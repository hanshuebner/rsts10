TITLE	ONLINE,<ON-LINE SUPPORT FOR RSTS/E INIT>,0A,10-MAY-91,ABC/SJK/WJS

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR ONLINE
;+
;
;  000  RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;
;				[RSTS V9.0]
;  001	WJS  26-Sep-83	Allow more than 15 phases
;
;-

.SBTTL	DEFINITIONS AND MACROS

.MCALL	..V1..

..V1..

.MCALL	.TTYOUT, .TTYIN, .READW, .WRITW, .LOOKUP, .CLOSE,.PRINT
.MCALL	.RCTRLO,.EXIT

; COMMON ASCII DEFINITIONS

.EQUATE	BELL	, 7
.EQUATE	TAB	, 11
.EQUATE	LF	, 12
.EQUATE	VT	, 13
.EQUATE	FF	, 14
.EQUATE	CR	, 15
.EQUATE	ESCAPE	, 33
.EQUATE	SPACE	, 40

.MACRO	I.MESS
.NLIST	BEX
	 TMPORG	TTYTXT
.ENDM	I.MESS

	TMPORG	OLHOOK		;HOOKS FOR ON-LINE DRIVERS
H.TYPE::.WORD	RTSPC		;HOOK FOR CHARACTER OUTPUT
H.ASK::	.WORD	RTSPC		;HOOK FOR QUESTION ASKER
H.GETI::.WORD	RTSPC		;HOOK FOR INPUT LINE GETTER
H.EXIT::.WORD	RTSPC		;HOOK FOR NORMAL EXIT
H.CTLC::.WORD	RTSPC		;HOOK FOR CTRL/C EXIT
H.LOKF::.WORD	RTSPC		;HOOK FOR LOKFIL CALL
H.LOKE::.WORD	RTSPC		;HOOK FOR LOKFIL COMPLETE
H.READ::.WORD	RTSPC		;HOOK FOR READ CALL
H.WRIT::.WORD	RTSPC		;HOOK FOR WRITE CALL
	UNORG

	DEFORG	ONLINE

.ENABL	LSB

MESSAG::MOV	R0,-(SP)	;TYPE A MESSAGE
	MOV	(R5)+,R0	;R0 -> MESSAGE
	CALL	ASCIZ0		;PRINT IT
	MOV	(SP)+,R0	;RESTORE R0
	RETURN	R5

ASCIZ0::MOV	R2,-(SP)
10$:	MOVB	(R0)+,R2	;NULL?
	BEQ	30$		;YES, END
	CALL	TYPE		;TYPE IT
	BR	10$

20$:	MOV	(R2),R2		;FOR SPECIAL TYPING, GET THE BYTES
	CALL	TYPE2		;DO THE TYPING (CALL TO 20$ SAVES R2)
30$:	MOV	(SP)+,R2	;RESTORE R2
	RETURN

RCTRLO::.RCTRLO			;RESET THE ^O FLAG
	RETURN			;DONE

TYPECR::CALL	20$,R2		;TYPE <CR><LF> STRING
	 .BYTE	CR,LF		;THIS IS IT

TYPE2::	CALL	TYPE		;TYPE ONE
	SWAB	R2		;GET THE OTHER
	BEQ	RTSPC		;NO SECOND CHARACTER!
TYPE::	CMPB	R2,#177		;RESET ^O HERE?
	BEQ	RCTRLO		;YUP, GO DO IT
	CMPB	R2,#200		;TYPE <CR><LF>?
	BEQ	TYPECR		;YES
	CALL	@H.TYPE		;** INTERCEPT ** R2=CHARACTER TO TYPE
	MOV	R0,-(SP)	;SAVE R0
	.TTYOUT	R2		;TYPE A CHARACTER
	MOV	(SP)+,R0	;RESTORE R0
RTSPC:	RETURN			;DONE

TYPTAB::CALL	20$,R2		;TYPE A TAB ONLY
	.BYTE	TAB,0

.DSABL	LSB

.SBTTL	QUESTION ASKER

;+
; ASKER - ASK A QUESTION AND GET AN ANSWER
;
;	CALL	ASKER,R5,<PTR TO SHORT TEXT, PTR TO LONG TEXT>
;
;	R1 -> ANSWER TEXT (ON WORD BOUNDARY)
;
;	Z=1, C=1 IFF ^Z TYPED
;	Z=1, C=0 IFF LINE FEED TYPED
;	Z=0, C=0 OTHERWISE
;
; NOTE:	TYPES SHORT TEXT, GETS ANSWER IN KBUFF.
;	IF ANSWER IS <CR> OR ?, TYPES LONG TEXT AND REPEATS
;-

ASKER::	CALL	@H.ASK		;** INTERCEPT ** ASKER CALL
	MOV	(R5)+,20$	;GET SHORT QUESTION FORM
10$:	CALL	RCTRLO		;FORCE RESET OF ^O
	CALL	MESSAG,R5	;TYPE A MESSAGE
20$:	 .WORD	0		;MESSAGE TEXT POINTER
	MOV	(R5),20$	;PRESET LONG FORM IN CASE HELP NEEDED
	CALL	GETIN		;AND GET AN ANSWER
	BEQ	10$		;HE NEEDS HELP
	TST	(R5)+		;POP OVER LONG FORM
	CMPB	(R1),#12	;LINE FEED?
	BEQ	40$		;YES -- RETURN Z=1, C=0
	CMPB	(R1),#'Z-100	;^Z?
	BEQ	30$		;YES -- RETURN Z=1, C=1
	TST	(PC)+		;NOTHING SPECIAL -- SET Z=0, C=0
30$:	SEC			;SET CARRY FOR ^Z
40$:	RETURN	R5		;EXIT

REGSAV::MOV	R4,-(SP)
	MOV	R3,-(SP)
	MOV	R2,-(SP)
	MOV	R1,-(SP)
	MOV	R0,-(SP)
	MOV	5*2(SP),-(SP)
	RETURN	R5

RESRPC::CALL	REGRES,R5
	RETURN

REGRES::MOV	(SP)+,R0	;REMOVE CALLING R5
	MOV	(SP)+,R0
	MOV	(SP)+,R1
	MOV	(SP)+,R2
	MOV	(SP)+,R3
	MOV	(SP)+,R4
	RETURN	R5

GETUNQ::MOV	(R5)+,R0	;GET MATCH TEXT POINTER IN R0
	REGSAV			;SAVE REGISTERS
	MOV	R1,R4		;COPY POINTER TO PASSED TEXT
	CLR	(SP)		;CLEAR RETURNED R0
10$:	MOV	R4,R1		;RESTORE POINTER TO PASSED TEXT
20$:	MOVB	(R0)+,R3	;GET MATCH TEXT CHARACTER
	BIC	#^C<177>,R3	;ISOLATE IT
	CMPB	R3,(R1)+	;COMPARE AGAINST PASSED TEXT
	BEQ	20$		;GOT IT?
	TSTB	-(R0)		;NO MATCH. IS MATCH TEXT CHARACTER OPTIONAL?
	BMI	40$		;YES, WE PROBABLY FOUND IT
30$:	CMPB	(R0)+,#377	;NO, SKIP TO END OF THIS MATCH STRING
	BNE	30$
	ADD	#2,(SP)		;NEXT INDEX
	TSTB	(R0)		;ANY MORE MATCH TEXT?
	BNE	10$		;YES, TRY AGAIN
	SEC			;NO, INDICATE FAILURE IN CARRY
35$:	CALL	REGRES,R5	;RESTORE REGISTERS
	RETURN	R5		;BACK

40$:	TSTB	-(R1)		;FOUND DISCREPANCY AT OPTIONAL CHARACTER
	BEQ	60$		;THAT WAS THE END OF THE PASSED STRING
	CMPB	(R1),#40	;IT WASN'T THE END, SO GOTTA BE A BLANK
	BNE	30$		;NO LUCK, NOT THIS MATCH TEXT
50$:	CMPB	(R1)+,(R1)	;SCAN PAST N BLANKS
	BEQ	50$		;UNTIL R1 -> NOT A BLANK
60$:	MOVB	(R1)+,(R4)+	;MOVE THE REST OF THE STRING DOWN
	BNE	60$		;UNTIL END OF ASCIZ
	CLC			;C=0 FOR SUCCESS
	BR	35$		;GO BACK TO THE CALLER

.SBTTL	ANSWER CHECKER

;+
; ANSWER - CHECK AN ANSWER FOR Y, N, <LF>, O, OR OTHER
;
;	R1 -> ANSWER TO CHECK
;
;	CALL	ANSWER,R5
;
;	 RETURN+0 - 'Y' RETURN
;	 RETURN+2 - 'N' RETURN
;	 RETURN+4 - LF  RETURN
;	 RETURN+6 - 'O' RETURN
;	 RETURN+10- OTHER
;-

ANSWER::MOV	R0,-(SP)	;SAVE R0
	CALLX	GETUNQ,R5	;PARSE THE ANSWER
	 GENTXT
	 UNQTXT	<Y\ES>		;0 YES
	 UNQTXT	<N\O>		;2 NO
	 .BYTE	12,377		;4 <LF>
	 UNQTXT	<O\LD>		;6 OLD
	 .BYTE	0		;10 OTHER
	 UNORG
	ADD	R0,R5		;BUMP RETURN ADDRESS PROPERLY
	MOV	(SP)+,R0	;RESTORE R0
	;CLC			;C=0 FROM 'ADD' ABOVE
	RETURN	R5

.SBTTL	YES/NO CHECKER

;+
; YESNO - CHECK REPLY FOR YES OR NO
;
;	R1 -> STRING TO CHECK
;
;	CALL	YESNO,R5,<PTR TO SHORT TEXT, PTR TO LONG TEXT>
;
;	 RETURN+0 - ^Z  FOUND
;	 RETURN+2 - LF  FOUND
;	 RETURN+4 - 'N' FOUND
;	 RETURN+6 - 'Y' FOUND
;-

.ENABL	LSB

YESNO::	MOV	(R5)+,20$	;GET TEXT POINTERS
	MOV	(R5)+,30$
10$:	CALL	ASKER,R5	;ASK THE QUESTION
20$:	 .WORD	0
30$:	 .WORD	0
	BCS	50$		;^Z -- RETURN +0
	CALL	ANSWER,R5	;CHECK THE ANSWER
	 TST	(R5)+		;YES -- RETURN +6
	 TST	(R5)+		;NO -- RETURN +4
	 BR	40$		;LF -- RETURN +2
	 NOP			;OLD  ??
	MESSAG	<"Please answer 'YES' or 'NO'."<200>>
	BR	10$

40$:	TST	(R5)+
50$:	RETURN	R5

.DSABL	LSB

.SBTTL	INPUT A LINE

GETIN::	CALL	@H.GETI		;** INTERCEPT ** GETIN GET INPUT LINE
	REGSAV
	CALLX	INPLIN,R5,<KBUFF>
	MOV	R5,TOS.R1(SP)	;RETURN TO CALLER IN R1
	CMPB	(R5),#CR	;PURE <CR>?
	BNE	10$		;NO
	CLR	(R5)		;YES, NULL IT OUT
10$:	CMP	(R5),#LF	;PURE LINE FEED?
	BEQ	20$		;YUP, RETURN LINE FEED
	MOV	#1+4+10+20+40+200+1000,R0
	CALLX	CVT$$
20$:	CMP	(R5),#"^Z	;FAKE CTRL/Z?
	BNE	30$		;NO
	MOV	#'Z-100,(R5)
30$:	CALLX	EQU$$,R4,70$	;CHECK FOR <LF>
	BNE	40$		;NOPE
	MOV	#12,KBUFF	;YES, RESET TO TRUE LINE FEED
40$:	CALLX	REGRES,R5	;RESTORE REGISTERS
	CMP	(R1),#"^C	;CONTROL C?
	BEQ	60$		;YES, TIME TO GO AWAY
	CMPB	(R1),#'?	;QUESTION MARK?
	BEQ	50$		;YES, RETURN Z=1 (AND C=0)
	TSTB	(R1)		;NO, CHECK OUT <CR> ONLY (AND C=0)
50$:	RETURN

60$:	CALL	@H.CTLC		;** INTERCEPT ** EXIT DUE TO CTRL/C TYPED
	.EXIT

70$:	.ASCIZ	"<LF>"
	.EVEN

KBUFF::	.BLKB	100.

.SBTTL	WAIT FOR TTY TO STOP

;+
; TTYSTP - WAIT FOR TTY TO STOP
;
;	CALL	TTYSTP
;
;	TTY IS DONE TYPING
;	DESTROYS R2
;-

GETTTY::
TTYSTP::RETURN			;YES

.SBTTL	OCTAL PRINTERS

;+
; OCTWRD - PRINT AN OCTAL NUMBER (6 DIGITS)
; OCTBYT - PRINT AN OCTAL BYTE (3 DIGITS)
; OCT3DG - PRINT 3-DIGIT OCTAL NUMBER
; OCT4DG - PRINT 4-DIGIT OCTAL NUMBER
;
;	R0 =  NUMBER TO PRINT
;
;	CALL	OCT???
;-

.ENABL	LSB

OCTWRD::REGSCR			;SAVE REGS
	MOV	#6,R1		;COUNT IS 6
	BR	20$		;DO IT

OCT4DG::REGSCR			;SAVE REGISTERS
	MOV	#4,R1		;PRINT LOW 4 DIGITS
	BR	20$

OCT3DG::REGSCR			;SAVE REGS
	BR	10$		;AND DO 3 DIGITS

OCTBYT::REGSCR			;SAVE REGS
	BIC	#^C<377>,R0	;CLEAR OTHER BITS
10$:	MOV	#3,R1		;COUNT IS 3
20$:	MOV	#-1,-(SP)	;SET STOPPER FLAG
30$:	MOV	R0,-(SP)	;MOVE BITS TO STACK
	BIC	#^C<7>,(SP)	;ISOLATE BOTTOM OCTAL DIGIT
	ADD	#'0,(SP)	;MAKE IT ASCII
	;CLC			;ADD CLEARS THE CARRY
	ROR	R0		;SHIFT RIGHT 3 BITS
	ASR	R0
	ASR	R0
	SOB	R1,30$		;CONTINUE FOR ALL DIGITS
40$:	MOV	(SP)+,R2	;GET A DIGIT
	BMI	50$		;DONE
	CALL	TYPE		;TYPE IT
	BR	40$		;CONTINUE

50$:	RETURN

.DSABL	LSB

.SBTTL	DECIMAL PRINTERS

;+
; DBLPRT - PRINT DOUBLE-PREC NUMBER IN DECIMAL, BLANK FILL
; DBLZER - PRINT DOUBLE-PREC NUMBER IN DECIMAL, NO BLANKS
;
;	R2 = NUMBER TO PRINT (LSB)
;	R3 = NUMBER TO PRINT (MSB)
;
;	CALL	DBL???
;-

.ENABL	LSB

DBLPRT::REGSCR			;SAVE REGISTERS
	MOV	#6,R5		;PRINT INTO A COLUMN 6 SPACES WIDE
	BR	10$

DBLZER::REGSCR			;SAVE REGISTERS
	CLR	R5		;DON'T ADD ANY LEADING SPACES
10$:	MOV	R2,R1		;MOVE LSB TO WHERE WE CAN WORK ON IT
	BR	30$

;+
; DECPRT - PRINT NUMBER IN DECIMAL WITH LEADING BLANKS
; DECZER - PRINT NUMBER IN DECIMAL, BLANK SUPPRESSED
; P4DDIG - PRINT 4-DIGIT NUMBER IN DECIMAL, BLANK FILL
;
;	R0 = NUMBER TO PRINT
;
;	CALL	DEC???
;-

DECPRT::REGSCR			;SAVE REGISTERS
	MOV	#6,R5		;PRINT INTO A COLUMN 6 SPACES WIDE
	BR	20$

P4DDIG::REGSCR			;SAVE REGISTERS
	MOV	#4,R5		;PRINT INTO A COLUMN 4 SPACES WIDE
	BR	20$

DECZER::REGSCR			;SAVE REGISTERS
	CLR	R5		;DON'T ADD ANY LEADING SPACES
20$:	CLR	R3		;MSB ARGUMENT IS ZERO
	MOV	R0,R1		;MOVE LSB TO WHERE WE CAN WORK ON IT

; R1 = LSB OF NUMBER TO BE PRINTED
; R3 = MSB OF NUMBER TO BE PRINTED
; R5 = MINIMUM WIDTH OF COLUMN TO PRINT
;
; DIVIDE THE NUMBER BY 10 (AT LEAST ONCE) UNTIL THE QUOTIENT IS ZERO,
; AND PUSH THE REMAINDERS ON THE STACK.  THESE ARE THE DIGITS OF THE
; NUMBER'S DECIMAL REPRESENTATION, FROM RIGHT TO LEFT.
; R4 WILL COUNT THE DIGITS PUSHED.

30$:	CLR	R4		;NO DIGITS PUSHED YET
40$:	CLR	R2		;DIVIDE UNSIGNED SINGLE WORD MSB
	DIV	#10.,R2		;IN R3, BY 10.  Q -> R2, R -> R3
	MOV	R3,R0		;REMAINDER < 10 IS HIGH WORD FOR NEXT DIV
	MOV	R2,R3		;QUOTIENT IS USED NEXT TIME THRU LOOP
	DIV	#10.,R0		;DIVIDE LSB BY 10. Q -> R0, R -> R1
	MOV	R1,-(SP)	;PUSH THE REMAINDER (IT'S A DIGIT)
	INC	R4		;COUNT DIGITS PUSHED
	MOV	R0,R1		;QUOTIENT IS USED NEXT TIME THRU LOOP
	BIS	R3,R0		;IS ENTIRE NUMBER NOW ZERO?
	BNE	40$		;REPEAT UNTIL IT IS ZERO
	SUB	R4,R5		;WIDTH - DIGITS => NUMBER OF LEADING BLANKS
	BLOS	60$		;NO SPACES IF DIGITS >= COLUMN SIZE
	MOV	#SPACE,R2
50$:	CALL	TYPE		;TYPE SPACES
	SOB	R5,50$		;REPEATEDLY

; UNSTACK AND PRINT THE DIGITS (WE KNOW THERE'S AT LEAST ONE)

60$:	MOV	(SP)+,R2	;UNSTACK A DIGIT
	ADD	#'0,R2		;MAKE ASCII
	CALL	TYPE		;PRINT IT
	SOB	R4,60$		;REPEAT
	RETURN

.DSABL	LSB

.SBTTL	PRINT FILE NAME

;+
; TYPFIL - PRINT FILE NAME FROM FIRQB
;
;	R4 -> FIRQB
;
;	CALL	TYPFIL
;-

.ENABL	LSB

TYPFIL::REGSCR			;SAVE REGISTERS
	ADD	#FQNAM1,R4	;POINT TO NAME
	MOV	(R4)+,R0	;GET NAME PART 1
	CALL	10$		;PRINT IT
	MOV	(R4)+,R0	;NAME PART 2
	CALL	10$		;PRINT IT
	MESSAGE	<".">		;DOT
	MOV	(R4)+,R0	;EXTENSION
	BR	10$		;PRINT IT AND RETURN

.SBTTL	RAD50 PRINTERS

;+
; RADPRT - PRINT RAD50 WORD
; RADZER - PRINT RAD50 WORD W/ BLANKS SUPPRESSED
;
;	R0 =  RAD50 WORD
;
;	CALL	RAD???
;-

RADPRT::REGSCR			;SAVE REGISTERS
	MOV	#SPACE,R5	;FILLER IS SPACE FOR 0
	BR	20$

RADZER::REGSCR			;SAVE REGISTERS
10$:	CLR	R5		;SUPPRESS SPACES
20$:	MOV	#90$,R1		;POINT TO TABLE OF DIVISORS
	MOV	R0,R3		;COPY THE WORD TO PRINT
30$:	CLR	R2		;CLEAR FOR DIVIDE
	DIV	(R1)+,R2	;DIVIDE
	;TST	R2		;IS THE RESULT A SPACE? (FROM DIVIDE)
	BNE	40$		;NO
	MOV	R5,R2		;YES, MAKE IT BLANK (MAYBE)
	BEQ	70$		;NO, IGNORE NULLS
	BR	60$		;YES, PRINT IT

40$:	CMP	R2,#26.		;ALPHABETIC?
	BHI	50$		;NO
	ADD	#'A-1,R2	;YES, MAKE IT ASCII
	BR	60$		;AND TYPE IT

50$:	MOVB	80$-27.(R2),R2	;GET SPECIAL CHARACTER OR DIGIT
60$:	CALL	TYPE		;TYPE IT AND RETURN
70$:	TST	(R1)		;ANY MORE TO DO?
	BNE	30$		;YES, LOOP ON IT
	RETURN

	I.MESS
80$:	.ASCII	"$.?0123456789"	;RAD50 TRANSLATION FOR 27.-39.
	UNORG

90$:	.WORD	50*50,50,1,0	;DIVISORS FOR RADIX 50 CONVERSION

.DSABL	LSB

.SBTTL	OCTAL & DECIMAL INPUTTERS

;+
; OCTINP - TRANSLATE AN OCTAL NUMBER
; DECINP - TRANSLATE A DECIMAL NUMBER
;
;	R1 -> STRING TO TRANSLATE
;
;	CALL ???INP
;
;	R0 = VALUE
;	R1 = UPDATED POINTER
;	CONDITION CODES SET FROM TSTB OF ENDING CHARACTER
;		(Z=1 MEANS NULL BYTE, USUALLY DESIRED)
;
;	SCAN STOPS ON CHARACTER ILLEGAL FOR SPECIFIED RADIX OR
;		IF OVERFLOW IS ENCOUNTERED
;-

OCTINP::TST	(PC)+		;CLEAR CARRY
DECINP::SEC			;SET CARRY
	REGSAV			;SAVE REGISTERS
	MOV	#4,R5		;R5 = RADIX/2
	ADC	R5		;10. IF ENTERED AT DECINP
	ASL	R5		;R5 = RADIX
	CLR	R3		;CLEAR THE ACCUMULATOR
10$:	MOVB	(R1)+,R0	;GET NEXT BYTE
	SUB	#'0,R0		;CONVERT FROM ASCII
	CMP	R0,R5		;CHECK AGAINST RADIX
	BHIS	20$		;TOO BIG TO BE A DIGIT
	MOV	R3,R2		;PUT OLD VALUE WHERE WE CAN MULTIPLY
	MUL	R5,R2		;PRODUCT MSB -> R2, LSB -> R3
	TST	R2		;DID ANY HIGH-ORDER BITS COME ON?
	BNE	20$		;YES -- UNSIGNED OVERFLOW
	ADD	R0,R3		;ADD IN NEW DIGIT
	BCC	10$		;GOOD, GO FOR ANOTHER BYTE
20$:	MOV	R3,TOS.R0(SP)	;RETURN VALUE IN R0
INPDNE:	MOV	R1,TOS.R1(SP)	;RETURN UPDATED POINTER IN R1
	CALLX	REGRES,R5	;RESTORE REGISTERS
	TSTB	-(R1)		;POINT TO UNUSED CHAR, SET CONDITION CODES
	RETURN

.SBTTL	DOUBLE PRECISION DECIMAL INPUTTER

;+
; DBLINP - SCAN OFF A DOUBLE PRECISION DECIMAL NUMBER
;
;	R1 -> STRING TO SCAN
;
;	CALL DBLINP
;
;	R1 -> FIRST UNSCANNED BYTE
;	R2 =  VALUE (LSB)
;	R3 =  VALUE (MSB)
;	CONDITION CODES SET FROM TSTB OF ENDING CHARACTER
;		(Z=1 MEANS NULL BYTE, USUALLY DESIRED)
;
;	SCAN STOPS ON CHARACTER ILLEGAL FOR SPECIFIED RADIX OR
;		IF OVERFLOW IS ENCOUNTERED
;-

DBLINP::REGSAV			;SAVE REGISTERS
	CLR	R2		;CLEAR ACCUMULATOR
	CLR	R3
	CLR	-(SP)		;ALLOCATE SPACE FOR DIGIT
10$:	MOVB	(R1)+,(SP)	;GET A DIGIT
	SUB	#'0,(SP)	;REDUCE ASCII DIGITS TO RANGE 0-9
	MOV	#9.,R0		;SET COUNTER FOR ADD LOOP BELOW
	CMP	(SP),R0		;IS THE CHARACTER LEGAL?
	BHI	30$		;NO -- RETURN
	MOV	R3,R5		;COPY PARTIAL RESULT FOR ADDING
	MOV	R2,R4
20$:	ADD	R4,R2		;ADD LSB
	ADC	R3
	BCS	30$		;SKIP OUT ON UNSIGNED OVERFLOW
	ADD	R5,R3		;ADD MSB
	BCS	30$		;SKIP OUT ON UNSIGNED OVERFLOW
	SOB	R0,20$		;ADD 9 TIMES TO MAKE 10X TOTAL
	ADD	(SP),R2		;ADD THE DIGIT
	ADC	R3
	BCC	10$		;GET THE NEXT DIGIT
30$:	TST	(SP)+		;REMOVE TEMP SPACE FROM STACK
	MOV	R2,TOS.R2(SP)	;SAVE ON STACK TO RETURN IN REGISTERS
	MOV	R3,TOS.R3(SP)
	BR	INPDNE		;GO RETURN PROPERLY

.SBTTL	RAD50 INPUTTER

;+
; RADINP - SCAN AND CONVERT 2 WORDS OF RADIX 50
; RADWRD - SCAN AND CONVERT 1 WORD  OF RADIX 50
;
;	R1 -> STRING TO SCAN
;
;	CALL	RAD???
;
;	R0 =  FIRST 3 CHARACTERS
;	R1 -> FIRST UNSCANNED CHARACTER
;	R3 =  NEXT 3 CHARACTERS IFF RADINP
;
;	SCAN STOPS AT FIRST NON-RAD50 CHARACTER OR AFTER 3 (OR 6)
;		CHARACTERS HAVE BEEN SCANNED
;	ONLY LETTERS AND DIGITS ARE ALLOWED
;-

.ENABL	LSB

RADINP::REGSCR			;SAVE REGISTERS
	CALL	RADWRD		;GET A WORD
	MOV	R0,TOS.R0(SP)	;RETURN IT IN R0 ON EXIT
	CALL	RADWRD		;GET ANUDDER
	MOV	R0,TOS.R3(SP)	;RETURN IT IN R3 ON EXIT
	BR	10$		;AND EXIT

RADWRD::REGSCR			;SAVE REGISTERS
	CLR	R3		;CLEAR RETURN VALUE
	MOV	#20$,R5		;A HANDY POINTER
	CALL	(R5)		;GET 3 CHARACTERS
	CALL	(R5)
	CALL	(R5)
	MOV	R3,TOS.R0(SP)	;RETURN ANSWER IN R0 ON EXIT
10$:	MOV	R1,TOS.R1(SP)	;UPDATE R1
	RETURN

; SUBROUTINE TO INPUT A SINGLE RAD50 CHARACTER, AND ADD IT TO
; THE WORD IN R3.  AFTER FINDING A NON-RAD50 CHARACTER, THE
; SUBROUTINE ADDS SPACES WHEN IT IS CALLED.

20$:	MOVB	(R1)+,R0	;GET A CHARACTER
	SUB	#'0,R0		;REDUCE DIGITS TO RANGE 0-9
	CMP	R0,#9.		;IS THIS ONE?
	BHI	30$		;NO -- IT MUST BE A LETTER
	ADD	#30.,R0		;YES -- RAD50 DIGITS ARE 30.-39.
	BR	50$		;GO ACCUMULATE

30$:	ADD	#'0-'A+1,R0	;REDUCE LETTERS TO RANGE 1-26.
	BEQ	40$		;ZERO IS ILLEGAL
	CMP	R0,#26.		;IS THIS A LETTER?
	BLOS	50$		;YES -- GO ACCUMULATE

40$:	DEC	R1		;LEAVE R1 POINTING AT THE BAD CHARACTER
	CLR	R0		;AND USE A SPACE INSTEAD
50$:	MUL	#50,R3		;'SHIFT LEFT' THE OLD VALUE
	ADD	R0,R3		;AND ADD IN THE NEW CHARACTER
	RETURN			;EXIT

.DSABL	LSB

.SBTTL	LOOK FOR A FILE

LOKFIL::CALL	@H.LOKF		;** INTERCEPT ** LOOKUP FILE
	REGSCR			;SAVE REGISTERS
	.CLOSE	16
	MOV	#LOKFNM,R0	;POINT TO AREA FOR FILE NAME
	ADD	#FQNAM1,R4	;R4 -> NAME
	MOV	(R4)+,(R0)+
	MOV	(R4)+,(R0)+
	MOV	(R4)+,(R0)+
	MOV	#LOKPPN,R0	;POINT TO FILESPEC AND PPN
	MOV	(R0)+,@SYSPTR	;SET PPN DESIRED
	BNE	10$		;IF PRESENT, USE IT
	EMT	377		;IF NOT, GET OUR OWN
	.STAT			; PPN FROM THE MONITOR
	MOV	XRB+10,@SYSPTR	;  AND USE THAT
10$:	.LOOKUP	16		;FIND THE FILE
	BCC	20$		;GOT IT
	MOV	#LOKPPN,R0	;POINT TO FILESPEC AND PPN
	TST	(R0)+		;WAS THERE AN EXPLICIT PPN?
	SEC			;PRESET CARRY IF SO
	BNE	30$		;YUP, FAIL NOW
	MOV	#0*400+1,@SYSPTR;NO, TRY [0,1]
	.LOOKUP	16		;TRY CURRENT ACCOUNT
	BCS	30$		;NO DICE
20$:	MOV	R0,FQFCB+FCSIZ-<FQNAM1+6>(R4) ;SET UP THE LENGTH
	BIS	#FS.OPN,FQSTAT-<FQNAM1+6>(R4) ;MARK IT OPEN
	CALL	@H.LOKE		;** INTERCEPT ** FILE OPENED
	CLC			;ENSURE C=0
30$:	RETURN

LOKPPN::.WORD	0		;PPN TO TRY FOR LOOKUP
LOKDEV::.RAD50	/DK /
LOKFNM::.WORD	0,0,0

.SBTTL	READ AND WRITE

.ENABL	LSB

READ.::	CMP	R0,#256.		; A one-block read ?		;001
	BNE	5$			; No => can't cache it, then	;001
	CALL	@H.READ		;** INTERCEPT ** READ BLOCK
5$:	REGSAV			;SAVE REGISTERS				;001
	MOV	R0,R2		;COPY COUNT
	.READW	16,(R5)+,R2,FCNVB(R1) ;DO THE READ
10$:	BCS	20$		;ERROR ABORTS
	MOV	R5,TOS.R5(SP)
	CALLX	REGRES,R5
	RETURN	R5

20$:	.PRINT	#30$
	EMT	350

30$:	.ASCIZ	"I/O ERROR !!!"
	.EVEN

WRITE.::CALL	@H.WRIT		;** INTERCEPT ** WRITE BLOCK
	REGSAV
	MOV	R0,R2
	.WRITW	16,(R5)+,R2,FCNVB(R1) ;DO THE WRITE
	BR	10$		;CHECK FOR ERRORS

.DSABL	LSB

.SBTTL	Root faker

I.INI0::
I.INIT::CALL	@H.EXIT		;** INTERCEPT ** NORMAL PROGRAM EXIT
	.EXIT


.SBTTL	Fake data

FQ...::	.WORD	0,0,0,1,0,0,0
	.BLKW0	17.
FC...::	.BLKW0	FCBSIZ/2

I.STAK	==	1000

SILBUF::.BLKB	SI.SIZ						;001

FIBUF::	.BLKW0	256.
FIBMAP	==	FIBUF+760
FIBENT	==	FIBUF+762
FIBEND	==	FIBUF+1000

SILNAM::.WORD	0,0

CTLOFG::.WORD	0

.END

