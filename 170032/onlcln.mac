.TITLE	ONLCLN,<ON-LINE DRIVER FOR CLEAN>,01,08-FEB-87,ABC/SHG/GPK/SDL/FEK/FRL/KMF/BGN

;
;		COPYRIGHT (c) 1974, 1987 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR ONLCLN

;+
;
;  000  RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;
;				[RSTS V8.0]
;  000	GPK  08-Sep-82	Changes for new file structure
;  001	GPK  05-Oct-82	Change terminology to "rebuild"
;  002  SDL  04-Oct-82  Added code to handle interface by DCL disk MOUNT 
;  003  SDL  23-Nov-82  Moved FIBUF buffer to root module MTDSMT
;  004	FEK  13-Jan-83	Correct RP04/5/6 size checks
;  005	GPK  16-Feb-83	Add SILBUF, add check for mounted disk
;  006	GPK  17-Feb-83	Make PARSEX honor its arguments
;
;				[RSTS V9.0]
;  007  FRL  06-Sep-83  Made RSX compatible
;  008  FRL  04-Jan-84  Now checks max size returned by .STAT 
;  009  KMF  05-Jan-84	Update for 8-bit compatability (unset parity bit)  
;  010  FRL  11-Jan-85  Follow conventions for errors and warnings
;  011  FRL  15-Mar-85  Exit on CTRL-Z
;  012  BGN  16-Jan-87  Allow for unit numbers larger than 7
;
;				[RSTS V9.5]
;  013	PJH  09-Jul-87	Add large disk support.  Change cluster I/O to
;			block mode I/O.
;  014  BGN   5-Aug-87	Fatal: routine did not pop PS off the stack
;
;				[RSTS V9.7]
;  015	JRM  18-Jan-89	Add "/D" switch.
;
;				[RSTS V10.0]
;  016	FEK  26-Jun-90	Allow DCS 64 to work.
;
;				[RSTS V10.1]
;  017	FEK  30-Dec-91	Allow clean/remount of system disk
;-

.SBTTL	DEFINING CSECT'S

	DEFORG	ONLCTL

CHELST:	.WORD	0
CHEHED:

FRELST:	.WORD	0

BITBYT::.BYTE	1,2,4,10,20,40,100,200,0,0

IMGTOP:	.LIMIT			;Beginning of cache is the top of the image ;007
ECACHE:	.WORD	0							;007
I.DSQ	== .-DSQCNT
;DSQCNT:
	.WORD	0

MFDDCN:	.WORD	1		;Starting DCN of MFD			;000
CLNDBG::.WORD	0		;Debug flag				;015
PATCH::	.BLKW	30.		; add some patch space in case		;016

	DEFORG	SATBUF

SATBUF::.BLKB	1000*16.
SILBUF::.BLKB	1000		;Yet another buffer			;005

	DEFORG	BUFFR2

S2TBUF:	.BLKB	1000*16.

	DEFORG	ONLTXT
	DEFORG	OLHOOK
	DEFORG	ONLINE
	DEFORG	TTYTXT
	DEFORG	ONLCLN
	ORG	CLN
	ORG	CLNTXT
	ORG	CLNCTL
	ORG	CLNPAT
	ORG	.99ODT		;For ODT				;000
	ORG	.99999		;Likewise				;000


	ORG	ONLCLN

.SBTTL	MACROS


.MACRO	I.MESS
	TMPORG	ONLTXT
.NLIST	BEX
.ENDM	I.MESS

.MACRO	X.READ	CHN,BUF,CNT,FBL,FBM	;CNT is buffer length in words	;013
.NLIST								;007
	CALLX	CLRXRB						;007
	ASL	CNT		;Change to bytes		;007
	MOVB	#2*CHN,XRB+XRCI	;Channel number*2		;007
	MOV	BUF,XRB+XRLOC	;Buffer address			;007
	MOV	CNT,XRB+XRLEN	;Buffer length in bytes		;007
	MOVB	FBM,XRB+XRBLKM	;MSB Block number		;013
	MOV	FBL,XRB+XRBLK	;LSB Block number		;013
	.READ							;007
	ASR	CNT		;Reset to words			;007
.LIST								;007
.ENDM								;007
	
.MACRO	X.WRIT	CHN,BUF,CNT,FBL,FBM				;013
.NLIST								;007
	CALLX 	CLRXRB						;007
	ASL	CNT		;Change to bytes		;007
	MOVB	#2*CHN,XRB+XRCI	;Channel number*2		;007
	MOV	BUF,XRB+XRLOC	;Buffer address			;007
	MOV	CNT,XRB+XRLEN	;Buffer length in bytes		;007
	MOV	CNT,XRB+XRBC	;No. of bytes to write		;007
	MOVB	FBM,XRB+XRBLKM	;MSB Block number		;013
	MOV	FBL,XRB+XRBLK	;LSB Block number		;013
	.WRITE							;007
	ASR	CNT		;Reset to words			;007
.LIST								;007
.ENDM								;007

.MACRO	X.ERPT			;R0 must hold error code
.NLIST
	CALLX	CLRFQB							;007
	MOVB	#ERRFQ,FIRQB+FQFUN;Set function code for error return	;007
	MOVB	R0,FIRQB+FQERNO	;Error code				;007
	CALFIP			;Get error message			;007
	MOV	#FIRQB+FQFIL,R0	;R0 -> error message			;007
	CALL	RCTRLO		;Reset ^O 				;007
	CALL	ASCIZ0		;Print error message			;007
.LIST
.ENDM

	
.MCALL	SVTK$S,EXIT$S							;007


.SBTTL	INITIALIZATION

.ENABL	LSB

ONLCLN::BIT	#JFPRIV,KEY	;IS THE USER PRIVILEGED ?		;002
	BNE	3$		;YES,3$					;002
	MESSAGE <"?You must be privileged to rebuild the disk"<200>> ;	;002
				;NO,ERROR THE USER OFF			;002
	JMP	LEAVE		;Exit					;007
3$:	CALLX	CLRFQB		;Clear FIRQB				;007
	MOVB	#RSTFQ,FIRQB+FQFUN ;Set function code to reset channels ;007
	CALFIP			;Close channels				;007
ONLCL2::.STAT			;Reset XRB with job statistics (THIS IS THE ;007
 				;   ENTRY POINT FOR A DCL DISK MOUNT TO ;007
				;   TO AVOID CLOSING CHANNELS)		;007
	MOVB	XRB+XRCI,R0	;Maximum job image size possible	;007
	CMP	R0,#32.		;Reasonable?				;008
	BLOS	5$		;Yes, go on				;008
	MOV	#32.,R0		;No, make it reasonable			;008
5$:	CALLX	CLRXRB		;Clear the XRB				;008
	MOVB	R0,XRB+XRLEN	;Set for maximum size			;007
	.CORE			;Allocate size				;007
	TSTB	FIRQB		;Error?					;008
	BEQ	7$		;No, go on				;008
	MOVB	FIRQB,R0	;Yes, get the error			;008
	X.ERPT			;Print it				;008
	MESSAGE	<<200>>		;New line				;007
	JMP	LEAVE		;Exit					;008

7$:	ASH	#11.,R0		;Determine top of memory		;008
	SUB	#2,R0							;007
	MOV  	R0,ECACHE	;Save this as end of cache		;007
	SVTK$S	#SSTTBL,#8.	;Set up TRAP trap handler for ERF	;007
	BIT	#16384.,@#30	;TEST THE PARAMETER WORD IN LOW CORE TO SEE ;002
				;  IF DCL INVOKED ONLCLN		;002
	BNE	13$		;WAS IT A DCL DISK MOUNT ?		;002
				;YES,13$ (TO AVOID DIALOG SINCE THE USER ALREADY ;002
				;	  SPECIFIED A DEVICE NAME ON MOUNT COMMAND) ;002
	CALLX	ASKER,R5	;NO - (WE WERE INVOKED THRU 'RUN $ONLCLN' BY ;002
				;      A PRIVILEGED USER)		;002
				;ASK FOR DISK TO CLEAN			;002
	 .WORD	10$		;SHORT TEXT
	 GENTXT			;LONG TEXT
	 .ASCII	"Type the name of the disk to rebuild."<200>		;001
	 .ASCII	"The disk must be physically but not logically mounted."<200>
10$:	 .ASCIZ	<177><12>"Disk? "
	 UNORG
	BCS	57$		;Ctrl-Z? then leave			;011
13$:	MOV	R1,R5		;COPY TEXT POINTER			;002
	CMPB	(R1),#'R	;DISK NAME WITH AN 'R' ?
	BNE	20$		;NO
	MOVB	#'D,(R1)	;YES, FIX IT
20$:	TSTB	(R5)+		;SCAN TO THE END
	BNE	20$
	CLR	CLNDBG		; Clear debug mode flag			;015
	DEC	R5		;Check for				;015
	CMPB	-(R5), #'D	; a "D" ?				;015
	BNE	23$		; Nope					;015
	CMPB	-1(R5), #'/	; a "/" ?				;015
	BNE	23$		; Nope					;015
	CLRB	-(R5)		; Yep,  remove it			;015
	COM	CLNDBG		; Set switch flag			;015
	DEC	R5		;Check for				;015
23$:	CMPB	(R5),#':	; trailing colon			;015
	BNE	30$		;NONE
	CLRB	(R5)		;REMOVE IT
30$:	MOV	#DSKNAM,R5	;POINT TO TABLE OF VALID DISK NAMES
40$:	CMP	(R1),(R5)+	;IS THIS IT?
	BEQ	60$		;YUP
	TST	(R5)		;NO, ANY MORE TO CHECK?
	BNE	40$		;YES, DO SO
50$:	MESSAGE	<"?Illegal disk name"<200>>				;010
55$:	BIT	#16384.,@#30	;DID A DCL MOUNT INVOKE ONLCLN ?	;002
	BEQ	ONLCLN		;NO,SO TRY AGAIN			;002
57$:	JMP	220$		;YES, SO EXIT WITHOUT TRYING AGAIN	;011

60$:	SUB	#DSKNAM+2,R5	;COMPUTE DISK INDEX
	MOV	R5,@#SYSNDX	;STORE DISK INDEX			;004
	MOV	DSKNAM(R5),DEVNAM ;SAVE DISK NAME (D?0:) 		;007
80$:	MOV	(R1)+,R4	;POP R1, SET R4<>0
	CLR	R0		;SET DISK UNIT TO 0
	TSTB	(R1)		;END OF STRING?
	BNE	100$		;NO, GO PARSE THE UNIT NUMBER
	CMP	R5,#IDX$DF	;YES, UNIT # NOT GIVEN.  HAVE UNITS?	;000
	BEQ	140$		;NO, USE UNIT 0 WITHOUT ASKING		;000
	CLR	R4		;FLAG FOR UNIT FROM UNIT QUESTION
90$:	CALLX	ASKER,R5	;ASK FOR A UNIT
	 GENTXT	<"Unit? ">
	 GENTXT	<"Physical unit number (0-15)? ">			;012
	BCS	133$		;Ctrl-Z? then leave			;011
100$:	CALLX	DECINP		;PARSE UNIT NUMBER
110$:	TSTB	(R1)		;END OF STRING?
	BNE	130$		;NO, ERROR IN UNIT NUMBER
	MOV	#15.,R1		;MAX UNIT IS 15				;012
	CMP	R5,#IDX$DF	; UNLESS RF (AND UNIT NUMBER GIVEN)	;000
	BNE	120$		;  (NO)					;000
	CLR	R1		;  IN WHICH CASE MAX UNIT IS 0		;000
120$:	CMP	R0,R1		;TOO BIG?
	BLOS	140$		;IT'S OK
130$:	TST	R4		;UNIT NUMBER IN FIRST RESPONSE?
	BNE	50$		;YES, REPEAT THAT QUESTION
	MESSAGE	<"?Invalid unit number"<200>>				;010
	BIT	#16384.,@#30	;DID A DCL MOUNT INVOKE ONLCLN ?	;002
	BEQ	90$		;NO,SO TRY AGAIN			;002
133$:	JMP	220$		;YES, SO EXIT WITHOUT TRYING AGAIN	;011

70$:	MESSAGE	<"?Sorry, but that disk doesn't exist"<200>>		;010
	BR	55$		;Try again or exit			;002

135$:	MESSAGE	<"?Disk is already mounted"<200>>			;010
	BR	55$		;Try again or exit			;005

140$:	CALL	SYSCHK		;Check if SY0: clean/remount is OK	;017
	BCS	135$		; No, it isn't OK!			;017
	CALLX	CLRFQB		;Clear the FIRQB			;007
	NOP			;debugging				;013
	MOVB	#OPNFQ,FIRQB+FQFUN ;Set code to open file to get DCS	;007
	MOVB	#2*1,FIRQB+FQFIL   ;Set channel number*2		;007
	MOVB	#377,FIRQB+FQDEVN+1;Explicit unit number		;007
	MOV	R0,-(SP)	;save unit number			;013
	MOVB	R0,FIRQB+FQDEVN	;Unit number				;007
	MOV	DEVNAM,FIRQB+FQDEV ;Disk name				;007
	TST	SYSMNT		;Doing SY0:?				;017
	BEQ	145$		; No, so nothing special required	;017
	MOV	#OP$MOD+OP$WUF,FIRQB+FQMODE  ;Set write mounted disk 	;017
145$:	CALFIP	
	TSTB	FIRQB		;Check for errors			;007
	BNE	70$		;NO SUCH UNIT IN THIS MONITOR		;007
	BIT	#DDWLO,FIRQB+FQFLAG ;Read-only (i.e. mounted disk)?	;005
	BNE	135$		;Yes, that's an error			;005
	MOV	FIRQB+FQBUFL,R2	;GET BUFFER SIZE (= DCS*1000)
	ROR	R2		; /2 with no sign extend		;016
	ASH	#-8.,R2		;COMPUTE DCS FOR THIS DISK		;016
	MOV	R2,DCS		;SAVE DCS
	;COMPUTE NUMBER OF BLOCKS ON DISK AS DCS*NUMBER OF CLUSTERS  	;007
	CLR	R0		;CLEAR FOR SHIFT			;007
	MOV	FIRQB+FQSIZ,R1	;DISK SIZE IN CLUSTERS			;007
150$:	ASR	R2		;SHIFT DCS (COUNTER)			;007
	BCS	160$		;DONE					
	ASL	R1		;SHIFT 24-BIT FIELD OF LOW BYTE OF R0   ;007
	ROL	R0		;   AND ALL OF R1			;007
	BR	150$

160$:	MOV	R0,SYSSZM 	;SAVE HIGH ORDER SIZE	
	MOV	R1,SYSSZL 	;SAVE LOW ORDER SIZE		
	CALL	CHEINI		;INITIALIZE THE CACHE
	CALLX	CLRFQB		;clear the firqb			;013
	;MOVB	#CLSFQ,FIRQB+FQFUN ;Set function code for close 	;013
.ASSUME CLSFQ EQ 0							;013
	MOVB	#2*1,FIRQB+FQFIL;  Set channel number*2			;013
	CALFIP			;  Close it				;013
	TSTB	FIRQB		;Error?					;013
	BNE	70$		;Yes, so error out			;013
	CALLX	CLRFQB		;clear the firqb			;013
	MOVB	#OPNFQ,FIRQB+FQFUN ;Set code to open file in blk mode	;013
	MOVB	#2*1,FIRQB+FQFIL   ;Set channel number*2		;013
	MOVB	#377,FIRQB+FQDEVN+1;Explicit unit number		;013
	MOVB	(SP)+,FIRQB+FQDEVN	;Unit number			;013
	MOV	DEVNAM,FIRQB+FQDEV ;Disk name				;013
	MOV	#OP$MOD+OP$BLK,FIRQB+FQMODE  ;Set block mode I/O	;013
	TST	SYSMNT		;Cleaning SY0:?				;017
	BEQ	162$		; NO, so just go to it.			;017
	BIS	#OP$WUF,FIRQB+FQMODE ;Yes, write mounted disk mode	;017
162$:	CALFIP	
	TSTB	FIRQB		;Check for errors			;013
	BNE	70$		;NO SUCH UNIT IN THIS MONITOR		;013

	MOV	#1,MFDDCN	;Assume MFD starts at 1			;000
	CALL	READPL		;Read in the pack label			;000
	BIT	#20000,FIBUF+PSTAT ;New pack?				;000
	BEQ	165$		;No					;000
	MOV	FIBUF+MDCN,MFDDCN ;Yes, save MFD starting DCN		;000
165$:	MOV	FIBUF+PPCS,R3	;GET DISK PACK CLUSTER SIZE		;000
	MOV	R3,R4		;COPY PCS
	BEQ	170$		;PCS OF 0 IS ILLEGAL
	CMP	R4,#64.		;LEGAL PCS = 1,2,4,8,16,32,64		;013
	BHI	170$		;ERROR IF > 64.				;013
	DEC	R4		;MAKE A MASK
	BIT	R3,R4		;IS IT A POWER OF 2?
	BEQ	180$		;YES, PCS IS VALID
170$:	MESSAGE	<"?Pack cluster size is invalid"<200>>			;010
	BR	220$		;TRY AGAIN HERE

180$:	MOV	R3,PCS		;SAVE THE PACK CLUSTER SIZE
	CLR	R2		;CLEAR FOR DIVIDE
	DIV	DCS,R2		;COMPUTE PCS/DCS
	MOV	R2,CLURAT	;SAVE THE CLUSTER RATIO
	MOV	PCS,R5		;RESTORE THE PACK CLUSTER SIZE
	MOV	SYSSZL,R1	;GET DISK SIZE (LSB)
	MOV	SYSSZM,R0	;GET DISK SIZE (MSB)
	SUB	R5,R1		;SUBTRACT PCS BLOCKS USED IN CLU 0
	SBC	R0		; FROM THE DISK SIZE IN BLOCKS
190$:	ASR	R5		;DIVIDE SIZE BY PCS
	BCS	200$		;TIL CARRY SETS
	;CLC
	ROR	R0		;SHIFT SIZE RIGHT
	ROR	R1
	BR	190$		;HANG IN THERE

200$:	MOV	R1,SATSYS+BITS	;SAVE NUMBER OF PACK CLUSTERS
	CLR	R0		;SET UP FOR DIVIDE
	ADD	#7777,R1	;ROUND UP BY 4095 AND
	ADC	R0
	ASHC	#-12.,R0	; DIVIDE BY 4096. BITS PER BLOCK
	MOV	R1,SATSYN	;SAVE NUMBER OF BLOCKS WITH FREE CLUS
	CALL	FIXCLU		;ROUND UP TO NEAREST CLUSTER @PCS
	CMP	R1,#16.		;large disk fixup required?		;013
	BLOS	205$		;no, so continue			;013
	MOV	#16.,R1		;yes, set 16 as max			;013
205$:	MOV	R1,SATSYS+SEGS	;STORE  # BLOCKS IN SYS DISK SAT
	MUL	#512.,R1	;AT 512. BYTES PER BLOCK
	MOV	R1,SATSYS+BYTS	;GIVES # BYTES IN SYS DISK SAT
	MOV	#FQBADB,R4	;POINT TO FIRQB FOR BADB.SYS
	CALL	LOKFIL		;OPEN IT INTERNALLY
	BCC	210$		;GOT IT
	MESSAGE	<"?BADB.SYS not found - not a RSTS disk"<200>>		;010
	BR	220$		;TRY AGAIN

210$:	MOV	#FQSATT,R4	;POINT TO FIRQB FOR SATT.SYS
	CALL	LOKFIL		;OPEN IT INTERNALLY
	BCC	225$		;GOT IT, START THE CLEANING		;002
	MESSAGE	<"?SATT.SYS not found - not a RSTS disk"<200>>		;010
220$:	JMP	LEAVE		;Exit, dis-allow retries 		;007

225$:	CALL	GODOIT		;REBUILD THE DISK			;002
	BIT	#16384.,@#30	;TEST THE PARAMETER WORD IN LOW CORE TO	;002
				;  SEE IF DCL INVOKED ONLCLN		;002
	BEQ	220$		;WAS IT A DCL DISK MOUNT ?		;002
				;  NO,220$ (WE WERE INVOKED BY 'RUN $ONLCLN') ;002
				;YES,SO CLOSE THE CHANNEL SO WE CAN MOUNT THE ;002
				;  USER'S DISK ON IT NOW		;002
	CALLX	CLRFQB		;  Clear the FIRQB			;007
	;MOVB	#CLSFQ,FIRQB+FQFUN ;Set function code for close 	;007
.ASSUME CLSFQ EQ 0							;007
	MOVB	#2*1,FIRQB+FQFIL;  Set channel number*2			;007
	CALFIP			;  Close it				;007
	TSTB	FIRQB		;Error?					;007
	BNE	230$		;Yes-- 230$				;007
	TST	SYSMNT		; SY0: cleaning?			;017
	BNE	250$		; Yes, so cleanup is necessary		;017
	RETURN			;RETURN SINCE THE REBUILDING IS DONE AND ;002
				;  MOUNT THE DISK			;002

230$:	MOVB	FIRQB,R0	;Get the error				;007
	X.ERPT			;Print it				;007
	MESSAGE	<<200>>		;New line				;007
250$:	JMP	LEAVE		;Exit					;007

SSTTBL: .WORD	0,0,0,0,0,0	;SST vector table			;007
	.WORD	FATAL		;Vector for TRAP			;007
	.WORD	0							;007

GLOBAL	<FIBUF,SYSNDX,SYSMNT>						;017

.DSABL LSB

GODOIT:	CALL	READPL		;GET THE PACK LABEL INTO FIBUF		;000
	BIS	#UC.MNT,FIBUF+PSTAT ;SET DISK DIRTY DURING CLEAN	;000
	CLR	FIBUF+WHOCLN	;ONLCLN can only do it once		;017
	CALL	WRITE		;MARK IT IN THE CACHE			
	CALL	CHEFLS		;FLUSH THE CACHE TO REWRITE THE PACK LABEL
	CALLX	CLEAN		;DO THE CLEAN
	CALL	READPL		;GET THE PACK LABEL BACK		;000
	BIS	#UC.MNT,FIBUF+PSTAT ;IT REALLY IS DIRTY UNTIL THE CACHE IS FLUSHED ;000
	CALL	WRITE		;PUT THE DIRTY BIT IN THE CACHE
	CALL	CHEFLS		;FLUSH THE CACHE OF EVERYTHING
	CALL	READPL		;GET THE PACK LABEL ONCE MORE (FROM CACHE) ;000
	BIC	#UC.MNT,FIBUF+PSTAT ;IT REALLY IS CLEAN NOW		;000
	CALL	WRITE		;PUT THE CLEAN BIT INTO THE CACHE
	CALL	CHEFLS		;FLUSH THE CACHE A FINAL TIME
	RETURN			;T-T-T-T-T-THATS ALL FOLKS!		;002

GLOBAL	<FIBUF>								;003

.SBTTL	Verify/setup SY0: cleaning conditions

;+									;017
;	The system disk can be cleaned online when this is the ONLY	;017
;	job running on the system.  To make sure it happens only at	;017
;	startup, there is the additional requirement that it be done	;017
;	only by job 1.  We must also make sure that the disks is in	;017
;	the right state.  This means we must verify that the disk was	;017
;	mounted at startup (RO, DIRTY, PRI).  If this is true, then	;017
;	we POKE memory to make it RW, and CLEAN.  But, to make it safe,	;017
;	we disable ^Cs.  With ^C disabled, we continue with the clean	;017
;	operation (remember, the disk looks clean and r/w).  When we	;017
;	are done, we reset the state to RO, but leave it clean.		;017
;-									;017

SYSCHK:	TST	SYSMNT		;Is it even an SY0: clean?		;017
	BEQ	20$		; No, so it IS OK!			;017
	CALLX	CLRFQB		;Start out clean			;017
	MOVB	#UU.TB2,FIRQB+FQFUN ;Are we the only job?		;017
	.UUO			 ;OK Monitor, give us the needed info	;017
	TSTB	FIRQB		 ;Did it work?				;017
	BNE	10$		 ; No - so can't do it!			;017
	CMPB	FIRQB+FQJOB,#1*2 ;Startup job?				;017
	BNE	10$		 ; No - so can't do it!			;017
	CALLX	CLRXRB		;Start with a clean area for PEEK	;017
	MOV	FIRQB+FQSIZ,XRB	; address of job cnt/job max		;017
	.PEEK			; to look at				;017
	TSTB	FIRQB		;Did it work?				;017
	BNE	10$		; No - so can't do it!			;017
	CMP	XRB,#401	; Job max = 1 and Job count = 1		;017
	BNE	10$		; No - so can't do it!			;017
	CALLX	CLRFQB		;Start out clean			;017
	MOVB	#UU.TB1,FIRQB+FQFUN ;Go find SY0: UNTCNT/UNTOPT address	;017
	.UUO			;OK Monitor, give us the info		;017
	TSTB	FIRQB		;Did it work?				;017
	BNE	10$		; No - so can't do it!			;017
	MOV	FIRQB+FQFLAG,R3	;Save UNTCNT -> for FUN calculation	;017
	MOV	FIRQB+FQNENT,R4	;Save UNTOPT -> for later		;017
	MOV	FIRQB+FQNAM1,XRB;Get the address of the DEVPTR table	;017
	SUB	#2,XRB		; for SY0:				;017
	.PEEK			;  and look there (get UNTCNT pointer)	;017
	TSTB	FIRQB		;Did it work?				;017
	BNE	10$		; No - so can't do it!			;017
	MOV	XRB,R2		;Save the address of SY0: UNTCNT word	;017
	.PEEK			; and get the UNTCNT word		;017
	TSTB	FIRQB		;Did it work?				;017
	BNE	10$		; No - so can't do it!			;017
	MOV	XRB,R5		;Get the UNTCNT word			;017
	BIT	#UC.PRI,R5	;Private or Public?			;017
	BEQ	10$		; Public = error			;017
	BIT	#UC.WLO,R5	;Write locked?				;017
	BEQ	10$		; No = error				;017
	CALLX	CLRFQB		;Start out clean			;017
	MOVB	#UU.TRM,FIRQB+FQFUN ;Time to lock out ^Cs		;017
	MOV	#1+<-1*400>,FIRQB+FQFIL	; sub-function 1 on our KB:	;017
	MOV	#400,FIRQB+FQDEV;and Turn OFF ^C!			;017
	.UUO			;OK Monitor, do it for us		;017
	TSTB	FIRQB		;Did it work?				;017
	BNE	10$		; No - so can't do it!			;017
	CALLX	CLRFQB		;Start out clean			;017
	MOVB	#UU.POK,FIRQB+FQFUN ;Change UNTCNT value for SY0:	;017
	MOV	R2,FIRQB+FQFIL	; at this address			;017
	MOV	R2,SYSMNT	; (and save for later also)		;017
	MOV	R5,FIRQB+FQPPN	;  to this value			;017
	BIC	#UC.WLO,FIRQB+FQPPN ; except make it R/W		;017
	.UUO			;OK Monitor, put out our info		;017
	TSTB	FIRQB		;Did it work?				;017
	BNE	10$		; No - so can't do it!			;017
	SUB	R3,R2		; FUN for SY0:				;017
	ADD	R4,R2		; -> UNTOPT entry for SY0:		;017
	MOV	R2,XRB		;  which is where we want to peek	;017
	.PEEK			; and get the UNTOPT word for SY0:	;017
	TSTB	FIRQB		;Did it work?				;017
	BNE	10$		; No - so can't do it!			;017
	CALLX	CLRFQB		;Start out clean			;017
	MOVB	#UU.POK,FIRQB+FQFUN ;Change UNTOPT value for SY0:	;017
	MOV	R2,FIRQB+FQFIL	; at this address			;017
	MOV	XRB,FIRQB+FQPPN	;  to this value			;017
	BIC	#UO.CLN,FIRQB+FQPPN ; except make it clean		;017
	.UUO			;OK Monitor, put out our info		;017
	TSTB	FIRQB		;Did it work?				;017
	BNE	10$		; No - so can't do it!			;017
	TST	(PC)+		;CLC and skip the SEC			;017
10$:	SEC			;Sorry, can't clean SY0: today		;017
20$:	RETURN			;Home again, Home again, jiggidy jog.	;017

GLOBAL	<SYSMNT>							;017

.SBTTL	INITIALIZE CACHE

CHEINI:	MOV	DCS,R0		;GET DEVICE CLUSTER SIZE
	CMP	R0,#16.		;large disk fixup required?		;013
	BLOS	5$		;no, so continue			;013
	MOV	#16.,R0		;yes, set 16 as max cache element size	;013
5$:	SWAB	R0		;COMPUTE NUMBER OF BYTES IN
	ASL	R0		; A CLUSTER = SIZE OF CACHE BUFFER
	ADD	#6,R0		;  + HEADER = SIZE OF CACHE ELEMENT
	SUB	R0,ECACHE	;LAST CACHE ELEMENT START		   ;007
	MOV	#FRELST,R1	;POINT TO LIST OF UNUSED CACHE ELEMENTS
	MOV	IMGTOP+2,R2	;FIRST ELEMENT IS AT START OF CACHE AREA   ;007
10$:	MOV	R2,(R1)		;LINK PREVIOUS ELEMENT TO NEXT ELEMENT
	MOV	R2,R1		;NEXT ELEMENT IS CURRENT
	ADD	R0,R2		;COMPUTE START OF NEW NEXT ELEMENT
	CMP	R2,ECACHE	;DOES THE NEXT ELEMENT FIT?
	BHI	20$		;NO
	BR	10$		;LOOP FOR MORE

20$:	ADD	R0,ECACHE	;LAST CACHE ELEMENT END			   ;007
	CLR	(R1)		;NO ROOM FOR NEXT ELEMENT, END LIST HERE
	CLR	CHELST		;NO BLOCKS IN CACHE NOW
	RETURN			;DONE

.SBTTL	FLUSH CACHE

.ENABL	LSB

CHEFLS:	MOV	#CHEHED+4,R1	;GET BIASED POINTER TO CACHE LIST
10$:	CMP	-(R1),-(R1)	;BACK UP POINTER
	MOV	-(R1),R1	;POINT TO NEXT ELEMENT IN THE LIST
	BEQ	50$		;DONE
	MOV	(R1)+,R3	;GET CLUSTER NUMBER OF CACHED CLUSTER
	CLR	R4		;CLEAR COUNTING MASK
	MOV	(R1)+,R0	;GET MASK OF BLOCKS MODIFIED
	BEQ	10$		;NO CHANGES HERE, GO ON TO THE NEXT ONE
20$:	ADD	#256.,R4	;COUNT ONE MORE BLOCK MODIFIED
	;CLC			;C=0 FROM 'CLC' ABOVE
	ROR	R0		;SHIFT MODIFIED MASK
	BNE	20$		;A HIGHER BLOCK WAS MODIFIED, CARRY ON
30$:	MOV	R3,R2		;Put DCN in R2				;013
	CALL	CNVRIB		;And convert to FBN			;013
	X.WRIT	1,R1,R4,R2,R3	;WRITE CACHE BUFFER, WC IN R4, FBN R2/R3;013
	TSTB	FIRQB		;ERROR CHECK				;007
	BNE	60$		;ERROR!					;007
40$:	CLR	-2(R1)		;TURN OFF MODIFIED MASK
	BR	10$		;LOOP TO FLUSH MORE

50$:	RETURN			;DONE

60$:	MOVB	FIRQB,R0	;GET THE ERROR CODE
	X.ERPT			;PRINT THE RSTS ERROR			;007
	MESSAGE	<" during disk output"<200>"DCN = ">
	MOV	R3,R0		;COPY DCN THAT FAILED
	CALLX	DECZER		;PRINT IT
	MESSAGE	<<200>>		;New line				;007
	CMP	(SP),#90$	;BEEN HERE BEFORE?
	BEQ	40$		;YES, DON'T ASK

70$:	MOV	R1,-(SP)	;PUSH THE CACHE LIST POINTER
80$:	CALLX	YESNO,R5	;ASK FOR CONFIRMATION
	 .WORD	90$
	 GENTXT
	  .ASCII "Type 'YES' if you want to retry the output operation."<200>
	  .ASCII "Type 'NO' if you want to finish up and terminate."<200>
90$:	  .ASCIZ <177><200>"Retry? "
	 UNORG
	BR	80$		;^Z   -- REPEAT THE QUESTION
	BR	80$		;<LF> -- REPEAT THE QUESTION
	BR	100$		;NO   -- FLUSH EVERYTHING
	MOV	(SP)+,R1	;YES  -- RESTORE THE CACHE LIST POINTER
	BR	30$		;THEN GO RETRY

100$:	MOV	(SP)+,R1	;RESTORE THE CACHE LIST POINTER
	MOV	#110$,(SP)	;EXIT AFTER TRYING TO FLUSH EVERYTHING
	BR	40$		;DON'T RETRY THIS

110$:	JMP	LEAVE		;Exit after trying to flush everything	;007

.DSABL	LSB

.SBTTL	DO I/O BETWEEN CACHE AND MEMORY

.ENABL	LSB

PARSEX::MOV	(R5)+,(PC)+	;Save function code			;006
3$:	 .WORD	0							;006
	MOV	(R5)+,(PC)+	; and buffer address			;006
6$:	 .WORD	0							;006
	REGSAV			;SAVE REGISTERS
	SUB	#1,R2		;COMPUTE DCN OF CLUSTER CONTAINING BLOCK
	SBC	R3		; BY TAKING FBN-1
	MOV	R2,-(SP)	;SAVE LOW ORDER WHICH HAS BLOCK WITHIN CLUSTER
	MOV	DCS,R5		;GET THE CLUSTER SIZE
	NEG	R5		;MAKE IT A MASK FOR HIGH ORDER BITS
	BIC	R5,(SP)		;COMPUTE BLOCK WITHIN DEVICE CLUSTER
10$:	ASR	R5		;SHIFT TO DIVIDE BY DCS
	BCS	20$		;DONE
	;CLC
	ROR	R3		;DIVIDE BY DCS
	ROR	R2		; TO COMPUTE (FBN-1)/DCS
	BR	10$

20$:	INC	R2		;  + 1 = DEVICE CLUSTER
	MOV	#CHEHED,R5	;POINT TO CACHE LIST
	CLR	R1		;BACKUP POINTER IS NULL
30$:	MOV	R1,R3		;PRESERVE BACKUP POINTER
	MOV	R5,R1		;SAVE POINTER TO PREVIOUS
	MOV	-(R5),R5	;POINT TO NEXT CACHE ELEMENT
	BEQ	40$		;NONE, GO ALLOCATE ONE AND READ INTO IT
	CMP	R2,(R5)		;IS THIS THE DEVICE CLUSTER WE WANT?
	BNE	30$		;NO, LOOP
	MOV	-(R5),-(R1)	;YES, UNLINK IT FROM THE CHAIN
	MOV	CHELST,(R5)+	;LINK THIS TO FIRST ELEMENT IN THE CHAIN
	MOV	R5,CHELST	;PLACE THIS ELEMENT AT THE HEAD OF THE CHAIN
	CMP	(R5)+,(R5)+	;ADVANCE POINTER TO DATA AREA
	BR	60$		;GO MOVE DATA TO OR FROM CACHE

40$:	MOV	FRELST,R5	;POINT TO NEXT FREE CACHE ELEMENT
	BEQ	110$		;NONE, GO RELEASE OLDEST ELEMENT
	MOV	(R5),FRELST	;GOT ONE, UNLINK IT FROM THE FREE LIST
50$:	MOV	CHELST,(R5)+	;LINK WORD IN ELEMENT POINTS TO HEAD OF LIST
	MOV	R5,CHELST	;INSERT ELEMENT AT HEAD OF LIST
	MOV	R2,(R5)+	;SET DCN IN ELEMENT
	CLR	(R5)+		;NO BLOCKS MODIFIED YET
	MOV	DCS,R4		;GET NUMBER OF BLOCKS TO READ
	CMP	R4,#16.		;large disk fixup required?		;013
	BLOS	55$		;no, so continue			;013
	MOV	#16.,R4		;yes, set 16 as max			;013
55$:	SWAB	R4		;CHANGE TO WORD COUNT
	CALL	CNVRIB		;Convert DCN to FBN (Cluster boundary)	;013
	X.READ	1,R5,R4,R2,R3	;READ INTO DATA PART			;007
	TSTB	FIRQB		;ERROR CHECK				;007
	BNE	130$		;ERROR					;007
60$:	MOV	(SP)+,R2	;RESTORE BLOCK NUMBER WITHIN CACHE
	MOV	#1,R0		;GET MASK BIT
	ASH	R2,R0		;COMPUTE BIT FOR BLOCK WITHIN DC
	SWAB	R2		;NOW CHANGE BLOCK COUNT
	ASL	R2		; TO BYTE OFFSET WITHIN DATA
	ADD	R5,R2		;POINT TO DESIRED DATA BLOCK
	MOV	#256./4,R3	;PRESET LOOP COUNTER
	MOV	6$,R4		;POINT TO DATA AREA			;006
	CMP	3$,#RFUN	;WAS IT A READ?				;006
	BNE	90$		;NO, IT WAS A WRITE
70$:	MOV	(R2)+,(R4)+	;READ, SO COPY
	MOV	(R2)+,(R4)+	; FROM CACHE DATA
	MOV	(R2)+,(R4)+	;  TO
	MOV	(R2)+,(R4)+	;   FIBUF
	SOB	R3,70$		;    UNTIL DONE
80$:	REGRES			;Restore registers			;006
	CLC			;C=0
	RETURN	R5		;DONE

90$:	BIS	R0,-(R5)	;SET BLOCK-MODIFIED BIT
100$:	MOV	(R4)+,(R2)+	;WRITE, SO COPY
	MOV	(R4)+,(R2)+	; FROM FIBUF
	MOV	(R4)+,(R2)+	;  TO
	MOV	(R4)+,(R2)+	;   CACHE DATA
	SOB	R3,100$		;    UNTIL DONE
	BR	80$		;NOW RETURN

110$:	MOV	R1,R5		;NO FREE BLOCKS, KICK OUT LAST CACHE ELEMENT
	MOV	-(R5),-(R3)	;SET 0 INTO LINK WORD OF NEXT-TO-LAST ELEMENT
	MOV	(R1)+,R3	;GET DCN OF LAST CACHE ELEMENT
	CLR	R4		;CLEAR COUNTING MASK
	MOV	(R1)+,R0	;GET MODIFICATION MASK
	BEQ	50$		;UNWRITTEN BLOCK, JUST REUSE ELEMENT IN R5
120$:	ADD	#256.,R4	;COUNT ONE MORE BLOCK TO REWRITE
	;CLC			;C=0 FROM 'ADD' ABOVE
	ROR	R0		;SHIFT MODIFICATION MASK
	BNE	120$		;MORE TO WRITE
	MOV	R2,-(SP)	;Save DCN of element			;013
	MOV	R3,-(SP)	;Save DCN of last element		;013
	MOV	R3,R2		;Convert last element			;013
	CALL	CNVRIB		;Convert DCN to FBN			;013
	X.WRIT	1,R1,R4,R2,R3	;WRITE DATA TO start of DEVICE CLUSTER	;013
	MOV	(SP)+,R3	;Restore element			;013
	MOV	(SP)+,R2	;Restore element			;013
	TSTB	FIRQB		;ERROR CHECK				;007
	BEQ	50$		;NO ERROR				;007
	MOVB	FIRQB,R0	;GET ERROR CODE
	X.ERPT			;PRINT ERROR				;007
	MESSAGE	<" during cache rewrite - aborting"<200>>
	BR	140$		;QUIT

130$:	MOVB	FIRQB,R0	;GET ERROR CODE
	X.ERPT			;PRINT ERROR				;007
	MESSAGE	<" during cache fill - aborting"<200>>
140$:	CALL	CHEFLS		;FLUSH THE CACHE
	JMP	LEAVE		;Exit					;007

.DSABL	LSB

GLOBAL	<FIBUF>								;003

.SBTTL	SEXPAR - TRUELY EMULATES PARSEX

.ENABL	LSB

SEXPAR::MOV	(R5)+,70$	;SAVE THE FUNCTION CODE
	MOV	(R5)+,80$	;AND THE ADDRESS OF WHERE TO DO I/O TO
	REGSAV			;SAVE THE REGISTERS

; Note:  SEXPAR is called with the count to write from the PCS. not the DCS,
; soooo, the following code will write DCS chunks of disk up to the PCS,
; unless the PCS > 16, in which case, we write 16 blocks.  All callers
; (namely, CLN's WIPER) know about this and call SEXPAR with 16 block write
; requests in a loop, up to PCS

	MOV	I.DSQ+DSQCNT,R5	;NUMBER OF WORDS TO WRITE (PCS, not DCS);013
	CMP	R5,#16.*256.	;PCS greater than 16?			;013
	BLOS	23$		;No, so do standard			;013
	MOV	#16.*256.,R5	;Make online version act like INIT.SYS	;013
23$:	NEG	R5		;NEGATIVE NUMBER OF WORDS TO WRITE
	MOV	DCS,R4		;R4 = DCS
	CMP	R4,#16.		;large disk fixup required?		;013
	BLOS	25$		;no, so continue			;013
	MOV	#16.,R4		;yes, set 16 as max			;013
25$:	SWAB	R4		;R4 = # WORDS IN ONE DCS
	CMP	70$,#RFUN	;IS THIS A READ?
	BEQ	40$		;YUP, LETS DO A READ INSTEAD
30$:	X.WRIT	1,80$,R4,R2,R3	;WRITE CALL				;007
	BR	50$		;GO TO COMMON ERROR RETURN


40$:	X.READ	1,80$,R4,R2,R3	;READ CALL				;007
50$:	TSTB	FIRQB		;ERROR CHECK				;007
	BNE	60$		;ERROR					;007
	SWAB	R4		;make back into block count written	;013
	ADD	R4,R2		;increment address of write		;013
	ADC	R3		;double-precision, of course		;013
	SWAB	R4		;back to word count			;013
	ADD	R4,R5		;INDICATE ANOTHER CLUSTER WRITTEN
	BCC	30$		;NOT DONE YET
	CALLX	REGRES,R5	;RESTORE THE REGISTERS
	RETURN	R5		;AND RETURN

60$:	MOVB	FIRQB,R0	;GET ERROR CODE TO PRINT
	X.ERPT			;PRINT IT				;007
	MESSAG	<" during wipeout phase - aborting"<200>>
	CALL	CHEFLS		;FLUSH THE CACHE
	JMP	LEAVE		;Exit					;007

70$:	.WORD	0		;SAVED FUNCTION CODE
80$:	.WORD	0		;SAVED ADDRESS TO DO I/O TO

.DSABL	LSB

.SBTTL	SIMULATE A READ.

.ENABL	LSB

READ.::	MOV	R0,10$		;SAVE COUNT OF WORDS TO DO
	MOV	FCWND+2(R1),R2	;Get DCN to read			;013
	CALL	CNVRIB		;convert to a FBN			;013
	X.READ	1,(R5)+,10$,R2,R3	;and do the read		;013
	TSTB	FIRQB		;ERROR CHECK				;007
	BNE	20$		;AN ERROR, DIE MISERABLY		;007
	RETURN	R5

10$:	.WORD	0		;NUMBER OF WORDS TO DO

20$:	ERF	<"Error during READ.">					;002

.DSABL	LSB




.SBTTL	Handle fatal errors

FATAL:	CALL	RCTRLO		;Reset ^O				;000
	TST	(SP)+		;Don't forget the PS!			;014
	MOV	(SP)+,R0	;Get PC following TRAP			;000
	MOV	(R0),R0		;Get pointer to string			;000
	CALL	ASCIZ0		;Print it out				;000
	JMP	LEAVE		;Exit					;007

.SBTTL	MANAGE S2TBUF

SAVSAT::REGSCR			;SAVE REGISTERS
	MOV	#SATBUF,R0	;POINT TO FIRST BUFFER
	MOV	#S2TBUF,R1	;POINT TO SECOND BUFFER
	MOV	#16.*256.,R2	;WORD COUNT
10$:	MOV	(R0)+,(R1)+	;COPY A WORD
	SOB	R2,10$		; WE GO
	RETURN

RESSAT::REGSCR			;SAVE REGISTERS
	MOV	#SATBUF,R0	;POINT TO FIRST BUFFER
	MOV	#S2TBUF,R1	;POINT TO SECOND BUFFER
	MOV	#16.*256.,R2	;WORD COUNT
10$:	MOV	(R1)+,(R0)+	;COPY A WORD
	SOB	R2,10$		; WE GO
	RETURN

GETSB2::ADD	#S2TBUF,2(SP)	;BIAS POINTER INTO S2TBUF
	MOV	2(SP),SB2ADR	;SAVE ADDRESS
	BIT	#1,2(SP)	;WORD?
	BNE	10$		;NO, BYTE
	MOV	@2(SP),2(SP)	;GET A WORD
	RETURN

10$:	MOVB	@2(SP),2(SP)	;REPLACE ADDRESS WITH DATA
	RETURN

PUTSB2::MOVB	2(SP),@SB2ADR	;REPLACE DATA
	MOV	(SP)+,(SP)	;DUMP DATA FROM STACK
	RETURN

PTRSB2::MOV	(SP),-(SP)	;MAKE ROOM FOR POINTER
	MOV	#S2TBUF,2(SP)	;SET POINTER ONTO STACK
RSTSB2::RETURN			;DONE. NOTHING TO RESET

SB2ADR:	.WORD	0		;SAVED ADDRESS FROM GETSB2::

.SBTTL	READ FOR FIP (READ,READSV,READRF,READMF)
;+
; READ   - READ BLOCK INTO FIBUF GIVEN FBN (WRITE FIRST IF MARKED)
; READSV - READ BLOCK INTO FIBUF GIVEN FBN, ALWAYS WRITE CURRENT BUF
; READRF - READ BLOCK INTO FIBUF GIVEN DCN (RP)
; READMF - READ FIRST BLOCK OF MFD INTO FIBUF
;
; CALL:	FIPUNT = DISK UNIT NUMBER
;	FOR READ AND READSV -
;		R2 = LSB OF FBN OF BLOCK TO READ
;		R3 = MSB OF FBN OF BLOCK TO READ
;	FOR READRF -
;		R2 = DCN OF BLOCK TO READ
;	FOR READMF - NO SETUP
;	CALL	READ??
;
; BACK:	R2/R3 AND FIBPHS = FBN OF BLOCK READ
;	FIBUF CONTAINS THE BLOCK
;	FIBUNT = UNIT NUMBER
;	C=0
;-
READSV::BISB	(PC),@#FIBSTA	;FORCE A WRITE
READ::	CMP	R2,@#FIBPHS	;CHECK TO SEE IF SEGMENT ALREADY THERE
	BNE	10$		;IF NOT EQUAL, THEN DO THE I/O
	CMP	R3,@#FIBPHS+2	;CHECK MSB'S
	BEQ	20$		;IT'S ALREADY THERE, SO RETURN CARRY=0
10$:	CALL	WRITEC		;CHECK FOR WRITE BEFORE READ
	CALL	PARSEX,R5,<RFUN,FIBUF> ;DO A DISK OPERATION
	MOV	R2,@#FIBPHS	;SET LSB OF THE FIP BLOCK #
	MOV	R3,@#FIBPHS+2	; AND THE MSB'S
20$:	CLC			;MUST EXIT WITH C AT 0
	RETURN

; ENTRY TO READ THE FIRST BLOCK OF THE MFD

READMF::MOV	MFDDCN,R2	;Pick up starting DCN of MFD		;000
	.BR	READRF		;Go read it				;000

; ENTRY TO READ IF R2 CONTAINS A RETRIEVAL POINTER (DCN) RATHER THAN
; R2,R3 CONTAINING THE FIP BLOCK NUMBER TO BE READ

READRF::CALL	CNVRIB		;CONVERT RIB ENTRY TO FIP BLOCK #
	BR	READ		;AND DO A NORMAL READ

; Entry to read the pack label						;000

READPL::MOV	#1,R2		;Pack label is at DCN 1			;000
	CLR	R3		; or FBN 1, whatever			;000
	BR	READ		;  so go read it			;000

GLOBAL	<FIBUF>								;003

.SBTTL	WRITE FOR FIP (WRITE,WRITEC)
;+
; WRITE  - WRITE OUT CONTENTS OF FIBUF
; WRITEC - WRITE OUT CONTENTS OF FIBUF ONLY IF FIBSTA IS NON-0
;
; CALL:	FIBPHS = FIB BLOCK NUMBER OF BLOCK IN BUFFER
;	FIBUNT = DISK UNIT NUMBER
;	CALL	WRITE?
;
; BACK:	BLOCK WRITTEN
;	FIBSTA = 0
;-
.ENABL	LSB

WRITEC::TSTB	@#FIBSTA	;CHECK STATUS OF BUFFER
	BEQ	30$		;IF 0, NOTHING THERE OR NO CHANGE
WRITE::	CLRB	@#FIBSTA	;INDICATE BUFFER WRITTEN
	MOV	R2,-(SP)	;PUSH OLD R2
	MOV	R3,-(SP)	;AND  R3
	MOV	@#FIBPHS+2,R3	;GET MSB OF BLOCK # TO WRITE
	MOV	@#FIBPHS,R2	;GET THEM OTHER BITS TOO
	BNE	10$		;IF BLOCK # NOT ZERO,THEN DO THE I/O
	TST	R3		;ARE YOU SURE IT'S ZERO?
	BEQ	20$		;IF SO THEN SKIP THE WRITE
10$:	CALL	PARSEX,R5,<WFUN,FIBUF> ;FINISH PARAMS AND DO IT
20$:	MOV	(SP)+,R3	;POP OLD R3
	MOV	(SP)+,R2	;AND R2
30$:	RETURN

.DSABL	LSB
GLOBAL	<FIBUF>								;003

.SBTTL	GET A CLEAN SAT INTO CORE (CLNSAT)
;+
; CLNSAT - LOAD IN-CORE SAT BUFFER WITH CLEAN (NOTHING ALLOCATED) SAT
;
; CALL:	SETSAT MUST HAVE BEEN CALLED
;	CALL	CLNSAT
;
; BACK:	IN-CORE SATBUF LOADED WITH SAT BITS:
;	ALL SYSTEM DISK CLUSTERS ARE DEALLOCATED
;	ALL BITS CORRESPONDING TO NON-EXISTENT BLOCKS ARE ALLOCATED
;	through block 16						;013
;
; NOTE:	THE SAT IS KEPT IN CORE AS A MULTIPLE OF PCS BLOCKS,
;	EVEN THOUGH ITS FILE LENGTH REFLECTS ITS TRUE EXTENT
;-
CLNSAT::CLR	R4		;ZERO SAT BYTE POINTER
	MOV	R2,-(SP)	;get a register				;013
	MOV	#1,R5		;START AT BIT ZERO
	MOV	SATSYS+BITS,R0	;R0 = # CLUSTERS IN SYS DISK SAT

; THIS ROUTINE DEALLOCATES BITS IN THE SAT. NUMBER OF BITS IS IN R0

10$:	CMP	R4,SATSYS+BYTS	;ROOM IN SAT ?
	BHIS	35$		;NO, QUIT, restoring r2			;013
	BICB	R5,SATBUF(R4)	;YES, CLEAR A BIT
	CALL	30$		;ADVANCE TO NEXT BIT
	SOB	R0,10$		;CLEAR AS MANY AS NEEDED

; NOW TO FINISH UP BY ALLOCATING ALL BITS BEYOND PHYSICAL END OF DISK

20$:	MOV	SATSYS+BYTS,R2	;save the byts to be cleared		;013
	CMP	R2,#16.*1000	;at the 16 blk limit?			;013
	BLOS	25$		;no, so continue			;013
	MOV	#16.*1000,R2	;set at the valid limit			;013
25$:	CMP	R4,SATSYS+BYTS	;FINISHED YET ?
	BHIS	35$		;YES, FINAL EXIT			;013
	BISB	R5,SATBUF(R4)	;SET A BIT
	CALL	30$		;ADVANCE TO NEXT BIT
	BR	25$		;LOOP MORE				;013

; THIS ROUTINE ADVANCES TO THE NEXT BIT

30$:	ASLB	R5		;SHIFT BIT LEFT ONE
	BCC	40$		;STILL IN BYTE ?
	INC	R4		;NO, ON TO NEXT BYTE
	INC	R5		;AND SET MASK TO BIT 0 AGAIN
	BR	40$		;and return				;013

35$:	MOV	(SP)+,R2	;restore register			;013
40$:	RETURN

.SBTTL	WOMP THE IN-CORE SAT TO DISK (WOMSAT)
;+
; WOMSAT - WOMP THE IN-CORE SAT TO DISK
;
; CALL:	SAT SET UP IN SATBUF
;	CALL	WOMSAT
;
; BACK:	SAT HAS BEEN WOMPED
;	BITS CORRESPONDING TO THINGS PAST THE END-OF-DISK ALWAYS SET
;	up to and including the 16th block (even on large disks)	;013
;
; ERRORS: IF THE FILE SATT.SYS[0,1] DOES NOT EXIST (FIRQB NOT SET),
;	"INIT BUG - SATT.SYS NON-EXISTENT AT TIME OF WOMP"
;-
.ENABL	LSB

WOMSAT::REGSCR			;SAVE REGS
	BIT	#FS.OPN,FQSATT+FQSTAT ;SATT.SYS HAD OUGHTA EXIST
	BEQ	40$		;ELSE WE SHOULDN'T TRY TO WRITE INTO IT
	MOV	SATSYS+BYTS,R5	;R5 = TOTAL # BYTES IN SYSTEM DISK SATT
	CMP	R5,#16.*1000	;greater than 16 blocks?		;013
	BLOS	5$		;no, so ok				;013
	MOV	#16.*1000,R5	;yes, so only do 16 blocks worth	;013
5$:	ADD	#SATBUF,R5	;R5 -> END OF SATT (ABSOLUTE)
	MOV	SATSYS+BITS,R0	;R0 = REAL # OF BITS (TRUE CLUSTERS)
	MOV	R0,R1		;COPY THAT
	BIC	#7,R0		;ROUND R0 TO A BYTE MULTIPLE OF BITS
	BIC	R0,R1		;R1 = BIT NUMBER WITHIN LAST BYTE
	CLC
	ROR	R0		;R0 = RELATIVE BYTE POINTER INTO SATT
	ASR	R0
	ASR	R0
	ADD	#SATBUF,R0	;R0 -> FIRST BYTE WITH NX BLOCKS
	TST	R1		;IS THE BIT NUMBER 0?
	BEQ	20$		;YES, END OF SATT OR FILL BY BYTES
10$:	BISB	GETCLS(R1),(R0)	;SET ALL BITS FOR CLUSTERS ABOVE
	INC	R1		;  SYSTEM DISK BOUNDARY
	CMP	R1,#10		;DONE 8TH BIT IN THIS BYTE YET?
	BNE	10$		;NO
	INC	R0		;BUMP TO NEXT BYTE
20$:	CMP	R0,R5		;DONE WITH ALL BYTES ?
	BEQ	30$		;YEP
	MOVB	#-1,(R0)+	;SET THE WHOLE BYTE
	BR	20$		;AND LOOP

30$:	MOV	#FCSATT,R1	;POINT TO FCB FOR THE WRITE
	CLR	FCNVB(R1)	;START WRITING SAT AT BLOCK 0
	MOV	FCWND+2(R1),R2	;CONVERT DCN TO FBN			;013
	CALL	CNVRIB		;DO IT					;013
	MOV	FCSIZ(R1),R4	;R4 = SIZE OF SATT.SYS IN BLOCKS	;013
	SWAB	R4		; CONVERTED TO WORD COUNT		;013
	X.WRIT	1,#SATBUF,R4,R2,R3					;013
	TSTB	FIRQB		;ERROR CHECK				;007
	BNE	50$		;ERROR					;007
	RETURN

50$:	ERF	<"Error during WOMSAT">

40$:	ERF	<"INIT bug - SATT.SYS non-existent at time of WOMP">

.DSABL	LSB

GLOBAL	<SATSYS,S2TBUF,FQSATT>

.SBTTL	SEARCH UFD FOR PPN + FILE.EXT  (SDU)
;+
; SDU - SEARCH UFD FOR [PPN]FILNAM.EXT
;
; CALL:	R0 -> PPN+FILNAM.EXT
;	CALL	SDU
;
; BACK:	C=0	FILE FOUND IN UFD
;		R2 = LINK IN UFD TO PREVIOUS NAME ENTRY
;		R3 = LINK IN UFD TO FOUND NAME ENTRY
;		R5 -> NAME ENTRY
;		FIPMUC = UFD CLUSTER SIZE
;	C=1	FILE NOT FOUND
;		R5=0	PPN NOT FOUND IN MFD
;			FIPCLU = LINK IN MFD TO LAST NAME ENTRY
;			FIBUF CONTAINS BLOCK WHICH FIPCLU POINTS TO
;		R5=2	PPN FOUND IN MFD, BUT UFD NOT ALLOCATED
;			FIBUF CONTAINS MFD BLOCK W/ ACCOUNT'S NAME ENTRY
;			FIPCLU = ABSOLUTE POINTER TO
;				ACCOUNT'S NAME ENTRY + UAR
;				(I.E. @FIPCLU IS DCN OF UFD = 0)
;			FIPMUC = UFD CLUSTER SIZE (FROM ACCOUNT'S AB)
;		R5=4	UFD EXISTS, BUT FILE NOT FOUND
;			R2 = LINK IN UFD TO LAST NAME ENTRY
;			R3 = 0
;			FIBUF CONTAINS UFD BLOCK WHICH R2 POINTS TO
;			FIPMUC = UFD CLUSTER SIZE
;-
SDU::	CALL	RUF		;RUF WILL GET THE UFD
	BCS	30$		;EXIT IF PPN NOT FOUND OR NO UFD
	CLR	R2		;INIT UFD SCAN
	CLR	R3		;ZERO LINK
10$:	CALL	RDB		;GET A NAME BLOCK
	CMP	2(R0),UNAM(R5)	;MATCH ON NAME FIRST WORD ?
	BNE	20$		;NO,GET ANOTHER NAME BLOCK
	CMP	4(R0),UNAM+2(R5);GO FOR 2 ?
	BNE	20$		;NOPE
	CMP	6(R0),UNAM+4(R5);TRY THE EXTENSION
	BNE	20$		;SORRY CHARLIE
	BITB	#US.DEL!US.UFD,USTAT(R5) ;MARKED FOR DELETION OR UFD?
	BEQ	30$		;IF NOT, THEN WE FOUND IT
				;IF SO , IGNORE IT
20$:	MOV	R3,R2		;NEW LAST LINK
	MOV	(R5),R3		;NEW THIS LINK
	BIC	#17,R3		;WITHOUT FLAG BITS
	BNE	10$		;IF NOT END OF UFD, LOOP
	MOV	#4,R5		;IF END, SET R5=4 FOR EOF
	SEC			;INDICATE BADNESS
30$:	RETURN			;RETURN

.SBTTL	READ UFD GIVEN A PPN  (RUF)
;+
; RUF	- READ FIRST BLOCK OF UFD GIVEN PPN
;
; CALL:	R0 -> PPN
;	CALL	RUF
;
; BACK:	C=0	UFD WAS FOUND
;		FIBUF CONTAINS FIRST BLOCK OF UFD
;		FIPMUC = UFD CLUSTER SIZE
;		FIPCLU = LINK IN MFD POINTING TO NB ENTRY FOR PPN
;		R5 = 0
;	C=1	UFD COULD NOT BE READ
;		R5=0	PPN NOT FOUND IN MFD
;			FIPCLU = LINK IN MFD TO LAST NAME ENTRY
;			FIBUF CONTAINS BLOCK WHICH FIPCLU POINTS TO
;		R5=2	PPN FOUND IN MFD, BUT UFD NOT ALLOCATED
;			FIBUF CONTAINS MFD BLOCK W/ ACCOUNT'S NAME ENTRY
;			FIPCLU = ABSOLUTE POINTER TO
;				ACCOUNT'S NAME ENTRY + UAR
;				(I.E. @FIPCLU IS DCN OF UFD = 0)
;			FIPMUC = UFD CLUSTER SIZE (FROM ACCOUNT'S NB)
;-
RUF::	CLR	R5		;SET R5 TO ZERO INITIALLY
	REGSCR			;SAVE REGS
	MOV	(R0),-(SP)	;PUT SUPPLIED PPN ON STACK
	MOV	SP,R0		;R0 -> COPY OF PPN FOR SDM
	CALL	SDM		;SEARCH MFD FOR THIS PPN
	MOV	R2,FIPCLU	;STORE POSSIBLE LAST LINK IN TEMP
	BCS	30$		;NO PPN WAS FOUND, ACCOUNT DOESN'T EXIST
	ADD	#UAR,R5		;R5 -> RB LINK WORD
	MOV	(R5),R2		;GET THE UFD START DCN
	BNE	10$		;IF UFD EXISTS, BRANCH
	MOV	R5,FIPCLU	;STORE NB POINTER INTO A TEMP
	MOV	R3,-(SP)	;SAVE LINK TO ACCOUNT'S UFD NAME ENTRY
	MOV	-(R5),R3	;GET THE AB LINK
	CALL	RDB		;NOW GET ACCOUNT'S MFD ACCOUNTING ENTRY
	MOV	UCLUS(R5),FIPMUC;SET THE UFD CLUSTER SIZE FROM THAT
	MOV	(SP)+,R3	;RESTORE NAME ENTRY LINK
	CALL	RDB		;READ NAME ENTRY AGAIN
	COM	(SP)+		;SET THE CARRY, DUMP STACK
	MOV	#2,TOS.R5(SP)	;SET R5 TO 2 (ACCOUNT BUT NO UFD)
	RETURN			;RETURN WITH BADNESS NOTED

10$:	CALL	CNVRIB		;CONVERT DCN TO FIP BLOCK #
20$:	CALL	READ		;READ IN FIRST BLOCK OF UFD
	MOV	FIBMAP,FIPMUC	;SET UFD CLUSTER SIZE FROM MAP
      ; CLC			;INDICATE GOODNESS
30$:	INC	(SP)+		;DUMP STACK LEAVING CARRY ALONE
	RETURN

GLOBAL	<FIBMAP>							;003

.SBTTL	READ NAME ENTRY FOR OPEN FILE (RNB)
;+
; RNB - READ NAME ENTRY OF OPEN FILE
;
; CALL:	R1 -> FCB
;	CALL	RNB
;
; BACK:	R5 -> NAME ENTRY OF FILE IN FIBUF
;-
RNB::	MOV	R2,-(SP)	;SAVE REGS
	MOV	R3,-(SP)
	CMPB	(R1),SYSNDX	;IS THIS THE RIGHT DISK?
	BNE	10$		;NO, BOOT
	CMPB	DDUNT(R1),SYSUNT ;YES, RIGHT UNIT?
	BNE	10$		;NO, BOOT
	MOV	FCUFND+F.FBNL(R1),R2 ;GET LSB OF FBN FOR NAME ENTRY
	MOVB	FCUFND+F.FBNM(R1),R3 ;GET MSB
	CALL	READ		;READ IN THE RIGHT BLOCK
	CLR	R5		;CLEAR R5 FOR BISB
	BISB	FCUFND+F.UNT(R1),R5 ;GET OFFSET/2 IN R5
	ASL	R5		;R5 = OFFSET OF N.E. IN FIBUF
	ADD	#FIBUF,R5	;R5 -> N.E.
	MOV	(SP)+,R3	;RESTORE REGS
	MOV	(SP)+,R2
	RETURN

10$:	ERF	<"INIT bug - RNB to wrong disk">

GLOBAL	<FIBUF>								;003

.SBTTL	SEARCH UFD FOR PPN  (SDM)

;+
; SDM - SEARCH MFD FOR PPN
;
; CALL:	R0 -> PPN
;	CALL	SDM
;
; BACK:	C=0	PPN FOUND IN MFD
;		R2 = LINK IN MFD TO PREVIOUS NAME ENTRY (TO DELETE ACCT)
;		R3 = LINK IN MFD TO THIS NAME ENTRY
;		R5 -> NAME ENTRY
;		FIBUF CONTAINS MFD BLOCK W/ THIS ACCOUNT'S NAME ENTRY
;		FIPMUC = MFD CLUSTER SIZE
;	C=1	PPN NOT FOUND IN MFD
;		R2 = LINK IN MFD TO LAST NAME ENTRY
;		R3 = 0
;		R5 DESTROYED
;		FIBUF CONTAINS LAST BLOCK OF MFD
;		FIPMUC = MFD CLUSTER SIZE
;-

.ENABL	LSB

SDM::	CALL	READMF		;READ MFD FIRST BLOCK
	MOV	FIBMAP,FIPMUC	;SET MFD CLUSTER SIZE
	CMP	MFDDCN,#1	;Old disk?				;000
	BNE	SDMNEW		;No, do it the new way			;000
	CLR	R2		;PREVIOUS LINK IS MFD'S DUMMY ENTRY
	MOV	FIBUF,R3	;R3 = LINK TO FIRST NAME ENTRY IN MFD
10$:	CALL	RDB		;READ A NAME ENTRY
	CMP	(R0),UNAM(R5)	;TEST ARGS
	BNE	20$		;THIS IS NOT THE ACCOUNT NAME ENTRY
	BITB	#US.UFD,USTAT(R5) ;NAME MATCHES. MAYBE IT'S A FILE?
	BNE	50$		;NO, IT'S REALLY A UFD, SO EXIT WITH C=0
20$:	MOV	R3,R2		;SET NEW LAST LINK
	MOV	(R5),R3		;NEW CURRENT LINK
30$:	BIC	#17,R3		; WITHOUT FLAG BITS
	BNE	10$		;CONTINUE IF NON ZERO
40$:	SEC			;ELSE INDICATE BADNESS
50$:	RETURN

SDMNEW:	ADD	#1,R2		;Point to GFD pointer table		;000
	ADC	R3							;000
	CALL	READ		;Read that block			;000
	CLR	R5		;Avoid sign extension			;000
	BISB	1(R0),R5	;Get group number			;000
	ASL	R5		;Word offset				;000
	MOV	FIBUF(R5),R2	;Get GFD DCN				;000
	BEQ	40$		;None, exit failing			;000
	CALL	CNVRIB		;Convert to FBN				;000
	ADD	#2,R2		;Point to name block link table		;000
	ADC	R3							;000
	CALL	READ		;Read that				;000
	CLR	R5		;Avoid sign extension			;000
	BISB	(R0),R5		;Get user number			;000
	ASL	R5		;Word offset				;000
	MOV	FIBUF(R5),R5	;Get link to name entry			;000
	SUB	#2,R2		;Point back to GFD label block		;000
	SBC	R3		; double precision			;000
	CALL	READ		;Read it in for cluster map		;000
	MOV	R5,R3		;Copy link				;000
	BR	30$		; and exit				;000

.DSABL	LSB
GLOBAL	<FIBMAP,FIBUF>							;003

.SBTTL	READ A DIRECTORY ENTRY (RDS AND RDB)
;+
; RDB - READ ENTRY FROM A DIRECTORY GIVEN LINK
; RDS - READ ENTRY FROM A DIRECTORY GIVEN LINK, MARK CURRENT BLOCK DIRTY
;
; CALL:	FIBUF MUST CONTAIN ANY BLOCK OF THIS DIR (SO FIBENT IS VALID)
;	FIBPHS CONTAINS CURRENT FIBUF FBN (AS USUAL)
;	R3 = LINK TO DESIRED ENTRY
;	CALL	RDB OR RDS
;
; BACK:	BLOCK WITH DESIRED ENTRY IS IN FIBUF
;	R5 -> DESIRED ENTRY
;	C=0
;
; ERRORS: IF A LINK IS DECODED AND SPECIFIES AN UNALLOCATED DIRECTORY
;	CLUSTER, OR SPECIFIES A BLOCK WITHIN CLUSTER WHICH IS
;	GREATER THAN THIS DIRECTORY CLUSTER SIZE:
;	"DIRECTORY ERROR DETECTED IN RDB"
;-
.ENABL	LSB

RDS::	BISB	(PC),@#FIBSTA	;MARK FIBUF FOR WRITE (MBFW)
RDB::	MOV	R2,-(SP)	;SAVE CALLING R2
	MOV	R3,-(SP)	;SAVE LINK FOR LATER RESTORING
	BIC	#17,R3		;CLEAR OFF FLAG BITS
	MOV	R3,R5		;COPY LINK INTO R5
	BIC	#^C<777>,R5	;LEAVE ONLY BUFFER OFFSET IN R5
	BIC	R5,R3		;AND REST ONLY IN R3
	ADD	#FIBUF,R5	;R5 IS NOW THE ABS POINTER FOR EXIT
	SWAB	R3		;GET REST OF LINK INTO LOW BITS
	MOV	R3,R2		;COPY WHAT IS LEFT OF LINK
	BIC	#-16-1,R2	;LEAVE ONLY CLUSTER NUMBER * 2 IN R2
	MOV	FIBENT(R2),R2	;NOW GET MAP ENTRY
	BNE	20$		;MUST BE NON-ZERO
10$:	ERF	<"Directory error detected in RDB">

20$:	ASH	#-4,R3		;SHIFT TO GET BLOCK WITHIN CLUSTER
	CMPB	R3,FIBMAP	;IS IT VALID FOR THIS DIRECTORY?	;000
	BHIS	10$		;NO, DIRECTORY IS BAD
	MOV	R3,-(SP)	;SAVE THAT OFFSET
	CALL	CNVRIB		;CONVERT DEVICE CLUSTER # TO FIP BLOCK #
	ADD	(SP)+,R2	;ADD OFFSET INTO DIRECTORY CLUSTER
	ADC	R3		;(DOUBLE PRECISION)
	CALL	READ		;READ IN THE BLOCK OF THE DIRECTORY
	MOV	(SP)+,R3	;RESTORE ORIGINAL LINK WORD
	MOV	(SP)+,R2	;AND CALLING R2
	RETURN

.DSABL	LSB
GLOBAL	<FIBENT,FIBMAP,FIBUF>						;003

.SBTTL	LOOKUP A FILE
;+
; LOKFIL - LOOKUP A FILE ON THE DISK
;
; CALL:	R4 -> FIRQB CONTAINING PPN+FILNAM.EXT
;	CALL	LOKFIL
;
; BACK:	C=0	FILE FOUND ON DISK
;		FCB ASSOCIATED WITH FIRQB SET UP FOR READING
;		FQSIZC SET UP WITH FILE'S SIZE
;	C=1	FILE NOT FOUND
;-
LOKFIL::REGSCR			;SAVE ALL REGISTERS
	BIC	#FS.OPN,FQSTAT(R4) ;MARK IT NOT OPEN FOR NOW
	MOV	R4,R0		;COPY FIRQB POINTER
	ADD	#FQPPN,R0	;R0 -> PPN+FILNAM.EXT
	CALL	SDU		;LOOK UP THE FILE BY NAME
	BCS	40$		;CAN'T FIND IT, RETURN C=1
	ADD	#FQFCB+FCBSIZ,R4 ;R4 -> END OF ASSOCIATED FCB
	MOV	#FCBSIZ/2,R3	;R3 = NUMBER OF WORDS TO CLEAR
10$:	CLR	-(R4)
	SOB	R3,10$
	MOVB	FIBIDX,(R4)+	;SAVE DISK TYPE INDEX
	MOVB	USTAT(R5),(R4)+	;FILE FLAGS (CONTIGUOUS)
	INC	R4		;SKIP PENDING XFER
	MOVB	FIBUNT,(R4)+	;SAVE FIP UNIT NUMBER
	MOV	R4,R0		;REMEMBER THIS POINTER
	ADD	#FCUFND-FCSIZ,R4 ;POINT TO UFD NAME ENTRY DESCRIPTOR
	MOV	R5,R2		;COPY NAME ENTRY POINTER
	SUB	#FIBUF,R2	;GET OFFSET TO N.E. WITHIN FIBUF
	ASR	R2		;MAKE IT A BYTE
	MOVB	R2,(R4)+	;SAVE IT IN FCB
	MOVB	FIBPHS+2,(R4)+	;SAVE CURRENT FIP BLOCK NUMBER
	MOV	FIBPHS,(R4)+	;(23 BITS)
	MOV	UAA(R5),R3	;R3 = LINK TO ACCOUNT ENTRY
	MOV	UAR(R5),R2	;R2 = LINK TO FIRST RETRIEVAL ENTRY
	CALL	RDB		;POINT TO ACCOUNT ENTRY
	MOV	USIZ(R5),(R0)	;SAVE FILE SIZE IN FCB
	MOV	(R0)+,FQSIZC-<FQFCB+FCWND>(R4) ; ALSO IN FQB EXTENSION
	CMP	(R0)+,(R0)+	;SKIP NEXT VIRTUAL BLOCK & FIRST V.B.(0)
	MOV	UCLUS(R5),(R0)	;GET FILE CLUSTER SIZE
	DEC	(R0)+		;MAKE IT A BYTE (AND FLAGS = 0)
	MOV	R2,R3		;R3 = LINK TO RETRIEVAL ENTRY
	BIC	#17,R3		; WITHOUT FLAG BITS
	BEQ	30$		;NONE (NULL FILE)
	CALL	RDB		;READ IT IN
20$:	MOV	(R5)+,(R4)+	;MOVE IN A WINDOW
	BIT	R5,#17		;DONE (ONLY FIBUF IS ALIGNED!)
	BNE	20$
30$:	CLC			;CLEAR CARRY FOR DONE
	BIS	#FS.OPN,FQSTAT-<FQFCB+FCUFND>(R0) ;MARK THE FILE OPEN
40$:	RETURN

GLOBAL	<FIBUF>								;003

.SBTTL	CONVERT RETRIEVAL POINTER (DCN) TO FIP BLOCK #
;+
; CNVRIB - CONVERT RETRIEVAL POINTER (DEV CLU) TO FIP BLOCK #
; CNVRB2 - CONVERT RETRIEVAL POINTER TO FBN, PASSING DCS
;
; CALL:	R2 = RP TO CONVERT
;	DCS = DEVICE CLUSTER SIZE IF CNVRIB
;	R3  = DEVICE CLUSTER SIZE IF CNVRB2
;	CALL	CNVR??
;
; BACK:	R2/R3 = CORRESPONDING FBN
;-
CNVRIB::MOV	DCS,R3		;GET DEVICE CLUSTER SIZE
CNVRB2::MOV	R3,-(SP)	;SAVE DCS ON THE STACK
	CLR	R3		;CLEAR MSB OF FBN
	DEC	R2		;R2 = DCN - 1
10$:	ASR	(SP)		;MULTIPLY BY DEVICE CLUSTER SIZE (DCS)
	BCS	20$		; AND THEN ADD 1 TO GET
	ASL	R2		;  FIP BLK # = DCS*(DCN -1) + 1
	ROL	R3
	BR	10$

20$:	ADD	#1,R2		;R2 NOW HAS LSB OF BLOCK #
	ADC	R3		;R3 HAS MSB
	TST	(SP)+		;POP GARBAGE
	RETURN

.SBTTL	CONVERT DEVICE CLUSTER NUMBER TO PACK CLUSTER NUMBER (RIB2CN)
;+
; RIB2CN - CONVERT DEVICE CLUSTER NUMBER (R.P.) TO PACK CLUSTER NUMBER
;
; CALL:	R2 = DCN TO CONVERT
;	CLURAT = CLUSTER RATIO (PCS/DCS)
;	CALL	RIB2CN
;
; BACK:	R3 = PACK CLUSTER NUMBER
;	NO ERROR IF DCN TO CONVERT IS NOT ON PACK CLUSTER BOUNDARY
;-
RIB2CN::MOV	R2,-(SP)	;SAVE R2 FOR RETURN
	MOV	R2,R3		;NEED IT IN R3 FOR DIVIDE
	DEC	R3		;RETRIEVAL POINTER - 1
	MOV	CLURAT,R2	;PCN = (R.P. - 1)/(PCS/DCS)
10$:	ASR	R2		;NOW DIVIDE
	BCS	20$		;ALL DONE
	;CLC			;AVIOD SIGN EXTENSION ON
	ROR	R3		;THIS SHIFT
	BR	10$

20$:	MOV	(SP)+,R2	;RESTORE RETRIEVAL POINTER TO R2
	RETURN

.SBTTL	CONVERT PACK CLUSTER NUMBER TO FIP BLOCK NUMBER (CN2SEG)
;+
; CN2SEG - CONVERT PACK CLUSTER NUMBER TO FIP BLOCK NUMBER
;
; CALL:	R2 = PACK CLUSTER NUMBER TO CONVERT
;	PCS = PACK CLUSTER SIZE
;	CALL	CN2SEG
;
; BACK:	R2/R3 = FIP BLOCK NUMBER
;-
CN2SEG::CLR	R3		;BLK # = CN * PCS + 1
	MOV	PCS,-(SP)	;CLEAR MSB (R3) AND STACK PCS
10$:	ASR	(SP)		;NOW MULTIPLY
	BCS	20$		;ALL DONE
	ASL	R2		;DOUBLE
	ROL	R3		; SHIFT
	BR	10$

20$:	TST	(SP)+		;DUMP STACK ITEM
	ADD	#1,R2		;ADD 1
	ADC	R3		; AND CARRY
	RETURN

.SBTTL	CONVERT FIP BLOCK NUMBER TO PACK CLUSTER NUMBER
;+
; SEG2CN - CONVERT FIP BLOCK NUMBER TO PACK CLUSTER NUMBER
;
; CALL:	R2/R3 = FBN TO CONVERT
;	PCS = PACK CLUSTER SIZE
;	CALL	SEG2CN
;
; BACK:	R2 = PACK CLUSTER NUMBER
;	R3 <> 0 IF FBN WAS NOT ON A PACK CLUSTER BOUNDARY
;	CONDITION CODES SET ON R3 (Z=1 IF BOUNDARY OK)
;-
SEG2CN::SUB	#1,R2		;PCN = (BLK - 1)/PCS
	SBC	R3
	MOV	PCS,-(SP)	;GET PCS
10$:	ASRB	(SP)		;DIVIDE BY PCS
	BCS	20$
	ASR	R3		;SHIFT MSB
	ROR	R2		; BRING BITS INTO LSB
	ROLB	1(SP)		;SHIFTED OUT BITS TO STACK
	BR	10$

20$:	MOV	(SP)+,R3	;SET CC'S AND R3
	RETURN

.SBTTL	ROUND UP BLOCK COUNT TO CLUSTER MULTIPLE (FIXCLU)
;+
; FIXCLU - ROUND UP BLOCK COUNT TO AN EVEN NUMBER OF PACK CLUSTERS
;
; CALL:	R1 = NUMBER OF BLOCKS
;	CALL	FIXCLU
;
; BACK:	R0 = NUMBER OF PACK CLUSTERS AT CURRENT PCS (ROUNDED UP)
;	R1 = NUMBER OF BLOCKS = R0*PCS
;-
FIXCLU::MOV	PCS,R0		;GET PCS IN R0 FOR DIVIDE
10$:	ASR	R0		;SHIFT PCS
	BCS	20$		;DONE DIVIDE
	;CLC
	ROR	R1		;# OF BITS = (CLUSTER SIZE + PCS -1)/PCS
	ADC	R1		;AND ROUND UP IF ANY REMAINDER
	BR	10$

20$:	MOV	R1,R0		;NUMBER OF PACK CLUS TO R0
	MOV	PCS,-(SP)	;COMPUTE NUMBER OF BLOCKS AGAIN IN R1
30$:	ASR	(SP)		;MULTIPLY BY PCS
	BCS	40$
	ASL	R1
	BR	30$

40$:	TST	(SP)+		;POP THE 0 WORD
	RETURN

.SBTTL	COMPUTE SAT POINTERS GIVEN PACK CLUSTER NUMBER (FIXREG)
;+
; FIXREG - COMPUTE SAT BYTE OFFSET AND BIT NUMBER FROM PCN
;
; CALL:	R0 = PACK CLUSTER NUMBER
;	CALL	FIXREG
;
; BACK:	R2 = BIT NUMBER (USED FOR INDEXING INTO GETCLS)
;	R4 = OFFSET INTO SAT
;-
FIXREG::MOV	R0,R2		;CURRENT CN TO R2
	MOV	R0,R4		;AND R4
	BIC	#177770,R2	;ONLY BYTE REMAINDER IN R2
	CLC
	ROR	R4		;BYTE NUMBER = BIT NUMBER / 8.
	ASR	R4		;
	ASR	R4		;
	RETURN

.SBTTL	DATA AREA

DSKNAM:	$DISKS
	 .WORD	"NAME
.ENDM
    	 .WORD	0


DEVNAM:	.WORD	0		;DEVICE NAME				;007

GETCLS::.BYTE	1,2,4,10,20,40,100,200,0
	.EVEN
AUTOQS::.WORD	0		;<>0 IF AUTO-RESTART IN PROGRESS
SATSYS::.WORD	0		;* + SEGS = # OF BLOCKS
	.WORD	0		;* + BYTS = # OF BYTES
	.WORD	0		;* + BITS = # OF BITS OR CLUSTER @PCS
SATSYN::.WORD	0		;# OF CLUSTERS OF SAT THAT ARE USEFUL

FIBIDX:				;FIBUF DISK INDEX SAME AS SYSTEM DISK INDEX
SYSNDX::.WORD	0		;SYSTEM DISK INDEX.
FIBUNT:				;FIBUF DISK UNIT NUMBER SAME AS SYS DISK
SYSUNT::.WORD	0		;SYSTEM DISK UNIT NUMBER
DCS::	.WORD	0		;SYSTEM DISK DEVICE CLUSTER SIZE
PCS::	.WORD	0		;SYSTEM DISK PACK CLUSTER SIZE
CLURAT::.WORD	0		;CLUSTER RATIO = PCS/DEVICE CLUSTER SIZE
BADFLG:	.WORD	0		;FILE BAD BLOCK FLAG FOR CLEAN

SETFP0:			;START OF FIP CLEARED AREA

FIBPHS::.WORD	0,0	;BLOCK NUMBER CURRENTLY IN 'FIBUF'

FIPCLU:	.WORD	0	;CURRENT FILE CLUSTER SIZE
FIPMUC:	.WORD	0	;CURRENT MFD/UFD CLUSTER SIZE

;****** I,J,K ARE GROUPED
I:	.WORD	0	;LINK OFFSET INTO BUFFER (0-777)
J:	.BYTE	0	;LINK ?
K:	.BYTE	0	;LINK ?

;****** FIBUNT,FIBSTA ARE GROUPED
	.EVEN
	.BYTE	0	;FIBUNT: UNIT # OF BLOCK CURRENTLY IN 'FIBUF'
FIBMOD::
FIBSTA::.BYTE	0	;MARKER FOR 'FIBUF' (MUST BE ODD ADDR!)

SYSSZL::.WORD	0	;SELECTED DISK SIZE LSB
SYSSZM::.WORD	0	;  "        "    "  MSB

SYSPHU::.BYTE	0,0	;LOW BYTE=UNIT*2, HIGH BYTE = UNIT

SETFP1:			;END OF FIP CLEARED AREA

.SBTTL		FIRQB'S

.MACRO	FQBGEN	TAG,NAMEXT,SIZ
.LIST
FQ'TAG::
.NLIST
	.WORD	0		;LINK (UNUSED)
	.BYTE	0,0		;FUNCTION, JOB
	.WORD	0		;CHANNEL
	.WORD	0*400+1		;PPN [0,1]
	.RAD50	"NAMEXT"	;FILE NAME & EXTENSION
	.WORD	SIZ+0		;REQUIRED SIZE (IF ANY)
	.WORD	0,0,0
	.BYTE	60,77		;STATUS, PROTECTION (?)
	.WORD	0,0,0,0		;REMAINDER OF STANDARD FIRQB

	.WORD	0		;REFRESH STATUS BITS
	.WORD	0		;CURRENT FILE SIZE
	.WORD	0		;CURRENT START CLUSTER
	.WORD	0		;PREFERRED START CLUSTER
	.WORD	0,0,0		;EXTRA WORDS FOR SCRATCH
	.WORD	0
.LIST
FC'TAG::
	.BLKW0	FCBSIZ/2	;FILE'S FCB

.NLIST
.ENDM	FQBGEN

	FQBGEN	SATT,<SATT  SYS>
	FQBGEN	BADB,<BADB  SYS>



.SBTTL	DEFINITIONS AND MACROS


; COMMON ASCII DEFINITIONS

.EQUATE	BELL	, 7
.EQUATE	TAB	, 11
.EQUATE	LF	, 12
.EQUATE	VT	, 13
.EQUATE	FF	, 14
.EQUATE	CR	, 15
.EQUATE	ESCAPE	, 33
.EQUATE	SPACE	, 40

.MACRO	I.MESS
.NLIST	BEX
	TMPORG	TTYTXT
.ENDM	I.MESS

	TMPORG	OLHOOK		;HOOKS FOR ON-LINE DRIVERS
H.TYPE::.WORD	RTSPC		;HOOK FOR CHARACTER OUTPUT
H.ASK::	.WORD	RTSPC		;HOOK FOR QUESTION ASKER
H.GETI::.WORD	RTSPC		;HOOK FOR INPUT LINE GETTER
H.EXIT::.WORD	RTSPC		;HOOK FOR NORMAL EXIT
H.CTLC::.WORD	RTSPC		;HOOK FOR CTRL/C EXIT
H.LOKF::.WORD	RTSPC		;HOOK FOR LOKFIL CALL
H.LOKE::.WORD	RTSPC		;HOOK FOR LOKFIL COMPLETE
H.READ::.WORD	RTSPC		;HOOK FOR READ CALL
H.WRIT::.WORD	RTSPC		;HOOK FOR WRITE CALL
	UNORG

	TMPORG	EXTPRC		;EXIT PROCESSOR

.ENABL	LSB

LEAVE::	TST	SYSMNT		;Special FUNKY SY0: stuff		;017
	BEQ	10$		; NO - so no special funky exit		;017
	CMP	SYSMNT,#-1	; But, did we do the funky stuff?	;017
	BEQ	10$		;  NO again, so no funky exit		;017
	CALLX	CLRFQB		;Start out clean			;017
	MOV	SYSMNT,XRB	; at this address			;017
	.PEEK			;  we must get the contents		;017
	TST	FIRQB		;But, did we?				;017
	BNE	20$		; NO - we failed :(			;017
	MOVB	#UU.POK,FIRQB+FQFUN ;Change UNTCNT value for SY0:	;017
	MOV	SYSMNT,FIRQB+FQFIL  ; at this address			;017
	MOV	XRB,FIRQB+FQPPN	    ;  to this value			;017
	BIS	#UC.WLO,FIRQB+FQPPN ; except make it R/O		;017
	.UUO			;OK Monitor, put out our info		;017
	TST	FIRQB		;But, did we?				;017
	BNE	20$		; NO - we failed :(			;017
	CALLX	CLRFQB		;Start out clean again			;017
	MOVB	#RSTFQ,FIRQB+FQFUN  ;We're off to do a reset		;017
	CALFIP			;	a wonderful reset of RSTS	;017
	TST	FIRQB		;But, did we?				;017
	BNE	20$		; NO - we failed :(			;017
	MOVB	#UU.DIE,FIRQB+FQFUN ; and prepare to goto INIT.SYS	;017
	MOV	#1,FIRQB+FQFIL	; but don't forget to come back!!!	;017
	.UUO			; - gone!				;017
20$:	MOV	FIRQB,R0	; CAN'T GET HERE!			;017
	HALT			;OOPS					;017

10$:	EXIT$S			;Reset channels and Exit		;007

.DSABL	LSB

	UNORG

	DEFORG	ONLINE

.ENABL	LSB

MESSAG::MOV	R0,-(SP)	;TYPE A MESSAGE
	MOV	(R5)+,R0	;R0 -> MESSAGE
	CALL	ASCIZ0		;PRINT IT
	MOV	(SP)+,R0	;RESTORE R0
	RETURN	R5

ASCIZ0::MOV	R2,-(SP)
10$:	CMP	R0,#FIRQB+40	;END OF FIRQB? (IF CALLED FROM X.ERPT)	;007
	BEQ	30$		;YES, END				;007
	MOVB	(R0)+,R2 	;NULL?
	BEQ	30$		;YES, END				
	CALLX	TYPE		;TYPE IT
	BR	10$

20$:	MOV	(R2),R2		;FOR SPECIAL TYPING, GET THE BYTES
	CALL	TYPE2		;DO THE TYPING (CALL TO 20$ SAVES R2)
30$:	MOV	(SP)+,R2	;RESTORE R2
	RETURN

RCTRLO::.TTRST			;RESET ^O FLAG				;007
	RETURN			;DONE

TYPECR::CALL	20$,R2		;TYPE <CR><LF> STRING
	 .BYTE	CR,LF		;THIS IS IT

TYPE2::	CALL	TYPE		;TYPE ONE
	SWAB	R2		;GET THE OTHER
	BEQ	RTSPC		;NO SECOND CHARACTER!
TYPE::	CMPB	R2,#176		;Ignore this character?			;000
	BEQ	RTSPC		;Yes, so do				;000
	CMPB	R2,#177		;RESET ^O HERE?
	BEQ	RCTRLO		;YUP, GO DO IT
	CMPB	R2,#200		;TYPE <CR><LF>?
	BEQ	TYPECR		;YES
	CALL	@H.TYPE		;** INTERCEPT ** R2=CHARACTER TO TYPE
	MOV	R2,TBUF		; CHAR TO WRITE				;007
	CALL	CLRXRB							;007
	MOV	#1,XRB+XRLEN						;007
	MOV	#1,XRB+XRBC						;007
	MOV	#TBUF,XRB+XRLOC	;WRITE FROM ONE WORD BUFFER		;007
	.WRITE								;007
RTSPC:	RETURN			;DONE

TYPTAB::CALL	20$,R2		;TYPE A TAB ONLY
	.BYTE	TAB,0

TBUF:	.WORD	0							;007

.DSABL	LSB


ASKER::	CALL	@H.ASK		;** INTERCEPT ** ASKER CALL
	MOV	(R5)+,20$	;GET SHORT FORM OF QUESTION
10$:	CALL	RCTRLO		;FORCE RESET OF ^O
	CALL	MESSAG,R5	;TYPE A MESSAGE
20$:	 .WORD	0		;MESSAGE TEXT POINTER
	MOV	(R5),20$	;PRESET LONG FORM IN CASE HELP NEEDED
	CALL	GETIN		;AND GET AN ANSWER
	BCS	30$		;Ctrl-Z? then return			;011
	BEQ	10$		;HE NEEDS HELP
30$:	ROR	-(SP)		;Save carry				;011
	TST	(R5)+		;POP OVER LONG FORM		
	ROL	(SP)+		;Restore carry				;011
	RETURN	R5		;AND EXIT				;011


GETUNQ::MOV	(R5)+,R0	;GET MATCH TEXT POINTER IN R0
	REGSAV			;SAVE REGISTERS
	MOV	R1,R4		;COPY POINTER TO PASSED TEXT
	CLR	(SP)		;CLEAR RETURNED R0
10$:	MOV	R4,R1		;RESTORE POINTER TO PASSED TEXT
20$:	MOVB	(R0)+,R3	;GET MATCH TEXT CHARACTER
	BIC	#^C<177>,R3	;ISOLATE IT
	CMPB	R3,(R1)+	;COMPARE AGAINST PASSED TEXT
	BEQ	20$		;GOT IT?
	TSTB	-(R0)		;NO MATCH. IS MATCH TEXT CHARACTER OPTIONAL?
	BMI	40$		;YES, WE PROBABLY FOUND IT
30$:	CMPB	(R0)+,#377	;NO, SKIP TO END OF THIS MATCH STRING
	BNE	30$
	ADD	#2,(SP)		;NEXT INDEX
	TSTB	(R0)		;ANY MORE MATCH TEXT?
	BNE	10$		;YES, TRY AGAIN
	SEC			;NO, INDICATE FAILURE IN CARRY
35$:	CALL	REGRES,R5	;RESTORE REGISTERS
	RETURN	R5		;BACK

40$:	TSTB	-(R1)		;FOUND DISCREPANCY AT OPTIONAL CHARACTER
	BEQ	60$		;THAT WAS THE END OF THE PASSED STRING
	CMPB	(R1),#40	;IT WASN'T THE END, SO GOTTA BE A BLANK
	BNE	30$		;NO LUCK, NOT THIS MATCH TEXT
50$:	CMPB	(R1)+,(R1)	;SCAN PAST N BLANKS
	BEQ	50$		;UNTIL R1 -> NOT A BLANK
60$:	MOVB	(R1)+,(R4)+	;MOVE THE REST OF THE STRING DOWN
	BNE	60$		;UNTIL END OF ASCIZ
	CLC			;C=0 FOR SUCCESS
	BR	35$		;GO BACK TO THE CALLER


.MACRO	UNQTXT	TEXT
.NLIST
.DSABL	CRF
$$$$$$	= 0
.IRPC	X,<TEXT>
.IF EQ	''X-'\
$$$$$$	= 200
.IFF
	 .BYTE	''X+$$$$$$
.ENDC
.ENDM
	 .BYTE	377
.ENABL	CRF
.LIST
.ENDM	UNQTXT

ANSWER::MOV	R0,-(SP)	;SAVE R0
	CALLX	GETUNQ,R5	;PARSE THE ANSWER
	 GENTXT
	 UNQTXT	<Y\ES>		;0 YES
	 UNQTXT	<N\O>		;2 NO
	 .BYTE	12,377		;4 <LF>
	 UNQTXT	<O\LD>		;6 OLD
	 .BYTE	0		;10 OTHER
	 UNORG
	ADD	R0,R5		;BUMP RETURN ADDRESS PROPERLY
	MOV	(SP)+,R0	;RESTORE R0
	RETURN	R5		;NOTE C=0 FROM ADD

.SBTTL	YES/NO CHECKER
;+
; YESNO - CHECK REPLY FOR YES OR NO
;
; CALL:	R1 -> STRING TO CHECK
;	CALL	YESNO,R5,<PTR TO SHORT TEXT, PTR TO LONG TEXT>
;
; BACK:	R5 + 0	IF ANSWER WAS ^Z
;	R5 + 2	IF ANSWER WAS <LF>
;	R5 + 4	IF ANSWER WAS NO
;	R5 + 6	IF ANSWER WAS YES
;-
.ENABL	LSB

YESNO::	MOV	(R5)+,20$	;GET TEXT POINTERS
	MOV	(R5)+,30$
10$:	CALL	ASKER,R5	;ASK THE QUESTION
20$:	 .WORD	0
30$:	 .WORD	0
	CALL	ANSWER,R5	;CHECK THE ANSWER
	 BR	40$		;YES
	 BR	50$		;NO
	 NOP			;<LF> ??
	 NOP			;OLD  ??
	MESSAG	<"Please answer 'YES' or 'NO'."<200>>			;002
	BR	10$

40$:	ADD	#2,R5		;BUMP RETURN FOR YES ANSWER
50$:	ADD	#4,R5		;BUMP RETURN FOR NO ANSWER
	RETURN	R5

.DSABL	LSB

.SBTTL	INPUT A LINE

GETIN::	CALL	@H.GETI		;** INTERCEPT ** GETIN GET INPUT LINE
	REGSAV
	CALL	INPLIN,R5,<KBUFF>				;007
	BCC	5$		; NO ERROR, BRANCH.		;007
	MOV	#"^Z,(R5)	; ASSUME CTRL-Z			;007
5$:	MOV	R5,TOS.R1(SP)	;RETURN TO CALLER IN R1		;007
	CMPB	(R5),#CR	;PURE <CR>?
	BNE	10$		;NO
	CLR	(R5)		;YES, NULL IT OUT
10$:	CMP	(R5),#LF	;PURE LINE FEED?
	BEQ	20$		;YUP, RETURN LINE FEED
	MOV	#4+10+20+40+200+1000,R0				;009
	CALLX	CVT$$		;TRIM ALL BUT PARITY
20$:	CMP	(R5),#"^Z	;FAKE CTRL/Z?
	BNE	30$		;NO
	CALLX	REGRES,R5	;Yes, restore registers		;011
	SEC			;Set carry			;011
	BR	50$		;And return			;011

30$:	CALLX	EQU$$,R4,70$	;CHECK FOR <LF>
	BNE	40$		;NOPE
	MOV	#12,KBUFF	;YES, RESET TO TRUE LINE FEED
40$:	CALLX	REGRES,R5	;RESTORE REGISTERS
	CMP	(R1),#"^C	;CONTROL C?
	BEQ	60$		;YES, TIME TO GO AWAY
	CMP	(R1),#'?	;QUESTION MARK?
	BEQ	50$		;YES, RETURN Z=1 (AND C=0)
	TSTB	(R1)		;NO, CHECK OUT <CR> ONLY (AND C=0)
50$:	RETURN

60$:	CALL	@H.CTLC		;** INTERCEPT ** EXIT DUE TO CTRL/C TYPED
	JMP	LEAVE		;Exit					;007

70$:	.ASCIZ	"<LF>"
	.EVEN
KBUFF::	.BLKB	100.

;+
; INPLIN - INPUT A LINE FROM THE TERMINAL
;
; CALL:	CALL	INPLIN,R5,<BUFFER>
;
; BACK:	R5 -> BUFFER
;	STRING READ FROM TELETYPE, TERMINATED WITH LF, ESC, OR FF
;	STRING MADE ASCIZ, BUT DELIMITER NOT STRIPPED
;
; NOTE:	NO SIZE CHECKING DONE
;-

INPLIN::MOV	R0,-(SP)	;SAVE R0			;007
	MOV	R5,-(SP)	;SAVE R5			;007
	MOV	(R5),R5		;R5 -> BUFFER			;007
10$:	CALL	X.TYIN		;GET A CHAR			;007
	BCS	30$		;CTRL-Z ??			;007
	MOVB	R0,(R5)+	;SET IT				;007
	CMPB	R0,#12		;LF?				;007
	BEQ	20$						;007
	CMPB	R0,#33		;ESC?				;007
	BEQ	20$						;007
	CMPB	R0,#14		;FF?				;007
	BNE	10$						;007
20$:	CLRB	(R5)		;SET TERMINATOR			;007
	MOV	(SP)+,R5	;RESTORE R5			;007
	MOV	(SP)+,R0	;RESTORE R0			;007
	MOV	(R5)+,(SP)	;RETURN R5 -> BUFFER		;007
	;CLC			;Clear from CLRB		;011
	RETURN	R5						;007

30$:	MOV	(SP)+,R5	; ERROR RETURN			;007
	MOV	(SP)+,R0					;007
	MOV	(R5)+,(SP)	; RETURN BUFFER ADDR IN R5	;007
	;SEC			;Can only get here by BCS	;011
	RETURN	R5						;007

;+
; X.TYIN - EMULATE THE RT11 .TTYIN CALL
;
;	CALLX	X.TYIN
;
;	R0 =  CHARACTER
;	XRB   IS DESTROYED
;
;	C=1 AND R0=0  IF ERROR ON READ (I.E. CONTROL Z)
;
;-


X.TYIN::CLR	-(SP)		;MAKE ROOM FOR THE CHARACTER ON THE STACK  ;007
	CALL	CLRXRB		;					   ;007
	MOV	#1,XRB+0	;SET ONE CHARACTER FOR READ     	   ;007
	MOV	SP,XRB+XRLOC	;BUFFER ADDRESS (THE STACK)		   ;007
	.READ			;READ ONE BYTE FROM THE TERMINAL 	   ;007
	TSTB	FIRQB		;ERROR?					   ;007
	BEQ	10$		;NO, CONTINUE 				   ;007
	CLR	(SP)		;YES, CLEAR ANY INPUT			   ;007
	SEC			; SET THE CARRY BIT TO FLAG THE ERROR	   ;007
10$:	MOV	(SP)+,R0	;PLACE THE CHARACTER INTO R0		   ;007
	RETURN			;AND RETURN TO THE CALLER		   ;007


.SBTTL	WAIT FOR TTY TO STOP
;+
; TTYSTP - WAIT FOR TTY TO STOP
;
; CALL:	CALL	TTYSTP
;
; BACK:	TTY IS DONE TYPING
;	DESTROYS R2
;-

GETTTY::
TTYSTP::RETURN			;YES

.SBTTL	OCTAL PRINTERS
;+
; OCTWRD - TYPE AN OCTAL NUMBER (6 DIGITS)
; OCTBYT - TYPE AN OCTAL BYTE (3 DIGITS)
; OCT3DG - TYPE 3-DIGIT OCTAL
; OCT4DG - TYPE 4-DIGIT OCTAL
;
; CALL:	R0 = NUMBER TO PRINT
;	CALL	OCT???
;
; BACK:	NUMBER HAS BEEN TYPED
;
; MODULES CALLED: TYPE
;-
.ENABL	LSB

OCTWRD::REGSCR			;SAVE REGS
	MOV	#6,R1		;COUNT IS 6
	BR	20$		;DO IT

OCT3DG::REGSCR			;SAVE REGS
	BR	10$		;AND DO 3 DIGITS

OCTBYT::REGSCR			;SAVE REGS
	BIC	#^C<377>,R0	;CLEAR OTHER BITS
10$:	MOV	#3,R1		;COUNT IS 3
20$:	MOV	#-1,-(SP)	;SET STOPPER FLAG
30$:	MOV	R0,-(SP)	;MOVE BITS TO STACK
	BIC	#^C<7>,(SP)	;ISOLATE BOTTOM OCTAL DIGIT
	ADD	#'0,(SP)	;MAKE IT ASCII
	;CLC			;ADD CLEARS THE CARRY
	ROR	R0		;SHIFT RIGHT 3 BITS
	ASR	R0
	ASR	R0
	SOB	R1,30$		;CONTINUE FOR ALL DIGITS
40$:	MOV	(SP)+,R2	;GET A DIGIT
	BMI	50$		;DONE
	CALL	TYPE		;TYPE IT
	BR	40$		;CONTINUE

50$:	RETURN

OCT4DG::REGSCR			;SAVE REGISTERS
	MOV	#4,R1		;PRINT LOW 4 DIGITS
	BR	20$

.DSABL	LSB

.SBTTL	DECIMAL PRINTERS
;+
; DECPRT - PRINT NUMBER IN DECIMAL WITH LEADING BLANKS
; DECZER - PRINT NUMBER IN DECIMAL, BLANK SUPPRESSED
; P4DDIG - PRINT 4-DIGIT NUMBER IN DECIMAL, BLANK FILL
;
; CALL:	R0 = NUMBER TO PRINT
;		CALL	DEC???
;
; DBLPRT - PRINT DOUBLE-PREC NUMBER IN DECIMAL, BLANK FILL
; DBLZER - PRINT DOUBLE-PREC NUMBER IN DECIMAL, NO BLANKS
;
; CALL:	R2 = LOW ORDER NUMBER
;	R3 = HIGH ORDER NUMBER IF DBLPRT OR DBLZER
;	CALL	DBL???
;
; BACK:	NUMBER HAS BEEN PRINTED AS SPECIFIED
;
; MODULES CALLED: TYPE
;-
.ENABL	LSB

DBLZER::REGSCR			;SAVE REGISTERS
	MOV	R2,R0		;COPY LOW ORDER TO SAFER PLACE
	BR	10$

DBLPRT::REGSCR			;SAVE REGISTERS
	MOV	R2,R0		;COPY LOW ORDER TO SAFER PLACE
	BR	20$

DECZER::REGSCR			;SAVE REGISTERS
	CLR	R3		;CLEAR HIGH ORDER
10$:	CLR	R5		;NO FILL CHARACTER
	BR	30$

P4DDIG::REGSCR			;SAVE REGISTERS
	MOV	#4-1*2,R4	;SET DIGIT COUNTER
	CLR	R3		;CLEAR HIGH ORDER
	MOV	#SPACE,R5	;FILL WITH BLANKS
	BR	40$

DECPRT::REGSCR			;SAVE REGISTERS
	CLR	R3		;CLEAR HIGH ORDER
20$:	MOV	#SPACE,R5	;FILL WITH BLANKS
30$:	MOV	#6-1*2,R4	;SET DIGIT COUNTER
40$:	MOV	#110$+<5*4>,R1	;POINT TO LIST FOR DIVISION
	SUB	R4,R1		;BACK UP BY DIGIT COUNT
	SUB	R4,R1
	ASR	R4		;SET DIGIT COUNT * 1
50$:	CLR	R2		;CLEAR QUOTIENT
60$:	SUB	(R1),R0		;SUBTRACT ONCE
	SBC	R3		; AND PROPAGATE
	SUB	2(R1),R3	;SUBTRACT FROM HIGH ORDER
	BMI	70$		;OVERFLOW EXITS LOOP
	INC	R2		;ONCE MORE
	BR	60$		;TRY ANOTHER SUBTRACTION

70$:	ADD	(R1)+,R0	;FIX BOGUS SUBTRACTION
	ADC	R3
	ADD	(R1)+,R3	;AND ADVANCE TABLE POINTER
	TST	R2		;0?
	BNE	80$		;NO, WE HAVE A DIGIT
	MOV	R5,R2		;YES, USE FILL CHARACTER
	BNE	90$		;IF THERE IS ONE
	BR	100$		;ELSE PUNT

80$:	MOV	#'0,R5		;WE ARE IN A NUMBER, 0 FILLS WITH 0
	ADD	R5,R2		;AND MAKE THE DIGIT INTO ASCII
90$:	CALL	TYPE		;TYPE A CHARACTER
100$:	SOB	R4,50$		;MAIN LOOP FOR ANOTHER DIGIT
	MOV	R0,R2		;FINAL DIGIT
	ADD	#'0,R2		;MAKE IT ASCII
	CALLR	TYPE		;TYPE IT
	;RETURN

110$:	.WORD	34464.,1.	;100000
	.WORD	10000.,0.	; 10000
	.WORD	 1000.,0.	;  1000
	.WORD	  100.,0.	;   100
	.WORD	   10.,0.	;    10
;	.WORD	    1.,0.	;     1

.DSABL	LSB

.SBTTL	RAD50 PRINTERS
;+
; RADPRT - PRINT RAD50 WORD
; RADZER - PRINT RAD50 WORD W/ BLANKS SUPPRESSED
;
; CALL:	R0 = RAD50 WORD
;	CALL	RAD???
;
; BACK:	RAD50 WORD HAS BEEN PRINTED
;
; MODULES CALLED: TYPE
;-
.ENABL	LSB

RADPRT::REGSCR			;SAVE REGISTERS
	MOV	#SPACE,R5	;FILLER IS SPACE FOR 0
	BR	10$

RADZER::REGSCR			;SAVE REGISTERS
	CLR	R5		;SUPPRESS SPACES
10$:	MOV	#100$,R1	;POINT TO TABLE OF DIVISORS
20$:	CLR	R2		;CLEAR QUOTIENT
30$:	SUB	(R1),R0		;SUBTRACT UNTIL OVERFLOW
	BLO	40$		;OVERFLOW, GET OUT
	INC	R2		;KEEP ANSWER GOING
	BR	30$

40$:	ADD	(R1)+,R0	;CORRECT OVERFLOW, ADVANCE TABLE
	TST	R2		;IS THE RESULT A SPACE?
	BNE	50$		;NO
	MOV	R5,R2		;YES, MAKE IT BLANK (MAYBE)
	BEQ	80$		;NO, IGNORE NULLS
	BR	70$		;YES, PRINT IT

50$:	CMP	R2,#26.		;ALPHABETIC?
	BHI	60$		;NO
	ADD	#'A-1,R2	;YES, MAKE IT ASCII
	BR	70$		;AND TYPE IT

60$:	MOVB	90$-27.(R2),R2	;GET SPECIAL CHARACTER OR DIGIT
70$:	CALL	TYPE		;TYPE IT AND RETURN
80$:	TST	(R1)		;ANY MORE TO DO?
	BNE	20$		;YES, LOOP ON IT
	RETURN

	I.MESS
90$:	.ASCII	"$.?0123456789"	;RAD50 TRANSLATION FOR 27.-39.
	UNORG

100$:	.WORD	50*50,50,1,0	;DIVISORS FOR RADIX 50 CONVERSION

.DSABL	LSB

.SBTTL	OCTAL & DECIMAL INPUTTERS
;+
; OCTINP - TRANSLATE AN OCTAL NUMBER
; DECINP - TRANSLATE A DECIMAL NUMBER
;
; CALL:	R1 -> STRING TO TRANSLATE
;	CALL ???INP
;
; BACK:	R0 = VALUE
;	R1 = UPDATED POINTER
;	CONDITION CODES SET FROM TSTB OF ENDING CHARACTER
;		(Z=1 MEANS NULL BYTE, USUALLY DESIRED)
;	SCAN STOPS ON CHARACTER ILLEGAL FOR SPECIFIED RADIX OR
;		IF OVERFLOW IS ENCOUNTERED
;-
OCTINP::TST	(PC)+		;CLEAR CARRY
DECINP::SEC			;SET CARRY
	REGSAV			;SAVE REGISTERS
	MOV	#4,R5		;R5 = RADIX/2
	ADC	R5		;10. IF ENTERED AT DECINP
	ASL	R5		;R5 = RADIX
	DEC	R5		;R5 = RADIX - 1
	CLR	R3		;CLEAR THE ACCUMULATOR
10$:	MOVB	(R1)+,R0	;GET NEXT BYTE
	SUB	#'0,R0		;CONVERT FROM ASCII
	BLO	30$		;NOT ASCII, SO RETURN
	CMP	R0,R5		;CHECK AGAINST RADIX
	BHI	30$		;TOO BIG TO BE A DIGIT
	MOV	R5,R4		;R4 = RADIX = # OF ADD LOOPS
	MOV	R3,R2		;R2 = ADDEND
20$:	ADD	R2,R3		;ADD IN FOR MULTIPLY
	BCS	30$		;OVERFLOW IS EVIL
	SOB	R4,20$		;ELSE LOOP
	ADD	R0,R3		;ADD IN NEW DIGIT
	BCC	10$		;GOOD, GO FOR ANOTHER BYTE
30$:	MOV	R3,TOS.R0(SP)	;RETURN VALUE IN R0
INPDNE:	MOV	R1,TOS.R1(SP)	;RETURN UPDATED POINTER IN R1
	CALLX	REGRES,R5	;RESTORE REGISTERS
	TSTB	-(R1)		;POINT TO UNUSED CHAR, SET CONDITION CODES
	RETURN

.SBTTL	DOUBLE PRECISION DECIMAL INPUTTER
;+
; DBLINP - SCAN OFF A DOUBLE PRECISION DECIMAL NUMBER
;
; CALL:	R1 -> STRING TO SCAN
;	CALL DBLINP
;
; BACK:	LOW ORDER VALUE IN R2, HIGH ORDER IN R3
;	OTHER RETURNS AS IN ???INP ABOVE
;-
DBLINP::REGSAV			;SAVE REGISTERS
	CLR	R2		;CLEAR ACCUMULATOR
	CLR	R3
10$:	MOVB	(R1)+,R0	;GET A DIGIT
	SUB	#'9+1,R0	;CHECK RANGE AND REDUCE IT
	ADD	#'9+1-'0,R0	;IS IT DECIMAL?
	BCC	20$		;NO
	ASL	R2		;* 2
	ROL	R3
	BCS	20$		;OVERFLOW
	MOV	R3,R5		;SAVE N*2 IN R4/R5
	MOV	R2,R4
	ASL	R2		;* 4
	ROL	R3
	BCS	20$
	ASL	R2		;* 8
	ROL	R3
	BCS	20$
	ADD	R4,R2		;N*8 + N*2 = N*10.
	ADC	R3
	BCS	20$
	ADD	R5,R3
	BCS	20$
	ADD	R0,R2		;ADD NEW DIGIT
	ADC	R3
	BCC	10$		;NO OVERFLOW IS GOOD
20$:	MOV	R2,TOS.R2(SP)	;SAVE ON STACK TO RETURN IN REGISTERS
	MOV	R3,TOS.R3(SP)
	BR	INPDNE		;GO RETURN PROPERLY


.SBTTL	RAD50 INPUTTER
;+
; RADINP - SCAN AND CONVERT 2 WORDS OF RADIX 50
; RADWRD - SCAN AND CONVERT 1 WORD  OF RADIX 50
;
; CALL:	R1 -> STRING TO SCAN
;	CALL	RAD???
;
; BACK:	FIRST WORD IN R0
;	SECOND IN R3 IF RADINP
;	R1 = UPDATED POINTER
;	SCAN STOPS AT FIRST NON-RAD50 CHARACTER OR AFTER 3 (OR 6)
;		CHARACTERS HAVE BEEN SCANNED
;-
.ENABL	LSB

RADINP::REGSCR			;SAVE REGISTERS
	CALL	RADWRD		;GET A WORD
	MOV	R0,TOS.R0(SP)	;RETURN IT IN R0 ON EXIT
	CALL	RADWRD		;GET ANUDDER
	MOV	R0,TOS.R3(SP)	;RETURN IT IN R3 ON EXIT
	BR	10$		;AND EXIT

RADWRD::REGSCR			;SAVE REGISTERS
	CLR	R3		;CLEAR RETURN VALUE
	MOV	#20$,R5		;A HANDY POINTER
	CALL	(R5)		;GET 3 CHARACTERS
	CALL	(R5)
	CALL	(R5)
	MOV	R3,TOS.R0(SP)	;RETURN ANSWER IN R0 ON EXIT
10$:	MOV	R1,TOS.R1(SP)	;UPDATE R1
	RETURN

20$:	MOVB	(R1),R0		;GET A CHARACTER
	SUB	#'9+1,R0	;CHECK FOR
	ADD	#'9+1-'0,R0	;  NUMBER (AND REDUCE BY '0)
	BCC	50$		;NO, GO TRY FOR LETTER
	ADD	#30.,R0		;YES, MAKE IT RADIX 50 NUMBER
30$:	INC	R1		;BUMP PAST ACCEPTED CHARACTER
40$:	MUL	#50,R3		;SHIFT OLD VALUE
	ADD	R0,R3		;ADD IN NEW LETTER
	RETURN

50$:	SUB	#'Z+1-'0,R0	;CHECK FOR
	ADD	#'Z+1-'A,R0	;  LETTER (AND REDUCE BY ('A)
	BCC	60$		;INVALID, USE BLANK FILL
	INC	R0		;CONVERT TO RADIX 50 LETTER
	BR	30$		;AND ACCEPT CHARACTER

60$:	CLR	R0		;USE BLANK
	BR	40$		;BUT DON'T SKIP CHARACTER

.DSABL	LSB

.SBTTL	ROOT FAKER

I.INI0::
I.INIT::CALL	@H.EXIT		;** INTERCEPT ** NORMAL PROGRAM EXIT
	.EXIT



.SBTTL	FAKE DATA

I.STAK	==	1000

SILNAM::.WORD	0,0

CTLOFG::.WORD	0


	.END

