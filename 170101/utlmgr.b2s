1	!******************************************************************** &
	!								      &
	!	p r o g r a m   t i t l e				      &
	!								      &
	!	   program : UTLMGR.B2S					      &
	!	   version : V10.1					      &
	!	      edit : A						      &
	!	 edit date : 10-MAY-91					      &
  	!	 author(s) : JJT,BGN,JAC,JFM,SEL			      &
	!								      &
	!******************************************************************** &
	!								      &
	!		  C O P Y R I G H T				      &
	!								      &
	!								      &
	!		      Copyright (C) 1983, 1991 by		      &
	!	Digital Equipment Corporation, Maynard, Mass.		      &
	!								      &
	!								      &
	! This software is furnished under a license and may be used and      &
	! copied  only  in accordance with the terms of such license and      &
	! with the  inclusion  of  the  above  copyright  notice.   This      &
	! software  or  any  other copies thereof may not be provided or      &
	! otherwise made available to any other person.  No title to and      &
	! ownership of the software is hereby transferred.		      &
	!								      &
	! The information in this software is subject to change  without      &
	! notice  and should not be construed as a commitment by Digital      &
	! Equipment Corporation.					      &
	!								      &
	! DIGITAL assumes no responsibility for the use  or  reliability      &
	! of its software on equipment that is not supplied by DIGITAL.	      &
	!								      &
	!******************************************************************** &
	!								      &
	!	m o d i f i c a t i o n   h i s t o r y   l o g		      &
	!								      &
	!								      &
	! VER/ED	EDIT DATE	REASON				      &
	!								      &
	! V9.1-04	07-Jun-85	(JJT) Add LOAD/INDEX and UNLOAD/INDEX &
	! V9.2-06	13-Feb-86	(JJT) Fix bug with LOGIN/TERMINAL     &
	! V9.6-03	18-Dec-87	(JJT) Add LAT/FMS commands	      &
	! V9.6-07	17-Feb-88	(JJT) Put REMOVE/JOB in its own module &
	! V9.6-08	26-Feb-88	(JJT) Remove SET/SHOW CONFIGURATION   &
	! V10.0-01	24-Aug-88	(JJT) Add SET SYSTEM/EMT, SHOW SYS/EMT &
	! V9.7-04	18-Jan-88	(JFM) Add virtual disk commands	      &
	! V10.0-A	13-Jul-89	(SEL) Add /OUTPUT to SHOW commands    &
	! V10.0-A	20-Jul-89	(SEL) Print to _NL: on NOOUTPUT	      &
	! V10.0-D	21-Sep-89	(SEL) Combine SHOW LOGI programs      &
	! V10.0-D	06-Oct-89	(SEL) Change /OUTPUT error trapping   &
	!					to only display the RSTS error &
	!								      &

									      &
									      &

10	!******************************************************************** &
	!								      &
	!	p r o g r a m   d e s c r i p t i o n			      &
	!								      &
	!	UTLMGR.B2S allows the system manager or a user with the	      &
	!	appropriate privileges to perform various device management   &
	!	operations, control the operation of the system and conduct   &
	!	time sharing operations. It uses the Common User Interface    &
	!	as its command parser.					      &
	!								      &
	!								      &
	!******************************************************************** &
	!								      &
	!	c h a n n e l   a s s i g n m e n t s			      &
	!								      &
	!	channel #	file-spec	description		      &
	!	=========	=========	===========		      &
	!								      &
	!	1		miscellaneous	Used to gain access to	      &
	!					user's file		      &
	!								      &
	!******************************************************************** &
	!								      &
	!	v a r i a b l e s  /  a r r a y s   u s e d		      &
	!								      &
	!	name		description				      &
	!	====		===========				      &
	!								      &
	!******************************************************************** &
	!								      &
	!	s u b r o u t i n e s   u s e d				      &
	!								      &
	!	name			description			      &
	!	====			===========			      &
	!	FET$P BY REF		fetch a parameter		      &
	!	FET$CQ BY REF		fetch command qualifier		      &
	!	FET$A BY REF		fetch a non-keyword argument	      &
	!	FET$KA BY REF		fetch a keyword argument	      &
	!	U.INI BY REF		initialize CUI tables		      &
	!	U.DIA BY REF		get user command via CUI	      &
	!	DISPLY			display the syntax errors	      &
	!	GETLOG			get the User-defined logicals	      &
	!								      &
	!								      &
	!								      &
	!								      &
	!								      &
	!								      &
	!								      &
	!								      &
	!								      &
	!								      &
	!								      &
	!								      &
	!								      &
	!******************************************************************** &
	!								      &
	!	f u n c t i o n s   u s e d				      &
	!								      &
	!	line #	name		description			      &
	!	======	====		===========			      &
	!								      &
	!	15010	FNCVT.LINE$	CONVERTS A LINE NUMBER TO A KEYWORD   &
	!	16000	FNF.TO.I%	PACK A FLOATING NUMBER TO	      &
	!				UNSIGNED INTEGER		      &
	!	16100	FNI.TO.F	CONVERT AN UNSIGNED INTEGER TO	      &
	!				FLOATING POINT NUMBER		      &
	!	16200	FNGET.SWAP%	RETURN SYSTEM FILE SPECIFICATION      &
	!								      &
	!	17100	FNPRINTCOLUMN%	PRINT COLUMNS OF ITEMS. DOES A	      &
	!				CR/LF WHEN NECESSARY.		      &
	!								      &
	!******************************************************************** &
	!								      &
	!	m a p   d e c l a r a t i o n s				      &
	!								      &
	!	line #	name	description				      &
	!	======	====	===========				      &
	!								      &
	!								      &
	!								      &
	!******************************************************************** &
	!								      &
	!	c o m m o n   d e c l a r a t i o n s			      &
	!								      &
	!	line #	name	description				      &
	!	======	====	===========				      &
	!	   700	CUICMN	CUI common data (%INCLUDE CUI:CUICMN.B2S)     &
	!	   700	UTYKEY	CUI constants (%INCLUDE SYSTEM:UTYKEY.B2S)    &
	!	   760	LOGICL	Buffer to store User-logicals		      &
	!								      &
	!******************************************************************** &

									      &
									      &

700	!	i n c l u d e   r e q u i r e d   M A P s , C O M M O N s     &
	!								      &
	!								      &
	%INCLUDE "CUI:CUICMN.B2S"		!include CUI data section     &
	%INCLUDE "SYSTEM:UTYKEY.B2S"		!include CUI common data      &

	!******************************************************************** &
	!								      &
	!	D E F I N E   C O N S T A N T S				      &
	!								      &
	!******************************************************************** &
									      &
	EXTERNAL WORD CONSTANT			! Define RSTS error codes:    &
						! (LB:ERR.STB)		      &
						!			      &
			CTRLCE,			!   ?programmable ^C trap     &
			EOF,			!   ?End of file	      &
			NODEVC,			!   ?Invalid device	      &
			PRVIOL			!   ?Protection violation     &

910	DIM	FIRQB%(30%)			!SYScall array		      &

1000	!	s e t   u p   f o r   R U N   e n t r y			      &
	!								      &
	!								      &
	I$="V10.1-A"							      &
\	UTY.VER$ = "10.0"			!UTLMGR program version	      &
\	UTY.EDT$ = ""				!UTLMGR program edit level    &
\	ENT.TY% = 0%				!init as a RUN entry	      &
\	HDNG% = -1%				!enable program heading	      &

									      &
									      &

2000	!	s e t   u p   f o r   c o m m a n d   p r o c e s s i n g     &
	!								      &
	!								      &
	ON ERROR GOTO 19000			!init standard error trap     &
									      &
\	DROP.PRIV$=CHR$(6%)+CHR$(-21%)+CHR$(255%)!DROP PRIVS STRING	      &
\	REGAIN.PRIV$=CHR$(6%)+CHR$(-21%)+CHR$(0%)!GAIN PRIVS STRING	      &
\	IF HDNG% THEN				!if heading enabled,	      &
		PRINT "UTLMGR "+I$+"   "+				      &
			     ERT$(0%)		!  print program heading      &
\		HDNG% = 0%			!  and clear heading flag     &

2100	CALL U.INI BY REF (U.CMN%,ENT.TY%)	!init CUI tables	      &
\	TERM.WIDTH%=ASCII(SEG$(SYS(CHR$(6%)+	!Get this KB's width	      &
		CHR$(16%)+CHR$(0%)+CHR$(255%)),5%,5%))-1%		      &
\	CHANGE SYS(CHR$(6%)+CHR$(26%)) TO FIRQB%!return job info	      &
\	JOB.NO% = FIRQB%(1%)/2%			!save user job no.	      &
\	KB.NO% = FIRQB%(4%)			!save user kb no.	      &
\	PPN% = FIRQB%(21%) + SWAP%(FIRQB%(22%))	!save user's PPN	      &
\	COLUMN1% = 4%				!beginning of first column    &
\	COLUMNWIDTH% = 8%			!width of a column	      &

									      &
									      &

3000	!								      &
	!	G E T   C O M M A N D					      &
	!								      &
\	ON ERROR GOTO 19000			! Ensure standard error trap  &
\	FIRQB%(I%) = 0% FOR I% = 1% TO 30%	! Clear the FIRQB array	      &
\	ERRSTS% = 0%				! Clear the error flag	      &
\	CLOSE #12%				! Close output channel	      &
\	V$ = SYS(CHR$(6%)+CHR$(-21%)+CHR$(255%))! Drop temp privs temporarily &
\	CALL U.DIA BY REF			!  get user command	      &
\	IF U.STAT% = 11% THEN			!  if EOF (CTRL/Z),	      &
		GOTO 32000			!    exit program	      &
	ELSE	IF U.STAT% <> 0%		!  else if any other error,   &
		GOTO 3000			!    reprompt		      &

									      &
									      &

4000	!	p r o c e s s     c o m m a n d s			      &
									      &
	V$ = SYS(DROP.PRIV$)			!MAKE SURE PRIVS ARE OFF      &
\	GOSUB 11020				!Check for /OUTPUT qualifier  &
\	SELECT	U.CMDC%				!SELECT THE GIVEN COMMAND     &
									      &

									      &
									      &

4100	  CASE	BRD.K%,				!BROADCAST		      &
		FOR.K%				!FORCE			      &
									      &
\	CALL UFORCE				!GO DO IT		      &

4200	  CASE	LGN.K%				!LOGIN			      &
									      &
\	CALL FET$P BY REF (PPN.T%)		!FETCH THE PPN		      &
\	PPN$ = ""				!INIT THE PPN		      &
\	IF U.PRES% THEN				!IF PRESENT		      &
		PPN$ = SEG$(U.STR$,1%,U.LEN%)	!  EXTRACT IT		      &
\		PPN.POS% = U.POS%		!  SAVE THE POSITION	      &
\		PPN$ = "[" + PPN$ IF INSTR(1%,PPN$,"[") = 0% !ADD [ IF NONE   &
\		PPN$ = PPN$ + "]" IF INSTR(1%,PPN$,"]") = 0% !ADD ] IF NONE   &
\	END IF								      &
\	SAVE.PPN$ = PPN$			!SAVE THE PPN AS IS	      &
\	S% = INSTR(1%,PPN$,"/")			!LOOK FOR A POSSIBLE SLASH    &
\	IF S% THEN				!IF THERE		      &
		PPN$ = LEFT(PPN$,S%-1%) + "," + RIGHT(PPN$,S%+1%) !PUT IN "," &
\	END IF								      &
\	IF LEN(PPN$) THEN			!IF A PPN WAS SPECIFIED	      &
		CHANGE FSS$(PPN$,1%) TO FIRQB%	!  FSS THE PPN		      &
\		PROJ% = FIRQB%(6%)		!  GET THE PROJECT #	      &
\		PROG% = FIRQB%(5%)		!  GET THE PROGRAMMER #	      &
\		FIRQB%(0%) = 30%		!  30 BYTES		      &
\		FIRQB%(1%) = 6%			!  SYS CALL TO FIP	      &
\		FIRQB%(2%) = 25%		!  WILDCARD PPN LOOKUP	      &
\		FIRQB%(I%) = 0% FOR I% = 3% TO 4% !NO INDEX		      &
\		FIRQB%(I%) = 0% FOR I% = 7% TO 22% !CLEAR UNUSED BYTES	      &
\		CHANGE FIRQB% TO FIRQB$		!  CHANGE THE ARRAY TO STRING &
\		ON ERROR GOTO 4250		!  SET LOCAL ERROR TRAP	      &
\		FIRQB$ = SYS(FIRQB$)		!  LOOKUP THE PPN	      &
\		ON ERROR GOTO 19000		!  RESET THE ERROR TRAP	      &
	ELSE					!IF PPN WAS NOT SPECIFIED     &
		PROJ% = SWAP%(PPN%) AND 255%	!  USE OUR PROJECT #	      &
\		PROG% = PPN% AND 255%		!  USE OUR PROGRAMMER #	      &
\	END IF								      &
\	DIFF.PPN% = 0%				!DEFAULT TO SAME PPN	      &
\	DIFF.PPN% = 32%				!SAY IT IS DIFFERENT	      &
		IF SWAP%(PROJ%) + PROG% <> PPN% !  IF IT IS		      &
\	TERM% = 0%				!INIT THE KB		      &
\	CALL FET$CQ BY REF (TER.Q%)		!/TERMINAL SPECIFIED?	      &
\	IF U.PRES% THEN				!IF PRESENT		      &
		CALL FET$A BY REF		!  GET THE KB NUMBER	      &
\		TERM.POS% = U.POS%		!  SAVE THE TERMINAL POS      &
\		TERM$ = SEG$(U.STR$,1%,U.LEN%)	!  EXTRACT IT		      &
\		TERM$ = TERM$ + ":" UNLESS INSTR(1%,TERM$,":") !ADD ":"	      &
\		CHANGE FSS$(TERM$,1%) TO FIRQB% !  FSS IT		      &
\		IF (STATUS AND 255%) <> 2% THEN	!  IF NOT A TERMINAL	      &
			CALL DISPLY("?Device is not a terminal")	      &
\			GOTO 3000		!    PRINT ERR AND EXIT	      &
\		END IF							      &
\		IF FIRQB%(26%) = 255% THEN	!  IF A KB # WAS SPECIFIED    &
			TERM% = FIRQB%(25%)	!    STORE IT		      &
		ELSE				!  IF JUST KB: WAS GIVEN      &
			TERM% = KB.NO%		!    STORE OUR KB #	      &
\		END IF							      &
\		TERM% = 128% IF TERM% = 0%	!  SPECIAL CASE KB0:	      &
\	END IF								      &
\	CALL FET$CQ BY REF(PRI.Q%)		!/PRIORITY SPECIFIED?	      &
\	PRIO% = -8%				!SET DEFAULT PRIORITY	      &
\	IF U.PRES% THEN				!IF PRESENT		      &
		IF TERM% = 0% THEN		!  IF /TERMINAL ISN'T THERE   &
			CALL DISPLY("?/TERMINAL qualifier required")	      &
\			GOTO 3000		!  SAY SO AND EXIT	      &
\		END IF							      &
\		CALL FET$A BY REF		!  GET THE PRIORITY	      &
\		PRIO% = VAL(SEG$(U.STR$,1%,U.LEN%)) !EXTRACT IT		      &
\		PRIO% = 255% UNLESS PRIO%	!  SPECIAL CASE PRIORITY 0    &
\	END IF								      &
\	CALL FET$CQ BY REF (RUN.Q%)		!/RUNBURST SPECIFIED?	      &
\	RUNB% = 6%				!SET DEFAULT RUNBURST	      &
\	IF U.PRES% THEN				!IF PRESENT		      &
		IF TERM% = 0% THEN		!  IF /TERMINAL ISN'T THERE   &
			CALL DISPLY("?/TERMINAL qualifier required")	      &
\			GOTO 3000		!  SAY SO AND EXIT	      &
\		END IF							      &
\		CALL FET$A BY REF		!  GET THE RUNBURST	      &
\		RUNB% = VAL(SEG$(U.STR$,1%,U.LEN%)) !EXTRACT IT		      &
\	END IF								      &
\	CALL FET$CQ BY REF (OVR.Q%)		!/OVERRIDE SPECIFIED	      &
\	OVER.NO.LOGINS% = 0%			!INIT VARIABLE TO FALSE	      &
\	IF U.PRES% THEN				!IF PRESENT		      &
		IF TERM% = 0% THEN		!  IF /TERMINAL ISN'T THERE   &
			CALL DISPLY("?/TERMINAL qualifier required")	      &
\			GOTO 3000		!  SAY SO AND EXIT	      &
\		END IF							      &
\		OVER.NO.LOGINS% = 128%		!  DEFAULT IS NOW TRUE	      &
\		CALL FET$KA BY REF (NOL.K%)	!  =NO_LOGINS SPECIFIED?      &
\		IF U.PRES% THEN			!  IF PRESENT		      &
			OVER.NO.LOGINS% = 128%	!    SET IT		      &
\		END IF							      &
\	END IF								      &
\	V$ = SYS(CHR$(8%)+"LOGIN " + SAVE.PPN$) !STUFF CORE COMMON	      &
		IF TERM% = 0%			! IF NO /TERMINAL	      &
\	CHAIN "$LOGIN" LINE 0			!GO TO LOGIN		      &
		IF TERM% = 0%			! IF NO /TERMINAL	      &
									      &
\	V$ = SYS(REGAIN.PRIV$)			!Turn on Temp privs	      &
\	CHANGE SYS(CHR$(6%)+CHR$(-25%)+CHR$(-1%)+CHR$(4%)+		      &
		CHR$(PROG%)+CHR$(PROJ%)) TO FIRQB%  ! Read login time info    &
\	V$ = SYS(DROP.PRIV$)			!Turn off Temp privs	      &
\	V$ = SYS(CHR$(8%)+"*UTLMGR*"+		!Start stuffing core common   &
		 CVT%$(FIRQB%(9%)+SWAP%(FIRQB%(10%)))+ !Date info	      &
		 CVT%$((FIRQB%(11%)+SWAP%(FIRQB%(12%))) AND 2047%) + !Time    &
		 CHR$(FIRQB%(8%)))		!and KB number		      &
									      &
\	CHANGE FSS$("_SY0:[1,2]LOGIN",1%) TO FIRQB% !PUT LOGIN IN THE FIRQB   &
\	FIRQB%(0%) = 30%			!30 BYTES		      &
\	FIRQB%(1%) = 6%				!SYS CALL TO FIP	      &
\	FIRQB%(2%) = 24%			!CREATE A JOB SUBFUNCTION     &
\	FIRQB%(3%) = 66% + DIFF.PPN% + OVER.NO.LOGINS% !CREATE A LOGGED-IN JOB &
\	FIRQB%(4%) = TERM%			!PUT IN THE KB #	      &
\	FIRQB%(I%) = -1% FOR I% = 11% TO 12%	!WILDCARD THE FILETYPE	      &
\	FIRQB%(13%) = PROG%			!PUT IN THE PROGRAMMER #      &
\	FIRQB%(14%) = PROJ%			!PUT IN THE PROJECT #	      &
\	FIRQB%(15%) = PRIO%			!PUT IN THE PRIORITY	      &
\	FIRQB%(16%) = RUNB%			!PUT IN THE RUNBURST	      &
\	FIRQB%(I%) = 0% FOR I% = 17% TO 22%	!CLEAR RESERVED BYTES	      &
\	FIRQB%(27%) = 0%			!LOW BYTE OF LINE #	      &
\	FIRQB%(28%) = 0%			!HIGH BYTE		      &
\	FIRQB%(I%) = 0% FOR I% = 29% TO 30%	!CLEAR MORE RESERVED BYTES    &
\	ON ERROR GOTO 4250			!SET LOCAL ERROR TRAP	      &
\	CHANGE FIRQB% TO FIRQB$			!CHANGE THE ARRAY TO A STRING &
\	CHANGE SYS(FIRQB$) TO FIRQB%		!DO THE SYS CALL	      &
\	ON ERROR GOTO 19000			!RESET THE ERROR TRAP	      &
\	V$ = SYS(CHR$(8%)+"")			!CLEAR CORE COMMON	      &
\	GOTO 3000				!GO GET THE NEXT COMMAND      &

4250	V$ = SYS(CHR$(8%)+"")			!CLEAR CORE COMMON	      &
\		IF ERR = 4% THEN		!?NO ROOM FOR USER ERROR      &
			PRINT "?Logins disabled"!  PRINT ERROR		      &
	ELSE	IF ERR = 5% THEN		!?CAN'T FIND FILE OR ACCOUNT  &
			U.POS% = PPN.POS%	!  RESTORE PARAMETER POSITION &
\			CALL DISPLY ("?Invalid account") !PRINT ERROR	      &
	ELSE	IF ERR = 8% THEN		!?DEVICE NOT AVAILABLE	      &
			U.POS% = TERM.POS%	!  RESTORE ARGUMENT POSITION  &
\			CALL DISPLY ("?Terminal not available") !PRINT ERROR  &
	ELSE	IF ERR = 10% THEN		!?PROTECTION VIOLATION	      &
			PRINT "?Insufficient privileges"! PRINT ERROR	      &
	ELSE	IF ERR = 69% THEN		!?QUOTA EXCEEDED	      &
			U.POS% = PPN.POS%	!  RESTORE PARAMETER POSITION &
\			CALL DISPLY ("?Job quota exceeded") !PRINT ERROR      &
	ELSE	GOTO 19000			!UNKNOWN ERROR		      &

4260	RESUME 3000				!GO GET THE NEXT COMMAND      &

									      &

4300	  CASE	ALO.K%,	 			!ALLOCATE		      &
		DAL.K%				!DEALLOCATE		      &
									      &
\	CALL UALLOC				!GO DO IT		      &

									      &
									      &

4400	  CASE	SJB.K%	 			!REMOVE/JOB		      &
									      &
\	CALL	UREMJB							      &

									      &
									      &

4500	  CASE	JOB.K%				!SET JOB		      &
									      &
\	CALL UJOB				!GO DO IT		      &


4600	  CASE	JDT.K%	 			!DETACH JOB		      &
									      &
\	CALL UDTACH				!GO DO IT		      &

									      &
									      &

4700	  CASE	HAN.K%	 			!HANGUP			      &
									      &
\	PRIV.NEED$ = "HWCTL"			!WE NEED HWCTL PRIV	      &
\	IF ASCII(SEG$(SYS(CHR$(6%)+CHR$(32%)+CHR$(1%)+ !IF WE DON'T HAVE      &
		STRING$(3%,0%)+PRIV.NEED$),3%,3%)) THEN! THE RIGHT PRIV	      &
		PRINT "?"+PRIV.NEED$+ " privilege required" !PRINT ERROR MESSAGE &
	ELSE								      &
		GOSUB 10010			!GO GET THE KB NUMBER	      &
\		GOTO 3000 IF K0% < 0%		!EXIT IF THERE WAS AN ERROR   &
\		V$ = SYS(CHR$(6%)+CHR$(-9%)+CHR$(K0%)+CHR$(2%))	!HANGUP THE KB &
\	END IF								      &

									      &
									      &

4800	  CASE	DAT.K%,				!SET DATE		      &
		TIM.K%				!SET TIME		      &
									      &
\	CALL UDATE				!GO DO IT		      &


4900	  CASE	DAY.K%	 			!SHOW DAYTIME		      &
									      &
\	PRINT DATE$(0%);" ";TIME$(0%)		!PRINT THE DATE AND TIME      &


5000	  CASE	DLP.K%,				!SET PRINTER		      &
		DEV.K%				!SET DEVICE		      &
									      &
\	CALL UDEV				!GO DO IT		      &


5200	  CASE	DRS.K%,	 			!INSTALL/RUNTIME_SYSTEM	      &
		KRS.K%,				!REMOVE/RUNTIME_SYSTEM	      &
		URS.K%,	 			!UNLOAD/RUNTIME_SYSTEM	      &
		DLB.K%,	 			!INSTALL/LIBRARY	      &
		KLB.K%,				!REMOVE/LIBRARY		      &
		ULB.K%,	 			!UNLOAD/LIBRARY		      &
	  	CVD.K%,				!CREATE/VIRTUAL_DISK	      &
		DVT.K%				!DELETE/VIRTUAL_DISK	      &
									      &
\	CALL URTS				!GO DO IT		      &


5400	  CASE	ASG.K%,	 			!ASSIGN/SYSTEM		      &
		DEA.K%				!DEASSIGN/SYSTEM	      &
									      &
\	CALL UASIGN				!GO DO IT		      &


5600	  CASE	DCM.K%,	 			!DEFINE/COMMAND/SYSTEM	      &
		KCM.K%				!DELETE/COMMAND/SYSTEM	      &
									      &
\	CALL UCMND				!GO DO IT		      &


5700	  CASE	COM.K%	 			!SHOW COMMAND/SYSTEM	      &
									      &
\	CALL USCMND				!GO DO IT		      &


5800	  CASE	CAC.K%,	 			!SET CACHE		      &
		DCC.K%,				!SET CACHE/DISABLE	      &
		SCC.K%	 			!SHOW CACHE		      &
									      &
\	CALL UCACHE				!GO DO IT		      &


5900	  CASE	FIL.K%	 			!SET FILE		      &
									      &
\	CALL UFILE				!GO DO IT		      &

6000	  CASE	LIX.K%,	 			!LOAD/INDEX		      &
		UIX.K%				!UNLOAD/INDEX		      &
									      &
\	CALL UINDEX							      &


6100	  CASE	JPV.K%	 			!SHOW JOB/PRIVILEGE	      &
									      &
\	CALL USHPRV				!GO DO IT		      &


6200	  CASE	INS.K%	 			!INSTALL FILE		      &
									      &
\	SETPRIV%(I%) = 0% FOR I% = 0% TO 3%	!CLEAR THE PRIV HOLDER ARRAY  &
\	CALL FET$P BY REF (INS.T%)		!GET THE FILENAME	      &
\	F$ = SEG$(U.STR$,1%,U.LEN%)		!EXTRACT IT		      &
\	PARM.POS% = U.POS%			!SAVE THE POS OF THE PARAMETER &
\	SUB.FUNC% = 1%				!DEFAULT TO INSTALL PERM FILE &
\	CHANGE FSS$(F$,1%) TO FIRQB%		!DO THE FILENAME STRING SCAN  &
\	WILD% = 0%				!DEFAULT TO NO WILDCARD SPEC  &
\	WILD% = -1% IF (FIRQB%(28%) AND 128%) = 128% !SET FLAG IF WILD	      &
\	IF (FIRQB%(29%) AND 8%) = 0% THEN 	!IF NO FILETYPE SPECIFIED     &
		FIRQB%(11%) = -17947% AND 255%	!PUT IN RAD-50 OF	      &
\		FIRQB%(12%) = SWAP%(-17947%) AND 255%!3 QUESTION MARKS	      &
\		WILD% = -1%			!SET THE WILDCARD SPEC	      &
\	END IF								      &
\	CALL FET$CQ BY REF (PRV.Q%)		!/PRIVILEGE SPECIFIED?	      &
\	IF U.PRES% THEN				!IF PRESENT		      &
		SUB.FUNC% = 2%			!  INSTALL PERM FILE W/PRIVS  &
\		IF NOT WILD% THEN		!  IF NO WILD CARD FILE SPEC  &
			FIRQB%(0%) = 30%	!  30 BYTES		      &
\			FIRQB%(1%) = 6%		!  SYS CALL TO FIP	      &
\			FIRQB%(2%) = 17%	!  DISK DIRECTORY LOOKUP CODE &
\			FIRQB%(I%) = 255% FOR I% = 3% TO 4%!LOOKUP BY FILENAME &
\			FIRQB%(I%) = 0% FOR I% = 13% TO 22%!CLEAR SOME BYTES  &
\			FIRQB%(I%) = 0% FOR I% = 27% TO 30%!CLEAR SOME MORE   &
\			CHANGE FIRQB% TO FIRQB$	!  CHANGE THE ARRAY TO STRING &
\			CHANGE SYS(FIRQB$) TO FIRQB%!DO THE SYS CALL	      &
\			IF FIRQB%(15%) < 192% THEN!IF NOT A PRIVILEGED PROGRAM &
						!  (PRIV BIT & EXECUTABLE BIT &
						!   SET IN PROTECTION CODE)   &
				U.POS% = PARM.POS%!    RESTORE THE POSITION   &
\			     CALL DISPLY ("?File is not a privileged program") &
\				GOTO 3000	!    PRINT ERROR AND GO BACK  &
\			END IF						      &
\		END IF							      &
\		CALL FET$A BY REF		!  GET FIRST PRIV	      &
\ INSPRIVLOOP:	CLR% = 0%			!  SET CLEAR FLAG TO NO CLEAR &
\		Z$ = SEG$(U.STR$,1%,U.LEN%)	!  EXTRACT THE PRIV	      &
\		Z$ = EDIT$(Z$,-2%)		!  REMOVE ALL JUNK	      &
\		GOTO INSCHECKPRIV IF U.LEN% <= 6%!  GO CHECK IT IF <= 6 CHARS &
						!  ELSE IT HAS TO BE NOpriv   &
\		IF SEG$(Z$,1%,2%) <> "NO" THEN	!  IF IT ISN'T NOpriv	      &
			CALL DISPLY ("?Invalid privilege")		      &
\			GOTO 3000		!    PRINT ERROR AND GO BACK  &
\		END IF							      &
\		CLR% = -1%			!  SET CLEAR FLAG	      &
\		Z$ = SEG$(Z$,2%,LEN(Z$))	!  STRIP OFF "NO"	      &
\ INSCHECKPRIV:	GOSUB 11000			!  GO CHECK OUT THE PRIV      &
\		IF ERRSTS% THEN			!  IF ERROR		      &
			IF SEG$(Z$,1%,2%) <> "NO" THEN	!  IF IT ISN'T NOpriv &
			     CALL DISPLY ("?Invalid privilege")		      &
\			     GOTO 3000		!      PRINT ERROR AND GO BACK &
\			END IF						      &
\			CLR% = -1%		!    SET CLEAR FLAG	      &
\			Z$ = SEG$(Z$,2%,LEN(Z$))!    STRIP OFF "NO"	      &
\			GOTO INSCHECKPRIV	!    GO CHECK OUT THE PRIV    &
\		END IF							      &
\		IF NOT CLR% THEN		!  IF NOT CLEAR (IF SET)      &
			SETPRIV%(I%) = SETPRIV%(I%) OR	!SET APPROPRIATE BITS &
			  ((FIRQB%((I%*2%)+7%) AND 255%) OR		      &
			  (SWAP%(FIRQB%((I%*2%)+8%) AND 255%)))		      &
				FOR I% = 0% TO 3%			      &
		ELSE				!    IF CLEAR		      &
			SETPRIV%(I%) = SETPRIV%(I%) AND!CLEAR APPROPRIATE BITS &
			NOT ((FIRQB%((I%*2%)+7%) AND 255%) OR		      &
			  (SWAP%(FIRQB%((I%*2%)+8%) AND 255%)))		      &
				FOR I% = 0% TO 3%			      &
\		END IF							      &
\		CALL FET$A BY REF		!  GET NEXT PRIV	      &
\		GOTO INSPRIVLOOP IF U.PRES%	!  GO CHECK IT OUT IF PRESENT &
\	END IF								      &
\	CALL FET$CQ BY REF (LIN.Q%)		!/LINE SPECIFIED?	      &
\	IF (WILD% = -1%) AND 			!IF WILD CARD SPEC AND	      &
	   (SUB.FUNC% <> 2%) AND		! NO /PRIVILEGE AND	      &
	   (NOT U.PRES%) THEN			! NO /LINE_NUMBER	      &
	      U.POS% = PARM.POS%		!  RESTORE THE POSITION	      &
\	      CALL DISPLY ("?Wildcard filespec not valid for permanent files") &
\	      GOTO 3000				!  PRINT ERROR AND GO BACK    &
\	END IF								      &
\	IF WILD% THEN				!IF WE HAVE A WILDCARD SPEC   &
		CHANGE FSS$(F$,1%) TO FIRQB%	!DO THE FILENAME STRING SCAN  &
\		IF (FIRQB%(29%) AND 8%) = 0% THEN !IF NO FILETYPE SPECIFIED   &
			FIRQB%(11%) = -17947% AND 255%	!PUT IN RAD-50 OF     &
\			FIRQB%(12%) = SWAP%(-17947%) AND 255%!3 QUESTION MARKS &
\		END IF							      &
\	END IF								      &
\	IF (SUB.FUNC% = 2%) OR			!IF (INSTALLING PRIV PROGRAM) &
	  ((SUB.FUNC% = 1%) AND			!  OR ((NON-PRIV PROGRAM) AND &
	   (NOT U.PRES%)) THEN			!  (/LINE IS NOT PRESENT))    &
		OPEN F$ FOR INPUT AS FILE 1% IF NOT WILD%!OPEN THE FILE	      &
						!	   IF NO WILDCARD     &
\		FIRQB%(0%) = 30%		!  30 BYTES		      &
\		FIRQB%(1%) = 6%			!  SYS CALL TO FIP	      &
\		FIRQB%(2%) = 30%		!  INSTALL FILE CODE	      &
\		FIRQB%(3%) = 1% IF NOT WILD%	! SET CHANNEL # IF NO WILDCARD &
\		FIRQB%(3%) = -1% IF WILD%	!  SET WILDCARD SPEC FUNCTION &
\		FIRQB%(4%) = SUB.FUNC%		!  STORE SUBFUNCTION	      &
\		IF SUB.FUNC% = 2% THEN		!  IF WE HAD PRIVS TO SET     &
			FIRQB%(15%) = SETPRIV%(0%) AND 255%! FIRST 8 PRIVS    &
\			FIRQB%(16%) = SWAP%(SETPRIV%(0%)) AND 255%! SECOND 8  &
\			FIRQB%(17%) = SETPRIV%(1%) AND 255%! THIRD 8 PRIVS    &
\			FIRQB%(18%) = SWAP%(SETPRIV%(1%)) AND 255% !FOURTH 8  &
\			FIRQB%(19%) = SETPRIV%(2%) AND 255%! FIFTH 8 PRIVS    &
\			FIRQB%(20%) = SWAP%(SETPRIV%(2%)) AND 255%! SIXTH 8   &
\			FIRQB%(21%) = SETPRIV%(3%) AND 255%! SEVENTH 8 PRIVS  &
\			FIRQB%(22%) = SWAP%(SETPRIV%(3%)) AND 255% !EIGHTH 8  &
\		END IF							      &
\		CHANGE FIRQB% TO FIRQB$		!  CHANGE THE ARRAY TO STRING &
\		FIRQB$ = SYS(FIRQB$)		!  DO THE SYSCALL	      &
\		CLOSE 1%			!  CLOSE THE FILE	      &
\	END IF								      &
\	IF U.PRES% THEN				!IF /LINE IS PRESENT	      &
		SUB.FUNC% = 3%			!  INSTALL ENTRY POINTS	      &
\		FIRQB%(I%) = 0% FOR I% = 15% TO 22% !CLEAR THE ENTRY POINTS   &
\		GOTO INSLINESYS IF U.NO%	!  GO DO IT IF /NOLINE_NUMBER &
\		I% = 0%				!  INITIALIZE COUNTER	      &
\		CALL FET$KA BY REF (CCL.K%)	!  =CCL SPECIFIED?	      &
\		IF U.PRES% THEN			!  IF PRESENT		      &
			I% = I% + 1%		!    BUMP COUNTER	      &
\			FIRQB%(2%*I%+13%) = 30000% AND 255%!STORE THE LINE    &
\			FIRQB%(2%*I%+14%) = SWAP%(30000%) AND 255%!NUMBER     &
\		END IF							      &
\		CALL FET$KA BY REF (DCL.K%)	!  =DCL SPECIFIED?	      &
\		IF U.PRES% THEN			!  IF PRESENT		      &
			I% = I% + 1%		!    BUMP COUNTER	      &
\			FIRQB%(2%*I%+13%) = 30500% AND 255%!STORE THE LINE    &
\			FIRQB%(2%*I%+14%) = SWAP%(30500%) AND 255%!NUMBER     &
\		END IF							      &
\		CALL FET$KA BY REF (CHN.K%)	!  =CHAIN SPECIFIED?	      &
\		IF U.PRES% THEN			!  IF PRESENT		      &
			I% = I% + 1%		!    BUMP COUNTER	      &
\			FIRQB%(2%*I%+13%) = 31000% AND 255%!STORE THE LINE    &
\			FIRQB%(2%*I%+14%) = SWAP%(31000%) AND 255%!NUMBER     &
\		END IF							      &
\ INSLINELOOP:	FOR I1% = I%+1% TO 4%		!  UP TO 4 POSSIBLE ENTRIES   &
\			CALL FET$A BY REF	!    GET THE ENTRY POINT      &
\			EXIT INSLINELOOP UNLESS U.PRES% !EXIT IF NO MORE      &
\			Z% = U.LOW%		!   GET THE NUMBER	      &
\			EXIT INSLINELOOP UNLESS Z% !EXIT UNLESS A VALUE	      &
\			FIRQB%(2*I1%+13%) = Z% AND 255% !STORE FIRST HALF     &
\			FIRQB%(2*I1%+14%) = SWAP%(Z%) AND 255% !STORE SECOND  &
\		NEXT I1%						      &
\		IF I1% = 4% THEN		!  IF WE HAD 4 ENTRIES	      &
			CALL FET$A BY REF	!    SEE IF THERE ARE ANY MORE &
\			IF U.PRES% THEN		!    IF THERE ARE	      &
				CALL DISPLY("%More than 4 entries specified") &
						!	PRINT WARNING MESSAGE &
\			END IF						      &
\		END IF							      &
\ INSLINESYS:	OPEN F$ FOR INPUT AS FILE 1% IF NOT WILD%!OPEN THE FILE	      &
						! IF NO WILDCARD	      &
\		FIRQB%(0%) = 30%		!30 BYTES		      &
\		FIRQB%(1%) = 6%			!SYS CALL TO FIP	      &
\		FIRQB%(2%) = 30%		!INSTALL FILE CODE	      &
\		FIRQB%(3%) = 1% IF NOT WILD%	!SET CHANNEL # IF NO WILDCARD &
\		FIRQB%(3%) = -1% IF WILD%	!SET WILDCARD SPEC FUNCTION   &
\		FIRQB%(4%) = SUB.FUNC%		!STORE SUBFUNCTION	      &
\		CHANGE FIRQB% TO FIRQB$		!CHANGE THE ARRAY TO A STRING &
\		FIRQB$ = SYS(FIRQB$)		!DO THE SYSCALL		      &
\		CLOSE 1%			!CLOSE THE FILE		      &
\	END IF								      &


6300	  CASE	SWI.K%	 			!SHOW INSTALL		      &
									      &
\	ALL% = 0%				!DEFAULT FLAG TO NOT ALL      &
\	CALL FET$CQ BY REF (ALL.Q%)		!/ALL SPECIFIED?	      &
\	IF U.PRES% THEN				!IF PRESENT		      &
		ALL% = -1%			!  SET THE FLAG		      &
	ELSE								      &
		CALL FET$P BY REF (INS.N%)	!  GET THE FILE TO LIST	      &
\		Z$ = SEG$(U.STR$,1%,U.LEN%)	!  EXTRACT IT		      &
\		Z$ = EDIT$(Z$,-2%)		!  REMOVE ALL JUNK	      &
\	END IF								      &
\	FOUND% = 0%				!DEFAULT TO NOT FOUND	      &
\	INDX% = 1%				!INIT THE INDEX TO 1	      &
\	ON ERROR GOTO 6320			!SET LOCAL ERROR TRAP	      &
\	SHOWINSLOOP:							      &
	WHILE 1% = 1%				!LOOP FOREVER		      &
\		CHANGE SYS(CHR$(6%)+CHR$(30%)+CHR$(0%)+!GET THE NEXT INSTALLED &
		  CHR$(4%)+CHR$(INDX%)+CHR$(SWAP%(INDX%))) TO FIRQB% !FILE    &
\		F$ = ""				!  INIT THE FILENAME VAR      &
\		F$ = F$ + RAD$(FIRQB%(I%)+SWAP%(FIRQB%(I%+1%)))		      &
			FOR I% = 7% TO 9% STEP 2% !GET THE FILENAME	      &
\		IF NOT ALL% THEN		!  IF NOT ALL FILES	      &
			ITERATE SHOWINSLOOP UNLESS SEG$(F$,1%,LEN(Z$)) = Z$   &
						!    GET NEXT FILE	      &
						!    UNLESS WE HAVE A MATCH   &
\		END IF							      &
\		PRINT TAB(10%);			!  MOVE TO 10TH COLUMN	      &
\		PRINT "[";NUM1$(FIRQB%(6%));",";NUM1$(FIRQB%(5%));"]";	      &
						!  PRINT PPN		      &
\		PRINT F$; "."; RAD$(FIRQB%(11%)+SWAP%(FIRQB%(12%)));	      &
						!  PRINT FILENAME AND TYPE    &
\		FIRQB%(I%) = FIRQB%(I%)+SWAP%(FIRQB%(I%+1%)) !MAKE WORDS OUT  &
				FOR I% = 23% TO 29% STEP 2%  !OF THE BYTES    &
\		IF FIRQB%(23%) = -1% THEN	! IF THERE AREN'T ENTRY POINTS &
			PRINT "/LINE=ALL"	!    PRINT ALL POINTS VALID   &
		ELSE				! IF THERE ARE ENTRY POINTS   &
			ENT.PNT$ = ""		!    INIT ENTRY POINT STRING  &
\			ENT.PNT$ = ENT.PNT$ +	!    APPEND TO THE STRING     &
			FNCVT.LINE$(FIRQB%(I%)) + ","	!    THE ENTRY POINT  &
				UNLESS FIRQB%(I%) = 0% !UNLESS IT IS ZERO     &
					FOR I% = 23% TO 29% STEP 2%	      &
\			ENT.PNT$ = SEG$(ENT.PNT$,1%,LEN(ENT.PNT$)-1%)	      &
			  IF SEG$(ENT.PNT$,LEN(ENT.PNT$),LEN(ENT.PNT$)) = "," &
						!    STRIP OFF TRAILING COMMA &
\			ENT.PNT$ = "ALL" IF LEN(ENT.PNT$) = 0% !ALL POINTS    &
						!    		ARE VALID     &
\			ENT.PNT$ = "(" + ENT.PNT$ + ")" !PUT ON ( )	      &
			  IF POS(ENT.PNT$,",",1%)!	IF MULTIPLE	      &
\			PRINT "/LINE="; ENT.PNT$!    PRINT THE ENTRY POINTS   &
\		END IF							      &
\		FIRQB%(I%) = FIRQB%(I%+8%) FOR I% = 7% TO 14% !MOVE THE PRIVS
6305		UNTIL 0%			!LOOP UNTIL WE HAVE AN ERROR  &
\			FIRQB%(0%) = 30%	!  30 BYTES		      &
\			FIRQB%(1%) = 6%		!  SYS CALL TO FIP	      &
\			FIRQB%(2%) = 32%	!  CHECK ACCESS FUNCTION CODE &
\			FIRQB%(3%) = 2%		!  CONVERT PRIV MASK TO NAME  &
\			FIRQB%(I%) = 0% FOR I% = 4% TO 6%! CLEAR OUT	      &
\			FIRQB%(I%) = 0% FOR I% = 15% TO 30%!CLEAR OUT MORE    &
\			CHANGE FIRQB% TO FIRQB$	!  CHANGE THE ARRAY TO STRING &
\			FIRQB$ = SYS(FIRQB$)	!  DO THE SYS CALL	      &
\			JUNK% = FNPRINTCOLUMN% (SEG$(FIRQB$,15%,20%))	      &
						!  PRINT THE PRIV NAME	      &
\			CHANGE FIRQB$ TO FIRQB%	!  CHANGE THE STRING TO ARRAY &
\		NEXT
6307		FOUND% = -1%			!  FLAG THAT WE FOUND ONE     &
\		INDX% = INDX% + 1%		!  INCREMENT INDEX	      &
\	NEXT								      &

6310	ON ERROR GOTO 19000			!RESET ERROR TRAP	      &
\	IF FOUND% = 0% THEN			!IF NO MATCHES FOUND	      &
		IF ALL% = 0% THEN		!  IF WE WANTED A MATCH	      &
			CALL DISPLY ("?File not installed")		      &
\			GOTO 3000		!    PRINT ERROR AND GO BACK  &
		ELSE							      &
			PRINT "%No files installed" !PRINT ERROR	      &
\			GOTO 3000		!    AND GO BACK	      &
\		END IF							      &
\	END IF								      &
\	GOTO 3000				!GET NEXT COMMAND	      &

6320	RESUME 6307 IF ERL = 6305		!CONTINUE IF NO MORE PRIVS    &
\	RESUME 6310				!CLEAR ERROR AND END	      &


6400	  CASE	DSW.K%,	 			!INSTALL/SWAPFILE	      &
		DER.K%,				!INSTALL/ERROR_FILE	      &
		DOV.K%,				!INSTALL/OVERLAY_FILE	      &
		KSP.K%,				!REMOVE/SWAP_FILE	      &
		KER.K%,				!REMOVE/ERROR_FILE	      &
		KOV.K%,				!REMOVE/OVERLAY_FILE	      &
		SWA.K%	 			!SHOW FILE/SYSTEM	      &
									      &
\	CALL USWAP				!GO DO IT		      &


6500	  CASE	DUM.K%	 			!DUMP/SYSTEM		      &
									      &
\	PRIV.NEED$ = "SYSIO"			!WE NEED SYSIO PRIV	      &
\	IF ASCII(SEG$(SYS(CHR$(6%)+CHR$(32%)+CHR$(1%)+ !IF WE DON'T HAVE      &
		STRING$(3%,0%)+PRIV.NEED$),3%,3%)) THEN! THE RIGHT PRIV	      &
		PRINT "?"+PRIV.NEED$+ " privilege required"! PRINT ERROR MESSAGE &
	ELSE								      &
		V$ = SYS(CHR$(6%)+CHR$(-27%))		!DO THE SYS CALL      &
\	END IF								      &


6600	  CASE	SYS.K%				!SET SYSTEM		      &
									      &
\	CALL FET$CQ BY REF (EMT.Q%)		!/EMT SPECIFIED?	      &
\	CALL UEMT IF U.PRES%			!CALL THAT MODULE IF PRESENT  &
\	CALL USYSTM				!DO THE REST OF SHOW SYSTEM   &


6700	CASE  REM.K%				!REMOVE FILE		      &
									      &
\	CALL FET$CQ BY REF (ALL.Q%)		!/ALL SPECIFIED?	      &
\	IF U.PRES% THEN				!IF PRESENT		      &
		V$ = SYS(CHR$(6%)+CHR$(30%))	!  REMOVE ALL INSTALLED FILES &
\		GOTO 3000			!  GO GET THE NEXT COMMAND    &
\	END IF								      &
\	CALL FET$P BY REF (INS.T%)		!GET THE FILENAME	      &
\	Z$ = SEG$(U.STR$,1%,U.LEN%)		!EXTRACT IT		      &
\	CHANGE FSS$(Z$,1%) TO FIRQB%		!DO THE FILENAME STRING SCAN  &
\	WILD% = 0%				!DEFAULT TO NO WILDCARD SPEC  &
\	WILD% = -1% IF (FIRQB%(28%) AND 128%) = 128% !SET FLAG IF WILD	      &
\	IF (FIRQB%(29%) AND 8%) = 0% THEN 	!IF NO FILETYPE SPECIFIED     &
		FIRQB%(11%) = -17947% AND 255%	!PUT IN RAD-50 OF	      &
\		FIRQB%(12%) = SWAP%(-17947%) AND 255%!3 QUESTION MARKS	      &
\		WILD% = -1%			!MAKE SURE FLAG IS SET	      &
\	END IF								      &
\	OPEN Z$ FOR INPUT AS FILE 1% IF NOT WILD%!OPEN THE FILE IF NO WILDSPEC &
\	FIRQB%(0%) = 30%			!30 BYTES		      &
\	FIRQB%(1%) = 6%				!SYS CALL TO FIP	      &
\	FIRQB%(2%) = 30%			!INSTALL FILE CODE	      &
\	FIRQB%(3%) = 1% IF NOT WILD%		!SET CHANNEL # IF NO WILDCARD &
\	FIRQB%(3%) = -1% IF WILD%		!SET WILDCARD SPEC FUNCTION   &
\	FIRQB%(4%) = 0%				!REMOVE FILE SUBFUNCTION      &
\	FIRQB%(I%) = 0% FOR I% = 13% TO 20%	!CLEAR OUT SOME OF THE ARRAY  &
\	FIRQB%(I%) = 0% FOR I% = 27% TO 30%	!CLEAR OUT SOME MORE	      &
\	CHANGE FIRQB% TO FIRQB$			!CHANGE THE ARRAY TO A STRING &
\	FIRQB$ = SYS(FIRQB$)			!REMOVE THE INSTALLED FILE    &
\	CLOSE 1%				!CLOSE THE FILE		      &
									      &


6800	  CASE	SLG.K%				!SHOW LOGICAL (USER/SYSTEM/ALL) &
									      &
\	CALL USHLOG				!GO DO IT		      &
									      &


6900	  CASE	SSY.K%				!SHOW SYSTEM		      &
									      &
\	CALL USHSYS				!GO DO IT		      &

6905	  CASE	SHM.K%				!SHOW SYSTEM/EMT	      &
									      &
\	CALL UEMT				!GO DO IT		      &
									      &


7000	  CASE	SDV.K%				!SHOW DEVICE		      &
									      &
\	CALL USHDEV				!GO DO IT		      &


7100	  CASE	SLP.K%				!SHOW PRINTER		      &
									      &
\	CALL USHLPD				!GO DO IT		      &


7200	  CASE	LOV.K%,				!LOAD/OVERLAY		      &
		UOV.K%				!UNLOAD/OVERLAY		      &
									      &
\	CALL UOVRLY				!GO DO IT		      &

8900	  CASE ELSE				!DISPATCHING ERROR	      &
									      &
\	U.POS% = 1%							      &
\	CALL DISPLY ("?UTLMGR dispatching error")			      &
									      &
\	END SELECT	 			!END OF THE COMMANDS	      &
\	GOTO 3000	 			!GET NEXT COMMAND	      &


10000	!								      &
	!	S U B R O U T I N E S					      &
	!								      &
	CALL FET$CQ BY REF (ALL.Q%)		!/ALL SPECIFIED?	      &
\	IF U.PRES% THEN				!IF PRESENT		      &
		CHANGE SYS(CHR$(6%)+CHR$(-3%)) TO FIRQB% !GET MONITOR TABLES I &
\		K0% = 0%			!  FIRST KB IS KB0:	      &
\		K1% = FIRQB%(3%)		!  HIGHEST KB NUMBER	      &
\		RETURN				!  GO BACK		      &

10010	K0% = -1%				!DEFAULT TO ERROR	      &
\	CALL FET$P BY REF (KB.T%)		!GET THE KEYBOARD	      &
\	Z$ = SEG$(U.STR$,1%,U.LEN%)		!EXTRACT IT		      &
\	Z$ = Z$ + ":" UNLESS POS(Z$,":",1%)	!APPEND A COLON IF NONE THERE &
\	KB$ = EDIT$(Z$,-2%)			!STORE THE KB		      &
\	V$ = FSS$(KB$,1%)			!DO THE FILENAME STRING SCAN  &
\	IF (STATUS AND 255%) <> 2% THEN		!IF NOT A KB		      &
		CALL DISPLY ("?Device is not a terminal")		      &
\		RETURN				!  PRINT ERROR AND GO BACK    &
\	END IF								      &
\	KB% = KB.NO%				!DEFAULT TO OUR OWN KB	      &
\	IF ASCII(SEG$(V$,26%,26%)) <> 0% THEN	!IF A UNIT NUMBER SPECIFIED   &
		KB% = ASCII(SEG$(V$,25%,25%))	!  GET KB NUMBER	      &
\	END IF								      &
\	IF KB% = KB.NO% THEN			!IF OUR OWN KEYBOARD	      &
		CALL DISPLY ("?Own Keyboard not allowed")		      &
\		RETURN				!  PRINT ERROR AND GO BACK    &
\	END IF								      &
\	K0%, K1% = KB%				!RETURN THE KB NUMBER	      &
\	RETURN					!GO BACK		      &


11000	ERRSTS% = 0%				!DEFAULT TO NO ERRORS	      &
\	IF Z$ = "ALL" THEN			!IF SET ALL PRIVILEGES	      &
		FIRQB%(I%) = 255% FOR I% = 7% TO 14% !SET ALL PRIVILEGES      &
\		CLR% = 0%			!     CLEAR THE CLEAR FLAG    &
\		RETURN				!     GO BACK		      &
\	END IF								      &
\	IF Z$ = "NONE" THEN			!IF CLEAR ALL PRIVILEGES      &
		FIRQB%(I%) = 255% FOR I% = 7% TO 14% !SET ALL PRIVILEGES      &
\		CLR% = -1%			!     SET THE CLEAR FLAG      &
\		RETURN				!     GO BACK		      &
\	END IF								      &
\	ON ERROR GOTO 11010			!SET LOCAL ERROR TRAP	      &
\	CHANGE SYS(CHR$(6%)+CHR$(32%)+CHR$(1%)+STRING$(3%,0%)+Z$) TO FIRQB%   &
						!CONVERT PRIV NAME TO MASK    &
\	ON ERROR GOTO 19000			!RESET ERROR TRAP	      &
\	RETURN					!GO BACK		      &

11010	RESUME 11015				!CLEAR ERROR
11015	ERRSTS% = -1%				!SET ERROR FLAG		      &
\	ON ERROR GOTO 19000			!RESET ERROR TRAP	      &
\	RETURN					!GO BACK		      &

11020	OUT.CHN% = 0%				!Default output to KB:	      &
\	CALL FET$CQ BY REF (OUT.Q%)		!/OUTPUT?		      &
\	RETURN IF NOT U.PRES%			! Nope, so output to KB:      &
\	IF U.NO% THEN				! /NOOUTPUT?		      &
	   OPEN "_NL:" FOR OUTPUT AS FILE 12% 	! Yup, so open null device    &
	ELSE								      &
	   CALL FET$A BY REF			! /OUTPUT=FILENAME?	      &
\  	   RETURN IF NOT U.PRES%		! Nope, so output to KB:      &
\	   ON ERROR GOTO 11030			! Set up local error trap     &
\	   OPEN SEG$(U.STR$,1%,U.LEN%) FOR OUTPUT AS FILE 12%		      &
\	   CAUSE ERROR NODEVC			! Don't use it if...	      &
		IF STATUS AND 256%              !     device is NFS...	      &
		UNLESS STATUS AND 2048%		!     unless CCPOS() is valid &
\	   CAUSE ERROR PRVIOL			! Don't use it if...	      &
		IF STATUS AND 1024%             !       we don't have access  &
\	   ON ERROR GOTO 19000			! Ensure standard error trap  &
\	END IF					! File okay		      &
\	OUT.CHN% = 12%				! Channel # to pass to subprgms &

11025	RETURN					! Go back		      &

11030	CALL DISPLY (ERT$(ERR)) 		! Print error		      &
\	RESUME 3000				! Exit program		      &

									      &

15000	!								      &
	!	F U N C T I O N S					      &
	!								      &

15010	DEF FNCVT.LINE$(Q%)						      &
	!								      &
	! FUNCTION:	FNCVT.LINE$	RETURN LINE NUMBER KEYWORD OF	      &
	!				LINE NUMBER Q%			      &
	! INPUT:			LINE NUMBER			      &
	! RETURNS:			1) CCL IF LINE NUMBER = 30000	      &
	!				2) DCL IF LINE NUMBER = 30500	      &
	!				3) CHAIN IF LINE NUMBER = 31000	      &
	!				4) LINE NUMBER IF NO MATCH	      &
	!								      &
\	FNCVT.LINE$ = NUM1$(Q%)		!DEFAULT TO THE LINE NUMBER	      &
\	FNCVT.LINE$ = "CCL" IF Q% = 30000%! CCL LINE NUMBER		      &
\	FNCVT.LINE$ = "DCL" IF Q% = 30500%! DCL LINE NUMBER		      &
\	FNCVT.LINE$ = "CHAIN" IF Q% = 31000% ! CHAIN LINE NUMBER	      &
\	FNEND								      &

									      &
									      &

17100	! FNPRINTCOLUMN% (TEXT$) -- Print text in next available column.      &
	! Inputs:							      &
	!	TEXT$ -- The text to print				      &
	!	TERM.WIDTH% -- Width of screen				      &
	!	CCPOS(0%) -- Current cursor position			      &
	! Effect:							      &
	!	If there isn't room for another column, <CR><LF> is	      &
	!	printed and the cursor is advanced to the left margin.	      &
	!	Otherwise cursor is advanced to next column (i.e. position of &
	!	first column plus n * width of a column).		      &
	!	Text is printed.					      &
	! Value: Meaningless.						      &

17110	DEF FNPRINTCOLUMN% (TEXT$)					      &
	\ CURSOR% = CCPOS(0%)		! Get current cursor position.	      &
	\ IF CURSOR% < COLUMN1% THEN	! If cursor is left of first column of &
					! text then			      &
		PRINT SPACE$ (COLUMN1% - CURSOR%);			      &
					!   Move cursor to first column of    &
					!   text.			      &
		\ GOTO 17140		!   Go print text.		      &

17120	NEXTCOLUMN% = ((CURSOR%-COLUMN1%)/COLUMNWIDTH%)*COLUMNWIDTH% +	      &
	COLUMNWIDTH% + COLUMN1%		! Compute position of next text column. &
	\ PAD% = NEXTCOLUMN% - CURSOR%	! Compute spaces needed to pad cursor &
					! to next column.		      &
									      &
	\ IF (NEXTCOLUMN% + COLUMNWIDTH%) > TERM.WIDTH% THEN		      &
					! If there isn't room for another     &
					! column then			      &
		PRINT			!   Go to next line of screen.	      &
		\ PRINT SPACE$ (COLUMN1%);!  Move cursor to first column of   &
					!   text.			      &
		\ GOTO 17140		!   Go print text.		      &

17130	PRINT SPACE$ (PAD%);		! Pad cursor out to next column.      &

17140	PRINT TEXT$;			! Print the text.		      &
	\ FNEND								      &


19000	!	s t a n d a r d   e r r o r   h a n d l i n g		      &
	!								      &
	!								      &
	PRINT ERT$(ERR)							      &
					!print fatal error msg		      &
\	RESUME 3000			!resume to get next command	      &


30500	!	D C L   e n t r y   p o i n t				      &
	!								      &
	!								      &
	ENT.TY% = 16%				!set DCL entry type	      &
\	HDNG% = 0%				!no program heading	      &
\	GOTO 2000				!and branch to main	      &


31000	!	C H A I N   e n t r y   p o i n t			      &
	!								      &
	!								      &
	ENT.TY% = 2%				!set CHAIN entry type	      &
\	HDNG% = 0%				!no program heading	      &
\	GOTO 2000				!and branch to main	      &


32000	!	e n d - o f - p r o g r a m   p r o c e s s i n g	      &
	!								      &
	!								      &
	CLOSE #Z% FOR Z% = 1% TO 12%		!close all channels	      &
\	Z$ = SYS (CHR$(9%))			!exit to user's KBM	      &


32767	END
