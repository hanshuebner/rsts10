2!		PROGRAM		: ANALY1.B2S
5!		VERSION		: V10.1
6!		EDIT		: L
7!		EDIT DATE	: 10-AUG-92
10	EXTEND
11	!								      &
									      &
									      &
	!		  C O P Y R I G H T				      &
									      &
									      &
  !		      Copyright (C) 1974, 1992 by			      &
  !	        Digital Equipment Corporation, Maynard, Mass.		      &
  !									      &
  !									      &
  !	This software is furnished under a license and may be used and	      &
  !	copied  only  in accordance with the terms of such license and	      &
  !	with the  inclusion  of  the  above  copyright  notice.   This	      &
  !	software  or  any  other copies thereof may not be provided or	      &
  !	otherwise made available to any other person.  No title to and	      &
  !	ownership of the software is hereby transferred.		      &
  !									      &
  !	The information in this software is subject to change  without	      &
  !	notice  and should not be construed as a commitment by Digital	      &
  !	Equipment Corporation.						      &
  !									      &
  !	DIGITAL assumes no responsibility for the use  or  reliability	      &
  !	of its software on equipment that is not supplied by DIGITAL.	      &
  !									      &
  !*******************************************************************	      &
									      &

20	!								      &
									      &
									      &
	!	M O D I F I C A T I O N    H I S T O R Y		      &
									      &
									      &
	! VER/ED	EDIT DATE	REASON				      &
	!								      &
	! DLS 9.1-05	28-Aug-85	Add LDX to comment field for disks    &
	! DLS 9.2-06	12-Mar-86	Put a space in front of LDX	      &
	! REG 9.3	12-Jan-87	NFS disks can not be DLA/DLW	      &
	! REG 9.4	03-APR-87	EXPAND SYMBOL ARRAYS		      &
	! REG 9.4	18-MAY-87	EXPAND SILMOD ARRAY TO 50 ENTRIES     &
	! REG 9.6	27-JAN-88	Fix SY/B and PK displays	      &
	! REG 9.6	07-APR-88	Merge in FK's changes		      &
	! REG 9.7	21-MAR-89	Enlarge SILMOD array from 50 to 255.  &
	! FEK 9.7	27-Mar-89	Enlarge DEC%(), Update DECnet stuff.  &
	!				and enlarge annotations arrays	      &
	! REG 9.7	23-Jul-89	Add FEK's SYSTAT up-time format	      &
	! 				and KB exclamation/asterisk notation  &
	! REG 10.0	28-OCT-89	Add open files SYSTAT display	      &
	! REG 10.0	28-Oct-89	Add SHOW DEVICE and SHOW CACHE	      &
	! REG 10.0	05-Feb-90	Fix DV0:/locked-out bug		      &
	! REG 10.0	27-Mar-90	Update LAT info for DP's changes      &
	! REG 10.0	04-MAY-90	Fix SHOW DEV KB's/FAKDDB	      &
	! REG 10.0	08-Jun-90	Fix JHEAD, FJHEAD		      &
	! REG 10.0	28-Jun-90	Fix open file PPN's		      &
	! REG 10.1	01-Nov-90	Add error trap for invalid time (514) &
	! FEK 10.1	11-Jul-91	Always display SHOW DEVICE + SHOW CAC &
	! DSD 10.1	18-Dec-91	Fix display of LAT sessions	      &

100	!								      &
									      &
									      &
	!	G E N E R A L    D E S C R I P T I O N			      &
									      &
									      &
   !	 ANALYS is a crash dump analyzer program  which  provides  the	      &
   !	 system manager with the means to decode/retain information in	      &
   !	 the CRASH.SYS file.						      &
   !									      &
   !	 After outputting the equivalent of both a SYSTAT  report  and	      &
   !	 NIP  report,  ANALYS  chains to ANALY1, which outputs message	      &
   !	 receiver info, a core  dump,  extracts/formats  messages  for	      &
   !	 ERRCPY  and appends a full crash error log file report to the	      &
   !	 regular ANALYS report.						      &
   !									      &
   !	 A short report (no core dump of monitor) may be  obtained  by	      &
   !	 specifying "/NODUMP" after the output file name.		      &
   !									      &
   !	 An  annotated  core  dump (both octal and annotations) may be	      &
   !	 obtained by  specifying  "/WIDE"  after the output file name.	      &
   !									      &
   !	 An  annotated  core  dump  without  the octal contents may be	      &
   !	 obtained by specifying /ALPHA.					      &
   !									      &
   !	 A  report  containing  only  the  equivalent of a SYS/F (free	      &
   !	 buffers) plus  the  alpha  only core dump may be obtained  by	      &
   !	 specifying /BUFFERS.						      &
   !									      &
   !	 "/NARROW" is equivalent to not specifying any switch - it  is	      &
   !	 included to allow a user to override the default if /WIDE  is	      &
   !	 made the default via an optional patch.			      &
   !									      &
	!								      &
									      &
									      &
	!	I / O    C H A N N E L S				      &
									      &
									      &
   !	CHANNEL #		USED FOR				      &
   !	   1			OUTPUT					      &
   !	   3			.SIL FILE				      &
   !	   8			CRASH ERROR LOG FILE			      &
   !	  10			WORK1-FILE				      &
   !	  12			CRASH FILE				      &
									      &

400	!								      &
									      &
									      &
	!	V A R I A B L E    D E F I N I T I O N S		      &
									      &
									      &
									      &
   !	VARIABLE NAME		USED FOR				      &
   !									      &
   !	A%()		USED FOR SYS CALLS				      &
   !	AD		USED IN FNPEEK FUNCTION				      &
   !	ADD.BLOCK%,ADD.OFFSET% USED IN FNPEEK FUNCTION			      &
   !	ANNOT%		COUNT OF ANNOTATION SYMBOLS			      &
   !	B$,B%		UTILITY VARIABLES				      &
   !	BASE.BLOCK%	USED IN FNPEEK FUNCTION				      &
   !	C%		UTILITY VARIABLE				      &
   !	C$		CARRIAGE RETURN/LINE FEED			      &
   !	C0%		UTILITY VARIABLE				      &
   !	CC%()		WORK FILE STORAGE AREA				      &
   !	CHN%		CHANNEL # * 2					      &
   !	COM$		NODE COMMENTS STRING				      &
   !	CR.LOGFIL$	CRASH ERROR LOGGING FILE (ERRCRS.FIL)		      &
   !	D%		DDB POINTER, UTILITY VARIABLE			      &
   !	D$		CRASH FILE I/O BUFFER				      &
   !	D.UMP%		CORE DUMP/NODUMP INDICATOR			      &
   !			0 = no core dump				      &
   !			1 = include a core dump				      &
   !			2 = Don't include XBUF in the dump		      &
   !	DDB%		BASE OF A DMC-11 DDB				      &
   !	DDJBNO%		DDB JOB #					      &
   !	DEC%()		USED TO EXTRACT DECNET/E INFO			      &
   !	DECNET%		COUNT OF SYMBOLS NEEDED FOR DECNET/E		      &
   !	DIAGNOSE%	USED FOR MAINTENANCE ONLY			      &
   !	DMC$		DMC-11 LINE OR ROUTER NAME			      &
   !	DMC%		DMC-11 LINE #					      &
   !	DRV.IDX%	DRIVER INDEX					      &
   !	E$		ERROR MESSAGE HOLDER				      &
   !	E%		ERROR VARIABLE					      &
   !	EPMM		$$EPMM AS AN UNSIGNED INTEGER.			      &
   !	F%		R.FLAG						      &
   !	F%(,)		MAPS CRASH FILE TO MEMORY LOCATIONS		      &
   !	FCB%		FILE CONTROL BLOCK POINTER			      &
   !	FCBLST%,FIJBDA%,FIJOB% POINTERS TO TABLES			      &
   !	FILE.NAME$()	NAMES OF WORK FILES				      &
   !	FIP.UNT%	FIP UNIT NUMBER					      &
   !	FPL.SEG%	FIP POOL DUMP SEGMENT NUMBER			      &
   !	FPLAP6%		MAPPING ADDRESS FOR FIP				      &
   !	FPL.ST		FIP POOL ADDRESS AS AN UNSIGNED INTEGER		      &
   !	FPL.END		UPPER FIP POOL LIMIT AS AN UNSIGNED INTEGER	      &
   !	FLW%		FLOW CONTROL FLAG WORD				      &
   !	FRE%		FIRST RETRIEVAL ENTRY				      &
   !	FXMONS%		MONITOR SEGMENT SIZE				      &
   !	G%(),G$(),G0%(),G0$() SYMBOL AND ANNOTATION ARRAYS		      &
   !	GET.NUM%	INDICATES WHETHER OR NOT A LINK # HAS TO BE	      &
   !			EXTRACTED FROM AN LLA				      &
   !	HAND.IDX%	DEVICE HANDLER INDEX NO.			      &
   !	HD%		PRINT HEADER FLAG; ITEM FOUND/NOT FOUND FLAG	      &
   !	I$		VERSION/EDIT #					      &
   !	I%		UTILITY VARIABLE				      &
   !	I0$		INPUT FILE					      &
   !	INTFAC%		INTERFACE TYPE					      &
   !	J%,J1%,J2%,J3%,J4%,J5%,J6% UTILITY VARIABLES			      &
   !	JDB%		MAIN JOB DATA BLOCK				      &
   !	JDPPN%		PPN OF JOB BEING SCANNED			      &
   !	JOB$		JOB # STRING					      &
   !	KB.DDB%		KB DDB OF JOB BEING SCANNED			      &
   !	LCNT.MX%	LOGICAL LINK COUNT/MAX ALLOWED			      &
   !	LINK%		LINK #						      &
   !	LIR%,LIR$	LOCAL INTERRUPT REQUESTS			      &
   !	LLA%		LOCAL LINK ADDRESS (LLA)			      &
   !	LLB%		BASE OF A LOGICAL LINK BLOCK (LLB)		      &
   !	LLT.FLG%	LOW ORDER LLT.FLG% BITS OF AN LLA CONTAIN THE LINK #  &
   !	LLX%		BASE OF AN LLB EXTENSION			      &
   !	LM$		LINK COUNT/MAX					      &
   !	M%(),M2%()	MISCELLANEOUS POINTERS				      &
   !	MAP%()		TABLE OF CRASH FILE SEGMENT LAYOUT		      &
   !	MAX.SEG%	HIGHEST SEGEMENT NUMBER, CURRENTLY = XBUF.SEG%	      &
   !	MOD$		DMC LINE TYPE					      &
   !    MSCP.SEG%	MSCP REGION DUMP SEGMENT NUMBER			      &
   !	N%		SYMBOL TABLE STARTING BLOCK #, UTILITY VARIABLE	      &
   !	NF.ACT%		IF <>0, NODE IS ACTIVE				      &
   !	NF.INI%		IF <>0, NODE HAS RECEIVED A NODE INIT MSG	      &
   !	NF.NAJ%		IF <>0, NODE IS NON-ADJACENT			      &
   !	N.FLGS%		NODE FLAG WORD					      &
   !	NOB%		BASE OF A NODE BLOCK (NOB)			      &
   !	NODE$		NODE NAME					      &
   !	NUM.DECNT.UNITS%	TOTAL NUMBER OF DECNET UNITS		      &
   !	O0$		OUTPUT FILE					      &
   !	OB.JOB%		NETWORK OBJECT TYPE/JOB #			      &
   !	OCT.ST%		DUMP PARAMETER VARIABLE				      &
   !	P2%		DEVTBL POINTER FOR PK'S				      &
   !	P3%		KB # OF THE KB FOR PK0				      &
   !	PAT%(),PAT$()	USED FOR INSTALLED PATCHES			      &
   !	PATCH%		COUNT OF INSTALLED PATCHES			      &
   !	PKG.LOC$	ERROR PACKAGE LOCATION				      &
   !	Q$,Q%,Q,Q0,Q0%,Q1%,QQ% UTILITY VARIABLES IN VARIOUS FUNCTIONS	      &
   !	QTA%		USED IN NIP STUFF				      &
   !	R		ADDRESS TO PEEK AT				      &
   !	RCVRID$		RECEIVER ID					      &
   !	RDR.LDR%	COUNT OF DATA SEGMENTS REQUESTED BY REMOTE/LOCAL      &
   !			PROCESS BUT NOT YET SENT/RECEIVED		      &
   !	RIB%		BASE OF A RECEIVER ID BLOCK (RIB)		      &
   !	RIR%,RIR$	REMOTE INTERRUPT REQUESTS			      &
   !	RIR.LIR%	COUNT OF INTERRUPTS REQUESTED BY REMOTE/LOCAL	      &
   !			PROCESS BUT NOT YET SENT/RECEIVED		      &
   !	MOD.TRY%	FLOW CONTROL MODIFIERS, TRANSMIT RETRY COUNT	      &
   !	LL.MOD%		REMOTE/LOCAL FLOW CONTROL FLAGS			      &
   !    ROOT.SEG%	MONITOR DUMP SEGMENT NUMBER			      &
   !	S$		STRING TO BE PRINTED, UTILITY VARIABLE		      &
   !	S%		USED IN STRING PADDING FUNCTIONS		      &
   !	S0$		UTILITY STRING					      &
   !	SATBUF		POINTER TO SATBUF				      &
   !	SCB.WCB%	POINTER TO THEM					      &
   !	SEG%		CURRENT SEGMENT NO.				      &
   !	SIL.FILE$	NAME OF SIL FILE				      &
   !	SILMOD%(),SILPAT%() POINTER ARRAYS				      &
   !	SNDLST%		POINTER TO SENDER LIST				      &
   !	STA$		LINK STATE MNEMONIC				      &
   !	STA.ULA%	STATE FLAG BITS/USER LINK ADDRESS (ULA)		      &
   !	STB%		FLAG TO PRINT SYMBOL TABLE OR NOT		      &
   !	T		TIME UTILITY VARIABLE				      &
   !	T9$		TAB						      &
   !	T%		UTILITY VARIABLE				      &
   !	T0		TIME UTILITY VARIABLE				      &
   !	T1%		UTILITY VARIABLE				      &
   !	TF.TMQ%		TIMER QUEUE LINK WORD				      &
   !	U%		DEVICE UNIT #					      &
   !	UNIT%		USED TO FIND MAX XM: UNIT ALLOWED ON THE SYSTEM	      &
   !	W%		INDICATES WHICH ROUTINE TO DO			      &
   !	WCB%		WINDOW CONTROL BLOCK				      &
   !	WIDE%		<>0 MEANS DO AN ANNOTATED LISTING		      &
   !	WORK1.FILE$,WORK2.FILE$ WORK FILE NAMES				      &
   !	XBUF.SEG%	XBUF DUMP SEGMENT NUMBER			      &
   !	XMMODE%		USED TO GET DMC-11 MODE				      &
   !	XM0.DDB.PTR%	POINTER TO THE DDB FOR XM0:			      &

800	!								      &
									      &
									      &
	!	F U N C T I O N / S U B R O U T I N E    D E S C .	      &
									      &
									      &
									      &
   !	FUNCTION		USE					      &
   !									      &
   !	FNE$			EXTRACT ERROR TEXT			      &
   !	FNF()			CONVERT INTEGER TO FLOATING POINT	      &
   !	FNFLOW$			PRODUCE A FLOW CONTROL MNEMONIC		      &
   !	FNLO$			GET AN 8 POSITION OCTAL STRING		      &
   !	FNN$			TURN A # INTO A STRING AND LEFT PAD IT	      &
   !				WITH SPACES				      &
   !	FNNAM$			EXTRACT A RECEIVER ID OR NODE NAME	      &
   !	FNPEEK()		PEEK AT FP ADDRESS IN SEGMENT 0		      &
   !	FNPN$			SPECIAL CASE FNN$			      &
   !	FNP%			CORRESPONDS TO A 'PEEK'			      &
   !	FNS$			LEFT PAD A STRING WITH SPACES		      &
   !	FNSR5%()		SHIFT AN INTEGER RIGHT 5 BITS		      &
   !									      &
   !	SUBROUTINE LINES	USE					      &
   !	10010-10140		JOB STATUS				      &
   !	10250-10290		RUN-TIME SYSTEMS			      &
   !	10350-10420		BUSY DEVICES				      &
   !	10470-10480		'FREE' STATISTICS			      &
   !	10500-10550		DISK STRUCTURE				      &
   !	10600-10690		OPEN FILES				      &
   !	10700-10740		MESSAGE RECEIVERS			      &
   !	10800-10899		RESIDENT LIBRARIES			      &
   !	11000-11100		LINK STATUS ROUTINE			      &
   !	12200-12300		EXTRACT NODE BLOCK INFORMATION		      &
   !	12400-12480		EXTRACT RECEIVER ID BLOCK INFO		      &
   !	12600-12660		EXTRACT LOGICAL LINK BLOCK INFO;	      &
   !				PRINT LINK INFO				      &
   !	13000-13120		NODE STATUS ROUTINE			      &
   !	13500-13580		DMC LINE ROUTINE			      &
   !	14000-14060		TIME (HH:MM:SS.S)			      &
   !	14100			COMMON PRINT ROUTINE			      &
   !	14500			FIELD FILE INFO				      &

900	DIM A%(30%)							      &
		!							      &
		!	D I M E N S I O N    S T A T E M E N T S	      &
		!							      &
		!							      &
		! A%()	USED TO HOLD SYS CALLS				      &
		!							      &
									      &

940	DIM #10%,	M%(80%), M2%(80%), DEC%(40%),			      &
			CC%(30%), FILE.NAME$(5%)=32%, MAP%(10%,3%)	      &
	\ DIM #11%,	PAT%(17%),PAT$(17%)=8%,				      &
			SILMOD%(255%,20%),				      &
			SILPAT%(24%,63%),				      &
			G%(128%), G$(128%)=8%,				      &
			GX%(32767%,1%), DUPLST%(2000%,1%), GX$(15000%)=32%    &
		! F%()	'MAPS' CRASH FILE TO MEMORY LOCATIONS		      &
		!	(FNP%(LOC/2)=PEEK(LOC))				      &
		!							      &
		! PAT()	- INSTALLED PATCHES, E.G.,$$0301		      &
		! SILMOD(,) - ENTRIES FOR SIL DIRECTORY - MAXIMUM OF 255      &
		!	(,0)=SE.NAM					      &
		!	(,1)=SE.NAM					      &
		!	(,2)=SE.IDN					      &
		!	(,3)=SE.IDN					      &
		!	(,4)=SE.BLK					      &
		!	(,5)=SE.STB					      &
		!	(,6)=SE.STN					      &
		!	(,7)=SE.LOD					      &
		!	(,8)=SE.SIZ					      &
		!	(,9)=SE.XFR					      &
		!	(,10)=SE.SZD					      &
		!	(,11)=SE.OVB					      &
		!	(,12)=SE.OVN					      &
		!	(,13)=SE.OFF					      &
		!	(,14)=0						      &
		!	(,15)=0						      &
		!	(,16)=0 OR VALUE OF XXXPAT			      &
		!		E.G., EMTPAT				      &
		!	(,17-20)=0					      &
		! SILPAT(,) - XXXPAT CONTENTS (64. WORDS)		      &
		! G%(),G$() - POINTERS AND NAMES USED FOR ANNOTATION	      &
		! GX%(X%,Y%) - WHERE  X% = MEMORY ADDRESS		      &
		!		      Y% = 0% -> INTO ANNOTATION TABLE	      &
		!			   1% -> INTO DUPLICATE LIST	      &
		! DUPLST%(X%,Y%) -    X% = NEXT FREE ENTRY		      &
		!		      Y% = 0% -> INTO ANNOTATION TABLE	      &
		!			   1% LINK -> INTO DUPLST TABLE	      &
		! GX$(X%)	      X% = NEXT FREE ANNOTATION		      &
		! MONITOR TABLES - PART I STORED IN M%()		      &
		! WHERE POSSIBLE, THESE SUBSCRIPTS ARE USED FOR		      &
		! CONSISTENCY WITH SYSTAT - THOSE THAT DIFFER ARE *'D	      &
		! M%(1)		FIJBDA*					      &
		! M%(3)		FIBUF*					      &
		! M%(5)		DEVCNT					      &
		! M%(7)		DEVPTR					      &
		! M%(9)		SATBUF*					      &
		! M%(11)	JOBTBL					      &
		! M%(13)	JBSTAT					      &
		! M%(15)	JBWAIT					      &
		! M%(17)	UNTCLU					      &
		! M%(19)	UNTCNT					      &
		! M%(21)	SATCTL					      &
		! M%(23)	PATCH*					      &
		! M%(25)	SATCTM					      &
		! M%(29)	UNTOWN					      &
		! M%(33)	(JCRSIZ) - SIZE OF JOB DATA STRUCTURE	      &
		! M%(35)	LATAP5					      &
		! M%(37)	$$LATS					      &
		!							      &
		! M2%() - PACKAGE LOCATION UTILITY ARRAY (30) AND	      &
		!   MONITOR TABLES - PART II + EXTRAS			      &
		! M2%(1)	LRGFIL*					      &
		! M2%(3)	FREES					      &
		! M2%(5)	DEVNAM					      &
		! M2%(7)	CSRTBL					      &
		! M2%(9)	DEVOKB					      &
		! M2%(11)	TTYHCT					      &
		! M2%(13)	JOBCNT					      &
		! M2%(15)	RTSLST					      &
		! M2%(17)	ERLCTL					      &
		! M2%(19)	SNDLST					      &
		! M2%(21)	LOGNAM					      &
		! M2%(23)	DEVSYN					      &
		! M2%(25%)	($$JCR6) - START OF JOB CONTROL REGION * 64   &
		! M2%(27%)						      &
		! M2%(29%)	FCBLST					      &
		! M2%(57%)	UNTLVL					      &
		! m2%(67%)	FAKDDB					      &
		! M2%(69%)	CHECTL					      &
		! M2%(71%)	CSRTBL					      &
		!							      &
		! ITEMS NEEDED IF DECNET'S CONFIGURED			      &
		! DEC%(1%)	NSPCCB -- <> MEANS DECNET IS THERE	      &
		! DEC%(2%)	LNKMAX					      &
		! DEC%(3%)	NODLST -- <> MEANS NSP ENABLED		      &
		! DEC%(4%)	NSPLST					      &
		! DEC%(5%)	SIDBUF					      &
		! DEC%(6%)	NSPLLB					      &
		! DEC%(7%)	NSPCDB					      &
		! DEC%(8%)	LLTBUF -- <> MEANS NSP ENABLED		      &
		!			Contorted address of LLT buffer	      &
		! DEC%(9%)	NSPQUE					      &
		! DEC%(10%)	TRNQUE					      &
		! DEC%(11%)	CONQUE					      &
		! DEC%(12%)	NETPOL private buffer pool free list	      &
		! DEC%(13%)	IDLNOB Idle Node Block list		      &
		! DEC%(14%)	NSPQ2F Work blocks waiting for FIP	      &
		! DEC%(15%)	NSPFCQ Work blocks returned from FIP	      &
		! DEC%(16%)	ENDCHE MMU value of end-node cache	      &
		! DEC%(17%)	RTEMMU MMU address of cost/hops vector	      &
		! DEC%(18%)	OAJMMU MMU address of adjacency vector	      &
		! DEC%(19%)	MTXMMU MMU address of routing matrix	      &
		! DEC%(20%)	RTMSTA Routing message start address	      &
		! DEC%(21%) 	EVTMMU MMU value for Event logger database    &
		! DEC%(22%)	ADJFLG Start of Adjacency MMU pointers	      &
		! DEC%(23%)	NSPJDB Pointer to NSP's JDB		      &

999	!								      &
									      &
									      &
	!	M A I N    C O D I N G    A R E A			      &
									      &
									      &

1000	ON ERROR GOTO 19000						      &
	\ S$=SYS(CHR$(6%)+CHR$(-21%))					      &
	\ IF (DIAGNOSE% AND 64%)					      &
		THEN PRINT "Starting ANALY1 - ";DATE$(0%);TIME$(0%);	      &
			"CPU time";TIME(1%)				      &
	\	STOP IF (DIAGNOSE% AND 128%)				      &
		! SET UP STANDARD ERROR TRAP				      &
		! PERMANENTLY DROP TEMPORARY PRIVILEGES			      &
		! RETURN KB TO LEFT MARGIN				      &

1010	I$="V10.1-L"							      &
		! SET UP VERSION/EDIT #.				      &

1030	CHANGE SYS(CHR$(12%)) TO A%					      &
	\ PKG.LOC$="["+NUM1$(A%(6%))+","+NUM1$(A%(5%))+"]"		      &
	\ PKG.LOC$="_"+CHR$(A%(23%))+CHR$(A%(24%))+NUM1$(A%(25%))+":"+	      &
		PKG.LOC$ IF A%(26%) AND 1%				      &
	\ IF A%(3%)+SWAP%(A%(4%))<>15%*2% THEN				      &
		PRINT "?Please 'RUN ANALYS'"				      &
	\	GOTO 32767 UNLESS DIAGNOSE%				      &
	\ GOTO 5000 IF (DIAGNOSE% AND 4%) OR (DIAGNOSE% AND 8%)		      &
		! BUILD NAME OF DEVICE AND ACCOUNT OF LAST OPENED FILE.	      &
		! WE MUST HAVE COME FROM A COMPILED FILE SO WE CAN BE	      &
		! SURE THAT THIS NAME IS REALLY OUR PACKAGE LOCATION.	      &

1040	IF E0%<>2% THEN							      &
		PRINT "?Illegal entry - Please 'RUN ANALYS'"		      &
		\ GOTO 32767 UNLESS DIAGNOSE%				      &
	! ONLY CHAINING FROM ANALYS IS ALLOWED				      &

1100	OPEN WORK1.FILE$ FOR INPUT AS FILE 10%, MODE 256%		      &
	\ CSRTBL%=M2%(7%)						      &
		! Table of physical device addresses			      &
	\ CSR.KB%=M2%(65%)						      &
		! Used to find PK job numbers				      &
	\ DEVOKB%=M2%(9%)						      &
		! (Number of disk devices on system) * 2		      &
	\ DDBPTR%=CSRTBL%+DEVOKB%/2%					      &
		! Points to 1st CSR entry for KB's.  For PK's, the CSR	      &
		! table contains the address of the KB's DDB rather	      &
		! than a physical CSR address, so we can get the PK	      &
		! KB's DDB from that.					      &
	\ EPMM=FNF(M2%(31%))						      &
	\ DDCTBL%=M2%(45%)						      &
	\ UCTTBL%=M2%(47%)						      &
	\ FPLAP6%=M2%(53%)						      &
	\ HAND.IDX%=CC%(3%)						      &
	\ LLT.FLG%=CC%(6%)						      &
	\ P2%=CC%(7%)							      &
	\ P3%=CC%(8%)							      &
	\ NUM.DECNT.UNITS%=CC%(9%)					      &
	\ XM0.DDB.PTR%=CC%(10%)						      &
	\ ROOT.SEG%=CC%(12%)						      &
	\ FPL.SEG%=CC%(13%)						      &
	\ XBUF.SEG%=CC%(14%)						      &
	\ MSCP.SEG%=CC%(18%)						      &
	\ JCTRL.SEG%=CC%(19%)						      &
	\ FPL.ST=FNF(CC%(16%))						      &
	\ FPL.END=FNF(CC%(17%))						      &
	\ JHEAD.SEG%=CC%(21%)						      &
	\ FJHEAD.SEG%=CC%(22%)						      &
	\ I0$=FILE.NAME$(1%)						      &
	\ O0$=FILE.NAME$(2%)						      &
	\ JCR.ST=(MAP%(JCTRL.SEG%,0%)-1%)*512%				      &
									      &
	! EXTRACT NEEDED INFORMATION FROM FILENAME PASSED IN CORE COMMON.     &

1400	C$=CHR$(13%)+CHR$(10%)						      &
	\ T9$=CHR$(9%)							      &
	\ S$=I0$							      &
	\ OPEN S$ FOR INPUT AS FILE 12%, MODE 256%+8192%		      &
	\ FIELD #12%, 512% AS D$					      &
	\ JCRSIZ=FNF(FNP%(M%(33%)))					      &
	\ S$=O0$							      &
	\ IF HAND.IDX%=0%						      &
	    THEN							      &
		OPEN S$ FOR INPUT AS FILE 1%, MODE 2%			      &
	    ELSE							      &
		IF HAND.IDX%=14%					      &
		    THEN						      &
			OPEN S$ FOR OUTPUT AS FILE 1%, MODE 128%	      &
		    ELSE						      &
			IF HAND.IDX%=6%					      &
			    THEN					      &
				OPEN S$ AS FILE #1%, MODE 8192%		      &
			    ELSE					      &
				OPEN S$ AS FILE 1%			      &
									      &
	! OPEN THE FILE BASED ON HANDLER INDEX:				      &
	!	0 OR 14	DISK OR TAPE -- APPEND MODE			      &
	!	OTHER	PLAIN OPEN					      &

4470	PRINT #1%, C$;							      &
	\ FOR W%=1% TO 11%						      &
	\	ON W% GOSUB	10000,	10350,	10500,	10600,	10450,	      &
				10250,	10800,	13700,  11500,  11800,	      &
				12000
4480	NEXT W%								      &
		! JOB STATUS, BUSY DEVICES, DISKS, OPEN FILES,		      &
		! BUFFER / HUNG TTY / JOB COUNT, RTS'S, LIB'S,		      &
		! MEMORY ALLOCATION, SHOW DEVICES, SHOW CACHE, LAT INFO	      &
		!							      &
	\ GOTO 5000 UNLESS DEC%(1%)					      &
	\ FOR W%=1% TO 3%						      &
	\	ON W% GOSUB	11000, 13000, 13500
4490	NEXT W%								      &
		!							      &
		! LINKS, NODES, LINES					      &

5000	PRINT "Exiting ANALY1 - ";DATE$(0%);TIME$(0%);			      &
			"CPU time";TIME(1%) IF (DIAGNOSE% AND 64%)	      &
	\ GOTO 32767 IF (DIAGNOSE% AND 2%)				      &
	\ CLOSE 1%,10%,12%						      &
	\ S$=PKG.LOC$+"ANALY2"						      &
	\ CHAIN S$ LINE 31000						      &
	! CLEAR THE ERROR VARIABLE, GOTO EACH ROUTINE.			      &
	! SAVE SOME NEEDED INFO IN CORE COMMON.				      &
	! CHAIN TO THE CORE DUMP PROGRAM.				      &
	! NOTE: IF /BUFFERS OR /ALPHA SPECIFIED BUT FOR SOME REASON WE	      &
	!  CAN'T DO THE ANNOTATIONS (USER'S BEEN TOLD), DO THE CHAIN ANYWAY.  &
	!  /ALPHA WILL GET THE OCTAL INSTEAD, /BUFFERS WILL FIZZLE SOON.      &

10000	!								      &
									      &
									      &
	!	S U B R O U T I N E S					      &
									      &
									      &
									      &
	!	J O B    S T A T U S					      &
	!								      &
	!								      &
	!	J O B    D A T A    B L O C K    ( J D B )		      &
	!								      &
	!	  CONTENTS		OFFSET				      &
	!	   JDIOB		  0	PTR TO IOB		      &
	!	   JDFLG		  2	STATUS FLAGS		      &
	!	JDPOST - JDIOST		  4	PATTERN TO POST - ERR CODE    &
	!	   JDWORK		  6	PTR TO WRK		      &
	!	   JDJB2		  8	PTR TO JDB2		      &
	!	JDSIZN - JDFLG2		 10	NEXT RES SIZE - FLAGS	      &
	!	   JDRTS		 12	PTR TO RTS		      &
	!	   JDRESQ		 14	RESIDENCY QUANTUM	      &
	!  	   JDMCTL		 16	MEMORY CONTROL AREA	      &
	!	     "" 		 18		""		      &
	!	     "" 		 20		""		      &
	!	  ""   - JDSIZE		 22		""		      &
	!	     "" 		 24		""		      &
	!	   JDRESB		 26	L3 QUEUE BITS		      &
	!	JDBRST - JDPRI		 28	RUNBURST - PRIORITY	      &
	!	JDSWAP - JDSIZM		 30	SWAP PARAM - PRIV MEM MAX     &
	!								      &
	!	JDFLG BITS:						      &
	!	BIT	MEANING						      &
	!	 0	JFPOST						      &
	!	 1	JFIOST						      &
	!	 2	JFKEY						      &
	!	 3	JFCC (CTRL/C)					      &
	!	 4	JF2CC (2 CTRL/C'S)				      &
	!	 5	JFPPT						      &
	!	 6	JFGO						      &
	!	 7	JFREDO						      &
	!	 8	JFSYST - TEMP PRIVILEGES POSSIBLE		      &
	!	 9	JFFPP						      &
	!	10	JFPRIV - PERMANENT PRIVILEGES			      &
	!	11	JFSYS - TEMP PRIVILEGES ACTIVE			      &
	!	12	JFOPR - NOT YET LOGGED IN			      &
	!	13	JFBIG - CAN EXCEED PRIVATE MEM MAX		      &
	!	14	JFLOCK - NOT TO BE SWAPPED			      &
	!	15	JFSPCL						      &
	!								      &
	!								      &
	!	J O B    D A T A    B L O C K    2    ( J D B 2 )	      &
	!								      &
	!	  CONTENTS		OFFSET				      &
	!	   J2TICK		  0	UNCONVERTED CLOCK TICKS	      &
	!	   J2CPU		  2	CPU LSB			      &
	!	   J2CON		  4	CONNECT TIME		      &
	!	   J2KCT		  6	KILO-CORE-TICKS LSB	      &
	!	   J2DEV		  8	DEVICE TIME		      &
	!	J2CPUM - J2KCTM		 10	CPU MSB - KCT MSB	      &
	!	   J2NAME1		 12	JOB'S PROGRAM NAME	      &
	!	   J2NAME2		 14		""		      &
	!  	   J2DRTS		 16	PTR TO DEFAULT RTS	      &
	!	   J2MPTR 		 18	PTR TO RIB		      &
	!	   J2PPTR		 20	POSTING POINTER		      &
	!	   J2PCNT		 22	POSTING COUNT		      &
	!	   J2PPN		 24	PPN			      &
	!	   J2UFDR		 26	RETRV PTR TO SYS DISK UFD     &
	!	  RESERVED		 28				      &
	!	  RESERVED		 30				      &
	!								      &

10010	PRINT #1%,C$;"Crash Dump Status From ";DATE$(FNP%(512%));" at ";      &
	\ SY.TIME%=FNP%(514%)						      &
	\ UP.TIME%=FNP%(38%)						      &
	\ VALID.SY.TIME% = (SY.TIME%>=1% AND SY.TIME%<=1440%)		      &
	\ VALID.UP.TIME% = (UP.TIME%>=1% AND UP.TIME%<=1440%)		      &
	\ PRINT #1%, TIME$(SY.TIME%); IF VALID.SY.TIME%			      &
	\ PRINT #1%, "??:?? ??"; UNLESS VALID.SY.TIME%			      &
	\ PRINT #1%, ", Up: ";						      &
	\ IF NOT (VALID.SY.TIME% AND VALID.UP.TIME%) THEN		      &
		S$="??? ??:??:??"					      &
	\	GOTO 10016						      &

10014	J%=FNP%(36%)/1000%+2%						      &
	\ J2%=(FNP%(512%)/1000% <> FNP%(36%)/1000%)			      &
	\ J2%=635%+((J%/4%*4%)=J%) IF J2%				      &
	\ T=((FNP%(512%)-FNP%(36%)-J2%)*1440.+				      &
	  FNP%(38%)-FNP%(514%))*60.+60.-(FNP%(516%) AND 255%)		      &
	\ c1%=0% ! do the DDD HH:MM:SS format				      &
	\ GOSUB 14000							      &
	! PRINT THE SYSTEM HEADER INCLUDING THE CURRENT DATE AND	      &
	! TIME (USING MINUTES TILL MIDNIGHT - SECONDS UNTIL NEXT MINUTE)      &
	! AND LENGTH OF TIME THE SYSTEM'S WAS UP.			      &
	! CHECK FOR CHANGE OF YEAR, ADJUST FOR LEAPYEAR.		      &
	! NOTE: 635 (OR 636) IS NOT A TYPO:				      &
	! E.G., 31-DEC-78 -> 01-JAN-79					      &
	!     DATE$(8365) -> DATE$(9001) --> 9001-8365=635+1		      &
	! PEEK(n)	CONTENTS					      &
	! 36		IDATE = DATE SYSTEM LAST STARTED		      &
	! 38		ITIME = TIME SYSTEM LAST STARTED		      &
	! 512		DATE = CURRENT DATE				      &
	! 514		TIME = CURRENT TIME				      &
	! 516 (BYTE)	TIMSEC = SECONDS TO NEXT MINUTE			      &
	! GET OUT AFTER PRINTING THE HEADER IF /BUFFERS WAS SPECIFIED	      &
	!  (ONLY SYS/F PLUS DUMP).					      &

10016	J%=0%								      &
	\ JCRSIZ=FNP%(M%(33%))						      &
	\ JCR.ST=(MAP%(JCTRL.SEG%,0%)-1%)*512.				      &
	\ PRINT #1%,S$,C$;C$;						      &
	\ PRINT #1%;"Job";TAB(7%);"Who";TAB(14%);"Where";TAB(23%);"What";     &
		TAB(31%);"Size";TAB(39%);"State";			      &
		TAB(48%);"Run-Time  Pri/RB   RTS"			      &
	! CLEAR THE JOB # VARIABLE.					      &
	! PRINT THE JOB STATUS HEADING, INCLUDING 'PRIORITY'		      &

10020	 J%=J%+2%							      &
	\ JOB.BASE=JCR.ST+(J%*JCRSIZ)					      &
	\ JDB%=FNP%(M%(11%)+J%)						      &
	\ GOTO 10140 IF JDB%=-1% OR E%<>0%  ! QUIT IF AT THE END OF JOB TABLE &
	\ GOTO 10020 UNLESS JDB% 	! LOOK AGAIN IF JOB NUMBER NOT PRESENT &
	\ JDFLG%=FNP%(JDB%+2%)						      &
	\ KB.DDB%=FNP%(FNP%(JDB%))					      &
	\ TTINTF%=FNP%(KB.DDB%+30%)					      &
	\ INTFAC%=TTINTF% AND 255%					      &
	\ JDPPN%=FNP%(FNP%(JDB%+8%)+24%)				      &
	\ PRINT #1%,FNN$(2%,J%/2%);TAB(3%);				      &
	\ DIAL.UP$=""							      &
	\ DIAL.UP$="*" IF TTINTF% AND 16384%				      &
	\ IF (FNP%(KB.DDB%+2%) AND 255%)=J%				      &
		AND (FNP%(KB.DDB%+6%) AND 8192%)<>0%			      &
	  THEN J2%=SWAP%(FNP%(KB.DDB%+2%)) AND 255%			      &
	\	DIAL.UP$=CHR$(33%)+DIAL.UP$ IF (TTINTF% AND 255%)=18%	      &
		! IT'S A LAT IF IT'S DYNAMIC AND IT'S NOT A PK DEVICE.	      &
	\ ELSE J2%=-1%							      &
	\ END IF							      &
	! INCREMENT THE JOB # AND LOOK AT THE CORRESPONDING JOBTBL ENTRY      &
	! JDB%		POINTS TO THE JDB				      &
	!		-1	SIGNALS THE END				      &
	!		 0	SIGNALS THE JOB IS NOT LOADED		      &
	! KB.DDB%	POINTS TO THE DDB OF THE JOB'S CONSOLE KB:	      &
	! TTINTF%	TERMINAL INTERFACE FLAG:			      &
	!		BIT	MEANING					      &
	!		0-7	INTERFACE TYPE CODE (INTFAC%):		      &
	!			0	KL11				      &
	!			2	DC11				      &
	!			4	DL11				      &
	!			6	DE11				      &
	!			8	PK11				      &
	!			10	DJ11				      &
	!			12	DH11				      &
	!			14	DZ11				      &
	!		8-11	TTSUBL - SUB-LINE NUMBER		      &
	!		12	TTRDRN - READER RUN CONTROL		      &
	!		13	TTHPRT - HARDWARE PARITY		      &
	!		14	TTMODM - MODEM CONTROL			      &
	!		15	TTMUX  - MULTIPLEXOR			      &
	! JDPPN%	JDPPN						      &
	!								      &
	! WILL PRINT ALL *'S IF JOB WAS NOT LOGGED IN.			      &
	! IF THE OWNER JOB INDEX FROM THE DDB IS THE SAME AS THE JOB #	      &
	! WE'RE WORKING WITH AND THIS IS THE JOB'S CONSOLE TERMINAL	      &
	! (CHECK THE DEVICE ASSIGNMENT STATUS IN THE DDB) THEN		      &
	!	DETERMINE THE DEVICE'S UNIT # (DDUNT)			      &
	! ELSE	SIGNAL THE JOB IS DETACHED				      &
									      &

10050	S$="**,**"							      &
	\ S0$=" "							      &
	\ IF JDPPN% THEN						      &
		S$=NUM1$(SWAP%(JDPPN%) AND 255%)+","+NUM1$(JDPPN% AND 255%)   &
	\	S0$="-" IF JDFLG% AND 256%				      &
	\	S0$="+" IF JDFLG% AND 2048%				      &
		! IF LOGGED IN THEN					      &
		!	SET UP REAL ACCOUNT				      &
		!	-	TEMPORARY PRIVILEGES POSSIBLE		      &
		!	+	TEMPORARY PRIVILEGES ACTIVE		      &

10065	PRINT #1%,S0$;TAB(9%-INSTR(1%,S$,","));S$;			      &
	\ S$="KB"							      &
		! In anticipation that this will be true		      &
	\ IF INTFAC%=8% AND J2%<>-1% THEN				      &
			! If the interface type = 8, and KB# is not -1, then  &
		DEVDDB%=FNP%(CSR.KB%+(J2%*2%))				      &
			! CSRTBL + DEVOKB/2 + KB.NUMBER*2 = DDB address for   &
			! this KB.					      &
	\	S$="KB"+NUM1$(J2%)+"J"					      &
			! Build the 1st 3 parts of the string "KBnnJmm"	      &
			! The "mm" part comes later.			      &
	\	J2%=(FNP%(DEVDDB%+2%) AND 255%)/2%			      &
			! Second word in a PK KB's DDB is the job number*2    &
			! of the PK's controlling job. We'll put it in J2%    &
			! so that it gets printed out instead of KB# in the   &
			! next line.					      &

10070	S$=S$+NUM1$(J2%)						      &
	\ S$=S$+DIAL.UP$						      &
	\ S$="Det" IF J2%=-1%						      &
	\ PRINT #1%,TAB(14%);S$;TAB(22%);				      &
		RAD$(FNPEEK%(JCTRL.SEG%,JOB.BASE+16));			      &
		RAD$(FNPEEK%(JCTRL.SEG%,JOB.BASE+18));TAB(29%);		      &
		FNN$(3%,(FNP%(JDB%+22%) AND 255%));"/";			      &
		FNN$(2%,(FNPEEK%(JCTRL.SEG%,JOB.BASE+52) AND 255%));	      &
		"K";TAB(39%);						      &
	\ T%=FNP%(M%(15%)+J%)						      &
	\ S$="RN"							      &
	\ GOTO 10110 IF (T% AND FNP%(M%(13%)+J%))			      &
	\ S$="RS"							      &
	\ GOTO 10110 IF FNP%(JDB%+24%)=0% AND				      &
	   (FNP%(JDB%+22%) AND -256%)=(NOT 15359%)			      &
	\ T%=T% AND (NOT 16384%) IF (T% AND (NOT 16384%))<>0%		      &
	\ S$="BF"							      &
	\ GOTO 10110 IF (T% AND 16384%)					      &
	\ S$="SL"							      &
	\ GOTO 10080 IF (T% AND 8192%)=0%				      &
	\ S$="SR" IF (FNP%(JDB%+4%) AND 255%)=5%			      &
	\ GOTO 10110							      &
	! FLAG THE JOB IF IT'S A DIAL-IN (MODEM SET).			      &
	! PRINT THE JOB NAME (J2NAME), THE CURRENT SIZE,		      &
	! IN K (M.SIZE) AND THE MAX SIZE, IN K (JDSIZM).		      &
	! T%=JBWAIT							      &
	! IN GENERAL, SET S$('STATE')=STRING WHICH WILL BE PRINTED	      &
	! IF THE TEST WHICH FOLLOWS IMMEDIATELY IS SATISFIED.		      &
	! POSSIBLE STATES		CONDITIONS			      &
	!	RN			(JBWAIT AND JBSTAT)<>0 AND	      &
	!				'ACTUAL' STATE IS NOT DESIRED.	      &
	!	RS (RESIDENCY WAIT)	IF M.PHYA=0% AND		      &
	!				M.CTRL=LCK,SWP AND IN		      &
	! (TURN OFF BUFFER WAIT BIT IF ANY OTHERS ARE ON. CHECK FOR THE	      &
	! FOLLOWING STATES BY LOOKING AT JBWAIT.)			      &
	!	BF (BUFFER WAIT)	IF BIT 14 IS ON			      &
	!	SL (SLEEP WAIT)		IF BIT 13 IS ON.		      &
	!	SR (RECEIVER WAIT)	IF BIT 13 IS ON AND ERROR CODE	      &
	!				(IN JDIOST) IS 5		      &

10080	S$="FP"								      &
	\ GOTO 10110 IF (T% AND 4096%)					      &
	\ S$="TT"							      &
	\ GOTO 10110 IF (T% AND 2048%)					      &
	\ S$="HB"							      &
	\ GOTO 10110 UNLESS T%						      &
	\ DRV.IDX%=2%							      &
	\ GOTO 10100 IF T%=2%						      &
	!	FP			BIT 12 IS ON			      &
	!	TT			BIT 11 IS ON			      &
	!	HB			NO BITS ARE ON			      &
	! IF NONE OF THE PREVIOUS STATES THEN WE HAVE A "DEVICE WAIT".	      &
	! BYPASS THE CHANNEL # CHECK IF WE KNOW WE HAVE A KB INPUT WAIT.      &
									      &

10090	CHN%=FNP%(FNP%(JDB%+6%)+6%) AND 255%				      &
	\ SCB.WCB%=FNP%(FNP%(JDB%)+CHN%)				      &
	\ DRV.IDX%=0%							      &
	\ DRV.IDX%=FNP%(SCB.WCB%) AND 255% IF SCB.WCB%<>0%		      &
	\ IF DRV.IDX%=0% THEN						      &
		FIP.UNT%=FNP%(FNP%(SCB.WCB%+8%)-4%) AND 255%		      &
	\ 	S$=CVT%$(SWAP%(FNP%(M2%(21%)+(FIP.UNT%*10%)+6%)))	      &
	\	S$="??" IF LEN(CVT$$(S$,-2%))=0% OR SCB.WCB%=0%		      &
	\	GOTO 10110						      &
	! CHN%=CHANNEL # *2.						      &
	! INDEX INTO THE IOB WHICH POINTS TO EITHER A DDB (NON-DISK),	      &
	! OR A WCB (DISK).						      &
	! LOOK AT THE DRIVER INDEX (SAME LOCATION IN BOTH).		      &
	! IF WE HAVE A DISK (DRV.IDX%=0%) THEN				      &
	!	FIND THE FIP UNIT NUMBER IN THE FCB (POINTED TO FROM WCB).    &
	!	EXTRACT THE PROPER NAME FROM DSKLOG			      &
									      &

10100	S$=CVT%$(SWAP%(FNP%(M2%(5%)+M2%(9%)+DRV.IDX%-2%)))		      &
	\ S$="^C" IF FNP%(FNP%(JDB%+6%)+10%)<0% IF DRV.IDX%=2%		      &
	! WE HAVE A NON-DISK WAIT.					      &
	! INDEX INTO DEVNAM TO GET THE PROPER NAME.			      &
	! CHECK FOR ^C ON KB INPUT WAITS.				      &

10110	PRINT #1%,S$;" ";						      &
	\ T%=SWAP%(FNPEEK%(JCTRL.SEG%,JOB.BASE+52)) AND 255%		      &
	\ T1%=FNP%(JDB%+22%)						      &
	\ IF (T1% AND -4096%)<>0% THEN					      &
		T%=64%							      &
	\	IF (T1% AND 1536%)<>0% THEN				      &
			T%=T%+64%					      &
	\		IF (T1% AND 512%)<>0% THEN			      &
				T%=T%+64%				      &
	! PRINT THE 1ST PART OF THE STATE INFO.				      &
	! GET THE CONTENTS OF JDSWAP AND M.CTRL.			      &
	! IF THIS IS <0 THEN						      &
	!	JOB IS EITHER						      &
	!	BIT 12-15	LOCKED					      &
	!	BIT 11		SWAPPED					      &
	!	BIT 10		SWAPPING IN (OR WANTS TO)		      &
	!	BIT 9		SWAPPING OUT (OR WANTS TO)		      &

10120	IF (T% AND 63%)<>0% THEN					      &
		S$=CHR$(65%+(T% AND 192%)/64%)+				      &
		RIGHT(NUM$(100%+(T% AND 63%)),3%)			      &
	ELSE	IF (T% AND 192%)=0% AND (FNP%(JDB%+2%) AND 16384%)<>0% THEN   &
		S$="NSw "						      &
	ELSE	S$=MID("    Lck Swi Swo ",(T% AND 192%)/16%+1%,4%)	      &
	! IF THE JOB IS SWAPPED THEN					      &
	!	PRINT SLOT # AND SWAPPING FILE, WHERE			      &
	!	A	SWAP0.SYS					      &
	!	B	SWAP1.SYS					      &
	!	C	SWAP2.SYS					      &
	!	D	SWAP3.SYS					      &
	!	ELSE	PRINT BLANKS OR PROPER MESSAGE			      &

10130	PRINT #1%,S$;							      &
	\ T0=FNPEEK%(JCTRL.SEG%,JOB.BASE+6)				      &
	\ T0=T0+65536. IF T0<0.						      &
	\ T0=T0+65536.*(SWAP%(FNPEEK%(JCTRL.SEG%,JOB.BASE+14)) AND 255%)      &
	\ T=INT(T0/10.)							      &
	\ T0=T0-10.*T							      &
	\ c1%=1% ! do the HHH:MM:SS format				      &
	\ GOSUB 14000							      &
	\ T%=FNP%(JDB%+12%)						      &
	\ PRINT #1%,FNS$(8%);".";CHR$(48%+T0);				      &
	\ S$=NUM1$(FNPEEK%(JCTRL.SEG%,JOB.BASE+50)*256%/256%)		      &
	\ PRINT #1%;FNS$(5%);"/";					      &
		NUM1$(SWAP%(FNPEEK%(JCTRL.SEG%,JOB.BASE+50)) AND 255%);	      &
		TAB(66%);RAD$(FNP%(T%+2%));RAD$(FNP%(T%+4%))		      &
	\ GOTO 10020 UNLESS E%						      &
	! PRINT SWAPPING INFO.						      &
	! PRINT THE ACCUMULATED CPU TIME (J2CPU AND J2CPUM).		      &
	! GET THE PRIORITY FROM JDPRI.					      &
	! LEFT THEN RIGHT SHIFT IT TO GET THE PROPER SIGN.		      &
	! PRINT THE PRIORITY AND THE RTS NAME.				      &
	! CONTINUE UNLESS THERE WERE ANY FNP% ERRORS.			      &

10140	RETURN								      &
									      &

10250	!								      &
									      &
									      &
	!	R U N - T I M E    S Y S T E M S			      &
									      &
									      &
									      &
	!	R T S    D E S C R I P T O R    B L O C K		      &
	!								      &
	!	  CONTENTS		OFFSET				      &
	!	   R.LINK		  0	PTR TO NEXT RTS		      &
	!	   R.NAME1		  2	RTS NAME		      &
	!	   R.NAME2		  4				      &
	!	   R.DEXT		  6	DEF EXT FOR RUNNABLE IMAGES   &
	!  	   R.MCTL		  8	MEMORY CONTROL AREA	      &
	!	     "" 		 10		""		      &
	!	     "" 		 12		""		      &
	!	  ""   - R.SIZE		 14	  ""  - RTS SIZE IN K WORDS   &
	!	     "" 		 16		""		      &
	!	   R.DATA1		 18	FUN/FBN OF THE RTS	      &
	!	   R.DATA2		 20				      &
	!	   R.FILE1		 22	NE OFFSET/2, FBN OF FILE UFD  &
	!	   R.FILE2		 24				      &
	!	   R.CNT		 26	ACCESS/RESIDENCY COUNT	      &
	!	R.MSIZ - R.SIZE		 28	MAX JOB SIZE - MIN JOB SIZE   &
	!	   R.FLAG		 30	FLAGS			      &
	!								      &
	!	R.FLAG BITS:						      &
	!	BIT	MEANING						      &
	!	0-7	EMT PREFIX CODE					      &
	!	 8	KEYBOARD MONITOR				      &
	!	 9	ONLY 1 USER					      &
	!	10	MAP RTS READ/WRITE				      &
	!	11	DON'T ERROR LOG					      &
	!	12	UNCONDITIONAL REMOVE				      &
	!	13	RUN SIZE COMPUTED FROM FILESIZE			      &
	!	14	SAVE THE LOAD ADDRESS (M.PHYA)			      &
	!	15	SPECIAL EMT HANDLING				      &

10260	J%=M2%(15%)							      &
	\ DKBM.PTR%=FNP%(J%-2%)						      &
	\ GOTO 10290 UNLESS J%						      &
	\ PRINT #1%,C$;"Run-Time Systems:";C$;				      &
	" Name";TAB(8%);"Ext";TAB(14%);"Dev";TAB(21%);"Size";		      &
	TAB(29%);"Users";TAB(36%);"Comments"				      &
	\ T%=0%								      &
	! GET OUT IF /BUFFERS SPECIFIED.				      &
	! GET ROOT OF RTS DESCRIPTOR BLOCKS				      &
	! IF ROOT IS ZERO THEN						      &
	!	GET OUT							      &
	! ELSE PRINT HEADER						      &
	! T% IS A FLAG FOR PRIMARY RTS DETERMINATION			      &

10265	J2%=M2%(61%)							      &
	\ FRST.FLAG%=0%							      &
	\ T1$=NUM1$(FNP%(J2%+28%) AND 255%)				      &
	!\ PRINT #1%,RAD$(FNP%(J2%+2%));RAD$(FNP%(J2%+4%));TAB(8%);"TSK";     &
	!	TAB(20%);FNN$(4%-LEN(T1$),(FNP%(J2%+14%) AND 255%));	      &
	!							"(";T1$;")K"; &
	!	TAB(29%);FNN$(3%,(FNP%(J2%+26%) AND 255%));		      &
	!	TAB(36%);"Monitor"					      &
	! PRINT LINE FOR THE NULL RTS.					      &

10270	J%=FNP%(J%)							      &
	\ GOTO 10290 IF J%=0% OR E%<>0%					      &
	\ T%=T%+1%							      &
	\ C%=FNP%(J%+26%)						      &
	\ J2%=FNP%(J%+14%)						      &
	\ F%=FNP%(J%+30%)						      &
	\ S1$=NUM1$(FNP%(J%+28%) AND 255%)				      &
	\ PRINT #1%,RAD$(FNP%(J%+2%));RAD$(FNP%(J%+4%));T9$;		      &
		RAD$(FNP%(J%+6%));TAB(14%);				      &
	\ PRINT #1%, FNACCOUNT$(M2%(21%),FNP%(J%+18%),0%);		      &
		IF FRST.FLAG%<>0%					      &
	\ FRST.FLAG%=-1%						      &
	\ PRINT #1%, TAB(20%);FNN$(4%-LEN(S1$),(J2% AND 255%));"(";S1$;")K";  &
		TAB(29%);FNN$(3%,(C% AND 255%));			      &
	\ IF (J2% AND -256%)=512% THEN					      &
		S$="Non-Res"						      &
	ELSE	IF (J2% AND 1024%) THEN					      &
			S$="Loading"					      &
		ELSE	S$="Temp"					      &
	\		S$="Perm" IF C%<0%				      &
	\		S$="Primary, Perm" IF T%=1%			      &

10280	J3%=FNP%(J%+16%)						      &
	\ S$=S$+", Addr:"+NUM1$(FNSR5%(J3%)) IF J3%			      &
	\ IF (F% AND 256%) THEN						      &
		S$=S$+", DF KBM" IF DKBM.PTR%=J%			      &
	\	S$=S$+", KBM"    IF DKBM.PTR%<>J%
10285	S$=S$+MID(", 1US, R/W, NER, Rem, CSZ",(I%-9%)*5%+1%,5%)		      &
		IF (F% AND 2%^I%) FOR I%=9% TO 13%			      &
	\ S$=S$+", EMT:"+NUM1$(F% AND 255%) IF F%<0%			      &
	\ PRINT #1%,TAB(36%);S$						      &
	\ GOTO 10270
10290	RETURN								      &
	! C%=R.CNT, J2%=M.CTRL - R.KSIZ, F%=R.FLAG			      &
	! WE ARE LOOKING AT A RTS DESCRIPTOR BLOCK.			      &
	! PRINT THE RTS NAME (R.NAME, 2 WDS), THE DEFAULT RTS EXTENSION	      &
	! (R.DEXT), THE SIZE OF THE MODULE IN K (R.KSIZ),		      &
	! AND ITS MAXIMUM USER JOB SIZE IN K (R.SIZE).			      &
	!								      &
	! PRINT THE COUNT OF USERS EXECUTING UNDER THE RTS (R.CNT).	      &
	! PRINT THE LOAD ADDRESS IF NON-ZERO.				      &
	! EXAMINE M.CTRL AND DETERMINE THE CURRENT STATE OF THE RTS.	      &
	! CONTINUE IF WE HAVEN'T REACHED THE END (0) OF THE LINKED LIST	      &
	! OF RTS DESC. BLOCKS AND THERE WEREN'T ANY FNP% ERRORS.	      &
									      &

10350	!								      &
									      &
									      &
	!	B U S Y    D E V I C E S				      &
									      &
									      &

10360	PRINT #1%,C$;"Busy Devices:";					      &
	\ C0%=0%							      &
	\ J1%=M%(5%)+M2%(9%)						      &
	\ DVPTR%=M%(7%)+M2%(9%)						      &
	\ GOTO 10420 IF E%						      &
	\ FOR C%=M2%(5%)+M2%(9%) TO (M2%(23%)-2%) STEP 2%		      &
	\	S$=CVT%$(SWAP%(FNP%(C%)))				      &
	\	J2%=FNP%(DVPTR%)					      &
	\	CR.VP%=0%						      &
	\	CR.VP%=1% IF S$="XM"					      &
	\	CR.VP%=-1% IF S$="XD"					      &
	\	FOR U%=0% TO FNP%(J1%)					      &
	\		D%=FNP%(J2%)					      &
	\		J%=FNP%(D%+2%) AND 255%				      &
	\		S$=FNDDCU$(D%) IF CR.VP%<>0%			      &
				UNLESS DDCTBL%=0% OR UCTTBL%=0%		      &
	\		XE.DDB.PTR%=J2% IF S$="XE" AND U%=0%		      &
	\		XH.DDB.PTR%=J2% IF S$="XH" AND U%=0%		      &
	\		GOTO 10390 IF J%=0%				      &
	\		GOTO 10390 IF (8192% AND FNP%(D%+6%)) IF S$="KB"      &
	\		GOTO 10390 if d%=m2%(67%)	! Skip fake devices   &
	\		PRINT #1%;C$;"Device	Job	Why" UNLESS C0%	      &
	\		C0%=1%						      &
	\		S1$="J*2="+NUM1$(J%) IF (J% AND 1%)<>0%		      &
	\		S1$="INIT Disabled" IF J%=1%			      &
	\		S1$="CFG Disabled" IF J%=3%			      &
	\		S1$="TRN" IF J%=5%				      &
	\		S1$=NUM1$(J%/2%) UNLESS (J% AND 1%)<>0%		      &
	\		PRINT #1%, S$;					      &
	\		PRINT #1%, NUM1$(U%); UNLESS CR.VP%		      &
	\		PRINT #1%, T9$;S1$;T9$;				      &
	\		GOTO 10380 IF J%=1%				      &
	\		J%=FNP%(D%+6%)					      &
	\		PRINT #1%,"AS"; IF (J% AND (32767%+1%))		      &
	\		IF (J% AND 255%) THEN				      &
				IF (J% AND (32767%+1%)) THEN		      &
					PRINT #1%,"+OPEN";		      &
				ELSE	PRINT #1%,"OPEN";
10370			IF S$="MT" OR S$="MM" OR S$="MS" OR S$="MU" THEN      &
				IF (SWAP%(FNP%(D%+24%)) AND 255%)=0%	      &
					THEN	PRINT #1%,"+DOS";	      &
				ELSE	PRINT #1%,"+ANSI";
10380			PRINT #1%
10390			J2%=J2%+2%					      &
	\		GOTO 10420 IF E%				      &
	\	NEXT U%
10400		J1%=J1%+2%						      &
	\ DVPTR%=DVPTR%+2%						      &
	\ NEXT C%							      &
	! GET OUT IF /BUFFERS SPECIFIED.				      &
	! M%(5%)	DEVCNT -> MAX UNIT NUMBER			      &
	! M%(7%)	DEVPTR -> EACH ENTRY IS A POINTER TO A POINTER	      &
	!			  TO THE UNIT 0 DDB OF THE NON-DISK DEVICE.   &
	! M2%(5%)	DEVNAM -> ASCII DEVICE NAMES			      &
	! M2%(9%)	DEVOKB -> NON-DISKS				      &
	! M2%(23%)	DEVSYN -> ALTERNATE DEVICE NAMES		      &
	!								      &
	! CLEAR BUSY DEVICES EXIST FLAG.				      &
	! J1%	1ST NON-DISK IN DEVCNT					      &
	! J2%	POINTS TO DEVPTR WHICH WILL POINT TO DEVTBL		      &
	! FOR ALL NON-DISK DEVICES (C% POINTS TO NON-DISK ENTRY IN	      &
	! DEVNAM - STOPS BEFORE DEVSYN)					      &
	!	GET THE DEVICE NAME.					      &
	!	FOR 0 TO THE MAXIMUM # OF UNITS FOR THIS TYPE:		      &
	!		POINT D% TO THE PROPER DDB (VARIABLE LENGTH)	      &
	!								      &
	!		  DDB		OFFSET				      &
	!		DDSTS - DDIDX	0				      &
	!		DDUNT - DDJBNO	2				      &
	!		   DDTIME	4				      &
	!		STATUS - DDCNT	6				      &
	!								      &
	!		LOOK AT THE OWNER JOB INDEX IN THE DDB (DDJBNO)	      &
	!		0	SIGNALS FREE				      &
	!		ODD	SIGNALS DISABLED DEVICE			      &
	!		IGNORE THE UNIT IF IT'S ONE OF THESE.		      &
	!		IF IT'S A TERMINAL, CHECK THE DDB ASSIGNMENT	      &
	!		STATUS TO SEE IF IT'S THE JOB'S CONSOLE		      &
	!		TERMINAL - IF SO, IGNORE IT.			      &
	!		OTHERWISE, PRINT THE DEVICE,UNIT # AND JOB #	      &
	!		GET THE ASSIGNMENT STATUS FROM THE DDB.		      &
	!		CHECK TO SEE IF THE DEVICE WAS ASSIGNED ("AS")	      &
	!		IF THE INIT COUNT IN DDCNT WAS NON-ZERO,	      &
	!		PRINT (OR TACK ON IF ALSO ASSIGNED) "OPEN".	      &
	!		IF WE HAVE A MAGTAPE, CHECK APPROPRIATELY.	      &
	!		CONTINUE IF THERE WERE NO FNP% ERRORS.		      &

10410	PRINT #1%," None" UNLESS C0%					      &
	! LET THE USER KNOW IF THERE WEREN'T ANY BUSY DEVICES		      &

10420	RETURN								      &

10450	!								      &
									      &
									      &
	!	B U F F E R,   H U N G   T T Y    A N D			      &
	!	J O B   C O U N T    I N F O R M A T I O N		      &
									      &
									      &

10460	J%=FNP%(M2%(11%))						      &
	\ C%=FNP%(M2%(17%))						      &
	\ IF E%=0% THEN							      &
		C%=C%-J% IF J%>0%					      &
	\	PRINT #1%,C$;						      &
		"General";TAB(9%);"FIP";TAB(32%);"Hung";C$;		      &
		"Buffers";TAB(9%);"Buffers";TAB(18%);"Jobs/Jobmax";TAB(32%);  &
		"TTY'S";TAB(40%);"Errors";C$;				      &
		TAB(2%);FNN$(3%,FNP%(M2%(3%)+2%));TAB(11%);		      &
		FNN$(3%,FNP%(M2%(3%)-2%));TAB(18%);			      &
		FNN$(4%,(FNP%(M2%(13%)) AND 255%));"/";			      &
		NUM1$(SWAP%(FNP%(M2%(13%))) AND 255%);TAB(32%);		      &
		FNN$(3%,J%);TAB(40%);FNN$(3%,C%)			      &
	! C%=TOTAL ERROR COUNT (ERLCTL)-TTYHCT (J%, # OF HUNG TTY ERRORS      &
	! SINCE SYSTEM STARTUP).					      &
	! PRINT THE HEADER						      &
	! LOOK AT TABLE OF FREE BUFFER INFO (FREES)			      &
	! AND GET # OF GENERAL AND FIP BUFFERS.				      &
	! FROM JOBCNT, DETERMINE THE CURRENT/MAX JOB COUNT.		      &
	! NOTE THAT WE DO THIS ONE IF /BUFFERS SPECIFIED.		      &

10470	RETURN								      &
									      &

10500	!								      &
									      &
									      &
	!	D I S K    S T R U C T U R E				      &
									      &
									      &

10510	PRINT #1%,C$;"Disk Structure:";C$;				      &
	"Dsk  Open    Size      Free    Clu   Err Name      Level  Comments"  &
	\ J2%=M%(19%)							      &
	\ J%=M%(21%)							      &
	\ J1%=M%(17%)							      &
	\ J3%=M2%(21%)							      &
	\ J5%=M%(29%)							      &
	\ J7%=M2%(57%)							      &
	\ FUN%=0%							      &
	\ FOR C%=0% TO (M2%(9%)-2%) STEP 2%				      &
	\	S0$=CVT%$(SWAP%(FNP%(M2%(5%)+C%)))			      &
	\	GOTO 10550 IF E%					      &
	\	FOR U%=0% TO FNP%(M%(5%)+C%)				      &
	\		J4%=FNP%(J2%)					      &
	\		IF J4%<0% THEN					      &
				GOTO 10540				      &
			ELSE	PRINT #1%,S0$;NUM1$(U%);TAB(5%);	      &
				FNN$(3%,J4% AND 511%);TAB(10%);		      &
	\			IF (J4% AND 4096%) THEN			      &
					PRINT #1%,TAB(31%);		      &
					FNN$(4%,FNP%(J1%) AND 255%);	      &
					TAB(35%);			      &
					FNN$(3%,SWAP%(FNP%(J1%)) AND 255%);   &
	\				GOTO 10530
10520			T=FNP%(J%)					      &
	\		T=T+65536. IF T<0.				      &
	\		T=T+65536.*FNP%(M%(25%)+J%-M%(21%))		      &
	\		T9=FNDISKSIZE(J%-M%(21%),M%(17%),M2%(55%))	      &
	\		T9%=(T/T9)*100% IF T9>0.			      &
	\		TOTAL$=NUM1$(T9)				      &
	\		FREE$=NUM1$(T)					      &
	\		PRINT #1%, STRING$(7%-LEN(TOTAL$),32%);TOTAL$;	      &
				   TAB(18%);STRING$(7%-LEN(FREE$),32%);FREE$; &
	\		PRINT #1%, TAB(27%);FNN$(2%,T9%);"%"; IF T9>0.	      &
	\		PRINT #1%, TAB(31%);				      &
			FNN$(3%,FNP%(J1%) AND 255%);TAB(35%);		      &
			FNN$(3%,SWAP%(FNP%(J1%)) AND 255%);TAB(41%);	      &
			RAD$(FNP%(J3%));RAD$(FNP%(J3%+2%));RAD$(FNP%(J3%+4%)) &
			;TAB(45%);					      &
			FNN$(3%,SWAP%(FNP%(J7%)) AND 255%);".";		      &
			NUM1$(FNP%(J7%) AND 255%);
10530			S$="Pub"					      &
	\		S$="Pri" IF (J4% AND 16384%)			      &
	\		S$="NFS" IF (J4% AND 4096%)<>0%			      &
	\		S$=S$+","+"R-O" IF (J4% AND 2%^10%)<>0%		      &
	\		S$=S$+","+"DLA" IF (J4% AND 2%^11%)=0%		      &
	\		S$=S$+","+"DLW" IF ((J4% AND 2%^11%)<>0%)	      &
					AND ((J4% AND 4096%)=0%)	      &
	\		S$=S$+","+"Lck" IF ((J4% AND 2%^13%)<>0%)	      &
					AND ((J4% AND 4096%)=0%)	      &
	\		S$=S$+", LDX" IF FNP%(M%(25%)+(M%(25%)-M%(21%))+FUN%) &
	\		PRINT #1%,TAB(58%);S$;				      &
	\		I%=FNP%(J5%)					      &
	\		PRINT #1%,", NFF"; IF I% AND 512%		      &
	\		PRINT #1%,", INI"; IF I% AND 2%			      &
	\		PRINT #1%,", DP"; IF I% AND 8%			      &
	\		PRINT #1%,", dirty"; IF I% AND 1%		      &
	\		I%=SWAP%(FNP%(J1%)) AND 255%			      &
	\		IF ((J4% AND 20480%)<>0% AND I%<>0%) THEN	      &
				PRINT #1%,", Job ";NUM1$(I%/2%);	      &
					UNLESS (I% AND 1%)<>0%		      &
	\			PRINT #1%,", System "; IF (I% AND 1%)<>0%     &
	!		IF (PRIVATE OR NFS) AND (THERE IS A JOB #) THEN	      &
	!			PRINT OWNING JOB # (NFS OR NOSHARE)	      &
	!			PRINT SYSTEM (IF SWAPFILE (JOB*2 IS ODD))     &

10535			PRINT #1%					      &

10540			FUN%=FUN%+2%					      &
	\		J%=J%+2%					      &
	\		J1%=J1%+2%					      &
	\		J2%=J2%+2%					      &
	\		J5%=J5%+2%					      &
	\		J3%=J3%+10%					      &
	\		J7%=J7%+2%					      &
	\		GOTO 10560 IF E%				      &
	\	NEXT U%
10550	NEXT C%								      &
	! GET OUT IF /BUFFERS SPECIFIED.				      &
	! M%(5%)	DEVCNT -> MAX UNIT NUMBER			      &
	! M%(17%)	UNTCLU -> ERROR COUNT - PCS			      &
	! M%(19%)	UNTCNT -> AVAILABILITY/STATUS OF DISK		      &
	! M%(21%)	SATCTL -> LSB/MSB OF 32-BIT COUNT OF		      &
	! M%(25%)	SATCTM     FREE BLOCKS				      &
	! M2%(5%)	DEVNAM -> ASCII DEVICE NAMES			      &
	! M2%(9%)	DEVOKB -> NON-DISKS				      &
	! M2%(21%)	LOGNAM -> LOGICAL DEVICE NAME TABLE		      &
	! M2%(57%)	UNTLVL    UNIT REV AND LEVEL TABLE		      &
	!								      &
	! PRINT THE HEADER.						      &
	! J2%	UNTCNT							      &
	! J%	SATCTL							      &
	! J1%	UNTCLU							      &
	! J3%	LOGNAM							      &
	! EXTRACT THE DEVICE NAME FROM THE DEVNAM TABLE.		      &
	! FOR ALL DISKS OF THIS TYPE (U%=UNIT #) DO THE FOLLOWING:	      &
	! SET J4%=THE STATUS ENTRY OF ERROR COUNTS			      &
	!	 AND OPEN FILES FOR THIS DEVICE (UNTCNT).		      &
	! IF J4%<0 THEN							      &
	!	THIS DEVICE IS DISMOUNTED AND MAY BE IGNORED.		      &
	! ELSE	PRINT DEVICE, UNIT # AND # OF OPEN FILES ON THE DISK.	      &
	! NEXT, GET THE COUNT OF FREE BLOCKS FROM THE SATCTM AND SATCTL,      &
	! ADJUSTING AS NECESSARY FOR NEGATIVE NUMBERS.			      &
	! CHECK J4% (UNTCNT) TO SEE IF THE FOLLOWING BITS ARE SET:	      &
	!	BIT	MEANING IF SET					      &
	!	14	PRIVATE						      &
	!	13	LOCKED						      &
	!	12	NON-FILE-STR.					      &
	!	11	DATE OF LAST WRITE				      &
	!	10	READ ONLY					      &
	!	 9	LINK-TO-TOP					      &
	! IF NON-FILE-STR. THEN						      &
	!	JUST PRINT ERROR COUNT AND CLUSTER SIZE			      &
	!	THEN GO TO UNTCNT BIT CHECK ROUTINE.			      &
	! CHECK UNTCNT BITS - IF PRI,NFS, CAN ALSO CHECK UNTOWN FOR OWNER     &
	!	AND CLEAN BIT.						      &
	!								      &
	!	IF LARGE FILES ARE CONFIGURED, PRINT OPEN FILE SPECIFICS      &
	!	IF ANY FILES ARE OPEN;					      &
	!	BUMP UNTCNT, SATCTL, UNTOWN, AND UNTCLU POINTERS AND	      &
	!	GO ON TO NEXT DISK OF THIS TYPE				      &
	!	UNLESS THERE WERE ANY FNP% ERRORS.			      &
	! AFTER COMPLETING THIS TYPE, GO ON TO THE NEXT.		      &

10560	RETURN								      &

10600	!								      &
									      &
									      &
	!	O P E N    F I L E S					      &
									      &
									      &
									      &
	!	F I L E   C O N T R O L   B L O C K			      &
	!								      &
	!	   CONTENTS	OFFSET					      &
	!	    F$LINK	   0	PTR TO NEXT FCB			      &
	!	    F$FID	   2	FILE ID OF FILE			      &
	!	    F$PPN	   4	PPN OF FILE			      &
	!	    F$NAM	   6	FILE NAME AND EXTENSION		      &
	!			   8	   IN RAD50			      &
	!			  10					      &
	!	F$PROT-F$STAT	  12	PROTECTION CODE-STATUS BYTE	      &
	!	F$RCNT-F$ACNT	  14	ACCESS CNT FOR READ REGARDLESS-	      &
	!					NORMAL/UPDATE OPENS	      &
	!	    F$WFND	  16	FBB OF FIRST RETRIEVAL ENTRY	      &
	!			  18					      &
	!	    F$UFND	  20 	FBB OF NAME ENTRY		      &
	!	   		  22					      &
	!	F$SIZM-F$UNT	  24 	FILE SIZE MSB-FIP UNIT NUMBER	      &
	!	    F$SIZL	  26	FILE SIZE LSB			      &
	!	    F$CLUS	  28	FILE CLUSTERSIZE		      &
	!	    F$WCB	  30	PTR TO FIRST WCB OPEN ON THIS FILE    &
	!								      &
	! Access to open file information is granted according to the state   &
	! of the user's WREAD and GREAD privs.				      &
	!								      &
	!   WREAD  GREAD  Open file info allowed			      &
	!   -----------------------------------------------------	      &
	!     on    n/a   All files					      &
	!    off     on   Files open by any job whose PPN is in user's group  &
	!		  or any files in user's group open by any PPN	      &
	!    off    off   Files open by any job whose PPN is same as user's   &
	!		  or files in user's PPN open by any PPN	      &
	!								      &

10610	GOTO 10690 UNLESS M2%(29%)					      &
	\ O.DEV$=""	! specific disk is for SYSTAT only, "" for all disks  &
	\ J7%=0%	! specific job is for SYSTAT only, 0 for all jobs     &
	\ PRINT #1%,C$;"Open Files";					      &
!	\ PRINT #1%," (";O.DEV$;" only)"; IF LEN(O.DEV$)		      &
!	\ PRINT #1%," for job ";NUM1$(J7%);":" IF J7%			      &
!	\ PRINT #1%," and jobs accessing them"; IF O8% AND 1024% IF J7%=0%    &
	\ PRINT #1%,":"; UNLESS J7%					      &
	\ HD%,HD1%,T%=0%						      &
	\ J2%=M%(19%)							      &
	\ J6%=M2%(29%)							      &
	!	PRINT HEADER						      &
	!	GET UNTCNT AND FCBLST					      &

10616	FOR C%=0% TO (M2%(9%)-2%) STEP 2%				      &
	\	S0$=CVT%$(SWAP%(FNP%(M2%(5%)+C%)))			      &
	\	FOR U%=0% TO FNP%(M%(5%)+C%)				      &
	\		J4%=FNP%(J2%)					      &
	\		GOTO 10670 IF (J4% AND 4096%)<>0% OR J4%<0%	      &
	\		PRINT #1% IF HD%=0%				      &
	\		HD%=-1%						      &
	\		T%=-1% UNLESS J7%				      &
	\		PRINT #1%,C$;S0$;NUM1$(U%);": -- "; UNLESS J7%	      &
	\		GOTO 10620 IF (J4% AND 511%)>0%			      &
	\		PRINT #1%;"None" UNLESS J7%			      &
	\		GOTO 10670					      &
	!	FOR ALL DISKS IN THE SYSTEM				      &
	!		GET THE DEVICE NAME				      &
	!		FOR ALL UNITS OF THIS DISK			      &
	!			J4%=STATUS ENTRY OF ERROR COUNTS AND	      &
	!				OPEN FILES FOR THIS DEVICE (UNTCNT)   &
	!			IGNORE THIS DISK IF NFS OR DISMOUNTED	      &
	!			ALSO IGNORE IT IF NO OPEN FILES		      &

10620			FCB%=FNP%(J6%)					      &
	\		GOTO 10625 IF FCB%				      &
	\		PRINT #1%;"System files only" UNLESS J7%	      &
	\		GOTO 10670					      &
	!			IF FCBLST = 0 THEN IT IS A SYSTEM FILE	      &
	!				IGNORE IT			      &

10625			PRINT #1%,"File";TAB(26%);"Op/RR";TAB(34%);"Size";    &
			 TAB(41%);"Clu";TAB(49%);"FRE";TAB(63%);"NE";	      &
			 TAB(72%);"Status"				      &
				 IF J7%=0% OR HD1%=0%			      &
	\		HD1%=-1%					      &
	\		WHILE FCB%					      &
	\			F.CLUS%=FNP%(FCB%+28%)			      &
	\			GOTO 10628 IF F.CLUS%=2%^I%		      &
					FOR I%=0% TO 8%			      &
	\			GOTO 10660				      &
	!			PRINT HEADINGS				      &
	!			WHILE NOT END OF FCBLST			      &
	!				CHECK TO SEE IF FILE-CLUSTER IS A     &
	!					POWER OF 2		      &
	!				IF NOT THEN SKIP		      &

10628				GOTO 10630 UNLESS J7%	! No specific job     &
	\			WCB%=FNP%(FCB%+30%)	! Get first WCB	      &
	\			ST%=0%			! none found	      &
	\				WHILE WCB%<>0% AND (ST%=0%)	      &
	\				T%,ST%=-1% IF (FNP%(WCB%+2%)	      &
						AND 255%)=J7%*2%	      &
	\				WCB%=FNP%(WCB%+12%) AND (NOT 31%)     &
	\				NEXT				      &
	\			GOTO 10650 UNLESS ST%	! Next file	      &

10630				ST%=FNP%(FCB%+12%)			      &
	\			FILE.PPN% = FNP%(FCB%+4%)		      &
	\			FILE.PROJ%=SWAP%(FILE.PPN%) AND 255%	      &
	\			FILE.PROG%=FILE.PPN% AND 255%		      &
	\			PRINT #1%,S0$;NUM1$(U%);":";		      &
				 "[";FNN$(3%,FILE.PROJ%);",";		      &
				NUM1$(FILE.PROG%);TAB(12%);"]";		      &
	\			PRINT #1%;				      &
				 RAD$(FNP%(FCB%+6%));RAD$(FNP%(FCB%+8%));     &
				 ".";RAD$(FNP%(FCB%+10%));		      &
		 		"<";FNN$(2%,SWAP%(ST%) AND 255%);">";	      &
		 			UNLESS (ST% AND 64%)<>0%	      &
	\			PRINT #1%;TAB(26%);			      &
				 FNN$(2%,FNP%(FCB%+14%) AND 255%);"/";	      &
				 NUM1$(SWAP%(FNP%(FCB%+14%)) AND 255%);	      &
	\			S$=NUM1$((SWAP%(FNP%(FCB%+24%)) AND 255%)*65536. &
				 +32768.+(FNP%(FCB%+26%) EQV 32767%))	      &
	\			PRINT #1%;TAB(33%);FNS$(5%);TAB(41%);	      &
				 FNN$(2%,F.CLUS%);			      &
	\			FRE%=FNP%(FCB%+16%)			      &
	\			NE%=FNP%(FCB%+20%)			      &
	\			PRINT #1%;TAB(45%);			      &
				 FNLO$((SWAP%(FRE%) AND 255%)*65536.+32768.+  &
		 		 (FNP%(FCB%+18%) EQV 32767%));		      &
		 		 "@";RIGHT(FNO$((FRE% AND 255%)*2%),4%);      &
		 		 TAB(58%);FNLO$((SWAP%(NE%) AND 255%)*65536.  &
				 +32768.+(FNP%(FCB%+22%) EQV 32767%));	      &
		 		 "@";RIGHT(FNO$((NE% AND 255%)*2%),4%);	      &
	\			S$=""					      &
	\			S$=", Pla" IF (ST% AND 2%)<>0%		      &
	\			S$=S$+", "+MID("UpdCtgNoKUFD",(I%-2%)*3%-2%,3%) &
					IF (ST% AND 2%^I%)<>0% FOR I%=3% TO 6% &
	\			T$=""					      &
	\			WCB%=FNP%(FCB%+30%)			      &
	\			T$=T$+", Perm" IF WCB% AND 1%		      &
	\			T$=T$+", Priv" IF WCB% AND 2%		      &
	\			WCB%=WCB% AND -32%			      &
	\			IF (ST% AND 128%) THEN			      &
					T$=", MDL"			      &
	\				IF (FNP%(WCB%) AND 2048%)=0% THEN     &
						T$=", Tent"		      &
						IF (FNP%(WCB%+12%) AND 2%)<>0% &
									      &
	!				PRINT FCB INFO FOR ALL FILES OPEN ON  &
	!					THIS UNIT		      &

10634				PRINT #1%;TAB(72%);RIGHT(S$+T$,3%)	      &
	!				PRINT STATUS			      &

10635				WHILE WCB%<>0%				      &
	\				ST%=FNP%(WCB%)			      &
	\				W.FLG%=FNP%(WCB%+2%)		      &
	\				JOBNO% = (W.FLG% AND 255%)	      &
	\				W.WCB%=FNP%(WCB%+12%)		      &
	\				OPEN.PPN%=FNP%(FNP%(FNP%(M%(11%)      &
					 +JOBNO%)+8%)+24%)		      &
	\ 				OPEN.PROJ%=SWAP%(OPEN.PPN%) AND 255%  &
	\				PRINT #1%;TAB(6%);		      &
	\				GOTO 10660 IF (JOBNO%/2%) > 63%	      &
	\				S$ = NUM1$((SWAP%(FNP%(WCB%+4%))      &
						AND 255%)*65536.+32768.+      &
						(FNP%(WCB%+6%) EQV 32767%))   &
	\				B=VAL(S$) !SAVE LAST BLOCK #	      &
	\				PRINT #1%,"Job ";		      &
	\				PRINT #1%,"NSP"; IF JOBNO% = 3%	      &
	\				PRINT #1%,"TRN"; IF JOBNO% = 5%	      &
	\				PRINT #1%,NUM1$(JOBNO%/2%);	      &
							UNLESS JOBNO% = 3%    &
							    OR JOBNO% = 5%    &
	\				PRINT #1%,TAB(14%);"Block ";S$;	      &
	\				S$=""				      &
	\				S$="NFS, " IF ST% AND 256%	      &
	\				S$=S$+"Rd, " IF (ST% AND 512%)=0%     &
	\				S$=S$+"Wr, " IF (ST% AND 1024%)=0%    &
	\				S$=S$+"UFD, " IF ST% AND 16384%	      &
	\				S$=S$+"Lock " IF ST% AND 8192%	      &
	\				X%=SWAP%(W.FLG%) AND 31%	      &
						IF ST% AND 8192%	      &
	\				S$=S$+NUM1$(B-X%)+"+"+NUM1$(X%)	      &
						IF ST% AND 8192%	      &
	\				S$=S$+", " IF ST% AND 8192%	      &
	\				S$=S$+"Seq, " IF W.WCB% AND 16%	      &
						IF W.WCB% AND 8%	      &
	\				S$=S$+"Rnd, "			      &
						IF (W.WCB% AND 16%)=0%	      &
						IF W.WCB% AND 8%	      &
	\				S$=S$+"Aex, " IF W.WCB% AND 4%	      &
	\				S$=S$+"RR, " IF W.WCB% AND 1%	      &
	\				IF (ST% AND 2048%)=0% THEN	      &
						S$=S$+"Tent, "		      &
							IF (W.WCB% AND 2%)<>0% &
					ELSE	IF (W.WCB% AND 2%)<>0% THEN   &
							S$=S$+"SpUp, "	      &
						ELSE	S$=S$+"Up, "	      &
	!				PRINT JOB # AND BLOCK #		      &

10640					PRINT #1%;			      &
					 TAB(29%);LEFT(S$,LEN(S$)-2%)	      &
	\				GOTO 10648 UNLESS		      &
						(W.FLG% AND 8192%)=8192%      &
	\				WCB%=WCB%+32% ! -> wcb EXTENSION      &
	\				B=0				      &
	\				FOR X%=2% TO 28% STEP 4%	      &
	\				S$=""				      &
	\				S$="Lock "+			      &
					  NUM1$((FNP%(WCB%+x%) AND	      &
					  255%)*65536.+32768.+(FNP%	      &
					  (WCB%+X%+2%) EQV 32767%))+"+"+      &
					  NUM1$(SWAP%(FNP%(WCB%+X%)) AND 255%) &
	\				S$="" IF FNP%(WCB%+X%)=0%	      &
	\				PRINT #1%; TAB(29%);S$ IF LEN(S$)     &
	\				B=B+1 IF LEN(S$)		      &
	\				NEXT X%				      &
	\				PRINT #1%; TAB(29%);		      &
					"No explicit locks"		      &
						IF B=0			      &

10648					WCB%=W.WCB% AND (NOT 31%)	      &
	\			NEXT					      &
	\			PRINT #1%				      &
	!				PRINT WCB INFO			      &

10650				FCB%=FNP%(FCB%)				      &
	\		NEXT	! Get next file (FCB)			      &
	\		PRINT #1% IF J7%=0% OR CCPOS(O%)		      &
	\		GOTO 10670	! Go onto next disk unit	      &

10660			PRINT #1%;"??"
10670			J2%=J2%+2%					      &
	\		J6%=J6%+2%					      &
	\	NEXT U%							      &
	!		INCREMENT UNTCNT AND FCBLST			      &
	!		GOTO NEXT DISK UNIT				      &

10680	NEXT C%								      &
	! AFTER COMPLETING THIS TYPE, GO ON TO THE NEXT.		      &
	! IF NO OPEN FILES EXISTED FOR ANY DEVICE SPECIFIED, PRINT NONE	      &

10690	RETURN								      &
									      &
									      &
									      &

10800	!								      &
									      &
									      &
	!	R E S I D E N T    L I B R A R I E S			      &
									      &
									      &
									      &
	!	L I B    D E S C R I P T O R    B L O C K		      &
	!								      &
	!	  CONTENTS		OFFSET				      &
	!	   R.LINK		  0	PTR TO NEXT LIB		      &
	!	   R.NAME1		  2	LIB NAME		      &
	!	   R.NAME2		  4				      &
	!	   L.PPN		  6	LIB'S OWNING PPN	      &
	!  	   R.MCTL		  8	MEMORY CONTROL AREA	      &
	!	     "" 		 10		""		      &
	!	     "" 		 12		""		      &
	!	  ""   - R.SIZE		 14	  ""  - RTS SIZE IN K WORDS   &
	!	     "" 		 16		""		      &
	!	   R.DATA1		 18	FUN/FBN OF THE RTS	      &
	!	   R.DATA2		 20				      &
	!	   R.FILE1		 22	NE OFFSET/2, FBN OF FILE DATA &
	!	   R.FILE2		 24				      &
	!	   R.CNT		 26	ATTACH/MAP COUNTS	      &
	!	L.PROT - L.STAT		 28	PROT CODE - STATUS	      &
	!	   R.FLAG		 30	LIB FLAGS		      &
	!								      &
	!	R.FLAG BITS:						      &
	!	BIT	MEANING						      &
	!	0-8	MEANINGLESS					      &
	!	 9	ONLY 1 USER					      &
	!	10	MAP RTS READ/WRITE				      &
	!	11	DONT' LOG ERRORS				      &
	!	12	UNCONDITIONAL REMOVE				      &
	!	13	MEANINGLESS					      &
	!	14	SAVE THE LOAD ADDRESS (M.PHYA) (ALWAYS SET)	      &
	!	15	MEANINGLESS					      &
	!								      &
	!	L.STAT BITS:						      &
	!	BIT	MEANING						      &
	!	0-6	(LS.DYN) DYNAMIC REGION BLOCK			      &
	!	 7	(LS.LIB) RESIDENT LIBRARY BLOCK			      &
									      &

10820	J%=M2%(15%)+2%							      &
	\ PRINT #1%,C$;"Resident Libraries:";				      &
	\ HD%=0%							      &
	! GET ROOT OF LIBRARY DESC. BLOCKS (LIBLST), WHICH IS RTSLST+2.	      &

10830	J%=FNP%(J%)							      &
	\ GOTO 10850 IF (J%=0%) OR E%					      &
	\ PRINT #1%,C$;" Name";TAB(7%);"Prot";TAB(19%);"Acct";		      &
	  TAB(29%);"Size";TAB(35%);"Users";TAB(42%);"Comments"		      &
		UNLESS HD%						      &
	\ HD%=-1%							      &
	\ C%=FNP%(J%+26%)						      &
	\ J2%=FNP%(J%+14%)						      &
	\ F%=FNP%(J%+30%)						      &
	\ PPN%=FNP%(J%+6%)						      &
	\ PPROG$=NUM1$(PPN% AND 255%)					      &
	\ IF (FNP%(J%+28%) AND 64%) = 0% THEN				      &
		PRINT #1%,RAD$(FNP%(J%+2%));RAD$(FNP%(J%+4%));		      &
		TAB(7%);"<";FNN$(3%,(SWAP%(FNP%(J%+28%)) AND 255%));">";      &
		TAB(14%)+FNACCOUNT$(M2%(21%),FNP%(J%+18%),FNP%(J%+6%));	      &
		TAB(29%)+FNN$(3%,(J2% AND 255%))+"K";			      &
		TAB(35%)+FNN$(3%,(C% AND 255%));			      &
	  ELSE								      &
	 	PRINT #1%,RAD$(FNP%(J%+2%));RAD$(FNP%(J%+4%));		      &
		TAB(7%);"<";FNN$(3%,(SWAP%(FNP%(J%+28%)) AND 255%));">";      &
		TAB(18%);"[";FNN$(3%,SWAP%(PPN%) AND 255%);",";PPROG$;	      &
			SPACE$(3%-LEN(PPROG$));"]";			      &
		TAB(29%)+FNN$(3%,(J2% AND 255%))+"K";			      &
		TAB(35%)+FNN$(3%,(C% AND 255%));			      &
	! Determine if dynamic region or library			      &

10835	IF (J2% AND -256%)=512% THEN					      &
		S$="Non-Res"						      &
	ELSE	IF (J2% AND 1024%) THEN					      &
			S$="Loading"					      &
		ELSE	S$="Temp"					      &
	\		S$="Perm" IF C%<0%
10840	S$=S$+", Addr:"+NUM1$(FNSR5%(FNP%(J%+16%)))			      &
	\ IF (FNP%(J%+28%)AND 64%) <> 0% THEN				      &
		F% = F% AND 512%					      &

10845	S$=S$+MID(", 1US, R/W, NER, Rem",(I%-9%)*5%+1%,5%) IF		      &
			(F% AND 2%^I%)<>0% FOR I%=9% TO 12%		      &
	\ PRINT #1%,TAB(42%);S$						      &
	\ GOTO 10830							      &

10850	PRINT #1%," None" UNLESS HD%					      &
	\ RETURN							      &
	! C%=R.CNT, J2%=M.CTRL (HI) - R.KSIZ (LO), F%=R.FLAG		      &
	! WE ARE LOOKING AT A RESIDENT LIBRARY (RL) DESCRIPTOR BLOCK (RDB).   &
	! PRINT THE RL NAME (R.NAME), THE ASSOCIATED PROTECTION (L.PROT),     &
	! THE ASSOCIATED PPN (L.PPN),					      &
	!  AND THE SIZE OF THE MODULE IN K (R.KSIZ)			      &
	! AND ITS MAXIMUM USER JOB SIZE IN K (R.SIZE).			      &
	!								      &
	! PRINT THE COUNT OF USERS EXECUTING UNDER THE RL (R.CNT).	      &
	! GET THE LOAD ADDRESS.						      &
	! EXAMINE M.CTRL AND DETERMINE THE CURRENT STATE OF THE RL.	      &
	! CONTINUE IF WE HAVEN'T REACHED THE END (0) OF THE LINKED LIST	      &
	! OF RL DESC. BLOCKS.						      &
									      &

11000	!								      &
									      &
									      &
	!	L I N K S						      &
									      &
									      &

11020	HD%=0%								      &
	\ GET.NUM%=-1%							      &
	\ NOB%=FNP%(DEC%(3%))						      &
	\ WHILE NOB%							      &
	\	LLB%=FNP%(NOB%+24%)					      &
	\	WHILE LLB%						      &
	\		LLB%=LLB%-28%					      &
	\		GOSUB 12240					      &
	\		GOSUB 12400					      &
	\		GOSUB 12600					      &
	\		GOTO 11100 IF E%				      &
	\		LLB%=FNP%(LLB%+28%)				      &
	\	NEXT							      &
	\	NOB%=FNP%(NOB%+28%)					      &
	\ NEXT								      &
		! CLEAR THE "FOUND A LOGICAL LINK"			      &
		! SET "GET LINK #'S" FLAGS.				      &
		! IF HAVE AN ACTIVE NODE:				      &
		! WE CAN EXTRACT THE LIST HEAD OF LLB'S FOR LINKS	      &
		! OPEN TO THE NODE.					      &
		! PLOW THROUGH THE LIST OF LLB'S FOR THIS NODE:		      &
		!	GET RIB INFO					      &
		!	GET/PRINT THE REMAINING INFO.			      &
		! CONTINUE TILL WE'VE COMPLETED THE LAST LLB.		      &
		! DO THIS FOR ALL NODES					      &

11060	PRINT #1%,C$;"No DECnet Logical Links were in use."		      &
			UNLESS HD% OR E%<>0%				      &
		! LET THE USER KNOW IF ALL LINKS WERE FREE		      &

11100	RETURN								      &
		! LINK ROUTINE EXIT.					      &


11500	DIM	HEX%(6%)			!Hex conversion array	      &
\	TRUE% = -1%				!DEFINE BOOLEAN TRUE	      &
\	FALSE% = 0%				!DEFINE BOOLEAN FALSE	      &
\	VALID_MUX$ = "DJ,DH,DZ,VH"		!VALID MULTIPLEXOR TYPES      &
\	LINE_TYPE$ = "KL"+"DC"+"DL"+"DE"+"PK"+	!LINE TYPES (IN ORDER)	      &
		     "DJ"+"DH"+"DZ"+"VH"+"??"				      &
\	CONT_TYPE$ = "KL"+"DC"+"DE"+"PK"+	!LINE TYPES (IN ORDER)	      &
		     "DJ"+"DH"+"DZ"+"VH"				      &
\	ETH_OFFSET% = 64%			!Offset in Ethernet's DDB     &
						! to find the name + address  &
\	PREVIOUSLY_CALLED%=FALSE%		!INITIALIZE FOR LATER USE     &
\	DM_P_V_FOUND%=FALSE%			!INITIALIZE FOR LATER USE     &
\	DM_R_C_FOUND%=FALSE%			!INITIALIZE FOR LATER USE     &
\	KB_FOUND%=FALSE%			!INITIALIZE FOR LATER USE     &
\	DEVCNT%=M%(5%)-2%						      &
\	DEVPTR%=M%(7%)-2%						      &
\	DEVNAM%=M2%(5%)-2%						      &
\	CSRTBL%=M2%(7%)							      &
\	UMT_DU%=M2%(77%)						      &
\	CMT%=M2%(73%)							      &
\	CM.CSR%=6%*2%							      &
\	CMTSIZ%=9%*2%							      &
\	FAKDDB%=M2%(67%)						      &
\	DEVTBL% = FNP%(DEVPTR%+DEVOKB%)		!START OF DEVTBL	      &
									      &
\	LAST_CONT$ = ""				!INIT LAST KB CONTROLLER NAME &
\ 	OUTPUT_COMPLETE% = FALSE%		!SET IF ANY OUTPUT IS DONE    &
\	DISK%=-1% 				! FIRST DEVICES ARE DISKS     &
\ DEVICE_LOOP:					!DEVICE TABLE LOOP	      &
\	DEVNAM% = DEVNAM%+2%			!POINT AT NEXT ENTRY	      &
\	DEVCNT% = DEVCNT%+2%			!POINT AT NEXT ENTRY	      &
\	DEVPTR% = DEVPTR%+2%			!POINT AT NEXT ENTRY	      &
\	CONT_NAME$ = ""				!INIT KB CONTROLLER NAME      &
\	DEVICE_TYPE% = FNP%(DEVNAM%)		!GET A DEVICE		      &
\	MAXIMUM_UNIT% = FNP%(DEVCNT%)		!AND THE MAXIMUM UNIT #	      &
\	UNTCNT_POINTER% = FNP%(DEVPTR%)		!POINTER INTO UNTCNT TABLE    &
									      &
\	GOTO SUBPROGRAM_EXIT IF DEVICE_TYPE% = -1% !END OF THE TABLE	      &
\	GOTO DEVICE_LOOP IF MAXIMUM_UNIT% = -1% !NO UNITS POSSIBLE - NEXT     &
		OR MAXIMUM_UNIT%>255%		!NOT A UNIT, BUT A SYNONYM    &
									      &
\    DEVICEUNT_LOOP:				!DEVICE UNIT LOOP	      &
\	   DEVNAM$ = CHR$(DEVICE_TYPE%)+CHR$(SWAP%(DEVICE_TYPE%)) ! DEV NAME  &
\	   KB_FOUND% = TRUE% IF DEVNAM$="KB"!NOW -> 1 CSR/DEVICE from now on  &
									      &
\	FOR UNIT_LOOP% = 0% TO MAXIMUM_UNIT%	!1 PASS/UNIT		      &
\		CONTROL$=""			! CLEAR OUT CONTROLLER INFO   &
\		DEF_ADDR$=""			! CLEAR OUT ANY DEFAULT ADDR  &
\		GOSUB CSR			! GET A CSR		      &
\		KB_VALID%=FALSE%					      &
\		IF DEVNAM$="KB" THEN		!CURRENT DEV A KB?	      &
			GOSUB TERM_INFO		!YES - GET KB CONTROL INFO    &
		ELSE							      &
			GOSUB CONTROLLER_INFO	!HANDLE OTHER CASES	      &
\		END IF				!			      &
\	   GOSUB DEVICE_VALIDATE					      &
\	   IF VALID_DEVICE% THEN					      &
		GOSUB DEVICE_STATUS	!GET STATUS			      &
\		GOSUB CSROCTAL		!CONVERT CSR TO OCTAL		      &
\		PRINT #1%, "Device _";					      &
			DEVNAM$;					      &
			NUM1$(UNIT_LOOP%);":";				      &
\		PRINT #1%, TAB(15%); CONT_NAME$;			      &
			IF LEN(CONT_NAME$)				      &
\		PRINT #1%, TAB(25%);"Control ";CONTROL$;		      &
			IF LEN(CONTROL$)				      &
\		PRINT #1%, TAB(41%);CSR$; IF LEN(CSR$)			      &
\		PRINT #1%, TAB(53%);"Status: ";STATUS$;			      &
			IF LEN(STATUS$)					      &
\		PRINT #1%, TAB(53%);"Def Addr: ";DEF_ADDR$;		      &
			IF LEN(DEF_ADDR$)				      &
\		PRINT #1%, C$;						      &
\			OUTPUT_COMPLETE%=TRUE%				      &
\	   END IF							      &
\		UNTCNT_POINTER%=UNTCNT_POINTER%+2% IF KB_FOUND%		      &
						!POINT AT NEXT DDB	      &
\	NEXT UNIT_LOOP%				!NEXT DEVICE UNIT	      &
\	GOTO DEVICE_LOOP			!NEXT DEVICE TYPE	      &
		UNLESS (LOOKUP_DEV_LEN% = TRUE%) AND OUTPUT_COMPLETE%	      &
\	GOTO SUBPROGRAM_EXIT						      &
									      &
\ TERM_INFO:					!CODE TO COPE WITH TERMINALS  &
\	DYN.PK% = (FNP%(FNP%(UNTCNT_POINTER%)) AND 16384%) = 16384%	      &
						!IS THIS A DYNAMIC PK?	      &
\	DDJBNO% = FNP%(FNP%(UNTCNT_POINTER%)+2%)! DDJBNO FROM DDB	      &
\	DDSTS% = FNP%(FNP%(UNTCNT_POINTER%))	! control flags		      &
\	TTINTF% = FNP%(FNP%(UNTCNT_POINTER%)+30%)!TTINTF FROM DDB	      &
\	SUBLINE% = SWAP%(TTINTF% AND 3840%)	!SUBLINE NUMBER FROM DDB      &
\	TT_TYPE% = (TTINTF% AND 255%)		!INTERFACE TYPE*2%	      &
\	KB_VALID%=TRUE% IF TT_TYPE%<=18%	! VALIDATE KB'S		      &
\	IF KB_VALID%=TRUE% THEN						      &
		TT_TYPE$ = MID(LINE_TYPE$,TT_TYPE%+1%,2%)!STRING EQV	      &
\		IF DYN.PK% THEN			!IF IT'S A DYNAMIC PK	      &
			IF TT_TYPE$ <> "PK" THEN!  IF IT'S NOT USED AS A PK   &
				TT_TYPE$ = "LAT"!    IT MUST BE LAT	      &
\			END IF						      &
\			CONT_NAME$ = ""		!  NO ALTERNATE CONT NAME     &
\			CONTROL$ = TT_TYPE$ + ":"!  NO UNIT # IN CONTROLLER   &
\			CSR% = 0%		!  NO CONTROLLER ADDRESS      &
\			RETURN			!  THAT'S IT, SO GO BACK      &
\		END IF							      &
\	END IF								      &
									      &
\	TEST% = INSTR(1%,VALID_MUX$,TT_TYPE$)	!IS IT A MUX?		      &
									      &
\	IF NOT (PREVIOUSLY_CALLED%) THEN	!GET CONTROLLER NUMBER	      &
		PREVIOUSLY_CALLED% = TRUE%	!ONE SHOT MUX CODE	      &
\		LAST_SUBLINE%=0%		!FIRST SUBLINE		      &
\		INTF_UNIT%=0%			!FIRST INTERFACE	      &
\		LAST_TYPE$=TT_TYPE$		!CURRENT TYPE IS SAVED TYPE   &
	ELSE					!WE HAVE BEEN CALLED BEFORE   &
		IF SUBLINE%<=LAST_SUBLINE% THEN	!DID WE CHANGE INTERFACE?     &
			IF LAST_TYPE$=TT_TYPE$ THEN      !SAME INTERFACE TYPE &
				LINE_UNIT%=LINE_UNIT%+1% !INCREMENT LINE_UNIT &
			ELSE						      &
				LINE_UNIT%=0%		 !NEW INTERFACE TYPE  &
\				LAST_TYPE$=TT_TYPE$	 !SAVE CURRENT KB TYP &
\			END IF						      &
\		END IF							      &
\		LAST_SUBLINE%=SUBLINE%	 	!SAVE SUBLINE		      &
\	END IF					!DONE MUX CODE		      &
\									      &
\	TERM_INFO_2:							      &
\	CONT_TYPE% = INSTR(1%,CONT_TYPE$,TT_TYPE$)/2% !GET THE CONTROLLER     &
						!  TYPE VALUE		      &
\	CONT_CHAR$ = CHR$(65%+CONT_TYPE%)	!  GET THE CHAR (A - H)	      &
\	IF LAST_CONT$ <> CONT_CHAR$ THEN	!  IF THE CONTROLLER CHANGED  &
		LAST_CONT$ = CONT_CHAR$		!    NEW CONTROLLER TYPE      &
\		THIS_SUBLINE% = 0%		!    START AT ZERO	      &
	ELSE					!  SAME CONTROLLER AS BEFORE  &
		THIS_SUBLINE% = THIS_SUBLINE% + 1% !INCREMENT TO NEXT SUBLINE &
\	END IF								      &
\	CONTROL$ =				!APPEND DATA ABOUT THIS DEV   &
		TT_TYPE$+			!INTERFACE TYPE		      &
		NUM1$(LINE_UNIT%)+":"		!INTERFACE NUMBER	      &
\	IF TEST% THEN				!VALID MUX?		      &
		CONTROL$ = CONTROL$ +		!YES - ADD		      &
		NUM1$(SUBLINE%)			!SUBLINE #		      &
\	END IF					!			      &
\	CONT_NAME$ = "(KB" + CONT_CHAR$ +	!FORM THE CONTROLLER NAME     &
		NUM1$(THIS_SUBLINE%) + ":)"				      &
\	IF CONT_NAME$ = "(KBA0:)" THEN		!SPECIAL CASE KB0	      &
		CONTROL$ = "TT0:"		! SET CONTROLLER TO TT0:      &
\		LINE_UNIT% = LINE_UNIT% - 1%	! SET UP FOR NEXT DL11 CONT   &
\	END IF								      &
\	RETURN					!BACK TO CALLER		      &
\ CONTROLLER_INFO:							      &
\	SELECT DEVNAM$				!SELECT DEVICE NAME	      &
						!NO SPECIFIC ORDER ON DEVs    &
									      &
						!***** DISKS *****	      &
\	CASE = "DK"	\ CONTROL$="RK:"	!RK05, CONTROLLER TYPE RK     &
\	CASE = "DL"	\ CONTROL$="RL:"	!RL01-2, CONTROLLER TYPE RL   &
\	CASE = "DP"	\ CONTROL$="RP:"	!RP02/3, CONTROLLER TYPE RP   &
\	CASE = "DB"	\ CONTROL$="RB:"	!RP04-7, CONTROLLER TYPE RB   &
\	CASE = "DM"	\ CONTROL$="RM:"	!RK06-7, CONTROLLER TYPE RM   &
\	CASE = "DR"	\ CONTROL$="RR:"	!RM02-5, CONTROLLER TYPE RR   &
\	CASE = "DU"	\ CONTROL$="RU:"	!RA/RC25, CONTROLLER TYPE RU  &
									      &
\	CASE = "LP"				!PRINTER		      &
\		CONTROL$="LP"+NUM1$(UNIT_LOOP%)+!CONTROL SAME AS PRINTER      &
		   ":"				!NAME			      &
\	CASE = "MM"				!TU77,78, TE16, TU16, TU45    &
\		CONTROL$="TU:"			!CONTROLLER TYPE TU	      &
\	CASE = "MS"				!MS TAPE		      &
\		CONTROL$="TS:"			!CONTROLLER TYPE TS	      &
\		MTTM02%=SWAP%(FNP%(FNP%(UNTCNT_POINTER%)+8%)) AND 255%	      &
\		CONTROL$="TS11" IF MTTM02%=0%	!OH NO, A TS11		      &
\		CONTROL$="TU80" IF MTTM02%=2%	! TU80			      &
\		CONTROL$="TK25" IF MTTM02%=4%	! TK25			      &
\		CONTROL$="TS05" IF MTTM02%=6%	! TS05			      &
\	CASE = "MU"				! TMSCP			      &
\		CONTROL$=""						      &
\		MTTM02%=SWAP%(FNP%(FNP%(UNTCNT_POINTER%)+8%)) AND 255%	      &
\		CONTROL$="TU81" IF MTTM02%=2%	! TU81			      &
\		CONTROL$="TK50" IF MTTM02%=3%	! TK50			      &
\		CONTROL$="TK70" IF MTTM02%=14%	! TK70			      &
\	CASE = "MT"				!TE10,			      &
\		CONTROL$="TM:"			!CONTROLLER TYPE TM?	      &
\	CASE = "DX"				!RX01, RX02		      &
\		RX_UNIT=UNIT_LOOP%/2.0		!REAL DIVIDE		      &
\		RX_UNIT%=UNIT_LOOP%/2%		!INTEGER DIVIDE		      &
\		CONTROL$="RX"+NUM1$(RX_UNIT%)+	!CONTROLLER TYPE RX+UNIT+     &
		":"+NUM1$((RX_UNIT-RX_UNIT%)*2%)!":"+ 0 =LEFT DRIVE,1=RIGHT   &
									      &
						!***** COM DEVICES *****      &
\	CASE = "XM"				!DMC, DMR		      &
\		DDFLAG%=FNP%(FNP%(UNTCNT_POINTER%)+8%)!DDFLAG FROM DDB	      &
\		IF NOT(DM_R_C_FOUND%) THEN	!CALLED BEFORE?		      &
			DM_R_C_FOUND%=TRUE%	!NO - BUT NOW WE HAVE	      &
\			DM_R_C_UNIT%=0%		!FIRST UNIT SHOULD BE ZERO    &
		ELSE				!			      &
			DM_R_C_UNIT%=DM_R_C_UNIT%+1% !INCREMENT UNIT #	      &
		END IF				!			      &
\		IF DDFLAG% AND 128% THEN	!DMR BIT SET?		      &
			XM_TYPE$="DMR"		!YUP			      &
		ELSE				!			      &
			XM_TYPE$="DMC"		!NO, MUST BE A DMC	      &
		END IF				!			      &
\		CONTROL$=XM_TYPE$+"-"+NUM1$(DM_R_C_UNIT%) !SET CONTROL	      &
\	CASE = "XD"				!DMP/DMV (A BIT TRICKY)	      &
\		DDFLAG%=FNP%(FNP%(UNTCNT_POINTER%)+8%)!DDFLAG FROM DDB	      &
\		IF NOT(DM_P_V_FOUND%) THEN	!PREVIOUSLY CALLED?	      &
			DM_P_V_FOUND%=TRUE%	!NO - BUT NOW WE HAVE BEEN    &
\			XD_NUM%,XD_TRIB%=0%	!MUST BE FIRST LINE/TRIBUTARY &
\			XD_CSR%=CSR%		!SAVE THE CSR OF THIS DEVICE  &
		ELSE							      &
			IF XD_CSR%=CSR% THEN	!SAME CSR AS LAST DMP/DMV?    &
\				XD_TRIB%=XD_TRIB%+1% !YES,INCREMENT TRIBUTARY &
			ELSE			!			      &
				XD_TRIB%=0%	!NOPE, RESET TRIBUTARY	      &
\				XD_CSR%=CSR%	!SAVE NEW CSR		      &
\				XD_NUM%=XD_NUM%+1% !INCREMENT LINE #	      &
			END IF			!			      &
\		END IF				!			      &
\		IF DDFLAG% AND 128% THEN	!DMV BIT SET?		      &
			XD_TYPE$="DMV"		!YES			      &
		ELSE				!			      &
			XD_TYPE$="DMP"		!NO - MUST BE A DMP	      &
\		END IF				!			      &
\		CONTROL$=XD_TYPE$+"-"+		!CONTROLLER TYPE XD+	      &
		   NUM1$(XD_NUM%)+"."+		!NUMBER OF CONTROLLER	      &
		   NUM1$(XD_TRIB%)		!TRIBUTARY		      &
									      &
\	CASE = "XE"				!UNA DEVICE		      &
\		XENAME%=FNP%(FNP%(UNTCNT_POINTER%)+ETH_OFFSET%)		      &
						!NAME FROM DDB		      &
\		CONT_NAME$ = "(DE"+RAD$(XENAME%)+")"!CONVERT THE NAME TO ASCII &
\		IF NOT(XE_FOUND%) THEN		!CALLED BEFORE?		      &
			XE_FOUND%=TRUE%		!NO - BUT NOW WE HAVE	      &
\			XE_UNIT%=0%		!FIRST UNIT SHOULD BE ZERO    &
		ELSE				!			      &
			XE_UNIT%=XE_UNIT%+1%	!INCREMENT UNIT #	      &
		END IF				!			      &
\		CONTROL$ = "UNA-" + NUM1$(XE_UNIT%) !ADD UNIT #		      &
\		DEF_ADDR$ = FNHEX$(FNP%(UNTCNT_POINTER%)) !GET ADDRESS	      &
									      &
\	CASE = "XH"				!QNA DEVICE		      &
\		XHNAME%=FNP%(FNP%(UNTCNT_POINTER%)+ETH_OFFSET%)		      &
						!NAME FROM DDB		      &
\		CONT_NAME$ = "(DE"+RAD$(XHNAME%)+")"!CONVERT THE NAME TO ASCII &
\		IF NOT(XH_FOUND%) THEN		!CALLED BEFORE?		      &
			XH_FOUND%=TRUE%		!NO - BUT NOW WE HAVE	      &
\			XH_UNIT%=0%		!FIRST UNIT SHOULD BE ZERO    &
		ELSE				!			      &
			XH_UNIT%=XH_UNIT%+1%	!INCREMENT UNIT #	      &
		END IF				!			      &
\		CONTROL$ = "QNA-" + NUM1$(XH_UNIT%) !ADD UNIT #		      &
\		DEF_ADDR$ = FNHEX$(FNP%(UNTCNT_POINTER%)) !GET ADDRESS	      &
									      &
\	END SELECT				!END OF CASE		      &
\	RETURN					!BACK TO CALLER		      &
\ CSR:						!GET CSR OF DEVICE (IF REAL)  &
	RETURN IF (DEVNAM$="PK")		!SKIP PK DEVICES	      &
\	IF (UNIT_LOOP%=0%) OR (KB_FOUND%) THEN  !NEW CSR?		      &
		CSR% = FNP%(CSRTBL%+CSR_CNT%)	!GET CSR FROM CSRTBL	      &
\	        CSR_CNT% = CSR_CNT% + 2%	!POINT AT NEXT ENTRY IN TABLE &
\	END IF					!			      &
									      &
\	RETURN					!BACK TO CALLER		      &
\ CSROCTAL:								      &
									      &
\	IF (TT_TYPE%=8%) OR (CSR%=0%) OR	!SKIP DEVS WITHOUT REAL CSRs  &
	   (INSTR(1%,"DV,NL,PK",DEVNAM$)<>0%) THEN			      &
		CSR$=""				!INVALIDATE CSR STRING	      &
	ELSE								      &
		CSR% = CSR% AND 32767%		!NEEDED FOR OCTAL CONVERSION  &
\		CSR$ = "CSR 7"			!FIRST DIGIT ALWAYS 7	      &
\		CSR$ = CSR$+			!BUILD THE STRING	      &
			CHR$(48%+((CSR%/8%^Q%) AND 7%))			      &
			FOR Q% = 4% TO 0% STEP -1%			      &
\	END IF					!			      &
									      &
\	RETURN					!BACK TO CALLER		      &
									      &
\ DEVICE_VALIDATE:							      &
	VALID_DEVICE% = 0%						      &
\	DISK% = FALSE%							      &
\	IF MID(DEVNAM$,1%,1%)="D" AND KB_FOUND%=FALSE% THEN		      &
		DISK% = TRUE%						      &
\		VALID_DEVICE% = TRUE%		!SET FLAG TO VALID	      &
\		GOTO DEVICE_VALIDATE_EXIT				      &
\	END IF								      &
									      &
\	IF DEVNAM$="KB" THEN						      &
		VALID_DEVICE% = TRUE% IF KB_VALID% = TRUE%		      &
\	END IF								      &
									      &
\	IF FNP%(FNP%(DEVPTR%)+UNIT_LOOP%*2%)<>FAKDDB% THEN		      &
		VALID_DEVICE%=TRUE%		!SET FLAG TO VALID	      &
	ELSE	VALID_DEVICE% = FALSE%		!SET FLAG TO NOT VALID	      &
\		GOTO DEVICE_VALIDATE_EXIT				      &
\	END IF								      &
									      &
\	DEVICE_VALIDATE_EXIT:						      &
\	RETURN								      &
									      &
\ DEVICE_STATUS:							      &
	STATUS$=""				!CLEAR THE STATUS	      &
\	GOSUB DEVICE_STATUS_DISK IF DISK%	!GET DISK STATUS	      &
\	GOTO DEVICE_STATUS_EXIT UNLESS DEVNAM$="KB"!DISKS ARE DONE	      &
\	DDJBNO%=0% IF TT_TYPE$="PK" AND DEVNAM$="KB"	! NOT REALLY DISABLED &
\	SELECT DDJBNO%				!SELECT DDJBNO		      &
\	   CASE = 1%				!OWNED BY INIT?		      &
\		STATUS$="Disabled by INIT"	!			      &
\	   CASE = 3%				!OWNED BY CFG?		      &
\		STATUS$="Disabled"		!			      &
\	   CASE = 5%				!OWNED BY DECNET	      &
\		STATUS$="Owned by DECnet"	!			      &
\	   CASE = 7%				!OWNED BY LAT		      &
\		STATUS$="Owned by LAT"		!			      &
\	   CASE ELSE				!			      &
\		STATUS$=""			!			      &
\	END SELECT				!END OF SELECT		      &
\	DEF_ADDR$ = "" IF LEN(STATUS$)		!Disabled Ethernet device     &
						! overrides Default Address   &
\	GOTO DEVICE_STATUS_EXIT IF LEN(STATUS$) !SKIP THE REST IF DISABLED or &
		OR LEN(DEF_ADDR$)		! if there is a Def Address   &
\	IF DDSTS% AND 2%^8% THEN		!RESTRICTED LINE?	      &
		STATUS$=STATUS$+", " 		!YES			      &
			IF LEN(STATUS$) 	!APPEND ", " IF NEEDED	      &
\		STATUS$=STATUS$+"Restricted"	!SET STATUS$		      &
\	END IF								      &
\	IF (TTINTF% AND 16384%) AND (DEVNAM$="KB") THEN !DIALUP?	      &
		STATUS$=STATUS$+", "		!YES			      &
			IF LEN(STATUS$)		!APPEND ", " IF NEEDED	      &
\		STATUS$=STATUS$+"Dialup"	!SET STATUS$		      &
\	END IF					!			      &
									      &
\	DEVICE_STATUS_EXIT:						      &
\	   RETURN				!BACK TO CALLER		      &
									      &
\ DEVICE_STATUS_DISK:							      &
\	STATUS$= "Disabled by INIT"	!SET DEFAULT TO DISABLED	      &
\	DSTAT% = 32767%+1%		! AND DEFAULT TO DISMOUNTED	      &
\	DSTAT%=FNP%(FNP%(DEVPTR%)+UNIT_LOOP%*2%)			      &
\	IF DEVNAM$ = "DU" THEN		!IF IT'S A DU DISK		      &
		CSR% = 0%		! INITIALIZE TO NO CSR		      &
\		UREAL% = FNP%(UMT_DU% + UNIT_LOOP%*4% +2%)		      &
			! UMT$DU + (UNIT# * 4) + OFFSET 2		      &
\		IF UREAL% <> 0% THEN	!  IF THE UNIT IS REAL		      &
			CNTRL% = FNP%(UMT_DU% + (UNIT_LOOP%*4%))/CMTSIZ%      &
				! UMT$DU + (UNIT# * 4) / CMT TABLE ENTRY SIZE &
\			CONTROL$ = "RU"+NUM1$(CNTRL%)+":"		      &
\			CSR% = FNP%(CMT% + CMTSIZ%*CNTRL% + CM.CSR%)	      &
				! CMT + (CTRLR# * TBL SIZE) + CSR OFFSET      &
\		ELSE			!  IF NO CSR			      &
			STATUS$= "Non-existent"	!  SET TO NON-EXISTENT	      &
\		END IF							      &
\	END IF								      &

11600	IF (DSTAT% AND 2%^13%) THEN	!IF THE DISK IS RESTRICTED	      &
\	  IF (DSTAT% AND 2%^15%) THEN	! THEN IF THE DISK ISN'T MOUNTED      &
		STATUS$= "Disabled by INIT" !  SET STATUS TO DISABLED	      &
	  ELSE								      &
		STATUS$= "Restricted"	! ELSE SET STATUS TO RESTRICTED	      &
\	  END IF							      &
	ELSE				!IF A NON-RESTRICTED DISK	      &
	  STATUS$= ""			!SET NO STATUS			      &
		IF STATUS$ <> "Non-existent"	!  IF NOT SET TO NON-EXISTENT &
\	END IF								      &

11610	IF DSTAT%>=0% THEN			!DISK MOUNTED?		      &
		STATUS$=", "+STATUS$		!YES			      &
			IF LEN(STATUS$)		!APPEND ", " IF NEEDED	      &
\		STATUS$="Mounted"+STATUS$	!Add Mounted to status	      &
\	END IF								      &
\	RETURN								      &
\ SUBPROGRAM_EXIT:				!DONE WITH SHOW DEVICES	      &
\	RETURN					!EXIT			      &


11700	!								      &
	!	F u n c t i o n s					      &
	!								      &
	DEF FNHEX$(ETH_DDB%)			!Function to return the	      &
						!Default physical address     &
\	ADDR_HEX$ = ""				!Init the storage variable    &
\	HEX%(I%) = FNP%(ETH_DDB%+ETH_OFFSET%+I%+1%) AND 255%!Get a byte	      &
						!	of hex numbers	      &
		FOR I% = 1% TO 5% STEP 2%	! from low byte of each word  &
\	HEX%(I%) = SWAP%(FNP%(ETH_DDB%+ETH_OFFSET%+I%)) AND 255% !Get another &
		FOR I% = 2% TO 6% STEP 2%	! from high byte of each word &
\	FOR I% = 1% TO 6%			!For each of the six bytes    &
\		HEX% = (HEX%(I%) AND 240%)/16%	! Get the first hex number    &
\		HEX$ = NUM1$(HEX%)		! Make a string out of it     &
\		GOTO 11710 IF HEX% < 10%	! Hex = Decimal if it's < 10  &
\		HEX$ = CHR$(HEX%-10%+65%)	! Convert 11-15 to A-F	      &

11710		ADDR_HEX$ = ADDR_HEX$ + HEX$	! Add it to the others	      &
\		HEX% = HEX%(I%) AND 15%		! Get the last hex number     &
\		HEX$ = NUM1$(HEX%)		! Make a string out of it     &
\		GOTO 11720 IF HEX% < 10%	! Hex = Decimal if it's < 10  &
\		HEX$ = CHR$(HEX%-10%+65%)	! Convert 11-15 to A-F	      &

11720		ADDR_HEX$ = ADDR_HEX$ + HEX$	! Add it to the others	      &
\		ADDR_HEX$ = ADDR_HEX$ + "-" IF I% < 6%!Add dash if not at end &
\	NEXT I%					!Next byte		      &
\	FNHEX$ = ADDR_HEX$			!Store the address	      &
\	FNEND					!End of function	      &


11800	CHECTL%=M2%(69%)						      &
	!								      &
	! offset from CHECTL - name:size; Meaning			      &
	!-------------------------------------------------------------------- &
	!								      &
	! 00 - CH$CTL:.BLKW; 400=>cacheing enabled; 0=>cacheing disabled      &
	! 02 - CH$TIC:.BLKW; 1=>charge cache time; 0=>no charge		      &
	! 04 - CH$SEC:.BLKW; Approx seconds since boot (mod 64k)	      &
	! 06 - CH$NXT:.BLKW; Pointer to "first" in list @ +2 (1=>no cacher)   &
	! 08 - CH$PRV:.BLKW; Pointer to "last" in list @ +0		      &
	! 10 - CH$PAR:.BLKW; PAR6 value for extended cache tags		      &
	! 12 - CH$TAG:.BLKW; List of usable extended cache tags		      &
	! 14 - CH$USM:.BLKW; -1=>use monitor buffer pool; 0=>don't use it     &
	! 16 - CH$WTG:.BLKW; List of usable extended cache write-tags	      &
	! 18 - CH$LIM:.BLKW; Limit of total number of extended cache tags     &
	! 20 - CH$FLM:.BLKW; Limit of number of extended cache directory tags &
	! 22 - CH$DLM:.BLKW; Limit of number of extended cache data tags      &
	! 24 - CH$MOD:.BLKB; 0=>no data; 1=>open mode data; -1=>all data      &
	! 25 - CH$DAT:.BLKB; 0=>no data cacheing; 200=>data cacheing available &
	! 26 - CH$BSZ:.BLKW; Size of a cache cluster in blocks		      &
	! 90 - Cache keep timer?					      &
\	M$="disabled"							      &
\	M$="enabled for Directories" IF FNP%(CHECTL%)=256%		      &
\	PRINT #1%, C$;							      &
\	PRINT #1%,  "Caching configuration"				      &
\	PRINT #1%,  "---------------------"				      &
\	PRINT #1%,  "   Caching ";M$;					      &
\	PRINT #1%,  " and Data"; IF (SWAP%(FNP%(CHECTL%+24%)) AND 255%)=128%  &
\	PRINT #1%, C$;							      &
\	PRINT #1%,  "   Cache Keep timer = ";				      &
		NUM1$(FNI.TO.F(FNP%(CHECTL%+90%)));" seconds"		      &
\	c.l=1%								      &
\	c.l=FNP%(CHECTL%+26%) AND 255%					      &
		IF SWAP%(FNP%(CHECTL%+24%)) AND 255%			      &
\	PRINT #1%,  "   Cluster size = ";NUM1$(c.l)			      &
\	M$="File selectable"						      &
\	M$="All data" IF (FNP%(CHECTL%+24%) AND 255%)=255%		      &
\	M$="Disabled" IF (FNP%(CHECTL%+24%) AND 255%)=0%		      &
\	PRINT #1%,  "   Data caching = ";M$				      &
		IF SWAP%(FNP%(CHECTL%+24%)) AND 255%			      &
\	PRINT #1%, C$;							      &
\	PRINT #1%,  "XBUF usage (in K-words)"				      &
\	PRINT #1%,  "-----------------------"				      &
!									      &
\	CHENUE%=M2%(71%)						      &
\	PRINT #1%,  "   Total cache:"; TAB(25%);			      &
\		ALL.WD = FNI.TO.F(FNP%(CHECTL%+18%))			      &
\		VAL.UE = FNI.TO.F(FNP%(CHENUE%))			      &
\		PRINT #1%  USING "####.##", VAL.UE*(c.l/4%);		      &
\		PRINT #1%,  " (maximum clusters allowed: ";		      &
\		PRINT #1%,  "Unlimited"; IF ALL.WD = 65535.		      &
\		PRINT #1%,  NUM1$(VAL.UE); IF ALL.WD <> 65535.		      &
\		PRINT #1%,  ")"						      &
!									      &
\	PRINT #1%,  "   Directory cache:"; TAB(25%);			      &
\		ALL.WD = FNI.TO.F(FNP%(CHECTL%+20%))			      &
\		VAL.UE = FNI.TO.F(FNP%(CHENUE%+2%))			      &
\		PRINT #1%  USING "####.##", VAL.UE*(c.l/4%);		      &
\		PRINT #1%,  " (maximum clusters allowed: ";		      &
\		PRINT #1%,  "Unlimited"; IF ALL.WD = 65535.		      &
\		PRINT #1%,  NUM1$(VAL.UE); IF ALL.WD <> 65535.		      &
\		PRINT #1%,  ")"						      &
!									      &
\	PRINT #1%,  "   Data cache:"; TAB(25%);				      &
\		ALL.WD = FNI.TO.F(FNP%(CHECTL%+22%))			      &
\		VAL.UE = FNI.TO.F(FNP%(CHENUE%+4%))			      &
\		PRINT #1%  USING "####.##", VAL.UE*(c.l/4%);		      &
\		PRINT #1%,  " (maximum clusters allowed: ";		      &
\		PRINT #1%,  "Unlimited"; IF ALL.WD = 65535.		      &
\		PRINT #1%,  NUM1$(VAL.UE); IF ALL.WD <> 65535.		      &
\		PRINT #1%,  ")"						      &
!									      &
\	INVALID%=FNP%(CHENUE%+6%)					      &
\	IF INVALID% THEN						      &
		PRINT #1%,  "   Pending replacement:"; TAB(25%);	      &
\		PRINT #1%  USING "####.##",				      &
			FNI.TO.F(INVALID%)*(c.l/4%)			      &
\	END IF								      &
!									      &
\	RTSLST%=M2%(15%) ! GET RTS POINTER				      &
\	PRINT #1%,  "   ASSIGN/SYSTEM tables:"; TAB(25%);		      &
\	PRINT #1%  USING "  ##.##",(FNI.TO.F(FNP%(RTSLST%+4%))*64.)/1024.     &
\	PRINT #1%,  "   LOAD/OVERLAY tables:"; TAB(25%);		      &
\	PRINT #1%  USING " ###.##",FNI.TO.F(FNP%(RTSLST%+12%))/2048.	      &
\	PRINT #1%,  "   LOAD/INDEX tables:"; TAB(25%);			      &
\	PRINT #1%  USING "  ##.##",FNI.TO.F(FNP%(RTSLST%+14%))/2048.	      &
\	PRINT #1%,  "   DCL Buffers:"; TAB(25%);			      &
\	PRINT #1%  USING "  ##.##",(FNI.TO.F(FNP%(RTSLST%+6%))*288.)/1024.    &
\	PRINT #1%,  "   Quota tables:"; TAB(25%);			      &
\	PRINT #1%  USING "  ##.##",(FNI.TO.F(FNP%(RTSLST%+8%))*64.)/1024.;    &
\	PRINT #1%,  " (small buffers in use: ";NUM1$(FNP%(RTSLST%+10%)*2); ")" &
\	PRINT #1%,  "   Window turn blocks:"; TAB(25%);			      &
\	PRINT #1%  USING "  ##.##",(FIN.TO.F(FNP%(RTSLST%+16%))*288.)/1024.;  &
\	PRINT #1%,  " (maximum blocks used: "; NUM1$(FNP%(RTSLST%+18%)); ")"  &
\	PRINT #1%							      &
\	RETURN								      &

11850	DEF FNF.TO.I%(F) = F+65536.*(F>32767. AND F<65536.)		      &
		! PACK A FLOATING NUMBER IN THE RANGE 0-65535		      &
		! INTO AN UNSIGNED INTEGER FORMAT.			      &
		! AN ERROR WILL OCCUR IF THE FLOATING NUMBER IS OUT OF RANGE. &

11860	DEF FNI.TO.F(I%) = 32768.+(I% EQV 32767%)			      &
		! CONVERT A NUMBER FROM UNSIGNED INTEGER FORMAT		      &
		! TO A FLOATING NUMBER IN THE RANGE 0-65535.		      &
									      &

12000	!								      &
	GOTO 12190 IF FNP%(M%(35%))=0%		! No LAT, so exit now	      &
									      &
									      &
	!	L A T    I N F O R M A T I O N				      &
	!								      &
	!								      &
	! A VCB IS SET UP AS FOLLOWS:					      &
	!  CONTENTS	OFFSET	COMMENTS				      &
	! C.LNK		 0	Link to next VCB			      &
	! C.FLAG	 2	Flag word				      &
	! C.RCID	 4	Remote Circuit ID			      &
	! C.LCID	 6	Local Circuit ID			      &
	! C.DOFF	 8	L.EPDB offset for ethernet line		      &
	! C.TMR		10	Circuit timer cell			      &
	! C.CTIM	12	Remote system circuit timer value	      &
	! C.SESQ	14-17	List of session blocks for this circuit	      &
	! C.CXMT	18	Current transmit CCB pointer		      &
	! C.BEND	20	End virtual address we can use in I/O buffers &
	! C.XMTQ	22-25	Retransmit queue			      &
	! C.XMTT	26	Retransmit timer			      &
	! C.XMTC	27	Retry count				      &
	! C.OXMT	28	# transmits dispatched but not completed      &
	! C.OUTQ	30-33	Sessions on pending transmit queue	      &
	! C.SEQ		34	Message Number last received		      &
	! C.NXMT	35	Next message number to transmit		      &
	! C.LXMT	36	Lowest unacked message number		      &
	! C.HXMT	37	Highest unacked message number		      &
	! C.SADD	38-43	Ethernet address of server		      &
	! C.NXBF	44	# xmit buffs associated w/this server	      &
	! C.NAML	45	Length of server name			      &
	! C.NAM		46-61	The name itself				      &
	! C.BSIZ	62	Size of largest buffer for server	      &
	! C.VERS	64	Version number of server		      &
	! C.ECO		65	ECO level of server			      &
	!	Then come lots of various counters			      &
									      &
	! A Session block is set up as follows:				      &
									      &
	! S.LNK		 0	Link to next session block		      &
	! S.CIR		 2	Link to circuit block			      &
	! S.OUTL	 4	Link to next session on pending xmit queue    &
	! S.SOLB	 6	Solitation block pointer		      &
	! S.LSID	 8	Local Slot ID				      &
	! S.RSID	 9	Remove Slot ID				      &
	! S.LCRD	10	Number of credits server has granted to us    &
	! S.RCRD	11	Number of credits we have granted to server   &
	! S.SLSZ	12	Maximum slot size on tramsmit		      &
	! S.FLAG	13	Session flags				      &
	! S.SLEN	14	User's service name length		      &
	! S.SRVC	15-30	Service name				      &
	! S.PLEN	31	User's port name length			      &
	! S.PORT	32-47	Port name				      &
									      &
	\ G1%=M%(37%)			! $$LATS			      &
	\ HD%,E1%=0%							      &
	\ PRINT #1%,C$;C$;"LAT sessions: ";				      &
	\ FOR J5%=0% TO 1%						      &
	\ G%=FNP%(G1%+4%)		! start of LAT Circuit blocks	      &
	\ G%=FNP%(G1%+8%) IF J5%	! start of LAT Idle Circuit blocks    &
	\ E1%=M1% IF E%							      &
	\ WHILE G%<>0% AND E1%=0%					      &
	\    PRINT #1%, C$;"  Server Name      Max Buff  Protocol";	      &
			   "   KB#    Port Name        Service"  UNLESS HD%   &
	\    HD%=-1%							      &
	\    J%=SWAP%(FNP%(G%+44%)) AND 31%		! Length of name      &
	\    E1%=M1% IF E%						      &
	\    G$=""							      &
	\	FOR J1%=0% TO J%+1% STEP 2%				      &
	\	    J2%=FNP%(G%+46%+J1%)				      &
	\	    E1%=M1% IF E%					      &
	\	    G$=G$+CHR$(J2%)+CHR$(SWAP%(J2%))	! build server name   &
	\	NEXT J1%						      &
	\    G$=LEFT(G$,J%)		! Fix up the name		      &
	\    J1%=FNP%(G%+64%)	! Version #				      &
	\    E1%=M1% IF E%						      &
	\    PRINT #1%, " ";G$;TAB(20%);NUM1$(FNF(FNP%(G%+62%)));	      &
		TAB(30%);"V";NUM1$(J1% AND 255%);".";			      &
		NUM1$(SWAP%(J1%) AND 255%);				      &
	\    J3%=FNP%(G%+14%)	! session block pointer			      &
	\    E1%=M1% IF E%						      &
	\    WHILE J3%<>0% AND E1%=0%					      &
	\	J%=SWAP%(FNP%(J3%+30%)) AND 31%		! Get the length      &
	\	G$=""							      &
	\	FOR J1%=0% TO J%+1% STEP 2%				      &
	\	    J2%=FNP%(J3%+32%+J1%)				      &
	\	    E1%=M1% IF E%					      &
	\	    G$=G$+CHR$(J2%)+CHR$(SWAP%(J2%))	! build port name     &
	\	NEXT J1%						      &
        \       PRINT #1%, TAB(39%);"KB";NUM1$(FNP%(J3%+8%) AND 255%);":";    &
                    TAB(46%);LEFT(G$,J%);				      &
	\	J%=FNP%(J3%+14%)					      &
	\	E1%=M1% IF E%						      &
	\	G$=CHR$(SWAP%(J%))					      &
	\	J%=J% AND 31%			! Get just the length	      &
	\	FOR J1%=0% TO J% STEP 2%				      &
	\	    J2%=FNP%(J3%+16%+J1%)				      &
	\	    E1%=M1% IF E%					      &
	\	    G$=G$+CHR$(J2%)+CHR$(SWAP%(J2%))	! Build service name  &
	\	NEXT J1%						      &
	\	PRINT #1%, TAB(63%);LEFT(G$,J%)				      &
	\	J3%=FNP%(J3%)		! Get the next Session block	      &
	\	E1%=M1% IF E%						      &
	\    NEXT							      &
	\    G%=FNP%(G%)		! get the next VCB in the chain	      &
	\    E1%=M1% IF E%						      &
	\ NEXT								      &
	\ NEXT J5%							      &
	\ PRINT #1%, "None" UNLESS HD% OR E1%				      &
	\ PRINT #1% IF CCPOS(1%)	! Make sure we are at the left margin &

12190	RETURN								      &

12200	!								      &
									      &
									      &
	!	N O D E    B L O C K    ( N O B )			      &
	!								      &
	!								      &
	! A NOB IS SET UP AS FOLLOWS:					      &
	!  CONTENTS	OFFSET	COMMENTS				      &
	!    .BLKW	   0	RESERVED FOR FIP PROCESSING		      &
	!    .BLKW	   2	RESERVED FOR FIP PROCESSING		      &
	!    N.TMR	   4	NOB DELETION TIMER (IF IN IDLNOB)	      &
	! OR N.DLY		  OR DELAY VALUE FOR NODE		      &
	!    N.NAME1	   6	NODE NAME (6 ASCII CHARACTERS)		      &
	!    N.NAME2	   8	  (NAME)				      &
	!    N.NAME3	  10	  (NAME)				      &
	!    N.DDB	  12	DDB ADDR OF OUTPUT LINE (LOOPS ONLY)	      &
	! OR N.ADDR		  OR REMOTE NODE ADDRESS		      &
	!    N.NHOP	  14	Next hop (ethernet loop nodes only)	      &
	!		  16	Reserved				      &
	!		  18	Reserved				      &
	!    N.NCB	  20	POINTER TO NODE COUNTER BLOCK		      &
	!    N.FLGS	  22	(LOW)  NODE FLAG BITS			      &
	!    N.LCNT	  22	(HIGH) # OF LINKS TO THIS NODE		      &
	!    N.LLLB1	  24	POINTER TO ROOT OF LLB LIST FOR THIS NODE     &
	!    N.LLLB2	  26	POINTER TO TAIL OF LLB LIST FOR THIS NODE     &
	!    N.LINK	  28	LINK TO NEXT NODE BLOCK			      &
	!    RESERVED	  30	RESERVED				      &
	!								      &
	!	N.FLGS BITS:						      &
	!    NAME	VALUE	BIT	MEANING				      &
	!    NF.REA	  1	 0	REAL FLAG (IN NODE DATABASE ONLY)     &
	!					(NOT SET IN NOB)	      &
	!    NF.LUP	  2	 1	NODE BEING LOOKED UP		      &
	!    NF.LOP	  4	 2	LOOP NODE NOB			      &
	!    NF.PH4	  8	 3	PHASE 4 NODE (remote ONLY)	      &
	!    NF.END	 16	 4	END NODE     (exec ONLY)	      &
	!    NF.IBP	 32	 5	Honor proxy on received CI	      &
	!    NF.OBP	 64	 6	Request proxy on originated CI	      &
	!    NF.DEL	128	 7	NODE BLOCK TO BE DELETED WHEN	      &
	!					LAST LINK IS GONE	      &

12240	NODE$=FNNAM$(NOB%,6%)						      &
		! GET THE NODE NAME.					      &

12260	N.FLGS%=FNP%(NOB%+22%) AND 255%					      &
	\ NF.LOP%=N.FLGS% AND 4%					      &
	\ N.NHOP%=FNP%(NOB%+14%)					      &
	\ DDB%,N.ADDR%=FNP%(NOB%+12%)					      &
	\ DDB%=0% IF NF.LOP%=0%						      &
	\ N.ADDR%=0% IF NF.LOP%<>0%					      &
	\ DMC%=-1% \ DMC$=" None"					      &
		! EXTRACT THE DMC-11 DDB BASE/ROUTER NOB BASE FROM THE NOB.   &
		! EXTRACT FLAG INFO; SET DEFAULTS.			      &
		! IF IT'S ADJACENT THEN					      &
		!	LOCAL NODE DDB POINTER IS 0.			      &
		!	SAVE THE # AND SET UP THE DMC LINE # STRING	      &

12300	RETURN								      &

12400	!								      &
									      &
									      &
	!	R E C E I V E R    I D    B L O C K    ( R I B )	      &
	!		I N F O R M A T I O N				      &
	!								      &
	!								      &
	!								      &
	! A RIB IS SET UP AS FOLLOWS:					      &
	!   CONTENTS	OFFSET	DESCRIPTION				      &
	!    S.LINK	   0 	LINK TO NEXT BLOCK			      &
	!    S.RCID1	   2 	RECEIVER ID (6 BYTES OF ASCII)		      &
	!    S.RCID2	   4 	  (ID)					      &
	!    S.RCID3	   6 	  (ID)					      &
	!    S.JBNO	   8 	(LOW)  JOB NUMBER			      &
	!    S.OBJT	   8	(HIGH) OBJECT TYPE (NETWORKS)		      &
	!    S.ACCS	  10	(LOW)  ACCESS CONTROL			      &
	!    S.SRBN	  10	(HIGH) SUB RIB NUMBER			      &
	!    S.BMAX	  12 	BUFFER MAXIMUM (IN BYTES)		      &
	!    S.MMAX	  14	(LOW)  MESSAGE MAXIMUM			      &
	!    S.MCNT	  14	(HIGH) MESSAGE COUNT			      &
	!    S.MLST1	  16 	POINTER TO MESSAGE LIST ROOT		      &
	!    S.MLST2	  18	POINTER TO MESSAGE LIST TAIL		      &
	!    S.LMAX	  20	(LOW)  LINK MAXIMUM			      &
	!    S.LCNT	  20	(HIGH) LINK COUNT			      &
	!    S.LLST1	  22 	LINK LIST ROOT POINTER			      &
	!    S.LLST2	  24	LINK LIST TAIL POINTER			      &
	!    RESERVED	  26	RESERVED				      &
	!    RESERVED	  28	RESERVED				      &
	!    RESERVED	  30	RESERVED				      &

12420	RIB%=FNP%(LLB%+2%)						      &
		! EXTRACT THE BACK POINTER TO THE RIB FOR THE OWNER OF	      &
		! THIS LINK FROM THE LLB.				      &

12440	RCVRID$=FNNAM$(RIB%,2%)						      &
		! GET THE RECEIVER ID.					      &

12460	OB.JOB%=FNP%(RIB%+8%)						      &
	\ I%=OB.JOB% AND 255%						      &
	\ IF (I% AND 1%) THEN						      &
		JOB$=LEFT(RCVRID$,3%)					      &
	ELSE	JOB$=FNN$(2%,I%/2%)					      &
		! GET THE JOB #						      &
		! IF THE JOB # IS ODD THEN				      &
		!	WE HAVE SOMETHING 'SPECIAL' ('NSP');		      &
		!	WILL PRINT THE JOB # AS THE ID.			      &
		!	ELSE	SAVE THE 'REAL' JOB #			      &

12480	RETURN								      &
									      &

12600	!								      &
									      &
									      &
	!	L O G I C A L    L I N K    B L O C K    ( L L B )	      &
	!		    I N F O R M A T I O N			      &
	!								      &
	!								      &
	!								      &
	! AN LLB IS SET UP AS FOLLOWS:					      &
	!   CONTENTS	OFFSET	DESCRIPTION				      &
	!    LL.LNK	   0 	LINK TO NEXT LLB FOR THIS RECEIVER	      &
	!    LL.RIB	   2 	BACK POINTER TO RIB FOR THIS LINK	      &
	!    LL.LLX	   4	ADDR OF LOGICAL LINK BLOCK EXTENSION	      &
	!    LL.TMR	   6	LINK TIMER WORD				      &
	!    LL.PPN	   8	PPN for this link (if verification = on)      &
	!    LL.ACQ	  10	LINK to next LLB on action queue	      &
	!    LL.LFL	  12	(LOW)  LOCAL LINK FLAGS			      &
	!    LL.RFL	  12	(HIGH) REMOTE LINK FLAGS		      &
	!    LL.ULA	  14	(LOW)  USER LINK ADDRESS		      &
	!    LL.STA	  14	(HIGH) LINK STATE			      &
	!    LL.TRY	  16	(LOW)  TRANSMIT RETRY COUNT		      &
	!    LL.MOD	  16	(HIGH) FLOW CONTROL MODIFIERS		      &
	!    LL.LLA	  18	LOCAL LINK ADDR (NSP'S REF #)		      &
	!    LL.RLA	  20	REMOTE LINK ADDRESS			      &
	!    LL.RMX	  22	MAX SIZE DATA MESSAGE USER WILL ACCEPT	      &
	!    LL.TMX	  24	MAX SIZE DATA MESSAGE REMOTE WILL ACCEPT      &
	!    LL.XTM	  26	TIME WHEN MSG XMITTED (FOR DELAY EST.)	      &
	! OR LL.CMA	  26	  OR ADDR OF CI MSG IN CIR STATE	      &
	! OR LL.DIR	  26	  OR DISCONNECT REASON FOR DI AND DC MSGS     &
	!    LL.LLB	  28	THREAD THRU ALL LLB'S FOR THIS NODE	      &
	!    LL.NOB	  30	POINTER TO NOB FOR REMOTE NODE		      &
	!								      &
	!	LOCAL LINK FLAG BYTE (LL.LFL)				      &
	!   BIT NAME	VALUE	BIT	MEANING				      &
	!    LF.DBL	  1	 0	DATA SUBCHANNEL BLOCKED IF SET	      &
	!    LF.LBL	  2	 1	INT/LS SUBCHANNEL BLOCKED IF SET      &
	!    LF.PST	  4	 2	POSTING REQUIRED IF SET		      &
	!    LF.DAK	  8	 3	Data ACK is needed		      &
	!    LF.LAK	 16	 4	INT/LS ACK is needed		      &
	!    LF.SBP	 32	 5	SEND BACKPRESSURE ON/OFF IF SET	      &
	!    LF.EOM	 64	 6	LAST SEGMENT WAS EOM (OR NONE SENT)   &
	!    LF.BPS	128	 7	LCL BPRESS. SWITCH (1=FLOW OFF, 0=ON) &
	!								      &
	! 	REMOTE LINK FLAG BYTE (LL.RFL)				      &
	!   BIT NAME	VALUE	BIT	MEANING				      &
	!    RESERVED	  1	 0	RESERVED			      &
	!    RESERVED	  2	 1	RESERVED			      &
	!    RESERVED	  4	 2	RESERVED			      &
	!    RESERVED	  8	 3	RESERVED			      &
	!    RF.P4P	 16	 4	Remote node is Phase 4+ node	      &
	!    RF.PH4	 32	 5	Remote node is Phase 4 or higher      &
	!    RF.PH2	 64	 6	REMOTE NODE IS PHASE 2 NODE	      &
	!    RF.BPS	128	 7	REM. BPRESS. SW. (1=FLOW OFF, 0=ON)   &
	!								      &
	!	LINK STATE DEFINITIONS (LL.STA)				      &
	!   BIT NAME	VALUE	BIT	MEANING				      &
	!    RESERVED	  1	 0	RESERVED			      &
	!    ST$CID	  2	 1	CI DELIVERED - WAITING FOR CR OR DI   &
	!    ST$CIS	  4	 2	CI SENT - WAITING FOR ACK OR REPLY    &
	!    ST$CIR	  8	 3	CI RCVD - WAITING FOR USER ACTION     &
	!    ST$CCS	 16	 4	CONNECT CONFIRM SENT - WAIT FOR ACK   &
	!    ST$RUN	 32	 5	DTA XFER MODE - LINK IS ESTABLISHED   &
	!    ST$DIP	 64	 6	DISCONNECT INITIATE PENDING - DI WILL &
	!				  BE SENT BY NSP WHEN BUFFS FREE UP   &
	!    ST$DIS	128	 7	DISC. INIT. SENT - WAITING FOR ACK    &
	!								      &
	!	LINK MODIFIERS DEFINITIONS (LL.MOD)			      &
	!   BIT NAME	VALUE	BIT	MEANING				      &
	!   LM.FLO:			LOCAL FLOW CONTROL OPTION BITS	      &
	!    LM$NON	  1	 0	NO FLOW CONTROL			      &
	!    LM$SEG	  2	 1	SEGMENT FLOW CONTROL		      &
	!    LM$MSG	  4	 2	MESSAGE FLOW CONTROL		      &
	!    RESERVED	  8	 3	RESERVED			      &
	!								      &
	!   RM.TYP:			LINK TYPE BITS (FROM REC'D CI/CC)     &
	!    RESERVED	  1	 0	RESERVED			      &
	!    RM$NLL	  2	 1	NORMAL LOGICAL LINK		      &
	!    RESERVED	  4	 2	RESERVED			      &
	!    RESERVED	  8	 3	RESERVED			      &
	!								      &
	!   RM.FLO:			REMOTE FLOW CONTROL OPTION BITS	      &
	!    RM$NON	  4	 2	NO FLOW DONTROL			      &
	!    RM$SEG	  8	 3	SEGMENT FLOW CONTROL		      &
	!    RM$MSG	 16	 4	MESSAGE FLOW CONTROL		      &
	!    RESERVED	 32	 5	RESERVED			      &
	!								      &
	!	L O G I C A L    L I N K    B L O C K			      &
	!		E X T E N S I O N    ( L L X )			      &
	!								      &
	! AN LLX IS SET UP AS FOLLOWS:					      &
	!   CONTENTS	OFFSET	DEFINITION				      &
	!    LX.DTI	   0	DATA SUBCHANNEL ACK TIMEOUT (ALSO FOR IDLE)   &
	!    LX.DCH	   2	Out of order cache list head		      &
	!    LX.DRN	   4	RECEIVE SEGMENT NUMBER			      &
	!    LX.DTN	   6	TRANSMIT SEGMENT NUMBER			      &
	!    LX.LDR	   8	(LOW)  # OF SEGS REQUESTED BUT NOT RECEIVED   &
	!    LX.RDR	   8	(HIGH) # OF SEGS REQUESTED BUT NOT SENT	      &
	!    LX.DTM	  10	(LOW)  TRANSMIT QUEUE MAXIMUM		      &
	!    LX.DTC	  10	(HIGH) TRANSMIT QUEUE COUNT		      &
	!    LX.DTQ1	  12	TRANSMIT QUEUE				      &
	!    LX.DTQ2	  14	  TRANSMIT QUEUE			      &
	!    LX.LTI	  16	INT/LS SUBCHANNEL CONTROL INFO		      &
	!			  INT/LS SUBCHANNEL ACK TIMEOUT		      &
	!    LX.LCH	  18	Out of order cache list head		      &
	!    LX.LRN	  20	RECEIVE SEGMENT NUMBER			      &
	!    LX.LTN	  22	TRANSMIT SEGMENT NUMBER			      &
	!    LX.LIR	  24	(LOW)  # OF INT'S REQ'D, BUT NOT RECEIVED     &
	!    LX.RIR	  24	(HIGH) # OF INT'S REQ'D, BUT NOT SENT	      &
	!    LX.LTM	  26	(LOW)  TRANSMIT QUEUE MAXIMUM		      &
	!    LX.LTC	  26	(HIGH) TRANSMIT QUEUE COUNT		      &
	!    LX.LTQ1	  28	TRANSMIT QUEUE				      &
	!    LX.LTQ2	  30	  TRANSMIT QUEUE			      &
									      &

12620	STA.ULA%=FNP%(LLB%+14%) AND NOT (4096%)				      &
	\ LLA%=FNP%(LLB%+18%)						      &
	\ LLX%=FNP%(LLB%+4%)						      &
	\ MOD.TRY%=FNP%(LLB%+16%)					      &
	\ LL.MOD%=SWAP%(MOD.TRY%) AND 255%				      &
	\ RDR.LDR%=FNP%(LLX%+8%)					      &
	\ RIR$,LIR$="Blk"						      &
	\ RIR.LIR%=FNP%(LLX%+24%)					      &
	\ LIR%=RIR.LIR% AND 255%					      &
	\ LIR$=FNN$(2%,LIR%) UNLESS (LIR% AND 128%)			      &
	\ RIR%=SWAP%(RIR.LIR%) AND 255%					      &
	\ RIR$=FNN$(2%,RIR%) UNLESS (RIR% AND 128%)			      &
	\ STA$=""							      &
	\ STA$=MID("CIDCISCIRCCSRunDIPDIS",(I%-9%)*3%+1%,3%)		      &
		IF (STA.ULA% AND 2%^I%) FOR I%=9% TO 15%		      &
	\ IF GET.NUM% THEN						      &
		LINK%=0%						      &
	\	LINK%=LINK%+(LLA% AND 2%^I%)				      &
			FOR I%=LLT.FLG% TO 0% STEP -1%			      &
		! EXTRACT ALL NEEDED WORDS FROM THE LLB.		      &
		! SET UP THE 'STATE'.					      &
		! IF WE NEED TO DETERMINE THE LINK # (FOR /J:, /N:, OR	      &
		! /R:) THEN						      &
		!	EXTRACT THE LOGICAL LINK NUMBER FROM THE LOW N	      &
		!	BITS OF	THE LLA.				      &

12640	PRINT #1%,C$;C$;"Links: ";C$;					      &
		"Link  Node   ULA  LLA    RLA   State";			      &
		"  LDR LIR  RDR RIR LFC RFC Job"			      &
			IF HD%=0%					      &
	\ HD%=-1%							      &
	\ PRINT #1%,FNN$(3%,LINK%);TAB(5%);NODE$;			      &
		TAB(13%);FNN$(2%,STA.ULA% AND 255%);			      &
		TAB(17%);FNN$(3%,LLA%);					      &
		TAB(24%);FNN$(3%,FNP%(LLB%+20%));			      &
		TAB(32%);STA$;						      &
	\ PRINT #1%;TAB(37%);FNPN$(3%,RDR.LDR%*256%/256%);		      &
		TAB(42%);LIR$;						      &
		TAB(46%);FNPN$(3%,SWAP%(RDR.LDR%)*256%/256%);		      &
		TAB(51%);RIR$;						      &
		TAB(55%);FNFLOW$(LL.MOD%);				      &
		TAB(59%);FNFLOW$(LL.MOD%/4%);TAB(63%);JOB$		      &
		! PRINT THE HEADER THE FIRST TIME THROUGH.		      &
		! PRINT THE LINK INFO.					      &

12660	RETURN								      &
									      &

13000	!								      &
									      &
									      &
	!	N O D E S						      &
									      &
									      &

13020	FOR J3%=0% to 1%						      &
	\    HD%=0%							      &
	\    PRINT #1%,C$;"Idle Nodes: "; IF J3%			      &
	\    NOB%=FNP%(DEC%(13%)) IF J3%				      &
	\    PRINT #1%,C$;"Nodes: "; UNLESS J3%				      &
	\    NOB%=FNP%(DEC%(3%)) UNLESS J3%				      &
		! TO LIST ALL NODES POINT TO THE FIRST NODE BLOCK	      &
		! (IF NSP IS ENABLED, AT LEAST THE LOCAL NODE WILL BE	      &
		! IN THE LIST).						      &

13040	    WHILE NOB%							      &
	\	GOSUB 12240						      &
			! GO GET N.ADDR% AND DDB%			      &
	\	PRINT #1%;C$;						      &
			" Name      Addr       Links  Nxt Hop    Comments"    &
				UNLESS HD%				      &
	\	HD%=-1%							      &
	\	N.LCNT%=FNP%(NOB%+22%)					      &
	\	LM$=""							      &
	\	LM$=FNN$(2%,SWAP%(N.LCNT%) AND 255%)			      &
	\	COM$=""							      &
	\	COM$=COM$+						      &
			MID(", bit1, LUP , Loop, PH4 , End , IBP , OBP",      &
			I%*6%+1%,6%) IF (N.FLGS% AND 2%^I%) FOR I%=0% TO 6%   &
	\	COM$=RIGHT(COM$,3%)					      &

13060		NT.NUM$ =NUM1$(N.ADDR% AND 1023%)			      &
	\	PRINT #1%,NODE$;TAB(10%);FNN$(2%,N.ADDR%/1024%);	      &
			".";NT.NUM$;SPACE$(4%-LEN(NT.NUM$));		      &
			TAB(22%);LM$;TAB(29%);FNN$(2%,N.NHOP%/1024%);".";     &
			NUM1$(N.NHOP% AND 1023%);TAB(40%);COM$;		      &
	\	IF COM$="Loop" THEN					      &
			PRINT #1%, ": ";				      &
	\		Z$=CVT%$(SWAP%(FNP%(M2%(5%)+M2%(9%)+		      &
				(FNP%(DDB%) AND 255%)-2%)))		      &
	\		CR.VP%=1% IF Z$="XM"				      &
	\		CR.VP%=-1% IF Z$="XD"				      &
	\		PRINT #1%, FNDDCU$(DDB%);			      &

13070		PRINT #1%						      &

13080		GOTO 13100 IF E%					      &
	\	NOB%=FNP%(NOB%+28%)					      &
	\    NEXT							      &
		! FOR ALL NODE BLOCKS:					      &
		!	EXTRACT THE NODE NAME, LINE (OR ROUTER), AND FLAGS.   &
		!	EXTRACT REMAINING INFO (PER NOB LAYOUT, 12500).	      &
		!	NOTE THAT ONLY ACTIVE NODES LINK COUNT/MAX	      &
		!	IF NODE IS NON-ADJACENT THEN			      &
		!		SET UP STATE (OFF OR RUN)		      &
		!	IF ADJACENT THEN				      &
		!		SET UP "COMMENTS" AND STATE.		      &
		!	PRINT ALL INFO.					      &
		!	POINT TO THE NEXT NOB.				      &

13100	    PRINT #1%, "None" UNLESS HD% OR E%<>0%			      &
		! THERE WEREN'T ANY.					      &
	\ NEXT J3%							      &

13120	RETURN								      &

13500	!								      &
									      &
									      &
	!	L I N E S						      &
									      &
									      &
	! A NET DDB IS SET UP AS FOLLOWS:				      &
	!   CONTENTS	OFFSET	MEANING					      &
	!    DDIDX	   0	(LOW)  DRIVER INDEX			      &
	!    DDSTS	   0	(HIGH) STATUS AND ACCESS CONTROL	      &
	!    DDJBNO	   2	(LOW)  OWNING JOB NO.*2			      &
	!    DDUNT	   2	(HIGH) UNIT NUMBER			      &
	!    DDTIME	   4	TIME ASSIGNED OR INITED			      &
	!    DDCNT	   6	INIT COUNT AND ASSIGNMENT CONTROL	      &
	!    DDFLAG	   8	COMM DRIVER LINE FLAGS			      &
	!    L.FLAG	  10	TRANSPORT LINE FLAGS			      &
	!    L.TBUF	  12	(low) Count of outstanding xmit buffers	      &
	!    L.RQTA	  12	(high) Receive buffer quota		      &
	!    L.TIME	  14	Circuit TIMER				      &
	!    L.DDB	  16	Address to pass to driver as DDB	      &
	!    L.INFO	  18	POINTER TO INIT/VERIFY INFO BUFFER	      &
	!    L.ZDAT	  20	Date when counters were last zeroed	      &
	!    L.SCNT	  22	Start of counters			      &
	!    L.TREC	  22	COUNT OF TRANSIT PACKETS RECEIVED	      &
	!	      AND 24	  (2 WORDS)				      &
	!    L.TXMT	  26	COUNT OF TRANSIT PACKETS SENT		      &
	!	      AND 28	  (2 WORDS)				      &
	!    L.LREC	  30	COUNT OF PACKETS RECEIVED FOR LOCAL NSP	      &
	!	      AND 32	  (2 WORDS)				      &
	!    L.LXMT	  34	COUNT OF PACKETS TRANSMITTED FOR LOCAL NSP    &
	!	      AND 36	  (2 WORDS)				      &
	!    L.TCON	  38	COUNT OF TRANSMIT PACKETS LOST BY CONGESTION  &
	!    L.LCON	  40	COUNT OF LOCAL NSP PACKETS LOST BY CONGESTION &
	!    L.DOWN	  42	NUMBER OF TIMES LINE WENT DOWN		      &
	!    L.IERR	  44	COUNT OF INITIALIZATION FAILURES	      &
	!    L.COST	  46	(LOW)  LINE COST FOR THIS LINE		      &
	!    L.ANUM	  46	(HIGH) Adjacency number for this circuit      &
	!    L.HTMR	  48	HELLO TIMER INTERVAL			      &
	!    L.XBUF	  50	(LOW)  COUNT OF TRANSMIT BUFFERS OUTSTANDING  &
	!    L.NBUF	  50	(HIGH) COUNT OF LOCAL NSP TRANSMIT BUFFERS    &
	!    L.CINT	  52	Counter timer interval			      &
	!    L.CTMR	  54	Timer for couter logging		      &
	!    L.QMAX	  56	Originating queue limit			      &
	!    L.RTRM	  58	Recall timer				      &
	!    L.MRTR	  60	(low) Maximum broadcast routers allowed	      &
	!    L.TRTR	  60	(high) Total number of routers		      &
	!    L.DDEP:	  62:	(START OF DEVICE DEPENDENT PORTION)	      &
	!								      &
	!	DDFLAG VALUES FOR TRANSPORT:				      &
	!   BIT NAME	VALUE	BIT	MEANING				      &
	!    ????							      &
	!								      &
	! A DMC-11 DDB EXTENSION LOOKS LIKE:				      &
	!								      &
	!	CONTENTS	OFFSET					      &
	!	   X2TIPQ0		0				      &
	!	   X2TIPQ1		2				      &
	!	   X2RIPQ0		4				      &
	!	   X2RIPQ1		6				      &
	!	   X2TQUE0		8				      &
	!	   X2TQUE1		10				      &
	!	   X2RQUE0		12				      &
	!	   X2RQUE1		14				      &
	!	   X2RCPQ0		16				      &
	!	   X2RCPQ1		18				      &
	!	   X2CPLQ0		20				      &
	!	   X2CPLQ1		22				      &
	!	X2NXMT - X2TCNT		24				      &
	!	UNUSED - X2NRCP		26				      &
	!	X2NRCV - X2RCNT		28				      &
	!	   X2MSIZ		30				      &
									      &

13510	HD%=0%								      &
	\ PRINT #1%,C$;"Circuits: ";					      &
	\ DEV.NAM%=M2%(5%)						      &
	\ DEV.OKB%=M2%(9%)						      &
	\ XCON% = FNP%(M2%(37%))					      &
	\ DDB.PTR%=XE.DDB.PTR%						      &
	\ DDB.PTR%=XH.DDB.PTR% IF XCON% AND 32%				      &
	\ MAX%=4%							      &

13520	FOR DEV%=1% TO 2%	! do this once for DMC and once for ethernet  &
	\   MAX%=NUM.DECNT.UNITS% IF DEV%=2%				      &
	\   GOTO 13580 IF DEV%=2% AND MAX%<0%				      &
	\   DDB.PTR%=XM0.DDB.PTR% IF DEV%=2%				      &
	\   FOR UNIT%=0% TO MAX%					      &
	\	DDB%=FNP%(DDB.PTR%+(2%*UNIT%))				      &
	\	GOTO 13560 IF DDB%=M2%(67%)	! Skip fake devices	      &
	\	G%=DDB%			! Get a copy of the DDB pointer	      &
	\	G%=FNP%(DDB%+16%) IF DEV%=1%	! Get e-net DDB pointer	      &
	\	GOTO 13560 UNLESS G% IF DEV%=1%	! Exit if it ain't there      &
	\	GOTO 13560 IF (FNP%(G%+14%) AND 1024%)=0% IF DEV%=1%	      &
			! Test the DECnet bit in the PDB for e-net devices    &
	\	DMC$=CVT%$(SWAP%(FNP%(DEV.NAM%+DEV.OKB%-2%+(FNP%(DDB%) AND    &
			255%))))+NUM1$(SWAP%(FNP%(DDB%+2%)) AND 255%)	      &
	\	CR.VP%=0%						      &
	\	CR.VP%=1% IF LEFT(DMC$,2%)="XM"				      &
	\	CR.VP%=-1% IF LEFT(DMC$,2%)="XD"			      &
	\	DMC$=FNDDCU$(DDB%) IF CR.VP%<>0%			      &
			UNLESS DDCTBL%=0% OR UCTTBL%=0%			      &
	\	DMC$="UNA-"+NUM1$(UNIT%) IF LEFT(DMC$,2%)="XE"		      &
	\	DMC$="QNA-"+NUM1$(UNIT%) IF LEFT(DMC$,2%)="XH"		      &
	\	DDJBNO%=FNP%(G%+2%) AND 255%				      &
			! G% = DDB% for XM/XD devices and the PDB pointer     &
			! from the DDB of the XE/XH devices		      &
	\	JOB$="J*2="+NUM1$(DDJBNO%) IF (DDJBNO% AND 1%)<>0%	      &
	\	JOB$="INIT Disabled" IF DDJBNO%=1%			      &
	\	JOB$="CFG Disabled" IF DDJBNO%=3%			      &
	\	JOB$="TRN" IF DDJBNO%=5%				      &
	\	JOB$=FNN$(2%,DDJBNO%/2%) UNLESS (DDJBNO% AND 1%)<>0%	      &
	\	TEMP$="Off"						      &
	\	L.FLAG%=FNP%(DDB%+10%)					      &
	\	TEMP$="On " IF (L.FLAG% AND (24%))=8%			      &
	\	TEMP$="Res" IF (L.FLAG% AND (24%))=16%	! Restarting	      &
	\	TEMP$="Srv" IF (L.FLAG% AND (24%))=24%	! Service	      &
	\	TEMP$=TEMP$+" - starting"				      &
			IF (L.FLAG% AND 6%)<>0% IF TEMP$<>"Off"		      &
	\	TEMP$=TEMP$+" - running"				      &
			IF (L.FLAG% AND 6%)=0% IF TEMP$<>"Off"		      &
	\	NODE$=" - "						      &
			! Anyway to get the name/address?		      &
	\	FLAGS%=L.FLAG% AND -32%					      &
	\	FLAGS$=""						      &
	\	FLAGS$=FLAGS$+MID(					      &
		   ", RVM, VER, BRO, FIP, RST, ANS, CON, RTM, TRA, LSM, SRM", &
			(I%-5%)*5%+1%,5%) IF (FLAGS% AND (2%^I%))<>0%	      &
			FOR I%=5% TO 15%				      &
	\	FLAGS$=RIGHT(FLAGS$,3%) IF LEN(FLAGS$)			      &
	\	IF CR.VP%<>-1% THEN	! Not DMV/DMP devices		      &
		    SIZ$=NL$						      &
		ELSE			! DMV/DMP devices		      &
		    IF VAL(RIGHT(DMC$,LEN(DMC$)))=0% THEN	! DM?-*.0     &
			I%=FNP%(DDB%+76%)	! Get the CDB pointer	      &
	\		I%=FNP%(I%+8%)		! Get the receive buffer size &
	\		SIZ$=NUM1$(I%)		! Into a string		      &

13540		PRINT #1%,C$;						      &
			"Circuit  Addr   Size  State"+			      &
			"            Job   Flags"	IF HD%=0%	      &
	\	HD%=-1%							      &
	\	PRINT #1%, DMC$; TAB(10%); NODE$; TAB(16%); SIZ$; TAB(23%);   &
			TEMP$;TAB(39%); JOB$; TAB(45%); FLAGS$;C$;	      &

13560		GOTO 13580 IF E%					      &
	\   NEXT UNIT%							      &

13580	NEXT DEV%	! Go onto the next (ethernet)			      &
	\ PRINT #1%, "None" IF HD%=0% AND E%=0%				      &
	\ PRINT #1%							      &
	\ RETURN							      &
		! WE MUST EXTRACT LINE INFO BY SCANNING ALL DMC-11 DDBS.      &

13700	!								      &
									      &
									      &
	!	M E M O R Y    A L L O C A T I O N			      &
									      &
									      &
									      &

13710	MEMLST%=M%(31%)							      &
	\ JOBTBL%=M%(11%)						      &
	\ PRINT #1%							      &
	\ PRINT #1%, 'Memory layout : '					      &
	\ PRINT #1%, 'Start    End  Length  Content'			      &
	\ GOSUB 13800							      &
		!							      &
		! LOOKUP MONITOR TABLES PART I				      &
		! GET THE ROOT OF MEMLST				      &
		! GET THE LOCATION OF JOBTBL				      &
		! PRINT THE HEADER					      &
		! GET VIRTUAL DISK INFO					      &

13720	IF (MEMLST% AND 8%+16%) THEN					      &
		NPTR%=MEMLST%-6%					      &
	\	NPTR%=FNP%(MEMLST%-8%)+12% IF (MEMLST% AND 16%)		      &
	\	NAM$=RAD$(FNP%(NPTR%))+RAD$(FNP%(NPTR%+2%))		      &
	\	NPTR%=0%						      &
	\	IF (MEMLST% AND 16%) THEN				      &
			GOSUB 13760					      &
		ELSE							      &
			IF (FNP%(MEMLST%+20%) AND 128%) THEN		      &
				ID$='LIB'				      &
			ELSE						      &
			 	ID$='RTS'				      &
		!							      &
		! IF WE HAVE A RTS, LIB, OR JOB THEN			      &
		! 	GET THE NAME OF THE RTS, LIB, OR JOB BY		      &
		!	PEEKING AT THE APPROPRIATE ADDRESS.		      &
		!	IF WE HAVE A JOB THEN				      &
		!		GO FIND THE JOB NUMBER.			      &
		!	ELSE	IF BIT 8 AT MLST+20% IS SET THEN	      &
		!			WE HAVE A LIB			      &
		! 		ELSE 	WE HAVE A RTS			      &
		!							      &
		! THE LOW ORDER BITS OF MLST%, (THE ADDRESS OF THE	      &
		! MEMORY CONTROL SUB-BLOCK), DETERMINE THE TYPE OF ENTRY      &
		! SINCE THE MCTRL SUB-BLOCK HAS DIFFERENT OFFSETS IN	      &
		! THE DATA STRUCTURE DESCRIBING THE ENTITY, DEPENDING	      &
		! ON THE ENTITY.					      &
		!							      &
		! THE OFFSETS ARE DEFINED AS FOLLOWS :			      &
		!	0	MONITOR					      &
		!	2	EXTENDED BUFFER POOL (XBUF)		      &
		!	4	LOCKED OUT MEMORY (LCK)			      &
		!	6	NON-EXISTANT MEMORY (NXM)		      &
		!	8	RUN-TIME SYSTEM (RTS) OR		      &
		!			RESIDENT LIBRARY (LIB)		      &
		!	16	USER JOB				      &

13730	NAM$=MID('MONITOR   ** XBUF **LOCKED OUT   NXM    ',		      &
		(MEMLST% AND 6%)*5%+1%,10%) UNLESS (MEMLST% AND 8%+16%)	      &
	\ NAM$=NAM$+' '+ID$ IF (MEMLST% AND 8%+16%)			      &
	\ MPHYA%=(FNP%(MEMLST%+8%)/32%) AND 2047%			      &
	\ VDISK%=(							      &
		    (VSTAT%>0%)						      &
		    AND							      &
		    (							      &
		       (MPHYA%>=VSTAR%)					      &
		       AND						      &
		       (MPHYA%<VSTAR%+VSIZE%)				      &
		    )							      &
		 )							      &
	\ NAM$="Virtual Disk" IF VDISK%					      &
	\ PNXT%=FNP%(MEMLST%+2%)					      &
	\ IF PNXT%=0% THEN						      &
		PRINT #1%, FNN$(4%,MPHYA%); 'K -  *** END *** ';C$;C$	      &
	ELSE								      &
	 	TSIZE%=FNP%(MEMLST%+4%)					      &
	\	MSIZE%=(FNP%(MEMLST%+6%) AND 255%)			      &
	\	PRINT #1%, FNN$(4%,MPHYA%);'K - '; FNN$(4%,MPHYA%+MSIZE%-1%); &
			'K (';  FNN$(4%,MSIZE%); 'K) '; NAM$		      &
	\	PRINT #1%, FNN$(4%,MPHYA%+MSIZE%); 'K - ';		      &
			FNN$(4%,MPHYA%+TSIZE%-1%); 'K (';		      &
			FNN$(4%,TSIZE%-MSIZE%); 'K)   (FREE)  '		      &
			IF (TSIZE%-MSIZE%)				      &
	\	MEMLST%=PNXT%						      &
	\	GOTO 13720						      &
		!							      &
		! IF IT ISN'T A RTS, LIB, OR JOB, THEN FIGURE OUT WHAT IT IS  &
		! BY LOOKING AT THE LAST 3 BITS OF THE ADDRESS		      &
		! IF IT IS A RTS, LIB, OR JOB THEN APPEND 'RTS','LIB',	      &
		!	OR 'JNN' WHERE NN IS THE JOB NUMBER.		      &
		! LOOK AT THE MCTRL SUB-BLOCK TO FIND			      &
		! 	THE STARTING ADDRESS OF THIS ITEM AND		      &
		!	THE ADDRESS OF THE NEXT MCTRL SUB-BLOCK.	      &
		! IF END OF MEMLST THEN PRINT END			      &
		! ELSE GET TOTAL SIZE OF THIS ITEM, INCLUDE UNUSED MEMORY AND &
		!	SIZE OF IN-USE MEMORY FOR THIS ITEM.		      &
		! THE MEMLST ENTRY HAS THE FOLLOWING FORMAT :		      &
		!	BYTES	CONTENTS				      &
		!	 0-1	POINTER TO PREVIOUS MEMLST ENTRY.	      &
		!	 2-3	POINTER TO NEXT MEMLST ENTRY.		      &
		!	 4-5	TOTAL SIZE OF ITEM IN KW (INCL UNUSED MEMORY) &
		!	  6	AMOUNT OF IN-USE MEMORY			      &
		!	  7	CONTROL INFORMATION FOR THIS ITEM.	      &
		!	 8-9	PHYSICAL ADDRESS OF START OF THIS ITEM	      &
		!			DIVIDED BY 100(8) IN BYTES.	      &
		! PRINT OUT THE STARTING ADDRESS - ENDING ADDRESS, SIZE, AND  &
		!	NAME OF ITEM.					      &
		! IF THERE IS UNUSED SPACE LEFT OVER, PRINT A SEPARATE LINE   &
		!	INDICATING 'FREE' AS CONTENTS.			      &

13740									      &

13750	RETURN								      &
		! RETURN FROM LISTING MEMORY ALLOCATION TABLE.		      &

13760	NPTR%=NPTR%+2%							      &
	\ PNXT%=FNP%(JOBTBL%+NPTR%)					      &
	\ GOTO 13760 IF PNXT%<>MEMLST%-16% AND PNXT%<>-1%		      &
	\ NPTR%=0% IF PNXT%=-1%						      &
	\ ID$='J'+RIGHT(NUM1$(100%+NPTR%/2%),2%)			      &
	\ IF NPTR%>0% THEN JOB.BASE=JCR.ST+(NPTR%*JCRSIZ)		      &
	\ 	NAM$ = RAD$(FNPEEK%(JCTRL.SEG%,JOB.BASE+16))		      &
			+RAD$(FNPEEK%(JCTRL.SEG%,JOB.BASE+18))		      &

13770	RETURN								      &
		!							      &
		! GIVEN NPTR%=0%					      &
		! INCREMENT NPTR (JBTBL POINTER)			      &
		! GET ADDRESS OF JOB FROM JBTBL				      &
		! IF THIS ADDRESS NOT =THE JOB MLST IS POINTING TO AND	      &
		!	NOT = -1% (END OF JBTBL) THEN REPEAT		      &
		! IF JBTBL ENTRY = -1% THEN WE DIDN'T FIND THE JOB, SO	      &
		!	RETURN 'J00'					      &
		! SET ID$ TO THE JOB NUMBER AS (THE OFFSET IN JBTBL)/2%	      &

13800	DV%=ASCII("D")+ASCII("V")*256%					      &
	\ INDEX%=0%							      &
		! INDEX INTO MONITOR TABLES SET TO ZERO			      &

13810	DEV%=FNP%(M2%(5%)+INDEX%)					      &
	\ IF DEV%=-1% THEN GOTO 13840					      &
		! END OF THE LIST?					      &

13820	IF DEV%<>DV% THEN INDEX%=INDEX%+2%				      &
	\ GOTO 13810							      &

13830	VSTAT%=FNP%(M%(19%)+INDEX%)					      &
	\ IF VSTAT%>=0% THEN FREE%=FNP%(M%(21%)+INDEX%)			      &
	\  VSTAR%=FNP%(M2%(7%)+INDEX%)					      &
	\  VSTAR% = VSTAR%+2048% IF VSTAR% < 0%				      &
	\  VSIZE%=(FNP%(M%(17%)+INDEX%) AND 255%)*			      &
		  (FNP%(M2%(55%)+INDEX%)+1%)+1%				      &
	\  VSIZE%=INT((VSIZE%/4.0)+.9999)				      &
		! IF IT'S MOUNTED GET FREE SPACE, START ADDRESS, TOTAL SIZE   &

13840	RETURN								      &
									      &

14000	!								      &
									      &
									      &
	!	T I M E -    H H : M M : S S . S			      &
									      &
									      &
	!	c1%=1% for HH:MM:SS					      &
	!	c1%=0% for DDD HH:MM:SS					      &
									      &
									      &

14010	S$=""								      &
	\ T%=0%								      &
	\ GOTO 14060 IF T<0. OR T>359999. if c1%=1%			      &
	\ goto 14060 if t<0. or t>63158399. if c1%=0%			      &
	\ goto 14015 if c1%=1%						      &
	! CLEAR STRING TO BE RETURNED AND INITIALIZE			      &
	! MAKE SURE TIME IS WITHIN ALLOWABLE RANGE (< 100 HRS).		      &
	! or < 730D 23H:59M:59S  (This is two full years)		      &

14012	t1%=t/86400.							      &
	\ if t1%<>0% then						      &
		t=t-86400.*t1%						      &
	\	gosub 14040						      &
	\	s$=s$+" "						      &
	! t1%= # of days - subtract from total if non-zero		      &

14015	T1%=T/3600.							      &
	\ IF (T1% or t%)<>0% THEN					      &
		T=T-3600.*T1%						      &
	\	GOSUB 14040						      &
	\	S$=S$+":"						      &
	! T1%= # OF HOURS - SUBTRACT FROM TOTAL IF NON-ZERO		      &

14020	T1%=T/60%							      &
	\ IF (T1% OR T%)<>0% THEN					      &
		T=T-60%*T1%						      &
	\	GOSUB 14040						      &
	\	S$=S$+":"						      &
	! NOW T1%= # OF MINUTES - SUBTRACT FROM TOTAL IF NON-ZERO AND	      &
	! TACK ON TO STRING						      &

14030	T1%=T								      &
	! PREPARE TO GET SECONDS.TENTHS OF SEC.				      &

14040	T$=NUM$(T1%+T%*100%)						      &
	\ S$=S$+MID(T$,2%+T%,LEN(T$)-2%-T%)				      &
	\ T%=1%								      &
	! TACK THIS PART ONTO THE STRING				      &

14050	RETURN								      &
									      &

14060	S$="???:??:??"							      &
	\ s$=s$+":??" if c1%=0%						      &
	\ GOTO 14050							      &
	! COULDN'T CONVERT THE NUMBER.					      &

15000	!								      &
									      &
									      &
	!	F U N C T I O N S					      &
									      &
									      &

15200	DEF* FNSR5%(Q%)=						      &
	(Q% AND 32767%)/32% OR (1024% AND (Q%<0%))			      &
									      &
	! Q% GETS SHIFTED RIGHT 5 BITS, TAKING INTO ACCOUNT THAT	      &
	! Q% MAY BE NEGATIVE.						      &

15300	DEF* FNN$(S%,N%)						      &
	\ FNN$=""							      &
	! FUNCTION	FNN$	TURN N% INTO A STRING AND LEFT PAD	      &
	!			THE STRING WITH SPACES			      &

15310	S$=NUM1$((N% EQV 32767%)+32768.)				      &
	\ FNN$=FNS$(S%)							      &
		! GET THE STRING (MAKE SURE IT'S POSITIVE) AND LEFT PAD	      &
		!  IT WITH SPACES.					      &

15320	FNEND								      &

15400	DEF* FNO$(Q%)							      &
	\ FNO$=""							      &
	! FUNCTION	FNO$	GET A 6 POSITION OCTAL STRING		      &

15410	Q$="0"								      &
	\ Q0%=4096%							      &
	\ IF Q%<0% THEN							      &
		Q$="1"							      &
	\	Q%=Q%+32767%+1%						      &
	! SET UP TO CONVERT THE NUMBER					      &
	! TAKE CARE OF NEGATIVE NUMBERS					      &

15420	WHILE Q0%>0%							      &
	\	Q1%=Q%/Q0%						      &
	\	Q%=Q%-Q0%*Q1%						      &
	\	Q0%=Q0%/8%						      &
	\	Q$=Q$+CHR$(48%+Q1%)					      &
	\ NEXT								      &
	! CONVERT THE NUMBER TO OCTAL, SAVING EACH DIGIT		      &

15430	FNO$=Q$								      &
	! SET THE FUNCTION						      &

15440	FNEND								      &
									      &

15445	DEF* FNLO$(Q)							      &
	\ FNLO$=""							      &
	! FUNCTION	FNLO$	GET A 6 POSITION OCTAL STRING		      &

15447	Q$=""								      &
	\ Q0=2097152.							      &
	\ WHILE INT(Q0)>0.						      &
	\	Q1%=Q/Q0						      &
	\	Q=Q-Q0*Q1%						      &
	\	Q0=Q0/8%						      &
	\	Q$=Q$+CHR$(48%+Q1%)					      &
	\ NEXT								      &
	! SET UP TO CONVERT THE NUMBER					      &
	! CONVERT THE NUMBER TO OCTAL, SAVING EACH DIGIT		      &

15456	FNLO$=Q$							      &
	! SET THE FUNCTION						      &

15470	FNEND								      &
									      &
									      &

15500	DEF* FNP%(Q%)							      &
	! FUNCTION	FNP%	THIS FUNCTION IS EQUIVALENT		      &
	!			TO A PEEK OF AN ADDRESS			      &
	!								      &

15510	FNP%,E%=0%							      &
	\ IF (Q% AND 1%)<>0% THEN					      &
		E%=-1%							      &
	\	PRINT #1%, C$;"Odd PEEK Address - ";NUM1$(FNF(Q%))	      &
	\	GOTO 15560						      &

15520	R=FNF(Q% AND -2%)						      &
	\ IF R >= 0. AND R <= EPMM THEN					      &
		SEGMNT%=ROOT.SEG%					      &
	\	FNP%=FNPEEK%(SEGMNT%,R)					      &
	\	GOTO 15560						      &
		! IF THE ADDRESS IS BETWEEN 0 AND $$EPMM THEN		      &
		! PEEK AT THE ROOT SEGMENT.				      &
		!							      &

15530	GOTO 15540 IF R > EPMM						      &
		  AND R < FPL.ST					      &
	\ IF FPLAP6% <> 0% THEN						      &
		IF R <= FPL.END THEN					      &
			SEGMNT%=FPL.SEG%				      &
	\		OFFSET=R-FPL.ST					      &
	\		R=((MAP%(FPL.SEG%,0%)-1%)*512.)+OFFSET		      &
	\		FNP%=FNPEEK%(SEGMNT%,R)				      &
	\		GOTO 15560					      &
		! ERROR IF THE ADDRESS IS BETWEEN PERMANENTLY MAPPED	      &
		! MEMORY AND AND THE START ADDRESS OF FIP POOL.		      &
		! PEEK INTO THE FIP POOL IF WE HAVE A FIP POOL AND	      &
		! THE ADDRESS IS NOT BEYOND THE UPPER LIMIT.		      &

15540	E%=-1%								      &
	\ PRINT #1%, C$;"Address out of range - ";NUM1$(FNF(Q%))	      &

15560	FNEND								      &
									      &

15600	DEF* FNPEEK%(SEG%,AD)						      &
		! FUNCTION TO TRANSLATE A MEMORY ADDRESS TO		      &
		! BLOCK AND OFFSET IN A FILE OF INTEGERS.		      &

15610	FNPEEK%,E%=0%							      &
	\ E%=-1% IF SEG%<>0% AND MAP%(SEG%,0%)=0%			      &
	\ GOTO 15630 IF E%						      &
	\ START.ADDRS=(MAP%(SEG%,0%)-1%)*512.				      &
	\ END.ADDRS=MAP%(SEG%,1%)*512.+MAP%(SEG%,2%)			      &
	\ IF (AD<START.ADDRS) OR (AD>END.ADDRS) THEN			      &
		PRINT #1%, C$;"%Peek address (";			      &
			  NUM1$(AD);") out of range, (";		      &
			  NUM1$(START.ADDRS);" - ";			      &
			  NUM1$(END.ADDRS);")"				      &
	\ E%=-1%							      &
	\ GOTO 15630							      &
		! INVALID ADDRESS					      &

15620	BASE.BLOCK%=MAP%(SEG%,0%)					      &
	\ AD=AD-START.ADDRS						      &
	\ ADD.BLOCK%=(AD/512%)						      &
	\ ADD.OFFSET%=AD-((ADD.BLOCK%)*512.)+1%				      &
	\ GET #12%, BLOCK (BASE.BLOCK%+ADD.BLOCK%)			      &
	\ FNPEEK%=SWAP%(CVT$%(MID(D$,ADD.OFFSET%,2%)))			      &

15630	FNEND								      &

15690	DEF* FNF(QQ%)=(QQ% AND 32767%) - (32768. * (QQ% < 0%))		      &
		! FUNCTION TO CONVERT INTEGER TO FLOATING POINT.	      &

15700	DEF* FNE$(E8%)=							      &
	CVT$$(RIGHT(SYS(CHR$(6%)+CHR$(9%)+CHR$(E8%)),3%),4%)		      &

15800	DEF* FNS$(S%)=SPACE$(S%-LEN(S$))+S$				      &
	! LEFT PAD A STRING WITH SPACES.				      &

15900	DEF* FNDISKSIZE(FUN%,UNTCLU%,SATEND%)				      &
	\ DSIZE=FNP%(SATEND%+FUN%)					      &
	\ DSIZE=DSIZE+65536. IF DSIZE<0.				      &
	\ FNDISKSIZE=(DSIZE+2.)*(FNP%(UNTCLU%+FUN%) AND 255%)		      &
	\ FNEND								      &
		! FIND MAXIMUM SIZE IN BLOCKS FOR A DISK BY FUN		      &
		!	FUN = FIP UNIT NUMBER * 2			      &

16000	DEF* FNDDCU$(DDB.PTR%)						      &
	! THIS FUNCTION RETURNS A DEVICE DESIGNATOR STRING IN		      &
	! DDCU FORMAT, FOR DMC, DMR, DMP, DMV DEVICES.			      &
	! IT REQUIRES THE GLOBAL VARIABLE CR.VP% TO BE VALID		      &
	!	CR.VP = 1  FOR DMC/DMR					      &
	!	CR.VP = -1 FOR DMV/DMP					      &
	! IT LOOKS AT THE DDFLAG WORD IN THE DDB OF THE DEVICE, TO	      &
	! DETERMINE WHETHER THE DEVICE IS DMC OR DMR, OR IN THE		      &
	! OTHER CASE WHETHER IT IS DMV OR DMP.				      &
	! FORMAT FOR THE DEVICES IS AS FOLLOWS:				      &
	!	DMC	DMC-0, DMC-1, DMC-2...				      &
	!	DMR	DMR-0, DMR-1, DMR-2...				      &
	!	DMV	DMV-0.0, DMV-0.1,... DMV-1.0, DMV-1.1...	      &
	!	DMP	DMP-0.0, DMP-0.1,... DMP-1.0, DMP-1.1...	      &

16010	FNDDCU$="???"							      &
	\ GOTO 16040 IF CR.VP%=0%					      &
	\ DDFLAG%=(FNP%(DDB.PTR%+8%) AND 128%)				      &
	\ IF (CR.VP%=1%) THEN						      &
		FNDDCU$="DM"+"C-"+NUM1$(SWAP%(FNP%(DDB.PTR%+2%)) AND 255%)    &
							UNLESS DDFLAG%	      &
	\	FNDDCU$="DM"+"R-"+NUM1$(SWAP%(FNP%(DDB.PTR%+2%)) AND 255%)    &
							IF DDFLAG%	      &
	\	GOTO 16040						      &

16020	IF (CR.VP%=-1%) THEN						      &
		TOT.UTS%=0%						      &
	\	DDC.OFS%=DDCTBL%+(FNP%(DDB.PTR%) AND 255%)		      &
	\	OFS.CTS%=FNP%(DDC.OFS%)					      &
	\	UCT.OFS%=UCTTBL%+(SWAP%(OFS.CTS%) AND 255%)		      &
	\	NUM.CTS%=OFS.CTS% AND 255%				      &
	\	UNIT.NUMBER%=SWAP%(FNP%(DDB.PTR%+2%)) AND 255%		      &
	\	FOR CTS%=0% TO NUM.CTS%-1%				      &
	\		U.P.C%=FNP%(UCT.OFS%+(2%*CTS%))			      &
	\		FOR UTS%=0% TO U.P.C%-1%			      &
	\			GOTO 16030 IF TOT.UTS%=UNIT.NUMBER%	      &
	\			TOT.UTS%=TOT.UTS%+1%			      &
	\		NEXT UTS%					      &
	\	NEXT CTS%						      &
	\	GOTO 16040						      &
	! TO TRANSLATE "XD?" INTO DM?-?.? FORMAT, WE NEED TWO TABLES.	      &
	! THE DDCTBL IS A TABLE ORGANIZED AS FOLLOWS:			      &
	!								      &
	!			DDCTBL					      &
	!			+-----------------+-----------------+	      &
	! OFFSET BY DDIDX ---->	|  UCTTBL OFFSET  | CONTROLLERS/DEV |	      &
	!			+-----------------+-----------------+	      &
	!                       |                 |                 |	      &
	!			+-----------------+-----------------+	      &
	!			|                ETC                |	      &
	!								      &
	!			UCTTBL					      &
	!			+-----------------+-----------------+	      &
	! OFFSET FROM DDCTBL -> | NUMBER OF UNITS ON CONTROLLER #0  |	      &
	!			+-----------------+-----------------+	      &
	!			| NUMBER OF UNITS ON CONTROLLER #1  |	      &
	!			+-----------------+-----------------+	      &
	!			|                ETC                |	      &
	!								      &
	! TO MAKE THE TRANSLATION, YOU HAVE TO COUNT THE NUMBER OF	      &
	! UNITS ON EACH CONTROLLER, AND ADD 'EM UP UNTIL YOU GET TO THE	      &
	! UNIT NUMBER IN THE DDB%.  FOR EXAMPLE, IF THERE ARE 4 CONTROLLERS,  &
	! AND EACH CONTROLLER HAS 4 UNITS, THEN "XD6" WOULD BE DM?-1.2	      &

16030		FNDDCU$="DM"+"P-"+NUM1$(CTS%)+"."+NUM1$(UTS%)		      &
						UNLESS DDFLAG%		      &
	\	FNDDCU$="DM"+"V-"+NUM1$(CTS%)+"."+NUM1$(UTS%)		      &
						IF DDFLAG%		      &
	\	GOTO 16040						      &

16040	FNEND								      &
									      &

16100  DEF* FNACCOUNT$(LOGNAM%,FUN%,PPN%)				      &
       \ LOGNAM%=LOGNAM%+((FUN% AND 255%)*10%)				      &
       \ Q$=								      &
	 CVT%$(SWAP%(FNP%(LOGNAM%+6%)))+NUM1$(FNP%(LOGNAM%+8%) AND 255%)+":"  &
       \ IF PPN%<>0% THEN						      &
	       P.PROG$=NUM1$(PPN% AND 255%)				      &
       \       Q$=Q$+"["+FNN$(3%,SWAP%(PPN%) AND 255%)+","+		      &
		  P.PROG$+SPACE$(3%-LEN(P.PROG$))+"]"
16110  FNACCOUNT$=Q$							      &
       \ FNEND								      &
		! FORMAT THE DEV:[P,PN] DISPLAY FOR RTS/LIB		      &
		!        LOGNAM% = ADDRESS OF LOGNAM TABLE		      &
		!	 FUN%    = FIP UNIT NUMBER*2			      &
		! 	 PPN%    = <>0% FOR LIB, =0 FOR RTS		      &
									      &

18000	DEF* FNFLOW$(FLW%)=						      &
		MID("No SegMsg ? ",(FLW% AND 3%)*3%+1%,3%)		      &
	! FUNCTION:	FNFLOW$		SET UP LOCAL OR REMOTE FLOW	      &
	!				CONTROL MNEMONIC		      &
	! PARAMETERS:	FLW.CTL		LOCAL OR REMOTE FLOW CONTROL	      &
	!				FLAG WORD:			      &
	!				BITS	MEANING			      &
	!				0-1	LINK TYPE BITS		      &
	!				2-3	FLOW CONTROL OPTION BITS      &
	!				4-7	CURRENTLY UNUSED	      &
	! RETURNS:	FNFLOW$		MNEMONIC, WHERE:		      &
	!				No	NO FLOW CONTROL		      &
	!				Seg	SEGMENT FLOW CONTROL	      &
	!				Msg	MESSAGE FLOW CONTROL	      &
	!				?	UNDEFINED		      &
	! ERRORS:	NONE						      &
									      &
									      &
									      &

18010	DEF* FNNAM$(B%,NM%)						      &
	\ FNNAM$=""							      &
	! FUNCTION:	FNNAM$		EXTRACT A NODE NAME OR RECEIVER	      &
	!				ID FROM A NOB OR RIB.		      &
	! PARAMETERS:	B%		BASE OF EITHER A NOB OR RIB	      &
	!		NM%		OFFSET WHERE THE NAME STARTS	      &
	! RETURNS:	FNNAM$		THE NODE NAME OR RECEIVER ID	      &
	!				WITH TRAILING BLANKS REMOVED	      &
	! ERRORS:	NONE						      &

18020	B$=""								      &
	\ B$=B$+CVT%$(SWAP%(FNP%(B%+J%))) FOR J%=NM% TO NM%+4% STEP 2%	      &
	\ B$=CVT$$(B$,-2%)						      &
	\ B$="" UNLESS LEN(B$)						      &
		! EXTRACT THE 6 CHARACTER ASCII NAME			      &

18030	FNNAM$=B$							      &
		! SET THE FUNCTION					      &

18040	FNEND								      &
									      &

18050	DEF* FNPN$(S%,N%)=SPACE$(S%-LEN(NUM1$(N%)))+NUM1$(N%)		      &
		! SPECIAL CASE FNN$ --  DON'T FORCE TO >0 (RDR & LDR).	      &
									      &
									      &

19000	!								      &
									      &
									      &
	!	E R R O R    H A N D L I N G				      &
									      &
									      &

19010	RESUME 19020							      &

19020	IF ERR=11% AND (ERL=1050% OR ERL=1090% OR ERL=1110%) THEN	      &
		GOTO 32767						      &
	ELSE	IF ERL=1110% OR ERL=1070% OR ERL=1090% OR ERL=5000% THEN      &
			E$=" - "+S$					      &
		ELSE	E$=" at Line "+NUM1$(ERL)			      &
	! TAKE CARE OF CONTROL/Z ON 'INPUT LINE'.			      &
	! ONLY EXPECTED, SPECIALLY FLAGGED ERRORS ARE OPEN ERRORS.	      &
	! FLAG ALL OTHERS WITH LINE # TO AID IN TRACK-DOWN OF REASON.	      &

19030	PRINT "?ANALY1 - ";FNE$(ERR);E$					      &
	! PRINT THE FATAL ERROR MESSAGE.				      &

19040	GOTO 32767							      &

31000	!								      &
									      &
									      &
	!	C H A I N    E N T R Y					      &
									      &
									      &

31010	ON ERROR GOTO 19000						      &
	\ E0%=2%							      &
	\ S$=SYS(CHR$(7%))						      &
	\ DIAGNOSE%=CVT$%(S$)						      &
	\ WORK1.FILE$=RIGHT(S$,3%)					      &
	\ GOTO 1000							      &
	! CHAIN ENTRY FROM ANALYS					      &
	! SET UP ENTRY TYPE, EXTRACT ALL REQUIRED INFO FROM CORE COMMON	      &
	! AND GOTO WORK.						      &

32767	END
