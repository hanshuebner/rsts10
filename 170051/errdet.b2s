1	!		PROGRAM		: ERRDET.B2S
	!		VERSION		: V10.1
	!		EDIT		: I
	!		EDIT DATE	: 31-JAN-92
	! 
	!
	!
	!		  C O P Y R I G H T
	!
	!
  	!		      Copyright (C) 1976, 1992 by
  	!	        Digital Equipment Corporation, Maynard, Mass. 
  	!	
  	!	
  	!	This software is furnished under a license and may be used and 
  	!	copied  only  in accordance with the terms of such license and 
  	!	with the  inclusion  of  the  above  copyright  notice.   This 
  	!	software  or  any  other copies thereof may not be provided or 
  	!	otherwise made available to any other person.  No title to and 
  	!	ownership of the software is hereby transferred. 
  	!		
  	!	The information in this software is subject to change  without 
  	!	notice  and should not be construed as a commitment by Digital 
  	!	Equipment Corporation. 
  	!	
  	!	DIGITAL assumes no responsibility for the use  or  reliability 
  	!	of its software on equipment that is not supplied by DIGITAL. 
  	!	
	!******************************************************************* 

	! 
	!
	!
	!	M O D I F I C A T I O N    H I S T O R Y 
	!
	!
	!
	! VER/ED	EDIT DATE	REASON
	! 9.0-10 VAM	14-Dec-84	Rewrite MSCP annotation section.
	! 9.3-02 VAM	17-Jan-86	Improve annotation for BBR packets.
	! 9.3-08 DBM	13-May-86	Ethernet support.
	! 9.4-04 VAM	30-Apr-87	Don't show MU errors if /NOTAPE.
	! 9.5-02 MRK	10-Jul-87	Convert to Basic Plus 2.
	! 9.5-05 VAM	01-Sep-87	More annotation for MSCP drive number.
	! 9.6-07 VAM	26-Feb-88	Add "BBR Failed" message.
	!10.1-01 FEK	17-Apr-91	Add Super & Data to MMU errors

	!
	!
	!
	!	G E N E R A L    D E S C R I P T I O N
	!
	!
   	!	ERRDET is CHAINed to from ERRDIS if a full report or list of
   	!	possible bad blocks is desired.

	!
	!
	!	I / O    C H A N N E L S
	!
	!
	!	CHANNEL #		USED FOR
	!
	!	2			ERRDAT.FIL, error descriptor file.
	!	5			Error logging file (E.G., ERRLOG.FIL).
	!	7			User output file.

	!
	!
	!
	!	V A R I A B L E    D E F I N I T I O N S
	!
	!
	!	VARIABLE NAME		USED FOR
	!
	!	ACC$		Account number obtained from the "FCB" list.
	!	ADDR$,ADDR%	Register pointer
	!	ANNOT$		Contains annotation text for MCSP fields
	!	ANOTHER.DASH$	Another string of dashes used to underline 
	!				titles
	!	BAD%		Disk retry counter - if -1% then we must further
	!				check this error for possible bad 
	!				blocks.
	!	BAD.CNT%	# of bad blocks we've found (if checking for
	!			them)
	!	BIT.DSC$	12 character bit descriptor (bit highlighter)
	!	CR		Carriage return - defined by BASIC
	!	CRLF		Carriage return/line feed
	!	CBUF$		Section of buffer which will be 'converted' in
	!				formatting function
	!	CNT%		Sent to FNDUMP% - # of bytes to be converted
	!	COD%		Sent to FNDUMP% - type of conversion
	!	CTENTS%		Contents of a register
	!	CNTRLR.MAX%	Total number of "XD" controllers
	!	CNTRLR.NO%	"XD" controller number
	!	D$,D1%		Dummy variables
	!	DASH$		String of -'s (hyphens)
	!	DASH.FLAG%	Flag for FNPRT% to know when to underline or not
	!	DB%		DB error code (19)
	!	DDCTBL%		Pointer to DDCTBL table
	!	DDCU$		Used to build the DDCU type physical device name
	!	DDIDX%		Driver index
	!	DIVISOR%	Holds divisor for 32-bit divide
	!	DM%		DM error code (16)
	!	DR%		DR error code (18)
	!	ENTRY.TYP%	Entry type indicator - 0=RUN, 2=CHAIN
	!	EN.DAT%		Limiting final date of errors to be checked
	!	EN.TIM%		Limiting final time of errors to be processed
	!	ER.DAT%		Date of a particular error
	!	ER.DSC$		16 character error description
	!	ER.MNE$		2 character error mnemonic
	!	ER.TIM%		Time (excluding seconds) a particular error
	!				occurred
	!	ER.TYP%		Error code of the error we're working on.
	!	FBN		Fip block # (used in checking for bad blocks)
	!	FILE$		Filename obtained from the "FCB" list
	!	FIRST%		Lower limit on range of error types to be 
	!				checked
	!	FIRST.DAT%	Date of first error
	!	FIRST.MIN%	Time of first error (excluding seconds)
	!	FIRST.TIM%	Seconds
	!	FUN%		Function be executed on disk errors -
	!				needed when checking for bad blocks.
	!	HIGH.WORD%	High-order word used for 32-bit divide and 
	!				DECOUT
	!	I$		Version/Edit #
	!	I%		Utility variable
	!	JSTBAD%		Indicates if only bad blocks are to be listed
	!	K%		Utility variable
	!	KB$,KB%		Used in determine correct KB #
	!	L$		Total length of an error record (field)
	!	LAST%		Upper limit of error types to be checked
	!	LAST.DAT%	Date of last error
	!	LAST.DSK%	Last disk error code
	!	LAST.FIELD%	Last field number of error message
	!	LAST.MIN%	Time (excluding seconds) of last error
	!	LAST.TIM%	Seconds 
	!	LAST.READ.BLK%	Last block number read from ERRDAT.FIL
	!	LBN		Logical block # of bad block
	!	LF		Line feed - defined by BASIC
	!	LN%		Total length of an error record
	!	LOW.WORD%	Low-order word used for 32-bit divide and DECOUT
	!	MSCP.ERR%	Error number for MSCP packet status code
	!	PA%		Memory system error code (7)
	!	PARAM$		20 byte parameter portion of each error record
	!	PBUF$		Print buffer
	!	PKT.TYP$()	Holds legal packet types from FNPACKET.TYPE%
	!	PPC%		Physical PC
	!	PRNT.IF.CLR%	If <>0, print bit descriptor only if bit is 
	!			clear
	!				If  =0, print bit descriptor only if 
	!				bit is set
	!	PRNT.UNIT%	Print unit number flag for non-disk devices
	!	Q$,Q%,Q0%,Q1%	Utility variables and strings
	!	REG%		Register counter
	!	REC%		Error file record counter
	!	REG$,CURRENT.REG%	Register being looked at
	!	REMAINDER%	Holds remainder from 32-bit divide
	!	REST$		Portion of this error record that we're not
	!				working with yet
	!	RK06ER%,RM03ER%	Bad block flags
	!	S$,S0$		Utility strings
	!	SA.REG$		Contains the value of the SA register
	!	SAV$		String containing bad block info
	!	SKP%		Sent to FNDUMP% - print controller
	!	TABLE3%		Get MONITOR TABLE PART III flag
	!				 0 = we haven't yet done the call
	!				-1 = we have already done the call
	!	TOT.LIM%	Error file block limit
	!	TOT.LOG%	Total errors logged, including repeats
	!	TOT.REC%	Total errors received
	!	TOT.USED%	Total blocks used
	!	T1%,T2%		Utility time variables
	!	THE.END%	# of descriptors for a particular error field
	!	UCTTBL%		Pointer to the start of the UCTTBL table
	!	UDA.ER.DESC$	Holds current UDA error message
	!	UDA.ER.TYP%	UDA error number
	!	UNIT.CNT%	Cumulative total of "XD" devices
	!	UNIT.NO%	Supplied device unit number
	!	VPC%		Virtual PC
	!	ZERO%		Indicates whether file will be zeroed on return
	!				to ERRDIS
	!
	!
	!	F U N C T I O N / S U B R O U T I N E    D E S C .
	!
	!

	!	FUNCTION/SUBROUTINE		USE
	!
	!	FNBYTE$			Get a 3 position octal string
	!	FNBAD.CVT%		Bad block conversion into decimal
	!	FNDUMP%			Formatting (conversion) function
	!	FNN$			Left pad a numeric string with spaces
	!	FNWORD$			Get a 6 position octal string
	!	FNPACKET.TYPE%		Returns type of an MSCP packet
	!	FNPRT%			Print routine 
	!	FNTIM2$			Get a time string in HH:MM:SS form
	!	FNT3%			Get MONITOR TABLE PART III

	!
	!
	! 	D E C L A R A T I O N      S T A T E M E N T S
	!
	! 

	DECLARE STRING CONSTANT		CTRAP = "6"C + "249"C, &
					CRLF = CR + LF, &
					NL = ""

	DECLARE INTEGER CONSTANT	FIRST.DSK = 12%, &
					LAST.DSK  = 21%, &
					LAST.DEV  = 43%, &
					PA        =  7%, &
					KT        =  8%, &
					DB        = 19%, &
					DM        = 16%, &
					DR        = 18%, &
					DU        = 21%, &
					TS        = 38%, &
					MU        = 41%, &
					XE        = 42%, &
					XH        = 43%

	!
	!
	!
	!	D I M E N S I O N    S T A T E M E N T S
	!
	!

	DIM	N%(3%), N$(3%), &
		P%(11%), F%(84%), PKT.TYP$(15%), &
		FLD.LEN%(8%),OFF%(8%), &
		PART$(8%),M%(30%), &
		HEX.CHARS%(15%), TBL%(31%)
		! P%()	Used in extracting parameter info
		!	Elements are as follows:
		!	SUBSCRIPT	CONTENTS
		!	  1		Error code
		!	  2		Job #*2
		!	  3		Last field
		!	  4		Repeat count
		!	  5-6		Sequence #
		!	  7-8		Date
		!	  9-10		Time
		!	  11		Seconds to next minute
		!
		! F%()	Used to extract field info which must be specially
		! 	processed.
		!
		! NOTE: If Error Code=55 ('Unrecognized Msg'), then
		!	SUBSCRIPT	CONTENTS
		!	  1		55
		!	  2		Job#*2 of sender
		!	  3-4		PPN of sender
		!	  5-6		0'S
		!	  7-8		Date
		!	  9-10		Time
		!	  11		0
		! M%()		Used to hold returned SYS() info.
		! HEX.CHARS%()	Holds hexidecimal/BCD character set.
		! PKT.TYP$()	Holds MSCP packet type descriptors
		! OTHERS	Used in extracting error record fields.

	DECLARE INTEGER CONSTANT	DRIVE.MODEL.LIMIT = 4%
		! This is equal to the maximum allowable value for
		!  the first subscript of DRIVE.MODEL$.  We also use it
		!  later for range checking.

	DIM #3%, &
		ITEM.DESC$(31%)=32%, &
		! 	Field descriptions &
		SA.ERROR.CODE$(31%)=32%, &
		! 	SA Register Codes &
		MESSAGE.FLAG$(7%)=32%, &
		! 	Message Flags &
		END.FLAG$(7%)=32%, &
		! 	End Flags &
		END.CODE$(255%)=32%, &
		! 	End Codes &
		STATUS.CODE$(255%)=64%, &
		! 	Status Codes &
		UNIT.CLASS$(255%)=16%, &
		! 	Controller and Drive Class &
		CONTROLLER.MODEL$(255%)=8%, &
		! 	Controller Model &
		UDA.ERROR.CODE$(63%)=64%, &
		! 	UDA Internal Error Codes &
		DRIVE.MODEL$(DRIVE.MODEL.LIMIT,255%)=8%, &
		! 	Disk and Tape Drive Model &
		DRIVER.ERROR.CODE$(31%)=32%, &
		! 	Driver internal error codes &
		BBR.FAIL.CODE$(31%)=32%, &
		! 	BBR failure byte codes &
		STATUS.CODE.IDX%(255%), &
		! 	Index for STATUS.CODE$() &
		PKT.ITEM%(15%,31%), &
		! 	Items to print for packets &
		BBR.FLAG.CODE$(7%)=16%, &
		! 	BBR flag byte bit meanings &
		UDA.ERROR.CODE.IDX%(63%), &
		! 	Index for UDA.ERROR.CODE$() &
		SDI.STATUS.1%(15%), &
		! 	SDI Error bits (Word 1) &
		SDI.STATUS.2%(15%)
		! 	SDI Error bits (Word 2)
		!		
		! The MSCP message and detail file.


	!
	!
	!	M A I N    C O D I N G    A R E A
	!
	!

 ENTRY_POINT:
	ON ERROR GOTO 19000
		! Set up standard error trap.

	I$="V10.1-I"
		! Set up version/edit #

	IF ENTRY.TYP%=0% THEN
		PRINT IF CCPOS(0%)
		PRINT "ERRDET";CHR$(9%);I$;CHR$(9%)
	END IF
		! IF we have a run entry THEN
		!	return KB to left margin
		!	print the system header

	PKG.LOC$="ERROR$:"
	IF ENTRY.TYP%<>2% AND ENTRY.TYP%<>3% AND ENTRY.TYP%<>8% THEN
		PRINT "?Illegal Entry - Please 'RUN ";PKG.LOC$;"ERRDIS'"
		GOTO DROP_PRIVLIGES_AND_EXIT
	END IF
		! Only CHAINing from ERRDIS is allowed.
		! 2 means CHAIN from ERRDIS.
		! 3 means CHAIN from ERRDIS after ANALYS was run.

	IF NOT FNPRIV%("SWCTL") THEN
		PRINT "?SWCTL privilege required"
		GOTO DROP_PRIVLIGES_AND_EXIT
	END IF
		! You need SWCTL to be here.

	IN.INT%,TABLE3%,LAST.READ.BLK% = 0%
	JSTBAD%=-1% IF ER.COD%=62%
	S$=SYS(CHR$(6%)+CHR$(-21%)+CHR$(255%))
	IF HND.IDX%=0% THEN
		OPEN O0$ FOR INPUT AS FILE 7%, MODE 2%
	ELSE	IF HND.IDX%=14% THEN
			OPEN O0$ FOR OUTPUT AS FILE 7%, MODE 128%
		ELSE	OPEN O0$ AS FILE 7%
		END IF
	END IF
		! Set up CR-LF string.
		! Set up last disk error code.
		! Set up specially used error codes.
		! Drop privleges before opening the output file.
		! Re-open the output file:
		! Disk and tape - append mode

	PKT.TYP$(0%)="Unknown"
	PKT.TYP$(1%)="End Message Packet"
	PKT.TYP$(2%)="Last Fail Packet"
	PKT.TYP$(3%)="Controller Error Packet"
	PKT.TYP$(4%)="Host Memory Access Error Packet"
	PKT.TYP$(5%)="Disk Transfer Error Packet"
	PKT.TYP$(6%)="SDI (Standard Disk Interface) Error Packet"
	PKT.TYP$(7%)="Small Disk Error Packet"
	PKT.TYP$(8%)="Tape Transfer Error Packet"
	PKT.TYP$(9%)="STI Communication or Command Failure Packet"
	PKT.TYP$(10%)="STI Drive Error Log Packet"
	PKT.TYP$(11%)="STI Formatter Error Log Packet"
	PKT.TYP$(12%)="Bad Block Replacement Attempt Packet"
	PKT.TYP$(13%)="Media Loader Error Packet"
	PKT.TYP$(15%)="No Packet Generated"

	HEX.CHARS%(I%)=I%+48% FOR I%=0% TO 9%
	HEX.CHARS%(I%+10%)=I%+65% FOR I%=0% TO 5%

	! These are the currently legal packet types.
	! The value used as the index is gotten from FNPACKET.TYPE% -
	!  these numbers have nothing to do with the real world.
	! Type 15 is a special case - This is used in the event an MSCP SA
	!  error occurs, in which case the controller does not generate an
	!  error packet.
	! The numbers in HEX.CHARS%() represent the ASCII values of the digits
	!  in the hexadecimal/BCD character set.

	S$=SYS(CHR$(6%)+CHR$(-21%)+CHR$(0%))
	OUT.OPN%=-1%
	OPEN PKG.LOC$+"ERRDAT.FIL" FOR INPUT AS FILE 2%, MODE 8192%
	OPEN PKG.LOC$+"MSCPER.FIL" FOR INPUT AS FILE 3%, MODE 8192%
	OPEN I0$ FOR INPUT AS FILE 5%
	GET #5%, RECORD 1%
	FIELD #5%, 498% AS D$, 2% AS TOT.REC$, 2% AS TOT.USED$, &
	  2% AS Z$, 2% AS TOT.LIM$
	TOT.REC%=CVT$%(TOT.REC$)
	IF TOT.REC%=0% THEN
		PRINT #7%,CRLF;CRLF;"No Errors have been Received"
		ZERO%=0%
	GOTO PRINT_TOTALS_AND_CHAIN
	END IF
		! Get our privleges back.
		! Open the error description file.
		! Open the error log file.
		! Set up to extract totals from header.
		! If no errors have been received, (file wiped out
		! between errdis and here) skip scan.

	TOT.USED%=CVT$%(TOT.USED$)
	TOT.LIM%=CVT$%(TOT.LIM$)
	THIS.PAG%,LAST.COD%,BAD.CNT%=0%
	AST$=STRING$(76%,42%)
	DASH$=STRING$(28%,45%)
	FIRST%,LAST%=ER.COD%
	PR%=-1%
	IF ER.COD%<0% THEN
		FIRST%,PR%=0%
		LAST%=61%
	END IF
		! Get rest of totals.
		! Get the code (0-61) of the error (all IF CODE=-62) to be
		! listed - set up proper scanning limits accordingly.

	IF ER.COD%=62% THEN
		FIRST%=FIRST.DSK
		LAST%=LAST.DSK
		PRINT #7%,"List of Possible Bad Blocks:";CRLF;DASH$
	END IF
		! IF CODE=62 THEN
		!	set up to just scan disks:
		! TYPE	DC DF DS DK DM DP DR DB DL
		! CODE	12 13 14 15 16 17 18 19 20

	FOR REC%=2% TO TOT.USED%
		PRV%=0%
		GET #5%, RECORD REC%

 FIELD_ERROR_RECORD:	
		FIELD #5%,PRV% AS D$,2% AS L$
		LN%=CVT$%(L$)
		GOTO GET_NEXT_BLOCK IF LN%=0% OR LN%<22% OR (LN%+PRV%)>512%
		FIELD #5%,PRV% AS D$,2% AS L$,20% AS PARAM$
		CHANGE LEFT(PARAM$,11%) TO P%
		ER.TYP%=P%(1%)
		LAST.FIELD%=P%(3%)
		GOTO GET_NEXT_RECORD UNLESS ER.TYP%>=FIRST% AND ER.TYP%<=LAST%
		IF ER.COD%=-63% THEN
			GOTO GET_NEXT_RECORD IF	((ER.TYP%=31%) &
					OR (ER.TYP%=32%) &
					OR (ER.TYP%=TS) &
					OR (ER.TYP%=MU))
		END IF
		BAD%,SPECIAL%=0%
		GOTO VERIFY_DATE_TIME_RANGE IF ER.TYP%=55%
		IF JSTBAD% THEN
			GOTO GET_NEXT_RECORD UNLESS LAST.FIELD%>=4%
			GOSUB IND_FIELD_SETUP_SUBROUTINE
			GOSUB DISKS_SUBROUTINE
			GOSUB MSCP_DUMP_SUBROUTINE IF ER.TYP%=DU OR ER.TYP%=MU
			GOTO GET_NEXT_RECORD
		END IF
		! Go print field 5 only if it's a [T]MSCP error.

 VERIFY_DATE_TIME_RANGE:
		ER.DAT%=P%(7%)+SWAP%(P%(8%))
		ER.TIM%=P%(9%)+SWAP%(P%(10%))
		ER.MIN% = P%( 11% )
		GOTO GET_NEXT_RECORD IF ER.DAT%<ST.DAT% OR &
			ER.DAT%>EN.DAT% OR &
			(ER.DAT%=ST.DAT% AND ER.TIM%>ST.TIM%) OR &
			(ER.DAT%=EN.DAT% AND ER.TIM%<EN.TIM%)
		IN.INT% = IN.INT% + 1%
		IF FIRST.DAT%=0% THEN
			FIRST.DAT%=ER.DAT%
			FIRST.TIM%=ER.TIM%
			FIRST.MIN%=P%(11%)
			GOTO GET_ERROR_DESCRIPTOR_INFO
		END IF
		! Look at the next 'legal' error record.
		! Extract the parameter portion of the record.
		! Ignore unless the error type is to be reported.
		! Skip bad block If code 55 (unrecognized MSG) since P%(3)
		!  has a different meaning.
		! If only bad blocks are to be listed then
		!	ignore entry unless at least 4 fields are present
		!	do the individual field set up.
		!	goto the disk field 2 routine which will cause
		!	all the real work to be done.
		!	go on to the next entry.
		! Verify that the DATE/TIME is within the desired range.
		! Save the very first reported DATE and TIME.

		THIS.COD%=(ER.TYP%=0%)
		IF (THIS.PAG%<10%) AND &
			(LAST.COD%<>0%) AND (THIS.COD%<>0%) THEN
			PRINT #7%,CRLF;CRLF
		ELSE	PRINT #7%,CHR$(12%)
			THIS.PAG%=0%
		END IF
		! THIS.COD=0 unless this is one of our "don't skip a page"
		!	codes (currently just MS)
		! If we havn't filled up a page and the previous code was a
		! "DSAP" code and this one is too then
		! 	just skip a couple of lines
		! else	new page - clear # on page count.

 GET_ERROR_DESCRIPTOR_INFO:
	IF	ER.TYP%=DR &
	AND	((SWAP%(CVT$%(MID(CBUF$,(10%*2%)+1%,2%)))) AND 255%)=34% &
		THEN	NEW.BLK%=DB+1%
		ELSE	NEW.BLK%=ER.TYP%+1%
	END IF
	!	If it's a DR error, but the registers say that the drive
	!	type is RP07, then treat it like an RP06.

		GOSUB CACHED_READ_SUBROUTINE
		GOSUB IND_FIELD_SETUP_SUBROUTINE UNLESS ER.TYP%=55%
		FIELD #2%,16% AS ER.DSC$,494% AS D$,2% AS ER.MNE$

		IF ER.TYP%=TS THEN
			FIELD #5%,OFF%(2%)+17% AS D$,1% AS D$
			D%=2%*ASCII(D$)+1%
			D%=17% IF D%>13%
			ER.DSC$=MID("TS11TU80TK25TS05Unkn",D%,4%)
			GOTO PRINT_HEADER_INFO
		END IF

		IF ER.TYP%=MU THEN
			FIELD #5%,OFF%(2%)+17% AS D$,1% AS D$
			D%=4%*ASCII(D$)+5%
			D%=1% IF D%=61%
			D%=5% IF D%>29%
			ER.DSC$=MID("TK70UnknUnknTU81TK50UnknUnknTK60",D%,4%)
		END IF
	!
	!	If TS or MU error get drive type from DDB.
	!	Do some magic on it depending on the error type
	!	to get to the correct name in the string.
	!	If we don't know about it, point it to "Unkn"
	!	TS drive types are TS11(0),TU80(2),TK25(4),TS05(6).
	!	MU drive types are TU81(2),TK50(3),TK70(14).

 PRINT_HEADER_INFO:
		PRINT #7%,AST$;CRLF;ER.MNE$;"  ";CVT$$(ER.DSC$,128%);
		PRINT #7%," Seq #";FNUNSIGNED$(P%(5%)+SWAP%(P%(6%))); &
			UNLESS ER.TYP%=55%
		PRINT #7%," Occurred on ";DATE$(ER.DAT%);" at "; &
		 	FNTIM2$(ER.TIM%,P%(11%))
		GOTO PRINT_DETAILED_DESCRIPTION UNLESS ER.TYP%=55%
		PRINT #7%,CRLF;"Received from:";CRLF;LEFT(DASH$,14%);CRLF; &
			"Job Number";TAB(32%);NUM1$(P%(2%)/2%);CRLF; &
			"Account";TAB(32%);"[";NUM1$(P%(4%));","; &
			NUM1$(LAST.FIELD%);"]"
		GOTO SKIP_PAGE_CHECK
		! Print header info.
		! Print all we can about 'unrecognized messages'.

 PRINT_DETAILED_DESCRIPTION:
		PRINT #7%,"Repeat Count: ";NUM1$(P%(4%)) IF P%(4%)
		GOTO SKIP_PAGE_CHECK UNLESS LN%>24%
		GOSUB USER_DESCRIPTION_SUBROUTINE
		PRINT #7%,CRLF;"Detailed Description:";CRLF;LEFT(DASH$,21%)
		IF ER.TYP%>=FIRST.DSK AND ER.TYP%<=LAST.DSK THEN
			GOSUB DISKS_SUBROUTINE
		ELSE	IF ER.TYP%>23% AND ER.TYP%<=LAST.DEV THEN
				GOSUB NON_DISK_DEVICE_SUBROUTINE 
			ELSE	GOSUB NON_DEVICE_SUBROUTINE
			END IF
		END IF
		! Take care of all disks: CODES 12-21
		!
		! Do 'other peripheral devices':
		!	24	KB
		!	25	DT
		!	26	LP
		!	27	PR
		!	28	PP
		!	29	CR
		!	30	CD
		!	31	MT
		!	33	DX
		!	34	XM
		!	35	RJ
		!	36	XY
		!	37	NW
		!	38	TS
		!	39	DD
		!	40	XD
		!	41	MU
		!	42	XE
		!	43	XH
		!
		! Do all non-devices.

		S$="CSR Address"
		DASH.FLAG%=-1% IF FLD.LEN%(3%)>0%
		ANOTHER.DASH$=LEFT(DASH$,12%)
		S$=S$+"es" IF FLD.LEN%(3%)>2%
		ANOTHER.DASH$=LEFT(DASH$,14%) IF FLD.LEN%(3%)>2%
		S$=S$+":"
		Z%=FNDUMP%(S$,OFF%(3%),FLD.LEN%(3%),1%,1%) &
			IF FLD.LEN%(3%)>0%
		IF FLD.LEN%(4%)>0% THEN
			PRINT #7%
			DASH.FLAG%=-1%
			ANOTHER.DASH$=LEFT(DASH$,22%)
			L4%=FLD.LEN%(4%)
			Z%=FNDUMP%("Contents of Registers:",OFF%(4%),L4%,4%,1%) &
				IF L4%>2%
			ANOTHER.DASH$=LEFT(DASH$,21%)
			Z%=FNDUMP%("Contents of Register:",OFF%(4%),L4%,4%,1%) &
				IF L4%<3%
		! Dump registers and contents If fields contain data.
		! Standardize output report by:
		!	1. Using DASH.FLAG% to control when FNPRT% underlines
		!		the appropiate title
		!	2. Using ANOTHER.DASH$ as the underline for FNPRT%
		!	3. Building S$ as singular or plural and
		!		with a ":" on the end.
		!	4. Printing "Register:" as singular or plural.

		END IF

		IF	(ER.TYP%=DU OR ER.TYP%=MU) &
		AND	(FLD.LEN%(5%)>0%) &
		THEN	GOSUB MSCP_DUMP_SUBROUTINE
		END IF
		! Go dump Field 5, If it's there and we've got
		!  a [T]MSCP error

 SKIP_PAGE_CHECK:
		LAST.COD%=(ER.TYP%=0%)
		THIS.PAG%=THIS.PAG%+1% IF LAST.COD%
		! LAST.COD%=TRUE If this is a "don't skip a page" code.
		! If true, keep track of number on this page so we don't go
		! hog wild printing.

 GET_NEXT_RECORD:
		PRV%=PRV%+LN%
		GOTO FIELD_ERROR_RECORD UNLESS PRV%>490%

 GET_NEXT_BLOCK:
	NEXT REC%
	LAST.DAT%=ER.DAT%
	LAST.TIM%=ER.TIM%
	LAST.MIN%=ER.MIN%
		! Save the exact time and date of the last error.
	IF JSTBAD% THEN
		PRINT #7%,"None Found" UNLESS BAD.CNT%
		GOTO PRINT_TOTALS_AND_CHAIN
	END IF
		! If just listing bad blocks then
		!	let the user know we're done and get out.

	IF IN.INT% = 0% THEN
		PRINT "No errors found within the desired interval."
		GOTO PRINT_TOTALS_AND_CHAIN
	END IF

	GET #5%, RECORD 1%
	PRINT #7%,CHR$(12%) IF FIRST.DAT%
	PRINT #7%,"Reported Date/Time Range:";CRLF;"	";DATE$(FIRST.DAT%); &
			", ";FNTIM2$(FIRST.TIM%,FIRST.MIN%);" through "; &
			DATE$(LAST.DAT%);", ";FNTIM2$(LAST.TIM%,LAST.MIN%); &
			CRLF;"File Totals Follow:";CRLF
	FOR I%=FIRST% TO LAST%
	FIELD #5%,I%*8% AS D$,2% AS N$(0%),2% AS N$(1%), &
				2% AS N$(2%),2% AS N$(3%)
		N%(K%)=CVT$%(N$(K%)) FOR K%=0% TO 3%
		IF PR% OR N%(2%) THEN
			NEW.BLK%=I%+1%
			GOSUB CACHED_READ_SUBROUTINE
			FIELD #2%, 16% AS ER.DSC$
			S$=" "
			S$="s" UNLESS N%(1%)=1%
			PRINT #7%,CRLF;ER.DSC$;" --"; &
			FNN$(7%,N%(1%));"Error";S$; &
			" Logged out of";FNN$(7%,N%(2%));"Received"
			PRINT #7%;TAB(21%);"Record Limit ("; &
			N%(3%);") for this Type has been Reached" &
				IF N%(0%)=N%(3%)
			PR%=0%
		END IF

	NEXT I%
	PRINT #7%,NUM1$(TOT.USED%);" out of";TOT.LIM%; &
	  "Blocks have been used in ";I0$

 PRINT_TOTALS_AND_CHAIN:
	PRINT #7% IF OUT.OPN%<>0%
	PRINT #7%,"Total Number of Possible Bad Blocks:";BAD.CNT% &
		IF BAD.CNT% AND JSTBAD%
	PRINT #7%, AST$
	CLOSE 2%,3%,5%,7%
	GOTO DROP_PRIVLIGES_AND_EXIT IF ENTRY.TYP%=3%
	I0$=I0$+"/NEW" IF ENTRY.TYP%=8%
	S$=SYS(CHR$(8%)+CVT%$(ZERO%)+I0$)
	CHAIN PKG.LOC$+"ERRDIS" LINE 31000
		! Print bad block total.
		! All done - get out if ERRDIS report was appended
		! 	to ANALYS report.
		! Go back to main program to (possibly) zero file,
		! 	list bad blocks and restart ?'s. 

10000	!
	!
	!
	!	S U B R O U T I N E S
	!
	!
	!	F I E L D    1    -    U S E R    D E S C R I P T I O N
	!
	!

 USER_DESCRIPTION_SUBROUTINE:
	GOTO END_USER_DESCRIPTION_SUBROUTINE IF FLD.LEN%(1%)=0% OR P%(2%)=0%
	CHANGE PART$(1%) TO F%
	KB%=F%(1%)+SWAP%(F%(2%))
	IF KB%>=0% THEN
		KB$=NUM1$(KB%)
	ELSE	KB$=NUM1$(NOT KB%)+" (Det)"
	END IF
		! IF FIELD 1 is really filled THEN
		!	extract the KB number - if this is complemented,
		!	it means the job was detached.

	NEW.BLK%=63%
	GOSUB CACHED_READ_SUBROUTINE
	PRINT #7%,CRLF;"User Description:";CRLF;LEFT(DASH$,17%);CRLF; &
	  	"Job Number";TAB(32%);NUM1$(P%(2%)/2%);CRLF; &
	  	"KB Number";TAB(32%);KB$;CRLF; &
		"Account";TAB(32%);"[";NUM1$(F%(4%));",";NUM1$(F%(3%));"]"
	FOR K%=0% TO 5%
		Z%=FNREAD%(K%)
		Z%=FNDUMP%(NAM$,OFF%(1%)+OF%,CNT%,COD%,SKP%)
		PRINT #7%;"00" IF K%=1% OR K%=5%
		PRINT #7%;"K" IF K%=2%
	NEXT K%
		! Initialize the data.
		! Print TITLE, JOB #, (converted) KB # and PPN.
		! Get and print the contents of FIELD 1:
		!	OFFSET		CONTENTS
		!	0	KB # (complemented if detached)
		!	2	PPN
		!	4	PROGRAM NAME1
		!	6	PROGRAM NAME2
		!	8	M.PHAY
		!	10	M.CTRL - M.SIZE
		!	12	RTSNAME1
		!	14	RTSNAME2
		!	16	M.PHAR
		!
		! Note that M.SIZE (user program size) will be printed
		!  as XXK .

 END_USER_DESCRIPTION_SUBROUTINE:
	RETURN

	!
	!
	!
	!	F I E L D    2    -    D I S K S
	!
	!

 DISKS_SUBROUTINE:
	NEW.BLK%=64%
	GOSUB CACHED_READ_SUBROUTINE
	CHANGE LEFT(PART$(2%),18%) TO F%
	DCS%=F%(7%)
	GOTO UDA_CONTROLLER_ERRORS IF F%(4%) AND ER.TYP%=DU
	S$=":"
	S$=NUM1$(F%(17%))+S$ IF F%(18%)
	SPECIAL%=(ER.TYP%=DM OR ER.TYP%=DR)
	OFF.POS%=0%
	OFF.POS%=F%(3%) IF SPECIAL% OR ER.TYP%=DB
	CHANGE MID(PART$(2%),17%,32%) TO F%
	IF SPECIAL% OR ER.TYP%=DB THEN
		BAD%=(F%(31%)=1%) IF OFF.POS%=176%
	ELSE	BAD%=(F%(4%)=255%)
	END IF
		! This section also dumps UDA errors, unless F%(4%) is set,
		!	then drop to section for UDA controller errors.
		! Get to the beginning of the disk info.
		! Set "SPECIAL" flag to show if we have RK06 or RM03 -
		! bad blocks must be handled specially for these.
		! From FIELD 2, extract offset position (if we have an
		! RP04-05-06, RM03, or RK06) and the disk unit #, if explicit.
		!
		! From the DSQ in FIELD 2, extract the 'retry' counter:
		! for RK06, RM03, and RP04-05-06, this is DSQCTO (ignore
		! what's there unless offset position was 260(8) (176(10)).
		! For all other disks, it is DSQERR.

	GOTO END_DISKS_SUBROUTINE IF JSTBAD% AND ER.TYP%=DU
	GOTO END_DISKS_SUBROUTINE UNLESS (BAD% OR SPECIAL%) IF JSTBAD%
	Z%=FNBAD.CVT%
	GOTO PRINT_DISK UNLESS JSTBAD%
	GOSUB PRINT_BAD_BLOCKS_SUBROUTINE
	GOTO END_DISKS_SUBROUTINE
		! No need to hunt for bad blocks here if it's a UDA error.
		! Stick around if we're working on bad blocks.
		! Get the LBN in decimal.
		! Again stick around if we're working on bad blocks.
		! Go print it out.
		! Get out.

 PRINT_DISK:
	FOR K%=0% TO (10%-(FLD.LEN%(2%)>50%)-(FLD.LEN%(2%)>82%))
		Z%=FNREAD%(K%)
		IF K%=2% AND OFF.POS%=64% THEN
			PRINT #7%,NAM$;TAB(32%);"Previous"
		ELSE	Z%=FNDUMP%(NAM$,OFF%(2%)+OF%,CNT%,COD%,SKP%)
			PRINT #7% IF K%=10% OR K%=11%
			PRINT #7%,TAB(32%);NUM1$(LBN);CRLF IF K%=9%
			PRINT #7%,S$ IF K%=8%
		END IF

	NEXT K%
	PRINT #7%
	GOTO END_DISKS_SUBROUTINE
		! Get, decode and print the contents of each FIELD 2 offset.
		! Note that the disk unit # must be handled specially.
		! The contents of FIELD 2 for a disk is as follows:
		!	K%	OFFSET	CONTENTS
		!	0-1	0	Timeout - status
		!	2-3	2	Overlap - offset
		!	4	4	Unit size in DC'S
		!	5-6	6	PCS	- DCS
		!	7	8	Logical NAME1
		!		10	Logical NAME2
		!	8	12	Physical name
		!		14	Explicit - unit # (unit # is available
		!				   if explicit=-1)
		!	9	--	LBN (position only-compute LBN)
		!	10	16	DSQ
		!	11	48	WCB (if a file request)
		!	12	80	FCB (if a file request) 

	!
	!
	!	U D A   C O N T R O L L E R   E R R O R S   O N L Y
	!
	!

 UDA_CONTROLLER_ERRORS:
	GOTO END_DISKS_SUBROUTINE IF JSTBAD%
	FOR K%=0% TO 1%
		Z%=FNREAD%(K%)
		Z%=FNDUMP%(NAM$,OFF%(2%)+OF%,CNT%,COD%,SKP%)
	NEXT K%
	PRINT #7%,CRLF
	GOTO END_DISKS_SUBROUTINE
		! Return if looking for just bad blocks
		! IF F%(4%)<>0%, and this is a UDA error, THEN it is a
		! 	controller error, so there will be no offsets 4
		!	through 80.
		! Print just the "I/O STATUS" and "TIMEOUT INDICATOR"
		!	before getting out.

 END_DISKS_SUBROUTINE:
	RETURN

	!
	!
	!
	!	F I E L D    2    -    N O N - D I S K 
	!				 D E V I C E
	!
	!

 NON_DISK_DEVICE_SUBROUTINE:
	NEW.BLK%=65%
	GOSUB CACHED_READ_SUBROUTINE
	GOTO ETHERNET_CONTROLLER IF FLD.LEN%(2%)<=0%
	CHANGE LEFT(PART$(2%),8%) TO F%
	PRNT.UNIT%=-1%
	S$=":"
	S$=NUM1$(F%(5%))+S$ IF F%(6%)
	DDB.SIZ%=(F%(7%)+SWAP%(F%(8%)))*2%
	DDB.EXT.SIZ%=FLD.LEN%(2%)-8%-DDB.SIZ% 
	FOR K%=0% TO (2%-(DDB.EXT.SIZ%>0%))
		Z%=FNREAD%(K%)
		IF K%=2% THEN
			CNT%=DDB.SIZ%
		ELSE	IF K%=3% THEN
				CNT%=DDB.EXT.SIZ%
				OF%=8%+DDB.SIZ%
			END IF
		END IF

		Z%=FNDUMP%(NAM$,OFF%(2%)+OF%,CNT%,COD%,SKP%)
		PRINT #7%,S$ IF K%=1% AND PRNT.UNIT%=-1%
		PRINT #7% UNLESS K%=0%
	NEXT K%

 ETHERNET_CONTROLLER:
	PRINT #7% IF FLD.LEN%(2%)<=0%
	FOR K%=6% TO 8%
		IF FLD.LEN%(K%)>0% THEN
			S$=MID("TSQCCBCDB",K%*3%-17%,3%)
			Z%=FNDUMP%(S$,OFF%(K%),FLD.LEN%(K%),1%,1%)
			PRINT #7%
		END IF

	NEXT K%
		! FOR NON-DISKS DEVICES:
		!	K%	OFFSET		CONTENTS
		!	0	0		Timeout
		!	1	2		Physical name
		!		4		Explicit
		!		6		DDB size in words
		!	2	8		Start of the DDB
		!	3	8+DDB SIZE	DDB extension (optional)
		!
		! FIELD 6 is a new field which holds the TSQ of a request
		! it is currently only defined for the MSDVR, but will be
		! required by the TMSCP driver.  Since it is comparable to
		! a DSQ, it is dumped here with FIELD 2 for non-disk devs.
		!
		! FIELD 7 is the CCB for an ethernet controller, and
		! FIELD 8 is the CDB for an ethernet controller.
		!
		! Note that proper size of the DDB extension should be
		! the length of FIELD 2 (which is in bytes) - 8 bytes
		! for the TI, NAME/UNIT, and DDB size - DDB size in bytes.

	RETURN

	!
	!
	!
	!	F I E L D    2    -    N O N - D E V I C E
	!
	!

 NON_DEVICE_SUBROUTINE:
	NEW.BLK%=66%
	GOSUB CACHED_READ_SUBROUTINE
	CHANGE LEFT(PART$(2%),32%) TO F%
	FOR K%=0% TO 15%
		Z%=FNREAD%(K%)
		Z%=FNDUMP%(NAM$,OFF%(2%)+OF%,CNT%,COD%,SKP%)
		IF K%=7% THEN 
			PPC%=F%(17%)+SWAP%(F%(18%))
			VPC%=F%(13%)+SWAP%(F%(14%))
			PPC%=PPC%+((VPC% AND 8191%)/64%)
			PRINT #7%;TAB(32%);FNWORD$(PPC%); & 
				RIGHT(FNBYTE$(VPC%),2%)
		END IF

	NEXT K%
		! Print out everything - take special care of physical PC,
		! which is calculated from the virtual PC and contents of 
		! the page address register.
		! For non-devices, FIELD 2 contains the following:
		!	OFFSET	CONTENTS
		!	0	R0
		!	2	R1
		!	4	R2
		!	6	R3
		!	8	R4
		!	10	R5
		!	12	Virtual PC
		!	14	PSW
		!	16	Contents of the page address register
		!	18	Stack pointer
		!	20	Last word on the stack
		!	22	Next to last on the stack
		!	24	(Program counter-6)
		!	26	(PC-4)
		!	28	(PC-2)
		!	30	(PC)
		!	32	CPU ID 
		!	34	CPU ERR

	CHANGE RIGHT(PART$(2%),33%) TO F%
	F%(K%)=F%(K%)+SWAP%(F%(K%+1%)) FOR K%=1% TO 31% STEP 2%
	PRINT #7%, "CPU ID";TAB(32%); &
		SPACE$(6%-LEN(NUM1$(F%(1%))));NUM1$(F%(1%))
	PRINT #7%, "CPU ERR";TAB(32%);FNWORD$(F%(3%))
	FOR K%=5% TO F%(0%)-4% STEP 2%
		PRINT #7%, "MED ";FNBYTE$(64%+((K%-5%)/2%)); &
			TAB(32%);FNWORD$(F%(K%))
	NEXT K%
	PRINT #7%
	! Print out the CPU specific information.

	RETURN

	!
	!
	!
	!	F I E L D  5  	-  [ T ] M S C P   D U M P
	!
	!			-  U D A   B A D   B L O C K S
	!
	!

 MSCP_DUMP_SUBROUTINE:
	GOTO BAD_BLOCKS_SUBROUTINE IF JSTBAD%
	CHANGE LEFT(PART$(5%),FLD.LEN%(5%)) TO F%
	MSCP.ERR%=(F%(15%) AND 31%)
	PKT.LEN%=F%(1%)+SWAP%(F%(2%))
	IF SA%>=0% AND PKT.LEN%>0% THEN
		PKT%=FNPACKET.TYPE%(0%) ELSE
		PKT%=15%
	END IF
	! Let 'em know what's coming up.
	!
	!  Field 5 contains:
	!		Offset		Contents
	!		   0	[T]MSCP envelope (2 words)
	!		   4	[T]MSCP packet (60(10) bytes)
	!		  64	[T]MSCP internal control status word
	!		  66	[T]MSCP internal unit status word
	!		  68	[T]MSCP error code.  This is a number
	!				which the driver produces to indicate
	!				what it thinks is happening.  If this
	!				=1% (for MSCP devices), then the
	!				operation was a bad block replacement.
	!		  70	BBR failure code.  This byte is zero if BBR
	!				was successful, and contains a failure
	!				code (defined in MSCPDF.MAC) if BBR
	!				failed.  This byte is actually the
	!				low byte of BBRFLG.
	!		  71	BBR status flags.  This byte contains bits
	!				that show the exit status of BBR.
	!				This byte is actually the high byte
	!				of BBRFLG.
	!		  72	LBN being replaced.  If BBR failed, this LBN
	!				is a bad block.
	!		  76	Replacement block number
	!		  80	RBN being replaced (2 words)
	!
	!	NOTE: If the UDA bad block gets replaced successfully, offset
	!		72 contains that replacement block number. It is only
	!		when the replacement is not successful that there is
	!		actually a bad block, hence the flag in offset 70 to
	!		indicate that the replacement failed, thus making
	!		offset 72 a bad block.
	!
	! If the value of the SA register indicates a UDA hardware error,
	!  or if the packet length is zero, then we'll say that a packet was
	!  never generated.

	T$=NL
	T$="T" IF ER.TYP%=MU
	PRINT #7%, CRLF;CRLF;T$;"MSCP Description:";CRLF;LEFT(DASH$,17%)
	PRINT #7%, T$;"MSCP Packet Type";TAB(32%);PKT.TYP$(PKT%)
	IF PKT%=15%
		THEN	GOTO BBR_SPECIFICS
		ELSE	PRINT #7%, CRLF;T$;"MSCP Envelope";TAB(32%); &
			FNWORD$(PKT.LEN%);"   ";FNWORD$(F%(3%)+SWAP%(F%(4%)))
		END IF

	! Set up T$ depending on error type.
	! Print out the section heading and underline it.
	! Get the packet type descriptor and print it, too.
	! If no packet was generated, skip to the driver-specific stuff.
	! Otherwise, tell 'em the contents of the envelope.

	PRINT #7%, CRLF;T$;"MSCP Packet";TAB(32%);
	FOR I%=2% TO PKT.LEN% STEP 2%
	WORD%=F%(I%+3%)+SWAP%(F%(I%+4%))
	PRINT #7%, FNWORD$(WORD%);
	IF (I% AND 7%)
		THEN	PRINT #7%, "   ";
		ELSE	PRINT #7%, CRLF;TAB(32%);
	END IF
	! Step through F%(), making words out of bytes and printing them.
	! I% is used as a word index into F%(), so it counts by twos.
	! We start counting at two because the first two words of the packet
	!  are the byte count and message type, which are not really part of
	!  the packet.
	! If we've printed four across, then go to the next line,
	!  otherwise just print a few spaces and keep going.

	NEXT I%
	PRINT #7%
	PRINT #7%
	! Print the entire packet out.
	! Make sure we're back at the left margin - neatness counts,
	!  you know.

	IF PKT% THEN
		TBL%(I%)=PKT.ITEM%(PKT%,I%) &
			FOR I%=0% TO PKT.ITEM%(PKT%,0%)
		FOR I%=1% TO TBL%(0%)
		TEXT$=ITEM.DESC$(TBL%(I%))
		BYTE.OFFSET%=ASCII(MID(TEXT$,1%,1%))
		NUM.BYTES%=ASCII(MID(TEXT$,2%,1%))
		DISP.TYPE%=ASCII(MID(TEXT$,3%,1%))
		ANNOT.TYPE%=ASCII(MID(TEXT$,4%,1%))
		TEXT$=CVT$$(RIGHT(TEXT$,5%),4%+128%)
		PRINT #7%, TEXT$;TAB(32%);

		IF DISP.TYPE% THEN
			ON DISP.TYPE% GOSUB &
				OCTAL_BYTES_DISPLAY_SUBROUTINE, &
				OCTAL_WORDS_DISPLAY_SUBROUTINE, &
				DECIMAL_DISPLAY_SUBROUTINE, &
				HEXADECIMAL_DISPLAY_SUBROUTINE
		END IF

		IF ANNOT.TYPE% THEN
			ON ANNOT.TYPE% GOSUB &
				MESSAGE_FLAG_SUBROUTINE, &
				END_FLAG_SUBROUTINE, &
				END_CODE_SUBROUTINE, &
				STATUS_EVENT_CODE_SUBROUTINE, &
				UNIT_CLASS_SUBROUTINE, &
				CONTROLLER_MODEL_SUBROUTINE, &
				CONTROLLER_SW_VERSION_SUB, &
				UDA_INTERNAL_ERROR_CODE_SUB, &
				DRIVE_MODEL_SUBROUTINE, &
				LOGICAL_BLOCK_NUMBER_SUB, &
				SDI_ERROR_WORD1_SUBROUTINE, &
				SDI_ERROR_WORD2_SUBROUTINE, &
				DRIVE_ERROR_CODE_SUBROUTINE, &
				DRIVE_NUMBER_SUBROUTINE
			PRINT #7%, TAB(42%);ANNOT$;
		END IF

		PRINT #7%
		NEXT I%
	END IF
	! Skip this section if we don't know the packet type.
	! Read the details of which items to print into TBL%() -
	!  this will help cut down on disk accesses.
	! Get the details on the item to print.
	! START.BYTE% is the byte offset from the beginning of the packet.
	! NUM.BYTES% is the byte length of this item.
	! ANNOT.TYPE% is used to index the annotation subroutine.
	! TEXT$ is the text associated with this item.
	! Print it out so we know what we're up against.
	! Depending on how we want it displayed, go off to the right place.
	! Lines 11000-11400 are reserved for display formatting subroutines.
	! The values of DISP.TYPE% are as follows;
	!	0 = Do not display numeric value
	!	1 = Display as octal bytes
	!	2 = Display as octal words
	!	3 = Display as a decimal value
	!	4 = Display as a hexadecimal or BCD value
	!	5 = Reserved for future expansion
	! If we need to annotate it, do so.
	! ANNOT.TYPE% is read from ERRDAT.FIL and determines the proper
	!  subroutine for this data type.
	! By default, the annotation subroutines expect to have the values
	!  to be annotated in WORD% or BYTE%, and the annotation is returned
	!  in ANNOT$.
	! As new and exciting fields are added to the MSCP packet, the
	!  number and types of annotation routines will probably have to be
	!  increased.  To this end, lines 11500-12900 have been set aside for
	!  annotation subroutines.

 BBR_SPECIFICS:
	PRINT #7%, CRLF;CRLF;"Driver Related Data:";CRLF;LEFT(DASH$,20%)
	PRINT #7%, "Internal Control Status Word";TAB(32%); &
		FNWORD$(SWAP%(F%(66%))+F%(65%))
	PRINT #7%, "Internal Unit Status Word";TAB(32%); &
		FNWORD$(SWAP%(F%(68%))+F%(67%))
	BYTE%=SWAP%(F%(70%))+F%(69%)
	PRINT #7%, "Driver Error Code";TAB(32%);FNWORD$(BYTE%);TAB(42%);
	PRINT #7%, "Unknown" &
		IF BYTE%>31% OR BYTE%<0%
	PRINT #7%, DRIVER.ERROR.CODE$(BYTE%) &
		IF BYTE%>=0% AND BYTE%<=31%
	! Give Part I of the Driver Related Data.
	! This stuff will be printed for all [T]MSCP errors.

	IF BYTE%=1% AND ER.TYP%=DU THEN
		BYTE%=F%(71%)
		PRINT #7%, "BBR Failure Code";TAB(32%);FNBYTE$(BYTE%);TAB(42%);
		PRINT #7%, "Unknown" &
			IF BYTE%>31% OR BYTE%<0%
		PRINT #7%, BBR.FAIL.CODE$(BYTE%) &
			IF BYTE%>=0% AND BYTE%<=31%
		BYTE%=F%(72%)
		PRINT #7%, "BBR Flag Byte";TAB(32%);FNBYTE$(BYTE%);TAB(42%);
		GOSUB BBR_FLAG_SUBROUTINE
		PRINT #7%, ANNOT$
	END IF
	! Part II of the Driver Related Data is the BBR specific stuff.
	! We only need to print this if the 'Driver Error Code' is 1 (which
	!  says that the packet was generated by BBR), and the error type
	!  is 21 (MSCP).

	PRINT #7%
	RETURN
	! Go back for more.

	!
	!
	!	Here for bad block printouts.
	!
	!

 BAD_BLOCKS_SUBROUTINE:
	IF JSTBAD% 
		THEN 	IF F%(69%)=1% AND (F%(71%) AND 2%)=0% AND ER.TYP%=DU
			THEN Z%=FNBAD.CVT%
			BAD1%=BAD%
			BAD%=1% 
			GOSUB PRINT_BAD_BLOCKS_SUBROUTINE
			BAD%=BAD1%
			END IF
		END IF
 	! If bad blocks are wanted and all tests apply, then grab the BAD.
	! Get the LBN in decimal.
	! Save the old value of BAD%
	! Go print the bad block report.
	! Restore BAD%

	RETURN

	!
	!
	!	S U B R O U T I N E   T O   P R I N T    B A D   B L O C K S
	!
	!

 PRINT_BAD_BLOCKS_SUBROUTINE:
	NEW.BLK%=64%
	GOSUB CACHED_READ_SUBROUTINE
	Z%=FNREAD%(K%) FOR K%=0% TO 6%
	SAV$=NL
	FOR K%=7% TO 8%
		Z%=FNREAD%(K%)
		Z%=FNDUMP%(NAM$,OFF%(2%)+OF%,CNT%,COD%,2%)
		SAV$=SAV$+PBUF$
		SAV$=SAV$+S$ IF K%=8%
		SAV$=SAV$+CRLF
	NEXT K%
	Z%=FNDUMP%(NL,OFF%(4%),FLD.LEN%(4%),4%,2%)
	IF BAD% THEN
		PRINT #7%,SAV$;"Logical Block Number";TAB(32%);NUM1$(LBN);CRLF
		BAD.CNT%=BAD.CNT%+1%
	END IF
		! Get the block containing the descriptors for bad blocks.
		! Read through the first 7 descriptiors to get to "Logical
		!	Name" and "Physical Name"
		! Print them.
		! Print the LBN.
		! Increment the bad block count.

	RETURN

	!
	!
	!
	!	M S C P   A N N O T A T I O N   S U B R O U T I N E S
	!
	!

	!
	!
	!	Display a value as octal bytes
	!
	!

 OCTAL_BYTES_DISPLAY_SUBROUTINE:
	FOR J%=0% TO NUM.BYTES%-1%
	BYTE%=J%+BYTE.OFFSET%
	IF BYTE% AND 1%
		THEN	BYTE%=BYTE%+4%
		ELSE	BYTE%=BYTE%+6%
	END IF
	! Because the bytes are stored in swapped form, and because the MSCP
	!  envelope information (which is not technically part of the packet
	!  and thus is not counted in the offset value) is in the first four
	!  bytes of F%(), then we need to do some funny things with offsets
	!  to get the correct byte index.

	PRINT #7%, FNBYTE$(F%(BYTE%));" ";
	NEXT J%
	RETURN
	! Once we have the byte index, print out the byte.
	! Keep going 'till we're done.
	! Go back for more.

	!
	!
	!	Display a value as octal words
	!
	!

 OCTAL_WORDS_DISPLAY_SUBROUTINE:
	PRINT #7%, FNWORD$(F%(BYTE.OFFSET%+J%+5%)+ &
		SWAP%(F%(BYTE.OFFSET%+J%+6%)));" "; &
			FOR J%=0% TO NUM.BYTES%-2% STEP 2%
	RETURN

	!
	!
	!	Display a value as decimal
	!
	!

 DECIMAL_DISPLAY_SUBROUTINE:
	X%(J%)=0% &
		FOR J%=0% TO 4%
	X%(J%/2%)=F%(BYTE.OFFSET%+J%+5%)+SWAP%(F%(BYTE.OFFSET%+J%+6%)) &
		FOR J%=0% TO NUM.BYTES%-2% STEP 2%
	LOW.WORD%=X%(0%)
	MID.LOW.WORD%=X%(1%)
	MID.HIGH.WORD%=X%(2%)
	HIGH.WORD%=X%(3%)
	GOSUB DIVIDE_64_BIT_SUBROUTINE
	PRINT #7%, ANNOT$;".";
	RETURN
	! Put the words.

	!
	!
	!	Display a value as hexadecimal bytes
	!
	!

 HEXADECIMAL_DISPLAY_SUBROUTINE:
	FOR J%=0% TO NUM.BYTES%-1%
	BYTE%=J%+BYTE.OFFSET%
	IF BYTE% AND 1%
		THEN	BYTE%=BYTE%+4%
		ELSE	BYTE%=BYTE%+6%
	END IF
	! I'm not gonna go through this explanation again.  Please see
	! OCTAL_BYTES_DISPLAY_SUBROUTINE above.

	BYTE%=F%(BYTE%)
	PRINT #7%, CHR$(HEX.CHARS%(SWAP%(BYTE%*16%) AND 15%)); &
			CHR$(HEX.CHARS%(BYTE% AND 15%));" ";
	NEXT J%
	PRINT #7%," (Hex)";
	RETURN
	! Take the byte apart, and use each four bits as the index into
	!  HEX.CHARS%().
	! Print the hex/BCD values out.
	! When we're done, let 'em know it's hex.
	! Go back for more.

	!
	!
	!	M e s s a g e   F l a g   A n n o t a t i o n
	!
	!

 MESSAGE_FLAG_SUBROUTINE:
	BYTE%=F%(14%)
	ANNOT$=NL
	X%=128%
	FOR J%=7% TO 0% STEP -1%
	ANNOT$=ANNOT$+MESSAGE.FLAG$(J%)+"  " &
		IF BYTE% AND X%
	X%=X%/2%
	NEXT J%
	ANNOT$=CVT$$(ANNOT$,128%)
	RETURN

	!
	!
	!	E n d   F l a g   A n n o t a t i o n
	!
	!

 END_FLAG_SUBROUTINE:
	BYTE%=F%(14%)
	ANNOT$=NL
	X%=128%
	FOR J%=7% TO 0% STEP -1%
	ANNOT$=ANNOT$+END.FLAG$(J%)+"  " &
		IF BYTE% AND X%
	X%=X%/2%
	NEXT J%
	ANNOT$=CVT$$(ANNOT$,128%)
	RETURN

	!
	!
	!	E n d   C o d e   A n n o t a t i o n
	!
	!

 END_CODE_SUBROUTINE:
	BYTE%=F%(13%) AND 127%
	ANNOT$=CVT$$(END.CODE$(BYTE%),4%+128%)
	RETURN
	! Subtract 128 from the end code to get rid of the end flag.

	!
	!
	!	S t a t u s / E v e n t   C o d e   A n n o t a t i o n
	!
	!

 STATUS_EVENT_CODE_SUBROUTINE:
	WORD%=F%(15%)+SWAP%(F%(16%))
	BYTE%=STATUS.CODE.IDX%(0%)
	FOR J%=1% TO BYTE%
	GOTO END_STATUS_EVENT_CODE_SUB IF STATUS.CODE.IDX%(J%)=WORD%
	NEXT J%
 	ANNOT$="Unknown"
	RETURN

 END_STATUS_EVENT_CODE_SUB:
	ANNOT$=CVT$$(STATUS.CODE$(J%),4%+128%)
	RETURN

	!
	!
	!	U n i t   C l a s s   A n n o t a t i o n
	!
	!

 UNIT_CLASS_SUBROUTINE:
	IF BYTE.OFFSET% AND 1%
		THEN	BYTE%=BYTE.OFFSET%+4%
		ELSE	BYTE%=BYTE.OFFSET%+6%
	END IF
	! The odd/even beast strikes again!!

	BYTE%=F%(BYTE%)
	ANNOT$=CVT$$(UNIT.CLASS$(BYTE%),4%+128%)
	RETURN
	! Get it from the array and go back.

	!
	!
	!	C o n t r o l l e r   M o d e l   A n n o t a t i o n
	!
	!

 CONTROLLER_MODEL_SUBROUTINE:
	IF F%(25%)>=3% AND F%(23%)=2%
		THEN	F%(23%)=6%
	END IF
	! First, we check to see if it's an old UDA50-A.
	! If the S/W version is 3 or greater, then it's a UDA50-A,
	!  despite what the controller model byte says.

	ANNOT$=CVT$$(CONTROLLER.MODEL$(F%(23%)),4%+128%)
	RETURN
	! Get the model string from the array.
	! Go back.

	!
	!
	!	C o n t r o l l e r   S / W   V e r s i o n   A n n o t a t e
	!
	!

 CONTROLLER_SW_VERSION_SUB:
	BYTE%=F%(25%)
	J%=F%(23%)
	ANNOT$=NL
	ANNOT$="** Out of Revision!! **" &
		IF BYTE%<3% AND &
			(J%=2% OR J%=6%)
	RETURN
	! If the S/W version is less than 3, you've got a bogus device!!
	! Get your act together, buddy.

	!
	!
	!	U D A   I n t e r n a l   E r r o r   C o d e   A n n o t e
	!
	!

 UDA_INTERNAL_ERROR_CODE_SUB:
	WORD%=F%(27%)+SWAP%(F%(28%))
	ANNOT$=NL
	BYTE%=UDA.ERROR.CODE.IDX%(0%)
	FOR J%=1% TO BYTE%
	GOTO END_UDA_INTERNAL_ERROR_CODE_SUB IF UDA.ERROR.CODE.IDX%(J%)=WORD%
	NEXT J%
	J%=63%
	! Search through the list, looking for a match.
	! If none, use Code 63 (Unknown).

 END_UDA_INTERNAL_ERROR_CODE_SUB:
	ANNOT$=CVT$$(UDA.ERROR.CODE$(J%),4%+128%)
	RETURN

	!
	!
	!	D r i v e   M o d e l   A n n o t a t i o n
	!
	!

 DRIVE_MODEL_SUBROUTINE:
	BYTE%=F%(36%)-2%
		! Get the drive class code.

	IF BYTE% > DRIVE.MODEL.LIMIT THEN
		ANNOT$="Unknown"
		RETURN
	END IF
		! If the class code is out of range, then just
		!  return "Unknown".

	ANNOT$=CVT$$(DRIVE.MODEL$(BYTE%,F%(35%)),4%+128%)
	RETURN

	!
	!
	!	L o g i c a l   B l o c k   N u m b e r   S t u f f
	!
	!
	! Here, we perform magic with logical block numbers.  The LBN (or
	! the RBN) is a 32-bit number that is returned with an SDI Error or
	! Disk Transfer Error packet.  For RA60, RA80 and RA81 disks, we can
	! break this number down into a physical disk address (cylinder,
	! track and sector), which is useful.  Here we do this.
	!

 LOGICAL_BLOCK_NUMBER_SUB:
	BYTE%=F%(35%)
	ANNOT$=NL
	IF BYTE%<>1% AND BYTE%<>4% AND BYTE%<>5%
		THEN RETURN
	END IF
	! If we don't know how to figure the drive type, go back.

	LOW.LBN%=F%(BYTE.OFFSET%+5%)+SWAP%(F%(BYTE.OFFSET%+6%))
	HIGH.LBN%=F%(BYTE.OFFSET%+7%)+SWAP%(F%(BYTE.OFFSET%+8%))
	IF HIGH.LBN% AND (NOT 4095%)=16384%+8192%
		THEN	ANNOT$="(RBN)"
			RETURN
	END IF
	! Get the high and low LBNs.
	! If there's some bits set up top, it's an RBN.
	! Annotate it accordingly and go back.

	HIGH.LBN%=HIGH.LBN% AND 4095%
	ON BYTE% GOSUB RA80_ADDRESS,UNKNOWN_ADDRESS,UNKNOWN_ADDRESS, &
			RA60_ADDRESS,RA81_ADDRESS
	ANNOT$="Cyl "+NUM1$(CYL%)+"  Trk "+NUM1$(TRK%)+"  Sec "+NUM1$(SEC%)
	RETURN
	! Get the high and low LBN words.
	! Dispatch to the right place.
	! Build the annotation string and go back.

 RA80_ADDRESS:
	HIGH.WORD%=HIGH.LBN%
	LOW.WORD%=LOW.LBN%
	DIVISOR%=868%
	GOSUB DIVIDE_32_BIT_SUBROUTINE
	CYL%=LOW.WORD%
	GRP%=REMAINDER%/434%
	HIGH.WORD%=HIGH.LBN%
	LOW.WORD%=LOW.LBN%
	DIVISOR%=31%
	GOSUB DIVIDE_32_BIT_SUBROUTINE
	SEC%=REMAINDER%
	CYL%=CYL%*2%+GRP%
	HIGH.WORD%=HIGH.LBN%
	LOW.WORD%=LOW.LBN%
	DIVISOR%=434%
	GOSUB DIVIDE_32_BIT_SUBROUTINE
	TRK%=REMAINDER%/31%
	RETURN
	! RA80.

 RA60_ADDRESS:
	HIGH.WORD%=HIGH.LBN%
	LOW.WORD%=LOW.LBN%
	DIVISOR%=168%
	GOSUB DIVIDE_32_BIT_SUBROUTINE
	CYL%=LOW.WORD%
	GRP%=REMAINDER%/42%
	HIGH.WORD%=HIGH.LBN%
	LOW.WORD%=LOW.LBN%
	DIVISOR%=42%
	GOSUB DIVIDE_32_BIT_SUBROUTINE
	SEC%=REMAINDER%
	CYL%=((CYL%/6%)*4%)+GRP%
	TRK%=CYL%-((CYL%/6%)*6%)
	RETURN
	! RA60.

 RA81_ADDRESS:
	HIGH.WORD%=HIGH.LBN%
	LOW.WORD%=LOW.LBN%
	DIVISOR%=714%
	GOSUB DIVIDE_32_BIT_SUBROUTINE
	CYL%=LOW.WORD%
	TRK%=REMAINDER%/51%
	HIGH.WORD%=HIGH.LBN%
	LOW.WORD%=LOW.LBN%
	DIVISOR%=51%
	GOSUB DIVIDE_32_BIT_SUBROUTINE
	SEC%=REMAINDER%
	RETURN
	! RA81.

 UNKNOWN_ADDRESS:
	RETURN
	! Nothing for this one yet.

	!
	!
	!	S D I   E r r o r   W o r d   1   A n n o t a t i o n
	!
	!

 SDI_ERROR_WORD1_SUBROUTINE:
	WORD%=F%(49%)+SWAP%(F%(50%))
	ANNOT$=NL
	BYTE%=32767%+1%
	FOR J%=15% TO 0% STEP -1%
	ANNOT$=ANNOT$+CVT%$(SDI.STATUS.1%(J%))+" " &
		IF WORD% AND BYTE%
	BYTE%=(BYTE%/2%) AND 32767%
	NEXT J%
	ANNOT$=CVT$$(ANNOT$,128%)
	RETURN

	!
	!
	!	S D I   E r r o r   W o r d   2   A n n o t a t i o n
	!
	!

 SDI_ERROR_WORD2_SUBROUTINE:
	WORD%=F%(51%)+SWAP%(F%(52%))
	ANNOT$=NL
	BYTE%=32767%+1%
	FOR J%=15% TO 0% STEP -1%
	ANNOT$=ANNOT$+CVT%$(SDI.STATUS.2%(J%))+" " &
		IF WORD% AND BYTE%
	BYTE%=(BYTE%/2%) AND 32767%
	NEXT J%
	ANNOT$=CVT$$(ANNOT$,128%)
	RETURN

	!
	!
	!	D r i v e   E r r o r   C o d e   A n n o t a t i o n
	!
	!

 DRIVE_ERROR_CODE_SUBROUTINE:
	BYTE.OFFSET%=BYTE.OFFSET%+1% &
		IF F%(35%)<>4%
	ANNOT$="(See Service Manual for explanation)"
	GOTO HEXADECIMAL_DISPLAY_SUBROUTINE
	! If the drive is an RA60, we want Byte 54, otherwise use Byte 55.
	! Go print it out in Hex.

	!
	!
	!	M a k e   D r i v e   D e s c r i p t o r
	!
	!

 DRIVE_NUMBER_SUBROUTINE:
	WORD%=F%(BYTE.OFFSET%+5%)+SWAP%(F%(BYTE.OFFSET%+6%))

	IF WORD%<0% OR WORD%>15% THEN
		ANNOT$="Unknown"
		RETURN
	END IF
	!	Only drive numbers 0-15 are legal.

	IF ER.TYP%=MU &
		THEN	ANNOT$="MU"
		ELSE	ANNOT$="DU"
	END IF
	!	Decide whether to call it MU or DU.

	ANNOT$=ANNOT$+NUM1$(WORD%)+":"
	RETURN
	!	Construct the whole device name and go back.

	!
	!
	!	B B R   F l a g   B y t e   B i t   A n n o t a t i o n
	!
	!

 BBR_FLAG_SUBROUTINE:
	ANNOT$=NL
	WORD%=128%
	FOR J%=7% TO 0% STEP -1%
	ANNOT$=ANNOT$+BBR.FLAG.CODE$(J%)+" " &
		IF BYTE% AND WORD%
	WORD%=(WORD%/2%)
	NEXT J%
	ANNOT$=CVT$$(ANNOT$,128%)
	ANNOT$="BBR NOT SUCCESSFUL "+ANNOT$ UNLESS (BYTE% AND 1%)
	RETURN

	!
	!
	!	I N D I V I D U A L    F I E L D    S E T U P
	!
	!

 IND_FIELD_SETUP_SUBROUTINE:
	FLD.LEN%(I%)=0% FOR I%=1% TO 8%
	FIELD #5%,(PRV%+22%) AS D$,(LN%-22%) AS REST$
	OFF%=PRV%+22%+2%
	FOR I%=1% TO LAST.FIELD%
		FLD.LEN%(I%)=(SWAP%(CVT$%(REST$)) AND 255%)*2%
		PART$(I%)=MID(REST$,3%,FLD.LEN%(I%)) IF FLD.LEN%(I%)>0%
		OFF%(I%)=OFF%
		OFF%=OFF%+FLD.LEN%(I%)+2%
		REST$=RIGHT(REST$,FLD.LEN%(I%)+3%)
	NEXT I%
	RETURN
		! Field this error record, bumping past the 2 byte length
		! header, the 20 byte parameter field and all previous error
		! records.
		! Set up the offset to be used for FNDUMP%() calls.
		! For 1 to the last field # in this record (minimum of 2):
		!	from the 2 byte header before each field, get
		!	the length of the actual data portion of the field.
		!	peel off the field - this is needed by certain
		!	routines, e.g., for extracting explicit disk
		!	unit #'s.
		!	Save the offset.
		!	Bump the offset for the next field.
		!	Point to the beginning of the next field.

	!
	!
	!	C a c h e d   R e a d   S u b r o u t i n e
	!
	! This subroutine is used to read a record from ERRDAT.FIL.  It keeps
	! track of the last block read, and will not read a new block unless
	! necessary.
	!

 CACHED_READ_SUBROUTINE:
	RETURN IF NEW.BLK%=LAST.READ.BLK%
	GET #2%, RECORD NEW.BLK%
	LAST.READ.BLK%=NEW.BLK%
	RETURN
	! Check to see if we've already got it.
	! If so, just go back.
	! If not, get it again.
	! Update our stuff and go back.

	!
	!
	!	3 2 - B I T   D I V I D E
	!
	!
	! This routine will divide a 32-bit unsigned number by a 16-bit
	! unsigned integer, and produce an unsigned 32-bit integer result,
	! with an unsigned 16-bit remainder.
	!
	!
	! INPUTS:	HIGH.WORD%	= High order dividend
	!		LOW.WORD%	= Low order dividend
	!		DIVISOR%	= Divisor
	!
	! OUTPUTS:	HIGH.WORD%	= High order result
	!		LOW.WORD%	= Low order result 
	!		REMAINDER%	= Remainder


 DIVIDE_32_BIT_SUBROUTINE:
	DIV.EQV%=DIVISOR% EQV 32767%
	REMAINDER%=0%
	FOR K%=1% TO 32%
	CARRY.LOW%=(LOW.WORD%<0%) AND 1%
	CARRY.HIGH%=(HIGH.WORD%<0%) AND 1%
	LOW.WORD%=LOW.WORD%*2%
	HIGH.WORD%=HIGH.WORD%*2%+CARRY.LOW%
	REMAINDER%=REMAINDER%*2%+CARRY.HIGH%
	IF (REMAINDER% EQV 32767%)>=DIV.EQV% THEN
		REMAINDER%=REMAINDER%-DIVISOR%
		LOW.WORD%=LOW.WORD%+1%
	END IF
	! Start with a clean remainder.
	! Here, we perform a multiple-word shift.
	! Find out if there will be a carry from either the low- or high-
	!  order words of the dividend.
	! Shift the low-order word left 1 bit.
	! Shift the high-order word next, adding any carry that may have been
	!  generated from the low-order word.
	! Finally, shift the remainder, adding any carry that came from the
	!  high-order word.
	! Compare the remainder and divisor, ignoring the sign.
	! If the remainder is greater than the divisor, subtract the divisor.
	! Increment the low-order dividend word; notice that after 32 shifts,
	!  this will become the low-order result.

	NEXT K%
	RETURN
	! Do this 32 times, and we'll be all done.

	!
	!
	!	6 4 - B I T   D E C I M A L   O U T P U T   R O U T I N E
	!
	!
	! This routine accepts a 64-bit binary argument, passed as 4 16-bit
	! integers, and produces a string that represents the decimal value
	! of the arguments.
	!
	!
	! INPUTS:	HIGH.WORD%	= High order dividend
	!		MID.HIGH.WORD%	= High order middle dividend
	!		MID.LOW.WORD%	= Low order middle dividend
	!		LOW.WORD%	= Low order dividend
	!
	! OUTPUTS:	ANNOT$		= Returned string
	!
	!

 DIVIDE_64_BIT_SUBROUTINE:
	ANNOT$=NL
	Y$="    "

 DIVISION_COMPUTATION:
	REMAINDER%=0%
	FOR K%=1% TO 64%
	CARRY.LOW%=(LOW.WORD%<0%) AND 1%
	CARRY.MID.LOW%=(MID.LOW.WORD%<0%) AND 1%
	CARRY.MID.HIGH%=(MID.HIGH.WORD%<0%) AND 1%
	CARRY.HIGH%=(HIGH.WORD%<0%) AND 1%
	LOW.WORD%=LOW.WORD%*2%
	MID.LOW.WORD%=MID.LOW.WORD%*2%+CARRY.LOW%
	MID.HIGH.WORD%=MID.HIGH.WORD%*2%+CARRY.MID.LOW%
	HIGH.WORD%=HIGH.WORD%*2%+CARRY.MID.HIGH%
	REMAINDER%=REMAINDER%*2%+CARRY.HIGH%
	IF (REMAINDER% EQV 32767%) >= -22768% THEN
		REMAINDER%=REMAINDER%-10000%
		LOW.WORD%=LOW.WORD%+1%
	END IF
	! Start with a clean remainder.
	! Here, we perform a multiple-word shift.
	! Find out if there will be a carry from either the low- or high-
	!  order words of the dividend.
	! Shift the low-order word left 1 bit.
	! Shift the high-order word next, adding any carry that may have been
	!  generated from the low-order word.
	! Finally, shift the remainder, adding any carry that came from the
	!  high-order word.
	! Compare the remainder and divisor, ignoring the sign.
	! If the remainder is greater than the divisor, subtract the divisor.
	! Increment the low-order dividend word; notice that after 32 shifts,
	!  this will become the low-order result.

	NEXT K%
	X$=NUM1$(REMAINDER%)
	IF HIGH.WORD% OR MID.HIGH.WORD% OR MID.LOW.WORD% OR LOW.WORD%
		THEN	RSET Y$="000"+X$
			ANNOT$=Y$+ANNOT$
			GOTO DIVISION_COMPUTATION
	END IF

	! Change the remainder to a string.
	! If there's any more bits left, we'll go back.
	! First, tack on some leading zeroes.
	! Add it to the existing string.

	ANNOT$=X$+ANNOT$
	RETURN

	!
	!
	!
	!	F U N C T I O N S
	!
	!

	! 
	!
	!
	!	E R R O R   E X P L O S I O N   F U N C T I O N 
	!
	!

15000	DEF	FNERROR.EXPLODE%(PNT%)
	CURRENT.REG%=-1% 
	IF PNT%<=20% THEN
		FIELD #2%, (14%*PNT%)+208% AS D$, 2% AS ADDR$, 12% AS BIT.DSC$
		ADDR%=CVT$%(ADDR$)
		IF ADDR%<>32767% THEN
			CURRENT.REG%=SWAP%(ADDR%) AND 31%
			MASK%=2%^(ADDR% AND 15%)
			PRNT.IF.CLR%=ADDR% AND 128%
			PNT%=PNT%+1%
		END IF
	END IF
		! Only 21 (0-20) bit specifications are allowed.
		! Field the error descriptor record.
		! Convert address - 32767 indicates we're out of real
		! bit descriptors.
		! Get register # (high byte),
		!  set proper mask bit on (from low byte,which will
		!  be 0-15).
		! 128 bit indicates if we should print the descriptor
		!   if the bit is clear rather than set
		!   bump pointer.

	FNERROR.EXPLODE%=PNT%
		! Pass the new value of the pointer (PNT%) back.
	FNEND

15100	DEF	FNPACKET.TYPE%(X%)
	! Function:		FNPACKET.TYPE%
	!			Determine Packet Type for a [T]MSCP packet
	!
	! Parameter:		Ignored.
	!
	! Value returned:	[T]MSCP Packet Type -
	!			0 = Unknown
	!			1 = End Message Packet
	!			2 = Last Fail Packet
	!			3 = Controller Error Packet
	!			4 = Host Memory Access Error Packet
	!			5 = Disk Transfer Error Packet
	!			6 = SDI (Standard Disk Interface) Error Packet
	!			7 = Small Disk Error Packet
	!			8 = Tape Transfer Error Packet
	!			9 = STI Communication or Command Fail Packet
	!			10= STI Drive Error Log Packet
	!			11= STI Formatter Error Log Packet
	!			12= Bad Block Replacement Attempt Packet
	!			13= Media Loader Error Packet
	!
	! This function uses F%(), and assumes that it contains
	! the MSCP error information.
	!

	MSG.TYP%=(F%(3%)+SWAP%(F%(4%))) AND 240%
	FNPACKET.TYPE%=0%
	IF MSG.TYP%=0% THEN
		FNPACKET.TYPE%=1%
		EXIT DEF
	END IF

	! Get the second word of the envelope.
	! Ignore all but the relevant bits.
	! If it's 0, then we've got an end packet - No need to look further.

	EXIT DEF IF MSG.TYP%<>16%
	FORMAT.CODE%=F%(13%)
	STATUS.CODE%=F%(15%)+SWAP%(F%(16%))
	IF FORMAT.CODE%=0% AND STATUS.CODE%=10% THEN
		FNPACKET.TYPE%=2%
		EXIT DEF
	END IF

	! If it's not 0, then it should be 16 (20 octal).
	! If not, we've got a problem - let 'em know and leave.
	! This might be a 'Last Fail' packet -
	!  check the Format Code and Status/Event Code to find out.

	IF FORMAT.CODE%>=0% AND FORMAT.CODE%<=10% THEN
		FNPACKET.TYPE%=FORMAT.CODE%+3%
	END IF

	! If it's in the range 0-10, then it's a legal Format Code.
	! Mangle it for our purposes and go on.

	END DEF
	! That's all, folks !!

15200	DEF FNBYTE$(Q%)
	! Function:		FNBYTE$(Q%)
	!			Convert low byte of Q% to a string which
	!			represents it's octal value
	! Parameter:		Q%
	!			An integer value
	! Data returned:	A three-character string representing the
	!			octal value of the low byte of Q%
	!

	Q%=Q% AND 255%
	Q0%=64%
	Q$=NL
	WHILE Q0%>0%
		Q1%=Q%/Q0%
		Q%=Q%-Q0%*Q1%
		Q0%=Q0%/8%
		Q$=Q$+CHR$(48%+Q1%)
	NEXT
	FNBYTE$=Q$
	FNEND
	! Convert the number to octal, saving each digit.
	! Not too bad, eh?

15300	DEF FNWORD$(Q%)
	! FUNCTION	FNO$		Get a 6 position octal string
	! PARAMETER	Q%		number to convert to octal

	Q$="0"
	Q0%=4096%
	IF Q%<0% THEN
		Q$="1"
		Q%=Q%+32767%+1%
	END IF

	WHILE Q0%>0%
		Q1%=Q%/Q0%
		Q%=Q%-Q0%*Q1%
		Q0%=Q0%/8%
		Q$=Q$+CHR$(48%+Q1%)
	NEXT
	FNWORD$=Q$
	FNEND
		! Convert the number to octal, saving each digit.
		! Set the function.

	!
	!
	!	F O R M A T   A N D   P R I N T   E R R O R S 
	!
	!

16000	DEF FNDUMP%(TITLE$, OFST%, LGT%, CODE%, SKIP%)
	! FUNCTION	FNDUMP%		Extract and convert data
	! PARAMETERS	TITLE$		Title to be printed at left
	!				column
	!		OFST%		Start of data to be formatted in
	!				buffer 5.
	!		LGT%		Number of bytes of data to be
	!				formatted
	!		CODE%		Type of extraction/conversion
	!				   to be done
	!					1=Octal
	!					2=RAD50
	!					3=ASCII
	!					4=Register contents
	!					5=Decimal byte (unsigned)
	!					6=Decimal word (unsigned)
	!		SKIP%		Directs whether we should remain
	!				on the same print line after
	!				dumping what's been converted
	!				SKIP%=0  stay on the same line
	!				SKIP%=1% print, jump a line
	!				SKIP%=2% don't print
	!
	! For modes 1-3 and 5 title is printed at left margin.
	! Formatted data starts at column 25.
	! Octal data is printed 4 words per line additional lines if
	! required are printed without title starting at column 25.
	!
	! Utilitizes file "ERRDAT.FIL" to expand printout to include
	! char. register name, octal contents and up to 4-12 byte
	! bit descriptors.

	FNDUMP%=1%
	FIELD #5%, OFST% AS D$, LGT% AS CBUF$
	PBUF$=TITLE$
	GOTO PRINT_LAST_BUFFER UNLESS LGT%
	PBUF$=PBUF$+SPACE$(32%-LEN(PBUF$))
	ON CODE% GOTO OCTAL_FORMATTING,RAD50_FORMATTING,ASCII_FORMATTING, &
		REGISTER_CONTENTS_FORMATTING,DECIMAL_FORMAT,DECIMAL_FORMAT
		! Left justify title in print buffer.
		! Go and print if # of bytes=0
		! Tab out to align columns.
		! On desired code goto
		!	Octal, RAD50, ASCII, register contents, decimal.

 OCTAL_FORMATTING:
	IF LGT%=1% THEN
		PBUF$=PBUF$+FNBYTE$(SWAP%(CVT$%(CBUF$)))
		GOTO PRINT_LAST_BUFFER
	END IF
		!
		!
		!	O C T A L   F O R M A T   S E C T I O N
		!
		!
		! Just doing 1 byte - right justify

	ACC$,FILE$=NL
	IF CVT$$(TITLE$,2%)="FCB" THEN
		D1%=CVT$%(MID(CBUF$,5%,2%))
		ACC$="["+NUM1$(D1% AND 255%) &
			+","+NUM1$(SWAP%(D1%) AND 255%)+"]"
		FILE$=FILE$+RAD$(SWAP%(CVT$%(MID(CBUF$,D1%,2%)))) &
					FOR D1%=7% TO 9% STEP 2%
		FILE$=FILE$+"."+RAD$(SWAP%(CVT$%(MID(CBUF$,11%,2%))))
		FILE$=CVT$$(FILE$,2%)
	END IF
	!
	! If we're listing the "FCB", extract the account number
	! and filename.

	FOR D1%=1% TO LGT%-1% STEP 2%
	PBUF$=PBUF$+FNWORD$(SWAP%(CVT$%(MID(CBUF$,D1%,2%))))+ &
				SPACE$(2%+2*(SKIP%=0%))
		IF LEN(PBUF$)>62% THEN
				PBUF$=PBUF$+ACC$ IF D1%=7%
			PBUF$=PBUF$+FILE$ IF D1%=15%
			DASH.FLAG%=FNPRT%(PBUF$,SKIP%,DASH.FLAG%,LGT%)
			PBUF$=SPACE$(32%)
		END IF
		! Convert to octal two bytes at a time
		! If buffer gets full then
		!	print and space fill 24 bytes.
		! Since FNPRT% returns a zero, DASH.FLAG% will be cleared
		!  after FNPRT% is executed.

	NEXT D1%
	GOTO PRINT_LAST_BUFFER
		! Dump the last print buffer.

 RAD50_FORMATTING:
	PBUF$=PBUF$+RAD$(SWAP%(CVT$%(MID(CBUF$,D1%,2%)))) &
		FOR D1%=1% TO LGT%-1% STEP 2%
	GOTO PRINT_LAST_BUFFER
		!
		!
		!	R A D 5 0   F O R M A T   S E C T I O N
		!
		!
		! Convert RAD50 word to ASCII string.
		! Go and print.

 DECIMAL_FORMAT:
	D1%=SWAP%(CVT$%(CBUF$))
	D1%=(D1% AND 255%) IF CODE%=5%
	PBUF$=PBUF$+NUM1$((D1% EQV 32767%)+32768.)
	GOTO PRINT_LAST_BUFFER
		!
		!
		!	D E C I M A L
		!
		! Get value of entire word.
		! If they only want lower byte displayed, clear out upper byte.
		! Make it unsigned, and convert to ASCII.

 ASCII_FORMATTING:
	IF CBUF$="XM" OR CBUF$="XD" THEN
		DDCU$ = "DM"
		PRNT.UNIT%=0%
		DDFLAG% = SWAP%(CVT$%(MID(PART$(2%),17%,2%)))
		UNIT.NO% = F%(5%)
		GOTO XD_DEVICE IF CBUF$ = "XD"
		IF DDFLAG% AND 128% THEN
			DDCU$ = DDCU$+"R"
		ELSE
			DDCU$ = DDCU$+"C"
		END IF
	
		DDCU$ = DDCU$+"-"+NUM1$(UNIT.NO%) IF F%(6%)
		GOTO SET_VARIABLES
			!
			! Set the print unit number flag off.
	 		! Get DDFLAG word out of the DDB.
			! Skip if we have an "XD" typed device.
			! Otherwise make the physical name DMC
			! or DMR and add the unit # if supplied.
			!

 XD_DEVICE:
		IF DDFLAG% AND 128% THEN
			DDCU$ = DDCU$+"V"
		ELSE
			DDCU$ = DDCU$+"P"
		END IF
			!
			! If the 8th bit is set we have a DMV
			! otherwise it's a DMP.
			!

		GOTO SET_VARIABLES UNLESS F%(6%)
		DDIDX% = SWAP%(CVT$%(MID(PART$(2%),9%,2%))) AND 255%
		I% = FNT3%(DDIDX%) UNLESS TABLE3%
		TABLE3% = -1%
		UNIT.CNT% = 0%
		FOR CNTRLR.NO% = 0% TO CNTRLR.MAX%-1%
			I% = PEEK(UCTTBL%+(CNTRLR.NO%*2%))
		IF (UNIT.CNT%+(I%-1%)) < UNIT.NO% THEN 
				UNIT.CNT% = UNIT.CNT%+I%
			ELSE
				DDCU$ = DDCU$+"-"+NUM1$(CNTRLR.NO%)+"."+ &
					NUM1$(UNIT.NO%-UNIT.CNT%)
				GOTO SET_VARIABLES
			END IF
	
		NEXT CNTRLR.NO%
		DDCU$ = CBUF$
		PRNT.UNIT%=-1%
			!
			! Skip the controller #+unit # search if no unit
			! number was supplied.
			! Get the driver index for the XD device from the DDB.
			! Obtain pointers to the DDCTBL and UCTTBL tables.
			! Get the number of units for controller CNTRLR.NO%.
			! If the accumulated number of units+the number of 
			! units-1
			! For this controller is less than the unit number then
			!	add the number of units to the accumulated total
			!	and try again.
			! else
			!	form the DDCU style name using the controller 
			!	number and unit number-accumulated unit count.
			!	and return.
			! If we've reached the end of the line and have yet to
			! to exceed or equal the unit number something is wrong.
			! return at least the old form of physical name and set
			! the print unit number flag on.
			!

 SET_VARIABLES:
		PBUF$ = PBUF$+DDCU$
		PBUF$ = PBUF$+CRLF UNLESS PRNT.UNIT%
		GOTO PRINT_LAST_BUFFER
	END IF
		!
		! GET THE DDCU DEVICE FORMAT IF WE HAVE A COMM. DEVICE
		!

	IF LEN(CBUF$)>62% THEN
		PBUF$=PBUF$+LEFT(CBUF$,62%)
		CBUF$=RIGHT(CBUF$,63%)
		DASH.FLAG%=FNPRT%(PBUF$,SKIP%,DASH.FLAG%,LGT%)
		PBUF$=SPACE$(32%)
		GOTO ASCII_FORMATTING
	END IF

		!
		!
		!	A S C I I    F O R M A T    S E C T I O N
		!
		!
		! Strip off and print 64 char lines of ASCII data.
		! Always start at column 32.

	PBUF$=PBUF$+CBUF$
	GOTO PRINT_LAST_BUFFER
		! Append on ASCII data and go print the last buffer.
		! Exit function.

	!
	!
	!
	!	R E G I S T E R   C O N T E N T S   F O R M A T T I N G
	!
	!

 REGISTER_CONTENTS_FORMATTING:
	DASH.FLAG%=FNPRT%(PBUF$,SKIP%,DASH.FLAG%,LGT%) UNLESS JSTBAD%
		!Since FNPRT% returns a zero, DASH.FLAG% will be cleared
		! after FNPRT% is executed.
	PNT%,RK06ER%,RM03ER%=0%
	IF ER.TYP%<>DU
		THEN IF BAD% OR SPECIAL% THEN
			NEW.BLK%=67%
			IF LAST.READ.BLK% <> 67% THEN
				GET #2%, BLOCK 67%
				LAST.READ.BLK% = 67%
			END IF
		! Duplicate of CACHED READ ROUTINE only basic plus two will 
		! not allow you to call a subtroutine out of a function.
		K%=0%
		WHILE F%(0%)<>ER.TYP%
			K%=K%+1%
			Z%=FNREAD%(K%)
			F%(I%)=CVT$%(RIGHT(NAM$,I%*2%+1%)) &
				FOR I%=0% TO 8%
		NEXT
		END IF
	END IF
		! Print the title.
		! Initialize bit pointer and 'bad sector' flags
		! For RK06 AND RM03 (***automatic bad block if bad
		! sector is indicated after scan***).
		! Make sure that this is not a UDA error
		! If there is a chance we have a bad block then
		!	get to the beginning of the bad block info.
		!	Get the proper error type info:
		!	F%()	MEANING
		!	0	ER.TYP%
		!	1	Error register # (e.g., RKER)
		!	2	Error register bits to check
		!	3	Control/status register (e.g., RKCS)
		!	4	Function (command) mask
		!	5-8	Things to check for (e.g.,data check)

	NEW.BLK%=ER.TYP%+1%
	IF LAST.READ.BLK% <> NEW.BLK% THEN
		GET #2%, BLOCK NEW.BLK%
		LAST.READ.BLK% = NEW.BLK%
	END IF
	PNT%=FNERROR.EXPLODE%(PNT%)
	FOR REG%=0% TO LGT%/2%-1%
		EXIT DEF IF ((REG%+1%)*2%)>LEN(CBUF$)
		FIELD #2%, (8%*REG%)+16% AS D$, 8% AS REG.DSC$
		EXIT DEF IF REG.DSC$="99999999"
		REG.DSC$=S2$+LEFT(REG.DSC$,3%)+S0$ IF ER.TYP%=KT AND (REG%>0%)
		IF ER.TYP%=PA AND REG%=6% THEN
			TEMP%=SWAP%(CVT$%(MID(CBUF$,(REG%*2%)+1%,2%)))
			GOTO NEXT_REGISTER IF TEMP%=CTENTS%
		END IF
		! LGT% is the number of bytes in FLD.LEN(4%)
		! Get out of the loop and goto the function end if:
		!	1. There are no more register contents.
		!	2. There are no more register descriptions.

		CTENTS%=SWAP%(CVT$%(MID(CBUF$,(REG%*2%)+1%,2%)))
		PBUF$=REG.DSC$+"  "+FNWORD$(CTENTS%)
		PBUF$=PBUF$+SPACE$(32%-LEN(PBUF$))
		IF ER.TYP%=DU OR ER.TYP%=MU
		THEN	SA%=CTENTS%
			SA%=0% IF SA%>0% OR ((SA% AND 32767%)>30%)
			SA%=31% IF SA%=(32767%+1%)
			PBUF$=PBUF$+SA.ERROR.CODE$(SA% AND 32767%)
			GOTO PRINT_LAST_BUFFER
		END IF
		! Put the register description and contents into PBUF$.
		! If it's a UDA error, get the contents of the SA register.
		! If the contents are positive, or the bottom 15 bits are 
		!  greater than 30, then we don't know about this error - 
		!  call it Unknown.
		! If only the sign bit is set, it's a generic UDA error, 
		!  so tell 'em.

		PBUF$=PBUF$+"Extended Address " IF ER.TYP%=PA AND REG%=6%
		RK06ER%=(CTENTS% AND 128%) IF REG%=6% AND ER.TYP%=DM
		RM03ER%=(CTENTS% AND (32767%+1%)) IF REG%=16% AND ER.TYP%=DR
		IF BAD% AND (REG%=F%(3%)) THEN
			FUN%=(CTENTS% AND F%(4%))
			GOTO DEVICE_SPECIFIC_REGISTER_FMT &
				IF FUN%=F%(I%) FOR I%=5% TO 8%
			BAD%=0%
		END IF
		! Take care of some exceptions.

 DEVICE_SPECIFIC_REGISTER_FMT:
		BAD%=0% UNLESS (CTENTS% AND F%(2%)) IF BAD% AND (F%(1%)=REG%)
		IF JSTBAD% THEN
			EXIT DEF UNLESS SPECIAL% IF BAD%=0%
			GOTO NEXT_REGISTER
		END IF

		IF ER.TYP%=DB AND REG%=10% THEN
			Z0%=(CTENTS% AND 255%)
			S0$=NL
			S0$="RP04" IF Z0%=16%
			S0$="RP05" IF Z0%=17%
			S0$="RP06" IF Z0%=18%
			PBUF$=PBUF$+S0$+SPACE$(9%)
		END IF

		IF ER.TYP%=DR AND REG%=10% THEN
			Z0%=(CTENTS% AND 255%)
			S0$=NL
			S0$="RM02" IF Z0%=21%
			S0$="RM03" IF Z0%=20%
			S0$="RM05" IF Z0%=23%
			S0$="RP07" IF Z0%=34%
			PBUF$=PBUF$+S0$+SPACE$(9%)
		END IF

		IF ER.TYP%=TS AND REG%=8% THEN
			PBUF$=PBUF$+"TC "+NUM1$((CTENTS% AND 14%)/2%)+"  "
			IF CTENTS%<0% THEN
				PBUF$=PBUF$+"FC "+NUM1$((CTENTS% AND 48%)/16%) &
				+"  "
			END IF
		END IF
		! TS11 - add on termination class bits and fatal termination
		! class bits.

 PRINT_REGISTER_CONTENTS:
		GOTO FINISH_REGISTER_PRINTING IF CURRENT.REG%<>REG%
		IF (MASK% AND CTENTS%) THEN
			PBUF$=PBUF$+BIT.DSC$+SPACE$(1%) IF PRNT.IF.CLR%=0%
		ELSE	PBUF$=PBUF$+BIT.DSC$+SPACE$(1%) IF PRNT.IF.CLR%<>0%
		END IF

		PNT%=FNERROR.EXPLODE%(PNT%)
		IF LEN(PBUF$)<62% THEN
			GOTO PRINT_REGISTER_CONTENTS
		ELSE	DASH.FLAG%=FNPRT%(PBUF$,SKIP%,DASH.FLAG%,LGT%)
			PBUF$=SPACE$(32%)
			GOTO PRINT_REGISTER_CONTENTS
		END IF

 FINISH_REGISTER_PRINTING:
 		DASH.FLAG%=FNPRT%(PBUF$,SKIP%,DASH.FLAG%,LGT%)
		IF ER.TYP%=KT AND (REG%=0%) THEN
			S2$="U"
			S2$="S" IF (CTENTS% AND 64%+32%)=32%
			S2$="K" IF (CTENTS% AND 64%+32%)=0%
			S2$=S2$+"D" IF (CTENTS% AND 16%)=16%
			S2$=S2$+"I" IF (CTENTS% AND 16%)=0%
			S0$=NUM1$((CTENTS% AND 14%)/2%)+"  "
		END IF

 NEXT_REGISTER:
	NEXT REG%
	BAD%=-1% IF RK06ER% OR RM03ER%
	PRINT #7%,AST$;CRLF; &
			"Possible Bad Block - Logical Block #";LBN;CRLF;AST$ &
		IF BAD% IF JSTBAD%=0%
	EXIT DEF
		! Make sure we're at the correct record
		! Get 1st error bit descriptor.
		! Step through a maximum of 24 (0-23) registers
		! as follows:
		!	Exit if we're out of register contents to process.
		!	Field the register descriptor record to extract
		!	the registor name - put this and the register
		!	contents obtained from the error record into the
		!	print buffer.
		!	Get out if we have the next reg #.
		!	If the specified bit was on then
		!		tack on the bit	description unless 'print
		!		if clear' flag is set.
		!	If the specified bit was not on then
		!		tack on descriptor if 'print if clear' set.
		!	Jump to a new print line if this one has no more room.
		!	Note that memory mgmt. errors (type 8) must take care
		!	  of USER/SUPERVISOR/KERNEL registers.
		!	Print bad block info if "bad blocks only".

 PRINT_LAST_BUFFER:
	DASH.FLAG%=FNPRT%(PBUF$,SKIP%,DASH.FLAG%,LGT%)
		! Dump the last buffer when necessary.

	FNEND


16100	DEF FNPRT%(A$,SKIP%,DASH.FLAG%,LGT%)
	! FUNCTION	FNPRT%	Print a string
	! PARAMETERS	A$	String to print
	!
	! SKIP%=0	Stay on the same line
	! SKIP%=1%	Print and jump to the next line
	! SKIP%=2%	Don't print at all (for just listing bad blocks)

	GOTO END_FUNCTION_PRINT IF A$=SPACE$(LEN(A$))
	A$=CVT$$(A$,128%) IF LGT%=0%
	IF SKIP%=0% THEN
		PRINT #7%,A$;
	ELSE	IF SKIP%=1% THEN
			PRINT #7%,A$
		END IF
	END IF
		! Set the function
		! If the buffer is empty, don't print.
		! Print the buffer, remaining on the same line or
		!   jumping to the next as directed by 'skip'.

	PRINT #7%, ANOTHER.DASH$ IF DASH.FLAG%
		! Underlines the title, but only if DASH.FLAG% is set
		!    DASH.FLAG% is set only for the headers of fields 3 and 4.

 END_FUNCTION_PRINT:
	FNPRT%=0%
 	FNEND

16200	DEF FNEXT%(Q%)=CVT$%(RIGHT(S$,Q%))
		! Get some stuff out of the core common string.

16300	DEF FNTIM2$(T1%,T2%)
	! FUNCTION	FNTIM2$		Get time string of the form
	!				HH:MM:SS

	Q$=TIME$(T1%)
	T2%=60% IF T2%=0%
	Q$=LEFT(Q$,5%)+":"+RIGHT(NUM1$(100%+60%-T2%),2%)+ &
		RIGHT(Q$,6%)
	FNTIM2$=Q$
	FNEND
		! Get the 'normal' time string and tack on
		!   seconds before the next minute.

16400	DEF FNN$(S%,N%)
	N$=NUM$((N% EQV 32767%)+32768.)
	FNN$=SPACE$(S%-LEN(N$))+N$
	FNEND
		! Left pad a numeric (positive) string with spaces.

16500	DEF FNREAD%(R%)
	R% = R% - 16% IF R% >= 16%
	FIELD #2%, 32%*R% AS Z$,24% AS NAM$, 2% AS OF$, 2% AS CNT$, &
			 2% AS COD$, 2% AS SKP$
	OF%=CVT$%(OF$)
	CNT%=CVT$%(CNT$)
	COD%=CVT$%(COD$)
	SKP%=CVT$%(SKP$)
	FNREAD%=0%
	FNEND
		! This function gets the R%+1TH set of data out of the
		! channel 2 buffer.

16600	DEF FNT3%(DDIDX%)
	!
	! FUNCTION GETS MONITOR TABLE PART III.
	!
	! INPUTS	DDIDX%	= Driver index
	!
	! RETURNS	DDCTBL%	= pointer to the DDCTBL table
	!		UCTTBL%	= pointer into the UCTTBL table
	!		CNTRLR.MAX% = number of controllers
	!
	! NO ERRORS POSSIBLE
	!

	CHANGE SYS(CHR$(6%)+CHR$(-29%)) TO M%
	DDCTBL% = M%(3%)+SWAP%(M%(4%))
	UCTTBL% = M%(5%)+SWAP%(M%(6%))
	I% = PEEK(DDCTBL%+DDIDX%)
	OFFSET% = SWAP%(I%) AND 255%
	CNTRLR.MAX% = I% AND 255%
	UCTTBL% = UCTTBL%+OFFSET%
	!
	! Get the offset into the UCTTBL and the number of
	! controllers from the DDCTBL table.
	! Update the UCTTBL pointer to point to the first
	! unit count for this device type.
	!

	FNEND

16700	DEF FNBAD.CVT%
	!
	! FUNCTION TO RETURN THE LBN IN DECIMAL
	!
	! RETURNS:  LBN
	!
	! NO ERRORS POSSIBLE
	!

	CHANGE MID(PART$(2%),17%,32%) TO F%
	FBN=F%(11%)+SWAP%(F%(12%))
	FBN=FBN+65536. IF FBN<0.
	FBN=FBN+65536.*F%(10%)
	LBN=FBN
	CHANGE LEFT(PART$(2%),16%) TO F%
	DCS%=F%(7%)
	LBN=FBN+(DCS%-1%) UNLESS FBN=0.
	FNEND

	!
	!
	!	P r i v i l e g e   C h e c k   F u n c t i o n
	!
	!
16800	DEF	FNPRIV%(X$)
	X$=SYS(CHR$(6%)+CHR$(32%)+CHR$(1%)+STRING$(3%,0%)+X$)
	FNPRIV%=(ASCII(MID(X$,3%,1%))=0%)
	FNEND
	! This function takes a privilege name as it's argument, and returns
	!  -1 if the user has the specified privilege, or 0 if not.

	!
	!
	!	U n s i g n e d   I n t e g e r   C o n v e r s i o n
	!
	!

16900	DEF FNUNSIGNED$(X%)=NUM1$((X% EQV 32767%)+32768.)


19000	!
	!
	!	E R R O R    H A N D L I N G
	!
	!

	RESUME PRINT_ERROR_AND_EXIT UNLESS ERR=28%
	PRINT #7%,CRLF;CRLF; &
		"Control/C Encountered - File will NOT be Zeroed";CRLF &
		IF (OUT.OPN%<>0%) AND (ZERO%<>0%)
	ZERO%=0%
	RESUME PRINT_TOTALS_AND_CHAIN
		! Control/c gets us back to ERRDIS - if this happens,
		! file may not be zeroed - will simply restart ?'s.
		! All other errors are fatal.

	!
	!
	!	C H A I N    E N T R Y
	!
	!

31000	ON ERROR GOTO 19000
	OUT.OPN%=0%
	S$=SYS(CTRAP)
	S$=SYS(CHR$(7%))
	ER.COD%=FNEXT%(1%)
	ST.DAT%=FNEXT%(3%)
	ST.TIM%=FNEXT%(5%)
	EN.DAT%=FNEXT%(7%)
	EN.TIM%=FNEXT%(9%)
	ZERO%=FNEXT%(11%)
	HND.IDX%=FNEXT%(13%) 
	ENTRY.TYP%=FNEXT%(15%)
	ENTRY.TYP%=2% IF ENTRY.TYP%=0%
	S$=RIGHT(S$,17%)
	I%=INSTR(1%,S$,"?")
	I0$=LEFT(S$,I%-1%)
	O0$=RIGHT(S$,I%+1%)
	GOTO ENTRY_POINT
		! Chain entry from ERRDIS
		! Set up ctrl/c trap, extract all needed info and goto work.

 PRINT_ERROR_AND_EXIT:
	PRINT "?ERRDET - "; &
		CVT$$(RIGHT(SYS(CHR$(6%)+CHR$(9%)+CHR$(ERR)),3%),4%); &
		" at Line";ERL
	GOTO END_PROGRAM
		!
		!	E X I T
		!
		! We're here if there was an error

 DROP_PRIVLIGES_AND_EXIT:
	S$=SYS(CHR$(6%)+CHR$(-21%))
	S$=SYS(CHR$(9%))
		! Get rid of privileges.
		! Remove ourselves from memory.

 END_PROGRAM:
	END
