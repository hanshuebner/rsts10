2!		PROGRAM		: AUTOED.BAS
5!		VERSION		: V10.1
6!		EDIT		: A
7!		EDIT DATE	: 10-MAY-91
10		EXTEND
11	! &
	&
	&
	!		  C O P Y R I G H T &
	&
	&
  !		      Copyright (C) 1977, 1991 by &
  !	        Digital Equipment Corporation, Maynard, Mass. &
  !	&
  !	&
  !	This software is furnished under a license and may be used and &
  !	copied  only  in accordance with the terms of such license and &
  !	with the  inclusion  of  the  above  copyright  notice.   This &
  !	software  or  any  other copies thereof may not be provided or &
  !	otherwise made available to any other person.  No title to and &
  !	ownership of the software is hereby transferred. &
  !	&
  !	The information in this software is subject to change  without &
  !	notice  and should not be construed as a commitment by Digital &
  !	Equipment Corporation. &
  !	&
  !	DIGITAL assumes no responsibility for the use  or  reliability &
  !	of its software on equipment that is not supplied by DIGITAL. &
  !	&
  !******************************************************************* &

20	! &
	&
	&
	!	M O D I F I C A T I O N    H I S T O R Y &
	&
	&
	&
	! VER/ED	EDIT DATE	REASON &
	! &

100	! &
	&
	&
	&
	!	G E N E R A L    D E S C R I P T I O N &
	&
	&
	&
   !	AUTOED EDITS ASCII TEXT FILES.  IT OPENS A TEMPORARY WORK FILE &
   !	CREATED BY THE PROGRAM CPATCH BEFORE CPATCH CHAINS TO AUTOED. &
   !	THE WORK FILE CONTAINS A DESCRIPTION OF THE FILE CONTAINING &
   !	THE EDITING COMMAND, THE FILE TO WRITE A LOG OF THE EDITING &
   !	OPERATIONS, THE FILE TO EDIT, AND WHERE TO WRITE THE RESULTING &
   !	EDITTED FILE.  AUTOED USES A COMMAND LANGUAGE WHICH IS A &
   !	SUBSET OF EDIT 11'S COMMAND LANGUAGE. &

300	! &
	&
	&
	!	I / O    C H A N N E L S &
	&
	&
	&
   !	CHANNEL #		USED FOR &
   !	   1%		EDIT COMMAND INPUT &
   !	   2%		LOG FILE FOR EDITS &
   !	   3%		INPUT CHANNEL FOR FILE TO EDIT &
   !	   4%		OUTPUT CHANNEL FOR EDITTED FILE &
   !	  11%		NL: USED TO CREATE A BUFFER FOR EDIT OPERATIONS &
   !	  12%		WORK FILE FOR PASSING INFORMATION BETWEEN PROGRAMS &

400	! &
	&
	&
	!	V A R I A B L E    D E F I N I T I O N S &
	&
	&
	&
   !	VARIABLE NAME		USED FOR &
   !	&
   !	ARG%		NUMERIC ARGUMENT TO EDIT COMMANDS &
   !	BDARG$		"BAD ARGUMENT" ERROR MESSAGE &
   !	BPAG$		FIELD OF BUFFER CONTAINING PORTION OF &
   !			LINE BEING EDITTED WHICH LIES BEHIND &
   !			THE EDIT POINTER &
   !	BSNL$		STRING CONTAINING THE LAST CHARACTER OF &
   !			ALL ACCEPTABLE NEW LINE SEQUENCES &
   !	C0		COUNT OF LINES READ FROM COMMAND FILE &
   !	C0$		STRING CONTAINING NAME OF COMMAND FILE &
   !	C0%		CHANNEL NO. OF COMMAND FILE. &
   !	C1		COUNT OF LINES READ FROM COMMAND FILE AS PASSED &
   !			TO THE PROGRAM FROM CPATCH &
   !	CHC%(10)	TYPE CODE FOR STRING REPLACEMENT IN COMMAND FILE &
   !	CHL$(10)	STRINGS TO BE REPLACED AS THEY APPEAR IN COMMAND FILE &
   !	CHS$(10)	STRINGS TO USE IN PLACE OF THOSE MATCHING ABOVE &
   !    CNT0%		SCRATCH VARIABLE FOR FUNCTION FNGTCH$ &
   !	COMMND$		LEGAL SINGLE CHARACTER COMMMANDS &
   !	COMPNT%		POINTER FOR SCANNING INPUT COMMAND STRING &
   !			WHICH IS STORED IN A FIELD AT THE END OF &
   !			THE NULL DEVICE BUFFER &
   !	COM.FIL.LIN$	LAST LINE READ FROM COMMAND FILE USING &
   !			A LINE AT A TIME READ &
   !	CR$		CARRAIGE RETURN LINE FEED &
   !	CRLF$		AS ABOVE BUT WITH PARITY SET &
   !	CS%		CURRENT CHECKSUM OF CHARACTERS TO LOG FILE &
   !			(WITHOUT THE FANCY <null>, <lf>, ETC.) &
   !	CS.FLAG%	<>0 -> DO CHECKSUMMING ON ANY TEXT TO BE LOGGED &
   !	E0%		CHAIN ENTRY FLAG &
   !	EOF$		END OF FILE ERROR MESSAGE &
   !	ERMSG$		ERROR MESSAGE FOR LAST EDIT ERROR TO OCCUR &
   !	ESC$		ESCAPE CHARACTER &
   !	FF$		FORM FEED CHARACTER &
   !	FILN$(7)	FILE NAME ARRAY IN WORK FILE TO PASS INFORMATION &
   !			BETWEEN CPATCH AND AUTOED (WORK FILE VIRTUAL ARRAY) &
   !	FILN%(7,63)	VIRTUAL ARRAY TO ACCESS WORK FILE BY WORDS &
   !			(AS FOR CHECKSUMMING INFORMATION) &
   !	FLSH$		CHARACTERS TO IGNORE ON A SINGLE CHARACTER READ &
   !	FPAG$		FIELD WITHIN THE CURRENT LINE BEING EDITTED WHICH &
   !			LIES FORWARD OF THE EDIT POINTER &
   !	GTCS$		TEMP STRING IN GET CHARACTER ROUTINE &
   !	HI%		UTILITY VARIABLE &
   !	I$		VERSION/EDIT NUMBER &
   !    I0$		NAME OF EDIT INPUT FILE &
   !	I0%		CHANNEL NO. FOR EDIT INPUT FILE &
   !	ILCOM$		ILLEGAL COMMMAND ERROR MESSAGE &
   !	JN$,JN%		CURRENT JOB NUMBER AS ASCII STRING AND INTEGER &
   !	L0$		NAME OF LOG FILE &
   !	L0%		CHANNEL NUMBER OF LOG FILE &
   !	L0TP$		UTILITY VARIABLE &
   !	L1%		LOG FILE DEVICE TYPE FLAGE &
   !	LNT%		NO. OF ITEMS IN TABLES CHL$,CHS$, AND CHC% &
   !	N%		UTILITY VARIABLE &
   !	NL$		A NULL STRING CONSTANT &
   !	NLNGT%		NO. OF CHARACTERS IN LAST SELECTED NEWLINE &
   !			CHARACTER SEQUENCE &
   !	NMBR$		STRING OF ASCII DIGITS &
   !	NULL$		STRING CONTAINING A SINGLE CHR$(0%) &
   !	O0$		NAME OF EDIT OUTPUT FILE &
   !	O0%		CHANNEL NUMBER OF EDIT OUTPUT FILE &
   !	PAG$		CURRENT LINE BEING EDITTED (FIELD IN NL: BUFFER) &
   !	PAGEND%		LENTH OF CURRENT LINE BEING EDITTED &
   !	PAGPNT%		EDIT POINTER &
   !	PAGSTAT%	INDICATOR FOR EDIT END OF PAGE AND &
   !			END OF FILE &
   !	PATCH$		NAME OF CPATCH PROGRAM FOR CHAIN COMMAND &
   !	PGSIZ%		TOTAL NULL DEVICE BUFFER SIZE &
   !	PKG.LOC$	NAME OF ACCOUNT WHICH CONTAINS ALL PROGRAMS &
   !	S%(132)		SCRATCH ARRAY, USED FOR CHECKSUMMING &
   !	SEARCH$		FIELD OF NL: BUFFER USED TO HOLD CURRENT STRING &
   !			TO BE INSERTED OR SEARCHED FOR &
   !	SNF$		SEARCH FAILURE ERROR MESSAGE &
   !	STR1%,STR2%	UTILITY VARIABLES &
   !	SZE%		  "        " &
   !	T0-Tn(% OR $)	TEMPORARY (SCRATCH) VARIABLES &
   !	TCM0$		CURRENT SINGLE LETTER EDIT COMMAND BEING EXECUTED &
   !	TMIN$		CONSTANT "-" &
   !	TMIN%		MINUS FLAG FOR PARSING NUMERIC ARGUMENTS &
   !	TZERO$		CONSTANT "0" &
   !	WARN%		<0 INDICATES THAT ERRORS ARE NOT TO BE FATAL; &
   !				THIS IS A COLON-MODIFIED COMMAND. &
   !			>0 INDICATES THAT AN ERROR HAS OCCURRED IN A &
   !				COLON-MODIFIED COMMAND. &
   !	WORK$		NAME OF WORK FILE &

800	! &
	&
	&
	!	F U N C T I O N / S U B R O U T I N E    D E S C . &
	&
	&
	&
	! &
	&
	&
	&
	!	S U B R O U T I N E S &
	&
	&
	! SUBROUTINE	LINES		USED FOR &
	! &
	! INIT		10000-10130	INITIALIZE PROGRAM VARIABLES &
	! &
	! OPEN		10210		OPEN EDIT INPUT AND OUPUT FILES &
	!				AND NULL DEVICE &
	! &
	! SEARCH (G)	11000-11020	IMPLEMENTS THE EDIT 11 "G" COMMAND &
	!				(GET TEXT ON CURRENT PAGE) &
	! &
	! SEARCH (H)	11050-11070	EDIT 11 "H" COMMAND (SEARCH &
	!				WHOLE BUFFER) &
	! &
	! VERIFY (V)	11100		"V" COMMAND (VERIFY) &
	! &
	! EXIT (EX)	11150-11170	"EX" COMMAND (PROGRAM EXIT) &
	! &
	! LIST (L)	11200-11220	"L" COMMAND (LIST LINES) &
	! &
	! INSERT (I)	11300-11340	"I" (INSERT TEXT) &
	! &
	! CHANGE (C)	11400-11410	"C" COMMAND (CHANGE TEXT) &
	! &
	! KILL (K)	11500-11510	"K" COMMAND (KILL LINES) &
	! &
	! ADVANCE (A)	11600-11610	"A" COMMAND (ADVANCE POINTER BY &
	!				LINES) &
	! &
	! DELETE (D)	11700-11710	"D" COMMAND (DELETE CHARACTERS) &
	! &
	! JUMP (J)	11900-11910	"J" COMMAND (ADVANCE POINTER BY &
	!				CHARACTERS) &
	! &
	&
	&
	&
	!	F U N C T I O N S &
	&
	&
	&
	! FNR$(S1$,S2$,S3$) &
	!		15600-15650	RETURN S1$ WITH ALL OCCURANCES OF &
	!				S2$ REPLACED BY S3$ &
	! &
	! FNCS%(S$)	15700		ADD S$ INTO CHECKSUM CS% &
	! &
	! FNL0%(S$)	15800-15830	OUTPUT S$ TO LOG FILE &
	! &
	! FNL1%(S$)	15950		AS ABOVE BUT FIRST SUBSTITUTE &
	!				"<ESC>" FOR CHR$(27%) ETC. FOR &
	!				ALL CONTROL CHARACTERS &
	! &
	! FNC0%		16050-16095	GET A COMMAND LINE &
	! &
	! FNGNLC%(S$)	16200-16220	GET POSITION OF NEXT BASIC PLUS &
	!				NEW LINE CHARACTER OR CHARACTER &
	!				SEQUENCE IN STRING S$ &
	! &
	! FNGTLN$	16400-16440	GET LINE OF TEXT FROM COMMAND FILE &
	! &
	! FNGTCH$(CNT%) 16500-16570	GET CNT% CHARACTERS FROM COMMAND FILE &
	! &
	! ------	16310-16370	COMMON SUBROUTINES FOR FNGTLN AND &
	!				FNGTCH &
	! &
	! FNL%(N%)	17000-17020	MOVE POINTER AHEAD N% LINES IN &
	!				FILE BEING EDITTED &
	! &
	! FNK%(N%)	17050-17090	KILL N% LINES OF TEXT &
	! &
	! FNG%		17100-17130	MOVE TEXT POINTER TO NEXT &
	!				OCCURANCE OF STRING CONTAINED &
	!				IN SEARCH$. SEARCH STOPS AT &
	!				FIRST FORM FEED CHARACTER &
	! &
	! FNH%		17200-17220	AS ABOVE BUT TO END OF FILE &
	! &
	! FNIS%		17250-17280	SET SEARCH$ TO EQUAL NEXT &
	!				VALID EDIT 11 TEXT ARGUMENT &
	! &
	! FNEL$		17300-17340	INPUT LINE FROM EDIT INPUT FILE &
	! &
	! FNGCS%	18500		PUT COMMAND LINE INTO COMMAND LINE &
	!				FIELD OF NL: TEXT BUFFER &
	! &
	! FNGOC%	18650-18680	GET NEXT CHARACTER FROM ABOVE STRING &
	! &

900	! &
	&
	&
	!	D I M E N S I O N    S T A T E M E N T S &
	&
	&

920	DIM #12%, FILN$(7%)=128% &
	\ DIM #12%, FILN%(7%,63%) &
	\ DIM CHL$(10%),CHS$(10%),CHC%(10%),S%(132%) &

1000	! &
	&
	&
	!	M A I N    C O D I N G    A R E A &
	&
	&

1010	ON ERROR GOTO 19000 &
	\ I$="V10.1-A" &
	\ T0$=SYS(CHR$(6%)+CHR$(-21%)) &
		! SET UP STANDARD ERROR TRAP. &
		! BUILD LEVEL/EDIT STRING. &
		! PERMANENTLY DROP TEMPORARY PRIVILEGES. &

1015	IF E0%=0% THEN &
		PRINT IF CCPOS(0%) &
	\	PRINT "AUTOED";CHR$(9%);I$;CHR$(9%); &
		CVT$$(RIGHT(SYS(CHR$(6%)+CHR$(9%)+CHR$(0%)),3%),4%) &
	\	PRINT "?Illegal entry - Please 'RUN CPATCH'" &
	\	GOTO 32760 &
		! PRINT HEADER AND GET OUT IF RUN ENTRY. &

1020	CHANGE SYS(CHR$(12%)) TO S% &
	\ PKG.LOC$="["+NUM1$(S%(6%))+","+NUM1$(S%(5%))+"]" &
	\ PKG.LOC$="_"+CHR$(S%(23%))+CHR$(S%(24%)) &
	    +NUM1$(S%(25%))+":"+PKG.LOC$ &
		IF S%(26%) AND 1% &
	\ IF S%(3%)+SWAP%(S%(4%))<>15%*2% THEN &
		PRINT IF CCPOS(0%) &
	\	PRINT "?AUTOED must be compiled" &
	\	GOTO 32760 &
		! BUILD NAME OF DEVICE AND ACCOUNT OF LAST OPENED FILE. &
		! WE MUST HAVE COME FROM A COMPILED FILE SO WE CAN BE &
		! SURE THAT THIS NAME IS REALLY OUR PACKAGE LOCTAION. &
		! IF WE DIDN'T COME FROM A CHAIN ENTRY FROM A COMPILED &
		! FILE, PRINT AN APPREPRIATE ERROR MESSAGE. &

1030	GO SUB 10000 &
	\ OPEN WORK$ FOR INPUT AS FILE 12% &
	\ CS.FLAG%=FILN%(7%,61%) &
	\ C0$=FILN$(1%) &
	\ L0$=FILN$(2%) &
	\ OPEN L0$ FOR OUTPUT AS FILE L0% &
	\ L1%=-1% IF (STATUS AND 255%)=2% &
	\ OPEN C0$ FOR INPUT AS FILE C0% &
	\ C1%=-1% IF (STATUS AND 255%)=2% &
	\ C1=CVT$F(FILN$(7%)) &
	\ C0=0 &
	\ T0$=FNGTLN$ WHILE (C0 < C1) AND (C1%=0%) &
	\ C0=C1 IF C1% <> 0% &
	\ GO SUB 10200 &
		! SKIP TO CURRENT POSITION IN COMMAND FILE. &
		! PERFORM OPEN OF EDIT FILES. &
	&

2000	T0%=FNL0%('*') &
	\ T0%=FNGCS% &
		! OUTPUT PROMPT, GET COMMAND STRING &

2010	ARG%=0% &
	\ TMIN%=0% &
	\ TCM0$=FNGOC$ &
	\ IF TCM0$=NL$ &
		THEN GO TO 2000 &
		ELSE IF TCM0$=TZERO$ &
			THEN ARG%=0% &
			\    TCM0$=FNGOC$ &
			\    IF TCM0$=NL$ &
				THEN GO TO 2000 &
				ELSE GO TO 2070 &
		! ZERO ARG IS SPECIAL CASE &

2040	IF TCM0$=TMIN$ &
		THEN TMIN%=1% &
		\ TCM0$=FNGOC$ &
			! MINUS SIGN FOR NUMS. &

2050	WHILE (INSTR(1%,NMBR$,TCM0$) <> 0%) AND (TCM0$ <> NL$) &
	\ ARG%=(ARG%*10%)+INSTR(1%,NMBR$,TCM0$)-1% &
	\ TCM0$=FNGOC$ &
	\ NEXT &
		! PARSE UP NUMERIC ARGS. &

2060	ARG%=1% IF ARG%=0% &
	\ ARG%=-ARG% IF TMIN% <> 0% &
	\ GO TO 2000 IF TCM0$=NL$ &
		! HANDLE MINUS SIGN AND NO &
		! ARG, WHICH DEFAULTS TO 1. &

2070	WARN%=0% &
	\ IF TCM0$=":" THEN &
		WARN%=-1% &
	\	TCM0$=FNGOC$ &
		! IF THIS IS A COLON-MODIFIED SEARCH, SET THE FLAG &
		! TO PRODUCE ONLY WARNING ERRORS AND GET THE NEXT &
		! COMMAND CHARACTER. &

2080	TCM0$=CVT$$(TCM0$,32%) &
	\ T0%=INSTR(1%,COMMND$,TCM0$) &
	\ IF T0%=0% &
		THEN ERMSG$=ILCOM$+TCM0$ &
		\ GO TO 2100 &

2090	ERMSG$=NL$ &
	\ ON T0% GO SUB 11000,11050,11100,11150,11200, &
		11300,11400,11500,11600,11700,11900 &

2100	IF ERMSG$=NL$ &
		THEN GO TO 2010 &
		ELSE IF WARN%>0% THEN GOTO 32710 &
			ELSE T0%=FNL0%(CR$+ERMSG$+CR$) &
			\ GO TO 2000 &
		! TAKE APPROPRIATE ACTION ON AN ERROR. &
	&

10000	! &
	&
	&
	!	S U B R O U T I N E S &
	&
	&
	&
	! &
	&
	&
	&
	!	I N I T I A L I Z E   V A R I A B L E S &
	&
	&

10020	NULL$=CHR$(0%) &
	\ JN%=ASCII(SYS(CHR$(6%)+CHR$(9%)+NULL$))/2% &
	\ JN$=RIGHT(NUM1$(100%+JN%),2%) &
	\ WORK$="WORK"+JN$+".TMP" &
	\ PATCH$=PKG.LOC$+"CPATCH" &
	\ ESC$=CHR$(27%) &
	\ FF$=CHR$(12%) &
	\ NL$="" &
	\ CR$=CHR$(13%)+CHR$(10%) &
	\ CRLF$=CHR$(128%+13%)+CHR$(128%+10%) &
	\ COMMND$="GHVELICKADJ" &
	\ NMBR$="0123456789" &
	\ TMIN$="-" &
	\ TZERO$="0" &
	\ SNF$="?srch fail" &
	\ BDARG$="?bad arg for " &
	\ ILCOM$="?bad com: " &
	\ EOF$="?eof" &
	\ FLSH$=CHR$(9%)+CHR$(12%)+CHR$(10%)+CHR$(13%) &
			+CHR$(32%)+NULL$+ESC$ &
	\ C0$,L0$,O0$,I0$=NL$ &
	\ O0%=4% &
	\ I0%=3% &
	\ L0%=2% &
	\ C0%=1% &
	\ L1%,C1%,CS%=0% &
	\ RESTORE &

10080	FOR I%=1% TO 10% &
	\ READ CHL$(I%) &
	\ GO TO 10110 IF CHL$(I%)=TZERO$ &
	\ CHS$(I%)=NL$
10090	READ T0% &
	\ GO TO 10100 IF T0%=256% &
	\ CHS$(I%)=CHS$(I%)+CHR$(T0%) &
	\ GO TO 10090
10100	READ CHC%(I%) &
	\ NEXT I%
10110	LNT%=I%-1% &
		! INITIALIZE ARRAY FOR SUBSTITUTION OF &
		! NAMES FOR CONTROL CHARACTERS. &

10115	BSNL$=CHR$(12%)+NULL$+CHR$(10%)+ESC$ &

10120	RETURN &

10130	DATA	"<ff>",12,256,2, &
		"<lf>",10,13,0,256,2, &
		"<cr>",13,10,256,2, &
		"<esc>",27,256,1, &
		"<tab>",9,256,0, &
		"<null>",0,256,0, &
		<10>,10,256,0, &
		<13>,13,256,0,0 &

10200	! &
	&
	&
	&
	!	F I L E   O P E N   A N D   I N I T &
	&
	&

10210	PGSIZ%=512% &
	\ I0$=FILN$(3%) &
	\ O0$=FILN$(4%) &
	\ CLOSE 12% &
	\ OPEN I0$ FOR INPUT AS FILE I0% &
	\ OPEN O0$ FOR OUTPUT AS FILE O0% &
	\ OPEN "_NL:" AS FILE 11%, RECORDSIZE PGSIZ% &
	\ FIELD #11%, 0% AS PAG$, 0% AS FPAG$, 0% AS BPAG$ &
	\ PAGPNT%,PAGEND%,PAGSTAT%=0% &
	\ RETURN &
		! OPEN FILES AND INIT TEXT BUFFER &
		! IN THE NULL DEVICE BUFFER. &
	&

10999	! &
	&
	&
	&
	!	S E A R C H   ( G ) &
	&
	&

11000	T0%=FNIS% &
	\ GO TO 11010 IF T0% <> 0% &
	\ FOR HI%=1% UNTIL HI% > ARG% &
	\	T0%=FNG% &
	\	GO TO 11020 IF T0% <> 0% &
	\ NEXT HI% &
	\ RETURN &

11010	ERMSG$=BDARG$+TCM0$ &
	\ RETURN &

11020	ERMSG$=SNF$ &
	\ WARN%=1% IF WARN% &
	\ RETURN &

11049	! &
	&
	&
	&
	!	S E A R C H   ( H ) &
	&
	&

11050	T0%=FNIS% &
	\ GO TO 11060 IF T0% <> 0% &
	\ FOR HI%=1% UNTIL HI% > ARG% &
		\ T0%=FNH% &
		\ GO TO 11070 IF T0% <> 0% &
	\ NEXT HI% &
	\ RETURN &
		! SEARCH FOR THE NTH OCCURANCE OF THE STRING &

11060	ERMSG$=BDARG$+TCM0$ &
	\ RETURN &

11070	ERMSG$=EOF$ &
	\ WARN%=1% IF WARN% &
	\ RETURN &
	&

11099	! &
	&
	&
	&
	!	V E R I F Y   ( V ) &
	&
	&

11100	T0%=FNL0%(PAG$) &
	\ RETURN &

11149	! &
	&
	&
	&
	!	E X I T   ( E X ) &
	&
	&

11150	T0$=FNGOC$ &
	\ T0$=CVT$$(T0$,32%) &
	\ IF T0$ <> "X" &
		THEN ERMSG$=ILCOM$+TCM0$+T0$ &
		\    RETURN &

11160	WHILE 1% > 0% &
		\ T0%=FNL%(32767%) &
		\ PAGSTAT%=PAGSTAT% AND -3% &
		\ GO TO 11170 IF PAGSTAT% <> 0% &
	\ NEXT &

11170	GO TO 32700 IF C1% <> 0% &
	\ COM.FIL.LIN$=NL$ &
	\ GOSUB 16310 &
	\ GO TO 32700 IF COM.FIL.LIN$=NL$ &
	\ CLOSE I0%,O0%,11% &
	\ OPEN WORK$ FOR INPUT AS FILE 12% &
	\ KILL FILN$(3%) &
	\ NAME FILN$(4%) AS FILN$(3%) &
	\ GOSUB 10200 &
	\ RETURN &
		! IF EX OCCURED IN THE MIDDLE OF A PATCH &
		! THEN CONTINUE AFTER COPYING OUTPUT AND &
		! RENAMING IT TO NEW INPUT. &
	&

11199	! &
	&
	&
	&
	!	L I S T   ( L ) &
	&
	&

11200	IF (ARG% < 0%) OR (ARG% > 1%) &
		THEN ERMSG$=BDARG$+TCM0$ &
		\    RETURN &

11210	IF (ARG%=0%) &
		THEN T0%=FNL0%(BPAG$) &
		ELSE T0%=FNL0%(FPAG$) &

11220	RETURN &
	&

11299	! &
	&
	&
	&
	!	I N S E R T   ( I ) &
	&
	&

11300	T0%=FNIS% &
	\ IF T0%=2% &
		THEN ERMSG$=BDARG$+TCM0$ &
		\    RETURN &

11310	IF T0%=0% &
		THEN T1%=LEN(SEARCH$) &
		\    FIELD #11%, PAGPNT% AS T0$, T1% AS T0$, &
				LEN(FPAG$) AS T1$ &
		\    RSET T1$=FPAG$ &
		\    LSET T0$=SEARCH$ &
		\    PAGPNT%=PAGPNT%+T1% &
		\    PAGEND%=PAGEND%+T1% &
		\    FIELD #11%, PAGEND% AS PAG$ &
		\    FIELD #11%, PAGPNT% AS BPAG$, &
			PAGEND%-PAGPNT% AS FPAG$ &
		\    RETURN &

11320	T0$=FNC0$ &
	\ T1%=INSTR(1%,T0$,ESC$) &
	\ IF T1%=0% &
		THEN PRINT #O0%, BPAG$; &
		\    FIELD #11%, 0% AS BPAG$ &
		\    PRINT #O0%, T0$; &
		\    GO TO 11320 &
			! IF AN ENTIRE LINE TO INSERT, THEN &
			! PRINT PRINT ANY TEXT BEFORE CURRENT &
			! POINTER LOCATION AND PRINT THE LINE &
			! WITH THE POINTER SET TO 0. &

11330	T0%=LEN(BPAG$) &
	\ T1%=LEN(T0$)-1% &
	\ T2%=LEN(FPAG$) &
	\ FIELD #11%, T0% AS BPAG$, T1% AS T1$, T2% AS T2$ &
	\ IF PAGPNT% < (T0%+T1%) &
		THEN RSET T2$=FPAG$ &
		ELSE LSET T2$=FPAG$ &

11340	LSET T1$=T0$ &
	\ PAGPNT%=T0%+T1% &
	\ PAGEND%=PAGPNT%+T2% &
	\ FIELD #11%, PAGPNT% AS BPAG$,T2% AS FPAG$ &
	\ FIELD #11%, PAGEND% AS PAG$ &
	\ RETURN &
	&

11399	! &
	&
	&
	&
	!	C H A N G E   ( C ) &
	&
	&

11400	T0%=FNIS% &
	\ IF T0%=2% &
		THEN ERMSG$=BDARG$+TCM0$ &
		\    RETURN &

11410	GO SUB 11700 &
	\ GO SUB 11310 &
	\ RETURN &
	&
	&

11499	! &
	&
	&
	&
	!	K I L L   ( K ) &
	&
	&

11500	IF ARG% < 0% &
		THEN ERMSG$=BDARG$+TCM0$ &
		ELSE T0%=FNK%(ARG%) &

11510	RETURN &

11599	! &
	&
	&
	&
	!	A D V A N C E   ( A ) &
	&
	&

11600	IF ARG% < 0% &
		THEN ERMSG$=BDARG$+TCM0$ &
		ELSE T0%=FNL%(ARG%) &

11610	RETURN &
	&

11699	! &
	&
	&
	&
	!	D E L E T E   ( D ) &
	&
	&

11700	ARG%=-256% IF ARG%=0% &
	\ IF ARG% < 0% &
		THEN ARG%=-ARG% &
		\    ARG%=PAGPNT% IF PAGPNT%-ARG% < 0% &
		\    PAGPNT%=PAGPNT%-ARG% &

11710	ARG%=PAGEND%-PAGPNT% IF (ARG%+PAGPNT%) > PAGEND% &
	\ T3%=PAGEND%-(PAGPNT%+ARG%) &
	\ FIELD #11%, PAGPNT% AS BPAG$, ARG% AS T0$, &
			T3% AS T0$ &
	\ FIELD #11%, PAGPNT% AS BPAG$, T3% AS FPAG$ &
	\ LSET FPAG$=T0$ &
	\ PAGEND%=PAGEND%-ARG% &
	\ FIELD #11%, PAGEND% AS PAG$ &
	\ RETURN &
	&

11899	! &
	&
	&
	&
	!	J U M P   ( J ) &
	&
	&

11900	ARG%=-256% IF ARG%=0% &
	\ PAGPNT%=PAGPNT%+ARG% &
	\ IF PAGPNT% < 0% &
		THEN PAGPNT%=0% &
		ELSE IF PAGPNT% > PAGEND% &
			THEN PAGPNT%=PAGEND% &

11910	FIELD #11%, PAGPNT% AS BPAG$, PAGEND%-PAGPNT% AS FPAG$ &
	\ RETURN &
	&

15000	! &
	&
	&
	!	F U N C T I O N S &
	&
	&
	&
	! &
	&
	&
	&
	!	F U N C T I O N   F N R $ &
	&
	&
	&
	! FUNCTION: FNR$(S1$,S2$,S3$) &
	! &
	! FUNCTION WHICH RETURNS THE VALUE S1$ WITH &
	! EVERY OCCURANCE OF S2$ REPLACED BY S3$ &

15600	DEF* FNR$(S1$,S2$,S3$) &
	\ T1$=S1$ &
	\ T1%=LEN(S2$) &
	\ T2%=1% &
	\ T3%=LEN(S3$) &
		! GET STRING LENGTH OF STRING TO REPLACE &
		! AND INIT SEARCH POSITION &

15630	T2%=INSTR(T2%,T1$,S2$) &
	\ IF T2% <> 0% &
		THEN T1$=LEFT(T1$,T2%-1%)+S3$+RIGHT(T1$,T2%+T1%) &
		\    T2%=T2%+T3% &
		\    GO TO 15630 &
		! SUBSTITUTE S3$ FOR S2$ &

15650	FNR$=T1$ &
	\ FNEND &
	&

15700	! &
	&
	&
	!	F U N C T I O N    F N C S % &
	&
	&
	! FUNCTION FNCS%(S$) &
	! &
	! ADD CHECKSUM OF STRING S$ TO RUNNING CHECKSUM CS% &
	! NO VALUE IS RETURNED. &
	! &
	DEF* FNCS%(S$) &
	\ CHANGE LEFT(S$,132%) TO S% &
	\ CS%=SWAP%(CS%)*2%+CS% XOR S%(T0%) FOR T0%=1% TO S%(0%) &
	\ FNEND &
	&
	&

15799	! &
	&
	&
	&
	!	F U N C T I O N   F N L 0 % &
	&
	&
	&
	! FUNCTION FNL0%(S$) &
	! &
	! CHECKSUM THE STRING IF APPROPRAITE. &
	! OUTPUT STRING TO LOG FILE.  IF COMMAND FILE &
	! IS KB: THEN OUTPUT ALSO TO KB: EVEN IF &
	! IT IS NOT THE LOG FILE &
	! VALUE		MEANING &
	!  0%		NO ERROR &
	! IF ERROR AND WARN% NOT SET, PROG RESUMES AT 32710 WITH T6% SET &
	! TO THE FOLLOWING POSSIBLE VALUES. &
	!  1%		STRING DOES NOT MATCH INPUT &
	!  2%		EOF ON INPUT &
	! IF ERROR WITH WARN% SET, ERMSG$ RETURNS ="?mismatch", &
	! WARN% RETURNS =1. &
	! &
	! IF NULLS ARE NO LONGER CONVERTED TO <NULL>, AND RECORD &
	! I/O IS NOT ADOPTED, THEN NULLS WHICH ARE NOT PART OF A &
	! <LF><CR><NULL> SEQUENCE MUST BE FLUSHED. &
	! THAT WOULD BE INSERTED HERE OR IN FNL1% &

15800	DEF* FNL0%(S$) &
	\ GO TO 15830 IF LEN(S$)=0% &
	\ IF C1% <> 0% &
		THEN GO TO 15810 &
		ELSE SZE%=LEN(S$) &
		\ T0$=FNGTCH$(SZE%) &
		\ IF T0$=S$ &
		    THEN  GO TO 15810 &
		    ELSE	ERMSG$="?mismatch" IF WARN% &
			\	WARN%=1% IF WARN% &
			\	T6%=1% &
			\	T6%=2% UNLESS LEN(T0$) &
			\	ERMSG$="?eof" UNLESS LEN(T0$) &
			\	GO TO 32710 UNLESS LEN(T0$) &
			\	L0TP$=CRLF$+CRLF$+"=cmd=>"+T0$+ &
					CRLF$+CRLF$+"=log=>"+S$+ &
					CRLF$+CRLF$ &
			\	L0TP$=L0TP$+"%" IF WARN% &
			\	L0TP$=L0TP$+"?" UNLESS WARN% &
			\	L0TP$=L0TP$+"mismatch?" &
					+CRLF$ &
			\	T0%=FNL1%(L0TP$) &
			\	GO TO 32710 &
				! IF COMMAND FILE IS NOT KB:, &
				! THEN INPUT A STRING AND COMPARE. &
				! SET ERROR IF EOF OR MISMATCH. &

15810	T0%=FNCS%(S$) IF CS.FLAG% &
	\ PRINT S$; IF L1% OR C1% &
	\ FNL0%=FNL1%(S$) UNLESS L1% &
		! CHECKSUM AND LOG THE MESSAGE. &

15830	FNL0%=0% &
	\ FNEND &
	&

15900	! &
	&
	&
	&
	!	F U N C T I O N   F N L 1 % &
	&
	&
	&
	! FUNCTION: FNL1%(S$) &
	! &
	! OUTPUTS STRING TO LOG FILE AFTER SUBSTITUTING &
	! STRINGS <CR>, ETC. FOR TERMINATOR CHARACTERS. &

15950	DEF* FNL1%(S$) &
	\ FOR I%=1% TO LNT% &
		\ T0$=CHL$(I%) &
		\ T0$=T0$+CRLF$ IF CHC%(I%)=2% &
		\ S$=FNR$(S$,CHS$(I%),T0$) &
	\ NEXT I% &
	\ PRINT #L0%, CVT$$(S$,1%); &
	\ FNL1%=0% &
	\ FNEND &
		! PERFORM SUBSTITUTIONS OF LINE DELIMITERS &
		! AND OTHER CONTROL CHARACTERS. &
		! LOG THE STRING. &

16000	! &
	&
	&
	&
	!	F U N C T I O N   F N C 0 $ &
	&
	&
	&
	! FUNCTION: FNC0$ &
	! &
	! FUNCTION TO INPUT A COMMAND FROM THE COMMAND &
	! FILE.  THE COMMAND IS ALSO LOGGED, UNLESS &
	! THE LOG FILE AND THE INPUT FILE ARE BOTH &
	! KB:.  THE COMMAND IS CHECKSUMMED IF APPROPRIATE. &

16050	DEF* FNC0$ &
	\ T2$=FNGTLN$ &
	\ FNC0$=T2$ &
	\ I%=FNCS%(T2$) IF CS.FLAG% &
	\ IF L1% <> 0% &
		THEN PRINT T2$; UNLESS C1% &
		ELSE T2%=FNL1%(T2$) &
			! CHECKSUM THE COMMAND. &
			! LOG THE COMMAND IF REQUIRED. &

16090	IF T2$=NL$ &
		THEN T6%=2% &
		\    GO TO 32710 &

16095	FNEND &
	&

16150	! &
	&
	&
	&
	!	F U N C T I O N   F N G N L C % &
	&
	&
	&
	! FUNCTION: FNGNLC%(S$) &
	! &
	! RETURNS POSITION IN STRING S$ OF THE NEXT &
	! NEW LINE CHARACTER SEQUENCE.  START THE SEARCH &
	! AT N%.  RETURNS THE DISTANCE FROM N% TO THE LAST &
	! CHARACTER IN THE STRING, BEFORE THE NEW LINE, &
	! AND THE LENGTH OF THE NEW LINE IN THE &
	! VARIABLE NLNGT%. NOTE THAT THE DISTANCE &
	! IS COMPUTED STARTING WITH THE NTH CHARACTER; &
	! I.E. IF N%=2% AND THE STRING BEFORE THE NEW &
	! LINE CHARACTER SEQUENCE ENDS AT THE &
	! 4TH CHARACTER IN THE STRING, THE FUNCTION &
	! RETURNS 3%. &

16200	DEF* FNGNLC%(S$,N%) &
	\ FNGNLC%,NLNGT%=0% &
	\ GO TO 16220 IF N% > LEN(S$) &
	\ FOR I%=N% TO LEN(S$) &
		\ T0$=MID(S$,I%,1%) &
		\ GO TO 16210 IF (T0$=NULL$) AND (I%=N%) &
		\ T1%=INSTR(1%,BSNL$,T0$) &
		\ GO TO 16210 IF T1%=0% &
		\ T1$=CHS$(T1%) &
		\ T2%=LEN(T1$) &
		\ T0$=MID(S$,(I%-(T2%-1%)),T2%) &
		\ GO TO 16210 IF T0$ <> CHS$(T1%) &
		\ FNGNLC%=(I%-T2%)-(N%-1%) &
		\ NLNGT%=T2% &
		\ GO TO 16220 &
			! LOOK FOR THE FIRST CHARACTER OF A NEW LINE &
			! SEQUENCE. &

16210	NEXT I% &

16220	FNEND &
	&

16300	! &
	&
	&
	&
	!	C O M M O N   C O D E   F O R   G T L N , G T C H &
	&
	&
	&
	! ROUTINE TO INPUT A LINE, CONVERT ALL LONG FORM CONTROL &
	! CHARACTERS TO THE ACTUAL CHARACTERS, AND UPDATE POSITION &
	! IN STRING OF NEXT NEW LINE CHARACTER. &

16310	ON ERROR GO TO 16370 &
	\ INPUT LINE #C0%,T0$ &
	\ IF C1%=0% &
		THEN T0$=CVT$$(T0$,5%) &
		ELSE T0$=CVT$$(T0$,1%) &
		\    GO TO 16340 &
		! GET A COMMAND. IF FROM KB: THEN &
		! JUST STRIP PARITY. IF FROM COMMAND FILE, &
		! THEN STRIP PARITY AND ALL NEW LINE &
		! CHARACTERS. THEN PROCEED TO PERFORM &
		! CONVERSION OF <CHR> FORMAT TO ACTUAL &
		! CHARACTERS. &

16320	FOR I%=1% TO LNT% &
		\ T0$=FNR$(T0$,CHL$(I%),CHS$(I%)) &
		\ T0$=FNR$(T0$,CVT$$(CHL$(I%),32%),CHS$(I%)) &
	\ NEXT I% &
	\ GO TO 16310 IF T0$=NL$ &
			! PERFORM SUSTITUTION OF CONTROL &
			! CHARACTERS FOR THEIR SPELLED OUT &
			! FORM. &

16340	COM.FIL.LIN$=COM.FIL.LIN$+T0$ &

16345	! &
	&
	&
	&
	!	O T H E R    E N T R Y &
	&
	&
	&

16350	T0%=FNGNLC%(COM.FIL.LIN$,1%) &
	\ STR1%=T0% &
	\ STR2%=NLNGT% &
		! GET POSITION OF NEXT NEW LINE CHARACTER &
		! SEQUENCE, AND NUMBER OF CHARACTERS IN THAT &
		! SEQUENCE. &

16360	ON ERROR GO TO 19000 &
	\ RETURN &
		! RESET ERROR AND EXIT ROUTINE. &

16370	RESUME 16360 &
		! SET STRING TO EMPTY IF EOF &
	&

16380	! &
	&
	&
	&
	!	F U N C T I O N   F N G T L N $ &
	&
	&
	&
	! FUNCTION: FNGTLN$ &
	! &
	! FUNCTION TO GET NEXT INPUT LINE FROM CHANNEL C0% &
	! AND UPDATE COMMAND LINE COUNT. &

16400	DEF* FNGTLN$ &

16410	IF STR1%+STR2%=0% &
		THEN GOSUB 16310 &
		\ IF STR1%+STR2%=0% &
			THEN FNGTLN$=COM.FIL.LIN$ &
			\    COM.FIL.LIN$=NL$ &
			\    GO TO 16440 &
				! IF NO LINE IN CHANNEL STRING BUFFER &
				! THEN INPUT A NEW LINE.  IF STILL NONE &
				! THEN EXIT WITH A NULL STRING. &

16420	FNGTLN$=LEFT(COM.FIL.LIN$,STR1%+STR2%) &
	\ COM.FIL.LIN$=RIGHT(COM.FIL.LIN$,STR1%+STR2%+1%) &
	\ GO SUB 16350 &
	\ C0=C0+1 &

16440	FNEND &
	&

16450	! &
	&
	&
	&
	!	F U N C T I O N   F N G T C H $ &
	&
	&
	&
	! FUNCTION: FNGTCH$(CNT%) &
	! &
	! FUNCTION TO INPUT A STRING OF LENGTH CNT% FROM &
	! CHANNEL C0%. IF A NEW LINE IS READ &
	! THEN INCREMENT C0 &

16500	DEF* FNGTCH$(CNT%) &

16510	CNT0%=LEN(COM.FIL.LIN$) &
	\ IF CNT0% < CNT% &
		THEN GOSUB 16310 &
		\ IF CNT0%=LEN(COM.FIL.LIN$) &
			THEN GO TO 16520 &
				! IF CURRENT BUFFER STRING &
				! IS SHORTER THAN REQUESTED STRING &
				! THEN READ IN A NEW LINE.  IF READ &
				! DOES NOT INCREASE LENGTH OF BUFFER &
				! STRING, THEN JUST GET OUT OF LOOP. &

16515	IF CNT0% < CNT% GO TO 16510 &
		! KEEP REPEATING UNTIL LEN(COM.FIL.LIN$) &
		! > CNT% OR UNTIL EOF &

16520	CNT%=LEN(COM.FIL.LIN$) IF LEN(COM.FIL.LIN$) < CNT% &
	\ GTCS$=NL$ &
		! SET COUNT FOR EOF CASE, AND INIT &
		! TEMP STRING TO NULL &

16530	WHILE LEN(GTCS$) < CNT% &
	\ CNT0%=CNT%-LEN(GTCS$) &
	\ IF (CNT0% > (STR1%+STR2%)) AND ((STR1%+STR2%) <> 0%) &
		THEN GTCS$=GTCS$+FNGTLN$ &
		\ GO TO 16550 &
			! IF STRING IS AT LEAST ONE LINE LONG, &
			! THEN GET FIRST PART OF IT WITH A &
			! CALL TO FNGTLN$ &

16540	GTCS$=GTCS$+LEFT(COM.FIL.LIN$,CNT0%) &
	\ C0=C0+1 IF (CNT0% > STR1%) &
	\ COM.FIL.LIN$=RIGHT(COM.FIL.LIN$,CNT0%+1%) &
	\ GO SUB 16350 &
		! GET REMAINDER OF STRING TO BE INPUT. &
		! IF A NEW LINE BEGINS IN IT, THEN INC &
		! LINE COUNT &

16550	NEXT &
	\ FNGTCH$=GTCS$ &

16570	FNEND &

16999	! &
	&
	&
	&
	!	F U N C T I O N   F N L % &
	&
	&
	&
	! FUNCTION: FNL%(N%) &
	! &
	! FUNCTION TO SKIP AHEAD TO THE NTH LINE IN THE EDIT FILE &
	! STARTING AT POINT.  POINTER IS SET TO THE BEGINNING OF THE &
	! LINE AND VARIABLE PAG$ CONTAINS THE LINE. &

17000	DEF* FNL%(N%) &
	\ GO TO 17015 IF N%=0% &
	\ FOR I%=1% TO N% &
		\ PRINT #O0%, PAG$; &
		\ T0$=FNEL$ &
		\ GO TO 17010 IF T0$=NL$ &
		\ PAGEND%=LEN(T0$) &
		\ FIELD #11%, PAGEND% AS PAG$ &
		\ LSET PAG$=T0$ &
	\ NEXT I% &
	\ FIELD #11%, 0% AS BPAG$, PAGEND% AS FPAG$ &
	\ PAGPNT%=0% &
	\ FNL%=0% &
	\ GO TO 17020 &
		! OUTPUT LINES OF TEXT TO EDIT OUTPUT FILE &
		! UNTIL NTH LINE, THEN SET PAGE. &

17010	FNL%=2% &
	\ FIELD #11%, 0% AS BPAG$, 0% AS FPAG$, 0% AS PAG$ &
	\ GO TO 17020 &
		! SET EOP INDICATOR AND ZERO ALL VARIABLES FOR PAGE. &

17015	PAGPNT%=0% &
	\ FIELD #11%, PAGPNT% AS BPAG$, PAGEND% AS FPAG$ &
	\ FNL%=0% &

17020	FNEND &
	&

17049	! &
	&
	&
	&
	!	F U N C T I O N   F N K % &
	&
	&
	&
	! FUNCTION: FNK%(N%) &
	! &
	! FUNCTION TO KILL THE NEXT N LINES OF TEXT. &
	! KILLS BEGINNING OF CURRENT LINE TO POINT IF &
	! N=0% OR KILLS THE LINE FOLLOWING POINT PLUS &
	! N-1% FOLLOWING LINES &

17050	DEF* FNK%(N%) &
	\ GO TO 17080 IF N%=0% &
	\ GO TO 17060 IF N%=1% &
	\ FOR I%=1% TO N%-1% &
		\ T0$=FNEL$ &
		\ GO TO 17070 IF T0$=NL$ &
	\ NEXT I% &
		! KILL THE NEXT N%-1% LINES. &

17060	T0$=FNEL$ &
		! INPUT NEXT LINE AFTER KILLED LINES. &

17070	PAGPNT%=LEN(BPAG$) &
	\ T0%=LEN(T0$) &
	\ FIELD #11%, PAGPNT% AS BPAG$, T0% AS FPAG$ &
	\ LSET FPAG$=T0$ &
	\ PAGEND%=PAGPNT%+T0% &
	\ FIELD #11%, PAGEND% AS PAG$ &
	\ GO TO 17090 &
		! SET UP NEW PAGE IN BUFFER. &

17080	PAGPNT%=0% &
	\ PAGEND%=LEN(FPAG$) &
	\ FIELD #11%, 0% AS BPAG$, PAGEND% AS PAG$ &
	\ LSET PAG$=FPAG$ &
	\ FIELD #11%, PAGEND% AS FPAG$ &
		! DELETE FIRST HALF OF LINE FOR A 0 ARG. &

17090	FNK%=0% &
	\ FNEND &
	&

17099	! &
	&
	&
	&
	!	F U N C T I O N   F N G % &
	&
	&
	&
	! FUNCTION: FNG% &
	! &
	! PERFORMS SEARCH OF INPUT FILE FOR THE STRING &
	! SEARCH$.  CONTINUES UNTIL STRING IS FOUND OR &
	! UNTIL A FORM FEED CHARACTER IS ENCOUNTERED. &
	! IF THE STRING IS FOUND, THE POINTER IS LEFT &
	! POINTING TO THE CHARACTER FOLLOWING THE STRING, &
	! AND A VALUE OF ZERO IS RETURNED. IF THE STRING &
	! IS NOT FOUND, A 2% IS RETURNED. &

17100	DEF* FNG% &

17110	T0%=INSTR(PAGPNT%+1%,PAG$,SEARCH$) &
	\ IF T0%=0% &
		THEN T0%=FNL%(1%) &
		\    IF T0%=0% &
			THEN GO TO 17110 &
			ELSE FNG%=2% &
			\    GO TO 17130 &
		! SEARCH EACH LINE FOR AN OCCURANCE OF THE STRING. &
		! IF NONE FOUND, THEN RETURN EOF ERROR &

17120	PAGPNT%=T0%-1%+LEN(SEARCH$) &
	\ FIELD #11%, PAGPNT% AS BPAG$, PAGEND%-PAGPNT% AS FPAG$ &
	\ FNG%=0% &
		! RETURN MATCH INDICATOR &

17130	FNEND &

17199	! &
	&
	&
	&
	!	F U N C T I O N   F N H % &
	&
	&
	&
	! FUNCTION:  FNH% &
	! &
	! SAME AS ABOVE EXCEPT SEARCH PROCEEDS PAST PAGE &
	! BOUNDARIES. &

17200	DEF* FNH% &
	\ FNH%=0% &

17210	T0%=FNG% &
	\ IF T0% <> 0% &
		THEN PAGSTAT%=PAGSTAT% AND -3% &
		\    IF PAGSTAT%=0% &
			THEN GO TO 17210 &
			ELSE FNH%=2% &

17220	FNEND &
	&

17249	! &
	&
	&
	&
	!	F U N C T I O N   F N I S % &
	&
	&
	&
	! FUNCTION: FNIS% &
	! &
	! SETS VARIABLE SEARCH$ TO CONTAIN NEXT VALID TEXT &
	! ARGUMENT.  VALUES ARE: &
	! &
	!	0	SEARCH$ CONTAINS A VALID ARG. &
	! &
	!	1	END OF LINE. VALID ONLY IN CASE &
	!		OF MULTI LINE INSERT. SEARCH$ CONTENTS &
	!		ARE INDETERMANENT. &
	! &
	!	2	COMPLETELY ILLEGAL ARG &

17250	DEF* FNIS% &
	\ T0$=FNGOC$ &
	\ IF T0$=NL$ &
		THEN FNIS%=1% &
		\ GO TO 17280 &
		! IF END OF LINE THEN RETURN A 1% &

17260	FIELD #11%, PGSIZ% AS T1$ &
	\ T0%=INSTR(COMPNT%+1%,T1$,T0$) &
	\ IF T0% <> 0% &
		THEN FIELD #11%, COMPNT% AS T0$, (T0%-1%)-COMPNT% &
							AS SEARCH$ &
		\    COMPNT%=T0% &
		\    FNIS%=0% &
		\    GO TO 17280 &
			! LOOK FOR ENCLOSING CHARACTER. IF FOUND &
			! THEN USE IT TO SET SEARCH. &

17270	FNIS%=2% &

17280	FNEND &
	&

17299	! &
	&
	&
	&
	!	F U N C T I O N   F N E L $ &
	&
	&
	&
	! FUNCTION: FNEL$ &
	! &
	! FUNCTION TO INPUT A LINE OF TEXT FROM THE EDIT &
	! INPUT FILE. NL$ IS RETURNED IF ATTEMPT TO READ &
	! PAST AN END OF FILE, AND PAGSTAT% IS SET TO 1%. &

17300	DEF* FNEL$ &
	\ GO TO 17330 IF PAGSTAT% <> 0% &
	\ ON ERROR GO TO 17320 &
	\ INPUT LINE #I0%, T0$ &
	\ T0$=CVT$$(T0$,1%) &
	\ FNEL$=T0$ &
	\ PAGSTAT%=PAGSTAT% OR 2% IF INSTR(1%,T0$,CHR$(12%)) <> 0% &
	\ GO TO 17340 &

17320	PAGSTAT%=1% &
	\ RESUME 17330 &

17330	FNEL$=NL$ &

17340	ON ERROR GO TO 19000 &
	\ FNEND &
	&

18450	! &
	&
	&
	&
	!	F U N C T I O N   F N G C S % &
	&
	&
	&
	! FUNCTION: FNGCS% &
	! &
	! INPUTS A COMMAND STRING INTO THE TEXT BUFFER. &

18500	DEF* FNGCS% &
	\ T0$=FNC0$ &
	\ T0$=CVT$$(T0$,4%) &
	\ T0%=LEN(T0$) &
	\ COMPNT%=PGSIZ%-T0% &
	\ FIELD #11%, COMPNT% AS T1$, T0% AS T1$ &
	\ LSET T1$=T0$ &
	\ FNGCS%=0% &
	\ FNEND &
	&

18600	! &
	&
	&
	&
	!	F U N C T I O N   F N G O C $ &
	&
	&
	&
	! FUNCTION: FNGOC$ &
	! &
	! GET SINGLE CHARACTER FROM CURRENT COMMAND &
	! STRING. RETURN NL$ IF NO STRING. &

18650	DEF* FNGOC$ &

18660	IF COMPNT%=PGSIZ% &
		THEN FNGOC$=NL$ &
		ELSE FIELD #11%, COMPNT% AS T0$, 1% AS T0$ &
		\    FNGOC$=T0$ &
		\    COMPNT%=COMPNT%+1% &
		\    IF INSTR(1%,FLSH$,T0$) <> 0% &
			THEN GO TO 18660 &
		! IF A CR, LF, FF, NULL, BLANK, &
		! OR TAB THEN FLUSH IT. &

18680	FNEND &
	&

19000	! &
	&
	&
	!	E R R O R    H A N D L I N G &
	&
	&

19010	CLOSE O0%,I0%,C0%,L0% &
	\ OPEN WORK$ FOR INPUT AS FILE 12% &
	\ FILN$(0%)=CVT$$(RIGHT(SYS(CHR$(6%)+CHR$(9%)+CHR$(ERR)),3%),4%) &
			+" at line"+NUM$(ERL)+"in AUTOED "+I$ &
	\ C0=0 &
	\ RESUME 32720 &
		! ERROR HANDLER &
	&

31000	! &
	&
	&
	!	C H A I N    E N T R Y &
	&
	&

31010	E0%=-1% &
	\ GO TO 1000 &
		! SET CHAIN FLAG AND GO TO MAIN CODE. &

32699	! &
	&
	&
	&
	!	E X I T &
	&
	&

32700	PRINT #L0%, FF$; IF L1%=0% &
	\ CLOSE I0%,O0%,L0%,C0%,12% &
	\ OPEN WORK$ FOR INPUT AS FILE 12% &
	\ FILN%(7%,62%)=CS% &
	\ CLOSE 12% &
	\ CHAIN PATCH$ LINE 31000 &
		! NORMAL EXIT USED IN "EX" COMMAND &

32710	PRINT #L0%,FF$; IF L1%=0% &
	\ CLOSE I0%,O0%,L0%,C0% &
	\ OPEN WORK$ FOR INPUT AS FILE 12% &
	\ FILN%(7%,62%)=CS% &
	\ IF WARN%>0% THEN &
		FILN$(0%)="%"+RIGHT(ERMSG$,2%) &
	  ELSE	IF T6%=1% THEN &
			FILN$(0%)="?mismatch" &
		ELSE	FILN$(0%)="?eof" &
		! STORE ERROR MESSAGE FOR RETURN CHAIN. &

32720	CLOSE O0%,I0%,L0%,C0%,12% &
	\ CHAIN PATCH$ LINE 31000 &

32760	T0$=SYS(CHR$(9%)) &
		! CLEAR PROGRAM AND EXIT TO USER DEFAULT RTS. &

32767	END &

