2!		PROGRAM		: ANALY2.B2S
5!		VERSION		: V10.1
6!		EDIT		: L
7!		EDIT DATE	: 10-AUG-92
10	EXTEND
11	!								      &
									      &
									      &
	!		  C O P Y R I G H T				      &
									      &
									      &
  !		      Copyright (C) 1974, 1992 by			      &
  !	        Digital Equipment Corporation, Maynard, Mass.		      &
  !									      &
  !									      &
  !	This software is furnished under a license and may be used and	      &
  !	copied  only  in accordance with the terms of such license and	      &
  !	with the  inclusion  of  the  above  copyright  notice.   This	      &
  !	software  or  any  other copies thereof may not be provided or	      &
  !	otherwise made available to any other person.  No title to and	      &
  !	ownership of the software is hereby transferred.		      &
  !									      &
  !	The information in this software is subject to change  without	      &
  !	notice  and should not be construed as a commitment by Digital	      &
  !	Equipment Corporation.						      &
  !									      &
  !	DIGITAL assumes no responsibility for the use  or  reliability	      &
  !	of its software on equipment that is not supplied by DIGITAL.	      &
  !									      &
  !*******************************************************************	      &
									      &

20	!								      &
									      &
									      &
	!	M O D I F I C A T I O N    H I S T O R Y		      &
									      &
									      &

21	! VER/ED	EDIT DATE	REASON				      &
	! 9.4/REG	03-APR-87	EXPAND SYMBOL ARRAYS		      &
	! 9.4/REG	15-APR-87	ADD BN'S DECNET CHANGES		      &
	! 9.4/REG	18-MAY-87	EXPAND SILMOD ARRAY TO 50 ENTRIES     &
	! 9.4/REG	19-MAY-87	STOP FNCCB IF NO XBUF SEGMENT	      &
	! 9.5/REG	01-SEP-87	ADD VIRT DISK TO MEM LIST,	      &
	!				MOVE 1ST FNP% TO AFTER THE OPEN	      &
	!				  OF THE OUTPUT FILE IN CASE OF ERR   &
	!				CHANGE TEXT BELOW		      &
	! 9.6/REG	28-JAN-88	Put CSRTBL in m2(7) where it belongs  &
	! 9.6/REG	21-MAR-88	Correct MPHYA% calculation in MEMLST  &
	! 				Change DEVTBL and DEVEND lookup	      &
	! 9.6/REG	07-APR-88	Merge FK's changes		      &
	! 9.6/REG	12-APR-88	MINOR CLEANUP			      &
	! 9.6/REG	13-APR-88	FIX DSKLOG/SYSLOG MIXUP		      &
	! 9.6/REG	14-APR-88	USE FNGLOOP FOR NSP'S PERM CDB ANNOT. &
	! 9.7/FEK	20-Mar-89	Enhance Annotations (+ DECnet)	      &
	!				and enlarge annotations arrays	      &
	! 9.7/REG	21-MAR-89	Enlarge SILMOD array from 50 to 255.  &
	! 9.7/REG	25-MAY-89	Fix NO.SEG peeks and DU DSQs	      &
	! 10.0/REG	18-OCT-89	Add NO DDB annotations		      &
	! 10.0/FEK	25-Oct-89	Fix current DU DSQ & MU TSQ chains    &
	! 10.0/REG	07-May-90	Spurious "out-buf" bug (13620 area)   &
	! 10.0/REG	08-Jun-90	Fix JHEAD, FJHEAD		      &
	! 10.1/REG	11-Jul-90	Fix BAKSML pointers		      &
	! 10.1/REG	25-Oct-90	Fix LAT annotation		      &

100	!								      &
									      &
									      &
	!	G E N E R A L    D E S C R I P T I O N			      &
									      &
									      &

110!									      &
	! ANALY2 looks up the annotations for the memory dump that	      &
	! occurs in ANALY3.  The annotations go into array entries	      &
	! keyed to the appropriate memory addresses.			      &
	!								      &
	! ANALY2's FNP%() functions contain an extra parameter which	      &
	! can be used for isolating problems when adding or maintaining	      &
	! the code.							      &
   !									      &

300	!								      &
									      &
									      &
	!	I / O    C H A N N E L S				      &
									      &
									      &

301!	CHANNEL #		USED FOR				      &
   !	   1			OUTPUT					      &
   !	   2			CRASH ERROR LOGGING FILE		      &
   !	   8			NULL DEVICE				      &
   !	   9			WORK2-FILE				      &
   !	  12			CRASH FILE				      &
									      &

400	!								      &
									      &
									      &
	!	V A R I A B L E    D E F I N I T I O N S		      &
									      &
									      &
									      &
   !	VARIABLE NAME		USED FOR				      &
   !									      &
   !	A%()		UTILITY ARRAY					      &
   !	ACCSS%		USED IN PENDING MESSAGE ROUTINE			      &
   !	AD		USED IN FNPEEK FUNCTION				      &
   !	ADD.BLOCK%,ADD.OFFSET% USED IN FNPEEK FUNCTION			      &
   !	ADDR%		ADDRESS TO PEEK AT				      &
   !	ADDRESS%,ADDRESS1% CURRENT MEM ADDRESSES DURING DUMP		      &
   !	BASE.BLOCK%	USED IN FNPEEK FUNCTION				      &
   !	BYT.POS$	BYTE POSITION BLOCK TOT.USED$ WHERE NEXT ERROR	      &
   !	BYTE%()		HOLDS ASCII OF 64 CHAR DUMP CHUNK		      &
   !	C$		CARRIAGE RETURN/LINE FEED			      &
   !	C%		COUNTING VARIABLE IN DUMP ROUTINE		      &
   !	C0%		COUNTING VARIABLE IN DUMP ROUTINE		      &
   !	CC%()		STORAGE ARRAY					      &
   !	CF%		<>0 MEANS COULDN'T FIND ANNOTATION SYMBOL	      &
   !	CR.LOGFIL$	CRASH ERROR LOGGING FILE			      &
   !	D$		CRASH FILE I/O BUFFER				      &
   !	D.UMP%		CORE DUMP/NODUMP INDICATOR			      &
   !			0 = NO CORE DUMP				      &
   !			1 = REGULAR, OCTAL DUMP				      &
   !			2 = Regular, but no XBUF dump			      &
   !	DIAGNOSE%	FOR MAINTENANCE ONLY				      &
   !	DUP%		DUPLICATE LINE COUNT				      &
   !	E$		ERROR MESSAGE HOLDER				      &
   !	END.BLOCK%,END.OFFST% END OF SEGMENT				      &
   !	EPMM		$$EPMM AS AN UNSIGNED INTEGER			      &
   !	ER.COD%		ERROR CODE					      &
   !	ER.LOG$		NUMBER OF ERRORS LOGGED AND REPEATED FOR ERROR	      &
   !			TYPE J%						      &
   !	ER.RCV$		NUMBER OF ERRORS RECEIVED FOR ERROR TYPE	      &
   !			J% INCLUDING REPEATS.				      &
   !	ERR.TIM%	TIME ERRORS RECEIVED				      &
   !	FILE.NAME$()	HOLDS FILE NAMES				      &
   !	FPL.SEG%	FIP POOL DUMP SEGMENT NUMBER			      &
   !	FPLAP6%		MAPPING ADDRESS FOR FIP				      &
   !	FPL.ST		FIP POOL ADDRESS AS AN UNSIGNED INTEGER		      &
   !	FPL.END		UPPER FIP POOL LIMIT AS AN UNSIGNED INTEGER	      &
   !	G%,G$,G%(),G$(),G0%(),G0$(),G0%,G0$,G.FREE%,G1%,G2%,G3%,G4%,	      &
   !	G5%,G6%,G7%,G8%,G9%,G7$,G8$,G9$ UTILITY VARIABLES IN ANNOTATIONS      &
   !	I%,I1%,I2%	UTILITY VARIABLE				      &
   !	I0$		INPUT FILE					      &
   !	J%		UTILITY VARIABLE				      &
   !	K%		UTILITY VARIABLE				      &
   !	KAR5%		HOLDS CURRENT CONTENTS THEREOF			      &
   !	LINE.%		CURRENT PRINTING LINE OF 64 CHAR CHUNK		      &
   !	MAP%()		LAYOUT OF CRASH FILE				      &
   !	MAX.SEG%	HIGHEST SEGMENT NUMBER, CURRENTLY = JCR		      &
   !	MSCP.SEG%	MSCP REGION DUMP SEGMENT NUMBER			      &
   !	OCT.ST%		PARAMETER VARIABLE				      &
   !	PMB%		CHECK FOR MESSAGES TO ERRCPY FLAG:		      &
   !			0	MEANS DON'T BOTHER			      &
   !			<>0	MEANS HAVE TO CHECK AND PMB% IS		      &
   !				THE POINTER TO THE LIST OF		      &
   !				PENDING MESSAGES FOR ERRCPY		      &
   !				(RECEIVER ID 'ERRLOG')			      &
   !	M0$		UTILITY STRING					      &
   !			USED IN CRASH ERROR LOGGING ROUTINE		      &
   !	O0$		OUTPUT FILE					      &
   !	Q%		ADDRESS TO 'PEEK' AT IN FNP%			      &
   !	Q$		OCTAL STRING					      &
   !	Q0%		FUNCTION UTILITY VARIABLE			      &
   !	Q9%		SIZE OF THE CRASH FILE				      &
   !	RECRD.ALW$	NUMBER OF ALLOWABLE ERROR RECORDS FOR ERROR TYPE J%.  &
   !	RECRD.LOG$	NUMBER OF RECORDS LOGGED FOR THIS ERROR TYPE J%.      &
   !	REPEAT%		ERROR REPEAT COUNT				      &
   !	ROOT.SEG%	MONITOR ROOT DUMP SEGMENT NUMBER		      &
   !	RPT%		FLAG INDICATING IF WE SHOULD CHAIN TO ERRDIS	      &
   !			TO APPEND THE CRASH ERROR LOG FILE REPORT	      &
   !	S$		STRING TO BE PRINTED, UTILTY STRING		      &
   !	SAT.OFF%	OFFSET INTO SATBUF				      &
   !	SATBUF%		POINTER TO SATBUF				      &
   !	START.BLOCK%	BEGINNING OF SEGMENT				      &
   !	STB%		SYMBOL TABLE DUMP FLAG				      &
   !	T$		TAB						      &
   !	T0$		ANLSXX.TMP					      &
   !	TOO.MANY%	-1 MEANS TOO MANY ANNOTATIONS - SOME POINTER WAS      &
   !			 IN LIMBO - PROBABLY "FREE #x"			      &
   !	TOT.LOG$	TOTAL ERRORS LOGGED (INCLUDING REPEATS).	      &
   !	TOT.REC$	TOTAL ERRORS RECEIVED (INCLUDING REPEATS).	      &
   !	TOT.USED$	BLOCK NUMBER FOR START OF NEXT ERROR RECORD.	      &
   !			RECORD IS TO BE WRITTEN.			      &
   !	TOT.LIM$	LIMIT ON NUMBER OF ERROR BLOCKS IN FILE.	      &
   !	VN%		GATE FOR DIFFERENT VERSION PRINTOUTS		      &
   !	W%		UTILITY VARIABLE				      &
   !	W$		UTILITY STRING					      &
   !	WDE%		LINES PER CHUNK TO PRINT			      &
   !	WORD%()		32-WORD CHUNK ARRAY				      &
   !	XBUF.SEG%	XBUF DUMP SEGMENT NUMBER			      &
   !	XCON%		SYSTEM CONFIGURATION WORD			      &
   !									      &

800	!								      &
									      &
									      &
	!	F U N C T I O N / S U B R O U T I N E    D E S C .	      &
									      &
									      &
									      &
   !	FUNCTION/SUBROUTINE		USE				      &
   !									      &
   !	FNB$			GET A 3 POSITION OCTAL STRING		      &
   !	FNE$			RETURN ERROR MESSAGE			      &
   !	FNF()			MAKE FLOATING POINT FROM INTEGER	      &
   !	FNGADD%,FNGLOOP%	ANNOTATION FUNCTIONS			      &
   !	FNG%			EXTRACT INFO FROM CORE COMMON STRING	      &
   !	FNJCR.P%		Peek into the JCR			      &
   !	FNO$			GET A 6 POSITION OCTAL STRING		      &
   !	FNP%			CORRESPONDS TO A 'PEEK'			      &
   !	FNPEEK%			CALLED BY FNP% - DOES THE PEEK		      &
   !	FNSR5%			SHIFT INTEGER RIGHT 5 BITS		      &
   !	FNXBUF.P%		Peek into XBUF				      &
   !	LINES 10700-10740	MESSAGE RECEIVERS			      &
   !	LINES 11100-12900	OCTAL DUMP OF CORE			      &
   !	LINES 13000-14010	ANNOTATION ROUTINES			      &
   !	LINES 14500-14700	CRASH ERROR EXTRACTION ROUTINE		      &
									      &

900	!								      &
									      &
									      &
	!	D I M E N S I O N    S T A T E M E N T S		      &
									      &
									      &

920	DIM A%(30%), QUE.NAME$(10%,2%), OFFSET%(10%,2%), ADJ.TXT$(5%)	      &

950	DIM #11%,	PAT%(17%),PAT$(17%)=8%,				      &
			SILMOD%(255%,20%),				      &
			SILPAT%(24%,63%),				      &
			G%(128%), G$(128%)=8%,				      &
			GX%(32767%,1%), DUPLST%(2000%,1%), GX$(15000%)=32%    &
	\ DIM #10%,	M%(80%), M2%(80%), DEC%(40%),			      &
			CC%(30%), FILE.NAME$(5%)=32%, MAP%(10%,3%)	      &
		! PAT()	- INSTALLED PATCHES, E.G.,$$0301		      &
		! SILMOD(,) - ENTRIES FOR SIL DIRECTORY - MAXIMUM OF 255      &
		!	(,0)=SE.NAM					      &
		!	(,1)=SE.NAM					      &
		!	(,2)=SE.IDN					      &
		!	(,3)=SE.IDN					      &
		!	(,4)=SE.BLK					      &
		!	(,5)=SE.STB					      &
		!	(,6)=SE.STN					      &
		!	(,7)=SE.LOD					      &
		!	(,8)=SE.SIZ					      &
		!	(,9)=SE.XFR					      &
		!	(,10)=SE.SZD					      &
		!	(,11)=SE.OVB					      &
		!	(,12)=SE.OVN					      &
		!	(,13)=SE.OFF					      &
		!	(,14)=0						      &
		!	(,15)=0						      &
		!	(,16)=VALUE FOR TERPAT,EMTPAT,FIPPAT ETC.	      &
		!	(,17-20)=0					      &
		! SILPAT(,) - CONTENTS OF XXXPAT PATCH SPACE (64 WORDS)	      &
		! G%(),G$() - POINTERS AND NAMES USED FOR ANNOTATION	      &
		! GX%(X%,Y%) - WHERE  X% = MEMORY ADDRESS		      &
		!		      Y% = 0% -> INTO ANNOTATION TABLE	      &
		!			   1% -> INTO DUPLICATE LIST	      &
		! DUPLST%(X%,Y%) -    X% = NEXT FREE ENTRY		      &
		!		      Y% = 0% -> INTO ANNOTATION TABLE	      &
		!			   1% LINK -> INTO DUPLST TABLE	      &
		! GX$(X%)	      X% = NEXT FREE ANNOTATION		      &
		! MONITOR TABLES - PART I STORED IN M%()		      &
		! WHERE POSSIBLE, THESE SUBSCRIPTS ARE USED FOR		      &
		! CONSISTENCY WITH SYSTAT - THOSE THAT DIFFER ARE *'D	      &
		! M%(1)		FIJBDA*					      &
		! M%(3)		FIJOB*					      &
		! M%(5)		DEVCNT					      &
		! M%(7)		DEVPTR					      &
		! M%(9)		SATBUF* - NOT USED (SEE CRASAV)		      &
		! M%(11)	JOBTBL					      &
		! M%(13)	JBSTAT					      &
		! M%(15)	JBWAIT					      &
		! M%(17)	UNTCLU					      &
		! M%(19)	UNTCNT					      &
		! M%(21)	SATCTL					      &
		! M%(23)	PATCH*					      &
		! M%(25)	SATCTM					      &
		! M%(29)	UNTOPT					      &
		! M%(31)	MEMLST					      &
		! M%(33)	(JCRSIZ) - SIZE OF JOB DATA STRUCTURE	      &
		! M%(35)	LATAP5					      &
		! M%(37)	$$LATS					      &
		!							      &
		! M2%() - PACKAGE LOCATION UTILITY ARRAY (30) AND	      &
		!   MONITOR TABLES - PART II + EXTRAS			      &
		! M2%(1)	LRGFIL*					      &
		! M2%(3)	FREES					      &
		! M2%(5)	DEVNAM					      &
		! M2%(7)	CSRTBL					      &
		! M2%(9)	DEVOKB					      &
		! M2%(11)	TTYHCT					      &
		! M2%(13)	JOBCNT					      &
		! M2%(15)	RTSLST					      &
		! M2%(17)	ERLCTL					      &
		! M2%(19)	SNDLST					      &
		! M2%(21)	DSKLOG					      &
		! M2%(23)	DEVSYN					      &
		! M2%(25%)	($$JCR6) - START OF THE JOB CONTROL REGION    &
		! M2%(27%)						      &
		! M2%(29%)	FCBLST					      &
		! M2%(31%)	$$EPMM - END OF R/W MON AREA, NOT USED	      &
		! M2%(33%)	X.TAB - TABLE OF DUMP SEGMENTS		      &
		! M2%(35%)	X.TABS - SIZE OF X.TAB			      &
		! M2%(37%)	X.CON - FLAG WORD, HAS MANY GOODIES	      &
		! M2%(39%)	X.MONS - SIZE OF R/W MON DUMP		      &
		! M2%(41%)	X.SCS - CLUSTER SIZE OF CRASH.SYS DISK	      &
		! M2%(43%)	CRASAV - POINTS TO BEGINNING OF SATBUF	      &
		! M2%(45%)	DDCTBL - POINTS TO BEGINNING OF DDCTBL	      &
		! M2%(47%)	UCTTBL - POINTS TO BEGINNING OF UCTTBL	      &
		! M2%(49%)	STSTBL -				      &
		! M2%(51%)	TTFMSB - FMS SUPPORT SYMBOL		      &
		! M2%(53%)	FIPOOL - ADDRESS OF FIP POOL		      &
		! M2%(55%)	SATEND - POINTS TO SAT END TABLE	      &
		! M2%(57%)      UNTLVL - UNIT LEVEL OF DISK		      &
		! M2%(59%)	LOWAD  - LOW ADDRESS OF MEMORY PARITY ERROR   &
		! M2%(61%)	NULRTS - THE NULL RTS BLOCK ADDRESS	      &
		! M2%(63%)	$$CRSZ - (NOT USED - SEE X.MONS)	      &
		! M2%(65%)	CSR.KB - USED TO FIND PK JOB NUMBERS	      &
		! M2%(67%)	FAKDDB - used to find fake devices	      &
		!							      &
		! ITEMS NEEDED IF DECNET'S CONFIGURED			      &
		! DEC%(1%)	NSPCCB -- <> MEANS DECNET IS THERE	      &
		! DEC%(2%)	LNKMAX					      &
		! DEC%(3%)	NODLST -- <> MEANS NSP ENABLED		      &
		! DEC%(4%)	NSPLST					      &
		! DEC%(5%)	SIDBUF					      &
		! DEC%(6%)	NSPLLB					      &
		! DEC%(7%)	NSPCDB					      &
		! DEC%(8%)	LLTBUF -- <> MEANS NSP ENABLED		      &
		!			Contorted address of LLT buffer	      &
		! DEC%(9%)	NSPQUE					      &
		! DEC%(10%)	TRNQUE					      &
		! DEC%(11%)	CONQUE					      &
		! DEC%(12%)	NETPOL private buffer pool free list	      &
		! DEC%(13%)	IDLNOB Idle Node Block list		      &
		! DEC%(14%)	NSPQ2F Work blocks waiting for FIP	      &
		! DEC%(15%)	NSPFCQ Work blocks returned from FIP	      &
		! DEC%(16%)	ENDCHE MMU value of end-node cache	      &
		! DEC%(17%)	RTEMMU MMU address of cost/hops vector	      &
		! DEC%(18%)	OAJMMU MMU address of adjacency vector	      &
		! DEC%(19%)	MTXMMU MMU address of routing matrix	      &
		! DEC%(20%)	RTMSTA Routing message start address	      &
		! DEC%(21%) 	EVTMMU MMU value for Event logger database    &
		! DEC%(22%)	ADJFLG Start of Adjacency MMU pointers	      &
		! DEC%(23%)	NSPJDB Pointer to NSP's JDB		      &

999	!								      &
									      &
									      &
	!	M A I N    C O D I N G    A R E A			      &
									      &
									      &

1000	ON ERROR GOTO 19000						      &
	\ IF (DIAGNOSE% AND 64%)					      &
		THEN PRINT "Starting ANALY2 - ";DATE$(0%);TIME$(0%);	      &
			"CPU time";TIME(1%)				      &
	\	STOP IF (DIAGNOSE% AND 128%)				      &
	! SET UP STANDARD ERROR TRAP.					      &

1010	I$="V10.1-L"							      &
	! SET UP VERSION/EDIT #.					      &

1030	IF E0%<>2% THEN							      &
		PRINT "?Illegal Entry - Please 'RUN ANALYS'"		      &
	\	GOTO 32760 UNLESS DIAGNOSE%				      &
	! ONLY CHAINING FROM ANALYS IS ALLOWED.				      &

1050	CHANGE SYS(CHR$(12%)) TO A%					      &
	\ PKG.LOC$="["+NUM1$(A%(6%))+","+NUM1$(A%(5%))+"]"		      &
	\ PKG.LOC$="_"+CHR$(A%(23%))+CHR$(A%(24%))			      &
		+NUM1$(A%(25%))+":"+PKG.LOC$				      &
		IF A%(26%) AND 1%					      &
	\ IF A%(3%)+SWAP%(A%(4%))<>15%*2% THEN				      &
		PRINT "?ANALY2 must be compiled"			      &
	\	GOTO 32760 UNLESS DIAGNOSE%				      &
		! BUILD NAME OF DEVICE AND ACCOUNT OF LAST OPENED FILE.	      &
		! WE MUST BE A COMPILED FILE IF WE WANT TO BE SURE THAT	      &
		! THIS NAME IS REALLY OUR PACKAGE LOCATION.		      &

1100	OPEN WORK1.FILE$ FOR INPUT AS FILE 10%, MODE 256%		      &
	\ M1%=-1%	! SET A HANDY CONSTANT				      &
	\ JOBTBL%=M%(11%)						      &
	\ SNDLST%=M2%(19%)						      &
	\ FCBLST%=M2%(29%)						      &
	\ EPMM=FNF(M2%(31%))						      &
	\ DDCTBL%=M2%(45%)						      &
	\ UCTTBL%=M2%(47%)						      &
	\ FPLAP6%=M2%(53%)						      &
	\ DECNET%=(DEC%(1%)<>0%)					      &
	\ D.UMP%=CC%(1%)						      &
	\ FXMONS%=CC%(2%)						      &
	\ HAND.IDX%=CC%(3%)						      &
	\ ROOT.SEG%=CC%(12%)						      &
	\ FPL.SEG%=CC%(13%)						      &
	\ XBUF.SEG%=CC%(14%)						      &
	\ FPL.ST=FNF(CC%(16%))						      &
	\ FPL.END=FNF(CC%(17%))						      &
	\ MSCP.SEG%=CC%(18%)						      &
	\ JCTRL.SEG%=CC%(19%)						      &
	\ JHEAD.SEG%=CC%(21%)						      &
	\ FJHEAD.SEG%=CC%(22%)						      &
	\ NUM.DECNT.UNITS%=CC%(9%)					      &
	\ XM0.DDB.PTR%=CC%(10%)						      &
	\ I0$=FILE.NAME$(1%)						      &
	\ O0$=FILE.NAME$(2%)						      &
									      &
	! EXTRACT INFORMATION FROM FILE NAME PASSED IN CORE COMMON.	      &

1400	C$=CHR$(13%)+CHR$(10%)						      &
	\ T$=CHR$(9%)							      &
	\ S$=I0$							      &
	\ NL$=""							      &
	\ OPEN S$ FOR INPUT AS FILE 12%, MODE 256%+8192%		      &
	\ FIELD #12%, 512% AS D$					      &
	\ S$=O0$							      &
	\ IF HAND.IDX%=0% THEN						      &
		OPEN S$ FOR INPUT AS FILE 1%, MODE 2%			      &
	ELSE	IF HAND.IDX%=14% THEN					      &
			OPEN S$ FOR OUTPUT AS FILE 1%, MODE 128%	      &
		ELSE	IF HAND.IDX%=6% THEN				      &
				OPEN S$ AS FILE 1%, MODE 8192%		      &
			ELSE	OPEN S$ AS FILE 1%			      &
	! OPEN THE FILE BASED ON HANDLER INDEX:				      &
	!	0 OR 14	DISK OR TAPE -- APPEND MODE			      &
	!	OTHER	PLAIN OPEN					      &

1420	E%=0%								      &
	\ JCR.ST=(MAP%(JCTRL.SEG%,0%)+M1%)*512%				      &
	\ JCRSIZ=FNF(FNP%(0%,M%(33%)))					      &
	\ GOSUB 12000 IF ((DIAGNOSE% AND 63%)=0%) OR (DIAGNOSE% AND 4%)	      &
	UNLESS (((DIAGNOSE% AND 4%)<>0%) AND ((DIAGNOSE% AND 256%)<>0%))      &
		OR (DIAGNOSE% AND 63%)=8%				      &
	\ PRINT "Exiting ANALY2 - ";DATE$(0%);TIME$(0%);		      &
			"CPU time";TIME(1%) IF (DIAGNOSE% AND 64%)	      &
	\ GOTO 32767 IF (DIAGNOSE% AND 4%) UNLESS (DIAGNOSE% AND 8%)	      &
	\ CLOSE 1%, 10%, 11%, 12%					      &
	\ S$=PKG.LOC$+"ANALY3"						      &
	\ CHAIN S$ LINE 31000						      &
	! GO GET ANNOTATIONS						      &
	! SET UP CORE COMMON, AND CHAIN TO ERRDIS.			      &
									      &

10000	!								      &
									      &
									      &
	!	S U B R O U T I N E S					      &
									      &
									      &

12000	OPEN 'ANAL'+RIGHT(NUM1$(100%+((PEEK(518%) AND 255%)/2%)),2%)+	      &
		'.TMP' FOR INPUT AS FILE 11%, RECORDSIZE 4096%, MODE 256%     &
	\ IF D.UMP%=0% THEN						      &
		GOTO 12590						      &
		!							      &
		!	C O R E    D U M P				      &
		!							      &
		! SKIP DUMP IF /NODUMP SPECIFIED.			      &

12510	DUPLST%(I%,0%),DUPLST%(I%,1%)=0% FOR I%=2000% TO 0% STEP M1%	      &
	\	GX%(I%+1%,0%),GX%(I%+1%,1%)=0% FOR I%=32766% TO M1% STEP M1%  &
	\	GX.MAX%=15000%						      &
	\	DUP.MAX%=2000%						      &
	\	MAX.BUF%=2000%						      &
	\	GX.FREE%,DUP.FREE%,TOO.MANY%,FPL%,CF%=0%		      &
	\	E%,E1%=0%						      &
	\	GOSUB 14600	! go init some XBUF variables		      &
	\	GOSUB 13000						      &
	\	I%=FNE.A%("Monitor")					      &
	\	GOTO 12590 IF TOO.MANY%					      &
	\	E%,E1%=0%						      &
	\	GOSUB 14100 IF MAP%(MSCP.SEG%,0%)			      &
	\	I%=FNE.A%("MSCP")					      &
	\	GOTO 12590 IF TOO.MANY%					      &
	\	E%,E1%=0%						      &
	\	GOSUB 14300	! UNA/QNA annotations			      &
	\	I%=FNE.A%("Ethernet")					      &
	\	GOTO 12590 IF TOO.MANY%					      &
	\	E%,E1%=0%						      &
	\	GOSUB 14500 IF MAP%(XBUF.SEG%,0%)			      &
	\	I%=FNE.A%("XBUF")					      &
	\	GOTO 12590 IF TOO.MANY%					      &
		! PRINT HEADER.						      &
		! GO SET UP ALL THE ANNOTATIONS.			      &
		! IF TOO.MANY<>0 THEN SOME POINTER (PROBABLY 'FREE #n')	      &
		!	WAS IN LIMBO - WARN EM BUT DO THE DUMP		      &
		! DO MSCP ANNOTATIONS IF THE MSCP SEGMENT IS PRESENT.	      &
		!	(MSCP region must come before ETHERNET region)	      &
		! Do ETHERNET region annotations			      &
		! DO XBUF ANNOTATIONS IF THE XBUF SEGMENT IS PRESENT.	      &

12590	RETURN								      &
		! GENERAL RETURN FROM DUMP SUBROUTINE.			      &

13000	!								      &
									      &
									      &
	!	C C L ' S						      &
									      &

13010	G$='CCLLST'							      &
	\ E%=0%								      &
	\ GOSUB 14000							      &
	\ GOTO 13100 IF CF%						      &
		! FIND BEGINNING OF CCL LIST IF WE CAN			      &
		! (POINTED TO BY G%)					      &

13020	G%=FNP%(1%,G%)							      &
	\ E1%=M1% IF E%							      &
	\ GOTO 13100 IF E%						      &
	\ G0%=G0%+1%							      &
	\ GOTO 13100 IF G0%>MAX.BUF%					      &
	\ GOTO 13100 UNLESS G%						      &
	\ G1%=FNP%(2%,G%+2%)						      &
	\ G2%=FNP%(3%,G%+4%)						      &
	\ E1%=M1% IF E%							      &
	\ GOTO 13100 IF E%						      &
	\ G0$=''							      &
	\ IF G1%>G2% THEN						      &
		PRINT #1%, C$;"?Start CCL > end CCL.";			      &
	\	E1%=M1%							      &
	\	GOTO 13100						      &
		! G%=	CCL LIST POINTER				      &
		! G0%=	INDEX OF ANNOTATION ARRAY			      &
		! GO ON TO NEXT LIST IF WE RAN OUT OF CCL'S		      &
		! G1%=	BEGINNING OF ASCII STRING FOR ONE CCL		      &
		! G2%=	END OF ASCII STRING FOR THAT CCL		      &
		! IF END IS BEFORE BEGINNING, WE HAVE A PROBLEM.	      &

13030	G0$=G0$+'-' IF G1%=G2%						      &
	\ G3%=FNP%(4%,G1%) AND 255%					      &
	\ E1%=M1% IF E%							      &
	\ GOTO 13100 IF E%						      &
	\ GOTO 13040 IF G3%=255%					      &
	\ G0$=G0$+CHR$(G3%)						      &
	\ G1%=G1%+1%							      &
	\ G0$=G0$+'-' IF G1%=G2%					      &
	\ G3%=SWAP%(FNP%(5%,G1%+M1%)) AND 255%				      &
	\ GOTO 13040 IF G3%=255%					      &
	\ G0$=G0$+CHR$(G3%)						      &
	\ G1%=G1%+1%							      &
	\ GOTO 13030							      &
		! ADD A "-" IF WE ARE AT END OF CCL			      &
		! G3%=	NEXT ASCII CHARACTER IN CCL			      &
		! ADD IT TO THE STRING G0$				      &
		! INCREMENT G1% TO THE NEXT BYTE			      &
		! SEE IF WE ARE DONE					      &
		! ADD THE CHARACTER TO THE CCL STRING			      &

13040	I%=FNGADD%(SEGMNT%,G%,' CCL #'+NUM1$(G0%)+' "'+G0$+'"')		      &
	\ GOTO 13020							      &
		! PUT THE ANNOTATION IN THE ARRAY			      &
		! AND GO DO SOME MORE					      &
									      &

13100	!								      &
									      &
									      &
	!	R E C E I V E R ' S					      &
									      &

13110	G%=SNDLST%							      &
	\ E%=0%								      &
	\ G0%,G6%=0%							      &
	\ G6%=M1% UNLESS DECNET%					      &
		! ALSO SCAN SPECIAL LIST OF RECEIVERS IF DECNET'S INSTALLED   &

13120	G%=FNP%(6%,G%)							      &
	\ E1%=M1% IF E%							      &
	\ GOTO 13200 IF E%						      &
	\ G0%=G0%+1%							      &
	\ GOTO 13200 IF G0%>MAX.BUF%					      &
	\ IF G%=0% THEN							      &
		GOTO 13200 IF G6%					      &
	\	G%=FNP%(7%,DEC%(4%))	! DEC%(4%)=NSPLST		      &
	\	E1%=M1% IF E%						      &
	\	GOTO 13200 IF E%					      &
	\	G6%=M1%							      &
	\	GOTO 13200 UNLESS G%					      &
		! ANY MORE? CHECK NSPLST IF APPROPRIATE			      &

13130	GPK1%=FNP%(8%,G%+2%)						      &
	\ GPK2%=FNP%(9%,G%+4%)						      &
	\ GPK3%=FNP%(10%,G%+6%)						      &
	\ I%=FNGADD%(SEGMNT%,G%,' RIB '+NUM1$(G0%)+' "'			      &
		+CHR$(GPK1% AND 255%)+CHR$(SWAP%(GPK1%) AND 255%)	      &
		+CHR$(GPK2% AND 255%)+CHR$(SWAP%(GPK2%) AND 255%)	      &
		+CHR$(GPK3% AND 255%)+CHR$(SWAP%(GPK3%) AND 255%)+'"')	      &
	\ E1%=M1% IF E%							      &
	\ GOTO 13200 IF E%						      &
	\ G1%=G%+16%							      &
	\ G2%=0%
13140	G1%=FNP%(11%,G1%)						      &
	\ E1%=M1% IF E%							      &
	\ GOTO 13200 IF E%						      &
	\ G2%=G2%+1%							      &
	\ GOTO 13150 UNLESS G1%						      &
	\ G3%=FNP%(12%,G1%+2%)						      &
	\ G$=" MSG "+NUM1$(G2%)+" RIB "+NUM1$(G0%)			      &
	\ G$=G$+" map'd data" IF G3% AND 31%				      &
	\ I%=FNGADD%(SEGMNT%,G1%,G$)					      &
	\ GOTO 13140 IF (G3% AND 31%) OR (G3%=0%)			      &
	\ G4%=FNP%(13%,G3%)						      &
	\ E1%=M1% IF E%							      &
	\ GOTO 13200 IF E%						      &
	\ I%=FNGLOOP%(SEGMNT%,FNSR5%(G3%),FNSR5%(G4%),' Data,'+G$)	      &
	\ GOTO 13140
13150	G1%=G%+22%							      &
	\ G2%,G4%=0%
13160	G1%=FNP%(14%,G1%)						      &
	\ E1%=M1% IF E%							      &
	\ GOTO 13200 IF E%						      &
	\ G2%=G2%+1%							      &
	\ GOTO 13200 IF G2%>MAX.BUF%					      &
	\ GOTO 13120 UNLESS G1%						      &
	\ I%=FNGADD%(SEGMNT%,G1%,					      &
			' LLB #'+NUM1$(G2%)+' of RIB #'+NUM1$(G0%))	      &
	\ G3%=FNP%(15%,G1%+4%)						      &
	\ G4%=G4%+1%							      &
	\ GOTO 13160 UNLESS G3%						      &
	\ I%=FNGADD%(SEGMNT%,G3%,					      &
			" LLX #"+NUM1$(G4%)+" of RIB #"+NUM1$(G0%))	      &
	\ I%=FNCCB%(FNP%(16%,G3%+2%),"","LLX DATA SUB CH CTRL")		      &
	\ I%=FNCCB%(FNP%(17%,G3%+18%),"","LLX INT/LS SUB CTRL")		      &
	\ GOTO 13160							      &
									      &

13200	!								      &
									      &
									      &
	!	J O B ' S						      &
									      &
									      &

13210	E%=0%								      &
	\ G8%=M2%(21%)							      &
	\ G$='DEVNKB'							      &
	\ GOSUB 14000							      &
	\ G7%=G%							      &
	\ GOTO 13300 IF CF%						      &
	\ G0%=1%							      &
	\ G%=JOBTBL%+2%							      &
	\ G9%=FNP%(18%,M2%(25%))					      &

13220	G1%=FNP%(19%,G%)						      &
	\ E1%=M1% IF E%							      &
	\ GOTO 13270 IF E%						      &
	\ GOTO 13300 IF (G1%=M1%)					      &
	\ GOTO 13270 UNLESS G1%						      &
	\ G2%=FNP%(20%,G1%+12%)						      &
	\ E1%=M1% IF E%							      &
	\ GOTO 13270 IF E%						      &
	\ I%=FNGADD%(SEGMNT%,G1%,' JDB of job '+NUM1$(G0%)+', RTS='+	      &
			CVT$$(RAD$(FNP%(21%,G2%+2%))			      &
			+RAD$(FNP%(22%,G2%+4%)),2%))			      &
	\ G2%,G3%=G0%*2%*JCRSIZ						      &
	\ G2%=(G2%+(G9%*64.))/64%					      &
	\ G0$=FNO$(G2%)+RIGHT(FNB$(G3% AND 63%),2%)			      &
	\ I%=JCRSIZ/32%							      &
	\ I%=FNGLOOP%(JCTRL.SEG%,G2%,I%,' JCR of job '+NUM1$(G0%)+' = '+G0$)  &
	\ G2%=FNP%(23%,G1%+6%)						      &
	\ I%=FNGADD%(SEGMNT%,G2%,' WRK of job '+NUM1$(G0%))		      &
	\ JCR=FNF(G3%)	! SAVE THE JCR ENTRY FOR THIS JOB POINTER	      &
	\ G3%=FNJCR.P%(24%,JCR+60%,0%) ! WDB POINTER			      &
	\ IF G3% THEN							      &
		E1%=M1% IF E%						      &
	\	GOTO 13225 IF E%					      &
	\	FOR G2%=0% WHILE G3%<>0% AND G2%<MAX.BUF%		      &
	\		I%=FNGADD%(SEGMNT%,G3%-12%,' WDB #'+num1$(g2%+1%)+    &
					' of job '+NUM1$(G0%))		      &
	\		G3%=FNP%(25%,G3%-12%)				      &
	\		E1%=M1% IF E%					      &
	\		GOTO 13225 IF E%				      &
	\		I%=FNP%(26%,G3%)	! SET SEGMENT%		      &
	\	NEXT G2%						      &
	!	If there is a WDB pointer, then find which pool it's in	      &
	!	and anotate it.  Follow the pointer to the next one, if	      &
	!	there is one, and count them.				      &

13225	G4%=FNJCR.P%(27%,JCR+96%,0%) ! pending ASYNC completion list	      &
	\ E1%=M1% IF E%							      &
	\ GOTO 13230 IF E%						      &
	\ FOR G2%=0% WHILE G4%<>0% AND G2%<MAX.BUF%			      &
	\	I%=FNGADD%(SEGMNT%,G4%,' ASTQ #'+NUM1$(G2%)+		      &
				' of job '+NUM1$(G0%))			      &
	\	G4%=FNP%(28%,G4%)					      &
	\	E1%=M1% IF E%						      &
	\	GOTO 13230 IF E%					      &
	\ NEXT G2%							      &
	\ G5%=FNJCR.P%(29%,JCR+100%,0%) ! AST block for simulated async	      &
	\ E1%=M1% IF E%							      &
	\ GOTO 13230 IF E%						      &
	\ I%=FNGADD%(SEGMNT%,G5%,' ASTB of job '+NUM1$(G0%)) IF G5%	      &
	\ G6%=FNJCR.P%(30%,JCR+106%,M1%) ! some other pointer		      &
	\ E1%=M1% IF E%							      &
	\ GOTO 13230 IF E%						      &
	\ IF G6% THEN							      &
		SEGMNT%=XBUF.SEG%					      &
	\	SEGMNT%=ROOT.SEG% UNLESS (G6% AND 31%)			      &
	\	NO.SEG%=(MAP%(SEGMNT%,0%)=0%)				      &
	\	G6%=FNR7R%(G6%) IF SEGMNT%=XBUF.SEG%			      &
	\	I%=FNGADD%(SEGMNT%,G6%," AUX PTR for job "+NUM1$(G0%))	      &
						UNLESS NO.SEG%		      &

13230	G2%=FNP%(31%,G1%)						      &
	\ G3%=FNP%(32%,G2%)	! set SEGMNT% for this IOB		      &
	\ I%=FNGADD%(SEGMNT%,G2%,' IOB of job '+NUM1$(G0%))		      &
	\ FOR G3%=0% TO 30% STEP 2%					      &
	\	G4%=FNP%(33%,G2%+G3%)					      &
	\	E1%=M1% IF E%						      &
	\	GOTO 13240 IF E%					      &
	\	GOTO 13240 UNLESS G4%					      &
	\	G6%=(FNP%(34%,G4%) AND 255%)				      &
	\	E1%=M1% IF E%						      &
	\	GOTO 13240 IF E%					      &
	\	SEG.TMP%=SEGMNT%					      &
	\	WARN$=NL$						      &
	\	GOSUB 13290	! uses FNP%(35%-54%)			      &
	\	I%=FNGLOOP%(SEG.TMP%,FNSR5%(G4%),G5%,WARN$+' CH #'+	      &
			NUM1$(G3%/2%)+' ('+G0$+':) of job '+NUM1$(G0%))
13240	NEXT G3%							      &
		! EACH ENTRY IN THE IOB IS NON-ZERO IF THE CHANNEL IS OPEN;   &
		! IF SO, POINTS TO A DDB (DEVICE OPEN) OR 'WCB' ON	      &
		! LARGE-FILE SYSTEMS					      &

13250	FOR G3%=0% TO 30% STEP 2%					      &
	\	G4%=FNJCR.P%(55%,JCR+64%+G3%,M1%)	! Don't set segment   &
	\	G4%=FNJCR.P%(56%,JCR+64%+G3%,0%) UNLESS G4% AND 31%	      &
	\	E1%=M1% IF E%						      &
	\	GOTO 13260 IF E%<>0% OR G4%=0%				      &
	\	IF G4% AND 31% THEN					      &
			NO.SEG%=(MAP%(XBUF.SEG%,0%)=0%)			      &
	\		WARN$=" LOG "					      &
	\		WARN$=" ICF " IF G3%				      &
	\		G4%=FNR7R%(G4%)					      &
	\		I%=FNGLOOP%(XBUF.SEG%,G4%,9%,WARN$+"CBB CH #"+	      &
				NUM1$(G3%/2%)+" of job "+NUM1$(G0%))	      &
				UNLESS NO.SEG%				      &
	\		G4%=FNXBUF.P%(57%,G4%,518%)			      &
	\		E1%=M1% IF E%					      &
	\		GOTO 13260 IF E%				      &
	!	Get the pointer for this PFB channel.  Get it again (and      &
	!	set SEGMNT% if its a real WCB/DDB pointer - not contorted)    &
	!	For the ICF/LOG - annotate the CBB, and get the real	      &
	!	WCB pointer from the CBB				      &

13254		G6%=(FNP%(58%,G4%) AND 255%)				      &
	\	E1%=M1% IF E%						      &
	\	GOTO 13260 IF E%					      &
	\	SEG.TMP%=SEGMNT%					      &
	\	WARN$=NL$						      &
	\	GOSUB 13290	! uses fnp%(35%-54%)			      &
	\	I%=FNGLOOP%(SEG.TMP%,FNSR5%(G4%),G5%,WARN$+' (PF) CH #'+      &
			NUM1$(G3%/2%)+' ('+G0$+':) of job '+NUM1$(G0%))
13260	NEXT G3%							      &
		! EACH ENTRY IN THE PFB IS NON-ZERO IF THE CHANNEL IS OPEN;   &
		! IF SO, POINTS TO A DDB (DEVICE OPEN) OR 'WCB' ON	      &
		! LARGE-FILE SYSTEMS OR CCB (IF ICF OR LOG)		      &

13270	G0%=G0%+1%							      &
	\ GOTO 13300 IF G0%>65%						      &
	\ G%=G%+2%							      &
	\ GOTO 13220							      &
									      &

13290	! This is all the common code for the open file processing for	      &
	! the IOB and the PFB						      &
	!								      &
		G5%=1%							      &
	\	IF G6% THEN						      &
			G0$=CHR$(FNP%(35%,G7%+G6%-2%))+			      &
			    CHR$(SWAP%(FNP%(36%,G7%+G6%-2%)))+		      &
			    NUM1$(SWAP%(FNP%(37%,G4%+2%)) AND 255%)	      &
		ELSE	G6%=(SWAP%(FNP%(38%,G4%+2%)) AND 255%)*10%	      &
				UNLESS FCBLST%				      &
	\		G6%=(FNP%(39%,FNP%(40%,G4%+8%)-4%) AND 255%)*10%      &
				IF FCBLST%				      &
	\		G0$=CHR$(FNP%(41%,G8%+G6%+6%))+			      &
				CHR$(SWAP%(FNP%(42%,G8%+G6%+6%)))+	      &
				NUM1$(FNP%(43%,G8%+G6%+8%) AND 255%)	      &
	\		WARN$=" ???" UNLESS LEN(CVT$$(G0$,-2%))>1%	      &
	\		G5%=G5%+1% IF FNP%(44%,G4%+10%) AND 16384%	      &
				IF FCBLST%=0%				      &
	\		IF FCBLST% THEN					      &
				G5%=G5%+1% IF FNP%(45%,G4%+2%) AND 8192%      &
	\			G6%=FNP%(46%,G4%+8%)-28%		      &
	\			G7$="["+NUM1$(SWAP%(FNP%(47%,G6%+4%))	      &
					AND 255%)+			      &
				","+NUM1$(FNP%(48%,G6%+4%) AND 255%)+"]"      &
	\			G7$=G7$+RAD$(FNP%(49%,G6%+6%))		      &
					+RAD$(FNP%(50%,G6%+8%))		      &
					+"."+RAD$(FNP%(51%,G6%+10%))	      &
					UNLESS FNP%(52%,G6%+12%) AND 64%      &
	\			TMP%=GX%(FNSR5%(G6%),0%)		      &
	\			I%=FNGADD%(SEGMNT%,G6%,			      &
						WARN$+" FCB for "+G7$)	      &
					UNLESS (TMP%<>0%)		      &
					   AND ASCII(GX$(TMP%))=SEGMNT%	      &
					    AND (LEN(WARN$)=0%)		      &
	\			WCB%=G4%				      &
	\			WHILE WCB%				      &
	\				TMP%=GX%(FNSR5%(WCB%),0%)	      &
	\				I%=FNGADD%(SEGMNT%,WCB%,WARN$+	      &
						   " WCB for "+G7$)	      &
					    UNLESS (TMP%<>0%)		      &
					       AND ASCII(GX$(TMP%))=SEGMNT%   &
						AND (LEN(WARN$)=0%)	      &
	\				WCB%=FNP%(53%,WCB%+12%) AND (NOT 31%) &
	\			NEXT					      &

13295			RETURN						      &

13300	!								      &
									      &
									      &
	!	R T S ' S						      &
									      &

13310	G$='RTSLST'							      &
	\ E%=0%								      &
	\ GOSUB 14000							      &
	\ G8%=G%							      &
	\ GOTO 13350 IF CF%						      &
		! GET ROOT OF RTS'S - SAVE FOR RES LIBS.		      &

13320	G%=FNP%(60%,G%)							      &
	\ E1%=M1% IF E%							      &
	\ GOTO 13330 IF E%						      &
	\ G0%=G0%+1%							      &
	\ GOTO 13330 IF G0%>MAX.BUF%					      &
	\ GOTO 13330 UNLESS G%						      &
	\ I%=FNGADD%(SEGMNT%,G%,' RTS #'+NUM1$(G0%)+			      &
		' "'+CVT$$(RAD$(FNP%(61%,G%+2%))			      &
		+RAD$(FNP%(62%,G%+4%)),2%)+'"')				      &
	\ GOTO 13320							      &

13330	!								      &
									      &
									      &
	!	L I B ' S						      &
									      &

13335	G%=G8%+2%							      &
		! RES LIB LIST STARTS AT RTSLST+2.			      &

13340	G%=FNP%(63%,G%)							      &
	\ E1%=M1% IF E%							      &
	\ GOTO 13350 IF E%						      &
	\ FOR G0%=1% WHILE G%<>0% AND G0%<MAX.BUF%			      &
	\	I%=FNGADD%(SEGMNT%,G%,' LIB #'+NUM1$(G0%)+		      &
			' "'+CVT$$(RAD$(FNP%(64%,G%+2%))		      &
			+RAD$(FNP%(65%,G%+4%)),2%)+'"')			      &
	\	G%=FNP%(66%,G%)						      &
	\	E1%=M1% IF E%						      &
	\	GOTO 13350 IF E%					      &
	\ NEXT G0%							      &
	! RESIDENT LIBRARIES						      &
									      &
									      &

13350	!								      &
									      &
									      &
	!	D S Q ' S      Q T B ' S        S A T T ' S		      &
									      &

13355	G$="DEVOKB"							      &
	\ E%=0%								      &
	\ GOSUB 14000							      &
	\ G1%=G%							      &
	\ G$="DEVNAM"							      &
	\ GOSUB 14000							      &
	\ G3%=G%							      &
	\ G$="DEVCNT"							      &
	\ GOSUB 14000							      &
	\ G2%=G%							      &
	\ GOTO 13400 IF CF%						      &
	\ G$="SATMMU"	! Table of MMU addresses for loaded SATs	      &
	\ GOSUB 14000							      &
	\ G8%=G%							      &
	\ G$="DSKQPT"	! Table of QTB pointers				      &
	\ GOSUB 14000							      &
	\ G9%=G%							      &
	\ TMP%=0%	! start a 0 counter (FUN)			      &
	\ FOR G5%=0% TO (G1%-2%) STEP 2%	! do all the types	      &
	\	G7$=CVT%$(SWAP%(FNP%(70%,G3%+G5%)))			      &
	\	GOTO 13365 UNLESS FNP%(71%,G2%+G5%)>=0%			      &
	\	E1%=M1% IF E%						      &
	\	G$="DQS$"+G7$						      &
	\	GOSUB 14000						      &
	\	FOR UNIT%=0% TO FNP%(72%,G2%+G5%) ! do all this types units   &
	\		G0%=FNP%(73%,G8%+TMP%) IF G8%	! get MMU -> for satt &
	\		E1%=M1% IF E%					      &
	\		G0%=0% IF E%<>0% OR G8%=0%			      &
	\		R=FNF(FNP%(74%,M2%(55%)+TMP%)) IF G0%	! SATEND      &
	\		I%=(R+1%)/1024%		! number of slivers needed    &
	\		I%=FNGLOOP%(XBUF.SEG%,G0%,I%," Loaded SATT for "+G7$+ &
				NUM1$(UNIT%)+":") IF G0%		      &
	\		GOTO 13360 IF CF% ! couldn't find DQS$ so skip DSQ's  &
	\		G6%=FNP%(75%,G%+UNIT%*2%)			      &
	\		E1%=M1% IF E%					      &
	\		GOTO 13360 IF E%				      &
	\		G6%=0% IF G7$="DU"	! ignore the DU flag	      &
	\		FOR G7%=1% WHILE G6%<>0% AND G7%<MAX.BUF%	      &
	\			I%=FNGADD%(SEGMNT%,G6%," DSQ #"+NUM1$(G7%)+   &
				    " for "+G7$+NUM1$(unit%)+":")	      &
	\			G6%=FNP%(76%,G6%)			      &
	\			E1%=M1% IF E%				      &
	\			GOTO 13360 IF E%			      &
	\		NEXT G7%	! next DSQ for same unit
13360			G6%=FNP%(77%,G9%+TMP%)	! get QTB pointer	      &
	\		E1%=M1% IF E%					      &
	\		GOTO 13362 IF E%				      &
	\		FOR G7%=1% WHILE G6%<>0% AND G7%<MAX.BUF%	      &
	\			G4%=G6% AND 31%				      &
	\			I%=FNP%(78%,G6%) UNLESS G4%		      &
	\			G0%=G6%					      &
	\			G0%=FNR7R%(G6%) IF G4%			      &
	\			SEG.TMP%=SEGMNT%			      &
	\			SEG.TMP%=XBUF.SEG% IF G4%		      &
	\			I%=FNGADD%(SEG.TMP%,G0%," QTB #"+NUM1$(G7%)+  &
				    " for "+G7$+NUM1$(UNIT%)+":")	      &
	\			G6%=FNXBUF.P%(79%,G0%,8%) IF G4%	      &
	\			G6%=FNP%(80%,G0%) UNLESS G4%		      &
	\			E1%=M1% IF E%				      &
	\			GOTO 13362 IF E%			      &
	\		NEXT G7%	! next QTB for same unit
13362		TMP%=TMP%+2%	! index the type/unit pointer (next FUN)      &
	\	NEXT UNIT%	! next unit of same disk		      &

13365	NEXT G5%	! next drive type				      &

13400	!								      &
									      &
									      &
	!	D E C N E T / E    R O O T    S P E C I F I C		      &
	!	N O D E S    A N D    S I D				      &
									      &

13410	GOTO 13450 UNLESS DECNET%					      &
	!								      &
	!    Several of the following items are annotated in XBUF	      &
	!    rather than here in the root section			      &
	!								      &
	!	NETPOL - DECnet private buffer pool free list - 12	      &
	!	IDLNOB - Idle Node Block list - 13			      &
	!	NSPQ2F - Work blocks waiting for FIP - 14		      &
	!	NSPFCQ - Work blocks returned from FIP - 15		      &
	!	ENDCHE - MMU value of end-node cache  - 16		      &
	!	RTEMMU - MMU address of cost/hops vector - 17		      &
	!	OAJMMU - MMU address of adjacency vector - 18		      &
	!	MTXMMU - MMU value to map routing matrix - 19		      &
	!	RTMSTA - Routing messages start address - 20		      &
	!	EVTMMU - MMU value for Event logger database - 21	      &
	!	NSPJDB - Pointer to NSP's JDB - 23			      &
	!								      &
	\ G%=DEC%(12%)		! DEC%(12%)=NETPOL			      &
	\ G$="private free pool"					      &
	\ GOSUB 13440							      &
	\ G%=DEC%(14%)		! DEC%(14%)=NSPQ2F			      &
	\ G$="to FIP queue"						      &
	\ GOSUB 13440							      &
	\ G%=DEC%(15%)		! DEC%(15%)=NSPFCQ			      &
	\ G$="from FIP queue"						      &
	\ GOSUB 13440							      &
	\ G%=DEC%(23%)							      &
	\ I%=FNGADD%(SEGMNT%,FNP%(81%,G%)," NSP's JDB") IF G%		      &
	\ E1%=M1% IF E%							      &
	\ G$="IDLCBF"							      &
	\ GOSUB 14000							      &
	\ I%=FNCCB%(FNP%(82%,G%),NL$,"Idle Control Buff.") UNLESS CF%	      &
	\ G%=FNP%(83%,DEC%(1%))		! NSPCCB			      &
	\ E1%=M1% IF E%							      &
	\ I%=FNGADD%(SEGMNT%,G%," NSP's permanent CCB") IF G%		      &
	\ G%=FNP%(84%,DEC%(6%))		! NSPLLB			      &
	\ E1%=M1% IF E%							      &
	\ I%=FNGADD%(SEGMNT%,G%," NSP's permanent LLB") IF G%		      &
	\ G%=DEC%(7%)		! NSPCDB				      &
	\ G1%=FNP%(85%,G%) AND (NOT 31%)				      &
	\ G2%=FNSR5%(FNP%(86%,G1%))					      &
	\ I%=FNGLOOP%(SEGMNT%,FNSR5%(G1%),G2%," NSP's permanent CDB") IF G%   &
	\ E1%=M1% IF E%							      &
	\ G%=DEC%(3%)		! NODLST				      &
	\ E%=0%								      &
	\ G$=" NOB"							      &
	\ FOR G1%=1% to 2%						      &
	\    G%=DEC%(13%) IF G1%=2%	! IDLNOB			      &
	\    G$=" Idle NOB" IF G1%=2%					      &
	\    G%=FNP%(87%,G%) IF G%					      &
	\    E1%=M1% IF E%						      &
	\    FOR G0%=1% WHILE G%<>0% AND G0%<MAX.BUF%			      &
	\	 I%=FNGADD%(SEGMNT%,G%,G$+" #"+NUM1$(G0%)+		      &
			' "'+CHR$(FNP%(88%,G%+6%) AND 255%)+		      &
			CHR$(SWAP%(FNP%(89%,G%+6%)) AND 255%)+		      &
			CHR$(FNP%(90%,G%+8%) AND 255%)+			      &
			CHR$(SWAP%(FNP%(91%,G%+8%)) AND 255%)+		      &
			CHR$(FNP%(92%,G%+10%) AND 255%)+		      &
			CHR$(SWAP%(FNP%(93%,G%+10%)) AND 255%)+'"')	      &
	\	 G4%=FNP%(94%,G%+20%)	! Pointer to Node counter block	      &
	\	 E1%=M1% IF E%						      &
	\	 I%=FNGLOOP%(SEGMNT%,FNSR5%(G4%),2%,G$+" #"+NUM1$(G0%)+	      &
			" Counter block") IF G4%			      &
	\	 G%=FNP%(95%,G%+28%)					      &
	\	 E1%=M1% IF E%						      &
	\    NEXT G0%							      &
	\ NEXT G1%							      &
	\ G%=DEC%(5%)	! SIDBUF					      &
	\ GOTO 13450 IF CF%						      &
	\ G%=FNP%(96%,G%)	! Get the pointer to the SIDBUF		      &
	\ E1%=M1% IF E%							      &
	\ GOTO 13450 IF E%						      &
	\ G7$=NL$							      &
	\ G1%=FNP%(97%,G%) 	! The first 2 byte			      &
	\ FOR G5%=1% WHILE G1%						      &
	\	G7$=G7$+CHR$(G1% AND 255%)				      &
	\	G4%=(G5% AND 1%)=0%		! Set flag if even	      &
	\	G1%=FNP%(98%,G%+G5%) IF G4%	! The even byte		      &
	\	E1%=M1% IF E%						      &
	\	G1%=0% IF E%						      &
	\	G1%=SWAP%(G1%) AND 255% UNLESS G4%	! The odd byte	      &
	\ NEXT G5%							      &
	\ I%=FNGADD%(SEGMNT%,G%,' System ID "'+G7$+'"')			      &
	\ G%=FNP%(99%,DEC%(20%))		! RTMSTA		      &
	\ E1%=M1% IF E%							      &
	\ G%=0% IF E%							      &
	\ I%=FNGADD%(SEGMNT%,G%," Routing Message = "+FNO$(G%)) IF G%	      &
	\ GOTO 13450							      &
									      &

13440	G%=FNP%(100%,G%)						      &
	\ FOR G0%=1% WHILE G%<>0% AND G0%<MAX.BUF%			      &
	\	I%=FNGADD%(SEGMNT%,G%," DECnet "+G$+" #"+NUM1$(G0%))	      &
	\	IF G$="private free pool" THEN				      &
		    G1%=FNP%(101%,G%+28%)		! XBUF pointer	      &
	\	    IF G1% THEN						      &
			G2%=FNXBUF.P%(102%,G1%,0%)/64%	! Length	      &
	\		I%=FNGLOOP%(XBUF.SEG%,G1%,G2%," DECnet "+G$+" #"+     &
				NUM1$(G0%))
13444		G%=FNP%(103%,G%)					      &
	\	E1%=M1% IF E%						      &
	\ NEXT G0%							      &
	\ RETURN							      &

13450	!								      &
									      &
									      &
	!	P E N D I N G    R E T U R N S				      &
									      &
									      &

13460	G$="BAKSML"							      &
	\ E%=0%								      &
	\ GOSUB 14000							      &
	\ GOTO 13500 IF CF%						      &
	\ G0%,G7%=0%							      &

13470	G%=FNP%(110%,G%)						      &
	\ E1%=M1% IF E%							      &
	\ GOTO 13500 IF E%						      &
	\ G0%=G0%+1%							      &
	\ GOTO 13500 IF G0%>MAX.BUF%					      &
	\ GOTO 13500 UNLESS G%						      &
	\ GOTO 13480 IF G%=G7%						      &
	\ G1%=FNP%(111%,G%)	! Size of this entry			      &
	\ E1%=M1% IF E%							      &
	\ GOTO 13500 IF E%						      &
	\ I%=FNGLOOP%(SEGMNT%,FNSR5%(G%),FNSR5%(G1%),			      &
			' Pending buffer #'+NUM1$(G0%))			      &
	\ G7%=G%							      &
	\ G%=G%+2%	! Address of pointer to next			      &
	\ GOTO 13470							      &

13480	I%=FNGADD%(SEGMNT%,G%,' (circular)')				      &
		! points to itself.					      &
									      &

13500	!								      &
									      &
									      &
	!	L A T    D A T A    S T R U C T U R E S			      &
									      &
									      &

13510	GOTO 13580 IF FNP%(300%,M%(35%))<=0%	! LATAP5		      &
	\ G1%=M%(37%)				! $$LATS		      &
	\ G$="$$LATE"							      &
	\ GOSUB 14000							      &
	\ GOTO 13580 IF G%=0% OR G1%=0%					      &
	\ I%=FNGADD%(SEGMNT%,G1%," LATCTL = "+FNO$(G1%)) IF G1%		      &
	! I%=FNGLOOP%(SEGMNT%,FNSR5%(G1%+32%),FNSR5%(G%)-FNSR5%(G1%)+M1%,     &
	!		" LATCTL Data section")				      &
	\ G%=FNP%(301%,G1%+4%)		! start of LAT Circuit blocks	      &
	\ E1%=M1% IF E%							      &
	\ GOTO 13520 IF E%						      &
	\ FOR G9%=1% WHILE G9%<MAX.BUF% AND G%<>0%			      &
	\	G2%=FNP%(302%,G%-2%)	! get the length of the block	      &
	\	E1%=M1% IF E%						      &
	\	G2%=32% IF E%						      &
	\ 	I%=FNGLOOP%(SEGMNT%,FNSR5%(G%),FNSR5%(G2%),		      &
			" LAT Active VCB #"+NUM1$(G9%))			      &
	\	G3%=FNP%(303%,G%+8%)	! -> PDB for this AVCB		      &
	\	E1%=M1% IF E%						      &
	\	I%=FNGADD%(SEGMNT%,G3%," LAT PDB for AVCB #"+NUM1$(G9%))      &
							IF G3%		      &
	\	G3%=FNP%(304%,G%+14%)	! session block pointer		      &
	\	FOR G8%=1% WHILE G8%<MAX.BUF% AND G3%<>0%		      &
	\		I%=FNGLOOP%(SEGMNT%,FNSR5%(G3%),2%," LAT SESQ #"+     &
				NUM1$(G8%)+" for AVCB #"+NUM1$(G9%))	      &
	\		G3%=FNP%(305%,G3%)				      &
	\		E1%=M1% IF E%					      &
	\	NEXT G8%						      &
	\	G3%=FNP%(306%,G%+18%)	! current xmit CCB for this AVCB      &
	\	I%=FNGADD%(SEGMNT%,G3%," LAT Xmit CCB for AVCB #"+NUM1$(G9%)) &
							IF G3%		      &
	\	G3%=FNP%(307%,G%+22%)	! retransmit queue		      &
	\	E1%=M1% IF E%						      &
	\	FOR G8%=1% WHILE G8%<MAX.BUF% AND G3%<>0%		      &
	\		I%=FNGLOOP%(SEGMNT%,FNSR5%(G3%),1%," LAT XMTQ #"+     &
				NUM1$(G8%)+" for AVCB #"+NUM1$(G9%))	      &
	\		G4%=FNP%(308%,G3%+26%)		! Get XBUF pointer    &
	\		I%=FNXBUF.P%(309%,G4%,0%)	! Get the length      &
	\		I%=64% IF E%					      &
	\		I%=FNGLOOP%(XBUF.SEG%,G4%,I%/64%," LAT XMTQ #"+	      &
			    NUM1$(G8%)+" for AVCB #"+NUM1$(G9%)+" buffer")    &
				IF G4%					      &
	\		G3%=FNP%(310%,G3%)				      &
	\		E1%=M1% IF E%					      &
	\	NEXT G8%						      &
	\	G%=FNP%(311%,G%)	! get the next thing in the chain     &
	\	E1%=M1% IF E%						      &
	\ NEXT G9%							      &

13520	G%=FNP%(312%,G1%+8%)		! start of LAT Idle Circuit blocks    &
	\ E1%=M1% IF E%							      &
	\ G2%=FNP%(313%,G%-2%) IF G%	! get the length of the block	      &
	\ E1%=M1% IF E%							      &
	\ G2%=32% IF E%							      &
	\ FOR G9%=1% WHILE G9%<MAX.BUF% AND G%<>0%			      &
	\ 	I%=FNGLOOP%(SEGMNT%,FNSR5%(G%),FNSR5%(G2%),		      &
			" LAT Idle VCB #"+NUM1$(G9%))			      &
	\	G%=FNP%(314%,G%)	! get the next thing in the chain     &
	\	E1%=M1% IF E%						      &
	\ NEXT G9%							      &
	\ G2%=FNP%(315%,G1%+16%)	!  -> Multicast message buffer	      &
	\ E1%=M1% IF E%							      &
	\ I%=FNGADD%(SEGMNT%,G2%," LAT Multicast buffer = "+FNO$(G2%)) IF G2% &
	\ G2%=FNP%(316%,G1%+18%)	!  -> LAT Node descriptor buffer      &
	\ I%=FNGADD%(SEGMNT%,G2%," LAT Node buffer = "+FNO$(G2%)) IF G2%      &
	\ G%=FNP%(317%,G1%+20%)		!  -> LAT Service block		      &
	\ FOR G9%=1% WHILE G9%<MAX.BUF% AND G%<>0%			      &
	\ 	I%=FNGLOOP%(SEGMNT%,FNSR5%(G%),3%," LAT Service #"+NUM1$(G9%)) &
	\	G%=FNP%(318%,G%)	! get the next thing in the chain     &
	\	E1%=M1% IF E%						      &
	\ NEXT G9%							      &
	\ G$="LATQUE"							      &
	\ GOSUB 14000							      &
	\ GOTO 13580 IF CF%						      &
	\ G%=FNP%(319%,G%)	! start of LAT completion queue		      &
	\ E1%=M1% IF E%							      &
	\ G2%=32%		! make the length 1 buffer for now	      &
	\ FOR G9%=1% WHILE G9%<MAX.BUF% AND G%<>0%			      &
	\ 	I%=FNGLOOP%(SEGMNT%,FNSR5%(G%),FNSR5%(G2%),		      &
			" LAT Completion queue #"+NUM1$(G9%))		      &
	\	G%=FNP%(320%,G%)	! get the next thing in the chain     &
	\	E1%=M1% IF E%						      &
	\ NEXT G9%							      &

13580	!								      &
	!	Some Static ROOT structures				      &
	!								      &
	I%=FNGLOOP%(ROOT.SEG%,FNSR5%(M%(9%)),FNSR5%(512%),		      &
			" SATBUF (and CRASAV) area")			      &
	\ G$="FIBUF"							      &
	\ GOSUB 14000							      &
	\ I%=FNGLOOP%(ROOT.SEG%,FNSR5%(G%),FNSR5%(512%)," FIBUF") IF G%	      &
	\ G$="FREES"							      &
	\ GOSUB 14000							      &
	\ G2%=FNP%(330%,G%+6%)		! Big buffer free/busy flag	      &
	\ E1%=M1% IF E%							      &
	\ G$="BGBUFR"							      &
	\ GOSUB 14000							      &
	\ G1%=G%							      &
	\ G$="RAWMEM"							      &
	\ GOSUB 14000							      &
	\ G3%=1%							      &
	\ G3%=(G%-G1%)/32% IF FNF(G%) > FNF(G1%)			      &
	\ G$="(Inuse)"							      &
	\ G$="(Unknown)" IF G2%						      &
	\ G$="(Available)" IF G2%=1%					      &
	\ I%=FNGLOOP%(SEGMNT%,FNSR5%(G1%),G3%," Big Buffer "+G$) IF G1%	      &
	\ G$="OVBASE"							      &
	\ GOSUB 14000							      &
	\ G1%=FNP%(340%,G%)		! Get the pointer to OVBASE	      &
	\ E1%=M1% IF E%							      &
	\ G1%=0% IF CF%							      &
	\ G4%=1%	! Calculate real size from .SIL header data	      &
	\ I%=FNGLOOP%(SEGMNT%,FNSR5%(G1%),G4%," Overlay (OVR) Base Table")    &
		IF G1%							      &
	\ G$="O2BASE"							      &
	\ GOSUB 14000							      &
	\ G2%=FNP%(345%,G%) UNLESS CF%	! Get the pointer to O2BASE	      &
	\ E1%=M1% IF E%							      &
	\ G2%=0% IF CF%							      &
	\ G4%=1%	! Calculate real size from .SIL header data	      &
	\ I%=FNGLOOP%(SEGMNT%,FNSR5%(G2%),G4%," Overlay (OV2) Base Table")    &
		IF G2%							      &

13600	!								      &
									      &
									      &
	!	B U F F E R    C H A I N S				      &
									      &
									      &

13610	TTFMSB%=M2%(51%)						      &
	\ TTFMSB%=FNP%(400%,TTFMSB%)	! get the value from the pointer      &
	\ E1%=M1% IF E%							      &
	\ NODB%=0%							      &
	\ NOKB%=-1%							      &
	\ G$='DEVNKB'							      &
	\ GOSUB 14000							      &
	\ G2%=G%							      &
	\ GOTO 13700 IF CF%						      &
	\ G$='DEV.KB'							      &
	\ GOSUB 14000							      &
	\ DEVTBL%=FNP%(401%,M%(7%)+M2%(9%))				      &
		! DEVTBL = PEEK(DEVPTR+DEVOKB)				      &
	\ MAX.DEV%=M2%(23%)-M2%(5%)-2%					      &
		! Last device before start of synonym table is:		      &
		! =DEVSYN-DEVNAM-2					      &
	\ DEVEND%=FNP%(402%,M%(7%)+MAX.DEV%)+FNP%(403%,M%(5%)+MAX.DEV%)	      &
		! DEVEND (Last entry in DEVTBL) is last unit of last device   &
		! in the DEVPTR table, which is:			      &
		! PEEK(DEVPTR+MAX.DEV)+PEEK(DEVCNT+MAX.DEV)		      &
		! DEVTBL entries point to device DDB's			      &

13620	GOTO 13700 IF (G%>DEVEND%) OR (G%>=JOBTBL%)			      &
		! so we can exit this loop when we're all done		      &
	\ G3%=FNP%(404%,G%)	! point to the devices DDB		      &
	\ E1%=M1% IF E%							      &
	\ GOTO 13700 IF E%						      &
	\ G%=G%+2%							      &
	\ GOTO 13620 IF G3%=M2%(67%) ! skip this device if it's a 'fake' one  &

13630	G0%=(FNP%(405%,G3%) AND 255%)	! Driver index			      &
	\ E1%=M1% IF E%							      &
	\ GOTO 13620 IF E%						      &
	\ GPK%=G2%+G0%-2%	! pointer to the name			      &
	\ GOTO 13620 IF (GPK% AND 1%)					      &
	\ PGPK%=FNP%(406%,GPK%)	! get the name itself			      &
	\ G$=CHR$(PGPK% AND 255%)+CHR$(SWAP%(PGPK%) AND 255%)		      &
	\ NODB%=-1% IF G$="NO" ! Set the NO: flag when we see the NO: device  &
	\ G0%=(SWAP%(FNP%(407%,G3%+2%)) AND 255%) ! unit # from the DDB	      &
	\ CR.VP%=0%							      &
	\ CR.VP%=1% IF G$="XM"						      &
	\ CR.VP%=M1% IF G$="XD"						      &
	\ A.TXT$=' '+G$+NUM1$(G0%)+": DDB = "+FNO$(G3%) UNLESS CR.VP%	      &
	\ A.TXT$=' '+FNDDCU$(G3%)+" DDB = "+FNO$(G3%) IF CR.VP%		      &
	\ A.TXT$=A.TXT$+" for "+NODB$ IF NOKB%=1%			      &
	\ NODB$=G$+NUM1$(G0%)+":" IF NODB% ! Get the NOn: name for its KB:    &
	\ G4%=FNGADD%(SEGMNT%,G3%,A.TXT$)				      &
	\ G4%=0%							      &
	\ G4%=FNP%(408%,G3%+32%) IF G$='MT' OR G$='MM' OR G$='MS'	      &
		OR G$='MU'	! ANSI tape extension			      &
	\ G4%=FNP%(409%,G3%+68%) IF (FNP%(410%,G3%+10%) AND 30%)<>0%	      &
		IF G$="XM"						      &
	\ G4%=FNP%(411%,G3%+18%) IF G$="XE" OR G$="XH"			      &
	\ E1%=M1% IF E%							      &
	\ GOTO 13620 IF E%						      &
	\ I%=FNGADD%(SEGMNT%,G4%,' '+G$+NUM1$(G0%)+': DDB extension')	      &
		IF G4% UNLESS CR.VP%					      &
	\ I%=FNGADD%(SEGMNT%,G4%," "+FNDDCU$(G3%)+" - Info buffer") IF G4%    &
		IF CR.VP%						      &
	\ GOTO 13690 IF NODB%						      &
	\ GOTO 13650 IF G$='KB' OR G$='LP' OR G$='PR' OR G$='PP'	      &
	\ GOTO 13620							      &

13650	IF G$="KB" THEN							      &
		! IF THIS IS A KB: AND WE HAVE FMS SUPPORT THEN		      &
	    IF TTFMSB% THEN						      &
		BUFPTR%=FNP%(412%,G3%+TTFMSB%)				      &
	\	I%=FNGADD%(XBUF.SEG%,BUFPTR%,				      &
			"FMS Buffer for KB"+NUM1$(G0%)+":") IF BUFPTR%	      &
		! FMS BUFFER FOR A KB (IN XBUF)				      &

13660	G4%=FNP%(413%,G3%+10%)						      &
	\ E1%=M1% IF E%							      &
	\ GOTO 13620 IF E%						      &
	\ G4%=((G4%+M1%) AND (NOT 31%)) IF G4%				      &
	\ G0$=' '+G$+NUM1$(G0%)+': '					      &
	\ G0$=G0$+'out' IF G$<>'PR'					      &
	\ G0$=G0$+'in' IF G$='PR'					      &
	\ G0$=G0$+'-buf #'						      &
	\ GOSUB 13670 IF G4%						      &
	\ GOTO 13620 UNLESS G$='KB'					      &
	\ G4%=FNP%(414%,G3%+18%)	! Keyboard input buffer		      &
	\ G4%=((G4%+M1%) AND (NOT 31%)) IF G4%				      &
	\ G0$=' '+G$+NUM1$(G0%)+': in-buf #'				      &
	\ GOSUB 13670 IF G4%						      &
	\ G4%=FNP%(415%,G3%+40%) 	! Follow the Echo control chain	      &
	\ G4%=((G4%+M1%) AND (NOT 31%)) IF G4%				      &
	\ G0$=' '+G$+NUM1$(G0%)+': echo-buf #'				      &
	\ GOSUB 13670 IF G4%						      &
	\ G4%=FNP%(416%,G3%+48%)	! Get the Delimiter Mask pointer      &
	\ I%=FNGADD%(SEGMNT%,G4%," "+G$+NUM1$(G0%)+": Delimiter mask") IF G4% &
	\ GOTO 13620							      &

13670	G7%=0%
13680	G7%=G7%+1%							      &
	\ RETURN IF G7%>MAX.BUF%					      &
	\ I%=FNGADD%(SEGMNT%,G4%,G0$+NUM1$(G7%))			      &
	\ G4%=FNP%(417%,G4%)						      &
	\ E1%=M1% IF E%							      &
	\ RETURN IF E%							      &
	\ RETURN UNLESS G4%						      &
	\ G4%=((G4%+M1%) AND (NOT 31%))					      &
	\ GOTO 13680							      &

13690	  IF NODB% 				! If this is the NO: device   &
	  THEN	IF NOKB%=1% 			! then if we just did its KB  &
		THEN	G3%=FNP%(4171%,G3%+64%)	! then point to next NO: DDB  &
	\		IF G3%=0% 		! If there isn't one	      &
			THEN	NODB%=0% 	! then reset the NO: DDB flag &
	\			NOKB%=-1%	! reset the NO: KB: flag, too &
	\			GOTO 13620 	! and exit the NO: DDB loop   &
	\		END IF 			!			      &
		ELSE	OLDG3%=G3%		! Save G3% for a nano or two  &
	\		G3%=FNP%(4172%,G3%+66%) ! else point to NO's KB DDB   &
	\		IF G3%=0%		! If there isn't one	      &
			THEN	NOKB%=NOKB%*-1%	!  then pretend we did it     &
	\			G3%=OLDG3%	! That's why we saved it      &
	\			GOTO 13690	!  and look for next NO: DDB  &
	\		END IF			!			      &
	\	END IF 				!			      &
	\	NOKB%=NOKB%*-1% 		! Toggle the NO: KB: flag     &
	\	GOTO 13630 			! Go do another NO: or NO: KB: &
	  ELSE	GOTO 13620 			! else go do another DDB      &
	\ END IF							      &

13700	!								      &
									      &
									      &
	!	M E M O R Y    L I S T					      &
									      &
									      &

13710	G$='MEMLST'							      &
	\ E%=0%								      &
	\ GOSUB 14000							      &
	\ GOTO 13800 IF CF%						      &
	\ I%=FNGADD%(ROOT.SEG%,G%,' Memory list (Monitor)')		      &
	\ GOSUB 13740
13720	IF (G% AND 24%)=0% THEN						      &
		G0%=G% AND 7%						      &
	\	G0$=NL$							      &
	\	G0$='Xbuf' IF G0%=2%					      &
	\	G0$='Locked' IF G0%=4%					      &
	\	MPHYA%=(FNP%(430%,G%+8%)/32%) AND 2047%			      &
	\	G0$='Virtual Disk' IF (G0%=4%)				      &
			AND (VSTAT%>0%)					      &
			AND ((MPHYA%>=VSTAR%) AND (MPHYA%<VSTAR%+VSIZE%))     &
	\	G0$='ODT' IF G0%=6%					      &
	\	I%=FNGADD%(ROOT.SEG%,G%,' Memory list ('+G0$+')')	      &
							IF LEN(G0$)	      &

13730	G0%=FNP%(431%,G%+2%)						      &
	\ E1%=M1% IF E%							      &
	\ GOTO 13800 IF E%						      &
	\ IF G0%=0% THEN						      &
		I%=FNGADD%(ROOT.SEG%,G%,' Memory list (Tail)')		      &
	  ELSE								      &
		G%=G0%							      &
	\	GOTO 13720						      &

13735	GOTO 13800							      &

13740	DV%=ASCII("D")+ASCII("V")*256%					      &
	\ INDEX%=0%							      &
		! INDEX INTO MONITOR TABLES SET TO ZERO			      &

13745	DEV%=FNP%(432%,M2%(5%)+INDEX%)					      &
	\ IF DEV%=M1% THEN GOTO 13760					      &
		! END OF THE LIST?					      &

13750	IF DEV%<>DV% THEN INDEX%=INDEX%+2%				      &
	\ GOTO 13745							      &

13755	VSTAT%=FNP%(433%,M%(19%)+INDEX%)				      &
	\ IF VSTAT%>=0% THEN FREE%=FNP%(434%,M%(21%)+INDEX%)		      &
	\  VSTAR%=FNP%(435%,M2%(7%)+INDEX%)				      &
	\  VSTAR%=VSTAR%+2048% IF VSTAR%<0%				      &
	\  VSIZE%=(FNP%(436%,M%(17%)+INDEX%) AND 255%)*			      &
		  (FNP%(437%,M2%(55%)+INDEX%)+1%)+1%			      &
	\  VSIZE%=INT((VSIZE%/4.0)+.9999)				      &
		! IF IT'S MOUNTED GET FREE SPACE, START ADDRESS, TOTAL SIZE   &

13760	RETURN								      &
									      &

13800	!								      &
									      &
									      &
	!	F R E E    B U F F E R S				      &
									      &
									      &

13810	G$='FREES'							      &
	\ G$='FIPROO' IF FPL%						      &
	\ E%=0%								      &
	\ GOSUB 14000							      &
	\ GOTO 13840 IF CF% OR (G%=0%)					      &
	\ S$=NL$							      &
	\ S$=" FIP" IF FPL%						      &
	\ G%=G%+8% UNLESS FPL%						      &
	\ G1%,G7%=0%							      &
	\ G%=FNP%(450%,G%)	! Get the pointer to the first free buffer    &
	\ GOTO 13830 UNLESS G%						      &
	\ G0%=1%							      &

13820	G1%=FNP%(451%,G%+2%)	! Get the length of this free entry	      &
	\ E1%=M1% IF E%							      &
	\ GOTO 13840 IF E%						      &
	\ I%=FNGLOOP%(SEGMNT%,FNSR5%(G%),FNSR5%(G1%),S$+' Free #'+	      &
		NUM1$(G0%)+', '+FNO$(G1%)+' bytes') IF G1%		      &
	\ G7%=G%							      &
	\ G%=FNP%(452%,G%)						      &
	\ E1%=M1% IF E%							      &
	\ GOTO 13840 IF E%						      &
	\ G0%=G0%+1%							      &
	\ GOTO 13830 IF G0%>MAX.BUF%					      &
	\ GOTO 13830 UNLESS G%						      &
	\ GOTO 13820 IF FNF(G%)>FNF(G7%)				      &
	\ TEMP$=S$+' Free #'+NUM1$(G0%+M1%)+' (circular)' IF G%=G7%	      &
	\ TEMP$=S$+' Free #'+NUM1$(G0%+M1%)+' (backwards)' IF FNF(G%)<FNF(G7%) &
	\ I%=FNGADD%(SEGMNT%,G7%,TEMP$)					      &
		! POINTS TO ITSELF OR POINTS BACKWARDS.			      &

13830	GOTO 13840 IF FPL%						      &
	\ FPL%=M1%							      &
	\ GOTO 13810							      &
		! DONE IF WE'VE DONE THE FIP POOL FREE LIST		      &
		! OTHERWISE GO DO THEM!					      &

13840	I%=FNGADD%(ROOT.SEG%,FXMONS%," X.MONS = "+FNO$(FXMONS%))	      &
		! PRINT X.MONS ADDRESS (SIZE OF MONITOR)		      &

13900	!								      &
	!								      &
	!	D E C N E T    G L O B A L    Q U E U E S		      &
	!								      &
	!								      &
	! THERE ARE THREE GLOBAL QUEUE LISTS WHICH ARE POINTED TO BY THE      &
	! GLOBAL SYMBOLS NSPQUE, TRNQUE, AND CONQUE. THE GLOBAL QUEUES ARE    &
	! ANNOTATED AS FOLLOWS:						      &
	!								      &
	!		CCB #1 on NSPQUE				      &
	!								      &

13910	IF DECNET% THEN							      &
	  TMP%=FNDO.QUEUE%("NSPQUE")					      &
	\ TMP%=FNDO.QUEUE%("TRNQUE")					      &
	\ TMP%=FNDO.QUEUE%("NSPACQ")					      &
		!							      &
		! ANNOTATE THE GLOBAL QUEUES EXCEPT FOR CONQUE (DONE BELOW)   &
		!							      &

13940	!								      &
	!								      &
	!	D E C N E T   D E V I C E   Q U E U E S			      &
	!								      &
	!								      &
	! THERE ARE A NUMBER OF DEVICE QUEUE LISTS WHICH ARE POINTED	      &
	! TO BY POINTERS WHICH ARE FOUND WITHIN THE DEVICES DEVICE DATA	      &
	! BLOCK (DDB). THE FUNCTION OF THE FOLLOWING ROUTINE IS TO	      &
	! ANNOTATE THESE QUEUE LISTS. THE ANNOTATION OF THE QUEUES ARE	      &
	! AS FOLLOWS :							      &
	!								      &
	!		CCB #1 on DMC-0 XMTIPQ				      &
	!			  OR					      &
	!		CCB #1 on DMP-0.1 XDXMTG			      &
	!								      &
	! THE DMP DEVICES HAVE ANOTHER QUEUE LIST WHICH IS ON A CONTROLLER    &
	! BASES. THE POINTER TO THIS STRUCTURE CALLED THE CONTROLLER DATA     &
	! BLOCK (CDB) IS AT OFFSET 76. DECIMAL OF THE DEVICE'S DDB. THE	      &
	! QUEUE LISTS OF THE CDB WILL BE ANNOTATED AS FOLLOWS:		      &
	!								      &
	!		CCB #1 on DMP-0 X0INPQ				      &
	!								      &
	! THE CDB'S THEMSELVES WILL BE ANNOTATED AS FOLLOWS:		      &
	!								      &
	!		CDB for DMP-0, (size) bytes			      &
	!		 ... CDB for DMP-0, (size) bytes		      &
	!		 End CDB for DMP-0, (size) bytes		      &
	!								      &
	! Annotate the DMC/DMR/DMV/DMP DDB queues			      &
	!								      &
	! DMC/DMR							      &
	!								      &
	!	XMTIPQ	88	xmit in progress queue - given to DMC	      &
	!	XMRIPQ	92	recv in progress queue - given to DMC	      &
	!	XMTQUE	96	xmit pending queue - not given to DMC	      &
	!	XMRQUE	100	recv pending queue - not given to DMC	      &
	!	XMRCPQ	104	recv complete queue - non-DECnet use	      &
	!	XMCPLQ	108	completion queue			      &
	!								      &
	! DMV/DMP							      &
	!								      &
	!	XDCCB	72	Address of CCB waiting for buf-ret complete   &
	!	XDCDB	76	Pointer to CDB				      &
	!	XDXMTG	78	xmits given queue			      &
	!	XDRCVG	82	receives given queue			      &
	!	XDRCVC	86	receives completed queue		      &
	!	XDCPLQ	90	completion queue			      &
	!	XDXMTW	94	xmits waiting queue			      &
	!	XDRCVW	98	receives waiting queue			      &
	!	XDSPCQ	102	special requests processing queue	      &
	!								      &

13950	GOTO 13990 IF NUM.DECNT.UNITS% < 0%				      &
	\ TMP%=FNDO.QUEUE%("CONQUE")					      &
	\ FOR I%=0% TO 2%						      &
	\	READ OFFSET%(0%,I%)					      &
	\	READ QUE.NAME$(J%,I%),OFFSET%(J%,I%)			      &
			 FOR J%=1% TO OFFSET%(0%,I%)			      &
	\ NEXT I%							      &
	\ DEV.NAME%=M2%(5%)						      &
	\ DEV.OKB%=M2%(9%)						      &
	\ DEV.NAME$=NL$							      &
	\ FOR UNIT%=0% TO NUM.DECNT.UNITS%				      &
	\	DDB.PNTR%=FNP%(140%,XM0.DDB.PTR%+(2%*UNIT%))		      &
	\	JOB.NO%=FNP%(141%,DDB.PNTR%+2%) AND 255%		      &
	\	GOTO 13960 IF (JOB.NO% AND 1%) <> 0%			      &
	\	DEV.NAME$=CVT%$(SWAP%(FNP%(142%,DEV.NAME%+DEV.OKB%-2%	      &
			  +(FNP%(143%,DDB.PNTR%) AND 255%))))		      &
			  +NUM1$(SWAP%(FNP%(144%,DDB.PNTR%+2%)) AND 255%)     &
	\	TMP$=LEFT(DEV.NAME$,2%)					      &
	\	CR.VP%=0%						      &
	\	CR.VP%=1% IF TMP$="XM"					      &
	\	CR.VP%=M1% IF TMP$="XD"					      &
	\	GOTO 13960 UNLESS CR.VP%				      &
	\	DEV.NAME$=FNDDCU$(DDB.PNTR%)				      &
	\	IF TMP$="XM" THEN					      &
			TMP%=FNDEV.QUE%(DEV.NAME$,DDB.PNTR%,0%)		      &
		ELSE							      &
			TMP%=FNDEV.QUE%(DEV.NAME$,DDB.PNTR%,1%)		      &
	\		TMP%=FNP%(145%,DDB.PNTR%+72%)			      &
	\		I%=FNGADD%(SEGMNT%,TMP%," Buf-ret wait CCB for "+     &
				DEV.NAME$) IF TMP%			      &
	\		IF VAL(RIGHT(DEV.NAME$,LEN(DEV.NAME$)))=0% THEN	      &
				DEV.NAME$=LEFT(DEV.NAME$,5%)		      &
	\			CDB%=FNP%(146%,DDB.PNTR%+76%)		      &
	\			IF CDB% THEN				      &
					I%=FNP%(147%,CDB%-2%)		      &
	\				I%=FNGLOOP%(ROOT.SEG%,FNSR5%(CDB%),   &
						   FNSR5%(I%),		      &
						   " CDB for "+DEV.NAME$+     &
						   ", "+FNO$(I%)+	      &
						   " bytes")		      &
	\				TMP%=FNDEV.QUE%(DEV.NAME$,CDB%,2%)
13960	NEXT UNIT%							      &
		!							      &
		! SKIP THE DECNET DEVICE QUEUE ANNOTATIONS IF THERE ARE	      &
		! NO DMC'S, DMR'S, OR DMP'S.				      &
		! ANNOTATE 'CONQUE' -DONE HERE SINCE CONQUE DOES NOT	      &
		!                    EXIST IN ALL MONITORS.  EDIT # 001	      &
		! READ IN THE DEVICE QUEUE LISTS FOR DMC'S/DMR'S, DMP'S	      &
		! AND CDB'S.						      &
		! FOR EACH SUCH UNIT.					      &
		!	GET THE DDB POINTER				      &
		!	SKIP THIS UNIT IF IT'S DISABLED.		      &
		!	OTHERWISE, GET THE DEVICE NAME.			      &
		!	PUT THE DEVICE NAME IN DDCU FORMAT IF IT'S	      &
		!		AN "XM" (DMC/DMR) OR A "XD" (DMP).	      &
		!	IF THE DEVICE IS AN "XM" THEN			      &
		!		ANNOTATE THE DMC/DMR QUEUE LISTS.	      &
		!	ELSE						      &
		!		ANNOTATE THE DMP QUEUE LISTS.		      &
		!		IF IT'S TRIBUTARY NUMBER 0 THEN		      &
		!			GET THE CDB POINTER		      &
		!			IF THE CDB POINTER IS NOT 0 THEN      &
		!				ANNOTATE THE CDB ITSELF AND   &
		!				ALSO THE CDB QUEUE LISTS.     &
		! ONWARD TO THE NEXT UNIT.				      &
		!							      &

13980	!								      &
	!								      &
	! THE FOLLOWING IS THE QUEUE LISTS FOR THE DEVICE QUEUES.	      &
	! THE FIRST GROUP REPRESENT THE DMC/DMR DEVICE QUEUE LISTS	      &
	! ALLONG WITH THEIR OFFSETS INTO THE DDB IN DECIMAL.		      &
	! THE NEXT LIST REPRESENTS THE QUEUE LISTS FOR THE DMP ALLONG	      &
	! WITH THEIR OFFSETS INTO THE DDB AGAIN IN DECIMAL.		      &
	! THE LAST AND FINAL GROUP REPRESENT THE QUEUE LISTS FOUND IN	      &
	! THE CONTROLLER DATA BLOCK (DMP'S ONLY) ALLONG WITH THEIR OFFSETS.   &
	!								      &
	!								      &

13982	DATA	6,							      &
		"XMTIPQ", 88,						      &
		"XMRIPQ", 92,						      &
		"XMTQUE", 96,						      &
		"XMRQUE",100,						      &
		"XMRCPQ",104,						      &
		"XMCPLQ",108						      &

13984	DATA	7,							      &
		"XDXMTG", 78,						      &
		"XDRCVG", 82,						      &
		"XDRCVC", 86,						      &
		"XDCPLQ", 90,						      &
		"XDXMTW", 94,						      &
		"XDRCVW", 98,						      &
		"XDSPCQ",102						      &

13986	DATA	2,							      &
		"X0INPQ", 20,						      &
		"X0SPCQ", 24						      &

13990	E%=0%								      &
	\ RETURN							      &

14000	FOR I%=1% TO G%(0%)						      &
	\	IF G$=G$(I%) THEN					      &
			G%=G%(I%)					      &
	\		G0%,E%,CF%=0%					      &
	\		RETURN
14010	NEXT I%								      &
	\ PRINT #1%, '?Symbol "';G$;'" not found'			      &
	\ G%=0%								      &
	\ CF%=M1%							      &
	\ RETURN							      &
	! FIND A SYMBOL							      &
									      &

14100	!								      &
	!								      &
	!	M S C P    A N N O T A T I O N S			      &
	!								      &
	!								      &
	! Two tables which reside in the permanently mapped portion of the    &
	! monitor will need to be annotated. They are the CMT table, pointed  &
	! to by the global symbol "CMT", and the UMT table, pointed to by the &
	! global symbol "UMT$DU". The annotation used to point out these      &
	! tables will be as follows:					      &
	!								      &
	!			CMT Table				      &
	!			UMT Table				      &
	!								      &
	! Only the CMT table has any significants to ANALYS. It contains      &
	! information needed to annotate the MSCP region. The following	      &
	! diagram depicts the layout of the CMT table:			      &
	!								      &
	!								      &
	!			CMT Table (detail)			      &
	!								      &
	!			|----------------|			      &
	!		    |-->|    CM.UOF	 |			      &
	!		    | 	|----------------|			      &
	!		    |	|    CM.DNE	 |<---- TSQ Done queue	      &
	!	CMT header  |	|----------------|			      &
	!	    area    |	|    CM.QMR	 |			      &
	!		    |	|----------------|			      &
	!		    |	|    CM.CRQ	 |			      &
	!		    |	|----------------|			      &
	!		    |	|CM.DCT | CM.CCT*|<---- # of controllers      &
	!		    |	|----------------|   total + MSCP each 1 byte &
	!		    |	|    CM.AWS	 |			      &
	!		    |	|----------------|			      &
	!		    |	|    CM.BA6*	 |<---- MMU address of the    &
	!   Symbol "CMT"-|  |	|----------------|	BBR region. Always at &
	!   points here  |  |	|CM.BRM | CM.BRS |	the start of the MSCP &
	!		 |->|-->|----------------|	region.		      &
	!		    --->|    CM.CRT	 |			      &
	!		    |	|----------------|			      &
	!		    |	|    CM.UMR	 |<---- UNIbus map wait thread &
	!		    |	|----------------|			      &
	!		    |	|    CM.QUE	 |<---- Head of TSQ/DSQ list  &
	!		    |	|----------------|			      &
	!		    |	|    CM.AP6*	 |<---- MMU address of the    &
	!		    |	|----------------|	this controllers work &
	!	Required for|	|    CM.COF*	 |<-|	area in the MSCP seg. &
	!	each of the |	|----------------|  |-- Offset to CCB within  &
	!	0-4 possible|	|    CM.WKA	 |	the MMU pointed to by &
	!	disk cntrs  |	|----------------|	CM.AP6.		      &
	!	and 0-2     |	|    CM.CSR	 |			      &
	!	tape cntrs  |	|----------------|			      &
	!		    |	|CM.FLG	| CM.VTR |			      &
	!		    |	|----------------|			      &
	!		    |	|CM.CMD | CM.RSP |			      &
	!		    |-->|----------------|			      &
	!								      &
	!								      &
	! Items to be annotated in the MSCP region are the BBR (bad block     &
	! replacement) region and the CCBs (controller control blocks). These &
	! areas will be annotated as follows:				      &
	!								      &
	!			Start of the BBR region			      &
	!								      &
	!			CCB #n (physical address)		      &
	!								      &
	!			  where - n = Controller 0 to 3		      &
	!								      &
	!								      &
	! The following diagram outlines the MSCP region:		      &
	!								      &
	!    CM.BA6 --->|----------------|<-- Start of the BBR region	      &
	!		|		 |				      &
	!		|  BBR work area |				      &
	!		|		 |				      &
	!    CM.AP6+ -->|----------------|<-- CCB #0 (00300626)		      &
	!    CM.COF	|		 |				      &
	!    cntrlr 0	|    Cntrlr 0	 |				      &
	!		|    work area	 |				      &
	!    CM.AP6+ -->|----------------|<-- CCB #1 (00301656)		      &
	!    CM.COF	|		 |				      &
	!    cntrlr 1	|    Cntrlr 1	 |				      &
	!		|    work area	 |				      &
	!		|		 |				      &
	!		|----------------|				      &
	!								      &
	!								      &
	! The start of the BBR region is always at location 0 of the MSCP     &
	! region. But for flexibility, ANALY2 will use the address found in   &
	! CM.BA6 of the CMT header to locate the start of the BBR region.     &
	! To locate the address of each CCB (controller control block),	      &
	! ANALY2 will use the MMU address found in the symbol CM.AP6. Neither &
	! of these two symbols are global, therefore ANALY2 must peek at      &
	! CMT+CM.BA6 (where CM.BA6=-4. bytes) to obtain the BBR address and   &
	! at CMT+CM.AP6 (where CM.AP6=6. bytes) to get the MMU address of the &
	! CCB area for a given controller. The length of each controller      &
	! entry in the CMT table is 18 bytes long.			      &
	!								      &
	!								      &

14110	CM.CCT.OFST%=-8%						      &
	\ CM.AP6.OFST%=6%						      &
	\ CM.COF.OFST%=8%						      &
	\ ENTRY.SIZE%=18%						      &
	\ G$="UMT$DU"							      &
	\ GOSUB 14000							      &
	\ GOTO 14140 IF CF%<>0% OR G%=0%				      &
	\ I%=FNGADD%(ROOT.SEG%,G%," UMT Table = "+FNO$(G%))		      &
	\ G$="CMT"							      &
	\ GOSUB 14000							      &
	\ GOTO 14140 IF CF%<>0% OR G%=0%				      &
	\ I%=FNGADD%(ROOT.SEG%,G%," CMT Table = "+FNO$(G%))		      &
	\ BBR.REGION%=FNP%(150%,G%-4%)		! CM.BA6		      &
	\ I%=FNGADD%(MSCP.SEG%,BBR.REGION%," BBR Region") IF BBR.REGION%      &
	\ E1%=M1% IF E%							      &
	\ G6%=FNP%(151%,G%+CM.CCT.OFST%-6%)	! TSQ Done queue (CM.DNE)     &
	\ E1%=M1% IF E%							      &
	\ G$=" TSQ done queue #"					      &
	\ GOSUB 14150							      &
	\ I%=FNP%(152%,G%+CM.CCT.OFST%)					      &
	\ E1%=M1% IF E%							      &
	\ G5%=I% AND 255% 		! total number of [T]MSCP controllers &
	\ G4%=SWAP%(I%) AND 255%	! # of MSCP disks		      &
	\ G0$=" RU"							      &
	\ FOR CNTRLR%=0% TO G5%+M1%					      &
	\	G$=" D"					! DSQ default	      &
	\	G0$=" MU" IF CNTRLR% > G4%+M1%				      &
	\	G$=" T" IF CNTRLR% > G4%+M1%		! TSQ if MU	      &
	\	unit%=CNTRLR%				! assume DU	      &
	\	unit%=CNTRLR%-G4% IF CNTRLR% > G4%+M1%	! Get MU unit #	      &
	\	OFFST%=G%+(ENTRY.SIZE%*CNTRLR%)				      &
	\	G6%=FNP%(153%,OFFST%+4%)		! DSQ/TSQ queue root  &
	\	E1%=M1% IF E%						      &
	\	G$=G$+"SQ for"+G0$+NUM1$(unit%)+": #"			      &
	\	GOSUB 14150						      &
	\	G1%=FNP%(154%,OFFST%+CM.AP6.OFST%)			      &
	\	E1%=M1% IF E%						      &
	\	CM.COF%=FNP%(155%,OFFST%+CM.COF.OFST%) AND 63%		      &
	\	E1%=M1% IF E%						      &
	\	CM.CSR%=FNP%(156%,OFFST%+CM.COF.OFST%+4%)		      &
	\	E1%=M1% IF E%						      &
	\	PHYS.ADDRS$=FNO$(G1%)+RIGHT(FNB$(CM.COF%),2%)		      &
	\	G6%=FNMSCP.P%(157%,G1%,CM.COF%+20%)	! C.OLDL	      &
	\	E1%=M1% IF E%						      &
	\	G$=" Oldest command for"+G0$+NUM1$(unit%)+": #"		      &
	!\	GOSUB 14150						      &
	\	IF G1% THEN						      &
		   I%=FNGADD%(MSCP.SEG%,G1%," CCB #"+NUM1$(CNTRLR%)+	      &
				" ("+PHYS.ADDRS$+")")			      &
	\	   I%=FNGADD%(MSCP.SEG%,G1%+1%,"  "+G0$+NUM1$(unit%)+	      &
				": CSR = "+FNO$(CM.CSR%))		      &

14130	NEXT CNTRLR%							      &
		!							      &
		! INITIALIZE OFFSETS INTO THE CMT TABLE.		      &
		! LOOKUP THE SYMBOLS AND ANNOTATE THE CMT/UMT TABLES.	      &
		! ANNOTATE THE BAD BLOCK REPLACEMENT (BBR) REGION IN THE      &
		! MSCP SEGEMENT.					      &
		! ANNOTATE THE CONTROLLER CONTROL BLOCK (CCB) FOR EACH OF     &
		! THE UDA CONTROLLERS.					      &
		! THE PHYSICAL ADDRESS OF THE CCB = THE LOWER 6 BITS OF	      &
		!	CM.COF CONCATENATED TO THE MMU ADDRESS.		      &
		!							      &

14140	RETURN								      &
		! BACK HOME						      &

14150	FOR G7%=1% WHILE G6%<>0% AND G7%<MAX.BUF%			      &
	\	I%=FNGADD%(SEGMNT%,G6%,G$+NUM1$(G7%))			      &
	\	G6%=FNP%(158%,G6%)					      &
	\	E1%=M1% IF E%						      &
	\	NEXT G7%	! next TSQ/DSQ for same controller	      &
	\ RETURN							      &

14300	!								      &
	!								      &
	!      U N A / Q N A   C O N T R O L L E R   A N N O T A T I O N S    &
	!								      &
	!								      &
	! Data Structure Layout:					      &
	!								      &
	!								      &
	!      +---------------+					      &
	!      |               |-+					      &
	!      |   Channel     | |					      &
	!      |   Data        | |    +-------+				      &
	!      |   Block       |----->|Portal |				      &
	!      |   _#0         | |    |Data   |---+       +-------+  +------+ &
	!      |               | |    |Block  |   |------>| CCB   |->| CCB  | &
	!      +---------------+ |    | _#0   |   |---+   | for   |  | for  | &
	!                        |    +-------+   |   |   | RCV   |  | RCV  | &
	!                        |        | _#1   |   |   +-------+  +------+ &
	!                        |        +-------+   |         |        |    &
	!  +---------------------+            | _#2   |         V        V    &
	!  |                                  +-------+   +-------+  +------+ &
	!  |                                              | RCV   |  | RCV  | &
  	!  |   +---------------+                          | buffer|  |buffer| &
	!  +-->|               |                          |       |  |      | &
	!      |   Channel     |                          +-------+  +------+ &
	!      |   Data        |      +-------+				      &
	!      |   Block       |----->|Portal |				      &
	!      |   _#1         |      |Data   |---+			      &
	!      |               |--+   |Block  |   |			      &
	!      +---------------+  |   | _#0   |   |---+			      &
	!                         |   +-------+   |   |			      &
	!                         |       | _#1   |   |			      &
	!          +--------------+       +-------+   |			      &
	!          |                          | _#2   |			      &
	!          |                          +-------+			      &
	!          |							      &
	!          |   +-------+       +-------+			      &
	!          +-->| CCB   |------>| CCB   |			      &
	!              | for   |       | for   |			      &
	!              | XMIT  |--+    | XMIT  |			      &
	!              +-------+  |    +-------+			      &
	!                         |					      &
	!                         |    +-------+			      &
	!                         +--->| Xmit  |			      &
	!                              | buffer|			      &
	!                              +-------+			      &
	!								      &
	!								      &

14320	XCON% = FNP%(160%,M2%(37%))					      &
	\ GOTO 14330 IF XCON% AND 32%					      &
	\ G$="XECORE"							      &
	\ GOSUB 14000							      &
	\ GOTO 14399 IF CF%						      &
	\ I%=FNGADD%(ROOT.SEG%,G%," XEDCTL region, XECORE = "+FNO$(G%))	      &
	\ XECORE% = G%							      &
	\ CDB% = XECORE% + 48%						      &
	\ DPAR6% = XECORE% + 2%						      &
	\ MAX.CONT% = 4%						      &
	\ DEV.NAME$ = "XE"						      &
	\ GOTO 14340							      &
		! IF QBUS, JUMP TO CODE TO SPECIFICLY HANDLE IT		      &
		! FIND XECORE, ABORT IF NOT FOUND			      &
		! EXIT UNIBUS SPECIFIC CODE				      &

14330	G$="XHDATA"							      &
	\ GOSUB 14000							      &
	\ GOTO 14399 IF CF%						      &
	\ I%=FNGADD%(ROOT.SEG%,G%," XHDCTL region, XHDATA = "+FNO$(G%))	      &
	\ XHDATA% = G%							      &
	\ CDB% = XHDATA% + 22%						      &
	\ DPAR6% = XHDATA% + 2%						      &
	\ MAX.CONT% = 4%						      &
	\ DEV.NAME$ = "XH"						      &
		! HANDLE QBUS CASE					      &
		! FIND XHDATA, ABORT IF NOT FOUND			      &
		! EXIT QBUS SPECIFIC CODE				      &

14340	ETH.REGION% = FNP%(161%,DPAR6%)					      &
	\ I% = FNGADD%(MSCP.SEG%,ETH.REGION%," Ethernet Region")	      &
		IF ETH.REGION%						      &
	\ FOR CONT.LOOP% = 1% TO MAX.CONT%				      &
	\ DEV.NAME$=LEFT(DEV.NAME$,2%)+NUM1$(CONT.LOOP%+M1%)+":"	      &
	\ CONT.INDEX% = (CONT.LOOP% + M1%) * 2%				      &
	\ IF FNP%(163%,CDB%+CONT.INDEX%)=0% THEN			      &
	     GOTO 14360							      &

14352	CDBPTR = FNP%(164%,DPAR6%) * 64. +				      &
			(FNP%(165%,CDB%+CONT.INDEX%) AND 8191%)		      &
	\ CDBPEEK = CDBPTR-BBR.REGION%*64.+(MAP%(MSCP.SEG%,0%)+M1%)*512.      &

14355	PDB.PTR% = FNPEEK%(1010%,MSCP.SEG%,CDBPEEK - 14.)		      &
	\ PDB.NUM% = 0%							      &
		! GET PDB POINTER FROM THE CDB				      &

14356	GOTO 14357 IF (PDB.PTR% = 0) OR (PDB.NUM%>MAX.BUF%)		      &
	\ I%=3%		! Guess at 3 buffers for the QNA		      &
	\ I%=FNP%(166%,PDB.PTR%-14%)/32% IF LEFT(DEV.NAME$,2%)="XE"	      &
	\ E1%=M1% IF E%							      &
	\ G%=FNP%(167%,PDB.PTR%-10%) AND 255%	! Owning Job #		      &
	\ G$=" (Job "+NUM1$(G%/2%)+")"					      &
	\ G$=" (TRN)" IF G%=5%						      &
	\ G$=" (LAT)" IF G%=7%						      &
	\ I%=FNGLOOP%(ROOT.SEG%, FNSR5%(PDB.PTR%), I%," "+DEV.NAME$+" PDB #"+ &
		NUM1$(PDB.NUM%)+" for CDB #"+NUM1$(CONT.LOOP%+M1%)+G$)	      &
	\ CCB.PTR = FNP%(168%,PDB.PTR% + 4%)				      &
	\ I% = FNCCB%(CCB.PTR, DEV.NAME$, " RCV Pend. Post.")		      &
	\ PDB.PTR% = FNP%(169%,PDB.PTR%)				      &
	\ PDB.NUM% = PDB.NUM% + 1%					      &
	\ GOTO 14356							      &
		! PUNT IF NO MORE PDBs					      &
		! ANNOTATE IT						      &
		! CHASE ITS CCBs					      &
		! TRY NEXT PDB (EXIT IF WE HAVE ANNOTATED TOO MANY)	      &

14357	CCB.PTR = FNPEEK%(170%,MSCP.SEG%,CDBPEEK + 6.)			      &
	\ I% = FNCCB%(CCB.PTR, DEV.NAME$, "Active RCV BUF")		      &
	\ CCB.PTR = FNPEEK%(171%,MSCP.SEG%,CDBPEEK + 10.)		      &
	\ I% = FNCCB%(CCB.PTR, DEV.NAME$, "Free RCV BUF")		      &
	\ CCB.PTR = FNPEEK%(172%,MSCP.SEG%,CDBPEEK + 22.)		      &
	\ I% = FNCCB%(CCB.PTR, DEV.NAME$, "Outstn. XMIT BUF")		      &
	\ CCB.PTR = FNPEEK%(173%,MSCP.SEG%,CDBPEEK + 26.)		      &
	\ I% = FNCCB%(CCB.PTR, DEV.NAME$, "Pending XMIT BUF")		      &
		! CHASE CCBs OFF THE CDB				      &

14360	NEXT CONT.LOOP%							      &

14399	RETURN								      &
		! LET'S PUNT THIS COOKIE STAND				      &

14500	!								      &
	!								      &
	!	X B U F    A N N O T A T I O N S			      &
	!								      &
	!								      &

14510	 RETURN IF XBUF.ST%=0% AND XBUF.END%=0%				      &
	\ IF FNF(XBUF.END%)<FNF(XBUF.ST%) THEN				      &
		E1%=M1%							      &
	  ELSE								      &
		I%=FNGADD%(XBUF.SEG%,XBUF.ST%," Start of XBUF = "+	      &
		   FNO$(XBUF.ST%)+"00")					      &
	\	I%=FNGADD%(XBUF.SEG%,XBUF.END%," End of XBUF = "+	      &
		   FNO$(XBUF.END%)+"00")				      &
	\	G1%=XBUF.ST%			! Start at the beginning      &
	\	FOR G3%=0% WHILE G1%					      &
	\		G2%=FNXBUF.P%(180%,G1%,2%)	! Get the length      &
	\		E1%=M1% IF E%					      &
	\		G$=NUM1$(G2%)					      &
	\		G$="??" IF E%					      &
	\		G2%=1% IF E%					      &
	\		I%=FNGLOOP%(XBUF.SEG%,G1%,G2%," XBUF free #"+	      &
				NUM1$(G3%)+", "+G$+" slivers") IF G2%	      &
	\		G1%=FNXBUF.P%(181%,G1%,0%)	! Get next pointer    &
	\		E1%=M1% IF E%					      &
	\	NEXT G3%						      &
		!							      &
		! ANNOTATE THE BEGINNING AND END OF XBUF		      &
		! Also follow the XBUF free chain			      &

14520	! The loaded SATT tables are annotated in the DSQ section	      &
	! because there was code there already to deal with finding	      &
	! all the disk types and each unit for the types.		      &
	!								      &
	! The QTB tables are also annotated in the DSQ section		      &
	! for the same reason.						      &
	!								      &
	G$="SYSLOG"	! contorted address of first system logical	      &
	\ GOSUB 14000							      &
	\ G1%=G%							      &
	\ GOTO 14530 IF CF%						      &
	\ G1%=FNP%(185%,G1%)						      &
	\ E1%=M1% IF E%							      &
	\ FOR G2%=1% WHILE G1%<>0% AND G2%<MAX.BUF%			      &
	\	G3%=FNR7R%(G1%)						      &
	\	I%=FNGADD%(XBUF.SEG%,G3%," System Logical Block #"+NUM1$(G2%)) &
	\	G1%=FNXBUF.P%(186%,G3%,0%)				      &
	\	E1%=M1% IF E%						      &
	\ NEXT G2%							      &

14530	G$="CHESEC"							      &
	\ GOSUB 14000							      &
	\ G1%=FNP%(500%,G%+2%)	! CHENXT - get the first pointer @+2	      &
	\ E1%=M1% IF E%							      &
	\ G10%=G%+4%		! Address of CHELST - pointer to last	      &
	\ G$="$$CACH"							      &
	\ GOSUB 14000							      &
	\ CHE.AP5%=FNP%(501%,G%)	! Get the APR6 MMU value	      &
	\ E1%=M1% IF E%							      &
	\ TMP%=(G1% AND 8191%)/64%	! Calculate the offset in APR5	      &
	\ G$=FNO$(CHE.AP5%+TMP%)+RIGHT(FNB$((G1% AND 31%)-2%),2%)	      &
	\ I%=FNGADD%(XBUF.SEG%,CHE.AP5%+TMP%," First Used Tag = "+G$) IF G1%  &
	\ G2%=FNP%(502%,G%+2%)	! CHETAG - List of usable extended cache tags &
	\ TMP%=(G2% AND 8191%)/64%	! Calculate the offset in APR5	      &
	\ G$=FNO$(CHE.AP5%+TMP%)+RIGHT(FNB$(G2% AND 31%),2%)		      &
	\ I%=FNGADD%(XBUF.SEG%,CHE.AP5%+TMP%," First Free Tag = "+G$) IF G2%  &
	\ G3%=FNP%(503%,G%+6%)	! CHEWTG - List of usable cache write-tags    &
	\ TMP%=(G3% AND 8191%)/64%	! Calculate the offset in APR5	      &
	\ G$=FNO$(CHE.AP5%+TMP%)+RIGHT(FNB$(G3% AND 31%),2%)		      &
	\ I%=FNGADD%(XBUF.SEG%,CHE.AP5%+TMP%," First Write Tag = "+G$) IF G3% &
	\ G$="$$CBSZ"							      &
	\ GOSUB 14000							      &
	\ G4%=FNP%(504%,G%)	! CHEBSZ - Cache clustersize (in blocks)      &
	\ E1%=M1% IF E%							      &
	\ G5%=G%+16%	! TMWQUE - Queue for writes awaiting free write-tag   &
	\ G$="CHRDL3"							      &
	\ GOSUB 14000							      &
	\ G6%=G%-2%	! CHWRTQ - Caching queue root for writes	      &
	\ G7%=G%+4%	! CHREDQ - Caching queue root for reads		      &
	\ G$="CHENUE"							      &
	! This points to the total count of extended tags		      &
	\ GOSUB 14000							      &
	\ G8%=G%+2%	! CHFCNT - FIP (directory) type pointer		      &
		! +4%	  CHDCNT - Data type pointer			      &
	\ G14%=M2%(21%)	! DSKLOG pointer for converting FUN to name	      &
	\ FOR G9%=1% WHILE G1%<>G10% AND G1%<>0% AND E1%=0%		      &
	\	TMP%=G1% AND 8191%	! Calculate the offset in APR5	      &
	\	G11%=FNXBUF.P%(505%,CHE.AP5%,TMP%+10%)			      &
			! Get the type pointer				      &
	\	E1%=M1% IF E%						      &
	\	G$="Unknown"						      &
	\	G$="Dir." IF G11%=G8%					      &
	\	G$="File" IF G11%=G8%+2%				      &
	\	G11%=FNXBUF.P%(506%,CHE.AP5%,TMP%+2%)			      &
			! Return the unit # and MSB of block number	      &
	\	I%=G11% AND 255%	! Just the FUN			      &
	\	G13%=FNP%(507%,G14%+6%+(I%*10%))	! Name		      &
	\	TMP$=CVT%$(SWAP%(G13%))			! in ascii	      &
	\	G13%=FNP%(508%,G14%+8%+(I%*10%))	! Unit #	      &
	\	TMP$=TMP$+NUM1$(G13% AND 255%)+":"	! in ascii	      &
	\	G12%=FNXBUF.P%(509%,CHE.AP5%,TMP%+4%)			      &
			! Return the LSB of the block number		      &
	\	G13%=FNXBUF.P%(510%,CHE.AP5%,TMP%+6%)			      &
			! Get the MMU value for the data itself		      &
	\	R=65536.*(SWAP%(G11%) AND 255%)+G12%			      &
	\	FOR I1%=0% TO G4%-1%	! Do each block of the cluster	      &
	\	    I%=FNGLOOP%(XBUF.SEG%,G13%+(I1%*8%),8%," "+G$+" FBN "+    &
			NUM1$(R+I1%)+" on "+TMP$)			      &
	\	NEXT I1%						      &
	\	G13%=FNXBUF.P%(511%,CHE.AP5%,TMP%+8%)			      &
			! Pointer to DSQ's waiting on tag		      &
	\	I%=FNGADD%(ROOT.SEG%,G13%," DSQ waiting on Tag #"+NUM1$(G9%)) &
				IF G13%					      &
	\	I%=FNGADD%(XBUF.SEG%,CHE.AP5%+(TMP%/64%)," Tag #"+NUM1$(G9%)+ &
			" for "+TMP$) IF 1%=2%				      &
	!	This will annotate each tag, but takes LOTS of space	      &
	\	G1%=FNXBUF.P%(512%,CHE.AP5%,TMP%-2%)			      &
			! Get the pointer to the next cache tag		      &
	\	E1%=M1% IF E%						      &
	\ NEXT G9%							      &
	!								      &
	! Cache tags look as follows:					      &
	!								      &
	!  0	CH.NXT	Pointer to next @ CH.PRV			      &
	!  2	CH.PRV	Pointer to previous @ CH.NXT			      &
	!  4	CH.UNT	Unit number of block				      &
	!  5	CH.MSB	Block's FBN (MSB)				      &
	!  6	CH.LSB	Block's FBN (LSB)				      &
	!  8	CH.DAT	Pointer to Cached data block			      &
	! 10	CH.BLS	Pointer to DSQ's waiting on tag			      &
	! 12	CH.TYP	Type pointer (data or directory)		      &
	!			CHENUE+2 = Directory			      &
	!			CHENUE+4 = Data				      &
	! 14	CH.TIM	Time of last reference				      &
	!								      &
	! Cache write-tags (in use) look as follows:			      &
	!								      &
	!  0	WT.TYP	Write-tag type (real or from tag list)		      &
	!		  Real = 0  -  Borrowed <>0			      &
	! 1-9		Saved values from the DSQ			      &
	! 10	WT.CTP	Saved pointer to cache tag			      &
	!								      &
	! Cache write-tags (free) look as follows:			      &
	!								      &
	!  0		Pointer to next free write tag			      &
	! the rest	unused						      &

14570	! Many DECnet data structures also live in XBUF.		      &
	!								      &
	!	ENDCHE - MMU value of end-node cache  - 16		      &
	!	RTEMMU - MMU address of cost/hops vector - 17		      &
	!	OAJMMU - MMU address of adjacency vector - 18		      &
	!	MTXMMU - MMU value to map routing matrix - 19		      &
	!	EVTMMU - MMU value for Event logger database - 21	      &
	!								      &
	GOTO 14590 UNLESS DECNET%					      &
	\ G1%=FNR7R%(FNP%(530%,DEC%(8%)))	! Get the LLT MMU value	      &
	\ GOSUB 14580							      &
	\ I%=FNGLOOP%(XBUF.SEG%,G1%,G2%," DECnet LLT Buffer") IF G1%	      &
	\ G1%=FNP%(531%,DEC%(16%))	! Get the ENDCHE MMU value	      &
	\ GOSUB 14580							      &
	\ I%=FNGLOOP%(XBUF.SEG%,G1%,G2%," DECnet End node cache") IF G1%      &
	\ G1%=FNP%(532%,DEC%(17%))	! Get the cost/hops vector MMU value  &
	\ GOSUB 14580							      &
	\ I%=FNGLOOP%(XBUF.SEG%,G1%,G2%," DECnet Cost/Hops Vector") IF G1%    &
	\ G1%=FNP%(533%,DEC%(18%))	! Get the Adjacency vector MMU value  &
	\ GOSUB 14580							      &
	\ I%=FNGLOOP%(XBUF.SEG%,G1%,G2%," DECnet Adjacency vector") IF G1%    &
	\ G1%=FNP%(534%,DEC%(19%))	! Get the Routing matrix MMU value    &
	\ GOSUB 14580							      &
	\ I%=FNGLOOP%(XBUF.SEG%,G1%,G2%," DECnet Routing Matrix") IF G1%      &
	\ G1%=FNP%(535%,DEC%(21%))	! Get the EVTLOG database MMU value   &
	\ GOSUB 14580							      &
	\ I%=FNGLOOP%(XBUF.SEG%,G1%,G2%," DECnet EVTLOG database") IF G1%     &
	\ ADJ.TXT$(0%)=" Adjacency flag table"				      &
	\ ADJ.TXT$(1%)=" Adjacency node address table"			      &
	\ ADJ.TXT$(2%)=" Adjacency circuit table"			      &
	\ ADJ.TXT$(3%)=" Adjacency blocksize table"			      &
	\ ADJ.TXT$(4%)=" Adjacency listen timer value"			      &
	\ ADJ.TXT$(5%)=" Adjacency timers"				      &
	\ G%=DEC%(22%)			! ADJFLG pointer		      &
	\ FOR G4%=0% STEP 2% WHILE G4%<=10% AND G%<>0%			      &
	\	G1%=FNP%(536%,G%+G4%)					      &
	\	GOSUB 14580						      &
	\	I%=FNGLOOP%(XBUF.SEG%,G1%,G2%,ADJ.TXT$(G4%/2%)) IF G1%	      &
	\	ADJ.TXT$(G4%/2%)=NL$					      &
	\ NEXT G4%							      &
	\ GOTO 14590							      &

14580	E1%=M1% IF E%							      &
	\ G2%=FNXBUF.P%(537%,G1%,0%)/64% IF G1%	! Get the length	      &
	\ E1%=M1% IF E%							      &

14590	RETURN								      &

14600	!	initialize a bunch of XBUF variables.			      &
	!								      &
	I%=XBUF.SEG%*4%							      &
	\ XBUF.ST%=FNP%(540%,M2%(33%)+I%)				      &
	\ XBUF.END%=XBUF.ST%+FNP%(541%,M2%(33%)+I%+2%)+M1%		      &

14900	RETURN								      &
	! GO HOME							      &

15000	!								      &
									      &
									      &
	!	F U N C T I O N S					      &
									      &
									      &

15050	DEF* FNE.A%(Q$)							      &
	\	PRINT #1%, C$;C$;C$;"Errors encountered in ";Q$;	      &
		" annotations";" - they may not be accurate.";C$;C$;	      &
			if e1%						      &
	\	PRINT #1%, C$;C$;C$;					      &
		"Ran out of room for annotations - segment = ";Q$;C$;	      &
		"    Annotation count = ";NUM1$(GX.FREE%);C$;		      &
		"    Duplicate count  = ";NUM1$(DUP.FREE%);C$;C$;	      &
						IF TOO.MANY%		      &
	\ FNEND								      &

15100	DEF* FNSR5%(Q%)=						      &
		(Q% AND 32767%)/32% OR (1024% AND (Q%<0%))		      &
									      &
	! SHIFTS INTEGER Q% 5 BITS TO THE RIGHT, TAKING INTO ACCOUNT	      &
	! THAT Q% MIGHT BE NEGATIVE.					      &

15120	DEF* FNR7R%(Q%)=(SWAP%(Q%)*2%) OR ((Q% AND 128%)/128%)		      &
									      &
	! ROTATES A 16 BIT INTEGER RIGHT 7 PLACES.			      &
	! IT'S FOR TURNING A CONTORTED ADDRESS INTO AN MMU ADDRESS.	      &
	! IF YOU ADD 6 MORE BITS TO THE LOW ORDER END OF THE MMU ADDRESS,     &
	! YOU END UP WITH A 22-BIT PHYSICAL XBUF ADDRESS.		      &

15130	DEF* FNR7L%(Q%)=SWAP%((Q% AND 32767%)/2%+(16384% AND (Q%<0%)))	      &
		OR (128% AND (Q% AND 1%)<>0%)				      &
		! THIS ONE LEFT ROTATES A 16=BIT INTEGER.		      &
		! SHIFT IT RIGHT ONE POSITION, SAVE THE SIGN BIT, SWAP IT,    &
		! AND REPLACE THE 1 BIT IN 128				      &
		! TRY IT YOURSELF.  MAYBE I'M WRONG.			      &

15200	DEF* FNB$(Q%)							      &
	\ FNB$=NL$							      &
	! FUNCTION	FNB$	GET A 3 POSITION OCTAL STRING		      &

15210	Q%=Q% AND 255%							      &
	\ Q0%=64%							      &
	\ Q$=NL$							      &
	\ WHILE Q0%>0%							      &
	\	Q1%=Q%/Q0%						      &
	\	Q%=Q%-Q0%*Q1%						      &
	\	Q0%=Q0%/8%						      &
	\	Q$=Q$+CHR$(48%+Q1%)					      &
	\ NEXT								      &
	! CONVERT THE NUMBER TO OCTAL, SAVING EACH DIGIT		      &

15230	FNB$=Q$								      &
	! SET THE FUNCTION						      &

15240	FNEND								      &
									      &

15300	DEF* FNN$(S%,N%)						      &
	\ FNN$=NL$							      &
	! FUNCTION	FNN$	TURN N% INTO A STRING AND LEFT PAD	      &
	!			THE STRING WITH SPACES			      &

15310	S$=NUM1$((N% EQV 32767%)+32768.)				      &
	\ FNN$=FNS$(S%)							      &
	! GET THE STRING (MAKE SURE IT'S POSITIVE) AND LEFT PAD IT.	      &

15320	FNEND								      &

15400	DEF* FNO$(Q%)							      &
	\ FNO$=NL$							      &
	! FUNCTION	FNO$	GET A 6 POSITION OCTAL STRING		      &

15410	Q$="0"								      &
	\ Q0%=4096%							      &
	\ IF Q%<0% THEN							      &
		Q$="1"							      &
	\	Q%=Q%+32767%+1%						      &
	! SET UP TO CONVERT THE NUMBER					      &
	! TAKE CARE OF NEGATIVE NUMBERS					      &

15420	WHILE Q0%>0%							      &
	\	Q1%=Q%/Q0%						      &
	\	Q%=Q%-Q0%*Q1%						      &
	\	Q0%=Q0%/8%						      &
	\	Q$=Q$+CHR$(48%+Q1%)					      &
	\ NEXT								      &
	! CONVERT THE NUMBER TO OCTAL, SAVING EACH DIGIT		      &

15430	FNO$=Q$								      &
	! SET THE FUNCTION						      &

15440	FNEND								      &
									      &

15500	DEF* FNP%(S.L%,Q%)						      &
	! FUNCTION	FNP%	THIS FUNCTION IS EQUIVALENT		      &
	!			TO A PEEK OF AN ADDRESS			      &
	!								      &

15510	FNP%,E%=0%							      &
	\ IF (Q% AND 1%)<>0% THEN					      &
		E%=M1%							      &
	\	PRINT #1%, C$;"Odd PEEK Address - ";NUM1$(FNF(Q%));	      &
				" (from ";NUM1$(S.L%);")"		      &
	\	GOTO 15560						      &

15520	R=FNF(Q% AND -2%)						      &
	\ IF R >= 0. AND R <= EPMM THEN					      &
		SEGMNT%=ROOT.SEG%					      &
	\	FNP%=FNPEEK%(1001%,SEGMNT%,R)				      &
	\	GOTO 15560						      &
		! IF THE ADDRESS IS BETWEEN 0 AND $$EPMM THEN		      &
		! PEEK AT THE ROOT SEGMENT.				      &
		!							      &

15530	GOTO 15540 IF R > EPMM						      &
		  AND R < FPL.ST					      &
	\ IF FPLAP6% <> 0% THEN						      &
		IF R <= FPL.END THEN					      &
			SEGMNT%=FPL.SEG%				      &
	\		OFFSET=R-FPL.ST					      &
	\		R=((MAP%(FPL.SEG%,0%)+M1%)*512.)+OFFSET		      &
	\		FNP%=FNPEEK%(1002%,SEGMNT%,R)			      &
	\		GOTO 15560					      &
		! ERROR IF THE ADDRESS IS BETWEEN PERMANENTLY MAPPED	      &
		! MEMORY AND AND THE START ADDRESS OF FIP POOL.		      &
		! PEEK INTO THE FIP POOL IF WE HAVE FIP POOL AND	      &
		! THE ADDRESS IS NOT BEYOND THE UPPER LIMIT.		      &

15540	E%=M1%								      &
	\ PRINT #1%, C$;"Address out of range - ";NUM1$(FNF(Q%));	      &
				" (from ";NUM1$(S.L%);")"		      &

15560	FNEND								      &
									      &

15570	DEF* FNJCR.P%(S.L%,AD,Q%)					      &
	\ FNJCR.P%=0%							      &
	\ IF MAP%(JCTRL.SEG%,0%)=0% THEN E%=M1%				      &
	\	GOTO 15574						      &

15572	AD=AD+((MAP%(JCTRL.SEG%,0%)+M1%)*512.)				      &
	\ S%,FNJCR.P%=FNPEEK%(S.L%,JCTRL.SEG%,AD)			      &
	\ S%=FNP%(S.L%,S%) UNLESS Q% ! Set the segment # for this address     &

15574	FNEND								      &

15580	DEF* FNXBUF.P%(S.L%,S%,Q%)					      &
	\ FNXBUF.P%=0%							      &
	\ IF MAP%(XBUF.SEG%,0%)=0% THEN E%=M1%				      &
	\	GOTO 15584						      &

15582	AD=((FNF(S%-XBUF.ST%))*64%)+Q%					      &
	\ AD=AD+((MAP%(XBUF.SEG%,0%)+M1%)*512.)				      &
	\ FNXBUF.P%=FNPEEK%(S.L%,XBUF.SEG%,AD)				      &

15584	FNEND								      &

15590	DEF* FNMSCP.P%(S.L%,S%,Q%)					      &
	\ FNMSCP.P%=0%							      &
	\ IF MAP%(MSCP.SEG%,0%)=0% THEN E%=M1%				      &
	\	GOTO 15594						      &

15592	AD=((FNF(S%-BBR.REGION%))*64%)+Q%				      &
	\ AD=AD+((MAP%(MSCP.SEG%,0%)+M1%)*512.)				      &
	\ FNMSCP.P%=FNPEEK%(S.L%,MSCP.SEG%,AD)				      &

15594	FNEND								      &

15600	DEF* FNPEEK%(S.L%,SEG%,AD)					      &
		! FUNCTION TO TRANSLATE A MEMORY ADDRESS TO		      &
		! BLOCK AND OFFSET IN A FILE OF INTEGERS.		      &

15610	FNPEEK%=0%							      &
	\ START.ADDRS=(MAP%(SEG%,0%)+M1%)*512.				      &
	\ END.ADDRS=MAP%(SEG%,1%)*512.+MAP%(SEG%,2%)			      &
	\ IF (AD<START.ADDRS) OR (AD>END.ADDRS) THEN			      &
		PRINT #1%, C$;"%Peek address (";			      &
			   NUM1$(AD);") out of range, (";		      &
			   NUM1$(START.ADDRS);" - ";			      &
			   NUM1$(END.ADDRS);")";			      &
				" (from ";NUM1$(S.L%);")"		      &
	\ E%=M1%							      &
	\ GOTO 15630							      &
		! INVALID ADDRESS					      &

15620	BASE.BLOCK%=MAP%(SEG%,0%)					      &
	\ AD=AD-START.ADDRS						      &
	\ ADD.BLOCK%=(AD/512%)						      &
	\ ADD.OFFSET%=AD-((ADD.BLOCK%)*512.)+1%				      &
	\ GET #12%, BLOCK (BASE.BLOCK%+ADD.BLOCK%)			      &
	\ FNPEEK%=SWAP%(CVT$%(MID(D$,ADD.OFFSET%,2%)))			      &

15630	FNEND								      &

15690	DEF* FNF(QQ%)=(QQ% AND 32767%) - (32768. * (QQ% < 0%))		      &

15700	DEF* FNE$(E8%)=							      &
	CVT$$(RIGHT(SYS(CHR$(6%)+CHR$(9%)+CHR$(E8%)),3%),4%)		      &
	! EXTRACT AN ERROR MESSAGE.					      &

15800	DEF* FNS$(S%)=SPACE$(S%-LEN(S$))+S$				      &
	! LEFT PAD A STRING WITH SPACES.				      &

16000	DEF* FNDDCU$(DDB.PTR%)						      &
	! THIS FUNCTION RETURNS A DEVICE DESIGNATOR STRING IN		      &
	! DDCU FORMAT, FOR DMC, DMR, DMP, DMV DEVICES.			      &
	! IT REQUIRES THE GLOBAL VARIABLE CR.VP% TO BE VALID		      &
	!	CR.VP = 1  FOR DMC/DMR					      &
	!	CR.VP = -1 FOR DMV/DMP					      &
	! IT LOOKS AT THE DDFLAG WORD IN THE DDB OF THE DEVICE, TO	      &
	! DETERMINE WHETHER THE DEVICE IS DMC OR DMR, OR IN THE		      &
	! OTHER CASE WHETHER IT IS DMV OR DMP.				      &
	! FORMAT FOR THE DEVICES IS AS FOLLOWS:				      &
	!	DMC	DMC-0, DMC-1, DMC-2...				      &
	!	DMR	DMR-0, DMR-1, DMR-2...				      &
	!	DMV	DMV-0.0, DMV-0.1,... DMV-1.0, DMV-1.1...	      &
	!	DMP	DMP-0.0, DMP-0.1,... DMP-1.0, DMP-1.1...	      &

16010	FNDDCU$=NL$							      &
	\ DDFLAG%=(FNP%(200%,DDB.PTR%+8%) AND 128%)			      &
	\ IF (CR.VP%=1%) THEN						      &
		FNDDCU$="DM"+"C-"					      &
			+NUM1$(SWAP%(FNP%(201%,DDB.PTR%+2%)) AND 255%)	      &
							UNLESS DDFLAG%	      &
	\	FNDDCU$="DM"+"R-"					      &
			+NUM1$(SWAP%(FNP%(202%,DDB.PTR%+2%)) AND 255%)	      &
							IF DDFLAG%	      &
	\	GOTO 16040						      &

16020	IF (CR.VP%=M1%) THEN						      &
		TOT.UTS%=0%						      &
	\	DDC.OFS%=DDCTBL%+(FNP%(203%,DDB.PTR%) AND 255%)		      &
	\	OFS.CTS%=FNP%(204%,DDC.OFS%)				      &
	\	UCT.OFS%=UCTTBL%+(SWAP%(OFS.CTS%) AND 255%)		      &
	\	NUM.CTS%=OFS.CTS% AND 255%				      &
	\	UNIT.NUMBER%=SWAP%(FNP%(205%,DDB.PTR%+2%)) AND 255%	      &
	\	FOR CTS%=0% TO NUM.CTS%+M1%				      &
	\		U.P.C%=FNP%(206%,UCT.OFS%+(2%*CTS%))		      &
	\		FOR UTS%=0% TO U.P.C%+M1%			      &
	\			GOTO 16030 IF TOT.UTS%=UNIT.NUMBER%	      &
	\			TOT.UTS%=TOT.UTS%+1%			      &
	\		NEXT UTS%					      &
	\	NEXT CTS%						      &
	\	FNDDCU$="???"						      &
	\	GOTO 16040						      &
	! TO TRANSLATE "XD?" INTO DM?-?.? FORMAT, WE NEED TWO TABLES.	      &
	! THE DDCTBL IS A TABLE ORGANIZED AS FOLLOWS:			      &
	!								      &
	!			DDCTBL					      &
	!			+-----------------+-----------------+	      &
	! OFFSET BY DDIDX ---->	|  UCTTBL OFFSET  | CONTROLLERS/DEV |	      &
	!			+-----------------+-----------------+	      &
	!                       |                 |                 |	      &
	!			+-----------------+-----------------+	      &
	!			|                ETC                |	      &
	!								      &
	!			UCTTBL					      &
	!			+-----------------+-----------------+	      &
	! OFFSET FROM DDCTBL -> | NUMBER OF UNITS ON CONTROLLER #0  |	      &
	!			+-----------------+-----------------+	      &
	!			| NUMBER OF UNITS ON CONTROLLER #1  |	      &
	!			+-----------------+-----------------+	      &
	!			|                ETC                |	      &
	!								      &
	! TO MAKE THE TRANSLATION, YOU HAVE TO COUNT THE NUMBER OF	      &
	! UNITS ON EACH CONTROLLER, AND ADD 'EM UP UNTIL YOU GET TO THE	      &
	! UNIT NUMBER IN THE DDB%.  FOR EXAMPLE, IF THERE ARE 4 CONTROLLERS,  &
	! AND EACH CONTROLLER HAS 4 UNITS, THEN "XD6" WOULD BE DM?-1.2	      &

16030		FNDDCU$="DM"+"P-"+NUM1$(CTS%)+"."+NUM1$(UTS%)		      &
						UNLESS DDFLAG%		      &
	\	FNDDCU$="DM"+"V-"+NUM1$(CTS%)+"."+NUM1$(UTS%)		      &
						IF DDFLAG%		      &
	\	GOTO 16040						      &

16040	FNEND								      &

17000	DEF* FNGLOOP%(SEG%,G%,G0%,G$)					      &
	\ I0%=32%							      &
	\ I0%=1% IF SEG%=XBUF.SEG% OR SEG%=JCTRL.SEG% OR SEG%=MSCP.SEG%	      &
	\ FNGLOOP%=FNGADD%(SEG%,G%*I0%,G$)				      &
	\ GOTO 17020 IF G0%=1%						      &
	\ FOR I%=G%+1% TO G%+G0%-2%					      &
	\	FNGLOOP%=FNGADD%(SEG%,I%*I0%,"  ..."+G$)		      &
	\ NEXT I%							      &
	\ FNGLOOP%=FNGADD%(SEG%,(G%+G0%+M1%)*I0%,"  End"+G$)		      &

17020	FNEND								      &

17100	DEF* FNGADD%(SEG%,G%,G$)					      &
	\   FNGADD%=0%							      &
	\   GOTO 17190 IF SEG%=XBUF.SEG% AND D.UMP%=2%	! No XBUF DUMP	      &
	\   E%=M1% IF SEG%<>ROOT.SEG% AND MAP%(SEG%,0%)=0%		      &
	\   GOTO 17190 IF E%						      &

17110	   G%=FNSR5%(G%) IF SEG%=ROOT.SEG% OR SEG%=FPL.SEG%		      &
	\ G%=FNF(G%)-FNF(MAP%(SEG%,3%)) IF SEG%=XBUF.SEG%		      &
	\   GOTO 17190 IF G% < 0%					      &
		       OR G% > 16384%					      &
	\   GX.FREE%=GX.FREE%+1%					      &
	\   GOTO 17120 if (GX.FREE%<=GX.MAX%) and (GX.FREE%>0%)		      &
	\   TOO.MANY%=M1%						      &
	\   GOTO 17190							      &
		! DIVIDE THE ADDRESS BY 32 IF THE SEGMENT IS THE MONITOR.     &
		! SKIP THIS ANNOTATION IF IT'S OUT OF RANGE.		      &
		! TURN OFF ANNOTATIONS IF WE'VE REACHED MAXIMUM ALLOWED.      &
		!							      &

17120	   GOTO 17130 IF GX%(G%,0%)					      &
	\   GX%(G%,0%)=GX.FREE%						      &
	\   GOTO 17180							      &
		! DO WE ALREADY HAVE AN ANNOTATION FOR THIS ADDRESS?	      &
		! NO, SAVE THE POINTER INTO THE ANNOTATION LIST AND	      &
		!     GO ENTER THE ANNOTATION.				      &
		!							      &

17130	   DUP.FREE%=DUP.FREE%+1%					      &
	\   GOTO 17140 if (DUP.FREE%<=DUP.MAX%) AND (DUP.FREE%>0%)	      &
	\   TOO.MANY%=M1%						      &
	\   GOTO 17190							      &
		! YES WE HAVE AN ANNOTATION FOR THIS ADDRESS THEREFORE	      &
		! WE HAVE TO MAKE AN ENTRY IN THE DUPLICATE LIST.	      &
		! TURN OFF ANNOTATIONS IF WE RAN OUT OF ROOM IN THE	      &
		! DUPLICATE LIST.					      &
		!							      &

17140	   GOTO 17150 IF GX%(G%,1%)					      &
	\   GX%(G%,1%)=DUP.FREE%					      &
	\   DUPLST%(DUP.FREE%,0%)=GX.FREE%				      &
	\   GOTO 17180							      &
		! IS THERE ALREADY AN ENTRY IN THE DUPLICATE LIST	      &
		! FOR THIS ADDRESS?					      &
		! NO, THEN SAVE THE POINTER INTO THE DUPLICATE LIST,	      &
		!     SAVE THE ANNOTATION LIST POINTER IN THE DUPLICATE	      &
		!     LIST TABLE AND GO SAVE THE ANNOTATION.		      &
		!							      &

17150	   G%=GX%(G%,1%)
17160	   GOTO 17170 UNLESS DUPLST%(G%,1%)				      &
	\   G%=DUPLST%(G%,1%)						      &
	\   GOTO 17160							      &
		! GET THE POINTER INTO THE DUPLICATE LIST.		      &
		! DOES IT HAVE A LINK POINTER TO ANOTHER ENTRY?		      &
		! YES, GET THAT ENTRY AND TEST AGAIN.			      &
		!							      &

17170	   DUPLST%(G%,1%)=DUP.FREE%					      &
	\   DUPLST%(DUP.FREE%,0%)=GX.FREE%				      &
		! AH, WE'VE FOUND THE TAIL OF THE LINK LIST.		      &
		! SET THE LINK POINTER FOR THE NEW ENTRY AND		      &
		! SAVE THE POINTER INTO THE ANNOTATION LIST		      &
		! IN THAT NEW ENTRY.					      &
		!							      &

17180	   GX$(GX.FREE%)=CHR$(SEG%)+G$					      &
		! STORE THE ANNOTATION.					      &

17190	FNEND								      &
									      &

17300	DEF* FNDO.QUEUE%(QUEUE$)					      &
	!								      &
	!								      &
	! FUNCTION FNDO.QUEUE% IS DESIGNED TO INITIATE THE ANNOTATION	      &
	! OF THE GLOBAL QUEUES.						      &
	!								      &
	!	INPUT - QUEUE NAME					      &
	!								      &
	!	OUTPUT - NO VALUE RETUNED				      &
	!								      &

17310	E%=0%								      &
	\ G$=QUEUE$							      &
	\ GOSUB 14000							      &
	\ GOTO 17320 IF CF%						      &
	\ G1%=G%		! Save for later			      &
	\ G%=FNP%(210%,G%)						      &
	\ E1%=M1% IF E%							      &
	\ GOTO 17320 IF E%<>0% OR G%=0% OR G%=G1%			      &
	\ TMP%=FNCCB%(G%,NL$,QUEUE$)					      &
		!							      &
		! DO A SYMBOL TABLE LOOKUP ON THE QUEUE NAME.		      &
		! ANNOTATE THE CCB'S FOR THIS QUEUE LIST		      &
		!	IF THE SYMBOL FOR THE QUEUE EXISTS		      &
		!      AND THE POINTER TO THE QUEUE LIST HEAD IS NOT ZERO.    &
		!	and doesn't point to itself			      &
		!							      &

17320	FNEND								      &

17400	DEF* FNCCB%(PNTR%,DEV.NAME$,QUEUE$)				      &
	!								      &
	!								      &
	! THIS FUNCTION DOES THE ACTUAL ANNOTATING OF THE CCBS.		      &
	!								      &
	!	INPUTS - POINTER TO THE HEAD OF THE QUEUE LIST		      &
	!		 DEVICE NAME IN DDCU FORMAT. NULL STRING	      &
	!				IF DOING GLOBAL QUEUES		      &
	!		 QUEUE NAME					      &
	!								      &
	!	OUTPUTS - NONE						      &
	!								      &

17410	FOR LOOP.CNTR%=1% WHILE PNTR%<>0% AND LOOP.CNTR% <= MAX.BUF%	      &
	\	IF LOOP.CNTR% >= MAX.BUF% THEN				      &
			PRINT #1%, C$;C$;C$;				      &
				  "Endless loop in CCB annotations for";      &
	\		PRINT #1%, " device ";DEV.NAME$; IF LEN(DEV.NAME$)    &
	\		PRINT #1%, " queue list ";QUEUE$;C$		      &
	\		GOTO 17430
17420		TMP$,TMP2$=NL$						      &
	\	TMP$=" CCB #"+NUM1$(LOOP.CNTR%)				      &
	\	TMP2$=" "+DEV.NAME$ IF LEN(DEV.NAME$)			      &
	\	TMP2$=TMP2$+" "+QUEUE$					      &
	\	I%=FNGADD%(ROOT.SEG%,PNTR%,TMP$+" on"+TMP2$)		      &
	\	G%=FNP%(211%,PNTR%+24%)					      &
	\	GOTO 17430 IF E%					      &
	\	IF G% THEN						      &
			SEGMNT%=XBUF.SEG%				      &
	\		SEGMNT%=ROOT.SEG% UNLESS (G% AND 31%)		      &
	\		NO.SEG%=(MAP%(SEGMNT%,0%)=0%)			      &
	\		PRINT #1%, TMP$;TMP2$;" not annotated because";	      &
			" XBUF segment (#";NUM1$(SEGMNT%);") not dumped"      &
				IF NO.SEG%				      &
	\		GOTO 17425 IF NO.SEG%				      &
	\		G%=FNR7R%(G%) IF SEGMNT%=XBUF.SEG%		      &
	\		I%=FNXBUF.P%(212%,G%,0%)/64%			      &
	\		I%=FNGLOOP%(SEGMNT%,G%,I%,TMP$+TMP2$+" data")
17425		PNTR%=FNP%(213%,PNTR%)					      &
	\	GOTO 17430 IF E%					      &
	\ NEXT LOOP.CNTR%						      &
		!							      &
		! INITIALIZE THE LOOP COUNTER (KEEPS US FROM GETTING.	      &
		! INTO AN ENDLESS LOOP) AND THE CCB COUNTER.		      &
		! UNTIL THERE ARE NO MORE CCBS.				      &
		!	IF WE'VE EXCEEDED THE MAXIMUM LOOP RANGE THEN	      &
		!		PRINT AN ERROR MESSAGE.			      &
		!	ELSE						      &
		!		CREATE THE ANNOTATION STRING AND ANNOTATE     &
		!		THE CCB.				      &
		!		GET THE POINTER TO THIS CCB'S DATA BUFFER     &
		!		IF THE POINTER IS NOT 0 THEN		      &
		!			CONVERT THE CONTORTED ADDRESS INTO    &
		!			AN MMU ADDRESS.			      &
		!			DETERMINE WHICH SEGMENT IT'S IN AND   &
		!			ANNOTATE THE BUFFER.		      &
		!		GET THE LINK POINTER.			      &
		! TRY AGAIN.						      &

17430	E1%=M1% IF E%							      &
	\ FNEND								      &
		!							      &
		! SET THE FLAG WHICH TRIGGERS THE WARNING MESSAGE OF	      &
		! POSSIBLE INVALID ANNOTATIONS IF WE'VE ENCOUNTERED	      &
		! ANY ERRORS.						      &

17500	DEF* FNDEV.QUE%(DEV.NAME$,PNTR%,TYPE%)				      &
	!								      &
	!								      &
	! FNDEV.QUE% FUNCTION IS DESIGNED TO EXAMINE THE VARIOUS	      &
	! QUEUE LISTS POINTERS FOUND IN THE DEVICE'S DDB OR CDB		      &
	! AND IF NON ZERO INITIATE THE ANNOTATING OF THE CCBS.		      &
	!								      &
	!	INPUTS - DEVICE NAME IN DDCU FORMAT			      &
	!		 POINTER TO THE DEVICE'S DDB			      &
	!		 TYPE CODE					      &
	!								      &
	!	OUTPUT - NONE						      &
	!								      &
	!								      &

17510	FOR J%=1% TO OFFSET%(0%,TYPE%)					      &
	\	CCB.PNTR%=FNP%(220%,PNTR%+OFFSET%(J%,TYPE%))		      &
	\	TMP%=FNCCB%(CCB.PNTR%,DEV.NAME$,QUE.NAME$(J%,TYPE%))	      &
							IF CCB.PNTR%	      &
	\ NEXT J%							      &
	\ FNEND								      &
		!							      &
		! FOR EACH QUEUE IN THE LIST				      &
		!	IF THE CCB POINTER IS NOT 0 THEN		      &
		!		ANNOTATE THE CCB LIST			      &
		! ONWARD TO THE NEXT QUEUE.				      &
		!							      &
									      &

19000	!								      &
									      &
									      &
	!	E R R O R    H A N D L I N G				      &
									      &
									      &
	RESUME 19010							      &

19010	E$=" (at Line "+NUM1$(ERL)+")"					      &
	\ E$=E$+" - "+S$						      &
		IF ERL=1400% OR ERL=1420%				      &
	\ PRINT "?ANALY2 - ";FNE$(ERR);E$				      &
	\ GOTO 32765							      &
	! ONLY EXPECTED, SPECIALLY FLAGGED ERROR IS OPEN ERROR.		      &
	! FLAG ALL OTHERS WITH LINE # TO AID IN TRACK-DOWN OF REASON.	      &

31000	!								      &
									      &
									      &
	!	C H A I N    E N T R Y					      &
									      &
									      &

31010	ON ERROR GOTO 19000						      &
	\ E0%=2%							      &
	\ S$=SYS(CHR$(7%))						      &
	\ DIAGNOSE%=CVT$%(S$)						      &
	\ WORK1.FILE$=RIGHT(S$,3%)					      &
	\ GOTO 1000							      &
	! CHAIN ENTRY FROM ANALYS					      &
	! SET UP ENTRY TYPE, EXTRACT ALL REQUIRED INFO FROM CORE COMMON	      &
	! AND GOTO WORK.						      &

32760	S$=SYS(CHR$(9%))						      &
		! REMOVE OURSELVES FROM MEMORY				      &

32765	CLOSE 1%,12%							      &
		! CLOSE any open files					      &

32767	END								      &

