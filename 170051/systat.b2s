2!		PROGRAM		: SYSTAT.B2S
5!		VERSION		: V10.1
6!		EDIT		: I
7!		EDIT DATE	: 31-JAN-92
10	OPTION SIZE = REAL DOUBLE
11	!								      &
									      &
									      &
	!		  C O P Y R I G H T				      &
									      &
									      &
  !		      Copyright (C) 1974, 1992 by			      &
  !	        Digital Equipment Corporation, Maynard, Mass.		      &
  !									      &
  !									      &
  !	This software is furnished under a license and may be used and	      &
  !	copied  only  in accordance with the terms of such license and	      &
  !	with the  inclusion  of  the  above  copyright  notice.   This	      &
  !	software  or  any  other copies thereof may not be provided or	      &
  !	otherwise made available to any other person.  No title to and	      &
  !	ownership of the software is hereby transferred.		      &
  !									      &
  !	The information in this software is subject to change  without	      &
  !	notice  and should not be construed as a commitment by Digital	      &
  !	Equipment Corporation.						      &
  !									      &
  !	DIGITAL assumes no responsibility for the use  or  reliability	      &
  !	of its software on equipment that is not supplied by DIGITAL.	      &
  !									      &
  !*******************************************************************	      &
									      &

20	!								      &
									      &
									      &
	!	M O D I F I C A T I O N    H I S T O R Y		      &
									      &
									      &

21	! VER/ED	EDIT DATE	REASON				      &
									      &
		! Version 9.0 SYSTAT					      &
	!								      &
	! 01	KCG	08-Mar-84	Updated TB3 comments and routine.     &
	!				Added display for NULRTS in SY/R.     &
	! 02 	KMF	14-Mar-84	Memory Control Block Changes	      &
	!				Display Dynamic Regions		      &
	! 03	KMF	23-Apr-84	Change logical disk name structure    &
	!				OLD :	Logical	    NEW :  Logical    &
	!					Logical		   Logical    &
	!					Phys.name	   Logical    &
	!					Unit,flg	   Phys.name  &
	!					PPN		   Unit,flg   &
	! 04	KCG	03-Jul-84	Complete disk log table work.	      &
	! 05	BGN	28-Aug-84	Fix sy/c to show virtual disk	      &
	!				and the problem with xbuff, nxm,      &
	!				locked out mem >127Kw		      &
	! 06	KPH	08-Feb-85	Add hooks for NULRTS KBM	      &
	! 07	DLS	17-JUN-85	Added "LDX" to comments for sy/d      &
	! 08	DLS	02-JUL-85	Use UU.SYS instead of Peeking through &
	!				the JDB's			      &
	! 09	FEK	18-Jun-86	Add LOCK info to /W: option and	      &
	!				open files by job		      &
	! 10	DLS	07-Nov-86	Added DLA to comments for sy/d and    &
	!				removed ??? from comments for sy/m    &
	! 11	REG	12-Jan-87	NFS disks should not show DLA/DLW     &
	! 12	JJT	19-Feb-87	Allow for disk unit #'s > than 9      &
	! 13    DRW	08-May-87	Allow for "UP" time to display up to  &
	!                               9999 hours.			      &
	! 14	DRW	03-Sep-87	Trap for error at line 10020 for non- &
	!				existant job.			      &
	! 15	DRW	10-Sep-87	Trap for invalid PPN numbers with the &
	!				the /W qualifer after device check    &
	! 16	REG	26-Jan-88	Fix SY/B and PK printouts.	      &
	! 10.1-A	19-Feb-88	(JJT) Add a space after KB number     &
	! 10.1-A	01-Jun-88	(FEK) Add KB##<exclamation-point>*    &
	!				      and DD HH:MM:SS		      &
	! 10.1-A	23-Sep-88	(JJT) Make SYSTAT a BP2 program and   &
	!				      force it to be double precision &
	!								      &
	! 10.1-A	22-FEB-89	(REG) Add priv checks for /O, /W      &
	! 10.1-A	05-Feb-90	(REG) Fix DV0:/Locked-out bug	      &
	! 10.1-D	26-Jul-91	(JJT) Allow clearing of system and    &
	!				      disk error counters	      &
	! 10.1-D	30-Jul-91	(JJT) Allow a disk to be specified    &
	! 10.1-H	05-Dec-91	(JJT) Fix uptime overflow format      &
	!								      &
									      &

100	!								      &
									      &
									      &
	!	G E N E R A L    D E S C R I P T I O N			      &
									      &
									      &

110	!	SYSTAT provides RSTS users with current system		      &
	!	information in the areas of job, device, disk, buffer,	      &
	!	Run-Time System, Resident Libraries, open files, and	      &
	!	Message Receivers. SYSTAT may be run by users logged	      &
	!	into the system (RUN or CCL entry) or by users not	      &
	!	logged into the system).				      &
	!	Logged out users always receive output at the terminal	      &
	!	from which the request was made;			      &
	!	Logged in users may direct output to other devices,	      &
	!	including a filename etc. if so desired.		      &
	!	Valid SYSTAT options are as follows:			      &
	!								      &
	!	Switch		Purpose					      &
	!	/S		Job Status				      &
	!	/U		List only detached jobs			      &
	!	/A		List only attached jobs			      &
	!	/B		Busy Device Status			      &
	!	/D[:ddn][:Z]	Disk Structure [on disk ddn, if specified]    &
	!			   (Z option will reset all error counts on   &
	!			    all disks or on specified disk)	      &
	!			   (Requires HWCTL priv)		      &
	!	/F[:Z]		Free statistics				      &
	!			   (Z option will reset system error counts)  &
	!			   (Requires HWCTL priv)		      &
	!	/R		Run-Time System Status			      &
	!	/M		Message Receiver Status			      &
	!	/L		Resident Libraries			      &
	!	/O[:DDN:J]	List open files				      &
	!			  (not default; requires OPER, SYSMGR)	      &
	!	/W[:DDN:J]	List who has the files open also	      &
	!			  (not default; requires OPER, SYSMGR)	      &
	!	/C		Memory allocation table			      &
	!	null		S,B,D,F,R,M and L			      &
	!								      &
	!	Any combination of these switches is			      &
	!	permissible (only 1 slash is necessary)			      &
	!								      &
	!	The remaining options must be used alone:		      &
	!	/n		Status of Job # n			      &
	!	/Kn		Status of terminal # n			      &
	!	/0,0		Status of jobs not logged in		      &
	!	/n,m		Status of account (n,m)			      &
	!	/n,*		Status of all jobs with project	# n	      &
	!								      &

301!	CHANNEL #		USED FOR				      &
   !	  1			OUTPUT IF FILESPEC GIVEN		      &

400	!								      &
									      &
									      &
	!	V A R I A B L E    D E F I N I T I O N S		      &
									      &
									      &

401!	VARIABLE NAME	USED FOR					      &
   !
410!	C$		CARRIAGE RETURN, LINE FEED			      &
   !	C%		UTILITY VARIABLE (CHANNEL #,			      &
   !				LOOP CONTROLLER ETC.)			      &
   !	C0%		COUNTER AND ERLCTL VARIABLE			      &
   !	D.DISK$		Disk to display					      &
   !	D.UNIT%		Disk's unit number				      &
   !	E$		ERROR MESSAGE HOLDER				      &
   !	E%		ERROR CODE HOLDER				      &
   !	E0%		ENTRY TYPE					      &
   !	E9%		'MULTIPLE ERRORS' FLAG.				      &
   !	F$		FILENAME					      &
   !	H2%		HANDLER INDEX					      &
   !	HDR.PRINTED%	The header-printed flag				      &
   !	I$		VERSION/EDIT HOLDER				      &
   !	I%		UTILITY VARIABLE				      &
   !	J%		UTILITY VARIABLE				      &
   !	J0%		UTILITY VARIABLE				      &
   !	J1%		UTILITY VARIABLE				      &
   !	J2%		UTILITY VARIABLE				      &
   !	J3%		UTILITY VARIABLE				      &
   !	J4%		UTILITY VARIABLE				      &
   !	J7%		Job number for open files			      &
   !	J8%		UTILITY VARIABLE				      &
   !	O%		OUTPUT CHANNEL #				      &
   !	O7%		USER SPECIFIED JOB #, KB # OR ACCT FLAG		      &
   !	O8%		USER SPECIFIED OPTIONS FLAG			      &
   !	O.DEV$		DISK DEVICE SPECIFIED ON /O OR /W		      &
   !	PRIV.SYSIO%	user has SYSIO privilege			      &
   !	PRIV.TUNE%	user has TUNE privilege				      &
   !	PRIV.WREAD%	user has WREAD privilege			      &
   !	P2%		DEVTBL POINTER FOR PK'S				      &
   !	P3%		KB# OF THE KB FOR PK0				      &
   !	P4%		JOB # CONTROLLING A PK				      &
   !	PROJ%		PROJECT # OF JOB BEING CHECKED (JOB STATUS)	      &
   !	PROG%		PROG # OF JOB BEING CHECKED (JOB STATUS)	      &
   !	RESET.DISK.ERRORS% Reset disk error counts flag			      &
   !	RESET.ERRORS% 	Reset system error counts flag			      &
   !	S$		STRING TO BE PRINTED				      &
   !	S%		UTILITY VARIABLE				      &
   !	S0$		UTILITY STRING (DEVICE NAMES)			      &
   !	T		TIME VARIABLE					      &
   !	T$		UTILITY VARIABLE (FILENAME, TIME STRING)	      &
   !	T%		TIME AND UTILITY VARIABLE			      &
   !	T0		TIME HOLDER					      &
   !	T1%		TIME AND UTILITY VARIABLE			      &
   !	T2%		UTILITY VARIABLE				      &
   !	U%		UNIT #						      &
   !	W%		ROUTINE TO GOTO FLAG				      &
									      &

800	!								      &
									      &
									      &
	!	F U N C T I O N / S U B R O U T I N E    D E S C .	      &
									      &
									      &

801!	FUNCTION/SUBROUTINE		USE				      &
   !	FNF$			PRODUCE A UNIQUE FILENAME		      &
   !	FNN$			CONVERT A # TO A STRING AND LEFT PAD	      &
   !				IT WITH SPACES.				      &
   !	FNS%			SEARCH FOR AND EXTRACT A PARTICULAR	      &
   !				CHARACTER IN A STRING			      &
   !	FNS$			LEFT PAD A STRING WITH SPACES		      &
   !	FNT1%			EXTRACT MONITOR TABLE INFORMATION	      &
   !	FNT3%			GETS POINTERS INTO UCCTBL AND DDCTBL	      &
   !	FNDDCU$			CREATES DDCU STYLE DEVICE NAMES.	      &
									      &
									      &

900	!								      &
									      &
									      &
	!	D I M E N S I O N    S T A T E M E N T S		      &
									      &
									      &

910	DIM D9$(11%),M%(30%),M2%(30),M3%(30%),LOC%(40),SIZE%(40),	      &
		SIZE2%(40),NAM%(40),UU.SYS0%(30%),UU.SYS1%(30%),UU.SYS2%(30%) &
	! MONTH ARRAY							      &
	!								      &
	! MONITOR TABLES - PART I					      &
	! M%(3)		CNT.KB-1					      &
	! M%(4)		MAXCNT						      &
	! M%(5)		DEVCNT						      &
	! M%(7)		DEVPTR						      &
	! M%(9)		MEMLST						      &
	! M%(11)	JOBTBL						      &
	! M%(13)	JBSTAT						      &
	! M%(15)	JBWAIT						      &
	! M%(17)	UNTCLU						      &
	! M%(19)	UNTCNT						      &
	! M%(21)	SATCTL						      &
	! M%(23)	JSBTBL						      &
	! M%(25)	SATCTM						      &
	! M%(29%)	UNTOWN						      &
	!								      &
	! MONITOR TABLES - PART II					      &
	! M2%(3)	FREES						      &
	! M2%(5)	DEVNAM						      &
	! M2%(7)	CSRTBL						      &
	! M2%(9)	DEVOKB						      &
	! M2%(11)	TTYHCT						      &
	! M2%(13)	JOBCNT						      &
	! M2%(15)	RTSLST						      &
	! M2%(17)	ERLCTL						      &
	! M2%(19)	SNDLST						      &
	! M2%(21)	DSKLOG						      &
	! M2%(23)	DEVSYN						      &
	! M2%(25)	MEMSIZ						      &
	! M2%(29%)	FCBLST						      &
	!								      &
	! MONITOR TABLES - PART III					      &
	! M3%(1%)	JOB NUMBER*2					      &
	! M3%(3%)	DDCTBL						      &
	! M3%(5%)	UCTTBL						      &
	! M3%(7%)	SATEND						      &
	! M3%(9%)	UNTLVL						      &
	! M3%(11%)	MFDPTR						      &
	! M3%(13%)	MAGLBL						      &
	! M3%(15%)	# of jobs in the job table ( low byte )		      &
	! M3%(16%)	SO.1MX ( # of 'one instance' LOTs )		      &
	! M3%(17%)	LOTTBL						      &
	! M3%(19%)	EMLCTL						      &
	! M3%(21%)	Hardware configuration word			      &
	! M3%(23%)	UNTERR						      &
	! M3%(25%)	DEVCLU						      &
	! M3%(27%)	NULRTS						      &
	!								      &
	! LOC% - LOCATION OF MEMORY MODULES (/C ROUTINE).		      &
	! SIZE% - SIZE AND FLAGS FOR MEMORY MODULES (/C ROUTINE).	      &
	! SIZE2% - EXTENSION OF SIZE% (/C ROUTINE).			      &
	! NAM% - POINTER TO RTS AND LIB NAMES (/C ROUTINE).		      &
	!								      &
									      &

999	!								      &
									      &
									      &
	!	M A I N    C O D I N G    A R E A			      &
									      &
									      &

1000	ON ERROR GOTO 19000						      &
	\ PRINT IF CCPOS(0%)<>0%					      &
	! SET UP STANDARD ERROR TRAP					      &
	! RETURN KB TO LEFT MARGIN					      &

1010	I$="V10.1-I"							      &
	! SET UP V/E							      &

1020	PRINT "SYSTAT";CHR$(9%);I$;CHR$(9%);				      &
	 CVT$$(RIGHT(SYS(CHR$(6%)+CHR$(9%)+CHR$(0%)),3%),4%)		      &
	! PRINT THE SYSTEM HEADER					      &

1040	E0%=0%								      &
	\ PRINT "Output Status to? ";					      &
	\ OPEN "_KB:SYSTAT.CMD" AS FILE 1%				      &
	\ INPUT LINE #1%,S$						      &
	\ S$=CVT$$(S$,252%)						      &
	! GET THE OUTPUT FILE SPEC (AND SWITCHES)			      &
	! DISCARD EXCESS CHARACTERS,					      &
	! REDUCE SPACES/TABS TO 1 SPACE,				      &
	! CONVERT TO UPPERCASE, CONVERT [ AND ] TO ( AND ),		      &
	! AND DISCARD TRAILING SPACES AND TABS.				      &

1060	E9%=0%								      &
	\ UU$=CHR$(6%)+CHR$(26%)					      &
	\ I%=INSTR(1%,S$,"/O:")						      &
	\ I%=INSTR(1%,S$,"/W:") UNLESS I%				      &
	\ IF I% THEN							      &
		GOTO 1160 IF INSTR(1%,S$,"::")				      &
	\	GOTO 1160 IF INSTR(1%,S$,"<")				      &
	\	J%=INSTR(I%+4%,S$+"/","/")				      &
	\	O.DEV$=CVT$$(MID(S$,I%+3%,J%-I%-3%),252%)		      &
	\	S$=LEFT(S$,I%+1%)+RIGHT(S$,J%)				      &
	\	I%=INSTR(1%,O.DEV$,":")					      &
	\	T$=""	! Start requesting all jobs			      &
	\	T$=RIGHT(O.DEV$,I%+1%) IF I%				      &
	\	J%=0%							      &
	\	J%=J%+1% IF INSTR(1%,"0123456789",MID(O.DEV$,J8%,1%))	      &
			FOR J8%=1% TO LEN(O.DEV$) IF I%=0%		      &
	\	GOTO 1063 IF (J%=LEN(O.DEV$) AND J%<3%)			      &
	\	O.DEV$=LEFT(O.DEV$,I%-1%) IF I%				      &
	\	CHANGE SYS(CHR$(6%)+CHR$(-10%)+O.DEV$+":") TO M%	      &
	\	GOTO 1160 IF (M%(29%)+SWAP%(M%(30%)))<0%		      &
	\	GOTO 1160 UNLESS (STATUS AND 255%)=0%			      &
	\	GOTO 1160 IF ((M%(29%)+SWAP%(M%(30%))) AND 128%)<>0%	      &
	\	O.DEV$=CHR$(M%(23%))+CHR$(M%(24%))			      &
	\	O.DEV$=O.DEV$+NUM1$(M%(25%)) IF M%(26%)			      &
	\	GOTO 1065						      &
	! CLEAR THE 'MULTIPLE ERRORS' FLAG.				      &
	! CHECK FOR /O:Dxu:j OR /W:Dxu:j - EXTRACT AND CHECK		      &
	! (OK TO INCLUDE A COLON, ANYTHING AFTER IT IS IN "T$")		      &
	! ALSO TRAP FOR PPN WITH /W: AND REJECT				      &

1063	T$=O.DEV$							      &
	\ O.DEV$=""							      &

1065	J7%=0%	! To request all jobs					      &
	\ J7%=VAL(T$) ! Find out which specific job			      &

1070	I% = FNT1%				!Get the monitor table info   &
\	RESET.ERRORS% = 0%			!Init the reset-errors flag   &
\	I%=INSTR(1%,S$,"/F:Z")			!Search for reset errors      &
\	IF I% THEN				!If it's there		      &
		IF NOT(PRIV.HWCTL%) THEN	!    If no HWCTL privilege    &
			E% = 512% + 10%		!     Set the error flag      &
\			GOTO 19020		!     Goto error handler      &
\		END IF							      &
\		RESET.ERRORS% = -1%		! Set the flag		      &
\		S$ = LEFT(S$,I%+1%)+RIGHT(S$,I%+4%) !Change it back to /F     &

1075	RESET.DISK.ERRORS% = 0%			!Init the reset-disk-errors flag &
\	D.DISK$ = ""				!Init the disk to display     &
\	D.UNIT% = 0%				!Init the disk's unit #	      &
\	I%=INSTR(1%,S$,"/D:")			!Search for an argument	      &
\	IF I% THEN				!If it's there		      &
\		J%=INSTR(I%+3%,S$+"/","/")	! Find the next switch	      &
\		D.DISK$=CVT$$(MID(S$,I%+2%,J%-I%-2%),252%) !Extract the disk  &
							   ! w/leading colon  &
\		S$=LEFT(S$,I%+1%)+RIGHT(S$,J%)	! Put it back to /D	      &
\		GOTO 1160 UNLESS LEN(D.DISK$) > 1%! Error if just "/D:"	      &
\		I%=INSTR(1%,D.DISK$,":Z")	! Search for reset disk	      &
\		IF I% THEN			! If it's there		      &
			IF LEN(D.DISK$) - I% > 1% THEN ! :Zsomething?	      &
				IF ASCII(RIGHT(D.DISK$,I%+2%))= 58% !:Z:      &
					THEN RESET.DISK.ERRORS% = -1%	      &
						!Set the flag		      &
				ELSE		! Non ":" char after :Z	      &
					I%=INSTR(I%+1%,D.DISK$,":Z")	      &
						! The 1st :Z must be beginning &
						! of a logical, find next :Z  &
\					IF I% THEN !A 2nd :Z		      &
						RESET.DISK.ERRORS% = -1%      &
						!Set the flag		      &
\					END IF				      &
\				END IF					      &
			ELSE		! Nothing after :Z		      &
				RESET.DISK.ERRORS% = -1% !Set the flag	      &
\			END IF						      &
\		END IF							      &
\		IF RESET.DISK.ERRORS% THEN	! If we are resetting disk(s) &
			IF NOT(PRIV.HWCTL%) THEN!    If no HWCTL privilege    &
				E% = 512% + 10%	!      Set the error flag     &
\				GOTO 19020	!      Goto error handler     &
			ELSE			!    They do have HWCTL	      &
\				D.DISK$=LEFT(D.DISK$,I%-1%)+		      &
				  RIGHT(D.DISK$,I%+2%) !Remove ":Z"	      &
\			END IF						      &
\		END IF							      &
\		GOTO 1080 UNLESS LEN(D.DISK$)	! Exit if just "/D:Z"	      &
\		D.DISK$ = RIGHT(D.DISK$,2%)	! Strip off leading colon     &
			IF ASCII(D.DISK$) = 58% !  if it's there	      &
\		I%=INSTR(1%,D.DISK$,":")	! Search for trailing colon   &
\		D.DISK$ = D.DISK$ + ":" UNLESS I% !Add it if it's not there   &
\		CHANGE SYS(CHR$(6%)+CHR$(-10%)+D.DISK$) TO M% !FSS the disk   &
\		GOTO 1160 IF (M%(29%)+SWAP%(M%(30%)))<0% !Error if invalid    &
\		GOTO 1160 UNLESS (STATUS AND 255%)=0%	!Error if not disk    &
\		GOTO 1160 IF ((M%(29%)+SWAP%(M%(30%))) AND 128%)<>0% !No PPN's &
\		GOTO 1160 IF M%(26%) = 0%		!Must have a unit #   &
\		D.DISK$=CHR$(M%(23%))+CHR$(M%(24%))	!Get the actual name  &
\		D.UNIT% = M%(25%)			!Get unit #	      &
\		IF D.DISK$ = "SY" THEN			!If the system disk   &
			PRINT "?Must specify actual disk name" !Print err     &
\			GOTO 1300			! and get out	      &
									      &

1080	J%=INSTR(1%,S$+"/","/")						      &
	\ F$=LEFT(S$,J%-1%)						      &
	\ S$=RIGHT(S$,J%+1%)						      &
	\ I%=-1%							      &
	\ I%=FNS%("/") UNTIL I%=0%					      &
	\ O7%=0%							      &
	\ O8%=(NOT 528%)						      &
	\ GOTO 1180 IF LEN(S$)=0%					      &
	\ O8%=0%							      &
	\ O.F$="O"							      &
	\ O.W$="W"							      &
	! SEPARATE THE FILENAME (F$) FROM ANY SWITCHES (S$)		      &
	! REMOVE EXCESS SLASHES.					      &
	! SET FLAGS (O7%,O8%) TO INDICATE DEFAULT VALUES (SBDRFML).	      &
	! (NOT 528%-> 16%+512%, I.E., NOT /O OR /C)			      &
	! KEEP DEFAULT VALUES IF NO SWITCHES SPECIFIED.			      &
	! CLEAR 'SWITCH SPECIFIC' FLAG					      &
	! SET "OPEN FILES SWITCH ALLOWED" STRING, BASED ON USER'S PRIVILEGES  &
	!  AND WHETHER OR NOT LARGE FILES HAVE BEEN CONFIGURED.		      &
	! SET "MEMORY ALLOCATION SWITCH ALLOWED" STRING, BASED ON PRIVILEGES. &
	!								      &
	! THE FOLLOWING TABLE LISTS ALL LEGAL SWITCHES			      &
	! ALONG WITH THE CORRESPONDING FLAG VALUES:			      &
	! SWITCH	O7%	O8%					      &
	! S		0	2					      &
	! B		0	4					      &
	! D		0	8					      &
	! O		0	16					      &
	! F		0	32					      &
	! R		0	64					      &
	! L		0	128					      &
	! M		0	256					      &
	! C		0	512					      &
	! W		0	1024(+16)				      &
	! U		0	2048					      &
	! A		0	4096					      &
	! null		0	SBDRFML (NOT /O OR /C)			      &
	!								      &
	! ANY COMBINATION OF THE 7 BASIC SWITCHES IS ALLOWED.		      &
	!								      &
	! n		1	VAL(n)					      &
	! Kn		2	VAL(n)					      &
	! n,m		4	PPN					      &
	! n,*		4	n,255					      &
	! 0,0		4	0					      &
	!								      &
	! THESE SWITCHES MAY ONLY BE USED ALONE.			      &

1100	O8%=O8% OR (2% ^ INSTR(1%,"SBD"+O.F$+"FRLMC"+O.W$+"UA",		      &
					MID(S$,J%,1%)))			      &
		FOR J%=1% TO LEN(S$)					      &
	\ IF (O8% AND 1%)<>0% THEN					      &
		GOTO 1160 IF O8%<>1%					      &
	ELSE	O8%=O8% OR 2% IF (O8% AND 6144%)<>0%			      &
	\	O8%=O8% OR 16% IF (O8% AND 1024%)<>0%			      &
	\	O8%=O8% OR 6144% UNLESS (O8% AND 6144%)<>0%		      &
	\	GOTO 1180						      &
	! 24576=8192+16384						      &
	! 6144=2048+4096						      &
	! CHECK FOR APPEARANCE OF 5 BASIC SWITCHES:			      &
	! IF ANY OF THESE ARE PRESENT THEN				      &
	!	IF ANY NON-BASIC SWITCHES (OTHER THAN /O OR /W)		      &
	!	 APPEAR THEN ERROR					      &
	!	ELSE	FORCE ON JOB STATUS IF U OR A SPECIFIED		      &
	!		FORCE ON OPEN FILES IF W SPECIFIED		      &
	!		FORCE ON A AND U IF NEITHER WAS SPECIFIED	      &

1120	IF FNS%(",")<>0% THEN						      &
		O8%,J8%=0%						      &
	\	S0$=LEFT(S$,J0%-1%)					      &
	\	O7%=255% AND S0$="*"					      &
	\	O8%=VAL(S0$) IF O7%=0%					      &
	\	S$=RIGHT(S$,J0%)					      &
	\	J8%=255% AND (S$="*")					      &
	\	J0%=VAL(S$) IF J8%=0%					      &
	\	GOTO 1160 IF O8%<0% OR O8%>254% OR J0%<0% OR J0%>254%	      &
	\	J8%=J8% OR SWAP%(O7%)					      &
	\	O8%=SWAP%(O8%)+J0% OR J8%				      &
	\	O7%=4%							      &
	\	GOTO 1180						      &
		! ALLOW WILDCARDS FOR PROJ,PROG NUMBER			      &

1140	O7%=1% IF FNS%("K")						      &
	\ O7%=O7%+1%							      &
	\ O8%=VAL(S$)							      &
	\ IF O8%<2%-O7% OR O8%>M%(5%-O7%) THEN 1160			      &
	ELSE	1180							      &
	! O7%	1=n							      &
	!	2=Kn							      &
	! GET THE JOB # OR TERMINAL #.					      &
	! VERIFY THAT:							      &
	! FOR JOB #	>0 AND <=MAXCNT					      &
	! FOR KB	>=0 AND <=NULINE				      &
	! IF IT'S OUTSIDE OF ALLOWABLE RANGE THEN			      &
	!	IT'S AN ERROR						      &
	! ELSE	CONTINUE						      &

1160	E%=512%+52%							      &
	\ GOTO 19020							      &
	! SOME KIND OF OPTION ERROR - GO AND ISSUE MESSAGE.		      &

1180	GOTO 1160 IF J7%<1% OR J7%>M%(4%) IF J7%			      &
	\ O%=0%								      &
	\ IF LEN(F$)=0% THEN						      &
		GOTO 1220						      &
	ELSE	T$=F$							      &
	\	I%=INSTR(1%,T$,"?")					      &
	\	IF I% THEN						      &
			T$=LEFT(F$,I%-1%)+FNF$+RIGHT(F$,I%+1%)		      &
	\		T$=LEFT(T$,I%+5%)+".RPT"+RIGHT(T$,I%+6%)	      &
				UNLESS INSTR(1%,T$,".")			      &
	\		PRINT "(Output File is ";T$;")"			      &
	! SET THE OUTPUT CHANNEL TO 0.					      &
	! IF NO SPEC WAS GIVEN THEN					      &
	!	SKIP THIS						      &
	! ELSE	SAVE THE SPEC AND SEE IF IT CONTAINED A '?'.		      &
	!	IF IT DID THEN						      &
	!		INSERT A UNIQUE FILENAME WHERE THE ? WAS.	      &
	!		TACK ON AN EXTENSION OF '.RPT' IF		      &
	!		NO EXTENSION WAS GIVEN.				      &

1200	S0$=SYS(CHR$(6%)+CHR$(-21%)+CHR$(-1%))				      &
	\ OPEN T$ AS FILE 1%, MODE 2%					      &
	\ IF (STATUS AND 1024%)<>0% THEN				      &
		PRINT IF CCPOS(0%)<>0%					      &
	\	PRINT "?SYSTAT does not have write access to ";T$	      &
	\	GOTO 32765						      &

1210	O%=1%								      &
	\ S0$=SYS(CHR$(6%)+CHR$(-21%)+CHR$(0%))				      &
	! DROP TEMPORARY PRIVILEGES TO PREVENT NON-PRIVILEGED		      &
	! USERS FROM CROSSING ACCOUNTS.					      &
	! SET THE CHANNEL # TO 1.					      &
	! REGAIN PRIVILEGES.						      &

1220	PRINT #O%,C$;"Further logins are disabled" IF FNT1%		      &
	\ P2%,P3%=0%							      &
	\ FOR I%=(M2%(5%)+M2%(9%)) TO (M2%(23%)-2%) STEP 2%		      &
	\	IF CVT%$(SWAP%(PEEK(I%)))="PK" THEN			      &
			P2%=PEEK(M%(7%)+I%-M2%(5%))			      &
	\		P3%=PEEK(PEEK(P2%)+8%)/2%			      &
	\		GOTO 1260
1240	NEXT I%								      &
	! RE-EXAMINE TABLES TO SEE IF LOGINS HAVE BEEN DISABLED.	      &
	! SCAN THE DEVNAM TABLE TO SEE IF PK'S ARE LEGAL		      &
	! DEVICES.							      &
	! IF SO,							      &
	!	P2% = DEVTBL POINTER FOR PK'S				      &
	!	P3% = THE KB # OF THE KB FOR PK0			      &

1260	IF O7%<>0% THEN							      &
		J%=0%							      &
	\	PRINT #O%						      &
	\	GOSUB 10020						      &
	\	GOTO 1300						      &
	! IF WE JUST WANT SOME PORTION OF JOB STATUS THEN		      &
	!	SET UP JOB #						      &
	!	GO TO THE ROUTINE AND					      &
	!	GET OUT							      &

1280	ON W% GOSUB 10000,10350,10500,10600,10450,10250,10800,10700,13700     &
		IF (O8% AND 2%^W%)<>0% FOR W%=1% TO 9%			      &
	! CHECK FLAG BITS AND GO TO THE PROPER ROUTINE(S).		      &
	! JOB STATUS, BUSY DEVICES, DISKS, OPEN FILES, FREE STATS,	      &
	! RUN-TIME SYSTEMS, RESIDENT LIBRARIES, MESSAGE RECEIVERS,	      &
	! MEMORY ALLOCATION.						      &

1300	IF O%<>0% THEN							      &
		PRINT #O%						      &
	\	CLOSE O%						      &
	! CLOSE THE FILE IF NON-KB					      &

1320	GOTO 32765							      &
	! EXIT								      &
									      &

10000	!								      &
									      &
									      &
	!	S U B R O U T I N E S					      &
									      &
									      &
	!	J O B    S T A T U S					      &
	!								      &
	!								      &
	!	J O B    D A T A    B L O C K    ( J D B )		      &
	!								      &
	!	  CONTENTS		OFFSET				      &
	!	   JDIOB		  0	PTR TO IOB		      &
	!	   JDFLG		  2	STATUS FLAGS		      &
	!	JDPOST - JDIOST		  4	PATTERN TO POST - ERR CODE    &
	!	   JDWORK		  6	PTR TO WRK		      &
	!	   JDJB2		  8	PTR TO JDB2		      &
	!	JDSIZN - JDFLG2		 10	NEXT RES SIZE - FLAGS	      &
	!	   JDRTS		 12	PTR TO RTS		      &
	!	   JDRESQ		 14	RESIDENCY QUANTUM	      &
	!  	   JDMCTL		 16	MEMORY CONTROL AREA	      &
	!	     "" 		 18		""		      &
	!	     "" 		 20		""		      &
	!	  ""   - JDSIZE		 22		""		      &
	!	     "" 		 24		""		      &
	!	   JDRESB		 26	L3 QUEUE BITS		      &
	!	JDBRST - JDPRI		 28	RUNBURST - PRIORITY	      &
	!	JDSWAP - JDSIZM		 30	SWAP PARAM - PRIV MEM MAX     &
	!								      &
	!	JDFLG BITS:						      &
	!	BIT	MEANING						      &
	!	 0	JFPOST						      &
	!	 1	JFIOST						      &
	!	 2	JFKEY						      &
	!	 3	JFCC (CTRL/C)					      &
	!	 4	JF2CC (2 CTRL/C'S)				      &
	!	 5	JFPPT						      &
	!	 6	JFGO						      &
	!	 7	JFREDO						      &
	!	 8	JFSYST - TEMP PRIVILEGES POSSIBLE		      &
	!	 9	JFFPP						      &
	!	10	JFPRIV - PERMANENT PRIVILEGES			      &
	!	11	JFSYS - TEMP PRIVILEGES ACTIVE			      &
	!	12	JFOPR - NOT YET LOGGED IN			      &
	!	13	JFBIG - CAN EXCEED PRIVATE MEM MAX		      &
	!	14	JFLOCK - NOT TO BE SWAPPED			      &
	!	15	JFSPCL						      &
	!								      &
	!								      &
	!	J O B    D A T A    B L O C K    2    ( J D B 2 )	      &
	!								      &
	!	  CONTENTS		OFFSET				      &
	!	   J2TICK		  0	UNCONVERTED CLOCK TICKS	      &
	!	   J2CPU		  2	CPU LSB			      &
	!	   J2CON		  4	CONNECT TIME		      &
	!	   J2KCT		  6	KILO-CORE-TICKS LSB	      &
	!	   J2DEV		  8	DEVICE TIME		      &
	!	J2CPUM - J2KCTM		 10	CPU MSB - KCT MSB	      &
	!	   J2NAME1		 12	JOB'S PROGRAM NAME	      &
	!	   J2NAME2		 14		""		      &
	!  	   J2DRTS		 16	PTR TO DEFAULT RTS	      &
	!	   J2MPTR 		 18	PTR TO RIB		      &
	!	   J2PPTR		 20	POSTING POINTER		      &
	!	   J2PCNT		 22	POSTING COUNT		      &
	!	   J2PPN		 24	PPN			      &
	!	   J2UFDR		 26	RETRV PTR TO SYS DISK UFD     &
	!	  RESERVED		 28				      &
	!	  RESERVED		 30				      &
	!								      &

10010	PRINT #O%,C$;CVT$$(RIGHT(SYS(CHR$(6%)+CHR$(9%)+CHR$(0%)),3%),4%);     &
	" status at ";DATE$(0%);", ";TIME$(0%);" Up: ";			      &
	\ J%=PEEK(36%)/1000%+2%						      &
	\ J2%=(PEEK(512%)/1000% <> PEEK(36%)/1000%)			      &
	\ J2%=635%+((J%/4%*4%)=J%) IF J2%				      &
	\ T=((PEEK(512%)-PEEK(36%)-J2%)*1440.+				      &
	  PEEK(38%)-PEEK(514%))*60.+60.-(PEEK(516%) AND 255%)		      &
	\ c1%=0% ! do the DDD HH:MM:SS format				      &
	\ GOSUB 14000							      &
	\ PRINT #O%,S$							      &
	\ J%=0%								      &
	\ PRINT #O%,C$;							      &
	"Job";TAB(7%);"Who";TAB(14%);"Where";TAB(24%);"What";TAB(32%);	      &
	 "Size";TAB(40%);"State";TAB(50%);"Run-Time";			      &
	\ IF PRIV.TUNE% THEN						      &
		PRINT #O%,TAB(59%);"Pri/RB";TAB(68%);"RTS"		      &
	  ELSE	PRINT #O%,TAB(61%);"RTS"				      &
	! PRINT THE SYSTEM HEADER INCLUDING THE CURRENT DATE AND	      &
	! TIME (USING MINUTES TILL MIDNIGHT - SECONDS UNTIL NEXT MINUTE)      &
	! AND LENGTH OF TIME THE SYSTEM'S BEEN UP.			      &
	! CHECK FOR CHANGE OF YEAR, ADJUST FOR LEAPYEAR.		      &
	! NOTE: 635 (636 IF START DATE WAS A LEAPYEAR) IS NOT A TYPO:	      &
	! E.G., 31-DEC-78 -> 01-JAN-79					      &
	!     DATE$(8365) -> DATE$(9001) --> 9001-8365=635+1		      &
	! PEEK(n)	CONTENTS					      &
	! 36		IDATE = DATE SYSTEM LAST STARTED		      &
	! 38		ITIME = TIME SYSTEM LAST STARTED		      &
	! 512		DATE = CURRENT DATE				      &
	! 514		TIME = CURRENT TIME				      &
	! 516 (BYTE)	TIMSEC = SECONDS TO NEXT MINUTE			      &
	! CLEAR THE JOB # VARIABLE.					      &
	! PRINT THE JOB STATUS HEADING					      &
	! INCLUDE PRIORITY/RUNBURST IF USER HAS SYSIO PRIVILEGE		      &

10020	J%=J%+1%							      &
	\ UU.SYS$=UU$+CHR$(J%)						      &
	\ CHANGE SYS(UU.SYS$+CHR$(0%)) TO UU.SYS0%			      &
	\ UU.SYS0%(4%) = NOT(UU.SYS0%(4%)) AND 255% IF (UU.SYS0%(4%) AND 128%) &
	\ CHANGE SYS(UU.SYS$+CHR$(1%)) TO UU.SYS1%			      &
	\ JDB%=UU.SYS1%(25%)+SWAP%(UU.SYS1%(26%))			      &
	\ JDFLG%=UU.SYS1%(5%)+SWAP%(UU.SYS1%(6%))			      &
	\ JDPPN%=UU.SYS0%(21%)+SWAP%(UU.SYS0%(22%))			      &
	\ PROJ%=UU.SYS0%(22%)						      &
	\ PROG%=UU.SYS0%(21%)						      &
	\ DIAL.UP$=""							      &
	\ DIAL.UP$="*" IF ASCII(MID(SYS(UU.SYS$+CHR$(2%)),15%,1%)) = 1%	      &
	\ IF (UU.SYS1%(4%) AND 128%)					      &
	    THEN							      &
		J2%=-1%							      &
	    ELSE							      &
		J2%=UU.SYS0%(4%)					      &
	\	dial.up$="!"+dial.up$ if (peek(peek(peek(jdb%)))	      &
			and 16384%)<>0% and uu.sys0%(5%)=0%		      &
	! INCREMENT THE JOB # AND RETURN JOB STATUS (0,1, AND 2) FOR THE JOB  &
	! UU.SYS0%(4%) IS THE KEYBOARD NUMBER IF THE JOB IS DETACHED	      &
	! JDB%		POINTS TO THE JDB				      &
	! ASSEMBLE THE FLAG WORD					      &
	! ASSEMBLE THE PPN WORD						      &
	! SET DIALUP FLAG TO NULL					      &
	! SET DIALUP FLAG IF IT'S A DIALUP LINE				      &
	! IF WE'RE NOT WORKING WITH THE JOB'S CONSOLE TERMINAL		      &
	!    THEN SIGNAL THE JOB IS DETACHED				      &
	!    ELSE SAVE THE KEYBOARD NUMBER				      &
	!	add the LAT flag if dynamic, and not owned (not PK)	      &
									      &

10030	IF O7%<>0% THEN							      &
		GOTO 10020 IF	(O7%=1% AND J%<>O8%)			      &
			OR	(O7%=2% AND J2%<>O8%)			      &
			OR	(O7%=4% AND O8%<>(JDPPN% OR J8%))	      &
	\	GOTO 10045						      &
	! IF ANY OF THE 'NON-BASIC' SWITCHES WERE PRESENT THEN		      &
	!	IF n	(O7%=1%)	GET OUT IF WRONG JOB #		      &
	!	IF Kn	(O7%=2%)	GET OUT IF WRONG KEYBOARD	      &
	!	IF P,PN	(O7%=4%)	GET OUT IF WRONG ACC/PROG#	      &
	!	IF 0,0	(O7%=4%)	GET OUT IF LOGGED IN		      &
									      &

10040	GOTO 10020 IF	J2%=-1% AND (O8% AND 6144%)=4096% OR		      &
			J2%<>-1% AND (O8% AND 6144%)=2048%		      &
	! GET OUT IF:							      &
	! THIS JOB IS DETACHED AND WANT ONLY ATTACHED.			      &
	! THIS JOB IS ATTACHED AND WANT ONLY DETACHED.			      &
									      &

10045	! RESERVED FOR FUTURE USE					      &

10050	PRINT #O%,FNN$(2%,J%);						      &
	! PRINT THE JOB #.						      &
	\ S0$="  "							      &
	\ IF JDPPN%=0% THEN						      &
		S$="**,**" ! if not logged in, then print *'s		      &
	ELSE								      &
		S0$=" "	! get the spacing right				      &
	\	S0$="-" IF JDFLG% AND 256% IF PRIV.SYSIO%		      &
	\	S0$="+" IF JDFLG% AND 2048% IF PRIV.SYSIO%		      &
	\	S0$=S0$+" " ! correct the spacing			      &

10052	S$=NUM1$(PROJ%)+","+NUM1$(PROG%) IF JDPPN% ! otherwise make the PPN   &
	! IF LOGGED IN THEN						      &
	!	SET UP REAL ACCOUNT name				      &
	!	IF USER HAS SYSIO PRIV THEN				      &
	!		-	TEMPORARY PRIVILEGES POSSIBLE		      &
	!		+	TEMPORARY PRIVILEGES ACTIVE		      &

10055	! RESERVED FOR FUTURE USE					      &

10060	C%=INSTR(1%,S$,",")						      &
	\ C%=3% IF C%=0%						      &
	\ PRINT #O%,TAB(3%);S0$;TAB(9%-C%);S$;				      &

10065	S$="KB"								      &
		! In anticipation that this will be true		      &
	\ IF UU.SYS0%(5%)<>0% AND J2%<>-1% THEN				      &
			! If there's a controlling job and KB# is not -1 THEN &
		S$="KB"+NUM1$(J2%)+"J"					      &
			! Build the 1st 3 parts of the string "KBnnJmm"	      &
			! The "mm" part comes later.			      &
	\	J2%=(UU.SYS0%(5%)-1%)/2%				      &
			! PK's controlling job goes in J2% so that it gets    &
			! printed out instead of KB# in the next line.	      &
									      &

10070	S$=S$+NUM1$(J2%)						      &
	\ S$=S$+DIAL.UP$						      &
	\ S$="Det" IF J2% = -1%						      &
	\ PRINT #O%,TAB(14%);S$;TAB(23%);RAD$(UU.SYS0%(17%)+		      &
	    SWAP%(UU.SYS0%(18%)));RAD$(UU.SYS0%(19%)+SWAP%(UU.SYS0%(20%)));   &
	    TAB(30%);FNN$(4%+PRIV.TUNE%,UU.SYS1%(13%));			      &
	\ PRINT #O%,"/";FNN$(2%,UU.SYS1%(19%)); IF PRIV.TUNE%		      &
	\ PRINT #O%,"K";TAB(40%);					      &
	\ T%=UU.SYS1%(11%)+SWAP%(UU.SYS1%(12%))				      &
	\ S$="RN"							      &
	\ GOTO 10110 IF (T% AND (UU.SYS1%(9%)+SWAP%(UU.SYS1%(10%))))<>0%      &
	\ S$="RS"							      &
	\ GOTO 10110 IF (UU.SYS1%(15%)+SWAP%(UU.SYS1%(16%)))=0% AND	      &
		UU.SYS1%(14%)=196%					      &
	\ T%=T% AND (NOT 16384%) IF (T% AND (NOT 16384%))<>0%		      &
	\ S$="BF"							      &
	\ GOTO 10110 IF (T% AND 16384%)<>0%				      &
	\ S$="SL"							      &
	\ GOTO 10080 IF (T% AND 8192%)=0%				      &
	\ S$="SR" IF (UU.SYS1%(7%) AND 255%)=5%				      &
	\ GOTO 10110							      &
	! PRINT KB INFO - with DIAL-UP FLAG (MODEM) EITHER NULL OR "*"	      &
	!			or "<exclamation-point>" for LAT	      &
	!			or "<exclamation-point>*" for lat dialup      &
	! PRINT THE JOB NAME (J2NAME) AND THE CURRENT SIZE,		      &
	! IN K (M.SIZE).						      &
	! PRINT THE JOB'S MAXIMUM SIZE, IN K (JDSIZM) IF THE		      &
	! USER'S PRIVILEGED.						      &
	! T%=JBWAIT							      &
	! IN GENERAL, SET S$('STATE')=STRING WHICH WILL BE PRINTED	      &
	! IF THE TEST WHICH FOLLOWS IMMEDIATELY IS SATISFIED.		      &
	! POSSIBLE STATES		CONDITIONS			      &
	!	RN			(JBWAIT AND JBSTAT)<>0 AND	      &
	!				'ACTUAL' STATE IS NOT DESIRED.	      &
	!	RS (RESIDENCY WAIT)	IF M.PHYA=0% AND		      &
	!				M.CTRL=LCK,SWP AND IN		      &
	! (TURN OFF BUFFER WAIT BIT IF ANY OTHERS ARE ON. CHECK FOR THE	      &
	! FOLLOWING STATES BY LOOKING AT JBWAIT.)			      &
	!	BF (BUFFER WAIT)	IF BIT 14 IS ON			      &
	!	SL (SLEEP WAIT)		IF BIT 13 IS ON.		      &
	!	SR (RECEIVER WAIT)	IF BIT 13 IS ON AND ERROR CODE	      &
	!				IS 5				      &

10080	S$="FP"								      &
	\ GOTO 10110 IF (T% AND 4096%)<>0%				      &
	\ S$="TT"							      &
	\ GOTO 10110 IF (T% AND 2048%)<>0%				      &
	\ S$="HB"							      &
	\ GOTO 10110 IF T%=0%						      &
	\ DRV.IDX%=2%							      &
	\ GOTO 10100 IF T%=2%						      &
	!	FP			BIT 12 IS ON			      &
	!	TT			BIT 11 IS ON			      &
	!	HB			NO BITS ARE ON			      &
	! IF NONE OF THE PREVIOUS STATES THEN WE HAVE A "DEVICE WAIT".	      &
	! BYPASS THE CHANNEL # CHECK IF WE KNOW WE HAVE A KB INPUT WAIT.      &
									      &

10090	SCB.WCB%=PEEK(PEEK(JDB%)+UU.SYS1%(20%))				      &
	\ DRV.IDX%=0%							      &
	\ DRV.IDX%=PEEK(SCB.WCB%) AND 255% IF SCB.WCB%<>0%		      &
	\ IF DRV.IDX%=0% THEN						      &
		FIP.UNT%=PEEK(PEEK(SCB.WCB%+8%)-4%) AND 255%		      &
	\ 	S$=CVT%$(SWAP%(PEEK(M2%(21%)+(FIP.UNT%*10%)+6%)))	      &
	\	S$="??" IF LEN(CVT$$(S$,-2%))=0% OR SCB.WCB%=0%		      &
	\	GOTO 10110						      &
	! INDEX INTO THE IOB WHICH POINTS TO EITHER A DDB (NON-DISK),	      &
	! OR A WCB (DISK).						      &
	! LOOK AT THE DRIVER INDEX (SAME LOCATION IN BOTH).		      &
	! IF WE HAVE A DISK (DRV.IDX%=0%) THEN				      &
	!	FIND THE FIP UNIT NUMBER IN THE FCB (POINTED TO FROM WCB).    &
	!	EXTRACT THE PROPER NAME FROM DSKLOG			      &
									      &

10100	S$=CVT%$(SWAP%(PEEK(M2%(5%)+M2%(9%)+DRV.IDX%-2%)))		      &
	\ S$="^C" IF (UU.SYS1%(21%)+SWAP%(UU.SYS1%(22%)))<0% IF DRV.IDX%=2%   &
	! WE HAVE A NON-DISK WAIT.					      &
	! INDEX INTO DEVNAM TO GET THE PROPER NAME.			      &
	! CHECK FOR ^C ON KB INPUT WAITS.				      &

10110	PRINT #O%,S$;" ";						      &
	\ T%=UU.SYS0%(6%)						      &
	\ T1%=UU.SYS1%(13%)+SWAP%(UU.SYS1%(14%))			      &
	\ IF (T1% AND -4096%)<>0% THEN					      &
		T%=64%							      &
	\	IF (T1% AND 1536%)<>0% THEN				      &
			T%=T%+64%					      &
	\		IF (T1% AND 512%)<>0% THEN			      &
				T%=T%+64%				      &
	! PRINT THE 1ST PART OF THE STATE INFO.				      &
	! GET THE CONTENTS OF JDSWAP AND M.CTRL.			      &
	! IF THIS IS <0 THEN						      &
	!	JOB IS EITHER						      &
	!	BIT 12-15	LOCKED					      &
	!	BIT 11		SWAPPED					      &
	!	BIT 10		SWAPPING IN (OR WANTS TO)		      &
	!	BIT 9		SWAPPING OUT (OR WANTS TO)		      &

10120	IF (T% AND 63%)<>0% THEN					      &
		S$=CHR$(65%+(T% AND 192%)/64%)+				      &
		RIGHT(NUM$(100%+(T% AND 63%)),3%)			      &
	ELSE	IF (T% AND 248%)=0% AND (JDFLG% AND 16384%)<>0% THEN	      &
		S$="NSw "						      &
	ELSE	S$=MID("    Lck Swi Swo ",(T% AND 192%)/16%+1%,4%)	      &
	! IF THE JOB IS SWAPPED THEN					      &
	!	PRINT SLOT # AND SWAPPING FILE, WHERE			      &
	!	A	SWAP0.SYS					      &
	!	B	SWAP1.SYS					      &
	!	C	SWAP2.SYS					      &
	!	D	SWAP3.SYS					      &
	!	ELSE	PRINT BLANKS OR PROPER MESSAGE			      &

10130	PRINT #O%,S$;							      &
	\ T0=UU.SYS0%(7%)+(256.*(UU.SYS0%(8%)))				      &
	\ T0=T0+(65536.*UU.SYS0%(16%))					      &
	\ T=INT(T0/10.)							      &
	\ T0=T0-10.*T							      &
	\ c1%=1% ! do the HH:MM:SS format				      &
	\ GOSUB 14000							      &
	\ T0 = 15. IF ASCII(S$)=63%					      &
	\ PRINT #O%,FNS$(8%);".";CHR$(48%+T0);				      &
	\ S$=NUM1$(UU.SYS1%(17%)*256%/256%)				      &
	\ PRINT #O%,FNS$(5%);"/";NUM1$(UU.SYS1%(18%));			      &
		IF PRIV.TUNE%						      &
	\ PRINT #O%,TAB(59%-(PRIV.TUNE%*9%)-((NOT PRIV.TUNE%)*2%));	      &
		RAD$(UU.SYS0%(27%)+SWAP%(UU.SYS0%(28%)));		      &
		RAD$(UU.SYS0%(29%)+SWAP%(UU.SYS0%(30%)))		      &
	\ GOTO 10020							      &
	! PRINT THE SWAPPING INFO.					      &
	! PRINT THE ACCUMULATED CPU TIME.				      &
	! If the CPU time overflowed, set T0 = ASCII of "?" minus 48%	      &
	!   so that a "?" will be printed in the PRINT #O, ... CHR$(48%+T0)   &
	! GET THE PRIORITY FROM JDPRI.					      &
	! LEFT THEN RIGHT SHIFT IT TO GET THE PROPER SIGN.		      &
	! PRINT THE PRIORITY IF THE USER'S PRIVILEGED.			      &
	! PRINT THE RTS NAME THEN GET OUT				      &

10140	RETURN								      &
									      &

10250	!								      &
									      &
									      &
	!	R U N - T I M E    S Y S T E M S			      &
									      &
									      &
									      &
	!	R T S    D E S C R I P T O R    B L O C K		      &
	!								      &
	!	  CONTENTS		OFFSET				      &
	!	   R.LINK		  0	PTR TO NEXT RTS		      &
	!	   R.NAME1		  2	RTS NAME		      &
	!	   R.NAME2		  4				      &
	!	   R.DEXT		  6	DEF EXT FOR RUNNABLE IMAGES   &
	!  	   R.MCTL		  8	MEMORY CONTROL AREA	      &
	!	     "" 		 10		""		      &
	!	     "" 		 12		""		      &
	!	  ""   - R.SIZE		 14	  ""  - RTS SIZE IN K WORDS   &
	!	     "" 		 16		""		      &
	!	   R.DATA1		 18	FUN/FBN OF THE RTS	      &
	!	   R.DATA2		 20				      &
	!	   R.FILE1		 22	NE OFFSET/2, FBN OF FILE UFD  &
	!	   R.FILE2		 24				      &
	!	   R.CNT		 26	ACCESS/RESIDENCY COUNT	      &
	!	R.MSIZ - R.SIZE		 28	MAX JOB SIZE - MIN JOB SIZE   &
	!	   R.FLAG		 30	FLAGS			      &
	!								      &
	!	R.FLAG BITS:						      &
	!	BIT	MEANING						      &
	!	0-7	EMT PREFIX CODE					      &
	!	 8	KEYBOARD MONITOR				      &
	!	 9	ONLY 1 USER					      &
	!	10	MAP RTS READ/WRITE				      &
	!	11	DON'T ERROR LOG					      &
	!	12	UNCONDITIONAL REMOVE				      &
	!	13	RUN SIZE COMPUTED FROM FILESIZE			      &
	!	14	SAVE THE LOAD ADDRESS (M.PHYA)			      &
	!	15	SPECIAL EMT HANDLING				      &
									      &

10260	J%=M3%(27%)							      &
	\ DKBM.PTR%=PEEK(M2%(15%)-2%)					      &
	\ PRINT #O%,C$;"Run-Time Systems:";C$;				      &
	" Name";TAB(8%);"Typ";TAB(14%);"Dev";TAB(21%);"Size";		      &
		TAB(29%);"Users";TAB(36%);"Comments"			      &
	\ T%=0%								      &
	! Get pointer to the NULRTS description block.			      &
	! GET POINTER TO THE DEFAULT KEYBOARD MONITOR.			      &
	! PRINT HEADER							      &
	! T% IS A FLAG FOR PRINTING PRIMARY RTS COMMENT			      &
									      &

10270	T%=T%+1%							      &
	\ C%=PEEK(J%+26%)						      &
	\ J2%=PEEK(J%+14%)						      &
	\ F%=PEEK(J%+30%)						      &
	\ T$=NUM1$(PEEK(J%+28%) AND 255%)				      &
	\ PRINT #O%,RAD$(PEEK(J%+2%));RAD$(PEEK(J%+4%));		      &
		TAB(8%);RAD$(PEEK(J%+6%));				      &
	\ PRINT #O%, TAB(14%);FNACCOUNT$(M2%(21%),PEEK(J%+18%),0%);	      &
			UNLESS T%=1%					      &
	\ PRINT #O%, TAB(20%);FNN$(4%-LEN(T$),(J2% AND 255%));"(";T$;")K";    &
		TAB(29%);FNN$(3%,(C% AND 255%));			      &
	\ IF T% = 1% THEN						      &
		S$="Monitor"						      &
	ELSE	IF (J2% AND -256%)=512% THEN				      &
			S$="Non-Res"					      &
		ELSE	IF (J2% AND 1024%)<>0% THEN			      &
				S$="Loading"				      &
			ELSE	S$="Temp"				      &
	\			S$="Perm" IF C%<0%			      &
	\			S$="Primary, Perm" IF J%=PEEK(M2%(15%))	      &

10280	J3%=PEEK(J%+16%)						      &
	\ S$=S$+", Addr:"+NUM1$(FNSHFT.RGT%(J3%,5%)) IF J3%<>0%		      &
	\ IF (F% AND 256%) THEN						      &
		S$=S$+", DF KBM" IF DKBM.PTR%=J%			      &
	\	S$=S$+", KBM"  IF DKBM.PTR%<>J%				      &

10285	S$=S$+MID(", 1US, R/W, NER, Rem, CSZ",(I%-9%)*5%+1%,5%)		      &
		IF (F% AND 2%^I%)<>0% FOR I%=9% TO 13%			      &
	\ S$=S$+", EMT:"+NUM1$(F% AND 255%) IF F%<0%			      &
	\ PRINT #O%,TAB(36%);S$						      &
	\ J%=PEEK(J%)							      &
	\ GOTO 10270 IF J%						      &
	\ RETURN							      &
	! C%=R.CNT, J2%=M.CTRL (HI) - R.KSIZ (LO), F%=R.FLAG		      &
	! WE ARE LOOKING AT A RTS DESCRIPTOR BLOCK.			      &
	! PRINT THE RTS NAME (R.NAME), THE DEFAULT RTS EXTENSION	      &
	! (R.DEXT), AND THE SIZE OF THE MODULE IN K (R.KSIZ)		      &
	! AND ITS MAXIMUM USER JOB SIZE IN K (R.SIZE).			      &
	!								      &
	! PRINT THE COUNT OF USERS EXECUTING UNDER THE RTS (R.CNT).	      &
	! PRINT LOAD ADDRESS IF NON-ZERO.				      &
	! IF THE RTS IS A KEYBOARD MONITOR THEN				      &
	!	MAKE THE DESCRIPTOR "DKBM" IF IT'S THE DEFAULT KBM	      &
	! ELSE								      &
	!	IT'S JUST "KBM"						      &
	! EXAMINE M.CTRL AND DETERMINE THE CURRENT STATE OF THE RTS.	      &
	! CONTINUE IF WE HAVEN'T REACHED THE END (0) OF THE LINKED LIST	      &
	! OF RTS DESC. BLOCKS.						      &
									      &

10350	!								      &
									      &
									      &
	!	B U S Y    D E V I C E S				      &
									      &
									      &

10360	PRINT #O%,C$;"Busy Devices:";					      &
	\ C1%=0%							      &
	\ J1%=M%(5%)+M2%(9%)						      &
	\ DVPTR%=M%(7%)+M2%(9%)						      &
	\ FOR C%=(M2%(5%)+M2%(9%)) TO (M2%(23%)-2%) STEP 2%		      &
	\	S$=CVT%$(SWAP%(PEEK(C%)))				      &
	\	J2%=PEEK(DVPTR%)					      &
	\	FOR U%=0% TO PEEK(J1%)					      &
	\		D%=PEEK(J2%)					      &
	\		DDIDX%=PEEK(D%) AND 255%			      &
	\		I%=FNT3%(DDIDX%) IF U%=0% AND S$="XD"		      &
	\		J%=PEEK(D%+2%) AND 255%				      &
	\		GOTO 10390 IF J%=0% OR ((J% AND 1%)<>0% AND	      &
							(J%<>3% AND J%<>5%))  &
	\		GOTO 10390 IF (8192% AND PEEK(D%+6%))<>0%	      &
						IF S$="KB"		      &
	\		PRINT #O%;C$;"Device      Job    Why" IF C1%=0%	      &
	\		C1%=1%						      &
	\		T$="CFG" IF J%=3%				      &
	\		T$="TRN" IF J%=5%				      &
	\		T$=NUM1$(J%/2%) UNLESS J%=3% OR J%=5%		      &
	\		PRINT #O%,FNDDCU$(S$,U%,D%); IF S$ = "XM"	      &
						     OR S$ = "XD"	      &
	\		PRINT #O%,S$;NUM1$(U%);TAB(12%); UNLESS S$ = "XM"     &
								 OR S$ = "XD" &
	\		PRINT #O%,T$;"	   ";				      &
	\		PRINT #O%,"Disabled"; IF J%=3%			      &
	\		J%=PEEK(D%+6%)					      &
	\		PRINT #O%,"AS"; IF (J% AND (32767%+1%))<>0%	      &
	\		IF (J% AND 255%)<>0% THEN			      &
				IF (J% AND (32767%+1%))<>0% THEN	      &
					PRINT #O%,"+Open";		      &
				ELSE	PRINT #O%,"Open";
10370			IF S$="MT" OR S$="MM" OR S$="MS" OR S$="MU" THEN      &
				IF (SWAP%(PEEK(D%+24%))AND 255%)=0% THEN      &
					PRINT #O%,"+DOS";		      &
				ELSE	PRINT #O%,"+ANSI";
10380			PRINT #O%
10390			J2%=J2%+2%					      &
	\	NEXT U%
10400		J1%=J1%+2%						      &
	\ DVPTR%=DVPTR%+2%						      &
	\ NEXT C%							      &
	! M%(5%)	DEVCNT -> MAX UNIT NUMBER			      &
	! M%(7%)	DEVPTR -> EACH ENTRY IS A POINTER TO A POINTER	      &
	!			  TO THE UNIT 0 DDB OF THE NON-DISK DEVICE.   &
	! M2%(5%)	DEVNAM -> ASCII DEVICE NAMES			      &
	! M2%(9%)	DEVOKB -> NON-DISKS				      &
	! M2%(23%)	DEVSYN -> ALTERNATE DEVICE NAMES		      &
	!								      &
	! CLEAR BUSY DEVICES EXIST FLAG.				      &
	! J1%	1ST NON-DISK IN DEVCNT					      &
	! J2%	POINTS TO DEVPTR WHICH WILL POINT TO DEVTBL		      &
	! FOR ALL NON-DISK DEVICES (C% POINTS TO NON-DISK ENTRY IN	      &
	! DEVNAM - STOPS BEFORE DEVSYN)					      &
	!	GET THE DEVICE NAME.					      &
	!	FOR 0 TO THE MAXIMUM # OF UNITS FOR THIS TYPE:		      &
	!		POINT TO THE PROPER DDB (VARIABLE LENGTH)	      &
	!								      &
	!		  DDB		OFFSET				      &
	!		DDSTS - DDIDX	0				      &
	!		DDUNT - DDJBNO	2				      &
	!		   DDTIME	4				      &
	!		STATUS - DDCNT	6				      &
	!								      &
	!		GET THE DRIVER INDEX				      &
	!		LOOK AT THE OWNER JOB INDEX IN THE DDB (DDJBNO)	      &
	!			0	SIGNALS FREE			      &
	!		ODD	SIGNALS DISABLED DEVICE			      &
	!		IGNORE THE UNIT IF IT'S ONE OF THESE.		      &
	!		IF IT'S A TERMINAL, CHECK THE DDB ASSIGNMENT	      &
	!		STATUS TO SEE IF IT'S THE JOB'S CONSOLE TERMINAL      &
	!		IF SO, IGNORE IT.				      &
	!		OTHERWISE, PRINT THE DEVICE,UNIT # AND JOB #	      &
	!		GET THE ASSIGNMENT STATUS FROM THE DDB.		      &
	!		CHECK TO SEE IF THE DEVICE IS ASSIGNED ("AS")	      &
	!		IF THE INIT COUNT IN DDCNT IS NON-ZERO,		      &
	!		PRINT (OR TACK ON IF ALSO ASSIGNED) "OPEN".	      &
	!		IF WE HAVE A MAGTAPE, CHECK APPROPRIATELY.	      &

10410	PRINT #O%," None" IF C1%=0%					      &
	! LET THE USER KNOW IF THERE WEREN'T				      &
	! ANY BUSY DEVICES						      &

10420	RETURN								      &
									      &

10450	!								      &
									      &
									      &
	!	B U F F E R,   H U N G   T T Y    A N D			      &
	!	J O B   C O U N T    I N F O R M A T I O N		      &
									      &
									      &

10460	J%=PEEK(M2%(11%))						      &
	\ C%=PEEK(M2%(17%))						      &
	\ C%=C%-J% IF J%>0%						      &
	\ PRINT #O%,C$;							      &
	"General  FIP                    Hung";C$;			      &
	"Buffers  Buffers  Jobs/Jobmax   TTY's   Errors";C$;		      &
	FNN$(5%,PEEK(M2%(3%)+2%));"      ";				      &
	FNN$(3%,PEEK(M2%(3%)-2%));"      ";				      &
	FNN$(2%,(PEEK(M2%(13%)) AND 255%));"/";				      &
	NUM1$(SWAP%(PEEK(M2%(13%))) AND 255%);TAB(32%);			      &
	FNN$(3%,J%);"     ";FNN$(4%,C%)					      &
	! C%=TOTAL ERROR COUNT (ERLCTL)-TTYHCT (J%, # OF HUNG		      &
	! TERMINAL ERRORS SINCE SYSTEM START UP).			      &
	! PRINT THE HEADER						      &
	! LOOK AT TABLE OF FREE BUFFER INFO (FREES)			      &
	! AND GET # OF GENERAL AND FIP SMALL BUFFERS.			      &
	! FROM JOBCNT, DETERMINE THE CURRENT/MAX JOB COUNT.		      &

10465	Z$=SYS(CHR$(6%)+CHR$(-30%)+CHR$(2%)) IF RESET.ERRORS%		      &
		! Reset the system error count if requested.		      &

10470	RETURN								      &
									      &

10500	!								      &
	!								      &
	!								      &
	!	D I S K    S T R U C T U R E				      &
	!								      &
	!								      &

10510	DEVCNT%=M%(5%)							      &
	\ UNTCLU%=M%(17%)						      &
	\ UNTCNT%=M%(19%)						      &
	\ SATCTL%=M%(21%)						      &
	\ SATCTM%=M%(25%)						      &
	\ UNTOPT%=M%(29%)						      &
	\ DEVNAM%=M2%(5%)						      &
	\ NUM.DISK.TYPES%=M2%(9%)					      &
	\ DSKLOG%=M2%(21%)						      &
	\ SATEND%=M3%(7%)						      &
	\ UNTLVL%=M3%(9%)						      &
	\ UNTERR%=M3%(23%)						      &
	\ DEVCLU%=M3%(25%)						      &
	\ FUN% = 0%							      &
	\ HDR.PRINTED% = 0%						      &
	\ FOR C%=0% TO NUM.DISK.TYPES%-2% STEP 2%			      &
	\	DEVICE.NAME$=CVT%$(SWAP%(PEEK(DEVNAM%+C%)))		      &
	\	FOR U%=0% TO PEEK(DEVCNT%+C%)				      &
	\		UNTCNT.ENTRY%=PEEK(UNTCNT%+FUN%)		      &
	\		UNTCLU.ENTRY%=PEEK(UNTCLU%+FUN%)		      &
	\		UNTLVL.ENTRY%=PEEK(UNTLVL%+FUN%)		      &
	\		UNTOPT.ENTRY%=PEEK(UNTOPT%+FUN%)		      &
	\		DSKLOG.PTR%=DSKLOG%+(FUN%*5%)			      &
	\		GOTO 10540 IF UNTCNT.ENTRY%<0%			      &
	\		GOTO 10540 IF (D.DISK$ <> "") AND		      &
				     ((D.DISK$ <> DEVICE.NAME$) OR	      &
				      (D.UNIT% <> U%))			      &
	\		PRINT #O%,C$;"Disk Structure:";C$;		      &
	"Dsk  Open    Size      Free    Clu   Err Name      Level  Comments"  &
				UNLESS HDR.PRINTED%			      &
	\		HDR.PRINTED% = -1%				      &
	\			PRINT #O%,DEVICE.NAME$;NUM1$(U%);TAB(5%);     &
				FNN$(4%,UNTCNT.ENTRY% AND 1023%);TAB(10%);    &
	\			IF (UNTCNT.ENTRY% AND 4096%)<>0% THEN	      &
					PRINT #O%,TAB(31%);		      &
					FNN$(3%,UNTCLU.ENTRY% AND 255%);      &
					TAB(35%);			      &
					FNN$(5%,PEEK(UNTERR%+FUN%));	      &
	\				GOTO 10530			      &
	!								      &
	! Get pointers to various device tables				      &
	! Initialize the header-printed flag to not printed yet		      &
	! For each disk type on the system				      &
	!	Get the device name					      &
	!	For each unit of this type				      &
	!		Get various table entries for the unit		      &
	!		Skip it if this unit is not mounted		      &
	!		Skip it if the user specified a disk and no match     &
	!		Print the header if we haven't already printed it     &
	!		Set the header-printed flag			      &
	!			Print the device name and unit number	      &
	!			If the device is mounted non-file structured then &
	!				Print Pack Cluster Size and Error Count &
	!				Go and print comments		      &
	!								      &

10520			T=PEEK(SATCTL%+FUN%)				      &
	\		T=T+65536. IF T<0.				      &
	\		T=T+65536.*PEEK(SATCTM%+FUN%)			      &
	\		PCS% = UNTCLU.ENTRY% AND 255%			      &
	\		T9 = FNDISKSIZE(PCS%,PEEK(SATEND%+FUN%),	      &
						PEEK(DEVCLU%+FUN%) AND 255%)  &
	\		TOTAL$=NUM1$(T9)				      &
	\		FREE$=NUM1$(T)					      &
	\		PRINT #O%, STRING$(7%-LEN(TOTAL$),32%);TOTAL$;	      &
				   TAB(18%);STRING$(7%-LEN(FREE$),32%);FREE$; &
	\		T9% = (T/T9)*100% IF T9 > 0.			      &
	\		PRINT #O%, TAB(27%);FNN$(2%,T9%);"%"; IF T9 > 0.      &
	\		PRINT #O%, TAB(31%);				      &
			FNN$(3%,UNTCLU.ENTRY% AND 255%);TAB(35%);	      &
			FNN$(5%,PEEK(UNTERR%+FUN%));TAB(41%);		      &
			RAD$(PEEK(DSKLOG.PTR%));RAD$(PEEK(DSKLOG.PTR%+2%));   &
			RAD$(PEEK(DSKLOG.PTR%+4%));TAB(45%);		      &
			FNN$(3%,SWAP%(UNTLVL.ENTRY%) AND 255%);".";	      &
			NUM1$(UNTLVL.ENTRY% AND 255%);			      &
	!								      &
	!		Get the number of free blocks (LSB)		      &
	!		Make it an unsigned number			      &
	!		Now add in the free blocks (MSB)		      &
	!		  and compute the disk size			      &
	!		Print the number of available blocks along with the   &
	!		  Pack Cluster Size, Error Count, Name and Rev/Level  &
	!		  numbers					      &
	!								      &

10530			S$="Pub"					      &
	\		S$="Pri" IF (UNTCNT.ENTRY% AND 16384%)<>0%	      &
	\		S$="NFS" IF (UNTCNT.ENTRY% AND 4096%)<>0%	      &
	\		S$=S$+","+"R-O" IF (UNTCNT.ENTRY% AND 2%^10%)<>0%     &
	\		S$=S$+","+"DLA" IF ((UNTCNT.ENTRY% AND 2%^11%)=0%)    &
					AND ((UNTCNT.ENTRY% AND 4096%)=0%)    &
	\		S$=S$+","+"DLW" IF ((UNTCNT.ENTRY% AND 2%^11%)<>0%)   &
					AND ((UNTCNT.ENTRY% AND 4096%)=0%)    &
	\		S$=S$+","+"Lck" IF (UNTCNT.ENTRY% AND 2%^13%)<>0%     &
	\		S$=S$+",LDX" IF PEEK(SATCTM%+(SATCTM%-SATCTL%)+FUN%)  &
	\		S$=S$+",NFF" IF UNTOPT.ENTRY% AND 512%		      &
	\		S$=S$+",INI" IF UNTOPT.ENTRY% AND 2%		      &
	\		S$=S$+",DP" IF UNTOPT.ENTRY% AND 8%		      &
	\		S$=S$+",dirty" IF UNTOPT.ENTRY% AND 1%		      &
	\		OWNER%=SWAP%(UNTCLU.ENTRY%) AND 255%		      &
	\		IF ((UNTCNT.ENTRY% AND 20480%)<>0% AND OWNER%<>0%)    &
			THEN						      &
				S$=S$+",Job "+NUM1$(OWNER%/2%)		      &
					UNLESS (OWNER% AND 1%)<>0%	      &
	\			S$=S$+",System" IF (OWNER% AND 1%)<>0%	      &
	!								      &
	!		Determine and print which features this unit has      &
	!		If this unit is mounted private or non-file structured &
	!		  and there's an owner then			      &
	!			Print the owning job number unless system job &
	!			Print SYSTEM if the owning job is a system job &
	!								      &

10535			TMP$=FNPRINT.CMNTS$(O%,58%,S$)			      &
	\		PRINT #O%					      &

10537	IF RESET.DISK.ERRORS% THEN		!If reset disk error counts   &
		IF (D.DISK$ = "") OR		! If we reset all disks errors &
		((D.DISK$ = DEVICE.NAME$) AND	!or this is the specified disk &
		 (D.UNIT% = U%)) THEN		!   and unit number	      &
			Z$=SYS(CHR$(6%)+CHR$(-30%)+CHR$(1%)+ !Then reset it   &
			   STRING$(19%,0%)+DEVICE.NAME$+CHR$(U%)+CHR$(-1%))   &

10540	 		FUN% = FUN%+2%					      &
	\	NEXT U%							      &
	\ NEXT C%							      &
	\ PRINT "%Disk is not mounted" UNLESS HDR.PRINTED%		      &
	\ RETURN							      &
	!								      &
	!		Next Fip Unit Number				      &
	!		Update the Logical Name pointer			      &
	!	Next unit						      &
	! Next disk type						      &
	! Display a warning unless we printed something.		      &
	! Finished, return to our caller				      &
	!								      &
									      &

10600	!								      &
									      &
									      &
	!	O P E N    F I L E S					      &
									      &
									      &
									      &
	!	F I L E   C O N T R O L   B L O C K			      &
	!								      &
	!	   CONTENTS	OFFSET					      &
	!	    F$LINK	   0	PTR TO NEXT FCB			      &
	!	    F$FID	   2	FILE ID OF FILE			      &
	!	    F$PPN	   4	PPN OF FILE			      &
	!	    F$NAM	   6	FILE NAME AND EXTENSION		      &
	!			   8	   IN RAD50			      &
	!			  10					      &
	!	F$PROT-F$STAT	  12	PROTECTION CODE-STATUS BYTE	      &
	!	F$RCNT-F$ACNT	  14	ACCESS CNT FOR READ REGARDLESS-	      &
	!					NORMAL/UPDATE OPENS	      &
	!	    F$WFND	  16	FBB OF FIRST RETRIEVAL ENTRY	      &
	!			  18					      &
	!	    F$UFND	  20 	FBB OF NAME ENTRY		      &
	!	   		  22					      &
	!	F$SIZM-F$UNT	  24 	FILE SIZE MSB-FIP UNIT NUMBER	      &
	!	    F$SIZL	  26	FILE SIZE LSB			      &
	!	    F$CLUS	  28	FILE CLUSTERSIZE		      &
	!	    F$WCB	  30	PTR TO FIRST WCB OPEN ON THIS FILE    &
	!								      &
	! Access to open file information is granted according to the state   &
	! of the user's WREAD and GREAD privs.				      &
	!								      &
	!   WREAD  GREAD  Open file info allowed			      &
	!   -----------------------------------------------------	      &
	!     on    n/a   All files					      &
	!    off     on   Files open by any job whose PPN is in user's group  &
	!		  or any files in user's group open by any PPN	      &
	!    off    off   Files open by any job whose PPN is same as user's   &
	!		  or files in user's PPN open by any PPN	      &
	!								      &

10610	USER.PPN% = SWAP%(CVT$%(MID(SYS(UU$+CHR$(0%)+CHR$(0%)),21%,2%)))      &
	\ USER.PROJ% = SWAP%(USER.PPN%) AND 255%			      &
	\ PRINT #O%,C$;"Open Files";					      &
	\ PRINT #O%," (";O.DEV$;" only)"; IF LEN(O.DEV$)		      &
	\ PRINT #O%," for job ";NUM1$(J7%);":" IF J7%			      &
	\ PRINT #O%," and jobs accessing them"; IF O8% AND 1024% IF J7%=0%    &
	\ PRINT #O%,":"; UNLESS J7%					      &
	\ HD%,HD1%,T%=0%						      &
	\ J2%=M%(19%)							      &
	\ J6%=M2%(29%)							      &
	!	PRINT HEADER						      &
	!	GET UNTCNT AND FCBLST					      &

10615	SYFLAG%=0%							      &
	\ IF LEN(O.DEV$) THEN						      &
		IF 'SY'=LEFT(O.DEV$,2%) AND LEFT(O.DEV$,3%)<>"SY0" THEN	      &
			SYFLAG%=1%					      &
	\		O.DEV$=''					      &
 	!	IF SY: WAS SPECIFIED THEN SET THE FLAG			      &

10616	FOR C%=0% TO (M2%(9%)-2%) STEP 2%				      &
	\	S0$=CVT%$(SWAP%(PEEK(M2%(5%)+C%)))			      &
	\	FOR U%=0% TO PEEK(M%(5%)+C%)				      &
	\		GOTO 10670 IF S0$<>LEFT(O.DEV$,2%) IF LEN(O.DEV$)     &
	\		GOTO 10670 IF NUM1$(U%)<>RIGHT(O.DEV$,3%)	      &
				IF LEN(O.DEV$) > 2%			      &
	\		J4%=PEEK(J2%)					      &
	\		GOTO 10670 IF (J4% AND 4096%)<>0% OR J4%<0%	      &
	\		GOTO 10670 IF (J4% AND 16384%) AND (SYFLAG%<>0%)      &
	\		PRINT #O% IF HD%=0%				      &
	\		HD%=-1%						      &
	\		T%=-1% UNLESS J7%				      &
	\		PRINT #O%,C$;S0$;NUM1$(U%);": -- "; UNLESS J7%	      &
	\		GOTO 10620 IF (J4% AND 511%)>0%			      &
	\		PRINT #O%;"None" UNLESS J7%			      &
	\		GOTO 10670					      &
	!	FOR ALL DISKS IN THE SYSTEM				      &
	!		GET THE DEVICE NAME				      &
	!		FOR ALL UNITS OF THIS DISK			      &
	!			J4%=STATUS ENTRY OF ERROR COUNTS AND	      &
	!				OPEN FILES FOR THIS DEVICE (UNTCNT)   &
	!			IGNORE THIS DISK IF NFS OR DISMOUNTED	      &
	!			IGNORE THIS DISK IF NOT A PUBLIC DISK WHEN    &
	!				SY: IS SPECIFIED		      &
	!			ALSO IGNORE IT IF NO OPEN FILES		      &

10620			FCB%=PEEK(J6%)					      &
	\		GOTO 10625 IF FCB%				      &
	\		PRINT #O%;"System files only" UNLESS J7%	      &
	\		GOTO 10670					      &
	!			IF FCBLST = 0 THEN IT IS A SYSTEM FILE	      &
	!				IGNORE IT			      &

10625			PRINT #O%,"File";TAB(29%);"Op/RR";TAB(38%);"Size";    &
			 TAB(46%);"Clu";TAB(51%);"Status"		      &
			 IF J7%=0% OR HD1%=0%				      &
	\		HD1%=-1%					      &
	\		WHILE FCB%					      &
	\			F.CLUS%=PEEK(FCB%+28%)			      &
	\			GOTO 10628 IF F.CLUS%=2%^I%		      &
					FOR I%=0% TO 8%			      &
	\			GOTO 10660				      &
	!			PRINT HEADINGS				      &
	!			WHILE NOT END OF FCBLST			      &
	!				CHECK TO SEE IF FILE-CLUSTER IS A     &
	!					POWER OF 2		      &
	!				IF NOT THEN SKIP		      &

10628				GOTO 10630 UNLESS J7%	! No specific job     &
	\			WCB%=PEEK(FCB%+30%)	! Get first WCB	      &
	\			ST%=0%			! none found	      &
	\				WHILE WCB%<>0% AND (ST%=0%)	      &
	\				T%,ST%=-1% IF (PEEK(WCB%+2%)	      &
						AND 255%)=J7%*2%	      &
	\				WCB%=PEEK(WCB%+12%) AND (NOT 31%)     &
	\				NEXT				      &
	\			GOTO 10650 UNLESS ST%	! Next file	      &

10630				FILE.OK%=0%				      &
	\			FILE.PPN% = PEEK(FCB%+4%)		      &
	\			FILE.PROJ%=SWAP%(FILE.PPN%) AND 255%	      &
	\			FILE.PROG%=FILE.PPN% AND 255%		      &
	\			FILE.OK% = PRIV.WREAD% OR		      &
				  (PRIV.GREAD% AND (USER.PROJ%=FILE.PROJ%))   &
				  OR (FILE.PPN% = USER.PPN%)		      &
	\			GOTO 10632 IF FILE.OK%			      &
	\			WCB%=PEEK(FCB%+30%)			      &
	\			WCB%=WCB% AND -32%			      &
	\			READ.OK%=0%				      &
	\			WHILE WCB%<>0%				      &
	\				W.FLG%=PEEK(WCB%+2%)		      &
	\				JOBNO% = (W.FLG% AND 255%)	      &
	\				W.WCB%=PEEK(WCB%+12%)		      &
	\				OPEN.PPN% = SWAP%(CVT$%(MID(SYS(UU$   &
					 +CHR$(JOBNO%/2%)+CHR$(0%)),21%,2%))) &
	\ 				OPEN.PROJ%=SWAP%(OPEN.PPN%) AND 255%  &
	\				READ.OK%=-1% IF (PRIV.GREAD% AND      &
						(USER.PROJ%=OPEN.PROJ%))      &
						OR (OPEN.PPN% = USER.PPN%)    &
	\				W.WCB%=PEEK(WCB%+12%)		      &
	\				WCB%=W.WCB% AND -32%		      &
	\			NEXT					      &
	\			GOTO 10650 IF NOT READ.OK%		      &
	!				GO THROUGH ALL THE WCB'S FOR THIS     &
	!				OPEN FILE AND SKIP THE FILE UNLESS    &
	!				IT IS OPEN TO A PPN THE USER HAS      &
	!				PRIVS FOR			      &

10632				ST%=PEEK(FCB%+12%)			      &
	\			PRINT #O%,S0$;NUM1$(U%);":";		      &
				 "[";FNN$(3%,FILE.PROJ%);",";		      &
				NUM1$(FILE.PROG%);TAB(12%);"]";		      &
	\			PRINT #O%;				      &
				 RAD$(PEEK(FCB%+6%));RAD$(PEEK(FCB%+8%));     &
				 ".";RAD$(PEEK(FCB%+10%));		      &
		 		"<";FNN$(2%,SWAP%(ST%) AND 255%);">";	      &
		 			UNLESS (ST% AND 64%)<>0%	      &
	\			PRINT #O%;TAB(29%);			      &
				 FNN$(2%,PEEK(FCB%+14%) AND 255%);"/";	      &
				 NUM1$(SWAP%(PEEK(FCB%+14%)) AND 255%);	      &
	\			S$=NUM1$((SWAP%(PEEK(FCB%+24%)) AND 255%)*65536. &
				 +32768.+(PEEK(FCB%+26%) EQV 32767%))	      &
	\			PRINT #O%;TAB(36%);FNS$(5%);TAB(46%);	      &
				 FNN$(2%,F.CLUS%);			      &
	\			S$=""					      &
	\			S$=", Pla" IF (ST% AND 2%)<>0%		      &
	\			S$=S$+", "+MID("UpdCtgNoKUFD",(I%-2%)*3%-2%,3%) &
					IF (ST% AND 2%^I%)<>0% FOR I%=3% TO 6% &
	\			T$=""					      &
	\			WCB%=PEEK(FCB%+30%)			      &
	\			T$=T$+", Perm" IF WCB% AND 1%		      &
	\			T$=T$+", Priv" IF WCB% AND 2%		      &
	\			WCB%=WCB% AND -32%			      &
	\			IF (ST% AND 128%) THEN			      &
					T$=", MDL"			      &
	\				IF (PEEK(WCB%) AND 2048%)=0% THEN     &
						T$=", Tent"		      &
						IF (PEEK(WCB%+12%) AND 2%)<>0% &
									      &
	!				PRINT FCB INFO FOR ALL FILES OPEN ON  &
	!					THIS UNIT		      &

10634				PRINT #O%;TAB(51%);RIGHT(S$+T$,3%)	      &
	\			GOTO 10650 UNLESS O8% AND 1024%		      &
	!				PRINT STATUS			      &
	!				IF WCB INFO NOT REQUESTED, THEN SKIP  &

10635				WHILE WCB%<>0%				      &
	\				ST%=PEEK(WCB%)			      &
	\				W.FLG%=PEEK(WCB%+2%)		      &
	\				JOBNO% = (W.FLG% AND 255%)	      &
	\				W.WCB%=PEEK(WCB%+12%)		      &
	\				OPEN.PPN% = SWAP%(CVT$%(MID(SYS(UU$   &
					 +CHR$(JOBNO%/2%)+CHR$(0%)),21%,2%))) &
	\ 				OPEN.PROJ%=SWAP%(OPEN.PPN%) AND 255%  &
	\				GOTO 10648 UNLESS PRIV.WREAD%	      &
					   OR FILE.OK%			      &
					   OR (PRIV.GREAD% AND		      &
					   (USER.PROJ%=OPEN.PROJ%))	      &
					   OR (OPEN.PPN% = USER.PPN%)	      &
	\				PRINT #O%;TAB(6%);		      &
	\				GOTO 10660 IF (JOBNO%/2%) > 63%	      &
	\				S$ = NUM1$((SWAP%(PEEK(WCB%+4%))      &
						AND 255%)*65536.+32768.+      &
						(PEEK(WCB%+6%) EQV 32767%))   &
	\				B=VAL(S$) !SAVE LAST BLOCK #	      &
	\				PRINT #O%,"Job ";		      &
	\				PRINT #O%,"NSP"; IF JOBNO% = 3%	      &
	\				PRINT #O%,"TRN"; IF JOBNO% = 5%	      &
	\				PRINT #O%,NUM1$(JOBNO%/2%);	      &
							UNLESS JOBNO% = 3%    &
							    OR JOBNO% = 5%    &
	\				PRINT #O%,TAB(14%);"Block ";S$;	      &
	\				S$=""				      &
	\				S$="NFS, " IF ST% AND 256%	      &
	\				S$=S$+"Rd, " IF (ST% AND 512%)=0%     &
	\				S$=S$+"Wr, " IF (ST% AND 1024%)=0%    &
	\				S$=S$+"UFD, " IF ST% AND 16384%	      &
	\				S$=S$+"Lock " IF ST% AND 8192%	      &
	\				X%=SWAP%(W.FLG%) AND 31%	      &
						IF ST% AND 8192%	      &
	\				S$=S$+NUM1$(B-X%)+"+"+NUM1$(X%)	      &
						IF ST% AND 8192%	      &
	\				S$=S$+", " IF ST% AND 8192%	      &
	\				S$=S$+"Seq, " IF W.WCB% AND 16%	      &
						IF W.WCB% AND 8%	      &
	\				S$=S$+"Rnd, "			      &
						IF (W.WCB% AND 16%)=0%	      &
						IF W.WCB% AND 8%	      &
	\				S$=S$+"Aex, " IF W.WCB% AND 4%	      &
	\				S$=S$+"RR, " IF W.WCB% AND 1%	      &
	\				IF (ST% AND 2048%)=0% THEN	      &
						S$=S$+"Tent, "		      &
							IF (W.WCB% AND 2%)<>0% &
					ELSE	IF (W.WCB% AND 2%)<>0% THEN   &
							S$=S$+"SpUp, "	      &
						ELSE	S$=S$+"Up, "	      &
	!				PRINT JOB # AND BLOCK #		      &

10640					PRINT #O%;			      &
					 TAB(29%);LEFT(S$,LEN(S$)-2%)	      &
	\				GOTO 10648 UNLESS		      &
						(W.FLG% AND 8192%)=8192%      &
	\				WCB%=WCB%+32% ! -> wcb EXTENSION      &
	\				B=0				      &
	\				FOR X%=2% TO 28% STEP 4%	      &
	\				S$=""				      &
	\				S$="Lock "+			      &
					  NUM1$((PEEK(WCB%+x%) AND	      &
					  255%)*65536.+32768.+(PEEK	      &
					  (WCB%+X%+2%) EQV 32767%))+"+"+      &
					  NUM1$(SWAP%(PEEK(WCB%+X%)) AND 255%) &
	\				S$="" IF PEEK(WCB%+X%)=0%	      &
	\				PRINT #O%; TAB(29%);S$ IF LEN(S$)     &
	\				B=B+1 IF LEN(S$)		      &
	\				NEXT X%				      &
	\				PRINT #O%; TAB(29%);		      &
					"No explicit locks"		      &
						IF B=0			      &

10648					WCB%=W.WCB% AND (NOT 31%)	      &
	\			NEXT					      &
	\			PRINT #O%				      &
	!				PRINT WCB INFO			      &

10650				FCB%=PEEK(FCB%)				      &
	\		NEXT	! Get next file (FCB)			      &
	\		PRINT #O% IF J7%=0% OR CCPOS(O%)		      &
	\		GOTO 10670	! Go onto next disk unit	      &

10660			PRINT #O%;"??"
10670			J2%=J2%+2%					      &
	\		J6%=J6%+2%					      &
	\	NEXT U%							      &
	!		INCREMENT UNTCNT AND FCBLST			      &
	!		GOTO NEXT DISK UNIT				      &

10680	NEXT C%								      &
	\ PRINT #O%," No open files found"; IF T%=0%			      &
	\ PRINT #O%," for this job"; IF J7% IF T%=0%			      &
	\ PRINT #O%,"." IF T%=0%					      &
	! AFTER COMPLETING THIS TYPE, GO ON TO THE NEXT.		      &
	! IF NO OPEN FILES EXISTED FOR ANY DEVICE SPECIFIED, PRINT NONE	      &

10690	RETURN								      &
									      &
									      &
									      &

10700	!								      &
									      &
									      &
	!	M E S S A G E    R E C E I V E R S			      &
									      &
									      &
									      &
	!	R E C E I V E R    I D    B L O C K			      &
	!								      &
	!	  CONTENTS		OFFSET				      &
	!	   S.LINK		  0	PTR TO NEXT RIB		      &
	!	   S.RCID1		  2	RECEIVER ID IN ASCII	      &
	!	   S.RCID2		  4				      &
	!	   S.RCID3		  6				      &
	!  	S.OBJT - S.JBNO		  8	OBJ TYPE (NET) - JOB #*2      &
	!	RESRVE - S.ACCS		 10	RESERVED - ACCESS CONTROL     &
	!	   S.BMAX 		 12	BUFFER MAXIMUM IN BYTES	      &
	!	S.MCNT - S.MMAX		 14	MESSAGE COUNT - MESSAGE MAX   &
	!	   S.MLST1 		 16	MSG LIST ROOT/TAIL POINTERS   &
	!	   S.MLST2		 18				      &
	!	S.LCNT - S.LMAX		 20	LINK COUNT - LINK MAX	      &
	!	   S.LLST1		 22	LINK LIST ROOT/TAIL POINTERS  &
	!	   S.LLST2		 24				      &
	!	  RESERVED		 26	RESERVED FOR NETWORKS	      &
	!	  RESERVED		 28	RESERVED FOR NETWORKS	      &
	!	  RESERVED		 30	RESERVED FOR NETWORKS	      &
	!								      &
	!	S.ACCS BITS:						      &
	!	BIT	MEANING						      &
	!	0	ALLOW LOCAL SENDERS				      &
	!	1	ALLOW ONLY PRIVILEGED LOCAL SENDERS		      &
	!	2	ALLOW NETWORK SENDERS				      &
	!	3	NETWORK SINGLE LINK MODE			      &
	!	4-6	RESERVED					      &
	!	7	FURTHER LOCAL SENDS ARE 'XOFFED'		      &

10710	RIB%=PEEK(M2%(19%))						      &
	\ PRINT #O%,C$;"Message Receivers: ";				      &
	\ IF RIB%<>0% THEN						      &
		PRINT #O%,C$;						      &
	"Rcvrid   Job    Rib  Obj   Msgs/Max   Links/InMax/OutMax  Access"    &
	ELSE	PRINT #O%," None"					      &
	\	GOTO 10740						      &
	!								      &
	! ACCESS THE SNDLST.						      &
	! PRINT THE HEADING.						      &
	! IF THE LIST IS NOT EMPTY THEN					      &
	!	PRINT ADDITIONAL HEADINGS				      &
	! ELSE	LET THE USER KNOW THERE AREN'T ANY			      &
	!	VALID RECEIVERS AND GET OUT.				      &

10715	NSP% = 0%							      &
	\ NSPLST% = SWAP%(CVT$%(MID(SYS(CHR$(6%)+CHR$(22%)+CHR$(-24%)+	      &
					CHR$(3%)),9%,2%)))		      &
	!								      &
	! OBTAIN NSP'S RIB OF THE NSP LIST.				      &
	!								      &

10720	WHILE RIB%<>0%							      &
	\	RCVRID$ = ""						      &
	\	OB.JOB% = PEEK(RIB%+8%)					      &
	\	JOBNO% = OB.JOB% AND 255%				      &
	\	ACC.ESS% = PEEK(RIB%+10%)  AND 255%			      &
	\	MCNT.MX% = PEEK(RIB%+14%)				      &
	\	LCNT.MX% = PEEK(RIB%+20%)				      &
	\	LOUT.MX% = PEEK(RIB%+26%) AND 255%			      &
 	\	RIB.NUM% = SWAP%(PEEK(RIB%+10%)) AND 255%		      &
	\	RIB.NUM$ = NUM1$(RIB.NUM%)				      &
	\	RIB.NUM$ = ' '+RIB.NUM$ WHILE LEN(RIB.NUM$) < 3%	      &
	\	RCVRID$ = RCVRID$+CVT%$(SWAP%(PEEK(RIB%+J0%)))		      &
				FOR J0% = 2% TO 6% STEP 2%		      &
	\	JOB$ = LEFT(RCVRID$,3%) IF (JOBNO% AND 1%)		      &
	\	JOB$ = FNN$(2%,JOBNO%/2%) UNLESS (JOBNO% AND 1%)	      &
	\	ACC.ESS%=(ACC.ESS% AND (NOT 1%)) IF (ACC.ESS% AND 2%)<>0%     &
	\	ACC.ESS$=""						      &
	\	ACC.ESS$=ACC.ESS$+", "+					      &
		CVT$$(MID("LclPrvNetOneNcs   Evt",I%*3%+1%,3%),2%)	      &
			IF ((ACC.ESS% AND 2%^I%)<>0%) AND (I%<>5%)	      &
				FOR I%=6% TO 0% STEP -1%		      &
	\	ACC.ESS$="  None" IF ACC.ESS$=""			      &
	\	PRINT #O%,RCVRID$;TAB(9%);JOB$; TAB(15%); RIB.NUM$;	      &
		TAB(21%);FNN$(2%,SWAP%(OB.JOB%) AND 255%);		      &
		TAB(27%);FNN$(4%,SWAP%(MCNT.MX%) AND 255%);		      &
			"/";NUM1$(MCNT.MX% AND 255%);			      &
		TAB(40%);FNN$(5%,SWAP%(LCNT.MX%) AND 255%);		      &
			"/";NUM1$(LCNT.MX% AND 255%);			      &
			"/";NUM1$(LOUT.MX%);				      &
		TAB(59%);RIGHT(ACC.ESS$,3%)				      &
	\	RIB%=PEEK(RIB%)						      &
	\	IF RIB%=0% AND NSP%=0% THEN				      &
			RIB%=PEEK(NSPLST%)				      &
	\		NSP%=-1%
10730	NEXT								      &
		! WHILE WE HAVEN'T REACHED THE END OF THE RECEIVER LIST:      &
		!	GET THE ACCESS CONTROL (SENDER) BYTE.		      &
		!	PRINT THE HEADER THE FIRST TIME THROUGH.	      &
		!	SET THE 'NETWORK MSG RCVRS EXIST' FLAG.		      &
		!	EXTRACT/PRINT THE RECEIVER ID AND		      &
		!	THE WORDS CONTAINING				      &
		!		NETWORK OBJECT TYPE - JOB #*2 (FUNCTION)      &
		!		PENDING MSG COUNT   - MAX ALLOWED	      &
		!		LOGICAL LINK COUNT  - MAX ALLOWED	      &
		!	EXTRACT/SET UP THE SENDER INFO:			      &
		!		BIT	MEANING IF SET			      &
		!		 0	LOCAL SENDERS ALLOWED		      &
		!		 1	LOCAL SENDERS MUST BE PRIVILEGED      &
		!			(MASKED	OUT IF BIT 0 IS ALSO ON)      &
		!		 2	NETWORK SENDERS ALLOWED		      &
		!		 3	ONE-SHOT CONNECTS		      &
		!		 4	NO CONDITIONAL SLEEPS		      &
		!		 5	(UNUSED)			      &
		!		 6	EVENT LOGGER			      &
		!		 7	(X-OFF, NOT DISPLAYED)		      &
		!*****							      &
		!	PRINT THE SENDER INFO.				      &
		!*****							      &
		!	GET THE LINK TO THE NEXT RECEIVER ID BLOCK.	      &
		!	IF WE'VE CHECKED ALL THE REGULAR RIB'S, PROCEED	      &
		!	TO SCAN NSP'S SPECIAL LIST.			      &
		! CONTINUE IN THIS LOOP.				      &
		! LET THE USER KNOW IF THERE WERE NO NETWORK MESSAGE	      &
		! RECEIVERS, I.E. NO RECEIVERS AT ALL OR NONE THAT HAD	      &
		! THE NETWORK SENDERS BIT SET.				      &

10740	RETURN								      &

10800	!								      &
									      &
									      &
	!	R E S I D E N T    L I B R A R I E S			      &
									      &
									      &
									      &
	!	L I B    D E S C R I P T O R    B L O C K		      &
	!								      &
	!	  CONTENTS		OFFSET				      &
	!	   R.LINK		  0	PTR TO NEXT LIB		      &
	!	   R.NAME1		  2	LIB NAME		      &
	!	   R.NAME2		  4				      &
	!	   L.PPN		  6	LIB'S OWNING PPN	      &
	!  	   R.MCTL		  8	MEMORY CONTROL AREA	      &
	!	     "" 		 10		""		      &
	!	     "" 		 12		""		      &
	!	  ""   - R.SIZE		 14	  ""  - RTS SIZE IN K WORDS   &
	!	     "" 		 16		""		      &
	!	   R.DATA1		 18	FUN/FBN OF THE RTS	      &
	!	   R.DATA2		 20				      &
	!	   R.FILE1		 22	NE OFFSET/2, FBN OF FILE DATA &
	!	   R.FILE2		 24				      &
	!	   R.CNT		 26	ATTACH/MAP COUNTS	      &
	!	L.PROT - L.STAT		 28	PROT CODE - STATUS	      &
	!	   R.FLAG		 30	LIB FLAGS		      &
	!								      &
	!	R.FLAG BITS:						      &
	!	BIT	MEANING						      &
	!	0-8	MEANINGLESS					      &
	!	 9	ONLY 1 USER					      &
	!	10	MAP RTS READ/WRITE				      &
	!	11	DONT' LOG ERRORS				      &
	!	12	UNCONDITIONAL REMOVE				      &
	!	13	MEANINGLESS					      &
	!	14	SAVE THE LOAD ADDRESS (M.PHYA) (ALWAYS SET)	      &
	!	15	MEANINGLESS					      &
	!								      &
	!	L.STAT BITS:						      &
	!	BIT	MEANING						      &
	!	0-6	(LS.DYN) DYNAMIC REGION BLOCK			      &
	!	 7	(LS.LIB) RESIDENT LIBRARY BLOCK			      &

10820	J%=M2%(15%)+2%							      &
	\ PRINT #O%,C$;"Resident Libraries:";				      &
	\ HD%=0%							      &
	! GET ROOT OF LIBRARY DESC. BLOCKS (LIBLST), WHICH IS RTSLST+2.	      &

10830	J%=PEEK(J%)							      &
	\ GOTO 10850 IF J%=0%						      &
	\ IF PEEK(J%+2%)=0% THEN					      &
		GOTO 10830						      &
	  ELSE								      &
		PRINT #O%, C$;" Name";TAB(7%);"Prot";TAB(19%);"Acct";	      &
	  	TAB(29%);"Size";TAB(35%);"Users";TAB(42%);"Comments" UNLESS HD% &
		\ HD%=-1%						      &
		\ C%=PEEK(J%+26%)					      &
		\ J2%=PEEK(J%+14%)					      &
		\ F%=PEEK(J%+30%)					      &
		\ PPN%=PEEK(J%+6%)					      &
		\ PPROG$=NUM1$(PPN% AND 255%)				      &
		\ IF (PEEK(J%+28%) AND 64%) = 0% THEN			      &
			PRINT #O%,RAD$(PEEK(J%+2%));RAD$(PEEK(J%+4%));	      &
			TAB(7%);"<";FNN$(3%,(SWAP%(PEEK(J%+28%)) AND 255%));">"; &
			TAB(14%)+FNACCOUNT$(M2%(21%),PEEK(J%+18%),PEEK(J%+6%)); &
			TAB(29%)+FNN$(3%,(J2% AND 255%))+"K";		      &
			TAB(35%)+FNN$(3%,(C% AND 255%));		      &
		  ELSE							      &
		 	PRINT #O%,RAD$(PEEK(J%+2%));RAD$(PEEK(J%+4%));	      &
			TAB(7%);"<";FNN$(3%,(SWAP%(PEEK(J%+28%)) AND 255%));">"; &
			TAB(18%);"[";FNN$(3%,SWAP%(PPN%) AND 255%);",";PPROG$; &
				SPACE$(3%-LEN(PPROG$));"]";		      &
			TAB(29%)+FNN$(3%,(J2% AND 255%))+"K";		      &
			TAB(35%)+FNN$(3%,(C% AND 255%));		      &
		! Determine if dynamic region or library		      &

10835 	IF (J2% AND -256%)=512% THEN					      &
		S$="Non-Res"						      &
	ELSE	IF (J2% AND 1024%)<>0% THEN				      &
			S$="Loading"					      &
		ELSE		S$="Temp"				      &
		\		S$="Perm" IF C%<0%			      &

10840	T%=FNSHFT.RGT%(PEEK(J%+16%),5%)					      &
	\ S$=S$+", Addr:"+NUM1$(T%) IF T%<>0%				      &
	\ IF (PEEK(J%+28%)AND 64%) <> 0% THEN				      &
		F% = F% AND 512%					      &

10845	S$=S$+MID(", 1US, R/W, NER, Rem",(I%-9%)*5%+1%,5%) IF		      &
			(F% AND 2%^I%)<>0% FOR I%=9% TO 12%		      &
	\ PRINT #O%,TAB(42%);S$						      &
	\ GOTO 10830							      &

10850	PRINT #O%," None" UNLESS HD%					      &
		! WERE THERE ANY RESIDENT LIBRARIES?			      &

10860	RETURN								      &
	! C%=R.CNT, J2%=M.CTRL (HI) - R.KSIZ (LO), F%=R.FLAG		      &
	! WE ARE LOOKING AT A RESIDENT LIBRARY (RL) DESCRIPTOR BLOCK (RDB).   &
	! SKIP ALL UNNAMED DYNAMIC REGIONS.				      &
	! PRINT THE RL NAME (R.NAME),					      &
	! THE ASSOCIATED PROTECTION (L.PROT), THE ASSOCIATED PPN (L.PPN),     &
	!  AND THE SIZE OF THE MODULE IN K (R.KSIZ)			      &
	!								      &
	! PRINT THE COUNT OF USERS EXECUTING UNDER THE RL (R.CNT).	      &
	! PRINT LOAD ADDRESS.						      &
	! EXAMINE M.CTRL AND DETERMINE THE CURRENT STATE OF THE RL.	      &
	! CONTINUE IF WE HAVEN'T REACHED THE END (0) OF THE LINKED LIST	      &
	! OF RL DESC. BLOCKS.						      &
									      &

13700	!								      &
									      &
									      &
	!	M E M O R Y    A L L O C A T I O N			      &
									      &
									      &

13710	J%=M%(9%)							      &
	\ NJ%=PEEK(J%+2%)						      &
	\ T$,S0$=""							      &
	\ I%,J2%=0%							      &
	\ PRINT #O%							      &
	\ PRINT #O%, "Memory allocation table:"				      &
	\ PRINT #O%, " Start   End  Length  Permanent   Temporary"	      &
	\ GOSUB 13800							      &
		! GET THE ROOT OF THE MEMLST LIST.			      &
		! INITIALIZE T$ AND S$ FOR PRINTING RESULTS.		      &
		! INITIALIZE FOR PEEKING THROUGH LISTS.			      &
		! PRINT HEADER.						      &
		! CHECK FOR VIRTUAL DISK				      &

13720	IF (J% AND 8%+16%)=0% THEN					      &
		SIZE%(I%)=(PEEK(J%+6%) AND 255%)+SWAP%(J% AND 6%)	      &
	\	T3%=PEEK(J%+8%)						      &
	\	LOC%(I%)=FNSHFT.RGT%(T3%,5%)				      &
	\	GOSUB 13785						      &
	\	I%=I%+1%						      &
		! GO THROUGH THE MEMORY LIST.				      &
		! WE ARE ONLY LOOKING FOR THE MONITOR, XBUF,		      &
		!	LOCKED OUT OR NON-EXISTANT MEMORY.		      &

13730	J%=NJ%								      &
	\ NJ%=PEEK(NJ%+2%) IF J%					      &
	\ GOTO 13720 IF J%						      &
	\ I%=I%-1%							      &
	\ T2%,J4%=LOC%(I%)						      &
		! GET NEXT ITEM IN MEMLST.				      &
		! CONTINUE IF THERE IS STILL MORE IN THE LIST.		      &
		! GET THE ADDRESS OF THE END OF MEMORY.			      &
	\ J%=M2%(15%)							      &
	\ J1%=I%							      &
		! INITIALIZE FOR RTS LIST SEARCH.			      &
		! REMEMBER WHERE THE RTS'S BEGIN.			      &

13740	J%=PEEK(J%)							      &
	\ IF J% THEN							      &
		I1%=PEEK(J%+26%)					      &
	\	GOTO 13740 UNLESS (PEEK(J%+30%) AND 16384%) OR I1%<0%	      &
	\	T3%=PEEK(J%+16%)					      &
	\	LOC%(I%)=FNSHFT.RGT%(T3%,5%)				      &
	\	SIZE%(I%)=(PEEK(J%+14%) AND 255%)+(I1% AND -256%)	      &
	\	NAM%(I%)=J%+2%						      &
	\	I%=I%+1%						      &
	\	GOTO 13740						      &
		! GET NEXT RTS OR LIB IN LINKED RTSLST OR LIBLST.	      &
		! SKIP IT IF ADDRESS NOT FIXED AND NOT PERMANENT.	      &
		! GET SIZE AND POINTER TO NAME.				      &
		! CONTINUE.						      &

13750	J3%=I%-1%							      &
	\ IF J2%=0% THEN						      &
		J2%=I%							      &
	\	J%=M2%(15%)+2%						      &
	\	GOTO 13740						      &
		! MARK THE END OF WHAT WE'VE PEEKED AT SO FAR.		      &
		! IF WE HAVEN'T ALREADY GOTTEN INFO ON RES LIBS,	      &
		! MARK THE END OF RTS'S AND GO GET THEM.		      &

13760	FOR I%=0% TO J3%						      &
	\   J5%=LOC%(I%)						      &
	\   J4%=J5% IF J5%<J4% AND J5%>J%				      &
	\   J6%=LOC%(I%)+(SIZE%(I%) AND 255%)+SIZE2%(I%)		      &
	\   J4%=J6% IF J6%<J4% AND J6%>J%				      &
	\   IF J5%<=J% AND J6%>J% THEN					      &
		IF I%<J1% THEN						      &
		T$=MID("MONITOR   ** XBUF **Locked out   NXM   ",	      &
			(SWAP%(SIZE%(I%)) AND 255%)*5%+1%,10%)		      &
		ELSE							      &
			S$=RAD$(PEEK(NAM%(I%)))+RAD$(PEEK(NAM%(I%)+2%))	      &
	\		S$=S$+" RTS" IF I%<J2%				      &
	\		S$=S$+" DYN" IF (PEEK(NAM%(I%)+26%)AND 192%) = 192%   &
	\		S$=S$+" LIB" IF (PEEK(NAM%(I%)+26%)AND 192%) = 128%   &
	\		IF SIZE%(I%)<0% THEN				      &
				T$=S$					      &
			ELSE	S0$=S0$+", "+S$				      &
		! FIND OUT HOW FAR FROM MEMORY J% WE CAN GO BEFORE	      &
		! SOMETHING CHANGES - EITHER WE RUN OUT OF SOME SECTION	      &
		! WE ARE IN OR WE ENCOUNTER A NEW MEMORY ENTITY.	      &
		! PUT PERMANENTLY ALLOCATED LABEL IN T$ (IF ANY),	      &
		! AND COMPILE S$ WITH ANY NAMES OF RTS'S OR LIB'S THAT	      &
		! ARE ADDED AT AN ADDRESS BUT NOT PERMANENTLY RESIDENT.	      &

13770	NEXT I%								      &
	\ T$="  (User)  " UNLESS LEN(T$)				      &
	\ VDISK%=0%							      &
	\ VDISK%=-1% IF (VSTAR%=J%) AND (VSTAT%>0%)			      &
	\ T$="Virtual Disk" IF VDISK%					      &
	\ SEG%=J4%-J%							      &
	\ J4%=J4%-(SEG%-VSIZE%) IF VDISK%				      &
	\ PRINT #O%, FNN$(4%,J%);"K - ";FNN$(4%,J4%-1%);"K (";		      &
		FNN$(4%,J4%-J%);"K) ";T$;" ";RIGHT(S0$,2%)		      &
	\ IF J4%>=T2% THEN						      &
		PRINT #O%, FNN$(4%,J4%);"K -  *** END ***"		      &
	  ELSE	J%=J4%							      &
	\	J4%=T2%							      &
	\	T$,S0$=""						      &
	\	GOTO 13760						      &
		! PRINT OUT THE ALLOCATION BETWEEN J% K AND J4% K.	      &
		! IF THIS IS THE LAST THING IN MEMORY, END THE LIST.	      &
		! IF NOT, GO BACK AND SEE WHAT THE NEXT SEGMENT IS.	      &

13780	RETURN								      &

13785	IF ((NJ% AND 8%+16%)=0%) AND					      &
		((J% AND 6%) = (NJ% AND 6%)) AND (J% AND 6%)<>0% THEN	      &
		SIZE2%(I%)=SIZE2%(I%)+(PEEK(NJ%+6%) AND 255%)		      &
	\ NJ%=PEEK(NJ%+2%)						      &
	\ GOTO 13785 IF NJ%						      &
		! LOOK TO SEE IF THIS SEGMENT IS GREATER THAN 127K, IF IT     &
		! IS APPEND ANY NUMBER OF EXTRA SEGMENTS		      &

13795	RETURN								      &
		! RETURN FROM LISTING MEMORY ALLOCATION TABLE.		      &

13800	DV%=ASCII("D")+ASCII("V")*256%					      &
	\ INDEX%=0%							      &
		! INDEX INTO MONITOR TABLES SET TO ZERO			      &

13810	DEV%=PEEK(M2%(5%)+INDEX%)					      &
	\ IF DEV%=-1% THEN GOTO 13840					      &
		! END OF THE LIST?					      &

13820	IF DEV%<>DV% THEN INDEX%=INDEX%+2%				      &
	\ GOTO 13810							      &

13830	VSTAT%=PEEK(M%(19%)+INDEX%)					      &
	\ IF VSTAT%>=0% THEN FREE%=PEEK(M%(21%)+INDEX%)			      &
	\  VSTAR%=PEEK(M2%(7%)+INDEX%)					      &
	\  VSTAR% = VSTAR%+2048% IF VSTAR% < 0%				      &
	\  VSIZE%=(PEEK(M%(17%)+INDEX%) AND 255%)*			      &
		  (PEEK(M3%(7%)+INDEX%)+1%)+1%				      &
	\  VSIZE%=INT((VSIZE%/4.0)+.9999)				      &
		! IF IT'S MOUNTED GET FREE SPACE, START ADDRESS, TOTAL SIZE   &

13840	RETURN								      &

14000	!								      &
									      &
									      &
	!	T I M E -    D D D   H H : M M : S S . S		      &
									      &
									      &
	!	c1%=1% for HH:MM:SS					      &
	!	c1%=0% for DDD HH:MM:SS					      &

14010	S$=""								      &
	\ T%=0%								      &
	\ GOTO 14060 IF T<0. OR T>359999. if c1%=1%			      &
	\ goto 14060 if t<0. or t>63158399. if c1%=0%			      &
	\ goto 14015 if c1%=1%						      &
	! CLEAR STRING TO BE RETURNED AND INITIALIZE			      &
	! MAKE SURE TIME IS WITHIN ALLOWABLE RANGE (< 100 HRS).		      &
	! or < 730D 23H:59M:59S  (This is two full years)		      &

14012	t1%=t/86400.							      &
	\ if t1%<>0% then						      &
		t=t-86400.*t1%						      &
	\	gosub 14040						      &
	\	s$=s$+" "						      &
	! t1%= # of days - subtract from total if non-zero		      &

14015	T1%=T/3600.							      &
	\ IF (T1% or t%)<>0% THEN					      &
		T=T-3600.*T1%						      &
	\	GOSUB 14040						      &
	\	S$=S$+":"						      &
	! T1%= # OF HOURS - SUBTRACT FROM TOTAL IF NON-ZERO		      &

14020	T1%=T/60%							      &
	\ IF (T1% OR T%)<>0% THEN					      &
		T=T-60%*T1%						      &
	\	GOSUB 14040						      &
	\	S$=S$+":"						      &
	! NOW T1%= # OF MINUTES - SUBTRACT FROM TOTAL IF NON-ZERO AND	      &
	! TACK ON TO STRING						      &

14030	T1%=T								      &
	! PREPARE TO GET SECONDS.TENTHS OF SEC.				      &

14040	T$=NUM$(T1%+T%*100%)						      &
	\ S$=S$+MID(T$,2%+T%,LEN(T$)-2%-T%)				      &
	\ T%=1%								      &
	! TACK THIS PART ONTO THE STRING				      &

14050	RETURN								      &
									      &

14060	S$="??:??:??"							      &
	\ s$="??? "+s$ if c1%=0%					      &
	\ GOTO 14050							      &
	! COULDN'T CONVERT THE NUMBER.					      &

15000	!								      &
									      &
									      &
	!	F U N C T I O N S					      &
									      &
									      &

15100	DEF* FNF$							      &
	! FUNCTION	FNF$		SET UP A 6 CHARACTER		      &
	!				STRING TO BE USED AS A		      &
	!				FILENAME			      &

15110	S0$=DATE$(0%)							      &
	\ C%=(INSTR(1%,"JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC",		      &
	     CVT$$(MID(S0$,4%,3%),32%))+2%)/3%				      &
	\ S0$=CHR$(64%+C%)+LEFT(S0$,2%)					      &
	\ T%=TIME(0%)/60%						      &
	\ S0$=S0$+CHR$(65%+T%/60%)+					      &
	      RIGHT(NUM1$(100%+T%-(T%/60%)*60%),2%)			      &
	! GET THE CURRENT DATE.						      &
	! GET THE MONTH # (JAN=1,...,DEC=12).				      &
	! FORM A 3 CHARACTER STRING CONSISTING OF			      &
	! THE MONTH # MAPPED INTO A LETTER (1=A,...,12=L)		      &
	! + THE DAY OF THE MONTH.					      &
	! GET THE CLOCK TIME (IN MINUTES) SINCE MIDNIGHT.		      &
	! TACK ON TO THE 1ST STRING ANOTHER 3 CHARACTER STRING		      &
	! CONSISTING OF THE # OF HOURS SINCE MIDNIGHT MAPPED		      &
	! INTO A LETTER (0=A,...,23=X) + THE # OF 'LEFTOVER'		      &
	! MINUTES SINCE MIDNIGHT (FORCE THIS TO 2 DIGITS).		      &

15120	FNF$=S0$							      &
	! SET THE FUNCTION						      &

15130	FNEND								      &

15140	DEF* FNN$(S%,N%)						      &
	! FUNCTION	FNN$	TURN N% INTO A STRING AND LEFT PAD	      &
	!			THE STRING WITH SPACES			      &

15150	S$=NUM1$((N% EQV 32767%)+32768.)				      &
	\ FNN$=FNS$(S%)							      &
	! GET THE STRING (MAKE SURE IT'S POSITIVE) AND LEFT PAD IT.	      &

15160	FNEND								      &

15170	DEF* FNS%(C$)							      &
	! FUNCTION	FNS%	EXTRACT STRING C$ FROM S$		      &

15180	J0%,FNS%=INSTR(1%,S$,C$)					      &
	\ S$=LEFT(S$,J0%-1%)+RIGHT(S$,J0%+1%) IF J0%<>0%		      &
	! SEE IF C$ APPEARS IN S$.					      &
	! IF SO, EXTRACT IT FROM S$.					      &

15190	FNEND								      &

15200	DEF* FNS$(S%)=SPACE$(S%-LEN(S$))+S$				      &
	! LEFT PAD A STRING						      &
									      &

15210	DEF* FNT1%							      &
	! FUNCTION	FNT1%		SET UP 'MONITOR			      &
	!				TABLES ARRAYS' AND		      &
	!				DETERMINE IF LOGINS		      &
	!				ARE DISABLED			      &
	! RETURNS	FNT1%		0=ENABLED			      &
	!				1=DISABLED			      &

15220	CHANGE SYS(CHR$(6%)+CHR$(-3%)) TO M%				      &
	\ M%(J%)=M%(J%)+SWAP%(M%(J%+1%)) FOR J%=5% TO 29% STEP 2%	      &
	\ CHANGE SYS(CHR$(6%)+CHR$(-12%)) TO M2%			      &
	\ M2%(J%)=M2%(J%)+SWAP%(M2%(J%+1%)) FOR J%=3% TO 29% STEP 2%	      &
	\ S0$=SYS(CHR$(6%)+CHR$(-21%)+CHR$(-1%))			      &
	\ PRIV.SYSIO% = FNPRIV%("SYSIO")				      &
	\ PRIV.TUNE% = FNPRIV%("TUNE")					      &
	\ PRIV.WREAD% = FNPRIV%("WREAD")				      &
	\ PRIV.GREAD% = FNPRIV%("GREAD")				      &
	\ PRIV.HWCTL% = FNPRIV%("HWCTL")				      &
	\ S0$=SYS(CHR$(6%)+CHR$(-21%)+CHR$(0%))				      &
	\ CHANGE SYS(CHR$(6%)+CHR$(-29%)) TO M3%			      &
	\ M3%(J%)=M3%(J%)+SWAP%(M3%(J%+1%)) FOR J%=3% TO 29% STEP 2%	      &
	\ C$=CHR$(13%)+CHR$(10%)					      &
	\ FNT1%=((SWAP%(PEEK(M2%(13%))) AND 255%)=1%)			      &
	\ CSRTBL%=M2%(7%)						      &
		! then get the address of CSRTBL			      &
	\ DEVOKB%=M2%(9%)						      &
		! (Number of disk devices on system) * 2		      &
	\ DDBPTR%=CSRTBL%+DEVOKB%/2%					      &
		! Points to 1st CSR entry for KB's.  For PK's, the CSR	      &
		! table contains the address of the KB's DDB rather	      &
		! than a physical CSR address, so we can get the PK	      &
		! KB's DDB from that.					      &
	! SET UP THE ARRAYS						      &
	! M%()	MONITOR TABLES PART I					      &
	! M2%()	MONITOR TABLES PART II					      &
	! M3%() MONITOR TABLES PART III					      &
	! PRIV.SYSIO%	-1 User has SYSIO privilege			      &
	!		 0 User does not have SYSIO privilege		      &
	! PRIV.TUNE%	-1 User has TUNE privilege			      &
	!		 0 User does not have TUNE privilege		      &
	! PRIV.WREAD%	-1 User has WREAD privilege			      &
	!		 0 User does not have WREAD privilege		      &
	!								      &
	! SET THE FUNCTION VALUE TO SIGNAL WHETHER			      &
	! OR NOT LOGINS ARE ENABLED					      &
	! -1	SIGNALS DISABLED					      &
	! 0	SIGNALS ENABLED
15230	FNEND								      &

15250	DEF* FNT3%(DDIDX%)						      &
	!								      &
	! FUNCTION GETS POINTERS INTO UCCTBL AND DDCTBL			      &
	!								      &
	! INPUTS	DDIDX%	= DRIVER INDEX				      &
	!								      &
	! RETURNS	DDCTBL%	= POINTER INTO THE DDCTBL ENTRY		      &
	!		UCTTBL%	= POINTER INTO THE UCTTBL		      &
	!		CNTRLR.MAX% = NUMBER OF CONTROLLERS		      &
	!								      &
	! NO ERRORS POSSIBLE						      &
	!								      &

15260	DDCTBL% = M3%(3%)						      &
	\ UCTTBL% = M3%(5%)						      &
	\ I% = PEEK(DDCTBL%+DDIDX%)					      &
	\ OFFSET% = SWAP%(I%) AND 255%					      &
	\ CNTRLR.MAX% = I% AND 255%					      &
	\ UCTTBL% = UCTTBL%+OFFSET%					      &
	!								      &
	! GET THE OFFSET INTO THE UCTTBL AND THE NUMBER OF CONTROLLERS	      &
	! FROM THE DDCTBL TABLE.					      &
	! UPDATE THE UCTTBL POINTER TO POINT TO FIRST UNIT COUNT.	      &
	!								      &

15270	FNEND								      &

15300	DEF* FNSHFT.RGT%(X%,Y%)=					      &
	(X% AND 32767%)/(2%^Y%) OR ((2%^(15%-Y%)) AND (X%<0%))		      &
									      &
	! FUNCTION TO SHIFT RIGHT A 16-BIT INTEGER (X%), BY (Y%) BITS.	      &

15400	DEF* FNDISKSIZE(PACK.CLUSTER.SIZE%,HIGHEST.PCN%,DEVICE.CLUSTER.SIZE%) &
	\ DSIZE = HIGHEST.PCN%						      &
	\ DSIZE = DSIZE+65536. IF DSIZE < 0.				      &
	\ FNDISKSIZE = ((DSIZE+1.)*PACK.CLUSTER.SIZE%)+DEVICE.CLUSTER.SIZE%   &
	\ FNEND								      &
	!								      &
	! FIND THE MAXIMUM USABLE SIZE (IN BLOCKS) FOR A DISK DEVICE	      &
									      &

15450	DEF* FNACCOUNT$(DSKLOG%,FUN%,PPN%)				      &
	\ DSKLOG%=DSKLOG%+((FUN% AND 255%)*10%)				      &
	\ Q$=								      &
	  CVT%$(SWAP%(PEEK(DSKLOG%+6%)))+NUM1$(PEEK(DSKLOG%+8%) AND 255%)+":" &
	\ IF PEEK(J%+28%)AND 64% <> 0% THEN				      &
		IF PPN%<>0% THEN					      &
			P.PROG$=NUM1$(PPN% AND 255%)			      &
		\	Q$=Q$+"["+FNN$(3%,SWAP%(PPN%) AND 255%)+","+	      &
			   P.PROG$+SPACE$(3%-LEN(P.PROG$))+"]"
15455	FNACCOUNT$=Q$							      &
	\ FNEND								      &
		! Format the DEV:[  P,PN  ] display for RTS/LIB		      &
		!	DSKLOG%	= address of DSKLOG table		      &
		!	FUN%	= FIP unit number*2%			      &
		!	PPN%	= <>0% for LIB, =0% for RTS		      &

15500	!								      &
	!	D D C U   F U N C T I O N				      &
	!								      &
	! FUNCTION WILL RETURN THE DDCU STYLE PHYSICAL NAMES FOR	      &
	! COMMUNICATION DEVICES SUCH AS "XM" AND "XD".			      &
	!								      &

15510	DEF FNDDCU$(DEV.TYPE$,UNIT.NO%,DDB.PNTR%)			      &
	\ DDCU$ = "DM"							      &
	\ DDFLAG% = PEEK(DDB.PNTR%+8%)					      &
	\ GOTO 15520 IF DEV.TYPE$ = "XD"				      &
	\ IF DDFLAG% AND 128% THEN					      &
		DDCU$ = DDCU$+"R"					      &
	  ELSE								      &
		DDCU$ = DDCU$+"C"					      &

15515	DDCU$ = DDCU$+"-"+NUM1$(UNIT.NO%)				      &
	\ GOTO 15550							      &
		!							      &
		! SET THE PRINT UNIT NUMBER FLAG OFF.			      &
		! IF IT'S A "XM" DEVICE, I.E., DMC/DMR			      &
		! IF THE 8TH BIT OF THE DDFLAG WORD IS			      &
		! SET MAKE THE PHYSICAL NAME DMR OTHERWISE		      &
		! IT'S A DMC.						      &
		! ADD THE UNIT NUMBER.					      &
		!							      &

15520	IF DDFLAG% AND 128% THEN					      &
		DDCU$ = DDCU$+"V"					      &
	  ELSE								      &
		DDCU$ = DDCU$+"P"					      &
	!								      &
	! GET DDFLAG WORD OUT OF THE DDB.				      &
	! IF THE 8TH BIT IS SET WE HAVE A DMV				      &
	! OTHERWISE IT'S A DMP.						      &
	!								      &

15530	UNIT.CNT% = 0%							      &
	\ FOR CNTRLR.NO% = 0% TO CNTRLR.MAX%-1%				      &
	\	I% = PEEK(UCTTBL%+(CNTRLR.NO%*2%))			      &
	\	IF (UNIT.CNT%+(I%-1%)) < UNIT.NO% THEN			      &
			UNIT.CNT% = UNIT.CNT%+I%			      &
		ELSE							      &
			DDCU$ = DDCU$+"-"+NUM1$(CNTRLR.NO%)+"."+	      &
				NUM1$(UNIT.NO%-UNIT.CNT%)		      &
	\		GOTO 15550
15540	NEXT CNTRLR.NO%							      &
	\ DDCU$ = DEV.TYPE$+NUM1$(UNIT.NO%)				      &
		!							      &
		! SKIP THE CONTROLLER #+UNIT # SEARCH IF NO UNIT	      &
		! NUMBER WAS SUPPLIED.					      &
		! GET UNIT NUMBER AND INITIALIZE UNIT COUNT.		      &
		! OBTAIN POINTERS TO THE DDCTBL AND UCTTBL TABLES.	      &
		! FIND THE OFFSET INTO THE UCTTBL TABLE WHERE WE CAN	      &
		! GET THE NUMBER OF UNITS FOR EACH CONTROLLER OF THIS	      &
		! TYPE.							      &
		! GET THE NUMBER OF UNITS FOR CONTROLLER CNTRLR.NO%.	      &
		! IF THE ACCUMULATED NUMBER OF UNITS+THE NUMBER OF UNITS      &
		! FOR THIS CONTROLLER IS LESS THAN THE UNIT NUMBER THEN	      &
		!	ADD THE NUMBER OF UNITS TO THE ACCUMULATED TOTAL      &
		!	AND TRY AGAIN.					      &
		! ELSE							      &
		!	FORM THE DDCU STYLE NAME USING THE CONTROLLER	      &
		!	NUMBER AND UNIT NUMBER-ACCUMULATED UNIT COUNT.	      &
		!	AND RETURN.					      &
		! IF WE'VE REACHED THE END OF THE LINE AND HAVE YET TO	      &
		! TO EXCEED OR EQUAL THE UNIT NUMBER SOMETHING IS WRONG.      &
		! RETURN AT LEAST THE OLD FORM OF PHYSICAL NAME AND SET	      &
		! THE PRINT UNIT NUMBER FLAG ON.			      &
		!							      &

15550	FNDDCU$ = DDCU$+STRING$(12%-LEN(DDCU$),32%)			      &
	\ FNEND								      &

16000	DEF* FNPRINT.CMNTS$(CHNL%,START.POS%,STRNG$)			      &
	!								      &
	!								      &
	! This function is called by the disk structure routine to print      &
	! the comment section. It outputs the text on the channel specified   &
	! by CHNL% starting at the position indicated by START.POS%. Elements &
	! of the string passed must be seperated by ",".		      &
	!								      &
	!								      &
	\ IF KB.WIDTH% = 0% THEN					      &
		TMP$ = SYS(CHR$(6%)+CHR$(16%)+CHR$(0%)+CHR$(255%))	      &
	\	KB.WIDTH% = ASCII(MID(TMP$,5%,1%)) - 1%			      &
	! If don't know KB width yet,					      &
	!	Get terminal characteristics				      &
	!	Save terminal width					      &

16010	CUR.POS%=START.POS%						      &
	\ UNTIL LEN(STRNG$)=0%						      &
	\	COMMA%=INSTR(1%,STRNG$,",")				      &
	\	COMMA%=LEN(STRNG$)+1% UNLESS COMMA%			      &
	\	SUB.STRNG$=CVT$$(LEFT(STRNG$,COMMA%-1%),156%)		      &
	\	STRNG$=RIGHT(STRNG$,COMMA%+1%)				      &
	\	IF CUR.POS%+LEN(SUB.STRNG$)+2% > KB.WIDTH% THEN		      &
			PRINT #CHNL%					      &
	\		CUR.POS%=START.POS%				      &
	!								      &
	! Set the current print position to the specified start position      &
	! Until all text has been processed				      &
	!	Find the seperator "," or set pointer to the end of the	      &
	!	  text if none is found					      &
	!	Parse out the sub string and string remainder		      &
	!	If we're about to reach the end of the line then	      &
	!		Advance to the next line and reset our current	      &
	!		 print position to the start positon		      &

16030		SUB.STRNG$ = ", "+SUB.STRNG$				      &
			UNLESS CUR.POS% = START.POS%			      &
	\	PRINT #CHNL%,TAB(CUR.POS%);SUB.STRNG$;			      &
	\	CUR.POS%=CUR.POS%+LEN(SUB.STRNG$)			      &
	\ NEXT								      &
	\ FNEND								      &
	!								      &
	!	Prefix with ", " unless at start position		      &
	!	Print the text and adjust the current position pointer	      &
	! Continue until all text has been displayed			      &
	! Return to caller						      &

17000	DEF* FNSWTCH.PRS$(STRING.$,SWITCH$)				      &
	!								      &
	!								      &
	! NOTE:		THIS FUNCTION IS RESERVED FOR FUTURE USE ONLY.	      &
	!								      &
	!								      &
	! FUNCTION	FNSWTCH.PRS$	 SEARCHES THROUGH STRING.$ LOOKING    &
	!				 FOR A MATCH FOR SWITCH$.	      &
	!								      &
	! PARAMETERS	STRING.$	STRING TO SCAN.			      &
	!		SWITCH$		SWITCH WE'RE SCANNING FOR.	      &
	!								      &
	! RETURNS	FNSWTCH.PRS$	IF NO MATCH IS FOUND, THEN A NULL IS  &
	!				RETURNED.			      &
	!				OTHERWISE THE VALUE OF THE SWITCH IS  &
	!				RETURNED IF AN EQUAL SIGN IS FOUND.   &
	!				OTHERWISE THE SWITCH ITSELF, WITHOUT  &
	!				THE "/", IS RETURNED.		      &
	!								      &

17010	FNSWTCH.PRS$=NL$						      &
	\ SWITCH$="/"+SWITCH$ UNLESS INSTR(1%,SWITCH$,"/")		      &
	\ MATCH%=INSTR(1%,STRING.$,SWITCH$)				      &
	\ GOTO 17020 UNLESS MATCH%					      &
	\ SLASH%=INSTR(MATCH%+1%,STRING.$,"/")				      &
	\ SLASH%=LEN(STRING.$)+1% UNLESS SLASH%				      &
	\ FIELD.$=MID(STRING.$,MATCH%+1%,(SLASH%-MATCH%)-1%)		      &
	\ EQUAL%=INSTR(1%,FIELD.$,"=")					      &
	\ IF EQUAL% THEN						      &
		FNSWTCH.PRS$=RIGHT(FIELD.$,EQUAL%+1%)			      &
	  ELSE								      &
		FNSWTCH.PRS$=FIELD.$					      &
		!							      &
		! INITIALIZE THE RETURNED VALUE TO NULL.		      &
		! LOOK FOR THE SWITCH IN STRING.$.			      &
		! EXIT IF THE SWITCH WAS NOT FOUND.			      &
		! EXTRACT THE SWITCH AND ITS POSSIBLE VALUE		      &
		! FROM THE STRING.					      &
		! IF THERE'S A "=" THEN					      &
		!	RETURN THE VALUE OF THE SWITCH.			      &
		! ELSE							      &
		!	RETURN THE SWITCH ITSELF WITHOUT THE "/".	      &
		!							      &

17020	FNEND								      &

17100	DEF* FNPRIV%(PRIV$) =						      &
		(ASCII(MID(SYS(CHR$(6%)+CHR$(32%)+CHR$(1%)+		      &
		STRING$(3%,0%)+PRIV$),3%,1%)) = 0%)			      &
		! FUNCTION TO DETERMINE IF USER HAS PRIV 'PRIV$'	      &
		! RETURNS -1% IF USER HAS PRIV, ELSE RETURNS 0%		      &

19000	!								      &
									      &
									      &
	!	E R R O R    H A N D L I N G				      &
									      &
									      &

19010	E%=ERR								      &
	\ RESUME 32765 IF ERR = 11% AND ERL = 1040			      &
	\ RESUME 10020 IF ERR = 10% AND ERL = 10020			      &
	\ RESUME 10140 IF ERR = 18% AND ERL = 10020			      &
	\ RESUME 10052 IF ERL=10050					      &
	\ RESUME 1160 IF ERL=1065 ! ERROR MESSAGE IF ANY JOB # ERROR	      &
	\ IF ERL = 10715 THEN						      &
		NSP% = -1%						      &
	\	RESUME 10720						      &
	!								      &
	! IF DECNET IS NOT PRESENT THEN					      &
	!	SET THE NSP FLAG TO INDICATE WE'VE DONE IT		      &
	!	AND RESUME TO PRINT THE MESSAGE TABLE.			      &
	!								      &

19015	RESUME 19020 UNLESS E%=33% AND					      &
		(ERL=10090% OR						      &
		 (ERL>=10625% AND ERL<=10650%))				      &
	\ S$="??"							      &
	\ RESUME 10110 IF ERL=10090%					      &
	\ PRINT #O%;TAB(6%); IF ERL=10635%				      &
	\ PRINT #O%;S$							      &
	\ RESUME 10670							      &
	! SAVE ERROR VALUE ON SYSTEM TRAPPED ERROR.			      &
	! WILL TRY TO CONTINUE IF WE HAD A ODD ADDRESS ERROR WHEN	      &
	! TRYING TO GET THE HANDLER INDEX (CHANNEL # WAS >30) OR	      &
	! DURING OPEN FILE ROUTINE.					      &

19020	GOTO 32765 IF E9%						      &
	\ E9%=-1%							      &
	\ E$=""								      &
	\ E%=52% IF ERL=1060%						      &
	\ E$="Illegal Option or Argument" IF E%=52% OR E%=512%+52%	      &
	\ E$="HWCTL privilege required" IF E% = 512% + 10%		      &
	\ E$=CVT$$(RIGHT(SYS(CHR$(6%)+CHR$(9%)+CHR$(E%)),4%),4%)	      &
		IF E$=""						      &
	\ E$=E$+" - "+T$ IF ERL=1200%					      &
	\ PRINT								      &
	\ PRINT "?";E$							      &
	\ PRINT								      &
	\ E%=0%								      &
	\ GOTO 1300							      &
	! EXIT IF A PREVIOUS ERROR WAS ENCOUNTERED.			      &
	! SET THE 'ERROR ENCOUNTERED' FLAG.				      &
	! SET UP ERROR MESSAGES.					      &
	! TACK ON SPECIAL INFO (ONLY 1 TO DATE, FILENAME).		      &
	! PRINT AND GO AND GET OUT.					      &
	!								      &
	! ** ALL ERRORS ARE FATAL, HENCE THE FORCED '?' **		      &
									      &

30000	!								      &
									      &
									      &
	!	C C L    E N T R Y					      &
									      &
									      &

30010	ON ERROR GOTO 19000						      &
	\ E0%=0%							      &
	\ S$=CVT$$(SYS(CHR$(7%)),4%+8%+16%+32%+128%+256%)		      &
	\ FOR J%=6% TO 1% STEP -1%					      &
	\	IF LEFT(S$,J%)=LEFT("SYSTAT",J%) THEN			      &
			S$=CVT$$(RIGHT(S$,J%+1%),8%)			      &
	\		GOTO   30040					      &
	! SET FLAG TO INDICATE CCL ENTRY (EQUIVALENT			      &
	! IN THIS PROGRAM TO RUN).					      &
	! GET CORE COMMON STRING AND PEEL OFF ACTUAL COMMAND.		      &
	! REMOVE LEADING SPACES.					      &
	! GOTO SWITCH PROCESSOR AT THIS POINT				      &

30030	NEXT J%								      &
	\ GOTO 1060							      &
	! END OF LOOP TO MATCH CCL COMMAND AND PEEL OFF			      &
	! SYSTAT COMMAND.						      &

30040	N.EW%=0%							      &
	\ N.EW%=INSTR(1%,S$,"/NEW")					      &
	\ S1$=S$							      &
	\ S$="/"+FNSWTCH.PRS$(S$,"/OPT") IF N.EW%<>0%			      &
	\ T$=FNSWTCH.PRS$(S1$,"/OUT") IF N.EW%<>0%			      &
	\ GOTO 1060							      &
	! DEFINE /NEW.							      &
	! /NEW IS USED FOR DIFFERENT OUTPUT				      &
	! WHEN RUN FROM A MENU.						      &
	! 	THIS SWITCH IS RESERVED FOR FUTURE USE ONLY.		      &

32000	!								      &
									      &
									      &
	!	L O G G E D    O U T    E N T R Y			      &
									      &
									      &

32010	ON ERROR GOTO 19000						      &
	\ E0%=1%							      &
	\ O%=0%								      &
	\ S$=CVT$$(SYS(CHR$(7%)),-2%)					      &
	\ GOTO 1160 UNLESS ASCII(S$)=47% OR S$=""			      &
	\ GOTO 1060							      &
	! FLAG AS LOGGED OUT RUN					      &
	! FORCE OUTPUT TO THE USER'S KB.				      &
	! GET THE CORE COMMON STRING.					      &
	! SLASH MUST BE PRESENT - FILESPEC IS ILLEGAL.			      &
	! JUMP TO SWITCH PROCESSING ROUTINE				      &

32765	S$=SYS(CHR$(9%))						      &

32767	END
