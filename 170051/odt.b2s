5!		VERSION		: V10.1
6!		EDIT		: J
7!		EDIT DATE	: 27-MAR-92
8!		AUTHORS		: KCG/JFM/SEL/DBM
10		EXTEND
11	!								      &
									      &
									      &
	!		  C O P Y R I G H T				      &
									      &
									      &
  !		      Copyright (C) 1974, 1992 by			      &
  !	        Digital Equipment Corporation, Maynard, Mass.		      &
  !									      &
  !									      &
  !	This software is furnished under a license and may be used and	      &
  !	copied  only  in accordance with the terms of such license and	      &
  !	with the  inclusion  of  the  above  copyright  notice.   This	      &
  !	software  or  any  other copies thereof may not be provided or	      &
  !	otherwise made available to any other person.  No title to and	      &
  !	ownership of the software is hereby transferred.		      &
  !									      &
  !	The information in this software is subject to change  without	      &
  !	notice  and should not be construed as a commitment by Digital	      &
  !	Equipment Corporation.						      &
  !									      &
  !	DIGITAL assumes no responsibility for the use  or  reliability	      &
  !	of its software on equipment that is not supplied by DIGITAL.	      &
  !									      &
  !*******************************************************************	      &
									      &
									      &
									      &
									      &

20	!								      &
									      &
	!	M O D I F I C A T I O N    H I S T O R Y		      &
									      &
									      &
	! VER/ED	EDIT DATE	REASON				      &
	!								      &
	! 9/12   KCG	18-Feb-85	Comment out BP2 bug at line 1080.     &
	! 9.4    KCG	17-Dec-86	Made conversion from real to integer  &
	!				correct (V%=H) at line 10070.	      &
	! 10.0-J JFM	22-Mar-90	Call external routine to make CTRL/J  &
	!				a (multiple) private delimiter.	      &
	!				Renamed program from .BAS to .B2S     &
	! 10.0-L4 SEL	26-Jun-90	Uncomment out the BP2 bug; it's fixed &
	! 10.0-L5 JFM	10-Aug-90	Allow /[NO]WRITE without file name    &
	! 10.0-L6 SEL 	07-Sep-90	Prohibit CTRL/D if accessing memory   &
	! 10.1-B  DBM 	23-May-91	Large disk support		      &
	! 10.1-J  FEK	20-Feb-92	fix >16 bit disk relocation registers &
	!								      &

100	!								      &
									      &
	!	G E N E R A L     D E S C R I P T I O N			      &
									      &
	!								      &
									      &
	!	ODT OPENS A FILE, A PERIPHERAL DEVICE, OR MEMORY AS AN	      &
	!	ADDRESS SPACE AND ALLOWS A USER TO EXAMINE AND CHANGE	      &
	!	WORD OR BYTE LOCATIONS WITHIN THE ADDRESS SPACE. AS	      &
	!	AUXILIARY OPERATIONS, THE USER CAN LIST THE CONTENTS	      &
	!	OF CERTAIN CONVENTIONAL TABLE LOCATIONS IN THE OPERATING      &
	!	SYSTEM. THE PROGRAM IMMEDIATELY INTERPRETS AND EXECUTES	      &
	!	EACH CHARACTER AS THE USER TYPES IT. THE PROGRAM ACCESSES     &
	!	AND MANIPULATES DATA IN WORD AND BYTE LOCATIONS BASED ON      &
	!	OCTAL VALUES. THE WORD IS THE 16-BIT PDP-11 WORD AND CAN      &
	!	HAVE A VALUE BETWEEN 0(OCTAL) AND 177777(OCTAL), THE LIMIT    &
	!	IMPOSED BY 16 BITS. A WORD HAS A HIGH ORDER(ODD ADDRESS)      &
	!	AND A LOW ORDER(EVEN ADDRESS) BYTE. A BYTE CAN HAVE A VALUE   &
	!	BETWEEN 0 (OCTAL) AND 377 (OCTAL) THE LIMIT THAT CAN BE	      &
	!	REPRESENTED BY 8 BITS.					      &
	!								      &
	!	ODT allows 16-bit addresses where examining memory, and	      &
	!	32-bit addresses when examining files or disks.		      &
									      &
									      &

300	!								      &
									      &
	!	I / O     C H A N N E L    L I S T			      &
									      &
	!		CHANNEL #		USED FOR		      &
	!								      &
	!		1			TERMINAL KB: INPUT	      &
	!		2			FILE I/O		      &
	!		3			LINE PRINTER OUTPUT	      &
	!		4			NL: (Buffer for disk block)   &
									      &
									      &
									      &

400	!								      &
									      &
	!	V A R I A B L E    D E F I N I T I O N S		      &
									      &
	!	VARIABLE NAME		USED FOR			      &
									      &
	!		A		LONG value of an address	      &
	!		A%		DECIMAL VALUE OF ADDRESS OR	      &
	!				CONTENTS MODIFIER		      &
	!		A0%		FLAG INDICATING VALUE IN A%(3)	      &
	!		B		LONG value of an address	      &
	!		BUFF.SIZ%		BUFFER SIZE IN BYTES	      &
	!		KB.INP$		KB INPUT CHARACTER STRING	      &
	!		CHAR%		INPUT CHARACTER DECIMAL VALUE	      &
	!		C0%		POSITION IN KB INPUT CHAR STRING      &
	!		USE.CRASH%		CRASH.SYS FILE FLAG (-1)      &
	!		D		LONG VALUE OF ADDRESS		      &
	!				OR CONTENTS MODIFIER		      &
	!		D0		SAME AS D			      &
	!		D0%		BYTE OFFSET IN RECORD		      &
	!		D1		LONG VALUE OF REGISTER OFFSET	      &
	!		D1%		OCTAL DIVISION REMAINDER	      &
	!		D9		TEMPORY D VALUE STORAGE		      &
	!		D9%		TEMPORY ADDRESS STORAGE		      &
	!		E%		END OF FILE FLAG		      &
	!		ERR		CONTAINS VALUE SYSTEM ERROR	      &
	!		F%		MEMORY(0%)/FILE(-1%) FLAG	      &
	!		F0%		F COMMAND FLAG			      &
	!		FBN%		CLUSTER vs BLOCK mode access flag     &
	!		DEV.ACCESS%	Device write access flag	      &
	!		DEV.IS.DISK%	Disk device flag		      &
	!		NFS%		NON-FILE STRUCTURED MODE FLAG	      &
	!		H		Record # for target address	      &
	!		H9		Record # currently buffered	      &
	!		I$		ODT HEADER/INPUT MODE STRING	      &
	!		I0$		Disk device spec with /MODE:128 added &
	!		I%		BLOCK FLAG(0%=EVEN/1%=ODD)	      &
	!		I0%		ARRAY INDEX			      &
	!		L%		ADDRESS OFFSET IN RECORD	      &
	!		L1		UPPER LIMIT FOR LIST COMMAND	      &
	!		L2%		LOWER LIMIT FOR LIST COMMAND	      &
	!		FILE.SIZE.LSB%	File size (Least significant 16 bits) &
	!		FILE.SIZE.MSB%	File siz (Most significant 8 bits)    &
	!		FILE.SIZE	Total size of file		      &
	!		M$		CURRENT COMMAND CHARACTER	      &
	!		M%		EVEN/ODD ADDRESS FLAG		      &
	!		M0%		BYTE(1%)/WORD(2%) FLAG		      &
	!		O%		CHANNEL FLAG			      &
	!		O0%		FORWARD/REVERSE FLAG		      &
	!		P$		STRING VALUE OF MODIFIED CONTENTS     &
	!		P%		INTEGER VALUE OF MODIFIED CONTENTS    &
	!		Q%		CONTENTS OF LAST ADDRESS DISPLAYED    &
	!		R1%, R2%	Temporary address storage	      &
	!		R8%		VALUE OF LAST OFFSET REGISTER	      &
	!				REFERENCED FOR OPENING AN ADDRESS     &
	!		RW.FLG%		R/W FLAG(0%=R/W,1%=RONLY)	      &
	!		RECOUNT		INPUT CHARACTER COUNT		      &
	!		S$		STRING VALUE OF FILE SIZE	      &
	!		STATUS		CHANNEL INFO			      &
	!		S0%, S1%	Flag words from FSS		      &
	!		U		TEMPORARY ADDRESS STORAGE	      &
	!		V		TEMPORARY ADDRESS STORAGE	      &
	!		V%		LSB OF A LONG VALUE		      &
	!		X		LONG ADDRESS VALUE		      &
									      &

800	!								      &
									      &
	!	F U N C T I O N / S U B R O U T I N E      L I S T	      &
									      &
	!	FUNCTION/SUBROUTINE	DESCRIPTION			      &
	!								      &
	!	FND%			BREAKS LOCATION ADDRESS DOWN	      &
	!				INTO RECORD NUMBER AND ADDRESS	      &
	!				WITHIN RECORD			      &
	!								      &
	!	FNA(I0%)		TRANSFORMS TWO INTEGER VALUES	      &
	!				INTO ONE LONG NUMBER		      &
	!								      &
	!	FNL(L%, H%)		TRANSFORM TWO INTEGERS INTO A LONG    &
	!								      &
	!	FNL%(D)			TRANSFORMS ONE LONG		      &
	!				VALUE INTO TWO INTEGER NUMBERS	      &
	!								      &
	!	FNP%(H,L%)		PERFORMS FILE RECORD I/O TO GET	      &
	!				OR MODIFY ADDRESS CONTENTS	      &
	!								      &
	!	UDIV(D, I%)		UNSIGNED 32-BIT BY 15-BIT DIVIDE      &
	!								      &
	!	10010			CALCULATES AND PRINTS OUT REG	      &
	!				AND OFFSET VALUES, AND PRINTS	      &
	!				BLOCK AND ADDRESS IN		      &
	!				BLOCK VALUES			      &
	!								      &
	!	11000			CHANGES BUFFER IF ADDRESS	      &
	!				CONTENTS HAVE BEEN MODIFIED	      &
	!								      &
	!	12000			CONVERTES DECIMAL NUMBER TO AN	      &
	!				OCTAL NUMBER AND PRINTS OCTAL	      &
	!				VALUE				      &
	!								      &
	!	13000			RETRIVES ADDRESS CONTENTS, GETS	      &
	!				RECORD, FIELDS BUFFER		      &
	!								      &
	!	13500			GETS INPUT STRING AND DOES OCTAL      &
	!				TO DECIMAL CONVERSION BEFORE	      &
	!								      &
	!	14000			GETS INPUT CHARACTERS ONE AT A	      &
	!				TIME				      &

900	!								      &
	!	A R R A Y    L I S T					      &
	!	ARRAY			USE				      &
									      &
	!	A%(3)			A% STORAGE			      &
	!	A0%(2)			CONTENT FLAG FOR A%(3) ARRAY	      &
	!	B%(3)			HIGH ORDER PART OF F.P. NUM	      &
	!	R%(15,2)		REGISTER OFFSETS		      &
	!	R0%(15,2)		CONTENT FLAG FOR R%(15,2) ARRAY	      &

910	DIM B%(3%),A%(3%),A0%(2%),R%(15%,2%),R0%(15%,2%)		      &

920	MAP (LNGBUF) LONG LNG		! Buffer to build/disect longwords    &
	\ MAP (LNGBUF) WORD LSB, MSB	! LSB and MSB of longword	      &

980	DECLARE LONG CONSTANT	L.0 = "0"L,				      &
				L.512 = "512"L,				      &
				L.65536 = "65536"L,			      &
				L.MAX = O"17777777777"L,		      &
				L.MSB = O"37777600000"L			      &

990	!Force previous floating point numbers into longwords...
997	DECLARE LONG FUNCTION FNA(WORD), FNL(WORD, WORD), UDIV(LONG, WORD)
998	DECLARE WORD FUNCTION FNP%(LONG, WORD)
999	DECLARE LONG A,B,D,D0,D1,D9,H,H9,L1,R,U,V,X,FILE.SIZE		      &

1000	!								      &
	!	M A I N    C O D I N G    A R E A			      &
	!								      &
	ON ERROR GOTO 19000	! Set up standard error trap		      &
	\ PRINT IF CCPOS(0%)	! Return cursor to left margin		      &
	\ I$="V10.1-J"		! Set up version/edit #			      &
	\ PRIV.OFF$=SYS(CHR$(6%)+CHR$(-21%))				      &
				! Turn off temp privs			      &
	\ CALL SETMUL BY REF	! Set up some (multiple) private delimiters   &

1020	PRINT "ODT	"+I$+CHR$(9%)+					      &
	CVT$$(RIGHT(SYS(CHR$(6%)+CHR$(9%)+CHR$(0%)),3%),4%)		      &
		! PRINT THE SYSTEM HEADER				      &

1030	ON ERROR GOTO 19000						      &
	\ PRINT "Type HELP for help"					      &
	\ PRINT								      &
	\ PRINT "File <MEMORY>";					      &
	\ INPUT LINE I$							      &
		! SET UP ERROR TRAP					      &
		! ASK FOR FILE TO WORK ON				      &

1040	C0%,D,Q%,D9,F%,O%,D9%,USE.CRASH%,R8%,R2%,R1%=0%			      &
	\ H9=1%					! First record is BLOCK 1%    &
	\ FBN%,NFS%=0%				! Assume normal file access   &
	\ BUFF.SIZ%=512%			! Default buffersize for disk &
	\ M%,M0%=2%							      &
	\ M$="/"				!Assume word		      &
	\ R0%(I%,1)=-1% FOR I%=0% TO 15%	!Initialize relocation	      &
	\ R0%(I%,2)=-1% FOR I%=0% TO 15%	! registers		      &
	\ R%(I%,1)=-1% FOR I%=0% TO 15%		! and their		      &
	\ R%(I%,2)=-1% FOR I%=0% TO 15%		! contents		      &
	\ F0%,B%(3%),A%(3%)=-1%			!Initialize flags	      &
	\ RW.FLG%=1%				!Assume read only	      &
	\ PRINT IF CCPOS(0%)			!Get to left margin	      &
	\ GOTO 1120 IF I$=CHR$(13%)+CHR$(10%) 	!If CR then READ-ONLY	      &
	\ IF I$=CHR$(10%)+CHR$(13%)+CHR$(0%) THEN !If LF only then READ-WRITE &
		RW.FLG%=0%						      &
	\	GOTO 1120						      &
	\ END IF							      &
	\ IF I$=CHR$(27%) THEN			!If ESC(ALT), then	      &
		I$="[0,1]CRASH.SYS"		!  Use CRASH.SYS	      &
	\	PRINT "Using file ";I$		!  Say it		      &
	\	USE.CRASH%=-1%			!  Flag it		      &
	\ ELSE					!Else			      &
	\ 	RW.FLG%=0% 			!  Make it READ-WRITE	      &
		 IF ASCII(RIGHT(I$,LEN(I$)))=0% !   if it ends in LF	      &
	\ END IF				!End if			      &
	\ F$=SYS(CHR$(6%)+CHR$(-23%)+I$)	!FSS the input without error  &
	\ SAVED.STATUS%=STATUS			!Get STATUS variable from FSS &
	\ QUAL$=CVT$$(RIGHT(I$,LEN(I$)-RECOUNT+1%),-2%)  !Get the switches    &
	\ I$=LEFT(I$,LEN(I$)-RECOUNT)		!Get I$ without switches      &
	\ IF INSTR(1%,"/WRITE",QUAL$)=1% AND LEN(QUAL$)>1% THEN		      &
		RW.FLG% = 0%						      &
	  ELSE 	IF INSTR(1%,"/NOWRITE",QUAL$)=1% AND LEN(QUAL$)>3% THEN	      &
		        RW.FLG% = 1%					      &
		ELSE 	IF LEN(QUAL$) THEN				      &
				PRINT "?Illegal option - ";QUAL$;".  ";	      &
	\			GOTO 1030				      &
	\		END IF						      &
	\	END IF							      &
	\ END IF							      &
	\ I$ = CVT$$(I$,-2%)			!Clean up input		      &
	\ GOTO 1120 UNLESS LEN(I$)		!Use memory if no file name   &
	\ GOTO 1200 IF I$="HELP"		!Type help text if so desired &
	\ BUFF.SIZ%=0%				!Let monitor tell us BUFSIZ   &
	\ S0% = SWAP%(CVT$%(RIGHT(F$, 27%)))	!Get flag word 1 from FSS     &
	\ S1% = SWAP%(CVT$%(RIGHT(F$, 29%)))	!Get flag word 2 from FSS     &
	\ IF (S1% < 0%) THEN						      &
		PRINT "?Illegal file name"				      &
	\	GOTO 1030			! Try again		      &
	\ END IF							      &
	\ GOTO 1080 IF (SAVED.STATUS% AND 255%)	! Skip next if non-disk	      &
	\ GOTO 1080 UNLESS (S1% AND 8192%)	! Skip unless dev specified   &
	\ GOTO 1080 IF (S1% AND (1%+8%+128%))	! Skip if ppn or name found   &
	\ BUFF.SIZ% = (32767%+1%)+512%		! NFS, set small buffersize   &
	\ IF (S0% AND 2%) THEN			! Mode specified?	      &
		MO% = SWAP%(CVT$%(RIGHT(F$,17%))) ! Save the mode value	      &
	\	IF (MO% AND 128%) = 0% THEN	!   Block mode specified?     &
			FBN% = -1%		!   No, turn on FBN flag      &
	\		H9 = 0%			!     1st block is #0, not #1 &
						!     Rebuild file spec...    &
	\		I0$ = "_"+MID(F$,23%,2%)!     Device name	      &
	\		I0$ = I0$ + NUM1$(ASCII(MID(F$,25%,1%)))! Unit #,     &
				IF ASCII(MID(F$,26%,1%))	!  if present &
	\		I0$ = I0$ + ":/MODE:"	!     Colon + "/MODE:"	      &
	\		I0$ = I0$ + NUM1$(128% OR (MO% AND 32767%))	      &
						!     Force block mode	      &
	\	END IF							      &
	\ ELSE					! No mode specified	      &
		FBN% = -1%			!   Turn on FBN flag	      &
	\	H9 = 0%				!   1st block is #0, not #1   &
	\	I0$ = I$ + "/MODE:128"		!   Add mode 128 to spec      &
	\ END IF							      &
	!								      &
	! I$ now contains the original file spec with whatever modes the      &
	! user specified.  I0$ now contains the same file spec with mode      &
	! 128 added to be used when we need to ensure block mode access.      &

1080	  OPEN I$ FOR INPUT AS FILE 2%, RECORDSIZE BUFF.SIZ%		      &
	\ NFS%=STATUS AND 256%						      &
	\ F%=-1%							      &
	\ DEV.ACCESS%=STATUS AND 1024%					      &
	\ DEV.IS.DISK%=NOT (STATUS AND 255%)				      &
	\ BUFF.SIZ%=BUFSIZ(2%)						      &
	\ CLOSE 2%							      &
	\ OPEN "_NL:" AS FILE 4%, RECORDSIZE BUFF.SIZ%			      &
	\ OPEN I$ FOR INPUT AS FILE 2%, RECORDSIZE (32767%+1%)+2%	      &
		! OPEN FILE ON CHANNEL 2				      &
		! NFS%<>0% NON-FILE STRUCTURED MODE			      &
		! SET FILE/MEMORY FLAG TO INDICATE FILE			      &
		! DEV.ACCESS%<>0% - JOB DOES NOT HAVE WRITE ACCESS TO DEVICE  &
		! DEV.IS.DISK%<>0% - DISK				      &
		! BUFF.SIZ% = Recommended buffer size, or 512 for NFS disk    &
		!							      &
		! Close the input file and open it again with a small	      &
		!  buffer, then open the null device with the correct	      &
		!  buffersize.						      &
		!							      &
		!  (This is done in case we are in FBN mode and need to	      &
		!   perform I/O on the boot block.  The only way to do	      &
		!   this is on the first access to the disk.  Since we	      &
		!   would lose the I/O buffer on the re-open, we use the      &
		!   the null device to save the buffer in case we need	      &
		!   to re-write the boot block)				      &

1090	IF NFS%<>0% AND NOT DEV.IS.DISK% THEN				      &
	    PRINT "?Only disk file can be opened in non-file structured mode" &
	\   PRINT							      &
	\   GOTO 1030							      &
	\ END IF							      &
	\ IF DEV.ACCESS%<>0% AND RW.FLG%=0% THEN			      &
		PRINT "%Program does not have write access to device."	      &
	\	RW.FLG%=1%						      &
	\ END IF							      &
	\ S$=SYS(CHR$(12%))						      &
	\ DCS%=ASCII(RIGHT(S$,21%))					      &
	\ FILE.SIZE.LSB%=SWAP%(CVT$%(MID(S$,13%,2%)))			      &
	\ FILE.SIZE.MSB%=ASCII(MID(S$,4%,1%))				      &
	\ FILE.SIZE=FNL(FILE.SIZE.LSB%,FILE.SIZE.MSB%)			      &
	\ IF NFS% THEN							      &
		IF FBN% THEN						      &
			FILE.SIZE = FILE.SIZE * DCS%			      &
		ELSE	FILE.SIZE = FILE.SIZE - 1%			      &
	\	END IF							      &
	\ END IF							      &
	\ IF FILE.SIZE=L.0 THEN						      &
		PRINT "?File has length 0"				      &
	\	GOTO 1030						      &
	\ END IF							      &
	\ GET #2%+SWAP%(4%), BLOCK H9					      &
		! Only NFS access to disks				      &
		! Check for write access to file/device			      &
		! Compute maximum record number				      &
		! (Don't count boot block if /MODE:128 access to NFS disk)    &
		! Make sure file contains at least 1 record		      &
		! Get first record, or boot block for NFS disk (no mode 128%) &

1120	PRINT "Access is READ WRITE" IF RW.FLG%=0%			      &
	\ PRINT "Access is READ ONLY" IF RW.FLG%=1%			      &

1125	PRINT								      &
	\ GOTO 1140							      &
		! Print access granted					      &

1130	PRINT "?"							      &
		! ILLEGAL CHARACTER INPUT				      &

1140	ON ERROR GOTO 19000						      &
	\ A$=SYS(CHR$(6%)+CHR$(-7%))					      &
	\ OPEN "_KB:ODT.CMD" AS FILE 1%					      &
	\ PRINT "*";							      &
		! SET UP ERROR TRAP					      &
		! ENABLE CNTL/C TRAP					      &
		! SET UP KEYBOARD AS INPUT FILE				      &
		! "*" INDICATES READY TO ACCEPT COMMAND			      &

1150	B%(I%),A%(I%),A0%(I%)=0% FOR I%=0% TO 2%			      &
	\ I0%=2%							      &
	\ O0%=1%							      &
	\ EOF%=0%							      &
		! ZERO ARRAY ELEMENTS					      &
		! SET ARRAY INDEX					      &
		! SET REVERSE POINTER					      &
		! RESET EOF FLAG					      &

1160	GOSUB 13500							      &
	\ R1%=R2% IF R2%>0%						      &
	\ A=FNL(A%,R2%)							      &
	\ B=FNA(I0%)+A*O0%						      &
	\ A%(I0%)=FNL%(B)						      &
	\ B%(I0%)=H							      &
	\ A0%(I0%)=A0%(I0%)+A0%						      &
	\ O0%=1%							      &
		! GET THE NEXT COMMAND CHARACTER			      &
		! SAVE VALUE > 65K IF ONE HAS BEEN INPUT		      &
		! COMPUTE NEW ADDRESS					      &
		! O0% INDICATES IF INFO IN CORRESPONDING ELEMENT OF ARRAY A%  &
									      &

1170	SELECT	CHAR%			!Select the input character	      &
					!				      &
	\ CASE 32%, 43%			!SPACE or PLUS			      &
	\	GOTO 1160 		!	Get next command	      &
	\ CASE 45%			!MINUS				      &
	\	O0%=-1% 		! 	Set reverse flag	      &
	\	GOTO 1160 		!	Get next command	      &
	\ CASE 46% 			!PERIOD (.)			      &
	\	X=D+FNA(I0%) 		!	Open last location opened     &
	\	A%(I0%)=FNL%(X)		!	Store low order value of X    &
	\	B%(I0%)=H 		!	Store high order value of X   &
	\	A0%(I0%)=1%		!	???			      &
	\ 	GOTO 1160 		!	Get next command	      &
	\ CASE 81%			!Q				      &
	\	X=FNA(I0%)+FNL(Q%,0%)	!	Use last quantity printed     &
	\	A%(I0%)=FNL%(X)		!	Store low order value of X    &
	\	B%(I0%)=H 		!	Store high order value of X   &
	\	A0%(I0%)=1%		!	???			      &
	\ 	GOTO 1160 		!	Get next command	      &
	\ CASE 44%			!COMMA (,) - Separates relocation     &
					!	register number from	      &
					!	an octal offset value	      &
	\	GOTO 1130 IF A%(I0%)<0% OR A%(I0%)>15%			      &
					! 	Check if register number input &
					!	is in register range	      &
	\	R8%=A%(I0%) 		!	Move the offset to A%(I0%)    &
	\ 	GOTO 1130 IF R0%(A%(I0%),1%)=-1%			      &
	\	IF A%(I0%)<8% THEN					      &
			A%(I0%)=R%(A%(I0%),1%)				      &
	\		A0%(I0%)=1%		!	???		      &
	\	 	GOTO 1160 		!	Get next command      &
	\	END IF							      &
	\	LSB=R%(A%(I0%),1%)					      &
	\	MSB=0%							      &
	\	MSB=R%(A%(I0%),2%) IF R0%(A%(I0%),2%)=0%		      &
	\ 	X=LNG*512%						      &
		! Transform the integer values in the relocation registers    &
		! into a longword.					      &
		! Change register block offset to address offset	      &
		! Assume block is always logical block			      &
	\	A%(I0%)=FNL%(X)		!	Store low order value of X    &
	\	B%(I0%)=H 		!	Store high order value of X   &
	\	A0%(I0%)=1%		!	???			      &
	\ 	GOTO 1160 		!	Get next command	      &
	\ CASE 59%			!SEMI-COLON (;)			      &
	\	I0%=I0%-1%		!	Separates values in a list    &
	\	GOTO 1130 IF I0%<0%	!	Request.  Error if none	      &
	\	GOTO 1160 		!	Get next command	      &
	\ CASE 27%, 36%			! ESCAPE or DOLLAR		      &
	\	PRINT "$"; IF CHAR%=27%	!	Echo ESCAPE as "$"	      &
	\	GOSUB 14000 		!	Get more data		      &
	\	IF CHAR%>=48% AND CHAR%<=53% THEN			      &
					!	Between 0-5 then compute      &
			A%(I0%)=A%(I0%)+FNP%(L.0,22%)+(CHAR%-48%)*2%+2%	      &
	\		A0%(I0%)=1%					      &
	\ 		GOTO 1160					      &
	\	END IF							      &
	\	IF CHAR%=54% THEN 		! $6			      &
			A%(I0%)=A%(I0%)+FNP%(L.0,22%)+16%		      &
	\		A0%(I0%)=1%					      &
	\	 	GOTO 1160					      &
	\	END IF							      &
	\	IF CHAR%=55% THEN 		!$7			      &
			A%(I0%)=A%(I0%)+FNP%(L.0,22%)+18%		      &
	\		A0%(I0%)=1%					      &
	\ 		GOTO 1160					      &
	\	END IF							      &
	\	IF CHAR%=83% THEN		!$S - Processor status word   &
	\		A%(I0%)=A%(I0%)+FNP%(L.0,22%)+20%		      &
	\		A0%(I0%)=1%					      &
	\ 		GOTO 1160					      &
	\	END IF							      &
	\	GOTO 1130		!Illegal register, error	      &
									      &
	\ CASE 82% 		! R - STORE VALUE IN OFFSET REGISTER	      &
	\	IF I0%=2% AND A0%(2%)=0% THEN				      &
			R%(I%,1%)=-1% FOR I%=0% TO 15%			      &
	\		R%(I%,2%)=-1% FOR I%=0% TO 15%			      &
	\		R0%(I%,1%)=-1% FOR I%=0% TO 15%			      &
	\		R0%(I%,2%)=-1% FOR I%=0% TO 15%			      &
	\		PRINT						      &
	\		GOTO 1140					      &
	\	END IF							      &
	\	GOTO 1130 IF A%(I0%)<0% OR A%(I0%)>15%			      &
	\	R%(A%(I0%),1%)=A%(I0%+1%)				      &
	\	R%(A%(I0%),2%)=R1% IF A%(I0%)>7% AND R1%>0%		      &
	\	R0%(A%(I0%),1%)=0% IF I0%<2%				      &
	\	R0%(A%(I0%),2%)=0% IF A%(I0%)>7% AND R1%>0% AND I0%<2%	      &
	\	R0%(A%(I0%),1%)=-1% IF I0%=2%				      &
	\	R0%(A%(I0%),2%)=-1% IF I0%=2%				      &
	\	PRINT							      &
	\	GOTO 1140						      &
		! PUT OFFSET IN REGISTER				      &
		! SET THE REGISTER FLAG=0% IF A VALUE HAS BEEN PUT IN THE REG. &
		! SET THE REGISTER FLAG=-1% IF NO VALUE PROCEEDS THE REG.     &
		!	PARAMETER.					      &
	\ CASE 47%		! / - OPEN ADRESS AS A WORD		      &
	\	IF A0%(I0%) THEN					      &
			GOTO 1380 IF A%(I0%) AND 1%			      &
	\		D9=D						      &
	\		D=FNA(I0%)					      &
	\		M%=2%						      &
	\		M$="/"						      &
	\	END IF							      &
			! HAS AN ADDRESS LOCATION BEEN ENTERED?		      &
			! CHECK FOR EVEN/ODD ADDRESS			      &
			! SET FOR EVEN ADDRESS				      &
	\	M0%=2%							      &
	\ 	GOTO 1390 IF D AND 1%					      &
	\	GOTO 1400						      &
		! CHECK IF ADDRESS IN EVEN/ODD RECORD			      &
									      &
	\ CASE 92%		! \ - OPEN ADDRESS AS A BYTE		      &
	\	GOTO 1380						      &
	\ CASE 13%		! CR - CLOSE ADDRESS AND WAIT FOR INPUT	      &
	\	GOTO 1410						      &
	\ CASE 10%		! LF - CLOSE CURRENT ADDRESS OPEN NEXT	      &
	\	PRINT     	!      SEQUENTIAL ADDRESS		      &
	\	GOTO 1420 	!					      &
	\ CASE 94%		! ^ CIRCUMFLEX CHARACTER - CLOSES CURRENT     &
	\	GOTO 1450  	!   LOCATION OPENS SEQUENTIAL PRECEDING	      &
				!   LOCATION				      &
	\ CASE 64%		!@ COMMERICAL "AT" SYMBOL - USE CONTENTS      &
	\	GOTO 1470	!   OF CURRENT LOCATION AS AN ABSOLUTE	      &
				!   ADDRESS LOCATION			      &
	\ CASE 95%		! _ UNDERLINE SYMBOL - USE CONTENT OF CURRENT &
	\	GOTO 1480 	!   LOCATION AS A PC RELATIVE ADDRESS	      &
	\ CASE 62%		!> - USE LOW ORDER BYTE AS RELATIVE BRANCH    &
	\	GOTO 1490 	!   OFFSET				      &
	\ CASE 60%		! < - CLOSE CURRENT LOCATION AND OPEN LAST    &
	\	GOTO 1510	!   EXPLICITLY OPEN LOCATION		      &
	\ CASE 70%		! F - SETS RELOCATION CALCULATION FOR LIST    &
	\	GOTO 1520 	!   REQUEST				      &
	\ CASE 75%		! K - Calculate address of Kluster - Use      &
	\	GOTO 1525	!   contents of current location as a DCN     &
	\ CASE 76%		! L - REQUEST A LIST OF ADDRESSES	      &
	\	GOTO 1530 	!					      &
	\ CASE 67%		! C - PRINT MONITOR TABLE INFO		      &
	\	GOTO 1680 	!					      &
	\ CASE 37%		! % - GIVES ASCII REPRESENTATION OF RADIX-50  &
	\	GOTO 10080 	!   VALUE IN CUURENTLY OPEN LOCATION	      &
	\ CASE 34%		! " - GIVES ASCII REPRESENTATION OF CURRENTLY &
	\	GOTO 10090 	!   OPEN LOCATION			      &
	\ CASE 4%, 68%		! ^D, D - Use contents of current address     &
	\	GOTO 1740 	!   as a directory link			      &
	\ CASE ELSE		!Anything else				      &
	\	GOTO 1130	! Found no legal command - try again	      &
	\ END SELECT							      &

1200	!								      &
	! Print HELP text						      &
	!								      &
	PRINT								      &
	\ PRINT "At the 'File <MEMORY>?' prompt, options are:"		      &
	\ PRINT								      &
	\ PRINT "    Enter:       To:"					      &
	\ PRINT "    ------       ---"					      &
	\ PRINT "    RETURN       Request READ-ONLY access to memory"	      &
	\ PRINT "    LINE FEED    Request READ-WRITE access to memory"	      &
	\ PRINT "    ESCAPE       Request access to [0,1]CRASH.SYS"	      &
	\ PRINT "    <filespec>   Access a filename, device or directory."    &
	\ PRINT								      &
	\ PRINT "You can also specify /WRITE or /NOWRITE to explicitly"	      &
	\ PRINT "request read-write or read-only access.  If you specify"     &
	\ PRINT	"these switches, they must appear at the end of the input."   &
	\ PRINT "WRITE may be abbreviated to as little as one character."     &
	\ PRINT								      &
	\ PRINT "For help on commands, see the `Utilities Reference Manual'." &
	\ PRINT								      &
	\ GOTO 1030							      &

1380	IF A0%(I0%) THEN						      &
		D9=D							      &
	\	D=FNA(I0%)						      &
	\	M%=1%							      &
	\	M$="\"							      &
		! SET UP AND GET CONTENTS OF ODD ADDRESS		      &

1390	M0%=1%								      &

1400	GOSUB 13010							      &
	\ GOTO 1140 IF EOF%						      &
	\ GOSUB 12010							      &
	\ GOTO 1150							      &
		! OPEN LOCATION						      &
		! DISPLAY CONTENTS					      &
		! RETURN AND WAIT FOR NEXT COMMAND			      &

1410	GOSUB 11020							      &
	\ GOSUB 14000							      &
	\ GOTO 1140							      &
		! #<CR>							      &
		! REPLACE CURRENT ADDRESS CONTENTS WITH SPECIFIED	      &
		!	CONTENTS - IF ANY				      &
		! DECODE ANY INPUT CHARACTERS WAITING - BUT THESE	      &
		!	WILL BE IGNORED					      &
		! PROMPT WITH "*"					      &

1420	GOSUB 11010							      &
	\ D=D+M%							      &
		! #<LF>							      &
		! REPLACE CURRENT ADDRESS CONTENTS WITH SPECIFIED	      &
		!	CONTENTS - IF ANY				      &
		! UP THE ADDRESS COUNT BY M%(1% OR 2%) TO OPEN NEXT	      &
		!	SEQUENTIAL ADDRESS				      &

1430	V=D								      &
	\ V%=FNL%(V)							      &
	\ M0%=2%							      &
	\ GOSUB 10030							      &
	\ IF M%=2% THEN							      &
		IF D AND 1% THEN					      &
			M%=1%						      &
	\		M$="\"						      &
		! BREAK THE ADDRESS INTO TWO INTEGERS THEN		      &
		! GOTO SUBROUTINE TO PRINT ADDRESS THEN			      &
		! DETERMINE IF AN EVEN/ODD ADDRESS AND			      &
		! WHEATHER TO OPEN AS BYTE OR WORD			      &

1440	PRINT M$;							      &
	\ M0%=M%							      &
	\ GOTO 1400							      &
		! FORCE COMMAND TO KB0:					      &
		! SET EVEN ODD ADDRESS FLAG				      &
		! GOTO GET ADDRESS CONTENTS AND PRINT OUT		      &

1450	GOSUB 11010							      &
	\ D=D-M%							      &
		! #^							      &
		! REPLACE CURRENT CONTENTS WITH SPECIFIED CONTENTS	      &
		! DECREMENT ADDRESS TO OPEN PREVIOUS SEQUENTIAL		      &
		! ADDRESS						      &

1460	PRINT								      &
	\ GOTO 1430							      &
		! PRINT - TO GET CUSOR TO LEFT SIDE OF SCREEN		      &
		! GOTO PRINT ADDRESS ON SCREEN				      &

1470	GOSUB 11010							      &
	\ D=FNL(Q%,0%)							      &
	\ GOTO 1460							      &
		! #@							      &
		! REPLACE CURRENT ADDRESS CONTENTS WITH SPECIFIED	      &
		! CONTENTS - IF ANY					      &
		! USE CONTENTS OF CURRENT ADDRESS AS ABSOLUTE ADDRESS	      &
		! RESET CUSOR AND PRINT ADDRESS				      &

1480	GOSUB 11010							      &
	\ D=D+2%+Q%							      &
	\ GOTO 1460							      &
		! #_							      &
		! REPLACE CURRENT ADDRESS CONTENTS WITH SPECIFIED	      &
		! CONTENTS - IF ANY					      &
		! CALCULATE P.C. OFFSET OF CURRENT ADDRESS USING	      &
		! CONTENTS OF CURRENT ADDRESS				      &

1490	GOSUB 11010							      &
	\ I%=ASCII(CHR$(Q%))						      &
	\ IF I%>127% THEN						      &
		I%=I%-256%						      &
		! #>							      &
		! REPLACE CURRENT ADDRESS CONTENTS WITH SPECIFIED	      &
		! CONTENTS - IF ANY					      &
		! GET LOW ORDER BYTE VALUE				      &
		! DETERMINE THE SIGNED VALUE				      &

1500	D=D+2%+2%*I%							      &
	\ GOTO 1460							      &
		! CALCULATE BRANCH OFFSET FROM CURRENT ADDRESS		      &
		! USING LOW ORDER BYTE SIGNED VALUE			      &

1510	GOSUB 11020							      &
	\ D=D9								      &
	\ GOTO 1460							      &
		! #<							      &
		! REPLACE CURRENT ADDRESS CONTENTS WITH SPECIFIED	      &
		! CONTENTS - IF ANY					      &
		! RESET D TO LAST EXPLICIT ADDRESS OPENED		      &
		! GO PRINT ADDRESS AND CONTENTS				      &

1520	F0%=A%(I0%)							      &
	\ PRINT								      &
	\ GOTO 1140							      &
		! #F							      &
		! SET THE F-COMMAND FLAG				      &
		! RETURN FOR NEXT COMMAND				      &

1525	GOTO 1130 UNLESS NFS%						      &
	\ GOSUB 11010							      &
	\ D=L.512*FNL(Q%,0%)*DCS%					      &
	\ D=D-(L.512*DCS%) UNLESS FBN%					      &
	\ GOTO 1460							      &
		! #K - Read "Kluster" specified by Q%			      &
		! Not a legal command unless NFS disk access		      &
		! Replace current address contents with specified value	      &
		! Use contents of current address as DCN value		      &
		! (Don't count DCN 0 if block mode access)		      &
		! Reset cursor and print address			      &

1530	GOTO 1560 IF F0%						      &
	\ R8%=0%							      &
	\ A%=I0%							      &
		! IF THE F COMMAND FLAG SET THEN			      &
		!	SETUP THE REGISTER INDICTOR			      &
		!	AND SAVE THE INDEX TO THE A%(I%) ARRAY		      &

1540	R8%=R8%+1%							      &
		! UP THE REGISTER COUNTER				      &

1550	GOTO 1660 IF R8%>7%						      &
	\ IF R0%(R8%,1%)=-1% AND R8%<8% THEN				      &
		GOTO 1540						      &
		! DONE IF BEEN THRU REGISTERS 0-7			      &
		! IF NOTHING IN REGISTER AND REGISTER NUMBER < 8% THEN	      &
		!	TRY NEXT REGISTER				      &
		! ELSE  PRINT OUT VALUE FOR THIS REGISTER		      &

1560	PRINT								      &
	\ L2%=0%							      &
	\ IF I0%=2% THEN						      &
		D=0%							      &
	\	L1=FNA(2%)						      &
	\	GOTO 1610						      &
		! #;#;#L						      &
		! SET UP VARIABLES FOR L(LIST) COMMAND			      &
		! FOR ONE PARAMETER ASSUME LIST GOES FROM 0 TO N	      &
		! GOTO CALCULATE ADDRESSES WITH OFFSETS AND PRINT	      &
		! VALUES OUT						      &

1570	IF I0%=1% THEN							      &
		D=FNA(2%)						      &
	\	L1=FNA(1%)						      &
	\	GOTO 1610						      &
		! FOR TWO PARAMETERS SET VARIABLES TO GO FROM		      &
		! D TO L1						      &
		! GOTO CALCULATE ADDRESSES WITH OFFSETS AND PRINT VALUES      &

1580	D=FNA(1%)							      &
	\ L1=FNA(0%)							      &
	\ IF A0%(2%) THEN						      &
		O%=3%							      &
	\	IF A%(2%)=1% THEN					      &
			S$="LP:"					      &
	\		GOTO 1600					      &
		! THIS CODE ASSUMES THREE INPUT PARAMETERS		      &
		! FIRST PARAMETER IS ASSUMED TO BE DEVICE FLAG		      &
		! SECOND AND THIRD DEFINE ADDRESS RANGE			      &
		! ANY VALUE FOR THE FIRST AGRUMENT WILL OPEN CHANNEL 3	      &
		! IF FIRST ARGUMENT =1% THEN				      &
		!	OUTPUT ON LP0:					      &
		! GOTO SETUP ERROR TRAP AND PRINT OUT ADDRESES,OFFSETS	      &
		! AND VALUE OF CONTENTS					      &

1590	PRINT "Device";							      &
	\ INPUT LINE S$							      &
		! PRINT THE PROMPT FOR THE LIST REQUEST TO BE		      &
		! OUTPUT TO						      &

1600	ON ERROR GOTO 1670						      &
	\ OPEN S$ FOR OUTPUT AS FILE 3%					      &
		! SET I/O ERROR TRAP					      &

1610	 U=D								      &

1620	IF L2% AND 7% THEN						      &
		GOTO 1630						      &
	ELSE	PRINT #O%						      &
	\	M0%=2%							      &
	\	D=U							      &
	\	V=D							      &
	\	V%=FNL%(V)						      &
	\	GOSUB 10020						      &
	\	PRINT #O%,M$;						      &
	\	L2%=0%							      &
		! THE IF STATEMENT IS SET UP TO PRINT THE CONTENTS	      &
		! OF EIGHT ADDRESS OFFSETS ACROSS THE WIDTH OF THE	      &
		! PAGE, THE ELSE PRINTS THE FIRST ADDRESS OF THE EIGHT	      &
		! AND FORCES THE COMMAND AND RESETS L2%			      &
		! NOTE *** THE VARIABLE U IS USED HERE TO KEEP THE OFFSET     &
		!          COUNT SINCE THE VALUE OF D CHANGES FROM AN	      &
		!	   OFFSET VALUE TO THE VALUE OF AN ADRESS	      &
		!	   LOCATION AFTER GOING TO 10005		      &

1630	L2%=L2%+1%							      &
	\ M0%=M%							      &
	\ GOSUB 13010							      &
	\ GOTO 1140 IF EOF%						      &
	\ PRINT #O%," ";						      &
	\ GOSUB 12020							      &
		! INCREMENT THE ACROSS PAGE COUNTER			      &
		! SET BYTE/WORD FLAG					      &
		! GET NEW ADDRESS + OFFSET CONTENTS			      &
		! CHECK FOR END OF FILE					      &
		! PRINT SPACE						      &
		! PRINT CONTENTS					      &

1640	D=D+M%								      &
	\ U=U+M%							      &
	\ D0=U								      &
		! INCREMENT THE ADDRESS VALUE				      &
		! INCREMENT THE OFFSET VALUE				      &
		! CALCULATE A NEW POSITIVE ADDRESS			      &

1650	IF D0<=L1 THEN							      &
		GOTO 1620						      &
	ELSE	IF F0%=0% AND R8%<7% THEN				      &
			I0%=A%						      &
	\		GOTO 1540					      &
		! IF COUNT NOT = L1 THEN				      &
		!	KEEP PRINTING ADDRESS CONTENTS			      &
		! ELSE  CHECK THE F COMMAND FLAG AND THE REGISTER INDEX	      &
		!		IF REGISTER 7% HASN'T BEEN REACHED	      &
		!			GO BACK TO THE NEXT REGISTER	      &

1660	PRINT #O%							      &
	\ CLOSE 3%							      &
	\ O%=0%								      &
	\ PRINT								      &
	\ GOTO 1140							      &
		! RETURN THE CUSOR					      &
		! CLOSE THE OUTPUT CHANNEL				      &
		! SET CHANNEL FLAG TO ZER0				      &
		!	READY FOR NEXT COMMAND				      &

1670	PRINT "%I/O Error";						      &
	\ CLOSE 3%							      &
	\ O%=0%								      &
	\ RESUME 1130							      &
		! I/O ERROR TRAP					      &
		! CLOSE OUTPUT CHANNEL					      &
		! RESET OUTPUT CHANNEL					      &
		! READY FOR NEXT COMMAND				      &

1680	RESTORE								      &
	\ M0%=2%							      &
		! C - COMMAND						      &
		! RECYCLE DATA STATEMENT COUNTER TO START AT LOWEST	      &
		! DATA STATEMENT					      &
		! ENSURE WE PRINT WORDS					      &
									      &

1690	IF USE.CRASH% THEN						      &
		READ I%,BYTE.OFF%,S$					      &
	\	IF I% THEN						      &
			GOTO 1690					      &
		! IF THE CRASH.SYS FILE FLAG IS SET THEN		      &
		!	READ THRU DATA STATEMENTS TIL I%=0%		      &

1700	PRINT								      &
	\ READ I%,BYTE.OFF%,S$						      &
	\ IF I%=0% THEN							      &
		PRINT							      &
	\	GOTO 1140						      &
	ELSE	PRINT S$;"	";					      &
		! PRINT BLANK LINE - TO RETURN CUSOR			      &
		! READ NEXT DATA STATEMENT				      &
		! I%=0% ENDS MONITOR TABLE PRINT OUT, BUT STARTS	      &
		! CRASH.SYS FILE PRINT OUT				      &
		! FIRST ELEMENT = 0% THEN GO BACK FOR NEXT COMMAND	      &
		! ELSE PRINT THIRD ELEMENT(LABEL)			      &

1710	IF USE.CRASH% THEN						      &
		V%=FNP%(L.0,BYTE.OFF%)					      &
	\	GOTO 1730						      &
		! GET CONTENTS OF CRASH.SYS FILE			      &
		! GO TO DISPLAY THEM					      &

1720	S$=MID(SYS(CHR$(6%)+CHR$(I%)),ABS%(BYTE.OFF%),2%)		      &
	\ V%=ASCII(S$)							      &
	\ IF BYTE.OFF%>0% THEN						      &
		V%=V%+SWAP%(ASCII(RIGHT(S$,2%)))			      &
		! MONITOR TABLE SYS CALL				      &
		! GET HIGH BYTE AS INTEGER				      &

1730	GOSUB 12020							      &
	\ GOTO 1700							      &
		! GO TO DISPLAY CONTENTS OF CRASH.SYS FILE		      &
		! GO GET NEXT LOCATION					      &

1740	GOTO 1130 IF NOT F%						      &
	\ GOSUB 11010							      &
	\ C.CLU% = (Q% AND 3584%) / 512%				      &
	\ FIELD #4%, 31%*16% AS C.CLU$,					      &
		2% AS C.CLU$, 2%*C.CLU% AS C.DCN$, 2% AS C.DCN$		      &
	\ D = (((SWAP%(Q%) AND 240%)/16%)*512%) +			      &
		((Q% AND 496%)/16%)*16%					      &
	\ D = D + C.CLU% * SWAP%(CVT$%(C.CLU$)) * 512% UNLESS NFS%	      &
	\ D = D + FNL(SWAP%(CVT$%(C.DCN$)),0%) * DCS% * 512% IF NFS%	      &
	\ D = D - (L.512 * DCS%) IF NFS% UNLESS FBN%			      &
	\ GOTO 1460							      &
		!#D							      &
		! NO CAN DO IF ACCESSING MEMORY (ONLY VALID FOR FILES)	      &
		! REPLACE CURRENT CONTENTS WITH SPECIFIED CONTENTS,	      &
		!  IF ANY.						      &
		! GET CLUSTER NUMBER OF NEW BLOCKETTE.			      &
		! FIELD THE UFD/MFD CLUSTER MAP AND FIND THE UFD	      &
		!  CLUSTERSIZE AND DCN OF NEW CLUSTER.			      &
		! CALCULATE OFFSET INTO CLUSTER OF BLOCKETTE.		      &
		! ADD CLUSTER OFFSET IF FILE-STRUCTURED DIRECTORY ACCESS      &
		! ELSE ADD DCN ADDRESS FOR NON-FILE-STRUCTURED DISK ACCESS.   &
		! (DON'T COUNT DCN 0 FOR NFS BLOCK MODE ACCESS)		      &
		! RESTORE THE CARRIAGE/CURSOR AND PRINT.		      &

9000	DATA -3,-3,NULINE,		-3,-4,MAXCNT
9010	DATA -3,5,DEVCNT,		-3,7,DEVPTR
9020	DATA -3,9,MEMLST,		-3,11,JOBTBL
9030	DATA -3,13,JBSTAT,		-3,15,JBWAIT
9040	DATA -3,17,UNTCLU,		-3,19,UNTCNT
9050	DATA -3,21,SATCTL,		-3,25,SATCTM
9060	DATA -3,23,JSBTBL,		-12,3,FREES
9070	DATA -12,5,DEVNAM,		-12,7,CSRTBL
9080	DATA -12,9,DEVOKB,		-12,11,TTYHCT
9090	DATA -12,13,JOBCNT,		-12,15,RTSLST
9100	DATA -12,17,ERRCTL,		-12,19,SNDLST
9110	DATA -12,21,LOGNAM,		-12,23,DEVSYN
9120	DATA -12,25,MEMSIZ
9130	DATA 0,0,""
9140	DATA 1, 0,NULINE,		1, 1,JOBMAX
9150	DATA 1, 2,DEVCNT,		1, 3,DEVPTR
9160	DATA 1, 4,MEMLST,		1, 5,JOBTBL
9170	DATA 1, 6,JBSTAT,		1, 7,JBWAIT
9180	DATA 1, 8,UNTCLU,		1, 9,UNTCNT
9190	DATA 1,10,SATCTL,		1,12,SATCTM
9200	DATA 1,11,JSBTBL,		1,13,FREES
9210	DATA 1,14,DEVNAM,		1,15,CSRTBL
9220	DATA 1,16,DEVOKB,		1,17,TTYHCT
9230	DATA 1,18,JOBCNT,		1,19,RTSLST
9240	DATA 1,20,ERRCTL,		1,21,SNDLST
9250	DATA 1,22,FIPBUF,		1,23,FIJOB
9260	DATA 1,24,FIJBDA,		1,25,RTSLOD
9270	DATA 1,26,RTSLNK,		1,27,JOBRES
9280	DATA 0,0,""							      &

10000	!	S U B R O U T I N E S					      &

10010		!*******************************************************      &
		!							      &
		! THIS SUBROUTINE IS USED TO FORCE ADDRESS COMMANDS	      &
		! TO THE KB: AND DOES SO BY CALCULATING THE REGISTER	      &
		! VALUE AND OFFSET OR THE BLOCK VALUE AND ADDRESS	      &
		! VALUE WITHIN THE BLOCK				      &

10020	IF F0% THEN							      &
		GOTO 10070						      &
	ELSE	D1=FNL(R%(R8%,1%),0%)					      &
	\	D=V+D1							      &
		! ONLY IF THE F COMMAND HAS BEEN SELECTED DOES		      &
		! THE PROGRAM FALL THRU TO PRINT THE REGISTER		      &
		! NUMBERS AND THE OFFSETS FOR THE L COMMAND		      &
									      &

10030	I0%=R8%								      &
		! SETUP VARIABLES TO CALCULATE REGISTER			      &
		!	OFFSETS						      &

10040	GOTO 10070 IF R%(R8%,1%) = -1% AND R%(R8%,2%) = -1%		      &
	\ D1=FNL(R%(R8%,1%), 0%)					      &
	\ IF R8%>7% THEN						      &
		D1=FNL(R%(R8%,1%), R%(R8%,2%)) IF R%(R8%,2%)>-1%	      &
	\	D1=512%*D1						      &
		! Don't use relocation value if non-existant (-1, -1)	      &
		! GET THE REGISTER OFFSET VALUE				      &
		! FOR REGISTERS 10-17 OCTAL MULTIPLE BY 512 BYTES PER BLOCK   &

10050	D0=D-D1								      &
	\ IF D0<0% THEN							      &
		GOTO 10070						      &
	ELSE	IF R8%>7% THEN						      &
			I0%=R8%-8%					      &
	\		PRINT #O%,"1";					      &
		! FOR REGISTERS 10-17 OCTAL				      &
		! PRINT FIRST OCTAL REGISTER NUMBER			      &

10060	PRINT #O%,CHR$(48%+I0%);",";					      &
	\ V%=FNL%(D0)							      &
		! PRINT SECOND OCTAL REGISTER NUMBER			      &

10070	IF H=0 THEN							      &
		GOTO 12020						      &
	ELSE	D0 = FNL(V%,H%)						      &
	\	V = O"30000000000"L					      &
	\	J% = 3%							      &
	\	FOR I% = 1% TO 11%					      &
	\		I0% = (D0 AND V) / ((NOT V) + 1%)		      &
	\		PRINT #O%, CHR$(48% + (I0% AND J%));		      &
	\		D0 = D0 AND (NOT V)				      &
	\		V = V / 8%					      &
	\		J% = 7%						      &
	\	NEXT I%							      &
	\	RETURN							      &
		! IF RECORD 0% THEN					      &
		!	Print 16-bit address				      &
		! ELSE	Print 32-bit address				      &

10080	PRINT " ";RAD$(V%);" ";						      &
	\ GOTO 1150							      &
		! % - PRINT ASCII VALUE OF RAD-50 NUMBER		      &

10090	PRINT " ";CHR$(V%);CHR$(SWAP%(V%));" ";				      &
	\ GOTO 1150							      &
		! " - PRINTS ASCII REPRESENTATION OF CURRENT		      &
		! OPEN ADDRESS						      &

11000		!*****************************************************	      &
		!							      &
		! THIS SUBROUTINE PLACES VALUES IN THE BUFFER IF THE	      &
		! PROGRAM IS ALLOWED TO MODIFY ADDRESS CONTENTS. THIS	      &
		! ROUTINE DOES NOT WRITE THE BUFFER CONTENTS TO A FILE	      &
		! BUT USES THE LSET COMMAND TO SET UP THE BUFFER SO THAT      &
		! THE NEXT TIME A ADDRESS IS LOOKED UP WHICH IS NOT	      &
		! IN THE RANGE OF ADDRESSES FOR THE BUFFER FNP DOES A	      &
		! PUT.							      &

11010	D9=D								      &
		! STORE ADDRESS TEMPORIARLY				      &

11020	IF A0%(I0%)=0% THEN						      &
		RETURN							      &
	ELSE	IF RW.FLG% THEN						      &
			PRINT "%Write access not selected"		      &
	\	RETURN							      &
		! IS THERE ANYTHING TO WRITE				      &
		! NO WRITE PERMISSION - RETURN				      &

11030	IF F% THEN							      &
		GOTO 11050						      &
	ELSE	IF M%<>1% THEN						      &
			S$=CHR$(A%(I0%))+CHR$(SWAP%(A%(I0%)))		      &
		ELSE	IF FND% AND 1% THEN				      &
				S$=CHR$(PEEK(FNL%(D) AND (-2%)))+	      &
					CHR$(A%(I0%))			      &
			ELSE	S$=CHR$(A%(I0%))+			      &
				CHR$(SWAP%(PEEK(FNL%(D) AND (-2%))))	      &
									      &
		!*******************************************************      &
			! THIS CODE CHANGES THE CONTENTS OF LOW CORE	      &
			! AND IS THERFORE NEVER EXECUTED		      &
			! BUT IF IT WERE IT WOULD SET UP DATA TO POKE	      &
		!*******************************************************      &

11040	S$=SYS(CHR$(6%)+CHR$(-6%)+CHR$(FNL%(D) AND (-2%))+		      &
		CHR$(SWAP%(FNL%(D)))+S$)				      &

11045	RETURN								      &
		!*******************************************************      &
			! THIS IS THE SYS CALL THAT DOES THE POKE	      &
		!*******************************************************      &

11050	I%=FND% AND (-2%)						      &
	\ IF UDIV(D,BUFF.SIZ%)>=FILE.SIZE THEN				      &
		PRINT "%Address exceeds file limits"			      &
	\	EOF%=-1%						      &
	\	RETURN							      &
		! TRYING TO WRITE OUTSIDE FILE LIMITS			      &
		! //??? How can we write outside the file limit		      &
		!	if we can't read it???			//	      &

11060	D0=FNL(I%, 0%)							      &

11070	D8%=(D0/2%) AND L.MAX						      &
	\ I%=FNP%(H,D8%)						      &
	\ IF M%=1% THEN							      &
		A%(I0%)=ASCII(CHR$(A%(I0%)))				      &
		! FNP CHANGES THE FIELD VALUE TO SET UP FOR THE LSET	      &

11080	IF M%=2% THEN							      &
		P%=A%(I0%)						      &
	\	GOTO 11100						      &

11090	IF D AND 1% THEN						      &
		P%=SWAP%(A%(I0%))+ASCII(CHR$(I%))			      &
	ELSE	P%=A%(I0%)+SWAP%(ASCII(CHR$(SWAP%(I%))))		      &

11100	LSET P$=CVT%$(SWAP%(P%))					      &
	\ D9%=-1%							      &
	\ RETURN							      &
		! GETS CONTENTS OF NEXT SEQ LOCATION			      &

12000		!*******************************************************      &
		!							      &
		! THIS SUBROUTINE PRINTS THE OCTAL VALUE OF V%		      &

12010	PRINT #O%," ";							      &
	\ GOSUB 12020							      &
	\ PRINT #O%," ";						      &
	\ RETURN							      &
		! PRINT SPACE						      &
		! DO DECIMAL TO OCTAL CONVERSION			      &

12020	Q%,I%=V%							      &
	\ BYTE.OFF%=4096%						      &
	\ IF M0%=1% THEN						      &
		BYTE.OFF%=64%						      &
	ELSE	IF I%>=0% THEN						      &
			PRINT #O%,"0";					      &
		ELSE	PRINT #O%,"1";					      &
	\		I%=I%+32767%+1%					      &
		! CHECKS TO SEE IF IT WILL DISPLAY ADDRESS CONTENTS	      &
		! AS A WORD OR BYTE					      &
		! OPEN AS A WORD MUST DETERMINE IF CONTENTS ARE + OR -	      &

12030	D1%=I%/BYTE.OFF%						      &
	\ I%=I%-D1%*BYTE.OFF%						      &
	\ BYTE.OFF%=BYTE.OFF%/8%					      &
	\ PRINT #O%,CHR$(48%+D1%);					      &
	\ IF BYTE.OFF% THEN						      &
		GOTO 12030						      &
	  ELSE	RETURN							      &
		! DECIMAL TO OCTAL CONVERSION CHAR BY CHAR		      &
		! DISPLAY CHARS						      &

13000		!*******************************************************      &
		!							      &
		! THIS SUBROUTINE GETS THE CONTENTS OF THE ADDRESS "D"	      &

13010	IF F% THEN							      &
		I%=FND% AND (-2%)					      &
	ELSE								      &
		IF (D>=0%) AND (D<L.65536) THEN				      &
			V%=PEEK(FNL%(D) AND (-2%))			      &
	\		GOTO 13040					      &
	\	ELSE							      &
			PRINT #O%,"%Address exceeds PEEK limits"	      &
	\		EOF%=-1%					      &
	\		RETURN						      &
	!	END IF							      &
	! END IF							      &
		! FILE - EVEN OR ODD ADDRESS				      &
		! ELSE PEEK INTO CORE FOR ADDRESS CONTENTS IF VALID ADDRESS   &

13020	IF UDIV(D,BUFF.SIZ%)>=FILE.SIZE THEN				      &
		PRINT #O%,"%Address exceeds file limits"		      &
	\	EOF%=-1%						      &
	\	RETURN							      &
		! IS ADDRESS OUT OF FILE RANGE?				      &

13025	IF NFS% AND FBN% THEN						      &
		IF (D>=L.512) AND (D<(L.512*DCS%)) THEN			      &
			PRINT #O%,"%Address in inaccessible part of disk"     &
	\		EOF%=-1%					      &
	\		RETURN						      &
		! Check for address between boot block and pack label	      &

13030	D0=I%								      &
	\ D8%=(D0/2%) AND L.MAX						      &
	\ IF USE.CRASH%=0% THEN						      &
		V%=FNP%(H,D8%)						      &
	ELSE	IF ((D0/2%) AND L.MAX)<12032% THEN			      &
			V%=FNP%(H+1%,D8%)				      &
		ELSE	PRINT #O%,"%";"Address exceeds CRASH.SYS limits"      &
	\		I%=0%						      &
	\		EOF%=-1%					      &
	\		RETURN						      &
		! CRASH.SYS FILE CHECK ADDRESS WITHIN RANGE		      &
		! OPEN ADDRESS LOCATION					      &

13040	IF M0%=2% THEN							      &
		RETURN							      &
	ELSE	IF FND% AND 1% THEN					      &
			V%=SWAP%(V%)					      &
		! CONTENTS TO BE DISPLAYED AS WORD - RETURN		      &
		! CONTENTS TO BE DISPLAYED AS BYTE CHECK		      &
		! FOR EVEN/ODD ADDRES					      &

13050	V%=ASCII(CHR$(V%))						      &
	\ RETURN							      &
		! RETURN BYTE CONTENTS AS INTEGER			      &

13500	!*******************************************************************  &
	!		    - S U B R O U T I N E -			      &
	! This subroutine gets the input string and does an OCTAL to DECIMAL  &
	! conversion for any values input				      &
	!*******************************************************************  &
	!								      &
	A%,A0%,R2%,B=0%			!Initialize variables		      &

13510	GOSUB 14000			!Get a character		      &
	\ RETURN IF CHAR%<48% OR CHAR%>55% !Done if not an integer	      &
	\ A0%=1%			!Signal a number has been input	      &
	\ B=B*8%			!Bump current value by 10(8)	      &
	\ B=B+CHAR%-48%			!Add in new digit		      &
	\ Z=H				!Save current H			      &
	\ A%=FNL%(B)			!Break longword into integers	      &
	\ R2%=H				!				      &
	\ H=Z				!				      &
	\ GOTO 13510			!And loop			      &

14000	!*******************************************************************  &
	!		    - S U B R O U T I N E -			      &
	! This subroutine gets characters one at a time and interperts each   &
	! character value one at a time					      &
	!*******************************************************************  &
									      &
	IF C0%=0% THEN			!If no characters in string then      &
		KB.INP$=SYS(CHR$(4%))	!    Enable ODT submode		      &
	\	GET #1%			!    Get input from terminal	      &
	\	FIELD #1%, RECOUNT AS KB.INP$				      &
	\	C0%=1%			!    Start at first byte	      &
	\ END IF			!End if				      &
	\ CHAR%=ASCII(CVT$$(MID(KB.INP$,C0%,1%),32%))			      &
				 	!Get (next) character in string	      &
	\ GOTO 32600 IF CHAR%=26% 	!Quit if CTRL/Z			      &
	\ C0%=C0%+1%			!Bump to next byte		      &
	\ C0%=0% IF C0%>LEN(KB.INP$)	!Reinitialize if no more chars	      &
	\ RETURN			!All done			      &

14100	!*******************************************************************  &
	!		    - S U B R O U T I N E -			      &
	! This subroutine re-writes the currently modifed buffer to disk      &
	!*******************************************************************  &
	IF (H9=0%) AND FBN% THEN					      &
		CLOSE 2%						      &
	\	OPEN I$ FOR INPUT AS FILE 2%, RECORDSIZE (32767%+1%)+2%	      &
	! END IF							      &
		! Must re-open disk if we need to re-write boot block	      &

14110	PUT #2%+SWAP%(4%), BLOCK H9					      &
	\ D9%=0%							      &
	\ RETURN							      &
		! Re-write buffer, clear dirty flag, and return		      &

15000	!	F U N C T I O N S					      &

15010	DEF* FND%							      &
	\ X=UDIV(D,BUFF.SIZ%)						      &
	\ FND%=R							      &
	\ H=X								      &
	\ FNEND								      &
		! FND = ADDRESS LOCATION WITHIN RECORD			      &
		! H = RECORD NUMBER ADDRESS FALLS WITHIN		      &

15015	DEF* LONG FNL(L%, H%)						      &
	\ LSB = L%							      &
	\ MSB = H%							      &
	\ FNL = LNG							      &
	\ FNEND								      &
		! Build a long from two integers using (LNGBUF)		      &

15020	DEF LONG FNA(I0%) = FNL(A%(I0%), B%(I0%))			      &
		! Transforms two integer values from A%(I0%) and	      &
		! B%(I0%) into a long word				      &

15030	DEF* FNL%(LONG D)						      &
	\ LNG = D							      &
	\ H, H% = MSB							      &
	\ FNL%, X = LSB							      &
	\ FNEND								      &
		! Breaks long word into integer components		      &
		!	H = HIGH ORDER VALUE				      &
		!	X  = LOW ORDER VALUE				      &

15040	DEF* FNP%(LONG H, WORD L)					      &
	\ IF (NFS% AND FBN%) THEN					      &
		H = H - (DCS% - 1%) IF H > 0%				      &
	  ELSE								      &
		H = H + 1%						      &
		! Convert LBN to (FBN-1%) for blocks other than boot block    &
		! Otherwise, RECORD number is one-based, not zero-based.      &

15050	GOTO 15070 IF H=H9						      &
	\ GOSUB 14100 IF D9%						      &
	\ GOTO 15060 UNLESS FBN% AND ((H9=0%) OR (H=0%))		      &
	\ IF (H9=0%) THEN F$=I0$ ELSE F$=I$				      &
		! Field value if already in current buffer		      &
		! Write out current buffer if dirty			      &
		! Get new record unless current or last block is boot block   &
		! Choose filename to open based on how we need to access disk &

15055	CLOSE 2%							      &
	\ OPEN F$ FOR INPUT AS FILE 2%, RECORDSIZE (32767%+1%)+2%	      &
		! Re-open file in proper mode (Block or Cluster)	      &

15060	GET #2%+SWAP%(4%), BLOCK H					      &
	\ H9=H								      &
		! Get new record, update current record number		      &

15070	FIELD #4%, 2%*L AS P$, 2% AS P$					      &
	\ FNP%=SWAP%(CVT$%(P$))						      &
	\ FNEND								      &
		! PERFORMS FILE I/O					      &

15100	DEF LONG UDIV(LONG DIVIDEND, WORD DIVISOR)			      &
	\ R = 0%							      &
	\ FOR J% = 1% TO 32%						      &
	\	R = R * 2% + ((DIVIDEND < 0%) AND 1%)			      &
	\	DIVIDEND = DIVIDEND * 2%				      &
	\	IF (R >= DIVISOR) THEN					      &
			R = R - DIVISOR					      &
	\		DIVIDEND = DIVIDEND + 1%			      &
	\	END IF							      &
	\ NEXT J%							      &
	\ UDIV = DIVIDEND						      &
	\ FNEND								      &
		! 32-BIT UNSIGNED DIVIDE BY 15-BIT INTEGER		      &
		! REMAINDER IS RETURNED IN R				      &
		! TRUST ME.  (OR LOOK AT THE ERROR LOGGER)		      &
		!	TO MAKE IT DIVIDE BY A 16-BIT UNSIGNED VALUE,	      &
		!	DIVISOR MUST BE CONVERTED TO A LONGWORD, AS	      &
		!	IN FNL(DIVISOR,0%)				      &

19000	!								      &
	!	E R R O R     H A N D L I N G				      &
	!								      &
	RESUME 32767 IF ERR=28% OR (ERR=11% AND ERL=1030%)		      &
	\ PRINT IF CCPOS(0%)						      &
	\ IF ERL=1080% THEN						      &
	\	PRINT "?Error opening ";I$				      &
	\	PRINT ERT$(ERR)						      &
	\	RESUME	1030						      &
	\ END IF							      &
	\ IF ERR=10% AND ERL=13010% THEN				      &
	\	PRINT "?RDMEM privilege required"			      &
	\	RESUME	1030						      &
	\ END IF							      &
	\ IF ERR=18% AND ERL=11040% THEN				      &
	\	PRINT "%Write access not permitted"			      &
	\	PRINT "?SYSMOD privilege required"			      &
	\	RESUME	11045						      &
	\ END IF							      &
	\ PRINT "??Unexpected error in ODT"				      &
	\ PRINT ERT$(ERR);" at line ";ERL				      &
	\ RESUME 32767							      &

30000	!								      &
	!	C C L    E N T R Y					      &
	!								      &
	I$=SYS(CHR$(7%))			!Get core common	      &
	\ I$=RIGHT(I$,INSTR(1%,I$,"ODT")+3%)	!Strip off ODT part	      &
	\ GOTO 1020 UNLESS LEN(I$)		!Start fresh if no parameters &
	\ GOTO 1040				!Otherwise start in middle    &

32600	!CTRL/Z typed, write out current buffer if dirty...		      &

32610	GOSUB 14100 IF D9%						      &
	\ CLOSE 1%,2%,3%,4%						      &

32767	END
