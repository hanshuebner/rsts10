	.TITLE EGCML EXTENDED GET COMMAND LINE
	.IDENT	/06.02/
;
;    COPYRIGHT (c) 1984, 1985, 1986, 1987, 1988, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD
;	 MASSACHUSETTS.  ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE  IS  FURNISHED  UNDER  A LICENSE AND MAY BE USED
; AND  COPIED  ONLY IN  ACCORDANCE WITH THE TERMS OF SUCH LICENSE
; AND WITH  THE INCLUSION  OF THE ABOVE  COPYRIGHT  NOTICE.  THIS
; SOFTWARE  OR ANY OTHER  COPIES  THEREOF, MAY NOT BE PROVIDED OR
; OTHERWISE MADE  AVAILABLE TO ANY OTHER PERSON.  NO TITLE TO AND
; OWNERSHIP OF THE SOFTWARE IS HEREBY TRANSFERRED.
;
; THE INFORMATION  IN THIS DOCUMENT IS SUBJECT  TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT  BY  DIGITAL
; EQUIPMENT CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF
; ITS SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.
;
;
;
;
; PREVIOUSLY MODIFIED BY:
;
;	R. D. Haney
;	M. S. Harvey
;	J. R. Kauffman
;	D. M. Knox
;	P. J. Kobar
;	L.    Siler
;
; MODIFIED FOR RSX-11M-PLUS V4.1 BY:
;
;	R. D. Haney	02-Nov-87
;		RDH134	Accept long initial command line	07069	06.01
;			from MCR
;
;
; MODIFIED FOR RSTS V10.1 BY:
;
;
;	S. E. LeVan	23-May-91
;
;		SEL001 Add RSTS-specific conditionals
;

; HISTORY

;
; THIS IS A FUNCTIONAL EQUIVALENT TO SEVERAL VERSIONS OF THE SYSTEM LIBRARY
; GET COMMAND LINE SERVICE ROUTINE. IT COMBINES THE EARLIER FCS-11 AND RMS-11
; BASED VERSIONS AS WELL AS THE EXTENDED VERSION USED BY THE INDIRECT
; COMMAND PROCESSOR. INCLUDED ARE THE FUNCTIONS REQUIRED BY THE
; SOS EDITOR AND THE F4V FORTRAN COMPILER UNDER VMS. NEW SERVICES INCLUDE
; SUPPORT FOR PROCEDURE LIBRARIES AND FULL FUNCTIONAL TERMINAL DRIVERS.
;


;
; VERIFY CONDITIONAL ASSEMBLY COMBINATIONS
;

;
; ASSEMBLY CONDITIONALS USED BY EGCML:
;
; FCS$$	DEFINED IF THE FILE SYSTEM IS FCS-11
; RMS$$ DEFINED IF THE FILE SYSTEM IS RMS-11
;
; LIB$$ DEFINED IF SUPPORT FOR UNIVERSAL LIBRARIES IS INCLUDED
;
; RSX$$ DEFINED IF OPERATON UNDER RSX-11M/RSX-11M-PLUS
; IAS$$ DEFINED IF OPERATON UNDER IAS/RSX-11D
; R$$VMS DEFINED IF EXTENDED OPERATION UNDER THE VMS AME IS INTENDED
;
; TTD$$ DEFINED IF A FULL FUNCTION TERMINAL DRIVER IS AVAILABLE
; MCM$$ DEFINED IF MULTIPLE COMMANDS PER LINE ARE SUPPORTED
;
; PT1$$ DEFINED IF THIS ASSEMBLY IS FOR PART 1 OF EGCML
; PT2$$ DEFINED IF THIS ASSEMBLY IS FOR PART 2 OF EGCML
; PT3$$ DEFINED IF THIS ASSEMBLY IS FOR PART 3 OF EGCML

;
; ESTABLISH DEFAULT ASSEMBLY CONDITIONALS
;
	.IF NDF PT1$$ & PT2$$ & PT3$$	; IF NEITHER PART1/2 ARE DEFINED
	PT1$$ = 0			; DEFINE THEM BOTH
	PT2$$ = 0			; FOR A MONOLITHIC EGCML
	PT3$$ = 0			;
	.ENDC

	; ADJUST TITLE TO REFLECT THE REAL PART OF THE MODULE

	.IIF DF PT1$$ 	.TITLE EGCML EXTENDED GET COMMAND PART 1
	.IIF DF PT2$$	.TITLE EGCML2 EXTENDED GET COMMAND PART 2
	.IIF DF PT3$$	.TITLE EGCML3 EXTENDED GET COMMAND PART 3

	 ; FOR THE MONOLITHIC EGCML
	.IIF DF PT1$$&PT2$$&PT3$$ .TITLE EGCML EXTENDED GET COMMAND

	.IIF NDF RMS$$&FCS$$ FCS$$=0	; FCS-11 IS DEFAULT
	.IIF NDF RSX$$&IAS$$&R$$VMS RSX$$=0 ; RSX IS DEFAULT
	.IIF NDF LIB$$	LIB$$=0		; LIBRARIES SUPPORTED
	.IIF NDF TTD$$	TTD$$ = 0	; FULL FUNCTION TERMINAL SERVICE


	F$SYST=0			; INITIALIZE CONDITIONALS CODE
	.IIF DF FCS$$ F$SYST=F$SYST ! 1 ; SET FCS-11 FLAG
	.IIF DF RMS$$ F$SYST=F$SYST ! 2 ; SET RMS-11 FLAG

	.IIF EQ <F$SYST - 3> .ERROR	; MULTIPLE FILE SYSTEM DEFINITIONS
	.IIF EQ <F$SYST - 0> .ERROR	; NO FILE SYSTEM DEFINED

	.IIF DF LIB$$ F$SYST=F$SYST ! 10 ; NOTE LIBRARY SUPPORT AVAILABLE
	.IIF DF R$$VMS F$SYST=F$SYST ! 20 ; OPERATING SYSTEM IS VMS AME
	.IIF DF RSX$$ F$SYST=F$SYST ! 40 ; OPERATING SYSTEM IS RSXM/S/M-PLUS
	.IIF DF IAS$$ F$SYST=F$SYST ! 100 ; OPERATING SYSTEM IS IAS/RSX-11D

;
; DEFINE MACROS
;

	.MCALL .PCODE,.PDATA,.IDATA ; GET THE PSECT DEFINITIONS
	.MCALL EGCMI$		; GET DEFINITIONS FOR NEW INTERFACE
	.MCALL DIR$		; GET DEFINITIONS FOR SYSTEM MACROS
	.MCALL CSI$,CSI$1,CSI$2	; GET COMMAND STRING MACRO DEFINITIONS

	.IF NDF	R$RSTS		;SEL001 - Skip next code if RSTS 
	.IF NDF	R$$VMS

	.MCALL	CSI$4 		; GET COMMAND STRING MACRO DEFINITIONS
	.MCALL	FEAT$S			; GET FEATURE MASK DIRECTIVE

	.ENDC	;not R$$VMS
	.ENDC	;not R$RSTS

	.IF DF FCS$$		; IF FCS-11

	.MCALL	FDOF$L,FCSBT$	; GET FDB DEFINTIONS
	.MCALL FINIT$,OFNB$,CLOSE$	; GET FCS-11 MACRO DEFINITIONS
	.MCALL GET$,GET$S
	.GLOBL .PARSE,.POINT,.MARK,.DLFNB ; DEFINE OTHER FCS-11 ENTRYS USED
	.GLOBL .PRSFN,.XQIO,.FSRPT	;

	.ENDC

	.IF DF RMS$$

				; GET RMS-11 MACRO DEFINITIONS
	.ENDC

;
; REGISTER SAVE MACRO DEFINITIONS
;
	.MACRO	.SAVR1
	JSR	R5,.SAVR1	; SAVE R1-R5
	.ENDM

	.MACRO	.SAVVR
	JSR	R2,$SAVVR	; SAVE R0-R2
	.ENDM

	.MACRO	.SAVNR
	JSR	R5,$SAVRG	; SAVE R3-R5
	.ENDM

	.MACRO	CALLR	DES
	JMP	DES		; DES WILL ISSUE RETURN
	.ENDM

;
; DEFINE GCML DATA BLOCK OFFSETS AND FLAGS
;

	EGCMI$			; ESTABLISH NEW GCML INTERFACE CONTEXT
	GCMLD$			; DEFINE GCML BLOCK OFFSETS
	CSI$			; DEFINE CSI BLOCK OFFSETS

	.IF DF FCS$$		; IF FCS-11 FILE SERVICES

	FDOF$L			; DEFINE FDB OFFSETS
	FCSBT$			; DEFINE FDB BIT VALUES

	.ENDC
;
; DEFINE OTHER LOCAL SYMBOLS
;

	SPACE = 040		; SPACE CHARACTER
	TAB = 011		; TAB
	ATSIGN = '@		; INDIRECT FILE MARK
	SCOLON = ';		; SEMI-COLON, COMMENT MARKER
	EXCLAM = '!		; EXCLAMATION MARK, COMMENT MARKER
	VERBAR = '|		; VERTICAL BAR, MULTI COMMAND SEPARATOR
	RBRACKT = '>		; RIGHT BRACKET, PROMPT CHARACTER
	SLASH = '/		; SLASH
	HYPHEN = '-		; HYPHEN, CONTINUATION CHARACTER
	UNDLIN = '_		; UNDERLINE, CONTINUATION PROMPT CHARACTER

	SAVMOD = GE.SDE!GE.SLB	; BITS TO SAVE WHEN NESTING FILE
	NULCMD = 033		; NULL COMMAND IS ESCAPE
	SIZRFA = G.PLFS-G.SRWP	; BYTE COUNT OF A FILE "RFA"
;
; DEFINE OFFSETS INTO FILE DESCRIPTOR
;
	N.FNSZ = 10		; SIZE IF FILENAME STRING
	N.FNPT = 12		; POINTER TO FILENAME STRING
;
; SWITCHES IN MODE WORD
;
	SWITS = GE.SLB ! GE.SER ! GE.SDE
;
; SWITCHES WHOSE EFFECT IS ONLY ONE INDIRECT LEVEL
;
	SWITA = GE.SLB ! GE.SER ! GE.SDE
;
; SWITCHES WHOSE EFFECT IS SET UNTIL NEGATED.
;
	SWITB = 0


;
; COMPUTE SIZE OF TEMPORARY WORK BUFFER
;

	SZULHD = <42.*2>	; SIZE OF UNIVERSAL LIBRARY HEADER
	SZGCML = <42.*2>	; SIZE OF GCML$ DPB
	WORKBF = SZGCML		; ASSUME DPB IS LARGER
	.IIF GT C.SIZE-WORKBF WORKBF = C.SIZE
				; PICK LARGER OF CSI$ BLOCK AND
				; GCML$ DPB
	.IIF GT SZULHD-WORKBF WORKBF = SZULHD
				; PICK LARGER OF WORK BUFFER AND
				; UNIVERSAL LIBRARY HEADER
	.PAGE

	.PCODE			; PURE CODE SECTION

	.IF DF PT1$$		; THIS CODE GOES IN PART 1

;
; GET COMMAND LINE
;

$GCML::
	.SAVR1			; SAVE R1-R5
	MOV	R0,R5		; R5 ALWAYS POINTS TO IMPURE TABLE AREA

	SUB	#WORKBF,SP	; CREATE A TEMPORARY WORK BUFFER
	MOV	SP,G.CSIB(R5)	; AND POINT TO IT. THIS WILL BE USED FOR
				; THE GMCR$ DPB AND CSI$ DATA BLOCK

	MOV	#GE.VRS,R0	; ASSUME A MISMATCH BETWEEN THE IMPURE AREA
				; FORMAT AND THIS ROUTINE
	CMPB	#G.ISIZ,G.IMPS(R5) ; COMPARE EXPECTED SIZE WITH REAL SIZE
	BNE	12$		; BR IF MISMATCH

	MOV	G.BUFF+2(R5),G.CMLD+2(R5) ; INITALIZE OUTPUT ADDRESS
	BIC	#GE.IEF,(R5)	; RESET "INTERMEDIATE EOF SEEN" FLAG
				; THE GMCR$ DPB AND CSI$ DATA BLOCK

	MOVB	G.FUNC(R5),R0	; PICK UP FUNCTION CODE
	CMP	#MAXCMD,R0	; IS THE FUNCTION LEGAL?
	BLO	10$		; BR IF NOT

	MOV	#20$-5$,-(SP)	; FAKE A "JSR,PC" ON THE STACK
	ADD	PC,(SP)		; IN A PIC FASHION
5$:
	ASL	R0		; CONVERT TO WORD OFFSET
	ADD	R0,PC		; AND JUMP INTO DISPATCH TABLE

	BR	GCML9		; 0= GET COMMAND
	BR	GCML1		; 1= RESET COMMAND SERVICE
	BR	GCML2		; 2= CLOSE TOP LEVEL COMMAND
	BR	GCML3		; 3= OBTAIN MCR COMMAND LINE ONLY
	BR	GCML4		; 4= RESUBMIT LINE FOR SCAN
	BR	9$		; 5= CHAIN TO NEW FILE
	BR	GCML6		; 6= RESET MCR EOF FLAG
	BR	GCML7		; 7=POP ONE LEVEL OF NESTED COMMAND FILE

	MAXCMD = 7		; MAXIMUM LEGAL FUNCTION CODE
;
; RELAY JUMPS
;
9$:	CALL	..LCM5		; OPEN NEW FILE.  IF SUCCESSFUL, TOP ENTRY
				;   ON FILE STACK WILL CONTAIN CONTEXT OF
				;   FILE BEING DEPARTED
	BCS	910$		; DID NOT SUCCEED.  DO EXIT SERVICES
	MOV	G.PPTR(R5),R4	; POINT TO TOP OF STACK
	ADD	#G.PLFS,G.PPTR(R5) ; ELIMINATE TOP ENTRY FROM STACK
	MOV	G.PPTR(R5),R3	; SETUP TO MOVE RFA INFO
	MOV	(R4)+,(R3)+	; MOVE RFA INFO.  IT RELATES TO THE FILE
	MOV	(R4)+,(R3)+	;   TO WHICH WE .CHAINED AND NEEDS TO BE
	MOV	(R4),(R3)	;   LOCATED AT TOP OF NEW STACK ENTRY
	DECB	G.CDEP(R5)	; AND DECREMENT THE NESTING LEVEL
910$:
	RETURN			; RETURN TO EXIT SERVICES AT $20:


10$:
	MOV	#GE.CMD,R0	; SETUP FOR COMMAND FUNCTION CODE ERROR
12$:
	SEC			; FLAG ERROR
				; AND FALL THROUGH INTO EXIT SERVICE

;
; COMMON EXIT POINT
;
; THE INDIVIDUAL ROUTINES RETURN HERE WITH CARRY SET OR CLEAR
; INDICATING SUCCESS OR ERROR
; OUTPUT:
; C/SET => ERROR
;	R0 = THE ERROR VALUE IF IT IS A GCML GENERATED
;	R0 = 0 IF THE ERROR IS TO BE TAKEN FROM
;	THE FILE DATABASE ERROR VALUE
;
; C/CLR => SUCCESS
;
20$:
	MOVB	#IS.SUC,G.ERR(R5) ; INITALIZE RETURN TO SUCCESS
	BCC	30$		; BR IF SUCCESS

	MOVB	R0,G.ERR(R5)	; ASSUME GCML GENERATED ERROR
	BNE	30$		; BR IF INTERNAL ERROR
	MOV	G.FILE(R5),R0	; POINT TO FILE TABLE

	.IF DF FCS$$		; IF THIS IS AN FCS-11 GCML

	MOVB	F.ERR(R0),G.ERR(R5) ; AND RETURN THE ERROR CODE VALUE

	.ENDC

	.IF DF RMS$$		; IF THIS IS AN RMS-11 GCML


	.ENDC
30$:
	ROR	WORKBF(SP)	; SAVE ERROR INDICATION

	CALL	..GCOC		; IS THE FILE OPEN
	BEQ	40$		; BR IF NOT, NO FILE EXPAND IS NECESSARY
	MOV	G.FQFN(R5),R0	; DOES THE USER WANT THE FULLY QUALIFIED FILE
				; NAME SPECIFICATION?
	BEQ	40$		; BR IF NO BUFFER ADDRESS SUPPLIED
	TSTB	(R0)		; DOES THE BUFFER NEED REFRESHING?
	BNE	40$		; NO SKIP CALL TO EXPAND
	CALL	..GCEF		; EXPAND THE FILENAME STRING
40$:
	ADD	#WORKBF,SP	; REMOVE TEMPORARY WORK BUFFER

	BIT	#GE.CLO,(R5)	; ARE WE TO CLOSE THE TOP LEVEL?
	BEQ	42$		; BR IF NOT

	CALL	..GCPC		; CLOSE THE TOP LEVEL IF IT IS OPEN
42$:
	ROL	(SP)		; RESTORE ERROR FLAG

	MOVB	#F$SYST,G.FUNC(R5) ; LEAVE AN ASSEMBLY OPTIONS MASK FOR
				; THE CALLER IF HE CARES.
	MOV	R5,R0		; RESTORE DATA POINTER
	RETURN			; AND RETURN TO CALLER

	.PAGE
	.ENABL LSB

;
; RESET COMMAND SERVICE TO TOP LEVEL
;
GCML1:
	TSTB	G.CDEP(R5)	; AT TOP ALREADY?
	BLE	30$		; YES, RETURN SUCCESS
10$:
	DECB	G.CDEP(R5)	; BACK OFF THE NEST STACK A FRAME AT A TIME
	BEQ	20$		; BR IF DONE
	CALL	GCML7		; USE COMMON ROUTINE TO PERFORM PUSHDOWN
				; STACK ADJUSTMENT
	BR	10$		; LOOP FOR ALL FRAMES ON STACK
20$:
	INCB	G.CDEP(R5)	; FLAG LEVEL 1
	CALL	..GCRO		; OPEN TOP LEVEL AGAIN
30$:
	CLR	G.FRAG+0(R5)	; ENSURE NO RESIDUAL FRAGMENT
	;CLC			; FLAG SUCCESS
	RETURN			; AND RETURN TO COMMON EXIT SERVICE


;
; CLOSE CURRENT INPUT FILE
;
GCML2:
	CALLR	..GCPC		; PUSH THE CONTEXT OF THE TOP FILE TO THE
				; INTERNAL STACK AND CLOSE THE FILE
	;RETURN			; TO CALLER WITH CLOSE ERROR CODE


;
; GCML3 -- OBTAIN MCR COMMAND LINE ONLY
;
GCML3:
	TSTB	G.CDEP(R5)	; WHAT DEPTH ARE WE?
	BGE	120$		; BR IF NOT A INITALIZE LEVEL

	MOV	G.BUFF+0(R5),R4	; SET BUFFER MAXIMUM SIZE
	MOV	G.BUFF+2(R5),R3	; AND BUFFER ADDRESS

	CALL	..GCGM		; OBTAIN MCR COMMAND LINE IF ANY

	MOV	R2,G.CMLD+0(R5)	; RETURN LINE TO CALLER
	MOV	R1,G.CMLD+2(R5)	; ADDRESS

	RETURN			; TO CALLER
;
; GCML4 -- RESUBMIT LINE FOR SCAN
;
GCML4:
	CALLR	GCML41		; JOIN COMMON SCAN


;
; GCML6 -- RESET MCR LEVEL EOF FLAG
;
GCML6:
	CALL	GCML1		; USE COMMON ROUTINE TO RESET TO
				; LEVEL 1.
	BIC	#GE.MCR,(R5)	; RESET THE MCR EOF FLAG
	DECB	G.CDEP(R5)	; SET DEPT TO LEVEL 0
	RETURN			; AND RETURN
120$:
	MOV	#GE.CMD,R0	; SET ERROR CODE
	SEC			; NOT YET IMPLEMENTED
130$:
	RETURN

;
; GCML7 -- DISCARD TOP COMMAND FILE
;
GCML7:
	CALL	..GCOC		; IS THE TOP FILE OPEN?
	BNE	140$		; BR IF IT IS

	ADD	#G.PLFS,G.PPTR(R5) ; REMOVE ONE WHOLE STACK FRAME FROM
				; PUSHDOWN LIST
	RETURN			; AND THAT IS ALL
140$:
	CALLR	..GCRO		; CLOSE THE TOP FILE AND DELETE IF DESIRED
	;RETURN			; RETURN TO CALLER

	.DSABL LSB
	.PAGE

;
; GCML9 -- GET NEXT COMMAND LINE
;

	.ENABLE LSB
GCML9:
	CLR	G.CMLD+0(R5)	; RESET THE OUTPUT COMMAND SIZE

;
; LEVEL REFERENCES THE NESTING AND INITALIZATION LEVEL OF GCML
;
;	LEVEL = -1 BEFORE THE FIRST CALL TO GCML
;	      =  0 AFTER THE CALL TO ..GCGM AND FOR ALL DEFAULT
;			LUN ASSIGNMENT READS.
;	      >= 1 IF EITHER THE TOP LEVEL FILE HAS BEEN PUSHED
;			AND CLOSED OR A FILE NEST "@FILESPEC" HAS
;			BEEN PROCESSED.
;
20$:
	MOV	G.BUFF+2(R5),R3	; LOAD POINTER TO LINE BUFFER
	MOV	G.BUFF+0(R5),R4	; AND MAXIMUM SIZE
	MOVB	#RBRACK,G.DFPR+5(R5) ; SETUP PROMPT FOR TERMINAL READ
25$:
	.IF DF MCM$$		; IF MULTIPLE LINES ARE SUPPORTED

	TST	G.FRAG+0(R5)	; ANY FRAGMENT LEFT?
	BEQ	30$		; BR IF NOT
	CALL	..GCGF		; OBTAIN NEXT FRAGMENT FROM RESIDUAL BUFFER
	BNE	70$		; IF ANY OBTAINED, GO SCAN IT
30$:
	.ENDC

	TSTB	G.CDEP(R5)	; WHAT LEVEL ARE WE AT?
	BEQ	40$		; BR IF WE ARE AT LEVEL 0
	BGT	50$		; BR IF PROCESSING INDIRECT FILES
				; IF AT INITIAL LEVEL =-1,
	CALL	..GCGM		; TRY TO OBTAIN AN MCR COMMAND
	MOV	#GE.RBG,R0	; ASSUME BUFFER OVERFLOW ERROR
	BCS	95$		; BR IF LINE OVERFLOW ERROR

	TST	R2		; WAS A LINE RETURNED?
	BNE	70$		; BR IF YES, GO SCAN IT

	CALL	..GCTO		; GO OPEN THE TOP LEVEL FILE USING ASSEMBLED
				; DEFAULT FILE NAME BLOCK (USUALLY THE TERMINAL)
	BCS	95$		; BR IF OPEN ERROR
	BR	20$		; IF NO MCR COMMAND LINE, GO REFRESH
				; LINE BUFFER POINTER AND SIZE. SINCE
				; WE ARE NOW NOT AT LEVEL=-1, WE WILL ATTEMPT
				; TO READ FROM THE TERMINAL/FILE.
40$:
	BIT	#GE.MCR,(R5)	; DID WE HAVE MCR COMMAND INPUT?


	.IF DF R$$VMS		; IF AME-11/VMS COMPATABILITY MODE
	BEQ	50$		; BR IF NO MCR LINE WAS PICKED
	CALL	..GCGM		; GET THE NEXT COMMAND FROM THE AME
	BCS	94$		; AND EXIT ON ANY ERROR
	TST	R2		; WAS A COMMAND LINE RETURNED BY THE AME?
	BEQ	94$		; IF EQ NO, ALL DONE, RETURN TO TOP LEVEL EOF
	BR	70$		; OTHERWISE, GO SCAN IT

	.IFF			; IF NOT VMS AME

	BNE	94$		; YES, ALL DONE, GO RETURN TOP LEVEL EOF

	.ENDC

50$:
	CALL	..GCOT		; OPEN TOP LEVEL IF NOT ALREADY OPEN
	BCS	95$		; BR IF RE-OPEN ERROR
	CALL	GETFIL		; OBTAIN THE INPUT LINE FROM THE FILE

	BCC	70$		; BR IF READ SUCCESS
	CMPB	#IE.EOF,R0	; WAS THIS AN END FILE ON READ
	BNE	95$		; BR IF NOT, OTHER ERROR
	TSTB	G.CDEP(R5)	; WHAT LEVEL ARE WE AT
	BEQ	95$		; BR IF AT LEVEL 0, RETURN TOP LEVEL EOF

	BIS	#GE.IEF,(R5)	; SET FLAG THAT INTERMEDIATE EOF WAS SEEN
	BIT	#GE.RWD,(R5)	; DOES THE CALLER WANT AUTOMATIC REWIND?
	BEQ	60$		; BR IF NOT, GO POP FILE

;
; REWIND THE FILE TO ITS ZERO POINT. IF THIS IS A LIBRARY THEN THE ZERO
; POINT IS SOMEWHERE IN THE MIDDLE OF THE LIBRARY. THE MODULE START
; POINT HAS BEEN SAVED ON THE PUSH DOWN STACK.
;
	MOV	G.FILE(R5),R0	; POINT TO FILE DATABASE

	.IF DF FCS$$		; IF FCS-11

	BITB	#FD.REC,F.RCTL(R0) ; IS THIS A RECORD DEVICE?
	BNE	60$		; BR IF NOT, WE CAN'T REWIND  RECORD DEVICES

	MOV	G.PPTR(R5),R4	; LOAD THE PUSHDOWN STACK POINTER

	CALL	..GCPR		; PICK UP THE REWIND POINT "RFA", POINT THE FILE
	CALL	..GCSR		; AND PUT THE RFA BACK ON THE STACK

	MOV	#GE.IOR,R0	; ASSUME I/O ERROR
	BCS	95$		; BR IF I/O ERROR ON POSITION OPERATION

	.ENDC

	.IF DF RMS$$		; IF RMS-11

	.ENDC

	BR	20$		; NOW GO READ FIRST LINE AGAIN
;
; AN END OF FILE WAS SEEN ON THE CURRENT FILE. CLOSE IT AND RESTORE
; THE CONTEXT OF THE PREVIOUSLY NESTED FILE.
;
60$:
	CALL	..GCRO		; RESTORE THE PREVIOUS FILE CONTEXT
	BR	20$		; GO READ NEXT LINE

;
; NOW SCAN THE LINE OBTAINED
;
70$:
	MOV	R2,G.CMLD+0(R5) ; ASSUME WE RETURN THIS LINE, SET LENGTH
	BEQ	20$		; IF NULL LINE RETURNED
	MOV	R1,G.CMLD+2(R5)	; ASSUME WE RETURN THIS LINE, SET ADDRESS

;
; COMMENT LINE CHECK
;
	CMPB	#SCOLON,(R1)	; IS THIS A COMMENT LINE?
	BNE	80$		; BR IF NOT
	BIT	#GE.COM,(R5)	; ARE COMMENTS WANTED?
	BEQ	130$		; YES, RETURN THIS LINE
	BR	20$		; NO, GO READ ANOTHER LINE

;
; CONTINUATION LINE CHECK
;
80$:
	BIT	#GE.CON,(R5)	; DOES THE USER WANT CONTINUATION LINES?
	BNE	85$		; BR IF YES
	CMPB	#HYPHEN,-1(R3)	; IS THIS A CONTINUATION LINE?
	BNE	85$		; BR IF NOT

	CMPB	-(R3),(R4)+	; BACK UP FREE SPACE POINTER AND COUNT
	BR	25$		; GO FOR MORE INPUT

;
; MULTIPLE COMMAND LINE CHECK
;
85$:
	.IF DF MCM$$		; IF MULTIPLE COMMAND LINES SUPPORTED

	TST	G.FRAG+0(R5)	; ARE WE PROCESSING A FRAGMENT?
	BNE	88$		; IF YES, SKIP "SET FRAGMENT" OPERATION
	BIT	#GE.MUL,(R5)	; ARE MULTIPLE LINES PERMITTED?
	BEQ	88$		; BR IF NOT. SKIP SCAN

	CALL	..GCSF		; CHECK FOR MULTIPLE COMMAND LINE

	MOV	R2,G.CMLD+0(R5)	; UPDATE SIZE IN CASE IT CHANGED
	MOV	R1,G.CMLD+2(R5)	; AND START ADDRESS IN CASE IT SHUFFLED

	.ENDC

;
; CASE SHIFT CHECK
;
88$:
	BIT	#GE.LC,(R5)	; DOES THE USER WANT LOWER CASE?
	BNE	90$		; BR IF YES

	CALL	CVTUC		; CONVERT LINE TO UPPER CASE
;
; INDIRECT FILE SPECIFICATION CHECK
;
90$:
	CMPB	#ATSIGN,(R1)	; IS THIS AN INDIRECT FILE NEST?
	BNE	130$		; NO, THATS ALL. RETURN THIS LINE

	BIT	#GE.IND,(R5)	; ARE INDIRECT FILES TO BE PROCESSED?
	BEQ	130$		; NO, RETURN THE LINE TO THE CALLER

GCML41:
	MOV	R1,G.CMLD+2(R5)	; AND REWRITE SAVED LINE DESCRIPTOR
	MOV	R2,G.CMLD+0(R5)	;
	CMPB	(R1)+,-(R2)	; ADJUST POINTER AND COUNT OVER "@"

	CALL	CVTUC		; UPCASE THE FILE NAME AND POSSIBLE SWITCHES

	CALL	..GCAT		; PARSE INDIRECT FILE SPECIFICATION
	BCS	96$		; BR IN INDIRECT OPEN ERROR

	BIT	#GE.FOP,(R5)	; RETURN AFTER OPEN?
	BNE	130$		; BR IF YES, USER WANTS TO SEE THIS LINE
	JMP	GCML9		; BR IF NOT, GO READ FROM NEW FILE

;
; TOP LEVEL EOF REURN
;
92$:
	CALL	..GCCD		; CLOSE OR DELETE THE CURRENT FILE
	BIC	#GE.MCR,(R5)	; RESET THE FLAGS TO INITIAL STATE
	DECB	G.CDEP(R5)	; AND LEVEL TO -1
94$:
	MOV	#GE.EOF,R0	; RETURN END-OF-FILE STATUS
95$:
	CLR	G.CMLD+0(R5)	; NO COMMAND LINE IS RETURNED ON ERRORS
96$:
	SEC			; INDICATE ERROR RETURN
100$:
	RETURN			;
130$:
	CLC			; INDICATE NO ERROR
	RETURN			;

	.DSABL LSB
;
; CONVERT LINE TO UPPER CASE
;
CVTUC:
	.SAVVR			; SAVE R0,R1,R2
	MOV	R1,R0		; SET SOURCE ADDRESS SAME AS DESTINATION
	TST	R2		; VERIFY WE HAVE A POSITIVE BYTE COUNT
	BLE	10$		; SKIP UPCASE CALL IF NOT
	CALL	$CVTUC		; USE LIBRARY CONVERT ROUTINE
10$:
	RETURN			; AND RETURN TO CALLER

	.PAGE
	.ENDC			; END OF PART 1 CODE
	.IF DF PT3$$		; THE FOLLOWING CODE GOES IN PART 3

;
; ..GCGM - SUBROUTINE CONDITIONALLY GETS AN MCR LINE
;
; INPUT:
;	R3 = ADDRESS OF FREE SPACE TO PLACE LINE
;	R4 = FREE SPACE IN BUFFER
; OUTPUT:
;	R1 = ADDRESS OF RESULT
;	R2 = COUNT OF RESULT
;	R3,R4 = UPDATED TO REFLECT REMAINING FREE SPACE
;

..GCGM::
	CLRB	G.CDEP(R5)	; FORCE US TO LEVEL 0
103$:	MOV	G.CSIB(R5),R1	; POINT TO WORK BUFFER FOR USE AS DPB

	MOV	(PC)+,(R1)	; ADD THE DIC
		.BYTE 127.,41.	;
104$:
	DIR$	R1		; OBTAIN THE NEXT FRAGMENT OF THE COMMAND
	BCS	105$		; BR IF NO MORE

	MOV	@#$DSW,R2	; PICK UP CHARACTER COUNT
	TST	(R1)+		; POINT TO THE FIRST CHARACTER

	CLR	R0		; SET TERMINATING CHARACTER (IE. NULL)
	CALL	MOVECT		; MOVE COUNTED STRING
	BCC	1043$		; CONTINUE IF NO BUFFER OVERFLOW
	MOV	#GE.BIF,R0	; REPORT SYNTAX ERROR
	RETURN			; AND RETURN TO CALLER
1043$:
	CMPB	#'-,-1(R3)	; END WITH A "-"; I.E. IS THERE CONTINUATION
	BNE	1045$		; NO, PROCEED
	DEC	R3		; YES.  BACKUP ONE POSITION IN BUFFER
	INC	R4		; AND MAKE THAT SPACE AVAILABLE
	BR	103$		; GO BACK FOR THE CONTINUATION

1045$:
	MOVB	(R1),G.TERM(R5) ; SAVE THE TERMINATING CHARACTER FOR THE USER

105$:
	MOV	G.BUFF+0(R5),R2	; MAXIMUM SIZE OF LINE
	MOV	G.BUFF+2(R5),R1	; ADDRESS OF LINE

	SUB	R4,R2		; AND SUBTRACT FREE SPACE
	BLE	130$		; RETURN NOW IF NO COMMAND LINE
;
; NOW SCAN THE COMMAND LINE SKIPPING OVER THE TASK NAME WHICH PRECEEDS
; THE ACTUAL COMMAND.
;
110$:
	CALL	SKPSST		; SKIP TO A SLASH, SPACE, OR TABS
	CALL	SKPBLK		; PRESS OUT BLANKS AND TABS
	BEQ	130$		; BR IF CHARACTERS NOT RETURNED
	BIS	#GE.MCR,(R5)	; REMEMBER WE HAVE PICKED AN MCR LINE
130$:
	CLC
140$:
	RETURN

	.PAGE
;
; ..GCGF -- ISOLATE NEXT FRAGMENT FROM MULTIPLE LINE INPUT
;
; INPUT:
;	R3,R4 = DESCRIPTOR FOR FREE SPACE IN LINE BUFFER
; OUTPUT:
;	R1,R2 = DESCRIPTOR FOR NEXT FRAGMENT
;	R3,R4 = UPDATED TO REFLACE FREE SPACE IN LINE BUFFER
;
	.IF DF MCM$$		; IF MULTIPLE FRAGMENT LINES SUPPORTED

	.ENABLE LSB

..GCSF::
	ADD	R3,R4		; POINT TO END OF LINE BUFFER
	MOV	R2,R1		; AND COPY THE CHARACTER COUNT OF THE CURRENT
				; LINE.
10$:
	MOVB	-(R3),-(R4)	; SHUFFLE THE LINE TO THE END OF THE LINE BUFFER
	DEC	R2		; CREATING A FREE SPACE AT THE FRONT.
	BGT	10$		;

	MOV	R1,R2		; RESTORE CHARACTER COUNT
	MOV	R4,R1		; AND POINTER TO FRONT OF THE FREE SPACE
	ADD	R2,R4		; POINT BACK TO THE END OF THE BUFFER
	MOV	G.BUFF+2(R5),R3	; RESTORE BUFFER BASE ADDRESS
	SUB	R3,R4		; AND DERIVE THE REMAINING FREE SPACE
	BR	20$		; JOIN COMMON CODE BELOW TO ISOLATE THE FIRST
				; FRAGMENT.
;
; ..GCGF -- ISOLATE THE NEXT FRAGMENT FROM THE FRAGMENT LINE
;
; INPUT:
;	R1,R2 DESCRIBE THE SOURCE STRING FROM WHICH THE NEXT FRAGMENT IS
;		TO BE ISOLATED
;	R3,R4 DESCRIBE THE FREE SPACE REMAINING (IE ALL OF IT) IN THE
;		USER SUPPLIED LINE BUFFER.
;
; OUTPUT:
;	R1,R2 DESCRIBE THE RETURNED LINE FRAGMENT
;	R3,R4 DESCRIBE THE REMAINING FREE SPACE
;	G.FRAG+0,+2 DESCRIBE ANY RESIDUAL LINE FOR THE NEXT SCAN
;
; NOTE THAT THE 'RESIDUAL' IS SAVED IN THE SAME LINE BUFFER AS THE
; COMMAND FRAGMENT BEING RETURNED TO THE CALLER. IT IS ASSUMED THAT
; THE CALLER DOES NOT USE THE LINE BUFFER FOR ANY OTHER PURPOSE
; BETWEEN COMMANDS. THIS IS THE CASE FOR ALL KNOWN UTILITES.
;
..GCGF::
	MOV	G.FRAG+2(R5),R1	; LOAD THE FRAGMENT DESCRIPTOR
	MOV	G.FRAG+0(R5),R2	; LEFT OVER FROM THE LAST SCAN
	BEQ	40$		; BR IF NOTHING LEFT.
	CLR	G.FRAG+0(R5)	; INDICATE THAT WE WILL USE THE ENTIRE
				; RESIDUAL.
	CMPB	(R1)+,-(R2)	; ADJUST COUNT AND POINTER OVER SEPARATOR
20$:
	MOV	#VERBAR,R0	; SET THE COPY/SCAN TERMINATION CHARACTER
	CALL	MOVECT		; AND USE THE CHARACTER MOVE ROUTINE
				; CHARACTERS AT (R1,R2) ARE SHUFFLED TO
				; (R3,R4) UNTIL EITHER THE SOURCE COUNT (R2),
				; THE FREE SPACE COUNT (R4), OR THE TERMINATION
				; CHARACTER IS REACHED.
	MOV	#IE.RBG,R0	; ASSUME A BUFFER OVERFLOW ERROR (ACTUALLY NOT
				; POSSIBLE)
	BCS	40$		; AND RETURN ON ERROR

	MOV	R1,G.FRAG+2(R5)	; SAVE ANY RESIDUAL FOR THE NEXT SCAN
	MOV	R2,G.FRAG+0(R5)	;

	MOV	G.BUFF+2(R5),R1	; AND BUILD A DESCRIPTOR TO THE RESULT
	MOV	R3,R2		; COPY THE END-LINE POINTER
	SUB	R1,R2		; COUNT = END-START
40$:
	RETURN			; RETURN TO CALLER

	.DSABLE LSB

	.ENDC			; IF MULTIPLE FRAGMENT LINES SUPPORTED
	.PAGE
	.ENDC			; END OF PART 3 CODE
	.IF DF PT1$$		; FOLLOWING CODE GOES IN PART 1

;
; GETFIL -- GET NEXT COMMAND FROM FILE
;
; INPUT:
;	R3 = ADDRESS OF LINE
;	R4 = SIZE OF BUFFER TO PLACE LINE
;
; OUTPUT:
;	R0 = FINAL I/O STATUS
;	R1 = ADDRESS OF RESULT
;	R2 = SIZE OF RESUTL
;
GETFIL:
5$:
	MOV	G.FILE(R5),R0	; PICK UP FILE DATABASE ADDRESS

	.IF DF FCS$$		; IF FCS-11

	CMPB	#IE.EOF,@F.BDB(R0) ; IS THERE A DELAYED EOF FROM FCS-11?
	BEQ	35$		; BR IF YES, THIS 'FILE' IS DONE

	BITB	#FD.TTY,F.RCTL(R0) ; IS THIS A TERMINAL?
	BEQ	20$		; BR IF NOT A TERMINAL

	.ENDC

	.IF DF RMS$$

	.ENDC

;
; READ FROM TERMINAL
;
	MOV	G.PRMP+2(R5),R1	; PICK UP USER PROMPT ADDRESS
	MOV	G.PRMP+0(R5),R2	; AND SIZE
	BNE	10$		; BR IF USER SUPPLIED PROMPT

	MOV	R5,R1		; OTHERWISE POINT TO DEFAULT PROMPT
	ADD	#G.DFPR,R1	;
	MOV	#6.,R2		; SET FIXED SIZE "<CR><LF>XXX>"
10$:
	MOV	G.CSIB(R5),R0	; POINT TO WORK BUFFER

	MOV	R3,(R0)+	; PLACE I/O PARAMETERS IN BUFFER
	MOV	R4,(R0)+	; READ BUFFER ADDRESS AND SIZE
	MOVB	G.TIOP+0(R5),(R0)+ ; INSERT THE USER SUPPLIED TIMEOUT VALUE
	CLRB	(R0)+		; NULL
	MOV	R1,(R0)+	; PROMPT ADDRESS
	MOV	R2,(R0)+	; AND SIZE
	MOVB	G.TIOP+1(R5),(R0)+ ; INCLUDE USER SUPPLED PARAMETER
	CLRB	(R0)		;

	MOV	G.FILE(R5),R0	; LOAD FDB ADDRESS
	MOV	G.CSIB(R5),R3	; POINT TO PARAMETERS

	BIT	#GE.RPR,(R5)	; HAS AN IO.RPR FAILED ALREADY?
	BNE	13$		; BR IF YES, DON'T INCUR OVERHEAD AGAIN

	MOV	#IO.RPR,R1	; SET FUNCTION CODE
	BISB	G.TIOS(R5),R1	; 'OR' IN USER SUPPLIED SUBFUNCTIONS
	MOV	#6.,R2		; AND SET COUNT

	CALL	.XQIO		; AND ISSUE QIO

	CMPB	#IS.SUC,@F.BDB(R0) ; WAS THE FUNCTION CODE RECOGNIZED?
	BEQ	15$		; YES, CONTINUE BELOW
	CMPB	#IE.EOF,@F.BDB(R0) ; OR DID THE USER TYPE CONTROL-Z?
	BEQ	15$		; YES.
				; ANYTHING ELSE IS ASSUMED TO BE "DON'T
				; RECOGNIZE IO.RPR FUNCTION CODE".
	BIS	#GE.RPR,(R5)	; FLAG FAILURE SO WE DON'T DO THIS AGAIN
;
; THE 'READ-WITH-PROMPT' FAILED. SETUP AND ISSUE A WRITE PROMPT
; FOLLOWED BY A READ.
;
13$:
	MOV	#IO.WLB,R1	; SET FUNCTION CODE
	MOV	#2,R2		; SET COUNT OF PARAMETERS
	ADD	#6,R3		; AND POINT TO PROMPT ADDRESS/COUNT
	CALL	.XQIO		; ISSUE WRITE

	MOV	#IO.RLB,R1	; SET FUNCTION
	MOV	#2,R2		; SET COUNT AGAIN
	SUB	#6,R3		; POINT TO READ BUFFER PARAMETERS AGAIN
	CALL	.XQIO		; AND ISSUE READ
15$:
	MOV	(R3),R3		; RESTORE INPUT BUFFER ADDRESS
	MOV	R3,R1		; AND RESULT ADDRESS

	MOV	F.BDB(R0),R2	; GET I/O STATUS ADDRESS
	MOVB	1(R2),G.TERM(R5) ; SAVE TERMINATING CHARACTER
	MOV	(R2),R0		; RETURN I/O STATUS CODE
	CMPB	#IS.SUC,R0	; SUCCESS?
	BNE	60$		;

	MOV	2(R2),R2	; RETURN SIZE OF LINE READ
	BR	30$		; AND GO COMPUTE REMAINING FREE SPACE
;
; READ FROM FILE
;
20$:
	GET$S	FDB=G.FILE(R5),INADR=R3,MAXCNT=R4 ;

	MOV	F.NRBD+2(R0),R1	; SET RESULT ADDRESS
	MOV	F.NRBD+0(R0),R2	; AND SIZE
	MOVB	F.ERR(R0),R0	; AND RETURN THE FINAL I/O STATUS

;
; PROCESS LINE READ
;
30$:
	BCS	60$		; BR IF I/O ERROR
	MOVB	#UNDLIN,G.DFPR+5(R5) ; SETUP PROMPT FOR CONTINUATION LINE
				; INCASE WE RETURN HERE FOR TERMINAL READ
	ADD	R2,R3		; ADVANCE FREE SPACE ADDRESS BY SIZE READ
	SUB	R2,R4		; ADJUST REMAINING FREE SPACE
	MOV	G.BUFF+2(R5),R1	; RESTORE BUFFER BASE ADDRESS
	MOV	R3,R2		; COPY FILL POINTER
	SUB	R1,R2		; AND COMPUTE CHARACTERS RETURNED
	BR	40$		; GO RETURN LINE TO CALLER

35$:
	MOV	#IE.EOF,R0	; RETURN END OF FILE FROM DELAYED EOF
	SEC			; FLAG NOT SUCCESSFUL
	BR	60$		; AND RETURN

;
; DONE RETURN LINE TO CALLER
;
40$:
	CLC			; INDICATE NO ERRORS
	RETURN			; TO CALLER
60$:
	CMPB	#IE.EOF,R0	; WAS THIS AN END-FILE?
	BEQ	70$		; IF SO, RETURN IT
	MOVB	#GE.IOR,R0	; IF NOT, RETURN A "I/O ERROR" CODE
70$:
	SEC			; FLAG ERROR
	RETURN			;

	.PAGE
	.ENDC			; END OF PART 1 CODE
	.IF DF PT2$$		; THE FOLLOWING CODE GOES IN PART 2

;
; ..GCAT -- PROCESS "@FILENAME" COMMANDS
;
; IF PROCEEDURE LIBRARIES ARE SUPPORTED, GCML TREATS THE FOLLOWING POSSIBLE
; USER TYPEINS AS BELOW:
;
;			FILENAME SPECIFIED
;			YES			NO
;		-----------------------------------------------------------
;		    |			    / CUR=LIB | LOOKUP IN CURRENT LIBR
;	          Y | NEWLIB+MODULE	X--+	      |
;		    |			    \ CUR=FIL | LOOKUP IN CURRENT DIR.
;		    |
;   /LB:MODULE	    |
;		 NO | NEW LIB+.MAIN.	ILLEGAL
;		    |
;		    |
;  NO /LB SWITCH    | LOOKUP FILE	ILLEGAL
;
;		----------------------------------------------------------
;

;
; ..GCAT -- PARSE AN INDIRECT FILE REFERENCE
;
; INPUT:
;	R1 = ADDRESS OF LINE TO PARSE
;	R2 = COUNT OF LINE
;
;	THE CURRENT LINE CONTAINS A LEADING "@" INDICATING A NESTED
;	FILE.
;
; OUTPUT:
;	THE CURRENT INPUT FILE IS PUSHED AND CLOSED AND THE NEW FILE
;	REFERENCE IS OPENED.
;
	.ENABLE LSB

..GCAT::
	MOV	#GE.MDE,R0	; ASSUME MAXIMUM DEPTH EXCEEDED
	CMPB	G.CDEP(R5),G.MAXD(R5) ; AT MAXIMUM YET?
	BGE	40$		; BR IF YES, RETURN ERROR

;
; ENTER HERE FOR THE .CHAIN.  THIS WILL PRESERVE THE CONTEXT OF THE
; FILE BEING DEPARTED SO THAT IT CAN BE RESTORED CORRECTLY IF THE 
; OPEN FAILS ON THE NEW FILE
;

..LCM5::

	CALL	PSHNOC		; PUSH CURRENT FILE BUT DON'T CLOSE
				; IT JUST YET
	BR	5$		; SKIP ALTERNATE ENTRY POINT SETUP
;
; ON ENTRY HERE, R1,R2 REFERENCE THE LINE TO BE PARSED
;

..GCM5::
	CALL	..GCOT		; OPEN TOP LEVEL FILE IF NOT ALREADY OPEN
5$:
	CALL	CLOFIL		; NOW CLOSE THE TOP LEVEL FILE BUT LEAVE
				; THE CURRENT FILE ID AND DIRECTORY ID
				; FOR ANY SUBSEQUENT REOPEN
	CLR	G.LBMN(R5)	; RESET THE LIBRARY MODULE NAME STRING
;
; SINCE THE FILE SPEC CAN HAVE TRAILING PARAMETERS OR COMMENTS
; WE MUST SCAN FOR THE FIRST -BLANK/TAB- CHARACTER AND CALL THAT
; THE END OF THE FILE SPEC.
;
	MOV	R2,R3		; COPY COUNT OF LINE
8$:
	CALL	SKPSST		; SKIP TO BLANK, TAB, OR SLASH
	CMPB	#SLASH,(R1)	; DID A SLASH STOP THE SCAN?
	BNE	9$		; BR IF NOT

	CMPB	(R1)+,-(R2)	; ADVANCE OVER SLASH
	BR	8$		; AND KEEP SCANNING TO ISOLATE THE FILESPEC
9$:
	SUB	R2,R3		; COMPUTE THE REAL FILE SPECIFICER COUNT
	SUB	R3,R1		; AND ADJUST THE FILE SPEC ADDRESS POINTER
	MOV	R3,R2		; COPY REAL COUNT TO PROPER REGISTER

	CALL	CSIPRS		; PARSE FILE NAME REFERENCED BY R1,R2
	MOV	#GE.BIF,R4	; ASSUME BAD SYNTAX
	BCS	30$		; BR IF CSI PARSE ERROR
				; R0 = FILE DATASET DESCRIPTOR ADDRESS
				; R1 = CSI STATUS BITS
				; R2 = NEW CONTENTS OF G.MODE IF NEW FILE OK

	.IF DF LIB$$		; IF PROCEDURE LIBRARIES ARE SUPPORTED
;
; PROCEDURE LIBRARIES ARE SUPPORTED
;
	BITB	#CS.NMF!CS.DVF,R1 ; WAS A FILENAME SPECIFIED?
	BNE	11$		; BR IF IT WAS
;
; PROCESS A COMMAND OF THE FORM "@/LB:MODULE"
;
	TST	(R5)		; IS THE CURRENTLY OPEN FILE A LIBRARY
	BPL	10$		; BR IF NOT

	CALL	..GCOC		; LOAD FILE POINTER
	CALL	OPNFIL		; AND REOPEN IT IN ORDER TO REFRESH
				; THE FILE ATTRIBUTE INFORMATION IN THE
				; FDB.
	BR	13$		; AND JOIN LIBRARY LOOKUP
;
; CURRENT FILE IS NOT A LIBRARY, IGNORE THE "LB" SWITCH AND ASSUME THE
; USER IS REFERENCING ANOTHER FILE -IN THE SAME DIRECTORY- AS THE CURRENT
; NOTE THAT THIS ALLOWS A COLLECTION OF FILES TO EXIST IN A DIRECTORY OR
; IN A LIBRARY AND FOR A COMMAND OF THE FORM "@/LB:MODULE" TO REFERENCE
; THE CORRECT TARGET. FOR DEBUGGING THE FILES WILL BE LOOSE IN A DIRECTORY
; AND FOR PRODUCTION, PACKAGED IN A LIBRARY. THE INDIVIDUAL FILES WILL NOT
; HAVE TO CHANGE FOR EITHER CONFIGURATION TO WORK.
;
10$:
	BIC	#GE.SLB,R2	; TREAT THE NEW FILE AS A FILE,
				; INSTEAD OF AS A LIBRARY MODULE
	MOV	R5,R3		; BUILD POINTER TO PARSED MODULE NAME
	ADD	#G.LBMN,R3	;
	MOV	R3,N.FNPT(R0)	; PLACE IT IN THE DATASET DESCRIPTOR RETURNED BY
				; CSI
	MOV	#6,N.FNSZ(R0)	; AND OVERWRITE SIZE WITH MAXIMUM.

	ADD	#6,R3		; POINT BEYOND STRING
101$:
	TSTB	-(R3)		; SCAN BACKWARD ADJUSTING LENGTH COUNT
				; TO REAL COUNT
	BNE	102$		; BR IF NO MORE NULLS
	DEC	N.FNSZ(R0)	; ADJUST COUNT
	BR	101$		; AND KEEP SCANNING
102$:
	CALL	CHNOPN		; ATTEMPT TO OPEN THIS FILE IN THE SAME
				; DIRECTORY AS THE PREVIOUS FILE
	BR	14$		; AND JOIN COMMON PROCESSING CODE
11$:
	CALL	NEWOPN		; OPEN NEW FILE OR LIBRARY
	MOV	#GE.OPR,R4	; ASSUME OPEN ERROR
	BCS	30$		; BR IF OPEN ERROR

	TST	R2		; WAS AN "/LB" SWITCH SEEN?
	BMI	13$		; YES, BR IF WE JUST OPENED A LIBRARY

	.IF DF FCS$$		; IF FCS-11 IS THE FILE SYSTEM

	MOV	G.FILE(R5),R0	; PICK UP FILE DATABASE
	CMP	#512.,F.RSIZ(R0) ; IS THE RECORD SIZE SO LARGE THAT IT MIGHT
				; BE A LIBRARY?
	.ENDC

	.IF DF RMS$$		; IF RMS-11 IS THE FILE SYSTEM

	.ENDC

	BHI	14$		; SURELY NOT, CONTINUE TO ASSUME ITS A COMMAND
				; FILE.

	.IF DF FCS$$		; IF FCS-11 IS THE FILE SYSTEM

		NOTDSK = FD.REC ! FD.CCL ! FD.TTY ! FD.SDI ! FD.SQD

	BITB	#NOTDSK,F.RCTL(R0) ; IS THIS NOT A DISK?
	BNE	14$		; YES. DON'T TRY LOOKUP ON ANYTING ELSE

	.ENDC

	BIS	#GE.SLB,R2	; ASSUME IT IS A LIBRARY AS THOUGH SO SPECIFIED
	CALL	60$		; ATTEMPT A LOOKUP OF THE ".MAIN." MODULE
	BCC	14$		; AH HA. IT WAS A LIBRARY

	BIC	#GE.SLB,R2	; RESET LIBRARY ASSUMPTION
	CALL	CLOFIL		; CLOSE THE FILE TO RESET ITS CONTEXT
	CALL	OPNFIL		; AND RE-OPEN IT
	BR	14$		; AND CONTINUE AS THOUGH WE HADNT MESSED UP
;
; USER WANTS A COMMAND LIBARARY. OPEN THE LIBRARY FILE AND LOOKUP
; THE INDICATED MODULE. DEFAULT TO MODULE ".MAIN." IF NO MODULE
; WAS SPECIFIED BY THE USER
;
13$:
	CALL	60$		; PERFORM LOOKUP ON WHAT IS ASSUMED TO BE
				; A LIBRARY
;
; THE NEW FILE/MODULE HAS BEEN FOUND, WE CAN NOW UPDATE
; THE MODE BIT VALUES
;
14$:
	MOV	#GE.OPR,R4	; ASSUME NO SUCH MODULE
	BCS	30$		; BR IF LOOKUP ERROR. GO REOPEN THE PREVIOUS
				; FILE
	MOV	R2,(R5)		; UPDATE MODE SWITCHES WITH NEW VALUES

;
; IF A MODULE WAS FOUND, THEN THE REWIND POINT INFORMATION ON TOP OF
; THE PUSHDOWN STACK MUST BE UPDATED TO REFLECT THE REAL START POSITION
; OF THE MODULE IN THE LIBRARY.
;
	MOV	G.PPTR(R5),R4	; PICK UP THE PUSHDOWN FRAME POINTER
	MOV	G.FILE(R5),R0	; AND POINT TO THE FILE DATABASE

	ADD	#SIZRFA,R4	; REMOVE THE RFA FROM THE STACK
	CALL	..GCSR		; AND REPLACE IT WITH THE REAL REWIND POINT

	BR	50$		; RETURN WITH NEW FILE CONTEXT

	.IFF			; IF LIBRARIES ARE NOT SUPPORTED
;
; PROCEDURE LIBRARIES ARE NOT SUPPORTED
;

	CALL	NEWOPN		; OPEN NEW COMMAND FILE
	BCC	50$		; BR IF NO ERROR
	MOV	#GE.OPR,R4	; OPEN ERROR

	.ENDC			; LIBRARIES ARE SUPPORTED

30$:
	CALL	..GCRO		; RESTORE PREVIOUS FILE IF WE HAD
				; A NESTING ERROR.
	MOV	R4,R0		; SETUP ERROR RETURN CODE
	CLC			; ASSUME ERROR SUPPRESSION
	BIT	#GE.SER,(R5)	; DOES THE USER WISH US TO SUPPRESS FILE
				; LOOKUP ERRORS?
	BNE	50$		; BR IF YES
40$:
	SEC			; FLAG ERROR
50$:
	RETURN			; AND RETURN TO CALLER

	.IF DF LIB$$		; IF LIBRARIES ARE SUPPORTED
;
; MODULE LOOKUP INTERFACE
;
60$:
	.SAVVR			; SAVE R0,R1,R2
	MOV	R5,R0		; POINT TO THE MODULE NAME BUFFER
	ADD	#G.LBMN,R0	;

	MOV	G.CSIB(R5),R3	; PICK UP ADDRESS OF WORK BUFFER
	MOV	#^R.MA,(R3)	;
	MOV	#^RIN.,2(R3)	; PUT DEFAULT NAME INTO NAME BUFFER

	MOV	#1,R1		; SET CONVERT CONTROL
	CALL	$CAT5		; CONVERT 6 CHARACTER NAME TO RAD50
	TST	R1		; ANYTHING CONVERTED?
	BEQ	70$		; BR IF NOT

	MOV	R1,(R3)		; SAVE THE FIRST NAME HALF
	MOV	#1,R1		; AND REPEAT CONVERSION FOR SECOND HALF
	CALL	$CAT5		;

	MOV	R1,2(R3)	; SET SECOND NAME HALF
70$:
	MOV	R3,R1		; POINT TO NAME
	MOV	G.FILE(R5),R0	; POINT TO FILE DATABASE

	CALLR	$ULA		; AND DO LIBRARY LOOKUP
	;RETURN

	.ENDC

	.DSABLE LSB
	.PAGE
;
; COMMAND STRING INTERPRETATION
;
; INPUT:
;	R1 = FILE NAME STRING ADDRESS
;	R2 = FILE NAME STRING LENGTH
;	R5 = GCML CONTROL BLOCK ADDRESS
;
; OUTPUT:
;	R0 = DATASET DESCRIPTOR ADDRESS IN CSI BLOCK
;	R1 = CSI PARSE RESULT STATUS BITS (CS.XXX)
;	R2 = NEW BIT SETTINGS FOR G.MODE IF FILELOOKUP IS SUCCESSFUL
;
; PARSE THE FILE NAME SPECIFICATION INTO THE CSI CONTROL BLOCK
;

CSIPRS:
	CSI$1	G.CSIB(R5),R1,R2	; DO INITIAL SYNTAX CHECK ON STRING
	BCS	10$		; BR IF SYNTAX ERROR
	BITB	#CS.EQU,C.STAT(R0) ; WAS AN "=" FOUND?
	BNE	10$		; BR IF YES. ILLEGAL CONSTRUCT
	.IF NDF	R$RSTS			;SEL001 - Skip next code if RSTS 
	.IF NDF	R$$VMS			; IF NOT VAX-11 RSX

	FEAT$S	#FE$LOG			; ARE LOGICAL NAMES SUPPORTED?
	BCC	2$			; CC, OK
	CMP	#IE.SDP,$DSW		; IS FEAT$ IN THE SYSTEM?
	BEQ	3$			; EQ, NO
2$:
	CMP	#IS.SET,$DSW		; ARE THEY SUPPORTED?
	BNE	3$			; NE, NOT SUPPORTED.

	CSI$4	R0,OUTPUT,G.SWIT(R5)	; FULLY SCAN THE FILESPEC WITH POSSIBLE
	BR	4$			; LOGICAL NAME STRING
3$:
	.ENDC	;not R$$VMS
	.ENDC	;not R$RSTS

	CSI$2	R0,OUTPUT,G.SWIT(R5)	; FULLY SCAN THE FILESPEC
					; WITHOUT LOGICAL NAME EXPANSION
4$:
	BCS	10$		; BR IF ERROR

	MOVB	C.STAT(R0),R1	; PICK UP RESULT STATUS BITS
	BITB	#CS.WLD!CS.MOR,R1 ; MORE THAN ONE SPEC?
	BNE	10$		; BR IF SO, THIS TOO IS AN ERROR

	ADD	#C.MKW1,R0	; ADVANCE TO SWITCH MASK WORDS
	MOV	(R5),R2		; PICK UP CURRENT MODE BITS
	BIC	#SWITA,R2	; RESET "SINGLE LEVEL" SWITCHES
	BIC	#^CSWITA,(R0)	; AND CLEAR ALL BUT GCML SWITCHES
	BIS	(R0)+,R2	; SET NEW SWITCHES
	COM	(R0)		; REVERSE "NEGATED" SWITCH FLAGS
	BIC	#^CSWITA,(R0)	; DON'T CLEAR ANY BUT SWITCH BITS
	BIC	(R0),R2		; AND RECORD NEGATION IN MODE
	ADD	#C.DSDS-C.MKW2,R0 ; RETURN WITH R0 REFERENCING
				; THE DATASET DESCRIPTOR
	CLC
	RETURN			; RETURN SUCCESS
10$:
	SEC			; FLAG CSI ERROR
	RETURN

	.PAGE
	.ENABLE LSB
;
; ..GCCD -- CLOSE OR DELETE THE CURRENT FILE
;
..GCCD::
	CALL	..GCOC		; IS THE FILE OPEN?
	BEQ	50$		; BR IF NOT, SKIP DELETE

	BIT	#GE.SDE,(R5)	; IS THE FILE TO BE DELETED?
	BEQ	CLOFIL		; BR IF NOT
	TST	(R5)		; IS IT A LIBRARY?
	BMI	CLOFIL		; SORRY, CAN'T DELETE A LIBRARY

	.IF DF FCS$$		; IF FCS-11

	CALL	.DLFNB		; DELETE THE FILE

	.ENDC

	.IF DF RMS$$		; IF RMS-11


	.ENDC

	BR	CLOFIL		; GO CLOSE THE FILE

;
; ..GCPC -- CLOSE TOP LEVEL IF IT IS OPEN
;
..GCPC::
	CALL	..GCOC		; IS THE FILE OPEN?
	BEQ	50$		; BR IF NOT, SKIP PUSH AND CLOSE

;
; PSHCLO -- CLOSE THE TOP LEVEL FILE
;
PSHCLO:
	CALL	PSHNOC		; PUSH CURRENT FILE BUT DON'T CLOSE IT
CLOFIL:
	.SAVVR			; SAVE R0,R1,R2
	ADD	#SIZRFA,G.PPTR(R5) ; STRIP THE RFA PRESENT FOR OPEN FILES

	.IF DF MCM$$		; IF MULTIPLE FRAGMENT LINES SUPPORTED

	CLR	G.FRAG+0(R5)	; THROW AWAY ANY RESIDUAL FRAGMENT

	.ENDC

	.IF DF FCS$$		; IF FCS-11

	MOV	G.FILE(R5),R0	; LOAD THE FILE DATABASE ADDRESSS
	MOV	F.FNB+N.FID(R0),-(SP)	; SAVE FIRST WORD OF FID
	CLOSE$	R0		; CLOSE THE TOP LEVEL FILE
	TST	(R5)			; IS CURRENTLY OPEN FILE A LIBRARY?
	BPL	5$			; BRANCH IF NOT

	MOV	(SP)+,F.FNB+N.FID(R0)	; RESTORE FIRST WORD OF FID
	BR	10$
5$:
	TST	(SP)+			; REMOVE FIRST WORD OF FID FROM STACK
10$:

	.ENDC

	.IF DF RMS$$		; IF RMS-11

	.ENDC			;

	TST	G.FQFN(R5)	; DOES THE USER HAVE A FILE NAME BUFFER?
	BEQ	15$		; BR IF NOT
	CLRB	@G.FQFN(R5)	; IF SO, RESET IT, THE FILE IS CHANGED
15$:
	RETURN			;

;
; PUSH THE CONTEXT OF THE CURRENT FILE TO THE PUSHDOWN STACK.
; LEAVE THE FILE OPEN
;
PSHNOC:
	.SAVVR			; SAVE R0,R1,R2
	INCB	G.CDEP(R5)	; BOOST THE NESTING LEVEL
	MOV	G.PPTR(R5),R4	; LOAD THE PUSHDOWN STACK POINTER
	SUB	#G.PLFS,G.PPTR(R5) ; ADJUST THE FRAME POINTER

	MOV	G.FILE(R5),R0	; PICK UP THE FILEDATABASE POINTER

	.IF DF FCS$$		; IF FCS-11

	MOV	@F.BDB(R0),-(R4) ; SAVE THE CURRENT BLOCK BUFFER STATUS

	CALL	..GCSR		; PUSH THE CURRENT RFA TO THE STACK

	MOV	F.DFNB(R0),R1	; GET ADDRESS OF DEFAULT FILENAME BLOCK
	MOV	#"SY,N.DVNM(R1)	; ALL FILES DEFAULT TO "SY" BEYOND HERE

	MOV	#F.URBD/2,R1	; GET COUNT OF ATTRIBUTES TO PUSH
	MOV	R0,R2		; COPY FDB POINTER
20$:
	MOV	(R2)+,-(R4)	; PUSH FILE ATTRIBUTES TO STACK
	DEC	R1		;
	BGT	20$		; LOOP

	ADD	#F.FNB-F.URBD,R2 ; ADVANCE TO FILE ID
	MOV	(R2)+,-(R4)	; SAVE THEFILE ID
	MOV	(R2)+,-(R4)	;
	MOV	(R2)+,-(R4)	; 3 WORDS

	.IF NDF	R$RSTS			;SEL001 - Skip next code if RSTS 
	MOV	(R2)+,-(R4)		; SAVE THE FILE NAME
	MOV	(R2)+,-(R4)		;
	MOV	(R2)+,-(R4)		; THREE WORDS
	MOV	(R2)+,-(R4)		; SAVE THE FILE TYPE
	MOV	(R2)+,-(R4)		; SAVE THE FILE VERSION NUMBER

	ADD	#N.DID-N.STAT,R2	; ADVANCE TO THE DIRECTORY ID
	.IFF				;SEL001 - RSTS-only
	ADD	#N.DID-N.FNAM,R2	; ADVANCE TO THE DIRECTORY ID
	.ENDC	;R$RSTS

	MOV	(R2)+,-(R4)	; SAVE THE DIRECTORY ID
	MOV	(R2)+,-(R4)	;
	MOV	(R2)+,-(R4)	; THREE WORDS

	MOV	(R2)+,-(R4)	; AND SAVE THE DEVICE NAME
	MOV	(R2),-(R4)	; AND DEVICE UNIT

	MOV	(R5),-(R4)	; SAVE THE CURRENT MODE BITS
	BIC	#^CSAVMOD,(R4)	; ONLY THE "DELETE" SWITCH IS NEEDED

	MOV	G.SRWP+4(R4),-(R4) ; COPY THE REWIND POINT RFA TO THE TOP AGAIN
	MOV	G.SRWP+4(R4),-(R4) ; BECAUSE WE ARE LEAVING THE FILE OPEN AND
	MOV	G.SRWP+4(R4),-(R4) ; OPEN FILES HAVE A REWIND RFA ON THE PD STAC

	.ENDC

	.IF DF RMS$$		; IF RMS-11

	.ERROR			; RMS-11 CODE NO IMPLEMENTED

	.ENDC

50$:
	RETURN


	.DSABL LSB
	.PAGE
	.ENDC			; END OF PART 2
	.IF DF PT1$$		; IF THIS IS TWO PART CODE, THIS IS PART 1
;
; ..GCOT -- OPEN TOP LEVEL IF NOT ALREADY OPEN
;
; INPUT:
;	NONE
; OUTPUT:
;	THE TOP LEVEL FILE CONTEXT IS POPPED FROM THE PUSHDOWN LIST
;	AND RE-OPENED.
;
..GCOT::
	CALL	..GCOC		; TEST FILE OPEN FLAG
	BNE	10$		; BR IF OPEN, JUST RETURN
	CALLR	..GCRO		; IF NOT OPEN, GO POP AND OPEN IT
10$:
	RETURN			; OTHERWISE FILE IS OPEN

	.ENDC			; END OF PART 2 CODE
	.IF DF PT2$$		; IF TWO PART CODE, THIS IS PART 2
;
; ..GCRO -- POP TOP LEVEL AND REOPEN THE FILE
;
..GCRO::
	.SAVR1			; SAVE R1-R5
	CALL	..GCCD		; CLOSE TOP FILE IF OPEN AND OPTIONALLY
				; DELETE IT
	MOV	G.PPTR(R5),R4	; PICK UP PUSHDOWN STACK POINTER
	ADD	#G.PLFS,G.PPTR(R5) ; AND ADJUST FRAME POINTER TO REMOVE THE
				   ; PUSHED CONTEXT AND THE REWIND RFA.
	DECB	G.CDEP(R5)	; DECREMENT THE NESTING LEVEL
	BNE	10$		; BR IF WE ARE NOT RESTORING LEVEL 0

	MOV	F.DFNB(R0),R1	; PICK UP ADDRESS OF DEFAULT FILE NAME BLOCK
	CLR	N.DVNM(R1)	; REST THE DEFAULT DEVICE NAME. WE WILL USE
				; THE DEVICE SAVED BY THE FIRST FILE NEST AS
				; THE DEFAULT FOR THE TOP LEVEL

	BIT	#GE.MCR,(R5)	; WAS LEVEL 0 AN MCR COMMAND LINE?
	BNE	30$		; BR IF YES, GO GIVE EOF
10$:
	BIC	#SAVMOD,(R5)	; RESET ANY SWITCHES TO BE RESTORED
	BIC	#^CSAVMOD,(R4)	; FROM THE SAVE FRAME
	BIS	(R4)+,(R5)	; AND RESTORE THE SWITCHES

	MOV	G.FILE(R5),R0	; LOAD FILE DATA BASE POINTER
	CLR	G.FRAG+0(R5)	; ENSURE NO RESIDUAL FRAGMENT

	.IF DF FCS$$		; IF FCS-11

	MOV	R0,R3		; POINT TO FILE-ID PORTION OF FDB

	ADD	#F.FNB+N.UNIT+2,R3 ; POINT JUST BEYOND THE DEVICE UNIT
	MOV	(R4)+,-(R3)	; RESTORE THE DEVICE UNIT
	MOV	(R4)+,-(R3)	; AND THE DEVICE NAME

	MOV	(R4)+,-(R3)	; AND RESTORE THE DIRECTORY ID
	MOV	(R4)+,-(R3)	;
	MOV	(R4)+,-(R3)	; THREE WORDS

	.IF NDF	R$RSTS			;SEL001 - Skip next code if RSTS 
	SUB	#N.DID-N.STAT,R3	; ADVANCE TO THE FILE VERSION NUMBER
	MOV	(R4)+,-(R3)		; RESTORE THE FILE VERSION NUMBER
	MOV	(R4)+,-(R3)		; RESTORE THE FILE TYPE
	MOV	(R4)+,-(R3)		; RESTORE THE FILE NAME
	MOV	(R4)+,-(R3)		;
	MOV	(R4)+,-(R3)		; THREE WORDS

	.IFF				;SEL001 - Rsts-only code
	SUB	#N.DID-N.FNAM,R3	; ADJUST POINTER TO RESTORE THE FILE ID
	.ENDC	;R$RSTS

	MOV	(R4)+,-(R3)	; RESTORE THE FILE ID
	MOV	(R4)+,-(R3)	;
	MOV	(R4)+,-(R3)	; THREE WORDS

	CALL	OPNFNB		; REOPEN THIS FILE

	BCS	20$		; BR IF OPEN ERROR

	MOV	R0,R2		; POINT TO FILE ATTRIBUTES PORTION OF FDB
	ADD	#F.URBD,R2	; POINT TO ONE WORD BEYOND RESTORED SECTION
15$:
	MOV	(R4)+,-(R2)	; RESTORE FILE ATTRIBUTES
	CMP	R2,R0		; BACK TO START YET?
	BHI	15$		; BR IF NOT, RESTORE MORE

	CALL	..GCPR		; POINT FILE BACK TO PREVIOUS POSITION

	MOV	(R4)+,@F.BDB(R0) ; RESTORE PREVIOUS BLOCK BUFFER STATUS
	MOV	R4,G.PPTR(R5)	; THE OPEN WAS SUCCESSFUL. POINT THE FRAME
				; POINTER TO THE REWIND RFA FOR THE OPEN FILE
	BCC	40$		; RETURN IF SUCCESS ON POINT FILE OPERATION.

	CMPB	#IE.EOF,F.ERR(R0) ; WAS THIS BEYOND THE END OF FILE?
	BEQ	40$		; IF SO, THATS OK

20$:	MOV	#GE.OPR,R0	; LOAD OPEN ERROR CODE
	BR	35$		; AND RETURN
30$:
	MOV	#GE.EOF,R0	; LOAD END-OF-FILE CODE
35$:
	SEC			; FLAG ERROR
40$:
	RETURN			;

	.ENDC

	.IF DF RMS$$		; IF RMS-11

	.ERROR			; RMS-11 CODE NO IMPLEMENTED

	.ENDC

	.ENABLE LSB
;
; CHNOPN -- OPEN NEW FILE IN THE SAME DIRECTORY AS THE PREVIOUS FILE
;
; INPUT:
;	R0 = DATASET DESCRIPTOR ADDRESS
;
CHNOPN:
	.SAVVR			; SAVE R0,R1,R2
	CALL	50$		; CALL TO LOAD REGISTERS
	MOV	#NB.DIR!NB.DEV,N.STAT(R1) ; FORCE FLAGS INDICATING DIRECTORY
				; AND DEVICE ARE ALREADY PRESENT.
	CLR	F.FNAM(R0)	; CLEAR THE PREVIOUS MODULE NAME FROM FNB
	CLR	F.FNAM+2(R0)	;
	CLR	F.FNAM+4(R0)	;
				;
	TST	N.DID(R1)	; IS DIRECTORY SPECIFIED IN FILENAME BLOCK?
	BNE	10$		; YES.  LEAVE IT ALONE
	TST	N.FNSZ(R2)	; IS FILENAME SIZE=0 (AS IN @@ LINE)?
	BEQ	10$		; YES.  LET IT GO TO INTERRACTIVE MODE
	CALL	.PARSE		; PARSE THE WHOLE THING - THIS IS THE FIRST
				;   TIME ENTERING INDIRECT AND IS WITH AN
				;   @/LB:MODULE - NEED TO GET A DEVICE
				;   AND DIRECTORY INTO FILENAME BLOCK
	BR	32$		; TO COMMON OPEN
10$:
	CALL	.PRSFN		; PARSE THE FILENAME ONLY

	BR	32$		; TO COMMON OPEN
;
; ..GCTO -- PERFORM FIRST/TOP LEVEL OPEN
;
..GCTO::
	CLR	R0		; INDICATE NO PRESET DATASET DESCRIPTOR
				; FALL THROUGH INTO FILE OPEN

;
; NEWOPN -- OPEN NEWLY SPECIFIED FILE
;
; INPUT:
;	R0 = DEFAULT DATASET DESCRIPTOR FOR FILE
;
NEWOPN:
	.SAVR1			; SAVE R1-R5

	.IF DF FCS$$		; IF FCS-11

	MOV	@#.FSRPT,R1	; PICK UP FILE IMPURE AREA POINTER
	TST	A.DFUI(R1)	; HAS A FINIT$ BEEN DONE?
	BNE	30$		; BR IF YES

	FINIT$			; IF NOT, INITALIZE FILE SYSTEM
30$:
	CALL	50$		; LOAD REGISTERS
	CALL	.PARSE		; AND FILL IN FNB WITH FILE DATA
;
; UNDER VMS, THE .PARSE CALL WILL ACTUALLY ISSUE I/O TO DETERMINE THE
; EXISTENCE OF THE DIRECTORY AND FILE THAT WAS SPECIFIED. IF THE FILE
; CANNOT BE ACCESSED, THEN AN ERROR WILL BE RETURNED BY .PARSE, EVEN
; THOUGH THE PARSING OF THE FILESPEC ITSELF WAS SUCCESSFUL. IF THE
; ERROR RETURNED INDICATES THAT THE PARSE WAS SUCCESSFUL, GO AHEAD AND
; FILL IN THE DIRECTORY INFORMATION IN THE GCML CONTROL BLOCK.
;
	.IF DF	R$$VMS

	BCC	301$		; ON PARSE SUCCESS, FILL IN DIRECTORY INFO
	CMPB	F.ERR(R0),#IE.NSF ; DID PARSE REALLY SUCCEED?

	.IF DF	R$$VMS

	SEC			; MIGHT HAVE BEEN CLEARED BY CMPB

	.ENDC	;R$$VMS

	BNE	35$		; IF NE NO, REPORT ERROR NOW

	.IFF

	BCS	35$		; BR IF ERROR

	.ENDC	;R$$VMS

301$:	CLR	G.DDIR(R5)	; RESET DIRECTORY STRING SIZE
	MOV	4(R2),R1	; IS THERE A DIRECTORY STRING IN THE CSI DSDS
	BEQ	302$		; BR IF NOT
	MOV	6(R2),R2	; GET THE ADDRESS OF THE USER SUPPLIED DIRECTORY
	BR	303$		; CONTINUE BELOW
302$:
	CALL	.RDFDR		; GET ADDRESS OF DIRECTORY STRING FROM FCS-11
303$:
	MOV	R1,G.DDIR+0(R5) ; SAVE STRING SIZE
	MOV	R2,G.DDIR+2(R5)	; AND ADDRESS FOR LATER FILENAME EXPANSION

	.IF DF	R$$VMS

	TSTB	F.ERR(R0)	; DID THE AME PARSE AND FIND THE FILE?
	BPL	OPNFIL		; IF PL YES, OPEN IT FOR REAL NOW
	SEC			; DON'T BOTHER TO TRY TO OPEN FILE AGAIN

	.IFF

	BR	OPNFIL		; OPEN THE FILE FOR REAL

	.ENDC	;R$$VMS
32$:
	BCS	35$		; BR IF ERROR
OPNFIL:
	CALL	OPNFNB		; OPEN THE FILE FOR READ
	BCS	35$		; BR IF ERROR

	.ENDC			; FCS-11

	.IF DF RMS$$		; IF RMS-11

	.ENDC


	.IF DF LIB$$		; IF PROCEDURE LIBRARIES ARE SUPPORTED

	MOV	G.PPTR(R5),R1	; PICK UP THE PUSHDOWN STACK POINTER
	CLR	-(R1)		; AND PUT A DUMMY REWIND POINT "RFA"
	MOV	#1,-(R1)	; ON THE STACK
	CLR	-(R1)		; INCASE WE JUST OPENED A COMMAND FILE
				; AS OPPOSED TO A LIBRARY.
	SUB	#SIZRFA,G.PPTR(R5) ; ADJUST THE STACK POINTER

	.ENDC

35$:
	MOV	F.ERR(R0),R0	; RETURN WITH ERROR CODE
40$:
	RETURN
;
; LOAD REGISTERS AND SETUP FOR THE PARSE
;
50$:
	MOV	G.DEFT(R5),R1	; ASSUME THIS IS A COMMAND FILE.  INDIRECT
				;  MAY HAVE MADE IT .CMF OR .CMD
	TST	R2		; IS THE NEW FILE A LIBRARY?
	BPL	55$		; BR IF NOT
	MOV	#^RCLB,R1	; DEFAULT EXTENSION IS "CLB", NOT "CMD"
55$:
	MOV	R0,R2		; COPY DATASET DESCRIPTOR ADDRESS
	MOV	G.FILE(R5),R0	; AND LOAD FDB ADDRESS

	MOV	F.DFNB(R0),R3	; AND LOAD DEFAULT FILENAME BLOCK ADDRESS
	BEQ	57$		; BR IF NO DFNB SUPPLIED
	MOV	R1,N.FTYP(R3)	; SET DEFAULT TYPE FOR PARSE
57$:
	MOV	R0,R1		; POINT TO FILE NAME BLOCK
	ADD	#F.FNB,R1	;
	.IF NDF	R$$VMS

	BISB	#FL.AEX,F.FLG(R0) ; TELL .PARSE NOT TO EXPAND POSSIBLE LOGICAL
	.ENDC			  ; NAME STRINGS

	RETURN
	.DSABL LSB


;
; OPNFNB -- OPEN FILE BY FILE NAME BLOCK
;
; INPUT:
;	R0 = FILE DATABASE ADDRESS
;	G.OVBC(R5) = IF NON-ZERO THE COUNT OF BUFFERS TO USE FOR OPEN
;
; OUTPUT:
;	C/CLR => FILE IS OPENED USING G.OVBC BUFFERS OR LESS
;	C/SET => ERROR CODE IS IN DATA STRUCTURE
;
;

OPNFNB:
	.SAVVR			; SAVE R0-R2
	MOVB	G.OVBC(R5),R2	; PICK UP USER COUNT OF BUFFERS
	BITB	#FD.REC!FD.CCL!FD.TTY!FD.SDI!FD.SQD,F.RCTL(R0) ; IS THIS
				; OTHER THAN A DISK DEVICE?
	BEQ	5$		; BR IF THIS IS A DISK
	CLR	R2		; DON'T OVERRIDE ANYTHING ELSE(IE A TERMINAL)
5$:
	MOVB	R2,R1		; GET BUFFER COUNT
	SWAB	R1		; MULTIPLY BUFFER COUNT BY 512.
	ASL	R1		;
10$:
	MOV	R1,F.OVBS(R0)	; SET OVERRIDE BUFFER SIZE IN FILE DATABASE
	MOV	F.FNB+N.FID+0(R0),R1 ; SAVE THE FIRST WORD OF THE FILE ID
	MOVB	#FO.RD!FA.SHR,F.FACC(R0) ; OPEN FOR READ SHARED

	OFNB$	R0		; OPEN THE FILE
	BCC	40$		; BR IF NO ERROR

	CMPB	#IE.NBF,F.ERR(R0) ; WAS THE ERROR "NO BUFFER SPACE"?
	BNE	30$		; BR IF OTHER ERROR

	MOV	R1,F.FNB+N.FID+0(R0) ; RESTORE N.FID+0 FOR RETRY

	TST	R2		; HAVE WE CONVERGED ON THE DEFAULT CASE?
	BLE	30$		; YES, RETURN "NO BUFFER" AS A REAL ERROR
	DEC	R2		; TRY ONE BUFFER LESS
	BR	5$		; TRY AGAIN
30$:
	SEC			; PROPAGATE ERROR
40$:
	RETURN			;


	.ENDC			; IF THIS IS TWO PART, END OF PART 2
	.IF DF PT1$$		; IF TWO PART, THIS IS PART 1
;
; ..GCOC -- IS THE FILE OPEN?
;
; OUTPUT
;	R0 = FILE DATABASE POINTER
;
..GCOC::
	MOV	G.FILE(R5),R0	; GET FDB ADDRESS

	.IF DF FCS$$		; IF FCS-11

	TST	F.BDB(R0)	; IF NON-ZERO, THE FILE IS OPEN
	RETURN			;

	.ENDC

	.IF DF RMS$$		; IF RMS-11

	.ERROR			; RMS-11 CODE NOT IMPLEMENTED

	.ENDC

	.ENDC			; IF TWO PART CODE, END OF PART 1
	.IF DF PT2$$		; IF TWO PART CODE, THIS IS PART 2
;
; PUSH/POP RFA FROM PUSHDOWN STACK
;

	.IF DF FCS$$		; IF FCS-11 FILE SYSTEM

..GCSR::
	CALL	.MARK		; OBTAIN FCS-11 RFA
	MOV	R1,-(R4)	; AND PUSH IT TO THE PUSHDOWN STACK
	MOV	R2,-(R4)	;
	MOV	R3,-(R4)	;
	RETURN

..GCPR::
	MOV	(R4)+,R3	; POP RFA FROM STACK
	MOV	(R4)+,R2	;
	MOV	(R4)+,R1	;
	CALLR	.POINT		; AND REPOSITION FILE
	;RETURN			;

	.ENDC			; IF FCS-11

	.IF DF RMS$$		; IF RMS-11 FILE SYSTEM
..GCSR::
..GCPR::
	.ENDC			; IF RMS-11

	.ENDC			; END OF PART 2 CODE
	.IF DF PT3$$		; THE FOLLOWING CODE GOES IN PART 3
;
; ..GCEF -- EXPAND THE FILENAME STRING FOR THE USER
;
; THIS ROUTINE RETURNS THE FULLY QUALIFIED FILENAME STRING TO THE CALLER
; IN A USER SUPPLIED BUFFER
;
; INPUT:
;	R0 = USER BUFFER ADDRESS SUFFICIENTLY LARGE TO HOLD THE STRING
;	R5 = GCML IMPURE AREA POINTER
;
; OUTPUT:
;	THE BUFFER CONTAINS AN ASCIZ STRING FOR THE CURRENTLY OPEN FILE
;
..GCEF::
	MOV	G.FILE(R5),R1	; POINT TO THE FILE DATA STRUCTURE
	MOV	G.DDIR+2(R5),R2	; SET DIRECTORY STRING ADDRESS
	MOV	G.DDIR+0(R5),R3	; AND SET SIZE
	CALL	.EXPFN		; USE LIBRARY ROUTINE TO EXPAND THE STRING
	TST	(R5)		; IS THE CURRENT FILE A LIBRARY?
	BPL	35$		; BR IF NOT

	MOVB	#'/,(R0)+	; ADD THE "/LB:" SWITCH
	MOVB	#'L,(R0)+	;
	MOVB	#'B,(R0)+	;
	MOVB	#':,(R0)+	;

	MOV	R5,R1		; POINT TO MODULE NAME
	ADD	#G.LBMN,R1	;
	MOV	#6,R2		; SET MAXIMUM CHARACTERS TO MOVE
34$:
	MOVB	(R1)+,(R0)+	; SHUFFLE NEXT
	BEQ	40$		; RETURN IF NULL
	DEC	R2		; MAX REACHED?
	BNE	34$		; LOOP IF NOT
35$:
	CLRB	(R0)		; AND INSERT A TERMINATOR TO MAKE IT ASCIZ
40$:
	RETURN

	.PAGE

;
; MOVECT -- MOVE COUNTED STRING
;
; INPUT:
;	R0 = TERMINATION CHARACTER
;	R1 = ADDRESS OF SOURCE STRING
;	R2 = COUNT OF CHARACTERS TO MOVE
;	R3 = ADDRESS OF DESTINATION STRING
;	R4 = MAXIMUM SIZE OF DESTINATION BUFFER

MOVECT:
	CMPB	R0,(R1)		; NEXT CHARACTER THE TERMINATOR?
	CLC			; ASSUME NO ERRORS
	BEQ	5$		; BR IF TERMINATOR REACHED
	DEC	R4		; COUNT ONE DESTINATION CHARACTER
	BMI	10$		; BR IF LINE OVERFLOWS
	MOVB	(R1)+,(R3)+	; MOVE THE CHARACTER
	DEC	R2		; COUNT CHARACTER
	BGT	MOVECT		; LOOP FOR MORE
5$:
	RETURN			; DONE
10$:
	SEC			; FLAG BUFFER OVERFLOW
	RETURN			;

	.ENDC			; END OF PART 3 CODE
	.IF DF PT2$$ ! PT3$$	; THIS CODE GOES IN BOTH PART 2 AND PART 3

;
; SKPBLK -- PRESS OUT BLANKS AND TABS
;
; INPUT:
;	R1 = ADDRESS OF LINE
;	R2 = COUNT
;
; OUTPUT:
;	R1,R2 ARE UPDATED TO REFLECT PRESSED BLANKS AND TABS
;	THE Z-BIT IS SET IF NO CHARACTERS ARE LEFT
;
	.ENABLE LSB

10$:
	INC	R1		; ADVANCE POINTER
	DEC	R2		; AND COUNT CHARACTER
	BEQ	40$		; BR IF DONE
SKPBLK:
	CMPB	#SPACE,(R1)	; SPACE?
	BEQ	10$		; BR IF SPACE
	CMPB	#TAB,(R1)	; TAB?
	BEQ	10$		;
	BR	40$		; DONE, RETURN TO CALLER

;
; SKPSST -- SKIP TO A SLASH, SPACE, OR TABS
;
30$:
	INC	R1		; ADVANCE POINTER
	DEC	R2		; COUNT CHARACTER
	BEQ	40$		; RETURN IF DONE
SKPSST:
	TST	R2		; CHECK IF ACTION IS NECESSARY
	BEQ	40$		; EQ -> NO, LINE IS BLANK
	CMPB	#SPACE,(R1)	; SPACE?
	BEQ	40$		; YES, DONE
	CMPB	#TAB,(R1)	; TAB?
	BEQ	40$		; YES, DONE
	CMPB	#ATSIGN,(R1)	; INDIRECT FILE REFERENCE
	BEQ	40$		; YES, DONE
	CMPB	#SLASH,(R1)	; SLASH?
	BNE	30$		; BR IF NOT
40$:
	TST	R2		; RETURN INDICATION OF REMAINING CHARACTES
	RETURN			; RETURN TO CALLER

	.DSABLE LSB

	.ENDC			; END OF PART 2+3 CODE

	.END
