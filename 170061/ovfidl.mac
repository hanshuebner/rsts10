	.TITLE	OVFIDL	OPTIMIZED I/D OVERLAY CONTROL ROUTINES
	.IDENT	/1.02/
;
;		COPYRIGHT (c) 1987 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD
;	 MASSACHUSETTS.  ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE  IS  FURNISHED  UNDER  A LICENSE AND MAY BE USED
; AND  COPIED  ONLY IN  ACCORDANCE WITH THE TERMS OF SUCH LICENSE
; AND WITH  THE INCLUSION  OF THE ABOVE  COPYRIGHT  NOTICE.  THIS
; SOFTWARE  OR ANY OTHER  COPIES  THEREOF, MAY NOT BE PROVIDED OR
; OTHERWISE MADE  AVAILABLE TO ANY OTHER PERSON.  NO TITLE TO AND
; OWNERSHIP OF THE SOFTWARE IS HEREBY TRANSFERED.
;
; THE INFORMATION  IN THIS DOCUMENT IS SUBJECT  TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT  BY  DIGITAL
; EQUIPMENT CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF
; ITS SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.
;
;
; MODIFIED FOR RSX-11M-PLUS AND MICRO/RSX V4.0 BY:
;
;	L. M. PETERSON	22-MAR-86	1.00
;				CREATE OPTIMIZED I/D VERSION(S) OF MARKS FOR
;				AUTOLOADED TASKS
;
;	L. M. PETERSON	15-DEC-86	1.01	SPR#233P
;		LMP074		USE R.GSTS SET BY TKB TO ATTACH REGION FOR
;				CLUSTER LIBRARY (INSTEAD OF ALWAYS ATTACHING
;				READ ONLY)
;
;	L. M. PETERSON	28-AUG-87	1.02
;				ADD TEST BEFORE UPDATING N.DTDS LMP097

;------------------------------------------------------------------------
	.IF DF P$$LAS		; IF THIS ASSEMBLY SUPPORTS PLAS
	.IF DF C$$STR		; IF THIS ASSEMBLY SUPPORTS CLUSTERS
	.TITLE OVFIDC ID (DISK,PLAS,CLUS)
	.LIST CND		; LIST ALL CONDITIONALS
	.IFF			; IF NO CLUSTER SUPPORT
	.TITLE OVFIDR ID (DISK,PLAS,-CLUS)
	.NLIST CND		; DON'T LIST CONDITIONALLY EXCLUDED CODE
	.ENDC
	.IFF			; IF NO PLAS SUPPORT REQUIRED
	.TITLE OVFIDL ID (DISK,-PLAS,-CLUS)
	.NLIST CND		; DON'T LIST CONDITIONALLY EXCLUDED CODE
	.ENDC
;------------------------------------------------------------------------


;
; OVERLAY RUN TIME ROUTINES FOR OVERLAID I/D TASKS
;
; EQUATED SYMBOLS
;

O$VEF=31.			; SYSTEM OVERLAY EVENT FLAG
Q$IOW=3				; QUEUE I/O DIRECTIVE CODE

;
; MACRO LIBRARY CALLS
;

	.MCALL	ATRG$S,CRAW$S,DIR$,QIOSY$
	RGDF	,,S
	WDBDF	,,S
	QIOSY$

	.IIF NE WF$MAP-100000 .ERROR ; ASSUMPTION ERROR
	.IIF NE RF$ATT-100000 .ERROR ; ASSUMPTION ERROR

;+
; **-$MARKS-MARK SEGMENT
;
; THIS ROUTINE IS CALLED TO MARK ALL SEGMENTS OUT OF MEMORY THAT ARE
; NOT ON THE SAME PATH AS THE ARGUMENT SEGMENT. IT IS ONE OF THE OVER-
; LAY RUN TIME ROUTINES AND IS CALLED BY BOTH THE $LOAD (MANUAL LOAD-
; ING) AND $AUTO (AUTOMATIC LOADING) ROUTINES.
;
; INPUTS:
;
;	R1=ADDRESS OF RUNTIME IMPURE DATA AREA
;	R2=ADDRESS OF ARGUMENT SEGMENT DESCRIPTOR.
;
; OUTPUTS:
;
;	THE APPROPRIATE SEGMENTS ARE MARKED OUT OF MEMORY AND ALL REG-
;	ISTERS ARE PRESERVED.
;
; NOTE WELL:
;
;	THIS ROUTINE MAKES TWO ASSUMPTIONS ABOUT THE OVERLAY DATA
;	BASE IN AN OVERLAID I- AND D-SPACE TASK:
;
;	1) IF A SEGMENT DESCRIPTOR HAS A D-SPACE EXTENSION, THEN ITS
;	   I-SPACE WINDOW DESCRIPTOR POINTER, T$RWDP, AND ITS D-SPACE
;	   WINDOW DESCRIPTOR POINTER, T$DWDP, MUST EITHER BOTH BE ZERO OR 
;	   BOTH BE NON-ZERO.
;
;	2) IF TWO SEGMENT DESCRIPTORS HAVE D-SPACE EXTENSIONS AND POINT
;	   TO THE SAME I-SPACE WINDOW DESCRIPTOR, THEN THEY MUST POINT TO
;	   THE SAME D-SPACE WINDOW DESCRIPTOR AS WELL (AND VICE VERSA).
;-


	.PSECT	$$MRKS	I,RO,LCL,REL,OVR

;
; NOTE IN THE FOLLOWING GLOBAL SYMBOL DEFINITIONS THAT THESE
; DEFINITIONS HOLD:
;		MODULE:		DEFINITIONS:
;		 OVFIDL		$MARKS,$MAFKS,$MAFDS
;		 OVFIDR		$MARKS,$MAFKS,$MAFKR,$MAFDS,$MAFDR
;		 OVFIDC		$MARKS,$MAFKS,$MAFKR,$MAFKC,$MAFDS,$MAFDR,$MAFDC
;
; THIS PERMITS CORRECT LINKING OF A USER TASK WHEN LINKED AGAINST
; A SHARABLE LIBRARY CONTAINING MORE SUPPORT THAN IS IMMEDIATELY REQUIRED
; BY THAT SPECIFIC TASK.
;

$MARKS::
$MAFKS::
$MARDS::
$MAFDS::
	.IF NDF	P$$LAS		; IF PLAS IS NOT SUPPORTED 
				; DEFINE LABEL TO DRAW THIS MODULE FROM SYSLIB 
				; IF THE TASKBUILDER DETECTS *ONLY* DISK 
				; RESIDENT OVERLAYS. 

	BIT	#TR$MEM,(R2)	; Target segment already in memory?
	BEQ	110$		; If EQ, yes
	MOV	R2,-(SP)	; Save R2
	CLR	R3		; Initialize in-mem target path value
	MOV	R2,R4		; Save segment address

10$:	; Search load path of target segment for highest segment in memory

	BIT	#TR$DES,(R2)	; Reached root segment?
	BEQ	20$		; If EQ, yes
	MOV	T$RDWN(R2),R2	; Proceed down to root
	BIT	#TR$MEM,(R2)	; This segment in memory?
	BNE	10$		; If NE, no
	TST	R3		; Already found a segment in memory?
	BNE	10$		; If NE, yes
	MOV	R2,R3		; Save highest in-memory segment on target path
	BR	10$	

20$:	; Get load info and update

	MOV	T$RDWN(R2),R5	; Get highest loaded segment in current tree
	MOV	R4,T$RDWN(R2) 	; Save the segment that's going to be loaded
	TST	R5		; Any overlay loaded?
	BEQ	100$		; If EQ, no

30$:	; Mark segment out of memory and continue

	CMP	R3,R5		; Reached a common point?
	BEQ	100$		; If EQ, yes - so quit
	BIS	#TR$MEM,(R5)	; Mark segment out of memory
	MOV	T$RDWN(R5),R5	; Get next segment to unload
	BIT	#TR$DES,(R5)	; Reached root?
	BNE	30$		; If NE, no - go unload next segment

100$:	MOV	(SP)+,R2	; Restore R2
110$:	RETURN



	.IFF 			; P$$LAS DEFINED
$MARKR::
$MAFKR::			; IF PLAS IS SUPPORTED AND CLUSTER LIBRARIES
$MARDR::
$MAFDR::			; ARE *NOT* SUPPORTED
				; DEFINE LABEL TO DRAW THIS MODULE FROM SYSLIB
				; WHEN THE TASKBUILDER DETECTS REFERENCE TO A
				; MEMORY RESIDENT OVERLAY AND NO CLUSTER 
				; LIBRARY REFERENCES
	.IF DF C$$STR		
$MARKC::
$MAFKC::			; IF PLAS *AND* CLUSTER LIBRARIES ARE SUPPORTED
$MARDC::
$MAFDC::			; DEFINE LABEL TO DRAW THIS MODULE FROM SYSLIB
				; WHEN THE TASKBUILDER DETECTS REFERENCE TO A
				; MEMORY RESIDENT OVERLAY AND AT LEAST ONE 
				; CLUSTER LIBRARY REFERENCE
	.ENDC			; C$$STR

	BIT	#TR$MEM,(R2)	; Target segment already in memory?
	BEQ	110$		; If EQ, yes - so quit
	MOV	T$RNME(R2),R4	; Get pointer to root
	MOV	T$RDWN(R4),R5	; Get address of highest loaded segment
	MOV	R2,T$RDWN(R4)	; Update address to target segment
	TST	R5		; Any overlay loaded?
	BEQ	110$		; If EQ, no 
	MOV	R2,-(SP)	; Save R2
	MOV	T$RWDP(R2),R3	; Save addr of I-space window blk of target seg
	.IF DF C$$STR
	CLR	N.DTDS(R1)	; Reset the 'segment displaced' address
	.ENDC

; At this point:
; 	R2 is address of current segment on load path of target segment
;	R5 is address of current segment on unload path

10$:
	CMP	T$RLDA(R5),T$RLDA(R2) ; At same or lower APR on target path?
	BPL	20$		; If PL, yes - continue
	MOV	T$RDWN(R2),R2	; Move down target path
	BR	10$		; Try again
20$:
	CMP	R2,R5		; Reached common point?
	BEQ	100$		; If EQ, yes - so quit
	MOV	T$RDWN(R5),R4	; Get window block for parent of segment
	CMP	T$RWDP(R5),T$RWDP(R4) ; Same I-space window (DR above DR or MR)?
	BNE	30$		; If NE, no
	BIC	#TR$LOD,(R5)	; Mark segment unloaded
	BIS	#TR$MEM,(R5)	; Mark segment out of memory
	BR	90$		; Go get next segment
30$:
	BIS	#TR$MEM,(R5)	; Mark segment out of memory
	MOV	T$RWDP(R5),R4	; Get I-space window block of this segment
	.IF DF C$$STR
	CMP	W$NREG(R3),W$NREG(R4) ; Displaced segment in a different region?
	BEQ	35$		; If EQ, yes - no PD library
	TST	N.DTDS(R1)	; Have highest segment displaced?
	BNE	35$		; If NE, yes 
	MOV	R5,N.DTDS(R1)	; The current segment is being displaced by a
				; segment which uses a different window. Save
				; the first one, which will be the highest
				; segment displaced and a candidate for the
				; recovery path load upon return from 
				; the target
35$:
	.ENDC			; C$$STR
	CMP	R3,R4		; Same I-space window as target segment?
	BEQ	90$		; If EQ, yes - continue
	TST	T$RLNG(R5)	; Zero length I-space?
	BEQ	40$		; If EQ, yes
	TST	W$NFLG(R4)	; I-space window mapped?
	BPL	40$		; If PL, no - continue
	BIC	#WF$MAP,W$NFLG(R4) ; Flag window as not mapped
	CALL	@N.FMAP(R1)	; Try fast mapping
40$:
	BIT	#TR$DSP,T$RLDA(R5) ; Does segment have D-space?
	BEQ	90$		; If EQ, no
	TST	T$DLNG(R5)	; Zero length D-space?
	BEQ	90$		; If EQ, yes
	MOV	T$DWDP(R5),R4	; Get D-space window descriptor
	TST	W$NFLG(R4)	; D-space window mapped?
	BPL	90$		; If PL, no
	BIC	#WF$MAP,W$NFLG(R4) ; Flag window as not mapped
	CALL	@N.FMAP(R1)	; Try fast mapping
90$:
	MOV	T$RDWN(R5),R5	; Get next segment
	BIT	#TR$DES,(R5)	; Reached root?
	BNE	10$		; If EQ, no
	
100$:	MOV	(SP)+,R2	; Restore R2
110$:	RETURN	

	.ENDC			; DF P$$LAS

;+
; **-$RDSEG-READ OVERLAY SEGMENT
;
; THIS ROUTINE IS CALLED TO LOAD AN OVERLAY SEGMENT INTO MEMORY. IT
; IS ONE OF THE OVERLAY RUN TIME ROUTINES AND IS CALLED FROM BOTH THE
; $LOAD (MANUAL LOADING) AND $AUTO (AUTOMATIC LOADING) ROUTINES.
;
; INPUTS:
;
;	R1=ADDRESS OF RUNTIME IMPURE DATA AREA
;	R2=ADDRESS OF SEGMENT DESCRIPTOR OF SEGMENT TO BE LOADED.
;
; OUTPUTS:
;
;	C=1 IF I/O ERROR ON EITHER THE INITIAL REQUEST DIRECTIVE OR AT
;		THE COMPLETION OF A SYNCHRONOUS LOAD REQUEST.
;	C=0 IF REQUEST IS SUCCESSFULLY COMPLETED. SEGMENT IS MARKED IN
;		MEMORY.
; 	R3,R4,R5 ARE  DESTROYED
;-


	.PSECT	$$RDSG	I,RO,LCL,REL,OVR

$RDSEG::

	BIC	#TR$MEM,(R2)	; MARK SEGMENT IN MEMORY

	.IF DF	P$$LAS		; IF PLAS IS SUPPORTED

;
; MAP I-SPACE OVERLAY SEGMENT
;

	CMPB	N.SZSG(R1),#S$ZSEG+2 ; TASK HAVE RESIDENT OVERLAYS?
	BLO	200$		; IF LO NO
	TST	T$RLNG(R2)	; ZERO LENGTH I-SPACE?
	BEQ	100$		; IF EQ YES
	MOV	T$RWDP(R2),R3	; GET I-SPACE WINDOW DESCRIPTOR
	BEQ	100$		; IF EQ NONE
	TST	W$NFLG(R3)	; I-SPACE WINDOW MAPPED?
	BMI	100$		; IF MINUS, YES
	MOV	W$NREG(R3),R4	; GET POINTER TO REGION
	BEQ	60$		; IF EQ NONE
	TST	R$GFLG(R4)	; REGION ATTACHED?
	BMI	40$		; IF MI YES
	.IF DF	C$$STR
	MOV	R.GSTS(R4),-(SP) ; SAVE R.GSTS SET BY TKB
	.ENDC

	CLR	R.GSTS(R4) 	; GET REGION ID IF ALREADY ATTACHED
				; WITHOUT CREATING AN ADB
	ATRG$S	R4		; ATTACH REGION
	
	.IF NDF	C$$STR		; IF NO CLUSTER LIBRARY SUPPORT

	BCS	70$		; BR IF ATTACH FAILURE

	.IFF	; NDF C$$STR

	MOV	(SP)+,R.GSTS(R4) ; RESTORE  R.GSTS
	BCC	30$		; ALREADY ATTACHED
	ATRG$S	R4		; ATTACH REGION
	BCS	70$		; IF CS, THEN ATTACH FAILED
30$:
	.ENDC	; NDF C$$STR

	BIS	#RF$ATT,R$GFLG(R4) ; SET ATTACHED FLAG
40$:				;
	MOV	R.GID(R4),W.NRID(R3) ; SET REGION I/D
60$:				;
	CRAW$S	R3		; MAP I-SPACE ADDRESS WINDOW
	BCC	65$		; IF CC MAPPING SUCCESSFUL
	BIC	#WS.WRT,W.NSTS(R3) ; CHANGE MAPPING STATUS TO R/O
	CRAW$S	R3		; TRY MAPPING AGAIN
	BCS	70$		; BR IF MAP FAILURE
65$:
	BIS	#WF$MAP,W$NFLG(R3) ; SET STATUS=MAPPED
	BR	100$		;
70$:
	JMP	700$		; MAP FAILURE
100$:				;

;
; MAP D-SPACE OVERLAY SEGMENT
;

	BIT	#TR$DSP,T$RLDA(R2) ; DOES SEGMENT HAVE D-SPACE?
	BEQ	200$		; IF EQ NO
	TST	T$DLNG(R2)	; ZERO LENGTH D-SPACE?
	BEQ	200$		; IF EQ YES
	MOV	T$DWDP(R2),R3	; GET D-SPACE WINDOW DESCRIPTOR
	BEQ	200$		; IF EQ NONE
	TST	W$NFLG(R3)	; D-SPACE WINDOW MAPPED?
	BMI	200$		; IF MINUS, YES
	TST	W$NREG(R3)	; IS THERE A REGION DESCRIPTOR?
	BNE	70$		; IF NE YES - ERROR, D-SPACE OVERLAYS ARE
				; NOT SUPPORTED FOR REGIONS WHOSE ID'S ARE
				; OTHER THAN 0 AND 1
	CRAW$S	R3		; MAP D-SPACE ADDRESS WINDOW
	BCC	165$		; IF CC MAPPING SUCCESSFUL
	BIC	#WS.WRT,W.NSTS(R3) ;CHANGE MAPPING STATUS TO R/O
	CRAW$S	R3		; TRY MAPPING AGAIN
	BCS	70$		; BR IF MAP FAILURE
165$:
	BIS	#WF$MAP,W$NFLG(R3) ; SET STATUS=MAPPED
200$:				;
	BIT	#<TR$DSK!TR$LOD>,(R2) ; SEGMENT TO BE LOADED?
	BNE	600$		; IF NE NO
	BIS	#TR$LOD,(R2)	; MARK SEGMENT AS LOADED

	.IFF

	BIT	#TR$DSK,(R2)	; SEGMENT HAVE DISK SPACE?
	BNE	600$		; IF NE NO DISK

	.IFTF

	TST	T$RLNG(R2)	; ZERO LENGTH I-SPACE?
	BEQ	500$		; IF EQ YES

;
; BUILD A QIO DPB ON THE STACK TO LOAD THE I-SPACE DISK OVERLAY OR THE MEMORY
; RESIDENT OVERLAY IF IT HAS NOT YET BEEN LOADED
;

	CLR	-(SP)		; CLEAR PARAM. WORD 6
	MOV	(R2),-(SP)	; SET RELATIVE BLOCK NUMBER
	BIC	#170000,(SP)	; CLEAR STATUS FIELD
	CLR	-(SP)		; SECOND HALF OF RELATIVE BLOCK IS ZERO
	CLR	-(SP)		; ZERO STACK WORD
	MOV	T$RLNG(R2),-(SP) ; SET LENGTH OF OVERLAY SEGMENT
	MOV	T$RLDA(R2),-(SP) ; SET I-SPACE VIRTUAL LOAD ADDRESS
	BIC	#TR$DSP,(SP)	; CLEAR D-SPACE FLAG
	CLR	-(SP)		; NO AST TRAP ADDRESS
	MOV	R1,R4		; CALCULATE ADDRESS OF COMMON I/O STATUS
	ADD	#N.IOST,R4	;
	MOV	R4,-(SP)	; SET I/O STATUS BLOCK
	MOV	#O$VEF,-(SP)	; SET SYSTEM EVENT FLAG
	MOV	(R1),-(SP)	; SET LOGICAL UNIT NUMBER FOR OVERLAYS
	MOV	#IO.LOV,-(SP)	; SET FUNCTION CODE
	MOV	(PC)+,-(SP)	; SET DIRECTIVE CODE AND LENGTH
	.BYTE	Q$IOW,12.	;
	DIR$			; LOAD I-SPACE PART OF OVERLAY SEGMENT
	BCS	610$		; IF CS DIRECTIVE ERROR
	TSTB	(R4)		; TEST FINAL STATUS
	BMI	610$		; IF MI OVERLAY READ ERROR
500$:
	BIT	#TR$DSP,T$RLDA(R2) ; SEGMENT HAS D-SPACE?
	BEQ	600$		; IF EQ NO
	TST	T$DLNG(R2)	; ZERO LENGTH D-SPACE PART?
	BEQ	600$		; IF EQ YES

;
; BUILD A QIO DPB ON THE STACK TO LOAD THE D-SPACE DISK OVERLAY OR THE MEMORY
; RESIDENT OVERLAY IF IT HAS NOT YET BEEN LOADED
;

	CLR	-(SP)		; CLEAR PARAM. WORD 6
	MOV	T$DBLK(R2),-(SP) ; SET RELATIVE BLOCK NUMBER
	CLR	-(SP)		; SECOND HALF OF RELATIVE BLOCK IS ZERO
	CLR	-(SP)		; ZERO STACK WORD
	MOV	T$DLNG(R2),-(SP) ; SET LENGTH OF OVERLAY SEGMENT
	MOV	T$DLDA(R2),-(SP) ; SET D-SPACE VIRTUAL LOAD ADDRESS
	CLR	-(SP)		; NO AST TRAP ADDRESS
	MOV	R1,R4		; CALCULATE ADDRESS OF COMMON I/O STATUS
	ADD	#N.IOST,R4	;
	MOV	R4,-(SP)	; SET I/O STATUS BLOCK
	MOV	#O$VEF,-(SP)	; SET SYSTEM EVENT FLAG
				; >>>>>>>> ASSUME THAT N.OVLY = 0 <<<<<<<<
	MOV	(R1),-(SP)	; SET LOGICAL UNIT NUMBER FOR OVERLAYS
	MOV	#IO.LDO,-(SP)	; SET FUNCTION CODE: LOAD D-SPACE OVERLAY
	MOV	(PC)+,-(SP)	; SET DIRECTIVE CODE AND LENGTH
	.BYTE	Q$IOW,12.	;
	DIR$			; LOAD D-SPACE PART OF OVERLAY SEGMENT
	BCS	610$		; IF CS DIRECTIVE ERROR
	TSTB	(R4)		; TEST FINAL STATUS
	BMI	610$		; IF MI OVERLAY READ ERROR
600$:
	CLC			; SUCCESS
	RETURN			;
610$:
	.IFT

	BIC	#TR$LOD,(R2)	; MARK SEGMENT NOT LOADED

	.IFTF

700$:
	BIS	#TR$MEM,(R2)	; MARK SEGMENT OUT OF MEMORY
	SEC			; FAILURE
	RETURN			;

	.PAGE
;+
; **-PDLSV SERVICE PUSHDOWN LIBRARY MAPPING CALLS
;
; THIS ROUTINE IS PLACED HERE AS AN EXTENSION OF $AUTO EXECUTED WHEN
; A PUSHDOWN LIBRARY MAP IS DETECTED. THE CODE IS NOT IN AUTO IN ORDER
; TO SAVE MEMORY WHEN $AUTO IS USED FOR NON-PLAS MAPPED TASKS.
;-

	.PSECT	$$PDLS	I,RO,LCL,REL,OVR

PDLSV:
	.IF DF C$$STR		; IF CLUSTERS ARE SUPPORTED
;
; A PUSH-DOWN MAP HAS BEEN DETECTED. WE MUST EXPAND THE STACK TO
; PROVIDE STORAGE FOR THE DISPLACED SEGMENT ADDRESS.
;
	MOV	SP,R3		; POINT TO RETURN ADDRESS OF REGISTER RESTORE
	CMP	-(SP),-(SP)	; PROVIDE SPACE
	MOV	SP,R4		; SET DESTINATION POINTER

	MOV	(R3)+,(R4)+	; SHUFFLE THE STACK (REGISTER RESTORE ADDRESS)
	MOV	(R3)+,(R4)+	; SHUFFLE THE STACK (SAVED R1)
	MOV	(R3)+,(R4)+	; SHUFFLE THE STACK (SAVED R2)
	MOV	(R3)+,(R4)+	; SHUFFLE THE STACK (SAVED R3)
	MOV	(R3)+,(R4)+	; SHUFFLE THE STACK (SAVED R4)
	MOV	(R3)+,(R4)+	; SHUFFLE THE STACK (SAVED R5)

	MOV	#80$-75$,(R4)	; SET IN THE ADDRESS OF A COROUTINE CALL
	ADD	PC,(R4)+	; COMPUTE REAL ADDRESS IN A PIC FASHON
75$:
	MOV	(R3)+,(R4)+	; COPY THE TARGET ROUTINE ADDRESS
	MOV	R2,(R4)		; AND SAVE THE DISPLACED SEGMENT ADDRESS

	CALLR	ASTEN		; REEANBLE ASTS IF DISABLED
				; AND RETURN TO REGISTER RESTORE AND THENCE
				; TO THE TARGET VIA "80$" BELOW

;
; CALL THE TARGET AS A CO-ROUTINE.
;
80$:
	CALL	@(SP)+		; CALL THE TARGET
;
; (SP) = ADDRESS OF THE SEGMENT DISPLACED IN ORDER TO MAP THE TARGET
; 	SEGMENT
; 2(SP) = USER RETURN ADDRESS IN THE SOURCE SEGMENT
;
	ROR	2(SP)		; SAVE THE CARRY BIT IN THE USERS RETURN
				; ADDRESS
	CALL	ASTDS		; DISABLE AST RECOGNITION
	JSR	R5,.SAVR1	; SAVE R1,R2,R3,R4,R5
	MOV	@#N.OVPT,R1	; PICK UP ADDRESS OF IMPURE DATA AREA
;
; (SP) = RETURN ADDRESS TO RESTORE REGISTERS
; 2,4,6,10,12(SP) = SAVED R1,R2,R3,R4,R5
; 14(SP) = ADDRESS OF DISPLACED SEGMENT
; 16(SP) = USERS RETURN ADDRESS WITH SAVED CARRY
;
	MOV	14(SP),R2	; GET SEGMENT ADDRESS

	MOV	PC,R3		; COMPUTE ADDRESS IN A PIC FASHON
85$:
	ADD	#90$-85$,R3	; SET ADDRESS OF ROUTINE TO RESTORE CARRY
	MOV	R3,14(SP)	;

	CALL	@N.MRKS(R1)	; MARK APPROPRIATE SEGMENTS OUT OF MEMORY
	CLR	N.DTDS(R1)	; RESET ANY INDICATION WE DISPLACED A SEGMENT
	JMP	$ALBPL		; AND GO PERFORM PATH LOAD IN $AUTO
;
; AFTER THE APPROPRIATE SEGMENTS HAVE BEEN LOADED, A DIRECT RETURN WILL BE
; TAKEN SINCE THERE IS NO "DISPLACED SEGMENT". THIS TAKES US TO THIS POINT
; WHERE THE CARRY IS RESTORED AND A REAL RETURN TO THE ORIGINAL CALLING SEGMENT
; IS MADE.
;
90$:
	ASL	(SP)		; RESTORE THE CARRY
	RETURN			; FINALLY RETURN TO THE CALLER

	.IFF			; IF CLUSTERS ARE NOT SUPPORTED

	.IF DF P$$LAS		; AND PLAS IS SUPPORTED

	MOV	#IE.OVR&377,@#$DSW ; 'FAKE' AN "ILLEGAL OVERLAY" ERROR
	JMP	ALERR		; AND GO TO AUTOLOAD ERROR SERVICE

	.IFF			; IF PLAS IS NOT SUPPORTED

	RETURN			; AND RETURN TO REGISTER RESTORE AND THENCE
				; TO THE TARGET.

	.ENDC			; IF PLAS SUPPORTED OR NOT

	.IFT			; IF CLUSTERS ARE SUPPORTED

	.DSABL	LSB
;
; DEFINE OVERMAPPED PSECT FOR ACCESS TO THE AST ENABLE/DISABLE AND
; ERROR SERVICE ROUTINES.
;
	.PSECT	$$RTQ	I,RO,GBL,REL,OVR
ASTEN:				; ADDRESS OF AST ENABLE ROUTINE
	.PSECT	$$RTR	I,RO,GBL,REL,OVR
ASTDS:				; ADDRESS OF AST DISABLE ROUTINE
	.PSECT	$$RTS	I,RO,GBL,REL,OVR
				; PUT RETURN SEGMENT HERE TO PRESERVE ORDER

	.ENDC			; IF CLUSTERS OR NOT

	.PSECT	$$ALER	I,RO,LCL,REL,CON
ALERR:				; ENTRY POINT TO AUTOLOAD ERROR SERVICE

	.ENDC			; PLAS OR NON-PLAS

	.END
