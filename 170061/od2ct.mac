	.TITLE	OD2CT - CONVERT FROM ASCII TO TWO BINARY WORDS
	.IDENT	/V0301/
;  
; 		COPYRIGHT (c) 1981 BY
; 	DIGITAL EQUIPMENT CORPORATION, MAYNARD
; 	 MASSACHUSETTS.  ALL RIGHTS RESERVED.
;  
; THIS  SOFTWARE  IS FURNISHED UNDER A LICENSE AND MAY
; BE USED AND  COPIED  ONLY  IN  ACCORDANCE  WITH  THE
; TERMS  OF SUCH LICENSE AND WITH THE INCLUSION OF THE
; ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER
; COPIES  THEREOF  MAY  NOT  BE  PROVIDED OR OTHERWISE
; MADE AVAILABLE TO ANY OTHER  PERSON.   NO  TITLE  TO
; AND OWNERSHIP OF THE SOFTWARE IS HEREBY TRANSFERRED.
;  
; THE  INFORMATION  IN  THIS  SOFTWARE  IS  SUBJECT TO
; CHANGE WITHOUT NOTICE AND SHOULD  NOT  BE  CONSTRUED
; AS  A  COMMITMENT  BY DIGITAL EQUIPMENT CORPORATION.
;  
; DIGITAL ASSUMES NO RESPONSIBILITY  FOR  THE  USE  OR
; RELIABILITY  OF  ITS  SOFTWARE  ON EQUIPMENT THAT IS
; NOT SUPPLIED BY DIGITAL.
;  

;
; ANDREW C. GOLDSTEIN  10 JUL 1974
;
;
;	M. PETTENGILL	5-MAY-81
;		MLP034 - PUT CODE IN $$RESL WITH READ-ONLY ATTRIBUTE
;			ADD SUPPORT FOR # (OCTAL RADIX SIGN)
;			ADD ENTRY POINT FOR CSI2
;

.MACRO	SAVR1
	JSR	R5,.SAVR1
.ENDM	SAVR1

	.PSECT	$$RESL,RO

;+
;
; *** - .DD2CT	CONVERT A DECIMAL NUMBER TO TWO BINARY WORDS.
;		THIS SUBROUTINE CONVERTS AN ASCII DECIMAL NUMBER STRING
;		TO A DOUBLE LENGTH BINARY NUMBER. A TRAILING DECIMAL
;		POINT IS PERMITTED.
;
; *** - .OD2CT	CONVERT AN OCTAL OR DECIMAL NUMBER TO TWO BINARY WORDS.
;		THIS SUBROUTINE CONVERTS AN ASCII OCTAL OR DECIMAL
;		NUMBER STRING TO A DOUBLE LENGTH BINARY NUMBER. RADIX
;		IS CONTROLLED BY THE PRESENCE OR ABSENCE OF A TRAILING
;		DECIMAL POINT.
;
;	BOTH ENTRIES ACCEPT A LEADING "+" OR "-" AND PRODUCE A TWO'S
;	COMPLEMENT NEGATIVE FOR THE LATTER.
;
; INPUT:
;	R3 - ADDRESS OF TWO WORD FIELD TO HOLD CONVERTED NUMBER
;		WORD 1 - HIGH ORDER 16 BITS
;		WORD 2 - LOW ORDER 16 BITS
;	R4 - CHARACTER COUNT OF STRING
;	R5 - ADDRESS OF STRING
;
; OUTPUT:
;
;	CC-C
;	     CLEAR - SUCCESSFUL CONVERSION
;	     SET   - ILLEGAL CHARACTERS IN STRING
;
; ALL REGISTERS ARE PRESERVED
;
;-

	.ENABL	LSB

.DD2CT::SAVR1			; SAVE REGISTERS
	MOV	#10.,R1		; SET UP FOR DECIMAL RADIX ONLY
	BR	10$

.OD2CT::SAVR1			; SAVE REGISTERS
	MOV	#8.,R1		; SET UP FOR OCTAL RADIX

10$:	CLR	-(SP)		; CLEAR NEGATIVE FLAG
	CMPB	(R5),#'+	; LOOK FOR LEADING "+"
	BEQ	15$		; YES
	CMPB	(R5),#'-	; LOOK FOR LEADING "-"
	BNE	20$		; NO
	INC	(SP)		; YES - SET NEGATIVE
15$:	INC	R5		; EITHER - DISPOSE OF CHARACTER
	DEC	R4

20$:	MOV	R5,R2		; COPY THE STRING POINTER
	ADD	R4,R2		; POINT TO END OF STRING
	CMPB	-(R2),#'.	; LOOK FOR TRAILING DECIMAL POINT
	BNE	25$		; NO
	MOV	#10.,R1		; YES - SET DECIMAL
	BR	30$		; JOIN COMMON CODE

25$:	CMPB	(R5),#'#	; LEADING "#"?
	BNE	40$		; IF NE NO
	MOV	#8.,R1		; SET OCTAL
	INC	R5		; SKIP CHARACTER
	
30$:	DEC	R4		; REMOVE FROM STRING

40$:	CLR	(R3)+		; ZERO HIGH ORDER 16 BITS
	CLR	(R3)		; ZERO LOW ORDER 16 BITS

50$:	MOVB	(R5)+,R2	; GET NEXT CHARACTER
	SUB	#'0,R2		; CONVERT DIGIT TO VALUE
	BLO	90$		; NOT A LEGAL DIGIT CHARACTER

	CMP	R2,R1		; LAST CHANCE TO BE IN RANGE
	BHIS	90$		; DEFINITELY NOT LEGAL
	ASL	(R3)		; MULTIPLY CURRENT BINARY NUMBER BY 2
	ROL	-(R3)		; USE FULL 32 BIT ACCURACY
	MOV	(R3)+,-(SP)	; SAVE HIGH ORDER BITS
	MOV	(R3),-(SP)	; SAVE LOW ORDER BITS
	ASL	(R3)		; MULTIPLY AGAIN BY 2
	ROL	-(R3)		; KEEP THOSE BITS MOVING
	ASL	2(R3)		; MAKE TOTAL MULTIPLICATION BY 8
	ROL	(R3)+		; NOW HAVE (NEW NUMBER) = (OLD NUMBER)*8

	CMP	R1,#10.		; CHECK WHAT RADIX WE'RE IN
	BEQ	60$		; EQUAL IF DECIMAL
	CMP	(SP)+,(SP)+	; OCTAL - THROW AWAY (OLD NUMBER)*2
	BR	70$

60$:	ADD	(SP)+,(R3)	; ADD BACK (OLD NUMBER)*2
	ADC	-(R3)		; ADD ANY OVERFLOW TO HIGH ORDER
	ADD	(SP)+,(R3)+	; NOW HAVE (NEW NUMBER) = (OLD NUMBER)*10

70$:	ADD	R2,(R3)		; ADD THIS DIGIT TO MAKE NEW TOTAL
	ADC	-2(R3)		; MAKE SURE OVERFLOW IS CONSIDERED
	DEC	R4		; COUNT CHARACTERS
	BNE	50$		; GO GET NEXT DIGIT

	TST	(SP)+		; CHECK NEGATIVE FLAG
	BEQ	80$		; POSITIVE
	NEG	-(R3)		; COMPLEMENT HIGH ORDER
	NEG	2(R3)		; COMPLEMENT LOW ORDER
	SBC	(R3)		; AND PROPAGATE THE CARRY
	CCC			; SET SUCCESS
80$:	RETURN

; TO HERE ON AN ILLEGAL CHARACTER

90$:	TST	(SP)+		; CLEAN THE STACK
	SEC			; SET THE CARRY
	RETURN

	.DSABL	LSB

;+
;
; *** - ..D2CT	CONVERT A NUMBER FOR CSI2
;
; INPUT:
;	R3 = 2 IF OCTAL
;	     3 IF DECIMAL
;	R4 = CHARACTER COUNT OF STRING
;	R5 = ADDRESS OF STRING
;
; OUTPUTS:
;	R4 = LSB OF 32 BIT RESULT
;	R5 = MSB OF RESULT
;
;-

..D2CT::CLR	-(SP)			; ALLOCATE WORK BUFFER
	MOV	R3,-(SP)		; AND SAVE CONVERSION TYPE
	MOV	SP,R3			; SET ADDRESS OF BUFFER
	CMPB	#2,(R3)			; OCTAL?
	BEQ	10$			; IF EQ YES
	CALL	.DD2CT			; DO DECIMAL CONVERSION
	BR	20$			; JOIN COMMON CODE
10$:	CALL	.OD2CT			; DO OCTAL CONVERSION
20$:	ROL	R3			; SAVE STATE OF CARRY
	MOV	(SP)+,R5		; SET HIGH WORD OF RESULT
	MOV	(SP)+,R4		; SET LOW WORD OF RESULT
	RETURN				; RETURN TO CALLER


	.END
