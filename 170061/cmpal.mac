	.TITLE	CMPAL
	.IDENT	/03.01/

;
;		COPYRIGHT (c) 1983 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD
;	 MASSACHUSETTS.  ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE  IS  FURNISHED  UNDER  A LICENSE AND MAY BE USED
; AND  COPIED  ONLY IN  ACCORDANCE WITH THE TERMS OF SUCH LICENSE
; AND WITH  THE INCLUSION  OF THE ABOVE  COPYRIGHT  NOTICE.  THIS
; SOFTWARE  OR ANY OTHER  COPIES  THEREOF, MAY NOT BE PROVIDED OR
; OTHERWISE MADE  AVAILABLE TO ANY OTHER PERSON.  NO TITLE TO AND
; OWNERSHIP OF THE SOFTWARE IS HEREBY TRANSFERED.
;
; THE INFORMATION  IN THIS DOCUMENT IS SUBJECT  TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT  BY  DIGITAL
; EQUIPMENT CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF
; ITS SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.
;

	.ENABL	LC

;
; Authors:
;
;	Brian McCarthy
;	Michael Pettengill
;
; Modified by:
;
;	M. Pettengill	09-Feb-82	03.01
;		MLP069 -- Correct exit from super mode to super mode case.
;			  Add super mode RTI entry point $SRTI.
;
;
; This module supports the "new" transfer vector format generated by
; the taskbuilder for entering super mode libraries.  This format
; optimized for speed and size and supports user data space tasks.
;
; The CSM dispatcher routine and the standard completion routines,
; $CMPAL and $CMPCS are included in this module due to the close
; interaction between them.
;

;
; **-CSM Dispatcher-Dispatch CSM entry
; 
; This module must be linked at virtual zero in the supervisor mode
; library.  It is entered via a four word transfer vector of the form:
;
;	MOV	#completion-routine,-(SP)
;	CSM	#routine
;
; Note: Immediate mode emulation of the CSM instruction is required
; 	in the executive.
;
; The CSM instruction transfers control to the address contained in
; supervisor mode virtual 10.  At this point the stack is the following:
;
;	  (SP)	routine address
;	 2(SP)	PC (past end of transfer vector)
;	 4(SP)	PS with condition codes cleared
;	 6(SP)	Completion-routine address
;	10(SP)	Return address
;
; A routine address of 0 is special cased to support return to
; supervisor mode from a user mode debugging aid (ODT).  In this case
; stack is the following:
;
;	  (SP)	zero
;	 2(SP)	PC from CSM to be discarded
;	 4(SP)	PS from CSM to be discarded
;	 6(SP)	Super mode PC supplied by debugger
;	10(SP)	Super mode PS supplied by debugger
;

; To allow positioning at virtual zero, this code must be in the blank
; PSECT which is first in the TKBs PSECT ordering.

	.PSECT

	.ENABL	LSB

; Debugger return to super mode entry. Must start at virtual zero

	CMP	(SP)+,(SP)+	; Clean off PS and PC from CSM

;
; **-$SRTI-Super mode RTI
;
; This entry point performs the necessary stack management to allow
; an RTI from super mode to either super mode or user mode.
; The is as required for an RTI:
;
;	 (SP)	Super mode PC
;	2(SP)	Super mode PS
;

$SRTI::	TST	2(SP)		; Returning to user mode?
	BR	70$		; Join common code

; CSM transfer address, this word must be at virtual 10 in super mode

	.WORD	CSMSVR		; CSM dispatcher entry

; Dispatch CSM entry

CSMSVR:	MOV	6(SP),2(SP)	; Set completion routine address for RETURN
	JMP	@(SP)+		; Transfer to super mode library routine

;
; **-$CMPAL-Completion routine which sets up NZVC in the PS
;
; Copy all condition codes to stacked PS.  Current stack:
;
;	 (SP)	PS with condtion codes cleared
;	2(SP)	Completion routine address (to be discarded)
;	4(SP)	Return address
;

$CMPAL::BPL	40$		; 
	BNE	20$		; 
	BVC	10$		; 
	BIS	#16,(SP)	; Set NZV
	BR	$CMPCS		;
10$:	BIS	#14,(SP)	; Set NZ
	BR	$CMPCS		;
20$:	BVC	30$		;
	BIS	#12,(SP)	; Set NV
	BR	$CMPCS		;
30$:	BIS	#10,(SP)	; Set N
	BR	$CMPCS		;
40$:	BNE	60$		;
	BVC	50$		;
	BIS	#6,(SP)		; Set ZV
	BR	$CMPCS		;
50$:	BIS	#4,(SP)		; Set Z
	BR	$CMPCS		;
60$:	BVC	$CMPCS		;
	BIS	#2,(SP)		; Set V

;
; **-$CMPCS-Completion routine which sets up only C in the PS
;
; Copy only carry to stacked PS.  Current stack:
;
;	 (SP)	PS with condtion codes cleared
;	2(SP)	Completion routine address (to be discarded)
;	4(SP)	Return address
;

$CMPCS::ADC	(SP)		; Set up carry
	MOV	4(SP),2(SP)	; Setup return address for RTT
	MOV	(SP)+,2(SP)	; And PS. Returning to super mode?
70$:	BPL	80$		; If PL yes
	MOV	#6,-(SP)	; Number of bytes for (SP), PS, and PC
	ADD	SP,(SP)		; Compute clean stack value
	MTPI	SP		; Set up previous stack pointer
80$:	RTT			; Return to previous mode and caller

	.DSABL	LSB

	.END
