	.TITLE	OVFCTL	OPTIMIZED OVERLAY CONTROL ROUTINES
	.IDENT	/1.02/
;
;		COPYRIGHT (c) 1987 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD
;	 MASSACHUSETTS.  ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE  IS  FURNISHED  UNDER  A LICENSE AND MAY BE USED
; AND  COPIED  ONLY IN  ACCORDANCE WITH THE TERMS OF SUCH LICENSE
; AND WITH  THE INCLUSION  OF THE ABOVE  COPYRIGHT  NOTICE.  THIS
; SOFTWARE  OR ANY OTHER  COPIES  THEREOF, MAY NOT BE PROVIDED OR
; OTHERWISE MADE  AVAILABLE TO ANY OTHER PERSON.  NO TITLE TO AND
; OWNERSHIP OF THE SOFTWARE IS HEREBY TRANSFERED.
;
; THE INFORMATION  IN THIS DOCUMENT IS SUBJECT  TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT  BY  DIGITAL
; EQUIPMENT CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF
; ITS SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.
;
;
; MODIFIED FOR RSX-11M-PLUS AND MICRO/RSX V4.0 BY:
;
;	L. M. PETERSON	22-MAR-86	1.00
;				CREATE OPTIMIZED VERSION(S) OF MARKS FOR
;				AUTOLOADED TASKS
;
;	L. M. PETERSON	15-DEC-86	1.01	SPR#233P
;		LMP074		USE R.GSTS SET BY TKB TO ATTACH REGION FOR
;				CLUSTER LIBRARY (INSTEAD OF ALWAYS ATTACHING
;				READ ONLY)
;
;	L. M. PETERSON	28-AUG-87	1.02
;				ADD TEST BEFORE UPDATING N.DTDS LMP097

;------------------------------------------------------------------------
	.IF DF P$$LAS		; IF THIS ASSEMBLY SUPPORTS PLAS
	.IF DF C$$STR		; IF THIS ASSEMBLY SUPPORTS CLUSTERS
	.TITLE OVFCTC OVERLAY (DISK,PLAS,CLUS)
	.NLIST CND		; DON'T LIST CONDITIONALLY EXCLUDED CODE
	.IFF			; IF NO CLUSTER SUPPORT
	.TITLE OVFCTR OVERLAY (DISK,PLAS,-CLUS)
	.NLIST CND		; DON'T LIST CONDITIONALLY EXCLUDED CODE
	.ENDC
	.IFF			; IF NO PLAS SUPPORT REQUIRED
	.TITLE OVFCTL OVERLAY (DISK,-PLAS,-CLUS)
	.NLIST CND		; DON'T LIST CONDITIONALLY EXCLUDED CODE
	.ENDC
;------------------------------------------------------------------------


;
; OVERLAY RUN TIME ROUTINES
;
; EQUATED SYMBOLS
;

O$VEF=31.			; SYSTEM OVERLAY EVENT FLAG
Q$IO=1				; QUEUE I/O DIRECTIVE CODE
W$FR=41.			; WAIT FOR EVENT FLAG DIRECTIVE CODE

;
; MACRO LIBRARY CALLS
;

	.MCALL	ATRG$S,CRAW$S,DIR$,QIOSY$,WTSE$S
	RGDF	,,S
	WDBDF	,,S
	QIOSY$

;+
; **-$MARKS-MARK SEGMENT
;
; THIS ROUTINE IS CALLED TO MARK ALL SEGMENTS OUT OF MEMORY THAT ARE
; NOT ON THE SAME PATH AS THE ARGUMENT SEGMENT. IT IS ONE OF THE OVER-
; LAY RUN TIME ROUTINES AND IS CALLED BY BOTH THE $LOAD (MANUAL LOAD-
; ING) AND $AUTO (AUTOMATIC LOADING) ROUTINES.
;
; INPUTS:
;
;	R1=ADDRESS OF RUNTIME IMPURE DATA AREA
;	R2=ADDRESS OF ARGUMENT SEGMENT DESCRIPTOR.
;
; OUTPUTS:
;
;	THE APPROPRIATE SEGMENTS ARE MARKED OUT OF MEMORY
;	R3, R4, AND R5 ARE ALTERED
;
;-


	.PSECT	$$MRKS	I,RO,LCL,REL,OVR

;
; NOTE IN THE FOLLOWING GLOBAL SYMBOL DEFINITIONS THAT THESE
; DEFINITIONS HOLD:
;		MODULE:		DEFINITIONS:
;		 OVFCTL		 $MARKS,$MAFKS
;		 OVFCTR		 $MARKS,$MAFKS,$MAFKR
;		 OVFCTC		 $MARKS,$MAFKS,$MAFKR,$MAFKC
;
; THIS PERMITS CORRECT LINKING OF A USER TASK WHEN LINKED AGAINST
; A SHARABLE LIBRARY CONTAINING MORE SUPPORT THAN IS IMMEDIATELY REQUIRED
; BY THAT SPECIFIC TASK.
;

$MARKS::

$MAFKS::
	.IF NDF	P$$LAS		; IF PLAS IS NOT SUPPORTED 
				; DEFINE LABEL TO DRAW THIS MODULE FROM SYSLIB 
				; IF THE TASKBUILDER DETECTS *ONLY* DISK 
				; RESIDENT OVERLAYS. 

	BIT	#TR$MEM,(R2)	; Target segment already in memory?
	BEQ	110$		; If EQ, yes
	MOV	R2,-(SP)	; Save R2
	CLR	R3		; Initialize in-mem target path value
	MOV	R2,R4		; Save segment address

10$:	; Search load path of target segment for highest segment in memory

	TST	(R2)		; Reached root segment?
	BPL	20$		; If PL, yes
	MOV	T$RDWN(R2),R2	; Proceed down to root
	BIT	#TR$MEM,(R2)	; This segment in memory?
	BNE	10$		; If NE, no
	TST	R3		; Already found a segment in memory?
	BNE	10$		; If NE, yes
	MOV	R2,R3		; Save highest in-memory segment on target path
	BR	10$	

20$:	; Get load info and update

	MOV	T$RDWN(R2),R5	; Get highest loaded segment in current tree
	MOV	R4,T$RDWN(R2) 	; Save the segment that's going to be loaded
	TST	R5		; Any overlay loaded?
	BEQ	100$		; If EQ, no

30$:	; Mark segment out of memory and continue

	CMP	R3,R5		; Reached a common point?
	BEQ	100$		; If EQ, yes - so quit
	BIS	#TR$MEM,(R5)	; Mark segment out of memory
	MOV	T$RDWN(R5),R5	; Get next segment to unload
	TST	(R5)		; Reached root?
	BMI	30$		; If MI, no - go unload next segment

100$:	MOV	(SP)+,R2	; Restore R2
110$:	RETURN



	.IFF 			; P$$LAS DEFINED
$MARKR::
$MAFKR::			; IF PLAS IS SUPPORTED AND CLUSTER LIBRARIES
				; ARE *NOT* SUPPORTED
				; DEFINE LABEL TO DRAW THIS MODULE FROM SYSLIB
				; WHEN THE TASKBUILDER DETECTS REFERENCE TO A
				; MEMORY RESIDENT OVERLAY AND NO CLUSTER 
				; LIBRARY REFERENCES
	.IF DF C$$STR		
$MARKC::			; IF PLAS *AND* CLUSTER LIBRARIES ARE SUPPORTED
$MAFKC::			; DEFINE LABEL TO DRAW THIS MODULE FROM SYSLIB
				; WHEN THE TASKBUILDER DETECTS REFERENCE TO A
				; MEMORY RESIDENT OVERLAY AND AT LEAST ONE 
				; CLUSTER LIBRARY REFERENCE
	.ENDC			; C$$STR

	BIT	#TR$MEM,(R2)	; Target segment already in memory?
	BEQ	110$		; If EQ, yes - so quit
	MOV	T$RNME(R2),R4	; Get pointer to root
	MOV	T$RDWN(R4),R5	; Get address of highest loaded segment
	MOV	R2,T$RDWN(R4)	; Update address to target segment
	TST	R5		; Any overlay loaded?
	BEQ	110$		; If EQ, no
	MOV	R2,-(SP)	; Save R2
	MOV	T$RWDP(R2),R3	; Save address of window block of target segment
	.IF DF C$$STR
	CLR	N.DTDS(R1)	; Reset the 'segment displaced' address
	.ENDC

; At this point:
; 	R2 is address of current segment on load path of target segment
;	R5 is address of current segment on unload path

10$:
	CMP	T$RLDA(R5),T$RLDA(R2) ; At same or lower APR on target path?
	BPL	20$		; If PL, yes - continue
	MOV	T$RDWN(R2),R2	; Move down target path
	BR	10$		; Try again
20$:
	CMP	R2,R5		; Reached common point?
	BEQ	100$		; If EQ, yes - so quit
	MOV	T$RDWN(R5),R4	; Get window block for parent of segment
	BIS	#TR$MEM,(R5)	; Mark segment out of memory
	CMP	T$RWDP(R5),T$RWDP(R4) ; Same window (ie, DR on top of DR or MR)?
	BNE	30$		; If NE, no
	BIC	#TR$LOD,(R5)	; Mark segment unloaded
	BR	40$		; Go get next segment
30$:
	MOV	T$RWDP(R5),R4	; Get window block of this segment
	.IF DF C$$STR
	CMP	W$NREG(R3),W$NREG(R4) ; Displaced segment in a different region?
	BEQ	35$		; If EQ, yes - no PD library
	TST	N.DTDS(R1)	; Have highest segment displaced?
	BNE	35$		; If NE, yes 
	MOV	R5,N.DTDS(R1)	; The current segment is being displaced by a
				; segment which uses a different window. Save
				; the first one, which will be the highest
				; segment displaced and a candidate for the
				; recovery path load upon return from 
				; the target
35$:
	.ENDC			; C$$STR
	TST	W$NFLG(R4)	; Window mapped?
	BPL	40$		; If PL, no - continue
	CMP	R3,R4		; Same window block as target segment?
	BEQ	40$		; If EQ, yes - continue
	BIC	#WF$MAP,W$NFLG(R4) ; Flag window as not mapped
	CALL	@N.FMAP(R1)	; Try fast mapping
40$:
	MOV	T$RDWN(R5),R5	; Get next segment
	TST	(R5)		; Reached root?
	BMI	10$		; If EQ, no
	
100$:	MOV	(SP)+,R2	; Restore R2
110$:	RETURN	

	.ENDC			; DF P$$LAS

;+
; **-$RDSEG-READ OVERLAY SEGMENT
;
; THIS ROUTINE IS CALLED TO LOAD AN OVERLAY SEGMENT INTO MEMORY. IT
; IS ONE OF THE OVERLAY RUN TIME ROUTINES AND IS CALLED FROM BOTH THE
; $LOAD (MANUAL LOADING) AND $AUTO (AUTOMATIC LOADING) ROUTINES.
;
; INPUTS:
;
;	R1=ADDRESS OF RUNTIME IMPURE DATA AREA
;	R2=ADDRESS OF SEGMENT DESCRIPTOR OF SEGMENT TO BE LOADED.
;	R3=EVENT FLAG NUMBER.
;		IF R3 EQ 0, THEN A SYNCHRONOUS LOAD IS SPECIFIED. THE
;			EVENT FLAG THAT IS USED TO SYNCHRONIZE THE
;			LOADING IS THE STANDARD OVERLAY EVENT FLAG.
;		IF R3 NE 0, THEN AN ASYNCHRONOUS LOAD REQUEST IS SPEC-
;			IFIED. THE SPECIFIED EVENT FLAG IS USED IN THE
;			LOAD REQUEST THUS PROVIDING SYNCHRONIZATION
;			FOR THE CALLER.
;	R4=ADDRESS OF I/O STATUS DOUBLEWORD. IF NO STATUS DOUBLEWORD IS
;		SPECIFIED NO I/O STATUS IS RETURNED TO THE CALLER.
;	R5=AST TRAP ADDRESS. IF NO TRAP ADDRESS IS SPECIFIED NO TRAP OC-
;		CURS.
;
; OUTPUTS:
;
;	C=1 IF I/O ERROR ON EITHER THE INITIAL REQUEST DIRECTIVE OR AT
;		THE COMPLETION OF A SYNCHRONOUS LOAD REQUEST.
;	C=0 IF REQUEST IS SUCESSFULLY COMPLETED. SEGMENT IS MARKED IN
;		MEMORY.
; 	R3,R4,R5 ARE  DESTROYED
;-


	.PSECT	$$RDSG	I,RO,LCL,REL,OVR

$RDSEG::
	BIC	#TR$MEM,(R2)	; MARK SEGMENT IN MEMORY
	TST	T$RLNG(R2)	; ZERO LENGTH SEGMENT?
	BNE	1$		; IF NE NO
	BIS	#TR$LOD,(R2)	; MARK SEGMENT LOADED
	RETURN			; AND RETURN
1$:

	.IF DF	P$$LAS		;

	MOV	R3,-(SP)	; SAVE SOME REGISTERS
	MOV	R4,-(SP)	;

	CMPB	N.SZSG(R1),#S$ZSEG+2 ; TASK HAVE RESIDENT OVERLAYS?
	BLO	7$		; IF LO NO
	MOV	T$RWDP(R2),R3	; GET WINDOW BLOCK ADDRESS
	BEQ	7$		; IF EQ NONE
		.IIF NE WF$MAP-100000 .ERROR ; ASSUMPTION ERROR

	TST	W$NFLG(R3)	; WINDOW MAPPED?
	BMI	7$		; IF MINUS, YES
	MOV	W$NREG(R3),R4	; GET POINTER TO REGION
	BEQ	6$		; IF EQ NONE
		.IIF NE RF$ATT-100000 .ERROR ; ASSUMPTION ERROR

	TST	R$GFLG(R4)	; REGION ATTACHED?
	BMI	4$		; IF MINUS, YES.

	.IF DF	C$$STR
	MOV	R.GSTS(R4),-(SP) ; SAVE R.GSTS SET BY TKB
	.ENDC

	CLR	R.GSTS(R4) 	; GET REGION ID IF ALREADY ATTACHED
				; WITHOUT CREATING AN ADB
	ATRG$S	R4		; ATTACH REGION
	
	.IF DF	C$$STR
	MOV	(SP)+,R.GSTS(R4) ; RESTORE  R.GSTS
	.ENDC

	.IF DF 	P$$LAS		; IF PLAS SUPPORT

	.IF NDF	C$$STR		; IF NO CLUSTER LIBRARY SUPPORT

	BCS	71$		; BR IF ATTACH FAILURE

	.IFF	; NDF C$$STR

	BCC	3$		; ALREADY ATTACHED
	ATRG$S	R4		; ATTACH REGION
	BCS	71$		; IF CS, THEN ATTACH FAILED
3$:				; LABEL REFERENCE

	.ENDC	; NDF C$$STR

	.ENDC	; DF P$$LAS

	BIS	#RF$ATT,R$GFLG(R4) ; SET ATTACHED FLAG
4$:				;
	MOV	R.GID(R4),W.NRID(R3) ; SET REGION I/D
6$:				;
	CRAW$S	R3		; MAP ADDRESS WINDOW
	BCC	650$		; IF CC MAPPING SUCCESSFUL
	BIC	#WS.WRT,W.NSTS(R3) ;CHANGE MAPPING STATUS TO R/O
	CRAW$S	R3		; TRY MAPPING AGAIN
	BCS	71$		; BR IF MAP FAILURE
650$:
	BIS	#WF$MAP,W$NFLG(R3) ; SET STATUS=MAPPED
7$:				;
	CLC			; CLEAR CARRY
71$:
	MOV	(SP)+,R4	; RESTORE REGISTERS
	MOV	(SP)+,R3	;
	BCS	40$		; BR IF DIRECTIVE ERROR ABOVE
	BIT	#<TR$DSK!TR$LOD>,(R2) ; SEGMENT TO BE LOADED?
	BNE	50$		; IF NE NO
	BIS	#TR$LOD,(R2)	; MARK SEGMENT AS LOADED
	.IFF
	BIT	#TR$DSK,(R2)	; SEGMENT HAVE DISK SPACE?
	BNE	50$		; IF NE NO DISK
	.IFTF
;
; BUILD A QIO DPB ON THE STACK TO LOAD THE DISK OVERLAY OR THE MEMORY
; RESIDENT OVERLAY IF IT HAS NOT YET BEEN LOADED
;
	CLR	-(SP)		; CLEAR PARAM. WORD 6
	MOV	(R2),-(SP)	; SET RELATIVE BLOCK NUMBER
	BIC	#170000,(SP)	; CLEAR STATUS FIELD
	CLR	-(SP)		;SECOND HALF OF RELATIVE BLOCK IS ZERO
	CLR	-(SP)		;ZERO STACK WORD
	MOV	T$RLNG(R2),-(SP);SET LENGTH OF OVERLAY SEGMENT
	MOV	T$RLDA(R2),-(SP);SET VIRTUAL LOAD ADDRESS
	MOV	R5,-(SP)	;SET AST TRAP ADDRESS
	MOV	R4,-(SP)	;SET I/O STATUS DOUBLE WORD ADDRESS
	BNE	10$		;IF NE ONE SPECIFIED
	TSTB	R3		;SYNCHRONOUS REQUEST?
	BNE	10$		;IF NE NO
	MOV	R1,R4		; CALCULATE ADDRESS OF COMMON I/O STATUS
	ADD	#N.IOST,R4	;
	MOV	R4,(SP)		;
10$:				;
	MOV	R3,-(SP)	; SET EVENT FLAG NUMBER
	BNE	15$		;IF NE ASYNCHRONOUS REQUEST
	MOV	#O$VEF,(SP)	;SET SYSTEM EVENT FLAG
15$:				;
				; >>>>>>>> ASSUME THAT N.OVLY = 0 <<<<<<<<
	MOV	(R1),-(SP)	; SET LOGICAL UNIT NUMBER FOR OVERLAYS
	MOV	#IO.LOV,-(SP)	;SET FUNCTION CODE
	MOV	(PC)+,-(SP)	;SET DIRECTIVE CODE AND LENGTH
	.BYTE	Q$IO,12.	;
	DIR$			; MAKE REQUEST TO LOAD OVERLAY SEGMENT
	BCS	30$		; IF C/S LEAVE NOW
	TSTB	R3		;SYNCHRONOUS REQUEST?
	BNE	50$		;IF NE NO
	WTSE$S	#O$VEF		; WAIT FOR LOAD TO COMPLETE
	TSTB	(R4)		;TEST FINAL STATUS
	BPL	50$		;IF PL OKAY
30$:				; REFERENCE LABEL

	.IFT

	BIC	#TR$LOD,(R2)	; SET SEGMENT NOT LOADED

	.IFTF			; IF PLAS ON NON-PLAS SUPPORT

40$:				;
	BIS	#TR$MEM,(R2)	; MARK SEGMENT OUT OF MEMORY
	SEC			;SET CARRY
50$:				;
	RETURN			;

	.PAGE
;+
; **-PDLSV SERVICE PUSHDOWN LIBRARY MAPPING CALLS
;
; THIS ROUTINE IS PLACED HERE AS AN EXTENSION OF $AUTO EXECUTED WHEN
; A PUSHDOWN LIBRARY MAP IS DETECTED. THE CODE IS NOT IN AUTO IN ORDER
; TO SAVE MEMORY WHEN $AUTO IS USED FOR NON-PLAS MAPPED TASKS.
;-

	.PSECT	$$PDLS	I,RO,LCL,REL,OVR

PDLSV:
	.IF DF C$$STR		; IF CLUSTERS ARE SUPPORTED
;
; A PUSH-DOWN MAP HAS BEEN DETECTED. WE MUST EXPAND THE STACK TO
; PROVIDE STORAGE FOR THE DISPLACED SEGMENT ADDRESS.
;
	MOV	SP,R3		; POINT TO RETURN ADDRESS OF REGISTER RESTORE
	CMP	-(SP),-(SP)	; PROVIDE SPACE
	MOV	SP,R4		; SET DESTINATION POINTER

	MOV	(R3)+,(R4)+	; SHUFFLE THE STACK (REGISTER RESTORE ADDRESS)
	MOV	(R3)+,(R4)+	; SHUFFLE THE STACK (SAVED R1)
	MOV	(R3)+,(R4)+	; SHUFFLE THE STACK (SAVED R2)
	MOV	(R3)+,(R4)+	; SHUFFLE THE STACK (SAVED R3)
	MOV	(R3)+,(R4)+	; SHUFFLE THE STACK (SAVED R4)
	MOV	(R3)+,(R4)+	; SHUFFLE THE STACK (SAVED R5)

	MOV	#80$-75$,(R4)	; SET IN THE ADDRESS OF A COROUTINE CALL
	ADD	PC,(R4)+	; COMPUTE REAL ADDRESS IN A PIC FASHON
75$:
	MOV	(R3)+,(R4)+	; COPY THE TARGET ROUTINE ADDRESS
	MOV	R2,(R4)		; AND SAVE THE DISPLACED SEGMENT ADDRESS

	CALLR	ASTEN		; REEANBLE ASTS IF DISABLED
				; AND RETURN TO REGISTER RESTORE AND THENCE
				; TO THE TARGET VIA "80$" BELOW

;
; CALL THE TARGET AS A CO-ROUTINE.
;
80$:
	CALL	@(SP)+		; CALL THE TARGET
;
; (SP) = ADDRESS OF THE SEGMENT DISPLACED IN ORDER TO MAP THE TARGET
; 	SEGMENT
; 2(SP) = USER RETURN ADDRESS IN THE SOURCE SEGMENT
;
	ROR	2(SP)		; SAVE THE CARRY BIT IN THE USERS RETURN
				; ADDRESS
	CALL	ASTDS		; DISABLE AST RECOGNITION
	JSR	R5,.SAVR1	; SAVE R1,R2,R3,R4,R5
	MOV	@#N.OVPT,R1	; PICK UP ADDRESS OF IMPURE DATA AREA
;
; (SP) = RETURN ADDRESS TO RESTORE REGISTERS
; 2,4,6,10,12(SP) = SAVED R1,R2,R3,R4,R5
; 14(SP) = ADDRESS OF DISPLACED SEGMENT
; 16(SP) = USERS RETURN ADDRESS WITH SAVED CARRY
;
	MOV	14(SP),R2	; GET SEGMENT ADDRESS

	MOV	PC,R3		; COMPUTE ADDRESS IN A PIC FASHON
85$:
	ADD	#90$-85$,R3	; SET ADDRESS OF ROUTINE TO RESTORE CARRY
	MOV	R3,14(SP)	;

	CALL	@N.MRKS(R1)	; MARK APPROPRIATE SEGMENTS OUT OF MEMORY
	CLR	N.DTDS(R1)	; RESET ANY INDICATION WE DISPLACED A SEGMENT
	JMP	$ALBPL		; AND GO PERFORM PATH LOAD IN $AUTO
;
; AFTER THE APPROPRIATE SEGMENTS HAVE BEEN LOADED, A DIRECT RETURN WILL BE
; TAKEN SINCE THERE IS NO "DISPLACED SEGMENT". THIS TAKES US TO THIS POINT
; WHERE THE CARRY IS RESTORED AND A REAL RETURN TO THE ORIGINAL CALLING SEGMENT
; IS MADE.
;
90$:
	ASL	(SP)		; RESTORE THE CARRY
	RETURN			; FINALLY RETURN TO THE CALLER

	.IFF			; IF CLUSTERS ARE NOT SUPPORTED

	.IF DF P$$LAS		; AND PLAS IS SUPPORTED

	MOV	#IE.OVR&377,@#$DSW ; 'FAKE' AN "ILLEGAL OVERLAY" ERROR
	JMP	ALERR		; AND GO TO AUTOLOAD ERROR SERVICE

	.IFF			; IF PLAS IS NOT SUPPORTED

	RETURN			; AND RETURN TO REGISTER RESTORE AND THENCE
				; TO THE TARGET.

	.ENDC			; IF PLAS SUPPORTED OR NOT

	.IFT			; IF CLUSTERS ARE SUPPORTED

	.DSABL	LSB
;
; DEFINE OVERMAPPED PSECT FOR ACCESS TO THE AST ENABLE/DISABLE AND
; ERROR SERVICE ROUTINES.
;
	.PSECT	$$RTQ	I,RO,GBL,REL,OVR
ASTEN:				; ADDRESS OF AST ENABLE ROUTINE
	.PSECT	$$RTR	I,RO,GBL,REL,OVR
ASTDS:				; ADDRESS OF AST DISABLE ROUTINE
	.PSECT	$$RTS	I,RO,GBL,REL,OVR
				; PUT RETURN SEGMENT HERE TO PRESERVE ORDER

	.ENDC			; IF CLUSTERS OR NOT

	.PSECT	$$ALER	I,RO,LCL,REL,CON
ALERR:				; ENTRY POINT TO AUTOLOAD ERROR SERVICE

	.ENDC			; PLAS OR NON-PLAS

	.END
