	.TITLE	LOAD
	.IDENT	/10.02/

;
;		COPYRIGHT (c) 1983 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD
;	 MASSACHUSETTS.  ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE  IS  FURNISHED  UNDER  A LICENSE AND MAY BE USED
; AND  COPIED  ONLY IN  ACCORDANCE WITH THE TERMS OF SUCH LICENSE
; AND WITH  THE INCLUSION  OF THE ABOVE  COPYRIGHT  NOTICE.  THIS
; SOFTWARE  OR ANY OTHER  COPIES  THEREOF, MAY NOT BE PROVIDED OR
; OTHERWISE MADE  AVAILABLE TO ANY OTHER PERSON.  NO TITLE TO AND
; OWNERSHIP OF THE SOFTWARE IS HEREBY TRANSFERED.
;
; THE INFORMATION  IN THIS DOCUMENT IS SUBJECT  TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT  BY  DIGITAL
; EQUIPMENT CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF
; ITS SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.
;
; MODIFIED FOR RSX-11M/M-PLUS V4.0/V2.0 BY
;
;	J. E. POLLACK
;
; MODIFIED BY:
;
;	J. M. SALMAN	25-AUG-82	10.01
;		JMS060 -- MOVE FUNCTIONALITY IN AUTOX AND AUTOY TO
;			  LOAD AND DEFINE $AUTO SO THAT	 REFERENCE
;			  IN OVDAT IS RESOLVED.  REMOVE DEFINITION
;			  $AUEPT.
;
;	J. M. SALMAN	27-SEP-82	10.02
;		JMS070 -- SUPPORT MANUAL LOAD IN I- AND D-SPACE TASKS.
;
; MANUAL SEGMENT LOADING
;
; EQUATED SYMBOLS
;
; DEFINE REGION DESCRIPTOR FLAGS AND OFFSETS
;

	RGDF	,,S

;
; DEFINE WINDOW BLOCK FLAGS AND OFFSETS
;

	WDBDF	,,S

;+
; **-$LOAD-LOAD SEGMENT
;
; THIS ROUTINE IS CALLED TO MANUALLY LOAD A NAMED SEGMENT INTO MEMORY.
; IT IS ONE OF THE RUN TIME OVERLAY ROUTINES AND IS CALLED DIRECTLY BY
; THE USER. THE SEGMENT TABLES ARE SEARCHED FOR THE SPECIFIED SEGMENT
; NAME. IF THE NAME IS NOT FOUND A CARRY SET CONDITION IS RETURNED TO
; THE CALLER. ELSE $MARKS IS CALLED TO MARK THE APPROPRIATE SEGMENTS
; OUT OF MEMORY AND $RDSEG IS CALLED TO LOAD THE SEGMENT. BOTH SYN-
; CHRONOUS AND ASYNCHRONOUS REQUESTS ARE SUPPORTED.
;
; INPUTS:
;
;	R0=ADDRESS OF ARGUMENT PARAMETER BLOCK.
;
;	PARAMETER BLOCK FORMAT:
;
;	.BYTE	LENGTH,EVENT FLAG
;	.RAD50	/SEGNAME/
;	.WORD	I/O STATUS
;	.WORD	AST TRAP ADDRESS
;
;	WHERE:
;
;	LENGTH=LENGTH OF THE PARAMETER BLOCK IN WORDS. THE LENGTH MAY BE
;		ANY NUMBER GREATER THAN 3 BUT ONLY THE FIRST FIVE WORDS
;		OF THE PARAMTER BLOCK ARE CONSIDERED.
;	EVENT FLAG=EVENT FLAG NUMBER TO BE USED FOR AN ASYNCHRONOUS LOAD
;		REQUEST. IF NO EVENT FLAG IS SPECIFIED (I.E. ZERO), THEN
;		THE LOAD REQUEST IS CONSIDIERED TO BE SYNCHRONOUS.
;	SEGNAME=RAD50 NAME OF THE SEGMENT TO BE LOADED.
;	I/O STATUS=ADDRESS OF I/O STATUS DOUBLEWORD. STANDARD Q I/O
;		STATUS CODES APPLY.
;	AST TRAP ADDRESS=ADDRESS OF AST TRAP ROUTINE TO TRAP TO AT THE
;		COMPLETION OF THE LOAD REQUEST. NOTE THAT AN AST TRAP
;		CAN OCCUR ON SYNCHRONOUS LOAD REQUESTS.
;
;	I/O STATUS AND AST TRAP ADDRESS ARE OPTIONAL PARAMETERS AND NEED
;	BE SPECIFIED.
;
; OUTPUTS:
;
;	C=1 IF ILLEGAL PARAMETERS ARE SUPPLIED OR THE LOAD REQUEST IS
;		UNSUCESSFUL.
;	C=0 IF THE REQUEST IS SUCESSFULLY EXECUTED. FOR SYNCHRONOUS RE-
;		QUESTS THIS MEANS THAT THE DESIRED SEGMENT HAS BEEN
;		LOADED AND IS IN MEMORY. FOR ASYNCHRONOUS REQUESTS THIS
;		MEANS THAT THE LOAD REQUEST HAS BEEN SUCESSFULLY EXECU-
;		TED BUT THE SEGMENT IS NOT NECESSARILY IN MEMORY. THE
;		CALLER MUST INSURE THAT LOADING IS COMPLETE BEFORE CALL-
;		ING ANY ROUTINES OR ACCESSING ANY DATA IN THE LOADED
;		SEGMENT.
;	ALL REGISTERS ARE PRESERVED.
;-

	.PSECT	$$LOAD	I,RO,LCL,REL,CON

$LOAD::				;
	CMPB	(R0),#3		; ENOUGH PARAMETERS?
	BLO	60$		; IF LO NO

	JSR	R5,.SAVR1	; SAVE R1,R2,R3,R4,R5
	MOV	@#N.OVPT,R1	; GET THE IMPURE AREA POINTER
	MOVB	N.SZSG(R1),R4	; GET DESCRIPTOR LENGTH
	MOV	N.STBL(R1),R2	; GET SEGMENT DESCRIPTOR TABLE ADDRESS
10$:				;
	TST	(R2)		; END OF SEGMENT DESCRIPTOR LIST?
	SEC			; ASSUME SEGMENT NOT FOUND
	BEQ	50$		; IF EQ NOT FOUND
	CMP	T$RNME(R2),2(R0) ; CHECK SEGMENT NAME
	BNE	20$		; IF NE NOT DESIRED SEGMENT
	CMP	T$RNME+2(R2),4(R0) ; CHECK SECOND HALF OF NAME
	BEQ	30$		; IF EQ HAVE REQUESTED SEGMENT
20$:				;
	BIT	#TR$DSP,T$RLDA(R2) ; SEGMENT HAS D-SPACE EXTENSION?
	BEQ	25$		; IF EQ NO
	ADD	#S$ZIDX,R2	; ADJUST FOR SEGMENT DESCRIPTOR EXTENSION
25$:
	ADD	R4,R2		; POINT TO NEXT DESCRIPTOR
	BR	10$		; GO AGAIN
30$:				;
	CMPB	R4,#S$ZSEG+2	; DOES THE TASK HAVE RESIDENT OVERLAYS?
	BLO	35$		; BR IF NOT

	MOV	T$RWDP(R2),R4	; GET WINDOW POINTER
	BEQ	35$		; BR IF THIS IS NOT A RESIDENT OVERLAY

	BIC	#WF$MAP,W$NFLG(R4) ; MARK WINDOW AS NOT-MAPPED
	BIT	#TR$DSP,T$RLDA(R2) ; SEGMENT HAS D-SPACE EXTENSION?
	BEQ	45$		; IF EQ NO
	MOV	T$DWDP(R2),R4	; GET D-SPACE WINDOW POINTER
	BEQ	35$		; IF EQ NONE
	BIC	#WF$MAP,W$NFLG(R4) ; MARK WINDOW AS NOT-MAPPED
	BR	45$		; AND CONTINUE TO MAP
35$:
	BIC	#TR$LOD,(R2)	; FORCE SEGMENT LOAD IF FROM DISK
45$:				;
	MOV	N.RDSG(R1),-(SP) ; PUSH ADDRESS OF READ SEGMENT ROUTINE

	CLR	-(SP)		; ASSUME NO I/O STATUS
	CMPB	(R0),#4		; TEST FOR I/O STATUS OR AST
	BLO	40$		; IF LO NONE REQUESTED
	MOV	6(R0),(SP)	; SET ADDRESS OF I/O STATUS
40$:
	CLR	-(SP)		; ASSUME NO AST
	CMPB	(R0),#5		; CHECK FOR AST
	BLO	41$		; IF LO NO AST SPECIFIED
	MOV	10(R0),(SP)	; SET AST ADDRESS
41$:				;
	CLR	N.DTDS(R1)	; MAKE SURE 'CLUSTER' FLAG IS RESET
	CALL	@N.MRKS(R1)	; MARK APPROPRIATE SEGMENTS OUT OF MEMORY
	TST	N.DTDS(R1)	; WAS A CLUSTER LIBRARY FOUND?
	BNE	ALEROR		; TAKE AN ERROR EXIT

	CLR	R3		; SET FOR MOVB WITH NO EXTEND
	BISB	1(R0),R3	; GET EFN
	MOV	(SP)+,R5	; SET AST ADDRESS IF ANY
	MOV	(SP)+,R4	; SET IOSB ADDRESS IF ANY
	CALL	@(SP)+		; READ SEGMENT INTO MEMORY
50$:				;
60$:				;
	RETURN			;

;
; IF THE MARKS PHASE OF $LOAD ABOVE DETECTS THAT
; THE USER HAS LINKED AGAINST A CLUSTER LIBRARY,
; WE WILL GIVE AN ALERR ERROR
;
ALEROR:
	MOV	#IE.OVR&377,@#$DSW ; 'FAKE' AN "ILLEGAL OVERLAY" ERROR
	JMP	ALERR		; AND TAKE ERROR SERVICE

	.PSECT	$$ALER	I,RO,LCL,REL,CON
ALERR:				; ENTRY POINT TO AUTOLOAD ERROR SERVICE

;
; DEFINE $AUTO IN ORDER TO RESOLVE THE REFERENCE FROM THE OVERLAY
; RUN-TIME IMPURE AREA POINTER .NAUTO.
;

	.PSECT	$$AUTO	I,RO,LCL,REL,CON
$AUTO::
	RETURN			; DO NOTHING

;
; DEFINE $ALBPL.
; IF LOAD IS LINKED WITH OVCTC, THE $ALBPL IS DEFINED AND IF IT IS
; USED AS A TRANSFER POINT BY OVCTC THEN WE WILL GIVE AN ALERR ERROR.
;

$ALBPL::
	MOV	#IE.OVR&377,@#$DSW ; 'FAKE' AN "ILLEGAL OVERLAY" ERROR
	JMP	ALERR		; AND TAKE ERROR SERVICE

	.END
