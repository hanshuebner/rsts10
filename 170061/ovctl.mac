	.TITLE	OVCTL	OVERLAY CONTROL ROUTINES
	.IDENT	/15.06/
;
;		COPYRIGHT (c) 1989 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD
;	 MASSACHUSETTS.  ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE  IS  FURNISHED  UNDER  A LICENSE AND MAY BE USED
; AND  COPIED  ONLY IN  ACCORDANCE WITH THE TERMS OF SUCH LICENSE
; AND WITH  THE INCLUSION  OF THE ABOVE  COPYRIGHT  NOTICE.  THIS
; SOFTWARE  OR ANY OTHER  COPIES  THEREOF, MAY NOT BE PROVIDED OR
; OTHERWISE MADE  AVAILABLE TO ANY OTHER PERSON.  NO TITLE TO AND
; OWNERSHIP OF THE SOFTWARE IS HEREBY TRANSFERED.
;
; THE INFORMATION  IN THIS DOCUMENT IS SUBJECT  TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT  BY  DIGITAL
; EQUIPMENT CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF
; ITS SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.
;
;
; MODIFIED FOR RSX-11M/M-PLUS V4.0/V2.0 BY:
;
;	J. A. KASSON
;	J. E. POLLACK
;	J. M. LAWLER
;
; MODIFIED BY:
;
;	J. M. SALMAN	09-JUL-82	15.01
;		JMS052		DURING MARKSEG, DON'T ELIMINATE A WINDOW IF
;				IT IS THE SAME AS THE TARGET SEGMENT'S
;				WINDOW.
;
;	J. M. SALMAN	14-JUL-82	15.02
;		JMS055		MOVE ZERO LENGTH SEGMENT CHECKING FROM AUTO
;				TO RDSEG.
;
;	J. M. SALMAN	08-AUG-82	15.03
;		JMS059		DURING MARKSEG, PROCEED UPTREE IF CURRENT
;				SEGMENT'S WINDOW IS NOT MAPPED.
;
;	J. M. SALMAN	12-SEP-82	15.04
;		JMS069		IF TARGET SEGMENT IS DISK-RESIDENT, MAKE SURE
;				SEGMENTS ON A DIFFERENT PATH BUT SHARING THE 
;				SAME WINDOW ARE MARKED "NOT LOADED FROM DISK",
;				IN ADDITION TO BEING MARKED "NOT IN MEMORY".
;
;
; MODIFIED FOR RSX-11M-PLUS AND MICRO/RSX V4.0 BY:
;
;	L. M. PETERSON	15-DEC-86	15.05	SPR#233P
;		LMP074		USE R.GSTS SET BY TKB TO ATTACH REGION FOR
;				CLUSTER LIBRARY (INSTEAD OF ALWAYS ATTACHING
;				READ ONLY)
;
;	L. M. PETERSON	2-DEC-87	15.06
;		LMP041		GET RID OF UNNECESSARY ELAW$ (CRAW$ WILL DO IT)
;
; MODIFIED FOR RSX-11M-PLUS AND MICRO/RSX V4.3 BY:
;
;	L. M. PETERSON	19-0CT-89	15.06
;		LMP143		ADD CHRIS PETROVIC'S CODE FOR DEBUGGING OVERLAID
;				TASKS (IN-HOUSE)
;
;------------------------------------------------------------------------
	.IF DF P$$LAS		; IF THIS ASSEMBLY SUPPORTS PLAS
	.IF DF C$$STR		; IF THIS ASSEMBLY SUPPORTS CLUSTERS
	.TITLE OVCTC OVERLAY (DISK,PLAS,CLUS)
	.LIST CND		; LIST ALL CONDITIONALS
	.IFF			; IF NO CLUSTER SUPPORT
	.TITLE OVCTR OVERLAY (DISK,PLAS,-CLUS)
	.NLIST CND		; DON'T LIST CONDITIONALLY EXCLUDED CODE
	.ENDC
	.IFF			; IF NO PLAS SUPPORT REQUIRED
	.TITLE OVCTL OVERLAY (DISK,-PLAS,-CLUS)
	.NLIST CND		; DON'T LIST CONDITIONALLY EXCLUDED CODE
	.ENDC
;------------------------------------------------------------------------


;
; OVERLAY RUN TIME ROUTINES
;
; EQUATED SYMBOLS
;

O$VEF=31.			; SYSTEM OVERLAY EVENT FLAG
Q$IO=1				; QUEUE I/O DIRECTIVE CODE
W$FR=41.			; WAIT FOR EVENT FLAG DIRECTIVE CODE

;
; MACRO LIBRARY CALLS
;

	.MCALL	ATRG$S,CRAW$S,DIR$,QIOSY$,WTSE$S
	RGDF	,,S
	WDBDF	,,S
	QIOSY$

;+
; **-$MARKS-MARK SEGMENT
;
; THIS ROUTINE IS CALLED TO MARK ALL SEGMENTS OUT OF MEMORY THAT ARE
; NOT ON THE SAME PATH AS THE ARGUMENT SEGMENT. IT IS ONE OF THE OVER-
; LAY RUN TIME ROUTINES AND IS CALLED BY BOTH THE $LOAD (MANUAL LOAD-
; ING) AND $AUTO (AUTOMATIC LOADING) ROUTINES.
;
; INPUTS:
;
;	R1=ADDRESS OF RUNTIME IMPURE DATA AREA
;	R2=ADDRESS OF ARGUMENT SEGMENT DESCRIPTOR.
;
; OUTPUTS:
;
;	THE APPROPRIATE SEGMENTS ARE MARKED OUT OF MEMORY AND ALL REG-
;	ISTERS ARE PRESERVED.
;-


	.PSECT	$$MRKS	I,RO,LCL,REL,OVR

;
; NOTE IN THE FOLLOWING GLOBAL SYMBOL DEFINITIONS THAT THESE
; DEFINITIONS HOLD:
;		MODULE:		DEFINITIONS:
;		 OVCTL		 $MARKS
;		 OVCTR		 $MARKS,$MARKR
;		 OVCTC		 $MARKS,$MARKR,$MARKC
;
; THIS PERMITS CORRECT LINKING OF A USER TASK WHEN LINKED AGAINST
; A SHARABLE LIBRARY CONTAINING MORE SUPPORT THAN IS IMMEDIATELY REQUIRED
; BY THAT SPECIFIC TASK.
;
	.IF DF P$$LAS		; IF PLAS IS SUPPORTED
	.IF DF C$$STR		; IF CLUSTER LIBRARIES ARE SUPORTED
$MARKC::			; DEFINE LABEL TO DRAW THIS MODULE FROM
				; SYSLIB IF THE TASKBUILDER DETECTS
				; REFERENCE TO MEMORY RESIDENT OVERLAYS
				; WITH AT LEAST ONE CLUSTER LIBRARY REFERENCE
				; OR DISK RESIDENT OVERLAYS.

	.IFTF			; IF CLUSTER LIBRARIES ARE OR ARE NOT
				; SUPPORTED AND PLAS IS SUPPORTED
$MARKR::			; DEFINE LABEL TO DRAW THIS MODULE FROM
				; SYSLIB IF THE TASKBUILDER DETECTS
				; REFERENCE TO MEMORY RESIDENT OVERLAYS
				; (WITH NO CLUSTER LIBRARY REFERENCES)
				; OR DISK RESIDENT OVERLAYS.

	.ENDC			; IF CLUSTERS OR NOT-CLUSTERS
	.IFTF			; IF PLAS IS SUPPORTED OR NOT
$MARKS::			; DEFINE LABEL TO DRAW THIS MODULE FROM
				; SYSLIB IF THE TASKBUILDER DETECTS
				; ONLY DISK RESIDENT OVERLAYS. NOTE
				; THAT WHEN "OVCTR" OR "OVCTS" IS
				; INSERTED IN SYSLIB, THIS GLOBAL IS
				; DELETED TO AVOID CONFLICT WITH $MARKS
				; AS DEFINED IN "OVCTL".

	.IFT			; IF PLAS IS SUPPORTED.

	MOV	T$RWDP(R2),R4	; GET ADDRESS OF WINDOW BLOCK

	.IF DF C$$STR		; IF THIS ASSEMBLY SUPPORTS CLUSTERS

	CLR	N.DTDS(R1)	; RESET THE "SEGMENT DISPLACED" ADDRESS

	.ENDC			; IF CLUSTERS OR NOT

	.IFTF			; IF RESIDENT OVERLAYS SUPPORTED OR NOT

	MOV	R2,-(SP)	; SAVE ARGUMENT SEGMENT ADDRESS
;
; WORK DOWN-TREE UNTIL AN IN-MEMORY SEGMENT IS FOUND
;
10$:	BIT	#TR$MEM,(R2)	; SEGMENT IN MEMORY?
	BNE	20$		;IF NE NO
15$:	MOV	T$RDWN(R2),R2	;GET DOWN LINK OF SEGMENT
	BNE	10$		;IF NE GO AGAIN
17$:				;
	MOV	(SP)+,R2	;RESTORE ARGUMENT SEGMENT
	RETURN			;
;
; QUIT WHEN THE ROOT IS FOUND, ALL SEGMENTS ARE NOW MARKED AS
; OUT OF MEMORY
;
20$:				;
	TST	T$RDWN(R2)	; IS THIS A ROOT SEGMENT
	BEQ	17$		; IF EQ YES
	MOV	R2,-(SP)	; SAVE SEGMENT DESCRIPTOR ADDRESS
30$:	MOV	R2,-(SP)	;STACK SEGMENT DESCRIPTOR ADDRESS
;
; WORK HORIZONTALLY AT THIS LEVEL LOOKING FOR AN UP-PATH, IN-MEMORY
; SEGMENT
;
40$:	MOV	T$RNXT(R2),R2	;GET NEXT LINK OF SEGMENT
	CMP	R2,(SP)		;SAME AS TOS SEGMENT?
	BEQ	60$		;IF EQ YES
;
; IF FOUND, MARK IT OUT OF MEMORY
;
50$:				;
	BIT	#TR$MEM,(R2)	; SEGMENT IN MEMORY?
	.IFF
	BNE	40$		; IF NE NO
	.IFT
	BNE	70$		; IF NE NO
	.IFTF
	BIS	#TR$MEM,(R2)	; MARK SEGMENT OUT OF MEMORY

	.IFT

	CMPB	N.SZSG(R1),#S$ZSEG+2 ; TASK HAVE MEMORY RESIDENT OVERLAYS?
	BLO	52$		; IF LO NO
;
; UNMAP A WINDOW IF IT WILL BE USED FOR MAPPING THE TARGET
;
	TST	R4		; IS A WINDOW BLOCK PRESENT FOR THE TARGET SEGME
	BEQ	52$		; BR IF NOT. NO CHANCE OF PDL
	TST	T$RLNG(R2)	; IS THIS A ROOT?
	BEQ	57$		; IF NOT, JUST SKIP WINDOW ELIMINATION.
	MOV	T$RWDP(R2),R3	; GET WINDOW BLOCK FOR THIS SEGMENT
	BEQ	52$		; NO WINDOW HERE EITHER.

	.IF DF C$$STR		; IF CLUSTERS ARE SUPPORTED

	CMP	W$NREG(R3),W$NREG(R4) ; IS THE DISPLACED SEGMENT IN A
				; DIFFERENT REGION?
	BEQ	51$		; IF IN THE SAME REGION, NO PD LIBRARY

	MOV	R2,N.DTDS(R1)	; THE CURRENT SEGMENT IS BEING DISPLACED BY A
				; SEGMENT WHICH USES A DIFFERENT WINDOW. SAVE
				; ITS ADDRESS. THE LAST ONE SO SAVED WILL BE THE
				; HIGHEST SEGMENT DISPLACED AND A CANDIDATE FOR
				; THE RECOVERY PATH LOAD UPON RETURN FROM THE
				; TARGET
	.ENDC			; IF CLUSTERS OR NOT
51$:
		.IIF NE WF$MAP-100000 .ERROR ; ASSUMPTION ERROR

	CMP	R3,R4		; SAME WINDOW AS TARGET?
	BEQ	52$		; IF EQ YES
	TST	W$NFLG(R3) 	; WINDOW MAPPED?
	BPL	57$		; IF PL NO
	BIC	#WF$MAP,W$NFLG(R3) ; FLAG WINDOW AS NOT MAPPED
	BR	57$		;
52$:				;
	BIT	#TR$LOD,(R2)	; SEGMENT LOADED?
	BEQ	40$		; IF EQ NO
	BIC	#TR$LOD,(R2)	; CLEAR SEGMENT LOADED FLAG
57$:				;

	.ENDC

;
; WE FOUND AN UP-LINK, IN-MEMORY SEGMENT, PROCEED UPWARD UNTIL WE GET
; TO THE TOP OF THE IN-MEMORY BRANCH
;
	MOV	T$RUP(R2),(SP)	;REPLACE TOS WITH UP LINK OF SEGMENT
	BEQ	60$		;IF EQ NO LINK UP
	MOV	(SP),R2		;GET ADDRESS OF UP LINK
	BR	50$		;
60$:	TST	(SP)+		;CLEAN STACK
	MOV	(SP)+,R2	;RETRIEVE SEGMENT ADDRESS
	BR	15$		;
	.IF DF P$$LAS

;
; WE FOUND A SEGMENT OUT OF MEMORY BUT, IN THE CASE WHERE THE TARGET
; AND THE CURRENT SEGMENT ARE DISK-RESIDENT OVERLAYS ON TOP OF A COMMON
; MEMORY RESIDENT OVERLAY, WE WANT TO MAKE SURE THAT TR$LOD IS CLEARED.
;

70$:
	CMPB	N.SZSG(R1),#S$ZSEG+2 ; TASK HAVE MEMORY RESIDENT OVERLAYS?
	BLO	40$		; IF LO NO
	BIT	#TR$LOD,(R2)	; SEGMENT LOADED FROM DISK?
	BEQ	40$		; IF EQ NO
	TST	R4		; DOES TARGET HAVE A WINDOW DESCRIPTOR?
	BEQ	40$		; IF EQ NO
	CMP	T$RWDP(R2),R4	; DOES CURRENT HAVE SAME WINDOW AS TARGET?
	BNE	40$		; IF NE NO
	BIC	#TR$LOD,(R2)	; CLEAR "SEGMENT LOADED" FLAG
	BR	57$		; LOOK UP-TREE FOR MORE LOADED SEGMENTS

	.ENDC

;+
; **-$RDSEG-READ OVERLAY SEGMENT
;
; THIS ROUTINE IS CALLED TO LOAD AN OVERLAY SEGMENT INTO MEMORY. IT
; IS ONE OF THE OVERLAY RUN TIME ROUTINES AND IS CALLED FROM BOTH THE
; $LOAD (MANUAL LOADING) AND $AUTO (AUTOMATIC LOADING) ROUTINES.
;
; INPUTS:
;
;	R1=ADDRESS OF RUNTIME IMPURE DATA AREA
;	R2=ADDRESS OF SEGMENT DESCRIPTOR OF SEGMENT TO BE LOADED.
;	R3=EVENT FLAG NUMBER.
;		IF R3 EQ 0, THEN A SYNCHRONOUS LOAD IS SPECIFIED. THE
;			EVENT FLAG THAT IS USED TO SYNCHRONIZE THE
;			LOADING IS THE STANDARD OVERLAY EVENT FLAG.
;		IF R3 NE 0, THEN AN ASYNCHRONOUS LOAD REQUEST IS SPEC-
;			IFIED. THE SPECIFIED EVENT FLAG IS USED IN THE
;			LOAD REQUEST THUS PROVIDING SYNCHRONIZATION
;			FOR THE CALLER.
;	R4=ADDRESS OF I/O STATUS DOUBLEWORD. IF NO STATUS DOUBLEWORD IS
;		SPECIFIED NO I/O STATUS IS RETURNED TO THE CALLER.
;	R5=AST TRAP ADDRESS. IF NO TRAP ADDRESS IS SPECIFIED NO TRAP OC-
;		CURS.
;
; OUTPUTS:
;
;	C=1 IF I/O ERROR ON EITHER THE INITIAL REQUEST DIRECTIVE OR AT
;		THE COMPLETION OF A SYNCHRONOUS LOAD REQUEST.
;	C=0 IF REQUEST IS SUCESSFULLY COMPLETED. SEGMENT IS MARKED IN
;		MEMORY.
; 	R3,R4,R5 ARE  DESTROYED
;-


	.PSECT	$$RDSG	I,RO,LCL,REL,OVR

$RDSEG::
	BIC	#TR$MEM,(R2)	; MARK SEGMENT IN MEMORY
	TST	T$RLNG(R2)	; ZERO LENGTH SEGMENT?
	BNE	1$		; IF NE NO
	BIS	#TR$LOD,(R2)	; MARK SEGMENT LOADED
	RETURN			; AND RETURN
1$:

	.IF DF	P$$LAS		;

	MOV	R3,-(SP)	; SAVE SOME REGISTERS
	MOV	R4,-(SP)	;

	CMPB	N.SZSG(R1),#S$ZSEG+2 ; TASK HAVE RESIDENT OVERLAYS?
	BLO	7$		; IF LO NO
	MOV	T$RWDP(R2),R3	; GET WINDOW BLOCK ADDRESS
	BEQ	7$		; IF EQ NONE
		.IIF NE WF$MAP-100000 .ERROR ; ASSUMPTION ERROR

	TST	W$NFLG(R3)	; WINDOW MAPPED?
	BMI	7$		; IF MINUS, YES
	MOV	W$NREG(R3),R4	; GET POINTER TO REGION
	BEQ	6$		; IF EQ NONE
		.IIF NE RF$ATT-100000 .ERROR ; ASSUMPTION ERROR

	TST	R$GFLG(R4)	; REGION ATTACHED?
	BMI	4$		; IF MINUS, YES.

	.IF DF	C$$STR
	MOV	R.GSTS(R4),-(SP) ; SAVE R.GSTS SET BY TKB
	.ENDC

	CLR	R.GSTS(R4) 	; GET REGION ID IF ALREADY ATTACHED
				; WITHOUT CREATING AN ADB
	ATRG$S	R4		; ATTACH REGION
	
	.IF DF	C$$STR
	MOV	(SP)+,R.GSTS(R4) ; RESTORE  R.GSTS
	.ENDC

	.IF DF 	P$$LAS		; IF PLAS SUPPORT

	.IF NDF	C$$STR		; IF NO CLUSTER LIBRARY SUPPORT

	BCS	71$		; BR IF ATTACH FAILURE

	.IFF	; NDF C$$STR

	BCC	3$		; ALREADY ATTACHED
	ATRG$S	R4		; ATTACH REGION
	BCS	71$		; IF CS, THEN ATTACH FAILED
3$:				; LABEL REFERENCE

	.ENDC	; NDF C$$STR

	.ENDC	; DF P$$LAS

	BIS	#RF$ATT,R$GFLG(R4) ; SET ATTACHED FLAG
4$:				;
	MOV	R.GID(R4),W.NRID(R3) ; SET REGION I/D
6$:				;
	CRAW$S	R3		; MAP ADDRESS WINDOW
	BCC	650$		; IF CC MAPPING SUCCESSFUL
	BIC	#WS.WRT,W.NSTS(R3) ;CHANGE MAPPING STATUS TO R/O
	CRAW$S	R3		; TRY MAPPING AGAIN
	BCS	71$		; BR IF MAP FAILURE
650$:
	BIS	#WF$MAP,W$NFLG(R3) ; SET STATUS=MAPPED
7$:				;

	.IFTF

	CLC			; CLEAR CARRY
71$:

	.IFT

	MOV	(SP)+,R4	; RESTORE REGISTERS
	MOV	(SP)+,R3	;

	.IFTF			; IF PLAS OR NOT

	BCS	40$		; BR IF DIRECTIVE ERROR ABOVE

	.IFT			; IF PLAS

	BIT	#<TR$DSK!TR$LOD>,(R2) ; SEGMENT TO BE LOADED?
	BNE	50$		; IF NE NO
	BIS	#TR$LOD,(R2)	; MARK SEGMENT AS LOADED

	.IFF

	BIT	#TR$DSK,(R2)	; SEGMENT HAVE DISK SPACE?
	BNE	50$		; IF NE NO DISK

	.IFTF

;
; BUILD A QIO DPB ON THE STACK TO LOAD THE DISK OVERLAY OR THE MEMORY
; RESIDENT OVERLAY IF IT HAS NOT YET BEEN LOADED
;
	CLR	-(SP)		; CLEAR PARAM. WORD 6
	MOV	(R2),-(SP)	; SET RELATIVE BLOCK NUMBER
	BIC	#170000,(SP)	; CLEAR STATUS FIELD
	CLR	-(SP)		;SECOND HALF OF RELATIVE BLOCK IS ZERO
	CLR	-(SP)		;ZERO STACK WORD
	MOV	T$RLNG(R2),-(SP);SET LENGTH OF OVERLAY SEGMENT
	MOV	T$RLDA(R2),-(SP);SET VIRTUAL LOAD ADDRESS
	MOV	R5,-(SP)	;SET AST TRAP ADDRESS
	MOV	R4,-(SP)	;SET I/O STATUS DOUBLE WORD ADDRESS
	BNE	10$		;IF NE ONE SPECIFIED
	TSTB	R3		;SYNCHRONOUS REQUEST?
	BNE	10$		;IF NE NO
	MOV	R1,R4		; CALCULATE ADDRESS OF COMMON I/O STATUS
	ADD	#N.IOST,R4	;
	MOV	R4,(SP)		;
10$:				;
	MOV	R3,-(SP)	; SET EVENT FLAG NUMBER
	BNE	15$		;IF NE ASYNCHRONOUS REQUEST
	MOV	#O$VEF,(SP)	;SET SYSTEM EVENT FLAG
15$:				;
				; >>>>>>>> ASSUME THAT N.OVLY = 0 <<<<<<<<
	MOV	(R1),-(SP)	; SET LOGICAL UNIT NUMBER FOR OVERLAYS
	MOV	#IO.LOV,-(SP)	;SET FUNCTION CODE
	MOV	(PC)+,-(SP)	;SET DIRECTIVE CODE AND LENGTH
	.BYTE	Q$IO,12.	;
	DIR$			; MAKE REQUEST TO LOAD OVERLAY SEGMENT
	BCS	30$		; IF C/S LEAVE NOW
	TSTB	R3		;SYNCHRONOUS REQUEST?
	BNE	50$		;IF NE NO
	WTSE$S	#O$VEF		; WAIT FOR LOAD TO COMPLETE
	TSTB	(R4)		;TEST FINAL STATUS
	BPL	50$		;IF PL OKAY
30$:				; REFERENCE LABEL

	.IFT

	BIC	#TR$LOD,(R2)	; SET SEGMENT NOT LOADED

	.IFTF			; IF PLAS ON NON-PLAS SUPPORT

40$:				;
	BIS	#TR$MEM,(R2)	; MARK SEGMENT OUT OF MEMORY
	SEC			;SET CARRY
50$:				;

	.IF	DF	D$EBUG	; IN-HOUSE DEBUGGING - REASSEMBLE W/THIS SYMBOL,
				; BUILD TASK W/ODT AND LINK TO NEW OTS MODULE
	ROL	-(SP)		; GET CURRENT OVERLAY'S DISK BLOCK ADDRESS
	CMPB	(PC)+,(R2)	; IS THIS THE ONE WE WANT?
$$$BPT:	.WORD	0		; AT RUNTIME LOAD THIS LOCATION W/DISK BLOCK 
				; ADDRESS OF DESIRED OVERLAY
	BNE	60$		; IF NE, NO - LET TASK CONTINUE EXECUTING
	BPT			; BINGO
	.ENDC

	RETURN			;

	.PAGE
;+
; **-PDLSV SERVICE PUSHDOWN LIBRARY MAPPING CALLS
;
; THIS ROUTINE IS PLACED HERE AS AN EXTENSION OF $AUTO EXECUTED WHEN
; A PUSHDOWN LIBRARY MAP IS DETECTED. THE CODE IS NOT IN AUTO IN ORDER
; TO SAVE MEMORY WHEN $AUTO IS USED FOR NON-PLAS MAPPED TASKS.
;-

	.PSECT	$$PDLS	I,RO,LCL,REL,OVR

PDLSV:
	.IF DF C$$STR		; IF CLUSTERS ARE SUPPORTED
;
; A PUSH-DOWN MAP HAS BEEN DETECTED. WE MUST EXPAND THE STACK TO
; PROVIDE STORAGE FOR THE DISPLACED SEGMENT ADDRESS.
;
	MOV	SP,R3		; POINT TO RETURN ADDRESS OF REGISTER RESTORE
	CMP	-(SP),-(SP)	; PROVIDE SPACE
	MOV	SP,R4		; SET DESTINATION POINTER

	MOV	(R3)+,(R4)+	; SHUFFLE THE STACK (REGISTER RESTORE ADDRESS)
	MOV	(R3)+,(R4)+	; SHUFFLE THE STACK (SAVED R1)
	MOV	(R3)+,(R4)+	; SHUFFLE THE STACK (SAVED R2)
	MOV	(R3)+,(R4)+	; SHUFFLE THE STACK (SAVED R3)
	MOV	(R3)+,(R4)+	; SHUFFLE THE STACK (SAVED R4)
	MOV	(R3)+,(R4)+	; SHUFFLE THE STACK (SAVED R5)

	MOV	#80$-75$,(R4)	; SET IN THE ADDRESS OF A COROUTINE CALL
	ADD	PC,(R4)+	; COMPUTE REAL ADDRESS IN A PIC FASHON
75$:
	MOV	(R3)+,(R4)+	; COPY THE TARGET ROUTINE ADDRESS
	MOV	R2,(R4)		; AND SAVE THE DISPLACED SEGMENT ADDRESS

	CALLR	ASTEN		; REEANBLE ASTS IF DISABLED
				; AND RETURN TO REGISTER RESTORE AND THENCE
				; TO THE TARGET VIA "80$" BELOW

;
; CALL THE TARGET AS A CO-ROUTINE.
;
80$:
	CALL	@(SP)+		; CALL THE TARGET
;
; (SP) = ADDRESS OF THE SEGMENT DISPLACED IN ORDER TO MAP THE TARGET
; 	SEGMENT
; 2(SP) = USER RETURN ADDRESS IN THE SOURCE SEGMENT
;
	ROR	2(SP)		; SAVE THE CARRY BIT IN THE USERS RETURN
				; ADDRESS
	CALL	ASTDS		; DISABLE AST RECOGNITION
	JSR	R5,.SAVR1	; SAVE R1,R2,R3,R4,R5
	MOV	@#N.OVPT,R1	; PICK UP ADDRESS OF IMPURE DATA AREA
;
; (SP) = RETURN ADDRESS TO RESTORE REGISTERS
; 2,4,6,10,12(SP) = SAVED R1,R2,R3,R4,R5
; 14(SP) = ADDRESS OF DISPLACED SEGMENT
; 16(SP) = USERS RETURN ADDRESS WITH SAVED CARRY
;
	MOV	14(SP),R2	; GET SEGMENT ADDRESS

	MOV	PC,R3		; COMPUTE ADDRESS IN A PIC FASHON
85$:
	ADD	#90$-85$,R3	; SET ADDRESS OF ROUTINE TO RESTORE CARRY
	MOV	R3,14(SP)	;

	CALL	@N.MRKS(R1)	; MARK APPROPRIATE SEGMENTS OUT OF MEMORY
	CLR	N.DTDS(R1)	; RESET ANY INDICATION WE DISPLACED A SEGMENT
	JMP	$ALBPL		; AND GO PERFORM PATH LOAD IN $AUTO
;
; AFTER THE APPROPRIATE SEGMENTS HAVE BEEN LOADED, A DIRECT RETURN WILL BE
; TAKEN SINCE THERE IS NO "DISPLACED SEGMENT". THIS TAKES US TO THIS POINT
; WHERE THE CARRY IS RESTORED AND A REAL RETURN TO THE ORIGINAL CALLING SEGMENT
; IS MADE.
;
90$:
	ASL	(SP)		; RESTORE THE CARRY
	RETURN			; FINALLY RETURN TO THE CALLER

	.IFF			; IF CLUSTERS ARE NOT SUPPORTED

	.IF DF P$$LAS		; AND PLAS IS SUPPORTED

	MOV	#IE.OVR&377,@#$DSW ; 'FAKE' AN "ILLEGAL OVERLAY" ERROR
	JMP	ALERR		; AND GO TO AUTOLOAD ERROR SERVICE

	.IFF			; IF PLAS IS NOT SUPPORTED

	RETURN			; AND RETURN TO REGISTER RESTORE AND THENCE
				; TO THE TARGET.

	.ENDC			; IF PLAS SUPPORTED OR NOT

	.IFT			; IF CLUSTERS ARE SUPPORTED

	.DSABL	LSB
;
; DEFINE OVERMAPPED PSECT FOR ACCESS TO THE AST ENABLE/DISABLE AND
; ERROR SERVICE ROUTINES.
;
	.PSECT	$$RTQ	I,RO,GBL,REL,OVR
ASTEN:				; ADDRESS OF AST ENABLE ROUTINE
	.PSECT	$$RTR	I,RO,GBL,REL,OVR
ASTDS:				; ADDRESS OF AST DISABLE ROUTINE
	.PSECT	$$RTS	I,RO,GBL,REL,OVR
				; PUT RETURN SEGMENT HERE TO PRESERVE ORDER

	.ENDC			; IF CLUSTERS OR NOT

	.PSECT	$$ALER	I,RO,LCL,REL,CON
ALERR:				; ENTRY POINT TO AUTOLOAD ERROR SERVICE

	.ENDC			; PLAS OR NON-PLAS

	.END
