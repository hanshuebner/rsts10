	.TITLE	OVIDL
	.IDENT	/01.02/
;
;		COPYRIGHT (c) 1987 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD
;	 MASSACHUSETTS.  ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE  IS  FURNISHED  UNDER  A LICENSE AND MAY BE USED
; AND  COPIED  ONLY IN  ACCORDANCE WITH THE TERMS OF SUCH LICENSE
; AND WITH  THE INCLUSION  OF THE ABOVE  COPYRIGHT  NOTICE.  THIS
; SOFTWARE  OR ANY OTHER  COPIES  THEREOF, MAY NOT BE PROVIDED OR
; OTHERWISE MADE  AVAILABLE TO ANY OTHER PERSON.  NO TITLE TO AND
; OWNERSHIP OF THE SOFTWARE IS HEREBY TRANSFERED.
;
; THE INFORMATION  IN THIS DOCUMENT IS SUBJECT  TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT  BY  DIGITAL
; EQUIPMENT CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF
; ITS SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.
;
; J. M. SALMAN	19-SEP-82
;
; MODIFIED FOR RSX-11M-PLUS AND MICRO/RSX V4.0 BY:
;
; L. M. PETERSON	15-DEC-86	SPR#233P	1.01
;		LMP074		USE R.GSTS SET BY TKB TO ATTACH REGION FOR
;				CLUSTER LIBRARY (INSTEAD OF ALWAYS ATTACHING
;				READ ONLY)
;
; L. M. PETERSON	1-DEC-87			1.02
;		LMP041		GET RID OF UNNECESSARY ELAW$ (CRAW$ WILL DO IT)
;
;------------------------------------------------------------------------
	.IF DF P$$LAS		; IF THIS ASSEMBLY SUPPORTS PLAS
	.IF DF C$$STR		; IF THIS ASSEMBLY SUPPORTS CLUSTERS
	.TITLE	OVIDC I/D (DISK,PLAS,CLUS)
	.NLIST CND		; DON'T LIST CONDITIONALLY EXCLUDED CODE
	.IFF			; IF NO CLUSTER SUPPORT
	.TITLE	OVIDR I/D (DISK,PLAS,-CLUS)
	.NLIST CND		; DON'T LIST CONDITIONALLY EXCLUDED CODE
	.ENDC
	.IFF			; IF NO PLAS SUPPORT REQUIRED
	.TITLE	OVIDL I/D (DISK,-PLAS,-CLUS)
	.NLIST CND		; DON'T LIST CONDITIONALLY EXCLUDED CODE
	.ENDC
;------------------------------------------------------------------------


;
; OVERLAY RUN TIME ROUTINES FOR OVERLAID I- AND D-SPACE TASKS
;
; EQUATED SYMBOLS
;

O$VEF=31.			; SYSTEM OVERLAY EVENT FLAG
Q$IOW=3				; QUEUE I/O DIRECTIVE CODE

;
; MACRO LIBRARY CALLS
;

	.MCALL	ATRG$S,CRAW$S,DIR$,QIOSY$
	RGDF	,,S
	WDBDF	,,S
	QIOSY$

	.IIF NE WF$MAP-100000 .ERROR ; ASSUMPTION ERROR
	.IIF NE RF$ATT-100000 .ERROR ; ASSUMPTION ERROR


;+
; **-$MARKS-MARK SEGMENT
;
; THIS ROUTINE IS CALLED TO MARK ALL SEGMENTS OUT OF MEMORY THAT ARE
; NOT ON THE SAME PATH AS THE ARGUMENT SEGMENT. IT IS ONE OF THE OVER-
; LAY RUN TIME ROUTINES AND IS CALLED BY BOTH THE $LOAD (MANUAL LOAD-
; ING) AND $AUTO (AUTOMATIC LOADING) ROUTINES.
;
; INPUTS:
;
;	R1=ADDRESS OF RUNTIME IMPURE DATA AREA
;	R2=ADDRESS OF ARGUMENT SEGMENT DESCRIPTOR.
;
; OUTPUTS:
;
;	THE APPROPRIATE SEGMENTS ARE MARKED OUT OF MEMORY AND ALL REG-
;	ISTERS ARE PRESERVED.
;
; NOTE WELL:
;
;	THIS ROUTINE MAKES TWO ASSUMPTIONS ABOUT THE OVERLAY DATA
;	BASE IN AN OVERLAID I- AND D-SPACE TASK:
;
;	1) IF A SEGMENT DESCRIPTOR HAS A D-SPACE EXTENSION, THEN ITS
;	   I-SPACE WINDOW DESCRIPTOR POINTER, T$RWDP, AND ITS D-SPACE
;	   WINDOW DESCRIPTOR POINTER, T$DWDP, MUST EITHER BOTH BE ZERO OR 
;	   BOTH BE NON-ZERO.
;
;	2) IF TWO SEGMENT DESCRIPTORS HAVE D-SPACE EXTENSIONS AND POINT
;	   TO THE SAME I-SPACE WINDOW DESCRIPTOR, THEN THEY MUST POINT TO
;	   THE SAME D-SPACE WINDOW DESCRIPTOR AS WELL (AND VICE VERSA).
;-


	.PSECT	$$MRKS	I,RO,LCL,REL,OVR
 
;
; NOTE THE FOLLOWING GLOBAL SYMBOL DEFINITIONS FOR EACH MODULE:
;
;	MODULE		DEFINITIONS
;	------		----------------------------------------
;	OVIDL		$MARDS,$MARKS
;	OVIDR		$MARDR,$MARDS,$MARKR,$MARKS
;	OVIDC		$MARDC,$MARDR,$MARDS,$MARKC,$MARKR,$MARKS
;

	.IF DF P$$LAS		; IF PLAS IS SUPPORTED
	.IF DF C$$STR		; IF CLUSTER LIBRARIES ARE SUPPORTED
$MARDC::
$MARKC::
	.IFTF			; IF PLAS, CLUSTERS OR NOT CLUSTERS
$MARDR::
$MARKR::
	.ENDC
	.IFTF			; IF PLAS OR NOT PLAS
$MARDS::
$MARKS::

	.IFT			; IF PLAS IS SUPPORTED

	MOV	T$RWDP(R2),R4	; GET ADDRESS OF I-SPACE WINDOW BLOCK

	.IF DF C$$STR		; IF THIS ASSEMBLY SUPPORTS CLUSTERS

	CLR	N.DTDS(R1)	; RESET THE "SEGMENT DISPLACED" ADDRESS

	.ENDC			; IF CLUSTERS OR NOT

	.IFTF			; IF PLAS SUPPORTED OR NOT

	MOV	R2,-(SP)	; SAVE ARGUMENT SEGMENT ADDRESS

;
; WORK DOWN-TREE UNTIL AN IN-MEMORY SEGMENT IS FOUND
;

10$:	BIT	#TR$MEM,(R2)	; SEGMENT IN MEMORY?
	BNE	20$		;IF NE NO
15$:	MOV	T$RDWN(R2),R2	;GET DOWN LINK OF SEGMENT
	BNE	10$		;IF NE GO AGAIN
17$:				;
	MOV	(SP)+,R2	;RESTORE ARGUMENT SEGMENT
	RETURN			;

;
; QUIT WHEN THE ROOT IS FOUND, ALL SEGMENTS ARE NOW MARKED AS
; OUT OF MEMORY
;

20$:				;
	TST	T$RDWN(R2)	; IS THIS A ROOT SEGMENT
	BEQ	17$		; IF EQ YES
	MOV	R2,-(SP)	; SAVE SEGMENT DESCRIPTOR ADDRESS
30$:	MOV	R2,-(SP)	;STACK SEGMENT DESCRIPTOR ADDRESS

;
; WORK HORIZONTALLY AT THIS LEVEL LOOKING FOR AN UP-PATH, IN-MEMORY
; SEGMENT
;

40$:	MOV	T$RNXT(R2),R2	;GET NEXT LINK OF SEGMENT
	CMP	R2,(SP)		;SAME AS TOS SEGMENT?
	BEQ	60$		;IF EQ YES

;
; IF FOUND, MARK IT OUT OF MEMORY
;

50$:				;
	BIT	#TR$MEM,(R2)	; SEGMENT IN MEMORY?

	.IFF			; IF PLAS IS NOT SUPPORTED

	BNE	40$		; IF NE NO

	.IFT			; IF PLAS IS SUPPORTED

	BNE	70$		; IF NE NO

	.IFTF			; IF PLAS SUPPORTED OR NOT

	BIS	#TR$MEM,(R2)	; MARK SEGMENT OUT OF MEMORY

	.IFT			; IF PLAS IS SUPPORTED

;
; UNMAP ANY WINDOWS IF THEY WILL BE USED FOR MAPPING THE TARGET
;

	CMPB	N.SZSG(R1),#S$ZSEG+2 ; TASK HAVE MEMORY RESIDENT OVERLAYS?
	BLO	55$		; IF LO NO
	TST	R4		; ANY WINDOW DESCRIPTORS FOR TARGET SEGMENT?
	BEQ	55$		; IF EQ NO
	TST	T$RLNG(R2)	; ZERO LENGTH I-SPACE?
	BEQ	53$		; IF EQ YES
	MOV	T$RWDP(R2),R3	; GET I-SPACE WINDOW DESCRIPTOR
	BEQ	55$		; IF EQ NO WINDOW DESCRIPTOR

	.IF DF C$$STR		; IF CLUSTERS ARE SUPPORTED

	CMP	W$NREG(R3),W$NREG(R4) ; IS THE DISPLACED SEGMENT IN A
				      ; DIFFERENT REGION?
	BEQ	51$		; IF EQ NO PUSH DOWN LIBRARY
	MOV	R2,N.DTDS(R1)	; THE CURRENT SEGMENT IS BEING DISPLACED BY A
				; SEGMENT WHICH IS IN A DIFFERENT REGION. SAVE
				; ITS ADDRESS.  THE LAST ONE SO SAVED WILL BE
				; THE HIGHEST SEGMENT DISPLACED AND A CANDIDATE
				; FOR THE RECOVERY PATH LOAD UPON RETURN FROM
				; THE TARGET.
	.ENDC			; IF CLUSTERS OR NOT
51$:
	CMP	R3,R4		; SAME I-SPACE WINDOW AS TARGET?
	BEQ	55$		; IF EQ YES
	TST	W$NFLG(R3)	; IS I-SPACE WINDOW MAPPED?
	BPL	53$		; IF PL NO
	BIC	#WF$MAP,W$NFLG(R3) ; FLAG WINDOW AS NOT MAPPED
53$:
	BIT	#TR$DSP,T$RLDA(R2) ; DOES SEGMENT HAVE D-SPACE?
	BEQ	57$		; IF EQ NO
	TST	T$DLNG(R2)	; ZERO LENGTH D-SPACE?
	BEQ	57$		; IF EQ YES
	MOV	T$DWDP(R2),R3	; GET D-SPACE WINDOW DESCRIPTOR
	BEQ	57$		; IF EQ NO WINDOW DESCRIPTOR
	TST	W$NFLG(R3)	; WINDOW MAPPED?
	BPL	57$		; IF PL NO
	BIC	#WF$MAP,W$NFLG(R3) ; FLAG WINDOW AS NOT MAPPED
	BR	57$		;	
55$:
	BIT	#TR$LOD,(R2)	; SEGMENT LOADED?
	BEQ	40$		; IF EQ NO
	BIC	#TR$LOD,(R2)	; CLEAR SEGMENT LOADED FLAG
57$:

	.IFTF			; IF PLAS IS SUPPORTED OR NOT

;
; WE FOUND AN UP-LINK, IN-MEMORY SEGMENT, PROCEED UPWARD UNTIL WE GET
; TO THE TOP OF THE IN-MEMORY BRANCH
;

	MOV	T$RUP(R2),(SP)	;REPLACE TOS WITH UP LINK OF SEGMENT
	BEQ	60$		;IF EQ NO LINK UP
	MOV	(SP),R2		;GET ADDRESS OF UP LINK
	BR	50$		;
60$:	TST	(SP)+		;CLEAN STACK
	MOV	(SP)+,R2	;RETRIEVE SEGMENT ADDRESS
	BR	15$		;

	.IFT			; IF PLAS IS SUPPORTED

;
; WE FOUND A SEGMENT OUT OF MEMORY BUT, IN THE CASE WHERE THE TARGET
; AND THE CURRENT SEGMENT ARE DISK-RESIDENT OVERLAYS ON TOP OF A COMMON
; MEMORY RESIDENT OVERLAY, WE WANT TO MAKE SURE THAT TR$LOD IS CLEARED.
;

70$:
	CMPB	N.SZSG(R1),#S$ZSEG+2 ; TASK HAVE MEMORY RESIDENT OVERLAYS?
	BLO	40$		; IF LO NO
	BIT	#TR$LOD,(R2)	; SEGMENT LOADED FROM DISK?
	BEQ	40$		; IF EQ NO
	TST	R4		; DOES TARGET HAVE WINDOW DESCRIPTORS?
	BEQ	40$		; IF EQ NO
	CMP	T$RWDP(R2),R4	; DOES CURRENT SEGMENT HAVE SAME I-SPACE
				; WINDOW DESCRIPTOR AS TARGET?	
	BNE	40$		; IF NE NO
	BIC	#TR$LOD,(R2)	; CLEAR "SEGMENT LOADED" FLAG
	BR	57$		; LOOK UP-TREE FOR MORE LOADED SEGMENTS

	.ENDC

;+
; **-$RDSEG-READ OVERLAY SEGMENT
;
; THIS ROUTINE IS CALLED TO LOAD AN OVERLAY SEGMENT INTO MEMORY. IT
; IS ONE OF THE OVERLAY RUN TIME ROUTINES AND IS CALLED FROM BOTH THE
; $LOAD (MANUAL LOADING) AND $AUTO (AUTOMATIC LOADING) ROUTINES.
;
; INPUTS:
;
;	R1=ADDRESS OF RUNTIME IMPURE DATA AREA
;	R2=ADDRESS OF SEGMENT DESCRIPTOR OF SEGMENT TO BE LOADED.
;
; OUTPUTS:
;
;	C=1 IF I/O ERROR ON EITHER THE INITIAL REQUEST DIRECTIVE OR AT
;		THE COMPLETION OF A SYNCHRONOUS LOAD REQUEST.
;	C=0 IF REQUEST IS SUCCESSFULLY COMPLETED. SEGMENT IS MARKED IN
;		MEMORY.
; 	R3,R4,R5 ARE  DESTROYED
;-


	.PSECT	$$RDSG	I,RO,LCL,REL,OVR

$RDSEG::

	BIC	#TR$MEM,(R2)	; MARK SEGMENT IN MEMORY

	.IF DF	P$$LAS		; IF PLAS IS SUPPORTED

;
; MAP I-SPACE OVERLAY SEGMENT
;

	CMPB	N.SZSG(R1),#S$ZSEG+2 ; TASK HAVE RESIDENT OVERLAYS?
	BLO	200$		; IF LO NO
	TST	T$RLNG(R2)	; ZERO LENGTH I-SPACE?
	BEQ	100$		; IF EQ YES
	MOV	T$RWDP(R2),R3	; GET I-SPACE WINDOW DESCRIPTOR
	BEQ	100$		; IF EQ NONE
	TST	W$NFLG(R3)	; I-SPACE WINDOW MAPPED?
	BMI	100$		; IF MINUS, YES
	MOV	W$NREG(R3),R4	; GET POINTER TO REGION
	BEQ	60$		; IF EQ NONE
	TST	R$GFLG(R4)	; REGION ATTACHED?
	BMI	40$		; IF MI YES
	.IF DF	C$$STR
	MOV	R.GSTS(R4),-(SP) ; SAVE R.GSTS SET BY TKB
	.ENDC	
	CLR	R.GSTS(R4) 	; GET REGION ID IF ALREADY ATTACHED
				; WITHOUT CREATING AN ADB
	ATRG$S	R4		; ATTACH REGION

	.IF NDF	C$$STR		; IF NO CLUSTER LIBRARY SUPPORT

	BCS	70$		; BR IF ATTACH FAILURE

	.IFF	; NDF C$$STR

	MOV	(SP)+,R.GSTS(R4) ; RESTORE R.GSTS
	BCC	30$		; ALREADY ATTACHED
	ATRG$S	R4		; ATTACH REGION
	BCS	70$		; IF CS, THEN ATTACH FAILED
30$:
	.ENDC	; NDF C$$STR

	BIS	#RF$ATT,R$GFLG(R4) ; SET ATTACHED FLAG
40$:				;
	MOV	R.GID(R4),W.NRID(R3) ; SET REGION I/D
60$:				;
	CRAW$S	R3		; MAP I-SPACE ADDRESS WINDOW
	BCC	65$		; IF CC MAPPING SUCCESSFUL
	BIC	#WS.WRT,W.NSTS(R3) ; CHANGE MAPPING STATUS TO R/O
	CRAW$S	R3		; TRY MAPPING AGAIN
	BCS	70$		; BR IF MAP FAILURE
65$:
	BIS	#WF$MAP,W$NFLG(R3) ; SET STATUS=MAPPED
	BR	100$		;
70$:
	JMP	700$		; MAP FAILURE
100$:				;

;
; MAP D-SPACE OVERLAY SEGMENT
;

	BIT	#TR$DSP,T$RLDA(R2) ; DOES SEGMENT HAVE D-SPACE?
	BEQ	200$		; IF EQ NO
	TST	T$DLNG(R2)	; ZERO LENGTH D-SPACE?
	BEQ	200$		; IF EQ YES
	MOV	T$DWDP(R2),R3	; GET D-SPACE WINDOW DESCRIPTOR
	BEQ	200$		; IF EQ NONE
	TST	W$NFLG(R3)	; D-SPACE WINDOW MAPPED?
	BMI	200$		; IF MINUS, YES
	TST	W$NREG(R3)	; IS THERE A REGION DESCRIPTOR?
	BNE	70$		; IF NE YES - ERROR, D-SPACE OVERLAYS ARE
				; NOT SUPPORTED FOR REGIONS WHOSE ID'S ARE
				; OTHER THAN 0 AND 1
	CRAW$S	R3		; MAP D-SPACE ADDRESS WINDOW
	BCC	165$		; IF CC MAPPING SUCCESSFUL
	BIC	#WS.WRT,W.NSTS(R3) ;CHANGE MAPPING STATUS TO R/O
	CRAW$S	R3		; TRY MAPPING AGAIN
	BCS	70$		; BR IF MAP FAILURE
165$:
	BIS	#WF$MAP,W$NFLG(R3) ; SET STATUS=MAPPED
200$:				;
	BIT	#<TR$DSK!TR$LOD>,(R2) ; SEGMENT TO BE LOADED?
	BNE	600$		; IF NE NO
	BIS	#TR$LOD,(R2)	; MARK SEGMENT AS LOADED

	.IFF

	BIT	#TR$DSK,(R2)	; SEGMENT HAVE DISK SPACE?
	BNE	600$		; IF NE NO DISK

	.IFTF

	TST	T$RLNG(R2)	; ZERO LENGTH I-SPACE?
	BEQ	500$		; IF EQ YES

;
; BUILD A QIO DPB ON THE STACK TO LOAD THE I-SPACE DISK OVERLAY OR THE MEMORY
; RESIDENT OVERLAY IF IT HAS NOT YET BEEN LOADED
;

	CLR	-(SP)		; CLEAR PARAM. WORD 6
	MOV	(R2),-(SP)	; SET RELATIVE BLOCK NUMBER
	BIC	#170000,(SP)	; CLEAR STATUS FIELD
	CLR	-(SP)		; SECOND HALF OF RELATIVE BLOCK IS ZERO
	CLR	-(SP)		; ZERO STACK WORD
	MOV	T$RLNG(R2),-(SP) ; SET LENGTH OF OVERLAY SEGMENT
	MOV	T$RLDA(R2),-(SP) ; SET I-SPACE VIRTUAL LOAD ADDRESS
	BIC	#TR$DSP,(SP)	; CLEAR D-SPACE FLAG
	CLR	-(SP)		; NO AST TRAP ADDRESS
	MOV	R1,R4		; CALCULATE ADDRESS OF COMMON I/O STATUS
	ADD	#N.IOST,R4	;
	MOV	R4,-(SP)	; SET I/O STATUS BLOCK
	MOV	#O$VEF,-(SP)	; SET SYSTEM EVENT FLAG
	MOV	(R1),-(SP)	; SET LOGICAL UNIT NUMBER FOR OVERLAYS
	MOV	#IO.LOV,-(SP)	; SET FUNCTION CODE
	MOV	(PC)+,-(SP)	; SET DIRECTIVE CODE AND LENGTH
	.BYTE	Q$IOW,12.	;
	DIR$			; LOAD I-SPACE PART OF OVERLAY SEGMENT
	BCS	610$		; IF CS DIRECTIVE ERROR
	TSTB	(R4)		; TEST FINAL STATUS
	BMI	610$		; IF MI OVERLAY READ ERROR
500$:
	BIT	#TR$DSP,T$RLDA(R2) ; SEGMENT HAS D-SPACE?
	BEQ	600$		; IF EQ NO
	TST	T$DLNG(R2)	; ZERO LENGTH D-SPACE PART?
	BEQ	600$		; IF EQ YES

;
; BUILD A QIO DPB ON THE STACK TO LOAD THE D-SPACE DISK OVERLAY OR THE MEMORY
; RESIDENT OVERLAY IF IT HAS NOT YET BEEN LOADED
;

	CLR	-(SP)		; CLEAR PARAM. WORD 6
	MOV	T$DBLK(R2),-(SP) ; SET RELATIVE BLOCK NUMBER
	CLR	-(SP)		; SECOND HALF OF RELATIVE BLOCK IS ZERO
	CLR	-(SP)		; ZERO STACK WORD
	MOV	T$DLNG(R2),-(SP) ; SET LENGTH OF OVERLAY SEGMENT
	MOV	T$DLDA(R2),-(SP) ; SET D-SPACE VIRTUAL LOAD ADDRESS
	CLR	-(SP)		; NO AST TRAP ADDRESS
	MOV	R1,R4		; CALCULATE ADDRESS OF COMMON I/O STATUS
	ADD	#N.IOST,R4	;
	MOV	R4,-(SP)	; SET I/O STATUS BLOCK
	MOV	#O$VEF,-(SP)	; SET SYSTEM EVENT FLAG
				; >>>>>>>> ASSUME THAT N.OVLY = 0 <<<<<<<<
	MOV	(R1),-(SP)	; SET LOGICAL UNIT NUMBER FOR OVERLAYS
	MOV	#IO.LDO,-(SP)	; SET FUNCTION CODE: LOAD D-SPACE OVERLAY
	MOV	(PC)+,-(SP)	; SET DIRECTIVE CODE AND LENGTH
	.BYTE	Q$IOW,12.	;
	DIR$			; LOAD D-SPACE PART OF OVERLAY SEGMENT
	BCS	610$		; IF CS DIRECTIVE ERROR
	TSTB	(R4)		; TEST FINAL STATUS
	BMI	610$		; IF MI OVERLAY READ ERROR
600$:
	CLC			; SUCCESS
	RETURN			;
610$:
	.IFT

	BIC	#TR$LOD,(R2)	; MARK SEGMENT NOT LOADED

	.IFTF

700$:
	BIS	#TR$MEM,(R2)	; MARK SEGMENT OUT OF MEMORY
	SEC			; FAILURE
	RETURN			;

	.PAGE
;+
; **-PDLSV SERVICE PUSHDOWN LIBRARY MAPPING CALLS
;
; THIS ROUTINE IS PLACED HERE AS AN EXTENSION OF $AUTO EXECUTED WHEN
; A PUSHDOWN LIBRARY MAP IS DETECTED. THE CODE IS NOT IN AUTO IN ORDER
; TO SAVE MEMORY WHEN $AUTO IS USED FOR NON-PLAS MAPPED TASKS.
;-

	.PSECT	$$PDLS	I,RO,LCL,REL,OVR

PDLSV:
	.IF DF C$$STR		; IF CLUSTERS ARE SUPPORTED
;
; A PUSH-DOWN MAP HAS BEEN DETECTED. WE MUST EXPAND THE STACK TO
; PROVIDE STORAGE FOR THE DISPLACED SEGMENT ADDRESS.
;
	MOV	SP,R3		; POINT TO RETURN ADDRESS OF REGISTER RESTORE
	CMP	-(SP),-(SP)	; PROVIDE SPACE
	MOV	SP,R4		; SET DESTINATION POINTER

	MOV	(R3)+,(R4)+	; SHUFFLE THE STACK (REGISTER RESTORE ADDRESS)
	MOV	(R3)+,(R4)+	; SHUFFLE THE STACK (SAVED R1)
	MOV	(R3)+,(R4)+	; SHUFFLE THE STACK (SAVED R2)
	MOV	(R3)+,(R4)+	; SHUFFLE THE STACK (SAVED R3)
	MOV	(R3)+,(R4)+	; SHUFFLE THE STACK (SAVED R4)
	MOV	(R3)+,(R4)+	; SHUFFLE THE STACK (SAVED R5)

	MOV	#80$-75$,(R4)	; SET IN THE ADDRESS OF A COROUTINE CALL
	ADD	PC,(R4)+	; COMPUTE REAL ADDRESS IN A PIC FASHON
75$:
	MOV	(R3)+,(R4)+	; COPY THE TARGET ROUTINE ADDRESS
	MOV	R2,(R4)		; AND SAVE THE DISPLACED SEGMENT ADDRESS

	CALLR	ASTEN		; REEANBLE ASTS IF DISABLED
				; AND RETURN TO REGISTER RESTORE AND THENCE
				; TO THE TARGET VIA "80$" BELOW

;
; CALL THE TARGET AS A CO-ROUTINE.
;
80$:
	CALL	@(SP)+		; CALL THE TARGET
;
; (SP) = ADDRESS OF THE SEGMENT DISPLACED IN ORDER TO MAP THE TARGET
; 	SEGMENT
; 2(SP) = USER RETURN ADDRESS IN THE SOURCE SEGMENT
;
	ROR	2(SP)		; SAVE THE CARRY BIT IN THE USERS RETURN
				; ADDRESS
	CALL	ASTDS		; DISABLE AST RECOGNITION
	JSR	R5,.SAVR1	; SAVE R1,R2,R3,R4,R5
	MOV	@#N.OVPT,R1	; PICK UP ADDRESS OF IMPURE DATA AREA
;
; (SP) = RETURN ADDRESS TO RESTORE REGISTERS
; 2,4,6,10,12(SP) = SAVED R1,R2,R3,R4,R5
; 14(SP) = ADDRESS OF DISPLACED SEGMENT
; 16(SP) = USERS RETURN ADDRESS WITH SAVED CARRY
;
	MOV	14(SP),R2	; GET SEGMENT ADDRESS

	MOV	PC,R3		; COMPUTE ADDRESS IN A PIC FASHON
85$:
	ADD	#90$-85$,R3	; SET ADDRESS OF ROUTINE TO RESTORE CARRY
	MOV	R3,14(SP)	;

	CALL	@N.MRKS(R1)	; MARK APPROPRIATE SEGMENTS OUT OF MEMORY
	CLR	N.DTDS(R1)	; RESET ANY INDICATION WE DISPLACED A SEGMENT
	JMP	$ALBPL		; AND GO PERFORM PATH LOAD IN $AUTO
;
; AFTER THE APPROPRIATE SEGMENTS HAVE BEEN LOADED, A DIRECT RETURN WILL BE
; TAKEN SINCE THERE IS NO "DISPLACED SEGMENT". THIS TAKES US TO THIS POINT
; WHERE THE CARRY IS RESTORED AND A REAL RETURN TO THE ORIGINAL CALLING SEGMENT
; IS MADE.
;
90$:
	ASL	(SP)		; RESTORE THE CARRY
	RETURN			; FINALLY RETURN TO THE CALLER

	.IFF			; IF CLUSTERS ARE NOT SUPPORTED

	.IF DF P$$LAS		; AND PLAS IS SUPPORTED

	MOV	#IE.OVR&377,@#$DSW ; 'FAKE' AN "ILLEGAL OVERLAY" ERROR
	JMP	ALERR		; AND GO TO AUTOLOAD ERROR SERVICE

	.IFF			; IF PLAS IS NOT SUPPORTED

	RETURN			; AND RETURN TO REGISTER RESTORE AND THENCE
				; TO THE TARGET.

	.ENDC			; IF PLAS SUPPORTED OR NOT

	.IFT			; IF CLUSTERS ARE SUPPORTED

	.DSABL	LSB
;
; DEFINE OVERMAPPED PSECT FOR ACCESS TO THE AST ENABLE/DISABLE AND
; ERROR SERVICE ROUTINES.
;
	.PSECT	$$RTQ	I,RO,GBL,REL,OVR
ASTEN:				; ADDRESS OF AST ENABLE ROUTINE
	.PSECT	$$RTR	I,RO,GBL,REL,OVR
ASTDS:				; ADDRESS OF AST DISABLE ROUTINE
	.PSECT	$$RTS	I,RO,GBL,REL,OVR
				; PUT RETURN SEGMENT HERE TO PRESERVE ORDER

	.ENDC			; IF CLUSTERS OR NOT

	.PSECT	$$ALER	I,RO,LCL,REL,CON
ALERR:				; ENTRY POINT TO AUTOLOAD ERROR SERVICE

	.ENDC			; PLAS OR NON-PLAS

	.END
