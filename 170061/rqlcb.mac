	.TITLE	RQLCB
	.IDENT	/05/
;
;  
; 		COPYRIGHT (c) 1981 BY
; 	DIGITAL EQUIPMENT CORPORATION, MAYNARD
; 	 MASSACHUSETTS.  ALL RIGHTS RESERVED.
;  
; THIS  SOFTWARE  IS FURNISHED UNDER A LICENSE AND MAY
; BE USED AND  COPIED  ONLY  IN  ACCORDANCE  WITH  THE
; TERMS  OF SUCH LICENSE AND WITH THE INCLUSION OF THE
; ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER
; COPIES  THEREOF  MAY  NOT  BE  PROVIDED OR OTHERWISE
; MADE AVAILABLE TO ANY OTHER  PERSON.   NO  TITLE  TO
; AND OWNERSHIP OF THE SOFTWARE IS HEREBY TRANSFERRED.
;  
; THE  INFORMATION  IN  THIS  SOFTWARE  IS  SUBJECT TO
; CHANGE WITHOUT NOTICE AND SHOULD  NOT  BE  CONSTRUED
; AS  A  COMMITMENT  BY DIGITAL EQUIPMENT CORPORATION.
;  
; DIGITAL ASSUMES NO RESPONSIBILITY  FOR  THE  USE  OR
; RELIABILITY  OF  ITS  SOFTWARE  ON EQUIPMENT THAT IS
; NOT SUPPLIED BY DIGITAL.
;  
;
; VERSION 05
;
; D.N. CUTLER 6-OCT-72
;
; C. D'ELIA/B. SCHREIBER	IF BEST FIT AND BLOCK IS EXACT SIZE,
;				GRAB IT.
;
;	S. RUZICH	4-MAR-81
;
;		SR112 - GIVE .PSECT $$RESL READ-ONLY ATTRIBUTE
;
;	S. RUZICH	30-JUL-81
;
;		SR160 -	AVOID MERGING BLOCK WHICH ENDS AT 32K BYTES.
;
;
; BEST/FIRST FIT DYNAMIC CORE ALLOCATION ROUTINES
;
; DATA STRUCTURES
;
; FREE BLOCK LIST HEADER:
;
;	FREEHD:	.WORD	NEXT	;POINTER TO NEXT FREE BLOCK OR 0
;		.WORD	0	;ALWAYS ZERO
;
; FREE BLOCK:
;
;	FREEBK:	.WORD	NEXT	;POINTER TO NEXT OR 0
;		.WORD	SIZE	;SIZE OF BLOCK IN BYTES
;
; NOTE: THE FREE BLOCK LIST IS ORDERED BY THE CORE ADDRESS OF THE BLOCKS
;	THEMSELVES. THIS IS SO GARBAGE COLLECTION AND BLOCK AGGLOMERATIO
;	CAN BE PERFORMED WITH LITTLE OVERHEAD.
;+
; **-$RLCB-RELEASE CORE BLOCK
;
; THIS SUBROUTINE IS CALLED TO RELEASE A CORE BLOCK TO THE FREE LIST.
; THE FREE LIST IS SEARCHED UNTIL THE PROPER SLOT IS FOUND AND THE
; BLOCK IS MERGED INTO THE FREE LIST. IF THE BLOCK BEING RELEASED
; CAN BE AGGLOMERATED WITH A BLOCK ALREADY IN THE FREE LIST, THEN THE
; BLOCKS ARE AGGLOMERATED AND THE NEW BLOCK IS MERGED INTO THE FREE
; LIST.
;
; INPUTS:
;
;	R0=ADDRESS OF FREE BLOCK LIST HEAD.
;	R1=SIZE OF BLOCK TO RELEASE IN BYTES.
;	R2=ADDRESS OF BLOCK TO RELEASE.
;
; OUTPUTS:
;
;	NONE.
;-

	.PSECT	$$RESL,RO
$RLCB::	SAVRG			;SAVE NONVOLITILE REGISTERS
	ADD	#3,R1		;ROUND UP TO NEXT 2 WORD BOUNDRY
	BIC	#3,R1		;CLEAR EXCESS BITS
	BEQ	5$		;IF EQ VERGESSEN!!!
1$:	MOV	(R0),R3		;GET ADDRESS OF NEXT IN LIST
	BEQ	2$		;IF EQ END OF CHAIN
	CMP	R2,R3		;COMPARE ADDRESSES
	BLO	2$		;IF LO FOUND SLOT
	MOV	R3,R0		;SET NEW PREVIOUS ADDRESS
	BR	1$		;GO AGAIN
;
; SEE IF BLOCKS CAN BE MERGED IN NEW + OLD ORDER.
;
2$:	MOV	R3,(R2)		;ASSUME NO AGGLOMERATION
	MOV	R2,R4		;CALCULATE ADDRESS OF NEXT BLOCK
	ADD	R1,R4		;ADD IN BLOCK SIZE
	BEQ	3$		;EQ - NEW BLOCK ENDS AT 32K - DO NOT MERGE
	CMP	R3,R4		;COMPARE ADDRESSES
	BNE	3$		;IF NE DO NOT MERGE BLOCKS
	MOV	(R3)+,(R2)	;SET NEW FORWARD LINK
	ADD	(R3),R1		;ADJUST SIZE
;
; SEE IF BLOCKS CAN BE MERGED IN OLD + NEW ORDER.
;
3$:	MOV	R2,(R0)		;ASSUME NO AGGLOMERATION
	MOV	R0,R4		;CALCULATE ADDRESS OF NEXT BLOCK
	ADD	2(R0),R4	;ADD IN BLOCK SIZE
	CMP	R2,R4		;COMPARE ADDRESSES
	BNE	4$		;IF NE DO NOT MERGE
	MOV	(R2),(R0)	;SET NEW FORWARD LINK
	ADD	2(R0),R1	;ADJUST SIZE
	MOV	R0,R2		;SET NEW BASE ADDRESS OF BLOCK
4$:	MOV	R1,2(R2)	;SET SIZE OF BLOCK
5$:	RETURN			;

;+
; **-$RQCB-REQUEST CORE BLOCK
;
; THIS ROUTINE IS CALLED TO REQUEST A CORE BLOCK FROM THE FREE LIST.
; THE SELECTION IS MADE EITHER FIRST FIT OR BEST FIT ACCORDING TO THE
; THE INPUT PARAMETERS.
;
; INPUTS:
;
;	R0=ADDRESS OF FREE BLOCK LIST HEAD.
;	R1=SIZE OF BLOCK REQUESTED IN BYTES.
;		IF R1 IS GE 0, THEN BEST FIT IS USED.
;		IF R1 IS LT 0, THEN FIRST FIT IS USED.
;
;	IN EITHER CASE THE MAGNITUDE OF R1 IS THE SIZE OF THE BLOCK.
;
; OUTPUTS:
;
;	C=1 IF REQUEST CANNOT BE FULFILLED.
;	C=0 IF REQUEST IS SATISFIED.
;		R0=ADDRESS OF REQUESTED CORE BLOCK.
;-

$RQCB::	SAVRG			;SAVE NONVOLITILE REGISTERS
	CLR	R4		;CLEAR PREVIOUS BLOCK ADDRESS
	CLR	R5		;CLEAR FOUND BLOCK ADDRESS
	MOV	R1,R2		;SET TYPE OF FIT FLAG
	BPL	1$		;IF PL BEST FIT
	NEG	R1		;MAKE SIZE POSITIVE
1$:	ADD	#3,R1		;ROUND TO NEXT 2 WORD BOUNDRY
	BIC	#3,R1		;CLEAR EXCESS BITS
	BEQ	9$		;IF EQ VERGESSEN!!!
2$:	MOV	(R0),R3		;GET ADDR OF NEXT
	BEQ	5$		;IF EQ END OF LIST
	CMP	R1,2(R3)	;BLOCK BIG ENOUGH?
	BHI	4$		;IF HI NO
	BEQ	6$		;IF EQ CORRECT SIZE--USE IT
	TST	R2		;FIRST/BEST FIT?
	BMI	6$		;IF MI FIRST FIT
	TST	R5		;FIND PREVIOUS BLOCK?
	BEQ	3$		;IF EQ NO
	CMP	2(R5),2(R3)	;COMPARE BLOCK SIZES
	BLOS	4$		;IF LOS PREVIOUS WINS
3$:	MOV	R0,R4		;SET ADDR OF PREV
	MOV	R3,R5		;SET ADDR OF BLOCK
4$:	MOV	R3,R0		;SET NEW PREV ADDR
	BR	2$		;GO AGAIN
5$:	TST	R2		;FIRST/BEST FIT?
	BMI	9$		;IF MI FIRST FIT
	TST	R5		;FIND A BLOCK?
	BEQ	9$		;IF EQ NO
	MOV	R4,R0		;RETRIEVE ADDR OF PREV
	MOV	R5,R3		;RETRIEVE ADDR OF BLOCK
6$:	SUB	R1,2(R3)	;REDUCE SIZE OF BLOCK
	BEQ	7$		;IF EQ NONE LEFT
	ADD	2(R3),R3	;CALCULATE ADDRESS OF BLOCK
	BR	8$		;
7$:	MOV	(R3),(R0)	;LINK PREV TO NEXT
8$:	MOV	R3,R0		;SET ADDRESS OF BLOCK
	CLC			;CLEAR CARRY
	BR	10$		;
9$:	SEC			;SET CARRY
10$:	RETURN			;

	.END			;
