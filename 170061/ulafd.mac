	.TITLE	ULAFD
	.IDENT	/01.2/
 
; COPYRIGHT (C) 1978
; DIGITAL EQUIPMENT CORPORATION, MAYNARD MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LISENSE FOR USE ONLY ON A
; SINGLE COMPUTER SYSTEM AND MAY  BE  COPIED   ONLY  WITH  THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE,  OR
; ANY OTHER COPIES THEREOF, MAY NOT BE PROVIDED  OR  OTHERWISE
; MADE AVAILABLE TO ANY OTHER  PERSOM  EXCEPT FOR  USE ON SUCH
; SYSTEM AND TO ONE WHO AGREES TO THESE LICENSE  TERMS.  TITLE
; TO AND OWNERSHIP OF THE SOFTWARE SHALL AT ALL  TIMES  REMAIN
; IN DEC.
;
; THE INFORMATION IN THIS DOCUMENT IS SUBJECT TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT BY DIGITAL
; EQUIPMENT CORPORATION.
;
; DEC ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF
; ITS SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DEC.
;
; THIS SOFTWARE IS FURNISHED TO PURCHASER UNDER A LICENSE FOR USE
; ON A SINGLE COMPUTER SYSTEM AND CAN BE COPIED (WITH INCLUSION
; OF DEC'S COPYRIGHT NOTICE) ONLY FOR USE IN SUCH SYSTEM, EXCEPT
; AS MAY OTHERWISE BE PROVEDED IN WRITING BY DEC.
 
; THE INFORMATION IN THIS DOCUMENT IS SUBJECT TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT BY DIGITAL
; EQUIPMENT CORPORATION.
;
;
; VERSION 01.2
;
;
;
; BERNARD ALIMONTI	18-NOV-78
; UPDATED
;	M. JOHNSON	01-JUN-81
;		MJ017 -- RE-FIX SO EOF IS DETECTED IN A ONE BLOCK LONG MODULE
;			 IN SUCH A WAY THAT NO PRIVILEGE VIOLATION PROBLEM
;			 IS CAUSED (CORRECTION DEVELOPED BY E. POLLACK)
;
;
;
; UNIVERSAL LIBRARY ACCESS FIND
;
;
 
 
 
;
; MACRO CALLS
;
 
	.IF NDF S$$LIB
 
	.MCALL	GET$
 
	.IFF
 
	.MCALL	GET$S
 
	.ENDC
 
 
 
 
;
; DIRECT ASSIGNMENT
;
 
MNTESZ	=10			;UNI MNT ENTRY SIZE
 
LMT	=34			;LIB HDER OFFSET FOR LOW VBN OF START OF MNT
LMI	=36			;LIB HDER OFFSET FOR # OF MNT ENTRIES ALLOCATED
LMA	=40			;LIB HDER OFFSET FOR # OF MNT ENTRIES AVAILABLE
 
MHSIZE	=100			;SIZE OF UNIVERSAL MODULE HEADER
MHUFA	=40			;USER FILE ATTRIBUTES OF INSERTED FILE
 
  
 
 
;+
;
; **-$ULAFD-UNIVERSAL LIBRARY ACCESS FIND
;
; THIS ROUTINE FINDS THE MODULE DESIRED AND SETS-UP FOR ACCESS BY THE USER
; ROUTINE.  (ALSO, THE ROUTINE READS THE MODULE HEADER INTO THE BLOCK OF WORDS
; FOLLOWING THE 2 WORD BUFFER CONTAING THE RAD50 NAME OF THE DESIRED MODULE.)
;
;	INPUTS:
;
;		R0 = FDB ADDRESS OF UNIVERSAL LIBRARY
;		R2 = ADDRESS OF LIBRARY HEADER RECORD
;		R5 = ADDRESS OF A 2 WORD BUFFER CONTAINING THE RAD50 OF THE 
;			MODULE TO BE ACCESSED, FOLLOWED BY 40 OCTAL WORDS WHICH
;			WILL CONTAIN A COPY OF THE MODULE HEADER UPON RETURN
;
;		LIB. FILE SET FOR ACCESS IN LOCATE MODE
;		LIB. FILE REC TYPE SET TO FIXED LENGTH RECRODS
;		LIB. FILE REC SIZE SET TO SIZE OF UNIVERSAL MODULE HDER SIZE
;
;
;	OUTPUTS:
;
;		R0, R3-R5 = UNCHANGED
;		R1, R2 = GARBAGE
;
;		FIRST FIVE WORDS OF LIBRARY FILE'S FDB ARE SET TO EQUAL FIRST
;			FIVE WORDS OF THE FDB OF THE MODULES'S ASSOCIATED INPUT
;			FILE
;
;		LIB. FILE SET FOR ACCESS IN MOVE MODE
;		LIB. FILE REC TYPE SET TO VARIABLE LENGTH
;		LIB. FILE REC SIZE SET TO UNIVERSAL MODULE HEADER SIZE
;
;
;		F.EFBK+2 = LAST VBN OF MOUDLE
;
;		F.FFBY = NEXT AVAILABLE BYTE PAST END OF MODULE
;
;		F.ERR = INTERPRETED AS USUAL, EXCEPT IE.NSF IS INTERPRETED AS
;			"NO SUCH MODULE"
;
;		C-BIT SET = ERROR
;		C-BIT CLEAR = NO ERROR
;
;-
 
 
 
 
$ULAFD::SAVRG
	MOV	LMI(R2),-(SP)	;MOVE NUM OF MNT ENT. ALLOCAT. TO STACK
	SUB	LMA(R2),(SP)	;GET NUM OF ACTIVE MODULES
	MOV	(SP)+,R4	;COPY NUM TO R4
	TST	R4		;ANY ACTIVE MODULES?
	BEQ	50$		;IF EQ, NO, SO BRANCH TO REPORT ERROR
	CALL	FIND		;FIND MNT OF MOD SPECIFIED AND PROCESS
	BCC	140$		;IF CC, NO ERRORS, SO CONTINUE
	BVC	150$		;IF VC, FCS ERROR IN FIND, SO RETURN
50$:	MOV	#IE.NSF,F.ERR(R0) ;ACCESS ERROR, NO SUCH MODULE; ALSO CLR V-BIT
	SEC			;INDICATE ERROR
	BR	150$		;BRANCH TO RETURN
140$:	CLR	R1		;CLEAR R1 IN PREP OF POINT
	CLR	R3		;CLEAR R3 IN PREP OF POINT
	CALL	.POINT		;POINT TO MODULE HEADER (R2 SET IN FIND)
	BCS	150$		;IF CS, ERROR, SO RETURN
	BICB	#FD.PLC,F.RACC(R0) ;INDICATE MOVE MODE
	MOV	#R.VAR,F.RTYP(R0) ;INDICATE VARIABLE LENGTH REC
	MOV	#MHSIZE,F.RSIZ(R0) ;INDICATE REC SIZE OF MOD HEADER
	ADD	#4,R5		;POINT R4 TO MOD HDER BUFFER
 
	.IF	NDF	S$$LIB
 
	GET$	R0,R5,#MHSIZE	;GET MNT ENTRY
 
	.IFF
 
	GET$S	R0,R5,#MHSIZE	;GET MODULE HEADER
 
	.ENDC
 
	BCS	150$		;IF CS, ERROR, SO RETURN
	MOV	R5,R4		;POINT R4 TO MODULE HEADER RECORD
	CLR	R1		;CLEAR R1 IN PREP OF POINT
	INC	R2		;R2 =VBN OF BEGIN. OF MODULE
	CLR	R3		;CLEAR R3 IN PREP OF POINT
	CALL	.POINT		;POSITION FILE TO BEGIN. OF MOD
	BCS	150$		;IF CS, ERROR, SO RETURN

	ADD	#MHUFA,R4	;POINT R4 TO MOD HDER'S USER FILE ATTRIBS.
	MOV	R0,R5		;COPY LIB'S FDB ADDRESS TO R5
	MOV	(R4)+,(R5)+	;COPY F.RTYP/F.RATT
	MOV	(R4)+,(R5)+	;COPY F.RSIZ
	MOV	(R4)+,(R5)+	;COPY F.HIBK+0, ALWAYS ZERO IN LIBRARIES
	MOV	(R4)+,(R5)	; COPY F.HIBK+2
	ADD	R2,(R5)		;ADJUST F.HIBK+2 BY "BASE" ADDRESS OF MODULE
	DEC	(R5)+		; BASE "0"
	MOV	(R4)+,(R5)+	; COPY F.EFBK+0

	ADD	(R4)+,R2	;ADD # OF BLOCKS OF MOD TO CURRENT FILE POSITION
	DEC	R2		;R2 =VBN OF END OF MODULE
	MOV	R2,(R5)+	;COPY TO EOF INDICATOR OF FDB
	MOV	(R4),(R5)	;GET NEXT AVAIL. BYTE IN BLK
150$:	RETURN
 
 
 
 
	.PAGE
 
;+
;
; **-FIND-FIND A MODULE
;
; THIS ROUTINE FINDS THE MODULE DESIRED
;
;	INPUTS:
;
;		R0 = FDB ADDRESS OF UNIVERSAL LIABRARY
;		R4 = # OF ACTIVE MODULES IN THE LIBRARY
;		R5 = ADDRESS OF A 2 WORD BLK CONTAINING THE RAD50 OF THE MODULE
;			TO BE ACCESSED
;
;		LIB. FILE SET FOR ACCESS IN LOCATE MODE
;		LIB. FILE SET TO FIXED LENGTH RECORDS
;		LIB. FILE REC SIZE SET TO UNIVERSAL LIBRARY HDER SIZE
;
;	OUTPUTS:
;
;		R0, R4, R5 = UNCHANGED
;		R1, R3	= GARBAGE
;		R2 = VBN OF MOUDLE HEADER OF DESIRED MODULE
;
;		LIB. FILE SET FOR ACCESS IN LOCATE MODE
;		LIB. FILE REC TYPE SET TO FIXED LENGTH
;		LIB. FILE REC SIZE SET TO UNI. LIB. MNT ENTRY SIZE
;
;		C-BIT SET = ERROR (FCS ERROR OR DESIRED MODULE NOT FOUND)
;		V-BIT SET =DESIRED MODULE NOT FOUND
;
;-
 
 
 
 
FIND:	MOV	#MNTESZ,F.RSIZ(R0) ;INDICATE REC SIZE TO BE SIZE OF MNT ENTRY
	CLR	R1		;CLEAR R1 IN PREP OF POINT
	MOV	LMT(R2),R2	;COPY BEGINNING VBN OF MNT TO R2 FOR POINT
	CLR	R3		;CLEAR R3 IN PREP OF POINT
	CALL	.POINT		;POINT TO BEGINNING OFMNT
	BCS	150$		;IF CS, FCS ERROR, SO RETURN
	CLR	R3		;INITIALIZE COUNT OF MNT ENTRIES CHECKED
10$:	INC	R3		;INCREMENT COUNT OF NNT ENTRIES CHECKED
	CMP	R3,R4		;IS COUNT > TOTAL NUM OF ACTIVE MODULES?
	BGT	140$		;IF GT, YES, SO REPORT ERROR
 
	.IF	NDF	S$$LIB
 
	GET$	R0		;GET MNT ENTRY
 
	.IFF
 
	GET$S	R0		;GET MNT ENTRY
 
	.ENDC
 
 
	BCS	150$		;IF CS, FCS ERROR, SO RETURN
	MOV	F.NRBD+2(R0),R2	;POINT R2 TO MNT ENTRY RECORD
30$:	CMP	(R5),(R2)+	;1ST PART OF MOD NAME=1ST PART IN MNT ENT?
	BNE	10$		;IF NE, NO, SO GET NEXT MNT ENTRY
	CMP	2(R5),(R2)+	;2ND PART OF MOD NAME=2ND PART IN MNT ENT?
	BNE	10$		;IF NE, NO, SO GET NEXT NMN ENTRY
	MOV	(R2),R2		;MOVE VBN OF MODULE HEADER TO R2
	BR	150$		;BRANCH TO RETURN
140$:	SEC			;INDICATE ERROR
	SEV			;INDICATE ACCESS ERROR
	BR	160$		;BRANCH TO RETURN
150$:	CLV			;INDICATE NO ACCESS ERROR
160$:	RETURN
 
 
	.END
