;
;		COPYRIGHT (c) 1981 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD
;	 MASSACHUSETTS.  ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE  IS  FURNISHED  UNDER  A LICENSE AND MAY BE USED
; AND  COPIED  ONLY IN  ACCORDANCE WITH THE TERMS OF SUCH LICENSE
; AND WITH  THE INCLUSION  OF THE ABOVE  COPYRIGHT  NOTICE.  THIS
; SOFTWARE  OR ANY OTHER  COPIES  THEREOF, MAY NOT BE PROVIDED OR
; OTHERWISE MADE  AVAILABLE TO ANY OTHER PERSON.  NO TITLE TO AND
; OWNERSHIP OF THE SOFTWARE IS HEREBY TRANSFERED.
;
; THE INFORMATION  IN THIS DOCUMENT IS SUBJECT  TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT  BY  DIGITAL
; EQUIPMENT CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF
; ITS SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.
;

;
;
; MACRO DEFINITATIONS FOR EXTENDED GCML SYSTEM SERVICE
;

	.MACRO EGCMI$

;
;
; MACROS BELOW DEFINE THE IMPURE DATA AREAS AND OFFSETS
;
;		GCMLD$	DEFINE OFFSETS
;		ECMLB$	DEFINE IMPURE AREA
;

;
; GCMLD$ -- DEFINE OFFSETS INTO IMPURE AREA
;
	.MACRO GCMLD$ GLOB 

	.ASECT
	.=0

G.MODE:	.BLKW	2		; STATUS AND CONTROL FLAGS

	GE.COM = 1		; COMMENT RECOGNITION CONTROL
	GE.IND = 2		; INDIRECT FILE RECOGNITION CONTROL
	GE.CLO = 4		; CLOSE COMMAND FILE BEFORE RETURN CONTROL
	GE.LC  = 10		; PASS LOWER CASE CHARACTERS
	GE.CON = 20		; CONTINUATION LINES ALLOWED
	GE.XXX = 40		; UNUSED
	GE.MUL = 100		; MULTIPLE LINES PER INPUT ALLOWED
	GE.LIB = 200		; LIBRARIES ALLOWED
	GE.MCR = 400		; TOP LEVEL IS MCR COMMAND LINE
	GE.IEF = 1000		; SET => INTERMEDIATE EOF ENCOUNTERED
	GE.RWD = 2000		; SET => REWIND ON HITTING EOF
	GE.FOP = 4000		; SET => EXIT AFTER FILE OPEN
	GE.RPR = 10000		; SET => IO.RPR TO TERMINAL FAILED
	GE.SDE = 20000		; DELETE FILE ON FINAL CLOSE
	GE.SER = 40000		; SUPPRESS ERROR REPORT ON FILE LOOKUP
	GE.SLB = 100000		; LIBRARY MODULE SPECIFIED IN "@" COMMAND

;	G2.XXX = 1		; UNUSED SECOND STATUS WORD

G.IMPS:	.BLKB	1		; SIZE OF THIS IMPURE HEADER
G.OVBC:	.BLKB	1		; OVERRIDE BUFFER COUNT
G.FILE:	.BLKW	1		; POINTER TO FILE SYSTEM DATA
G.ERR:	.BLKB	1		; ERROR RETURN

	GE.IOR = -1		; I/O ERROR. DETAILS IN FILE SYSTEM STRUCTURE
	GE.OPR = -2		; UNABLE TO OPEN INDIRECT FILE
	GE.BIF = -3		; BAD INDIRECT FILE NAME OR SYNTAX
	GE.MDE = -4		; MAXIMUM NEST DEPTH EXCEEDED
	GE.CMD = -5		; USER FUNCTION COMMAND ERROR
	GE.VRS = -6		; VERSION MISMATCH BETWEEN IMPURE AREA AND EGCML
	GE.EOF = -10.		; END OF FILE
	GE.RBG = -40.		; BUFFER OVERFLOW

G.CDEP:	.BLKB	1		; NEST LEVEL COUNTER
				; INITALIZED TO -1
				; SET TO 0 AFTER FIRST GCML$ CALL
				; INCREMENTED TO REFLECT INDIRECT NEST LEVEL
G.FUNC:	.BLKB	1		; USER FUNCION CODE
				; 0 = GET NEXT COMMAND LINE
				; 1 = RESET COMMAND SERVICE
				; 2 = CLOSE TOP LEVEL COMAND
				; 3 = OBTAIN MCR COMMAND LINE ONLY
				; 4 = RESUBMIT LINE FOR SCAN
				; 5 = CHAIN TO NEW FILE
				; 6 = RESET MCR EOF FLAG
				; 7 = POP ONE LEVEL OF NESTED FILE
G.MAXD:	.BLKB	1		; MAXIMUM INDIRECT NEST DEPTH
G.TERM:	.BLKB	1		; TERMINAL INPUT TERMINATING CHARACTER
G.TIOS:	.BLKB	1		; TERMINAL I/O SUBFUNCTION BITS
				; THIS BYTE IS 'ORED' WITH THE I/O FUNCTION
				; USED TO READ WITH PROMPT FROM A TERMINAL
G.TIOP:	.BLKW	1		; TERMINAL I/O PARAMETER
				; THIS WORD CONTAINS USER SUPPLIED TIMEOUT AND
				; CARRAGE CONTROL INFORMATION FOR TERMINAL I/O
G.PRMP:	.BLKW	2		; USER PROMPT STRING DESCRIPTOR
G.CMLD:	.BLKW	2		; RETURNED COMMAND LINE DESCRIPTOR
G.FRAG:	.BLKW	2		; MULTIPLE COMMAND FRAGMENT DESCRIPTOR

G.BUFF:	.BLKW	2		; INPUT LINE BUFFER DESCRIPTOR
G.DFPR:	.BLKB	6		; 6 BYTE DEFAULT PROMPT STRING

G.CSIB:	.BLKW	1		; POINTER TO TEMPORARY WORK BUFFER
				; USED FOR GCML$ DPB AND CSI$
G.PPTR:	.BLKW	1		; STACK DESCRIPTOR
G.SWIT:	.BLKW	1		; POINTER TO SWITCH CONTROL TABLES
				; FOR "@FILE" SPECIFICATIONS
G.LBMN:	.BLKB	6		; MODULE NAME FOR "/LB:MODULE" SPECIFICATIONS
G.FQFN:	.BLKW	1		; ADDRESS OF USER BUFFER FOR FULLY QUALIFIED
				; FILE NAME
G.DDIR:	.BLKW	2		; DESCRIPTOR OF DIRECTORY STRING USED IN LAST OPEN
G.ISIZ:				; SIZE OF BASE SECTION OF IMPURE AREA

;
; PUSH DOWN STACK FRAME FORMAT
;
	.ASECT
	.=0

G.SUSR:	.BLKW	1		; USER STACK CONTEXT
G.SDID:	.BLKW	5		; DIRECTORY ID, DEVICE, AND UNIT
G.SFID:	.BLKW	3		; FILE ID
G.SRAT:	.BLKB	16.		; F.RCTL RECORD ATTRIBUTES
G.SPOS:	.BLKW	3		; RFA/.POINT ARGUMENT
G.SBST:	.BLKW	1		; BLOCK BUFFER STATUS
G.SRWP:	.BLKW	3		; RFA/.POINT ARGUMENT FOR REWIND POINT
G.PLFS:				; SIZE OF FRAME IN BYTES

	.PSECT

;
; REDEFINE MACRO TO CONSERVE SYMBOL TABLE SPACE
;
	.MACRO GCMLD$ X
	.ENDM

	.ENDM

;
; ECMLB$ -- ALLOCATE IMPURE AREA FOR EGCML$
;

	.MACRO ECMLB$ FILE,LUN=1,MAXD=3,PRMP=<   >,BFAD,BFSZ=80.,PDL,SWIT,?GF,?GB,?GS

	.MCALL GCMLD$,CWORD$,CBYTE$,CSTRG$ ; OBTAIN OTHER MACRO DEFINITIONS
	.MCALL CSI$SW,CSI$SV,CSI$ND

	.IIF NDF FCS$$ FCS$$=1	; DEFAULT TO FCS-11

	GCMLD$			; DEFINE OFFSETS AND BLOCK SIZE


;
; ALLOCATE FIXED PORTION OF GCML CONTROL TABLE
;

	...PC1=.		; SAVE ADDRESS OF START OF IMPURE AREA
	.BLKB	G.ISIZ		; ALLOCATE IMPURE AREA
;
; INSERT OTHER PARAMETERS INTO CONTROL TABLE
;
	CBYTE$	<G.ISIZ>,G.IMPS	; INSERT SIZE OF IMPURE AREA
	CWORD$	<GE.CON!GE.IND!GE.CLO!GE.COM>,G.MODE ; SET DEFAULT MODE VALUES
	CBYTE$	<MAXD>,G.MAXD	; INSERT MAXIMUM NEST DEPTH
	CBYTE$	<15>,G.DFPR	; INSERT <CR,LF> IN FRONT OF PROMPT
	CBYTE$	<12>,G.DFPR+1	;
	CSTRG$	<PRMP>,G.DFPR+2,3 ; INSERT DEFAULT PROMPT
	CBYTE$	<-1>,G.CDEP	; INITALIZE LEVEL
	CBYTE$	<TF.CCO>,G.TIOS	; INITALIZE TERMINAL SUBFUNCTION BITS
	CWORD$	<0>,G.TIOP	; INITALIZE TERMINAL PARAMETER
	CWORD$	<0>,G.FQFN	; INITALIZE FILE NAME BUFFER ADDRESS
	CBYTE$	<0>,G.OVBC	; INITALIZE THE OVERRIDE BUFFER COUNT

;
; ALLOCATE AND POINT TO PUSH DOWN STACK
;
	.IF B <PDL>		; IF THE USER DID NOT SUPPLY A PUSHDOWN STACK

	...TMP = <<MAXD+1>*G.PLFS>	; COMPUTE SIZE OF PUSH DOWN LIST

...PDL:	.BLKB	...TMP		; ALLOCATE AN INTERNAL NESTING STACK
	CWORD$	<...PDL+...TMP>,G.PPTR	; INITALIZE STACK DESCRIPTOR

	.IFF			; IF THE USER DID SUPPLY A STACK

	.ENDC

				; NOTE THAT THE STACK POINTER REFERENCES
				; THE HIGH END OF THE STACK, NOT THE BEGINNING.


;
; ALLOCATE AND POINT TO USER COMMAND LINE BUFFER
;
	.IF B <BFAD>		; IF THE USER DIDN'T SUPPLY A BUFFER

GB:	.BLKB	BFSZ+2		; ALLOCATE AN INTERNAL BUFFER
	CWORD$	<GB>,G.BUFF+2	; POINT TO IT

	.IFF

	CWORD$	<BFAD>,G.BUFF+2	; POINT TO USER BUFFER

	.ENDC

	CWORD$	<BFSZ>,G.BUFF+0	; INSERT BUFFER SIZE

;
; ALLOCATE AND POINT TO SWITCH CONTROL TABLES FOR "@FILE/SWIT" PARSING
;

	.IF B <SWIT>

...SWI:	GCMSW$	...PC1,GS	; INCLUDE GCML SWITCHES

	CWORD$	<...SWI>,G.SWIT		; POINT TO OUR TABLE

	.IFF

	CWORD$	<SWIT>,G.SWIT		; POINT TO USER SUPPLIED TABLE

	.ENDC


;
; ALLOCATE AND POINT TO FILE_DESCRIPTOR PORTION OF TABLE
;
	.IF NB <FILE>		; IS THERE A USER SUPPLIED FILE DATABASE?

	CWORD$	<FILE>,G.FILE	; IF SO, POINT TO IT

	.IFF

	CWORD$	<GF>,G.FILE	; INSERT FILE DATASTRUCTURE POINTER


	.IF DF FCS$$		; IF FCS-11 IS THE RECORD SYSTEM

	.MCALL FDBDF$,FDAT$A,FDOP$A,NMBLK$,FDBF$A

GF:	FDBDF$			; CREATE THE FCS-11 FILE DESCRIPTOR
	FDAT$A	2		; RECORD ATTRIBUTES
	FDOP$A	LUN,,...FNA	; FILE OPEN INFORMATION
	FDBF$A	,,1		; FORCE SINGLE BUFFERING
	CBYTE$	<FD.TTY!FD.REC!FD.CCL>,F.RCTL ; FORCE INITIAL ATTRIBUTES

...FNA:	NMBLK$	CMI,CMD		; DEFAULT INITIAL NAME BLOCK
				; DEFAULT DEVICE IS THE LINKTIME RESIDUAL
				; ASSIGNMENT FOR THE LOGICAL UNIT

	.IFF			; IF NOT FCS-11

	.IF DF RMS$$		; IF RMS-11 IS THE RECORD SYSTEM

	.MCALL FAB$B,RAB$B,NAM$B ; OBTAIN THE RMS-11 STRUCTURE DEFINITIONS
GF:	.WORD	1,...RAB	; RMS BLOCK DESCRIPTORS
	.WORD	1,...FAB	;

...RAB:	RAB$B			; ALLOCATE RECORD ACCESS BLOCK
	R$FAB	...FAB
	R$RAC	RB$SEQ
	RAB$E

...FAB:	FAB$B			; ALLOCATE FILE ACCESS BLOCK
	F$DNA	...DNA+3
	F$DNS	7
	F$FNA	...FNA
	F$FAC	FB$GET
	F$LCH	LUN
	F$NAM	...NAM
	F$ORG	FB$SEQ
	F$RAT	0
	F$RFM	FB$VAR
	FAB$E

...NAM:	NAM$B
	N$ESS	34.
	NAM$E

...DNA:	.ASCII	/SY:CMI.CMD/
...FNA:	.ASCII	/CMI/
	.BLKB	29.

	.IFF			; IF NOT RMS-11

	.ERROR			; FILE SYSTEM CONDITIONAL NOT DEFINED

	.ENDC			; .IF DF RMS$$

	.ENDC			; .IF DF FCS$$

	.ENDC			; .IF NB <FILE>


	.ENDM

;
; DEFINE A MACRO WHICH, WITH THE NAME OF THE OLD GCML IMPURE AREA
; ALLOCATION MACRO, REFERENCES THE NEW IMPURE AREA ALLOCATION MACRO
; THIS IS TO EASE REQUIREMENTS FOR SOURCE CHANGES WHEN CONVERTING
; FROM THE OLD INTERFACE TO THE NEW INTERFACE.
;
	.MACRO GCMLB$ MAXD=1,PRMP=<   >,UBUF,LUN,PDL,SIZE=80.
	.MCALL ECMLB$

	ECMLB$ ,LUN,MAXD,PRMP,UBUF,SIZE,PDL

	.ENDM


;
; DEFINE THE MACRO WHICH ESTABLISHES THE EGCML SWITCH TABLES
;
	.MACRO GCMSW$ GCMB,?VAL

	.MCALL CSI$SW,CSI$SV,CSI$ND

	CSI$SW	LB,GE.SLB,,SET,,VAL	; /LB:MODULE SWITCH
	CSI$SW	ER,GE.SER,,SET,NEG	; /ER SWITCH
	CSI$SW	DE,GE.SDE,,CLEAR,NEG	; /DE SWITCH
	CSI$ND

VAL:	CSI$SV	ASCII,GCMB+G.LBMN,6			; LIBRARY MODULE GCMB
	CSI$ND

	.ENDM

;
; DEFINE MACROS FOR USER CALLS TO THE GET COMMAND SERVICE
;

;
; GCML$ -- GET COMMAND LINE
;
	.MACRO GCML$  GCMB,PRAD,PRLN
	.MCALL	GCMLD$,LDR0$	; OBTAIN MACRO DEFINITIONS
	GCMLD$	DEF$L		; DEFINE GCML BLOCK OFFSETS
	LDR0$	GCMB		; MOVE BLOCK ADDRESS TO R0
	CLRB	G.FUNC(R0)	; FUNCTION 0 = GET COMMAND LINE

	.IF NB	<PRLN>
	MOV	PRLN,G.PRMP(R0)	; SET USER PROMPT SIZE
	.IF B	<PRAD>
	.ERROR			; PROMPT ADDRESS MISSING
	.IFF
	MOV	PRAD,G.PRMP+2(R0) ; SET USER PROMPT ADDRESS
	.ENDC
	.IFF
	CLR	G.PRMP(R0)	; SET NO PROMPT SUPPLIED
	.ENDC

	.GLOBL	$GCML
	JSR	PC,$GCML	; CALL COMMON GET COMMAND LINE ENTRY
	.ENDM

;
; RCML$ -- RESET COMMAND SERVICE TO TOP LEVEL
;

	.MACRO	RCML$	GCMB
	.MCALL	GCMLD$,LDR0$	; OBTAIN MACRO DEFINITIONS
	GCMLD$	DEF$L		; DEFINE GCML BLOCK OFFSETS
	LDR0$	GCMB		; LOAD BLOCK ADDRESS TO R0
	MOVB	#1,G.FUNC(R0)	; FUNCTION 1 = RESET COMMAND LINE
	.GLOBL	$GCML
	JSR	PC,$GCML	; CALL COMMON GET COMMAND LINE ENTRY
	.ENDM


;
; CCML$ -- CLOSE CURRENT LEVEL OF COMMAND LINE
;

	.MACRO	CCML$ GCMB
	.MCALL	GCMLD$,LDR0$	; OBTAIN MACRO DEFINITIONS
	GCMLD$	DEF$L		; DEFINE GCML BLOCK OFFSETS
	LDR0$	GCMB		; LOAD BLOCK ADDRESS TO R0
	MOVB	#2,G.FUNC(R0)	; FUNCTION 2 = CLOSE TOP LEVEL
	.GLOBL	$GCML
	JSR	PC,$GCML	; CALL COMMON GET COMMAND LINE ENTRY
	.ENDM

;
; MCML$ -- OBTAIN MCR COMMAND LINE ONLY
;

	.MACRO MCML$ GCMB
	.MCALL GCMLD$,LDR0$	; OBTAIN MACRO DEFINITIONS
	GCMLD$	DEF$L		; DEFINE GCML BLOCK OFFSETS
	LDR0$	GCMB		; POINT TO CONTROL BLOCK
	MOVB	#3,G.FUNC(R0)	; FUNCTION 3 = GET MCR LINE ONLY

	.GLOBL	$GCML		; DEFINE ENTRY POINT AS GLOBAL
	JSR	PC,$GCML	; TO DISPATCH ENTRY

	.ENDM

;
; FCML$ -- FORCE COMMAND LINE INTO GCML
;

	.MACRO FCML$ GCMB
	.MCALL GCMLD$,LDR0$	; OBTAIN MACRO DEFINITIONS
	GCMLD$	DEF$L		; DEFINE GCML BLOCK OFFSETS
	LDR0$	GCMB		; POINT TO CONTROL BLOCK
	MOVB	#4,G.FUNC(R0)	; FUNCTION 4 = FORCE COMMAND LINE TO GCML

	.GLOBL	$GCML		; DEFINE ENTRY POINT AS GLOBAL
	JSR	PC,$GCML	; TO DISPATCH ENTRY

	.ENDM

;
; LCML$ -- CHAIN TO NEW INPUT FILE
;

	.MACRO LCML$ GCMB
	.MCALL GCMLD$,LDR0$	; OBTAIN MACRO DEFINITIONS
	GCMLD$	DEF$L		; DEFINE GCML BLOCK OFFSETS
	LDR0$	GCMB		; POINT TO CONTROL BLOCK
	MOVB	#5,G.FUNC(R0)	; FUNCTION 5 = LINK TO NEW INPUT

	.GLOBL	$GCML		; DEFINE ENTRY POINT AS GLOBAL
	JSR	PC,$GCML	; TO DISPATCH ENTRY

	.ENDM

;
; ECML$ -- RESET MCR END FILE FLAG
;

	.MACRO ECML$ GCMB
	.MCALL GCMLD$,LDR0$	; OBTAIN MACRO DEFINITIONS
	GCMLD$	DEF$L		; DEFINE GCML BLOCK OFFSETS
	LDR0$	GCMB		; POINT TO CONTROL BLOCK
	MOVB	#6,G.FUNC(R0)	; FUNCTION 6 = RESET MCR EOF FLAG

	.GLOBL	$GCML		; DEFINE ENTRY POINT AS GLOBAL
	JSR	PC,$GCML	; TO DISPATCH ENTRY

	.ENDM

;
; DCML$ -- POP ONE LEVEL OF INDIRECT FILE
;
	.MACRO	DCML$ GCMB
	.MCALL GCMLD$,LDR0$	; OBTAIN MACRO DEFINITIONS
	GCMLD$	DEF$L		; DEFINE GCML BLOCK OFFSETS
	LDR0$	GCMB		; POINT TO CONTROL BLOCK
	MOVB	#7,G.FUNC(R0)	; FUNCTION 7 = POP ONE LEVEL OF NESTED FILE

	.GLOBL	$GCML		; DEFINE ENTRY POINT AS GLOBAL
	JSR	PC,$GCML	; TO DISPATCH ENTRY

	.ENDM

;
; GCMM$/GCMP$ -- PERFORM MARK AND POINT FUNCTION ON THE CURRENT
;		COMMAND FILE OR LIBRARY MODULE.
;

	.MACRO GCMM$	GCMB
	.MCALL GCMLD$,LDR0$
	GCMLD$	DEF$L		; DEFINE GCML BLOCK OFFSETS
	LDR0$	GCMB		; POINT TO THE CONTROL BLOCK
	MOV	G.FILE(R0),R0	; PICK UP FILE DATABASE ADDRESS

	.GLOBL	.MARK		; DEFINE ENTRY POINT AS GLOBAL
	JSR	PC,.MARK	; AND CALL FCS-11 ROUTINE TO RETURN 
				; FILE "RFA"
	.ENDM

	.MACRO	GCMP$	GCMB
	.MCALL	GCMLD$,LDR0$	; GET MACRO DEFINITIONS
	GCMLD$	DEF$L		; DEFINE GCML BLOCK OFFSETS
	LDR0$	GCMB		; POINT TO THE CONTROL BLOCK
	MOV	G.FILE(R0),R0	; PICK UP FILE DATABASE ADDRESS

	.GLOBL	.POINT		; DEFINE ENTRY POINT AS GLOBAL
	JSR	PC,.POINT	; AND CALL FCS-11 ROUTINE TO POINT THE
				; FILE
	.ENDM

;
; CMSET$ -- SET FIELDS IN GCML DATABASE
;

	.MACRO CMSET$ GCMB,TSUB,TVFC,FQFN,TTMO,OVBC
	.MCALL LDR0$,CMOV$B,CMOV$W,GCMLD$
	GCMLD$	DEF$L		; DEFINE DATABASE OFFSETS
	LDR0$	GCMB		; LOAD R0 WITH THE ADDRESS OF THE DATABASE
	CMOV$B	TSUB,G.TIOS	; UPDATE TERMINAL I/O SUBFUNCTION
	CMOV$B	TVFC,G.TIOP+1	; UPDATE TERMINAL VFC
	CMOV$B	TTMO,G.TIOP+0	; UPDATE TIMEOUT COUNT
	CMOV$W	FQFN,G.FQFN	; FILE NAME BUFFER RETURN
	CMOV$B	OVBC,G.OVBC	; SET OVERRIDE BUFFER COUNT

	.ENDM
;
; CMGET$ -- OBTAIN CONTENTS OF FIELDS IN GCML INPURE AREA
;
	.MACRO CMGET$	GCMB,TERM,FILE,FQFN,OVBC,ERR
	.MCALL LDR0$,CGET$B,CGET$W,GCMLD$
	GCMLD$	DEF$L		; DEFINE DATABASE OFFSETS
	LDR0$	GCMB		; LOAD R0 WITH THE ADDRESS OF THE DATABASE
	CGET$B	G.TERM,TERM	; OBTAIN TERMINATOR CHARACTER
	CGET$W	G.FILE,FILE	; OBTAIN FILE DATABASE ADDRESS
	CGET$B	G.ERR,ERR	; OBTAIN ERROR CODE
	CGET$W	G.FQFN,FQFN	; OBTAIN FILE NAME BUFFER ADDRESS
	CGET$B	G.OVBC,OVBC	; OBTAIN OVERRIDE BUFFER COUNT

	.ENDM


	.MACRO EGCMI$
	.ENDM

	.ENDM
