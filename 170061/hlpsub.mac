	.TITLE	HELP - HELP COMMAND SUBROUTINE
	.IDENT	/V01.04/
;
; COPYRIGHT (C) 1979, 1980, 1981 BY
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;
;
; MODULE DESCRIPTION:
;
;	HELP FILE SEARCHING AND DISPLAY ROUTINES
;
;
;
; DISTRIBUTED SYSTEMS SOFTWARE ENGINEERING
;
; IDENT HISTORY:
;
; 1.00	14-DEC-79
;	DECNET-11M/S V3.0
;	DECNET-11M-PLUS V1.0
;
; 1.01	6-MAR-80	J.A. SCHRIESHEIM
;	ADDED STRING SYNONYMS, MATCH-ANY KEYWORDS AND
;	UNIVERSAL LIBRARY SUPPORT.
;
; 1.02	10-MAR-80
;	ADDED "/CHAIN" SWITCH TO ALLOW MULTI LEVEL ACCESS
;	TO INDIRECT FILES.
;
; 1.03	14-MAR-80
;	CHANGED INDIRECT FILE HANDLING TO BE NESTED FILES,
;	WHICH RETURN TO CALLING FILE ON EOF.
;
; 1.04	28-OCT-81	J.M. KINNEAR
;	ADDED PSECT DEFINITIONS FOR I/D SPACE


	.SBTTL MACRO CALLS AND LOCAL DATA
;
; MACRO LIBRARY CALLS
;
	.MCALL	DIR$,QIOW$,FCSMC$,CALLR
	.MCALL	CSI$,CSI$1,CSI$2,NMBLK$						
	.MCALL	CSI$SW,CSI$ND,CSI$SV
	.MCALL	.PDATA,.PCODE
	FCSMC$		; DEFINE FCS MACROS
	CSI$		; DEFINE CSI OFFSETS
	.NLIST	BEX
	.ENABL	LC

	FILDEP=3	; DEPTH OF NESTED INDIRECT FILES ALLOWED

	.PDATA		; PURE DATA PSECT

;
; ERROR MESSAGES
;
ER1:	.ASCIZ	<15>/??? -- HELP file nesting depth exceeded/
ER2:	.ASCII	<15>/??? -- HELP file error /
ER2NUM:	.ASCIZ	/-NNNNN/
ER3:	.ASCIZ	<15>/??? -- Ambiguous HELP qualifier/
ER4:	.ASCIZ	<15>/??? -- Improper HELP file format/
ER5:	.ASCIZ	<15>/??? -- Unknown HELP qualifier/
ER6:	.ASCIZ	<15>/??? -- Indirect HELP file syntax error/
ER7:	.ASCII	<15>/??? -- Indirect HELP file open error /
ER7NM:	.ASCIZ	/-NNNNN/
ER8:	.ASCIZ	<15>/??? -- HELP synonym not found/
ER9:	.ASCIZ	<15>/??? -- Ambiguous HELP synonym/
	.EVEN
;
; LOCAL DATA
;
ODPB:	QIOW$	IO.WVB,$HLUN2,$HEFN,,,,<0,0,40> ; OUTPUT DPB
CSIBLK:	.BLKB	C.SIZE		; ALLOCATE CSI BLOCK
	SW$LB=1			; "/LB" SWITCH VALUE
	SW$CH=2			; "/CH" SWITCH VALUE
CSITAB:	CSI$SW	LB,SW$LB,,,,LBTAB ; CSI SWITCH TABLE FOR "/LB:MODULE"
	CSI$SW	CH,SW$CH	  ; CSI SWITCH TABLE FOR "/CH" (CHAIN)
	CSI$ND			; END OF TABLE
LBTAB:	CSI$SV	ASCII,MODNAM,6	; SWITCH VALUE FOR PARSING MODULE NAME
	CSI$ND			; END OF TABLE
DEFINM:	NMBLK$			; ALLOCATE DEFAULT FILENAME BLOCK		
FNBLEN	=.-DEFINM		; LENGTH OF FILENAME BLOCK
FDBSAV:	.BLKW	7		; FDB SAVE AREA
BUFFPT:	.BLKW	1		; SAVED POINTER TO USER'S COMMAND LINE
INDFLG:	.BYTE	0		; INDIRECT FILE FLAG -				
				; INDFLG = 0 INDIRECT FILE SPECS IGNORED	
				; INDFLG > 0 FILE SHOULD BE USED		
SYNFLG:	.BYTE	0		; SYNONYM FLAG - INITIALLY ZERO
				; 0 = "#" SYNONYM RECOGNITION DISABLED
				; 1 = RECOGITION ENABLED, "#" NOT FOUND
				; 2 = "#" SYNONYM FOUND, RECOGITION DISABLED
WLDFLG:	.BYTE	0		; WILD CARD SYNONYM FLAG
				; 0 = KEYWORD RECORD MATCHED EXACTLY
				; ELSE, KEYWORD RECORD WAS A WILDCARD
R4FLG:	.BYTE	0		; R4 USAGE FLAG - R4 POINTS TO ...
				; ... KEYWORD IN COMMAND LINE, IF R4FLG=0
				; ... KEYWORD IN SYNBUF, IF R4FLG=1
SAVER4:	.WORD	0		; IF R4FLG=1, SAVER4 = COMMAND LINE PTR
SPSAV:	.BLKW	1		; SAVED STACK POINTER
MARKSV:	.BLKW	6		; STORAGE FOR SAVING .POINT REGISTERS
DEPTH:	.BLKW	1		; KEYWORD DEPTH LEVEL
FILESP:	.BLKW	1		; NESTED INDIRECT FILE CONTEXT STACK POINTER
FILSTK:	.BLKW	8.*FILDEP	; NESTED INDIRECT FILE CONTEXT STACK
HLPBUF:	.BLKB	134.		; HELP FILE RECORD: 132+2 FOR COBOL CARR
MODNAM:	.ASCII	/.MAIN./	; LIBRARY MODULE NAME (DEFAULT=.MAIN.)
SPACE:	.ASCII	/ /		; LINE TO OUTPUT FOR 0 LENGTH HELP FILE RECORD
STRBUF:	.BLKB	134.		; STRING SYNONYM BUFFER
	.EVEN
;
; THE NEXT TWO LINES MUST REMAIN CONTIGUOUS
;
ULABLK:	.BLKW	2		; ULB ACCESS BUFFER - (USES SYNBUF AS WELL)
SYNBUF:	.BLKB	80.		; SYNONYM BUFFER
	.EVEN
	.LIST	BEX

	.PCODE			; PURE CODE PSECT


	.SBTTL	HELP - PROCESS HELP COMMAND
;+										
; *** - $HELP  -  PRINT OUT THE DESIRED PART OF THE HELP FILE			
;										
; HELP RECOGNIZES COMMAND LINES OF THE FORM:					
;	HELP									
;	HELP KEY1 KEY2 ... KEY9							
; WHERE KEY1, KEY2, ... KEY9 ARE KEYWORDS (STRINGS OF CHARACTERS		
; SEPARATED BY BLANKS OR TABS).  THE EFFECT IS TO DISPLAY A SECTION
; THE HELP FILE.  WHEN TYPING A KEYWORD, IT IS NECESSARY TO TYPE
; ONLY THE MINIMUM NUMBER OF INITIAL CHARACTERS THAT UNAMBIGUOUSLY		
; DIFFERENTIATE THE KEYWORD FROM ALL OTHER KEYWORDS OF LEVEL N IN		
; THE HELP FILE.
;										
; HELP FILES ARE STRUCTURED IN A RIGIDLY NESTED FASHION. THEY ARE COMPOSED
; OF KEYWORD RECORDS (LINES) AND BLOCKS OF TEXT.  A KEYWORD RECORD		
; HAS A DIGIT (1-9) AS ITS FIRST CHARACTER, FOLLOWED BY AN ARBITRARY		
; NUMBER OF BLANKS AND TABS, FOLLOWED BY A KEYWORD.  A KEYWORD IS A		
; STRING OF UPPER-CASE LETTERS AND NON-LOWER-CASE CHARACTERS.  A BLOCK		
; OF TEXT IS A SERIES OF LINES EACH OF WHICH DO NOT BEGIN WITH A DIGIT.		
; FOR COMPATIBILITY WITH THE DCLS IMPLEMENTATION, THEY SHOULD BEGIN ONLY	
; WITH A TAB OR BLANK.  A KEYWORD LINE OR TEXT LINE CAN BE UP TO 132.		
; CHARACTERS LONG.  IF A KEYWORD BEGINS WITH A $ OR A /, THE $ OR /		
; IS IGNORED.									
;										
; THE GENERAL HELP FILE ORGANIZATION IS A BLOCK OF TEXT, WHICH
; BEGINS WITH A LINE THAT WILL NOT BE DISPLAYED (GENERALLY BLANK) AND		
; IS DISPLAYED IF THERE ARE NO KEYWORDS, FOLLOWED BY AN ARBITRARY		
; NUMBER OF GROUPS COMPOSED OF A KEYWORD RECORD AND A BLOCK OF TEXT.		
; THE COMMAND LINE IS SCANNED FOR KEYWORDS.  IF KEY1 EXISTS, THE FILE
; IS SEARCHED FOR THE KEYWORD RECORD "1 KEY1".  IF KEY2 DOES NOT EXIST,		
; THE BLOCK OF TEXT AFTER THE KEYWORD RECORD IS DISPLAYED.  IF KEY2		
; DOES EXIST, THE GROUPS AFTER "1 KEY1" AND BEFORE THE NEXT LEVEL 1		
; KEYWORD RECORD ARE SEARCHED FOR THE KEYWORD RECORD "2 KEY2".  IF THE
; KEYWORD IN THE KEYWORD RECORD IS "*", THEN THE RECORD MATCHES ALL USER
; KEYWORDS AND THAT TRANSITION IS ALWAYS TAKEN. THE PROCESS CONTINUES
; FOR THE N KEYWORDS.
;										
; THE FOLLOWING IS AN EXAMPLE OF THAT GENERAL ORGANIZATION:			
;										
;   BLOCK OF TEXT (BEGINNING WITH A BLANK LINE)					
;  1 KEY1									
;   BLOCK OF TEXT1								
;  1 KEY2									
;   BLOCK OF TEXT 2								
;  2 KEY3									
;   BLOCK OF TEXT3								
;  2 KEY4									
;   BLOCK OF TEXT4								
;  3 KEY5									
;   BLOCK OF TEXT5								
;  2 *
;   BLOCK OF TEXT6								
;										
; LEGAL COMMANDS ARE:								
;	HELP - BLOCK OF TEXT IS DISPLAYED					
;	HELP KEY1 - BLOCK OF TEXT1 IS DISPLAYED					
;	HELP KEY2 - BLOCK OF TEXT2 IS DISPLAYED					
;	HELP KEY2 KEY3 - BLOCK OF TEXT3 IS DISPLAYED				
;	HELP KEY2 KEY4 - BLOCK OF TEXT4 IS DISPLAYED				
;	HELP KEY2 KEY4 KEY5 - BLOCK OF TEXT5 IS DISPLAYED			
;	HELP KEY2 XXXX  - BLOCK OF TEXT6 IS DISPLAYED				
;										
; NOTE THAT TWO KEYWORDS CAN BE IDENTICAL (E.G., KEY2 AND KEY3) AS		
; LONG AS THEY DO NOT HAVE THE SAME LEVEL NUMBER (E.G., KEY3 AND KEY4).
;										
; INDIRECT FILES:								
;										
; THE HELP FILE MAY CONTAIN INDIRECT REFERENCES TO OTHER FILES.  AN "AT"	
; SIGN AS THE FIRST NON-BLANK IN A LINE INDICATES THAT A FILE SPECIFI-		
; CATION WILL FOLLOW, EG. @[200,200]NEWFEATURE.EXT.  THIS PERMITS THE		
; USER TO REFER TO FILES CONTAINING LARGE BLOCKS OF TEXT AND 			
; HIGHER-LEVEL KEYWORDS, THUS SPEEDING SEARCH TIME AND ENABLING MORE		
; FLEXIBLE USE OF THE HELP FILE.						
;										
; EXAMPLES OF PROPER USAGE FOLLOW:						
;										
; (1)				    ! (2)					
; N KEY1			    ! N KEY1					
;  @INDFL.EXT ---> FILE INDFL.EXT:  !  TEXT1A					
; N KEY2	    TEXT1	    !  @INDFL.EXT ---> FILE INDFL.EXT:		
;  TEXT2			    ! N KEY2	        TEXT1B			
;				    !  TEXT2					
; (3)										
; N KEY1									
;  @INDFL.EXT ---> FILE INDFL.EXT:						
; N KEY2	    TEXT1							
;  TEXT2	   N+1 KEY1.1							
; N KEY3	    TEXT1.1							
;  TEXT3	   N+1 KEY1.2							
;		    TEXT1.2							
;		   ... KEYWORDS AND						
;		    TEXT OF LEVEL N+1 OR MORE					
;										
; IN AN INDIRECT FILE SPEC., ANY FIELDS WHICH THE USER DOES NOT PROVIDE		
; WILL DEFAULT TO THOSE OF THE HELP FILE PRESENTLY OPEN. (EXCEPTION:		
; AN ABSENT VERSION NUMBER BECOMES 0 - THE LATEST VERSION.)			
; E.G., IF SY0:[1,2]HELP.TXT;3 HAS A REFERENCE TO [200,200]MYFIL, THEN		
; HELLO WILL TRY TO OPEN FILE SY0:[200,200]MYFIL.TXT;0.				
;										
; INDIRECT FILES MAY REFER TO OTHER INDIRECT FILES TO A DEPTH OF "FILDEP"
;										
; SYNONYMS:									
;										
; TWO OR MORE KEYS MAY BE RELATED BY A "SYNONYM" FEATURE.  A SYNONYM KEY	
; HAS NO TEXT OR HIGHER LEVEL KEYS; IT REFERS TO A LATER KEY FOR THESE.		
; IN PLACE OF A TEXT, THE LINE AFTER A SYNONYM KEY CONTAINS A POUND		
; SIGN PRECEDING THE NAME OF THE KEY REFERED TO. THE KEY REFERED TO MUST	
; HAVE THE SAME LEVEL NUMBER AS THE SYNONYM KEY, AND MUST SUCCEED THE 		
; SYNONYM KEY IN THE SAME FILE.  THESE KEYS MUST NOT BE SEPARATED BY A		
; LOWER LEVEL KEYWORD.  EXAMPLES:						
;										
; (1)				    ! (2)					
; N KEY1			    ! N KEY1					
;  #KEY7			    !  #KEY3					
; N KEY2			    ! N KEY2					
;  TEXT2			    !  #KEY3					
; ...ETC...			    ! N KEY3					
; N KEY7			    !  TEXT3					
;  TEXT7			    ! N+1 KEY 3.1				
;				    !  TEXT3.1					
; 				    !						
; KEY1 AND KEY7 BOTH REFER TO	    ! KEY1, KEY2, AND KEY3 ALL REFER TO		
; TEXT7.			    ! TEXT3, AND ALL CAN USE KEY3.1.		
;										
; IN (1) ABOVE, THE "...ETC..." MUST NOT INCLUDE A KEY OF LEVEL N-1 OR		
; LESS.										
;										
;
; STRING SYNONYMS:
;
; A STRING CAN BE DEFINED AS A SYNONYM FOR A USER-SUPPLIED HELP COMMAND.
; WHEN THE STRING SYNOMYM SYMBOL IS ENCOUNTERED FOLLOWING A KEYWORD, THE
; HELP PROCESSING IS RESTARTED FROM THE BEGINNING USING THE STRING SUPPLIED
; IN THE HELP FILE. FOR EXAMPLE, IF THE USER TYPES:
;
;   >XXX HELP KEY1 KEY2 ETC....
;
; AND THE FILE CONTAINS:
;
;   1 KEY1
;   2 KEY2
;    =NEW STRING
;
; THEN THE HELP COMMAND WILL BE PROCESSES AS IF THE USER HAD TYPED:
;
;   >XXX HELP NEW STRING
;
;										
; INPUTS:									
;	R4     -> ADDRESS OF FIRST CHARACTER PAST "HELP" IN COMMAND LINE		
;	$HLUN1 =  LUN TO BE USED FOR OPENING HELP FILES
;	$HLUN2 =  LUN TO BE USED FOR TERMINAL OPERATIONS (DISPLAY AND ERRORS)
;	$HEFN  =  EVENT FLAG TO BE USED FOR SYNCHRONIZING I/O
;	$HFDB  =  FDB TO BE USED FOR OPENING HELP FILE
;	$HDSP  =  DATASET DESCRIPTOR FOR HELP FILE
;	$HNAME =  3 ASCII CHARS USED TO PREFACE ERROR MESSAGES
;	$HMOD  =  RAD50 UNIVERSAL LIBRARY MODULE NAME FOR LEVEL 0 HELP
;										
; OUTPUTS:									
;	THE DESIRED PART OF THE HELP FILE IS COPIED TO TI:			
;	ALL REGISTERS ARE PRESERVED
;	NO ERRORS ARE RETURNED
;-										
 										
$HELP::	CALL	$SAVAL		; SAVE ALL REGISTERS
	MOV	R4,BUFFPT	; SAVE POINTER TO COMMAND LINE
	MOV	SP,SPSAV	; SAVE STACK POINTER
	MOV	#FILSTK,FILESP	; RESET NESTED FILE CONTEXT STACK
	MOV	$HDSP,R1	; SET DATASET DESCRIPTOR
	CLR	R2		; NO DEFAULT NAME BLOCK
	MOV	$HMOD,ULABLK	; SET MODULE NAME (IF ULB)
	MOV	$HMOD+2,ULABLK+2; ...
	CALL	OPEN		; TRY TO OPEN FILE
	BCC	10$		; CC- OK.					
5$:	CALLR	FILERR		; ERROR!					
10$:	MOV	#IO.ATT,ODPB+Q.IOFN ; SET ATTACH FUNCTION
	DIR$	#ODPB		; ATTACH TI:
13$:	CALL	MARK1		; MARK ITS POSITION				
	MOV	#'0,DEPTH	; START LOOKING FOR LEVEL 1 KEYWORDS		
	CLRB	INDFLG		; DO NOT USE INDIRECT FILES UNTIL A		
				;   KEYWORD MATCH IS FOUND.			
20$:	CALL	TSTERM		; LOOK FOR TERMINATOR
	BCS	35$		; IF CS, NOT AT A TERMINATOR
30$:	TSTB	(R4)+		; FOUND LAST KEYWORD?				
	BEQ	TEXT		; COPY HELP FILE TO TI: UNTIL A			
				; KEYWORD RECORD IS FOUND			
35$:	INC	DEPTH		; NEW KEYWORD IMPLIES A NEW DEPTH		
40$:	CALL	NXTREC		; DOES A KEYWORD RECORD WITH THAT		
				; LEVEL (DEPTH) EXIST?				
	BCS	90$		; NO, THE KEYWORD IS UNKNOWN			
	CALL	COMPAR		; COMPARE RECORD KEYWORD AND USER KEYWORD	
	BCS	40$		; NO MATCH.  TRY ANOTHER RECORD.		
;										
;	KEYWORD AMBIGUITY TEST: LOOK AT NEXT KEYWORD OF SAME LEVEL FOR		
;	POTENTIAL AMBIGUITY.  IF A NEARLY DUPLICATE KEY IS FAR AHEAD,		
;	IT WILL NEVER BE RECOGNISED.  THIS MAY BE AVOIDED BY SORTING		
;	EQUAL LEVEL KEYS IN ALPHA ORDER.  HOWEVER, WE DO NOT WANT TO		
;	FOLLOW INDIRECT FILES IN THE AMBIGUITY SEARCH - THE CURRENT FILE	
;	WOULD BE LOST.  HENCE, A NEARLY DUPLICATE KEY IN ANOTHER FILE		
;	WILL BE IGNORED.							
;										
	CALL	MARK2		; WE WILL .POINT IF NO AMBIGUITY EXISTS		
50$:	MOVB	#1,SYNFLG	; ENABLE SYNONYM SEARCH IN NXTREC		
	CLRB	INDFLG		; DISABLE INDIRECT FILE PROCESSING		
	CALL	NXTREC		; DOES ANOTHER KEYWORD RECORD EXIST?		
	BCS	60$		; NO, MAY WANT TO PRINT THE LAST SECTION	
	MOV	R0,R3		; SAVE HELP FILE KEYWORD ADDRESS AND		
	MOV	R1,R5		;    LENGTH FOR SYNSCH.				
	CALL	COMPAR		; FOUND A DUPLICATE KEYWORD?			
	BCS	55$		; NO, NON-AMBIGUOUS KEYWORD
	TSTB	WLDFLG		; ELSE, WAS THE KEYWORD RECORD A WILD CARD ?
	BEQ	100$		; NO, KEYWORD IS AMBIGUOUS			
55$:	CMPB	#2,SYNFLG	; WAS A SYNONYM REQUESTED?			
	BNE	65$		; NO						
	CALL	SYNSCH		; YES - SEARCH HELP FILE FOR IT			
	BR	50$		; TEST FOR AMBIGUITY & ANOTHER SYNONYM		
60$:	CMPB	#2,SYNFLG	; WAS A SYNONYM REQUESTED?			
	BNE	65$		; NO - OK					
	CALLR	SYNERR		; YES - BUT NO MORE KEYWORDS EXISTS		
65$:	TSTB	R4FLG		; IS THE COMMAND LINE POINTER SAVED?		
	BEQ	70$		; NO						
	MOV	SAVER4,R4	; RESTORE IT					
	CLRB	R4FLG		; FLAG ACCORDINGLY				
70$:	MOV	#MARKSV,R1	; REMEMBER WHERE TEXT STARTS THAT IS		
	MOV	#3*2+MARKSV,R2	; ASSOCIATED WITH THIS KEYWORD RECORD.		
	MOV	(R2)+,(R1)+	;						
	MOV	(R2)+,(R1)+	;						
	MOV	(R2),(R1)	;						
	CALL	POINT		; START NEXT KEYWORD SEARCH AFTER		
				; LAST GOOD KEYWORD RECORD			
	CALL	PUSH		; POINT PAST MATCHED USER KEYWORD		
	INCB	INDFLG		; ENABLE INDIRECT FILE PROCESSING FOR		
				;    NEXT KEYWORD SEARCH.			
	BR	20$		; SEE IF MORE KEYWORDS				
90$:	MOV	#ER5,R0		; UNKNOWN KEYWORD				
	CALL	PUSH		; POINT AFTER UNKNOWN KEYWORD			
	MOV	R4,R3		; SAVE R4					
95$:	CALL	ERROR		; PRINT ERROR MESSAGE
	MOV	BUFFPT,R4	; POINT TO COMMAND LINE
	CALL	TSTERM		; LOOK FOR LEADING SPACES
	BCS	97$		; IF CS, NO  SPACES
	INC	R4		; SKIP OVER SPACE OR TAB
97$:	MOV	R4,R0		; COPY POINTER
	MOV	R3,R1		; POINT TO END OF LINE
	SUB	R0,R1		; FORM NUMBER OF CHARS TO ERROR			
	CALLR	HLPERR		; PRINT LINE IN ERROR AND GET OUT		
100$:	MOV	R1,R3		; SAVE ADDRESS OF HELP LINE IN ERROR		
	TSTB	R4FLG		; IS THE AMBIGUITY IN A SYNONYM KEY?		
	BNE	110$		; YES						
	MOV	#ER3,R0		; NO - NORMAL KEY				
	BR	95$		;						
110$:	MOV	#ER9,R0		; AMBIGUOUS SYNONYM ERROR MESSAGE		
	CALL	ERROR		; WRITE ERROR MESSAGE				
	MOV	#SYNBUF,R0	; MOVE SYNONYM ADDRESS				
	CALL	WRIT		; PRINT IT 
	CALLR	EXIT		; DETACH TI: AND RETURN


	.SBTTL	TEXT - DISPLAY PORTION OF HELP FILE
;+
; *** - TEXT - DISPLAY PORTION OF HELP FILE ON TI:
;	       (OR TO AN OPEN FILE).
;
; INPUT:
;	$HFDB+2 - IF   0, DISPLAY TEXT TO TI:
;		- IF <>0, USE AS ADDRESS OF FDB TO FILE TO
;			  PUT HELP TO.
;
; OUTPUT:
;	PORTION OF HELP FILE WRITTEN
;
;-
	
TEXT:	CALL	POINT		; POINT AT FIRST RECORD TO COPY TO TI:		
	INCB	INDFLG		; ANY INDIRECT FILE SPEC IS NOW USEFUL		
10$:	GET$	$HFDB,#HLPBUF,#134. ; GET THE NEXT HELP FILE RECORD		
	BCC	15$		; IF CC, GOT IT
	CALL	FILPOP		; ELSE, TRY TO OPEN PREVIOUS LEVEL FILE
	BCS	60$		; IF CS, COULDN'T - RETURN
	BR	10$		; ELSE, GET A RECORD
15$:	MOV	F.NRBD(R0),R1	; GET LENGTH OF RECORD				
	BNE	20$		; IF NE, PRINT IT
	MOV	#SPACE,R0	; ELSE, PRINT A LINE WITH 1 SPACE
	INC	R1		; ...
	BR	30$		; ...
20$:	MOV	F.NRBD+2(R0),R0	; POINT AT FIRST CHARACTER OF RECORD		
	CALL	ISREC		; IS THIS A KEYWORD RECORD?			
	BCC	60$		; YES, DONE COPYING RECORDS TO TI:		
	CALL	ISINDR		; IS THIS AN @INDIRECT FILE?			
	BCS	10$		; YES, NEED TO GET A RECORD			
30$:

	TST	$HFDB+2		; ARE WE WRITTING TO A FILE ?
	BEQ	40$		; IF EQ, NO - USE QIO TO TI:
	MOV	R0,R2		; COPY RECORD ADDRESS
	PUT$	$HFDB+2,R2,R1	; ELSE, PUT THE RECORD IN THE FILE
	MOV	R2,R0		; RESTORE RECORD ADDRESS
	BR	50$		; ...


40$:	CALL	WRIT2		; COPY THE RECORD TO TI:			
50$:	BCC	10$		; IF EVERYTHING WENT OKAY, SEE IF		
				; THE NEXT LINE SHOULD BE COPIED		
60$:	CALLR	EXIT		; CLOSE FILE AND RETURN


	.SBTTL	NXTREC - GET TNE NEXT HELP RECORD
;+										
; *** -  NXTREC  -  GET THE NEXT HELP FILE RECORD OF THE SAME LEVEL		
;		    AS THE USER KEYWORD						
;										
; INPUT:									
;	DEPTH - USER KEYWORD LEVEL						
;										
; OUTPUT:									
;	CARRY CLEAR - NEXT HELP FILE RECORD OF THE SAME LEVEL AS THE		
;			USER KEYWORD IS IN HLPBUF				
;		R0 - ADDR OF FIRST CHAR IN NEXT HELP FILE RECORD OF		
;			THE SAME LEVEL AS THE USER KEYWORD			
;		R1 - SIZE OF RECORD						
;	CARRY SET - NO MORE RECORDS IN FILE OR FOUND A RECORD WITH A		
;			LEVEL NUMBER LESS THAN THAT OF THE USER KEYWORD		
;	R4, R5 - PRESERVED							
;	IF SYNONYM RECOGITION IS ENABLED, A SYNONYM MAY BE SAVED.		
;-										
 										
NXTREC:	GET$	$HFDB,#HLPBUF,#134. ; GET NEXT RECORD				
	BCC	5$		; IF CC, GOT ONE
	TSTB	INDFLG		; SHOULD WE FOLLOW INDIRECT FILES ?
	SEC			; ASSUME NO
	BEQ	20$		; IF EQ, NO
	CALL	FILPOP		; ELSE, ATTEMPT TO OPEN PREVIOUS LEVEL
	BCS	20$		; FILE OPEN ERROR, RETURN
	BR	NXTREC		; ELSE, GET A RECORD FROM THE NEW FILE
5$:	MOV	F.NRBD(R0),R1	; SAVE LENGTH OF RECORD				
	BEQ	NXTREC		; IGNORE ZERO LENGTH RECORDS			
	MOV	F.NRBD+2(R0),R0	; POINT AT FIRST BYTE OF RECORD			
	CMPB	#1,SYNFLG	; ARE SYNONYM SEARCHES ENABLED?			
	BNE	10$		; NO						
	CALL	SYNSAV		; SAVE SYNONYM IF "#" ENCOUNTERED		
10$:	CALL	ISINDR		; IS THIS AN @INDIRECT FILE?			
	BCS	NXTREC		; YES - NEED TO GET A RECORD			
	CALL	ISREC		; IS THIS RECORD A KEYWORD RECORD?		
	BCS	NXTREC		; NO, IGNORE THE RECORD				
	CMPB	(R0),DEPTH	; COMPARE IT WITH USER KEYWORD LEVEL		
	BHI	NXTREC		; IT IS GREATER THAN DEPTH (C=0)		
20$:	RETURN			;						


	.SBTTL	COMPAR - COMPARE USER KEYWORK WITH HELP FILE KEY 								
;+										
; *** - COMPAR  -  COMPARE USER KEYWORD WITH HELP FILE KEYWORD			
;										
;	A KEYWORD MATCH MEANS THAT WE ARE IN HOT PURSUIT OF THE DESIRED		
;	TEXT - INDIRECT FILE LOOKUPS ARE ENABLED.  IF NO MATCH, AN 		
;	INDIRECT FILE SPEC REFERS TO THE WRONG KEYWORD'S TEXT -			
;	INDIRECT FILE LOOKUPS ARE DISABLED.					
;										
; INPUT:									
;	R0 - POINTS TO LEVEL (FIRST CHARACTER) OF HELP FILE KEYWORD		
;		RECORD								
;	R1 - LENGTH OF HELP FILE KEYWORD RECORD					
;	R4 - POINTS AT FIRST CHARACTER OF CURRENT USER KEYWORD			
;										
; OUTPUT:									
;	C=0 ,INDFLG>0 - USER KEYWORD AND HELP FILE KEYWORD MATCH		
;	     WLDFLG=0 - HELP FILE KEYWORD IS EXACT MATCH
;	     WLDFLG=1 - HELP FILE KEYWORD IS WILDCARD
;	C=1 ,INDFLG=0 - USER KEYWORD AND HELP FILE KEYWORD DO NOT MATCH		
;	R1 - ADDRESS OF CHARACTER IN USER KEYWORD WHERE SCAN STOPPED		
;	R3, R4, R5 - PRESERVED							
;-										
 										
COMPAR:	MOV	R4,-(SP)	; SAVE R4					
	CLRB	WLDFLG		; ASSUME NO WILD CARD MATCH
	INCB	INDFLG		; ASSUME FOR NOW THAT INDIRECT FILE		
				;   SPECS SHOULD BE RECOGNISED.			
10$:	INC	R0		; POINT PAST RECORD LEVEL CHARACTER		
	DEC	R1		; REDUCE COUNT OF CHARS LEFT IN RECORD		
	BNE	30$		; IF NE, MORE CHARS
20$:	CMP	(SP)+,(SP)+	; POP RETURN ADDR AND SAVED R4			
	MOV	#ER4,R0		; IMPROPER HELP FILE FORMAT			
	CALL	ERROR		;						
	MOV	$HFDB,R0	; GET COMMAND ADDRESS AND LENGTH
	MOV	F.NRBD(R0),R1	; ...
	MOV	F.NRBD+2(R0),R0	; ...
	CALLR	HLPERR		; PRINT LINE AND EXIT
30$:	CMPB	#40,(R0)	; SKIP BLANKS AND TABS IN HELP FILE		
	BEQ	10$		;						
	CMPB	#11,(R0)	;						
	BEQ	10$		;						
	CMPB	#'*,(R0)	; IS FIRST NONBLANK CHAR OF RECORD
				; KEYWORD A *?
	BNE	32$		; NO, MATCH SPECIFIC KEYWORD
	DEC	R1		; IS IT THE ONLY CHAR ON THE LINE ?
	BNE	32$		; NO, NOT A "MATCH ANY" KEYWORD
	INCB	WLDFLG		; ELSE INDICATE WILDCARD MATCH
	CALL	PUSH		; GET TO END OF USER KEYWORD
	BR	60$		; AND RETURN
32$:	CMPB	#'$,(R0)	; IS FIRST NONBLANK CHAR OF RECORD		
				; KEYWORD A $?					
	BEQ	35$		; YES, IGNORE IT				
	CMPB	#'/,(R0)	; IS FIRST NONBLANK CHAR OF RECORD		
				; KEYWORD A /?					
	BNE	40$		; NO						
35$:	INC	R0		; IGNORE THE $ OR /				
	DEC	R1		; ANY CHARACTERS LEFT IN RECORD?		
	BEQ	20$		; NO, IMPROPER HELP FILE FORMAT			
40$:	CMPB	#'/,(R4)	; IS FIRST CHAR OF USER KEYWORD A /?		
	BNE	45$		; YES						
	INC	R4		; NO, IGNORE THE /				
45$:	CMPB	(R0)+,(R4)+	; ARE THE NEXT TWO CHARS THE SAME?		
	BNE	50$		; NO						
	CALL	TSTERM		; SEEN ALL OF USER KEYWORD?			
	BCC	60$		; YES, DECLARE A MATCH				
	DEC	R1		; ALL OF HELP FILE KEYWORD SEEN?		
	BNE	45$		; NO, KEEP TRYING				
50$:	CLRB	INDFLG		; IGNORE INDIRECT FILE SPECS 			
	SEC			; SHOW NO MATCH					
60$:	MOV	R4,R1		; SAVE HOW FAR WE GOT INTO USER KEYWORD		
	MOV	(SP)+,R4	; RESTORE R4					
	RETURN			;						
 										


	.SBTTL	TSTERM - TEST IF CHARACTER IS A TERMINATOR 									
;+										
; *** - TSTERM  -  TEST IF A CHARACTER IS A TERMINATOR				
;
;	IF CHARACTER IS A TERMINATOR, SKIP OVER POSSIBLE MULTIPLE
;	TERMINATORS (MULTIPLE SPACES OR TABS).
;										
; INPUT:									
;	R4 - ADDRESS OF CHARACTER TO BE TESTED					
;										
; OUTPUT:									
;	CARRY CLEAR - R4 DID POINT TO A TERMINATOR, AND
;	      R4 POINTS TO LAST TERMINATOR FOUND
;	CARRY SET - R4 DID NOT POINT TO A TERMINATOR, AND
;	      IS PRESERVED
;	R0, R1, R3, R5 - PRESERVED					
;-
 										
TSTERM:	MOVB	(R4),R2		; GET A CHARACTER TO TEST
	BEQ	25$		; IF EQ, AT END OF LINE - RETURN
	CALL	30$		; LOOK FOR FIRST TERMINATOR
	BCS	40$		; IF CS, NONE FOUND
10$:	INC	R4		; LOOK AT NEXT CHARACTER -
	MOVB	(R4),R2		;   FOR MULTIPLE TERMINATORS
	BEQ	25$		; IF EQ, AT END OF LINE - RETURN
	CALL	30$		; ELSE, IS THIS A TERMINATOR ?
	BCC	10$		; IF CC, YES - EXAMINE NEXT CHAR
20$:	DEC	R4		; ELSE, NO - POINT TO LAST TERMINATOR
25$:	CLC			; TELL USER AT LEAST ONE FOUND
	BR	40$		; AND RETURN
	
30$:	CMPB	#40,R2		; R2 = SPACE ?
	BEQ	40$		; YES, IT IS A TERMINATOR			
	CMPB	#11,R2		; R2 = TAB ?
	BEQ	40$		; YES, IT IS A TERMINATOR			
	SEC			; SHOW NO TERMINATOR IN R2			
40$:	RETURN			;						


	.SBTTL	OPEN - OPEN THE SPECIFIED HELP FILE
;+										
; *** - OPEN  -  OPEN THE SPECIFIED HELP FILE
;										
; INPUT:									
;	R1 - DATASET DESCRIPTOR BE USED IN FILE OPEN
;	R2 - DEFAULT FILE NAME BLOCK
;	ULABLK - RAD50 NAME OF MODULE TO BE ACCESSED (6 CHARS), 
;		 IF FILE IS A ULB. ELSE, 0.
;										
; OUTPUT:									
;	R0 - FDB ADDRESS
;	R4 - PRESERVED								
;	FDBSAV - FIRST SEVEN WORDS OF HELP FDB SAVED
;-										
 										
OPEN:	FDOP$R	$HFDB,#$HLUN1,R1,R2,#FO.RD ; SET UP OPEN SECTION OF FDB
	OPEN$R	,,,#FD.PLC,#HLPBUF,#134.   ; OPEN HELP FILE
	BCS	30$		; IF CS, RETURN WITH ERROR
10$:	MOV	R0,R1		; COPY FDB ADDRESS
	MOV	#FDBSAV,R2	; POINT TO FDBSAV AREA
	MOV	#7,R3		; SEVEN WORDS TO SAVE
20$:	MOV	(R1)+,(R2)+	; ...
	DEC	R3		; ...
	BNE	20$		; ...
	MOV	#ULABLK,R1	; POINT TO ULA CONTEXT BLOCK
	TST	(R1)		; ANY MODULE SPECIFIED ?
	BEQ	30$		; IF EQ, NO - NOT ULB
	CALL	$ULA		; ELSE, TRY TO ACCESS MODULE
30$:	RETURN


	.SBTTL	MARK - MARK THE POSITION IN THE HELP FILE 									
;+										
; *** - MARK1  -  MARK THE POSITION OF THE PART OF THE HELP FILE THAT		
;		  MAY BE COPIED TO TI: (POINT RESTORES THESE VALUES)		
; *** - MARK2  -  TEMPORARILY MARK THE PRESENT HELP FILE POSITION		
;										
; INPUT:									
;	NONE									
;										
; OUTPUT:									
;	THE REGISTERS FROM A .MARK ARE STORED IN MARKSV				
;	R4 - PRESERVED								
;-										
 										
	.ENABL	LSB								
 										
MARK1:	MOV	#MARKSV,R5	; POINT AT THE SAVE BLOCK			
	BR	10$		;						
MARK2:	MOV	#3*2+MARKSV,R5	; POINT AT THE SAVE BLOCK			
10$:	MOV	$HFDB,R0	; MARK THE CURRENT FILE POSITION		
	CALL	.MARK		;						
	MOV	R1,(R5)+	; SAVE THE REGISTERS				
	MOV	R2,(R5)+	;						
	MOV	R3,(R5)		;						
	RETURN			;						
 										
	.DSABL	LSB								


	.SBTTL	POINT - POINT TO THE SAVED FILE POSITION 									
;+										
; *** - POINT  -  POINT AT THE FILE POSITION SAVED BY MARK1			
;										
; INPUT:									
;	NONE									
;										
; OUTPUT:									
;	THE HELP FILE IS POSITIONED ACCORDING TO THE SAVED REGISTER		
;		VALUES IN MARKSV, MARKSV+2, MARKSV+4				
;	R4, R5 - PRESERVED							
;-										
 										
POINT:	MOV	#MARKSV,R0	; POINT AT THE REGISTER SAVE BLOCK		
	MOV	(R0)+,R1	; RESTORE THE REGISTERS				
	MOV	(R0)+,R2	;						
	MOV	(R0),R3		;						
	MOV	$HFDB,R0	; POINT AT FDB FOR HELP FILE			
	CALL	.POINT		; REPOSITION THE FILE				
	RETURN			;						


	.SBTTL	PUSH - POINT PAST CURRENT KEYWORD 										
;+										
; *** - PUSH  -  MOVE R4 PAST THE CURRENT USER KEYWORD				
;										
; INPUT:									
;	R4 - ADDRESS OF SOME CHARACTER IN CURRENT USER KEYWORD			
;		OR ADDRESS OF TERMINATOR OF CURRENT USER KEYWORD		
;										
; OUTPUT:									
;	R4 - ADDRESS OF FIRST TERMINATOR AFTER CURRENT USER KEYWORD		
;-										
 										
PUSH:	CALL	TSTERM		; R4 POINTS AT A TERMINATOR?			
	BCC	10$		; YES						
	INC	R4		; POINT AT NEXT CHARACTER			
	BR	PUSH		;						
10$:	RETURN			; 										


	.SBTTL	ISREC - CHECK FOR KEYWORK IN RECORD 										
;+										
; *** - ISREC  -  IS THE CURRENT RECORD A KEYWORD RECORD (I.E., BEGINS		
;		  WITH A DECIMAL DIGIT)?					
;										
; INPUT:									
;	R0 - ADDRESS OF FIRST CHARACTER OF CURRENT RECORD			
;										
; OUTPUT:									
;	CARRY CLEAR - THE CURRENT RECORD IS A KEYWORD RECORD			
;	CARRY SET - THE CURRENT RECORD IS NOT A KEYWORD RECORD			
;	R0, R1, R2, R3, R4, R5 - PRESERVED					
;-										
 										
ISREC:	CMPB	(R0),#'1	; IS THE FIRST CHARACTER A DIGIT?		
	BLO	10$		; NO, CARRY IS SET				
	CMPB	#'9,(R0)	; IS THE FIRST CHARACTER A DIGIT?		
10$:	RETURN			;						


	.SBTTL	ISINDR - CHECK FOR INDIRECT FILE REQUEST									
;+										
; *** -	 ISINDR  -  EXAMINE HELP FILE RECORD FOR INDIRECT FILE (@)		
;		    REQUEST.  IF FOUND, SAVE OLD HELP FILENAME AS		
;		    DEFAULT, SET UP THE NEW FILE, AND OPEN IT.			
;										
; INPUT:									
;	INDFIL - INDIRECT FILE FLAG						
;	R0 - ADDRESS OF HELP FILE RECORD					
;	R1 - LENGTH OF HELP FILE RECORD						
;										
; OUTPUT:									
;	CARRY SET - INDIRECT FILE WAS FOUND AND OPENED				
;		R0, R1, R2, R3, R5 DESTROYED					
;		R4  PRESERVED							
;	CARRY CLEAR - NO INDIRECT FILE REQUESTED				
;		R3 DESTROYED							
;		R0, R1, R2, R4 PRESERVED					
;	ERRORS MAY CAUSE TERMINATION WITHOUT RETURN				
;-										
;										
;	SCAN HELP RECORD FOR '@' AS INITIAL NON-BLANK				
;										
ISINDR:	TSTB	INDFLG		; IS INDIRECT FILE PROCESSING ENABLED?		
	BEQ	95$		; NO - RETURN C=0				
	MOV	R0,R2		; R2 IS MOVING POINTER INTO HELP LINE		
	MOV	R1,R3		; LENGTH OF HELP LINE				
	BR	9$		;						
8$:	INC	R2		;						
	DEC	R3		; ANY CHARACTERS LEFT?				
	BEQ	95$		; NO - RETURN C=0				
9$:	CMPB	#40,(R2)	; IGNORE BLANKS ...				
	BEQ	8$		;						
	CMPB	#11,(R2)	;    ... AND TABS.				
	BEQ	8$		;						
	CMPB	#'@,(R2)+	; LOOK FOR "@" AS FIRST NON-BLANK/TAB		
	BEQ	10$		; IF EQ, FOUND
95$:	CLC			; ELSE NO INDIRECT FILE - RETURN C=0	
	CALLR	100$		; ...
10$:	DEC	R3		; CORRECT LENGTH				
	MOV	R3,R1		; R1 = LENGTH OF FILENAME			
	CSI$1	#CSIBLK,R2,R1	; EXAMINE FILENAME				
	BCC	12$		; BRANCH IF FILENAME SYNTAX IS OK		
11$:	MOV	#ER6,R0		; INDIRECT FILE SYNTAX ERROR			
	CALL	ERROR		; PRINT ERROR MESSAGE				
	MOV	CSIBLK+C.FILD+2,R0 ; ADDRESS OF FILE SPEC IN ERROR		
	MOV	CSIBLK+C.FILD,R1 ; LENGTH OF FILE SPEC IN ERROR			
	CALLR	HLPERR		; PRINT THE OFFENDING SEGMENT AND RETURN
12$:	CSI$2	,OUTPUT,#CSITAB	; PARSE FILENAME				
	BCS	11$		; PARSE UNSUCCESSFUL				
14$:	BITB	#<CS.WLD!CS.MOR>,C.STAT(R0) ; ANY WILD CARDS OR			
 					    ; MULTIPLE FILES?			
	BNE	11$		; IF NE, YES - ERROR
;										
;	SAVE FDB FILE NAME BLOCK IN DEFAULT FILENAME BLOCK			
;										
	MOV	$HFDB,R0	; POINT TO FDB
	ADD	#F.FNB,R0	; BUMP TO FILE NAME BLOCK		
	MOV	#DEFINM,R1	; R1 POINTS TO DEFAULT FILE NAME BLOCK		
	MOV	#FNBLEN,R5	; BLOCK LENGTH USED AS COUNTER			
20$:	MOVB	(R0)+,(R1)+	; MOVE FNB TO DEFAULT FILE NAME 		
	DEC	R5		;						
	BGT	20$		; BRANCH IF MORE CHARACTERS			
	CLR	DEFINM+N.FVER	; VERSION ZERO IS BEST DEFAULT			
	MOV	R2,-(SP)	; SAVE FILESPEC ADDRESS
	MOV	R3,-(SP)	; ... AND LENGTH
	BIT	#SW$CH,C.MKW1+CSIBLK; CHAIN TO NEW FILE ?
	BEQ	30$		; IF EQ, NO
	MOV	#'1,DEPTH	; ELSE, NOW LOOK FOR LEVEL 1 KEYWORDS
	MOV	#FILSTK,FILESP	; RESET FILE CONTEXT STACK
	BR	35$		; AND CLOSE FILE
30$:	MOV	#ER1,R0		; ASSUME NESTING DEPTH WILL BE EXCEEDED
	CMP	FILESP,#FILSTK+<8.*<FILDEP-1>> ; ROOM ON FILE CONTEXT STACK ?
	BHI	70$		; IF HI, NO - DEPTH EXCEEDED
	CALL	FILPSH		; PUST THE CURRENT FILE CONTEXT ON THE STACK
35$:	CALL	CLOSE		; CLOSE CURRENT HELP FILE,			
	CLR	ULABLK		; ASSUME FILE IS NOT A LIBRARY
	CLR	ULABLK+2	; ...
	BIT	#SW$LB,C.MKW1+CSIBLK; WAS "/LB" SPECIFIED ?
	BEQ	50$		; IF EQ, NO
	MOV	$HFDB,R0	; ELSE, POINT TO HELP FILE FDB
	MOVB	#IE.BNM,F.ERR(R0) ; ASSUME BAD MODULE NAME
	MOV	#^R.MA,ULABLK	; DEFAULT NAME TO ".MAIN."
	MOV	#^RIN.,ULABLK+2	; ...
	MOV	#MODNAM,R0	; POINT TO MODULE NAME FROM "/LB:" SWITCH
	TST	(R0)		; WAS A NAME SPECIFIED ?
	BEQ	50$		; IF EQ, NO - USE DEFAULT
	MOV	#1,R1		; ENABLE "." AS RAD50 CHAR
	CALL	$CAT5		; CONVERT MODULE NAME TO RAD50
	MOV	R1,ULABLK	; SAVE 3 CHARS
	BCC	45$		; IF CC, 3 CHARS CONVERTED
	TST	R2		; LEGAL LAST CHAR ?
	BNE	60$		; IF NE, NO - BAD NAME
45$:	MOV	#1,R1		; ALLOW "." AS LEGAL CHAR
	CALL	$CAT5		; CONVERT TO RAD50
	MOV	R1,ULABLK+2	; SAVE LAST 3 CHARS
	BCC	50$		; IF CC, 6 CHAR NAME
	TST	R2		; ELSE WAS LAST CHAR ILLEGAL ?
	BNE	60$		; IF NE, YES - ERROR	
50$:	MOV	#CSIBLK+C.DSDS,R1 ; SET DATASET DESCRIPTOR ADDRESS
	MOV	#DEFINM,R2	; AND POINT TO DEFAULT FILENAME BLOCK
	CALL	OPEN		; TRY TO OPEN THE FILE
	BCS	60$		; IF CS, ERROR
55$:	CMP	(SP)+,(SP)+	; CLEAN FILE NAME ADDRESS AND LENGTH OFF STACK
	SEC			; INDICATE NEW FILE OPEN
	BR	100$		; AND RETURN
60$:	MOVB	F.ERR(R0),R1	; GET ERROR CODE				
	MOV	#ER7NM,R0	; GET ADDRESS OF BUFFER				
	CLR	R2		; SURPRESS LEADING ZEROES			
	CALL	$CBDSG		; CONVERT ERROR CODE				
	MOVB	#'.,(R0)+	; PUT IN DECIMAL POINT				
	CLRB	(R0)		; NULL SIGNALS END OF LINE			
	MOV	#ER7,R0		; ADDRESS OF ERROR MESSAGE			
70$:	CALL	ERROR		; WRITE MESSAGE					
	MOV	(SP)+,R1	; LENGTH OF FILE SPEC
	MOV	(SP)+,R0	; ADDRESS OF FILE SPEC IN HELP LINE		
	CALLR	HLPERR		; PRINT THE OFFENDING SEGMENT
100$:	RETURN			;


	.SBTTL	FILPSH - SAVE FILE CONTEXT ON FILE STACK
;+										
; *** -	 FILPSH  -  SAVE A FILE'S CONTEXT ON THE FILE STACK.
;										
; INPUT:									
;	FILESP - FILE STACK POINTER
;										
; OUTPUT:									
;	FILESP - UPDATED STACK POINTER
;	CONTEXT SAVED ON STACK:
;		FILE ID
;		FILE SEQUENCE NUMBER
;		DEVICE NAME
;		DEVICE UNIT NUMBER
;		MODULE NAME (2 RAD50 WORDS, OR 0)
;		LOW ORDER VIRTUAL BLOCK NUMBER
;		BYTE WITHIN BLOCK
;-										

FILPSH:	MOV	$HFDB,R0		; POINT TO HELP FILE FDB
	CALL	.MARK			; MARK CURRENT POSITION IN FILE
	MOV	FILESP,R1		; GET STACK POINTER
	MOV	R2,(R1)+		; SAVE LOW ORDER VIRTUAL BLOCK NUMBER
	MOV	R3,(R1)+		; ... BYTE WITHIN BLOCK
	MOV	ULABLK+2,(R1)+		; ... 2ND WORD OF MODULE NAME
	MOV	ULABLK,(R1)+		; ... 1ST WORD OF MODULE NAME
	MOV	F.FNB+N.UNIT(R0),(R1)+	; ... DEVICE UNIT NUMBER
	MOV	F.FNB+N.DVNM(R0),(R1)+	; ... DEVICE NAME
	MOV	F.FNB+N.FID+2(R0),(R1)+	; ... SEQUENCE NUMBER
	MOV	F.FNB+N.FID(R0),(R1)+	; ... FILE ID
	MOV	R1,FILESP		; SET NEW STACK POINTER
	RETURN


	.SBTTL	FILPOP - OPEN FILE AND RESTORE CONTEXT
;+										
; *** -	 FILPOP  -  OPEN FILE AND RESTORE IT'S CONTEXT FROM THE
;		    FILE STACK.
;										
; INPUT:									
;	FILESP - FILE STACK POINTER
;	CONTEXT SAVED ON STACK:
;		FILE ID
;		FILE SEQUENCE NUMBER
;		DEVICE NAME
;		DEVICE UNIT NUMBER
;		MODULE NAME (2 RAD50 WORDS, OR 0)
;		LOW ORDER VIRTUAL BLOCK NUMBER
;		BYTE WITHIN BLOCK
;
; OUTPUT:									
;	FILESP - UPDATED STACK POINTER
;-										

FILPOP:	MOV	FILESP,R5		; GET STACK POINTER
	CMP	R5,#FILSTK		; IS THERE ANYTHING ON THE STACK ?
	BLOS	10$			; IF LOS, NO - DON'T POP FILE
	CALL	CLOSE			; CLOSE THE CURRENT FILE
	MOV	-(R5),F.FNB+N.FID(R0)	; RESTORE FILE ID
	MOV	-(R5),F.FNB+N.FID+2(R0)	; ... SEQUENCE NUMBER
	MOV	-(R5),F.FNB+N.DVNM(R0)	; ... DEVICE NAME
	MOV	-(R5),F.FNB+N.UNIT(R0)	; ... DEVICE UNIT NUMBER
	MOV	-(R5),ULABLK		; ... 1ST WORD OF MODULE NAME
	MOV	-(R5),ULABLK+2		; ... 2ND WORD OF MODULE NAME
	CLR	R1			; INDICATE NO DATASET DESCRIPTOR
	CLR	R2			; OR DEFAULT NAME BLOCK
	CALL	OPEN			; TRY TO RE-OPEN THE FILE	
	BCS	10$			; IF CS, RETURN WITH ERROR
	CLR	R1			; ZERO HIGH ORDER VIRTUAL BLOCK NUMBER
	MOV	-(R5),R3		; ... BYTE WITHIN BLOCK
	MOV	-(R5),R2		; SET LOW ORDER BLOCK NUMBER
	MOV	R5,FILESP		; SAVE STACK POINTER
	CALL	.POINT			; POINT INTO FILE
10$:	RETURN


	.SBTTL	SYNSAV - CHECK FOR SYNONYM KEYWORD
;+										
; *** - SYNSAV	-  EXAMINE FIRST LINE OF HELP TEXT FOR SYNONYM (#)
;		   OR STRING SYNONYM (=) CUE.
;										
; INPUT:									
;	R0 - POINTS TO FIRST BYTE OF HELP LINE					
;	R1 - LENGTH OF HELP LINE						
;										
; OUTPUT:									
;	SYNFLG=0 - "#" WAS NOT FOUND AS FIRST NON-BLANK				
;		R0, R1, R4 PRESERVED						
;		R2, R3, R5 DESTROYED						
;	SYNFLG=2 - "#" WAS FOUND AS FIRST NON-BLANK				
;		SYNONYM SAVED IN SYNBUF						
;		R0, R1, R4 PRESERVED						
;		R2, R3, R5 DESTROYED						
;
;	IF "=" WAS FOUND AS THE FIRST NON-BLANK CHARACTER, HELP
;	PROCESSING IS RESTARTED FROM THE TOP, USING THE SUPPLIED
;	STRING.
;-										
										
SYNSAV:
	MOV	R0,R2		; ADDRESS OF HELP LINE				
	MOV	R1,R3		; LENGTH OF HELP LINE				
	BR	10$		;						
5$:	INC	R2		; EXAMINE NEXT CHARACTER			
	DEC	R3		; ANY CHARACTERS LEFT?				
	BEQ	90$		; NO - RETURN
10$:	CMPB	#40,(R2)	; IGNORE BLANKS ...				
	BEQ	5$		;						
	CMPB	#11,(R2)	;    ... AND TABS.				
	BEQ	5$		;						
	MOV	#STRBUF,R5	; ASSUME STRING SYNONYM FOUND, POINT TO BUFFER
	CMPB	#'=,(R2)+	; LOOK FOR "=" AS FIRST NON-BLANK/TAB
	BEQ	20$		; IF EQ, STRING SYNONYM
	MOV	#SYNBUF,R5	; ASSUME SYNONYM FOUND, POINT TO BUFFER
	CMPB	#'#,-1(R2)	; LOOK FOR "#" AS FIRST NON-BLANK/TAB		
	BNE	90$		; NO SYNONYM - RETURN SYNFLG=0			
	INCB	SYNFLG		; FLAG - SYNONYM STORED IN SYNBUF		
20$:	DEC	R3		; CORRECT LENGTH				
30$:	DEC	R3		; ANY CHARACTERS LEFT?				
	BMI	40$		; NO						
	MOVB	(R2)+,(R5)+	; STORE KEYWORD					
	BR	30$		;						
40$:	CLRB	(R5)		; KEYWORD NEEDS A NULL
	BITB	#2,SYNFLG	; SYNONYM OR STRING SYNONYM ?
	BNE	100$		; IF NE, SYNONYM
	CALL	CLEAN		; CLEAN UP
	MOV	SPSAV,SP	; RESTORE STACK
	MOV	#STRBUF,R4	; POINT TO SPACE PRECEDING NEW STRING
	CALLR	$HELP		; AND TAKE IT FROM THE TOP
90$:	CLRB	SYNFLG		; NO SYNONYM REQUEST FOUND			
100$:	RETURN			;						


	.SBTTL	SYNSCH - SEARCH FILE FOR REQUESTED SYNONYM KEY									
;+										
; *** - SYNSCH  -  SEARCH HELP FILE FOR REQUESTED SYNONYM KEY			
;										
; INPUT:									
;	SYNBUF CONTAINS SYNONYM KEY						
;	R3 - HELP LINE KEYWORD ADDRESS						
;	R5 - HELP LINE KEYWORD LENGTH						
;										
; OUTPUT:									
;	MATCHING KEY RECORD IS MARKED						
;	R4FLG = 1								
;	SAVER4 - COMMAND LINE POINTER						
;	R4 - POINTS TO SYNBUF							
;	R0, R1, R2, R3, R5 - DESTROYED						
;-										
										
SYNSCH:	MOV	R3,R0		; ADDRESS OF KEYWORD FOR COMPARE		
	MOV	R5,R1		; LENGTH					
	CLRB	SYNFLG		; IGNORE ANY OTHER SYNONYMS IN SEARCH		
	TSTB	R4FLG		; IS THE COMMAND LINE POINTER SAVED?		
	BNE	5$		; YES						
	MOV	R4,SAVER4	; NO - SAVE IT					
	INCB	R4FLG		; FLAG ACCORDINGLY				
5$:	MOV	#SYNBUF,R4	; COMPAR ASSUMES R4 POINTS TO KEYWORD		
	BR	20$		; NXTREC HAS ALREADY POINTED OUT A KEY		
10$:	CLRB	INDFLG		; IGNORE INDIRECT FILE REQUESTS			
	CALL	NXTREC		; GET NEXT KEY					
	BCS	SYNERR		; KEY NOT FOUND - PRINT ERROR MESSAGE		
20$:	CALL	COMPAR		; IS THIS THE RIGHT KEY?			
	BCS	10$		; NO MATCH YET					
	CALL	MARK2		; MARK THIS RECORD				
	RETURN			;						


	.SBTTL	ERROR PROCESSING ROUTINES
HLPERR:	CALL	WRIT2		; WRITE THE LINE IN ERROR
EXIT:	CALL	CLEAN		; CLOSE FILES, DETACH TERMINAL
	MOV	SPSAV,SP	; RESTORE STACK
	RETURN
CLEAN:	MOV	#IO.DET,ODPB+Q.IOFN ; SET FUNCTION TO DETACH
	DIR$	#ODPB		; DETACH TERMINAL
CLOSE:	CALL	$SAVAL		; SAVE SOME REGISTERS
	MOV	$HFDB,R0	; POINT TO FDB	
	MOV	R0,R1		; MAKE SCRATCH COPY
	MOV	#FDBSAV,R2	; POINT TO SAVED FDB CONTENTS
	MOV	#7,R3		; SEVEN WORDS TO RESTORE
10$:	MOV	(R2)+,(R1)+	; ...
	DEC	R3		; ...
	BNE	10$		; ...
	CLOSE$			; CLOSE FILE
	RETURN
SYNERR:	MOV	#ER8,R0		; ADDRESS OF ERROR MESSAGE			
	CALL	ERROR		; WRITE ERROR MESSAGE TO TERMINAL		
	MOV	#SYNBUF,R0	; SYNONYM LINE ADDRESS				
	CALL	WRIT		; WRITE SYNONYM LINE TO TERMINAL		
	BR	EXIT		; DETACH TERMINAL AND RETURN TO CALLER
										
FILERR:	MOVB	F.ERR(R0),R1	; GET ERROR CODE
	MOV	#ER2NUM,R0	; GET ADDRESS OF BUFFER
	CLR	R2		; SUPPRESS LEADING ZEROES
	CALL	$CBDSG		; CONVERT ERROR CODE
	MOVB	#'.,(R0)+	; PUT IN DECIMAL POINT
	CLRB	(R0)		; SET END OF LINE
	MOV	#ER2,R0		; POINT TO ERROR MESSAGE
	CALL	ERROR		; WRITE IT OUT
	BR	EXIT		; CLOSE FILE, DETACH TI: AND RETURN
ERROR:	MOV	R0,R1		; COPY MESSAGE ADDRESS
	TSTB	(R1)+		; SKIP LEADING <CR>
	MOVB	$HNAME,(R1)+	; MOVE IN TASK NAME
	MOVB	$HNAME+1,(R1)+	; ...
	MOVB	$HNAME+2,(R1)	; ...
	CALLR	WRIT		; WRITE OUT ERROR MESSAGE AND RETURN


	.SBTTL	WRIT - WRIT OUT ASCIZ BUFFER
	.SBTTL	WRIT2 - WRIT OUT SPECIFIED LENGTH BUFFER
;+
; *** - WRIT - WRITE OUT ASCIZ BUFFER
; *** - WRIT2 - WRITE OUT SPECIFIED LENGTH BUFFER
;
; INPUT:
;	R0 - MESSAGE ADDRESS
;	R1 - MESSAGE LENGTH (IF ENTRY AT WRIT2)
;
;-
WRIT:	MOV	R0,R1		; COPY BUFFER ADDRESS
10$:	TSTB	(R1)+		; END OF MESSAGE?
	BNE	10$		; NO, LOOP TILL END
	SUB	R0,R1		; COMPUTE LENGTH
WRIT2:	MOV	#IO.WVB,ODPB+Q.IOFN ; SET WRITE VIRTUAL FUNCTION
	MOV	#ODPB,R4	; GET OUTPUT DPB ADDRESS
	MOV	R0,Q.IOPL(R4)	; SET BUFFER ADDRESS
	MOV	R1,Q.IOPL+2(R4)	; SET BUFFER LENGTH
	DIR$	R4		; WRITE IT OUT
	RETURN
 
	.END
