	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
	.INCLUDE /CMN:IIDEF/
	.INCLUDE /DVR:IBMDEF/
TITLE	IIDVR,<IBM INTERFACE DRIVER>,0A,10-MAY-91,PGV/JTC/FEK/GPK/KPH

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR IIDVR

;+
;
;  000	PGV  02-Sep-81	Creation - copied from V7.0-07
;  001	PGV  02-Sep-81	Apply source level corrections for changes
;			made by patches in 2780/3780 V1.0. /
;			To RSTS group for I and D space mods.
;  002  JTC  09-Sep-81	I and D space mods: Change all APR references.
;			Add PSECTS IIDISP and IIDTBL.
;  003	PGV  01-OCT-81	Change translation of EBCDIC 4F (Vert bar) to
;			ASCII 174 (which is a vertical bar)
;  004	PGV  06-OCT-81	Disallow CONNECTs for the same II unit to more
;			than one KMC (viz V7.0 Dispatch 50.2.4 R)
;  005	PGV  07-OCT-81	Fix 'buffer overrun' problem where more tabs
;			are sent than there are stops in tab record.
;  006	PGV  20-OCT-81	Correct handling of requests entering at SLP$II
;  007	PGV  21-OCT-81	Add patch space in PSECT IIDVR at IIPAT.
;  008	PGV  26-OCT-81	Correct translation of EBCDIC BD and C0.
;  009  PGV  03-NOV-81	Correct handling of 3780 PUN channel.
;  010  PGV  03-NOV-81	To RSTS/E group for submission to SDC with
;			V7.1 of RSTS/E!  
;  011	JB   10-DEC-82	Correct the processing of tab format messages
;			SPR #11-46950, also zero tab buffer when allocated
;  012	FEK  7-Feb-83	Cleanup For V8.0 submission
;  013	GPK  20-Apr-84	Multiple privileges
;  014	KPH  12-Sep-84	Changes for APR5 FIP pool
;
;			[RSTS/E V9.1]
;  015	KPH  12-Mar-85	APR5 is now always read/write
;
;			[RSTS/E V9.3]
;  016  KPH  22-Feb-86	Move out of RSTS phase
;-

.SBTTL	DUP-11 CSR(S)
 
RXCSR	=	0		;RECEIVER STATUS REGISTER (R/W)
RXDBUF	=	2		;RECEIVER DATA BUFFER REGISTER (R-O)
PARCSR	=	2		;PARAMETER STATUS REGISTER (W-O)
TXCSR	=	4		;TRANSMITTER STATUS REGISTER (R/W)
TXDBUF	=	6		;TRANSMITTER DATA BUFFER (R/W)
 
; DEFINE BITS IN RXCSR
 
.BSECT
 
	.BLKB	.		;DATA SET CHANGE B (R-O)
DTR:	.BLKB	.		;DATA TERMINAL READY
RTS:	.BLKB	.		;REQUEST TO SEND
	.BLKB	.		;SECONDARY TRANSMIT DATA
RCVEN:	.BLKB	.		;RECEIVER ENABLE
	.BLKB	.		;DATA SET INTERRUPT ENABLE
	.BLKB	.		;RECEIVER INTERRUPT ENABLE
RXDONE:	.BLKB	.		;RECEIVER DONE (R-O)
	.BLKB	.		;STRIP SYNC
DSR:	.BLKB	.		;DATA SET READY (R-O)
	.BLKB	.		;SECONDARY RECEIVED DATA (R-O)
	.BLKB	.		;RECEIVER ACTIVE (R-O)
CARR:	.BLKB	.		;CARRIER (R-O)
CTS:	.BLKB	.		;CLEAR TO SEND (R-O)
RING:	.BLKB	.		;RING INDICATOR (R-O)
	.BLKB	.		;DATA SET CHANGE A (R-O)

	DEFORG	IIDVRM		;Main driver code			;016

.SBTTL	OPEN MODE TABLE
 
.MACRO	DEFOPS	MODE,ACTRTN
	.WORD	MODE
	.WORD	ACTRTN
.ENDM	DEFOPS
 
.IF	DF KM3271		;RSTS/KMC-3271
 
TB3271:	DEFOPS	0,NO3271	;NORMAL MODE
	DEFOPS	1,XO3271	;NORMAL MODE WITH TRANSPARENCY
	DEFOPS	1000.,NS3271	;NORMAL MODE WITH SPECIFID CU-DEV REQUEST
	DEFOPS	1001.,XS3271	;NORMAL MODE WITH SPEC CU-DEV AND TRANSPARENCY
	DEFOPS	5000.,IIMTO	;MTO MODE
 
LG3271=<.-TB3271/4>		;# OF POSSIBLE MODES FOR RSTS/KMC-3271
 
.ENDC				;RSTS/KMC-3271
 
.IF	DF KM2780 ! KM3780	;RSTS/KMC-2780/3780
 
TB2780:
TB3780:
	DEFOPS	10000.,RR2780	;READER MODE NOT XPAR
	DEFOPS	10001.,RT2780	;READER MODE XPAR
	DEFOPS	12000.,CO2780	;CONTROL MODE
	DEFOPS	13000.,PR2780	;PRINTER MODE
	DEFOPS	13001.,PU2780	;PUNCH MODE
 
LG2780=<.-TB2780/4>		;# OF POSSIBLE MODES FOR RSTS/KMC-2780
LG3780=<.-TB3780/4>		;# OF POSSIBLE MODES FOR RSTS/KMC-3780
.ENDC				;RSTS/KMC-2780/3780

 
.SBTTL	SPECIAL FUNCTION SERVICE
 
;+
; SPC$II - SPECIAL FUNCTION SERVICE FOR IBM INTERFACE DRIVER.
;
;	R0 =  UNIT NUMBER TIMES TWO
;	R1 -> DDB/FCB
;	R2 -> SPECIAL FUNCTION CODE
;	R3 -> XRB
;	R4 =  CALLING JOB NUMBER TIMES TWO
;	R5 -> (MAPPED) XRB
;
;	...
;
;	JMP	RTI3
;
;	-OR-
;
;	ERROR	CODE
;-
 
	TMPORG	IIDISP,2						;016
	 .WORD	SPC$II							;016
	UNORG								;016

SPC$II:	ERROR	PRVIOL		;NO SPECIAL FUNCTION SERVICE		;016

.SBTTL	STATUS CHANGE SERVICE
 
;+
; IIXSTA - STATUS CHANGE SERVICE
;	   CALLED BY XK DRIVER WHEN STATUS HAVE CHANGED
;	   IN THE AUXILIARY PROCESSOR.
;
;	R0 =  CONTROLLER # * 2
;	R1 =  UNIT # * 2 WITHIN THE CONTROLLER
;	R4 -> BRIDGE BLOCK
;	BBSTS(R4) = CHANGED STATUS
;		0 -> DISCONNECT REQUEST
;		1 -> START REQUEST
;		2 -> STOP REQUEST
;	PRIORITY IS PR5
;
;	...
;
;	RETURN WITH C CLEAR	(SUCCESS)
;
;	- OR -
;
;	RETURN WITH C SET	(FAIL)
;
;	ALL REGISTERS PRESERVED
;-
 
IIXSTA:
	REGSCR			;;SAVE AL REGISTERS
	MOV	DEV.II(R0),R1	;;R1 -> IIDDB
	TSTB	(R4)		;;WHAT IS THE STATUS OF BB?
	BNE	5$		;;IF NE, START OR STOP REQUEST...
 
; DISCONNECT REQUEST
 
	CLR	IIBBP(R1)	;;LET'S CLEAR THE BB PTR
	CLR	IIPRID(R1)	;; AND PRODUCT ID, TO SAY NOT CONNECTED * 004 *
	RETURN			;;RETURN TO CALLER....
 
5$:	BMI	20$		;;IF MINUS, II IS DEAD?
	BITB	#1,(R4)		;;IS IT START REQUEST?
	BNE	15$		;;YES...
 
; STOP REQUEST
 
	MOV	IILTTP(R1),R2	;;R2 -> LTT
	MOVB	IILTTN(R1),R3	;;R3 = # OF ENTRIES IN LTT
10$:	TSTB	(R2)		;;IS THE ENTRY FREE?
	BEQ	12$		;;YEP...
	SEC			;;NOOP, NOT ALLOW TO STOP, SET ERROR STATUS
	RETURN			;;RETURN TO CALLER....
 
12$:	ADD	#LTTSIZ,R2	;;NEXT ENTRY
	SOB	R3,10$		;;TEST NEXT...
 
	MOV	CSR.II(R0),R2	;;R2 -> CSR
	MOV	#400,TXCSR(R2)	;;RESET DUP-11
	CLR	TIM.II(R0)	;;DISABLE TIMER NOW...
	BIC	#DDAUXA,(R1)	;;MARK AS STOPPED!
	MOV	#400,TXCSR(R2)	;;WAIT 2 MICROSEC AND RESET DUP-11 AGAIN
	RETURN			;;RETURN TO CALLER....
 
15$:	MOV	#2,TIM.II(R0)	;;START TIMER
	MOV	CSR.II(R0),R4	;;R4 -> CSR
	MOV	#400,TXCSR(R4)	;;MASTER RESET DUP-11, WAIT AT LEASE 2 MICROS
	BIS	#DDAUXA,(R1)	;;THE AUX PROCESSOR IS ACTIVE NOW!
	BIS	#DDAUXA,(R1)	;;DO ONE MORE TIME TO BE SURE FOR 2 MICROS!
	MOV	#101062,PARCSR(R4) ;;SET PAR REG - DEC MODE, INH CRC, SET SYNC
 
.IF	DF KM3271		;RSTS/KMC-3271
 
	CMP	#II3271,IIPRID(R1) ;;IS IT KMC-3271?
	BNE	17$		;;NOOP...
	CLR	TIM.II(R0)	;;NO TIMER FOR RSTS/KMC-3271
	MOV	#422,(R4)	;;SET RXCSR - STRIP SYNC, RECV ENABLE, DTR UP
17$:
 
.ENDC				;RSTS/KMC-3271
 
	RETURN			;;RETURN TO CALLER....
 
; AUX PROCESSOR IS DEAD, WE ARE DOING NOTHING FOR THAT NOW!
 
20$:	BIS	#DDSTAT,(R1)	;;INDICATE AUX PROCESSOR IS DEAD
30$:	RETURN			;;RETURN

.SBTTL	BRIDGE BLOCK INTERRUPT SERVICE
 
;+
; IIXINT - BRIDGE BLOCK INTERRUPT SERVICE.
;	   CALLED BY AUXILIARY PROCESSOR WHEN AN INTERRUPT FROM AUXILIARY
;	   PROCESSOR HAS TO BE DELIEVERIED TO THE IIDVR.
;
;	R0 =  CONTROLLER # * 2
;	R1 =  UNIT # * 2 WITHIN THE CONTROLLER
;	R2 -> IRB
;	R3 =  INTERRUPT STATUS
;		2  OUTDON - OUTPUT DONE
;		4  DATAIN - DATA IN
;	       10  RVI-IN - RVI RECEIVED
;	       12  EOT-IN - EOT RECEIVED
;	       14  XDATIN - DATA IN X'PARENCY
;	       16  STX-IN - OUTPUT DONE WITH STX-IN
;	      200  LINSIC - LINE SICK / NAK COUNT OVERFLOWED
;	      210  TIMOUT - TIME-OUT/NAK 3 TIMES ON TRANSMISION
;	      220  DISIMM - DISCONNECT IMM
;	      300  LINTOT - LINE SICK / TIMED OUT
;	R4 -> BRIDGE BLOCK
;
;	...
;
;	RETURN		(WITH R0, R1 AND R3 CHANGED)
;-
 
IIXINT:
	MOV	DEV.II(R0),R0	;;R0 -> IIDVR
	MUL	#LTTSIZ/2,R1	;;R1 =  OFFSET TO LTT ENTRY
	ADD	IILTTP(R0),R1	;;R1 -> LTT ENTRY
 
.IF	DF KM2780 ! KM3780	;RSTS/KMC-2780/3780
 
	TST	R3		;;IS LINE IN SICK?
	BPL	50$		;;IF PL NOOP...
 
; LINE IN SICK
 
	CMPB	#220,R3		;;IS IT DISCONNECT IMM?
	BNE	4$		;;NOOP...
	BIS	#<IIEVF!IIDDTR>,LTTMD(R1) ;;SET DISC FLAG TO ALLOW SPOOLER
				;; TO RAISE DTR
	BIC	#IICON,LTTMD(R1) ;;NO MORE CONNECTION
	BR	5$		;;GOTO COMMON CODES....
4$:	CMPB	#210,R3		;;IS IT TIME-OUT/NAK 3 TIMES ON TRANSMISION?
	BNE	20$		;;NOOP...
	TST	R2		;;DO WE HAVE IRB RETURN?
	BEQ	10$		;;NOOP...
5$:	BIC	#IITIMO,LTTMD(R1) ;;RESET TIMOUT/NAK FLAG (MUST BE FWRABT)
	BR	15$
10$:	BIT	#IITIMO,LTTMD(R1) ;;TIME-OUT FLAG SET?
	BNE	15$		;;YEP...
	BIS	#<IIEVF!IITIMO>,LTTMD(R1) ;;SET TIME-OUT FLAG
15$:	ADD	#LTTSIZ,R1	;;IT MUST BE FOR READER CHANNEL (2ND ENTRY)
	BR	INACK1		;;TAKE IT AS OUTPUT DONE THEN...
 
20$:	CMPB	#200,R3		;;IS IT LINE SICK/ NAK COUNT OVERFLOWED?
	BNE	30$		;;NOOP...
	MOV	#<IIEVF!IINAK>,R3 ;;SET LINE-SICK FLAG
	BR	40$
30$:	MOV	#<IIEVF!IITOUT>,R3 ;;IT MUST BE TIME-OUT COUNT OVERFLOWED!
40$:	BIS	R3,LTTMD(R1)	;;SET FLAG IN LTTMD IN STATUS CHANNEL
	BR	15$		;;GOTO COMMON CODE...
 
.ENDC				;RSTS/KMC-2780/3780
 
; DISPATCH TO APPROPRIATE SERVICE ROUTINES....
 
50$:	ADD	R3,PC		;;JUMP TO APPROPIATE SERVICE ROUTINE....
	 RETURN			;;STATUS = 0, NOP
	 BR	INACK		;;STATUS = 2, OUTDON WITH "ACK" IN
	 BR	INDATA		;;STATUS = 4, DATAIN
	 RETURN			;;STATUS = 6, NOP
 
.IF	DF KM2780 ! KM3780	;RSTS/KMC-2780/3780
 
	 BR	INRVI		;;STATUS =10, OUTDON WITH "RVI" IN
	 BR	INEOT		;;STATUS =12, EOT-IN
	 BR	INDATA		;;STATUS =14, DATAIN IN X'PARENCY
 
.IF	DF KM3780		;RSTS/KMC-3780
 
	.BR	INSTX		;;STATUS =16, OUTDONE WITH "STX" IN
 
; OUTPUT DONE WITH "STX" IN...
 
INSTX:
	BIS	#<IIEVF!IIFIRB!IISTX>,LTTMD(R1) ;;REMEMBER STX-IN
	BR	INACK		;;TAKE IT AS ACK-IN THEN...
 
.ENDC				;RSTS/KMC-3780
 
; OUTPUT DONE WITH "RVI" IN...
 
INRVI:
	BIS	#<IIEVF!IIRVI>,LTTMD(R1) ;;REMEMBER RVI-IN
	.BR	INACK		;;TAKE IT AS ACK-IN THEN
 
.ENDC				;RSTS/KMC-2780/3780
 
; OUTPUT DONE WITH "ACK" IN...
 
INACK:
 
	.ENABL	LSB
 
.IF	DF KM2780 ! KM3780	;RSTS/KMC-2780/3780
 
	BIT	#<II2780!II3780>,IIPRID(R0) ;;IS IT RSTS/KMC-2780/3780
	BEQ	30$		;;NOOP...
	BIC	#IITIMO,LTTMD(R1) ;;ANY OTHER ACTIVITIES, RESET NAK/TIMOUT
	ADD	#LTTSIZ,R1	;;THIS IS THE READER CHANNEL (2ND ENTRY)
	TSTB	(R2)		;;IS IT A FORWARD ABORT RETURN?
	BPL	30$		;;NOOP...
	BIS	#IIEVF,<LTTMD-LTTSIZ>(R1) ;;SET EVF TO STOP SPOOLER FROM SLEEP
	CALLX	REGSAV,R5	;;SAVE ALL REGISTERS
	MOV	R0,R3		;;SAVE IIDDB ADDR INTO R3
	MOV	R1,R0		;;MAKE A COPY OF LTT PTR INTO R0
	MOV	R3,R1		;;R1 -> IIDDB
	CALL	SNDEOT		;;SEND EOT SEQ...
	CALLX	REGRES,R5	;;RESTORE ALL REGISTERS
 
.ENDC				;RSTS/KMC-2780/3780
 
30$:	DEC	LTTCNT(R1)	;;ONE LESS PENDING OUTPUT
	BNE	35$		;;ALL GONE?
	CLRB	LTTSTA(R1)	;;YES, RESET FORWARD ABORT IN PROGRESS FLAG
35$:	CALL	RETBUF		;;RETURN IRB/BIG BUFF
INACK1:	TST	R2		;;MORE IRB/BIG BUF TO RETURN?
	BNE	30$		;;YES, GO AGAIN
	JMP	WAKJOB		;;GOTO COMMON CODES....
 
	.DSABL	LSB
 
.IF	DF KM2780 ! KM3780	;RSTS/KMC-2780/3780
 
; EOT RECEIVED
 
INEOT:
	CLR	DDFLAG(R0)	;;RESET LINE DEAD TIMER
	MOV	IILTTP(R0),R1	;;R1 -> CONTROL CHANNEL LTT ENTRY
	BIC	#<IIDIN!IIRVI!IISTX!IITIMO>,LTTMD(R1)
				;;RESET RVI, DATA-IN, STX-IN AND NAK/TIMOUT
	BIS	#<IIEVF!IIFBRK!IIFIRB>,LTTMD(R1) ;;EOT-IN, ASSUME BROKEN BY
						 ;;SENDER	 	** 001 **
	BIT	#IIETX,LTTMD(R1) ;;IS LAST BLOCK RCVD TERMINATED WITH ETX?
	BEQ	10$		;;IF EQ, NO - ASSUMPTION CORRECT 	** 001 **
	BIC	#<IIPUN!IIFBRK>,LTTMD(R1) ;; CLEAR PUN SELECT AND BREAK FILE
					  ;; STATUS 			** 001 **
 
10$:	JMP	WAKJOB		;;GO TO COMMON ROUTINE...
 
.ENDC				;RSTS/KMC-2780/3780
 
; DATA IN
 
INDATA:
 
.IF	DF KM3271		;RSTS/KMC-3271
 
	CMP	#II3271,IIPRID(R0) ;;IS IT RSTS/KMC-3271?
	BEQ	30$		;;YES...
 
.ENDC				;RSTS/KMC-3271
 
.IF	DF KM2780 ! KM3780	;RSTS/KMC-2780/3780
 
; WE WILL ASSUME IT IS RSTS/KMC-2780/3780
 
	MOV	LTTDEV(R1),DDFLAG(R0) ;;RESTART TIMER IF SPOOLER SPECIFIED SO
 
; WE HAVE TO FIND OUT IF IT IS FOR PRINTER OR PUNCH
 
	BIS	#IIDIN,LTTMD(R1) ;;FLAG AS DATA-IN TO SWITCH SPOLLER
				;; BACK TO RECEIVING
	BIC	#<IITIMO!IIFBRK>,LTTMD(R1) ;;NO MORE FILE BREAKEN & NAK/TIMOUT
	CLR	IRBPAR(R2)	;;RESET IRBPAR FOR COUNTING PURPOSE
	MOV	IRBCON(R2),R4	;;R4 = CONTROTED BUFFER ADDRESS OF BIG BUFF
	MAP	PUSH,APR=6,DATA	;;SAVE PAR6 ON THE STACK	* 002 *
	CALLX	MAPBUF		;;MAP THE BIG BUFF THRU APR6
	ADD	#BUFHDR,R3	;;PASS HEADER
 
.IF	DF KM3780		;RSTS/KMC-3780
 
	CMP	#II3780,IIPRID(R0) ;;IS IT 3780?
	BNE	10$		;;NOOP...
	BIT	#IIFIRB,LTTMD(R1) ;;FIRST BLOCK OF TEXT?
	BEQ	10$		;;NOOP, NO NEED TO CHECK FOR SELECTION...
	BIC	#IIFIRB,LTTMD(R1) ;;YEP, RESET AND CHECK FOR SELECTION
	CMP	#512.,@<2*LTTSIZ+LTTMD>(R1) ;IS IT IN RSTS TO RSTS?
	BEQ	10$		;;YEP, SELECT PRINTER ALL THE TIME...
	CMPB	#DC1,(R3)	;;SELECT PRINTER?
	BNE	5$		;;NOOP
	BIC	#IIPUN,LTTMD(R1) ;;RESET PUNCH SEL FLAG
	BR	9$		;;COUNT ONE LESS CHARACTER
5$:
	CMPB	#DC2,(R3)	;;SELECT PUNCH WITH DC2? 	** 001 **
	BEQ	7$		;;YEP...		 	** 001 **
	CMPB	#DC3,(R3)	;;SELECT PUNCH WITH DC3?
	BNE	20$		;;NOOP
7$:				;;				** 001 **
	BIS	#IIPUN,LTTMD(R1) ;;MARK PUNCH SEL FLAG
9$:	INC	R3		;;LOOK PAST THIS BYTE		** 001 **
	DEC	IRBBFL(R2)	;;ONE LESS BYTE TO WORRY
	INC	IRBPAR(R2)	;;WE HHAD TAKEN ONE BYTE ALREADY!
 
.IIF	NE <20$-.>	BR	20$
 
10$:
 
.ENDC				;RSTS/KMC-3780
 
.IF	DF KM2780		;RSTS/KMC-2780
 
	CMPB	#DATAIN,IRBMOD(R2) ;;IS IT NORMAL DATA-IN?
	BNE	20$		;;NOOP, NO CHANGE SELECTION THEN...
	CMPB	#ESC,(R3)	;;IS IT AN ESC SEQ?
	BNE	20$		;;NO
	BIC	#IIPUN,LTTMD(R1) ;;ASSUME FOR PRINTER
	CMPB	#'4,1(R3)	;;IS IT FOR PUNCH?
	BNE	20$		;;NOOP...
	BIS	#IIPUN,LTTMD(R1) ;;MARK PUNCH SEL FLAG
 
.ENDC				;RSTS/KMC-2780
 
20$:	ADD	IRBBFL(R2),R3	;;R3 -> LAST CHAR IN THE DATA BUFFER
	BIC	#IIETX,LTTMD(R1) ;;ASSUME TERMINATED WITH ETB
	CMPB	#ETX,(R3)	;;IS IT ETX?
	BNE	25$		;;NOOP...
	BIS	#<IIETX!IIFIRB>,LTTMD(R1) ;;MARK AS ETX AND CHECK SEL 
25$:	BIT	#IIPUN,LTTMD(R1) ;;IS IT FOR PUNCH?
	BEQ	28$		;;NOOP...
	ADD	#LTTSIZ,R1	;;ADJUST TO POINT TO 4RD LTT ENTRY (PUNCH)
28$:	ADD	#LTTSIZ*2,R1	;;ADJUST TO POINT TO 3TH LTT ENTRY (PRINTER)
	MAP	POP,APR=6,DATA	;;RESTORE PAR6		* 002 *
 
.ENDC				;RSTS/KMC-2780/3780
 
30$:
 
; NOTE: THE FOLLOWING INSTRUCTION SHOULD BE REMOVED WHEN WE FIXED THE
;	MICRO-CODES IN RSTS/3271 EP TO CLEAR THE NEXT IRB PTR IN IRB.
;
	CLR	IRBNXT(R2)	;;CLEAR THE NEXT IRB LINK WORD
 
	TSTB	(R1)		;;IS THE ENTRY EMPTY?
	BNE	35$		;;NO
	MOV	IIBBP(R0),R4	;;RESTORE BB POINTER
32$:	CALL	RETBUF		;;JUST RETURN THE IRB/BIG BUF SINCE NO ONE
	MOV	R2,-(SP)	;;SAVE R2 ONTO STACK
	CLR	R2		;;INDICATE NO IRB
	MOV	#2,R3		;;INDICATE RCVD BUFF RETURN
	CALLBB	BBASND		;;RETURN RCVD BUF
	MOV	(SP)+,R2	;;RESTORE R2
	BNE	32$		;;IF MORE TO RETURN, GOTO 32$
	RETURN			;;AND THEN LEAVE....
35$:
	MOV	LTTIRB(R1),R3	;;IS THERE ANY IRB WAITING?
	BNE	37$		;;YES, CHAIN TO THE END...
	MOV	R2,LTTIRB(R1)	;;OTHERWISE, JUST MOVE INTO LTTIRB
	BR	WAKJOB		;;GOTO COMMON CODES..
37$:	TST	IRBNXT(R3)	;;ANY IRB CHAIN OFF THIS ONE?
	BEQ	38$		;;NO, WE FOUND THE END OF THE CHAIN..
	MOV	IRBNXT(R3),R3	;;OTHERWISE, CHAIN DOWN
	BR	37$		;;TRY AGAIN
38$:	MOV	R2,IRBNXT(R3)	;;CHAIN THE IRB IN R2	
 
WAKJOB:	MOVB	(R1),R1		;;R1 = JOB # * 2
	BEQ	40$		;;IF ZERO, NO JOB..
	BIS	#JSTIM,JBSTAT(R1) ;;WAKE IT UP ANYWAY....
40$:	RETURN			;;RETURN HAPPILY.....
 
 
; RETURN IRB/BIG BUF POINTED TO BY R2
; R2 -> NEXT IRB IN THE CHAIN WHEN EXIT.
 
RETBUF:	MOV	R4,-(SP)	;;SAVE R4 ON THE STACK
	MOV	IRBCON(R2),R4	;;R4 = CONTROTED BIG BUFF ADDR
	BEQ	10$		;;IF EQ, NO BIG BUFF
	BUFFER	RETURN		;;RETURN BIG BUFF
10$:	MOV	R2,R4		;;R4 -> IRB
	MOV	IRBNXT(R4),R2	;;R2 -> NEXT IRB OR -0-
	BUFFER	RETSML		;;RETURN IRB
	MOV	(SP)+,R4	;;RESTORE R4
	RETURN
 
	GLOBAL	<JBSTAT>

.SBTTL	DEVICE ASSIGNMENT SERVICE
 
;+
; ASN$II - DEVICE ASSIGNMENT SERVICE FOR IBM INTERFACE DRIVER.
;
; THIS ROUTINE IS CALLED BY THE UUO HANDLER TO BUILD A BRIDGE BETWEEN
; A PARTICULAR KMC UNIT AND AN II UNIT.  WHEN THIS CALL EXECUTES
; SUCCESSFULLY, THE UUO HANDLER WILL TAKE CARE OF THE NECESSARY DETAILS
; (SUCH AS GETTING US LST'S, ETC) INCLUDING FILLING IN THE PRODUCT ID
; CODE (2780, 3780, OR 3271) INTO IIPRID.
; IF IIPRID IS ALREADY FILLED-IN, WE KNOW THAT THIS II UNIT HAS BEEN
; CONNECTED AND NOT SUBSEQUENTLY DISCONNECTED. IF IIPRID IS 0, THE
; II UNIT IS FREE.  
;
; IF CALLED BY A JOB
;
;	R0 =  JOB NUMBER OF ASSIGNER TIMES TWO
;	R1 -> DDB
;
;	...
;
;	RETURN		(WITH ALL REGISTER PRESERVED)
;
; IF CALLED BY UUO HANDLER
;
;	R0 -> BRIDGE BLOCK
;	R1 -> DDB
;
;	...
;
;	RETURN		(WITH ALL REGISTERS PRESERVED)
;-
 
	TMPORG	IIDISP,6						;016
	 .WORD	ASN$II							;016
	UNORG								;016

ASN$II:									;016
	BIT	(PC)+,R0	;FIND OUT WHO THE CALLER IS?
	.BYTE	0,-1
	BEQ	30$		;IF MSB IS ZERO, IT IS A JOB...
	TST	IIPRID(R1)	; ARE WE ALREADY CONNECTED?	* 004 *
	BEQ	20$		; IF EQ, NO - DO THE CONNECT	* 004 *
	SEC			; INDICATE FAILURE (UUO HANDLER WILL
				; RETURN 'DEVICE NOT AVAILABLE')* 004 *
	RETURN			; BACK TO MONITOR		* 004 *
 
20$:	MOV	#IIXSTA,BBDSTA(R0) ;MOVE STATUS CHANGE RTN ADDR INTO BB
	MOV	#IIXINT,BBDINT(R0) ;MOVE INTERRUPT SERV RTN ADDR INTO BB
	MOV	R0,IIBBP(R1)	;REMEMBER THE BB INTO IIDDB
	CLC			;CLEAR C TO INFORM SUCESSFUL
	RETURN			;RETURN
30$:
	BIT	#DDAUXA,(R1)	;IS THE AUX PROCESSOR RUNNING?
	BNE	35$		;YES, JUST RETURN
	ERROR	NOTAVL		;NO RETURN AS ERROR
35$:	CLR	R0		;WE DO NOT OWN DEVICE
	RETURN
 
	.PAGE
.SBTTL	DEVICE DEASSIGNMENT SERVICE
 
;+
; DEA$II - DEVICE DEASSIGNMENT SERVICE FOR IBM DEASSIGNMENT SERVICE.
;
; ACTUAL DEVICE DEASSIGNMENT (BREAKING THE BRIDGE WE BUILT ON THE
; PREVIOUS PAGE) IS DONE AT THE 'CHANGE OF STATUS' ENTRY POINT
; IIXSTA (9 PAGES PREVIOUS).
;
;	R1 -> DDB
;
;	...
;
;	RETURN		(WITH ALL REGISTERS PRESERVED)
;-
 
	TMPORG	IIDISP,12						;016
	 .WORD	DEA$II							;016
	UNORG								;016

DEA$II:									;016
	RETURN			;JUST RETURN

.SBTTL	TIMEOUTS
 
;+
; TMO$II - TIME OUT ENTRY POINT.
;
;	R0 =  UNIT NUMBER TIMES TWO
;	R1 -> DDB
;	R3 -> CSR
;	PRIORITY IS PR5
;
;	...
;
;	RETURN
;-
 
	.ENABL	LSB
 
	TMPORG	IIDISP,16						;016
	 .WORD	TMO$II							;016
	UNORG								;016

TMO$II:									;016
	BIT	#DDAUXA,(R1)	;;IS THE KMC ACTIVE?
	BEQ	20$		;;NOOP...
	MOV	#2,TIM.II(R0)	;;RESTART THE TIMER
	MOV	IILTTP(R1),R2	;;R2 -> 1ST ENTRY OF LST
	TST	DDFLAG(R1)	;;IS THE TIMER FOR LINE DEAD STARTED?
	BEQ	10$		;;NOOP...
	DEC	DDFLAG(R1)	;;DEC TIMER
	BNE	10$		;;IF NE, NOT YET TIMED OUT...
	MOV	#400,TXCSR(R3)	;;MASTER RESET DUP-11
	BIC	#<IIDTR!IICON>,LTTMD(R2) ;;NO MORE DTR AND CONNECTION
	BIS	#IIEVF,LTTMD(R2) ;;SET EVENT FLAG, MAKE SURE WAITED 2 MICROS
	MOV	#101062,PARCSR(R3) ;;SET PAR REG - DEC MODE, INH CRC, NO SYNC
	BR	12$		;;GOTO COMMON CODE...
	
10$:	MOV	LTTMD(R2),-(SP)	;;SAVE A COPY OF STATUS ONTO STACK
	CALL	CHKDTR		;;GO AND CHECK DTR AND DSR...
	CMP	LTTMD(R2),(SP)+ ;;ANY CHANGES?
	BEQ	20$		;;NOOP
	BIS	#IIEVF,LTTMD(R2) ;;SET IIEVF TO NOTIFY SPOOLER
12$:	MOVB	(R2),R4		;;R4 = JOB # * 2
	BEQ	20$		;;IF ZERO, NO JOB
	BIS	#JSTIM,JBSTAT(R4) ;;WAKE IT UP IF IT IS SLEEPING
20$:	RETURN			;;RETURN
 
	.DSABL	LSB
 
CHKDTR:	BIC	#<IIDTR!IICON>,LTTMD(R2) ;;ASSUME NO DTR AND NO CONNECTION
 
; YES, LET'S FIND OUT IF WE STILL HAVE DTR OR NOT
 
	BIT	#DTR,(R3)	;;IS DTR STILL UP?
	BEQ	15$		;;NOOP, GOOD ASSUMPTION...
	BIS	#IIDTR,LTTMD(R2) ;;YEP, REMEMBER IT
 
; YES, HOW ABOUT CONNECTION THEN...
 
5$:	BIT	#DSR,(R3)	;;IS DSR UP?
	BEQ	15$		;;NO, GOOD ASSUMPTION...
	BIS	#IICON,LTTMD(R2) ;;REMEMBER WE STILL HAVE CONNECTION THEN
15$:	RETURN
 
	GLOBAL	<TIM.II>

.SBTTL	OPEN SERVICE
 
;+
; OPN$II - OPEN SERVICE.
;
;	R0 =  UNIT # * 2
;	R1 -> DDB (MUST BE PRESERVED)
;	R4 -> FIRQB (DEFAULT FQFLAG AND FQBUFL VALUE LOADED)
;	R5 =  JOBS IOB ENTRY (MUST BE PRESERVED)
;
;	...
;
;	RETURN
;
;	-OR-
;
;	CALLX	RETDEV
;	ERROR	CODE
;-
 
	TMPORG	IIDISP,22						;016
	 .WORD	OPN$II							;016
	UNORG								;016

OPN$II:									;016
	BIT	#DDAUXA,(R1)	;HAS WE BEEN ATTACHED?
	BNE	5$		;IF NE, YES
	CALLX	RETDEV		;RETURN ERROR AS DEV NOT AVL
	ERROR	NOTAVL
5$:	MOV	FQMODE(R4),R3	;R3 = OPEN MODE
 
.IF	DF KM3271		;RSTS/KMC-3271
 
	CMP	#II3271,IIPRID(R1) ;IS IT IN RSTS/KMC-3271?
	BEQ	10$		;YES....
 
.ENDC				;RSTS/KMC-3271
 
.IF	DF KM2780		;RSTS/KMC-2780
 
	CMP	#II2780,IIPRID(R1) ;IS IT IN RSTS/KMC-2780?
	BEQ	20$		;YES...
 
.ENDC				;RSTS/KMC-2780
 
.IF	DF KM3780		;RSTS/KMC-3780
 
	CMP	#II3780,IIPRID(R1) ;IS IT IN RSTS/KMC-3780?
	BEQ	30$		;YES...
 
.ENDC				;RSTS/KMC-3780
 
	CALLX	RETDEV		;IIDVR HAS NOT BEEN INITIALIZED PROPERLY!
	ERROR	NOTMNT		;REPORT AS DISK NOT MOUNTED....
 
.IF	DF KM3271		;RSTS/KMC-3271
 
10$:	CMP	#100000!2000.,R3 ;ARE WE IN SPECIAL MODE?
	BHI	12$		;NO, GOOD
	MOV	R0,-(SP)	;Save a register			;013
	MOV	R5,-(SP)	; and another				;013
	MOVB	FQJOB(R4),R0	;Get job * 2				;013
	CALLX	CHKPRV,R4						;013
	 .BPRIV	HWCTL		;Check for hardware control privs	;013
	MOV	(SP)+,R5	;Restore regs first			;013
	MOV	(SP)+,R0	; and another				;013
	BCC	12$		;Skip if ok				;013
	CALLX	RETDEV		;RETURN ERROR
	ERROR	PRVIOL
12$:
	MOV	#LG3271,R0	;R0 = # OF ENTRIES IN TABLE
	MOV	#TB3271,R2	;R2 -> START OF TABLE OF MODES AND ACTION RTNS
	BR	40$		;GO TO COMMON CODES....
 
.ENDC				;RSTS/KMC-3271
 
.IF	DF KM2780		;RSTS/KMC-2780
 
20$:
	MOV	#LG2780,R0	;R0 = # OF ENTRIES IN TABLE
	MOV	#TB2780,R2	;R2 -> START OF TABLE OF MODES AND ACTION RTNS
	BR	40$		;FALL THROUGH TO COMMON CODES...
 
.ENDC				;RSTS/KMC-2780
 
.IF	DF KM3780		;RSTS/KMC-3780
 
30$:
	MOV	#LG3780,R0	;R0 = # OF ENTRIES IN TABLE
	MOV	#TB3780,R2	;R2 -> START OF TABLE OF MODES AND ACTION RTNS
	.BR	40$		;FALL THROUGH TO COMMON CODES...
 
.ENDC				;RSTS/KMC-2780
 
40$:	BIC	#100000,R3	;CLEAR THE MS BIT OF MODE
44$:	CMP	(R2)+,R3	;IS THIS THE MODE
	BNE	48$		;YES GO PROCESS
	JMP	@(R2)		;JUMP TO PROCESS ADDRESS...
48$:	TST	(R2)+		;BUMP TO NEXT ENTRY
	SOB	R0,44$		;ANY MORE?
	CALLX	RETDEV		;ILLEAGL MODE SPECIFIED
	ERROR	MODERR
 
	GLOBAL	<DEV.II,CSR.II,EXTPOL,MONPOL,JOBTBL>

.IF	DF KM3271		;RSTS/KMC-3271
 
	.ENABL	LSB
 
; ROUTINE TO HANDLE NORMAL MODE OPENS...
 
NO3271:
	CALL	FLTTE		;GO GET AN LTT ENTRY
	BCC	20$		;IF CC, FOUND ONE...
5$:	CALLX	RETDEV		;NO, RETRUN AS "NOROOM" ERROR....
	ERROR	NOROOM
 
; ROUTINE TO HANDLE TRANSPARENT MODE OPENS...
 
XO3271:
	CALL	FLTTE		;GO GET AN LTT ENTRY
	BCS	5$		;INDICATE NO LTT ENTRY...
10$:	MOVB	#TRANMD,LTTMD(R2) ;REMEMBER TRANSPARENT MODE
	BR	30$		;FINISH UP...
 
; ROUTINE TO HANDLE NORMAL MODE WITH SPECIFIC LOGICAL TERMINAL...
 
NS3271:
	CALL	FSLTTE		;GO FIND A SPECIFIC LTT ENTRY
	BCS	40$		;PROCESS LTT HUNTING ERROR
20$:	MOVB	#NORMMD,LTTMD(R2) ;REMEMBER OPEN MODE
30$:	MOVB	FQFIL(R4),LTTCHN(R2) ;REMEMBER CHANNEL # * 2
	MOVB	FQJOB(R4),(R2)	;REMBER JOB # * 2
	RETURN			;EXIT HAPPILY....
 
; ROUTINE TO HANDLE MTO MODE OPENS...
 
IIMTO:
	CALL	FLTTE		;GO FIND A FREE LTT ENTRY
	BCS	5$		;CS, NO FREE LTT...
	MOVB	#MTOMD,LTTMD(R2) ;SET MODE SELECT STATUS
	BR	30$		;GO TO COMMON ROUTINE
 
; ROUTINE TO HANDLE TRANSPARENT MODE WITH SPECIFIC LOGICAL TERMINAL...
 
XS3271:
	CALL	FSLTTE		;GO FIND A SPECIFIC LTT ENTRY
	BCC	10$		;IF CC, FOUND THE LTT ENTRY...
40$:	TST	R2		;IS R2 ZERO TO INDICATE ALREADY OPEN?
	BNE	50$		;INDICATE IN USE ALREADY
	CALLX	RETDEV
	ERROR	BSERR		;INDICATE A BAD SELECTION ERROR
50$:	CALLX	RETDEV
	ERROR	INUSE		;INDICATE ALREADY IN USE BY SOMEONE ELSE
 
	.DSABL	LSB
 
.ENDC				;RSTS/KMC-3271

.IF	DF KM3271		;RSTS/KMC-3271
 
.SBTTL	FLTTE  --  FIND LTT ENTRY
 
;+
; FLTTE - FIND FIRST AVAILABLE LTT ENTRY.
;
;	R1 -> DDB
;	R4 -> FIRQB
;	R5 -> JOB IOB ENTRY
;
;	...
;
;	RETURN		(R2 AND R3 CHANGED)
;	C IS CLEAR => FOUND A LTT ENTRY AND R2 -> FREE LTT ENTRY
;	C IS SET => THERE IS NO FREE ENTRY
;-
 
FLTTE:
	MOV	IILTTP(R1),R2	;R2 PTS TO BEGIN OF LTT TABLE
	MOVB	IILTTN(R1),R3	;R3 = TOTAL # OF LTT ENTRIES
2$:
	TSTB	(R2)		;IS IT A FREE ENTRY?
	BEQ	5$		;WE FOUND EMPTY ENTRY
	ADD	#LTTSIZ,R2	;BUMP R2 TO NEXT LTT ENTRY
	SOB	R3,2$		;GO LOOP AGAIN
 
; IF HERE WE FAILED TO FIND A FREE LTT ENTRY
 
	SEC			;SET C TO INDICATE NO HOLE FOUND IN LTT
5$:	RETURN			;RETURN
 
.ENDC				;RSTS/KMC-3271

.IF	DF KM3271		;RSTS/KMC-3271
 
.SBTTL	FSLTTE	-- FIND A SPECIFIED LTT ENTRY
 
;+
; FSLTTE - FIND THE LTT ENTRY FOR A SPECIFIC LOGICAL TERMINAL.
;
;	R1 -> DDB
;	R4 -> FIRQB
;
;	...
;
;	RETURN		(R2 AND R3 CHANGED)
;	C IS CLEAR => FOUND THE ENTRY AND R2 -> LTT ENTRY
;	C IS SET => IF R2 = 0, NO SUCH LOGICAL TERMINAL
;		    ELSE THE LTT ENTRY FOR THE SPEC LOGICAL TERM IS BUSY.
;-
 
FSLTTE:
	MOV	IILTTP(R1),R2	;R2 IS START OF LTT TABLE
	MOVB	IILTTN(R1),R3	;R3 = # OF LTT ENTRIES
2$:	CMPB	FQSIZ(R4),LTTDEV(R2) ;IS IT SAME DEVICE?
	BNE	7$		;GO ON WITH NEXT LTT ENTRY
	TSTB	(R2)		;IS IT OCCUPIED BY SOMEONE?
	;CLC
	BNE	10$		;IF NE, SOMEONE IS USING THIS TERMINAL...
	RETURN			;C IS CLEAR, JUST RETURN
7$:	ADD	#LTTSIZ,R2	;GET TO NEXT ENTRY
	SOB	R3,2$		;TRY NEXT ENTRY...
	CLR	R2		;COULD NOT FIND A MATCH, CLEAR R2
10$:
	SEC			;SET C BIT
	RETURN
 
.ENDC				;RSTS/KMC-3271

.IF	DF KM2780 ! KM3780	;RSTS/KMC-2780/3780
 
	.ENABL	LSB
 
; ROUTINE TO HANDLE READER MODE NOT XPAR
 
RR2780:
	MOV	#NORMMD,R0	;R0 = NORMAL MODE
	BR	10$		;GOTO COMMON CODES...
 
; ROUTINE TO HANDLE READER MODE XPAR
 
RT2780:
	MOV	#TRANMD,R0	;R0 = XPAR MODE
10$:	MOV	IILTTP(R1),R2	;R2 -> BEGIN OF LTT
	ADD	#LTTSIZ,R2	;R2 -> 2ND LTT ENTRY
	TSTB	(R2)		;IS IT FREE?
	BNE	60$		;NO
	MOVB	R0,LTTMD(R2)	;REMEMBER THE OPEN MODE IN LTT
	MOV	FQSIZ(R4),LTTDEV(R2) ;REMEMBER CARD SIZE FROM FILE SIZE
	BNE	40$		;IF NE, USER HAS SPECIFIED ONE
	MOV	#80.,LTTDEV(R2)	;OTHERWISE, SET IT TO DEFAULT
	BR	40$		;GOTO COMMON CODES...
 
; ROUTINE TO HANDLE CONTROL MODE
 
CO2780:
	MOV	IILTTP(R1),R2	;R2 -> BEGIN OF LTT
	TSTB	(R2)		;IS IT FREE?
	BNE	60$		;NO
	MOV	FQSIZ(R4),LTTDEV(R2) ;MOVE # OF SEC FOR LINE DEAD TIMER
	MOV	#<IIDDTR!IIEOT!IIFIRB!IIETX>,LTTMD(R2) ;PRESET INIT. STATUS
	BR	40$		;GOTO COMMON CODES...
 
; ROUTINE TO HANDLE PRINTER MODE
 
PR2780:
	MOV	IILTTP(R1),R2	;R2 -> BEGIN OF LTT
	ADD	#<2*LTTSIZ>,R2	;R2 -> 3RD ENTRY
	TSTB	(R2)		;IS IT FREE?
	BNE	60$		;NOOP...
	MOV	R1,-(SP)	;SAVE R1 ONTO STACK
	MOV	R2,-(SP)	;SAVE R2 AND R4 ONTO STACK
	MOV	R4,-(SP)
	MOV	#<2+2+144.+BUFHDR>,R1 ;WE NEED THAT MANY BYTES
	MOV	#40.,R2		;LEAVE 40 SMALL BUFFERS
	CALLX	BUFFER,R5,MONPOL ;GET BUFFER FROM MONITOR
	BCC	20$		;IF CC, OK
	MOV	(SP)+,R4	;RESTORE REGS
	MOV	(SP)+,R2
	MOV	(SP)+,R1
	CALLX	RETDEV		;RETURN AS NO BUFFER ERROR THEN
	ERROR	NOBUFS
 
20$:	ADD	#BUFHDR,R4	;BYPASS THE BUFFER HEADER
	MOV	R4,R3		;MAKE A COPY OF TAB REC ADDR INTO R3
	MOV	(SP)+,R4	;RESTORE FIRQB ADDR
	MOV	(SP)+,R2	;RESTORE LTT ADDR
	MOV	(SP)+,R1	;RESTORE DDB ADDR
	MOV	R3,LTTMD(R2)	;SAVE THE TAB REC ADDR INTO LTTMD OF LTT
	MOV	FQSIZ(R4),(R3)+	;SAVE PRINTER WIDTH FROM FILE SIZE
	BNE	25$		;IF IT IS NOT ZERO, OK
	MOV	#144.,-2(R3)	;OTHERWISE TAKE DEFAULT AS 144.
25$:	CLR	(R3)		;CLEAR TAB FLAG
	MOV	#72.,R0		;Number of words to zero out	* 011 *
30$:	CLR	(R3)+		;Zero next word			* 011 *
	SOB	R0,30$		;Loop until done		* 011 *
	MOVB	#'+,LTTDEV+1(R2) ;RESET TO OVERPRINT
	BR	40$		;GOTO COMMON CODES...
 
; ROUTINE TO HANDLE PUNCH MODE
 
PU2780:
	MOV	IILTTP(R1),R2	;R2 -> BEGIN OF LTT
	ADD	#<3*LTTSIZ>,R2	;R2 -> 4TH ENTRY
	TSTB	(R2)		;IS IT FREE?
	BNE	60$		;NO
40$:	MOVB	FQFIL(R4),LTTCHN(R2) ;REMEMBER CHANNEL # * 2
	MOVB	FQJOB(R4),(R2) 	;REMEMBER JOB # * 2
	RETURN			;EXIT HAPPILY.....
 
60$:	CALLX	RETDEV		;RETURN AS INUSE ERROR
	ERROR	INUSE
 
	.DSABL	LSB
 
.ENDC				;RSTS/KMC-2780/3780

.SBTTL	LTTMAT -- FIND A MATCHING LTT ENTRY...
 
;+
; LTTMAT -- TO FIND A MATCHING LTT ENTRY
;
;	MATCH IS FOR JOB # AND THEN CHANNEL #
;
;	ON ENTRY:
;		R1 -> DDB		
;		R3 = CHAN # * 2
;		R4 = JOB # * 2			
;							
;	ON EXIT:
;		R0 -> LTT ENTRY IF FOUND
;		R0 =  0 IF NOT FOUND
;-
 
LTTMAT:
	MOV	IILTTP(R1),R0	;R0 PTS TO BEGINNING OF LTT TABLE
	MOV	R5,-(SP)	;SAVE R5 ONTO STACK
	MOVB	IILTTN(R1),R5	;R5 = # OF ENTRIES IN THIS LTT
1$:	CMPB	(R0),R4		;MATCHING JOB # DURING SER$?
	BNE	2$		;NO, SKIP TO NEXT ENTRY
	CMPB	LTTCHN(R0),R3	;MATCHING CHAN #
	BEQ	4$		;YES, FOUND IT
2$:	ADD	#LTTSIZ,R0	;SKIP TO NEXT LLT ENTRY PARDNER
	SOB	R5,1$		;LOOP AROUND UNTIL LLT ENTRIES
				;EXHAUSTED AND TIRED
	CLR	R0		;CLEAR R0 TO INDICATE ERROR
4$:	MOV	(SP)+,R5	;RETREIVE USER BUFFER PTR
	RTS	PC		;EXIT

.SBTTL	USER LEVEL SERVICE
 
;+
; SER$II - USER LEVEL READ/WRITE SERVICE.
;
;	R0 =  UNIT# * 2
;	R1 -> DDB
;	R2 =  READ OR WRITE
;	R3 -> XRB
;	R4 =  CALLING JOB # * 2
;	R5 -> USERS BUFFER THRU APR6
;-
 
	TMPORG	IIDISP,26						;016
	 .WORD	SER$II							;016
	UNORG								;016

SER$II:									;016
	BIT	#DDAUXA,(R1)	;IS THE AUX PROCESSOR ACTIVE?
	BNE	5$		;IF NE, YES
	ERROR	NOTAVL		;OTHERWISE, REPORT AS NOT AVAILABLE ERROR
5$:
	MOV	R3,-(SP)	;SAVE XRB ON STACK
	MOV	XRCI(R3),R3	;R3 = CHAN #
	CALL	LTTMAT		;MATCH FOR LTT ENTRY
	MOV	(SP)+,R3	;RESTORE XRB FROM STACK
	TST	R0		;FOUND IT?
	BNE	10$		;YES, GOOD
	ERROR	NOTOPN		;REPORT NOT OPEN
10$:
 
.IF	DF KM2780 ! KM3780	;RSTS/KMC-2780/3780
 
	BIT	#<II2780!II3780>,IIPRID(R1) ;IS IT RSTS/KMC-2780/3780
	BNE	20$		;YES...
 
.ENDC				;RSTS/KMC-2780/3780
 
.IF	DF KM3271		;RSTS/KMC-3271
 
	CMP	#II3271,IIPRID(R1) ;IS IT RSTS/KMC-3271
	BEQ	40$		;YES...
 
.ENDC
 
	ERROR	NOTMNT		;IT HAS'NT BEEN INITIALIZED PROPERLY.....
 
.IF	DF KM2780 ! KM3780	;RSTS/KMC-2780/3780
 
20$:	CMP	#.READ&377,R2	;IS THIS A READ?
	BNE	WT2780		;NO, GOTO WRITE SERVICE FOR KMC-2780/3780...
	JMP	RD2780		;YES, GOTO READ SERVICE FOR KMC-2780/3780...
 
.ENDC				;RSTS/KMC-2780/3780
 
.IF	DF KM3271		;RSTS/KMC-3271
 
40$:	CMP	#.READ&377,R2	;IS THIS A READ?
	BNE	WT3271		;NO, GOTO WRITE SERCIE FOR KMC-3271....
	.BR	RD3271		;YES, GOTO READ SERVICE FOR KMC-3271....
 
.ENDC				;RSTS/KMC-3271

.IF	DF KM3271		;RSTS/KMC-3271
 
.SBTTL	USER LEVEL READ SERVICE FOR RSTS/KMC-3271
 
;+
; RD3271 - USER LEVEL READ SERVICE.
;
;	R0 -> LTT
;	R1 -> DDB
;	R3 -> XRB
;	R5 -> USER'S BUFFER THRU APR6
;
;	...
;
;	JMPX	IOEXIT		(WITH IBM DATA IN USER'S BUFFER)
;
;	-OR-
;
;	ERROR	EOF		(NO IBM DATA RECEIVED)
;-
 
RD3271:
	MOV	LTTIRB(R0),R2	;R2 -> IRB
	BNE	3$		;IF R2 IS NON-ZERO, WE HAVE ONE WAITING..
	ERROR	EOF		;RETURN AS EOF ERROR....
3$:	CALLX	IIMDAT		;MOVE DATA TO USER'S AREA		;016
	CALL	FRBUFS		;FREE IRB AND BIG BUFF
	JMPX	IOEXIT		;GO EXIT....
 
.ENDC				;RSTS/KMC-3271

.IF	DF KM3271		;RSTS/KMC-3271
 
.SBTTL	USER LEVEL WRITE SERVICE FOR RSTS/KMC-3271
 
;+
; WT3271 - USER LEVEL WRITE SERVICE.
;
;	R0 -> LTT
;	R1 -> DDB
;	R3 -> XRB
;	R5 -> USER'S BUFFER THRU APR6
;
;	...
;
;	JMPX	IOEXIT		(WITH IBM DATA IN USER'S BUFFER)
;
;	-OR-
;
;	ERROR	EOF		(NO IBM DATA RECEIVED)
;-
 
WT3271:
	CMPB	#MTOMD,LTTMD(R0) ;OPEN FOR MTO OPERATION?
	BNE	40$		;NO GOT TO 40$
 
; FOR MTO MODE, THE FIRST BYTE IS A FUNCTION BYTE:
;	0  LOOK
;	2  CANCEL
; THE SECOND BYTE IS TERMINAL NUMBER FOR "LOOK" AND "CANCEL" FUNCTION.
 
	TSTB	(R5)		;IS IT LOOK?
	BEQ	12$		;YES...
	CMPB	#2,(R5)		;IS IT CANCEL?
	BNE	30$		;NO, UNRECONIGZE FUNCTION...
12$:	MOVB	1(R5),R3	;R3=TERMINAL TO CANCEL
	CMP	IILTTN(R1),R3	;IS IT WITHIN LIMIT?
	BLO	30$		;OUT OF LIMIT, NO GOOD
	MUL	#LTTSIZ,R3	;POINT TO THE RIGHT LTT
	ADD	IILTTP(R1),R3	;ADD START OF LTT
	TSTB	(R5)		;IS IT LOOK?
	BEQ	15$		;YES, GOTO 15$
	MOV	R3,R0		;R0-> LTT ENTRY
	CALL	CLOSE		;CLOSE THIS ENTRY
	BR	25$		;EXIT....
 
15$:	SPLC	5		;;DISABLE INTERRUPT
	MOV	LTTIRB(R3),LTTIRB(R0) ;;GIVE IRB TO MTO
	CLR	LTTIRB(R3)	;;CLEAR IRB CHAIN PTR
	SPLC	3		;ENABLE INTERRUPT
25$:	JMPX	IOEXIT		;EXIT....
 
30$:	ERROR	NEDERR		;RETURN AS NOT ENOUGHT DATA ERROR
 
; NORMAL WRITE REQUEST
 
40$:
	CMP	LTTCNT(R0),IIDCNT(R1) ;CAN WE SEND MORE?
	BLO	50$		;YES..
	ERROR	ODD		;TOO MUCH DATA...
50$:
	MOV	XRBC(R3),R2	;R2 = DATA LENGTH
	ADD	#BUFHDR,R2	;R2 = DESIRED SIZE OF BUF
	MOV	IIBBP(R1),R4	;R4 -> BIRDGE BLOCK
	CALLBB	BBGIRB		;GET AN IRB/BIG BUF
	BCC	55$		;IF CC, WE GOT ONE..
	ERROR	NOBUFS		;RETURN AS "NOBUFS" ERROR....
 
; WE HAVE R2 -> IRB
 
55$:
	MOV	XRBC(R3),IRBBFL(R2) ;MOVE IN DATA LENGTH INTO IRB
	MOV	#PUTFCN,(R2)	;MOVE IN "PUTFCN" INTO IRBFCN
	MOV	XRMOD(R3),IRBMOD(R2) ;COPY MODIFIER INTO IRBMOD
	INC	LTTCNT(R0)	;ONE MORE PENDING O/P
	CALLX	IIMTTX		;MOVE DATA FROM USER'S BUF TO BIG BUF	;016
	SUB	IILTTP(R1),R0	;R0 = OFFSET FM START OF LTT TO LTT ENTRY
	MOV	R1,-(SP)	;SAVE IIDDB ADDR
	MOV	R0,R1		;R1 -> LTT ENTRY
	CLR	R0
	DIV	#LTTSIZ/2,R0	;FIND OUT WHICH LTT IS THIS ONE
	MOV	(SP)+,R1	;RESTORE IIDDB ADDRESS
	CALLBB	BBASND		;SEND IT TO AUX PROCESSOR
	JMPX	IOEXIT		;RETURN TO USER HAPPILY.....
 
.ENDC				;RSTS/KMC-3271

.IF	DF KM2780 ! KM3780	;RSTS/KMC-2780/3780
 
.SBTTL	USER LEVEL WRITE SERVICE FOR RSTS/KMC-2780/3780
 
;+
; WT2780 - USER LEVEL WRITE SERVICE.
;
;	R0 -> LTT
;	R1 -> DDB
;	R3 -> XRB
;	R5 -> USER'S BUFFER THRU APR6
;
;	...
;
;	JMPX	IOEXIT		(WITH IBM DATA IN USER'S BUFFER)
;
;	-OR-
;
;	ERROR	EOF		(NO IBM DATA RECEIVED)
;-
 
WT2780:
	MOV	IIBBP(R1),R4	;R4 -> BRIDGE BLOCK
	MOV	R0,R2		;MAKE A COPY OF LTT ADDR INTO R2
	SUB	IILTTP(R1),R2	;EXCLUDE BIAS OF LTT
	BEQ	5$		;IF ZERO, CONTROL CHANNEL
	SUB	#LTTSIZ,R2	;SECOND LTT?
	BEQ	RDR		;YEP, READER CHANNEL
	 ERROR	PRVIOL		;NOOP, EITHER PUNCH OR PRINTER IS R-O...
 
; CONTROL CHANNEL
 
5$:	MOV	XRMOD(R3),R2	;R2 = WRITE MODIFIER
	CMP	#10,R2		;RAISE DTR?
	BEQ	10$		;YEP...
	CMP	#20,R2		;DROP DTR WITH DRAIN?
	BEQ	20$		;YEP...
	CMP	#21,R2		;DROP DTR WITHOUT DRAIN?
	BEQ	30$		;YEP...
	 ERROR	MODERR		;NOOP, MODIFIER ERROR
 
; RAISE DTR
 
10$:	BIT	#IIDDTR,LTTMD(R0) ;DID THE SPOOLER REQEST DROP DTR?
	BEQ	40$		;IF NOT, RETURN AS ERROR...
				; WE DO'NT LET THE SPOOLER TO RAISE DTR
				; UNTIL THE KMC RETURN 220 ERROR IN ORDER
				; TO PREVENT A RACE CONDITION
	CALL	DUMIRB		;GO AND GET A DUMMY IRB FOR SET DTR...
	BCS	40$		;NO BUFFER IF CS...
	MOV	#<PUTFCN+SETDTR>,(R2) ;R2 -> IRB, SET DTR FUNCTION CODE
	MOV	#<IIEOT!IIFIRB!IIETX>,LTTMD(R0) ;INIT STATUS WORD
	ADD	#LTTSIZ,R0	;FAKE IT AS READER CHANNEL
	CALL	SNDIBM		;INFORM THE KMC TO SET DTR...
	BR	38$		;COMMON EXIT...
 
; DROP DTR WITH DRAIN
 
20$:	BIT	#IIDTR,LTTMD(R0) ;DID WE HAVE DTR SET YET?
	BNE	22$		;YES, LET IT GO...
	 ERROR	NOTOPN		;NOOP, NO NEED TO DO THAT...
22$:	BIT	#IIEOT,LTTMD(R0) ;DID WE JUST SEND EOT?
	BEQ	25$		;NOOP...
	CALL	DUMIRB		;GO AND GET A DUMMY IRB FOR DROP DTR...
	BCS	40$		;NO BUFFER IF CS...
	MOV	#<PUTFCN+CLRDTR>,(R2) ;R2 -> IRB, CLEAR DTR FUNCTION CODE
	BIS	#IIDDTR,LTTMD(R0) ;REMEMBER IT IN LTTMD
	ADD	#LTTSIZ,R0	;FAKE IT AS READER CHANNEL
	CALL	SNDIBM		;INFORM THE KMC TO DROP DTR WHEN DONE....
	BR	38$		;EXIT.....
 
25$:	BIS	#IIDDTR,LTTMD(R0) ;REMEMBER IT IN LTTMD
	BR	38$		;COMMON EXIT...
 
; DROP DTR WITHOUT DRAIN
 
30$:	SPLC	5		;;DISABLE INTERRUPT
	MOVB	DDUNT(R1),R2	;;R2 = II UNIT #
	ASL	R2		;;R2 = II UNIT # * 2
	MOV	CSR.II(R2),R2	;;R2 -> DUP-11 RXCSR
	MOV	#10,R4		;;SET UP COUNTER TO 8 TIMES
35$:	MOV	#400,TXCSR(R2)	;;MASTER RESET DUP-11
	BIS	#IIEVF,LTTMD(R0) ;;REMEMBER IT IN LTTMD
	BIC	#<IIDTR!IICON>,LTTMD(R0) ;;NO MORE DTR AND DSR
	SOB	R4,35$		;;RESET DUP-11 UNITL DONW
	MOV	#101062,PARCSR(R2) ;;SET PAR REG - DEC MODE, INH CRC, SET SYNC
	SPLC	3		;ENABLE INTERRUPT
 
38$:	JMPX	IOEXIT		;EXIT FROM DRIVER.....
 
40$:	ERROR	NOBUFS		;RETURN AS NO BUFFER ERROR.....
 
 
; GET A DUMMY IRB WITHOUT DATA BUFFER
; OUTPUT:
;	C = 0 IF WE GOT AN IRB
;		R2 -> IRB
;
;	C = 1 IF WE COULD NOT GET AN IRB
;	ALL REGISTERS PRESERVED EXCEPT R2.
 
DUMIRB:	MOV	R4,-(SP)	;SAVE R4 ONTO STACK
	BUFFER	GETSML		;GET A SMALL BUFFER
	BVS	10$		;NO SMALL BUFFER IF V SET
	MOV	R4,R2		;MAKE A COPY OF SMALL BUF ADDR INTO R2
	CLR	IRBNXT(R2)	;CLEAR LINK WORD
	CLR	IRBCON(R2)	;CLEAR CONTORTED BUF ADDR
	CLR	IRBBFL(R2)	;CLEAR BUFFER LENGTH WORD
	;CLC			;CLEAR C TO INDICATE SUCCESS
	BR	15$		;GOTO COMMON RETURN
10$:	SEC			;SET C TO INDICATE FAILURE
15$:	MOV	(SP)+,R4	;RESTORE R4
	RETURN			;RETURN TO CALLER

.SBTTL	READER CHANNEL USER LEVEL WRITE SERVICE FOR RSTS/KMC-2780
 
; READER CHANNEL
 
RDR:	CMP	#2,XRMOD(R3)	;FORWARD ABORT?
	BEQ	50$		;YES
 
	CMP	#4,XRMOD(R3)	;EMPTY BUFFER CHAIN TEST?
	BNE	5$		;NOOP...
	TST	LTTCNT(R0)	;IS IT EMPTY?
	BEQ	60$		;YEP...
 
5$:	MOV	IILTTP(R1),R2	;R2 -> BEGINNING OF LTT
	BIT	#IIDIN,LTTMD(R2) ;IS IT IN RECEIVING?
	BEQ	23$		;NOOP...
	TST	<LTTSIZ*2+LTTIRB>(R2) ;ANY PENDING DATA FOR PRINTER?
	BNE	21$		;YEP...
	TST	<LTTSIZ*3+LTTIRB>(R2) ;ANY PENDING DATA FOR PUNCH?
	BEQ	23$		;NOOP...
21$:	 ERROR	NOROOM		;YEP, REPORT "NOROOM" ERROR TO SWITCH SPOOLER
 
23$:	BIT	#<IIDISC!IIRVI!IIEVF>,LTTMD(R2) ;ANY FLAG SET?
	BEQ	25$		;NO
	 ERROR	INTLCK		;YEP, INTLCK ERROR TO SWITCH SPOOLER TO RCVD
25$:	BIT	#IICON,LTTMD(R2) ;DO WE HAVE A CONNECTION?
	BEQ	73$		;NOOP, FAKE AN NO BUFFER ERROR
	MOV	XRMOD(R3),R2	;R2 = MOD
	CMP	#4,R2		;WITHIN LEGAL MODIFIER RANGE?
	BLO	26$		;NOOP...
	ASL	R2		;DOUBLE R2 FOR WORD ADDRESSING
	ADD	R2,PC		;BANCH TO PROPER ROUTINES...
	 BR	70$		;NORMAL SEND
	 BR	40$		;SEND EOT
	 BR	50$		;FORWARD ABORT
26$:	 ERROR	MODERR		; MODIFIER ERROR...
	.BR	30$		;EMPTY BUFFER CHAIN TEST
 
30$:	 ERROR	INUSE		;THE BUFF MUST NOT BE EMPTY IF WE ARE HERE...
 
; SEND EOT
 
40$:	CLRB	LTTSTA(R0)	;NO MORE FORWARD ABORT IN PROGRESS
	CALL	SNDEOT		;SEND EOT SEQ...
	BCS	73$		;IF CS, NO BUF...
	BR	60$		;GOTO COMMON EXIT.....
 
; FORWARD ABORT
 
50$:	BIT	#IICON,<-LTTSIZ+LTTMD>(R0) ;DO WE HAVE CONNECTION?
	BEQ	51$		;NOOP, LET IT GO THROUGH THEN...
	TSTB	LTTSTA(R0)	;HAS IT BEEN MARKED FOR FORWARD ABORT?
	BNE	60$		;YEP, NO MORE FORWARD ABORT
51$:	INCB	LTTSTA(R0)	;MARK AS FORWARD ABORT IN PROGRESS
	MOV	LTTOUT(R0),R2	;R2 -> PENDING OUTPUT IRB
	BEQ	55$		;NONE IF ZERO...
	CLR	LTTOUT(R0)	;NO MORE PENDING OUTPUT IRB
	MOV	IRBCON(R2),R4	;R4 = CONTROTED BUF ADDR FOR DATA BUF
	BEQ	52$		;IF ZERO, NO BIG BUF
	BUFFER	RETURN		;RETURN BIG BUF
52$:	MOV	R2,R4		;R4 -> IRB
	BUFFER	RETSML		;RETURN SMALL BUF
	MOV	IIBBP(R1),R4	;R4 -> BB
55$:	BIT	#IIEOT,<-LTTSIZ+LTTMD>(R0) ;ARE WE IN THE MIDDLE OF A FILE?
	BEQ	58$		;YEP...
	TST	LTTCNT(R0)	;NOOP, BUT DO WE HAVE OUTSTANDING IRBS?
	BEQ	60$		;NOOP, THAT IS ALL CLEAR, JUST EXIT...
58$:	TST	LTTCNT(R0)	;DO WE HAVE ANY OUTSTANDING IRBS IN LST?
	BEQ	40$		;NOOP, SEND ETX/EOT...
	CLR	R0		;ALWAYS THE 1ST LST
	CLR	R2		;INDICATE NO IRB
	MOV	#FWRABT,R3	;FUNCTION CODE = FORWARD ABORT
	CALLBB	BBASND		;SEND IT OUT
60$:	JMPX	IOEXIT		;EXIT DRIVER.....
 
 
; NORMAL SEND TO IBM
 
70$:	CLRB	LTTSTA(R0)	;NO MORE FORWARD ABORT IN PROGRESS
	CMP	XRBC(R3),LTTDEV(R0) ;IS REOCRD LNG LEGAL?
	BLE	71$		;YES...
	 ERROR	BADCNT		;OTHERWISE, IT IS BAD...
71$:	MOV	LTTOUT(R0),R2	;R2 -> PENDING OUTPUT BUFFER
	BNE	85$		;IF NE, REAL ONE...
72$:	CMP	IIDCNT(R1),LTTCNT(R0) ;HAVE WE EXCEEDED QUOTA?
	BGE	74$		;NOOP...
73$:	 ERROR	NOBUFS		;YEP, RETURN AS NO BUFFER ERROR...
74$:
 
.IF	DF KM3780		;RSTS/KMC-3780
 
	CMP	#II3780,IIPRID(R1) ;IS IT 3780?
	BNE	80$		;NOOP...
	MOV	#<512.+BUFHDR>,R2 ;ALLOCATE (512.+10.) FOR 3780
	CALLBB	BBGIRB		;GO AND GET AN IRB/BIG BUFFER
	BCS	73$		;IF CS, NO BUFFERS...
	INC	IRBBFL(R2)	;PRESET BUF COUNTER TO 1 FOR BLK DELIMITER
	MOV	#102.,IRBPAR(R2) ;PRESET MAX # OF REC TO 102.
	MOV	#<512.-2>,IRBPAR+2(R2) ;PRESET MAX # OF CHAR (512.-"IRS-ETB")
	CMP	#512.,LTTDEV(R0) ;IS IT IN RSTS TO RSTS MODE?
	BNE	77$		;NOOP, THE VALUE WE SET IS RIGHT
	MOV	#<512.+1>,IRBPAR+2(R2) ;OTHERWISE PRESET MAX # OF CHAR TO 513.
77$:
.IIF	NE <84$-.>	BR	84$
 
80$:
 
.ENDC				;RSTS/KMC-3780
 
.IF 	DF KM2780		;RSTS/KMC-2780
 
	MOV	#<400.+BUFHDR>,R2 ;ALLOCATE (400.+10.) FOR 2780
	CALLBB	BBGIRB		;GO AND GET AN IRB/BIG BUFFER
	BCS	73$		;IF CS, NO BUFFERS...
	MOV	#7,IRBPAR(R2)	;PRESET MAX # OF REC TO 7
	MOV	#<400.-1>,IRBPAR+2(R2) ;PRESET MAX # OF CHAR TO (400.-"ETB")
	.BR	84$
 
.ENDC				;RSTS/KMC-2780
 
84$:	MOV	R2,LTTOUT(R0)	;REMEMBER THE IRB ADDR INTO LTTOUT IN LTT
	BIC	#IIEOT,<LTTMD-LTTSIZ>(R0) ;NO MORE SENT EOT STATUS
85$:	MOV	IRBPAR+2(R2),-(SP) ;(SP) = (MAX BUF SIZE-LAST "ETX/ETB" CHAR)
	SUB	IRBBFL(R2),(SP)	;FIND OUT HOW MUCH SPACE LEFT IN (SP)
	CMPB	#NORMMD,LTTMD(R0) ;NORMAL DATA OUT?
	BEQ	88$		;YES
	CMP	LTTDEV(R0),(SP)+ ;DO WE HAVE ENOUGH SPACE FOR THIS RECORD?
	BLE	95$		;YEP...
	BR	90$		;SEND THE CURRENT ONE OUT THEN...	
88$:	CMP	XRBC(R3),(SP)+	;DO WE HAVE ENOUGH SPACE FOR THIS BIG BUF?
	BLE	95$		;YEP...
90$:	MOV	R0,-(SP)	;SAVE LTT ENTRY POINTER
	CLR	IRBPAR(R2)	;CLEAR THE # OF RECORDS COUNTER
	CLR	IRBPAR+2(R2)	;CLEAR MAX BUF SIZE COUNTER
	MOV	#<PUTFCN+DATOUT>,(R2) ;ASSUME NORMAL DATA OUT
	CMPB	#NORMMD,LTTMD(R0) ;REALLY?
	BEQ	91$		;YEP...
	MOV	#<PUTFCN+DATTOU>,(R2) ;CHANGE IT TO DATA OUT IN X'PARENCY THEN
91$:	CALL	SNDIBM		;SEND IT TO IBM
	MOV	(SP)+,R0	;RESTORE LTT ENTRY POINTER
	BR	72$		;GOTO CHECK QUOTA...
 
95$:	CALLX	IIMTTX		;MOVE THE RECORD TO BIG BUFFER		;016
	DEC	IRBPAR(R2)	;ONE MORE RECORDS
	BNE	60$		;IF NE, WE STILL CAN TAKE MORE, JUST LEAVE...
	CALL	SNDIBM		;OTHERWISE, SEND IT TO IBM
	BR	60$		;LEAVE....
 
; SEND TO IBM SUBOURTINE
; INPUT:
;	R0 -> LTT
;	R1 -> IIDDB
;	R2 -> IRB
;	R4 -> BB
 
SNDIBM:	INC	LTTCNT(R0)	;ONE MORE OUTSTANDING PENDING O/P
	CLR	LTTOUT(R0)	;NO MORE PENDING O/P IRB
	CLR	R0		;R0 = 0, BECAUSE WE ALWAYS USE 1ST LST ENTRY
	CALLBB	BBASND		;SEND IT TO IBM...
	RETURN			;RETURN TO CALLER...
 
; SEND EOT SEQ
; ON ENTRY:
;	R0 -> LTT
;	R1 -> IIDDB
; ON RETURN:
;	R1 -> IIDDB
;	OTHER REG ARE CHANGED
 
SNDEOT:	MOV	LTTOUT(R0),R2	;R2 -> PENDING OUTPUT IRB
	BNE	5$		;IF NE, REAL ONE
	MOV	#64.,R2		;WE WILL ASK FOR 64 BYTES
	CALLBB	BBGIRB		;GO AND GET AN IRB/BIG BUFFER
	BCS	50$		;IF CS, NO BUFFERS....
	MOV	#1,IRBBFL(R2)	;ONE CHAR ("ETX") TO GO OUT
5$:	MOV	IRBCON(R2),R4	;R4 = CONTROTED ADDR OF BIG BUF
	CALLX	MAPBUF		;MAP BIG BUFFER THRU APR6
	ADD	IRBBFL(R2),R3	;BIAS TO POINT TO NEXT AVAILABLE BYTE
	MOVB	#ETX,BUFHDR-1(R3) ;REPLACE LAST "ETB" WITH "ETX"
	MOV	R0,-(SP)	;SAVE LTT ENTRY POINTER
	MOV	#<PUTFCN+DATOUT>,(R2) ;ASSUME NORMAL DATA OUT
	CMPB	#NORMMD,LTTMD(R0) ;REALLY?
	BEQ	7$		;YEP....
	MOV	#<PUTFCN+DATTOU>,(R2) ;CHANGE IT TO DATA OUT IN X'PARENCY THEN
7$:	MOV	IIBBP(R1),R4	;R4 -> BRIDGE BLOCK
	CALL	SNDIBM		;SEND IT TO IBM
	MOV	(SP)+,R0	;RESTORE LTT ENTRY POINTER
	CALL	DUMIRB		;GET A DUMMY IRB
	BCS	50$		;IF CS, NO BUFFERS....
	MOV	R0,-(SP)	;SAVE LTT ENTRY ADDR ONTO STACK
	MOV	#<PUTFCN+EOTOUT>,(R2) ;SET FUNCTION MODIFIER TO SEND-EOT
	CALL	SNDIBM		;SEND IT TO IBM
 
; THEN, WE WILL FIND OUT IF WE HAVE DROP DTR REQUEST OUTSTANDING...
 
	MOV	(SP)+,R0	;RESTORE LTT ENTRY POINTER
	BIS	#IIEOT,<-LTTSIZ+LTTMD>(R0) ;REMEMBER WE HAVE JUST SEND EOT
	BIT	#IIDDTR,<-LTTSIZ+LTTMD>(R0) ;DROP DTR REQ?
	BEQ	40$		;NOOP, JUST EXIT
	CALL	DUMIRB		;GO AND GET AN IRB FOR DROP DTR...
	BCS	50$		;NO BUFFER IF CS...
	MOV	#<PUTFCN+CLRDTR>,(R2) ;R2 -> IRB, CLEAR DTR FUNCTION CODE
	CALL	SNDIBM		;INFORM THE KMC TO DROP DTR...
40$:	CLC			;SET NORAML STATUS
50$:	RETURN			;RETURN TO CALLER
 
.ENDC				;RSTS/KMC-2780/3780

.IF	DF KM2780 ! KM3780	;RSTS/KMC-2780/3780
 
.SBTTL	USER LEVEL READ SERVICE FOR RSTS/KMC-2780
 
;+
; RD2780 - USER LEVEL READ SERVICE.
;
;	R0 -> LTT
;	R1 -> DDB
;	R3 -> XRB
;	R5 -> USER'S BUFFER THRU APR6
;
;	...
;
;	JMPX	IOEXIT		(WITH IBM DATA IN USER'S BUFFER)
;
;	-OR-
;
;	ERROR	ODD		(OUT OF DATA)
;	ERROR	EOF		(ETX RECEIVED)
;-
 
RD2780:
	MOV	R0,R2		;R2 -> LTT ENTRY
	SUB	IILTTP(R1),R2	;R2 = OFFSET OF LTT ENTRY FROM START OF LTT
	MOV	R3,R4		;SAVE XRB ADDR INTO R4
	MOV	R2,R3		;MAKE A COPY INTO R3 SO THAT WE CAN DO A DIV
	CLR	R2
	DIV	#LTTSIZ,R2	;FIND OUT WHICH LTT ENTRY IS THIS ONE
	MOV	R4,R3		;RESTORE XRB ADDR INTO R3
	ASL	R2		;TIMES 2 TO DO WORD ADDRESSING
	ADD	R2,PC		;JUMP TO APPROPRIATE ROUTINES...
	 BR	50$		; CONTROL CHANNEL
	 ERROR	PRVIOL		; READER CHANNEL, ILLEGAL FOR "GET"
	 BR	5$		; PRINTER CHANNEL
	.BR	3$		; PUNCH CHANNEL
 
3$:	MOV	#LTTSIZ*2,R4	;R4 = DISPLACEMENT OF PRT LTT
	BR	10$		;GOTO COMMON CODES...
 
5$:	MOV	#LTTSIZ*3,R4	;R4 = DISPLACEMENT OF PUN LTT
	.BR	10$		;GOTO COMMON CODES...
 
; READ SERVICE FOR PRINTER AND PUNCH CHANNELS
 
10$:	MOV	LTTIRB(R0),R2	;R2 -> IRB/BIG BUFFER -OR- 0
	BNE	15$		;IF NOT 0, WE HAVE AN IRB
	MOV	IILTTP(R1),R2	;R2 -> BEGINNING OF LTT
	BIT	#<IIEVF!IIFBRK>,LTTMD(R2) ;IS ANY FLAG SET?
	BNE	12$		;YEP...
 
; HERE, WE DO NOT HAVE ANY INPUT DATA, NOR FILE BROKEN STATUS.
; WE WILL LOOK AT OTHER RECEIVING CHANNEL (PRINTER/PUNCH) AND FIND
; OUT IF THERE IS ANY MESSAGE TO RECEIVE, IF THERE IS ANY, WE WILL
; FORCE AN "INTLCK" ERROR TO FORCE THE SPOOLER TO SWITCH TO OTHER
; RECEIVING LOOP
 
	ADD	R2,R4		;R4 -> LTT OF PRT/PUN
	TST	LTTIRB(R4)	;IS IT EMPTY TOO?
	BNE	12$		;NOOP, FORCE "INTLCK" ERROR TO SWITCH TO RCVD
	 ERROR	ODD		;OTHERWSIE, RETURN AS OUT OF DATA
12$:	 ERROR	INTLCK		;RETURN AS INTERLOCK ERROR...
15$:	TST	IRBBFL(R2)	;ANY DATA LEFT IN BIG BUF?
	BEQ	30$		;NOOP, EOF CASE...
	CALLX	IIMDAT		;MOVE DATA TO USER'S BUFFER		;016
	TST	IRBBFL(R2)	;ANY DATA LEFT IN BIG BUF?
	BNE	60$		;YES, JUST EXIT...
	CMPB	#ETX,LTTDEV(R0)	;DID WE HIT AN "ETX"?
	BEQ	20$		;YEP...
	CALL	FRBUFS		;NOOP, FREE IRB/BIG BUF
20$:	TST	XRBC(R3)	;DID WE PASS ANY DATA?
	BNE	60$		;YEP, JUST EXIT...
	 ERROR	ODD		;NOOP, RETURN AS NO BUF, SO THAT SPOOLER WILL
				; COME BACK AGAIN...
 
30$:	TSTB	LTTDEV(R0)	;DID WE DELIEVE THE CARRIAGE CONTROL CHAR YET?
	BNE	37$		;NO, SO DO IT NOW...
33$:	CALL	FRBUFS		;FREE IRB/BIG BUFF
35$:	 ERROR	EOF		;YES, THEN RETURN AS EOF (STX-IN)
37$:	MOVB	LTTDEV+1(R0),(R5)+ ;DELIEVE THE SAVED CARRIAGE CONTROL CHAR
	MOV	#<'+>*400,LTTDEV(R0) ;RESET TO SINGLE SPACEING
	CMP	#512.,@LTTMD(R0) ;IS IT IN RSTS-RSTS MODE?
	BEQ	33$		;YEP, NO NEED TO DELIEVE CC CHAR...
	MOV	#1,XRBC(R3)	;RECORD LENGTH IS ONE
	BR	60$
 
; READ SERVICE FOR CONTROL CHANNEL
 
50$:	MOV	R0,-(SP)	;SAVE R0 ONTO STACK
	MOV	R3,-(SP)	;SAVE R3 ONTO STACK
	MOV	R0,R2		;R2 -> LTT
	MOVB	DDUNT(R1),R0	;R0 = II UNIT #
	ASL	R0		;R0 = II UNIT # * 2
	MOV	CSR.II(R0),R3	;R3 -> DUP-11 CSR
	SPLC	5		;;DISABLE INTERRUPT
	CALL	CHKDTR		;;UPDATE DTR AND DSR INFORMATION
	SPLC	3		;ENABLE INTERRUPT
	MOV	(SP)+,R3	;RESTORE R3
	MOV	(SP)+,R0	;RESTORE R0
	
	MOV	#<LTTSIZ*4/2>,R2 ;R2 = # OF WORDS FOR THE WHOLE LTT
	MOV	R2,XRBC(R3)	;MOVE # OF WORDS MOVED
55$:	MOV	(R0)+,(R5)+	;MOVE THE LTT INTO USER'S BUFFER
	SOB	R2,55$		; UNTIL DONE...
	MOV	IILTTP(R1),R2	;R2 -> CONTROL CHANNEL LTT ENTRY
	BIC	#<IITOUT!IINAK!IIEVF>,LTTMD(R2) ;RESET BITS IN LTTMD
60$:	JMPX	IOEXIT		;EXIT....
 
.ENDC				;RSTS/KMC-2780/3780

.SBTTL	FRBUFS -- FREE UP IRB AND BIG BUFFER
 
;+
; FRBUFS - FREE UP IRB AND BIG BUFFER.
;
;	R0 -> LTT ENTRY
;	R1 -> IIDDB
;	R2 -> IRB
;
;	...
;
;	RETURN		(WITH ALL REGISTERS PRESERVED EXCEPT R4)
;	  R4 = 0, IF THERE IS NO MORE WAITING IRB IN LTT
;	  ELSE R4 -> FIRST WAITING IRB IN LTT.
;-
 
FRBUFS:
	SPLC	5		;;DISABLE INTERRUPT
 
; LETS FREE THE BIG BUFFER ( A DISTANT RELATION TO THE BIG BOPPER)
 
	MOV	IRBCON(R2),R4	;;R4 = CONTROTED BUF ADDR OF BIG BUF
	BEQ	10$		;;IF ZERO, NONE...
 
; NOTE THAT WE MUST FEED THIS FREE BUFFER CALL THE CONTORTED ADDRESS
 
	BUFFER	RETURN          ;;GOODBYE BIG BUFFER
 
10$:	MOV	R2,R4		;;SETUP TO RETURN IRB
	MOV	IRBNXT(R2),LTTIRB(R0) ;;UNLINK FM LTTIRB CHAIN
	BUFFER 	RETSML		;;GOOD-BYE IRB
 
; INFORM XKDVR OF THE RETURN RCVD BUFFER
 
	MOV	R3,-(SP)	;;SAVE R3 ONTO STACK
	CLR	R2		;;R2 = 0, NO IRB
	MOV	#2,R3		;;R3 = 2, RETURN RCVD BUFF
	MOV	IIBBP(R1),R4	;;R4 -> BB
	CALLBB	BBASND		;;CALL XKDVR
	MOV	(SP)+,R3	;;RESTORE R3
 
	MOV	LTTIRB(R0),R4	;;R4 -> NEXT IRB OR =0
	SPLC	3		;ENABLE INTERRUPT
	RETURN			;EXIT

.SBTTL	CLOSE SERVICE
 
;+
; CLS$II - CLOSE SERVICE.
;
;	R0 =  UNIT # * 2
;	R1 -> DDB/FCB
;	R4 -> FIRQB
;	R5 -> DDB/FCB (MUST BE PRESERVED)
;	IF Z=1 THEN A REAL CLOSE CALL
;	IF Z=0 THEN A "RESET" CLOSE CALL
;
;	...
;
;	RETURN
;-
 
	.ENABL	LSB
 
	TMPORG	IIDISP,32						;016
	 .WORD	CLS$II							;016
	UNORG								;016

CLS$II:									;016
	BIT	#DDAUXA,(R1)	;IS AUX PROCESSOR ACTIVE?
	BNE	10$		;YES, PROCESS REQUEST
	ERROR	NOTAVL		;RETURN AS "NOTAVL" ERROR
10$:	MOV	FQFIL(R4),R3	;R3 = CHAN # * 2
	MOV	FQJOB(R4),R4	;R4 = JOB # * 2
	CALL	LTTMAT		;TRY TO MATCH IN THE LTT
	TST	R0		;DO WE HAVE A MATCH?
	BNE	20$		;HOPEFULLY YES
	ERROR	NOTOPN		;THIS IDIOT CLOSES FILES THAT
CLOSE:
20$:
	REGSCR			;SAVE REGS
	CLR	(R0)		;CLEAR "LTTJBN" AND "LTTCHN"
	TST	LTTIRB(R0)	;ANY IRBS WAITING TO BE READ
	BEQ	40$		;NO, GOOD		 
				;HERE LETS FREE IRBS & BUFFERS WAITING 
				;TO BE READ (IF ANY)
30$:	MOV	LTTIRB(R0),R2	;R2 -> IRB
	JSR	PC,FRBUFS	;GO FREE BUFFERS
	TST	R4		;ANY MORE?
	BNE	30$		;NO, GO AGAIN
40$:	MOV	LTTOUT(R0),R2	;R2 -> OUTPUT IRB
	BEQ	50$		;NO IRB...
	CLR	LTTOUT(R0)	;CLEAR THE POINTER
	MOV	IRBCON(R2),R4	;R4 = CONTROTED BUFFER ADDR OF BIG BUF
	BUFFER	RETURN		;RETURN BIG BUFF
	MOV	R2,R4		;R4 -> IRB
	BUFFER	RETSML		;RETURN SMALL BUFF
50$:
 
.IF	DF KM2780 ! KM3780	;RSTS/KMC-2780/3780
 
	BIT	#<II2780!II3780>,IIPRID(R1) ;IS IT 2780/3780?
	BEQ	70$		;NOOP...
	MOV	LTTMD(R0),R4	;R4 = LTTMD IN LTT
	BEQ	70$		;IF ZERO, NO TAB REC BUF
	SUB	IILTTP(R1),R0	;FIND OUT IF IT IS PRINTER CHANNEL
	CMP	#LTTSIZ*2,R0	;IS IT?
	BNE	70$		;NOOP
	SUB	#BUFHDR,R4	;BACK TO THE BEGINNING OF BUFFER HEADER
	BUFFER	RETURN		;OTHERWISE, IT IS A TAB REC BUF, RETURN IT
70$:
 
.ENDC				;RSTS/KMC-2780/3780
 
	RETURN			;EXIT HAPPILY....
 
	.DSABL	LSB

.SBTTL	SLEEP SERVICE
 
;+
; SLP$II - SLEEP SERVICE ROUTINE.
;	    WILL BE CALLED WHEN JOB IS REQUESTING TO
;	    GO TO SLEEP WITH SIGN BIT IS SET.
;
;	ON ENTRY:   
;		R0 = UNIT # * 2
;		R1 -> DDB
;
;	ON EXIT:
;		C = 1 GO AHEAD AND SLEEP
;		C = 0 DON'T GO TO SLEEP NOW
;		R2, R3 AND R5 MUST NOT BE CHANGED
;
;-

	TMPORG	IIDISP,36						;016
	 .WORD	SLP$II							;016
	UNORG								;016

SLP$II:									;016
	MOV	IILTTP(R1),R0	;R0->LTT
 
.IF	DF KM2780 ! KM3780	;RSTS/KMC-2780/3780
 
	BIT	#<II2780!II3780>,IIPRID(R1) ;IS IT RSTS/KMC-2780/3780
	BEQ	30$		;NO					* 006 *
	BIT	#IIEVF,LTTMD(R0) ;DID WE HAVE A CHANGE OF STATUS LAST TIME?
	BNE	20$		;YEP...
 
	MOV	IILTTN(R1),R1	;R1 = # OF ENTRIES
5$:
	CMPB	JOB,(R0)	;1ST BYTE IN LTT IS JOB # * 2, DO THEY MATCH?
	BNE	10$		;NO
	TST	LTTIRB(R0)	;YES, IS THERE ANY IRB WAITING?
	BNE	20$		;YES, EXIT WITH C CLEAR	
10$:
	ADD	#LTTSIZ,R0	;NO, SKIP TO NEXT ENTRY
	SOB	R1,5$		;CONT UNTIL DONE
 
.IFTF				; RSTS/E 2780
 
30$:	CLC			; CLEAR CARRY 		
	RETURN			; RETURN TO ALLOW THE JOB TO SLEEP
 
.IFT				; DF 2780!3780
 
20$:
	SEC			; SET CARRY 
	RETURN			; NO SLEEPING NOW! 
.ENDC
 

.SBTTL	INTERRUPT SERVICE
 
;+
; INT$II - INTERRUPT SERVICE FOR IBM INTERFACE DRIVER.
;
;	R0 = UNIT # * 2
;	PRIORITY IS PR5
;
;	...
;
;	RETURN
;-
 
	TMPORG	IIDINT,6						;016
	 .WORD	INT$II							;016
	UNORG								;016

INT$II:	RETURN			;WE SHOULD NOT SEE ANY INTERRUPT, JUST RETURN ;016
 
.END
