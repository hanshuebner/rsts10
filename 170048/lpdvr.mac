	.IF	NDF	LPDVRX						;021
	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
	.ENDC	;ND	LPDVRX
	.INCLUDE /CMN:LPDEF/
TITLE	LPDVR,<LINE PRINTER I/O SERVICE>,0A,13-MAY-91,MHB/JDM/GW/SPC/SJM/PRL/JHC/DBM

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR LPDVR
;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;  001	SJM  13-JUL-81	ADDED SUPPORT FOR I&D SPACE
;
;  000  PRL  28-Jun-82	CREATION - Copied from V7.2-04
;  001  PRL  28-Jun-82  Add "NO STALL" RECORD modifier
;  002  JHC  23-Sep-82 	Remove 'hooks' for feature patch 3.7.3
;  003  JHC  23-Sep-82  Add support for 8BIT characteristic and
;			change VTAB handling for removed characteristic.
;  004	JHC  18-Nov-82	enhance NOSTALL support to inform caller (with XRBC<>0)
;			that LP is still printing.
;  005	FEK  11-Oct-83	Source clear V8-06 patch 3.7.6
;  006	PRL  19-Nov-83	Support 32-bit page counter
;			Support form size passed in FQSIZ
;			Support new <esc> to $ mode
;			Support new NOWRAP mode
;  007	PRL  21-Nov-83	Fix branch bug with LPDVRA assembly
;  008	PRL  22-Nov-83	Add .SPEC function 0 to return 32-bit page counter
;  009	PRL  22-Nov-83	Support default form length in DDB (LPTDFL)
;  010	PRL  08-Jan-84	Support NOTRUNCATE record modifier (LPMNOX)
;			Add .SPEC function 1 to return vertical/horizontal pos
;			Fix ESCAPE mode handling
;  011	PRL  11-Jan-84	Fix horizontal positioning for NOWRAP mode
;  012	PRL  15-Jan-84	Support NOPRINT record modifier (LPMNPR)
;  013	PRL  01-Mar-84	Remove reference to LPTPUC
;			Support LPTTAB characteristic
;			Support BINARY OUTPUT mode
;  014	PRL  04-Mar-84	Force <cr> if not at left margin on close
;			Init DDHORZ on open
;			Treat LPTCHR as a word (delete LPTPUC references)
;  015	PRL  09-Mar-84	Correct carry getting cleared by TSTB DDFLAG(R1)
;			Correct "sense" of BIT instructions
;			Correct references so R3 always points to XRBC
;  016	PRL  14-May-84	Handle special char in binary/non-binary modes
;
;			[RSTS/E V9.2]
;  017  DRP  23-Dec-85  Fix problem with "Special Space" handling.
;
;			[RSTS/E V9.3]
;  018	DBM  01-Feb-87	Return HNGDEV when device is hung and the request
;			has both the stall and no stall bits set.
;
;			[RSTS/E V9.3]
;  019	DBM  20-Apr-87	Return the device before giving error on 8-bit
;			printers when software formatting requested.
;
;			[RSTS/E V10.0]
;  020	DBM  28-Dec-89	Don't bang on the CSR so much.
;			Stall for 10 seconds after printer goes off-line
;
;			[RSTS/E V10.1]
;  021  WRM  26-Dec-90	Modified to use .INCLUDEs
;  022	FEK  5-Dec-90	Fix buffer return race condition
;-

.IF	DF	LPDVRA

; DEFINE IRB

.DSECT

IRBFCN:	.BLKW		;FUNCTION CODE
IRBSTA:	.BLKW		;STATUS
IRBCHN:	.BLKB		;CHANNEL #
IRBRES:	.BLKB		;MS 2 BITS OF 18 BIT UNIBUS ADDR FOR BIG BUF
IRBB18:	.BLKW		;LS 16 BITS OF 18 BIT UNIBUS ADDR FOR BIG BUF
IRBMOD:	.BLKW		;FUNCTION MODIFIER
IRBCON:	.BLKW		;RSTS CONTORTED ADDR FOR BIG BUF
IRBNXT:	.BLKW		;NEXT IRB LINK PTR
IRBBFL:	.BLKW		;DATA LENGTH IN THE BIG BUF
IRBPAR:	.BLKW		;PARAMETERS PASSING OVER (MAY BE MORE THAN ONE)

; DEFINE FUNCTION CODE

PUTFCN	=	0*400	;FUNCTION PUT
OPNFCN	=	2*400	;FUNCTION OPEN
CLOFCN	=	4*400	;FUNCTION CLOSE
FWDABT	=	201	;FUNCTION SUB-MODIFIER - FORWARD ABORT REQUEST

; DEFINE SOME CONSTANTS

BLKSIZ	=	1000	;512 BYTES BLOCK
DFOCNT	=	2	;ALLOW ONLY TWO PENDING O/P BLOCKS
OUTDON	=	2	;DATA OUTPUT DONE STATUS
LERROR	=	6	;LINE PRINTER HUNG STATUS

; DEFINE BRIDGE BLOCK

.DSECT

BBSTS:	.BLKB		;BB STATUS
BBDOFF:	.BLKB		;DATA OFFSET
BBGIRB:	.BLKW		;SUBROUTINE ADDR TO GET IRB/BIG BUF
BBASND:	.BLKW		;SUBROUTINE ADDR TO SEND IRB/BIG BUF
BBAAP5:	.BLKW		;APR5 VALUE FOR THE ABOVE SUBROUTINES
BBDUNT:	.BLKB		;DEVICE CONTROLLER #
BBAUNT:	.BLKB		;AUX PROCESSOR CONTROLLER #
BBDSTA:	.BLKW		;SUBROUTINE ADDR FOR STATUS CHANGED
BBDINT:	.BLKW		;SUBROUTINE ADDR FOR BB INTERRUPT
BBDAP5:	.BLKW		;APR5 VALUE FOR THE ABOVE SUBROUTINES
BBLSTP:	.BLKW		;LST POINTER
BBOCNT:	.BLKB		;PENDING OUTPUT COUNT

.ENDC	;DF	LPDVRA

	DEFORG	LPDVR

	DEFORG	LPDINT

	ORG	LPDVR

.IF	DF	LPDVRA

.TITLE	LPDVRA	LINE PRINTER W/ AUX PROCESSOR SUPPORT

.IFF	;DF	LPDVRA

.IF	DF	LPDVRX

.TITLE	LPDVRX	LINE PRINTER W/ EXTENDED BUFFERING

.ENDC	;DF	LPDVRX

.ENDC	;DF	LPDVRA

; DEFINE 'DDSTS' VALUE FOR LINE PRINTERS

.IF	DF	LPDVRA

STS.LP	==	DDAUX!DDRLO/400
		;AUXILIARY PROCESSOR CAPABILITY
		;WRITE ONLY DEVICE

.IFF	;DF	LPDVRA

STS.LP	==	DDRLO/400
		;WRITE ONLY DEVICE

.ENDC	;DF	LPDVRA

; DEFINE FLAGS FOR LINE PRINTERS

FLG.LP	==	FLGFRC!FLGMOD!FLGPOS!DDRLO!DDNFS!LPTHND
		;BYTE ORIENTED
		;ACCEPT MODIFIERS
		;MAINTAINS POSITION
		;WRITE ONLY
		;NON-FILE STRUCTURED
		;LINE PRINTER

; DEFINE WIDTH

SIZ.LP	==	0
		;VARIABLE LINE WIDTH

; DEFINE DEFAULT BUFFER SIZE

BUF.LP	==	128.
		;DEFAULT BUFFER SIZE IS 128. CHARACTERS

; THIS DRIVER DOESN'T ISSUE ANY ERROR LOGGING CALLS...

ERL$LP	==	0

	TMPORG	LPDINT

LPDINT:	CALLX	INTSAV,R5	;SAVE ALL REGISTERS
	  .WORD	1200		;PAR5 VALUE
	  .WORD	INT$LP		;INTERRUPT SERVICE ENTRY POINT

	UNORG

.SBTTL	THE CHARACTER DISPATCH TABLE

LPDVR:	.BLKB	200		;RESERVE THE DISPATCH TABLE SPACE

.MACRO	LPTDSP	CHAR,LAST
$$$$$$	=	.-LPTDSP/2
$$$$$0	=	$$$$$$
.IIF	LT	$$$$$0,	$$$$$0=^C<$$$$$0>
.ASSUME	$$$$$0&177600 EQ 0
$$$$$0	=	.
.	=	CHAR+LPDVR
	 .BYTE	$$$$$$
.IF	NB	<LAST>
.IF	NE	LAST-CHAR-1
.REPT	LAST-CHAR-1
.NLIST
	.BYTE	$$$$$$
.LIST
.ENDR
.LIST
	 ;	...
.NLIST
.ENDC
	 .BYTE	$$$$$$
.ENDC
.	=	$$$$$0
.ENDM	LPTDSP

.SBTTL	SPECIAL FUNCTION SERVICE

;+
; SPC$LP - SPECIAL FUNCTION SERVICE FOR LINE PRINTERS.			;008+
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB/FCB
;	R2 =  SPECIAL FUNCTION CODE
;	R3 -> XRB
;	R4 =  CALLING JOB NUMBER TIMES 2
;	R5 -> (MAPPED) XRB
;
;	...
;
;	JMP	RTI3
;
;	-OR-
;
;	ERROR	CODE
;
;	SPECIAL FUNCTION CODES:
;
;	0	Return 32-bit page counter in XRBC,XRBC+2 words
;	1	Return vertical/horizontal position in XRBC bytes	;010
;
;-

.ENABL	LSB

SPC$LP::CMP	R2,#SPCBAD	;is the function within range?
	BLO	10$		;yes, continue
	ERROR	PRVIOL		;no, return invalid special function

10$:	ASL	R2		;compute function*2 for indexing
	CALL	@SPCDSP(R2)	;dispatch to function
	JMPX	RTI3		;and jump out via RTI3

; DEFINE CALL TABLE FOR FUNCTIONS

SPCDSP:	.WORD	SPCFN0		; 0 = return 32-bit page counter
	.WORD	SPCFN1		; 1 = return horizontal/vertical pos	;010
SPCBAD	= <.-SPCDSP>/2		;first illegal .SPEC code		;008-

.SBTTL	SPCFN0	- FUNCTION 0:	RETURN 32-BIT PAGE COUNTER TO USER	;008+

;+
; This .SPEC function returns the 32-bit page counter in the user's XRB:
;
;	XRB offset	Value returned
;	----------	--------------
;
;	XRBC+0		lsb of 32-bit page counter
;	    +2		msb of 32-bit page counter
;
;-

SPCFN0:	TST	(R5)+		;bump XRB pointer (R5 -> XRBC)
.ASSUME	XRBC	EQ	2
	MOV	LPTPG0(R1),(R5)+ ;move lsb of counter into (real) XRBC+0
	MOV	LPTPG1(R1),(R5)	;move msb of counter into XRBC+2
	RETURN			;and exit				;008-

.DSABL	LSB

.SBTTL	SPCFN1	- FUNCTION 1:	RETURN POSITION INFORMATION TO USER	;010+

;+
; This .SPEC function returns the following LP position information
; in the user's XRB:
;
;	XRB offset	Byte value returned
;	----------	-------------------
;
;	XRBC+0		vertical position (DDVERC-DDVERT)
;	    +1		horizontal position (DDHORC-DDHORZ)
;
; The values returned range from 0 to n-1, where n is the page width
; or length.  0 indicates left-hand margin or top of page.
;-

SPCFN1:	TST	(R5)+		;bump XRB pointer (R5 -> XRBC)
.ASSUME	XRBC	EQ	2
	MOVB	DDVERC(R1),R2	;get page length
	SUB	DDVERT(R1),R2	;subtract curr vertical position
.ASSUME	DDVERT&1 EQ	0
	MOVB	R2,(R5)+	;move result into (real) XRBC+0
	MOVB	DDHORC(R1),R2	;get line length
	SUB	DDHORZ(R1),R2	;subtract curr horizontal position
.ASSUME	DDHORZ&1 EQ	0
	MOVB	R2,(R5)		;move result into (real) XRBC+1
	RETURN			;and exit				;010-

.DSABL	LSB

.SBTTL	LINE PRINTER OPEN

;+
; OPN$LP - OPEN SERVICE FOR LINE PRINTERS.				;006+
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB (MUST BE PRESERVED)
;	R4 -> FIRQB (DEFAULT FQFLAG AND FQBUFL VALUE LOADED)
;	R5 -> JOB'S IOB ENTRY (MUST BE PRESERVED)
;
;	...
;
;	RETURN
;
;	-OR-
;
;	CALL	RETDEV
;	ERROR	CODE
;-

OPN$LP::MOV	R1,R2		;copy DDB pointer
	ADD	#DDFLAG,R2	;R2 -> DDFLAG word
	MOV	LPTCHR(R1),(R2) ;load characteristics into DDFLAG	;014
	BIC	#^C<LPTALC>,(R2) ;clear all bits except 'allow lowercase' ;014
	CLR	LPTBFG(R1)	;clear buffer check & error status
.ASSUME	LPTERR	EQ	LPTBFG+1
	MOV	FQMODE(R4),R3	;save mode bits in R3
	MOV	FQSIZ(R4),R0	;save FQSIZ (form size if bit 15 on) in R0
	BPL	10$		;bit 15 off, so get form size from FQMODE
	BIC	#^C<377>,R0	;force form size max to 255.
	BR	20$		;and join common

10$:	MOV	R3,R0		;get form size from FQMODE
	BIC	#^C<177>,R0	;force form size max to 127. (bits 6:0)
	BIC	#177,R3		;and clear form size bits in mode
20$:	TST	R0		;any form size specified?
	BNE	30$		;yes, use it
	BISB	LPTDFL(R1),R0	;no, use default
	BIS	#LPTFFT,(R2)	;  and force <ff> for top-of-form
30$:	MOVB	R0,DDVERC(R1)	;load form size
	MOVB	R0,DDVERT(R1)	;init vertical line position
	MOVB	DDHORC(R1),DDHORZ(R1) ;init horizontal line position	;014
	CLR	LPTPG0(R1)	;clear lsb of 32-bit page counter
	CLR	LPTPG1(R1)	;  and msb word too
	ASL	R3		;align mode bits with DDFLAG
	BIC	#^C<LPTCUP!LPTNFC!LPTFFT!LPTOVF!LPTALC!LPTSFT!LPTNOX!LPTCH0!LPTNWR!LPTESC>,R3 ;clear all non-modifier bits
	BIS	R3,(R2)		;load modifier bits into DDFLAG word
	BIT	#LPTALC,R3	;request uppercase only?
	BEQ	40$		;no, continue
	BIC	#LPTALC,(R2)	;yes, clear allow lowercase bit
40$:	BIT	#LPT8BT,LPTCHR(R1) ;is this an 8-bit printer?
	BEQ	45$		;no, continue
	BIT	#LPTSFT,(R2)	;yes, request software formatting?
	BEQ	45$		;no, continue
	CALLX	RETDEV		;Yes.  Return it unless it was assigned	;019
	ERROR	ERRERR		;Now return the error to the user	;019

45$:	BIT	#LPTOVF,(R2)	;no, request skip over perforations?
	BEQ	50$		;no, continue
	CMPB	R0,#6.		;yes, is form length long enough?
	BHI	50$		;yes, continue
	BIC	#LPTOVF,(R2)	;no, clear skip over perfs bit
	.BR	50$		;and continue				;006-

50$:

.IF	DF	LPDVRA

	BIT	#DDAUXA,(R1)	;IS AUX PROCESSOR ACTIVE?
	BEQ	70$		;NO, JUST EXIT
	BUFFER	GETSML		;GET A SMALL BUFFER
	BVC	60$		;IF V CLEAR, WE GOT IT...
	CALLX	RETDEV		;RETURN AS NO BUF ERROR
	ERROR	NOBUFS
60$:	MOV	#OPNFCN,(R4)	;SET FUNCTION TO "OPEN"
	MOV	DDFLAG(R1),IRBPAR(R4) ;DDFLAG IS THE PARAMETER TO PASS OVER
	MOVB	DDVERC(R1),IRBPAR+2(R4) ;FORM LENGTH TOO
	MOVB	DDUNT(R1),R0	;R0 = UNIT #
	ASL	R0		;R0 = UNIT # * 2
	CALLR	LPTSND		;SEND IT TO AUX PROC....
70$:

.ENDC	;DF	LPDVRA

	RETURN			;NOW EXIT

.IF	DF	LPDVRA

.SBTTL	STATUS CHANGE SERVICE

;+
; LPXSTA - STATUS CHANGE SERVICE
;	   CALLED BY AUXILIARY PROCESSOR WHEN STATUS HAVE BEEN CHANGED
;	   IN THE AUXILIARY PROCESSOR.
;
;	R0 =  CONTROLLER # * 2
;	R1 =  UNIT # * 2 WITHIN THE CONTROLLER
;	R4 -> BRIDGE BLOCK
;	BBSTS(R4) = CHANGE STATUS
;		0 -> DISCONNECT REQUEST
;		1 -> START REQUEST
;		2 -> STOP REQUEST
;	PRIORITY IS PR5
;
;	...
;
;	RETURN WITH C CLEAR	(SUCCESS)
;
;	- OR -
;
;	RETURN WITH C SET	(FIALURE)
;
;	ALL REGISTERS PRESERVED
;-

LPXSTA:
	REGSCR			;;SAVE ALL REGISTERS
	MOV	DEV.LP(R0),R1	;;R1 -> LPDDB
	TSTB	(R4)		;;WHAT IS THE STATUS OF BB?
	BNE	5$		;;IF NE, START OR STOP REQUEST

; DISCONNECT REQUEST

	CLR	LPTBBP(R1)	;;DISCONNECT REQUEST, LET'S CLEAR THE BB PTR
	BR	30$		;;AND RETURN

5$:	BMI	20$		;;IF MINUS, KMC IS DEAD
	BITB	#1,(R4)		;;IS IT START REQUEST?
	BNE	15$		;;YES...

; STOP REQUEST

	TSTB	DDCNT(R1)	;;MAKE SURE IT IS NOT INIT'D
	BEQ	10$		;;NO, GOOD...
	SEC			;;SET C TO INDICATE FAILURE STATUS
	RETURN
10$:	BIC	#DDAUXA,(R1)	;;MARK AUX PROCESSOR AS INACTIVE
	BR	30$		;;AND RETURN

; START REQUEST

15$:	CLR	@CSR.LP(R0)	;;DISABLE LP INTERRUPT
	BIS	#DDAUXA,(R1)	;;MARK AUX PROCESSOR AS ACTIVE
	BR	30$		;;AND RETURN

; AUX PROCESSOR IS DEAD, WE ARE DOING NOTHING FOR THAT NOW!

20$:	BIS	#DDSTAT,(R1)	;;INDICATE AUX PROCESSOR IS DEAD
30$:	CLC			;;MAKE SURE C IS CLEAR
	RETURN

GLOBAL	<DEV.LP,CSR.LP>

.SBTTL	BRIDGE BLOCK INTERRUPT SERVICE

;+
; LPXINT - BRIDGE BLOCK INTERRUPT SERVICE
;	   CALLED BY AUXILIARY PROCESSOR WHEN AN INTERRUPT FROM AUXILIARY
;	   PROCESSOR HAS TO BE DELIVERED TO THE DRIVER.
;
;	R0 =  CONTROLLER # * 2
;	R1 =  UNIT # * 2 WITHIN THE CONTROLLER
;	R2 -> IRB
;	R3 =  INTERRUPT STATUS [OUTDON OR LERROR]
;	R4 -> BRIDGE BLOCK
;
;	RETURN		(ALL REGISTERS ARE PRESERVED EXCEPT R1 AND R4)
;
; WHEN A BLOCK OF DATA HAS BEEN OUTPUT, THE AUXILIARY PROCESSOR WILL CALL
; THIS DRIVER THROUGH THIS ENTRY POINT.
;-

LPXINT:	MOV	DEV.LP(R0),R1	;;R1 -> LPDDB
	BIC	#DDSTAT,(R1)	;;ASSUME NO ERROR
	CMP	#LERROR,R3	;;WE GOT HUNG LP?
	BEQ	20$		;;YES...
	MOV	R4,-(SP)	;;SAVE R4 ONTO STACK
	MOV	IRBCON(R2),R4	;;R4 = CONTORTED ADDR FOR BIG BUFF
	BEQ	10$		;;IF ZERO, NO BIG BUFF...
	BUFFER	RETURN		;;RETURN BIG BUFF
10$:	MOV	R2,R4		;;R4 -> IRB
	MOV	IRBNXT(R4),R2	;;R2 -> NEXT IRB OR -0-
	BUFFER	RETSML		;;RETURN IRB
	MOV	(SP)+,R4	;;RESTORE BB PTR
	DECB	BBOCNT(R4)	;;ONE LESS PENDING O/P
	TST	R2		;;ANY MORE IRB?
	BNE	LPXINT		;;NO, GO AGAIN...
	BR	40$		;;GO TO COMMON CODES TO RESTART JOB...

20$:	BIS	#DDSTAT,(R1)	;;INDICATE HUNG PRINTER
	BIT	#LPTBOK,DDFLAG(R1) ;;IS BUFFER CHAIN OWNED?		;015
	BEQ	30$		;;ALWAYS FLUSH ON ERROR IF NOT		;015
	TSTB	DDCNT(R1)	;;INIT'D NOW??
	BNE	40$		;;YES, SO DON'T CLEAR THE BUFFER CHAIN
30$:	CLR	R2		;;INDICATE NO IRB
	MOV	#FWDABT,R3	;;SET SUB-FUNCTION TO FORWARD ABORT
	CALLBB	BBASND		;;GIVE IT TO AUX PROCESSOR
40$:	CALLX	IOFINI,R5,JS.LP	;;RESTART JOB
	RETURN			;;RETURN TO CALLER....

GLOBAL	<DEV.LP,JS.LP>

.ENDC	;DF	LPDVRA

.SBTTL	DEVICE DEASSIGNMENT SERVICE

;+
; DEA$LP - DEVICE DEASSIGNMENT SERVICE FOR LINE PRINTERS.
;
;	R1 -> DDB
;
;	...
;
;	RETURN		(WITH ALL REGISTERS PRESERVED)
;-

.ENABL	LSB

DEA$LP::

.IF	DF	LPDVRA

	BIT	#DDAUXA,(R1)	;IS AUX PROCESSOR ACTIVE?
	BNE	60$		;YES, JUST EXIT

.ENDC	;DF	LPDVRA

.IF	DF	LPDVRX

	MOV	R4,-(SP)	;SAVE R4
	SPLC	4		;No interrupts (they may change LPTIRB)	;022
	MOV	LPTIRB(R1),R4	;;GET IRB/DATA BUFFER INDICATOR
	BEQ	10$		;;NOTHING THERE, SO NOTHING TO DO
	BIT	R4,#40-1	;;DO WE HAVE AN UNUSED IRB/DATA BUFFER PAIR?
	BNE	10$		;;NO
	CALLX	RETIRB		;;YES, RETURN IT NOW
10$:	CLR	LPTIRB(R1)	;;INDICATE NO IRB/BUFFER PAIR EXISTS
	SPLC	3		;;Interrupts are OK now.		;022
	MOV	(SP)+,R4	;RESTORE R4

.ENDC	;DF	LPDVRX

.IF	DF	LPDVRA

	BR	50$		;NOW FORCE AN INTERRUPT

.IFF	;DF	LPDVRA

	.BR	50$		;NOW FORCE AN INTERRUPT

.IFTF	;DF	LPDVRA

.SBTTL	DEVICE ASSIGNMENT SERVICE

;+
; ASN$LP - DEVICE ASSIGNMENT SERVICE FOR LINE PRINTERS.
;
; IF CALL BY A JOB
;
;	R0 =  JOB NUMBER OF ASSIGNER TIMES 2
;	R1 -> DDB
;
;	...
;
;	RETURN		(WITH ALL REGISTERS PRESERVED)
;
; IF CALL BY UUO HANDLER
;
;	R0 -> BRIDGE BLOCK
;	R1 -> DDB
;
;	...
;
;	RETURN		(WITH ALL REGISTERS PRESERVED)
;-

ASN$LP::

.IFT	;DF	LPDVRA

	BIT	(PC)+,R0	;FIRST OF ALL, FIND OUT WHO THE CALLER IS?
	.BYTE	0,-1
	BEQ	40$		;IF MSB IS ZERO, IT IS A JOB...
	TSTB	DDJBNO(R1)	;CALLED BY UUO, CAN'T ACCEPT UNLESS WE'RE IDLE
	BNE	20$		;IF NOT, REJECT THE CONNECTION....
	CMP	DDBUFC+FP(R1),DDBUFC+EP(R1) ;MAKE SURE CHAIN IS EMPTY
	BNE	20$		;NO, REJECT IT....
	TST	LPTPSP(R1)	;TRULY EMPTY?
	BNE	20$		;NO, REJECT IT....
	MOV	R4,-(SP)	;SAVE R4 ONTO STACK
	CALLX	CLRBUF,R5,DDBUFC+EP ;CLEAR THE BUFFER CHAIN
	MOVB	DDUNT(R1),R4	;R4 = UNIT #
	ASL	R4		;R4 = UNIT # * 2
	CLR	TIM.LP(R4)	;CLEAR THE TIMEOUT TIMER
	CLR	@CSR.LP(R4)	;DISABLE INTERRUPT
	MOV	(SP)+,R4	;RESTORE R4
	MOV	#LPXSTA,BBDSTA(R0) ;MOVE STATUS CHANGE ROUTINE ADDR INTO BB
	MOV	#LPXINT,BBDINT(R0) ;MOVE INTERRUPT SERV RTN ADDR INTO BB
	MOV	R0,LPTBBP(R1)	;SAVE BB ADDR IN LPDDB
	;CLC			;CARRY CLEAR FROM CLR ABOVE
	RETURN			;RETURN TO UUO HANDLER....
20$:	SEC			;SET C BIT TO REJECT THE CONNECTION
30$:	RETURN			;RETURN TO UUO HANDLER....

GLOBAL	<TIM.LP,CSR.LP>

; WE ARE CALLED BY A JOB

40$:	TST	LPTBBP(R1)	;HAS THE BRIDGE TO AUX PROC BEEN MADE?
	BEQ	50$		;NO, WE WILL FORCE AN INTERRUPT...
	BIT	#DDAUXA,(R1)	;IS THE CONNECTION ACTIVE?
	BNE	30$		;YES, JUST RETURN TO CALLER (JOB)....
	ERROR	NOTAVL		;NO, TOO BAD, USER HAS TO WAIT....

.ENDC	;DF	LPDVRA

50$:	MOV	R0,-(SP)	;SAVE R0
	MOVB	DDUNT(R1),R0	;GET UNIT NUMBER
	ASL	R0		; TIMES 2 FOR WORD ADDRESSING
	CALL	LPTGO		;NOW FORCE A PRINTER INTERRUPT
	MOV	(SP)+,R0	;RESTORE R0
60$:	RETURN			; AND EXIT

.DSABL	LSB

.SBTTL	USER LEVEL SERVICE

;+
; SER$LP - USER LEVEL READ/WRITE SERVICE.
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB/FCB
;	R2 =  2 (.READ)
;	      4 (.WRITE)
;	R3 -> XRB
;	R4 =  CALLING JOB NUMBER TIMES 2
;	R5 -> USER'S BUFFER (THROUGH APR 6)
;	IF Z=1 OR C=0 THEN THIS IS THE FIRST CALL
;	IF Z=0 OR C=1 THEN THIS IS A "REDO" CALL
;-

SER$LP::

.IF	DF	LPDVRA

	BIT	#DDAUXA,(R1)	;IS THE AUX PROCESSOR ACTIVE?
	BEQ	20$		;NO
	MOV	LPTBBP(R1),R4	;R4 -> BRIDGE BLOCK
	BIT	#LPTBOK,DDFLAG(R1) ;DOES CALLER OWN BUFFER CHAIN?	;015
	BNE	40$		;YES					;015
	TSTB	BBOCNT(R4)	;ANY PENDING O/P?
	BEQ	30$		;NO, CONTINUE...
10$:	JMPX	IOREDO		;YES, STALL THE JOB...
20$:

.ENDC	;DF	LPDVRA

	CALL	LPTGO		;ALWAYS CHECK OUT THE PRINTER
	BIT	#LPTBOK,DDFLAG(R1) ;DOES CALLER OWN BUFFER CHAIN?	;015
	BNE	40$		;YES					;015
	CMP	DDBUFC+FP(R1),DDBUFC+EP(R1) ;NO, CHAIN EMPTY NOW??
	BNE	25$		;NOT EMPTY YET, STALL THIS JOB
	TST	LPTPSP(R1)	;TRULY EMPTY??
	BEQ	30$		;yes, go ahead
.ASSUME	LPTICH	EQ 	LPTPSP+1
	;CLC			;C=0 (FIRST CALL) FROM 'TST' ABOVE
25$:	JMP	230$		;Stall the job, we're not empty
30$:	BIS	#LPTBOK,DDFLAG(R1) ;EMPTY NOW, SAY CHAIN OWNED
40$:	BCS	70$		;NOT FIRST CALL (C=1), JUST CONTINUE
	CLR	XRBLK(R3)	;FIRST CALL, INDICATE SEQUENTIAL DEVICE
	CLRB	XRBLKM(R3)	; IN BOTH PLACES
	BIT	#LPMCLB,XRMOD(R3) ;REQUEST CLEAR BUFFERS BEFORE TRANSFER?
	BEQ	50$		;NOT THIS TIME
	CALL	LPTFLS		;YEP, SO DO IT
50$:	CLRB	LPTBQC(R1)	;INITIALLY SAY AWAKEN EARLY
	BIT	#LPMSOC,XRMOD(R3) ;REQUEST STALL UNTIL OUTPUT COMPLETE?
	BEQ	60$		;NO
	MOVB	(PC),LPTBQC(R1)	;YES, SET FLAG FOR LATER AWAKENING
.ASSUME	LPTBQC&377 NE 0
60$:	TSTB	LPTERR(R1)	;HAVE WE GIVEN THE ERROR YET?
	BEQ	70$		;NOPE, MUST TAKE THIS REQUEST
	TST	(R1)		;YEP, IS PRINTER STILL HUNG NOW?
	BMI	190$		;STILL HUNG UP, KEEP GIVING THE ERROR

.IF	DF	LPDVRA

	BIT	#DDAUXA,(R1)	;IS AUX PROCESSOR ACTIVE?
	BNE	240$		;YES, GOTO 240$

.ENDC	;DF	LPDVRA

	CALLX	FREBUF,R5,BFQ.LP ;NOT NOW HUNG, BUT ARE THERE ENOUGH BUFFERS??
	BCS	190$		;KEEP GIVING THE ERROR UNTIL BUFFERS AVAILABLE
70$:

.IF	DF	LPDVRA

	BIT	#DDAUXA,(R1)	;IS AUX PROCESSOR ACTIVE?
	BNE	240$		;YES

.ENDC	;DF	LPDVRA

GLOBAL	<BFQ.LP>

	PUSH	#LPMSOC!LPMNST	;Get STALL and NO STALL bits on stack	;018
	BIC	XRMOD(R3),(SP)+	;Were BOTH set?				;018
	BNE	75$		;Nope.					;018
	CMP	DDBUFC+FP(R1),DDBUFC+EP(R1) ;see if the buffer chain is empty
	BNE	175$		;not empty, go check for a hung device	;018
	TST	LPTPSP(R1)	;truly empty?
	BNE	175$		;nope, check for a hung device		;018
75$:	MOVB	(PC),LPTBFG(R1)	;SIGNAL INITIAL BUFFER CHECK
.ASSUME	LPTBFG&377 NE 0

.IF	DF	LPDVRX

	MOV	LPTIRB(R1),R2	;GET CURRENT IRB/DATA BUFFER PAIR IF ANY
	BEQ	80$		;NONE
	BIT	R2,#40-1	;ONE, IS IT STILL AVAILABLE?
	BEQ	100$		;YEP, JUST TRY TO USE IT
80$:	CLR	LPTIRB(R1)	;ELSE NO IRB/DATA BUFFER PAIR INDICATION
	MOV	XRBC(R3),R2	;GET USER'S TOTAL BYTE COUNT
	CMP	R2,#512.+77&177700-BUFHDR ;BIG ENOUGH FOR XBUF?
	BLO	100$		;NO, DON'T TRY TO USE XBUF
	CMP	R2,#8000.	;YES, WITHIN A REASONABLE MAXIMUM?
	BLOS	90$		;YEP, USE ACTUAL REQUEST
	MOV	#8000.,R2	;NOPE, USE SOMETHING REASONABLE
90$:	CALLX	GETIRX		;ATTEMPT XBUF ALLOCATION
	BCS	100$		;FAILED, FORGET IT...
	MOV	R2,LPTIRB(R1)	;O.K., STORE NEW IRB/DATA BUFFER INDICATION
100$:

.ENDC	;DF	LPDVRX

	BR	150$		;CARRY ON IN COMMON CODE

110$:	CALLX	FREBUF,R5,BFQ.LP ;CHECK FOR FREE BUFFERS AGAINST FUDGE FACTOR
	BCS	160$		;FAILURE, SO STALL FOR NOW
120$:	CLRB	LPTBFG(R1)	;SAY ALL IS O.K. IN BUFFER LAND
130$:	TSTB	LPTBFG(R1)	;SHOULD WE CHECK BUFFERING?
	BNE	110$		;YES, SO GO DO THE CHECK
	GETUSR			;GET A CHARACTER FROM THE USER'S BUFFER
	BIT	#LPMBIN,XRMOD(R3) ;binary output requested?		;013
	BEQ	135$		;no, continue				;013
	TSTB	LPTSPC(R1)	;yes, any special character?		;016
	BEQ	133$		;no, continue				;016
	CMPB	R2,LPTSPC(R1)	;yes, is this the spec char?		;016
	BNE	133$		;no, so continue			;016
	MOV	#100040,R2	;yes, load 'special' space char		;016
	BR	287$		;and skip to buffer the char		;016

133$:	BIT	#LPT8BT,LPTCHR(R1) ;allow 8-bit characters?		;013
	BNE	287$		;yes, so just send it			;013
	BIC	#200,R2		;no, clear character's sign bit		;013
	BR	287$		;and go send it				;013

135$:	TST	R2		;CHECK THE FETCHED CHARACTER
	BMI	285$		;IF SIGN BIT ON, THEN CHECK FOR SPECIAL
140$:	INC	XRLOC(R3)	;COUNT AS FETCHED (XRLOC<-XRLOC+1)	;015
	DEC	XRBC(R3)	; AND USED (XRBC<-XRBC-1)		;015
	CALL	LPTSRT		;NOW DO OUR "THING" WITH CHARACTER
150$:	TST	XRBC(R3)	;MORE TO TRANSFER?			;015
	BNE	130$		;CONTINUE TRANSFERING UNTIL NO MORE
	;CLC			;FLAG NO PROBLEM WITH BUFFERING
160$:	CALL	LPTGO		;START THE LINE PRINTER
170$:	BIT	(R1),(R1)	;IS THE PRINTER NOW HUNG?
	BPL	210$		;NOPE
	BCC	180$		;YEP, BUT ALL HAS BEEN BUFFERED
	CMP	FREES+2,#20.	;DOWN TO <= 20. FREE BUFFERS?
	BLOS	190$		;YES, SO WE MUST(!) QUIT
	TSTB	LPTBFG(R1)	;NOT ALL BUFFERED, WERE TO CONTINUE?
	BNE	120$		;CONTINUE IN MAINLINE LOOP
	BR	300$		;CONTINUE IN FORMATTING CODE

175$:	TST	(R1)		;STALL and NO STALL, is device online?	;018
	BPL	200$		;Yep.  Return XRBC<>0 and no error	;018
.ASSUME	DDSTAT	EQ 100000
180$:	TSTB	LPTERR(R1)	;DID WE GIVE AN ERROR LAST TIME?
 	BNE	220$		;YES, CANNOT GIVE AN ERROR NOW THEN...
190$:	SETERR	HNGDEV,@IOSTS	;INDICATE THE ERROR
200$:	MOVB	@IOSTS,LPTERR(R1) ;REMEMBER LAST STATUS PASSED TO USER
	JMPX	IOEXIT		;NOW RETURN TO THE USER

210$:	BCS	230$		;STALL THE USER IF CARRY SET
220$:	BIT	#LPMSOC,XRMOD(R3) ;REQUEST STALL UNTIL OUTPUT COMPLETE?	;015
	BEQ	200$		;NO, SO DON'T STALL
	CMP	DDBUFC+FP(R1),DDBUFC+EP(R1) ;ALL DATA SENT TO PRINTER?
	BNE	230$		;NO, STALL
	TST	LPTPSP(R1)	;TRULY ALL SENT?
	BEQ	200$		;YES. DON'T STALL
.ASSUME	LPTICH	EQ	LPTPSP+1
230$:	BIT	#LPMNST,XRMOD(R3) ;REQUEST NO STALL?			;015
	BNE	200$		;YES, SO DON'T STALL
	JMPX	IOREDO		;NO, STALL THE USER

GLOBAL	<BFQ.LP,FREES,HNGDEV>

.IF	DF	LPDVRA

240$:	TST	(R1)		;LINE PRINTER HUNG?
	BMI	260$		;YES, SO DO NOT LOOK AT THE QUOTA, JUST GO...
	CMPB	#DFOCNT,BBOCNT(R4) ;HAVE WE EXCEEDED THE QUOTA YET?
	BLOS	230$		;YES, WAIT THEN....
260$:	TST	XRBC(R3)	;ANY MORE TO TRANSFER?			;015
	BEQ	170$		;NO, TIME TO EXIT....
	MOV	#BLKSIZ,R2	;R2 = DESIRED BLOCK SIZE TO STORE DATA
	CMP	R2,XRBC(R3)	;MAY A BLOCK CONTAIN ALL DATA IN USER BUF? ;015
	BLO	270$		;NO, THEN WE JUST ASK FOR A BLOCK
	MOV	XRBC(R3),R2	;THEN WE ONLY NEED THAT MANY BYTES..	;015
270$:	SUB	R2,XRBC(R3)	;WE WILL HAVE THAT MUCH DONE NOW!!!	;015
	ADD	R2,XRLOC(R3) 	;UPDATE BUFFER POINTER			;015
	MOV	R2,-(SP)	;(SP) = DATA LENGTH
	ADD	#BUFHDR,R2	;ADD LENGTH OF HEADER
	CALLBB	BBGIRB		;GO AND GET AN IRB/BIG BUF
	BCC	280$		;GOT IT, GOOD
	TST	(SP)+		;REMOVE DATA LENGTH FROM STACK
	TST	(R1)		;LINE PRINTER HUNG?
	BMI	190$		;YES, WE MUST QUIT...
	BR	230$		;TRY AGAIN LATER....
280$:	MOV	IRBCON(R2),R4	;R4 -> BIG BUFFER	
	MOV	XRMOD(R3),IRBMOD(R2) ;MOVE RECORD MODIFIER INTO IRB	;015
	MOV	(SP)+,IRBBFL(R2) ;FILL IN DATA SIZE
	MOV	R2,-(SP)	;(SP) -> IRB
	MOV	IRBBFL(R2),R2	;R2 = # OF BYTES TO MOVE
	MOV	R2,R0		;R0 = # OF BYTES TO MOVE TOO!
	CALLX	BLKMOV		;MOVE DATA FROM USER BUF TO BIG BUF
	ADD	R2,R5		;UPDATE BUFFER POINTER IN R5
	MOV	(SP)+,R2	;R2 -> IRB
	MOVB	DDUNT(R1),R0	;R0 = UNIT #
	ASL	R0		;R0 = UNIT # * 2
	MOV	LPTBBP(R1),R4	;R4 -> BB
	INCB	BBOCNT(R4)	;ONE MORE PENDING BLO/P
	CALLBB	BBASND		;SEND THE BLOCK TO AUX PROCESSOR....
	BR	240$		;GO AGIN...

.ENDC	;DF	LPDVRA

.SBTTL	SPECIAL CHARACTERS (SIGN BIT ON) COME HERE

285$:	BIT	#LPT8BT,LPTCHR(R1) ;ALLOWING 8-BIT CHARS?
	BEQ	290$		;NO, CONSIDER REASON FOR SIGN BIT ON.
287$:	INC	XRLOC(R3)	;OTHERWISE, COUNT AS CHARACTER		;015
	DEC	XRBC(R3)	; DONE					;015
	CALL	LPTSTO		;AND STORE IT
	BR	150$		;CONTINUE WITH MORE DATA IF ANY

290$:	BIC	#^C<177>,R2	;TRIM OFF SIGN BIT
	BIT	#LPTSFT,DDFLAG(R1) ;SOFTWARE FORMATTING?		;015
	BEQ	140$		;IF NOT THEN NORMAL DATA ALSO
	CALLX	FREBUF,R5,BFQ.LP ;IF FORMATTING THEN CHECK BUFFERING
	BCS	160$		;FAILURE, STALL FOR NOW
300$:	CLR	-(SP)		;FORM A FULL ZERO WORD
	MOVB	DDVERC(R1),(SP)	;GET FORM LENGTH
	SUB	R2,(SP)		; AND FIND (LENGTH)-(REQUEST)
	BLE	320$		;IF IMPOSSIBLE THEN IGNORE IT
310$:	CALL	LPTLFO		;LINE FEED THE PRINTER
	CMPB	(SP),DDVERT(R1)	;ARE WE AT THE SPECIFIED SPOT?
	BNE	310$		;NOT YET, KEEP LINE FEEDING
320$:	INC	XRLOC(R3)	;YES, COUNT AS CHARACTER		;015
	DEC	XRBC(R3)	; AND DEC CHARACTER COUNT		;015
	TST	(SP)+		;DUMP THE FORM LINE VALUE
	JMP	150$		; AND CONTINUE WITH MORE DATA IF ANY	;007

.IF	DF	LPDVRX

STORIT:	MOV	R3,-(SP)	;;SAVE R3
	MOV	LPTIRB(R1),R3	;;GET IRB/DATA BUFFER INDICATOR
	CALLX	STOIRB,R5,DDBUFC+FP ;;GO BUFFER USING IRB IF ANY
	MOV	R3,LPTIRB(R1)	;;SAVE NEW IRB/DATA BUFFER INDICATOR
	MOV	(SP)+,R3	;;RESTORE R3
	RETURN			;;EXIT

.ENDC	;DF	LPDVRX

GLOBAL	<BFQ.LP>

.SBTTL	TIMEOUTS

;+
; TMO$LP - TIME OUT ENTRY POINT.
;
;	R0 =  UNIT NUMBER TIMES TWO
;	R1 -> DDB
;	R3 -> CSR
;	PRIORITY IS PR5
;
;	...
;
;	RETURN
;-

.ENABL	LSB

TMO$LP::

.IF	DF	LPDVRA

	BIT	#DDAUXA,(R1)	;;HAVE WE BEEN CONNECTED?
	BNE	30$		;;YES, JUST RETURN

.ENDC	;DF	LPDVRA

	BIT	(R3),#100200	;;WHAT KIND OF HANG IS THIS?
	BGT	LPTGO		;;Ready but no interrupt, clear it	;020
	.BR	LPTHNG		;;Call it a hung device			;020

LPTHNG:	BIS	#DDSTAT,(R1)	;;INDICATE HUNG PRINTER
	BIT	#LPTBOK,DDFLAG(R1) ;;IS BUFFER CHAIN OWNED?		;015
	BEQ	LPTFLS		;;ALWAYS FLUSH ON ERROR IF NOT		;015
	TSTB	DDCNT(R1)	;;INIT'D NOW??
	BNE	10$		;;YEP, SO DON'T CLEAR THE BUFFER CHAIN
LPTFLS:	CALLX	CLRBUF,R5,DDBUFC+EP ;;CLEAR THE BUFFER CHAIN
	CLR	LPTPSP(R1)	;; AND CLEAR PENDING THINGS
.ASSUME	LPTICH	EQ	LPTPSP+1
	MOVB	DDVERC(R1),DDVERT(R1) ;;INDICATE TOP-OF-FORM NOW
10$:	CALLX	IOFINI,R5,JS.LP	;;AWAKEN THE USER FROM LP WAIT IF ANY
	BR	20$		;;Wait 10 seconds before trying again	;020
;;020+
;;NOTE:	Timeout will be cancelled if user issues another .WRITE
;;	Otherwise, we end up giving the printer some time to come
;;	back on-line without eating all of the system idle time
;;	banging on the CSR
;;020-

.SBTTL	ROUTINE TO START A LINE PRINTER

; THIS ROUTINE DOESN'T AFFECT THE CARRY BIT

LPTGO:	BIS	#100,@CSR.LP(R0) ;Interrupt enable the printer		;020
20$:	MOV	#10.,TIM.LP(R0)	;Set the timeout value			;020
30$:	RETURN			;EXIT

.DSABL	LSB

GLOBAL	<JS.LP,CSR.LP,TIM.LP>

.SBTTL	LINE PRINTER CLOSE

;+
; CLS$LP - CLOSE SERVICE FOR LINE PRINTERS.
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB/FCB
;	R5 -> DDB/FCB (MUST BE PRESERVED)
;	IF Z=1 THEN A REAL CLOSE CALL
;	IF Z=0 THEN A "RESET" CLOSE CALL
;
;	...
;
;	RETURN
;-

.ENABL	LSB

CLS$LP::BNE	40$		;RESET CLOSE, SO DON'T BUFFER ANYTHING

.IF	DF	LPDVRA

	BIT	#DDAUXA,(R1)	;IS AUX PROCESSOR ACTIVE?
	BEQ	20$		;NO, GO HANDLE IT OURSELVES
	BUFFER	GETSML		;GET AN IRB
	BVS	10$		;IF V SET, NO BUF, TOO BAD, JUST LEAVE...
	MOV	#CLOFCN,(R4)	;MOVE FUNCTION CODE ("CLOSE")
LPTSND:	CLR	IRBCON(R4)	;CLEAR CONTROTED BUFF ADDR
	CLR	IRBNXT(R4)	;CLEAR NEXT IRB LINK
	CLR	IRBBFL(R4)	;CLEAR DATA LENGTH
	MOV	R4,R2		;R2 -> IRB
	MOV	LPTBBP(R1),R4	;R4 -> BRIDGE BLOCK
	INCB	BBOCNT(R4)	;ONE MORE TO GO
	CALLBB	BBASND		;GIVE IT TO THE AUX PROCESSOR
10$:	RETURN
20$:

.ENDC	;DF	LPDVRA

	MOV	#<ZERO-XRMOD>,R3 ;load 'fake' XRB addr (so XRMOD=0)	;014
	BIT	#LPTNFC,DDFLAG(R1) ;SHOULD WE FORM FEED ON CLOSING?	;015
	BNE	30$		;NO, continue				;014
	CALLX	FREBUF,R5,BFQ.LP ;CHECK FOR ROOM AVAILABLE
	BCS	40$		;NO ROOM
	MOV	PC,-(SP)	;DO BELOW CODE TWICE
	CALL	60$		;GET TO TOP OF FORM
30$:	CMPB	DDHORZ(R1),DDHORC(R1) ;are we at left margin?		;014
	BEQ	40$		;yes, so exit				;014
	CALLX	FREBUF,R5,BFQ.LP ;no, is buffer space available?	;014
	BCS	40$		;no, so exit				;014
	CALL	LPTCRO		;yes, go output a <cr>			;014

40$:

.IF	DF	LPDVRA

	BIT	#DDAUXA,(R1)	;IS AUX PROCESSOR ACTIVE?
	BNE	10$		;YES, JUST LEAVE

.ENDC	;DF	LPDVRA

	CALLR	LPTGO		;DONE, EXIT

GLOBAL	<BFQ.LP,ZERO>

.SBTTL	CHARACTER PROCESSING

LPTDSP	000,177	;ALL COME HERE INITIALLY...
50$:	TST	DDFLAG(R1)	;USE UPARROW STYLE CONTROLS?
	BPL	80$		;NO
.ASSUME	LPTCUP	EQ	100000
	BIS	#100,R2		;YES, MAKE THE CONTROL PRINTABLE
	CALL	130$,R2		;SAVE CHARACTER FOR LATER PROCESSING
	MOV	#'^,R2		;NOW SET THE PREFIX UPARROW
	BR	LPTBUF		; AND GO BUFFER IT

LPTDSP	004	;EOT							;012
	BIT	#LPTEOT,LPTCHR(R1) ;DO WE PROCESS THE <EOT>?		;015
	BEQ	50$		;NO, TREAT AS NON-PRINTABLE
	JMP	LPTRST		;YES, GO RESET THINGS AND SEND IT

LPTDSP	014	;FORM FEED
60$:	CALL	GETTOF		;TRY TO GET TO TOP OF FORM
	CMPB	DDVERT(R1),DDVERC(R1) ;TOP OF FORM YET?
	BNE	60$		;NOPE, KEEP TRYING
	RETURN

LPTDSP	033	;ESCAPE							;006
	BIT	#LPTESC,DDFLAG(R1) ;convert <esc> to $?			;015
	BEQ	80$		;no, check if output controls enabled	;010
	MOV	#'$,R2		;yes, change it to a $			;006
	BR	LPTBUF		;and go buffer it			;006

80$:	BIT	#LPTNPC,LPTCHR(R1) ;SHOULD WE OUTPUT CONTROLS?		;015
	BNE	LPTSTO		;YES
LPTDSP	000	;NULL
LPTDSP	177	;DEL
90$:	RETURN			;IGNORE CHARACTER

LPTDSP	010	;BACKSPACE
	BIT	#LPTNBS,LPTCHR(R1) ;DO <BACKSPACE> FOR THIS PRINTER?	;015
	BNE	50$		;NOPE, TREAT AS NON-PRINTING
	CMPB	DDHORZ(R1),DDHORC(R1) ;YEP, ALREADY AT THE LEFT MARGIN?
	BHIS	90$		;IGNORE IT IF SO
	INCB	DDHORZ(R1)	;ELSE CORRECT THE HORIZONTAL POSITION
	BIT	#LPTRBS,LPTCHR(R1) ;YEP, OUTPUT AS <BS>??		;015
	BNE	LPTSTO		;REAL IT IS, SO OUTPUT IT
	MOVB	DDHORZ(R1),-(SP) ;SAVE CORRECTED POSITION OF <BS>
	CALL	LPTCRO		;SEND <CR> TO RESTORE CARRIAGE
100$:	CMPB	DDHORZ(R1),(SP)	;WHERE WE WANT TO BE YET??
	BLOS	110$		;YES, EXIT
	MOV	#100$,-(SP)	;NO, SET THE RETURN ADDRESS TO CHECK AGAIN
LPTSPO:	MOV	#40,R2		;SET CHARACTER TO <SPACE>
	BR	LPTBUF		; AND SEND IT OUT

110$:	TST	(SP)+		;POP SAVED HORIZONTAL POSITION
	RETURN			; AND EXIT

LPTDSP	011	;TAB
	CALLR	LPTAB		;call the tab processor & return	;013

LPTDSP	140,176	;LOWER CASE GRAPHICS
	BIT	#LPTALC,DDFLAG(R1) ;UPPER CASE ONLY?			;015
	BNE	LPTBUF		;LEAVE LOWER CASE AS LOWER CASE
	BIC	#40,R2		;MAKE LOWER CASE INTO UPPER CASE
	BR	LPTBUF		; AND, THEN, CONTINUE

120$:	CMPB	R2,LPTSPC(R1)	;THE SPECIAL CHARACTER?
	BNE	140$		;NO
	MOV	#100040,R2	;YES, SUBSTITUTE "SPECIAL" SPACE
	BR	LPTBUF		; AND GO PROCESS IT

130$:	CALL	(R2)		;RETURN TO CALLER WITH A RETURN ADDRESS
	MOV	(SP)+,R2	;RESTORE THE SAVED CHARACTER
	CMP	R2,#100040	;Special Space?				;017
	BEQ	LPTBUF		;Yes, go process it			;017

.SBTTL	MAIN LINE PRINTER CHARACTER CODE

LPTSRT:	TSTB	LPTSPC(R1)	;DOES A SPECIAL CHARACTER EXIST?
	BNE	120$		;YES, SO CHECK FOR IT
140$:	MOVB	LPDVR(R2),R4	;GET ENTRY FROM THE DISPATCH TABLE
	ASL	R4		; DOUBLE IT
	ADD	R4,PC		;  AND DISPATCH ON IT...

LPTDSP:				;REFERENCE ONLY
LPTDSP	040,137	;NORMAL UPPER CASE GRAPHICS
LPTBUF:	DECB	DDHORZ(R1)	;WILL THIS CHARACTER FIT ON THIS LINE?
	BEQ	190$		;NOPE, SEE WHAT TO DO WITH IT THEN
	CMPB	DDVERT(R1),#6.	;ONLY 6. LINES LEFT ON THIS PAGE?
	BLOS	200$		;YES, CHECK FOR PERFORATION SKIPPING

LPTSTO:	TSTB	R2		;trying to output a null?		;013
	BEQ	180$		;yes, so ignore the character		;013
	BIT	#LPMNPR,XRMOD(R3) ;no, request NOPRINT?			;012
	BNE	180$		;yes, so ignore the character		;012
	SPLC	4		;;LOCKOUT LP INTERRUPTS NOW
	CMP	R2,#40		;;is this a real space char?		;016
	BNE	150$		;;no, continue				;016
	TSTB	LPTSPC(R1)	;;yes, using special character?		;016
	BEQ	145$		;;no, so try to compress it		;016
	DEC	R2		;;yes, use 37(8) as a space instead	;016
	BR	150$		;;and skip space compression		;016

145$:	BIT	#LPT8BT,LPTCHR(R1) ;;SENDING 8-BIT CHARS TO PRINTER?
	BNE	160$		;;YES, CAN'T COMPRESS SPACES
	DECB	LPTPSP(R1)	;;COUNT THE PENDING SPACE(S)
	BMI	170$		;;COUNT STILL O.K., JUST EXIT
	INCB	LPTPSP(R1)	;;COUNT OVERFLOWED, CORRECT IT
150$:	MOVB	LPTPSP(R1),R4	;;GET POSSIBLE PENDING SPACE COUNT
	BEQ	160$		;;NONE, JUST BUFFER THIS CHARACTER
	MOV	R2,-(SP)	;;SOME, SAVE THE DESIRED CHARACTER
	MOV	R4,R2		;;SET THE PENDING SPACE COUNT (<0)

.IF	DF	LPDVRX

	CALL	STORIT		;; AND GO BUFFER IT

.IFF	;DF	LPDVRX

	CALLX	STORE,R5,DDBUFC+FP ;; AND GO BUFFER IT

.ENDC	;DF	LPDVRX

	MOV	(SP)+,R2	;;RESTORE THE DESIRED CHARACTER
	CLRB	LPTPSP(R1)	;;INDICATE NO PENDING COUNT NOW
160$:	MOV	DDBUFC+BC(R1),-(SP) ;;SAVE THE BUFFER COUNT

.IF	DF	LPDVRX

	CALL	STORIT		;;STORE THE CHARACTER

.IFF	;DF	LPDVRX

	CALLX	STORE,R5,DDBUFC+FP ;;STORE THE CHARACTER

.ENDC	;DF	LPDVRX

	CMP	(SP)+,DDBUFC+BC(R1) ;;IS THIS A NEW BUFFER
	BEQ	170$		;;SAME OLD BUFFER
	MOVB	(PC),LPTBFG(R1)	;;SIGNAL BUFFER NEEDS CHECKING
.ASSUME	LPTBFG&377 NE 0
170$:	SPLC	3		;;RETURN TO LEVEL 3
180$:	RETURN			;EXIT

LPTDSP	060	;ZERO
	BIT	#LPTCH0,DDFLAG(R1) ;MAKE "0" INTO "O" WHEN "0" FOUND?	;015
	BEQ	LPTBUF		;NOPE, LEAVE THE "0" A "0"
	MOV	#'O,R2		;YES, SO MAKE INTO "O"
	BR	LPTBUF		;GO PROCESS CHARACTER

LPTDSP	015	;CARRIAGE RETURN
	TSTB	LPTCHR(R1)	;CHECK FOR IGNORED <CR>'S BEFORE <LF>'S
	BPL	LPTCRO		;SKIP IF NO OPTIMIZATION
.ASSUME	LPTSCR	EQ	200
	CMPB	DDHORZ(R1),DDHORC(R1) ;IS CARRIAGE ALREADY RETURNED?
	BEQ	180$		;IGNORE IT IF SO
	TST	XRBC(R3)	;IF NOT ARE THERE MORE CHARACTERS TO COME? ;015
	BEQ	LPTCRO		;NOPE, SO ACTUALLY SEND THE <CR>
	GETUSR			;GET THE NEXT CHARACTER
	DEC	R5		;RESTORE THE POINTER TO THE CHARACTER WE GOT
	CMP	R2,#12		;IS THE NEW CHARACTER A LINE FEED?
	BEQ	180$		;YES. IGNORE THE <CR>
	BR	LPTCRO		;NO. RESTORE THE <CR> AND SEND IT

190$:	BIT	#LPTNOX,DDFLAG(R1) ;TRUNCATE OVERFLOW LINES ON OVERFLOW?
	BNE	195$		;yes, so ignore the character		;006
	BIT	#LPMNOX,XRMOD(R3) ;no, request one-shot truncate?	;015
	BNE	195$		;yes, so ignore the character		;010
	BIT	#LPTNWR,DDFLAG(R1) ;no, is NOWRAP in effect?		;015
	BEQ	210$		;no, return carriage then print		;006
	INCB	DDHORZ(R1)	;yes, so don't count this character	;011
	BR	LPTSTO		;but send it anyway			;011

195$:	INCB	DDHORZ(R1)	;DON'T COUNT THIS CHARACTER
	RETURN			; AND EXIT

200$:	BIT	#LPTOVF,DDFLAG(R1) ;CHECKING FOR PERFORATIONS?		;015
	BEQ	LPTSTO		;NO, JUST STORE CHARACTER
	BIT	#LPMPOP,XRMOD(R3) ;REQUEST PRINT OVER PERFORATION?	;015
	BNE	LPTSTO		;YES
	CALL	130$,R2		;NO, SAVE UPCOMING CHAR FOR LATER
GETTOF:	BIT	#LPTFFT,DDFLAG(R1) ;use <ff> to get to TOF?		;006
	BEQ	LPTLFO		;no, so line feed it out		;006
	MOV	#14,R2		;yes, load <ff> character		;006
	BR	LPTRST		;and go reset to TOF			;006

210$:	CALL	130$,R2		;SAVE OVERFLOW CHAR FOR LATER
LPTDSP	012	;LINE FEED
LPTLFO:	MOV	#12,R2		;SET TO OUTPUT A <LF>
	DECB	DDVERT(R1)	;END OF FORM?
	BNE	220$		;NOPE
LPTRST:	MOVB	DDVERC(R1),DDVERT(R1) ;RESET FORM LENGTH COUNTER TO TOP
	ADD	#1,LPTPG0(R1)	;incr lsb of page counter		;006
	ADC	LPTPG1(R1)	;  and msb too				;006
220$:	BIT	#LPTCRF,LPTCHR(R1) ;SHOULD WE DO A <CR> BEFORE <LF>,<VT>,<FF>? ;015
	BNE	230$		;NO. JUST OUTPUT IT
	CMPB	DDHORZ(R1),DDHORC(R1) ;IS CARRIAGE RESTORED?
	BEQ	230$		;YES, SO ALL O.K.
	MOV	R2,-(SP)	;NO, SAVE THE CHARACTER
	CALL	LPTCRO		; AND DO A <CR> FIRST
	MOV	(SP)+,R2	;NOW RESTORE THE SAVED CHARACTER
230$:	CMP	R2,#14		;IS THIS A <FF>
	BEQ	240$		;YES
LPTRHZ:	MOVB	DDHORC(R1),DDHORZ(R1) ;RESET HORIZONTAL LINE POSITION
	CALLR	LPTSTO		;NOW STORE THE CHARACTER

240$:	BIT	#LPTSFF,LPTCHR(R1) ;DOING <FF> FILL?			;015
	BNE	LPTRHZ		;NO, JUST OUTPUT IT
	CALL	LPTRHZ		;YES, FIRST OUTPUT THE <FF>
	CALL	LPTSPO		; NOW OUTPUT A <SPACE> FOR TIMING...
	BR	250$		;  AND THEN GO SEND ANOTHER <CR>

LPTCRO:	CLRB	LPTPSP(R1)	;CLEAR PENDING SPACE(S) IF <CR>
250$:	MOV	#15,R2		;SET CHARACTER TO <CR>
	BR	LPTRHZ		; GO SEND THE <CR>

.DSABL	LSB

.SBTTL	LPTAB	- LINE PRINTER TAB PROCESSOR

;+									;013+
;
; LPTAB:
;
; Inputs:	R1 -> LP's DDB
;		R2 = current character (<tab>)
;		R3 -> XRB
;
; Call:		JSR	PC,LPTAB
;
; Returns:	Expands tab to spaces or outputs tab unchanged
;		Updates horizontal position accordingly
;		All tab stops assumed multiples of 8
;		R4 destroyed, all registers preserved
;
;-

	.ENABL	LSB

LPTAB:	MOVB	DDHORC(R1),R4	;get current horz position
	SUB	DDHORZ(R1),R4	;invert it to get true position
.ASSUME	DDHORZ&1 EQ	0
	COM	R4		;calculate spaces
	BIC	#^C<7>,R4	; to next
	INC	R4		;  tab stop
	CMPB	R4,DDHORZ(R1)	;will we overflow the line?
	BHIS	30$		;yes, skip to overflow handler
	BIT	#LPTTAB,LPTCHR(R1) ;no, send <tab> unchanged?
	BEQ	20$		;no, skip to force spaces
10$:	SUB	DDHORZ(R1),R4	;move horzizontal
.ASSUME	DDHORZ&1 EQ	0
	NEG	R4		; positon to
	MOVB	R4,DDHORZ(R1)	;  next tab stop
	CALLR	LPTSTO		;and send the <tab> character

20$:	PUSH	R4		;save space count
	CALL	LPTSPO		;call space outputter
	POP	R4		;restore space count
	SOB	R4,20$		;do until next tab stop
	BR	60$		;and skip to exit

30$:	BIT	#LPTNOX,DDFLAG(R1) ;are we in truncate mode?
	BNE	50$		;yes, force to line end
	BIT	#LPMNOX,XRMOD(R3) ;no, one-shot truncate?
	BNE	50$		;yes, force to line end
	BIT	#LPTNWR,DDFLAG(R1) ;no, nowrap mode?
	BNE	40$		;yes, skip to nowrap processor
	CALLR	LPTLFO		;no, call the line wrapper

40$:	MOVB	DDHORZ(R1),R4	;compute spaces
	DEC	R4		; to end of line
	BIT	#LPTTAB,LPTCHR(R1) ;send <tab> unchanged?
	BNE	10$		;yes, go send the <tab> character
	TST	R4		;no, are we already at end of line?
	BHI	20$		;no, so send spaces to end
50$:	MOVB	#1,DDHORZ(R1)	;yes, force position to end of line
60$:	RETURN			;exit

	.DSABL	LSB							;013-

.SBTTL	INTERRUPTS

;+
; INT$LP - INTERRUPTS FOR LINE PRINTERS.
;
;	R0 =  UNIT NUMBER TIMES 2
;	PRIORITY IS INTERRUPT PRIORITY
;
;	...
;
;	RETURN
;-

INT$LP::CLR	TIM.LP(R0)	;;CLEAR ANY TIMEOUT
	MOV	DEV.LP(R0),R1	;;GET THE DDB POINTER
	MOV	CSR.LP(R0),R3	;; AND GET THE HARDWARE CSR ADDRESS
	CLR	(R3)		;;DISABLE FURTHER LINE PRINTER INTERRUPTS

.IF	DF	LPDVRX

	MAP	PUSH,APR=6,DATA	;;SAVE INTERRUPTED DPAR6 VALUE
	CLR	R5		;;SAY NO ACTIVE XBUF POINTER

.IFTF	;DF	LPDVRX

.IF	DF	LPDVRA

	BIT	#DDAUXA,(R1)	;;IS THE AUX PROCESSOR ACTIVE?
	BNE	110$		;;YES, FALSE INTERRUPT, JUST EXIT

.ENDC	;DF	LPDVRA

	BIC	#DDSTAT,(R1)	;; AND ASSUME NO ERROR
	TSTB	LPTICH(R1)	;;ALREADY HAVE A PENDING CHARACTER?
	BNE	70$		;;YES
	BR	20$		;;NO, SO GET ONE

10$:	MOV	R2,LPB(R3)	;;OUTPUT THE CHARACTER TO THE PRINTER
20$:

GLOBAL	<TIM.LP,DEV.LP,CSR.LP>

.IFT	;DF	LPDVRX

	TST	R5		;;ACTIVE XBUF POINTER?
	BNE	30$		;;YES
	BIT	DDBUFC+EP(R1),#40-2 ;;CURRENT EMPTY POINTER POSSIBLE IRB?
	BNE	50$		;;NOPE
	MOV	DDBUFC+EP(R1),R5 ;;MIGHT BE, SO GET EMPTY POINTER
	BIT	R5,#40-1	;;REALLY AN IRB/DATA BUFFER POINTER?
	BEQ	40$		;;NOPE
	MAP	IRBMMU-1(R5),APR=6,DATA ;;YEP, MAP THE DATA BUFFER
30$:	CMP	IRBEPT-1(R5),IRBFPT-1(R5) ;;UP TO THE FILL POINTER YET?
	BHIS	40$		;;YEP, DO A REAL "FETCH" TO DEALLOCATE
	MOVB	@IRBEPT-1(R5),R2  ;;FETCH CHARACTER FROM DATA BUFFER
	INC	IRBEPT-1(R5)	;; AND BUMP THE EMPTY POINTER
	BR	60$		;;  THEN GO USE IT

40$:	CLR	R5		;;NO XBUF POINTER IS ACTIVE
50$:

.IFTF	;DF	LPDVRX

	CALLX	FETCH,R5,DDBUFC+EP ;;GET THE NEXT CHARACTER
	BCC	60$		;;GOT SOMETHING
	CLR	R2		;;NO MORE
60$:	MOVB	R2,LPTICH(R1)	;;SAVE THE PENDING CHARACTER
70$:	TST	(R3)		;;ANY HARDWARE ERROR ?
	BMI	120$		;;YES, GIVE AN ERROR
	TSTB	(R3)		;;READY TO GOBBLE CHARACTER ?
	BPL	90$		;;NO, SO START TIMING OUT
	MOVB	LPTICH(R1),R2	;;YES, GET THE PENDING CHARACTER
	BEQ	80$		;;NONE, ALL DONE WITH BUFFER CHAIN
	BPL	10$		;;ONE, AND REAL AT THAT, SEND IT
	BIT	#LPT8BT,LPTCHR(R1) ;;SENDING 8-BIT CHARS?
	BNE	10$		;;YES, SEND THIS ONE
	MOV	#40,LPB(R3)	;;ONE, A PENDING COUNT, SO SEND A SPACE
	INCB	LPTICH(R1)	;; AND COUNT IT AS SENT
	BMI	70$		;;COUNT STILL EXISTS, CHECK FOR READY
	BR	20$		;;COUNT EXPIRED, GET NEXT

80$:	MOVB	LPTPSP(R1),R2	;;CHAIN EMPTY, GET ANY PENDING COUNT
	BEQ	100$		;;NO PENDING COUNT EXISTS, DONE
	CLRB	LPTPSP(R1)	;;COUNT EXISTS, BUT CLEAR IT OUT
	BR	60$		;; THEN GO DO THAT COUNT

GLOBAL	<TIM.LP,DEV.LP,CSR.LP>

90$:	CALL	LPTGO		;;RESTART THE PRINTER AND TIMEOUT
	TSTB	LPTBQC(R1)	;;AWAKEN JOB WHEN ALMOST DONE?
	BNE	110$		;;NO, EXIT NOW THEN
100$:	CALLX	IOFINC,R5,<BFQ.LP-10.,JS.LP> ;;RESTART JOB IF NEEDED
110$:

.IFT	;DF	LPDVRX

	MAP	POP,APR=6,DATA

.ENDC	;DF	LPDVRX

	RETURN			;;INTERRUPT EXIT

120$:	CALL	LPTHNG		;;INDICATE "HUNG" PRINTER
	BR	110$		;;QUIT

GLOBAL	<BFQ.LP,JS.LP>

.END

