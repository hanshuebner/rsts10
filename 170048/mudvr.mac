        .INCLUDE /CMN:COMMON/
        .INCLUDE /CMN:KERNEL/
        .INCLUDE /CMN:MTDEF/
        .INCLUDE /DSK:MSCPDF/
TITLE	MUDVR,<TMSCP MAGTAPE DRIVER>,0B,21-JUN-91,TPT/DBM/VAM/FEK

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR MUDVR
;+
;  000	TPT  07-Dec-84	Procreation of Skeletor
;  001	DBM  27-May-85	Check for presence of tape controllers
;  002	DBM  01-Jun-85	Put in error logging code
;  003	TPT  24-Jun-85	Miscellaneous changes
;  004	TPT  15-Jul-85	Bug fixes, code stripping
;  005	TPT  20-Aug-85	Multi-controller support re-hab, cleanup
;  006	TPT  13-Sep-85	Incorporate comments, suggestions, bug fixes
;
;			[RSTS/E V9.2]
;  007	TPT  22-Oct-85	Source clr bug fixes
;  008	DBM  06-Dec-85	Store job number in TSQ to allow closes with I/O out
;  009	TPT  10-Dec-85	Do true rewind/offline, mov BLDTSQ to MTA for MS/MU 
;			drivers.  Code cleanup.
;  010	TPT  20-Jan-86	Only return NOROOM on writes and WTM's at EOT
;  011	TPT  10-Mar-86	Also mark UCB avail. in rew/off ; code cleanup
;
;			[RSTS/E V9.3]
;  012  VAM  27-Jul-86	Make calls to CPH/UQPORT mapped.
;			Also, put controller ID into DDB.
;  013  VAM  25-Aug-86	Fix handling of MT.OPN flag in SER$MU.
;  014	DBM  20-Oct-86	New density support.  Fix/rework density processing.
;			Return drive code, not controller ID in DDB
;			Fix ONL.MU to handle errors
;			RETURN to MTA for FIP requests
;
;			[RSTS/E V9.4]
;  015	DBM  05-Feb-87	Finish work required to support the TK70
;  016  VAM  09-Mar-87	Fix bug in ANSI EOF1 trailer block count.
;			Add support for new Read-Only Volume Format subcode.
;
;			[RSTS/E V9.6]
;  017  VAM  24-Mar-88	Use TMSCP "skip tape marks" feature to skip forward
;			or backward one tape mark if 0 is specified as
;			argument to .SPEC call.
;
;			[RSTS/E V9.7]
;  018  VAM  23-Mar-89	Fix bit test for asynchronicity during out-of-buffers
;			condition in SER$MU.
;
;			[RSTS/E V10.1]
;  019	FEK  10-Dec-90	L3QSET QPHCON directly - also add .ASSUMEs
;-


	DEFORG	MUDVRM

.SBTTL  TSQ -- INCLUDING TMSCP SPECIFIC ENTRIES

.DSECT	,NOCREF

	.BLKW		; QUEUE LINK WORD (FORWARD POINTER)
TSQJOB:	.BLKB		; JOB NUMBER					;008
TSQTRY:	.BLKB		; RETRY COUNT AND ERROR FLAG
TSQL3Q:	.BLKW		; COMPLETION QUEUE AND L3Q BITS TO SET	
TSQIDX:	.BLKB		; DEVICE INDEX				
TSQCEV:	.BLKB		; REQUEST ERROR VALUE			
TSQRET:	.BLKW		; PARAMETER TO RETURN			
TSQMTO:	.BLKB		; OPEN FLAG WORD				;008
TSQMAM:	.BLKB		; MEMORY ADDRESS OF THE TRANSFER (MSB)	
TSQMAL:	.BLKW		; LOW ORDER MEMORY ADDRESS OF TRANSFER	
TSQCNT:	.BLKW		; WORD (OR RECORD) COUNT OF TRANSFER/OPERATION
TSQCMD:	.BLKB		; FUNCTION CODE OF OPERATION		
TSQSTS:	.BLKB		; OPERATION STATUS WORD			
TSQASY:	.BLKW		; POINTER TO ASYWRK BLOCK		
TSQTOT:	.BLKW		; TOTAL TRANSFER COUNTER		
TSQUMT:	.BLKW		;*UMT TABLE ENTRY POINTER FOR UNIT
TSQDDB:	.BLKW		;*DDB POINTER FOR UNIT UNDERGOING RESPONSE PROCESSING
	.BLKB	2	;*RESERVED
TSQBWP:	.BLKW		;*TMSCP REQUEST QUEUE ITEM BACKWARD POINTER
TSQID:	.BLKB		;*TSQ/DSQ IDENTIFIER (TSQ=-1, DSQ=DCS-1)
TSQPUN:	.BLKB		; PHYSICAL UNIT NUMBER	
TSQSIZ:			; Hokay, the size better = 1 small buffer

.BSECT			; Bit assignments for TSQSTS

	.BLKB	.	;RESERVED - R.SENT IN MSCPDF (REQUEST SENT TO CONTROLLER)
	.BLKB	.	;RESERVED - R.ERR  IN MSCPDF (REQUEST IN ERROR)
	.BLKB	.	;RESERVED - R.UMRA IN MSCPDF (UMRs ASSIGNED TO TSQ)
R.SYN:	.BLKB	.	;THIS IS A SYNCHRONIZATION TSQ (TO CLR SERIOUS EXCEPTION)
	.BLKB	.	;RESERVED - R.UNTS IN MSCPDF (UNIT SEARCH IN PROGRESS)
R.ECK:	.BLKB	.	;SET WHEN THIS REQUEST IS ERROR CHECK
	.BLKB	.	;RESERVED
R.ASY:	.BLKB	.	;SET WHEN THIS REQUEST IS ASYNCHRONOUS

.SBTTL	TMSCP MAGTAPE DDB EXTENSION

.DSECT	MTFQB+2		;POSITION PAST THE CURRENT MTDDB SIZE

MUCMT:	.BLKW		;CMT OFFSET FOR THIS UNIT
MUUCB:	.BLKW		;UCB POINTER FOR THIS UNIT
MUAINF:	.BLKW		;UNIT STATUS WORD
MURWP:	.BLKB		;UNIT READ/WRITE PENDING COUNTER
	.BLKB		;Reserved (Used to be MUDENS)			;014

.ASSUME	MUCMT	EQ	MTFQB+2	;SANITY CHECK (IT'S ALLRIGHT?  SALLRIGHT!)


; BIT ASSIGNMENTS IN MUAINF
; NOTE: BITS MUST REMAIN IN PLACE BECAUSE THEY ARE FORMATTED TO RETURN CORRECT
;	INFORMATION FOR 'RETURN UNIT STATUS' .SPEC.

.BSECT				;MUAINF - UNIT STATUS FLAGS

	.BLKB	.		;RESERVED
	.BLKB	.		;RESERVED
	.BLKB	.		;RESERVED
	.BLKB	.		;RESERVED
	.BLKB	.		;RESERVED
MU$OFL:	.BLKB	.		;UNIT IS OFFLINE
	.BLKB	.		;RESERVED
	.BLKB	.		;RESERVED
MU$BOT:	.BLKB	.		;UNIT IS AT BEGINNING OF TAPE
MU$BET:	.BLKB	.		;UNIT IS BEYOND END OF TAPE
MU$WPR:	.BLKB	.		;UNIT IS WRITE PROTECTED
MU$LCK:	.BLKB	.		;RESERVED
MU$ECA:	.BLKB	.		;UNIT IS IN ERROR STATE
	.BLKB	.		;RESERVED
	.BLKB	.		;RESERVED
MU$LER:	.BLKB	.		;LAST COMMAND CAUSED ERROR

.SBTTL	DEVICE ASSIGNMENT SERVICE
;+
; ASN$MU - DEVICE ASSIGNMENT SERVICE
;
;	R0 = JOB NUMBER OF ASSIGNER TIMES 2
;	R1 ->DDB
;
;	...
;
;	RETURN		(WITH EVERYTHING PRESERVED)
;-
	TMPORG	MUDINT,32
	 .WORD	ASN$MU
	UNORG

ASN$MU:	NOP		;BPT -  TESTING
	MOV	#MUAPTR,MTRPTR+MTDDSP(R1) ;SET THE ROOT[L3Q] POINTER IN DDB
	MOVB	MAGLBL,MTLBLI+MTDDSP(R1) ;SET LABELING DEFAULT
	CLRB	MTFLAG+MTDDSP(R1)	 ;CLR FLAGS
	CLR	MURWP+MTDDSP(R1)	;CLR INFINITE I/O COUNT / SAVED DENSITY
	BIC	#^C<MU$BOT!MU$WPR>,MUAINF+MTDDSP(R1) ;RESET SOME UNIT FLAGS
	CALMCP	INITPH		;Make sure data structures are INIT'd.	;012
	PUSH	<R2,R5>		;SAVE A REGISTER
	MAP	PUSH,APR=6,DATA	;SAVE CURRENT MAPPING
	PUSH	<R3>		;SAVE TSQ POINTER
	MOV	MUCMT+MTDDSP(R1),R3 ;GET CMT OFFSET FOR THIS DEVICE
	ADD	#CMT,R3		;UP TO CMT PROPER
	MAP	CM.AP6(R3),APR=6,DATA ;MAP TO THIS UNITS UCB
	MOV	MUUCB+MTDDSP(R1),R3 ;PICK UP UCB POINTER
	BIC	#US.LCK!US.SYC,U.STAT(R3) ;CLR EXTRANEOUS FLAGS
	MOV	TAPDEN,R5	;Get system default density		;015
	CALL	VERDEN		;Make it appropriate for this drive	;015
;	BICB	#MT.DEN,MTFLAG+MTDDSP(R1) ;Assume 1600 (From CLRB, above) ;014
	CALL	DEN800		;Check for 800 BPI format		;014
	BCS	10$		;Not 800, leave flag alone		;014
	BISB	#MT.DEN,MTFLAG+MTDDSP(R1) ;OK, SET TO 800
10$:	MOV	R2,U.FORM(R3)	;SAVE FORMAT (DENSITY)
	POP	<R3>		;RESTORE TSQ POINTER
	MAP	POP,APR=6,DATA	;RESTORE MAPPING
	POP	<R5,R2>		;RESTORE REG
	.BR	DEA$MU		;AND FALL THROUGH TO RETURN
 	
GLOBAL	<MAGLBL,MUAPTR,TAPDEN>


.SBTTL	DEVICE DEASSIGNMENT SERVICE
;+
; DEA$MU - DEVICE ASSIGNMENT SERVICE
;
;	R1 ->DDB
;
;	...
;
;	RETURN		(WITH EVERYTHING PRESERVED)
;-
	TMPORG	MUDINT,36
	 .WORD	DEA$MU
	UNORG

DEA$MU:	RETURN			;RETURN (REDUNTANT, REDUNDANT)

.SBTTL	UMR$MU	- UMR FREED UP NOTIFICATION ENTRY
;+
; UMR$MU - UMR FREED PROCESSING IS DONE IN COMMON PROTOCOL HANDLER
;
;-
	TMPORG	MUDINT,46						;019
	 .WORD	UMR$MU
	UNORG

UMR$MU:	MCPJMP	UMR$PH		;Off to common processing (TMSCP/MSCP)	;012


.SBTTL	TMO$MU - DEVICE TIME-OUT ENTRY POINT
;+
; TMO$MU - TIMEOUT PROCESSING DONE IN THE COMMON PROTOCOL HANDLER
;
;-
	TMPORG	MUDINT,22
	 .WORD	TMO$MU
	UNORG

TMO$MU:	MCPJMP	TMO$PH		;Off to common processing.		;012


.SBTTL	CON$MU - CONTINUATION PROCESSING
;+
; CON$MU - CONTINUATION PROCESSING DONE IN THE COMMON PROTOCOL HANDLER
;
;-

;	See CON$IP in CPH.MAC						;019

;002+
.SBTTL	Error logging

;+
; The following code performs error logging for TMSCP controllers
; and associated devices.  TMSCP error logs come in 3 flavors.
;
; 1. TSQ, End packet
; 2. Response packet only
; 3. Controller fatal, no TSQ and no packet.
;
; This code is entered into via the error log EMT service code.
;
; Input:	R0 -> Queue root
;		R1 -> Error log packet (R1=0 if no error log packet)
;		R2 -> Available table pointer (Port driver dispatch table PTR)
;		R3 -> CSR
;		R4 -> TSQ (If TSQ exists, otherwise R4 = 0)
;		R5 -> CCB
;
;-

	TMPORG	BBRDSP,12	;Set up for indirect calls...		;012
	.WORD	LOGMU		; ...to go here.			;012
	UNORG								;012

LOGMU:	LOG$MU			;Log an error				;012
	RETURN			; and go back.				;012


	TMPORG	MUDINT,12
	 .WORD	ERL$MU
	UNORG

ERL$MU:	CALL	CMNERL		;;;USE COMMON ROUTINE
	MOV	R4,-(SP)	;;;TEMP SAVE TSQ
	MOV	R4,R1		;;;Copy TSQ pointer
	BEQ	10$		;;;No TSQ.  Then there won't be a DDB
	MOV	TSQDDB(R4),R1	;;;Get the DDB pointer for ERLDVR
	SUB	#MTDDSP,R1	;;;Un-Bias it
10$:	MOV	R1,-(SP)	;;;Save DDB pointer
	CALLX	ERLDVR,R5	;;;Use common routine
	.BYTE	ERC$MU		;;;ERROR CODE
	.BYTE	DDS.MU		;;;Size of the DDB
	.BYTE	2,1		;;;SAVE IP AND SA REGISTERS
	.BYTE	0,0		;;;THAT'S IT
	MOV	(SP)+,R4	;;;Restore DDB pointer
	BEQ	40$		;;;None, get out
20$:	MOV	MTDDSP+MTACB(R4),(R1) ;;;Store ANSI control block pointer
	BEQ	30$		;;;None.
	MOV	#2*400+16.,-(R1) ;;;Got one.  Set field # and length
30$:	MOV	MTDDSP+MUUCB(R4),R4	;;;R4 = UCB address
	BEQ	40$		;;;Unit not yet assigned
	MOV	U.STAT(R4),MSCPUS;;;Save sofware unit status
40$:	CALL	ERLPKT		;;;NOW, LOG THE MSCP ERROR LOG AREA
	MOV	(SP)+,(R2)	;;;Store the TSQ pointer
	BEQ	50$		;;;None, we are done
	MOV	#6*400+<TSQSIZ/2>,-2(R2) ;;;Set field # and length for TSQ
50$:	CMP	(R2)+,(R2)+	;;;Point past terminator (-1) in control table
	RETURN			;;;BACK TO ERROR LOGGER

	GLOBAL	<MSCPUS,DDS.MU,LOG$MU>					;012

.SBTTL	COMMON ERROR LOG CODE AMONG DRIVERS
;+
; COMMON ERROR LOG ROUTINE.  GETHERS ERROR LOG DATA.
;
; INPUTS/OUTPUTS SAME AS ABOVE.
;
; A copy of this routine lives in DUDSK.  If any changes
; are made here, be sure they are made in DUDSK too.
;-
CMNERL:	MOV	R0,-(SP)	;;;SAVE R0 AND R1
	MOV	R1,-(SP)	;;;IS THERE AN ERROR LOG PACKET?
	BEQ	20$		;;;NO, MUST BE A FATAL CONTROLLER ERROR
	MOV	R3,-(SP)	;;;TEMP SAVE R3
	MOV	E.LENG(R1),R0	;;;R0=LOG MESSAGE LENGTH
	ADD	#ENVLP,R0	;;;ADD EXTRA FOR THE ENVELOPE
	ADD	#E.LENG,R1	;;;R1 -> AT BEGINNING OF ENVELOPE
	MOV	#MSCPPK,R3	;;;R3 -> SAVE AREA FOR ERROR PACKET
10$:	MOVB	(R1)+,(R3)+	;;;MOVE PACKET TO SAVE AREA
	SOB	R0,10$		;;;LOOP TIL DONE
	MOV	(SP)+,R3	;;;RESTORE R3
20$:	MOV	(SP)+,R1	;;;RESTORE R1
	MOV	(SP)+,R0	;;;RESTORE R0
	MOV	(R5),MSCPCS	;;;SAVE CONTROLLER STATUS WORD		;019
	.ASSUME	C.STAT	EQ	0
	RETURN			;;;RETURN TO CALLER

.SBTTL	SAVE MSCP PACKET
;+
; THIS ROUTINE SAVES THE MSCP PACKET
;
; R2 -> PAST SECOND -1 ERLTBL TERMINATOR
; "MSCPPK" CONTAINS PACKET TO BE SAVED
;
; ...
;
; R2 -> TERMINATOR (-1) +2 IN CONTROL TABLE (WORD) (2 WORDS)
;
; A copy of this routine lives in ERLDSK.  If a change
; is made here, be sure to change ERLDSK too.
;-
ERLPKT:	MOV	#5*400+MSCPWC,-2(R2)	;;;FIELD 5, "MSCPWC" WORDS
	MOV	#MSCPPK,(R2)+		;;;  OF MSCP DATA
	MOV	#-1,(R2)+		;;;TERMINATE THE CONTROL TABLE
	MOV	#-1,2(R2)		;;;  IN BOTH PLACES
	RETURN				;;;RETURN TO DRIVER

GLOBAL	<MSCPPK,MSCPWC,MSCPCS,MSCPUS,DQS$XX,UMT$XX>
;002-

;+
; INT$MU - MU INTERRUPT SERVICE
;
; PROCESSING DONE IN THE UQPORT.  WE GET THE TOTAL NUMBER OF 
; DISK CONTROLLERS * 2 AND THEN INDEX TO OUR TAPE CONTROLLER.
; INT$PH WILL INDEX BEYOND THE LAST DISK CMT TO THE FIRST
; TAPE CMT.  SEE INT$PH (UQPORT) TO SEE THE RESULTS.
;	
;	R0 = CONTROLLER #*2
;
;-
	TMPORG	MUDINT,6
	 .WORD	INT$MU
	UNORG

INT$MU::PUSH	<R0>		;SAVE TAPE CONTROLLER #*2
	MOVB	CMT+CM.DCT,R0 	;GET TOTAL # OF MSCP DISK CNTRLR'S
	ASL	R0		;*2 
	ADD	(SP)+,R0	;GET UP TO FIRST TAPE CONTROLLER
	MCPJMP	INT$PH		;Off to common interrupt service (UQPORT) ;012


.SBTTL	SPC$MU - SPECIAL FUNCTION SERVICE
;+
; SPC$MU - SPECIAL FUNCTION SERVICE FOR TMSCP
;
;	R0 =  UNIT # TIMES 2
;	R1 -> DDB/FCB
;	R2 =  SPECIAL FUNCTION CODE
;	R3 -> XRB
;	R4 =  CALLING JOB NUMBER TIMES 2
;	R5 -> (MAPPED) XRB
;
;	...
;
;	JMP	RTI3
;
;	-OR-
;
;	ERROR	CODE
;
;	LEGAL FUNCTIONS ARE:
;	
;	0		REWIND THEN OFFLINE
;	1		WRITE TAPE MARK (END-OF-FILE)
;	2		REWIND
;	3		SKIP(SPACE) FORWARD
;	4		SKIP(SPACE) BACKWARD (BACKSPACE)
;	5		SET DENSITY/PARITY
;	6		RETURN UNIT STATUS
;	7		RETURN FILE CHARACTERISTICS
;	10		REWIND ON CLOSE
;	11		END OF VOLUME (EOV)
;	12		ERROR CONDITION ACKNOWLEDGED (ECA)
;	13		EXTENDED DENSITY
;-
	TMPORG	MUDINT,26
	 .WORD	SPC$MU
	UNORG

.ENABL	LSB

SPC$MU:	CMP	R2,#<GBF.MT-1>-2 ;IS THE FUNCTION OUT OF RANGE?
.ASSUME	<XDN.MT+1> EQ GBF.MT
	BLOS	10$		;NO, VALID FUNCTION, SO CONTINUE
	ERROR	NOTMTA		;ILLEGAL FUNCTION

10$:	BIS	#JFPOST,@JOBF	;MAKE SURE USER GETS INFO POSTED BACK
	CLR	JBSTAT(R4)	;PUT THE JOB INTO AN I/O STALL
	MOV	#JS.MU,JBWAIT(R4);FOR TMSCP
	ADD	#MTDDSP,R1	;OFFSET TO DDB LINK WORD
	CALLM	BLDTSQ,MVRAP5	;GET R3 -> TSQ SMALL BUFFER		;009	
	BCS	20$		;NO SMALLS, TRY AGAIN (NO ASYNCH .SPECS) 
	MOV	XRBC(R3),TSQCNT(R4) ;SET THE FUNCTIONS COUNT		
	TST	R2		;IS THIS FUNCTION CODE ZERO?
	BEQ	15$		;YES, LET THROUGH UNSCATHED
	CMPB	(R2)+,(R2)+	;ELSE ADD 2 TO THE FUNCTION CODE
15$:	JMP	120$		;AND GO PROCESS IT

20$:	BIS	#JSBUF,JBWAIT(R4) ;SET BUFFER STALL			
	JMPX	IOREDO		; and set up for a retry.		;012

GLOBAL	<JBSTAT,JBWAIT,JS.MU>

.SBTTL	SER$MU - TMSCP USER LEVEL READ/WRITE SERVICE

;+
; SER$MU - USER LEVEL READ/WRITE SERVICE FOR TMSCP
;
; ON NORMAL ENTRY:
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB/FCB
;	R2 =  2 (.READ)
;	      4 (.WRITE)
;	R3 -> XRB
;	R4 =  CALLING JOB NUMBER TIMES 2
;	R5 -> USER'S BUFFER (THROUGH KISAR6)
;	IF Z=1 OR C=0 THEN THIS IS THE FIRST CALL
;	IF Z=0 OR C=1 THEN THIS IS A "REDO" CALL
;
; ENTRY FROM MTU:
;	R2 = -1
;	R3 -> TSQ from MTU
;
; NOTES:
;
;	1) ACCESS RIGHTS HAVE BEEN VERIFIED.
;	2) DIRECTIONAL RIGHTS HAVE BEEN VERIFIED.
;
;-

	TMPORG	MUDINT,16
	 .WORD	SER$MU
	UNORG

SER$MU:	CMPB	CMT+CM.DCT,CMT+CM.CCT ;CONTROLLER PRESENT?
	BNE	23$		;YES, SO CONTINUE
	ERROR	NOTAVL		;NOPE

23$:	ADD	#MTQPTR+MTDDSP,R1 ;GET TO OFFSET 0 IN MUDDB		
	CMP	#-1,R2		;CALLING FROM MTU?			
	BNE	50$		;NOPE, SO SET UP THE REQUEST		
	TST	R3		;YES, IS THIS AN ERROR CHECK COMPLETION?
	BNE	25$		;NOPE, REGULAR MTU REQUEST
	BICB	#MT.ECK,MTFLAG(R1) ;YES, SO CLR ERROR STATE
	MOV	#CMT+CM.DNE,R4	;PICK UP OUR DONE QUEUE
	MOV	(R4),R4		;PICK UP ERROR CHECK COMPLETION TSQ
	MOVB	MTLCEV(R1),TSQCEV(R4) ;POST BACK ERROR MTU DECIDES ON
	L3QSET	QMUDNE		;QUE DONE SERVICE TO FINISH UP
	JMP	150$		;AND LEAVE...
;+
;	MTU REQUEST PROCESSING
;-

25$:	BICB	#TS$RWD,TSQSTS(R3) ;MTA ALWAYS SETS THIS FOR THE MSDVR
.ASSUME TS$RWD EQ 2
	MOV	SP,TSQASY(R3)	;NORMAL MTU REQUEST
	BITB	#MT.ECK,MTFLAG(R1) ;ARE WE IN ERROR CHECK STATE?
	BEQ	40$		;NO, SO JUST CONTINUE
	BISB	#R.ECK,TSQSTS(R3) ;SAY THIS IS AN "ERROR CHECK" TSQ
40$:	MOV	R3,R4		;SET TSQ POINTER IN R4 TO MERGE WITH CODE
	BR	130$		;JUST MTU, ALL SET UP, LET'S PROCESS	
;+
;	USER REQUEST PROCESSING
;-

50$:	CALLM	BLDTSQ,MVRAP5	;R3-> TSQ SMALL BUFFER			;009	
	BCC	52$		;GOT ONE
	BIT	#1,XRBCRA(R3)	;No smalls, is this an asynch request?	;018
	BEQ	20$		;NOPE					;008
	CALL	190$		;YES, SO RETURN ASYWRK
	ERROR	NOBUFS		;ASYNCHRONOUS, SO LOSE IT

52$:	CLR	XRBLK(R3)	;CLEAR THE BLOCK NUMBER
	CLRB	XRBLKM(R3)	;AND THE HIGH BYTE
	ASR	R2		;READ=1, WRITE=2
	MOV	XRLOC(R3),TSQMAL(R4) ;SAVE THE USERS VIRTUAL BUFFER ADDRESS
	BIT	#1,TSQMAL(R4)	;BUT, IS THE ADDRESS ODD?		
	BNE	80$		;REAL ODD
	MOV	XRLEN(R3),TSQCNT(R4) ;SET THE COUNT AS THE BUFFER LENGTH
	MOVB	TSQJOB(R4),R0	;GET THE JOB # OF THE OWNER		;008
	MOV	TSQMAL(R4),R5	;SET USER'S VIRTUAL BUFFER ADDRESS	
	PUSH	<R3,R2>		;SAVE XRB POINTER AND COMMAND
	CLR	R3		;NO STALL BITS
	CALLX	FNDJOB		;Try and find the job.			;012
	 BR	100$		;ERROR IN JOB RESIDENCY (ISSUE ERROR, PRVIOL)
				;WE SHOULD ALWAYS BE RESIDENT (WE ARE JOB)
	MOVB	R2,TSQMAM(R4)	;SET THE EXTENDED MEMORY ADDRESS
	MOV	R3,TSQMAL(R4)	;SET MEMORY ADDRESS
	TSTB	MURWP(R1)	;ANY READS/WRITES ALREADY OUTSTANDING?
	BEQ	60$		;NO, SO THIS IS FIRST, LEAVE JOB LOCKED
	CALLX	UNLOC0		;Yes, already locked, don't inc lock count.;012
				;(DROP ONE CAUSE FNDJOB ALREADY INC'D IT)
60$:	POP	<R2,R3>		;RESTORE XRB POINTER AND COMMAND
	INCB	MURWP(R1)	;AND INCREMENT THE OUTSTANDING R/W COUNTER
	BPL	70$		;Less than 128 requests outstanding,	;012
				; so go ahead.				;012
	DECB	MURWP(R1)	;OH-OH, TOO MANY OUT THERE, DEC THE R/W COUNT
	CALL	180$		;RETURN SMALL BUFFERS
	ERROR	INUSE		;AND RETURN DIRECTIVE ERROR INUSE

70$:	CMP	R2,#2		;IS THIS A WRITE REQUEST?
	BNE	110$		;NO, READ.
	MOV	XRBC(R3),TSQCNT(R4) ;WRITE COUNT IS SUPPLIED BY COUNT	
	CMP	TSQCNT(R4),#14.	;14. BYTE IS MINIMUM RECORD SIZE
	BHIS	120$		;Everything is okay. Go queue it.	;012
80$:	CALL	180$		;RETURN THE SMALL BUFFERS
	DECB	MURWP(R1)	;THIS REQUEST IS NO LONGER OUTSANDING
	BNE	90$		;LOCK COUNT DIDN'T CHANGE
	CALLX	UNLOC0		;Unlock the job.			;012
90$:	ERROR	BADCNT		;SET THE BUFFER LENGTH ERROR

100$:	POP	<R2,R3>		;CLEAN UP THE STACK IN CASE
	CALL	180$		;RETURN THE SMALL BUFFERS
	ERROR	PRVIOL		;SOMETHING WRONG WITH JOB.

110$:	BIT	TSQCNT(R4),#1	;IS READ BUFFER ODD?
	BNE	80$		;YES, THAT IS AN ERROR
120$:	MOVB	R2,TSQCMD(R4)	;SET THE COMMAND IN THE TSQ		
	MOV	#RTI3PH,-(SP)	;Asynchronous return will be via RTI3PH	;014
130$:	CALMCP	INITPH		;Initialize data structures (if needed).;012
	MOV	R1,R3		;COPY DDB POINTER
	ADD	#MUCMT,R3	;UP TO DDB UMT ENTRY
	MOV	R3,TSQUMT(R4)	;COPY THAT POINTER
	MOV	R1,TSQDDB(R4)	;COPY DDB POINTER
	MOVB	#-1,TSQID(R4)	;MARK THIS AS A TSQ
	CMP	(R3),#1		;IS THE PHYSICAL UNIT PRESENT?
	.ASSUME	UM.CMT	EQ	0
	BEQ	210$		;NO, GIVE A DEVICE HUNG ERROR
	MOV	(R3),R3		;R3 -> OFFSET INTO CMT			;019
	.ASSUME	UM.CMT	EQ	0
	ADD	#CMT,R3		;GET ABSOLUTE ADDRESS OF CMT ENTRY
	MOV	R3,R0		;THIS IS THE QUEUE ROOT
	ADD	#CM.QUE,R0	;R0 -> CMT QUEUE ROOT POINTER
	CALMCP	QUETSQ		;Queue the request.			;012	
	BINIT	140$		;IF INIT, LET REQSER SET PH CONTINUATION ;009
	L3QSET	QPHCON		;REQUEST CONTINUATION SERVICE		;019
140$:	PUSH	<R4>		;SAVE THE TSQ POINTER
	MOV	R3,R4		;COPY CMT POINTER
	CALMCP	SERVIC		;Request service for this controller.	;012
	POP	<R4>		;RESTORE THE TSQ POINTER
	TSTB	TSQSTS(R4)	;ASYNCH REQUEST?			
.ASSUME R.ASY EQ 200
	BMI	150$		;Yes, go out through RTI3PH		;014
	BITB	#MT.OPN,TSQMTO(R4) ;From MTU?				;013
	BEQ	150$		;Yes, return to MTA			;014
	MOV	#DMPJOB,(SP)	;Synchronous request, so dump the job	;014
150$:	RETURN			;Get out of here appropriately		;014

;ROUTINE TO RETURN SMALL BUFFER(S) ON AN ERRORED REQUEST

180$:	BUFFER	RETSML		;RETURN THE TSQ
	BIT	#1,XRBCRA(R3)	;ASYNCHRONOUS REQUEST?	
	BEQ	200$		;NO, SO DON'T RETURN THE WORK BLOCK
190$:	MOV	R3,R4		;ASYNCHRONOUS, GET  ASYWRK IN R4
	BUFFER	RETSML		;RETURN THAT BUFFER
200$:	RETURN

210$:	CALL	180$		;RETURN ANY TSQ'S
	ERROR	HNGDEV		;SAYING THIS GUY IS HUNG OR WRITE LCK

GLOBAL	<RTI3PH,DMPJOB>							;014
.DSABL	LSB

.SBTTL	MUSERV - TMSCP PROCESS REQUEST SERVICE
;+
; MUSERV
;
; THIS ROUTINE CALLS RESPECTIVE FUNCTION PROCESSORS WHICH
; IN TURN ISSUE COMMANDS TO THE TMSCP CONTROLLER.  THIS ROUTINE
; IS REACHED VIA PROREQ IN THE COMMON PROTOCOL HANDLER AND IS A
; PART OF LEVEL 3 CONTINUATION PROCESSING.
;
; INPUT:	R3 -> UCB
;		R4 -> TSQ
;		R5 -> CCB
;
;-

	TMPORG	BBRDSP,4		;Set up dispatch point		;012
	.WORD	$MUSRV			;for mapped indirect call.	;012
	UNORG								;012

$MUSRV:									;012
MUSERV:	BITB	#R.SENT,TSQSTS(R4) ;HAS THE REQUEST BEEN SENT?
	BNE	50$		;YES, SO LEAVE (FOR NOW)	
	BIT	#US.LCK,U.STAT(R3) ;ARE WE IN A "ERROR LOCKED" STATE?
	BEQ	10$		;NO, SO CONTINUE LIKE USUAL
	BITB	#R.ECK,TSQSTS(R4) ;YES, IS THIS ERROR CHECK TSQ?
	BNE	20$		;YES, SO CONTINUE LIKE USUAL
	CMPB	#ECA.MT,TSQCMD(R4) ;HOW 'BOUT ECA .SPEC?
	BEQ	20$		;YES, SO CONTINUE
	MOV	TSQDDB(R4),R1	;COPY DDB POINTER
	BITB	#MT.ECK,MTFLAG(R1) ;ERROR CHECK STATE?
	BNE	5$		;YES, SO DEVHNG
	BIT	#US.SYC,U.STAT(R3) ;SYNCHRONIZING?
	BEQ	5$		;NOPE
	BITB	#R.SYN,TSQSTS(R4) ;YES, IS THIS THE SYNCH TSQ?
	BEQ	50$		;NOPE, SYNCHRONIZING, DON'T PROCESS ANYTHING
	JMP	SYNCH		;YES, WELL LET'S SEND IT...

5$:	SETERR	HNGDEV,TSQCEV(R4) ;NO, SO THIS REQUEST DOESN'T MAKE IT
	BR	45$		;AND QUE OUT TO DONE SERVICE

10$:	BIT	#US.UMR,U.STAT(R3) ;ARE WE UMR STALLED?
	BNE	50$		;YES, SO HANG 10 FOR A WHILE...
20$:	MOVB	TSQCMD(R4),R2	;GET THE FUNCTION CODE
	ASL	R2		;AND MAKE IT * 2 FOR REQUEST DISPATCH
	ADD	#FUNPRO,R2	;GET ADDRESS OF FUNCTION PROCESSOR
	CMP	R2,#FUNEND	;VALID FUNCTION?
	BLO	25$		;Yes.					;012
	CRASH			;INVALID FUNCTION, SOMETHING'S WRONG

25$:	PUSH	<R3>		;SAVE A REGISTER
	MOV	TSQDDB(R4),R3	;PICK UP THE DDB POINTER
	TST	MTIDX(R3)	;DO DEFAULTS NEED SETTING?
.ASSUME	DDSTAT	EQ	100000
	BPL	30$		;NOPE, JUST GO DISPATCH REQUEST
	BIC	#DDSTAT,MTIDX(R3);SAY DEFAULTS NO LONGER NEED SETTING
	CLRB	MTFLAG(R3)	;CLEAR DDFLAG
	MOVB	MTDUNI(R3),MTOFLG(R3) ;SET THE OPEN FLAG IN THE DDB
	MOVB	MTOFLG(R3),TSQMTO(R4) ;GET A COPY IN THE TSQ	
30$:	POP	<R3>		;RESTORE UCB POINTER
	CLR	TSQRET(R4)	;CLEAR THE RETURNED VALUE
	CLRB	TSQCEV(R4)	;CLEAR THE RETURNED ERROR CODE
	CALL	@(R2)		;FINALLY, CALL THE FUNCTION...
	BR	50$		;EXIT

45$:	PUSH	<R0>		;SAVE R0
	MOV	C.CMT(R5),R0	;R0->CMT OF REQUEST
	ADD	#CMT+CM.QUE,R0	;R0->TSQ QUEUE ROOT FOR CMT
	CALMCP	DEQUER		;;Dequeue the request.			;012
	BISB	#R.SENT,TSQSTS(R4) ;FLAG AS SENT FOR DONE PROCESSING
	POP	<R0>		;RESTORE R0
	CALL	QUEMTD		;QUEUE IT UP FOR DONE SERVICE
50$:	RETURN

GLOBAL	<UNDFNI>	
;+
; FUNCTION PROCESSOR DISPATCH TABLE
;-
FUNPRO:	.WORD	MUREW           ;REWIND THEN OFFLINE		** REPOSITION **
	.WORD	MUREAD		;READ FUNCTION PROCESSOR
	.WORD	MUWRIT		;WRITE FUNCTION PROCESSOR
	.WORD	MUWTM		;WRITE TAPE MARK
	.WORD	MUREW		;REWIND				** REPOSITION **
	.WORD	MUSKP		;SKIP FORWARD  (SPACE)		** REPOSITION **
	.WORD	MUBSP		;SKIP BACKWARD (BACKSPACE)	** REPOSITION **
	.WORD	MUSET		;SET DENSITY/PARITY
	.WORD	MURUS		;RETURN UNIT STATUS
	.WORD	MTACHR		;RETURN FILE CHARACTERISTICS
	.WORD	MTACRW		;REWIND ON CLOSE		** REPOSITION **
	.WORD	MUNTM		;END OF VOLUME (EOV) - A NOP	
	.WORD	MTAECA		;ERROR CONDITION ACKNOWLEDGE (ECA)	
	.WORD	MTAXDN		;EXTENDED DENSITY PROCESSOR
	.WORD	MTAGBF		;GET AN ANSI LABEL BUFFER
FUNEND:				;END OF TABLE (FOR NOW...)

.SBTTL	WRITE  - TMSCP WRITE COMMAND FUNCTION PROCESSOR
.SBTTL	READ   - TMSCP READ  COMMAND FUNCTION PROCESSOR
;+
; READ/WRITE
;
; SUBROUTINE TO INITIATE READ/WRITE TRANSFER
;
; INPUT:	R5 -> CCB
;		R4 -> TSQ
;		R3 -> UCB
;
; OUTPUT:	IF UMR'S AVAILABLE READ/WRITE COMMAND
;		SENT TO CONTROLLER
;
; IF NO UMRs ARE AVAILABLE, THE UNIT IS PLACED IN A UMR STALL
; STATE (US.UMR SET IN UCB) PENDING UMR BEING FREED UP.  WE
; JUMP THIS REQUEST TO THE FRONT OF THE UMR STALLED QUE (CM.QMR)
; IN THE CMT HEADER.
;
; REGISTERS PRESERVED
;-

.ENABL	LSB
MUWRIT:
MUREAD:	REGSCR			;SAVE REGISTERS
	BITB	#MT.OPN,TSQMTO(R4) ;IS IT FIP I/O?			
	BNE	10$		;NOPE, USER I/O
	CLR	R1		;CLEAR THE MSB TO SHIP OUT
	MOV	TSQMAL(R4),R2	;GET THE LSB OF THE BUFFER		
	BNE	15$		;If there is an LSB, go to it.		;016
	JMP	MTAGLB		;GET THE LABEL, IT REQUEUES RD/WRT REQUEST

10$:	CALMCP	ACQUMR		;Get UMRs.				;012
	BCS	90$		;MUST WAIT FOR UMR'S
15$:	MOV	R1,-(SP)	;Save high unibus address on stack.	;016
	MOV	R2,-(SP)	;SAVE LOW UNIBUS ADDRESS ON STACK
20$:	CALMCP	GTCPKT		;Get a command packet.			;012
	BCC	30$		;WE HAVE GOT A COMMAND PACKET
	CMP	(SP)+,(SP)+	;THROW AWAY UNIBUS ADDRESS
	BR	100$		;GO, RELEASE UMR'S

30$:	MOV	R4,(R1)		;SAVE TSQ AS LOW CMD.REF.NUMBER		;019
	.ASSUME	P.CRF	EQ	0
	MOV	R3,P.CRF+2(R1)	;SAVE UCB AS HIGH CMD.REF.NUMBER
	MOVB	(R3),P.UNIT(R1) ;UNIT NUMBER TO COMMAND PACKET		;019
	.ASSUME	U.UNIT	EQ	0
50$:	MOV	(SP)+,P.BUFF(R1) ;PUT LOW AND HIGH UNIBUS ADDRESS
	MOV	(SP)+,P.BUFF+2(R1) ; .. IN COMMAND PACKET
	MOV	#OP.WR,P.OPCD(R1) ;SAY THIS IS A WRITE
	CMPB	#RED.MT,TSQCMD(R4)	;BUT IS THIS A READ?
	BNE	60$		;NOPE
	MOV	#OP.RD,P.OPCD(R1) ;YES, THEN MAKE IT A READ
60$:	MOVB	#<MT.FS!MT.OPN>,-(SP)					;016
				; Is this file-structured, user I/O?	;016
	BICB	TSQMTO(R4),(SP)+; (Both bits must be SET...)		;016
	BNE	70$		;No, so don't touch block count.	;016
	PUSH	<R1>		;Otherwise, save a register...		;016
	MOV	TSQDDB(R4),R1	; ...and get our DDB pointer.		;016
	INC	MTBCNT(R1)	;Increment block count for ANSI to use.	;016
	POP	<R1>		;Restore register.			;016
70$:	MOV	TSQCNT(R4),P.BCNT(R1) ;P.BCNT = WORD COUNT
	CALMCP	SENDCM		;Send command to the controller.	;012
	BCS	100$		;SEND FAILED
	BISB	#R.SENT,TSQSTS(R4) ;SAY, IT MADE IT
80$:	RETURN			;RETURN TO CALLER

90$:	MOV	C.CMT(R5),R0	;GET CMT OFFSET FROM CCB
	ADD	#CMT+CM.QUE,R0	;R0-> Q-ROOT
	CALMCP	DEQUER		;Dequeue this request.			;012
	BISB	#R.UMRW,TSQSTS(R4) ;MARK THIS AS WAITING FOR UMRS	;007
	MOV	#CMT+CM.QMR,R0	;R0-> UMR STALLED Q-ROOT
	CALMCP	JUMPQU		;Put this request on front of queue.	;012
	BIS	#US.UMR,U.STAT(R3) ;MARK THIS UNIT AS STALLED PENDING UMRs
	BR	80$		;RETURN
	
100$:	CALL	@RELUMR		;RELEASE UMRS
	BICB	#R.UMRA!R.SENT,TSQSTS(R4) ;Clear UMRs assigned & sent flags
	BR	80$		;EXIT

GLOBAL	<CMT,REGSCR,RELUMR>						;012

.DSABL	LSB

;+
; MTAGBF - BIG BUFFER FOR ANSI READ
; MTAGLB - GET AN ANSI LABEL BUFFER
;
; HERE WE EITHER JUST GET THE ANSI LABEL BUFFER OR IF IT
; IS A READ AND THERE IS NO LSB, THEN WE GET A BIG BUFFER
; AND GO PROCESS AS A READ.
;
; INPUT:	R5 -> CCB
;		R4 -> TSQ
;		R3 -> UCB
;-

MTAGBF:	MOVB	#ECA.MT,TSQCMD(R4) ;TAKE THE ECA ROUTE (DO NOTHING)
MTAGLB:	MOV	R1,-(SP)	;SAVE
	MOV	R3,-(SP)	;  SOME
	MOV	R4,-(SP)	;    REGISTERS
	MOV	R5,-(SP)	; . . . .	
	MOV	R4,R3		;COPY TSQ POINTER
	MOV	TSQDDB(R4),R4	;PICK UP DDB POINTER
	MOV	MTUBUF(R4),TSQMAL(R3) ;SAVE WHAT'S IN MTUBUF
	PUSH	<R3>		;SAVE THIS
	CALLX	GETBIG,R5,MTULBF ;REQUEST A BIG I/O BUFFER
	POP	<R3>		;AND BACK, AGAIN
	MOV	MTUBUF(R4),R2	;GET THE BUFFER ADDRESS FROM THE DDB
	MOV	TSQMAL(R3),MTUBUF(R4) ;RESTORE MTU TO WHAT IT WAS
	MOV	R2,TSQMAL(R3)	;COPY THE BUFFER ADDRESS INTO THE TSQ
	MOV	(SP)+,R5	;RESTORE CCB POINTER
	MOV	(SP)+,R4	;RESTORE TSQ
	MOV	(SP)+,R3	;RESTORE UCB
	MOV	(SP)+,R1	;RESTORE PACKET POINTER
	CMPB	#ECA.MT,TSQCMD(R4) ;IS THIS GET ANSI LABEL SPEC?
	BNE	10$		;NOPE, SO ISSUE AS A BIG READ		;012
	JMP	MUNTM		;YES, TAKE NO TAPE MOTION ROUTE
10$:	JMP	MUREAD		;Branch out-of-range kludge.		;012
;+
; MTAECA - ERROR CONDITION ACKNOWLEDGED PROCESSING
;-
MTAECA:	BIT	#US.LCK,U.STAT(R3) ;"ERROR LOCKED" STATE?
	BEQ	JMUNTM		;Nope, so this is a NOP			;014
;+
; NOTE: (FROM YOUR SPONSOR)
; OK, WE REALLY HAVE AN ECA.  WE ARE GOING TO CLEAR THE "ERROR LOCKED"
; STATE IN THE UCB, THE UNIT HAS BEEN SYNCHRONIZED WITH THE USER AND WE CAN
; JUST SKIP TO DONE SERVICE HAPPY AND SMILING.
;-
	BIC	#US.LCK,U.STAT(R3) ;CLR "ERROR LOCKED" CONDITION
	PUSH	<R0>		;SAVE R0
	MOV	C.CMT(R5),R0	;R0->CMT OF REQUEST
	ADD	#CMT+CM.QUE,R0	;R0->TSQ QUEUE ROOT FOR CMT
	BISB	#R.SENT,TSQSTS(R4) ;SAY WE SENT IT
	CALMCP	DEQUER		;;Dequeue the request.			;012
	POP	<R0>		;RESTORE R0
	CALL	QUEMTD		;QUEUE IT UP FOR DONE SERVICE
	RETURN
;+
; MTACRW - ALLOW REWIND ON CLOSE
;-

MTACRW:	PUSH	<R1>		;SAVE A REGISTER
	MOV	TSQDDB(R4),R1	;PICK UP DDB POINTER
	BICB	#MT.NRW,MTFLAG(R1) ;ALLOW REWIND ON CLOSE
	POP	<R1>		;RESTORE REGISTER
JMUNTM:	JMP	MUNTM		;AND COMMON NOP

;+
; MUWTM - WRITE TAPE MARK
;
; INPUT:	R5 -> CCB
;		R4 -> TSQ
;		R3 -> UCB
;-
.ENABL	LSB

MUWTM:	CALL	PKTGET		;GET A COMMAND PACKET OR DON'T COME BACK
	MOV	#OP.WTM,P.OPCD(R1) ;SET WRITE TAPE MARK OPCODE
	.BR	SNDCMD		;AND FINISH SETTING UP PACKET

;+
; SNDCMD - SET-UP COMMAND PACKET AND TRY TO SEND TO 
;	   CONTROLLER.
;
; INPUT:	R1 ->  COMMAND PACKET
;		R3 ->  UCB 
;		R4 ->  TSQ 
;-
SNDCMD:	MOV	R4,(R1)		;SAVE DSQ AS LOW CMD.REF.NUMBER		;019
	.ASSUME	P.CRF	EQ	0
	MOV	R3,P.CRF+2(R1)	;SAVE UCB AS HIGH CMD.REF.NUMBER
	MOVB	(R3),P.UNIT(R1)	;SAVE UNIT NUMBER			;019
	.ASSUME	U.UNIT	EQ	0
	CALMCP	SENDCM		;Send the command to the controller.	;012
	BCS	10$		;SEND FAILED
	BISB	#R.SENT,TSQSTS(R4) ;INDICATE SENT STATUS IN TSQ
	RETURN			;AND LEAVE...

10$:	BICB	#R.SENT,TSQSTS(R4) ;NOTHING GOT SENT, WE'LL TRY AGAIN LATER
	RETURN			;THAT'S ALL

.DSABL	LSB

;+
; PKTGET - GET A COMMAND PACKET OR DON'T RETURN
;
; INPUT:	R3 ->  UCB 
;		R4 ->  TSQ 
;		R5 ->  CCB
;		SP ->  RETURN ADDRESS, SAVED VALUE
;
; IF SUCCESSFUL: R1 -> COMMAND PACKET, OTHERWISE WE RETURN TO
; MAINLINE REQUEST PROCESSING.
;-
.ENABL	LSB

PKTGET:	CALMCP	GTCPKT		;Get a command packet.			;012
	BCC	10$		;OK, WE'VE GOT ONE
	BICB	#R.SENT,TSQSTS(R4) ;TELL'EM TOUGH LUCK BABY
	TST	(SP)+		;DUMP RETURN ADDRESS...
10$:	RETURN			;AND LEAVE...

.DSABL	LSB

.SBTTL	TAPE REPOSITION COMMAND PROCESSING (REPO)
;+
; MUREW	- REWIND TAPE
;
; INPUT:	R5 -> CCB
;		R4 -> TSQ
;		R3 -> UCB
;-
.ENABL	LSB

MUREW:	CALL	PKTGET		;GET A COMMAND PACKET OR DON'T COME BACK
	MOV	#MD.RWD!MD.IMM,-(SP) ;SAVE REWIND WITH IMMEDIATE COMPLETION
	TSTB	TSQCMD(R4)	;REWIND OFFLINE?
	BNE	MUREP		;NOPE
	MOV	#MD.UNL,(SP)	;YES, WELL, SPECIFY AN UNLOAD TOO	;009
	MOV	#OP.AVL,P.OPCD(R1) ;AND MAKE THE UNIT AVAILABLE...	;009
	BR	10$		;CONTINUE IN COMMON PROCESSING		;009
	
MUREP:	MOV	#OP.REP,P.OPCD(R1) ;SAY THIS IS REPOSITION COMMAND
10$:	MOV	(SP)+,P.MOD(R1)	;WITH THESE MODIFIERS			;009
	CALL	SNDCMD		;SET UP PACKET AND TRY TO SEND IT
	RETURN			;LEAVE REGARDLESS...		

;+
; MUBSP - SKIP BACKWARD PROCESSING (BACKSPACE)
;-
MUBSP:	CALL	PKTGET		;GET A PACKET OR DON'T COME BACK
	MOV	#MD.REV,-(SP)	;WE HAVE TO GO BACKWARDS
	BR	20$		;GET TO COMMON CODE
;+
; MUSKP - SKIP FORWARD PROCESSING (SPACE)
;-
MUSKP:	CALL	PKTGET		;TRY FOR A PACKET OR DON'T COME BACK
	CLR	-(SP)		;ENSURE DIRECTION/OBJECT COUNT ARE CLEAR
20$:	MOV	TSQCNT(R4),P.BCNT(R1)	;Did they give a zero?		;017
	BNE	MUREP		; No, join common reposition code.	;017
	INC	P.TCNT(R1)	;Say to move 1 tape mark.		;017
	INC	TSQCNT(R4)	;Set skip count to 1.			;017
;	CLR	P.BCNT(R1)	;Remember, byte count is zero.		;017
	BR	MUREP		;Go join common code.			;017

.DSABL	LSB

.SBTTL	MUSET - SET DENSITY/PARITY COMMAND PROCESSING
;+
; MUSET	- SET DENSITY/PARITY FOR THIS MAGTAPE.  FOR NOW
;	TSQCNT WILL CONTAIN 14 FOR 800 BPI, 400 FOR 1600
;	BPI.  PARITY IS EVEN IF A ONE IS SET IN TSQCNT AND ODD
;	IF 0.  
;
; INPUT:	R5 -> CCB
;		R4 -> TSQ
;		R3 -> UCB
;
.ENABL	LSB

MUSET:	MOV	R5,-(SP)	;Save CCB pointer			;014
	MOV	#<32768.+1600.>,R5	;Assume 1600 BPI		;014
	BIT	#400,TSQCNT(R4) ;DO THEY WANT 1600?
	BNE	10$		;Yes					;014
	MOV	#<32768.+800.>,R5	;No, must be 800 BPI		;014
	BR	10$		;Drop to common processor		;014

.SBTTL	MTAXDN - SET EXTENDED DENSITY FUNCTION PROCESSING
;+
; MTAXDN - SET EXTENDED DENSITY 
;
;
; INPUT:	R5 -> CCB
;		R4 -> TSQ
;		R3 -> UCB
;
MTAXDN:	PUSH	R5		;SAVE CCB POINTER
	MOV	TSQCNT(R4),R5	;GET USER PARAMETER
	BEQ	40$		;Not there, just get current density	;014
	BPL	10$		;Bit 15 not set, so just check a	;015
				; density for validity.			;015
	MOV	TSQDDB(R4),R1	;PICK UP OUR DDB POINTER
	BIT	#MU$BOT,MUAINF(R1) ;ARE WE AT BOT?
	BEQ	60$		;Nope, can't set it			;014
10$:	MOV	R5,R1		;Copy parameter				;014
	BPL	15$		;User wants to check a density		;015
	BIC	#100000,R1	;Get rid of set flag			;015
15$:	CALL	GETDEN		;Get the current density		;015
	CMP	R1,R2		;Current = What he wants?		;015
	BEQ	35$		;Yep, so this is a NOP			;015
	MOV	R5,R1		;Copy parameter once again		;015
	CALL	VERDEN		;VERIFY DENSITY
	BCS	50$		;VERDEN gave us an error		;014	
	CMPB	TSQCMD(R4),#DEN.MT ;Old style call?			;014
	BEQ	20$		;Yes. DEN.MT returns 0			;015 
	MOV	R5,TSQRET(R4)	;No. Return closest density		;015
20$:	POP	R5		;Now restore CCB pointer		;015
	TST	R1		;Did we want to set a density?		;014
 	BPL	MUNTM		;Nope, just return it			;014
	MOV	R2,U.FORM(R3)	;Save this density in UCB		;014
	MOV	TSQDDB(R4),R1	;Get the DDB pointer again.		;015
	BICB	#MT.PAR!MT.DEN,MTOFLG(R1) ;Say odd parity, 1600 for now	;014
	CALL	DEN800		;Check for 800 BPI			;014
	BCS	30$		;Nope, other density or cartridge mode	;014
	BISB	#MT.DEN,MTDDSP(R1) ;OK, set it to 800			;014
30$:	CALL	PKTGET		;GET A  COMMAND PACKET OR DON'T COME BACK
	MOV	#OP.SUC,P.OPCD(R1) ;SAY THIS IS A SET UNIT CHARACTERISTICS
	MOV	R2,P.FORM(R1)	;With this density format		;014
	JMP	SNDCMD		;AND SEND THE COMMAND TO THE CONTROLLER

35$:	CMPB	TSQCMD(R4),#DEN.MT ;Old style call?			;015
	BEQ	90$		;Yes.  Restore CCB pointer and get out	;015
	MOV	R1,TSQRET(R4)	;Return density asked for		;015
	BR	90$		;Now go restore CCB pointer		;015

40$:	POP	R5		;Restore CCB pointer			;014
	CALL	PKTGET		;Get a command packet or don't return	;014
	MOV	#OP.GUS,P.OPCD(R1) ;Perform a Get Unit Status		;014
	JMP	SNDCMD		;Go issue it				;014

50$:	SETERR	BDNERR,TSQCEV(R4) ;Bad number error			;014
	BR	70$		;Join common error handling		;014

60$:	SETERR	NOTMTA,TSQCEV(R4) ;Illegal MAGTAPE usage error		;015
70$:	CMPB	TSQCMD(R4),#DEN.MT ;Old style call?			;014
	BNE	80$		;Nope.  Real error.			;015
	CLRB	TSQCEV(R4)	;No harm, no foul			;014
	BR	90$		;Finish up				;015

80$:	MOV	R5,TSQRET(R4)	;Return closest density			;015
90$:	POP	R5		;Restore CCB pointer			;015
	.BR	MUNTM		;All done in here			;014

.SBTTL	MTACHR - RETURN FILE CHARACTERISTICS COMMAND PROCESSING
;+
; MTACHR - RETURN FILE CHARACTERISTICS COMMAND PROCESSOR.
;
; NOP COMMAND, ACTUAL PROCESSING DONE AT PROCESS RESPONSE TIME.
;
; INPUT:	R5 -> CCB
;		R4 -> TSQ
;		R3 -> UCB
;
MTACHR:	.BR	MUNTM		;TREAT THIS AS A NOP

.SBTTL	MURUS - RETURN UNIT STATUS COMMAND PROCESSING
;+
; MURUS - RETURN UNIT CHARACTERISTICS PROCESSING
;
; NOP COMMAND, ACTUAL PROCESSING DONE AT PROCESS RESPONSE TIME.
;
; INPUT:	R5 -> CCB
;		R4 -> TSQ
;		R3 -> UCB
;
MURUS:	.BR	MUNTM

.SBTTL	MUNTM - NON-TAPE-MOTION COMMAND PROCESSING (NOPs)
;+
; MUNTM	- NON TAPE MOTION REQUEST PROCESSING.  ALL NTM
; 	REQUESTS ARE PROCESSED AS NOPs WITH ACTUAL PROCESSING
;	DONE AT PROCESS RESPONSE TIME.
;
; MUNTMP - NON TAPE MOTION REQUEST THAT ALREADLY ALLOCATED A 
;	COMMAND PACKET.
;
; INPUT:	R5 -> CCB
;		R4 -> TSQ
;		R3 -> UCB
;
; VALID NTMs:	GET FILE CHARACTERISTICS
;		REWIND ON CLOSE
;		END OF VOLUME
;		ERROR CONDITION ACKNOWLEDGED (ECA)
;		GET ANSI LABEL BUFFER
;-

MUNTM:	CALL	PKTGET		;TRY FOR A PACKET
MUNTMP:	CLR	-(SP)		;ENSURE REWIND MODIFIER IS CLEAR
	JMP	MUREP		;Issue the NOP.				;017

.DSABL	LSB

.SBTTL	MURESP  -  TMSCP PROCESS RESPONSE SERVICE
;+
; MURESP - PROCESS COMPLETION OF TAPE REQUEST
;   INPUT:	R5 -> CCB
;		R3 =  END MESSAGE OPCODE * 2 (FROM BITS 0:5 OF P.OPCD)
;		R1 -> RESPONSE PACKET
;
; R0, R2 and R4 are modified.						;012
;
;-

	TMPORG	BBRDSP,6		;Set up dispatch point		;012
	.WORD	$MURSP			;for mapped indirect call.	;012
	UNORG								;012

.ENABL	LSB

$MURSP:									;012
MURESP:	CMP	#MUTBLE-MU$TBL,R3	;VALID END CODE?
	BLOS	80$			;NOPE, SO PUNT			;009
	MOV	C.PDVR(R5),R0		;YES, SO GET PORT DRIVER DIS. TABLE
	MOV	P.CRF+2(R1),R4		;PICK UP UCB POINTER
	BIT	#US.SYC,U.STAT(R4)	;ARE WE SYNCHRONIZING?
	BEQ	10$			;NO, SO CONTINUE
	CMPB	#ST.SEX,P.STS(R1)	;IS THIS SERIOUS EXCEP. END STATUS?
	BEQ	80$			;YES, WELL WAIT TILL SYNCH FINISHES ;009
	BR	20$			;NOPE, CLR SEX NOP, DON'T TOUCH CMD STATUS

10$:	CALL	SETSTS			;SET COMMAND STATUS
20$:	MOV	MU$TBL(R3),R2		;Get routine address/2.		;012
	CLC				;Don't let C get in the way!!	;012
	ROL	R2			;Fix address and set/clear C.	;012
	BCS	30$			;It's mapped, so go out for it.	;012
	CALL	(R2)			;Check out this response locally;012
	BR	40$			;And, go on.			;012

30$:	PUSH	<R2>			;Push address to be called.	;012
	PUSH	<#40$>			;Put return address on stack.	;012
	JMPX	CALMCP			;And, go do mapped call to MCP.	;012

;+
; NOTE: We may never come back here.  Some routines that we		;012
;	dispatch to go directly back to CPH without returning		;012
;	here (see MUERR and SYN.MU)					;012
;-
40$:	CMPB	P.OPCD(R1),#OP.ONL	;IS THIS AN ONLINE REQ. (FROM GUS)?
	BEQ	80$			;OOPS, GET OUT OF HERE FAST...	;009
	MOV	(R1),R4			;PICK UP TSQ POINTER		;019
	.ASSUME	P.CRF	EQ	0
	BEQ	50$			;OOPS, NO TSQ
	CMPB	#MAGSEL,TSQCEV(R4)	;MAGSEL ERROR?
	BNE	50$			;NOPE
	CMPB	#UNT.MT,TSQCMD(R4)	;ON A GET UNIT STATUS?
	BNE	50$			;NOPE
	MOV	#MU$OFL,TSQRET(R4)	;YES, MAKE SURE THEY KNOW IT'S OFFLINE
50$:	CMPB	P.OPCD(R1),#OP.GUS!200	;IS THIS A GUS END?
	BNE	60$			;NOPE
	MOV	P.CRF+2(R1),R3		;PICK UP UCB POINTER
	MOV	P.FORM(R1),U.FORM(R3)	;Save current format		;014
	MOV	P.FMEN(R1),U.FMEN(R3)	;Save drive's format menu	;014
	TST	R4			;Was there a TSQ?		;014
	BEQ	80$			;No, GUS does nothing else	;014
	MOV	U.FORM(R3),R2		;Get current density flag	;014
	MOV	TSQDDB(R4),R0		;Get DDB pointer		;014
	BEQ	55$			;No DDB, punt.			;015
	BICB	#MT.DEN,MTFLAG(R0) 	;Assume 1600			;014
	CALL	DEN800			;Really 800?			;014
	BCS	55$			;Nope, other density format	;014
	BISB	#MT.DEN,MTFLAG(R0)	;OK, set it to 800		;014
55$:	CMPB	#XDN.MT,TSQCMD(R4)	;Extended density call?		;014
	BNE	80$			;GUS does nothing else		;014
	CALL	GETDEN			;Find current density		;015
	MOV	R2,TSQRET(R4)		;Return current density		;015
	BR	75$			;Go post call to done processing;014

60$:	CMPB	P.OPCD(R1),#OP.AVL!OP.END	;An available command?	;014
	BEQ	70$			;YES, SO CONTINUE		;009
	CMPB	P.OPCD(R1),#12!OP.END	;GCS,GUS,SCC,or ONLINE end MSG?	;014
	BLO	80$			;Yes, then no TSQ associated	;014
.ASSUME	OP.GCS LT 12
.ASSUME	OP.GUS LT 12
.ASSUME	OP.SCC LT 12
.ASSUME	OP.ONL LT 12
;+
; NOTE: We don't issue ABORTs (1) or ACCESS NVM (5), and
;       no other commands below 12 are currently defined
;-
70$:	MOV	(R1),R4			;GET OUR TSQ POINTER		;019
	.ASSUME	P.CRF	EQ	0
	BEQ	80$			;Leave if nothing (Sanity check);014
75$:	MOV	C.CMT(R5),R0		;Pick up CMT offset		;014
	ADD	#CMT+CM.QUE,R0		;Point to this unit's CMT queue	;014
	CALMCP	DEQUER			;;Deque this request.		;012
	CALL	QUEMTD			;AND QUEUE FOR DONE SERVICE
80$:	RETURN				;BACK TO PRORSP (CPH) TO RELEASE PACKET ;009

.SBTTL	MU$TBL  - TMSCP RESPONSE MESSAGE PROCESSING TABLE
;+
; This table contains the addresses of the routines to be called for	;012
; TMSCP End Message processing.  The actual value stored is (address/2)	;012
; with Bit 15 set if the call is external to another phase (and thus	;012
; needs to be called mapped).						;012
;
; Commands marked with;
;	"*"	are not implemented in this driver.			;012
;	"!"	are not valid for TMSCP.				;012
;	"%"	are TMSCP-specific.					;012
;-

MAPPED	=	100000		; Bit to say call is mapped external.	;012

MU$TBL:	.WORD	CRASH/2			; Shouldn't get here		;012
	.WORD	CRASH/2			; Abort *			;012
	.WORD	MAPPED!<GCSEND/2>	; Get Command Status		;012
	.WORD	MAPPED!<GUSEND/2>	; Get Unit Status		;012
	.WORD	MAPPED!<SCCEND/2>	; Set Controller Characteristics;012
	.WORD	CRASH/2			; Access Non-Volatile Memory	;014
	.WORD	CRASH/2			; (Not used)			;012
	.WORD	IGNORE/2		; Serious Exception [CPH]	;012
	.WORD	REP.MU/2		; Available (rewind offline)	;012
	.WORD	ONL.MU/2		; Online			;012
	.WORD	SUC.MU/2		; Set Unit Characteristics	;012
	.WORD	CRASH/2			; Determine Access Path (*)	;012
	.WORD	CRASH/2			; (Not used)			;012
	.WORD	CRASH/2			; (Not used)			;012
	.WORD	CRASH/2			; (Not used)			;012
	.WORD	CRASH/2			; (Not used)			;012
	.WORD	CRASH/2			; Access *			;012
	.WORD	CRASH/2			; Compare Controller Data *	;012
	.WORD	CRASH/2			; Erase !			;012
	.WORD	CRASH/2			; Flush !			;012
	.WORD	CRASH/2			; Replace (BBR) !		;012
	.WORD	CRASH/2			; (Not used)			;012
	.WORD	CRASH/2			; Erase Gap *			;012
	.WORD	CRASH/2			; (Not used)			;012
	.WORD	CRASH/2			; (Not used)			;012
	.WORD	CRASH/2			; (Not used)			;012
	.WORD	CRASH/2			; (Not used)			;012
	.WORD	CRASH/2			; (Not used)			;012
	.WORD	CRASH/2			; (Not used)			;012
	.WORD	CRASH/2			; (Not used)			;012
	.WORD	CRASH/2			; (Not used)			;012
	.WORD	CRASH/2			; (Not used)			;012
	.WORD	IGNORE/2		; Compare Host Data *		;012
	.WORD	RD.MU/2			; Read				;012
	.WORD	WR.MU/2			; Write				;012
	.WORD	CRASH/2			; (Not used)			;012
	.WORD	WTM.MU/2		; Write Tape Mark %		;012
	.WORD	REP.MU/2		; Reposition %			;012
MUTBLE:					; Address of end of table.	;012

CRASH:	CRASH		;SOMETHING'S WRONG, CRASH AND BURN...

IGNORE:	RETURN		;IGNORE THIS GUY

GLOBAL	<GCSEND,GUSEND,SCCEND>						;012


.SBTTL	SETSTS - SET TAPE STATUS
;+
; SETSTS - SET TAPE STATUS IN MTLCST
;
; INPUT:	R1 -> RESPONSE PACKET
;
; ALL REGISTERS PRESERVED
;-				
.ENABL	LSB

SETSTS:	CMPB	P.OPCD(R1),#OP.ONL ;IS THIS ONLINE (FROM GUS)?
	BEQ	40$		;YES, SO LEAVE FAST
	CMPB	P.OPCD(R1),#OP.SUC!200 ;GCS/GUS/SCC/ONLINE END?
	BMI	40$		;YES, SO LEAVE FAST
	MOV	R3,-(SP)	;SAVE A REGISTER
	MOV	R4,-(SP)	;AND ANOTHER
	MOV	(R1),R4		;PICK UP TSQ POINTER			;019
	.ASSUME	P.CRF	EQ	0
	CMPB	#UNT.MT,TSQCMD(R4) ;IS THIS A RETURN UNIT STATUS?
	BEQ	35$		;YES, SO DON'T DO ANYTHING
	MOV	TSQDDB(R4),R3	;PICK UP DDB POINTER
	MOVB	TSQCMD(R4),MTLCMD(R3) ;SAVE LAST COMMAND
	BIC	#MU$BET!MU$LER,MUAINF(R3) ;CLR STATUS FLGS
	CLR	R0		;GET TO OFFSET 0
4$:	CMPB	TSQCMD(R4),NTMSTS(R0) ;SHOULD WE TOUCH BOT FLAG?
	BEQ	5$		;NOPE
	TSTB	(R0)+		;UP TO NEXT ENTRY
	TSTB	NTMSTS(R0)	;END?
	BPL	4$		;NO
	BIC	#MU$BOT,MUAINF(R3) ;MOTION COMMAND
5$:	CLR	R4		;CLR STATUS WORD
	CMPB	#ST.TM,P.STS(R1) ;DID WE HIT A TAPE MARK?
	BNE	10$		;NO, SO CONTINUE
	BIS	#MTEOF,R4	;SAY TAPE MARK ENCOUNTERED
10$:	CMPB	#ST.RDT,P.STS(R1) ;HOW 'BOUT RECORD DATA TRUNCATED?
	BNE	20$		;NOPE
	BIS	#MTRLE,R4	;YES, SO REPORT RECORD LENGTH ERROR
20$:	BITB	#EF.EOT,P.FLGS(R1) ;END OF TAPE?
	BEQ	30$		;NOPE
	BIS	#MTEOT,R4	;YES, SO SET IT
30$:	MOV	R4,MTLCST(R3)	;AND SET LAST COMMAND STATUS
35$:	MOV	(SP)+,R4	;RESTORE A REGISTER
	MOV	(SP)+,R3	;AND ANOTHER
40$:	RETURN			;WE'RE DONE

;+
;THE FOLLOWING COMMANDS WON'T EFFECT THE REWIND FLAG
;-
NTMSTS:	.BYTE	RWO.MT	;REWIND (OFFLINE)
	.BYTE	REW.MT	;REWIND (HANDLED IN REP.MU)
	.BYTE	DEN.MT	;SET DENSITY
	.BYTE	UNT.MT	;GET UNIT STATUS
	.BYTE	FIL.MT	;GET FILE CHARACTERISTICS
	.BYTE	ECA.MT	;ERROR CONDITION ACKNOWLEDGE
	.BYTE	XDN.MT	;SET EXTENDED DENSITY
	.BYTE	-1.

.DSABL	LSB

.SBTTL	ONL.MU - TAPE ONLINE END PACKET PROCESSOR
;+
; ONL.MU - ONLINE END PACKET PROCESSING
;
; INPUT:	R5 -> CCB
;		R1 -> END PACKET
;
; OUTPUT: IF SUCCESSFUL, DRIVE IS SET TO ONLINE STATE.
;	  IF NOT SUCCESSFUL, DRIVE IS SET TO OFFLINE
;	  STATE AND REQUESTS TO IT ARE RETURNED WITH
;	  MAGTAPE SELECT ERRORS. 
;
;		R3 -> UCB on exit
;-
ONL.MU:	MOV	P.CRF+2(R1),R3		;R3 -> UCB
	PUSH	<R4>			;SAVE R4
	MOV	(R1),R4			;GET DSQ POINTER		;019
	.ASSUME	P.CRF	EQ	0
	MOV	TSQDDB(R4),R4		;AND DDB POINTER FINALLY
	MOV	#OLFERR,MSCPER		;Assume failure			;014
	BIS	#MU$OFL,MUAINF(R4)	;SAY WE'RE OFFLINE
	BIT	#ST.MSK,P.STS(R1)	;ONLINE SUCCESSFUL?
	BEQ	30$			;Yep.  No problems here		;014
	CALMCP	UNTOFF			;Unsuccessful, mark it offline	;014
	CALMCP	LOG.PH			;Log an error			;014
	BR	40$			;All done			;014

30$:	BIC	#US.OLP,U.STAT(R3)	;Clear online in progress	;014
	BIS	#US.ONL,U.STAT(R3) 	;AND INDICATE UNIT ONLINE
	BIS	#MU$BOT,MUAINF(R4)	;SAY WE'RE AT BOT
	BIC	#MU$OFL!MU$WPR,MUAINF(R4) ;CLR UNIT OFFLINE FLAG/WRITE PROTECT
	MOV	P.FORM(R1),U.FORM(R3)	;SAVE UNIT DENSITY
	MOV	P.SPED(R1),U.SPED(R3)	;SAVE UNIT SPEED
	MOVB	P.UNTI+6(R1),MUTYP(R4)	;Save unit model type in DDB.	;014
	BIT	#<UF.WPH!UF.WPS!UF.WPD>,P.UNFL(R1) ;Write protected?	;014
	BEQ	40$			;NOPE
	BIS	#MU$WPR,MUAINF(R4)	;YES, SO SAY WRITE PROTECTED
40$:	POP	<R4>			;RESTORE R4
	RETURN				;AND RETURN...

.SBTTL	SUC.MU - SET UNIT CHARACTERISTICS RESPONSE MESSAGES
;+
; SUC.MU - PROCESS SUC RESPONSE
;
; INPUT:	R5 -> CCB
;		R1 -> RESPONSE PACKET
;
;-				
.ENABL	LSB

SUC.MU:	MOV	P.STS(R1),R2		;ANY ERRORS?
	BIT	#ST.MSK,R2		; (Don't look at the subcode.)	;016
	BEQ	80$			;Nope, all's well...		;014
JMUERR:	JMP	MUERR			;Other error, check it out...	;014

80$:	RETURN				;All done			;014

.DSABL	LSB

.SBTTL	RD.MU/WR.MU - PROCESS READ/WRITE RESPONSE MESSAGES
;+
; RD.MU/WR.MU - READ/WRITE RESPONSE MESSAGE PROCESSING
;
; INPUT:	R5 -> CCB
;		R4 =  CMT
;		R1 -> RESPONSE PACKET
;		R0 -> PORT DRIVER DISPATCH TABLE
;
; OUTPUT:	SUCCESS -> WE QUE TO DONE QUEUE FOR POSTING
;	
;		FAILURE -> WE CLR SERIOUS EXCEPTION (IF APPLICABLE)
;			   ERROR IS SAVED AND WE QUE TO DONE QUEUE
;			   FOR POSTING.
;-
RD.MU:
WR.MU:	MOV	(R1),R4			;R4 -> TSQ OF CURRENT REQUEST	;019
	.ASSUME	P.CRF	EQ	0
	MOV	P.CRF+2(R1),R3		;R3 -> UCB
	BITB	#R.UMRA,TSQSTS(R4)	;NEED TO DEALLOCATE UMRS?
	BEQ	10$			;NOPE
	CALL	@RELUMR			;RELEASE ANY UMRS
10$:	MOV	P.BCNT(R1),TSQRET(R4)	;SAVE #BYTES TRANSFERRED (ALWAYS)
	MOV	P.STS(R1),R2		;WAS REQUEST SUCCESSFUL?
	BNE	JMUERR			;Nope, so do error processing	;014
	BITB	#EF.LOG,P.FLGS(R1)	;ERROR LOG GENERATED?
	BEQ	50$			;NOPE, ALL IS WELL, SO LEAVE
	CLR	MSCPER			;INDICATE HARDWARE ERROR
	CALMCP	LOG.PH			;Log the info.			;012
50$:	RETURN				; RETURN TO CALLER

.SBTTL	REP.MU - REPOSITION RESPONSE PROCESSING
;+
; REP.MU - RESPONSE PROCESSING FOR ALL FLAVORS OF REPOSITION
;	   (AND WRITE-TAPE-MARK)
;
; INPUT:	R5 -> CCB
;		R1 -> RESPONSE PACKET
;
;	HERE WE HANDLE ALL FLAVORS OF THE REPOSITION COMMAND.  THESE INCLUDE
;	SKIP FORWARD, BACKSPACE, REWIND, REWIND UNLOAD AND NOP (INCLUDING THE
;	CLR SERIOUS EXCEPTION NOP).
;
;	ESPECIALLY IMPORTANT TO NOTE THAT IF WE GET A REPO PACKET BACK WITH
;	R.ERR ALREADY SET IN TSQSTS, THEN THIS IS THE END PACKET OF A CLR
;	SERIOUS EXCEPTION.  WE HAVE SPECIAL STUFF TO DO.
;-
WTM.MU:	
REP.MU:	MOV	(R1),R4		;PICK UP TSQ POINTER			;019
	.ASSUME	P.CRF	EQ	0
	MOV	TSQDDB(R4),R3	;PICK UP DDB POINTER			;011
	CMPB	#REW.MT,TSQCMD(R4) ;A REWIND?
	BEQ	60$		;YES					;011
	TSTB	TSQCMD(R4)	;A REWIND-OFFLINE?			;011
	BNE	70$		;NO					;011
	PUSH	<R3>		;SAVE DDB POINTER			;011
	MOV	P.CRF+2(R1),R3	;PICK UP UCB POINTER			;011
	MOV	#US.AVL,U.STAT(R3) ;MARK UCB AS AVAILABLE		;011
	POP	<R3>		;RESTORE DDB POINTER			;011
60$:	TSTB	P.STS(R1)	;SUCESSFUL?
	BNE	130$		;NOPE
	BIS	#MU$BOT,MUAINF(R3) ;YES, SO SAY AT BOT			;011
	RETURN			;AND LEAVE
	
70$:	BITB	#R.ERR,TSQSTS(R4) ;RESULT OF A SYNCHRONIZATION NOP?
	BNE	SYN.MU		;YES, SO FINISH SYNCHRONIZING WITH UNIT
	CMPB	#BSP.MT,TSQCMD(R4) ;BACKSPACE?
	BEQ	75$		;YES
	CMPB	#SKP.MT,TSQCMD(R4) ;SPACE FORWARD?
	BNE	80$		;NOPE
75$:	MOV	TSQCNT(R4),TSQRET(R4) ;RETURN AMOUNT WE WANTED TO SKIP
	SUB	P.BCNT(R1),TSQRET(R4) ;MINUS RECORDS SKIPPED
	SUB	P.TCNT(R1),TSQRET(R4) ; and tape marks skipped.		;017
	BR	130$		;AND CHECK FOR ERRORS

80$:	CMPB	#UNT.MT,TSQCMD(R4);IS THIS A RETURN UNIT STATUS?
	BNE	95$		;NOPE
	MOVB	MTLCMD(R3),TSQRET(R4) ;REPORT LAST COMMAND		;011
	BIC	#^C<7>,TSQRET(R4) ;GET RID OF EXTRANEOUS GARBAGE
	MOV	MUAINF(R3),-(SP) ;GET UNIT STATUS FLAGS			;011
	BIC	#^C<MU$LER!MU$WPR!MU$BET!MU$BOT!MU$OFL>,(SP) ;CLR EXTRANEOUS BITS
	BIS	#10030,(SP)	;DEFAULT TO 1600 BPI
	BIT	#MTEOF,MTLCST(R3) ;HIT TAPE MARK ON LAST?		;011
	BEQ	93$		;NOPE
	BIS	#200,(SP) 	;YES, SO MARK ERROR+EOF
93$:	BIT	#MTRLE,MTLCST(R3) ;HOW 'BOUT RECORD LENGTH ERROR?	;011
	BEQ	94$		;NOPE
	BIS	#100,(SP)	;YES, SO MARK IT
94$:	BIS	(SP)+,TSQRET(R4) ;OKAY SO RETURN CURRENT STATUS
	BR	130$		;AND EXIT
	
95$:	CMPB	#FIL.MT,TSQCMD(R4) ;HEY, IS THIS A RETURN FILE CHARACTERISTICS?
	BNE	110$		;NOPE,
	CLR	TSQRET(R4)	;CLR THE RETURNED VALUE
	MOV	MTACB(R3),R3	;GET ACB ADDRESS			;011
	BEQ	110$		;NONE, SO WE'RE DONE			;011
	MOV	(R3),TSQRET(R4)	;GOT ONE, SO RETURN THE CHARACTERISTICS ;011
110$:	CMPB	#EOV.MT,TSQCMD(R4) ;IS THIS EOV SPEC?
	BNE	130$		;NOPE
	MOV	MTACB(R3),R3	;GET ACB POINTER			;011
	BNE	120$		;GOOD, THERE IS ONE
	SETERR  NOTMTA,TSQCEV(R4) ;EOV .SPEC NOT ALLOWED ON DOS TAPE
	BR	140$		;AND WE'RE DONE

120$:	MOV	#^REOV,2(R3)	;SAY EOV LABEL TYPE			;011
	BR	140$		;AND LEAVE

130$:	MOVB	P.STS(R1),R2	;WAS REQUEST SUCCESSFUL?
	BEQ	140$		;YES
	JMP	MUERR		;ERROR, SO PROCESS IT

140$:	RETURN			;NOT DOING ANYTHING QUITE YET

.SBTTL	SYN.MU - CLR SERIOUS EXCEPTION RESPONE PROCESSING
;+
; SYN.MU - RESPONSE PROCESSING FOR CLR SERIOUS EXCEPTION NOPs
;
; INPUT:	R1 -> RESPONSE PACKET
;		R4 -> TSQ
;		R5 -> CCB
;
; OK, WE'RE HERE BECAUSE WE RECEIVED A SYNCHRONIZATION END MESSAGE
; TELLING US THAT WE'VE JUST CLR'D A SERIOUS EXCEPTION AND NOW MUST
; SYNCHRONIZE WITH THE USER.  WE CLR OFF ALL COMMAND QUES AND WILL
; THEN WAIT FOR A ECA BEFORE WE UNLOCK THE TAPE UNIT.
;-
SYN.MU: MOV	C.CMT(R5),R0		;R0=CMT OFFSET
	ADD	#CMT+CM.QUE,R0		;R0->REQUEST QUEUE ROOT
	PUSH	<R4>			;SAVE ORIGINAL TSQ
	CALMCP	DEQUER			;;Deque this request		;012
	CALL	QUEMTD			;AND QUE IT FOR DONE SERVICE
;+
;	REMOVE ANY REQUESTS ALREADY SENT TO CONTROLLER
;-

2$:	MOV	(R0),R4			;PICK UP TSQ, IF ANY
	BEQ	5$			;DONE
	BITB	#R.SENT,TSQSTS(R4)	;ALREADY SENT?
	BNE	3$			;YES, SO DEQUE IT
	MOV	R4,R0			;ELSE, CHECK NEXT ENTRY
	BR	2$

3$:	MOV	C.CMT(R5),R0		;R0=CMT OFFSET
	ADD	#CMT+CM.QUE,R0		;R0->REQUEST QUEUE ROOT
	CALL	15$			;DEQUE AND QUE TO DONE QUEUE
	BR	2$			;AND CONTINUE THROUGH LIST

;+
;	REMOVE ALL TAPE REQUESTS FOR THIS UNIT FROM THE UMR STALLED QUEUE
;-
5$:	MOV	P.CRF+2(R1),R3		;PICK UP UCB POINTER
	BIT	#US.UMR,U.STAT(R3)	;ARE WE UMR STALLED TOO?
	BEQ	7$			;NO, SO IT'S A LITTLE EASIER
	BIC	#US.UMR,U.STAT(R3)	;YES, BUT NOT ANYMORE
	MOV	#CMT+CM.QMR,R0		;OK, WE NEED THE UMR STALLED QUEUE ROOT
	MOV	R0,R4			;COPY ROOT POINTER
6$:	MOV	(R4),R4			;GRAB A TSQ
	BEQ	7$			;NOTHING TO DO
	TSTB	TSQID(R4)		;OOPS, SOMETHING. IS THIS A TSQ?
	BPL	6$			;NO, SO CHECK NEXT
	CMPB	TSQPUN(R4),P.UNIT(R1)	;FOR THIS UNIT AT ALL?
	BNE	6$			;NOPE, MAYBE NEXT
	CALL	15$			;YES, SO DEQUE AND QUEUE TO DONE QUE

;+
;	REMOVE ANY REQUESTS LEFT ON THE CM.QUE
;-
7$:	MOV	C.CMT(R5),R0		;R0=CMT OFFSET
	ADD	#CMT+CM.QUE,R0		;R0->REQUEST QUEUE ROOT
8$:	MOV	(R0),R4			;PICK UP TSQ
	BEQ	20$			;DONE
	CALL	15$			;DEQUE/QUE TO DONE W/DEVHNG
	BR	8$			;CONTINUE THROUGH QUE	

15$:	BITB	#R.UMRA,TSQSTS(R4)	;UMRs ASSIGNED?		;007
	BEQ	16$			;NOPE			;007
	CALL	@RELUMR			;YES, RELEASE ANY UMRs	;007
16$:	CALMCP	DEQUER			;Deque it from C.OLDL.		;012
	SETERR	HNGDEV,TSQCEV(R4)	;LOAD THE ERROR
	BISB	#R.SENT,TSQSTS(R4)	;MARK AS PROCESSED
	CALL	QUEMTD			;QUEUE THIS GUY TO CM.DNE
	RETURN

20$:	POP	<R4>			;RESTORE ORIGINAL TSQ
	BIC	#US.SYC,U.STAT(R3)	;WE IS SYNCHRONIZED!
	TST	(SP)+			;Pop MURESP return address off	;012
					; the stack and throw it away.	;012
	RETURN				;And return directly to CPH.	;012


.SBTTL	MUERR - TMSCP COMMON ERROR PROCESSOR
;+
; MUERR - TMSCP COMMON ERROR PROCESSING
;
;	INPUT	R2 =	COMMAND
;		R1 ->	PACKET
;		R3 ->	UCB
;
;-
.ENABL	LSB

MUERR:	MOV	(R1),R4		;Make sure we've got the TSQ pointer.	;016
	.ASSUME	P.CRF	EQ 0						;016
	BIC	#^C<ST.MSK>,R2	;CLEAR SUB CODE
	CMPB	#ST.OFL,R2	;UNIT OFFLINE?
	BNE	10$		;NOPE
	SETERR	MAGSEL,TSQCEV(R4) ;YES, GIVE MAG SELECT ERROR
	MOV	#MU$OFL,R2	;GET OFFLINE FLAG
	CALL	SETFLG		;SET IT
	BR	190$		;AND LEAVE...

10$:	CMPB	#ST.DAT,R2	;DATA ERROR?
	BNE	20$		;NOPE
15$:	SETERR	DATERR,TSQCEV(R4) ;Say "Data Error".			;016
	BR	110$		;MARK IT AND SYNC.

20$:	CMPB	#ST.WPR,R2	;UNIT WRITE PROTECTED?
	BNE	30$		;NOPE
	BIT	#SS.ROV,P.STS(R1);Subcode "Read-Only Volume Format"?	;016
	BNE	15$		;Yes, go issue Data Error.		;016
	MOV	#MU$WPR,R2	;GET UNIT WRITE PROTECTED FLAG
	SETERR	HNGDEV,TSQCEV(R4) ;RETURN DEVICE HUNG ERROR
	BR	120$

30$:	CMPB	#RED.MT,TSQCMD(R4) ;WAS THIS A READ FUNCTION?
	BEQ	90$		;YES, SO GO DO READ ERROR PROCESSING
	BITB	#EF.EOT,P.FLGS(R1) ;WAS THIS AN EOT ERROR?
	BEQ	40$		;NOPE					;010
	CMPB	#WRT.MT,TSQCMD(R4) ;IS THIS A WRITE AT EOT?		;010
	BEQ	170$		;YES, GIVE "NOROOM" ERROR		;010
	CMPB	#EOF.MT,TSQCMD(R4) ;HOW 'BOUT A WRITE-TAPE-MARK?	;010
	BEQ	170$		;YES, GIVE "NOROOM" ERROR		;010
	BR	180$		;OTHERWISE, ALL IS WELL			;010

40$:	CMPB	#SKP.MT,TSQCMD(R4) ;WAS THIS A SKIP FORWARD?		;010
	BEQ	70$		;YES
	CMPB	#BSP.MT,TSQCMD(R4) ;HOW ABOUT A BACKSPACE?
	BEQ	70$		;YES
50$:	MOVB	#HNGDEV,TSQCEV(R4) ;SAY, DEVICE HUNG OR WRITE LOCKED
	CLR	MSCPER		;SET DRIVER GENERATED ERROR CODE
	MOV	#US.AVL,U.STAT(R3) ;MAKE UNIT AVAILABLE SO THAT THE NEXT
				;REQUEST WILL BRING IT ONLINE AGAIN.
60$:	CALMCP	LOG.PH		;Call error logger.			;012
	BITB	#EF.SEX,P.FLGS(R1) ;HAVE TO CLR SERIOUS EXCEPTION?
	BNE	110$		;YES...
	RETURN
	
70$:	CMPB	#ST.BOT,R2	;DID WE REVERSE INTO BOT?
	BNE	80$		;NO
	MOV	#MU$BOT,R2	;YES, SAY AT BOT
	CALL	SETFLG		;SET THE FLAG
	BR	190$		;AND LEAVE (NO REAL ERROR)

80$:	CMPB	#ST.TM,R2	;DID WE HIT A TAPE MARK, MAYBE?
	BNE	50$		;NO, UNKNOWN ERROR CONDITION
	BISB	#R.ERR,TSQSTS(R4) ;NOT ERROR (BUT TAKE SYNCH PATH TO CLR SEX)
	BR	130$		;GO AND CLR SEX

90$:	CMPB	#ST.TM,R2	;WAS THERE A TAPE MARK?
	BEQ	160$		;YES, SO REPORT THAT
100$:	CMPB	#ST.RDT,R2	;RECORD DATA TRUNCATED (RECORD LEN. LONG)?
	BNE	140$		;NOPE
	BITB	#EF.SEX,P.FLGS(R1) ;OK, BUT WAS IT RECORD LENGTH SHORT?
	BEQ	190$		;YES, SO NOTHING SPECIAL
	SETERR	MAGRLE,TSQCEV(R4) ;SET MAGTAPE RECORD LENGTH ERROR
	MOV	TSQCNT(R4),TSQRET(R4) ;RETURN THE COUNT AS THE RETURNED VALUE
110$:	CLR	R2		;SET ERROR FLAG
120$:	CALL	SETFLG		;AND SET IT
130$:	CALL	SYNCH		;SYNCHRONIZE (CLR SEX)
	TST	(SP)+		;Pop MURESP return address off		;012
				; the stack and throw it away.		;012
	RETURN			;And return directly to CPH.		;012
	
140$:	BITB	#EF.EOT,P.FLGS(R1) ;WAS THIS AN EOT ERROR?
	BNE	190$		;YES, THAT IS NO ERROR
150$:	BR	50$		;NO, SO THIS IS A HNGDEV

160$:	SETERR	EOF,TSQCEV(R4)  ;SET AN EOF ERROR
	BR	110$		;SYNCHRONIZE (CLR SEX)

170$:	SETERR	NOROOM,TSQCEV(R4) ; SET THE NO ROOM FOR USER ON DEVICE ERROR ;010
180$:	BISB	#R.ERR,TSQSTS(R4) ;FLAG THIS TSQ AS ERR'D		;010
	BITB	#EF.SEX,P.FLGS(R1) ;SERIOUS EXCEPTION?
	BNE	130$		;YES, SO CLR IT...
190$:	RETURN

;+
; SETFLG - SET PASSED UNIT FLAG BIT IN MUAINF
;
; 	INPUT:	R4 ->TSQ
;		R2 = BITS TO SET IN MUAINF 
;
; WE MARK THE TSQ STATUS BIT FOR ERRORS AND ALSO FOR
; NON-ERRORS WHERE WE WANT TO CLR SERIOUS EXCEPTION.
; WE FLAG MUAINF BECAUSE WE USE THIS DATA FOR THE RETURN UNIT
; STATUS CALL.
;-
	
SETFLG:	PUSH	<R1>		;SAVE RESPONSE PACKET POINTER
	MOV	TSQDDB(R4),R1	;COPY DDB POINTER
	BIT	#MU$BOT,R2	;AT BEGINNING OF TAPE?
	BNE	200$		;YES, WELL NOT AN ERROR THEN
	BIS	#MU$LER,R2	;THIS COMMAND CAUSED AN ERR
	BISB	#R.ERR,TSQSTS(R4) ;SAY WE HAVE ERROR HERE
200$:	BIS	R2,MUAINF(R1)	;SET UNIT FLAG BITS	
	POP	<R1>		;RESTORE PACKET POINTER
	RETURN			;AND WE'RE DONE

GLOBAL	<DTAERR,DHGERR,MSCPER,HNGDEV>

.DSABL	LSB

;+
; SYNCH - SYNCHRONIZE WITH THE TAPE UNIT.
;
;	INPUT	R4 ->	TSQ OF RESPONSE
;		R5 ->	CCB
;
;	ALL REGISTERS PRESERVED
;
;	WE COME HERE TO CLR ANY REQUEST WHICH ENDS IN A SERIOUS EXCEPTION 
;	CONDITION.  WE WILL SEND OUT A NOP WITH A CLR SERIOUS EXCEPTION 
;	MODIFIER TO THE CONTROLLER TO CLR THE PROBLEM.  THIS UNIT WILL BE 
;	LOCKED (VIA US.LCK) AND MARKED AS SYNCHRONIZING (VIA US.SYC).
;
;	IF WE CAN'T GET A PACKET WE'LL BE COMING BACK HERE FROM PROREQ.  THE
;	TSQ IS MARK SPECIALLY BECAUSE WE MUST BE ABLE TO SYNCHRONIZE TO 
;	CONTINUE.  NOTE THAT UNIT WILL BE LOCKED UNTIL WE COMPLETE SYNCHRONI-
;	ZATION.
;-

SYNCH:	REGSCR			;SAVE EVERYONE
	PUSH	<R1>		;SAVE PACKET POINTER
	MOV	TSQDDB(R4),R1	;PICK UP DDB POINTER
	MOV	MUUCB(R1),R3	;AND PICK UP UCB POINTER
	BIS	#US.LCK!US.SYC,U.STAT(R3) ;LOCK THIS UNIT AND SAY WE'RE SYNCHRONIZING
	POP	<R1>		;RESTORE PACKET POINTER
	BISB	#R.SYN,TSQSTS(R4) ;MARK AS SYNCHRONIZATION TSQ
	CALL	PKTGET		;GET A COMMAND PACKET OR DON'T COME BACK
	MOV	#MD.CSE,-(SP)	;ALSO CLEARING SERIOUS EXCEPTION
	JMP	MUREP		;AND SEND THE COMMAND TO THE CONTROLLER

.SBTTL	DNE$MU - DONE PROCESSING
;+
; DNE$MU - DONE PROCESSING/POSTING OF REQUESTS 
;
; ALL POSTING SPECIAL CASES HANDLED HERE (3 FLAVORS) :
;	1) SYNCHRONOUS USER POSTING
;	2) ASYNCHRONOUS USER POSTING
;	3) MTU POSTING, ALL SYNCHRONOUS
;	
;-
	TMPORG	MUDINT,42						;019
	 .WORD	DNE$MU
	UNORG

DNE$MU:	MOV	#RTI3PH,-(SP)	;RETURNING VIA RTI3 (IF APPROPRIATE)
	MOV	#CMT+CM.DNE,R0	;GET THE Q-ROOT FOR THE DONE QUEUE
4$:	MOV	(R0),R4		;GET TSQ (IF ANY)
	BEQ	45$		;NOTHING OUT THERE			;009
	MOV	TSQDDB(R4),R3	;PICK UP DDB POINTER
	BIT	#MT.ECK,MTFLAG(R3) ;"ERROR LOCKED" CONDITION FOR THIS UNIT?
	BEQ	7$		;NOPE, SO ALL IS WELL
	BITB	#R.ECK,TSQSTS(R4) ;YES, IS THIS "ERROR CHECK" TSQ?
	BNE	9$		;YES, SO WE CAN PROCESS IT
	MOV	R4,R0		;NOPE, SO COPY TSQ POINTER
	BR	4$		;AND TRY NEXT ITEM

7$:	TST	(R4)		;ANYTHING ELSE IN QUEUE?
	BEQ	9$		;NOPE
	L3QSET	QMUDNE		;YES, SO LET'S MAKE SURE WE COME BACK
9$:	MOV	#CMT+CM.DNE,R0	;ALWAYS ENSURE WE HAVE QUEUE ROOT
	CALMCP	DEQUER		;;Dequeue the request (updating FWP/BWP).;012
	MOV	R4,R3		;COPY THE TSQ POINTER
	MOV	TSQDDB(R3),R4	;COPY THE DDB POINTER
	BITB	#R.SENT,TSQSTS(R3) ;-ERROR CHECK COMPLETION TSQ?
	BNE	10$		;-NOPE, SO CONTINUE
	PUSH	<R4>		;-YES, SO SAVE DDB POINTER
	MOV	MTFQB(R4),R4	;-COPY PHONEY FIRQB TO RETURN
	BUFFER	RETSML		;-RETURN SMALL BUFFER
	POP	<R4>		;-RESTORE DDB POINTER
	CLR	MTFQB(R4)	;-DON'T WANT THIS AROUND
	BR	12$		;-AND CONTINUE...

10$:	CMPB	#EOF,TSQCEV(R3)	;END-OF-FILE ERROR?
	BNE	12$		;NOPE, SO NOTHING SPECIAL
	BITB	#MT.OPN,TSQMTO(R3) ;FIP REQUEST?
	BEQ	12$		;YES, DON'T EVEN THINK ABOUT AN EOV
	TST	MTACB(R4)	;FILE-STRUCTURED ANSI PROCESSING?
	BEQ	12$		;NOPE, IT'S DOS, NOTHING SPECIAL
	BICB	#R.SENT,TSQSTS(R3) ;MARK ERR'D TSQ SPECIALLY
	BISB	#MT.ECK,MTFLAG(R4) ;SET ERROR CHECK FLAG IN DDB
	PUSH	<R4>		;SAVE DDB POINTER
	MOV	R3,R4		;COPY TSQ POINTER
	CALMCP	JUMPQU		;This guy goes to the head of the queue.;012
	POP	<R4>		;RESTORE DDB POINTER
	MOV	R4,R1		;R1->DDB @0
	TST	(SP)+		;GET RID OF RTI3 RETURN
	JMPM	ASYECK,MVRAP5	; and do the asynch error check (mapped);012

12$:	MOV	TSQDDB(R3),R4	;COPY THIS UNITS DDB POINTER
	BITB	#MT.OPN,TSQMTO(R3) ;WAS REQUEST ISSUED FROM MTU?
	BEQ	30$		;YES, SO RETURN THATAWAY, NO MORE SET UP
	MOVB	TSQJOB(R3),R0	;GET THE USER'S JOB NUMBER		;008
	TSTB	TSQSTS(R3) 	;ASYNCHRONOUS FUNCTION?
.ASSUME R.ASY EQ 200
	BMI	60$		;YEAH, GO POST ASYNCHRONOUS ANSWER

	.WEAK	JMPM,ASYECK,MVRAP5		;Not present in INIT.	;012

;+
; SYNCHRONOUS POSTING
;-
	PUSH	R4		;NO, SO POST SYNCHRONOUSLY (SAVE DDB)
	MOV	R0,R4		;COPY JOB NUMBER
	CALLX	IOFIN4,R5,JS.MU	;AND POST COMPLETION TO THE USER
	POP	R4		;GET R4 BACK
	BITB	#R.ERR,TSQSTS(R3) ;;ERR'D TSQ?
	BEQ	13$		;;NOPE, SO CONTINUE
	CALL	UNLCK		;;YES, SO UNLOCK UNIT
13$:	MOV	JOBTBL(R0),R2	;GET THE USER'S JDB POINTER		;008
	MOVB	TSQCEV(R3),JDIOST(R2) ;;POST THE ERROR BACK....
	MOV	TSQASY(R3),R2	;;GET THE USER'S XRB
	MOV	TSQRET(R3),XRBC(R2) ;;AND COPY THE RETURNED PARAMETER
	TSTB	TSQCMD(R3)	;;REWIND-OFFLINE?
	BEQ	70$		;;YEP, SO DON'T UNLOCK IT.		;009
.ASSUME	RWO.MT EQ 0
	CMPB	TSQCMD(R3),#WRT.MT ;;NO, IS IT A READ OR A WRITE?
	BHI	70$		;;NOPE, SO ITS NOT LOCKED ANYWAY	;009
	BR	65$		;;CONTINUE...				;009
	
;+
; MTU COMPLETION
;-

30$:	BITB	#R.ERR,TSQSTS(R3) ;ERR'D TSQ?
	BEQ	40$		;NOPE
	BITB	#R.ECK,TSQSTS(R3) ;YES, BUT IS THIS "ERROR CHECK" TSQ?
	BNE	40$		;YES, SO DON'T UNLOCK UNIT
	CALL	UNLCK		;OK, UNLOCK UNIT
40$:	MOV	MTFQB(R4),R4	;GET THE FIRQB POINTER FOR RESPONSE	
	MOV	#FIPSYS,(SP)	;WRITE FIPSYS OVER RTI3 RETURN
45$:	RETURN			;AND RETURN VIA FIPSYS...		;009

;+
; ASYNCHRONOUS POSTING -- SET UP AND USE ASYDNE
;-

60$:	PUSH	R4		;SAVE THE DDB POINTER, IN CASE THERE'S MORE
	MOV	TSQASY(R3),R4	;AND A POINTER TO THE WORK BLOCK
	MOVB	TSQCEV(R3),XRBUSE(R4) ;MOV ASYNCH ERROR CODE INTO THE LOW BYTE
	MOV	TSQRET(R3),XRBC(R4)   ;AND GIVE HIM THE RETURNED PARAMETER
	CALL	ASYDNE		;VIA ASYDNE			
	POP	R4		;RESTORE THE DDB POINTER
65$:	DECB	MURWP(R4)	;ANY PENDING READ/WRITE?		;009
	BNE	70$		;SOMETHING PENDING, DON'T UNLOCK YET
	CALLX	UNLOCK		;Nothing left, so undo the MU lock bit.	;012
70$:	CALL	RETBUF		;DUMP THE SMALL BUFFER BACK TO FREE LIST
	RETURN			;RETURN VIA RTI3...

.WEAK	ASYDNE,FIPSYS		; MONITOR ONLY, INIT DON'T NEED THEN

GLOBAL	<JOBTBL,EOF>

.SBTTL	UNLCK - UNLOCK UNIT "ERROR LOCKED" STATE
;+
; UNLCK - IF WE ARE CALLED, THIS UNIT HAS BEEN IN AN ERROR LOCKED
;	  STATE.  FOR SYNCHRONOUS AND MTU DONE PROCESSING WE HAVE
;	  ALREADY DECIDED THAT THE ERROR CONDITION WHICH HAD LOCKED
;	  US IS CLR, SO THE UNIT "ERROR LOCKED" STATE IS CLR'D.
;
;	  NOTE: ASYNCH "ERROR LOCKED" STATES WILL BE CLR'D THROUGH THE
;		ECA .SPEC.  NOTHING SPECIAL IS DONE WITH THE LOCK BIT
;		FOR ASYNCH DONE PROCESSING.
;
;	R3 -> TSQ
;	R4 -> DDB
;
;  CALL UNLCK
;-

UNLCK:	MAP	PUSH,APR=6,DATA	;SAVE CURRENT MAPPING
	PUSH	<R3>		;SAVE TSQ POINTER
	MOV	MUCMT(R4),R3	;GET CMT OFFSET FOR THIS DEVICE
	ADD	#CMT,R3		;UP TO CMT PROPER
	MAP	CM.AP6(R3),APR=6,DATA ;MAP TO THIS UNITS UCB
	MOV	MUUCB(R4),R3	;PICK UP UCB POINTER
	BIC	#US.LCK,U.STAT(R3) ;CLR "ERROR LOCKED" CONDITION FOR THIS UNIT
	POP	<R3>		;RESTORE TSQ POINTER
	MAP	POP,APR=6,DATA	;RESTORE MAPPING
	RETURN

.SBTTL	RETBUF - GET RID OF SMALL BUFFER POINTED AT BY R3
;+
;
;	R3 -> TSQ SMALL BUFFER TO RETURN
;  CALL RETBUF
; 	RETURN THE TSQ SMALL BUFFER (POINTED TO BY R3)
; 	WITHOUT MUNGING ANY REGISTERS
;
;-

RETBUF:	PUSH	<R4>		;NO, SO DUMP IT
	MOV	R3,R4		;BY MOVING IT INTO R4, AND...
	BINIT	20$		;INIT, CAN'T RETSML 'CUZ MAYBE NO VECTOR ;009
	BUFFER	RETSML		;...NO INIT, RETURN THE TSQ SMALL BUFFER
10$:	POP	<R4>		;STRAIGHTEN OUT THE STACK
	RETURN			;AND RETURN

;+
; WE STAND ON OUR HEADS HERE BECAUSE INIT SUCCESSFULLY EMULATES
; GETSML AND RETSML THRU I/O TRAPS UNLESS READING THE BOOTSTRAP IN OVER
; THE VECTORS.  SO, WE SET UP THE STACK TO PERFORM A RETTSQ JUST AS
; THOUGH IT WERE COMING THRU THE TRAP -- IN FACT, IT COMES BACK VIA THE TRAP.
;-

20$:	MOV	@#PS,-(SP)	;SET UP FOR THE RTT WE'LL BE RETURNING THRU
	MOV	#10$,-(SP)	;SET UP TO RETURN AT 10$ ABOVE
	CALLX	RETTSQ,R0	;CALL INTO THE ROOT, SETTING UP R0 FOR RETURN

.WEAK	RETTSQ

GLOBAL	<IE>


;+
;	VERDEN - Verifies/returns legal densities.
;	(Idea by VAM, stolen by me)
;	(Re-written by me-II to follow format menu rules)
;
;	This routine accepts a density to verify in R5, and returns a verified
;	density in R5 according to the following rules;
;
;	Bit 15 = 0
;		Returns the lowest legal density that is not less than the
;		value passed in bits 0-14.
;	Bit 15 = 1
;		Test the density in bits 0-14 to see if it's legal for the
;		drive.  If so, the C-bit is cleared and the value in bits
;		0-14 is returned.  If not, the C-bit is set, and the value
;		returned is the same as when bit 15 is zero.
;
;	CALL:
;		R5 = Density to verify.  See above description.
;		R3 = UCB POINTER
;
;		CALL	VERDEN
;
;	RETURN:
;		C-bit Clr: No error.
;		C-bit Set: Error.
;
;		R2 = Format flag for set unit char
;		R5 = 'Nearest' legal density.
;-

VERDEN:	PUSH	<R0,R1>		;Save a couple of registers		;014
	CLR	-(SP)		;Assume no errors			;014
	MOV	U.FMEN(R3),-(SP) ;Get tape format code			;014
	MOV	#DENTBL,R0	;Get pointer to density table		;014
	MOVB	1(SP),R1	;Get drive type				;014
	BEQ	20$		;Zero = old density type		;014
10$:	ADD	#<8.*2>,R0	;Advance pointer to next density type	;014
	ASR	R1		;Drop low bit into carry		;014
	BCC	10$		;Keep searching 'til it drops		;014
20$:	MOV	R0,R1		;Copy pointer to beginning of table	;014
	ADD	#<8.*2>,R1	;Make it a pointer to end of table	;014
	TST	R5		;Want specifics?			;014
	BMI	60$		;Yes					;014
	CMP	R5,#32767.	;Want highest?				;014
	BEQ	90$		;Yes					;014
30$:	MOV	#1,R2		;Start with lowest bit value		;014
40$:	TST	(R0)		;This value used?			;014
	BEQ	50$		;No.  Skip it				;014
	CMP	R5,(R0)		;Was it the value we wanted?		;014
	BHI	50$		;No, check next value			;014
	BITB	R2,(SP)		;Maybe.  Does this unit support it?	;014
	BNE	110$		;Yes					;014
50$:	TST	(R0)+		;Advance table pointer			;014
	ASLB	R2		;Update menu bit			;014
	BCC	40$		;Keep looking for a match		;014
	BR	90$		;Fell off the edge, return highest	;015

60$:	BIC	#100000,R5	;Get rid of 'test for legality' flag	;014
	CMP	R5,#1.		;Want lowest?				;014
	BEQ	30$		;Yes					;014
	CMP	R5,#32767.	;Want highest?				;014
	BEQ	90$		;Yes					;014
	MOV	#1,R2		;Start with lowest bit value		;014
70$:	TST	(R0)		;This value used?			;014
	BEQ	80$		;Nope.  Advance and check next value	;014
	CMP	R5,(R0)		;This the value we want?		;014
	BNE	80$		;Nope.  Try next			;014
	BITB	R2,(SP)		;Maybe, does unit support it?		;014
	BNE	110$		;Yes.					;014
80$:	TST	(R0)+		;Update table pointer			;014
	ASLB	R2		;Update menu bit			;014
	BCC	70$		;Keep looking for a match		;014
	DEC	2(SP)		;Signal an error			;014
				;Now return highest value...		;014
90$:	MOV	#200,R2		;Start with highest bit value		;014
	MOV	R1,R0		;Get pointer to word past table		;014
100$:	TST	-(R0)		;Bump pointer				;014
	BITB	R2,(SP)		;Does drive support this value?		;014
	BNE	110$		;Yes					;014
	ASR	R2		;Update menu bit			;014
	BCC	100$		;Keep looking for a match		;014
				;Fell off the edge, return garbage	;014
110$:	MOV	(R0),R5		;Return density in R5			;014
	BIC	#TF.MSK,(SP)	;Isolate tape format code		;014
	BIS	(SP)+,R2	;Return tape format code in R2		;014
	ASL	(SP)+		;Set carry for exit status		;014
	POP	<R1,R0>		;Restore registers			;014
	RETURN			;And exit				;014

;+
; DENTBL - Translation table for RSTS to controller internal format
;
;	This table represents all possible densities of TMSCP
;	controllers.  It is organized by format code as a
;	series of 8 element lists.  Each element in the list
;	corresponds with a bit	in the format bit-flags.
;
;	The high byte of the format menu determine which
;	set of 8 elements to look at, and the low byte
;	has each bit assigned to a specific entry, from
;	least significant to most significant bit.
;-
DENTBL:	.WORD	800.,1600.,6250.,6667.,0,0,0,0	;Old format tape drives
	.WORD	800.,1600.,6250.,0,0,0,0,0	;9-Track format tape drives
	.WORD	6667.,10000.,0,0,0,0,0,0	;TK50 compatible cartridges
	.WORD	0,0,0,0,0,0,0,0			;RV80 compatible cartridges
	.WORD	0,0,0,0,0,0,0,0			;Not yet implemented
	.WORD	0,0,0,0,0,0,0,0			;Not yet implemented
	.WORD	0,0,0,0,0,0,0,0			;Not yet implemented
	.WORD	0,0,0,0,0,0,0,0			;Not yet implemented
	.WORD	0,0,0,0,0,0,0,0			;Not yet implemented
	
;+
; DEN800 - Check density format flag for 800 BPI drive
;
; Input:  R2 = format flag word
;
;	  C returned clear if format indicates 800 BPI, else set
;-
DEN800:	SEC			;Assume it's not 800 BPI (Best case)	;014
	BIT	#<^C<TC.9TR>*TF.COD>,R2	;NOT <Old OR 9-track> format?	;014
.ASSUME TC.OLD	EQ 0
	BNE	10$		;Yes, so leave it at 1600		;014
	BIT	#TF.800,R2	;Really 800?				;014
	BEQ	10$		;Nope, other density or cartridge mode	;014
	CLC			;Son of a gun, an 800 BPI TMSCP device	;014
10$:	RETURN			;Back to caller				;014

;+
; GETDEN - Return density of current drive
;
; Input:  R3 = UCB pointer
;
; Output: R2 = Current density of drive
;-
GETDEN:	MOV	R0,-(SP)	;Save R0				;015
	MOV	#DENTBL-2,R0	;Set up to get density table pointer	;015
	MOVB	U.FORM+1(R3),R2	;Get format type			;015
	BEQ	20$		;Old format type, pointer set up	;015
.ASSUME	TC.OLD EQ 0
10$:	ADD	#<8.*2>,R0	;Advance pointer to next format type	;015
	ASR	R2		;Drop low bit into carry		;015
	BCC	10$		;Keep searching 'til it drops		;015
20$:	MOVB	U.FORM(R3),R2	;Get low byte of format flag		;015
	BEQ	40$		;Sanity check, this should be non-zero	;015
30$:	TST	(R0)+		;Advance to next (or first) entry	;015
	ASR	R2		;Drop low bit into carry		;015
	BCC	30$		;Keep searching 'til it drops		;015
40$:	MOV	(R0),R2		;Return current density			;015
	MOV	(SP)+,R0	;Restore R0				;015
	RETURN			;All done				;015

.SBTTL	QUEMTD	- QUEUE THE TSQ FOR MAGTAPE DONE SERVICE
;+
; QUEMTD - QUEUE THIS REQUEST TO THE DONE QUEUE AND HAVE 
;	   DONE SERVICE PICK IT UP LATER.
;
; INPUT:	R4 -> TSQ
;
; OUTPUT:	ALL REGISTERS PRESERVED.
;-
;-

	TMPORG	BBRDSP,10		;Set up dispatch point		;012
	.WORD	$QUMTD			;for mapped indirect call.	;012
	UNORG								;012

$QUMTD:									;012
QUEMTD:	MOV	R0,-(SP)		;SAVE R0 
	MOV	#CMT+CM.DNE,R0		;GET OUR DONE Q-ROOT
	CALMCP	QUETSQ			;Queue it to the done queue.	;012
	MOV	(SP)+,R0		;AND RESTORE R0
	L3QSET	QMUDNE			;HIT DONE SERVICE WHEN RSTS ALLOWS US
	RETURN				;AND BACK TO WHEREVER...

	.END ;or is it?
