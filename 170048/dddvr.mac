TITLE	DDDVR,<DECTAPE II DRIVER>,0A,10-MAY-91,SJK/AJK

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR DDDVR
;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;
;  001  AJK  18-JUN-81  CORRECTED PROBLEMS WITH ERROR RECOVERY/RETRY
;			
;-

	DEFORG	DDDVR

	DEFORG	DDDCTL

	DEFORG	DDDINT

	INCLUDE	ERLDVR

	ORG	DDDVR

.SBTTL	DECTAPE II DRIVER DEFINITIONS

; DEFINE 'DDSTS' VALUE FOR DECTAPE II

STS.DD	==	0/400
		;NO SPECIAL FLAGS

; DEFINE FLAGS FOR DECTAPE II

FLG.DD	==	FLGRND!DDNFS!DT2HND
		;RANDOM ACCESS
		;NON-FILE STRUCTURED
		;DECTAPE II

; DEFINE WIDTH

SIZ.DD	==	5*14.+1
		;DEFAULT FOR "NO WIDTH"

; DEFINE DEFAULT BUFFER SIZE

BUF.DD	==	512.
		;DEFAULT TO 512 BYTE BUFFER (BLOCK MODE)

; OP CODES

.DSECT

DD.NOP:	.BLKB		; NO OPERATION, RETURN END PACKET
DD.INI:	.BLKB		; INITIALISE
DD.RED:	.BLKB		; READ REQUEST
DD.WRT:	.BLKB		; WRITE REQUEST
DD.CMP:	.BLKB		; NOP (COMPARE)
DD.POS:	.BLKB		; POSITION TAPE
DD.ABT:	.BLKB		; ABORT OPERATION
DD.DAG:	.BLKB		; RUN INTERNAL DIAGNOSTICS
DD.GST:	.BLKB		; NOP (GET STATUS)
DD.SST:	.BLKB		; NOP (SET STATUS)
DD.GCH:	.BLKB		; GET CHARACTERISTICS
DD.SCH:	.BLKB		; NOP (SET CHARACTERISTICS)

.EQUATE	DD.END,	100	; END PACKET OP (SENT BY TU58)

; FLAG BYTES FOR TU58 (RSP) PROTOCOL

.RADIX	2

DF.DATA	= 	00001	; DATA PACKET
DF.CMND	=	00010	; COMMAND PACKET
DF.INIT	=	00100	; INIT (SINGLE BYTE) PACKET
DF.CONT	=	10000	; CONTINUE (SINGLE BYTE) PACKET
DF.XOFF	=	10011	; XOFF (SINGLE BYTE) PACKET

.RADIX	8

; COMMAND PACKET FORMAT

.DSECT

CP.FLG:	.BLKB		; FLAG
CP.MBC:	.BLKB		; MESSAGE BYTE COUNT (ALWAYS 10)
CP.OPC:	.BLKB		; OP CODE
CP.MOD:	.BLKB		; MODIFIER
CP.UNT:	.BLKB		; UNIT NUMBER (0 OR 1)
CP.SWT:	.BLKB		; SWITCHES (NOT USED)
CP.SEQ:	.BLKW		; SEQUENCE NUMBER (ALWAYS 0)
CP.CNT:	.BLKW		; DATA BYTE COUNT TO XFER FOR READ OR WRITE
CP.BLK:	.BLKW		; BLOCK NUMBER FOR COMMANDS REQUIRING TAPE POSITIONING
CP.CHK:	.BLKW		; MESSAGE CHECKSUM
CP.SIZ:			; LENGTH OF A MESSAGE PACKET

; DATA PACKET FORMAT

.DSECT

DP.FLG:	.BLKB		; FLAG
DP.DBC:	.BLKB		; DATA BYTE COUNT (1 TO 128)

; DEFINE CSR LAYOUT FOR TU58 ON DL11E INTERFACE

.DSECT

RCSR:	.BLKW		; RECEIVER CSR
RBUF:	.BLKW		; RECEIVER BUFFER REGISTER
XCSR:	.BLKW		; TRANSMITTER CSR
XBUF:	.BLKW		; TRANSMITTER BUFFER REGISTER

; RECEIVER STATUS REGISTER (RCSR) FOR DL11E

.BSECT

RC.RE:	.BLKB	.	; READER ENABLE
RC.DTR:	.BLKB	.	; SET TO ASSERT DTR
RC.RQS:	.BLKB	.	; REQUEST TO SEND
	.BLKB	.	; RESERVED
	.BLKB	.	; RESERVED
RC.DIE:	.BLKB	.	; DATASET INTERRUPT ENABLE
RC.RIE:	.BLKB	.	; RECEIVER INTERRUPT ENABLE
RC.RD:	.BLKB	.	; RECEIVER DONE
	.BLKB	.	; RESERVED
	.BLKB	.	; RESERVED
RC.SRD:	.BLKB	.	; SECONDARY RECEIVED DATA
RC.RA:	.BLKB	.	; RECEIVER ACTIVE
RC.CD:	.BLKB	.	; CARRIER DETECTED
RC.CTS:	.BLKB	.	; CLEAR TO SEND
RC.RI:	.BLKB	.	; RING INDICATOR
RC.DSC:	.BLKB	.	; DATASET STATUS CHANGE

; RECEIVER DATA BUFFER REGISTER (RBUF) FOR DL11E

.DSECT	377

RB.DAT:	.BLKB		; RECEIVED DATA
	.BLKB	.	; RESERVED
	.BLKB	.	; RESERVED
	.BLKB	.	; RESERVED
	.BLKB	.	; RESERVED
RB.PRE:	.BLKB	.	; RECEIVED DATA PARITY ERROR
RB.FE:	.BLKB	.	; FRAMING ERROR
RB.OVR:	.BLKB	.	; DATA OVERRUN
RB.ERR:	.BLKB	.	; ERROR CONDITION

; TRANSMITTER STATUS REGISTER (XCSR) FOR DL11E

.BSECT

XC.BRK:	.BLKB	.	; XMIT BREAK
	.BLKB	.	; UNUSED
	.BLKB	.	; MAINTENANCE MODE
	.BLKB	.	; UNUSED
	.BLKB	.	; UNUSED
	.BLKB	.	; UNUSED
XC.TIE:	.BLKB	.	; XMITTER INTERRUPT ENABLE
XC.TRE:	.BLKB	.	; XMITTER READY
	.BLKB	.	; UNUSED
	.BLKB	.	; UNUSED
	.BLKB	.	; UNUSED
	.BLKB	.	; UNUSED
	.BLKB	.	; UNUSED
	.BLKB	.	; UNUSED
	.BLKB	.	; UNUSED
	.BLKB	.	; UNUSED

; TRANSMITTER DATA BUFFER REGISTER (XBUF?) FOR DL11E

.DSECT	377

XB.DAT:	.BLKB		; DATA TO XMIT
	.BLKB	.	; UNUSED
	.BLKB	.	; UNUSED
	.BLKB	.	; UNUSED
	.BLKB	.	; UNUSED
	.BLKB	.	; UNUSED
	.BLKB	.	; UNUSED
	.BLKB	.	; UNUSED
	.BLKB	.	; UNUSED

; DEFINE THE OFFSETS IN THE 160. BYTE BUFFER OBTAINED AT OPEN

.DSECT

BF.SIZ:	.BLKW		; SIZE OF THE BUFFER IN BYTES (160.)
BF.OFF:	.BLKW		; OFFSET TO DATA
BF.LNK:	.BLKW		; LINK WORD
BF.CNT:	.BLKW		; COUNT OF REAL DATA BYTES IN BUFFER
BF.TCT:	.BLKW		; TOTAL BYTE COUNT FOR THIS OPERATION
BF.ULC:	.BLKW		; USER BUFFER LOCATION
BF.XRB:	.BLKW		; POINTER TO USER'S XRB
BF.DAT:			; DATA PORTION OF THE BUFFER
	.BLKB		; FLAG BYTE
	.BLKB		; MESSAGE BYTE COUNT
	.BLKB	132.	; UP TO 128. BYTES OF DATA + PROTOCOL AND CHECKSUM
	.BLKB	6.	; 6 BYTES OF EXTRA BUFFER SPACE AFTER XOFF
.ASSUME	<.-160.> LE 0


; DEFINE FLAG BITS IN D2STUS (STATUS WORD IN DDB)

.BSECT

FL.INP:	.BLKB	.	; CURRENTLY INPUTTING
FL.OUT:	.BLKB	.	; CURRENTLY OUTPUTTING
FL.TMO:	.BLKB	.	; TIME OUT OCCURRED
FL.PRO:	.BLKB	.	; PROTOCOL ERROR HAS OCCURRED
FL.CHK:	.BLKB	.	; A CHECKSUM ERROR HAS OCCURRED
FL.ERR:	.BLKB	.	; SOME OTHER ERROR HAS OCCURRED
FL.INT:	.BLKB	.	; CURRENTLY INITTING THE DEVICE
FL.XOF:	.BLKB	.	; DEVICE HAS BEEN XOFFED
	.BLKB	.	; RESERVED
	.BLKB	.	; RESERVED
	.BLKB	.	; RESERVED
	.BLKB	.	; RESERVED
	.BLKB	.	; RESERVED
	.BLKB	.	; RESERVED
	.BLKB	.	; RESERVED
FL.SVC:	.BLKB	.	; REQUEST NEEDS TO BE STARTED

FL.IO	= FL.INP!FL.OUT	; BIT COMBINATION FOR SOME I/O GOING ON
FL.FOO	= FL.ERR!FL.CHK!FL.PRO!FL.TMO ; BAD STUFF

.SBTTL	DECTAPE II DIRTY (READ/WRITE) AREA

	TMPORG	DDDCTL

CONQUE:	.WORD	0		; BASE OF THE DD CONTINUATION QUEUE

	UNORG

.SBTTL	DECTAPE II PURE (READ-ONLY) DATA

	TMPORG	DDDINT

DDDINT:	CALLX	INTSAV,R5	; INPUT INTERRUPT HANDLING
	  .WORD	1200
	  .WORD	INT$DD

	CALLX	INTSVX,R5	; OUTPUT INTERRUPT HANDLING
	  .WORD	DDDAP5
	  .WORD	ONT$DD

	UNORG

	GLOBAL	<DDDAP5>

.SBTTL	SPECIAL FUNCTION SERVICE

;+
; SPC$DD - SPECIAL FUNCTION SERVICE FOR DECTAPE II.
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB/FCB
;	R2 =  SPECIAL FUNCTION CODE
;	R3 -> XRB
;	R4 =  CALLING JOB NUMBER TIMES 2
;	R5 -> (MAPPED) XRB
;
;	...
;
;	JMP	RTI3
;
;	-OR-
;
;	ERROR	CODE
;
;-


SPC$DD::ERROR	PRVIOL		;NONE

.SBTTL	DEVICE ASSIGNMENT SERVICE

;+
; ASN$DD - DEVICE ASSIGNMENT SERVICE FOR DECTAPE II.
;
;	R0 =  JOB NUMBER OF ASSIGNER TIMES 2
;	R1 -> DDB
;
;	...
;
;	RETURN		(WITH ALL REGISTERS PRESERVED)
;-

ASN$DD::.BR	DEA$DD		;NOTHING SPECIAL

.SBTTL	DEVICE DEASSIGNMENT SERVICE

;+
; DEA$DD - DEVICE DEASSIGNMENT SERVICE FOR DECTAPE II.
;
;	R1 -> DDB
;
;	...
;
;	RETURN		(WITH ALL REGISTERS PRESERVED)
;-

DEA$DD::RETURN			;NOTHING TO DO...

.SBTTL	INPUT INTERRUPTS

;+
; INT$DD - INPUT INTERRUPTS FOR DECTAPE II.
;
;	R0 =  UNIT NUMBER TIMES 2
;	PRIORITY IS PR5
;
;	...
;
;	RETURN
;-

.ENABL	LSB

10$:	CLR	(R3)		;; CLEAR ANY POSSIBLE INTERRUPTS IN THE FUTURE
.ASSUME	RBUF	EQ	2
	RETURN			;;  AND IGNORE THIS INTERRUPT

INT$DD::ASL	R0		;; MULTIPLY THIS UNIT NUMBER TO GET BASE CSR
	MOV	CSR.DD(R0),R3	;; GET THE BASE CSR ADDRESS
	MOV	CONQUE,R1	;; GET THE DDB POINTER
	BEQ	10$		;; NONE, PUNT UNSOLICITED INTERRUPTS
	SUB	#D2QUE,R1	;; SUBTRACT QUEUE THREAD BIAS
	BIT	#FL.INP,D2STUS(R1);; ARE WE INPUTTING?
	BEQ	10$		;; NO, SO PUNT THIS INTERRUPT
	MOV	(R3)+,D2CSR(R1)	;; SAVE THE CSR
	MOV	(R3),R2		;; GET THE BUFFER REGISTER INTO R2
	MOV	R2,D2XBF(R1)	;; SAVE THE BUFFER REGISTER
	MOV	#RC.RIE,-(R3)	;; MAKE SURE WE GET NEXT INTERRUPT
	.CALLR	INCHAR		;; BUFFER THE CHARACTER

.DSABL	LSB

.SBTTL	BUFFER INCOMING CHARACTER

;+
; INCHAR - BUFFER AN INCOMING CHARACTER
;
;	CALLER SHOULD BE AT PR5
;
;	R1 -> DDB
;	R2 =  DL11 BUFFER REGISTER CONTENTS
;	R3 -> CSR @ RCSR
;
;	CALL	INCHAR
;
;	REGISTER RANDOM
;-

INCHAR:	MOVB	DDUNT(R1),R0	;; GET THE UNIT NUMBER OF THIS DRIVE
	ASL	R0		;;  TIMES 2
	MOV	#2,TIM.DD(R0)	;; SET A TIME OUT IN 2 SECONDS
	BIT	#RB.FE!RB.OVR,R2;; IS THERE SOME KIND OF ERROR?
	BEQ	10$		;; NO, JUST PROCESS THIS CHARACTER
	CLR	(R3)		;; MAKE SURE WE DON'T GET AN INTERRUPT
	CLR	TIM.DD(R0)	;;  OR A TIMEOUT
	BIS	#FL.ERR,D2STUS(R1);; SAY THERE WAS AN ERROR
	LOG$DD			;; YES, VIRGINIA, THERE IS AN ERROR
	BR	20$		;;    AND GO SCHEDULE L3 SERVICE
10$:	MOV	D2BUFR(R1),R4	;; GET A POINTER TO THE BUFFER
	MOV	BF.CNT(R4),R0	;;  AND A COUNT OF THE BYTES IN THE BUFFER
	MOV	R4,R5		;; GET THE BASE OF THE BUFFER
	ADD	R0,R5		;; ADD IN THE OFFSET FROM THE DATA PORTION
	MOVB	R2,BF.DAT(R5)	;; SET THE BYTE INTO THE BUFFER
	INC	BF.CNT(R4)	;; UPDATE THE COUNTER
	TST	R0		;; IS THIS THE FIRST BYTE?
	BEQ	40$		;; YES, THIS IS THE SPECIAL FLAG BYTE
	TSTB	D2STUS(R1)	;; ARE WE IN AN XOFF STATE?
.ASSUME	FL.XOF	EQ	200
	BMI	30$		;;  YES, JUST STORE THE CHARACTER
	SUB	#3,R0		;; -3 BYTES TO ADJUST FOR FLG, CNT, AND CHKSUM
	CMPB	R0,BF.DAT+CP.MBC(R4);; ENOUGH DATA FOR A WHOLE PACKET?
	BNE	30$		;; NO, RETURN TO CALLER
	CLR	XCSR(R3)	;; YES, XOFF THIS UNIT, CLEAR OUTPUT INTERRUPT
	MOV	#DF.XOF,XBUF(R3);; SEND XOFF TO DD UNIT
	BIS	#FL.XOF,D2STUS(R1);; PLACE THIS UNIT IN XOFF MODE
20$:	L3QSET	QDDCON		;; SET L3Q CONTINUATION
30$:	RETURN			;;  AND WE ARE DONE

40$:	MOVB	R2,R5		;; COPY THE BYTE VALUE
	CMPB	R5,#DF.INIT	;; IS IT THIS 1 BYTE MESSAGE
	BEQ	20$		;; YES, CONTINUE AT L3
	CMPB	R5,#DF.CONT	;; IS IT THIS 1 BYTE MESSAGE
	BEQ	20$		;; YES, CONTINUE AT L3
	DEC	R5		;; IS IT THIS MULTI BYTE MESSAGE
.ASSUME	DF.DATA	EQ	1
	BEQ	30$		;; YES, CONTINUE INPUTTING MESSAGE
	CMPB	R5,#DF.CMND-1	;; IS IT THIS MULTI BYTE MESSAGE
	BEQ	30$		;; YES, CONTINUE INPUTTING MESSAGE
	MOV	#FL.PRO,D2STUS(R1);; IT IS NOT A FLAG BYTE, WE ARE OUT OF SYNC
	MOVB	DDUNT(R1),R0	;; GET THE DEVICE UNIT NUMBER AGAIN
	ASL	R0		;;  TIMES TWO
	CLR	(R3)		;; DON'T LET THE DEVICE TALK ANY MORE
	CLR	TIM.DD(R0)	;;  AND CLEAR OUT ANY TIME OUT PARAMETER
	LOG$DD			;; LOG THIS AS AN ERROR
	BR	20$		;; STOP THIS AND LET L3 FIGURE IT OUT

	GLOBAL	<QDDCON,TIM.DD,LOG$DD,CSR.DD>

.SBTTL	OUTPUT INTERRUPTS

;+
; ONT$DD - OUTPUT INTERRUPTS FOR DECTAPE II.
;
;	R0 =  UNIT NUMBER TIMES 2
;	PRIORITY IS PR5
;
;	...
;
;	RETURN
;-

.ENABL	LSB

10$:	CLR	(R3)		;; DISABLE INTERRUPTING FROM THIS CONTROLLER
	RETURN			;;  AND IGNORE THIS INTERRUPT

ONT$DD::ASL	R0		;; MULTIPLY BY TWO TO GET FIRST UNIT NUMBER
	MOV	CSR.DD(R0),R3	;; GET THE CSR ADDRESS FOR THIS DEVICE
	ADD	#XCSR,R3	;; ADD IN OFFSET TO TRANSMITTER BUFFER REG
	MOV	CONQUE,R1	;; GET THE DDB POINTER
	BEQ	10$		;; NONE, PUNT UNSOLICITED INTERRUPTS
	SUB	#D2QUE,R1	;; SUBTRACT QUEUE THREAD WORD BIAS
	BIT	#FL.OUT,D2STUS(R1);; ARE WE OUTPUTTING OR INITING?
	BEQ	10$		;;  NO, IGNORE THIS INTERRUPT
	MOV	(R3),D2CSR(R1)	;; SAVE THE CSR
	MOV	2(R3),D2XBF(R1)	;; SAVE THE BUFFER REGISTER
.ASSUME	XBUF-XCSR  EQ	2
	.CALLR	OUTCHR		;; OUTPUT THE NEXT CHARACTER

.DSABL	LSB

.SBTTL	OUTPUT A CHARACTER

;+
; OUTCHR - OUTPUT A CHARACTER
;
;	CALLER SHOULD BE AT PR5
;
;	R1 -> DDB
;	R3 -> CSR @ XCSR
;
;	CHARACTER TO OUTPUT IS IN OUTPUT BUFFER
;
;	CALL	OUTCHR
;
;	REGISTERS RANDOM
;-

.ENABL	LSB

OUTCHR:	MOV	D2BUFR(R1),R4	;; GET THE POINTER TO THE BUFFER
	MOVB	@BF.OFF(R4),R5	;; GET THE CHARACTER TO PRESENT TO XBUF
	MOV	#XC.TIE,R2	;; GET THE VALUE TO PRESENT TO THE XCSR
	BIT	#FL.INT,D2STUS(R1);; ARE WE INITING?
	BEQ	10$		;; NO, NORMAL OUTPUT
	TST	-2(R3)		;; YES, CLEAR RECEIVER BUF (ON SHG'S ADVICE)
.ASSUME	RBUF	EQ	XCSR-2
	CMPB	R5,#377		;; IS THIS A BREAK CHAR
	BNE	10$		;; NO, SO NO BREAK BIT SETTING
	INC	R2		;; SET THE BREAK BIT
.ASSUME	XC.BRK	EQ	1
10$:	MOV	R2,(R3)+	;; SET THE CSR
	MOV	R5,(R3)		;; SET THE CHARACTER TO OUTPUT
	MOVB	DDUNT(R1),R0	;; GET THE UNIT NO. TIMES TWO
	ASL	R0		;;
	DEC	BF.CNT(R4)	;; DOWN COUNT ONE MORE CHARACTER
	BEQ	20$		;; YES, GO RESCHEDULE R3 SERVICE
	INC	BF.OFF(R4)	;; INCREMENT THE POINTER
	MOV	#2,TIM.DD(R0)	;; SET A TIME OUT IN 2 SECONDS
	RETURN			;;  AND GO AWAY

20$:	MOV	#FL.INP,D2STUS(R1);; ANY PACKET SENT GETS SOME BACKTALK
	;CLR	BF.CNT(R4)	;; BF.CNT MUST BE ZERO FOR INPUT (ALREADY IS)
	CLR	TIM.DD(R0)	;; LET L3Q SERVICE SET TIMEOUT PARAMETER
	CLR	-(R3)		;; DON'T LET OUTPUT RECEIVE INTERRUPT US
	SUB	#4,R3		;; POINT BACK TO THE RCSR
.ASSUME	RCSR	EQ	XCSR-4
	MOV	#RC.RIE,(R3)	;; LET INPUT INTERRUPT US
	TSTB	(R3)		;; IS THERE A CHARACTER WAITING ALREADY?
.ASSUME	RC.RD	EQ	200
	BPL	30$		;; NO EXIT THE INTERRUPT ROUTINE
	MOV	(R3)+,D2CSR(R1)	;; STORE THE INCOMING CSR VALUE
	MOV	(R3),R2		;; GET THE INCOMING CHARACTER
	MOV	#RC.RIE,-(R3)	;; MAKE SURE THE INTERRUPT IS SET (REDUNDANT)
	MOV	R2,D2XBF(R1)	;; SAVE THE BUFFER REGISTER
	CALL	INCHAR		;; GO BUFFER THE CHARACTER
30$:	L3QSET	QDDCON		;; QUE THIS DDB UP FOR SERVICE
40$:	RETURN			;;  AND RETURN

	GLOBAL	QDDCON

.SBTTL	TIMEOUTS

;+
; TMO$DD - TIME OUT ENTRY POINT FOR DECTAPE II.
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB
;	R3 -> CSR
;	PRIORITY IS PR5
;
;	...
;
;	RETURN
;-

TMO$DD::CLR	TIM.DD(R0)	;;MAKE SURE WE DON'T TIMEOUT AGAIN
	TSTB	D2STUS(R1)	;;ARE WE IN XOFF STATE?
.ASSUME	FL.XOF	EQ	200
	BMI	40$		;;YES, IGNORE TIMEOUT, WEVE BEEN WAITN' FOR IT
	BIT	#FL.IO,D2STUS(R1) ;;ARE WE WAITING FOR I/O?
	BEQ	40$		;;NO, EXTRANEOUS TIME OUT. IGNORE IT.
	BIS	#FL.TMO,D2STUS(R1) ;;SET THE TIMEOUT FLAG
	LOG$DD			;;LOG THE ERROR
	BR	30$		;;YES, RESHEDULE THE ERROR

GLOBAL	<TIM.DD>

.DSABL	LSB

.SBTTL	ERROR LOGGING

;+
; ERL$DD - ERROR LOGGING ENTRY POINT FOR DECTAPE II.
;
;	REGISTERS SAME AS AT TIME OF LOG$DD CALL
;	PRIORITY IS PR7
;
;	...
;
;	RETURN
;-

ERL$DD::MOV	R1,R4		;;;SAVE DDB POINTER HERE
	CALLX	ERLDVR,R5	;;;CALL COMMON DEVICE ERROR LOGGER
	 .BYTE	ERC$DD		;;;DECTAPE II ERROR CODE
	 .BYTE	DDS.DD		;;;SIZE OF DDB
	 .BYTE	0,0		;;;NO REGISTERS, SINCE THEY ARE IN THE DDB
	BIT	#FL.TMO,D2STUS(R4) ;;;TIMEOUT?
	BEQ	10$		;;;NO
	COMB	(R0)		;;;YES, SET A FLAG
10$:	MOV	D2BUFR(R4),(R1)	;;;FILL IN THE DDB EXTENSION (CONTROL BUFFER)
	BEQ	20$		;;;SKIP IF NO BUFFER (REALLY SCREWED UP!)
	MOV	#2*400+16.,-(R1);;;FILL IN 16. WORDS OF FIELD 2
20$:	RETURN			;;;BACK TO ERROR LOGGER

GLOBAL	<DDS.DD>

.SBTTL	OPEN SERVICE FOR DECTAPE II

;+
; OPN$DD - OPEN SERVICE FOR DECTAPE II.
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB (MUST BE PRESERVED)
;	R4 -> FIRQB (DEFAULT FQFLAG AND FQBUFL VALUE LOADED)
;	R5 -> JOB'S IOB ENTRY (MUST BE PRESERVED)
;
;	...
;
;	RETURN
;
;	-OR-
;
;	CALL	RETDEV
;	ERROR	CODE
;-

.ENABL	LSB

10$:	CALLX	RETDEV		;OTHERWISE, RETURN THE DEVICE
	ERROR	NOBUFS		;SAY NO BUFFER SPACE AVAILABLE

20$:	CALLX	RETDEV		;RETURN THE DEVICE		;001
	ERROR	INUSE		;DEVICE ALREADY OPEN AND IN USE	;001

OPN$DD::MOV	R1,-(SP)	;SAVE R1,R2
	MOV	R2,-(SP)	;
	TST	D2BUFR(R1)	;ALREADY ALLOCATED A BUFFER FROM MON POOL;001
	BNE	20$		;YES, THAT IS AN ERROR			 ;001
	MOV	#160.,R1	;SET TO GET A 160. BYTE BUFFER
	MOV	#40.,R2		;LEAVE 40 BUFFERS
	CALLX	BUFFER,R5,MONPOL;GET THE BUFFER FROM MON POOL
	MOV	(SP)+,R2	;RESTORE R2,R1
	MOV	(SP)+,R1	;
	BCS	10$		;OOPS! NO BUFFS, GIVE HIM AN ERROR
	MOV	R4,D2BUFR(R1)	;SAVE THE BUFFER ADDRESS
	CLR	D2BLOK(R1)	;START TRANSFERS AT BLOCK ZERO
	RETURN			; AND THEN RETURN

	GLOBAL	<MONPOL>

.DSABL	LSB

.SBTTL	CLOSE SERVICE FOR DECTAPE II

;+
; CLS$DD - CLOSE SERVICE FOR DECTAPE II.
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB/FCB
;	R5 -> DDB/FCB (MUST BE PRESERVED)
;	IF Z=1 THEN A REAL CLOSE CALL
;	IF Z=0 THEN A "RESET" CLOSE CALL
;
;	...
;
;	RETURN
;-

CLS$DD::CLR	D2STUS(R1)	;CLEAR THE STATUS, NOTHING GOING ON NOW
	MOV	D2BUFR(R1),R4	;GET THE ADDRESS OF THE BUFFER
	CLR	D2BUFR(R1)	;CLEAR BUFFER ADDRESS IN DDB		;001
	BUFFER	RETURN		;RETURN THE BUFFER TO THE MONITOR POOL
	RETURN

.SBTTL	USER LEVEL SERVICE

;+
; SER$DD - USER LEVEL READ/WRITE SERVICE.
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB/FCB
;	R2 =  2 (.READ)
;	      4 (.WRITE)
;	R3 -> XRB
;	R4 =  CALLING JOB NUMBER TIMES 2
;	R5 -> USER'S BUFFER (THROUGH KISAR6)
;	IF Z=1 OR C=0 THEN THIS IS THE FIRST CALL
;	IF Z=0 OR C=1 THEN THIS IS A "REDO" CALL
;
; NOTES:
;
;	1) ACCESS RIGHTS HAVE BEEN VERIFIED.
;	2) DIRECTIONAL RIGHTS HAVE BEEN VERIFIED.
;
; EXITS:
;
;	1) ALL COMPLETE WITH NO ERROR
;
;		JMP	IOEXIT
;
;	2) ALL COMPLETE WITH ERROR
;
;		SETERR	CODE
;		JMP	IOEXIT
;
;		-OR-
;
;		ERROR	CODE
;
;	3) STALL DESIRED (FOR "REDO" LATER)
;
;		JMP	IOREDO
;-

SER$DD::MOVB	R2,D2FUN(R1)	; SET THE TYPE OF REQUEST (READ/WRITE)
	CLRB	XRBLKM(R3)	; INDICATE SMALL DEVICE
	CMPB	#.READ&377,R2	; IS THIS A READ OR WRITE?
	BEQ	10$		; YES    (WRITE)
	MOV	XRBC(R3),(R3)	; SHORTEN BUFFER TO AMOUNT TO READ
.ASSUME	XRLEN	EQ	0
10$:	CLR	XRBC(R3)	; CLEAR BYTE COUNT, TOTAL WILL BE POSTED

	MOV	D2BUFR(R1),R4	; GET THE ADDRESS OF THE BUFFER
	MOV	R3,BF.XRB(R4)	; SAVE THE XRB ADDRESS
	MOV	XRLEN(R3),BF.TCT(R4); SAVE THE INITIAL DATA LENGTH
	MOV	XRLOC(R3),BF.ULC(R4); SAVE THE INITIAL BUFFER POINTER
	BIC	#DDMOD,(R1)	; MAKE SURE MODIFIER FLAG IS OFF
	MOV	XRBLK(R3),R4	; GET THE BLOCK NUMBER
	BEQ	20$		; NO RECORD NUMBER HERE, USE DEFAULT
	MOV	R4,D2BLOK(R1)	; SAVE THE RECORD NUMBER TO USE
20$:	CLR	D2QRET(R1)	; CLEAR RETURN ADDRESS FOR L3Q SERVICE
.ASSUME	CONDSP	EQ	DDIOST
	MOV	R1,R4		; COPY THE DDB POINTER
	ADD	#D2QUE,R4	; BIAS IT TO THE THREAD WORD
	CALLX	QUEUER,R5,CONQUE; QUEUE IT UP FOR SERVICE IN THE CON QUEUE
	BCC	30$		; SKIP THE L3Q SET IF NOT FIRST IN QUEUE
	L3QSET	QDDCON		; SET CONTINUATION PROCESSING
30$:	JMPX	DMPJOB		;  AND DUMP THE CURRENT JOB

.SBTTL	LEVEL 3 QUEUED CONTINUE ENTRY POINT

.ENABL	LSB

10$:	RETURN			;RETURN

CON$DD::MOV	#RTI3,-(SP)	;RETURN TO RTI3 WHEN DONE
	CALL	SETDD3		;SET UP THE REGISTERS FOR THIS REQUEST
	BEQ	10$		; AND EXIT IF NOTHING IN QUEUE
	ADD	D2QRET(R1),PC	;DISPATCH TO CONTINUATION CODE
CONDSP:				;DISPATCH BIAS
DDIOST:				;DDIOST ROUTINE MUST BE NEXT

	GLOBAL	RTI3

.DSABL	LSB

.SBTTL	START A DECTAPE II I/O REQUEST

.ENABL	LSB

DDIOST:	CLR	D2STUS(R1)	;  AND CLEAR ANY STATUS
	MOVB	#5.,D2RTRY(R1)	; SET THE INITIAL RETRY COUNTER
	CMPB	D2FUN(R1),#.READ&377 ; GET THE REQUESTED OPERATION
	BNE	100$		; DO WRITE REQUEST PROCESSING

5$:	CALL	INITDD		; BEFORE ANYTHING, RESET TO KNOWN STATE	 ;001
	BCS	30$		; IF AN ERROR OCCURED LET ROUTINE GET IT
	CALL	GETMES,R5	; GET A CONTINUE
	 .WORD	4.		;  WITH 4. SECOND TIMEOUT, MAX SHOULD BE 1.
	 BR	30$		;  DATA PACKET PROCESSING [ERROR]
	 BR	30$		;  END PACKET PROCESSING [ERROR]
	 BR	10$		;  CONTINUE PROCESSING
	 BR	30$		;  ERROR PROCESSING

10$:	CALL	SETCMD,R5,DD.RED; SET UP THE COMMAND IN THE BUFFER AND OUTPUT
	BCS	30$		;  AN ERROR OCCURRED
20$:	CALL	GETMES,R5	; GET SOME DATA
	 .WORD	45.		;  WITH 45. SECOND TIMEOUT, MAX SHOULD BE 30.
	 BR	50$		;  DATA PACKET PROCESSING
 	 BR	30$		;  END PACKET PROCESSING		 ;001
	 BR	30$		;  CONTINUE PROCESSING [ERROR]
	 .BR	30$		;  ERROR PROCESSING

30$:	DECB	D2RTRY(R1)	; DO WE WANT TO RETRY THE OPERATION
	BNE	40$		; NO, GIVE THE USER AN ERROR		 ;001
	JMP	220$		; REPORT DEVICE HUNG ERROR		 ;001

40$:	ADD	#XRLOC+2,R2	; OFFSET TO THE USER'S BUFFER POINTER + 2
	MOV	BF.ULC(R4),-(R2); RESET THE BUFFER POINTER
	CLR	-(R2)		; CLEAR BYTE COUNT, STARTING OVER
	MOV	BF.TCT(R4),-(R2); RESET THE INITIAL DATA LENGTH
	BR	5$		; GO RESTART THE WHOLE MESS		 ;001

50$:	CALL	DDJRES		; MAKE THE JOB RESIDENT, R5 -> USER BUFFER
	MOV	R4,R3		; SAVE THE POINTER TO THE BUFFER
	ADD	#BF.DAT+DP.DBC,R4; GET ADDRESS OF START OF DATA
	CLR	R2		; CLEAR R2
	BISB	(R4)+,R2	; GET THE BYTE COUNT FOR MESSAGE, NO SGN EXTND
	MOV	R2,R0		; SAVE THAT NUMBER
60$:	MOVB	(R4)+,(R5)+	; MOVE BYTES INTO USER AREA
	SOB	R2,60$		; UNTIL ALL BYTES ARE MOVED
	SPLC	5		;; LOCK OUT INTERRUPT FOR BUFFER SHUFFLE
	MOV	BF.CNT(R3),R1	;; R1 = TOTAL BYTES RECEIVED
	SUB	R0,R1		;; SUBTRACT THE AMOUNT OF DATA
	SUB	#4,R1		;;  AND NUMBER OF BYTES IN PROTOCOL OVERHEAD
	MOV	R1,BF.CNT(R3)	;; UPDATE THE COUNT IN THE BUFFER
	BLE	80$		;; NO BYTES LEFT TO SHUFFLE, BACK TO PR3
	ADD	#BF.DAT,R3	;; POINT R3 AT DATA
	CMPB	(R4)+,(R4)+	;; BUMP R4 PAST THE CHECKSUM
70$:	MOVB	(R4)+,(R3)+	;; SHIFT THE BYTES DOWN IN THE BUFFER
	SOB	R1,70$		;; LOOP UNTIL DONE
80$:	SPLC	3		;; BACK TO PRIORITY THREE

	CALL	SETDD3		; STRAIGHTEN OUT THE REGISTERS
	ADD	#XRLOC+2,R2	; OFFSET XRB POINTER TO XRLOC+2
.ASSUME	XRLOC+2	EQ	6
	ADD	R0,-(R2)	; BUMP THE BUFFER POINTER
	ADD	R0,-(R2)	; ADD IT INTO TOTAL BYTE COUNT READ
	SUB	R0,-(R2)	; SUBTRACT THE AMOUNT OF USER BUFFER LEFT
	BNE	20$		; IF NOT DONE, GET MORE
	CALL	GETMES,R5	; GET AN END PACKET
	 .WORD	4.		;  WITH 4. SECOND TIMEOUT, MAX SHOULD BE 1
	 BR	30$		;  DATA PACKET PROCESSING [ERROR]
90$:	 BR	D2DONE		;  END PKT PROCESSING (LABEL KLUDGE FOR ABOVE)
	 BR	30$		;  CONTINUE PROCESSING [ERROR]
	 BR	30$		;  ERROR PROCESSING

100$:	CALL	INITDD		; BEFORE ANYTHING, RESET TO KNOWN STATE
	BCS	130$		; IF AN ERROR OCCURED LET ROUTINE GET IT
	CALL	GETMES,R5	; GET A CONTINUE
	 .WORD	4.		;  WITH 4. SECOND TIMEOUT, MAX SHOULD BE 1.
	 BR	130$		;  DATA PACKET PROCESSING [ERROR]
	 BR	130$		;  END PACKET PROCESSING [ERROR]
	 BR	110$		;  CONTINUE PROCESSING
	 BR	130$		;  ERROR PROCESSING

110$:	CALL	SETCMD,R5,DD.WRT; SET UP FOR A WRITE REQUEST AND OUTPUT MESS.
	BCS	130$		; SOME ERROR OCCURRED
120$:	CALL	GETMES,R5	; WAIT FOR A CONTINUE
	 .WORD	45.		;  WITH 45. SECOND TIMEOUT, MAX SHOULD BE 30.
	 BR	130$		;  DATA PACKET PROCESSING [ERROR]
	 BR	125$		;  END PACKET PROCESSING		 ;001
	 BR	150$		;  CONTINUE PROCESSING
	 BR	130$		;  ERROR PROCESSING			 ;001

125$:	TST	(R2)		; WRITE COMPLETE (I.E.-CHAR COUNT0) ?	 ;001
	BEQ	D2DONE		; YES, PERFORM DONE			 ;001


130$:	DECB	D2RTRY(R1)	; DO WE WANT TO RETRY THE OPERATION
	BEQ	220$		; NO, GIVE THE USER AN ERROR

140$:	ADD	#XRLOC+2,R2	; ADD IN OFFSET TO USER'S BUFFER POINTER + 2
	MOV	BF.ULC(R4),-(R2); RESET THE INITIAL BUFFER POINTER
	CLR	-(R2)		; NO BYTE XFERED YET
	MOV	BF.TCT(R4),-(R2); RESET THE INITIAL DATA LENGTH
	BR	100$		; GO RESTART THE WHOLE MESS		 ;001

150$:	TST	(R2)		; ANY BYTES TO WRITE?
	BNE	160$		; YES, EVERYTHING IS FINE
	MOV	#FL.PRO,D2STUS(R1) ; NO, CONTINUE IS A PROTOCOL ERROR
	LOG$DD			; LOG THE ERROR
	BR	130$		;  AND DO ERROR HANDLING

160$:	CALL	DDJRES		; MAKE THE JOB RESIDENT
				; R0 = NUMBER OF BYTES TO WRITE
				; R5 ->USER BUFFER MAPPED
	ADD	#XRLOC+2,R2	; OFFSET TO USER'S BUFFER POINTER + 2
	ADD	R0,-(R2)	; BUMP THE BUFFER POINTER
	ADD	R0,-(R2)	; ADD IN TOTAL AMOUNT WRITTEN
	SUB	R0,-(R2)	; SUBTRACT AMOUNT FROM TOTAL LEFT IN BUFFER
.ASSUME	XRLEN	EQ	0
	ADD	#BF.DAT,R4	; OFFSET THE BUFFER POINTER TO DATA
	MOVB	#DF.DAT,(R4)+	; SET THE DATA PACKET FLAG
	CLR	R3		; CLEAR THE CHECK SUM
	BISB	#DF.DAT,R3	; SET LOW HALF OF CHECKSUM
	MOVB	R0,(R4)+	; SET THE MESSAGE BYTE COUNT
	SWAB	R3		; SWAP CHECKSUM ACCUMULATOR
	BISB	R0,R3		; SET IN THE TOP HALF OF THE CHECK SUM
	SWAB	R3		; SWAP THE CHECKSUM ACCUMULATOR BACK TO NORMAL
170$:	CLR	R2		; CLEAR A TEMPORARY ACC FOR INTERMEDIATE VALUE
	BISB	(R5),R2		; SET THIS BYTE IN THE CHECKSUM
	MOVB	(R5)+,(R4)+	;  AND SET IT IN THE BUFFER
	DEC	R0		; DECREMENT AMOUNT TO DO
	BEQ	180$		; IF THAT IS THE END, THEN DO IT
	SWAB	R2		; SWAP THE TEMP ACC
	BISB	(R5),R2		; SET THIS BYTE INTO THE TEMP ACC
	MOVB	(R5)+,(R4)+	; SET THE BYTE INTO THE BUFFER ALSO
	SWAB	R2		; SWAP THE TEMP ACC BACK
	DEC	R0		; DECREMENT THE AMOUNT TO DO
180$:	ADD	R2,R3		; ADD IN FINAL AMOUNT TO THE CHECKSUM
	ADC	R3		; ADD IN ANY CARRY
	TST	R0		; MORE DATA LEFT?
	BNE	170$		; YES, GO THROUGH THE LOOP AGAIN
	MOVB	R3,(R4)+	; SET IN LOW BYTE OF CHECKSUM
	SWAB	R3		; SWAP THE CHECKSUM
	MOVB	R3,(R4)+	; AND SET IN THE HIGH BYTE OF THE CHECKSUM
	MOV	R4,-(SP)	; SAVE THE CURRENT BUFFER POINTER
	CALL	SETDD3		; SET UP THE REGISTERS IN PROPER ORDER
	MOV	(SP)+,R4	; RESTORE BUFFER POINTER FOR MESSAGE OUTPUT
	CLR	D2STUS(R1)	; MAKE SURE STATUS IS SET PROPERLY
	CALL	OUTMES		; OUTPUT THE MESSAGE
	BCS	130$		; SOME PROBLEM OCCURRED
	BR	120$		; GO GET AN ACK OR AN END

.SBTTL	END OF USER REQUEST PROCESSING

D2DONE:	MOV	XRBC(R2),R5	; GET THE TOTAL AMOUNT TRANSFERRED
	ADD	#777,R5		; ADD IN TO GET CEIL(COUNT/512)
	BIC	#777,R5		; MAKE THE NUMBER AN EVEN BLOCK
	SWAB	R5		; SWAP BYTES TO FORMULATE BLOCK COUNT WRITTEN
	ASR	R5		;  AND DIVIDE BY TWO FOR REAL NUMBER
	ADD	R5,D2BLOK(R1)	; ADD IN THE NUMBER OF BLOCKS TO GET NEXT BL#
	MOVB	BF.DAT+CP.MOD(R4),R0 ; DID A TU58 ERROR OCCUR
	BEQ	200$		; NO
	MOV	#ERRTBL,R5	; GET A POINTER TO THE ERROR TABLE
190$:	CMPB	(R5)+,R0	; IS THIS THE ERROR?
	BNE	210$		; NO
	MOVB	(R5)+,R0	; YES, GIVE THE CORRESPONDING RSTS ERROR
200$:	BR	230$		; AND FINISH PROCESSING

210$:	TSTB	(R5)+		; IS THIS THE END OF THE LIST
	BNE	190$		; NO, CONTINUE ON
220$:	SETERR	HNGDEV,R0	; END OF LIST, SET DEVICE HUNG
230$:	CLR	D2STUS(R1)	; MAKE SURE ALL STATUS IS CLEARED
	CALLX	IOFINI,R5,JS.DD	; POST DD DVR COMPLETION
	MOV	JOBTBL(R4),R5	; GET A POINTER TO USER'S JDB
	CMPB	R0,#EOF		; IS THIS AN EOF ERROR
	BNE	240$		; NO, IT IS NOT AN EOF ERROR
	CMPB	D2FUN(R1),#<.WRITE&377> ; IS THIS A WRITE COMMAND?
	BNE	240$		; NO, LEAVE THE ERROR AS AN EOF
	SETERR	NOROOM,R0	; OTHERWISE CHANGE IT TO NO ROOM
240$:	MOVB	R0,JDIOST(R5)	; GIVE HIM AN ERROR CODE TO POST
	BNE	250$		; USE THE REAL ERROR, IF ANY
	BIT	#JFCC,JDFLG(R5)	; IF NO ERROR, GIVE HIM
	BEQ	250$		;  A CTRLCE (IF HE TYPED ONE)
	SETERR	CTRLCE,JDIOST(R5); POST ^C TYPED
250$:	MOV	@CONQUE,CONQUE	; DEQUEUE CURRENT REQUEST
	BEQ	260$		; SKIP L3QSET IF NO OTHER REQUEST IS WAITING
	L3QSET	QDDCON		; SIGNAL L3 TO START NEXT REQUEST
260$:	RETURN			;   AND RETURN

GLOBAL	<JS.DD,JOBTBL,QDDCON,CSR.DD,TIM.DD,DEV.DD,EOF>

.DSABL	LSB

.SBTTL	SET UP REGISTERS FOR L3Q DD PROCESSING

;+
; SETDD3 - SET UP REGISTERS FOR CURRENT DEVICE NEEDING L3Q SERVICE
;
;	CALL	SETDD3
;
;	R1 -> DDB
;	R2 -> XRB
;	R3 -> CSR
;	R4 -> DATA BUFFER
;
;-

SETDD3:	MOV	CONQUE,R1	; GET THE DDB POINTER FOR THIS REQUEST
	BEQ	10$		; IF NOTHING IN QUEUE, EXIT WITH Z BIT SET
	SUB	#D2QUE,R1	;  AND SUBTRACT THE QUEUE WORD BIAS
	MOVB	DDUNT(R1),R3	; GET THE UNIT NUMBER FOR THIS DEVICE
	ASL	R3		;  TIMES TWO
	MOV	CSR.DD(R3),R3	; GET THE CSR FOR THIS UNIT
	MOV	D2BUFR(R1),R4	; GET THE BUFFER POINTER
	MOV	BF.XRB(R4),R2	; GET THE XRB ADDRESS
	;CLZ			; POINTER CAN NEVER BE ZERO
10$:	RETURN			; RETURN
	
	GLOBAL	<DEV.DD,CSR.DD>

.SBTTL	SETUP A COMMAND PACKET

;+
; SETCMD - FORM COMMAND PACKET INTO DATA BUFFER
;
;	R1 -> DDB
;	R2 -> XRB
;	R3 -> CSR BASE ADDRESS
;	R4 -> DATA BUFFER
;
;	CALL	SETCMD,R5,<TYPE>
;
;	R4 -> AFTER LAST BYTE OF CHECK SUM
;-

SETCMD:	CLR	D2STUS(R1)	; CLEAR ANY STATUS BITS
	ADD	#BF.DAT,R4	; OFFSET TO THE DATA PORTION OF BUFFER
	MOV	R4,-(SP)	; SAVE POINTER TO BEGINNING OF DATA
	MOVB	#DF.CMND,(R4)+	; SET THE COMMAND PACKET FLAG
	MOVB	#10.,(R4)+	; SET THE BYTE COUNT FOR THE MESSAGE
	MOV	(R5)+,(R4)+	; SET THE COMMAND TYPE
	TST	(R1)		; IS THIS A MODIFIED COMMAND?
.ASSUME	DDMOD	EQ	100000
.ASSUME	DDSTS	EQ	1
	BPL	10$		; NO
	MOVB	#1,-1(R4)	; YES, SET THE MODIFIER
10$:	MOVB	DDUNT(R1),(R4)	; SET THE DEVICE NUMBER
	BICB	#^C<1>,(R4)+	;  AND CORRECT FOR THE CONTROLLER
	CLRB	(R4)+		; NO SWITCHES
	CLR	(R4)+		; NO SEQUENCE NUMBER
	MOV	(R2),(R4)+	; SET THE BYTE COUNT
	MOV	D2BLOK(R1),(R4)+; SET THE BLOCK NUMBER TO START AT
	MOV	(SP),R0		; GET A POINTER TO THE FIRST WORD OF DATA
	CLR	(SP)		; CLEAR THE TOP OF STACK FOR CHECKSUMMING
20$:	ADD	(R0)+,(SP)	; ADD IN A WORD
	ADC	(SP)		; WITH END AROUND CARRY
	CMP	R0,R4		; ARE WE TO THE END YET?
	BNE	20$		; NO, CONTINUE
	MOV	(SP)+,(R4)+	;  AND SET THE CHECK SUM
	MOV	R5,(SP)		; REPLACE THE RETURN ADDRESS ON THE STACK
	BR	OUTMES		; OUTPUT THE MESSAGE NOW

.SBTTL	INITIALISE DECTAPE II TO RESYNCHRONIZE PROTOCOL

;+
; INITDD - INITIALISE DECTAPE II TO RESYNCHRONIZE PROTOCOL
;
;	R1 -> DDB
;	R3 -> CSR
;	R4 -> BUFFER
;
;	CALL	INITDD
;
;	R0 =  UNIT NUMBER OF DEVICE
;	R5 =  GARBAGE
;	D2STUS - STATUS FLAG CLEARED
;-

INITDD:	MOV	#FL.INT,D2STUS(R1); SET THE STATUS
	ADD	#BF.DAT,R4	;POINT TO THE DATA PORTION OF THE BUFFER
	MOV	#-1,(R4)	;SEND TWO BREAKS
	MOV	(R4)+,(R4)+	;SEND TWO MORE BREAKS
	MOV	#DF.INIT*400+377,(R4)+ ;  SEND A RUBOUT WITH PARITY, INIT
	MOVB	#DF.INIT,(R4)+	;  A FINAL INIT
	.BR	OUTMES		;  AND OUTPUT THE MESSAGE

.SBTTL	START A MESSAGE ON ITS WAY

;+
; OUTMES - START AN OUTPUT TRANSFER
;
;	R1 -> DDB
;	R3 -> CSR
;	R4 -> PAST LAST BYTE TO OUTPUT
;
;	CALL	OUTMES
;
;	R1 -> DDB
;	R2 -> XRB
;	R3 -> CSR
;-

OUTMES:	BIS	#FL.OUT,D2STUS(R1); SET THE STATUS TO OUTPUTTING
	MOV	D2BUFR(R1),R5	; GET THE ADDRESS OF THE BUFFER
	SUB	#BF.DAT,R4	; SUBTRACT THE OFFSET IN THE BUFFER
	SUB	R5,R4		; SUBTRACT THE BASE OF THE BUFFER R4=COUNT
	MOV	R4,BF.CNT(R5)	; SET THE COUNT OF BYTES TO OUTPUT
	ADD	#BF.DAT,R5	; WHERE TO FIND THE FIRST BYTE
	MOV	R5,BF.OFF-BF.DAT(R5) ; SET THE BEGINNING OF THE DATA TO OUTPUT
	MOVB	DDUNT(R1),R0	; GET THIS DEVICE NUMBER
	ASL	R0		; DOUBLE IT
	MOV	#2,TIM.DD(R0)	; SET A TIME OUT FOR OUR INTERRUPT
	MOV	(SP)+,D2Q2RT(R1); SAVE THE RETURN ADDRESS
	MOV	#10$-CONDSP,D2QRET(R1); RETURN ADDRESS FOR MESSAGE COMPLETE
	ADD	#XCSR,R3	; POINT TO THE XMITTER CSR
	MOV	#XC.TIE,(R3)	; TELL IT TO INTERRUPT US NOW
	RETURN			;   AND RETURN THROUGH RTI3

10$:	MOV	D2Q2RT(R1),-(SP); SET THE ADDRESS TO RETURN TO
	BIT	#FL.FOO,D2STUS(R1) ; WERE THERE ANY ERRORS
	BNE	20$		; YES, SET CARRY AND RETURN
	TST	(PC)+		; NO, CLEAR CARRY AND SKIP NEXT
20$:	SEC			; SET AN ERROR FLAG
	RETURN			;  AND RETURN TO OUR CALLER

.SBTTL	RECEIVE A MESSAGE

;+
; GETMES - RECEIVE A MESSAGE AND DISPATCH
;
;	R1 -> DDB
;	R3 -> CSR
;	R4 -> DATA BUFFER
;
;	CALL	GETMES,R5,TIME.OUT
;
;	R1 -> DDB
;	R2 -> XRB
;	R3 -> CSR
;	R4 -> DATA BUFFER
;
;	DISPATCH RETURN IS AS FOLLOWS
;
;	MESSAGE TYPE		OFFSET
;	------------		------
;
;	DATA PACKET		  0
;	COMMAND PACKET		  2
;	CONTINUE		  4
;	INIT OR ERROR		  6
;-

GETMES:	TST	(SP)+		; DUMP THE SAVED R5
	MOV	BF.CNT(R4),R0	; ANYTHING BUFFERED
	BEQ	10$		; NO, WE NEED TO START UP THE XFER
	CMPB	BF.DAT(R4),#DF.CMND ; IS THIS A MULTI-BYTE MESSAGE
	BHI	40$		; NO, IT MUST BE A SINGLE BYTE MESSAGE
	CMPB	-(R0),-(R0)	; DECREMENT THE MESSAGE BYTE COUNT BY TWO
	CMPB	R0,BF.DAT+DP.DBC(R4); IS THERE ENOUGH DATA IN THE MESSAGE
.ASSUME	DP.DBC	EQ	CP.MBC
	BHIS	40$		; YES, PROCESS THE MESSAGE ALREADY HERE
10$:	MOVB	DDUNT(R1),R0	; GET THE UNIT NUMBER OF THE DEVICE
	ASL	R0		; TIMES TWO FOR INDEXING
	MOV	(R5),TIM.DD(R0)	; SET A TIMEOUT IN n. SECONDS
	MOV	R5,D2Q2RT(R1)	; SET RETURN ADDRESS TO CALLING ROUTINE
	MOV	#30$-CONDSP,D2QRET(R1); SET WHERE TO RETURN ON RESCHEDULE L3
	MOV	#RC.RIE,(R3)	;TELL TU58 TO INTERRUPT ON INCOMING DATA
.ASSUME	RCSR	EQ	0
	TSTB	D2STUS(R1)	; ARE WE IN XOFF STATE?
	BPL	20$		;NO, SO SETTING IE IS ALL THAT IS NEEDED
	BIC	#FL.XOF,D2STUS(R1); SAY WE ARE OUT OF XOFF STATE
	CLR	XCSR(R3)	;DON'T INTERRUPT WHEN XON IS RECEIVED
	MOV	#DF.CONT,XBUF(R3);TELL THE TU58 TO SPEAK (BARK)
20$:	RETURN			;  AND EXIT THROUGH RTI3

30$:	MOV	D2Q2RT(R1),R5	; SET WHERE ROUTINE RETURN ADDRESS
40$:	BIT	#FL.FOO,D2STUS(R1) ; IS THERE SOME ERROR?
	BEQ	50$		; NO
	ADD	#10,R5		; YES, SET THE PROPER RETURN ADDRESS
	BR	70$		;  AND RETURN AN ERROR TO THE USER

50$:	MOV	#FNCTBL,R0	; GET THE FUNCTION TABLE
	ADD	#BF.DAT,R4	; OFFSET THE BUFFER POINTER TO DATA REGION
60$:	TST	(R5)+		; BUMP THE RETURN ADDRESS
	CMPB	(R0),(R4)	; IS THIS THE FLAG?
.ASSUME	CP.FLG	EQ	0
	BEQ	80$		; YES, PROCESS THIS MESSAGE
	TSTB	(R0)+		; IS THIS THE END OF THE LIST?
	BNE	60$		; NO, KEEP GOING
	BIS	#FL.PRO,D2STUS(R1) ; SAY PROTOCOL ERROR
	LOG$DD			; LOG AN ERROR
70$:	MOV	R5,-(SP)	; SET A PHONEY RETURN ADDRESS
	CALLR	SETDD3		;  AND SET UP THE REGISTERS AND RETURN

80$:	CMPB	(R4),#DF.CMND	; IS THIS A SINGLE BYTE MESSAGE?
	BHI	70$		; YES, GIVE PROPER RETURN	
	MOV	R5,-(SP)	; STORE THE PROPER RETURN ADDRESS
	CLR	R5		; CLEAR AN ACCUMULATOR
	BISB	CP.MBC(R4),R5	; COPY THE MESSAGE BYTE COUNT (NO SIGN EXTEND)
	CMPB	(R5)+,(R5)+	; BYTE COUNT BY TWO
	CLR	R0		; CLEAR AN ACCUMULATOR
90$:	CLR	R2		; CLEAR A TEMPORARY ACCUMULATOR
	BISB	(R4)+,R2	; GET A BYTE
	DEC	R5		; DEC BYTE COUNT
	BEQ	100$		; IF END OF BYTES, DO END PROCESSING
	SWAB	R2		; SWAP THE ACCUMULATOR
	BISB	(R4)+,R2	; GET THE HIGH BYTE
	SWAB	R2		; SWAP THE BYTE TO THIER APPROPRIATE POSITIONS
	DEC	R5		; DECREMENT BYTE COUNT
100$:	ADD	R2,R0		; DO FINAL ACCUMULATE
	ADC	R0		; ADD IN THE CARRY (IF ANY)
	TST	R5		; ANY MORE TO DO?
	BNE	90$		; YES, DO IT
	CLR	R2		; CLEAR R2 FOR TU58'S VERSION OF CHECKSUM
	BISB	(R4)+,R2	; GET LSB
	SWAB	R2		; SWAP FOR MSB
	BISB	(R4)+,R2	; GET MSB
	SWAB	R2		; SWAP BACK TO PROPER POSITION
	CMP	R0,R2		; COMPARE THE TWO CHECKSUMS
	BEQ	110$		; IF EQUAL RETURN TO CALLER, EVERYTHING GOOD
	BIS	#FL.CHK,D2STUS(R1) ; SAY WE HAVE A CHECKSUM ERROR
	LOG$DD			; TELL IT TO THE LOGGER
	ADD	#4,(SP)		; BUMP RETURN ADDRESS BY 4
	MOV	D2BUFR(R1),R0	; GET A BUFFER POINTER
	RORB	BF.DAT(R0)	; ROTATE TO FIND OUT IF WE NEED ANOTHER BUMP
	BCC	110$		; NO, THIS IS A COMMAND FLAG
	ADD	#2,(SP)		; YES, THIS IS A DATA FLAG
110$:	CALLR	SETDD3		; SET UP THE REGISTERS AND RETURN

.SBTTL	REQUEST JOB RESIDENCY AND MAP USER'S BUFFER

;+
; DDJRES - MAKE JOB RESIDENT FOR I/O
;
;	R1 -> DDB
;	R2 -> XRB
;	R3 -> CSR
;	R4 -> DEVICE BUFFER
;
;	CALL	DDJRES
;
;	R0 =  AMOUNT FOR XFER
;	R1 -> DDB
;	R2 -> XRB
;	R3 -> CSR
;	R4 -> DEVICE BUFFER
;	R5 -> USER'S BUFFER MAPPED THROUGH KISAR6
;-

DDJRES:	CALL	SETDD3		; SET UP THE REGISTERS
	MOVB	DDJBNO(R1),R0	; GET JOB NUMBER TIMES 2
	MOV	#QDDCON,R3	; SIGNAL CONTINUATION IF STALLED
	MOV	XRLOC(R2),R5	; GET THE USER BUFFER ADDRESS
	CALLX	FNDJOB		; FIND THE JOB
	 BR	30$		; ERROR IN JOB RESIDENCY
	BCC	10$		; GOT IT
	SUB	#CONDSP+4,(SP)	; SUBTRACT RETURN ADDRESS BIAS
	MOV	(SP)+,D2QRET(R1); RETURN TO CALL US WHEN RESIDENT
	RETURN			;  AND RETURN THROUGH RTI3

10$:	CALLX	UNLOCK		; UNLOCK THE JOB FROM MEMORY
	MOV	JOBTBL(R0),R1	; POINT TO THE JOB JDB
	CALLX	CLRRSQ		; AND CLEAR ANY RESIDENCY QUANTUM
	CALL	SETDD3		; SET UP THE REGISTERS
	MOV	#128.,R0	; RETURN AMOUNT FOR THIS XFER
	CMP	(R2),R0		; DOES THE USER HAVE THIS MUCH?
	BHIS	20$		; YES, AT LEAST
	MOV	(R2),R0		; USE THE AMOUNT LEFT AS THE AMOUNT FOR XFER
20$:	RETURN			;  AND RETURN

	GLOBAL	<JOBTBL>

30$:	CALL	SETDD3		; SET UP ALL THE REGISTERS
	CALL	INITDD		; STOP ANYTHING IN PROGRESS
	MOV	#D2DONE,(SP)	; RETURN TO END PROCESSING
	RETURN			;   AND RETURN

	GLOBAL	<QDDCON>

.SBTTL	TABLE TO MAP TU58 ERRORS INTO RSTS ERRORS

;+
; ERRTBL MAPS TU58 COMPLETION ERROR CODES INTO RSTS ERROR CODES
; THE FOLLOWING ERROR CODES ARE THOSE WHICH DO NOT MAP INTO THE
; HNGDEV ERROR.
;-

.RADIX	10

ERRTBL:	.BYTE	-2 ,EOF		; END OF MEDIUM
	.BYTE	-6 ,DATERR	; READ ERROR ON READ AFTER WRITE
	.BYTE	-17,DATERR	; DATA CHECK ERROR
	.BYTE	-55,EOF		; BAD RECORD NUMBER (SHOULD NEVER OCCUR)

; THE FOLLOWING ERROR MAPPING MUST BE LAST SINCE THE SCANNING ALGORITHM
; WILL TERMINATE ON THE ZERO BYTE

	.BYTE	1  ,0		; NO ERROR (TU58 SUCCEEDED WITH RETRYS)

.RADIX	8

FNCTBL:	.BYTE	DF.DATA		; TABLE OF MESSAGE TYPES
	.BYTE	DF.CMND
	.BYTE	DF.CONT
	.BYTE	0

	GLOBAL	<EOF,HNGDEV,DATERR>

.END
