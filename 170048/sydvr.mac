.INCLUDE /CMN:COMMON/							;023
.INCLUDE /CMN:KERNEL/							;023
.INCLUDE /CMN:FLDEF/							;023
TITLE	SYDVR,<Logical disk driver>,0A,10-MAY-91,MHB/ABC/AWR/DRP/GPK/MND/FRL/MNB/KPH/WRM/PJH

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR SYDVR

;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;  001	TG   27-Jun-80	Fixed R3 FNDJOB Jump @0 bug
;  002  SRM  21-Sep-81	Add FIP Pool code.
;
;				[RSTS V8.0]
;  003	DRP  28-Jun-82	Allow reading beyond the logical end-of-file
;			if UO.INI is set in the UNTOPT table.
;  004	GPK  04-Nov-82	Bugfix in 003 to check for NFS open first
;  005	MND  03-Mar-83	Fix FILSET to bypass DCN calculation when DCS=0 (MSCP)
;  006	GPK  12-Oct-83	Add entry point for PFBIO
;  007	GPK  28-Nov-83	Merge in UPDLRG code, add Compare function
;  008	FRL  05-Dec-83	Extended level 3 queue (L3Q)
;  009  MNB  26-Jan-84  Asynchronous Read/Write changes
;  010  MNB  10-Apr-84  Asynch req bit is now #1 of XRBCRA
;			Error code now in ASYWRK+XRBUSE, not JDIOST
;			Asynch "Read-check" support
;  011  MNB  22-Apr-84	Asynchronous EXTEND support
;  012  GPK  20-Apr-84	PFBIO got moved to EM2 phase
;  013	KPH  26-Jun-84	Allow up to 255. I/O requests
;			Don't allow read-check if no read access to file
;  014	KPH  07-Aug-84	Add delayed close
;  015	KPH  29-Aug-84	Changes for FIP pool in APR5
;			Add I-space read
;  016	GPK  01-Nov-84	Add entry point for BLK.PF function of .PFB
;  017	KPH  22-Mar-85	Bugfix in NFS EOF checking
;  018	KPH  10-Apr-85	Don't update block number on errors
;
;				[RSTS V9.1]
;  019  KPH  21-Feb-85	System stack window turn processing
;  020  KPH  03-Jun-85	Add WTB usage counters
;  021  KPH  16-Aug-85	Remove 017 (fixed in MSCP)
;			Change error code for window turn I/O errors
;
;				[RSTS V9.2]
;  022  KPH  16-Aug-85	Add job control region
;
;				[RSTS V9.3]
;  023  KPH  22-Feb-86	Move out of RSTS phase
;			Correct next VBN update at EOF
;
;				[RSTS V9.5]
;  024  WRM  28-Jul-87	Add Truncate file sub function
;
;				[RSTS V9.6]
;  025	PJH  29-Feb-88	Fix record position on INTLCK error
;
;				[RSTS V10.0]
;  030	FEK  18-Apr-90	Fix incorrectly validated or invalidated WCBs
;  031	FEK  06-Aug-90	Fix buffer overruns on .READAs with illegal XRMOD
;-

	DEFORG	SYDVRM							;023

.SBTTL	WTB layout

.DSECT	,NOCREF

WT$SIZ:	.BLKW		;Size of this WTB, rounded to XBUF boundry
WT$DSQ:	.BLKB	DSQSIZ	;Saved DSQ from request
WT$DRN:	.BLKW		;Desired retrieval entry number
WT$REN:	.BLKW		;Retrieval entry being read into WTB
WT$ADR:	.BLKW		;Memory address of buffer to read next time
WT$BLK:	.BLKW		;LSB of FBN of block read into WTB
	.BLKB		;MSB of FBN of block read into WTB
WT$UNT:	.BLKB		;FIP unit number of disk to read from
WT$BUF:	.BLKB	512.	;I/O buffer for record
WTBSIZ:			;Size of a WTB in bytes
	
	UNORG

.SBTTL	UPDATE INTERLOCK CHECKING

;+
; UPDCHK - UPDATE INTERLOCK CHECKING.
;
;	R0 =  JOB NUMBER TIMES 2
;	R1 -> WCB
;	R3 -> JOB DATA BLOCK
;	R4 -> DSQ
;
;	CALL	UPDCHK
;
;	R5 = ERROR CODE IF CONFLICT(S), ELSE UNCHANGED
;
;	IF C=0 THEN NO CONFLICT(S)
;	IF C=1 THEN CONFLICT(S)
;-

UPDCHK:	BITB	#WC$SPU,W$WCB(R1) ;REQUIRE LOCK TO WRITE MODE?
	BEQ	10$		;NO
	CMPB	DSQFUN(R4),#WFUN+1 ;YES, IS JOB TRYING TO WRITE?
	BHIS	10$		;NOT THIS TIME
	;SEC			;C=1 SINCE BHIS=BCC
	BIT	#WC$LCK,(R1)	;IS BLOCK REALLY LOCKED?
	BNE	100$		;YES, RETURN WITH C=0
	SETERR	PRVIOL,R5	;YEP, PRESET THE ERROR CODE
	RETURN			;SPECIAL UPDATE VIOLATION, RETURN C=1

10$:	REGSCR			;SAVE ALL REGISTERS
	MOVB	W$FLAG(R1),R0	;GET THE FLAGS TO GET
	BIC	#^C<WC$LLK>,R0	; LENGTH OF THE LOCK = # blocks in the transfer
	NEG	R0		;We'll add a negative length		;011
	MOVB 	W$NVBM(R1),R2	;Get END+1 block of transfer MSB	;011
	ADD	W$NVBL(R1),R0	;Form start block of lock LSB		;011
	ADCB	R2		; and add carry to the MSB		;011
	DECB	R2		;Fix MSB. Now R2/R0 = Start blk MSB/LSB	;011
	MOV	W$FCB(R1),R5	;GET ADDRESS OF FILE'S FCB
	MOV	F$WCB-F$CLUS(R5),R5 ;GET ADDRESS OF FIRST WCB FOR THIS FILE
20$:	CMP	R5,R1		;IS THIS OUR OWN WCB?
	BEQ	90$		;YES, IGNORE IT
	BIT	#WC$UPD,(R5)	;IS THIS FILE OPEN IN UPDATE MODE?
	BEQ	90$		;IGNORE READ REGARDLESS OPENS
	MOV	R5,-(SP)	;WE MUST CHECK IT, SO SAVE WCB ADDRESS
	BIT	#WC$LCK,(R5)+	;IMPLICIT LOCK TO CHECK?
	BEQ	70$		;NO, CHECK FOR EXPLICIT LOCK(S)
	INC	R5		;Skip to W$FLAG so we can		;011
	MOVB	(R5)+,R3	;GET LENGTH OF IMPLICIT LOCK
	BIC	#^C<WC$LLK>,R3	; AND ISOLATE IT
	INC	R5		;Skip to W$NVBM				;011
	MOVB	(R5)+,R4	;GET END BLOCK OF RANGE MSB
	MOV	(R5),R5		; AND LSB
	SUB	R3,R5		;COMPUTE START OF RANGE LSB
40$:	SBC	R4		; AND CARRY. NOW R4/R5 = RANGE MSB/LSB
	CMPB	R4,W$NVBM(R1)	;COMPARE OTHER START BLOCK		;011
	BNE	50$		; TO OUR END BLOCK+1
	CMP	R5,W$NVBL(R1)	;  TO SEE IF HE STARTS AFTER WE END	;011
50$:	BHIS	70$		;NO OVERLAP, GO CHECK EXPLICIT LOCK(S)
	ADD	R3,R5		;COMPUTE HIS END BLOCK+1
	ADC	R4		; DOUBLY
	CMPB	R4,R2		;COMPARE OTHER END BLOCK+1		;011
	BNE	60$		; TO OUR START BLOCK
	CMP	R5,R0		;  TO SEE IF HE ENDS BEFORE WE START	;011
60$:	BHI	160$		;CONFLICT!
70$:	MOV	(SP),R5		;NO IMPLICIT CONFLICT. RESTORE HIS WCB ADDRESS
	BITB	#WC$EXT,W$FLAG(R5) ;DOES HE HAVE EXPLICIT LOCKS?
	BNE	110$		;YES, GO CHECK THEM
80$:	MOV	(SP)+,R5	;RESTORE WCB POINTER
90$:	MOV	W$WCB(R5),R5	;GET NEXT WCB FOR THIS FILE
	BIC	#40-1,R5	;REMOVE FLAG BITS
	BNE	20$		;LOOP FOR MORE
	BIS	#WC$LCK,(R1)	;NO CONFLICT, SO GIVE HIM THE IMPLICIT LOCK
100$:	CLC			;SET C=0 FOR NO ERROR
	RETURN

GLOBAL	<JOBTBL>

; CHECK FOR EXPLICIT LOCK CONFLICT

110$:	ADD	#WCBSIZ,R5	;POINT TO WCB EXTENSION
120$:	TST	(R5)+		;SKIP A WORD
130$:	MOVB	(R5)+,R3	;GET EXPLICIT LOCK MSB
	MOVB	(R5)+,R4	; AND SIZE
	BMI	80$		;IF END OF LOCKS, NO CONFLICT
	BEQ	120$		;ZERO LENGTH MEANS NO LOCK HERE
	CMPB	W$NVBM(R1),R3	;COMPARE OUR END BLOCK+1		;011
	BNE	140$		; TO OTHER START BLOCK
	CMP	W$NVBL(R1),(R5)	;  TO SEE IF WE END BEFORE HE STARTS	;011
140$:	BLOS	120$		;NO CONFLICT, CHECK MORE EXPLICIT LOCKS
	ADD	(R5)+,R4	;ADD OTHER LOCK BLOCK LSB TO SIZE
	ADC	R3		; AND CARRY TO GET OTHER LOCK END BLOCK+1
	CMPB	R3,R2		;COMPARE OTHER END BLOCK+1		;011
	BNE	150$		; TO OUR START BLOCK
	CMP	R4,R0		;  TO SEE IF HE ENDS BEFORE WE START	;011
150$:	BLOS	130$		;NO CONFLICT, CHECK MORE
160$:	COM	(SP)+		;DUMP WCB POINTER, SET C=1
	SETERR	INTLCK,TOS.R5(SP) ;SET INTERLOCKED ERROR
	RETURN			;RETURN

.SBTTL	Special function processing

;+
; SPC$SY - Special function processing
;
;	R1 -> WCB
;	R2 =  SPECIAL FUNCTION CODE
;	R5 -> XRB
;		XRBC  = STARTING VBN LSB OF RANGE TO UNLOCK FOR CODE=3
;		XRLOC = STARTING VBN MSB
;
; Positive subcodes are Lock/Unlock functions for update mode files:	;007
;	CODE	ACTION
;	  0	RELEASE ALL LOCKS (IMPLICIT & EXPLICIT)
;	  1	RELEASE IMPLICIT LOCK ONLY
;	  2	MAKE IMPLICIT LOCK EXPLICIT
;	  3	RELEASE AN EXPLICIT LOCK
;	  4	MAKE IMPLICIT LOCK EXPLICIT AND RELEASE IMPLICIT LOCK
;	  5	Truncate open file					;024
;
; Negative subcodes are special disk functions:				;007
;	Code	Action							;007
;	 -1	Compare data						;007
;	 -2	I-Read							;024
;
;-

	TMPORG	SPCTBL,0						;023
	 .WORD	SPC$SY							;023
	UNORG

SPC$SY::MAP	FIPPOL		;MAP THE POOL OF FIP BUFFERS.		;007
	TST	R2		;Is this a lock/unlock function?	;007
	BPL	5$		;No					;007
	JMP	SPCIO		;Yes, go process it			;007

5$:	MOV	#DDRLO!DDWLO,R5	;Pick up read & write lock bits		;013
	BIC	(R1),R5		;Do we have any access to file?		;013
	BEQ	10$		;No, don't allow this call then		;013
	MOV	R3,R5		;USE THE COPY OF THE XRB FROM WORK BLOCK.
	MOV	R1,R4		;COPY THE WCB POINTER
	ADD	#WCBSIZ,R4	; AND INDEX TO (POSSIBLE) WCB EXTENSION
	TST	(R1)+		;POINT TO FLAGS-1 IN THE REAL WCB
	MOV	#WC$EXT*400,R3	;GET A HANDY BIT FLAG
	;MOV	#WC$LCK,R3	; AND ANOTHER IDENTICAL FLAG
.ASSUME	WC$LCK	EQ	WC$EXT*400
	CMP	(R5)+,#5	;IS THE CODE WITHIN RANGE?		;024
	BLOS	20$		;YES, GO DISPATCH
10$:	ERROR	PRVIOL		;INVALID FUNCTION CODE

20$:	CLR	R0		;CLEAR A HANDY REGISTER
	ASL	R2		;DOUBLE FUNCTION CODE FOR DISPATCHING
	ADD	R2,PC		; AND DISPATCH
	 BR	200$		;CODE 0 - RELEASE ALL
	 BR	210$		;CODE 1 - RELEASE IMPLICIT
	 BR	40$		;CODE 2 - MAKE IMPLICIT EXPLICIT
	 BR	230$		;CODE 3 - RELEASE EXPLICIT
	 BR	30$		;CODE 4 - MAKE IMPLICIT EXPLICIT AND RELEASE
	 .BR	28$		;Code 5 - Truncate file call to FIP	;024


28$:	JMP	280$		;a hop.. skip.. and a leap away		;024

30$:	MOV	R3,R0		;CODE 4 - MAKE EXPLICIT & RELEASE. SET FLAG
40$:	MOV	R0,-(SP)	;CODE 2 - MAKE EXPLICIT. SAVE FLAG FOR UNLOCK
	BIT	R3,-2(R1)	;IS THERE AN IMPLICIT LOCK TO USE?
	BEQ	10$		;NOPE, NO IMPLICIT, SO ERROR
	BIT	R3,(R1)		;IS THERE A WCB EXTENSION YET?
	BNE	90$		;YES, SO JUST SEARCH IT
	TST	-(R1)		;NEED ONE, GO TO CURRENT WCB TOP
	MOV	R1,-(SP)	; AND SAVE THAT POINTER
	MOV	#WCBSIZ+40,R1	;ASK FOR THIS MUCH FOR A NEW WCB
..BWCB	==	.-2	;**PATCH** SIZE OF AN EXTENDED WCB
	MOV	#40.,R2		; LEAVING 40. IN MONITOR'S POOL
	MOV	#FIPPOL,R4	;Get from the FIP pool			;015
	CALLX	BUFFR4,R5	;CAN WE GET IT FROM FIP POOL OR MON POOL? ;015
	BCS	180$		;NO, SO SORRY
	MOV	R4,R0		;THIS IS OUR NEW WCB
	ADD	R1,R4		;NOW GO TO ITS END+2
	MOV	#-1,-(R4)	;FLAG END WITH A -1 WORD
50$:	CLR	-(R4)		;CLEAR THE REST
	CMP	R4,R0		; UNTIL BACK TO
	BHI	50$		;  THE TOP
	MOV	@JOBDA,R5	;GET JOB'S IOB POINTER
	MOV	(SP),R2		;GET ORIGINAL WCB BACK AGAIN
60$:	CMP	R2,(R5)+	;A MATCH WITH ORIGINAL YET?
	BNE	60$		;NOPE, CONTINUE (WE MUST FIND IT!)
	MOV	R0,-(R5)	;YEP, RE-POINT THIS IOB SLOT
	MOV	#WCBSIZ/2,R5	;GET NUMBER OF WORDS TO COPY
70$:	MOV	(R2)+,(R0)+	;COPY ORIGINAL TO NEW
	SOB	R5,70$		; AND LOOP
	MOV	R1,(R0)		;SET TOTAL SIZE IN EXTENSION, THEN
	SUB	#WCBSIZ,(R0)	; LEAVE ONLY EXTENSION SIZE IN EXTENSION
	MOV	R4,R1		;PLACE NEW WCB POINTER HERE
	MOV	(SP)+,R4	;GET ORIGINAL WCB
	MOV	W$FCB(R1),R5	;GET POINTER TO FCB @ F$CLUS
	TST	(R5)+		; AND INDEX TO F$WCB LIST
.ASSUME	F$WCB	EQ	F$CLUS+2
80$:	MOV	R5,R2		;COPY POINTER TO PREVIOUS LINK WORD
	MOV	(R5),R5		;GET POINTER TO NEXT WCB ON THE LIST
	BIC	#40-1,R5	;REMOVE FLAG BITS
	ADD	#W$WCB,R5	; AND POINT TO THE LIST THREAD WORD
	CMP	(R5),W$WCB(R4)	;IS THIS THE OLD WCB?
	BNE	80$		;NO, KEEP LOOKING
	BIC	R4,(R2)		;YES, REMOVE LINK TO OLD WCB
	BIS	R1,(R2)		; AND LINK IT TO THE NEW WCB
	BUFFER	RETSML		;NOW RETURN THE OLD WCB
	MOV	R0,R4		;GET EXTENSION POINTER AGAIN
	TST	(R1)+		;INDEX WCB POINTER JUST AS BEFORE
	BIS	R3,(R1)		; AND MARK AS HAVING AN EXTENSION

GLOBAL	<FIPPOL>

90$:	MOVB	W$FLAG-2(R1),R3	;GET LENGTH OF IMPLICIT LOCK
	BIC	#^C<WC$LLK>,R3	; AND ISOLATE IT
	CMP	(R1)+,(R1)+	;POINT TO W$NVBL
.ASSUME	W$NVBL	EQ	6
	MOV	(R1),R0		;GET END BLOCK+1 OF IMPLICIT LOCK LSB
	MOVB	-(R1),R2	; AND MSB
	SUB	R3,R0		;SUBTRACT LENGTH TO GET
	SBC	R2		; STARTING BLOCK OF IMPLICIT LOCK
	MOVB	R3,(SP)		;SAVE THE LOCK LENGTH AS A BYTE BELOW FLAGS
100$:	TST	(R4)+		;SKIP A WORD
110$:	MOVB	(R4)+,R3	;GET AN EXPLICIT LOCK'S MSB
	MOVB	(R4)+,R5	; AND LENGTH
	BMI	150$		;AT END OF LIST, NO CONFLICT
	BEQ	100$		;AN EMPTY SLOT, SKIP IT FOR NOW
	CMPB	R3,(R1)		;COMPARE EXPLICIT START BLOCK
	BNE	120$		; TO IMPLICIT END BLOCK+1
	CMP	(R4),W$NVBL-W$NVBM(R1) ;  TO CHECK FOR OVERLAP
120$:	BHIS	100$		;NO CONFLICT, SO CONTINUE
	ADD	(R4)+,R5	;COMPUTE EXPLICIT LOCK'S
	ADC	R3		; END BLOCK
	CMPB	R3,R2		;COMPARE EXPLICIT END BLOCK+1
	BNE	130$		; TO IMPLICIT START BLOCK
	CMP	R5,R0		;  TO CHECK FOR OVERLAP
130$:	BLOS	110$		;NO CONFLICT, SO CONTINUE
	CMP	R0,-(R4)	;CONFLICT, ARE THE STARTING LSB'S THE SAME?
	BNE	140$		;NOPE, OVERLAP ERROR
	CMPB	(SP)+,-(R4)	;LOCK LENGTHS THE SAME?
	BNE	140$		;NOPE, OVERLAP ERROR
	CMPB	R2,-(R4)	;ARE THE STARTING MSB'S THE SAME?
	BEQ	220$		;YES, SAME LOCK IS A NO-OP
140$:	ERROR	INTLCK		;ELSE ERROR

150$:	MOV	R1,R4		;COPY POINTER TO WCB @ W$NVBM
	ADD	#WCBSIZ-W$NVBM,R1 ;POINT TO THE WCB EXTENSION
160$:	TST	(R1)+		;SKIP A WORD
	TST	(R1)+		;WHERE ARE WE?
	BMI	190$		;FULL, ERROR
	BNE	160$		;AT IN-USE SLOT, CONTINUE
	MOV	R0,(R1)		;FREE, SET EXPLICIT STARTING BLOCK LSB
	MOVB	(SP),-(R1)	; AND LENGTH BYTE
	MOVB	R2,-(R1)	;  AND STARTING BLOCK MSB
	CLRB	(SP)		;ISOLATE THE UNLOCK MASK FOR A WORD
	BIC	(SP)+,-W$NVBM(R4) ;UNLOCK IF CODE 4
	BR	220$		;ALL DONE

170$:	ERROR	NOSUCH		;LOCK TO RELEASE NOT FOUND

180$:	ERROR	NOBUFS		;NO ROOM FOR EXTENDED WCB

190$:	ERROR	NOROOM		;TOO MANY EXPLICIT LOCKS ACTIVE

200$:	BIT	R3,(R1)		;CODE 0 - RELEASE ALL. ANY EXPLICIT LOCK(S)?
	BEQ	210$		;NOPE
	BUFFER	RETURN		;YEP, RETURN THE EXTENDED PART OF THE WCB
	BIC	R3,(R1)		; AND SAY IT HAS BEEN RETURNED
210$:	BIC	R3,-(R1)	;CODE 1 - RELEASE THE IMPLICIT LOCK (IF ANY)
220$:	JMPX	RTI3		;NOW EXIT

230$:	MOV	(R5)+,R0	;CODE 3 - RELEASE EXPLICIT. GET BLOCK LSB
	MOVB	(R5),R2		; AND MSB
	BNE	250$		;EXPLICIT EXPLICIT LOCK RELEASE REQUEST
	TST	R0		;IS THE BLOCK NUMBER REALLY ZERO?
	BNE	250$		;NO, RELEASE ONLY REQUESTED LOCK
	BIT	R3,(R1)		;RELEASE ALL EXPLICITS, ANY THERE?
	BEQ	220$		;NO, SO SIMPLE...
240$:	TST	(R4)+		;YEP, SKIP A WORD
	TST	(R4)		;END OF LIST NOW?
	BMI	220$		;YES, DONE, EXIT
	CLR	(R4)+		;NO, MAKE IT AN EMPTY ENTRY
	BR	240$		; AND LOOP

250$:	SUB	#1,R0		;MAKE VBN INTO 0-N RANGE
	SBC	R2		; CARRYING ON
	BIT	R3,(R1)		;ARE EXPLICIT LOCK(S) POSSIBLE?
	BEQ	170$		;NO, SO SAY NOT FOUND
260$:	TST	(R4)+		;SKIP A WORD
270$:	MOVB	(R4)+,R3	;GET MSB OF EXPLICIT LOCK
	TSTB	(R4)+		;LENGTH OF LOCK TELLS WHERE WE ARE
	BMI	170$		;AT END OF LIST, AN ERROR (NOT FOUND)
	BEQ	260$		;AT AN EMPTY ENTRY, CONTINUE
	CMP	R0,(R4)+	;AT A REAL ENTRY, LSB'S MATCH?
	BNE	270$		;NO MATCH, CONTINUE TRYING...
	CMPB	R2,R3		;REALLY MATCH?
	BNE	270$		;NO
	CLR	-(R4)		;MATCHED, MAKE IT AN EMPTY ENTRY
	CLR	-(R4)		; IN BOTH WORDS
	BR	220$		;  AND DONE




280$:					;Set up for Truncate call	;024
	MOV	JOBWRK,R4		;R4->WRK block of job		;024
	MOV	R1,<FQNAM1+2>(R4)	;Save ptr to WCB		;024
	MOV	FQJOB(R4),FQNAM1(R4)	;move LSB of block # to safety	;024
	CLR	(R4)			;clear the queue link word	;024
	MOVB	JOB,R3			;Set up JOB*2			;024
	MOV	R3,FQJOB(R4)		;...				;024
	MOVB	#TRUFQ,FQFUN(R4)	;load FIP func from FIPTBL	;024
	JMPX	FIPSTL			;issue FIP call			;024

	GLOBAL	<FIPSTL>						;024


.SBTTL	SPCIO -- Special (non-read/write) I/O functions

SPCIO:	CMP	R2,#-2		;Is this a compare or I-read function?	;015
	BHIS	20$		;Yes, good				;007
10$:	ERROR	PRVIOL		;Bad function code			;013

20$:	BIT	#DDRLO,(R1)	;Allowed to read from this channel?	;013
	BNE	10$		;No, don't allow this call to pass	;013
	MOV	XRBC(R3),(R3)	;Yes, use byte count as buffersize	;007
.ASSUME	XRLEN EQ 0							;007
	MOVB	XRMOD(R3),XRBLKM(R3) ;Get the block number MSB		;010
	CLRB	XRMOD(R3)	;Now clear this (paranoia sets in)	;010
	CLR	JBSTAT(R4)	;Make this job non-runnable		;015
	MOV	#JS.SY,JBWAIT(R4) ; like this				;015
	CMP	R2,#-1		;Is this a read-check?			;015
	BEQ	50$		;Yes, so set up for it			;015
	MOV	#.READ&377,R2	;I-space read, set up the function code	;015
	MOV	#1,XRTIME(R3)	;And set the flag for later		;015
	MOV	(R3),R5		;Pick up byte count			;015
	BEQ	40$		;Zero, forget this			;015
	ADD	XRLOC(R3),R5	;R5 now has highest address for transfer ;015
	BCC	30$		;Entire range is good, that's good	;015
	BNE	40$		;Last byte larger than 32K, forget it	;015
30$:	DEC	R5		;R5 has last byte in transfer		;015
	CMP	R5,MAXLOW	;Transfer too large?			;015
	BLOS	ISPCRD		;No, go and do it			;015
40$:	ERROR	BADCNT		;Invalid address or byte count		;015

50$:	CLR	R2		;Set function code for compare		;007
.ASSUME	<^C<0>&6> EQ RFUN.C						;007
	;CLC			;Do "write" validation (C=0 from TST)	;007
	CALLX	CHKXRB		;Validate parameters			;007
	.BR	SER$SY		;Now go process the I/O			;007

GLOBAL	<JBSTAT,JBWAIT,MAXLOW>						;010

.SBTTL	FILE SERVICE MAIN ENTRY POINT

;+
; SER$SY - MAIN ENTRY POINT FOR FILE SERVICE READ/WRITE.
;
;	R1 -> WCB
;	R2 =  2 (.READ) OR 4 (.WRITE) or 0 if .SPEC code -1		;007
;	R3 -> XRB
;	R4 =  JOB NUMBER TIMES 2
;-

.ENABL	LSB								;006

	TMPORG	SERTBL,0						;023
	 .WORD	SER$SY							;023
	UNORG								;023

SER$SY::CLR	XRTIME(R3)	;Indicate this is a D-space request	;015
SYSRW::				;Entry point for BLK.PF			;016
ISPCRD:	MAP	FIPPOL		;MAP FIP'S PRIVATE BUFFER POOL		;015
	CMPB	W$PR(R1),#255.	;Are we up to our I/O limit?		;013
	BLO	10$		;No, not this time			;013
	CALL	RETASY		;Return work block if asynchronous request ;013
	ERROR	INUSE		;And report that we've done too much I/O ;013

10$:	CLR	R5		;GUESS AT ONLY WORD MULTIPLE REQUIRED	;013
	BIT	#1,XRBCRA(R3)	;Is this asynch I/O?			;010
	BEQ	20$		;No, continue				;010
	BITB	R2,#.READ	;Is it an asynchronous read (.READA)?	;010
	BEQ	20$		;No, either a .WRITA or .SPEC		;010
	CMPB	#1,XRMOD(R3)	;Are we requesting a "Read-check"?	;010
	BNE	20$		;No, it is a true .READA		;010
	CLR	R2		;Yes, set SPEC code for a read-check	;010
20$:	MOV	(R3)+,R0	;GET BUFFER LENGTH FROM XRB @ XRLEN
	BITB	R2,#.WRITE	;REALLY A WRITE REQUEST?
	BEQ	40$		;NO, READ or SPEC
	DECB	R5		;YES, WRITE, BLOCK MULTIPLE REQUIRED
	BIT	#WC$UFD,(R1)	;IS FILE REALLY A UFD??
	BEQ	30$		;NO, DATA FILE
	MOV	#^C<400>,R5	;YES, MUST BE EXACTLY 1 BLOCK TO WRITE
30$:	MOV	(R3),R0		;GET COUNT FROM XRB @ XRBC
40$:	CLC			;C=0 for ROR below			;031
	ROR	R0		;MAKE THE BYTE COUNT A WORD COUNT
	BCS	60$		;WORD MULTIPLE IS REQUIRED
	BIT	#WC$UPD,(R1)	;UPDATE MODE FILE?
	BEQ	50$		;NO, NORMAL MODE
	CMP	R0,#WC$LLK*400	;UPDATE, MUST BE WITHIN THIS RANGE
	BHI	60$		;TOO MUCH, ERROR
50$:	BIT	R0,R5		;IS COUNT A CORRECT MULTIPLE?
	BEQ	70$		;YES, ALL O.K. TO PROCEED
60$:	CALL	RETASY		;Return work block if asynchronous request ;013
	ERROR	BADCNT		;And report a parameter error

70$:	CMP	(R3)+,(R3)+	;ADVANCE TO XRCI/XRBLKM IN THE XRB
	TST	(R3)		;IS BLOCK NUMBER ASSUREDLY IN RANGE?
	BMI	60$		;IT CERTAINLY IS NOT
	BIT	-(R3),#1	;IS START ADDRESS EVEN (WORD ALIGNED)?
	BNE	60$		;NO, ODD, ERROR
	MOV	R4,R5		;O.K., SAVE JOB NUMBER TIMES 2
	BUFFER	GETSML,0	;GET DSQ (NOTHING CLEARED)
	BVC	90$		;GOT IT, CONTINUE
	BIT	#1,XRBCRA-XRLOC(R3) ;Failed, is this asynchronous?	;013
	BEQ	80$		;No, so go stall the job		;013
	CALL	RETASY		;Return the asynchronous work block	;013
	ERROR	NOBUFS		;  and die - no buffers available	;009

80$:	MOV	#JSBUF,JBWAIT(R5) ;FAILED TO GET A DSQ, STALL JOB
	JMPX	IOREDO		;NOW WAIT FOR A SMALL BUFFER

GLOBAL	<JBWAIT>

;	R0	R1	R2	R3	R4	R5
;	WRDCNT	->WCB	2/4	->XRLOC	->DSQ	J#*2

90$:	ADD	#DSQTOT,R4	;INDEX DOWN INTO THE NEW FOUND DSQ
	MOV	R0,XRBUSE+10-XRLOC(R3) ;SAVE THE WORD COUNT
	ADD	#400-1,R0	;NOW ROUND UP WORD COUNT TO
	CLRB	R0		; A BLOCK MULTIPLE (MOD 400)
	SUB	R0,XRBUSE+10-XRLOC(R3) ;FORM THE LAST XFER CORRECTION
	SWAB	R0		;NOW WE HAVE THE BLOCK COUNT
	MOV	R0,(R4)		;SAVE BLOCK COUNT FOR TRANSFER
	MOV	R3,-(R4)	;Save WRK or ASYWRK pointer		;009
	SUB	#XRLOC,(R4)	; in the DSQ @ DSQMSC			;009
	BIS	R1,XRTIME-XRLOC(R3) ;Save WCB -> in WRK or ASYWRK	;015
	COM	R2		;USE TRICKY ARITHMETIC ON
	BIC	#^C<6>,R2	; 2/4 TO FORM THE PROPER FUNCTION
.ASSUME	RFUN	EQ	<^C<.READ &377>&6>
.ASSUME	WFUN	EQ	<^C<.WRITE&377>&6>
	MAP	JOBJC6,APR=6,DATA ;Map caller's JCR entry		;022
	MOV	JOBJCR,R0	;And point to it			;022
	TSTB	JCPRI(R0)	;RUNNING WITH HIGH PRIORITY?		;022
	BLE	100$		;NO
	BIS	(PC)+,R2	;YES, SO INCLUDE PRIORITY IN DSQ (@DSQFAR)
	 .BYTE	0,-1		;CHANGE FAIRNESS COUNT TO EXPIRED
100$:	MOV	R2,-(R4)	;SET FUNCTION/FAIRNESS COUNT
	TST	-(R4)		;BACK UP DSQ POINTER
	MOV	(R3)+,-(R4)	;NOW SET USER'S VIRTUAL ADDRESS
.ASSUME	DSQMAL	EQ	DSQFUN-4
	CMP	-(R4),(R3)+	;BACK UP DSQ POINTER, INDEX TO XRBLK IN XRB
	MOV	(R3),-(R4)	;COPY SPECIFIED BLOCK NUMBER LSB
.ASSUME	XRBLK	EQ	XRLOC+4
	CLR	(R3)		;CLEAR IT IN CASE OF ERROR
	MOV	-(R3),-(R4)	;SAME FOR BLOCK NUMBER MSB (HIGH BYTES!)
.ASSUME	XRBLKM	EQ	XRBLK-1
	CLRB	XRBLKM-XRCI(R3)	; AND CLEAR IT IF ERROR
	MOV	#FLDNE,-(R4)	;SET COMPLETION QUEUE/L3Q BIT @ DSQL3Q
	MOV	R5,-(R4)	;SET JOB NUMBER @ DSQJOB (DSQERR=0)
	BIT	#1,XRBCRA-XRCI(R3) ;Was this an asynch request?		;010
	BNE	110$		;Yes, don't dump the job!		;010
	CALLX	SAVJQX,R5	;DUMP JOB SAVING THE QUANTUM	
110$:	MOV	(R4),R0		;RESTORE JOB NUMBER TIMES 2		;009
	MOV	R3,-(R4)	;SAVE POINTER TO XRB @ XRCI IN DSQ+0
	MOV	-(R3),R5	;GET USER'S VIRTUAL ADDRESS FROM XRLOC

GLOBAL	<FLDNE>								;023

;	R0	R1	R2	R3	R4	R5
;	J#*2	??	??	->XRLOC	->DSQ	USRADR

	CMP	XRBSAV-XRLOC(R3),#PFBRDO ;Request from .PFB?		;016
	BNE	115$		;No					;016
	BIC	#1,XRTIME-XRLOC(R3) ;Yes, clear .PFB's read/write flag	;016
115$:	BIT	#1,XRTIME-XRLOC(R3) ;I-space read?			;016
	BEQ	130$		;No, not this time			;015
	BIC	#1,XRTIME-XRLOC(R3) ;Yes, but clear the flag now	;015
	MOV	JOBTBL(R0),R3	;Yes, pick up JDB pointer		;022
	ADD	#<MC.LCK*400>,JDMCTL+M.SIZE(R3) ;And set another lock	;022
	BCS	120$		;Too many locks, crash!			;015
	MOV	JDMCTL+M.PHYA(R3),R3 ;Pick up physical address of job	;022
	CALLX	MAPJCR		;Map JCR entry for job			;022
	MOVB	JCHDRS(R1),R1	;R1 = Size of job's header		;022
	ASH	#11.-6,R1	;R1 = size of header in slivers		;022
	ADD	R1,R3		;R3 has MMU address of job's I-space start ;022
	CLR	R2		;Get ready to get physical address	;015
	ASHC	#6,R2		;R2 and R3 have base address of I-space	;015
	ADD	R5,R3		;Offset to user's address		;015
	ADC	R2		;Double precision			;015
	BR	140$		;Now join up				;015

120$:	CRASH			;Too many locks on memory control block	;015

130$:	CLR	R3		;SET NO BITS ON RESIDENCY
	CALLX	FNDJOB		;NOW FIND THE JOB (NEVER A STALL!)
	CRASH			;Calling job was job... can't happen!	;015
				;2ND EXIT - R5 GUARNTEED NONZERO
140$:	MOVB	R2,DSQMAM(R4)	;SET ADDRESS BITS <21-16>
	MOV	R3,DSQMAL(R4)	; AND BITS <15-0>
	MOV	DSQMSC(R4),R2	;Get -> to WRK or ASYWRK, then		;010
	CLRB	XRBUSE(R2)	; clear error code initially, then	;010
	MOV	XRTIME(R2),R1	;  RESTORE WCB POINTER NOW		;010
SYSFIO::MAP	FIPPOL		;Be sure that FIP pool is mapped	;023
	MOV	R1,R5		;COPY WCB POINTER
	TSTB	W$PR(R5)	;Is this our first I/O request?		;013
	BEQ	150$		;Yes, so don't play with locks		;013
	CALLX	UNLOCK		;Remove this lock, we already have one	;013
150$:	INCB	W$PR(R5)	; and add one more pending I/O request	;013
	ADD	#W$NVBM,R5	; AND INDEX TO NEXT VBN DATA
	MOV	#WC$LCK,-(SP)	;ASSUME WE WILL CLEAR THE LOCK
	MOV	DSQMSC(R4),R2	;Make sure R2 -> WRK, then		;011
	MOVB	#1,XRBPT(R2)	;SET PENDING TRANSFERS TO ONE (# DSQ's)	;011
	MOVB	DSQFBM(R4),R3	;GET SAVED BLOCK NUMBER MSB
	MOV	DSQFBL(R4),R2	; AND LSB
	BNE	160$		;EXPLICIT BLOCK NUMBER, USE IT
	TST	R3		;IS IT REALLY ZERO (IMPLICIT NEXT)?
	BEQ	210$		;YES, USE NEXT AND UNLOCK CURRENT
160$:	BIT	#DDNFS,(R1)	;NON-FILE STRUCTURED?
	BNE	200$		;IT IS NFS, MAKE IT FBN (MAYBE) AND UNLOCK
	SUB	#1,R2		;FS, FORM CORRECT DESIRED BLOCK #
	SBC	R3		; CARRYING ON
	BIT	(SP),(R1)	;IS THERE A LOCK ON NOW??
	BEQ	200$		;NOPE, GO SET BLK # (AND UNLOCK)
	MOV	R2,R0		;YES, COPY THE BLOCK NUMBER LSB
	MOV	R3,-(SP)	; AND MSB
	ADD	DSQTOT(R4),R0	;COMPUTE END BLK # +1 OF REQUEST
	ADC	(SP)		; CARRYING ON
	CMPB	(SP)+,(R5)+	;END OF REQUEST VS. END OF CURR. LOCK
	BNE	170$		;UNEQUAL, CHECK DIRECTION
	CMP	R0,(R5)		;DOES REQUEST END AFTER END OF CURRENT LOCK?
170$:	BHI	190$		;YES, GO SET BLK # AND UNLOCK
	MOVB	W$FLAG(R1),R0	;NO, GET # BLK'S IN CURRENT LOCK AND
	BIC	#^C<WC$LLK>,R0	; TRIM TO A VALID VALUE, THEN
	SUB	R0,(R5)		;  FORM BLK # STARTING CURRENT LOCK
	SBCB	-(R5)		;   AND CARRY
	CMPB	R3,(R5)+	;COMPARE START OF REQUEST TO START OF LOCK
	BNE	180$		;UNEQUAL, GO CHECK DIRECTION
	CMP	R2,(R5)		;DOES REQUEST START BEFORE START OF CURR LOCK?
180$:	BLO	190$		;YES, GO SET BLK # AND UNLOCK
	CLR	(SP)		;REQUEST ENTIRELY WITHIN CURR LOCK, NO UNLOCK
190$:	DEC	R5		;FIX TO POINT TO W$NVBM
200$:	BIC	(SP)+,(R1)	;UNLOCK ANY LOCKED BLOCK IF DESIRED
	TSTB	W$FLAG(R1)	;NON-FILE STRUCTURED IN CLUSTER MODE?
.ASSUME	WC$NFC	EQ	200
	BPL	220$		;NOPE, WE HAVE VBN (FS) OR FBN (NFS BLK MODE)
	TST	R3		;DCN MUST BE SINGLE PRECISION
	BNE	260$		;IF DCN TOO BIG, GIVE EOF ERROR
	MOV	W$FCB(R1),R3	;POINT TO FCB
	MOVB	F$UNT-F$CLUS(R3),R3 ; AND GET THE FIP UNIT NUMBER
	CALLX	CNVDC3		;CONVERT USER'S DCN TO FBN
	BR	220$		;Go set desired block number MSB/LSB	;011

210$:	MOVB	(R5)+,R3	;GET NEXT BLOCK NUMBER MSB (W$NVBM)	;011
	MOV	(R5)+,R2	; AND LSB (W$NVBL)			;011
	BIC	(SP)+,(R1)	;UNLOCK ANY LOCKED BLOCK IF DESIRED
220$:	MOV	DSQMSC(R4),R5	;Get WRK ->				;011
	ADD	#XRBLKM,R5	;Index to XRBLKM (MSB)			;011
	MOVB	R3,(R5)+	;Set desired block number MSB @XRBLKM	;011
	MOV	R2,(R5)		; and LSB @XRBLK			;011
	MOV	R1,R5		;Get WCB ->				;011
	ADD	#W$NVBM,R5	; and index to W$NVBM			;023
	MOVB	R3,(R5)+	;Set up the current block in WCB also	;023
.ASSUME	W$NVBL	EQ	W$NVBM+1
	MOV	R2,(R5)+	;In both the MSB and LSB		;023
.ASSUME	W$FCB	EQ	W$NVBL+2
	.BR	230$		;And check out this transfer		;011

GLOBAL	<JOBTBL>							;015

;	R0	R1	R2	R3	R4	R5
;	??	->WCB	BLK LSB	BLK MSB	->DSQ	->W$FCB

230$:	ADD	DSQTOT(R4),R2	;ADD THE BLOCK COUNT TO THE STARTING BLOCK
	ADCB	R3		; TO GET 1 BEYOND THIS TRANSFER
	BVS	280$		;IF THAT IS 24 BITS, ENTIRE XFER IS BEYOND EOF
	BIT	#DDNFS,(R1)	;Is this channel open NFS?		;004
	BEQ	240$		;No, so always do EOF check		;004
	MOVB	F$UNT(R1),R0	;Get FUN (FCB is in WCB if NFS)		;004
	ASL	R0		;  TIMES 2
	BITB	#UO.INI,UNTOPT(R0) ;INITIALIZING ON THIS UNIT?
	BEQ	240$		;NO
	CMPB	DSQFUN(R4),#RFUN ;IS IT A .READ?
.ASSUME	WFUN	LT	RFUN
	BEQ	FILRDY		;YES, ALLOW READING BEYOND END
240$:	MOV	R3,R0		;IF EXTEND, SAVE THE NEW SIZE MSB
	MOV	(R5),R5		;GET THE POINTER TO FCB @ F$CLUS
.ASSUME	W$FCB	EQ	W$NVBL+2
	SUB	-(R5),R2	;SUBTRACT FILE SIZE LSB
.ASSUME	F$SIZL	EQ	F$CLUS-2
	SBC	R3		; FROM BLOCK BEYOND END
	MOVB	-(R5),R5	;  THEN GET SIZE MSB
	SUB	R5,R3		;   AND SUBTRACT THAT TO GET EXTEND AMOUNT
	BMI	FILRDY		;OVERFLOW MEANS NO EXTEND, SO GO DO IT
	BNE	250$		;POSITIVE MSB AMOUNT IS A LARRRRRGE EXTEND
	TST	R2		;IS THE EXTEND AMOUNT LSB ZERO?
	BEQ	FILRDY		;YES, NO EXTEND TO DO
250$:	CMPB	DSQFUN(R4),#WFUN ;WE MUST EXTEND IF WRITE
	BLOS	290$		; AND IT IS WRITE
	MOV	(R4),R5		;GET XRB POINTER @ XRCI
	CLR	XRBUSE+10-XRCI(R5) ; AND SAY LAST BLOCK IS FULL BLOCK I/O
	TST	R3		;IS THE EXTEND AMOUNT > 65536. ?
	BNE	260$		;YES, CAN'T SHORTEN THE TRANSFER THAT MUCH
	SUB	R2,DSQTOT(R4)	;SHORTEN THE TRANSFER BY THE OVERRUN AMOUNT
	BHI	FILRDY		;IF TRANSFER STILL POSITIVE AMOUNT, DO IT
260$:	SETERR	EOF,R5		;EOF IF READ ENTIRELY OUT OR NFS WRITE TOO BIG
	BR	285$		; AND GO SET THAT ERROR			;019

270$:	SETERR	PRVIOL,R5	;SET THE PROTECTION ERROR
	BR	285$		; AND END US				;019	

280$:	CMPB	DSQFUN(R4),#WFUN ;OFF THE DEEP END. READ OR WRITE?
	BHI	260$		;GIVE EOF IF READ
	SETERR	NOROOM,R5	;SET THE NO ROOM ERROR
285$:	JMP	FILDNE		; AND EXIT				;019

GLOBAL	<UNTOPT>

;	R0	R1	R2	R3	R4	R5
;	NEW	->WCB	EXTEND	EXTEND	->DSQ	??
;	SIZE MSB	LSB	MSB

290$:	BIT	#DDNFS,(R1)	;NON-FILE STRUCTURED?
	BNE	260$		;YES, SO NO EXTEND (CALL IT EOF)
	BIT	#WC$UFD!WC$CTG!DDWLO,(R1) ;IS EXTEND LEGAL HERE?
	BNE	270$		;NOPE, SO CALL IT AN ERROR
	BIT	#WC$UPD,(R1)	;MAYBE. IS THIS AN UPDATE FILE?
	BEQ	320$		;NOPE, EXTEND IS LEGAL
	BITB	#WC$EXT,W$FLAG(R1) ;UPDATE EXTEND, IS THERE AN EXPLICIT LOCK?
	BEQ	270$		;NO, SO EXTEND ISN'T LEGAL
	MOV	R1,R5		;POINT TO
	ADD	#WCBSIZ,R5	; WCB EXTENSION
300$:	TST	(R5)+		;SKIP A WORD
310$:	TST	(R5)+		;CHECK THIS SLOT
	BEQ	300$		;ZERO MEANS EMPTY ENTRY
	BMI	270$		;MINUS MEANS END, SO BLOCK 0 ISN'T LOCKED
	TST	(R5)+		;LOOK AT LOCKED BLOCK NUMBER LSB
	BNE	310$		;NOT BLOCK 0
	TSTB	-4(R5)		;IS BLOCK 0 REALLY EXPLICITLY LOCKED?
	BNE	310$		;IF NOT, CONTINUE. IF SO, EXTEND IS LEGAL.
320$:	MOV	W$FCB(R1),R5	;GET POINTER TO FCB @ F$CLUS
	BITB	#UP.RUN,F$PROT-F$CLUS(R5) ;IS THIS A RUNNABLE FILE?
	BEQ	330$		;IF NOT, ANY EXTEND IS LEGAL
	TST	R0		;YES, WOULD THIS EXTEND MAKE IT LARGE?
	BNE	270$		;IF SO, THAT VIOLATES PROTECTION
330$:	BISB	#WC$DLW,W$FLAG(R1) ;INDICATE SIZES WON'T MATCH ANYMORE
	MOV	(R5),-(SP)	;GET THE CLUSTER SIZE
	NEG	(SP)		; AND MAKE IT A MASK
	MOV	-(R5),R0	;GET THE CURRENT FILE SIZE LSB
	NEG	R0		; AND COMPUTE -SIZE
	BIC	(SP)+,R0	;  TO COMPUTE AMOUNT OF "FREE" EXTEND
	TST	R3		;IS EXTEND AMOUNT VERY LARGE?
	BNE	340$		;YES, CAN'T DO IT ALL FOR FREE
	CMP	R2,R0		;IS DESIRED <= FREE AMOUNT?
	BHI	340$		;NO, MUST DO REAL EXTEND
	MOV	R2,R0		;YES, PARTIALLY INCREASE SIZE (IT'S ALL FREE)
340$:	ADD	R0,(R5)		;NO, UPDATE FCB SIZE TO BIGGEST ALLOWED
	ADCB	-(R5)		; IN BOTH PLACES
	SUB	R0,R2		;DECREASE EXTEND AMOUNT BY FREE EXTEND TAKEN
	SBC	R3		; AS A DOUBLE WORD
	BNE	350$		;NON-ZERO, SO A REAL EXTEND NEEDED
	TST	R2		;FULLY ZERO?
	BNE	350$		;NOPE, GOTTA EXTEND IT
	BIT	#WC$AEX,W$WCB(R1) ;IT WAS ALL FREE, CAN WE CHEAPLY EXTEND?
	BEQ	360$		;YES, SO CONTINUE
350$:	MOVB	#EXTFQ,FQFUN(R4) ;ELSE SET FUNCTION FOR EXTENDING A FILE
	ADD	DSQTOT(R4),W$NVBL(R1) ;Update next block number LSB	;023
	ADCB	W$NVBM(R1)	;And carry into MSB			;023
	BR	FILFIP		;GO CALL THE FILE PROCESSOR

360$:	BIS	#WC$LCK,(R1)	;SET IMPLICIT LOCK ON EXTEND QUANTITY FOR
	.BR	FILRDY		; EXTENDING "GUARDED UPDATE," AND CONTINUE

.DSABL	LSB								;006

;	R0	R1	R2	R3	R4	R5
;	??	->WCB	??	??	->DSQ	??

FILRDY:	ADD	DSQTOT(R4),W$NVBL(R1) ;Update next block number LSB	;023
	ADCB	W$NVBM(R1)	;And carry into MSB			;023
	MOVB	DSQJOB(R4),R0	;GET THE JOB NUMBER FROM THE DSQ
	MOV	JOBTBL(R0),R3	; AND GET THE JDB POINTER FROM THAT
	CALL	FILSET		;DO FINAL HOUSEKEEPING BEFORE TRANSFER
	BIT	#WC$UPD,(R1)	;UPDATE MODE FILE?
	BEQ	10$		;NO
	CALL	UPDCHK		;YES, CHECK FOR CONFLICT(S)
	BCC	10$		;No conflicts, continue			;025
	SUB	DSQTOT(R4),W$NVBL(R1) ;Conflict, so put back pointer	;025
	SBCB	W$NVBM(R1)	;In the MSB too				;025
	BR	FILDNE		;CONFLICT(S) EXIST, ERROR		;025

10$:	CALL	FILGO,R5	;FINALLY START THE TRANSFER(S)
	 BR	FILTRN		;WINDOW NEEDS TURNING
FILRTI:	JMPX	RTI3		;ALL DONE AND GOING

FILTRW:	L3QSET	QFILE		;ENSURE WE FINISH FILE COMPLETIONS LATER
FILTRN:	NOP			;Patch point for testing window turn code ;019
	MOV	R4,R5		;Save DSQ pointer			;019
	MOV	R2,R0		;And desired retrieval entry number	;019
	MOV	W$REN(R1),-(SP)	;Guess that this is a forward turn	;019
	INC	(SP)		; ...					;019
	BCC	10$		;Good guess				;019
	CLR	(SP)		;Backwards, set up for window #0	;019
10$:	MOV	R1,-(SP)	;Save WCB pointer			;019
	MOV	#WTBSIZ,R1	;Pick up size of a WTB			;019
	MOV	#-1,R2		;Never use the monitor's pool		;019
	MOV	#LRGPOL,R4	;Try allocation in LRGPOL		;019
	CALLX	BUFFR4,R5	;Now get us a buffer			;019
	MOV	(SP)+,R1	;Restore WCB pointer			;019
	BCS	50$		;No buffers, go use FIP for this	;019
	INC	USETBL+UT.WTB	;Got one, update usage counter		;020
	CMP	USETBL+UT.WTB,USETBL+UT.WTH ;Update high water mark?	;020
	BLOS	15$		;No, not this time			;020
	MOV	USETBL+UT.WTB,USETBL+UT.WTH ;Update high water mark	;020
15$:	CALLX	MAPBUF		;Go map the WTB				;020
	MOV	R5,R4		;Get DSQ pointer in R4			;019
	CALL	SAVDSQ		;And save the DSQ			;019

; Now we will finish filling in the WTB

	MOV	#140000+WT$DRN,R3 ;R3 -> WTB @ WT$DRN			;019
	MOV	R0,(R3)+	;Save desired retrieval entry #		;019
	MOV	(SP),(R3)+	;Save retrieval entry number to read	;019
.ASSUME	WT$REN	EQ	WT$DRN+2

; The WTB is now filled in. Now we will look in the FCB or WCB to find
; the block number to read off of disk (either the first ret entry for
; a forward turn or the next ret entry for a backwards turn).

	MAP	FIPPOL		;Now map the pool of FIP buffers	;019
	MOV	W$FCB(R1),R0	;And get the FCB pointer @ F$CLUS	;019
	TST	(SP)+		;Is this a forward window turn?		;019
	BNE	20$		;Forward window turn, set up for that	;019
	MOV	R0,R1		;Backwards, get FCB pointer		;019
	ADD	#F$WFND-F$CLUS,R1 ;And point to FBB for first ret entry	;019
	BR	30$		;Now join up				;019

20$:	ADD	#W$NXT,R1	;Point to FBB for next retrieval entry	;019
	CMP	(R1),#-1	;Is there really a next window?		;019
	BNE	30$		;Yes, so go set it up			;019
	SETERR	BADDIR,DSQERR(R4) ;No, so set up bad directory		;019
	CALLX	DISKER		;And queue it to our completion queue	;019
	BR	40$		;Now we're done				;019

30$:	CLR	R5		;Get ready to get r.e. offset		;019
	BISB	(R1)+,R5	;Pick up r.e. offset / 2		;019
	ASL	R5		;Now make it times two			;019
	ADD	#140000+WT$BUF,R5 ;Now we have desired memory address	;019
	MOVB	(R1)+,R3	;Pick up MSB of block number to read	;019
	MOV	(R1)+,R2	;Pick up LSB of block number to read	;019
	MOVB	F$UNT-F$CLUS(R0),R0 ;Pick up FIP unit number		;019
	MAP	DSQMSC(R4),APR=6,DATA ;Remap the WTB			;019
	MOV	R5,@#140000+WT$ADR ;And save the desired address	;019
	MOVB	R0,@#140000+WT$UNT ;Set unit number			;019
	CALL	REDWTB		;Now read in the desired WTB		;019
40$:	JMPX	RTI3		;And we're done				;019

50$:	MOV	R5,R4		;Restore DSQ pointer			;019
	TST	(SP)+		;Clean up the stack			;019
	MOVB	#WINFQ,FQFUN(R4) ;SET WINDOW FUNCTION INTO DSQ
FILFIP:	JMPX	FIPSYS		; AND USE THE DSQ AS A FIRQB

GLOBAL	<LRGPOL,USETBL>							;020

.ENABL	LSB

;	R0	R1	R2	R3	R4	R5
;	??	->WCB	??	??	->DSQ	ERROR CODE
; Come here if there is an error detected with the passed request

FILDNE:	CMP	DSQL3Q(R4),#FLDNE ;Is this file I/O or PFB I/O?		;006
	BEQ	10$		;File I/O				;006
	CALLMI	PFIODN,EM2AP5	;PFB I/O, go there			;012
	RETURN			; and leave				;012

10$:	MOV	DSQMSC(R4),R3	;Get WRK/ASYWRK ->			;010
	MOVB	R5,XRBUSE(R3)	; and SET THE ERROR CODE		;010
	MOVB	DSQJOB(R4),R0	;GET THE JOB NUMBER FROM THE DSQ
	MOV	JOBTBL(R0),R3	; AND GET THE JDB POINTER FROM THAT
20$:	TSTB	R5		;IS THERE AN ERROR?
	BGT	40$		;YES, ALWAYS UNLOCK RECORD, NEVER FAVOR JOB
	CMPB	TIMCLK,#30.	;TIME TO FAVOR THIS DISK JOB?
..DFAV	==	.-2	;**PATCH** DISK FAVORITISM FACTOR
	BHI	30$		;NO
	MOV	R1,-(SP)	;Yes, so save WCB pointer		;022
	CALLX	MAPJCR		;Map JCR entry				;022
	BISB	#1,JCPRI(R1)	;Increase this job's priority		;022
	MOV	(SP)+,R1	;Get back WCB pointer			;022
	MAP	FIPPOL		;And restore FIP pool mapping		;022
30$:	CMPB	DSQFUN(R4),#RFUN ;WAS THE FUNCTION READ?
	BHIS	50$		;SINCE READ, DON'T UNLOCK RECORD
40$:	BIC	#WC$LCK,(R1)	;UNLOCK THE RECORD LIKE THIS
50$:	DECB	W$PR(R1)	;One less pending request		;009
	BNE	60$		;More to do, don't unlock job yet	;013
	CALLX	UNLOCK		;Go and unlock the job			;013
	TSTB	(R1)		;Are we going to do a delayed close?	;014
	BEQ	60$		;No, not this time			;014
	BISB	#200,(R1)	;Yes, so now is the time to do it	;014
60$:	MOV	R4,R2		;SAVE THE DSQ POINTER AND		;013
	MOV	DSQMSC(R4),R4	;Get pointer to WRK (or ASYWRK) here	;009
	CALL	FIXBLK		;Update XRBLK/M to -> beginning of Xfer	;011
	BIT	#1,XRBCRA(R4)	;Was this an asynch request?		;010
	BEQ	70$		;No, do it the old (synch) way		;009
	CALLX	ASYDNE		;Say Asynch I/O is all done		;015
	BR	80$		;continue...				;009

70$:	MOVB	XRBUSE(R4),JDIOST(R3) ;SET THE ERROR CODE		;010
	MOV	R0,R4		; PUT JOB NUMBER TIMES 2 HERE
	CALLX	IOSYD4		;Say synch I/O is all done		;015

80$:	MOV	R2,R4		;NOW RESTORE DSQ POINTER
	TSTB	(R1)		;Should we do a delayed close?		;014
	BPL	90$		;No, not this time			;014
	MOVB	#DECFQ,FQFUN(R4) ;Yes, so go set up the function code	;014
	MOV	R1,FQPPN(R4)	;And save the WCB pointer		;014
	L3QSET	QFILE		;Be sure to come back for more completions ;014
	JMPX	FIPSYS		;And pass this DSQ to FIP		;014

90$:	BUFFER	RETSML		;BE NICE AND RETURN SMALL BUFFER

GLOBAL	<FLDNE>								;023

	L3QENT	QFILE,,SYDAP5	;COMPLETIONS COME HERE

100$:	MAP	FIPPOL		;MAP THE FIP POOL FOR WCB'S
	MOV	DSDONQ,R4	;GET TOP ITEM FROM QUEUE
	BEQ	140$		;IT NO MORE, THEN QUIT			;019
	MOV	(R4),DSDONQ	; ELSE DEQUEUE AND CONTINUE
	MOV	DSQMSC(R4),R2	;Get the WRK or ASYWRK ->		;009
	MOV	XRTIME(R2),R1	; ...so we can RESTORE WCB POINTER	;009
	MOVB	DSQJOB(R4),R0	; AND THE JOB NUMBER TIMES 2
	MOV	JOBTBL(R0),R3	;  AND, FROM THAT, THE JOB DATA POINTER
	MOVB	XRBUSE(R2),R5	;GET ERROR BEFORE THIS, IF ANY		;010
	BNE	120$		;IF THERE WAS ONE, DON'T OVERRIDE IT
	MOVB	DSQERR(R4),R5	;GET ERROR CODE IF ANY
	BMI	120$		;NO ERROR THIS TIME
	BNE	110$		;ERROR, AND IT IS EXPLICIT
	SETERR	DATERR,R5	;ERROR BUT NON-EXPLICIT, SO DATA ERROR
110$:	MOVB	R5,XRBUSE(R2)	;NO, NOW THERE IS AN ERROR		;010
120$:	DECB	XRBPT(R2)	;Have we done all the I/O for transfer	;009
	BEQ	20$		;Yes, so go and tell the user about it
	TST	DSQTOT(R4)	;No, do we have to queue more I/O?
	BEQ	90$		;No, they are queued already

; If DSQTOT is non-zero in a DSQ, it means that we could not queue
; all the I/O because of a lack of small buffers. We saved the
; important DSQ fields in the work block which we will now restore
; and try the I/O again. Note that this operation can happen
; over and over if there is a multi-block transfer using only
; one available DSQ.

	CALL	GETXRB		;GET XRBUSE+10 POINTER INTO R3
	MOV	-(R3),(R0)	;RESTORE THE ORIGINAL FUNCTION/FAIRNESS
	MOV	-(R3),-(R0)	;RESTORE THE ORIGINAL BLOCK COUNT
	MOV	-(R3),-(R0)	;RESTORE ORIGINAL LSB OF ADDRESS
	MOVB	-(R3),-(R0)	;RESTORE ORIGINAL MSB OF ADDRESS
	CALL	FILGO0,R5	;FIX MEMORY ADDRESS AND CONTINUE TRANSFERS
	 BR	130$		;GO TURN A WINDOW			;019
	BR	100$		;DONE, TRANSFER(S) QUEUED, DO MORE COMPLETIONS

130$:	JMP	FILTRW		;Go turn a window			;019
140$:	JMPX	RTI3		;Go get out				;019

.DSABL	LSB

GLOBAL	<JOBTBL,DSDONQ,SYDAP5>						;023

.SBTTL	Save DSQ in WTB and set it up

;+
; SAVDSQ - Save DSQ in WTB and set it up
;
;	R4 -> DSQ
;
;	CALL	SAVDSQ
;
;	R5 = Undefined
;-

SAVDSQ:	MOV	#DSQSIZ/2,R5	;Pick up size of a DSQ in words		;019
	MOV	R3,-(SP)	;Get a work register			;019
	MOV	#140000+WT$DSQ,R3 ;R3 -> DSQ				;019
10$:	MOV	(R4)+,(R3)+	;Copy a word of the DSQ			;019
	SOB	R5,10$		;For the whole DSQ			;019

; Now that we have saved the DSQ, we will update the DSQ for our use

	MOV	(SP)+,R3	;Restore caller's R3			;019
	SUB	#DSQSIZ,R4	;Restore DSQ pointer			;019
	MOV	@DPAR6,DSQMSC(R4) ;And save the address of WTB		;019
	MOV	#WTDNE,DSQL3Q(R4) ;And set up to use our completion queue ;019
	RETURN			;And now we're done			;019

GLOBAL	<WTDNE>								;023

.SBTTL	Restore a DSQ

;+
; RESDSQ -> Restore a DSQ
;
;	R4 -> DSQ
;
;	CALL	RESDSQ
;
;	R0 = Undefined
;	R1 = Undefined
;-

RESDSQ:	MOV	#DSQSIZ/2,R0	;Get size of DSQ in words		;019
	MOV	#140000+WT$DSQ,R1 ;R1 -> Saved DSQ in WTB		;019
10$:	MOV	(R1)+,(R4)+	;Restore a word				;019
	SOB	R0,10$		;For the whole thing			;019
	SUB	#DSQSIZ,R4	;Restore R4				;019
	RETURN			;And we're done				;019

.SBTTL	WTB I/O

;+
; REDWTB - I/O into a WTB
;
;	R2 = LSB of desired block number
;	R3 = MSB of desired block number
;	R4 -> DSQ
;
; WTB is mapped through APR6
;
;	CALL	REDWTB
;
;-

REDWTB:	MOV	R2,@#140000+WT$BLK ;Save LSB of block to read in WTB	;019
	MOVB	R3,@#140000+WT$BLK+2 ;Save MSB of block to read in WTB	;019
	ADD	#DSQUNT,R4	;R4 -> DSQ @ DSQUNT			;019
	MOVB	@#140000+WT$UNT,(R4)+ ;Set up the unit number in DSQ	;019
	MOVB	R3,(R4)+	;Stash MSB of block number to read	;019
.ASSUME	DSQFBM	EQ	DSQUNT+1
	MOV	R2,(R4)+	;And LSB of block number to read	;019
.ASSUME	DSQFBL	EQ	DSQFBM+1
	INC	R4		;Advance to DSQMAM			;019
.ASSUME	DSQMAM	EQ	DSQFBL+3
	MOV	DSQMSC-DSQMAM(R4),R1 ;Pick up MMU address of WTB	;019
	CLR	R0		;And clear MSB				;019
	ASHC	#6,R0		;Now get physical address of WTB	;019
	ADD	#WT$BUF,R1	;And advance to I/O buffer		;019
	ADC	R0		;Double precision			;019
	MOVB	R0,(R4)+	;Stash MSB of WTB address in DSQ	;019
	MOV	R1,(R4)+	;Stash LSB of WTB address in DSQ	;019
.ASSUME	DSQMAL	EQ	DSQMAM+1
	MOV	#400,(R4)+	;Read in one block of directory structure ;019
.ASSUME	DSQCNT	EQ	DSQMAL+2
	MOVB	#RFUN,(R4)+	;Set function as read			;019
.ASSUME	DSQFUN	EQ	DSQCNT+2
	MOVB	@#140000+WT$DSQ+DSQFAR,(R4) ;Set up the fairness	;019
	SUB	#DSQFAR,R4	;Point to start of DSQ			;019
	CALLRX	DISK		;Now start this I/O			;019

.SBTTL	Window turn completion processing

	L3QENT	QWTDNE,,SYDAP5	;Window turn reads come here		;019

WINDNE:	MOV	WTDONQ,R4	;Pick up completed DSQ			;019
	BEQ	20$		;All done				;019
	MOV	(R4),WTDONQ	;Now unlink this DSQ			;019
	MAP	DSQMSC(R4),APR=6,DATA ;Map the WTB			;019
	MOVB	DSQERR(R4),R5	;Pick up error code			;019
	BMI	30$		;None, that's good			;019
	BNE	10$		;Specific error, return it		;019
	SETERR	ABORT,R5	;Non-explicit error, set a fatal one	;021
10$:	JMP	180$		;And return it				;019

20$:	JMPX	RTI3		;All done with WTB processing		;019

30$:	MOV	@#140000+WT$ADR,R0 ;R0 -> Retrieval entry just read	;019
	MOV	(R0),R1		;Pick up link word from ret entry	;019
	BIT	#UL.CLO!UL.BLO!UL.ENO,R1 ;Is this a valid link word?	;019
	BNE	40$		;Yes, sure is				;019
	MOV	#-1,R2		;No, so set the invalid flag		;019
	MOV	R2,R3		; In both places			;019
	BR	50$		;And skip calculation			;019

40$:	BIC	#^C<UL.ENO>,R1	;Save only the entry number		;019
	ADD	#140000+WT$BUF,R1 ;Now pick up WTB offset		;019
	MOV	R1,@#140000+WT$ADR ;And save address of next ret entry	;019
	MOV	(R0),R5		;Pick up link word again		;019
	BIC	#^C<UL.BLO!UL.CLO>,R5 ;And save only block & cluster	;019
	SWAB	R5		;And get cluster & block in low byte	;019
	MOV	R5,R2		;Copy swapped link word #		;019
	BIC	#^C<UL.CLO/400>,R2 ;Save only cluster # * 2		;019
	CMP	R2,#UL.CLO/400	;Is this cluster number legal?		;019
	BHIS	170$		;No, forget this			;019
	MOV	140000+WT$BUF+762(R2),R2 ;Now we have DCN of cluster	;019
	BEQ	170$		;Invalid, forget it			;019
	ASH	#-4,R5		;Get block number in low bits now	;019
	CMPB	R5,@#140000+WT$BUF+760 ;Legal block number?		;019
	BHIS	170$		;No, forget it				;019
	MOVB	@#140000+WT$UNT,R3 ;Pick up FIP unit number		;019
	CALLX	CNVDC3		;Now get the FBN to read		;019
	ADD	R5,R2		;And add in block offset		;019
	ADC	R3		;Double precision			;019
50$:	CMP	@#140000+WT$REN,@#140000+WT$DRN ;Is this the desired record? ;019
	BEQ	80$		;Yes, so we've found the window		;019
60$:	INC	@#140000+WT$REN	;Set up for next window			;019
	CMP	R3,#-1		;Is there a link to next?		;019
	BEQ	170$		;No, bad directory			;019
	CMP	R2,@#140000+WT$BLK ;Is this the correct block?		;019
	BNE	70$		;No, not this time			;019
	CMPB	R3,@#140000+WT$BLK+2 ;Maybe, MSB match?			;019
	BEQ	30$		;Yes, so check out this ret entry	;019
70$:	CALL	REDWTB		;Wrong block, set up to read next one	;019
	BR	WINDNE		;And check for more completions		;019

; We come here when done with window turns. We will set up for SYDVR
; action and start I/O.
;
;	R0 -> Retrieval entry to copy to DSQ
;	R1 -> Address in WTB for next retrieval entry
;	R2 = LSB of FBB for next window (-1 if none)
;	R3 = MSB of FBB for next window (-1 if none)
;	R4 -> DSQ for request

80$:	MOV	DSQMSC(R4),-(SP) ;Save MMU address of WTB		;019
	MOV	#7,R5		;Set up size of r.e			;019
	ADD	#10*2,R0	;Now point to last r.e. + 2		;019
90$:	MOV	-(R0),-(SP)	;Save a word of the r.e.		;019
	SOB	R5,90$		;And loop for the whole r.e.		;019
	MOV	R2,-(SP)	;Save LSB of FBB for next window	;019
	SWAB	R3		;Get MSB into high byte			;019
	MOV	R3,-(SP)	;And save MSB of FBB for next window	;019
	BMI	100$		;No next window, easy...		;019
	SUB	#140000+WT$BUF,R1 ;Get offset into n.e. for next window	;019
	ASR	R1		;Now get n.e. offset in words		;019
	MOVB	R1,(SP)		;And save it for the WCB		;019
100$:	MOV	@#140000+WT$DRN,-(SP) ;Save the r.e. number of this r.e	;019
	CALL	RESDSQ		;Restore the DSQ			;019
	MAP	FIPPOL		;And map the FIP pool			;019
	MOV	DSQMSC(R4),R1	;Pick up work block pointer		;019
	MOV	XRTIME(R1),R1	;Now get WCB pointer			;019
	ADD	#W$REN,R1	;And point to W$REN			;019
	MOV	(SP)+,(R1)+	;Set r.e. number just read into WCB	;019
.ASSUME	W$WCB	EQ	W$REN+2
	TST	(R1)+		;And advance past W$WCB			;019
.ASSUME	W$NXT	EQ	W$WCB+2
.ASSUME	W$WND	EQ	W$NXT+4
	MOV	#9.,R0		;Set up to set new FBB and window	;019
110$:	MOV	(SP)+,(R1)+	;Now set up a word in the WCB		;019
	SOB	R0,110$		;For all 9. words			;019
	SUB	#WCBSIZ,R1	;Point to start of WCB			;019
	CALL	FILGO,R5	;Now do that I/O			;019
	 BR	160$		;Window needs turning, go for it	;019

; If we get here, we are done with queueing transfers. We will now check
; to see if we set up the last retrieval window of the file. If not,
; everything is OK. If we did, we will check to see if the extend code
; has modified the filesize. If so, we will invalidate this window so
; that the next I/O request can fix it.

	ADD	#W$NXT,R1	;Point to WCB @ W$NXT			;019
	TST	(R1)		;Is there another window?		;019
	BPL	150$		;Yes, so no chance of it being invalid	;019
	CMP	-(R1),-(R1)	;No, so point to WCB @ W$REN		;019
.ASSUME	W$REN EQ <W$NXT-4>
	MOV	R1,R2		;And save the pointer			;019
	MOV	(R1),R4		;Get the retrieval entry number		;019
	MOV	-(R1),R0	;And get the FCB @ F$CLUS pointer	;019
.ASSUME W$FCB EQ <W$REN-2>
	MOV	(R0),R3		;Get the file clustersize		;019
	MUL	#7,R3		;Now get blocks/ret entries		;019
	MUL	R3,R4		;Now R4, R5 has block number		;019
	ADD	#W$WND-W$FCB,R1	;Point to WCB @ W$WND			;019
120$:	TST	(R1)+		;Is this entry in use?			;019
	BEQ	130$		;No, so we now have file size		;019
	ADD	(R0),R5		;Update block number			;019
	ADC	R4		;Double precision			;019
	BIT	#40-1,R1	;More to do?				;019
	BNE	120$		;Yes, loop for the whole WCB		;019

; We now have the maximum possible filesize in <R4,R5>. If the size
; in the FCB is larger, we will have to invalidate the current window.
;
;	R0 -> FCB @ F$CLUS
;	R2 -> WCB @ W$REN
;	R4 = Max filesize MSB
;	R5 = Max filesize LSB

130$:	MOV	-(R0),R3	;Get filesize LSB			;019
.ASSUME	F$SIZL EQ <F$CLUS-2>
	CMPB	-(R0),R4	;Is filesize MSB equal?			;030
.ASSUME F$SIZM EQ <F$SIZL-1>
	BNE	140$		;No, check it out			;019
	CMP	R3,R5		;Check out filesize LSB			;019
140$:	BLOS	150$		;Filesize is OK, nothing to do		;019
	MOV	#-1,(R2)	;Filesize is too large, invalidate R.E.	;019
150$:	MOV	(SP)+,R5	;Restore MMU address of WTB		;019
	BR	190$		;And return the WTB			;019

; If we get here, we will need to do another window turn. Since the WTB
; code is supposed to get us the correct window, the only way that we
; should get here is if a transfer crosses windows. Therefore, we'll see
; if the request is for the next window, and if so, set it up. If it
; isn't for the next window, we'll crash (since that "can't" happen).

160$:	MOV	R2,R0		;Move desired window to a safe place	;019
	ADD	#W$NXT,R1	;Point to FBB for next window		;019
	MOV	(R1)+,R3	;Pick up MSB of FBB of next window	;019
	SWAB	R3		;Now get block number in low byte	;019
	MOV	(R1)+,R2	;Pick up LSB of FBB of next window	;019
	MAP	POP,APR=6,DATA	;And map the WTB			;019
	CALL	SAVDSQ		;Go and save the DSQ			;019
	INC	@#140000+WT$DRN	;Say we want the next window		;019
	CMP	R0,@#140000+WT$DRN ;Do we want the next window really?	;019
	BEQ	60$		;Yes, so go get it			;019
	CRASH			;Window error! Crash!			;019

; Come here if the directory is messed up
;
;	R4 -> DSQ
;	WTB is mapped through APR6

170$:	SETERR	BADDIR,R5	;Set up for bad directory error		;019

; Come here on errors
;
;	R4 -> DSQ
;	R5 = Error code
;	WTB is mapped through APR6
;
; We will restore the DSQ, place the error code in the DSQ, queue the
; DSQ to its completion queue, and return the WTB.

180$:	CALL	RESDSQ		;Restore the DSQ			;019
	MOVB	R5,DSQERR(R4)	;And set the error code			;019
	CLR	DSQTOT(R4)	;And say the transfer is finished	;019
	CALLX	DISKER		;Go and queue this DSQ			;019
	MOV	@DPAR6,R5	;Pick up MMU address of WTB		;019

; Come here to return a WTB and get next request
;
;	R5 = MMU address of WTB

190$:	MOV	R5,R4		;R4 and R5 have MMU address for conversion ;019
	ASHC	#7,R4		;Convert MMU address to contorted address ;019
	BUFFER	RETURN		;Go return the buffer to the pool	;019
	DEC	USETBL+UT.WTB	;And update the usage counter		;020
	JMP	WINDNE		;And go for the next request		;019

GLOBAL	<USETBL,WTDONQ,SYDAP5>						;023

.SBTTL	FIX XRBLK/XRBLKM IN WRK BLOCK BEFORE I/O COMPLETION POSTING	;011+

;+
; FIXBLK - Fix up WRK block's XRBLK/XRBLKM to point to beginning of transfer
;
;	R1 -> WCB
;	R4 -> WRK (or ASYWRK)
;	
;	CALL	FIXBLK
;
;	R5 =  RANDOM
;-

.ENABL	LSB								;011+

FIXBLK:	NOP
	MOV	XRBC(R4),R5	;Put number of bytes transferred here	;011
	ADD	#777,R5		;Round up to the nearest block number	;011
	CLRB	R5		;Clear out the lower half		;011
	SWAB	R5		; and put number of blocks*2 there	;011
	ASR	R5		;Now get number of blocks transferred	;011
	SUB	R5,XRBLK(R4)	; and subtract that from our END+1	;011
	SBCB	XRBLKM(R4)	;  carry the heavy load			;011
	ADD	#XRBLK,R4	;POINT TO AREA FOR RETURNED BLOCK NUMBER
	TSTB	W$FLAG(R1)	;NON-FILE STRUCTURED IN CLUSTER MODE?
.ASSUME	WC$NFC	EQ	200
	SEC			;GET A HANDY BIT
	BPL	40$		;NOPE, NO FIXES NEEDED
	SBC	(R4)		;YES, CONVERT FBN TO DCN
	SBCB	-(R4)		; BY TAKING DCN-1
	BCS	30$		;ZERO SHOULD STILL BE ZERO
	MOV	@W$FCB(R1),R5	;Get the device cluster size		;011
	BEQ	30$		;If DCS=0, bypass DCN calculation (MSCP disks)
	BR	20$		;GO ENTER THE CONVERSION LOOP

10$:	RORB	(R4)		;SHIFT THE
	ROR	XRBLK-XRBLKM(R4) ; BLOCK NUMBER
20$:	ASR	R5		;MORE SHIFTING?
	BCC	10$		;YES, LOOP FOR MORE
30$:	CLRB	(R4)+		;RETURN AN MSB OF 0 AND
	INC	(R4)		; DO FINAL CORRECTION: DCN = ((FBN-1)/DCS)+1
40$:	BIT	#DDNFS,(R1)	;IS IT FILE STRUCTURED?
	BNE	50$		;NON-FILE STRUCTURED FBN OR DCN IS ALREADY OK
	ADC	(R4)		;FILE STRUCTURED NEEDS INCREMENTING HERE
	ADCB	XRBLKM-XRBLK(R4) ; AND CARRYING
50$:	SUB	#XRBLK,R4	;Exit with R4 -> WRK (or ASYWRK)	;011
	RETURN			;NOW EXIT

.DSABL	LSB								;011-

.SBTTL	WINDOW CHECKER

;+
; FILIX - CHECK WHETHER WINDOW IN WCB MAPS NEXT VBN IN <WRK @ XRBLK>	;011
; GETREN - Calculate retrieval entry number for FIP
;
;	R1 -> WCB
;	R2 -> WRK or ASYWRK						;011
;
;	CALL	FILIX,R5
;	CALL	GETREN,SYDAP5
;
;	For FILIX:  FIRST RETURN => WINDOW NEEDS TURNING
;	(GETREN always returns this way)
;
;		R0 -> WCB @ W$FCB
;		R2 =  RETRIEVAL ENTRY NUMBER DESIRED
;		R3 =  RANDOM
;
;		C=1 IF WINDOW TURN IS BACKWARD
;
;	For FILIX:  SECOND RETURN => WINDOW IS ALIGNED
;	(GETREN never returns this way)
;
;		R0 -> WCB @ W$FCB
;		R2 =  FIP BLOCK NUMBER (LSB)
;		R3 =  FIP BLOCK NUMBER (MSB)
;-

GETREN::MAP	FIPPOL		;Re-map FIP pool			;023
	CALL	FILIX,R5	;Calculate that R.E. number		;023
	 RETURN			;And we're done				;023
	CRASH			;GETREN called incorrectly!		;023

FILIX:	MOV	R1,R0		;COPY THE WCB POINTER			;023
	ADD	#W$FCB,R0	; and point it to W$FCB			;011
	MOV	XRBLK(R2),R3	;Save next virtual block number LSB	;011
	MOVB	XRBLKM(R2),R2	; and MSB				;011
	MOV	R0,-(SP)	;SAVE POINTER TO WCB @ W$FCB
	BIT	#WC$CTG!DDNFS,(R1) ;CONTIGUOUS OR NON-FILE STRUCTURED?
	BEQ	10$		;NOPE, NORMAL RULES APPLY
	MOV	R2,-(SP)	;BLOCK WITHIN CLUSTER IS VBN, SO SAVE MSB
	MOV	R3,-(SP)	; AND LSB OF OFFSET
	MOV	W$WND(R1),R2	;Get the start DCN we want		;019
	BR	40$		;CONVERT DCN AND ADD IN OFFSET

10$:	CLR	-(SP)		;MSB OF OFFSET WITHIN CLUSTER IS 0
	MOV	@(R0)+,R0	;GET FILE CLUSTER SIZE FROM FCB
	NEG	R0		;MAKE IT INTO A MASK
	MOV	R3,-(SP)	;SAVE VBN LSB
	BIC	R0,(SP)		; AND ISOLATE BLOCK WITHIN FILE CLUSTER
	BR	30$		;GO SHIFT THE VBN TO GET FILE CLUSTER NUMBER

20$:	;CLC			;C=0 SINCE BCC BRANCHED
	ROR	R2		;DIVIDE THE VBN
	ROR	R3		; BY THE FILE CLUSTER SIZE
30$:	ASR	R0		;   TO GET THE FILE CLUSTER NUMBER
	BCC	20$		;    OF THE BLOCK
	DIV	#7,R2		;COMPUTE RETRIEVAL ENTRY NUMBER
	CMP	R2,W$REN(R1)	;DOES IT MATCH R.E. NUMBER OF CURRENT WINDOW?
	BNE	50$		;NO, POP STACK, WINDOW NEEDS TURN, C=1 IF BACK
	ASL	R3		;YES, MAKE WORD WITHIN ENTRY A WORD OFFSET
	ADD	R1,R3		;ADD THE WCB POINTER TO THE R.P. OFFSET ;019
	MOV	W$WND(R3),R2	;GET THE R.P. (DCN) WE WANT
	BEQ	70$		;Zero... WCB is messed up		;019
40$:	ADD	#2,R5		;TAKE 2ND EXIT FOR GOODNESS		;019
	MOV	W$FCB(R1),R3	;POINT TO FCB
	MOVB	F$UNT-F$CLUS(R3),R3 ; AND GET THE FIP UNIT NUMBER
	CALLX	CNVDC3		;CONVERT USER'S DCN TO FBN
	ADD	(SP)+,R2	;ADD IN OFFSET LSB
	ADC	R3		; AND ANY CARRY THAT OCCURS
	ADD	(SP)+,R3	;ADD IN OFFSET MSB
	BR	60$		;GO EXIT

50$:	BIT	(SP)+,(SP)+	;DUMP OFFSET VALUES PRESERVING CARRY
60$:	MOV	(SP)+,R0	;RESTORE POINTER TO WCB @ W$FCB
	RETURN	R5		;NOW EXIT

70$:	CRASH			;WCB contains zero for allocated cluster ;019

.SBTTL	SET UP WCB AND XRB BEFORE TRANSFER

;+
; FILSET - SET UP USER BEFORE STARTING FILE TRANSFER
;
;	R1 -> WCB
;	R3 -> JDB
;	R4 -> DSQ
;
;	CALL	FILSET
;
;	R2 -> WRK (or ASYWRK) block					;011
;	R5 =  RANDOM
;-

FILSET::MAP	FIPPOL		;Be sure FIP pool is mapped		;023
	MOV	DSQMSC(R4),R2	;GET POINTER TO WORK BLOCK (XRB)	;009
	MOV	DSQTOT(R4),R5	;NOW GET TRANSFER BLOCK COUNT
	MOV	R5,-(SP)	; AND REPLICATE IT ON STACK
	SWAB	R5		;NOW TIMES 256. FOR A WORD COUNT
	ADD	XRBUSE+10(R2),R5 ; CORRECTED FOR POSSIBLE SHORT TRANSFER
	ASL	R5		;  * 2 FOR TOTAL BYTE COUNT
	MOV	R5,XRBC(R2)	;RETURN BYTE COUNT TO THE USER
	MOV	(SP),R5		;GET THE BLOCK COUNT AGAIN
	BIC	#^C<WC$LLK>,(SP) ;TRIM TO SIZE THAT FIT'S LOCK LENGTH
	BICB	#WC$LLK,W$FLAG(R1) ;REMOVE THE OLD LOCK LENGTH AND	;011
	BISB	(SP)+,W$FLAG(R1) ; SET THE NEW ONE			;011
	MUL	#128.,R5	;FIND PENALTY FACTOR FOR THAT MANY
..BQNT	==	.-2	;**PATCH** DISK I/O RESIDENCY QUANTUM FACTOR
	SUB	R5,JDRESQ(R3)	; AND DO THE PENALIZATION
	BHIS	10$		;QUANTUM STILL O.K.
	CLR	JDRESQ(R3)	;<0 QUANTUM GETS ZERO
10$:	RETURN			;Now exit because			;011
				; XRBLK,XRBLKM are updated at IODN time	;011

.DSABL	LSB

.SBTTL	START A FILE TRANSFER

;+
; FILGO - START A FILE TRANSFER.
; FILSTA - Start a transfer for FIP's extend/window turn processor
;
;	R1 -> WCB
;	R4 -> DSQ
;
;	CALL	FILGO,R5
;	CALLM	FILSTA,SYDAP5
;
;	For FILGO:  First return, window needs turning
;	For FILSTA: If "Z" is clear (BNE branches), window needs turning
;
;		R0 -> WCB @ W$FCB
;		R2 =  RETRIEVAL ENTRY NUMBER DESIRED
;		R3 =  RANDOM
;
;		C=1 IF WINDOW TURN IS BACKWARD
;
;	For FILGO:  Second return => all o.k., transfer(s) queued
;	For FILSTA: If "Z" is set (BEQ branches), transfers are queued
;
;		R0 =  RANDOM
;		R2 =  RANDOM
;		R3 =  RANDOM
;-

FILSTA::MAP	FIPPOL		;Be sure FIP pool is mapped		;023
	CALL	FILGO,R5	;Start up that transfer			;023
	 BR	10$		;Window needs turning, return that	;023
	SEZ			;Indicate no window turn needed		;023
	BR	20$		;And get out				;023

10$:	CLZ			;Indicate we need a window turn		;023
20$:	RETURN			;All done now				;023

.ENABL	LSB

10$:	MOV	R3,-(SP)	;SAVE ORIGINAL DSQ ADDRESS
	MOV	R4,R0		;COPY NEW DSQ ADDRESS
	MOV	#DSQSIZ/2,R2	;COUNT WORDS TO COPY
20$:	MOV	(R3)+,(R0)+	;NOW COPY THE OLD DSQ
	SOB	R2,20$		; TO THE NEW DSQ
	CLR	DSQTOT(R4)	;CLEAR FLAG IN THIS ONE
	CALL	70$,R5		; AND START IT
	MOV	(SP)+,R4	;GET BACK THE ORIGINAL DSQ
FILGO0:	MOV	DSQCNT(R4),R3	;GET THE WORD COUNT OF PREVIOUS REQUEST
	ASL	R3		;SHIFT FOR BYTE COUNT
	ADD	R3,DSQMAL(R4)	;ADD IT INTO MEMORY ADDRESS
	ADCB	DSQMAM(R4)	; AND CARRY
FILGO:	MOV	DSQMSC(R4),R2	;Put WRK block -> here for FILIX	;023
	CALL	FILIX,R5	;CHECK OUT THE WINDOW
	 RETURN	R5		;1ST EXIT IF NEEDS TURNING
	CLR	DSQCNT(R4)	;CLEAR COUNT INITIALLY
	MOV	R2,DSQFBL(R4)	;SET LSB OF DISK ADDRESS
	MOVB	R3,DSQFBM(R4)	; AND MSB OF DISK ADDRESS

	BIT	#DDNFS,(R1)	;NON-FILE STRUCTURED?
	BEQ	50$		;NO
	MOV	DSQTOT(R4),R2	;YES, GET TOTAL BLOCK TRANSFER COUNT
	CLR	DSQTOT(R4)	; AND SAY WE WILL DO IT ALL
	MOVB	R2,DSQCNT+1(R4)	;SET WORD COUNT TO FULL TRANSFER
	MOV	R4,-(SP)	;Save the DSQ ->			;011
	MOV	DSQMSC(R4),R4	; and load R4 with the WRK block ->	;011
	TSTB	W$FLAG(R1)	;NON-FILE STRUCTURED BY CLUSTERS?
.ASSUME	WC$NFC	EQ	200
	BPL	30$		;NOPE, NEXT BLOCK NUMBER IS JUST CURRENT+SIZE
	MOV	@(R0)+,R3	;GET DEVICE CLUSTER SIZE
	DEC	R3		;MAKE IT A MASK
	ADD	R3,R2		;ROUND FBN ADDITION FACTOR TO AN EXACT
	BIC	R3,R2		; NUMBER OF DEVICE CLUSTERS
	MOVB	XRBLKM(R4),R0	;Get FBN MSB				;011
	BIS	XRBLK(R4),R0	;Is the current transfer from FBN 0?	;011
	BNE	30$		;No					;011
	SUB	R3,R2		;Yes, don't number shadow area of DCN 0	;011
30$:	ADD	R2,XRBLK(R4)	;Add transfer amount to current FBN	;011
	ADCB	XRBLKM(R4)	; to get block number for next time	;011
	MOV	(SP)+,R4	;Now restore the DSQ ->			;011
40$:	CALL	GETXRB		;GET XRBUSE+10 POINTER INTO R3
	ADD	(R3),-(R0)	;NOW DO FINAL XFER CORRECTION IN DSQCNT
	ADD	#2,R5		;WE ARE DONE, SO TAKE SECOND EXIT	;015
	BR	80$		; AND GO START IT UP

50$:	MOV	DSQMSC(R4),R2	;Put WRK block -> here for FILIX	;011
	ADD	#1,XRBLK(R2)	;BUMP NEXT VIRTUAL BLOCK		;011
	ADCB	XRBLKM(R2)	; BY ONE MORE BLOCK			;011
	INCB	DSQCNT+1(R4)	;  AND COUNT AS 256 MORE WORDS TO TRANSFER
	DEC	DSQTOT(R4)	;SUBTRACT 1 BLOCK FROM TOTAL
	BEQ	40$		;IF EXHAUSTED THEN QUIT
	CALL	FILIX,R5	;CHECK WINDOW FOR NEXT BLOCK
	 BR	60$		;NEEDS TURNING, SO QUIT
	SUB	DSQFBL(R4),R2	;FIND DIFFERENCE
	SBC	R3		;BETWEEN THE NEW AND OLD DISK ADDRESSES
	CMPB	R3,DSQFBM(R4)	;THE MSB OF THE DIFFERENCE
	BNE	60$		; MUST BE ZERO
	SWAB	R2		;SWAP BYTES TO COMPARE WITH WORD COUNT
	CMP	R2,DSQCNT(R4)	;LSB MUST BE CURRENT COUNT
	BEQ	50$		;AND IT IS, SO CONTINUE
60$:	MOV	R4,R3		;SAVE THIS DSQ ADDRESS
	BUFFER	GETSML,0	; AND TRY TO GET ANOTHER
	BVC	10$		;IF WE GOT IT, GO COPY AND START A PIECE
	MOV	R3,R4		;RESTORE DSQ POINTER
	CALL	GETXRB		;GET XRB @ XRBUSE+10 INTO R3
	MOV	(R0),-(R3)	;SAVE THE FUNCTION/FAIRNESS @ XRBUSE+6
	MOV	-(R0),-(R3)	;SAVE THE WORD COUNT @ XRBUSE+4
	MOV	-(R0),-(R3)	;SAVE THE LSB OF ADDRESS @ XRBUSE+2
	MOVB	-(R0),-(R3)	;SAVE THE MSB OF ADDRESS @ XRBUSE+1
	ADD	#2,R5		;TAKE SECOND EXIT, SINCE NO FIP ACTION NEEDED ;015

70$:	MOV	DSQMSC(R4),R3	;Get -> to WRK or ASYWRK, then		;009
	INCB	XRBPT(R3)	; COUNT THIS AS A REQUEST		;009
80$:	MOV	W$FCB(R1),R3	;GET POINTER TO FCB @ F$CLUS
	MOVB	F$UNT-F$CLUS(R3),DSQUNT(R4) ;SET THE FIP UNIT NUMBER
	CMPB	DSQFUN(R4),#WFUN ;WRITING?
	BHI	90$		;NO
	BISB	#WC$DLW,W$FLAG(R1) ;YES, DATE OF LAST WRITE NEEDS UPDATING
90$:	CALLX	DISK		;NOW START THE TRANSFER
	RETURN	R5		; AND EXIT

.DSABL	LSB

GETXRB:	MOV	DSQMSC(R4),R3	;Now have the XRB			;009
	ADD	#XRBUSE+10,R3	;INDEX PAST REAL XRB INFORMATION
	MOV	R4,R0		;COPY THE DSQ POINTER
	ADD	#DSQFUN,R0	; AND INDEX TO A USEFUL PLACE
	RETURN			;EXIT

GLOBAL	<JOBTBL>

.SBTTL	Return a (possibly) asynchronous work block

;+
; RETASY - Return a (possibly) asynchronous work block
;
;	R3 -> Anywhere in work block
;
;	CALL	RETASY
;
;	R3 = Undefined
;	R4 = Undefined
;
; This routine will return asynchronous work blocks to the small buffer pool.
; If this is not an asynchronous work block, it will be untouched.
;-

RETASY:	BIC	#40-1,R3	;R3 -> Start of work block		;013
	ROR	XRBCRA(R3)	;Is this an asynchronous work block?	;013
	BCC	10$		;No, not this time			;013
	MOV	R3,R4		;R4 -> Asynchronous work block to return ;013
	BUFFER	RETSML		;Now return it to the pool		;013
10$:	RETURN			;And we're done				;013

.END
