	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
	.INCLUDE /CMN:DXDEF/
TITLE	DXDVR,<FLOPPY DISK DRIVER>,0A,10-MAY-91,ABC/SJK/AJK/FRL

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR DXDVR
;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;
;  001  AJK  17-JUN-81  ADDED CODE TO RESOLVE THE FOLLOWING BUGS:
;			1. SPECIAL FUNCTION PROCESSOR DID NOT SET L3Q FOR
;			   CONTINUATION SERVICE ON A NONE EMPTY QUEUE.
;			2. RECALIBRATE DOES NOT GENERATE AN INTERRUPT.  
;			   INTERRUPT FOR RECALIBRATE IS SIMULATED USING THE
;			   TIME OUT LOGIC OF THE DRIVER.
;			3. 'DXWAIT' SUBROUTINE HAS BEEN REWRITTEN TO CORRECTLY
;			   CHECK FOR DONE/TR READY BITS.  ALSO, A TIME OUT
;			   LOGIC WAS INCORPORATED TO PREVENT SYSTEM HANG UP IN
;			   THE EVENT OF A DEVICE MALFUNCTIONING.
;
;				[RSTS V9.0]
;  002  FRL  25-Oct-83   Added extended L3Q capability
;
;-


	DEFORG	DXDVR

	DEFORG	DXDCTL

	DEFORG	DXDINT

	INCLUDE	ERLDVR

	ORG	DXDVR

.SBTTL	FLOPPY DISK DRIVER DEFINITIONS

; DEFINE 'DDSTS' VALUE FOR FLOPPY DISK

STS.DX	==	0/400
		;NO SPECIAL FLAGS

; DEFINE FLAGS FOR FLOPPY DISK

FLG.DX	==	FLGRND!DDNFS!RXDHND
		;RANDOM ACCESS
		;NON-FILE STRUCTURED
		;FLOPPY DISK

; DEFINE WIDTH

SIZ.DX	==	5*14.+1
		;DEFAULT FOR "NO WIDTH"

; DEFINE DEFAULT BUFFER SIZE

BUF.DX	==	512.
		;DEFAULT TO 512 BYTE BUFFER (BLOCK MODE)

.SBTTL	FLOPPY DISK HARDWARE DEFINITIONS

; COMMANDS

.DSECT	1		;FUNCTION CODES WITH GO BIT

FIL.DX:	.BLKB	2	;FILL SILO
EMP.DX:	.BLKB	2	;EMPTY SILO
WRT.DX:	.BLKB	2	;WRITE SECTOR
RED.DX:	.BLKB	2	;READ SECTOR
INT.DX:	.BLKB	2	;INITIALIZE DISKETTE
RDS.DX:	.BLKB	2	;READ STATUS
WDD.DX:	.BLKB	2	;WRITE SECTOR WITH DELETED DATA MARK
RDE.DX:	.BLKB	2	;READ DEFINITIVE ERROR CODE

; DEFINE THE RX?11 CSR

.BSECT

DXTGO:	.BLKB	.	;INITIATE COMMAND		(ALL DISKS)
DXTFUN:	.BLKB	.	;FUNCTION CODE (NEXT 3 BITS)	(ALL DISKS)
	.BLKB	.	;
	.BLKB	.	;
UN1.DX:			; PSUEDONYM
DXTUN1:	.BLKB	.	;UNIT SELECT			(ALL DISKS)
DXTDNE:	.BLKB	.	;TRANSFER READY			(ALL DISKS)
DXTIE:	.BLKB	.	;INTERRUPT ENABLE		(ALL DISKS)
DXTRDY:	.BLKB	.	;TRANSFER READY			(ALL DISKS)
DXTDEN:	.BLKB	.	;DENSITY FLAG (1=DOUBLE)	(RX02/RX03)
DXTHSL:	.BLKB	.	;HEAD SELECT			(RX03 ONLY)
DXTEXF:	.BLKB	.	;EXTENDED FUNCTION CODE   (NOT IMPLEMENTED)
DXTRX2:	.BLKB	.	;CONTROLLER IS RX211		(RX02/RX03)
DXTEXA:	.BLKB	.	;EXTENDED ADDRESS (NEXT 2 BITS) (RX02/RX03)
	.BLKB	.	;
CLR.DX:			; PSUDONYM
DXTCLR:	.BLKB	.	;CLEAR CONTROLLER		(ALL DISKS)
DXTERR:	.BLKB	.	;TRANSFER ERROR			(ALL DISKS)

; DEFINE DXOPEN STATUS BYTE

.BSECT

	.BLKB	.	;UNUSED
DXOSET:	.BLKB	.	;OPEN FLAGS ARE SET (I/O HAS BEEN DONE)
DXOBLK:	.BLKB	.	;BLOCK # HAS NOT BEEN MODIFIED FOR DOUBLE DENSITY OP
	.BLKB	.	;UNUSED
	.BLKB	.	;UNUSED
DXORX2:	.BLKB	.	;UNIT IS ON RX211 CONTROLLER
DXORX3:	.BLKB	.	;UNIT IS AN RX03 (2 HEADS PER DRIVER)
DXODEN:	.BLKB	.	;DISKETTE IS DOUBLE DENSITY

; DEFINE RX2ES

.BSECT

RXECRC:	.BLKB	.	;CRC ERROR
	.BLKB	.	;UNUSED
RXEIND:	.BLKB	.	;INIT DONE
RXEWRT:	.BLKB	.	;WRITE PROTECT ERROR
RXEDER:	.BLKB	.	;DENSITY ERROR
RXEDEN:	.BLKB	.	;DRIVE DENSITY (1=DOUBLE)
RXEDAT:	.BLKB	.	;DELETED DATA ERROR
RXERDY:	.BLKB	.	;DRIVE READY
RXEUN1:	.BLKB	.	;UNIT SELECTED
RXEHSL:	.BLKB	.	;HEAD SELECTED
RXEWCO:	.BLKB	.	;WORD COUNT OVERFLOW ERROR
RXENXM:	.BLKB	.	;NON-EXISTANT MEMORY TIMEOUT


.SBTTL	FLOPPY DISK DIRTY (READ/WRITE) AREA

	TMPORG	DXDCTL

DXQUE:	.WORD	0	;DRIVER REQUEST QUEUE
DXEDMP:	.BLKW0	4	;R/W AREA FOR DMA RDE.DX
	.BYTE	0	;FILL BYTE
DXEDSQ	= .-DSQMAM	; PHONEY DSQ FOR GETUMR
DXEMAM:	.BYTE	0	;MSB OF MEMORY LOC
DXEMAL:	.WORD	0	;LSB OF MEMORY LOC
DXECNT:	.WORD	0	;BYTE COUNT FOR XFER

.SBTTL	FLOPPY DISK PURE (READ-ONLY) DATA

	TMPORG	DXDINT

DXDINT:	CALLX	INTSAV,R5
	  .WORD	1200
	  .WORD	INT$DX

	UNORG

.SBTTL	SPECIAL FUNCTION SERVICE

;+
; SPC$DX - SPECIAL FUNCTION SERVICE FOR FLOPPY DISK.
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB/FCB
;	R2 =  SPECIAL FUNCTION CODE
;	R3 -> XRB
;	R4 =  CALLING JOB NUMBER TIMES 2
;	R5 -> (MAPPED) XRB
;
;	...
;
;	JMP	RTI3
;
;	-OR-
;
;	ERROR	CODE
;
;	SPECIAL FUNCTION CODES:
;
;	0	READ DENSITY/NUMBER OF HEADS
;	1	RECOMPUTE DENSITY/NUMBER OF HEADS ON NEXT I/O
;	2	INITIALIZE DISKETTE DENSITY
;
;-

.ENABL	LSB

10$:	ERROR	PRVIOL		;INVALID SPECIAL FUNCTION

20$:	ERROR	ERRERR		;FUNCTION CALLED WHICH REQUIRES RX02

SPC$DX::MOV	R3,DXXRB(R1)	;SAVE THE ADDRESS OF THE XRB
	CMP	R2,#<SPCHGH/2>	;IS THE FUNCTION WITHIN RANGE
	BHI	10$		; NO, ERROR RETURN
	BIS	#JFPOST,@JOBF	;ENSURE POSTING THE RESULTS
	ASL	R2		;FUNCTION*2 FOR INDEXING
	MOV	#RTI3,-(SP)	;SET THE RETURN ADDRESS ON THE STACK
	JMP	@SPCDSP(R2)	;DISPATCH TO FUNCTION

; DEFINE JUMP TABLE FOR FUNCTIONS

SPCDSP:	.WORD	SPSTAT		;RETURN OPEN STATUS AS #HEADS & DENSITY
	.WORD	SPCRCM		;RECOMPUTE DENSITY/NUMBER OF HEADS
	.WORD	SPINIT		;INITIALIZE THE DISKETTE

SPCHGH	= .-2-SPCDSP		;HIGHEST .SPEC CODE * 2

.SBTTL	SUSPEND JOB FOR DX COMPLETION

;+
;
; SUSPND - SUSPENDS JOB FOR DX COMPLETION
;
;	R4 = JOB*2
;
;	CALL SUSPND
;
;-

SUSPND:	CLR	JBSTAT(R4)	;PUT JOB INTO STALL
	MOV	#JS.DX,JBWAIT(R4);FOR DX I/O
	RETURN

GLOBAL	<JS.DX,JBSTAT,JBWAIT,JOBTBL,IOFINI>

.SBTTL	START DISKETTE INITIALIZATION - SPECIAL FUNCTION CODE 2

SPINIT:	BITB	#DXORX3!DXORX2,DXOSTS(R1);IS THIS AN RX02 OR RX03?
	BEQ	20$		;IF NOT, THEN RETURN AN ERROR
	MOV	#INT.DX!DXTIE,R5;SET THE FUNCTION FOR INITIALIZATION,WITH IE
	BITB	#1*2,R0		;IS THIS AN ODD UNIT?
	BEQ	30$		;  NO, SKIP UNIT SELECT
	BIS	#DXTUN1,R5	;  YES, UNIT SELECT
30$:	MOV	2(R3),R0	;GET THE SECOND PARAMETER WORD
	CMP	#1,R0		;IS THIS A SINGLE DENSITY INIT?
	BEQ	40$		;  YES - GO QUEUE FUNCTION
	CMP	#2,R0		;IS THIS A DOUBLE DENSITY INIT?
	BNE	10$		;  NO  - ERROR OUT, NO OTHER POSSIBILITIES
	BIS	#DXTDEN,R5	;SET THE DOUBLE DENSITY INDICATOR
40$:	ADD	#DXFUN,R1	;OFFSET DDB TO DXFUN
	MOV	R5,(R1)+	;STORE FUNCTION CODE
	MOV	R3,(R1)+	;STORE XRB POINTER
	MOV	#DXINIT-CONDSP,(R1)+ ;WHERE TO GO
	CALL	SUSPND		;SUSPEND THE JOB FOR DX COMPLETION
	MOV	R1,R4		;MOVE DXQPTR INTO R4
	CALLR	QUEDXF		; AND GO QUEUE THE DX FUNCTION

.SBTTL	RECOMPUTE DENSITY OF DISKETTE - SPECIAL FUNCTION CODE 1

SPCRCM:	CMPB	#DXOSET,DXOSTS(R1);IS THIS LATCHED AS RX01?
	BEQ	SPSTAT		;YES, JUST RETURN STATUS
	CALL	SUSPND		;SUSPEND THE JOB FOR DX COMPLETION
	MOV	#50$-CONDSP,DX2RET(R1);WHERE TO RETURN AFTER DXOSTS IS SET
	MOV	R1,R4		;COPY THE DDB POINTER
	ADD	#DXQRET,R4	;ADD IN OFFSET TO DXQRET
	MOV	#DXSETR-CONDSP,(R4)+;STORE ADDRESS OF COMPUTE ROUTINE
	CALLR	QUEDXF		;QUEUE THE FUNCTION (IT RETURNS TO RTI3)

50$:	CALLX	IOFINI,R5,JS.DX	;POST DRIVER COMPLETION
	MOV	JOBTBL(R4),R5	;GET JDB POINTER
	BIT	#JFCC,JDFLG(R5)	;WAS THERE A CONTROL C?
	BEQ	60$		;  NO - GO RETURN STATUS TO USER
	SETERR	CTRLCE,JDIOST(R5);POST A CONTROL-C TO THE USER
60$:	MOV	DXXRB(R1),R3	;COPY THE XRB POINTER FOR SPSTAT (BELOW)
	MOV	DXQPTR(R1),DXQUE;DEQUEUE THE REQUEST
	BEQ	SPSTAT		;QUEUE EMPTY, SKIP L3QSET		;001
	L3QSET	QDXCON		;SIGNAL USER SERVICE TO RUN		;001
	.BR	SPSTAT		;NOW RETURN STATUS TO USER

.SBTTL	RETURN OPEN STATUS TO THE USER - SPECIAL FUNCTION CODE 0

SPSTAT:	TST	(R3)+		;BUMP XRB POINTER
	MOV	#1*400!1,(R3)	;SET THE INITIAL STATUS (SINGLE DENS, 1 HEAD)
	BITB	#DXOSET,DXOSTS(R1);HAS STATUS BEEN SET?
	BEQ	SPCRCM		;    NO - RECOMPUTE THE STATUS
	TSTB	DXOSTS(R1)	;CHECK FOR DENSITY SETTING
.ASSUME	DXODEN	EQ	200	;
	BPL	70$		;  SINGLE DENSITY - CONTINUE
	ASLB	(R3)		;DOUBLE DENSITY, ADJUST THE DENSITY BYTE
70$:	BITB	#DXORX3,DXOSTS(R1);IS THIS A TWO HEADED MONSTER?
	BEQ	80$		;NO - RETURN TO THE USER
	ASLB	1(R3)		;YES - ADJUST THE BYTE
80$:	RETURN			;BACK THROUGH RTI3

.DSABL	LSB

.SBTTL	UNIBUS MAP REGISTER AVAILABLE

;+
; UMR$DX - UNIBUS MAP REGISTER IS NOW AVAILABLE
;
;	ENTRY AT PR5
;
;-

.ENABL	LSB

UMR$DX::CALL	SETDX		;;SET UP REGISTERS FROM QUEUE
	BEQ	10$		;; IF NOTHING IN QUEUE EXIT FAST
	TSTB	DXUWAT(R1)	;;IS THIS REQUEST WAITING FOR UMR?
	BPL	10$		;; NO, EXIT
	CLRB	DXUWAT(R1)	;; YES, SET FOR CONTINUATION
	CALLR	SETQDX		;;GO SET

10$:	.BR	ASN$DX		;; AND LEAVE

.DSABL	LSB

.SBTTL	DEVICE ASSIGNMENT SERVICE

;+
; ASN$DX - DEVICE ASSIGNMENT SERVICE FOR FLOPPY DISK.
;
;	R0 =  JOB NUMBER OF ASSIGNER TIMES 2
;	R1 -> DDB
;
;	...
;
;	RETURN		(WITH ALL REGISTERS PRESERVED)
;-

ASN$DX::.BR	DEA$DX		;NOTHING SPECIAL

.SBTTL	DEVICE DEASSIGNMENT SERVICE

;+
; DEA$DX - DEVICE DEASSIGNMENT SERVICE FOR FLOPPY DISK.
;
;	R1 -> DDB
;
;	...
;
;	RETURN		(WITH ALL REGISTERS PRESERVED)
;-

DEA$DX::RETURN			;NOTHING TO DO...

.SBTTL	INTERRUPTS

;+
; INT$DX - INTERRUPTS FOR FLOPPY DISK.
;
;	R0 =  UNIT NUMBER TIMES 2
;	PRIORITY IS PR5
;
;	...
;
;	RETURN
;-

.ENABL	LSB

INT$DX::CMP	(PC),(PC)+	;;SET N=0 SO SXT WILL PRODUCE 0
				;;SKIP NEXT WORD AS DATA

.SBTTL	TIMEOUTS

;+
; TMO$DX - TIME OUT ENTRY POINT.
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB
;	R3 -> CSR
;	PRIORITY IS PR5
;
;	...
;
;	RETURN
;-

TMO$DX::SEN			;;TIMEOUT IS LIKE INTERRUPT, BUT WITH -1
	SXT	R5		;; IN THE HIGH BYTE OF DXSTS
	CLR	TIM.DX		;;NO TIMEOUT NOW
	CALL	SETDX		;;GET REGISTERS SET UP
	BEQ	10$		;;NOTHING IN THE QUEUE!
	CALL	SETQDX		;;SIGNAL FLOPPY CONTINUATION AT L3
	BIT	#CLR.DX,DXSTS(R1) ;;WAITING FOR RECALIBRATE?		;001
	BEQ	DXSREG		;;NO					;001
	CLR	R5		;;YES, PRETEND INTERRUPT FROM RECALIBRAT;001
DXSREG:	MOV	2(R3),DXSTS(R1)	;;SAVE STATUS IN DDB
	MOV	(R3),DXCTL(R1)	;;SAVE CSR VALUE
	CLR	(R3)		;;DISABLE INTERRUPTING
	BIC	#170000,DXSTS(R1);;CLEAR OUT THE CURRENT UNDEFINED BITS
	TST	R5		;;WAS THIS A TIMEOUT?
	BPL	10$		;;NO, INTERRUPTS JUST CONTINUE ON
	BIS	#100000,DXSTS(R1);;TIMEOUTS REQUIRE NEGATE SIGN BIT
10$:	RETURN			;;EXIT FROM INTERRUPT

.DSABL	LSB

GLOBAL	<TIM.DX>

.SBTTL	ERROR LOGGING

;+
; ERL$DX - ERROR LOGGING ENTRY POINT.
;
;	REGISTRS SAME AS AT TIME OF LOG$DX CALL
;	PRIORITY IS PR7
;
;	...
;
;	RETURN
;-

ERL$DX::MOV	R1,R4		;;;SAVE DDB POINTER HERE
	CALLX	ERLDVR,R5	;;;CALL COMMON DEVICE ERROR LOGGER
	 .BYTE	ERC$DX		;;;FLOPPY ERROR CODE
	 .BYTE	DDS.DX		;;;SIZE OF DDB
	 .BYTE	0,0		;;;NO REGISTERS, SINCE THEY ARE IN THE DDB
	BIT	#DXTRX2,DXCTL(R4) ;;; IS THIS AN RX02 DISKETTE?
	BEQ	10$		;;;NOPE, DON'T DUMP INTERNAL REGISTERS
	MOV	#DXEDMP,(R1)	;;;FILL IN THE DDB EXTENSION (INT REGS)
	MOV	#2*400+4,-(R1)	;;;SAY 4 WORDS OF FIELD 2
10$:	MOV	R4,(R2)		;;;SET A FIELD 4 POINTER
	ADD	#DXCTL,(R2)	;;; TO THE SAVED CSR REGISTERS
	MOV	#4*400+2,-(R2)	;;;SAY 2 WORDS OF FIELD 4
	TST	DXSTS(R4)	;;;TIMEOUT?
	BPL	20$		;;;NO
	COMB	(R0)		;;;YES, SET A FLAG
20$:	RETURN			;;;BACK TO ERROR LOGGER

GLOBAL	<DDS.DX>

.SBTTL	OPEN SERVICE FOR FLOPPY DISK

;+
; OPN$DX - OPEN SERVICE FOR FLOPPY DISK.
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB (MUST BE PRESERVED)
;	R4 -> FIRQB (DEFAULT FQFLAG AND FQBUFL VALUE LOADED)
;	R5 -> JOB'S IOB ENTRY (MUST BE PRESERVED)
;
;	...
;
;	RETURN
;
;	-OR-
;
;	CALL	RETDEV
;	ERROR	CODE
;-

.ENABL	LSB

OPN$DX::MOVB	#DXOSET,DXOSTS(R1);PRESET RX11 CONTROLLER OPEN STATUS
	BIS	#DDSTAT,(R1)	;ASSUME WE WANT BLOCK MODE
	MOV	R3,-(SP)	;SAVE R3 (NEEDED FOR MODE)
	MOV	FQMODE(R4),R3	;GET THE OPEN MODE
	MOV	R3,DXBLOK(R1)	;SET NEXT SECTOR
	BIC	#^C<4095.>,DXBLOK(R1) ;WITH BITS ISOLATED
	ASL	R3		;CHECK FOR BLOCK MODE
	BPL	10$		;IF BLOCK MODE, FQBUFL = 512. IS RIGHT
	BIC	#DDSTAT,(R1)	; ELSE TURN OFF BLOCK MODE FLAG
	MOV	#128.,FQBUFL(R4) ;  AND SET 128 BYTE SECTORS
10$:	BIT	#DXTRX2,@CSR.DX(R0);IS THIS AN RX211 CONTROLLER?
	BEQ	20$		; NO - DONE WITH OPEN
	MOVB	#DXORX2,DXOSTS(R1);SET RX211 CONTROLLER AND NO I/O DONE YET
	TST	R3		;ARE WE IN BLOCK MODE?
	BPL	20$		; YES, RETURN TO THE CALLER
	ASL	FQBUFL(R4)	; NO, SO DOUBLE THE BUFFERSIZE
20$:	MOV	(SP)+,R3	;RESTORE R3 NOW
	.BR	CLS$DX		;END OF OPEN

.DSABL	LSB

.SBTTL	CLOSE SERVICE FOR FLOPPY DISK

;+
; CLS$DX - CLOSE SERVICE FOR FLOPPY DISK.
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB/FCB
;	R5 -> DDB/FCB (MUST BE PRESERVED)
;	IF Z=1 THEN A REAL CLOSE CALL
;	IF Z=0 THEN A "RESET" CLOSE CALL
;
;	...
;
;	RETURN
;-

CLS$DX::RETURN			;SIMPLE ISN'T IT...

.SBTTL	USER LEVEL SERVICE

;+
; SER$DX - USER LEVEL READ/WRITE SERVICE.
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB/FCB
;	R2 =  2 (.READ)
;	      4 (.WRITE)
;	R3 -> XRB
;	R4 =  CALLING JOB NUMBER TIMES 2
;	R5 -> USER'S BUFFER (THROUGH KISAR6)
;	IF Z=1 OR C=0 THEN THIS IS THE FIRST CALL
;	IF Z=0 OR C=1 THEN THIS IS A "REDO" CALL
;
; NOTES:
;
;	1) ACCESS RIGHTS HAVE BEEN VERIFIED.
;	2) DIRECTIONAL RIGHTS HAVE BEEN VERIFIED.
;
; EXITS:
;
;	1) ALL COMPLETE WITH NO ERROR
;
;		JMP	IOEXIT
;
;	2) ALL COMPLETE WITH ERROR
;
;		SETERR	CODE
;		JMP	IOEXIT
;
;		-OR-
;
;		ERROR	CODE
;
;	3) STALL DESIRED (FOR "REDO" LATER)
;
;		JMP	IOREDO
;-

.ENABL	LSB

5$:	ERROR	BADCNT		;ODD BYTE COUNT IS AN ERROR

SER$DX::BIT	#1,XRBC(R3)	;IS THE BYTE COUNT FOR XFER ODD?
	BNE	5$		; YES, GIVE HIM AN ERROR
	BIT	R0,#1*2		;IS THIS AN ODD UNIT?
	BEQ	10$		;NO, LEAVE IT EVEN
	BIS	#UN1.DX,R2	;SET THE ODD UNIT SELECT BIT IN DXFUN

10$:	BIS	#WRT.DX,R2	;CHANGE 2(READ)=>7, 4(WRITE)=>5
	MOV	R1,R4		;COPY THE DDB POINTER
	ADD	#DXBLOK,R4	;POINT TO THE BLOCK NUMBER WORD
	MOV	XRBLK(R3),R0	;GET THE REQUESTED BLOCK NUMBER
	BIT	R2,#2		;IS IT READ OR WRITE?
	BNE	20$		;READ, IGNORE DELETED DATA MARK BIT
	MOV	XRBC(R3),(R3)	;MOVE WRITE COUNT INTO XRLEN
	BIT	R0,#040000	;IS RECORD 16384. SET?
	BEQ	20$		;NO, JUST AN ORDINARY WIRTE
	ADD	#WDD.DX-WRT.DX,R2 ;CHANGE FROM WRITE TO WRITE W/DEL DATA
20$:	MOV	R0,XRBUSE(R3)	;SAVE INTERLEAVE INDICATOR IN XRB
	BIC	#140000,R0	;REMOVE FLAG BITS FROM BLOCK NUMBER
	BEQ	30$		;NO BLOCK NUMBER SPECIFIED, USE NEXT
	BIC	#020000,R0	;UNSET 8192. FLAG IF SET
	MOV	R0,(R4)		;SAVE BLOCK IN DDB
30$:	MOV	(R4),XRBLK(R3)	;RETURN A BLOCK NUMBER TO HIM
	CLRB	XRBLKM(R3)	; WITH A ZEROED HIGH ORDER
	TST	(R1)		;BLOCK MODE?
	BPL	40$		;NO
	ASL	(R4)		;YES, GIVE HIM A FREE * 4
	ASL	(R4)		;
	BISB	#DXOBLK,DXOSTS-DXBLOK(R4); SAY BLOCK # NEEDS MOD IF DOUBLE DEN
40$:	TST	(R4)+		;BUMP POINTER
	MOV	R2,(R4)+	;SAVE THE FUNCTION CODE
	MOV	R3,(R4)+	;SAVE THE USER XRB POINTER
	CLR	(R4)+		;FIRST SERVICE IS START-UP
.ASSUME	DXSTRT	EQ	CONDSP	;
QUEDXF:	CALLX	QUEUER,R5,DXQUE	;QUEUE IT UP FOR FLOPPY SERVICE
	BCC	50$		;NOT FIRST
	CALL	SETQDX		;START IT UP IF FIRST
50$:	JMPX	DMPJOB		;DUMP THE JOB

.DSABL	LSB
.ENABL	LSB

.SBTTL	LEVEL 3 QUEUED CONTINUE ENTRY POINT

CON$DX::MOV	#RTI3,-(SP)	;PRETEND RTI3 CALLED US
	CALL	SETDX		;SET UP THE REGISTERS
	BEQ	30$		;NOTHING THERE TO CONTINUE WITH!
	ADD	DXQRET(R1),PC	;DISPATCH TO CONTINUATION CODE
CONDSP:				;DISPATCH BIAS

GLOBAL	<RTI3>

.SBTTL	USER SERVICE AT LEVEL 3

DXSTRT:	BITB	#DXOSET,DXOSTS(R1);ARE DENSITY/RX3 SET?
	BNE	10$		;YES, JUST KEEP IT GOING
	MOV	DXQRET(R1),DX2RET(R1);MAKE SURE WE RETURN HERE
	CALLR	DXSETR		;CALL THE SETTING ROUTINE, IT WILL REQUEUE

10$:	MOV	#5,DXRTRY(R1)	;SET RETRY COUNT TO 5, ERROR CODE TO 0
	TSTB	DXOSTS(R1)	; IS THIS A DOUBLE DENSITY DISKETTE?
.ASSUME	DXODEN	EQ	200	;DXODEN IS THE BYTE'S SIGN BIT
	BPL	DXIORT		;  THIS IS A SINGLE DENSITY DISKETTE
	BIS	#DXTDEN,DXFUN(R1); THIS IS A DOUBLE DENSITY DISKETTE, SET BIT
	TST	(R1)		; ARE WE IN BLOCK MODE?
	BPL	DXIORT		;  NO, SO WE SHOULD BE JUST ABOUT SET
	BITB	#DXOBLK,DXOSTS(R1); DO WE NEED TO MODIFY THIS BLOCK #
	BEQ	DXIORT		;  NO, CONTINUE ON
	ASR	DXBLOK(R1)	;  YES, COMPUTED SECTOR NUMBER IS WRONG
	BICB	#DXOBLK,DXOSTS(R1);    AND SAY NO MOD NEEDED NEXT TIME THROUGH
DXIORT:	CLR	DXSTS(R1)	;SET TIMEOUT FLAG TO 0
	BIT	#2,DXFUN(R1)	;IS THE FUNCTION WRITE?
	BNE	110$		;NO, READ
20$:	CALL	DXJRES		;FOR WRITING, MAKE THE JOB RESIDENT
	BITB	#DXORX2,DXOSTS(R1);ARE WE ON AN RX211?
	BEQ	80$		;NO, DO THINGS THE SLOW WAY

; DMA FILL FUNCTION STARTS HERE

	MOV	R2,-(SP)	;SAVE R2
	MOV	R1,-(SP)	;  AND R1
	TST	DXECNT		;IS THIS A ZERO SECTOR?
	BEQ	40$		; YES, NO NEED FOR UMR, JUST PAD FROM ZERO
	MOV	R1,R4		;USE THE DDB POINTER AS A UNIQUE ID TO GETUMR
	MOVB	DXEMAM,R1	;SET THE HIGH BYTE OF THE ADDRESS
	MOV	DXEMAL,R2	;  AND THE LOW BYTE
	NEG	R0		;MAKE BYTE COUNT INTO -(BYTE COUNT)
	ROR	R0		;MAKE -(BYTE COUNT) INTO -(WORD COUNT)
	SPLC	5		;BUMP THE PRIORITY
	CALL	@GETUMR		;;ATTEMPT TO GET THE UMR
	SPL	3		;;LOWER THE PRIORITY
	BCC	50$		;NO ERROR, GO PROCESS DMA
	MOV	(SP)+,R1	; RESTORE THE DDB POINTER
	MOV	#20$-CONDSP,DXQRET(R1); SAVE THE RETURN ADDRESS
	MOVB	#-1,DXUWAT(R1)	;SAY WE ARE UMR STALLED
	TST	(SP)+		; DUMP THE SAVED R2
30$:	RETURN			; AND EXIT VIA RTI3

40$:	MOV	#ZERO,R2	;GET THE ADDRESS OF ZERO
	CLR	R1		; AND CLEAR THE MSB
	MOV	#2,DXECNT	;SET THE COUNT TO 2 BYTES (1 WORD)
50$:	MOV	R2,R4		;SAVE THE LSB OF THE MEMORY LOCATION
	MOV	R1,R5		; SET THE MSB OF MEM LOC
	ASH	#12.,R5		;SET IN THE PROPER EXT MEM ADDRESS BITS
	MOV	(SP)+,R1	;RESTORE R1
	MOV	(SP)+,R2	;  AND  R2
60$:	BIS	#FIL.DX,R5	;GET FUNCTION
	TSTB	DXOSTS(R1)	;IS THIS A DOUBLE DENSITY FUNCTION?
.ASSUME	DXODEN	EQ	200	;
	BPL	70$		;  SINGLE DENSITY, ALL SET FOR DMA
	BIS	#DXTDEN,R5	;SET THE DENSITY FLAG
70$:	MOV	R5,(R3)		;SET THE FUNCTION
	CALL	DXWAIT,R5,DXTRDY;WAIT FOR A XFER READY
	MOV	DXECNT,R5	;GET THE BYTE COUNT
	ASR	R5		; DIVIDE BY TWO FOR WORD COUNT
	MOV	R5,2(R3)	;SET IN COUNT FOR XFER
	CALL	DXWAIT,R5,DXTRDY;WAIT FOR CONTROLLER TO EAT THE WORD COUNT
	MOV	R4,2(R3)	;SET IN LSB FOR XFER
	CALL	DXWAIT,R5,DXTDNE; AND FINALLY WAIT FOR IT TO FINISH
	MOV	R1,R4		;TELL RELUMR OUR DDB (UNIQUE IDENTIFIER)
	CALL	@RELUMR		; AND RETURN THE UMR
	BR	110$		;AND SKIP PAST NON-DMA FILL

GLOBAL	<ZERO,RELUMR,GETUMR>

; NON-DMA FILL FUNCTION STARTS HERE

80$:	MOV	#FIL.DX,(R3)	;FUNCTION IS FILL SILO
90$:	CLR	R2		;CLEAR A LOC FOR BYTE
	CMP	R0,R4		;IS BYTE COUNT DOWN TO FILL POINT?
	BLOS	100$		; YES, FILL WITH NULL BYTE IN R2
	MOVB	(R5)+,R2	; NO, GET A BYTE FROM THE USER
100$:	CALL	DXWAIT,R5,DXTRDY ;TRANSFER READY MUST COME UP FROM LAST OP
	MOVB	R2,2(R3)	;SET IN NEXT BYTE FOR XFER
	SOB	R0,90$		; AND GET NEXT BYTE
	MOV	DXXRB(R1),R2	;RESTORE USER'S XRB ADDRESS
	CALL	DXWAIT,R5,DXTDNE ;NOW WE MUST HAVE TRANSFER DONE
	.BR	110$		; MERGE

; END OF FILL FUNCTION

110$:	MOV	DXBLOK(R1),R5	;GET THE SECTOR NUMBER
	CLR	R4		;CLEAR FOR DIVIDE
	DIV	#26.,R4		;COMPUTE TRACK AND SECTOR
	BIS	(R1),XRBUSE(R2)	;BLOCK MODE OR RECORD SAYS INTERLEAVE?
	BPL	120$		;NO
	CMP	#12.,R5		;YES, INTERLEAVE WITHIN TRACK
	ROL	R5		; SECTORS 0-12 => EVEN, 13.-25. => ODD
	ASL	R4		;SKEW THE SECTOR
	ADD	R4,R5		; BY TRACK
	ADD	R4,R5		;  TIMES
	ADD	R4,R5		;   SIX
	ASR	R4		;RESTORE THE TRACK NUMBER
	INC	R4		;OFFSET TRACK TO AVOID USING TRACK 0
120$:	SETERR	EOF,R0		;PRESET AN ERROR CODE
	CMP	R4,#77.		;TRACK IS BIGGER THAN MAXIMUM?
	BLO	130$		;   NO, CONTINUE ON
	CALLR	DXDONE		;   YES, EOF ERROR

130$:	BIS	#DXTIE,DXFUN(R1);SET THE INTERRUPT FOR FUNCTION COMPLETION
	MOV	DXFUN(R1),(R3)	;SET READ OR WRITE FUNCTION AND UNIT
	CALL	DXWAIT,R5,DXTRDY ;WAIT UNTIL IT TOOK IT
	MOV	R4,R0		;COPY THE TRACK NUMBER
	CLR	R4		;CLEAR FOR DIVIDE
	DIV	#26.,R4		;ENSURE THAT SECTOR NUMBER IS 0-25.
	INC	R5		; BUT USE 1.-26. FOR THE CONTROLLER
	MOV	R5,2(R3)	;SET THE SECTOR NUMBER
	CALL	DXWAIT,R5,DXTRDY ;WAIT UNTIL IT ATE IT
	MOV	R0,2(R3)	;SET THE TRACK NUMBER
	CLRB	DXERR(R1)	;ENSURE ERROR CODE IS OFF (NOT RETRYING)
140$:	MOV	#4,TIM.DX	;TIME OUT IN 4 SECONDS
	MOV	#160$-CONDSP,DXQRET(R1) ;WHEN DONE, RETURN HERE
150$:	RETURN			;TO MONITOR AT RTI3

160$:	SETERR	DATERR,R0	;PRESET USER DATA ERROR CODE
	MOV	DXSTS(R1),R5	;GET ERROR CODE. TIME OUT?
	BMI	DXEROR		;YES, LOG THE ERROR AND RETRY
	TST	DXCTL(R1)	;CONTROLLER ERROR?
	BPL	240$		;NOPE, CONTINUE WITH USER SERVICE
	TSTB	R5		;YES. IS THERE A DRIVE READY FOR US?
	BMI	170$		;YES, THE ERROR IS USER DATA ERROR

DXEROR:	SETERR	HNGDEV,R0	;SET HUNG DEVICE ERROR CODE
170$:	MOVB	R0,DXERR(R1)	;SAVE THE CODE IN THE DDB
	MOV	#DXEDMP,R5	;GET ADDRESS OF THE DUMP AREA
	BIT	#DXTRX2,(R3)	;CHECK FOR RX02 TYPE CONTROLLER
	BEQ	200$		; THIS IS AN RX01, DO NON-DMA RDE.DX

; DMA READ ERROR STATUS

	MOV	R1,R4		;TELL RELUMR OUR DDB (UNIQUE IDENTIFIER)
	CALL	@RELUMR		;RETURN IT
180$:	MOV	#RDE.DX,(R3)	;TELL RX211 TO DUMP ERROR STATUS
	CALL	DXWAIT,R5,DXTERR!DXTRDY!DXTDNE ;WAIT FOR A BIT TO APPEAR;001
	BPL	230$		; JUST IN CASE AN ERROR OCCURRED
	MOV	R5,2(R3)	;SET THE ADDRESS FOR THE DMA XFER
	CALL	DXWAIT,R5,DXTERR!DXTRDY!DXTDNE ;WAIT FOR A COMPLETION 	;001
						; OR AN ERROR
	MOV	(R5),DXSTS(R1)	;SAVE STATUS IN RX01 COMPATIBLE LOCATION
	BR	230$		;MERGE TO COMMON ERROR CODE

; NON-DMA ERROR STATUS

200$:	MOV	#RDE.DX,(R3)	;SET THE FUNCTION TO THE DRIVE
	ADD	#12.,R5		;ADD IN OFFSET TO TOP OF ERROR DUMP AREA
210$:	CLR	-(R5)		;CLEAR WORDS DOWN TO BEGINNING OF DUMP AREA
	CMP	#DXEDMP,R5	;  ARE WE TO THE BEGINNING OF THE DUMP AREA?
	BNE	210$		;    NO, CONTINUE THE CLEARING OPERATION
	CALL	DXWAIT,R5,DXTERR!DXTRDY!DXTDNE ;WAIT FOR COMPLETION NOW	;001
	MOV	2(R3),(R5)	;SAVE ERROR IN RX02 COMPATIBLE LOCATION
	.BR	230$		;MERGE TO COMMON ERROR CODE

; END OF ERROR STATUS

230$:	LOG$DX			;LOG THE ERROR
	DECB	DXRTRY(R1)	;ANY RETRIES LEFT?
	BGT	235$		; YES, RESUME PROCESSING
	CALLR	DXDONE		; NO, PUNT

235$:	MOV	#CLR.DX,(R3)	;YES, RECALIBRATE THE DX
	BIS	#CLR.DX,DXSTS(R1) ;RECALIBRATE DOES NOT GENERATE AN INTERRUPT.
				  ; SO, BY SETTING THIS FLAG THE TIME OUT
				  ; LOGIC WILL PRETEND AS IF AN INTERRUPT
				  ; HAD OCCURED.			;001
	BR	140$		;GO SET TIME OUT AND INTERRUPT ENABLE

GLOBAL	<TIM.DX,LOG$DX,RELUMR>

240$:	MOVB	DXERR(R1),R0	;INTERRUPT FROM RECALIBRATE?
	BEQ	250$		;   NO, CONTINUE ON
	CALLR	DXIORT		;   YES, CONTROLLER NOW CLEAR. RETRY I/O
250$:	;CLR	R0		;NO. SET ERROR CODE CLEARLY 0
	BIT	#2,DXFUN(R1)	;USER SERVICE COMPLETION. READ?
	BEQ	330$		;NOPE
260$:	CALL	DXJRES		;YES, FORCE JOB RESIDENCY
	BITB	#DXORX2,DXOSTS(R1);IS THIS A RX211?
	BEQ	290$		;NO - DO THINGS THE NON-DMA SLOW WAY

; DMA EMPTY STARTS HERE

	MOV	R2,-(SP)	; SAVE R2
	MOV	R1,-(SP)	;   AND R1
	MOV	R1,R4		;USE OUR DDB AS THE UNIQUE ID TO GETUMR
	MOVB	DXEMAM,R1	;GET THE HIGH BYTE OF THE ADDRESS
	MOV	DXEMAL,R2	;  AND THE LOW WORD
	NEG	R0		;MAKE BYTE COUNT INTO -(BYTE COUNT)
	ROR	R0		;MAKE -(BYTE COUNT) INTO -(WORD COUNT)
	SPLC	5		;BUMP UP PRIORITY
	CALL	@GETUMR		;; TRY TO GET THE UMR
	SPL	3		;;PRIORITY BACK DOWN
	BCC	270$		;IF SUCCESSFUL GO PROCESS SILO EMPTY
	MOV	(SP)+,R1	;RESTORE R1 (DDB POINTER)
	MOV	#260$-CONDSP,DXQRET(R1) ; SET THE RETURN POINTER
	MOVB	#-1,DXUWAT(R1)	;SAY WE ARE WAITING FOR A UMR
	TST	(SP)+		;JUNK SAVED R2
	RETURN			; RETURN THROUGH RTI3

270$:	MOV	R2,R4		;SAVE LSB OF MEMORY ADDRESS FOR DMA XFER
	MOV	R1,R5		;GET THE MSB
	ASH	#12.,R5		;SET MSB OF MEM LOC INTO PROPER EXT ADR BITS
	MOV	(SP)+,R1	;RESTORE THE DDB POINTER
	MOV	(SP)+,R2	;RESTORE R2
	BIS	#EMP.DX,R5	; AND OR IN THE EMPTY FUNCTION
	TSTB	DXOSTS(R1)	;CHECK FOR DENSITY BIT
.ASSUME	DXODEN	EQ	200	;
	BPL	280$		;  SINGLE DENSITY, ALL SET TO XFER
	BIS	#DXTDEN,R5	;SET THE DENSITY BIT
280$:	MOV	R5,(R3)		;SET THE FUNCTION
	CALL	DXWAIT,R5,DXTRDY;WAIT FOR XFER READY
	MOV	DXECNT,R5	;GET THE NUMBER OF BYTES
	ASR	R5		; DIVIDED BY TWO FOR WORD COUNT
	MOV	R5,2(R3)	;  AND SET IT IN FOR THE XFER
	CALL	DXWAIT,R5,DXTRDY;WAIT FOR AN XFER READY
	MOV	R4,2(R3)	; SET THE LSB OF THE ADDRESS
	CALL	DXWAIT,R5,DXTDNE;WAIT FOR A COMPLETION
	MOV	R1,R4		;TELL RELUMR OUR DDB (UNIQUE IDENTIFIER)
	CALL	@RELUMR		; AND GET RID OF THE UMR
	CLR	R0		;INSURE NO ERROR CODE
	BR	320$		;SKIP THE SLOW THINGS

; NON-DMA EMPTY STARTS HERE

290$:	MOV	#EMP.DX,(R3)	;FUNCTION IS EMPTY SILO
300$:	CALL	DXWAIT,R5,DXTRDY ;WAIT FOR TRANSFER READY
	MOVB	2(R3),-(SP)	;GET THE BYTE FROM THE SILO
	CMP	R0,R4		;IS BYTE COUNT DOWN TO FILL POINT?
	BLOS	310$		;YES, IGNORE IT
	MOVB	(SP),(R5)+	;MOVE THE BYTE TO THE USER
310$:	TST	(SP)+		;DUMP THE BYTE
	SOB	R0,300$		;DO ALL 128 BYTES
	;CLR	R0		;NO ERROR CODE
	CALL	DXWAIT,R5,DXTDNE ;NOW, TRANSFER DONE MUST BE UP
	.BR	320$		; MERGE

; END OF EMPTY

GLOBAL	<RELUMR,GETUMR>

320$:	ASLB	DXSTS(R1)	;DID WE READ A DELETED DATA MARK?
	BPL	330$		;NO
	SETERR	FMTERR,R0	;YES, SET FORMAT ERROR IN DDB
330$:	INC	DXBLOK(R1)	;NEXT SECTOR NUMBER NEXT TIME
	CMP	(R2)+,(R2)+	;POINT TO XRLOC
	MOV	#128.,R5	;CHANGES ARE BY SECTORS
	TSTB	DXOSTS(R1)	;IS THIS A DOUBLE DENSITY FLOPPY?
.ASSUME	DXODEN	EQ	200	;
	BPL	340$		;   NO  - LEAVE 128. SECTOR SIZE
	ASL	R5		;   YES - MAKE 256. SECTOR SIZE
340$:	ADD	R5,(R2)		;UPDATE BUFFER ADDRESS
	ADD	R5,-(R2)	;UPDATE AMOUNT READ/WRITTEN
	SUB	R5,-(R2)	;ONE SECTOR LESS TO DO
	BHI	360$		;MORE TO DO...
	ADD	(R2)+,(R2)	;DONE ACTUAL TRANSFER. FIX RETURNED COUNT
	CLR	-(R2)		;CORRECT XRB POINTER, WRITE ZERO-FILLER
	TST	(R1)		;ARE WE IN BLOCK MODE?
	BPL	DXDONE		;NO, NO MORE FILLER IF SECTOR MODE
	BIT	#2,DXFUN(R1)	;WRITING?
	BNE	DXDONE		;IF READING, NO NEED TO FILL
	MOV	#3,R5		;ASSUME WE ARE SINGLE DENSITY
	TSTB	DXOSTS(R1)	;ARE WE?
.ASSUME	DXODEN	EQ	200	;
	BPL	350$		; NO, SO WE WERE RIGHT
	ASR	R5		; YES, SO BLOCK MODE IS 2 SECTORS
350$:	BIT	R5,DXBLOK(R1)	;NEXT SECTOR ON BLOCK BOUNDARY?
	BEQ	DXDONE		;IF SO, DONE FILLING EVERYTHING
360$:	TSTB	R0		;ANY ERROR?
	BNE	DXDONE		;YES, EXIT TO USER WITH ERROR
	CALLR	DXSTRT		;ELSE CONTINUE WITH A NEW SECTOR

DXDONE:	CALLX	IOFINI,R5,JS.DX	;POST DX DRIVER COMPLETION (R4 <- JOB *2)
	MOV	JOBTBL(R4),R5	;GET POINTER TO JDB
	MOVB	R0,JDIOST(R5)	;GIVE HIM AN ERROR CODE TO POST
	BNE	370$		;USE THE FLOPPY ERROR, IF ANY
	BIT	#JFCC,JDFLG(R5)	;NO ERROR, BUT DID HE HIT ^C ?
	BEQ	370$		;NOPE
	SETERR	CTRLCE,JDIOST(R5) ;YES, GIVE HIM THAT ERROR
370$:	TST	(R1)		;BLOCK MODE?
	BPL	390$		;NO
	MOV	#3,R5		;ASSUME WE ARE SINGLE DENSITY
	TSTB	DXOSTS(R1)	;ARE WE?
.ASSUME	DXODEN	EQ	200	;
	BPL	380$		; YES, WE ARE RIGHT
	ASR	R5		; NO, WE ARE WRONG, ADJUST TO 2 DEN
380$:	ADD	R5,DXBLOK(R1)	;YES, ROUND UP TO NEXT MULTIPLE OF 4/DENSITY
	ASR	DXBLOK(R1)	; SECTORS, AND COMPUTE THE TRUE BLOCK NUMBER
	TSTB	DXOSTS(R1)	;ARE WE DOUBLE DENSITY?
.ASSUME	DXODEN	EQ	200	;
	BMI	390$		; YES, SO NEXT ASR IS TOTALLY UNNEEDED
	ASR	DXBLOK(R1)	;  ONE MORE ASR FOR SINGLE DENSITY (4 SEC/BLK)
390$:	MOV	DXQPTR(R1),DXQUE ;DEQUEUE THIS REQUEST
	BEQ	400$		;NO MORE
SETQDX:	L3QSET	QDXCON		;SIGNAL IT TO RUN
400$:	RETURN			;BACK TO RTI3

.DSABL	LSB

GLOBAL	<JS.DX,JOBTBL>

.SBTTL	FORCE JOB RESIDENCY FOR DX DRIVER

.ENABL	LSB

DXJRES:	MOVB	DDJBNO(R1),R0	;GET THE JOB NUMBER * 2
	MOV	(PC)+,R3 	;SIGNAL CONTINUATION IF STALLED ;002
	 .L3Q	 QDXCON						;002
	MOV	XRLOC(R2),R5	;GET USER BUFFER ADDRESS
	CALLX	FNDJOB		;FIND THE JOB
	 BR	40$		;ERROR IN RESIDENCY
	BCC	10$		;GOT IT
	SUB	#CONDSP+4,(SP)	;MAKE RELATIVE, BACK UP TO CALL AGAIN
	MOV	(SP)+,DXQRET(R1) ;RETURN TO CALL US WHEN RESIDENT
	RETURN			;TO RTI3

10$:	MOVB	R2,DXEMAM	; SAVE MSB OF ADDRESS
	MOV	R3,DXEMAL	;   AND LSB
	CALLX	UNLOCK		;UNLOCK THE JOB
	MOV	JOBTBL(R0),R1	;GET JDB AND
	CALLX	CLRRSQ		; CLEAR ANY RESIDENCY QUANTUM
	CALL	SETDX		;RESTORE THE STANDARD REGISTERS
	MOV	#128.,R0	;RETURN A HANDY COUNT IN R0
	TSTB	DXOSTS(R1)	;CHECK FOR DOUBLE DENSITY FLOPPY
.ASSUME	DXODEN	EQ	200	;
	BPL	20$		; SINGLE DENSITY - PUNT
	ASL	R0		; DOUBLE DENSITY - SET 256. SECTOR SIZE
20$:	MOV	R0,R4		;SET TO COMPUTE 128.(256.) - (BYTE COUNT)
	MOV	R0,DXECNT	;AND SET THE BYTE COUNT
	SUB	(R2),R4		;SUBTRACT THE USER COUNT LEFT
	BHIS	30$		;IF HIS COUNT IS <= 128(256.), OK
	CLR	R4		; ELSE FILL POINT IS 0 FOR FULL SECTOR
30$:	SUB	R4,DXECNT	;ADJUST XFER CNT FOR NUMBER OF FILL CHARACTERS
	RETURN			;BACK WITH JOB RESIDENT

40$:	MOV	#DXDONE,(SP)	;ERROR IN RESIDENCY. REROUTE TO EXIT
SETDX:	MOV	DXQUE,R1	;POINT TO THE DRIVER QUEUE
	BEQ	50$		;IF NOTHING, RETURN WITH Z=1
	SUB	#DXQPTR,R1	;POINT TO START OF DDB
	MOV	DXXRB(R1),R2	;USE R2 AS XRB POINTER
	MOVB	DDUNT(R1),R3	;GET THE UNIT NUMBER
	ASL	R3		; TIMES 2
	MOV	CSR.DX(R3),R3	;NOW GET THIS UNIT'S CSR
	;CLZ			; WHICH CANNOT BE NULL
50$:	RETURN


.DSABL	LSB

GLOBAL	<JOBTBL,CSR.DX>

.SBTTL	WAIT FOR TRANSFER READY

.ENABL	LSB

;+
; DXWAIT - WAIT FOR TRASFER READY(TR), DONE
;
; THIS ROUTINE WILL WAIT FOR TRANSFER READY OR DONE TO BE SET.
;
; *  IF ONE OF THESE BITS IS NOT SET WITHIN 2 SECONDS, THE ERROR BIT IS
;    ASSUMED.
; *  IF THE ERROR BIT IS SPECIFIED AS INPUT TO THIS SUBROUTINE, ERROR RETURN
;    IS TO USER.  OTHERWISE, EXIT IS THROUGH 20$
;
; INPUT:	R5 POINTS TO BIT MASK TO TEST FOR
;
; OUTPUT:	DONE BIT SET, N BIT IN STATUS WORD = 0
;		TRANSFER READY SET, N BIT IN STATUS WORD = 1 
;
; ALL REGISTERS PRESERVED
;
;-
DXWAIT:	CLR	-(SP)		;MAKE ROOM FOR TIME SAVE AREA ON STACK
	MOVB	TIMSEC,(SP)	;SAVE CURRENT TIME ON STACK
1$:	BITB	(R3),#DXTRDY!DXTDNE ;TR/DONE ON?
	BNE	3$		;YES
;
	MOV	(SP),-(SP)	;TEMP SAVE SECONDS AT ENTRY
	CLR	-(SP)		;MAKE ROOM FOR CURRENT SEC
	MOVB	TIMSEC,(SP)	;PUT CURRENT SEC ON STACK
	SUB	(SP)+,(SP)	;COMPUTE # OF SECONDS WAITED
	BGE	2$		;POS. MEANS, WE ARE IN MINUTE OF ENTRY
	ADD	#60.,(SP)	;NEG. MEANS, WE ARE IN NEXT MINUTE FROM ENTRY
2$:
	CMP	(SP)+,#2	;FULL 2 SECONDS ELLAPSED?
	BLOS	1$		;NO
3$:
	TST	(SP)+		;CLEAN STACK
	BITB	(R3),#DXTRDY!DXTDNE ;TR/DONE SET?
	BMI	4$		;TR SET
	BEQ	5$		;TR/DONE NOT SET
	BIT	(R3),#DXTERR	;DONE SET, CHECK ERROR BIT?
	BNE	5$		;ERROR, CHECK WHERE TO RETURN TO
4$:	BITB	(R5),(R3)	;DID WHAT WE WANT COME UP?
	BNE	6$		;YES
5$:	BIT	(R5),#DXTERR	;RETURN TO CALLER ON ERROR?
	BEQ	20$		;NO
6$:	TST	(R5)+		;POINT TO RETURN ADDRESS
	BITB	-2(R5),(R3)	;SET/RESET 'N' BIT IN PS
	RETURN	R5		;RETURN TO CALLER


20$:	CALL	DXSREG		;SAVE REGISTERS IN DDB
	MOV	(SP)+,R5	;POP RETURN ADDRESS
	CALLR	DXEROR		; AND GO TO ERROR HANDLER

.SBTTL	CONTINUE DISKETTE INITIALIZATION

DXINIT:	MOV	#DXINI0-CONDSP,DXQRET(R1);SET RETURN ON INT. OR TMO
	CLR	DXRTRY(R1)	;NO RETRIES ON ERRORS
	MOV	#30.,TIM.DX	;SET TIMEOUT AT 30 SECONDS
	MOV	DXFUN(R1),(R3)	;START THE DRIVE ON ITS WAY
	CALL	DXWAIT,R5,DXTRDY;WAIT FOR AN XFER READY
	MOV	#'I,2(R3)	;GIVE IT THE SECRET ASCII 'I'
	RETURN			;TO RTI3 AND LET RSTS DO SOMETHING ELSE

DXINI0:	BICB	#DXOSET,DXOSTS(R1);SAY NO I/O DONE ON NEW DISKETTE
	CLR	DXBLOK(R1)	;AND NO BLOCKS WRITTEN/READ
	CLR	R0		;SET ERROR CODE TO ZERO (NO ERROR)
	TST	DXSTS(R1)	;WAS THERE AN INT OR A TMO
	BMI	30$		;TIMEOUT - MUST BE AN ERROR
	TST	DXCTL(R1)	;WAS THERE AN ERROR?
	BMI	30$		; YES, DO THE ERROR PROCESSING	
	CALLR	DXDONE		; NO, WE ARE FINISHED

30$:	CALLR	DXEROR		;CALL ERROR PROCESSING

GLOBAL	<RTI3,TIM.DX>

.SBTTL	SET DX OPEN STATUS FOR RX211 CONTROLLERS
DXSETR:	CLR	DXRTRY(R1)	;NO RETRY FOR THIS OPERATION
	MOV	#RDS.DX!DXTIE,R5;GET THE STATUS, INT. WHEN DONE
	BITB	#1,DDUNT(R1)	;TEST FOR AN ODD UNIT
	BEQ	40$		;EVEN UNIT - SKIP UNIT 1 SELECT
	BIS	#DXTUN1,R5	;SET THE UNIT SELECT
40$:	MOV	#60$-CONDSP,DXQRET(R1); SET A RETURN ADDRESS
	MOV	#4,TIM.DX	; SET A TIMEOUT IN 4 SECONDS
	MOV	R5,(R3)		; START THE FUNCTION
50$:	RETURN			;RETURN TO RTI3

60$:	MOV	DXSTS(R1),R5	;GET ERROR CODE
	BPL	70$		;IF NO ERROR, GO FIND STATUS BITS
	CALLR	DXEROR		;   ELSE LET THE ERROR HANDLER TAKE OVER

70$:	MOVB	DXOSTS(R1),R4	; COPY THE OPEN STATUS
	BICB	#^C<DXORX2!DXOBLK>,R4; MAKE SURE ALMOST NOTHING IS LEFT
	BIT	#RXEDEN,R5	;CHECK FOR DENSITY
	BEQ	90$		;  SINGLE, LEAVE BIT OFF
	BISB	#DXODEN,R4	;DOUBLE DENSITY
90$:	BISB	#DXOSET,R4	;STATUS HAS NOW BEEN PROPERLY SET
	MOV	DX2RET(R1),DXQRET(R1);SET THE RETURN ADDRESS
	MOVB	R4,DXOSTS(R1)	;RECORD THE NEW STATUS VALUE
	CALLR	SETQDX		;REQUEUE FUNCTION (LET IT RETURN FOR US)

.DSABL	LSB

GLOBAL	<TIM.DX>

.END
