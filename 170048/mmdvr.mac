	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
	.INCLUDE /CMN:MTDEF/
TITLE	MMDVR,<MASSBUS MAGTAPE I/O SERVICE>,0A,10-MAY-91,MHB/JDM/SJK/AJK/SRM/KCG/FRL/TWH/DBM/KPH/VAM

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR MMDVR
;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;
;  001  AJK  16-JUN-81  ON A BACKSPACE, INCORRECT RETURN VALUE WAS
;			RETURNED IF DRIVE ALREADY AT BOT.
;  002	SRM  15-Nov-81	Change the TMPORG into BUFCTL to reflect
;			the BUFCTL changes for FIP Pool.
;  003	KCG  26-Jul-82	Source clear patch 3.7.7 from 7.2.  Done under
;			the DNE$MM:: symbol.
;
;				[RSTS V9.0]
;  004  FRL  25-Oct-83  Added level three queue (L3Q) extension capability
;  005	TWH  28-MAR-84	Add new spec function for EOV and EOV processing
;  006	DBM  01-May-84	Finish up EOV processing and add ECA spec
;  007	DBM  10-Jul-84	Add 'true' ECA support
;  008	DBM  09-Aug-84	Fix a bug in EOV processing
;  009	DBM  28-Aug-84	Don't go into error condition state if in INIT
;  010	DBM  06-Sep-84	Only give NOROOM error on writes
;  011	KPH  11-Sep-84	Move to MVR phase
;  012	KPH  03-Jan-85	Add density sensing for TM02
;  013	KPH  21-Jan-85	Don't allow density setting unless at BOT
;
;				[RSTS V9.1]
;  014  VAM  22-Apr-85	Add Extended Set Density .SPEC function.
;  015  VAM  03-Sep-85	Fix bugs in Extended Set Density function (grumble!!)
;
;				[RSTS V9.2]
;  016  KPH  16-Aug-85	Add job control region
;  017	DBM  09-Oct-85	Fix MTU request handling for ECA, move EOV with it.
;
;				[RSTS V9.3]
;  018	DBM  07-Nov-86	Check density after read interrupts for density sensing
;-

	DEFORG	MMDVRM

	INCLUDE	ERLDVR

.SBTTL	RH11/TM02-3/TU16/TE16 HARDWARE DEFINITIONS

; REGISTER OFFSETS

.DSECT

RHCS1:	.BLKW		;RH11 CONTROL STATUS #1 (CSR)
RHWC:	.BLKW		;RH11 WORD COUNT
RHBA:	.BLKW		;RH11 BUS ADDRESS BITS <15-0>
MMFC:	.BLKW		;TM02-3 FRAME COUNTER
RHCS2:	.BLKW		;RH11 CONTROL STATUS #2
RHDS:	.BLKW		;RH11 DRIVE STATUS
RHER:	.BLKW		;RH11 ERROR REGISTER (#1)
RHAS:	.BLKW		;RH11 ATTN SUMMARY
	.BLKW		;CHECK/CRC
	.BLKW		;DATA BUFFER
RHMR:	.BLKW		;MAINTENANCE
RHDT:	.BLKW		;RH11 DRIVE TYPE
	.BLKW		;SERIAL NUMBER
MMTC:	.BLKW		;TM02-3 TAPE CONTROL

.BSECT	HIGH		;BIT ASSIGNMENTS IN RHCS1

	.BLKB	.	;BUS ADDRESS BIT <16>
	.BLKB	.	;BUS ADDRESS BIT <17>
	.BLKB	.	;PORT SELECT
	.BLKB	.	;DRIVE AVAILABLE (IN DRIVE)
	.BLKB	.	;RESERVED (IN DRIVE)
RHMCPE:	.BLKB	.	;MASSBUS CONTROL PARITY ERROR
RHTRE:	.BLKB	.	;COMPOSITE TRANSFER ERROR
RHSC:	.BLKB	.	;COMPOSITE SPECIAL CONDITION

.BSECT			;BIT ASSIGNMENTS IN RHCS2

	.BLKB	.	;UNIT SELECT BIT <0>
	.BLKB	.	;UNIT SELECT BIT <1>
	.BLKB	.	;UNIT SELECT BIT <2>
	.BLKB	.	;BUS ADDRESS INCREMENT INHIBIT
	.BLKB	.	;PARITY TEST
RHCLR:	.BLKB	.	;RH11 MASTER CLEAR
	.BLKB	.	;INPUT READY
	.BLKB	.	;OUTPUT READY
RHMDPE:	.BLKB	.	;MASSBUS DATA PARITY ERROR
RHMXF:	.BLKB	.	;MISSED TRANSFER
RHPGE:	.BLKB	.	;PROGRAM ERROR
RHNEM:	.BLKB	.	;NON-EXISTENT MEMORY
RHNED:	.BLKB	.	;NON-EXISTENT DRIVE
RHPE:	.BLKB	.	;MEMORY BUS PARITY ERROR
	.BLKB	.	;WRITE CHECK ERROR
RHDLT:	.BLKB	.	;DATA LATE ON MEMORY BUS

.BSECT			;BIT ASSIGNMENTS IN RHDS

	.BLKB	.	;SLAVE ATTN
MMBOT:	.BLKB	.	;BEGINNING OF TAPE
MMEOF:	.BLKB	.	;END OF FILE (TAPE MARK)
	.BLKB	.	;ID BURST
MMSDN:	.BLKB	.	;SLOWING DOWN
MMPES:	.BLKB	.	;PHASE ENCODED STATUS
	.BLKB	.	;SLAVE STATUS CHANGE
RHDRY:	.BLKB	.	;DRIVE READY
RHDPR:	.BLKB	.	;DRIVE PRESENT
	.BLKB	.	;UNUSED
MTEOT:	.BLKB	.	;END OF TAPE
RHWRL:	.BLKB	.	;WRITE LOCKED
RHMOL:	.BLKB	.	;MEDIUM ON-LINE
RHPIP:	.BLKB	.	;POSITIONING IN PROGRESS
RHERR:	.BLKB	.	;COMPOSITE DRIVE ERROR
RHATA:	.BLKB	.	;ATTN ACTIVE

.BSECT			;BIT ASSIGNMENTS IN RHER

RHILF:	.BLKB	.	;ILLEGAL FUNCTION
RHILR:	.BLKB	.	;ILLEGAL REGISTER
RHRMR:	.BLKB	.	;REGISTER MODIFICATION REFUSED
MMCPAR:	.BLKB	.	;PARITY ERROR ON CONTROL BUS
MMFMT:	.BLKB	.	;FORMAT ERROR
MMDPAR:	.BLKB	.	;PARITY ERROR ON DATA BUS
MMINC:	.BLKB	.	;INCORRECTABLE DATA ERROR/VPE
MMPEF:	.BLKB	.	;FORMAT ERROR/LRC
MMBTE:	.BLKB	.	;NON-STANDARD GAP
MMFCE:	.BLKB	.	;FRAME COUNT ERROR
MMCS:	.BLKB	.	;CORRECTABLE SKEW/ILLEGAL TAPE MARK
MMNEF:	.BLKB	.	;NON-EXECUTABLE FUNCTION
RHDTE:	.BLKB	.	;DRIVE TIMING ERROR
RHOPI:	.BLKB	.	;OPERATION IMCOMPLETE
RHUNS:	.BLKB	.	;UNSAFE
MMCOR:	.BLKB	.	;CORRECTABLE DATA ERROR/CRC ERROR

.BSECT	HIGH		;BIT ASSIGNMENTS IN RHDT

	.BLKB	.	;BIT <8> OF DRIVE CODE (0)
	.BLKB	.	;RESERVED (0)
RHSPR:	.BLKB	.	;SLAVE PRESENT (1)
RHDRQ:	.BLKB	.	;DRIVE REQUEST REQUIRED (DUAL PORT) (0)
RH7CH:	.BLKB	.	;7-CHANNELS (0)
RHMOH:	.BLKB	.	;MOVING HEADS (0)
RHTAP:	.BLKB	.	;TAPE (1)
RHNSA:	.BLKB	.	;NOT SECTOR ADDRESSABLE (1)

; BIT ASSIGNMENTS IN "MMAINF"

.BSECT

MT$TRY:	.BLKB	.	;RETRYABLE REQUEST
MT$NIN:	.BLKB	.	;NO INTERRUPT REALLY OCCURED
MT$LCK:	.BLKB	.	;JOB IS LOCKED INTO MEMORY
MT$ERS:	.BLKB	.	;CURRENTLY ERASEING
MT$BAK:	.BLKB	.	;DOING BACKSPACE FOR RETRY
MT$REQ:	.BLKB	.	;PROCESSING A REQUEST
MT$BSY:	.BLKB	.	;CONTROL IS BUSY
MT$INT:	.BLKB	.	;EXPECTING AN INTERRUPT

	UNORG

.SBTTL	DEVICE ASSIGNMENT SERVICE

.ENABL	LSB								;014
;+
; ASN$MM - DEVICE ASSIGNMENT SERVICE FOR MAGTAPE.
;
;	R0 =  JOB NUMBER OF ASSIGNER TIMES 2
;	R1 -> DDB
;
;	...
;
;	RETURN		(WITH ALL REGISTERS PRESERVED)
;-

	TMPORG	MMDINT,32						;011
	 .WORD	ASN$MM							;011
	 UNORG								;011

ASN$MM:	DEC	TIM.MM		;START ONCE A SECOND TIMEOUTS		;011
	MOV	#MMAPTR,MTRPTR+MTDDSP(R1) ;SET THE ROOT POINTER IN DDB	;011
	MOVB	MAGLBL,MTLBLI+MTDDSP(R1) ;SET LABELING DEFAULT
;+
;	Here, we get the system default density and use VERDEN to convert it
;	to a legal density (800 or 1600).  Upon return, R5 will contain either
;	800. (1440 octal) or 1600. (3100 octal).  We then shift the bottom byte
;	of R5 left one bit to determine what value was returned; if R5 was
;	1600., this action will make the bottom byte negative, and if R5 was
;	800. it will remain positive after the shift.
;-
	PUSH	R5				;Get us a work register	;014
	MOV	TAPDEN,R5			;Get default parity.	;014
	CALL	VERDEN				;Make sure it's OK.	;014
	BICB	#MT.DEN,MTFLAG+MTDDSP(R1)	;Start by assuming 1600.;014
	ASLB	R5				;Is it really 1600?	;014
	BMI	10$				;Yup.			;014
	BISB	#MT.DEN,MTFLAG+MTDDSP(R1)	;Otherwise, make it 800.;014
10$:	;BICB	#MT.ECK,MTFLAG+MTDDSP(R1) ;CLEAR ERROR CHECK STATE	;007
	POP	R5				;Leave all as it was.	;014
	RETURN			;NOW EXIT

.SBTTL	DEVICE DEASSIGNMENT SERVICE

;+
; DEA$MM - DEVICE DEASSIGNMENT SERVICE FOR MAGTAPE.
;
;	R1 -> DDB
;
;	...
;
;	RETURN		(WITH ALL REGISTERS PRESERVED)
;-

	TMPORG	MMDINT,36						;011
	 .WORD	DEA$MM							;011
	 UNORG								;011

DEA$MM:	INC	TIM.MM		;END ONCE A SECOND TIMEOUTS		;011
	RETURN			; AND EXIT

GLOBAL	<TIM.MM,MAGLBL,TAPDEN,MMAPTR>					;011

.SBTTL	ONCE A SECOND ENTRY POINT (TIMEOUTS)

.ENABL	LSB

	TMPORG	MMDINT,22						;011
	 .WORD	TMO$MM							;011
	 UNORG								;011

TMO$MM:	MOV	#MMADRW,R2	;;PTR TO: DRW, INF, TIM, SFC		;011
	MOVB	#-1,(R2)+	;;DO REWINDERS NEXT TIME PLEASE
	L3QSET	QMMCON		;; AND SIGNAL CODE TO DO IT
	BIT	(PC)+,(R2)+	;;WAITING FOR A TIME OUT?
	 .BYTE	MT$INT,200	;;IF SO, COUNT >= 0 AND INTERRUPT EXPECTED
;.ASSUME MMATIM	EQ MMAINF+1	;;TIMEOUT IS HIGH BYTE			;011
	BLE	20$		;;NOPE
	MOV	(R2),R5		;;YES, SNAG SAVED "MTABRC"
	MOV	MMFC(R3),(R2)	;;UPDATE SAVED VERSION TO CURRENT
	CMP	R5,(R2)		;;FIND THE DIFFERENCE
	BNE	20$		;;THEY ARE DIFFERING, SO DON'T TIMEOUT NOW
	DECB	-(R2)		;;SAME, TIMED OUT?
	BPL	20$		;;NOT YET
	LOG$MM			;;WHOOPS, LOG THE ERROR
	MOV	#RHCLR,RHCS2(R3) ;;THEN CLEAR OUT EVERYTHING
10$:	BICB	#MT$INT!MT$NIN,MMAINF ;;SAY AN INTERRUPT OCCURED	;011
	L3QSET	QMMDNE		;;CALL COMPLETION CODE
20$:	RETURN			;;NOW EXIT

.SBTTL	PROCESS INTERRUPTS (PR5)

	TMPORG	MMDINT,6						;011
	 .WORD	INT$MM							;011
	 UNORG								;011

INT$MM::TSTB	MMAINF		;;EXPECTING THIS INTERRUPT?
	BPL	20$		;;NO, SO JUST EXIT
	MOV	CSR.MM,R3	;;YES, GET CSR POINTER
	BIT	#1,(R3)		;;COMMAND REALLY FINISHED??
	BEQ	10$		;;ALL DONE IF SO
	MOVB	RHAS(R3),R0	;;ELSE GET THE ATTN LINE SUMMARY
	BEQ	10$		;;NOTHING ON, TAKE THE INTERRUPT
	MOV	#BITBYT,R1	;;GET BIT TO BYTE CONVERSION TABLE
30$:	BITB	R0,(R1)+	;;A MATCH?
	BEQ	30$		;;NO, LOOP FOR A MATCH
	MOVB	-(R1),R0	;;A MATCH, GET THE SINGLE BIT
	SUB	#BITBYT,R1	;;FIND THE MASSBUS UNIT NUMBER
	MOV	RHCS2(R3),R2	;;GET CURRENT MASSBUS UNIT NUMBER
	BIC	#^C<7>,R2	;; AND ISOLATE IT
	CMP	R1,R2		;;SAME UNIT??
	BEQ	10$		;;YES, TAKE THE INTERRUPT
	MOVB	R1,RHCS2(R3)	;;DIFFERENT, SELECT THE ATTN UNIT
	MOVB	#IE,(R3)	;; AND RE-INTERRUPT ENABLE THE RH11
	MOV	R0,RHAS(R3)	;;  AND TURN OFF THE ATTN LINE OF UNIT
	MOVB	R2,RHCS2(R3)	;;NOW BACK TO ORIGINAL UNIT
	RETURN			;; AND WAIT FOR ANOTHER INTERRUPT

.DSABL	LSB

GLOBAL	<LOG$MM,CSR.MM,BITBYT,IE,MMADRW,MMAINF,MMATIM>			;011

.SBTTL	LOG MAGTAPE ERRORS

	TMPORG	MMDINT,12						;011
	 .WORD	ERL$MM							;011
	 UNORG								;011

ERL$MM:	MOV	MMAQUE,R4	;;;GET THE (BIASED) DDB ADDRESS		;011
	MOV	R4,R1		;;;COPY THE (BIASED) DDB ADDRESS
	SUB	#MTDDSP,R1	;;; TO GET REAL DDB POINTER
	MOV	CSR.MM,R3	;;;ALSO GET THE CSR POINTER
	CALLX	ERLDVR,R5	;;;USE COMMON ROUTINE
	  .BYTE	ERC$MM		;;;ERROR CODE
	  .BYTE	DDS.MM		;;;DDB SIZE IN BYTES
	  .BYTE	RHCS1,9.	;;;OFFSET, 9. REGISTERS
	  .BYTE	RHMR,4		;;;OFFSET, 4 REGISTERS
	  .BYTE	0,0		;;;THAT'S ALL
	TSTB	MMATIM		;;;TIMEOUT?				;011
	BPL	10$		;;;NO
	COMB	(R0)		;;;YES, INDICATE TIMEOUT
10$:	MOV	MTACB(R4),(R1)	;;;SET ACB POINTER (IF ANY)
	BEQ	20$		;;;NONE
	MOV	#2*400+16.,-(R1) ;;;ONE, SAY 16. WORDS OF FIELD 2
20$:	RETURN			;;;BACK TO ERROR LOGGER

GLOBAL	<CSR.MM,DDS.MM,MMAQUE,MMATIM>					;011

.SBTTL	MAGTAPE UNIT SELECT (AND VERIFY) ROUTINES

.ENABL	LSB

MTASEE:	MOV	#80$,R5		;SET THE RETURN FOR "RETURN R5"
MTASEL:	MOVB	MTOFLG(R4),R0	;GET DENSITY/PARITY/UNIT
	BIC	#^C<MT.DEN!MT.PAR!MT.UNT>,R0 ;TRIM TO ONLY THOSE VALUES
	BIT	R0,#MT.DEN	;800 BPI NRZ OR 1600 BPI PE MODE?
	BNE	10$		;USER WANTS 800 BPI NRZ
	ADD	#1140,R0	;USER WANTS 1600 BPI PE
10$:	ADD	#1140,R0	;MAGIC ADD FOR CORRECT BIT PATTERN
				;MT.DEN+MT.PAR+EXTRA+MAGIC=RESULT
				;    0 +   0  + 1140+ 1140=2300 (1600 PE)
				;  140 +   0  +    0+ 1140=1300 (800 NRZ,ODD)
				;  140 +  10  +    0+ 1140=1310 (800 NRZ,EVEN)
20$:	MOV	CSR.MM,R3	;GET THE CSR POINTER
	ADD	#RHDS,R3	; AND INDEX TO DRIVE STATUS
	MOVB	MTTM02(R4),RHCS2-RHDS(R3) ;SELECT THE CORRECT TM02-3 UNIT
	MOV	R0,MMTC-RHDS(R3) ;SELECT UNIT AND SET DEN/FMT/PARITY
	MOV	#RHTRE,RHCS1-RHDS(R3) ;CLEAR CONTROLLER
	;CLC			;C=0 FROM 'ADD' ABOVE
	ADC	RHAS-RHDS(R3)	;ALSO CLEAR ALL ATTN LINES
	MOV	RHDT-RHDS(R3),-(SP) ;GET THE DRIVE TYPE
	BIC	#47,(SP)	; AND CLEAR TM03 AND SLAVE TYPE BITS
	CMP	(SP)+,#RHNSA!RHTAP!RHSPR!10 ;REALLY THE CORRECT DRIVE TYPE?
	BNE	70$		;NO, SO SELECTION FAILURE, EXIT C=1
	BIT	#RHMOL,(R3)	;MEDIUM ON-LINE?
	BEQ	70$		;NO, SO SELECT ERROR, EXIT C=1
	BIT	#RHPIP,(R3)	;IS DRIVE REWINDING?
	BNE	30$		;YES, O.K., BUT DON'T ISSUE ANY COMMAND TO IT
	BIT	#RHDRY!MMSDN,(R3) ;ELSE IS IT READY OR SETTLING DOWN??
	BEQ	70$		;NEITHER, SO SELECT ERROR, EXIT C=1
	MOV	#RHTRE!11,RHCS1-RHDS(R3) ;NOW CLEAR CONTROL AND THE DRIVE
30$:	CMP	R0,#2300	;SET C=0 IF 1600 PE ('BHIS'='BCC')
	BIT	#MMPES,(R3)	;IS THE SELECTED DRIVE AT 1600 PE??
	BEQ	50$		;NOPE, SELECTED DRIVE IS AT 800 NRZ
	BCC	60$		;O.K. IF DEN=1600(C=0) & DRIVE=1600(Z=0)
	ADD	#2000,R0	;MAKE 800 (13XU) INTO 1600 (230U)
40$:	SUB	#1000,R0	;MAKE 1600(230U) INTO 800(130U)
	BIC	#^C<3307>,R0	;ENSURE THE EXTRA BIT(S) ARE OFF
	BR	20$		; AND GO TRY AGAIN...

50$:	BCC	40$		;WRONG IF DEN=1600(C=0) & DRIVE=800(Z=1)
60$:	TST	(PC)+		;O.K., SET C=0 (AND SKIP THE 'SEC')
70$:	SEC			;BAD, INDICATE SELECT ERROR (C=1)
	RETURN	R5		;EXIT WITH C-BIT INDICATION

80$:	BCC	90$		;ALL O.K.
	SETERR	MAGSEL,MTLCEV(R4) ;SELECT ERROR, SET ERROR CODE
	MOV	#MTASVT,R5	; AND RETURN TO STATUS SAVER
90$:	JMP	(R5)		;NOW EXIT

.DSABL	LSB

GLOBAL	<CSR.MM>

.SBTTL	SPECIAL FUNCTION SERVICE

;+
; SPC$MM - SPECIAL FUNCTION SERVICE FOR MAGTAPE.
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB/FCB
;	R2 =  SPECIAL FUNCTION CODE
;	R3 -> XRB
;	R4 =  CALLING JOB NUMBER TIMES 2
;	R5 -> (MAPPED) XRB
;
;	...
;
;	JMP	RTI3
;
;	-OR-
;
;	ERROR	CODE
;-

.ENABL	LSB

	TMPORG	MMDINT,26						;011
	 .WORD	SPC$MM							;011
	 UNORG								;011

SPC$MM:	CMP	R2,#<GBF.MT-1>-2;IS FUNCTION IN CORRECT RANGE?		;011
.ASSUME	<XDN.MT+1> EQ GBF.MT						;014
	BLOS	7$		;YES, SO GO SET UP PARAMETERS
5$:	ERROR	NOTMTA		;ELSE ERROR

7$:	TST	R2		;REWIND OFFLINE? (CODE 0)		;006
	BEQ	8$		;YES - SO LEAVE IT ALONE		;006
	CMPB	(R2)+,(R2)+	;ELSE ADD 2 TO CODE (CHEAPLY)
8$:	BITB	#MT.ECK,MTFLAG+MTDDSP(R1)	;ARE WE WAITING FOR AN ECA? ;007
	BEQ	10$		;NOPE.  GO AHEAD			;017
	CMP	R2,#ECA.MT	;YES, THIS HAD BETTER BE THE ECA	;007
	BEQ	10$		;IT IS, FANTASTIC!			;007
	ERROR	HNGDEV		;SET HUNG DEVICE ERROR AND WAIT FOR ECA	;007

10$:	BIS	#JFPOST,@JOBF	;BE SURE USER GETS RETURNED VALUE	;017
	ADD	#MTCNT+MTDDSP,R1 ;INDEX INTO DDB AWAYS
	CLR	JBSTAT(R4)	;PUT JOB IN A STALL CONDITION
	MOV	#JS.MM,JBWAIT(R4) ; ON MAGTAPE COMPLETION
	MOV	XRBC(R3),(R1)+	; AND SET THE FUNCTION'S COUNT
	BR	40$		; AND CONTINUE

GLOBAL	<JBSTAT,JS.MM,JBWAIT>

.SBTTL	USER LEVEL SERVICE

;+
; SER$MM - USER LEVEL READ/WRITE SERVICE.
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB/FCB
;	R2 =  2 (.READ)
;	      4 (.WRITE)
;	R3 -> XRB
;	R4 =  CALLING JOB NUMBER TIMES 2
;	R5 -> USER'S BUFFER (THROUGH KISAR6)
;	IF Z=1 OR C=0 THEN THIS IS THE FIRST CALL
;	IF Z=0 OR C=1 THEN THIS IS A "REDO" CALL
;-

	TMPORG	MMDINT,16						;011
	 .WORD	SER$MM							;011
	 UNORG								;011

SER$MM:	BITB	#MT.ECK,MTFLAG+MTDDSP(R1)	;ARE WE WAITING FOR AN ECA? ;011
	BEQ	17$		;NOPE. SO ALLOW REQUEST			;007
	ERROR	HNGDEV		;ERROR OUT 'TIL WE GET AN ECA		;007

17$:	ADD	#MTUBUF+MTDDSP,R1 ;INDEX INTO DDB AWAYS
	CLR	XRBLK(R3)	;INDICATE A SEQUENTIAL DEVICE
	CLRB	XRBLKM(R3)	; IN BOTH PLACES
	MOV	XRLOC(R3),(R1)	;NOW SET USER'S VIRTUAL BUFFER ADDRESS
	BIT	(R1)+,#1	;IS IT ODD?
	BNE	20$		;YES, ERROR
	MOV	(R3)+,(R1)	;SET COUNT AS THE BUFFER LENGTH
	ASR	R2		;MAKE 2/4 INTO 1/2
	CMP	R2,#.WRITE&377/2 ;IS IT WRITE?
	BNE	30$		;NO, READ, CHECK FOR WORD SIZE BUFFER
	MOV	(R3),(R1)	;WRITE, COUNT IS SUPPLIED BYTE COUNT
	CMP	(R1)+,#14.	;14. BYTES IS THE MINIMAL RECORD SIZE
	BGE	40$		;O.K. RECORDS ARE 14.<=SIZE<16K
20$:	ERROR	BADCNT		;ELSE SET AN ERROR AND EXIT

30$:	BIT	(R1)+,#1	;IS READ BUFFER ODD SIZE?
	BNE	20$		;YES IS AN ERROR
40$:	TST	(R1)+		;SKIP FLAG WORD IN DDB
	MOVB	#MTRTCT,(R1)+	;SET INITIAL RETRY COUNT
	INC	R1		;SKIP DOS/ANSI FLAG
	MOVB	R2,(R1)		; AND, FINALLY, SET THE COMMAND
	SUB	#MTCCMD,R1	;BACKUP TO QUEUE WORD IN DDB
	MOV	R1,R4		;PUT POINTER IN CORRECT SPOT
	CALLX	QUEL3Q		;NOW QUEUE REQUEST INTO DRIVER'S QUEUE
	JMPX	DMPJOB		;THEN DUMP THE JOB AND EXIT

.DSABL	LSB

.SBTTL	UMR HANDLING

;+
; UMR$MM - ENTERED WHEN A UNIBUS MAPPING REGISTER BECOMES AVAILABLE.
;
;	ALL REGISTERS RANDOM
;	PRIORITY IS PR5
;
;	RETURN		(PRIORITY STILL PR5)
;-

	TMPORG	MMDINT,52						;011
	 .WORD	UMR$MM							;011
	 UNORG								;011

UMR$MM:	L3QSET	QMMCON		;;RE-ENTER AT LEVEL 3
	RETURN

.SBTTL	LEVEL 3 QUEUED CONTINUE ENTRY POINT

	TMPORG	MMDINT,42						;011
	 .WORD	CON$MM							;011
	 UNORG								;011

CON$MM:	CALL	MTASET		;CALL THE PROCESSING CODE		;011
MTART3:	JMPX	RTI3		;EXIT VIA LEVEL 3

.SBTTL	PROCESS FINISHED REQUEST

.ENABL	LSB

	TMPORG	MMDINT,46						;011
	 .WORD	DNE$MM							;011
	 UNORG								;011

DNE$MM:	MOV	MMAQUE,R4	;GET FINISHED REQUEST			;011
	CALL	@RELUMR		;RELEASE ANY MAPPING REGISTERS
	MOV	#MMAINF,R1	;HANDY POINTER				;011
	BITB	#MT$NIN,(R1)	;DID AN INTERRUPT OCCUR?
	BEQ	10$		;YES, CHECK IT OUT
	JMP	220$		;NO, NO CHECKING

10$:	MOV	CSR.MM,R3	;GET THE CSR POINTER AND
	ADD	#RHER,R3	; INDEX TO ERROR REGISTER
	MOV	MMFC-RHER(R3),R2 ;SNAG THE CURRENT FRAME COUNT
	MOV	(R3),R0		; AND SNAG THE ERROR REGISTER
	MOV	-(R3),R5	;NOW SNAG THE CURRENT STATUS
	BIT	#RHNED!RHNEM,-(R3) ;CHECK FOR HARD ERROR IN RHCS2
	BEQ	20$		;NONE
	BIS	#RHERR,R5	;ONE, SIGNAL AN ERROR
	BIS	#RHUNS!RHRMR!RHILR!RHILF,R0 ; AND MAKE IT VERY HARD
20$:	BIC	#MMFCE,R0	;ONLY FRAME COUNT ERROR (AND CLEAR IT) ?
	BNE	30$		;OTHER ERROR(S) TOO
	BIC	#RHERR,R5	;ONLY FRAME COUNT, SO NO REAL ERROR
30$:	ASL	R5		;DUMP THE 'ATA' BIT
	BPL	60$		;NO ERROR
	LOG$MM			;ERROR, SO LOG THE ERROR
	BIT	R5,#MMPES*2	;PHASE ENCODED NOW?
	BEQ	60$		;NOPE, ALL ERRORS COUNT
				;*** PATCH SOURCE CLEAR - KCG 
	CMPB	MTCCMD(R4),#WRT.MT ; ARE WE DOING A WRITE 
	BEQ	40$		;YES
	CMPB	MTCCMD(R4),#EOF.MT ; OR A WTM
	BEQ	40$		;YES
	BIC	#MMCOR!MMCS,R0	;NO, SO DON'T COUNT THESE ERRORS
	BR	50$		;SKIP TEST
40$:	TST	R0		;TEST ALL ERRORS
				;*** END PATCH 3.7.7 ( FROM V7.2 )
50$:	BNE	60$		;BUT OTHER ERROR(S) EXIST
	BIC	#RHERR*2,R5	;CLEAR COMPOSITE ERROR IF NO REAL ERROR
60$:	ASR	R5		;SIGN EXTEND THE 'ERR' BIT
	BIC	#MTEOF!MTRLE,R5	;CLEAR 'EOF' AND 'RLE' LOCATIONS
	BIT	R5,#MMEOF	;REAL 'EOF'?
	BEQ	70$		;NO
	BIS	#MTEOF,R5	;YES, SO SET THE BIT HERE TOO
70$:	CMPB	MTCCMD(R4),#RED.MT ;WAS THE FUNCTION READ?
	BNE	90$		;NO
	BICB	#MT.DEN,MTOFLG(R4)	;Start by assuming 1600.	;018
	BIT	#MMPES,R5		;Is it really 1600?		;018
	BNE	75$			;Yup.				;018
	BISB	#MT.DEN,MTOFLG(R4)	;Otherwise, make it 800.	;018
75$:	CMP	R2,MTCNT(R4)	;Check frame count vs initial count	;018
	BLOS	80$		;WE READ <= INITIAL COUNT, SO O.K.
	BIS	#MTRLE,R5	;WE READ > INITIAL COUNT, SO 'RLE'
	MOV	MTCNT(R4),R2	; AND SAY ONLY THIS MUCH REALLY READ
80$:	NEG	R2		;PRE-CORRECT RETURNED VALUE
90$:	NEG	R2		;CORRECT RETURNED VALUE
	MOV	R2,MTCRET(R4)	; AND SAVE IT FOR THE CALLER
	CMPB	MTCCMD(R4),#REW.MT ;WAS THE COMMAND REWIND?
	BNE	100$		;NOPE
	BIC	#MTEOT,R5	;YEP, NEVER A END-OF-TAPE ERROR
100$:	MOV	R5,MTLCST(R4)	;SAVE STATUS

GLOBAL	<RELUMR,CSR.MM,LOG$MM,MMAQUE,MMAINF>				;011

	MOV	(PC)+,R2	;GUESS AT THE WORST TYPE OF ERROR
	 .BYTE	HNGDEV,DATERR
	TSTB	MMATIM		;WHICH IS TIMEOUTS			;011
	BMI	200$		;IT DID TIMEOUT...
	BIT	R5,#RHMOL	;STILL ON-LINE?
	BEQ	170$		;NO, SO SELECT ERROR
	BIT	R0,#RHUNS!MMNEF!MMFMT!RHRMR!RHILR!RHILF ;HARD TYPE ERROR?
	BNE	200$		;YES
	BIT	#RHDLT!RHPE!RHPGE!RHMXF!RHMDPE,(R3)+ ;CHECK FOR RETRYABLE IN RH11
	BNE	110$		;IT IS RETRYABLE
	BIT	R0,#MMCOR!RHOPI!RHDTE!MMCS!MMBTE!MMPEF!MMINC!MMDPAR!MMCPAR ;RETRY?
	BEQ	140$		;NOPE, SO DON'T TRY TO RETRY...
110$:	SWAB	R2		;SHIFT TO THE DATA ERROR CODE
	BITB	#MT$TRY,(R1)	;REQUEST RETRYABLE?
	BEQ	200$		;NO
	INCB	MTRTRY(R4)	;YES, BUT HAVE WE RETRIED ENOUGH?
	BGT	200$		;YES, SO NO MORE RETRIES
	BITB	#MT$LCK,(R1)	;LOCKED INTO MEMORY NOW?
	BEQ	120$		;NOPE
	MOVB	MTJBNO(R4),R0	;YEP, SO GET THE JOB NUMBER
	CALLX	UNLOCK		; AND UNLOCK THE JOB
120$:	MOV	#33+IE,R5	;SET BACKSPACE FUNCTION
	MOV	(PC)+,(R1)	;SET FLAGS AND TIMEOUT VALUE
	 .BYTE	MT$INT!MT$BSY!MT$REQ!MT$BAK,7.
	BITB	#MT.ADR,MTFLAG(R4) ;Should we alter the density?	;012
	BEQ	130$		;No, not this time			;012
	BISB	#MT.ADS,MTFLAG(R4) ;Yes, so say that we did it		;012
	MOV	#MT.DEN,R2	;Get the bits to toggle			;012
	XOR	R2,MTOFLG(R4)	;And do it				;012
.ASSUME	MTOFLG&1 EQ 0							;012
	MOV	#7+IE,R5	;Set function as rewind			;012
130$:	CALL	MTASEL,R5	;RE-SELECT THIS UNIT
	BCS	170$		;NO SELECT POSSIBLE, SELECT ERROR
	MOV	#-1,MMFC-RHDS(R3) ;Set the frame count for the function
	MOV	R5,RHCS1-RHDS(R3) ;NOW DO IT
	JMP	MTART3		; AND EXIT

140$:	BITB	#MT$ERS,(R1)	;FINISHED ERASEING TAPE?
	BNE	150$		;YES, SO RETRY NOW
	BITB	#MT$BAK,(R1)	;FINISHED A BACKSPACE?
	BEQ	160$		;NOPE
	MOV	#25+IE,R5	;YES, SET THE ERASE TAPE FUNCTION
	MOV	(PC)+,(R1)	;SET FLAGS AND TIMEOUT VALUE
	 .BYTE	MT$INT!MT$BSY!MT$REQ!MT$ERS,7.
	BITB	MTRTRY(R4),#1	;IS IT TIME FOR ERASEING TAPE?
..MMGP	==	.-2	;**PATCH** FREQUENCY OF TAPE ERASES
	BNE	150$		;NO, JUST RETRY FROM HERE
	CMPB	MTCCMD(R4),#WRT.MT ;YES, BUT IS THE FUNCTION WRITE?
	BEQ	130$		;IF WRITE, THEN ERASE SOME TAPE
150$:	MOV	#RTI3,-(SP)	;NO, SO SET UP TO REALLY RETRY
	JMP	240$		; AND FINISH UP HERE			;012

GLOBAL	<HNGDEV,DATERR,RTI3,IE,MMATIM>					;011

160$:	CMPB	MTCCMD(R4),#RED.MT ;WAS THE COMMAND READ?
	BNE	190$		;NO
	MOV	(PC)+,R2	;YES, GUESS AT EOF ERROR
	 .BYTE	EOF,MAGRLE
	ASL	R5		;EOF(BIT 14)?
	BMI	180$		;YES
	SWAB	R2		;NO, SO GUESS AT RECORD LENGTH ERROR
	BIT	R5,#MTRLE*2	;RLE?
	BNE	200$		;YES
	BR	210$		;NO, SO NO ERROR AT ALL

170$:	SETERR	MAGSEL,R2	;SET SELECT ERROR CODE
180$:	CLR	MTCRET(R4)	;BYTE COUNT=0 IF EOF
	BR	200$		;GO EXIT WITH ERROR

190$:	BIT	R5,#MTEOT	;END OF TAPE ERROR?
	BEQ	210$		;NO, SO NO ERROR
	CMPB	MTCCMD(R4),#WRT.MT ;EOT, WAS THIS A WRITE?		;010
	BNE	210$		;NO, SO NO ERROR			;010
	SETERR	NOROOM,R2	;SET END OF TAPE ERROR			;010
200$:	MOVB	R2,MTLCEV(R4)	;SET THE ERROR TYPE
210$:	SWAB	MTCCMD(R4)	;CALL CURRENT LAST COMMAND

GLOBAL	<EOF,MAGRLE>

220$:	MOVB	MTJBNO(R4),R0	;GET USER'S JOB NUMBER
	MOV	#FIPSYS,-(SP)	;GUESS THAT FIP CALLED US
	BITB	#MT.OPN,MTOFLG(R4) ;GOOD GUESS?
	BEQ	MTANXT		;YES			
	MOV	JOBTBL(R0),R2	;NOW GET USER'S JOB DATA POINTER
	TSTB	MTLCEV(R4)	;DID ANY ERROR OCCUR?
	BEQ	230$		;NO, SO ALL'S WELL			;007
	MOVB	MTLCMD(R4),R3	;WAS LAST COMMAND A REWIND-OFFLINE? (0)	;007
.ASSUME	RWO.MT	EQ 0
	BEQ	230$		;YES, SO THAT'S OKAY			;007
	CMPB	R3,#WRT.MT	;NO, IS IT READ OR WRITE?		;007
	BGT	230$		;NO, SO THAT'S OKAY TOO			;007
	MOV	R4,-(SP)	;Save DDB pointer			;016
	MOV	JDWORK(R2),R4	;And get work block pointer		;016
	CALLX	CHKASY		;Is this an asynchronous request?	;016
	MOV	(SP)+,R4	;Restore DDB pointer in any event	;016
	BCC	230$		;Synchronous, don't set ECA flag	;016
	BISB	#MT.ECK,MTFLAG(R4) ;Asynchrnous, set ECA flag		;007
230$:	MOV 	JDWORK(R2),R3	;GET POINTER TO USER WORK BLOCK		;005
	MOV	R3,MTFQB(R4)	;MAKE SURE MTFQB IS CORRECT		;008
	BITB	#MT$LCK,(R1)	;WAS JOB LOCKED INTO MEMORY?		;005
	BEQ	235$		;NO, SO DON'T UNLOCK IT			;005
	CALLX	UNLOCK		;YES, BETTER UNLOCK IT			;005
235$:	TST	MTACB(R4)	;File-structured ANSI processing?	;006
	BEQ	237$		;NOPE					;005
	CMPB	MTLCEV(R4),#EOF ;ARE WE AT EOF?				;005
	BNE	237$		;NOPE					;005
	MOVB	#EOVFQ,FQFUN(R3);SET FUNCTION				;005
	MOVB	R0,FQJOB(R3)	;SET JOB # IN WORK BLOCK		;006
	MOV	R4,FQCLUS(R3)	; AND DDB POINTER			;006
	SUB	#MTDDSP,FQCLUS(R3)	; UNBIASED, OF COURSE		;006
	CLR	JBSTAT(R0)	;STALL JOB				;005
	MOV	#JSFIP,JBWAIT(R0) ;WAITING FOR FIP			;005
	BR	MTANXT		;					;005

237$:	MOV	#RTI3,(SP)	;NO, USER CALLED FOR READ/WRITE		;005
	MOV	R4,-(SP)	;SAVE THE DDB POINTER
	MOV	R0,R4		; AND SET JOB NUMBER TIMES 2
	CALLX	IOFIN4,R5,JS.MM	;SAVE MAGTAPE IS DONE
	MOV	(SP)+,R4	;RESTORE THE DDB POINTER
	MOVB	MTLCEV(R4),JDIOST(R2) ;SET ERROR (IF ANY)		
	MOV	MTCRET(R4),XRBC(R3) ; AND SET RETURNED VALUE
MTANXT:	MOV	(R4),MMAQUE	;DEQUEUE TO NEXT REQUEST		;011
	BICB	#MT.ADR,MTFLAG(R4) ;Forget about density setting	;012
	BITB	#MT.ADS,MTFLAG(R4) ;Do we need to set density?		;012
	BEQ	240$		;No, not this time			;012
	TSTB	MTLCEV(R4)	;Yes, but did an error occur?		;012
	BEQ	238$		;No, great				;013
	CMPB	MTLCEV(R4),#MAGRLE ;Error, but was it RLE?		;013
	BEQ	238$		;Yes, so set the density		;013
	CMPB	MTLCEV(R4),#EOF	;How about EOF?				;013
	BNE	239$		;Nope, so don't make density permenant	;013
238$:	MOVB	MTOFLG(R4),R3	;Get the final density			;012
	BIC	#^C<MT.DEN>,R3	;And save only density			;012
	BICB	#MT.DEN!MT.PAR,MTFLAG(R4) ;Forget the default density	;012
	BISB	R3,MTFLAG(R4)	;And make the current density be default ;012
239$:	BICB	#MT.ADS,MTFLAG(R4) ;And forget the density set flag	;012
240$:	L3QSET	QMMCON		;TELL STARTER TO RUN
	CLRB	MMAINF		;SAYING START A REQUEST			;011
	MOV	MTFQB(R4),R4	;PICKUP FIRQB ADDRESS IF ANY
MTARTS:	RETURN			; AND EXIT

.DSABL	LSB

GLOBAL	<JOBTBL,FIPSYS,RTI3,JS.MM,MMAQUE,MMAINF,MAGRLE,EOF>		;013

.SBTTL	PROCESS A REQUEST PROCESSOR

MTASET:	MOV	#MMAINF,R2	;GET HANDY POINTER			;011
	BITB	#MT$BSY,(R2)	;CONTROL BUSY NOW?
	BNE	MTARTS		;IF SO, THEN QUICKLY EXIT
	BITB	#MT$REQ,(R2)	;ARE WE PROCESSING A REQUEST?
	BNE	50$		;YES, SO DON'T CHECK REWINDERS
10$:	MOV	#MMARWQ,R4	;GET POINTER TO REWINDING QUEUE		;011
	TST	(R4)		;QUEUE EMPTY?
	BEQ	40$		;YES, SO DON'T TRY TO CHECK IT
	TSTB	MMADRW		;IF SOME, THEN SHOULD WE DO THEM?	;011
	BEQ	40$		;NO, NOT QUITE NOW...
	MOVB	MMASCT,R5	;YES, SO HOW MANY TO SKIP?		;011
20$:	MOV	R4,R1		;KEEP A 'PREVIOUS' POINTER
	MOV	(R1),R4		; THEN MOVE TO NEXT ENTRY
	BEQ	40$		;EXIT IF NO MORE IN QUEUE
	DEC	R5		;SKIP ANOTHER?
	BPL	20$		;YES, SO KEEP GOING
	CALL	MTASEL,R5	;NO, SO TRY TO SELECT THIS UNIT
	BCS	30$		;REMOVE FROM QUEUE IF NON-SELECTABLE
	BIT	#RHPIP,(R3)	;ELSE IS IT READY YET?
	BEQ	30$		;YES, SO REMOVE FROM QUEUE
	INCB	MMASCT		;NO, SO MUST SKIP ONE MORE IN QUEUE	;011
	BR	20$		;GO GET NEXT

30$:	MOV	(R4),(R1)	;DEQUEUE THIS ENTRY FROM REWIND QUEUE
	CALLX	QUEUER,R5,MMAQUE ; AND THEN QUEUE IT INTO REQUEST QUEUE	;011
	BR	10$		;BUT STILL CHECK OTHERS...

40$:	CLR	MMASCT		;RESET SKIP COUNT TO ZERO		;011
;.ASSUME	MMADRW	EQ MMASCT+1 ;ALSO CLEAR 'CHECK REWINDERS' FLAG	;011

50$:	MOV	MMAQUE,R4	;GET A REQUEST FROM REQUEST QUEUE	;011
	BEQ	MTARTS		;EXIT VIA LEVEL 3 IF NONE
	MOV	(PC)+,(R2)	;INIT REQUEST AND TIME OUT
	 .BYTE	MT$REQ!MT$NIN,7.
;.ASSUME MMATIM	EQ MMAINF+1						;011
	TST	MTIDX(R4)	;DO DEFAULTS NEED SETTING?
	BPL	60$		;NO
.IIF	NE	DDSTAT-100000, .ERROR ;THE ABOVE WON'T WORK
	BIC	#DDSTAT,MTIDX(R4) ;YES, BUT NO LONGER
	BICB	#^C<MT.DEN!MT.PAR>,MTFLAG(R4) ;LEAVE ONLY DEN/PAR
	BISB	MTDUNI(R4),MTOFLG(R4) ;And be sure unit number is in DDB ;013
	CALL	MTASEL,R5	;Select the unit			;013
	BCS	55$		;Unable to select it, anything goes	;013
	BIT	#MMBOT!RHPIP,(R3) ;BOT or going there?			;013
	BEQ	60$		;No, so don't change density		;013
55$:	BICB	#MT.DEN!MT.PAR,MTOFLG(R4) ;Clear out the old density	;013
	BISB	MTFLAG(R4),MTOFLG(R4) ;And set the new density		;013
60$:	CLR	MTCRET(R4)	;PRE-CLEAR RETURN VALUE
	CLRB	MTLCEV(R4)	; AND PRE-CLEAR ERROR CODE TO NO ERROR
	MOVB	MTJBNO(R4),R1	;GET JOB OF REQUESTOR
	MOV	JOBTBL(R1),R1	; TO GET THE JOB DATA TO
	CALLX	CLRRSQ		;  ENSURE JOB CAN SWAP OUT
	MOVB	MTCCMD(R4),R1	;GET COMMAND TO PROCESS
	ASL	R1		; TIMES 2 FOR WORD INDEXING
	JMP	@70$(R1)	;GO TO IT...

70$:	.WORD	MTARWU		; 0. IS REWIND THEN OFFLINE
	.WORD	MTARD		; 1. IS READ
	.WORD	MTAWT		; 2. IS WRITE
	.WORD	MTAEOF		; 3. IS WRITE END-OF-FILE
	.WORD	MTARWD		; 4. IS REWIND
	.WORD	MTASBP		; 5. IS SKIP FORWARD (SPACE)
	.WORD	MTABSP		; 6. IS SKIP BACKWARD (BACKSPACE)
	.WORD	MTAPD		; 7. IS SET DENSITY/PARITY
	.WORD	MTAST		; 8. IS RETURN UNIT STATUS
	.WORD	MTACHR		; 9. IS RETURN FILE CHARACTERISTICS
	.WORD	MTACRW		;10. IS REWIND ON CLOSE
	.WORD	MTAEOV		;11. is Write End-Of-Volume On Close	;017
	.WORD	MTAECA		;12. is Error Condition Acknowledge	;017
	.WORD	MTAXDN		;13. is Extended Set Density .SPEC call	;014
	.WORD	MTAGBF		;14. IS GET AN ANSI LABEL BUFFER	;00V
.ASSUME	GBF.MT EQ 14.							;00V

; NOTE THAT:
;	R1 =  COMMAND NUMBER TIMES 2
;	R2 -> MMAINF
;	R4 -> REQUEST (DDB)

GLOBAL	<JOBTBL,MMAQUE,MMARWQ,MMASCT,MMADRW,MMAINF>			;011

.SBTTL	MAGTAPE "GO" ROUTINE

MTAGO:	BIT	#RHPIP,(R3)	;TAPE CURRENTLY REWINDING?
	BNE	MTADEQ		;YES, SO DELAY THIS OPERATION
	MOVB	R1,MMGFUN	;SET UP RH11 FUNCTION			;011
MTGO:	MOV	CSR.MM,R3	;GET POINTER TO CSR (RHCS1)
	MOV	MTCNT(R4),R4	;GET THE BYTE COUNT
	NEG	R4		;MAKE IT A -(BYTE COUNT)
	MOV	R4,MMASFC	; AND SAVE IT FOR TIMEOUT CHECKING	;011
	MOV	R4,MMFC(R3)	;SET THE FRAME COUNTER
	BISB	#MT$INT!MT$BSY,MMAINF ;INDICATE INTERRUPT COMING AND CONTROL BUSY ;011
	MOVB	MMGFUN,(R3)	;START THE I/O				;011
MTARET:	RETURN			;DONE					;012

.SBTTL	RE-QUEUE REWINDERS TO A HOLDING QUEUE

MTADEQ:	MOV	(R4),MMAQUE	;DEQUEUE FROM REQUEST QUEUE		;011
	CALLX	QUEUER,R5,MMARWQ ; AND REQUEUE INTO THE REWINDING QUEUE	;011
	CLRB	(R2)		;TERMINATE THIS REQUEST
	BR	MTASET		;TRY STARTING ANOTHER REQUEST

.SBTTL	GET AN ANSI LABEL BUFFER

MTAGBF:	MOVB	#UNT.MT,MTCCMD(R4) ;CHANGE FUNCTION TO 'UNIT STATUS'
MTAGLB:	MOV	R4,(SP)		;SAVE DDB POINTER (& POP "RTI3")
	CALL	MTANXT		;NOW DEQUEUE THIS REQUEST FROM DRIVER QUEUE
	MOV	(SP)+,R4	;RESTORE THE DDB POINTER
	CALLX	GETBIG,R5,MTULBF ;REQUEST A BIG (I/O) BUFFER
	CALLX	QUEL3Q		;WE GOT IT, RE-QUEUE TO DRIVER'S QUEUE
	JMPX	RTI3		; AND EXIT...

GLOBAL	<CSR.MM,MMAQUE,MMARWQ,MMGFUN,MMAINF,MMASFC>			;011

.SBTTL	PROCESS WRITE

MTAWT:	MOV	#61-<71-<1*2>>,R1 ;SET UP WRITE COMMAND
	CALL	MTASEE		;SELECT AND DIE IF ERROR
	BIT	#RHWRL,(R3)	;WRITE LOCKED?
	BNE	MTAWL1		;YES, ERROR

.SBTTL	PROCESS READ

.ENABL	LSB

MTARD:	BISB	#MT$TRY,(R2)	;RETRYABLE
	CALL	MTASEE		;SELECT AND DIE IF ERROR
	BIT	#RHPIP,(R3)	;DRIVE REWINDING NOW?
	BNE	MTADEQ		;YES, SO PUT REQUEST IN PENDING QUEUE
	ADD	#71-<1*2>+IE,R1	;FIND THE CORRECT I/O COMMAND
	MOVB	R1,MMGFUN	;REMEMBER THE FUNCTION			;011
	BITB	#MT.OPN,MTOFLG(R4) ;IS IT FIP I/O?
	BNE	10$		;NO, USER I/O
	CLR	R1		;ASSUME THERE'S A BUFFER ADDRESS
	MOV	MTUBUF(R4),R2	;IS THERE?
	BEQ	MTAGLB		;NO, GET A BUFFER
	BR	30$		;YES, GO MAP THE TRANSFER

10$:	TSTB	MTOFLG(R4)	;FILE STRUCTURED?
	BPL	20$		;NO
	BIT	R1,#10		;YES, A READ??
	BEQ	20$		;NOT A READ
	BIT	#MTEOF,MTLCST(R4) ;F/S READ ALREADY AT EOF?
	BNE	60$		;YES, DON'T LET IT THROUGH
20$:	BISB	#MT$LCK,(R2)	;JOB WILL BE LOCKED INTO MEMORY SOON
	MOVB	MTJBNO(R4),R0	;GET JOB NUMBER TO FIND
	MOV	MML3QB,R3	;AND L3Q BITS IN CASE OF A STALL 	;011
	MOV	MTUBUF(R4),R5	;SET USER'S VIRTUAL BUFFER ADDRESS
	CALLX	FNDJOB		;TRY TO FIND JOB (BRING INTO MEMORY)
MTAWL1:	BR	MTAWLR		;ERROR IN JOB RESIDENCY, SO QUIT
	BCS	MTARET		;NON-RESIDENT, EXIT FOR NOW		;012
	MOVB	R2,R1		;SET EXTENDED MEMORY ADDRESS
	MOV	R3,R2		;SET MEMORY ADDRESS
30$:	MOV	MTCNT(R4),R0	;GET +(BYTE COUNT)
	NEG	R0		; -(BYTE COUNT)
	ASR	R0		; -(WORD COUNT)
	MOV	CSR.MM,R3	;GET CSR FOR THE DEVICE
	SPLC	5		;;RAISE PRIORITY
	CALLX	RHMADR		;;SET UP ADDRESSING FOR THE TRANSFER
	SPL	3		;;LOWER PRIORITY AGAIN
	BCC	50$		;SKIP IF WE MADE IT
	BITB	#MT.OPN,MTOFLG(R4) ;FIP I/O?
	BEQ	40$		;YES, DON'T UNLOCK ANY JOB
	MOVB	MTJBNO(R4),R0	;NO, GET THE JOB NUMBER TIMES TWO
	CALLX	UNLOCK		;AND LET THE JOB SWAP OUT
40$:	RETURN			;WE'RE DONE FOR NOW

50$:	CMPB	MTRTRY(R4),#MTRTCT ;FIRST TIME THROUGH?
	BNE	MTGO		;NO
	BIT	#MT.ADR,MTFLAG(R4) ;Really the first time?		;012
	BNE	MTGO		;No, not this time			;012
	BIT	#40,RHDT(R3)	;Is this a TM02?			;012
	BNE	55$		;No, not this time			;012
	BIT	#MMBOT,RHDS(R3)	;Yes, are we at BOT?			;012
	BEQ	55$		;No, not this time			;012
	BITB	#10,MMGFUN	;Yes, is this a read?			;012
	BEQ	55$		;No, so no density checking		;012
	BITB	#MT.PAR,MTOFLG(R4) ;Are we set to odd parity?		;012
	BNE	55$		;No, even, don't mess with it		;012
	BISB	#MT.ADR,MTFLAG(R4) ;Yes, so set to do density checking	;012
	ASLB	MTRTRY(R4)	;And double the retry count		;012
55$:	BITB	#MT.OPN,MTOFLG(R4) ;FIP I/O?
	BEQ	57$		;YES, DON'T DESTROY RETURN ADDRESS	;012
	INC	MTBCNT(R4)	;YES, COUNT THE BLOCKS
57$:	JMP	MTGO		; AND DO IT				;012

60$:	SETERR	EOF,MTLCEV(R4)	;SET THE END-OF-FILE ERROR
	BR	MTASWB		; AND GIVE THAT ERROR


.DSABL	LSB

GLOBAL	<IE,MMGFUN,MML3QB>						;011

.SBTTL	PROCESS BACKSPACE

MTABSP:	CALL	MTASEE		;SELECT AND DIE IF ERROR
	BIT	#RHPIP!MMBOT,(R3) ;ALREADY (OR COMING) THERE?
	BEQ	MTASBP		;IF NOT, DO BACKSPACE		;001
	MOV	MTCNT(R4),MTCRET(R4) ;RETURN CORRECT VALUE AND	;001
	BR	MTASVT		;QUEUE COMPLETION PROCESSING	;001

.SBTTL	PROCESS SPACE

.ENABL	LSB

MTASBP:	CALL	MTASEE		;SELECT AND DIE IF ERROR
	ADD	#31-<5*2>+IE,R1	;FORM HARDWARE COMMAND
10$:	JMP	MTAGO		;ISSUE FN IN R1 UNLESS TAPE REWINDING

.SBTTL	PROCESS OFFLINE

MTARWU:	CALL	MTASEL,R5	;SELECT UNIT
	BCS	MTASVT		;IF ALREADY OFFLINE, THEN EXIT
	MOV	#3,RHCS1-RHDS(R3) ;OFF-LINE THE UNIT INVOLVED
	BR	MTASVT		;SAVE STATUS AND EXIT

GLOBAL	<IE>

.SBTTL	PROCESS REWIND

MTARWD:	CALL	MTASEE		;SELECT AND DIE IF ERROR
	BIT	#RHPIP!MMBOT,(R3) ;ALREADY (OR COMING) THERE?
	BNE	MTASVT		;YES, SO JUST EXIT
	MOV	#7+IE,R1	;SET HARDWARE COMMAND
20$:	CLR	MTCNT(R4)	;FORCE COUNT TO BE ZERO
	BR	10$		; AND GO GO

.SBTTL	PROCESS WRITE EOF 

MTAEOF:	BISB	#MT$TRY,(R2)	;RETRYABLE
	CALL	MTASEE		;SELECT AND DIE IF ERROR
	MOV	#27+IE,R1	;SET THE HARDWARE FUNCTION
	BIT	#RHWRL,(R3)	;WRITE LOCKED?
	BEQ	20$		;NO, SO GO
MTAWLR:	SETERR	HNGDEV,MTLCEV(R4) ;SET HUNG DEVICE/WRITE LOCK ERROR
MTASVT:	MOV	(R3),R5		;SAVE STATUS FOR THIS REQUEST
	ASL	R5		;DUMP THE 'ATA' BIT AND
	ASR	R5		; SIGN EXTEND 'ERR'
	BIC	#MTEOF!MTRLE,R5	;CLEAR TM11/TU10 EOF & RLE BITS
	BIT	R5,#MMEOF	;EOF?
	BEQ	30$		;NO
	BIS	#MTEOF,R5	;YES, SO INDICATE IT
30$:	MOV	R5,MTLCST(R4)	;SAVE AWAY THE LAST STATUS
MTASWB:	SWAB	MTCCMD(R4)	;MAKE CURRENT COMMAND LAST COMMAND
MTAEXC:	L3QSET	QMMDNE		;CALL COMPLETION ROUTINE
	BISB	#MT$BSY!MT$NIN,(R2) ;SAY CONTROL BUSY & NO INTERRUPT
MTARPC:	RETURN			; AND OUT

.DSABL	LSB

GLOBAL	<IE>

.SBTTL	PROCESS STATUS REQUEST

MTAST:	MOV	R4,R1		;COPY DDB POINTER
	MOV	#40!20,-(R1)	;SET NON-SELECTABLE AND "TU16/TE16"
	CALL	MTASEL,R5	;TRY TO SELECT UNIT
	BCS	10$		;UNIT IS NON-SELECTABLE
	BIC	#40,(R1)	;UNIT IS SELECTABLE, TURN OFF BIT
	BIT	#RHPIP,(R3)	;IS A REWIND IN PROGRESS?
	BEQ	10$		;NOPE
	JMP	MTADEQ		;YEP, GO WAIT UNTIL THAT REWIND COMPLETES

10$:	BISB	MTLCMD(R4),(R1)+ ;SET LAST COMMAND IN VALUE
	MOVB	MTOFLG(R4),(R1)	;GET DDB STATUS
	BICB	#^C<MT.DEN!MT.PAR>,(R1) ;LEAVING ONLY DENSITY/PARITY
	MOV	(R3),R5		;GET ACTIVE STATUS VALUE
	BCS	20$		;NON-SELECTABLE UNIT, SKIP DENSITY CHECK
	CLRB	(R1)		;GUESS AT 1600 PE (MT.DEN!MT.PAR=0)
	BIT	R5,#MMPES	;IS THE DRIVE IN 1600 PE MODE?
	BNE	20$		;YES
	MOVB	#MT.DEN,(R1)	;NO, SET 800 NRZ
	BIT	#10,MMTC-RHDS(R3) ;ALSO EVEN PARITY?
	BEQ	20$		;NOPE, ODD PARITY (MT.PAR=0)
	BISB	#MT.PAR,(R1)	;YEP, INDICATE EVEN PARITY
20$:	BIT	R5,#MMBOT	;BOT
	BEQ	30$		;NO
	INCB	(R1)		;YES
30$:	BIT	R5,#RHWRL	;WRITE LOCKED?
	BEQ	40$		;NO
	BISB	#4,(R1)		;YES
40$:	MOV	MTLCST(R4),R5	;GET LAST COMMAND STATUS NOW
	BPL	50$		;NO ERROR
	BISB	#200,(R1)	;INDICATE ERROR OCCURED
50$:	BIT	R5,#MTEOT	;EOT?
	BEQ	60$		;NO
	BISB	#2,(R1)		;YES
60$:	DEC	R1		;BACK TO LOW BYTE OF VALUE NOW
	ASL	R5		;EOF (BIT 14)?
	BPL	70$		;NO
	BIS	#200,(R1)	;YES
70$:	BIT	R5,#MTRLE*2	;RECORD LENGTH ERROR?
	BEQ	80$		;NO
	BIS	#100,(R1)	;YES
80$:	BIT	#MT.DEN*400,(R1) ;PHASE ENCODED?
	BNE	MTAEXC		;NO
	BIS	#10,(R1)	;YES
	BR	MTAEXC		; AND OUT

.SBTTL	PROCESS CHARACTERISTICS REQUEST

MTACHR:	MOV	R4,R1		;COPY DDB POINTER
	CLR	-(R1)		; AND CLEAR RETURNED VALUE
	MOV	MTACB(R4),R5	;GET THE ACB ADDRESS
	BEQ	MTAOUT		;NONE, SO JUST EXIT
	MOV	(R5),(R1)	;ONE, SET CHARACTERISTICS
	BR	MTAOUT		; AND EXIT

.SBTTL	PROCESS REWIND ON CLOSE

MTACRW:	BICB	#MT.NRW,MTFLAG(R4) ;SAY REWIND ON CLOSE
MTAOUT:	BR	MTAEXC		;THEN EXIT

.SBTTL	Process Write End-Of-Volume On Close

MTAEOV:	MOV	MTACB(R4),R1	;Get ACB pointer			;017
	BEQ	5$		;NONE...THAT'S BAD			;005
	MOV	#^REOV,2(R1) 	;SAY WE WILL WRITE EOV'S  (ACBTYP)	;005
	BR	MTAOUT		;Then exit				;017

5$:	SETERR	NOTMTA,MTLCEV(R4) ;Return an error			;017
	BR	MTAOUT		;And exit with it			;017

.SBTTL	Process Error Condition Acknowledge

MTAECA:	BICB	#MT.ECK,MTFLAG(R4) ;Clear wait for ECA bit if needed	;017
	BR	MTAOUT		;Then exit				;017

.SBTTL	PROCESS PARITY/DENSITY

MTAPD:	CALL	MTASEE		;SELECT AND DIE IF ERROR
	MOV	MTCNT(R4),R5	;GET SUPPLIED SETTING
	TSTB	MTOFLG(R4)	;FILE STRUCTURED?
	BMI	30$		;REJECT SETTING IF SO
	ASH	#3,R5		;SHIFT INTO CORRECT SPOT
	BIS	#MT.DEN,R5	;FORCE 800 BPI (IF NRZI)
	BIT	R5,#400*10	;DESIRE 1600 BPI PHASE ENCODED?
	BEQ	10$		;NO
	BIC	R5,R5		;YES, SO SET 1600 BPI PE MODE
10$:	BIC	#^C<MT.DEN!MT.PAR>,R5 ;TRIM TO ONLY DEN/PAR
	BIT	#MMBOT!RHPIP,(R3) ;At BOT or going there?		;013
	BEQ	15$		;No, so don't change present density	;013
	BICB	#MT.DEN!MT.PAR,MTOFLG(R4) ;CLEAR OLD SETTING
	BISB	R5,MTOFLG(R4)	; AND SET NEW
15$:	BCC	20$		;NOT SETTING THE DEFAULT		;013
	BICB	#MT.DEN!MT.PAR,MTFLAG(R4) ;ELSE CLEAR OUT OLD DEFAULT
	BISB	R5,MTFLAG(R4)	; THEN SET THE NEW
20$:	CLR	R5		;INDICATE NO ERROR
30$:	MOV	R5,MTCRET(R4)	;SET RETURN VALUE
	BR	MTAOUT		;DOESN'T COUNT AS A COMMAND

.ENABL	LSB

GLOBAL	<BDNERR,NOTMTA>							;014

MTAXDN:	MOV	MTCNT(R4),R5		;Find out what they really want.;014
	MOV	R5,R1			;Make a copy of it.		;014
	BEQ	40$			;Get current density?  OK.	;014
	CALL	VERDEN			;See if it's OK.		;014
	BCS	100$			;Nope, bad density - punt.	;014
	TST	R1			;Do we want to set a density?	;014
	BPL	60$			;No, just check, so go back.	;014
10$:	MOV	CSR.MM,R3		;Get the CSR address.		;014
	MOVB	MTTM02(R4),RHCS2(R3)	;Get formatter number into CS2.	;014
	MOVB	MTOFLG(R4),R0		;Get unit number.		;014
	BIC	#^C<MT.UNT>,R0		;Get rid of unused stuff.	;014
	BICB	#MT.UNT,MMTC(R3)	;Make sure no bogus bits.	;014
	BISB	R0,MMTC(R3)		;Select the drive.		;014
	MOVB	#377,RHAS(R3)		;Get rid of any attention bits.	;014
	MOV	RHDT(R3),R0		;Get the drive type.		;014
	BIC	#47,R0			;Clear out TM03 and slave type.	;014
	CMP	R0,#RHNSA!RHTAP!RHSPR!10;Is it what we expected?	;014
	BNE	110$			;If not, go tell 'em.		;014
	BIT	#RHMOL,RHDS(R3)		;Online?			;014
	BEQ	110$			;Nope, doesn't look like it.	;014
	BIT	#RHPIP!MMBOT,RHDS(R3)	;At BOT or going there?		;014
	BEQ	110$			;Sorry, no can do!		;014
	BICB	#MT.DEN,MTOFLG(R4)	;Set 1600 BPI in open flags...	;014
	CMP	R5,#1600.		;Do we want it at 1600 BPI?	;014
	BEQ	20$			;Yup, so leave it alone.	;014
	BISB	#MT.DEN,MTOFLG(R4)	;Otherwise, set it for 800 BPI	;014
20$:	CALL	MTASEL,R5		;Re-select drive at new density.;015
	BCS	110$			;Oops!!  Something died.	;015
	MOVB	MTOFLG(R4),R0		;Get a copy of the open flags.	;015
	BIC	#^C<MT.DEN>,R0		;And get rid of extraneous bits.;015
	BICB	#MT.DEN,MTFLAG(R4)	;Clear density out of MTFLAG...	;015
	BISB	R0,MTFLAG(R4)		; ...and make temp flags perm.	;015
	BR	60$			;Exit gracefully.		;015

40$:	MOV	#800.,R5		;Start with 800 BPI.		;014
	BITB	#MT.DEN,MTOFLG(R4)	;Are we really set for 1600?	;014
	BNE	60$			;Nope, so leave it at 800 BPI.	;014
50$:	ASL	R5			;Otherwise, make it say 1600.	;014
60$:	MOV	R5,MTCRET(R4)		;Return current density...	;014
	BR	MTAOUT			; ...and go back.		;014

100$:	MOVB	#BDNERR,MTLCEV(R4)	;Put error in exit value.	;014
	BR	50$			;Go back.			;014

110$:	MOVB	#NOTMTA,MTLCEV(R4)	;Same song, second verse.	;014
	BR	60$							;014


.ENABL	LSB

;+
;	VERDEN - Verifies/returns legal densities.
;
;	This routine accepts a density to verify in R5, and returns a verified
;	density in R5 according to the following rules;
;
;	Bit 15 = 0
;		Returns the lowest legal density that is not less than the
;		value passed in bits 0-14.
;	Bit 15 = 1
;		Test the density in bits 0-14 to see if it's legal for the
;		drive.  If so, the C-bit is cleared and the value in bits
;		0-14 is returned.  If not, the C-bit is set, and the value
;		returned represents the highest legal density for that
;		drive.
;
;	CALL:
;		R5 = Density to verify.  See above description.
;
;		CALL	VERDEN
;
;	RETURN:
;		C-bit Clr: No error.  R5 is nearest legal density.
;		C-bit Set: Error.  R5 is highest possible density.
;
;-

VERDEN:	PUSH	<R1>			;Save us a scratch register.	;014
	MOV	#800.,R1		;Start by assuming 800 BPI.	;014
	TST	R5			;Do they want error stuff?	;014
	BMI	40$			;Yup, go to it.			;014
	CMP	R5,R1			;See what density to check.	;014
	BLOS	20$			;They want 800 (or maybe less).	;014
10$:	ASL	R1			;Otherwise, make it say 1600.	;014
20$:	TST	(PC)+			;Clear carry and skip next.	;014
30$:	SEC				;Otherwise, show an error.	;014
	MOV	R1,R5			;Go back with the answer.	;014
	POP	<R1>			;Put original registers back.	;014
	RETURN

40$:	BIC	#100000,R5		;Remove evil influences.	;014
	CMP	R5,#1.			;Do they want lowest density?	;014
	BEQ	20$			;Yup, treat it like a check.	;014
	CMP	R5,#32767.		;How about highest?		;014
	BEQ	10$			;OK, so be it.			;014
	CMP	R1,R5			;Is it a match?			;014
	BEQ	20$			;Yup, go back.			;014
	ASL	R1			;Otherwise, try 1600 BPI.	;014
	CMP	R1,R5			;How about this time?		;014
	BEQ	20$			;Okee dokee.			;014
	BR	30$			;Otherwise, say an error.	;014

.END

