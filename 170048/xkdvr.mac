	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
	.INCLUDE /CMN:XKDEF/
TITLE	XKDVR,<KMC-11 DRIVER>,0A,10-MAY-91,SCC/SPC/PGV/GPK/KPH

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR XKDVR

;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;  001  PGV  03-NOV-81	TO RSTS/E GROUP FOR SUBMISSION TO SDC WITH V7.1 RSTS/E
;
;			[RSTS/E V9.0]
;  002	GPK  20-Apr-84	Multiple privilege changes
;
;			[RSTS/E V9.3]
;  003  KPH  22-Feb-86	Move out of RSTS phase
;
;-

.SBTTL	IRB AND BRIDGE BLOCK DEFINITIONS

; DEFINE IRB

.DSECT

IRBFUN:	.BLKW		;FUNCTION CODE & ITS MODIFIER
IRBSTA:	.BLKW		;STATUS
IRBCHN:	.BLKB		;CHANNEL #
IRB18M:	.BLKB		;MS 2 BITS OF 18 BIT UNIBUS ADDR OF DATA WITHIN BUF
IRB18L:	.BLKW		;LS 16 BITS OF 18 BIT UNIBUS ADDR OF DATA WITHIN BUF
IRBMOD:	.BLKW		;DATA MODIFIER
IRBCON:	.BLKW		;CONTROTED ADDR FOR BIG BUF
IRBNXT:	.BLKW		;LINK TO NEXT IRB (IF CHAINED)
IRBBFL:	.BLKW		;DATA LENGTH IN THE BIG BUF
IRBPAR:	.BLKW		;PARAMETERS PASSING OVER (MAY BE MORE THAN ONE)

; DEFINE FUNCTION CODE

PUTFCN	=	0*400	;FUNCTION PUT
OPNFCN	=	2*400	;FUNCTION OPEN
CLSFCN	=	4*400	;FUNCTION CLOSE
XKSMLB	=	377*400	;FUNCTION SMALL BUUFER PUT
FWDABT	=	201	;FUNCTION SUB-MODIFIER - FORWARD ABORT REQUEST

; DEFINE BRIDGE BLOCK

.DSECT

BBSTS:	.BLKB		;BB STATUS
BBDOFF:	.BLKB		;DATA OFFSET
BBGIRB:	.BLKW		;SUBROUTINE ADDR TO GET IRB/BIG BUF
BBASND:	.BLKW		;SUBROUTINE ADDR TO SEND IRB/BIG BUF
BBAAP5:	.BLKW		;APR5 VALUE FOR THE ABOVE SUBROUTINES
BBDUNT:	.BLKB		;DEVICE CONTROLLER #
BBAUNT:	.BLKB		;AUX PROCESSOR CONTROLLER #
BBDSTA:	.BLKW		;SUBROUTINE ADDR FOR STATUS CHANGED
BBDINT:	.BLKW		;SUBROUTINE ADDR FOR BB INTERRUPT
BBDAP5:	.BLKW		;APR5 VALUE FOR THE ABOVE SUBROUTINES
BBLSTP:	.BLKW		;LST POINTER
BBOCNT:	.BLKB		;PENDING OUTPUT COUNT

.SBTTL	LSTDEF -- LINK STATUS TABLE ENTRY DEFFINITION

; THERE ARE TWO ENTRY FOR EACH LINK IN THE LINK STATUS TABLE.
; ONE FOR OUTPUT AND ONE FOR INPUT.
; LAST ENTRY IN THE TABLE HAS A TERMINATOR (377) IN THE STATUS FIELD.

.DSECT

LSTTER:	.BLKB		;LOGICAL LINK IDENTIFICATION
LSTSTS:	.BLKB		;LOGICAL LINK STATUS
LSTIRB:	.BLKW		;HEADER OF INPUT/OUTPUT IRB CHAIN
LSTSIZ:			;SIZE OF AN LST ENTRY

; DEFINE STATUS IN LSTSTS FOR OUTPUT

DATOUT	=	1	;DATA TO BE OUTPUT
OUTDON	=	2	;OUTPUT DATA DONE WITH "ACK" IN
EOTOUT	=	3	;SEND EOT
SETDTR	=	5	;SET DTR
LERROR	=	6	;LINE IN ERROR
RVIIN	=	10	;OUTPUT DATA DONE WITH "RVI" IN
CLRDTR	=	11	;DROP DTR
DATTOU	=	21	;DATA TO BE OUTPUT IN TRANSPARENCY
ENDLST	=	377	;END OF LST ENTRY

; DEFINE STATUS IN LSTSTS FOR INPUT

GIVBAK	=	2	;GIVE BACK IRB/BIG BUFF TO RSTS/E (INPUT)
DATAIN	=	4	;RCVD DATA
GETBUF	=	6	;GO AND GET SOME FREE IRB/BIG BUFF
EOTIN	=	12	;EOT RECEIVED
DATTIN	=	14	;TRANSPARENT DATA RECEIVED
LINSIC	=	200	;LINE SICK/NAK OVERFLOW
LINTOT	=	300	;LINE SICK/TIMED OUT

.SBTTL	LOADER HEADER DESCRIPTOR

; A LOADER HEADER DESCRIPTER APPEARS AT THE BEGINNING OF EACH LOAD
; REQUEST FOR THE KMC-11.

.DSECT

LHDMET:	.BLKB		;TYPE OF MEMORY
LHDNWD:	.BLKB		;# OF PDP-11 WORDS TO LOAD INTO THE KMC-11
LHDPGN:	.BLKB		;PAGE # IN KMC-11 TO LOAD INTO
LHDDIS:	.BLKB		;DISPLACEMENT IN PAGE (IN KMC-11 WORDS) TO LOAD FROM
LHDSIZ:			;SIZE OF LHD

; DEFINE TYPE OF MEMORY

CRAM	=	0	;FOR CRAM MEMORY IN KMC-11
RAM	=	1	;FOR RAM MEMORY IN KMC-11

; SOME MISCELLANEOUS CONSTANTS FOR XKDVR

LOADMD	=	1	;LOAD MODE
DEBGMD	=	2	;DEBUG MODE
CTLMD	=	4	;CONTROL MODE

.IF	DF DE$BUG

	.MACRO	MPXIN	VAL
	JSR	R4,MPX4
	.WORD	VAL
	.ENDM


	.SBTTL 	LOCAL DEBUG SYMBOL DEFFINITIONS

NBRKS = 8.	;# OF KMC-11 BREAKPOINTS
BRKCSR = 1	;CSR FOR BRKPNT COMMUNICATION
BRKVAL = 1	;BRKPNT VALUE IN BRKCSR
RAMSIZ = 1024.	;SIZE OF KMC-11 RAM MEMORY

; THE FOLLOWING ARE SOME KMC-11 PROTOTYPE INSTURCUTIONS

BRKPT0	=	114760	;JMP TO BRK 0 INSTRUCTION
BTOUT	=	061220	;MOVE BREG, OUT1 <CSR0>
MEMOUT	=	55220	;MOVE MEM,OUT1
OUTOB	=	120400	;MOVE INP1<CSR0> TO BREG
SPTOB	=	060600	;MOVE SP ADRESS  <0> TO BREG
MPJMP	=	100400	;ALWAYS TO 0
MPNOP	=	0	;NOP
IN0OUT	=	021000	;MOVE INPUT 0 TO OUTPUT 0
IN1OUT	=	122400	;MOVE INPUT 1 TO OUTPUT 1
IN1TOM	=	122400	;MOVE INP1 TO MEM
MARINC	=	014000	;INC MAR
MARLOD	=	010000	;LOAD MAR
LITOB	=	000400	;LOAD BRG
BTOSP	=	063220	;MOVE BRG TO SP <0>
MARLDX	=	004000	;LOAD EXTENDED MAR
IN8OUT	=	121200	;MOVE INP1 <8> TO OUT1<0>

; SOME CSR1 BIT SETTINGS FOR DEBUG....

MPRUN	=	100000	;RUN BIT
MPINI	=	040000	;INIT THE DEVICE
MPIIN	=	001000	;MICRO INSTRUCTION FROM INPUT CSR6
MPSTEP	=	000400	;SINGLE STEP BIT

.ENDC

; DEFINE OFFSET IN CSR OF KMC-11

BSEL0=0
BSEL1=1
BSEL2=2
BSEL3=3
BSEL4=4
BSEL5=5
BSEL6=6
BSEL7=7
BSEL8=10

	DEFORG	XKDVRM							;003

; JUMP TABLE FOR DEBUG WORK

DEBSTA:

	.WORD	DBSEXC	;TO START EXECUTION	VALUE = 0
	.WORD	DBSTOP	;STOP ROUTINE		VALUE = 1

.IF	DF, DE$BUG

	.WORD	BRKRTN	;BREAKPOINT TEST RTN	VALUE = 2
	.WORD	DISEXC	;GO TO DISPLAY EXEC	VALUE = 3
	.WORD	SETEXC	;GOTO SET EXEC		VALUE = 4
	.WORD	MPSNGL	;GO SINGLE CYCLE	VALUE = 5
	.WORD	MPPROC	;GO PROCEED		VALUE = 6
	.WORD	ZEREXC	;GOTO ZERO EXEC    	VALUE = 7

.ENDC
 
MAXDEB=<.-DEBSTA/2>

; JUMP TABLE FOR DEBUG DISPLAY ROUTINES

.IF	DF,DE$BUG

DISSTA:
	.WORD	MPBRKS	;DISPLAY BREAKPOINTS	VALUE = 0
	.WORD	MPIOB	;DISPLAY I/O BUS	VALUE = 1
	.WORD	MPREG	;DISPLAY SCRATCHPADS	VALUE = 2
	.WORD	MPDCAM	;DISPLAY  CRAM LOCATION	VALUE = 3
	.WORD	MPLIST	;DISPLAY DATA RAM	VALUE = 4
DEBDIL=<.-DISSTA/2>	;NUMBER OF ENTRIES

; ZERO JUMP TBL

ZERSTA:
	.WORD	MPZRAM	;ZERO DATA RAM		VALUE = 0
DEBZIL=<.-ZERSTA/2>

; SET STATUS JUMP TBL

SETSTA:
	.WORD	MPSEBK	;SET BREAKPOINT		;VALUE = 0
	.WORD	0
	.WORD	MPWSP	;SET A SCRATCHPAD	;VALUE = 2
	.WORD	MPWCAM	;WRITE A CRAM LOCATION	;VALUE = 3
	.WORD	MPWRAM	;SET DATA RAM		;VALUE = 4
DEBSIL=<.-SETSTA/2>

.ENDC			; ** SPC 8/17/78 **

.SBTTL	KMC-11 OPEN SERVICE

;+
; OPN$XK - KMC-11 OPEN SERVICE
;
;	R0 = UNIT # * 2
;	R1 -> XKDDB (MUST BE PRESERVED)
;	R4 -> FIRQB (DEFAULT FQFLAG AND FQBUFL VALUE LOADED)
;	R5 -> JOB IOB ENTRY (MUST BE PRESERVED)
;
;	...
;
;	RETURN
;
;	- OR -
;
;	CALLX	RETDEV
;	ERROR	CODE
;-

	TMPORG	XKDISP,2						;003
	 .WORD	OPN$XK							;003
	UNORG								;003

OPN$XK:									;003
	MOV	FQMODE(R4),R3	;R3 = OPEN MODE
	BPL	5$		;IT BIT 15 IS CLEAR, NO MODE SPECIFIED...

; BEFORE WE CHECK MODE, LET'S SEE IF THE USER HAS THE PRIVELEGE TO DO
; ANYTHING OR NOT!

	MOV	R0,-(SP)	;Save a register			;002
	MOV	R5,-(SP)	; and another				;002
	MOVB	FQJOB(R4),R0	;Get job * 2				;002
	CALLX	CHKPRV,R4						;002
	 .BPRIV	HWCTL		;Check for hardware control privs	;002
	MOV	(SP)+,R5	;Restore regs first			;002
	MOV	(SP)+,R0	; and another				;002
	BCC	2$		;Skip if ok				;002
	CALLX	RETDEV		;OTHERWISE, RETURN AS PRIVILEGE VIOLATION...
	ERROR	PRVIOL
2$:	
	CMP	#100000!LOADMD,R3 ;LOAD MODE?
	BEQ	10$		;YES, GOTO COMMON CODES...
	CMP	#100000!DEBGMD,R3 ;DEBUG MODE?
	BEQ	10$		;YES, GOTO COMMON CODES...
	CMP	#100000!CTLMD,R3 ;CONTROL MODE?
	BEQ	15$		;YES...
5$:	CALLX	RETDEV		;TOO BAD, WE DO'NT HAVE A LEGAL MODE
	ERROR	MODERR

; HERE, WE HAVE CHECKED FOR PRIVILEGE AND OPEN MODE.
; LET'S MAKE SURE THAT WE HAVE BEEN CONNECTED..

10$:
	BIT	#XKCON,XKSTS(R1) ;HAVE WE BEEN CONNECTED?
	BEQ	20$		;IF NOT, ERROR
15$:	MOVB	R3,DDFLAG(R1)	;WE WILL REMEMBER THE OPEN MODE INTO DDB
	RETURN			;HAPPY RETURN....
20$:	CALLX	RETDEV
	ERROR	NOTAVL		;RETURN AS NOT AVAILABLE....

	GLOBAL	<DEV.XK,CSR.XK,EXTPOL,JOBTBL>

.SBTTL	DEVICE ASSIGNMENT SERVICE

;+
; ASN$XK - DEVICE ASSIGNMENT SERVICE FOR KMC-11
;
; IF CALL BY A JOB
;
;	R0 =  JOB NUMBER OF ASSIGNER TIMERS 2
;	R1 -> DDB
;
;	...
;
;	RETURN		(WITH ALL REGISTERS PRESERVED)
;
; IF CALL BY UUO HANDLER
;
;	R0 -> BRIDGE BLOCK
;	R1 -> DDB
;
;	...
;
;	RETURN		(WITH ALL REGISTERS PRESERVED)
;-

	TMPORG	XKDISP,6						;003
	 .WORD	ASN$XK							;003
	UNORG								;003

ASN$XK:									;003
	BIT	(PC)+,R0	;CALLED BY A JOB?
	.BYTE	0,-1
	BEQ	10$		;IF MSB IS ZERO, IT IS A JOB...
	MOV	#GETIRB,BBGIRB(R0) ;FILL IN "GETIRB" ROUTINE ADDR
	MOV	#SNDKMC,BBASND(R0) ;FILL IN "SNDKMC" ROUTINE ADDR
				;UUO HANDLER SHOULD MOVE BB ADDR INTO DDB FOR
				;  ME IN ADDITION TO SET "XKCON" IN XKSTS.
10$:

.SBTTL	DEVICE DEASSIGNMENT SERVICE

;+
; DEA$XK - DEVICE DEASSIGNMENT SERVICE FOR KMC-11
;
;	R1 -> DDB
;
;	...
;
;	RETURN		(WITH ALL REGISTERS PRESERVED)
;-

	TMPORG	XKDISP,12						;003
	 .WORD	DEA$XK							;003
	UNORG								;003

DEA$XK:									;003
	.BR	TMO$XK		;Nothing to do here			;003

.SBTTL	TIMEOUTS

;+
; TMO$XK - TIME OUT SERVICE.
;
;	R0 =  UNIT NUMBER TIMES TWO
;	R1 -> DDB
;	R3 -> CSR
;	PRIORITY IS PR5
;
;	...
;
;	RETURN
;-

	TMPORG	XKDISP,16						;003
	 .WORD	TMO$XK							;003
	UNORG								;003

TMO$XK:	RETURN			;WE SHOULD NOT COME HERE ANYWAY...	;003

.SBTTL	USER LEVEL SERVICE

;+
; SER$XK - KMC-11 USER LEVEL SERVICE.
;
;	R0 =  UNIT # * 2
;	R1 -> XKDDB
;	R2 =  2 (.READ)
;	      4 (.WRITE)
;	R3 -> XRB
;	R4 =  CALLING JOB # * 2
;	R5 -> USER'S BUFFER THRU APR6
;-

	TMPORG	XKDISP,22						;003
	 .WORD	SER$XK							;003
	UNORG								;003

SER$XK:
	CMPB	#LOADMD,DDFLAG(R1) ;HAS WE OPENED FOR LOADING?
	BEQ	1$		;YES, GO AND LOAD MICOR-CODES...
	JMP	DEBUG		;OTHERWISE, TAKE CTL AND DEBUG AS THE SAME...
1$:
	CMP	#.WRITE&377,R2	;IS IT A WRITE REQUEST?
	BEQ	3$		;YES, THAT IS GOOD...
	ERROR	EOF		;RETURN AS EOF ERROR....
3$:
	MOV	CSR.XK(R0),R0	;R0 -> 1ST CSR OF KMC-11
	CMPB	#RAM,LHDMET(R5)	;ARE WE LOADING RAM MIRCO-CODES?
	BEQ	RAMLD		;YES, LET'S GO....

; HERE, WE HAVE CRAM TO LOAD
;	R0 -> CSR
;	R1 -> XKDDB
;	R3 -> XRB
;	R5 -> USER'S BUFFER THRU APR6

	BIT	#XKRUN,XKSTS(R1) ;IS KMC RUNNING?
	BEQ	4$		;NO, THAT IS GOOD...
	ERROR	INUSE		;OTHERWISE, RETURN AS ERROR
4$:	MOV	XRMOD(R3),R4	;R4 = PRODUCT ID
	CMP	#XKRLDR,R4	;IS IT RAMLDR?
	BEQ	6$		;YES...
	MOV	XKPRID(R1),-(SP) ;CHECK FOR PRODUCT ID THEN
	BIC	#XKRLDR,(SP)	;MAKE SURE WE DON'T COUNT XKRLDR BIT
	CMP	R4,(SP)+	;ARE THEY THE SAME?
	BEQ	6$		;YEP...
	ERROR	PRVIOL		;RETURN AS PROTECTION VIOLATION
6$:	MOVB	LHDPGN(R5),R3	;R3 = KMC-11 CRAM PAGE TO LOAD
	MUL	#400,R3		;R3 = PHYSICAL CRAM ADDR OF THE PAGE TO LOAD
	MOVB	LHDDIS(R5),R2	;R2 = DISP WITHIN THE PAGE TO START
	BIC	(PC)+,R2	;NO SIGN EXTENTION
	.BYTE	0,-1
	ADD	R2,R3		;R3 = PHYSICAL CRAM ADDR TO START TO LOAD
	MOVB	LHDNWD(R5),R2	;R2 = # OF WORDS TO LOAD
	BIC	(PC)+,R2	;NO SIGN EXTENTION
	.BYTE	0,-1
	BNE	10$		;IF NOT ZERO, THAT IS...
	MOV	#400,R2		;OTHERWISE, SET IT TO 256 WORDS TO LOAD
10$:	ADD	#LHDSIZ,R5	;R5 -> MICRO-CODES TO LOAD THRU APR6

; AT THIS TIME, WE HAVE:
;	R0 -> 1ST CSR OF KMC-11
;	R2 = # OF WORDS TO LOAD
;	R3 = PHYSICAL CRAM ADDR TO START TO LOAD
;	R4 = PRODUCT ID
;	R5 -> MICRO-CODES TO LOAD IN USER'S BUF THRU APR6

CRAMLD:
	MOV	#2000,(R0)	;SELECT CRAM MEMORY
	MOV	R3,4(R0)	;LOAD LOAD ADDR
	MOV	(R5),6(R0)	;MOVE MICRO INSTRUCTIONS
	BIS	#20000,(R0)	;SET IT IN HOPEFULLY
	CLR	(R0)		;CLEAR CSR
	CLR	4(R0)
	CLR	6(R0)

; THE MICRO INSTRUCTION SHOULD BE IN CRAM AT THIS TIME, WE WILL READ IT
; OUT AND SEE IF WE HAVE THE SAME AS WHAT WE LOADED.

	MOV	#2000,(R0)	;SELECT CRAM MEMORY
	MOV	R3,4(R0)	;MOVE LOAD ADDR
	CMP	(R5)+,6(R0)	;ARE THEY THE SAME?
	BNE	BADLD		;NO, HARDWARE PROBLEM, GO AND REPORT IT....
	INC	R3		;NEXT CRAM LOCATION
	SOB	R2,CRAMLD	;LOOP UNTIL DONE...

; HOW WONDERFUL WE GOT HERE, WE HAVE JUST FINISH LOADING OF CRAM
; LET'S REMEMBER THE PRODUCT ID INTO XKDDB.

	CMP	#XKRLDR,R4	;IS IT RAMLDR?
	BEQ	3$		;YES
	MOV	R4,XKPRID(R1)	;RESET TO THE ORIGINAL PRODUCT ID
3$:	BIS	R4,XKPRID(R1)	;REMEMBER WHAT WE HAD LOADED
	MOV	#XKLOAD!XKCON,XKSTS(R1) ;SET STATUS TO "XKLOAD & XKCON"

.IF	DF DE$BUG

	MOV	#-1,XKCADR	;NO BRK HITTED				;003
	MOV	#NBRKS,R4	;R4 = # OF BREAKS PTS
	CLR	R5		;R5 IS BRK INDEX
5$:
	MOV	#-1,XKADR1(R5)	;RESET ALL BRK PTRS			;003
	TST	(R5)+
	SOB	R4,5$		;LOOP UNTIL DONE...

GLOBAL	<XKCADR,XKADR1>							;003

.ENDC

	JMPX	IOEXIT		;EXIT BACK TO THE USER....	

; HERE, WE HAVE RAM TO LOAD

RAMLD:
	MOV	R1,-(SP)	;SAVE XKDDB ONTO STACK
	MOV	XRBC(R3),R1	;GET # OF CHAR TO LOAD
	ADD	#10,R1		;R1 = # OF CHAR TO LOAD + HEADER
	MOV	#60.,R2		;LET'S SAY WE LEAVE 60 SMALL BUF IN POOL
	CALLX	BUFFER,R5,EXTPOL ;GET BUFF FROM EXTENDED POOL
	BCC	2$		;IF CC, WE GOT THE BUFFER...
	TST	(SP)+		;REMOVE XKDDB ADDR FROM STACK
	ERROR	NOBUFS		;OTHERWISE, RETURN AS NO BUF ERROR....
2$:
	MOV	R0,-(SP)	;SAVE XKCSR ADDR INTO R0 TOO
	MOV	R1,R0		;R0 = ROUNDED UP SIZE OF BIG BUFF
	MOV	XRBC(R3),R2	;GET # OF CHAR TO LOAD INTO R2

; WE HAVE SET UP CALLING PARAMETERS AS FOLLOWING:
;	R0 = LENGTH OF EXTENDED BUFFER
;	R2 = # OF BYTES TO MOVE
;	R4 = CONTROTED BUFFER ADDR OF BIG BUFFER
;	R5 -> USER BUFF THRU APR6

	CALLX	BLKMOV		;CALL FOR EXECUTIVE FOR MOVE SERVICE.... ;003
	CALL	CAL18B		;CALCULATE PHYSICAL ADDR FOR BIG BUF
				;18 BIT ADDR RETURNED IN R2 AND R3
	MOV	(SP)+,R0	;RESTORE KMC-11 CSR ADDR
	MOV	(SP)+,R1	;RESTORE XKDDB ADDR
	MOV	R3,BSEL4(R0)	;MOVE LOW ORDER 16 BIT ADDR
	MOVB	R2,BSEL6(R0)	;MOVE HIGH ORDER 2 BIT ADDR
	MOV	#201,BSEL2(R0)	;INDICATE TO RAMLDR PROG IN CRAM THAT
				;WE HAVE SOMTHING TO LOAD INTO RAM
	MOV	#10000.,R5	;SET UP COUNT TO LOOP ON
12$:	TSTB	BSEL2(R0)	;DONE?
	BNE	15$		;NO, TRY AGAIN

; WE HAVE BEEN INFORMED THAT THE LOADING OF RAM WAS DONE!!!

	BUFFER	RETURN		;RETURN BIG BUFFER
	JMPX	IOEXIT		;RETURN TO USER
15$:
	SOB	R5,12$		;CONT POLLING...

; HARDWARE ALWAYS DOES NOT WORK RIGHT, ANYWAY, WE WILL SET KMC-11 AS DEAD.
; REPORT ERROR BACK TO LOADER PROG.

	BUFFER	RETURN		;RETURN BIG BUFFER
BADLD:
	BIS	#XKDEAD,XKSTS(R1) ;SET STATUS TO KMC DEAD
	ERROR	ABORT		;ERROR REPORT TO USER

.SBTTL	CLOSE SERVICE

;+
; CLS$XK - KMC-11 CLOSE SERVICE.
;
;	R0 = UNIT # * 2
;	R1 -> XKDDB
;	R5 -> XKDDB (MUST BE PRESERVED)
;
;	...
;
;	RETURN
;-

	TMPORG	XKDISP,26						;003
	 .WORD	CLS$XK							;003
	UNORG								;003

CLS$XK:									;003
	CLRB	DDFLAG(R1)	;CLEAR OPEN MODE
	RETURN			;RETURN TO USER

.SBTTL	SPECIAL FUNCTION SERVICE

;+
; SPC$XK - SPECIAL FUNCTION SERVICE FOR KMC-11.
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB/FCB
;	R2 =  SPECIAL FUNCTION CODE
;	R3 -> XRB
;	R4 =  CALLING JOB NUMBER TIMES 2
;	R5 -> (MAPPED) XRB
;
;	...
;
;	JMP	RTI3
;
;	-OR-
;
;	ERROR	CODE
;-

	TMPORG	XKDISP,32						;003
	 .WORD	SPC$XK							;003
	UNORG								;003

SPC$XK:									;003
	ERROR	PRVIOL		;NO SPECIAL FUNCTION SERVICE

.SBTTL	SNDKMC -- ENTRY POINT FROM USER'S LEVEL INTERFACE DRIVER

;+
; SNDKMC - ENTRY POINT FROM USER'S LEVEL INTERFACE FRIVER.
;
;	R0 =  UNIT NUMBER TIMES 2 (WITHIN THE CONTROLLER)
;	R1 -> DDB OF USER'S LEVEL INTERFACE DRIVER
;	R2 -> IRB OR 0
;	R3 =  FUNCTION CODE (IF R2 = 0)
;		BIT 15 = 0
;		      201	FORWARD ABORT
;			2	RETURN RCVD BUFFER
;		BIT 15 = 1
;			LSB	NEW MAX # OF RCVD BUFFERS
;	R4 -> BRIDGE BLOCK
;
;	...
;
;	RETURN		(WITH ALL REGISTERS PRESERVED)
;	C = 0 => OK
;	C = 1 => FAILURE
;-

SNDKMC:
	REGSCR			;SAVE ALL REGISTERS
	MOVB	BBAUNT(R4),R1	;R1 = XK UNIT #
	ASL	R1		;R1 = XK UNIT # * 2
	MOV	DEV.XK(R1),R1	;R1 -> XKDDB
	TST	R2		;DO WE HAVE AN IRB?
	BNE	8$		;YEP...
	TST	R3		;A NEW MAX # OF RCVD BUFF?
	BPL	5$		;NOOP...
	MOVB	R3,XKMRBF(R1)	;YEP, REMEMBER IT IN XKDDB
	;CLC			;CLEAR C BIT
	RETURN			;EXIT.....

5$:	CMP	#2,R3		;IS IT A SIGNAL OF RCVD BUFF RETURN?
	BNE	8$		;NOOP...
	DECB	XKCRBF(R1)	;YEP, UPDATE CURRENT # OF RCVD BUFF ALLOCATED
	BR	GBUF		;GO TO SERVICE THE FREE IRB CHAIN...

8$:	BIT	#XKRUN,XKSTS(R1) ;IS KMC-11 RUNNING?
	BNE	10$		;YES, THAT IS GOOD
	SEC			;SET C BIT
	RETURN			;RETURN TO CALLER....
10$:
	MOV	R0,R1		;R1 = LINE #
	MUL	#LSTSIZ,R1	;R1 = OFFSET TO ENTRY IN LST FOR THE LINE
	ADD	BBLSTP(R4),R1	;R1 -> ENTRY IN LST FOR THE LINE
	MOV	@#PS,-(SP)	;SAVE CURRENT PSW
	SPLC	5		;;DISABLE INTERRUPT
	TST	R2		;;IS R2 PTR TO AN IRB?
	BNE	20$		;;YES, GOTO 20$
	MOV	LSTIRB(R1),R2	;;R2 -> 1ST IRB ON THE CHAIN
	BEQ	70$		;;IF THERE IS NO IRB ON THE CHAIN, EXIT...
	BISB	R3,(R2)		;;SET SUB-FUNCTION CODE IN THE IRB
	BR	70$		;;AND EXIT...
20$:
	MOV	LSTIRB(R1),R3	;;IS THERE ANY IRB WAITING?
	BNE	50$		;;YES, LET'S CHAIN DOWN
	MOV	R2,LSTIRB(R1)	;;NO, SO JUST QUEUE THIS ONE
	CMPB	#XKSMLB/400,IRBFUN+1(R2) ;;IS IT SMALL BUF WITH O/P DATA ONLY?
	BNE	40$		;;NOOP...
	MOVB	#DATOUT,LSTSTS(R1) ;;SET STATUS
	BR	70$		;;GOTO COMMON CODES...
40$:	MOVB	(R2),R3		;;GET FUNCTION MODIFIER
	BIS	#DATOUT,R3	;;IT MUST BE DATOUT ANYWAY
	MOVB	R3,LSTSTS(R1)	;;SET STATUS
	BR	70$		;;GOTO COMMON CODES...
50$:
	MOV	R3,R4		;;MAKE A COPY INTO R4
	MOV	IRBNXT(R4),R3	;;R3 -> NEXT IRB
	BNE	50$		;;IF NE, CONT...
	MOV	R2,IRBNXT(R4)	;;ADD IRB TO END OF CHAIN
70$:
	MOV	(SP)+,@#PS	;RESTORE PSW

; EXIT HAPPILY

80$:	CLC			;CLEAR C BIT
	RETURN			;EXIT....

.SBTTL	INTERRUPTS AT VECTOR XX0

;+
; INT$XK - INTERRUPTS FOR KMC-11 AT VECTOR XX0
;
;	R0 =  UNIT NUMBER TIMES TWO
;	PRIORITY IS PR5
;
;	...
;
;	RETURN
;-

	TMPORG	XKDINT,6						;003
	 .WORD	INT$XK							;003
	UNORG								;003

INT$XK:									;003
	MOV	DEV.XK(R0),R1	;R1 -> APPRO XKDDB
	MOV	R1,R5		;R5 -> APPRO XKDDB
	ADD	#XKBBP,R5	;R5 -> START OF BRIDGE BLOCK POINTERS
	MOV	#MAXBBP,R2	;R2 = MAX # OF BB PTR ENTRIES
1$:
	MOV	(R5),R4		;R4 -> BRIDGE BLOCK
	BEQ	12$		;IF ZERO, END OF BB PTRS...
	MOV	BBLSTP(R4),R3	;R3 -> LST
3$:	MOVB	LSTSTS(R3),R0	;R0 = OUTPUT STATUS
	BEQ	4$		;IF ZERO, FREE ENTRY
	CMP	#-1,R0		;END OF LST?
	BEQ	10$		;YEP...
	BIT	#1,R0		;IS LSB SET?
	BNE	4$		;YES, DATA OUT STATUS, JUST BYPASS
	CALL	XMIT		;SERVICE X'MIT LST
4$:
	ADD	#LSTSIZ,R3	;TRY INPUT LST
	MOVB	LSTSTS(R3),R0	;R0 = INPUT STATUS
	BEQ	7$		;IF ZERO, FREE ENTRY
	CALL	RCVD		;SERVICE RCVD LST
7$:
	ADD	#LSTSIZ,R3	;SKIP TO NEXT LST ENTRY (NEXT LINE)
	BR	3$		;GO AGAIN...
10$:
	TST	(R5)+		;SKIP TO NEXT ENTRY
	SOB	R2,1$		;LOOP UNTIL DONE...
12$:
	BR	GBUF		;TRY TO SERVICE FREE BUFFER CHAIN
				;AND RETURN

; DISPATCH SERVICE FOR X'MIT STATUS

XMIT:	REGSCR			;SAVE ALL REGISTERS
	TST	R0		;TIME-OUT ERROR?
	BPL	10$		;IF POSITIVE, NO ERROR...
	CMPB	#210,R0		;IS IT 3 NAKS/TIMOUTS ERROR?
	BEQ	TIMOUT		;YEP...
	CMPB	#220,R0		;IS IT LINE ERROR (NO DSR OR DTR)
	BEQ	DISIMM		;YEP, DISC IMM...
	BR	ERROVR		;OTHERWISE, IT IS ERROR COUNT OVERFLOWED...
10$:	ADD	R0,PC		;GO TO APPROPRIATE SERVICE RTN...
	 RETURN			;STATUS = 0, NOTHING TO DO
	 BR	TDONE		;STATUS = 2, OUTPUT DONE WITH "ACK" IN
	 RETURN			;STATUS = 4, RESERVED
	 BR	TERROR		;STATUS = 6, OUTPUT ERROR
	 BR	INRVI		;STATUS = 10, OUTPUT DONE WITH "RVI" IN
	 RETURN			;STATUS = 12, RESERVED
	 RETURN			;STATUS = 14, RESERVED
	 BR	INSTX		;STATUS = 16, OUTPUT DONE WITH "STX" IN

; DISPATCH SERVICE FOR RCVD STATUS

RCVD:	REGSCR			;SAVE ALL REGISTERS
	TST	R0		;LINE ERROR?
	BPL	10$		;NOOP...
	CALL	GIVIT		;GIVE THE BUFFER BACK FIRST OF ALL
	JMP	SICLIN		;THEN REPORT LINE IN SICK...
10$:	ADD	R0,PC		;DISPATCH TO APPROPRIATE SERVICE RTN...
	 RETURN			;STATUS = 0, NOTHING TO DO
	 BR	GIVIT		;STATUS = 2, GIVE BACK BUFFERS
	 BR	BUFIN		;STATUS = 4, DATA FROM IBM
	 BR	SRVBUF		;STATUS = 6, SERVICE FREE IRB/BIG BUF CHAIN
	 RETURN			;STATUS = 10, RESERVED
	 BR	INEOT		;STATUS = 12, EOT RECEIVED
	 BR	BUFIN		;STATUS = 14, DATA FROM IBM IN X'PARENCY

.SBTTL	SRVBUF -- SERVICE FREE IRB CHAIN

SRVBUF:	CLRB	LSTSTS(R3)	;CLEAR STATUS
	.BR	GBUF		;FALL THROUGH

.SBTTL	GBUF   -- FREE IRB CHAIN MAINTAINCE SERVICE

;+
; GBUF - FREE IRB CHAIN MAINTAINCE SERVICE.
;
;	R1 -> XKDDB
;
;	...
;
;	RETURN
;-

GBUF:
	MOV	R1,R3		;R3 -> XKDDB
	MOVB	XKBNO(R3),R5	;R5 = # OF FREE IRB NEEDED
	BEQ	10$		;IF EQ, NO NEED TO MAINTAIN FREE IRB CHAIN...
	MOV	XKIRBH(R3),R1	;GET IRB CHAIN 
	BEQ	4$		;IF EQ, WE GOT NO MORE...
1$:
	DEC	R5		;REMEMBER WE GOT ONE
	BEQ	10$		;IF EQ, WE GOT ALL WE NEED....
	MOV	IRBNXT(R1),R1	;R1 = NEXT IRB IN THE CHAIN
	BNE	1$		;IF NE, ONE MORE...

; WE DO'NT HAVE ENOUGH IRB'S IN THE CHAIN, LET'S GO AND GET SOME

4$:
	CMPB	XKMRBF(R3),XKCRBF(R3) ;CAN WE ALLOCATE MORE RCVD BUFF?
	BLOS	10$		;NOOP...
	MOVB	XKBSIZ(R3),R2	;R2 = # OF BYTES FOR EXTEND BUFFER/100
	BIC	#177400,R2	;MAKE SURE IT DOES'NT HAVE SIGN EXTENSION
	ASH	#6,R2		;R2 = # OF BYTES FOR EXTEND BUFFER
	CALL	GETIRB		;WE WILL GO AND GET ONE
	BCS	10$		;IF CS, NO BUFFER AVAILABLE
	MOV	XKIRBT(R3),R0	;R5 -> LAST IRB IN THE CHAIN
	BNE	7$		;IF NE, REAL POINTER...
	MOV	R2,XKIRBT(R3)	;OTHERWISE, FAKE POINTER, MADE IT 1ST ONE
	MOV	R2,XKIRBH(R3)
	BR	8$
7$:	MOV	R2,XKIRBT(R3)	;ADJUST TAIL POINTER
	MOV	R2,IRBNXT(R0)	;CHAIN TO THE IRB CHAIN
8$:	INCB	XKCRBF(R3)	;ONE MORE RCVD BUFF ALOCATED
	SOB	R5,4$		;GO UNITL WE GOT ALL...
10$:
	RETURN

.SBTTL	TIMOUT -- TIME-OUT ON TRANSMISION

;+
; IF THE SUB-FUNCTION BYTE HAS BEEN MARKED AS FORWARD ABORT, THE WHOLE
; IRB CHAIN WILL BE RETURNED TO THE SLAVE DEVICE DRIVER. OTHERWISE, JUST
; REPORT IT.
;-

	.ENABL	LSB

TIMOUT:
	MOV	LSTIRB(R3),R2	;R2 ->IRB
	BEQ	7$		;IF ZERO, NO IRB
	TSTB	(R2) 		;HAS IT BEEN MARKED AS FORWARD ABORT?
	BMI	5$		;YES, RETURN THE WHOLE CHAIN...
	MOV	R2,R5		;MAKE A COPY OF IRB ADDR INTO R5
	CLR	R2		;OTHERWISE, MARK AS NO IRB
	BR	3$		;GOTO 3$...

.SBTTL	DISIMM -- DISCONNECT IMM

;+
; KMC-11 WILL SET LST STATUS TO 220 IF IT FOUND OUT THAT THE DTR/DSR
; IS OFF DURING RECEIVING OR TXACT IS OFF DURING TRANSMITTING.
; WE WILL FAKE A GIVBAK STATUS INTO THE RCVD LST AND RETURN THE WHOLE
; IRB CHAIN IN XMIT LST.
;-

DISIMM:	MOVB	#GIVBAK,LSTSTS+LSTSIZ(R3) ;FAKE A GIVBAK STATUS
	MOV	LSTIRB(R3),R2	;R2 -> IRB IF ANY
	BR	5$

.SBTTL	TDONE  -- OUTPUT DATA DONE

;+
; TDONE - OUTPUT DATA DONE WITH "ACK" IN
; INRVI - OUTPUT DATA DONE WITH "RVI" IN
; INSTX - OUTPUT DATA DONE WITH "STX" IN
; ERROVR - OUTPUT "EOT" DONE WITH ERROR COUNTER OVERFLOWED
;
; WHEN A BLOCK OF DATA HAS BEEN OUTPUT, KMC-11 WILL INTERRUPT XKDVR
; AFTER SETTING THE LSTSTS TO "OUTDON", "RVIIN", "STXIN" OR "TIMOUT"
; FOR THE SPECIFIED LINE.
; THIS SUBROUTINE IS RESPONSIBLE TO UNCHAIN THE FIRST IRB OUT OF THE
; OUTPUT IRB CHAIN; SET APPROPRIATE STATUS INTO LSTSTS AND CALL THE
; CORRESPONDING USER LEVEL INTERFACE DRIVER FOR ATTENTION.
;
; IF THE SUB-FUNCTION BYTE HAS BEEN MARKED AS FORWARD ABORT, THE WHOLE
; IRB CHAIN WILL BE RETURNED TO THE CALLER.
;
;	R0 -> LST STATUS
;	R1 -> XKDDB
;	R3 -> LST
;	R4 -> BRIDGE BLOCK
;-


TDONE:
INRVI:
INSTX:
ERROVR:
	MOV	LSTIRB(R3),R2	;R2 -> IRB
	BEQ	7$		;IF ZERO, NO IRB
	CMPB	#XKSMLB/400,IRBFUN+1(R2) ;IS IT SAMLL BUF WITH O/P DATA ONLY?
	BEQ	5$		;YES, GOTO 5$...
	TSTB	(R2)		;HAS IT BEEN MARKED AS FORWARD ABORT?
	BMI	5$		;YES, GOTO 5$, RETURN THE WHOLE CHAIN...

	MOV	IRBNXT(R2),R5	;OTHERWISE, UNCHAIN THE 1ST IRB
	MOV	R5,LSTIRB(R3)	; LINK THE NEXT INTO LST
	BEQ	7$		;IF ZERO, NO MORE...
	CLR	IRBNXT(R2)	;CLEAR LINK WORD FORM IRB
3$:
	MOVB	(R5),R5
	BIS	#DATOUT,R5	;MUST BE DATOUT ANYWAY
	MOVB	R5,LSTSTS(R3)	;SET STATUS 
	BR	9$
5$:	CLR	LSTIRB(R3)	;NO CHAIN FOR SMALL BUF WITH O/P DATA ONLY
7$:	CLRB	LSTSTS(R3)	;SET STATUS TO "FREE"
9$:
	BR	SETUP		;GOTO SETUP COMMON CODES....

	.DSABL	LSB

.SBTTL	TERROR -- OUTPUT ERROR

;+
; TERROR - OUTPUT ERROR
;
;	R0 =  LST STATUS
;	R1 -> XKDDB
;	R3 -> LST
;	R4 -> BRIDGE BLOCK
;-

TERROR:
	MOVB	#DATOUT,LSTSTS(R3) ;RESET LSTSTS BACK TO "DATOUT"
	BR	SETUP		;GO TO SETUP COMMON CODES....

.SBTTL	GIVIT  -- GIVE BACK BUFFERS TO MONITOR

;+
; GIVIT - GIVE BACK BUFFERS TO MONITOR.
;
; GIVE BACK BUFFERS TO RSTS/E MONITOR
; BUFFERS INCLUDES EXTENDED BUFFER AND SMALL BUFFER
;
;	R0 =  LST STATUS
;	R1 -> XKDDB
;	R3 -> LST
;	R4 -> BRIDGE BLOCK
;
;	...
;
;	RETURN
;	  LSTSTS = 0
;	  ALL IRB/BUFFERS CHAINED OFF THIS LST HAVE BEEN GIVEN BACK TO MONITOR
;-
		
GIVIT:
	MOV	LSTIRB(R3),R2	;R2 -> IRB
	CLR	LSTIRB(R3)	;CLEAR IRB POINTER
	CLRB	LSTSTS(R3)	;STATUS = 0, NOTHING TO DO
	TST	R2		;A REAL IRB?
	BEQ	5$		;NO REALLY...

; SINCE THE MICROCODE FOR 3271, 2780/3780 EP DOES NOT CLEAR THE LINK WORD,
; WE HAVE TO CHECK IF THE KMC-11 IS DOING 3271 EMULATION.
; IF IT IS, WE WILL ASSUME THE LINK WORD IS INVALID....

	BIT	#<XK3271!XK2780!XK3780>,XKPRID(R1) ;IS IT KMC-3271, 2780/3780
	BEQ	2$		;NO
	CLR	IRBNXT(R2)	;IF IT IS, WE HAVE BETTER CLEAR IT
2$:
	MOV	IRBCON(R2),R4	;R4 = CONTROTED BUFFER ADDR
	BUFFER	RETURN		;RETURN BUFFER TO EXTENDED POOL
	MOV	R2,R4		;MAKE A COPY OF IRB ADDR INTO R4
	MOV	IRBNXT(R2),R2	;R2 -> NEXT IRB IN THE CHAIN
	BUFFER	RETSML		;RETURN SMALL BUFF TO MONITOR POOL
	DECB	XKCRBF(R1)	;ADJUST COUNTER FOR # OF RCVD BUFF USED
	TST	R2		;ANY MORE IRB IN THE CHAIN?
	BNE	2$		;YES, GO AGAIN...
5$:	RETURN			;NO, DONE....

.SBTTL	EOT-IN FROM IBM
.SBTTL	LINE SICK STATUS FROM IBM

;+
; EOT-IN
; LINE SICK / NAK OVERFLOWED OR TIMED OUT
;
;	R0 =  LSTSTS
;		EOT-IN	12
;		LINE SICK/NAK OVERFLOWED	200
;		LINE SICK/TIMED OUT		300
;	R1 -> XKDDB
;	R3 -> LST ENTRY
;	R4 -> BRIDGE BLOCK
;
;	...
;
;	CALLBB	BBDINT
;	RETURN
;-

.SBTTL	BUFIN  -- ROUTINE TO PROCESS AN INCOMING BUFFER FROM A KMC-11

;+
; BUFIN - INPUT SERVICE.
;
;	R0 =  LST STATUS
;	R1 -> XKDDB
;	R3 -> LST ENTRY
;	R4 -> BRIDGE BLOCK
;
;	...
;
;	CALLBB	BBDINT
;	RETURN
;-

BUFIN:
	MOV	LSTIRB(R3),R2	;R2 -> IRB
	MOVB	R0,IRBMOD(R2)	;REMEMBER LSTSTS IN IRBMOD FOR KMC-2780
INEOT:
SICLIN:
	CLR	LSTIRB(R3)	;GET IRB POINTER OUT OF LST
	CLRB	LSTSTS(R3)	;CLEAR LSTSTS

; NOW, WE WILL CALL THE USER LEVEL INTERFACE DRIVER
; FIRST OF ALL, WE HAVE TO SET UP ALL PARAMETERS IN THE REGISTERS:
;	R0 =  CONTROLLER # * 2 
;	R1 =  UNIT # * 2 WITHIN THE CONTROLLER
;	R2 -> IRB
;	R3 =  LST STATUS
;	R4 -> BRIDGE BLOCK
;-

SETUP:
	MOV	R3,R1		;R1 -> LST ENTRY
	MOV	R0,R3		;R3 =  LST STATUS
	SUB	BBLSTP(R4),R1	;R1 =  OFFSET TO ENTRY FROM TOP OF LST
	ASH	#-3,R1		;R1 =  UNIT # WITHIN THE CTR (LINE # )
	ASL	R1		;R1 =  UNIT # * 2 WITHIN THE CTL (LINE # * 2)
	MOVB	BBDUNT(R4),R0	;R0 =  CONTROLLER #
	ASL	R0		;R0 =  CONTROLLER # * 2
	CALLBB	BBDINT		;CALL USER'S LEVEL INTERFACE DRIVER
	RETURN			;AND RETURN

.SBTTL	INT4XK -- INTERRUPT SERVICE ROUTINE FOR VECTOR XX4

;+
; INT4XK - INTERRUPT SERVICE ROUTINE FOR VECTOR XX4
;
;	R0 = UNIT # * 2
;	PRIORITY IS PR5
;
;	...
;
;	RETURN
;-

	TMPORG	XKDINT,16						;003
	 .WORD	INT4XK							;003
	UNORG								;003

INT4XK:									;003
	MOV	DEV.XK(R0),R1	;R1 -> XKDDB
	MOV	R1,R5		;MAKE A COPY INTO R5
	ADD	#XKBBP,R5	;R5 -> START OF BRIDGE BLOCK PTRS
	MOV	#MAXBBP,R2	;R2 = MAX # OF BB PTR ENTRIES
1$:
	MOV	(R5),R4		;R4 -> BRIDGE BLOCK
	BEQ	12$		;IF ZERO, END OF BB PTR...
	MOVB	BBSTS(R4),R3	;WHAT IS THE STATUS OF XX4 VECTOR
	BEQ	10$		;IF ZERO, NOTHING TO DO WITH THIS BB...
	CALLX	REGSAV,R5	;SAVE ALL REGISTERS
	CLRB	BBSTS(R4)	;CLEAR THE STATUS
	MOVB	BBDUNT(R4),R0	;R0 = CONTROLLER #
	ASL	R0		;R0 = CONTROLLER # * 2
	BIS	#100000,R3	;R3 HAS BIT 15 SET TO IDENTIFY XX4 INTERRUPT
	CALLX	REGRES,R5	;RESTORE ALL REGISTERS
10$:
	TST	(R5)+		;GOTO NEXT SUB-DDB ENTRY
	SOB	R2,1$		;GO AGAIN...
12$:	RETURN			;WHEN DONE, JUST RETURN....

.SBTTL	GETIRB -- ROUTINE TO GET AN IRB/BIG BUFF

;+
; GETIRB - ROUTINE TO GET AN IRB/BIG BUFF
;
;	R2 =  REQUESTED BIG BUFFER SIZE IN BYTES
;
;	...
;
;	RETURN
;	  C = 0 => OK AND R2 -> IRB
;	  C = 1 => FAILURE
;	  ALL REGISTERS PRESERVED EXCEPT R2.
;-

GETIRB:
	REGSCR			;SAVE ALL REGISTERS
	BUFFER	GETSML		;TRY TO GET A SMALL BUFFER
	BVS	6$		;IF VS, NO MORE...
	MOV	R4,R0		;R0 -> SMALL BUFFER
	MOV	R2,R1		;R1 = # OF BYTES REQUESTED
	MOV	#-1,R2		;LEAVE NO ROOM IN POOL
	CALLX	BUFFER,R5,EXTPOL ;GET BIG BUFF FROM EXTPOL
	BCS	4$		;NO BUFFERS FOR US?
	MOV	R4,IRBCON(R0)	;MOVE CONTORTED BIG BUFFER ADR TO IRB
	CLR	IRBNXT(R0)	;CLEAR LINK WORD
	CALL	CAL18B		;CALCULATE PHYSICAL MEMORY ADDR
	MOVB	R2,IRB18M(R0)	;MOVE MS 2 BITS OF 18 BIT ADDR
	MOV	R3,IRB18L(R0)	;MOVE LS 16 BITS OF 18 BIT ADDR
	MOV	R0,TOS.R2(SP)	;SAVE IRB ADDR INTO SAVED R2 ON STACK
	CLC			;SIGNAL SUCESSFUL
	RETURN			;HAPPY RETURN....
4$:
	MOV	R0,R4		;R4 -> SMALL BUFFER
	BUFFER	RETSML		;RETURN SML BUF SINCE WE COULD'NT GET BIG BUF
6$:	SEC			;SET C BIT TO INDICATE FAILURE
	RETURN			;EXIT

.SBTTL	CAL18B -- ROUTINE TO CALCULATE 18 BIT ADDRESS 

;+
; CAL18B  -- ROUTINE TO CALCULATE 18 BIT ADDRESS
;
;	R4 =  CONTROTED BUFFER ADDRESS
;
;	...
;
;	R3 WILL HAVE LOW ORDER 16 BITS
;	R2 WILL HAVE HIGH ORDER 2 BITS
;-

CAL18B:
	CLR	R2		;CLEAR R2
	MOV	R4,R3		;MAKE A COPY OF CONTROTED ADDR INTO R3
	BIT	#37,R3		;IS IT MONITOR BUFFER?
	BEQ	10$		;YES
	ASHC	#-7,R3		;ROTATE FOR PHYSICAL ADDRESS/100
	ADD 	EXTPOF,R3 	;ADDIN EXBF POOL 
8$:	ASHC	#6,R2		;CONVERT TO 18 BIT ADDRESS IN R2 AND R3
10$:	ADD	#BUFHDR,R3	;ADD BUFF HDR
	ADC	R2		;CARRY THE ALLOWANCE
	RETURN

	GLOBAL <EXTPOF>

.SBTTL	DEBUG ROUTINE TO HANDLE DEBUGGING WORK

;+
; DEBUG - ROUTINE TO HANDLE DEBUGGING WORK.
;
;	R0 =  UNIT # * 2
;	R1 -> XKDDB
;	R2 =  READ/WRITE
;	R3 -> XRB
;	R4 =  CALLING JOB # * 2
;	R5 -> USER BUFFERS THRU APR6
;-

DEBUG:
	CMP	#.WRITE&377,R2	;IS IT A WRITE REQUEST?
	BEQ	1$		;YES, GOOD
	ERROR	EOF		;WE DO'NT LIKE READ REQ, RETURN AS "EOF"....
1$:
	CMP	#3,(R5)		;IS FUNCTION EQ TO "TEST BREAK"?
	BEQ	10$		;YES....
	CMP	#2,(R5)		;IS FUNCTION EQ TO "STOP"?
	BEQ	10$		;YES....
	BIT	#XKRUN,XKSTS(R1) ;IS KMC-11 RUNNING?
	BEQ	10$		;NO, PROCEED...
	ERROR	PRVIOL		;RETURN AS PRIVILEGE VIOLATION ERROR...
10$:	CALLX	REGSAV,R5	;SAVE ALL REGISTERS
	MOV	R5,R3		;R3 -> USER BUFFERS THRU APR6
	MOV	CSR.XK(R0),R1	;R1 -> 1ST CSR ADDR

; THIS ROUTINE IS THE DEBUG EXECUTIVE THAT WILL DISPATCH THE DEBUGGER
; TO THE PROPER ROUTINE...
;
; AT THIS TIME, WE HAVE:
;	R0 = UNIT # * 2
;	R1 -> XK CSR ADDR
;	R3 -> USER BUFFERS THRU APR6
;
; FIRST LETS SEE IF WE HAVE A VALID CODE

	MOV	#DEBSTA,R4	;R4 = TBL ADDRESS
	MOV	#MAXDEB,R5	;R5 = # OF DEBUG COMMANDS
DEBDRV:				;DEBUG EXECUTION SELECTION ROUTINE
	MOV	(R3),R2		;R2 = COMMAND VALUE
	BEQ	10$		;IS IT ZERO, YES, THAT IS INVALID...
	CMP	R5,R2		;IS IT > HIGHEST DEBUG/DISPLAY COMMAND?
	BLT	10$		;TOO HIGH NOT A VALID DEBUG COMMAND
	DEC	R2		;1 LESS THAN COMMAND
	ASL	R2		;MULTIPLY BY 2
	ADD	R4,R2		;R2 = TABLE OF DEBUG/DISPLAY STATE ADDRESSES
	CALL	@(R2)		;JUMP BASED ON VALUE IN TABLE
	BR	15$		;RETURN TO COMMON CODES...
10$:
	SEC			;SET C BIT TO REFECT ERROR
15$:
	CALLX	REGRES,R5	;RESTORE REGS
	BCS	20$		;IF C SET, GOTO 20$...
	JMPX	IOEXIT
20$:
	ERROR	NOSUCH		;RETURN AS "NOSUCH" ERROR

.IF	DF, DE$BUG		; ** SPC 8/17/78 **

.SBTTL	DEBUG  -- ZEREXC  ZERO EXECUTIVE

ZEREXC:
	MOV	#ZERSTA,R4	;JUMP TABLE ADR INTO R4
	MOV	#DEBZIL,R5	;NUMBER OF ZERO MODES
	BR	DEBJMP		;GOTO COMMON CODES TO SET UP FOR JUMP....

.SBTTL	DEBUG  -- SETEXC  SET EXECUTIVE

SETEXC:
	MOV	#SETSTA,R4	;JUMP TBL ADDRESS INTO R4
	MOV	#DEBSIL,R5	;R5 = # OF ITEMS
	BR	DEBJMP		;GOTO COMMON CODES TO SET UP FOR JUMP....

.SBTTL	DEBUG  -- DISEXC  DISPLAY EXECUTIVE

DISEXC:
	MOV	#DISSTA,R4	;JUMP TABLE ADDR INTO R4
	MOV	#DEBDIL,R5	;R5 = # OF DISPLAY MODES

DEBJMP:
	TST	(R3)+		;SKIP PASS THE FUNCTION CODE
	TST	(SP)+		;REMOVE RETURN ADDR ON STACK
	BR	DEBDRV		;LET JUMP TABLE EXECUTOR DO BRANCH...

.ENDC				; ** SPC 8/17/78 **

.SBTTL	DBSTOP -- STOP KMC-11 ROUTINE

;+
; DBSTOP - STOP EXECUTION.
;
;	R0 =  UNIT # * 2
;	R1 -> CSR
;	R3 -> USER'S BUFFER THRU APR6
;-

DBSTOP:
	MOV	DEV.XK(R0),R2	;R2 -> XKDDB
	BIT	#XKRUN,XKSTS(R2) ;IS KMC-11 RUNNING?
	BNE	5$		;YEP...
	SEC			;SET C BIT TO REPORT ERROR
	RETURN
5$:	BIT	#XKSTOP,XKSTS(R2) ;IS KMC-11 STOPPED?
	BNE	10$		;YES, NOP...
	SPLC	5		;;DISABLE INTERRUPT
	CALLX	REGSAV,R5	;;SAVE ALL REGISTERS
	MOV	R2,R3		;;R3 -> XKDDB
	ADD	#XKBBP,R3	;;R3 -> BB ENTRY IN XKDDB
	MOVB	XKACBB(R2),R5	;;R5 = # OF ACTIVE BB ENTRY
6$:	MOV	(R3)+,R4	;;R4 -> BRIDGE BLOCK
	MOVB	BBDUNT(R4),R0	;;R0 = CONTROLLER #
	ASL	R0		;;R0 = CONTROLLER # * 2
	MOVB	#2,BBSTS(R4)	;;SET BB STATUS TO STOP REQUEST
	CLR	R1		;;ASSUME ONLY ONE UNIT
	CMP	#XKDZ,XKPRID(R2) ;;ARE WE KMC-DZ?
	BNE	7$		;;NOOP...
	MOV	#16,R1		;;8 UNITS PER DZ, SET TO 7 * 2
7$:	CALLBB	BBDSTA		;;STATUS CHANGE NOTICE...
	BCS	15$		;;IF CS, SLAVE DRIVER IS BUSY, RETURN ERROR...
	SUB	#2,R1		;;NEXT UNIT
	BPL	7$		;;MORE UNIT IF POSTIVE...
	CLRB	BBSTS(R4)	;;CLEAR BB STATUS
	SOB	R5,6$		;;TRY NEXT CONTROLLER...
	CALLX	REGRES,R5	;;RESTORE ALL REGISTERS
	CLR	(R1)		;STOP KMC-11 NOW
	SPLC	3		;ENABLE INTERRUPT
	BIC	#XKRUN,XKSTS(R2) ;IT IS NOT STARTED!
	BIS	#XKSTOP,XKSTS(R2) ;IT IS STOPPED NOW!

.IF	DF DE$BUG

	MOV	#-1,XKCADR	;MARK AS NO BREAK HITTED..		;003
	BR	MPRSBP		;RESET ALL BRK PTS....

GLOBAL	<XKCADR>							;003

.ENDC

10$:	CLC
	RETURN

15$:	CALLX	REGRES,R5	;;RESTORE ALL REGISTERS
	SPLC	3		;ENABLE INTERRUPT
	SEC			;SET ERROR STATUS
	RETURN			;RETURN TO CALLER

.IF	DF DE$BUG

;+
; MPRSBP - RESET BREAK POINTS
;-

MPRSBP:
	CLR	R5		;R5 IS BRK INDEX
	MOV	#NBRKS,R4	;R4 = # OF BRK PTRS
5$:
	TST	XKADR1(R5)	;IS BRK PTR IN USED?			;003
	BMI	7$		;NO, TRY NEXT
	CLRB	1(R1)		;CLEAR CSR
	MOVB	#4,1(R1)	;SELECT CRAM
	MOV	XKADR1(R5),4(R1) ;SET CRAM ADDR				;003
	MOV	XKUIN(R5),6(R1)	;MOVE ORIGINAL INSTRUCTION		;003
	MOVB	#44,1(R1)	;WRITE CRAM
7$:	TST	(R5)+		;NEXT BRK INDEX
	SOB	R4,5$		;DONE ALL?
	CLRB	1(R1)		;CLEAR CSR ANYWAY
;	CLC
	RETURN

GLOBAL	<XKADR1,XKUIN>							;003

.ENDC

.SBTTL	DBSEXC -- DEBUG START EXECUTION AT ZERO ROUTINE

;+
; DBSEXC - START EXECUTION AT ZERO.
;
;	R0 =  UNIT # * 2
;	R1 -> CSR
;	R3 -> USER'S BUFFER THRU APR6
;-

DBSEXC:
	MOV	DEV.XK(R0),R2	;R2 -> XKDDB
	MOV	XKSTS(R2),R4	;R4 = XKSTS
	BIT	#XKCON,R4	;HAS THIS BEEN CONNECTED?
	BEQ	10$		;NO, DO'NT START IT...
	BIT	#XKLOAD,R4	;HAVE MICRO-CODES BEEN LOADED?
	BEQ	10$		;NO, DO'NT START IT...

; NOW, WE WILL START KMC-11.

.IF	DF DE$BUG

	CALL	MPSBP		;SET BREAK POINTS...
	MOV	DEV.XK(R0),R2	;R2 -> XKDDB

.ENDC

	BIT	#XKRLDR,XKPRID(R2) ;ARE WE STARTING RAMLDR?
	BNE	8$		;YES, WE CAN BYPASS ALL THESE...
	TSTB	XKBNO(R2)	;DO WE HAVE TO SET UP FREE IRB/BIG BUF CHAIN?
	BEQ	5$		;NO
	CALLX	REGSAV,R5	;SAVE ALL REGISTERS
	MOV	R2,R1		;R1 -> XKDDB
	CALL	GBUF		;SET UP FREE IRB/BIG BUF CHAIN
	CALLX	REGRES,R5	;RESTORE ALL RESGISTERS	
	TST	XKIRBH(R2)	;DID WE GET ANY?
	BEQ	10$		;NOOP, HAVE BETTER NOT TO START IT
5$:	SPLC	5		;;DISABLE INTERRUPT
	CALLX	REGSAV,R5	;;SAVE ALL REGISTERS
	MOV	R2,R3		;;R3 -> XKDDB
	ADD	#XKBBP,R3	;;R3 -> BB ENTRY IN XKDDB
	MOVB	XKACBB(R2),R5	;;R5 = # OF ACTIVE BB ENTRY
6$:	MOV	(R3)+,R4	;;R4 -> BRIDGE BLOCK
	MOVB	BBDUNT(R4),R0	;;R0 = CONTROLLER #
	ASL	R0		;;R0 = CONTROLLER # * 2
	MOVB	#1,BBSTS(R4)	;;SET BB STATUS TO START REQUEST
	CLR	R1		;;ASSUME ONLY ONE UNIT
	CMP	#XKDZ,XKPRID(R2) ;;ARE WE KMC-DZ?
	BNE	7$		;;NOOP...
	MOV	#16,R1		;;8 UNITS PER DZ, SET TO 7 * 2
7$:	CALLBB	BBDSTA		;;STATUS CHANGE NOTICE...
	SUB	#2,R1		;;NEXT UNIT
	BPL	7$		;;MORE UNIT IF POSTIVE...
	CLRB	BBSTS(R4)	;;CLEAR BB STATUS
	SOB	R5,6$		;;TRY NEXT CONTROLLER...
	CALLX	REGRES,R5	;;RESTORE ALL REGISTERS
8$:	MOV	#40000,(R1)	;;DO A MASTER CLEAR
	MOV	#100000,(R1)	;;START KMC-11
	MOV	DEV.XK(R0),R2	;;R2 -> XKDDB
	BIC	#XKSTOP,XKSTS(R2) ;;CLEAR STOP BIT IF EVER SET
	BIS	#XKRUN,XKSTS(R2) ;;REMEMBER KMC AS RUNNING
	SPLC	3		;ENABLE INTERRUPT
	CLC			;CLEAR C BIT
	RETURN			;HAPPY EXIT....
10$:
	SEC			;SET C BIT
	RETURN			;ERROR EXIT....


.SBTTL
.SBTTL	DEBUG MAIN ROUTINES
.SBTTL


; THE FOLLOWING CODE IS A REWRITTEN FORM OF THE RSX-11 KMC-11
; DEBUGGING TOOLS.  IT WAS DONE BECAUSE THE RSX-11 TOOLS WERE
; WRITTEN WITH A BASIC CONCEPT THAT WAS TOTALLY FOREIGN TO RSTS/E

; ADDED TO THE XKDVR IN RSTS/E BY STEVE COHEN
; MODIFIED BY S. P. CHAN ON NOVEMBER 17, 1978.

.SBTTL	MPBRKS -- DISPLAY KMC BREAKPOINTS

.IF	DF,DE$BUG		; ** SPC 8/17/78 **

;+
; **MPBRKS-ROUTINE TO DISPLAY STATUS OF KMC BREAKPOINTS
;
; SYNTAX:  DB
;
;	R3 -> DISTYPE + BUFFER (PASS BUFHDR)
;
;	...
;
;	THE BREAKPOINT INFO WILL BE IN BINARY IN USER'S BUFFER.
;-

MPBRKS:	
	CLR	-(R3)		;SET BUFFER PTR TO START OF USER'S BUF
	CLR	R5		;SET INDEX TO ZERO
10$:	MOV	R5,(R3)		;MOVE BREAK INDEX
	ASR	(R3)+		;CHANGE TO BRK NUMBER
	MOV	XKADR1(R5),(R3)+ ;MOVE BREAK ADDRESS TO BUFFER		;003
	MOV	XKUIN(R5),(R3)+	;GET THE INSTRUCTIONON INTO BUFFER	;003
	MOV	XKPCNT(R5),(R3)+ ;MOVE PROCEED COUNT INTO BUFFER	;003
20$:
	TST	(R5)+		;BUMP INDEX
	CMP	R5,#<NBRKS*2>	;ALL DONE
	BLO	10$
;	CLC			;CLEAR C BIT
	RETURN			;HAPPY RETURN....

GLOBAL	<XKADR1,XKUIN,XKPCNT>						;003

.SBTTL	MPIOB  -- ROUTINE TO DISPLAY KMC I/O BUS

;+
; **MPIOB-ROUTINE TO GET CONTENTS OF I/O BUS REGISTERS**
;
; SYNTAX:  DOO0000-0030   FOR I/O BUS REGISTERS
;
;	R3 -> DISTYPE + BUFFER
;
;	...
;
;	RETURNS IN THE BUFFER 8. INBUS VALUES FOLLOWED BY 10. INBUS * VALUES
;-

MPIOB:
	CLR	-(R3)		;SET BUFFER BACK TO PAST BUFHDR
	MOV	#IN0OUT,R5	;GET PROTOTYPE MICRO INSTRUCTION
	MOV	#1,-(SP)	;(SP) INDICATES WE STILL HAVE  INBUS* TO DO...
	MOV	#8.,R2		;WE WILL DO THIS 8. TIMES FOR 8. INBUS REGS
10$:
12$:	MOV	R5,R4		;GET INSTRUCTION TO EXECUTE
	CALL	MPEX		;EXECUTE THAT
	MOVB	(R1),(R3)+	;GET THE DATA INTO BUFFER
17$:	ADD	#20,R5		;ADJ 1 INPUT ADDRESS
	SOB	R2,10$		;LOOP TILL DONE WITH SET OF REGS
	TST	(SP)		;IF 0 WE ARE DONE
	BEQ	20$		;RETURN TO SENDER
	MOV	#121000,R5	;SETUP TO MOVE INBUS*
	MOV	#10.,R2		;WE WANT 10. INBUS* REGS
	CLR	(SP)		;CLEAR (SP) TO INDICATE NO MOVE TO DO
	BR	10$		;LETS LOOP AGAIN
20$:
	TST	(SP)+		;REPOP THE STACK
	CLC			;CLEAR C BIT
	RETURN			;HAPPY RETURN....

.SBTTL	MPREG  -- ROUTINE TO DISPLAY SCRATCH PADS

;+
; **MPREG-A ROUTINE TO DISPLAY THE BRG AND 16 SCRATCH PADS**
;
; 	SYNTAX
;	  DSO0000-0030
;
;	R3 -> DISTYPE + BUFFER
;
;	...
;
;	DATA ARE IN FOLLOWING ORDERS IN USER'S BUFFER:
;	  BRG SP0 SP1 SP2 SP3 SP4 SP5 SP6 SP7  * SP10 ... SP17
;-

MPREG:
	CLR	-(R3)		;PUT BUF PTR BACK
	MPXIN	BTOUT		;MOVE BREG TO OUTPUT
	MOVB	(R1),(R3)+	;GET THE B REG VALUE
	MOVB	(R1),-(SP)	;SAVE THAT
	MOV	#SPTOB,R5	;GET PROTOTYPE MICRO INSTRUCTION
10$:	MOV	R5,R4		;COPY MICRO INSTRUCTION
	CALL	MPEX		;EXECUTE IT
	MPXIN	BTOUT		;COPY BREG TO OUTPUT
	MOVB	(R1),(R3)+	;COPY DATA
	INC	R5		;ADJ SPAD ADR
	BIT	#17,R5		;ADDRESS WRAP AROUND?
	BEQ	30$		;BR IF ALL DONE
	BR	10$		;PROCEED
30$:	MOVB	(SP)+,(R1)	;GET OLD BREG VALUE
	MPXIN	OUTOB		;RESTORE BREG
	CLC			;CLEAR C BIT
	RETURN			;HAPPY RETURN....

.SBTTL	MPSEBK -- SET A BREAK POINT IN THE KMC

;+
; **MPSEBK-ROUTINE TO SET A BREAKPOINT IN THE KMC MICROCODE**
;
;	SYNTAX--
;		SBXYYYY
;			WHERE X IS A BREAKPOINT # 0-3
;			      YYYY IS THE OCTAL VALUE OF THE KMC WORD
;				****  BEWARE LISTING ADDRESSES WITH MACROS
;				      ARE 2* KMC WORD ADDRESS
;
;	R3 -> SETTYPE + BUFFER
;
;	...
;
;	RETURN
;-

MPSEBK:
	MOV	2(R3),R4	;R4 = BREAK #
	CMP	#NBRKS,R4	;VALID BREAK #?
	BLOS	40$		;BR TO 40$ IF NOT
	CMP	4(R3),#4000	;VALID ADDRESS TO SET?
	BLO	30$		;IF LO, GOOD ADDRESS...
	TST	4(R3)		;RESET BREAK POINT?
	BPL	40$		;NO
	MOV	#-1,4(R3)	;MAKE IT AS -1 ANYWAY
30$:
	ASL	R4		;MULTIPLY B# BY 2 DELETED
	MOV	4(R3),XKADR1(R4) ;REMEMBER THE BREAK ADDR		;003
	CLR	XKPCNT(R4)	;CLEAR PROCEED COUNT			;003
	;CLC
	RETURN
40$:
	SEC
	RETURN

GLOBAL	<XKADR1,XKPCNT>							;003

.SBTTL	MPDCAM -- ROUTINE TO DISPLAY A CRAM LOCATION

;+
; **MPDCAM-ROUTINE TO DISPLAY A CRAM LOCATION**
;
;	SYNTAX
;		DWOAAAA-0000
;		WHERE AAAA IS THE ADDRESS TO LOOK AT
;
;	R1 -> CSR
;	R3 -> DISTYPE + BUFFER
;
;	...
;
;	CRAM CONTAIN IS IN USER'S BUFFER
;-

MPDCAM:
	CLRB	1(R1)		;CLEAR CSR CONTROL REG
	MOVB	#4,1(R1)	;SELECT CRAM MEMORY
	MOV	2(R3),4(R1)	;MOVE ADDRESS TO READ TO CSR
	MOV	6(R1),-(R3)	;MOVE CRAM WORD TO RETURN AREA
;	CLC			;CLEAR C BIT
	RETURN			;HAPPY RETURN....

.SBTTL	MPWCAM	--  SET OR WRITE A CRAM WORD

;+
; **MPWCAM-SET A CRAM WORD**
;
;	SYNTAX
;		SWOAAAADDDDDD
;		WHERE:
;			AAAA	=	ADDRESS TO MODIFY
;			DDDDDD	=	WORD OCTAL TO WRITE
;
;	R1 -> CSR
;	R3 -> MEMTYPE + ADDRESS + VALUE
;
;	...
;
;	RETURN
;-

MPWCAM:
	CLRB	1(R1)	;CLEAR CSR CONTROL REG
	MOVB	#4,1(R1)	;SELECT CRAM MEMORY
	MOV	2(R3),4(R1)	;MOVE CRAM ADDRESS TO CSR
	MOV	4(R3),6(R1)	;MOVE DATA TO WRITE TO CSR
	MOVB	#44,1(R1)	;SET IN DATA INTO CRAM
	CLRB	1(R1)		;CLEAR CONTROL CSR
;	CLC
	RETURN

.SBTTL	MPPROC/MPGOTO - BREAKPOINT CONTINUE COMMANDS

;+
; **MPPROC-ROUTINE TO PROCEED FROM BREAK POINT**
; **MPGOTO-ROUTINE TO START KMC AT SPECIFIC ADDRESS**
;
;	R0 =  UNIT # * 2
;	R1 -> CSR
;	R3 -> BUFHDR
;-

	.ENABL	LSB

MPPROC:
	MOV	DEV.XK(R0),R2	;R2 -> XKDDB
	BIT	#XKSTOP,XKSTS(R2) ;IS IT STOPPED?
	BEQ	MPERR2		;IF NOT, YOU CAN'T PROCEED (DO A START)...
	BIC	#XKSTOP,XKSTS(R2) ;IT IS STARTED
	BIS	#XKRUN,XKSTS(R2)
	TST	XKCADR		;DID IT HIT A BREAK PT?			;003
	BMI	10$		;NO
	CLRB	1(R1)		;YES, LET'S GET THE BREAK INSTRUCTION
	MOVB	#4,1(R1)	;SELECT CRAM
	MOV	XKCADR,4(R1)	;SET ADDRESSS				;003
	MOV	6(R1),R4	;R4 = INSTRUCTION TO EXECUTE
	CALL	MPEX		;EXECUTE THAT 1

MPGOTO:
	MOV	XKCADR,R4	;R4 IS SETUP TO JUMP WHERE WE WANT	;003
	CALL	MPSADR		;IF SET SET DEVICE THERE
	MOV	#-1,XKCADR	;RESET AS NO BREAK PT HITTED..		;003
10$:	CALL	MPSBP		;SET UP BREAK POINT....
	BIS	#MPRUN,(R1)	;SET GO
	CLC			;CLEAR C BIT
	RETURN			;HAPPY RETURN....

MPERR2:
	SEC			;SET C BIT
	RETURN			;ERROR RETURN....

GLOBAL	<XKCADR>							;003

.DSABL	LSB

.SBTTL	MPSNGL -- SINGLE STEP COMMAND...

;+
;  MPSNGL-SINGLE STEP ROUTINE.
;
;  SYNTAX: F FOR FIDDLE...
;
;	R1 -> CSR
;	R3 -> BUFHDR + COUNT
;
;	...
;
;	RETURN
;-

MPSNGL:
	MOV	2(R3),R4	;GET COUNT
10$:	BIS	#MPSTEP,(R1)	;STEP
	BIC	#MPSTEP,(R1)	;CLR THE BIT
	SOB	R4,10$
	CLC
	RETURN

.SBTTL	MPWRAM -- ROUTINE TO WRITE THE DATA RAM

;+
; MPWRAM-ROUTINE TO WRITE THE DATA RAM
;
; SYNTAX
;	SROAAAADDDDDD
;	WHERE	AAAA = RAM ADDRESS (MUST BE 4 CHARS
;		DDDDDD = DATA FOR CHARACTER  (MUST BE 6 DIGITS)
;
;	R1 -> CSR
;	R3 = BUF PTR PAST BUFHDR AND COMMAND
;
;-

MPWRAM:				;WRITE RAM
	CALL	MPGMAR		;FIND CURRENT MAR
	MOV	2(R3),R4	;GET ADDRESS SUPPLIED
	CALL	MPSMAR		;SET MAR TO VALUE
10$:	MOV	#IN1TOM,R4	;GET MICRO INSTRUCTION
	MOVB	4(R3),(R1)	;SET DATA INTO MICRO-PROC PORT
	CALL	MPEX		;EXECUTE THAT
	CLC
	RETURN
MPLDMA:
	ASR	R4		;FIX UP ADDRESS
	ROLB	R4		;TO HARDWARE NUMBER
	MOV	R4,XKMAR	;SET NEW MAR				;003
	RETURN

GLOBAL	<XKMAR>								;003

.SBTTL	MPRAM  -- ZERO DATA RAM

;+
; **MPZRAM-ROUTINE TO ZERO DATA RAM**
;
; SYNTAX---
;
;	ZR
;
;	R1 -> CSR
;	R3 -> BUFHDR
;+

MPZRAM:
	CLRB	(R1)		;DATA TO SET IS ZERO
	CLR	R4		;GET A ZERO
	CALL	MPSMAR		;SET MAR THERE
	MOV	#RAMSIZ,R5	;AMOUNT OF MEMORY TO ZERO
10$:	MPXIN	<IN1TOM!MARINC>	;COPY INPUT TO MEMORY
	SOB	R5,10$
	CLC
	RETURN

.SBTTL	MPWSP  -- WRITE A SCRATCH PAD

;+
; **MPWSP-ROUTINE TO WRITE A VALUE TO A SCRATCH PAD**
;
; WRITE SPAD LOCATION
; SYNTAX---
;	SSNM	;WHERE M IS THE VALUE TO WRITE INTO SCRATCH PAD N
;
; INPUTS:
;	R1 -> CSR
;	R3 = BUFFER PTR PAST COMMAND + BUFHDR
;-

MPWSP:
	MPXIN	BTOUT		;GET THE BREG
	MOVB	(R1),-(SP)	;SAVE BREG
	MOV	4(R3),R4	;R4 = VALUE TO WRITE
	ADD	#LITOB,R4	;FIX UP INSTRUCTION
	CALL	MPEX		;AND EXECUTE IT-LOAD VAL INTO B
	MOVB	2(R3),R4	;COPY SPAD ADDRESS
	ADD	#BTOSP,R4	;BUILD INST TO COPY B TO SPAD <N>
	CALL	MPEX		;DO THAT---MOVE BREG,SPAD<N>
	MOVB	(SP)+,(R1)	;SET ORIGINAL CONTENTS OF B INTO PORT
	MPXIN	OUTOB		;RESTORE BREG
	CLC
	RETURN

.SBTTL	MPLIST -- LIST MICRO PROCESSOR DATA RAM

;+
; **MPLIST-LIST MICRO PROCESSOR DATA RAM**
;
; SYNTAX---
;	DRTSE	;WHERE S IS THE STARTING ADDRESS AND E IS THE ENDING
;		 ADDRESS EXCEPT IF E <S THEN IT IS THE COUNT
;		T IS THE DISPLAY TYPE
;
;	R1 -> CSR
;	R3 = BUF PTR + BUFHDR + COMMAND
;-

MPLIST:
	MOV	2(R3),R5	;R5 = STARTING ADDRESS
	MOV	4(R3),R4	;R4 = ENDIING ADDRESS OR COUNT
	CLR	-(R3)		;SET R3 BACK TO PAST BUFHDR
	CMP	R4,R5		;HI ADR OR COUNT SPECED?
	BLOS	5$		;BR IF COUNT
	SUB	R5,R4		;MAKE COUNT
5$:	CMP	#RAMSIZ,R4	;COUNT BIGGER THE RAM SIZE?
	BHIS	6$		;NO
	MOV	#RAMSIZ,R4	;YES, MAKE IT EQUAL TO THE RAM SIZE
6$:
	MOV	R4,-(SP)	;SAVE COUNT
	BNE	7$		;BR IF NON-ZERO VALUE
	INC	(SP)		;MAKE MINIMUM COUNT
7$:	CALL	MPGMAR		;FIND CURRENT MAR
	MOV	R5,R4		;SET TARGET MAR
	CALL	MPSMAR		;SET IT TO R4 VALUE
	MOV	(SP)+,R5	;POP COUNT TO LIST
	ADD	#17,R5		;ROUND UP COUNT
	BIC	#17,R5		;ETC
10$:	MPXIN	MEMOUT		;GET MEMORY TO OUTPUT
	MOVB	(R1),(R3)+	;GET THE DATA
	SOB	R5,10$
	CLC			;CLEAR C BIT
	RETURN			;HAPPY RETURN....

.SBTTL	MEMORY ADDRESS REGISTER ROUTINES

;+
; **MPGMAR-GET CURRENT VALUE TO MAR**
;
; INPUTS:
;	NONE
;
; OUTPUTS:
;	XKMAR IS SET TO CURRENT MAR VALUE
;-
MPGMAR:
	MOV	#1024.,XKMAR	;SET A VALUE				;003
10$:
	DEC	XKMAR		;COUNT DOWN UNTIL OVERFLOW		;003
	BEQ	20$		;BR IF WRAP AROUND-MUST BE DMC-11(NOT SBC)
	MPXIN	MARINC		;ADD 1 TO MAR
	MPXIN	IN8OUT		;COPY MAR OVERFLOW FLAG
	ASLB	(R1)		;MAR OVERFLOW?
	BPL	10$		;BR IF NO
20$:	RETURN

GLOBAL	<XKMAR>								;003

 
;+
; **MPSMAR-ROUTINE TO SET THE MAR**
;
; INPUTS:
;	R4 = VALUE TO SET MAR
;
; OUTPUTS:
;	MAR IS SET TO VALUE IN R4
;-
MPSMAR:
	MOV	R4,-(SP)	;SAVE MAR
	BIC	#177400,R4	;REDUCE TO PAGE OFFSET
	BIS	#MARLOD,R4	;FORM MICR INSTRUCTION
	CALL	MPEX		;EXECUTE THAT
	MOV	(SP)+,R4	;GET ADDRES BACK
	CLRB	R4		;REMOVE PAGE OFFSET
	SWAB	R4		;GET PAGE NUMBER IN LOW BYTE
	BIS	#MARLDX,R4	;FOR MICRO INSTRUCTION
	CALLR	MPEX		;RETURN FROM THERE

.SBTTL	SET MICRO PROCESSOR PC AND EXECUTE INSTRUCTION
;+
; **MPSADR---MICRO PROCESSOR SET ADDRESS
;
;THIS ROUTINE SETS THE ADDRESS OF THE NEXT MICRO INSTRUCTION
;	BY EXECUTING A JUMP FROM THE CSR6
;
;INPUT:
;	R4= MICRO PROC. ADDRESS
;OUTPUT:
;	R4 HAS JUMP INSTRUCTION,AND THE JUMP HAS BEEN EXECUTED
;	---BY THE MICRO PROC.
;
MPSADR:
	CALL	MAKBR		;CHANGE R4 INTO BRANCH
	MOV	#-1,XKCINS	;RESET INSTRUCTION COUNTER		;003
	BR	MPEX		;EXECUTE THAT INSTRUCTION
;
;MPX4---EXECUTE INSTRUCTION POINTED TO BY R4
;
;ENTRY:
;	JSR	R4,MPX4
;	.WORD	MINST		;MICRO-INSTRUCTION TO EXECUTE
;OUTPUT:
;	RETURN AT CALL R4+2
;	R4 HAS THE INSTRUCTION
;
;
MPX4:
	TST	(R4)+		;FIX UP RETURN ADDRESS
	MOV	R4,(SP)		;WRITE OVER OLD R4 VALUE
	MOV	-(R4),R4	;PICK UP INSTRUCTION
MPEX:
	BIS	#<MPIIN>,(R1)	;SET ROM IN
	MOV	R4,6(R1)	;SET INTO DEVICE
	BIS	#<MPIIN!MPSTEP>,(R1) ;STEP THE DEVICE
	CLRB	1(R1)		;DISABLE THE DEVICE
	INC	XKCINS		;COUNT INSTRUCTIONS			;003
	RETURN
MAKBR:
	INC	R4		;ADD 1 TO INSTUURCTION AFTER BREAK TO GOTO
	SWAB	R4		;GET HI BITS OF JUMP LO
	ASLB	R4		;MOVE PAGES BITS OVER
	ASLB	R4
	ASLB	R4		;WHERE THEY GO IN A JUMP
	SWAB	R4		;PUT THINGS BACK
	ADD	#MPJMP,R4	;MAKE A JUMP INSTRUCTION
	RETURN

GLOBAL	<XKCINS>							;003

.SBTTL	MPSBP -- SET BREAK POINT ROUTINES

;+
; **MPSBP-SET BREAK POINTS**
;-

MPSBP:
	MOV	#BRKPT0,R4	;GET THE BRK INSTRUCTION FOR BRK 0
	CLR	R5		;START WITH INDEX OF 0
10$:	MOV	XKADR1(R5),R2	;R2 = BRK ADDR				;003
	BMI	20$		;BR IF NOT IN USE
	CLRB	1(R1)		;CLEAR CSR
	MOVB	#4,1(R1)	;SELECT CRAM MEMORY
	MOV	R2,4(R1)	;MOVE BRK ADDR
	MOV	6(R1),XKUIN(R5)	;SAVE USER'S INSTRUCTION		;003
	MOV	R4,6(R1)	;MOVE BRK INSTRUCTION
	MOVB	#44,1(R1)	;WRITE INTO CRAM
	CLRB	1(R1)		;CLEAR CSR
20$:	ADD	#2,R4		;ADJ JUMP TO NEXT BREAK
	TST	(R5)+		;BUMP INDEX
	CMP	R5,#<NBRKS*2>	;DO THEM ALL?
	BLO	10$		;BR IF MORE TO GO
	RETURN			;ALL DONE

GLOBAL	<XKADR1,XKUIN>							;003

.SBTTL	BRKRTN  ENTERRED VIA Q COMMAND TO POLL IF A BREAKPOINT

;******************************************************************
;*                                          			  *
;*	BRK RTN  --	THIS ROUTINE POLLS CSR0 BYTE 0 TO SEE IF  *
;*			A BREAKPOINT HAS OCCURRED.  THE 1ST	  *
;*			4 BITS ARE ZERO ALWAYS			  *
;*			BREAKPOINT 0 = 00010000B = 16.		  *
;*			           1 = 00100000B = 32.		  *
;*				   2 = 00110000B = 48.		  *
;*				   3 = 01000000B = 64.		  *
;*								  *
;*		THE BREAKPOINT ROUTINE BRANCHES TO ITSELF AFTER   *
;*		SETTING CSR0 BYTE 0.  				  *
;*								  *
;******************************************************************

BRKRTN:
	TSTB	(R1)		;ANY BREAKPOINT
	BNE	5$		;IF NE, HIT BREAK...
	SEC			;SET C BIT
	RETURN			;ERROR RETURN...

; IF WE ARE HERE WE HAVE A BREAKPOINT

5$:
	MOVB	(R1),R5		;R5 = BREAK INFORMATION
	CLR	(R1)		;CLEAR KMC-11 AND STOP IT...
	ASH	#-4,R5		;SHIFT RIGHT 4 BITS

; VALUE IN R5 IS 1 MORE THAT BREAK NUMBER

	MOV	R5,(R3)+	;MOVE BREAK # + 1 TO OUT BUFFER
	DEC	R5		;R5 NOW = BREAK #
	MOV	#XKADR1,R2	;R2 = BEGIN OF ADDRESS TBL		;003
	ASL	R5		;R5 = INDEX INTO TBL
	ADD	R5,R2		;R2 = PLACE IN BREAK ADDRESS TBL
	MOV	XKADR1(R5),XKCADR ;REMEMBER BRK ADDR			;003
	MOV	(R2),(R3)	;MOVE ADDRESS TO OUTBUF
	MOV	#NBRKS,R4	;R4 = # OF BRK PTRS
	CLR	R5		;R5 IS A BRK INDEX
10$:
	CLRB	1(R1)		;CLEAR CSR
	MOVB	#4,1(R1)	;SELECT CRAM
	TST	XKADR1(R5)	;BRK PT IN USED?			;003
	BMI	20$		;NO
	MOV	XKADR1(R5),4(R1) ;SET ADDR				;003
	MOV	XKUIN(R5),6(R1)	;MOVE ORIGINAL INSTRUCTION		;003
	MOVB	#44,1(R1)	;WRITE CRAM
	CLRB	1(R1)		;CLEAR CSR
20$:	TST	(R5)+
	SOB	R4,10$
	MOV	DEV.XK(R0),R2	;R2 -> XKDDB
	BIC	#XKRUN,XKSTS(R2) ;IT IS NOT RUNNING ANYMORE!
	BIS	#XKSTOP,XKSTS(R2) ;AND IT HAS BEEN STOPPED!
	CLC			;CLEAR C BIT
	RETURN			;HAPPY RETURN....

GLOBAL	<XKCADR,XKADR1,XKUIN>						;003

;
;SCSR---SAVE CSRS
;
MPSCSR:
	MOV	R0,-(SP)	;SAVE R0
	CLRB	1(R1)		;STOP THE DEVICE
	ADD	#6,R1		;POINT AT BOTTOM
	MOV	#XKCSRS+6,R0	;POINT AT SAVE AREA			;003
	MOV	(R1),(R0)	;SAVE CSR6
	MOV	-(R1),-(R0)	;-AND 4
	MOV	-(R1),-(R0)	;--AND 2
	MOV	-(R1),-(R0)	;---AND FINALLY 0
	MOV	(SP)+,R0	;RESTORE R0
	RETURN
;
;RCSR---RESTORE DEVICE CSR'S
;
MPRCSR:
	MOV	R0,-(SP)	;SAVE R0
	MOV	#XKCSRS+6,R0	;POINT AT CSR SAVE AREA			;003
	ADD	#6,R1		;ADVANCE TO BOTTOM
	MOV	(R0),(R1)	;RESTORE
	MOV	-(R0),-(R1)	;-THE
	MOV	-(R0),-(R1)	;--DEVICE
	MOV	-(R0),-(R1)	;---REGISTERS
	MOV	(SP)+,R0	;RESTORE R0
	RETURN

GLOBAL	<XKCSRS>							;003

.ENDC				; ** SPC 8/17/78 **

	.END	
