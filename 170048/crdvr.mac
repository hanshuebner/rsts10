	.IF	NDF	CD11	;get commomn and kernel if not there	;001
	.INCLUDE	/CMN:COMMON/
	.INCLUDE	/CMN:KERNEL/
	.INCLUDE	/CMN:CRDEF/
	.ENDC	;NDF	CD11						;001
TITLE	CRDVR,<CARD READER I/O SERVICE>,0A,10-MAY-91,JDM/GW/ABC

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR CRDVR
;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;
;			[RSTS/E V10.1]
;  001  WRM  26-Dec-90	Modified to use includes
;-

.IIF	NDF	CD11,	CD11=0	;DEFAULT TO CR11 DRIVER

; MACRO FOR CORRECT CARD READER ENTRY POINT LABELS

.MACRO	CDRENT	LABEL
.IF	EQ	CD11
.LIST
LABEL'CR::			;CR11 ENTRY POINT
.NLIST
.IFF
.LIST
LABEL'CD::			;CD11 ENTRY POINT
.NLIST
.ENDC
.ENDM	CDRENT

.IF	EQ	CD11		;FOR CR11

	DEFORG	CRDVR

	DEFORG	CRDINT

	INCLUDE	ERLDVR

	ORG	CRDVR

; DEFINE 'DDSTS' VALUE FOR CARD READER

STS.CR	==	DDWLO/400
		;READ ONLY DEVICE

; DEFINE FLAGS FOR CARD READER

FLG.CR	==	FLGFRC!FLGMOD!DDWLO!DDNFS!CDRHND
		;BYTE ORIENTED
		;ACCEPTS MODIFIERS
		;READ ONLY
		;NON-FILE STRUCTURED
		;CARD READER

; DEFINE WIDTH

SIZ.CR	==	5*14.+1
		;DEFAULT FOR "NO WIDTH"

; DEFINE DEFAULT BUFFER SIZE

BUF.CR	==	160.
		;DEFAULT BUFFER SIZE IS 80. WORDS

	TMPORG	CRDINT

CRDINT:	CALLX	INTSAV,R5	;SAVE ALL REGISTERS
	  .WORD	1200		;PAR5 VALUE
	  .WORD	INT$CR		;INTERRUPT SERVICE ENTRY POINT

	UNORG

.ENDC

.IF	NE	CD11		;FOR CD11

.TITLE	CDDVR	CARD READER I/O SERVICE

	DEFORG	CDDVR

	DEFORG	CDDINT

	INCLUDE	ERLDVR

	ORG	CDDVR

; DEFINE 'DDSTS' VALUE FOR CARD READER

STS.CD	==	DDWLO/400
		;READ ONLY DEVICE

; DEFINE FLAGS FOR CARD READER

FLG.CD	==	FLGFRC!FLGMOD!DDWLO!DDNFS!CDRHND
		;BYTE ORIENTED
		;ACCEPTS MODIFIERS
		;READ ONLY
		;NON-FILE STRUCTURED
		;CARD READER

; DEFINE WIDTH

SIZ.CD	==	5*14.+1
		;DEFAULT FOR "NO WIDTH"

; DEFINE DEFAULT BUFFER SIZE

BUF.CD	==	160.
		;DEFAULT BUFFER SIZE IS 80. WORDS

	TMPORG	CDDINT

CDDINT:	CALLX	INTSAV,R5	;SAVE ALL REGISTERS
	  .WORD	1200		;PAR5 VALUE
	  .WORD	INT$CD		;INTERRUPT SERVICE ENTRY POINT

	UNORG

.ENDC

.SBTTL	LEVEL 3 USER I/O SERVICE ROUTINES

;+
; SER$CD,SER$CR - USER LEVEL READ/WRITE SERVICE.
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB/FCB
;	R2 =  2 (.READ)
;	      4 (.WRITE)
;	R3 -> XRB
;	R4 =  CALLING JOB NUMBER TIMES 2
;	R5 -> USER'S BUFFER (THROUGH KISAR6)
;	IF Z=1 OR C=0 THEN THIS IS THE FIRST CALL
;	IF Z=0 OR C=1 THEN THIS IS A "REDO" CALL
;
; NOTES:
;
;	1) ACCESS RIGHTS HAVE BEEN VERIFIED.
;	2) DIRECTIONAL RIGHTS HAVE BEEN VERIFIED.
;
; EXITS:
;
;	1) ALL COMPLETE WITH NO ERROR
;
;		JMP	IOEXIT
;
;	2) ALL COMPLETE WITH ERROR
;
;		SETERR	CODE
;		JMP	IOEXIT
;
;		-OR-
;
;		ERROR	CODE
;
;	3) STALL DESIRED (FOR "REDO" LATER)
;
;		JMP	IOREDO
;-

.ENABL	LSB

	CDRENT	SER$
	CLR	XRBLK(R3)	;INDICATE SEQUENTIAL DEVICE
	CLRB	XRBLKM(R3)	; IN BOTH PLACES
	MOV	DDFLAG(R1),-(SP) ;SAVE READ MODE AND ERROR CODE
	TST	XRMOD(R3)	;OVERRIDE THE READ MODE?
	BEQ	10$		;NO
	MOVB	XRMOD(R3),1(SP)	;YES, SO LOAD OVERRIDE READ MODE
10$:	MOV	#IOREDO,R2	;PRESET RETURN ADDRESS TO "IOREDO"
	TST	(R3)+		;POINT TO XRBC
	BIT	#CDRBSY,DDFLAG(R1) ;CHECK TO SEE IF CARD READY BUSY
	BNE	130$		;IF BUSY, THEN PUT USER INTO WAIT
	MOV	CDRPTR(R1),R0	;PUT BUFFER POINTER INTO REGISTER
	TST	(R1)		;IS THIS THE FIRST TIME THROUGH
	BPL	160$		;YES. GO READ A CARD
	MOV	DDFLAG(R1),R4	;GET THE STATUS
	ASL	R4		;SHIFT SO THAT CARRY=CDRNDT AND N-BIT = CDRTRN
	BCS	160$		;IF NO DATA IN BUFFER, THEN READ A CARD
	BMI	180$		;IF TRANSLATED DATA, THEN JUST USE IT
	MOV	CDRBUF(R1),R4	;GET END+2 OF THE
	ADD	#160.,R4	; READER'S BUFFER
20$:	BIC	#^C<7777>,-(R4)	;ENSURE NO EXTRA BITS ARE ON
	CMP	R4,CDRBUF(R1)	;MORE?
	BHI	20$		;YES LOOP
	MOV	R3,-(SP)	;SAVE XRB POINTER
	MOV	R5,-(SP)	;SAVE BUFFER POINTER
	MOV	CDRBUF(R1),R4	;FORM POINTER TO
	ADD	#160.,R4	; END OF BUFFER
	MOV	R4,CDRBFE(R1)	;ASSUME DATA WITHOUT CR/LF
	MOV	4(SP),R5	;GET READ MODE AND INT. ERROR CODE
	ASH	#6,R5		;PUT "DON'T PACK" BIT INTO BIT 15 (SIGN)
	BIT	R5,#377*100+100000 ;CHECK FOR INT. ERROR AND/OR DON'T PACK
	BNE	40$		;IF TRUE, THEN DON'T CHECK FOR EOF PUNCHES
	CMP	@CDRBUF(R1),#7400 ;CHECK FOR 12-11-0-1 (EOF)
	BEQ	30$		;IT IS EOF
	CMP	@CDRBUF(R1),#7417 ;CHECK FOR 12-11-0-1-6-7-8-9 (EOF TOO)
	BNE	40$		;NOT AN EOF
30$:	SETERR	EOF,4(SP)	;SET ERROR CODE
40$:	ASL	R5		;CHECK "DON'T PACK" AND "DON'T TRANS"
	BCS	140$		;DON'T PACK DATA AT ALL
	BMI	60$		;DON'T TRANSLATE THE DATA
	ADD	#2,CDRBFE(R1)	;NOW ASSUME DATA WITH CR/LF
50$:	TST	-(R0)		;CATCH ANY TRAILING BLANKS IN DATA
	BEQ	50$		; AND IGNORE THEM QUICKLY
	TST	(R0)+		;CORRECT POINTER
60$:	CMP	R0,CDRBUF(R1)	;AT THE END (START) OF BUFFER ?
	BLOS	150$		;IF SO, THEN ALL DATA TRANSLATED

GLOBAL	<IOREDO>

; UNPACK THE CARD. THE 12 ROWS OF THE CARD ARE STORED IN A WORD C,B,A,1,2,3,4,5,6,7,8,9
; WHERE ROW 12=C, ROW 11=B AND ROW 10=A. THIS NEEDS TO BE UNPACKED INTO
; A BYTE OF FORMAT CBA98XXX, WHERE XXX IS AN OCTAL NUMBER  REPRESENTING
; WHICH BIT 1-7 WAS PUNCHED. ONLY ONE OF THESE BITS CAN BE PUNCHED ON A LEGAL CARD

	MOV	-(R0),R2	;GET A 12 BIT CARD CODE 
	CLR	R3		;R2=0000CBA123456789	R3=0000000000000000	C=?
	ROR	R2		;R2=00000CBA12345678	R3=0000000000000000	C=9
	ROL	R3		;R2=00000CBA12345678	R3=0000000000000009	C=0
	RORB	R2		;R2=00000CBA01234567	R3=0000000000000009	C=8
	ROL	R3		;R2=00000CBA01234567	R3=0000000000000098	C=0
	ASH	#3,R3		;R2=00000CBA01234567	R3=0000000000098000	C=0
	ASLB	R2		;R2=00000CBA12345670	R3=0000000000098000	C=0
	TSTB	R2		;ARE THERE ANY PUNCHES IN 1-7
	BEQ	80$		;NO. SKIP THE LOOP
70$:	INC	R3		;PACK 1-7 PUNCHES IN R3:<2-0>
	ASLB	R2		;BY SHIFTS
	BCC	70$		;LOOP TILL THE CARRY SETS
	TSTB	R2		;ANY OTHER PUNCHES
	BNE	100$		;YES. THEN ITS AN ERROR
80$:	ASH	#-3,R2		;R2=00000000CBA00000	R3=0000000000098XXX
	BIS	R2,R3		;R2=00000000CBA00000	R3=00000000CBA98XXX
	TST	R5		;TRANSLATE THE DATA?
	BPL	90$		;YES
	MOVB	R3,-(R4)	;NOPE, JUST STORE THE PACKED DATA BYTE
	BR	60$		; AND CONTINUE

90$:	MOVB	CDRTBL(R3),-(R4) ;CHARACTER INTO BUFFER
	BPL	60$		;IF LEGAL CHARACTER, GET ANOTHER
	INC	R4		;NEGATIVE CHARACTER IS ILLEGAL CODE
100$:	TSTB	4(SP)		;ANY PREVIOUS ERROR ?
	BNE	110$		;YES, SO LEAVE IT ALONE
	SETERR	DATERR,4(SP)	;NO, SO SET A DATA ERROR
110$:	MOVB	#'\+200,-(R4)	;MAKE ILLEGAL CHARACTER A PARITY BACKSLASH
	BR	60$		; AND LOOP TILL BUFFER EMPTY

120$:	MOV	R0,CDRPTR(R1)	;SAVE THE DATA POINTER FOR NEXT TIME
	MOVB	(SP),@IOSTS	;SET ERROR CODE IF ANY
130$:	BR	190$		; AND EXIT

140$:	MOV	R0,CDRBFE(R1)	;END OF DATA IS LAST COLUMN READ
	MOV	CDRBUF(R1),R4	;START OF DATA IS BUFFER'S START
150$:	MOV	R4,R0		;GET A NEW INTERNAL POINTER
	MOV	(SP)+,R5	;RESTORE BUFFER POINTER
	MOV	(SP)+,R3	;RESTORE POINTER TO XRBC
	BIS	#CDRTRN,DDFLAG(R1) ;SAY DATA IN BUFFER IS TRANSLATED
	BR	180$		; AND GIVE IT TO THE CALLER

160$:	CLRB	(SP)		;GET RID OF OLD INTERRUPT ERROR
	BR	CDRGET		;NOW GET THE NEXT CARD

170$:	CMP	XRLEN-XRBC(R3),(R3)+ ;IS THE USER'S BUFFER FULL?
	BLOS	120$		;YES, TIME TO QUIT
	MOVB	(R0)+,R2	;GET A CHATACTER
	PUTUSR			; AND MOVE IT TO THE USER' BUFFER
	INC	(R3)		;BUMP BUFFER ADDRESS IN XRB
	INC	-(R3)		;INC THE BYTE COUNT
180$:	MOV	#IOEXIT,R2	;SET THE FINAL EXIT ADDRESS
	CMP	R0,CDRBFE(R1)	;MORE DATA TO GIVE USER?
	BLO	170$		;YES, TRY TO GIVE IT TO HIM
	TST	(R3)		;NO, DID WE GIVE HIM ANYTHING?
	BNE	CDRGET		;SURE DID, EXIT AND READ ANOTHER CARD
	TSTB	(SP)		;NOPE, ANY ERROR PENDING?
	BNE	CDRGET		;ERROR IS PENDING, GIVE USER THAT ERROR
	SETERR	HNGDEV,(SP)	;ELSE ALL SCREWED UP, GIVE BAD NEWS

GLOBAL	<IOEXIT>

; READ A CARD

CDRGET:	BIS	#DDSTAT,(R1)	;SAY WE WERE HERE BEFORE
	BIS	#CDRNDT,DDFLAG(R1) ; AND THERE IS NO DATA IN THE BUFFER
	MOV	CDRBUF(R1),CDRPTR(R1) ;RESET INTERNAL POINTER
	CLRB	DDFLAG(R1)	;RESET INTERRUPT ERROR TO NONE
	MOVB	(SP),@IOSTS	;SET ERROR IF ANY
	BNE	190$		;IF ERROR, THEN NO MORE READING
	BIS	#CDRBSY,DDFLAG(R1) ;SET CARD READER BUSY
	MOVB	DDUNT(R1),R0	;GET UNIT NUMBER
	ASL	R0		; TIMES 2 FOR WORD ADDRESSING

.IF	EQ	CD11		;FOR CR11

	MOV	#5.,TIM.CR(R0)	; SET TIMEOUT TO 5 SECONDS
	MOV	CSR.CR(R0),R3	;GET THE CSR POINTER
	TST	CRB(R3)		;ENSURE EMPTIED DATA BUFFER
	MOV	#101,(R3)	;NOW START READING A CARD

GLOBAL	<TIM.CR,CSR.CR>

.IFF				;FOR CD11

	MOV	#5.,TIM.CD(R0)	; SET TIMEOUT TO 5 SECONDS
	MOV	CSR.CD(R0),R3	;GET THE CSR ADDRESS
	MOV	CDRBUF(R1),CDBA(R3) ;SET THE BUS ADDRESS TO OUR BUFFER
	MOV	#-80.,CDCC(R3)	;READ 80. COLUMNS
	MOV	#101,(R3)	;MAKE IT READ

GLOBAL	<TIM.CD,CSR.CD>

.ENDC

190$:	RETURN	R2		;EXIT

.DSABL	LSB

.SBTTL	CARD READER OPEN/CLOSE

;+
; OPN$CD,OPN$CR - OPEN SERVICE FOR CARD READER.
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB (MUST BE PRESERVED)
;	R4 -> FIRQB (DEFAULT FQFLAG AND FQBUFL VALUE LOADED)
;	R5 -> JOB'S IOB ENTRY (MUST BE PRESERVED)
;
;	...
;
;	RETURN
;
;	-OR-
;
;	CALL	RETDEV
;	ERROR	CODE
;-

	CDRENT	OPN$
	BIC	#CDRMOD,DDFLAG(R1) ;CLEAR THE OLD DEFAULT MODE
	BISB	FQMODE(R4),DDFLAG+1(R1) ; AND SET THE NEW ONE
	BIT	#CDRBSY,DDFLAG(R1) ;READER RUNNING NOW ?
	BNE	10$		;IF SO THEN LET IT ALONE
	BIS	#CDRNDT,DDFLAG(R1) ;SET INITIAL PATTERN

.IF	NE	CD11

	MOV	#CDPCLR,@CSR.CD(R0) ;DO A CONTROLLER CLEAR FOR CD11

GLOBAL	<CSR.CD>

.ENDC

	MOV	R1,CDRBUF(R1)	;BUILD POINTER TO
	ADD	#CDRBUF+2,CDRBUF(R1) ; READER'S BUFFER
	MOV	#12*400+15,CDRBUF+2+160.(R1) ;TERMINATE WITH CR/LF
10$:	;RETURN			;ALL DONE

;+
; CLS$CD,CLS$CR - CLOSE SERVICE FOR CARD READER.
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB/FCB
;	R5 -> DDB/FCB (MUST BE PRESERVED)
;	IF Z=1 THEN A REAL CLOSE CALL
;	IF Z=0 THEN A "RESET" CLOSE CALL
;
;	...
;
;	RETURN
;-

	CDRENT	CLS$

.SBTTL	DEVICE ASSIGNMENT SERVICE

;+
; ASN$CD,ASN$CR - DEVICE ASSIGNMENT SERVICE FOR CARD READER.
;
;	R0 =  JOB NUMBER OF ASSIGNER TIMES 2
;	R1 -> DDB
;
;	...
;
;	RETURN		(WITH ALL REGISTERS PRESERVED)
;-

	CDRENT	ASN$

.SBTTL	DEVICE DEASSIGNMENT SERVICE

;+
; DEA$CD,DEA$CR - DEVICE DEASSIGNMENT SERVICE FOR CARD READER
;
;	R1 -> DDB
;
;	...
;
;	RETURN		(WITH ALL REGISTERS PRESERVED)
;-

	CDRENT	DEA$
	RETURN			;NOTHING TO DO...

.IF	EQ	CD11

.SBTTL	CR11 CARD READER INTERRUPT SERVICE (PR6)

;+
; INT$CR - INTERRUPTS FOR CARD READER.
;
;	R0 =  UNIT NUMBER TIMES 2
;	PRIORITY IS INTERRUPT PRIORITY
;
;	...
;
;	RETURN
;-

INT$CR::MOV	DEV.CR(R0),R1	;;GET THE DDB ADDRESS
	MOV	CDRPTR(R1),R4	;;GET THE BUFFER POINTER
	MOV	CSR.CR(R0),R3	;;GET THE CSR ADDRESS
	MOV	(R3),R2		;; AND ITS CONTENTS
	MOV	CDRBUF(R1),R5	;;GET POINTER TO IMAGE BUFFER
	ASL	R2		;;SHIFT STATUS TO DETERMINE IF
	BCS	30$		;; THERE WAS AN ERROR INTERRUPT OR,
	BMI	CDRI02		;; THERE WAS A CARD DONE INTERRUPT OR,
	ADD	#160.,R5	;; THERE WAS A DATA COLUMN INTERRUPT
	CMP	R4,R5		;;CHECK FOR END OF BUFFER
	BHIS	20$		;;BRANCH HERE IF MORE THAN 80. COLUMNS
	MOV	CRB(R3),(R4)+	;;STORE CHARACTER IN BUFFER
	MOV	R4,CDRPTR(R1)	;;THEN UPDATE THE POINTER
10$:	MOV	#3.,TIM.CR(R0)	;;START A NEW 3 SECOND TIMER
	RETURN			;;EXIT

20$:	SETERR	DATERR,DDFLAG(R1) ;;SET A DATA ERROR
	BR	10$		;;RESET TIMEOUT AND EXIT

30$:	BIT	R2,#CROFFL*2	;;WAS THE ERROR AN OFF LINE ERROR ?
	BEQ	TMO$CR		;;IF NOT, THEN REAL ERROR
	CMP	R4,R5		;;IF SO, WERE ANY COLUMNS READ ?
	BNE	CDRI02		;;IF TRUE, THEN IGNORE ERROR
	BR	CDRI01		;;NOTHING READ, HUNG (NOT LOGGED!)

GLOBAL	<DEV.CR,CSR.CR,TIM.CR>

.ENDC

.SBTTL	TIMEOUTS

;+
; TMO$CD,TMO$CR - TIME OUT ENTRY POINT.
;
;	R0 =  UNIT NUMBER TIMES TWO
;	R1 -> DDB
;	R3 -> CSR
;	PRIORITY IS PR5
;
;	...
;
;	RETURN
;-

	CDRENT	TMO$

.IF	EQ	CD11		;FOR CR11

	LOG$CR			;;LOG CR11/CM11 ERROR
CDRI01:	SETERR	HNGDEV,DDFLAG(R1) ;;SET HUNG DEVICE AS ERROR
CDRI02:	CLR	(R3)		;;A SIMPLE CLEAR TO STOP READING
	CLR	TIM.CR(R0)	;;ZERO THE ASSOCIATED TIMEOUT
	CALLX	IOFINI,R5,JS.CR	;;SIGNAL ALL DONE

GLOBAL	<LOG$CR,TIM.CR,JS.CR>

.IFF				;FOR CD11

	LOG$CD			;;LOG CD11 ERROR
CDRI01:	SETERR	HNGDEV,DDFLAG(R1) ;;SET HUNG DEVICE AS ERROR
CDRI02:	MOV	#CDPCLR,(R3)	;;CLEAR CONTROLLER COMPLETELY
	CLR	TIM.CD(R0)	;;ZERO THE ASSOCIATED TIMEOUT
	CALLX	IOFINI,R5,JS.CD	;;SIGNAL ALL DONE

GLOBAL	<LOG$CD,TIM.CD,JS.CD>

.ENDC

	BIC	#CDRNDT!CDRTRN!CDRBSY,DDFLAG(R1) ;;SET UNTRANSLATED DATA AND NOT BUSY
	RETURN			;;EXIT

.IF	NE	CD11

.SBTTL	CD11 CARD READER INTERRUPT SERVICE (PR4)

;+
; INT$CD - INTERRUPTS FOR CARD READER.
;
;	R0 =  UNIT NUMBER TIMES 2
;	PRIORITY IS INTERRUPT PRIORITY
;
;	...
;
;	RETURN
;-

INT$CD::MOV	DEV.CD(R0),R1	;;GET THE DDB POINTER
	MOV	CSR.CD(R0),R3	;;GET THE CSR ADDRESS
	MOV	CDBA(R3),CDRPTR(R1) ;;SAVE THE BUFFER POINTER
	MOV	(R3),R2		;;GET CSR CONTENTS
	BPL	CDRI02		;;NO ERROR, SO QUIT QUICK
	BIT	R2,#CDBADE	;;NXM,DTL,OR DATA ERROR (SHOULD NEVER HAPPEN)
	BNE	TMO$CD		;;YES. CALL IT DEVICE ERROR
	ASL	R2		;;READER CHECK BIT INTO SIGN
	BPL	10$		;;BRANCH IF NO PICK,STACK,HOPPER,READ CHECKS
	BIT	R2,#CDHPCK*2	;;WAS IT REALLY A HOPPER CHECK ?
	BNE	10$		;;YES
	MOV	CDBB(R3),R4	;;GET THE CONTENTS OF THE READER BUFFER
	BPL	20$		;;BRANCH IF THE ECO WASN'T INSTALLED
	ASL	R4		;;IS IT A READ CHECK?
	BMI	20$		;;YES. THEREFORE A DATA ERROR
.IIF	NE	CDRDCK*2-100000, .ERROR ;THE ABOVE WON'T WORK
10$:	CMP	CDRBUF(R1),CDBA(R3) ;;DID WE READ ANYTHING ?
	BNE	CDRI02		;;YES, SO IGNORE ERROR
	ASL	R2		;;CHECK FOR EOF (1200 CPM MODEL ONLY)
	BPL	CDRI01		;;NOT EOF, DEVICE ERROR (NOT LOGGED!)
	SETERR	EOF,DDFLAG(R1)	;;EOF, SET THAT ERROR
	BR	CDRI02		;; AND EXIT

20$:	SETERR	DATERR,DDFLAG(R1) ;;SET DATA (READ CHECK) ERROR
	LOG$CD			;;LOG A CD11 ERROR
	BR	CDRI02		;; AND EXIT

GLOBAL	<DEV.CD,CSR.CD,LOG$CD>

.ENDC

.SBTTL	SPECIAL FUNCTION SERVICE

;+
; SPC$CD,SPC$CR - SPECIAL FUNCTION SERVICE FOR CARD READER.
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB/FCB
;	R2 =  SPECIAL FUNCTION CODE
;	R3 -> XRB
;	R4 =  CALLING JOB NUMBER TIMES 2
;	R5 -> (MAPPED) XRB
;
;	...
;
;	JMP	RTI3
;
;	-OR-
;
;	ERROR	CODE
;-

	CDRENT	SPC$
	ERROR	PRVIOL		;NO SPECIAL FUNCTION SERVICE

.SBTTL	ERROR LOGGING FOR THE CARD READER

;+
; ERL$CD,ERL$CR - ERROR LOGGING FOR THE CARD READER.
;-

	CDRENT	ERL$

.IF	EQ	CD11

	MOV	TIM.CR(R0),-(SP) ;;;SAVE TIMEOUT INDICATION

.IFF

	MOV	TIM.CD(R0),-(SP) ;;;SAVE TIMEOUT INDICATION

.IFTF

	CALLX	ERLDVR,R5	;;;USE A COMMON ROUTINE

.IFT

	  .BYTE	ERC$CR		;;;ERROR CODE
	  .BYTE	DDS.CR		;;;DDB SIZE IN BYTES
	  .BYTE	0,3		;;;NO OFFSET, 3 REGISTERS

GLOBAL	<TIM.CR,DDS.CR>

.IFF

	  .BYTE	ERC$CD		;;;ERROR CODE
	  .BYTE	DDS.CD		;;;DDB SIZE IN BYTES
	  .BYTE	0,4		;;;NO OFFSET, 4 REGISTERS

GLOBAL	<TIM.CD,DDS.CD>

.ENDC

	  .BYTE	0,0		;;;THAT'S ALL
	TST	(SP)+		;;;WAS IT A TIMEOUT?
	BNE	10$		;;;NO
	COMB	(R0)		;;;YES, INDICATE A TIMEOUT
10$:	RETURN			;;;RETURN TO THE ERROR LOGGER

	.INCLUDE	/CRANSI/	;get the ANSI card punch table	;001
