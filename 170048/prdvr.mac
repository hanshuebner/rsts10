	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
	.INCLUDE /CMN:PRDEF/
TITLE	PRDVR,<PAPER TAPE READER I/O SERVICE>,0A,10-MAY-91,MHB/GW/ABC/SJK/AJK

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR PRDVR
;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;
;  001  AJK  17-JUN-81  REMOVED CODE CAUSING INTERRUPT SERVICE TO OVERLAP WITH
;			USER SERVICE.  THIS CAUSED POSSIBLE LOSS OF CHARACTERS 
;			IN THE CASE WHERE 'FATCH' IS INTERRUPTED BY 'STORE'
;			CALLED FROM INTERRUPT SERVICE.
;			
;-

	DEFORG	PRDVR

	DEFORG	PRDINT

	INCLUDE	ERLDVR

	ORG	PRDVR

; DEFINE 'DDSTS' VALUE FOR PAPER TAPE READER

STS.PR	==	DDWLO/400
		;READ ONLY DEVICE

; DEFINE FLAGS FOR PAPER TAPE PRINTER

FLG.PR	==	FLGFRC!DDWLO!DDNFS!PTRHND
		;BYTE ORIENTED
		;READ ONLY
		;NON-FILE STRUCTURED
		;PAPER TAPE READER

; DEFINE WIDTH

SIZ.PR	==	5*14.+1
		;DEFAULT FOR "NO WIDTH"

; DEFINE DEFAULT BUFFER SIZE

BUF.PR	==	128.
		;DEFAULT BUFFER SIZE IS 128. CHARACTERS

	TMPORG	PRDINT

PRDINT:	CALLX	INTSAV,R5	;SAVE ALL REGISTERS
	  .WORD	1200		;PAR5 VALUE
	  .WORD	INT$PR		;INTERRUPT SERVICE ENTRY POINT

	UNORG

.SBTTL	LEVEL 3 USER SERVICE ROUTINE FOR THE PAPER TAPE READER

;+
; SER$PR - USER LEVEL READ/WRITE SERVICE.
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB/FCB
;	R2 =  2 (.READ)
;	      4 (.WRITE)
;	R3 -> XRB
;	R4 =  CALLING JOB NUMBER TIMES 2
;	R5 -> USER'S BUFFER (THROUGH KISAR6)
;	IF Z=1 OR C=0 THEN THIS IS THE FIRST CALL
;	IF Z=0 OR C=1 THEN THIS IS A "REDO" CALL
;
; NOTES:
;
;	1) ACCESS RIGHTS HAVE BEEN VERIFIED.
;	2) DIRECTIONAL RIGHTS HAVE BEEN VERIFIED.
;
; EXITS:
;
;	1) ALL COMPLETE WITH NO ERROR
;
;		JMP	IOEXIT
;
;	2) ALL COMPLETE WITH ERROR
;
;		SETERR	CODE
;		JMP	IOEXIT
;
;		-OR-
;
;		ERROR	CODE
;
;	3) STALL DESIRED (FOR "REDO" LATER)
;
;		JMP	IOREDO
;-

SER$PR::CLR	XRBLK(R3)	;INDICATE SEQUENTIAL DEVICE
	CLRB	XRBLKM(R3)	; IN BOTH PLACES
10$:	CMP	(R3)+,(R3)+	;POINT TO XRLOC
	CALLX	FETCH,R5,DDBUFC+EP ;FETCH A CHARACTER FROM BUFFER
	MOV	DDFLAG(R1),R4	;GET OVERFLOW (IF ANY), PARITY FLAGS	;001
	BCC	20$		;SKIP IF WE GOT A CHARACTER
	BPL	50$		;NO OVERFLOW, EITHER. TRY TO READ MORE
.ASSUME	PTROVF	EQ	100000
	MOVB	R4,R2		;GET OVERFLOW CHARACTER			;001
	BIC	#PTROVF!PTRVCH,DDFLAG(R1) ;CLEAR THE OVERFLOW FLAG
20$:	BIC	#^C<PRPRTY!PRPODD>,R4 ;ISOLATE THE PARITY FLAGS		;001
	BEQ	30$		;NO PARITY CHECKING, PASS 8-BIT CHARACTERS
	ASR	R4		;SHIFT ODD-PARITY FLAG TO 200 IN LOW BYT;001
.ASSUME	PRPODD/2	EQ	200
.ASSUME	PRPRTY/2&377	EQ	0
	XOR	R2,R4		;MOVE CHARACTER, MAKE IT EVEN PARITY IF OK;001
	BIC	#^C<177>,R2	;STRIP THE CHARACTER TO BE 7-BIT
	ASH	#-4,R4		;SHIFT FOUR BITS DOWN			;001
	XOR	R2,R4		; AND PUT FOUR BITS TOGETHER FOR TABLE INDEX
	BIC	#^C<17>,R4	;ISOLATE TABLE INDEX			;001
	BISB	PTABLE(R4),R2	;TURN ON 200 BIT IF PARITY ERROR	;001
	BPL	30$		;NO ERROR, SO NO SIGNAL TO USER
	SETERR	DATERR,@IOSTS	;TELL HIM WE FOUND A PARITY ERROR
30$:	PUTUSR			;STORE THE CHARACTER IN THE USERS BUFFER
	INC	(R3)		;BUMP THE BUFFER POINTER
	INC	-(R3)		; AND THE BYTE COUNT
	CMP	(R3),-(R3)	;IS THE BUFFER FULL
	BLO	10$		;NO. GO BACK FOR THE NEXT CHARACTER
40$:	JMPX	IOEXIT		;YES. SO WE ARE DONE FOR NOW

50$:	BIT	#100200,@CSR.PR(R0) ;CHECK THE READER'S STATUS
..PCSS	==	.-4	;*PATCH* CHANGE TO 100100 FOR C.S.S. PR
	BMI	70$		;OUT-OF-TAPE, DON'T TRY TO READ MORE
	BNE	60$		;RUNNING NOW, LET IT RUN
	CALL	START		;IDLE, START THE READER READING
60$:	JMPX	IOREDO		;STALL THIS JOB FOR READER

70$:	TST	-(R3)		;DID WE TRANSFER ANYTHING THIS TIME?
	BNE	40$		;IF SO, THEN GIVE ERROR NEXT TIME
	TST	(R1)		;WAS THERE EVER ANY TAPE IN THE READER??
	BMI	80$		;YES, SO GIVE THE END-OF-FILE ERROR
.ASSUME	DDSTAT	EQ	100000
	ERROR	HNGDEV		;NO TAPE AT ALL SO CALL IT HUNG

80$:	ERROR	EOF		;END-OF-FILE ERROR

GLOBAL	<PTABLE,CSR.PR>

.SBTTL	PAPER TAPE READER OPEN

;+
; OPN$PR - OPEN SERVICE FOR PAPER TAPE READER.
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB (MUST BE PRESERVED)
;	R4 -> FIRQB (DEFAULT FQFLAG AND FQBUFL VALUE LOADED)
;	R5 -> JOB'S IOB ENTRY (MUST BE PRESERVED)
;
;	...
;
;	RETURN
;
;	-OR-
;
;	CALL	RETDEV
;	ERROR	CODE
;-

OPN$PR::MOV	FQMODE(R4),R2	;GET THE MODE BITS FOR PARITY CHECKING
	BIC	#^C<2+1>,R2	;ISOLATE ONLY BIT 1 (ENABLE) AND BIT 0 (ODD)
	ASR	R2		;SHIFT EVEN/ODD INTO CARRY
	BEQ	10$		;NO ENABLING BIT, SO LEAVE A ZERO MODE
	ROL	R2		;PUT EVEN/ODD BIT BACK
10$:	MOVB	R2,DDFLAG+1(R1)	;STOW THE PARITY MODE

.SBTTL	PAPER TAPE READER CLOSE

;+
; CLS$PR - CLOSE SERVICE FOR PAPER TAPE READER.
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB/FCB
;	R5 -> DDB/FCB (MUST BE PRESERVED)
;	IF Z=1 THEN A REAL CLOSE CALL
;	IF Z=0 THEN A "RESET" CLOSE CALL
;
;	...
;
;	RETURN
;-

CLS$PR::CLR	@CSR.PR(R0)	;BE SURE TO STOP READER
	CALLX	CLRBUF,R5,DDBUFC+EP ;CLEAR THE INPUT BUFFER
	BIC	#DDSTAT,(R1)	;INDICATE THAT ITS THE FIRST TIME THROUGH
	BIC	#PTROVF!PTRVCH,DDFLAG(R1) ;CLEAR THE OVERFLOW FLAG
	;RETURN			;THAT'S ALL

GLOBAL	<CSR.PR>

.SBTTL	DEVICE ASSIGNMENT SERVICE

;+
; ASN$PR - DEVICE ASSIGNMENT SERVICE FOR PAPER TAPE READER.
;
;	R0 =  JOB NUMBER OF ASSIGNER TIMES 2
;	R1 -> DDB
;
;	...
;
;	RETURN		(WITH ALL REGISTERS PRESERVED)
;-

ASN$PR::			;NOTHING TO DO

.SBTTL	DEVICE DEASSIGNMENT SERVICE

;+
; DEA$PR - DEVICE DEASSIGNMENT SERVICE FOR PAPER TAPE READER.
;
;	R1 -> DDB
;
;	...
;
;	RETURN		(WITH ALL REGISTERS PRESERVED)
;-

DEA$PR::RETURN			;NOTHING TO DO...

.SBTTL	INTERRUPT SERVICE (PR4)

;+
; INT$PR - INTERRUPTS FOR PAPER TAPE READER.
;
;	R0 =  UNIT NUMBER TIMES 2
;	PRIORITY IS INTERRUPT PRIORITY
;
;	...
;
;	RETURN
;-

.ENABL	LSB

INT$PR::MOV	DEV.PR(R0),R1	;;GET DDB ADDRESS
	MOV	CSR.PR(R0),R3	;;HARDWARE STATUS REGISTER
	CLR	TIM.PR(R0)	;;CLEAR TIMEOUT IF WE INTERRUPTED
	TST	(R3)		;;OUT OF TAPE?
	BMI	40$		;;YES, CLEAR INT ENB & START JOB
	MOVB	PRB(R3),R2	;;ELSE GET CHARACTER
	CALLX	STORE,R5,DDBUFC+FP ;;PUT THE CHARACTER INTO THE BUFFER CHAIN
	BCS	30$		;;DIDN'T FIT
	MOV	DDBUFC+BC(R1),R4 ;;GET # BUFFERS NOW IN USE
	BLT	40$		;;IF OVER QUOTA THEN STOP READER
	CALL	START		;;ELSE KEEP THE READER RUNNING
20$:	RETURN			;;EXIT FROM INTERRUPT


30$:	MOVB	R2,DDFLAG(R1)	;;STORE OVERFLOW CHAR
	BIS	#PTROVF,DDFLAG(R1) ;; AND SET THE OVERFLOW BIT
40$:	CLR	(R3)		;;DISABLE INTERRUPT
	CALLX	IOFINI,R5,JS.PR	;;FINISH UP I/O AND START JOB		;001
	BR	20$		;;RETURN FROM INTERRUPT			;001

GLOBAL	<DEV.PR,CSR.PR,TIM.PR,JS.PR>

.SBTTL	TIMEOUTS

;+
; TMO$PR - TIMEOUT ENTRY POINT.
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB
;	R3 -> CSR
;	PRIORITY IS PR5
;
;	...
;
;	RETURN
;-

TMO$PR::LOG$PR			;;LOG A READER ERROR
	BR	40$		;;DISABLE READER AND AWAKEN JOB

.DSABL	LSB

; START THE READER READING ROUTINE

START:	BIS	#DDSTAT,(R1)	;INDICATE WE HAVE TRIED TO READ ONCE
	MOV	#5.,TIM.PR(R0)	;START A TIMEOUT
	MOV	#101,@CSR.PR(R0) ; AND MAKE THE READER GO
	RETURN			;  THEN BACK

GLOBAL	<LOG$PR,TIM.PR,CSR.PR>

.SBTTL	SPECIAL FUNCTION SERVICE

;+
; SPC$PR - SPECIAL FUNCTION SERVICE FOR PAPER TAPE READER.
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB/FCB
;	R2 =  SPECIAL FUNCTION CODE
;	R3 -> XRB
;	R4 =  CALLING JOB NUMBER TIMES 2
;	R5 -> (MAPPED) XRB
;
;	...
;
;	JMP	RTI3
;
;	-OR-
;
;	ERROR	CODE
;-

SPC$PR::ERROR	PRVIOL		;NO SPECIAL FUNCTION SERVICE

.SBTTL	ERROR LOGGING

ERL$PR::CALLX	ERLDVR,R5	;;;USE A COMMON ROUTINE
	  .BYTE	ERC$PR		;;;ERROR CODE
	  .BYTE	DDS.PR		;;;DDB SIZE IN BYTES
	  .BYTE	0,2		;;;NO OFFSET, 2 REGISTERS
	  .BYTE	0,0		;;; AND NO MORE...
	COMB	(R0)		;;;INDICATE TIMEOUT TYPE ERROR
	RETURN			;;;RETURN TO THE ERROR LOGGER

GLOBAL	<DDS.PR>

.END

