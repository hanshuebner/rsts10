	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
	.LIBRARY /CMN:NETDEF.SML/
TITLE	XMDVR,<DMC-11 DRIVER>,0A,10-MAY-91,JDM/ABC/MHB/RTW/GPK/RVR/GMB/FRL/JHC/KPH/MNB/DWF

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR XMDVR.MAC

;+
; EDIT  BY    DATE		REASON
;
;  01  RVR  18-May-81	Added Net. Mgmt. V2.1 counters.
;
;  02  RVR  31-MAY-81	Fixed BIS(B) bug in FTLERR routine and
;			corrected label position for 110$ in L3Q code.
;
;  03  RVR  02-Aug-81	Corrected operands of BIS in FTLERR routine.
;			Setup save of R3 in Return Counters call to
;			DMC Base Table fetch & update routine. Fix
;			XRB (via R3) references in Return Counters setup.
;			Fix counter update routine to update after
;			saved bytecount trimmed of addr bits 16&17.
;			Fixed Transport job # check in SPC$XM handling.
;			Correct basetable counter update code in Return
;			Counters function.
;
;  04  RVR  06-Aug-81	Removed "Date/Time Counters were last zeroed"
;			storage area - to be moved into TRN portion
;			of DDB. Added FC$STA entry point in SER$XM
;			handling.
;
;  05  RVR  10-Aug-81	Changed several references to handle I&D mapping.
;			Changed Basetable counter handling to preserve
;			stored counters across Open/Close functions.
;
;  06  GPK  15-Aug-81	Bugfix to RDCTR/SAVCTR
;
;  07  RVR  21-Aug-81	Bugfix to Receive Complete counter updating code.
;
;  08  RVR  03-Sep-81	Bugfix to Return Status Read (RMOD 4096).
;
;  09  RVR  30-Sep-81	Changed device init routines to zero basetable
;			and leave traffic counters intact on device
;			inits/restarts.
;
;  10  GPK  06-Oct-81	Counter timer hooks
;
;  11  RVR  27-Oct-81	Doubled FLAP counter as per QAR report to accomodate
;			DMR11's on fast machines.
;
;  12  GPK  22-Jan-82	Patch 3.7.6 -- don't mess up circuit counters when
;			the device is turned off
;
;  13  GMB  09-Dec-82	Insure buffer size correct in SUPBUF and
;			removed bit fiddling from TENTRN
;
;				[RSTS V9.0]
;  014	GPK  06-May-83	Multiple privileges
;  015	GPK  09-Jun-83	Changed .PRIV to .BPRIV
;  016	FRL  23-Nov-83	Removed old L3Q globals
;  017	GPK  20-Apr-84	Privilege name changes
;  018	GPK  25-Apr-84	Remove large posting stuff
;  019	GPK  22-May-84	Source-clear 3.7.16
;  020  JHC  30-Oct-84	Fix buffer return problem in user interface
;  021	JHC  09-Apr-85	Source clear 3.7.5 small buffer confusion (May '83)
;  022	GPK  17-Apr-85	Don't use MONPOL for buffers
;
;				[RSTS V9.2]
;  023  KPH  16-Aug-85	Add job control region
;
;				[RSTS V9.3]
;  024	MNB  17-Mar-86	Don't supply buffers for DECnet, remove L.BMIN
;			references, lock out interrupts in RBFTRN
;  025	DWF  25-Mar-86	Set IEI correctly
;  026  KPH  17-Apr-86	Bugfix in SUPBUF
;  027  KPH  05-May-86	User buffer is now mapped on entry at SPC$
;  028  KPH  11-Jul-86	Remove BSTALL stuff; simply try to allocate
;			buffers when below quota in done service
;			Don't give any buffers to the DMC-11 until the
;			core table has been assigned.
;			Fix race conditions making jobs runnable
;			Remove references to L.HTMR
;  029	DWF  21-Nov-86	Fix receive buffer handling
;-

.SBTTL	DEFINE NEEDED SYMBOLS

.MCALL	$CCB,$NETDDB,$NETDEF,$COUNT

	$CCB
	$NETDDB
	$NETDEF
	$COUNT

.SBTTL	DEVICE DEPENDENT PORTION OF THE DDB LAYOUT

.DSECT	L.DDEP

XMBSIZ:	.BLKW			;RECEIVE BUFFER SIZE FOR THIS LINE
XMMODE:	.BLKW			;OPERATIONAL MODE (BIT DEFINITIONS BELOW)
XMCTBL:	.BLKW			;CORE TABLE ADDRESS (ABSOLUTE OR CONTORTED)
XMBQTA:	.BLKB			;QUOTA OF RECEIVE BUFFERS REQUIRED
XMTIMR:	.BLKB			;NUMBER OF SECONDS FOR TRANS TIME OUTS
XMFLG2:	.BLKW			;SECOND WORD OF FLAGS
XMCTLO:	.BLKW			;SEL6 VALUE FROM CONTROL OUT
XMECTR:	.BLKW	3		;COUNTERS FOR NON-FATAL DMC ERRORS
XMLCTR:	.BLKB	6		;DMC LINE COUNTERS FROM BASE TABLE
XM.BTL	=: .-XMLCTR		;LENGTH OF BASE TABLE LINE COUNTER AREA
XMTIPQ:	.BLKW	2		;XMIT IN PROGRESS QUEUE - GIVEN TO DMC
XMRIPQ:	.BLKW	2		;REC  IN PROGRESS QUEUE - GIVEN TO DMC
XMTQUE:	.BLKW	2		;TRANSMIT PENDING QUEUE - NOT YET GIVEN TO DMC
XMRQUE:	.BLKW	2		;RECEIVE PENDING QUEUE  - NOT YET GIVEN TO DMC
XMRCPQ:	.BLKW	2		;REC  COMPLETE QUEUE    - NON DECNET USE
XMCPLQ:	.BLKW	2		;COMPLETION QUEUE
XMQEND:				;END OF QUEUES
XMTCNT:	.BLKB			;NUMBER OF TRANSMIT BUFFERS GIVEN TO DMC
XMNXMT:	.BLKB			;TOTAL NUMBER OF BUFFERS PENDING ON XMIT SIDE
XMNRCP:	.BLKB			;NUMBER OF BUFFERS ON USER RCV COMPLETE QUEUE
XMERR:	.BLKB			;DMC-11 "LAST ERROR RECEIVED" CODE
XMRCNT:	.BLKB			;NUMBER OF RECEIVE BUFFERS GIVEN TO DMC
XMNRCV:	.BLKB			;TOTAL NUMBER OF BUFFERS ASSIGNED TO RECEIVE

XMERRC:				;START OF NET MGMT V2.1 TRAFFIC COUNTERS
XMXBYT:	.BLKW	2		;NUMBER OF BYTES TRANSMITTED
XMXMSG:	.BLKW	2		;NUMBER OR MESSAGES TRANSMITTED
XMRBYT:	.BLKW	2		;NUMBER OF BYTES RECEIVED
XMRMSG:	.BLKW	2		;NUMBER OF MESSAGES RECEIVED
XM.TTL	=: .-XMXBYT		;LENGTH OF TRAFFIC COUNTER AREA
XMENDC:

XMDDSZ:				;SIZE OF DDB

; CHECK ORDERING REQUIREMENTS
.ASSUME	XMBQTA&1 EQ 0
.ASSUME	XMTIPQ+4 EQ XMRIPQ
.ASSUME	XMTQUE+4 EQ XMRQUE
.ASSUME	XMTQUE-XMTIPQ EQ XMRQUE-XMRIPQ
.ASSUME	XMRCNT-XMTCNT EQ XMRQUE-XMTQUE
.ASSUME	XMNRCV-XMNXMT EQ XMRQUE-XMTQUE

; BITS DEFINED IN DDFLAG

.BSECT

	.BLKB	177		;RESERVED
XM.DMR:	.BLKB	.		;DEVICE IS DMR-11 IF SET, ELSE IS A DMC-11
XM.OPN:	.BLKB	.		;DEVICE HAS BEEN OPENED
XM.SUP:	.BLKB	.		;DMC11 WAITING FOR DSR TO GIVE BASE TABLE
XM.FXC:	.BLKB	.		;FIRST TRANSFER COMPLETE
XM.FLS:	.BLKB	.		;USER WAITING FOR OUTPUT QUEUES TO EMPTY
XM.WAT:	.BLKB	.		;USER WAITING FOR INPUT BUFFER
XM.ERR:	.BLKB	.		;REQUEST L3 POSTING OF ERROR TO TRN
	.BLKB	.		;Reserved				;028
DDSTAT:	.BLKB	.		;DEVICE IS RUNNING

; BITS DEFINED IN XMFLG2

.BSECT	HIGH

XM.DS1:	.BLKB	.		;DSR HIGH ON LAST TIMEOUT.
XM.DSR:	.BLKB	.		;DSR ON FOR AT LEAST ONE FULL SECOND.
	.BLKB	.		;RESERVED
	.BLKB	.		;RESERVED
	.BLKB	.		;RESERVED
	.BLKB	.		;RESERVED
	.BLKB	.		;RESERVED
	.BLKB	.		;RESERVED

; ERROR CODES IN XMERR

.DSECT	-1

ER.TMO:	.BLKB			;TIME OUT WITH XMIT PENDING
ER.DMC:	.BLKB			;DMC11 HARDWARE ERROR
ER.UNK:	.BLKB			;UNKNOWN CTLO INTERRUPT
ER.III:	.BLKB			;ILLEGAL INPUT INTERRUPT
ER.IOI:	.BLKB			;ILLEGAL OUTPUT INTERRUPT
ER.UII:	.BLKB			;UNSOLICITED INPUT INTERRUPT
ER.UOI:	.BLKB			;UNEXPECTED OUTPUT INTERRUPT
ER.MRC:	.BLKB			;DDCMP MAINTENANCE MESSAGE RECEIVED
ER.LSD:	.BLKB			;LOST DATA ERROR
ER.OFF:	.BLKB			;OFF-LINE (GENERATED BY DRIVER)
ER.DIS:	.BLKB			;DISCONNECT ON LINE
ER.STR:	.BLKB			;DDCMP START RECEIVED
ER.NEM:	.BLKB			;UNIBUS ADDRESS TIMEOUT ON DMC ACCESS
ER.PRO:	.BLKB			;PROCEDURE ERROR 

; BITS DEFINED IN XMMODE

.BSECT	HIGH
 
XM.MNT:	.BLKB	.		;DDCMP MAINTAINTENANCE MODE
XM.HOS:	.BLKB	.		;HANG-UP ON RECEIVING A START IF SET
XM.HDX:	.BLKB	.		;HALF DUPLEX OPERATION IF SET
XM.SEL:	.BLKB	.		;LONG SELECT TIMER (DMR ONLY)
	.BLKB	.		;RESERVED
	.BLKB	.		;RESERVED
XM.LUL:	.BLKB	.		;LINE UNIT LOOP BACK
	.BLKB	.		;RESERVED

.SBTTL	DEFINE DMC11 HACK COMMANDS

DMCRUN	=	202		;WHEN MOVED TO BSEL1 THE DMC EXECUTES THE 
				;INSTRUCTION IN SEL6 EVERY 300 NSEC.
DMCDSR	=	010		;DSR BIT IN THE DMC11 LINE UNIT.

; SEL6 INSTRUCTIONS (THESE ARE KMC-11 OPCODES WHICH ARE
; EXECUTED REPEATEDLY WHEN THE DMCRUN COMMAND IS ISSUED)

DRPDTR	=	122013		;DROP DTR COMMAND
				;  OUT	IBUS, BSEL0, MODEM CSR
DSPDSR	=	021263		;MOVE LINE UNIT STATUS TO BSEL3
				;  OUT  IBUS, MODEM CSR, BSEL3

; SECONDARY BUFFER DESCRIPTOR AUXILIARY DEFINITIONS

; DMC AUXILIARY DEFINITIONS
;
; THE FIRST 2 WORDS OF THE SECONDARY BUFFER DESCRIPTOR ARE
; USED FOR TRANSMIT, RECEIVE, AND RECEIVE COMPLETE.

.DSECT	CC.SEC

CC.XBA:	.BLKW			;LOW ORDER 16 BITS OF 18 BIT ADDRESS
CC.XBC:	.BLKW			;BITS 14,15 = HI ORDER 2 BITS OF ADDRESS
				;BITS 13,0  = CHARACTER COUNT

.SBTTL	DMC11 HARDWARE DEFINITIONS
 
; REGISTER OFFSETS
 
.DSECT
 
SEL0:	.BLKW			;DMC SELECT 0
SEL2:	.BLKW			;DMC SELECT 2
SEL4:	.BLKW			;DMC SELECT 4
SEL6:	.BLKW			;DMC SELECT 6
 
.DSECT
 
BSEL0:	.BLKB			;DMC BYTE SELECT 0
BSEL1:	.BLKB			;DMC BYTE SELECT 1
BSEL2:	.BLKB			;DMC BYTE SELECT 2
BSEL3:	.BLKB			;DMC BYTE SELECT 3
BSEL4:	.BLKB			;DMC BYTE SELECT 4
BSEL5:	.BLKB			;DMC BYTE SELECT 5
BSEL6:	.BLKB			;DMC BYTE SELECT 6
BSEL7:	.BLKB			;DMC BYTE SELECT 7
 
; SEL0 BIT DEFINITIONS
 
.BSECT
 
	.BLKB	2
IFC:	.BLKB	1		;INPUT FUNCTION CODE BITS (SEE BELOW)
ITR:	.BLKB	.		;INPUT TRANSMIT/RECEIVE INDICATOR
	.BLKB	.		;RESERVED
	.BLKB	.		;RESERVED
RQI:	.BLKB	.		;REQUEST IN
IEI:	.BLKB	.		;INTERRUPT ENABLE INPUT
RDYI:	.BLKB	.		;READY FOR INPUT
	.BLKB	.		;STEP MICROPROCESSOR
	.BLKB	.		;ROM IN
	.BLKB	.		;ROM OUT
LUL:	.BLKB	.		;LINE UNIT LOOP
	.BLKB	.		;STEP LU
	.BLKB	.		;RESERVED
MCLR:	.BLKB	.		;MASTER CLEAR
	.BLKB	.		;RUN

; SEL0 FUNCTION DEFINITIONS (INPUT TO THE DMC11)

.DSECT

BACCI:	.BLKB			;BUFFER ADDRESS AND CHARACTER COUNT IN
CNTLI:	.BLKB			;CONTROL IN
	.BLKB			;RESERVED
BASEI:	.BLKB			;BASE ADDRESS IN

; BSEL2 BIT DEFINITIONS
 
.BSECT
 
	.BLKB	2
OFC:	.BLKB	1		;OUTPUT FUNCTION CODE (SEE BELOW)
OTR:	.BLKB	.		;OUTPUT TRANSMIT/RECEIVE INDICATOR
	.BLKB	.		;RESERVED BIT
	.BLKB	.		;RESERVED BIT
	.BLKB	.		;RESERVED BIT
IEO:	.BLKB	.		;INTERRUPT ENABLE OUTPUT
RDYO:	.BLKB	.		;READY WITH OUTPUT


; SEL2 FUNCTION DEFINITIONS (OUTPUT FROM THE DMC11)

.DSECT

BACCO:	.BLKB			;BUFFER ADDRESS AND CHARACTER COUNT OUT
CNTLO:	.BLKB			;CONTROL OUT
	.BLKB			;RESERVED
	.BLKB			;RESERVED

; INPUT SEL4 DEFINITIONS
 
; SEL4 IS ALWAYS THE LOW-ORDER 16 BITS OF A UNIBUS ADDRESS
 
; INPUT SEL6 DEFINITIONS
 
; BA/CC IN (SEL6 DEFINITIONS)

.BSECT

	.BLKB	17776		;FILLER
CC:	.BLKB	120001		;CHARACTER COUNT IS IN LOW 14. BITS
MEB:	.BLKB			;MEMORY EXTENSION BITS 

; BASE IN (SEL6 DEFINITIONS)

.BSECT

	.BLKB	7777
RESUME:	.BLKB	.		;RESUME OPERATION (NOT USED)
	.BLKB	120000
MEB:	.BLKB			;MEMORY EXTENSION BITS

; CONTROL IN (SEL6 DEFINITIONS)
 
.BSECT	HIGH
 
XM.MNT:	.BLKB	.		;DDCMP MAINTAINTENANCE MODE
	.BLKB	.		;RESERVED
XM.HDX:	.BLKB	.		;HALF DUPLEX OPERATION IF SET
XM.SEL:	.BLKB	.		;LONG SELECT TIMER (DMR ONLY)
	.BLKB	.		;RESERVED
	.BLKB	.		;RESERVED
	.BLKB	.		;RESERVED
	.BLKB	.		;RESERVED

; CONTROL OUT (SEL6 DEFINITIONS)
 
.BSECT
 
XMDCHK:	.BLKB	.		;DATA CHECK ERROR, NPR LATE ERROR (NON-FATAL)
XMTMO:	.BLKB	.		;TIMEOUT (NON-FATAL)
XMOVRN:	.BLKB	.		;RECEIVE OVERRUN (NON-FATAL)
XMBOOT:	.BLKB	.		;BOOT MESSAGE RECEIVED
XMLOST:	.BLKB	.		;LOST DATA ERROR
	.BLKB	.		;RESERVED BIT
XMDISC:	.BLKB	.		;DISCONNECT
XMSTRT:	.BLKB	.		;START MESSAGE RECEIVED
XMNXM:	.BLKB	.		;NON-EXISTENT MEMORY ERROR
XMPROC:	.BLKB	.		;PROCEDURE ERROR
 
.EQUATE	XMERRS,	<XMDCHK!XMTMO!XMOVRN!XMBOOT!XMLOST!XMDISC!XMSTRT!XMNXM!XMPROC>

.SBTTL	LOAD ADDRESSES INTO "XMDINT"

	TMPORG	XMDINT,0

	.BLKW	3		;FILL FOR CALL INTSAV,R5 + .WORD 1200
	.WORD	XMI$CI		;ENTRY FOR DMC CONTROL IN INTERRUPTS

	.BLKW	3		;FILL FOR CALL INTSAV,R5 + .WORD 1200
	.WORD	XMI$CO		;ENTRY FOR DMC CONTROL OUT INTERRUPTS

; MISCELLANEOUS DEFINITIONS
 
.EQUATE	BTBSZ,	128.*2		;BASE TABLE SIZE
.EQUATE	RBUFMX,	512.+128.-BUFHDR ;MAXIMUM RECEIVE BUFFER SIZE
.EQUATE	LOOPCT,	2.*255.		;DEVICE INITIALIZATION LOOP COUNTS
.EQUATE	RDIDLA,	20		;DELAY COUNTER WAIT FOR RDYI AFTER RQI SET

	UNORG

.SBTTL	ORG DMC11 MAIN DRIVER CODE.

	DEFORG	XMDVRM		;PUT DMC DRIVER CODE IN XMDVRM

.SBTTL	SLP$XM - DMC11 "SLEEP" CHECKING (NON-DECNET USE)

;+
; SLP$XM - "SLEEP" CHECKING ENTRY POINT.
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB
;	R4 -> JOB'S IOB @ CH# +2
;
;	...
;
;	R0 =  RANDOM
;	R1 =  RANDOM
;	R4 =  RANDOM
;
;	IF C=1 THEN DON'T LET THE JOB "SLEEP"
;	IF C=0 THEN LET THE JOB "SLEEP"
;
;	RETURN
;-

	TMPORG	XMDINT,52

	.WORD	SLP$XM

	UNORG

SLP$XM:	MOV	XMRCPQ(R1),R0	;CHECK FOR ENTRY IN RECEIVE COMPLETION QUEUE
	NEG	R0		;SET C=1 IF AND ONLY IF R0<>0
	RETURN			;EXIT

.SBTTL	OPN$XM - DMC11 OPEN ROUTINE (NON-DECNET USE)

;+
; OPN$XM - OPEN SERVICE FOR DMC11.
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB (MUST BE PRESERVED)
;	R4 -> FIRQB (DEFAULT FQFLAG AND FQBUFL VALUE LOADED)
;	R5 -> JOB'S IOB ENTRY (MUST BE PRESERVED)
;
;	...
;
;	RETURN
;
;	-OR-
;
;	CALL	RETDEV
;	ERROR	CODE
;-

	TMPORG	XMDINT,32

	.WORD	OPN$XM

	UNORG

.ENABL	LSB

OPN$XM:	TSTB	DDCNT(R1)	;ONLY FIRST OPEN DOES ANYTHING
	;CLC			;C=0 FROM 'TST' TO INDICATE OPN ENTRY
	BR	10$		;MERGE FOR COMMON ENTRY

.SBTTL	CLS$XM - DMC11 CLOSE ROUTINE (NON-DECNET USE)

;+
; CLS$XM - CLOSE SERVICE FOR DMC11.
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB/FCB
;	R5 -> DDB/FCB (MUST BE PRESERVED)
;	IF Z=1 THEN A REAL CLOSE CALL
;	IF Z=0 THEN A "RESET" CLOSE CALL
;
;	...
;
;	RETURN
;-

CLS$XM:	CMPB	DDCNT(R1),#1	;LAST CLOSE?
	SEC			;C=1 TO INDICATE CLS ENTRY
10$:	BNE	20$		;NOT 1ST OPEN/LAST CLOSE, SO DO NOTHING
	MOV	R5,-(SP)	;SAVE IOB OR DDB ADDRESS
	MOV	R1,-(SP)	;SAVE DDB ADDRESS
	MOV	CSR.XM(R0),R3	;SET POINTER TO CSR
	CALL	XMOPCL		;CALL TO OPEN OR CLOSE, DEPENDING ON C
	MOV	(SP)+,R1	;RESTORE DDB ADDRESS
	MOV	(SP)+,R5	;RESTORE IOB ENTRY
	BCS	30$		;IF C SET - ERROR ON OPEN (NEVER ON CLOSE)
	TST	(PC)+		;INDICATE SUCCESS, SKIP NEXT LINE
15$:	SEC			;INDICATE FAILURE
20$:	RETURN			;EXIT
 
; ERROR DETECTED AT INITIALIZATION
 
30$:	CMPB	DDJBNO(R1),#TRNJOB ;UNIT OWNED BY TRN?
	BEQ	15$		;YES, SET CARRY AND EXIT
	MOV	R0,R3		;HANG ON TO ERROR CODE
	CALLX	RETDEV		;RETURN DEVICE
	MOV	R3,R0		;RESTORE ERROR CODE
	JMPX	ERROR		;RETURN THE ERROR

.DSABL	LSB

GLOBAL	<CSR.XM>	

	; THIS IS AFTER CLOSE SO OPEN BRANCH CAN REACH

	TMPORG	XMDINT,36

	.WORD	CLS$XM

	UNORG

.SBTTL	SER$XM - DMC11 READ WRITE SERVICE

;+
; SER$XM - USER LEVEL READ/WRITE SERVICE.
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB/FCB
;	R2 =  2 (.READ)
;	      4 (.WRITE)
;	R3 -> XRB
;	R4 =  CALLING JOB NUMBER TIMES 2
;	R5 -> USER'S BUFFER (THROUGH KISAR6)
;	IF Z=1 OR C=0 THEN THIS IS THE FIRST CALL
;	IF Z=0 OR C=1 THEN THIS IS A "REDO" CALL
;
; MAY ALSO BE ENTERED FROM THE SYSTEM (TRANSPORT)
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB
;	R2 =  6  (TRN TRANSMIT)
;	      10 (RETURN RECEIVE BUFFER TO DRIVER)
;	R4 =  JUNK
;	R5 -> CCB
;
; NOTES:
;
;	1) ACCESS RIGHTS HAVE BEEN VERIFIED.
;	2) DIRECTIONAL RIGHTS HAVE BEEN VERIFIED.
;
; EXITS:
;
;	1) ALL COMPLETE WITH NO ERROR
;
;		JMP	IOEXIT
;
;	2) ALL COMPLETE WITH ERROR
;
;		SETERR	CODE
;		JMP	IOEXIT
;
;		-OR-
;
;		ERROR	CODE
;
;	3) STALL DESIRED (FOR "REDO" LATER)
;
;		JMP	IOREDO
;
;	IF CALL WAS MADE WITH A SYSTEM FUNCTION, EXIT IS
;
;		RETURN
;-

	TMPORG	XMDINT,26

	.WORD	SER$XM

	UNORG

SER$XM:	ROR	R0		;SAVE CARRY (R0 WAS EVEN)
	CMP	R2,#4		;SYSTEM CALL (FROM TRN)?
	BHI	10$		;YES, NO XRB TO CLEAN UP
	CLR	XRBLK(R3)	;CLEAN UP THE RETURNED BLOCK # FOR SANITY
	CLRB	XRBLKM(R3)	; AND BLOCK # MSB ALSO
10$:	ASL	R0		;RESTORE R0 AND CARRY
	BIC	#XM.WAT!XM.FLS,DDFLAG(R1) ;TURN OFF FLAGS, CHECK FOR ENABLED
	JMP	@20$-2(R2)	;DISPATCH ON READ/WRITE

20$:	.WORD	READXM		;2  READ
	.WORD	WRITXM		;4  WRITE
	.WORD	TENTRN		;6  TRANSMIT TRN BUFFER
	.WORD	SUPBUF		;10 SUPPLY RECEIVE BUFFER
	.WORD	STATUS		;12 RETURN LINE/CIRCUIT STATUS (ON/OFF ONLY)

.ASSUME	.READ&377  EQ 2
.ASSUME .WRITE&377 EQ 4
.ASSUME	FC$XMT	   EQ 6
.ASSUME	FC$BUF	   EQ 10
.ASSUME	FC$STA	   EQ 12

.ENABL	LSB

WRITXM:	BPL	32$		;DEVICE IS NOT RUNNING, GIVE ERROR
	BCS	10$		;I/O REDO - NEVER TRANSMIT DATA
	BIT	#010000,XRMOD(R3) ;NO DATA TO TRANSMIT?
	BNE	10$		;YES, JUST A STATUS CHECK/STALL
	MOV	R3,-(SP)	;SAVE XRB POINTER
	MOV	R1,-(SP)	;SAVE THE DDB POINTER
	MOV	XRBC(R3),R1	;GET THE NUMBER OF BYTES TO SEND
	CMP	R1,#8000.	;MORE THAN 8000 (A 1000 ROUNDING OF)
				;4K-64W (MAX FOR 'BLKMOV')?
	BHI	130$		;YES, THE COUNT IS BAD
	BUFFER	GETSML,,20.	;ALLOCATE A SMALL BUFFER FOR A CCB	;022
	BVS	30$		;IF V SET (NO BUFFER) - RETURN ERROR
	MOV	R4,-(SP)	;SAVE CCB ADDRESS
	MOV	R1,R0		;COPY THE COUNT FOR BLKMOV
	ADD	#BUFHDR,R1	;REQUEST INCLUDES BUFFER HEADER WORDS
	MOV	#-1,R2		;Do not use MONPOL for buffers		;022
	CALLX	BUFFER,R5,EXTPOL ;GET A BUFFER FROM EXTENDED POOL
	BCS	20$		;IF C SET (NO BUFFER) - RETURN ERROR
	MOV	R0,R2		;NEED COUNT IN R0 AND R2 FOR EXEC MOVER
	CALLX	BLKMOV		;MOVE USER DATA INTO SYSTEM BUFFER
	MOV	(SP)+,R5	;CCB ADDRESS BACK TO R5
	MOV	(SP)+,R1	;RESTORE DDB ADDRESS
	MOV	R4,CC.BUF+BF.ADR(R5) ;STORE BUFFER ADDRESS INTO CCB
	MOV	R0,CC.BUF+MS.SIZ(R5) ;ALSO STORE COUNT IN CCB
	CALLX	MAPBUF		;MAP THE DATA BUFFER THROUGH PAR6
	MOV	@DPAR6,CC.BUF+BF.MMU(R5) ;SAVE THE MMU ADDRESS
	MOV	R3,CC.BUF+BF.VIR(R5) ; AND THE VIRTUAL ADDRESS
	CALL	TENAB		;QUEUE THE TRANSMIT BUFFER
	MOV	(SP)+,R3	;RESTORE THE XRB POINTER
10$:	TSTB	XMNXMT(R1)	;ANY BUFFERS IN THE TRANSMIT QUEUE?
	BEQ	50$		;NO, EASY EXIT
	CALL	XMWAIT,R5,XM.FLS ;STALL UNTIL BUFFERS FLUSHED IF REQUESTED
	BR	50$		;EXIT IF NO WAIT REQUESTED

20$:	MOV	(SP)+,R4	;RESTORE CCB ADDRESS FOR DEALLOCATION
	BUFFER	RETSML		;RETURN THE BUFFER USED FOR CCB
30$:	ERROR	NOBUFS		;NO BUFFERS, SORRY

32$:	JMP	120$		;Too far to walk, soo...

GLOBAL	<EXTPOL>

; USER GET DATA REQUEST - LOOK FOR RECEIVED DATA AND GIVE TO USER
 
READXM:	MOV	R1,R0		;COPY THE POINTER
	ADD	#XMRCPQ,R0	;BIAS UP TO RECEIVE COMPLETE QUEUE
	BIT	#010000,XRMOD(R3) ;DOES HE WANT STATUS RETURNED?
	BNE	60$		;YES, DO IT EASILY
	MOV	R5,R2		;Copy user buffer pointer		;018
	CALLX	POPQUE		;GET FIRST MESSAGE ON THE QUEUE
	BCS	110$		;IF NOTHING QUEUED, RETURN ERROR
	DECB	XMNRCP(R1)	;ONE FEWER BUFFER ON RCV COMPLETE QUEUE
	MOV	CC.BUF+BF.ADR(R5),R4 ;Get buffer's contorted address
	MOV	CC.BUF+MS.SIZ(R5),R0 ;Get our byte count
	MOV	(R3),R1		;Get user's buffersize			;018
.ASSUME	XRLEN EQ 0							;018
	MOV	R5,R3		;Save CCB pointer			;018
	MOV	R2,R5		;Set up user buffer pointer		;018
	CLR	R2		; and indicate move to user buffer	;018
	CALLX	BLKMOV		;Go move the data			;018
	MOV	JOBWRK,R2	;Get user's work block pointer		;018
	MOV	R0,XRBC(R2)	; and post actual count read		;018
	MOV	CC.BUF+BF.ADR(R3),R4 ;get address of buffer to return	;020
	BUFFER	RETURN		;and set them free....			;020
	MOV	R3,R4		;PUT CCB ADDRESS HERE FOR DEALLOCATION	;018
	BUFFER 	RETSML		;RETURN THE CCB BUFFER
50$:	JMPX	IOEXIT		;FINISHED I/O

60$:	MOV	#<XMERRC-XMTCNT>+2+<11*2>,XRBC(R3) ;SET LEN OF STATUS DATA
	CMP	(R3)+,(R3)	;IS HIS BUFFER BIG ENOUGH?
	BLO	130$		;NOPE, BAD COUNT
	SPLC	5		;;LOCKOUT DMC-11 INTERRUPTS
	ADD	#XMTCNT-XMRCPQ,R0 ;;POINT TO COUNTERS IN DDB
	MOV	#<XMERRC-XMTCNT>/2,R2 ;; AND COUNT
.ASSUME	XMERRC EQ XMNRCV+1	;;VERIFY END OF COUNTERS SYMBOL
80$:	MOV	(R0)+,(R5)+	;;GIVE HIM A WORD
	SOB	R2,80$		;;MOVE IT ALL
	MOV	XMRCPQ-XMERRC(R0),R2 ;;POINT TO FIRST MESSAGE CCB
	BEQ	70$		;;IF NONE, RETURN LENGTH OF ZERO
	MOV	CC.BUF+MS.SIZ(R2),R2 ;;GET SIZE OF FIRST MESSAGE ON QUEUE
70$:	MOV	R2,(R5)+	;;STORE LENGTH
	MOVB	XMERR(R1),(R5)+ ;;PASS ERROR CODE AND
	MOVB	DDFLAG+1(R1),(R5)+ ;; DRIVER FLAGS TO USER
	ADD	#XMBSIZ,R1	;;ADVANCE DDB POINTER TO DATA
	MOV	#^B1110111100000000,R2 ;;SET POSTING MASK (1ST WORD ALWAYS!) ;028
90$:	MOV	(R1),(R5)+	;;COPY A WORD
100$:	TST	(R1)+		;;ADVANCE DDB POINTER
	ASL	R2		;;SHIFT POSTING PATTERN
	BCS	90$		;;C=1 MEANS POST A WORD
	BNE	100$		;;SKIP HERE, BUT LOOP IF MORE TO POST
	SPLC	3		;;BACK TO INTERRUPTABLE AGAIN
	BR	50$		;DONE

110$:	TST	DDFLAG(R1)	;IS DEVICE HUNG ?
	BPL	120$		;YES - RETURN HUNG DEVICE ERROR
	CALL	XMWAIT,R5,XM.WAT ;STALL TO WAIT FOR BUFFER IF REQUESTED
	ERROR	NOSUCH		;NO STALL, ERROR IMMEDIATELY

120$:	ERROR	HNGDEV		;DMC ISN'T RUNNING

130$:	ERROR	BADCNT		;WRITE REQUEST IS TOO BIG

.DSABL	LSB



; CHECK DDB LAYOUTS FOR STATUS MESSAGE CODE ABOVE

.DSECT	XMTCNT
XMTCNT:	.BLKB			;NUMBER OF TRANSMIT BUFFERS GIVEN TO DMC
XMNXMT:	.BLKB			;TOTAL NUMBER OF BUFFERS PENDING ON XMIT SIDE
XMNRCP:	.BLKB			;NUMBER OF BUFFERS ON USER RCV COMPLETE QUEUE
	.BLKB			;RESERVED
XMRCNT:	.BLKB			;NUMBER OF RECEIVE BUFFERS GIVEN TO DMC
XMNRCV:	.BLKB			;TOTAL NUMBER OF BUFFERS ASSIGNED TO RECEIVE

; BITS SET IN THE POSTING MASK ABOVE CORRESPOND TO WORDS TO BE TRANSFERRED,
; EXCEPT FOR THE FIRST WORD WHICH IS AUTOMATICALLY TRANSFERRED.

.DSECT	XMBSIZ
XMBSIZ:	.BLKW			;RECEIVE BUFFER SIZE FOR THIS LINE
XMMODE:	.BLKW			;OPERATIONAL MODE
XMCTBL:	.BLKW			;CORE TABLE ADDRESS (ABSOLUTE OR CONTORTED)
XMBQTA:	.BLKB			;QUOTA OF RECEIVE BUFFERS REQUIRED
XMTIMR:	.BLKB			;NUMBER OF SECONDS FOR TRANS TIME OUTS
	.BLKW			;SECOND WORD OF FLAGS
XMCTLO:	.BLKW			;SEL6 VALUE FROM CONTROL OUT
XMECTR:	.BLKW	3		;COUNTERS FOR NON-FATAL DMC ERRORS

UNORG

.SBTTL	PUT USER INTO I/O REDO IF NEEDED

;+
;	R1 -> DDB
;	R3 -> XRB
;
;	CALL	XMWAIT,R5,<WAIT BITS>
;
;	R0 =  RANDOM
;	R3 -> XRB @ XRMOD
;
;	RETURN IS DIRECTLY TO 'IOREDO' IF NECESSARY
;-

XMWAIT:	MOV	(R5)+,R0	;GET THE WAIT BITS
	ADD	#XRMOD,R3	;POINT TO MODIFIER WORD
	BIT	#060000,(R3)	;WAIT FOR CONDITION OR FOR TIMER?
	BEQ	20$		;NO, RETURN IMMEDIATELY
	BIS	R0,DDFLAG(R1)	;YES, SET REASON FOR WAIT
	BIT	#020000,(R3)	;UNCONDITIONAL WAIT FOR CONDITION OR ERROR?
	BNE	10$		;YES, JUST GO TO IOREDO
	CLRB	1(R3)		;Clear out the high byte of the timer
	;BIC	#070000,(R3)	;NEXT TIME THROUGH, RETURN IMMEDIATELY
	MOV	(R3),R2		;Now pick up the wait time		;023
	MOVB	DDJBNO(R1),R0	;GET OWNING JOB NUMBER * 2		;023
	BIS	#JSTIM!JS.KB,JBWAIT(R0) ;ADD WAIT CONDITIONS TO JS.XM	;023
	CALLX	MAPJCR		;Map JCR entry				;023
	MOV	R2,JCCLOK(R1)	;Set up the wait time			;023
10$:	MOV	#IOREDO,R5	;REROUTE TO IOREDO
20$:	RETURN	R5

GLOBAL	<JBWAIT,IOREDO>							;023

.SBTTL	XMHALT - DMC DISABLE

;+
; XMHALT - CLEAR DMC11, RELEASE ALL QUEUED DATA, DEALLOCATE BASE TABLE
;
;	R1 -> DDB
;	R3 -> CSR
;
;	CALL	XMHALT
;
;	R0 =  RANDOM
;	R2 =  RANDOM
;	R4 =  RANDOM
;	R5 =  RANDOM
;
;	C=0 (CANNOT FAIL)
;-

.ENABL	LSB

XMHALT:	CALL	XMCDTR		;DROP DTR ON THE DMC11
	CALL	FLUSHQ		;DUMP ALL BUFFERS, BASE TABLE, FIX DDFLAG
	BIC	#XM.OPN,DDFLAG(R1) ;MARK UNIT CLOSED
	CLC			;INDICATE SUCCESS
	RETURN			;AND EXIT
 
.DSABL	LSB

.SBTTL	XMCDTR - DMC TURN DTR OFF 

;+
; XMCDTR - PUT DMC11 INTO LOOP CLEARING DTR EVERY 300 NSEC
;
;	R1 -> DDB
;	R3 -> CSR
;
;	CALL	XMCDTR
;
;	RETURN	(WITH ALL REGISTERS PRESERVED)
;	DMC MASTER RESET AND IN LOOP CLEARING DTR UNLESS ERROR
;	WAS START RECEIVED AND THE XM.HOS BIT WAS 0.
;	THIS LETS THE DMC HANGUP THE PHONE ON CLOSE.
;-

.ENABL	LSB

XMCDTR:	MOV	#MCLR,(R3)	;MASTER CLEAR THE DMC11
	BIT	#XMSTRT,XMCTLO(R1) ;WAS THIS STOP CAUSED BY A RECEIVED START
	BEQ	10$		;NO THEN HANG-UP THE PHONE
	BIT	#XM.HOS,XMMODE(R1) ;OPEN MODE OF HANGUP ON START RECV?
	BEQ	20$		;NO THEN JUST MASTER CLEAR DONT DROP DTR
10$:	MOV	#DRPDTR,SEL6(R3) ;PUT INSTRUCTION FOR DMC TO EXECUTE IN SEL6
	MOVB	#DMCRUN,BSEL1(R3) ;TELL DMC11 TO LOOP ON INSTRUCTION IN SEL6
20$:	RETURN			;AND EXIT

.DSABL	LSB

.SBTTL	XMINIT - DMC INITIALIZATION ROUTINE

;+
; XMINIT - INITIALIZE THE DMC11
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB
;	R3 -> CSR
;	R4 -> FIRQB
;		FIRQB @ FQMODE = HALF-DUPLEX AND OTHER MODE FLAGS 
;		FIRQB @ FQSIZ  = RECEIVE BUFFER SIZE
;		FIRQB @ FQCLUS = RECEIVE BUFFER QUOTA (BYTE)
;	   =  0 TO USE PREVIOUS PARAMETERS
;
;	CALL	 XMINIT
;
;	R0,R1,R2,R4,R5 =  RANDOM
;
;	C=0 IF SUCCESS
;	C=1 IF FAILURE, REASON CODE IN R0
;
; NOTE:	XMINIT ALWAYS RETURNS SYNCHRONOUSLY
;-

.ENABL	LSB

XMOPCL:	BCS	XMHALT		;SORT USER OPEN FROM USER CLOSE
XMINIT:	MOV	R0,-(SP)	;SAVE UNIT NUMBER FOR LATER.
	MOV	R1,R5		;COPY THE DDB POINTER
	SETERR	INUSE,R0	;PRESET AN ERROR (TRN ONLY)
	BIT	#XM.OPN,DDFLAG(R5) ;DEVICE ALREADY OPEN?
	BNE	70$		;YES, RETURN ERROR
	MOV	(SP),R0		;GET A COPY OF UNIT NUMBER
	CLR	TIM.XM(R0)	;MAKE SURE TIMEOUTS ARE OFF
	BIC	#XM.ERR!XM.WAT!XM.FLS!XM.FXC!XM.SUP,DDFLAG(R1)		;028
				;CLEAN UP DDB FLAGS
	SETERR	BADCNT,R0	;ASSUME PARAMETERS ARE BAD
	TST	R4		;FIRQB GIVEN FOR NEW PARAMETERS?
	BEQ	10$		;NO, USE OLD PARAMETERS
	MOV	FQMODE(R4),XMMODE(R5) ;SET MODE INTO DDB
	MOV	FQSIZ(R4),XMBSIZ(R5) ;SET THE RECEIVE BUFFER SIZE
	MOVB	FQCLUS(R4),XMBQTA(R5) ;SET THE QUOTA
10$:	MOV	XMBSIZ(R5),R2	;GET BUFFER SIZE TO USE
	BLE	60$		;ZERO OR NEGATIVE IS INVALID
	CMP	R2,#RBUFMX	;BIGGER THAN WE CAN HANDLE ?
	BHI	60$		;YES, ALSO RETURN AN ERROR
20$:	ADD	#XMFLG2,R1	;POINT TO START OF SECTION TO CLEAR
	MOV	#<XMLCTR-XMFLG2>/2,R2 ;NUMBER OF WORDS TO CLEAR
30$:	CLR	(R1)+		;CLEAR A WORD
	SOB	R2,30$		;CTLO,FLG2, AND COUNTERS
	MOV	#XM.BTL,R2	;# BASETABLE COUNTERS TO NEGATE
35$:	NEGB	(R1)+		;BECAUSE NEW = CURRENT-OLD
	SOB	R2,35$		; BUT WE WANT NEW = CURRENT + OLD (AKA --OLD)
.ASSUME	XM.BTL&1 EQ 0		;BETTER BE EVEN!
.ASSUME	XMTIPQ EQ XMLCTR+XM.BTL	;ERROR IF NOT ALIGNED
	MOV	#<XMQEND-XMTIPQ>/4,R2 ;SET LOOP COUNT TO NUMBER OF QUEUES
40$:	MOV	R1,R4		;COPY THE POINTER
	CLR	(R1)+		;CLEAR POINTER TO FIRST ELEMENT
	MOV	R4,(R1)+	;INITIALIZE POINTER TO LAST ELEMENT
	SOB	R2,40$		;NEXT...
	CLR	(R1)+		;NOW CLEAR THOSE BUFFER COUNTS
	CLR	(R1)+		; SOME MORE...
	CLR	(R1)+		;  AND THE LAST ONE
	MOV	#-1,R2		;Don't use MONPOL for this		;022
	MOV	#BTBSZ+BUFHDR,R1 ;GET SIZE OF CORE TABLE (INCLUDING OVERHEAD)
	CALLX	BUFFER,R5,EXTPOL ;ALLOCATE A BUFFER FOR CORE TABLE
	BCS	60$		;QUIT IF NO BUFFER AVAILABLE
	MOV	R4,XMCTBL(R5)	;STORE CONTORTED BASETABLE BUFFER ADDRESS
	MOV	R3,R0		;SAVE CSR POINTER FOR MAPBUF CALL
	CALLX	MAPBUF		;NOW MAP IT SO IT CAN BE ZEROED (R3 -> BUFFER)
	ADD	#BUFHDR,R3	;SKIP PAST BUFFER HEADER
	MOV	#BTBSZ/2,R2	;ZERO OUT THE ENTIRE BASETABLE
50$:	CLR	(R3)+		; SO THAT DMC ERROR COUNTERS
	SOB	R2,50$		;  ARE CORRECT AT BASETABLE ASSIGN TIME
	MOV	R0,R3		;RESTORE DEVICE CSR POINTER
	BIS	#MCLR,(R3)	;MASTER CLEAR THE DMC11 AND TURN DTR ON.
	MOV	#DSPDSR,SEL6(R3)	;SET INSTRUCTION TO MOVE DSR TO BSEL3
	MOVB	#DMCRUN,BSEL1(R3)	;HAVE DMC EXECUTE SEL6 EVERY 300 NSEC
	BIS	#DDSTAT!XM.SUP!XM.OPN,DDFLAG(R5) ;SET THE DMC IN STARTUP MODE
	MOV	(SP)+,R0		;GET BACK UNIT NUMBER TO SET TIMER.
	INC	TIM.XM(R0)	;SET ONE SECOND TIMER TO CHECK DSR.
	CLC			;INDICATE SUCCESSFUL SO FAR.
	RETURN			;EXIT TO FIP OR TRN

;
; REPORT OPEN/BUFFER ERRORS FOR DMC TO USER
;

60$:	MOV	R5,R1		;RESTORE DDB ADDRESS
	MOV	R0,-(SP)	;SAVE THE ERROR CODE
	CALL	XMHALT		;DEALLOCATE CORE TABLE ON ERRORS
	MOV	(SP)+,R0	;RESTORE THE ERROR CODE
70$:	COM	(SP)+		;CLEAN STACK OF SAVED DEVICE NUMBER, SET C
	RETURN			;AND RETURN

GLOBAL	<TIM.XM>

.DSABL	LSB


; CHECK DDB LAYOUT ASSUMPTIONS FOR DDB SETUP CODE ABOVE

.DSECT	XMFLG2

; THE FIRST PART IS ZEROED
XMFLG2:	.BLKW			;SECOND WORD OF FLAGS
XMCTLO:	.BLKW			;SEL6 VALUE FROM CONTROL OUT
XMECTR:	.BLKW	3		;COUNTERS FOR NON-FATAL DMC ERRORS
XMLCTR:	.BLKB	6		;DMC LINE COUNTERS FROM BASE TABLE

; THESE ARE QUEUE HEADS WHICH ARE SET TO "EMPTY"
XMTIPQ:	.BLKW	2		;XMIT IN PROGRESS QUEUE - GIVEN TO DMC
XMRIPQ:	.BLKW	2		;REC  IN PROGRESS QUEUE - GIVEN TO DMC
XMTQUE:	.BLKW	2		;TRANSMIT PENDING QUEUE - NOT YET GIVEN TO DMC
XMRQUE:	.BLKW	2		;RECEIVE PENDING QUEUE  - NOT YET GIVEN TO DMC
XMRCPQ:	.BLKW	2		;REC  COMPLETE QUEUE    - NON DECNET USE
XMCPLQ:	.BLKW	2		;COMPLETION QUEUE
XMQEND:				;END OF QUEUES

; FINALLY, THE DMC-11 DYNAMIC BUFFER COUNTS
XMTCNT:	.BLKB			;NUMBER OF TRANSMIT BUFFERS GIVEN TO DMC
XMNXMT:	.BLKB			;TOTAL NUMBER OF BUFFERS PENDING ON XMIT SIDE
XMNRCP:	.BLKB			;NUMBER OF BUFFERS ON USER RCV COMPLETE QUEUE
XMERR:	.BLKB			;DMC-11 "LAST ERROR RECEIVED" CODE
XMRCNT:	.BLKB			;NUMBER OF RECEIVE BUFFERS GIVEN TO DMC
XMNRCV:	.BLKB			;TOTAL NUMBER OF BUFFERS ASSIGNED TO RECEIVE

UNORG

.SBTTL	XMASBT - ASSIGN THE DMC A BASE TABLE 

;+
; XMASBT - ASSIGN A BASE TABLE AFTER DSR IS ON FOR 2 SECONDS:
;		CALLED BY XM LEVEL 3 QUE SERVICE ROUTINE.
;
;	R3 -> CSR
;	R5 -> DDB
;
;	CALL	XMASBT
;
;-

.ENABL	LSB

XMASBT:	MOV	#MCLR,(R3)	;MASTER CLEAR THE DMC11 AND LEAVE DTR ON.
	MOV	XMCTBL(R5),R4	;GET BASE TABLE (MMU) ADDRESS INTO DDB
	CALL	30$,R2,<RDYI*400!RQI!BASEI> ;REQUEST DMC PORT FOR BASE I
	MOV	R4,R1		;COPY (CONTORTED) BUFFER ADDRESS
	CALL	UNIMAP		;CONVERT IT TO 18-BIT DMC FORMAT
	ADD	#BUFHDR,R1	;ACCOUNT FOR BUFFER HEADER
	BCC	10$		;IN MULTIPRECISION ARITHMETIC
	ADD	#40000,R0	;DO THIS THE HARD WAY
10$:	MOV	R1,SEL4(R3)	;STORE LOW-ORDER 16 BITS
	MOV	R0,SEL6(R3)	; AND HIGH-ORDER 2 BITS
	CALL	70$		;RELEASE PORT, WAIT FOR RDYI TO CLEAR
	CALL	30$,R2,<RDYI*400!RQI!CNTLI> ;REQUEST DMC PORT FOR CONTROL IN
	MOV	XMMODE(R5),R0	;GET OPERATIONAL MODE
	BIT	R0,#XM.LUL	;DOES HE WANT LINE UNIT LOOPBACK?
	BEQ	20$		;NO
	BIS	#LUL,(R3)	;YES, GIVE IT TO HIM
20$:	BIC	#^C<XM.HDX!XM.SEL!XM.MNT>,R0 ;TRIM TO MODE BITS
..XMMD	==	.-2	;**PATCH** COMPLEMENT OF MODE BITS FOR DMC-11 OPEN
	MOV	R0,SEL6(R3)	;SET THE OPERATIONAL MODE
	CALL	70$		;RELEASE PORT, WAIT FOR RDYI TO CLEAR
	BIS	#IEO,SEL2(R3)	;ENABLE OUTPUT INTERRUPT
	BIC	#XM.SUP,DDFLAG(R5) ;CLEAR STARTUP FLAG.
	L3QSET	QXMDNE		;SCHEDULE L3 SERVICE TO ASSIGN RCV BUFFERS
	CLC			;INDICATE SUCCESSFUL INITIALIZATION
	RETURN			;EXIT

; REQUEST DMC PORT FOR INPUT FUNCTION

30$:	MOVB	(R2)+,(R3)	;SET UP FUNCTION CODE IN DMC
	MOVB	(R2)+,R0	;GET RDYI BIT SO THAT WE WAIT FOR IT TO GO ON
	MOV	R2,(SP)		;SAVE RETURN ADDRESS
40$:	MOV	#LOOPCT,R2	;GET SPIN COUNTER
50$:	CALL	FLAP		;FLAP AROUND A WHILE
	MOV	R0,-(SP)	;SAVE STATE OF RDYI THAT WE WANT
	ADD	(R3),(SP)	;ADD IN CURRENT STATE
	TSTB	(SP)+		;IS RDYI IN THE RIGHT STATE?
	BPL	60$		;YES, RETURN
.ASSUME	RDYI EQ 200
	SOB	R2,50$		;NO, WAIT MORE
	TST	(SP)+		;TIME'S UP, ASSUME IT'S HUNG. DUMP RETURN
	MOV	R5,R1		;PUT DDB POINTER IN R1
	CALL	XMCDTR		;RESET DMC AND DROP DTR
	SEC			;FLAG THE ERROR
60$:	RETURN			;AND RETURN

70$:	BIC	#RQI,(R3)	;RELEASE THE PORT
	CLR	R0		;WAIT FOR RDYI TO GO DOWN
	BR	40$		;ENTER THE LOOP

.DSABL	LSB

.SBTTL	FLUSHQ - RELEASE ALL QUEUED BUFFERS

;+
; FLUSHQ - FLUSH ALL BUFFER QUEUES IN THE DDB QUEUE BLOCK
;
;	R1 -> DDB
;	DMC11 MUST HAVE BEEN MASTER CLEARED
;
;	CALL FLUSHQ
;
;	R4 =  RANDOM
;	R5 =  RANDOM
;
; IF THE LINE BELONGS TO TRANSPORT, ITS TRANSMIT BUFFERS ARE QUEUED
; TO TRANSPORT WITH FUNCTION FC$XER RATHER THAN BEING DISCARDED
;-

.ENABL	LSB

FLUSHQ:	CALL	SAVCTR		;SAVE LINE COUNTERS IF WE CAN
	MOV	R1,R0		;Copy DDB pointer			;028
	ADD	#XMCTBL,R0	;And point to core table address	;028
	MOV	(R0),R4		;And pick it up				;028
	BEQ	50$		;IF EQ NO CORE TABLE ASSIGNED OR ALLOCATED
	BUFFER	RETURN		;DEALLOCATE THE CORE TABLE
	CLR	(R0)		;FLAG AS NOT THERE
50$:	ADD	#XMQEND-XMCTBL,R0 ;POINT PAST LAST QUEUE
	MOV	#<XMQEND-XMTIPQ>/4,-(SP) ;PUSH COUNT OF QUEUES TO FLUSH
60$:	CMP	-(R0),-(R0)	;BACK UP TO NEXT QUEUE
70$:	CALLX	POPQUE		;DEQUEUE THE NEXT MESSAGE
	BCS	90$		;NO MORE, DONE WITH THIS QUEUE
	CMPB	DDJBNO(R1),#TRNJOB ;OWNED BY TRANSPORT?
	BNE	80$		;NO, SO RETURN IT
	BITB	#DF.NSP!DF.TRN,CC.DFL(R5) ;TRANSMIT BUFFER?
	BEQ	80$		;NO, SO RETURN IT
	MAP	CC.BUF+BF.MMU(R5),APR=6,DATA ;YES, SO MAP THE BUFFER
	MOV	CC.BUF+BF.VIR(R5),R4 ;STARTING ADDRESS OF THE BUFFER IN R4
	ADD	BF.OFF(R4),R4	;POINT PAST HEADER + MISC TO START OF DATA
	ADD	R4,CC.BUF+MS.SIZ(R5) ;ADD IN DATA SIZE TO GET END ADDRESS
.ASSUME	BF.END EQ MS.SIZ	;END ADDR OR SIZ OF BUF, BASED ON MOON'S PHASE
	CALL	RBFTRF,R0,FC$XER ;RETURN TO TRN WITH XMIT ERROR FUNCTION
	BR	70$		;AND CONTINUE

80$:	CALLX	RBFCCB		;RETURN THE BUFFER AND THE CCB
	BR	70$		;AND CONTINUE
 
90$:	DEC	(SP)		;DONE?
	BNE	60$		;NO, DO ANOTHER QUEUE
	TST	(SP)+		;CLEAN THE STACK
100$:	BIC	#DDSTAT,DDFLAG(R1) ;DEVICE NOT RUNNING
	CLRB	XMERR(R1)	;AND NO ERROR
	RETURN			;DONE

.DSABL	LSB

.SBTTL	DNE$XM - LEVEL 3 SERVICE FOR I/O COMPLETE & BUFFER ASSIGNMENT

;+
; DNE$XM - DMC11 LEVEL 3 SERVICE
;
; 1) FOR EACH DMC11 UNIT:
;    A)	ALL BUFFERS ON THE COMPLETION QUEUE ARE REMOVED AND PROCESSED.
;	FOR RECEIVE COMPLETE, EXCESS BUFFER SPACE IS RETURNED TO THE
;	SYSTEM POOL AND THE MESSAGE IS QUEUED TO DECNET OR TO THE USER.
;	FOR TRANSMIT COMPLETE, THE CCB AND BUFFER ARE DEALLOCATED.
;    B)	IF THE UNIT HAD A HARDWARE ERROR, ALL PENDING BUFFERS ARE REMOVED.
;	IF OWNED BY DECNET, IT IS NOTIFIED.
;
; 2) FOR EACH UNIT, BUFFERS ARE ALLOCATED (IF POSSIBLE AND IF NECESSARY)
;	TO GET IT UP TO ITS RECEIVE BUFFERING QUOTA.
;	THEN ANY BUFFERS PENDING ARE HANDED TO THE DMC11.
;-

	TMPORG	XMDINT,66

	.WORD	DNE$XM

	UNORG

.ENABL	LSB

DNE$XM:	MOV	#CNT.XM,R0	;GET COUNT OF DMC DDB'S TO SCAN
10$:	MOV	R0,-(SP)	;STACK THE CURRENT INDEX
	ASL	R0		;DOUBLE IT FOR WORD OFFSET
	MOV	DEV.XM-2(R0),R1	;GET THIS UNIT'S DDB ADDRESS
	BIT	#XM.OPN,DDFLAG(R1) ;IS THIS UNIT OPEN?
	BEQ	60$		;NO, SKIP IT
	BIT	#XM.SUP,DDFLAG(R1) ;IS DMC IN STARTUP STATE.
	BNE	70$		; YES SEE IF DSR HAS COME TO BE
	MOV	R1,R0		;COPY DDB POINTER
	ADD	#XMCPLQ,R0	;POINT TO COMPLETION QUEUE
	TST	(R0)		;ANY COMPLETIONS FOR THIS UNIT?
	BEQ	30$		;NO (THIS TEST IS FOR SPEED ONLY)
20$:	SPLC	5		;LOCK ACCESS TO COMPLETION QUEUE
	CALLX	POPQUE		;;GET THE FIRST ITEM ON COMPLETION QUEUE
	SPL	3		;;DROP BACK TO PR3
	BCC	80$		;GO PROCESS A COMPLETED BUFFER

; COMPLETION QUEUE NOW EMPTY, SO REPORT ERROR IF NECESSARY

30$:	BIT	#XM.ERR,DDFLAG(R1) ;IS THIS DMC HALTED FOR ERROR?
	BEQ	60$		;NOPE
	CMPB	DDJBNO(R1),#TRNJOB ;YES, DOES TRN OWN IT?
	BNE	50$		;NO, CLEAN UP AFTER ERROR FOR USER
	CALL	FLUSHQ		;ERROR ON TRN'S DMC11, JUNK ALL BUFFERS
	BUFFER	GETSML		;GET AN ERROR CCB
	BVS	40$		;COULDN'T GET IT
	MOV	R4,R5		;PUT BUFFER POINTER IN R5
	MOVB	XMERR(R1),CC.SEC(R5) ;PASS ERROR CODE IN CC.SEC OF CCB.
	CALL	RBFTRF,R0,FC$ERR ;QUEUE THE CCB TO TRN WITH ERROR FUNCTION
	BR	60$		;DONE HERE NOW

40$:	BIS	#XM.ERR,DDFLAG(R1) ;SET FLAG TO COME HERE AGAIN NEXT TIME
	MOV	(SP),R0		;GET UNIT NUMBER BACK
	ASL	R0		;DOUBLE FOR WORD INDEX
	INC	TIM.XM(R0)	;TRY TO GET THAT BUFFER AGAIN IN 1 SECOND
	BR	60$		;AND ONWARDS

50$:	MOV	-(R0),-(SP)	;SAVE RECEIVE COMPLETE QUEUE TAIL
.ASSUME	XMRCPQ+4 EQ XMCPLQ
	MOV	-(R0),-(SP)	;SAVE QUEUE HEAD, TOO
	CLR	(R0)		;FLUSHQ SHOULDN'T RETURN THESE
	CALL	FLUSHQ		;RETURN ALL HANGING BUFFERS
	MOV	(SP)+,XMRCPQ(R1) ;RESTORE THE RECEIVE COMPLETE QUEUE
	MOV	(SP)+,XMRCPQ+2(R1) ; SO THE USER CAN GET THEM LATER
	CALL	XMFINI,R5,<XM.WAT!XM.FLS> ;AWAKEN ANY SLEEPING USER
	.BR	60$		;GO TO COMMON CODE.

; LOOP FOR NEXT DMC11

60$:	MOV	(SP)+,R0	;RESTORE DMC INDEX
	DEC	R0		;ALL DONE 
	BNE	10$		;LOOP IF MORE UNITS
	JMP	160$		;ELSE TRY TO SATISFY BUFFER STALLS AND REQUEST ;028

70$:	BIT	#XM.DSR,XMFLG2(R1) ;WAS DSR SET ON TWO 1 SEC TIME OUTS?
	BEQ	60$		;NO THEN DONE FOR NOW
	MOV	R1,R5		;COPY DDB POINTER FOR BASE TABLE ASSIGN
	MOV	(SP),R3		;GET UNIT TO GET CSR ADDRESS
	ASL	R3		;UNIT # = UNIT # * 2
	MOV	CSR.XM-2(R3),R3 ;GET THIS DMC'S CSR
	CALL	XMASBT		;GIVE THE DMC A BASE TABLE
	BCC	60$		;ALL OK THEN GO TO NEXT DMC
	BIS	#XM.ERR,DDFLAG(R5) ;SET ERROR FLAG
	MOVB	#ER.DMC,XMERR(R5) ;SET THE ERROR CODE FOR HUNG DEVICE
	CLR	XMCTLO(R5)	;SET ERROR AS 0 FOR SPECIAL CASE.
	MOV	R5,R1		;COPY DDB POINTER FOR ERROR SECTION.
	BR	30$		;GO AS IF AN ERROR ON ENTRY

GLOBAL	<CNT.XM,DEV.XM,TIM.XM>

; DISPATCH ON TRANSMIT VS. RECEIVE COMPLETE

80$:	TSTB	CC.FC(R5)	;RECEIVE OR TRANSMIT COMPLETE?
	BNE	110$		;GO IF RECEIVE COMPLETE

; TRANSMIT COMPLETE - POST BUFFER TO RECEIVE COMPLETE QUEUE OR TRN

	ADDL	CC.BUF+MS.SIZ(R5),XMXBYT(R1) ;FIRST, UPDATE XMIT BYTCNT
	COUNTL	XMXMSG(R1)	;NOW UPDATE XMIT MESSAGE (BLOCK) COUNT
	DECB	XMNXMT(R1)	;ONE LESS BUFFER ON TRANSMIT SIDE
	BNE	90$		;SKIP IF STILL MORE
	CALL	XMFINI,R5,XM.FLS ;WAKE UP USER IF WAITING FOR OUTPUT FLUSH
90$:	CMPB	DDJBNO(R1),#TRNJOB ;COMPLETION FOR TRN?
	BEQ	100$		;YES, GIVE BUFFER BACK TO IT
	CALL	RBFCCB		;MERELY RETURN BUFFERS IF TRANSMIT COMPLETE
	BR	20$		;LOOP FOR MORE

100$:	MAP	CC.BUF+BF.MMU(R5),APR=6,DATA ;MAP THE BUFFER
	MOV	CC.BUF+BF.VIR(R5),R2 ;GET ITS VIRTUAL ADDRESS
	ADD	BF.OFF(R2),R2	;POINT TO START OF DATA
.ASSUME	MS.SIZ EQ BF.END
	ADD	R2,CC.BUF+BF.END(R5) ;CONVERT SIZE TO END
	CALL	RBFTRF,R0,FC$XCP ;RETURN WITH XMIT COMPLETE CODE
	JMP	20$		;LOOP FOR MORE

GLOBAL	<RBFCCB>

; RECEIVE COMPLETE - RETURN UNUSED BUFFER SPACE AND QUEUE TO USER OR DECNET

110$:	ADD	#CC.BUF+BF.VIR,R5 ;INDEX TO BUFFER VIRTUAL ADDRESS IN CCB
	MOV	(R5)+,R4	;GET BUFFER VIRTUAL ADDRESS
	MAP	(R5)+,APR=6,DATA ;SET THE MMU TO MAP TO IT
.ASSUME	BF.MMU EQ BF.VIR+2
	MOV	(R4),R3		;GET SIZE OF BUFFER
.ASSUME BF.SIZ EQ 0							;024
	MOV	R3,R2		;COPY THAT FOR LATER
	BIC	#^C<CC>,(R5)	;REMOVE MEB FROM RECV'D MSG SIZE
.ASSUME	MS.SIZ EQ BF.MMU+2
	ADDL	(R5),XMRBYT(R1)	;NOW UPDATE RCV BYTCNT
	COUNTL	XMRMSG(R1)	;UPDATE RCV MESSAGE (BLOCK) COUNT, TOO
	DECB	XMNRCV(R1)	;ONE LESS BUFFER ON RECEIVE SIDE
	MOV	(R5),BF.CNT(R4)	;SIZE OF DATA -> BUFHDR
	CMPB	DDJBNO(R1),#TRNJOB ;DATA DESTINED FOR TRANSPORT?
	BEQ	130$		;YES, DON'T TRUNCATE BUFFERS HERE
	SUB	(R5),R3		;GET SIZE OF EXCESS BUFFER SPACE
	SUB	#BUFHDR,R3	;ACCOUNT FOR BUFFER HEADER WORDS
	BIC	#77,R3		;ROUND DOWN SIZE OF EXCESS TO RETURN
	BEQ	140$		;IF EXCESS < 64 WORDS, DON'T BOTHER
	SUB	R3,R2		;REDUCE SIZE OF ORIGINAL BUFFER
	MOV	R2,(R4)		;AND STORE NEW BUFFER SIZE
.ASSUME	BF.SIZ EQ 0
	ADD	R2,R4		;OFFSET TO START OF BUFR TO BE RETURNED
	MOV	R3,(R4)		;SET SIZE OF BUFFER TO RETURN
	MOV	BF.ADR-MS.SIZ(R5),R4 ;PUT CONTORTED BUFFER ADDRESS HERE
	BIT	R4,#37		;WAS IT AN EXTENDED POOL BUFFER ?
	BEQ	120$		;NO, MONITOR POOL BUFFER
	ASL	R2		;SIZE(= SIZE/100 ROL 6) => SIZE/100 ROL 7
120$:	ADD	R2,R4		;ADD SIZE (TRUE OR CONTORTED) TO BUFFER PTR
	ADC	R4		;CARRY IF CONTORTED FOR SIZE ROTATED LEFT 7
	BUFFER	RETURN		;RETURN THE EXCESS BUFFER SPACE
	BR	140$		;AND CONTINUE

130$:	MOV	BF.OFF(R4),R2	;GET DATA OFFSET INTO BUFFER
	ADD	R4,R2		;NOW DATA ADDRESS
	ADD	R2,(R5)		;CONVERT SIZE TO BUFFER END
.ASSUME	MS.SIZ EQ BF.END
140$:	SUB	#CC.BUF+MS.SIZ,R5 ;FIX THE CCB POINTER
	CMPB	DDJBNO(R1),#TRNJOB ;THIS DMC OWNED BY TRN?
	BEQ	150$		;YES, GO QUEUE CCB TO ITS QUEUE
	MOV	R5,@-(R0)	;QUEUE CCB TO USER'S RECEIVE COMPLETE QUEUE
.ASSUME	XMRCPQ+2 EQ XMCPLQ-2
	MOV	R5,(R0)+	; AS THE LAST BUFFER
	INCB	XMNRCP(R1)	;ONE MORE BUFFER ON RECEIVE COMPLETE QUEUE
	CALL	XMFINI,R5,XM.WAT ;WAKE UP USER IF WAITING FOR BUFFER
	JMP	20$		;BACK FOR MORE

150$:	CALL	RBFTRN,R0	;RETURN THE BUFFER TO TRN
	JMP	20$		;RETURN FOR MORE

; TRY TO BRING ALL UNITS UP TO BUFFER QUOTA

160$:	MOV	#CNT.XM,R0	;GET COUNT OF NUMBER OF DMC'S		;028
190$:	MOV	R0,-(SP)	;STACK CURRENT UNIT INDEX
	ASL	R0		;DOUBLE IT FOR WORD OFFSET
	MOV	DEV.XM-2(R0),R1	;GET THIS UNIT'S DDB ADDRESS
	MOV	DDFLAG(R1),R4	;PUT THE FLAG BITS HERE
	BPL	220$		;SKIP THIS UNIT IF NOT ENABLED
	BIT	#XM.SUP,R4	;IN STARTUP MODE?
	BNE	220$		;YES SKIP THIS UNIT
200$:	CMPB	XMNRCV(R1),XMBQTA(R1) ;THIS DMC NEED A BUFFER ?
	BGE	210$		;NO, INDEX TO NEXT UNIT
	CALL	RCVBUF		;TRY TO GET A RECEIVE BUFFER
	BCC	200$		;GOT ONE, TRY FOR MORE
	L3QSET	QXMDNE,WAIT2T	;Failed, try again in 1-2 ticks		;028
210$:	CALL	ASNBUF		;HAND RECEIVE AND TRANSMIT BUFFERS TO DMC
220$:	MOV	(SP)+,R0	;POP THE CURRENT UNIT INDEX
	SOB	R0,190$		;COUNT 'EM DOWN
	JMPX	RTI3		;IN WHICH CASE JUST EXIT

.DSABL	LSB

GLOBAL	<CNT.XM,DEV.XM>

.SBTTL	RCVBUF - ALLOCATE RECEIVER BUFFER AND CCB

;+
;	R1 -> DDB
;
;	CALL	RCVBUF
;
;	R0 =  RANDOM
;	R2 =  RANDOM
;	R3 =  RANDOM
;	R4 =  RANDOM
;	R5 =  RANDOM
;
;	C=0 IF BUFFER WAS ALLOCATED
;		BUFFER IS PLACED ON 'NOT SENT' QUEUE
;
;	C=1 IF BUFFER NOT AVAILABLE
;-

RCVBUF:	BUFFER	GETSML,,40.	;Get a buffer for a CCB			;028
	BVS	40$		;None, return failure			;028
	MOV	R4,R5		;Save the CCB pointer in a safe place	;028
	MOV	R1,R0		;COPY THE DDB POINTER
	MOV	XMBSIZ(R0),R1	;GET RECEIVE BUFFER SIZE TO ALLOCATE
	ADD	#BUFHDR,R1	;ADD OVERHEAD FOR BUFFER HEADER WORDS
	MOV	#-1,R2		;Don't use MONPOL for data buffer	;022
	CALLX	BUFFER,R5,EXTPOL ;GRAB THE BUFFER FROM EXTENDED POOL
	BCS	30$		;No space, give an error		;028
	CALLX	MAPBUF		;Got a buffer, go map it
	MOV	R5,R2		;Point to the CCB to set it up		;029
	ADD	#CC.BUF+BF.ADR,R2 ;POINT TO BUFFER PARAMETER AREA OF CCB;029
	MOV	R4,(R2)+	;STORE (POSSIBLY CONTORTED) BUFFER ADDR IN CCB ;029
	MOV	R3,(R2)+	;SAVE POINTER TO BUFFER (POSSIBLY VIA APR6) ;029
	MOV	@DPAR6,(R2)+	;SAVE THE BUFFER'S APR6 VALUE		;029
	MOV	XMBSIZ(R0),(R2)+ ;SET THE RECV BUF SIZE (EXCLUDING HEADER) ;029
	MOV	R0,R1		;RESTORE THE DDB ADDRESS
	CALLR	RENAB		;QUEUE THIS BUFFER TO "NOT SENT" QUEUE

; We got an error trying to allocate XBUF, so return the MONPOL buffer

30$:	MOV	R5,R4		;Get back CCB pointer			;029
	BUFFER	RETSML		;And return it to the pool		;028

; We got an error trying to get the CCB, so give an error to the caller

40$:	MOV	R0,R1		;RESTORE DDB ADDRESS
	SEC			;INDICATE FAILURE
	RETURN

GLOBAL	<EXTPOL>							;028

.SBTTL	SUPBUF	Supply a receive buffer from the routing layer

;+
; This routine is used by DECnet to supply a receive buffer for a
; circuit, since DECnet controls buffer allocation for the circuits
; that it owns.
;
; ENTRY:
;	R0 =	UNIT NUMBER * 2
;	R1 ->	DDB
;	R5 ->	CCB
;-

.ENABL	LSB

SUPBUF:	MOV	XMBSIZ(R1),CC.BUF+MS.SIZ(R5)	; Insure size correct	;026
	CALL	RENAB		;And put this on the receive not given queue ;028
	BR	15$		;And exit trying to queue receive	;028

.SBTTL	RENAB, TENAB - QUEUE BUFFER TO 'NOT SENT' QUEUE OR TO DMC

;+
;	R1 -> DDB
;	R5 -> CCB
;
;	CALL	RENAB OR TENAB
;
;	R0 =  RANDOM
;	R2 =  RANDOM
;	R3 =  RANDOM
;	R4 =  RANDOM
;	R5 =  RANDOM
;	C=0
;
; NOTES:
;	THE BUFFER IS ENTERED INTO THE 'NOT SENT' QUEUE
;
;	If this is a transmit, and startup is complete, we will
;	exit through ASNBUF which will try to give the buffer to the
;	DMC-11. If startup isn't complete, the transmit will
;	remain on the 'not sent' queue and will be de-queued when
;	startup finishes.
;-

RENAB:	MOV	#XMRQUE+2,R2	;GET OFFSET TO "RECV NOT SENT" QUEUE
	BR	20$		;ADD TO QUEUE AND GIVE BUFFER TO DMC

TENTRN:	TST	DDFLAG(R1)	;IS THE DMC RUNNING?
	BMI	10$		;YES, WE CAN TRANSMIT
	MOV	#ER.OFF,CC.SEC(R5) ;SET ERROR CODE AS "DMC IS OFF"
	CALL	RBFTRF,R0,FC$XER ;NO, RETURN BUFFER WITH ERROR CODE
	BR	40$		; AND LEAVE QUIETLY

10$:	MAP	CC.BUF+BF.MMU(R5),APR=6,DATA ;MAP THE BUFFER
	MOV	CC.BUF+BF.VIR(R5),R0 ;GET ITS VIRTUAL ADDRESS
	ADD	BF.OFF(R0),R0	;POINT TO THE DATA
	SUB	R0,CC.BUF+BF.END(R5) ;CONVERT END TO SIZE
.ASSUME	BF.END EQ MS.SIZ
TENAB:	MOV	#XMTQUE+2,R2	;GET DDB OFFSET TO "XMIT NOT SENT" QUEUE
	CALL	20$		;Put the buffer on the queue		;028
15$:	BIT	#XM.SUP,DDFLAG(R1) ;Startup complete?			;028
	BEQ	ASNBUF		;Yes, go give the DMC the buffer	;028
	BR	40$		;No, exit with C = 0 			;028

20$:	MOV	R1,-(SP)	;SAVE DDB ADDRESS
	MOV	CC.BUF+BF.ADR(R5),R1 ;GET BUFFER ADDRESS
	CALL	UNIMAP		;MAP TO AN 18 BIT ADDRESS
	MAP	CC.BUF+BF.MMU(R5),APR=6,DATA ;MAP THE BUFFER
	MOV	CC.BUF+BF.VIR(R5),R4 ;POINT TO IT
	ADD	BF.OFF(R4),R1	;ADJUST POINTER TO START OF DATA
	BCC	30$		;MULTIPRECISION ARITHMETIC
	ADD	#40000,R0	; THE HARD WAY
30$:	BIS	CC.BUF+MS.SIZ(R5),R0 ;ADD SIZE TO HI ORDER ADDRESS
	MOV	R0,CC.XBC(R5)	; AND SAVE THAT IN CCB
	MOV	R1,CC.XBA(R5)	;STORE LOW 16 IN CCB
	MOV	(SP)+,R1	;RESTORE THE DDB ADDRESS
	ADD	R1,R2		;MAKE A REAL QUEUE ADDRESS
	CLR	(R5)		;CLEAR THE CCB LINK WORD
	SPLC	5		;LOCK ACCESS TO THIS QUEUE
	MOV	R5,@(R2)+	;;QUE THE CCB TO APPROPRIATE
	MOV	R5,-(R2)	;; "NOT SENT" QUEUE
	SPLC	3		;;DROP BACK TO LEVEL 3
	INCB	XMNXMT-<XMTQUE+2>(R2) ;COUNT ONE MORE BUFFER ON THIS SIDE
.ASSUME	XMNXMT-<XMTQUE+2> EQ XMNRCV-<XMRQUE+2>				;024
	;CLC			;Indicate success (from SPLC above)	;028
	RETURN			;Now exit				;028


.SBTTL	ASNBUF - ASSIGN RECEIVE AND TRANSMIT BUFFERS TO THE DMC
;+
;	R1 -> DDB
;
;	CALL	ASNBUF
;
;	R0 =  RANDOM
;	R2 =  RANDOM
;	R3 =  RANDOM
;	R5 =  RANDOM
;	C=0
;
;	BUFFERS ARE MOVED FROM THE 'RECEIVE NOT SENT' QUEUE TO THE DMC11
;		UNTIL DONE, DMC HAS 7, OR PORT IS UNAVAILABLE
;	IF THE PORT IS STILL FREE, BUFFERS ARE MOVED FROM THE 'TRANSMIT
;		NOT SENT' QUEUE UNDER THE SAME CONDITIONS
;	IF THE PORT IS NOT AVAILABLE, AN INTERRUPT IS REQUESTED
;-

ASNBUF:	MOVB	DDUNT(R1),R3	;GET THE DMC UNIT NUMBER
	ASL	R3		;MAKE IT A WORD INDEX
	MOV	CSR.XM(R3),R3	;GET THIS DMC'S CSR ADDRESS
	CALL	60$,R5,<XMRQUE,RQI!ITR>	;ASSIGN AS MANY RECV BUFS AS POSSIBLE
	BCS	40$		;EXIT ON PORT LOCK OUT
	CALL	60$,R5,<XMTQUE,RQI> ;ASSIGN TRANSMIT BUFFERS
40$:	CLC			;ENSURE C=0
50$:	RETURN

60$:	MOV	(R5)+,R0	;GET OFFSET TO QUEUE
	ADD	R1,R0		;MAKE A REAL DDB ADDRESS
	MOV	(R5)+,R2	;GET REQUEST COMMAND FOR DMC
	MOV	R5,(SP)		;SAVE RETURN ADDRESS, CLOBBER (SP)
70$:	SPLC	3		;;RETURN TO PR3 TO TAKE INTERRUPTS
	SPLC	5		;AVOID INTERRUPTS NOW
	TST	(R0)		;;ANYTHING REMAINING ON THIS QUEUE ?
	BEQ	80$		;;NOPE, EXIT WITH C=0 (FROM 'TST')
	CMPB	XMTCNT-XMTQUE(R0),#7 ;;7 BUFFERS ALREADY ASSIGNED ?
	BHIS	80$		;;YES, SO EXIT WITH C=0 ('BHIS'='BCC')
	;SEC			;;C=1 FROM 'BHIS'='BCC'
	MOV	DDFLAG(R1),R5	;;IS THE DMC STILL RUNNING?
	BPL	80$		;;NO, RETURN WITH C=1 FOR FAILURE
	CALL	SETDMC		;;SET UP DMC & ASSIGN BUF IF POSSIBLE
	BCC	70$		;;LOOP IF BUFFER WAS ASSIGNED
80$:	SPL	3		;;DOWN TO PROPER PRIORITY, PRESERVING CARRY
	RETURN			;EXIT

.DSABL	LSB

.SBTTL	STATUS	INQUIRE ABOUT LINE/CIRCUIT STATE

;+
; ENTRY:
;	R1 ->	DDB
;
; EXIT:
;	C  = 0		CIRCUIT ON
;	R0 = 0
;
;	C  = 1		CIRCUIT OFF
;	R0 = NOTMNT	LINE IS OFF (I.E. NO CIRCUIT)
;-

STATUS:	CLR	R0		;ASSUME LINE IS ON AND RUNNING
	TST	XMCTBL(R1)	;WAS IT? (C = 0)
	BNE	10$		;YES
	SETERR	NOTMNT,R0	;ELSE SAY LINE OFF
	SEC			;FLAG RETURN STATUS AS SUCH
10$:	RETURN			;RETURN WITH STATUS


.SBTTL	SETDMC - GET DMC11 INPUT PORT AND SEND A BUFFER OR REQUEST INTERRUPT

;+
;	R0 -> 'NOT SENT' QUEUE
;	R1 -> DDB
;	R2 =  DMC ASSIGNMENT TYPE
;		RQI!ITR IF RECEIVE BUFFER ASSIGNMENT
;		RQI! 0  IF TRANSMIT BUFFER ASSIGNMENT
;	R3 -> CSR
;
;	CALL	SETDMC
;
;	R5 =  RANDOM
;
;	C=0 IF PORT WAS OBTAINED AND BUFFER ASSIGNED
;	C=1 IF PORT NOT AVAILABLE; INPUT INTERRUPT IS SET
;-

SETDMC:	BIT	#RDYI!RQI,(R3)	;;BUFFER ASSIGNMENT INTERRUPT PENDING ?
	BNE	40$		;;YES, JUST EXIT
	MOVB	R2,(R3)		;;REQUEST PORT FOR BUFFER ASSIGNMENT
	MOV	#RDIDLA,R5	;;SET A SMALL DELAY FOR RDYI TO COME UP
10$:	TSTB	SEL2(R3)	;;DMC TRYING TO DO OUTPUT INTERRUPT ?
	BMI	20$		;;YES, ENABLE INPUT INTERRUPT AND EXIT
	CALL	FLAP		;;WAIT A WHILE, CHECK RDYI
	BMI	SETBUF		;;IF ON, DO BUFFER ASSIGNMENT IN SETBUF
	SOB	R5,10$		;;LOOP IF DELAY NOT EXPIRED
20$:	CLR	R5		;;SET VERRRRRY LONG SPIN
30$:	BISB	#IEI,(R3)	;;ENABLE THE INPUT INTERRUPT		;025
	BISB	#IEI,(R3)	;;Make sure this REALLY happens		;025
	CALL	FLAP		;;WAIT A WHILE
	BIT	#IEI,(R3)	;;DID IT GO ON?
	BNE	40$		;;YES, EXIT C=1
	SOB	R5,30$		;;NO, SPIN A WHILE
40$:	SEC			;;NOTE FAILURE TO ASSIGN BUFFER
	RETURN			;;AND EXIT

.SBTTL	XMI$CI - DMC11 INPUT INTERRUPT SERVICE
 
;+
; XMI$CI - DMC11 INPUT INTERRUPTS
;
;	R0 =  UNIT NUMBER TIMES 2
;	PRIORITY IS INTERRUPT PRIORITY
;
;	...
;
;	RETURN
;
; NOTES:
;	THE CODE IN SEL0 SPECIFIES RECEIVE BUFFER ASSIGNMENT OR
;	TRANSMIT BUFFER ASSIGNMENT.  OTHER CODES ARE ILLEGAL.
;-	

XMI$CI:	MOV	DEV.XM(R0),R1	;;GET DDB ADDRESS INTO R1
	MOV	CSR.XM(R0),R3	;;GET CSR ADDSESS INTO R3
	BIC	#IEI,(R3)	;;CLEAR INPUT INTERRUPT ENABLE
	MOV	R1,R0		;;COPY DDB ADDRESS
	ADD	#XMTQUE,R0	;;ASSUME TRANSMIT BUFFER ASSIGNMENT
	MOV	(R3),R5		;;GET DMC SEL0 REGISTER
	BIC	#^C<ITR!IFC>,R5	;;ISOLATE FUNCTION AND XMIT/RECV FLAG
	BEQ	10$		;;CODE 0, TRANSMIT BUFFER ASSIGNMENT
	MOV	#ER.III,R2	;;PRESET ILLEGAL INPUT INTERRUPT ERROR
	CMP	R5,#ITR		;;IS IT CODE 0, RECEIVER BUFFER ASSIGNMENT?
	BNE	FTLERR		;;ANY OTHER FUNCTION CODE IS AN ERROR
	CMP	(R0)+,(R0)+	;;ADVANCE TO QUEUE OF "RECEIVE NOT SENT"
.ASSUME	XMRQUE-4 EQ XMTQUE
10$:	L3QSET	QXMDNE		;;RESCHEDULE US IN CASE OTHER BUFFERS PENDING
	.BR	SETBUF		;;GO ASSIGN A BUFFER TO THE DMC

GLOBAL	<DEV.XM,CSR.XM>

.SBTTL	ASSIGN A BUFFER TO THE DMC FOR RECEIVE OR TRANSMIT

;+
;	R0 -> "NOT GIVEN TO DMC" QUEUE IN DDB (XMRQUE OR XMTQUE)
;	R1 -> DDB
;	R3 -> CSR
;
;	CALL	SETBUF
;
;	R5 =  RANDOM
;	C=0
;-

SETBUF:	CALLX	POPQUE		;;DEQUEUE NEXT BUFFER TO GIVE TO DMC
	BCS	40$		;;FATAL ERROR IF NOTHING ON QUEUE
	MOV	R0,-(SP)	;;SAVE POINTER TO QUEUE
	CMP	-(R0),-(R0)	;;BACK UP TO 'GIVEN TO DMC' QUEUE
	MOV	R5,@-(R0)	;;ENQUEUE THE BUFFER
	MOV	R5,(R0)		;;MAKE IT THE NEW LAST BUFFER
	CMP	R5,-(R0)	;;IS IT ALSO THE FIRST BUFFER?
	BNE	10$		;;NOPE, NO TIMER WORK
	SUB	R1,R0		;;FIND OUT WHICH QUEUE THIS IS
	CMP	R0,#XMTIPQ	;;TRANSMIT QUEUE?
	BNE	10$		;;NO, SO NO TIMEOUT SERVICE
	CALL	SETTMO		;;YES, SET A TIMER ON FIRST TRANSMIT BUFFER
10$:	MOV	(SP)+,R0	;;RESTORE QUEUE POINTER
	INCB	XMTCNT-XMTQUE(R0) ;;BUMP COUNT OF ASSIGNED BUFFERS
	MOV	CC.XBA(R5),SEL4(R3) ;;LOAD LOW 16 BITS OF ADR INTO SEL4
	MOV	CC.XBC(R5),SEL6(R3) ;;LOAD HI ADDR & COUNT INTO SEL6
	BIC	#RQI,(R3)	;;CLEAR RQI
	MOV	#RDIDLA,R5	;;SET SPIN COUNT
20$:	CALL	FLAP		;;DO A LONG NOP, TEST STATE OF RDYI, CLEAR C
	BPL	30$		;;IF DOWN, EXIT NOW
	SOB	R5,20$		;;ELSE SPIN (IF BUSTED, EXIT SPIN LOOP!)
30$:	;CLC			;;INDICATE SUCCESS (C=0 FROM FLAP)
	RETURN			;;RETURN

; UNSOLICITED INTERRUPT (IMPOSSIBLE IN SYNCHRONOUS CASE)

40$:	MOVB	#ER.UII,R2	;;UNSOLICITED INPUT INTERRUPT
	BR	FTLERR		;;MAKE IT A FATAL ERROR


.SBTTL	XMI$CO - DMC11 CONTROL OUT INTERRUPT PROCESSING
 
;+
; XMI$CO - DMC11 CONTROL OUT INTERRUPT
;
;	R0 =  UNIT NUMBER TIMES 2
;	PRIORITY IS INTERRUPT PRIORITY
;
;	...
;
;	RETURN
;
; NOTE:	TRANSMIT OR RECEIVE COMPLETE QUEUED TO COMPLETION QUEUE,
;	OR ERROR REPORTED
;-

XMI$CO:	MOV	CSR.XM(R0),R3	;;POINT TO DMC11 CSR
	MOV	SEL2(R3),R5	;;GET THE FUNCTION CODE
	CLR	R4		;;CLEAR FOR NO SIZE INFO ON XMIT COMPLETE
	CLR	R2		;;GUESS AT 'TRANSMIT COMPLETE' FUNCTION
	MOV	DEV.XM(R0),R1	;;GET DDB ADDRESS FOR THIS UNIT
	MOV	R1,R0		;;COPY DDB POINTER
	ADD	#XMTIPQ,R0	;;POINT TO TRANSMIT QUEUE
	BIC	#^C<OTR!OFC>,R5	;;ISOLATE FUNCTION AND XMIT/RECV BIT
	BEQ	10$		;;FUNCTION 0 TRANSMIT COMPLETE, GO DO IT
	MOV	#ER.IOI,R2	;;PRESET ERROR CODE IN CASE ILLEGAL INTERRUPT
	BIT	R5,#2		;;FUNCTION CODE 2 OR 3?
	BNE	FTLERR		;;YUP, RESERVED CODES ARE ILLEGAL
	MOV	SEL6(R3),R4	;;GET SIZE (IF RECV CPL) OR STATUS (IF CTLO)
	ASR	R5		;;FUNCTION CODE 0 OR 1?
	BCS	50$		;;CODE 1 IS CONTROL OUT
	MOV	#FC$RCP,R2	;;CODE 0 IS RECEIVE COMPLETE. SET FN CODE
	CMP	(R0)+,(R0)+	;;ADVANCE TO 'RECEIVE IN PROGRESS' QUEUE
.ASSUME	XMRIPQ-4 EQ XMTIPQ
10$:	CALLX	POPQUE		;;DEQUEUE NEXT XMIT BUFFER
	BCS	40$		;;FATAL ERROR IF NOTHING ON QUEUE
	DECB	XMTCNT-XMTIPQ(R0) ;;DEC NO. OF BUFFERS SENT TO DMC
	MOVB	R2,CC.FC(R5)	;;STORE RECV OR XMIT COMPLETE CODE
	TST	R4		;;TRANSMIT?
	BEQ	20$		;;YES, DON'T MUCK UP THE SIZE
	MOV	R4,CC.BUF+MS.SIZ(R5) ;;SET RECV MESSAGE SIZE (IF RECV)
	BR	30$		;;QUEUE IT

20$:	BIS	#XM.FXC,DDFLAG(R1) ;;FIRST TRANSFER IS COMPLETE, START TIMING
30$:	MOV	R5,@XMCPLQ+2(R1) ;;PUT THIS CCB ON COMPLETION QUEUE
	MOV	R5,XMCPLQ+2(R1)	;; AS LAST ELEMENT
	TST	R4		;;WAS THIS A TRANSMIT?
	BNE	L3QSXM		;;NO, LEAVE TIMER ALONE
	CALL	SETTMO		;;SET TIME-OUT IF TRANSMIT QUEUE
	BR	L3QSXM		;;ASK FOR COMPLETION PROCESSING & EXIT

40$:	MOV	#ER.UOI,R2	;;UNEXPECTED OUTPUT INTERRUPT
	BR	FTLERR		;;MAKE IT A FATAL ERROR

50$:	MOV	R1,R0		;;CONTROL OUT MEANS ERROR. COPY DDB ADDRESS
	ADD	#XMCTLO,R0	;;INDEX TO ERROR RECORDING WORDS
	MOV	R4,(R0)+	;;SAVE MOST RECENT STATUS
	MOV	R4,R2		;;COPY STATUS
	BEQ	90$		;;NO BITS ON IS A FREAK CTLO INTERRUPT
.ASSUME	XMECTR EQ XMCTLO+2
	MOV	#3,R5		;;COUNT THREE NON-FATAL ERRORS
60$:	ASR	R2		;;ERROR HERE?
	ADC	(R0)+		;;COUNT IT IF SO
.ASSUME	XMDCHK EQ 1
.ASSUME	XMTMO EQ 2
.ASSUME	XMOVRN EQ 4
	SOB	R5,60$		;;DO THEM ALL
	TST	R2		;;ANY ERROR BITS LEFT?
	BEQ	RLPORT		;;NOPE, A NON-FATAL INTERRUPT IS EASY
	MOV	#ER.MRC,R4	;;START WITH MAINTAIN MESSAGE RECEIVED
70$:	ASR	R2		;;LOOK FOR THE ERROR
	BCS	80$		;;FOUND IT
	INC	R4		;;UPDATE COUNT SINCE ERROR NOT FOUND
	CMP	#ER.PRO,R4	;;TO THE LAST DEFINED ERROR YET?
	BGE	70$		;; NO KEEP AT IT
	CLR	R4		;;NOT A DEFINED ERROR
80$:	MOV	R4,R2		;;MOVE ERROR CODE FOR LOGGER
	MOVB	R4,XMERR(R1)	;;STUFF ERROR IN DDB
	CMP	#ER.DIS,R2	;;DISCONNECT ERROR
	BEQ	NLGERR		;;DONT LOG DISCONNECT ERRORS
	BIT	XMCTLO(R1),#^C<XMERRS> ;;ANY UNUSUAL BITS?
	BEQ	FTLERR		;;WE GOT A STANDARD FATAL ERROR
90$:	MOV	#ER.UNK,R2	;;UNDOCUMENTED BITS ON, GIVE UNKNOWN ERROR
	.BR	FTLERR		;;LOG IT

GLOBAL	<CSR.XM,DEV.XM>

.SBTTL	LOG ERROR AND STOP THE DMC

;+
;	R1 -> DDB
;	R2 =  ERROR CODE
;	R3 -> CSR
;
;	CALL	FTLERR
;
;	DMC11 HALTED, LEVEL 3 SERVICE SCHEDULED
;-

FTLERR:	MOVB	R2,XMERR(R1)	;;SAVE THE ERROR CODE
	LOG$XM			;;LOG THE ERROR
NLGERR:	CALL	XMCDTR		;;MASTER CLEAR THE DEVICE AND DROP DTR
	BIC	#<DDSTAT!XM.SUP>,DDFLAG(R1) ;;NOTE DEVICE IS NOT RUNNING
	BIS	#XM.ERR,DDFLAG(R1) ;;ASK L3 SERVICE TO REPORT ERROR
L3QSXM:	L3QSET	QXMDNE		;;SCHEDULE L3 QUE SERVICE FOR THIS UNIT
RLPORT:	BIC	#RDYO!OFC!OTR,SEL2(R3) ;;RELEASE THE PORT
	RETURN			;;AND EXIT

GLOBAL	<LOG$XM>

.SBTTL	AWAKEN USER WAITING FOR DMC EVENT

;+
;	R1 -> DDB
;
;	CALL	XMFINI,R5,<WAIT BIT MASK>
;
;	R4 =  RANDOM
;-

XMFINI:	BIT	(R5)+,DDFLAG(R1)	;IS THE USER WAITING FOR THIS EVENT?
	BNE	10$		 	;YES SO GO DO AN I/O REDO
	CALLX	IOFINI,R5,JSTIM		;No, wake job up if it is sleeping ;028
	BR	20$			;AND THAT IS ALL

10$:	BIC	-2(R5),DDFLAG(R1) 	;CLEAR THE I/O WAITING BIT
	CALLX	IOFINI,R5,JS.XM		;SCHEDULE THE USER FOR DMC-11 I/O REDO
20$:	RETURN	R5

GLOBAL	<JS.XM>								;028

.SBTTL	TMO$XM - TIMEOUTS

;+
; TMO$XM - TIME OUT ENTRY POINT.
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB
;	R3 -> CSR
;	PRIORITY IS PR5
;
;	...
;
;	RETURN
;
; NOTES:
;	A TIMEOUT WHEN A TRANSMIT IS PENDING IS CONSIDERED FATAL SINCE IT
;	IMPLIES THAT THE DMC WILL NOT TALK TO ANYONE.
;	THIS CODE MERELY SETS UP THE REGISTERS NOTED AND DISPATCHES TO THE
;	FTLERR ENTRY POINT IN THE CTLO INTERRUPT SERVICE CODE.
;	A TIMEOUT WHEN NO TRANSMIT IS PENDING IS IGNORED FOR A USER OR TRN.
;-

	TMPORG	XMDINT,42

	.WORD	TMO$XM

	UNORG

.ENABL	LSB

TMO$XM:	BIT	#DDSTAT!XM.ERR,DDFLAG(R1) ;;RUNNING OR IN ERROR?
	BEQ	20$		;;NEITHER, IGNORE TIMEOUT
	BPL	80$		;;ERROR, PROCESS IT AT LEVEL 3
.ASSUME	XM.ERR GT 0
	BIT	#XM.SUP,DDFLAG(R1) ;;IS THIS DMC IN STARTUP MODE?
	BNE	30$		;;YES THEN CHECK DSR
	MOV	#ER.TMO,R2	;;PRESET TIMEOUT ERROR
	TST	XMTIPQ(R1)	;;ANY TRANSMITS PENDING?
	BNE	10$		;;XMIT PENDING TIMEOUT GO KILL IT
	TST	XMTQUE(R1)	;;ARE THERE MESSAGE FOR THE DMC?
	BEQ	20$		;;NO, ALL DONE
10$:	JMP	FTLERR		;;YES, LOG THE ERROR AND MASTER CLR THE DMC
20$:	RETURN

; CHECK STATE OF DSR ON DMC11

30$:	BIT	#XM.LUL,XMMODE(R1) ;;IS THIS DMC11 IN LINE LOOP?
	BEQ	40$		;;NO CHECK DSR
	BIS	#XM.DSR!XM.DS1,XMFLG2(R1) ;;FAKE SEEING DSR
	BR	70$		;;AND GO SCHEDULE LEVEL 3 SERVICE
40$:	BITB	#DMCDSR,BSEL3(R3) ;;IS DSR ON ON THIS DMC11.
	BEQ	50$		;;NO CLEAR THE DSR ON LAST TIME FLAG.
	BIT	#XM.DS1,XMFLG2(R1) ;;WAS DSR ON LAST TIME
	BNE	70$		;;YES DSR HAS BEEN ON FOR A SEC SO LET DMC FLY
	BIS	#XM.DS1,XMFLG2(R1) ;;SET DSR ON LAST SEC FLAG
	BR	60$		;;SET UP TO DO IT AGAIN
50$:	BIC	#XM.DS1,XMFLG2(R1) ;;CLEAR THE DSR ON LAST SEC FLAG
60$:	MOV	R3,-(SP)	;;SAVE R3
	MOV	#1,R3		;;SET 1 SEC TIME OUT
	BR	100$		;;TRY AGAIN NEXT SEC.
70$:	BIS	#XM.DSR,XMFLG2(R1) ;;SET THE DSR ON FOR A SEC FLAG.
80$:	L3QSET	QXMDNE		;;SCHEDULE LEVEL 3 SERVICE TO ASSIGN BASE TABLE
	RETURN			;;AND EXIT

.SBTTL	SET TIMEOUT VALUE FOR UNIT

;+
; SETTMO - SET OR CLEAR TIME-OUT FOR THIS UNIT
;
;	R1 -> DDB
;
;	CALL	SETTMO
;
;	R0 =  RANDOM
;-

SETTMO:	BIT	#XM.FXC,DDFLAG(R1) ;;FIRST TRANSMIT COMPLETE?
	BEQ	110$		;;NOPE, NO TIMEOUT UNTIL REMOTE END LIVES
	MOV	R3,-(SP)	;;SAVE A WORK REGISTER
	MOV	XMTIPQ(R1),R3	;;GET THE FIRST QUEUE ELEMENT ADDRESS
	BEQ	100$		;;NONE, SO CLEAR TIMEOUT
	MOV	#3.*60.,R3	;;We have one, set three minute timeout	;028
100$:	MOVB	DDUNT(R1),R0	;;GET UNIT NUMBER
	ASL	R0		;; TIMES 2
	MOV	R3,TIM.XM(R0)	;;SET THE TIMER FOR THE UNIT
	MOV	(SP)+,R3	;;RESTORE R3
110$:	RETURN			;;DONE

.DSABL	LSB

GLOBAL	<TIM.XM>

.SBTTL	DEVICE ASSIGNMENT SERVICE

;+
; ASN$XM - DEVICE ASSIGNMENT SERVICE FOR DMC11.
;
;	R0 =  JOB NUMBER OF ASSIGNER TIMES 2
;	R1 -> DDB
;
;	...
;
;	RETURN		(WITH ALL REGISTERS PRESERVED)
;-

	TMPORG	XMDINT,56

	.WORD	ASN$XM

	UNORG

ASN$XM:	.BR	DEA$XM		;Nothing to do...			;028

.SBTTL	DEVICE DEASSIGNMENT SERVICE

;+
; DEA$XM - DEVICE DEASSIGNMENT SERVICE FOR DMC11.
;
;	R1 -> DDB
;
;	...
;
;	RETURN		(WITH ALL REGISTERS PRESERVED)
;-

	TMPORG	XMDINT,62

	.WORD	DEA$XM

	UNORG

DEA$XM:	RETURN			;NOTHING TO DO...


.SBTTL	SPECIAL FUNCTION SERVICE

;+
; SPC$XM - SPECIAL FUNCTION SERVICE FOR DMC11.
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB/FCB
;	R2 =  SPECIAL FUNCTION CODE
;	R3 -> XRB
;	R4 =  CALLING JOB NUMBER TIMES 2 OR 5 IF CALLER IS DECnet
;	R5 -> (MAPPED) XRB (meaningless if caller is DECnet)
;
;	...
;
;	JMP	RTI3
;
;	-OR-
;
;	ERROR	CODE
;
; NOTE:	IF CALLER IS TRANSPORT (R4 = 5), THEN EXIT IS VIA "RETURN" WITH
;	CARRY CLEAR IF NO ERROR, OR CARRY SET AND ERROR CODE IN R0
;	CALLS MADE FROM TRANSPORT MUST STILL BE SYNCHRONOUS; IT IS
;	ASSUMED THAT THE USER IS STILL AROUND IN MEMORY AND THAT SUCH
;	THINGS AS "JOBF" ARE STILL SET TO POINT TO HIM
;-

	TMPORG	XMDINT,46

	.WORD	SPC$XM

	UNORG

.ENABL	LSB

SPC$XM:	MOV	R4,-(SP)	;SAVE CALLER'S JOB NUMBER
	ROR	R0		;SAVE CARRY
	CMP	R2,#SPCMAX	;LEGAL FUNCTION CODE?
	BHIS	10$		;NO, ERROR
	ASL	R2		;MAKE WORD OFFSET (C=0)
	ROL	R0		;RESTORE R0 AND CARRY
	JMP	@SPCTBL(R2)	;DISPATCH TO SUBFUNCTION HANDLER

10$:	SETERR	PRVIOL,R0

SPCERR:	ASR	(SP)+		;WHO'S CALLING?
	BCC	20$		;A USER
	RETURN			;TRANSPORT, GIVE IT A C=1 AND ERROR IN R0

20$:	JMPX	ERROR		;REPORT PROBLEM TO USER


SPCTBL:	.WORD	CPYCTR		;COPY THE COUNTERS
	.WORD	RDCTR		;READ THE COUNTERS FROM THE DDB
	.WORD	SETQTA		;UPDATE QUOTA

SPCMAX	= <. - SPCTBL> / 2

.SBTTL	SETQTA	ASSIGN NEW BUFFER QUOTA

;+
; FUNCTION 2 - SET BUFFER QUOTA
;
; XRB	= 2 (FUNCTION CODE)
; XRB+2	= NEW QUOTA
;
; RETURNS:
;	NOTHING USEFUL
;-

SETQTA:	SETERR	BADCNT,R0	;ASSUME BAD PARAMETERS
	MOV	XRBC(R3),R2	;GET NEW QUOTA
	CMP	R2,#2		;BELOW MINIMUM?
	BLO	SPCERR		;YES, ERROR
	CMP	R2,#32.		;ABOVE MAXIMUM?
	BHI	SPCERR		;YES, ERROR
	MOVB	R2,XMBQTA(R1)	;SET NEW QUOTA
	L3QSET	QXMDNE		;SCHEDULE LEVEL 3 PROCESS TO ASSIGN BUFFERS
	BR	30$		;ALL DONE


.SBTTL	COPY COUNTERS FROM BASETABLE TO DDB

;+
; FUNCTION 0 - READ OR READ/CLEAR COUNTERS FROM DEVICE
;
;	XRB   =	0 (FUNCTION CODE)
;	XRB+10=	0 TO READ
;	      <>0 FOR READ AND CLEAR
;
; RETURNS:
;	NOTHING USEFUL
;
; THIS FUNCTION INITIATES A TRANSFER OF THE COUNTERS FROM THE DEVICE TO THE
; DDB, CLEARING THE DEVICE'S COUNTERS, IF REQUESTED.
;-

CPYCTR:				;THIS IS A NO-OP

; EXIT FROM SPEC PROCESSING

30$:	ASR	(SP)+		;CHECK CALLER'S JOB NUMBER
	BCC	40$		;USER JOB
	CLC			;INDICATE SUCCESS
	RETURN			;AND BACK TO TRANSPORT

40$:	JMPX	RTI3		;EXIT BACK TO USER VIA RTI3

.SBTTL	GIVE CURRENT COUNTERS TO THE USER

;+
; FUNCTION 1 - GIVE CURRENT COUNTERS TO THE USER
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB/FCB
;	R2 =  SPECIAL FUNCTION CODE * 2
;	R3 -> XRB
;	R4 =  CALLING JOB NUMBER TIMES 2 OR 5 IF CALLER IS DECnet
;	R5 -> (MAPPED) XRB if user, otherwise meaningless
;
;	XRB   = 1 (FUNCTION CODE)
;	XRB+2 = LENGTH OF BUFFER
;	XRB+4 = ADDRESS OF BUFFER (mapped if caller is DECnet)
;	XRB+10=	0 TO READ
;	      <>0 FOR READ AND CLEAR
;
; ON EXIT:
;
;	XRB+2 = NUMBER OF BYTES ACTUALLY TRANSFERRED
;
; THIS FUNCTION RETURNS THE COUNTERS TO THE USER BUFFER AND, IF REQUESTED,
; ZEROES THE COUNTERS.
;-

RDCTR:	MOV	10(R3),R0	;SAVE READ VS. READ/CLEAR INDICATOR
	CMP	XRBC(R3),#XM.BTL+XM.TTL ;IS BUFFER LONG ENOUGH?
	BLO	190$		;NO, ERROR
	CMPB	(SP),#TRNJOB	;CALLED FROM TRN?
	BEQ	70$		;Yes, so skip these checks		;027
	TST	R0		;READ OR READ/CLEAR?
	BEQ	60$		;ANYONE CAN READ THE COUNTERS
	MOVB	JOB,R0		;Get caller's job number		;014
	CALLX	CHKPRV,R4	;Check his privilege			;014
	 .BPRIV	SWCTL		;Must have software control privs	;017
	BCS	10$		;Error if not -- note R0 is left <> 0	;014
60$:	MOV	XRBC(R3),(R3)	;Set up the XRB like a .READ		;027
.ASSUME	XRLEN EQ 0
	CLR	XRBC(R3)	;AND CLEAR BYTE COUNT FIELD (LIKE READ)
	SEC			;SET 'C' TO INDICATE READ (MONITOR -> USER)
	CALLX	CHKXRB		;CHECK XRB FOR USER (NO RETURN IF ERROR)
70$:	MOV	#XM.BTL+XM.TTL,XRBC(R3) ;REPORT ACTUAL LENGTH TO MOVE
	MOV	R1,-(SP)	;SAVE DDB POINTER
	ADD	#XMLCTR,R1	;POINT TO LINE COUNTERS
	TST	XMCTBL-XMLCTR(R1) ;CHECK BASE TABLE POINTER
	BEQ	80$		; LINE IS OFF, JUST COPY THE COUNTERS
	MOV	R3,-(SP)	;PRESERVE FIRQB POINTER
	MAP	PUSH,APR=6,DATA	;Save DECnet buffer mapping		;027
	CALL	150$		;READ BASE TABLE COUNTERS, R1 -> COUNTERS
	MAP	POP,APR=6,DATA	;Restore DECnet mapping			;027
	MOV	(SP)+,R3	;RESTORE R3
80$:	CMP	2(SP),#TRNJOB	;CALLED BY TRN?
	BNE	90$		;NO
	MOV	XRLOC(R3),R5	;Yes, get buffer address		;027
	BR	100$		;NOW TRANSFER

90$:	BIS	#JFPOST,@JOBF	;MAKE SURE XRBC IS POSTED BACK TO THE USER
	CALLX	SCRUMX		;MAP THE USER
100$:	MOV	(SP)+,R3	;RESTORE DDB ADDRESS
	MOV	#XM.BTL,R2	;COUNT OF BYTES TO MOVE
110$:	MOVB	(R1)+,(R5)+	;MOVE THAT DATA
	TST	R0		;READ+CLEAR?
	BEQ	120$		;NO
	TST	XMCTBL(R3)	;YES, IS LINE OFF?
	BNE	120$		;NO, LINE IS ON SO SAVED COUNTERS ARE CORRECT
	CLRB	-1(R1)		;ELSE REALLY CLEAR THE SAVED COUNTERS
120$:	SOB	R2,110$		;DO ANOTHER BASETABLE COUNTER
	MOV	R3,R1		;COPY DDB ADDRESS
	ADD	#XMERRC,R1	;NOW POINT TO TRAFFIC COUNTERS
	MOV	#XM.TTL,R2	;COUNT OF BYTES TO MOVE
130$:	MOVB	(R1)+,(R5)+	;MOVE OUT ANOTHER BYTE OF THE COUNTERS
	TST	R0		;SHOULD IT GET ZEROED?
	BEQ	140$		;NOPE, LEAVE IT ALONE
	CLRB	-1(R1)		;ELSE CLEAR IT AS WE GO
140$:	SOB	R2,130$		;DO ANUDDER BYTE OF THE COUNTERS
	BR	30$		;AND EXIT

150$:	MOV	R0,-(SP)	;SAVE READ VS. READ/CLEAR INDICATION
	MOV	R3,R5		;COPY POINTER TO WORK BLOCK
	ADD	#XRBSIZ,R5	;SAVE COMPUTED COUNTS IN TOP OF WORK BLOCK
.ASSUME	XRBSIZ+6 LE 40
160$:	MOV	XMCTBL-XMLCTR(R1),R4 ;GET BASE TABLE ADDRESS
	CALLX	MAPBUF		;MAP THE BASE TABLE
	ADD	#BUFHDR+5,R3	;POINT TO THE DATA
	MOV	#6,R4		;COUNT OF DATA TO MOVE
170$:	MOVB	(R3)+,R2	;GET CURRENT COUNT
	MOVB	(R1)+,R0	;AND PREVIOUS COUNT
	TST	(SP)		;READ/CLEAR?
	BEQ	180$		;NO
	MOVB	R2,-1(R1)	;UPDATE PREVIOUS COUNT IN DDB
180$:	SUB	R0,R2		;COMPUTE DELTA COUNT
	MOVB	R2,(R5)+	;MY KINGDOM FOR AN "SUBB"!
	SOB	R4,170$		;REPEAT UNTIL DONE
	MOV	R5,R1		;TELL MAINLINE WHERE TO FIND THE COUNTERS
	SUB	#6,R1		;POINT BACK TO FIRST COUNTER
	MOV	(SP)+,R0	;RESTORE READ/CLEAR FLAG
185$:	RETURN

190$:	SETERR	BADCNT,R0	;SET ERROR CODE
	JMP	SPCERR		;EXIT WITH ERROR

GLOBAL	<MAXLOW>

.SBTTL	SAVE CURRENT COUNTERS BEFORE TURNING THE LINE OFF

;+
; SAVCTR - SAVE LINE COUNTERS IN THE DDB
;
;	R1 ->	DDB
;
;	CALL	SAVCTR
;
;	ALL REGISTERS PRESERVED
;-

SAVCTR:	TST	XMCTBL(R1)	;DO WE STILL HAVE A BASE TABLE?
	BEQ	185$		;IF NOT, WE DON'T HAVE COUNTERS EITHER
	REGSCR			;SAVE ALL REGISTERS
	ADD	#XMLCTR,R1	;POINT TO THE LINE COUNTER AREA
	MOV	R1,R5		;STORE DIFFERENCES BACK INTO DDB
	CLR	-(SP)		;DO ONLY A READ
	BR	160$		;MERGE WITH COMMON CODE

.DSABL	LSB

.SBTTL	ERL$XM	ERROR LOGGING ENTRY

	TMPORG	XMDINT,22

	.WORD	ERL$XM

	UNORG

ERL$XM:	MOV	R2,-(SP)	;;;SAVE THE ERROR CODE
	CALLX	ERLDVR,R5	;;;CALL THE ERROR LOGGER
	  .BYTE	ERC$XM		;;;ERROR CODE
	  .BYTE	DDS.XM		;;;DDB SIZE IN BYTES
	  .BYTE	0,4		;;;OFFSET, 4 REGISTERS
	  .BYTE	0,0		;;;END
	INCB	(SP)+		;;;TIMEOUT?
	BNE	10$		;;;NO
	COMB	(R0)		;;;YES, INDICATE IT
10$:	BITB	#1,1(R5)	;;;THIS DMC OWNED BY TRN?
	BEQ	20$		;;;NOPE, BELONGS TO SOME JOB
	CLRB	1(R5)		;;;YES, ZERO OUT FUNNY TRN JOB NUMBER
20$:	RETURN			;;;FINISH UP IN ERROR LOGGER

GLOBAL	<DDS.XM>

.SBTTL	UNIMAP - ROUTINE TO CONVERT BUFFER ADDRESS TO UNIBUS ADDRESS

;+
; UNIMAP - FORM UNIBUS WINDOW MAPPED ADDRESS
;
;	R1 =  BUFFER ADDRESS AS ABSOLUTE (MONPOL) OR CONTORTED (EXTPOL)
;
;	CALL	UNIMAP
;
;	R0 =  HIGH ORDER 2 BITS OF ADDRESS IN BITS <15:14>
;	R1 =  LOW ORDER 16 BITS OF UNIBUS ADDRESS (THROUGH UNIBUS MAP)
;-

UNIMAP:	CLR	R0		;CLEAR THE HIGH ORDER
	BIT	R1,#37		;MONITOR POOL BUFFER?
	BEQ	10$		;YUP, ALL SET
	ASHC	#-7,R1		;ROTATE FOR PHYSICAL ADDRESS /100
	ADD	EXTPOF,R1	;ADD IN THE EXTENDED POOL OFFSET
	ASHC	#6,R0		;CONVERT TO 18 BIT ADDRESS IN R0 AND R1
10$:	ASH	#14.,R0		;SHIFT THE HIGH 2 BITS TO THE TOP FOR THE DMC
	RETURN			;AND EXIT

.SBTTL	FLAP AROUND WITH A LONG NOP WAITING FOR RDYI TO SET OR CLEAR

;+
; FLAP - WAIT FOR RDYI THE HARD WAY
;
;	R3 -> CSR
;
;	CALL	FLAP
;
;	N-BIT SET FROM RDYI
;	C=0
;-

FLAP:	MOV	R3,-(SP)	;SAVE A KNOWN BIG NON-0 NUMBER
	MUL	R3,R3		;WAIT A WHILE
	MUL	R3,R3		; AND A WHILE MORE
	MOV	(SP),R3		;RESTORE THE FLAPPER
	TSTB	@(SP)+		;SET CONDITIONS (THE SLOW WAY)
	RETURN			;ARRRRRRRRRGHHHHHH!!!

GLOBAL	<EXTPOF>

;+
; RBFTRF - RETURN CCB TO TRANSPORT, SETTING PARAMETERS
;
;	R1 -> DDB
;	R5 -> CCB
;
;	CALL	RBFTRF,R0,FC$XXX
;
;	CC.FC AND CC.DDB LOADED, THEN CCB IS QUEUED TO TRANSPORT
;-

RBFTRF:	MOVB	(R0)+,CC.FC(R5)	;LOAD THE FUNCTION
	INC	R0		;SKIP UNUSED HIGH BYTE
	.BR	RBFTRN		;QUEUE IT TO TRN

;+
; RBFTRN - RETURN BUFFER TO TRN
;
;	R1 -> DDB
;	R5 -> CCB
;
;	CALL	RBFTRN,R0
;
;	CCB IS QUEUED TO TRN AND TRN IS AWAKENED
;-

RBFTRN:	MOV	R1,CC.DDB(R5)	;LOAD THE DDB POINTER
	CLR	(R5)		;Clear out link to ensure end of list	;019
	SPLC	5		;Lock out interrupts			;024
	MOV	R5,@TRNQUE+2	;;QUEUE THIS CCB FOR TRN
	MOV	R5,TRNQUE+2	;; AS THE LAST ON THE QUEUE
	SPLC	3		;;Re-enable interrupts			;024
	L3QSET	QTRN		;WAKE UP TRN
	RETURN	R0

GLOBAL	<TRNQUE>

	.END
