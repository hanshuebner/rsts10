.INCLUDE /CMN:COMMON/
.INCLUDE /CMN:KERNEL/
.INCLUDE /CMN:IIDEF/
.INCLUDE /DVR:IBMDEF/
TITLE	IIDINT,<IBM Interface root code>,0A,10-MAY-91,KPH

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR IIDINT

;+
;			[RSTS/E V9.3]
;  000  KPH  22-Feb-86	Creation - create out of IIDVR and thin air
;-

	DEFORG	IIDVR		;MAIN DRIVER CODE
 
	DEFORG	IIDINT		;ROOT INTERRUPT CODE (R-O, I&D-SPACE)
 
	DEFORG	IIDISP		;ROOT CODE (R-O, I-SPACE)
$IIDISP	==	. 		;**Merge** Alternate for IIDISP

	DEFORG	IIDTBL		;ROOT TABLES (R-O, D-SPACE)
 
	DEFORG	IIDCTL		;ROOT CONTROL DATA (R/W, D-SPACE)
 
; DEFINT 'DDSTS' VALUE FOR IBM INTERFACE DRIVER
 
STS.II	==	DDAUX/400
		;AUXILIARY PROCESSOR CAPABILITY
 
; DEFINE FLAGS FOR IRB INTERFACE DRIVER
 
FLG.II	==	FLGFRC!FLGMOD!DDNFS!IBMHND
		;BYTE ORIENTED
		;ACCEPT MODIFIERS
		;NON-FILE STRUCTURED
		;IBM INTERFACE
 
; DEFINE WIDTH
 
SIZ.II	==	5.*14.+1
		;NO SPCIFIC WIDTH
 
; DEFINE DEFAULT BUFFER SIZE
 
BUF.II	==	512.
		;DEFAULT BUFFER SIZE IS 512. BYTES
 
; THIS DRIVER DOES'NT ISSUE ANY ERROR LOGGING CALLS...
 
ERL$II	==	0
 
	ORG	IIDINT		;"INTERRUPT" DISPATCH
 
IIDINT::CALLX	INTSAV,R5	;Save all registers
	.WORD	1200		;**Merge** APR value filled in 
	.WORD	0		;**Merge** Interrupt value filled in

.SBTTL	Resolve driver entry points

	ORG	IIDISP		;Root I-only code

SPC$II::JMP	@#0		;Off to the special function service
ASN$II::JMP	@#0		;Off to the assignment service
DEA$II::JMP	@#0		;Off to the deassignment service
TMO$II::JMP	@#0		;Off to the timeout service
OPN$II::JMP	@#0		;Off to the open service
SER$II::JMP	@#0		;Off to user level service
CLS$II::JMP	@#0		;Off to the close service
SLP$II::JMP	@#0		;Off to the sleep service

.SBTTL	MOVE DATA FROM USER'S BUUFER TO BIG BUFFER
 
;+
; IIMTTX
;
;	INPUT :
;		R0 -> LTT
;		R1 -> IIDDB
;		R2 -> IRB
;		R5 -> USER'S INPUT BUFFER THRU APR6
;
;		...
;
;		RECORD COPIED TO BIG BUFFER
;
;		RETURN		(ALL REGISTERS PRESERVED)
;-
 
IIMTTX::
	REGSCR			;SAVE ALL REGISTERS
	MAP	PUSH,APR=5,DATA	;SAVE APR5 WHICH MAPS THE DRIVER	
	MAP	@DPAR6,APR=5,DATA ;MAP USER'S BUFFER THROUGH APR5 TOO	
	SUB	#20000,R5	;CONVERT USER'S APR6 BUFFER ADDR TO APR5 ADDR 
	MOV	IIPRID(R1),-(SP) ;SAVE PRODUCT ID ON THE STACK
	MOV	XRBC(R3),R1	;R1 = RECORD LENGTH
	MOV	IRBCON(R2),R4	;R4 = CONTROTED BUFFER ADDR FOR BIG BUFFER
	CALLX	MAPBUF		;MAP BIF BUFF THRU APR6
	ADD	#BUFHDR,R3
	MOV	R3,R4		;R4 -> BEGINNING OF BIG BUF THRU APR6
 
.IF	DF KM3271		;RSTS/KMC-3271
 
	BIT	#II3271,(SP)	;IS IT RSTS/KMC-3271
	BEQ	40$		;NO
	CMPB	#NORMMD,LTTMD(R0) ;IS IT NORMAL MODE?
	BNE	10$		;NO, OK
	MOVB	#'',(R3)+	;YES, MOVE IN THE AID CHAR "'"
	INC	R1		;ONE MORE TO GO
10$:	MOV	R1,IRBBFL(R2)	;SAVE NUMBER OF BYTES TO GO OUT
20$:	MOVB	(R5)+,(R3)+	;MOVE THE DATA
	SOB	R1,20$		;CONTINUE UNTIL DONE
	BR	100$		;GO TO COMMON RETURN ROUTINE...
40$:
 
.ENDC				;RSTS/KMC-3271
 
.IF	DF KM2780		;RSTS/KMC-2780
 
	BIT	#II2780,(SP)	;IS IT RSTS/KMC-2780
	BEQ	70$		;NO...
	MOV	IRBBFL(R2),-(SP) ;(SP) = # OF CHAR IN THE DATA BUF
	BEQ	45$		;IF ZERO, FIRST TIME TO BE HERE
	ADD	(SP),R3		;ADJUST R3 -> NEXT AVAILABLE BYTE IN BIG BUF
	MOVB	#ITB,-1(R3)	;CHANGE THE PREVIOUS ETB TO ITB
45$:	TST	(SP)+		;CLEAN UP STACK
	CMPB	#NORMMD,LTTMD(R0) ;NORMAL MODE?
	BNE	60$		;NO...
	ADD	R1,IRBBFL(R2)	;ADJUST CURRECT BUFFER COUNT
	MOV	R1,-(SP)	;SAVE COUNT ONTO STACK
	INC	IRBBFL(R2)	;INCLUDE DELIMITER TOO IN BUF COUNT
50$:	MOVB	(R5)+,(R3)+	;MOVE THE RECORD UNTIL DONE
	SOB	R1,50$
	CMP	LTTDEV(R0),(SP)+ ;DID WE MOVE A FULL RECORD?
	BEQ	65$		;YEP...
	DEC	R3		;LET'S LOOK AT LAST CHAR
	CMPB	#EM,(R3)+	;IS IT AN "EM"?
	BEQ	65$		;YEP, JUST LEAVE...
	MOVB	#EM,(R3)+	;NOOP, INSERT AN "EM" AT THE END THEN
	INC	IRBBFL(R2)	;ONE MORE BYTE WE'VE MOVED
	BR	65$
 
; X'PARENCY OUT TO IBM
 
60$:	ADD	LTTDEV(R0),IRBBFL(R2) ;WE HAVE MOVED IN 80 CHAR + 1 DELIMITER
	INC	IRBBFL(R2)
	CALL	XPAOUT		;MOVE IN X'PARENCY MODE...
 
65$:	MOVB	#ETB,(R3)+	;MOVE IN BLOCK DELIMITER
	SUB	#2,IRBPAR+2(R2) ;SUB 2 BYTES FROM MAX BUF SIZE FOR CRC
	BR	100$
70$:
 
.ENDC				;RSTS/KMC-2780

.IF	DF KM3780		;RSTS/KMC-3780
 
	BIT	#II3780,(SP)	;IS IT RSTS/KMC-3780
	BEQ	95$		;NO...
	ADD	IRBBFL(R2),R3	;ADJUST R3 -> NEXT AVAILABLE BYTE IN BIG BUF
	DEC	R3		;OVERWRITE ITB
	CMPB	#NORMMD,LTTMD(R0) ;NORMAL MODE?
	BNE	84$		;NO...
	ADD	R1,IRBBFL(R2)	;ADJUST CURRECT BUFFER COUNT
	INC	IRBBFL(R2)	;INCLUDE "RS" CHAR
	BR	83$
 
; WE HAVE MORE THAN ONE CHARS LEFT, WE HAVE TO LOOK FOR SPACE COMPRESSION
 
73$:	CMPB	#40,(R5)	;SPACE?
	BNE	82$		;NOOP...
	CMPB	(R5)+,(R5)	;TWO SPACES TOGETHER?
	BEQ	74$		;YEP...
	MOVB	#40,(R3)+	;MOVE THE SPACE WE FOUND
	BR	83$		;TRY AGAIN
74$:	MOVB	#GS,(R3)+	;MOVE THE "GS" CHAR
	MOVB	#102,(R3)	;WE HAVE FOUND TWO SPACES
	BR	78$
 
77$:	CMPB	#40,(R5)	;SPACE?
	BNE	81$		;NOOP...
	INCB	(R3)		;ONE MORE SPACE
	BMI	80$		;EXCEED 63 SPACES?
	DEC	IRBBFL(R2)	;NO, ONE LESS CHAR MOVED TO BIG BUFF
78$:	INC	R5		;ADVANCE TO NEXT CHAR
	SOB	R1,77$		;MORE TO SEARCH FOR?
	INC	R3		;NOOP, JUST ADVANCE POINTER
	BR	85$		;AND EXIT...
 
80$:	DECB	(R3)		;RESTORE THE COUNTER
81$:	INC	R3		;ADVANCE POINTER
	BR	83$		;TRY AGAIN
 
82$:	MOVB	(R5)+,(R3)+	;MOVE THE CHAR
83$:	SOB	R1,73$		;ONE CHAR LEFT TO MOVE?
	MOVB	(R5)+,(R3)+	;MOVE THE LAST CHAR
	BR	85$		;GOTO COMMON EXIT...
 
84$:	ADD	LTTDEV(R0),IRBBFL(R2) ;WE HAVE MOVED IN 80 CHAR
	CALL	XPAOUT		;MOVE IN X'PARENCY MODE...
	BR	87$
 
85$:	MOVB	#RS,(R3)+	;MOVE IN RECORD SEPERATOR
87$:	MOVB	#ETB,(R3)+	;MOVE IN BLOCK DELIMITER
	.BR	100$
95$:
 
.ENDC				;RSTS/KMC-3780
 
100$:	TST	(SP)+		;KICK OFF THE PRODUCT ID FROM THE TOP OF STACK
	MOV	IRBBFL(R2),BF.CNT-BUFHDR(R4) ;MOVE COUNT INTO BIG BUF HEADER
	MAP	@DPAR5,APR=6,DATA ;RESTORE APR6 FROM APR5	
	MAP	POP,APR=5,DATA	;RESTORE APR5 FROM STACK	
	RETURN
 
.IF	DF KM2780 ! KM3780	;RSTS/KMC-2780/3780
 
; X'PARENCY OUT TO IBM
 
XPAOUT:
	CMP	LTTDEV(R0),R1	;WE MUST SEND 80 CHAR, DO WE HAVE 80?
	BHIS	10$		;LESS THAN OR EQUAL IS OK...
	MOV	LTTDEV(R0),R1	;OTHERWISE, MAKE IT AS 80
10$:	MOV	R1,-(SP)	;SAVE R1 ON THE STACK
	MOV	R0,-(SP)	;SAVE R0 ON THE STACK
20$:	MOVB	(R5)+,R0	;R0 = CHAR IN ASCII
	BIC	#177400,R0	;MAKE SURE WE ONLY TAKE LSB
	MOVB	ASCEBC(R0),(R3)+ ;MOVE THE RECORD WITH X'LATION UNTIL DONE
	SOB	R1,20$
	MOV	(SP)+,R0	;RESTORE R0 FROM STACK
	MOV	LTTDEV(R0),R1	;FIND OUT IF WE HAVE MOVED EXACTLY 80 CHAR
	SUB	(SP)+,R1	;R1 = 80 - # OF CHAR MOVED
	BEQ	50$		;IF EQ, MOVED 80 CHAR, DONE...
40$:	MOVB	#100,(R3)+	;PAD WITH SPACE IN EBCDIC
	SOB	R1,40$		;UNTIL DONE
50$:	RETURN
 
.ENDC				;RSTS/KMC-2780/3780
 
GLOBAL	<DPAR5,DPAR6>

.SBTTL	MOVE DATA FROM BIG BUFF TO USER'S BUFF
 
;+
; IIMDAT
;
;	INPUT:
;		R0 -> LTT
;		R1 -> IIDDB
;		R2 -> IRB
;		R3 -> XRB
;		R5 -> USER'S BUFFER THRU APR6
;
;		...
;
;		DATA MOVED FROM BIG BUFF TO USER'S BUFF
;
;		RETURN		(WITH ALL REGISTERS PRESERVED)
;-
 
IIMDAT::
	REGSCR			;SAVE ALL REGISTERS
	MAP	PUSH,APR=5,DATA	;SAVE APR5 WHICH MAPS THE DRIVER	
	MAP	@DPAR6,APR=5,DATA ;MAP USER'S BUFFER THROUGH APR5 TOO	
	SUB	#20000,R5	;CONVERT USER'S APR6 BUFFER ADDR TO APR5 ADDR
	MOV	IIPRID(R1),-(SP) ;(SP) = PRODUCT ID
	MOV	(R3),-(SP)	;(SP) = XRLEN
	MOV	IRBCON(R2),R4	;GET CONTROTED ADDR INOT R4
	CALLX	MAPBUF		;MAP BIG BUFF THRU APR6
	ADD	#BUFHDR,R3	;MAKE R3 -> START OF MSG
	MOV	(SP)+,R4	;R4 = XRLEN, LENGTH OF USER'S BUF
 
.IF	DF KM3271		;RSTS/KMC-3271
 
MD3271:	BIT	#II3271,(SP)	;IS IT RSTS/KMC-3271
	BEQ	40$		;NOOP...
	CMP	IRBBFL(R2),R4	;IS USER'S BUFF BIG ENOUGH TO CONTAIN THE MSG?
	BHIS	1$		;NOOP, JUST TAKE USER'S BUF LENGTH AS COUNT
	MOV	IRBBFL(R2),R4	;YES,  TAKE THE COUNT OF MSG LENGTH
1$:	CMPB	#NORMMD,LTTMD(R0);IS IT NORMAL MODE
	BEQ	3$		;YES, GOTO 3$
2$:	MOVB	(R3)+,(R5)+	;MOVE DATA
	SOB	R4,2$		;CONT UNTIL DONE
	BR	30$		;GOTO COMMON EXIT....
 
3$:	ADD	#3,R3		;ADJUST POINTER
	SUB	#3,R4		;SUB OUT ESC-WCC FROM COUNT
	BEQ	30$		;IF ZERO, DONE
5$:	MOVB	(R3)+,R1	;GET CHAR FORM BIG BUFF
	MOV	#NDEL,R0	;R0 = # OF TIMES TO LOOP THRU DELTAB
	MOV	#DELTAB,R2	;R2 -> BIGIN OF DELTAB
15$:	CMPB	(R2),R1		;IS IT IN OUR TABLE?
	BEQ	17$		;YES
	ADD	#4,R2		;SKIP TO NEXT ENTRY
	SOB	R0,15$		;CONT UNTIL END
	MOVB	R1,(R5)+	;MOVE TO USER'S DATA AREA
	BR	20$		;GO AND SERVICE NEXT CHAR
 
17$:	TST	(R2)+		;ANY CHAR TO BE INSERTED?
	BMI	18$		;NOOP...
	MOVB	-1(R2),(R5)+	;INSERT THE CHAR
18$:	SUB	(R2),R4		;SUB # TO PASS
	ADD	(R2),R3		;ADJUST POINTER
20$:	SOB	R4,5$		;LOOP UNTIL DONE
 
30$:	.IIF	NE <.-MDDONE>	JMP	MDDONE ;GOTO COMMON EXIT ROUTINE....
 
40$:
 
.ENDC				;RSTS/KMC-3271
 
.IF	DF KM2780 ! KM3780	;RSTS/KMC-2780/3780
 
MD2780:	BIT	#<II2780!II3780>,(SP) ;IS IT RSTS/KMC-2780/3780
	BNE	5$		;YEP...
	JMP	200$		;NOOP, TRY OTHER PRODUCT...
5$:	ADD	IRBPAR(R2),R3	;POINT TO 1ST BYTE OF NEXT RECORD TO MOVE
	MOV	R3,-(SP)	;SAVE CURRENT POINTER ADDR
	MOV	R0,-(SP)	;FIND OUT IF WE ARE PUNCH OR PRINTER?
	SUB	IILTTP(R1),(SP)
	MOV	IRBBFL(R2),R1	;R1 = # OF CHAR LEFT IN DATA BUF
	CMP	#LTTSIZ*3,(SP)+	;IS IT FOR PUNCH?
	BNE	20$		;NOOP, IT MUST BE FOR PRINTER THEN....
 
; FOR PUNCH
 
	CMPB	#DATAIN,IRBMOD(R2) ;IS IT NORMAL DATA-IN?
	BEQ	7$		;YES...
	MOV	#80.,R4		;MUST BE 80 FOR X'PARENCY
	JMP	70$		;
 
7$:	CMP	#2,R1		;DO WE HAVE AT LEASE TWO BYTES?
	BHI	10$		;NOOP, NO NEED TO SEARCH FOR ESC SEQ...
	CMPB	#ESC,(R3)	;IS IT AN ESCAPE SEQUENCE?
	BNE	10$		;NO
	BITB	(R3)+,(R3)+	;IGNORE THE ESCAPE SEQ FOR PUNCH
	SUB	#2,R1		;TWO LESS BYTES TO WORRY
10$:	CMP	#II3780,2(SP)	;IS IT IN 3780?  		
	BNE	65$		;NO - GO TO COMMON ROUTINES 	
	MOV	R2,-(SP)	;SAVE R2 ONTO STACK		
	JMP	160$		;GO AND SERVICE 3780 PUNCH...	
 
; FOR PRINTER
;  SERVICE CARRIAGE CONTROL CHAR
 
20$:	MOVB	LTTDEV+1(R0),(R5)+ ;MOVE THE OLD ONE TO USER'S BUFFER
	MOVB	#40,LTTDEV+1(R0) ;RESET TO SINGLE SPACING
 
.IF	DF KM3780		;RSTS/KMC-3780
 
	CMP	#II3780,2(SP)	;IS IT IN 3780?
	BNE	25$		;NOOP...
	CMPB	#DATAIN,IRBMOD(R2) ;IS IT NORMAL DATA-IN?
	BEQ	25$		;YEP, GO AND SEARCH FOR "ESC"
	CMP	#512.,@LTTMD(R0) ;IS IT IN RSTS TO RSTS?
	BNE	50$		;NOOP...
	DEC	R5		;YES, NO CARRIAGE CONTROL CHAR
	BR	50$		;NO NEED TO SEARCH FOR ONE EITHER...
25$:
 
.ENDC				;RSTS/KMC-3780
 
	MOV	R4,-(SP)	;SAVE R4 ONTO STACK
30$:	CMP	#2,R1		;DO WE HAVE AT LEASE TWO BYTES?
	BHI	45$		;NOOP, NO NEED TO SEARCH FOR ESC SEQ...
	CMPB	#ESC,(R3)	;IS IT A ESCAPE SEQUENCE?
	BNE	45$		;NO
	INC	R3		;SKIP TO NEXT BYTE
	MOVB	(R3)+,R4	;R4 = CARRIAGE CONTROL CHAR IN EBCDIC
	SUB	#2,R1		;TWO LESS BYTES
	CMPB	#HT,R4		;IS IT "HT"?
	BNE	35$		;NOOP...
	CALL	SETTAB		;SET UP TAB RECORD
	TST	R1		;ANY MORE CHAR IN DATA BUF?
	BNE	30$		;IF NE, MORE...
	MOVB	-(R5),LTTDEV+1(R0) ;RESTORE CARRIAGE CONTROL CHAR
	BR	45$		;CONTINUE...
 
35$:	CMPB	#'/,R4		;IS IT ASCII "/"?
	BEQ	45$		;YES, TAKE THE PRESET VALUE (SPACE)...
	CMPB	#'A,R4		;WITHIN ASCII "A" AND "T"?
	BHI	40$		;LOWER THAN "A", NO CONVERSION...
	CMPB	#'T,R4	
	BLO	40$		;HIGHER THAN "T"...
	MOVB	<CCCHR-101>(R4),R4 ;MADE THE CONVERSION
40$:	MOVB	R4,LTTDEV+1(R0)	;REMEMBER IN LTT
45$:	MOV	(SP)+,R4	;RESTORE R4
 
; SERVICE DATA FOR PRINTER
 
50$:	DEC	R4		;INCLUDE CARRIAGE CONTROL CHAR
	CMPB	#DATAIN,IRBMOD(R2) ;IS IT NORMAL DATA-IN?
	BEQ	55$		;YES...
	MOV	@LTTMD(R0),R4	;USE DEFAULT LP LENGTH FOR X'PARENCY
	BR	70$
55$:
 
.IF	DF KM3780		;RSTS/KMC-3780
 
	CMP	#II3780,2(SP)	;IS IT IN 3780
	BEQ	100$		;YEP...
 
.ENDC				;RSTS/KMC-3780
 
GLOBAL	<DPAR6>

.IF	DF KM2780		;RSTS/KMC-2780
 
; RSTS/KMC-2780
; TO INSURE THAT WE DO NOT IMPOSE EXTRA OVERHEADS INTO THE DRIVER,
; WE WILL FIND OUT IF WE HAVE RECEIVED A TAB RECORD MESSAGE OR NOT.
 
	MOV	R0,-(SP)	;MAKE A COPY OF LTT PTR ONTO STACK
	MOV	LTTMD(R0),(SP)	;(SP) -> TAB REC
	ADD	#2,(SP)		;(SP) -> TAB FLAG
	TST	@(SP)+		;DO WE HAVE A TAB RECORD RECEIVED PREVIOULY?
	BEQ	65$		;NOOP, THEN WE DO NOT SEARCH FOR "HT"....
 
; NORMAL DATA-IN WITH TAB RECORD MESSAGE OUTSTANDING,
; WE HAVE TO SEARCH FOR TERMINATOR IN ADDITION TO "HT".
 
60$:	DEC	R1		;ONE CHAR LESS
	BMI	67$		;NONE IF BECOMES MINUS...
	CMPB	#ITB,(R3)	;IS THIS THE END OF A RECORD?
	BEQ	68$		;YEP...
	CMPB	#HT,(R3)	;IS IT A "HT"?
	BNE	63$		;NOOP...
	CALL	FILTAB		;YEP, SEARCH FOR TAB STOP AND FILL WITH SPACE
	INC	R4		;FAKE ONE EXTRA CHR SPACE IN USER BUF	
	BR	64$		;SERVICE NEXT CHAR IF THERE'S ROOM	
63$:	MOVB	(R3)+,(R5)+	;MOVE THE DATA
64$:	SOB	R4,60$		;MOVE UNTIL DONE OR USER BUF FILLED UP...
	BR	66$		; FILLED UP USER BUF, JUST SEARCH DELIMITER...
 
.ENDC				;RSTS/KMC-2780
 
; FOR PRINTER AND PUNCH IN 2780 AND 3780
; NORMAL DATA IN WITHOUT OUTSTANDING TAB RECORD,
; WE ONLY HAVE TO SEARCH FOR TERMINTOR.
 
65$:	DEC	R1		;ONE CHAR LESS
	BMI	67$		;NONE IF BECOMES MIMUS...
	CMPB	#ITB,(R3)	;IS THIS THE END OF A RECORD?
	BEQ	68$		;YEP...
	MOVB	(R3)+,(R5)+	;MOVE THE DATA
	SOB	R4,65$		;MOVE UNTIL DONE OR USER BUF FILLED UP...
 
; FILLED UP USER BUF, JUST SEARCH FOR DELIMITER WITHOUT MOVING ANYMORE DATA
 
66$:	DEC	R1		;ONE CHAR LESS
	BMI	67$		;NONE IF BECOMES MIMUS...
	CMPB	#ITB,(R3)	;IS THIS THE END OF A RECORD?
	BEQ	68$		;YEP...
	INC	R3		;NOOP, SKIP THE CHAR
	BR	66$		; SKIP UNTIL ITB IS FOUND OR NO MORE CHAR...
 
; NO MORE CHAR LEFT IN THE DATA BUF
 
67$:	CLR	R1		;RESET COUNTER THEN
	BR	69$
 
; FOUND THE RECORD DELIMITER
 
68$:	INC	R3		;SKIP THE RECORD DELIMITER
69$:	MOV	R1,IRBBFL(R2)	;RESTORE CURRENT COUNTER BACK INTO IRB
	CMPB	#EM,-1(R5)	;IS LAST CHAR AN "EM"?
	BNE	180$		;NOOP...
	DEC	R5		;YEP, IGNORE THAT CHAR THEN
	BR	180$		;GOTO COMMON CODES....
 
 
; FOR PRINTER IN 2780 AND 3780
; FOR PUNCH IN 2780 AND 3780
; X'PARENT DATA IN
 
70$:	MOV	R1,IRBBFL(R2)	;UPDATE COUNTER IN IRB
	SUB	R4,IRBBFL(R2)	;DO WE HAVE A FULL RECORD?
	BHIS	73$		;YEP, GOTO COMMON CODES FOR X'PARENCY-IN....
	ADD	IRBBFL(R2),R4	;NOOP, LET'S RESTORE WHAT WE HAD INTO R4
	CLR	IRBBFL(R2)	;AND WE HAVE FINISH ALL FOR THIS BLOCK
 
; PARTIAL RECORD
;  WE ARE SUPPOSED TO HAVE A FULL RECORD IN X'PARENCY MODE IN 2780,
;  IT IS ALLOWED TO HAVE PARTIAL RECORD IN X'PARENCY MODE IN 3780.
;  BUT, WE WILL SERVICE IT ANYWAY.....
 
73$:	MOVB	(R3)+,R1	;R1 = CHAR IN EBCDIC
	BIC	#177400,R1	;MAKE SURE WE ONLY TAKE LSB
	MOVB	EBCASC(R1),(R5)+ ;MOVE THE DATA WITH X'LATION
	SOB	R4,73$		;LOOP UNTIL DONE...
 
.IF	DF KM3780		;RSTS/KMC-3780
 
	CMP	#II3780,2(SP)	;IS IT 3780?
	BEQ	180$		;YEP
	TST	IRBBFL(R2)	;DONE WITH THIS BLOCK?
	BEQ	180$		;YEP...
	INC	R3		;SKIP RECORD DELIMITER (ITB) THEN...
	DEC	IRBBFL(R2)	;ONE LESS BYTE IN DATA BUFFER
 
.ENDC				;RSTS/KMC-3780
 
	BR	180$		;GOTO COMMON EXIT...

.IF	DF KM3780		;RSTS/KMC-3780
 
;+
; RSTS/KMC-3780
;  IT HAS DIFFERENT DATA FORMAT THAN RSTS/KMC-2780
;  THE FOLLOWING CHARACTERS HAS TO BE SEARCHED:
;
;	ITB	UNIT SEPERATOR
;		  - JUST IGNORE IT
;	HT	HORIZONTAL TAB
;		  - SKIP TO NEXT TAB POSITION
;	GS	SPACE COMPRESS INDICATOR
;		  - NEXT CHAR IS A COUNT OF SPACES COMPRESSED
;		  - HEX 42 ->  2 SPACES
;		  - HEX 7F -> 63 SPACES
;	NL	NEW LINE
;		  - PRINT DATA IN RECORD UP TO CRUUENT POSITION
;		  - IF THE RECORD STARTED WITH AN <ESC> VFC SEQ,
;		  - THEN PROCESS THAT SEQUENCE ELSE SKIP TO NEXT LINE.
;	RS	RECORD SEPERATOR
;		  - SAME AS NL
;	VT	VERTICAL TAB
;		  - PRINT DATA IN RECORD UP TO CURRENT POSITION,
;		  - AND GERNEATE A VERTICAL FORMS SKIP TO CHANNEL 2.
;	FF	FORM FEED
;		  - PRINT DATA IN RECORD UP TO CURRENT POSITION,
;		  - AND GENERATE A VERTICAL FORMS SKIP TO CHANNEL 1.
;	LF	LINE FEED
;		  - PRINT DATA IN RECORD UP TO CURRENT POSITION,
;		  - AND GENERAL A SKIP TO NEXT LINE
;
; VT, FF AND LF WILL JUST BE PASSED TO THE SPOOLER.
; NL WILL BE FUNCTIONALLY IDENTICAL TO RS.
;-
 
100$:
 
; TO INSURE THAT WE DO NOT IMPOSE EXTRA OVERHEADS INTO THE DRIVER,
; WE WILL FIND OUT IF WE HAVE RECEIVED A TAB RECORD MESSAGE OR NOT.
 
	MOV	R2,-(SP)	;SAVE R2 ONTO STACK
	MOV	LTTMD(R0),R2	;R2 -> TAB REC
	TST	2(R2)		;DO WE HAVE A TAB RECORD RECEIVED PREVIOULY?
	BEQ	160$		;NOOP, THEN WE DO NOT SEARCH FOR "HT"....
 
; NORMAL DATA-IN WITH TAB RECORD MESSAGE OUTSTANDING,
; WE HAVE TO SEARCH FOR TERMINATOR IN ADDITION TO "HT".
 
130$:	DEC	R1		;ONE CHAR LESS
	BMI	167$		;NONE IF BECOMES MINUS...
	CMPB	#RS,(R3)	;IS THIS THE END OF A RECORD?
	BEQ	168$		;YEP...
	CMPB	#NL,(R3)	;IS THIS "NL"?
	BEQ	168$		;YEP...
	CMPB	#ITB,(R3)	;IS THIS AN "IUS"?
	BNE	135$		;NOOP...
	INC	R3		;YEP, JUST IGNORE IT IN 3780
	BR	130$		;TRY NEXT CHAR...
135$:	CMPB	#GS,(R3)	;IS THIS A COMPRESS SPACE?
	BNE	140$		;NOOP...
 
; COMPRESS SPACE
 
	INC	R3		;SKIP ONE BYTE
	DEC	R1		;ONE CHAR LESS IN DATA BUF
	BMI	167$		;NO MORE IF BECOMES MINUS...
	CALL	EXPAND		;GO AND EXPAND COMPRESS SPACE...
	BR	143$		;YES, TRY NEXT CHAR IN DATA BUF...
 
140$:	CMPB	#HT,(R3)	;IS IT A "HT"?
	BNE	145$		;NOOP...
	CALL	FILTAB		;YEP, SEARCH FOR TAB STOP AND FILL WITH SPACE
143$:	INC	R4		;FAKE AS ONE MORE BYTE IN USER BUF
	BR	150$		;SERVICE NEXT CHAR...
 
145$:	MOVB	(R3)+,(R5)+	;MOVE THE DATA
150$:	SOB	R4,130$		;MOVE UNTIL DONE OR USER BUF FILLED UP...
	BR	166$		; FILLED UP USER BUF, JUST SEARCH DELIMITER...
 
; NORMAL DATA IN WITHOUT OUTSTANDING TAB RECORD,
; WE ONLY HAVE TO SEARCH FOR TERMINTOR.
 
160$:	DEC	R1		;ONE CHAR LESS
	BMI	167$		;NONE IF BECOMES MIMUS...
	CMPB	#RS,(R3)	;IS THIS THE END OF A RECORD?
	BEQ	168$		;YEP...
	CMPB	#NL,(R3)	;IS THIS "NL"?
	BEQ	168$		;YEP...
	CMPB	#ITB,(R3)	;IS THIS THE END OF A RECORD?
	BNE	162$		;NOOP...
	INC	R3		;YEP, JUST IGNORE IT IN 3780
	BR	160$		;TRY NEXT CHAR...
162$:	CMPB	#GS,(R3)	;IS THIS A COMPRESS SPACE?
	BNE	163$		;NOOP...
	INC	R3		;SKIP ONE BYTE
	DEC	R1		;ONE CHAR LESS IN DATA BUF
	BMI	167$		;NO MORE IF BECOMES MINUS...
	CALL	EXPAND		;GO AND EXPAND COMPRESS SPACE...
	INC	R4		;FAKE AS ONE BYTE MORE IN USER BUF
	BR	165$
 
163$:	MOVB	(R3)+,(R5)+	;MOVE THE DATA
165$:	SOB	R4,160$		;MOVE UNTIL DONE OR USER BUF FILLED UP...
 
; FILLED UP USER BUF, JUST SEARCH FOR DELIMITER WITHOUT MOVING ANYMORE DATA
 
166$:	DEC	R1		;ONE CHAR LESS
	BMI	167$		;NONE IF BECOMES MIMUS...
	CMPB	#RS,(R3)	;IS THIS THE END OF A RECORD?
	BEQ	168$		;YEP...
	CMPB	#NL,(R3)	;IS THIS A "NL"?
	BEQ	168$		;YEP...
	INC	R3		;NOOP, SKIP THE CHAR
	BR	166$		; SKIP UNTIL ITB IS FOUND OR NO MORE CHAR...
 
; NO MORE CHAR LEFT IN THE DATA BUF
 
167$:	CLR	R1		;RESET COUNTER THEN
	BR	170$		;NO NEED TO SKIP THE RECORD DELIMITER...
 
; FOUND THE RECORD DELIMITER
 
168$:	INC	R3		;SKIP THE RECORD DELIMITER
170$:	MOV	(SP)+,R2	;RESTORE R2 FROM STACK
	MOV	R1,IRBBFL(R2)	;RESTORE CURRENT COUNTER BACK INTO IRB
	.BR	180$		;GOTO COMMON CODES....
 
.ENDC				;RSTS/KMC-3780
 
180$:	TST	IRBBFL(R2)	;IS IT THE END OF BLOCK?
	BNE	185$		;NOOP...
	MOVB	(R3),LTTDEV(R0) ;REMEMBER THE TERMINATER THEN
185$:
 
	SUB	(SP)+,R3	;FIND OUT # OF CHAR PASSED
	ADD	R3,IRBPAR(R2)	;UPDATE NEXT BYTE POINTER
 
.IIF	NE <.-MDDONE>	JMP	MDDONE ;GOTO COMMON EXIT ROUTINE...
 
200$:
 
.ENDC				;RSTS/KMC-2780/3780
 
MDDONE:	TST	(SP)+		;CLEAN UP STACK
	ADD	#20000,R5	;RESTORE APR6 USERS BUFFER ADDR FROM APR5 ADDR
	SUB	TOS.R5+2(SP),R5	;FIND OUT ACTUAL # OF CHAR MOVED
	MOV	TOS.R3+2(SP),R3	;RESTORE XRB ADDR
	MOV	R5,XRBC(R3)	;MOVE TO XRB COUNT
	MAP	@DPAR5,APR=6,DATA ;RESTORE APR6 FROM APR5	
	MAP	POP,APR=5,DATA	;RESTORE APR5 FROM STACK	
	RETURN
 
.IF	DF KM2780 ! KM3780	;RSTS/KMC-2780/3780
 
; SUBROUTINE TO SAVE "HT" RECORD FROM IBM
 
SETTAB:	MOV	R5,-(SP)	;SAVE USER'S BUFFER POINTER ONTO STACK
	MOV	LTTMD(R0),R5	;R5 -> SAVED AREA FOR TAB REC
	MOV	(R5)+,R4	;R4 = MAX LENGTH OF TAB RECORD BUFFER
	MOV	R4,(R5)+	;FLAG AS VALID FOR THIS TAB REC
	TST	R1		;Is there any data to move?	
	BEQ	40$		;No, done...			
5$:	CMPB	#ESC,(R3)+	;Is it an ESC seq?		
	BEQ	10$		;Yes, skip it			
	CMPB	#ITB,-(R3)	;End of a record?		
	BEQ	40$		;Yes, all done...		
	CMPB	#NL,(R3)	;Is it a "NL"?			
	BEQ	40$		;Yes, end of tab format msg...	
	CMPB	#RS,(R3)	;Is it a "RS"?			
	BEQ	20$		;Yes, ignore it			
	TST	R4		;Tab buffer full?		
	BEQ	20$		;Yes, ignore char.		
	MOVB	(R3)+,(R5)+	;Put char in tab buffer		
	DEC	R4		;Bump tab buffer counter	
	BR	30$		;Ready to process next input	
10$:	DEC	R1		;Allow for ESC			
	BEQ	40$		;If it was last char then done	
20$:	INC	R3		;Point to next input char	
30$:	SOB	R1,5$		; and move on to process it	
40$:	MOV	(SP)+,R5	;RESTORE USER'S BUFFER POINTER
	RETURN			; AND RETURN....
 
; SUBROUTINE TO SEARCH FOR NEXT TAB STOP AND FILL IN SPACE(S)
; ON ENTRY:
;	R2 -> IRB
;	R4 =  # OF BYTES LEFT IN USER'S BUFFER
;	R5 -> NEXT BYTE TO FILL IN USER'S BUFFER
 
FILTAB:
	INC	R3		;ADVANCE POINTER
	TST	R4		;ANY MORE LEFT IN USER'S BUF
	BEQ	30$		;NOOP, JUST LEAVE....
	MOV	R3,-(SP)	;SAVE R3 ONTO STACK
	MOV	LTTMD(R0),R3	;R3 -> TAB RECORD SAVED AREA 
	ADD	(R3),R3		;ADD PRINTER WIDTH INTO R3
	ADD	#5,R3		;R3 -> END OF TAB RECORD
	SUB	R4,R3		;R3 -> APPROPRIATE LOCATION IN TAB REC
	BR	15$		;SIMPLE FILL IN A SPACE FIRST OF ALL...
10$:	CMPB	#HT,(R3)+	;FOUND NEXT TAB?
	BEQ	20$		;YEP...
15$:	MOVB	#40,(R5)+	;FILL A SPACE
	SOB	R4,10$		;TRY AGAIN...
20$:	MOV	(SP)+,R3	;RESTORE R3
30$:	RETURN			;EXIT....
 
 
; CARRIAGE CONTROL CHARACTERS CONVERSION TABLE
; FOR ESC A TO ESC T
 
	TMPORG	IIDTBL		;ROOT D-SPACE TABLES	
 
CCCHR:
	.ASCII	.123456789:;<+NOPQR0".
 
	.EVEN
 
	UNORG			;			
 
.ENDC				;RSTS/KMC-2780/3780
 
.IF	DF KM3780		;RSTS/KMC-3780
 
; COMPRESS SPACE EXPANDSION
 
EXPAND:	MOVB	(R3)+,R2	;R2 = COMPREE SPACE COUNT
	BIC	#177700,R2	;GET THE ACTUAL COUNT INTO R2
	BEQ	20$		;None, nothing to do
	SUB	R2,R4		;DO WE HAVE ENOUGH SPACE IN USER BUF?
	BPL	10$		;YEP...
	ADD	R4,R2		;NOOP, JUST MOVE AS MUCH AS YOU CAN
	CLR	R4		;NO MORE SPACE IN USER BUF AFTER THEN
10$:	MOVB	#40,(R5)+	;MOVE SPACES
	SOB	R2,10$
20$:	RETURN
 
.ENDC				;RSTS/KMC-3780
 
GLOBAL	<DPAR5>

	ORG	IIDTBL		;ROOT D-SPACE TABLES		
 
.IF	DF KM3271		;RSTS/KMC-3271
 
.SBTTL	TABLE OF 3271 ORDERS TO DELETE
 
;+
; DELTAB -- TABLE OF 3271 ORDERS TO DELETE
;
;	THIS TABLE CONSISITS OF ENTRIES THAT HAVE THE
;	CONVERTED VALUE OF THE CHARACTER IN WORD 0
;	FOLLOWED BY THE NUMBER OF CHARACTERS AFTER
;	IT TO DELETE AND CHARACTER TO BE INSERTED.
;
;	VALUES IN THE TABLE
;
;	ORDER	HEX	ASCII	# TO DELETE 	CHAR TO BE
;				   AFTER	 INSERTED
;	SF	1D	135 ]	     1		  SPACE
;	IC	13	023 ^S	     0
;	PT	05	005 ^I	     0		   HT
;	NULL	00	000	     0		  SPACE
;	EUA	12	022 ^R	     2
;	SBA	11	133 [	     2
;	RA	3C	176 	     3
;
; OF COURSE THE FIRST ESCAPE AND WCC CHAR WILL BE DELETED
; SF ANC SBA HAVE BEEN CONVERTED AS ']' ANC '[' RESPECTIVELY.
; RA HAS BEEN CONVERTED TO "176".
; IC, PT AND EUA WOULD STILL BE THE SAME AS IN EBCDIC.
;-
 
.MACRO	TABDEL	ORDER,NO,CHAR
 
	.BYTE	ORDER,CHAR
	.WORD	NO
 
.ENDM	TABDEL
 
DELTAB:
	TABDEL	135,1,40	;SF -- START FIELD CHARACTER
	TABDEL	023,0,-1	;IC -- INSERT CHARACTER
	TABDEL	005,0,11	;PT -- PROGRAM TAB
	TABDEL	000,0,40	;NULL -- NULL CHARACTER
	TABDEL	022,2,-1	;EUA -- ERASE TO ADDRESS
	TABDEL	133,2,-1	;SBA -- SET BUFFER ADDRESS
	TABDEL	176,3,-1	;REPEAT TO ADDRESS
 
NDEL=<.-DELTAB/4>		;# OF ORDERS IN DELETE TABLE
 
.ENDC				;RSTS/KMC-3271

.IF	DF KM2780 ! KM3780	;RSTS/KMC-2780/3780
 
.SBTTL	EBCDIC TO ASCII CONVERSION TABLE
 
EBCASC:	.BLKB	400		;256 ENTRY FULL CONVERSION TABLE
 
.SBTTL	ASCII TO EBCDIC CONVERSION TABLE
 
ASCEBC:	.BLKB	400		;256 ENTRY FULL CONVERSION TABLE
 
; DEFINE A MACRO TO FILL IN THE ABOVE TABLES
 
.MACRO	EBCDIC	HEX SYMBOL ASCII
 
.=EBCASC+$$$
	.BYTE	ASCII
.=ASCEBC+ASCII
	.BYTE	$$$
$$$=$$$+1
 
.ENDM
 
$$$=0
 
	.NLIST	MEB
	.ENABL	LC
 
; DEFINE THE CONVERSION TABLES:
;
;	EBCDIC	SYMBOL	ASCII
;	(HEX)		(OCTAL)
 
EBCDIC	00	NUL	00
EBCDIC	01	SOH	01
EBCDIC	02	STX	02
EBCDIC	03	ETX	03
EBCDIC	04	PF	200
EBCDIC	05	HT	11
EBCDIC	06	LC	201
EBCDIC	07	DEL	177
EBCDIC	08	---	202
EBCDIC	09	---	203
EBCDIC	0A	SMM	204
EBCDIC	0B	VT	13
EBCDIC	0C	FF	14
EBCDIC	0D	CR	15
EBCDIC	0E	SO	16
EBCDIC	0F	SI	17
EBCDIC	10	DLE	20
EBCDIC	11	DC1	21
EBCDIC	12	DC2	22
EBCDIC	13	DC3	23
EBCDIC	14	RES	205
EBCDIC	15	NL	206
EBCDIC	16	BS	10
EBCDIC	17	IL	207
EBCDIC	18	CAN	30
EBCDIC	19	EM	31
EBCDIC	1A	CC	210
EBCDIC	1B	CU1	211
EBCDIC	1C	IFS	34
EBCDIC	1D	IGS	35
EBCDIC	1E	IRS	36
EBCDIC	1F	IUS	37
EBCDIC	20	DS	212
EBCDIC	21	SOS	213
EBCDIC	22	FS	214
EBCDIC	23	---	215
EBCDIC	24	BYP	216
EBCDIC	25	LF	12
EBCDIC	26	ETB	27
EBCDIC	27	ESC	33
EBCDIC	28	---	217
EBCDIC	29	---	220
EBCDIC	2A	SM	221
EBCDIC	2B	CU2	222
EBCDIC	2C	---	223
EBCDIC	2D	ENQ	05
EBCDIC	2E	ACK	06
EBCDIC	2F	BEL	07
EBCDIC	30	---	224
EBCDIC	31	---	225
EBCDIC	32	SYN	26
EBCDIC	33	---	226
EBCDIC	34	PN	227
EBCDIC	35	RS	230
EBCDIC	36	UC	231
EBCDIC	37	EOT	04
EBCDIC	38	---	232
EBCDIC	39	---	233
EBCDIC	3A	---	234
EBCDIC	3B	CU3	235
EBCDIC	3C	DC4	24
EBCDIC	3D	NAK	25
EBCDIC	3E	---	236
EBCDIC	3F	SUB	32
EBCDIC	40	< >	40
EBCDIC	41	---	237
EBCDIC	42	---	240
EBCDIC	43	---	241
EBCDIC	44	---	242
EBCDIC	45	---	243
EBCDIC	46	---	244
EBCDIC	47	---	245
EBCDIC	48	---	246
EBCDIC	49	---	247
EBCDIC	4A	CENT	250
EBCDIC	4B	<.>	56
EBCDIC	4C	"<"	74
EBCDIC	4D	<(>	50
EBCDIC	4E	<+>	53
EBCDIC	4F	<|>	174		
EBCDIC	50	<&>	46
EBCDIC	51	---	252
EBCDIC	52	---	253
EBCDIC	53	---	254
EBCDIC	54	---	255
EBCDIC	55	---	256
EBCDIC	56	---	257
EBCDIC	57	---	260
EBCDIC	58	---	261
EBCDIC	59	---	262
EBCDIC	5A	<!>	41
EBCDIC	5B	<$>	44
EBCDIC	5C	<*>	52
EBCDIC	5D	<)>	51
EBCDIC	5E	<;>	73
EBCDIC	5F	<^>	136
EBCDIC	60	<->	55
EBCDIC	61	</>	57
EBCDIC	62	---	263
EBCDIC	63	---	264
EBCDIC	64	---	265
EBCDIC	65	---	266
EBCDIC	66	---	267
EBCDIC	67	---	270
EBCDIC	68	---	271
EBCDIC	69	---	272
EBCDIC	6A	<|>	174
EBCDIC	6B	<,>	54
EBCDIC	6C	<%>	45
EBCDIC	6D	<_>	137
EBCDIC	6E	">"	76
EBCDIC	6F	<?>	77
EBCDIC	70	---	273
EBCDIC	71	---	274
EBCDIC	72	---	275
EBCDIC	73	---	276
EBCDIC	74	---	277
EBCDIC	75	---	300
EBCDIC	76	---	301
EBCDIC	77	---	302
EBCDIC	78	---	303
EBCDIC	79	***	140
EBCDIC	7A	<:>	72
EBCDIC	7B	<#>	43
EBCDIC	7C	<@>	100
EBCDIC	7D	<'>	47
EBCDIC	7E	<=>	75
EBCDIC	7F	<">	42
EBCDIC	80	---	304
EBCDIC	81	<a>	141
EBCDIC	82	<b>	142
EBCDIC	83	<c>	143
EBCDIC	84	<d>	144
EBCDIC	85	<e>	145
EBCDIC	86	<f>	146
EBCDIC	87	<g>	147
EBCDIC	88	<h>	150
EBCDIC	89	<i>	151
EBCDIC	8A	---	305
EBCDIC	8B	---	306
EBCDIC	8C	---	307
EBCDIC	8D	---	310
EBCDIC	8E	---	311
EBCDIC	8F	---	312
EBCDIC	90	---	313
EBCDIC	91	<j>	152
EBCDIC	92	<k>	153
EBCDIC	93	<l>	154
EBCDIC	94	<m>	155
EBCDIC	95	<n>	156
EBCDIC	96	<o>	157
EBCDIC	97	<p>	160
EBCDIC	98	<q>	161
EBCDIC	99	<r>	162
EBCDIC	9A	---	314
EBCDIC	9B	---	315
EBCDIC	9C	---	316
EBCDIC	9D	---	317
EBCDIC	9E	---	320
EBCDIC	9F	---	321
EBCDIC	A0	---	322
EBCDIC	A1	<~>	176
EBCDIC	A2	<s>	163
EBCDIC	A3	<t>	164
EBCDIC	A4	<u>	165
EBCDIC	A5	<v>	166
EBCDIC	A6	<w>	167
EBCDIC	A7	<x>	170
EBCDIC	A8	<y>	171
EBCDIC	A9	<z>	172
EBCDIC	AA	---	323
EBCDIC	AB	---	324
EBCDIC	AC	---	325
EBCDIC	AD	<[>	173	
EBCDIC	AE	---	326
EBCDIC	AF	---	327
EBCDIC	B0	---	330
EBCDIC	B1	---	331
EBCDIC	B2	---	332
EBCDIC	B3	---	333
EBCDIC	B4	---	334
EBCDIC	B5	---	335
EBCDIC	B6	---	336
EBCDIC	B7	---	337
EBCDIC	B8	---	340
EBCDIC	B9	---	341
EBCDIC	BA	---	342
EBCDIC	BB	---	343
EBCDIC	BC	---	344
EBCDIC	BD	<]>	175	
EBCDIC	BE	---	345
EBCDIC	BF	---	346
EBCDIC	C0	<[>	133	
EBCDIC	C1	<A>	101
EBCDIC	C2	<B>	102
EBCDIC	C3	<C>	103
EBCDIC	C4	<D>	104
EBCDIC	C5	<E>	105
EBCDIC	C6	<F>	106
EBCDIC	C7	<G>	107
EBCDIC	C8	<H>	110
EBCDIC	C9	<I>	111
EBCDIC	CA	---	347
EBCDIC	CB	---	350
EBCDIC	CC	---	351
EBCDIC	CD	---	352
EBCDIC	CE	---	353
EBCDIC	CF	---	354
EBCDIC	D0	<]>	135	
EBCDIC	D1	<J>	112
EBCDIC	D2	<K>	113
EBCDIC	D3	<L>	114
EBCDIC	D4	<M>	115
EBCDIC	D5	<N>	116
EBCDIC	D6	<O>	117
EBCDIC	D7	<P>	120
EBCDIC	D8	<Q>	121
EBCDIC	D9	<R>	122
EBCDIC	DA	---	355
EBCDIC	DB	---	356
EBCDIC	DC	---	357
EBCDIC	DD	---	360
EBCDIC	DE	---	361
EBCDIC	DF	---	362
EBCDIC	E0	<\>	134
EBCDIC	E1	---	363
EBCDIC	E2	<S>	123
EBCDIC	E3	<T>	124
EBCDIC	E4	<U>	125
EBCDIC	E5	<V>	126
EBCDIC	E6	<W>	127
EBCDIC	E7	<X>	130
EBCDIC	E8	<Y>	131
EBCDIC	E9	<Z>	132
EBCDIC	EA	---	364
EBCDIC	EB	---	365
EBCDIC	EC	---	366
EBCDIC	ED	---	367
EBCDIC	EE	---	370
EBCDIC	EF	---	371
EBCDIC	F0	<0>	60
EBCDIC	F1	<1>	61
EBCDIC	F2	<2>	62
EBCDIC	F3	<3>	63
EBCDIC	F4	<4>	64
EBCDIC	F5	<5>	65
EBCDIC	F6	<6>	66
EBCDIC	F7	<7>	67
EBCDIC	F8	<8>	70
EBCDIC	F9	<9>	71
EBCDIC	FA	<|>	372
EBCDIC	FB	---	373
EBCDIC	FC	---	374
EBCDIC	FD	---	375
EBCDIC	FE	---	376
EBCDIC	FF	---	377
 
	.DSABL	LC
	.LIST	MEB
 
.ENDC				;RSTS/KMC-2780/3780

.END
