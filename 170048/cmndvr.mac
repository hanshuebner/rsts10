	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
	.INCLUDE /DSK:MSCPDF/
TITLE	CMNDVR,<COMMON DEVICE DRIVER ROUTINES>,0A,13-MAY-91,MHB/GW/WBN/SJM/AJK/FRL/KPH

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR CMNDVR
;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-08
;  001	SJM  13-JUL-81	ADDED I&D SPACE SUPPORT
;  002  AJK  13-JAN-82  MAP TO DISK PHASE BEFORE CALLING FOR UMR FREED NOTIF.
;
;			[RSTS V9.0]
;  003  FRL  25-Oct-83  Made compatible with extended L3Q
;  004  JHC  14-Jan-85	Increase priority of part of RELUMR to PR5
;			to support INT$ UMR release in MSDVR.
;
;			[RSTS V9.3]
;  005  KPH  22-Feb-86	Change SYDAP5 reference to RSTAP5
;  006  KPH  28-Jul-86	Remove BSTALL reference
;  007	FEK  24-Oct-86	Don't call disk drivers with no csr on UMR free up.
;
;			[RSTS V10.1]
;  008	FEK  16-Apr-91	Optimize UMR usage for lowcore I/O
;
;-


	DEFORG	CMNDVR

	DEFORG	UMRISP

	DEFORG	UMRCTL

	ORG	ERLDVR		;REQUIRED HERE FOR PHASED DMC DRIVER

	ORG	CMNDVR

.SBTTL	COMMON DISK/DEVICE DRIVER ERROR LOGGING CONTROL TABLE

	TMPORG	ERLCTB

ERLCTB:	.BLKW		;CSR				CSR


;+
; 			*** NOTE ***
; DO NOT DISTURB THE ORDER OF THE MSCP ERROR LOG SAVE AREA
;-
			;*** MSCP ERROR LOG SAVE AREAS ***
MSCPPK::.BLKB	RSPLNG	;MSCP PACKET SAVE AREA
MSCPCS::.BLKW		;INTERNAL MSCP CONTROLLER STATUS WORD (C.STAT)
MSCPUS::.BLKW		;INTERNAL MSCP UNIT STATUS WORD (U.STAT)
MSCPER::.BLKW		;CLASS DRIVER ERROR CODE
BBRFLG::.BLKW		;BBR FLAG WORD
BADLBN::.BLKW	2	;LBN BEING REPLACED
RBN::	.BLKW	2	;REPLACEMENT BLOCK NUMBER
BADRBN::.BLKW	2	;RBN BEING REPLACED
MSCPWC==<.-MSCPPK>/2	;***END MSCP ERROR LOG SAVE AREA ***


REGSVA::.BLKW	20.	;DISK REGISTERS SAVE AREA (USED BY "ERLDSK")
ENDRSA::.BLKW	2	;END OF SAVE AREA (USED BY "ERLDSK")


ERLAUX::.BLKW		;STATUS/TIMEOUT			TIMEOUT INDICATION
	.BLKB		;OFFSET POSITION		DEVICE NAME
	.BLKB		;OVERLAPPED SEEK INDICATION	 (2 BYTES)
	.BLKW		;UNIT'S SIZE IN DC'S		DEVICE UNIT
	.BLKB		;DEVICE CLUSTER SIZE		DDB SIZE
	.BLKB		;PACK CLUSTER SIZE		 (IN WORDS)

ERLTBL::.BLKB		;ERROR CODE			ERROR CODE
	.BLKB		;JOB NUMBER TIMES 2 (& FLAGS)	JOB NUMBER TIMES 2
	.BLKB		;4 WORDS			4 WORDS
	.BLKB		; FIELD 2			 FIELD 2
	.BLKW		;  -> STATUS INFORMATION	  -> DEVICE INFORMATION
	.BLKB		;4 WORDS			DDB SIZE IN WORDS
	.BLKB		; FIELD 2			 FIELD 2
	.BLKW		;  -> INTO LOGICAL NAME TABLE	  -> DDB
	.BLKB		;16. WORDS			2 WORDS		  **
	.BLKB		; FIELD 2			 FIELD 2	  *OPT
	.BLKW		;  -> DSQ			  -> DDB EXTENSION**
	.BLKB		;16. WORDS	**		1 WORD
	.BLKB		; FIELD 2	*OPT		 FIELD 3
	.BLKW		;  -> SCB/WCB	**		  -> CSR
	.BLKB		;16. WORDS	**		N WORDS		  **
	.BLKB		; FIELD 2	*OPT		 FIELD 4	  *OPT
	.BLKW		;  -> FCB	**		  -> DEV REGS	  **
	.BLKB		;1 WORD				N' WORDS	  **
	.BLKB		; FIELD 3			 FIELD 4	  *OPT
	.BLKW		;  -> CSR			  -> MORE DEV REGS**
	.BLKB		;N WORDS	**		2 WORDS		  **
	.BLKB		; FIELD 4	*OPT		 FIELD 4	  *OPT
	.BLKW		;  -> DEVICE REGS*		  -> RHBAE, RHCS3 **
	.BLKB		;N' WORDS	**		M WORDS		  **
	.BLKB		; FIELD 4	*OPT		 FIELD X	  *OPT
	.BLKW		;  -> MORE DEV REGS*		  -> DATA	  **
	.BLKB		;2 WORDS	**		TERMINATING -1
	.BLKB		; FIELD 4	*OPT
	.BLKW		;  -> RHBAE, RHCS3*
	.BLKB		;N WORDS	**
	.BLKB		; FIELD 5	*OPT
	.BLKW		;  -> MSCP PACKET
	.BLKB		;M WORDS	**
	.BLKB		; FIELD X	*OPT
	.BLKW		;  -> DATA	**
	.BLKW		;TERMINATING -1

	UNORG

.SBTTL	COMMON DISK/DEVICE ERROR LOGGING FINISH UP

;+
; ERLCMN - COMMON DISK/DEVICE ERROR LOGGING FINISH UP.
;
;	R2 -> CONTROL TABLE
;	R3 -> CSR
;	R5 -> .BYTE <STARTING REG OFFSET>,<# REGS>	** OPTIONAL **
;	      .BYTE <STARTING REG OFFSET>,<# REGS>	** OPTIONAL **
;	      .BYTE 0,0
;	      -- LOCATION RETURNED TO --
;	SP -> VALUE FOR R1, VALUE FOR R5, ...
;
;	...
;
;	R1 =  AS POP'D FROM STACK
;	R2 -> TERMINATOR (-1) +2 IN CONTROL TABLE (WORD) (2 WORDS)
;	R5 =  AS POP'D FROM STACK
;-

ERLCMN::MOV	#3*400+1,(R2)+	;;;FIELD 3, 1 WORD
	MOV	#ERLCTB,(R2)	;;; FROM CSR LOCATION
	MOV	R3,@(R2)+	;;;  SO STORE THE CSR
10$:	MOVB	(R5)+,R1	;;;SIGN EXTEND THE REGISTER OFFSET
	ADD	R3,R1		;;; MAKE IT ABSOLUTE
	MOVB	(R5),(R2)+	;;;SET # WORDS TO SAVE
	MOVB	#4,(R2)+	;;; AND FIELD 4
	MOV	R1,(R2)+	;;;SET POINTER TO REGISTERS TO SAVE
	TSTB	(R5)+		;;;REALLY END OF LIST?
	BNE	10$		;;;NOPE, LOOP
	CMP	-(R2),-(R2)	;;;YEP, BACK UP TO REAL END OF TABLE
	MOV	BAELST,R1	;;;GET THE RH70 BAE LIST
	BEQ	30$		;;;NO LIST EXISTS
20$:	MOV	(R1)+,2(R2)	;;;SET THE POINTER TO BAE
	BEQ	30$		;;;NONE, END OF LIST
	CMP	R3,(R1)+	;;;MATCH TABLE CSR?
	BNE	20$		;;;NO, LOOP FOR MORE
	MOV	#4*400+2,(R2)+	;;;YES, SET FIELD 4, 2 WORDS
	BIC	#1,(R2)+	;;; AND ENSURE AN EVEN POINTER
30$:	MOV	#-1,(R2)+	;;;TERMINATE THE CONTROL TABLE
	MOV	#-1,2(R2)	;;; IN BOTH PLACES
	MOV	(SP)+,R1	;;;RESTORE R1 FROM THE STACK
	RETURN	R5		;;;NOW EXIT RESTORING R5

GLOBAL	<BAELST>

.SBTTL	COMMON RH11 DEVICE ADDRESS HANDLING

;+
; RHMADR - MAP AN ADDRESS FOR RH11, USING UMR'S OR BAE.
;
;	R0 =  -(WORD COUNT)
;	R1 =  HIGH PHYSICAL ADDRESS
;	R2 =  LOW PHYSICAL ADDRESS
;	R3 -> CSR
;	R4 -> DSQ OR DDB (USED TO IDENTIFY WINDOW OWNER)
;	PRIORITY IS PR5
;
;	CALL	RHMADR
;
;	R0 =  RANDOM
;	R1 =  RANDOM
;	R2 =  RANDOM
;	RHWC(R3) = -(WORD COUNT)
;
;	IF SUCCESS: C = 0
;		IF BAE:	RHBA(R3) = LOW PHYSICAL ADDRESS
;			(BAE) =    HIGH PHYSICAL ADDRESS
;		ELSE:	RHBA(R3) = LOW UNIBUS ADDRESS
;			1(R3) =    HIGH UNIBUS ADDRESS
;			UMR'S ALLOCATED.  CALL @RELUMR TO RELEASE THEM.
;
;	IF FAILURE: C = 1
;		UMRFLG = 1 TO INDICATE UMR$ CALLS WHEN A WINDOW IS FREED.
;-

RHMADR::MOV	R0,RHWC(R3)	;;SET -(WORD COUNT)
	MOV	R1,-(SP)	;;FREE A REGISTER
	MOV	R2,-(SP)	;; AND ANOTHER
	MOV	BAELST,R1	;;SEE IF THIS DEVICE HAS A BAE
	BEQ	20$		;;NONE DO, SKIP IT
10$:	MOV	(R1)+,R2	;;GET ADDRESS OF SOME BAE
	BEQ	20$		;;END OF LIST, WE DON'T HAVE ONE
	CMP	R3,(R1)+	;;IS IT OURS?
	BNE	10$		;;NO, KEEP LOOKING
	MOV	(SP)+,RHBA(R3)	;;SET LOW PHYSICAL ADDRESS
	MOV	(SP)+,(R2)	;;SET HIGH PHYSICAL ADDRESS
	;CLC			;;C = 0 FROM COMPARE ABOVE
	RETURN			;;RETURN SUCCESS

20$:	MOV	(SP)+,R2	;;RESTORE ADDRESS
	MOV	(SP)+,R1	;; REGISTERS
	CALL	@GETUMR		;;MAP TRANSFER VIA UNIBUS MAP
	BCS	30$		;;IF FAILURE, RETURN WITH CARRY SET
	MOV	R2,RHBA(R3)	;;IF SUCCESS, SET UNIBUS ADDRESS
	MOVB	R1,1(R3)	;; INTO AN 18-BIT RH11
30$:	RETURN			;;RETURN (C SET/CLEAR FROM ABOVE)

GLOBAL	<BAELST>

.SBTTL	COMMON UNIBUS MAP HANDLING

;+
; GETUMR - ALLOCATE UMR'S FOR ADDRESSING AN NPR TRANSFER.
;
;	R0 =  -(WORD COUNT)
;	R1 =  HIGH PHYSICAL ADDRESS
;	R2 =  LOW PHYSICAL ADDRESS
;	R4 -> DSQ OR DDB (USED TO IDENTIFY WINDOW OWNER)
;	PRIORITY IS PR5
;
;	CALL	@GETUMR
;
;	R0 =  RANDOM
;
;	IF SUCCESS: C = 0
;		R1 =  HIGH UNIBUS ADDRESS
;		R2 =  LOW UNIBUS ADDRESS
;
;	IF FAILURE: C = 1
;		R1 =  RANDOM
;		R2 =  RANDOM
;		UMRFLG = 1 TO INDICATE UMR$ CALLS WHEN A WINDOW IS FREED.
;-

$$GUMR	==	.	;**INIT** CHANGED TO '$$RTSP' IF NO UMR'S NEEDED
GETUMR::.WORD	GETUMX		;;SEE IF WE NEED TO DO UNIBUS MAPPING

	TMPORG	UMRISP		;FOLLOWING CAN BE RETURNED TO BUFFER POOL...

GETUMX:	MOV	R3,-(SP)	;;SAVE A REGISTER
	TST	R1		;;A really high address?		;008
	BNE	5$		;; Yes, so do the real work		;008
	MOV	R2,R3		;;Get the low part of the address	;008
	MOV	R0,-(SP)	;; and the word count			;008
	ASL	(SP)		;;  made into a byte count		;008
	SUB	(SP)+,R3	;; now find the end of the I/O		;008
	BCC	5$		;; To big! - get a real UMR		;008
	CMP	R3,#120000	;;Anywhere in the ROOT?			;008
	BLO	55$		;;Yes, so they are easy			;008
5$:	MOV	R2,-(SP)	;;SAVE LOW ADDRESS
	NEG	R0		;;GET +(WORD COUNT)
	ADD	#4096.-1,R0	;;ROUND UP TO 4K MULTIPLE
	ASH	#-12.,R0	;;COMPUTE NUMBER OF MAP REGISTERS REQUIRED
	BIC	#^C<17>,R0	;;STRIP DUPLICATED SIGN BITS
	MOV	UMRPTR,R2	;;START OF LIST OF AVAILABLE UMR'S
10$:	CMP	#UMRTBE-2,R2	;;END OF LIST?
	BLO	60$		;;YES, WE FAILED (C=1 SINCE 'BLO'='BCS')
	MOV	R0,R3		;;DUPLICATE COUNT
20$:	TST	(R2)+		;;IS THIS ONE FREE?
	BNE	10$		;;NO, START LOOKING AGAIN FROM HERE
	SOB	R3,20$		;;YES, IS THAT ENOUGH IN A ROW?
	MOV	R0,R3		;;HAVE ENOUGH, NOW MARK THAT THEY'RE IN USE
30$:	MOV	R4,-(R2)	;;PUT OUR UNIQUE NAME IN THE TABLE
	SOB	R3,30$		;; FOR EACH REGISTER
	ADD	#<UNIWIN/2>+<2*5>-UMRTAB,R2 ;;CHANGE FROM TABLE POINTER ... ;0??
	ASL	R2		;; ... TO POINTER TO UMR'S IN I/O PAGE
	MOV	(SP)+,(R2)+	;;SET LOW ADDRESS INTO FIRST UMR WE CLAIMED
	MOV	R2,-(SP)	;;SAVE POINTER TO UMR (+2)
	BR	50$		;;ENTER THE LOOP TO SET REMAINING UMR'S

40$:	MOV	-4(R2),(R2)	;;COPY PREVIOUS LOW ADDRESS
	ADD	#4096.*2,(R2)+	;;INCREMENT BY 4K BYTES
	ADC	R1		;; AND CARRY
50$:	MOV	R1,(R2)+	;;COPY THE HIGH ADDRESS
	SOB	R0,40$		;;REPEAT
	MOV	(SP)+,R2	;;GET UMR ADDRESS +2
	SUB	#UNIWIN+2,R2	;; TURN INTO 4* UMR NUMBER
	ASH	#5-2,R2		;;R2 = 000000HH LLL00000
	SWAB	R2		;;R2 = LLL00000 000000HH
	MOVB	R2,R1		;;R1 = HIGH UNIBUS ADDRESS
	CLRB	R2		;;R2 = LOW UNIBUS ADDRESS
55$:	CLC			;;WE'RE RETURNING SUCCESS		;008
	BR	70$		;;GO RETURN THESE VALUES

60$:	MOV	SP,UMRFLG	;;INDICATE WE ARE WAITING FOR A UMR	;003
	MOV	(SP)+,R2	;;RESTORE SAVED LOW ADDRESS
70$:	MOV	(SP)+,R3	;;RESTORE A REGISTER
	RETURN			;;C=0 FOR SUCCESS, C=1 FOR FAILURE

	UNORG

;+
; RELUMR - RELEASE UMR'S ALLOCATED TO THIS DSQ OR DDB.
;
;	R4 -> DSQ OR DDB (USED TO IDENTIFY WINDOW OWNER)
;
;	CALL	@RELUMR
;-

$$RUMR	==	.	;**INIT** CHANGED TO '$$RTSP' IF NO UMR'S NEEDED
RELUMR::.WORD	RELUMX		;GO RELEASE THE UMR(S)

	TMPORG	UMRISP		;THIS CAN VANISH TOO...

RELUMX:	MOV	R0,-(SP)	;GET A SCRATCH REGISTER
	MOV	UMRPTR,R0	;POINT TO WINDOW LIST
10$:	CMP	R4,(R0)+	;WAS THIS WORD ALLOCATED?
	BNE	20$		;NO, SKIP
	CLR	-2(R0)		;YES, CLEAR IT
20$:	CMP	R0,#UMRTBE	;DONE?
	BLO	10$		;NO, REPEAT
	MOV	(SP)+,R0	;RESTORE SCRATCH REGISTER
	MOV	@#PS,-(SP)	; save the current priority		;004
	SPLC	5		;; boost it to 5			;004
	TST	UMRFLG		;;Waiting for a UMR?			;003
	BEQ	30$		;;No, exit				;003
	L3QSET	QUMR	        ;;SIGNAL UMR FREED UP ROUTINE IF REQUESTED ;003
	CLR	UMRFLG		;; BUT ONLY DO IT ONCE...
30$:	MOV	(SP)+,@#PS	; and restore calling priority		;004
	RETURN			;EXIT

	TMPORG	UMRCTL

UMRFLG:	.WORD	0		;"QUMR" IF WE SHOULD TELL ABOUT FREED UMR'S

; ALLOCATION TABLE FOR UMR'S EXCEPT THE FIRST 5 (20K WORTH)		;0??
;
; EACH WORD IS:
;
;	0	IF FREE
;	177777	IF PERMANENTLY ALLOCATED (BY INIT)
;	-> DSQ	IF ALLOCATED FOR USE BY A DSQ (OR -> DDB FOR A DDB)
;
; UMRPTR POINTS TO THE FIRST WORD THAT IS NOT 177777

$$UMRP	==	.	;**INIT** POINT TO FIRST AVAILABLE TABLE ENTRY
UMRPTR:	.WORD	UMRTAB		;ASSUME ALL ARE AVAILABLE

$$UMRT	==	.	;**INIT** TABLE FILLED IN AS ABOVE
UMRTAB:	.BLKW0	31.-5		;FIRST 7 DON'T OCCUPY SPACE
UMRTBE:	.WORD	-1		;MARK END OF TABLE

	UNORG



.ENABL	LSB

	L3QENT	QUMR,5$,RSTAP5	;UMR FREED UP NOTIFICATIONS COME HERE	;005

	TMPORG	UMRISP		;THIS CODE IS UNUSED IF NO UMR'S...

5$:	MOV	#UMREND,R5	;END OF UMR ENTRY-POINT TABLE
	MOV	#DVRA5E,R1	;END OF TABLE OF DRIVER PAR5 VALUES
10$:	MAP	@-(R1),APR=5,CODE,DATA ;SET PAR5 FOR THIS DRIVER
	CMP	R1,#DVRAP5	;REACHED START OF PAR5 LIST (DISKS)?
	BLOS	20$		;YES, GO DO THE DISKS
	MOV	-(R5),R2	;NO, GET ADDRESS TO CALL
	BEQ	10$		;SKIP IF THIS DRIVER DOESN'T HANDLE IT
	MOV	R1,-(SP)	;SAVE REGISTER ACROSS THE CALL
	CALL	30$		;GO DO THE CALL

;+
; WHEN THE NON-DISK DRIVER IS CALLED:
;
;	PRIORITY LEVEL IS PR5
;
;	...
;
;	RETURN
;-

	MOV	(SP)+,R1	;RESTORE REGISTER AFTER THE CALL
	BR	10$		; AND LOOP...

GLOBAL	<RSTAP5,UMREND,DVRA5E,DVRAP5>					;005

20$:	MOV	-(R5),R1	;GET POINTER TO D?DINT @ DQS$OO
.ASSUME AP5$OO LT DQS$OO
	MOV	DSKCSR-DSKPTR(R5),R3 ;GET THE CSR ADDRESS		;007
	BPL	25$		;DON'T BOTHER IF THERE ARE NONE		;007
				; This is because several drivers don't check
				; before then use it, and corrupt lowcore.
	MAP	@AP5$OO-DQS$OO(R1),APR=5,CODE,DATA ; MAP TO DRIVER
	MOV	(R1)+,R0	;GET BASE QUEUE ROOT POINTER (@ DQS$OO)
	MOV	(R1),R2		;GET ADDRESS FOR A DISK DRIVER (@ UMR$OO)
.ASSUME	UMR$OO	EQ	DQS$OO+2
	CALL	30$		;GO DO THE CALL

;+
; WHEN THE DISK DRIVER IS CALLED:
;
;	R0 -> BASE QUEUE ROOT
;	R3 -> CSR
;	PRIORITY LEVEL IS PR5
;
;	...
;
;	RETURN
;-

25$:	CMP	R5,#DSKPTR	;WAS THAT THE TOP OF THE DISK POINTER LIST?
	BHI	20$		;NO, REPEAT
	JMPX	RTI3		;YES, ALL DONE

30$:	MOV	R5,-(SP)	;SAVE REGISTER ACROSS THE CALL
	SPLC	5		;;RAISE PRIORITY
	CALL	(R2)		;;CALL THE UMR FREED UP ROUTINE
	SPLC	3		;;DROP PRIORITY AGAIN
	MOV	(SP)+,R5	;RESTORE REGISTER AFTER THE CALL
	RETURN			; AND EXIT

	UNORG

.DSABL	LSB

GLOBAL	<DSKAP5,DSKCSR,DSKPTR>

.SBTTL	ADD-ON DEVICE SUPPORT GLOBAL FLAGS

;+
; AODFLG - DEFINE GLOBAL FLAGS FOR ADD-ON DEVICE SUPPORT
;
;-
	ORG	CMNDVR
	;DEFINE THESE FLAGS IN THE COMMON DRIVER .PSECT
.BSECT
.RM80.:	.BLKB	.		;BIT VALUE FOR DECLARING RM80 SUPPORT
.RM05.:	.BLKB	.		;BIT VALUE FOR DECLARING RM05 SUPPORT
.RP07.:	.BLKB	.		;BIT VALUE FOR DECLARING RP07 SUPPORT

	TMPORG	CMNDVR
$$AODS	==	<.RM80.!.RM05.!.RP07.> ;NON-ZERO IF AODS, ELSE ZERO.
$$AODV	==	1.		;THIS VERSION OF ADD-ON DEVICE SUPPORT
	UNORG
.END
