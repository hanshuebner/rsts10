	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
	.INCLUDE /CMN:FLDEF/
	.INCLUDE /CMN:DTDEF/
TITLE	DTDVR,<DECTAPE DRIVER>,0A,10-MAY-91,ABC/SRM/FRL

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR DTDVR
;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;  001	SRM  15-Nov-81	Change the TMPORG into BUFCTL to reflect
;			the BUFCTL changes for FIP Pool.
;  002  FRL  23-Nov-83  Made compatible with extended L3Q capability
;
;-

	DEFORG	DTDVR

	DEFORG	DTDCTL

	DEFORG	DTDINT

	TMPORG	BGBUFR

BGBUFR:	.BLKB	1000		;EXTEND THE BIG BUFFER TO 1 BLOCK

	TMPORG	BUFCTL,10

	.WORD	1		;SAY THAT 1 BIG BUFFER EXISTS

	INCLUDE	ERLDVR		;INCLUDE THE ERROR LOGGER

	ORG	DTDVR

.SBTTL	DECTAPE DRIVER DEFINITIONS

; DEFINE 'DDSTS' VALUE FOR DECTAPE

STS.DT	==	0/400
		;NO SPECIAL FLAGS

; DEFINE FLAGS FOR DECTAPE

FLG.DT	==	DTAHND
		;DECTAPE

; DEFINE WIDTH

SIZ.DT	==	5*14.+1
		;DEFAULT FOR "NO WIDTH"

; DEFINE DEFAULT BUFFER SIZE

BUF.DT	==	510.
		;DEFAULT TO 510. BYTE BUFFER

; DECTAPE OPEN/CLOSE ARE NON-RESIDENT

OPN$DT	==	-2+1
CLS$DT	==	-2+1

.SBTTL	TC11/TU56 HARDWARE DEFINITIONS

; REGISTER OFFSETS

.DSECT	-2

TCST:	.BLKW		;STATUS AND ERROR REGISTER
TCCM:	.BLKW		;COMMAND (CSR)
TCWC:	.BLKW		;WORD COUNT
TCBA:	.BLKW		;UNIBUS ADDRESS <15-0>
TCDT:	.BLKW		;DATA & BLOCK NUMBER

; BIT ASSIGNMENTS IN "DTST"

.DSECT	3

	.BLKB	31	;EXTENDED DATA BITS
	.BLKB	4	;DATA TRACKS
	.BLKB	.	;MAINTENANCE MARK TRACK
	.BLKB	.	;CLOCK SIMULATES TIMING
TCUPS:	.BLKB	.	;TAPE IS UP TO SPEED
TCNEX:	.BLKB	.	;NON-EXISTENT MEMORY
TCDATM:	.BLKB	.	;DATA MISSED
TCBLKM:	.BLKB	.	;BLOCK MISSED
TCSELE:	.BLKB	.	;SELECT ERROR
TCILO:	.BLKB	.	;ILLEGAL OPERATION
TCMTE:	.BLKB	.	;MARK TRACK ERROR
TCPAR:	.BLKB	.	;PARITY ERROR
TCENDZ:	.BLKB	.	;END ZONE

.SBTTL	DECTAPE DIRTY (READ/WRITE) AREA

	TMPORG	DTDCTL

DTQXFR:	.WORD	0	;PHYSICAL TRANSFER QUEUE

DTQRES:	.WORD	0	;STALLED FOR RESIDENCY QUEUE

DTQFIP:	.WORD	0	;FIP SERVICE REQUEST QUEUE

	TMPORG	DTDINT

DTDINT:	CALLX	INTSAV,R5
	 .WORD	1200
	 .WORD	INT$DT

.SBTTL	DECTAPE PURE (READ-ONLY) DATA

RESDTQ:	.WORD	DTQRES	;POINTER TO THE QUEUE ROOT
L3QBIT:	.L3Q	QDTRES	;LEVEL 3 QUEUE BIT TO SET			;002

FIPDTQ:	.WORD	DTQFIP	;POINTER TO THE QUEUE ROOT
	.L3Q	QDTFIP	;LEVEL 3 QUEUE BIT TO SET			;002


	UNORG

.SBTTL	SPECIAL FUNCTION SERVICE

;+
; SPC$DT - SPECIAL FUNCTION SERVICE FOR DECTAPE.
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB/FCB
;	R2 =  SPECIAL FUNCTION CODE
;	R3 -> XRB
;	R4 =  CALLING JOB NUMBER TIMES 2
;	R5 -> (MAPPED) XRB
;
;	...
;
;	JMP	RTI3
;
;	-OR-
;
;	ERROR	CODE
;-

SPC$DT::ERROR	PRVIOL		;NO SPECIAL FUNCTION SERVICE

.SBTTL	DEVICE ASSIGNMENT SERVICE

;+
; ASN$DT - DEVICE ASSIGNMENT SERVICE FOR DECTAPE.
;
;	R0 =  JOB NUMBER OF ASSIGNER TIMES 2
;	R1 -> DDB
;
;	...
;
;	RETURN		(WITH ALL REGISTERS PRESERVED)
;-

ASN$DT::MOV	R5,-(SP)	;SAVE AN ODD REGISTER
	MOVB	DDUNT(R1),R5	;GET UNIT NUMBER
	MUL	#3,R5		;COMPUTE OFFSET INTO BUFF.SYS
	SWAB	R5		;PUT IN HIGH BYTE
	COMB	R5		;SET LOW BYTE = -1 (NO OUTPUT OPEN)
	MOV	R5,DTOFIL+DTDDSP(R1) ;SET UP DTOFIL AND DTBUFB
.IIF	NE	DTOFIL+1-DTBUFB, .ERROR ;THE ABOVE WON'T WORK
	MOV	(SP)+,R5	;RESTORE R5
	MOV	#FIPDTQ,DTFIPQ+DTDDSP(R1) ;SET ADDRESS FOR QUEL3Q
	;RETURN			;THEN EXIT

.SBTTL	DEVICE DEASSIGNMENT SERVICE

;+
; DEA$DT - DEVICE DEASSIGNMENT SERVICE FOR DECTAPE.
;
;	R1 -> DDB
;
;	...
;
;	RETURN		(WITH ALL REGISTERS PRESERVED)
;-

DEA$DT::RETURN			;NOTHING TO DO...

.SBTTL	INTERRUPTS

;+
; INT$DT - INTERRUPTS FOR DECTAPE.
;
;	R0 =  UNIT NUMBER TIMES 2
;	PRIORITY IS INTERRUPT PRIORITY
;
;	...
;
;	RETURN
;-

.ENABL	LSB

INT$DT::MOV	CSR.DT,R3	;;POINT TO DECTAPE CONTROLLER
	MOV	DTQXFR,R4	;;POINT TO DDB OF UNIT DOING TRANSFER
	BEQ	130$		;;NONE, EXIT QUICKLY, CLEARING TIMEOUTS
	BIT	#TCPAR!TCMTE!TCILO!TCBLKM!TCDATM!TCNEX,TCST(R3) ;;HARD ERROR?
	BEQ	10$		;;NO, DON'T LOG IT
	LOG$DT			;;LOG A DECTAPE ERROR
10$:	BIT	#4,(R3)		;;WERE WE SEARCHING?
	BNE	80$		;;NO, GO SERVICE ACTUAL I/O COMPLETION
	TSTB	DTCFUN(R4)	;;CAN THIS FUNCTION BE ^C-ED ?
	BPL	20$		;;NO
	SETERR	CTRLCE,R5	;;YES, PRESET AN ERROR
	MOVB	DTJBNO(R4),R2	;;GET THE JOB NUMBER
	MOV	JOBTBL(R2),R2	;;GET THE USER'S DDB
	BIT	#JFCC,JDFLG(R2)	;;DID HE TYPE ^C ?
	BNE	110$		;;YES, STOP AND QUIT
20$:	CLR	R5		;;INITIALIZE SEARCH BIAS TO 0
	MOV	#REV.DT,R2	;;GET THE DECTAPE REVERSE DIRECTION BIT
	MOV	TCDT(R3),R0	;;GET THE BLOCK NUMBER WE JUST FOUND
	TST	(R3)		;;ANY ERROR?
	BMI	70$		;;YES, CHECK FOR END ZONE OR SELECT ERR
	SUB	DTBLOK(R4),R0	;;COMPUTE DISTANCE TO DESIRED BLOCK
	CMPB	DTUDIR(R4),1(R3) ;;SEARCHING IN PROPER DIRECTION?
	BNE	30$		;;NO, GO SET A BIAS FOR BLOCK TO FIND
	TST	R0		;;YES, ARE WE AT THE DESIRED BLOCK?
	BNE	40$		;;NOT YET, SEARCH WITH BIAS OF 0
	MOV	DTCFUN(R4),(R3)	;;YES. START XFER, SAME DIRECTION & UNIT
	BR	160$		;;SET TIMEOUT VALUE AND START IT

30$:	TST	(R5)+		;;WRONG DIRECTION, BIAS SEARCH BY 2
40$:	BIT	R2,(R3)		;;THAT IS RIGHT IF GOING FORWARD
	BEQ	50$		;; SINCE WE WANT TO GO PAST, THEN READ REV
	NEG	R0		;;IF SEARCH IS REV, FIND A LOWER BLOCK
50$:	CMP	R0,R5		;;FWD IS RIGHT IF CURRENT <= TARGET
	BLE	160$		;;DIRECTION IS RIGHT, GO CONTINUE SEARCH
60$:	DECB	DTECNT(R4)	;;DON'T ROCK RIGHT AROUND THE CLOCK
	BLE	100$		;;TOO MUCH ROCKING IS AN ERROR
	XOR	R2,(R3)		;;TURN AROUND
	BR	160$		;;SET TIMEOUT, GO, SEARCH MORE

GLOBAL	<CSR.DT,LOG$DT,JOBTBL>

70$:	BIT	#TCENDZ!TCSELE,TCST(R3) ;;SEARCH ERROR. IS IT END ZONE OR SELECT?
	BMI	60$		;;END ZONE, GO TURN AROUND
	BNE	100$		;;SELECT ERROR, DON'T BOTHER TO RETRY
80$:	TST	(R3)		;;DONE TRANSFER (OR SEARCH ERROR)
	BPL	120$		;;IF SUCCESSFUL, FINISH UP
90$:	DECB	DTECNT(R4)	;;IF ERROR, COUNT DOWN THE COUNTER
	BGT	DTGO1		;;IF WE ARE ALLOWED TO, RETRY
100$:	MOVB	TCST+1(R3),DTECNT(R4) ;;SAVE THE HARDWARE STATUS
	SETERR	HNGDEV,R5	;;SET AN ERROR CODE
110$:	MOVB	R5,DTSERR(R4)	;; IN THE DDB
120$:	L3QSET	QDTDNE		;;SIGNAL DECTAPE DONE
130$:	MOVB	#SST.DT,(R3)	;;STOP THE SELECTED TRANSPORT
140$:	CLR	TIM.DT		;;DON'T TIME OUT ANY MORE
	RETURN

GLOBAL	<TIM.DT>

.SBTTL	START I/O ON DECTAPE FOR USER OR FIP

;+
; DTAIOS - START DECTAPE OPERATION OR QUEUE IT
;
;	R4 -> DECTAPE DDB @ DTQPTR
;	DTCFUN(R4) = FUNCTION (RED.DT OR WRT.DT)
;	DTBLOK(R4) = BLOCK TO READ OR WRITE (<0 IF REVERSE)
;	DTBUFF(R4) = BIG BUFFER TO USE
;
;	CALL	DTAIOS
;
;	R0, R2, R3, R5 RANDOM
;	R1 -> FCB/FIRQB
;	DTSERR(R4) = ERROR CODE IF ERROR
;-

DTAIOS:	MOVB	DTUNT(R4),DTUDIR(R4) ;PRESET UNIT IN HIGH BYTE
	MOV	#DTRTCT,DTECNT(R4) ;INIT ERROR COUNT, ERROR CODE = 0
	MOV	(SP)+,DTQRET(R4) ;SAVE ADDRESS TO GO TO ON COMPLETION
	MOV	#RTI3,-(SP)	;RETURN TO MONITOR AFTER STARTING
	CALLX	QUEUER,R5,DTQXFR ;PLACE THE DDB IN THE TRANSFER QUEUE
	BCS	DTGO		;FIRST IN QUEUE, SO START IT
	RETURN			;RETURN TO MONITOR, START IT LATER

DNE$DT::CALL	DEQUE,R1,DTQXFR	;DEQUEUE TRANSFER THAT COMPLETED
	BEQ	170$		;NO OTHER TO START, CONTINUE WITH THIS
	MOV	R4,R0		;PRESERVE POINTER TO THIS DDB
	MOV	(R4),R4		;POINT TO NEXT TRANSFER TO START
DTGO:	TST	DTBLOK(R4)	;WANT TO GO IN REVERSE?
	BPL	150$		;NO, FORWARD
	NEG	DTBLOK(R4)	;YES, CORRECT THE BLOCK NUMBER
	BIS	#REV.DT,DTCFUN(R4) ;TURN ON THE REVERSE BIT IN FUNCTION
150$:	MOV	CSR.DT,R3	;POINT TO THE CONTROLLER
DTGO1:	CMP	(R3)+,(R3)+	;ADVANCE TO BUFFER ADDRESS
	MOV	DTBUFF(R4),(R3)	;SET IT UP FOR LATER
	MOV	#-256.,-(R3)	;SET 256 WORD TRANSFER FOR LATER
	MOV	DTCFUN(R4),-(SP) ;SET UNIT & SEARCH DIRECTION
	MOVB	#RNU.DT!1,(SP)	;READ NUMBER, IE
	MOV	DTSOPT(R4),R5	;GET START DIRECTION OPTIMIZATION
	CLR	DTSOPT(R4)	;TURN IT OFF FOR NEXT TIME
	XOR	R5,(SP)		;START THE OTHER WAY, IF REQUESTED
	MOV	(SP)+,-(R3)	;START THE SEARCH
	MOV	R0,R4		;RESTORE FINISHED DDB POINTER
160$:	MOV	#5,TIM.DT	;SET A 5 SECOND TIMEOUT
	INC	(R3)		;START THE FUNCTION
170$:	RETURN			;BACK TO MAIN LINE (OR MONITOR)

GLOBAL	<RTI3,CSR.DT,TIM.DT>

.SBTTL	TIMEOUTS

;+
; TMO$DT - TIME OUT ENTRY POINT.
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB
;	R3 -> CSR
;	PRIORITY IS PR5
;
;	...
;
;	RETURN
;-

TMO$DT::SPLC	6		;;GO TO DECTAPE PRIORITY
	MOV	DTQXFR,R4	;;GET THE DDB OF THE XFER IN PROGRESS
	BEQ	130$		;;NOTHING. DON'T LOG, JUST LEAVE
	LOG$DT			;;LOG A TIMEOUT ERROR
	BR	90$		;;COUNT ERRORS, RETRY IF POSSIBLE

.DSABL	LSB

GLOBAL	<LOG$DT>

.SBTTL	ERROR LOGGING

;+
; ERL$DT - ERROR LOGGING ENTRY POINT.
;
;	REGISTERS SAME AS AT TIME OF ERL$DT CALL
;	PRIORITY IS PR7
;
;	...
;
;	RETURN
;-

ERL$DT::MOV	R4,R1		;;;COPY THE BIASED DDB POINTER
	SUB	#DTDDSP,R1	;;;POINT TO THE START OF THE DDB
	CALLX	ERLDVR,R5	;;;CALL COMMON DEVICE ERROR LOGGER
	 .BYTE	ERC$DT		;;;DECTAPE ERROR CODE
	 .BYTE	DDS.DT		;;;SIZE OF DDB
	 .BYTE	TCST,5		;;;LOG 5 WORDS STARTING AT TCST
	 .BYTE	0,0		;;;END OF LIST
	TST	TIM.DT		;;;TIMEOUT ERROR?
	BNE	10$		;;;NO
	COMB	(R0)		;;;YES, LOG IT AS SUCH
10$:	MOV	DTFQCB(R4),(R1)	;;;SET FCB/FIRQB POINTER (IF ANY)
	BEQ	20$		;;;NONE
	MOV	#2*400+16.,-(R1) ;;;ONE, SAY 16. WORDS OF FIELD 2
20$:	RETURN			;;;BACK TO ERROR LOGGER

GLOBAL	<DDS.DT,TIM.DT>

.SBTTL	USER LEVEL SERVICE

;+
; SER$DT - USER LEVEL READ/WRITE SERVICE.
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB/FCB
;	R2 =  2 (.READ)
;	      4 (.WRITE)
;	R3 -> XRB
;	R4 =  CALLING JOB NUMBER TIMES 2
;	R5 -> USER'S BUFFER (THROUGH KISAR6)
;	IF Z=1 OR C=0 THEN THIS IS THE FIRST CALL
;	IF Z=0 OR C=1 THEN THIS IS A "REDO" CALL
;
; NOTES:
;
;	1) ACCESS RIGHTS HAVE BEEN VERIFIED.
;	2) DIRECTIONAL RIGHTS HAVE BEEN VERIFIED.
;
; EXITS:
;
;	1) ALL COMPLETE WITH NO ERROR
;
;		JMP	IOEXIT
;
;	2) ALL COMPLETE WITH ERROR
;
;		SETERR	CODE
;		JMP	IOEXIT
;
;		-OR-
;
;		ERROR	CODE
;
;	3) STALL DESIRED (FOR "REDO" LATER)
;
;		JMP	IOREDO
;-

SER$DT::MOV	R1,R0		;COPY THE FCB POINTER
	ADD	#DTFDDB,R0	;POINT TO THE DDB LINK
	MOV	(R0),R4		;GET THE DDB POINTER
	MOV	R1,DTFQCB(R4)	;CROSS-LINK THE DDB TO THIS FCB
	MOV	RWCODE-2(R2),R2	;GET THE CODE FOR TAPE
	ASR	R2		;FIX IT, SETTING C=1 IF READ
	MOV	R2,DTCFUN(R4)	;SAVE THE I/O FUNCTION IN THE DDB
	MOV	XRLOC(R3),-(R0)	;SAVE USER BUFFER ADDRESS
	MOV	#510.,R2	;ASSUME FILE STRUCTURED LIMIT OF 510
	MOV	-(R0),R5	;POINT TO THE FILE WINDOW
	BEQ	90$		;NFS OR CONTIGUOUS FILE IS DIFFERENT

	MOV	-(R0),DTBLOK(R4) ;SAVE THE NEXT BLOCK TO DO
	BEQ	50$		;EOF OR NO ROOM FOR USER ON DEVICE!
	BCC	20$		;IF WRITE, GO TURN A WINDOW
	MOV	(R0),R5		;GET THE BLOCK NUMBER
	BPL	10$		;POSITIVE IS OK
	NEG	R5		;ELSE MAKE IT POSITIVE
10$:	CMP	R5,#578.	;IS THE LINK OUT OF RANGE?
	BLO	40$		;NO, IT'S OK
	ERROR	BADDIR		;ERROR IN DT DIRECTORY STRUCTURE

20$:	TST	(R5)		;ARE WE ABOUT TO LINK TO BLOCK 0?
	BNE	30$		;NO, WE CAN GO
	INCB	FQFUN(R1)	;YES. DID WE GIVE A WARNING?
	BNE	70$		;NOPE, GO GIVE A WARNING
30$:	MOV	(R0),DTFLBL(R1)	;REMEMBER THE BLOCK JUST READ/WRITTEN
	MOV	(R5)+,(R0)+	;IF WRITE, GET NEXT BLOCK FOR LINKING
	MOV	R5,(R0)		;SAVE WINDOW FOR NEXT TIME
40$:	CLR	XRBLK(R3)	;NOT A RANDOM ACCESS DEVICE
	CLRB	XRBLKM(R3)	; IN BOTH PLACES
	BR	140$		;GO CHECK OUT THE COUNT

50$:	BCC	80$		;NO MORE BLOCKS. SORT READ FROM WRITE
60$:	ERROR	EOF		;NO MORE TO READ (OR OUT OF BOUNDS)

70$:	MOVB	#-1,FQFUN(R1)	;INDICATE THAT A WARNING WAS GIVEN
80$:	ERROR	NOROOM		;IF WRITING, GIVE THIS ERROR

90$:	TST	(R2)+		;NFS OR CONTIGUOUS. LIMIT IS 512 BYTES
	MOV	XRBLK(R3),R5	;GET THE REQUESTED BLOCK NUMBER
	BEQ	100$		;NONE, DON'T CLOBBER OUR MEMORY
	MOV	R5,-2(R0)	;HE WANTS ONE. REMEMBER IT
100$:	MOV	-(R0),R5	;GET THE DESIRED BLOCK
	BPL	110$		;POSITIVE IS OK
	NEG	R5		;ELSE FORCE IT TO BE POSITIVE
110$:	TST	(R1)		;CONTIGUOUS FILE?
	BPL	120$		;NO, NFS DECTAPE
	DEC	R5		;YES, MAKE AN OFFSET FROM STARING BLOCK
120$:	CMP	R5,DTFLEN(R1)	;IS THIS TOO BIG?
	BHIS	60$		;IS SURE IS
	MOV	(R0),XRBLK(R3)	;NO, RETURN BLOCK NUMBER TO THE USER
	CLRB	XRBLKM(R3)	; WITH A ZERO HIGH ORDER
	ADD	DTFSBL(R1),R5	;COMPUTE THE TRUE BLOCK NUMBER
	INC	(R0)		;AND NEXT TIME, USE THE NEXT BLOCK
	BGT	130$		;ALSO, IF THIS IS BACKWARDS
	NEG	R5		; THEN FIX THE BLOCK NUMBER
130$:	MOV	R5,DTBLOK(R4)	;SET BLOCK NUMBER FOR TRANSFER
140$:	MOV	(R3)+,R5	;GET THE USER BUFFER SIZE
	TSTB	DTCFUN(R4)	;READING? (CODE HAS CCE.DT ON)
.IIF	NE	CCE.DT-200, .ERROR ;THE ABOVE WON'T WORK
	BMI	150$		;YES
	CMP	R2,(R3)		;IS WRITE COUNT BIGGER THAN LEGAL?
	BHIS	160$		;NO, USE IT
	ERROR	BADCNT		;YES, CAN'T WRITE TOO MUCH

150$:	MOV	R5,(R3)		;READING. READ HIS WHOLE BUFFER
	CMP	R5,R2		;UNLESS HIS BUFFER
	BLOS	160$		; IS BIGGER THAN THE MAXIMUM WE CAN READ
	MOV	R2,(R3)		;  IN WHICH CASE WE SHORTEN HIS COUNT
160$:	MOV	(R3),DTFCNT(R1)	;SAVE THE COUNT IN THE FCB
	CALLX	SAVJOB,R5	;DUMP THE JOB BEFORE STARTING WORK
	CALLX	GETBIG,R5,512.	;GET A BIG BUFFER IN R3 AND DTBUFF(R4)
	MOV	DTFQCB(R4),R1	;RESTORE FCB POINTER
	MOV	R3,R2		;COPY THE BUFFER
	MOV	#256.,R0	;CLEAR IT ALL
170$:	CLR	(R2)+
	SOB	R0,170$
	TSTB	DTCFUN(R4)	;READING?
	BPL	190$		;NO, WRITING
	CALL	DTAIOS		;READING. GO DO THE ACTUAL I/O
	CALL	DTJRES		;MAKE THE JOB RESIDENT
	BNE	180$		;NFS OR CTG, DON'T FIX THE LINK
	MOV	(R3)+,DTFNXB(R1) ;LINKED FILE, SO SET NEXT BLOCK TO READ
180$:	MOVB	(R3)+,(R5)+	;COPY DATA TO HIM
	SOB	R2,180$
	BR	DTRUSR		;MERGE WITH COMMON EXIT CODE

190$:	CALL	DTJRWR		;TURN WINDOW IF NEEDED, THEN MAKE RESIDENT
	BNE	200$		;NFS OR CTG, DON'T SET LINK TO NEXT
	MOV	DTFNXB(R1),(R3)+ ;SET LINK TO NEXT BLOCK
200$:	MOVB	(R5)+,(R3)+	;MOVE DATA TO OUTPUT BUFFER
	SOB	R2,200$
	INC	DTFLEN(R1)	;THE FILE IS 1 BLOCK LONGER NOW
	MOV	JOBTBL(R0),R1	;GET HIS JOB DATA BLOCK
	CALLX	CLRRSQ		; AND MAKE HIM SWAPPABLE AGAIN
	CALL	DTAIOS		;DO THE TRANSFER
DTRUSR:	CALLX	RETBIG,R5,512.	;RETURN THE BIG BUFFER
	MOVB	DTSERR(R4),R3	;SAVE ERROR CODE (IF ANY)
	MOVB	DTJBNO(R4),R4	;GET THE USER JOB NUMBER
	CALLX	IOFIN4,R5,JS.DT	;MAKE USER RUNNABLE SINCE DECTAPE DONE
	MOV	JOBTBL(R4),R1	;GET USER'S JDB POINTER
	MOVB	R3,JDIOST(R1)	;SET ERROR CODE
	BNE	DTRTI3		;IF ANY...
	BIT	#JFCC,JDFLG(R1)	;NO ERROR, BUT DID HE TYPE ^C?
	BEQ	DTRTI3		;NO
	SETERR	CTRLCE,JDIOST(R1) ;YES, GIVE HIM THAT ERROR
DTRTI3:	JMPX	RTI3		;EXIT WITH THE USER RUNNABLE

RWCODE:	.WORD	<RED.DT!CCE.DT>*2+1 ;USER READ CODE, C=1 ON ASR
	.WORD	<WRT.DT>*2+0	;USER WRITE CODE

GLOBAL	<JOBTBL,JS.DT>

.SBTTL	FORCE JOB RESIDENCY FOR DECTAPE OPERATION

.ENABL	LSB

DTJRES:	MOV	(SP)+,DTQRET(R4) ;SAVE RESIDENCY COMPLETION ADDRESS
10$:	CALLX	QUEUER,R5,DTQRES ;QUEUE UP A RESIDENCY REQUEST
	BCC	DTRTI3		;ONE IS ALREADY PENDING, SO DELAY
RES$DT::MOV	DTQRES,R4	;GET JOB TO BE MADE RESIDENT
	BEQ	DTRTI3		;HOW DID WE GET HERE?
	MOVB	DTJBNO(R4),R0	;GET JOB NUMBER TO BRING IN
	MOV	DTFQCB(R4),R1	;AND GET FCB ADDRESS
	MOV	L3QBIT,R3	;SIGNAL US WHEN RESIDENT		;002
	MOV	DTFADR(R1),R5	;SET USER BUFFER ADDRESS
	CALLX	FNDJOB		;FIND THE JOB
	 BR	30$		;ERROR IS RESIDENCY
	BCS	DTRTI3		;NOT HERE, BUT COMING
	MOV	(R4),DTQRES	;DEQUEUE FROM RESIDENCY QUEUE
	BEQ	20$		;NO MORE PENDING
	L3QSET	QDTRES		;ELSE SIGNAL US AGAIN LATER
20$:	CALLX	UNLOCK		;UNLOCK THE JOB
	MOV	DTBUFF(R4),R3	;GET BIG BUFFER ADDRESS
	MOV	DTFCNT(R1),R2	;GET USER BYTE COUNT
	BIT	#DT.CTG!DDNFS,(R1) ;CONTIGUOUS OR NFS?
	JMP	@DTQRET(R4)	;RETURN WITH RESIDENCY & CC SET

DTJRWR:	MOV	(SP)+,DTQRET(R4) ;SAVE RETURN ADDRESS
	MOV	#RESDTQ,DTRPTR(R4) ;SET FOR QUEL3Q BY DTU
	MOV	DTFPTR(R1),R0	;GET THE WINDOW POINTER
	BEQ	10$		;NFS OR CTG, NO TURNS NEEDED
	BIT	R0,#37		;IS THE WINDOW EMPTY?
	BNE	10$		;NOPE (OR READ), JUST GET THE JOB
	FJMPDV	DT,UTL,MOVE,FQADDR(R1) ;LOAD THE DISPATCH ADDRESS
	BR	FIPSGO		;GO DO DSPFQ INTO FIP

30$:	SETERR	HNGDEV,DTSERR(R4) ;RESIDENCY ERROR - RETURN TO USER QUICKLY
	BR	DTRUSR

.DSABL	LSB


.SBTTL	DECTAPE SERVICES FOR FIP

.ENABL	LSB

FIP$DT::CALL	DEQUE,R1,DTQFIP	;DEQUEUE THIS REQUEST
	BEQ	10$		;NO MORE
	L3QSET	QDTFIP		;SIGNAL MORE LATER
10$:	MOV	DTBUFF(R4),(SP)+ ;DUMP DTQRET WORD. DO WE HAVE A BUFFER?
	BNE	20$		;YES
	CALLX	GETBIG,R5,512.	;NO, GET ONE
	MOV	DTFQCB(R4),R1	;RESTORE FIRQB POINTER
20$:	TSTB	DTCFUN(R4)	;FUNCTION IS SIMPLE BUFFER FETCH?
	BEQ	FIPSGO		;YUP, EASY TO FINISH
	CALL	DTAIOS		;DO THE I/O
	TSTB	DTSERR(R4)	;ERROR DURING FIP OPERATION?
	BEQ	FIPSGO		;NOPE, RETURN TO CALLER
	FJMPDV	DT,UTL,MOVE,FQADDR(R1) ;YES, REROUTE TO ERROR HANDLER
	SUB	#2,FQADDR(R1)	; WHICH IS A SUBFUNCTION OF UTILITY CODE
FIPSGO:	MOV	R1,R4		;R4 -> FCB FOR DSPFQ CALL
	MOVB	#DSPFQ,FQFUN(R4) ;FUNCTION IS DISPATCH
	JMPX	FIPSYS		;TO FIP

.DSABL	LSB

.SBTTL	DEQUEUE A REQUEST FROM A QUEUE

;+
; DEQUE - REMOVE A REQUEST FROM A QUEUE
;
;	CALL	DEQUE,R1,<ADDRESS OF QUEUE ROOT>
;
;	R4 -> TOP ELEMENT OF QUEUE
;	R1 -> FCB/FIRQB FROM DTFQCB(R4)
;	DISPATCH ADDRESS FROM DTQRET(R4) PUSHED ON STACK
;	Z=1 (BEQ SUCCEEDS) IF NOTHING MORE IN QUEUE
;
;	GOES DIRECTLY TO RTI3 IF QUEUE IS EMPTY
;-

DEQUE:	MOV	@(R1)+,R4	;R4 -> TOP ELEMENT
	BEQ	10$		;NOTHING IN QUEUE, SO EXIT QUIETLY
	MOV	DTQRET(R4),(SP)	;OVERLAY OLD R1 WITH RETURN ADDRESS
	MOV	DTFQCB(R4),-(SP) ;NEW R1 IS FCB/FIRQB POINTER
	MOV	(R4),@-2(R1)	;REMOVE REQUEST FROM QUEUE
	RETURN	R1		;BACK WITH CONDITION CODES SET

10$:	MOV	(SP)+,R1	;DUMP CALLER'S R1
	BR	DTRTI3		;EXIT FASTLY

.END

