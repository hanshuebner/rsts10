	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
	.INCLUDE /CMN:MTDEF/
TITLE	MTDVR,<MAGTAPE I/O SERVICE>,0A,10-MAY-91,MHB/JDM/SJK/AJK/SRM/FRL/TWH/DBM/KPH/VAM

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR MTDVR
;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;
;  001  AJK  16-JUN-81  ON A BACKSPACE, INCORRECT VALUE WAS RETURNED
;			WHEN DRIVE IS ALREADY AT BOT.
;  002	SRM  15-Nov-81	Change the TMPORG into BUFCTL to reflect
;			the BUFCTL changes for FIP Pool.
;
;				[RSTS V9.0]
;  003  FRL  25-Oct-83  Added extended level three queue (L3Q) capability
;  004	TWH  02-APR-84	ADD EOV CHECK ON EOF ERROR
;  005	DBM  01-May-84	Finish up EOV processing and add ECA spec
;  006	DBM  20-Jul-84	Add 'true' ECA support
;  007	DBM  09-Aug-84	Fix a bug in EOV handling
;  008	DBM  28-Aug-84	Skip error condition check if in INIT
;  009	DBM  06-Sep-84	Don't return NOROOM error unless command is a write
;  010	KPH  11-Sep-84	Move to MVR phase
;  011	KPH  04-Feb-85	Bugfix in 010 (fix DEA$MT and UMR$MT merge)
;  012	DBM  22-Mar-85	Bug fixes for NOROOM and ECA checking
;
;				[RSTS V9.1]
;  013  VAM  06-MAY-85	Add Extended Set Density .SPEC call
;
;				[RSTS V9.2]
;  014  KPH  16-Aug-85	Add job control region
;  015	DBM  09-Oct-85	Fix MTU request handling, move EOV handling with it
;-

	DEFORG	MTDVRM							;010

	INCLUDE	ERLDVR

.SBTTL	TM11/TU10 HARDWARE DEFINITIONS

; REGISTER OFFSETS

.DSECT	-2

MTAS:	.BLKW		;STATUS
MTAC:	.BLKW		;COMMAND (CSR)
MTABRC:	.BLKW		;BYTE/RECORD COUNT
	.BLKW		;UNIBUS ADDRESS <15-0>
	.BLKW		;DATA BUFFER
MTARDL:	.BLKW		;READ LINES

; BIT ASSIGNMENTS IN "MTAS" (FOR "MTLCST")

.BSECT

MTTUR:	.BLKB	.	;TAPE UNIT READY
MTRWS:	.BLKB	.	;REWIND STATUS
MTWRL:	.BLKB	.	;WRITE LOCKED
MTSDWN:	.BLKB	.	;SETTLE DOWN
MTCH79:	.BLKB	.	;1=>7 TRACK; 0=>9 TRACK
MTBOT:	.BLKB	.	;BEGINNING OF TAPE
MTSELR:	.BLKB	.	;SELECT REMOTE
MTNXM:	.BLKB	.	;NON-EXISTENT MEMORY
MTBTE:	.BLKB	.	;BAD TAPE ERROR
MTRLE:	.BLKB	.	;RECORD LENGTH ERROR
MTEOT:	.BLKB	.	;END OF TAPE
MTBGL:	.BLKB	.	;BUG GRANT LATE
MTPAE:	.BLKB	.	;PARITY ERROR
MTCRE:	.BLKB	.	;CRC ERROR
MTEOF:	.BLKB	.	;EOF DETECTED (TAPE MARK)
MTILC:	.BLKB	.	;ILLEGAL COMMAND

; BIT ASSIGNMENTS IN "MTAC"

.BSECT

	.BLKB	15	;GO
	.BLKB	42	;FUNCTION
	.BLKB	20	;UNIBUS ADDRESS <17-16>
	.BLKB	.	;INTERRUPT ENABLE
	.BLKB	3200	;CONTROL UNIT READY
.IIF	NE	MT.UNT*400-., .ERROR ;SELECTION CODE WON'T WORK
	.BLKB	400	;UNIT SELECT
.IIF	NE	MT.PAR*400-., .ERROR ;SELECTION CODE WON'T WORK
	.BLKB	.	;PARITY SELECT
MTPWRC:	.BLKB	50000	;POWER CLEAR CONTROL
.IIF	NE	MT.DEN*400-., .ERROR ;SELECTION CODE WON'T WORK
	.BLKB	20000	;DENSITY SELECT
	.BLKB	.	;ERROR

; BIT ASSIGNMENT IN "MTARDL"

.EQUATE	MTGPSD,	10000	;GAP SHUTDOWN

; BIT ASSIGNMENTS IN "MTAINF"

.BSECT

MT$TRY:	.BLKB	.	;RETRYABLE REQUEST
MT$NIN:	.BLKB	.	;NO INTERRUPT REALLY OCCURED
MT$LCK:	.BLKB	.	;JOB IS LOCKED INTO MEMORY
MT$RW:	.BLKB	.	;REQUEST IS READ/WRITE
MT$BAK:	.BLKB	.	;DOING BACKSPACE FOR RETRY
MT$REQ:	.BLKB	.	;PROCESSING A REQUEST
MT$BSY:	.BLKB	.	;CONTROL IS BUSY
MT$INT:	.BLKB	.	;EXPECTING AN INTERRUPT

	UNORG

.SBTTL	DEVICE ASSIGNMENT SERVICE

;+
; ASN$MT - DEVICE ASSIGNMENT SERVICE FOR MAGTAPE.
;
;	R0 =  JOB NUMBER OF ASSIGNER TIMES 2
;	R1 -> DDB
;
;	...
;
;	RETURN		(WITH ALL REGISTERS PRESERVED)
;-

	TMPORG	MTDINT,32						;010
	 .WORD	ASN$MT							;010
	 UNORG								;010

ASN$MT: DEC	TIM.MT		;START ONCE A SECOND TIMEOUTS		;010
	MOV	#MTAPTR,MTRPTR+MTDDSP(R1) ;SET THE ROOT POINTER IN DDB
	MOVB	MAGLBL,MTLBLI+MTDDSP(R1) ;SET LABELING DEFAULT
	MOVB	#MT.DEN,MTFLAG+MTDDSP(R1)	;Default density is 800	;013
	;BIBC	#MT.ECK,MTFLAG+MTDDSP(R1) ;CLEAR ANY ERROR CHECK STATE
	RETURN			;NOW EXIT

.SBTTL	DEVICE DEASSIGNMENT SERVICE

;+
; DEA$MT - DEVICE DEASSIGNMENT SERVICE FOR MAGTAPE.
;
;	R1 -> DDB
;
;	...
;
;	RETURN		(WITH ALL REGISTERS PRESERVED)
;-

	TMPORG	MTDINT,36						;011
	 .WORD	DEA$MT							;010
	 UNORG								;010

DEA$MT:	INC	TIM.MT		;END ONCE A SECOND TIMEOUTS		;010
	RETURN			; AND EXIT

GLOBAL	<TIM.MT,MAGLBL,TAPDEN,MTAPTR>					;013

.SBTTL	LOG MAGTAPE ERRORS

	TMPORG	MTDINT,12						;010
	 .WORD	ERL$MT							;010
	 UNORG								;010

ERL$MT:	MOV	R4,R1		;;;COPY THE (BIASED) DDB ADDRESS	;010
	SUB	#MTDDSP,R1	;;; TO GET REAL DDB POINTER
	CALLX	ERLDVR,R5	;;;USE COMMON ROUTINE
	  .BYTE	ERC$MT		;;;ERROR CODE
	  .BYTE	DDS.MT		;;;DDB SIZE IN BYTES
	  .BYTE	MTAS,4		;;;OFFSET, 4 REGISTERS
	  .BYTE	MTARDL,1	;;;OFFSET, 1 REGISTER
	  .BYTE	0,0		;;;THAT'S ALL
	TSTB	MTATIM		;;;TIMEOUT?
	BPL	10$		;;;NO
	COMB	(R0)		;;;YES, INDICATE TIMEOUT
10$:	MOV	MTACB(R4),(R1)	;;;SET ACB POINTER (IF ANY)
	BEQ	20$		;;;NONE
	MOV	#2*400+16.,-(R1) ;;;ONE, SAY 16. WORDS OF FIELD 2
20$:	RETURN			;;;BACK TO ERROR LOGGER

GLOBAL	<DDS.MT,MTATIM>							;010

.SBTTL	ONCE A SECOND ENTRY POINT (TIMEOUTS)

.ENABL	LSB

	TMPORG	MTDINT,22						;010
	 .WORD	TMO$MT							;010
	 UNORG								;010

TMO$MT:	MOV	#MTADRW,R2	;;PTR TO: DRW, INF, TIM, SRC		;010
	MOVB	#-1,(R2)+	;;DO REWINDERS NEXT TIME PLEASE
	MOV	MTAQUE,R4	;;ANYTHING IN THE REQUEST QUEUE?
	BNE	10$		;;YES, SO DON'T CALL ANY CODE
	L3QSET	QMTCON		;;NO, SO CALL THE REWIND CHECKING CODE
10$:	BIT	#100200,(R2)+	;;WAITING FOR A TIME OUT?
	BLE	30$		;;NOPE
	MOV	(R2),R5		;;YES, SNAG SAVED "MTABRC"
	MOV	MTABRC(R3),(R2)	;;UPDATE SAVED VERSION TO CURRENT
	CMP	R5,(R2)		;;FIND THE DIFFERENCE
	BNE	30$		;;THEY ARE DIFFERING, SO DON'T TIMEOUT NOW
	DECB	-(R2)		;;SAME, TIMED OUT?
	BPL	30$		;;NOT YET
	LOG$MT			;;WHOOPS, LOG THE ERROR
	MOV	#020000,MTARDL(R3) ;;THEN FORCE AN IMMEDIATE SHUTDOWN
	;BR	INT$MT		;;FAKE AN INTERRUPT

.SBTTL	PROCESS INTERRUPTS (PR5)

	TMPORG	MTDINT,6						;010
	 .WORD	INT$MT							;010
	 UNORG								;010

INT$MT::MOV	CSR.MT,R3	;;GET THE HARDWARE POINTER
	MOV	MTAQUE,R4	;;GET TOP-OF-QUEUE REQUEST
	BEQ	20$		;;NONE, JUST EXIT
	TSTB	MTAINF		;;EXPECTING THIS INTERRUPT?
	BPL	40$		;;NO, SO LOG ERROR
	BICB	#MT$INT!MT$NIN,MTAINF ;;YES, BUT NOT ANOTHER
	L3QSET	QMTDNE		;;NOW CALL COMPLETION CODE
20$:	BIC	#IE,(R3)	;;CLEAR INTERRUPT ENABLE FOR MAGTAPE
30$:	RETURN			;; AND EXIT

40$:	LOG$MT			;;LOG UNEXPECTED INTERRUPT ERROR
	BR	20$		;;NOW GO EXIT

.DSABL	LSB

GLOBAL	<LOG$MT,CSR.MT,IE,MTAQUE,MTADRW,MTAINF>				;010

.SBTTL	MAGTAPE UNIT SELECT (AND VERIFY) ROUTINES

.ENABL	LSB

MTASEE:	MOV	#90$,R5		;SET THE RETURN FOR "RETURN R5"
MTASEL:	MOV	CSR.MT,R3	;GET HARDWARE COMMAND POINTER
	MOVB	MTOFLG(R4),R0	;GET UNIT, ETC. FROM DDB
	BIC	#^C<MT.DEN!MT.PAR!MT.UNT>,R0 ;LEAVE UNIT, DENSITY, PARITY
	CMPB	R0,MTACUN	;IS IT THE CURRENTLY SELECTED UNIT?
	BEQ	60$		;YES, SO NO NEED TO RE-SELECT
	MOV	#20$,-(SP)	;NO, GUESS AT THE LONG DELAY
	TSTB	MTACUN		;IS ANY UNIT NOW SELECTED?
	BMI	10$		;NOPE, SO SELECT AND LONG DELAY
	BIT	#MTRWS!MTTUR,MTAS(R3) ;YEP, SO IS IT READY?
	BEQ	10$		;NEED LONG DELAY IF NOT NOW READY
	MOV	#30$,(SP)	;IF READY SHORT DELAY WORKS
10$:	MOVB	R0,MTACUN	;SET NEW UNIT AS CURRENT
	SWAB	R0		;PUT DATA WHERE HARDWARE WANTS IT
	MOV	R0,(R3)		; AND DO THE UNIT SELECT
	RETURN			;GO TO PROPER DELAY ROUTINE

20$:	CMP	(SP)+,(SP)+	;DUMP SAVED R5 AND MAIN RETURN
	BICB	#BQMTCON,@#OQMTCON+L3QUE ;Cancel immediate re-entry	;003
	L3QSET	QMTCON,WAIT2T	; and wait 2 ticks (settle time) ;003
	JMP	MTART3		;EXIT VIA LEVEL 3 FOR NOW

30$:	ADD	#MTARDL,R3	;GET POINTER TO 50US CLOCK
	MOV	(R3),R0		;NOW GRAB ITS INITIAL VALUE
40$:	MOV	(R3),-(SP)	;GET CURRENT VALUE OF CLOCK
	XOR	R0,(SP)+	;DID VALUE CHANGE?
	BPL	40$		;NO, WE NEED AN INITIAL CHANGE HERE
50$:	MOV	(R3),-(SP)	;GET CURRENT VALUE OF CLOCK
	XOR	R0,(SP)+	;DID VALUE RESTORE ITSELF?
	BMI	50$		;NOT YET, WE NEED BACK TO ORIGINAL
	BR	MTASEL		;NOW GO TRY THE THING AGAIN

60$:	BIT	#MTSELR,-(R3)	;IS REMOTE SELECT TRUE?
	BEQ	70$		;NO, SO REAL (EASY) SELECT ERROR (C=1)
	BIT	#MTGPSD,MTARDL-MTAS(R3) ;IS TAPE GOING THROUGH GAP?
	BNE	20$		;IF SO, THEN WAIT A WHILE...
	BIT	#MTSDWN,(R3)	;ELSE IS IT SETTLING DOWN?
	BNE	20$		;WAIT A WHILE IF SO...
	BIT	#MTRWS!MTTUR,(R3) ;ELSE IS IT REALLY READY?
	BNE	80$		;YES, SO ALL IS O.K. (C=0)
70$:	SEC			;INDICATE SELECTION FAILURE (C=1)
80$:	RETURN	R5		;EXIT WITH C-BIT INDICATION

90$:	BCC	100$		;ALL O.K., SO JUST EXIT
	SETERR	MAGSEL,MTLCEV(R4) ;IF ERROR, THEN SET THE ERROR CODE
	MOV	#MTASVT,R5	; AND CHANGE THE RETURN ADDRESS
100$:	JMP	(R5)		;EXIT

.DSABL	LSB
GLOBAL	<CSR.MT,WAIT2T,L3QUE,MTACUN>					;010

.SBTTL	GET AN ANSI LABEL BUFFER

MTAGBF:	MOVB	#UNT.MT,MTCCMD(R4) ;CHANGE FUNCTION TO 'UNIT STATUS'
MTAGLB:	MOV	R4,(SP)		;SAVE THE DDB POINTER (& POP "RTI3")
	CALL	MTANXT		;NOW DEQUEUE THIS REQUEST FROM DRIVER QUEUE
	MOV	(SP)+,R4	;RESTORE THE DDB POINTER
	CALLX	GETBIG,R5,MTULBF ;REQUEST A BIG (I/O) BUFFER
	CALLX	QUEL3Q		;WE GOT IT, RE-QUEUE TO DRIVER'S QUEUE
	BR	MTART3		; AND EXIT...

.SBTTL	SPECIAL FUNCTION SERVICE

;+
; SPC$MT - SPECIAL FUNCTION SERVICE FOR MAGTAPE.
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB/FCB
;	R2 =  SPECIAL FUNCTION CODE
;	R3 -> XRB
;	R4 =  CALLING JOB NUMBER TIMES 2
;	R5 -> (MAPPED) XRB
;
;	...
;
;	JMP	RTI3
;
;	-OR-
;
;	ERROR	CODE
;-

.ENABL	LSB

	TMPORG	MTDINT,26						;010
	 .WORD	SPC$MT							;010
	 UNORG								;010

SPC$MT:	CMP	R2,#<GBF.MT-1>-2;IS FUNCTION IN CORRECT RANGE?		;010
.ASSUME	<XDN.MT+1> EQ GBF.MT						;005
	BLOS	7$		;YES, SO GO SET UP PARAMETERS
5$:	ERROR	NOTMTA		;ELSE ERROR

7$:	TST	R2		;IS CODE 0?				;005
	BEQ	8$		;IF SO, THEN LEAVE IT AS 0		;005
	CMPB	(R2)+,(R2)+	;ELSE ADD 2 TO CODE (CHEAPLY)		;005
8$:	BITB	#MT.ECK,MTFLAG+MTDDSP(R1)	;WAITING FOR AN ECA?	;006
	BEQ	10$		;NO, GO AHEAD				;015
	CMP	R2,#ECA.MT	;USER REQUEST, THIS BETTER BE AN ECA	;006
	BEQ	10$		;GOOD JOB, USER!			;006
	ERROR	HNGDEV		;OH WELL, WE'LL WAIT			;006

10$:	BIS	#JFPOST,@JOBF	;BE SURE USER GETS RETURNED VALUE	;015
	CLR	JBSTAT(R4)	;PUT JOB IN A STALL CONDITION		;004
	MOV	#JS.MT,JBWAIT(R4) ; ON MAGTAPE COMPLETION
	ADD	#MTCNT+MTDDSP,R1 ;INDEX INTO DDB AWAYS
	MOV	XRBC(R3),(R1)+	; AND SET THE FUNCTION'S COUNT
	BR	30$		; AND CONTINUE

GLOBAL	<JBSTAT,JS.MT,JBWAIT>

.SBTTL	USER LEVEL SERVICE

;+
; SER$MT - USER LEVEL READ/WRITE SERVICE.
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB/FCB
;	R2 =  2 (.READ)
;	      4 (.WRITE)
;	R3 -> XRB
;	R4 =  CALLING JOB NUMBER TIMES 2
;	R5 -> USER'S BUFFER (THROUGH KISAR6)
;	IF Z=1 OR C=0 THEN THIS IS THE FIRST CALL
;	IF Z=0 OR C=1 THEN THIS IS A "REDO" CALL
;-

	TMPORG	MTDINT,16						;010
	 .WORD	SER$MT							;010
	 UNORG								;010

SER$MT:	BITB	#MT.ECK,MTFLAG+MTDDSP(R1)	;WAITING FOR AN ECA?	;010
	BEQ	17$		;NO, GO AHEAD				;006
	ERROR	HNGDEV		;OH WELL, WE'LL WAIT			;006

17$:	ADD	#MTUBUF+MTDDSP,R1 ;INDEX INTO DDB AWAYS
	CLR	XRBLK(R3)	;INDICATE A SEQUENTIAL DEVICE
	CLRB	XRBLKM(R3)	; IN BOTH PLACES
	MOV	XRLOC(R3),(R1)	;NOW SET USER'S VIRTUAL BUFFER ADDRESS
	BIT	(R1)+,#1	;IS IT ODD?
	BNE	20$		;YES, ERROR
	MOV	(R3)+,(R1)+	;SET COUNT AS BUFFER LENGTH
	ASR	R2		;MAKE 2/4 INTO 1/2
	CMP	R2,#.WRITE&377/2 ;IS IT WRITE?
	BNE	30$		;NOT WRITE, ALL SET
	MOV	(R3),-(R1)	;WRITE, USE SUPPLIED BYTE COUNT
	CMP	(R1)+,#14.	;14. BYTES IS THE MINIMAL RECORD SIZE
	BGE	30$		;O.K. RECORDS ARE 14.<=SIZE<16K
20$:	ERROR	BADCNT		;ELSE SET AN ERROR AND EXIT

30$:	TST	(R1)+		;SKIP FLAG WORD IN DDB
	MOVB	#MTRTCT,(R1)+	;SET INITIAL RETRY COUNT
	INC	R1		;SKIP DOS/ANSI FLAG
	MOVB	R2,(R1)		; AND, FINALLY, SET THE COMMAND
	SUB	#MTCCMD,R1	;BACKUP TO QUEUE WORD IN DDB
	MOV	R1,R4		;PUT POINTER IN CORRECT SPOT
	CALLX	QUEL3Q		;NOW QUEUE REQUEST INTO DRIVER'S QUEUE
	JMPX	DMPJOB		;THEN DUMP THE JOB AND EXIT

.DSABL	LSB

.SBTTL	UMR HANDLING

;+
; UMR$MT - ENTERED WHEN A UNIBUS MAPPING REGISTER BECOMES AVAILABLE.
;
;	ALL REGISTERS RANDOM
;	PRIORITY IS PR5
;
;	RETURN		(PRIORITY STILL PR5)
;-

	TMPORG	MTDINT,52						;011
	 .WORD	UMR$MT							;010
	 UNORG								;010

UMR$MT:	L3QSET	QMTCON		;;RE-ENTER AT LEVEL 3			;010
	RETURN

.SBTTL	LEVEL 3 QUEUED CONTINUE ENTRY POINT

	TMPORG	MTDINT,42						;010
	 .WORD	CON$MT							;010
	 UNORG								;010

CON$MT:	CALL	MTASET		;CALL THE PROCESSING CODE		;010
MTART3:	JMPX	RTI3		;EXIT VIA LEVEL 3

.SBTTL	LEVEL 3 QUEUED DONE ENTRY POINT

.ENABL	LSB

10$:	MOV	#-1,MTLCST(R4)	;FORCE VERY FATAL TYPE ERROR
20$:	MOV	MTACUN-1,R0	;GET CURRENT UNIT
	CLRB	R0		;REMOVE FUNCTION
	BIS	#MTPWRC,R0	; AND ADD POWER CLEAR BIT
	NEGB	MTACUN		;SAY NO UNIT IS TO BE SELECTED
	MOV	R0,(R3)		;NOW CLEAR CONTROL...
	BR	30$		; AND WAIT A WHILE

	TMPORG	MTDINT,46						;010
	 .WORD	DNE$MT							;010
	 UNORG								;010

DNE$MT:	MOV	CSR.MT,R3	;GET COMMAND REGISTER POINTER		;010
	MOV	MTAQUE,R4	; AND FINISHED REQUEST
	MOV	#MTAINF,R1	;HANDY POINTER
	BITB	#MT$NIN,(R1)	;DID AN INTERRUPT OCCUR?
	BNE	170$		;NO, SO NO MORE STATUS CHECKING
	TSTB	MTACUN		;DID WE HAVE DO CLEAR CONTROL?
	BMI	90$		;YES, SO DON'T CHECK AGAIN
	SETERR	HNGDEV,MTLCEV(R4) ;PRESET THE MOST FATAL TYPE ERROR
	TSTB	MTATIM		;DID THE TIME OUT EXPIRE?
	BMI	10$		;YES, SO POWER CLEAR, ETC.
	BIT	#MTSELR,-(R3)	;IS UNIT STILL SELECTED?
	BEQ	40$		;NO, FORGET MORE CHECKING
	BIT	#MTRWS!MTTUR,(R3) ;IF SELECTED, IS IT READY?
	BNE	40$		;YES, SO CAN CONTINUE NOW
30$:	L3QSET	QMTDNE,WAIT2T 	;WAIT FOR 2 TICKS OF STALL	;003
	BR	MTART3		;WE WILL BE COMING BACK LATER

40$:	MOV	(R3)+,R5	;SNAG THE CURRENT STATUS
	BIT	R5,#MTILC!MTCRE!MTPAE!MTBGL!MTBTE!MTNXM ;ANY ERROR?
	BEQ	50$		;NOPE
	LOG$MT			;YES, SO LOG THAT ERROR
50$:	BITB	#MT$BAK,(R1)	;FROM BACKSPACE OF RETRY?
	BEQ	60$		;NOPE
	CALL	190$		;YES, SO FINISH UP AND
	BR	MTART3		; EXIT VIA LEVEL 3

60$:	MOV	MTABRC(R3),R2	;GET BYTE/RECORD COUNTER
	BITB	#MT$RW,(R1)	;READ/WRITE TYPE REQUEST?
	BEQ	80$		;NO, SO NO SPECIAL COMPUTING
	ADD	MTCNT(R4),R2	;YES, SO FORM REAL COUNT FOR XFER
	CMP	R2,MTCNT(R4)	;VALID COUNT?
	BLOS	70$		;YES
	LOG$MT			;NO, SO LOG AN ERROR
	CRASH			; AND DIE!!!!!

70$:	NEG	R2		;NEGATE FOR NEGATE BELOW
80$:	NEG	R2		;FIX UP COUNT SO WE CAN
	MOV	R2,MTCRET(R4)	;SO IT FOR THE CALLER
	MOV	R5,MTLCST(R4)	;SAVE THE STATUS BITS
	BMI	20$		;"ILC", SO POWER CLEAR CONTROL

GLOBAL	<CSR.MT,WAIT2T,LOG$MT,MTAQUE,MTACUN,MTAINF,MTATIM>		;010

90$:	MOV	MTLCST(R4),R5	;GET THE LAST STATUS
	BMI	160$		;"ILC", ERROR CODE ALREADY SET
	TSTB	R5		;FATAL TYPE ERROR?
	BMI	160$		;YES, ERROR ALREADY SET
.IIF	NE	MTNXM-200, .ERROR ;THE ABOVE WON'T WORK
	MOV	(PC)+,R2	;SET THE GENERAL DATA ERROR
	 .BYTE	DATERR,NOROOM
	BIT	R5,#MTCRE!MTPAE!MTBGL!MTBTE ;WAS IT A GENERAL DATA ERROR?
	BEQ	110$		;NO
	BITB	#MT$TRY,(R1)	;YES, REQUEST RETRYABLE?
	BEQ	150$		;NO
	INCB	MTRTRY(R4)	;YES, BUT HAVE WE RETRIED ENOUGH?
	BGT	150$		;YES, SO NO MORE RETRIES
	BITB	#MT$LCK,(R1)	;CURRENTLY LOCKED INTO MEMORY?
	BEQ	100$		;NO
	MOVB	MTJBNO(R4),R0	;GET JOB NUMBER INVOLVED
	CALLX	UNLOCK		; AND UNLOCK IT DURING BACKSPACE
	CALL	@RELUMR		;RELEASE ASSOCIATED UMR'S
100$:	MOV	MTACUN-1,-(SP)	;STACK UNIT INVOLVED
	MOVB	#IE+12+1,(SP)	;MAKE FUNCTION A BACKSPACE
	MOV	#-1,MTABRC(R3)	; OF 1 RECORD
	MOV	(PC)+,(R1)	;SET FLAGS AND TIMEOUT VALUE
	 .BYTE	MT$INT!MT$BSY!MT$REQ!MT$BAK,7.
	MOV	(SP)+,(R3)	;SO DO IT
	BR	MTART3		; AND EXIT

110$:	CMPB	MTCCMD(R4),#RED.MT ;WAS THE COMMAND READ?
	BNE	130$		;NO
	MOV	(PC)+,R2	;YES, GUESS AT EOF ERROR
	 .BYTE	EOF,MAGRLE
	ASL	R5		;EOF(BIT 14)?
	BMI	120$		;YES
	SWAB	R2		;NO, SO GUESS AT RECORD LENGTH ERROR
	BIT	R5,#MTRLE*2	;RLE?
	BNE	150$		;YES
	BR	140$		;NO, SO NO ERROR AT ALL

120$:	CLR	MTCRET(R4)	;BYTE COUNT=0 IF EOF
	BR	150$

130$:	SWAB	R2		;SWITCH TO END OF TAPE ERROR
	BIT	R5,#MTEOT	;END OF TAPE ERROR?
	BEQ	140$		;NO					;009
	CMPB	MTCCMD(R4),#WRT.MT ;YES, WAS THE COMMAND A WRITE?	;009
	BEQ	150$		;YES					;012
140$:	CLR	R2		;NO, SO NO ERROR AT ALL
150$:	MOVB	R2,MTLCEV(R4)	;SET THE ERROR TYPE
160$:	SWAB	MTCCMD(R4)	;CALL CURRENT LAST COMMAND

GLOBAL	<DATERR,NOROOM,IE,EOF,MAGRLE,RELUMR,MTACUN>			;010

170$:	MOVB	MTJBNO(R4),R0	;GET USER'S JOB NUMBER
	MOV	JOBTBL(R0),R2	;NOW GET USER'S JOB DATA POINTER
	MOV	#FIPSYS,-(SP)	;GUESS THAT FIP CALLED US
	BITB	#MT.OPN,MTOFLG(R4) ;GOOD GUESS?
	BEQ	MTANXT		;YES
	TSTB	MTLCEV(R4)	;DID ANY ERROR OCCUR?
	BEQ	180$		;NO, SO ALL'S WELL			;006
	MOVB	MTLCMD(R4),R3	;WAS LAST COMMAND A REWIND-OFFLINE?	;006
	BEQ	180$		;YES, SO THAT'S OKAY			;006
	CMP	R3,#WRT.MT	;IS IT READ OR WRITE?			;012
	BGT	180$		;NO, SO THAT'S OKAY TOO			;006
	MOV	R4,-(SP)	;Save DDB pointer			;014
	MOV	JDWORK(R2),R4	;Pick up work block pointer		;014
	CALLX	CHKASY		;Was this an asynch request?		;014
	MOV	(SP)+,R4	;Restore DDB pointer			;014
	BCC	180$		;No, not this time			;014
	BISB	#MT.ECK,MTFLAG(R4) ;Yes, so set the flag		;014
180$:	BITB	#MT$LCK,(R1)	;WAS JOB LOCKED INTO MEMORY?
	BEQ	185$		;NO, SO DON'T UNLOCK IT			;004
	CALLX	UNLOCK		;YES, BETTER UNLOCK IT
185$:	MOV	JDWORK(R2),R3	;NOW GET WORK(XRB) BLOCK		;004
	MOV	R3,MTFQB(R4)	;MAKE SURE MTFQB IS CORRECT		;007
	TST	MTACB(R4)	;File structured ANSI processing?	;005
	BEQ	187$		;NOPE					;004
	CMPB	MTLCEV(R4),#EOF	;IS THIS A EOF ERROR?			;004
	BNE	187$		;NOPE					;004
	MOVB	#EOVFQ,FQFUN(R3) ;FIND OUT IF IT'S EOV			;004
	MOVB	R0,FQJOB(R3)	;SET JOB # IN WORK BLOCK		;005
	MOV	R4,FQCLUS(R3)	;AND DDB POINTER			;005
	SUB	#MTDDSP,FQCLUS(R3);UNBIASED, OF COURSE			;005
	CLR	JBSTAT(R0)	;STALL JOB				;004
	MOV	#JSFIP,JBWAIT(R0) ;SAY WAITING FOR FIP			;004
	BR	MTANXT		;BLOW AWAY				;004

187$:	MOV	#RTI3,(SP)	;NO, USER CALLED FOR READ/WRITE		;004
	MOV	R4,-(SP)	;SAVE THE DDB POINTER
	MOV	R0,R4		; THEN SET THE JOB NUMBER TIMES 2
	CALLX	IOFIN4,R5,JS.MT	;SAY MAGTAPE IS DONE
	MOV	(SP)+,R4	;RESTORE DDB POINTER
	CALL	@RELUMR		;RETURN ANY WINDOW WE USED
	MOVB	MTLCEV(R4),JDIOST(R2) ;SET ERROR (IF ANY)
	MOV	MTCRET(R4),XRBC(R3) ; AND SET RETURNED VALUE		;004
MTANXT:	MOV	(R4),MTAQUE	;DEQUEUE TO NEXT REQUEST
190$:	L3QSET	QMTCON		; AND TELL STARTER TO RUN
	CLRB	MTAINF		;SAYING START A REQUEST
	MOV	MTFQB(R4),R4	;PICKUP FIRQB ADDRESS IF ANY
MTARTS:	RETURN			; AND EXIT

.DSABL	LSB

GLOBAL	<JOBTBL,FIPSYS,RTI3,JS.MT,RELUMR,MTAQUE,MTAINF>			;010

.SBTTL	PROCESS A REQUEST PROCESSOR

MTASET:	MOV	#MTAINF,R2	;GET HANDY POINTER
	BITB	#MT$BSY,(R2)	;CONTROL BUSY NOW?
	BNE	MTARTS		;IF SO, THEN QUICKLY EXIT
	BITB	#MT$REQ,(R2)	;ARE WE PROCESSING A REQUEST?
	BNE	50$		;YES, SO DON'T CHECK REWINDERS
10$:	MOV	#MTARWQ,R4	;GET POINTER TO REWINDING QUEUE
	TST	(R4)		;QUEUE EMPTY?
	BEQ	40$		;YES, SO DON'T TRY TO CHECK IT
	TSTB	MTADRW		;IF SOME, THEN SHOULD WE DO THEM?
	BEQ	40$		;NO, NOT QUITE NOW...
	MOVB	MTASCT,R5	;YES, SO HOW MANY TO SKIP?
20$:	MOV	R4,R1		;KEEP A 'PREVIOUS' POINTER
	MOV	(R1),R4		; THEN MOVE TO NEXT ENTRY
	BEQ	40$		;EXIT IF NO MORE IN QUEUE
	DEC	R5		;SKIP ANOTHER?
	BPL	20$		;YES, SO KEEP GOING
	CALL	MTASEL,R5	;NO, SO TRY TO SELECT THIS UNIT
	BCS	30$		;REMOVE FROM QUEUE IF NON-SELECTABLE
	BIT	#MTTUR,(R3)	;ELSE IS IT READY YET?
	BNE	30$		;YES, SO REMOVE FROM QUEUE
	INCB	MTASCT		;NO, SO MUST SKIP ONE MORE IN QUEUE
	BR	20$		;GO GET NEXT

30$:	MOV	(R4),(R1)	;DEQUEUE THIS ENTRY FROM REWIND QUEUE
	CALLX	QUEUER,R5,MTAQUE ; AND THEN QUEUE IT INTO REQUEST QUEUE
	BR	10$		;BUT STILL CHECK OTHERS...

40$:	CLR	MTASCT		;RESET SKIP COUNT TO ZERO

50$:	MOV	MTAQUE,R4	;GET A REQUEST FROM REQUEST QUEUE
	BEQ	MTARTS		;EXIT VIA LEVEL 3 IF NONE
	MOV	(PC)+,(R2)	;INIT REQUEST AND TIME OUT
	 .BYTE	MT$REQ!MT$NIN,7.
	TST	MTIDX(R4)	;DO DEFAULTS NEED SETTING?
	BPL	60$		;NO
.IIF	NE	DDSTAT-100000, .ERROR ;THE ABOVE WON'T WORK
	BIC	#DDSTAT,MTIDX(R4) ;YES, BUT NO LONGER
	BICB	#^C<MT.DEN!MT.PAR>,MTFLAG(R4) ;LEAVE ONLY DEN/PAR
	MOVB	MTFLAG(R4),MTOFLG(R4) ;NOW SET THE DEN/PAR AND
	BISB	MTDUNI(R4),MTOFLG(R4) ; .OR. IN THE UNIT NUMBER
60$:	CLR	MTCRET(R4)	;PRE-CLEAR RETURN VALUE
	CLRB	MTLCEV(R4)	; AND PRE-CLEAR ERROR CODE TO NO ERROR
	MOVB	MTJBNO(R4),R1	;GET JOB OF REQUESTOR
	MOV	JOBTBL(R1),R1	; TO GET THE JOB DATA TO
	CALLX	CLRRSQ		;  ENSURE JOB CAN SWAP OUT
	MOVB	MTCCMD(R4),R1	;GET COMMAND TO PROCESS
	ASL	R1		; TIMES 2 FOR WORD INDEXING
	JMP	@70$(R1)	;GO TO IT...

70$:	.WORD	MTARWU		; 0. IS REWIND THEN OFFLINE
	.WORD	MTARD		; 1. IS READ
	.WORD	MTAWT		; 2. IS WRITE
	.WORD	MTAEOF		; 3. IS WRITE END-OF-FILE
	.WORD	MTARWD		; 4. IS REWIND
	.WORD	MTASBP		; 5. IS SKIP FORWARD (SPACE)
	.WORD	MTABSP		; 6. IS SKIP BACKWARD (BACKSPACE)
	.WORD	MTAPD		; 7. IS SET DENSITY/PARITY
	.WORD	MTAST		; 8. IS RETURN UNIT STATUS
	.WORD	MTACHR		; 9. IS RETURN FILE CHARACTERISTICS
	.WORD	MTACRW		;10. IS REWIND ON CLOSE
	.WORD	MTAEOV		;11. is Write End-Of-Volume on close	;015
	.WORD	MTAECA		;12. is Error Condition Acknowledge	;015
	.WORD	MTAXDN		;13. is Extended Set Density .SPEC call	;013
	.WORD	MTAGBF		;14. IS GET AN ANSI LABEL BUFFER	;004
.ASSUME	GBF.MT EQ 14.							;004

; NOTE THAT:
;	R1 =  COMMAND NUMBER TIMES 2
;	R2 -> MTAINF
;	R4 -> REQUEST (DDB)

GLOBAL	<JOBTBL,MTAQUE,MTARWQ,MTASCT,MTADRW,MTAINF>			;010

.SBTTL	MAGTAPE "GO" ROUTINE

MTAGO:	BIT	#MTRWS,(R3)+	;TAPE CURRENTLY REWINDING?
	BNE	MTADEQ		;YES, SO DELAY THIS OPERATION
	MOVB	R1,MTGFUN	;SET THE FUNCTION
	CLR	R1		;PREVENT CONFUSION
MTGO:	MOV	CSR.MT,R3	;GET THE CSR POINTER
	BISB	#MT$INT!MT$BSY,MTAINF ;INDICATE INTERRUPT COMING AND CTRL BUSY
	MOV	MTGFUN,-(SP)	;PUT UNIT NUMBER & FUNCTION ONTO STACK
;.ASSUME	MTACUN	EQ	MTGFUN+1				;010
	ASH	#4,R1		;HIGH-ORDER ADDRESS TO BITS <5:4>
	BIS	(SP)+,R1	;COMBINE FUNCTION, UNIT, AND ADDRESS
	MOV	R2,4(R3)	;SET LOW ADDRESS
	MOV	MTCNT(R4),R2	;PICK UP +(BYTE COUNT)
	NEG	R2		;MAKE -(BYTE COUNT)
	MOV	R2,MTASRC	;SAVE FOR TIMEOUT CHECKING
	MOV	R2,2(R3)	;SET INTO CONTROL
	BIS	#IE+1,R1	;SET IE AND GO BITS
	MOV	R1,(R3)		;START THE OPERATION
	RETURN			;ALL DONE

.SBTTL	RE-QUEUE REWINDERS TO A HOLDING QUEUE

MTADEQ:	MOV	(R4),MTAQUE	;DEQUEUE FROM REQUEST QUEUE
	CALLX	QUEUER,R5,MTARWQ ; AND REQUEUE INTO THE REWINDING QUEUE
	CLRB	(R2)		;TERMINATE THIS REQUEST
	BR	MTASET		;TRY STARTING ANOTHER REQUEST

GLOBAL	<CSR.MT,IE,MTAQUE,MTARWQ,MTGFUN,MTAINF,MTASRC>			;010

.SBTTL	PROCESS WRITE

MTAWT:	CALL	MTASEE		;SELECT AND DIE IF ERROR
	CMPB	MTRTRY(R4),#MTRTCT ;FIRST TIME THROUGH?
	BEQ	10$		;YES, NEVER AN IRG WRITE
	BITB	MTRTRY(R4),#1	;TIME FOR WRITE WITH EXTENDED IRG?
..MTGP	==	.-2	;**PATCH** FREQUENCY OF IRG WRITES
	BNE	10$		;NO
	MOV	#14,R1		;YES, SO USE WRITE WITH EXTENDED IRG FUNCTION
10$:	BIT	#MTWRL,(R3)	;WRITE LOCKED?
	BNE	MTAWL1		;YES, ERROR

.SBTTL	PROCESS READ

.ENABL	LSB

MTARD:	MOVB	R1,MTGFUN	;SAVE FUNCTION
	BISB	#MT$RW!MT$TRY,(R2) ;READ/WRITE, RETRYABLE
	CALL	MTASEE		;SELECT AND DIE IF ERROR
	BIT	#MTRWS,(R3)+	;DRIVE REWINDING NOW?
	BNE	MTADEQ		;YES, SO PUT REQUEST IN PENDING QUEUE
	BITB	#MT.OPN,MTOFLG(R4) ;IS IT FIP I/O?
	BNE	10$		;NO, USER I/O
	CLR	R1		;YES, ASSUME WE HAVE A BUFFER ADDRESS
	MOV	MTUBUF(R4),R2	;FIP I/O, GET THE BUFFER ADDRESS
	BNE	MTGO		;THERE IS A BUFFER SO USE IT
	JMP	MTAGLB		;ELSE GO GET A BUFFER...

10$:	TSTB	MTOFLG(R4)	;FILE STRUCTURED?
	BPL	20$		;NO
	CMP	R1,#2		;YES, ALSO A READ??
	BNE	20$		;NOT A READ
	BIT	#MTEOF,MTLCST(R4) ;A F/S READ, AT EOF ALREADY?
	BNE	40$		;YES, DON'T LET IT THROUGH
20$:	BISB	#MT$LCK,(R2)	;JOB WILL BE LOCKED INTO MEMORY SOON
	MOVB	MTJBNO(R4),R0	;GET JOB NUMBER TO FIND
	MOV	MTL3QB,R3 	; and L3Q bit in case of a stall 	;010
	MOV	MTUBUF(R4),R5	;SET USER'S VIRTUAL BUFFER ADDRESS
	CALLX	FNDJOB		;TRY TO FIND JOB (BRING INTO MEMORY)
MTAWL1:	BR	MTAWLR		;ERROR IN JOB RESIDENCY, QUIT
	BCS	MTARPC		;NON-RESIDENT, EXIT FOR NOW
	MOVB	R2,R1		;SET EXTENDED MEMORY ADDRESS
	MOV	R3,R2		;SET MEMORY ADDRESS
	MOV	MTCNT(R4),R0	;GET +(BYTE COUNT)
	NEG	R0		;GET -(BYTE COUNT), SET CARRY IF NOT ZERO
	ROR	R0		;GET -(WORD COUNT), ROUNDING TO -INFINITY
	SPLC	5		;;RAISE PRIORITY
	CALL	@GETUMR		;;MAP THE TRANSFER, RETURN ADDR IN R1,R2
	SPL	3		;LOWER PRIORITY AGAIN
	BCC	25$		;SKIP IF WE MADE IT
	MOVB	MTJBNO(R4),R0	;NO, FIRST GET THE JOB NUMBER TIMES TWO
	CALLRX	UNLOCK		;AND LET THE JOB SWAP OUT

25$:	CMPB	MTRTRY(R4),#MTRTCT ;FIRST TIME THROUGH?
	BNE	MTGO		;NO
	INC	MTBCNT(R4)	;YES, COUNT THE BLOCKS
	BR	MTGO		; AND DO IT

40$:	SETERR	EOF,MTLCEV(R4)	;SET THE END-OF-FILE ERROR
	BR	MTASWB		; AND EXIT WITH THAT ERROR


.DSABL	LSB

GLOBAL	<GETUMR,MTGFUN,MTL3QB>						;010

.SBTTL	PROCESS PARITY/DENSITY

MTAPD:	CALL	MTASEE		;SELECT AND DIE IF ERROR
	MOV	MTCNT(R4),R5	;GET SUPPLIED SETTING
	TSTB	MTOFLG(R4)	;FILE STRUCTURED?
	BMI	40$		;REJECT SETTING IF SO
	ASH	#3,R5		;SHIFT INTO CORRECT SPOT
	BCS	10$		;SETTING FOR THE DEFAULTS
	BIT	#MTCH79,(R3)	;7 TRACK OR 9 TRACK TAPE?
	BNE	20$		;IF 7 TRACK, ALL SETTINGS ARE POSSIBLE
10$:	BIS	#MT.DEN,R5	;FORCE 800 BPI FOR 9 TRACK
20$:	BIC	#^C<MT.DEN!MT.PAR>,R5 ;LEAVE ONLY DENSITY/PARITY BITS
	BICB	#MT.DEN!MT.PAR,MTOFLG(R4) ;CLEAR OLD SETTING
	BISB	R5,MTOFLG(R4)	; AND SET NEW
	BCC	30$		;NOT A DEFAULT SETTING
	BICB	#MT.DEN!MT.PAR,MTFLAG(R4) ;ELSE CLEAR OUT OLD DEFAULT
	BISB	R5,MTFLAG(R4)	; THEN SET THE NEW
30$:	CLR	R5		;INDICATE NO ERROR
40$:	MOV	R5,MTCRET(R4)	;SET RETURN VALUE
	BR	MTAEXC		;DOESN'T COUNT AS A COMMAND

.SBTTL	PROCESS BACKSPACE

MTABSP:	CALL	MTASEE		;SELECT AND DIE IF ERROR
	BIT	#MTBOT!MTRWS,(R3) ;ALREADY (OR COMING) THERE?
	BEQ	MTASBP		;IF NOT, DO BACK SPACE		;001
	MOV	MTCNT(R4),MTCRET(R4) ;SET VALUE FOR RETURN	;001
	BR	MTASVT		;QUEUE L3Q FOR DONE PROCESSING	;001

.SBTTL	PROCESS SPACE

.ENABL	LSB

MTASBP:	CALL	MTASEE		;SELECT AND DIE IF ERROR
	CMPB	-(R1),-(R1)	;FORM HARDWARE COMMAND (CHEAPLY)
10$:	JMP	MTAGO		; AND GO

.SBTTL	PROCESS OFFLINE

MTARWU:	CALL	MTASEL,R5	;SELECT UNIT
	BCS	MTASVT		;IF ALREADY OFFLINE, THEN EXIT
	MOV	MTACUN-1,-(SP)	;GET UNIT INVOLVED
	MOVB	#1,(SP)		;FUNCTION IS REWIND/OFF-LINE
	MOV	(SP)+,MTAC-MTAS(R3) ;SO DO IT
	BR	MTASVT		;SAVE STATUS AND EXIT

GLOBAL	<MTACUN>							;010

.SBTTL	PROCESS REWIND

MTARWD:	CALL	MTASEE		;SELECT AND DIE IF ERROR
	BIT	#MTBOT!MTRWS,(R3) ;ALREADY (OR COMING) THERE?
	BNE	MTASVT		;YES, SO JUST EXIT
	MOV	#16,R1		;SET HARDWARE COMMAND
20$:	CLR	MTCNT(R4)	;FORCE COUNT TO BE ZERO
	BR	10$		; AND GO GO

.SBTTL	PROCESS WRITE EOF

MTAEOF:	BISB	#MT$TRY,(R2)	;RETRYABLE
	CALL	MTASEE		;SELECT AND DIE IF ERROR
	BIT	#MTWRL,(R3)	;WRITE LOCKED?
	BEQ	20$		;NO, SO GO
MTAWLR:	SETERR	HNGDEV,MTLCEV(R4) ;SET HUNG DEVICE/WRITE LOCK ERROR
MTASVT:	MOV	(R3),MTLCST(R4)	;SAVE STATUS FOR THIS REQUEST
MTASWB:	SWAB	MTCCMD(R4)	;MAKE CURRENT COMMAND LAST COMMAND
MTAEXC:	L3QSET	QMTDNE		;CALL COMPLETION ROUTINE
	BISB	#MT$BSY!MT$NIN,(R2) ;SAY CONTROL BUSY & NO INTERRUPT
MTARPC:	RETURN			; AND OUT

.DSABL	LSB

.SBTTL	PROCESS STATUS REQUEST

MTAST:	MOV	R4,R1		;COPY DDB POINTER
	CLR	-(R1)		;CLEAR RETURNED VALUE
	CALL	MTASEL,R5	;SELECT UNIT
	BCC	10$		;UNIT IS SELECTABLE
	BIS	#40,(R1)	;NON-SELECTABLE UNIT
10$:	BISB	MTLCMD(R4),(R1)+ ;SET LAST COMMAND IN VALUE
	MOVB	MTOFLG(R4),(R1)	;GET DDB STATUS
	BICB	#^C<MT.DEN!MT.PAR>,(R1) ;LEAVING ONLY DENSITY/PARITY
	MOV	(R3),R5		;GET ACTIVE STATUS VALUE
	BIT	R5,#MTBOT!MTRWS	;BOT (OR COMING THERE)
	BEQ	20$		;NO
	INCB	(R1)		;YES
20$:	BIC	#^C<MTCH79!MTWRL>,R5 ;GET ONLY 7/9 AND WRITE LOCK NOW
	BISB	R5,(R1)		; AND SET THEM
	MOV	MTLCST(R4),R5	;GET LAST COMMAND STATUS NOW
	BIT	R5,#MTEOT	;EOT?
	BEQ	30$		;NO
	BISB	#2,(R1)		;YES
30$:	BIT	R5,#MTILC!MTCRE!MTPAE!MTBGL!MTBTE!MTNXM ;ERROR AT ALL?
	BEQ	40$		;NO
	BISB	#200,(R1)	;YES
40$:	DEC	R1		;BACK TO LOW BYTE OF VALUE NOW
	ASL	R5		;EOF (BIT 14)?
	BPL	50$		;NO
	BIS	#200,(R1)	;YES
50$:	BIT	R5,#MTRLE*2	;RECORD LENGTH ERROR?
	BEQ	MTAEXC		;NO
	BIS	#100,(R1)	;YES
MTAOUT:	BR	MTAEXC		; AND OUT

.SBTTL	PROCESS CHARACTERISTICS REQUEST

MTACHR:	MOV	R4,R1		;COPY DDB POINTER
	CLR	-(R1)		;CLEAR RETURNED VALUE
	MOV	MTACB(R4),R5	;GET ACB ADDRESS
	BEQ	MTAOUT		;NONE, EXIT
	MOV	(R5),(R1)	;ONE, SET CHARACTERISTICS
	BR	MTAOUT		; AND EXIT

.SBTTL	PROCESS REWIND ON CLOSE

MTACRW:	BICB	#MT.NRW,MTFLAG(R4) ;SAY REWIND ON CLOSE
	BR	MTAOUT		; THEN EXIT

.SBTTL	Process write End-Of-Volume on close

MTAEOV:	MOV	MTACB(R4),R1	;Get ACB Pointer			;015
	BEQ	5$		;FOOL, IT MUST BE DOS			;004
	MOV	#^REOV,2(R1)	;SAY EOV LABEL TYPE			;015
	BR	MTAOUT		;Then exit				;015

5$:	SETERR	NOTMTA,MTLCEV(R4) ;Set error				;015
	BR	MTAOUT		;Then exit				;015

.SBTTL	Process Error Condition Acknowledge

MTAECA:	BICB	#MT.ECK,MTFLAG(R4) ;Clear wait for ECA flag regardless	;015
	BR	MTAOUT		;Then exit				;015

.SBTTL	Extended Set Density Function

GLOBAL	<BDNERR,NOTMTA>							;013

MTAXDN:	MOV	MTCNT(R4),R1		;Find out what they want.	;013
	BMI	30$			;Go set density if requested.	;013
10$:	MOV	#800.,R1		;Otherwise, we return 800 BPI.	;013
20$:	MOV	R1,MTCRET(R4)		;Return the value...		;013
	BR	MTAOUT			; ...and go back.		;013

30$:	CALL	MTASEL,R5		;See if we can get to it.	;013
	BCS	40$			;Nope, so go back with error.	;013
	BIT	#MTBOT!MTRWS,(R3)	;Are we at BOT or on the way?	;013
	BEQ	40$			;Nope, let 'em know.		;013
	BIC	#100000,R1		;Get sign bit out of the way.	;013
	CMP	R1,#1.			;Do they want lowest density?	;013
	BEQ	10$			;Yup, go do it.			;013
	CMP	R1,#32767.		;How about highest?		;013
	BEQ	10$			;Same thing.			;013
	CMP	R1,#800.		;Otherwise, it's gotta be 800.	;013
	BEQ	20$			;If so, just go back.		;013
	MOVB	#BDNERR,MTLCEV(R4)	;If not, call it an error.	;013
	BR	10$			;Go back with correct density.	;013

40$:	MOVB	#NOTMTA,MTLCEV(R4)	;Say it's a bad thing they do.	;013
	BR	10$			;Go back, returning 800.	;013

.END

