1	SUB SHOENT							      &
\	MODULE$ = "SHOENT"						      &
\	ON ERROR GOTO 19000						      &
\	SUBEXIT IF CC.FLG%						      &
	!								      &
	!								      &
	!******************************************************************** &
	!								      &
	!	s u b p r o g r a m   t i t l e				      &
	!								      &
	!	  subprogram : SHOENT.B2S				      &
	!	     version : V10.1					      &
	!	        edit : J					      &
	!	   edit date : 27-MAR-92				      &
	!	   author(s) : PRL/DRP/ACT/DBM/SEL			      &
	!								      &
	!******************************************************************** &
	!								      &
	!		  C O P Y R I G H T				      &
	!								      &
	!								      &
	!		      Copyright (C) 1982, 1992 by		      &
	!	Digital Equipment Corporation, Maynard, Mass.		      &
	!								      &
	!								      &
	! This software is furnished under a license and may be used and      &
	! copied  only  in accordance with the terms of such license and      &
	! with the  inclusion  of  the  above  copyright  notice.   This      &
	! software  or  any  other copies thereof may not be provided or      &
	! otherwise made available to any other person.  No title to and      &
	! ownership of the software is hereby transferred.		      &
	!								      &
	! The information in this software is subject to change  without      &
	! notice  and should not be construed as a commitment by Digital      &
	! Equipment Corporation.					      &
	!								      &
	! DIGITAL assumes no responsibility for the use  or  reliability      &
	! of its software on equipment that is not supplied by DIGITAL.	      &
	!								      &
	!******************************************************************** &
	!								      &
	!	s u b p r o g r a m   c a l l   f o r m a t		      &
	!								      &
	!	CALL SHOENT 	(arguments passed via PBSCMN common section)  &
	!								      &
	!	Argument	I/O	Usage				      &
	!	========	===	=====				      &
	!	ERRSTS%		I	Error status			      &
	!				   0 = no error			      &
	!				   n = ERR value		      &
	!								      &
	!******************************************************************** &
	!								      &
	!	m o d i f i c a t i o n   h i s t o r y   l o g		      &
	!								      &
	!								      &
	! VER/ED	EDIT DATE	REASON				      &
	! V9.0-11	07-Feb-85	(PRL) Display server in KBn: format   &
	! V9.0-12	01-Mar-85	(PRL) Fix entry ownership check	      &
	!				(PRL) Don't display log file-spec     &
	!					unless owner of entry	      &
	! V9.0-14	01-Apr-85	(PRL) Call BINASC for page limit      &
	! =================================================================== &
	! V9.1-05	09-Aug-85	(PRL) Fix FN.KBX.TO.KB$ function      &
	! =================================================================== &
	! V9.5-01	10-Jun-87	(DBM) Fix FN.KBX.TO.KB$ function      &
	! =================================================================== &
	! V9.6-07	19-Feb-88	(DBM) Add /[NO]WRAP support	      &
	! =================================================================== &
	! V10.0-01	03-Jul-89	(PRL) Add /STATUS support	      &
	!		07-Jul-89	(PRL) Add status FORMS_WAIT	      &
	!		08-Jul-89	(PRL) Add hooks for /OUTPUT support   &
	!		21-Jul-89	(PRL) Display NOTIFY on /FULL output  &
	!		15-Aug-89	(PRL) Add /BY_JOB_STATUS support      &
	! V10.0-C	15-Sep-89	(PRL) Add code review cleanup	      &
	! V10.0-G	17-Nov-89	(SEL) Print to output channel	      &
	! V10.0-L	02-Jul-90	(PRL) Add ABORTING status keyword     &
	! =================================================================== &
	! V10.1-J	19-Mar-92	(PRL) Support 'xxx*' wildcards	      &
	!******************************************************************** &
	!								      &
	!	c o m m o n   d e c l a r a t i o n s			      &
	!								      &
	!	line #	name	description				      &
	!	======	====	===========				      &
	!	   800	PBSKEY	CUI program constants (%INCLUDE PBSKEY.B2S)   &
	!	   890	CUICMN	CUI common data (%INCLUDE CUICMN.B2S)	      &
	!								      &
	!******************************************************************** &
	!								      &
	!	d i m e n s i o n   d e c l a r a t i o n s		      &
	!								      &
	!	line #	variable		description		      &
	!	======	========		===========		      &
	!	   900	NAM.1%(30)		work table for FN.MATCH.NAME% &
	!		NAM.2%(30)		work table for FN.MATCH.NAME% &
	!								      &
	!******************************************************************** &

700	!	i n c l u d e   r e q u i r e d   M A P s , C O M M O N s     &
	!								      &
	!								      &
	%INCLUDE "SYSTEM:PBSCMN.B2S"		!include QUEUE data section   &
	%INCLUDE "SYSTEM:PBSMAP.B2S"		!include QUEUE map sections   &
	%INCLUDE "SYSTEM:PBSKEY.B2S"		!include CUI keywords	      &
	%INCLUDE "CUI:CUICMN.B2S"		!include CUI data section     &

900	!	D I M E N S I O N   d e c l a r a t i o n s		      &
	!								      &
	!								      &
	DIM	NAM.1%(10),			!table for FN.MATCH.NAME%     &
		NAM.2%(10)			!table for FN.MATCH.NAME%     &

1000	!	m a i n   s u b p r o g r a m   l o g i c		      &
	!								      &
	!								      &
	IF SHO.CHNL% THEN						      &
	   SHO.WIDTH% = 80%			!init to 80 if output to file &
\	ELSE								      &
	   SHO.WIDTH% = KB.WIDTH% 		!init to kb's width if output &
\	END IF					! is to channel 0 (_KB0:)     &
\	QTYP% = 0%				!init to select all types     &
\	ENT.POS% = 0%				!show no entry parameter      &
\	ENT.NO% = 0%				!show no entry number parm    &
						!			      &
\	QUAL.POS% = 38%				!init qualifier start pos     &
						!			      &
\	CALL FET$CQ BY REF (FUL.Q%)		!fetch /FULL qualifier	      &
\	FUL.FLG% = U.PRES%			!set flag if present	      &
						!			      &
\	CALL FET$CQ BY REF (FIL.Q%)		!fetch /FILES qualifier	      &
\	FLS.FLG% = U.PRES%			!set flag if present	      &
						!			      &
\	CALL FET$CQ BY REF (PRT.Q%)		!fetch /PRINT qualifier	      &
\	IF U.PRES% THEN				!if present,		      &
		QTYP% = PRT.TYP%		!  select print queues only   &
\	END IF					!end if			      &
						!			      &
\	CALL FET$CQ BY REF (BAT.Q%)		!fetch /BATCH qualifier	      &
\	IF U.PRES% THEN				!if present,		      &
		QTYP% = BAT.TYP%		!  select batch queues only   &
\	END IF					!end if			      &
						!			      &
\	STS.MSK% = 0%				!show no select by status     &
						!			      &
\	CALL FET$CQ BY REF (STS.Q%)		!fetch /STATUS qualifier      &
\	CALL FET$CQ BY REF (BYJ.Q%)		!fetch /BY_JOB_STATUS qual    &
		UNLESS U.PRES%			!  unless /STATUS found	      &
\	IF U.PRES% THEN				!if either present,	      &
		GOSUB 8000			!  go build status mask	      &
\	END IF					!end if			      &
						!			      &
\	CALL FET$P BY REF (ENT.T%)		!fetch entry parameter	      &
\	IF U.PRES% THEN				!if present,		      &
		ENT.POS% = U.POS%		!  save position in cmd line  &
\		ENTRY$ = SEG$(U.STR$,1%,U.LEN%)	!  save entry string	      &
\		ENT.NO% = FN.ENTRY% (ENTRY$)	!  set/clear entry-no. flag   &
\	END IF					!end if			      &
						!			      &
\	IF ENT.NO% THEN				!if entry-number parm,	      &
		GOSUB 10000			!  display via entry-number   &
	ELSE	GOSUB 11000			!else display via entry-spec  &
\	END IF					!end if			      &
						!			      &
\	SUBEXIT					!exit			      &

8000	!	b u i l d   s t a t u s   s e l e c t i o n   m a s k	      &
	!								      &
	!								      &
\	CALL FET$KA BY REF (ABT.K%)		!fetch ABORTING keyword arg   &
\	STS.MSK% = STS.MSK% OR (2% ^ JS.ABT%)	!set ABORTING bit in mask     &
		IF U.PRES%			!  if arg present	      &
						!			      &
\	CALL FET$KA BY REF (AFT.K%)		!fetch AFTER keyword arg      &
\	CALL FET$KA BY REF (TIM.K%)		!fetch TIMED_RELEASE arg      &
		UNLESS U.PRES%			!  unless AFTER found	      &
\	STS.MSK% = STS.MSK% OR (2% ^ JS.AFT%)	!set AFTER bit in mask	      &
		IF U.PRES%			!  if either arg present      &
						!			      &
\	CALL FET$KA BY REF (FRM.K%)		!fetch FORMS_WAIT keyword arg &
\	STS.MSK% = STS.MSK% OR (2% ^ JS.FRM%)	!set FORMS_WAIT bit in mask   &
		IF U.PRES%			!  if arg present	      &
						!			      &
\	CALL FET$KA BY REF (HLD.K%)		!fetch HOLD[ING] keyword arg  &
\	STS.MSK% = STS.MSK% OR (2% ^ JS.NRD%)	!set NOT RDY bit in mask      &
		IF U.PRES%			!  if arg present	      &
						!			      &
\	CALL FET$KA BY REF (RDY.K%)		!fetch READY keyword arg      &
\	CALL FET$KA BY REF (PND.K%)		!fetch PENDING keyword arg    &
		UNLESS U.PRES%			!  unless READY found	      &
\	STS.MSK% = STS.MSK% OR (2% ^ JS.RDY%)	!set READY bit in mask	      &
		IF U.PRES%			!  if either arg present      &
						!			      &
\	CALL FET$KA BY REF (STR.K%)		!fetch STARTED keyword arg    &
\	CALL FET$KA BY REF (EXE.K%)		!fetch EXECUTING keyword arg  &
		UNLESS U.PRES%			!  unless STARTED found	      &
\	STS.MSK% = STS.MSK% OR (2% ^ JS.STR%)	!set STARTED bit in mask      &
		IF U.PRES%			!  if either arg present      &
						!			      &
\	RETURN					!exit			      &

10000	!	d i s p l a y   e n t r y   v i a   n u m b e r		      &
	!								      &
	!								      &
	RETURN IF CC.FLG%			!exit if CTRL/C		      &
						!			      &
\	ES.PPN% = -1%				!select any PPN		      &
\	ES.NAM$ = ""				!select any name	      &
\	ENT.SEQ% = FN.UNSIGNED%(ENT.NO%)	!select entry number	      &
						!			      &
\	ENT.FLG% = FALSE%			!clear entry-selected flag    &
\	CUR.TYP% = -1%				!show no current type	      &
\	Z% = FN.GET.ENTRY%(3%)			!get entry record	      &
						!			      &
\	GOSUB 12000 UNLESS ERRSTS%		!display entry unless error   &
						!			      &
\	IF ERRSTS% THEN				!if any errors,		      &
		SELECT QTYP%			!  select via queue type:     &
\		CASE = PRT.TYP%			!  case = print entries,      &
\			Z$ = "print "		!    build print text	      &
\		CASE = BAT.TYP%			!  case = batch entries,      &
\			Z$ = "batch "		!    build print text	      &
\		CASE ELSE			!  case else,		      &
\			Z$ = ""			!    build null text	      &
\		END SELECT			!  end select		      &
						!			      &
\		IF STS.MSK% THEN		!  if select by status,	      &
			Z1$ = " with specified status"			      &
						!    build select text	      &
		ELSE	Z1$ = ""		!  else build null text	      &
\		END IF				!  end if		      &
						!			      &
\		U.POS% = 0%			!  disable repainting cmd     &
\		CALL DISPLY ("%No "+Z$+"entry "+ENTRY$+Z1$+" found")	      &
						!  display error message      &
\	END IF					!end if			      &
						!			      &
\	RETURN					!exit			      &

11000	!	d i s p l a y   e n t r y   v i a   e n t r y - s p e c	      &
	!								      &
	!								      &
	ENT.SEQ% = 0%				!no select via entry seq no.  &
\	ES.QUE$ = "*"				!select all queues	      &
\	ES.NAM$ = "*"				!select all entries	      &
						!			      &
\	CALL FET$CQ BY REF (ALL.Q%)		!fetch /ALL qualifier	      &
\	ALL.FLG% = U.PRES%			!set flag if present	      &
\	IF ALL.FLG% THEN			!if /ALL specified,	      &
		ES.PPN% = -1%			!  select all PPNs	      &
	ELSE	ES.PPN% = PPN%			!else select user's entries   &
\	END IF					!end if			      &
						!			      &
\	ES.SPEC$ = ES.QUE$ + ":" + FN.PPN$(ES.PPN%,FALSE%) + ES.NAM$	      &
						!build default entry-spec     &
						!			      &
\	IF ENT.POS% THEN			!if entry spec present,	      &
		ES.SPEC$ = ENTRY$		!  save entry-spec string     &
\		ES.FLG%% = 1%+2%+4%+8%+16%+32%+64%			      &
						!  set entry-spec options:    &
						!    1  = allow null que name &
						!    2  = allow wild que name &
						!    4  = allow null PPN      &
						!    8  = allow wild PPN      &
						!    16 = allow null ent name &
						!    32 = allow wild ent name &
						!    64 = allow not own PPN   &
						!			      &
\		QUE.POS%,OWN.POS%,NAM.POS% = 0%	!  init entry-spec pointers   &
\		U.POS% = ENT.POS%		!  point to entry spec	      &
\		CALL ENTSPC (ES.SPEC$,ES.FLG%,ES.QUE$,ES.PPN%,ES.NAM$)	      &
						!  parse entry-spec	      &
\		SUBEXIT IF ERRSTS% OR CC.FLG%	!  exit if error or CTRL/C    &
\	END IF					!end if			      &
						!			      &
\	ENT.FLG% = FALSE%			!clear entry-selected flag    &
\	CUR.TYP% = -1%				!show no current entry type   &
\	Z% = FN.GET.ENTRY%(3%)			!get 1st entry rec	      &
\	UNTIL ERRSTS% OR CC.FLG%		!until no entries or CTRL/C:  &
\		GOSUB 12000			!  display this entry record  &
\		Z% = FN.GET.ENTRY%(0%)		!  get next entry	      &
\	NEXT					!next (entry record)	      &
\	SUBEXIT IF CC.FLG%			!exit if CTRL/C		      &
						!			      &
\	IF ENT.FLG% THEN			!if any entries selected,     &
		ERRSTS% = 0%			!  return success status      &
	ELSE	ERRSTS% = ERR.NOTFND%		!else return NOTFND error     &
\		SELECT QTYP%			!  select via queue type:     &
\		CASE = PRT.TYP%			!    case = print entries,    &
\			Z$ = "print "		!      build 'print' text     &
\		CASE = BAT.TYP%			!    case = batch entries,    &
\			Z$ = "batch "		!      build 'batch' text     &
\		CASE ELSE			!    case else,		      &
\			Z$ = ""			!      build null text	      &
\		END SELECT			!  end select		      &
						!			      &
\		IF STS.MSK% THEN		!  if select by status,	      &
			Z1$ = " with specified status"			      &
						!    build select text	      &
		ELSE	Z1$ = ""		!  else build null text	      &
\		END IF				!  end if		      &
						!			      &
\		U.POS% = 0%			!  disable repainting cmd     &
\		CALL DISPLY ("%No "+Z$+"entry "+ES.SPEC$+Z1$+" found")	      &
						!  display error msg	      &
\	END IF					!end if			      &
						!			      &
\	RETURN					!exit			      &

12000	!	d i s p l a y   c u r r e n t   e n t r y		      &
	!								      &
	!								      &
	RETURN IF CC.FLG%			!exit if CTRL/C		      &
\	PRINT #SHO.CHNL% IF CCPOS(SHO.CHNL%)	!ensure left margin	      &
						!			      &
\	IF NOT ENT.FLG% THEN			!if no entries displayed yet, &
		GOSUB 13000			!  gosub to display heading   &
	ELSE	PRINT #SHO.CHNL%		!else skip a line	      &
			IF FUL.FLG%		!	if /FULL	      &
			   OR FLS.FLG%		!	or /FILES	      &
\	END IF					!end if			      &
						!			      &
\	PRINT #SHO.CHNL%,			!display:		      &
		FN.PAD$(NUM1$(FN.UNSIGNED(PKT.SEQ%)),+5%); " ";		      &
						!	sequence no.	      &
		FN.PAD$(FN.ORDINAL$(ENT.POS),+6%); "  ";		      &
						!	ordinal position      &
						!			      &
\	SELECT QUE.TYP%				!select via entry type:	      &
\	CASE = PRT.TYP%				!case = print entry,	      &
\		Z$ = "Print"			!  use 'print' text	      &
\	CASE = BAT.TYP%				!case = batch entry,	      &
\		Z$ = "Batch"			!  use 'batch' text	      &
\	CASE ELSE				!case else,		      &
\		Z$ = "?????"			!  use '?????' text	      &
\	END SELECT				!end select		      &
						!			      &
\	PRINT #SHO.CHNL%,			!display:		      &
		FN.PAD$(Z$,-5%); "  ";		!	entry type	      &
		FN.PAD$(ENT.QUE$,-9%); "  "; 	!	queue name	      &
		FN.PPN$(PKT.JB.PPN%,TRUE%); "  ";			      &
						!	entry's PPN	      &
		FN.PAD$(ENT.NAM$,-9%); "  ";	!	entry's name	      &
		FN.PAD$(FN.STATUS$(PKT.STS%),-10%); "  ";		      &
						!	entry's status	      &
		FN.PAD$(NUM1$(ASCII(PKT.JB.PRI$)),+3%);			      &
						!	entry's priority      &
						!			      &
\	PRINT #SHO.CHNL%, "  "; SEG$(PKT.JB.FRM$,1%,ASCII(PKT.JB.FML$));      &
						!display form-name	      &
		IF QUE.TYP% = PRT.TYP%		!  if print entry	      &
						!			      &
\	PRINT #SHO.CHNL%			!skip to next line	      &
						!			      &
\	GOSUB 12100				!display full entry data      &
		IF FUL.FLG%			!  if /FULL specified	      &
						!			      &
\	GOSUB 12400				!display file-specs	      &
		IF FN.OWN.ENTRY%(PKT.JB.PPN%)	!  if owner rights to entry   &
			IF FUL.FLG% OR FLS.FLG%	!    if /FULL or /FILES	      &
\						!			      &
\	ENT.FLG% = TRUE%			!show we've seen an entry     &
\	RETURN					!exit			      &

12100	!	d i s p l a y   f u l l   e n t r y   d a t a		      &
	!								      &
	!								      &
	RETURN IF CC.FLG%			!exit if CTRL/C		      &
						!			      &
\	PRINT #SHO.CHNL% IF CCPOS(SHO.CHNL%)	!ensure left margin	      &
						!			      &
\	PRINT #SHO.CHNL%, TAB(6%); "Entered ";				      &
		FN.DATE.TIME$(SWAP%(PKT.EDA%),SWAP%(PKT.ETI%));		      &
						!display entry date/time      &
						!			      &
\	IF (PKT.FLG% AND JBF.NTF%) <> 0% THEN	!if /NOTIFY specified,	      &
		PRINT #SHO.CHNL%, TAB(QUAL.POS%); "/NOTIFY";		      &
						!  display /NOTIFY	      &
	ELSE	IF DEBUG% THEN			!else if DEBUG mode,	      &
			PRINT #SHO.CHNL%, TAB(QUAL.POS%); "/NONOTIFY";	      &
						!    display /NONOTIFY	      &
\		END IF				!  end if		      &
\	END IF					!end if			      &
\	PRINT #SHO.CHNL%			!skip to new line	      &
						!			      &
\	PRINT #SHO.CHNL%, TAB(6%); "Start after ";			      &
			FN.DATE.TIME$(PKT.JB.ADA%,PKT.JB.ATI%)		      &
						!display after date/time      &
		IF PKT.JB.ADA%			!  if any /AFTER date	      &
						!			      &
\	PRINT #SHO.CHNL%, TAB(6%); "Last modified ";			      &
			FN.DATE.TIME$(PKT.JB.MDA%,PKT.JB.MTI%)		      &
						!display modified date/time   &
		IF PKT.JB.MDA%			!  if any modified date	      &
						!			      &
\	IF PKT.JB.SDA% THEN			!if any start date,	      &
		SELECT QUE.TYP%			!  select via queue type:     &
\		CASE = PRT.TYP%			!  case = print entry,	      &
\			Z$ = "print "		!    use 'print'	      &
\		CASE = BAT.TYP%			!  case = batch entry,	      &
\			Z$ = "batch "		!    use 'batch'	      &
\		CASE ELSE			!  case else,		      &
\			Z$ = ""			!    null server type	      &
\		END SELECT			!  end select		      &
						!			      &
\		Z1$ = FN.KBX.TO.KB$(SEG$(PKT.JB.DEV$,1%,ASCII(PKT.JB.DVL$)))  &
						!  build server name	      &
\		PRINT #SHO.CHNL%, TAB(6%); "Started ";			      &
			FN.DATE.TIME$(PKT.JB.SDA%,PKT.JB.STI%); " on ";	      &
			Z$; "server "; Z1$	!  display start info	      &
\	END IF					!end if			      &
						!			      &
\	IF PKT.JB.FDA% THEN			!if any finish date,	      &
\		SELECT PKT.STS%			!  select via status word:    &
\		CASE = JS.ABT%			!  case = aborting,	      &
\			Z$ = "Aborting "	!    show aborting status     &
\		CASE = JS.SUC%			!  case = success,	      &
\			Z$ = "Succeeded "	!    show success status      &
\		CASE = JS.FAI%			!  case = failure,	      &
\			Z$ = "Failed "		!    show failed status	      &
\		CASE = JS.ABO%			!  case = aborted,	      &
\			Z$ = "Aborted "		!    show aborted status      &
\		CASE = JS.KIL%			!  case = deleted,	      &
\			Z$ = "Deleted "		!    show deleted status      &
\		CASE ELSE			!  case else,		      &
\			Z$ = "?????? "		!    show unknown status      &
\		END SELECT			!  end select		      &
						!			      &
\		PRINT #SHO.CHNL%, TAB(6%); Z$;				      &
			FN.DATE.TIME$(PKT.JB.FDA%,PKT.JB.FTI%)		      &
						!  display finished date/time &
\	END IF					!end if			      &
						!			      &
\	SELECT QUE.TYP%				!select via queue type	      &
\	CASE = PRT.TYP%				!case = print entry,	      &
\		GOSUB 12200			!  display print fields	      &
\	CASE = BAT.TYP%				!case = batch entry,	      &
\		GOSUB 12300			!  display batch fields	      &
\	END SELECT				!end select		      &
						!			      &
\	RETURN					!exit			      &

12200	!	d i s p l a y   p r i n t   f i e l d s			      &
	!								      &
	!								      &
	RETURN IF CC.FLG%			!exit if CTRL/C		      &
\	PRINT #SHO.CHNL% IF CCPOS(SHO.CHNL%)	!ensure left margin	      &
						!			      &
\	PRINT #SHO.CHNL%, TAB(6%); "Job count "; NUM1$(PKT.JB.COP%);	      &
						!display job count	      &
\	IF (PKT.JB.PGL% = -1%) AND (PKT.JB.PGM% = -1%) THEN		      &
						!if page limit = -1,	      &
		Z0$ = "UNLIMITED"		!  use "unlimited" value      &
	ELSE	U.LEN% = 255%			!else set max buffer length   &
\		CALL BINASC BY REF (PKT.JB.PGL%,"UL",U.STR$,U.LEN%)	      &
						!else call convert routine    &
\		Z0$ = SEG$(U.STR$,1%,U.LEN%)	!  and save numeric string    &
\	END IF					!end if			      &
						!			      &
\	PRINT #SHO.CHNL%, ", Page limit "; Z0$	!display the page limit	      &
						!			      &
\	RETURN					!exit			      &

12300	!	d i s p l a y   b a t c h   f i e l d s			      &
	!								      &
	!								      &
	RETURN IF CC.FLG%			!exit if CTRL/C		      &
\	PRINT #SHO.CHNL% IF CCPOS(SHO.CHNL%)	!ensure left margin	      &
						!			      &
\	PRINT #SHO.CHNL%, TAB(6%);		!indent for CPU/time limits   &
\	IF PKT.JB.CPU% = -1% THEN		!if unlimited,		      &
		Z$ = "UNLIMITED"		!  use 'unlimited'	      &
	ELSE	Z$ = NUM1$(FN.UNSIGNED(PKT.JB.CPU%))			      &
						!else use actual value	      &
\	END IF					!end if			      &
\	PRINT #SHO.CHNL%, "CPU limit "; Z$;	!display CPU limit	      &
						!			      &
\	IF PKT.JB.TIM% = -1% THEN		!if unlimited,		      &
		Z$ = "UNLIMITED"		!  use 'unlimited'	      &
	ELSE	Z$ = NUM1$(FN.UNSIGNED(PKT.JB.TIM%))			      &
						!else use actual value	      &
\	END IF					!end if			      &
\	PRINT #SHO.CHNL%, ", Time limit "; Z$	!display time limit	      &
						!			      &
\	PRINT #SHO.CHNL%, TAB(6%);		!indent for log file text     &
\	IF PKT.JB.COP% THEN			!if any logfile block,	      &
		MOVE FROM #PBS.CHNL%,		!  get from the queue file    &
			FILL$ = PKT.JB.COP%,	!    skip to start of block   &
			LG.FLG%,		!    log file flag word	      &
			LG.QNL$ = 1%, 		!    length of queue-name     &
			LG.QNM$ = 9%,		!    queue-name		      &
			LG.SPL$	= 1%,		!    length of log file-spec  &
			LG.SPC$ = ASCII(LG.SPL$)!    log file-spec	      &
						!			      &
\		PRINT #SHO.CHNL%, "Log file";	!  print log_file header      &
\		PRINT #SHO.CHNL%, " "; LG.SPC$;	!  display log file name      &
			IF FN.OWN.ENTRY%(PKT.JB.PPN%)			      &
						!    if owner rights to entry &
\		LG.QNL% = ASCII(LG.QNL$)	!  get length of queue name   &
\		IF LG.QNL% = 0% THEN		!  if no log-file queue name, &
			PRINT #SHO.CHNL%, ", No log queue";		      &
						!    display no queue msg     &
		ELSE	PRINT #SHO.CHNL%, ", Log queue ";		      &
				SEG$(LG.QNM$,1%,LG.QNL%);		      &
						!  else display queue name    &
						!			      &
\			IF (LG.FLG% AND FF.DEL%) THEN			      &
						!    if log delete flag set,  &
				Z$ = "L"	!      null NO prefix	      &
			ELSE	Z$ = "No l"	!    else set NO text	      &
\			END IF			!    end if		      &
\			PRINT #SHO.CHNL%, ", "; Z$; "og delete"		      &
						!    display log delete msg   &
\		END IF				!end if			      &
						!			      &
	ELSE	PRINT #SHO.CHNL%, "No log file"	!else display no log msg      &
\	END IF					!end if			      &
						!			      &
\	PRINT #SHO.CHNL% IF CCPOS(SHO.CHNL%)	!ensure at left margin	      &
\	PRINT #SHO.CHNL%, TAB(6%);		!indent for parameters	      &
\	IF PKT.JB.PAR% = 0% THEN		!if no parameters,	      &
		PRINT #SHO.CHNL%, "No parameters"			      &
						! display no parameters text  &
	ELSE	MOVE FROM #PBS.CHNL%,		!  get from the queue file    &
			FILL$ = PKT.JB.PAR%,	!    skip to parameters block &
			PB.SPL$ = 1%,		!    length of parm string    &
			PB.SPC$ = ASCII(PB.SPL$)!    parm string	      &
\		PRINT #SHO.CHNL%, "Parameters: "; PB.SPC$		      &
						!  display parameters	      &
\	END IF					!end if			      &
						!			      &
\	RETURN					!exit			      &

12400	!	d i s p l a y   f i l e - s p e c s			      &
	!								      &
	!								      &
	RETURN IF CC.FLG%			!exit if CTRL/C		      &
						!			      &
\	FIL.OFF% = PKT.JB.FIL%			!init offset to 1st file      &
\	FIL.SEQ% = 0%				!init file seq no.	      &
\	WHILE FIL.OFF% > 0%			!do while more files:	      &
\		FIL.SEQ% = FIL.SEQ% + 1%	!  incr sequence no.	      &
\		MOVE FROM #PBS.CHNL%,		!  move file data fields:     &
			FILL$ = FIL.OFF%,	!    offest to 1st field      &
			FIL.OFF%,		!    offset to next file      &
			FIL.FLG%,		!    file flag		      &
			FIL.COP%,		!    file copies	      &
			FIL.LEN$ = 1%,		!    file-name length	      &
			FIL.SPC$ = ASCII(FIL.LEN$)			      &
						!    file-spec		      &
\		GOSUB 12500			!  gosub to display it	      &
\		RETURN IF CC.FLG%		!  exit if CTRL/C	      &
\	NEXT					!for all files		      &
						!			      &
\	RETURN					!exit			      &

12500	!	d i s p l a y   c u r r e n t   f i l e   s p e c	      &
	!								      &
	!								      &
	RETURN IF CC.FLG%			!exit if CTRL/C		      &
\	PRINT #SHO.CHNL%, TAB(8%); FN.PAD$(NUM1$(FIL.SEQ%),+2%); "> ";	      &
				   FN.FILE.SPEC$(FIL.SPC$);		      &
						!print sq no. & file-spec     &
\	QL.POS% = QUAL.POS%			!init column for qualifiers   &
\	QL.POS% = CCPOS(SHO.CHNL%) + 1%		!change column		      &
		IF CCPOS(SHO.CHNL%) >= QL.POS%	!  if long filespec	      &
\	GOSUB 12600				!print any file qualifiers    &
\	RETURN					!exit			      &

12600	!	d i s p l a y   f i l e   q u a l i f i e r s		      &
	!								      &
	!								      &
	RETURN IF CC.FLG%			!exit if CTRL/C		      &
\	SELECT QUE.TYP%				!select via queue type:	      &
\	CASE = PRT.TYP%				!case = print entry,	      &
\		PRINT #SHO.CHNL%, TAB(QL.POS%); "/COPIES="; NUM1$(FIL.COP%);  &
						!  display copies qualifier   &
			IF ((FIL.COP% <> DFL.FCP%)			      &
						!    if not same as default   &
			    OR DEBUG%)		!    or degugger on	      &
\		Z% = FN.FILE.QUAL%("BINARY",FF.BIN%,DFL.BIN%)		      &
						!  display /BINARY qualifier  &
\		Z% = FN.FILE.QUAL%("CONVERT",FF.CNV%,DFL.CNV%)		      &
						!  display /CONVERT qualifier &
\		Z% = FN.FILE.QUAL%("DELETE",FF.DEL%,DFL.DEL%)		      &
						!  display /DELETE qualifier  &
\		Z% = FN.FILE.QUAL%("FEED",FF.FEE%,DFL.FEE%)		      &
						!  display /FEED qualifier    &
\		Z% = FN.FILE.QUAL%("FLAG_PAGES",FF.FPG%,DFL.FPG%)	      &
						!  display /FLAG_PAGES qual   &
\		Z% = FN.FILE.QUAL%("TRUNCATE",FF.TRN%,DFL.TRN%)		      &
						!  display /TRUNCATE qual     &
\		Z% = FN.FILE.QUAL%("WRAP",FF.RAP%,DFL.RAP%)		      &
						!  display /WRAP qual	      &
						!			      &
\	CASE = BAT.TYP%				!case = batch entry,	      &
\		Z% = FN.FILE.QUAL%("DELETE",FF.DEL%,DFL.DEL%)		      &
						!  display /DELETE qualifier  &
						!			      &
\	END SELECT				!end select		      &
						!			      &
\	PRINT #SHO.CHNL% IF CCPOS(SHO.CHNL%)	!ensure left margin	      &
\	RETURN					!exit			      &

13000	!	d i s p l a y   c o l u m n   h e a d i n g s		      &
	!								      &
	!								      &
	! This routine displays the SHOW ENTRY column headings.  It should    &
	! only be called when an initial entry has been selected for display. &
	! The ENT.FLG% (entry-displayed flag) can be tested to determine when &
	! to call this routine (only when ENT.FLG% = 0%, meaning no entries   &
	! have been displayed yet).					      &
	!								      &
	! This routine conditionally adds the "Forms" column heading only if  &
	! the entry selected for display is a PRINT entry.  This makes sense  &
	! as long as PRINT entries are always displayed before BATCH entries. &
	!								      &
	!								      &
	PRINT #SHO.CHNL%, "Entry    Pos  Type   Queue      Owner      Name";  &
				"       Status      Pri";		      &
						!print generic col headings   &
\	PRINT #SHO.CHNL%, "  Forms";		!append forms col heading     &
		IF CUR.TYP% = PRT.TYP%		!  if displaying PRINT entry  &
\	PRINT #SHO.CHNL%			!start new line		      &
	!								      &
\	PRINT #SHO.CHNL%, "-----    ---  ----   -----      -----      ----";  &
				"       ------      ---";		      &
						!underline generic headings   &
\	PRINT #SHO.CHNL%, "  -----";		!append forms col underline   &
		IF CUR.TYP% = PRT.TYP%		!  if displaying PRINT entry  &
\	PRINT #SHO.CHNL%			!start new line		      &
	!								      &
\	RETURN					!exit			      &

15000	!	f n . g e t . e n t r y %				      &
	!								      &
	!								      &
	!inputs:	GET.MODE%	-	initial GET mode to use	      &
	!		QTYP%		-	entry's queue type to select  &
	!					  (0 -> don't sel by que typ) &
	!		ES.NAM$		-	entry's name to select	      &
	!					  ("" -> don't sel by name)   &
	!		ES.PPN%		-	entry's PPN to select	      &
	!					  (0 -> don't sel by PPN)     &
	!		ENT.SEQ%	-	entry's seq no. to select     &
	!					  (0 -> don't sel by seq no.) &
	!		STS.MSK%	-	select by status mask	      &
	!					  (0 -> don't sel by status)  &
	!		ENT.POS		-	last entry's relative pos     &
	!								      &
	!outputs:	FN.GET.ENTRY%	-	select-entry status:	      &
	!					   TRUE% - entry selected     &
	!					  FALSE% - no entry selected  &
	!		ERRSTS%		-	error status:		      &
	!					  0 = no error (rec found)    &
	!					  n = error (rec not found)   &
	!		ENT.POS		-	entry's relative position     &
	!		ENT.QUE$	-	entry's queue name	      &
	!		ENT.NAM$	-	entry's name		      &
	!								      &
	!uses:		Z$		-	local work string	      &
	!								      &
	!notes:								      &
	!								      &
	! This function is called to return the next entry definition  record &
	! (EDR),  based  on  the selection values specified above.  The value &
	! GET.MODE% (0-3) is used by this function in  its  initial  call  to &
	! GETREC, to allow the caller to decide how to get the initial entry  &
	! record.  Mode 0 (GET NEXT) should be specified if at least one  EDR &
	! has  been  read and no other non-EDRs have been read since the last &
	! call; otherwise, mode 1 (GET EQ) should be specified, with QUE.TYP% &
	! set accordingly.  Once the  initial GET is performed, the record is &
	! tested  to ensure that it is actually a EDR;  if  not  the function &
	! exits with status ERR.NOTFND%. Otherwise, a check is made to see if &
	! the EDR should  be selected, based on the selection values.  If the &
	! EDR  is  selected,  the  function  exits  with  success status (0); &
	! otherwise, a GET NEXT is performed and the process repeats.	      &
	!								      &
	!								      &
	DEF FN.GET.ENTRY% (GET.MODE%)					      &
\	FNEXIT IF CC.FLG%			!exit if CTRL/C		      &
\	Z$ = CHR$(QTYP%) + STRING$(5%,0%)	!build search key	      &
		IF GET.MODE%			!  if non-zero GET mode	      &
\	FN.GET.ENTRY% = FALSE%			!set fn value = rec not found &

15010	CALL GETREC (GET.MODE%,1%,Z$)		!get initial entry record     &
\	FNEXIT IF CC.FLG%			!exit if CTRL/C		      &
\	QUE.TYP% = ASCII(PKT.QUE$)		!get queue type		      &
\	ENT.POS = 0.				!zero entry's rel position    &
		IF QUE.TYP% <> CUR.TYP%		!  if different queue type    &
\	ENT.POS = ENT.POS + 1.			!incr queue pos counter	      &
\	CUR.TYP% = QUE.TYP%			!show this type as current    &
\	ERRSTS% = ERR.NOTFND%			!return not-found error	      &
		IF QUE.TYP% AND (NOT 15%)	!  if not a entry record      &
			UNLESS ERRSTS%		!    unless pending error     &
\	FNEXIT IF ERRSTS%			!exit if any error	      &
						!			      &
\	GET.MODE% = 0%				!use GET NEXT mode now	      &
						!			      &
\	GOTO 15010				!skip this entry	      &
		IF PKT.SEQ% <> ENT.SEQ%		!  if seq nos. don't match    &
			IF ENT.SEQ%		!    if any seq no. to match  &
						!			      &
\	GOTO 15010				!skip this entry	      &
		IF QTYP% <> QUE.TYP%		!  if different types	      &
			IF QTYP%		!    if single queue type     &
						!			      &
\	GOTO 15010				!skip this entry	      &
		UNLESS FN.MATCH.PPN%(PKT.JB.PPN%,ES.PPN%)		      &
						!  unless PPN's match	      &
\	ENT.QUE$ = SEG$(PKT.QNM$,1%,ASCII(PKT.QNL$))			      &
						!return queue name	      &
\	GOTO 15010				!skip this entry	      &
		UNLESS FN.MATCH.NAME%(ENT.QUE$,ES.QUE$)			      &
						!  unless queue-names match   &
			IF LEN(ES.QUE$)		!    if select by queue-name  &
						!			      &
\	ENT.NAM$ = SEG$(PKT.JB.NAM$,1%,ASCII(PKT.JB.NML$))		      &
						!return entry name	      &
\	GOTO 15010				!skip this entry	      &
		UNLESS FN.MATCH.NAME%(ENT.NAM$,ES.NAM$)			      &
						!  unless entry-names match   &
			IF LEN(ES.NAM$)		!    if select by entry-name  &
						!			      &
\	GOTO 15010				!skip this entry	      &
		IF ((2% ^ PKT.STS%) AND STS.MSK%) = 0%			      &
						!  if no match on status      &
			IF STS.MSK%		!    if select by status      &
						!			      &
\	FN.GET.ENTRY% = TRUE%			!set fn value = rec found     &
\	FNEND					!end FN.GET.ENTRY% function   &

15100	!	f n . m a t c h . p p n % ( PPN.1% , PPN.2% )		      &
	!								      &
	!								      &
	!inputs:	PPN.1%		-	queue rec PPN		      &
	!		PPN.2%		-	PPN word to match	      &
	!					  (255 = wildcard)	      &
	!								      &
	!outputs:	FN.MATCH.PPN%	-	returned match status:	      &
	!					  TRUE% = PPN's match	      &
	!					 FALSE% = PPN's don't match   &
	!								      &
	!uses:		Z0%		-	loop index		      &
	!		Z1%		-	1st PPN's byte value	      &
	!		Z2%		-	2nd PPN's byte value	      &
	!								      &
	!								      &
	DEF FN.MATCH.PPN% (PPN.1%,PPN.2%)				      &
\	FN.MATCH.PPN% = FALSE%			!init fn value as no match    &
\	FOR Z0%= 1% TO 2%			!do for each PPN byte:	      &
\		Z1% = PPN.1% AND 255%		!  get lo byte of 1st ppn     &
\		Z2% = PPN.2% AND 255%		!  get lo byte of 2nd ppn     &
\		FNEXIT				!  exit (no match)	      &
			IF Z1% <> Z2% 		!    if bytes don't match,    &
				IF Z2% <> 255%	!      if byte not wild	      &
\		PPN.1% = SWAP%(PPN.1%)		!  swap 1st ppn bytes	      &
\		PPN.2% = SWAP%(PPN.2%)		!  swap 2nd ppn bytes	      &
\	NEXT Z0%				!continue for hi bytes	      &
\	FN.MATCH.PPN% = TRUE%			!match if loop completes      &
\	FNEND					!end FN.MATCH.PPN% function   &

15200	!	f n . m a t c h . n a m e $ ( NAM.1$ , NAM.2$ )		      &
	!								      &
	!								      &
	!inputs:	NAM.1$		-	entry name string	      &
	!		NAM.2$		-	name string to match	      &
	!								      &
	!outputs:	FN.MATCH.NAME%	-	returned match status:	      &
	!					   TRUE% = names match	      &
	!					  FALSE% = names don't match  &
	!								      &
	!uses:		Z0%		-	loop index		      &
	!		NAM.1%()	-	work table for entry name     &
	!		NAM.2%()	-	work table for match name     &
	!								      &
	!notes:		This function compares a entry or queue name string   &
	!		(NAM.1$) against a match name string (NAM.2$). The    &
	!		match name string may contain a '*' or multiple '?'   &
	!		wildcard characters (always match).		      &
	!								      &
	!		If the match name string is null or *, then the	      &
	!		function returns TRUE% (match), regardless of the     &
	!		entry name string.				      &
	!								      &
	!		If the match string contains a trailing *, then	      &
	!		the * is replaced with enough ?'s to fill the string  &
	!		to a length of nine characters.			      &
	!								      &
	!								      &
	DEF FN.MATCH.NAME% (NAM.1$,NAM.2$)				      &
\	IF LEN(NAM.2$) = 0%			!if null match name	      &
	   OR NAM.2$ = "*" THEN			! or wildcard match name,     &
		FN.MATCH.NAME% = TRUE%		!  return match		      &
\		FNEXIT				!  and exit		      &
\	END IF					!end if			      &
						!			      &
\	Z0% = POS(NAM.2$,"*",LEN(NAM.2$))	!look for trailing * char     &
\	IF Z0% > 0% THEN			!if any found,		      &
		NAM.2$ = SEG$(NAM.2$,1%,Z0%-1%) +			      &
			 STRING$(9%-Z0%+1%,ASCII("?"))			      &
						!  replace * with ?'s	      &

15210	CHANGE EDIT$(NAM.1$,2%+4%) TO NAM.1%	!move entry name into array   &
\	CHANGE EDIT$(NAM.2$,2%+4%) TO NAM.2%	!move match name into array   &
\	FN.MATCH.NAME% = FALSE%			!init fn value as no match    &
						!			      &
\	FNEXIT					!exit with no match	      &
		IF NAM.1%(0%) > NAM.2%(0%)	!  if entry name is longer    &
						!			      &
\	FNEXIT					!exit with no match	      &
		IF NAM.1%(Z0%) <> NAM.2%(Z0%)	!  if chars don't match	      &
			IF NAM.2%(Z0%) <> ASCII("?")			      &
						!    if not wildcard char     &
				FOR Z0% = 1% TO NAM.1%(0%)		      &
						!      for each char	      &
						!			      &
\	FNEXIT					!exit with no match	      &
		IF NAM.2%(Z0%) <> ASCII("?")	!  if next char not wild      &
			FOR Z0% = NAM.1%(0%)+1% TO NAM.2%(0%)		      &
						!    for remaining chars      &
						!			      &
\	FN.MATCH.NAME% = TRUE%			!match if loops complete      &
\	FNEND					!end FN.MATCH.NAME% function  &

15300	!	f n . t i m e % ( TI.ME% )				      &
	!								      &
	!								      &
	!inputs:	TI.ME%		-	minutes until/since midnight  &
	!								      &
	!outputs:	FN.TIME%	-	inverted time integer	      &
	!								      &
	!uses:		none.						      &
	!								      &
	!notes:		The standard RSTS time integer is defined as minutes  &
	!		until midnight.  However, time integers	are defined   &
	!		in the spooling package as minutes since midnight.    &
	!		This function will "invert" a time integer, allowing  &
	!		its use for both encoding and decoding spooler/RSTS   &
	!		time integers.					      &
	!								      &
	!								      &
	DEF FN.TIME% (TI.ME%) =						      &
		1440% - TI.ME%			!invert time value	      &

15400	!	f n . f i l e . s p e c $ ( FSPEC$ )			      &
	!								      &
	!								      &
	!inputs:	FSPEC$		-	standard file spec	      &
	!								      &
	!outputs:	FN.FILE.SPEC$	-	returned file-spec with any   &
	!					network password field(s)     &
	!					replaced with "password"      &
	!								      &
	!uses:		Z%,Z1%,Z2%	-	work integers		      &
	!								      &
	!								      &
	DEF FN.FILE.SPEC$ (FSPEC$)					      &
\	FN.FILE.SPEC$ = FSPEC$			!return file-spec string      &
\	Z1% = POS(FSPEC$,'"',1%) + 1%		!find NET access field start  &
\	FNEXIT UNLESS Z1% > 1%			!exit unless one found	      &
\	Z2% = POS(FSPEC$,'"::',Z1%)		!find net access field end    &
\	FNEXIT UNLESS Z2% > 0%			!exit unless one found	      &
\	Z% = POS(FSPEC$," ",Z1%)		!find password start	      &
\	FNEXIT UNLESS (Z% > 0%) AND (Z% < Z2%)	!exit unless one found	      &
\	FN.FILE.SPEC$ = SEG$(FSPEC$,1%,Z%) + "password" +		      &
				SEG$(FSPEC$,Z2%,MAXINT%)		      &
						!replace any passwd fields    &
\	FNEND					!end FN.FILE.SPEC$ function   &

15500	!	f n . k b x . t o . k b $  ( SRV$ )			      &
	!								      &
	!								      &
	! inputs:	SRV$		-	server name in _KBcn: format  &
	!								      &
	! outputs:	FN.KBX.TO.KB$	-	server name in _KBn: format   &
	!								      &
	! uses:		FIRQB%()	-	sys call array		      &
	!								      &
	!								      &
	DEF FN.KBX.TO.KB$ (SRV$)					      &
\	IF LEFT(SRV$,3%) = "_KB" THEN		!if KB type server,	      &
		ON ERROR GOTO 15520		!else trap own errors	      &
\		CHANGE FSS$(SRV$,1%) TO FIRQB%	!  FSS the server name	      &
\		SRV$ = "_KB" + NUM1$(FIRQB%(25%)) + ":"			      &
						!  return full _KBn: name     &
			UNLESS (FIRQB%(30%) AND 128%)			      &
						!  unless invalid (removed)   &
\	END IF					!end if			      &
\	GOTO 15550				!skip to exit		      &

15520	RESUME 15550				!resume to exit		      &

15550	FN.KBX.TO.KB$ = SRV$			!return server name	      &
\	FNEND					!end FN.KBX.TO.KB$ function   &

15600	!	f n . s t a t u s $   ( STS% )				      &
	!								      &
	!								      &
	!inputs:	STS%		-	status code		      &
	!								      &
	!outputs:	FN.STATUS$	-	status keyword		      &
	!								      &
	!uses:		None.						      &
	!								      &
	!								      &
	DEF FN.STATUS$ (STS%)						      &
\	SELECT STS%				!select via status value:     &
\	CASE = JS.RDY%				!case = ready,		      &
\		FN.STATUS$ = "READY"		!  set status = READY	      &
\	CASE = JS.AFT%				!case = after,		      &
\		FN.STATUS$ = "AFTER"		!  set status = AFTER	      &
\	CASE = JS.NRD%				!case = not ready,	      &
\		FN.STATUS$ = "HOLD"		!  set status = HOLD	      &
\	CASE = JS.FRM%				!case = forms wait,	      &
\		FN.STATUS$ = "FORMS_WAIT"	!  set status = FORMS_WAIT    &
\	CASE = JS.STR%				!case = started,	      &
\		FN.STATUS$ = "STARTED"		!  set status = STARTED	      &
\	CASE = JS.ABT%				!case = aborting,	      &
\		FN.STATUS$ = "ABORTING"		!  set status = ABORTING      &
\	CASE = JS.SUC%				!case = succeeded,	      &
\		FN.STATUS$ = "ENDED"		!  set status = ENDED	      &
\	CASE = JS.FAI%				!case = failed,		      &
\		FN.STATUS$ = "FAILED"		!  set status = FAILED	      &
\	CASE = JS.ABO%				!case = aborted,	      &
\		FN.STATUS$ = "ABORTED"		!  set status = ABORTED	      &
\	CASE = JS.KIL%				!case = deleted,	      &
\		FN.STATUS$ = "DELETED"		!  set status = DELETED	      &
\	CASE ELSE				!case = else,		      &
\		FN.STATUS$ = "UNKNOWN"		!  set status = unknown	      &
\	END SELECT				!end select		      &
						!			      &
\	FNEND					!end FN.STATUS$ function      &

15700	!	f n . u n s i g n e d % ( FL.PT )			      &
	!								      &
	!								      &
	!inputs:	VALUE		-	floating-pt value 0 to 65535  &
	!								      &
	!outputs:	FN.UNSIGNED%	-	unsigned 16-bit integer	      &
	!								      &
	!uses:		None.						      &
	!								      &
	!								      &
	DEF FN.UNSIGNED% (FL.PT)					      &
\	FL.PT = 0.				!force to 0		      &
		IF FL.PT < 0. OR FL.PT > 65535.	!  if not in range 0-65535    &
\	FL.PT = FL.PT - 65536.			!normalize (-32768,+32767)    &
		IF FL.PT > 32767.		!  if over max pos integer    &
\	FN.UNSIGNED% = FL.PT			!return unsigned integer      &
\	FNEND					!end FN.UNSIGNED% function    &

15800	!	f n . u n s i g n e d ( VALUE% )			      &
	!								      &
	!								      &
	!inputs:	VALUE%		-	16-bit unsigned integer	      &
	!								      &
	!outputs:	FN.UNSIGNED	-	corresponding FL-PT value     &
	!								      &
	!uses:		Z		-	work FL-PT		      &
	!								      &
	!								      &
	DEF FN.UNSIGNED (VALUE%)					      &
\	Z = VALUE%				!move to fl-pt variable	      &
\	Z = Z + 65536.				!normalize to 0		      &
		IF Z < 0.			!  if negative		      &
\	FN.UNSIGNED = Z				!  return fl-pt value	      &
\	FNEND					!end FN.UNSIGNED function     &

15900	!	f n . d a t e . t i m e $ ( DA.TE% , TI.ME% )		      &
	!								      &
	!								      &
	!inputs:	DA.TE%		-	RSTS date integer	      &
	!		TI.ME%		-	inverted time integer	      &
	!								      &
	!outputs:	FN.DATE.TIME$	-	date/time string	      &
	!								      &
	!uses:		none.						      &
	!								      &
	!								      &
	DEF FN.DATE.TIME$ (DA.TE%,TI.ME%) =				      &
		DATE$(DA.TE%) + " " + TIME$(FN.TIME%(TI.ME%))		      &
						!build "dd-mmm-yy hh:mm am"   &

16000	!	f n . p p n $ ( PPN% , FIXED% )				      &
	!								      &
	!								      &
	!inputs:	PPN%		-	PPN word		      &
	!		FIXED%		-	fixed-length string flag      &
	!								      &
	!outputs:	FN.PPN$		-	PPN string "[ proj,prog ]"    &
	!								      &
	!uses:		Z1$, Z2$	-	work strings		      &
	!		Z%		-	work integer		      &
	!								      &
	!notes:	If FIXED% flag is set, then PPN is returned as a fixed-length &
	!	9-character string of the form "[aaa,bbb]", where aaa is the  &
	!	project no. with leading spaces, and bbb is the programmer    &
	!	no. with trailing spaces.  If FIXED% flag is zero, then the   &
	!	PPN string is returned with no leading/trailing spaces.	      &
	!								      &
	!								      &
	DEF FN.PPN$ (PPN%,FIXED%)					      &
\	Z1$, Z2$ = "*"				!init proj,prog strings	      &
\	Z% = SWAP%(PPN%) AND 255%		!get project no.	      &
\	Z1$ = NUM1$(Z%)				!build project string	      &
		UNLESS Z% = 255%		!  unless wild		      &
\	Z1$ = SPACE$(3%-LEN(Z1$)) + Z1$		!add leading spaces	      &
		IF FIXED%			!  if fixed-length flag set   &
\	Z% = PPN% AND 255%			!get programmer no.	      &
\	Z2$ = NUM1$(Z%)				!build programmer string      &
		UNLESS Z% = 255%		!  unless wild		      &
\	Z2$ = Z2$ + SPACE$(3%-LEN(Z2$))		!add trailing spaces	      &
		IF FIXED%			!  if fixed-length flag set   &
\	FN.PPN$ = "[" + Z1$ + "," + Z2$ + "]"	!return PPN string	      &
\	FNEND					!end FN.PPN$ function	      &

16100	!	f n . f i l e . q u a l % ( QL.NAM$ , QL.BIT% , QL.DLF% )     &
	!								      &
	!								      &
	!inputs:	FIL.FLG%	-	qualifier flag word	      &
	!		QL.NAM$		-	qualifier name		      &
	!		QL.BIT%		-	qualifier bit value	      &
	!		QL.DFL%		-	default qualifier value	      &
	!		QL.POS%		-	starting ccpos for quals      &
	!								      &
	!outputs:	FN.FILE.QUAL%	-	length of qualifier string    &
	!					(format "/[NO]qualifier")     &
	!								      &
	!uses:		Z%		-	work integer		      &
	!		Z$		-	work string		      &
	!								      &
	!notes:								      &
	!								      &
	! This function will display a file qualifier in the form "/[NO]qual" &
	! based on the arguments passed.  A qualifier is displayed only if    &
	!								      &
	!		the qualifier differs from the default		      &
	!	OR	the flag DEBUG% is set (debugging mode)		      &
	!								      &
	! Each qualifier is displayed starting at the next qualifier zone     &
	! (14 characters each, starting at leftmost position QL.POS%).	      &
	!								      &
	!								      &
	DEF FN.FILE.QUAL% (QL.NAM$,QL.BIT%,QL.DFL%)			      &
\	Z% = (FIL.FLG% AND QL.BIT%)		!save qualifier bit status    &
\	IF Z% = QL.DFL% AND NOT DEBUG% THEN	!if = default and debug off,  &
		Z$ = ""				!  don't display qual	      &
	ELSE	IF Z% THEN			!else if bit on,	      &
			Z$ = "/" + QL.NAM$	!    display "/qual"	      &
		ELSE	Z$ = "/NO" + QL.NAM$	!  else display "/NOqual"     &
\		END IF				!  end if		      &
\	END IF					!end if			      &
						!			      &
\	FN.FILE.QUAL% = LEN(Z$)			!return qual len as fn value  &
\	FNEXIT UNLESS LEN(Z$)			!exit unless qual to display  &
						!			      &
\	Z% = QL.POS% + 14% * ((CCPOS(SHO.CHNL%) - QL.POS% + 13%) / 14%)	      &
						!compute next zone position   &
\	IF Z% + 14% > SHO.WIDTH% THEN		!  if no room on curr line,   &
		PRINT #SHO.CHNL%		!  start a new line	      &
\		Z% = QL.POS%			!  and reset starting zone    &
\	END IF					!end if			      &
						!			      &
\	PRINT #SHO.CHNL%, TAB(Z%); Z$;		!display the qualifier	      &
\	FNEND					!end FN.FILE.QUAL% function   &

16300	!	f n . p r i v % ( P R I V $ )				      &
	!								      &
	!								      &
	!inputs:	PRIV$		-	priv name to check	      &
	!								      &
	!outputs:	FN.PRIV%	-	privilege status:	      &
	!					  TRUE  -> priv on	      &
	!					  FALSE -> priv off	      &
	!								      &
	!		ERRSTS%		-	0 if priv on		      &
	!					ERR.PRVIOL if priv off	      &
	!					ERR.BADNAM if invalid priv    &
	!								      &
	DEF FN.PRIV%(PRIV$)			!start definition	      &
\	ON ERROR GOTO 16310			!local error routine	      &
\	ERRSTS% = 0%				!clear ERRSTS		      &
\	PRIV$ = EDIT$(PRIV$,-1%)		!trim the priv name string    &
\	Z$ = SYS (				!do check priv SYS call:      &
		CHR.6$ +			!  FIP call		      &
		CHR$(32%) +			!  check access function      &
		CHR$(1%) +			!  check priv name subfun     &
		CHR.0$ +			!  reserved		      &
		CHR.00$ +			!  reserved		      &
		PRIV$				!  priv name to check	      &
		 )				!end of sys call	      &
\	Z%,FN.PRIV% = (ASCII(SEG$(Z$,3%,3%)) = 0%)			      &
						!return priv status	      &
\	IF NOT Z% THEN				!if priv not enabled,	      &
		CALL DISPLY ("?"+PRIV$+" privilege required")		      &
						!  display error message      &
\		ERRSTS% = ERR.PRVIOL%		!  and return PRVIOL error    &
\	END IF					!end if			      &
\	GOTO 16320				!skip to function exit	      &

16310	ERRSTS% = ERR.BADNAM%			!set bad priv name	      &
\	CALL DISPLY ("?Invalid privilege name")	!display error message	      &
\	FN.PRIV% = FALSE%			!return priv disabled	      &
\	RESUME 16320				!resume to function end	      &

16320	FNEND					!end FN.PRIV% function	      &

16400	!	f n . n u m e r i c % ( ENTRY$ )			      &
	!								      &
	!								      &
	!inputs:	ENTRY$		-	entry string		      &
	!								      &
	!outputs:	FN.NUMERIC%	-	numeric-entry flag:	      &
	!					  TRUE  -> entry is numeric   &
	!					  FALSE -> entry not numeric  &
	!								      &
	!uses:								      &
	!								      &
	!notes:	This function determines whether an entry string is numeric   &
	!	(indicating an entry number), or non-numeric (indicating an   &
	!	entry-spec).						      &
	!								      &
	!								      &
	DEF FN.NUMERIC% (ENTRY$)					      &
\	ON ERROR GOTO 16410			!trap own errors	      &
\	Z% = VAL(ENTRY$)			!try to convert to integer    &
\	FN.NUMERIC% = (	(POS(ENTRY$,"+",1%) +	!check for + sign	      &
			 POS(ENTRY$,"-",1%) +	!	   - sign	      &
			 POS(ENTRY$,".",1%))	!	   decimal point      &
				= 0% )		!numeric if none	      &
\	GOTO 16420				!skip to exit fn	      &

16410	FN.NUMERIC% = FALSE%			!return non-numeric flag      &
\	RESUME 16420				!resume to exit fn	      &

16420	FNEND					!end FN.NUMERIC% function     &

16500	!	f n . o w n . e n t r y % ( ACC.PPN% )			      &
	!								      &
	!inputs:	ACC.PPN%	-	entry's PPN to check	      &
	!		PPN%		-	user's PPN		      &
	!								      &
	!outputs:	FN.OWN.ENTRY%	-	ownership flag:		      &
	!					  TRUE  -> owner access	      &
	!					  FALSE -> no owner access    &
	!								      &
	!notes:	This function determines if the user has owner access to the  &
	!	current entry, based on the user's PPN and the entry's PPN.   &
	!								      &
	!	A user has ownership of an entry if:			      &
	!								      &
	!		1) The user has WACNT privilege			      &
	!	or	2) The user has GACNT privilege and the PPN's	      &
	!		   project number matches the user's		      &
	!		3) The entry's PPN matches the user's		      &
	!								      &
	!								      &
	DEF FN.OWN.ENTRY% (ACC.PPN%)					      &
\	IF ACC.PPN% = PPN% THEN			!if same ppn,		      &
		FN.OWN.ENTRY% = TRUE%		!  return TRUE		      &
	ELSE	CHANGE SYS (			!else do UU.CHK SYS call:     &
			CHR.6$ +		!    FIP call		      &
			CHR$(32%) +		!    check access function    &
			CHR.00$ +		!    reserved		      &
			CHR$(ACC.PPN%) +	!    prog no. to check	      &
			CHR$(SWAP%(ACC.PPN%))	!    proj no. to check	      &
			   ) TO FIRQB%		!  end of sys call	      &
						!			      &
\		FN.OWN.ENTRY% = ((FIRQB%(3%) AND 128%) <> 0%)		      &
						!  return ownership flag      &
\	END IF					!end if			      &
						!			      &
\	FNEND					!end FN.OWN.ENTRY% function   &

16600	!	f n . o r d i n a l $ ( VALUE. )			      &
	!								      &
	!								      &
	!inputs:	VALUE.		-	fl-pt value		      &
	!								      &
	!outputs:	FN.ORDINAL$	-	ordinal string		      &
	!								      &
	!uses:		Z$		-	temp work string	      &
	!		Z%,Z1%,Z2%	-	temp work integer	      &
	!								      &
	!								      &
	DEF FN.ORDINAL$ (VALUE.)					      &
\	Z$ = NUM1$(VALUE.)			!build numeric string	      &
\	Z1% = LEN(Z$)				!save length of string	      &
\	Z2% = Z1% - 1%				!save length minus one	      &
\	IF VAL(SEG$(Z$,Z2%,Z2%)) = 1% THEN	!if next-to-last digit = 1,   &
		Z1% = 0%			!  treat last digit as 0      &
	ELSE	Z1% = VAL(SEG$(Z$,Z1%,Z1%))	!else save last digit	      &
\	END IF					!end if			      &
						!			      &
\	SELECT Z1%				!select via last digit:	      &
\	CASE = 1%				!case = xxx1,		      &
\		Z$ = Z$ + "st"			!  suffix is 'st'	      &
\	CASE = 2%				!case = xxx2,		      &
\		Z$ = Z$ + "nd"			!  suffix is 'nd'	      &
\	CASE = 3%				!case = xxx3,		      &
\		Z$ = Z$ + "rd"			!  suffix is 'rd'	      &
\	CASE ELSE				!case else,		      &
\		Z$ = Z$ + "th"			!  suffix is 'th'	      &
\	END SELECT				!end select		      &
						!			      &
\	FN.ORDINAL$ = Z$			!return ordinal string	      &
\	FNEND					!end FN.ORDINAL$ function     &

16700	!	f n . e n t r y % ( ENTRY$ )				      &
	!								      &
	!								      &
	!inputs:	ENTRY$		-	entry string		      &
	!								      &
	!outputs:	FN.ENTRY%	-	entry number in range 1-9999  &
	!					0 if not an entry number      &
	!		ERRSTS%		-	error status:		      &
	!					     0 = valid entry no. or 0 &
	!					   <>0 = invalid entry no.    &
	!								      &
	!uses:		Z		-	work fl-pt		      &
	!								      &
	!notes:	This function determines whether an entry string is numeric   &
	!	(indicating an entry number), or non-numeric (indicating an   &
	!	entry-spec).  If non-numeric, then 0 is returned.  If entry   &
	!	number, then ensures in range 1-9999.  If in range, then the  &
	!	entry number is returned with ERRSTS%=0.  If out of range,    &
	!	then entry number 0 is returned with ERRSTS% = ERR.BADNAM%.   &
	!								      &
	!								      &
	DEF FN.ENTRY% (ENTRY$)						      &
\	ON ERROR GOTO 16710			!trap own errors	      &
\	ERRSTS% = 0%				!init success		      &
\	Z = VAL(ENTRY$)				!try to convert to number     &
\	IF POS(ENTRY$,"+",1%) OR		!if includes + sign,	      &
	   POS(ENTRY$,"-",1%) OR		!or includes - sign,	      &
	   POS(ENTRY$,".",1%) THEN		!or includes decimal point,   &
		FN.ENTRY% = 0%			!  return entry no. = 0	      &
\		GOTO 16720			!  and skip to exit	      &
\	END IF					!end if			      &
						!			      &
\	IF (Z >= 1.) AND (Z <= 9999.) THEN	!if entry no. in range,	      &
		FN.ENTRY% = Z			!  return entry no.	      &
	ELSE	ERRSTS% = ERR.BADNAM%		!else return BADNAM error     &
\		FN.ENTRY% = 0%			!  return entry no. = 0	      &
\		CALL DISPLY ("?Number not in range 1 to 9999")		      &
						!  display error message      &
\	END IF					!end if			      &
\	GOTO 16720				!skip to exit		      &

16710	FN.ENTRY% = 0%				!return entry no. 0	      &
\	RESUME 16720				!resume to exit fn	      &

16720	FNEND					!end FN.NUMERIC% function     &

17000	!	f n . p a d $   ( TEXT$ , FLD.LEN% )			      &
	!								      &
	!								      &
	!inputs:	TEXT$		-	text string to pad	      &
	!								      &
	!		FLD.LEN%	-	field length:		      &
	!					  if +n, pad with leading sp  &
	!					  if -n, pad with trailng sp  &
	!								      &
	!outputs:	FN.PAD$		-	string padded to field length &
	!								      &
	!uses:		ZZZ$		-	temp work string	      &
	!								      &
	!								      &
	DEF FN.PAD$ (TEXT$,FLD.LEN%)					      &
\	IF FLD.LEN% > 0% THEN			!if positive field length,    &
		ZZZ$ = SPACE$(FLD.LEN%)		!  build full-length string   &
\		RSET ZZZ$ = TEXT$		!  RSET the text string	      &
	ELSE	ZZZ$ = SPACE$(-FLD.LEN%)	!  build full-length string   &
\		LSET ZZZ$ = TEXT$		!  LSET the text string	      &
\	END IF					!end if			      &
						!			      &
\	FN.PAD$ = ZZZ$ + ""			!return padded string	      &
\	FNEND					!end FN.PAD$ function	      &

19000	!	s t a n d a r d   e r r o r   h a n d l i n g		      &
	!								      &
	!								      &
	FATAL% = TRUE%				!set fatal error flag	      &
\	ERRSTS% = ERR				!save error no.		      &
\	ERRLIN% = ERL				!save error line no.	      &
\	ERRNAM$ = ERN$				!save module name	      &
\	RESUME 32767				!resume to exit		      &

32767	!	e n d   o f   s u b p r o g r a m			      &
	!								      &
	!								      &
	SUBEND
