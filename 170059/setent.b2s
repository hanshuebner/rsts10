1	SUB SETENT							      &
\	MODULE$ = "SETENT"						      &
\	ON ERROR GOTO 19000						      &
\	SUBEXIT IF CC.FLG%						      &
	!								      &
	!								      &
	!******************************************************************** &
	!								      &
	!	s u b p r o g r a m   t i t l e				      &
	!								      &
	!	  subprogram : SETENT					      &
	!	     version : V10.1					      &
	!	        edit : J					      &
	!	   edit date : 27-MAR-92				      &
	!	   author(s) : PRL					      &
	!								      &
	!******************************************************************** &
	!								      &
	!		  C O P Y R I G H T				      &
	!								      &
	!								      &
	!		      Copyright (C) 1984, 1992 by		      &
	!	Digital Equipment Corporation, Maynard, Mass.		      &
	!								      &
	!								      &
	! This software is furnished under a license and may be used and      &
	! copied  only  in accordance with the terms of such license and      &
	! with the  inclusion  of  the  above  copyright  notice.   This      &
	! software  or  any  other copies thereof may not be provided or      &
	! otherwise made available to any other person.  No title to and      &
	! ownership of the software is hereby transferred.		      &
	!								      &
	! The information in this software is subject to change  without      &
	! notice  and should not be construed as a commitment by Digital      &
	! Equipment Corporation.					      &
	!								      &
	! DIGITAL assumes no responsibility for the use  or  reliability      &
	! of its software on equipment that is not supplied by DIGITAL.	      &
	!								      &
	!******************************************************************** &
	!								      &
	!	s u b p r o g r a m   c a l l   f o r m a t		      &
	!								      &
	!	CALL SETENT						      &
	!								      &
	!	Argument	I/O	Usage				      &
	!	========	===	=====				      &
	!	ERRSTS%		O	error status			      &
	!				   0 = success			      &
	!				   n = ERR value		      &
	!								      &
	!******************************************************************** &
	!								      &
	!	m o d i f i c a t i o n   h i s t o r y   l o g		      &
	!								      &
	! VER/ED	EDIT DATE	REASON				      &
	!								      &
	! V9.0-10	22-Jan-85	(PRL) Change rules for entry owner    &
	! V9.0-12	25-Jan-85	(PRL) Don't allow null entry name     &
	! =================================================================== &
	! V9.2-02	01-OCT-85	(PRL) Fix multiple record access      &
	!				        problem if /PRIORITY change   &
	! =================================================================== &
	! V10.1-A	17-Mar-91	(PRL) Support /[NO]NOTIFY qualifier   &
	! V10.1-J	19-Mar-92	(PRL) Support 'XXX*' wildcards	      &
	!								      &
	!******************************************************************** &
	!								      &
	!	s u b p r o g r a m   d e s c r i p t i o n		      &
	!								      &
	!	This subprogram is called to modify entries in a queue.  The  &
	!	format of the SET ENTRY command is:			      &
	!								      &
	!		SET ENTRY entry					      &
	!								      &
	!	where entry is either an entry number or entry-spec.	      &
	!								      &
	!	Qualifiers:						      &
	!								      &
	!			/[NO]AFTER				      &
	!			/BATCH					      &
	!			/CPU_LIMIT=n				      &
	!			/FORMS=form-name			      &
	!			/HOLD					      &
	!			/JOB_COUNT=n				      &
	!			/[NO]NOTIFY				      &
	!			/PAGE_LIMIT=n				      &
	!			/PRINT					      &
	!			/PRIORITY=n				      &
	!			/RELEASE				      &
	!			/TIME_LIMIT=n				      &
	!			/USER=ppn				      &
	!								      &
	!******************************************************************** &
	!								      &
	!	v a r i a b l e s  /  a r r a y s   u s e d		      &
	!								      &
	!	name		description				      &
	!	====		===========				      &
	!								      &
	!******************************************************************** &
	!								      &
	!	s u b r o u t i n e s   u s e d				      &
	!								      &
	!	line #/name		description			      &
	!	===========		===========			      &
	!	DISPLY			print error text at user's KB	      &
	!	ENTSPC			parse entry-spec		      &
	!	CHKQUE			validate queue-name		      &
	!	GETREC			read queue file record		      &
	!	RECV			receive ACK/NACK packet		      &
	!	SEND			send packet to queue manager	      &
	!								      &
	!	FET$A BY REF		fetch (CUI) argument		      &
	!	FET$CQ BY REF		fetch (CUI) command qualifier	      &
	!	FET$P BY REF		fetch (CUI) parameter		      &
	!	FET$NP BY REF		fetch next (CUI) parameter	      &
	!								      &
	!******************************************************************** &
	!								      &
	!	f u n c t i o n s   u s e d				      &
	!								      &
	!	line #	name		description			      &
	!	======	====		===========			      &
	!	15000	FN.UNSIGNED%	convert fl-pt to unsigned int	      &
	!	15100	FN.UNSIGNED	convert unsigned integer to fl-pt     &
	!	15200	FN.PPN$		return [proj,prog] string	      &
	!	15300	FN.ENTRY.ID$	return entry ID of current entry rec  &
	!	15400	FN.OWN.ENTRY%	return user's own-entry status	      &
	!	15600	FN.GET.ENTRY%	return next selected entry record     &
	!	15700	FN.MATCH.PPN%	return 'PPNs match' status	      &
	!	15800	FN.MATCH.NAME%	return names-match status	      &
	!	15900	FN.PRIV%	return user's privilege status	      &
	!	16000	FN.ENTRY%	return entry no. or 0 if entry-spec   &
	!	16100	FN.CAP$		return string with 1st char U/C	      &
	!								      &
	!******************************************************************** &
	!								      &
	!	m a p   d e c l a r a t i o n s				      &
	!								      &
	!	line #	name	description				      &
	!	======	====	===========				      &
	!	   700	PBSCMN	QUEUE common data (%INCLUDE PBSCMN.B2S)	      &
	!	   	PBSMAP	Send/Recv/Record fields (%INCLUDE PBSMAP.B2S) &
	!								      &
	!******************************************************************** &
	!								      &
	!	c o m m o n   d e c l a r a t i o n s			      &
	!								      &
	!	line #	name	description				      &
	!	======	====	===========				      &
	!	   700	PBSKEY	CUI constants (%INCLUDE PBSKEY.B2S)	      &
	!	   	CUICMN	CUI common data (%INCLUDE CUICMN.B2S)	      &
	!								      &
	!******************************************************************** &
	!								      &
	!	d i m e n s i o n   d e c l a r a t i o n s		      &
	!								      &
	!	line #	variable		description		      &
	!	======	========		===========		      &
	!	   900	NAM.1%(30)		work table for FN.MATCH.NAME% &
	!		NAM.2%(30)		work table for FN.MATCH.NAME% &
	!								      &
	!******************************************************************** &

700	!	i n c l u d e   r e q u i r e d   M A P s , C O M M O N s     &
	!								      &
	!								      &
	%INCLUDE "SYSTEM:PBSCMN.B2S"		!include QUEUE data section   &
	%INCLUDE "SYSTEM:PBSMAP.B2S"		!include QUEUE map sections   &
	%INCLUDE "SYSTEM:PBSKEY.B2S"		!include CUI keywords	      &
	%INCLUDE "CUI:CUICMN.B2S"		!include CUI data section     &

900	!	D I M E N S I O N   d e c l a r a t i o n s		      &
	!								      &
	!								      &
	DIM	SEQ.NO%(100),			!table of recs found seq nos. &
		NAM.1%(10),			!table for FN.MATCH.NAME%     &
		NAM.2%(10)			!table for FN.MATCH.NAME%     &

1000	!	m a i n   s u b p r o g r a m   l o g i c		      &
	!								      &
	!								      &
	Z$ = SYS (PRIV.ON$)			!enable privs		      &
\	TODAY% = PEEK(512%)			!get todays's date word	      &
\	Z$ = SYS (PRIV.OFF$)			!disable privs		      &
\	END.DAY% = 1%				!define end of day (11:59PM)  &
						!			      &
						!define SET bit values:	      &
\	AFT.BIT% = 1%				!  /AFTER		      &
\	CPU.BIT% = 2%				!  /CPU_LIMIT		      &
\	FRM.BIT% = 4%				!  /FORMS		      &
\	HLD.BIT% = 8%				!  /HOLD		      &
\	JBC.BIT% = 16%				!  /JOB_COUNT		      &
\	PAG.BIT% = 32%				!  /PAGE_LIMIT		      &
\	PRI.BIT% = 64%				!  /PRIORITY		      &
\	REL.BIT% = 128%				!  /RELEASE		      &
\	TIM.BIT% = 256%				!  /TIME_LIMIT		      &
\	NTF.BIT% = 512%				!  /NOTIFY		      &
\	NNT.BIT% = 1024%			!  /NONOTIFY		      &
						!			      &
\	DISPLAY% = FALSE%			!turn off error display	      &
\	PBSCTL.FLG% = FN.PRIV% ("PBSCTL")	!set/clear PBSCTL priv flag   &
\	DISPLAY% = TRUE%			!re-enable error display      &
						!			      &
\	QTYP% = 0%				!select any queue type	      &
\	SET.FLG% = 0%				!clear all set bits	      &
\	ANY.FLG% = FALSE%			!clear 'any type qual' flag   &
\	OWN.REQ.FLG% = FALSE%			!clear 'ownership req'd' flag &
						!			      &
\	CALL FET$P BY REF (ENT.T%)		!fetch entry parameter	      &
\	ENT.POS% = U.POS%			!save position in cmd line    &
\	ENTRY$ = SEG$(U.STR$,1%,U.LEN%)		!save entry string	      &
\	ENT.NO% = FN.ENTRY% (ENTRY$)		!return entry no. or 0	      &
\	SUBEXIT IF ERRSTS%			!exit if invalid entry no.    &
						!			      &
\	CALL FET$CQ BY REF (AFT.Q%)		!fetch /[NO]AFTER qualifier   &
\	IF U.PRES% THEN				!if present,		      &
		ANY.FLG% = TRUE%		!  set 'any queue qual' flag  &
\		GOSUB 10100			!  process qualifier	      &
\		SUBEXIT IF ERRSTS% OR CC.FLG%	!  exit if error or CTRL/C    &
\	END IF					!end if			      &
						!			      &
\	CALL FET$CQ BY REF (CPU.Q%)		!fetch /CPU_LIMIT qual	      &
\	IF U.PRES% THEN				!if present,		      &
		QTYP% = BAT.TYP%		!  select only batch queues   &
\		GOSUB 10200			!  process qualifier	      &
\		SUBEXIT IF ERRSTS% OR CC.FLG%	!  exit if error or CTRL/C    &
\	END IF					!end if			      &
						!			      &
\	CALL FET$CQ BY REF (FRM.Q%)		!fetch /FORMS qual	      &
\	IF U.PRES% THEN				!if present,		      &
		QTYP% = PRT.TYP%		!  select only print queues   &
\		GOSUB 10300			!  process qualifier	      &
\		SUBEXIT IF ERRSTS% OR CC.FLG%	!  exit if error or CTRL/C    &
\	END IF					!end if			      &
						!			      &
\	CALL FET$CQ BY REF (HLD.Q%)		!fetch /HOLD qualifier	      &
\	IF U.PRES% THEN				!if present,		      &
		ANY.FLG% = TRUE%		!  set 'any queue qual' flag  &
\		GOSUB 10400			!  process qualifier	      &
\		SUBEXIT IF ERRSTS% OR CC.FLG%	!  exit if error or CTRL/C    &
\	END IF					!end if			      &
						!			      &
\	CALL FET$CQ BY REF (JBC.Q%)		!fetch /JOB_COUNT qualifier   &
\	IF U.PRES% THEN				!if present,		      &
		QTYP% = PRT.TYP%		!  select only print queues   &
\		GOSUB 10500			!  process qualifier	      &
\		SUBEXIT IF ERRSTS% OR CC.FLG%	!  exit if error or CTRL/C    &
\	END IF					!end if			      &
						!			      &
\	CALL FET$CQ BY REF (NTF.Q%)		!fetch /[NO]NOTIFY qual	      &
\	IF U.PRES% THEN				!if present,		      &
		ANY.FLG% = TRUE%		!  set 'any queue qual' flag  &
\		GOSUB 10550			!  process qualifier	      &
\		SUBEXIT IF ERRSTS% OR CC.FLG%	!  exit if error or CTRL/C    &
\	END IF					!end if			      &
						!			      &
\	CALL FET$CQ BY REF (PGL.Q%)		!fetch /PAGE_LIMIT qual	      &
\	IF U.PRES% THEN				!if present,		      &
		QTYP% = PRT.TYP%		!  select only print queues   &
\		GOSUB 10600			!  process qualifier	      &
\		SUBEXIT IF ERRSTS% OR CC.FLG%	!  exit if error or CTRL/C    &
\	END IF					!end if			      &
						!			      &
\	CALL FET$CQ BY REF (PTY.Q%)		!fetch /PRIORITY qualifier    &
\	IF U.PRES% THEN				!if present,		      &
		ANY.FLG% = TRUE%		!  set 'any queue qual' flag  &
\		GOSUB 10700			!  process qualifier	      &
\		SUBEXIT IF ERRSTS% OR CC.FLG%	!  exit if error or CTRL/C    &
\	END IF					!end if			      &
						!			      &
\	CALL FET$CQ BY REF (RLS.Q%)		!fetch /RELEASE qualifier     &
\	IF U.PRES% THEN				!if present,		      &
		ANY.FLG% = TRUE%		!  set 'any queue qual' flag  &
\		GOSUB 10800			!  process qualifier	      &
\		SUBEXIT IF ERRSTS% OR CC.FLG%	!  exit if error or CTRL/C    &
\	END IF					!end if			      &
						!			      &
\	CALL FET$CQ BY REF (TIM.Q%)		!fetch /TIME_LIMIT qual	      &
\	IF U.PRES% THEN				!if present,		      &
		QTYP% = BAT.TYP%		!  select only batch queues   &
\		GOSUB 10900			!  process qualifier	      &
\		SUBEXIT IF ERRSTS% OR CC.FLG%	!  exit if error or CTRL/C    &
\	END IF					!end if			      &
						!			      &
\	IF SET.FLG% = 0% THEN			!if no SET bits on,	      &
		U.POS% = 1%			!  point to command	      &
\		CALL DISPLY ("?Additional qualifier required")		      &
						!  display no quals error     &
\		ERRSTS% = ERR.NOSUCH%		!  return NOSUCH error	      &
\		SUBEXIT				!  and exit		      &
\	END IF					!end if			      &
						!			      &
\	IF ANY.FLG% THEN			!if "any-type" quals found,   &
		QTYP% = 0%			!  select any queue type      &
\		CALL FET$CQ BY REF (PRN.Q%)	!  fetch /PRINT qualifier     &
\		IF U.PRES% THEN			!  if present,		      &
			QTYP% = PRT.TYP%	!    select only print queues &
\		END IF				!  end if		      &
						!			      &
\		CALL FET$CQ BY REF (BAT.Q%)	!  fetch /BATCH qualifier     &
\		IF U.PRES% THEN			!  if present,		      &
			QTYP% = BAT.TYP%	!    select only batch queues &
\		END IF				!  end if		      &
\	END IF					!end if			      &
						!			      &
\	IF ENT.NO% THEN				!if entry-number,	      &
		GOSUB 2000			!  go modify by number	      &
	ELSE	GOSUB 3000			!  go modify by spec	      &
\	END IF					!end if			      &
						!			      &
\	SUBEXIT					!exit			      &

2000	!	m o d i f y   b y   e n t r y   n u m b e r		      &
	!								      &
	!								      &
	MSG.TXT$ = ""				!show no message text	      &
\	GOSUB 2100				!go modify this entry no.     &
\	RETURN IF CC.FLG%			!exit if CTRL/C		      &
\	IF LEN(MSG.TXT$) THEN			!if any msg text,	      &
		U.POS% = 0%			!  disable repainting cmd     &
\		CALL DISPLY (MSG.TXT$)		!  display message text	      &
\	END IF					!end if			      &
						!			      &
\	RETURN					!exit			      &

2100	!	m o d i f y   c u r r e n t   e n t r y   n o .		      &
	!								      &
	!								      &
	KY$ = CVT%$(SWAP%(FN.UNSIGNED%(ENT.NO%)))			      &
						!build seq no. key string     &
\	CALL GETREC (1%,0%,KY$)			!find entry rec by seq no.    &
\	SUBEXIT IF FATAL% OR CC.FLG%		!exit if fatal err or CTRL/C  &
						!			      &
\	Z% = ASCII(PKT.QUE$)			!get entry's type	      &
\	IF ((Z% AND NOT 15%) <> 0%)		!if not an entry record,      &
	   OR ((Z% AND 15%) = 0%)		!or no entry type defined,    &
	   OR ((QTYP% <> 0%) AND (Z% <> QTYP%))	!or wrong type of entry,      &
	   OR (PKT.SEQ% = 0%) THEN		!or queue header rec (0),     &
		ERRSTS% = ERR.NOTFND%		!  return NOTFND error	      &
			UNLESS ERRSTS%		!    unless pending error     &
\	END IF					!end if			      &
						!			      &
\	IF ERRSTS% = ERR.NOTFND% THEN		!if record not found,	      &
		SELECT QTYP%			!  select via queue type:     &
\		CASE = PRT.TYP%			!  case = print entries,      &
\			Z$ = "print "		!    build print text	      &
\		CASE = BAT.TYP%			!  case = batch entries,      &
\			Z$ = "batch "		!    build print text	      &
\		CASE ELSE			!  case else,		      &
\			Z$ = ""			!    build null text	      &
\		END SELECT			!  end select		      &
\		MSG.TXT$ = "%No " + Z$ + "entry " + ENTRY$ + " found"	      &
						!  build error message text   &
\	END IF					!end if			      &
						!			      &
\	RETURN IF ERRSTS%			!exit if any errors	      &
						!			      &
\	QUE.TYP% = ASCII(PKT.QUE$) AND 15%	!save entry type	      &
\	GOSUB 4000				!go send modify cmd	      &
\	RETURN					!and exit		      &

3000	!	m o d i f y   b y   e n t r y - s p e c			      &
	!								      &
	!								      &
	ES.SPEC$ = ""				!init null entry-spec	      &
\	ES.QUE$ = "*"				!select all queues	      &
\	ES.NAM$ = ""				!require entry name	      &
\	ES.PPN% = PPN%				!select own entries	      &
\	ES.SPEC$ = ENTRY$			!save entry-spec string	      &
						!			      &
\	ES.FLG%% = 1%+2%+4%+8%+32%+64%		!set options for entry-spec:  &
						!  1  = allow null queuename  &
						!  2  = allow wild queuename  &
						!  4  = allow null PPN	      &
						!  8  = allow wild PPN	      &
						! ~16 = disallow null entname &
						!  32 = allow wild entname    &
						!  64 = allow not own PPN     &
						!			      &
\	QUE.POS%, OWN.POS%, NAM.POS% = 0%	!init entry-spec pointers     &
\	U.POS% = ENT.POS%			!point to entry name parm     &
\	CALL ENTSPC (ES.SPEC$,ES.FLG%,ES.QUE$,ES.PPN%,ES.NAM$)		      &
						!parse entry-spec	      &
\	SUBEXIT IF ERRSTS% OR CC.FLG%		!exit if error or CTRL/C      &
						!			      &
\	ENT.CNT% = 0%				!show no entries seen yet     &
\	SEQ.IDX% = 0%				!init seq no. table index     &
\	SAV.SEQ% = 0%				!init to not save seq nos.    &
						!			      &
\	Z% = FN.GET.ENTRY%(3%)			!get 1st entry rec	      &
\	UNTIL ERRSTS% OR CC.FLG%		!until no entries or CTRL/C:  &
\		GOSUB 3100			!  go modify this entry	      &
\		Z% = FN.GET.ENTRY%(0%)		!  get next entry record      &
			UNLESS ERRSTS%		!    unless pending error     &
\	NEXT					!next (entry record)	      &
\	SUBEXIT IF CC.FLG% OR FATAL%		!exit if CTRL/C or fatal err  &
						!			      &
\	IF ENT.CNT% > 0% THEN			!if any entries selected,     &
		ERRSTS% = 0%			!  show no error	      &
	ELSE	ERRSTS% = ERR.NOTFND%		!else return not found status &
\		Z$ = ""				!  init queue type text	      &
\		Z$ = "print "			!  build 'print'	      &
			IF QTYP% = PRT.TYP%	!    if print queues	      &
\		Z$ = "batch "			!  build 'batch'	      &
			IF QTYP% = BAT.TYP%	!    if batch queues	      &
\		U.POS% = 0%			!  no repainting of cmd	      &
\		CALL DISPLY ("%No "+Z$+"entry "+ES.SPEC$+" found")	      &
						!  display error msg	      &
\	END IF					!end if			      &
						!			      &
\	RETURN					!and exit		      &

3100	!	m o d i f y   c u r r e n t   e n t r y - s p e c	      &
	!								      &
	!								      &
	MSG.TXT$ = ""				!clear message text	      &
\	GOSUB 4000				!go modify the entry	      &
\	RETURN IF CC.FLG%			!exit if CTRL/C		      &
\	IF LEN(MSG.TXT$) THEN			!if any message text,	      &
		U.POS% = 0%			!  disable repainting cmd     &
\		CALL DISPLY (MSG.TXT$)		!  display message	      &
\	END IF					!end if			      &
						!			      &
\	IF SAV.SEQ% THEN			!if need to save seq no.,     &
		SEQ.IDX% = SEQ.IDX% + 1%	!  incr table insert index    &
			UNLESS SEQ.IDX% >= 100%	!    unless already at max    &
\		SEQ.NO%(SEQ.IDX%) = PKT.SEQ%	!  save rec seq no. in table  &
\	END IF					!end if			      &
						!			      &
\	RETURN					!exit			      &

4000	!	c o m m o n   m o d i f y   r o u t i n e		      &
	!								      &
	!								      &
	ENT.CNT% = ENT.CNT% + 1%		!incr entry counter	      &
\	U.POS% = 0%				!disable repainting cmd	      &
						!			      &
\	SELECT QUE.TYP%				!select via queue type:	      &
\	CASE = PRT.TYP%				!case = print queue,	      &
\		Z$ = "print "			!  build 'print' text	      &
\	CASE = BAT.TYP%				!case = batch queue,	      &
\		Z$ = "batch "			!  build 'batch' text	      &
\	CASE ELSE				!case else,		      &
\		Z$ = ""				!  build null text	      &
\	END SELECT				!end select		      &
\	ENTRY$ = Z$ + "entry " + FN.ENTRY.ID$	!build entry ID string	      &
						!			      &
\	WRN.TXT$ = "%" + FN.CAP$(ENTRY$) + " "	!build warning text	      &
						!			      &
\	IF NOT FN.OWN.ENTRY% (PKT.JB.PPN%) THEN	!if not owner of entry,	      &
		IF OWN.REQ.FLG% OR		!  if ownership required or   &
		   NOT PBSCTL.FLG% THEN		!  no PBSCTL priv,	      &
			MSG.TXT$ = "%No owner rights to " + ENTRY$	      &
						!    build error message      &
\			RETURN			!    and exit		      &
\		END IF				!  end if		      &
\	END IF					!end if			      &
						!			      &
\	GOSUB 5000				!go SET non-type fields	      &
\	RETURN IF ERRSTS% OR CC.FLG%		!exit if error or CTRL/C      &
						!			      &
\	IF QUE.TYP% = PRT.TYP% THEN		!if print queue,	      &
		GOSUB 6000			!  go SET print fields	      &
\		RETURN IF ERRSTS% OR CC.FLG%	!  exit if error or CTRL/C    &
\	END IF					!end if			      &
						!			      &
\	IF QUE.TYP% = BAT.TYP% THEN		!if batch queue,	      &
		GOSUB 7000			!  go SET batch fields	      &
\		RETURN IF ERRSTS% OR CC.FLG%	!  exit if error or CTRL/C    &
\	END IF					!end if			      &
						!			      &
\	PKT.FLG% = SET.FLG%			!load set bits into flag      &
\	PKT.HDR$ = STRING$(LEN(PKT.HDR$),0%)	!zero packet header fields    &
\	PKT.VER$ = CHR$(PBS.VER%)		!load PBS version no.	      &
\	PKT.CMD$ = CHR$(MD.CMD%)		!load MODIFY command code     &
\	PKT.RTQ$ = CHR$(AK.FLG%)		!load return-ack flag	      &
\	CALL SEND (MD.LEN%,SEND.RETRY%)		!send MODIFY packet	      &
\	SUBEXIT IF ERRSTS%			!abort if errors	      &
		    OR CC.FLG%			!  or CTRL/C		      &
			OR NOSEND%		!    or NOSEND flag set	      &
						!			      &
\	Z% = RECV.WAIT%				!use work copy of wait secs   &
\	CALL RECV (Z%)				!wait for ACK packet	      &
\	SUBEXIT IF ERRSTS% OR CC.FLG%		!abort if errors or CTRL/C    &
						!			      &
\	IF ASCII(PKT.CMD$) = AK.CMD% THEN	!if ACK received,	      &
		ERRSTS% = 0%			!  clear error status	      &
\		MSG.TXT$ = FN.CAP$(ENTRY$) + " modified"		      &
						!  build deleted msg text     &
\		RETURN				!  and exit		      &
\	END IF					!end if			      &
						!			      &
						!NACK received:		      &
\	Z$ = ""					!init null message text	      &
\	EXC.MSG$ = "exceeds queue's maximum"	!init 'exceeds' msg text      &
						!			      &
\	ERRSTS% = PKT.STS%			!get error status	      &
\	SELECT ERRSTS%				!select via error status:     &
\	CASE = RMS.LBY%				!case = entry started,	      &
\		Z$ = "already started"		!  return error text	      &
\	CASE = RMS.RNF%				!case = entry not found,      &
\		ENT.CNT% = ENT.CNT% - 1%	!  decr entry counter	      &
\	CASE = RMS.IOP%				!case = priority too big,     &
\		Z$ = "- /PRIORITY " + EXC.MSG$	!  return error text	      &
\	CASE = RMS.PLG%				!case = page limit too big,   &
\		Z$ = "- /PAGE_LIMIT " + EXC.MSG$!  return error text	      &
\	CASE = RMS.ISI%				!case = CPU limit too big,    &
\		Z$ = "- /CPU_LIMIT " + EXC.MSG$	!  return error text	      &
\	CASE = RMS.IRC%				!case = time limit too big,   &
\		Z$ = "- /TIME_LIMIT " + EXC.MSG$!  return error text	      &
\	CASE ELSE				!case else,		      &
\		FATAL% = TRUE%			!  set fatal error flag	      &
\		ERRNAM$ = MODULE$		!  return bad module name     &
\	END SELECT				!end select		      &
						!			      &
\	ERRSTS% = 0%				!always return success	      &
		UNLESS FATAL%			!  unless fatal error	      &
\	MSG.TXT$ = WRN.TXT$ + Z$		!append warning msg prefix    &
		IF LEN(Z$)			!  if any text selected	      &
						!			      &
\	RETURN					!and exit		      &

5000	!	S E T   n o n - t y p e   f i e l d s			      &
	!								      &
	!								      &
	ERRSTS% = 0%				!init status for success      &
						!			      &
\	IF SET.FLG% AND AFT.BIT% THEN		!if /[NO]AFTER,		      &
		PKT.JB.ADA% = JB.ADA%		!  update after date	      &
\		PKT.JB.ATI% = JB.ATI%		!  update after time	      &
\	END IF					!end if			      &
						!			      &
\	IF SET.FLG% AND PRI.BIT% THEN		!if /PRIORITY,		      &
		SAV.SEQ% = (PKT.JB.PRI$>JB.PRI$)!  set flag if lowered	      &
\		PKT.JB.PRI$ = JB.PRI$		!  update priority field      &
\	END IF					!end if			      &
						!			      &
\	RETURN					!exit			      &

6000	!	S E T   p r i n t   t y p e   f i e l d s		      &
	!								      &
	!								      &
	ERRSTS% = 0%				!init status for success      &
						!			      &
\	IF SET.FLG% AND FRM.BIT% THEN		!if /FORMS,		      &
		PKT.JB.FML$ = JB.FML$		!  update form length field   &
\		PKT.JB.FRM$ = JB.FRM$		!  update form name field     &
\	END IF					!end if			      &
						!			      &
\	IF SET.FLG% AND JBC.BIT% THEN		!if /JOB_COUNT,		      &
		PKT.JB.COP% = JB.COP%		!  update job copies field    &
\	END IF					!end if			      &
						!			      &
\	IF SET.FLG% AND PAG.BIT% THEN		!if /PAGE_LIMIT,	      &
		PKT.JB.PGL% = JB.PGL%		!  update page limit lsb      &
\		PKT.JB.PGM% = JB.PGM%		!  update page limit msb      &
\	END IF					!end if			      &
						!			      &
\	RETURN					!exit			      &

7000	!	S E T   b a t c h   t y p e   f i e l d s		      &
	!								      &
	!								      &
	ERRSTS% = 0%				!init status for success      &
						!			      &
\	IF SET.FLG% AND CPU.BIT% THEN		!if /CPU_LIMIT,		      &
		PKT.JB.CPU% = JB.CPU%		!  update CPU limit field     &
\	END IF					!end if			      &
						!			      &
\	IF SET.FLG% AND TIM.BIT% THEN		!if /TIME_LIMIT,	      &
		PKT.JB.TIM% = JB.TIM%		!  update time limit field    &
\	END IF					!end if			      &
						!			      &
\	RETURN					!exit			      &

10100	!	p r o c e s s   / [ N O ] A F T E R   q u a l i f i e r	      &
	!								      &
	!								      &
	AFT.POS% = U.POS%			!save qual position	      &
\	SET.FLG% = SET.FLG% OR AFT.BIT%		!set AFTER flag		      &
\	OWN.REQ.FLG% = TRUE%			!set 'ownership req'd' flag   &
						!			      &
\	IF U.NO% THEN				!if /NOAFTER,		      &
		JB.ADA% = 0%			!  zero after date	      &
\		JB.ATI% = 0%			!  zero after time	      &
						!			      &
	ELSE	CALL FET$A BY REF		!else fetch the args	      &
\		U.DATE% = TODAY%		!  use today's date	      &
			UNLESS U.DATE%		!    unless one specified     &
\		U.TIME% = END.DAY%		!  use 11:59PM		      &
			UNLESS U.TIME%		!    unless one specified     &
\		JB.ADA% = U.DATE%		!  save after date	      &
\		JB.ATI% = FN.TIME%(U.TIME%)	!  save after time	      &
\	END IF					!end if			      &
						!			      &
\	RETURN					!exit			      &

10200	!	p r o c e s s   / C P U _ L I M I T   q u a l i f i e r	      &
	!								      &
	!								      &
	CPU.POS% = U.POS%			!save qual position	      &
\	SET.FLG% = SET.FLG% OR CPU.BIT%		!set CPU_LIMIT flag	      &
\	OWN.REQ.FLG% = TRUE%			!set 'ownership req'd' flag   &
						!			      &
\	CALL FET$A BY REF			!fetch priority arg	      &
\	CALL FET$KA BY REF (UNL.K%)		!fetch UNLIMITED keyword      &
\	IF U.PRES% THEN				!if present,		      &
		U.LOW% = -1%			!  force value to -1	      &
	ELSE	CALL FET$A BY REF		!else fetch the argument      &
\	END IF					!end if			      &
\	JB.CPU% = U.LOW%			!save value		      &
						!			      &
\	RETURN					!exit			      &

10300	!	p r o c e s s   / F O R M S   q u a l i f i e r		      &
	!								      &
	!								      &
	FRM.POS% = U.POS%			!save qual position	      &
\	SET.FLG% = SET.FLG% OR FRM.BIT%		!set JOB_COUNT flag	      &
\	OWN.REQ.FLG% = TRUE%			!set 'ownership req'd' flag   &
						!			      &
\	CALL FET$A BY REF			!fetch the arg		      &
\	Z$ = SEG$(U.STR$,1%,U.LEN%)		!save form name		      &
\	CALL GETFRM (Z$,"",FALSE%)		!lookup form in FDF	      &
\	RETURN IF ERRSTS%			!exit if not found	      &
\	JB.FML$ = CHR$(LEN(Z$))			!save form-name length	      &
\	JB.FRM$ = Z$				!save form-name		      &
						!			      &
\	RETURN					!and exit		      &

10400	!	p r o c e s s   / H O L D   q u a l i f i e r		      &
	!								      &
	!								      &
	HLD.POS% = U.POS%			!save qual position	      &
\	SET.FLG% = SET.FLG% OR HLD.BIT%		!set HOLD flag		      &
						!			      &
\	RETURN					!exit			      &

10500	!	p r o c e s s   / J O B _ C O U N T   q u a l i f i e r	      &
	!								      &
	!								      &
	JBC.POS% = U.POS%			!save qual position	      &
\	SET.FLG% = SET.FLG% OR JBC.BIT%		!set JOB_COUNT flag	      &
\	OWN.REQ.FLG% = TRUE%			!set 'ownership req'd' flag   &
						!			      &
\	CALL FET$A BY REF			!get the arg		      &
\	JB.COP% = U.LOW%			!save value		      &
						!			      &
\	RETURN					!exit			      &

10550	!	p r o c e s s   / [ N O ] N O T I F Y   q u a l i f i e r     &
	!								      &
	!								      &
	NTF.POS% = U.POS%			!save qual position	      &
\	IF U.NO% THEN				!if /NONOTIFY,		      &
		SET.FLG% = SET.FLG% OR NNT.BIT%	!  set NONOTIFY flag	      &
	ELSE	SET.FLG% = SET.FLG% OR NTF.BIT%	!else set NOTIFY flag	      &
\	END IF					!end if			      &
\	OWN.REQ.FLG% = TRUE%			!set 'ownership req'd' flag   &
\	RETURN					!exit			      &

10600	!	p r o c e s s   / P A G E _ L I M I T   q u a l i f i e r     &
	!								      &
	!								      &
	PGL.POS% = U.POS%			!save qual position	      &
\	SET.FLG% = SET.FLG% OR PAG.BIT%		!set PAGE_LIMIT flag	      &
\	OWN.REQ.FLG% = TRUE%			!set 'ownership req'd' flag   &
						!			      &
\	CALL FET$KA BY REF (UNL.K%)		!fetch UNLIMITED keyword      &
\	IF U.PRES% THEN				!if present,		      &
		U.LOW%,U.HIGH% = -1%		!  force values to -1	      &
	ELSE	CALL FET$A BY REF		!else fetch the argument      &
\	END IF					!end if			      &
\	JB.PGL% = U.LOW%			!save lsb value		      &
\	JB.PGM% = U.HIGH%			!save msb value		      &
						!			      &
\	RETURN					!exit			      &

10700	!	p r o c e s s   / P R I O R I T Y   q u a l i f i e r	      &
	!								      &
	!								      &
	PTY.POS% = U.POS%			!save qual position	      &
\	SET.FLG% = SET.FLG% OR PRI.BIT%		!set PRIORITY flag	      &
\	CALL FET$A BY REF			!fetch priority arg	      &
\	JB.PRI$ = CHR$(U.LOW%)			!save priority value	      &
						!			      &
\	RETURN					!exit			      &

10800	!	p r o c e s s   / R E L E A S E   q u a l i f i e r	      &
	!								      &
	!								      &
	REL.POS% = U.POS%			!save qual position	      &
\	SET.FLG% = SET.FLG% OR REL.BIT%		!set RELEASE flag	      &
						!			      &
\	RETURN					!exit			      &

10900	!	p r o c e s s   / T I M E _ L I M I T   q u a l i f i e r     &
	!								      &
	!								      &
	TIM.POS% = U.POS%			!save qual position	      &
\	SET.FLG% = SET.FLG% OR TIM.BIT%		!set TIME_LIMIT flag	      &
\	OWN.REQ.FLG% = TRUE%			!set 'ownership req'd' flag   &
						!			      &
\	CALL FET$A BY REF			!fetch priority arg	      &
\	CALL FET$KA BY REF (UNL.K%)		!fetch UNLIMITED keyword      &
\	IF U.PRES% THEN				!if present,		      &
		U.LOW% = -1%			!  force value to -1	      &
	ELSE	CALL FET$A BY REF		!else fetch the argument      &
\	END IF					!end if			      &
\	JB.TIM% = U.LOW%			!save value		      &
						!			      &
\	RETURN					!exit			      &

15000	!	f n . u n s i g n e d % ( FL.PT )			      &
	!								      &
	!								      &
	!inputs:	VALUE		-	floating-pt value 0 to 65535  &
	!								      &
	!outputs:	FN.UNSIGNED%	-	unsigned 16-bit integer	      &
	!								      &
	!uses:		None.						      &
	!								      &
	!								      &
	DEF FN.UNSIGNED% (FL.PT)					      &
\	FL.PT = 0.				!force to 0		      &
		IF FL.PT < 0. OR FL.PT > 65535.	!  if not in range 0-65535    &
\	FL.PT = FL.PT - 65536.			!normalize (-32768,+32767)    &
		IF FL.PT > 32767.		!  if over max pos integer    &
\	FN.UNSIGNED% = FL.PT			!return unsigned integer      &
\	FNEND					!end FN.UNSIGNED% function    &

15100	!	f n . u n s i g n e d ( VALUE% )			      &
	!								      &
	!inputs:	VALUE%		-	16-bit unsigned integer	      &
	!								      &
	!outputs:	FN.UNSIGNED	-	corresponding FL-PT value     &
	!								      &
	!uses:		Z		-	work FL-PT		      &
	!								      &
	!								      &
	DEF FN.UNSIGNED (VALUE%)					      &
\	Z = VALUE%				!move to fl-pt variable	      &
\	Z = Z + 65536.				!normalize to 0		      &
		IF Z < 0.			!  if negative		      &
\	FN.UNSIGNED = Z				!  return fl-pt value	      &
\	FNEND					!end FN.UNSIGNED function     &

15200	!	f n . p p n $ ( PPN% )					      &
	!								      &
	!inputs:	PPN%		-	PPN word		      &
	!								      &
	!outputs:	FN.PPN$		-	PPN string "[proj,prog]"      &
	!								      &
	!uses:		Z%		-	work integer		      &
	!		Z1$, Z2$	-	work strings		      &
	!								      &
	!								      &
	DEF FN.PPN$ (PPN%)						      &
\	Z1$, Z2$ = "*"				!init proj,prog strings	      &
\	Z% = SWAP%(PPN%) AND 255%		!get project no.	      &
\	Z1$ = NUM1$(Z%)				!build project string	      &
		UNLESS Z% = 255%		!  unless wild		      &
\	Z% = PPN% AND 255%			!get programmer no.	      &
\	Z2$ = NUM1$(Z%)				!build programmer string      &
		UNLESS Z% = 255%		!  unless wild		      &
\	FN.PPN$ = "[" + Z1$ + "," + Z2$ + "]"	!return PPN string	      &
\	FNEND					!end FN.PPN$ function	      &

15300	!	f n . e n t r y . i d $					      &
	!								      &
	!								      &
	!inputs:	PKT.QNM$	-	entry's queue name	      &
	!		PKT.QNL$	-	entry's queue name length     &
	!		PKT.JB.PPN%	-	entry's PPN		      &
	!		PKT.JB.NAM$	-	entry's name		      &
	!		PKT.JB.NML$	-	entry's name length	      &
	!								      &
	!outputs:	FN.ENTRY.ID$	-	entry ID string in the form   &
	!					  "n queue:[ppn]name"	      &
	!								      &
	DEF FN.ENTRY.ID$ =						      &
		  NUM1$(FN.UNSIGNED(PKT.SEQ%))	!entry no.		      &
		+ " " + SEG$(PKT.QNM$,1%,ASCII(PKT.QNL$)) + ":"		      &
						!append queue name	      &
		+ FN.PPN$(PKT.JB.PPN%)		!append PPN		      &
		+ SEG$(PKT.JB.NAM$,1%,ASCII(PKT.JB.NML$))		      &
						!append entry name	      &

15400	!	f n . o w n . e n t r y % ( ACC.PPN% )			      &
	!								      &
	!inputs:	ACC.PPN%	-	entry's PPN to check	      &
	!		PPN%		-	user's PPN		      &
	!								      &
	!outputs:	FN.OWN.ENTRY%	-	ownership flag:		      &
	!					  TRUE  -> owner access	      &
	!					  FALSE -> no owner access    &
	!								      &
	!notes:	This function determines if the user has owner access to the  &
	!	current entry, based on the user's PPN and the entry's PPN.   &
	!								      &
	!	A user has ownership of an entry if:			      &
	!								      &
	!		1) The user has WACNT privilege			      &
	!	or	2) The user has GACNT privilege and the PPN's	      &
	!		   project number matches the user's		      &
	!		3) The entry's PPN matches the user's		      &
	!								      &
	!								      &
	DEF FN.OWN.ENTRY% (ACC.PPN%)					      &
\	IF ACC.PPN% = PPN% THEN			!if same ppn,		      &
		FN.OWN.ENTRY% = TRUE%		!  return TRUE		      &
	ELSE	CHANGE SYS (			!else do UU.CHK SYS call:     &
			CHR.6$ +		!    FIP call		      &
			CHR$(32%) +		!    check access function    &
			CHR.00$ +		!    reserved		      &
			CHR$(ACC.PPN%) +	!    prog no. to check	      &
			CHR$(SWAP%(ACC.PPN%))	!    proj no. to check	      &
			   ) TO FIRQB%		!  end of sys call	      &
						!			      &
\		FN.OWN.ENTRY% = ((FIRQB%(3%) AND 128%) <> 0%)		      &
						!  return ownership flag      &
\	END IF					!end if			      &
						!			      &
\	FNEND					!end FN.OWN.ENTRY% function   &

15500	!	f n . t i m e % ( TIME.INT% )				      &
	!								      &
	!								      &
	!inputs:	TIME.INT%	-	minutes until/since midnight  &
	!								      &
	!outputs:	FN.TIME%	-	inverted time integer	      &
	!								      &
	!uses:		none.						      &
	!								      &
	!notes:		The standard RSTS time integer is defined as minutes  &
	!		until midnight.  However, time integers	are defined   &
	!		in PBS as minutes since midnight.  This function will &
	!		"invert" a time integer, allowing its use for both    &
	!		encoding and decoding PBS/RSTS time integers.	      &
	!								      &
	!								      &
	DEF FN.TIME% (TIME.INT%) =					      &
		1440% - TIME.INT%		!invert time value	      &

15600	!	f n . g e t . e n t r y % ( GET.MODE% )			      &
	!								      &
	!								      &
	!inputs:	GET.MODE%	-	initial GET mode to use	      &
	!		QTYP%		-	entry's queue type to select  &
	!		ES.QUE$		-	entry's queue to select	      &
	!		ES.NAM$		-	entry's name to select	      &
	!		ES.PPN%		-	entry's PPN to select	      &
	!		JFRM$		-	entry's form name to select   &
	!								      &
	!outputs:	FN.GET.ENTRY%	-	select-entry status:	      &
	!					   TRUE% - entry selected     &
	!					  FALSE% - no entry selected  &
	!		ERRSTS%		-	error status:		      &
	!					  0 = no error (rec found)    &
	!					  n = error (rec not found)   &
	!		QUE.TYP%	-	entry rec's queue type	      &
	!		ENT.QUE$	-	entry rec's queue name	      &
	!		ENT.NAM$	-	entry rec's name	      &
	!		ENT.FRM$	-	entry rec's form name	      &
	!								      &
	!uses:		Z$		-	local work string	      &
	!								      &
	!notes:								      &
	!								      &
	! This function is called to return the next entry definition  record &
	! (EDR),  based  on  the selection values specified above.  The value &
	! GET.MODE% (0-3) is used by this function in  its  initial  call  to &
	! GETREC, to allow  the caller to decide how to get the initial entry &
	! record.  Mode 0 (GET NEXT) should be specified if at least one  EDR &
	! has  been  read and no other non-EDRs have been read since the last &
	! call; otherwise, mode 1 (GET EQ) should be specified, with QUE.TYP% &
	! set accordingly.  Once the  initial GET is performed, the record is &
	! tested  to ensure that it is actually a EDR;  if  not  the function &
	! exits with status ERR.NOTFND%. Otherwise, a check is made to see if &
	! the EDR should  be selected, based on the selection values.  If the &
	! EDR  is  selected,  the  function  exits  with  success status (0); &
	! otherwise, a GET NEXT is performed and the process repeats.	      &
	!								      &
	! A special SEQ.NO% table is used if /PRIORITY was specified.  In     &
	! such a case, lowering an ertry's priority will cause it to be	      &
	! logically repositioned later in the file, causing it to be accessed &
	! twice.  To prevent this, the sequence number of each entry returned &
	! by this function is saved in a table.  If an entry is read whose    &
	! sequence number is found in the table, then the record is skipped.  &
	!								      &
	!								      &
	DEF FN.GET.ENTRY% (GET.MODE%)					      &
\	FNEXIT IF CC.FLG%			!exit if CTRL/C		      &
\	Z$ = CHR$(QTYP%) + STRING$(5%,0%)	!build search key	      &
		IF GET.MODE%			!  unless get-next mode	      &
\	FN.GET.ENTRY% = FALSE%			!set fn val = rec not found   &

15610	CALL GETREC (GET.MODE%,1%,Z$)		!get initial entry record     &
\	FNEXIT IF CC.FLG%			!exit if CTRL/C		      &
\	QUE.TYP% = ASCII(PKT.QUE$)		!save entry's queue type      &
\	ERRSTS% = ERR.NOTFND%			!return not-found error	      &
		IF QUE.TYP% AND (NOT 15%)	!  if not a entry record      &
			UNLESS ERRSTS%		!    unless pending error     &
\	FNEXIT IF ERRSTS%			!exit if any error	      &
\	GET.MODE% = 0%				!use GET NEXT mode now	      &
						!			      &
\	GOTO 15610				!skip this entry	      &
		IF QTYP% <> QUE.TYP%		!  if different types	      &
			IF QTYP%		!    if single queue type     &
\	GOTO 15610				!skip this entry	      &
		UNLESS FN.MATCH.PPN%(PKT.JB.PPN%,ES.PPN%)		      &
						!  unless PPN's match	      &
\	ENT.QUE$ = SEG$(PKT.QNM$,1%,ASCII(PKT.QNL$))			      &
						!extract queue name	      &
\	GOTO 15610				!skip this entry	      &
		UNLESS FN.MATCH.NAME%(ENT.QUE$,ES.QUE$)			      &
						!  unless queue-names match   &
			IF LEN(ES.QUE$)		!    if select by queue-name  &
						!			      &
\	ENT.NAM$ = SEG$(PKT.JB.NAM$,1%,ASCII(PKT.JB.NML$))		      &
						!extract entry name	      &
\	GOTO 15610				!skip this entry	      &
		UNLESS FN.MATCH.NAME%(ENT.NAM$,ES.NAM$)			      &
						!  unless entry-names match   &
			IF LEN(ES.NAM$)		!    if select by entry-name  &
						!			      &
\	GOTO 15610				!skip this entry	      &
		IF PKT.SEQ% = SEQ.NO%(Z%)	!  if seq no. found in table  &
			FOR Z% = 1% TO SEQ.IDX%	!    for all entries in table &
						!			      &
\	FN.GET.ENTRY% = TRUE%			!set fn val = rec found	      &
\	FNEND					!end FN.GET.ENTRY% function   &

15700	!	f n . m a t c h . p p n % ( PPN.1% , PPN.2% )		      &
	!								      &
	!								      &
	!inputs:	PPN.1%		-	queue rec PPN		      &
	!		PPN.2%		-	PPN word to match	      &
	!					  (255 = wildcard)	      &
	!								      &
	!outputs:	FN.MATCH.PPN%	-	returned match status:	      &
	!					  TRUE% = PPN's match	      &
	!					 FALSE% = PPN's don't match   &
	!								      &
	!uses:		Z0%		-	loop index		      &
	!		Z1%		-	1st PPN's byte value	      &
	!		Z2%		-	2nd PPN's byte value	      &
	!								      &
	!								      &
	DEF FN.MATCH.PPN% (PPN.1%,PPN.2%)				      &
\	FN.MATCH.PPN% = FALSE%			!init fn value as no match    &
\	FOR Z0%= 1% TO 2%			!do for each PPN byte:	      &
\		Z1% = PPN.1% AND 255%		!  get lo byte of 1st ppn     &
\		Z2% = PPN.2% AND 255%		!  get lo byte of 2nd ppn     &
\		FNEXIT				!  exit (no match)	      &
			IF Z1% <> Z2% 		!    if bytes don't match,    &
				IF Z2% <> 255%	!      if byte not wild	      &
\		PPN.1% = SWAP%(PPN.1%)		!  swap 1st ppn bytes	      &
\		PPN.2% = SWAP%(PPN.2%)		!  swap 2nd ppn bytes	      &
\	NEXT Z0%				!continue for hi bytes	      &
\	FN.MATCH.PPN% = TRUE%			!match if loop completes      &
\	FNEND					!end FN.MATCH.PPN% function   &

15800	!	f n . m a t c h . n a m e $ ( NAM.1$ , NAM.2$ )		      &
	!								      &
	!								      &
	!inputs:	NAM.1$		-	entry name string	      &
	!		NAM.2$		-	name string to match	      &
	!								      &
	!outputs:	FN.MATCH.NAME%	-	returned match status:	      &
	!					   TRUE% = names match	      &
	!					  FALSE% = names don't match  &
	!								      &
	!uses:		Z0%		-	loop index		      &
	!		NAM.1%()	-	work table for entry name     &
	!		NAM.2%()	-	work table for match name     &
	!								      &
	!notes:		This function compares a entry name string (NAM.1$)   &
	!		against a match name string (NAM.2$). The match name  &
	!		string may contain a '*' or multiple '?' wildcard     &
	!		characters (always match).			      &
	!								      &
	!		If the match name string is null or *, then the	      &
	!		function returns TRUE% (match), regardless of the     &
	!		entry name string.				      &
	!								      &
	!		If the match string contains a trailing *, then	      &
	!		the * is replaced with enough ?'s to fill the string  &
	!		to a length of nine characters.			      &
	!								      &
	!								      &
	DEF FN.MATCH.NAME% (NAM.1$,NAM.2$)				      &
\	IF LEN(NAM.2$) = 0%			!if null match name	      &
	   OR NAM.2$ = "*" THEN			! or wildcard match name,     &
		FN.MATCH.NAME% = TRUE%		!  return match		      &
\		FNEXIT				!  and exit		      &
\	END IF					!end if			      &
						!			      &
\	Z0% = POS(NAM.2$,"*",LEN(NAM.2$))	!look for trailing * char     &
\	IF Z0% > 0% THEN			!if any found,		      &
		NAM.2$ = SEG$(NAM.2$,1%,Z0%-1%) +			      &
			 STRING$(9%-Z0%+1%,ASCII("?"))			      &
						!  replace * with ?'s	      &

15810	CHANGE EDIT$(NAM.1$,2%+4%) TO NAM.1%	!move entry name into array   &
\	CHANGE EDIT$(NAM.2$,2%+4%) TO NAM.2%	!move match name into array   &
\	FN.MATCH.NAME% = FALSE%			!init fn value as no match    &
						!			      &
\	FNEXIT					!exit with no match	      &
		IF NAM.1%(0%) > NAM.2%(0%)	!  if entry name is longer    &
						!			      &
\	FNEXIT					!exit with no match	      &
		IF NAM.1%(Z0%) <> NAM.2%(Z0%)	!  if chars don't match	      &
			IF NAM.2%(Z0%) <> ASCII("?")			      &
						!    if not wildcard char     &
				FOR Z0% = 1% TO NAM.1%(0%)		      &
						!      for each char	      &
						!			      &
\	FNEXIT					!exit with no match	      &
		IF NAM.2%(Z0%) <> ASCII("?")	!  if next char not wild      &
			FOR Z0% = NAM.1%(0%)+1% TO NAM.2%(0%)		      &
						!    for remaining chars      &
						!			      &
\	FN.MATCH.NAME% = TRUE%			!match if loops complete      &
\	FNEND					!end FN.MATCH.NAME% function  &

15900	!	f n . p r i v % ( P R I V $ )				      &
	!								      &
	!								      &
	!inputs:	PRIV$		-	priv name to check	      &
	!								      &
	!outputs:	FN.PRIV%	-	privilege status:	      &
	!					  TRUE  -> priv on	      &
	!					  FALSE -> priv off	      &
	!								      &
	!		ERRSTS%		-	0 if priv on		      &
	!					ERR.PRVIOL if priv off	      &
	!					ERR.BADNAM if invalid priv    &
	!								      &
	DEF FN.PRIV%(PRIV$)			!start definition	      &
\	ON ERROR GOTO 15910			!local error routine	      &
\	ERRSTS% = 0%				!clear ERRSTS		      &
\	PRIV$ = EDIT$(PRIV$,-1%)		!trim the priv name string    &
\	Z$ = SYS (				!do check priv SYS call:      &
		CHR.6$ +			!  FIP call		      &
		CHR$(32%) +			!  check access function      &
		CHR$(1%) +			!  check priv name subfun     &
		CHR.0$ +			!  reserved		      &
		CHR.00$ +			!  reserved		      &
		PRIV$				!  priv name to check	      &
		 )				!end of sys call	      &
\	Z%,FN.PRIV% = (ASCII(SEG$(Z$,3%,3%)) = 0%)			      &
						!return priv status	      &
\	IF NOT Z% THEN				!if priv not enabled,	      &
		CALL DISPLY ("?"+PRIV$+" privilege required")		      &
						!  display error message      &
\		ERRSTS% = ERR.PRVIOL%		!  and return PRVIOL error    &
\	END IF					!end if			      &
\	GOTO 15920				!skip to function exit	      &

15910	ERRSTS% = ERR.BADNAM%			!set bad priv name	      &
\	CALL DISPLY ("?Invalid privilege name")	!display error message	      &
\	FN.PRIV% = FALSE%			!return priv disabled	      &
\	RESUME 15920				!resume to function end	      &

15920	FNEND					!end FN.PRIV% function	      &

16000	!	f n . e n t r y % ( ENTRY$ )				      &
	!								      &
	!								      &
	!inputs:	ENTRY$		-	entry string		      &
	!								      &
	!outputs:	FN.ENTRY%	-	entry number in range 1-9999  &
	!					0 if not an entry number      &
	!		ERRSTS%		-	error status:		      &
	!					     0 = valid entry no. or 0 &
	!					   <>0 = invalid entry no.    &
	!								      &
	!uses:		Z		-	work fl-pt		      &
	!								      &
	!notes:	This function determines whether an entry string is numeric   &
	!	(indicating an entry number), or non-numeric (indicating an   &
	!	entry-spec).  If non-numeric, then 0 is returned.  If entry   &
	!	number, then ensures in range 1-9999.  If in range, then the  &
	!	entry number is returned with ERRSTS%=0.  If out of range,    &
	!	then entry number 0 is returned with ERRSTS% = ERR.BADNAM%.   &
	!								      &
	!								      &
	DEF FN.ENTRY% (ENTRY$)						      &
\	ON ERROR GOTO 16010			!trap own errors	      &
\	ERRSTS% = 0%				!init success		      &
\	Z = VAL(ENTRY$)				!try to convert to number     &
\	IF POS(ENTRY$,"+",1%) OR		!if includes + sign,	      &
	   POS(ENTRY$,"-",1%) OR		!or includes - sign,	      &
	   POS(ENTRY$,".",1%) THEN		!or includes decimal point,   &
		FN.ENTRY% = 0%			!  return entry no. = 0	      &
\		GOTO 16020			!  and skip to exit	      &
\	END IF					!end if			      &
						!			      &
\	IF (Z >= 1.) AND (Z <= 9999.) THEN	!if entry no. in range,	      &
		FN.ENTRY% = Z			!  return entry no.	      &
	ELSE	ERRSTS% = ERR.BADNAM%		!else return BADNAM error     &
\		FN.ENTRY% = 0%			!  return entry no. = 0	      &
\		CALL DISPLY ("?Number not in range 1 to 9999")		      &
						!  display error message      &
\	END IF					!end if			      &
\	GOTO 16020				!skip to exit		      &

16010	FN.ENTRY% = 0%				!return entry no. 0	      &
\	RESUME 16020				!resume to exit fn	      &

16020	FNEND					!end FN.NUMERIC% function     &

16100	!	f n . c a p $ ( TEXT$ )					      &
	!								      &
	!								      &
	!inputs:	TEXT$		-	text string to capitalize     &
	!								      &
	!outputs:	FN.CAP$		-	text string with u/c 1st char &
	!								      &
	!								      &
	DEF FN.CAP$(TEXT$) =						      &
		EDIT$(SEG$(TEXT$,1%,1%),32%) + SEG$(TEXT$,2%,MAXINT%)	      &
						!return converted string      &

19000	!	s t a n d a r d   e r r o r   h a n d l i n g		      &
	!								      &
	!								      &
	FATAL% = TRUE%				!set fatal error flag	      &
\	ERRSTS% = ERR				!save error no.		      &
\	ERRLIN% = ERL				!save error line no.	      &
\	ERRNAM$ = ERN$				!save module name	      &
\	RESUME 32767				!resume to exit		      &

32767	!	e n d   o f   s u b p r o g r a m			      &
	!								      &
	!								      &
	SUBEND
