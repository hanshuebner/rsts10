TITLE	DIAMNT,<DIALOGUE MOUNT ROUTINES>,0A,10-MAY-91,JBL/GPK/MNB

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	Edit history for DIAMNT

;+
;
;  000	GPK  10-Aug-82	Changes for init boot work
;  001  MNB  03-MAR-83  CHANGE DCN'S TO BLOCKS BEFORE EXPAND: CALL	;MNB001
;
;-

.SBTTL	DIAMNT DATA AND TEXT

	I.DATA
INIDCN:	.BLKW0			;ADDRESS WHERE INIT DCN'S GO INTO INIT
	UNORG

	I.MESS
	.ENABL	LC
BADINI:	.ASCIZ	"Bad INIT.SYS on system disk"<200>
BADSAT:	.ASCIZ	"Bad block in SATT.SYS"<200>
NOINI:	.ASCIZ	"No INIT.SYS on system disk"<200>
SBINI:	.ASCIZ	"Can't write INIT.SYS"<200>
	.EVEN
	UNORG

.SBTTL	DIVU - UNSIGNED DIVIDE - (R4,R5)/R3

;+
; DIVU - UNSIGNED DIVIDE
;
;	CALL:	R4,R5 = DIVIDEND (R5 - LSB, R4 - MSB)
;		R3 = DIVISOR
;		CALL	DIVU
;
;	RETURN:	R0 = QUOTIENT (FOR PRINTING)
;		R4 AND R5 GARBAGED
;-

.ENABL	LSB

DIVU:	MOV	#17.,R0		;BIT COUNTER
	CLC			;DON'T BRANCH FIRST TIME THRU
10$:	BCS	15$		;IF CARRY FROM MSB ALWAYS SUBTRACT DIVISOR
	CMP	R3,R4		;DIVISOR .GT. HIGH ORDER OF DIVIDEND ?
	BHI	20$		;YES - DON'T SUBTRACT DIVISOR
15$:	SUB	R3,R4		;NO
	SEC			;FOR ROL
20$:	ROL	R5		;SHIFT DIVIDEND LEFT ONE
	ROL	R4
	SOB	R0,10$		;DO FOR ALL BITS IN WORD + 1
	MOV	R5,R0		;PUT RESULT IN R0 FOR PRINTING
	RETURN

.DSABL	LSB


.SBTTL	ALLOC - DETERMINE # OF ALLOCATED PC'S

;+
; ALLOC - DETERMINE, FROM THE SOURCE DISK SATT, THE NUMBER OF ALLOCATED PC'S
;
;	CALL:	R3 = LINK TO FIRST SATT.SYS RETRIEVAL ENTRY
;		CALL	ALLOC
;
;	RETURN: C=1 IF USER DOES NOT WANT TO USE DISK AS THERE ARE
;	        TOO FEW UNALLOCATED CLUSTERS (PC'S)
;	        R1 = # ALLOCATED CLUSTERS
;-

.ENABL	LSB

ALLOC:	REGSCR			;SAVE REGISTERS
	CALL	FSRDB		;GET [0,1]SATT.SYS RETRIEVAL ENTRY
	BCS	80$		;ERROR
	TST	(R5)+		;SKIP UP TO DCN OF FIRST CLUSTER
	MOV	(R5),R2		;PUT IT IN R2
	CALLX	CNVRIB		;PUT CORRESPONDING FBN IN R2/R3
	MOV	SATSYS+BYTS,R1	;# OF BYTES TO TRANSFER
	ASR	R1		;MAKE IT WORDS
	MOV	#SATBUF,BUFPTR	;PREPARE TO READ IN THE SAT
	CALL	RDSKIO,R5	;READ IT
	  BR	90$		;BAD BLOCK ERROR
	  CLR	R3		;SUCCESS - CLEAR SATT BYTE POINTER
	CLR	R1		;CLEAR ALLOCATED PACK CLUSTER
	MOV	#1,R5		;START AT BIT 0
	MOV	SATSYS+BITS,R0	;GET # PACK CLUSTERS ON THIS DISK
10$:	BITB	R5,SATBUF(R3)	;TEST BIT
	BEQ	20$		;NOT SET
	INC	R1		;ADD 1 TO ALLOCATED PC COUNT
20$:	ASLB	R5		;NEXT BIT IN BYTE
	BCC	30$		;STILL BITS IN BYTE
	INC	R3		;ON TO NEXT BYTE
	INC	R5		;BACK TO BIT 0
30$:	SOB	R0,10$		;LOOP IF MORE PACK CLUSTERS
	MOV	R1,TOS.R1(SP)	;R1 WILL = # ALLOC. PC'S ON EXIT
	MOV	SATSYS+BITS,R3	;GET NUMBER OF PACK CLUSTERS
	MOV	R3,R4		;COPY TO R4
	SUB	R1,R4		;COMPUTE NUMBER OF FREE CLUSTERS
	MUL	#100.,R4	
	BPL	40$		;WE'RE POSITIVE SO IT'S OK
	ADD	#100.,R4	;NEGATIVE - ADD BACK IN 100.*65536.
40$:	CALL	DIVU		;DO UNSIGNED DIVIDE - RESULT IN R0
	CMP	#10.,R0		;R0 LESS THAN 10% ?
	BLOS	60$		;NO
	CALL	JPERC		;'%%% '
	MESSAG	<"Input disk has only ">
	CALLX	DECZER		;PRINT INTEGRAL PERCENTAGE
	MESSAG	<"% free clusters"<200>>
	CALLX	YESNO,R5	;MOUNT IT ANYWAY ?
	  .WORD	50$
	  GENTXT
	   .ASCII <200>
	   .ASCII "There are very few free clusters on the input disk."<200>
	   .ASCII "Therefore, it is recommended that files be  deleted"<200>
	   .ASCII "before continuing."<200>
50$:	   .ASCIZ "Mount it anyway <NO> ? "
	  UNORG
	 BR	70$		;CTRL/Z - GO BACK
	 BR	70$		;LF - DEFAULT IS NO
	 BR	70$		;NO
60$:	 CALLX	SAVSAT		;YES - THROW SATT UP INTO SATBF2 (SO THAT
				; IT IS RESTORED ON EXIT FROM MOUNT)
	CALLX	GETTTY		;KEEP CLOCK GOING
	TST	(PC)+		;ALL IS WELL - POP OVER THE SEC
70$:	SEC			;ERROR
	RETURN

80$:	MOV	#BADDIR,ERRADR	;%%% BAD DIRECTORY
	BR	70$

90$:	MOV	#BADSAT,ERRADR	;%%% BAD BLOCK IN SATT
	BR	70$

GLOBAL	<SATSYS,SATBUF>
.DSABL	LSB

.SBTTL	ALLOC2 - CHECK OUTPUT DISK FOR RELOCATION CLUSTERS

;+
; ALLOC2 - CHECK THAT THE OUTPUT DISK HAS A REASONABLE # OF EXTRA FREE
;	   CLUSTERS FOR RELOCATION PURPOSES
;
;	CALL:	NBADO = NUMBER OF BAD BLOCKS (PC'S) ON THE OUTPUT DISK
;		ORGDSK TABLE FILLED IN
;		CALL	ALLOC2
;
;	RETURN:	C=0 - PROCEED
;		C=1 - USER SAID NOT TO USE THIS DISK
;-

.ENABL	LSB

ALLOC2:	REGSCR			;SAVE REGISTERS
	TST	NBADO		;ANY OUTPUT DISK BAD BLOCKS ?
	BEQ	60$		;NO - EXIT
	MOV	#ORGDSK,R0	;POINT TO ORIGINAL DISK INFO. TABLE
	MOV	ORGSZL(R0),R4	;ORIG. DISK SIZE (LSB)
	MOV	ORGSZM(R0),R5	;ORIG. DISK SIZE (MSB)
	MOVB	ORGPCS(R0),PCS	;ORIG. DISK PCS
	MOV	PCS,R1		;PREPARE FOR DIVIDE
10$:	ASR	R1		;DIVIDE BY PCS
	BCS	20$
	ASR	R5		;SHIFT MSB
	ROR	R4		; BRING BITS TO LSB
	BR	10$

20$:	MOV	R4,R3		;COPY TO R3
	SUB	NBADO,R4	;SUBTRACT BAD BLOCK COUNT
	SUB	ORGAPC(R0),R4	;SUBTRACT # ALLOCATED PC'S ON ORIG. DISK
				;R4 IS NOW THE EXCESS USABLE FOR RELOCATIONS
	BEQ	30$		;NO EXCESS AT ALL, BUT JUST FIT
	BCC	30$		;THERE IS SOME EXCESS
	MOV	#TMBBO,ERRADR	;%%% TOO MANY BAD BLOCKS ON OUTPUT
	BR	70$		;EXIT WITH ERROR

30$:	MUL	#100.,R4	;EXCESS * 100. TO COMPUTE PERCENTAGE
	BPL	40$		;WE'RE POSITIVE SO IT'S OK
	ADD	#100.,R4	;NEGATIVE - ADD BACK IN 100.*65536.
40$:	CALL	DIVU		;DO UNSIGNED DIVIDE - RESULT IN R0
	CMP	#10.,R0		;EXCESS GREATER THAN 10% ?
	BLOS	60$		;YES - WE'RE OK
	CALL	JPERC		;'%%% '
	MESSAG	<"Only ">
	CALLX	DECZER		;PRINT INTEGRAL PERCENTAGE
	MESSAG	<"% of the output disk clusters are available ">
	MESSAG	<"for relocation."<200>>
	CALLX	YESNO,R5	;MOUNT IT ANYWAY ?
	  .WORD	50$
	  GENTXT
	   .ASCII <200>
	   .ASCII "There are very few output disk clusters usable for"<200>
	   .ASCII "relocation. Therefore, it is recommended  that"<200>
	   .ASCII "another disk be selected."<200>
50$:	   .ASCIZ "Mount it anyway <NO> ? "
	  UNORG
	 BR	70$		;CTRL/Z - GO BACK
 	 BR	70$		;LF - DEFAULT IS NO
	 BR	70$		;NO
60$:	CALLX	GETTTY		;KEEP CLOCK GOING
	 TST	(PC)+		;YES - POP OVER SEC
70$:	SEC
	RETURN

.DSABL	LSB
GLOBAL	<NBADO,ORGDSK,PCS>

.SBTTL	WRINIT - WRITE OUT INIT IMAGE

;+
; WRINIT - WRITE OUT INIT IMAGE
;
;	CALL:	R0 = SAVE VOLUME INDEX
;		R1 = SAVE VOLUME UNIT #
;		CALL	WRINIT
;
;	RETURN:	C=0 - WROTE THEM OUT
;		C=1 - FAILED SOMEWHERE
;-

.ENABL	LSB

WRINIT:	CLR	-(SP)		;MAKE SPACE FOR STORING A WORD
	MOV	(PC),NOTAG	;WE DON'T WANT TAGS
	MOV	#SATBUF+2000,R5	;WHERE THE DOS LABEL/INIT BLOCKS GO
	MOV	R5,BUFPTR	;MAKE BUFPTR POINT TO SAME SPOT
	TSTB	SSVOL+SSHIDX	;SAVE VOLUME MAGTAPE ?
	BEQ	10$		;NO
	CALL	SELEC2		;SELECT SAVE TAPE
	MOV	#FQINIT+FQNAM1,R4	;POINT TO RAD50 'INIT.SYS'
	CALL	DOSLAB		;SET UP DOS LABEL
	CALL	MTIO,R5,WFUN	;WRITE IT OUT
	  BR	130$		;UNRECOVERABLE I/O ERROR
	  BR	140$		;BAD BLOCK
	  BR	140$		;EOF
10$:	  CALL	SELEC3		;SET UP FOR I/O WITH SYSTEM DISK
20$:	CLR	INIDCN		;HAVEN'T GOT ADDRESS YET
	MOV	#FQINIT+FQPPN,R0	;R0 -> [0,1]INIT.SYS
	CALL	FSSDU		;LOOKUP INIT.SYS
	BCS	110$		;ERROR
	MOV	UAA(R5),R3	;GET LINK TO ACCOUNTING ENTRY
	MOV	UAR(R5),R2	;GET 1ST RETR. ENTRY LINK
	CALL	FSRDB		;GET ACCOUNTING ENTRY
	BCS	120$		;ERROR
	MOV	UCLUS(R5),TMPWRD	;GET FILE CLUSTER SIZE
	MOV	R2,R3		;1ST RETR. ENTRY LINK
	CLR	R4		;R4 IS THE # OF BLOCK SLOTS LEFT IN AN SC
30$:	CALL	FSRDB		;GET RETR. ENTRY
	BCS	120$		;ERROR
	TST	(R5)+		;POP PAST LINK TO NEXT ENTRY
40$:	MOV	(R5)+,R2	;GET A DCN
	BEQ	90$		;ALL DONE IF IT'S ZERO
	CALLX	CNVRIB		;CONVERT IT TO AN FBN
	MOV	TMPWRD,R1	;GET # BLOCKS PER FILE CLUSTER
50$:	MOV	R1,(SP)		;STORE # DC'S/FILE CLUSTER LEFT
	MOV	#256.,R1	;GET A BLOCK
	CALL	RDSKIO,R5	;READ IT
	  BR	120$		;BAD BLOCK ERROR
	  TST	INIDCN		;DO WE HAVE THE DCN BLOCK ADDRESS YET ?
	BNE	60$		;YES
	MOV	SATBUF+2000+106,INIDCN	;NO - BUT NOW WE DO
60$:	CALL	SELEC2		;SELECT OUTPUT VOLUME
	TSTB	SSVOL+SSHIDX	;SAVE VOLUME MAGTAPE ?
	BNE	70$		;YES
	CALL	WRINDK		;NO - IT'S A DISK
	BCS	140$		;BAD BLOCK ERROR
	BR	80$		;SUCCESSFUL WRITE

70$:	CALL	MTIO,R5,WFUN	;DO MAGTAPE I/O
	  BR	130$		;UNRECOVERABLE I/O ERROR
	  BR	140$		;BAD BLOCK
	  BR	140$		;EOF
80$:	  MOV	(SP),R1		;GET BACK # DC'S/FILE CLUSTER LEFT
	ADD	#1,R2		;NEXT BLOCK
	ADC	R3
	CALL	SELEC3		;SELECT SYSTEM DISK
	SOB	R1,50$		;DO FOR # DCN'S PER FILE CLUSTER
	BIT	R5,#17		;END OF RETRIEVAL ENTRY ?
	BNE	40$		;NO - GO GET NEXT DCN
	MOV	-20(R5),R3	;YES - GET LINK TO NEXT
	BNE	30$		;CONTINUE IF NON-ZERO
90$:	TSTB	SSVOL+SSHIDX	;SAVE VOLUME MAGTAPE ?
	BEQ	100$		;NO
	CALL	SELEC2		;MAKE SURE WE HAVE THE OUTPUT
	MOV	#1,R5		;WILL WRITE ONE EOF
	CALL	WRTEOF		;WRITE IT
100$:	MOV	#0,NOTAG	;CLEAR NOTAG W/O AFFECTING CARRY
	INC	(SP)+		;POP OUR TEMP. STORAGE SPACE
	RETURN

110$:	MOV	#NOINI,ABTADR	;%%% NO INIT.SYS ON SYSTEM DISK
	BR	130$

120$:	MOV	#BADINI,ABTADR	;%%% BAD INIT.SYS ON SYSTEM DISK
130$:	SEC			;AN ERROR
	BR	100$

140$:	CALL	BBOUSV		;BAD BLOCK ON SAVE VOLUME
	BCS	100$		;CAN'T GO ON
	BR	60$		;RECOVERED - CONTINUE

GLOBAL	<FQINIT,SATBUF,SSVOL>
.DSABL	LSB

.SBTTL	WRINDK - INIT DISK WRITE ROUTINE

;+
; WRINDK - INIT DISK WRITE ROUTINE
;
;	CALL:	R4 = # BLOCKS REMAINING IN CURRENT SAVE CLUSTER
;		NUMDCN = NUMBER OF DCN'S ALREADY SAVED
;		CALL	WRINDK
;
;	RETURN:	C=1 - COULDN'T WRITE BLOCK
;		C=0 - OTHERWISE
;-

.ENABL	LSB

WRINDK:	MOV	R1,-(SP)	;SAVE R1
	MOV	R2,-(SP)	;SAVE R2
	MOV	R3,-(SP)	;SAVE R3
	TST	R4		;STILL SPACE IN SAVE CLUSTER ?
	BNE	10$		;YUP
	MOV	CURFBN,R2	;NO - GET CURRENT FBN
	MOV	CURFBN+2,R3
	CALL	CHKSBA		;MAKE SURE WE HAVE A GOOD ONE
	MOV	R2,CURFBN	;SET IT UP
	MOV	R3,CURFBN+2
	ADD	#8.,CURFBN	;UP TO THE NEXT SAVE CLUSTER
	ADC	CURFBN+2
	MOV	#7,R4		;NUMBER OF BLOCKS STILL AVAILABLE
	BR	20$		; IN CURRENT SAVE CLUSTER

10$:	MOV	TMPDWD,R2
	MOV	TMPDWD+2,R3
	ADD	#1,R2
	ADC	R3
	DEC	R4
20$:	CALL	WDSKIO,R5	;WRITE BLOCK
	  BR	60$		;BAD BLOCK ERROR
30$:	  MOV	R2,TMPDWD	;STORE AWAY FBN
	MOV	R3,TMPDWD+2
	MOV	NUMDCN,R1	;GET # INIT DCN'S SAVED
	ASL	R1		; * 2
	CALL	SEG2DN		;CONVERT FBN TO DCN
	TST	R1		;THIS THE FIRST DCN ?
	BEQ	40$		;YUP - NO NEED TO CHECK PREVIOUS
	CMP	R2,SATBUF+7776(R1)  ;THIS ONE SAME AS PREVIOUS ?
	BEQ	50$		;YUP - DON'T ADD THIS ONE
40$:	MOV	R2,SATBUF+10000(R1) ;STORE DCN IN SATBUF
	INC	NUMDCN		;RESTORE # DCN'S SAVED
50$:	TST	(PC)+		;ALL IS WELL - POP OVER SEC
60$:	SEC			;NO GOOD
	MOV	(SP)+,R3	;RESTORE R3
	MOV	(SP)+,R2	;RESTORE R2
	MOV	(SP)+,R1	;RESTORE R1
	RETURN

.DSABL	LSB
GLOBAL	<CURFBN,SATBUF>

.SBTTL	GETBOO - GET BOOT BLOCK

;+
; GETBOO - GET THE BOOT BLOCK INTO SATBUF+2
;
;	CALL:	SYSNDX/SYSUNT/DCS SETUP FOR DEVICE TO BE BOOTED
;		CALL	GETBOO
;
;	RETURN:	BOOT BLOCK IS IN SATBUF STARTING AT WORD 2
;		First word is zero if no bootstrap was found
;-

.ENABL	LSB

GETBOO:	MOV	SSVOL+SSDEN,R1	;Get density in case of tape
	CALLRX	GBOOT		;GET THE BOOT
BOORET::MOV	#256.,R0	;BOOT IS 256. WORDS LONG
	MOV	#SATBUF+4,R1	;POINTER TO BOOT DESTINATION
	MOV	#SATBUF+10000,R2 ;POINTER TO BOOT SOURCE
20$:	MOV	(R2)+,(R1)+	;MOVE A WORD
	SOB	R0,20$		;GET THE WHOLE THING
	RETURN

.DSABL	LSB
GLOBAL	<SYSNDX,SSVOL,SAVDEV,SATBUF>

.SBTTL	RSTBOO - WRITE BOOT + NULL BLOCK TO RSTS DISK

;+
; RSTBOO - WRITE BOOT + NULL BLOCK TO RSTS DISK
;
;	CALL:	BOOT BLOCK SET UP STARTING AT SATBUF+4
;		CALL	RSTBOO
;
;	RETURN:	C=0 - SUCCESSFUL
;		C=1 - UNSUCCESSFUL
;-

.ENABL	LSB

RSTBOO:	MOV	#SATBUF+4,BUFPTR	;POINT TO THE BOOT BLOCK
	MOV	#SATBUF+1004,R2	;POINT TO END OF BOOT
	MOV	#256.,R3	;WE WILL CLEAR AREA WHERE PLB MIGHT BE
				;(THIS IS SO THE DISK, IF IT WAS PREVIOUSLY
				;A SAVE VOLUME, WILL NOT BE IDENTIFIABLE AS
				;ONE IF THIS OPERATION IS ABORTED)
10$:	CLR	(R2)+		;CLEAR A WORD
	SOB	R3,10$		;CLEAR THEM ALL
	CLR	R2		;BOOT BLOCK IS NUMBER 0
	CLR	R3
	MOV	#512.,R1	;BOOT + NULL BLOCK = 512. WORDS
	CALL	WDSKIO,R5	;WRITE IT
	  BR	30$		;BAD BLOCK
	  MOV	MNTTBL+2,R4	;POINT TO OUTPUT VOLUME'S MOUNT TABLE
	MOV	ORGDSK+ORGDCR,MNTDCR(R4)	;THE NEW CREATION DATE
	MOVB	ORGDSK+ORGPCS,R3	;THE NEW PCS FOR THE DIVIDE
	MOVB	R3,MNTPCS(R4)	;THE NEW PCS
	CLR	R2		;CLEAR R2 FOR DIVIDE
	MOVB	MNTDCS(R4),R1	;GET THE DCS
	DIV	R1,R2		;GET THE RATIO
	MOVB	R2,MNTCLU(R4)	;SAVE IT
	MOVB	#FMTRST,MNTFMT(R4)	;CHRISTENED A RSTS DISK
	TST	(PC)+		;ALL'S WELL - POP OVER SEC
20$:	SEC			;NO GOOD
	RETURN

30$:	MOV	#NOWRTB,ABTADR		;%%% CAN'T WRITE BOOT
	BR	20$

.DSABL	LSB
GLOBAL	<SATBUF,MNTTBL,ORGDSK>

.SBTTL	BOODCN - SET UP INIT DCN'S IN BOOT AND INIT

;+
; BOODCN - SET UP INIT DCN'S IN BOOT AND INIT
;
;	CALL:	BOOT BLOCK IN SATBUF STARTING AT OFFSET 4
;		DCN'S IN SATBUF STARTING AT OFFSET 10000
;		TMPFBN = FIRST FBN INIT WRITTEN TO
;		TMPCBO = BAD BLOCK FILE POINTER AT TIME OF
;		FIRST WRITE
;		INIDCN = ADDRESS WHERE DCN'S SHOULD GO IN INIT
;		CALL	BOODCN
;
;	RETURN:	C=1 - FATAL WRITE ERROR
;		C=0 - SUCCESSFUL
;		      CORRECT NUMBER OF DCN'S PUT IN BOOT
;		      ALL DCN'S PUT INTO INIT STARTING AT ADDRESS INIDCN
;-

.ENABL	LSB

BOODCN:	REGSCR			;SAVE REGISTERS
	CALL	SELEC2		;SELECT OUTPUT CHANNEL
	MOV	NUMDCN,R4	;GET NUMBER OF DCN'S
	CMP	#<3*256.>-1,R4	;MORE THAN 3 BLOCKS (-1 WORD) WORTH OF DCN'S ?
	BLO	40$		;YES - TOO MUCH INIT!
	ASL	R4		;MAKE IT BYTE OFFSET
	MOV	#SATBUF+10000,R3;GET ADDRESS WHERE DCN'S ARE
	ADD	R3,R4		;R4 -> LOCATION PAST LAST DCN
10$:	CLR	(R4)+		;WE MUST END DCN BLOCK(S) WITH ZEROES
	CMP	#SATBUF+10000+<3*512.>,R4 ;HAVE WE FILLED IN 2 BLOCKS WORTH ?
	BLO	10$		;NO - ZERO ANOTHER WORD
	MOV	NUMDCN,R4	;RESTORE R4
	MOV	SATBUF+4+<B.TWC-B.BOOT>,R5	;WORD COUNT NEEDED FOR INIT
	MOV	#SATBUF+4+<B.DATE-B.BOOT>,R2	;Where the block map goes
	ADD	#377,R5		;Round INIT's word count
	CLRB	R5		; up to a block's worth
	SWAB	R5		;  now block count
	CLR	R1		;Init count of DCNs in chunk
	CLR	-(SP)		; and start of chunk
20$:	MOV	(R3)+,R0	;Get a DCN
	SUB	R1,R0		;See if it is adjacent
	CMP	R0,(SP)		;Well?
	BEQ	30$		;Yes, add it to the current chunk
	MUL	DCS,R1		;EXPAND DCN'S TO NUMBER OF BLOCKS	;MNB001
	CALL	EXPAND		;Expand this chunk out into the block map
	TST	(R2)		;Any room left in map?
	BNE	70$		;No, quit and mark as non-bootable
	MOV	-2(R3),-(SP)	;Set starting DCN of next chunk
	CLR	R1		; and initialize size
30$:	INC	R1		;Count one more cluster
	SUB	DCS,R5		;Have we done enough blocks?
	BLOS	50$		;Yes, we're done
	SOB	R4,20$		;Otherwise do another
40$:	ERF	<"Bad INIT word count"> ;CANNOT MOVE PAST END OF LIST

50$:	MUL	DCS,R1		;EXPAND DCN'S TO NUMBER OF BLOCKS	;MNB001
	ADD	R5,R1		;Reduce last chunk to only what we need
	BEQ	60$		;We don't need anything, skip ahead
	CALL	EXPAND		;Expand the last chunk
	MOV	SATBUF+4+<B.TWC-B.BOOT>,R0 ;Get the actual word count we want
	BIC	#^C<377>,R0	;Isolate last partial block's worth
	BEQ	60$		;Was a full block, skip
	MOVB	R0,4(R2)	;Update last chunk's word count
	DECB	5(R2)		; one less full block
60$:	TST	-(R2)		;Did we overflow?
	BEQ	80$		;No, so this is the end marker
70$:	CLR	SATBUF+4	;Mark non-bootable volume
80$:	MOV	INIDCN,R5	;GET ADDRESS WHERE DCN'S SHOULD GO
	CLC			;FOR ROR
	ROR	R5		;MAKE WORD OFFSET
	CLRB	R5		;WE WILL ROUND TO NEAREST BLOCK
	SWAB	R5		;THIS IS NOW THE INIT RELATIVE BLOCK NUMBER
	MOV	#SATBUF+10000,R4	;ONCE AGAIN - POINT TO THE DCN'S
	MOV	R4,BUFPTR	;WHERE WE WILL BEGIN WRITING FROM
90$:	MOV	(R4)+,R2	;GET A DCN
	CALLX	CNVRIB		;CONVERT TO AN FBN
	SUB	DCS,R5		;IS THE ONE WE WANT IN THIS DEVICE CLUSTER ?
	BGT	90$		;NO - TRY ANOTHER
	ADD	DCS,R5		;YES - GET BLOCK WITHIN CLUSTER
	ADD	R5,R2		;COMPUTE FBN WE WANT
	ADC	R3
	MOV	NUMDCN,R0	;NUMBER OF THEM
	INC	R0		;MAKE SURE WE MOVE OUR ZEROED WORD
100$:	MOV	#256.,R1	;WRITE A BLOCK FULL AT A TIME
	CALL	WDSKIO,R5	;WRITE 'EM
	  BR	130$		;BAD BLOCK - FATAL
	  SUB	#256.,R0	;ANY MORE ?
	BLE	110$		;NO - WE'RE DONE
	ADD	#1000,BUFPTR	;POINT TO NEXT BLOCK FULL
	INC	R5		;WANT TO SEE IF NEXT BLOCK IS IN CURRENT DC
	SUB	DCS,R5		;IS IT ?
	BEQ	90$		;NO - GO GET ANOTHER DCN
	ADD	#1,R2		;YES - INCREMENT FBN
	ADC	R3
	BR	100$		;GO WRITE ANOTHER BLOCK

110$:	TST	(PC)+		;ALL'S WELL, POP OVER SEC
120$:	SEC			;NOT SO GOOD
	RETURN

130$:	MOV	#SBINI,ABTADR	;CAN'T WRITE INIT DCN'S
	BR	120$

.DSABL	LSB

GLOBAL	<SATBUF,DCS>

.SBTTL	Enter data for a contiguous chunk into the block map

EXPAND:	TST	R1		;IS THERE A PREVIOUS CHUNK?		;MNB001
	BEQ	30$		;Skip if there was no previous chunk
	MOV	R4,-(SP)	;Save some registers
	MOV	R5,-(SP)	; another one
	MOV	2+4(SP),R4	;Get starting DCN
	MUL	DCS,R4		;Multiply by DCS to get block number
	BPL	10$		;Branch if no overflow
	ADD	DCS,R4		;Correct for signed multiply
10$:	MOV	#77400/400,R0	;Get max block count
	CMP	R0,R1		;Do we even have that many blocks?
	BLOS	20$		;Yes
	MOV	R1,R0		;No, so do only as many as exist in this chunk
20$:	MOV	R0,-(R2)	;Set block count
	SWAB	(R2)		; now word count
	MOV	R4,-(R2)	;Set high order block number
	MOV	R5,-(R2)	; and low order
	ADD	R0,R5		;Advance block number
	ADC	R4		; in double precision
	SUB	R0,R1		;Compute how many blocks are left
	BNE	10$		;Some, stash another chunk
	MOV	(SP)+,R5	;Restore registers
	MOV	(SP)+,R4	; and another
30$:	MOV	(SP)+,(SP)	;Remove the word passed on the stack
	RETURN			;Done...

.SBTTL	IDENT - IDENTIFY ROUTINE

.ENABL	LSB

IDENT:	TSTB	MAGTAP		;DEVICE MAGTAPE ?
	BEQ	10$		;NO
	CALL	DENSET,R5	;YES - SET THE DENSITY
	  JMP	50$		;COULDN'T READ TAPE
	  BR	40$		;ERROR IN SET
	  BR	20$		;GOTTA BE A SAVE SET - IF ANYTHING
10$:	CALL	CHKRST		;SEE IF DEVICE RSTS
	  BCC	30$		;YES
20$:	CALL	CHKSAV		;SEE IF SAVE VOLUME
	  BCS	50$		;NOT THAT EITHER
30$:	CALL	CHKID		;CHECK SPECIFIED ID
	BCS	60$		;ERROR
	CALL	DISMNE		;IDENTIFY DEVICE
	TST	(PC)+		;ALL IS WELL - POP OVER SEC
40$:	SEC			;FAILURE
	RETURN

50$:	MOV	#NOLAB,ERRADR	;%%% DEVICE HAS NO LABEL
	BR	40$

60$:	MOV	#WRGVOL,ERRADR	;%%% WRONG VOLUME
	BR	40$

.DSABL	LSB

.SBTTL	BBSORT - BAD BLOCK TABLE SORTER

.ENABL	LSB

BBSORT:	MOV	BADBO,R0	;GET BB TABLE ADDRESS
	BIT	#OPSV,OPFLG	;THIS A SAVE ?
	BNE	10$		;YES - GO DO BIG SORT
	CALL	WSORT		;NO - DO LITTLE SORT
	MOV	R1,R5		;;PREPARE TO SET UP NEWOBB
	BR	20$		;;GO FINISH SETUP

10$:	CALL	W2SORT		;BIG TABLE SORT
	MOV	R1,R5		;;PREPARE TO SET UP NEWOBB
	ASL	R5		;;(FOR 2 WORD TABLE)
20$:	ASL	R5		;;TURN COUNT TO OFFSET
	ADD	R0,R5		;;AND STORE IT
	RETURN

.DSABL	LSB
GLOBAL	<BADBO,OPFLG>

.SBTTL	DUMMY ROUTINES

PROMPT:	JMP	ILLCAL		;ILLEGAL CALL - GO DIE


