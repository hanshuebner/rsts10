TITLE	GGBOOT,<GET BOOTS ON-LINE>,0A,10-MAY-91,ABC/WBN/SHG/JBL/NMC/AWR/RVR/GPK/VAM

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	Edit history for GGBOOT

;+
;
;  000	GPK  10-Aug-82	Updates for new bootstraps and BLDBOT
;  001  VAM  26-Jun-85	Update for new-format magtape boot
;
;-

.SBTTL	GGBOOT MACROS AND PARAMETERS

.MACRO	I.MESS
	TMPORG	GGBTXT
.NLIST	BEX
.ENDM	I.MESS

.MACRO	I.DATA
	TMPORG	GGBCTL
.NLIST	BEX
.ENDM	I.DATA

.MACRO	WARN	M
.NLIST
	CALL	WARN,R5
.IF 	NB	M
	.WORD	M
.ENDC
.LIST
.ENDM	WARN

.MACRO	DECZER	C
.NLIST
.IF NB	<C>
	MOVB	C,R0
.ENDC
	CALLX	DECZER
.LIST
.ENDM	DECZER

.MACRO	CALLF2	M		;FILE-STRUCTURED CALL
.NLIST
	CALL	FSIO1
	CALLX	M		;CALL THE ROUTINE
	CALL	FSIO2
.LIST
.ENDM	CALLF2

.SBTTL	ORDER THE CSECTS IN MEMORY

	DEFORG	GGB
	DEFORG	GGBCTL
	DEFORG	GGBTXT
	ORG	GGB

.SBTTL	GGBOOT DATA

	TMPORG	GGBCTL

INIBLK:	.BLKW0			;NUMBER OF CURRENT INIT BLOCK IN FIBUF
GGBMSG:	.ASCIZ "GGBOOT"		;ROUTINE NAME MESSAGE
	.EVEN

DEVASC:	.WORD	0		;DEVICE NAME IN ASCII
DEVNUM:	.WORD	0		;UNIT NUMBER (& UNIT FLAG)

STBLOC:	.BLKW0	1		;BLOCK OFFSET OF STB IN INIT
STBNUM:	.BLKW0	1		;NUMBER OF SYMBOLS IN STB
OVBLOC:	.BLKW0	1		;BLOCK OFFSET OF OVERLAY DESCRIPTOR BLOCK
OVBNUM:	.BLKW0	1		;NUMBER OF OVERLAYS
SYMBOL:	.BLKW0	2		;SYMBOL TO BE FOUND BY GETSYM
FTLGET:	.BLKW0	1		;0 IF SYMBOL LOOKUPS ARE FATAL, ELSE NON-ZERO

	UNORG

.SBTTL	SOME DEFINITIONS

.EQUATE	USERPC,	40		;OFFSET FOR INIT TRANSFER ADDRESS
.EQUATE	USERTOP,50		;OFFSET FOR INIT LOAD WORD COUNT

.SBTTL	GET BOOTSTRAP INTO SATBUF FOR A DEVICE

.ENABL	LSB

GGBOOT::REGSAV			;SAVE OUR REGISTERS
	MOV	RTNNAM,-(SP)	;SAVE NAME OF CALLER
	MOV	#GGBMSG,RTNNAM	;'GGBOOT'
	MOV	#256.,I.DSQ+DSQCNT ;1 BLOCK
	CLRB	HIGHBF		;I/O TO LOW MEMORY
	CALL	SEL3		;SETUP FOR I/O TO SYSTEM DISK
	MOV	#FQINIT,R4	;R4 -> INIT FIRQB
	CALLX	LOKFIL		;LOOK UP INIT
	BCS	30$		;CAN'T FIND IT - FATAL ERROR
10$:	MOV	#-1,INIBLK	;NOTHING IN BUFFER YET
	CLR	R2		;HIGH WORD OF BLOCK 0 BYTE ADDRESS IS 0
	CLR	R3		;BYTE ADDRESS OF BYTE 0 IS 0
	CALL	INIWRD		;SO GET THE FIRST WORD OF INIT.SYS
	CMP	(SP)+,#1	;THE SIL MUST HAVE EXACTLY 1 MODULE
	BNE	20$		;COMPLAIN IF IT AIN'T SO
	MOV	#2+SE.STB,R3	;FIND THE BLOCK OFFSET OF THE STB
	CALL	INIWRD		;GET IT
	MOV	(SP)+,STBLOC	;SAVE IT
	BEQ	20$		;THERE MUST BE AN STB
	TST	(R3)+		;FIND THE NUMBER OF SYMBOLS
.ASSUME	SE.STB+2 EQ SE.STN
	CALL	INIWRD		;GET IT
	MOV	(SP)+,STBNUM	;SAVE IT
	BEQ	20$		;MORE SIL SANITY-CHECKING
	MOV	#2+SE.OVB,R3	;FIND BLOCK OFFSET OF OVERLAY DESCRIPTOR BLOCK
	CALL	INIWRD		;NOTE: R2 IS STILL 0 BECAUSE WE ARE IN BLOCK 0
	MOV	(SP)+,OVBLOC	;SAVE IT
	BEQ	20$		;NO OVERLAYS IN INIT???
	TST	(R3)+		;FIND THE NUMBER OF OVERLAY DESCRIPTORS
.ASSUME	SE.OVB+2 EQ SE.OVN
	CALL	INIWRD		;GET IT
	MOV	(SP)+,OVBNUM	;SAVE IT
	BNE	GETBOO		;ALL IS GOOD
	;BEQ	20$		;THERE MUST BE SOME OVERLAYS IN INIT

20$:	ERF	<"INIT.SYS is not a SAV format SIL">
30$:	ERF	<"Can't open [0,1]INIT.SYS in GGBOOT">

.DSABL LSB

GLOBAL	<RTNNAM,I.DSQ,HIGHBF,FQINIT>

.ENABL	LSB

NOBOOT:	ERF	<"Missing bootstrap in INIT.SYS">			;001

GETBOO:	CALL	SEL2		;LOOK AT THE OUTPUT VOLUME FOR A SECOND
	MOV	SYSNDX,R0	;GET THE DEVICE NAME INDEX
	CALL	SEL3		;FURTHER I/O FROM INIT.SYS FOR A WHILE
	CALL	GETSYM,R5	;Find the bootstrap pointer table
	 .RAD50	"XXBOOT"
	MOV	R3,XXBPTR	;Store it for BLDBOT
	MOV	R2,XXBPTR+2	; and high order also
	MOV	#USERPC,R3	;We're looking for the transfer address
	CLR	R2
	CALL	INIWRD		;Fetch it
	MOV	(SP)+,XFERAD	;Pass it to BLDBOT
	MOV	#USERTOP,R3	;We want to know how big INIT is	;001
	CLR	R2		;It only requires a 16-bit address.	;001
	CALL	INIWRD		;Fetch the last word's address		;001
	CLC			;No evil influences.			;001
	ROR	(SP)		;Convert it to a word count and		;001
	INC	(SP)		; undo the RT11 crazyness.		;001
	MOV	(SP)+,BOOTWC	;Save the word count away.		;001
	TST	R0		;Magtape?
	BMI	60$		;Yes					;001
	CMP	R0,#IDX$DB	;DB type disk?
	BEQ	20$		;Yes
	CMP	R0,#IDX$DR	;A DR, maybe?
	BNE	40$		;No, so no massbus ID hassles
20$:	MOV	#102,R3		;Get address of massbus ID pointers
	CLR	R2		;No high order
	CALL	INIWRD		;Fetch it
	MOV	(SP)+,R3	;Pick up the address
	CLR	R2		;No high order
	ADD	R0,R3		;Index into table using the device index
	CALL	INIWRD		;Fetch the pointer to device's ID table
	MOV	SYSUNT,R3	;Pick up unit number
	ASL	R3		; times 2
	ADD	(SP)+,R3	;Point to its massbus ID
	CLR	R2		;Again no high order
	CALL	INIWRD		;Get the massbus ID for this drive
	MOV	(SP)+,MSBSID	;Store it
40$:	CALLX	BLDBOT,R5,<SATBUF+10000> ;Fetch the bootstrap
	BCS	NOBOOT		;Error, quit
	MOV	BOOTWC,<B.TWC-B.BOOT>+SATBUF+10000 ;Set the total word count
	TST	R0		;Did we find a bootstrap?
	BNE	50$		;Yes
	CLR	SATBUF+10000	;Indicate we didn't find one
50$:	CALL	SEL2		;ENSURE THE OUTPUT DISK IS SET UP
	MOV	(SP)+,RTNNAM	;Restore the caller's routine name
	CALLX	REGRES,R5
	CALLRX	ONLBOR		;BACK TO ONLSAV

60$:	CALL	GETSYM,R5	;Look up the address of "MGBOOT"	;001
	 .RAD50	"MGBOOT"	;This sets up R2 and R3.		;001
	CALLX	BLDMGB,R5,<SATBUF+10000>;Get the secondary boot!	;001
	BR	50$		;And, go back for more.			;001

.DSABL	LSB

GLOBAL	<SATBUF,XFERAD,XXBPTR,SYSNDX,SYSUNT,MSBSID,BOOTWC>		;001

.SBTTL	INIWRD - FETCH A WORD FROM INIT.SYS

;+
; INIWRD - FETCH A WORD FROM INIT.SYS
;
;	R2 = MSB OF BYTE ADDRESS WITHIN INIT
;	R3 = LSB OF BYTE ADDRESS WITHIN INIT
;
;	CALL	INIWRD
;
;	(SP) = THE WORD
;-

INIWRD::MOV	(SP),-(SP)	;MAKE ROOM FOR RETURNED VALUE
	MOV	R0,-(SP)	;GET A WORKING REGISTER
	MOV	R2,-(SP)	;SAVE R2
	MOV	R3,-(SP)	;ALSO R3
	DIV	#1000,R2	;DIVIDE WORD ADDRESS BY 512. TO GET
	MOV	R2,R0		; THE INIT ADDRESS
	CMP	R0,INIBLK	;IS THIS BLOCK IN THE BUFFER?
	BEQ	10$		;YES
	MOV	R0,INIBLK	;NO, BUT IT WILL BE
	MOV	R1,-(SP)	;SAVE R1
	MOV	#FCINIT,R1	;R1 -> INIT FCB
	MOV	R0,FCNVB(R1)	;THE VIRTUAL BLOCK NUMBER
	CALL	SEL3		;SELECT THE SYSTEM DISK
	CALL	SRVBFB		;CONVERT VBN TO FBN
	BCS	RDIERR		;NO GOOD
	CALL	FSREAD		;DO THE READ INTO FIBUF
	BNE	RDIERR		;NO GOOD
	MOV	(SP)+,R1	;RESTORE R1
	CALL	SEL2		;BACK TO THE OUTPUT DEVICE
10$:	MOV	(SP)+,R3	;RESTORE R3
	MOV	(SP)+,R2	; AND R2
	MOV	R3,R0		;COPY THE ADDRESS AGAIN
	BIC	#^C<777>,R0	;ISOLATE OFFSET IN BLOCK
	MOV	FIBUF(R0),4(SP) ;RETURN VALUE ON THE STACK
	MOV	(SP)+,R0	;RESTORE R0
	RETURN

RDIERR:	ERF	<"Error reading [0,1]INIT.SYS in GGBOOT">

GLOBAL	<FIBUF,FCINIT>

.SBTTL	SRVBFB - CONVERT VBN TO FBN

;+
; SRVBFB - CONVERT VIRTUAL BLOCK NUMBER TO FIP BLOCK NUMBER
;
; CALL:	R1 -> FCB
;	VIRTUAL BLOCK NUMBER IN FCB @ FCNVB
;
; BACK:	FCB HAS CORRECT WINDOW
;	R2/R3 = FBN OF BLOCK
;	R0 DESTROYED
;	C-BIT WILL INDICATE SUCCESS OR FAILURE
;-

.ENABL	LSB

10$:	MOV	R4,-(SP)	;SAVE R4
	CALL	SRRNB		;R1 -> FCB. GET FILE'S NAME ENTRY IN
	CLR	R3		;GET CLUSTERSIZE FROM FCB
	BISB	FCLUS(R1),R3
	INC	R3
	MUL	#7,R3		;TIMES 7 FOR 7 ENTRIES PER WINDOW
	MOV	R3,-(SP)	;SAVE NUMBER OF BLOCKS PER WINDOW
	MOV	FCWND(R1),-(SP)	;AND LINK TO NEXT WINDOW
	MOV	R1,R4		;POINT FCB TO NVB ENTRY
	ADD	#FCNVB,R4	; WHICH CONTAINS THE BLOCK TO WINDOW TO
	CMP	(R4)+,(R4)	;DO WE TURN BACK THE WINDOW?
	BHIS	20$		;NO, FORWARD
	MOV	2(SP),(R4)	;SET FCFLB TO -(CLUSIZ) SO THAT
	NEG	(R4)		;  IT WILL BE 0 AFTER THE READ
	MOV	UAR(R5),(SP)	;SET UP LINK TO FIRST WINDOW
20$:	MOV	(SP)+,R3	;GET RETRIEVAL ENTRY LINK
	CALL	FSRDB		;POINT TO IT
	BCS	40$		;BAD RETRIEVAL ENTRY
	ADD	(SP),(R4)	;BUMP BLOCK NUMBER OF WINDOW BY WINDOW SZ
	MOV	(R5),-(SP)	;SAVE LINK TO NEXT R.E.
	CALL	SRFLX,R5	;CHECK FOR A VALID WINDOW
	 BR	20$		;NOT YET, KEEP TURNING WINDOWS
	CMP	(SP)+,(SP)+	;DUMP JUNK FROM STACK
	MOV	R1,R0		;COPY FCB POINTER
	ADD	#FCWND,R0	;R0 -> FCB @ FCWND
30$:	MOV	(R5)+,(R0)+	;COPY THE WINDOW TO THE FCB
	BIT	R5,#17		;DONE?
	BNE	30$		;NO
	MOV	(SP)+,R4	;RESTORE R4 (DSQ POINTER)
SRVBFB::CALL	SRFLX,R5	;ATTEMPT THE CONVERSION
	 BR	10$		;NO, MUST TURN WINDOWS
	RETURN			;GOT IT - RETURN


40$:	SEC			;INDICATE AN ERROR
	RETURN

.DSABL	LSB

.SBTTL	READ NAME ENTRY FOR OPEN FILE (SRRNB)

;+
; SRRNB - READ NAME ENTRY OF OPEN FILE
;
; CALL:	R1 -> FCB
;	CALL	SRRNB
;
; BACK:	R5 -> NAME ENTRY OF FILE IN FIBUF
;-

.ENABL	LSB

SRRNB::	MOV	R2,-(SP)	;SAVE REGS
	MOV	R3,-(SP)
	MOV	FCUFND+F.FBNL(R1),R2 ;GET LSB OF FBN FOR NAME ENTRY
	MOVB	FCUFND+F.FBNM(R1),R3 ;GET MSB
10$:	CALL	FSREAD		;READ IN THE RIGHT BLOCK
	BNE	20$		;AN ERROR
	CLR	R5		;CLEAR R5 FOR BISB
	BISB	FCUFND+F.UNT(R1),R5 ;GET OFFSET/2 IN R5
	ASL	R5		;R5 = OFFSET OF N.E. IN FIBUF
	ADD	#FIBUF,R5	;R5 -> N.E.
	MOV	(SP)+,R3	;RESTORE REGS
	MOV	(SP)+,R2
	CLC
	RETURN

20$:	JMP	RDIERR		;TIS FATAL

.DSABL	LSB
GLOBAL	<FIBUF>

.SBTTL	GET FBN FROM FILE VBN, TURNING WINDOWS IF NEEDED

;+
; SRFLX - CONVERT VBN TO FBN OR INDICATE WINDOW TURN NEEDED
;
; CALL:	R1 -> FCB WITH VBN IN FCB @ FCNVB
;	CALL	SRFLX,R5
;
; BACK:	R0 DESTROYED
;	IF WINDOW IN MEMORY IS OK, R2/R3 = FBN
;		AND RETURN AT CALL+4
;	IF WINDOW TURN NEEDED, RETURN AT CALL+2
;-

SRFLX:	MOV	R1,R0		;COPY FCB POINTER
	ADD	#FCNVB,R0	;POINT TO NEXT LOGICAL BLOCK (VBN TO DO)
	MOV	(R0)+,R2	;BLOCK NUMBER TO R2
	SUB	(R0)+,R2	;COMPUTE FCNVB-FCFVB = BLOCK # REL WINDOW
	BLO	50$		;TOO FAR DOWN, MUST TURN WINDOW
	BITB	#US.NOX,DDSTS(R1) ;IS THE FILE CONTIGUOUS?
	BEQ	10$		;NO, WE HAVE TO WORK
	MOV	R2,R0		;YES, R0 = RELATIVE BLOCK WITHIN FILE
	CLR	R2		;USE THE FIRST WINDOW ENTRY
	BR	40$		;GO DO IT

10$:	CLR	R3		;CLEAR REGISTER TO GET
	BISB	(R0),R3		; CLUSTERSIZE-1
	MOV	R2,R0		;REMEMBER BLOCK # REL WINDOW
	COM	R3		;MAKE CLUSTERSIZE A MASK
	BIC	R3,R0		;R0 = BLOCK WITHIN CLUSTER
20$:	ASR	R3		;DIVIDE BLOCK # BY CLUSTERSIZE
	BCS	30$
	;CLC			;NO SIGN EXTEND
	ROR	R2
	BR	20$

30$:	CMP	R2,#6		;R2 = WINDOW # RELATIVE TO IN-CORE
	BHI	50$		;ONLY 7 R.P.'S IN CORE, SORRY
	ASL	R2		;R2 = OFFSET IN WINDOW OF RP
40$:	ADD	R1,R2		;ADD IN FCB POINTER
	MOV	FCWND+2(R2),R2	;GET PROPER RETRIEVAL POINTER
	CALLX	CNVRIB		;CONVERT R.P. IN R2 TO A FBN
	ADD	R0,R2		;ADD IN BLOCK NUMBER WITHIN CLU
	ADC	R3
	TST	(R5)+		;ADVANCE TO GOOD RETURN
50$:	RETURN	R5		;RETURN HAPPY


.SBTTL	SELECT - A - CHANNEL

;+
; SEL3 - SELECT THE SYSTEM DISK
; SEL2 - SELECT THE OUTPUT DEVICE
;
;	CALL:	CALL	SEL?
;
;	RETURN:	SYSNDX/SYSUNT/DCS SET UP FOR THE DEVICE
;-

.ENABL	LSB

SEL3::	MOV	R2,-(SP)	;SAVE R2
	MOVB	#6,CHANO	;SYSTEM DISK UNIT # * 2
	MOV	SAVUNT+4,R2	;ADDRESS OF SYSTEM DISK INFO.
	BR	10$		;ON WITH IT

SEL2::	MOV	R2,-(SP)	;SAVE R2
	MOVB	#4,CHANO	;OUTPUT DEVICE UNIT # * 2
	MOV	SAVUNT+2,R2	;ADDRESS OF OUTPUT DEVICE INFO.
10$:	MOV	DEVIDX(R2),SYSNDX	;THE DEVICE INDEX
	MOV	DEVUNT(R2),SYSUNT	;THE UNIT #
	MOV	DEVDCS(R2),DCS		;THE DCS
	CLR	FIBPHS		;CLEAR LAST BLOCK READ
	CLR	FIBPHS+2
	MOV	(SP)+,R2	;RESTORE R2
	RETURN

.DSABL	LSB
GLOBAL	<SAVUNT,CHANO,SYSNDX,SYSUNT,DCS,FIBPHS>

.SBTTL	GETSYM - DECODE A GLOBAL SYMBOL ADDRESS

;+
; GETSYM - DECODE A GLOBAL SYMBOL ADDRESS
;
;	CALL	GETSYM,R5
;	 .RAD50	"SYMBOL"
;
; RETURNS
;	R2 = MSB OF DISK BYTE ADDRESS
;	R3 = LSB OF DISK BYTE ADDRESS
;	C = 0 IF SYMBOL WAS FOUND
;	C = 1 IF SYMBOL NOT FOUND
;-

.ENABL	LSB

GTSYM1:	CLR	FTLGET		;MAKE SURE WE SET
	COM	FTLGET		; THE FATAL ERROR FLAG TO NON-FATAL
	BR	10$		;  BECAUSE WE MIGHT NOT FIND A SYMBOL
GETSYM:	CLR	FTLGET		;LOOKUP FAILURES ARE NOW FATAL
10$:	MOV	R0,-(SP)	;GET A WORKING REGISTER
	MOV	(R5)+,SYMBOL	;REMEMBER THE DESIRED SYMBOL
	MOV	(R5)+,SYMBOL+2	;REMEMBER ALL OF IT
	MOV	R5,-(SP)	;SAVE THE RETURN ADDRESS
	CLR	R2		;GET THE BLOCK OFFSET
	MOV	STBLOC,R2	; OF THE STB
	MUL	#512.,R2	;MAKE IT A BYTE ADDRESS
	MOV	STBNUM,R0	;GET NUMBER OF SYMBOLS
	DEC	R0		;BIAS IT, SLIGHTLY
20$:	CALL	INIWRD		;GET THE FIRST WORD
	ADD	#2,R3		;POINT TO THE NEXT WORD
	ADC	R2		;ADJUST MSB OF POINTER
	CMP	(SP)+,SYMBOL	;DO THEY MATCH?
	BNE	30$		;NO
	CALL	INIWRD		;GET THE SECOND WORD
	CMP	(SP)+,SYMBOL+2	;IS IT A MATCH?
	BEQ	50$		;YES
30$:	ADD	#6,R3		;ELSE POINT TO THE NEXT SYMBOL
	ADC	R2		;FIX THE MSB
	SOB	R0,20$		;TRY TO MATCH THE NEXT SYMBOL
	TST	FTLGET		;DIDN'T FIND IT. ARE LOOKUP FAILURES FATAL?
	BEQ	40$		;YES, SO TOO BAD
	MOV	(SP)+,R5	;NO, SO RESTORE OLD R5
	MOV	(SP)+,R0	; AND OLD R0
	SEC			;INDICATE SOFT FAILURE
	RETURN	R5		;NOW LET CALLER WORRY ABOUT IT.

40$:	ERF	<"No BOOT in STB of INIT.SYS">

50$:	ADD	#2,R3		;GET SYMBOL'S OVLY DESCRIPTOR NUMBER
	ADC	R2		;FIX MSB
	CALL	INIWRD		;GET IT
	MOV	(SP)+,R0	;R0 = OVERLAY DESCRIPTOR NUMBER
	CMP	R0,OVBNUM	;IS IT <= NUMBER OF OVERLAYS?
	BHI	60$		;NOPE
	ADD	#2,R3		;GET THE SYMBOL'S VALUE
	ADC	R2		;FIX MSB
	CALL	INIWRD		;LEAVE THAT ON THE STACK
	CLR	R2		;GET BLOCK OFFSET
	MOV	OVBLOC,R2	; OF OVERLAY BLOCK DESCRIPTORS
	MUL	#512.,R2	;MAKE IT A BYTE ADDRESS
	ASH	#3.,R0		;OVLY NUM * 8 TO INDEX INTO OVLY BLOCK
	ADD	R0,R3		;MAKE AN ABSOLUTE ADDRESS
	ADC	R2		;FIX MSB
	CALL	INIWRD		;GET THE OVERLAY'S BASE ADDRESS
	MOV	2(SP),R0	;GET SYMBOL'S RELATIVE VALUE
	SUB	(SP)+,R0	;SUBTRACT THE BASE VIRTUAL ADDRESS
	TST	(SP)+		;TOSS SYMBOL'S RELATIVE VALUE
	ADD	#4,R3		;GET BYTE OFFSET TO THE OVERLAY
	ADC	R2		;FIX MSB
	CALL	INIWRD		;GET IT
	ADD	#2,R3		;GET LSB OF BYTE OFFSET
	ADC	R2		;FIX MSB
	CALL	INIWRD		;GET IT
	MOV	(SP)+,R3	;R3 = LSB OF BYTE OFFSET OF THE OVERLAY
	MOV	(SP)+,R2	;R2 = MSB OF BYTE OFFSET OF THE OVERLAY
	ADD	R0,R3		;ABSOLUTELY POINT TO THE DATA
	ADC	R2		;FIX MSB
	MOV	(SP)+,R5	;RESTORE THE RETURN ADDRESS
	MOV	(SP)+,R0	;RESTORE R0
	CLC			;INDICATE MUCH SUCCESS
	RETURN	R5		;AND RETURN

60$:	ERF	<"Illegal overlay number in INIT">

.DSABL	LSB
