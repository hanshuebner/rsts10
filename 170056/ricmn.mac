TITLE	RICMN,<RESTOR/IMAGE COMMON>,0A,10-MAY-91,JDB

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY

;+
;
;  001	AWR  15-APR-81	V7.0 PATCH 1.1.15 INSTALLED
;  002	GPK  10-Aug-82	Init bootstrap changes
;  003	JDB  13-OCT-82	MODIFIED FOR NEW DISK STRUCTURE			;JDB003
;  004	JDB  14-JAN-83	PREVENT ODD ADDRESS TRAPPING IN CHKREL		;JDB004
;  005  MNB  21-FEB-83  ADD GFD ERROR MESSAGES				;MNB005
;  006  MNB  03-MAR-83  CHANGE DCN'S TO BLOCKS PRIOR TO EXPAND: CALL	;MNB006
;  007  JDB  25-APR-84  SOURCE CLEAR 1.1.17, 1.1.22, 1.1.23		;JDB007
;  008  JDB   1-MAY-84  PREVENT DISK ERROR IN FIXGRP			;JDB008
;  009  JDB  14-MAY-84  CORRECT XFERAD AND LOAD SIZE FOR HOOK (FIXBOO)	;JDB009
;  010  JDB  06-DEC-84  FIX ACCOUNT LOSS ON OUTPUT			;JDB010
;
;-

.SBTTL	RICMN DATA

	I.DATA
DCN1ST:	.BLKW0			;0 MEANS VERY 1ST DCN OF A FILE
FIXNE:	.BLKW0			;<>0 MEANS RP TO 1ST UFD CLUS MUST BE FIXED
PCN1ST:	.BLKW0			;START OF WHERE RE-RELOCATED CHUNK GOES
RELCNT:	.BLKW0			;COUNT OF RELOCATED PCN'S
STRDCN:	.BLKW0			;1ST DCN IN RETRIEVAL ENTRY
SCNRP:	.BLKW0			;LINK TO FILE RETRIEVAL ENTRY
SCNUAR:	.BLKW0			;IF FIXNE<>0, REPLACE OLD 1ST RP IN MFD N.E
				;WITH THIS VALUE
SCNUST:	.BYTE	0		;FILE'S USTAT BYTE
	.EVEN
XPAND:	.BLKW0			;ENTITY CLUSIZ/PCS = # OF BITS IN SATT
	UNORG

.SBTTL	SOME DEFINITIONS
.EQUATE	USERPC,40		;OFFSET FOR INTI TRANSFER ADDRESS
.EQUATE	USERTOP,50		;OFFSET FOR INIT LOAD WORD COUNT

.SBTTL	PUTRST - PUT TO RSTS DISK

;+
; PUTRST - TRANSFER PACK CLUSTERS FROM THE BUFFER TO THE OUTPUT DISK
;
;	BLKXF	= # OF BLOCKS TRANSFERRED PRIOR TO THIS CALL
;	PCNRD	= # OF PACK CLUSTERS STORED IN THE BUFFER
;
;	THE 1ST 'PCNRD' ENTRIES OF THE PCN STORAGE TABLE (STARTING AT
;	XFRPCN) CONTAIN THE PCN'S OF THE SOURCE CLUSTERS CURRENTLY
;	STORED IN BUFBEG.
;
;	CALL	PUTRST
;
;	RETURNS: NOTHING FATAL HAPPENED
;	BLKXF	= UPDATED # OF BLOCKS TRANSFERRED
;
;-
.ENABL	LSB

PUTRST:	REGSCR			;SAVE REGISTERS
	MOV	PCNUM,-(SP)	;SAVE THE INPUT PCN
	CALL	SETCH2		;SET UP CHANNEL 2

;	CHECK ALL INPUT PC'S TO SEE IF THEY ARE KNOWN TO BE BAD

	MOV	PCNRD,R0	;MUST WRITE AS MANY AS WERE READ
10$:	MOV	(R4)+,R3	;GET THE PCN OF A CLUSTER TO WRITE
	CALL	KWNBB		;IS THIS PCN A KNOWN OUTPUT BAD BLOCK?
	BCS	20$		;HERE, UNKNOWN MEANS NOT BAD
	CALL	BBOURS		;IT'S KNOWN TO BE BAD - FIND A FREE SPOT
				; (RETURNS R2=NEW PCN)
	MOV	R2,-2(R4)	;REPLACE WHERE IT'S GOING
20$:	SOB	R0,10$		;FOR ALL OF THEM

;	DO THE TRANSFER, OPTIMIZING FOR CONTIGUOUS OUTPUT PCN'S

	MOV	PCNRD,R0	;AGAIN..
	MOV	#XFRPCN,R4	;START OF TRANSFER TABLE
30$:	CALL	CNTCTG		;HOW MANY STARTING FROM HERE ARE CONTIG?
40$:	MOV	PCNUM,R2	;GET CHUNK STARTER
	CALL	RWRST,R5,WFUN	;WRITE A CHUNK
	BCS	70$		;BAD BLOCK ERROR
	CALL	50$		;DID WE JUST PUT THE MFD?
	ASL	R1		;WE WANT BYTES
	ADD	R1,BUFPTR	;GET BACK THE WORD COUNT
	TST	R0		;ANY LEFT?
	BNE	30$		;YES - KEEP GOING
	MOV	PCS,R1		;WILL ADD PCS*READ COUNT TO
	MUL	PCNRD,R1	; GET BLOCK COUNT
	ADD	R1,BLKXFV	;INC # OF BLOCKS XFERRED TO THIS VOLUME
	ADC	BLKXFV+2	;(2 WORDS WORTH)
	MOV	(SP)+,PCNUM	;RESTORE THE INPUT PCN
	RETURN

50$:	TST	PCNUM		;DID WE JUST PUT THE PACK LABEL?	;JDB003
	BNE	60$		;NOPE
	CALL	MFDHND		;YES - HANDLE IT
60$:	RETURN

;	HIT A PREVIOUSLY UNKNOWN BAD BLOCK

70$:	CLR	KNOWN		;THIS IS A NEW BAD BLOCK
	CALL	50$		;DID WE JUST PUT THE MFD?
	CALL	XSETUP		;POINT TO XFER TABLE, CLEAR BUFPTR
	MOV	BADDCN,R2	;GET THE BAD DCN
	CALLX	RIB2CN		;CONVERT TO PCN IN R3
	CALL	BBOURS		;TRY TO RELOCATE IT (RETURNS R2=NEW PCN)
	MOV	PCNRD,R0	;GET COUNT IN TABLE
	MOV	PCSWDS,R1	;NEED TO BUMP BUFPTR
	ASL	R1		;BY BYTES
80$:	CMP	(R4)+,R3	;THIS IT?
	BEQ	90$		;YUP
	ADD	R1,BUFPTR	;BUMP PAST 1 ENTRY
	SOB	R0,80$		;R0 = COUNT LEFT TO XFER ON EXIT
90$:	MOV	R2,-(R4)	;REPLACE WHERE IT GOES - WILL RESTART
				; XFER FROM HERE
	BR	30$		;ONWARD

GLOBAL	<XFRPCN,PCNUM,PCS,PCSWDS>
.DSABL	LSB

.SBTTL	MFDHND - MFD PACK CLUSTER HANDLER

;+
; MFDHND - MFD PACK CLUSTER HANDLER
;
;	CALL:	PCNUM = 0
;		PACK LABEL IS FIRST BLOCK IN IOBUFF			;JDB003
;		CALL	MFDHND
;
;	RETURN:	MFD LABEL ENTRY HAS PCS = -1
;		PACK LABEL PC HAS BEEN VERIFIED IF REQUESTED		;JDB003
;	NOTE THAT WE DIE ON MFD I/O ERRORS
;-

.ENABL	LSB

MFDHND:	MOV	R0,-(SP)	;SAVE R0
	MOV	R1,-(SP)	;SAVE R1
	MOV	R3,-(SP)	;SAVE R3
	MOV	#BUFBEG+10,-(SP);IOBUFF OFFSET FOR PCS
	MOV	#-1,-(SP)	;MAKE IT -1
	CALLX	PUTIOB		;PUT IT IN
	TST	(SP)+		;POP OFFSET
	MOV	#256.,R1 	;1 BLOCK
	CALL	WDSKIO,R5	;REWRITE MFD BLOCK
	  BR	60$		;BAD BLOCK IN MFD
	  BIT	#VE,SWTWRD	;OK - WAS VERIFY REQUESTED ?
	BEQ	40$		;NO
	MOV	BUFPTR,-(SP)	;YES - SAVE BUFPTR
	CALLX	SAVSAT		;THROW SATT UP TO SATBF2 SO WE CAN USE IT
	CLRB	HIGHBF		;FOR I/O TO SATBUF
	MOV	#SATBUF,BUFPTR	;POINT TO IT
	MOV	PCSWDS,R1	;GET # WORDS/PC IN R1
	CALL	RDSKIO,R5	;READ THE PC
	  BR	60$		;BAD BLOCK IN MFD
	  MOV	#BUFBEG,R0	;OK - GET IOBUFF OFFSET
	CLR	R3		;SATBUF OFFSET
10$:	MOV	R0,-(SP)	;STACK THE OFFSET
	CALLX	GETIOB		;GET A WORD FROM IOBUFF
	CMP	(SP)+,SATBUF(R3);COMPARE IT AGAINST SATBUF
	BNE	50$		;UNEQUAL
20$:	CMP	(R0)+,(R3)+	;INCREMENT POINTERS UP TO NEXT WORD
	SOB	R1,10$		;DO FOR ALL WORDS IN PC
30$:	MOV	(SP)+,BUFPTR	;RESTORE BUFPTR
	MOVB	#1,HIGHBF	;RESTORE HIGHBF FOR I/O TO IOBUFF
	CALLX	RESSAT		;RESTORE THE SATT
	CALL	SETBF2		;RE-SETUP SATBF2
40$:	MOV	(SP)+,R3	;RESTORE R3
	MOV	(SP)+,R1	;RESTORE R1
	MOV	(SP)+,R0	;RESTORE R0
	RETURN

50$:	CMP	#10,R3		;IS THIS WORD THE PCS ?
	BEQ	20$		;YES - FORGET IT
60$:	CALL	BDMFD		;GO DIE

.DSABL	LSB
GLOBAL	<SWTWRD,HIGHBF,SATBUF,PCSWDS>

.SBTTL	BBOURS - BAD BLOCK ON OUTPUT RSTS DISK

;+
; BBOURS - HANDLE A BAD BLOCK ON AN OUTPUT RSTS DISK
;
;	R3 = PCN AT WHICH BAD BLOCK OCCURRED
;
;	CALL	BBOURS
;
;	RETURNS: ONLY IF SUCCESSFUL
;		R2 = PCN WHERE DATA SHOULD BE RELOCATED
;
;	NOTE THAT WE DIE IF NO FREE CLUSTER FOR RELOCATION OR
;	TOO MANY OUTPUT BAD BLOCKS
;
;-

.ENABL	LSB

BBOURS:	MOV	R0,-(SP)	;SAVE R0
	MOV	RELPTR,R0	;POINT TO THE 'OLD' ENTRY IN RELOC
	ADD	RELOC,R0	;INPUT TABLE
	MOV	R3,(R0)		;STORE THE OLD PCN (ALSO FOR SETBI2)
	TST	KNOWN		;WAS THIS A KNOWN BAD BLOCK?
	BNE	10$		;YES - DON'T ADD TO BB FILE
	CALL	ADDBBO		;ADD IT TO OUR BB FILE
	CALL	SETBI2		;SET THE BIT IN SATBF2 SO IT WON'T BE
				; USED FOR RELOCATION
10$:	CALL	FINFRE		;TRY TO FIND SOMEPLACE TO RELOCATE IT
	MOV	RELPTR,R0	;FOUND IT - POINT TO THE 'NEW' ENTRY IN RELOC
	ADD	RELOC+2,R0	;OUTPUT TABLE
	MOV	R2,(R0)		;STORE THE NEW PCN (R2, FROM FINFRE)
	ADD	#2,RELPTR	;GET READY FOR NEXT TIME
	MOV	(SP)+,R0	;RESTORE R0
	RETURN

ADDBBO:	INC	UNKBBO		;INC THE UNKNOWN OUTPUT BAD BLOCK COUNT
	MOV	UNKBBO,R0	;PREPARE TO GET TOTAL # OF OUTPUT BB'S
	ADD	NBADO,R0	;ADD IN KNOWN BAD B'S
	CMP	R0,MAXBB	;COMPARE TO MAX ALLOWED
	BHI	20$		;TOO MANY
	MOV	CNBBO,R0	;POINT TO WHERE THIS ENTRY GOES
	MOV	R3,(R0)+	;AND PUT IT THERE
	MOV	R0,CNBBO	;BUMP WHERE THE NEXT WILL GO
	RETURN

20$:	MOV	#TMBBO,ABTADR	;TOO MANY OUTPUT BAD BLOCKS
	CALL	CHKABT		;GO AND DIE

GLOBAL	<RELOC,RELPTR,CNBBO,NBADO,UNKBBO,MAXBB>
.DSABL	LSB

.SBTTL	SETBF2 - SET UP SATBF2

;+
; SETBF2 - SET UP SATBF2
;
;	CALL	SETBF2
;
;	RETURNS SATBF2 SET UP TO REFLECT INPUT SATT COMBINED WITH
;	KNOWN OUTPUT BAD BLOCKS AND THE DESTINATIONS OF ANY RELOCATIONS.
;	CLEAR BITS ARE NEITHER ALLOCATED ON
;	THE ORIGINAL DISK NOR ENTRIES IN THE KNOWN OUTPUT BAD BLOCK FILE.
;	ALLOWS RELOCATION WITHOUT REPEATED CHECKS TO OUTPUT BB FILE.
;
;-

.ENABL	LSB

SETBF2:	REGSCR			;SAVE THEM REGISTERS
	CALLX	SAVSAT		;FIRST, COPY SATBUF TO SATBF2
	MOV	NBADO,R3	;GET THE KNOWN OUTPUT BAD BLOCK COUNT
	ADD	UNKBBO,R3	;ADD IN THE ONES WE FOUNS
	BEQ	10$		;NONE - ALL DONE
	MOV	BADBO,R1	;BUFFER POINTER
	MOV	CNBBO,R5	;END OF BUFFER POINTER
	CALL	30$		;PUT BITS IN SATBF2
10$:	MOV	RELPTR,R5	;RELOCATION OFFSET
	BEQ	20$		;NONE - ALL DONE
	MOV	RELOC+2,R1	;REL. DEST. TABLE POINTER
	ADD	R1,R5		;ADDRESS OF END OF LIST
	CALL	30$		;PUT BITS IN SATBF2
20$:	RETURN

30$:	CMP	R1,R5		;LAST ENTRY?
	BEQ	40$		;YES - ALL DONE
	MOV	(R1)+,R0	;PUT THE PCN IN R0
	CALL	SETBI2		;SET THE BIT
	SOB	R3,30$		;TILL THE END
40$:	RETURN

SETBI2:	MOV	R2,-(SP)	;SAVE R2
	MOV	R4,-(SP)	; AND R4
	CALLX	FIXREG		;CONVERT PCN IN R0 TO BIT(R2)/OFFSET(R4)
	MOV	R4,-(SP)	;PUSH THE SATBF2 OFFSET
	CALLX	GETSB2		;GET THE APPROPRIATE BYTE FROM SATBF2
	BISB	BITBYT(R2),(SP)	;ALLOCATE THE BIT
	CALLX	PUTSB2		;REPLACE THE BYTE
	MOV	(SP)+,R4	;RESTORE R4
	MOV	(SP)+,R2	; AND R2
	RETURN

.DSABL	LSB
GLOBAL	<RELOC,RELPTR,BITBYT,NBADO,UNKBBO,BADBO,CNBBO>

.SBTTL	FINRST - DONE WITH RSTS OUTPUT

;+
; FINRST - UPDATE ALL DIRECTORY INFO - IF ALL GOES WELL,
;		PUT CORRECT PCS IN PACK LABEL				;JDB003
;
;	CALL	FINRST
;
;	RETURNS: ALL IS WELL
;-

.ENABL	LSB

FINRST:	CALL	SCNDIR		;CHECK FOR UNEXPECTED INPUT BAD BLOCKS AND
				; BAD COMPARES - WILL NOT COME BACK IF ANY
				; FOUND AND /NOERROR SPECIFIED
	CALL	FIXDIR		;TRY TO UPDATE DIRECTORY INFO - WILL NOT COME
				; BACK IF DE-CONTIGGED OR UNPLACED AND
				; /NOERROR SPECIFIED
	CALL	FIXBAD		;FINALLY, CORRECT BADB.SYS
	CLRB	HIGHBF		;NOT I/O TO IOBUFF ANY MORE
	CALL	SETCH2		;SET UP THE OUTPUT CHANNEL
	CALL	FSRDPL		;READ IN THE PACK LABEL			JDB003
	BNE	20$		;BAD PACK LABEL!			;JDB003
	MOV	PCS,FIBUF+10	;REPLACE THE PCS SO THE DISK IS USABLE
	BIS	#UC.MNT,FIBUF+12;SET PACK DIRTY BIT 'TILL WE WRITE THE SATT
	MOV	M.TBL,R4	;POINT TO THE OUTPUT MOUNT TABLE
	MOV	MNTPID(R4),FIBUF+14	;REPLACE THE PACK ID
	MOV	MNTPID+2(R4),FIBUF+16	;SECOND WORD
	CALL	FSWRIT		;WRITE IT BACK OUT
	BNE	20$		;BAD OUTPUT PACK LABEL			;JDB003
	CALL	FIXBOO		;FIX BOOT & DCN LIST IN BOOT BLOCK
	CALL	WRTSAT		;WRITE THE SATT
	BCS	10$		;FAILED - LEAVE DISK DIRTY
	CALL	FSRDPL		;READ IN THE PACK LABEL			;JDB003
	BNE	20$		;BAD PACK LABEL!			;JDB003
	BIC	#UC.MNT,FIBUF+12;MAKE THE PACK CLEAN AGAIN
	CALL	FSWRIT		;WRITE OUT PACK LABEL			;JDB003
	BNE	20$		;BAD PACK LABEL!			;JDB003
10$:	RETURN

20$:	CALL	BDMFD		;BAD PACK LABEL - DIE			;JDB003

.DSABL	LSB
GLOBAL	<HIGHBF,I.DSQ,PCS,FIBUF>

.SBTTL	FINFRE - FIND A FREE CLUSTER

;+
; FINFRE - FIND A FREE CLUSTER FOR RELOCATION
;
;	CALL	FINFRE
;
;	RETURNS: FREE CLUSTER FOUND
;		R2 = PCN OF THE FREE CLUSTER
;
;	NOTE THAT WE DIE ('VOLUME IS FULL') IF NO FREE CLUSTER AVAILABLE
;-

.ENABL	LSB

FINFRE:	MOV	R0,-(SP)	;SAVE R0
	MOV	R1,-(SP)	; AND R1
	MOV	R5,-(SP)	; AND R5
	CLR	R2		;PCN COUNTER
	CLR	R1		;R1 = SATT BYTE POINTER
	MOV	SATSYS+BITS,R0	;R0 = # OF CLUSTERS IN SATT
	MOV	#1,R5		;R5 = BIT IN SATT BYTE WE'RE CHECKING
				;START AT BIT ZERO
	MOV	R1,-(SP)	;PUSH SATBF2 OFFSET
	CALLX	GETSB2		;GET THE BYTE FROM SATBF2
10$:	BITB	R5,(SP)		;IS THE BIT ON?
	BEQ	30$		;NO - IT'S FREE - WILL RELOCATE HERE
	INC	R2		;BUMP THE PCN
	ASLB	R5		;SHIFT BIT LEFT ONE
	BCC	20$		;STILL IN SAME BYTE?
	INC	R1		;NO - GO ON TO THE NEXT BYTE
	INC	R5		; AND RESET OUR MASK TO ZERO
	MOV	R1,(SP)		;PLUG IN THE NEW OFFSET
	CALLX	GETSB2		;AND GET ANOTHER BYTE
20$:	SOB	R0,10$		;CHECK THEM ALL
	CALL	FULLUP		;NO FREE CLUSTER! 'VOLUME IS FULL'

;	FOUND A FREE BIT
30$:	BISB	R5,(SP)		;TURN ON THE BIT
	CALLX	PUTSB2		; IN THE DESTINATION SATT
40$:	MOV	(SP)+,R5	;RESTORE R5
	MOV	(SP)+,R1	; AND R1
	MOV	(SP)+,R0	; AND R0
	RETURN

GLOBAL	<PCNUM,SATSYS>
.DSABL	LSB

.SBTTL	FIXDIR - FIX UP THE OUTPUT DIRECTORY

;+
; FIXDIR - FIX UP THE OUTPUT DIRECTORY
;
;	CALL	FIXDIR
;	RETURNS ONLY IF NOTHING FATAL HAPPENED
;	DIES IF:	FATAL BAD BLOCK
;			/NOERROR SPECIFIED AND DE-CONTIGGED OR UNPLACED
;-

.ENABL	LSB

FIXDIR:	CALLX	RESSAT		;PUT SATBF2 IN SATBUF
	CALL	SETREL		;SET UP RELCNT AND MISSNG
	TST	RELCNT		;ANY RELOCATIONS ?
	BEQ	90$		;NO - GET OUT
	CALL	SETCH2		;WE'RE FIXING THE OUTPUT
	CALL	CHKMFD		;CLEAR VARIABLES, GET MFD IN FIBUF, PREPARE
				;TO SCAN MFD MAP
	BIT	#20000,PKSTAT	;IS THIS AN OLD PACK			;JDB003
	BEQ	5$		;BRANCH IF SO - DO IT THE OLD WAY	;JDB003
	CALL	FXDRNW		; ELSE DO IT THE NEW WAY		;JDB003
	BR	90$		; AND BE GONE				;JDB003
5$:	CALL	CHKREL		;ANY BADDIES?
	BCC	20$		;NOPE
	MOV	#FIBENT,R5	;HAD BEST NOT BE THE 1ST CLUSTER!
	CMP	(R5),STRDCN	; IF THAT CHANGED, WE MOVED THE MFD!
	BEQ	10$		; RELIEF - IT WASN'T MOVED
	CALL	BDMFD		;???BAD MFD
10$:	CALL	REPMAP		;REPLACE ALL MFD MAPS WITH NEW ONE
	TST	MISSNG		;HAVE WE ALREADY FOUND THEM ALL?
	BEQ	80$		;YES!
20$:	MOV	#FIBUF,R5	;POINT TO LINK TO FIRST ACCOUNT IN MFD
30$:	MOV	(R5),R3		;R3 = LINK (IN MFD) TO NEXT NAME ENTRY
	BIC	#UL.FLG,R3	;MINUS FLAG BITS
	BEQ	70$		;DONE - BUT NOT ALL WERE FOUND
40$:	CALL	RDBFIX		;READ IN THE MFD NAME ENTRY
	BITB	#US.UFD,USTAT(R5) ;IS THIS AN ACCOUNT?
	BEQ	30$		;NO, IT'S A FILE IN [1,1]
	MOV	UNAM(R5),SCNPPN	;SAVE THE PPN WE'RE SCANNING
	MOV	UAR(R5),R2	;GET RP TO 1ST BLOCK OF THE UFD
	BEQ	30$		;0 MEANS UFD DOESN'T EXIST
	MOV	R3,SCNUFL	;SAVE THE LINK IN MFD TO THIS UFD NE
	MOV	FIBPHS,CURFBN	;SAVE LSB OF THE BLOCK IN MFD WITH THIS UFD NE
	MOV	FIBPHS+2,CURFBN+2 ; AND SAVE THE MSB	
	CALL	FIXACC		;SCAN THE ACCOUNT
				;NOTHING FATAL IF WE CAME BACK
	TST	FIXNE		;NEED TO CORRECT NAME ENTRY?
	BNE	50$		;YES - MAKE SURE IT GETS DONE
	TST	MISSNG		;FOUND EM ALL YET?
	BEQ	80$		;GOODY - ALL DONE
50$:	MOV	CURFBN+2,R3	;RESTORE FBN MSB TO R3
	MOV	CURFBN,R2	; AND FBN LSB TO R2
	CALL	FSREAD		;READ BACK THE BLOCK IN MFD WITH THIS UFD NE
	BNE	100$		;BAD BLOCK
	MOV	SCNUFL,R3	;NOW, GET THE NE AGAIN
	CALL	RDBFIX		;TRY THE GET - DON'T COME BACK IF COULDN'T
	TST	FIXNE		;DOES JUST READ MFD N.E. NEED FIXING?
	BEQ	60$		;NO
	MOV	SCNUAR,UAR(R5)	;CORRECT THE 1ST R.P.
	MARK	FIBUF		;MAKE SURE IT'S RE-WRITTEN
60$:	TST	MISSNG		;ANY MORE TO FIND ?
	BEQ	80$		;NO
	BR	30$		;ON TO THE NEXT ACCOUNT

70$:	TST	MISSNG		;WELL, DID WE FIND THEM ALL?
	BEQ	80$		;YUP, NO NEED FOR EXTRA MESSAGE
	ERF	<"FIXDIR">	;BAD DIRECTORY SCAN

80$:	CALL	FSIO1		;ALMOST ALL DONE - PRE I/O SETUP
	CALLX	WRITEC		;WRITE FIBUF, IF REQUIRED
	CALL	FSIO2		;POST CALL - CHECK FOR ERROR
	BEQ	90$		;OK
	CMPB	#DATERR,IOERR	;BAD BLOCK??
	BEQ	100$		;TOO LATE!
	MARK	FIBUF		;MARK IT DIRTY AGAIN
	CALL	RETFRE		;RESET/RETRY
	BR	80$

90$:	RETURN

100$:	CALL	FATBAD		;FATAL BAD BLOCK

.DSABL	LSB
GLOBAL	<FIBUF,FIBPHS,CURFBN,IOERR,PKSTAT>

.SBTTL	FXDRNW - FIX UP THE OUTPUT DIRECTORY ON A NEW STYLE DISK	;JDB003

;+
; FXDRNW - FIX UP THE OUTPUT DIRECTORY ON A NEW STYLE DISK
;
;	FIRST BLOCK OF FIRST MFD CLUSTER IN FIBUF
;
;	CALL	FXDRNW
;
;	REGISTERS 0-5 PRESERVED
;	RETURNS ONLY IF NOTHING FATAL HAPPENED
;	DIES IF:	FATAL BAD BLOCK
;			/NOERROR SPECIFIED AND DE-CONTIGGED OR UNPLACED
;-

.ENABL	LSB

FXDRNW:	REGSCR			;PRESERVE R0-R5
	CALL	CHKREL		;ANY BADDIES?
	BCC	20$		;NOPE
	MOV	FIBENT,R5	;HAD BEST NOT BE THE 1ST CLUSTER!
	CMP	R5,STRDCN	; IF THAT CHANGED, WE MOVED THE MFD!
	BEQ	10$		; RELIEF - IT WASN'T MOVED
	CALL	FIXPLB		; ELSE FIX UP THE PACK LABEL TO POINT TO IT
10$:	CALL	REPMAP		;REPLACE ALL MFD MAPS WITH NEW ONE
	TST	MISSNG		;HAVE WE ALREADY FOUND THEM ALL?
	BEQ	30$		;YES!
20$:	MOV	#FIBUF,R4	;POINT TO FIRST DCN PTR
	MOV	FIBENT,R5	;GET DCN OF FIRST MFD CLUSTER
25$:	CALL	FIXGFD		;FIX CURRENTLY POINTED GFD AS REQUIRED
	TST	MISSNG		;HAVE WE GOTTEN ALL OF THEM?
	BEQ	30$		;BRANCH IF SO - ALL DONE
	CMP	#FIBUF+512.,R4	;ANY MORE GFD'S?
	BNE	25$		;BRANCH IF SO - GO FIX 'EM
30$:	RETURN			;THAT'S ALL FOLKS!

.DSABL	LSB


.SBTTL	FIXPLB - FIX UP THE PACK LABEL WHEN 1ST MFD CLUSTER MOVED	;JDB003

;+
; FIXPLB - FIX UP THE PACK LABEL WHEN 1ST MFD CLUSTER MOVED
;
;	FIRST BLOCK OF FIRST MFD CLUSTER IN FIBUF
;	R5=CURRENT DCN OF FIRST MFD CLUSTER
;
;	CALL	FIXPLB
;
;	REGISTERS 0-5 PRESERVED
;	RETURNS ONLY IF NOTHING FATAL HAPPENED
;	DIES IF:	FATAL BAD BLOCK
;-

.ENABL	LSB

FIXPLB:	REGSCR			;PRESERVE R0-R5
	CALL	STOMAP		;PRESERVE THE MFD CLUSTER MAP
	CALL	FSRDPL		;READ IN THE PACK LABEL
	BCS	100$		;BRANCH IF ANY PROBLEM
	MOV	R5,FIBUF+MDCN	;CORRECT MFD DCN IN PACK LABEL
	MARK	FIBUF		;MAKE SURE PACK LABEL GETS REWRITTEN
	MOV	R5,R2		;COPY MFD START DCN
	CALL	FSRDRF		;GET FIRST MFD CLUSTER BACK
	BCS	100$		;BRANCH IF ANY PROBLEM
	CALL	RESMAP		;RESTORE MFD CLUSTER MAP
	RETURN			;THAT'S ALL FOLKS!

100$:	CALL	BDMFD		;INDICATE MFD OR PACK LABEL ERROR

.DSABL	LSB

.SBTTL	FIXGFD - FIX UP THE CURRENTLY POINTED GFD		;JDB003
;+
;
;	INPUTS: R5 = DCN OF FIRST MFD CLUSTER (IN FIBUF)
;		R4=ADDRESS (WITHIN FIBUF) OF CURRENT GFD'S DCN PTR
;
;	OUTPUT: R4=UPDATED TO PT TO NEXT GFD DCN PTR (IF ANY)
;		R5 PRESERVED
;
;-

.ENABL LSB

FIXGFD:	MOV	R5,-(SP)	;PRESERVE MFD'S FIRST DCN
	MOV	R5,R2		;COPY DCN OF FIRST BLOCK OF FIRST MFD CLUSTER
	CALL	CNVRIB		;CONVERT DCN IN R2 TO FBN IN R2 AND R3
	ADD	#1,R2		;POINT TO BLOCK 2 OF CLUSTER 1 (DCN PTR BLOCK)
	ADC	R3		; (MSB)
	CALL	READ		;READ IN THE DCN POINTER BLOCK FROM THE MFD
	BCS	100$		;BRANCH IF IT COULDN'T BE HAD - BAD
	MOV	(R4)+,R2	;GET DCN PTR OF THIS GFD AND POP TO NEXT
	BEQ	30$		;BRANCH IF GFD NOT ALLOCATED
	CALL	RIB2CN		;CONVERT DCN IN R2 TO PCN IN R3
	MOV	MISSNG,-(SP)	;(EVERYONE CLAIMS SNCREL MESSES IT UP)
	CALL	SCNREL		;SEE IF THAT ONE WAS RELOCATED
	MOV	(SP)+,MISSNG	; (RESTORE MISSNG)
	BCC	10$		;BRANCH IF NOT - IT'LL BE EASIER
	MOV	NEWPCN,R3	; ELSE GET NEW PCN WHERE IT MOVED TO
	CALL	PCNDCN		;CONVERT PCN IN R3 TO DCN IN R3
	MOV	R3,R2		;COPY IT FOR IMPENDING READ
	MOV	R2,-2(R4)	;FIX IT IN THE DCN PTR BLOCK OF THE MFD
	MARK	FIBUF		;MAKE SURE WE WRITE DCN PTR BLOCK BACK
10$:	CALL	FSRDRF		;GET FIRST BLOCK OF GFD
	BCS	100$		;BRANCH IF PROBLEMS
	MOV	#FIBENT,R5	;POINT TO ITS CLUSTER MAP		;JDB004
	CALL	CHKREL		;ANY RELOCATED ONES IN GFD?
	BCC	20$		;NOPE
	CALL	REPMAP		;REPLACE ALL GFD MAPS WITH NEW ONE
	TST	MISSNG		;HAVE WE ALREADY FOUND THEM ALL?
	BEQ	30$		;YES!
20$:	CALL	FIXGRP		;FIX UP GFD'S OFFSPRING
30$:	MOV	(SP)+,R5	;RESTORE MFD'S FIRST DCN NUMBER
	RETURN			;THAT'S ALL FOLKS!

100$:	CALL	FATBAD		;NEW/FATAL BAD BLOCK

GLOBAL	<CNVRIB>
.DSABL LSB

.SBTTL	FIXGRP - FIX UP ANY UFD'S WHICH BELONG TO A .SBTTL	FIXGRP - FIX UP ANY UFD'S WHICH BELONG TO A GFD		;JDB003

;+
; FIXGRP - FIX UP AN ENTIRE GROUP
;
;	INPUTS : R2,R3 = FBN OF FIRST CLUSTER OF GFD
;
;	RETURN : ALL REGISTERS PRESERVED
;
;-

.ENABL LSB

FIXGRP:	REGSCR			;PRESERVE R0-R5
	MOV	#FIBUF,R4	;INITIALIZE DCN PTR BLOCK PTR
	ADD	#1,R2		;POINT TO BLOCK 2 OF CLUSTER 1 (DCN PTR BLK)
	ADC	R3		; (MSB)
10$:	CALL	READ		;GET DCN PTR BLOCK OF GFD
	BCS	100$		;BRANCH IF YOU COULDN'T - IT'S FATAL
	MOV	R2,-(SP)	;PRESERVE FBN
	MOV	R3,-(SP)	; (MSB)
	MOV	(R4)+,R2	;GET START DCN OF NEXT UFD
	BEQ	20$		;BRANCH IF UFD WASN'T ALLOCATED
	MOV	R4,-(SP)	;PRESERVE PTR TO NEXT DCN PTR
	CALL	FIXACC		; ELSE FIX UP THIS ACCOUNT
	MOV	(SP)+,R4	;RESTORE PTR TO NEXT DCN PTR
	TST	FIXNE		;WAS FIRST DCN OF UFD RELOCATED?
	BEQ	20$		;BRANCH IF NOT - THAT MAKES IT EASIER
	MOV	(SP),R3		;RETRIEVE FBN OF DCN PTR BLOCK		;JDB008
	MOV	2(SP),R2	; (LSB)					;JDB008
	CALL	READ		;GET THE DCN PTR BLOCK BACK
	BCS	100$		;BRANCH IF READ FAILED
	MOV	SCNUAR,-2(R4)	;REPLACE DCN PTR IN DCN PTR BLOCK
	MARK	FIBUF		;MAKE SURE IT GETS WRITTEN BACK
	ADD	#1,R2		;POINT TO BLK 3 OF CLUSTER (LINKS)	;JDB010
	ADC	R3		; (MSB)					;JDB010
	CALL	READ		;GET THE BLOCK OF LINK WORDS		;JDB010
	BCS	100$		;BRANCH IF YOU COULDN'T - IT'S FATAL	;JDB010
	MOV	-2(R4),-(SP)	;SAVE LINK TO NAME BLOCKETTE FOR UFD	;JDB010
	SUB	#2,R2		;POINT BACK TO 1ST BLOCK OF UFD		;JDB010
	SBC	R3		; (MSB)					;JDB010
	CALL	READ		;GET 1ST GFD BLOCK FOR CLUSTER MAP	;JDB010
	BCS	100$		;BRANCH IF YOU COULDN'T - IT'S FATAL	;JDB010
	MOV	(SP)+,R3	;RETRIEVE LINK TO NAME BLOCKETTE	;JDB010
	CALL	FSRDB		;GET THE NAME BLOCKETTE IN FIBUF	;JDB010
	BCS	100$		;BRANCH IF YOU COULDN'T - IT'S FATAL	;JDB010
	MOV	SCNUAR,UAR(R5)	;REPLACE DCN IN NAME BLOCKETTE		;JDB010
	MARK	FIBUF		;MAKE SURE IT GETS WRITTEN BACK		;JDB010
20$:	MOV	(SP)+,R3	;RESTORE FBN OF DCN PTR BLOCK
	MOV	(SP)+,R2	; (LSB)
	CMP	#FIBUF+512.,R4	;ANY MORE UFD'S
	BNE	10$		;BRANCH IF SO - GO FIX 'EM
	RETURN			;THAT'S ALL FOLKS!

100$:	CALL	FATBAD		;NEW/FATAL BAD BLOCK

.DSABL	LSB


.SBTTL		FIXACC - FIX AN ACCOUNT

;+
; FIXACC - FIX A UFD
;
;	R5 -> NAME ENTRY CURRENTLY IN FIBUF
;	R2 = RP (DCN) OF 1ST BLOCK OF UFD
;
;	CALL	FIXACC
;
;	RETURNS:	ALL IS WELL
;	WE DIE IF BAD LINKS ARE HIT OR NEW BAD BLOCK FOUND WHILE
;	FOLLOWING LINK.
;-

.ENABL	LSB

FIXACC:	CLR	SCNFNL		;LINK TO NE OF FILE BEING SCANNED
	CLR	FIXNE		;ASSUME NO CHANGE TO 1ST R.P.
	MOV	R2,SCNUAR	;SAVE ORIGINAL 1ST R.P.
	CALLX	RIB2CN		;CONVERT DCN IN R2 TO PCN IN R3
	MOV	MISSNG,-(SP)	;SAVE THE COUNT - IF 1ST R.P. WAS BAD MAPS
				; MUST BE UPDATED AND COUNT SHOULD NOT BE LOST
	CALL	SCNREL		;WAS 1ST R.P. RELOCATED?
	BCC	10$		;FORTUNATELY, NO
	MOV	NEWPCN,R3	;GET PCN IT WAS MOVED TO
	CALL	PCNDCN		;CONVERT TO DCN IN R3
	MOV	R3,R2		;REPLACE THE OLD ONE FOR THE READ
10$:	MOV	(SP)+,MISSNG	;RESTORE COUNT
	CALL	FSRDRF		;READ IN 1ST BLOCK OF THE UFD, BY DCN
	BNE	60$		;TIS BAD
	MOV	#UFDCLM,CLUFLG	;INDICATE UFD CLUSTER MAP CHECK
	MOVB	FIBMAP,CHKECS	;UFD CLUSTER SIZE -> ENTITY CLUSTER SIZE
	MOV	#FIBENT,R5	;POINT TO 1ST DCN IN UFD CLUSTER MAP
	CALL	CHKREL		;CHECK ALL THE RP'S IN THE MAP
	BCC	20$		;NO BADDIES
	CALL	REPMAP		;REPLACE ALL THE MAPS
	CMP	FIBENT,SCNUAR	;DID 1ST RP CHANGE
	BEQ	20$		;NOPE
	MOV	(PC),FIXNE	;INDICATE IT MUST BE CHANGED LATER
	MOV	FIBENT,SCNUAR	;SAVE IT
	TST	MISSNG		;DID MAP SCAN FIND/CORRECT THEM ALL?
	BEQ	50$		;YES - NO NEED TO SCAN FILES

; CHECK ALL FILES IN THE UFD

20$:	MOV	#FIBUF,R5	;R5 -> UFD LINK HEAD
	MOV	LPPN(R5),SCNPPN	;GET THE UFD'S PPN			;JDB008

; LOOP THROUGH EACH UFD NAME ENTRY CHECKING FILES

30$:	MOV	(R5),R3		;R3 = LINK TO NEXT UFD NAME ENTRY
	BIC	#UL.FLG,R3	;MINUS FLAG BITS
	BEQ	50$		;NONE, SO WE ARE DONE WITH THIS UFD
40$:	CALL	RDBFIX		;READ IN THE NAME ENTRY FOR THE FILE
				; DON'T COME BACK IF ANYTHING FATAL HAPPENED
	CALL	FIXFIL		;GO CHECK RETRIEVAL ENTRIES,ETC
				;NOTHING FATAL IF WE CAME BACK
				;LEAVES US WITH FILE NAME ENTRY BACK IN FIBUF
	TST	MISSNG		;FOUND THEM ALL YET?
	BNE	30$		;NOPE - GO DO ANOTHER FILE
50$:	RETURN			;NOTHING FATAL

;	NEW BAD BLOCK - TIS FATAL HERE
60$:	CALL	FATBAD		;NEW/FATAL BAD BLOCK

.DSABL	LSB

GLOBAL	<FIBMAP,FIBUF,FIBENT>

.SBTTL		FIXFIL - FIX A FILE ENTRY

;+
;	R2 =  LINK TO PREVIOUS ENTRY IN UFD
;	R3 =  LINK TO NAME ENTRY OF FILE TO SCAN
;	R5 -> NAME ENTRY IN FIBUF
;	FIBUF CONTAINS A BLOCK OF THE UFD
;
;	CALL	FIXFIL
;
;	RETURNS: ONLY IF NO FATAL PROBLEM
;		R5 -> NAME ENTRY
;		R2, R3 CLOBBERED
;-

.ENABL	LSB

FIXFIL:	MOV	R3,SCNFNL	;SAVE THE LINK IN UFD TO THIS FILE NE
	MOVB	USTAT(R5),SCNUST ;SAVE THE USTAT BYTE
	BITB	#US.UFD,SCNUST	;IS THIS A UFD?
	BNE	40$		;YES, THERE ARE NO RETRIEVAL ENTRIES
	MOV	UAR(R5),R2	;SAVE LINK TO 1ST RETRIEVAL ENTRY
	MOV	UAA(R5),R3	;GET LINK TO FILE'S ACCT. ENTRY
	CALL	RDBFIX		;TRY TO READ THE A.E. - DONT' COME BACK
				; IF COULDN'T
	MOV	UCLUS(R5),CHKECS ;FILE CLUSTER SIZE -> ENTITY CLUSTER SIZE

; CHAIN THROUGH RETRIEVAL ENTRIES

	CLR	DCN1ST		;DCN COUNTER - 0 MEANS VERY 1ST
	MOV	#FILCLM,CLUFLG	;PLAIN OLD FILE
	MOV	R2,R3		;GET RP LINK
10$:	BIC	#UL.FLG,R3	;MINUS FLAG BITS
	BEQ	30$		;NO MORE CLUSTERS - DONE WITH FILE
20$:	CALL	RDBFIX		;READ THE RETRIEVAL ENTRY - DON'T COME
				; BACK IF COULDN'T
	MOV	R3,SCNRP	;SAVE LINK TO RETRIEVAL ENTRY IN CASE WE
				; RDB TO THE NAME ENTRY
	MOV	(R5)+,-(SP)	;SAVE LINK TO NEXT & POP TO 1ST DCN
	CALL	CHKREL		;CHECK ALL THE RP'S - NOT FATAL IF FOUND
	MOV	(SP)+,R3	;GET BACK LINK TO NEXT
	TST	MISSNG		;ANY STILL UNFOUND?
	BNE	10$		;YUP
30$:	MOV	SCNFNL,R3	;RESTORE LINK TO THIS FILE'S NE
	CALL	RDBFIX		;GET IT BACK IF WE CAN
	CMPB	USTAT(R5),SCNUST ;HAVE WE CHANGED THE STATUS?
	BEQ	40$		;NOPE
	MOVB	SCNUST,USTAT(R5) ;YES - REPLACE IT
	MARK	FIBUF		;AND MAKE SURE IT'S REWRITTEN
40$:	RETURN			;ALL IS WELL

.DSABL	LSB

.SBTTL		RDBFIX - RDB FOR DIRECTORY FIX

;+
; RDBFIX - RDB FOR DIRECTORY FIX
;
;	R3 = DIRECTORY LINK
;	CALL	RDBFIX
;
;	RETURNS: ONLY IF NO FATAL PROBLEM
;	DIES IF BAD LINK ('BAD DIRECTORY') OR NEW BAD BLOCK ('FATAL
;	OUTPUT BAD BLOCK')
;-

.ENABL	LSB

RDBFIX:	CALL	RDBRTN		;CALL RDB
	BCC	10$		;C-BIT CLEAR MEANS NO PROBLEM
	CALL	FATBAD		;BAD BLOCKS ARE FATAL HERE
10$:	RETURN

.DSABL	LSB

.SBTTL		CHKREL - CHECK OUTPUT DCN'S

;+
; CHKREL - SEE IF ANY IN A CHUNK OF RP'S (DCN'S) ARE BAD
;
;	R5 -> 1ST DCN IN A CLUSTER MAP OR FILE CLUSTER MAP
;	MISSNG = REMAINING # OF UNFOUND RELOCATED OUTPUT PCN'S (<>0 ON ENTRY)
;	CHKECS = ENTITY CLUSTER SIZE, I.E., MFD, UFD, OR FILE CLUSTER SIZE
;
;	CALL	CHKREL
;
;	RETURNS:
;	REGISTER CONTENTS ARE LOST
;	
;	C = 0	DIDN'T FIND ANYTHING
;	C = 1	FOUND SOMETHING
;		MISSNG = REMAINING # OF UNFOUND RELOCATED PCN'S
;	IF ANY WERE BAD, FAILING PPN/FILENAME HAS BEEN PRINTED
;	'CHUNKS' (E.G., FILE CLUSTER IF BIGGER THAN PACK CLUSTER) HAVE
;	BEEN 'RE-RE-LOCATED'.
;
;	NOTE THAT WE ABORT HERE IF WE RUN OUT OF ROOM (NOT ENUF
;	CONTIGUOUS, PROPERLY ALIGNED PC'S TO MOVE A CHUNK).
;-

.ENABL	LSB

CHKREL:	REGSCR			;SAVE REGISTERS
	MOV	CHKECS,R1	;GET THE CLUSTER SIZE
	CLR	R0		;SET UP FOR DIVIDE
	DIV	PCS,R0		;ECS/PCS=# OF PC'S PER ENTITY CLUSTER
	MOV	R0,XPAND	;SAVE IT
	MOV	MISSNG,R1	;SAVE # UNFOUND ON ENTRY
	MOV	(R5),STRDCN	;SAVE 1ST R.P. IN CASE WE UNPLACED
10$:	MOV	(R5)+,R2	;GRAB A DCN
	BEQ	70$		;ZERO MEANS NO MORE
	MOV	MISSNG,MISNG1	;HOLD THE VALUE OF MISSNG		;AWR001
	CALLX	RIB2CN		;CONVERT DCN IN R2 TO PCN IN R3
	MOV	R3,PCNUM	;SAVE THE STARTING PCN OF THIS R.P.

; A DCN REFLECTS XPAND PCN'S, STARTING AT PCN PCNUM
; FIRST, FIND THOSE THAT HAVE BEEN RELOCATED
; IF ENTITY CLUSTER SIZE WAS > PCS THEN WE BROKE UP AN ENTITY CLUSTER
; AND NEED TO TRY AND REBUILD IT.

	MOV	XPAND,R0	;GET THE RATIO AS OUR LOOP CONTROL
	CLR	R4		;CLEAR COUNT FOUND FOR THIS DCN
20$:	CALL	SCNREL		;SEE IF PCN IN R3 WAS RELOCATED
	BCC	30$		;C-BIT CLEAR MEANS DIDN'T FIND IT
	INC	R4		;INC COUNT FOUND FOR THIS DCN
30$:	INC	R3		;ON TO THE NEXT PC IN THE ENTITY CLUSTER
	SOB	R0,20$		;FOR ALL OF THEM
	TST	R4		;ANY FOR THIS DCN?
	BEQ	60$		;NOPE - GO CHECK REMAINING R.P.'S
	CMP	#1,XPAND	;IS ECS=PCS?
	BEQ	40$		;YES - NO NEED TO REBUILD A CHUNK
	CALL	REDO		;OK, TRY TO REBUILD IT - DON'T COME BACK
				; IF YA COULDN'T
	BR	50$		;DID IT! CONTINUE

40$:	MOV	NEWPCN,R3	;PREPARE TO CONVERT TO DCN
	CALL	PCNDCN		;CONVERT TO DCN IN R3
	MOV	R3,-2(R5)	;REPLACE THE RP IN FIBUF
50$:	MARK	FIBUF		;MAKE SURE NEW STUFF IS WRITTEN
	CALL	CHGFIL		;DID WE DE-CONTIG OR UNPLACE?
60$:	INC	DCN1ST		;INDICATE WE'RE ON THE NEXT R.P.
	TST	MISSNG		;FIND THEM ALL?
	BEQ	80$		;YUP - GO INDICATE A FIND
	BIT	R5,#17		;TRY THE NEXT RP
	BNE	10$		;IF THERE IS ONE
70$:	CMP	R1,MISSNG	;DID WE FIND ANY?
	BEQ	90$		;NOPE (C-BIT IS CLEAR)
80$:	SEC			;INDICATE WE FOUND AT LEAST 1
90$:	RETURN			;ALL DONE - RESTORE/RETURN

	I.DATA								;AWR001
MISNG1:	.BLKW0			;TEMPORARY HOLD FOR MISSNG		;AWR001
	UNORG								;AWR001

.DSABL	LSB
GLOBAL	<PCNUM,PCS>

.SBTTL		REDO	- RE-RE-LOCATE DATA

;+
; REDO - RE-RE-LOCATE A CHUNK
;
;	CALL	REDO
;
;	RETURNS: IT HAS BEEN DONE
;
;	NOTE THAT WE ABORT IF VOLUME IS FULL
;
;-

.ENABL	LSB

REDO:	REGSCR			;SAVE REGISTERS
	MOV	MISNG1,R1	;RESTORE VALUE FOR MISSNG		;AWR001
	MOV	(PC),POST	;INDICATE FIXUP PASS
	MOV	R1,MISSNG	;WE ALREADY SUBTRACTED FOUND ONES
	MOV	MISSNG,-(SP)	;SAVE COUNT
	MOV	XPAND,R0	;THERE ARE 'XPAND' PCN'S IN AN ENTITY CLUSTER
	MOV	PCNUM,R3	;GET THE STARTING (OLD) PCN OF E.C.

;	FIRST, FREE UP SPACE CURRENTLY OCCUPIED BY THIS ENTITY CLUSTER IN SATT
;	THERE IS AT LEAST 1 RELOCATED PCN - OTHERS COULD BE EITHER AS ON ORIG
;	DISK OR COULD ALSO HAVE BEEN RELOCATED

10$:	MOV	R3,-(SP)	;SAVE THE DEFAULT I/O (ORIG. PCN)
	CALL	90$		;GET PCN (OLD OR RELOCATED) IN R3
	CALL	PCNDCN		;CONVERT PCN IN R3 TO DCN IN R3
	MOV	R3,R2		;RETCLU WANTS DCN IN R2
	MOV	PCS,R1		;WILL ONLY BE FREEING 1 SATT BIT
	CALLX	RETCLU		;FREE THE BIT
	MOV	(SP)+,R3	;POP THE LAST ORIG PCN
	INC	R3		;ON TO THE NEXT
	SOB	R0,10$		;DO FOR ALL PC'S IN THE ENTITY CLUSTER
	MOV	(SP)+,MISSNG	;GET BACK UNCHANGED COUNT BACK

;	NOW, SEE IF THERE'S ROOM FOR THE ENTITY CLUSTER
	
20$:	MOV	CHKECS,R1	;GET THE ENTITY CLUSTER SIZE TO GET
	CALLX	GETDIR		;IS THERE ANY FREE SPACE TO RE-LOCATE?
	BCC	70$		;NOPE - VOLUME IS FULL

;	OK, THERE'S ROOM - GET THE OLD DATA FROM THE RIGHT SPOT AND MOVE IT

	MOV	R2,-2(R5)	;SAVE THE NEW START DCN (R.P.)
	CALLX	RIB2CN		;CONVERT NEW DCN TO PCN
	MOV	R3,PCN1ST	;PCN1ST = STARTING PCN
	MOVB	#1,HIGHBF	;I/O TO IOBUFF
	CALL	XSETUP		;SET UP POINTERS
	CLR	PCNRD		;CLEAR COUNT
	MOV	PCNUM,-(SP)	;SAVE STARTING PCNUM
	MOV	MISSNG,-(SP)	; COUNT
	MOV	PCN1ST,-(SP)	; AND NEW STARTING PCNUM
	MOV	XPAND,R2	;THERE ARE 'XPAND' PCN'S IN AN ENTITY CLUSTER
30$:	TST	R2		;ANY LEFT TO DO?
	BEQ	60$		;NO, ALL DONE
	CALL	XSETUP		;SET UP POINTERS
	CLR	PCNRD		;CLEAR COUNT
	MOV	BUFPCS,R0	;R0 = # PC'S THAT CAN FIT IN A BUFFER
40$:	TST	R0		;NEED ANY MORE IN THE BUFFER?
	BEQ	50$		;NOPE
	MOV	PCNUM,R3	;OLD PCN
	CALL	90$		;IF RELOCATED, REPLACE R3
	MOV	R3,(R4)+	;STORE IT IN THE XFRPCN TABLE
	INC	PCNUM		;FOR NEXT TIME
	INC	PCNRD		;COUNT TO BE READ
	DEC	R0		;NEED 1 LESS
	SOB	R2,40$		;IN CASE WE HIT THE END
50$:	MOV	PCNRD,R0	;SET COUNT FOR GETRS2
	BEQ	60$		;BUT ALL DONE IF NONE IN XFRPCN TABLE
	CALL	GETRS2		;GET EM (DIES IF BAD BLOCK)
	CALL	PUTRS2		;YES - DUMP IT TO NEW LOCATIONS
	BCS	80$		;ALAS, A PROBLEM
	BR	30$		;FOR ALL OF THEM

60$:	TST	(SP)+		;GET RID OF PCN1ST
	TST	(SP)+		;GET RID OF MISSNG, WHICH WAS LEFT
				; CORRECT BY THE LAST PASS AT SCNREL
	TST	(SP)+		;GET RID OF USELESS PCNUM
	CLRB	HIGHBF		;DON'T LEAVE OURSELVES IN LIMBO
	RETURN

70$:	CALL	FULLUP		;??? VOLUME IS FULL

;	BAD BLOCK WHERE WE'RE TRYING TO RE-RELOCATE!
80$:	MOV	(SP)+,R3	;GET START OF RELOCATED PCN'S (PCN1ST) IN R3
	MOV	(SP)+,MISSNG	; AND COUNT (LEAVE PCNUM ON THE STACK)
	CALL	PCNDCN		;CONVERT PCN1ST (PCN) TO DCN IN R3
	MOV	R3,R2		;RETCLU WANTS DCN IN R2
	MOV	CHKECS,R1	;GET THE ENTITY CLUSTER SIZE TO FREE
	CALLX	RETCLU		;FREE THE BITS
	MOV	BADDCN,R2	;GET THE BAD DCN
	CALLX	RIB2CN		;CONVERT TO PCN IN R3
	MOV	R3,R0		;FIXREG WANTS IT IN R0
	CALLX	FIXREG		;CONVERT TO BIT(R2)/OFFSET(R4)
	BISB	BITBYT(R2),SATBUF(R4) ;SET IT SO WE DON'T USE IT AGAIN
	CALL	ADDBBO		;ADD TO THE OUTPUT BAD BLOCK FILE
	MOV	(SP)+,PCNUM	;GET BACK STARTING PCN
	BR	20$		;TRY IT AGAIN

90$:	TST	MISSNG		;FIND ALL RELOCATED ONES?
	BEQ	100$		;YUP, BYPASS EXTRA CHECK
	CALL	SCNREL		;OK, WAS IT RELOCATED?
	BCC	100$		;NOPE
	MOV	NEWPCN,R3	;REPLACE WITH THE PCN WE REALLY WANT
100$:	RETURN

.DSABL	LSB
GLOBAL	<PCNUM,XFRPCN,PCS,HIGHBF,SATBUF,BITBYT,BUFPCS>

.SBTTL		PCNDCN - CONVERT PCN TO DCN

;+
; PCNDCN - CONVERT A PCN TO DCN
; CALL:	R3	= PCN TO CONVERT
;	CALL	PCNDCN
;	
; RETURNS:
;	R3	= DCN
;-

.ENABL	LSB

PCNDCN:	MOV	R2,-(SP)	;SAVE CALLERS R2
	MOV	CLURAT,R2	;GET CLUSTER RATIO
10$:	ASR	R2		;RETRIEVAL POINTER (DCN) =
	BCS	20$		; PCN * (DCS/PCS)
	ASL	R3
	BR	10$

20$:	INC	R3		; + 1
	MOV	(SP)+,R2	;RESTORE R2
	RETURN

GLOBAL	<CLURAT>
.DSABL	LSB

.SBTTL		GETRS2 - GET FOR DIRECTORY FIXUP

;+
; GETRS2 - GET FOR DIRECTORY FIXUP
;
;	R0 = COUNT OF PCN'S IN XFRPCN
;
;	CALL	GETRS2
;
;	RETURNS: TIS DONE
;
;	THE DATA WE'RE GETTING IS ALREADY ON THE OUTPUT DISK. IN SOME CASES,
;	IT MIGHT BE POSSIBLE TO TRACK DOWN THE INPUT BLOCK, BUT IF IT IS
;	IN A FILE FROM A SAVE SET... WHICH VOLUME.
;	HENCE, WE DIE (NOTE THAT THE BLOCK WAS OK WHEN WE WROTE IT)
;-

.ENABL	LSB

GETRS2:	CALL	XSETUP		;SET UP POINTERS
	CLR	PCNRD		;POSGET RESETS THIS
10$:	MOV	PCNUM,-(SP)	;SAVE OLD PCNUM
	CALL	CNTCTG		;GET CONTIG COUNT & STARTING CONTIG PCN
	CALL	POSGET		;CALL GETRST AT FIXUP ENTRY
	MOV	(SP)+,PCNUM	;RESTORE PCNUM
	BCS	20$		;BAD BLOCK ERROR
	TST	R0		;ANY MORE?
	BNE	10$		;GO GET EM
	RETURN

20$:	CALL	JPERC		;<200>'%%% '
	MESSAG	<"Bad data in ">
	BIT	#MFDCLM,CLUFLG	;MFD?
	BEQ	30$		;NOPE
	MESSAG	<"MFD">		;PRINT IT
	BR	50$

30$:	BIT	#GFDCLM,CLUFLG	;GFD?					;MNB005
	BEQ	35$		;NOPE					;MNB005
	MESSAG	<"GFD">		;LET'S HEAR IT				;MNB005
	CLR	R0		;FOR GROUP NUMBER			;MNB005
	BISB	SCNPPN+1,R0	;GET THE GROUP NUMBER			;MNB005
	CALL	DECZER		;PRINT IT				;MNB005
	BR	50$							;MNB005

35$:	BIT	#UFDCLM,CLUFLG	;UFD?					;MNB005
	BEQ	40$		;NOPE
	MESSAG	<"UFD ">
	CALL	PRTPPC		;PPN
	BR	50$

40$:	CALL	PRTPNC		;PPN/FILENAME
50$:	CALL	FATBAD		;AND DIE

.DSABL	LSB
GLOBAL	<PCNUM>

.SBTTL		PUTRS2 - PUT FOR DIRECTORY FIXUP

;+
; PUTRS2 - PUT DATA TO NEW SPOT
;
;	PCN1ST = NEXT PCN TO DUMP (CONTIGUOUSLY) TO
;	PCNRD = # OF PCN'S IN THE BUFFER
;	CALL	PUTRS2
;
; RETURNS:
;	C = 0	TIS DONE
;	C = 1	BAD BLOCK - NEED TO RE-RE-RELOCATE
;		BADDCN = BAD DCN
;-

.ENABL	LSB

PUTRS2:	MOV	R2,-(SP)	;SAVE R2
	MOV	PCNRD,XFRCNT	;SO RWRST WILL WRITE THE CORRECT AMOUNT
	CALL	XSETUP		;SET UP POINTERS
	MOV	PCN1ST,R2	;STARTING PCN
	CALL	RWRST,R5,WFUN	;GO PUT CONTIG PC'S
	BCS	10$		;BAD BLOCK! (C-BIT SET)
	ADD	PCNRD,PCN1ST	;BUMP OUTPUT PCN POINTER
	CLC			;MAKE SURE C-BIT'S CLEAR
10$:	MOV	(SP)+,R2	;RESTORE R2
	RETURN

.DSABL	LSB

.SBTTL		CHGFIL - DID WE CHANGE THE FILE?

;+
; CHGFIL - SEE IF WE ALTERED A FILE'S STRUCTURE
;
;	SCNUST = FILE'S USTAT BYTE
;
;	CALL	CHGFIL
;
;	RETURNS:
;	SCNUST = FILE'S (UPDATED) USTAT BYTE
;	IF FILE WAS CHANGED, APPROPRIATE MESSAGE HAS BEEN PRINTED
;	IF FILE HAS CHANGED AND /NOERROR WAS SPECIFIED, WE ABORT HERE.
;
;-

.ENABL	LSB

CHGFIL:	BIT	#FILCLM,CLUFLG	;ARE WE IN A FILE ?
	BEQ	30$		;NO - MFD/UFD - GET OUT
	CLR	-(SP)		;LEAVE ROOM FOR A COUNT
	TST	DCN1ST		;IS THIS THE VERY 1ST DCN?
	BNE	10$		;NOPE
	BITB	#US.PLC,SCNUST	;YES - WAS THIS FILE PLACED?
	BEQ	10$		;NOPE
	BICB	#US.PLC,SCNUST	;WELL IT ISN'T ANYMORE
	CALL	JPERC		;<200>'%%% '
	MESSAG	<"Placed file ">
	CALL	PRTCLF		;PRINT THE NAME
	MESSAG	<" has been moved from DCN ">
	MOV	R0,-(SP)	;SAVE R0
	MOV	STRDCN,R0	;GET THE OLD 1ST DCN
	CALLX	DECZER		;PRINT IT'S NUMBER
	MESSAG	<" to DCN ">
	MOV	-2(R5),R0	;GET THE NEW 1ST DCN
	CALLX	DECZER		;PRINT IT
	CALLX	TYPECR		;NEW LINE
	MOV	(SP)+,R0	;RESTORE R0
	MOV	#1,(SP)		;ONLY WANT TO COUNT THIS FILE ONCE
10$:	BITB	#US.NOX,SCNUST	;WERE WE DE-CONTIGGED THIS PASS?
	BEQ	20$		;NOPE
	BICB	#US.NOX,SCNUST	;DO IT
	CALL	JPERC		;<200>'%%% '
	MESSAG	<"File ">
	CALL	PRTCLF		;PRINT THE NAME
	MESSAG	<" has been changed to non-contiguous"<200>>
	MOV	#1,(SP)		;AGAIN, ONLY WANT TO COUNT THIS FILE ONCE
20$:	ADD	(SP)+,TFICHG	;ADD IN TO TOTAL (MAY BE 0)
	BEQ	30$		;DIDN'T CHANGE ANYTHING
	CALL	CHKNOE		;ALTERED A FILE - CHECK FOR /NOERROR 
	MOV	SCNRP,R3	;GET BACK LINK TO RETRIEVAL ENTRY
	MOV	R5,-(SP)	;SAVE R5
	CALL	RDBFIX		;WE MAY HAVE CHANGED DIRECTORY BLOCKS
	MOV	(SP)+,R5	;RESTORE R5
30$:	RETURN

.DSABL	LSB

.SBTTL		SCNREL - SCAN RELOCATION TABLE

;+
; SCNREL - SCAN RELOCATION TABLE
;
;	R3 = PCN TO CHECK
;
;	CALL	SCNREL
;
;	RETURNS:
;	C = 0	PCN WAS NOT RELOCATED
;	C = 1	PCN WAS RELOCATED
;		NEWPCN = WHERE ORIG PCN WAS RELOCATED
;-

.ENABL	LSB

SCNREL:	REGSCR			;SAVE ALL REGISTERS
	CLR	R5
	MOV	RELOC,R0	;INPUT TABLE
	MOV	RELCNT,R1	;GET COUNT OF RELOCATED PCN'S
	BEQ	40$		;NOTHING TO DO
	MOV	MISSNG,R2	;SAVE COUNT WHEN WE GOT HERE
10$:	CMP	R3,(R0)+	;DOES IT MATCH OURS?
	BEQ	50$		;YES - WE FOUND ONE!
20$:	TST	(R5)+		;BUMP POINTER
	SOB	R1,10$		;SCAN THEM ALL
30$:	CMP	R2,MISSNG	;FIND ANY?
	BEQ	40$		;NOPE - CLEAR C-BIT
	SEC			;INDICATE A FIND
40$:	RETURN			;ALL DONE

50$:	MOV	R5,R4		;OUR OFFSET
	ADD	RELOC+2,R4	;OUTPUT TABLE
	MOV	(R4),R3		;SET UP FOR REST OF SCAN
	MOV	R3,NEWPCN	;SAVE IT
	DEC	MISSNG		;DECREMENT UNFOUND COUNT
	BR	20$		;MAKE SURE RELOCATED ONE WASN'T RELOCATED
				; (I.E., FREE PCN TURNED OUT TO BE UNEXPECTED
				; OUTPUT BAD BLOCK

GLOBAL	<RELOC>
.DSABL	LSB

.SBTTL		SETREL - SET UP RELOCATION COUNT

SETREL:	MOV	R1,-(SP)	;SAVE R1
	CLR	RELCNT		;COUNT OF RELOCATED PCN'S
	MOV	RELPTR,R1	;GET RELOCATION TABLE POINTER
	BEQ	10$		;GET OUT IF THERE WERE NONE
	ASR	R1		;MAKE IT A COUNT
	MOV	R1,RELCNT	;SAVE IT
	MOV	R1,MISSNG	;# OF UNFOUND RELOCATEES
10$:	MOV	(SP)+,R1	;RESTORE R1
	RETURN

GLOBAL	<RELPTR>

.SBTTL		REPMAP - REPLACE DIRECTORY MAPS

;+
; REPMAP - LOOP THROUGH DIRECTORY ENTRIES, REPLACING MAPS IN EACH BLOCK
;
; FIRST ENTRY:
;	FIBUF CONTAINS ANY BLOCK OF THE DIRECTORY (FIBENT IS VALID)
;
;	CALL	REPMAP
;
;	FIBUF CONTAINS FIRST BLOCK OF DIRECTORY
;-

.ENABL	LSB

REPMAP:	REGSCR			;SAVE ALL REGISTERS
	CALL	STOMAP		;1ST, SAVE THE UPDATED MAP
	CLR	R0		;R0 = OFFSET INTO FIBMAP
10$:	CLR	R1		;R1 = BLOCK WITHIN DIRECTORY CLUSTER
	TST	(R0)+		;NEXT FIBENT ENTRY
20$:	MOV	FIBMAP(R0),R2	;R2 = RP TO A DIRECTORY CLUSTER
	BEQ	40$		;NO MORE
	CALLX	CNVRIB		;CONVERT RP TO FBN IN R2/R3
	ADD	R1,R2		;ADVANCE TO BLOCK WITHIN CLUSTER
	ADC	R3
	BIT	#20000,PKSTAT	;IS THIS AN OLD PACK?			;JDB003
	BEQ	25$		;BRANCH IF SO - EVERYTHING THE SAME	;JDB003
	TST	FIBMAP		; ELSE IS THIS THE MFD OR A GFD?	;JDB003
	BPL	25$		;BRANCH IF NOT - MAKES NO DIFFERENCE	;JDB003
	CMP	#2,R0		; ELSE IS THIS THE FIRST CLUSTER?	;JDB003
	BNE	25$		;BRANCH IF NOT - MAKES NO DIFFERENCE	;JDB003
	TST	R1		; ELSE IS THIS THE FIRST BLOCK?		;JDB003
	BEQ	25$		;BRANCH IF SO - MAKES NO DIFFERENCE	;JDB003
	CMP	#3,R1		; ELSE IS THIS BLK 3 OR > OF CLUSTER?	;JDB003
	BGT	35$		;BRANCH IF NOT - NO MAPS IN BLKS 1 OR 2	;JDB003
25$:	CALL	FSREAD		;READ INTO FIBUF			;JDB003
	BNE	60$		;<>0 MEANS BAD BLOCK

;	NEW BLOCK IS IN FIBUF
30$:	CALL	RESMAP		;REPLACE WITH NEW MAP
	MARK	FIBUF		;MAKE SURE IT'S UPDATED
35$:	INC	R1		;NEXT BLOCK IN CLUSTER			;JDB003
	CMPB	R1,FIBMAP	;UP TO DIR CLUSTER SIZE?		;JDB003
	BLO	20$		;NOT YET
	CMP	R0,#16		;YES, DONE 7TH CLUSTER?
	BLO	10$		;NO, THERE MAY BE MORE
40$:	MOV	FIBENT,R2	;R2 = RP TO FIRST DIR BLOCK
	CALL	FSRDRF		;READ IT IN
	BNE	60$		;<>0 MEANS BAD BLOCK
50$:	RETURN

60$:	CALL	FATBAD		;YUK, BAD BLOCK IN REPMAP

GLOBAL	<FIBMAP,FIBENT,PKSTAT>
.DSABL	LSB

.SBTTL	FIXBAD - FIX UP BADB.SYS

;+
; FIXBAD: FIX UP BADB.SYS
;	CALL	FIXBAD
;		BADBO = POINTER TO START OF BAD BLOCK LIST
;		CNBBO = POINTER TO END OF BAD BLOCK LIST
;
;	ANY PREVIOUS ALLOCATION OF BADB.SYS IS ZAPPED, AND REPLACED
;	WITH THE NEW BAD BLOCK LIST.  (NOTE THAT, ON ENTRY, BADB.SYS
;	REFLECTS THE BAD BLOCKS ON THE ORIGINAL DISK!)
;
;	ALL REGISTERS PRESERVED
;
; BACK:	ONLY IF NO PROBLEMS.  ANY ERRORS ARE ERF'ED.
;-

.ENABL	LSB
.ENABL	LC

FIXBAD:	REGSCR			;SAVE SOME REGISTERS
	CLRB	HIGHBF
	CALL	SETCH2		;SET UP FOR THE OUTPUT DISK
	MOV	#FQBADB,R0	;FIND NAME ENTRY FOR BADB.SYS
	ADD	#FQPPN,R0	; IN [0,1]
	CALL	120$		;GO GET THE NAME ENTRY
10$:	MOV	R3,-(SP)	;SAVE NAME ENTRY LINK ON STACK
	MOV	UAR(R5),-(SP)	;SAVE LINK TO RET. ENTRY ON STACK
	CLR	UAR(R5)		;NOTHING TO RETRIEVE YET
	MOV	UAA(R5),R3	;GET LINK TO ACCOUNTING ENTRY
	CALL	90$		;SAVE NAME ENTRY, GET ACCOUNTING ENTRY
	MOV	CNBBO,R1	;FIND END OF BAD BLOCK LIST
	SUB	BADBO,R1	;CALCULATE LENGTH OF BAD BLOCK LIST
	ASR	R1		;MAKE IT A WORD COUNT
	MUL	PCS,R1		;CALCULATE THE BLOCKS ALLOCATED
	MOV	R1,USIZ(R5)	;SAVE THE NEW LENGTH (CAN'T BE > 65K)
	MOV	UCLUS(R5),R1	;SAVE OLD BADB.SYS CLUSTERSIZE FOR SAFETY
	MOV	PCS,UCLUS(R5)	;REPLACE IT WITH THE CORRECT ONE
	CALL	SETDAT		;GET THE CURRENT DATE AND TIME
	MOV	I.DATE,UDLA(R5)	;FIX THE DATE OF LAST ACCESS,
	MOV	I.DATE,UDC(R5)	; DATE OF CREATION, AND
	MOV	I.TIME,UTC(R5)	; TIME OF CREATION
	MARK	FIBUF		;FIBUF SHOULD BE WRITTEN TO DISK
	MOV	(SP)+,R0	;GET LINK TO FIRST RET. ENTRY

GLOBAL	<FIBUF,FQBADB,HIGHBF,CNBBO,BADBO,PCS,I.DATE,I.TIME>

.SBTTL		DE-ALLOCATE OLD BADB.SYS

; DE-ALLOCATE THE PREVIOUS BLOCKS OF BADB.SYS
;	(CODE SWIPED FROM XFL)
;	R1 = FILE CLUSTER SIZE
;	R0 = LINK IN UFD TO FIRST RETRIEVAL ENTRY
;

20$:	MOV	R0,R3		;COPY LINK TO NEXT (FIRST) RETRIEVAL ENTRY
	BIC	#17,R3		; WITHOUT FLAG BITS
	BEQ	50$		;ZERO MEANS END OF RETRIEVAL ENTRIES
	CALL	100$		;GET NEXT (FIRST) RIB
	MOV	(R5),R0		;GET NEXT LINK
	CLR	(R5)+		;WIPE OUT RIB LINK ENTRY
	MARK	FIBUF		;MARK FIBUF TO WRITE
30$:	MOV	(R5),R2		;GET CLUSTER TO RETURN
	BEQ	50$		;DONE, LAST RIB ONLY PARTIALLY FULL
	BIT	R4,#US.OUT	;IS THIS FILE OUT OF SATT?
	BNE	40$		;YUP, THAT CLUSTER DOESN'T EXIST
	CALLX	RETCLU		;RETURN FILE SPACE
40$:	CLR	(R5)+		;CLEAR CLUSTER ENTRY
	BIT	R5,#17		;IS THIS THE RIB'S END?
	BNE	30$		;IF NOT, THEN KEEP GOING
	BR	20$		;LOOP TO GET THE NEXT RIB

GLOBAL	<FIBMOD>

.SBTTL		BAD BLOCK ADDER

50$:	MOV	(SP),R3		;R3=LINK TO NAME ENTRY FOR BADB.SYS
	CALL	100$		;SO GET THE NAME ENTRY
	MOV	UAA(R5),R3	;WE WANT THE ACCOUNTING ENTRY
	CALL	100$		;GET IT
	TST	USIZ(R5)	;ZERO-LENGTH BADB.SYS?
	BEQ	150$		; YES - WE ARE DONE
	CALL	110$		;GET A FREE BLOCKETTE
	MOV	R3,-(SP)	;SAVE LINK TO NEW BLOCKETTE
	MOV	2(SP),R3	;GET NAME ENTRY AGAIN
	CALL	100$		;GET IT
	MOV	(SP)+,R3	;GET RET. ENTRY LINK
	TST	(SP)+		;AT LAST, GET NAME LINK OFF THE STACK
	MOV	R3,UAR(R5)	;SAVE FIRST RETRIEVAL LINK
	CALL	90$		;WRITE NAME ENTRY, GET RETRIEVAL ENTRY
	MOV	R3,R4		;R4=> LINK TO NEXT, R5=> RET. POINTER
	MARK	FIBUF		;MARK FIBUF DIRTY
	MOV	BADBO,R0	;R0=> NEXT BAD BLOCK IN LIST (AS PCN)
	MOV	CNBBO,R1	;R1=> END OF BAD BLOCK LIST
;
;	MAIN LOOP TO ADD BAD BLOCKS
;
60$:	CMP	R0,R1		;END OF BAD BLOCK LIST?
	BEQ	160$		; YES
70$:	BIT	#17,R5		;AT END OF THE BLOCKETTE?
	BNE	80$		; NO
	MOV	R4,-(SP)	;SAVE LINK TO CURRENT
	CALL	110$		;GET A NEW BLOCKETTE
	MOV	R3,-(SP)	;SAVE LINK TO NEW BLOCKETTE
	MOV	2(SP),R3	;GET LINK TO OLD BLOCKETTE
	CALL	100$		;GET OLD BLOCKETTE
	MOV	(SP)+,R3	;GET LINK TO NEXT BLOCKETTE
	MOV	R3,(R5)		;LINK THE NEXT BLOCKETTE
	TST	(SP)+		;POP OLD LINK FROM THE STACK
	CALL	90$		;WRITE OLD RET. ENTRY, GET THE NEW ONE
	MOV	R3,R4		;R4=> LINK TO NEXT, R5=>RET. ENTRY
	CLR	(R5)+		;ZAP THE LINK TO NEXT ENTRY
	MARK	FIBUF		;MARK FIBUF DIRTY
80$:	MOV	(R0)+,R3	;CALCULATE BLOCK'S DCN FROM ITS PCN
	CALL	PCNDCN		;PUTS DCN IN R3
	MOV	R3,(R5)+	;SAVE THE RETRIEVAL POINTER
	BR	60$		;GET SOME MORE

GLOBAL	<BADBO,CNBBO,FIBMOD>

.SBTTL		LOCAL DIRECTORY I/O ROUTINES

90$:	CALL	FSRDS		;WRITE CURRENT DIRECTORY BLOCK, GET NEXT
	BR	130$		;CHECK IT OUT

100$:	CALL	FSRDB		;GET NEXT DIRECTORY BLOCK
	BR	130$		;CHECK IT OUT

110$:	CALL	FSGDB		;GET A FREE BLOCKETTE
	BR	130$		;CHECK IT OUT

120$:	CALL	FSSDU		;GET THE NAME ENTRY
130$:	BCC	160$		;NO PROBLEM
140$:	MESSAG	<<177><200>"??? Error in BADB.SYS allocation">
	TSTB	IOERR		;BAD LINK?
	BEQ	170$		; YES
	CMPB	#DATERR,IOERR	;BAD BLOCK?
	BEQ	180$		;YES
	CALL	FULLUP		;'NO ROOM FOR DIRECTORY ENTRY'

150$:	TST	(SP)+		;REMOVE NAME ENTRY LINK FROM THE STACK
160$:	RETURN

170$:	CALL	BADLNK		;BAD LINK

180$:	CALL	FATBAD		;BAD BLOCK

.DSABL	LSB
GLOBAL	<IOERR>

.SBTTL	WRTSAT - WRITE THE FINAL SAT TO DISK

;+
; WRTSAT - WRITE THE FINAL SAT TO DISK
;
; GET HERE ON BRANCH FROM FIXBAD AFTER ALL BAD BLOCKS ARE FIXED
;
;-

.ENABL	LSB
.ENABL	LC

WRTSAT:	MOV	#FQSATT,R4	;LOOKUP FOR SATT.SYS
	CALLX	LOKFIL		;OPEN SATT.SYS (ON OUTPUT DISK)
	BCS	30$		;ERROR
10$:	CALLX	WOMSAT		;WOMP THE SATT TO DISK
	BCS	40$		;ERROR
	TST	(PC)+		;GOOD EXIT 
20$:	SEC	
	RETURN

30$:	ERF	<"WRTSAT">	;NO SATT.SYS

40$:	CMPB	#HNGDEV,IOERR	;HUNG DEVICE ERROR ?
	BNE	20$		;NO - EXIT WITH ERROR
	CALL	RETRY		;QUERY USER FOR RETRY
	BR	10$		;TRY AGAIN

GLOBAL	<FQSATT,IOERR>
.DSABL	LSB

.SBTTL	FIXBOO - FIX BOOT & DCN LIST IN (HOOK) OUTPUT BOOT BLOCK

;+
; FIXBOO - FIX DCN LIST IN (HOOK) OUTPUT BOOT BLOCK
;
;	CALL:	NOTHING SET UP
;		CALL	FIXBOO
;
;	RETURN:	If [0,1]INIT.SYS exists, the boot block is filled
;		with pointers to same
;-

.ENABL	LSB

FIXBOO:	REGSCR			;SAVE REGISTERS
	CALLX	SAVSAT		;SAVE SATBUF IN SATBF2
	CALL	SETCH2		;SELECT THE OUTPUT 'RSTS' DISK
	CLR	R2		;WE WANT FBN 0 - BOOT BLOCK
	CLR	R3
	CLRB	HIGHBF		;I/O IN LOW MEMORY
	MOV	#SATBUF,BUFPTR	;AND AGAIN
	MOV	#256.,R1	;WE WANT A BLOCK
	CALL	RDSKIO,R5	;READ IT IN
	  BR	85$		;BAD BLOCK - FATAL			;JDB009
	;USED TO BE BR 120$ BUT NOW GENERATES AN ADDRESSING ERROR	;JDB009
	  MOV	#SATBUF,R1	;GET BACK OUR POINTER
	TST	SATBUF		;Did we find the bootstrap in the first place?
	BEQ	10$		;No, replace it by a dummy boot
	MOV	#FQINIT,R4	;R4 ->OUTPUT:[0,1]INIT.SYS
	CALLX	LOKFIL		;LOOK UP INIT/ GET 1ST RET WINDOW IN FCB
	BCC	20$		;IT'S THERE - HOOK IT
10$:	CALL	GETDUM		;NO INIT - GET DUMMY BOOT
	BR	80$		;GO WRITE IT OUT

20$:	MOV	#FQINIT+FQPPN,R0	;R0 -> [0,1]INIT.SYS
	CALL	FSSDU		;LOOK UP INIT
	BCS	10$		;IT DISAPPEARED
	MOV	UAA(R5),R3	;THE ACCOUNTING ENTRY LINK
	MOV	UAR(R5),-(SP)	;THE 1ST RETRIEVAL ENTRY LINK
	CALL	FSRDB		;GET ACCOUNTING ENTRY
	BCS	100$		;BAD DIRECTORY - FATAL

	MOV	UCLUS(R5),R5	;GET FILE CLUSTER SIZE
	MOV	R5,FCS		;Save that
	CLR	R4		;CLEAR MSB FOR DIVIDE
	DIV	DCS,R4		;R4 = DEVICE CLUSTERS PER FILE CLUSTER
	MOV	(SP)+,R3	;RESTORE POINTER TO FIRST RETRIEVAL ENTRY
	MOV	R4,FCLRAT	;Save file cluster ratio
	MOV	SATBUF+<B.TWC-B.BOOT>,R2 ;Get our word count
	MOV	R2,-(SP)	;Save that
	MOV	R2,R4		;Copy size
	ADD	#377,R4		;Round up
	CLRB	R4		; to a block multiple
	SWAB	R4		;Now compute size in blocks
	CLR	R1		;Initialize # device clusters in segment
	CLR	-(SP)		; and starting DCN
	MOV	#SATBUF+<B.DATE-B.BOOT>,R2 ;Point to block map area
30$:	CALL	FSRDB		;R5 -> RETRIEVAL ENTRY
	BCS	100$		;Bad directory, die
	TST	(R5)+		;SKIP LINK TO NEXT RETRIEVAL ENTRY
	TST	INIDC1		;HAVE WE BEEN HERE BEFORE?		;JDB009
	BNE	40$		;BRANCH IF SO				;JDB009
	MOV	(R5),INIDC1	;ELSE SAVE DCN OF INIT.SYS INDEX BLK	;JDB009
		;NOTE: LAST SEQUENCE SHOULD ALWAYS WORK SINCE INIT.SYS	;JDB009
		;      INDEX BLOCK DCN MUST BE NON-ZERO (BOOT IS ZERO)	;JDB009
40$:	MOV	(R5)+,R0	;COPY A FILE CLUSTER
	BEQ	60$		;ZERO MARKS END OF LIST
	SUB	R1,R0		;See if this one is adjacent
	CMP	R0,(SP)		;Well?
	BEQ	50$		;Yes, add it to current chunk
	MUL	DCS,R1		;EXPAND DCN'S TO NUMBER OF BLOCKS	;MNB006
	CALL	EXPAND		;Expand this chunk out into the block map
	TST	(R2)		;Did we overflow the map area?
	BNE	90$		;Yes, quit
	MOV	-2(R5),-(SP)	;Set starting DCN of next chunk
	CLR	R1		; and initialize size
50$:	ADD	FCLRAT,R1	;Increase the size of this chunk
	SUB	FCS,R4		;And another file cluster bites the dust
	BLOS	60$		;Branch if we're done
	BIT	R5,#17		;END OF THIS RETRIEVAL ENTRY?
	BNE	40$		;NO, REPEAT
	MOV	-20(R5),R3	;YES, GET LINK TO NEXT
	BIC	#17,R3		;CLEAR FLAG BITS
	BNE	30$		;LOOP IF NOT END OF LIST

60$:	MUL	DCS,R1		;EXPAND DCN'S TO NUMBER OF BLOCKS	;MNB006
	ADD	R4,R1		;Cut last chunk to only as much as needed
	BEQ	70$		;Nothing needed, skip ahead
	CALL	EXPAND		;Expand the last chunk
	MOV	(SP)+,R0	;Get actual word count to use
	BIC	#^C<377>,R0	;Isolate last partial block's count
	BEQ	70$		;Was a full block, skip
	MOVB	R0,4(R2)	;Update last word count
	DECB	5(R2)		; one less block
70$:	TST	-(R2)		;Check for overflow
	BNE	90$		;No room in boot, make it non-bootable
	MOV	INIDC1,R2	;GET DCN OF INIT.SYS' SIL INDEX BLOCK	;JDB009
	CALL	FSRDRF		;READ IN THE SIL INDEX BLOCK		;JDB009
	BCS	110$		;UNLESS THERE ARE PROBLEMS		;JDB009
	MOV	FIBUF+SI.ENT+SE.XFR,SATBUF+B.XFER-B.BOOT		;JDB009
		;MOVE XFER ADDRESS FROM SIL'S INDEX BLOCK TO BOOT BFR	;JDB009
	MOV	FIBUF+SI.ENT+SE.SIZ,R2	;GET THE LOAD SIZE IN BYTES	;JDB009
	CLC			;AVOID SIGN EXTEND			;JDB009
	ROR	R2		;CHANGE BYTE SIZE TO WORD COUNT		;JDB009
	MOV	R2,SATBUF+B.TWC-B.BOOT	;SQUIRREL AWAY IN BOOT BUFFER	;JDB009
80$:	CLR	R2		;WE WANT FBN
	CLR	R3		; 0 AGAIN
	MOV	#256.,R1	;WRITE A BLOCK
	CALL	WDSKIO,R5	;WRITE OUT COMPLETED BOOT BLOCK
85$:	  BR	120$		;BAD BLOCK - FATAL			;JDB009
	  CALLX	RESSAT		;RESTORE THE SATT
	RETURN

90$:	TST	(SP)+		;DON'T NEED WORD COUNT ANY MORE		;JDB008
	MOV	#SATBUF,R1	;POINT BACK INTO SATBUF			;JDB008
	CALL	JPERC		; "%%%"
	MESSAG	<"Output volume is not bootable">
	BR	10$		;Put in the dummy boot

100$:	CALL	BADLNK		;BAD DIRECTORY ERROR

110$:	CALL	FATBAD		;BAD BLOCK ON DCN READ

120$:	MOV	#NOWRTB,ABTADR	;%%% CAN'T WRITE BOOT
	CALL	CHKABT

	I.DATA
FCS:	.BLKW			;INIT's file clustersize
FCLRAT:	.BLKW			;FCS/DCS
INIDC1:	.WORD	0	;HOLDER FOR OUTPUT INIT.SYS SIL INDEX DCN	;JDB009
	UNORG

GLOBAL	<FCINIT,FQINIT,FIBUF,HIGHBF,SATBUF,DCS>

.DSABL	LSB

.SBTTL	Enter data for a contiguous chunk into the block map

EXPAND:	TST	R1		;IS THERE A PREVIOUS CHUNK?		;MNB006
	BEQ	30$		;Skip if there was no previous chunk
	MOV	R4,-(SP)	;Save some registers
	MOV	R5,-(SP)	; another one
	MOV	2+4(SP),R4	;Get starting DCN
	MUL	DCS,R4		;Multiply by DCS to get block number
	BPL	10$		;Branch if no overflow
	ADD	DCS,R4		;Correct for signed multiply
10$:	MOV	#77400/400,R0	;Get max block count
	CMP	R0,R1		;Do we even have that many blocks?
	BLOS	20$		;Yes
	MOV	R1,R0		;No, so do only as many as exist in this chunk
20$:	MOV	R0,-(R2)	;Set block count
	SWAB	(R2)		; now word count
	MOV	R4,-(R2)	;Set high order block number
	MOV	R5,-(R2)	; and low order
	ADD	R0,R5		;Advance block number
	ADC	R4		; in double precision
	SUB	R0,R1		;Compute how many blocks are left
	BNE	10$		;Some, stash another chunk
	MOV	(SP)+,R5	;Restore registers
	MOV	(SP)+,R4	; and another
30$:	MOV	(SP)+,(SP)	;Remove the word passed on the stack
	RETURN			;Done...

