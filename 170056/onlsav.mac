TITLE	ONLSAV,<SAV/RES ON-LINE DRIVER>,0A,10-MAY-91,JDB

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	Edit history for ONLSAV

;+
;
;  000	GPK  10-Aug-82	Cells for BDLBOT/GGBOOT to pass things in
;  001	WJS  30-Sep-83	Remove "High buffer offset", cf PARSEX
;  002	TWH  12-DEC-83	ADD SIZE DEFINITIONS FOR VIRTUAL DISK
;  003  KMF  14-Jan-84  UPDATE FOR 8-BIT COMPATIBILITY (UNSET PARITY)
;  004	DBM  18-Jan-84	Add VT200 support (No <LF> key)
;  005	TPT  18-Jun-85	Added 'MU' mnemonic to BOONAM
;  006  VAM  12-Jul-85	Add BOOTWC global, and have GGBOOT fill it in.
;  007	JDB  02-Mar-87	Fix undefined DU.UNC for online version
;  008	PJH  02-Mar-87	Add hooks for GPK disks
;  009  JDB  12-May-87  Fix high unit number error messages
;  010	PJH  09-Jul-87	Add large disk (semi-)support
;  011  VAM  09-Feb-88	Add VBCHK and FSZBOT to resolve undefined globals.
;  012  BGN  22-AUG-88  Modify stack size
;-

.SBTTL	MACROS AND PARAMETER DEFINITIONS

;L$$IST	= 1.			; LIST THE PREFIX FILES.

.PRIV	= EMT!377		; FOR DIRECT RSTS CALLS.

.MCALL	..V1..,.EXIT
..V1..

.MACRO	I.MESS
	TMPORG	ONLTXT
.NLIST	BEX
.ENDM	I.MESS

; MACRO TO PRINT FATAL ERROR MESSAGE
.MACRO	ERF	TEXT
.IF NB	<TEXT>
CALL	PRTERF
MESSAG	<TEXT>
.ENDC
CALLR	ABORT
.ENDM

; MACRO TO GET OUT OF SAVE/RESTORE
.MACRO	EXIT
	CALLR	I.INIT
.ENDM

.MACRO	UNQTXT	TEXT
.NLIST
.DSABL	CRF
$$$$$$	= 0
.IRPC	X,<TEXT>
.IF EQ	''X-'\
$$$$$$	= 200
.IFF
	 .BYTE	''X+$$$$$$
.ENDC
.ENDM
	 .BYTE	377
.ENABL	CRF
.LIST
.ENDM	UNQTXT

.SBTTL	COMMON ASCII DEFINITIONS

.EQUATE	BELL	, 7
.EQUATE	TAB	, 11
.EQUATE	LF	, 12
.EQUATE	VT	, 13
.EQUATE	FF	, 14
.EQUATE	CR	, 15
.EQUATE	ESCAPE	, 33
.EQUATE	SPACE	, 40

; OTHER USEFUL CONSTANTS

.EQUATE	DDWLO	, 2000		;WRITE-LOCK FLAG IN FIRQB+FQFLAG
.EQUATE	WRKCHN	, 14.*2		;CHANNEL NUMBER * 2 FOR WORK FILE

DU.UNC==20	;Must Match INIT's definition				;JDB007

.SBTTL	DEFINING CSECT'S

	DEFORG	ONLCTL		;MUST BE FIRST
	DEFORG	ONLSAV		;CODE
	DEFORG	ONLTXT		;TEXT
	DEFORG	PATCH		;PATCH SPACE
	 .BLKW	100		;64. WORDS

; THE FOLLOWING SECTIONS ARE ALIGNED ON 1000 BYTE BOUNDARIES BY ROUNDING PATCH

	DEFORG	FIBUF		;FIP BUFFER
	DEFORG	SATBUF		;SATT BUFFER

	ORG	ONLSAV

.SBTTL	I/O BUFFERS

	TMPORG	FIBUF		;NOTE:  FIBUF MUST RESIDE ON A 1K BOUNDARY.

FIBUF::	.BLKW0	256.		; THIS FORCES IT TO #1000.
FIBMAP	==	FIBUF+760
FIBENT	==	FIBUF+762
FIBEND	==	FIBUF+1000
	UNORG

	TMPORG	SATBUF

SATBUF::.BLKB	1000*16.
SATLEN	=	.-SATBUF
	UNORG

	TMPORG	ONLCTL

IOBUFF::.BLKB	1000*16.+4
SCRBUF::.BLKB	1000*16.+4
	UNORG

.SBTTL	DATA AREA

	TMPORG	ONLCTL

I.STAK	==	1500				;012

BITBYT::.BYTE	1,2,4,10,20,40,100,200,0,0

	.EVEN


FQ...::	.WORD	0,0,0,1,0,0,0
	.BLKW0	17.
FC...::	.BLKW0	FCBSIZ/2

SILNAM::.WORD	0,0

CTLOFG::.WORD	0

I.DSQ::	.BLKW0	DSQSIZ/2	;FILE I/O DSQ
FILDSQ::.BLKW0	DSQSIZ/2	;ANOTHER DSQ

SETDEV:	.BLKW0	2
SETTBL:	.BLKW0	2
	.WORD	-1
	.WORD	12
	.WORD	13

RINGS::	. + 2
	.WORD	0		;FOR INIT CTRL-C TRAPPING
NRETRY::.WORD	0
FIPFLG::.WORD	0

D.DATF::.WORD	0		;DEFAULT DATE FORMAT
I.DATE::.WORD	0		;CURRENT DATE

NRSTSD::.BYTE	0		;FOR SETFNR (NOT-A-RSTS-DISK)
NOERR::	.BYTE	0		;FLAG TO FIP: DON'T STOP ON ERRORS

D.TIMF::.WORD	0		;DEFAULT TIME FORMAT
I.TIME::.WORD	0		;CURRENT TIME
I.SEC::	.BYTE	0		;SECONDS TO NEXT MINUTE

HIGHBF::.BYTE	0		;FOR EXTENDED MEMORY I/O ADDRESSING

	.EVEN								;001
IOBF1$::.WORD	0		;Give PARSEX an MMU value of "zero"	;001


SAVDEV::.BYTE	0		;<>0 SAYS 'BOOTED FROM SAVE VOLUME'
SAVBOO::.BYTE	0		;<>0 SAYS 'CAN'T DO NOTHIN' BUT BOOT NOW'
GOTSB2:	.BYTE	0		;<>0 SAYS 'SATBF2 IS RESIDENT (IN SCRBUF)'
	UNORG


.SBTTL	MORE DATA
	TMPORG	ONLCTL

GETCLS::.BYTE	1,2,4,10,20,40,100,200,0
	.EVEN
SATSYS::.WORD	0		;* + SEGS = # OF BLOCKS
	.WORD	0		;* + BYTS = # OF BYTES
	.WORD	0		;* + BITS = # OF BITS OR CLUSTER @PCS
SATSYN::.WORD	0		;# OF CLUSTERS OF SAT THAT ARE USEFUL

FIBIDX::			;FIBUF DISK INDEX SAME AS SYSTEM DISK INDEX
SYSNDX::.WORD	0		;SYSTEM DISK INDEX.
FIBUNT::			;FIBUF DISK UNIT NUMBER SAME AS SYS DISK
SYSUNT::.WORD	0		;SYSTEM DISK UNIT NUMBER
DCS::	.WORD	0		;SYSTEM DISK DEVICE CLUSTER SIZE
PCS::	.WORD	0		;SYSTEM DISK PACK CLUSTER SIZE
CLURAT::.WORD	0		;CLUSTER RATIO = PCS/DEVICE CLUSTER SIZE
BADFLG:	.WORD	0		;FILE BAD BLOCK FLAG FOR CLEAN
XXBPTR::.BLKW0	2		;Pointer block for BLDBOT
MSBSID::.BLKW0	1		;Massbus ID of disk being hooked (BLDBOT)
XFERAD::.BLKW0	1		;INIT's transfer address (BLDBOT)
BOOTWC::.BLKW0	1		;INIT's first segment word count	;006

SETFP0::			;START OF FIP CLEARED AREA

FIBPHS::.WORD	0,0	;BLOCK NUMBER CURRENTLY IN 'FIBUF'

FIPCLU::.WORD	0	;CURRENT FILE CLUSTER SIZE
FIPMUC::.WORD	0	;CURRENT MFD/UFD CLUSTER SIZE

;****** I,J,K ARE GROUPED
I::	.WORD	0	;LINK OFFSET INTO BUFFER (0-777)
J::	.BYTE	0	;LINK ?
K::	.BYTE	0	;LINK ?

;****** FIBUNT,FIBSTA ARE GROUPED
	.EVEN
	.BYTE	0	;FIBUNT: UNIT # OF BLOCK CURRENTLY IN 'FIBUF'
FIBMOD::
FIBSTA::.BYTE	0	;MARKER FOR 'FIBUF' (MUST BE ODD ADDR!)

SYSSZL::.WORD	0	;SELECTED DISK SIZE LSB
SYSSZM::.WORD	0	;  "        "    "  MSB

SYSPHU::.BYTE	0,0	;LOW BYTE=UNIT*2, HIGH BYTE = UNIT

SETFP1::		;END OF FIP CLEARED AREA
BACKUP::.BYTE	0	;FLAG IN INIT SAYS 'DOING SAVE/RESTORE'
	.EVEN
IOERR::	.BYTE	0	;RETURN I/O ERRORS HERE
DSIFLG::.BYTE	0	;FLAG FOR INIT DISK DRIVERS TO RECOVER ERRORS
TMPXRB:	.BLKW0	XRBSIZ/2 ;TO HOLD A TEMPORARY COPY OF THE XRB
	.EVEN
	UNORG

.SBTTL	FIRQB'S

.MACRO	FQBGEN	TAG,NAMEXT,SIZ
	TMPORG	ONLCTL
.LIST
	.EVEN
FQ'TAG::
.NLIST
	.WORD	0		;LINK (UNUSED)
	.BYTE	0,0		;FUNCTION, JOB
	.WORD	0		;CHANNEL
	.WORD	0*400+1		;PPN [0,1]
	.RAD50	"NAMEXT"	;FILE NAME & EXTENSION
	.WORD	SIZ+0		;REQUIRED SIZE (IF ANY)
	.WORD	0,0,0
	.BYTE	60,77		;STATUS, PROTECTION (?)
	.WORD	0,0,0,0		;REMAINDER OF STANDARD FIRQB

	.WORD	0		;REFRESH STATUS BITS
	.WORD	0		;CURRENT FILE SIZE
	.WORD	0		;CURRENT START CLUSTER
	.WORD	0		;PREFERRED START CLUSTER
	.WORD	0,0,0		;EXTRA WORDS FOR SCRATCH
	.WORD	0
.LIST
FC'TAG::
	.BLKW0	FCBSIZ/2	;FILE'S FCB
.NLIST
	UNORG
.ENDM	FQBGEN

	FQBGEN	SATT,<SATT  SYS>

	FQBGEN	BADB,<BADB  SYS>

	FQBGEN	INIT,<INIT  SYS>

.SBTTL	ROOTBL:	DSKSZL, DSKSZM, DSKDCS, DSKNAM: FIXED POINTERS

; POINTERS AND OTHER FIXED DATA FOR DISK CONTROL

	TMPORG	ONLCTL

DSKSZL::$DISKS		;DISK SIZE TABLE POINTERS (LSB) [FIXED]
	.WORD	NAME'$SZL		;NAME DISK LSB SIZE TABLE POINTER
.ENDM

DSKSZM::$DISKS		;DISK SIZE TABLE POINTERS (MSB) [FIXED]
	.WORD	NAME'$SZM		;NAME DISK MSB SIZE TABLE POINTER
.ENDM

DSKDCS::$DISKS		;DEVICE CLUSTER TABLE POINTERS [FIXED]
	.WORD	NAME'$DCS		;NAME DISK DCS TABLE
.ENDM
	UNORG

	TMPORG	ONLCTL
BOONAM::.WORD	"MU							;005
	.WORD	"MS		;Names of valid boot devices
	.WORD	"MT
	.WORD	"MM
DSKNAM::$DISKS			;DISK NAMES IN ASCII [FIXED]
	.WORD	"NAME
.ENDM
	.WORD	0		;ENDS WITH 0

DSKRAD::$DISKS			;DISK NAMES IN RAD-50 (UNIT 0)
	.RAD50	/NAME'0/
.ENDM
	.WORD	0		;ENDS WITH 0
	UNORG

.SBTTL	DEVICE INFORMATION

	TMPORG	ONLCTL

DC$SZL::.BLKW0	8.		;RC = 256 BLOCKS/PLATTER [FIXED]

DF$SZL::.BLKW0	8.		;RF = 1024 BLOCKS/PLATTER [VARIABLE]

DS$SZL::.BLKW0	8.		;RS04=2048, RS03=1024. ORDERED BY PHY UNIT [BOOT]

DK$SZL::.BLKW0	8.,4800.	;RK = 4800. SEGMENTS [FIXED]

DL$SZL::.BLKW0	4.,10220.	;RL01 = 10220, RL02 = 20460 [BOOT]

DM$SZL::.BLKW0	8.,27104.	;RK06 = 27104

DP$SZL::.BLKW0	8.,14464.	;RP03=80000, RP04=40000 [BOOT]
DP$SZM::.BLKW0	8.,1		;HIGH ORDER RP SIZE [BOOT]
DP$DCS::.BLKW0	8.,2		;RP02/03 DCS IS ALWAYS 2 [FIXED]

DB$SZL::.BLKW0	8.,36128.	;RB=167,200 SEGMENTS [BOOT]
DB$SZM::.BLKW0	8.,2		;RB SIZE (MSB) [BOOT]
DB$DCS::.BLKW0	8.,1		;DEV CLU SIZES FOR RP04/05/06'S [BOOT]

DR$SZL::.BLKW0	8.,586.		;RR=131,656 SEGMENTS
DR$SZM::.BLKW0	9.,2		;HIGH ORDER RR SIZE
DR$DCS::.BLKW0	8.,4		;RR DCS

DU$SZL::.BLKW0	16.		;DU (RA80) SEGMENTS
DU$SZM::.BLKW0	16.		;HIGH ORDER RA80 SIZE
DU$DCS::.BLKW0	16.,4		;RA80 DCS

DV$SZL::.BLKW0	1		;VIRTUAL DISK LSB (FILLED IN AT OPEN TIME) ;002
DV$SZM::.BLKW0	1		;VIRTUAL DISK MSB (FILLED IN AT OPEN TIME) ;002
DV$DCS::.BLKW0	1		;VIRTUAL DISK DCS (FILLED IN AT OPEN TIME) ;002

DW$SZL::.BLKW0	1		;HOOK FOR GPK STUFF			;008
DW$SZM::.BLKW0	1							;008
DW$DCS::.BLKW0	1							;008

DZ$SZL::.BLKW0	1		;HOOK FOR GPK STUFF			;008
DZ$SZM::.BLKW0	1							;008
DZ$DCS::.BLKW0	1							;008


; DEVICE CLUSTER SIZE IS 1 FOR ALL SMALL DISKS
DC$DCS::
DF$DCS::
DS$DCS::
DK$DCS::
DL$DCS::
DM$DCS::.BLKW0	8.,1		;DCS 1 FOR ALL 8 UNITS [FIXED]

; MSB OF SIZE OF ALL SMALL DISKS IS 0
DC$SZM::
DF$SZM::
DS$SZM::
DK$SZM::
DL$SZM::
DM$SZM::.BLKW0	8.		;ALL 8 UNITS ARE SMALL [FIXED]

; THE FOLLOWING VALUES DESCRIBE THE BOOTED DEVICE.
; THEY ARE ALL SET UP BY THE ONE-SHOT CODE, AND NEVER MODIFIED
SYNXSV::.WORD	0		;SAVE SYSTEM DISK INDEX [BOOT]
SYSUSV::.WORD	0		;SAVE SYSTEM DISK UNIT NUMBER [BOOT]
RCSLSV::.WORD	0		;SAVE RC SIZE [BOOT]
RFSLSV::.WORD	0		;SAVE RF SIZE [BOOT]
SYSNAM::.WORD	0		;SYSTEM DISK NAME IN ASCII [BOOT]
	UNORG

.SBTTL	ROOT FAKER AND ABORT

ABORT:				;ABORT (DROP THROUGH)

I.INI0::
I.INIT::.EXIT			;GO AWAY

.ENABL	LSB

INITGO::MOV	#I.STAK,SP	;INITIAL ENTRY POINT
	CALL	ZAPXRB		;CLEAR THE XRB
	CALL	ZAPFQB		; AND THE FIRQB
	MOVB	#LOKFQ,FIRQB+FQFUN ;PREPARE FOR LOOKUP OF SATT.SYS
	MOV	#-1.,FIRQB+4	;NOT WILDCARD LOOKUP
	MOV	#0*256.+1,FIRQB+FQPPN ;[0,1]
	MOV	#^RSAT,FIRQB+FQNAM1 ;SATT.SYS
	MOV	#^RT  ,FIRQB+FQNAM1+2
	MOV	#^RSYS,FIRQB+FQEXT
	.PRIV,	CALFIP		;DO THIS TO FIND SYSTEM DISK NAME. UGH.

	MOV	FIRQB+FQDEV,SYSNAM ;SAVE PHYSICAL NAME OF SYSTEM DISK
	MOVB	FIRQB+FQDEVN,R2	;GET UNIT NUMBER OF SYSTEM DISK
	MOV	R2,SYSUNT	;SAVE IT
	MOV	R2,SYSUSV	;AND AGAIN
	MOVB	R2,SYSPHU+1	;AND AGAIN
	ASL	R2		;MAKE IT UNIT*2
	MOVB	R2,SYSPHU	;AND SAVE THAT, AS WELL

	CALL	ZAPFQB		;PREPARE TO OPEN THE SYSTEM DISK
	MOVB	#OPNFQ,FIRQB+FQFUN ;SET 'OPEN' FUNCTION CODE
	MOVB	#3*2,FIRQB+FQFIL ;USE CHANNEL 3
	MOV	SYSNAM,FIRQB+FQDEV ;OPEN "SY0:"
	MOVB	SYSUNT,FIRQB+FQDEVN ;GET UNIT NUMBER
	MOVB	#-1,FIRQB+FQDEVN+1 ;SAYS 'REALLY A UNIT NUMBER'
	.PRIV,	CALFIP		;DO IT
	MOVB	FIRQB,IOERR	;ANY ERRORS?
	BEQ	10$		;NOPE
	CALL	TYPERR
	ERF

10$:	MOV	SYSNAM,R2	;CALCULATE SYSNDX
	MOV	#DSKNAM,R3	;GET DISK NAME TABLE
20$:	CMP	R2,(R3)+	;SAME NAME?
	BEQ	30$		;YUP
	TST	(R3)		;END OF LIST?
	BNE	20$		;NOPE
	CALL	PRTERF		;'??? FATAL SAV/RES BUG: '
	MESSAG	<"Unknown disk type ">
	CALL	TYPE2		;PRINT DEVICE NAME
	ERF

30$:	SUB	#DSKNAM+2,R3	;SET R3 TO DISK INDEX
	MOV	R3,SYSNDX	;SAVE IT
	MOV	R3,SYNXSV	;AND AGAIN
	MOVB	FIRQB+26,DCS	;GET SYSTEM DISK DCS
	MOV	FIRQB+FQSIZ,R1	;GET DISK SIZE IN CLUSTERS
	MUL	DCS,R0		;R0=MSB, R1=LSB
	ADD	DSKSZL(R3),R2	;R2 -> LSB FOR DISK TYPE/UNIT
	MOV	R1,(R2)		;SAVE LSB OF DISK SIZE
	MOVB	SYSPHU,R2	;GET BACK UNIT*2
	ADD	DSKSZM(R3),R2	;R2 -> MSB FOR DISK TYPE/UNIT
	MOV	R0,(R2)		;SAVE MSB FOR DISK
	MOV	SYSUNT,R2	;SAVE DCS IN DSKDCS TABLE
	ASL	R2		;CALCULATE UNIT*2
	ADD	DSKDCS(R3),R2	;FIND DCS ENTRY FOR THIS UNIT
	MOV	DCS,(R2)	;SAVE IT

	CALL	ZAPFQB		;MAKE US A WORK-FILE
	MOVB	#CRTFQ,FIRQB+FQFUN  ; OF A TEMPORARY SORT
	MOVB	#WRKCHN,FIRQB+FQFIL ; ON CHANNEL 14.
	MOV	#16.,FIRQB+FQSIZ ;16 DISK BLOCKS WORTH
	MOV	#100000!256.!64.!32.,FIRQB+FQMODE ;SEQ CACHE, CND CTG, TENT
	.PRIV,	CALFIP
	MOVB	FIRQB,IOERR	;ANY ERRORS?
	BEQ	40$		;NOPE
	CALL	PRTERF
	MESSAG	<"in work-file">
	CALL	TYPERR
	ERF

40$:	BIS	#ONLIN,MNTFLG	;FLAG TO SAY WE IS ON-LINE
	MOV	#I.STAK,SP	;RESET THE STACK POINTER
	CALLRX	SRDIAL		;GO DO THE DIALOG

.DSABL	LSB	

SRDONE::			;RE-ENTRY AFTER SUCCESSFUL COMPLETION
	MOVB	#4,CHANO	;PREPARE TO RESET CHANNELS
10$:	CALL	RESET		;RESET A CHANNEL
	ASRB	CHANO		;ON TO NEXT CHANNEL
	BGT	10$		;GO RESET IT
	BIS	#ONLIN,MNTFLG	;FLAG TO SAY WE IS ON-LINE
	MOV	#I.STAK,SP	;RESET THE STACK POINTER
	CALLRX	SVRST		;GO DO THE RESTART

;	DISPATCH TO PROPER ROUTINE

SRDOIT::MOV	OPFLG,R0	;WHAT DO THEY WANT?
	ASR	R0		;MAKE IT A WORD POINTER
	BIC	#1,R0		;WORDS ARE NOT ODD!
	JMP	@DISPAT(R0)	;DO IT

30$:	ERF	<"Bad option">

GLOBAL	<MNTFLG,OPNFLG,OPFLG,DISPAT>

.SBTTL	DISK - DO ALL DISK I/O HERE (CALLED BY PARSEX)

;+
; DISK:	DO ALL DISK I/O FOR PARSEX
;
; CALL	DISK
;
;	DATA PASSED IN DSQ
;
; RETURN:
;	C=0 DONE
;	C=1 ERROR IN IOERR
;	N.B.  NOT ALL ERRORS PASS THROUGH
;
;	NOTE::	IT IS ASSUMED THAT, IN INIT, IOBUFF STARTS
;		AT #200000. YOU HAVE BEEN WARNED.
;-
.ENABL	LSB

DISK::	MOV	R0,-(SP)	;SAVE SOME REGISTERS
	MOV	R1,-(SP)
	MOV	R2,-(SP)
	TSTB	GOTSB2		;IS SATBF2 MAPPED?
	BEQ	10$		; NO, SO ALL IS GOOD
	CALL	RSTSB2		;ELSE UNMAP IT

10$:	MOV	DSQFBL(R4),R0	;GET LSB OF BLOCK TO TRANSFER
	MOVB	DSQFBM(R4),R1	;GET MSB OF BLOCK TO TRANSFER
	;TST	R1		;IS IT BLOCK ZERO?
	BNE	20$		;NOPE
	TST	R0		;MAYBE?
	BNE	20$		;NO
	CLRB	OPNFLG		;RE-OPENING THE DISK
	CALL	XXRSET		;CALL XXRSET TO GET BACK TO FBN=0
	MOVB	#-1,OPNFLG	;SAY THAT IT IS OPEN
	BR	50$

20$:	MOV	DCS,-(SP)	;PUT DCS ON STACK
	DEC	(SP)		;MAKE IT A MASK
	COM	(SP)		;COMPLEMENT IT
	MOV	R0,R2		;GET LSB OF DESIRED BLOCK
	DEC	R2		;LOCATE THE BLOCK OFFSET INTO THE CLUSTER
	BIC	(SP),R2		;GRAB THE BLOCK OFFSET INTO THE CLUSTER
	TST	(SP)+		;RESTORE THE STACK
	SUB	#1,R0		;DCN=( (FBN-1)/DCS) ) + 1.
	SBC	R1		;SUBTRACT FROM BOTH WORDS OF FBN
	MOV	DCS,-(SP)	;GET DEVICE CLUSTERSIZE FOR DIVIDE
	BNE	30$		;CAN'T BE ZERO
	ERF	<"DCS=0 in DISK">

30$:	ASRB	(SP)		;DIVIDE BY DCS
	BCS	40$		;BRANCH WHEN DONE
	ASR	R1		;SHIFT MSB
	ROR	R0		;BRING BIT INTO LSB
	ROLB	1(SP)		;PUT EXTRA BITS IN HIGH BYTE ON STACK
	BR	30$		;DO SOME MORE

40$:	INC	R0		;R0=DESIRED DCN
	TST	(SP)+		;GET JUNK OFF THE STACK

50$:	CALL	ZAPXRB		;CLEAR THE XRB FOR I/O
	MOV	R0,XRB+XRBLK	;GET CLUSTER NUMBER TO TRANSFER
	MOV	DSQCNT(R4),R1	;GET BUFFERSIZE FROM WORD COUNT

60$:	ASL	R1		;MAKE IT BUFFERSIZE IN BYTES
	MOV	R1,XRB+XRLEN	;SAVE IT
	MOV	DSQMAL(R4),XRB+XRLOC ;GET BUFFER ADDRESS
	TSTB	HIGHBF		;BUFFER IN EXTENDED MEMORY?
	BEQ	70$		;NO
;	SUB	#<IOBUF1&1777>*100,XRB+XRLOC ;UNBIAS ADDRESS FROM PARSEX	;001
;				  (PARSEX is given a "bias" -IOBF1$::- of zero)	;001
	ADD	#IOBUFF,XRB+XRLOC ;ADDRESS GIVEN WAS OFFSET INTO IOBUFF
70$:	MOVB	CHANO,XRB+XRCI	;GET CHANNEL NUMBER
	MOVB	DSQFUN(R4),R0	;WHAT SHOULD WE DO?
	TST	R2		;BLOCK 0 OF CLUSTER?
	BNE	150$		;NO - DO IT THE HARD WAY

80$:	CMP	R0,#WFUN	;IS IT WRITE?
	BEQ	110$		;YES
	CMP	R0,#RFUN.C	;IS IT READ CHECK ONLY?
	BEQ	190$		; YES
	CMP	R0,#RFUN	;IS IT READ?
	BEQ	100$		;YES
90$:	CALL	PRTERF		;'FATAL SAV/RES BUG: '
	MESSAG	<"Bad DISK function #">
	CALL	OCTWRD		;TELL THEM WHAT WE WERE ASKED TO DO
	ERF

100$:	.PRIV,	.READ		;THIS SHOULD DO IT
	BR	120$

110$:	MOV	XRB+XRLEN,XRB+XRBC ;BUFFER LENGTH AND BYTE COUNT ARE
	.PRIV,	.WRITE		; BOTH DEFINED AT I.DSQ+DSQCNT

120$:	CLC			;ASSUME NO ERROR
	MOVB	FIRQB,IOERR	;WELL?
	BEQ	140$		;GOOD SHOW
	CMPB	IOERR,#DATERR	;USER DATA ERROR?
	BEQ	130$		; YES, SO RECOVER
	CMPB	IOERR,#HNGDEV	;IS DEVICE HANGED?
	BEQ	130$		; YES; RECOVER
	CALL	PRTERF		;'FATAL SAV/RES BUG:"
	CALL	TYPERR		;NO, SO GIVE UP
	ERF

130$:	SEC			;RETURN WITH ERROR FLAG SET
140$:	MOV	(SP)+,R2
	MOV	(SP)+,R1
	MOV	(SP)+,R0
	RETURN

.SBTTL	SPECIAL HANDLING FOR OFF-CLUSTER I/O

150$:	MOV	XRB+XRLOC,220$	;SAVE ADDRESS OF DESIRED BUFFER
	MOV	XRB+XRLEN,230$	;ALSO BUFFER LENGTH
	MOV	#SCRBUF,XRB+XRLOC ;READ ENTIRE CLUSTER INTO SCRBUF
	MOV	DCS,R1		;GET DEVICE CLUSTERSIZE
	CMP	R1,#16.		;large disk read??			;010
	BLOS	155$		;no, so continue			;010
	MOV	#16.,R1		;otherwise, only read 16		;010
155$:	MUL	#512.,R1	;MAKE IT A BYTE COUNT
	MOV	R1,XRB+XRLEN	;THIS MUCH WE SHOULD READ
	.PRIV,	.READ		;DO IT
	TSTB	FIRQB		;ANY ERROR?
	BEQ	160$		;NOPE
	BR	120$		;GO AWAY

160$:	CMP	R0,#RFUN.C	;IS IT READ-CHECK?
	BEQ	210$		; YES
	MOV	R2,R1		;GET BLOCK OFFSET
	MUL	#512.,R1	;MAKE IT A BYTE OFFSET
	ADD	#SCRBUF,R1	;NOW WE HAVE THE ADDRESS OF THE BLOCK
	MOV	230$,R2		;GET # BYTES TO MOVE
	ASR	R2		;MAKE IT WORDS
	CMP	R0,#RFUN	;IS IT READ?
	BEQ	170$		;YES
	CMP	R0,#WFUN	;IS IT WRITE?
	BNE	90$		;IF NOT, IT IS ILLEGAL

	MOV	220$,R0		;FOR WRITE, GET BLOCK FROM NAMED BUFFER
	CALL	BLKMOV		;WRITE BLOCK INTO SCRBUF
	MOV	DCS,R1		;PREPARE TO REWRITE ENTIRE CLUSTER
	MUL	#512.,R1	;CALCULATE BUFFER LENGTH IN BYTES
	MOV	R1,XRB+XRLEN	;PUT BUFLEN IN THE XRB
	MOV	#SCRBUF,XRB+XRLOC ;WRITING FROM SCRBUF
	MOVB	CHANO,XRB+XRCI	;WRITE IT TO THE CORRECT DEVICE!!
	CLR	XRB+12
	CLR	XRB+XRMOD
	.PRIV,	.WRITE		;WRITE IT
	TSTB	FIRQB		;ERROR?
	BEQ	180$		; NO
	BR	120$		;GIVE UP?

170$:	MOV	R1,R0		;FOR READ, GET DATA FROM SCRBUF
	MOV	220$,R1		;DESTINATION WILL BE AS SPECIFIED
	CALL	BLKMOV		;MOVE IT THERE
180$:	BR	140$		;ALL DONE

.SBTTL	READ-CHECK (RFUN.C) ROUTINE

190$:	MOV	XRB+XRLOC,220$	;REMEMBER WHAT TO CHECK AGAINST
	MOV	XRB+XRLEN,230$	;REMEMBER HOW MUCH TO CHECK
	MOV	#SCRBUF,XRB+XRLOC ;DO READ INTO SCRBUF
	MOV	DCS,R1		;HOW MUCH SHOULD WE READ?
	MUL	#512.,R1	; AN ENTIRE CLUSTER?
	CMP	R1,XRB+XRLEN	;DID THEY WANT MORE THAN A CLUSTER?
	BLE	200$		; YES
	MOV	R1,XRB+XRLEN	;ELSE READ MORE THAN THEY WANTED
200$:	.PRIV,	.READ		;DO IT
	TSTB	FIRQB		;ANY ERRORS?
	BEQ	210$		; NO
	BR	120$		;DO IT LIKE ANY OTHER I/O ERROR

210$:	MOV	R2,R1		;CALCULATE BLOCK OFFSET, IF ANY
	MUL	#512.,R1	;MAKE IF A BYTE OFFSET
	ADD	#SCRBUF,R1	;NOW IT IS AN ADDRESS
	MOV	220$,R0		;STARTING ADDRESS TO COMPARE AGAINST
	MOV	230$,R2		;NUMBER OF BYTES TO COMPARE
	ASR	R2		;NOW IT IS WORDS TO COMPARE
	CALL	DATCHK		;COMPARE THEM
	BCC	180$		;NO PROBLEM
	MOVB	#DATERR,FIRQB	;ELSE CALL IT 'USER DATA ERROR'
	JMP	120$		;MAKE IT AN I/O ERROR

	TMPORG	ONLCTL
220$:	.BLKW0			;HOLDS ADDRESS OF DESIRED BUFFER
230$:	.BLKW0			;HOLDS WORD COUNT FOR COMPARE
	UNORG
.DSABL	LSB

.SBTTL	XXRSET:	RESET AND OPEN A CHANNEL

;+
; MXRSET: TO MATCH INIT ROUTINE (SAME AS XXRSET ONLINE)
; XXRSET: RESET AND OPEN A CHANNEL
;
;  ** THIS ROUTINE IS TOTALLY UNLIKE THE INIT ROUTINE OF THE SAME NAME **
;
;CALL:	CALL XXRSET
;
;	NO DATA IS PASSED EXPLICITLY-- IT IS LYING AROUND IN VARIOUS TABLES.
;	NO PARTICULAR DATA IS RETURNED!!
;
;ERROR: C=1 IF CAN'T OPEN THE DEVICE.
;
;-
.ENABL	LSB

MXRSET::
XXRSET::REGSCR				;FREE UP SOME REGISTERS
	TSTB	OPNFLG			;IS THIS AN 'ERROR RESET' CALL
	BNE	50$			;YES
	CALL	RESET			;RESET THIS CHANNEL
	CALL	ZAPFQB			;CLEAN UP THE FIRQB
	MOVB	#OPNFQ,FIRQB+FQFUN	;SET OPEN FUNCTION CODE.
	MOVB	CHANO,FIRQB+FQFIL	;OPEN CURRENT CHANNEL.
	MOV	SYSNDX,R0		;GET DISK INDEX.
	MOV	DSKNAM(R0),FIRQB+FQDEV	;PLUG IN DISK NAME.
	MOVB	SYSUNT,FIRQB+FQDEVN	;ADD UNIT NUMBER.
	MOVB	#-1.,FIRQB+FQDEVN+1.	;FLAG IT REAL.
	.PRIV,	CALFIP			;DO IT.
	TSTB	FIRQB			;ANY ERRORS?
	BNE	20$			; OOPS
	BIT	#DDWLO,FIRQB+FQFLAG	;DO WE HAVE WRITE ACCESS?
	BEQ	10$			; YES, SO CONTINUE
	CALL	RESET			;ELSE CLOSE THE CHANNEL
	MOVB	#NOTAVL,FIRQB		; AND COMPLAIN LOUDLY
	BR	20$

10$:	TST	R0			;IS THIS A MAGTAPE ?
	BMI	20$			;YES - SKIP DISK SPECIFIC STUFF
	MOVB	FIRQB+26,R0		;GET DCS
	MOV	R0,DCS			;STORE IT AS A WORD
	MOV	SYSNDX,R1		;FIND THE DCS TABLE
	MOV	SYSUNT,R2		;GET UNIT NUMBER
	ASL	R2			;MAKE IT TIMES 2
	MOV	R2,R3			;IT'S A GOOD NUMBER, I'LL KEEP IT
	ADD	DSKDCS(R1),R3		;CALCULATE TABLE ADDRESS
	MOV	R0,(R3)			;SAVE THE DCS THERE

	CLR	R4		;CALCULATE 2-WORD DISK SIZE IN BLOCKS
	MOV	FIRQB+FQSIZ,R5	; BY MULTIPLYING DCS * SIZE SIDEWAYS
15$:	ASR	R0		;TAKE SOME DCS
	BEQ	18$		;DONE IF NONE
	ASHC	#1,R4		;ELSE GIVE IT TO SIZE
	BR	15$		;GO GET SOME MORE
18$:	MOV	R2,R3		;GET UNIT INDEX IN TABLE
	ADD	DSKSZM(R1),R3	;CALCULATE THE MSB TABLE ADDRESS
	MOV	R4,(R3)		;STORE MSB OF DISK SIZE
	ADD	DSKSZL(R1),R2	;CALCULATE THE LSB TABLE ADDRESS
	MOV	R5,(R2)		;STORE LSB OF DISK SIZE
20$:	MOVB	FIRQB,IOERR	;ERROR?
	CLC			;ASSUME NO ERROR
	BEQ	50$		;OK
	CMPB	FIRQB,#NOTAVL	;DEVICE NOT AVAILABLE?
	BNE	30$		;NOPE
	MESSAG	<<177><200>"%%% ">
	MOV	SYSNDX,R0	;WHAT DEVICE?
	MOV	DSKNAM(R0),R2	;PUT THE NAME IN R2
	CALL	TYPE2		;TYPE IT OUT
	MOVB	SYSUNT,R2	;THEN GET UNIT NUMBER
	MOV	R2,-(SP)	;PRESERVE THE WHOLE UNIT NUMBER		;JDB009
	SUB	#10.,(SP)	;DECIMAL ADJUST IT			;JDB009
	BMI	25$		;BRANCH IF 0<UNIT<10.			;JDB009
	MOV	#61,R2		;ELSE MAKE THE UNIT'S TENS DIGIT	;JDB009
	CALL	TYPE		;TYPE THE 'ONE'				;JDB009
	MOV	(SP),R2		;RETRIEVE THE UNIT'S UNITS DIGIT	;JDB009
25$:	BIS	#60,R2		;TURN UNIT'S UNIT DIGIT TO ASCII	;JDB009
	TST	(SP)+		;CLEAN STACK				;JDB009
	CALL	TYPE		;TYPE IT OUT
	MESSAG	<": -- Device not available"<200>>
	BIS	#NOMSG,MNTFLG	;INDICATE ERROR MSG. ALREADY PRINTED
	BR	40$

30$:	;CALL	TYPERR		;PRINT THE MESSAGE (DEBUG)
40$:	SEC			;FLAG ERROR HAPPENED
50$:	RETURN

RESET:	CALL	ZAPFQB		   ;CLEAN THE FIRQB
	MOVB	#RSTFQ,FIRQB+FQFUN ;SET RESET FUNCTION CODE
	MOVB	CHANO,FIRQB+FQFIL  ;PURGE CURRENT CHANNEL
	.PRIV,	CALFIP		   ;NO ERRORS POSSIBLE
	RETURN

GLOBAL	<CHANO,MNTFLG>
.DSABL	LSB

.SBTTL	MAGIO - DO INIT-LIKE MAGTAPE INPUT AND OUTPUT

;+
; MAGIO - DO INIT-LIKE MAGTAPE INPUT AND OUTPUT
;
; CALL	R0 = MAGTAPE INDEX (IGNORED ON-LINE)
;	R1 = UNIT NUMBER (ALSO IGNORED HERE)
;	I.DSQ+DSQCNT = NUMBER OF WORDS TO TRANSFER (NOT IGNORED)
;
;	CALL	MAGIO,R5,<FUN,BUFADR>
;
;		WHERE FUN IS WFUN OR RFUN
;
;	BACK	C=0 IS NO ERROR
;		C=1 IS ERROR
;		FIRQB = ERROR CODE
;-
.ENABL	LSB

MAGIO::	MOV	R2,-(SP)	;SAVE R2
	CALL	ZAPXRB		;TIDY UP THE XRB
	MOV	I.DSQ+DSQCNT,R2	;GET WORD COUNT
	ASL	R2		;MAKE IT A BYTE COUNT
	MOV	R2,XRB+XRLEN	;AND STUFF IT IN THE XRB
	MOV	R2,XRB+XRBC	;TWICE
	MOVB	CHANO,XRB+XRCI	;LIKEWISE THE CHANNEL NUMBER
	MOV	(R5)+,R2	;WHATEVER SHALL WE DO?
	MOV	(R5)+,XRB+XRLOC	;WHERE SHALL WE DO IT?
	TSTB	HIGHBF		;HIGH MEMORY I/O ?
	BEQ	10$		;NO
	ADD	#IOBUFF,XRB+XRLOC ;YES - PASSED ADDRESS WAS IOBUFF OFFSET
10$:	CMPB	#RFUN,R2	;MIGHT IT BE A READ?
	BEQ	20$		;OK
	CMPB	#WFUN,R2	;IS IT WRITE?
	BEQ	30$		;YES

	CALL	PRTERF
	MESSAG	<"Bad MAGIO call @ ">
	MOV	2(SP),R0	;WHERE DID THEY WANT IT?
	CALL	OCTWRD
	ERF

20$:	CLR	XRB+XRBC	;MUST BE ZERO FOR READ
	.PRIV			;HEY, RSTS!!!
	.READ			;DO THE READ FOR ME
	BR	40$		;THEN SEE HOW WE DID

30$:	.PRIV
	.WRITE			;DO THE WRITE FOR ME
40$:	CLC			;ASSUME IT IS GOOD
	MOVB	FIRQB,IOERR	;AN ERROR
	BEQ	50$		;NOPE - WONDERFUL
	;CALL	TYPERR		;AN ERROR - TELL ME ABOUT IT (DEBUG)
	SEC

50$:	MOV	(SP)+,R2	;RESTORE R2
	RETURN	R5
.DSABL	LSB

.SBTTL	MAGSPC - DO SPECIAL MAGTAPE FUNCTIONS

;+
; MAGSPC - DO FUNNY MAGTAPE THINGS
;
; CALL	R0 = MAGTAPE INDEX (IGNORED HERE)
;	R1 = MAGTAPE UNIT (ALSO IGNORED)
;	R2 = PARAMETER
;
;	CALL	MAGSPC,R5,FUN
;
;	WHERE FUN IS:				AND R2 IS:
;		1 - REWIND AND OFFLINE		(UNUSED)
;		2 - WRITE EOF			(UNUSED)
;		3 - REWIND			(UNUSED)
;		4 - SKIP FORWARD		RECORDS TO SKIP
;		5 - BACKSPACE			RECORDS TO BACKSPACE
;		6 - SET DENSITY			DENSITY
;		7 - RETURN STATUS		(UNUSED)
;
;	BACK:	C=0 IS NO ERROR
;		R3= VALUE RETURNED AT XRB+2
;
;		C=1 IF ERROR,
;		  ERROR CODE RETURNED IN IOERR
;-
.ENABL	LSB

MAGSPC::MOV	#XRB+16,R3	;STARTING AT THE END OF THE XRB,
	CLR	-(R3)		;ZAP IT
	CLR	-(R3)		;AND AGAIN
	CLR	-(R3)		;AND AGAIN
	MOVB	#MTAHND,-(R3)	;PLUG IN THE MT HANDLER INDEX
	MOVB	CHANO,-(R3)	;AND CHANNEL * 2
	CLR	-(R3)		;MAKE THIS WORD CLEAN
	MOV	R2,-(R3)	;GET THE PARAMETER
	MOV	(R5)+,-(R3)	;AND THE FUNCTION CODE
	DEC	(R3)		;AND NOW FOR THE REAL FUNCTION CODE

10$:	.PRIV			;DO A SPECIAL FUNCTION
	.SPEC			;IT BETTER BE MAGTAPE!!

	MOV	XRB+2,R3	;GET THE VALUE RETURNED
	CLC			;BUT OF COURSE IT WORKED
	MOVB	FIRQB,IOERR	;DIDN'T IT?
	BEQ	20$		;YUP
	;CALL	TYPERR		;TYPE IT OUT (DEBUG)
	SEC			;NO GO, TRY IT ANOTHER DAY, ANOTHER WAY
20$:	RETURN	R5		;RETURN

.DSABL	LSB

.SBTTL	TYPE A MESSAGE ON THE TERMINAL (MESSAG) ** FROM INITTY **

;+
; MESSAG - TYPE A MESSAGE ON THE TERMINAL
;
;	CALL	MESSAG,R5,<ADDR OF ASCIZ STRING>
;
; MESSAGE HAS BEEN TYPED (TTY NOT NECESSARILY STOPPED)
;-
.ENABL	LSB

MESSAG::MOV	R0,-(SP)	;SAVE R0
	MOV	(R5)+,R0	;GET ADDRESS OF MESSAGE
	CALL	ASCIZ0		;SEND IT
	MOV	(SP)+,R0	;RESTORE R0
	RETURN	R5

.SBTTL	ASCIZ0:	TYPE A MESSAGE, R0-->MESSAGE

ASCIZ0::MOV	R2,-(SP)
10$:	MOVB	(R0)+,R2	;NULL?
	BEQ	30$		;YES, END
	CALL	TYPE		;TYPE IT
	BR	10$

20$:	MOV	(R2),R2		;FOR SPECIAL TYPING, GET THE BYTES
	CALL	TYPE2		;DO THE TYPING (CALL TO 20$ SAVES R2)
30$:	MOV	(SP)+,R2	;RESTORE R2
	RETURN

.SBTTL	RCTRLO:	RESET THE CTRL/O FLAG

RCTRLO::CALL	ZAPXRB		;CLEAR THE XRB FOR .SPEC (ALL ZEROES, ALMOST)
	MOVB	#TTYHND,XRB+7	;SET HANDLER INDEX=TTY
	.PRIV,	.SPEC
	RETURN			;DONE

.SBTTL	TYPECR:	TYPE <CR><LF>

TYPECR::CALL	20$,R2		;TYPE <CR><LF> STRING
	 .BYTE	CR,LF		;THIS IS IT

.SBTTL	TYPE2:	TYPE 2 CHARS FROM R2

TYPE2::	CALL	TYPE		;TYPE ONE
	SWAB	R2		;GET THE OTHER
	BEQ	RTSPC		;NO SECOND CHARACTER!

.SBTTL	TYPE:	TYPE A CHAR FROM R2

TYPE::	CMPB	R2,#177		;RESET ^O HERE?
	BEQ	RCTRLO		;YUP, GO DO IT
	CMPB	R2,#176		;IGNORABLE CHARACTER?
	BEQ	RTSPC		;YES
	CMPB	R2,#200		;TYPE <CR><LF>?
	BEQ	TYPECR		;YES
	CALL	ZAPXRB		;CLEAR THE XRB FOR WRITE
	MOV	R2,-(SP)	;SAVE R2 (WITH THE CHAR TO PRINT)
	MOV	#XRB,R2		;R2 -> XRB
	INC	(R2)+		;BUFFER IS ONE BYTE LONG, SO
	INC	(R2)+		; PRINT ONE BYTE
	MOV	SP,(R2)+	; FROM THE STACK
	.PRIV,	.WRITE		;DO IT
	MOV	(SP)+,R2	;RESTORE R2
RTSPC:	RETURN			;DONE

.SBTTL	TYPTAB:	TYPE A TAB ONLY

TYPTAB::CALL	20$,R2		;TYPE A TAB ONLY
	.BYTE	TAB,0

.DSABL	LSB

.SBTTL	TYPERR:	PRINT ERROR TEXT
;+
; TYPERR: PRINT AN ERROR MESSAGE
;
; CALL:	IOERR=ERROR NUMBER
; NOTHING BACK.
;-
.ENABL	LSB

	TMPORG	ONLTXT
	.EVEN
10$:	.BYTE	177,200			;RESET CTRL/O, <CR><LF>
	.ASCII	"%%% "			;STANDARD MESSAGE PREFIX
20$:	.BLKB	28.			;27 CHARS TEXT, 1 CHAR NULL
	UNORG

TYPERR:	MOV	R0,-(SP)		;SAVE R0.
	MOV	R1,-(SP)		;ALSO R1.
	MOV	R2,-(SP)		;ALSO R2.

	CALL	ZAPFQB
	MOVB	#UU.ERR,FIRQB+FQFUN	;DETERMINE THE ERROR
	MOVB	IOERR,FIRQB+FQERNO	;WHAT ERROR?
	.PRIV,	.UUO

	MOV	#FIRQB+5,R0		;START OF TEXT IN
	MOV	#20$,R1			;START OF TEXT OUT
	MOV	#28.,R2			;MAX NUMBER OF CHARS + 1

30$:	MOVB	(R0)+,(R1)+		;COPY IT
	BEQ	40$			;I'M DONE IF YOU ARE
	SOB	R2,30$			;DO IT AGAIN?

40$:	CLRB	-(R1)			;END WITH 0
	MOV	#10$,R0			;BUFFER ADDRESS TO R0
	CALL	ASCIZ0			;TYPE IT

	MESSAG	<" - called from ">	;INDICATE WHO CALLED US
	MOV	6(SP),R0		;GET THE RETURN ADDRESS
	CALL	OCTWRD			;PRINT IT IN OCTAL
	CALL	TYPECR			;END WITH <CR>

	MOV	(SP)+,R2		;RESTORE R2,
	MOV	(SP)+,R1		; R1, AND
	MOV	(SP)+,R0		; R0.

	RETURN
.DSABL	LSB

.SBTTL	BLKMOV:	MOVE LOTS OF STUFF FROM HERE TO THERE
.SBTTL	ZAPFQB:	CLEAR THE FIRQB IN EAGER ANTICIPATION OF A RSTS CALL
.SBTTL	ZAPXRB:	CLEAR THE XRB FOR RSTS CALLS
;+
; BLKMOV -- MOVE DATA FROM HERE TO THERE
;  CALL	BLKMOV
;
;  PASSED:	R0 = SOURCE ADDRESS
;		R1 = DESTINATION ADDRESS
;		R2 = NUMBER OF WORDS TO TRANSFER
;
;	ALL REGISTERS PRESERVED
;	NOTHING RETURNED
;-
.ENABL	LSB

BLKMOV:	REGSCR			;SAVE SOME REGISTERS

10$:	MOV	(R0)+,(R1)+
	SOB	R2,10$
	RETURN

ZAPFQB:	CALL	20$,R2		;THIS PRESERVES R2, RETURN TO CALLER BELOW
	.WORD	FIRQB		;STARTING AT FIRQB,
	.WORD	FQBSIZ/2	; ZERO THIS MANY WORDS

ZAPXRB:	CALL	20$,R2		;PRESERVE R2, RETURN TO CALLER BELOW
	.WORD	XRB		;STARTING AT XRB,
	.WORD	XRBSIZ/2	; ZERO THIS MANY WORDS

20$:	MOV	R0,-(SP)	;SAVE R0
	MOV	(R2)+,R0	;GET STARTING ADDRESS AND
	MOV	(R2),R2		; NUMBER OF WORDS TO BE ZEROED
30$:	CLR	(R0)+		;ZERO THIS WORD
	SOB	R2,30$		; AND DO SOME MORE
	MOV	(SP)+,R0	;RESTORE R0
	MOV	(SP)+,R2	;RESTORE R2, WHICH WAS PUSHED BY THE CALL
	RETURN			;RETURN TO THE CALLER OF ZAP??B

.DSABL	LSB

.SBTTL	DATCHK - COMPARE THE DATA IN TWO BUFFERS (FOR RFUN.C)

;+
; DATCHK: COMPARE THE DATA IN TWO BUFFERS
;
; CALL DATCHK
;
; DATA PASSED--
;	R0=ADDRESS OF FIRST BUFFER
;	R1=ADDRESS OF SECOND BUFFER
;	R2=NUMBER OF WORDS TO COMPARE
; BACK--
;	C=0 ALL IS EQUAL
;	C=1 NOT ALL IS EQUAL
;	R0, R1, AND R2 ARE DESTROYED!!!
;-
.ENABL	LSB

DATCHK:	CMP	(R0)+,(R1)+	;ARE THEY THE SAME?
	BNE	10$		; NO
	SOB	R2,DATCHK	;ELSE CONTINUE
;CLC				;RETURN WITH CARRY CLEAR (FROM 'SOB')
	TST	(PC)+		;ALL DONE AND GOOD
10$:	SEC			;RETURN WITH CARRY SET
	RETURN

.DSABL	LSB

.SBTTL	PRTERF - FATAL ONLSAV BUG

;+
; PRTERF - WE ARE ABOUT TO DIE BECAUSE OF A BUG
;
;	CALL	PRTERF
;-

.ENABL	LC

PRTERF:	MESSAG	<<177><200>"??? Fatal SAV/RES bug: ">
	RETURN



.SBTTL	QUESTION ASKER ** FROM INITTY **

;+
; ASKER - ASK A QUESTION AND GET AN ANSWER
;
;	CALL	ASKER,R5,<PTR TO SHORT TEXT, PTR TO LONG TEXT>
;
;	R1 -> ANSWER TEXT (ON WORD BOUNDARY)
;
;	Z=1, C=1 IFF ^Z TYPED
;	Z=1, C=0 IFF LINE FEED TYPED
;	Z=0, C=0 OTHERWISE
;
; NOTE:	TYPES SHORT TEXT, GETS ANSWER IN KBUFF.
;	IF ANSWER IS <CR> OR ?, TYPES LONG TEXT AND REPEATS
;-
.ENABL	LSB

ASKER::	MOV	(R5)+,20$	;GET SHORT QUESTION FORM
10$:	CALL	RCTRLO		;FORCE RESET OF ^O
	CALL	MESSAG,R5	;TYPE A MESSAGE
20$:	 .WORD	0		;MESSAGE TEXT POINTER
	MOV	(R5),20$	;PRESET LONG FORM IN CASE HELP NEEDED
	CALL	GETIN		;AND GET AN ANSWER
	BEQ	10$		;HE NEEDS HELP
	TST	(R5)+		;POP OVER LONG FORM
	CMPB	(R1),#12	;LINE FEED?
	BEQ	40$		;YES -- RETURN Z=1, C=0
	CMPB	(R1),#'Z-100	;^Z?
	BEQ	30$		;YES -- RETURN Z=1, C=1
	TST	(PC)+		;NOTHING SPECIAL -- SET Z=0, C=0
30$:	SEC			;SET CARRY FOR ^Z

RTSR5::				;FOR USE BY LOK5.. IN FIP
40$:	RETURN	R5		;EXIT
.DSABL	LSB

.SBTTL	FIND UNIQUE/CORRECT TEXT STRING

;+
; GETUNQ - FIND UNIQUE STRING FROM TABLE OF UNIQUE/CORRECT TEXT
;
;	R1 -> TEXT
;
;	CALL	GETUNQ,R5,<PTR TO UNQTXT TO MATCH>
;
;	C=0	MATCH FOUND
;		R1 UNCHANGED, BUT TEXT PAST BLANKS MOVED DOWN
;		R0 = INDEX * 2 OF MATCHING TEXT
;
;	C=1	NO MATCH
;		R0 = (HIGHEST INDEX + 1) * 2
;-
.ENABL	LSB

GETUNQ::MOV	(R5)+,R0	;GET MATCH TEXT POINTER IN R0
	REGSAV			;SAVE REGISTERS
	MOV	R1,R4		;COPY POINTER TO PASSED TEXT
	CLR	(SP)		;CLEAR RETURNED R0
10$:	MOV	R4,R1		;RESTORE POINTER TO PASSED TEXT
20$:	MOVB	(R0)+,R3	;GET MATCH TEXT CHARACTER
	BIC	#^C<177>,R3	;ISOLATE IT
	CMPB	R3,(R1)+	;COMPARE AGAINST PASSED TEXT
	BEQ	20$		;GOT IT?
	TSTB	-(R0)		;NO MATCH. IS MATCH TEXT CHARACTER OPTIONAL?
	BMI	50$		;YES, WE PROBABLY FOUND IT
30$:	CMPB	(R0)+,#377	;NO, SKIP TO END OF THIS MATCH STRING
	BNE	30$
	ADD	#2,(SP)		;NEXT INDEX
	TSTB	(R0)		;ANY MORE MATCH TEXT?
	BNE	10$		;YES, TRY AGAIN
	SEC			;NO, INDICATE FAILURE IN CARRY
40$:	CALLX	REGRES,R5	;RESTORE REGISTERS
	RETURN	R5		;BACK

50$:	TSTB	-(R1)		;FOUND DISCREPANCY AT OPTIONAL CHARACTER
	BEQ	70$		;THAT WAS THE END OF THE PASSED STRING
	CMPB	(R1),#57	;WAS IT A "/" THAT STARTS A SWITCH
	BEQ	70$		;YES IT WAS, LETS MOVE THE SWITCH DOWN
	CMPB	(R1),#72	;WAS IT A ":" WHICH IS ALSO A GOOD ENDING
	BEQ	70$		;YES IT WAS, LETS MOVE THE SWITCH DOWN
	CMPB	(R1),#75	;WAS IT A "=" WHICH ENDS THE OUTPUT SIDE
	BEQ	70$		;YES IT WAS, LETS MOVE THE SWITCH DOWN
	CMPB	(R1),#40	;IT WASN'T THE END, SO GOTTA BE A BLANK
	BNE	30$		;NO LUCK, NOT THIS MATCH TEXT

60$:	CMPB	(R1)+,(R1)	;SCAN PAST N BLANKS
	BEQ	60$		;UNTIL R1 -> NOT A BLANK
70$:	MOVB	(R1)+,(R4)+	;MOVE THE REST OF THE STRING DOWN
	BNE	70$		;UNTIL END OF ASCIZ
	CLC			;C=0 FOR SUCCESS
	BR	40$		;GO BACK TO THE CALLER

.DSABL	LSB

.SBTTL	ANSWER CHECKER

;+
; ANSWER - CHECK AN ANSWER FOR Y, N, <LF>, O, OR OTHER
;
;	R1 -> ANSWER TO CHECK
;
;	CALL	ANSWER,R5
;
;	 RETURN+0 - 'Y' RETURN
;	 RETURN+2 - 'N' RETURN
;	 RETURN+4 - LF  RETURN
;	 RETURN+6 - 'O' RETURN
;	 RETURN+10- OTHER
;-

ANSWER::MOV	R0,-(SP)	;SAVE R0
	CALLX	GETUNQ,R5	;PARSE THE ANSWER
	 GENTXT
	 UNQTXT	<Y\ES>		;0 YES
	 UNQTXT	<N\O>		;2 NO
	 .BYTE	12,377		;4 <LF>
	 UNQTXT	<O\LD>		;6 OLD
	 .BYTE	0		;10 OTHER
	 UNORG
	ADD	R0,R5		;BUMP RETURN ADDRESS PROPERLY
	MOV	(SP)+,R0	;RESTORE R0
	;CLC			;C=0 FROM 'ADD' ABOVE
	RETURN	R5

.SBTTL	YESNO:	YES/NO CHECKER

;+
; YESNO - CHECK REPLY FOR YES OR NO
;
;	R1 -> STRING TO CHECK
;
;	CALL	YESNO,R5,<PTR TO SHORT TEXT, PTR TO LONG TEXT>
;
;	 RETURN+0 - ^Z  FOUND
;	 RETURN+2 - LF  FOUND
;	 RETURN+4 - 'N' FOUND
;	 RETURN+6 - 'Y' FOUND
;-

.ENABL	LSB

YESNO::	MOV	(R5)+,20$	;GET TEXT POINTERS
	MOV	(R5)+,30$
10$:	CALL	ASKER,R5	;ASK THE QUESTION
20$:	 .WORD	0
30$:	 .WORD	0
	BCS	50$		;^Z -- RETURN +0
	CALL	ANSWER,R5	;CHECK THE ANSWER
	 TST	(R5)+		;YES -- RETURN +6
	 TST	(R5)+		;NO -- RETURN +4
	 BR	40$		;LF -- RETURN +2
	 NOP			;OLD  ??
	MESSAG	<"Please answer 'YES' or 'NO'."<200>>
	BR	10$

40$:	TST	(R5)+
50$:	RETURN	R5

.DSABL	LSB

.SBTTL	GETIN:	INPUT A LINE
.ENABL	LSB

GETIN::	REGSAV
	CALL	INPLIN,R5,<KBUFF>
	MOV	R5,TOS.R1(SP)	;RETURN TO CALLER IN R1
	CMPB	(R5),#CR	;PURE <CR>?
	BNE	10$		;NO
	MOV	(PC)+,(R5)	;YES, MAKE IT <LF><NUL>
	.BYTE	LF,0
10$:	CMP	(R5),#32	;PURE CONTROL CHARACTER (IE <CHAR><NULL> )?
	BLE	20$		;YUP, RETURN IT
	MOV	#4+10+20+40+200+1000,R0 ;DONT TRIM PARITY 		;KMF003
	CALLX	CVT$$
20$:	CALLX	REGRES,R5	;RESTORE REGISTERS
	CMPB	(R1),#'?	;CHECK FOR '?' TO SEE IF USER WANTS HELP ;004
	CLC			;ALWAYS RETURN WITH C-BIT CLEAR
	RETURN

	TMPORG	ONLCTL
	.EVEN			;KBUFF MUST BE ALIGNED
KBUFF::	.BLKB	100.
KBULEN = .-KBUFF
	UNORG
.DSABL	LSB

.SBTTL	INPLIN:	INPUT A LINE FROM THE TERMINAL

;+
; INPLIN - INPUT A LINE FROM THE TERMINAL
;
; CALL:	CALL	INPLIN,R5,<BUFFER>
;
; BACK:	R5 -> BUFFER
;	STRING READ FROM TELETYPE, TERMINATED WITH LF, ESC, FF, OR CTRL/Z
;	STRING MADE ASCIZ, BUT DELIMITER NOT STRIPPED
;
; NOTE:	NO SIZE CHECKING DONE
;-
.ENABL	LSB

INPLIN::MOV	R0,-(SP)	;SAVE R0
	MOV	R5,-(SP)	;SAVE R5
	MOV	(R5),R5		;R5 -> BUFFER
	CALL	ZAPXRB		;CLEAR THE XRB
	MOV	#XRB,R0		;R0 -> XRB
	MOV	#KBULEN-1,(R0)+	;ACCEPT UP TO LENGTH OF KBUFF
	TST	(R0)+		;SKIP TO BUFFER ADDRESS
	MOV	R5,(R0)+	;PUT BUFFER ADDRESS THERE
; MOVB		#0,XRB+XRCI	;INPUT FROM CHANNEL ZERO
	.PRIV,	.READ		;ASK RSTS TO GET SOME DATA
	MOV	XRB+XRBC,R0	;GET BYTE COUNT
	CMP	R0,#KBULEN-1	;DID WE FILL THE BUFFER?
	BLT	20$		;NOPE, SO WE'RE ALL OK
10$:	CALL	ZAPXRB		;GRAB THE REMAINING INPUT BEFORE
	MOV	#XRB,R0		; REPORTING AN ERROR
	MOV	#KBULEN-1,(R0)+	;TAKE ALL WE CAN GET
	TST	(R0)+		;SKIP TO BUFFER ADDRESS
	MOV	R5,(R0)+	;SET BUFFER ADDRESS
; MOVB		#0,XRB+XRCI	;READ FROM CHANNEL 0
	MOV	#8192.,XRB+XRMOD ;READ WITH NO WAIT
	.PRIV,	.READ
	TST	XRB+XRBC	;ANYTHING GOT?
	BNE	10$		;DO IT TIL DONE
	MOVB	#128.,(R5)+	;FAKE AN ILLEGAL RESPONSE
	CLR	R0		;R5 -> END OF STRING

20$:	ADD	R0,R5		;FIND END OF STRING
	CMPB	-1(R5),#'Z-100	;MAYBE GARBAGE FOLLOWED BY CTRL/Z?
	BNE	30$		;NOPE
	MOV	(SP),R5		;PUT CTRL/Z AT FRONT OF BUFFER
	MOV	(R5),R5
	MOV	#'Z-100,(R5)+	;NOTE: BUFFER MUST BE WORD-ALIGNED

30$:	CLRB	(R5)		;DELIMIT THE END OF THE STRING
	MOV	(SP)+,R5	;RESTORE R5
	MOV	(SP)+,R0	;RESTORE R0
	MOV	(R5)+,(SP)	;RETURN R5 -> BUFFER
	RETURN	R5

.SBTTL	TTYSTP:	WAIT FOR TTY TO STOP
;+
; TTYSTP - WAIT FOR TTY TO STOP
;
; CALL:	CALL	TTYSTP
;
; BACK:	TTY IS DONE TYPING
;	DESTROYS R2
;-

GETTTY::
TTYSTP::RETURN			;YES

.SBTTL	OCTAL PRINTERS

;+
; OCTWRD - PRINT AN OCTAL NUMBER (6 DIGITS)
; OCTBYT - PRINT AN OCTAL BYTE (3 DIGITS)
; OCT3DG - PRINT 3-DIGIT OCTAL NUMBER
; OCT4DG - PRINT 4-DIGIT OCTAL NUMBER
;
;	R0 =  NUMBER TO PRINT
;
;	CALL	OCT???
;-

.ENABL	LSB

OCTWRD::REGSCR			;SAVE REGS
	MOV	#6,R1		;COUNT IS 6
	BR	20$		;DO IT

OCT4DG::REGSCR			;SAVE REGISTERS
	MOV	#4,R1		;PRINT LOW 4 DIGITS
	BR	20$

OCT3DG::REGSCR			;SAVE REGS
	BR	10$		;AND DO 3 DIGITS

OCTBYT::REGSCR			;SAVE REGS
	BIC	#^C<377>,R0	;CLEAR OTHER BITS
10$:	MOV	#3,R1		;COUNT IS 3
20$:	MOV	#-1,-(SP)	;SET STOPPER FLAG
30$:	MOV	R0,-(SP)	;MOVE BITS TO STACK
	BIC	#^C<7>,(SP)	;ISOLATE BOTTOM OCTAL DIGIT
	ADD	#'0,(SP)	;MAKE IT ASCII
	;CLC			;ADD CLEARS THE CARRY
	ROR	R0		;SHIFT RIGHT 3 BITS
	ASR	R0
	ASR	R0
	SOB	R1,30$		;CONTINUE FOR ALL DIGITS
40$:	MOV	(SP)+,R2	;GET A DIGIT
	BMI	50$		;DONE
	CALL	TYPE		;TYPE IT
	BR	40$		;CONTINUE

50$:	RETURN

.DSABL	LSB
.SBTTL		DECIMAL PRINTERS
.SBTTL	DBLPRT:	PRINT DOUBLE-PRECISION NUMBER IN DECIMAL, BLANK FILL
.SBTTL	DBLZER:	PRINT DOUBLE-PRECISION NUMBER IN DECIMAL, NO BLANKS
;+
; DBLPRT - PRINT DOUBLE-PREC NUMBER IN DECIMAL, BLANK FILL
; DBLZER - PRINT DOUBLE-PREC NUMBER IN DECIMAL, NO BLANKS
;
;	R2 = NUMBER TO PRINT (LSB)
;	R3 = NUMBER TO PRINT (MSB)
;
;	CALL	DBL???
;-

.ENABL	LSB

DBLPRT::REGSCR			;SAVE REGISTERS
	MOV	#6,R5		;PRINT INTO A COLUMN 6 SPACES WIDE
	BR	10$

DBLZER::REGSCR			;SAVE REGISTERS
	CLR	R5		;DON'T ADD ANY LEADING SPACES
10$:	MOV	R2,R1		;MOVE LSB TO WHERE WE CAN WORK ON IT
	BR	30$

.SBTTL	DECPRT:	PRINT NUMBER IN DECIMAL WITH LEADING BLANKS
.SBTTL	DECZER:	PRINT NUMBER IN DECIMAL, BLANKS SUPPRESSED
.SBTTL	P4DDIG:	PRINT 4-DIGIT NUMBER IN DECIMAL, BLANK FILL
;+
; DECPRT - PRINT NUMBER IN DECIMAL WITH LEADING BLANKS
; DECZER - PRINT NUMBER IN DECIMAL, BLANK SUPPRESSED
; P4DDIG - PRINT 4-DIGIT NUMBER IN DECIMAL, BLANK FILL
;
;	R0 = NUMBER TO PRINT
;
;	CALL	DEC???
;-

DECPRT::REGSCR			;SAVE REGISTERS
	MOV	#6,R5		;PRINT INTO A COLUMN 6 SPACES WIDE
	BR	20$

P4DDIG::REGSCR			;SAVE REGISTERS
	MOV	#4,R5		;PRINT INTO A COLUMN 4 SPACES WIDE
	BR	20$

DECZER::REGSCR			;SAVE REGISTERS
	CLR	R5		;DON'T ADD ANY LEADING SPACES
20$:	CLR	R3		;MSB ARGUMENT IS ZERO
	MOV	R0,R1		;MOVE LSB TO WHERE WE CAN WORK ON IT

; R1 = LSB OF NUMBER TO BE PRINTED
; R3 = MSB OF NUMBER TO BE PRINTED
; R5 = MINIMUM WIDTH OF COLUMN TO PRINT
;
; DIVIDE THE NUMBER BY 10 (AT LEAST ONCE) UNTIL THE QUOTIENT IS ZERO,
; AND PUSH THE REMAINDERS ON THE STACK.  THESE ARE THE DIGITS OF THE
; NUMBER'S DECIMAL REPRESENTATION, FROM RIGHT TO LEFT.
; R4 WILL COUNT THE DIGITS PUSHED.

30$:	MOV	#TYPE,80$	;OUTPUT BY TYPING
40$:	CLR	R4		;NO DIGITS PUSHED YET
	CLR	R2		;HIGH-HIGH ORDER = 0
	ASL	R1		;KEEP ONLY 15 BITS IN LOW WORD
	ROL	R3		;OVERFLOW INTO HIGH WORDS
	ROL	R2
	ROR	R1		;LOW WORD IS KEPT RIGHT-JUSTIFIED
50$:	DIV	#10.,R2		;DIVIDE MSB IN R3, BY 10.  Q -> R2, R -> R3
	MOV	R3,R0		;REMAINDER < 10 IS HIGH WORD FOR NEXT DIV
	MOV	R2,R3		;QUOTIENT IS USED NEXT TIME THRU LOOP
	CLR	R2		;HIGH-HIGH IS ZERO NEXT TIME
	ASL	R1		;LEFT-ADJUST 15-BIT LSB
	ASHC	#-1,R0		;TO PACK SO QUOTIENT FITS IN 15 BITS
	DIV	#10.,R0		;DIVIDE LSB BY 10. Q -> R0, R -> R1
	MOV	R1,-(SP)	;PUSH THE REMAINDER (IT'S A DIGIT)
	INC	R4		;COUNT DIGITS PUSHED
	MOV	R0,R1		;QUOTIENT IS USED NEXT TIME THRU LOOP
	BIS	R3,R0		;IS ENTIRE NUMBER NOW ZERO?
	BNE	50$		;REPEAT UNTIL IT IS ZERO
	SUB	R4,R5		;WIDTH - DIGITS => NUMBER OF LEADING BLANKS
	BLOS	70$		;NO SPACES IF DIGITS >= COLUMN SIZE
	MOV	#SPACE,R2
60$:	CALL	TYPE		;TYPE SPACES
	SOB	R5,60$		;REPEATEDLY

; UNSTACK AND PRINT THE DIGITS (WE KNOW THERE'S AT LEAST ONE)

70$:	MOV	(SP)+,R2	;UNSTACK A DIGIT
	ADD	#'0,R2		;MAKE ASCII
	CALL	@(PC)+		;EMIT IT
80$:	 .WORD	TYPE		;ROUTINE IS TYPE OR BYTE MOVER
	SOB	R4,70$		;REPEAT
	RETURN

.SBTTL	DECSTR:	CONVERT TO DECIMAL AND STORE STRING IN MESSAGE
;+
; DECSTR - CONVERT TO DECIMAL AND STORE STRING IN MESSAGE
;
;	R0 =  NUMBER TO PRINT
;	R1 -> 6-BYTE AREA TO STORE STRING, PADDED WITH 176'S
;
;	CALL	DECSTR
;-

DECSTR::REGSCR			;SAVE REGISTERS
	MOV	R1,110$		;SAVE STARTING ADDRESS FOR OUTPUT
	MOV	#6,R5		;COUNT SIX BYTES TO FILL
90$:	MOVB	#176,(R1)+	;PRE-FILL WITH IGNORE CHARACTERS
	SOB	R5,90$		; AND DON'T DO FILLS
	;CLR	R5		;NO LEFT-BLANKS
	CLR	R3		;MSB ARGUMENT IS ZERO
	MOV	R0,R1		;MOVE LSB TO WHERE WE CAN WORK ON IT
	MOV	#100$,80$	;CALL BYTE MOVER, NOT BYTE TYPER
	BR	40$		;ENTER MAIN LOOP

100$:	MOVB	R2,@(PC)+	;OUTPUT A BYTE
110$:	 .WORD	0		; TO THE CALLER'S STRING
	INC	110$		;NEXT BYTE
	RETURN

.DSABL	LSB

.SBTTL	PRINT A FILE NAME FROM THE FIRQB

;+
; TYPFIL - PRINT FILE NAME FROM FIRQB
;
;	R4 -> FIRQB
;
;	CALL	TYPFIL
;-

.ENABL	LSB

TYPFIL::REGSCR			;SAVE REGISTERS
	ADD	#FQNAM1,R4	;POINT TO NAME
	MOV	(R4)+,R0	;GET NAME PART 1
	CALL	10$		;PRINT IT
	MOV	(R4)+,R0	;NAME PART 2
	CALL	10$		;PRINT IT
	MESSAGE	<".">		;DOT
	MOV	(R4)+,R0	;EXTENSION
	BR	10$		;PRINT IT AND RETURN

.SBTTL		RAD50 PRINTERS
.SBTTL	RADPRT:	PRINT RAD50 WORD
.SBTTL	RADZER:	PRINT RAD50 WORD WITH BLANKS SUPPRESSED
.SBTTL	RADCNV: CONVERT RAD50 WORD TO ASCII

;+
; RADPRT - PRINT RAD50 WORD
; RADZER - PRINT RAD50 WORD W/ BLANKS SUPPRESSED
; RADCNV - CONVERT RAD50 WORD TO ASCII
;
;	R0 =  RAD50 WORD
;	R4 -> LOCATION TO STORE ASCII STRING (IF CALL = RADCNV)
;
;	CALL	RAD???
;-

RADCNV::REGSCR			;SAVE REGISTERS
	MOV	#-1,R2		;SET FLAG FOR CONVERSION TO ASCII
	MOV	#SPACE,R5	;FILLER IS SPACE FOR 0
	BR	30$

RADPRT::REGSCR			;SAVE REGISTERS
	MOV	#SPACE,R5	;FILLER IS SPACE FOR 0
	BR	20$

RADZER::REGSCR			;SAVE REGISTERS
10$:	CLR	R5		;SUPPRESS SPACES
20$:	CLR	R2		;SET FLAG FOR NO CONVERSION TO ASCII
30$:	MOV	R2,-(SP)	;PUT FLAG ON THE STACK
	MOV	#110$,R1	;POINT TO TABLE OF DIVISORS
	MOV	R0,R3		;COPY THE WORD TO PRINT
40$:	CLR	R2		;CLEAR FOR DIVIDE
	DIV	(R1)+,R2	;DIVIDE
	;TST	R2		;IS THE RESULT A SPACE? (FROM DIVIDE)
	BNE	50$		;NO
	MOV	R5,R2		;YES, MAKE IT BLANK (MAYBE)
	BEQ	90$		;NO, IGNORE NULLS
	BR	70$		;YES, PRINT IT

50$:	CMP	R2,#26.		;ALPHABETIC?
	BHI	60$		;NO
	ADD	#'A-1,R2	;YES, MAKE IT ASCII
	BR	70$		;AND TYPE IT

60$:	MOVB	100$-27.(R2),R2	;GET SPECIAL CHARACTER OR DIGIT
70$:	TST	(SP)		;SEE IF WE ARE TYPING OR CONVERTING
	BEQ	80$		;WE ARE TYPING, SO CALL THE TYPER
	MOVB	R2,(R4)+	;CONVERTING, STORE THIS CHARACTER
	BR	90$		;DO END OF LOOP TEST

80$:	CALL	TYPE		;TYPE IT AND RETURN
90$:	TST	(R1)		;ANY MORE TO DO?
	BNE	40$		;YES, LOOP ON IT
	TST	(SP)+		;REMOVE FLAG FROM STACK
	RETURN

	I.MESS
100$:	.ASCII	"$.?0123456789"	;RAD50 TRANSLATION FOR 27.-39.
	UNORG

110$:	.WORD	50*50,50,1,0	;DIVISORS FOR RADIX 50 CONVERSION

.DSABL	LSB

.SBTTL		OCTAL & DECIMAL INPUTTERS
.SBTTL	OCTINP:	TRANSLATE AN OCTAL NUMBER
.SBTTL	DECINP:	TRANSLATE A DECIMAL NUMBER

;+
; OCTINP - TRANSLATE AN OCTAL NUMBER
; DECINP - TRANSLATE A DECIMAL NUMBER
;
;	R1 -> STRING TO TRANSLATE
;
;	CALL ???INP
;
;	R0 = VALUE
;	R1 = UPDATED POINTER
;	CONDITION CODES SET FROM TSTB OF ENDING CHARACTER
;		(Z=1 MEANS NULL BYTE, USUALLY DESIRED)
;
;	SCAN STOPS ON CHARACTER ILLEGAL FOR SPECIFIED RADIX OR
;		IF OVERFLOW IS ENCOUNTERED
;-

OCTINP::TST	(PC)+		;CLEAR CARRY
DECINP::SEC			;SET CARRY
	REGSAV			;SAVE REGISTERS
	MOV	#4,R5		;R5 = RADIX/2
	ADC	R5		;10. IF ENTERED AT DECINP
	ASL	R5		;R5 = RADIX
	CLR	R3		;CLEAR THE ACCUMULATOR
10$:	MOVB	(R1)+,R0	;GET NEXT BYTE
	SUB	#'0,R0		;CONVERT FROM ASCII
	CMP	R0,R5		;CHECK AGAINST RADIX
	BHIS	20$		;TOO BIG TO BE A DIGIT
	MOV	R3,R2		;PUT OLD VALUE WHERE WE CAN MULTIPLY
	MUL	R5,R2		;PRODUCT MSB -> R2, LSB -> R3
	TST	R2		;DID ANY HIGH-ORDER BITS COME ON?
	BNE	20$		;YES -- UNSIGNED OVERFLOW
	ADD	R0,R3		;ADD IN NEW DIGIT
	BCC	10$		;GOOD, GO FOR ANOTHER BYTE
20$:	MOV	R3,TOS.R0(SP)	;RETURN VALUE IN R0
INPDNE:	MOV	R1,TOS.R1(SP)	;RETURN UPDATED POINTER IN R1
	CALLX	REGRES,R5	;RESTORE REGISTERS
	TSTB	-(R1)		;POINT TO UNUSED CHAR, SET CONDITION CODES
	RETURN

.SBTTL		DOUBLE PRECISION DECIMAL INPUTTER
.SBTTL	DBLINP:	SCAN OFF A DOUBLE PRECISION DECIMAL NUMBER

;+
; DBLINP - SCAN OFF A DOUBLE PRECISION DECIMAL NUMBER
;
;	R1 -> STRING TO SCAN
;
;	CALL DBLINP
;
;	R1 -> FIRST UNSCANNED BYTE
;	R2 =  VALUE (LSB)
;	R3 =  VALUE (MSB)
;	CONDITION CODES SET FROM TSTB OF ENDING CHARACTER
;		(Z=1 MEANS NULL BYTE, USUALLY DESIRED)
;
;	SCAN STOPS ON CHARACTER ILLEGAL FOR SPECIFIED RADIX OR
;		IF OVERFLOW IS ENCOUNTERED
;-

DBLINP::REGSAV			;SAVE REGISTERS
	CLR	R2		;CLEAR ACCUMULATOR
	CLR	R3
	CLR	-(SP)		;ALLOCATE SPACE FOR DIGIT
10$:	MOVB	(R1)+,(SP)	;GET A DIGIT
	SUB	#'0,(SP)	;REDUCE ASCII DIGITS TO RANGE 0-9
	MOV	#9.,R0		;SET COUNTER FOR ADD LOOP BELOW
	CMP	(SP),R0		;IS THE CHARACTER LEGAL?
	BHI	30$		;NO -- RETURN
	MOV	R3,R5		;COPY PARTIAL RESULT FOR ADDING
	MOV	R2,R4
20$:	ADD	R4,R2		;ADD LSB
	ADC	R3
	BCS	30$		;SKIP OUT ON UNSIGNED OVERFLOW
	ADD	R5,R3		;ADD MSB
	BCS	30$		;SKIP OUT ON UNSIGNED OVERFLOW
	SOB	R0,20$		;ADD 9 TIMES TO MAKE 10X TOTAL
	ADD	(SP),R2		;ADD THE DIGIT
	ADC	R3
	BCC	10$		;GET THE NEXT DIGIT
30$:	TST	(SP)+		;REMOVE TEMP SPACE FROM STACK
	MOV	R2,TOS.R2(SP)	;SAVE ON STACK TO RETURN IN REGISTERS
	MOV	R3,TOS.R3(SP)
	BR	INPDNE		;GO RETURN PROPERLY

.SBTTL		RAD50 INPUTTER
.SBTTL	RADINP:	SCAN AND CONVERT 2 WORDS OF RADIX 50
.SBTTL	RADWRD:	SCAN AND CONVERT 1 WORD  OF RADIX 50

;+
; RADINP - SCAN AND CONVERT 2 WORDS OF RADIX 50
; RADWRD - SCAN AND CONVERT 1 WORD  OF RADIX 50
;
;	R1 -> STRING TO SCAN
;
;	CALL	RAD???
;
;	R0 =  FIRST 3 CHARACTERS
;	R1 -> FIRST UNSCANNED CHARACTER
;	R3 =  NEXT 3 CHARACTERS IFF RADINP
;
;	SCAN STOPS AT FIRST NON-RAD50 CHARACTER OR AFTER 3 (OR 6)
;		CHARACTERS HAVE BEEN SCANNED
;	ONLY LETTERS AND DIGITS ARE ALLOWED
;-

.ENABL	LSB

RADINP::REGSCR			;SAVE REGISTERS
	CALL	RADWRD		;GET A WORD
	MOV	R0,TOS.R0(SP)	;RETURN IT IN R0 ON EXIT
	CALL	RADWRD		;GET ANUDDER
	MOV	R0,TOS.R3(SP)	;RETURN IT IN R3 ON EXIT
	BR	10$		;AND EXIT

RADWRD::REGSCR			;SAVE REGISTERS
	CLR	R3		;CLEAR RETURN VALUE
	MOV	#20$,R5		;A HANDY POINTER
	CALL	(R5)		;GET 3 CHARACTERS
	CALL	(R5)
	CALL	(R5)
	MOV	R3,TOS.R0(SP)	;RETURN ANSWER IN R0 ON EXIT
10$:	MOV	R1,TOS.R1(SP)	;UPDATE R1
	RETURN

; SUBROUTINE TO INPUT A SINGLE RAD50 CHARACTER, AND ADD IT TO
; THE WORD IN R3.  AFTER FINDING A NON-RAD50 CHARACTER, THE
; SUBROUTINE ADDS SPACES WHEN IT IS CALLED.

20$:	MOVB	(R1)+,R0	;GET A CHARACTER
	SUB	#'0,R0		;REDUCE DIGITS TO RANGE 0-9
	CMP	R0,#9.		;IS THIS ONE?
	BHI	30$		;NO -- IT MUST BE A LETTER
	ADD	#30.,R0		;YES -- RAD50 DIGITS ARE 30.-39.
	BR	50$		;GO ACCUMULATE

30$:	ADD	#'0-'A+1,R0	;REDUCE LETTERS TO RANGE 1-26.
	BEQ	40$		;ZERO IS ILLEGAL
	CMP	R0,#26.		;IS THIS A LETTER?
	BLOS	50$		;YES -- GO ACCUMULATE

40$:	DEC	R1		;LEAVE R1 POINTING AT THE BAD CHARACTER
	CLR	R0		;AND USE A SPACE INSTEAD
50$:	MUL	#50,R3		;'SHIFT LEFT' THE OLD VALUE
	ADD	R0,R3		;AND ADD IN THE NEW CHARACTER
	RETURN			;EXIT

.DSABL	LSB

.SBTTL		DATE AND TIME INPUTTER
.SBTTL	DATINI:	SET INITIAL DATE

.ENABL	LSB

DATINI::.PRIV			;GET DATE FROM MONITOR.
	.DATE
	MOV	XRB,I.DATE	;GET DATE
	MOV	XRB+2,I.TIME	; AND TIME
	MOVB	XRB+4,I.SEC	; AND SECONDS UNTIL NEXT MINUTE
	RETURN			;THAT'S ALL

10$:	SEC			;SET CARRY FOR ERROR RETURNED BELOW
	RETURN

CKDATE::
20$:	CALLX	DECINP		;GET THE DAY
	CMPB	(R1),#'.	;NUMERIC DATE?
	BNE	30$		;NOPE, IT BETTER BE ALPHABEITC
	INC	R1		;YES, SKIP THE DOT
	MOV	R0,R2		;SAVE THE YEAR NUMBER
	CALLX	DECINP		;PARSE THE MONTH
	CMP	R0,#12.		;LEGAL MONTH?
	BHI	10$		;NO
	MOV	R0,R5		;YES, COPY IT
	BEQ	10$		;ZERO IS ILLEGAL, TOO
	ASL	R5		;COMPUTE MONTH
	ASL	R5		; * 4
	ADD	#MONTHS+1-4,R5	;POINT TO MONTH NAME FOR LOOP BELOW
	CMPB	(R1)+,#'.	;SEPARATOR CORRECT?
	BNE	10$		;NO, ERROR
	CALLX	DECINP		;YES, PARSE DAY
	BNE	10$		;NOT END OF LINE, THAT'S AN ERROR
	MOV	R0,R3		;COPY THE DAY
	MOV	R2,R0		;RECOPY YEAR BACK
	BR	40$		;GO CHECK RANGES AND DO IT

30$:	MOV	R0,R3		;COPY THE DAY
	CMPB	(R1),#'-	;CHECK FOR DELIMITER
	BNE	10$		;NO GOOD
	MOV	R1,R5		;COPY POINTER TO MONTH NAME
	ADD	#4,R1		;SKIP OVER IT FOR NOW
	CMPB	(R5)+,(R1)+	;IS THIS ALSO THE RIGHT DELIMITER?
	BNE	10$		;NO
	CALLX	DECINP		;OK, GET THE YEAR NUMBER
	;BNE	10$		;(DIDN'T END ON A NULL) <- WHO CARES?
40$:	CALL	FEBCHK		;FIX LENGTH OF FEB
	CMP	R0,#99.		;WE'LL LIMIT IT TO THE 20TH CENTURY
	BHI	10$		;NO DICE
	CMP	R0,#76.		;WE ALSO LIMIT IT TO 1976 OR LATER
	BLO	10$		;NO DICE
	SUB	#70.,R0		;REDUCE DATE TO RELATIVE 1970
	MUL	#1000.,R0	; AND MAKE IT YEAR * 1000 IN R1, R0=0
	TST	R3		;IS THE DAY IMPOSSIBLE?
	BLE	10$		;YES, EVIL
	MOV	#MONTHS-2,R2	;POINT TO TABLE OF MONTH NAMES
50$:	ADD	R0,R1		;ADD LENGTH OF SKIPPED MONTH INTO DATE
	CMPB	(R2)+,(R2)+	;SKIP THE PREVIOUS MONTH
	MOVB	(R2)+,R0	;GET MONTH LENGTH
	BEQ	10$		;OOPS, NO GOOD NAME
	CMPB	(R5),(R2)+	;IS THIS THE RIGHT MONTH?
	BNE	50$		;NO
	CMPB	1(R5),(R2)	;2ND CHARACTER MATCH?
	BNE	50$		;NO
	CMPB	2(R5),1(R2)	;3RD?
	BNE	50$		;NO
	CMP	R3,R0		;IS THE DAY TOO BIG FOR US?
	BHI	10$		;YES
	ADD	R3,R1		;NO, ADD IT INTO THE DAY OF THE YEAR
	RETURN			;RETURN WITH CARRY CLEAR

FEBCHK:	MOVB	#29.,MONFEB	;ASSUME IT'S LEAP YEAR
	BIT	#3,R0		;IS THE YEAR A MULTIPLE OF 4?
	BEQ	60$		;YES, IT REALLY LEAPS
	DECB	MONFEB		;NO, IT'S 28 DAYS
60$:	RETURN

	I.MESS
MONTHS:	.ASCII	<31.>"JAN"
MONFEB:	.ASCII	<28.>"FEB"<31.>"MAR"<30.>"APR"<31.>"MAY"<30.>"JUN"<31.>"JUL"
	.ASCIZ	<31.>"AUG"<30.>"SEP"<31.>"OCT"<30.>"NOV"<31.>"DEC"
	UNORG
.DSABL	LSB

.SBTTL	DATSTR: PUT AN ALPHANUMBERIC DATE IN A STRING
.SBTTL	DATPRT: PRINT THE CURRENT DATE
.SBTTL	PRTDAT:	PRINT A SPECIFIED DATE
.SBTTL	TIMPRT:	PRINT THE CURRENT TIME
.SBTTL	PRTTIM:	PRINT A SPECIFIED TIME

;+
;
; DATSTR - PUT A SPECIFIED DATE IN A SPECIFIED 9-BYTE STRING
; DATPRT - PRINT THE CURRENT DATE
; PRTDAT - PRINT A SPECIFIED DATE
; TIMPRT - PRINT THE CURRENT TIME
; PRTTIM - PRINT A SPECIFIED TIME
;
;	R0 -> 9-BYTE BUFFER (DATSTR ONLY)
;	R1 =  DESIRED DATE OR TIME
;
;	CALL	DATSTR
;
;	R1 IS ALWAYS RETURNED WITH THE INTERNAL DATE OR TIME JUST
;	PRINTED.  ALL OTHER REGISTERS ARE PRESERVED.
;-
.ENABL	LSB

DATSTR::MOV	R2,-(SP)	;SAVE SOME REGISTERS
	MOV	R1,-(SP)	;
	MOV	R0,-(SP)	;R0 MUST BE ON THE TOP OF THE STACK!!!
	CALL	ZAPFQB		;CLEAR THE FIRQB FOR RETURN DATE UUO CALL
	MOV	R1,FIRQB+4	;SAVE THE DATE SPECIFIED
	CALL	40$		;DO THE CONVERSION
	MOV	#9.,R2		;FILL THE BUFFER WITH IGNORABLE
10$:	MOVB	#176,(R0)+	; CHARACTERS FOR PADDING
	SOB	R2,10$
	MOV	(SP),R0		;RESTORE BUFFER POINTER
	MOV	#FIRQB+10,R1	;R1 POINTS TO RETURNED STRING
	MOV	#9.,R2		;COPY UP TO 9 CHARACTERS
20$:	MOVB	(R1)+,(R0)+	;RETURNED STRING IS ASCIZ
	TSTB	(R1)		;IS THE NEXT CHAR NULL?
	BEQ	30$		; YES, SO DONE
	SOB	R2,20$		;TRY AGAIN
30$:	MOV	(SP)+,R0	;RESTORE...
	MOV	(SP)+,R1
	MOV	(SP)+,R2
	RETURN

DATPRT::MOV	I.DATE,R1	;USE CURRENT DATE
PRTDAT::CALL	ZAPFQB		;DATE WAS PASSED IN R1
	MOV	R1,FIRQB+4	;STORE DATE FOR .UUO CALL
	CALL	40$		;DO THE UUO
	CALL	MESSAG,R5,<FIRQB+10> ;PRINT IT
	RETURN

TIMPRT::MOV	I.TIME,R1	;USE CURRENT TIME
PRTTIM::CALL	ZAPFQB		;TIME WAS PASSED IN R1
	MOV	R1,FIRQB+22	;STORE TIME FOR .UUO CALL
	CALL	40$		;DO IT
	CALL	MESSAG,R5,<FIRQB+26> ;PRINT IT
	RETURN

40$:	MOVB	#UU.CNV,FIRQB+FQFUN
	.PRIV,	.UUO
	RETURN

.DSABL	LSB

.SBTTL	ROUTINES TO MAINTAIN AUXILIARY SAT BUFFER

.ENABL	LSB

;+
; GETSB2 - GET A BYTE FROM THE AUXILIARY SAT BUFFER
;
;	MOV	OFFSET,-(SP)	;WHERE OFFSET IS 0 TO 17777
;
;	CALL	GETSB2
;
;	(SP) CONTAINS THE BYTE FROM THE AUXILIARY BUFFER
;		IF THE OFFSET IS EVEN, A FULL WORD IS FETCHED
;-

GETSB2::CALL	SETSB2		;SET UP THE MMU
	ADD	#SCRBUF,2(SP)	;RELOCATE OFFSET TO BE MAPPED
	MOV	2(SP),SB2ADR	;SAVE THE ADDRESS FOR FUTURE PUTSB2 CALL
	BIT	#1,2(SP)	;WORD OFFSET?
	BNE	10$		;NO
	MOV	@2(SP),2(SP)	;YES, GET A WHOLE WORD
	RETURN

10$:	MOVB	@2(SP),2(SP)	;REPLACE ADDRESS WITH BYTE OF DATA
	RETURN

;+
; PUTSB2 - PUT A BYTE TO THE AUXILIARY SAT BUFFER
;
;	MOV	DATA,-(SP)	;PUT BYTE OF DATA ON THE STACK
;
;	CALL	PUTSB2
;
;	THE DATA BYTE IS POPPED FROM THE STACK AND REPLACES THE
;		BYTE MOST RECENTLY FETCHED BY GETSB2
;-

PUTSB2::CALL	SETSB2		;SET UP THE MMU
	MOVB	2(SP),@SB2ADR	;REPLACE THE BYTE OF DATA
	MOV	(SP)+,(SP)	;DUMP THE DATA BYTE
	MOVB	#-1,GOTSB2	;FLAG CHANGE HAS BEEN MADE
	RETURN

.ENABL	LSB
;+
; SAVSAT - COPY SATBUF TO THE AUXILIARY SAT BUFFER (DISK WORK-FILE)
;
;	CALL	SAVSAT
;-

SAVSAT::MOV	#SATBUF,XRB+XRLOC ;SAVE REGISTERS
	CALLR	20$

;+
; RESSAT - RESTORE SATBUF FROM AUXILIARY SAT BUFFER (DISK OR SCRBUF)
;
;	CALL	RESSAT
;-

RESSAT::TSTB	GOTSB2		;IS SATBF2 'MAPPED'?
	BEQ	10$		;NO
	REGSCR			; YES, SAVE SOME REGISTERS
	MOV	#SCRBUF,R0	;COPY FROM SCRBUF
	MOV	#SATBUF,R1	; TO SATBUF
	MOV	#SATLEN/2,R2	;COPY ALL OF IT
	CALLR	BLKMOV		;GO DO IT

10$:	MOV	#SATBUF,XRB+XRLOC ;RESTORE SATBUF FROM THE WORK-FILE
	CALLR	30$		;GO GET IT

RSTSB2::TSTB	GOTSB2		;IS SATBF2 'MAPPED'?
	BEQ	40$		; NO, SO DO NOTHING
	BLT	15$		;IT'S MAPPED AND CHANGED, SO SAVE IT
	CLRB	GOTSB2		;MAPPED, BUT NO CHANGE -- NO SWEAT
	BR	40$		;NOW ITS NOT MAPPED
15$:	CALL	60$		;ELSE SAVE THE OLD XRB
	MOV	#SCRBUF,XRB+XRLOC ;WRITE TO DISK FROM SCRBUF
	CALLR	20$

;+
; SETSB2 - MAP THE AUXILIARY SAT BUFFER
;
;	CALL	SETSB2
;
; NOTE - CALLER MUST CALL RSTSB2 TO TURN OFF MMU WHEN DONE
;	 CALLER MAY NOT DO I/O WHILE AUXILIARY BUFFER IS MAPPED
;-

SETSB2::TSTB	GOTSB2		;ARE WE THERE ALREADY?
	BNE	40$		; YES, SO DO NOTHING
	INCB	GOTSB2		;ELSE WE WILL BE SOON
	CALL	60$		;SAVE THE OLD XRB
	MOV	#SCRBUF,XRB+XRLOC ;MAP SATBF2 INTO SCRBUF
	CALLR	30$		;GO GET IT

20$:	MOV	R0,-(SP)	;WRITE SATBF2 TO THE WORK-FILE
	MOV	#XRB,R0		;BUFFER ADDRESS MUST BE PRE-SET @XRB+XRLOC
	MOV	#SATLEN,(R0)+	;XRB+XRLEN
	MOV	#SATLEN,(R0)+	;XRB+XRBC
	TST	(R0)+		;SKIP XRB+XRLOC
	MOV	#WRKCHN,(R0)+	;XRB+XRCI
	;CLRB	XRB+XRBLKM
	MOV	#1,(R0)+	;XRB+XRBLK
	CLR	(R0)+		;XRB+12
	CLR	(R0)+		;XRB+XRMOD
	.PRIV,	.WRITE		;DO IT
	MOVB	FIRQB,IOERR	;ANY ERRORS?
	BNE	50$		;YES
	CLRB	GOTSB2		;ELSE SAY SATBF2 IS GONE
	MOV	(SP)+,R0	;RESTORE R0
	CALL	70$		;RESTORE THE XRB
	RETURN

30$:	MOV	R0,-(SP)	;READ SATBF2 FROM THE WORK-FILE
	MOV	#XRB,R0		;BUFFER ADDRESS MUST BE PRE-SET @XRB+XRLOC
	MOV	#SATLEN,(R0)+	;XRB+XRLEN
	CLR	(R0)+		;XRB+XRBC
	TST	(R0)+		;SKIP XRB+XRLOC
	MOV	#WRKCHN,(R0)+	;XRB+XRCI
	;CLRB	XRB+XRBLKM
	MOV	#1,(R0)+	;XRB+XRBLK
	CLR	(R0)+		;XRB+XRTIME
	CLR	(R0)+		;XRB+XRMOD
	.PRIV,	.READ		;DO IT
	MOVB	FIRQB,IOERR	;ANY ERRORS?
	BNE	50$		; YES
	MOV	(SP)+,R0	;RESTORE R0
	CALL	70$		;RESTORE THE XRB
40$:	RETURN

50$:	CALL	PRTERF
	MESSAG	<"in Work-file">
	CALL	TYPERR
	ERF

60$:	MOV	R0,-(SP)	;SAVE SOME REGISTERS
	MOV	R1,-(SP)
	MOV	R2,-(SP)
	MOV	#XRB,R0		;COPY FROM XRB
	MOV	#TMPXRB,R1	; TO TMPXRB
	BR	80$		;GO DO IT

70$:	MOV	R0,-(SP)	;SAVE SOME REGISTERS
	MOV	R1,-(SP)
	MOV	R2,-(SP)
	MOV	#TMPXRB,R0	;COPY FROM TMPXRB
	MOV	#XRB,R1		; TO XRB
80$:	MOV	#XRBSIZ/2,R2	;COPY ALL OF IT
	CALL	BLKMOV		;GO DO IT
	MOV	(SP)+,R2	;RESTORE REGS
	MOV	(SP)+,R1
	MOV	(SP)+,R0
	RETURN

.DSABL	LSB
	TMPORG	ONLCTL
SB2ADR:	.WORD	0		;SAVE ADDRESS FROM GETSB2
	UNORG

.SBTTL	RESRPC:	RESTORE ALL REGISTERS AND RETURN
;+
; RESRPC - RESTORE ALL REGISTERS AND RETURN
;
; CALL:	  JMP	RESRPC
;-

RESRPC::CALL	REGRES,R5	;RESTORE R0 THROUGH R5
	RETURN

.SBTTL	ROUTINES FOR PEEKING AND POKING IOBUFF

;+
; GETIOB - GET A WORD FROM THE HIGH MEMORY I/O BUFFER
;
;	MOV	OFFSET,-(SP)	;WHERE OFFSET IS 0 TO 8196.
;
;	CALL	GETIOB
;
;	(SP) CONTAINS THE WORD FROM IOBUFF.
;-

.ENABL	LSB

GETIOB::MOV	2(SP),-(SP)	;MAKE A COPY OF THE OFFSET
	CALL	20$		;MAP THE I/O BUFFER
	MOV	@(SP)+,2(SP)	;FETCH THE DATA
	BR	10$		;AND UNMAP THE BUFFER

;+
; PUTIOB - PUT A WORD INTO THE HIGH MEMORY I/O BUFFER
;
;	MOV	OFFSET,-(SP)	;WERE OFFSET IS 0 TO 8196.
;	MOV	DATA,-(SP)	;DATA IS WHAT TO PUT IN THE BUFFER
;
;	CALL	PUTIOB	
;
;	(SP) CONTAINS THE OFFSET
;+

PUTIOB::MOV	4(SP),-(SP)	;MAKE A COPY OF THE OFFSET
	CALL	20$		;MAP THE I/O BUFFER
	MOV	4(SP),@(SP)+	;JAM IN THE DATA
	MOV	(SP)+,(SP)	;AND REMOVE THE DATA FROM THE STACK
10$:	;CLR	@#MMUSR0	;TURN OFF MEMORY MANAGEMENT
	RETURN	

20$:	;CALL	KPARSU		;SET UP KERNEL MAPPING
	;CMP	2(SP),#4096.*2	;FIRST 4K PAGE OF I/O BUFFER?
	;BLT	30$		;YES, MAP IT IN
	;SUB	#4096.*2,2(SP)	;NO, CHANGE OFFSET TO SECOND PAGE
	;MOV	#2200,@#KISAR6	;AND MAP IN SECOND PAGE
	;BR	40$		;TURN ON MEMORY MANAGEMENT
30$:	;MOV	#2000,@#KISAR6	;SET MAPPING FOR FIRST PAGE OF IOBUFF
40$:	ADD	#IOBUFF,2(SP)	;MAKE (SP) -> BUFFER WORD
	;MOV	#1,@#MMUSR0	;TURN ON MEMORY MANAGEMENT
	RETURN

.DSABL	LSB

;+
; REGSCR - SAVE ALL REGISTERS ON STACK AND SET UP CO-ROUTINE EXIT.
;
;	REGSCR
;
;	-OR-
;
;	CALL	REGSCR,R5
;
; NOTE: THE REGSCR MACRO DEFINES THE SYMBOLS:
;		TOS.R0,TOS.R1,...,TOS.R5,TOS.RA
;	TO BE TO SP STACK OFFSETS TO GET AT THOSE REGISTERS.
;-

SAVREG::			;HISTORICAL ENTRY POINT
REGSCR::MOV	R4,-(SP)	;SAVE R4,
	MOV	R3,-(SP)	; AND R3,
	MOV	R2,-(SP)	;  AND R2,
	MOV	R1,-(SP)	;   AND R1,
	MOV	R0,-(SP)	;    AND R0
	MOV	R5,-(SP)	;SAVE RETURN ADDRESS ON STACK
	MOV	6*2(SP),R5	;NOW RESTORE THE REAL R5 VALUE
	CALL	@(SP)+		;NOW CALL OUR CALLER
	MOV	(SP)+,R0	;RESTORE R0,
	MOV	(SP)+,R1	; AND R1,
	MOV	(SP)+,R2	;  AND R2,
	MOV	(SP)+,R3	;   AND R3,
	MOV	(SP)+,R4	;    AND R4,
	MOV	(SP)+,R5	;     AND R5
	RETURN			;NOW RETURN


.SBTTL	REGISTER SAVE/RESTORE

;+
; REGSAV - SAVE ALL REGISTERS ON STACK.
;
;	REGSAV
;
;	-OR-
;
;	CALL	REGSAV,R5
;
; NOTE: THE REGSAV MACRO DEFINES THE SYMBOLS:
;		TOS.R0,TOS.R1,...,TOS.R5,TOS.PC,TOS.PS
;	TO BE TO SP STACK OFFSETS TO GET AT THOSE REGISTERS.
;-

REGSAV::MOV	R4,-(SP)	;SAVE R4,
	MOV	R3,-(SP)	; AND R3,
	MOV	R2,-(SP)	;  AND R2,
	MOV	R1,-(SP)	;   AND R1,
	MOV	R0,-(SP)	;    AND R0
	MOV	5*2(SP),-(SP)	;REPLICATE SAVED R5
	RETURN	R5		;AND EXIT

;+
; REGRES - RESTORE ALL REGISTERS FROM STACK.
;
;	CALL	REGRES,R5
;-

REGRES::MOV	(SP)+,R0	;DUMMY TO REMOVE SAVED R5
	MOV	(SP)+,R0	;RESTORE R0,
	MOV	(SP)+,R1	; AND R1,
	MOV	(SP)+,R2	;  AND R2,
	MOV	(SP)+,R3	;   AND R3,
	MOV	(SP)+,R4	;    AND R4
	RETURN	R5		;RESTORE R5 AND EXIT


.SBTTL	BBLOK:	GET BAD BLOCKS (DUMMY ROUTINE)

.ENABL	LSB
BBLOK::	ERF	<"Illegal call to BBLOK">

.SBTTL	GBOOT:	GET A BOOTSTRAP (DUMMY ROUTINE, FOR NOW...)

GBOOT::	CALLRX	GGBOOT		;GET THE BOOT
ONLBOR::CALLRX	BOORET		;GO BACK TO SAVRES

.DSABL	LSB

.SBTTL	UNEXPECTED TRAP

UNXTRP::ERF	<"Unexpected trap">

.SBTTL	CVT$$  - TRIM A STRING
;+
; CVT$$  - TRIM A STRING
; CVT$$A - TRIM EVERYTHING OFF A STRING
;
; CALL:	R0 = TRIM MASK (IF CVT$$)
;	R5 -> ASCIZ STRING
;	CALL	CVT$$?
;
; BACK:	R5 -> ASCIZ STRING (MAY BE SHORTER) AT SAME PLACE
;	MASK	TRIMS
;	   1	DISCARD ALL PARITY BITS
;	   2	DISCARD ALL SPACES & TABS
;	   4	DISCARD CR LF FF ESC RO
;	  10	DISCARD LEADING SPACES & TABS
;	  20	REDUCE SPACES & TABS TO A SINGLE SPACE
;	  40	CONVERT LC TO UC
;	 100	CONVERT [ TO ( AND ] TO )
;	 200	DISCARD TRAILING SPACES & TABS
;	 400	PRESERVE QUOTED SUBSTRINGS
;	1000	MODIFY 4 (IF ON) TO DISCARD ALL CHARACTERS < 40 OR =177
;-
.ENABL	LSB

CVT$$A::CALLX	SAVREG,R5	;THIS ENTRY TRIMS THE WORLD
	MOV	#-1,R0		;SET FLAG WORD TO TRIM ALL
	BR	10$

CVT$$::	CALLX	SAVREG,R5	;SAVE REGISTERS
10$:	MOV	R5,R4		;R4 -> OUTPUT STRING
	CLR	-(SP)		;NOT IN QUOTES YET
	MOV	#170$,R1	;TABLE OF THINGS TO CLEAR
	ASH	#7,R0		;SHIFT THE MASK
	BCC	20$		;DUMP ONLY JUNK BYTES
	CLR	R1		;DUMP ALL BYTES < 40 OR =177
20$:	MOVB	(R5)+,R2	;GET A BYTE
	BEQ	130$		;DONE, SO EXIT
	BICB	R0,R2		;TURN OFF PARITY IF DESIRED
	TST	R0		;KEEP QUOTED BYTES?
	BPL	50$		;NO, QUOTES ARE NORMAL
	TSTB	(SP)		;YES, ARE WE WITHIN QUOTES?
	BEQ	30$		;NO
	CMPB	R2,(SP)		;YES, IS THIS THE ENDING QUOTE?
	BNE	120$		;NO
	CLRB	(SP)		;YES, CLEAR THE INSIDE FLAG
	BR	120$		;AND KEEP THE CLOSING QUOTE

30$:	CMPB	R2,#''		;START OF QUOTED STRING?
	BEQ	40$		;YES
	CMPB	R2,#'"		;MAYBE THIS KIND?
	BNE	50$		;NO
40$:	MOVB	R2,(SP)		;YES, START THE QUOTATION
	BR	120$		;AND KEEP THE OPENING QUOTE

50$:	BIT	R0,#4*200	;DISCARD TERMINATORS AND JUNK?
	BEQ	70$		;NO
	MOV	R1,R3		;YES, GET THE LIST POINTER
	BNE	60$		;DISCARD ONLY JUNK
	CMPB	R2,#40		;DISCARD ALL CONTROL CHARACTERS
	BLO	20$		;IT IS CONTROL
	CMPB	R2,#177		;ALSO DUMP RUBOUTS
	BEQ	20$
	BR	70$		;KEEP IT FOR NOW

60$:	CMPB	R2,(R3)+	;DOES THE BYTE MATCH THE LIST?
	BLO	60$		;NO, KEEP CHECKING
	BEQ	20$		;YES, DISCARD IT
	;BHI	70$		;NO, DON'T CHECK FURTHER
70$:	CMPB	R2,#40		;IS THIS A SPACE?
	BEQ	80$		;YES
	CMPB	R2,#11		;NO, MAYBE A TAB
	BNE	90$		;NOPE
80$:	BIT	R0,#2+10*200	;DISCARD ALL AND/OR LEADING ONES?
	BNE	20$		;YES, DISCARD THIS BYTE
	BIT	R0,#20*200	;REDUCE SPACES/TABS?
	BEQ	120$		;NO, JUST OUTPUT IT
	MOVB	#40,R2		;YES, THIS WILL BE A SPACE
	CMP	R4,5*2+2+2(SP)	;HAVE WE OUTPUT ANYTHING YET?
	BEQ	120$		;NO, CONVERT TO A SPACE AND OUTPUT IT
	CMPB	R2,-1(R4)	;YES, IS THE PRECEDING A SPACE?
	BEQ	20$		;IF SO, DISCARD THIS ONE
	BR	120$		;OUTPUT IT

90$:	BIT	R0,#40*200	;CONVERT LC TO UC?
	BEQ	100$		;NO
	CMPB	R2,#'A+40	;IS IT LC ALPHA?
	BLO	100$		;NO
	CMPB	R2,#'Z+40	;MAYBE?
	BHI	100$		;NO
	BICB	#40,R2		;YES, DOWNCASE IT
	BR	120$		;AND OUTPUT UC

100$:	BIT	#100*200,R0	;CONVERT [] TO ()?
	BEQ	120$		;NO
	CMPB	R2,#'[		;YES, IS IT [?
	BEQ	110$		;YES
	CMPB	R2,#']		;IS IT ]?
	BNE	120$		;NO
	DECB	R2		;IT IS ], SO ] = 135-64 = ) = 51
110$:	SUB	#'[-'(,R2	;AND         [ = 133-63 = ) = 50
120$:	MOVB	R2,(R4)+	;OUTPUT ONE BYTE TO NEW STRING
	BIC	#10*200,R0	;TURN OFF LEADING SPACE/TAB
	BR	20$		;LOOP FOR ANOTHER BYTE

130$:	TSTB	(SP)+		;WERE WE INSIDE QUOTES AT THE END?
	BNE	160$		;YES, DON'T TRIM TRAILING STUFF
	ASL	R0		;NO, DO WE DISCARD TRAILING SPACES/TABS?
	BPL	160$		;NO
140$:	MOVB	-(R4),R2	;GET LAST BYTE STORED
	CMP	R4,5*2+2(SP)	;BACK TOO FAR?
	BLO	150$		;YES, RETURN NULL STRING
	CMPB	R2,#40		;NO, IS IT SPACE?
	BEQ	140$		;YES, DISCARD IT
	CMPB	R2,#11		;MAYBE TAB?
	BEQ	140$		;DISCARD TAB
150$:	INC	R4		;KEEP LAST BYTE REMOVED
160$:	CLRB	(R4)+		;SET NULL STOPPER
	RTS	PC

170$:	.BYTE	177,33,15,14,12,0

.DSABL	LSB

.SBTTL	EQU$$,<COMPARE TWO STRINGS>
;+
; EQU$$ - COMPARE TWO STRINGS FOR EQUALITY
;
; CALL:	R5 -> SOURCE STRING
;	CALL	EQU$$,R4,<POINTER TO ASCIZ STRING>
;
; BACK:	IF TARGET STRING MATCHES SOURCE UP TO BUT NOT INCLUDING THE
;	TARGET'S 0 BYTE, R5 IS ADVANCED TO THE FIRST UNMATCHED
;	CHARACTER AND Z=1 (I.E. BEQ FOUND)
;	IF NO MATCH, R5 UNCHANGED AND Z=0 (I.E. BNE NOTEQUAL)
;-
.ENABL	LSB

EQU$$::	MOV	R5,-(SP)	;SAVE R5
	MOV	R0,-(SP)	;SAVE R0
	MOV	(R4)+,R0	;POINT TO STRING TO MATCH
10$:	CMPB	(R0)+,(R5)+	;CHECK A BYTE
	BNE	20$		;FAILURE
	TSTB	(R0)		;END OF MATCH?
	BNE	10$		;NOT YET
	MOV	(SP)+,R0	;YES, RESTORE R0
	CLR	(SP)+		;PURGE OLD R5, SET ZERO
	RETURN	R4		;AND RETURN SUCCESS

20$:	MOV	(SP)+,R0	;RESTORE R0
	MOV	(SP)+,R5	;RESTORE R5
	RETURN	R4		;RETURN NON-ZERO FROM R5

.DSABL	LSB

.SBTTL	Fake first-time boot routines					;011

;+									;011
; These routines are fake versions of the ones in ROOT.MAC.  They're	;011
; here so that online SAVRES will build and work just like offline	;011
; SAVRES...								;011
;									;011
; VBCHK always returns with C-bit clear (saying "this is not a		;011
; first-time boot").							;011
; FSZBOT doesn't do anything at all.					;011

VBCHK::	CLC			;Clear C...				;011
FSZBOT::RETURN			;And go back.				;011

	.END

