TITLE	MOUNT,<SAV/RES MOUNT FILE>,0A,10-MAY-91,JDB/TPT/VAM/JDB/BGN

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY
;+
;
;  002  JDB  07-OCT-82  MODIFIED FOR NEW DISK STRUCTURE		;JDB002
;  003  MNB  13-JAN-83  FIX BOONAM BUG INTRODUCED BY NEW INIT   ;MNB003
;  004  KMF  14-JAN-84  UPDATE FOR 8BIT COMPATIBILITY (UNSET PARITY)
;  005  JDB  25-APR-84  MODIFIED FOR INSTALL OPTION, SOURCE CLEAR	;JDB005
;			1.1.20, FIX ONLINE/OFFLINE INCOMPATIBILITY	;JDB005
;  006  JDB  27-FEB-85  FIXED TS11 PROBLEM ON ID FUNCTION		;JDB006
;  007  JDB  15-MAY-85  Updated for 6250 BPI support			;JDB007
;  008	TPT  18-Jun-85	Updated for 6667 BPI (TK50) support		;TPT008
;  009  VAM  26-Jun-85	Enable mount of new-format bootable tapes	;VAM009
;  010  JDB   8-Jul-85  Fixed density check for new HDS			;JDB010
;  011	JDB  12-Mar-86	Fixed offline SAves to multivolume tapes	;JDB011
;  012  JDB  27-Feb-87  Fixed to recognize units 8-DU.UNC		;JDB012
;  013  BGN  17-Mar-87  Fix online/offline problem			;BGN013
;  014  VAM  29-Jan-88	Allow reboot with full autosize.
;  
;-
.SBTTL	DEFINITIONS AND MACROS

.MACRO	MOVTXT	FROM,TO
.NLIST
	 CALL	MOVTXT,R5
	  .WORD	FROM
	  .WORD	TO
.LIST
.ENDM	MOVTXT

.SBTTL	DEVICE PRINTING MACROS

.MACRO	DECZER	C
.NLIST
.IF NB <C>
	MOVB	C,R0
.ENDC
	CALLX	DECZER
.LIST
.ENDM	DECZER

.MACRO	TYPDEV	C
.NLIST
.IF	NB	<C>
	MOV	C,R4		;SET UP FOR TYPING
.ENDC
	CALL	TYPDEV		;PRINT DEVICE/UNIT/COLON
.LIST
.ENDM	TYPDEV

.SBTTL	MOUNT SWITCH TABLES

	I.DATA
; SWITCH TEXT TO COMPARE AGAINST
MNTSWT:	UNQTXT	<SCR\ATCH>	;/SCRATCH SWITCH
	UNQTXT	<DEN\SITY>	;/DENSITY SWITCH
	.BYTE	0		;END OF LIST
	.EVEN

; BITS TO TEST TO SEE IF SWITCH ALREADY SPECIFIED
MSBIT:	.WORD	SCR		;/SCRATCH SWITCH
	.WORD	DEN		;/DENSITY SWITCH

; DENSITY SWITCH ARGUMENT TEXT TO COMPARE AGAINST
DENARG:	UNQTXT	<800\>		;800 BPI
	UNQTXT	<1600\>		;1600 BPI
	UNQTXT	<6250\>		;6250 BPI				;JDB007
	UNQTXT	<6667\>		;6667 BPI (TK50)			;008
	UNQTXT	<8000\>		;8000 BPI (TK25)			;009
	.BYTE	0		;END OF LIST
	.EVEN

; LEGAL DENSITIES (MUST BE IN LOW TO HIGH ORDER)
DENNUM:	.WORD	800.		;800 BPI
	.WORD	1600.		;1600 BPI
	.WORD	6250.		;6250 BPI				;JDB007
	.WORD	6667.		;6667 BPI (TK50)			;008
	.WORD	8000.		;8000 BPI (TK25)			;009
	UNORG

.SBTTL	MOUNT/DISMOUNT DATA AREA

	I.DATA
;	DIALOGUE/MOUNT
ENTIRE:	.BLKW0			;<>0 ENTIRE PROCEED, 0 MOUNT PROCEED
FULL:	.BLKW0			;<>0 FULL COMMAND SPECIFIED, SKIP MOST ?'S

;	MOUNT SPECIFIC
MAGPAD:	.BLKW0	9.		;SCRATCH PAD FOR ERROR RECOVERY
NOTAG:	.BLKW0			;DOS LABEL TAG FLAG
SPCDEN:	.BLKW0			;SPECIFIED/TO-BE-USED DENSITY
DENST:	.BLKW0			;DENSITY SET SUCCESS FLAG
DENTRY:	.BLKW0			;DENSITIES TRIED INDICATOR
DENBIT:	.BLKW0			;DENSITY TO TRY NEXT
BADADR:	.BLKW0	2		;ADDRESS OF SAVE SET/RSTS BAD BLOCK FILE
INIADR:	.BLKW0	2		;ADDRESS OF SAVE SET INIT IMAGE
M.CHN:	.BYTE	0		;I/O CHANNEL OF CURRENT MOUNT
NXTVOL:	.BYTE	0		;NEXT VOLUME #
	.EVEN
	UNORG


.SBTTL	TEXT USE BY BOTH MOUNT AND DIALOGUE

	I.MESS
	.ENABL	LC

;	WORDS TO BE INSERTED IN TEXT
MNTPRM:	.ASCIZ	"mount prompt.            "

;	LONG FORM QUESTIONS
ASKDEV:	.ASCII	"Type 2 characters to specify  the "
DEVIO:	.ASCII	"        device  type,"<200>
	.ASCII	"followed  by  a  single digit (0-7) to specify the unit"<200>
	.ASCIZ	"number."<200>
	.EVEN
	UNORG

.SBTTL	TEXT AND ERROR MESSAGES

	I.MESS
	.ENABL	LC

;	SWITCH ERRORS (BOTH MOUNT AND DIALOGUE)
DUPSW:	.ASCIZ	"Duplicate switches"<200>
ILLCMD:	.ASCIZ	"Illegal command"<200>
ILLSW:	.ASCIZ	"Illegal switch"<200>
ILLDEN:	.ASCIZ	"Illegal density"<200>
UNRSW:	.ASCIZ	"Unrecognized switch"<200>

;	DEVICE RELATED ERRORS
NOREC:	.ASCIZ	"Non-recoverable I/O error"<200>
DEVMNE:	.ASCIZ	"Device mnemonic must be specified"<200>
NODEV:	.ASCIZ	"Non-existent or hung device"<200>
NORBAD:	.ASCIZ	"Can't read bad block file"<200>
NOTVAL:	.ASCIZ	"Not a valid device"<200>
SAMDEV:	.ASCIZ	"Same device specified"<200>
TAPWON:	.ASCIZ	"Tape won't respond to "
WRBOOT:	.ASCIZ	"Can't write to the booted device"<200>
WRGVOL:	.ASCIZ	"This is not the correct volume"<200>
WRGSIZ:	.ASCIZ	"Wrong size disk"<200>
TRYFUL:	.ASCIZ	"Requested device not found during limited hardware scan"<200>;014
	.EVEN
	UNORG

.SBTTL	MOUNT ROUTINE MAINLINE

;+
; MOUNT  - MOUNT A VOLUME
;
;	CALL:	MNTFLG BITS:
;		INPUT	SET TO INDICATE INPUT OR OUTPUT
;		ONLIN	SET IF THIS IS AN ONLINE RUN
;		DIALMT	SET IF THIS IS A DIALOGUE MOUNT
;
;		OPFLG AND SWTWRD BITS ARE SET UP CORRECTLY
;		R2 -> INPUT LINE (DIALOGUE MOUNT ENTRY ONLY)
;
;		CALL	MOUNT
;
;	RETURN:	C=1 - MOUNT UNSUCCESSFUL - ERROR MESSAGE HAS BEEN PRINTED
;		C=0 - MOUNT SUCCESSFUL
;		      A DEVICE HAS BEEN MOUNTED AND
;		      THE MNTTBL, SSVOL AND ORGDSK TABLES ARE SET UP
;				MNTTBL - CONTAINS DEVICE SPECIFIC INFO.
;				SSVOL  - CONTAINS SAVE SET SPECIFIC INFO.
;				ORGDSK - CONTAINS INFO. CONCERNING THE
;					 ORIGINAL (OR SOURCE) DISK
;
;	NOTE THAT ALL TIME SPENT IN MOUNT SUBSEQUENT TO THE MOUNTING
;	OF THE ORIGINAL 2 VOLUMES IS CONSIDERED 'WAIT TIME'.  ON ENTRY,
;	PROCESS TIME (WE WERE PROCESSING TILL WE NEEDED ANOTHER VOLUME)
;	IS ACCUMULATED AND THE WAIT TIMERS STARTED.  ON EXIT, WAIT TIME
;	IS ACCUMULATED AND THE PROCESS TIMERS ARE RESTARTED.
;-

.ENABL	LSB
.ENABL	LC

MOUNT:	REGSCR			;REGULAR MOUNT ENTRY
	MOV	RTNNAM,-(SP)	;SAVE NAME OF CALLING ROUTINE
	MOV	BUFPTR,-(SP)	;SAVE BUFFER POINTER
	MOVB	RECTYP,-(SP)	;SAVE SAVE RECORD TYPE
	CALLX	SAVSAT		;SAVE WHATEVER IS IN SATBUF SO WE CAN USE IT
	CLRB	HIGHBF		;WILL DO ALL I/O TO LOW MEMORY
	MOVB	#1,NXTVOL	;1ST VOL IS THE DEFAULT
	BIT	#DIALMT,MNTFLG	;DIALOGUE MOUNT?
	BNE	10$		;YES - SKIP TIME STUFF AND PROMPTS
	BIC	#WAITNG,MNTFLG	;NOT WAITING YET
	CALL	STRWAI		;ACCUMULATE PROCESS TIME AND START WAITING
	BIS	#WAITNG,MNTFLG	;INDICATE WAITING IN MOUNT
	MOVB	SSVOL+SSSEQ,NXTVOL	;SAVE CURRENT SEQ #
	INCB	NXTVOL		;REFLECT WHAT WE WANT NEXT
RESTRT:	CALLX	GETTTY		;KEEP CLOCK GOING
	CALL	PROMPT		;GET USER INPUT LINE

GLOBAL	<MNTFLG,RTNNAM,HIGHBF,SSVOL>

10$:	CALL	SETUP		;DO INITIAL SETUP
	MOV	R2,R5		;R5 -> INPUT STRING
	CALL	CVT$$B		;DO NOT TRIM PARITY BIT			;004
	CALL	PARDEV		;PARSE THE DEVICE SPEC.
	BCS	80$		;BRANCH ON ERROR
	CALL	PARLIN		;PARSE REST OF INPUT LINE
	BCS	80$		;ERROR
	BIT	#OPID,OPFLG	;IS THIS AN IDENTIFY ?
	BEQ	20$		;NO
	CALL	IDENT		;DO IDENTIFY
	BCS	80$		;ERROR
	BR	ENDMNT		;FINISHED IDENTIFY

20$:	TST	INPUT		;IS THIS A MOUNT FOR INPUT ?
	BEQ	30$		;NO - ITS A MOUNT FOR OUTPUT
	CALL	INMNT		;DO INPUT MOUNT PROCESSING
	BCS	70$		;ERROR
	BR	40$		;FINISHED MOUNT FOR INPUT

30$:	CALL	OUTMNT		;DO OUTPUT MOUNT PROCESSING
	BCS	70$		;ERROR
40$:	BIT	#DIALMT,MNTFLG	;DIALOGUE MOUNT?
	BNE	ENDMNT		;YES
	CALL	MTPRCD,R5	;OK, DOES HE WANT TO PROCEED
	  BR	RESTRT		;^Z - REASK
	  BR	RESTRT		;NO - REASK
	  TST	INPUT		;YES - INPUT MOUNT?
	BNE	50$		;YES, GO ACCUM TIMES
	BIT	#OPSV,OPFLG	;SAVE?
	BEQ	50$		;NO, GO ACCUM TIMES
	INCB	SSVOL+SSSEQ	;INC THE VOL SEQ #
	CALL	INIDEV		;GO INIT SAVE VOLUME
	BCS	60$		;PROBLEM INITTING
50$:	BIC	#WAITNG,MNTFLG	;NOT WAITING ANYMORE
	CALL	STRPRC		;ACCUMULATE WAIT TIME AND RESTART PROCESS TIME
ENDMNT:	CALLX	RESSAT		;RESTORE WHATEVER WAS IN SATBUF
	MOVB	#1,HIGHBF	;RESUME I/O FROM IOBUFF
	CLC			;CLEAR C-BIT BEFORE EXITTING
ENDDMT:	MOVB	(SP)+,RECTYP	;RESTORE SAVE RECORD TYPE
	MOV	(SP)+,BUFPTR	;RESTORE BUFFER POINTER
	MOV	(SP)+,RTNNAM	;RESTORE CALLING ROUTINE NAME
	RETURN

GLOBAL	<MNTFLG,OPFLG,RTNNAM,HIGHBF,SSVOL>


60$:	DECB	SSVOL+SSSEQ	;DEC VOL SEQUENCE #
	MOV	ABTADR,ERRADR	;MESSAGES HERE AREN'T FATAL
70$:	BIS	#DISERR,MNTFLG	;DO DISMOUNT ON ERROR
80$:	TST	ERRADR		;ERROR MESSAGE SET ?
	BNE	90$		;YES
	MOV	ABTADR,ERRADR	;NO - MAYBE THERE IS AN ABORT-TYPE ERROR
90$:	CALL	PRIERR		;MESSAGE TO PRINT ?
	BIT	#DISERR,MNTFLG	;DISMOUNT REQUESTED ?
	BEQ	100$		;NO - EXIT
	CALL	DISMNE		;DO DISMOUNT
100$:	BIT	#DIALMT,MNTFLG	;DIALOGUE MOUNT ?
	BEQ	RESTRT		;NO - DO RESTART
	CALLX	RESSAT		;RESTORE SATBUF
	SEC			;SET C-BIT
	BR	ENDDMT		;EXIT WITH ERROR IF DIALOGUE MOUNT

.DSABL	LSB
GLOBAL	<MNTFLG,SSVOL>

.SBTTL	PARDEV - PARSE INPUT DEVICE SPECIFICATION

.ENABL	LSB

PARDEV:	CMPB	(R2),#'_	;UNDERSCORE BEFORE DEVICE SPEC?
	BNE	10$		;NO
	TSTB	(R2)+		;BYPASS IT
10$:	CMPB	(R2),#'0	;SEE IF FIRST CHARACTER IN STRING
	BLO	40$		; IS NUMERIC
	CMPB	(R2),#'9	; IF NOT, GO CHECK FOR LEGAL		;JDB012
	BHI	40$		; DEVICE MNEMONIC
	BIT	#DIALMT,MNTFLG	;CHECK FOR DIALOGUE MOUNT
	BNE	20$		;DIALOGUE MOUNT
	MOV	SSVOL+SSDTYP,(R4)	;REMEMBER DEVICE TYPE
	MOVB	SSVOL+SSDIDX,R0
	BR	30$		;GO SEE IF UNIT EXISTS

20$:	BIT	#OPRE!OPIN!OPIM,OPFLG	;SEE IF IMA, INS OR RES		;JDB005
	BEQ	190$		;NO - ERROR (MNEMONIC NEEDED)
	TST	INPUT		;SECOND DEVICE MOUNT?
	BNE	190$		;NO - ERROR
	MOV	ORGDSK+ORGTYP,(R4)	;REMEMBER DEVICE TYPE
	MOVB	ORGDSK+ORGIDX,R0
30$:	BPL	120$		;IT'S A DISK
	MOVB	#14.,MAGTAP	;IT'S A TAPE
	BR	120$

40$:	CMPB	(R2),#'R	;FIRST LETTER 'R' ?
	BNE	50$		;NO
	MOVB	#'D,(R2)	;CHANGE 'R' TO 'D'
50$:	MOV	#BOONAM,R0	;DO DEVICE TABLE SEARCH
60$:	CMPB	(R2),(R0)+	;COMPARE FIRST BYTE
	BEQ	70$		;OK SO FAR
	INC	R0		;MOVE UP TO NEXT WORD
	BR	80$		;RESUME

70$:	CMPB	1(R2),(R0)+	;COMPARE SECOND BYTE
	BEQ	90$		;FOUND IT
80$:	TST	(R0)		;END OF TABLE ?
	BNE	60$		;NO - TRY NEXT ENTRY
	BR	180$		;YES - NOT A VALID DEVICE

90$:	SUB	#DSKNAM+2,R0	;COMPUTE DEVICE INDEX -> R0
	BMI	100$		;IT'S A MAGTAPE
	CLRB	MAGTAP		;THIS IS A DISK
	BR	110$

100$:	MOVB	#14.,MAGTAP	;THIS IS A MAGTAPE
110$:	MOVB	(R2)+,(R4)	;REMEMBER SPECIFIED
	MOVB	(R2)+,MNTTYP+1(R4) ; DEVICE TYPE
	BIS	#DEVICE,MNTFLG	;DEVICE MNEMONIC SPECIFIED
	CMPB	(R2),#'0	;SEE IF WE HAVE A LEGAL UNIT #
	BLO	180$		;<0 NO GOOD
	CMPB	(R2),#'9						;JDB012
	BHI	180$		;>9 NO GOOD				;JDB012
120$:	MOVB	(R2)+,R1	;GET ASCII UNIT #
	SUB	#'0,R1		;MAKE IT NUMERIC
	CMPB	(R2),#':	;WAS IT A SINGLE DIGIT UNIT NUMBER	;JDB012
	BEQ	125$		;BRANCH IF SO - DONE			;JDB012
	CMPB	(R2),#'0	;LESS THAN ASCII ZERO?			;JDB012
	BLO	180$		;BRANCH IF SO - BAD			;JDB012
	CMPB	(R2),#'9	;GREATER THAN ASCII NINE?		;JDB012
	BHI	180$		;BRANCH IF SO - BAD			;JDB012
	MOV	R0,-(SP)	;PRESERVE R0				;JDB012
	MOV	R1,R0		;COPY TENS DIGIT			;JDB012
	MUL	#10.,R0		;"DECIMAL-ATE" IT			;JDB012
	MOVB	(R2)+,R0	;GET UNITS DIGIT			;JDB012
	SUB	#'0,R0		;MAKE IT NUMERIC			;JDB012
	ADD	R0,R1		;AND ADD IT IN				;JDB012
	MOV	(SP)+,R0	;RESTORE R0				;JDB012
	CMP	R1,#DU.UNC	;UNIT NUMBER LESS THAN OR EQUAL TO MAX?	;JDB012
	BHI	180$		;BRANCH IF NOT - BAD			;JDB012
125$:	BIT	#OPIM,OPFLG	;IMAGE ?				;JDB012
	BEQ	130$		;NO
	CLR	TAPNDX		;MAKE SURE TAPE INDEX IS NON-NEGATIVE
	BR	170$		;GO SEE IF TAPE SPECIFIED

130$:	BIT	#OPSV,OPFLG	;SAVE ?
	BEQ	140$		;NO
	TST	INPUT		;MOUNT FOR INPUT ?
	BNE	170$		;YES - MAGTAPE NOT ALLOWED
	BR	150$

140$:	BIT	#OPRE!OPIN,OPFLG	;RESTORE OR INSTALL?		;JDB005
	BEQ	150$		;NO - THEN MUST BE ID			;JDB006
	TST	INPUT		;MOUNT FOR OUTPUT ?
	BEQ	170$		;YES - MAGTAPE NOT ALLOWED
150$:	MOV	R0,TAPNDX	;THE SAVE VOLUME INDEX
	MOV	R1,TAPUNT	; AND UNIT #
160$:	CALLX	GETTTY		;TIC - TOC - KICK THE CLOCK
	BR	UNTCHK		;NOW CHECK OUT THE UNIT

170$:	TSTB	MAGTAP		;A MAGTAPE ?
	BEQ	160$		;NO
180$:	MOV	#NOTVAL,ERRADR	;%%% NOT A VALID DEVICE
	BR	200$

190$:	MOV	#DEVMNE,ERRADR	;%%% MNEMONIC MUST BE SPECIFIED
200$:	SEC
	RETURN

GLOBAL	<TAPNDX,TAPUNT,DSKNAM,BOONAM,MNTFLG,OPFLG,SSVOL,ORGDSK,DU.UNC>	;JDB012
.DSABL	LSB

.SBTTL	UNTCHK - SEE IF DEVICE UNIT EXISTS

.ENABL	LSB

UNTCHK:	MOVB	R0,MNTIDX(R4)	;SAVE DEVICE INDEX
	MOVB	R1,MNTUNT(R4)	;REMEMBER UNIT #
	TST	INPUT		;THIS A MOUNT FOR OUTPUT ?
	BNE	20$		;NO
	MOV	MNTTBL,R3	;GET ADDRESS OF INPUT MOUNT TABLE
	CMPB	MNTIDX(R3),MNTIDX(R4)	;SAME DEVICE INDEX AS INPUT ?
	BNE	10$		;NO
	CMPB	MNTUNT(R3),MNTUNT(R4)	;SAME UNIT # ?
	BEQ	70$		;YES - ERROR
10$:	MOV	SAVUNT+4,R3	;ADDRESS OF SYSTEM DISK INFO. TABLE
	CMPB	(R3),MNTIDX(R4)	;SAME DEVICE INDEX AS SYSTEM DISK ?
	BNE	20$		;NO
	CMPB	DEVUNT(R3),MNTUNT(R4)	;SAME UNIT # ?
	BEQ	80$		;YES - CAN'T WRITE TO THE BOOTED DEVICE
20$:	CALL	CHNSEL		;SET UP CHANNEL SPECS.
	MOVB	MNTUNT(R4),R1	;R1=UNIT #
	CLRB	OPNFLG		;DEVICE IS NOT OPEN YET
	MOVB	#-1,NOERR	;INHIBIT ERRORS
	TSTB	MAGTAP		;DO WE HAVE A MAGTAPE ?
	BEQ	30$		;NO
	CALLX	SETTAP		;YES - TRY TO OPEN IT
	MOVB	(PC),OPNFLG	;TAPE IS OPEN NOW - I THINK
	BCS	90$		;OOPS
	BR	60$		;ALL DONE

30$:	CALLX	LOKRST		;SEE IF DISK EXISTS AND IS MOUNTED
	MOVB	(PC),OPNFLG	;IT'S OPEN NOW
	TSTB	NRSTSD		;IS IT A RSTS DISK (INCLUDING SYSTEM DISK)?
	BEQ	40$		;YES
	TSTB	IOERR		;AN I/O ERROR ?
	BNE	90$		;YES
	BR	50$		;A NON-RSTS DISK

40$:	BISB	#FMTRST,MNTFMT(R4)	;FORMAT IS RSTS
	MOVB	PCS,MNTPCS(R4)	;PACK CLUSTER SIZE
	MOVB	CLURAT,MNTCLU(R4)	;CLUSTER RATIO (PCS/DCS)
50$:	ASL	R1		;COMPUTE UNIT # * 2
	MOV	R0,R3		;SAVE DEVICE INDEX
	MOV	R1,R0		;COPY UNIT # * 2 TO R0
	ADD	DSKSZL(R3),R0	;R0 -> DISK SIZE (LSB)
	ADD	DSKSZM(R3),R1	;R1 -> DISK SIZE (MSB)
	MOV	(R0),MNTSZL(R4)	;DISK SIZE (LSB)
	MOV	(R1),MNTSZM(R4)	;DISK SIZE (MSB)
	MOV	(R0),R0		;GET SIZE INTO R0/R1
	MOV	(R1),R1	
	SUB	DCS,R0		;COMPUTE LARGEST SC FBN=
	SBC	R1		; SIZE-DCS-7
	SUB	#7,R0		;
	SBC	R1		;
	MOV	R0,MNTMFB(R4)	;MAX. SC FBN LSB
	MOV	R1,MNTMFB+2(R4)	;MAX. SC FBN MSB
	MOVB	DCS,MNTDCS(R4)	;DEVICE CLUSTER SIZE
	TST	INPUT		;MOUNT FOR INPUT ?
	BNE	60$		;YES - EXIT
	BIT	#OPIM!OPIN!OPRE,OPFLG	;IMAGE, INSTALL OR RESTORE ?	;JDB005
	BEQ	60$		;NO - EXIT
	MOVB	ORGDSK+ORGPCS,PCS	;GET THE ORIGINAL PCS
	CALLX	SETSAT		;MAKE THE OUTPUT SATT LOOK RIGHT
	BIC	#17,MNTSZL(R4)	;DROP TO NEXT LOWER CLUSTER BOUNDARY	;JDB005
	MOV	ORGDSK+ORGSZL,-(SP)	;GET A COPY OF IT		;JDB005
	BIC	#17,(SP)	;DROP IT TO NEXT LOWER CLUSTER BOUNDARY	;JDB005
	CMP	(SP)+,MNTSZL(R4)	;COMPARE SIZE OF IN AND OUT	;JDB005
	BEQ	55$		; CONTINUE IF EQUAL			;BGN013
	MOV	ORGDSK+ORGSZL,-(SP) ; GET SIZE				;BGN013
	SUB	MNTSZL(R4),(SP)	; GET THE DIFFERENCE			;BGN013
	BGT	52$		; POSITIVE DIFF				;BGN013
	NEG	(SP)		; ELSE MAKE IT POSITIVE			;BGN013
52$:	CMPB	(SP)+,DCS	; CHECK THE DIFFERENCE			;BGN013
	BGT	110$		; ERROR IF > 1 DCS			;BGN013
55$:	CMP	ORGDSK+ORGSZM,MNTSZM(R4)	;MORE OF SIZE
	BNE	110$
60$:	CALL	130$		;RE-LOKRST SYSTEM DISK
	CLC
	RETURN

70$:	MOV	#SAMDEV,ERRADR	;%%% SAME DEVICE SPECIFIED
	BR	120$

80$:	MOV	#WRBOOT,ERRADR	;%%% CAN'T WRITE TO THE BOOTED DEVICE
	BR	120$		;GO FAIL

90$:	BIT	#NOMSG,MNTFLG	;DEVICE NOT AVAILABLE ?
	BNE	100$		;YES - MESSAGE HAS ALREADY BEEN PRINTED
	CALLX	VBCHK		;Is this a virgin boot?			;014
	BCC	95$		;No, so handle in the normal fashion.	;014
	MOV	#TRYFUL,ERRADR	;Tell them it wasn't found in partial.	;014
	CALL	PRIERR		;Print out the error message.		;014
	CALLX	FSZBOT		;See if they want to reboot with full	;014
				; hardware scan (FSZBOT is in ROOT.MAC).;014
	BR	120$		;And, go fail.				;014

95$:	MOV	#NODEV,ERRADR	;%%% DEVICE DOES NOT EXIST		;014
100$:	CLRB	IOERR		;GET RID OF THE ERROR
	BR	120$

110$:	MOV	#WRGSIZ,ERRADR	;%%% WRONG SIZE DISK
120$:	CALL	130$		;RE-LOKRST SYSTEM DISK
	SEC
	RETURN

130$:	CALL	SELEC3		;SELECT THE SYSTEM DISK
	MOV	SYSNDX,R0	;SYSTEM DISK INDEX
	MOV	SYSUNT,R1	;SYSTEM DISK UNIT #
	CALLX	LOKRST		;RESET IT
	CALL	CHNSEL		;GET BACK NEW DEVICE PARAMETERS
	RETURN

.DSABL	LSB

GLOBAL	<DSKSZL,DSKSZM,DCS,PCS,CLURAT,MNTTBL,NRSTSD,OPNFLG,IOERR,OPFLG>
GLOBAL	<SYSUNT,SYSNDX,SAVUNT,NOERR,ORGDSK,MNTFLG>

.SBTTL	PARLIN - PARSE REST OF INPUT LINE

.ENABL	LSB

PARLIN:	BIC	#SCR!DEN,SWTWRD	;CLEAR SWITCH BITS
	MOV	R2,R1		;POINT R1 TO CHAR AFTER DEVICE SPEC
	TSTB	(R1)
	BEQ	50$		;END OF INPUT LINE
	CMPB	(R1)+,#':	;CHARACTER COLON ?
	BNE	60$		;NO - ERROR
	TSTB	(R1)
	BEQ	50$		;END OF INPUT LINE
	CMPB	(R1),#'/	;DO WE HAVE A SWITCH ?
	BEQ	30$		;YES - GO GET IT
	BIT	#OPSV,OPFLG	;SAVE?
	BEQ	10$		;NOPE
	TST	INPUT		;INPUT MOUNT?
	BNE	10$		;YES
	TSTB	SSVOL+SSSEQ	;1ST VOLUME OF SAVE SET
	BNE	60$		;NO
10$:	CALLX	RADINP		;NO SWITCH - MUST BE PACKID
	MOV	R0,SPCPID	;PUT RAD50 PACKID/SSN IN SPCPID
	MOV	R3,SPCPID+2
	BIS	#PACKID,MNTFLG	;PACKID/SSN SPECIFIED
20$:	TSTB	(R1)
	BEQ	50$		;END OF INPUT LINE
	CMPB	(R1),#'/	;A SWITCH
	BNE	60$		;NO - ILLEGAL INPUT
30$:	INC	R1		;POINT TO BEGINNING OF SWITCH
	CALLX	GETUNQ,R5,MNTSWT	;PARSE SWITCH
	BCS	70$		;COULDN'T FIND SWITCH - ERROR
	BIT	MSBIT(R0),SWTWRD	;SEE IF SWITCH ALREADY SPECIFIED
	BNE	80$		;SWITCH ALREADY SPECIFIED - ERROR
	BIS	MSBIT(R0),SWTWRD	;SET SWITCH SPECIFIED
	TST	R0		;BRANCH TO CORRECT SWITCH HANDLER
	BEQ	40$		;/SCRATCH
	TSTB	MAGTAP		;THIS MAGTAPE ?
	BEQ	90$		;NO - ERROR
	CMPB	(R1)+,#':	;NEXT CHAR. COLON ?
	BNE	100$		;NO - ERROR - BAD DENSITY SWITCH FORMAT
	CALLX	GETUNQ,R5,DENARG	;PARSE DENSITY ARGUMENT
	BCS	100$		;CARRY SET - ERROR - UNRECOGNIZED DENSITY
	MOV	DENNUM(R0),SPCDEN	;REMEMBER SPECIFIED DENSITY
	BIT	#OPRE!OPIN!OPSV,OPFLG	;SAVE, INSTALL OR RESTORE ?	;JDB005
	BEQ	20$		;NO
	TSTB	SSVOL+SSSEQ	;FIRST VOLUME ?
	BEQ	20$		;YES
	CMP	SPCDEN,SSVOL+SSDEN	;RIGHT SAVE SET DENSITY SPECIFIED ?
	BNE	100$		;NO - ERROR
	BR	20$		;LOOK FOR ANOTHER SWITCH

40$:	TST	INPUT		;MOUNT FOR OUTPUT ?
	BNE	90$		;NO - ILLEGAL SWITCH
	BR	20$		;LOOK FOR ANOTHER SWITCH

50$:	CALLX	GETTTY		;REWIND CLOCK
	CLC
	RETURN

60$:	MOV	#ILLCMD,ERRADR	;%%% ILLEGAL INPUT SPEC.
	BR	110$

70$:	MOV	#UNRSW,ERRADR	;%%% UNRECOGNIZED SWITCH
	BR	110$

80$:	MOV	#DUPSW,ERRADR	;%%% DUPLICATE SWITCH
	BR	110$

90$:	MOV	#ILLSW,ERRADR	;%%% ILLEGAL SWITCH
	BR	110$

100$:	MOV	#ILLDEN,ERRADR	;%%% ILLEGAL DENSITY - BAD DENSITY OR FORMAT
110$:	SEC
	RETURN

.DSABL	LSB
GLOBAL	<SWTWRD,MNTFLG,OPFLG,SSVOL,SPCPID>

.SBTTL	SETUP  - INITIAL SET UP

;+
; SETUP - DO INITIAL SETUP
;		- CLEAR MAGTAP,PACKID,DEVICE,DISERR & DENST BITS IN MNTFLG
;		- SET UP ROUTINE NAME IN RTNNAM
;		- CLEAR ERROR ADDRESS WORD
;		- SETUP M.TBL AND M.CHN
;		- ZERO APPROPRIATE MOUNT TABLE
;
;	CALL:	CALL	SETUP
;
;	RETURN:	R4 = APPROPRIATE MOUNT TABLE ADDRESS
;		M.TBL AND M.CHN SETUP
;
;-

.ENABL	LSB

SETUP:	MOV	R0,-(SP)	;SAVE R0
	MOV	#MNTNAM,RTNNAM	;SET UP ROUTINE NAME
	BIC	#NOMSG!PACKID!DEVICE!DISERR!DIRTY,MNTFLG
	CLRB	MAGTAP		;CLEAR MAGTAPE INDICATOR
	CLR	ERRADR		;CLEAR ERROR ADDRESS WORD
	CLR	ABTADR		;AND FATAL ADDRESS WORD
	TST	INPUT		;THIS MOUNT FOR INPUT ?
	BEQ	10$		;NO
	MOVB	#1,M.CHN	;INPUT CHANNEL NUMBER
	MOV	MNTTBL,M.TBL	;INPUT MOUNT TABLE
	CLR	UNKBBI		;NO UNKNOWN BB'S YET
	BR	20$

10$:	MOVB	#2,M.CHN	;OUTPUT CHANNEL NUMBER
	MOV	MNTTBL+2,M.TBL	;OUTPUT MOUNT TABLE
	CLR	UNKBBO		;NO UNKNOWN BB'S YET
20$:	MOV	M.TBL,R4	;POINT TO APPRPRIATE MOUNT TABLE
	MOV	#MNTSIZ/2,R0	;WILL CLEAR ALL THE WORDS IN THE MOUNT TABLE
30$:	CLR	(R4)+		;CLEAR WORD
	SOB	R0,30$		;CLEAR 'EM ALL
	MOV	M.TBL,R4	;MAKE SURE R4 POINTS TO THE TABLE BASE
	MOV	(SP)+,R0	;RESTORE R0
	RETURN			;GET OUT

.DSABL	LSB
GLOBAL	<RTNNAM,MNTFLG,MNTTBL,UNKBBI,UNKBBO>

.SBTTL	CHNSEL - SETUP CHANNEL FOR DEVICE BEING MOUNTED

CHNSEL:	MOVB	M.CHN,R1	;GET THE CHANNEL NUMBER
	CALL	SETIO		;SET IT UP
	RETURN

.SBTTL	DENSET - SET MAGTAPE DENSITY

;+
; DENSET - SET MAGTAPE DENSITY
;
;	CALL:	CALL	DENSET,R5
;
;	RETURN:	R5 + 6 - SUCCESSFUL
;		R5 + 4 - ERROR IN SET
;		R5 + 0 - COULDN'T READ TAPE
;-

.ENABL	LSB

DENSET:	REGSAV			;SAVE REGISTERS
	CLR	DENTRY		;HAVEN'T TRIED ANY DENSITIES YET
	MOV	#1,DENBIT	;ALWAYS START WITH LOWEST DENSITY	;JDB007
	CLR	DENST		;SUCCESSFUL DENSITY SET FLAG
	CALL	CHNSEL		;SET UP CHANNEL
	CLR	R4		;DENNUM TABLE OFFSET
	TSTB	SSVOL+SSSEQ	;FIRST VOLUME ?
	BEQ	20$		;YES
	MOV	SSVOL+SSDEN,R5	;SAVE SET DENSITY
	CALL	170$		;INDICATE WHICH DENSITY WE HAVE
	CALL	SETIT		;SET DENSITY
	BCS	140$		;ERROR - TELL USER CAN'T READ IT
	MOV	R5,R2		;THIS IS THE OPERATION DENSITY
10$:	CALL	TAPERD		;TRY READING TAPE
	BCC	100$		;READ SUCCESSFUL
	TST	INPUT		;MOUNT FOR INPUT ?
	BNE	140$		;YES - TELL USER CAN'T READ
	BIT	#SCR,SWTWRD	;/SCRATCH SPECIFIED ?
	BNE	15$		;YES - EXIT CAN'T READ			;JDB005
	CALL	190$		;ANY MORE DENSITIES ?
	BCS	120$		;NO - EXIT CAN'T READ
	BR	10$		;YES - TRY NEXT

	;WE RESET THE DENSITY HERE 'CAUSE THE TM02 WILL LET YOU CREATE	;JDB005
	;A MIXED DENSITY TAPE. THE FOLLOWING CODE WILL PREVENT THIS	;JDB005
15$:	MOV	SSVOL+SSDEN,R5	;SAVE SET DENSITY			;JDB005
	CALL	SETIT		;AND NOW SET THE DENSITY		;JDB005
	BR	120$		;AND JOIN THE MAIN LINE			;JDB005

20$:	BIT	#DEN,SWTWRD	;/DENSITY SPECIFIED ?
	BEQ	30$		;NO - GO TRY LOWEST			;JDB007
	MOV	SPCDEN,R5	;GET SPECIFIED DENSITY
	CALL	170$		;INDICATE WHICH ONE WE HAVE
	CALL	SETIT		;SET DENSITY
	BCS	140$		;ERROR - TAPE WON'T RESPOND
	MOV	(PC),DENST	;DENSITY SET SUCCESSFUL
	MOV	R5,R2		;THIS IS THE OPERATION DENSITY
	TST	INPUT		;MOUNT FOR INPUT ?
	BNE	10$		;YES - GO TRY READ
	BR	90$		;NO - GO CHECK IF /SCR SPECIFIED


30$:	CALL	190$		;SET UP TO TRY LOWEST DENSITY		;JDB007
40$:	CALL	SETIT		;SET DENSITY
	MOV	INPUT,R3	;MOUNT FOR INPUT ? (DON'T LOSE C-BIT)
	BEQ	70$		;NO - GO DO OUTPUT SET FAIL ROUTINE
	BCC	60$		;YES - GO TRY READ
50$:	CALL	190$		;ANOTHER DENSITY TO TRY ?
	BCS	120$		;NO - EXIT CAN'T READ
	BR	40$		;YES - TRY IT

60$:	CALL	TAPERD		;TRY READ
	BCS	50$		;READ FAILED - SEE IF THERE IS ANOTHER
	MOV	R5,R2		;THIS ONE WORKED - STACK IT
	BR	100$		;SUCCESS - EXIT

70$:	BCS	80$		;OUTPUT SET FAILED - CHECK FOR ANOTHER
	TST	DENST		;HAS A SET SUCCEEDED YET ?
	BNE	90$		;YES - GO CHECK FOR /SCR
	MOV	(PC),DENST	;NO - BUT THIS ONE DID
	MOV	R5,R2		;THIS IS THE OPERATION DENSITY
	BR	90$		;GO CHECK FOR /SCR

80$:	CALL	190$		;ANY MORE DENSITIES ?
	BCC	40$		;YES - TRY IT
	TST	DENST		;HAS A SET WORKED YET ?
	BNE	120$		;YES - EXIT CAN'T READ
	CLR	R5		;NO - TAPE WON'T RESPOND
	BR	140$

90$:	BIT	#SCR,SWTWRD	;/SCRATCH SPECIFIED ?
	BNE	120$		;YES - EXIT CAN'T READ
	CALL	TAPERD		;NO - TRY READ
	BCC	100$		;SUCCESS - EXIT
	CALL	190$		;READ FAILED - ANOTHER DENSITY TO TRY ?
	BCS	120$		;NO - EXIT CAN'T READ
	BR	40$		;YES - TRY IT

100$:	ADD	#2,TOS.R5(SP)	;SUCCESS EXIT - RETURN + 6
110$:	ADD	#4,TOS.R5(SP)	;ERROR EXIT - RETURN + 4
120$:	MOV	R2,SSVOL+SSDEN	;CAN'T READ EXIT - RETURN + 0
	MOV	M.TBL,R4	;MOUNT TABLE
	MOV	R5,MNTDEN(R4)	;CURRENT TAPE DENSITY
130$:	CALLX	REGRES,R5	;RESTORE REGISTERS
	RETURN	R5		;RETURN


140$:	WARN	TAPWON		;'%%% TAPE WON'T RESPOND TO '
	TST	R5		;SPECIFIC DENSITY ?
	BEQ	150$		;NO
	MESSAG	<"density ">
	MOV	R5,R0
	CALLX	DECZER		;PRINT DENSITY
	BR	160$

150$:	MESSAG	<"any density">
160$:	CALLX	TYPECR
	BR	110$

170$:	CMP	R5,DENNUM(R4)	;THIS ONE THE ONE ?
	BEQ	180$		;YES
	TST	(R4)+		;TRY
	ASL	DENBIT		;   NEXT
	BR	170$		;       ONE

180$:	BIS	DENBIT,DENTRY	;SET ITS BIT
	MOV	#1,DENBIT	;START AT BEGINNING FOR RETRIES
	CLR	R4
	RETURN

190$:	CMP	#31.,DENTRY	;ANY MORE TO TRY ?			;JDB010
	BEQ	220$		;NO - FAIL

200$:	BIT	DENBIT,DENTRY	;THIS ONE TRIED ?
	BEQ	210$		;NO - WE CAN TRY IT
	TST	(R4)+		;TRY
	ASL	DENBIT		;   NEXT
	BR	200$		;       ONE

210$:	MOV	DENNUM(R4),R5	;GET IT
	BIS	DENBIT,DENTRY	;SET ITS BIT
	TST	(R4)+		;POINT TO NEXT
	ASL	DENBIT		;SET UP FOR NEXT
	TST	(PC)+		;OK THIS WAY
220$:	SEC
	RETURN

.DSABL	LSB
GLOBAL	<SSVOL,SWTWRD>

.SBTTL	SETIT  - SET THE DENSITY

;+
; SETIT - SET THE SPECIFIED DENSITY
;
;	CALL:	R0 = MAGTAPE INDEX
;		R1 = MAGTAPE UNIT #
;		R5 = DENSITY TO BE SET
;		CALL	SETIT
;
;	RETURN:	C BIT INDICATING SUCCESS OR FAILURE
;-

.ENABL	LSB

ERRDS:				;ERRDS AND SETIT NOW IDENTICAL		;JDB007
SETIT:	REGSCR			;SAVE REGISTERS				;JDB007
10$:	BIT	#ONLIN,MNTFLG	;ONLINE?				;JDB007
	BNE	50$		;ONLINE - EXIT				;JDB007

	CALL	REWIND		;REWIND SO WE CAN SET THE DENSITY	;JDB007
	MOV	TOS.R5(SP),R2	;GET REQUESTED DENSITY			;JDB007
	BIS	#100000,R2	;PARAMETER TO SET THE DENSITY		;JDB007
	CALL	MTSPC,R5,12.	;ISSUE VAM'S NEW .SPEC			;JDB007
	BCC	50$		;IF NO ERROR WE GOT OUR DENSITY		;JDB007
	CMPB	IOERR,#BADNER	;WAS DENSITY ILLEGAL FOR DRIVE?		;JDB007
	BNE	60$		;NO - SOME OTHER PROBLEM		;JDB007
	SEC			;ELSE WE FAILED (SOFTLY)		;JDB007
50$:	RETURN

60$:	CALL	RETRY		;QUERY FOR DEVICE HUNG
	BR	10$		;OK NOW - RETRY

.DSABL	LSB

.SBTTL	TAPERD - READ TAPE FOR DENSITY SET

;+
; TAPERD - DO TEST TAPE READ FOR THE DENSITY SETTING ROUTINE
;
;	CALL:	CALL	TAPERD
;
;	RETURN:	C=0 - READ SUCCESSFUL
;		      R5 WILL CONTAIN THE DENSITY IF IT CHANGED
;		C=1 - READ FAILED
;-

.ENABL	LSB

TAPERD:	REGSCR			;SAVE REGISTERS
10$:	CLR	ABTADR		;IN CASE MTIO RUNS INTO PROBLEMS, GET RID OF
				; ERROR IT PRODUCES
	CALL	REWIND		;REWIND TAPE
	MOV	(PC),NOTAG	;WE ARE NOT DEALING IN TAGS
	CALL	MTSPC,R5,7.	;GET TAPE STATUS
	BCS	60$		;NO GOOD
	MOV	R3,R4		;SAVE STATUS BEFORE READ
	BIC	#^C<8.+24576.>,R4	;ISOLATE DENSITY BITS
	MOV	#<2062./2>,R1	;We could get up to 2062. bytes.	;009
	MOV	#SATBUF,BUFPTR	;POINT TO SATBUF
	CALL	MTIO,R5,RFUN	;DO THE READ
	  BR	10$		;RANDOM I/O ERROR - TRY AGAIN
	  NOP			;BAD BLOCK/MAGTAPE RECORD LENGTH
	  NOP			;EOF/NOROOM
	  CMPB	#DATERR,IOERR	;A BAD BLOCK ?
	BEQ	50$		;YES - EXIT WITH ERROR

20$:	CALL	MTSPC,R5,7.	;GET TAPE STATUS
	BCS	60$		;NO GOOD
	BIC	#^C<8.+24576.>,R3	;ISOLATE DENSITY BITS
	CMP	R3,R4		;DENSITY THE SAME AS BEFORE READ ?
	BEQ	40$		;YES
	TST	INPUT		;MOUNT FOR INPUT ?
	BEQ	30$		;NO - GO FIND OUT WHAT DENSITY WE HAVE NOW
	TSTB	SSVOL+SSSEQ	;FIRST VOLUME ?
	BNE	50$		;NO - EXIT WITH ERROR
30$:	BIT	#DEN,SWTWRD	;/DENSITY SPECIFIED ?
	BNE	50$		;YES - EXIT WITH ERROR
	MOV	#1600.,R5	;R5 WILL CONTAIN THE DENSITY ON EXIT
	BIT	#8.,R3		;DENSITY 1600 ?
	BNE	40$		;YES
	ASR	R5		;NO - MAKE IT 800.
40$:	MOV	R5,TOS.R5(SP)	;NEW DENSITY
	TST	(PC)+		;SUCCESSFUL - CLEAR CARRY & POP OVER SEC
50$:	SEC
	MOV	#0,NOTAG	;CLEAR NOTAG INDICATOR W/O AFFECTING CARRY
	RETURN

60$:	CALL	RETRY		;QUERY FOR DEVICE HUNG
	CALL	SETIT		;SET CORRECT DENSITY
	BCS	60$		;ERROR IN SET
	BR	10$		;OK NOW - RETRY

GLOBAL	<IOERR,SATBUF,SSVOL,SWTWRD>
.DSABL	LSB

.SBTTL	CHKSAV - SAVE VOLUME CHECKER

;+
; CHKSAV - SEE IF THE CURRENT VOLUME IS A SAVE VOLUME
;
;	CALL:	CALL	CHKSAV
;
;	RETURN:	FOR A SAVE VOLUME:
;			C=0
;			FIRST BLOCK IN BUFBEG HAS THE SAVE SET LABEL
;			SAVE SET NAME AND
;			DATE AND TIME OF CREATION IN APPROPRIATE MOUNT TABLE
;			VOLSEQ CONTAINS THE SEQUENCE NUMBER
;			PKSTAT CONTAINS ORG PACK STATUS WORD IFF	;002
;				THIS IS AN INPUT MOUNT FOR THE FIRST	;002
;				VOLUME ON A RESTORE			;002
;		IF NOT A SAVE VOLUME:
;			C=1
;-

.ENABL	LSB

CHKSAV:	REGSCR			;SAVE REGISTERS
	CALL	CHNSEL		;SET UP THE CHANNEL
	CLR	CURFBN		; IN FBN 0
	CLR	CURFBN+2
	MOV	#SATBUF+4,R3	;POINT TO I/O BUFFER
	MOV	R3,BUFPTR	; AND AGAIN
	TSTB	MAGTAP		;THIS MAGTAPE ?
	BEQ	20$		;NO - DISK
	CALL	REWIND		;DO REWIND
	MOV	(PC),NOTAG	;SET NOTAG FLAG (DOS LABEL)
	MOV	#<2062./2>,R1	;We could get up to 2062. bytes.	;009
	MOV	#2,R2		;# OF I/O'S - 1 TO DO
				; DOS LABEL/BOOT BLOCK/PRIME LABEL
10$:	CALL	MTIO,R5,RFUN	;READ THE TAPE
	  BR	60$		;UNRECOVERABLE I/O ERROR
	  BR	60$		;BAD BLOCK ERROR
	  BR	60$		;EOF ERROR
	  MOV	#256.,R1	;1 BLOCKS WORTH
	DEC	R2		;1 LESS TO DO
	BMI	30$		;ALL DONE
	BNE	10$		;AGAIN
	ADD	#512.,BUFPTR	;POINT 1 BLOCK FURTHER INTO BUFFER
	BR	10$		;AGAIN

20$:	MOV	#512.,I.DSQ+DSQCNT	;CLUSTER IS TWO BLOCKS LONG
	CALL	SAVIO,R5,RFUN	;READ SAVE VOLUME
	  BR	60$		;UNRECOVERABLE I/O ERROR
	  BR	60$		;BAD BLOCK ERROR
	  BR	60$		;EOF ERROR
30$:	  CLR	NOTAG		;CLEAR FLAG
	CMP	PLBDSF(R3),#"SA	;FIRST TWO BYTES OF FORMAT
	BNE	60$		; MUST BE "SA"
	CMP	PLBDSF+2(R3),#"VR	;SECOND TWO BYTES
	BNE	60$		; MUST BE "VR"
	CMP	PLBDSF+4(R3),#"ES	;THIRD TWO BYTES
	BNE	60$		; MUST BE "ES"
	MOV	PLBBBA(R3),BADADR	;GET BAD BLOCK FILE ADDRESS
	MOV	PLBBBA+2(R3),BADADR+2
	MOV	PLBINA(R3),INIADR	;GET INIT IMAGE ADDRESS
	MOV	PLBINA+2(R3),INIADR+2
	TST	INPUT		;IS THIS A MOUNT FOR INPUT?		;002
	BEQ	35$		;BRANCH IF NOT				;002
	BIT	#OPRE!OPIN,OPFLG	;IS THIS A RES OR INS?		;004
	BEQ	35$		;BRANCH IF NOT				;002
	CMPB	#1,NXTVOL	;IS THIS THE FIRST VOLUME?		;002
	BNE	35$		;BRANCH IF NOT				;002
	MOV	PLBSTA(R3),PKSTAT	; ELSE GET THE ORG PACK STATUS	;002
35$:	MOV	PLBSLA(R3),CURFBN	;GET THE ADDRESS OF THE		;002
	MOV	PLBSLA+2(R3),CURFBN+2	; SAVE SET LABEL
	MOVB	#SAVLAB,RECTYP	;WE WANT THE SAVE SET LABEL
	TSTB	MAGTAP		;MAGTAPE ?
	BEQ	40$		;NO - DISK
	MOV	#2,R5		;2 EOFS
	CALL	ADVEOF		;DO ADVANCE
	BCS	60$		;ERROR - EXIT + 0
40$:	MOV	R3,BUFPTR	;POINT BUFPTR TO BEGINNING OF BUFFER
	MOV	#256.,I.DSQ+DSQCNT	;SAVE LABEL IS ONE BLOCK LONG
	CALL	SAVIO,R5,RFUN	;READ SAVE VOLUME
	  BR	60$		;WRONG MAGTAPE RECORD
	  BR	60$		;BAD BLOCK ERROR
	  BR	60$		;EOF ERROR
	  MOV	M.TBL,R4	;POINT TO CURRENT MOUNT TABLE
	MOV	(R3)+,MNTPID(R4)	;GET SAVE SET NAME
	MOV	(R3)+,MNTPID+2(R4)	;THERE ARE TWO WORDS OF IT
	MOV	(R3)+,MNTDCR(R4)	;DATE OF CREATION
	BEQ	60$			;AIN'T NO REAL DATE!
	MOV	(R3)+,MNTTCR(R4)	;TIME OF CREATION
	MOV	(R3)+,MNTEXP(R4)	;UP TO THE SEQUENCE NUMBER
	BEQ	60$			;NOT REAL EXP DATE
	MOVB	(R3),VOLSEQ	;VOLUME SEQUENCE NUMBER
	BISB	#FMTSAV,MNTFMT(R4)	;SET SAVE FORMAT BIT
50$:	TST	(PC)+		;WE WERE SUCCESSFUL - POP OVER SEC

60$:	SEC
	MOV	#0,NOTAG	;ZERO OUR TAG
	RETURN

GLOBAL	<I.DSQ,CURFBN,SATBUF,PKSTAT,OPFLG,PLBSTA>
.DSABL	LSB

.SBTTL	CHKRST - RSTS FILE STRUCTURED CHECKER

;+
; CHKRST - SEE IF A DISK IS RSTS FILE STRUCTURED
;
;	CALL:	CALL	CHKRST
;
;	RETURN:	IF DISK RSTS:
;		C=0
;		[0,1]SATT.SYS ACCOUNTING ENTRY IN FIBUF
;		PACK ID, CREATION DATE AND CREATION TIME
;		IN APPROPRIATE MOUNT TABLE
;		PACK STATUS WORD IN PKSTAT IFF AN INPUT MOUNT AND	;002
;			THIS IS NOT A RESTORE				;002
;		R3 = LINK TO FIRST RETREIVAL ENTRY OF SATT.SYS
;
;		IF DISK NOT RSTS:
;		C=1
;-

.ENABL	LSB

CHKRST:	REGSCR			;SAVE REGISTERS
	MOV	M.TBL,R4	;POINT TO CURRENT MOUNT TABLE
	BITB	#FMTRST,MNTFMT(R4)	;IS DISK RSTS ?
	BEQ	30$		;NO
	CALL	CHNSEL		;SET UP CHANNEL
10$:	CALL	FSRDPL		;READ IN PACK LABEL			;002
	BNE	30$		;ERROR READING PACK LABEL		;002
	TST	INPUT		;IS THIS A MOUNT FOR INPUT?		;002
	BEQ	15$		;BRANCH IF NOT				;002
	BIT	#OPRE!OPIN,OPFLG	;IS THIS A RESTORE OR INSTALL?	;004
	BNE	15$		;BRANCH IF SO				;002
	MOV	FIBUF+12,PKSTAT	; ELSE SQUIREL AWAY PACK STATUS WORD	;002
15$:	BIT	#UC.MNT,FIBUF+12	;IS THE PACK DIRTY?
	BEQ	20$		;NOPE
	BIS	#DIRTY,MNTFLG	;REMEMBER IT WAS DIRTY
20$:	MOV	FIBUF+14,MNTPID(R4)	;GET PACK ID
	MOV	FIBUF+16,MNTPID+2(R4)
	MOV	#FQSATT+FQPPN,R0	;R0 -> [0,1]SATT.SYS
	CALL	FSSDU		;SEARCH FOR SATT.SYS
	BCS	30$		;ERROR
	MOV	UAA(R5),R3	;R3 -> LINK TO ACCTING ENTRY
	MOV	UAR(R5),TOS.R3(SP)	;SET UP SO R3 POINTS TO
					; RETREIVAL ENTRY ON EXIT
	CALL	FSRDB		;READ IN ACCTING ENTRY
	BCS	30$		;ERROR
	MOV	UDC(R5),MNTDCR(R4)	;DATE OF CREATION
	MOV	UTC(R5),MNTTCR(R4)	;TIME OF CREATION
	TST	(PC)+		;SUCCESS - POP OVER SEC
30$:	SEC
	RETURN

GLOBAL	<FIBUF,FQSATT,MNTFLG,PKSTAT>
.DSABL	LSB

.SBTTL	CHBB?  - CHOOSE THE CORRECT BAD BLOCK FILE

;+
; CHBBI - CHOOSE THE CORRECT INPUT BAD BLOCK FILE
; CHBBO - CHOOSE THE CORRECT OUTPUT BAD BLOCK FILE
;
;	CALL:	CALL	CHBB?
;
;	RETURN:	R5 -> SELECTED BAD BLOCK FILE
;		BADBI WILL CONTAIN THE FILE ADDRESS (IF INPUT)
;		BADBO WILL CONTAIN THE FILE ADDRESS (IF OUTPUT)
;		CBADI/CBADO SET UP APPROPRIATELY
;-

.ENABL	LSB

CHBBI:	MOV	#BADBI,R5	;INPUT DEVICE ENTRY
	BIT	#OPRE!OPIN,OPFLG	;THIS A RESTORE OR INSTALL?	;JDB005
	BEQ	20$		;NO - GO SELECT THE SMALL ONE
	BR	10$		;YES - GO SELECT THE BIG ONE

CHBBO:	MOV	#BADBO,R5	;OUTPUT DEVICE ENTRY
	BIT	#OPSV!OPIM,OPFLG ;THIS A SAVE ?
	BEQ	20$		;NO - GO SELECT THE SMALL ONE
10$:	MOV	#BADBL,(R5)	;SELECT THE BIG ONE
	BR	30$		;FINISH

20$:	MOV	#BADBS,(R5)	;SELECT THE SMALL ONE
30$:	MOV	(R5)+,(R5)	;CURRENT BAD BLOCK POINTER (CBAD?)
	MOV	(R5)+,(R5)	;NEW BB ENTRY POINTER (NEW?BB)
	MOV	(R5)+,(R5)+	;CURRENT NEW BB POINTER (CNBB?)
	CLR	(R5)+		;NUMBER OF BAD BLOCKS (NBAD?)
	CLR	(R5)		;NUMBER OF UNKNOWN BB'S (UNKBB?)
	MOV	-4(R5),R5	;R5 -> CHOSEN FILE
	RETURN

GLOBAL	<BADBI,BADBO,BADBS,BADBL,OPFLG>
.DSABL	LSB

.SBTTL	SAVBAD - GET SAVE VOLUME BAD BLOCKS

;+
; SAVBAD - READ IN THE SAVE VOLUME BAD BLOCK FILES (PRIMARY &
;	   SECONDARY)
;
;	CALL:	CALL	SAVBAD
;
;	RETURN:	C=0 - OPERATION SUCCESSFUL
;		      R1 = # BAD BLOCKS
;		C=1 - COULDN'T READ BAD BLOCK FILES OR
;		      TOO MANY BAD BLOCKS
;-

.ENABL	LSB

SAVBAD:	REGSCR			;SAVE REGISTERS
	CALL	CHNSEL		;SET UP TO DO I/O
	MOV	BADADR,R2	;GET FBN OF BAD BLOCK FILE
	MOV	BADADR+2,R3
	MOV	#1024.,R1	;WE WANT FOUR BLOCKS
	MOV	#SATBUF,BUFPTR	;POINT TO I/O BUFFER
	CALL	RDSKIO,R5	;READ 'EM
	  BR	50$		;BAD BLOCK ERROR
	  CLR	R1		;BAD BLOCK COUNT
	MOV	#SATBUF,R0	;POINT TO THE BEGINNING OF 'EM
10$:	TST	(R0)+		;LSB ZERO ?
	BNE	20$		;NO - WE KNOW ONE IS HERE
	TST	(R0)		;YES - MSB ZERO ?
	BEQ	40$		;YES - END OF LIST
20$:	TST	(R0)+		;SKIP PAST MSB
30$:	INC	R1		;YES - COUNT IT
	CMP	R1,MAXBB	;MORE THAN 161 ?
	BHI	50$		;YES - ERROR
	BR	10$		;CHECK FOR MORE

40$:	TST	(PC)+		;ALL DONE - CLC AND POP OVER SEC
50$:	SEC
	MOV	R1,TOS.R1(SP)	;R1 WILL EQUAL # OF BAD BLOCKS ON EXIT
	RETURN

GLOBAL	<SATBUF,MAXBB>
.DSABL	LSB

.SBTTL	LBNFBN - CONVERT LBN'S TO FBN'S

;+
; LBNFBN - CONVERT AND TRANSFER INPUT LBN TABLE TO OUTPUT FBN TABLE
;
;	CALL:	R0 = ADDRESS OF LBN TABLE
;		R1 = # OF LBN'S
;		R4 = ADDRESS OF MOUNT TABLE
;		R5 = ADDRESS OF OUTPUT TABLE
;		CALL	LBNFBN
;
;	RETURN:	IT HAS BEEN DONE
;		TMPWRD POINTS TO THE FIRST UNOCCUPPIED POSITION IN FILE
;-

.ENABL	LSB

LBNFBN:	REGSCR			;SAVE REGISTERS
	MOV	R5,R2		;ADDRESS OF OUTPUT TABLE
	MOVB	MNTDCS(R4),R3	;DEVICE CLUSTER SIZE
	DEC	R3		; - 1
	TST	R1		;ANY LBN'S ?
	BEQ	30$		;NO - NOTHING TO DO
	BR	10$		;ON WITH IT

SAVFBN:	REGSCR
10$:	MOV	(R0)+,R5	;GET LSB
	MOV	(R0)+,R4	;GET MSB
	SUB	R3,R5		;SUBTRACT (DCS-1) FROM LBN
	SBC	R4
	BIT	#OPSV,OPFLG	;DESTINATION A SAVE VOLUME ?
	BEQ	20$		;NOPE
	SUB	#1,R5		;SFBN = (((FBN - 1)/8.) * 8.) + 1
	SBC	R4
	ASHC	#-3,R4		;DIVIDE BY 8.
	ASHC	#3,R4		;MULTIPLY BY 8.
	ADD	#1,R5		;ADD 1
	ADC	R4
20$:	MOV	R5,(R2)+	;PUT FBN IN OUTPUT TABLE
	MOV	R4,(R2)+
	SOB	R1,10$		;DO ALL LBN'S
	MOV	R2,TOS.R5(SP)	;R5 WILL POINT TO END OF ENTRIES IN FILE
30$:	CALLX	GETTTY		;KEEP GOING
	RETURN

	.DSABL	LSB
GLOBAL	<OPFLG>

.SBTTL	RSTBAD - GET RSTS BAD BLOCKS

;+
; RSTBAD - EXTRACT THE BAD BLOCK DCN'S FROM A RSTS DISK
;
;	CALL:	CALL	RSTBAD
;
;	RETURN:	C=0 - OPERATION SUCCESSFUL
;		      R1 = # BAD BLOCKS
;		C=1 - TOO MANY BAD BLOCKS OR
;		      COULDN'T READ BAD BLOCK FILE
;-

.ENABL	LSB

RSTBAD:	REGSCR			;AS ALWAYS
	CALL	CHNSEL		;SET UP CHANNEL
	CLR	R4		;CLEAR BAD BLOCK COUNTER
	MOV	#FQBADB+FQPPN,R0	;R0 -> [0,1]BADB.SYS
	CALL	FSSDU		;LOOK IT UP
	BCS	60$		;YES
	MOV	UAA(R5),R3	;GET LINK TO ACCOUNTING ENTRY
	MOV	UAR(R5),R1	;GET LINK TO 1ST RETRIEVAL ENTRY
	CALL	FSRDB		;GET ACCOUNTING ENTRY
	BCS	60$		;ERROR
	TST	USIZ(R5)	;SIZE OF BADB.SYS = 0 ?
	BEQ	50$		;YUP - GET OUT
	MOV	R1,R3		;SETUP FOR 1ST RETRIEVAL ENTRY
	MOV	#SATBUF,R2	;WHERE THE BAD BLOCK DCN'S WILL GO
20$:	CALL	FSRDB		;GET RETRIEVAL ENTRY
	BCS	60$		;ERROR
	MOV	(R5)+,R3	;GET POINTER TO NEXT
	MOV	#7,R1		;# DCN'S IN BLOCKETTE
30$:	INC	R4		;BADB COUNT
	CMP	R4,MAXBB	;TOO MANY ?
	BHI	60$		;YES - END WITH ERROR
	MOV	(R5)+,(R2)+	;GET DCN
	BEQ	40$		;IF ITS ZERO WE'RE DONE
	SOB	R1,30$		;GET NEXT
	TST	R3		;ANY MORE ENTRIES ?
	BNE	20$		;YES - GO GET IT
	BR	50$		;NO - WE'RE DONE

40$:	DEC	R4		;ZERO ENTRY DOESN'T COUNT
50$:	MOV	R4,TOS.R1(SP)	;SET R1 TO COUNT ON RETURN
	TST	(PC)+		;WE'RE SAFE THIS WAY
60$:	SEC
	RETURN

GLOBAL	<FQBADB,SATBUF,MAXBB>
.DSABL	LSB

.SBTTL	SKPREC - SKIP MAGTAPE RECORDS

;+
; SKPREC - SKIP R5 RECORDS ON MAGTAPE (R5 CAN BE NEGATIVE OR POSITIVE)
;
;	CALL:	R0 = MAGTAPE INDEX
;		R1 = MAGTAPE UNIT #
;		R5 = NUMBER (+ OR -) OF RECORDS TO SKIP
;		CALL	SKPREC
;
;	RETURN:	C-BIT INDICATES SUCCESS OR FAILURE
;		R5 = # RECORDS NOT SKIPPED
;-

.ENABL	LSB

SKPREC:	REGSCR			;SAVE REGISTERS
	MOV	#4,20$		;DEFAULT IS FORWARD SKIP (4)
	TST	R5		;ANALYZE # RECORDS TO SKIP
	BEQ	40$		;NONE - GET OUT
	BGT	10$		;GO DO FORWARD SKIP
	NEG	R5		;WILL DO BACKSPACE
	INC	20$		;MAKE FUNCTION BACKSPACE (5)
10$:	MOV	#1,R2		;SKIP ONE ONLY (SO WE CAN RESUME AFTER ERROR)
	CALL	MTSPC,R5	;DO SKIP
20$:	 .WORD	0		;FUNCTION
	BCS	60$		;ERROR
	SOB	R5,10$		;SKIP ALL RECORDS REQUESTED
30$:	MOV	R5,TOS.R5(SP)	;SEE IF ANY NOT SKIPPED
	BNE	50$		;YES - EXIT WITH ERROR
40$:	TST	(PC)+		;SUCCESS EXIT
50$:	SEC			;ERROR EXIT
	RETURN

60$:	CMPB	#NOROOM,IOERR	;'NO ROOM FOR USER'?
	BNE	70$		;NO - RETRY
	DEC	R5		;YES - WE REALLY DID SKIP ONE
	BR	30$		;EXIT

70$:	CALL	RETRY		;PROMPT FOR RETRY
	BR	10$		;GO RETRY

.DSABL	LSB
GLOBAL	<IOERR>

.SBTTL	ADVEOF - ADVANCE TO EOF

;+
; ADVEOF - ADVANCE TAPE FORWARD UNTIL R5 EOFS ARE PASSED
;
;	CALL:	R0 = DEVICE INDEX
;		R1 = DEVICE UNIT #
;		R5 = # EOFS TO PASS
;		CALL	ADVEOF
;
;	RETURN:	C-BIT ON INDICATES EOT DETECTED
;-

.ENABL	LSB

ADVEOF:	REGSCR			;SAVE REGISTERS
	TST	R5		;ANY ADVANCES REQUESTED ?
	BEQ	20$		;NO - EXIT
10$:	MOV	#32767.,R2	;LOOOOOONG ADVANCE
	CALL	MTSPC,R5,4.	;DO IT
	BCS	40$		;ERROR
	CALL	MTSPC,R5,7.	;GET TAPE STATUS
	BCS	50$		;ERROR
	BIT	#128.,R3	;EOF DETECTED ?
	BEQ	10$		;NO - KEEP GOING
	SOB	R5,10$		;YES - DO FOR REQUESTED # OF EOF'S

20$:	TST	(PC)+
30$:	SEC
	RETURN

40$:	CMPB	#NOROOM,IOERR	;NO ROOM FOR USER ?
	BEQ	30$		;YES - EXIT WITH ERROR
	CMPB	#DATERR,IOERR	;BAD BLOCK
	BEQ	30$		;YES - EXIT WITH ERROR
50$:	CALL	RETRY		;ERROR ROUTINE
	BR	10$		;RETRY

	.DSABL	LSB
GLOBAL	<IOERR>

.SBTTL	REWIND - GENERAL MAGTAPE FUNCTION CALL (FOR REWIND OR REWIND+OFFLINE)

;+
; REWIND - DO MAGTAPE FUNCTION CALL SPECIFIED IN R5
;		(BECAUSE THE ERROR RECOVERY PERFORMED HERE IS TO
;		IMMEDIATELY CALL RETRY ONLY OFFLINE/MAGTAPE SELECT
;		ERRORS SHOULD BE EXPECTED FROM THE CALL - 
;		THIS MEANS ONLY THE FOLLOWING CALLS SHOULD BE DONE
;		THROUGH THIS FUNCTION:
;				R5 = 3. -> REWIND
;				R5 = 1. -> REWIND AND OFFLINE)
;
;	CALL:	R0 = DEVICE INDEX
;		R1 = DEVICE UNIT
;		R5 = SPECIAL MAGTAPE FUNCTION TO DO (1. OR 3.)
;
;	RETURN: ITS DONE
;-

.ENABL	LSB

REWIND:	REGSCR			;SAVE REGISTERS
	MOV	#3,30$		;SET UP FOR REWIND
	BR	20$

REWOFF:	REGSCR			;SAVE REGISTERS
	MOV	#1,30$		;REWIND AND OFFLINE
20$:	CALL	MTSPC,R5	;DO IT
30$:	.WORD	0		;FUNCTION
	BCS	40$		;ERROR
	RETURN

40$:	CALL	RETRY		;QUERY USER FOR POSSIBLE RETRY
	BR	20$		;DO RETRY

.DSABL	LSB


.SBTTL	SAVIO  - DO I/O TO (OR FROM) A SAVE VOLUME

;+
; SAVIO - READ FROM OR WRITE TO A DISK OR MAGTAPE SAVE VOLUME
;
;	CALL:	CURFBN = FBN/RECNO (2 WORDS)
;		RECTYP = SAVE RECORD TYPE WANTED (BYTE)
;		I.DSQ+DSQCNT = NUMBER OF WORDS TO READ OR WRITE
;				(THIS NUMBER MUST BE <= 4096.)
;		BUFPTR = BUFPTR MUST CONTAIN (I.E., BE THE ADDRESS OF)
;			 THE RIGHT BUFFER ADDRESS)
;		NOTAG =  0 - I/O WITH TAGS
;		      <> 0 - I/O WITHOUT TAGS
;		      (FOR MAGTAPE ONLY)
;
;		CALL	SAVIO,R5,FUN
;
;	RETURN:	CURFBN = NEXT FBN/RECNO TO BE WRITTEN TO
;		+ 0	WRONG MAGTAPE RECORD OR NON-RECOVERABLE I/O ERROR
;		+ 2	BAD BLOCK ERROR
;		+ 4	EOF
;		+ 6	SUCCESS
;-

.ENABL	LSB

SAVIO:	MOV	(R5)+,DFUN	;GET THE FUNCTION
	MOV	BUFPTR,-(SP)	;SAVE THE BUFFER POINTER
	REGSAV			;SAVE REGISTERS
	MOV	I.DSQ+DSQCNT,R1	;GET WORD COUNT INTO R1
	CMP	#4096.,R1	;4096. WORDS MAX. FOR ANY SAVE I/O
	BHIS	10$		;WE'RE OK
	ERF	<"SAVIO">	;BAD SIZE SAVE TRANSFER

10$:	MOV	M.TBL,R4	;POINT TO CORRECT MOUNT TABLE
	MOV	CURFBN,R2	;GET CURRENT FBN (NEXT ONE TO WRITE TO/FROM)
	MOV	CURFBN+2,R3
20$:	MOV	R1,R5	;# WORDS TO TRANSFER
	SUB	#2048.,R5	;SEE IF WE HAVE MORE THAN 2048. WORDS
	BLE	30$		;NO - GO TRANSFER SPECIFIED # OF WORDS
	MOV	#2048.,R1	;YES - WILL ONLY XFER 1ST 2048. WORDS
30$:	TSTB	MNTIDX(R4) 	;MAGTAPE ?
	BMI	40$		;YES
	CALL	CHKSBA		;GET NEXT GOOD FBN
	BCS	70$		;EOF ERROR
	CALL	DSKIO,R5	;DO DISK I/O
DFUN:	.WORD	0		;THE FUNCTION
	  BR	80$		;BAD BLOCK ERROR
	  BR	50$		;GOOD OPERATION

40$:	CALL	MTIOS,R5	;DO MAGTAPE I/O
	  BR	90$		;UNRECOVERABLE I/O ERROR
	  BR	80$		;BAD BLOCK
	  BR	70$		;EOF
50$:	  TST	R5		;MORE TO WRITE ?
	BLE	60$		;NO - ALL DONE
	MOV	R5,I.DSQ+DSQCNT	;SET UP TO WRITE REST OF BUFFER
	ADD	#8.,R2		;ADD 8. (ONE SAVE CLUSTER) TO RECORD COUNT
	ADC	R3
	ADD	#4096.,BUFPTR	;ADDRESS OF SECOND HALF OF BUFFER
	BR	20$		;GO WRITE SECOND HALF

60$:	ADD	#8.,R2		;INCREMENT FBN/RECNO FOR EXIT
	ADC	R3
	ADD	#2,TOS.R5(SP)	;SUCCESS EXIT - RETURN + 6
70$:	ADD	#2,TOS.R5(SP)	;EOF EXIT - RETURN + 4
80$:	ADD	#2,TOS.R5(SP)	;BAD BLOCK ERROR - RETURN + 2
90$:	MOV	R2,CURFBN	;GET NEW FBN
	MOV	R3,CURFBN+2
	CALLX	REGRES,R5	;RESTORE REGISTERS
	MOV	(SP)+,BUFPTR	;RESTORE BUFFER POINTER
	RETURN	R5

.DSABL	LSB

GLOBAL	<I.DSQ,CURFBN>

.SBTTL	MAGTAPE I/O

;+
; MTIO  - GENERAL MAGTAPE I/O ROUTINE
; MTIOS - ENTRY POINT FOR SAVIO
;
;	CALL:	(R5) = FUNCTION (FOR MTIO)
;		DFUN  = FUNCTION (FOR MTIOS)
;		BUFPTR -> BUFFER FOR I/O
;		NOTAG =  0 -> CHECK TAG
;		      <> 0 -> DON'T CHECK TAG
;		R1 = NUMBER OF WORDS (- TAG IF TAG DESIRED) TO XFER
;		RECTYP = RECORD TYPE TO I/O
;		R2/R3 = RECORD NUMBER DESIRED
;
;		CALL	MTIO,R5,FUNCTION
;		CALL	MTIOS,R5
;
;	RETURN:	+ 0 - UNRECOVERABLE I/O ERROR
;		+ 2 - BAD BLOCK
;		+ 4 - EOF/NOROOM
;		+ 6 - SUCCESS !!!
;-

.ENABL	LSB

MTIO:	MOV	(R5)+,MAGFUN	;GET FUNCTION (REGULAR ENTRY POINT)
	BR	10$		;ON WITH IT

MTIOS:	MOV	DFUN,MAGFUN	;GET FUNCTION (SAVIO ENTRY POINT)
10$:	MOV	R1,I.DSQ+DSQCNT	;GET THE WORD COUNT
	MOV	R0,-(SP)	;SAVE R0
	MOV	R1,-(SP)	;SAVE R1
	MOV	BUFPTR,MAGBA	;GET BUFFER ADDRESS
	CALL	CCTRLC		;CTRL/C ? (WON'T RETURN IF THERE IS ONE)
	TST	NOTAG		;ARE WE USING TAGS ?
	BNE	20$		;NO
	SUB	#4,MAGBA	;YES - INCLUDE TAG IN I/O
	ADD	#2,I.DSQ+DSQCNT	;INCLUDE TAG IN WORD COUNT
	CALL	STOTWD		;STORE CONTENTS OF TAG AREA
	CMP	#WFUN,MAGFUN	;DOING A WRITE ?
	BNE	20$		;NO
	CALL	SETTAG		;SET UP TAG
20$:	CALL	DOMTIO		;DO THE I/O
	BCS	80$		;AN ERROR
	CMP	#RFUN,MAGFUN	;DOING A READ ?
	BNE	30$		;NO
	TST	NOTAG		;ARE WE DEALING IN TAGS ?
	BNE	30$		;NO
	CALL	CHKTAG,R4	;CHECK THE TAG
	  BR	90$		;BAD RECORD TYPE
	  BR	20$		;WRONG RECORD - SET UP FOR RETRY
30$:	  TST	(R5)+		;GOOD EXIT
40$:	TST	(R5)+		;EOF EXIT
50$:	TST	(R5)+		;BAD BLOCK EXIT
60$:	TST	NOTAG		;UNREC. I/O ERROR EXIT - TAGS A CONCERN HERE ?
	BNE	70$		;NO
	CALL	RESTWD		;RESTORE TAG
70$:	MOV	(SP)+,R1	;RESTORE R1
	MOV	(SP)+,R0	;RESTORE R0
	RETURN	R5

80$:	CMPB	#DATERR,IOERR	;BAD BLOCK ERROR ?
	BEQ	100$		;YUP
	CMPB	#MAGRLE,IOERR	;BAD RECORD LENGTH ?
	BEQ	100$		;YES - TREAT AS BAD BLOCK
	CMPB	#NOROOM,IOERR	;NO ROOM ?
	BEQ	110$		;YUP
	CMPB	#EOF,IOERR	;EOF ?
	BEQ	110$		;YES - RETURN SAME AS NO ROOM
	CALL	RTRMAG		;SETUP TO RETRY
	BCC	20$		;OK
90$:	MOV	#NOREC,ABTADR	;UNRECOVERABLE ERROR
	BR	60$		;EXIT BAD

100$:	CALL	MRESET		;RESET TAPE DRIVE
	BR	50$		;TREAT AS BAD BLOCK

110$:	CALL	MRESET		;RESET TAPE DRIVE
	BR	40$		;TREAT AS NO ROOM

.DSABL	LSB
GLOBAL	<IOERR,I.DSQ>

.SBTTL	RTRMAG - SET UP TO RETRY MAGTAPE I/O

;+
; RTRMAG - SET UP TO RETRY MAGTAPE I/O
;
;	R2/R3	- DESIRED RECORD NUMBER
;	RECTYP	- DESIRED RECORD TYPE
;	IOERR	- CONTAINS CURRENT ERROR
;	CALL	RTRMAG
;
;	RETURNS: (IF USER WANTED TO RETRY)
;	C = 0	WE HAVE SET THE TAPE TO THE RIGHT SPOT TO CONTINUE I/O
;	C = 1	NON-RECOVERABLE I/O ERROR
;-

.ENABL	LSB

RTRMAG:	REGSCR			;USER WANTS TO RETRY SO SAVE REGISTERS
	MOV	I.DSQ+DSQCNT,-(SP)	; AND SAVE TRANSFER WORD COUNT
	MOV	MAGBA,-(SP)	; AND SAVE BUFFER ADDRESS
	MOV	MAGFUN,-(SP)	; AND SAVE FUNCTION
	MOVB	HIGHBF,-(SP)	; AND SAVE HIGH BUFFER INDICATOR
10$:	CALL	RETRY		;QUERY USER FOR RETRY
	CALL	MRESET		;RESET TAPE DRIVE
	CALL	REWIND		;REWIND TAPE
	TST	NOTAG		;DO OUR RECORDS HAVE TAGS ?
	BNE	80$		;NO - WE CAN'T RECOVER
	MOV	#2,R5		;WE WILL ADVANCE AT LEAST 2 EOF'S
	MOVB	RECTYP,R4	;GET RECORD TYPE IN REGISTER
	CMP	#SAVLAB,R4	;WERE WE I/O'ING SAVE LABEL ?
	BEQ	40$		;YES - GO DO ADVANCE
	CMP	#SATTS,R4	;WERE WE I/O'ING THE SATTS ?
	BNE	20$		;NO
	INC	R5		;ANOTHER EOF
	CMP	R2,#32.		;RECORD # LT 32. ? (FIRST SATT)
	BLO	40$		;YES - GO DO ADVANCE
	INC	R5		;SECOND SATT - ANOTHER EOF
	BR	40$		;GO DO ADVANCE

20$:	CMP	#DATBLK,R4	;WERE WE I/O'ING DATA BLOCKS ?
	BEQ	30$		;YES
	TSTB	SSVOL+SSDAT	;NO - MUST BE DIRECTORY BLOCKS -
				; IS THERE DATA ON THIS VOLUME ?
	BEQ	30$		;NO
	INC	R5		;YES - ANOTHER EOF
30$:	INC	R5		;AND YET ANOTHER EOF TO SKIP
	CMPB	#1,SSVOL+SSSEQ	;IS THIS THE FIRST VOLUME ?
	BNE	40$		;NO - GO DO ADVANCE
	CMPB	(R5)+,(R5)+	;YES - TWO MORE EOF'S
40$:	CALL	ADVEOF		;DO THE ADVANCE
	BCS	80$		;EOT - THIS IS VERY BAD
	CMP	#SAVLAB,R4	;WERE WE I/O'ING SAVE LABEL ?
	BEQ	70$		;YES - WE'RE ALL SET UP - EXIT
	SUB	#8.,R2		;WE WILL LOOK FOR RECORD BEFORE RECORD
	SBC	R3		; WE WERE I/O'ING
	MOV	#RFUN,MAGFUN	;WE'RE GOING TO READ FOR A WHILE
	MOV	#9.,I.DSQ+DSQCNT ;AND ONLY 18. BYTES/READ (ALL WE NEED IS
				 ; THE TAG AREA)
	MOV	#MAGPAD,MAGBA	;WILL READ INTO SCRATCH PAD
	CLRB	HIGHBF		;DOING LOW BUFFER I/O
50$:	CALL	DOMTIO		;DO MAGTAPE I/O
	BCS	90$		;ERROR?
60$:	CLRB	IOERR		;MAKE SURE ERROR FLAG IS CLEAR	
	CALL	CHKTAG,R4	;CHECK THE TAG
	  BR	80$		;BAD RECORD TYPE
	  BR	50$		;WRONG RECORD - WE'RE SET UP FOR RETRY
70$:	  TST	(PC)+		;GOOD EXIT
80$:	SEC			;ERROR EXIT
	MOVB	(SP)+,HIGHBF	;RESTORE HIGH MEMORY INDICATOR
	MOV	(SP)+,MAGFUN	;RESTORE FUNCTION
	MOV	(SP)+,MAGBA	;RESTORE BUFFER ADDRESS
	MOV	(SP)+,I.DSQ+DSQCNT	;RESTORE XFER WORD COUNT
	RETURN			;ALL DONE

90$:	CALL	MRESET		;RESET TAPE DRIVE
	CMPB	#MAGRLE,IOERR	;MAGTAPE RECORD LENGTH ERROR?
	BEQ	60$		;YES - RESUME
	ADD	#8.,R2		;BACK TO THE RECORD WE WERE "I/O"ING
	ADC	R3		;BOTH WORDS
	BR	10$		;DO IT

.DSABL	LSB
GLOBAL	<IOERR,I.DSQ,SSVOL,HIGHBF>

.SBTTL	DOMTIO - DO MT I/O

.ENABL	LSB

DOMTIO:	CALL	MAGSET		;GET TAPE UNIT/INDEX
	CALLX	MAGIO,R5	;DO IT
MAGFUN:	.WORD	0		;THE FUNCTION
MAGBA:	.WORD	0		;THE BUFFER ADDRESS
	BCC	20$		;NO PROBLEM
	CMPB	#HNGDEV,IOERR	;LOOK LIKE A HUNG DEVICE?
	BNE	10$		;NO
	CALL	MTSPC,R5,7.	;MUST GET TAPE STATUS
	BCS	10$		;WE WERE REALLY HUNG
	MOVB	#DATERR,IOERR	;TEMPORARILY TREAT AS DATA ERROR
	BIT	#2040,R3	;IS TAPE OFFLINE (OR WRITE-LOCKED)?
	BEQ	10$		;NO - LEAVE AS DATA ERROR
	INCB	IOERR		;ITS HUNG - BUMP TO HNGDEV
10$:	SEC			;MAKE SURE CARRY STILL SET
20$:	RETURN

.SBTTL	MAGSET - SET DEVICE INDEX AND UNIT # IN R0 AND R1

MAGSET:	MOV	SYSNDX,R0	;THE INDEX
	MOV	SYSUNT,R1	;THE UNIT
	RETURN

GLOBAL	<SYSNDX,SYSUNT>
.DSABL	LSB

.SBTTL	MTSPC  - MAGTAPE SPECIAL FUNCTION CALL

;+
; MTSPC - MAGTAPE SPECIAL FUNCTION CALL
;
;	CALL:	CALL	MTSPC,R5,FUN
;
;	WHERE FUN IS:				AND R2 IS:
;		1 - REWIND AND OFFLINE		(UNUSED)
;		2 - WRITE EOF			(UNUSED)
;		3 - REWIND			(UNUSED)
;		4 - SKIP FORWARD		RECORDS TO SKIP
;		5 - BACKSPACE			RECORDS TO BACKSPACE
;		6 - SET DENSITY			DENSITY
;		7 - RETURN DRIVE STATUS		(UNUSED)
;
;	RETURN:	C=0 - SUCCESS
;		C=1 - FAILURE - IOERR IS THE ERROR
;
;	IF FUN IS:		THEN R3 IS:
;		1		(UNKNOWN)
;		2		(UNKNOWN)
;		3		(UNKNOWN)
;		4		RECORDS NOT SKIPPED OVER
;		5		RECORDS NOT BACKSPACED OVER
;		6		DENSITY (SAME AS PASSED)
;		7		DRIVE STATUS
;-

.ENABL	LSB

MTSPC:	MOV	(R5)+,10$	;GET THE FUNCTION
	CALL	MAGSET		;GET THE TAPE INDEX/UNIT
5$:	CALLX	MAGSPC,R5	;DO IT
10$:	.WORD	0		;WHERE THE FUNCTION GOES
	BCC	20$		;NO ERROR
	CALL	MRESET		;AN ERROR - RESET THE TAPE DRIVE
	SEC			;INDICATE AN ERROR
20$:	RETURN	R5

.DSABL	LSB

.SBTTL	MRESET - MAGTAPE RESET

.ENABL	LSB

MRESET:	MOV	R1,-(SP)	;SAVE R1
	MOV	R4,-(SP)	;SAVE R4
	MOV	R5,-(SP)	;SAVE R5
	MOVB	IOERR,-(SP)	;SAVE ERROR INDICATOR
10$:	BIT	#ONLIN,MNTFLG	;ARE WE ONLINE?				;JDB011
	BEQ	20$		;BRANCH IF NOT - INIT WANTS A NOP	;JDB011
	CALL	MAGSET		;GET TAPE UNIT/INDEX
	CALLX	MXRSET		;RESET THE TAPE
	BCS	30$		;PROBLEM
	MOV	M.TBL,R5	;POINT TO CORRECT MOUNT TABLE
	MOV	MNTDEN(R5),R5	;GET TAPE DENSITY
	BEQ	20$		;NO DENSITY SET UP YET
	CALL	ERRDS		;SET TAPE'S DENSITY (ERROR ENTRY)
	BCS	30$		;ERROR IN SET
20$:	MOVB	(SP)+,IOERR	;RESTORE ERROR INDICATOR
	MOV	(SP)+,R5	;RESTORE R5
	MOV	(SP)+,R4	;RESTORE R4 (WIPED OUT BY MXRSET)
	MOV	(SP)+,R1	;RESTORE R1
	RETURN

30$:	MOVB	#HNGDEV,IOERR	;INDICATE DEVICE WAS HUNG
	CALL	RETRY		;DOES USER WANT TO RETRY?
	BR	10$		;YUP
	
.DSABL	LSB
GLOBAL	<IOERR>

.SBTTL	STOTWD - STORE THE MAGTAPE TAG AREA

;+
; STOTWD - STORE THE MAGTAPE TAG AREA
; RESTWD - RESTORE MAGTAPE TAG AREA
;
;	CALL:	HIGHBF SET IF DOING I/O TO/FROM IOBUFF
;		CALL	???TWD
;
;	RETURN:	IT'S DONE
;-

.ENABL	LSB

STOTWD:	TSTB	HIGHBF		;I/O TO/FROM IOBUFF ?
	BEQ	10$		;NO - GET OUT
	MOV	MAGBA,-(SP)	;STACK OFFSET INTO IOBUFF
	CALLX	GETIOB		;GET THE WORD
	MOV	(SP),TMPDWD	;STORE FIRST TAG WORD
	MOV	MAGBA,(SP)	;STACK OFFSET AGAIN
	ADD	#2,(SP)		;MAKE IT OFFSET OF 2ND TAGWORD
	CALLX	GETIOB		;GET THE WORD
	MOV	(SP)+,TMPDWD+2	;STORE SECOND TAG WORD
	BR	10$		;ALL DONE

RESTWD:	TSTB	HIGHBF		;I/O TO/FROM IOBUFF
	BEQ	10$		;NO - GET OUT
	MOV	MAGBA,-(SP)	;STACK IOBUFF OFFSET
	MOV	TMPDWD,-(SP)	;STACK FIRST TAG WORD
	CALLX	PUTIOB		;PUT FIRST TAG WORD
	ADD	#2,(SP)		;OFFSET FOR SECOND TAG WORD
	MOV	TMPDWD+2,-(SP)	;SECOND TAG WORD
	CALLX	PUTIOB		;PUT SECOND TAG WORD
	TST	(SP)+		;POP OFFSET
10$:	RETURN

.DSABL	LSB
GLOBAL	<HIGHBF>

.SBTTL	CHKTAG - CHECK THE MAGTAPE RECORD TAG

;+
; CHKTAG - CHECK THE MAGTAPE RECORD TAG
;
;	CALL:	HIGHBF = HIGH MEMORY I/O INDICATOR
;		RECTYP = DESIRED RECORD TYPE
;		R2/R3  = DESIRED RECORD NUMBER
;		MAGBA  = ADDRESS OF TAG
;		CALL	CHKTAG,R4
;
;	RETURN:	+ 0 - BAD RECORD
;		+ 2 - WRONG RECORD - WE ARE SET UP FOR A RETRY
;		+ 4 - RECORD OK
;-

.ENABL	LSB

CHKTAG:	MOV	R0,-(SP)	;SAVE R0
	MOV	R5,-(SP)	;SAVE R5
	MOV	MAGBA,R0	;GET TAG ADDRESS
	TSTB	HIGHBF		;I/O TO/FROM IOBUFF ?
	BNE	20$		;YES
	MOV	2(R0),-(SP)	;STACK MSB/RECTYP
	CMPB	(SP),RECTYP	;RIGHT RECORD TYPE ?
	BNE	50$		;NO - FAIL
	CMPB	1(SP),R3	;RIGHT RECORD # MSB ?
	BNE	10$		;NO - GO TRY TO CORRECT
	CMP	(R0),R2		;RIGHT RECORD # LSB ?
	BEQ	30$		;YES - EXIT SUCCESSFUL
10$:	MOV	(R0),TMPWRD	;GET RECORD # LSB
	BR	70$		;GO TO CORRECTION ROUTINE

20$:	MOV	#2,-(SP)	;OFFSET FOR SECOND WORD OF TAG
	ADD	R0,(SP)		; IN BUFFER
	CALLX	GETIOB		;GET IT
	CMPB	(SP),RECTYP	;RIGHT RECORD TYPE ?
	BNE	50$		;NO - EXIT WITH ERROR
	CMPB	1(SP),R3	;RIGHT RECORD NUMBER MSB ?
	BNE	60$		;NO - GO TRY TO CORRECT CONDITION
	MOV	R0,-(SP)	;THIS TIME WE WANT THE FIRST TAG WORD
	CALLX	GETIOB		;GET IT
	MOV	(SP)+,TMPWRD	;THIS IS IT
	CMP	TMPWRD,R2	;RIGHT RECORD NUMBER LSB ?
	BNE	70$		;NO - GO TRY TO CORRECT CONDITION
30$:	TST	(R4)+		;SUCCESSFUL EXIT
40$:	TST	(R4)+		;READ RETRY EXIT
50$:	TST	(SP)+		;POP MSB/RECTYP TAG WORD
	MOV	(SP)+,R5	;RESTORE R5
	MOV	(SP)+,R0	;RESTORE R0
	RETURN	R4		;BAD RECORD EXIT

GLOBAL	<HIGHBF>


60$:	MOV	R0,-(SP)	;ADDRESS OF FIRST TAG WORD
	CALLX	GETIOB		;GET IT
	MOV	(SP)+,TMPWRD	; AND SAVE IT
70$:	CLRB	(SP)		;ISOLATE MSB OF RECORD NUMBER
	SWAB	(SP)		;PUT IN LOW BYTE
	MOV	R2,-(SP)	;SAVE R2
	MOV	R3,-(SP)	;SAVE R3
	SUB	TMPWRD,R2	;DETERMINE HOW FAR TO SKIP (FBN - CUR.POS.)
	SBC	R3
	SUB	4(SP),R3
	MOV	R3,R5		;SWAP R2 AND R3
	MOV	R2,R3		; FOR THE
	MOV	R5,R2		; DIVIDE
	DIV	#8.,R2		;RECORD NUMBERS ARE MULTIPLES OF 8.
	DEC	R2		;READ POINTED US AT THE NEXT SO SUBTRACT 1
	MOV	R2,R5		;GET # OF RECORDS
	CALL	SKPREC		;SKIP THE NECESSARY RECORDS
	MOV	(SP)+,R3	;RESTORE R3
	MOV	(SP)+,R2	;RESTORE R2
	BCS	50$		;AN ERROR ON SKIP - RETURN BAD RECORD
	BR	40$		;WE'RE ALL SET TO RE-I/O

.DSABL	LSB

.SBTTL	SETTAG - SET UP MAGTAPE RECORD PREFIX "TAG"

;+
; SETTAG - SET UP MAGTAPE RECORD PREFIX "TAG"
;
;	CALL:	R2/R3 = FBN/RECNO
;		MAGBA = BUFFER ADDRESS TO SETUP TAG
;		HIGHBF = IOBUFF I/O INDICATOR
;		RECTYP = RECORD TYPE
;		CALL	SETTAG
;
;	RETURN:	TAG IS SET UP IN FIRST FOUR BYTES OF SPECIFIED BUFFER
;-

.ENABL	LSB

SETTAG:	MOV	R0,-(SP)	;SAVE R0
	MOV	MAGBA,R0	;GET BUFFER ADDRESS
	TSTB	HIGHBF		;I/O TO/FROM IOBUFF ?
	BNE	10$		;YES
	MOV	R2,(R0)+	;MOVE IN FBN LSB
	MOVB	RECTYP,(R0)+	;THE RECORD TYPE
	MOVB	R3,(R0)		;THE FBN MSB
	BR	20$		;ALL DONE

10$:	MOV	R0,-(SP)	;MOVE BUFFER OFFSET ONTO STACK
	MOV	R2,-(SP)	;MOVE LSB OF RECORD NUMBER
	CALLX	PUTIOB		;PUT IT
	ADD	#2,(SP)		;NEW OFFSET
	TST	-(SP)		;PUSH STACK
	MOVB	RECTYP,(SP)	;PUT RECORD TYPE INTO STACKED WORD
	MOVB	R3,1(SP)	;PUT MSB OF RECORD # INTO STACKED WORD
	CALLX	PUTIOB		;PUT IT
	TST	(SP)+		;POP OFFSET OFF THE STACK
20$:	MOV	(SP)+,R0	;RESTORE R0
	RETURN

.DSABL	LSB
GLOBAL	<HIGHBF>

.SBTTL	CHKSB? - CHECK AGAINST THE SAVE VOLUME BAD BLOCK LIST

;+
; CHKSBA - CHECK AGAINST THE BAD BLOCK LIST
; CHKSBN - DO SAME BUT DON'T UPDATE CBADO/CBADI
;
;	CALL:	R2/R3 = FBN TO CHECK AGAINST
;		NBAD? = # BAD BLOCKS IN APPROPRITE BAD BLOCK FILE
;		CBAD? = CURRENT BAD BLOCK TO CHECK AGAINST (CHKSBA)
;		TMPCBO= CURRENT BAD BLOCK TO CHECK AGAINST (CHKSBN)
;		CALL	CHKSB?
;
;	RETURN:	R2/R3 = FBN OF NEXT GOOD SAVE CLUSTER
;		CBAD? UPDATED IF NECESSARY (CHKSBA)
;		TMPCBO UPDATED IF NECESSARY (CHKSBN)
;-

.ENABL	LSB

CHKSBN:	MOV	R0,-(SP)	;SAVE R0
	MOV	R4,-(SP)	;SAVE R4
	CLR	R4		;R4=0 => NO-UPDATE ENTRY
	MOV	TMPCBO,R0	;GET ADDRESS OF OLD CURRENT BAD BLOCK
	BR	20$		;ON WITH IT

CHKSBA:	MOV	R0,-(SP)	;SAVE R0
	MOV	R4,-(SP)	;SAVE R4
	MOV	(SP),R4		;R4<>0 => UPDATE ENTRY
	MOV	CBADO,R0	;ADDRESS OF CURRENT OUTPUT BAD BLOCK
	CMP	M.TBL,MNTTBL	;SAVE VOLUME INPUT ?
	BNE	30$		;NO - ITS OUTPUT
	MOV	CBADI,R0	;YES - GET CORRECT ADDRESS INTO R0	
20$:	CMP	M.TBL,MNTTBL	;AGAIN - SAVE VOLUME INPUT ?
	BNE	30$		;NO -IT'S OUTPUT
	TST	NBADI		;ANY INPUT BAD BLOCKS ?
	BEQ	100$		;NO - EXIT
	CMP	R0,NEWIBB	;EXHAUSTED BAD BLOCK LIST ?
	BEQ	100$		;YES - EXIT
	BR	40$		;NO - WE'VE STILL GOT SOME

30$:	TST	NBADO		;ANY OUTPUT BAD BLOCKS ?
	BEQ	100$		;NO - EXIT
	CMP	R0,NEWOBB	;EXHAUSTED BAD BLOCK LIST ?
	BEQ	100$		;YES - EXIT
40$:	CMP	R3,2(R0)	;IS CURRENT MSB GTR. THAN BAD BLOCK MSB ?
	BLOS	60$		;NO - WE'LL CHECK AGAINST THIS ONE
50$:	CMP	(R0)+,(R0)+	;MOVE R0 UP TO NEXT BAD BLOCK LIST ENTRY
	BR	20$		;TRY IT

60$:	BNE	70$		;MSB'S UNEQUAL - WE'RE BEFORE THE CUR. BAD B
	CMP	R2,(R0)		;IS CUR. LSB GTR. THAN BAD BLOCK LSB ?
	BHI	50$		;YES - GO TRY NEXT BAD BLOCK IN LIST
	BNE	70$		;NO - NOT EQUAL MEANS WE'RE BEFORE BAD B
	ADD	#8.,R2		;WE GET HERE IF CURRENT FBN IS BAD
	ADC	R3		; INCREMENT UP TO NEXT SAVE CLUSTER
	BR	50$		;GO COMPARE AGAINST NEXT BAD BLOCK IN LIST

70$:	TST	R4		;IS THIS NO UPDATE ENTRY ?
	BNE	80$		;NO - GO DO UPDATE
	MOV	R0,TMPCBO	;UPDATE TEMP. BAD BLOCK POINTER
	BR	100$		;EXIT

80$:	CMP	M.TBL,MNTTBL	;SAVE VOLUME INPUT ?
	BNE	90$		;NO - ITS OUTPUT
	MOV	R0,CBADI	;UPDATE INPUT BAD BLOCK POINTER
	BR	100$		;EXIT

90$:	MOV	R0,CBADO	;UPDATE OUTPUT BAD BLOCK POINTER
100$:	MOV	M.TBL,R4	;POINT TO MOUNT TABLE
	CMP	MNTMFB+2(R4),R3	;COMPARE MSB'S
	BLO	120$		;REACHED SIZE LIMIT
	BHI	110$		;WE'RE OK - GET OUT
	CMP	MNTMFB(R4),R2	;COMPARE LSB'S
	BLO	120$		;REACHED SIZE LIMIT
110$:	TST	(PC)+
120$:	SEC
	MOV	(SP)+,R4	;RESTORE R4
	MOV	(SP)+,R0	;RESTORE R0
	RETURN

.DSABL	LSB
GLOBAL	<CBADO,NBADI,CBADI,MNTTBL,NEWIBB,NBADO,NEWOBB>

.SBTTL	ASKNLF - ASK A 2 PART QUESTION

;+
; ASKNLF - ASK A 2 PART QUESTION AND GET AN ANSWER - DON'T ALLOW LINE FEED
;
;	NOTE THAT NO DEFAULTS (INDICATED BY A LINE FEED) ARE ALLOWED
;	WAIT TIME IS UPDATED
;
;	CALL	ASKNLF,R5,<PTR TO SHORT TEXT, PTR TO 2ND PART OF LONG TEXT,
;			PTR TO 1ST PART OF LONG TEXT>
;
;	R1 -> ANSWER TEXT (ON WORD BOUNDARY)
;
;	Z=1, C=1 IFF ^Z TYPED
;	Z=0, C=0 OTHERWISE
;
; NOTE:	TYPES SHORT TEXT, GETS ANSWER IN KBUFF.
;	IF ANSWER IS <CR> OR ?, TYPES BOTH LONG AND SHORT TEXT AND REPEATS
;-

.ENABL	LSB

10$:	WARN	DEFMSG		;WARN THE USER THERE'S NO DEFAULT
	CLR	R2		;PRINT JUST SHORT FORM
	BR	20$		;AND REPEAT

ASKNLF:	MOV	(R5)+,60$	;GET SHORT QUESTION FORM
	MOV	(R5)+,40$	;GET 2ND PART OF LONG
	MOV	(R5)+,30$	;GET 1ST PART OF LONG
	MOV	R2,-(SP)	;SAVE THE CALLER'S R2
	CLR	R2		;FIRST TIME THROUGH, SHORT FORM ONLY
20$:	CALLX	RCTRLO		;FORCE RESET OF ^O
	TST	R2		;SHORT OR LONG?
	BEQ	50$		;SHORT ONLY
	CALLX	TYPECR		;LONG FORM ALWAYS BEGINS ON NEW LINE
	CALLX	MESSAG,R5	;1ST PART
30$:	.WORD	0		;1ST PART OF LONG
	CALLX	MESSAG,R5	; AND THE 2ND
40$:	.WORD	0		;2ND PART OF LONG
50$:	CALLX	MESSAG,R5	;TYPE THE SHORT FORM
60$:	.WORD	0		;SHORT FORM ADDRESS
	CALLX	GETIN		;AND GET AN ANSWER
	BNE	70$		;DOES NOT NEED HELP
	MOV	(PC),R2		;WANT THE LONG FORM FROM NOW ON
	BR	20$		;AND KEEP GOING

70$:	CMPB	(R1),#LF	;LINE FEED IS UNACCEPTABLE
	BEQ	10$		;INDICATE ERROR AND REPROMPT
	CMPB	(R1),#CTRLZ	;CTRL/Z?
	BEQ	80$		;YES -- RETURN Z=1, C=1
	TST	(PC)+		;NOTHING SPECIAL -- SET Z=0, C=0
80$:	SEC			;SET CARRY FOR ^Z
	MOV	(SP)+,R2	;RESTORE R2
	RETURN	R5		;EXIT

.DSABL	LSB

.SBTTL	??PRCD - PROCEED CHECKER

;+
; SRPRCD - SEE IF USER WANTS TO PROCEED WITH THE ENTIRE OPERATION
;	   (ONLY CALLED FROM DIALOGUE)
; MTPRCD - SEE IF USER WANTS TO PROCEED WITH A MOUNT
;
;	R1 -> STRING TO CHECK
;	ENTIRE = <> 0 IF CALL TO SRPRCD
;
;	CALL	??PRCD,R5
;
;	RETURN+0 - ^Z	FOUND
;	RETURN+2 - 'N'	FOUND (OR CTRL/Z WITH FULL COMMAND)
;	RETURN+4 - 'Y'	FOUND
;-
.ENABL	LSB
.ENABL	LC

10$:	WARN	DEFMSG		;WARN THE USER THAT THERE'S NO DEFAULT
	BR	20$		;TRY AGAIN

MTPRCD:	MOVTXT	MNTPRM,PRC1	;RETURN TO 'MOUNT PROMPT'
	CLR	ENTIRE		;INDICATE MOUNT RATHER THAN ENTIRE

SRPRCD:				;DIALOGUE PROCEED ENTRY
20$:	CALLX	YESNO,R5	;DOES THE USER WANT TO PROCEED?
	  .WORD	30$
	  GENTXT
	   .ASCII <200>
	   .ASCII "Type 'Yes' to proceed with the operation."<200>
	   .ASCII "Type 'No' to abort and return to the "
PRC1:	   .ASCII "                         "<200>
30$:	   .ASCIZ <200>"Proceed (Yes or No)? "
	  UNORG
	 BR	60$		;CTRL/Z -- PROBABLY RETURN+0
	 BR	10$		;LF  -- NO GOOD
	 BR	40$		;NO  -- RETURN +2
	 TST	(R5)+		;YES -- RETURN +4

40$:	TST	(R5)+		;FIX UP THE RETURN ADDRESS	
50$:	RETURN	R5

;	CTRL/Z
60$:	TST	ENTIRE		;ENTIRE OR JUST MOUNT?
	BEQ	50$		;JUST MOUNT -> RETURN+0
	TST	FULL		;ENTIRE (IN DIALOGUE) - FULL COMMAND?
	BNE	40$		;YES, TREAT AS IF NO
	BR	50$		;RETURN+0

.DSABL	LSB

.SBTTL	CVT$$B

;+
; CVT$$B - TRIM EVERYTHING OFF A STRING
;
; CALL:	R5 -> ASCIZ STRING
;	CALL	CVT$$B
;
; BACK:	R5 -> ASCIZ STRING (MAY BE SHORTER) AT SAME PLACE
;	MASK	TRIMS
;	   1	(DO NOT WANT TO TRIM PARITY) 				;004
;	   2	DISCARD ALL SPACES & TABS
;	   4	DISCARD CR LF FF ESC RO
;	  10	DISCARD LEADING SPACES & TABS
;	  20	REDUCE SPACES & TABS TO A SINGLE SPACE
;	  40	CONVERT LC TO UC
;	 100	CONVERT [ TO ( AND ] TO )
;	 200	DISCARD TRAILING SPACES & TABS
;	 400	PRESERVE QUOTED SUBSTRINGS
;	1000	MODIFY 4 (IF ON) TO DISCARD ALL CHARACTERS < 40 OR =177
;-

.ENABL	LSB

CVT$$B:	REGSCR			;THIS ENTRY TRIMS THE WORLD
	MOV	#-2,R0		;SET FLAG WORD TO TRIM ALL BUT PARITY	;004
	MOV	R5,R4		;R4 -> OUTPUT STRING
	CLR	-(SP)		;NOT IN QUOTES YET
	MOV	#160$,R1	;TABLE OF THINGS TO CLEAR
	ASH	#7,R0		;SHIFT THE MASK
	BCC	10$		;DUMP ONLY JUNK BYTES
	CLR	R1		;DUMP ALL BYTES < 40 OR =177
10$:	MOVB	(R5)+,R2	;GET A BYTE
	BEQ	120$		;DONE, SO EXIT
	BICB	R0,R2		;TURN OFF PARITY IF DESIRED
	TST	R0		;KEEP QUOTED BYTES?
	BPL	40$		;NO, QUOTES ARE NORMAL
	TSTB	(SP)		;YES, ARE WE WITHIN QUOTES?
	BEQ	20$		;NO
	CMPB	R2,(SP)		;YES, IS THIS THE ENDING QUOTE?
	BNE	110$		;NO
	CLRB	(SP)		;YES, CLEAR THE INSIDE FLAG
	BR	110$		;AND KEEP THE CLOSING QUOTE

20$:	CMPB	R2,#''		;START OF QUOTED STRING?
	BEQ	30$		;YES
	CMPB	R2,#'"		;MAYBE THIS KIND?
	BNE	40$		;NO
30$:	MOVB	R2,(SP)		;YES, START THE QUOTATION
	BR	110$		;AND KEEP THE OPENING QUOTE

40$:	BIT	R0,#4*200	;DISCARD TERMINATORS AND JUNK?
	BEQ	60$		;NO
	MOV	R1,R3		;YES, GET THE LIST POINTER
	BNE	50$		;DISCARD ONLY JUNK
	CMPB	R2,#40		;DISCARD ALL CONTROL CHARACTERS
	BLO	10$		;IT IS CONTROL
	CMPB	R2,#177		;ALSO DUMP RUBOUTS
	BEQ	10$
	BR	60$		;KEEP IT FOR NOW

50$:	CMPB	R2,(R3)+	;DOES THE BYTE MATCH THE LIST?
	BLO	50$		;NO, KEEP CHECKING
	BEQ	10$		;YES, DISCARD IT
	;BHI	60$		;NO, DON'T CHECK FURTHER
60$:	CMPB	R2,#40		;IS THIS A SPACE?
	BEQ	70$		;YES
	CMPB	R2,#11		;NO, MAYBE A TAB
	BNE	80$		;NOPE
70$:	BIT	R0,#2+10*200	;DISCARD ALL AND/OR LEADING ONES?
	BNE	10$		;YES, DISCARD THIS BYTE
	BIT	R0,#20*200	;REDUCE SPACES/TABS?
	BEQ	110$		;NO, JUST OUTPUT IT
	MOVB	#40,R2		;YES, THIS WILL BE A SPACE
	CMP	R4,5*2+2+2(SP)	;HAVE WE OUTPUT ANYTHING YET?
	BEQ	110$		;NO, CONVERT TO A SPACE AND OUTPUT IT
	CMPB	R2,-1(R4)	;YES, IS THE PRECEDING A SPACE?
	BEQ	10$		;IF SO, DISCARD THIS ONE
	BR	110$		;OUTPUT IT

80$:	BIT	R0,#40*200	;CONVERT LC TO UC?
	BEQ	90$		;NO
	CMPB	R2,#'A+40	;IS IT LC ALPHA?
	BLO	90$		;NO
	CMPB	R2,#'Z+40	;MAYBE?
	BHI	90$		;NO
	BICB	#40,R2		;YES, DOWNCASE IT
	BR	110$		;AND OUTPUT UC

90$:	BIT	#100*200,R0	;CONVERT [] TO ()?
	BEQ	110$		;NO
	CMPB	R2,#'[		;YES, IS IT [?
	BEQ	100$		;YES
	CMPB	R2,#']		;IS IT ]?
	BNE	110$		;NO
	DECB	R2		;IT IS ], SO ] = 135-64 = ) = 51
100$:	SUB	#'[-'(,R2	;AND         [ = 133-63 = ) = 50
110$:	MOVB	R2,(R4)+	;OUTPUT ONE BYTE TO NEW STRING
	BIC	#10*200,R0	;TURN OFF LEADING SPACE/TAB
	BR	10$		;LOOP FOR ANOTHER BYTE

120$:	TSTB	(SP)+		;WERE WE INSIDE QUOTES AT THE END?
	BNE	150$		;YES, DON'T TRIM TRAILING STUFF
	ASL	R0		;NO, DO WE DISCARD TRAILING SPACES/TABS?
	BPL	150$		;NO
130$:	MOVB	-(R4),R2	;GET LAST BYTE STORED
	CMP	R4,5*2+2(SP)	;BACK TOO FAR?
	BLO	140$		;YES, RETURN NULL STRING
	CMPB	R2,#40		;NO, IS IT SPACE?
	BEQ	130$		;YES, DISCARD IT
	CMPB	R2,#11		;MAYBE TAB?
	BEQ	130$		;DISCARD TAB
140$:	INC	R4		;KEEP LAST BYTE REMOVED
150$:	CLRB	(R4)+		;SET NULL STOPPER
	CALLX	GETTTY		;AND SO ON AND SO ON AND SO ON ...
	RTS	PC

160$:	.BYTE	177,33,15,14,12,0

.DSABL	LSB

.SBTTL	PRIERR - PRINT ERROR MESSAGE

;+
; PRIERR - PRINT A WARNING MESSAGE
;
;	CALL	PRIERR
;
;-

.ENABL	LSB

PRIERR:	TST	ERRADR		;ANY MESSAGE?
	BEQ	10$		;NOPE
	WARN			;PRINT IT
ERRADR:  .WORD	0		;ADDRESS OF ERROR MESSAGE
	CLR	ERRADR		;GET RID OF IT
	CLR	ABTADR		;WE MAY HAVE USED THIS TO SETUP ERRADR
10$:	RETURN			;ALL DONE

.DSABL	LSB

