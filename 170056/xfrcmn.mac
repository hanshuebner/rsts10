TITLE	XFRCMN,<COMMON TRANSFER ROUTINES>,0A,10-MAY-91,JDB

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL EDIT HISTORY

;+
;
;  001  14-APR-81  AWR	V7.0 PATCH 1.1.11 INSTALLED
;  002  17-JUL-81  JDB	FIXED BAD COMPARE WITH /NOERROR PROBLEM
;  003  12-OCT-81  JDB	FIXED LOOPING DURING SCAN PROBLEM
;  004  08-OCT-82  JDB	MODIFIED FOR NEW DIRECTORY STRUCTURE		;JDB004
;  005  17-FEB-83  MNB  ADD GFD ERROR MESSAGES				;MNB005
;  007  19-APR-84  JDB  FIX 'BAD DIRECTORY' ERROR IN SCAN               ;JDB007
;  008  25-APR-84  JDB  MODIFIED FOR INSTALL OPTION			;JDB008
;  009  27-APR-48  JDB  FIXED PPN REPORTED IN UFD/FILE ERROR MESSAGES	;JDB009
;
;-


.SBTTL	XFRCMN DATA

.EQUATE	UL.LNK,	UL.BLO!UL.CLO!UL.ENO	;LINK WORD BITS USED IN LINK PART
.EQUATE	UL.FLG,	<^C<UL.LNK>>		;LINK WORD FLAG BITS

	I.DATA
;	ITEMS USED IN DIRECTORY SCANS
CLUMAP:	.BLKW0	8.		;CLUSTER SIZE + 7 DCN'S
CHKECS:	.BLKW0			;ENTITY CLUSTER SIZE
CLUFLG:	.BLKW0			;CLUSTER MAP TYPE FLAG
MISSNG:	.BLKW0			;# OF UNFOUND INPUT BB'S OR RELOCATION ENTRIES
NDBS:	.BLKW0			;NUMBER OF DIRECTORY BLOCKS PASSED
NEWPCN:	.BLKW0			;WHERE A PCN WAS RELOCATED
POST:	.BLKW0			;<>0 INDICATES DIRECTORY FIX-UP PASS
SCNPPN:	.BLKW0			;PPN OF ACCOUNT BEING SCANNED
SCNUFL:	.BLKW0			;LINK IN MFD TO NAME ENTRY OF ACCOUNT
SCNFNL:	.BLKW0			;LINK IN UFD TO NE OF FILE BEING SCANNED
XFRCNT:	.BLKW0			;# CONTIGUOUS PC'S TO XFER

;	DATA AREA - TRANSFER AND STATISTICS AREA
VERBLK:	.BLKW0	5		;VERIFY DATA BLOCK - THIS BLOCK WILL
				;CONTAIN DATA NEEDED BY VERIFY - IT WILL BE
				;LOADED PRIOR TO EVERY VOLUME TRANSFER - THE
				;WORDS ARE AS FOLLOWS:
				; + 0  = PCNUM
				; + 2  = CBADI
				; + 4  = CBADO
				; + 6  = CURFBN
				; + 10 = CURFBN+2
BLKXFV:	.BLKW0	2		;BLOCKS TRANSFERRED TO THIS VOLUME
DUMP:	.BLKW0			;<>0 MEANS DUMP THE BUFFER, 0 NOT YET FULL
KNOWN:	.BLKW0			;<>0 MEANS KNOWN BAD BLOCK, 0 MEANS UNKNOWN
PCNRD:	.BLKW0			;# OF CLUSTERS IN BUFBEG
TFICHG:	.BLKW0			;TOTAL # OF FILES STRUCTURALLY ALTERED
TVERRV:	.BLKW0			;TOTAL # OF BAD COMPARES ON THIS VOLUME
	UNORG

;	CLUFLG BIT MEANINGS
	.BSECT	, NOCREF
MFDCLM:	.BLKB	.		;MFD CLUSTER MAP
UFDCLM:	.BLKB	.		;UFD CLUSTER MAP
FILCLM:	.BLKB	.		;PLAIN OLD FILE
GFDCLM:	.BLKB	.		;GFD CLUSTER MAP			;JDB004
	UNORG


.SBTTL	XFRCMN TEXT

	I.MESS
	.ENABL	LC
NOREPA:	.ASCII	<200>"Affected file"
NOREP:	.ASCIZ	" will not be reported"<200>
BBIMSG:	.ASCIZ	"Bad block on input"
BVEMSG:	.ASCIZ	"Bad compare"
FATBB:	.ASCIZ	"Fatal output bad block"<200>
LABMSG:	.ASCIZ	<177><200><11>"Please label this volume!"<200>
PCNMSG:	.ASCIZ	", PCN = "
VOLFUL:	.ASCIZ	"Volume is full"<200>
	.EVEN
	UNORG

.SBTTL	DUMMY BOOT

	I.DATA

	.EVEN
DUMBOT:	NOP
	RESET			;UGH
	BR	5$		;** (PER GPK FOR NEW BOOT)		;JDB004
	BOOTID	5$,<>		;** (PER GPK FOR NEW BOOT		;JDB004
	CLR	20$		;COUNT DOWN MEMORY TO DELAY
10$:	DEC	(PC)+		;CHURN
20$:	 .WORD	0
	BNE	10$
	MOV	PC,R0		;GETTA POSITION INDEPENDENT MESSAGE
	ADD	#40$-.,R0	;ADDRESS INTO R0
30$:	TSTB	@#177564	;CONSOLE READY ?
	BPL	30$		;PATIENCE
	MOVB	(R0)+,@#177566	;TALK TO ME
	TSTB	(R0)		;ANY MORE ?
	BNE	30$		;YUP
	HALT			;NOPE
	BR	DUMBOT		;DO IT AGAIN IF HE CONTINUES

.NLIST	BEX
40$:	.ASCIZ	<377><377><7><12>"?PLEASE BOOT FROM THE SYSTEM DISK."<15><12>
	.EVEN
BOTLEN	=	.-DUMBOT	;DUMMY BOOT LENGTH
	UNORG

.SBTTL	GETDUM - GET DUMMY BOOT

;+
; GETDUM - GET DUMMY BOOT
;
;	CALL:	R1 = START ADDRESS TO PUT BOOT
;		DUMBOT = ADDRESS OF BOOT
;		BOTLEN = LENGTH (IN BYTES) OF BOOT
;		CALL	GETDUM
;
;	RETURN:	YOU GOT IT
;-

.ENABL	LSB

GETDUM:	MOV	R1,-(SP)	;SAVE R1
	MOV	#256.,R2	;WILL CLEAR A BLOCK
10$:	CLR	(R1)+		;CLEAR A WORD
	SOB	R2,10$		;TILL THE END
	MOV	(SP)+,R1	;RESTORE R1
	TST	SYSNDX		;MAGTAPE?
	BMI	30$		;YES - ALL DONE
	MOV	#DUMBOT,R0	;ADDRESS OF DUMMY BOOT
	MOV	#BOTLEN/2,R2	;LENGTH (IN WORDS) OF BOOT
20$:	MOV	(R0)+,(R1)+	;MOVE A WORD OF IT
	SOB	R2,20$		;MOVE THE WHOLE THING
30$:	RETURN

GLOBAL	<SYSNDX>
.DSABL	LSB

.SBTTL	SETCH? - SET UP FOR TRANSFER

;+
; SETCH1 - SET UP FOR TRANSFER FROM THE INPUT CHANNEL
; SETCH2 - SET UP FOR TRANSFER TO THE OUTPUT CHANNEL
;
;	CALL	SETCH?
;
;	BUFPTR	= BUFBEG POINTER
;	DUMP	= DUMP BUFFER FLAG
;	PCNRD	= # OF CLUSTERS THAT HAVE BEEN READ INTO THE BUFFER
;		  (CLEARED IF SETCH1)
;	R4	--> FIRST SLOT IN PCN TABLE
;
;
;-

.ENABL	LSB

SETCH1:	CALL	SELEC1		;SET UP CHANNEL 1
	CLR	PCNRD		;INDICATE NOTHING READ YET
	BR	10$

SETCH2:	CALL	SELEC2		;SET UP CHANNEL 2
10$:	MOV	M.TBL,R4	;POINT TO APPROPRIATE MOUNT TABLE
	MOVB	MNTDCS(R4),DCS	;GET THE DCS
	MOVB	MNTPCS(R4),PCS	;GET THE PCS
	MOVB	MNTCLU(R4),CLURAT	;GET THE CLUSTER RATIO
XSETUP:	MOV	#XFRPCN,R4	;R4 --> FIRST SLOT IN PCN STORAGE TABLE
	MOV	#BUFBEG,BUFPTR	;ZERO THE BUFFER POINTER (SO TO SPEAK)
	CLR	DUMP		;CLEAR THE DUMP FLAG
	RETURN

GLOBAL	<PCS,DCS,CLURAT,XFRPCN>
.DSABL	LSB

.SBTTL	PCSCON - COMPUTE SOME PCS CONSTANTS

;+
; PCSCON - COMPUTE SOME PCS CONSTANTS
;
;	CALL:	PCS = DESIRED PCS
;		CALL	PCSCON
;
;	RETURN:	PCSWDS = # WORDS/PACK CLUSTER
;		BUFPCS = # PACK CLUSTERS/BUFFER
;-

.ENABL	LSB

PCSCON:	MOV	R0,-(SP)	;SAVE R0
	MOV	R1,-(SP)	;SAVE R1
	MOV	PCS,R1		;R1=PCS
	MUL	#256.,R1	;NOW R1= WORDS TO READ/WRITE
	MOV	R1,PCSWDS	;STORE IT
	MOV	#16.,R1		;#BLOCKS/BUFFER
	CLR	R0		;FOR DIVIDE
	DIV	PCS,R0		;COMPUTE # PC'S/BUFFER
	MOV	R0,BUFPCS	;STORE IT
	MOV	(SP)+,R1	;RESTORE R1
	MOV	(SP)+,R0	;RESTORE R0
	RETURN

GLOBAL	<PCS,PCSWDS,BUFPCS>
.DSABL	LSB


.SBTTL	RWRST	- CONTIGUOUS I/O TO RSTS DISK

;+
; RWRST - READ/WRITE n CONTIGUOUS PCS SIZE CHUNKS TO DISK
;
;	R2	= STARTING PCN
;	XFRCNT	= NUMBER OF CONTIGUOUS PC'S
;	CALL	RWRST,R5,FUN
;
;	RETURNS: 
;	C = 1	BAD BLOCK ERROR
;		BADDCN = BAD DCN
;	C = 0	ALL WENT WELL
;	
;	R1 = WORDS READ/WRITTEN
;	R2/R3 = FBN
;
;-
.ENABL	LSB

RWRST:	MOV	(R5)+,10$	;GET THE FUNCTION
	CALLX	CN2SEG		;CONVERT PCN IN R2 TO FBN,
	MOV	PCSWDS,R1	;R1 = # OF WORDS IN A PACK CLUSTER
	MUL	XFRCNT,R1	; TIMES # OF PCS CHUNKS = WORDS TO WRITE
	CALL	DSKIO,R5	;READ/WRITE FROM THE RIGHT SPOT
10$:	  .WORD	0		;FUNCTION
	  BR	20$		;BAD BLOCK ERROR
	  TST	(PC)+		;ALL'S WELL - CLEAR C-BIT - POP PAST SEC
20$:	SEC			;BAD BLOCK
	RETURN	R5

GLOBAL	<PCSWDS>
.DSABL	LSB

.SBTTL	XFRFIL - FILL XFRPCN TABLE WITH PCN'S

;+
; XFRFIL - FILL XFRPCN TABLE WITH PCN'S
;
;	CALL:	PCNUM  = # OF FIRST PCN TO TRY
;		PCNRD  = ASSUMED TO BE ZERO
;		PCS    = PCS OF DISK
;		R2     = # OF SATT BITS YET TO CHECK
;		R3     = CURRENT SATT BYTE POINTER
;		R5     = BIT IN BYTE
;		R4     = ASSUMED TO POINT TO WHERE PCN'S ARE TO BE STORED
;
;		CALL	XFRFIL
;
;	RETURNS:
;		PCNUM  = NEXT PCN TO CHECK
;		PCNRD  = COUNT OF PCN'S IN XFRPCN
;-

.ENABL	LSB

XFRFIL:	TST	R2		;DID THE PREVIOUS PASS GET THEM ALL?
	BEQ	40$		;YES - ALL DONE
	MOV	BUFPCS,R0	;GET # PC'S/BUFFER
10$:	TST	R0		;WE NEED ANY MORE PC'S ?
	BEQ	40$		;NO - PROCEED TO DO GET
	BITB	R5,SATBUF(R3)	;THIS SATT BIT ALLOCATED ?
	BEQ	20$		;NO - ON TO NEXT
	INC	PCNRD		;YES - GOT ANOTHER
	MOV	PCNUM,(R4)+	;PUT PCN IN PCN'S-READ TABLE
	DEC	R0		;ONE LESS NECESSARY
20$:	INC	PCNUM		;NEXT PCN
	ASLB	R5		;NEXT BIT IN SATT BYTE
	BCC	30$		;STILL IN CURRENT BYTE
	INC	R3		;NEXT SATT BYTE
	INC	R5		;FIRST BIT IN THE BYTE
30$:	SOB	R2,10$		;FOR ALL BITS IN SATT
40$:	RETURN			;ALL DONE

.DSABL	LSB
GLOBAL	<PCNUM,SATBUF,BUFPCS>

.SBTTL	CNTCTG - COUNT CONTIGUOUS PCN'S

;+
; CNTCTG - COUNT CONTIGUOUS PCN'S IN XFRPCN TABLE
;
;	R4 -> SLOT TO START AT IN XFRPCN TABLE
;	R0 =  COUNT LEFT IN TABLE
;
;	CALL	CNTCTG
;	
;	RETURNS:
;		PCNUM  = START OF CONTIG PC'S
;		XFRCNT = # OF CONTIGUOUS PCN'S
;		R0 = COUNT LEFT TO BE CHECKED
;		R4 -> NEXT SLOT TO CHECK
;
;-
.ENABL	LSB

CNTCTG:	MOV	R3,-(SP)	;SAVE R3
	MOV	#1,XFRCNT	;HOW MANY PCS CHUNKS WE'LL WRITE
	MOV	(R4)+,PCNUM	;GRAB THE NEXT
	DEC	R0		;ONLY ONE? (COVERS PCS=16, TOO)
	BEQ	20$		;YUP, NOTHING TO COMPARE AGAINST
10$:	MOV	(R4),R3		;GET THE NEXT STORED PCN
	SUB	XFRCNT,R3	;WILL SEE IF IT'S 1 (2,3,..15) MORE THAN 1ST
	CMP	PCNUM,R3		;DOES CONTORTED PCN MATCH?
	BNE	20$		;NOPE, GO DUMP WHAT WE HAVE
	INC	XFRCNT		;BUMP THE PCN CHUNK COUNTER
	TST	(R4)+		;WILL CHECK THE NEXT ONE
	SOB	R0,10$
20$:	MOV	(SP)+,R3	;RESTORE R3
	RETURN			;ALL DONE

GLOBAL	<PCNUM>
.DSABL	LSB

.SBTTL	GETRST - GET ALLOCATED CLUSTER

;+
; GETRST - GET AN ALLOCATED CLUSTER
;
;	PCNUM	= PCN TO GET
;	BUFPTR	= WHERE THIS CLUSTER GOES IN THE BUFFER
;	XFRCNT	= NUMBER OF CONTIGUOUS PC'S TO GET
;	PCNRD	= # OF CLUSTERS ALREADY IN THE BUFFER
;	DUMP	= 0 (BUFFER NOT FULL)
;	R4	= POINTS TO WHERE WE SHOULD SAVE THIS PCN
;
;	CALL	GETRST
;
;	RETURNS:
;	C = 1	UNKNOWN BAD BLOCK ERROR DURING READ AND /NOERROR
;		OR DIRECTORY FIX-UP PASS
;
;	C = 0	NO ERROR, ONLY KNOWN BAD BLOCKS HIT, OR UNKNOWN
;		BAD BLOCK BUT /NOERROR WAS NOT SPECIFIED
;	BUFPTR	= WHERE NEXT CLUSTER READ SHOULD GO
;	PCNRD	= OLD PCNRD+XFRCNT
;	DUMP	--> NON-ZERO IF THIS READ FILLED THE BUFFER
;		    IF SET, THE BUFFER SHOULD BE WRITTEN	
;
;-

.ENABL	LSB

GETRST:	CLR	POST		;NORMAL ENTRY
POSGET:	MOV	R1,-(SP)	;SAVE R1
	MOV	R2,-(SP)	; AND R2
	MOV	R3,-(SP)	; AND R3
	MOV	PCNUM,R2	;CN2SEG WANTS PCN IN R2
	CALL	RWRST,R5,RFUN	;READ THE CHUNK (SETS UP R1)
	BCS	40$		;BAD BLOCK ERROR
10$:	ASL	R1		;WE WANT R1 IN BYTES
	ADD	R1,BUFPTR	;BUFPTR+WORD COUNT ->WHERE NEXT CLUSTER READ
	ADD	XFRCNT,PCNRD	;INC # OF PCN'S IN THE BUFFER
	CMP	#BUFEND,BUFPTR 	;DID WE JUST FILL THE BUFFER?
	BHI	20$		;NO
	MOV	(PC),DUMP	;YES - INDICATE IT'S TIME TO DUMP IT
20$:	TST	(PC)+		;NO ERROR - CLEAR C-BIT
30$:	SEC			;ERROR
	MOV	(SP)+,R3	;RESTORE R3
	MOV	(SP)+,R2	; AND R2
	MOV	(SP)+,R1	; AND R1
	RETURN

40$:	TST	POST		;FIXUP PASS?
	BNE	30$		;INDICATE AN ERROR
	TST	VFY		;VERIFY ONLY?
	BNE	10$		;KEEP GOING
	CALL	BBINRS		;GO CHECK IT OUT
	BCS	30$		;UNKNOWN AND /NOER SPECIFIED
	BR	10$		;KNOWN BAD BLOCK OR UNKNOWN BUT /NOER WAS
				; NOT SPECIFIED - KEEP GOING

.DSABL	LSB
GLOBAL	<PCNUM>

.SBTTL	KWNBB	- KNOWN BAD BLOCK?

;+
; KWNBB - DO WE HAVE A KNOWN BAD BLOCK ?
;
;	R3 = PCN WHICH WAS FOUND TO BE BAD
;
;	CALL	KWNBB
;
;	RETURNS:
;	C = 0	KNOWN BAD BLOCK (KNOWN<>0)
;	C = 1	UNKNOWN BAD BLOCK (KNOWN=0)
;	BAD BLOCK 'BUFFER' POINTS TO NEXT ENTRY TO CHECK
;
;-

.ENABL	LSB

KWNBB:	MOV	R0,-(SP)	;SAVE R0
	MOV	R1,-(SP)	; AND R1
	MOV	R2,-(SP)	; AND R2
	CMP	M.TBL,MNTTBL	;INPUT?
	BNE	10$		;NO - OUTPUT
	MOV	CBADI,R0	;BUFFER POINTER
	MOV	NBADI,R1	;GET THE KNOWN INPUT BAD BLOCK COUNT
	MOV	NEWIBB,R2	;END OF KNOWN BAD BLOCK LIST
	BR	20$

10$:	MOV	CBADO,R0	;BUFFER POINTER
	MOV	NBADO,R1	;GET THE KNOWN OUTPUT BAD BLOCK COUNT
	MOV	NEWOBB,R2	;END OF KNOWN BAD BLOCK LIST
20$:	TST	R1		;ANY KNOWN BAD BLOCKS?
	BEQ	60$		;NOPE
30$:	CMP	R0,R2		;LAST ENTRY?
	BEQ	50$		;YUP
	CMP	(R0)+,R3	;IS THE ENTRY THE SAME AS OUR PCN?
	BEQ	70$		;IF THE SAME, KNOWN BAD BLOCK
	BHI	40$		;HAVE WE GONE PAST OUR PCN
	BR	30$		;KEEP LOOKING

40$:	TST	-(R0)		;WE'RE PAST WHERE WE WANT TO BE
50$:	CALL	90$		;UPDATE THE RIGHT POINTER
60$:	CLR	KNOWN		;NOT KNOWN FLAG
	SEC			;UNKNOWN BAD BLOCK - SET C-BIT
	BR	80$

70$:	CALL	90$		;UPDATE THE RIGHT POINTER
	MOV	(PC),KNOWN	;TIS KNOWN
	CLC			;KNOWN BAD BLOCK - CLEAR C-BIT
80$:	MOV	(SP)+,R2	;RESTORE R2
	MOV	(SP)+,R1	; AND R1
	MOV	(SP)+,R0	; AND R0
	RETURN

90$:	CMP	M.TBL,MNTTBL	;INPUT?
	BNE	100$		;NO - OUTPUT
	MOV	R0,CBADI	;UPDATE INPUT BUFFER POINTER
	BR	110$

100$:	MOV	R0,CBADO	;UPDATE OUTPUT POINTER
110$:	RETURN

.DSABL	LSB
GLOBAL	<CBADI,NBADI,NEWIBB,CBADO,NBADO,NEWOBB,MNTTBL>

.SBTTL	COMPAR - COMPARE DATA IN IOBUFF TO RSTS DISK VIA WRITE CHECKS

;+
; COMPAR - COMPARE DATA IN IOBUFF TO RSTS DISK VIA WRITE CHECKS
;
;	CALL:	PCNRD = NUMBER OF PC'S TO COMPARE
;		PCS   = PACK CLUSTER SIZE TO BASE COMPARISON ON
;		R4 -> LIST OF PCN'S
;		CALL	COMPAR
;
;	RETURN:	BUFFERS HAVE BEEN COMPARED - ANY BAD COMPARISONS
;		CAUSED ENTRIES IN THE BADVER TABLE
;-

.ENABL	LSB

COMPAR:	REGSCR			;SAVE REGISTERS
	MOV	R4,R5		;SAVE PCN LIST POINTER (MIGHT NOT BE AT LIST 
				; HEADER)
	MOV	PCNUM,-(SP)	;SAVE PCNUM
	MOV	PCNRD,R0	;GET # PC'S TO COMPARE
	CLR	-(SP)		;USE THE STACK AS A FLAG WORD
10$:	MOV	(R4)+,R3	;GET A PCN TO COMPARE
	BNE	20$		;WAS IT THE MFD?
	MOV	(PC),(SP)	;SET FLAG
	BR	40$		;ONWARD

20$:	BIT	#OPRE!OPIN,OPFLG	;RES OR INS? (INPUT NON-RSTS)	;JDB008
	BNE	30$		;YES - NO NEED TO CHECK FOR KNOWN INPUT BB'S
	CALL	KWNCHK		;WAS IT OLD OR NEW BAD BLOCK?
	BCS	40$		;YES - IGNORE IT
30$:	CALL	SCNREL		;PCN THE SAME AS ON THE OUTPUT (RELOCATED?)
	BCC	40$		;NOPE
	MOV	NEWPCN,-2(R4)	;WHERE IT WAS RELOCATED
40$:	SOB	R0,10$		;DO FOR ALL PCN'S IN LIST
	MOV	R5,R4		;GET BACK PCN LIST POINTER
	MOV	PCSWDS,R1	;GET PCS*256 IN R1
	MOV	R1,R5		;SAVE IT
	ASL	R5		;GET BYTE COUNT
	MOV	PCNRD,R0	;GET BACK OUR PCN COUNT
	TST	(SP)+		;LOOK AT OUR FLAG & POP IT
	BNE	60$		;IT WAS THE MFD
50$:	TST	(R4)		;THIS PCN ENTRY ZERO ? (WAS BAD)
	BNE	60$		;NO - AT LEAST FIRST ONE IN LIST IS OK
	TST	(R4)+		;YES - SKIP OVER IT
	ADD	R5,BUFPTR	;BUMP FORWARD
	DEC	R0		;ONE LESS PCN TO COMPARE
	BEQ	80$		;NONE LEFT
	BR	50$		;CHECK NEXT ONE

60$:	CALL	CNTCTG		;GET # PCN'S CONTIGUOUS
	MOV	PCNUM,R2	;PCN TO START COMPARE
	CALLX	CN2SEG		;CONVERT TO FBN AND GET # WORDS/PC INTO DSQ
	MOV	PCSWDS,R1
	MUL	XFRCNT,R1	;COMPUTE TOTAL WORD COUNT FOR CONTIG. PCN'S
	CALL	DSKIO,R5,RFUN.C	;DO WRITE CHECK
	  BR	90$		;BAD COMPARE
	  ASL	R1		;GET # BYTES WE JUST COMPARED
70$:	ADD	R1,BUFPTR	;POINT UP TO NEXT PC
	TST	R0		;ANY MORE PCN'S TO COMPARE ?
	BNE	50$		;YES
	;CLC
80$:	MOV	(SP)+,PCNUM	;RESTORE PCNUM
	RETURN

90$:	CALL	ENTBVE		;ENTER PC (DETERMINED FROM BADDCN) IN BAD
				; COMPARE TABLE AND INFORM USER
	BIT	#NOER,SWTWRD	;ARE WE ALLOWING ERRORS ?
	BEQ	70$		;YES - RESUME COMPARE
				;17-JUL-81 - JDB - 1 LINE INSERTED
	INC	TVERR		;ELSE ENSURE WE LOOK FOR THIS IN SCNDIR
	SEC			;INDICATE WE SHOULD GET OUT
	BR	80$		;AND GET OUT

.DSABL	LSB
GLOBAL	<PCNUM,SWTWRD,I.DSQ,OPFLG>

.SBTTL	ENTBVE - PUT ENTRY IN BAD COMPARE FILE

;+
; ENTBVE - PUT ENTRY IN BAD COMPARE FILE
;
;	CALL:	R4 -> NEXT PCN IN PCN LIST TO BE COMPARED
;		R5 = # BYTES/PC
;		R0 = # PC'S LEFT TO BE COMPARED
;		BADDCN = BAD DCN
;		CALL	ENTBVE
;
;	RETURN:	R0 = # PC'S LEFT TO BE COMPARED
;		R1 = # BYTES JUST COMPARED (TO UPDATE BUFPTR)
;		R4 -> NEXT PCN IN PCN LIST TO BE COMPARED
;		IT HAS BEEN ENTERED OR APPROPRIATE MESSAGE PRINTED
;		IF NO ROOM IN FILE
;-

.ENABL	LSB

ENTBVE:	MOV	R0,-(SP)	;SAVE R0
	MOV	BADDCN,R2	;PREPARE TO CONVERT TO PCN
	CALLX	RIB2CN		; IN R3
	MOV	R3,R0		;FOR PRINTING
	INC	TVERRV		;INC COUNT OF BAD COMPARES THIS VOLUME
	CALL	PRTBVE		;%%% BAD COMPARE
	CALLX	MESSAG,R5,PCNMSG ;', PCN=
	CALLX	DECZER		;PRINT OUT PC
	CALLX	TYPECR		;NEW LINE
	MOV	BVEPTR,R3	;BADVER TABLE POINTER
	CMP	R3,#BVEEND	;POINTING PAST THE END ?
	BLT	10$		;NO - WE'RE OK
	CALLX	MESSAG,R5,NOREPA ;'AFFECTED FILE WILL NOT BE REPORTED'<200>
	BR	20$		;CAN'T ENTER PCN - NO ROOM

10$:	MOV	R0,(R3)+	;PUT BAD PC IN TABLE
	MOV	R3,BVEPTR	;NEW TABLE POINTER
20$:	MOV	XFRCNT,R1	;GET COUNT OF CONTIG. PCN'S WE WERE COMPARING
30$:	CMP	-(R4),R0	;WAS THIS THE BADDIE?
	BEQ	40$		;YES
	SOB	R1,30$		;ALL OF EM 
40$:	ADD	XFRCNT,(SP)	;COMPUTE NEW # PCN'S YET TO COMPARE:
	SUB	R1,(SP)		;
	MUL	R5,R1		;R1 = # BYTES WE JUST COMPARED
	TST	(R4)+		;R4 WILL POINT TO NEXT PCN TO COMPARE
	MOV	(SP)+,R0	;RESTORE R0
	RETURN

GLOBAL	<BVEEND,BVEPTR>
.DSABL	LSB

.SBTTL	PRTDIF - PRINT DIFFERENCES

;+
; PRTDIF - PRINT # OF DIFFERENCES FOUND
;
; CALL:	TVERRV = DIFFERENCES THIS VOLUME
;	CALL	PRTDIF
;
; RETURNS: MESSAGE PRINTED
;-

.ENABL	LSB

PRTDIF:	MOV	R0,-(SP)	;SAVE R0
	CALL	JSTAR		;'*** '
	MOV	TVERRV,R0	;GET COUNT
	CALLX	DECZER		;PRINT IT
	MESSAG	<" difference">
	CALL	PLURAL		;PRINT/NO PRINT AN 'S'
	MESSAG	<" found"<200>>
	MOV	(SP)+,R0	;RESTORE R0
	RETURN


;+
; PLURAL - PRINT AN 'S' IF PLURAL OR ZERO
;
;	R0 = COUNT
;	CALL	PLURAL
;-

PLURAL:	DEC	R0		;ONLY 1 TO START WITH?
	BEQ	10$		;YUP, NO 'S'
	MESSAG	<"s">		;PLURAL (OR 0) - PRINT THE 'S'
10$:	RETURN			;THAT'S ALL

.DSABL	LSB

.SBTTL	PTRSAV/PTRRES - SAVE AND RESTORE PARAMETERS FOR VERIFY

;+
; PTRSAV - SAVE CBADI/CBADO/CURFBN FOR VERIFY PASS
; PTRRES - RESTORE SAME
;
;	CALL:	CALL	PTR???
;
;	RETURN:	IT HAS BEEN DONE
;-

PTRSAV:	MOVB	RECTYP,-(SP)		;SAVE VOLUME RECORD TYPE
	MOV	PCNUM,-(SP)		;NEXT PC NUMBER TO XFER
	MOV	PCNRD,-(SP)		;# PCN'S READ
	MOV	#XFRPCN,R0		;POINT TO PCN'S READ TABLE
	MOV	#16.,R1			;IT HAS 16. ENTRIES
10$:	MOV	(R0)+,-(SP)		;STACK ONE
	SOB	R1,10$			;STACK THEM ALL
	MOV	CBADI,-(SP)		;CURRENT INPUT BAD BLOCK
	MOV	NBADO,-(SP)		;CURRENT OUTPUT BAD BLOCK	;AWR001
	MOV	CURFBN,-(SP)		;CURRENT SAVE VOLUME FBN
	MOV	CURFBN+2,-(SP)		;(TWO WORDS WORTH)
	MOV	23.*2(SP),-(SP)		;GET R5 ON TOP
	RETURN	R5

PTRRES:	INC	(SP)+			;THROW AWAY OLD R5
	MOV	(SP)+,CURFBN+2
	MOV	(SP)+,CURFBN
	MOV	(SP)+,NBADO		;				;AWR001
	MOV	(SP)+,CBADI
	MOV	#XFRPCN+32.,R0
	MOV	#16.,R1
10$:	MOV	(SP)+,-(R0)
	SOB	R1,10$
	MOV	(SP)+,PCNRD	
	MOV	(SP)+,PCNUM
	MOVB	(SP)+,RECTYP
	RETURN	R5

GLOBAL	<PCNUM,XFRPCN,CBADI,CBADO,CURFBN>

.SBTTL	BDMFD/FATBAD/FULLUP/BADLNK - VERY FATAL ERROR

;+
; BDMFD -	DIE, WE HIT A BAD MFD
; FATBAD -	DIE, WE HIT A FATAL BAD BLOCK (UNRECOVERABLE VIA RELOCATION)
; FULLUP -	DIE, VOLUME IS FULL
; BADLNK -	DIE, WE HIT A BAD LINK
; CHKNOE -	DIE IF /NOERROR WAS SPECIFIED
;
;	CALL	ROUTINE
;
;	THESE ROUTINES ABORT VIA CHKABT
;-

.ENABL	LSB

BDMFD:	MOV	#BADMFD,ABTADR		;BAD MFD
	BR	10$			;DIE

FATBAD:	MOV	#FATBB,ABTADR		;FATAL BAD BLOCK ERROR
	BR	10$

FULLUP:	MOV	#VOLFUL,ABTADR		;VOLUME IS FULL
	BR	10$

BADLNK:	MOV	#BADDIR,ABTADR		;'BAD DIRECTORY'
10$:	CALL	CHKABT			;GO PRINT AND DIE

CHKNOE:	BIT	#NOER,SWTWRD		;/NOERROR SPECIFIED ?
	BEQ	20$			;NO
	MOV	(PC),ABTUSR		;USER ABORT
	BR	10$			;DIE

20$:	RETURN

.DSABL	LSB
GLOBAL	<SWTWRD>


.SBTTL	CHKMFD - PREPARE FOR MFD SCAN					;JDB004

;+
; CHKMFD - PREPARE FOR MFD SCAN - CLEAR VARIABLES, GET THE MFD
;	   IN FIBUF, PREPARE TO SCAN MFD CLUSTER MAP
;
;	PROPER CHANNEL HAS BEEN SELECTED
;	CALL	CHKMFD
;
; RETURNS:
;	MFD IN FIBUF, ITEMS NEEDED TO SCAN MAP SET UP
;-

.ENABL	LSB

CHKMFD:	CLRB	HIGHBF		;MAKE SURE I/O IS NOT TO IOBUFF
	CLR	CLUFLG		;CLEAR MAP TYPE CHECK FLAG
	CLR	SCNPPN		;PPN OF ACCOUNT BEING SCANNED
	CLR	SCNUFL		;LINK IN MFD TO N.E. OF ACCOUNT
	CLR	SCNFNL		;LINK IN UFD TO N.E. OF FILE BEING SCANNED
	BIT	#20000,PKSTAT	;IS THIS A NEW PACK?
	BEQ	10$		;BRANCH IF NOT - DO IT THE OLD WAY
	CALL	FSRDPL		; ELSE GET THE PACK LABEL AT PCN 1
	BCS	30$		;BRANCH IF ANY PROBLEM IN DOING SO
	MOV	FIBUF+MDCN,R2	;GET (SUPPOSED) STARTING DCN OF THE MFD
	CALL	RIB2CN		;CONVERT IT TO A PCN IN R3
	MOV	MISSNG,-(SP)	;(EVERYBODY CLAIMS SCNREL MESSES IT UP)
	CALL	SCNREL		;SEE IF IT GOT RELOCATED
	MOV	(SP)+,MISSNG	;	(RESTORE MISSNG)
	BCC	10$		;BRANCH IF NOT - WE'LL GET MFD THE NORMAL WAY
	MOV	NEWPCN,R2	; ELSE COPY WHERE IT WENT TO
	CALL	CN2SEG		;CONVERT PCN TO FBN
	CALL	READ		;GET FIRST BLOCK OF MFD IN FIBUF
	BCS	30$		;BRANCH IF ANY PROBLEMS READING IT
	BR	20$		; ELSE JOIN NORMAL PROCESS
10$:	CALL	FSRDMF		;ENSURE THE MFD IS IN FIBUF
	BNE	10$		;BAD MFD - DIE
20$:	MOV	#MFDCLM,CLUFLG	;INDICATE MFD CLUSTER MAP CHECK
	MOVB	FIBMAP,CHKECS	;MFD CLUSTER SIZE -> ENTITY CLUSTER SIZE
	MOV	#FIBENT,R5	;POINT TO MFD CLUSTER MAP
	RETURN			;THAT'S IT

30$:	CALL	BDMFD		;DIE ON BAD MFD

.DSABL	LSB
GLOBAL	<PKSTAT>

.SBTTL	SCNDIR - SCAN ALL ACCOUNTS

;+
; SCNDIR - SCAN ALL ACCOUNTS TO FIND WHERE UNEXPECTED INPUT
;	  BAD BLOCKS RESIDE (SAVE/IMAGE) AND/OR BAD COMPARES OCCURRED
;	  (SAVE/RESTORE/IMAGE)
;
;	CALL	SCNDIR
;
;	RETURNS:
;	ALL LOCATIONS WHICH COULD BE FOUND WERE LISTED. NOTE THAT A
;	WELL-PLACED INPUT BAD BLOCK COULD PREVENT A THOROUGH DIRECTORY
;	SCAN. IN THIS CASE, MESSAGES HAVE BEEN PRINTED AND THE OPERATION
;	BEING PERFORMED MAY BE CONTINUED SINCE THESE BADDIES ONLY HURT
;	THE INPUT DISK - THE OUTPUT MAY OR MAY NOT BE HORRENDOUSLY HARMED;
;	E.G., A BAD MFD BLOCK COULD REALLY SCREW THINGS UP BUT A BAD FILE
;	BLOCK MIGHT JUST HURT AN UNIMPORTANT FILE.
;
;	NOTE THAT THE ROUTINE DOES NOT RETURN (DIES VIA CHKABT) IF EITHER
;	/NOERROR WAS SPECIFIED AND BAD INPUT BLOCK WAS FOUND OR IF A BAD
;	LINK WAS FOUND. IN THE LATTER CASE THIS MEANS THAT THE OUTPUT
;	MUST ALSO BE CORRUPT.
;
;
;-

.ENABL	LSB
.ENABL	LC

SCNDIR:	CALL	SETCH1		;SET UP THE INPUT CHANNEL
	BIT	#OPRE!OPIN,OPFLG	;RESTORE OR INSTALL?		;JDB008
	BEQ	10$		;NO - THE CHANNEL IS SET
	CALL	REPSET		;SET UP FOR DIRECTORY REPAIRS
				; (SCREWS UP MISSNG)
	CALL	SETCH2		;FOR RESTORE WE WANT THE OUTPUT DISK
10$:	MOV	UNKBBI,MISSNG	;GET COUNT OF UNEXPECTED INPUT BB'S
	ADD	TVERR,MISSNG	;ADD IN COUNT OF BAD COMPARES
	BEQ	60$		;GET OUT IF NO QUESTIONABLE BLOCKS
	CALL	CHKMFD		;CLEAR VARIABLES, GET MFD IN FIBUF, PREPARE
				;TO CHECK MFD CLUSTER MAP
	BIT	#20000,PKSTAT	;IS THIS AN OLD DISK?			;JDB004
	BEQ	15$		;BRANCH IF SO - DO IT THE OLD WAY	;JDB004
	CALL	SCDRNW		; ELSE DO IT THE NEW WAY		;JDB004
	BR	60$		; AND BE DONE				;JDB004
15$:	CALL	SCNDCN		;ANY BADDIES IN MFD CLUSTER MAP?
	BCS	50$		;YES! - ANYTHING IN MFD CLUSTER MAP MEANS
				;STOP SCAN
	MOV	#FIBUF,R5	;POINT TO LINK TO FIRST ACCOUNT IN MFD
20$:	MOV	(R5),R3		;R3 = LINK (IN MFD) TO NEXT NAME ENTRY
	BIC	#UL.FLG,R3	;MINUS FLAG BITS
	BEQ	40$		;DONE - BUT NOT ALL WERE FOUND
30$:	CALL	RDBSCN		;READ IN THE MFD NAME ENTRY
	BCS	80$		;C-BIT SET MEANS POINTED TO A BAD BLOCK
	BITB	#US.UFD,USTAT(R5) ;IS THIS AN ACCOUNT?
	BEQ	20$		;NO, IT'S A FILE IN [1,1]
	MOV	UNAM(R5),SCNPPN	;SAVE THE PPN WE'RE SCANNING
	MOV	UAR(R5),R2	;GET RP TO 1ST BLOCK OF THE UFD
	BEQ	20$		;0 MEANS UFD DOESN'T EXIST
	MOV	R2,-(SP)	;SAVE THE RP
	MOV	R3,-(SP)	;SAVE LINK TO NEXT
	CALLX	RIB2CN		;CONVERT DCN IN R2 TO PCN IN R3
	CALL	SCNTAB		;RP TO 1ST BLOCK HAD BEST BE OK!
	MOV	(SP)+,R3	;GET BACK LINK TO NEXT
	MOV	(SP)+,R2	;GET BACK THE RP
	BCS	70$		;IT ISN'T - CAN'T CHECK REST OF ACCOUNT
	MOV	R3,SCNUFL	;SAVE THE LINK IN MFD TO THIS UFD NE
	MOV	FIBPHS,TMPFBN	;SAVE LSB OF THE BLOCK IN MFD WITH THIS UFD NE
	MOV	FIBPHS+2,TMPFBN+2 ; AND SAVE THE MSB	
	CALL	SCNACC		;SCAN THE ACCOUNT
	BCS	50$		;FATAL ERROR DURING SCAN
	TST	MISSNG		;HAVE WE FOUND THEM ALL YET?
	BEQ	50$		;YES
	MOV	TMPFBN+2,R3	;RESTORE FBN MSB TO R3
	MOV	TMPFBN,R2	; AND FBN LSB TO R2
	CALL	FSREAD		;READ BACK THE BLOCK IN MFD WITH THIS UFD NE
	MOV	SCNUFL,R3	;NOW, GET THE NE AGAIN
	CALL	RDBSCN		;TRY THE GET - DON'T COME BACK IF IT'S BAD
	BCS	80$		;C-BIT SET MEANS POINTED TO A BB
	BR	20$		;ON TO THE NEXT ACCOUNT

40$:	CALL	PRTWRN		;"%%% BAD BLOCK ON INPUT/BAD COMPARE
	MESSAG	<": can't trace"<200>> ;COULDN'T FIND ALL THE BADDIES

50$:	CALL	CHKNOE		;CHECK FOR /NOERROR
60$:	RETURN

;	DCN OF UFD CLUSTER IS BAD - CAN'T SCAN REST OF ACCOUNT
70$:	CALL	BADUFD		;'%%% BAD BLOCK ON INPUT IN UFD
	CALL	CHKNOE		;SEE IF /NOERROR SPECIFIED
	BR	20$		;WASN'T - KEEP LOOKING

;	NEW BAD BLOCK READING OR READING BACK IN AN MFD NAME ENTRY
;	BAD BLOCK CAUSES END TO SCAN
80$:	CALL	PRTBBI		;'BAD BLOCK ON INPUT'
	MESSAG	<" in MFD"<200>>
	BR	50$		;INDICATE END TO THE SCAN

.DSABL	LSB
GLOBAL	<OPFLG,FIBUF,FIBPHS,UNKBBI,SSVOL,PKSTAT>


.SBTTL	SCDRNW - SCAN ALL ACCOUNTS ON A NEW DISK			;JDB004
;+
; SCDRNW - SCAN ALL ACCOUNTS TO FIND WHERE UNEXPECTED INPUT
;	  BAD BLOCKS RESIDE (SAVE/IMAGE) AND/OR BAD COMPARES OCCURRED
;	  (SAVE/RESTORE/IMAGE)
;
;	CALL	SCDRNW
;
;	INPUTS: FIRST BLOCK OF MFD IN FIBUF
;	OUTPUT: (SAME AS SCNDIR)
;

.ENABL	LSB
.ENABL	LC

SCDRNW:	MOV	#FIBENT,R5	;POINT TO FIRST RP IN CLUSTER MAP
	CALL	SCNDCN		;SEE IF ANY ARE IN MFD
	TST	MISSNG		;HAVE WE FOUND THEM ALL YET?
	BEQ	20$		;BRANCH IF SO - ALL DONE
	MOV	#FIBUF,R4	;INITIALIZE DCN PTR BLOCK PTR
	MOV	FIBMAP+2,R2	;GET DCN OF FIRST MFD CLUSTER
	CALL	CNVRIB		;CONVERT RETRIEVAL PTR TO FBN
	ADD	#1,R2		;POINT TO BLOCK 2 OF CLUSTER 1 (DCN PTR BLOCK)
	ADC	R3		; (MSB)
10$:	CALL	SCNGFD		;PROCESS THE CURRENTLY POINTED GFD
	BCS	20$		;BRANCH IF ANY ERRORS ENCOUNTERED
	TST	MISSNG		;HAVE WE FOUND THEM ALL YET?
	BEQ	20$		;BRANCH IF SO - ALL DONE
	CMP	#FIBUF+512.,R4	;ANY MORE GFD'S?
	BNE	10$		;BRANCH IF SO - GO GET 'EM
20$:	RETURN			;THAT'S ALL FOLKS!

.DSABL	LSB


.SBTTL	SCNGFD - SCAN GFD						;JDB004

;+
; SCNGFD - SCAN GFD
;
;	CALL:	CALL	SCNGFD
;
;	INPUTS: R2&R3 = FIP BLOCK NUMBER OF DCN PTR BLOCK IN MFD
;		R4 = CURRENT PTR TO A GFD DCN IN THE BLOCK
;
;	RETURN: R2&R3 PRESERVED
;		R4 = UPDATED TO PT TO NEXT GFD DCN (IF ANY)
;		OTHERS FAIR GAME
;		C-BIT INDICATES SUCCESS OR FAILURE
;-

.ENABL	LSB

SCNGFD:	MOV	R2,-(SP)	;PRESERVE FBN
	MOV	R3,-(SP)	; (MSB)
	CALL	READ		;GET THE DCN PTR BLOCK FROM THE MFD
	BCS	100$		;BRANCH ON READ FAILURE FROM MFD
	MOV	#GFDCLM,CLUFLG	;INDICATE GFD CLUSTER MAP CHECK
	MOV	(R4)+,R2	;GET DCN PTR OF THIS GFD AND POP TO NEXT
	BEQ	10$		;BRANCH IF THERE WAS NONE ALLOCATED
	CALL	FSRDRF		;GET FIRST BLOCK OF THE FILE DIRECTORY
	BCS	100$		;BRANCH IF BAD DIRECTORY
	MOV	FIBUF+LPPN,SCNPPN	;SQUIRREL AWAY THE GROUP NUMBER
	CALL	SCNDCN		;SCAN THE CLUSTER MAP
	TST	MISSNG		;HAVE WE FOUND THEM ALL YET?
	BEQ	10$		;BRANCH IF SO - ALL DONE
	CALL	SCNGRP		; ELSE SCAN GFD'S OFFSPRING
10$:	MOV	(SP)+,R3	;RESTORE FBN
	MOV	(SP)+,R2	; (LSB)
	RETURN			;THAT'S ALL FOLKS!

100$:	CALL	BADLNK		;BAD DIRECTORY ON RSTS DISK
.DSABL	LSB


.SBTTL	SCNGRP - SCAN A GFD'S OFFSPRING					;JDB004

;+
; SCNGRP - SCAN GFD'S OFFSPRING
;
;	CALL:	CALL	SCNGRP
;
;	INPUTS: R2,R3 = FBN OF FIRST CLUSTER OF GFD                     ;JDB007
;
;	RETURN: R0-R5 PRESERVED
;		C-BIT INDICATES SUCCESS OR FAILURE
;-

.ENABL	LSB

SCNGRP:REGSCR			;PRESERVE R0-R5
	MOV	#FIBUF,R4	;INITIALIZE DCN PTR BLOCK PTR
				;19-APR-84 - ONE LINE REMOVED - 	;JDB007
	ADD	#1,R2		;POINT TO BLOCK 2 OF CLUSTER 1 (DCN PTR BLOCK)
	ADC	R3		; (MSB)
10$:	CALL	READ		;GET DCN PTR BLOCK
	BCS	100$		;BRANCH IF READ FAILURE IN GFD
	MOV	R2,-(SP)	;PRESERVE FBN
	MOV	R3,-(SP)	; (MSB)
	MOV	(R4)+,R2	;GET CURRENT DCN PTR AND POP TO NEXT
	BEQ	20$		;BRANCH IF THAT WASN'T ALLOCATED
	CALL	SCNACC		; ELSE GO SCAN THIS UFD
20$:	MOV	(SP)+,R3	;RESTORE FBN
	MOV	(SP)+,R2	; (LSB)
	BCS	30$		;BRANCH IF UFD SCAN FAILED
	TST	MISSNG		;HAVE WE FOUND THEM ALL YET?
	BEQ	30$		;BRANCH IF SO - ALL DONE
	CMP	#FIBUF+512.,R4	;ANY MORE UFD'S?
	BNE	10$		;BRANCH IF SO - GO SCAN 'EM
30$:	RETURN			;THAT'S ALL FOLKS!

100$:	CALL	BADLNK		;BAD DIRECTORY ON RSTS DISK

.DSABL	LSB


.SBTTL		SCNACC - SCAN AN ACCOUNT

;+
; SCNACC - SCAN A UFD
;
;	R5 -> NAME ENTRY CURRENTLY IN FIBUF
;	R3 = LINK TO (NEXT) MFD NAME ENTRY
;	R2 = RP (DCN) OF 1ST BLOCK OF UFD
;
;	CALL	SCNACC
;
;	RETURNS: NOTHING FATAL HAPPENED
;	NOTE THAT IF ONE OF THE BAD INPUT/COMPARES WAS IN A CLUSTER MAP,
;	WE CAN'T COMPLETELY SCAN THE ACCOUNT (BUT NOT FATAL).
;	NOTE THAT WE DIE IF WE HIT A BAD LINK
;-

.ENABL	LSB

SCNACC:	CLR	SCNFNL		;LINK TO NE OF FILE BEING SCANNED
	CALL	FSRDRF		;READ IN 1ST BLOCK OF THE UFD,
	MOV	#UFDCLM,CLUFLG	;INDICATE UFD CLUSTER MAP CHECK
	MOVB	FIBMAP,CHKECS	;UFD CLUSTER SIZE -> ENTITY CLUSTER SIZE
	MOV	#FIBENT,R5	;POINT TO 1ST DCN IN UFD CLUSTER MAP
	MOV	FIBUF+LPPN,SCNPPN	;GET PPN FOR THIS UFD		;JDB009
	CALL	SCNDCN		;CHECK ALL THE RP'S IN THE MAP
	BCS	50$		;BADDIES? IF SO, CAN'T SCAN THIS UFD

; CHECK ALL FILES IN THE UFD

	MOV	#FIBUF,R5	;R5 -> UFD LINK HEAD

; LOOP THROUGH EACH UFD NAME ENTRY CHECKING FILES

30$:	MOV	(R5),R3		;R3 = LINK TO NEXT UFD NAME ENTRY
	BIC	#UL.FLG,R3	;MINUS FLAG BITS
	BEQ	50$		;NONE, SO WE ARE DONE WITH THIS UFD
40$:	CALL	RDBSCN		;READ IN THE NAME ENTRY FOR THE FILE
	BCS	BADUFD		;C-BIT SET MEANS BAD BLOCK
	CALL	SCNFIL		;GO CHECK RETRIEVAL ENTRIES,ETC
	BCS	60$		;C-BIT SET MEANS BAD BLOCK
				; MESSAGE ALREADY PRINTED
	TST	MISSNG		;FOUND THEM ALL YET?
	BNE	30$		;NOPE - GO DO ANOTHER FILE
50$:	CLC			;NOTHING FATAL
60$:	RETURN

;	NEW BAD INPUT BLOCK - WE CAN'T CONTINUE THE ACCOUNT SCAN.
BADUFD:	CALL	PRTBBI		;'BAD BLOCK ON INPUT'
	MESSAG	<" in UFD ">
	CALL	PRTPPC		;PRINT PPN
	CALLX	TYPECR		;NEW LINE
	BR	50$		;NAME ENTRY BAD BLOCK - CAN'T SCAN REST OF UFD

.DSABL	LSB
GLOBAL	<FIBMAP,FIBUF,FIBENT>

.SBTTL		SCNFIL - SCAN A FILE ENTRY

;+
;	R3 =  LINK TO NAME ENTRY OF FILE TO SCAN
;	R5 -> NAME ENTRY IN FIBUF
;	FIBUF CONTAINS A BLOCK OF THE UFD
;
;	CALL	SCNFIL
;
;	RETURNS:
;	C = 1	NOTHING FATAL BUT CAN'T FINISH THE FILE
;	C = 0	NO PROBLEMS
;		R5 -> NAME ENTRY
;		R0, R1, R2 CLOBBERED
;	NOTE THAT WE DIE IF WE HIT A BAD LINK
;-

.ENABL	LSB

SCNFIL:	MOV	R3,SCNFNL	;SAVE THE LINK IN UFD TO THIS FILE NE

; CHAIN THROUGH RETRIEVAL ENTRIES

	BITB	#US.UFD,USTAT(R5) ;IS THIS A UFD?
	BNE	40$		;YES, THERE ARE NO RETRIEVAL ENTRIES
	MOV	UAR(R5),R2	;SAVE LINK TO 1ST RETRIEVAL ENTRY
	MOV	UAA(R5),R3	;GET LINK TO FILE'S ACCT. ENTRY
10$:	CALL	RDBSCN		;TRY TO READ THE A.E.
	BCS	50$		;BAD BLOCK - NO COULD DO
	MOV	UCLUS(R5),CHKECS ;FILE CLUSTER SIZE -> ENTITY CLUSTER SIZE
20$:	MOV	R2,R3		;GET RP LINK
				;12-OCT-81 - JDB - ADDED ONE LINE
	BIC	#UL.FLG,R3	;WIPE OUT FLAG BITS, IF ANY
				;12-OCT-81 - JDB - END
	BEQ	30$		;NO MORE CLUSTERS - DONE WITH FILE
	CALL	RDBSCN		;READ THE RETRIEVAL ENTRY
	BCS	50$		;BAD BLOCK ERROR
	MOV	(R5)+,-(SP)	;SAVE LINK TO NEXT & POP TO 1ST DCN
	MOV	#FILCLM,CLUFLG	;PLAIN OLD FILE
	CALL	SCNDCN		;CHECK ALL THE RP'S - NOT FATAL IF FOUND
	MOV	(SP)+,R2	;GET BACK LINK TO NEXT
	TST	MISSNG		;ANY STILL UNFOUND?
	BNE	20$		;YUP
	BR	40$		;NO - NOTHING LEFT TO SCAN

30$:	MOV	SCNFNL,R3	;RESTORE LINK TO THIS FILE'S NE
	CALL	RDBSCN		;GET IT BACK
	BCS	50$		;BUT THE BLOCK WAS OK BEFORE
40$:	RETURN

50$:	CALL	PRTBBI		;'BAD BLOCK ON INPUT'
	MESSAG	<" in ">
	CALL	PRTCLF		;PRINT FAILING PPN/FILENAME
	CALLX	TYPECR		;NEW LINE
	SEC			;DONE WITH THIS FILE
	BR	40$

.DSABL	LSB

.SBTTL		RDBSCN - RDB FOR SCNDIR

;+
; RDBSCN - RDB FOR SCNDIR
;
;	R3 = LINK
;	CALL	RDBSCN
;
;	RETURNS:
;	C = 0	NO PROBLEM
;	C = 1	BAD BLOCK - CALLING ROUTINE SHOULD TELL EM WHERE
;		('%%% ' ALREADY PRINTED)
;	NOTE THAT THE ROUTINE DIES ON BAD LINKS
;-

.ENABL	LSB

RDBSCN:	CALL	RDBRTN		;CALL RDB
	BCC	10$		;C-BIT CLEAR MEANS NO PROBLEM
	CALL	JPERC		;NEW BAD BLOCK - LET EM KNOW WHERE - %%%
	SEC			;INDICATE A BB
10$:	RETURN			;ALL DONE

RDBRTN:	CALL	FSRDB		;TRY READ USING R3
	BCC	20$		;C-BIT CLEAR MEANS NO PROBLEM
	TSTB	IOERR		;BAD DIRECTORY (LINK) ERROR?
	BEQ	30$		;YES - TIS FATAL
	SEC
20$:	RETURN

30$:	CALL	BADLNK		;BAD LINKS ARE FATAL

.ENABL	LSB
GLOBAL	<IOERR>

.SBTTL		SCNDCN - CHECK DCN'S

;+
; SCNDCN - SEE IF ANY IN A CHUNK OF RP'S (DCN'S) ARE BAD
;
;	R5 -> 1ST DCN IN A CLUSTER MAP OR FILE CLUSTER MAP
;	R3 = LINK TO RP
;	MISSNG = REMAINING # OF UNFOUND UNEXPECTED INPUT ABD BLOCKS
;	CHKECS = ENTITY CLUSTER SIZE, I.E., MFD, UFD, OR FILE CLUSTER SIZE
;
;	CALL	SCNDCN
;
;	RETURNS:
;	REGISTER CONTENTS ARE LOST
;	
;	C = 0	DIDN'T FIND ANYTHING
;	C = 1	FOUND SOMETHING
;	IF ANY WERE BAD, FAILING PPN/FILENAME HAS BEEN PRINTED
;	MISSNG = REMAINING # OF UNFOUND UNEXPECTED INPUT BAD BLOCKS
;-

.ENABL	LSB

SCNDCN:	REGSAV			;SAVE REGISTERS
	MOV	CHKECS,R1	;GET THE CLUSTER SIZE
	CLR	R0		;SET UP FOR DIVIDE
	DIV	PCS,R0		;ECS/PCS=# OF PC'S PER ENTITY CLUSTER
	MOV	R0,R4		;SAVE IT
	MOV	MISSNG,R1	;SAVE # UNFOUND ON ENTRY
10$:	MOV	(R5)+,R2	;GRAB A DCN
	BEQ	50$		;ZERO MEANS NO MORE
	CALLX	RIB2CN		;CONVERT DCN IN R2 TO PCN IN R3
	MOV	R4,R2		;GET THE RATIO AS OUR LOOP CONTROL
20$:	MOV	R3,-(SP)	;SAVE OLD PCN
	MOV	MISSNG,-(SP)	;SCNREL MESSES IT UP
	CALL	SCNREL		;WAS OUR PCN RELOCATED ?
	MOV	(SP)+,MISSNG	;RESTORE MISSNG
	BCC	21$		;NO
	MOV	NEWPCN,R3	;YES - GET WHERE WAS RELOCATED TO
21$:	CALL	SCNTAB		;CHECK IT OUT
	BCC	40$		;NOT BAD
	CALL	PRTWRN		;PRINT APPROPRIATE WARNING
	MOV	R3,R0		;SET UP TO PRINT PCN
	BIT	#MFDCLM,CLUFLG	;IS THIS THE MFD CLUSTER MAP?
	BNE	80$		;UNFORTUNATELY, YES
	BIT	#GFDCLM,CLUFLG	;IS THIS A GFD CLUSTER MAP?		;JDB004
	BNE	90$		;SAD, BUT TRUE.				;JDB004
	BIT	#UFDCLM,CLUFLG	;IS THIS A UFD CLUSTER MAP?
	BNE	100$		;AFRAID SO				;JDB004
	MESSAG	<" in file ">	;JUST A FILE
	CALL	PRTCLF		;PRINT FAILING PPN & FILENAME
	MOV	TOS.R3+2(SP),R3	;MAY HAVE READ IN A DIF BLOCK - GET OLD LINK
	MOV	R5,-(SP)	;SAVE R5
	CALL	RDBSCN		;READ IT BACK
	MOV	(SP)+,R5	;RESTORE R5
	BCC	30$		;ALLS GOOD
	TST	(SP)+		;POP OLD PCN
	BR	60$		;EXIT BAD

30$:	CALLX	MESSAG,R5,PCNMSG ;', PCN = '
	CALLX	DECZER		;FOR NOW, PRINT DCN
	CALLX	TYPECR		;NEW LINE
40$:	MOV	(SP)+,R3	;GET BACK OLD PCN
	TST	MISSNG		;ANY UNFOUND BB'S
	BEQ	60$		;FOUND THEM ALL - GO SET C-BIT
	INC	R3		;ON TO THE NEXT PC IN THE ENTITY CLUSTER
	ADD	PCS,NDBS	;WE'VE PASSED ANOTHER PCS DIRECTORY BLOCKS
	SOB	R2,20$		;FOR ALL OF THEM
	BIT	R5,#17		;TRY THE NEXT RP
	BNE	10$		;IF THERE IS ONE
50$:	CMP	R1,MISSNG	;DID WE FIND ANY?
	BEQ	70$		;NOPE (C-BIT IS CLEAR)
60$:	SEC			;FOUND AT LEAST 1
70$:	CALLX	REGRES,R5	;RESTORE REGISTERS
	RETURN			;ALL DONE

80$:	MESSAG	<" in MFD">
	BR	30$

90$:	MESSAG	<" in GFD">						;JDB004
	CLR	R0		;TO GET GROUP NUMBER			;JDB004
	BISB	SCNPPN+1,R0	;GET IT					;JDB004
	CALL	DECZER		;PRINT THE GROUP NUMBER			;JDB004
	BR	30$		;AND GO FOR THE PCN			;JDB004

100$:	MESSAG	<" in UFD ">	;TWAS IN A UFD MAP			;JDB004
	CALL	PRTPPC		;CAN PRINT THE PPN
	BR	30$

.DSABL	LSB
GLOBAL	<PCS>

.SBTTL	SCNTAB - SCAN BADVER AND BB FILE

;+
; SCNTAB - SCAN UNEXPECTED INPUT BAD BLOCK FILE AND BADVER FILE
;
;	R3 = PCN TO CHECK
;
;	CALL	SCNTAB
;
;	RETURNS:
;	C = 0	PCN WAS NOT ONE OF THE 'UNEXPECTED INPUT BAD BLCOKS'
;		AND WAS NOT IN THE BADVER FILE
;	C = 1	PCN WAS AN 'UNEXPECTED BAD BLOCK' OR BAD VERIFY
;
;-

.ENABL	LSB

SCNTAB:	MOV	R2,-(SP)	;SAVE R2
	MOV	R4,-(SP)	;SAVE R4
	MOV	UNKBBI,R4	;COUNT OF UNEXP INPUT BAD BLOCKS
	BEQ	20$		;IF NONE ON TO BAD VERIFY FILE
	CLR	VFY		;WE ARE SEARCHING THE BAD BLOCK FILE
	MOV	NEWIBB,R2	;POINT TO BEGINNING OF BB FILE
	BIT	#OPRE!OPIN,OPFLG	;RESTORE OR INSTALL?		;JDB008
	BEQ	10$		;NO - USE NEWIBB
	MOV	#BADRES,R2	;USE BADRES TABLE
10$:	CALL	40$		;SCAN BAD BLOCK FILE
	BCS	30$		;FOUND ONE - GET OUT
20$:	MOV	TVERR,R4	;COUNT OF BAD VERIFIES
	BEQ	30$		;NONE - GET OUT
	MOV	(PC),VFY	;WE ARE NOW SEARCHING THE BAD COMPARE FILE
	MOV	#BADVER,R2	;POINT TO BEGINNING OF BADVER FILE
	CALL	40$		;SCAN BAD COMPARE FILE
30$:	MOV	(SP)+,R4	;RESTORE R4
	MOV	(SP)+,R2	;RESTORE R2
	RETURN

40$:	CMP	(R2)+,R3	;DOES IT MATCH OURS?
	BEQ	70$		;YES - WE FOUND ONE!
	SOB	R4,40$		;SCAN THEM ALL
	TST	(PC)+		;DCN IS OK - POP OVER SEC (C-BIT IS CLEAR)
50$:	SEC			;INDICATE A FIND
60$:	RETURN			;ALL DONE

70$:	DEC	MISSNG		;DECREMENT BAD BLOCKS UNFOUND
	CLR	-(R2)		;CLEAR OUT ENTRY SO WON'T BE REFOUND
	TST	VFY		;WERE WE SEARCHING THE BAD BLOCK FILE ?
	BNE	90$		;NO
	MOV	TVERR,R4	;COUNT OF BAD VERIFIES
	BEQ	90$		;NONE
	MOV	#BADVER,R2	;POINT TO THE BADVER TABLE
80$:	CMP	(R2)+,R3	;THIS A MATCH ?
	BEQ	100$		;YUP - GO ACCOUNT FOR IT
	SOB	R4,80$		;SEARCH 'EM ALL
90$:	BIT	#OPRE!OPIN,OPFLG	;A RESTORE OR INSTALL?		;JDB008
	BEQ	50$		;NO
	BIT	#MFDCLM!UFDCLM!GFDCLM,CLUFLG	;CHECKING A DIRECTORY MAP ?
	BEQ	50$		;NO
	CALL	REPDIR		;YES - REPAIR IT IF POSSIBLE
	BR	60$		;IT'S REPAIRED

100$:	DEC	MISSNG		;DECREMENT BAD BLOCKS UNFOUND
	CLR	-(R2)		;CLEAR OUT ENTRY SO WON'T BE REFOUND
	BR	90$

.DSABL	LSB
GLOBAL	<BADVER,TVERR,UNKBBI,NEWIBB,OPFLG>

.SBTTL	PRTWRN - PRINT BAD BLOCK ON INPUT/BAD COMPARE MSG

.ENABL	LSB

PRTWRN:	TST	VFY		;IS THIS A BAD VERIFY PASS ?
	BNE	PRTBVE		;YES
PRTBBI:	WARN	BBIMSG		;'%%% BAD BLOCK ON INPUT'
	BR	20$

PRTBVE:	WARN	BVEMSG		;'%%% BAD COMPARE'
20$:	RETURN

.DSABL	LSB

.SBTTL	PRBEG - PRINT PHASE MESSAGE

;+
; PRBEGC - PRINT 'BEGIN xx from dev: to dev: at HH:MM' AND CLEAR TOTALS
; PRBEG  - PRINT BUT DON'T CLEAR TOTALS (VERIFY OR VOLUMES SUBSEQUENT
;	   TO THE 1ST)
;
;	CALL	PRBEG?
;-

.ENABL	LSB
.ENABL	LC

PRBEGC:	CALL	OVRCON		;OFF-LINE, CONTEXT WAS LOST - PRESERVE IT
	MOVB	#1,HIGHBF	;SET UP FOR I/O TO/FROM IOBUFF
	BIC	#DIALMT,MNTFLG	;FROM HERE ON, NO MORE DIALOGUE MOUNTS
	CLR	ABTADR		;IN CASE WE ABORTED BEFORE
	CLR	ABTUSR		;CLEAR USER ABORT FLAG
	MOV	#ELPDAT,R1	;POINT TO BEGINNING OF TIMING INFO.
	MOV	#18.,R0		;WILL CLEAR 18. WORDS
10$:	CLR	(R1)+		;CLEAR A WORD
	SOB	R0,10$		;CLEAR 'EM ALL
	MOV	#BLKXFV,R1	;GET READY TO CLEAR NON-GLOBAL TOTALS
	MOV	#4.,R0		;4 WORDS WORTH, STARTING AT BLKXFV
20$:	CLR	(R1)+		;CLEAR A WORD
	SOB	R0,20$		;TILL THE END
	CALL	PRCSAV		;BOTH PROCESS TIME AND
	MOV	I.DATE,ELPDAT	; AND ELAPSED TIME
	MOV	I.TIME,ELPTIM	; START NOW
	MOVB	I.SEC,ELPSEC	; SO STORE STARTING TIMES

PRBEG:	REGSAV			;SAVE REGISTERS
	CALL	SETDAT		;GET THE CURRENT DATE AND TIME
	MOV	#BADVER,BVEPTR
	CALL	JSTAR		;'*** '
	MESSAG	<"Begin ">
	CALL	PRTRTN		;PRINT THE ROUTINE NAME
	MESSAG	<" from ">
	TYPDEV	MNTTBL		;PRINT THE INPUT DEVICE
	MESSAG	<" to ">
	TYPDEV	MNTTBL+2	;PRINT THE OUTPUT DEVICE
	MESSAG	<" at ">
	CALLX	TIMPRT		;PRINT THE TIME
	CALLX	TYPECR		;NEW LINE
	CALLX	REGRES,R5	;RESTORE THE REGISTERS
	RETURN

.DSABL	LSB
GLOBAL	<ELPHRS,ELPDAT,ELPTIM,ELPSEC,I.DATE,I.TIME,I.SEC>
GLOBAL	<BADVER,BVEPTR,MNTFLG>

.SBTTL	ENDOP - PRINT ENDING MESSAGE AND STATISTICS

;+
;	ENDOP - PRINT ENDING MESSAGE, AND, IF /STATS SPECIFIED, PRINT
;		STATISTICS
;
;	CALL ENDOP
;-

.ENABL	LSB

ENDOP:	REGSCR			;SAVE ALL REGISTERS
	CLRB	HIGHBF		;DONE I/O TO/FROM IOBUFF
	CLR	INPUT		;WE WANT THEM TO DISMOUNT THE OUTPUT
	CALL	DISMNT		;DO IT
	CALLX	MESSAG,R5,LABMSG ;TELL THEM TO LABEL IT
	MESSAG	<<177><200>"--- ">	;NEW LINE, WITH DASHES
	CALL	PRTRTN		;PRINT ROUTINE NAME
	MESSAG	<" operation completed at "> ;AND REST OF MESSAGE
	CALL	ELTIMC,R5,<ELPDAT,ELPHRS> ;GET ACCUMULATED ELAPSED TIME
	CALL	ELTIMC,R5,<PRCDAT,PRCHRS> ;GET LAST CHUNK OF PROCESS TIME
	CALLX	TIMPRT		;PRINT THE CURRENT TIME
	CALLX	TYPECR		;SKIP TO NEXT LINE
	BIT	#ST,SWTWRD	;STATISTICS REQUESTED?
	BNE	10$		;YES - PRINT THE STATS
	RETURN			;NO - GO BACK

10$:	MOV	OPFLG,R5	;GET OPERATION FLAG INTO A REGISTER
	MESSAG	<<200><11><11>"Summary Report"<200><200>>
	CALL	PRTRTN		;START FIRST LINE WITH PHASE NAME
	MESSAG	<" of ">
	MOV	MNTTBL,R4	;POINT TO INPUT MOUNT TABLE
	BIT	#OPRE!OPIN,R5	;RESTORE OR INSTALL?			;JDB008
	CALL	140$		;GO PRINT INPUT DEVICE/UNIT AND/OR ID
	MESSAG	<" to ">
	MOV	MNTTBL+2,R4	;POINT TO OUTPUT MOUNT TABLE
	BIT	#OPSV,R5	;SAVE?
	CALL	140$		;GO PRINT OUTPUT DEVICE SPEC.
	MESSAG	<<200><200>"    Input Device:"<11>> ;PRINT INPUT INFO
	MOV	MNTTBL,R4	;POINT TO THE INPUT TABLE
	BIT	#OPRE!OPIN,R5	;INDICATE IF THIS IS A RES OR INS	;JDB008
	CALL	70$		;PRINT DISK OR SAVE SET INFO
	MESSAG	<"   Output Device:"<11>> ;PRINT OUTPUT INFO
	MOV	MNTTBL+2,R4	;POINT TO THE OUTPUT TABLE
	BIT	#OPSV,R5	;INDICATE IF THIS IS A SAVE
	CALL	70$		;PRINT DISK OR SAVE SET INFO
	CALL	PRTRTN		;PHASE NAME AGAIN
	MESSAG	<" started on "> ;BEFORE WE PRINT THE DATE
	PRDAYT	ELPDAT		;PRINT TRANSFER START DATE/DAY
	MESSAG	<", at ">	;'AT'
	MOV	ELPTIM,R1	;GET THE STARTING TIME
	CALLX	PRTTIM		;AND PRINT IT
	MESSAG	<<200><200><11><11>"Run Statistics"<200>>
	MESSAG	<<200>"Transfer Totals:"<200><200><11>"Total of ">
	MOV	BLKXF,R2	;# OF BLOCKS XFERRED
	MOV	BLKXF+2,R3	;BOTH WORDS
	CALLX	DBLZER		;PRINT IT
	MESSAG	<" blocks transferred"<200><200>"Error Totals:"<200>>
	BIT	#VE,SWTWRD	;VERIFY?
	BEQ	20$		;NOPE
	MOV	TVERR,R0	;ERRORS DURING 'VERIFY'
	CALL	130$		;PRINT 'TOTAL OF'
	MESSAG	<" bad compare">
	CALL	PLURAL		;PRINT/NO PRINT AN 'S'
	MESSAG	<"."> 		;END OF PHRASE
20$:	CALLX	TYPECR		;NEW LINE
	MOV	MNTTBL,R4	;INPUT
	TSTB	MNTIDX(R4)	;WAS IT MAGTAPE?
	BMI	30$		;YES - SOURCE BAD BLOCKS DON'T MEAN ANYTHING
	MOV	UNKBBI,R0	;SOURCE BAD BLOCKS
	CALL	120$
	MESSAG	<"source.">
30$:	MOV	MNTTBL+2,R4	;OUTPUT
	TSTB	MNTIDX(R4)	;WAS IT MAGTAPE?
	BMI	40$		;YES - DEST. BAD BLOCKS DON'T MEAN ANYTHING
	MOV	UNKBBO,R0	;DESTINATION BAD BLOCKS
	CALL	120$
	MESSAG	<"destination.">
40$:	BIT	#OPIM!OPRE!OPIN,R5	 ;IMAGE, RESTORE OR INSTALL?	;JDB008
	BEQ	50$		;NOPE, SKIP PRINTING # ALTERED
	MESSAG	<<200><200><11>> ;NEW LINE FOR ALTERED FILES
	MOV	TFICHG,R0	;GET # OF FILES ALTERED
	CALLX	DECZER		;PRINT IT
	MESSAG	<" file">
	CALL	PLURAL		;PRINT/NO PRINT AN 'S'
	MESSAG	<" structurally altered.">
50$:	MESSAG	<<200><200>"Timing Totals:"<200><200><11>"Total elapsed">
	MOV	#ELPHRS,R1	;POINT TO ELAPSED TIME TOTALS
	CALL	60$		;PRINT ELAPSED TIME INFO
	MESSAG	<"Total wait   ">
	MOV	#WAIHRS,R1	;POINT TO WAIT TIME TOTALS
	CALL	60$		;PRINT WAIT TIME INFO
	MESSAG	<"Total process">
	MOV	#PRCHRS,R1	;POINT TO PROCESS TIME TOTALS
60$:	MESSAG	<" time:">	;REMAINDER OF BLURB
	MOV	(R1)+,R0	;EXTRACT HOURS
	CALLX	P4DDIG		;AND PRINT
	MESSAG	<" hrs.,">
	MOVB	(R1)+,R0	;EXTRACT MINUTES
	CALLX	P4DDIG		;AND PRINT
	MESSAG	<" mins.,">
	MOVB	(R1),R0		;EXTRACT SECONDS
	CALLX	P4DDIG		;AND PRINT
	MESSAG	<" secs."<200><11>>
	RETURN

70$:	BNE	80$		;PRINT SAVE SET INFO
	TYPDEV			;RSTS DISK - PRINT DEVICE TYPE AND UNIT
	CALL	PRTRST		;PRINT DISK SPECIFICS
	BR	110$

80$:	TSTB	MNTIDX(R4)	;WAS SAVE SET MAGTAPE?
	BPL	90$		;NOPE
	MESSAG	<"Magtape">	;PRINT 'MAGTAPE' AS DEVICE TYPE
	MOVB	(PC),MAGTAP	;MAKE SURE FLAG IS SET
	BR	100$		;GO ON TO THE REST

90$:	MESSAG	<"Disk">	;PRINT 'DISK' AS DEVICE TYPE
	CLRB	MAGTAP		;CLEAR MAGTAPE FLAG
100$:	MESSAG	<<200><11>"Set Name:"<11>>
	MOV	#SSVOL,R4	;POINT TO SAVE SET INFO
	PRTID	R4		;PRINT SAVE SET NAME
	MESSAG	<<200>"    # of volumes:"<11>>
	DECZER	SSSEQ(R4)	;PRINT SEQUENCE NUMBER
	CALL	PRTSAV		;PRINT REGULAR SAVE SET INFO
110$:	MESSAG	<<200><200>>	;TWO NEW LINES
	RETURN			;AND GET OUT

120$:	CALL	130$		;PRINT 'TOTAL OF'
	MESSAG	<" new bad block">
	CALL	PLURAL		;PRINT/NO PRINT AN 'S'
	MESSAG	<" encountered on ">
	RETURN

130$:	MESSAG	<<200><11>"Total of "> ;FIRST PART	
	CALLX	P4DDIG		;PRINT THE NUMBER
	RETURN

140$:	BNE	150$		;ITS A SAVE SET
	CALL	TYPDEV		;PRINT THE DEVICE AND UNIT
	BR	160$		;GO PRINT ID

150$:	MESSAG	<"Save Set ">	;'SAVE SET '
160$:	MOV	R4,R2		;POINT TO MOUNT TABLE FOR PRTNAM
	CALL	PRTNAM		;PRINT THE PACK ID OR SAVE SET NAME
	RETURN

.DSABL	LSB

GLOBAL	<WAIHRS,ELPDAT,ELPHRS,PRCDAT,PRCHRS,SSVOL,OPFLG,SWTWRD>
GLOBAL	<UNKBBI,UNKBBO,HIGHBF,MNTTBL>

.SBTTL	STOMAP/RESMAP - STORE AND RESTORE A DIRECTORY CLUSTER MAP

;+
; STOMAP - STORE THE DIRECTORY CLUSTER MAP LOCATED AT FIBMAP IN FIBUF
; RESMAP - RESTORE THE CURRENTLY STORED CLUSTER MAP BACK INTO FIBUF
;
;	CALL:	CALL	???MAP
;
;	RETURN:	IT HAS BEEN TRANSFERRED
;-

.ENABL	LSB

STOMAP:	REGSCR			;SAVE REGISTERS
	MOV	#FIBMAP,R0	;POINT TO MAP IN FIBUF
	MOV	#CLUMAP,R1	;OUR STORAGE LOCATION
	BR	10$		;ON WITH IT

RESMAP:	REGSCR			;SAVE REGISTERS
	MOV	#CLUMAP,R0	;WHERE STORED MAP IS
	MOV	#FIBMAP,R1	;WHERE TO PUT IT IN FIBUF
10$:	MOV	#8.,R2		;THERE ARE 8. WORDS IN A MAP
20$:	MOV	(R0)+,(R1)+	;MOVE A WORD
	SOB	R2,20$		;MOVE 'EM ALL
	RETURN

.DSABL	LSB
GLOBAL	<FIBMAP>

.SBTTL	PRINT NAME ENTRY AS [N,M] OR NNNNNN.EEE

.ENABL	LSB

PRNTNE:	MOV	R0,-(SP)	;PRESERVE R0
	BITB	#US.UFD,USTAT(R5) ;CHECK STATUS OF N.E. W/ BAD LINK
	BNE	20$		;IT'S A UFD, PRINT ITS PPN
	CMP	UNAM(R5),#-1	;IS IT A VALID RAD50 NAME?
	BNE	10$		;YES -- PRINT THE FILE NAME
	MESSAG	<"home entry">	;NO -- IT'S A UFD/MFD HOME ENTRY
	BR	40$		;DONE

10$:	MOV	UNAM(R5),R0	;PRINT THE FILE NAME
	CALLX	RADZER
	MOV	UNAM+2(R5),R0
	CALLX	RADZER
	MESSAG	<".">
	MOV	UNAM+4(R5),R0
	CALLX	RADZER
	BR	40$		;DONE

20$:	MOV	UNAM(R5),-(SP)	;GET THE PPN ON THE STACK
30$:	MESSAG	<"[">
	CLR	R0		;PRINT THE PPN
	BISB	1(SP),R0
	CALLX	DECZER
	MESSAG	<",">
	CLR	R0
	BISB	(SP)+,R0
	CALLX	DECZER
	MESSAG	<"]">
40$:	MOV	(SP)+,R0	;RESTORE R0
50$:	RETURN

;	R5 POINTS TO A N.E.
PRTPNC:	MOV	#PRNTNE,-(SP)	;PRINT NAME AFTER PPN
PRTPPC:	MOV	R0,-(SP)	;SAVE REGISTER
	MOV	SCNPPN,-(SP)	;PUSH PPN TO PRINT
	BR	30$		;ENTER THE LOOP

;	THIS ONE MUST BE SEPARATE OR R5 WILL BE DESTROYED
PRTCLF:	MOV	SCNFNL,R3	;GET LINK TO FILE IN UFD
	MOV	R5,-(SP)	;WE ARE ABOUT TO DESTROY R5
	CALL	FSRDB		;POINT TO IT
	BCS	60$		;ERROR
	CALL	PRTPPC		;PRINT THE PPN
	CALL	PRNTNE		;FOLLOWED BY THE NAME
	MOV	(SP)+,R5	;RESTORE R5
	RETURN

60$:	TSTB	IOERR		;BAD DIRECTORY ERROR?
	BEQ	70$		;YES
	CALL	FATBAD		;FATAL BAD BLOCK
70$:	CALL	BADLNK		;BAD DIRECTORY (LINK)

.DSABL	LSB
GLOBAL	<IOERR>

