TITLE	SRCMN,<SAVE/RESTORE COMMON ROUTINES>,0A,10-MAY-91,JBL

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	TEXT  & DATA USED ONLY BY MULTI-VOL MOUNT

	I.DATA
HALF:	.BLKW0			;BUFFER HALF INDICATOR
	.EVEN
	UNORG

	I.MESS
	.ENABL	LC

LOCK:	.ASCIZ	"LOCKED ."
EBL:	.ASCIZ	"ENABLED."
	.EVEN
	UNORG

.SBTTL	PROMPT - GET USER INPUT (MULTI VOLUME ONLY)

.ENABL	LSB

PROMPT:	MOV	R1,-(SP)	;SAVE R1
	MOV	R4,-(SP)	; AND R4
	TST	INPUT		;MOUNT FOR INPUT OR OUTPUT?
	BEQ	10$		;OUTPUT
	MOVTXT	INP,DEVIO	;"input"
	MOVTXT	LOCK,40$	;"LOCKED"
	BR	20$		;GO DO IT

10$:	MOVTXT	OUTP,DEVIO	;"output"
	MOVTXT	EBL,40$		;"ENABLE"
20$:	MOVB	NXTVOL,R0	;GET WHAT THE SEQ # SHOULD BE
	MOV	#60$,R1		;SET UP ADDRESS FOR DECSTR
	CALLX	DECSTR		;PUT VOL. SEQ. # IN-LINE
	MOV	#SSVOL+2,R2	;SAVE SET NAME IS AT R2, R2+2 (RAD-50)
	MOV	#70$,R4		;GET (IN-LINE) ADDRESS FOR TEXT
	MOV	(R2)+,R0	;GET 1ST WORD OF THE NAME, POINT TO 2ND
	CALLX	RADCNV		;GET THE 1ST HALF OF THE NAME
	MOV	(R2),R0		;GET THE 2ND HALF OF THE NAME
	ADD	#3,R4		;BUMP WHERE IT'S GOING
	CALLX	RADCNV		;GET THE 2ND HALF
30$:	CALL	ASKNLF,R5	;ASK USER FOR DEVICE SPEC - NO DEFAULT
	  .WORD	50$
	  GENTXT
	   .ASCII "This drive should be WRITE-"
40$:	   .ASCIZ "        "<200>
50$:	   .ASCII <200>"Mount volume # "
60$:	   .ASCII "      "	;SAVE SET SEQ. #
	   .ASCII " of SAVE Set "
70$:	   .ASCII "      "<200>	;SAVE SET NAME
	   .ASCIZ "Device ? "
	  UNORG
	 .WORD	ASKDEV
	BCS	80$		;CTRL/Z? - ERROR HERE
	MOV	R1,R2		;R2 -> INPUT STRING

	MOV	(SP)+,R4	;RESTORE R4
	MOV	(SP)+,R1	; AND R1
	RETURN

80$:	WARN	PREMSG		;PRINT NO PREVIOUS QUES. MSG.
	CALLX	MESSAG,R5,MORINF;" - TYPE <CR> FOR MORE INFORMATION'
	BR	30$		;GO REASK

.DSABL	LSB
GLOBAL	<SSVOL>

.SBTTL	ACCUM - ACCUMULATE VOLUME TOTALS

;+
; ACCUM - ACCUMULATE BLOCKS TRANSFERRED AND BAD COMPARES FOR VOLUME
;
;	CALL:	BLKXF  = TOTAL BLOCKS TRANSFERRED SO FAR
;		BLKXFV = BLOCKS TRANSFERRED TO THIS VOLUME
;		TVERR  = TOTAL BAD COMPARES
;		TVERRV = BAD COMPARES ON THIS VOLUME
;		CALL	ACCUM
;
;	RETURN:	BLKXF  = BLKXF + BLKXFV
;		TVERR  = TVERR + TVERRV
;		BLKXFV, TVERRV = 0
;-

.ENABL	LSB

ACCUM:	ADD	BLKXFV,BLKXF	;ADD LSB'S
	ADC	BLKXF+2		; AND CARRY
	ADD	BLKXFV+2,BLKXF+2 ;ADD MSB'S
	CLR	BLKXFV		;ZERO VOLUME TOTAL
	CLR	BLKXFV+2
	ADD	TVERRV,TVERR	;ADD IN BAD COMPARES TO TOTAL
	CLR	TVERRV		;ZERO VOLUME TOTAL
	RETURN

GLOBAL	<BLKXF,TVERR>
.DSABL	LSB

.SBTTL	SRVINI - SAVE/RESTORE VERIFY SET UP

;+
; SRVINI - SAVE/RESTORE VERIFY SET UP
;
;	CALL:	VERBLK	SET UP
;		CALL	SRVINI
;
;	RETURN:	VFY IS SET
;		PCNUM,CBADI,CBADO,CURFBN AS AT BEGINNING OF DATA XFER
;		R3 = OLD SATT BYTE POINTER
;		R5 = OLD SATT BIT IN BYTE
;		R2 = # OF PC'S TO COMPARE
;-

.ENABL	LSB

SRVINI:	MOV	(PC),VFY	;WE'RE IN A VERIFY NOW
	MOVB	#DATBLK,RECTYP	;DATA RECORD TYPE (5)
	MOV	#VERBLK,R1	;THE VERIFY DATA BLOCK
	MOV	(R1)+,R0	;THE OLD PCNUM
	MOV	(R1)+,CBADI	;THE OLD INPUT BB LIST PTR.
	MOV	(R1)+,CBADO	;THE OLD OUTPUT BB LIST PTR.
	MOV	(R1)+,CURFBN	;THE OLD FBN/RECNO LSB
	MOV	(R1)+,CURFBN+2	;THE OLD FBN/RECNO MSB
	CALLX	FIXREG		;GET THE OLD SATT BYTE # & BIT IN BYTE
	MOVB	BITBYT(R2),R5	;THE OLD BIT IN BYTE
	MOV	R4,R3		;THE OLD BYTE POINTER
	MOV	XFRPCN,R2	;GET LAST PCN DATA WRITTEN TO
	SUB	R0,R2		;COMPUTE # PC'S TO COMPARE
	MOV	R0,PCNUM	;MAKE OLD PCNUM OUR CURRENT ONE
	RETURN

GLOBAL	<XFRPCN,PCNUM,BITBYT,CBADI,CBADO,CURFBN>
.DSABL	LSB

.SBTTL	ERINFO - GET SAVE INPUT ERROR INFORMATION

;+
; ERINFO - GET SAVE INPUT ERROR INFORMATION
;
;	CALL:	PCNRD  = # PC'S ATTEMPTED TO BE READ
;		TMPFBN = FBN WE ATTEMPTED TO READ FROM
;		TMPCBO = CURRENT BAD BLOCK POINTER PRIOR TO READ ATTEMPT
;		CALL	ERINFO
;
;	RETURN:	R0 = # PC'S THAT CAN FIT IN 16. BLOCK BUFFER
;		R2 = ONE HALF OF R0
;		R3 = # BAD PC'S
;		R4 = POINTER INTO XFRPCN TABLE WHERE BAD PC'S START
;		R5 <> 0 IF SECOND HALF BUFFER FILL FAILED
;		   =  0 IF FIRST HALF BUFFER FILL FAILED
;-

.ENABL	LSB

ERINFO:	MOV	BUFPCS,R0	;R0 = # PC'S/BUFFER
	TSTB	SSVOL+SSHIDX	;SAVE VOLUME MAGTAPE ?
	BNE	10$		;YES - TMPFBN ALREADY CORRECT
	MOV	TMPFBN,R2	;GET LSB IF ATTEMPTED FBN
	MOV	TMPFBN+2,R3	;GET MSB OF SAME
	CALL	CHKSBN		;CHECK IT AGAINST THE BAD BLOCK LIST
	MOV	R2,TMPFBN	;PUT DERIVED FBN BACK IN TMPFBN
	MOV	R3,TMPFBN+2
10$:	CLR	R4		;R4 WILL BE POINTER INTO XFRPCN TABLE
	CLR	R5		;WHICH HALF BUFFER FILL FAILED INDICATOR
	MOV	R0,R2		;COPY OF # PC'S/BUFFER
	ASR	R2		;R2 = 1/2 # PC'S/BUFFER
	MOV	PCNRD,R3
	CMP	CURFBN+2,TMPFBN+2	;DID FIRST READ FAIL ?
	BNE	20$		;NO - SECOND DID
	CMP	CURFBN,TMPFBN	;SAME QUESTION
	BEQ	30$		;YES
20$:	MOV	(PC),R5		;SECOND HALF BUFFER FILL FAILED
	TST	R2		;PCS = 16. ?
	BEQ	40$		;YES
	SUB	R2,R3		;ONLY SECOND HALF BAD
	ADD	R0,R4		;MAKE R4 OFFSET TO SECOND HALF PCN'S
	BR	40$		;ALL DONE

30$:	TST	R2		;PCS = 16. ?
	BEQ	40$		;YES, ALL DONE
	CMP	R3,R2		;# DESIRED PC'S >= HALF BUFFER FULL ?
	BLOS	40$		;NO - IT'S LESS THAN
	MOV	R2,R3		;MAKE # BAD PC'S = HALF BUFFER FULL
40$:	ADD	#XFRPCN,R4	;MAKE R4 POINT WITHIN XFRPCN TABLE
	RETURN

.DSABL	LSB
GLOBAL	<XFRPCN,SSVOL,CURFBN>

.SBTTL	PTRGET - SAVE SOME POINTERS FOR VERIFY

;+
; PTRGET - SAVE CURRENT PCNUM/CBADI/CBADO FOR VERIFY
;		CALL	PTRGET
;-

PTRGET:	MOV	R0,-(SP)		;SAVE R0
	MOV	#VERBLK,R0		;PT TO VERIFY INFO BLOCK
	MOV	PCNUM,(R0)+
	MOV	CBADI,(R0)+
	MOV	CBADO,(R0)+
	MOV	CURFBN,(R0)+
	MOV	CURFBN+2,(R0)
	MOV	(SP)+,R0		;RESTORE R0
	RETURN

GLOBAL	<CURFBN,CBADI,CBADO,PCNUM>

.SBTTL	DUMMY ROUTINES

.ENABL	LSB

IDENT:	JMP	ILLCAL		;ILLEGAL CALL - GO DIE

.DSABL	LSB

