TITLE	SROOT,<SAV/RES ROOT FILE>,0A,10-MAY-91,JDB

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY
;+
;
;  002  JDB  07-OCT-82  ADDED PACK STATUS VARIABLE		;JDB002
;  003  JDB  24-APR-84  ADDED INSTALL DISPATCH ENTRY TO RESTORE ;JDB003
;  004  JDB  24-APR-84  CHANGED DUMMY DISPATCH ENTRY TO I.INI0  ;JDB004
;  005  VAM  12-Jul-85	Added BLDB (calls to BLDBOT for tape boots)
;

;-

.SBTTL	ROOT MACROS

.MACRO	DE2TBL	SYM,LEN,VAL=0,I=2	;MACRO DEFINES 'PAIRED' TABLES.
.IIF B	<SYM>	.ERROR	;NO NAME GIVEN FOR TABLE BEING DEFINED?
.IIF B	<LEN>	.ERROR	;ZERO LENGTH TABLE BEING DEFINED?
	TMPORG	SROADR
.EVEN
SYM::
	UNORG
.REPT	I
	TMPORG	SRODAT
	.EVEN
	$$$$$$=.
	.BLKW0	LEN,VAL
	UNORG
	TMPORG	SROADR
	.WORD	$$$$$$
	UNORG
.ENDR
.ENDM	DE2TBL

.SBTTL	ORDER THE CSECTS
	DEFORG	SRROO
	DEFORG	SRODAT		;DATA
	DEFORG	SROADR		;ADDRESSES FOR TABLES
	DEFORG	SROCOD		;ROOT code				;005
	ORG	SRROO

.SBTTL	DATA AREA - DEFINE TABLES

.SBTTL	DEFINE 'I/O UNITS' TABLE

	DE2TBL	SAVUNT,DEVSIZ/2,,3	;SAVUNT(3) HOLDS RANDOM DISK DATA
					; FOR 'MOUNTED' DISKS -- SEE SETIO:

.SBTTL	DEFINE THE 'MOUNT' TABLE.

	DE2TBL	MNTTBL,MNTSIZ/2		;DEFINE THE MOUNT TABLE.

.SBTTL	DEFINE THE RELOCATION TABLES

	DE2TBL	RELOC,161.		;BAD BLOCK RELOCATION TABLES

.SBTTL	ROUTINE DISPATCH TABLE - DO NOT CHANGE ORDER

	TMPORG	SRODAT

DISPAT::.WORD	IMAGE		;CALL IMAGE FOR IMAGE			;JDB003
	.WORD	SAVE		;CALL SAVE FOR SAVE			;JDB003
	.WORD	RESTOR		;CALL RESTOR FOR RESTORE		;JDB003
	.WORD	I.INI0		;INIT OPTION OR EXIT IF ILLCAL		;JDB004
	.WORD	RESTOR		;CALL RESTOR FOR INSTALL		;JDB003

	UNORG
GLOBAL	<IMAGE,SAVE,RESTOR,I.INI0>

.SBTTL	SROOT DATA AREA

	TMPORG	SRODAT
SSVOL::	.BLKW0	SSSIZ		;SAVE SET VOLUME INFO.
ORGDSK::.BLKW0	ORGSIZ		;ORIGINAL DISK INFO.
SPCPID::.BLKW0	2		;USER SPECIFIED PACKID
CURFBN::.BLKW0	2		;CURRENT SAVE VOLUME FBN/RECORD NUMBER
RTNNAM::.BLKW0			;ROUTINE NAME
RELPTR::.BLKW0			;RELOCATION TABLE POINTER
STDATE::.BLKW0			;DATE ON WHICH THE RUN STARTED
STTIME::.BLKW0			;TIME AT WHICH THE RUN STARTED
OUTDAT::.BLKW0			;DESIRED OUTPUT EXPIRATION DATE
PKSTAT::.BLKW0			;ORIGINAL PACK STATUS WORD		;JDB002

;NOTE:	THE ONLINE EMULATOR ASSUMES THE PRESENCE OF A GLOBALLY-DEFINED
;	BYTE CALLED "CHANO".  IT IS IGNORED BY INIT.  ONLINE, CHANO
;	DEFINES THE (RSTS) CHANNEL NUMBER OF THE CURRENTLY SELECTED
;	CHANNEL.
;
CHANO::	.BYTE	0		;CHANNEL * 2
OPNFLG::.BYTE	0		; =0 MEANS DISK IS NOT YET OPEN
				;<>0 MEANS DISK IS ALREADY OPEN

;	DEFINE SOME FLAGS
MNTFLG::.BLKW0			;FLAGS FOR MOUNT ROUTINE
OPFLG::	.BLKW0			;OPERATION REQUESTED
SWTWRD::.BLKW0			;USER SPECIFIED SWITCHES
	UNORG

.SBTTL	TIMING INFORMATION

	TMPORG	SRODAT

ELPDAT::.WORD	0		;DATE ON WHICH TRANSFER STARTED
ELPTIM::.WORD	0		;TIME AT WHICH TRANSFER STARTED
ELPSEC::.BYTE	0		;SECS TO NEXT MINUTE AT TRANSFER START
	.BYTE	0		;UNUSED
ELPHRS::.WORD	0		;REAL TIME ELAPSED DURING THE RUN (HRS)
	.BYTE	0		;ELAPSED MINS
	.BYTE	0		;ELAPSED SECS

WAIDAT::.WORD	0		;DATE ON WHICH WE STARTED TO WAIT
WAITIM::.WORD	0		;TIME AT WHICH WE STARTED TO WAIT
WAISEC::.BYTE	0		;SECS TO NEXT MINUTE AT WAIT START
	.BYTE	0		;UNUSED
WAIHRS::.WORD	0		;REAL TIME WAITING FOR OPER/TAPES (HRS)
	.BYTE	0		;WAIT MINS
	.BYTE	0		;WAIT SECS

PRCDAT::.WORD	0		;DATE ON WHICH WE STARTED TO PROCESS
PRCTIM::.WORD	0		;TIME ETC.
PRCSEC::.BYTE	0		;SECS TO NEXT MINUTE AT PROCESS START
	.BYTE	0		;UNUSED
PRCHRS::.WORD	0		;PROCESSING TIME (HRS)
	.BYTE	0		;PROCESS MINS
	.BYTE	0		;PROCESS SECS


BLKXF::	.BLKW0	2		;TOTAL # OF BLOCKS TRANSFERRED
TVERR::	.BLKW0			;TOTAL # OF BAD COMPARES
				;(POSITION THESE 2 HERE TO SAVE A LOOP)
	UNORG

.SBTTL	BUFFERS

	TMPORG	SRODAT
;	BAD BLOCK BUFFERS AND FLAGS
MAXBB::	.WORD	161.		;CURRENT RSTS BAD BLOCK MAXIMUM

BADBI::	.WORD	0		;ADDRESS OF INPUT BAD BLOCK FILE
CBADI::	.WORD	0		;LAST CHECKED KNOWN INPUT BAD BLOCK
				;ALSO MARKS END OF NON-SAVE BAD BLOCK BUFFER
NEWIBB::.WORD	0		;ADDRESS IN BAD BLOCK FILE WHERE NEXT
				; UNEXPECTED INPUT BAD BLOCK SHOULD GO
CNBBI::	.WORD	0		;CURRENT SLOT FOR NEW INPUT BAD BLOCK
NBADI::	.WORD	0		;NUMBER OF INPUT BAD BLOCKS
UNKBBI::.WORD	0		;NUMBER OF UNKNOWN INPUT BAD BLOCKS

BADBO::	.WORD	0		;ADDRESS OF OUTPUT BAD BLOCK FILE
CBADO::	.WORD	0		;LAST CHECKED KNOWN OUTPUT BAD BLOCK
NEWOBB::.WORD	0		;ADDRESS IN BAD BLOCK FILE WHERE NEXT
				; UNEXPECTED OUTPUT BAD BLOCK SHOULD GO
CNBBO::	.WORD	0		;CURRENT SLOT FOR NEW OUTPUT BAD BLOCK
NBADO::	.WORD	0		;NUMBER OF KNOWN OUTPUT BAD BLOCKS
UNKBBO::.WORD	0		;NUMBER OF UNKNOWN OUTPUT BAD BLOCKS

BADBS::	.BLKW0	161.+1		;SMALL BAD BLOCK FILE (FOR RSTS PCN'S)
				; +1 FOR GUARENTEED ZERO LAST ENTRY
BADBL::	.BLKW0	2*161.+2	;LARGE BAD BLOCK FILE (FOR SAVE FBN'S)
				; +2 FOR GUARENTEED ZERO LAST ENTRY


	UNORG
; TRANSFER DATA

	TMPORG	SRODAT
BADRES::.BLKW0	100.		;FOR OUTPUT PCN'S CORRESPONDING TO
				; UNEXPECTED INPUT BAD BLOCKS
BREEND::			;END OF BADRES FILE
BRELEN	==	.-BADRES	;LENGTH (IN BYTES) OF BADRES TABLE
BREPTR::.BLKW0			;POINTER INTO BADRES
BADVER::.BLKW0	100.		;BAD VERIFY FILE
BVEEND::			;END OF BADVER FILE
BVEPTR::.BLKW0			;BAD VERIFY POINTER
TAPNDX::.BLKW0			;TAPE INDEX
TAPUNT::.BLKW0			;TAPE UNIT
PCNUM::	.BLKW0			;PCN COUNTER/POINTER
XFRPCN::.BLKW0	16.		;PCN'S STORED IN BUFBEG
PCSWDS::.BLKW0			;# WORDS/PACK CLUSTER
BUFPCS::.BLKW0			;# BLOCKS/BUFFER
	UNORG

	ORG	SROCOD		;Here's where any code goes...		;005

BLDB1::	CALL	BLDB		;The DIA overlay calls it here...	;005
	CALLRX	BOOLR1		; ...and comes back here.		;005

BLDB2::	CALL	BLDB		;The SAV overlay calls it here...	;005
	CALLRX	BOOLR2		; ...and comes back here.		;005

BLDB:	MOV	#IDX$MU,R0			;Start with MU...	;005
	CALLX	BLDBOT,R5,<SATBUF+11000+14.>	;Make the call.		;005
	CALL	50$,R5				;See if it went OK.	;005
	MOV	#IDX$MS,R0			;Then comes MS...	;005
	CALLX	BLDBOT,R5,<SATBUF+11000+14.+1000>			;005
	CALL	50$,R5							;005
	MOV	#IDX$MM,R0			;Then, MM...		;005
	CALLX	BLDBOT,R5,<SATBUF+11000+14.+2000>			;005
	CALL	50$,R5							;005
	MOV	#IDX$MT,R0			;And, finally, MT.	;005
	CALLX	BLDBOT,R5,<SATBUF+11000+14.+3000>			;005
	CALL	50$,R5							;005
10$:	RETURN					;Get back!!		;005

;+
;	This routine is called immediately after a call to BLDBOT.  It first
;	checks R0 (returned by BLDBOT) to make sure that a bootstrap was
;	found for the specified device and, if so, that it's not too big.
;	It then uses the buffer address argument passed to BLDBOT and fixes
;	the word count in the boot.
;-

50$:	TST	R0			;Was there a boot at all?	;005
	BEQ	60$			;Nope, so go give error.	;005
	MOV	-6(R5),R1		;Get the buffer address.	;005
	ADD	#1000,R1		;This is the biggest it can be.	;005
	CMP	R0,R1			;Have we gone too far?		;005
	BHI	60$			;Yup, so go tell 'em.		;005
	MOV	-6(R5),R1		;Get the buffer address again.	;005
	MOV	BOOTWC,B.TWC-B.BOOT(R1)	;Put the word count in.		;005
	RETURN	R5			;Go back to the mainstream.	;005

60$:	TST	(R5)+			;Put the stack back into shape.	;005
	CLR	R0			;Say an error happened...	;005
	BR	10$			; ...and go back.		;005

.DSABL	LSB

GLOBAL	<SATBUF,BOOTWC>							;005

	.END
