TITLE	SAVCM2,<SAV/RES COMMON FILE 2>,0A,10-MAY-91,JDB

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY
;+									;JDB002
;  001  15-APR-81  AWR	V7.0 PATCH 1.1.12 INSTALLED			;JDB002
;  002  25-APR-84  JDB  MODIFIED DSKIO FOR INSTALL OPTION		;JDB002
;-									;JDB002

.SBTTL	SAVE COMMON DATA/TEXT AREA

	I.DATA
BADDCN:	.BLKW0			;DCN FOUND BAD ON I/O CALL (DSKIO)
BUFPTR:	.BLKW0			;BUFBEG POINTER
M.TBL:	.BLKW0			;ADDRESS OF CURRENT MOUNT TABLE
TMPWRD:	.BLKW0			;TEMP WORD
TMPDWD:	.BLKW0	2		;TEMP DOUBLE WORD
REWFLG:	.BLKW0			;<>0 MEANS REWIND/OFFLINE, 0 MEANS REWIND ONLY
TMPFBN:	.BLKW0	2		;TEMPORARY STORAGE FOR CURFBN
TMPCBO:	.BLKW0			;TEMPORARY STORAGE FOR CBADO
VFY:	.BLKW0			;VERIFY INDICATOR
VOLSEQ:	.BYTE	0		;SAVE VOLUME SEQUENCE NUMBER
RECTYP:	.BYTE	0		;MAGTAPE RECORD TYPE
	.EVEN
	UNORG

;	TEXT

	I.MESS
	.ENABL	LC

;	WORDS TO BE INSERTED IN TEXT
INP:	.ASCIZ	" input"
OUTP:	.ASCIZ	"output"

;	COMMON ROUTINE/PHASE NAMES
VEMSG:	.ASCIZ	"VERIFY pass"
DISNAM:	.ASCII	"DIS"
MNTNAM:	.ASCIZ	"MOUNT "

;	MISC. MESSAGES
CRDMSG:	.ASCIZ	<200>"   Creation date:"<11>
EXDMSG:	.ASCIZ	<200>" Expiration date:"<11>

;	DEVICE RELATED ERRORS
NOWRTB:	.ASCIZ	"Can't write boot"<200>
BADDIR:	.ASCIZ	"Bad directory for device"<200>
TMBBI:	.ASCIZ	"Too many bad blocks on input disk"<200>
TMBBO:	.ASCIZ	"Too many bad blocks on output disk"<200>
	.EVEN
	UNORG

.SBTTL	DATE TEXT

.ENABL	LSB

	I.ADDR
DAYS:	.WORD	10$
	.WORD	20$
	.WORD	30$
	.WORD	40$
	.WORD	50$
	.WORD	60$
	.WORD	70$
	UNORG
	GENTXT
	.ENABL	LC
10$:	.ASCIZ	"Sunday"		;1-JAN-72 WAS A SUNDAY
20$:	.ASCIZ	"Monday"
30$:	.ASCIZ	"Tuesday"
40$:	.ASCIZ	"Wednesday"
50$:	.ASCIZ	"Thursday"
60$:	.ASCIZ	"Friday"
70$:	.ASCIZ	"Saturday"
	.DSABL	LC
	.DSABL	LSB
	UNORG


.SBTTL	MOVTXT - MOVE TEXT

;+
; MOVTXT - MOVE TEXT (TO THE MIDDLE OF QUESTION TEXT)
;
;	CALL	MOVTXT,R5,<FROM,TO>
;
; STRING BEING MOVED MUST END IN A NULL, WHICH IS NOT MOVED
;-

.ENABL	LSB
.ENABL	LC

MOVTXT:	MOV	R4,-(SP)	;SAVE R4
	MOV	R3,-(SP)	; AND R3
	MOV	(R5)+,R4	;GET THE SOURCE
	MOV	(R5)+,R3	;GET THE DESTINATION
10$:	TSTB	(R4)		;END OF THE SOURCE?
	BEQ	20$		;YUP, DON'T MOVE THE NULL
	MOVB	(R4)+,(R3)+	;MOVE THE CHARACTER
	BR	10$		;AND CONTINUE

20$:	MOV	(SP)+,R3	;RESTORE R3
	MOV	(SP)+,R4	; AND R4
	RETURN	R5


;+
; ILLCAL - FATAL SAV/RES BUG
;
;	CALL	ILLCAL
;-

ILLCAL:	CALL	PRTERF		;'FATAL SAV/RES BUG:'
	MESSAG	<"Bad call - ">	;ILLEGAL CALL FROM XXXXX
	MOV	(SP),R0		;GET THE RETURN ADDRESS OF BAD CALL
	CALLX	OCTWRD		;PRINT IT
	EXIT			;DIE

.DSABL	LSB

.SBTTL	PRTNAM - PRINT AN ID

;+
; PRTNAM - GET AND PRINT A PACK ID OR SAVE SET NAME
;
;	R2 	ADDRESS OF FIRST WORD IN A TABLE
;		  (THE PACK ID OR NAME IS AT R2+2)
;
;	CALL	PRTNAM
;
;-

PRTNAM:	MOV	R2,-(SP)	;SAVE R2
	TST	(R2)+		;BUMP PAST 1ST WORD OF THE TABLE
	MOV	(R2)+,R0	;GET 1ST WORD OF THE NAME, POINT TO 2ND
	CALLX	RADZER		;PRINT THE 2ST HALF
	MOV	(R2),R0		;GET THE 2ND WORD OF THE NAME
	CALLX	RADZER		;PRINT THE SECOND HALF
	MOV	(SP)+,R2	;ALL DONE
	RETURN


.SBTTL	PRDAYT - DAY-DATE PRINTER
;+
; PRDAYT - PRINT A DATE IN "DAY-OF-WEEK, DD-MM-YY" FORMAT
;
;	CALL:	R0 = DATE
;		CALL	PRDAYT
;
;	RETURN:	DATE HAS BEEN PRINTED
;-


PRDAYT:	REGSCR			;SAVE REGISTERS CAUSE PRTDAT PLAYS WITH THEM
	MOV	R0,R1		;PRTDAT WANTS THE DATE IN R1
	CALL	CALDAY		;GET DAY-OF-WEEK
	CALLX	ASCIZ0		;PRINT IT
	MESSAG	<", ">		;COMMA - SPACE
	CALLX	PRTDAT		;PRINT DATE
	RETURN

.DSABL	LSB

.SBTTL	CALDAY - CALCULATE DAY OF WEEK

;+
; CALDAY: CALCULATE THE DAY OF THE WEEK
;
;	PASSED:	 R0 = DATE IN INTERNAL FORMAT
;	RETURNS: R0 -> DAY OF WEEK AS ASCIZ TEXT
;
;	NO ERRORS ARE POSSIBLE
;-

CALDAY:	MOV	R2,-(SP)	; SAVE R2
	MOV	R3,-(SP)	;  AND R3
        CLR	R2		; READY TO DIVIDE DATE BY 1000?
        MOV	R0,R3		; DATE TO R3.
        DIV	#1000.,R2	; DIVIDE BY 1000.
        DEC	R3		; R3=DAYS AFTER JAN 1
        MOV	R3,R0		; R0 WILL BE TOTAL DAYS.
        SUB	#2,R2		; MAKE BASE YEAR 1972, INSTEAD OF 1970.
        MOV	R2,R3		; READY TO MULTIPLY YEARS BY 365.?
        MUL	#365.,R3	; DO IT.
        ADD	R3,R0		; ADD 365*Y TO TOTAL DAYS.
        DEC	R2		; FURTHER ADJUST YEARS.
	ASHC	#-2-16.,R2	; DIVIDE BY 4, SHIFT TO R3
        ADD	R0,R3		; ADD IN ALL THE OTHERS.
        DIV	#7,R2		; DO IT.
	ASL	R3		; MAKE IT USEFUL.
        MOV	DAYS(R3),R0	; R0 -> DAY OF WEEK.
	MOV	(SP)+,R3	; RESTORE R3
	MOV	(SP)+,R2	;  AND R2
	RETURN

.SBTTL	SETIO - SET UP TABLES FOR I/O

;+
; SETIO - SET UP TABLES FOR I/O (FAKES SETFNS FOR "MOUNTED" VOLUMES)
;
;	R1 = CHANNEL # (1 OR 2)
;
;	CALL	SETIO
;
;	RETURNS: NOTHING IN PARTICULAR
;
;	NO ERRORS ARE POSSIBLE.
;-

.ENABL	LSB
.ENABL	LC

SETIO:	MOV	R1,-(SP)		;PUT CHANNEL NUMBER ON STACK.
	BEQ	10$			;BLOCK I/O TO CHANNEL 0?
	CMP	R1,#3			;CHANNEL TOO HIGH?
	BLOS	20$			;I/O TO OTHER CHANNELS IS ILLEGAL
10$:	CALL	PRTERF			;'??? FATAL SAV/RES BUG: '
	MESSAG	<"SETIO - ">
	MOV	2(SP),R0		;WHERE WERE WE S'POSED TO GO?
	CALLX	OCTWRD
	MESSAG	<" ,ch ">
	MOV	R1,R0			;WHAT CHANNEL?
	CALLX	OCTWRD
	EXIT				;DIE

20$:	TSTB	CHANO			;HAVE WE BEEN HERE BEFORE?
	BEQ	50$			;NOPE
	ASL	R1			;MAKE IT CHANNEL * 2
	CMPB	CHANO,R1		;SAME CHANNEL AS LAST I/O?
	BEQ	60$			;YUP.
;30$:	CALLF2	WRITEC			;WRITE FIBUF, IF REQUIRED
;	BEQ	40$			;ALL DONE IF Z=1
;	MARK	FIBUF			;MARK IT DIRTY AGAIN
;	CALL	FRESET			;TRY TO RESET THE DISK
;	BCC	30$			;SHALL WE RETRY?
;	CALL	CHKABT			;NO RETRY, SO GO PRINT
					;ABORT MESSAGE AND RESTART

40$:	CLR	FIBPHS			;NOTHING USEFUL IS IN FIBUF. SORRY
	CLR	FIBPHS+2
	MOVB	CHANO,R1		;FIND CORRECT "FAKE UNIT" TABLE
	MOV	SAVUNT-2(R1),R1		;R1=> FAKE DSQ
	MOV	SYSNDX,(R1)+		;SAVE CURRENT DISK INDEX
	MOV	SYSUNT,(R1)+		;SAVE CURRENT UNIT NUMBER
	MOV	DCS,(R1)+		;SAVE DCS
	MOV	CLURAT,(R1)+		;SAVE CLUSTER RATIO
	MOV	PCS,(R1)+		;SAVE PACK CLUSTER SIZE
	MOV	SATSYS,(R1)+		;NUMBER OF SEGMENTS IN SATT.SYS
	MOV	SATSYS+2,(R1)+		; + NUMBER OF BYTES
	MOV	SATSYS+4,(R1)+		; + NUMBER OF PACK CLUSTERS
	MOV	FIPCLU,(R1)+		;CURRENT FILE CLUSTERSIZE
	MOV	FIPMUC,(R1)+		;CURRENT UFD/MFD CLUSTERSIZE

	MOV	(SP),R1			;RESTORE CHANNEL ARG AS PASSED
	ASL	R1			;CALC INDEX INTO ADDRESS TABLES.
	CALL	GETCON			;GO GET CORRECT DISK INDEX, ETC.
50$:	MOV	(SP),R1			;RETRIEVE CHANNEL NUMBER
	ASL	R1			;MAKE IT TIMES 2.
	MOVB	R1,CHANO		;SAVE IT IN CHANO.
60$:	MOV	(SP)+,R1		;RESTORE R1
	RETURN

.DSABL	LSB
GLOBAL	<CHANO,SYSNDX,SYSUNT,SAVUNT,FIBSTA,FIBPHS,FIPCLU,FIPMUC,DCS,PCS>
GLOBAL	<CLURAT,SATSYS>

.SBTTL	OVRCON - PRESERVE CONTEXT ACROSS OVERLAYS

;+
; OVRCON - PRESERVE CONTEXT ACROSS SAVRES OVERLAYS
; GETCON - PRESERVE CONTEXT (SETIO ENTRY, R1 ALREADY SAVED)
;
;
;	CALL	OVRCON
;		CHANO = LAST CHANNEL # USED
;
;	CALL	GETCON
;		R1    = CHANNEL # TO GET CONTEXT FOR
;
;	RETURNS: CONTEXT IS RESTORED
;		 (NOTE THAT CONTEXT WAS ACTUALLY ONLY LOST IN INIT OVERLAYS)
;
;	NO ERRORS ARE POSSIBLE.
;-

.ENABL	LSB

OVRCON:	MOV	R1,-(SP)		;SAVE R1
	MOVB	CHANO,R1		;FIND CORRECT "FAKE UNIT" TABLE
	CALL	GETCON			;DO IT
	MOV	(SP)+,R1		;RESTORE R1
	RETURN

GETCON:	MOV	SAVUNT-2(R1),R1		;R1=START ADDRESS OF FAKE DSQ.
	MOV	(R1)+,SYSNDX		;GET CORRECT DISK INDEX
	MOV	(R1)+,SYSUNT		;AND CORRECT UNIT NUMBER
	MOV	(R1)+,DCS		;AND CORRECT DCS
	MOV	(R1)+,CLURAT		;AND CLUSTER RATIO
	MOV	(R1)+,PCS		;AND PACK CLUSTERSIZE
	MOV	(R1)+,SATSYS		;AND NUMBER OF SEGMENTS IN SATT
	MOV	(R1)+,SATSYS+2		;AND NUMBER OF BYTES IN SATT
	MOV	(R1)+,SATSYS+4		;AND NUMBER OF PACK CLUSTERS
	MOV	(R1)+,FIPCLU		;AND CURRENT FILE CLUSTERSIZE
	MOV	(R1)+,FIPMUC		;AND CURRENT UFD/MFD CLUSTERSIZE
	RETURN

.DSABL	LSB
GLOBAL	<CHANO,SYSNDX,SYSUNT,SAVUNT,FIBSTA,FIBPHS,FIPCLU,FIPMUC,DCS,PCS>
GLOBAL	<CLURAT,SATSYS>

.SBTTL	SELECT-A-CHANNEL

;+
; SELEC1 - SELECT CHANNEL 1
; SELEC2 - SELECT CHANNEL 2
; SELEC3 - SELECT CHANNEL 3
;
;	CALL:	CALL	SETC?
;
;	RETURN:	CORRECT DSQ SET UP FOR I/O
;		M.TBL CONTAINS ADDRESS OF CORRECT MOUNT TABLE (IF 1 OR 2)
;-

.ENABL	LSB

SELEC1:	MOV	R1,-(SP)	;SAVE R1
	MOV	#1,R1		;CHANNEL 1
	MOV	MNTTBL,M.TBL	;TABLE 1
	BR	10$

SELEC2:	MOV	R1,-(SP)	;SAVE R1
	MOV	#2,R1		;CHANNEL 2
	MOV	MNTTBL+2,M.TBL	;TABLE 2
	BR	10$

SELEC3:	MOV	R1,-(SP)	;SAVE R1
	MOV	#3,R1		;CHANNEL 3
10$:	CALL	SETIO		;SET IT
	MOV	(SP)+,R1	;RESTORE R1
	RETURN

.DSABL	LSB
GLOBAL	<MNTTBL>

.SBTTL	?DSKIO - DO DISK I/O

;+
; RDSKIO - READ DATA FROM A DISK
; WDSKIO - WRITE DATA TO A DISK
; DSKIO  - READ DATA FROM OR WRITE DATA TO DISK
;
;	CALL:	R1 = # WORDS TO TRANSFER
;		R2/R3  = FIP BLOCK NUMBER WHERE I/O SHOULD START
;		BUFPTR = BUFPTR MUST BE THE ADDRESS OF THE ADDRESS
;			 WITHIN THE DESTINATION (OR SOURCE) BUFFER.
;
;		CALL	RDSKIO,R5	(= CALL DSKIO,R5,RFUN)
;		CALL	WDSKIO,R5	(= CALL DSKIO,R5,WFUN)
;		CALL	DSKIO,R5,FUN
;
;	RETURN + 0	BAD BLOCK ERROR
;				BADDCN = BAD DCN
;	RETURN + 2	I/O SUCCESSFUL
;
;	NOTE THAT WILL ALWAYS READ/WRITE AS MANY BLOCKS AS POSSIBLE - EVEN
;      IF AN ERROR OCCURS ON ONE OF THE BLOCKS)
;
;-

.ENABL	LSB

RDSKIO:	MOV	#RFUN,130$	;THIS IS A READ
	BR	10$

WDSKIO:	MOV	#WFUN,130$	;THIS IS A WRITE
	BR	10$

DSKIO:	MOV	(R5)+,130$	;GET THE FUNCTION
10$:	MOV	R1,I.DSQ+DSQCNT	;THE WORD COUNT
	MOV	BUFPTR,IOADDR	;GET BUFFER ADDRESS			;AWR001
	CALL	CCTRLC		;BEFORE WE BOTHER.. CTRL/C?
	REGSAV			;SAVE REGISTERS
	CLR	R4		;INITIALIZE BAD DCN HOLDER
20$:	MOVB	#1,NOERR	;SET UP FOR NFS I/O
	MOV	I.DSQ+DSQCNT,R0	;SAVE THE WORD COUNT
	CALL	120$		;DO THE I/O
	TSTB	IOERR		;ANY ERROR?
	BNE	50$		;YUP
30$:	ADD	#2,TOS.R5(SP)	;SUCCESS - RETURN + 2
40$:	MOV	R4,BADDCN	;GET THE BAD DCN
	CALLX	REGRES,R5	;BAD BLOCK - RETURN +0 -- RESTORE REGISTERS
	CLRB	NOERR		;RESET NFS FLAG
	RETURN	R5

50$:	BIT	#OPIN,OPFLG	;ARE WE DOING AN INSTALL?		;JDB002
	BEQ	52$		;NO - SO EVERYTHING IS DONE AS BEFORE	;JDB002
	CMP	M.TBL,MNTTBL	;DID WE FAIL ON THE SAVESET?		;JDB002
	BEQ	55$		;YES - SO GIVE USER A CHANCE TO RETRY	;JDB002
52$:	CMPB	IOERR,#DATERR	;BAD BLOCK ERROR?			;JDB002
	BEQ	60$		;YES - GO DO RECOVERY
55$:	CALL	RETRY		;DOES THE USER WANT TO RETRY?		;JDB002
	MOV	R0,I.DSQ+DSQCNT	;GET BACK THE PROPER WORD COUNT
	CALL	DRESET		;RESET THE DISK
	BR	20$		;DO RETRY

60$:	CALL	150$		;SAVE PCN WRITING TO IN R4
	CMP	#256.,R0	;WERE WE XFERRING MORE THAN A BLOCK ?
	BHIS	40$		;NO - CAN'T DO ANY BETTER - RETURN + 0
	CLR	R4		;ERROR INDICATOR FOR RECOVERY ROUTINE
70$:	CALL	120$		;DO THE I/O
	TSTB	IOERR		;ANY ERROR?
	BNE	90$		;YES
80$:	SUB	#256.,R0	;WE'VE TRANSFERRED 1 BLOCK - WAS IT THE LAST
	BEQ	110$		;YES - ALL DONE
	ADD	#512.,IOADDR	;NO-INCREMENT BUFFER POINTER BY A BLOCK	;AWR001
	ADD	#1,R2		;INCREMENT FBN TO GET
	ADC	R3
	BR	70$		;GET NEXT BLOCK

90$:	BIT	#OPIN,OPFLG	;ARE WE DOING AN INSTALL?		;JDB002
	BEQ	92$		;NO - SO EVERYTHING IS DONE AS BEFORE	;JDB002
	CMP	M.TBL,MNTTBL	;DID WE FAIL ON THE SAVESET?		;JDB002
	BEQ	95$		;YES - SO GIVE USER A CHANCE TO RETRY	;JDB002
92$:	CMPB	IOERR,#DATERR	;BAD BLOCK ERROR?			;JDB002
	BEQ	100$		;YES - GO SET ERROR INDICATOR
95$:	CALL	RETRY		;DOES THE USER WANT TO RETRY?		;JDB002
	CALL	DRESET		;RESET THE DISK
	BR	70$		;YES - RETRY THE RETRY

100$:	CALL	150$		;SAVE THE BAD DCN
	BR	80$		;GO SEE IF WE'RE FINISHED

110$:	TST	R4		;ANY ERRORS ?
	BEQ	30$		;NO - SUCCESS -	RETURN + 2
	BR	40$		;BAD BLOCK ERROR - RETURN + 0

120$:	CLRB	IOERR		;ENSURE IOERR IS CLEAR BEFORE WE DO I/O
	CALLX	PARSEX,R5	;DO SOME I/O
130$:	  .WORD	0		;FUNCTION
IOADDR:	  .WORD	0		;BUFFER ADDRESS				;AWR001
	RETURN

150$:	TST	R4		;HAS THERE ALREADY BEEN A BAD BLOCK ?
	BNE	160$		;YES
	MOV	R2,-(SP)	;SAVE FBN LSB
	MOV	R3,-(SP)	;SAVE FBN MSB
	CALL	SEG2DN		;CONVERT FBN TO DCN
	MOV	R2,R4		;STORE THE DCN
	MOV	(SP)+,R3	;RESTORE FBN MSB
	MOV	(SP)+,R2	;RESTORE FBN LSB
160$:	RETURN

GLOBAL	<I.DSQ,NOERR,IOERR>
.DSABL	LSB

.SBTTL	DISMNT/DISMNE - DISMOUNT ROUTINE

;+
; DISMNT - DISMOUNT A VOLUME - PRINT APPROPRIATE DISMOUNT MESSAGE
;				AND CALL ENDFIP IF DISK
; DISMNE - SAME AS DISMOUNT EXCEPT THE SAVE VOLUME SEQUENCE NUMBER
;	   IS TAKEN FROM VOLSEQ
;
;	CALL:	INFORMATION SET UP IN MNTTBL AND SSVOL
;		FLAG WORDS: OPFLG AND MNTFLG SET UP
;		CALL	DISMNT
;
;	RETURN:	IT HAS BEEN DONE
;-

.ENABL	LSB
.ENABL	LC

DISMNT:	MOV	(PC),REWFLG	;USE SPARE FLAG TO INDICATE REWIND/OFFLINE
	MOVB	SSVOL+SSSEQ,VOLSEQ	;GET SS SEQ. #
	BR	10$

DISMNE:	CLR	REWFLG		;REWIND ONLY
10$:	REGSCR			;SAVE REGISTERS
	MOV	RTNNAM,-(SP)	;SAVE NAME OF CALLING ROUTINE
	MOV	#DISNAM,RTNNAM	;SET UP DISMOUNT ROUTINE NAME
	TST	INPUT		;OUTPUT DISMOUNT ?
	BEQ	20$		;YES
	CALL	SELEC1		;SELECT CHANNEL 1
	BR	30$		;GET ON WITH IT

20$:	CALL	SELEC2		;SELECT CHANNEL 2
30$:	MOV	M.TBL,R4	;MAKE SURE R4 SET UP PROPERLY
	TSTB	MNTIDX(R4)	;VOLUME MAGTAPE ?
	BPL	50$		;NOPE
	TST	REWFLG		;JUST REWIND
	BEQ	40$		;NO, BOTH
	CALL	REWOFF		;DO A REWIND AND OFFLINE
	BR	50$

40$:	CALL	REWIND		;REWIND ONLY
50$:	CALLX	TYPECR		;FIRST, PUT US ON A NEW LINE
	BIT	#OPID,OPFLG	;ARE WE IDENTIFYING?
	BEQ	60$		;NO
	MESSAG	<"         ">	;PRINT BLANKS
	BR	70$		; INSTEAD OF 'DISMOUNT'

60$:	MESSAG	<" Dismount">
70$:	MESSAG	<" Device:"<11>>
	TYPDEV			;PRINT THE DEVICE
	BITB	#FMTRST,MNTFMT(R4)	;FORMAT RSTS ?
	BEQ	80$		;NO
	CALL	PRTRST		;PRINT RSTS DISK INFO
	CALLX	ENDFIP		;RSTS CLEAN UP
	BR	90$		;ALL DONE

80$:	BITB	#FMTSAV,MNTFMT(R4)	;FORMAT SAVE ?
	BEQ	90$		;NO - EXIT
	MESSAG	<<200><11>"Set Name:"<11>>
	PRTID	R4		;PRINT THE SAVE SET NAME
	MESSAG	<<200><11>"   Seq #:"<11>>
	DECZER	VOLSEQ		;SAVE SET SEQ. #
	CALL	PRTSAV		;PRINT REST OF SAVE SET ONFO
90$:	CALLX	TYPECR		;NEW LINE
	MOV	(SP)+,RTNNAM	;GET BACK THE RIGHT NAME
	RETURN			;ALL DONE

.DSABL	LSB
GLOBAL	<SSVOL,RTNNAM,MNTTBL,OPFLG>

.SBTTL	TYPDEV - TYPE A DEVICE NAME

.ENABL	LSB
.ENABL	LC

TYPDEV:	MOV	(R4),R2		;GET DEVICE
	CALLX	TYPE2		;PRINT IT
	DECZER	MNTUNT(R4)	;PRINT UNIT NUMBER
	MESSAG	<":">		;END WITH A COLON
	RETURN

.SBTTL	PRTRST - PRINT RSTS DISK INFO

;+
; PRTRST - PRINT PARTIAL RSTS DISK INFO
;
;	R4 -> APPROPRIATE MOUNT TABLE
;
;	CALL	PRTRST
;
;-

PRTRST:	MESSAG	<<200><11>" Pack ID:"<11>>
	PRTID	R4		;PRINT THE PACK ID
	MESSAG	<<200>"Pack Clustersize:"<11>>
	DECZER	MNTPCS(R4)	;PRINT PCS
	CALLX	MESSAG,R5,CRDMSG ;'CREATION DATE'
	PRDAYT	MNTDCR(R4)	;CREATION DATE
	RETURN			;ALL DONE

;+
; PRTSAV - PRINT PARTIAL SAVE SET INFO
;
;	R4 -> SAVE SET TABLE
;
;	CALL	PRTSAV
;
;-

PRTSAV:	TSTB	MAGTAP		;THIS A MAGTAPE VOLUME ?
	BEQ	10$		;NO - DON'T PRINT DENSITY
	MESSAG	<<200><11>" Density:"<11>>
	MOV	SSDEN(R4),R0	;GET DENSITY
	CALLX	DECZER		;PRINT IT
10$:	CALLX	MESSAG,R5,CRDMSG ;'CREATION DATE'
	PRDAYT	SSDCR(R4)	;DATE OF CREATION
	CALLX	MESSAG,R5,EXDMSG ;'EXPIRATION DATE'
	PRDAYT	SSEXP(R4)	;DATE OF EXPIRATION
	RETURN			;ALL DONE

.DSABL	LSB
GLOBAL	RTNNAM


.SBTTL	DRESET - NFS DISK RESET

;+
; DRESET - NON-FILE STRUCTURED DISK RESET CALLER
;
;	CALL:	SYSNDX = DISK INDEX
;		SYSUNT = DISK UNIT #
;		CALL	?RESET
;
;	RETURN:	IT HAS BEEN DONE
;
; NOTE THAT RETFRE ISSUES A CALL TO RETRY BEFORE ENTERING FRESET; THIS
;	ENTRY IS FREQUENTLY USED WHEN A FILE-STRUCTURED 'ERROR' HAS 
;	OCCURRED.
;-

.ENABL	LSB

DRESET:	MOV	R1,-(SP)	;SAVE R1
	MOV	R4,-(SP)	;SAVE R4
10$:	MOV	SYSNDX,R1	;GET THE INDEX
	MOV	SYSUNT,R4	;GET THE UNIT #
	CLRB	IOERR		;GET RID OF OLD ERROR
	CALLX	XXRSET		;DO THE RESET
	BCC	20$		;ALL WENT WELL
	MOVB	#HNGDEV,IOERR	;INDICATE DEVICE WAS HUNG
	CALL	RETRY		;LET HIM FIX IT
	BR	10$		;WANTS TO TRY AGAIN

20$:	MOV	(SP)+,R4	;RESTORE R4
	MOV	(SP)+,R1	;RESTORE R1
	RETURN


.DSABL	LSB
GLOBAL	<SYSNDX,SYSUNT,IOERR>

.SBTTL	SEG2D?: CONVERT FIP BLOCK NUMBER TO DEVICE CLUSTER NUMBER

;+
; SEG2DN - CONVERT FIP BLOCK NUMBER TO DEVICE CLUSTER NUMBER
; SEG2D2 - DO SAME USING R1 AS THE DEVICE CLUSTER SIZE
;
;	CALL:	R2/R3 = FIP BLOCK NUMBER
;		DCS   = DEVICE CLUSTER SIZE (SEG2DN)
;		R1    = DEVICE CLUSTER SIZE (SEG2D2)
;		CALL	SEG2D?
;
;	RETURN:	R2 = DEVICE CLUSTER NUMBER
;		R3 <> 0 IF FBN WAS NOT ON DEVICE CLUSTER BOUNDARY
;		CONDITION CODES SET IN R3 (Z=1 IF BOUNDARY OK)
;-

	.ENABL	LSB

SEG2D2:	MOV	R1,-(SP)	;THE DEVICE CLUSTER SIZE
	BR	10$		;ON WITH IT

SEG2DN:	MOV	DCS,-(SP)	;THE DEVICE CLUSTER SIZE
10$:	SUB	#1,R2		;DCN = ((FBN - 1)/DCS) + 1
	SBC	R3		;SUBTRACT 1
20$:	ASRB	(SP)		;DIVIDE BY DCS
	BCS	30$		;ITS DONE
	ASR	R3		;SHIFT MSB
	ROR	R2		; BRING BITS INTO LSB
	ROLB	1(SP)		;SHIFTED OUT BITS TO STACK
	BR	20$		;DO IT AGAIN

30$:	INC	R2		;PLUS 1
	MOV	(SP)+,R3	;SET CC'S AND R3
	RETURN

.DSABL	LSB
GLOBAL	<DCS>

