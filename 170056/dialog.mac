TITLE	DIALOG,<SAV/RES DIALOGUE>,0A,10-MAY-91,JDB

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR DIALOG
;+
;
;  001  JDB  25-APR-84  ADDED INSTALL OPTION AND MODFIFIED		;JDB001
;			OPTION ARGUMENT TO TAKE DIALOG ROUTINE AS AN	;JDB001
;			ARGUMENT					;JDB001
;  002  JDB  26-APR-84  MAKE NOSTATS THE DEFAULT			;JDB002
;  003  JDB   2-APR-85  MAKE STATS THE DEFAULT AGAIN			;JDB003
;  004  JDB  27-FEB-87	DIALOG SPECIFIC BOOTBUILDER TO CONSOLIDATE DSMNT;JDB004
;  005  BGN  09-JAN-89	REMOVE SAVE OPTION				;BGN005
;
;-

.SBTTL	DIALOGUE MACROS

.MACRO	I.MESS
	TMPORG	DIATXT
.NLIST	BEX
.ENDM	I.MESS

.MACRO	I.DATA
	TMPORG	DIACTL
.NLIST	BEX
.ENDM	I.DATA

.MACRO	I.ADDR
	TMPORG	DIAADR
.NLIST	BEX
.ENDM	I.ADDR

.MACRO	OPTION	N1,N2,F,DROUTN,DESC,DSC1				;JDB001
.IF NB	<DESC>
	I.MESS
	 .ASCII	<40><40><40><40>"N1'N2"<11>"DESC"<200>
	UNORG
.ENDC
.IF NB	<DSC1>
	I.MESS
	 .ASCII	<11><11>"DSC1"<200>
	UNORG
.ENDC
	TMPORG	DIAOPT
	 .WORD	DROUTN		;SAVRES N1'N2 DIALOGUE ROUTINE		;JDB001
	TMPORG	DIAOTX
	 UNQTXT	<N1\N2>
	TMPORG	DIAFLG
	 .WORD	F
	UNORG
.ENDM	OPTION

.MACRO	ASK	C,L2,L1
.NLIST
	 CALL	ASKNLF,R5	;ASK A 2 PART QUESTION - NO DEFAULT
	  .WORD	C		; SHORT FORM
	  .WORD	L2		; 2ND PART OF LONG FORM
	  .WORD	L1		; 1ST PART OF LONG FORM
.LIST
.ENDM	ASK

.SBTTL	MORE DIALOGUE MACROS

.MACRO	WARN	M
.NLIST
	 CALL	WARN,R5
.IF	NB	M
	  .WORD	M
.ENDC
.LIST
.ENDM	WARN

.MACRO	STAR	M
.NLIST
	 CALL	STAR,R5
	  .WORD	M
.LIST
.ENDM	STAR

.MACRO	DEFALT	M
.NLIST
	 CALL	DEFALT,R5
	  .WORD	M
.LIST
.ENDM	DEFALT

.MACRO	MOVTXT	FROM,TO
.NLIST
	 CALL	MOVTXT,R5
	  .WORD	FROM
	  .WORD	TO
.LIST
.ENDM	MOVTXT

.MACRO	PRTID	C
.NLIST
.IF	NB	<C>
	MOV	C,R2		;SET UP FOR PRTNAM
.ENDC
	 CALL	PRTNAM		;PRINT THE ID
.LIST
.ENDM	PRTID

.MACRO	PRTIDC	C
.NLIST
	PRTID	C
	CALLX	TYPECR		; AND A <CR>
.LIST
.ENDM	PRTIDC

.MACRO	PRDAYT	C
.NLIST
.IF NB <C>
	MOV	C,R0
.ENDC
	CALL	PRDAYT		;PRINT 'DAY-OF-WEEK, DD-MMM-YY'
.LIST
.ENDM	PRDAYT

.SBTTL	DIALOGUE BRANCHING MACROS

.MACRO	.TAG		;DEFINE NEXT SEQUENTIAL TAG
.DSABL	CRF
TAGNUM	= TAGNUM+1	;NEXT SEQUENTIAL TAG
.IRP	N,<\TAGNUM>
.ENABL	CRF
.LIST
TAG'N:
.NLIST
.ENDM
.ENDM	.TAG

.MACRO	LOOP	C,FUDGE		;BRANCH ON CONDITION 'C' TO CURRENT "TAG"
.DSABL	CRF
.IRP	N,<\<FUDGE+TAGNUM>>
.ENABL	CRF
.IF	NB	<C>
	 B'C	TAG'N
.IFF
	 BR	TAG'N
.ENDC
.ENDM
.ENDM	LOOP

.MACRO	SKIP	C		;SKIP TO NEXT "TAG" ON CONDITION 'C'
	LOOP	<C>,+1
.ENDM	SKIP

.MACRO	BACK	C		;BACK TO PREVIOUS "TAG" ON CONDITION "C"
	LOOP	<C>,-1
.ENDM	BACK

.SBTTL	ORDER THE CSECTS
	DEFORG	DIA		;CODE
	DEFORG	DIACTL		;DATA
	DEFORG	DIAOPT		;FUNCTION DISPATCH
	DEFORG	DIAOTX		;FUNCTION NAME TEXT
	DEFORG	DIAFLG		;REQUESTED FUNCTION FLAG
	DEFORG	DIATXT		;DIALOGUE TEXT
	DEFORG	DIAADR		;ADDRESSES
	ORG	DIA

.SBTTL	BASIC SWITCHES

	TMPORG	DIACTL
DISWIT:	UNQTXT	</EX\PIRATION>	;MUST BE FIRST
	UNQTXT	</NOEX\PIRATION>
	UNQTXT	</VE\RIFY>
	UNQTXT	</NOVE\RIFY>
	UNQTXT	</ER\ROR>
	UNQTXT	</NOER\ROR>
	UNQTXT	</ST\ATS>
	UNQTXT	</NOST\ATS>
	.BYTE	0		;END OF THE BASIC SWITCHES
	.EVEN
	UNORG

	TMPORG	DIACTL	
SETBIT:	.WORD	EX		;/EXPIRATION
	.WORD	NOEX		;/NOEXP
	.WORD	VE		;/VERIFY
	.WORD	NOVE		;/NOVERIFY
	.WORD	ER		;/ERROR
	.WORD	NOER		;/NOERR
	.WORD	ST		;/STATS
	.WORD	NOST		;/NOSTATS
CONBIT:	.WORD	NOEX		;CAN'T HAVE /NOEX WITH /EX
	.WORD	EX		;CAN'T HAVE /EXP WITH /NOEXP
	.WORD	NOVE		;CAN'T HAVE /NOVE WITH /VERIFY
	.WORD	VE		;CAN'T HAVE /VERIFY WITH /NOVERIFY
	.WORD	NOER		;CAN'T HAVE /NOERROR WITH ERROR
	.WORD	ER		;CAN'T HAVE /ERROR WITH /NOERROR
	.WORD	NOST		;CAN'T HAVE /NOSTATS WITH /STATS
	.WORD	ST		;CAN'T HAVE /STATS WITH /NOSTATS
	UNORG	

	TMPORG	DIACTL
WRKBUF:	.BLKW0	32.		;WORK BUFFER - FOR SAVING INPUT LINE
VERFY:	.BLKW0			;<>0 MEANS VERIFY, 0 MEANS DON'T
PROCED:	.BLKW0			;<>0 MEANS PROCEED TO CALL TRANSFER ROUTINE
				;0 MEANS EITHER BAD OPTION, HELP, IDENTIFY, OR
				;  USER ANSWERED 'NO' TO PROCEED QUESTION.
	UNORG

.SBTTL	DIALOGUE ONLY TEXT

	I.MESS
	.ENABL	LC

;	OUR NAME
DIAMSG:	.ASCIZ	"Dialogue"

;	SWITCH ERRORS
ILLCMN:	.ASCII	"Illegal command: no "
ILLCIO:	.ASCIZ	"       device specified"<200>
ILLDAT:	.ASCIZ	"Illegal date"<200>
ILLCOM:	.ASCIZ	"Illegal switch combination"<200>

;	WORDS TO BE INSERTED IN TEXT
SRPRM:	.ASCIZ	"SAV/RES Function: prompt."
SSNMSG:	.ASCIZ	"Save Set Name"
PID:	.ASCIZ	"  Pack  Id   "
VEIM:	.ASCIZ	"the IMAGE copy operation."
VEEACH:	.ASCIZ	"each output volume.      "

;	FREQUENTLY USED SHORT FORM QUESTIONS
FRRDK:	.ASCIZ	<200>"From RSTS disk? "
TODEV:	.ASCIZ	<200>"To Device? "
FRDEV:	.ASCIZ	<200>"From Device? "
TORS:	.ASCII  <200>"To RSTS "
DSKDX:	.ASCIZ	"Dx: Disk? "

;	FREQUENTLY USED LONG FORM QUESTIONS

MATMSG:	.ASCII	"Include a "
MATID:	.ASCII	"              if you want SAVRES to ensure it"<200>
	.ASCII	"matches  the  one  on the volume.  This drive should be"<200>
	.ASCIZ	"WRITE-LOCKED."<200>

OVRRID:	.ASCII	"Include a "
OVRID:	.ASCII	"              if you  wish  to  override  the"<200>
	.ASCII	"default.   This  drive  should  have  a  SCRATCH volume"<200>
	.ASCIZ	"mounted, and must be WRITE-ENABLED."<200>
	.EVEN
	UNORG

.SBTTL	HELP MESSAGE TEXT

.ENABL	LC

;	I.MESS								;BGN005
;ALLHLP:	.ASCII	<177>						;BGN005
;	UNORG								;BGN005
;									;BGN005
;	OPTION	SA,VE,OPSV,DIASA,<Make a safe copy of a RSTS/E file-structured disk.>	;JDB001 ;BGN005

	I.MESS
SAVHLP:	.ASCII	<177>
	UNORG

	OPTION	RE,STORE,OPRE,DIARE,<Restore a RSTS/E file-structured disk from a SAVE Set.>	;JDB001
	OPTION	IM,AGE,OPIM,DIAIM,<Copy a volume image from a RSTS/E file-structured disk>,<to a LIKE disk.>	;JDB001
	OPTION	IN,STALL,OPIN,DIARE,<Create a RSTS/E file-structured disk from an>,<installation kit>	;JDB001
	OPTION	ID,ENTIFY,OPID,DIAID,<List the characteristics of a SAVE Set or RSTS/E disk.>	;JDB001
	OPTION	HE,LP,OPHE,DIAHE,<Print this list of acceptable responses.>
	I.MESS			;CLOSE OUT THE HELP MESSAGE
	 .ASCIZ	"Only the first two characters need be typed."<200>

	TMPORG	DIAOPT
	 .WORD	ILLFUN		;CATCH ILLEGAL OPTIONS

	TMPORG	DIAOTX
	 .BYTE	0		;END OPTION TEXT

	TMPORG	DIAFLG
	 .WORD	OPBD		;FOR ILLEGAL OPTIONS

	UNORG

.SBTTL	SAV/RES FUNCTION: DISPATCH

.ENABL	LSB
.ENABL	LC

TAGNUM	=	0

SRDIAL::CALLX	DATINI		;GET CURRENT DATE & TIME (OFFLINE, FROM USER)
	MOVB	#3*2,CHANO	;SYSTEM DISK CHANNEL NUMBER
10$:	CLRB	HIGHBF
	MOVB	#-1,BACKUP	;TO SUPPRESS ERROR LOGGING
	CLR	FIBPHS		;MAKE SURE WE WON'T INHIBIT READ OF MFD
	CLR	FIBPHS+2
	MOVB	#-1,OPNFLG	;SAYS CURRENT DEVICE IS OPEN
20$:	CALL	FSIO1		;PRE I/O CALL
	CALLX	SETFIP		;SET UP THE SYSTEM DISK
	CALL	FSIO2		;POST CALL - CHECK FOR ERROR
	BEQ	30$		;WE'RE ALL SET
	CALL	RETRY		;I/O PROBLEMS - GOTTA PROMPT FOR RETRY
	BR	20$		;TRY IT AGAIN

30$:	CALL	SELEC1		;FORCE IN SYSTEM DISK STUFF
	CALL	SELEC3		;RE-EXTRACT IT
	MOV	#DIAMSG,RTNNAM	;SET ROUTINE NAME TO 'DIALOGUE'
	BIS	#DIALMT,MNTFLG	;SET DIALOGUE MOUNT BIT
	CALLX	TYPECR		;NEW LINE
	CALLX	ASKER,R5	;ASK FOR A SAV/RES FUNCTION
	  GENTXT <<200>"SAV/RES Function: ">
	  GENTXT
	   .ASCII <200>"Please enter one of the valid SAV/RES functions,"<200>
	   .ASCIZ "or type 'HELP' for a help message: "
	  UNORG
	BCS	DIAEXI		;CTRL/Z? - IF SO, EXIT TO OPTION: OR READY
	BEQ	DIAEXI		;LINE FEED? - IF SO, EXIT
	CLR	OPFLG		;CLEAR THE OPERATION REQUESTED FLAG
	CLRB	OPNFLG		;CLEAR THE DISK OPEN FLAG
	CLR	VERFY		;CLEAR THE VERIFY FLAG
	CLR	PROCED		;CLEAR THE PROCEED TO TRANSFER FLAG
	MOV	#SSSIZ/2,R2
	MOV	#SSVOL,R3	;CLEAR OUT THE SAVE SET TABLE
40$:	CLR	(R3)+
	SOB	R2,40$
	CALLX	GETUNQ,R5,DIAOTX ;PARSE ON THE FUNCTION TEXT
	BIS	DIAFLG(R0),OPFLG ;SET OPERATION BIT
	BIT	#OPBD!OPHE,OPFLG ;DON'T BOTHER WITH SWITCH SCAN IF IT'S
	BNE	60$		; AN ILLEGAL FUNCTION OR USER NEEDS HELP
	TSTB	SAVDEV		;BOOTED FROM A SAVE VOLUME ?
	BNE	80$		;YES - DON'T LET EM DO A SAVE
	TST	SYSNDX		;BOOTED FROM A TAPE?
	BMI	80$		;YES - CAN'T DO A SAVE
50$:	CALL	SETDAT		;GET THE CURRENT DATE AND TIME
	MOV	I.DATE,STDATE	;SAVE DATE FOR MOUNT CHECKS
	MOV	I.TIME,STTIME	;SAVE THE TIME
	MOV	R0,-(SP)	;SAVE OUR POINTER
	CALL	SCAN		;PARSE ANY SWITCHES
	MOV	(SP)+,R0	;GET BACK OUR POINTER
	BCS	SVRST		;ANY ERROR?
60$:	CALL	@DIAOPT(R0)	;GO TO THE OPTION
	TST	PROCED		;CHECK PROCEED TO TRANSFER FLAG
	BEQ	70$		;IF 0, JUST HELP OR IDENTIFY (ALREADY DONE),
				;USER TYPED CTRL/Z TO FIRST QUESTION, OR
				;USER SAID 'NO' TO PROCEED PROMPT
	CALLRX	SRDOIT		;HAVE XFER INVOKED

70$:	BIT	#OPHE!OPID,OPFLG ;HELP DIDN'T OPEN ANY CHANNELS - IDENT ONLY
	BNE	SVRST		; THE INPUT CHANNEL - DON'T PULL IN OVERLAY
	CALLRX	SRDONE		;GO CLEAR SOME CHANNELS

80$:	BIT	#OPSV,OPFLG	;THIS A SAVE OPERATION REQUEST ?
	BEQ	50$		;NO
	MESSAG	<<177><200>"Illegal option">
	BR	SVRST		;START OVER

SVRST::	MOVB	#2*2,CHANO	;ENSURE SYSTEM DISK INFO. IS RE-EXTRACTED
	CALL	SELEC3		;RESELECT THE SYSTEM DISK
	BR	10$		;RESTART

DIAEXI:	EXIT			;GET OUT


BBDIA::	JMP	BBRET		;RETURN FROM BBLOK -> BACK TO MOUNT

.DSABL	LSB

GLOBAL	<MNTFLG,OPFLG,OPNFLG,BACKUP,I.DATE,I.TIME,HIGHBF,RTNNAM>
GLOBAL	<CHANO,STDATE,STTIME,FIBPHS,SSVOL,SAVDEV>

.SBTTL	TRAP ILLEGAL FUNCTIONS

ILLFUN:	MESSAG	<<177><200>"Type 'HELP' for help.">
	RETURN		;INVALID FUNCTION - GET FUNCTION AGAIN

.SBTTL	HELP FUNCTION

DIAHE:	MESSAG	<<177><12>"The valid SAV/RES functions are:"<200>>
;	TSTB	SAVDEV		;BOOTED FROM A SAVE VOLUME ?		;BGN005
;	BNE	10$		;YES LET EM KNOW THAY CAN'T 'SAVE'	;BGN005
;	TST	SYSNDX		;BOOTED FROM A TAPE?			;BGN005
;	BMI	10$		;YES - CAN'T DO A SAVE			;BGN005
;	CALLX	MESSAG,R5,ALLHLP;PRINT HELP TEXT     			;BGN005
;	RETURN

10$:	CALLX	MESSAG,R5,SAVHLP ;PRINT TEXT, STARTING FROM RESTORE
	RETURN

.SBTTL	SAVE DIALOGUE

	.ENABL	LSB

DIASA::	TST	FULL		;WAS A FULL COMMAND SPECIFIED?
	BNE	20$		;YES, GO PRINT SOURCE ID
.TAG
	MOVTXT	INP,DEVIO	;PREPARE TO ASK FOR INPUT DEVICE
	MOVTXT	PID,MATID	;MAY WANT TO MATCH 'PACK ID'
	ASK	FRRDK,MATMSG,ASKDEV ;GET THE INPUT SPEC - NO DEFAULT
	BCC	10$		;CTRL/Z?
	JMP	SRSEND		; YES - RETURN TO SAV/RES FUNCTION:

10$:	CALL	CHKIN		;CHECK THE INPUT SPEC
	LOOP	CS		;NO GOOD - REPEAT THIS QUESTION
20$:	CALL	JSTAR		;'*** '
	MESSAG	<"Pack ID">
	DEFALT	SSNMSG		;'/DEFAULT SAVE SET NAME'
	MESSAG	<" is ">
	PRTIDC	MNTTBL		;PRINT THE NAME
	TST	FULL		;WAS A FULL COMMAND SPECIFIED?
	BNE	30$		;YES, GO PRINT OUTPUT ID
.TAG
	MOVTXT	OUTP,DEVIO	;PREPARE TO ASK FOR OUTPUT DEVICE
	MOVTXT	SSNMSG,OVRID	;MAY WANT TO OVERRIDE 'SAVE SET NAME'
	ASK	TODEV,OVRRID,ASKDEV ;GET THE OUTPUT SPEC - NO DEFAULT
	BACK	CS		;CTRL/Z? - YES, GO BACK TO PREVIOUS ?
	CLRB	SSVOL+SSSEQ	;BACK TO 1ST SEQ #
	CALL	CHKOU		;CHECK THE OUTPUT SPEC
	LOOP	CS		;NO GOOD - REPEAT THIS QUESTION
30$:	STAR	SSNMSG		;'*** SAVE SET NAME'
	MESSAG	<" is ">	;'IS'
	PRTIDC	#SPCPID-2	;PRINT THE NAME
	SKIP			;GO SEE IF WE WILL ASK DATE QUESTION

40$:	BIT	#EX!NOEX,SWTWRD ;BACKING UP - ANY DATE SWITCHES SPECIFIED?
	LOOP	NE		;YES - KEEP BACKING UP
.TAG
	BIT	#EXDAT,SWTWRD	;[:DATE] SPECIFIED?
	BNE	50$		;YES - DATE ALREADY STORED
	CALL	SETDAT		;GET THE CURRENT DATE
	MOV	I.DATE,OUTDAT	;SAVE IT (AS IS FOR /NOEXP)
	BIT	#NOEX,SWTWRD	;WAS /NOEXPIRATION SPECIFIED?
	BNE	50$		;YES - USE CURRENT DATE
	ADD	#1000.,OUTDAT	;STORE 1 YEAR FROM TODAY - USE WITH /EXP OR
				; TO PRINT DEFAULT IF ASKING DATE QUESTION
	CALL	130$		;ADJUST FOR LEAP YEAR?
50$:	TST	FULL		;WAS A FULL COMMAND SPECIFIED?
	BNE	110$		;YES - GO ASK PROCEED QUESTION
	BIT	#EX!NOEX,SWTWRD ;ANY DATE SWITCH SPECIFIED?
	BNE	100$		;YES - SKIP DATE QUESTION
	MOV	#80$,R0		;POINT TO DATE BUFFER
	MOV	OUTDAT,R1	;SET UP TO MOVE DEFAULT DATE STRING
	CALLX	DATSTR		;AND DO IT
	SKIP			;GO ASK DATE QUESTION

60$:	WARN	ILLDAT		;RESPONDED WITH 'ILLEGAL DATE' - REPROMPT
.TAG
	CALLX	ASKER,R5	;SAVE - ASK FOR EXPIRATION DATE.
	  .WORD	70$
	  GENTXT
	   .ASCII <200>
	   .ASCII "Type the desired expiration date or press the LINE FEED"<200>
	   .ASCII "key to accept the date printed."<200>
70$:	   .ASCII <200>"Expiration Date <"
80$:	   .ASCIZ "         >? "
	  UNORG
	LOOP	CS,-2		;CTRL/Z? - YES, GO BACK TO PREVIOUS ?
	SKIP	EQ		;LINE FEED = DEFAULT, ON TO NEXT QUESTION
	CALLX	CKDATE		;GOT SOMETHING, CHECK THE DATE
	BCS	60$		;BAD DATE - GO ISSUE ERROR AND REPROMPT
	MOV	R1,OUTDAT	;REPLACE DEFAULT WITH USER SPECIFIED DATE
	SKIP			;AND ON TO THE NEXT QUESTION

90$:	BIT	#VE!NOVE,SWTWRD	;WERE VERIFICATION SWITCHES SPECIFIED?
	BNE	40$		;YES - KEEP BACKING UP

.TAG
100$:	BIT	#VE!NOVE,SWTWRD	;ASK OR BYPASS THIS QUESTION
	SKIP	NE		;BYPASS - ON TO PROCEED QUESTION
	CLR	VERFY		;VERIFY? - DEFAULT IS NO
	MOVTXT	VEEACH,VEWH	;VERIFY AFTER 'EACH OUTPUT' VOLUME
	CALLX	YESNO,R5	;WHAT DOES THE USER WANT
	  .WORD	VESHRT
	  GENTXT	,ASKVE
	   .ASCII <200>
	   .ASCII "Type 'Yes' if you want SAVRES to compare the input  and"<200>
	   .ASCII "output volumes at the end of "
VEWH:	   .ASCII "     "
VEWH2:	   .ASCII "                    "<200>
	   .ASCII "Type 'No' or press the LINE FEED key if you do not want"<200>
	   .ASCII "SAVRES to perform this verification."<200>
VESHRT:	   .ASCIZ <200>"Verify (Yes or No) <NO>? "
	  UNORG
	BR	40$		;CTRL/Z - BACK TO PREVIOUS ?
	NOP			;LF  =  NO
	SKIP			;NO  -- DON'T SET THE FLAG
	MOV	(PC),VERFY	;YES -- SET THE FLAG
.TAG
110$:	CALL	SETPRC		;SET UP TO ASK RIGHT PROCEED QUESTION
	CALL	SRPRCD,R5	;PROCEED (YES OR NO)?
	  BR	90$		;^Z  -- ASK PREVIOUS QUESTION
	  BR	SRSEND		;NO  -- BACK TO MAIN PROMPT
	  CALLX	SAVSAT		;YES -- SAVE THE SATT MOUNT LOOKED UP	
	MOV	OUTDAT,SSVOL+SSEXP ;STORE THE EXPIRATION DATE
	CALL	SETVER		;SET VERFY BIT IN GLOBAL IF APPROPRIATE
	CALL	JSTAR		;'*** '
	MESSAG	<"Initializing first SAVE volume"<200>>
	INCB	SSVOL+SSSEQ	;INC VOL SEQ #
	CALL	INIDEV		;TRY TO INIT OUTPUT SAVE VOLUME
	BCS	120$		;COULDN'T DO IT
	CALLX	RESSAT		;RESTORE THE SATT
	MOV	(PC),PROCED	;OUTPUT INITTED -- SET PROCEED FLAG

SRSEND:	RETURN

120$:	CALL	CHKABT		;PRINT APPROPRIATE ERROR MESSAGE
	BR	SRSEND		;HAS TO START ALL OVER

130$:	MOV	R0,-(SP)	;SAVE SOME REGS
	MOV	R1,-(SP)
	MOV	I.DATE,R1	;GET TODAY'S DATE
	CALL	160$		;SET UP TO SEE IF 'THIS' IS A LEAP YEAR
	BNE	140$		;NO - CHECK NEXT YEAR
	CMP	R1,#31.+29.	;HAVE WE PASSED JANUARY 31 + FEBRUARY 29?
	BLE	150$		;NO
	DEC	OUTDAT		;YES, SO BACK UP BY A DAY
	BR	150$

140$:	MOV	OUTDAT,R1	;GET EXPIRATION DATE (THIS DAY NEXT YEAR)
	CALL	160$		;IS NEXT YEAR A LEAP YEAR?
	BNE	150$		;NO, GET OUT
	CMP	R1,#31.+28.	;PASSED JAN 31 + FEB 28
	BLE	150$		;NO
	INC	OUTDAT		;YES, FORWARD A DAY
150$:	MOV	(SP)+,R1	;RESTORE R1
	MOV	(SP)+,R0	; AND R0
	RETURN

160$:	CLR	R0		;INT(DATE/1000)=YEAR-1970
	DIV	#1000.,R0	;YEAR TO R0, DAY OF YEAR TO R1
	CMPB	(R0)+,(R0)+	;ADJUST YEAR TO A LEAP YEAR BASE (1968)
				; (ADD 2)
	BIT	#3,R0		;IS THIS YEAR A LEAP YEAR?
	RETURN

.DSABL	LSB
GLOBAL	<MNTTBL,SWTWRD,OUTDAT,SSVOL,I.DATE,SPCPID>

.SBTTL	RESTORE DIALOGUE

.ENABL	LSB

DIARE::	TST	FULL		;WAS A FULL COMMAND SPECIFIED?
	BNE	10$		;YES, GO PRINT SOURCE ID
.TAG
	MOVTXT	INP,DEVIO	;PREPARE TO ASK FOR INPUT DEVICE
	MOVTXT	SSNMSG,MATID	;MAY WANT TO MATCH 'SAVE SET NAME'
	ASK	FRDEV,MATMSG,ASKDEV ;GET THE INPUT SPEC - NO DEFAULT
	BCS	SRREND		;CTRL/Z - RETURN TO SAV/RES FUNCTION:
	CALL	CHKIN		;CHECK THE INPUT SPEC
	LOOP	CS		;NO GOOD - REPEAT THIS QUESTION
10$:	STAR	SSNMSG		;'*** SAVE SET NAME'
	DEFALT	PIDMSG		;'/DEFAULT 'PACK ID IS '
	PRTIDC	MNTTBL		;PRINT THE ID
	TST	FULL		;WAS A FULL COMMAND SPECIFIED?
	BNE	20$		;YES, GO PRINT OUTPUT ID
.TAG
	MOV	#ORGDSK,R2	;GET ORIGINAL DISK TABLE ADDRESS
	MOV	#DSKDX,R0	;POINT TO WHERE WE'LL MOVE IT
	MOVB	(R2),(R0)+ 	;MOVE THE FIRST CHARACTER
	MOVB	ORGTYP+1(R2),(R0) ; AND THE SECOND
	MOVTXT	OUTP,DEVIO	;PREPARE TO ASK FOR OUTPUT DEVICE
	MOVTXT	PID,OVRID	;MAY WANT TO OVERRIDE 'PACK ID'
	ASK	TORS,OVRRID,ASKDEV ;GET THE OUTPUT SPEC - NO DEFAULT
	BACK	CS		;CTRL/Z - GO BACK TO PREVIOUS ?
	CALL	CHKOU		;CHECK THE OUTPUT SPEC
	LOOP	CS		;NO GOOD - REPEAT PROMPT
20$:	STAR	PIDMSG		;'*** Pack ID is '
	PRTIDC	#SPCPID-2	;PRINT THE NAME
	TST	FULL		;WAS A FULL COMMAND SPECIFIED?
	BNE	40$		;YES, GO ASK PROCEED ?
	SKIP

30$:	BIT	#VE!NOVE,SWTWRD	;WERE VERIFICATION SWITCHES SPECIFIED?
	LOOP	NE		;YES - KEEP BACKING UP

.TAG
	BIT	#VE!NOVE,SWTWRD	;ASK OR BYPASS THIS QUESTION
	SKIP	NE		;BYPASS - ON TO THE NEXT QUESTION
	CLR	VERFY		;VERIFY? - DEFAULT IS NO
	MOVTXT	VEEACH,VEWH	;VERIFY AFTER 'EACH OUTPUT' VOLUME
	MOVTXT	INP,VEWH2	;CHANGE 'OUTPUT' TO 'INPUT'
	CALLX	YESNO,R5	;WHAT DOES THE USER WANT
	  .WORD	VESHRT
	  .WORD	ASKVE
	   BACK			;^Z  -- BACK TO PREVIOUS ?
	   NOP			;LF  =  NO
	   SKIP			;NO  -- DON'T SET THE FLAG
	   MOV	(PC),VERFY	;YES -- SET VERIFY FLAG

.TAG
40$:	CALL	SETPRC		;SET UP TO ASK RIGHT PROCEED QUESTION
	CALL	SRPRCD,R5	;PROCEED (YES OR NO)?
	  BR	30$		;^Z  -- ASK PREVIOUS QUESTION
	  BR	SRREND		;NO  -- BACK TO MAIN PROMPT
	  CALL	DOBOOT		;YES -- GO INIT THE DEVICE

SRREND:	RETURN

.DSABL	LSB

GLOBAL	<ORGDSK,MNTTBL,CURFBN,SWTWRD,SPCPID>

.SBTTL	IMAGE DIALOGUE

.ENABL	LSB

DIAIM::	TST	FULL		;WAS A FULL COMMAND SPECIFIED?
	BNE	10$		;YES, GO PRINT SOURCE ID

.TAG
	MOVTXT	INP,DEVIO	;PREPARE TO ASK FOR INPUT DEVICE
	MOVTXT	PID,MATID	;MAY WANT TO MATCH 'PACK ID'
	ASK	FRRDK,MATMSG,ASKDEV ;GET THE INPUT SPEC - NO DEFAULT
	BCS	SRIEND		;^Z - GO BACK TO MAIN PROMPT
	CALL	CHKIN		;CHECK THE INPUT SPEC
	LOOP	CS		;NO GOOD - REPEAT THIS QUESTION
10$:	CALL	JSTAR		;'*** '
	MESSAG	<"Input Pack ID">
	DEFALT	OUTPID		;'/DEFAULT OUTPUT PACK ID IS '
	PRTIDC	MNTTBL		;PRINT THE NAME
	TST	FULL		;WAS A FULL COMMAND SPECIFIED?
	BNE	20$		;YES, GO PRINT DESTINATION ID

.TAG
	MOV	#ORGDSK,R2	;GET ORIGINAL DISK TABLE ADDRESS
	MOV	#DSKDX,R0	;POINT TO WHERE WE'LL MOVE IT
	MOVB	(R2),(R0)+ 	;MOVE THE FIRST CHARACTER
	MOVB	ORGTYP+1(R2),(R0) ; AND THE SECOND
	MOVTXT	OUTP,DEVIO	;PREPARE TO ASK FOR OUTPUT DEVICE
	MOVTXT	PID,OVRID	;MAY WANT TO OVERRIDE 'PACK ID'
	ASK	TORS,OVRRID,ASKDEV ;GET THE OUTPUT SPEC - NO DEFAULT
	BACK	CS		;CTRL/Z? - YES, GO BACK TO PREVIOUS ?
	CALL	CHKOU		;CHECK THE OUTPUT SPEC
	LOOP	CS		;NO GOOD - REPEAT PROMPT
20$:	STAR	OUTPID		;'*** Output Pack ID is '
	PRTIDC	#SPCPID-2	;PRINT THE NAME
	TST	FULL		;WAS A FULL COMMAND SPECIFIED?
	BNE	40$		;YES, GO ASK PROCEED ?
	SKIP			;NO, SEE IF WE ASK 'VERIFY'

30$:	BIT	#VE!NOVE,SWTWRD	;WERE VERIFICATION SWITCHES SPECIFIED?
	LOOP	NE		;YES - KEEP BACKING UP

.TAG
	BIT	#VE!NOVE,SWTWRD	;ASK OR BYPASS THIS QUESTION
	SKIP	NE		;BYPASS - ON TO THE PROCEED QUESTION
	CLR	VERFY		;VERIFY? - DEFAULT IS NO
	MOVTXT	VEIM,VEWH	;VERIFY AFTER 'IMAGE COPY OPERATION'
	CALLX	YESNO,R5	;WHAT DOES THE USER WANT
	  .WORD	VESHRT
	  .WORD	ASKVE
	   BACK			;^Z  -- ASK PREVIOUS QUESTION
	   NOP			;LF  =  NO
	   SKIP			;NO  -- DON'T SET THE FLAG
	   MOV	(PC),VERFY	;YES -- SET THE FLAG

.TAG
40$:	CALL	SETPRC		;SET UP TO ASK RIGHT PROCEED QUESTION
	CALL	SRPRCD,R5	;PROCEED (YES OR NO)?
	  BR	30$		;^Z  -- ASK PREVIOUS QUESTION
	  BR	SRIEND		;NO -- BACK TO MAIN PROMPT
	  CALL	DOBOOT		;YES -- GO INIT DEVICE

SRIEND:	RETURN

.DSABL	LSB
GLOBAL	<ORGDSK,SWTWRD,HIGHBF,I.DSQ,SPCPID>

.SBTTL	IDENTIFY DIALOGUE

.ENABL	LSB

DIAID::	TST	FULL		;WAS A FULL COMMAND SPECIFIED?
	BNE	SRDEND		;YES, MOUNT DID IT FOR US!
.TAG
	MOVTXT	INP,DEVIO	;PREPARE TO ASK FOR INPUT DEVICE
	CALL	ASKNLF,R5	;GET THE DEVICE SPEC - NO DEFAULT
	  .WORD	FRDEV
	  GENTXT
	   .ASCII "Include a Save Set name or Pack ID if you  want  SAVRES"<200>
	   .ASCII "to ensure it matches the one on the volume.  This drive"<200>
	   .ASCIZ "should be WRITE-LOCKED."<200>
	  UNORG
	  .WORD	ASKDEV
	BCS	SRDEND		;CTRL/Z? - YES, GO BACK TO MAIN PROMPT
	CALL	CHKIN		;CHECK THE (INPUT) SPEC
	LOOP	CS		;NO GOOD - REPEAT THIS QUESTION

SRDEND:	RETURN			;MOUNT DID IT FOR US
				;NOTE THAT PROCEED FLAG IS ZERO
.DSABL	LSB

.SBTTL	DOBOOT - GO INIT AN OUTPUT DEVICE (IMAGE/RESTORE)
;+
; DOBOOT - SETUP TO INIT AN OUTPUT DISK
;
;	CALL	DOBOOT
;
;	RETURNS: ONLY IF NOTHING FATAL HAPPENS
;-

.ENABL	LSB

DOBOOT:	CALLX	SAVSAT		;SAVE THE SATT MOUNT LOOKED UP
	MOV	MNTTBL+2,R4	;OUTPUT MOUNT TABLE
	MOV	SPCPID,MNTPID(R4) ;FILL IN ID
	MOV	SPCPID+2,MNTPID+2(R4) ;BOTH WORDS
	CALL	SETVER		;SET VERIFY BIT IN GLOBAL IF APPROPRIATE
	CALL	INIDEV		;TRY TO INIT THE OUTPUT RSTS DISK
	BCS	20$		;NO GOOD
	CALLX	RESSAT		;RESTORE THE SATT
	MOV	(PC),PROCED	;SET PROCEED FLAG
10$:	RETURN			;ALL DONE

20$:	CALL	CHKABT		;GO DIE
	BR	10$

.SBTTL	SETPRC - SET UP TO ASK RIGHT PROCEED QUESTION
;+
; SETPRC - SET UP TO CALL MTPRCD
;
;	CALL	SETPRC
;
;	RETURNS: TIS DONE
;-


SETPRC:	MOVTXT	SRPRM,PRC1	;RETURN TO 'S/R FUNCTION'
	MOV	(PC),ENTIRE	;INDICATE ENTIRE OPERATION
	RETURN

.DSABL	LSB

.SBTTL	SCAN - PARSE INPUT LINE/BASIC SWITCH SCAN

;+
;	SCAN - PARSE INPUT LINE AND SCAN FOR SOME SWITCHES
;
;	CALL	SCAN
;	R1 -> STRING TO SCAN
;
;	C=0	(COMMAND AND) ALL SWITCHES FOUND WERE OK
;	C=1	FORM, DUPLICATE, ILLEGAL COMBINATION, OR BAD ARG SWITCH
;+

.ENABL	LSB

SCAN::	REGSCR			;SAVE ALL REGISTERS
	CLR	SWTWRD		;CLEAR THE SPECIFIED SWITCHES FLAG
	CLR	FULL		;CLEAR FULL COMMAND FLAG
	CLR	ERRADR		;CLEAR ERROR ADDRESS
	MOV	R1,R5		;CLEAN UP THE STRING
	CALL	CVT$$B		; LIKE SO (DO NOT TRIM PARITY) 		;003
	TSTB	(R1)		;SWITCHES SPECIFIED AND/OR FULL COMMAND?
	BEQ	70$		;NOPE - A OK
	CALL	INSTR$,R4,<'=>	;FULL COMMAND?
	BNE	20$		;YES - SEPARATE CHECK
	BIT	#OPID,OPFLG	;IDENTIFY?
	BNE	30$		;YES - NO '=' BUT STILL FULL

; *** FUNCTION/OPTIONS ***

	CMPB	(R1),#'/	;MUST START WITH A SLASH
	BNE	110$		;THERE ISN'T ANY - NO GOOD
10$:	CALL	SWSCAN		;TRY FOR BASIC SWITCHES
	BCS	100$		;SOMETHING WENT WRONG
	MOV	R1,R5		;CLEAN UP AGAIN
	CALL	CVT$$B		;(DO NOT TRIM PARITY)			;003
	TSTB	(R1)		;ANY LEFTOVERS?
	BEQ	70$		;NOPE, NO NEED TO CHECK LEFTOVERS
	CALL	INSTR$,R4,<'/>	;ARE THERE SWITCHES IN THERE?
	BEQ	110$		;NOPE, PURE GARBAGE - 'ILLEGAL COMMAND'
	CALLX	GETUNQ,R5,MNTSWT ;IS IT A MOUNT SWITCH?
	BCS	150$		;NO - IT'S UNRECOGNIZED
	JMP	ILLSWE		;IT'S A MOUNT SWITCH, BUT HERE THAT'S 'ILLEGAL'

; ** FULL COMMAND ***

20$:	BIT	#OPID,OPFLG	;IDENTIFY WITH '='
	BNE	110$		; IS NO GOOD
30$:	CALL	SWSCAN		;FIRST, CHECK FOR BASIC SWITCHES
	BCS	100$		;SOMETHING WENT WRONG ALREADY
	MOV	R1,R5		;MUST CLEAN UP THE LINE IN CASE OF SPACES
	CALL	CVT$$B		;DO SO  (DO NOT TRIM PARITY)		;003
	BIT	#OPID,OPFLG	;IDENTIFY
	BNE	40$		;YES, JUST DO INPUT PART
	CALL	INSTR$,R4,<'=>	;FIND OUR ='S AGAIN
	CLRB	(R5)+		;CLEAR IT (OUTPUT SIDE TERMINATOR)
	TSTB	(R1)		;HAD BEST BE AN OUTPUT SPEC - IS THERE?
	BEQ	120$		;NOPE, MISSING OUTPUT SPEC
	CMPB	(R1),#'/	;HOHUM, MAKE SURE DOESN'T START A SWITCH
	BEQ	120$
40$:	TSTB	(R5)		;HAD BEST BE AN INPUT SPEC - IS THERE?
	BEQ	130$		;NOPE, MISSING INPUT SPEC
	MOV	(PC),INPUT	;INDICATE INPUT SPECIFICATION CHECK
	MOV	#WRKBUF,R2	;POINT TO SCRATCH AREA
50$:	MOVB	(R1),(R2)+	;SAVE THE OUTPUT SPEC
	TSTB	(R1)+		;INCLUDING THE NULL
	BNE	50$
	MOV	R5,R2		;MOUNT USES R2 AS STRING POINTER
	CALL	MOUNT		;CHECK IT OUT
	BCS	100$		;NO GOOD
	BIT	#OPID,OPFLG	;IDENTIFY?
	BNE	60$		;YUP - ALL DONE AND IDENTIFIED
	MOV	#WRKBUF,R1	;POINT TO SAVED OUTPUT SPEC
	CALL	CHKOU		;CHECK THE OUTPUT SPEC
	BCS	100$		;NO GOOD
60$:	MOV	(PC),FULL	;INDICATE THIS WAS A COMPLETE COMMAND
..NOER::			;**TO MAKE NOERROR THE DEFAULT
70$:	BIT	#NOER,SWTWRD	;NO PROBLEMS - WAS /NOERROR SPECIFIED?
	BNE	80$		;YES
	BIS	#ER,SWTWRD	;DEFAULT IS /ERROR
..NOST::
80$:	BIT	#NOST,SWTWRD	;LIKEWISE, WAS /NOSTATS SPECIFIED?	;JDB003
	BNE	90$		;YES
	BIS	#ST,SWTWRD	;DEFAULT IS /STATS			;JDB003
				;**NOTE: PATCH USED TO SWITCH THESE	;JDB003
90$:	CLC			;CLEAR C-BIT
100$:	RETURN			;AN ERROR OCCURRED OUTSIDE OF THIS ROUTINE
				; C-BIT ALREADY SET AND MESSAGE PRINTED
				; GET OUT

;	SWITCH PROBLEM DISCOVERED IN THIS ROUTINE - NEED TO ISSUE AN ERROR

110$:	MOV	#ILLCMD,ERRADR	;'ILLEGAL COMMAND'
	BR	160$		;GO PRINT IT

120$:	MOVTXT	OUTP,ILLCIO	;WILL PRINT 'OUTPUT'
	BR	140$		;GO PRINT IT

130$:	MOVTXT	INP,ILLCIO	;WILL PRINT 'INPUT'
140$:	MOV	#ILLCMN,ERRADR	;'MISSING INPUT OR OUTPUT SPEC'
	BR	160$

150$:	MOV	#UNRSW,ERRADR	;'UNRECOGNIZED SWITCH'
160$:	JMP	SWERR		;USE COMMON PRINT ERROR ROUTINE

.DSABL	LSB
GLOBAL	<SWTWRD,OPFLG>

.SBTTL	SCAN FOR SWITCHES
.ENABL	LSB

SWSCAN::REGSCR			;SAVE REGISTERS
	CLR	SWTWRD		;CLEAR SWITCH SPECIFIED WORD
10$:	MOV	R1,R5		;COPY STRING POINTER
	CALL	INSTR$,R4,<'/>	;ANY (MORE) SWITCHES?
	BEQ	70$		;NOPE, GET OUT
	MOV	R5,R1		;POINT TO THE SWITCH
	CALLX	GETUNQ,R5,DISWIT ;PARSE FOR THE BASIC SWITCHES
	BCC	20$		;GOT ONE
	INC	R1		;NO MATCH - MAY BE MOUNT SWITCH OR
	BR	10$		; UNRECOGNIZED - SCAN REST OF LINE - MOUNT
				; OR MAINLINE WILL HANDLE UNRECOGNIZED ONES
20$:	BIT	#OPID,OPFLG	;IS THIS AN IDENTIFY?
	BNE	ILLSWE		;YES - NO BASIC SWITCHES ARE ALLOWED!
	CMPB	(R1),#':	;DID WE END BECAUSE OF A COLON?
	BNE	30$		;NO, KEEP GOING
	TST	R0		;WE DID - ONLY ALLOWED WITH /EXP (R0=0)
	BNE	ILLSWE		;SOME OTHER SWITCH - NO GOOD
30$:	BIT	SETBIT(R0),SWTWRD ;WAS THIS SWITCH ALREADY SPECIFIED?
	BNE	80$		;YES - 'DUPLICATE SWITCHES'
	BIT	CONBIT(R0),SWTWRD ;DOES IT CONFLICT WITH ANYTHING?
	BNE	90$		;YES - 'ILLEGAL COMBINATION'
	BIS	SETBIT(R0),SWTWRD ;SET THE BIT FOR THE TIME BEING
	BIT	#VE,SWTWRD	;WAS IT /VERIFY?
	BEQ	40$		;NO
	MOV	(PC),VERFY	;YES - SET VERIFY FLAG
40$:	BIT	#EX!NOEX,SWTWRD	;DATE SWITCH SPECIFIED?
	BEQ	60$		;NO, KEEP GOING
	BIT	#OPSV,OPFLG	;IS THIS A 'SAVE'?
	BEQ	ILLSWE		;NO, 'ILLEGAL SWITCH'
	BIT	#EX,SWTWRD	;WAS IT A /EXP?
	BEQ	60$		;NO, IT'S OK (/NOEXP)
	CMPB	(R1),#':	;DO WE HAVE A COLON
	BNE	60$		;NO, WILL USE THE DEFAULT
	MOV	R1,-(SP)	;SAVE OUR POINTER
	INC	R1		;SKIP PAST THE COLON
	CALLX	CKDATE		;CHECK OUT THE DATE
	BCS	100$		;SOMETHING WAS WRONG WITH THE DATE
	BIS	#EXDAT,SWTWRD	;OK DATE - SET THE 'DATE SPECIFIED BIT'
	MOV	R1,OUTDAT	;SAVE THE SPECIFIED DATE
	MOV	(SP)+,R1	;RESTORE OUR POINTER (BEFORE THE :)
50$:	TSTB	(R1)		;ANYTHING LEFT
	BEQ	70$		;NOPE, TWAS THE LAST SWITCH
	CMPB	(R1),#'/	;NEED TO FIND THE END OF THE DATE
	BEQ	10$		;GOT IT (ANOTHER SWITCH FOLLOWED)
	CMPB	(R1),#'=	;END OF OUTPUT SIDE?
	BEQ	10$		;OK, GET OUT
	MOVB	#40,(R1)+	;BLANK IT OUT
	BR	50$		;KEEP LOOKING

60$:	TSTB	(R1)		;ANYTHING LEFT?
	BNE	10$		;YES
70$:	CLC			;'GOOD EXIT' - CLEAR C-BIT
	RETURN			; AND GET OUT

;	SOME ERROR OCCURRED

80$:	MOV	#DUPSW,ERRADR	;'DUPLICATE SWITCHES'
	BR	SWERR

ILLSWE:	MOV	#ILLSW,ERRADR	;'ILLEGAL SWITCH'
	BR	SWERR		;GO PRINT IT

90$:	MOV	#ILLCOM,ERRADR	;'ILLEGAL COMBINATION'
	BR	SWERR		;GO PRINT IT

100$:	MOV	(SP)+,R1	;HERE WE NEED TO RESTORE A POINTER
	MOV	#ILLDAT,ERRADR	;'ILLEGAL DATE'
SWERR:	CALL	PRIERR		;COMMON WARNING ERROR PRINTER
	SEC			;SET C-BIT TO INDICATE AN ERROR
	RETURN
	
.DSABL	LSB
GLOBAL	<SWTWRD,OUTDAT,OPFLG>

.SBTTL	SET VERIFY BIT
;+
; SETVER - SET VERIFY BIT IN GLOBAL IF VERIFY WAS REQUESTED
;
; CALL:	VERFY	= <>0 MEANS VERIFY, 0 MEANS DON'T
;	CALL	SETVER
;
; RETURNS:	VERIFY BIT IS SET IN GLOBAL IF VERFY WAS <>0
;-

SETVER:	TST	VERFY		;'YES' TO VERIFY PROMPT OR /VE?
	BEQ	10$		;NOPE
	BIS	#VE,SWTWRD	;SET VERIFY BIT IN GLOBAL SWITCH FLAG
10$:	RETURN			;ALL DONE



.SBTTL	'/DEFAULT' BLURB
;+
; DEFALT - PRINT '/DEFAULT' BLURB
;
;	CALL	DEFALT,R5,<PTR TO TEXT>
;
;-

DEFALT:	MESSAG	<"/default ">	;PRINT 1ST PART
	JMP	MESSAG		;LET MESSAGE DO THE REST

.DSABL	LSB
GLOBAL	<SWTWRD>

.SBTTL	SETUP AND CALL MOUNT

;+
; CHKIN - HAVE MOUNT CHECK AN INPUT SPECIFICATION
; CHKOU - HAVE THE MOUNT ROUTINE CHECK AN OUTPUT SPECIFICATION
;
;	R1 -> SPEC TO CHECK
;
;	CALL	CHK???
;
;	RETURNS WITH MOUNT'S ERROR INDICATOR:
;	
;	C = 1	ERROR
;	C = 0	SPEC CHECKS OUT
;-

.ENABL	LSB

CHKIN::	MOV	(PC),INPUT	;INDICATE 'INPUT' TO THE MOUNT ROUTINE
	BR	10$		;GO CHECK IT

CHKOU::	CLR	INPUT		;INDICATE 'OUTPUT' TO THE MOUNT ROUTINE
	BIT	#OPRE!OPIN,OPFLG	;RESTORE OR INSTALL?		;JDB001
	BEQ	10$		;NO
	MOV	CURFBN,-(SP)	;SAVE CURRENT SAVE VOLUME FBN AS IT CAN
	MOV	CURFBN+2,-(SP)	; POTENTIALLY BE DESTROYED ON OUTPUT MOUNT
10$:	MOV	R1,R2		;MOUNT WANTS THE POINTER IN R2
	CALL	MOUNT		;HAVE (DIALOGUE) MOUNT CHECK THE SPEC
	MOV	INPUT,R2	;INPUT MOUNT? (DON'T AFFECT CARRY)
	BNE	20$		;YES
	BIT	#OPRE!OPIN,OPFLG	;RESTORE OR INSTALL?		;JDB001
	BEQ	20$		;NO
	MOV	(SP)+,CURFBN+2	;RESTORE CURFBN
	MOV	(SP)+,CURFBN

20$:	RETURN			;AND GO BACK

.DSABL	LSB
GLOBAL	<CURFBN,OPFLG>

;+
; INSTR$ - LOCATE A CHARACTER IN A STRING
;
; CALL:	R5 -> ASCIZ STRING
;	CALL	INSTR$,R4,<'CHARACTER>
;
; BACK:	R5 -> CHARACTER (IF FOUND) OR TERMINATING 0 BYTE (IF NOT)
;	CONDITION CODES SET ON CHARACTER
;	(I.E. BNE FOUND)
;-
.ENABL	LSB

INSTR$:	TST	(R4)+		;ADVANCE OVER CHARACTER
10$:	TSTB	(R5)		;END OF STRING?
	BEQ	20$		;YES
	CMPB	(R5)+,-2(R4)	;IS IT THE CHARACTER?
	BNE	10$		;NO
	TSTB	-(R5)		;YES, POINT TO IT
20$:	RETURN	R4

.DSABL	LSB

.SBTTL	BLDB - INVOKE BOOT PROCURER					;JDB004

;+
; BLDB  - THERE IS A NEARLY IDENTICAL ROUTINE IN SAVE. CREATING		;JDB004
;	  THESE ALLOWED RE-CONSOLIDATION OF DSMNT1 AND DSMNT2 INTO	;JDB004
;	  DSMNT								;JDB004
;-

BLDB:	CALLRX	BLDB1	;INVOKE BLDB1 FOR DIALOG TO GET BOOTS		;JDB004
BOOLR1::RETURN		;RETURN TO DIALOG/SAVE COMMON MOUNT CODE	;JDB004

.DSABL	LSB
GLOBAL	<BLDB1>


