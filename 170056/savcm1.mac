TITLE	SAVCM1,<COMMON/GGBOOT FILE>,0A,10-MAY-91,JDB

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY
;+
;
;  002  JDB  07-OCT-82  ADDED FSRDPL FSIO ROUTINE			;JDB002
;
;				[RSTS V9.0]
;  003	DBM  09-Jan-84	Change <CR> to <LF> for VT200 support
;  004  JDB  26-APR-84  MODIFIED RETRY TO WORK FOR BAD BLOCKS(INSTALL)	;JDB004
;
;-
.SBTTL	COMMON SCRATCH DATA AREA

	I.DATA
ABTUSR:	.BLKW0			;<>0 ABORT PER USER REQUEST
				; (DIDN'T WANT TO RETRY)
INPUT:	.BLKW0			;<>0 MEANS INPUT, =0 MEANS OUTPUT
	.EVEN
	.BYTE			;MAGTAP MUST BE IN THE HIGH BYTE
MAGTAP:	.BYTE			;<>0 MEANS DEVICE MAGTAPE
	.EVEN

.SBTTL	FILE-STRUCTURED ROUTINE TABLE (DO NOT CHANGE ORDER !!!)

FSRTN:	.WORD	READMF		;READ MFD
	.WORD	READ		;READ BLOCK (R2/R3 = FBN)
	.WORD	READRF		;READ BLOCK (R2 = DCN)
	.WORD	WRITE		;WRITE BLOCK
	.WORD	RDB		;FOLLOW LINK
	.WORD	RDS		;FOLLOW LINK & WRITE CURRENT BLOCK
	.WORD	SDU		;FILE LOOKUP
	.WORD	GDB		;GET DIRECTORY ENTRY
	.WORD	READPL		;READ PACK LABEL			;JDB002
	UNORG

.SBTTL	DEFINE SOME ASCII CONSTANTS SYMBOLICALLY

	.EQUATE	LF	,12
	.EQUATE	CR	,13
	.EQUATE	FF	,14
	.EQUATE	CTRLZ	,32
	.EQUATE	ESC	,33
	.EQUATE	SPACE	,40

GLOBAL	<READMF,READ,READRF,WRITE,RDB,RDS,SDU,GDB,READPL>

.SBTTL	TEXT USE BY SEVERAL ROUTINES

	I.MESS
	.ENABL	LC

;	MISC. MESSAGES
DEFMSG:	.ASCII	"No default"
MORINF:	.ASCIZ	" - type '?' for more information"<200>
PREMSG:	.ASCIZ	"No previous questions"

;	DEVICE RELATED ERRORS
DEVHNG:	.ASCIZ	"Device hung or write-locked"<200>
MAGSLC:	.ASCIZ	"Magtape select error"<200>
BADMFD:	.ASCIZ	"Bad block in MFD"<200>
BADBLK:	.ASCIZ	"Bad block on installation kit - volume from alternate set may be used"<200>	;JDB003
	.EVEN
	UNORG

.SBTTL	WARN/STAR

;+
; WARN - PRINT A WARNING MESSAGE (BEGINNING WITH ' %%%')
; STAR - PRINT AN INFORMATIONAL MESSAGE (BEGINNING WITH '*** ')
;
;	CALL	WARN,R5,<PTR TO TEXT>
;	CALL	STAR,R5,<PTR TO TEXT>
;-

.ENABL	LSB

STAR:	CALL	JSTAR		;PRINT '*** ' PART
	BR	10$		;GO LET MESSAGE DO THE REST

WARN:	CALL	JPERC		;PRINT '%%% ' PART
10$:	JMP	MESSAG		;MESSAG DOES THE REST

JSTAR:	MESSAG	<<177><200>"*** ">	;INFORMATIONAL
	RETURN

JPERC:	MESSAG	<<177><200>"%%% ">	;WARNING
	RETURN

.DSABL	LSB

.SBTTL	ABORT ROUTINES
.SBTTL		CHKABT - SEE IF WE SHOULD ABORT
.SBTTL		CCTRLC - CTRL/C?
.SBTTL		PRTERF - SAVRES BUG - DIE

;+
; CCTRLC - ABORT IF USER TYPED CTRL/C
;
;	CALL	CCTRLC
;
;	RETURNS ONLY IF USER HASN'T TYPED CTRL/C
;-

.ENABL	LSB

CCTRLC:	CMPB	@RINGS,#'C-100	;CTRL/C?
	BNE	20$		;NOPE
	EXIT

;+
; CHKABT - SEE IF WE SHOULD ABORT
;
;	CALL:	ABTADR = <>0 MEANS A FATAL ERROR HAS OCCURRED
;			(E.G. VOLUME IS FULL) AND WE SHOULD ABORT
;		ABTUSR = <>0 MEANS USER WANTS TO ABORT
;		CALL	CHKABT
;
;	IF CHKABT RETURNS TO CALLING ROUTINE, THEN NEITHER OF THE ABOVE
;		WAS NON-ZERO
;
;	IF FATAL OR ABTUSR WAS NON-ZERO - MESSAGE HAS BEEN PRINTED AND
;		WE DIE
;-

CHKABT:	TST	ABTADR		;ANY FATAL ERROR ?
	BEQ	10$		;NOPE
	MESSAG	<<177><200>"??? Warning:"<200>"??? Operation aborted: ">
	CALLX	MESSAG,R5
ABTADR:	.WORD	0		;MESSAGE TO PRINT
	BR	DIE

10$:	TST	ABTUSR		;DOES USER WANT TO ABORT ?
	BEQ	20$		;NOPE
	MESSAG	<<177><200>"??? Operation aborted at user request">
DIE:	CLRB	HIGHBF		;FOR THE RESTART
	CALLRX	SRDONE		;SO ABORT ALREADY

PRTERF:	MESSAG	<<177><200>"??? Fatal SAV/RES bug: ">
20$:	RETURN			;GET OUT

.DSABL	LSB
GLOBAL	<RINGS,HIGHBF>

.SBTTL	RETRY - HANDLE RETRIES

;+
; RETRY - SEE IF USER WANTS TO PROCEED AFTER A DEVICE ERROR
;	   IF ERROR PASSED IS NOT HNGDEV OR MAGSEL THEN AN UNEXPECTED
;	   ERROR MESSAGE IS PRINTED AND THE OPERATION IS ABORTED
;
;	IOERR = ERROR CODE
;
;	CALL	RETRY
;
;	RETURNS ONLY IF THE USER WANTS TO RETRY
;-

.ENABL	LSB
.ENABL	LC

RETRY:	MOV	R0,-(SP)	;SAVE R0
	MOV	R2,-(SP)	; AND R2
	CALL	STRWAI		;START WAITING
	MOV	#DEVHNG,20$	;POINT TO DEVICE HUNG ERROR MESSAGE
	CMPB	IOERR,#HNGDEV	;'DEVICE HUNG' ERROR?
	BEQ	10$		;YES
	MOV	#BADBLK,20$	;POINT TO BAD BLOCK ERROR MESSAGE	;JDB004
	CMPB	IOERR,#DATERR	;'BAD BLOCK' ERROR? (ONLY FOR INSTALL)	;JDB004
	BEQ	10$		;YES - SO GO PRINT MESSAGE		;JDB004
	CMPB	IOERR,#MAGSEL	;'MAGTAPE SELECT' ERROR?
	BNE	90$		;NO - SOMETHING ELSE???
	MOV	#MAGSLC,20$	;YES
10$:	CALL	JPERC		;'%%% '
	MOV	SYSNDX,R2	;GET FAILING DEV INDEX
	MOV	DSKNAM(R2),R2	;GET DEVICE MNEMONIC
	CALLX	TYPE2		;PRINT IT
	DECZER	SYSUNT		;PRINT THE UNIT NUMBER
	MESSAG	<": - ">
	CALLX	MESSAG,R5	;PRINT REAL ERROR TEXT NEXT
20$:	.WORD	0		;ERROR TO PRINT
30$:	CALLX	YESNO,R5,40$	;SEE WHAT THE USER WANTS TO DO
	  GENTXT
	   .ASCII "Correct the condition (if possible) and type 'Yes'"<200>
	   .ASCII "to continue. Type 'No' to abort the operation."<200>
40$:	   .ASCIZ "Retry (Yes or No)? "
	  UNORG
	 BR	60$		;CTRL/Z BUT NO PREVIOUS ?'S
	 BR	70$		;LF	BUT NO DEFAULT
	 BR	80$		;NO
	 			;YES

50$:	CALL	STRPRC		;RESTART PROCESSING
	MOV	(SP)+,R2	;RESTORE R2
	MOV	(SP)+,R0	;RESTORE R0
	CLRB	IOERR		;GET RID OF OLD ERROR
	RETURN			;GET OUT

60$:	WARN	PREMSG		;NO PREVIOUS ?'S
	CALLX	MESSAG,R5,MORINF;' - TYPE '?' FOR MORE INFORMATION'
	BR	30$

70$:	WARN	DEFMSG		;NO DEFAULT
	BR	30$

80$:	MOV	(PC),ABTUSR	;INDICATE USER ABORT
	CALL	CHKABT		;PRINT THE MESSAGE AND RETURN TO PROMPT

90$:	CALL	PRTERF		;FATAL SAV/RES BUG:
	MESSAG	<"Err ">
	DECZER	IOERR		;DECIMAL RSTS ERROR NUMBER
	MESSAG	<" in ">
	CALL	PRTRTN		;PRINT THE ROUTINE NAME
	CALLX	TYPECR		;<CR>
	JMP	DIE		;DIE ALA CHKABT

GLOBAL	<IOERR,SYSNDX,SYSUNT,DSKNAM>
.DSABL	LSB

.SBTTL	FILE-STRUCTURED CALLS
;+
; FSIO1 - PRE FS I/O CALL
; FSIO2	- AFTER FS I/O CALL
;
;	APPROPRIATE ROUTINE IS CALLX'D VIA THE FSRTN TABLE:
; FSRTN:	READMF		;READ MFD
;		READ		;READ BLOCK (R2/R3 = FBN)
;		READRF		;READ BLOCK (R2 = DCN)
;		WRITE		;WRITE BLOCK
;		RDB		;FOLLOW LINK
;		RDS		;FOLLOW LINK & WRITE CURRENT BLOCK
;		SDU		;FILE LOOKUP
;		GDB		;GET DIRECTORY ENTRY
;		READPL		;READ PACK LABEL			;JDB002
;	SETS UP FOR THE CALL ALA
;	CALLX	RTN (FILE-STRUCTURED I/O ROUTINE)
;	DOES CALLX FOLLOW-UP
;
;-

.ENABL	LSB

FSRDMF:	MOV	R1,-(SP)	;SAVE R1
	CLR	R1		;+ 0 OFFSET FOR READMF
	BR	40$

FSREAD:	MOV	R1,-(SP)	;SAVE R1
	MOV	#2,R1		;+ 2 OFFSET FOR READ
	BR	40$

FSRDRF:	MOV	R1,-(SP)	;SAVE R1
	MOV	#4,R1		;+ 4 OFFSET FOR READRF
	BR	40$

FSWRIT:	MOV	R1,-(SP)	;SAVE R1
	MOV	#6,R1		;+ 6 OFFSET FOR WRITE
	BR	40$
									;JDB002
FSRDPL:	MOV	R1,-(SP)	;SAVE R1				;JDB002
	MOV	#20,R1		;+ 20 OFFSET FOR READPL			;JDB002
	BR	40$							;JDB002

FSRDB:	MOV	R1,-(SP)	;SAVE R1
	MOV	#10,R1		;+10 OFFSET FOR RDB
	BR	10$

FSRDS:	MOV	R1,-(SP)	;SAVE R1
	MOV	#12,R1		;+12 OFFSET FOR RDS
	BR	10$

FSSDU:	MOV	R1,-(SP)	;SAVE R1
	MOV	#14,R1		;+14 OFFSET FOR SDU
	BR	10$

FSGDB:	MOV	R1,-(SP)	;SAVE R1
	MOV	#16,R1		;+16 OFFSET FOR GDB
				;DROP THROUGH

10$:	CALL	FSIO1
	CALL	@FSRTN(R1)	;CALL ROUTINE
	BCC	30$		;ALL IS WELL
	CMPB	#HNGDEV,IOERR	;HUNG DEVICE ?
	BNE	20$		;NO
	CALL	RETFRE		;YES - RETRY/RESET
	BR	10$		;TRY AGAIN

20$:	SEC
30$:	MOVB	#0,NOERR
	MOV	(SP)+,R1	;RESTORE R1
	RETURN

40$:	CALL	FSIO1
	CALL	@FSRTN(R1)	;CALL ROUTINE
	CMPB	#HNGDEV,IOERR	;HUNG DEVICE ?
	BNE	50$		;NO
	CALL	RETFRE		;YES - RETRY/RESET
	BR	40$		;TRY AGAIN

50$:	TST	R1		;READMF?
	BGT	60$		;NOPE
	CMPB	#DATERR,IOERR	;BAD MFD?
	BNE	60$
	MOV	#BADMFD,ABTADR	;WILL SAY SO
60$:	MOV	(SP)+,R1	;RESTORE R1
FSIO2:	CLRB	NOERR		;TELL FIP TO STOP ON ERRORS
	TSTB	IOERR		;WAS THERE AN ERROR?
	RETURN

FSIO1:	CLRB	NRSTSD		;INICATE THIS IS A RSTS DISK
	MOVB	#-1,NOERR	;TELL FIP TO SUPPRESS ERRORS
	RETURN

GLOBAL	<NRSTSD,NOERR,IOERR>
.DSABL	LSB

.SBTTL	FRESET - FS DISK RESET CALLER
;+
; FRESET - FILE-STRUCTURED DISK RESET CALLER
;
;	CALL:	SYSNDX = DISK INDEX
;		SYSUNT = DISK UNIT #
;		CALL	?RESET
;
;	RETURN:	IT HAS BEEN DONE
;
; NOTE THAT RETFRE ISSUES A CALL TO RETRY BEFORE ENTERING FRESET; THIS
;	ENTRY IS FREQUENTLY USED WHEN A FILE-STRUCTURED 'ERROR' HAS 
;	OCCURRED.
;-

.ENABL	LSB

RETFRE:	CALL	RETRY		;SEE IF USER WANTS TO RETRY
FRESET:	MOV	R0,-(SP)	;SAVE R0
	MOV	R1,-(SP)	; AND R1
	MOV	SYSNDX,R0	;GET THE INDEX
	MOV	SYSUNT,R1	;GET THE UNIT
10$:	CLRB	IOERR		;GET RID OF OLD ERROR
	CALL	FSIO1		;PRE I/O SETUP
	CALLX	SETFNS		;TRY TO RESET THE DISK
	CALL	FSIO2		;POST CALL - CHECK FOR ERROR
	BEQ	20$		;IOERR=0 MEANS TIS DONE
	CALL	RETRY		;PERHAPS TIS HUNG
	BR	10$		;USER WANTS TO TRY AGAIN

20$:	MOV	(SP)+,R1	;RESTORE R1
	MOV	(SP)+,R0	; AND R0
	RETURN

.DSABL	LSB
GLOBAL	<SYSNDX,SYSUNT,IOERR>


.SBTTL	SET DATE AND TIME

;+
; SETDAT - SET THE CURRENT DATE, TIME, AND SECONDS TO NEXT MINUTE
;
;	CALL	SETDAT
;
;	RETURNS:
;		I.DATE	CURRENT DATE
;		I.TIME	CURRENT TIME
;		I.SEC	SECONDS TO NEXT MINUTE
;
;	ONLINE, DATINI IS CALLED TO UPDATE THESE VALUES
;	OFFLINE, THEY ARE KEPT UPDATED AUTOMATICALLY
;-

.ENABL	LSB

SETDAT:	BIT	#ONLIN,MNTFLG	;ARE WE ONLINE?
	BEQ	10$		;NOPE
	CALLX	DATINI		;GET THE CURRENT DATE,TIME,AND SECS
10$:	RETURN


.SBTTL	PRTRTN - PRINT ROUTINE NAME
;+
; PRTRTN - PRINT ROUTINE NAME
;
;	RTNNAM -> ADDRESS OF CURRENT ROUTINE
;
;	CALL	PRTRTN
;
;-

PRTRTN:	MOV	RTNNAM,R0	;GET THE CURRENT ROUTINE NAME
	CALLX	ASCIZ0		;AND PRINT IT
	RETURN			;THATS ALL

.DSABL	LSB
GLOBAL	<RTNNAM,MNTFLG>

.SBTTL	STR??? - START ACCUMULATING WAIT/PROCESS TIME

;+
; STRWAI - ACCUMULATE PROCESS TIME & START WAITING
;
;	WAITNG - SET IF ALREADY WAITING (IN MOUNT)
;	CALL	STRWAI
;
;-

.ENABL	LSB

STRWAI:	BIT	#WAITNG,MNTFLG	;ALREADY WAITING?
	BNE	10$		;YES - GET OUT
	CALL	ELTIMC,R5,<PRCDAT,PRCHRS> ;ACCUMULATE PROCESS TIME
	CALL	SETDAT		;ALL POST DIALOGUE MOUNTING IS WAIT TIME
	MOV	I.DATE,WAIDAT	;SAVE WHEN WE STARTED TO WAIT
	MOV	I.TIME,WAITIM	; SAVE THE TIME
	MOVB	I.SEC,WAISEC	; AND THE TIME TILL NEXT MINUTE
10$:	RETURN

STRPRC:	BIT	#WAITNG,MNTFLG	;ALREADY WAITING?
	BNE	10$		;YES - GET OUT
	CALL	ELTIMC,R5,<WAIDAT,WAIHRS> ;ACCUMULATE TIME SPENT IN MOUNT
				;EXECUTE PRCSAV

.SBTTL	PRCSAV - SAVE PROCESS START

;+
; PRCSAV - SAVE WHEN WE STARTED TO PROCESS
;
;	CALL	PRCSAV
;
;	NOTHING SPECIAL RETURNED
;-

PRCSAV:	CALL	SETDAT		;GET THE CURRENT DATE AND TIME
	MOV	I.DATE,PRCDAT	;SAVE THE DATE
	MOV	I.TIME,PRCTIM	; AND TIME
	MOVB	I.SEC,PRCSEC	; AND TIME TILL NEXT MINUTE
	RETURN			;ALL DONE

.DSABL	LSB
GLOBAL	<I.DATE,I.TIME,I.SEC,WAIDAT,WAITIM,WAISEC,WAIHRS,PRCDAT,PRCHRS>
GLOBAL	<PRCTIM,PRCSEC,MNTFLG>

.SBTTL	ELTIMC - CALCULATE ELAPSED TIME

;+
; ELTIMC: CALCULATE ELAPSED TIME
;
;	CALL:
;		CALL	ELTIMC,R5,<START,ELAPSED>
;
;	WHERE "START" AND "ELAPSED" ARE DATA BLOCKS DEFINED
;	AS FOLLOWS:
;
;	START:	.WORD	0 (START DATE)
;		.WORD	0 (START TIME)
;		.BYTE	0 (START SECONDS) (FROM I.SEC)
;
;	ELAPSED:.WORD	0 (ELAPSED HOURS)
;		.BYTE	0 (ELAPSED MINUTES)
;		.BYTE	0 (ELAPSED SECONDS)
;
;
;	RETURN:	ALL DATA RETURNED IN "ELAPSED"
;
;	NOTE THAT "ELAPSED" DATA IS CUMULATIVE, AND SHOULD INITIALLY BE
;	SET TO ZEROES.
;-
.ENABL	LSB

ELTIMC:	REGSAV			;SAVE THE REGISTERS
	CALL	SETDAT		;ENSURE CORRECT ON-LINE TIME
	MOV	(R5)+,R4	;SET R4 => "START" DATA
	MOV	(R5),R5		;SET R5 => "ELAPSED" DATA
	MOV	2(R4),R2	;R2 = STARTING "MINUTES TO NEXT MIDNIGHT"
	MOVB	4(R4),R3	;R3 = STARTING "SECONDS TO NEXT MINUTE"
	MOV	I.DATE,R1	;R1 = CURRENT DATE
	SUB	(R4),R1		;R1 = CURRENT DATE - BASE DATE
	BEQ	20$		;SAME DAY, SO NO SWEAT

	CMP	R1,#366.	;HAS THE YEAR CHANGED?
	BLE	10$		; NO, THANK GOODNESS
	MOV	#1,R1		;ASSUME BUT ONE DAY HAS PASSED (SLOPPY)

10$:	DEC	R1		;R1 = FULL DAYS THAT HAVE PASSED
	MUL	#24.,R1		;CONVERT R1 TO HOURS
	ADD	R1,(R5)		;ADD THAT TO ELAPSED HOURS
	MOVB	3(R5),R1	;GET ELAPSED SECONDS
	ADD	R3,R1		;ADD YESTERDAY'S SECONDS TO IT
	CLR	R0		;CLEAR R0 FOR DIVIDE
	DIV	#60.,R0		;CONVERT TO MINUTES AND SECONDS
	MOVB	R1,3(R5)	;PUT BACK THE SECONDS
	MOVB	2(R5),R1	;NOW GET ELAPSED MINUTES
	ADD	R0,R1		; TO WHICH ADD LEFT-OVER MINUTES
	ADD	R2,R1		; AND YESTERDAY'S MINUTES
	CLR	R0		;TIME TO SPLIT TIME
	DIV	#60.,R0		; INTO HOURS AND MINUTES
	MOVB	R1,2(R5)	;REPLACE ELAPSED MINUTES
	ADD	R0,(R5)		;ADD LEFTOVER HOURS TO ELAPSED HOURS
	MOV	#1440.,R2	;OLD MINUTES IS NOW "ZERO"
	MOV	#60.,R3		; AS IS OLD SECONDS

20$:	MOVB	I.SEC,R0	;GET CURRENT SECONDS TO NEXT MINUTE
	CMP	R0,R3		;WHO IS CLOSER TO THE MINUTE?
	BLE	30$		;"CURRENT" SECONDS
	ADD	#60.,R3		;MAKE "CURRENT" SECONDS FARTHER THAN "BASE"
	DEC	R2		; BY STEALING A MINUTE FROM "BASE" MINUTES

30$:	SUB	R0,R3		;CALCULATE "ELAPSED" SECONDS
	MOVB	3(R5),R1	;GET OLD ELAPSED SECONDS
	ADD	R3,R1		; AND ADD IT TO THE NEW ONES
	CLR	R0		;CLEAR FOR DIVIDE
	DIV	#60.,R0		;CONVERT TO MINUTES
	MOVB	R1,3(R5)	;AND REPLACE "ELAPSED" SECONDS
	SUB	I.TIME,R2	;NOW CALCULATE "ELAPSED" MINUTES
	ADD	R0,R2		;ADD MINUTES REMAINING FROM SECONDS
	MOVB	2(R5),R1	;GET OLD ELAPSED MINUTES
	ADD	R2,R1		; AND THROW THAT IN FOR GOOD MEASURE
	CLR	R0		;CLEAR FOR DIVIDE
	DIV	#60.,R0		;CONVERT TO HOURS AND MINUTES
	MOVB	R1,2(R5)	;SET ELAPSED MINUTES
	ADD	R0,(R5)		;ADD HOURS TO ELAPSED HOURS

	CALLX	REGRES,R5	;RESTORE THE REGISTERS
	CMP	(R5)+,(R5)+	;SKIP OVER IN-LINE ARGUMENTS
	CALLX	GETTTY		;KEEP CLOCK GOING
	RETURN	R5

.DSABL	LSB
GLOBAL	<I.TIME,I.DATE,I.SEC>

