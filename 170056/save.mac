TITLE	SAVE,<SAV/RES SAVE>,0A,10-MAY-91,JDB

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY
;+
;
;  001  AWR  14-APR-81	V7.0 PATCH 1.1.16 INSTALLED
;  002  AWR  14-APR-81	V7.0 PATCH 1.1.11 INSTALLED
;  003  JDB  29-JUN-81	FIX IMPROPER BACKSPACE ON MAGTAPE BADBLOCK
;  004  JDB  14-AUG-81	FIX CORRUPT DIR BLOKS AT END OF SAVESET VOL
;  005  JDB  07-OCT-82	MODIFIED TO WORK WITH NEW DIRECTORY STRUCTURE
;  006  MNB  08-FEB-83  FIX WRITE TO THE INPUT DISK LAST TIME AROUND
;  007  MNB  09-MAY-83  V8.0 PATCH 1.1.6 INSTALLED (SEE GNXFER:)
;  008  JDB  25-APR-84  SOURCE CLEAR 1.1.17 AND FIX BADDIR ERROR	;JDB008
;			DURING DIRECTORY XFER WHICH SPLITS VOLUME	;JDB008
;  009  JDB  19-JUN-85  REMOVED EXTRANEOUS LINE OF CODE IN XFRXFD	;JDB009
;  010  JDB  27-Feb-87  SAVE specific bootbuilder to consolidate DSMNT	;JDB010
;
;-

.SBTTL	TRANSFER MACROS

.MACRO	I.MESS
	TMPORG	SAVTXT
.NLIST	BEX
.ENDM	I.MESS

.MACRO	I.DATA
	TMPORG	SAVCTL
.NLIST	BEX
.ENDM	I.DATA

.MACRO	I.ADDR
	TMPORG	SAVADR
.NLIST	BEX
.ENDM	I.ADDR


.SBTTL	MACROS

.MACRO	ERF	M
	 CALL	PRTERF
.IF NB	<M>
MESSAG	<M>
.IFF
.ERROR	;NO MESSAGE FOR ERF?
.ENDC
	EXIT
.ENDM

.MACRO	WARN	M
.NLIST
	 CALL	WARN,R5
.IF	NB	M
	  .WORD	M
.ENDC
.LIST
.ENDM	WARN

.MACRO	PRTID	C
.NLIST
.IF	NB	<C>
	MOV	C,R2		;SET UP FOR PRTNAM
.ENDC
	 CALL	PRTNAM		;PRINT THE ID
.LIST
.ENDM	PRTID

.MACRO	PRTIDC	C
.NLIST
	PRTID	C
	CALLX	TYPECR		; AND A <CR>
.LIST
.ENDM	PRTIDC

.MACRO	DECZER	C
.NLIST
.IF NB <C>
	MOVB	C,R0
.ENDC
	CALLX	DECZER
.LIST
.ENDM	DECZER

.MACRO	TYPDEV	C
.NLIST
.IF	NB	<C>
	MOV	C,R4		;SET UP FOR TYPING
.ENDC
	CALL	TYPDEV		;AND PRINT DEVICE/UNIT/COLON
.LIST
.ENDM	TYPDEV

.MACRO	PRDAYT	C
.NLIST
.IF NB <C>
	MOV	C,R0
.ENDC
	CALL	PRDAYT		;PRINT 'DAY-OF-WEEK, DD-MMM-YY'
.LIST
.ENDM	PRDAYT

.SBTTL	ORDER THE CSECTS
	DEFORG	SAV		;CODE
	DEFORG	SAVCTL		;DATA
	DEFORG	SAVTXT		;SAVE TEXT
	DEFORG	SAVADR		;TABLE ADDRESSES
	ORG	SAV		;SAVE CSECT


.SBTTL	SAVE TEXT

	I.MESS
	.ENABL	LC

;	OUR NAME
SAVMSG:	.ASCIZ	"SAVE"
	.EVEN
	UNORG

.SBTTL	SAVE DATA

	I.DATA
ENDDAT:	.BLKW0		;LAST RSTS DISK PCN DATA RETRIEVED FROM + 1
DIRCON:	.BLKW0	5	;DIRECTORY BLOCK TRANSFER CONTEXT
			; DIRCON CONTAINS THE POINTER VALUES PRIOR
			; TO A DBT BUFFER FILL:
			;	DIRCON+0  = FIBPHS
			;	DIRCON+2  = FIBPHS+2
			;	DIRCON+4  = R5 (RP POINTER)
			;	DIRCON+6  = R2 (#PC'S/DC)
			;	DIRCON+10 = R3 (# OF PC WITHIN DC)
	UNORG

.SBTTL	SAVE

.ENABL	LSB

SAVE::	MOV	#SAVMSG,RTNNAM	;SET UP 'SAVE' AS ROUTINE NAME
	CALL	PRBEGC		;PRINT BEGIN MESSAGE AND CLEAR TOTALS, ETC.
	CALL	PUTSAT,R1	;PUT COPIES OF SATT TO SAVE VOLUME
	  BR	60$		;BAD BLOCK
	  BR	70$		;UNRECOVERABLE I/O ERROR
	CALL	SETCH1		;WILL GET FROM SOURCE
	CALL	PCSCON		;SET UP PCS CONSTANTS
	MOVB	#DATBLK,RECTYP	;DATA RECORD CODE (5)
	CALL	GETDCN		;GET DCN OF BEGINNING OF DATA
	MOV	R2,SSVOL+SSDAT	;MOVE IT INTO SS TABLE
	CLR	PCNUM		;ZERO PACK CLUSTER NUMBER COUNTER
	MOV	SATSYS+BITS,R2	;R2 = # CLUSTERS IN SOURCE SATT
	CLR	R3		;R3 = SATT BYTE POINTER
	MOV	#1,R5		;R5 = BIT IN SATT BYTE WE'RE CHECKING
	CALL	PTRGET		;SAVE PTRS FOR VERIFY
10$:	CALL	XFRFIL		;FILL THE PCN TABLE WITH ALLOCATED PCN'S
	MOV	PCNRD,R0	;ANYTHING IN THE TABLE?
	BEQ	30$		;NO, ALL DONE
	MOV	#XFRPCN,R4	;POINT TO BEGINNING OF TABLE
	CLR	PCNRD		;GETRST RESETS THIS
20$:	MOV	PCNUM,-(SP)	;SAVE OUR PCNUM (CHANGED BY CNTCTG)
	CALL	CNTCTG		;HOW MANY STARTING FROM HERE ARE CONTIG?
	CALL	GETRST		;GET 'XFRCNT' CHUNKS OF CONTIG PC'S
	MOV	(SP)+,PCNUM	;RESTORE PCNUM
	BCS	40$		;UNKNOWN BAD BLOCK AND /NOERROR SPECIFIED?
	TST	R0		;ANY PCN'S LEFT IN TABLE ?
	BNE	20$		;YES - GO GET 'EM
	CALL	PUTSAV		;NO - DUMP BUFFER
	BCS	50$
	CALL	SETCH1		;BACK TO THE RSTS DISK
	BR	10$		;GO CHECK THE REST OF THE SATT

30$:	MOV	PCNUM,ENDDAT	;DATA STOPS HERE
	CALL	SELEC2		;BACK TO OUTPUT
	CALL	WRT1EF		;WRITE 1 EOF IF MAGTAPE
	BCS	60$		;ERROR
	BIT	#VE,SWTWRD	;VERIFY REQUESTED ?
	BEQ	40$		;NO
	CALL	VERSAV		;DO SAVE PROCESS VERIFY
	BCS	50$		;NO GOOD
	TSTB	SSVOL+SSHIDX	;SAVE VOLUME MAGTAPE ?
	BEQ	40$		;NO
	MOV	#1,R5		;WILL ADVANCE PAST ONE EOF
	CALL	ADVEOF		;DO IT
	BCS	60$		;ERROR ON ADVANCE
40$:	CALL	PUTDIR		;PUT OUT DIRECTORY CLUSTERS
	BCS	50$
	CALL	ACCUM		;ADD LAST VOLUME'S BLOCKS INTO TOTAL
	TSTB	SSVOL+SSHIDX	;SAVE VOLUME MAGTAPE ?
	BNE	50$		;YES - WE'RE DONE
	CLR	PCNRD		;THERE ARE NO PC'S IN THE BUFFER
	CALL	SENDDK		;FINISH OFF THE DISK
50$:	CALL	SCNDIR		;CHECK FOR UNEXPECTED INPUT BAD BLOCKS
				; AND BAD COMPARES
	CALL	ENDOP		;PRINT ENDING MESSAGE (AND STATS)
	CALLRX	SRDONE		;BACK TO ONLSAV OR INIT

;	ABORT PER USER REQUEST OR BAD MAGTAPE

60$:	MOV	#BADMAG,ABTADR	;AN ERROR - EOF ERROR????
70$:	CALL	CHKABT		;FATAL ERROR OR ABORT PER USER?

.DSABL	LSB
GLOBAL	<SATSYS,RTNNAM,SSVOL,SWTWRD,PCNUM>

.SBTTL	PUTSAT - PUT TWO COPIES OF THE SATT TO THE SAVE VOLUME

;+
; PUTSAT - PUT TWO COPIES OF THE SATT TO THE SAVE VOLUME
;
;	CALL:	NO SETUP NECESSARY
;		CALL PUTSAT,R1
;
;	RETURN:	+ 0 - BAD BLOCK ON MAGTAPE
;		+ 2 - UNRECOVERABLE I/O ERROR
;		+ 4 - SUCCESS
;-

.ENABL	LSB

PUTSAT::MOV	#2,R4		;WILL WRITE 2 SATT'S
	MOV	#SSVOL+SSSAT1,R3	;WHERE SATT POINTERS GO
	CALL	SELEC2		;SETUP FOR I/O TO SAVE VOLUME
	MOVB	SSVOL+SSHIDX,MAGTAP	;SET UP MAGTAPE INDICATOR
	BEQ	10$		;WE'VE GOT A DISK
	CALL	REWIND		;REWIND TAPE
	MOV	#3,R5		;SET UP FOR ADVANCE
	CALL	ADVEOF		;ADVANCE PAST 3 EOF'S
	BCS	40$		;ERROR ON ADVANCE
10$:	MOV	#4096.,R2	;LENGTH IN WORDS OF SATT
	CALL	SAT2IO		;MOVE IT TO THE I/O BUFFER (IN HIGH MEMORY)
	MOV	R2,I.DSQ+DSQCNT	;SATT IS 4096. WORDS LONG
	MOVB	#SATTS,RECTYP	;SATT RECORD CODE
	MOV	#BUFBEG,BUFPTR	;POINT TO IT
	CALL	GETDCN		;GET THE DCN WHERE THE SATT IS GOING
	MOV	R2,(R3)+	;MOVE IN DCN OF SATT
	CALL	SAVIO,R5,WFUN	;WRITE IT OUT
	  BR	30$		;UNRECOVERABLE I/O ERROR
	  BR	50$		;BAD BLOCK ERROR
	  BR	40$		;EOF
	  CALL	WRT1EF		;WRITE 1 EOF IF MAGTAPEDO IT
	BCS	40$
20$:	SOB	R4,10$		;DO FOR 2 COPIES
	TST	(R1)+		;SUCCESS EXIT
30$:	TST	(R1)+		;UNRECOVERABLE I/O ERROR EXIT
40$:	RETURN	R1		;BAD BLOCK ON MAGTAPE EXIT

50$:	CALL	BBOUSV		;TRY TO RECOVER FOR BAD SAVE VOL. CLUSTER
	BCS	40$		;CAN'T CONTINUE
	TST	-(R3)		;RESET POINTER TO SATT POINTERS
	BR	10$		;GO RETRY

GLOBAL	<I.DSQ,SSVOL>
.DSABL	LSB

;
;	CALL:	CALL	PUTDIR
;
;	RETURN: C-BIT INDICATES SUCCESS OR FAILURE
;		REGISTERS NOT PRESERVED
;-

.ENABL	LSB

PUTDIR::CALL	SETCH1		;SET UP TO GET DIRECTORY CLUSTERS
	CLRB	HIGHBF		;SET UP FOR I/O TO FIBUF (IN LOW MEMORY)
	MOVB	#DIRBLK,RECTYP	;DIRECTORY BLOCKS (6)
	MOV	(PC),R2		;ENSURE R2 IS NON-ZERO
	CALL	GETDCN		;GET 1ST DCN WHERE DIRECTORY WILL BE PUT
	MOV	R2,SSVOL+SSDIR	;PUT IT IN THE SSVOL TABLE
	CALL	FSRDMF		;GET FIRST MFD CLUSTER
	BNE	130$		;BAD MFD
	CLR	DIRCON+4	;INDICATE THAT WE'RE AT THE BEGINNING
	BIT	#20000,PKSTAT	;IS THIS A NEW DISK?
	BEQ	10$		;BRANCH IF NOT - DO IT THE OLD WAY
	CALL	PTDRNW		;ELSE DO IT THE NEW WAY
	BCS	110$		;BE GONE IF ANY ERROR
	BR	20$		;ELSE CONTINUE AS BEFORE
10$:	CALL	PTDROL		;USE THE OLD METHOD (SORTA)
	BCS	110$		;BE GONE IF ANY ERROR
20$:	MOV	ENDDAT,XFRPCN	;GET PCN WHERE DATA STOPS
	MOVB	#1,HIGHBF	;WILL BE DOING I/O FROM BUFBEG
	CALL	PUTSAV		;PUT TO SAVE VOLUME
	BCS	110$		;COULDN'T
	TSTB	SSVOL+SSHIDX	;SAVE VOLUME MAGTAPE ?
	BEQ	110$		;NO
	MOV	#3,R5		;WILL WRITE 3 EOF'S
100$:	CALL	WRTEOF		;DO IT
	BCS	140$		;VERY BAD
110$:	RETURN			;THAT'S ALL FOLKS

130$:	CALL	CHKABT
140$:	CMPB	#NOROOM,IOERR	;'NO ROOM FOR USER'?
	BEQ	100$		;YES - WRITE REST OF EOF'S
	ERF	<"PUTDIR tape err">

.DSABL	LSB
GLOBAL	<PKSTAT>

.SBTTL	PTDROL - XFER OLD DIRECTORY CLUSTERS TO SAVE VOLUME	;JDB005
;+
; PTDROL - TRANSFER OLD RSTS DISK DIRECTORY CLUSTERS TO SAVE VOLUME
;
;	CALL:	CALL	PTDROL
;
;	INPUTS: FIRST BLOCK OF FIRST MFD CLUSTER IN FIBUF
;
;	RETURN: C-BIT INDICATES SUCCESS OR FAILURE
;		REGISTERS NOT PRESERVED
;-

.ENABL	LSB

PTDROL::MOV	FIBUF,R1	;SAVE LINK TO NEXT MFD NAME ENTRY
	CALL	STOMAP		;SAVE THE MFD CLUSTER MAP
10$:	CALL	XFRXFD		;TRANSFER XFD TO DIRECTORY BLOCK SET
	BCS	30$		;BRANCH IF XFD TRANSFER FAILED
	CALL	RESMAP		;RESTORE MFD CLUSTER MAP TO FIBUF
20$:	MOV	R1,R3		;RETRIEVE LINK TO NEXT MFD N.E.
	BEQ	30$		;BRANCH IF LINK WAS EMPTY - ALL DONE
	CALL	FSRDB		;GET NEXT MFD NAME ENTRY
	BCS	120$		;BRANCH IF BAD MFD
	MOV	(R5),R1		;SAVE LINK TO NEXT MFD N.E.
	BITB	#US.UFD,USTAT(R5)	;IS IT AN ACCOUNT
	BEQ	20$		;BRANCH IF NOT - ONLY A [1,1] FILE
	MOV	UAR(R5),R2	;ELSE GET STARTING DCN OF THE UFD
	BEQ	20$		;BRANCH IF THERE IS NONE - UFD IS EMPTY
	CALL	FSRDRF		;ELSE GET THE FIRST BLOCK OF THE UFD
	BCS	120$		;BRANCH IF BAD DIRECTORY
	BR	10$		;ELSE GO TRANSFER IT TO THE SAVESET
30$:	RETURN			;THAT'S ALL FOLKS!

120$:	CALL	BADLNK		;BAD DIRECTORY ON RSTS DISK

.DSABL	LSB


.SBTTL	PTDRNW - XFER NEW DIRECTORY CLUSTERS TO SAVE VOLUME	;JDB005
;+
; PTDRNW - TRANSFER NEW RSTS DISK DIRECTORY CLUSTERS TO SAVE VOLUME
;
;	CALL:	CALL	PTDRNW
;
;	INPUTS: FIRST BLOCK OF FIRST MFD CLUSTER IN FIBUF
;
;	RETURN: C-BIT INDICATES SUCCESS OR FAILURE
;		REGISTERS NOT PRESERVED
;-

.ENABL	LSB

PTDRNW::CALL	XFRXFD		;TRANSFER MFD TO SAVESET
	BCS	20$		;BRANCH IF MFD TRANSFER FAILED
	MOV	#FIBUF,R4	;INITIALIZE DCN PTR BLOCK PTR
	MOV	FIBMAP+2,R2	;GET DCN OF FIRST MFD CLUSTER
	CALL	CNVRIB		;CONVERT RETRIEVAL PTR TO FBN
	ADD	#1,R2		;POINT TO BLOCK 2 OF CLUSTER 1 (DCN PTR BLOCK)
	ADC	R3		; (MSB)
10$:	CALL	PRCGFD		;PROCESS THE CURRENTLY POINTED GFD
	BCS	20$		;BRANCH IF ANY ERRORS ENCOUNTERED
	CMP	#FIBUF+512.,r4	;ANY MORE GFD's?
	BNE	10$		;BRANCH IF SO - GO GET 'EM
20$:	RETURN			;THAT'S ALL FOLKS!

.DSABL	LSB


.SBTTL	PRCGFD - PROCESS GFD CLUSTER TRANSFER TO SAVE VOLUME	;JDB005
;+
; PRCGFD - PROCESS GFD DIRECTORY CLUSTERS TRANSFER TO SAVE VOLUME
;
;	CALL:	CALL	PRCGFD
;
;	INPUTS: R2&R3 = FIP BLOCK NUMBER OF DCN PTR BLOCK IN MFD
;		R4 = CURRENT PTR TO A GFD DCN IN THE BLOCK
;
;	RETURN: R2&R3 PRESERVED
;		R4 = UPDATED TO PT TO NEXT GFD DCN (IF ANY)
;		OTHERS FAIR GAME
;		C-BIT INDICATES SUCCESS OR FAILURE
;-

.ENABL	LSB

PRCGFD::MOV	R2,-(SP)	;PRESERVE FBN
	MOV	R3,-(SP)	; (MSB)
	CALL	READ		;GET THE DCN PTR BLOCK FROM THE MFD
	BCS	100$		;BRANCH ON READ FAILURE FROM MFD
	MOV	(R4)+,R2	;GET DCN PTR OF THIS GFD AND POP TO NEXT
	BEQ	10$		;BRANCH IF THERE WAS NONE ALLOCATED
	CALL	GNXFER		; ELSE GET IT AND TRANSFER IT TO SAVE VOLUME
	BCS	10$		;BRANCH IF GFD TRANSFER FAILED
	CALL	XFRGRP		; ELSE TRANSFER GFD'S OFFSPRING
10$:	MOV	(SP)+,R3	;RESTORE FBN
	MOV	(SP)+,R2	; (LSB)
	RETURN			;THAT'S ALL FOLKS!

100$:	CALL	BADLNK		;BAD DIRECTORY ON RSTS DISK
.DSABL	LSB


.SBTTL	GNXFER - GET BLOCK 1 OF XFD AND XFER XFD TO SAVE VOLUME	;JDB005
;+
; GNXFER - GET FIRST BLOCK OF AN XFD AND TRANSFER XFD TO SAVE VOLUME
;
;	CALL:	CALL	GNXFER
;
;	INPUTS: R2 = DCN OF FIRST BLOCK OF A FILE DIRECTORY
;
;	RETURN: R2,R3 = FBN EQUIVALENT OF DCN ON ENTRY			;JDB008
;		OTHERS FAIR GAME
;		C-BIT INDICATES SUCCESS OR FAILURE
;-

.ENABL	LSB

GNXFER::CALL	FSRDRF		;GET FIRST BLOCK OF THE FILE DIRECTORY
	BCS	100$		;BRANCH IF BAD DIRECTORY
	CALL	XFRXFD		;TRANSFER THE FILE DIRECTORY TO THE SAVESET
10$:	RETURN			;THAT'S ALL FOLKS!

100$:	CALL	BADLNK		;BAD DIRECTORY ON RSTS DISK

.DSABL	LSB


.SBTTL	XFRGRP - TRANSFER GFD'S OFFSPRING TO SAVE VOLUME	;JDB005

;+
; XFRGRP - TRANSFER GFD'S OFFSPRING TO SAVE VOLUME
;
;	CALL:	CALL	XFRGRP
;
;	INPUTS: R2,R3 = FBN OF FIRST CLUSTER OF GFD		;JDB008
;
;	RETURN: R0-R5 PRESERVED
;		C-BIT INDICATES SUCCESS OR FAILURE
;-

.ENABL	LSB

XFRGRP::REGSCR			;PRESERVE R0-R5
	MOV	#FIBUF,R4	;INITIALIZE DCN PTR BLOCK PTR
	ADD	#1,R2		;POINT TO BLOCK 2 OF CLUSTER 1 (DCN PTR BLOCK)
	ADC	R3		; (MSB)
10$:	CALL	READ		;GET DCN PTR BLOCK
	BCS	100$		;BRANCH IF READ FAILURE IN GFD
	MOV	R2,-(SP)	;PRESERVE FBN
	MOV	R3,-(SP)	; (MSB)
	MOV	(R4)+,R2	;GET CURRENT DCN PTR AND POP TO NEXT
	BEQ	20$		;BRANCH IF THAT WASN'T ALLOCATED
	CALL	GNXFER		; ELSE GO GET AND TRANSFER THIS UFD
20$:	MOV	(SP)+,R3	;RESTORE FBN
	MOV	(SP)+,R2	; (LSB)
	BCS	30$		;BRANCH IF UFD TRANSFER FAILED
	CMP	#FIBUF+512.,R4	;ANY MORE UFD'S?
	BNE	10$		;BRANCH IF SO - GO GET 'EM
30$:	RETURN			;THAT'S ALL FOLKS!

100$:	CALL	BADLNK		;BAD DIRECTORY ON RSTS DISK

.DSABL	LSB


.SBTTL	XFRXFD - XFER AN ENTIRE FILE DIRECTORY TO SAVE VOLUME	;JDB005

;+
; XFRXFD - TRANSFER A SET OF RSTS FILE DIRECTORY CLUSTERS TO SAVE VOLUME
;
;	CALL:	CALL	XFRXFD
;
;	INPUTS: FIRST BLOCK OF FIRST SOME XFD CLUSTER IN FIBUF
;
;	RETURN: C-BIT INDICATES SUCCESS OR FAILURE
;		REGISTERS 0-5 PRESERVED
;-

.ENABL	LSB

XFRXFD::REGSCR			;PRESERVE R0-R5
	MOVB	#1,HIGHBF	;WILL BE DOING I/O TO/FROM BUFBEG
	MOV	#FIBMAP,R5	;POINT TO CLUSTER MAP
	MOV	(R5)+,R3	;GET THE CLUSTER SIZE
	BIC	#100000,R3	;TURN OFF SIGN BIT IN CASE THIS IS A 'NEW' DISK
	CLR	R2		;SETUP FOR DIVIDE
	DIV	PCS,R2		;COMPUTE # PC'S ON DIRECTORY CLUSTER
20$:	MOV	R2,-(SP)	;SAVE IT ON THE STACK
	MOV	(R5)+,R2	;GET A RETREIVAL POINTER
	BNE	30$		;NON-ZERO - WE GOT A REAL ONE
	TST	(SP)+		;POP STACK
	BR	70$		;ALL DONE THIS DIRECTORY		;JDB008
30$:	CALLX	RIB2CN		;CONVERT DCN TO PCN
	MOV	R3,PCNUM	;THIS IS THE CLUSTER WE WANT
	MOV	(SP)+,R2	;RESTORE # PC'S/DC
	MOV	R2,R3		;COPY INTO R3
	;FOLLOWING LINE USED TO BE 40$: MOV PCNUM,(R4)+			;JDB009
	;CODE WAS REMOVED AND LABEL MOVED TO NEXT LINE (MOV #1,XFRCNT)	;JDB009
	;SINCE R4 IS UNDEFINED AND THERE IS NO POINT TO THE CODE	;JDB009
40$:	MOV	#1,XFRCNT	;SET UP XFRCNT FOR GETRST		;JDB009
	CALL	GETRST		;GET THE CLUSTER
	BCS	70$		;COULDN'T
	TST	DUMP		;BUFFER FULL ?
	BEQ	50$		;BRANCH IF NOT - GET SOME MORE
	MOV	ENDDAT,XFRPCN	;GET PCN WHERE DATA STOPS
	CALL	PUTSAV		;PUT TO SAVE VOLUME
	BCS	70$		;COULDN'T
	CALL	SETCH1		;SET UP TO GET MORE CLUSTERS
	MOV	FIBPHS,DIRCON	;SAVE THE # OF THE BLOCK WE HAVE
	MOV	FIBPHS+2,DIRCON+2
	MOV	R5,DIRCON+4	;SAVE THE POINTER TO THE RP
	MOV	R2,DIRCON+6	;SAVE THE #PC'S/DC
	MOV	R3,DIRCON+10	;SAVE THE # OF THE PC WITHIN THE DC
50$:	INC	PCNUM		;NEXT PC IN DC
	SOB	R3,40$		;DO FOR ALL PC'S IN DC
60$:	BIT	R5,#17		;EXHAUSTED THE RETREIVAL ENTRY?
		;NOTE - PREVIOUS ASSUMES THAT FIBMAP IS ON AN 8. WORD BOUNDARY
	BNE	20$		;NO - GO GET ANOTHER RP
70$:	MOVB	#0,HIGHBF	;RESET FOR I/O TO FIBUF - BUT LEAVE C-BIT ALONE
	RETURN			;THAT'S ALL FOLKS!

.DSABL	LSB

.SBTTL	PUTSAV - PUT TO SAVE VOLUME

;+
; PUTSAV - PUT CONTENTS OF BUFBEG OUT TO A SAVE VOLUME
;
;	CALL:	BLKXF = # OF BLOCKS TRANSFERRED PRIOR TO THIS CALL
;		PCNRD = # OF PACK CLUSTERS STORED IN THE BUFFER
;		CALL	PUTSAV
;
;	RETURN:	BLKXF UPDATED
;		C=1 - ERROR
;		C=0 - NO ERROR
;-

.ENABL	LSB

PUTSAV::REGSAV			;SAVE REGISTERS
	MOV	PCNRD,R3	;GET # OF PCN'S IN BUFFER
	BEQ	20$		;NOTHING TO PUT
	MUL	PCS,R3		;* PCS = # BLOCKS IN BUFFER
	MOV	R3,R2		;SAVE # BLOCKS
	MUL	#256.,R3	;* 256. = # WORDS IN BUFFER
	MOV	R3,I.DSQ+DSQCNT	;# WORDS TO TRANSFER
	MOV	CURFBN,TMPFBN	;SAVE CURFBN
	MOV	CURFBN+2,TMPFBN+2
	CALL	SETCH2		;I/O THRU CHANNEL 2
	CLR	R4
10$:	CALL	SAVIO,R5,WFUN	;PUT IT
	  BR	40$		;UNRECOVERABLE I/O ERROR
	  BR	50$		;BAD BLOCK ERROR
	  BR	60$		;EOF ERROR
	  ADD	R2,BLKXFV	;OK - UPDATE # BLOCKS TRANSFERRED
	ADC	BLKXFV+2
20$:	CLC			;SUCCESS EXIT
	CALL	SETCH2		;I/O THRU CHANNEL 2
30$:	CALLX	REGRES,R5	;RESTORE REGISTERS
	RETURN

40$:	CALL	CHKABT		;CHECK FOR FATAL ERROR
50$:	CALL	BBOUSV		;HANDLE BAD BLOCK
	BCC	10$		;ITS BEEN HANDLED - GO TRY AGAIN
	INC	R4
60$:	TSTB	SSVOL+SSHIDX	;SAVE VOLUME MAGTAPE ?
	BEQ	70$		;NO - GO FINISH OFF DISK VOLUME
	CALL	SENDMT,R4	;FINISH OFF MAGTAPE VOLUME
	  BR	100$		;GO DO REMOUNT - BAD VOLUME
	  BR	80$		;PROCEED WITH NORMAL FINISH

70$:	CALL	SENDDK		;FINISH OFF DISK VOLUME
80$:	BIT	#VE,SWTWRD	;VERIFY REQUESTED ?
	BEQ	90$		;NO
	CALL	VERSAV		;DO IT
	BCS	30$
90$:	CLR	INPUT		;WILL DO OUTPUT MOUNT/DISMOUNT
	CALL	DISMNT		;DISMOUNT CURRENT VOLUME
	CALLX	MESSAG,R5,LABMSG ;TELL THEM TO LABEL IT
100$:	CALL	ACCUM		;ADD VOLUME BLOCKS TO TOTAL
	CALL	MOUNT		;MOUNT NEXT
	BCS	30$		;MOUNT FAILURE - WE DIE
	CALL	PRBEG		;PRINT NEW START BLURB
	CLR	PCNRD		;CLEAR # PCN'S READ
	CALL	GETDCN		;GET OUR START DCN
	CALL	PTRGET		;SAVE VERIFY PTRS
	TST	SSVOL+SSDIR	;ARE WE IN THE DIRECTORY TRANSFER PHASE ?
	BEQ	110$		;NO
	MOV	R2,SSVOL+SSDIR	;YES - MOVE IN START DCN
	BR	20$		;GET OUT

110$:	MOV	R2,SSVOL+SSDAT	;SET UP FOR DATA TRANSFER
	BR	20$		;GET OUT

.DSABL	LSB
GLOBAL	<PCS,I.DSQ,CURFBN,SSVOL,SWTWRD>

.SBTTL	SENDMT - TERMINATE A MAGTAPE SAVE VOLUME

;+
; SENDMT - TERMINATE A MAGTAPE SAVE VOLUME
;	   TO TERMINATE A MAGTAPE VOLUME WE WILL BACKSPACE OVER FIVE (SIX
;	   IF WE HIT A BAD BLOCK) RECORDS TO GUARENTEE ENOUGH SPACE TO
;	   WRITE THREE EOF'S AND THEN WRITE THE EOF'S -- THIS ALSO IN-
;	   VOLVES BACKING UP OUR SATT BYTE AND BIT POINTERS SO WE RESUME
;	   WITH THE RIGHT PACK CLUSTER ON THE NEXT VOLUME.
;
;	CALL:	BLKXF = # BLOCKS WHICH HAVE BEEN TRANSFERRED
;		CURFBN = NEXT FBN TO BE WRITTEN TO
;		TMPFBN = FIRST FBN ATTEMPTED ON WRITE
;		(SP) = 1 IF WE HAVE TO SKIP A BAD BLOCK
;		     = 0 OTHERWISE
;		CALL	SENDMT,R4
;
;	RETURN: + 0 - BAD MAGTAPE VOLUME (TOO SHORT) -DISMOUNT HAS BEEN ISSUED
;		+ 2 - SUCCESSFUL VOLUME TERMINATION
;-

.ENABL	LSB

SENDMT::MOV	PCNRD,R2	;THE # OF PC'S TO SKIP
				;29-JUN-81 - JDB - START - 5 LINES REPLACED
	CMP	CURFBN,TMPFBN	;WAS IT THE FIRST RECORD WRITE THAT FAILED?
	BEQ	20$		;BRANCH IF SO - WE'RE ALL SET TO GO
	TST	(SP)		;DID WE HIT A BAD BLOCK?
	BNE	10$		;BRANCH IF SO - DON'T OVERDO IT
	INC	(SP)		;ON NORMAL TERMINATION SET INITIAL BACKSPACE=1
				;29-JUN-81 - JDB - END
10$:	INC	(SP)		;WILL BACKSPACE ONE MORE RECORD
20$:	CLRB	IOERR		;CLEAR PREVIOUS ERROR INDICATOR		;JDB008
	MOV	R4,HOLDR4	;SAVE R4 ACROSS SRESET (NOT ON STACK)	;JDB008
	CALL	SRESET		;RESET POINTERS FOR RESUMING ON NEXT VOLUME
	MOV	HOLDR4,R4	;RESTORE R4 (NOT FROM STACK)		;JDB008
	MOV	(SP),R5		;# RECORDS TO BACKSPACE
30$:	NEG	R5		;WANT TO BACKSPACE
	BEQ	40$		;NO MORE TO BACKSPACE
	CALL	SKPREC		;DO IT
	BCS	90$		;ERROR IN BACKSPACE
40$:	CLR	(SP)		;INDICATE WRITING EOF'S
	MOV	#3,R5		;WANT TO WRITE 3 EOF'S
50$:	CALL	WRTEOF		;DO IT
	BCS	90$		;ERROR IN EOF WRITE
	TST	BLKXFV		;VOLUME HAVE ANYTHING ON IT YET ?
	BNE	60$		;YES
	TST	BLKXFV+2	;SAME QUESTION
	BEQ	80$		;NO - IT'S NO GOOD
60$:	TST	(R4)+		;SUCCESS EXIT + 2
70$:	RETURN	R4

80$:	WARN	BADMAG		;BAD MAGTAPE
	CLR	INPUT		;WILL DO OUTPUT DISMOUNT
	CALL	DISMNT		;DO IT
	DECB	SSVOL+SSSEQ	;WANT TO DO A REMOUNT
				;29-JUN-81 - JDB - START - REPLACED ONE LINE
	BNE	70$		;ONLY IF THIS ISN'T THE FIRST VOLUME
	MOV	#BADMAG,ABTADR	;ELSE SPECIFY THAT MAGTAPE IS HOPELESS
	CALL	CHKABT		;AND GO DIE BY NORMAL PROCESSES
				;29-JUN-81 - JDB - END - 

90$:	CMPB	#NOROOM,IOERR	;"NO ROOM FOR USER"?
	BNE	100$		;NOPE
	TST	(SP)		;WRITING EOF'S?
	BEQ	50$		;YES - RESUME
	BR	30$		;RESUME RECORD SKIP

100$:	ERF	<"SENDMT tape err">

	TMPORG	SAVCTL							;JDB008
HOLDR4:	.WORD	0		;TEMPORARY HOLDING AREA FOR R4		;JDB008
	UNORG								;JDB008

.DSABL	LSB
GLOBAL	<SATBUF,CURFBN,SSVOL,IOERR>

.SBTTL	SENDDK - TERMINATE A DISK SAVE VOLUME

;+
; SENDDK - TERMINATE A DISK SAVE VOLUME
;	   TO TERMINATE A DISK VOLUME WE WILL WRITE OUT THE BAD BLOCK FILE
;	   EVEN IF IT IS EMPTY (TO GUARENTEE IT IS SO) AND SET UP THE SAVE
;	   SET COMPONENTS ADDRESSES (DCN'S) IN THE SAVE LABEL
;
;	CALL:	NOTHING IN PARTICULAR NEED BE SET UP
;		CALL	SENDDK
;
;	RETURN:	WE DID IT
;-

.ENABL	LSB

SENDDK::MOV	PCNRD,R2	;ANYTHING IN THE BUFFER ?
	BEQ	10$		;NO
	CALL	SRESET		;RESET POINTERS TO RESUME AFTER MOUNT
10$:	MOV	#1024.,R5	;WANT TO ZERO 1ST 4 BLKS OF BUFBEG
	CALL	CLRIOB		;CLEAR 'EM
	MOV	BADBO,R0	;ADDRESS OF SAVE VOLUME BAD BLOCK FILE
	MOV	NBADO,R1	;# OF BAD BLOCKS IN FILE
	ADD	UNKBBO,R1	;ADD IN UNEXPECTED BAD BLOCKS
	BEQ	30$		;GO PUT OUT ZEROED BAD BLOCK FILE
	CALL	W2SORT		;SORT 'EM
	MOV	#BUFBEG,-(SP)	;FIRST IOBUFF OFFSET
	MOV	DCS,R4		;SET UP CONSTANT = DCS - 1
	DEC	R4		; AS WE WILL CONVERT FBN TO LBN ON OUTPUT
20$:	MOV	(R0)+,R2	;GET AN FBN FROM THE BAD BLOCK BUFFER
	MOV	(R0)+,R3
	ADD	R4,R2		;LBN = FBN + (DCS - 1)
	ADC	R3
	MOV	R2,-(SP)	;SETUP TO PUT LSB
	CALLX	PUTIOB		;PUT IT
	ADD	#2,(SP)		;INCREMENT OFFSET IN TO BUFFER
	MOV	R3,-(SP)	;SETUP TO PUT MSB
	CALLX	PUTIOB		;PUT IT
	ADD	#2,(SP)		;INCREMENT OFFSET INTO BUFFER
	SOB	R1,20$		;DO FOR ALL BAD BLOCKS
	TST	(SP)+		;POP OFFSET OFF THE STACK
30$:	MOV	#BUFBEG,BUFPTR	;POINT TO BEGINNING OF BAD BLOCK FILE(S)
	MOVB	#1,HIGHBF	;I/O TO IOBUFF
	MOV	#1024.,R1	;LENGTH OF BAD BLOCK FILES (4 BLKS)
	MOV	#2,R2		;BAD BLOCK FILE AT FBN 2
	CLR	R3
	CALL	WDSKIO,R5	;WRITE THE BAD BLOCK FILE
	  BR	60$		;FATAL BAD BLOCK
	  CLR	R2		;WE WANT PLB
	MOV	#512.,R1	;NEED TO GET FIRST TWO BLKS ON DISK
	CALL	RDSKIO,R5	;READ 'EM
	  BR	60$		;BAD BLOCK
	  MOV	#BUFBEG+PLBSLA,-(SP)	;OFFSET FOR SAVE LABEL ADDRESS
	CALLX	GETIOB		;GET ADDRESS LSB
	MOV	(SP),R2		; INTO R2
	MOV	#BUFBEG+PLBSLA+2,(SP)	;OFFSET FOR MSB
	CALLX	GETIOB		;GET ADDRESS MSB
	MOV	(SP)+,R3	; INTO R3
	MOV	#256.,R1	;SAVE LABEL ONE BLOCK LONG
	CALL	RDSKIO,R5	;READ IT
	  BR	60$		;BAD BLOCK
	  MOV	#SSVOL+SSSATL,R0 ;POINT TO SATT LENGTH IN SSVOL
	MOV	#BUFBEG+SLSATL,R1 ;POINT TO SATT LENGTH IN SAVE LABEL
	MOV	#5,R4		;WILL MOVE 5 WORDS
40$:	MOV	R1,-(SP)	;IOBUFF OFFSET
	MOV	(R0)+,-(SP)	;WORD TO PUT
	CALLX	PUTIOB		;PUT IT
	CMP	(SP)+,(R1)+	;POP OFFSET, INC OFFSET
	SOB	R4,40$		;MOVE ALL 5 WORDS
	MOV	#256.,R1	;LENGTH OF SAVE LABEL
	CALL	WDSKIO,R5	;WRITE IT OUT
	  BR	60$		;BAD BLOCK ERROR
	  CLC
50$:	RETURN

60$:	CALL	FATBAD		;FATAL BAD BLOCK ERROR - GOOD-BYE

.DSABL	LSB
GLOBAL	<BADBO,NBADO,DCS,SSVOL>

.SBTTL	SRESET - RESET POINTERS TO RESUME ON NEW VOLUME

;+
; SRESET - RESET POINTERS TO RESUME ON NEW VOLUME
;
;	CALL:	R2 = # PC'S TO SKIP (IF CALLED DURING DATA TRANSFER)
;		SSVOL+SSDIR INDICATES WHETHER WE ARE IN A DATA OR
;		DIRECTORY BLOCK TRANSFER MODE
;		CALL	SRESET
;
;	RETURN:	POINTERS R2, R3, R5 SET UP FOR RESUMPTION
;-

.ENABL	LSB

SRESET::TST	SSVOL+SSDIR	;ARE WE TRANSFERRING DIR. BLKS. ?
	BNE	10$		;YES - GO DO PROPER RESET
	MOV	TOS.R3+4(SP),R3	;# OF CURRENT SATT BYTE
	MOV	TOS.R5+4(SP),R5	;# OF BIT IN SATT BYTE
	CALL	BACKPC		;BACK SPACE OVER PC'S IN SATT
	MOV	R3,TOS.R3+4(SP)	;NEW # OF CURRENT SATT BYTE
	MOV	R5,TOS.R5+4(SP)	;NEW # OF BIT IN SATT BYTE
	ADD	R2,TOS.R2+4(SP)	;INCREMENT # PC'S YET TO TRANSFER
	BR	30$		;ALL DONE

10$:	CLR	FIBPHS		;MAKE SURE WE WON'T INHIBIT READ
	CLR	FIBPHS+2
	MOV	#DIRCON+4,R4	;POINT TO SAVED RP POINTER
				;14-AUG-81 - JDB - START - 8 LINES REPLACED
	TST	(R4)		;CHECK OUT RP POINTER
	BEQ	20$		;ITS ZERO - WE'RE STARTING FROM THE TOP
	MOV	-(R4),R3	;GET DIRECTORY BLOCK MSB
	MOV	-(R4),R2	;GET DIRECTORY BLOCK LSB
	CALL	FSREAD		;READ IN DIRECTORY BLOCK
	BNE	40$		;BAD BLOCK - GO DIE
	CMP	(R4)+,(R4)+	;SKIP OVER LSB AND MSB AND POINT TO RP POINTER
20$:	MOV	(R4)+,TOS.R5+4(SP)	;GET RP POINTER
				;14-AUG-81 - JDB - END
	MOV	(R4)+,TOS.R2+4(SP)	;# PC'S/DC
	MOV	(R4)+,TOS.R3+4(SP)	;# OF PC WITHIN DC
30$:	RETURN

40$:	CALL	BADLNK		;NOT SO GOOD - DIE

.DSABL	LSB
GLOBAL	<SSVOL,FIBPHS>

.SBTTL	BACKPC - BACKSPACE OVER ALLOCATED BITS IN SATT

;+
; BACKPC - BACKSPACE OVER R2 ALLOCATED BITS IN THE SATT
;
;	CALL:	R2 = # BITS (PC'S) IN THE SATT TO BACKSPACE
;		R3 = # OF CURRENT SATT BYTE
;		R5 = # OF CURRENT BIT IN SATT BYTE
;		PCNUM = PC LAST TESTED
;
;		CALL	BACKPC
;
;	RETURN:	THE PC'S HAVE BEEN SKIPPED AND R3,R5 & PCNUM
;		ARE SET UP CORRECTLY TO RESUME TRANSFER
;		R2 = # ADDITIONAL BITS IN SATT STILL TO CHECK
;-

.ENABL	LSB

BACKPC::MOV	R2,-(SP)	;SAVE R2
	BR	20$		;AND A 1,2,3...

10$:	INC	(SP)		;FREE CLUSTER COUNTS AS BIT IN SATT TO CHECK
20$:	DEC	PCNUM		;BACK A PC
	CLC			;FOR THE ROTATE
	RORB	R5		;LAST BIT
	BCC	30$		;STILL IN BYTE
	DEC	R3		;LAST BYTE
	BISB	#128.,R5	;LAST BIT IN BYTE
30$:	BITB	R5,SATBUF(R3)	;THIS BIT ALLOCATED ?
	BEQ	10$		;NO - ON TO NEXT
	SOB	R2,20$		;YES - SUBTRACT ONE AND ON TO NEXT
	MOV	(SP)+,R2	;RESTORE R2
	RETURN			;...ALL DONE

GLOBAL	<SATBUF,PCNUM>
.DSABL	LSB


.SBTTL	CLRIOB - CLEAR SOME WORDS IN THE I/O BUFFER

;+
; CLRIOB - CLEAR SOME WORDS IN THE I/O BUFFER
;
;	CALL:	R5 = # OF WORDS TO CLEAR
;		CALL	CLRIOB
;
;	RETURN:	IT'S DONE
;-

.ENABL	LSB

CLRIOB:	MOV	#BUFBEG-2,-(SP)	;PUT THE OFFSET ON THE STACK
10$:	ADD	#2,(SP)		;FORWARD A WORD
	CLR	-(SP)		;WILL WILL PUT A ZERO WORD
	CALLX	PUTIOB		;CLEAR A WORD
	SOB	R5,10$		;DO FOR REQUESTED # OF WORDS
	TST	(SP)+		;POP OFFSET OFF THE STACK
	RETURN

.DSABL	LSB

.SBTTL	GETDCN - GET DCN OF FIRST DC IN NEXT SAVE CLUSTER

;+
; GETDCN - GET DCN OF FIRST DC IN NEXT SAVE CLUSTER
;
;	CALL:	CURFBN = NEXT FBN TO WRITE TO
;		CALL	GETDCN
;
;	RETURN:	R2 = DCN OF FIRST DC WITHIN NEXT SAVE CLUSTER WHICH
;		     IS ON A DEVICE CLUSTER BOUNDARY
;		CURFBN = FBN OF SAME SAVE CLUSTER
;-

.ENABL	LSB

GETDCN::TSTB	SSVOL+SSHIDX	;SAVE VOLUME MAGTAPE ?
	BNE	30$		;YES - EXIT IMMEDIATELY
	MOV	R1,-(SP)	;SAVE R1
	MOV	R3,-(SP)	;SAVE R3
	MOV	CURFBN,R2	;GET CURRENT FBN
	MOV	CURFBN+2,R3
	MOV	MNTTBL+2,R1	;THE SAVE VOLUME MOUNT TABLE
	MOVB	MNTDCS(R1),R1	;THE SAVE VOLUME DEVICE CLUSTER SIZE
10$:	CALL	CHKSBA		;MAKE SURE IT IS NOT BAD
	MOV	R2,-(SP)	;SAVE IT ON STACK
	MOV	R3,-(SP)
	CALL	SEG2D2		;GET THE CORRESPONDING DCN
	TST	R3		;WAS FBN ON DCN BOUNDARY ?
	BEQ	20$		;YES - WE'RE DONE
	MOV	(SP)+,R3	;NO - RESTORE FBN
	MOV	(SP)+,R2
	ADD	#8.,R2		;INCREMENT UP TO NEXT SAVE CLUSTER
	ADC	R3
	BR	10$		;TRY THIS ONE

20$:	MOV	(SP)+,CURFBN+2	;THIS IS THE ONE WE WANT
	MOV	(SP)+,CURFBN
	MOV	(SP)+,R3	;RESTORE R3
	MOV	(SP)+,R1	;RESTORE R1
30$:	RETURN

.DSABL	LSB
GLOBAL	<SSVOL,CURFBN,MNTTBL>

.SBTTL	VERSAV - SAVE VERIFY

;+
; VERSAV - SAVE VERIFY MAINLINE
;
;	CALL:	VERBLK SET UP
;		R3 = CURRENT SATT BYTE POINTER
;		R5 = CURRENT SATT BIT IN BYTE
;		CALL	VERSAV
;
;	RETURN:	ENTRIES IN BADVER IF ANY BAD COMPARES
;-

.ENABL	LSB

VERSAV::REGSCR			;SAVE REGISTERS
	TST	SSVOL+SSDIR	;DIRECTORY BLOCKS?		;AWR001
	BNE	80$		;YES - NOTHING TO DO		;AWR001
	MOV	#VEMSG,RTNNAM	;ROUTINE NAME IS 'VERIFY PASS'
	TSTB	SSVOL+SSHIDX	;SAVE VOLUME MAGTAPE ?
	BEQ	10$		;NO
	CALL	REWIND		;START REWIND NOW
10$:	CALL	PRBEG		;PRINT VERIFY BLURB
	TSTB	SSVOL+SSHIDX	;SAVE VOLUME MAGTAPE ?
	BEQ	30$		;NO
	MOV	#3,R5		;REWIND FUNCTION
	CMPB	#1,SSVOL+SSSEQ	;THIS THE FIRST SAVE VOLUME ?
	BNE	20$		;NO
	CMPB	(R5)+,(R5)+	;YES - MUST PASS 5 EOF'S (ADD 2)
20$:	CALL	ADVEOF		;DO ADVANCE
	BCS	90$		;EOT - THIS IS VERY BAD
30$:	CALL	PTRSAV,R5	;SAVE PCNUM/CBADI/CBADO/CURFBN
	CALL	SELEC2		;SELECT SAVE VOLUME
	MOV	NBADO,R1	;SET UP CALL FOR BBSORT		;AWR002
	ADD	UNKBBO,R1	;OFFSET BY UNKNOWN BAD BLOCKS	;AWR002
	CALL	BBSORT		;NOW ORDER THE BAD BLOCK LIST	;AWR002
	MOV	R5,NEWOBB	;RESET POINTERS			;AWR002
	MOV	R5,CNBBO	;				;AWR002
	MOV	R1,NBADO	;				;AWR002
	MOV	R0,CBADO	;				;AWR002
	CALL	SRVINI		;DO INITIAL SET UP
40$:	CALL	SETCH2		;SELECT SAVE VOLUME
	CLR	PCNRD		;AIN'T GOT NONE YET
	CALL	GETSAV		;GET DATA FROM SAVE VOLUME
	TST	DUMP		;DID WE GET ANYTHING ?
	BEQ	50$		;NO - WE'RE DONE
	MOV	PCNRD,-(SP)	;SAVE PCNRD
	CALL	SETCH1		;SELECT RSTS DISK
	MOV	(SP)+,PCNRD	;RESTORE PCNRD
	CALL	COMPAR		;DO COMPARE/WRITE CHECK
	BCS	70$
	BR	40$		;GO GET SOME MORE DATA

50$:	CALL	PRTDIF		;PRINT # OF DIFFERENCES
60$:	CLR	VFY		;CLEAR VFY WITHOUT AFFECTING CARRY
70$:	CALL	PTRRES,R5	;RESTORE CBADI/CBADO/CURFBN
	MOV	#SAVMSG,RTNNAM	;BRING BACK 'SAVE' AS ROUTINE NAME
80$:	RETURN

90$:	ERF	<"EOT in VERIFY">

.DSABL	LSB
GLOBAL	<SSVOL,RTNNAM>

.SBTTL	SAT2IO - TRANSFER BETWEEN SATBUF AND IOBUFF

;+
; SAT2IO - MOVE	R2 WORDS FROM SATBUF TO IOBUFF
;
;	CALL:	R2 = # WORDS TO TRANSFER
;		CALL	SAT2IO
;
;	RETURN:	IT HAS BEEN MOVED
;-

.ENABL	LSB

SAT2IO:	REGSCR			;SAVE REGISTERS
	CLR	-(SP)		;WHERE THE OFFSET WORD WILL GO
	DEC	R2		;OFFSET 0 WILL COUNT AS ONE
	ASL	R2		;COMPUTE A BYTE OFFSET
	MOV	R2,R3		;COPY IT
	ADD	#BUFBEG,R3	;R3 IS IOBUFF OFFSET
10$:	MOV	R3,(SP)		;THE OFFSET
	MOV	SATBUF(R2),-(SP);THE WORD FROM SATBUF
	CALLX	PUTIOB		;PUT IT
	CMP	-(R2),-(R3)	;BACK A WORD
	TST	R2		;FINISHED ?
	BGE	10$		;NOT YET
	TST	(SP)+		;YES - POP OFF THE OFFSET
	RETURN

.DSABL	LSB
GLOBAL	<SATBUF>

.SBTTL	RETURNS TO MOUNT

.ENABL	LSB

BBSAV::	JMP	BBRET		;RETURN FROM BBLOK -> BACK TO MOUNT

WRINIT:	CALL	WRT1EF		;WRITE 1 EOF IF SAVE VOLUME'S MAGTAPE
	RETURN			; COMES BACK C-BIT SET IF ERROR, CLEAR IF
				; OK OR NOT TAPE

SCNREL:
BOODCN:	CLC			;NOTHING TO DO FOR SAVE - BUT ENSURE
	RETURN			; WE'RE SUCCESSFUL

.DSABL	LSB

.SBTTL	SAVE DUMMY ROUTINES

.ENABL	LSB

BBSORT:	MOV	BADBO,R0	;GET BB TABLE ADDRESS
	CALL	W2SORT		;SAVE USES ONLY W2SORT - NO NEED FOR WSORT
	MOV	R1,R5		;NEED TO ADJUST (NEWOBB) POINTER
	ASL	R5		;TURN UNIQUE EXISTING BAD BLOCK
	ASL	R5		;COUNT INTO OFFSET
	ADD	R0,R5		;AND POINT TO THE RIGHT SPOT
	RETURN

ALLOC2:
RSTBOO:
INMNT:	JMP	ILLCAL	;ILLEGAL CALL - GO DIE

.DSABL	LSB

.SBTTL	GETSAV - GET FROM A SAVE VOLUME (SAVE)

;+
; GETSAV - FILL IOBUFF WITH SAVE VOLUME CLUSTERS
;
;	CALL:	PCNUM  = # OF FIRST PCN TO TRY
;		PCNRD  = ASSUMED TO BE ZERO
;		BUFPTR = ASSUMED TO POINT TO BEGINNING OF IOBUFF
;		R2     = # OF SATT BITS YET TO CHECK
;		R3     = CURRENT SATT BYTE POINTER
;		R5     = BIT IN BYTE
;		R0     = SAVE VOLUME INDEX
;		R1     = SAVE VOLUME UNIT #
;		R4     = ASSUMED TO POINT TO WHERE PCN'S ARE TO BE STORED
;		CURFBN = NEXT SAVE VOLUME FBN/RECNO TO READ
;
;		CALL	GETSAV
;
;	RETURN:	C=1 - UNKNOWN INPUT BAD BLOCK HIT AND EITHER WE'VE HIT
;		      THE RSTS LIMIT OR /NOERROR WAS SPECIFIED
;					OR
;		      WE COULDN'T MOUNT THE NEXT REQUIRED VOLUME
;		C=0 - DUMP INDICATES IF THE BUFFER HAS ANYTHING IN IT
;		      PCNRD IS THE NUMBER OF PC'S IN IT (IF DUMP<>0)
;-

.ENABL	LSB

GETSAV:	TST	R2		;ANYTHING LEFT TO GET ?
	BEQ	40$		;NO - GET OUT WITHOUT SETTING DUMP
	CLR	HALF		;CLEAR BUFFER HALF INDICATOR
	CALL	XFRFIL		;LOAD THE XFRPCN TABLE
	MOV	PCNRD,-(SP)	;SAVE COUNT READ
	BEQ	30$		;DIDN'T GET ANY
	MOV	PCSWDS,R1	;GET PCS*256.
	MUL	PCNRD,R1	;*PCNRD=# WORDS IN BUFFER
10$:	MOV	R1,I.DSQ+DSQCNT	;WHICH IS HOW MANY WE WANT
	MOV	CURFBN,TMPFBN	;SAVE CURFBN
	MOV	CURFBN+2,TMPFBN+2
	MOV	CBADO,TMPCBO	;SAVE POINTER TO BAD BLK TABLE
	CALL	SAVIO,R5,RFUN	;GET SOME DATA
	  BR	50$		;BAD MAGTAPE RECORD
	  BR	60$		;BAD BLOCK
	  BR	70$		;EOF ERROR
20$:	  MOV	(PC),DUMP	;INDICATE WE GOT SOMETHING
30$:	CLC
	MOV	(SP)+,PCNRD	;RESTORE COUNT READ
40$:	RETURN

50$:	CALL	CHKABT		;CHECK FOR FATAL ERROR
60$:	CALL	BBINSV		;HANDLE BAD BLOCK
	BCC	20$		;C=0 MEANS ALL DONE
	BR	10$		;RESUME		

70$:	ERF	<"EOF in VERIFY">

.DSABL	LSB
GLOBAL	<I.DSQ,CURFBN,CBADI>

.SBTTL	BBINSV - HANDLE AN INPUT SAVE VOLUME BAD BLOCK

;+
; BBINSV - HANDLE AN INPUT SAVE VOLUME BAD BLOCK
;
;	CALL:	PCS    = SAVE VOLUME PCS
;		PCNRD  = # PCN'S WE TRIED TO READ
;		TMPFBN = FIRST FBN WE TRIED TO READ TO
;		TMPCBO = CURRENT BAD BLOCK POINTER PRIOR TO READ ATTEMPT
;		CALL	BBINSV
;
;	RETURN:	C=0 - WE'RE FINISHED BUFFER FILL
;		IT MAY HAVE SOME BAD BLOCKS IN IT BUT THESE WILL RESULT IN
;		BAD COMPARES
;		C=1 - MUST RESUME BUFFER FILL
;		TMPWRD = NEW # WORDS TO TRANSFER
;		CURFBN = NEW FBN TO DO I/O FROM
;		R1     = WORD COUNT
;-

.ENABL	LSB

BBINSV:	REGSCR			;SAVE REGISTERS
	CALL	ERINFO		;GET SOME ERROR INFORMATION
	MOV	NEWOBB,R1	;POINTER TO NEW BB LIST
	CMP	R1,CNBBO	;ARE THERE ANY NEW BAD BLOCKS ?
	BEQ	40$		;NO - THIS IS A NEW ONE
10$:	CMP	(R1)+,CURFBN	;FBN LSB EQUAL ?
	BNE	20$		;NO - THIS IS NOT IT
	CMP	(R1)+,CURFBN+2	;FBN MSB EQUAL ?
	BNE	30$		;NO - THIS IS NOT IT
	CLR	R3		;FOUND IT - CLEAR BAD COUNT
	BR	40$		;AND GO REREAD INTO BUFFER

20$:	TST	(R1)+		;WE DIDN'T COMPARE THE MSB
30$:	CMP	R1,CNBBO	;AT END OF LIST ?
	BNE	10$		;NO - GO COMPARE AGAINST NEXT
40$:	ADD	#8.,CURFBN	;INCREMENT UP TO NEXT SC
	ADC	CURFBN+2
	TST	HALF		;BEEN HERE BEFORE?
	BNE	90$		;YES - SECOND HALF FAIL
	MOV	(PC),HALF	;HAVE FAILED ONCE THIS BUFFER FILL
	TST	R5		;SECOND HALF BUFFER FAIL ?
	BNE	90$		;YES - ALL DONE
	TST	R2		;PCS=16?
	BNE	50$		;NO
	MOV	#8.*256.,R1	;SET UP OUR WORD COUNT
	BR	60$

50$:	CMP	PCNRD,R2	;# OF PC'S WANTED <= 1/2 BUFFER?
	BLE	90$		;YES - HAVE ALL WE WANT
	ASL	R2		;# OF PCN'S/BUFFER
	SUB	R3,R2		;R2 = # PC'S LEFT TO GET
	MOV	R2,PCNRD	;NEW # PC'S TO READ
	MOV	PCSWDS,R1	;# WORDS/PC
	MUL	PCNRD,R1
	TST	R3		;REREAD WHOLE BUFFER?
	BEQ	70$		;YES - DON'T RESET BUFPTR
60$:	MOV	#BUFMID,BUFPTR	;POINT TO BUFFER MIDDLE
70$:	SEC			;MEANS RESUME BUFFER FILL
80$:	MOV	R1,TOS.R1(SP)	;REPLACE WORD COUNT
	RETURN

90$:	CLC			;ALL'S WELL
	BR	80$

.DSABL	LSB
GLOBAL	<NEWOBB,CNBBO,CURFBN>

.SBTTL	GETBOO - GET BOOT FOR SUBSEQUENT SAVE VOLUME

;+
; GETBOO - GET BOOT FOR SUBSEQUENT SAVE VOLUME
;
;	CALL:	NO SET UP NECESSARY
;		CALL	GETBOO
;
;	RETURN:	YOU GOT IT
;-

.ENABL	LSB

GETBOO:	MOV	#SATBUF+BUFBEG,R1	;POINT WHERE BOOT WILL GO
	CALL	GETDUM		;GET DUMMY DISK BOOT
	RETURN

.DSABL	LSB
GLOBAL	<SATBUF>

.SBTTL	BLDB - INVOKE BOOT PROCURER					;JDB010

;+
; BLDB  - THERE IS A NEARLY IDENTICAL ROUTINE IN DIALOG. CREATING	;JDB010
;	  THESE ALLOWED RE-CONSOLIDATION OF DSMNT1 AND DSMNT2 INTO	;JDB010
;	  DSMNT								;JDB010
;-

BLDB:	CALLRX	BLDB2	;INVOKE BLDB2 FOR SAVE TO GET BOOTS		;JDB010
BOOLR2::RETURN		;RETURN TO DIALOG/SAVE COMMON MOUNT CODE	;JDB010

.DSABL	LSB
GLOBAL	<BLDB2>


