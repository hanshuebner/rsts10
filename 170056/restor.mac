TITLE	RESTOR,<SAV/RES RESTORE>,0A,10-MAY-91,JBL/NMC

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	TRANSFER MACROS

.MACRO	I.MESS
	TMPORG	RESTXT
.NLIST	BEX
.ENDM	I.MESS

.MACRO	I.DATA
	TMPORG	RESCTL
.NLIST	BEX
.ENDM	I.DATA

.MACRO	I.ADDR
	TMPORG	RESADR
.NLIST	BEX
.ENDM	I.ADDR

.MACRO	DE2TBL	SYM,LEN,VAL=0,I=2	;MACRO DEFINES 'PAIRED' TABLES.
.IIF B	<SYM>	.ERROR	;NO NAME GIVEN FOR TABLE BEING DEFINED?
.IIF B	<LEN>	.ERROR	;ZERO LENGTH TABLE BEING DEFINED?
	TMPORG	RESADR
.EVEN
SYM:
	UNORG
.REPT	I
	TMPORG	RESCTL
	.EVEN
	$$$$$$=.
	.BLKW0	LEN,VAL
	UNORG
	TMPORG	RESADR
	.WORD	$$$$$$
	UNORG
.ENDR
.ENDM	DE2TBL

.SBTTL	MACROS

.MACRO	ERF	M
	 CALL	PRTERF
.IF NB	<M>
MESSAG	<M>
.IFF
.ERROR	;NO MESSAGE FOR ERF?
.ENDC
	 EXIT
.ENDM

.MACRO	WARN	M
.NLIST
	 CALL	WARN,R5
.IF	NB	M
	  .WORD	M
.ENDC
.LIST
.ENDM	WARN

.MACRO	MOVTXT	FROM,TO
.NLIST
	 CALL	MOVTXT,R5
	  .WORD	FROM
	  .WORD	TO
.LIST
.ENDM	MOVTXT

.MACRO	PRTID	C
.NLIST
.IF	NB	<C>
	MOV	C,R2		;SET UP FOR PRTNAM
.ENDC
	 CALL	PRTNAM		;PRINT THE ID
.LIST
.ENDM	PRTID

.MACRO	PRTIDC	C
.NLIST
	PRTID	C
	CALLX	TYPECR		; AND A <CR>
.LIST
.ENDM	PRTIDC

.MACRO	DECZER	C
.NLIST
.IF NB <C>
	MOVB	C,R0
.ENDC
	CALLX	DECZER
.LIST
.ENDM	DECZER

.MACRO	TYPDEV	C
.NLIST
.IF	NB	<C>
	MOV	C,R4		;SET UP FOR TYPING
.ENDC
	CALL	TYPDEV		;AND PRINT DEVICE/UNIT/COLON
.LIST
.ENDM	TYPDEV

.MACRO	PRDAYT	C
.NLIST
.IF NB <C>
	MOV	C,R0
.ENDC
	CALL	PRDAYT		;PRINT 'DAY-OF-WEEK, DD-MMM-YY'
.LIST
.ENDM	PRDAYT

.SBTTL	ORDER THE CSECTS
	DEFORG	RES		;CODE
	DEFORG	RESCTL		;DATA
	DEFORG	RESTXT		;RESTORE TEXT
	DEFORG	RESADR		;TABLE ADDRESSES
	ORG	RES		;RESTORE CSECT


.SBTTL	DATA AND TEXT

	I.MESS
	.ENABL	LC
RESMSG:	.ASCIZ	"RESTORE"
NORSAT:	.ASCIZ	"Can't read save volume SATT"<200>
	.EVEN
	UNORG

	I.DATA
REPABL:	.BLKW0		;DIRECTORY REPAIR ENABLE/DISABLE INDICATOR
	UNORG

.SBTTL	RESTORE

.ENABL	LSB

RESTOR::MOV	#RESMSG,RTNNAM	;SET UP 'RESTORE' AS ROUTINE NAME
	CALL	PRBEGC		;PRINT BEGIN MESSAGE AND CLEAR TOTALS, ETC.
	MOVB	SAVDEV,SAVBOO	;INDICATE THAT USER CAN ONLY BOOT FROM
				; NOW ON IF WE'RE RUNNING OFF A SAVE VOL.
	MOVB	SSVOL+SSHIDX,MAGTAP	;SET UP MAGTAPE INDICATOR
	CALL	SETCH2		;SET UP OUTPUT PCS
	CALL	PCSCON		;SET UP PCS CONSTANTS
	CALL	SETCH1		;SELECT THE SAVE VOLUME FOR I/O
	CLR	RELPTR		;CLEAR RELOCATION TABLE POINTER
	MOV	#BADRES,BREPTR	;POINT TO BEGINNING OF BADRES TABLE
	CALL	GETSAT		;GET THE SATT
	CALL	SETBF2		;SET UP SATBF2
	CLR	PCNUM		;WE WILL START WITH PC 0
	MOV	#ORGDSK,R5	;POINT TO ORIGINAL DISK TABLE
	MOV	ORGSZL(R5),R2	;ORIG. DISK SIZE (LSB)
	MOV	ORGSZM(R5),R3	;ORIG. DISK SIZE (MSB)
	MOVB	ORGPCS(R5),R1	;ORIG. DISK PCS TO R1
	MOV	MNTTBL+2,R5	;POINT TO THE OUTPUT MOUNT TABLE
	MOVB	MNTDCS(R5),R5	;GET DCS
	SUB	R5,R2		;SO WE CAN GET THE
	SBC	R3		; MAX PCN NUMBER
10$:	ASR	R1		;DIVIDE SIZE BY PCS
	BCS	20$
	ASR	R3		;SHIFT MSB
	ROR	R2		; BRING BITS TO LSB
	BR	10$

20$:	DEC	R2		;R2 = MAX PCN
	MOV	#1,R5		;R5 = BIT IN SATT BYTE
	MOVB	#DATBLK,RECTYP	;DATA RECORD TYPE (5)
	CALL	SAVD2F,R5,SSDAT	;SET UP CURFBN
	CLR	R3		;R3 = SATT BYTE POINTER
	CALL	PTRGET		;SAVE PTRS
30$:	CALL	GETSAV		;GET SOME STUFF FROM THE SAVE VOLUME
	BCS	90$		;SOME KIND OF VERY FATAL ERROR
	TST	DUMP		;SHALL WE PUT TO DISK ?
	BEQ	40$		;NO - WE'RE DONE
	CALL	PUTRST		;YES - PUT
	CALL	SETCH1		;RESET FOR SAVE VOLUME I/O
	BR	30$		;GO GET SOME MORE

40$:	BIT	#VE,SWTWRD	;VERIFY REQUESTED ?
	BEQ	50$		;NO
	CALL	VERRES		;DO RESTORE VERIFY
	BCS	80$
50$:	CALL	ACCUM		;ADD LAST VOLUME'S BLOCKS TO TOTAL
	CALL	FINRST		;CLEAN UP ERRORS
	MOV	(PC),INPUT	;INDICATE AN INPUT VOLUME
	CALL	DISMNT		;DISMOUNT SAVE VOLUME
	CALL	ENDOP		;PRINT ENDING MESSAGE (AND STATS)
60$:	TSTB	SAVDEV		;WERE WE BOOTED FROM A SAVE VOLUME
	BEQ	70$		;NOPE
	MESSAG	<<177><200><200><200>"*** Please Boot ">
	MESSAG	<"from the system disk"<200>>
70$:	CALLRX	SRDONE		;BACK TO ONLSAV OR INIT

80$:	MOV	(PC),ABTUSR	;WE WILL DIE DUE TO /NOERROR
90$:	CALL	CHKABT		;GO PRINT MESSAGE

.DSABL	LSB
GLOBAL	<BADRES,BREPTR,RTNNAM,PCNUM,HIGHBF,ORGDSK>
GLOBAL	<MNTTBL,SSVOL,SWTWRD,SAVBOO,SAVDEV>

.SBTTL	GETSAT - READ IN THE SATT

;+
; GETSAT - READ IN THE SATT FROM A SAVE VOLUME
;
;	CALL	GETSAT
;
;	RETURNS ONLY IF SATT (OR 2ND COPY) HAS BEEN READ IN
;-

.ENABL	LSB

GETSAT::REGSCR			;SAVE REGISTERS
	MOVB	#SATTS,RECTYP	;SATT RECORD TYPE (4)
	CLR	R0		;CLEAR ERROR INDICATOR
	MOVB	SSVOL+SSHIDX,R1	;MAGTAPE?
	BNE	80$		;YES - GO SETUP TAPE
	MOV	#SSSAT1,20$	;GET DCN OF FIRST COPY OF SATT
10$:	CALL	SAVD2F,R5	;SET UP CURFBN
20$:	  .WORD	0		;SSVOL OFFSET
30$:	MOV	#BUFBEG,BUFPTR	;POINT TO BEGINNING OF IOBUFF
	MOV	#4096.,I.DSQ+DSQCNT	;SATT IS 4096. WORDS LONG
	CALL	SAVIO,R5,RFUN	;READ THE SATT
	  BR	120$		;BAD MAGTAPE RECORD
	  BR	90$		;BAD BLOCK ERROR
	  BR	60$		;EOF ERROR
	  TSTB	R1		;SAVE VOLUME MAGTAPE ?
	BEQ	50$		;NO - IT'S DISK
	MOV	#1,R5		;WILL DO AT LEAST ONE ADVANCE
	BIT	#2,R0		;DID WE GET A BAD BLOCK ERROR ?
	BNE	40$		;YES - ONLY DO ONE ADVANCE
	INC	R5		;NO - PASS TWO EOF'S
	ADD	#16.,CURFBN	; MAKE SURE CURFBN POINTS TO DATA
40$:	CALL	ADVEOF		;DO ADVANCE
	BCS	110$		;ABORT IF ERROR
50$:	CALLR	IO2SAT		;MOVE SATT TO SATBUF AND RETURN

60$:	TSTB	R1		;SAVE VOLUME MAGTAPE ?
	BEQ	110$		;NO - WE REALLY SHOULDN'T BE HERE
	BIT	#1,R0		;HAVE WE ALREADY GOTTEN A BAD REC ERROR ?
	BNE	110$		;YES - DIE
70$:	BIS	#1,R0		;WE'VE GOT A BAD REC/EOF ERROR
80$:	CALL	REWIND		;DO IT
	MOV	#3,R5		;SETUP FOR ADVANCE
	MOV	#16.,CURFBN	;RECNO 16. IS  SATT 1
	BR	100$		;GO TRY AGAIN

90$:	BIT	#2,R0		;HAVE WE ALREADY GOTTEN A BAD BLK ERROR ?
	BNE	110$		;YES - DIE
	BIS	#2,R0		;WE'VE GOT A BAD BLOCK ERROR
	MOV	#SSSAT2,20$	;GET OFFSET OF DCN OF SATT COPY 2
	TSTB	R1		;SAVE VOLUME MAGTAPE ?
	BEQ	10$		;NO - GO UP TO RETRY
	MOV	#32.,CURFBN	;RECNO 32. IS SATT 2
	MOV	#1,R5		;DO ONE ADVANCE UP TO NEXT SATT
100$:	CALL	ADVEOF		;DO ADVANCE
	BCC	30$		;GO RETRY
110$:	MOV	#NORSAT,ABTADR	;%%% CAN'T READ SATT OFF SAVE VOLUME
120$:	CALL	CHKABT		;CHECK FOR FATAL ERROR

.DSABL	LSB
GLOBAL	<SSVOL,I.DSQ,CURFBN>

.SBTTL	GETSAV - GET FROM A SAVE VOLUME (RESTORE)

;+
; GETSAV - FILL IOBUFF WITH SAVE VOLUME CLUSTERS
;
;	CALL:	PCNUM  = # OF FIRST PCN TO TRY
;		PCNRD  = ASSUMED TO BE ZERO
;		BUFPTR = ASSUMED TO POINT TO BEGINNING OF IOBUFF
;		R2     = # OF SATT BITS YET TO CHECK
;		R3     = CURRENT SATT BYTE POINTER
;		R5     = BIT IN BYTE
;		R4     = ASSUMED TO POINT TO WHERE PCN'S ARE TO BE STORED
;		CURFBN = NEXT SAVE VOLUME FBN/RECNO TO READ
;
;		CALL	GETSAV
;
;	RETURN:	C=1 - UNKNOWN INPUT BAD BLOCK HIT AND EITHER WE'VE HIT
;		      THE RSTS LIMIT OR /NOERROR WAS SPECIFIED
;					OR
;		      WE COULDN'T MOUNT THE NEXT REQUIRED VOLUME
;		C=0 - DUMP INDICATES IF THE BUFFER HAS ANYTHING IN IT
;		      PCNRD IS THE NUMBER OF PC'S IN IT (IF DUMP<>0)
;-

.ENABL	LSB

GETSAV::TST	R2		;ANYTHING LEFT TO GET ?
	BEQ	60$		;NO - GET OUT WITHOUT SETTING DUMP
	CLR	HALF		;CLEAR BUFFER HALF INDICATOR
	CALL	XFRFIL		;FILL THE XFRPCN TABLE WITH ALLOCATED PC'S
	MOV	PCNRD,-(SP)	;SAVE COUNT READ
	BEQ	40$		;DIDN'T GET ANY
10$:	MOV	PCSWDS,R1	;GET PCS*256.
	MUL	PCNRD,R1	;*PCNRD=# WORDS IN BUFFER
20$:	CALL	GETSET		;READY ... GET SET ...
	CALL	SAVIO,R5,RFUN	;GET SOME DATA
	  BR	70$		;BAD MAGTAPE RECORD
	  BR	80$		;BAD BLOCK
	  BR	100$		;EOF ERROR
30$:	  MOV	(PC),DUMP	;INDICATE WE GOT SOMETHING
40$:	CLC
50$:	MOV	(SP)+,PCNRD	;RESTORE COUNT
60$:	RETURN

70$:	CALL	CHKABT		;CHECK FOR FATAL ERROR
80$:	CALL	BBINSV		;HANDLE BAD BLOCK
	BIT	#NOER,SWTWRD	;/NOERROR SPECIFIED ?
	BEQ	90$		;NO
	MOV	(PC),ABTUSR	;ABORT PER USER REQUEST
	BR	70$		;GO DIE

90$:	BCS	20$		;RESUME BUFFER FILL
	BR	30$		;EXIT SUCCESSFUL

100$:	TST	VFY		;DOING A VERIFY ?
	BEQ	110$		;NO
	JMP	EOFERF		;'EOF IN VERIFY PASS'

110$:	BIT	#VE,SWTWRD	;VERIFY SPECIFIED ?
	BEQ	120$		;NO
	CALL	VERRES		;DO RESTORE VERIFY
	BCS	50$
120$:	CALL	ACCUM		;ADD VOLUME BLOCKS TO TOTAL
	CALL	MNTNXT		;MOUNT THE NEXT VOLUME
	BCS	50$		;COULDN'T MOUNT IT - DIE
	CALL	SAVD2F,R5,SSDAT	;GET CORRECT START POINT FOR DATA TRANSFER
	CALL	PTRGET		;SAVE PTRS
	MOV	XFRPCN,VERBLK	;FIRST PCN ON NEXT VOLUME
	CALL	PRBEG		;PRINT NEW START BLURB
	BR	10$		;RESUME

.DSABL	LSB
GLOBAL	<XFRPCN,PCSWDS,SWTWRD>

.SBTTL	BBINSV - HANDLE AN INPUT SAVE VOLUME BAD BLOCK

;+
; BBINSV - HANDLE AN INPUT SAVE VOLUME BAD BLOCK
;
;	CALL:	PCS    = SAVE VOLUME PCS
;		PCNRD  = # PCN'S WE TRIED TO READ
;		TMPFBN = FIRST FBN WE TRIED TO READ TO
;		TMPCBO = CURRENT BAD BLOCK POINTER PRIOR TO READ ATTEMPT
;		CALL	BBINSV
;
;	RETURN:	C=1 - RESUME BUFFER FILL
;		C=0 - FINISHED BUFFER FILL
;			R1 = NEW WORD COUNT
;-

.ENABL LSB

BBINSV::REGSCR			;SAVE REGISTERS
	CALL	ERINFO		;GET ERRO INFORMATION
	TST	VFY		;DOING A VERIFY ?
	BNE	60$		;YES - SKIP MOST OF THIS
	MOV	R3,-(SP)	;SAVE # OF BAD PCN'S
	CALL	PRTBBI		;'%%% BAD BLOCK ON INPUT'
	MESSAG	<", output PCN">
	MOV	R3,R0		;1 OR MORE PCN'S?
	CALL	PLURAL		;PRINT/NO PRINT AN 'S'
	MESSAG	<" affected: ">
	CMP	R3,#8.		;ROOM ON SAME LINE?
	BLT	10$		;YUP
	CALLX	TYPECR
10$:	MOV	BREPTR,R1	;POINTER TO BADRES FILE
	BR	30$		;START PCN PRINT OUT AD BADVER TABLE LOAD

20$:	MESSAG	<", ">		;COMMA, SPACE
30$:	CMP	R1,#BREEND	;HAVE WE FILLED THE BADRES FILE ?
	BHIS	40$		;YES - DON'T PUT ANYTHING ELSE IN IT
	MOV	(R4),(R1)+	;MOVE BAD PCN INTO BADRES TABLE
40$:	MOV	(R4)+,R0	;GET IT INTO R0
	CALLX	DECZER		;PRINT IT
	SOB	R3,20$		;DO FOR ALL BAD PCN'S
	CALLX	TYPECR		;NEW LINE
	MOV	(SP)+,R3	;RESTORE # BAD PCN'S
	ADD	R3,UNKBBI	;ADD IN NEW ENTRIES
	CMP	UNKBBI,#BRELEN/2 ;MORE THAN THE FILE CAN HOLD ?
	BLE	50$		;NO - THEY'RE IN THE FILE
	CALL	JPERC		;<200>'%%% '
	MESSAG	<"Some affected files">
	CALLX	MESSAG,R5,NOREP	;'WILL NOT BE REPORTED'<200>
50$:	MOV	R1,BREPTR	;NEW BADRES POINTER
60$:	ADD	#8.,CURFBN	;UP TO NEXT SAVE CLUSTER FBN
	ADC	CURFBN+2
	TST	HALF		;BEEN HERE BEFORE?
	BNE	90$		;YES
	MOV	(PC),HALF	;INDICATE WE'VE BEEN HERE
	TST	R5		;SECOND HALF BUFFER FILL FAIL ?
	BNE	90$		;YES - WE'VE GOT WHAT WE WANT - GET OUT
	TST	R2		;PCS=16. ?
	BNE	70$		;NO
	MOV	#8.*256.,R1	;SET UP WORD COUNT
	BR	80$

70$:	CMP	PCNRD,R2	;# PC'S WANTED < OR = 1/2 A BUFFER ?
	BLE	90$		;YES - WE'VE GOT WHAT WE WANT - GET OUT
	ASL	R2		;R2 = # PCN'S/BUFFER NOW
	SUB	R3,R2		;COMPUTE # PC'S WE NEED TO FILL QUOTA
	MOV	R2,PCNRD	;NEW # OF PCN'S TO READ
	MOV	PCSWDS,R1	;SET UP THE
	MUL	PCNRD,R1	; PROPER WORD COUNT
80$:	MOV	#BUFMID,BUFPTR	;WE WILL READ INTO MIDDLE OF BUFFER
	BR	100$		;NEED TO RESUME BUFFER FILL

90$:	TST	(PC)+
100$:	SEC
	MOV	R1,TOS.R1(SP)	;REPLACE WITH NEW WORD COUNT
	RETURN

GLOBAL	<BREPTR,BRELEN,BREEND,UNKBBI,CURFBN,PCSWDS>
.DSABL	LSB

.SBTTL	VERRES - RESTORE VERIFY

;+
; VERRES - RESTORE VERIFY MAINLINE
;
;	CALL:	VERBLK SET UP
;		R3 = CURRENT SATT BYTE POINTER
;		R5 = CURRENT SATT BIT IN BYTE
;		PCNUM = NEXT PCN TO XFER
;		CALL	VERRES
;
;	RETURN:	ENTRIES IN BADVER IF ANY BAD COMPARES
;-

.ENABL	LSB

VERRES::REGSCR			;SAVE REGISTERS
	MOV	BUFPTR,-(SP)	;SAVE BUFFER POINTER
	MOV	#VEMSG,RTNNAM	;'VERIFY PASS'
	CALL	SETREL		;SET UP RELOCATION COUNT
	MOVB	SSVOL+SSHIDX,R1	;SAVE VOLUME MAGTAPE ?
	BEQ	10$		;NO
	CALL	REWIND		;DO REWIND
10$:	CALL	PRBEG		;PRINT START VERIFY MESSAGE
	TSTB	R1		;SAVE VOLUME MAGTAPE ?
	BEQ	30$		;NO
	MOV	#3,R5		;SET UP FOR ADVANCE FUNCTION
	CMPB	#1,SSVOL+SSSEQ	;IS THIS THE FIRST SAVE VOLUME ?
	BNE	20$		;NO
	CMPB	(R5)+,(R5)+	;YES - MUST SKIP 5 EOF'S
20$:	CALL	ADVEOF		;DO ADVANCE
	BCS	100$		;EOT - VERY BAD
30$:	CALL	PTRSAV,R5	;SAVE PCNUM/CBADI/CBADO/CURFBN
	CALL	SELEC1		;SELECT SAVE VOLUME
	CALL	SRVINI		;DO INITIALIZATION
40$:	CALL	SETCH1		;I/O TO SAVE VOLUME
	CALL	GETSAV		;FILL IOBUFF WITH SAVE VOLUME CLUSTERS
	TST	DUMP		;DID WE GET ANYTHING ?
	BEQ	60$		;NO - ALL DONE
	CALL	SETCH2		;I/O/WC TO RSTS DISK
	TST	(R4)		;FIRST PCN=0 ?
	BNE	50$		;NO
	DEC	PCNRD		;YES - MAKE THAT ONE LESS PC READ
	BEQ	40$		;NOTHING LEFT IN THIS BUFFER - FORGET IT
	TST	(R4)+		;UP TO NEXT PCN IN LIST
	MOV	PCSWDS,R1	;# WORDS/PCS
	ASL	R1		;# BYTES/PCS
	ADD	R1,BUFPTR	;POINT PAST PCN 0
50$:	CALL	COMPAR		;COMPARE PC'S
	BCS	80$
	BR	40$		;GO GET MORE FROM SAVE VOLUME

60$:	CALL	PRTDIF		;PRINT # OF DIFFERENCES
70$:	CLR	VFY		;CLEAR VFY
80$:	CALL	PTRRES,R5	;RESTORE PCNUM/CBADI/CBADO/CURFBN
	MOV	#RESMSG,RTNNAM	;BACK TO 'RESTORE'
	MOV	(SP)+,BUFPTR	;RESTORE BUFFER POINTER
90$:	RETURN

EOFERF:
100$:	ERF	<"VEOF">	;EOF IN VERIFY

.DSABL	LSB
GLOBAL	<SSVOL,RTNNAM,PCSWDS>

.SBTTL	REPDIR - REPLACE BAD DIRECTORY CLUSTERS

;+
; REPDIR - REPLACE BAD DIRECTORY CLUSTERS WHICH ARE THE RESULT OF A BAD
;	   INPUT READ OR A BAD COMPARE
;
;	CALL:	R3     = BAD PACK CLUSTER
;		NDBS   = NUMBER OF DIRECTORY CLUSTERS ALREADY CHECKED
;		PCS    = SAVE VOLUME PCS
;		CURFBN = FBN OF FIRST BLOCK OF DIRECTORY CLUSTERS ON
;			 SAVE VOLUME
;		CBADI  = CURRENT BAD BLOCK TO CHECK AGAINST
;		CALL	REPDIR
;
;	RETURN:	C=0 - BAD CLUSTER HAS BEEN SUCCESSFULLY REPLACED
;		C=1 - BAD CLUSTER HAS NOT BEEN REPLACED AND IS THEREFORE
;		      STILL BAD
;-

.ENABL	LSB

REPDIR::REGSCR			;SAVE REGISTERS
	TST	REPABL		;IS DIRECTORY REPAIRING ENABLED ?
	BNE	80$		;NO - EXIT W/ CARRY SET
	MOV	NDBS,R1		;GET RELATIVE NUMBER OF BAD DIRECTORY BLOCK
	INC	R1		;MAKE IT IN RANGE 1.- 8.
	CLR	R0		;FOR DIVIDE
	DIV	#8.,R0		;COMPUTE RELATIVE SAVE CLUSTER NUMBER & BLOCK
				; WITHIN CLUSTER
	MOV	R0,R5		;COPY CLUSTER NUMBER
	ASH	#3,R0		;MAKE R0 RELATIVE BLOCK NUMBER ON SAVE
				; CLUSTER BOUNDARY
	MOV	CURFBN,R2	;GET FIRST DIRECTORY BLOCK
	MOV	CURFBN+2,R3
	ADD	R0,R2		;ADD IN RELATIVE BLOCK NUMBER
	ADC	R3
10$:	CALL	SETCH1		;SET UP FOR SAVE CHANNEL I/O
	TSTB	SSVOL+SSHIDX	;IS IT MAGTAPE ?
	BNE	40$		;YES
20$:	MOV	CBADI,R4	;SAVE CURRENT BAD BLOCK POINTER
	CALL	CHKSBA		;SEE IF OUR FBN IS OK
	BCS	90$		;EOF
	MOV	CBADI,R5	;GET NEW CURRENT BAD BLOCK POINTER
	SUB	R4,R5		;COMPUTE NUMBER OF BAD BLOCKS FOUND
	ASR	R5
	BNE	30$		;WE FOUND SOME
	MOV	R2,CURFBN	;NONE FOUND - WE HAVE OUR FBN
	MOV	R3,CURFBN+2
	BR	50$		;ON WITH IT

30$:	MUL	#8.,R5		;THE REAL FBN IS BUMPED BY THE FOUND
				; BAD BLOCKS
	ADD	R5,R2		;BUMP IT
	ADC	R3
	BR	20$		;TRY THE NEW ONE

40$:	MOV	R2,CURFBN	;UPDATE THE CURRENT FBN
	MOV	R3,CURFBN+2
	CALL	SKPREC		;SKIP UP TO DESIRED CLUSTER
	BCS	90$		;EOT OR HUNG DEVICE

50$:	MOV	R1,R3		;GET BLOCK WITHIN SAVE CLUSTER
	ADD	#7,R1		;COMPUTE # BLOCKS TO GET (8. OR 16.)
	ASH	#-3,R1		; = ((R1 + 7.) / 8.) * 8.
	ASH	#3,R1
	MUL	#256.,R1	;COMPUTE # WORDS TO GET
	MOV	R1,R0		;SAVE # WORDS IN CASE OF EOF
60$:	CALL	GETSET		;GET WORD COUNT & SAVE CURFBN/CBADI
	MOVB	#DIRBLK,RECTYP	;WE WANT A DIRECTORY BLOCK
	CLR	R4		;INDICATE I/O IN PROGRESS FOR ERROR RECOVERY
	MOVB	#1,HIGHBF	;I/O TO IOBUFF
	CALL	SAVIO,R5,RFUN	;READ FROM SAVE VOLUME
	  BR	100$		;BAD MAGTAPE RECORD
	  BR	80$		;BAD BLOCK
	  BR	90$		;EOF
	  MOV	R3,R1		;COPY BLOCK WITHIN SAVE CLUSTER
	MOV	TOS.R3(SP),R3	;GET BAD BLOCK PCN
	CALL	SCNREL		;SEE IF IT WAS RELOCATED
	BCC	70$		;NOPE
	MOV	NEWPCN,R3	;YUP - GET PCN IT WAS RELOCATED TO
70$:	CALL	SETCH2		;SET RSTS CHANNEL
	MOV	R3,R2		;CN2SEG WANTS PCN IN R2
	MUL	#512.,R1	;RELATIVE BYTE OF BLOCK BEGINNING
	ADD	R1,BUFPTR	;POINT TO BEGINNING OF PC
	CALLX	CN2SEG		;GET AN FBN INTO R2/R3
	MOV	PCSWDS,R1	;# WORDS/PACK CLUSTER
	CALL	WDSKIO,R5	;WRITE THE PACK CLUSTER TO DISK
	  BR	80$		;BAD BLOCK
	  CLR	NDBS		;RESET RELATIVE DIRECTORY BLOCK NUMBER
	TST	(PC)+		;GOOD EXIT
80$:	SEC			;ERROR EXIT
	RETURN

90$:	CALL	MNTNXT		;MOUNT THE NEXT VOLUME OF SET
	BCS	100$		;FAILURE ON MOUNT - NO GOOD
	TST	R4		;WHERE DID WE FAIL ?
	BNE	10$		;DURING INITIAL SET-UP
	CALL	SAVD2F,R5,SSDIR	;SET UP CURFBN FOR DIR. BLK. I/O
	MOV	R0,R1		;GET BACK # WORDS TO GET
	BR	60$		;RESUME I/O TO SAVE VOLUME

100$:	MOV	(PC),REPABL	;DISABLE DIRECTORY REPAIRING
	BR	80$		;EXIT WITH ERROR

.DSABL	LSB
GLOBAL	<CURFBN,SSVOL,CBADI,HIGHBF,PCSWDS>

.SBTTL	IO2SAT - TRANSFER BETWEEN SATBUF AND IOBUFF

;+
; IO2SAT - MOVE R2 WORDS FROM IOBUFF TO SATBUF
;
;	CALL:	R2 = # WORDS TO TRANSFER
;		CALL	IO2SAT
;
;	RETURN:	IT HAS BEEN MOVED
;-

.ENABL	LSB

IO2SAT::CLR	-(SP)		;WHERE THE OFFSET WORD WILL GO
	MOV	#4095.*2.,R2	;COMPUTE BYTE OFFSET TO START MOVE
	MOV	R2,R3		;COPY IT
	ADD	#BUFBEG,R3	;R3 IS IOBUFF OFFSET
10$:	MOV	R3,(SP)		;THE OFFSET
	CALL	GETIOB		;GET IT
	MOV	(SP),SATBUF(R2)	;PUT IT IN SATBUF
	CMP	-(R2),-(R3)	;BACK A WORD
	TST	R2		;FINISHED ?
	BGE	10$		;NOT YET
	TST	(SP)+		;YES - POP OFF THE OFFSET
	RETURN

.DSABL	LSB
GLOBAL	<SATBUF>

.SBTTL	SAVD2F - CONVERT DCN FROM SSVOL TABLE INTO SAVE VOLUME FBN

;+
; SAVD2F - CONVERT DCN FROM SSVOL TABLE INTO SAVE VOLUME FBN
;
;	CALL:	DCS = SAVE VOLUME DCS
;		CALL	SAVD2F,R5,<SSVOL OFFSET>
;
;	RETURN:	FBN IS IN CURFBN
;-

.ENABL	LSB

SAVD2F::MOV	R2,-(SP)	;SAVE R2
	MOV	R3,-(SP)	;SAVE R3
	MOV	(R5)+,R2	;GET SSVOL OFFSET
	TSTB	SSVOL+SSHIDX	;SAVE VOLUME MAGTAPE ?
	BNE	10$		;YUP - GET OUT
	MOV	SSVOL(R2),R2	;GET THE DCN
	CALLX	CNVRIB		;CONVERT IT TO AN FBN
	MOV	R2,CURFBN	;GET THE FBN INTO CURFBN
	MOV	R3,CURFBN+2
	BR	20$		;GET OUT

10$:	MOV	(PC),SSVOL(R2)	;INSURE WORD <>0 FOR TAPE
20$:	MOV	(SP)+,R3	;RESTORE R3
	MOV	(SP)+,R2	;RESTORE R2
	RETURN	R5

.DSABL	LSB
GLOBAL	<SSVOL,CURFBN>

.SBTTL	GETSET - GET WORD COUNT & SAVE CURFBN/CBADI

GETSET::MOV	R1,I.DSQ+DSQCNT	;THE WORD COUNT
	MOV	CURFBN,TMPFBN	;SAVE CURRENT FBN
	MOV	CURFBN+2,TMPFBN+2
	MOV	CBADI,TMPCBO	;SAVE CURRENT INPUT BAD BLOCK
	RETURN




.SBTTL	MNTNXT - MOUNT THE NEXT INPUT SAVE VOLUME

;+
; MNTNXT - MOUNT THE NEXT INPUT SAVE VOLUME
;
;	CALL	MNTNXT
;
;	RETURN:	C=0 - MOUNT SUCCESSFUL
;		C=1 - COULDN'T MOUNT THE VOLUME
;-

MNTNXT::MOV	(PC),INPUT	;WE WANT AN INPUT VOLUME
	CALL	DISMNT		;DISMOUNT THE ONE CURRENTLY MOUNTED
	CALL	MOUNT		;MOUNT NEXT
	BCS	10$		;PROBLEM
	CALL	SETBF2		;RE-SETUP SATBF2
	TSTB	SSVOL+SSHIDX	;SAVE VOL MAGTAPE?
	BEQ	10$		;NO
	MOV	R5,-(SP)	;SAVE R5
	MOV	#1,R5		;PREPARE TO ADVANCE PAST EOF
	CALL	ADVEOF		;DO SO
	MOV	(SP)+,R5	;RESTORE R5
10$:	RETURN

GLOBAL	<I.DSQ,CURFBN,CBADI,SSVOL>

.SBTTL	REPSET - SET UP TO REPAIR DIRECTORIES

;+
; REPSET - SET UP TO CORRECT DIRECTORIES
;
;	CALL	REPSET
;
;	WILL DIE IF THERE IS A PROBLEM
;-

.ENABL	LSB

REPSET::CLR	REPABL		;ENSURE DIRECTORY REPAIRING IS ENABLED
	CLR	NDBS		;RELATIVE DIRECTORY BLOCK NUMBER
	CALL	SETREL		;SET UP RELCNT FOR SCNREL
	MOV	#BADRES,R5	;POINT TO BADRES TABLE
	MOV	UNKBBI,R0	;NUMBER OF ENTRIES IN BADRES
	BEQ	30$		;WEREN'T ANY
10$:	MOV	(R5)+,R3	;GET A BAD PCN
	CALL	SCNREL		;WAS IT RELOCATED ?
	BCC	20$		;NO
	MOV	NEWPCN,-2(R5)	;YES - GET WHERE WAS RELOCATED TO
20$:	SOB	R0,10$		;DO FOR ALL ENTRIES IN BADRES
30$:	CALL	SAVD2F,R5,SSDIR	;GET READY FOR DIRECTORY BLOCK I/O
	TSTB	SSVOL+SSHIDX	;SAVE VOLUME MAGTAPE ?
	BEQ	40$		;NO
	MOV	#1,R5		;WILL ADVANCE PAST ONE EOF
	CALL	ADVEOF		;DO IT
	BCC	40$		;SUCCESSFUL
	ERF	<"REPSET">	;REPSET (SCNDIR) TAPE ERROR
40$:	RETURN

.DSABL	LSB
GLOBAL	<SSVOL>

.SBTTL	DUMMY ROUTINES

.ENABL	LSB

BBSORT:	MOV	BADBO,R0	;GET BB TABLE ADDRESS
	CALL	WSORT		;RESTORE USES ONLY WSORT - W2SORT NOT USED
BBINRS:	RETURN

ALLOC:
INIDEV:
KWNCHK:
OUTMNT:	JMP	ILLCAL		;ILLEGAL CALL - GO DIE

.DSABL	LSB
GLOBAL	<BADBO>


