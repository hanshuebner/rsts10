.INCLUDE	/CMN:COMMON.MAC/
.INCLUDE	/CMN:KERNEL.MAC/
.LIBRARY	/CUI:CUIMAC.MLB/
.LIBRARY	/DCL:DCLMAC.MLB/
.NLIST
.INCLUDE	/CMN:PFBDEF.MAC/
.INCLUDE	/DCL:DCLPFX.MAC/
.LIST
TITLE	DCLCMD,<DCL Command Definitions>,0B,21-JUN-91,CEK/JFM/SDL/GMB/BGN/BTK/BTB

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR DCLCMD
;+
;  001	CEK  16-APR-82	Added edit history
;  002	CEK  16-APR-82	Removed @# notation
;  003	CEK  16-APR-82	Use addresses rather than offsets for PPARSE variables
;  004	CEK  16-APR-82	Changed ORG statements
;  005	CEK  15-May-82	Removed /RMS:FA from translation of TYPE command
;  006	CEK  25-May-82	Added /VK100 qualifier for SET TERM
;  007	CEK  07-Jun-82	Made PRINT rely on QUE's default queue.
;  008	CEK  07-Jun-82	Fixed bug in lookup of macro libs in MACRO command.
;  009	CEK  07-Jun-82	Added time selection qualifiers to COPY, REN, APPEND,
;			SET PROT, TYPE
;  010	CEK  14-Jun-82	Made EDIT verify existence of file if /[NO]OUTPUT
;  011	CEK  22-Jun-82	Moved parsing of DCL and $ prefix to this module.
;  012	CEK  07-Jul-82	Made use of REQUIRE= construct
;  013	CEK  07-Jul-82	Removed FORTRAN-IV-PLUS
;  014	CEK  16-Jul-82	Fixed bug where DIRECTORY sometimes defaults to DK:
;  015	JFM  05-Aug-82	Added C81 qualifiers /SHOW, /TRUNCATE, ...
;  016	JFM  15-Aug-82	Added LINK qualifiers /OTS, /RMS, /FMS, /DEBUG
;  017	JFM  31-Aug-82	Added INITIALIZE qualifiers /EXERCISE, /OWNER ...
;  018	JFM  15-Sep-82	Added /DESCRIPTION qualifier for LINK
;  019	JFM  20-Sep-82	Added MOUNT qualifiers - for disks, invokes ONLCLN
;  020  CEK  30-Sep-82	Changed $FETPV to $FETNP, Cheanged DF NEW conditionals
;  021	JFM  05-Oct-82	Added DEFARG construct to all keywords and arguments
;  022	JFM  15-Oct-82	Added START and STOP commands. RSTS/A Spooler
;  023	JFM  15-Oct-82	Changed RSTS/A DELETE/ENTRY, DELETE/JOB, INIT/PRINTER,
;			and PRINT since new spooler parses it's owm command.
;  024	JFM  20-Oct-82	Added new F77 switches /STANDARD, /EXTEND, /DEBUG, /OPT
;  025	JFM  27-Oct-82 	Utilized $FETCS -Fetch Command String,new splr commands
;  026	JFM  27-Oct-82	Changed qualifier and parameter TYPE names to U$ form
;  027	JFM  28-Oct-82	Made DCL understand QUEUE compatable jobspec syntax 
;  028	JFM  22-Nov-82  Added INIT/DEVICE, DEL/DEVICE and /PRINTER splr quals
;  029	JFM  05-Dec-82	Modularized entire DCLCMD into individual files, see 
;			FILES.TXT for locations.
;  030	JFM  05-Dec-82	Removed tags, put them into DCLPFX.
;				[ V8.0 ]
;  031	JFM  04-Apr-83	Added conditional code to TITLE statement.
;  032	JFM  18-Apr-83	Added SORT and MERGE commands.
;  033	JFM  11-May-83	Moved SUBMIT into a .IF, took out GLOBAL (ONKEY) TAGs
;				[ V9.0 ]
;  034  SDL  05-Aug-83  Add parsing of labels and assignment statements
;  035  SDL  21-Oct-83  Disallow spaces in labels between name and colon  
;  036  SDL  24-Oct-83  Added call to apostrophe and iterative substitution
;  037  SDL  01-Nov-83  Added call to command synonym substitution
;  038  JFM  04-Nov-83  Made changes to PARASG 
;  039	JFM  23-Nov-83  Made DCLA commands truly DCLA, changed SHOW & SET TERM
;  040	JFM  03-Dec-83  ?Invalid command now repaints line
;  041  SDL  19-Dec-83  Modified PARASG to check for invalid and reserved 
;                       symbol names
;  042  SDL  03-Jan-84  Bypass command synonym substitution conditionally
;  043  SDL  10-Jan-84  Added APOSUB and CMDSUB routines from DCLCFP
;  044  SDL  11-Jan-84  Added IF and GOTO commands
;  045  JFM  12-Jan-84  Keyword "DCL" goes away
;  046  SDL  01-Feb-84  Allowed for an asterick as an abbreviation character
;			in symbol assignments
;  047	JFM  18-Mar-84  Added Version to edit history, CCL flag clear if "$"
;  048  SDL  19-Mar-84  Added EXIT, STOP and some additional SET commands
;  049  SDL  21-Mar-84  Checked for EOF or other error conditions when reading 
;			commands from an Indirect Command File
;  050	SDL  26-Apr-84	Fixed bug in apostrophe substitution when the symbol
;			is equated to a null string
;  051	SDL  26-Apr-84	Added the SET [NO]ON, SET [NO]CONTROL_C and ON ... THEN
;			commands
;  052	JFM  08-May-84  Removed references to RSTSA
;  053	JFM  26-Jun-84  Added new commands to dispatch to PBS (SPL.CMD)
;  054	SDL  29-Jun-84	Fixed various bugs relating to error cases on symbol
;			assignments
;  055	SDL  03-Jul-84	Fixed bug in apostrophe substitution when the symbol
;			has an integer value 
;  056	JFM  08-Jul-84  Removed SET [NO]LOGINS, HOLD, and RELEASE commands
;  057	SDL  09-Jul-84	Restrict the number of IF ... THEN ... clauses allowed
;			on one command line, to avoid a stack overflow error
;  058	SDL  13-Jul-84	Require a command line which contains a label to
;			begin with a dollar sign
;  059	SDL  26-Jul-84	Added CHKSN routine by removing code from PARASG so
;			the INQUIRE command can call it also
;  060	JFM  30-Jul-84	Removed reference to SEPA.CMD
;  061	JFM  08-Aug-84	Changed UTLMGR command syntax, added SHOW commands
;  062	SDL  14-Aug-84	Fix problem in an assignment statement when specifying
;			an abbreviation point
;  063	SDL  01-Oct-84	Restricted use of symbol name abbreviations to command
;			synonym substitution and removed from apostrophe subst.
;  064	SDL  19-Oct-84	Performed apostrophe substitution again after command
;			synonym substitution took place on the command line
;  065	GMB  29-Oct-84	Added support for $STATUS transparent commands
;  066	SDL  13-Nov-84	Saved some words in APOSUB and CMDSUB subroutines
;  067	JFM  14-Dec-84	Fixed SET VERIFY/DEBUG, got rid of DISPLY bit in ICFFLG
;  068  GMB  02-Sep-86	Added SHOW DEVICE/ALL to go to UTLMGR
;
;			[V9.4]
;  069  GMB  19-Feb-87	Added GOSUB & RETURN
;			Changed PARDOL to use ENT.TY instead of CCLFLG
;			Replaced hard coded entry type constants with symbols
;  070  GMB  23-Feb-87	Rearranged prompting to support new prompt symbols
;
;			[V9.5]
;  071	JFM  26-May-87	Initialized EVLTYP in PARASG
;  072  BGN  25-Aug-87  Add SHOW QUOTAS command
;
;			[V9.6]
;  073  BGN  21-Sep-87	Add WAIT command
;  074  BGN  24-Feb-88	Add LAT support
;
;			[RSTS/E V9.7]
;  075  JFM  23-Aug-88	Change the way APOSUB and CMDSUB works, call expression
;			handler to do most of the work.  Move all text to one 
;			place.  Change CHKSN routine.  Got rid of many routines
;			not used after above changes.
;  076  JFM  09-Sep-88	Cleanup up CMDTBL code, added more subroutines to
;			do the work.  Made all comment blocks look the same.
;			Used new GLOBAL in $PARKEY to automatically globalize
;			routine addresses.  Don't use CALB to call LX.BLA or
;			LX.EOS.  Saves code and time.  Added lots of comments.
;  077  JFM  23-Nov-88	Made behavior of $_$_$_$_$_FOO the same as in V9.6
;  078  BTK  09-Dec-88	Check for spaces after labels
;  079  JFM  12-Dec-88	Undid change 077, making $_$_$FOO acceptable, executing
;			FOO as a command bypassing command substitution.
;  080	JFM  23-Jan-89	Add CREATE/VIRTUAL_DISK and DELETE/VIRTUAL_DISK commands
;
;			[RSTS/E V10.0]
;  081  BTB  25-Oct-89  Added RECALL command dispatch
;  082  BTB  10-Nov-89  Added OMS commands
;  083  BTB  13-Nov-89	Added one-shot prompt suppression support
;  084  BTB  20-Nov-89	Added missing OMS commands (SET/SHOW OPER, SHOW REQUEST)
;  085  BTB  20-Dec-89	Add Outbound LAT commands
;  086  BTB  16-Feb-90	Add MACRO entry point for CMDTBL (used by GOTO/GOSUB)
;  087  BTB  31-May-90	Add CC command; Change AUX entry points to AUX.CMD
;			Add BASIC/BPLUS (separate command from BASIC[/BP2])
;  088	JFM  14-Jun-90	Fix checking of F$ in CHKSN
;  089	JFM  18-Jun-90	Add another entry into BASIC, in case user has symbol
;			BASIC:==BASIC/BP2 and wants BASIC/BPLUS.
;  090	BTB  25-Jun-90	Remove DELETE/REQUEST command
;-


	.MCALL	PUTSTR,SETTYP,$BIT

	.PSECT	DCLCMD,RO,REL,CON
	DEFORG	DCLCMD

	$CUI	TABLE		;Include macros for CUI tables.

	 TMPORG	TEXT		;Text strings used in this file		;075
T.DS:	.ASCIZ "$"<SPACE><TAB>	;  Dollar signs, spaces and tabs	;075
T.COL:	.ASCIZ	":"		;  Colon, for assignment statements	;075
T.EQL:	.ASCIZ	"="		;  Eqaul sign, for assignment statements;075
T.LBL:	.ASCIZ	"A9$_"		;  Valid label characters:		;075
				;    A-Z, a-z, 0-9, $, underscore	;075
T.SYM:	.ASCIZ	"A9$_-*"	;  Valid symbol characters:		;075
				;    A-Z, a-z, 0-9, $, underscore,	;075
				;    hyphen, and asterick 		;075
	UNORG			;

.SBTTL	CMDTBL	-- Parse command keyword
;+
; CMDTBL -- Parse command keyword
;
; DESCRIPTION:
;	CMDTBL is the address passed in DCLRTS to the U.DIA routine to 
;	start the command dialogue.  It must be the address of threaded
;	code, but since most of that is done here is complicated, it is
;	done via MACRO code for the most part.  
;
;	This routine gets a command from the terminal (or command file).
;	Read errors are handled by simply reprompting unless the error
;	occured in a command file read.  Then we either STOP or EXIT,
;	depending on the type of exit.
;
;	We parse labels next, which is ignored if we aren't in a command
;	file.  Then we check the command for required apostrophe substitution.
;	Then we see if there is an assignment statement, and if so evaluate
;	it and add the symbol to the symbol table.  Otherwise, we perform
;	command substitution, and if performed, does more apostrophe 
;	substitution. 
;
;	Then the command is displayed if SET VERIFY/DEBUG is set.  We quit
;	if we are staring at a comment (as a result of substitution is the
;	only way).  Then we test to see if the command is an "@".  This is
;	handled here because it is not an ordinary command.
;	
;-
CMDTBL::$THR

; Read the command line

	$DO				;Go into MACRO code		;075
GETCMD::MOV	#-1,-(SP)		;Set for KBM (^C) read		;086
	CALL    GETPMT                  ;Get prompt string in R3	;081
	MOV     R3,-(SP)                ;Set prompt string 		;081
	CLR	-(SP)			;Set for no PREFIX		;075
	MOV	SP,R3			;Point to arg list
	CALLX	U$RDCMD			;Read a command
	ADD	#6,SP			;Pop arguments off the stack
	$ENDDO				;Let CUI handle U$RDCMD errors

; Process the command.  

	$DO				;Go back into MACRO code
	BIS	#STSUPD!SEVCHK,ICFFLG	;By default we will update $STATUS and
					; check severity.
	CMP	#NOR.TY,U.ENT(R4)	;Did DCL feed itself this line?
	BNE	12$			;No, go on
	MOV	INLEN,CMDLEN		;Restore command length
	TSTB	RUNCOM			;Run of a COM file?
	BNE	80$			;Do it if so (R0 is 0 from U$DO)
12$:	BIT	#ICFACT,ICFFLG		;Are we under an Indirect command file?
	BEQ	15$			;Branch if not
	TST	U.CMN+U.STAT		;Error reading a command?
	BLE	15$			;No, go on
	CMP	U.CMN+U.STAT,#EOF	;Was error "?End of file on device"?
	BNE	50$			;No, STOP (return to interactive level)
	CALLX	EX2.CMD			;Yes, EXIT (return to calling ICF)
	BR	60$			;Quit upon returning

15$:	CALL	PARLBL			;Label on command line?
	BCS	30$			;Branch if not
	CALLX	ADDLBL			;Add label to ICF's local sym table
	BCS	50$			;STOP if error occured
30$:	CALL	APOSUB			;Perform apostrophe substitution 
	BCS	80$			;Quit if error
	CALL	EOL			;Handle being at end of string
					;  May not return inline!
	BCS	60$			;Quit if line was blank


TRUEXP::; Enter here if the expression on an IF...THEN command was true.

	CALL	PARASG			;In format of an assignment statement?
	BCS	40$			;No, continue

	; There was an assignment statement, evaluate it and get out

	CALL	CHKSN			;Symbol name valid?
	BCS	80$			;No, error
	CALL	EVLASG			;Evaluate the assignment statement
	BCS	80$			;Error, exit
	BR	60$			;All done

	; There was no assignment statement

40$:	CALL	CMDSUB			;Do command substitution
	BCS	80$			;Branch if an error occured
	MOV	LX.POS,CMDPOS		;Store position of command
	CALL	PRIDBG			;Display command line if VERIFY/debug
	MOV	LX.POS,R4		;Get scan position		;076
	ADD	#CMDBUF-1,R4		;Make it an address		;076
	CMPB	(R4),#'!		;Looking at an "!", a comment?	;076
	BEQ	60$			;Yes, quit			;076
	MOV	#-1,R0			;Assume no "@" command		;076
	CMPB	(R4),#'@		;Do we have ind command file?	;076
	BNE	80$			;Yes, we were right		;076
	CLR	R0			;Yes, there was an "@" sign, 	;076
	INC	LX.POS			;Account for @ character	;076
	BR	80$			;And get out			;076

50$:	CALLX	ST2.CMD			;Get out of all higher ICFs	;075
60$:	MOV	#U.QUIT,R0		;Quit, all command processing done
80$:	$ENDDO				;Print error unless R0=0 or -1

GLOBAL	<EOF,U.CMN,DCLPMT,LOGPMT,LX.POS,CMDPOS>
GLOBAL	<U.QUIT,ICFFLG,CMDLEN,CMDBUF,INLEN,RUNCOM>

.SBTTL	TSTEXP	-- Test the expression 
;+
; TSTEXP -- Test the expression 
;
; DESCRIPTION:
;	We get here for two reasons.  The first is if there was no error
;	in any of the command processing that was done since the command
;	was read.  Any error messages were printed, or else we quit because
;	command processing was done.  The second entry point is used in
;	the IF...THEN command.  The IF...THEN command jumps to TRUEXP if
;	the expression tested true.  But when the $ENDDO command was 
;	executed control passed to $DO...$ENDDO macro block where the JMPX
;	occurred.  So, after that $ENDDO block in DCLCFP, the threaded code
;	$GOTO TSTEXP is executed to pass control back here.
;
; INPUTS:
; 	R0 =  0 (PRESENT) indicates there is an "@" command or we were 
;		entered at the P.RUN entry point because somebody is RUNning 
;		a .COM file.
; 	R0 = -1 (ABSENT) indicates no command file processing is to be done.
;		Command is in CMDBUF, all ready for command dispatch
; EFFECT:
;	Command is dipatched to the appropriate command, or tried as a
;	CCL, or errors with ?Invalid command.
;-

TSTEXP::$IF	PRESENT			;If we have an indirect command file
	$GOTO	IND.CMD			;  Go do the "@" command
	$ELSE				;Else
	$CALL	PARCMD			;  Parse a DCL command keyword,
					;    and go to appropriate routine.
	$IF	ABSENT			;  If that failed then
	$CALL	UNK.CMD			;    Try it as a CCL.
	$ENDIF				;  Endif	
	$ENDIF				;Endif	
	$RETURN				;Return to caller.
	$ENDTHR

GLOBAL	<IND.CMD>

.SBTTL	PARCMD	-- Parse a DCL command
;+
; PARCMD -- Parse a DCL command
;
; DESCRIPTION:
; 	Parse DCL command keyword and go to appropriate threaded routine.
; 	Return failure (ABSENT) status if and only if no keyword matches.
;
; 	Caution: the ONKEY statements in this routine JUMP to subroutines.
; 	THESE ARE NOT CALLS.  
;
; 	This table is alphabetical only for maintainability. This table is
; 	searched sequentially and can be reordered to put more frequently used
; 	commands first.  However qualfied commands (such as CLOSE/QUEUE) must
; 	be listed before their unqualified versions (CLOSE). For example:
;
; 	Right:
;		$ONKEY	CLL.C,CLL.CMD		;CLOSE/LOG_FILE
;		$ONKEY	CLQ.C,SPL.CMD		;CLOSE/QUEUE
;		$ONKEY	CLO.C,CLO.CMD		;CLOSE
;
; 	Wrong:
;		$ONKEY	CLL.C,CLL.CMD		;CLOSE/LOG_FILE
;		$ONKEY	CLO.C,CLO.CMD		;CLOSE
;		$ONKEY	CLQ.C,SPL.CMD		;CLOSE/QUEUE
;-

PARCMD:	$THR
	$PARKEY LABEL=GLOBAL
	$ONKEY	IF.C,IFTH.CMD		;IF
	$ONKEY	GOT.C,GOTO.CMD		;GOTO
	$ONKEY	GOS.C,GOSUB.CMD		;GOSUB
	$ONKEY	SET.C,10$,LOCAL		;SET
	$ONKEY	ONE.C,ONE.CMD		;ON ERROR
	$ONKEY	ONS.C,ONS.CMD		;ON SEVERE_ERROR
	$ONKEY	ONW.C,ONW.CMD		;ON WARNING
	$ONKEY	ONC.C,ONC.CMD		;ON CONTROL_C
	$ONKEY	DELS.C,DSYM.CMD		;DELETE/SYMBOL
	$ONKEY	CLL.C,CLL.CMD		;CLOSE/LOG_FILE
	$ONKEY	CLQ.C,SPL.CMD		;CLOSE/QUEUE
	$ONKEY	CLO.C,CLO.CMD		;CLOSE
	$ONKEY	EOD.C,EOD.CMD		;EOD
	$ONKEY	EXI.C,EXI.CMD		;EXIT
	$ONKEY	INQ.C,INQ.CMD		;INQUIRE
	$ONKEY	OPL.C,OPL.CMD		;OPEN/LOG_FILE
	$ONKEY	OPQ.C,SPL.CMD		;OPEN/QUEUE
	$ONKEY	OPE.C,OPE.CMD		;OPEN
	$ONKEY	REA.C,REA.CMD		;READ
	$ONKEY	REC.C,REC.CMD		;RECALL				;081
	$ONKEY	RET.C,RET.CMD		;RETURN
	$ONKEY	RUN.C,RUN.CMD		;RUN
	$ONKEY	WAI.C,WAI.CMD		;WAIT				;073
	$ONKEY	SHO.C,20$,LOCAL		;SHOW
	$ONKEY	WRI.C,WRI.CMD		;WRITE

	$ONKEY	ALL.C,UTL.CMD		;ALLOCATE
	$ONKEY	APP.C,APP.CMD		;APPEND
	$ONKEY	ASSP.C,LAT.CMD		;ASSIGN/PORT			;085
	$ONKEY	ASSQ.C,SPL.CMD		;ASSIGN/QUEUE
	$ONKEY	ASSS.C,UTL.CMD		;ASSIGN/SYSTEM
	$ONKEY	ASS.C,ASS.CMD		;ASSIGN
	$ONKEY	ATT.C,ATT.CMD		;ATTACH
	$ONKEY	BAC.C,BCK.CMD		;BACKUP
	$ONKEY	BPL1.C,BPL.CMD		;BASIC/BP2/BPLUS		;089
	$ONKEY	BPL2.C,BPL.CMD		;BASIC/BPLUS			;089
	$ONKEY	BAS.C,BAS.CMD		;BASIC [/BP2]			;089
	$ONKEY	BRO.C,UTL.CMD		;BROADCAST
	$ONKEY	BYE.C,BYE.CMD		;BYE
	$ONKEY	CCC.C,CC.CMD		;CC				;087
	$ONKEY	CCL.C,CCL.CMD		;CCL
	$ONKEY	COB.C,AUX.CMD		;COBOL				;087
	$ONKEY	COP.C,COP.CMD		;COPY
	$ONKEY	CREA.C,ACT.CMD		;CREATE/ACCOUNT
	$ONKEY	CREP.C,LAT.CMD		;CREATE/PORT			;085
	$ONKEY	CRES.C,LAT.CMD		;CREATE/SERVICE/LAT		;074
	$ONKEY	CREV.C,UTL.CMD		;CREATE/VIRTUAL_DISK		;080
	$ONKEY	CRE.C,CRE.CMD		;CREATE
	$ONKEY	DAL.C,UTL.CMD		;DEALLOCATE
	$ONKEY	DEAQ.C,SPL.CMD		;DEASSIGN/QUEUE
	$ONKEY	DEAP.C,LAT.CMD		;DEASSIGN/PORT			;085
	$ONKEY	DAS.C,UTL.CMD		;DEASSIGN/SYSTEM
	$ONKEY	DEA.C,DEAS.CMD		;DEASSIGN
	$ONKEY	DFCS.C,UTL.CMD		;DEFINE/COMMAND/SYSTEM
	$ONKEY	DELA.C,ACT.CMD		;DELETE/ACCOUNT
	$ONKEY	DECS.C,UTL.CMD		;DELETE/COMMAND/SYSTEM
	$ONKEY	DELE.C,SPL.CMD		;DELETE/ENTRY
	$ONKEY	DELP.C,LAT.CMD		;DELETE/PORT			;085
	$ONKEY	DELQ.C,SPL.CMD		;DELETE/QUEUE
	$ONKEY	DLSL.C,LAT.CMD		;DELETE/SERVICE/LAT		;074
	$ONKEY	DLSV.C,SPL.CMD		;DELETE/SERVER
	$ONKEY	DELV.C,UTL.CMD		;DELETE/VIRTUAL_DISK		;080
	$ONKEY	DEL.C,DEL.CMD		;DELETE
	$ONKEY	DET.C,UTL.CMD		;DETACH
	$ONKEY	DIB.C,AUX.CMD		;DIBOL				;087
	$ONKEY	DIF.C,DIF.CMD		;DIFFERENCES
	$ONKEY	DIR.C,DIR.CMD		;DIRECTORY
	$ONKEY	DIS.C,AUX.CMD		;DISMOUNT			;087
	$ONKEY	DUM.C,UTL.CMD		;DUMP
	$ONKEY	EDI.C,EDI.CMD		;EDIT
	$ONKEY	FORC.C,UTL.CMD		;FORCE
	$ONKEY	FOR.C,AUX.CMD		;FORTRAN			;087
	$ONKEY	HAN.C,UTL.CMD		;HANGUP
	$ONKEY	HEL.C,HEL.CMD		;HELP
	$ONKEY	INIQ.C,SPL.CMD		;INITIALIZE/QUEUE
	$ONKEY	INIS.C,SPL.CMD		;INITIALIZE/SERVER
	$ONKEY	INI.C,AUX.CMD		;INITIALIZE			;087
	$ONKEY	INS.C,UTL.CMD		;INSTALL
	$ONKEY	LIN.C,AUX.CMD		;LINK				;087
	$ONKEY	LOA.C,UTL.CMD		;LOAD
	$ONKEY	LOGI.C,UTL.CMD		;LOGIN
	$ONKEY	LOG.C,LOG.CMD		;LOGOUT
	$ONKEY	MAC.C,AUX.CMD		;MACRO				;087
	$ONKEY	MER.C,AUX.CMD		;MERGE				;087
	$ONKEY	MOU.C,AUX.CMD		;MOUNT				;087
	$ONKEY	PRI.C,PRI.CMD		;PRINT
	$ONKEY	REM.C,UTL.CMD		;REMOVE
	$ONKEY	REN.C,REN.CMD		;RENAME
	$ONKEY	REP.C,OMS.CMD		;REPLY				;082
	$ONKEY	REQ.C,OMS.CMD		;REQUEST			;082
	$ONKEY	RES.C,BCK.CMD		;RESTORE
	$ONKEY	SOR.C,AUX.CMD		;SORT				;087
	$ONKEY	STL.C,LAT.CMD		;START/LAT			;074
	$ONKEY	STOM.C,OMS.CMD		;START/OPERATOR_SERVICES	;082
	$ONKEY	STA.C,SPL.CMD		;START
	$ONKEY	STT.C,LAT.CMD		;STOP/LAT			;074
	$ONKEY	SPOM.C,OMS.CMD		;STOP/OPERATOR_SERVICES		;082
	$ONKEY	STOQ.C,SPL.CMD		;STOP/QUEUE
	$ONKEY	STOS.C,SPL.CMD		;STOP/SERVER
	$ONKEY	STO.C,STO.CMD		;STOP
	$ONKEY	SUB.C,SPL.CMD		;SUBMIT
	$ONKEY	TYP.C,TYP.CMD		;TYPE
	$ONKEY	UNL.C,UTL.CMD		;UNLOAD
	$ENDKEY	FAIL=5$			;End of command table
5$:	$RETURN	FAILURE			;Return failure if none matched


; S E T   C O M M A N D   O P T I O N S

10$:	$PARKEY	PROMPT=WHAT$P,LABEL=GLOBAL
	$ONKEY	ACCO.K,ACT.CMD		;SET ACCOUNT
	$ONKEY	CAC.K,UTL.CMD		;SET CACHE
	$ONKEY	CTC.K,CTC.CMD		;SET CONTROL=C
	$ONKEY	DAT.K,DAT.CMD		;SET DATA
	$ONKEY	DATE.K,UTL.CMD		;SET DATE
	$ONKEY	DEV.K,UTL.CMD		;SET DEVICE
	$ONKEY	ECH.K,ECH.CMD		;SET ECHO
	$ONKEY	ENT.K,SPL.CMD		;SET ENTRY
	$ONKEY	FILS.K,UTL.CMD		;SET FILES
	$ONKEY	HOS.K,SEHO.CMD		;SET HOST
	$ONKEY	JOB.K,UTL.CMD		;SET JOB
	$ONKEY	LOGF.K,LOGF.CMD		;SET LOGFILE
	$ONKEY	NCTC.K,NCTC.CMD		;SET NOCONTROL_C
	$ONKEY	NODA.K,NDAT.CMD		;SET NODATA
	$ONKEY	NODL.K,LAT.CMD		;SET NODE/LAT			;074
	$ONKEY	NCH.K,NEC.CMD		;SET NOECHO
	$ONKEY	NOON.K,NOON.CMD		;SET NOON
	$ONKEY	NOVE.K,NVER.CMD		;SET NOVERIFY
	$ONKEY	ON.K,ON.CMD		;SET ON
	$ONKEY	OPER.K,OMS.CMD		;SET OPERATOR_SERVICES		;084
	$ONKEY	PAS.K,ACT.CMD		;SET PASSWORD
	$ONKEY	PORT.K,LAT.CMD		;SET PORT			;085
	$ONKEY	PRIN.K,UTL.CMD		;SET PRINTER
	$ONKEY	PROM.K,PRO.CMD		;SET PROMPT
	$ONKEY	PROT.K,SEPR.CMD		;SET PROTECTION
	$ONKEY	QUE.K,SPL.CMD		;SET QUEUE
	$ONKEY	SEL.K,LAT.CMD		;SET SERVICES/LAT		;074
	$ONKEY	SER.K,SPL.CMD		;SET SERVER
	$ONKEY	SYS.K,UTL.CMD		;SET SYSTEM
	$ONKEY	TER.K,TER.CMD		;SET TERMINAL
	$ONKEY	TIM.K,UTL.CMD		;SET TIME
	$ONKEY	VER.K,VER.CMD		;SET VERIFY
	$ENDKEY

;  S H O W    C O M M A N D   O P T I O N S

20$:	$PARKEY	PROMPT=WHAT$P,LABEL=GLOBAL 
	$ONKEY	ACCO.K,ACT.CMD		;SHOW ACCOUNTS
	$ONKEY	BUF.K,SHBU.CMD		;SHOW BUFFERS
	$ONKEY	CAC.K,UTL.CMD		;SHOW CACHE
	$ONKEY	COMS.K,UTL.CMD		;SHOW COMMAND/SYSTEM
	$ONKEY	COUN.K,LAT.CMD		;SHOW COUNTERS/LAT		;074
	$ONKEY	DATE.K,SDT.CMD		;SHOW DATE
	$ONKEY	DAYT.K,SDT.CMD		;SHOW DAYTIME
	$ONKEY	DEVL.K,UTL.CMD		;SHOW DEVICES/ALL
	$ONKEY	DEVA.K,SHBS.CMD		;SHOW DEVICES/ALLOCATED
	$ONKEY	DEVS.K,UTL.CMD		;SHOW DEVICES
	$ONKEY	DIS.K,SHDI.CMD		;SHOW DISKS
	$ONKEY	ENT.K,SPL.CMD		;SHOW ENTRY
	$ONKEY	ENTS.K,SPL.CMD		;SHOW ENTRIES
	$ONKEY	FILO.K,SHOP.CMD		;SHOW FILES/OPEN
	$ONKEY	FILS.K,UTL.CMD		;SHOW FILES
	$ONKEY	JOBP.K,UTL.CMD		;SHOW JOB/PRIVILEGES
	$ONKEY	JOBS.K,SHJO.CMD		;SHOW JOBS
	$ONKEY	LGC.K,UTL.CMD		;SHOW LOGICALS
	$ONKEY	LIB.K,SHLI.CMD		;SHOW LIBRARY
	$ONKEY	LIBS.K,SHLI.CMD		;SHOW LIBRARIES
	$ONKEY	MEM.K,SHME.CMD		;SHOW MEMORY
	$ONKEY	NET.K,SHNE.CMD		;SHOW NETWORK
	$ONKEY	NODL.K,LAT.CMD		;SHOW NODE/LAT			;074
	$ONKEY	OPER.K,OMS.CMD		;SHOW OPERATOR_SERVICES		;084
	$ONKEY	PORT.K,LAT.CMD		;SHOW PORT			;085
	$ONKEY	PRIN.K,UTL.CMD		;SHOW PRINTERS
	$ONKEY	QUE.K,SPL.CMD		;SHOW QUEUES
	$ONKEY	QUO.K,QUO.CMD		;SHOW QUOTAS			;072
	$ONKEY	REQ.K,OMS.CMD		;SHOW REQUESTS			;084
	$ONKEY	RUN.K,SHRU.CMD		;SHOW RUN_TIME_SYSTEMS
	$ONKEY	RCV.K,SHRE.CMD		;SHOW RECEIVERS
	$ONKEY	SEL.K,LAT.CMD		;SHOW SERVICES/LAT		;074
	$ONKEY	SER.K,SPL.CMD		;SHOW SERVERS
	$ONKEY	SES.K,LAT.CMD		;SHOW SESSIONS			;074
	$ONKEY	SYM.K,SHSM.CMD		;SHOW SYMBOLS
	$ONKEY	SYS.K,UTL.CMD		;SHOW SYSTEM
	$ONKEY	TERS.K,LAT.CMD		;SHOW TERMINAL_SERVERS/LAT	;074
	$ONKEY	TER.K,TER.CMD		;SHOW TERMINAL
	$ONKEY	TIM.K,SDT.CMD		;SHOW TIME
	$ONKEY	USER.K,SHUS.CMD		;SHOW USERS
	$ENDKEY
	$ENDTHR

GLOBAL	<WHAT$P>

.SBTTL	PARDOL	-- Parsing dollar signs
;+
; PARDOL -- Parsing dollar signs
;
; DESCRIPTION:
; 	This routine skips an optional blank, and parses a dollar sign.
; 	Return ABSENT if dollar sign not found.
;
; INPUTS:
;	LX.POS	= current scan position           
;
; FORMAT:
;	CALL   PARDOL  
;
; OUTPUTS:
;	If success:
;		C = 0      	leading $ was found, all $'s and blanks parsed
;		ENT.TY = NOR.TY	no longer CCL entry since we ate CCL 
;		LX.POS	= position after and blanks and $'s.
;			       	character "$"
;	If failure:
;		C = 1      	Didn't find a leading "$", though all leading
;				blanks were parsed
;		LX.POS	= position after and leading blanks.
;
; All registers preserved (except R0)
;
;-
.ENABL	LSB

PARDOL::CALLX	LX.BLA			;Skip an optional blank.
	CALBX	LX.SKP <#T.DS>		;Look for a dollar sign or space.
	BCS	20$			;Set C-bit, didn't find leading $
	MOV	#NOR.TY,ENT.TY		;Could have been the dollar CCL so
					;... clear possible CCL type
	;CLC				;CLRB clears the C-bit
20$:	RETURN				;Return with status

.DSABL	LSB

GLOBAL	<ENT.TY>

.SBTTL	PARLBL	-- Parse a label
;+									
; PARLBL -- Parse a label
;
; DESCRIPTION:
; 	This routine checks to see if the command line has a syntactically 
;	valid label.  If it does, and the user is in an Indirect Command 
;	File, then the routine ADDLBL in DCLSYM is invoked to insert the 
; 	label (and its position in the ICF) in the local symbol table.  The 
; 	colon is required at the end of a label as the terminator, and a 
; 	dollar sign is required at the beginning of the line.  There can 
; 	be any number of spaces before the label name, but there can be no 
; 	intervening spaces after the label name and before the colon
; 	(ex. $ A  :).
;
; 	A label consists of 1-255 characters in the character set A-Z, a-z, 
; 	0-9, $ and underscore.  To avoid confusion, the first character 
;	cannot begin with a $ since dollar signs at the beginning of a DCL
;	command line are eaten (ex. $ABC:  is really label ABC).
;
;	The format of a label is:
; 				  $label:
;
; 	In an ICF, a label definition followed by another label definition 
;	on the  same command line results in the first being accepted, and 
; 	an error for the second one.  In $ ABC:DEF:  the label ABC: is added
; 	to the local symbol table, and DEF: results in an error being generated.
; 	
; 	In a command procedure, if a label has been found, continue parsing 
;	whatever follows.  If additional labels are found, then an error 
;	will be returned.  The second label is attempted as a command keyword.
;	This is not VMS compatible.
;
; INPUTS:
;	LX.POS	= current scan position
;	ICFFLG  indicates if we are in a command procedure
;
; FORMAT:
; 	CALL	PARLBL  (macro call)
;
; OUTPUTS:
;	C = 0, found a label (success)
;		LX.POS	= new scan position (right after the ":")
;		LX.PMAT	= start of label
;		LX.NMAT	= number of characters matched (excluding ":")
;		LX.ERP	= 0   (no error)
;		SYMFLG  = LABEL (flag that it's a label) gmb //fix //
;
;	C = 1, did not find a label (failure) 
;		LX.POS	= scan position after all dollars and spaces.
;		LX.ERP	= 0  
;
; Destroys R0,R1,R2
;-
.ENABL	LSB

PARLBL::CALL	PARDOL			;Parse any dollar signs and spaces
	BCS	40$			;Get out if there weren't any
	BIT	#ICFACT,ICFFLG		;Under an Indirect Command File?
	BEQ	30$			;No, then no label allowed
	MOV	LX.POS,R2		;Save scan position in case of no label
	CALBX	LX.SKP	<#T.LBL>	;Skip all valid label characters
	BCS	40$			;No characters matched, not a label

	MOV	LX.NMAT,R1		;Save number of valid chars matched
	CALBX	LX.EXAC	<#T.COL>	;Is 1st non-matching char a colon?
	BCS	20$			;No, not a label 

	; We found something like "$FOO:", but if could turn out to be
	; "$FOO:=" in which case this isn't a label but an assignment
	; statement.  Test for that case now.

	CALBX	LX.EXAC	<#T.EQL>	;Is it followed by an equal sign?
	BCC	20$			;It is, so this is not a label

	CALL	PARDOL			;Parse more dollar signs and spaces ;078
	MOV	R1,LX.NMAT		;Restore number of chars matched
	MOV	R2,LX.PMAT		;Restore position of match
	CLR	R0			;Flag that we found a label
				       .ASSUME LBLTYP EQ 0
	CLR	LX.ERP			;Clear error position (clears C bit)
	BR	40$			;And return

20$:	MOV	R2,LX.POS		;Restore original scan position
30$:	SEC				;Flag absence of a label
40$:	RETURN				;Return with status

.DSABL	LSB
GLOBAL	<LX.ERP,LX.POS,LX.PMAT,LX.NMAT,ICFFLG>

.SBTTL	PARASG	-- Parsing assignment statements 
;+									
; PARASG -- Parsing assignment statements 
;
; DESCRIPTION:
; 	This routine checks to see if the command line has an assignment 
;	statement (i.e. there is a symbol name followed by an '=').  If 
;	there is, then it sets flags as to the type of assignment.  The 
;	format of an assignment statement is:
;
;		symbol-name[:]=[=]expression
;
; INPUTS:
;	LX.POS	= current scan position.  We know all spaces, tabs and
;		  dollar signs have been parsed, so scan position is
;		  after any of these leading characters.
;
; FORMAT:
;	CALL  PARASG
;
; OUTPUTS:
;	C = 0, found an assignment statement (success) 
;		R0	= 0
;		LX.POS	=  new scan position, (right after the :== etc.)
;		NAMABB  =  number of characters in the minimum abbreviation for
;			    this symbol name (# of characters to the left of 
;			    the hyphen or asterick) 
;		NAMLNG	=  number of characters matched in the symbol name, 
;			    including the optional hyphen or asterick
;		NAMADR  -> address of symbol name in buffer
;		EVLTYP	=  0 if assignment is normal, 1 if string assignment.
;		gmb // fix SYMFLG//
;		SYMFLG	=  flag word indicating the kind of assignment found 
;			   (is some combination of the following bits)
;			  STRING - a string assignment (a colon was found)
;			  LOCAL  - local assignment (an equal sign was found)
;			  GLOBAL - global assignment (a double equal was found)
;			  NAME   - a symbol (vs. a label)
;
;	C = 1, did not find an assignment statement (failure) 
;
; Destroys registers R0,R2,R4,R5
;-
.ENABL	LSB

PARASG:	MOV	LX.POS,-(SP)		;Store scan position
	CALBX	LX.SKP <#T.SYM>		;Skip all valid symbol characters
					;(allow 1st char to be a digit, hyphen,
					; underscore, or asterick for now)
	BCS	30$			;Error, then not an assignment 	;076
	MOVB	LX.NMAT,NAMLNG		;Save number of characters matched
	CLRB	EVLTYP			;Initialize evaluation type
	CALLX	LX.BLA			;Parse optional blanks 
	CALBX	LX.EXAC	<#T.COL>	;Is it followed by a colon?
	BCS	10$			;No.  It's okay, colons are optional
	INCB	EVLTYP			;Guess it's a string assignment,
					;  although it may be a label.
10$:	CALBX	LX.EXAC	<#T.EQL>	;Next character an equal sign?	;075
	BCS	30$			;No? Then not an assignment	;075

; It is an assignment statement

	MOV	LCAPTR,SCOPE		;Assume local assignment	;075
	CALBX	LX.EXAC	<#T.EQL>	;Next char also equal sign?	;075
	BCS	20$			;No, we assumed right		
	MOV	GCAPTR,SCOPE		;Set symbol scope to global

20$:	ADD	#CMDBUF-1,(SP)		;Calculate address of symbol	;076
	MOV	(SP)+,NAMADR		;Save address of symbol name	;076
	CLC				;Indicate success		;076
	BR	40$			;Return success			;076

30$:	MOV	(SP)+,LX.POS		;Restore scan position
40$:	RETURN				;Return 

.DSABL	LSB

GLOBAL 	<NAMABB,NAMADR,NAMLNG,SCOPE,GCAPTR,LCAPTR,EVLTYP>
GLOBAL	<LX.POS,LX.NMAT,CMDBUF>

.SBTTL	CHKSN	-- Check for valid symbol name
;+									
; CHKSN -- Check for valid symbol name
;
; DESCRIPTION:
; 	This routine checks to see if the symbol name is valid on left side
;	of the equal sign on an assignment statement, on the INQUIRE command 
;	or on a READ command.  Each of these commands has the potential to 
;	create a symbol.  These symbols must be checked for validity BEFORE
;	adding them to the symbol table.
;
; 	A symbol name consists of 1-255 characters in the character set A-Z, 
;	a-z, 0-9, $, and underscore.  A symbol name cannot start with an 
;	integer, dollar sign, underscore or the characters "F$" (or f$), 
;	which represent reserved symbol name prefixes.  A hyphen or an 
;	asterick can be used to specify an abbreviation point for the symbol 
;	(that is, the minimum abbreviation allowed when referring to this 
;	symbol name in another DCL command).  For example, the symbols
;	AB-CD or AB*CD enable a user to refer to this symbol using either 
;	the names AB, ABC, or ABCD for COMMAND SUBSTITUTION PURPOSES ONLY.  
;	Naturally, a symbol name cannot begin with a hyphen or an asterick 
;	character.
;
; INPUTS:
;	NAMADR	= address of symbol name, in CMDBUF		;075
;	NAMLNG	= length of symbol name, including any 		;075
;				abbreviation point characters		;075
; FORMAT:
;	CALL  CHKSN
;
; OUTPUTS:
;	C = 0 if success, symbol name is valid 
;		R0	= 0
;		NAMABB  =  number of characters in the minimum abbreviation for
;			    this symbol name (# of characters to the left of 
;			    the hyphen or asterick) 
;
;	C = 1 if failure, symbol name was not valid 
;	    	R0 	= U.ISYN ("?Invalid symbol name")
;				  - the symbol name either began with a digit, 
;				    an underscore, a hyphen or an asterick, or 
;				    it contained more than 1 hyphen or asterick
;			= RSVN.E ("?Reserved symbol name")
;				  - user attempted to assign a symbol name 
;				    using a reserved prefix (F$, f$ or $)
;		LX.ERP  = position of error
;
; All registers preserved except R0
;-
.ENABL	LSB

CHKSN::	PUSH	<R2,R4,R5>	;Save registers
	MOV	NAMADR,R4	;Address of symbol name	
	MOV	R4,LX.ERP	;Any error points to symbol name	;075
	SUB	#CMDBUF-1,LX.ERP ;Make it a position			;075

; Test for a reserved symbol name					;075

	MOV	#RSVN.E,R0	;Assume "?Reserved symbol name"		;075
	CMPB	(R4),#'$	;1st character in symbol name a $ ?	;075
	BEQ	60$		;Yes, that's a reserved symbol name	;075
	CMPB	NAMLNG,#1	;Symbol name only one character?	;088
	BEQ	10$		;Yes, so it's not F$, is it?		;088
	CMPB	(R4),#'F	;Is first character an F?		;075
	BEQ	5$		;Yes, try next character		;088
	CMPB	(R4),#'f	;No, how about lower case?		;075
	BNE	10$		;No, it's not reserved			;075
5$:	CMPB	1(R4),#'$	;Yes, Is it followed by a $?		;088
	BEQ	60$		;Yes, it's reserved, error		;075

; Test for invalid symbol name						;075

10$:	MOV	#U.ISYN,R0	;Assume "?Invalid symbol name"		;075
	CMPB	(R4),#'0	;1st character in name a digit ?	;075
	BLT	20$		;No, continue				;075
	CMPB	(R4),#'9	;Maybe					;075
	BLE	60$		;Yes, error				;075
	CMPB	(R4),#'_	;No, 1st character an underscore ?	;075
	BEQ	60$		;Yes, error				;075
20$:	CMPB	(R4),#'-	;No, is it a hyphen ?			;075
	BEQ	60$		;Yes, error				;075
	CMPB	(R4),#'*	;No, 1st character is an asterick?	;075
	BEQ	60$		;Yes, error				;075

; Leave R0 as Invalid symbol name in case of multiple hyphens.  Set up	;075
; symbol name abbreviation point.					;075

	CLR	R5		;Ensure high byte is clear		;075
	BISB	NAMLNG,R5	;Get symbol name length			;075
	CLRB	NAMABB		;Clear the minimum abbreviation		;075
	MOV	R5,R2		;Copy number of chars in symbol name	;075
	
30$:	CMPB	(R4),#'-	;Is next character a hyphen ?		;075
	BEQ	50$		;Yes, set up abbreviation point		;075
	CMPB	(R4),#'*	;No, is it an asterisk?			;075
	BEQ	50$		;Yes, set up abbreviation point		;075
40$:	INC	R4		;Check next character			;075
	SOB	R5,30$		;Loop					;075
	CLR	R0		;Set no error (clear C bit)		;075
	BR	70$		;All done, set no errors		;075

; Found abbreviation point, set NAMABB.					;075

50$:	TSTB	NAMABB		;Name abbreviation already set?		;075
	BNE	60$		;Yes, error				;075
	SUB	R5,R2		;Compute abbreviation point		;075
	BISB	R2,NAMABB	;And set it in stone			;075
	BR	40$		;Continue loop				;075

60$:	SEC			;Indicate failure, set C bit		;075
70$:	POP	<R5,R4,R2>	;Restore registers, don't touch C-bit	;075
	RETURN			;Return to caller			;075

.DSABL	LSB

GLOBAL 	<NAMADR,NAMLNG,NAMABB,LX.ERP,CMDBUF,U.ISYN,RSVN.E>

.SBTTL	EVLASG	-- Evaluate an assignment statement
;+
; EVLASG -- Evaluate an assignment statement
;
; DESCRIPTION:
;	This routine calls the expression parser to evaluate the assigment.
;	We know we have a valid symbol name followed by [:]=[=].  What
;	follows that is up to the expression handler to deal with.
;	If the expression parser returns without error, the symbol is
;	added to the appropriate routine.
;
; INPUTS:
;	NAMLEN	= Length of symbol name to assign to, including hyphen or
;			asterisk, if any.
;	NAMADR	= Address of symbol name
;	NAMABB	= position of abbrieviation point, if any.
;	LX.POS  = beginning of expression
;	SCOPE   = local or global symbol table, depending on how many ='s
;	EVLTYP	= 0 or 1, depending on presence of : character
;
; FORMAT:
;	CALL	EVLASG
;
; OUTPUTS:
;	C=0 if success and
;		Symbol is added to the appropriate symbol table
;	C=1 if failure and
;		R0 = error code
;		LX.ERP = position of error
;-
.ENABL LSB

EVLASG:	BIC	#STSUPD!SEVCHK,ICFFLG	;Assignments don't affect $STATUS
	MOV	SCOPE,-(SP)		;Save symbol scope
	MOVB	NAMABB,-(SP)		;Save symbol's minimum abbrev over
					; the SRHENT routine called by EXPEVL
	CALLX	EXPEVL			;Do expression evaluation
	MOVB	(SP)+,NAMABB		;Restore the abbreviation point
	MOV	(SP)+,SCOPE		;Restore the scope
	TST	R0			;Error occur?
	BNE	10$			;Yes, quit with error status
	CALLX	LX.EOS			;Are we at end of string?
	BCS	20$			;?Invalid character if not.
	CALLX	ADDSYM			;Do the symbol assignment 
	TST	R0			;Did an error occur?
	BNE	10$			;Yes, return error
	CALL	PRIDBG			;No, print command line if verify/DEBUG
	TST	(PC)+			;Set no error, skip next instruction
10$:	SEC				;Indicate error 
20$:	RETURN				;Return with status

.DSABL	LSB

GLOBAL	<NAMABB,SCOPE>

.SBTTL	PRIDBG	-- Print translated command line if VERIFY/DEBUG
;+
; PRIDBG -- Print translated command line if VERIFY/DEBUG
;
; DESCRIPTION:
;	This routine checks to see if the current verify condition is
; 	SET VERIFY/DEBUG and prints the translated command line if it is.
;
; INPUTS:
;	Translated command is sitting in CMDBUF.
;
; FORMAT:
;	CALL PRIDBG
;
; OUTPUTS:
;	<none>
;-
.ENABL	LSB

PRIDBG:	BITB	#DEBUG,WATFLG		;Are we in DEBUG mode?
	BEQ	10$			;No, continue
	CMESSAGE #CMDD.M <CMDLEN,#CMDBUF>; Display translated command (debug)
10$:	RETURN

.DSABL	LSB

GLOBAL	<CMDBUF,CMDLEN,CMDD.M,WATFLG>

.SBTTL	EOL	-- Handle blank lines
;+
; EOL -- Handle blank lines
;
; DESCRIPTION:
;	This routine tests to see if we are at a blank line, and if we are,
;	we attempt to switch to ourselves.  Note that if we are in a command
;	file, we don't actually do the switch.
;
; INPUTS: 
;	KBMFLG tells us if DCL is already our KBM
;	ICFFLG tells us if we are in a command procedure
;	LX.POS is position in command line
;	CMDBUF has command line in it
;
; FORMAT:
;	CALL EOL
;
; OUTPUTS:
;	C=0 if we were not at end of line, so there is no reason to quit
;	C=1 for any other reason.  
;		<MAY NOT RETURN INLINE!>
;-
.ENABL	LSB

EOL:	CALLX	LX.EOS			;Are we at end-of-string?
	BCS	10$			;Branch if not
	BIC	#STSUPD!SEVCHK,ICFFLG	;Blank lines do not affect $STATUS
	BIT	#ICFACT,ICFFLG		;Are we in a command procedure?
	BNE	20$			;Quit if we are.  Don't SW at all.
	TSTB	KBMFLG			;Is job's KBM our own?
	BEQ	20$			;Yes, don't bother to switch
	CALBX	SAVSTB			;Save symbol table file, we might
					;  not come back in-line from .RTS
	CALLX	CLRFQX			;Clear FIRQB and XRB
	MOV	#-1,FIRQB+FQEXT		;Function = Establish new KBM
	MOV	...DCL,FIRQB+FQNAM1	;Switch to ourselves
	MOV	...DCL+2,FIRQB+FQNAM1+2	;  by loading in our own name
	.RTS				;This makes us (DCL) the job KBM.

; Control returns inline if we have privs (But watch it: the monitor has 
; detached any libraries. Has it done other damage?)

	CALLX	U$CHKE			;Abort if error. (Shouldn't happen.)
;gmb?	CALBX	GETSTB			;We came back!  Good for us.  Get STB
	BR	20$			;Quit

10$:	TST	(PC)+			;Indicate we are not at end of line
20$:	SEC				;Indicate we must quit after this call
	RETURN				;Return with status

.DSABL	LSB

GLOBAL	<...DCL,KBMFLG,ICFFLG>

;	
.SBTTL	APOSUB	-- Perform apostrophe substitution 
;+
; APOSUB -- Perform apostrophe substitution 
;
; DESCRIPTION:
;	This routine examines the user's command line and performs apostrophe 
;	substitution on symbol names enclosed in apostrophes, by replacing them
;	with their current value in the symbol table. In a non-quoted character
;	string, symbol substitution is specified by enclosing the name in 
;	matching apostrophes (ex. A='foo').  In a quoted character string, 
;	symbol substitution is specified by placing 2 apostrophes before the 
;	symbol name and one apostrophe following it (ex. A="''foo'").  The
;	symbol name specified in the matching apostrophes must be the full
;	symbol name in order for substitution to take place; it cannot be an
;	abbreviation for the symbol name (ex. in ABC-DE=5, the user must 
;	specify 'ABCDE' and not 'ABC' or 'ABCD').
;
;	A new feature (V9.7) enables the use of expressions in apostrophe
;	substitution.  This is accomplished by a call to the expression
;	parser.  Thus access to lexical functions and string concatenation,
;	for example, are possible.  
;
;	Apostrophe substitution is always iterative, and is performed from 
;	left to right.  Each time a substitution is made, DCL immediately 
;	rescans the command line from left to right starting at the scan
;	position of the previously matched substitution.  In other words,
;	this routine does not backtrack.  Once a character has been scanned
;	and determined that it is not an apostrophe, we never look at it or
;	or move that character again.  A maximum of 100 (MAXSUB) apostrophe 
;	substitutions will be performed before this routine errors with 
;	"?Substitution too complex" (CXSB.E).  At that point it is fairly
;	reasonable to assume that the substition would loop infinitely.
;	For example: $ A="'A'" ... $ 'A' ... loops infinitely.
;
;	When this routine is invoked, the user's command line is located in the
;	buffer CMDBUF.  We scan CMDBUF from LX.POS (current scan position)
;	to the end of the command line.  If an apostrophe is found, we 
;	remember the current scan position and call the expression parser.
;	(Note: special rules  for inside quotes).  When we come back we 
;	search for the closing quote character.  Then we call INSERT with
;	the postion of the opening quote, the character after the closing 
;	quote, and the pointer and length of the string result.  INSERT does
;	the substitution inline, only erroring if the substitution overflows
;	CMDBUF.
;
; INPUTS:
;	LX.POS  = original scan position
;	CMDBUF  = contains user's command line as he typed it
;	CMDLEN  = length of command string (bytes) 
;	CMDNEX  -> address of next byte free in CMDBUF
;
; FORMAT: 
;	CALL  APOSUB
;
; OUTPUTS:
;	C=0 if success and:
;		R0	= 0 (all apostrophe substitution was performed success-
;			     fully on the command, or there was none to perform)
; 		CMDBUF  = contains user's command line after substitution
;		CMDLEN  = length of translated command string (bytes) 
;		CMDNEX  -> address of next byte free in CMDBUF
;		LX.POS	= unchanged scan position
;		LX.ERP	= 0 (no error)
;
;	C=1 if failure and:
;		R0	= error code 
;    		         U.LONG = "?Command too long" (returned by INSERT)
;			          - the command line exceeded 255 characters 
;				    (if the substitution had been performed)
;			 CXSB.E = "?Substitution too complex"
;				  - apostrophe substitution reached the maximum
;				    number of iterations allowed on one command
;			 NOCA.E = "?Missing closing apostrophe"
;				  - the user did not specify closing apostrophe
;			            (ex. A="''abc", A='abc, A='ab  cd')
;			Any error returned by the expression handler.
;		CMDBUF  = contains user's command line with possibly some 
;		          substitutions that were successful before the error
;			  occurred
;		CMDLEN  = length of the command line in CMDBUF
;		CMDNEX  -> address of next byte free in CMDBUF
;		LX.POS	= unchanged scan position
;		LX.ERP	= error position 
;
; INTERNAL VARIABLES:
;
;	QUOFLG =  0 --> flag indicating we're not within a quoted string
;	       =  1 --> flag indicating we're within a quoted string
;	COUNTR =  number of iterations performed.  Starts at MAXSUB (100)
;		  and counts down to 0.  When it reaches 0, errors with 
;		  CXSB.E
;
; Destroys R0-R5.
;
;-
.ENABL	LSB

DQUOT	=:	42	;Ascii value of a double quote (") character	;075
SQUOT	=:	47	;Ascii value of a single quote (') character	;075

APOSUB:	MOV	LX.POS,-(SP)	;Save current scan postion		;075
	MOV	(SP),R3		;Get current scan position		;075
	ADD	#CMDBUF-1,R3	;Make it an address			;075
	MOV	CMDLEN,R4	;Get length of users command		;075
	SUB	LX.POS,R4	;Compute number of characters 		;075
	INC	R4		; left to examine			;075
	BEQ	25$		;No characters to examine, done		;075
	CLRB	QUOFLG		;Set flag, not in double quote		;075
	MOVB	#MAXSUB,COUNTR	;Set maximum number if iterations	;075

10$:	CMPB	(R3),#DQUOT	;Looking at a double quote character?	;075
	BEQ	30$		;Branch if so				;075
	CMPB	(R3),#SQUOT	;Looking at a single quote character?	;075
	BEQ	40$		;Branch if so				;075
15$:	INC	R3		;Skip to next character, nothing to do	;075
20$:	SOB	R4,10$		;That's the loop.  Short if no quote chars ;075
25$:	CLR	R0		;No errors, if it got this far		;075
	BR	80$		;All done				;075

;									;075
; Double quote character (") encountered.  				;075
;									;075
30$:	COMB	QUOFLG		;Toggle flag				;075
	BR	15$		; ... and keep going			;075

;									;075
; Single quote character (') encountered.  				;075
;									;075
40$:	MOV	R3,R5		;Save position of single quote character;075
				; just in case we will be performing 	;075
				; substition				;075
	INC	R3		;Account for the 1st single quote	;075
	TSTB	QUOFLG		;Are we inside double quotes?		;075
	BEQ	50$		;No.  Branch to symbol substitution	;075
	CMPB	(R3),#SQUOT	;Yes.  Is next byte also a single quote?;075
	BNE	20$		;Ignore this one if not			;075
	INC	R3		;Account for the 2nd single quote	;075

50$:	DECB	COUNTR		;Account for substitution iteration	;075
	BEQ	70$		;Too many if counted down to zero	;075
	MOV	R3,LX.POS	;Get address of single quote character	;075
	SUB	#CMDBUF-1,LX.POS;Make it position in command string	;075
	PUSH	<R5>		;Save opening quote character		;075
	CALLX	DOEXPS		;Call expression handler, translate 	;075
				;  result to a string.  (R1->string,	;075
				;  R2=len, R0=error if any)		;075
	POP	<R3>		;Restore quote position into R3		;075
	BCS	80$		;Report expression error if any		;075
	MOV	LX.POS,R4	;Get new scan position			;075
	CMP	R4,CMDLEN	;Are beyond last character in string?	;075
	BGT	60$		;Yes?  Then no closing quote character	;075
	ADD	#CMDBUF-1,R4	;Make it an address			;075
	CMPB	(R4)+,#SQUOT	;Is final character a single quote?	;075
	BNE	60$		;No, that's an error			;075

	CALB	INSERT		;Insert expression result into command	;075
				;  All registers preserved via CALB.	;075
	BCS	80$		;Quit if error occured			;075
	MOV	CMDLEN,R4	;Calculate number of characters left to ;075
				; examine after insert			;075
	ADD	#CMDBUF,R4	;Adjust to make it an address		;075
	SUB	R3,R4		;Now R4=number of chars left to examine	;075
	BEQ	80$		;No more, done				;075
	BR	10$		;Continue loop				;075

60$:	MOV	LX.POS,LX.ERP	;Set error position			;075
	MOV	#NOCA.E,R0	;Error: ?Missing closing apostrophe	;075
	BR	80$		;Return					;075

70$:	MOV	R5,LX.ERP	;Address of opening quote is where error;075
	SUB	#CMDBUF-1,LX.ERP;Make it a position			;075
	MOV	#CXSB.E,R0	;Error: ?Substitution too complex	;075
80$:	MOV	(SP)+,LX.POS	;Restore original scan position		;075
	TST	R0		;Error occur?				;075
	BEQ	90$		;Branch if not (clears C-bit)		;075
	SEC			;Indicate failure			;075
90$:	RETURN			;Return					;075

.DSABL	LSB								;075

GLOBAL	<MAXSUB,CXSB.E,NOCA.E,COUNTR,QUOFLG,CMDBUF,CMDLEN,LX.POS>	;075

.SBTTL	CMDSUB	-- Perform command substitution 
;+
; CMDSUB -- Perform command substitution 
;
; DESCRIPTION:
;	This routine examines the first command keyword (token) on the user's 
;	command line to determine if it matches the name of a symbol defined in
;	the user's symbol tables.  If so, automatic substitution is performed, 
;	replacing the keyword with the symbol's current value.  This lets a 
;	user define DCL command "synonyms" or redefine an existing DCL command 
;	in order to change a default qualifier.  The symbol name specified as
;	the first token keyword can be the full	symbol name or any abbreviation
;	point that has been defined for that symbol name in order for 
;	substitution to take place  (ex. in ABC-DE=5, the user can specify 
;	ABC, ABCD or ABCDE).  
;
;	When making the substitution in the command, the changes are made in 
;	the CMDBUF buffer.  It should be noted that if a label is followed by 
;	a command on one line, then the first token after the initial label 
;	is examined for possible substitution (LX.POS points to this token).
;
;	If command synonym substitution took place, then a call is made to 
;	perform apostrophe substitution again on the user's command line.
;
; 	Note:  the user can bypass command synonym substitution by beginning
;	       the token with an underscore.  This allows the user to use the
;	       real DCL command, even though he may have that keyword defined 
;	       in his symbol table.  
;
; INPUTS:
;	CMDBUF  contains user's command line as he typed it
;	CMDLEN  = length of command string (bytes) 
;	LX.POS  = current scan position.  PARDOL was called in PARLBL, so scan
;		  position is beyond any leading label, dollar signs, 
;		  underscores, spaces and/or tabs.
;
; FORMAT: 
;	CALL  CMDSUB (macro call)
;
; OUTPUTS:
;	C=0 if success AND:
;		R0	= 0 (successful), one of the following applied:
;			    1. the 1st token was replaced with its current 
;			        value, or 
;			    2. the token was not defined in the user's symbol
;			        tables, so no substitution was performed, or 
;			    3. the token was defined in the user's symbol 
;			        tables, but it had an integer type, so no
;				substitution was performed.
;
; 		CMDBUF  contains user's command line after symbol substitution
;		CMDLEN  = length of translated command string (bytes) 
;		CMDNEX  -> next available slot in CMDBUF
;		LX.POS	= position of command
;		LX.ERP	= 0 (no error)
;
;	C=1 if failure AND:
;		R0	= error code 
;    		         U.LONG = "?Command too long"
;			          - the command line exceeded 255 characters
;				    (if command synonym substitution had been 
;				     performed)
;			 U.ISYN = "?Invalid symbol name"
;				  - the symbol name specified was invalid
;		LX.POS	= original scan position 
;		LX.ERP	= error position 
;		CMDBUF  = contains user's original command line as he typed it
;		CMDLEN  = length of original command line (unchanged)
;
; Destroys R0-R5
;
;-
.ENABL	LSB

CMDSUB:	CALL	UND		;Looking at an underscore?		;076
	BEQ	10$		;Yes, bypass command substitution	;076
	PUSH	<R3>		;Save position of command		;076
	CALLX	DOEXPC		;Parse a command type expression	;075
	POP	<R3>		;Restore position of command		;076
	BCS	30$		;Error?  Ignore them!  			;075
				;  Else R1->string,R2=len		;075
	MOV	LX.POS,R4	;Take new scan position			;075
	ADD	#CMDBUF-1,R4	;Make it an address too			;075
				;All registers set up for insert	;075
	CALB	INSERT		;Insert command into CMDBUF		;075
	BCS	40$		;Command overflow is only possible error;075
	MOV	R3,LX.POS	;Get command position			;076
	SUB	#CMDBUF-1,LX.POS;Make it an offset			;076
	CALL	APOSUB		;Perform apostrophe substitution	;075
	BCS	40$		;Branch if error			;075
5$:	CALL	UND		;Looking at an underscore?		;079
	BNE	20$		;Branch if not				;077
10$:	INC	LX.POS		;Adjust for underscore			;076
20$:	CALL	PARDOL		;Parse any dollar signs and blanks now	;076
	BCC	5$		;Found a $ sign, recheck underscores	;079
	CALL	EOL		;And handle being at end of line	;077
				;  (May not return inline!)		;076
30$:	CLR	R0		;Ignore errors from DOEXPC		;075
40$:	RETURN			;Return with status			;075

UND:	MOV	LX.POS,R3	;Get scan position 			;075
	ADD	#CMDBUF-1,R3	;Make it an address			;075
	CMPB	(R3),#'_	;Command begin with an underscore?	;076
	RETURN			;Return

.DSABL	LSB								;075

GLOBAL	<LX.POS,CMDBUF>							;075

.SBTTL	INSERT	-- Insert a string into the command line
;+
; INSERT -- Insert a string into the command line
;
; DESCRIPTION:
;	This routine is used by the apostrophe substitution routine (APOSUB)
; 	and command substitution (CMDSUB) to insert the resulting expression 
; 	into the users command line.  It can return only one error:  U.LONG, 
; 	indicating that the substitution would result in an overflow of CMDBUF.
; 	Note that if that is the case, the substition does not take effect.
;
; INPUTS:
; 	R1 	-> String to insert
;	R2 	=  Length of string to insert
;	R3 	-> Position of first character where insert will go
;	R4 	-> First character after expression (and any closing quote)
;	      	   It could possibly be beyond the end of the line
;	CMDLEN 	=  Length of command as it currently exists
;	CMDNEX 	-> Address of next byte free in buffer
;
; FORMAT:
;	CALB	INSERT
;
; OUTPUTS:
;	C=0 if success and:
;		R0 	=  0
;		CMDLEN 	=  length of updated command
;		CMDNEX 	-> address of next free byte in buffer
;	C=1 if failure and:
;		R0	=  U.LONG ("?Command too long")
;				- if insert pushes command beyond buffer limit.
;
; All registers preserved via CALB
;-
.ENABL	LSB

INSERT:	MOV	R3,R5		;Get address of first position		;075
	ADD	R2,R5		;Get address of where insert will end	;075
	CMP	R5,R4		;Will the insert fit over expression?	;075
	BEQ	150$		;Branch if exactly in line		;075
	BHI	200$		;Branch if not				;075

	; We are inserting a small string over a larger expression	;075

	TST	R2		;Any characters in resulting string?	;075
	BEQ	105$		;Branch if none, don't enter SOB loop	;075
100$:	MOVB	(R1)+,(R3)+	;Move result over expression		;075
	SOB	R2,100$		;Until all bytes moved			;075
105$:	ADD	#CMDBUF-1,CMDLEN;Get ending address of current command	;075
110$:	CMP	R4,CMDLEN	;Pointing beyond end of command?	;075
	BHI	120$		;All done if so				;075
	MOVB	(R4)+,(R3)+	;Move byte into position		;075
	BR	110$		;And loop				;075

120$:	MOV	R3,CMDLEN	;Compute new end of command line	;075
	SUB	#CMDBUF,CMDLEN	; ...					;075
	MOV	R3,CMDNEX	;Set next free byte in CMDBUF		;075
	BR	240$		;And return				;075

	; We are inserting a string directly in place			;075

150$:	MOVB	(R1)+,(R3)+	;Move a byte at a time			;075
	SOB	R2,150$		; ... until all copied			;075
	BR	240$		;And return.  CMDLEN, CMDNEX all set up	;075

	; We are inserting a larger string over a small expression	;075

200$:	PUSH	<R1,R2>		;Save expression address and length	;075
	MOV	CMDLEN,R1	;Get current command length		;075
	ADD	#CMDBUF,R1	;R1=ending address of current command (+1) ;075
	ADD	R1,R2		;Compute where ending 			;075
	SUB	R4,R2		; ... character will be (+1)		;075
	ADD	R3,R2		; ...					;075
	CMP	R2,#CMDBUF+CMD.BSIZ ; Will command overflow buffer?	;075
	BHI	230$		;Yes, return error			;075	
	MOV	R2,CMDLEN	;Compute resulting end of command	;075
	SUB	#CMDBUF,CMDLEN	; ...					;075
	MOV	R2,CMDNEX	;Set next free byte in CMDBUF		;075
	
210$:	MOVB	-(R1),-(R2)	;Move characters from tail of command 	;075
				;  and working backwards 		;075
	CMP	R1,R4		;Have we moved all required characters?	;075
	BHI	210$		;Loop if not				;075

	POP	<R2,R1>		;Restore expression length and address	;075
220$:	MOVB	(R1)+,(R3)+	;Copy all characters from expression	;075
	SOB	R2,220$		;Until all characters copied		;075
	BR	240$		;All done				;075

230$:	CMP	(SP)+,(SP)+	;Clean up stack				;075
	CLR	LX.ERP		;Set no error position with this error	;075
	MOV	#U.LONG,R0	;Error: ?Command too long		;075
240$:	RETURN			;Return, restoring all registers	;075

.DSABL	LSB								;075

GLOBAL	<U.LONG,CMD.BSIZ,CMDBUF,CMDLEN,LX.ERP,CMDNEX>			;075

.SBTTL	GETPMT	Get the prompt string
;+
; GETPMT - Get the prompt string
;
; Inputs:
; 	ICFFLG describes the current ICF status
;
; Outputs:
;	R3 = the prompt
;
;
; Description:
;
; GETPMT takes a look at certain flags to determine if the prompt string
; should be the DCLPMT, the LOGPMT, or no prompt at all (in the case of
; a command file read).
;
; This routine is also called by the RECALL command in DCLRCL.MAC to get 
; the correct prompt to print before recalling a command as in RECALL 3 or 
; RECALL EDT.  In either of these cases, the prompt must be printed before 
; the command is recalled.  //Note that this will not be necessary if echo
; on read is implemented, since the prompt will have been displayed 
; already.//
;-
.ENABL	LSB

GETPMT::CLR	R3			;Assume read with no prompt	;081
	BIT	#ICFACT!NOPROM,ICFFLG	;Is ICF active or prompt suppressed? ;083
	BNE	20$			;Branch if so
	BIC	#LASTCC,ICFFLG		;Clear the CTRL/C flag 		;081
					; indicator before reading 	;081
					; the next command		;081
	MOV	@DCLPMT,R3		;Assume read w/normal prompt	;081
	BIT	#LOGACT,ICFFLG		;Log file active?		;081
	BEQ	10$			;Branch if not			;081
	MOV	@LOGPMT,R3		;Read with log file prompt	;081
10$:	ADD	#S.SLEN,R3		;Point to string		;081
20$:	BIC	#NOPROM,ICFFLG		;Clear no-prompt flag for next time ;083
	RETURN				;All set			;081

.DSABL	LSB

.SBTTL	UNK.CMD	-- Process an unknown command.
;+
; UNK.CMD -- Process an unknown command.
; 
; DESCRIPTION:
;	Control is passed here if the command did not match any of the 
;	command keywords in the PARCMD table.  We fetch the entire command
;	and put it into core common.  It is tried as a CCL by setting the 
;	type as unknown.  If that fails, it is flagged as ?Invalid command.
;-

UNK.CMD:$THR
	$DEFCMD
	$PARM	PARM1,U$REST,PF.OPT!PF.SEP;Parse rest of command line...
	$ENDCMD
	$FETP	PARM1			;Get everything on command line
					;except for $.
	$IF	PRESENT			;If anything there then
	PUTSTR				;  Put it into TRNBUF.
	SETTYP	UNKTYP			;  Flag unrecognized command, so we'll
					;  try it as a CCL.
	$ENDIF				;Else it's a no-op.
	$ENDTHR

.END
