.INCLUDE	/CMN:COMMON.MAC/
.INCLUDE	/CMN:KERNEL.MAC/
.LIBRARY	/CUI:CUIMAC.MLB/
.LIBRARY	/DCL:DCLMAC.MLB/
.NLIST
.INCLUDE	/CMN:PFBDEF.MAC/
.INCLUDE	/CMN:KBDEF.MAC/						;074
.INCLUDE	/DCL:DCLPFX.MAC/
.LIST
TITLE	DCLCFP,<DCL File Processor Commands>,0I,21-FEB-92,SDL/JFM/GMB/BGN/BTK/BTB/DLS
;
;		COPYRIGHT (c) 1974, 1990 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR DCLCFP
;+
;  001	SDL  12-Jul-83	Creation 
;  002  SDL  13-Oct-83  Set up error position for numerous error messages 
;  003  SDL  21-Oct-83  Changed register usage in CNVBIN routine
;  004  SDL  24-Oct-83  Added apostrophe substitution routine APOSUB
;  005  SDL  02-Nov-83  Added command synonym substitution routine CMDSUB
;  006  SDL  15-Nov-83  Removed the routines ANLASG, EXPEVL and CNVBIN
;  007  SDL  16-Nov-83  Moved CNVSTR routine into DCLEXP.MAC
;  008  SDL  08-Dec-83  Fixed up the error messages being generated
;  009  SDL  29-Dec-83  Allow for the symbol name abbreviation field
;  010  SDL  10-Jan-84  Moved label checking code to DCLSYM
;  011  SDL  11-Jan-84  Moved APOSUB and CMDSUB routines to DCLCMD
;  012  SDL  12-Jan-84  Added the IF ... THEN ... command
;  013  SDL  16-Jan-84	Added the GOTO command
;  014  JFM  19-Jan-84  Added EXIT, SET and STOP commands
;  015  SDL  10-Feb-84  Added the @ command
;  016  SDL  22-Feb-84  Added the GETCHN, RTNCLS, RTNCHN and CLSICF subroutines
;  017	JFM  22-Mar-84  Added SET VERIFY, SET DATA and SET LOGFILE commands
;  018  SDL  27-Mar-84  Removed common code from DSYM.CMD and SHSM.CMD
;  019  JFM  29-Mar-84  Added the INQUIRE command
;  020	SDL  30-Apr-84	Added the SET [NO]ON, SET [NO]CONTROL_C and ON ... THEN
;			commands
;  021	SDL  21-Jun-84	Made changes to account for the global and local symbol
;			table being in core at the same time
;  022	SDL  29-Jun-84	Changed "?Unsatisfied GOTO command" to "?Undefined
;			label <LABEL>" message
;  023	SDL  05-Jul-84	Fixed ON ... THEN ... commands so they return "?THEN 
;			keyword required"
;  024	SDL  09-Jul-84	Fixed IF ... THEN ... to return "?Expression too
;			complicated" when too deeply nested on one line
;  025	JFM  09-Jul-84  Changed CLSICF routine to a more general CLSPFB routine
;  026	SDL  11-Jul-84	Save and restore the END_OF_DATA character when in
;			nested command procedures
;  027	SDL  12-Jul-84	Save and restore the SET [NO]DATA setting when in
;			nested command procedures
;  028	SDL  13-Jul-84	Require a command line which contains a label to begin
;			with a dollar sign before adding it to symbol table
;  029	SDL  17-Jul-84	ON <...> THEN GOTO ... with a forward branch no longer 
;			goes into an infinite loop when a CTRL/C or the 
;			specified error condition has occurred
;  030	JFM  18-Jul-84  Made SET VER/WATCH and /NOP set bits in new WATFLG 
;  031	JFM  19-Jul-84  Cleared RUN comfile flag after through with it
;  032	SDL  20-Jul-84	The action of an ON <...> THEN ... command cannot
;			contain a command line label
;  033	SDL  22-Jul-84	Fixed INQUIRE command so that it checks for valid
;			symbol name characters and allows symbol abbreviations
;  034	JFM  23-Jul-84  Fixed bug in ?Undefined label error message 
;  035	JFM  28-Jul-84  CLOSE/LOGFILE no longer returns error if log not open
;  036	SDL  02-Aug-84	Removed some file lookup code from the @ command
;  037	SDL  08-Aug-84	Fixed @ command to open a command file immediately so a
;			nested ICF isn't saved away if new file doesn't exist
;  038	SDL  14-Aug-84	Handle cases where the symbol table file doesn't exist
;			or an error occurs when doing I/O to it
;  039	JFM  17-Aug-84  Changed default for SHOW SYMBOL to /ALL and fixed EXIT
;  040	SDL  22-Aug-84	Closed the PFB channels upon EXITing or STOPping that
;			F$SEARCH opened
;  041	SDL  23-Aug-84	Changed ICFSTK to be a table of bytes, not words
;  042	JFM  14-Sep-84  Removed references to previous RTS's
;  043	SDL  17-Sep-84	Added code for the OPEN and CLOSE of data files
;  044	SDL  19-Sep-84	Allowed /ALL qualifier with a parameter on many commands
;  045	JFM  25-Oct-84	Added the SET [NO]ECHO command
;  046	SDL  16-Nov-84	Removed code from EXIT command and had it call CLSF$S
;			routine to close F$SEARCH's PFB channels
;  047  GMB  04-Dec-84  Added new qualifer INQUIRE/WAIT.
;  048	JFM  20-Dec-84	CHKCHN allows qualifiers after channel number
;			.CHAIN is done if open fails, OPEN/LOG/WRITE guarentees
;			write access, READ/DELIM was backwards
;  049	GMB  27-Feb-85	Fixed READ of RMS files, echo handling in INQUIRE
;  050	GMB  28-Feb-85	Made FWRITE output even if SET NOECHO is in effect.
;  051  GMB  14-Apr-85  Made @ command SET DATA & SET DATA/END_OF_DATA="$"
;
;			[V9.3]
;
;  052  GMB  02-Dec-86  Maintain ICF file size for monitor
;
;			[V9.4]
;
;  053  GMB  16-Feb-87  Added GOSUB/RETURN commands and support
;			Revised GOTO command to share code with GOSUB,
;			... save position before searching for label, return to
;			... position and repaint command if label not found.
;			GOTO & GOSUB say "?Invalid label" if none given
;			Removed "D " hack to run .COM files from IND.CMD
;			Removed code to flag EOF in IND.CMD
;			Removed code to use EOF flag in EXI.CMD
;			READ routine now returns line length (minus CRLF)
;			READ routine now exits with R0 = 0 if no error
;			Fixed "@foo +1" bug - no longer strips "+" off
; 054  GMB  27-Feb-87	Handle symbol table full errors in DOGOTO & DOGOSUB
; 055  GMB  23-Mar-87	Replaced STFILE flag. Miscellaneous clean up.
; 056  GMB  24-Feb-87	Reversed logical sense of STFILE flag
; 057  JJT  12-Apr-87	Change NAMLEN to NAMLNG
; 058  JFM  11-May-87	Fixed bug where RETURN [status] didn't take error path.
; 059  BGN   4-Aug-87   Fix DOPFBW routine - source clear 20.1.8
;
;			[RSTS/E V9.7]
; 060	JFM  06-Sep-88	Fix bug in CHKSN call, it sets up LX.ERP just fine
; 061	JFM  16-Sep-88	No need to call PARDOL before PARLBL.  Don't use
;			CALB to LX.BLA or LX.EOS, just CALL them.  Remove
;			IFCNTR, no more restriction due to U$CALL fix.  Remove
;			unneeded code here and there.
; 062	JFM  27-Nov-88	Fix bug in $RETURN: Set ERRFLG with current status
; 063	BTK  08-Dec-88	Fixed bug (# 6267) causing occasional improper handling 
;			of errors on com file open.  Took out globalization of 
;			SRHABB.  (BUG 7010)
; 064	BTK  18-Dec-88	Make SRHABB truly external (not in DCLPFX).
;
;			[RSTS/E V10.0]
; 065	BTB  24-Oct-89	Set $STATUS in monitor on EXIT w/out status (for Batch)
; 066	BTB  18-Dec-89	Remove ;065 except for setting bit in FQPROT
; 067	BTB  07-Feb-90	Fixed bugs in GOSUB and GOTO; merged DOGOSUB into
;			GOSUB.CMD
; 068	JFM  02-Mar-90	Use different entry when calling U$RDMOR, use U$RDM1
; 069	BTB  27-Apr-90	Globalize FWRITE for ASSIGN/USER/REPLACE=QUERY
; 070	JFM  16-May-90	Clear typeahead and print message if INQUIRE times out
; 071	BTB  04-Jun-90	Correct ^ placement for SET LOG_FILE errors
; 072	JFM  08-Aug-90	Keep track of /TIMESTAMP in ICFFLG
;
;			[RSTS/E V10.1]
; 073	DLS  20-Jun-91	Remove INQUIRE timeout message
; 074	JFM  21-Jun-91	Include KBDEF, set RDMOD to TI.NCH before reading line
;			in RETURN.
; 075	DLS  09-Jul-91	Store the log file and procedure file filespec on open
; 076	JFM  12-Jul-91	Change name of variable
; 077	DLS  02-Aug-91	Index PROFIL off of LCAPTR (bug introduced in 075)
; 078	DLS  16-Jan-92	Clear first word of LOGFIL on CLOSE/LOG and changed
;			routine CHKLOG to TST LOGFIL for LOG file open
; 079	DLS  16-Jan-92	Fix error arrow position on open/write
; 080	DLS  18-Feb-92	Fixed many problems in OPEN/LOG and some clean-up
;-

;+
; DCLCFP - DCL File Processor Commands
;
; This module contains the command definitions for those commands 
; relating to Indirect Command File processing.  
; 
;
;-
	.PSECT	DCLCFP,RO,REL,CON
	DEFORG	DCLCFP

	.MCALL	$DISALLOW,LOOKUP
	.MCALL	PUTSTR,$MOV,$MOVV,$MOVB,$BIC,$BIS,$CLR,$CHECK

	$CUI	TABLE		;Include macros for CUI tables

; Macros used in this module

.MACRO	CHKCHN	PARM,MINVAL,QUAL
	.WORD	CHKCHN,PARM,MINVAL,QUAL
	.ENDM	CHKCHN

.MACRO	$CHKSN								;060
	.WORD	$CHKSN
	.ENDM	$CHKSN

; Variables
	TMPORG	IMPURE
BORFLG:	.WORD			;Flag indicating entire record read or not
	UNORG			;on a READ command

.SBTTL	@ command 
;+
; @file-spec  [p1 p2 p3 p4 p5 p6 p7 p8]
; 
; DESCRIPTION:
;	This command executes an Indirect Command Procedure.  "file-spec" 
; 	is the command file to execute, and .COM is the default file type.
; 	The ICF may be disk, magtape (DOS format only), card reader, DECtape
;	or paper tape. 	P1 - p8 are eight optional parameters passed to the 
;	command procedure.  They are assigned string values and placed in the
;	local symbol table for the current command procedure.  Any parameters 
;	not passed are set to the null string "".  The local symbols p1-p8 
;	can be manipulated just like any other symbol (that is, they can be 
; 	assigned new values or deleted by the user).
;
; 	The maximum level to which command procedures can be nested is 14
;	(13 inactive ICFs, which are kept on PFB channels, and 1 active ICF,
;	which is kept on the active PFB channel).  However, this value is 
; 	dependent on the number of DCL files open for reading or writing 
;	(via the $OPEN command); each open file requires one channel also.
;	Therefore, the number of DCL files open at one time combined with 
;	the # of open command procedures cannot exceed 14.
;
;	The @ command does the equivalent of SET DATA/END_OF_DATA="$"
;	before command file processing begins.  This insures that program
;	input will be taken from the command file.
;
; 	There are no qualifiers for this command.
;
;
; INPUTS:
; 	STFILE = flag indicating if the symbol table file exists on disk
;		 or could not be created
;
; OUTPUTS:
;
;   If an error did not occur:
;	CURPTR = address of next available byte in local symbol table
;	ENDUSE = address of last byte used for the local symbols P1-P8
; 	CMDLVL = is incremented 
;	LERFLG = 1 to indicate that error checking is enabled (default)
;	LCCFLG = 1 to indicate that CTRL/C checking is enabled (default)
;	LSEVLV = the level of severity that error checking is in affect for
;
; Errors returned to the user's terminal are:
;
; 	U.WLD  = "?Wildcards not allowed"  
;		  (ex. @FOO.*,  @*.COM)
;
;	U.TOOP = "?Too many parameters"
;		  (ex. @FOO 1 2 3 4 5 6 7 8 9)
;
;	NOCH.E = "?No channels available"
;		  (an I/O or PFB channel is not available; returned by GETCHN
;		   or CLSPFB routines)
;
;	U.IFIL = "?Invalid file specification"
;		  (the user's command file was not disk or DOS magtape)
;
;	U.FIEX = "?File does not exist"
;		  (the user's command file did not exist)
;
;	UNCR.E = "??Unable to create DCL work file"
;		  (the user's symbol table file does not exist on disk so 
;		   don't let the user RUN or issue an @ of a command file)
;
;	UNCP.E = "?Unable to copy tape command file to disk"
;		  (the user's tape command file could not be copied to a 
;		   temporary disk file for processing)
;
;	I/O errors are possible also.
;
; 	Many errors are regarded as a syntax error and control is returned
;	to the calling ICF, where processing continues.  Other are more
;	severe and are regarded as fatal errors, so control is returned to 
;	the interactive	level, thus closing all ICFs.
;
;
;
; TPCHAN, DSKCHN and IOCHAN are working cells, internal to this routine.  
; TPCHAN has the I/O channel # (*2) of where the non-disk ICF was opened, and
; DSKCHN has the I/O channel # (*2) of where the temporary scratch disk file 
; is opened since the command file was non-disk.  IOCHAN has the I/O channel # 
; (*2) which is used when moving the calling ICF from its active state to an 
; inactive state.
;-

IND.QL:	ENDQUAL				;Indicate that no qualifiers are to be
					; parsed (any qualifiers passed become
					; parameters to the @ command)

; Define CUI thread to implement $BGTB - execute IF portion if
; specified byte variable is GT 0.
;
;	$BGTB	variable_to_test,branch_if_true_label

.MACRO	$BGTB	VALUE,LABEL
	.WORD	U$BGTB,VALUE,LABEL
.ENDM

U$BGTB:	TSTB	@(R3)+			;Check byte variable value
	IFGT				;If it's GT 0 then
	MOV	(R3),R3			;  Go to label
	ELSE				;Else
	TST	(R3)+			;  Continue
	ENDIF				;Endif
	RETURN				;Return

IND.CMD::$THR
	$DEFCMD QUAL=IND.QL		;Point to the qualifier list
;
; If this is a RUN/CHAIN of a .COM file then we want to skip parsing
; the first parameter because it isn't there.
;
	$BGTB	RUNCOM,1$		;If RUNCOM GT 0 then this is a
					;... RUN/CHAIN of a .COM file so
					;... skip parm1
	$PARM	PARM1,TYPE=LF.N,FLAGS=PF.SEP!PF.NLS,PROMPT=COMF$P
					;Parse filespec, no space required 
					;... before it (PF.SEP), parameter
					;... list separators do not apply
					;... after it (PF.NLS), prompt if
					;... necessary
1$:	$PARM	PARM2,TYPE=U$REST,FLAGS=PF.SEP!PF.OPT
	$ENDCMD				;Put the rest into PARM2,space optional

	$DO				;
	TSTB	STFILE			;Does symbol table file exist on disk ?
	IFEQ				;If not then
	MOV	#UNCR.E,R0		;  ??Unable to create DCL work file
	RETURN				;  Return without executing the ICF
	ENDIF				;Endif

	MOV	SP,SAVSTP		;Save the stack pointer
	CLR	TPCHAN			;Clear out channel # for non-disk files
	CLR	DSKCHN			;Clear out channel # for temp disk file
	CLR	IOCHAN			;Clear out the channel # for keeping
					; the calling ICF (move old ICF from 
					; PFB to IOB)
	TSTB	RUNCOM			;Is this a run of a .COM file?
	IFNE				;If so then
	BIS	#100000,IOBCHN		;  File is already opened on channel 15
	JMP	STDISK			;  Mark 15 as used, go do disk stuff.
					;   (no need to copy it to temp disk
					;    file)
	ENDIF				;Endif

	CALB	FSSFIL <#1>		;Fetch and FSS the filespec 
					; (defaults to .COM)
	.ASSUME DSKHND EQ 0		;Assume disk handler index is 0
	TSTB	XRB+XRMOD		;Is it a disk file ?

; Open the disk command file to determine whether it exists or not.  Otherwise,
; if we're in a nested ICF already and attempt to execute another ICF, which
; does not exist, then we don't want to move the current ICF to an inactive
; PFB channel or set up a new local symbol table.

	IFZE				;If so
	MOV	IOBCHN,R4		;  Load up bit mask for IOB channels
	CALL	GETCHN			;  Get an I/O channel
					;   (returns R1 = channel # *2)
	BCS	9$			;  If a channel is not available, exit
					;   (get out of all higher level ICFs)
	MOV	R1,DSKCHN		;  Put channel # here so that it will
					;   be returned on an error
	MOV	R4,IOBCHN		;  Update the bit mask
	MOVB	#OPNFQ,FIRQB+FQFUN	;  'Open a file on a channel'
	MOV	R1,FIRQB+FQFIL		;  I/O channel number (*2)
	MOV	#OP$MOD!OP$RO,FIRQB+FQMODE 
					;  Mode = 'real mode', 'read-only'
	CALL	DOCFIP			;  Open the file		;080
	IFCS				;  If an error occurred
					;    R1 = channel # (*2)
	MOV	IOBCHN,R4		;    Load up I/O channels bit mask
	CALL	RTNRST			;    Reset and return the I/O channel
					;     (no errors possible)
	MOV	R4,IOBCHN		;    Update the bit mask
	CLR	DSKCHN			;    Clear disk chn since done with it
	MOV	#SUBBUF,R1		;    Set up to copy parameters into 
	MOV	U.CMN+U.POS,LX.ERP	;    Anything that happens in here is
					;     something wrong in filespec
	PUSH	R0			;    Save error code
	CALBX	FET.P	<#PARM2>	;    Fetch pointer to string
	POP	R0			;    Restore error code
	CLR	R2			;    Assume no characters to move
	TST	U.CMN+U.PRES		;    Were any paramters passed?
	BEQ	2$			;    No, go do .CMDLN and .CHAIN
	MOV	CMDLEN,R2		;    Get length of command
	SUB	U.CMN+U.POS,R2		;    Compute length of arguments
	INC	R2			;    Adjust for subtraction
2$:	MOV	R2,R5			;    Copy length of parameters
	BEQ	5$			;    No parameters to move
	MOV	#CMDBUF-1,R4		;    Point into command buffer
	ADD	U.CMN+U.POS,R4		;    Point to parameters
4$:	MOVB	(R4)+,(R1)+		;    Insert parameters into SUBBUF
	SOB	R2,4$			;      until done
	CALLX	CLRXRB			;    Clear the XRB
	MOV	R5,XRB+XRLEN		;    Store byte count.
	MOV	R5,XRB+XRBC		;    Copy command length
	MOV	#SUBBUF,XRB+XRLOC	;    Point at parameters
	.CMDLN				;    Move command line
	CALLX	U$CHKE			;    Abort if error
5$:	PUSH	R0			;    Save error code
	CALBX	SAVSTB			;    Save the symbol table
	CALB	FSSFIL <#1>		;    FSS the file name
	POP	R0			;    Restore error code, in case .CHAIN 
					;    fails
	MOV	R5,FIRQB+FQNENT		;    Set parameter word to non-zero if
					;    ... there are parameters, zero if
					;    ... none
	.CHAIN				;    Do a .CHAIN 1st and if it succeeds,
					;    then it automatically will go to 
					;    P.NEW.  If it fails, then we will 
					;    error anyway.  This is if we have 
					;    execute but not read access <104>
	MOV	R0,-(SP)		;    Save the error code temporarily
	REPAINT	LX.ERP			;    Repaint the command line pointing
					;     at the filename 
	MOV	(SP)+,R0		;    Restore the error code
	CMP	R0,#NOSUCH		;    Is it "?Can't find file or acct" ?
	IFZE				;    If so
	MOV	#U.FIEX,R0		;      Return "?File does not exist"
	ENDIF				;    Endif
9$:	BR	30$			;    Exit and return IOB channel
	ENDIF				;  Endif - no error occurred

					;  R1 = channel # (*2)
	MOV	IOBCHN,R4		;  Load up I/O channels bit mask
	CALL	RTNRST			;  Reset and return the I/O channel
					;   (no errors possible)
	MOV	R4,IOBCHN		;  Update the bit mask
	CLR	DSKCHN			;  Clear disk chn since done with it
	JMP	STDISK			;  No need to copy ICF to temp disk file
	ENDIF				;Endif

	CMPB	XRB+XRMOD,#MTAHND	;Is it a magtape file ?
	BEQ	10$			;Yes - only DOS format is allowed
	MOV	#U.IFIL,R0		;No, "?Invalid file specification"
	BR	30$			;Get out of all higher level ICFs

; Open the non-disk Indirect Command File.

10$:	MOV	IOBCHN,R4		;Load up the bit mask for IOB channels
	CALL	GETCHN			;Get an I/O channel
					; (returns R1 = channel # *2)
	BCS	30$			;If a channel is not available, exit
					; (no channels to return)
	MOV	R1,TPCHAN		;Set up the tape's I/O channel # (*2)
	MOV	R4,IOBCHN		;Update the bit mask
					;Don't reclear FIRQB and XRB since FSS
	MOVB	#OPNFQ,FIRQB+FQFUN	;Function = 'Open a file on a channel'
	MOV	R1,FIRQB+FQFIL		;I/O channel number (*2)
	;CLR	FIRQB+FQMODE 		;Don't specify any mode (use what FSS
					; returns)
	CALL	DOCFIP			;Open the file			;080
	BCS	30$			;Return tape channel if error

; Determine if it's DOS magtape.

	CALLX	CLRFQX			;Clear the FIRQB and XRB
	MOV	#7,XRB+XRLEN		;Function='Return file characteristics'
	;CLR	XRB+XRBC		;Parameter word is unused
	MOVB	TPCHAN,XRB+XRCI		;I/O channel # (*2) it's open on
	MOVB	#MTAHND,XRB+XRBLKM	;Handler index for magtape
	.SPEC				;Get the tape file characteristics
	CLR	R0			;
	BISB	FIRQB,R0		;Error occur ?
	BNE	30$			;Yes, return the tape channel
	MOV	#U.IFIL,R0		;Load up "?Invalid file specification"
	TST	XRB+XRBC		;Is it DOS format ?
	BNE	30$			;No, so return tape channel and error
					;Yes, so continue

; Create a scratch disk file.

	CALLX	CLRFQB			;Clear the FIRQB
	MOVB	#CRTFQ,FIRQB+FQFUN	;Function = 'Create/open a temp file'
	MOV	IOBCHN,R4		;Load up the bit mask for IOB channels
	CALL	GETCHN			;Get an I/O channel
					; (returns R1 = channel # *2)
	IFCS				;If a channel is not available
30$:	JMP	160$			;  Exit, return tape channel only
	ENDIF				;Endif

	MOV	R1,DSKCHN		;Save the I/O channel # (*2)
	MOV	R4,IOBCHN		;Update the bit mask
	MOVB	R1,FIRQB+FQFIL		;IOB channel # (*2)
	;CLR	FIRQB+FQSIZ		;Set initial block allocation = 0
					; (pre-extend the file later)
	;CLRB	FIRQB+FQSIZM		;
	;CLR	FIRQB+FQDEV		;Set disk device = SY: (not SY0:)
	MOV	#OP$TEN!OP$MOD,FIRQB+FQMODE ;Mode = 'tentative' and 'real'
	CALL	DOCFIP			;Go create the file		;080
	BCS	48$			;Print message, and then return tape
					; and disk channels if error
					; (R0 = error code)

; Transfer the non-disk Indirect Command File to the scratch disk file.
;
; Optimization note:
;	All we need for a tape buffer is 512 bytes.  The old code used the
;	local symbol table space.  If (for some unknown reason) writing
;	out and using the global table is not satisfactory then you might
;	want to allocate 512 bytes from the symbol table.
;
	CALBX	SAVSTB			;Save global symbol table so we
					;... can use its memory as a buffer
	BCS	48$			;Print message, exit if error occurs
					; (return tape and disk channels)

; Read a block of the non-disk command file.

; ?? Send an informational message to the user that this copy operation is
;    taking place (ex. "Copying <file-spec> to ...").

DOREAD:
	CALLX	CLRFQX			;Clear FIRQB and XRB buffers
	MOV	#512.,XRB+XRLEN 	;Size of input buffer in bytes
       	;CLR	XRB+XRBC		;Must = 0
	MOV	#GCA,XRB+XRLOC 		;Starting address of input buffer
					; (at global context area)
	MOVB	TPCHAN,XRB+XRCI 	;Tape IOB channel # (*2)
       	;CLRB	XRB+XRBLKM		;Clear MSB of block #
       	;CLR	XRB+XRBLK		;Clear LSB of block # (0 = next)
	.READ				;Read one block of the user's file
	CLR	R0			;Ensure high byte is clear
	BISB	FIRQB,R0		;Put error code into R0
	IFNZ				;If an error occurred
	CMPB	R0,#EOF			;  Reached end-of-file on ICF ?
	BEQ	CLSTAP			;  Yes, so close tape channel, continue
	BR	48$			;  No, some other error so exit
					;   (return tape and disk channels)
	ENDIF				;Endif

; Write the block to the scratch disk command file.

DOWRIT:
	CALLX	CLRFQX			;Clear the FIRQB and XRB
	MOV	#512.,XRB+XRLEN 	;Size of output buffer in bytes 
	MOV	#512.,XRB+XRBC  	;# of bytes to write out
	MOV	#GCA,XRB+XRLOC	 	;Start addr of global context in buffer
	MOVB	DSKCHN,XRB+XRCI 	;Disk IOB channel # (*2)
	;CLRB	XRB+XRBLKM		;Clear MSB of block #
	;CLR	XRB+XRBLK		;Clear LSB of block # (0 = next)
	.WRITE				;Write the work buffer to symbol file
					; (write a block of tape command file 
					;  to the temp disk command file)
	CLR	R0			;Clear out R0
	BISB	FIRQB,R0		;Move the error code into R0
	;TSTB	FIRQB			;Error occur ?
	BEQ	DOREAD			;No, so continue reading 
48$:	MOV	#UNCP.E,R1		;"?Unable to copy tape command file
					; to disk"
	CALL	DOCMES			;Print error message on user's terminal
					; (R0 = saved FIRQB error code upon
					;       returning so can still use it)
50$:	JMP	160$			;Yes, return tape and disk channels

; Close the tape file. 
	
CLSTAP:	MOV	TPCHAN,R1		;Tape I/O channel # (*2) to return
	MOV	IOBCHN,R4		;Load up I/O channels bit mask
	CALL	RTNRST			;Reset and return the I/O channel
					; (no errors possible)
	MOV	R4,IOBCHN		;Update the bit mask
	CLR	TPCHAN			;Flag that this channel was closed
	CALBX	RESSTB			;Restore the global symbol table
	BCS	50$			;Quit if error

; Write the symbol table that's in core (in the work buffer) out to the symbol
; table file.

STDISK:
	BIT	#ICFACT,ICFFLG		;Is an ICF currently active?
	BEQ	65$			;No, came from interactive level

; -- An ICF invoked this ICF --
; Get a PFB channel to keep the current ICF on for safe keeping while the newly
; invoked ICF resides on the active PFB channel.  If this fails, then exit 
; immediately (user must first close another ICF or data file).

	MOV	PFBCHN,R4		;Load up bit mask for PFB channels
	CALL	GETCHN			;Get a PFB channel
					; (returns R1 = PFB channel # *2)
	BCS	50$			;If a channel is not available, exit
					; (return disk channel)
	MOV	R4,PFBCHN		;Update the bit mask 
	DEC	NXISTK			;Addr next availble byte on ICF stack
	MOVB	R1,@NXISTK		;Save PFB channel # (*2) on stack
	MOV	LCAPTR,R1		;Get pointer to local context area
	MOV	RCDSIZ(R1),-(SP)	;Save record size of ICF we're leaving
	MOVB	RCDFMT(R1),-(SP)	;Save the record format of ICF
	CALBX	PSHSTB			;Write the higher-level local table
					; to the symbol table file 
					; (for non-disk ICF it was already
					;  written out)
	IFCS				;If an error occured,
60$:	JMP	150$			;  Exit, return PFB & disk channels
	ENDIF				;Endif

	TSTB	LCCFLG(R1)		;Is current state "NOCONTROL=C"?
	BNE	67$			;No,okay

; -- Came from interactive level, or SET NOCONTROL=C was in effect.  Clear
;    out the CC bit so we don't exit before we can begin. --

65$:	CALLX	READCC			;Read and reset the CTRL/C flag.  
	CLRB	DCLFLG			;This is an important step	;076
67$:	CALLX	INILCL			;Initialize the local symbol table
	BCS	2110$			;If we get an error then punt
					;... Go return PFB and disk channels,
					;... and EXIT to the calling ICF
					;gmb // Can we do anything better? //

; The 2nd parameter is fetched, which might not be there, to set up the local
; symbols P1-P8 using the values passed on the @ command line.

	MOV	#LCLPRM,R1		;Point to list of local parameter names
	CALBX	FET.P <#PARM2>		;Fetch rest of command line 
	TST	U.CMN+U.PRES		;Were any parameters passed ?
	BEQ	90$			;No, equate P1 to P8 to null string
	MOV	U.CMN+U.POS,LX.POS	;Yes, reset the scan position

;gmb // This section and the next should be combined into one //

; The expression evaluation type of -1 instructs DCLEXP to stop at any
; unquoted space.  

80$:	MOVB	(R1)+,NAMLNG		;Set up symbol name length	
	MOV	R1,NAMADR		;Set up address of symbol name 
	CLRB	NAMABB			;Set abbreviation point = 0 (none)
	MOV	LCAPTR,SCOPE		;This is a local assignment
	MOVB	#STRTYP,TYPE		;Symbol type is string
 	CLR	R2			;Ensure high byte is clear
	BISB	NAMLNG,R2		;Length of symbol name
	ADD	R2,R1			;Point to next local symbol in table
	MOV	R1,-(SP)		;Save pointer to next parameter name
	MOVB	#-1,EVLTYP		;Set evaluation type to @ param
	CALLX	EXPEVL			;Evaluate the parameter (ex. @FOO "a"b)
					; (no errors possible)
	INCB	NEWENT			;This is a new entry (so don't waste
					;... time searching for it)
	CALLX	ADDSYM			;Add symbol to local table (sets LCLNFG)
2110$:	BCS	110$			;If we get an error then punt
					;... Go return PFB and disk channels,
					;... and EXIT to the calling ICF
					;gmb // Can we do anything better? //
	MOV	(SP)+,R1		;Restore pointer to next local parm name
	CALLX	LX.BLA			;Parse optional blanks		;061
	CALLX	LX.EOS			;Are we at end of string?	;061
	BCC	90$			;Yes - all of the passed parameters are
					; set up as local symbols
	CMP	R1,#ENDLP		;No, are we at the end of the table ?
	BLT	80$			;No,80$ - there are more local symbols
					; to set up using the passed parameters
					;Yes, and should be at end of the line
	REPAINT	LX.POS			;Repaint command with error position
	MOV	#U.TOOP,R0		;"?Too many parameters" error
;gmb // is this next line needed? //
	MOVB	#1,GBLNFG		;Indicate that global context changed
	BR	110$			;Return PFB and disk channels,
					; and EXIT to the calling ICF since
					; it's regarded as a syntax error

; Any of the parameters P1-P8 which are missing on the @ command line are set 
; to the null string "".

90$:					;R1 = pointer into local parm table
	CMP	R1,#ENDLP		;Are we at the end of the table ?
	BGE	100$			;Yes, so exit (exactly 8 parameters 
					; were passed)
	MOVB	(R1)+,NAMLNG		;No, set up name length
	MOV	R1,NAMADR		;Set up name address
	MOVB	#STRTYP,TYPE		;Set entry type = 'string'
	CLRB	NAMABB			;Set abbreviation point = 0 (none)
	CLRB	VALLNG			;Set it to the null string ("")
					; (VALADR is ignored)
	MOV	LCAPTR,SCOPE		;Set symbol scope to local
 	CLR	R2			;Ensure high byte is clear
	BISB	NAMLNG,R2		;Length of symbol name
	ADD	R2,R1			;Point to next local symbol
	MOV	R1,-(SP)		;Save pointer to local parameter names
	INCB	NEWENT			;This is a new entry (so don't waste
					;... time searching for it)
	CALLX	ADDSYM			;Add parameter to local symbol table
	BCS	110$			;If we get an error then punt
					;... Go return PFB and disk channels,
					;... and EXIT to the calling ICF
					;gmb // Can we do anything better? //
	MOV	(SP)+,R1		;Restore pointer
	BR	90$			;Keep going

100$:	BIT	#ICFACT,ICFFLG		;Was ICF active when this "@" invoked?
	IFEQ				;If not then
	MOV	IOBCHN,R4		;  Load up bit mask for IOB channels
	CALL	GETCHN			;  Get an I/O channel
					;   (returns R1 = channel # *2)
	IFCS				;  If a channel was not available
	JMP	160$			;    Exit, return disk but no PFB chn
					;     (read global table into core)
	ENDIF				;  Endif

	MOV	R1,IOCHAN		;  Save I/O channel # (*2)
	MOV	R4,IOBCHN		;  Update the bit mask 
	JMP	OPNICF			;  Skip around
	ENDIF				;Endif
	MOV	LCAPTR,R2		;Point to local context

; Read the next line in the command file after the @ command. This is the
; line we want to return to on EXIT.  Then get the position of this line so
; we can save it for the EXIT.  In addition, retrieve the end of data
; character from the monitor for the ICF we're leaving (as specified on the SET
; DATA command, or is a $ by default). 

	CALL	READ,R5,<SUBBUF,TEMP01>	;Move to the line after the @ command
					;... using SUBBUF as a junk buffer and
					;... TEMP01 to trash the line length
	IFCS				;If an error occurred
	CMP	R0,#EOF			;  Was it end-of-file?
	BNE	110$			;  No. Some other error.  Exit and
					;  ... return PFB & I/O chan.
					;  We can ignore EOF errors here.
					;  ... They will cause an EXIT
					;  ... eventually.
	ENDIF				;Endif

	CALLX	CLRFQB			;Clear the FIRQB
	MOVB	#STA.PF,FIRQB+FQFIL	;Function = 'Read PFB channel status'
					; (get position of this line in ICF
					;  and the end of data char)
	MOV	#PF$ICF*2,FIRQB+FQNAM1	;PFB channel # (*2) for the ICF
	.PFB				;
	MOVB	FIRQB,R0		;Set the error code up
       ;TSTB	R0			;
	IFNZ				;If an error occurred
110$:	JMP	150$			;  Exit, return PFB and tape channels
	ENDIF				;Endif

	MOVB	FIRQB+FQPROT,EODCHR(R2)	;Save EOD character of ICF we left
					; in new local context area       
	;MOVB	#1,LCLNFG		;Local context was already changed 
	
; Save the return position of the ICF we are temporarily leaving away in the
; local context area of the newly invoked ICF.  It is needed for the EXIT
; command. 

	MOV	#ICFPOS,R1		;Get offset of ICF position cell (in the
					;... local context area)
	ADD	R2,R1			;Compute pointer to ICF cell
	MOV	#FIRQB+FQNAM1+2,R0	;Point to start of ICF pos in FIRQB
	MOV	(R0)+,(R1)+		;Save LSB of the block # 
	MOV	(R0)+,(R1)+		;Save MSB of the block #
	MOV	(R0)+,(R1)+		;Save recordsize of the current record
	MOV	(R0)+,(R1)		;Save byte offset

; Save the current status of the SET [NO]DATA setting so it can be restored
; when we return back to this ICF.

	CALLX	JBFPFB			;Read job flags
	BIC	#^C<J2NDAT>,FIRQB+FQBUFL;Save only the SET [NO]DATA setting
	MOV	FIRQB+FQBUFL,LDTFLG(R2)	;Save data setting of ICF we left in
					; local context of newly invoked ICF
       ;MOVB	#1,LCLNFG		;Local context was already changed

; Move the current Indirect Command File from the active PFB channel to an 
; IOB (temporarily).

120$:	CALLX	CLRFQX			;Clear FIRQB and XRB
	MOV	IOBCHN,R4		;Load up the bit mask for IOB channels
	CALL	GETCHN			;Get an I/O channel
					; (returns R1 = channel # *2)
	BCS	110$			;Exit, if an error occurred
					; (return PFB and I/O channels)
	MOV	R1,IOCHAN		;Save I/O channel # *2
	MOV	R4,IOBCHN		;Update the bit mask 
	MOV	R1,FIRQB+FQPPN		;Specify IOB channel number (*2)
	MOV	#PF$ICF*2,FIRQB+FQNAM1	;Specify PFB channel number (*2)
	CALL	P2I			;Move from PFB to IOB
	IFNZ				;If an error occurred
	JMP	140$			;  Return PFB, IOB and tape channels
	ENDIF				;Endif

; Move from the IOB to another PFB for safe keeping while in another ICF,
; and the new ICF will be on the active PFB channel.

	CALLX	CLRFQX			;Clear FIRQB and XRB
	MOVB	(SP)+,FIRQB+FQSIZM	;Restore the record format
	MOV	(SP)+,FIRQB+FQSIZ	;Restore the record size
	MOVB	@NXISTK,FIRQB+FQNAM1	;Specify PFB channel number (*2)
					;(this was allocated at very beginning)
	MOV	IOCHAN,FIRQB+FQPPN	;Specify IOB channel number (*2)
	CALL	I2P			;Move from IOB to PFB
	IFNZ				;If an error occurred
	JMP	140$			;  Return PFB, IOB and tape channels
	ENDIF				;Endif

; Open the disk Indirect Command File.

OPNICF:	TSTB	RUNCOM			;Is this a run of a .COM file?
	IFNE				;If so then
	MOV	#15.*2,DSKCHN		;  File is open on channel 15
	ENDIF				;Endif
					;R1 = I/O channel # *2 
	TST	DSKCHN			;Scratch disk ICF already open ?
	IFNZ				;If so
	MOV	IOCHAN,R1		;  Get I/O channel # *2 to return
	MOV	IOBCHN,R4		;  Load up I/O channels bit mask
	CALL	RTNRST			;  Reset and return the I/O channel
					;   (no errors possible)
	MOV	R4,IOBCHN		;  Update the bit mask
	MOV	DSKCHN,IOCHAN		;  IOCHAN has the open ICF channel #
	CLR	DSKCHN			;  Flag that this channel was closed
	BR	130$			;  Skip around open code since temp
					;   disk file is already opened
	ENDIF				;Endif

	CALB	FSSFIL <#1>		;Refetch and FSS the filespec 
					; (defaults to .COM)
	MOVB	#OPNFQ,FIRQB+FQFUN	;Function = 'Open a file on a channel'
	MOV	IOCHAN,FIRQB+FQFIL	;I/O channel number (*2)
					; (use channel already allocated and 
					;  used for I2P.PF, but done with)
	MOV	#OP$MOD!OP$RO,FIRQB+FQMODE ;Mode = 'real mode' and 'read-only'
	CALL	DOCFIP			;Open the file			;080
	BCS	140$			;Exit if an error occurs

; Read the file attributes, and move this IOB channel to the active PFB 
; channel so the monitor knows this is a new command file.  The PFB will 
; start handing me command files next time I ask for them.  

130$:	CALLX	CLRFQB			;Clear the FIRQB 		;075
	MOVB	#UU.FCB,FIRQB+FQFUN 	;Get open channel statistics	;075
	MOV	IOCHAN,FIRQB+FQFIL	;Set IOB channel number * 2	;075
	ASR	FIRQB+FQFIL		;Make it * 1			;075
	MOVB	#1,FIRQB+FQSIZM		;Subfunction code 1		;075
	.UUO				;Do the directive		;075
	MOV	#FIRQB+FQNAM1+2,R4 	;Point to PPN field		;075
	MOV	LCAPTR,R1		;Point to start of local symbol	;077
	ADD	#PROFIL,R1		;Point to procedure file loc.	;077
	MOV	(R4)+,(R1)+		;Save PPN into proper location	;075
	MOV	(R4)+,(R1)+		;Save name (first word	(RAD50)	;075
	MOV	(R4)+,(R1)+		;	and second word (RAD50));075
	MOV	(R4)+,(R1)+		;Save the file type (RAD50)	;075
	ADD	#6,R4			;Point to device		;075
	MOV	(R4)+,(R1)+		;Save device mnemonic (ASCII)	;075
	MOV	(R4),(R1)		;Save unit number and real flag	;075

	MOV	LCAPTR,R4		;Get pointer to local context area
	MOVB	#1,LERFLG(R4)		;Enable error checking
	MOVB	#ERROR,LSEVLV(R4)	;Set severity level to branch on to
					;... 'error' by default
	MOVB	#1,LCCFLG(R4)		;Enable CTRL/C checking
	MOVB	#1,LCLNFG		;Indicate change in local context 
	MOV	IOCHAN,R1		;Get I/O channel # (*2) of file
	CALL	GETATR			;Get file attributes (returns R1,R2)
	MOV	R1,RCDSIZ(R4)		;Save this ICF's record size in local
					; context area for this ICF
	MOVB	R2,RCDFMT(R4)		;Save this ICF's record format in local
					; context area for this ICF
	MOV	FIRQB+RMSEBL,ICFEBL(R4)
					;Save this ICF's length in blocks (LSB)
	MOVB	FIRQB+RMSEBM,ICFEBM(R4)
					;Save this ICF's length in blocks (MSB)
	MOV	FIRQB+RMSEOF,ICFEOF(R4)
					;Save this ICF's eof byte too


; Move this IOB channel to the active PFB channel so the monitor knows this 
; is a new command file.  The PFB will start handing me command files next 
; time I ask for them.  

;% Optimization note:  This next set of moves to the FIRQB might be
;% done as moves to (Rn)+.  You choose n.

	CALLX	CLRFQX			;Clear FIRQB and XRB
	MOVB	R2,FIRQB+FQSIZM		;Set up the record format
	MOVB	IOCHAN,FIRQB+FQPPN	;Specify IOB channel number (*2)
	MOVB	#PF$ICF*2,FIRQB+FQNAM1	;Specify PFB channel number (*2)
	MOV	R1,FIRQB+FQSIZ		;Set up the record size
	MOV	ICFEBL(R4),FIRQB+FQNAM1+2 ;Set up eof block bumber (LSB)
	MOVB	ICFEBM(R4),FIRQB+FQNAM1+1 ;Set up eof block bumber (MSB)
	MOV	ICFEOF(R4),FIRQB+FQEXT	;Set up eof byte number
	CALL	I2P			;Move from IOB to PFB
	BNE	140$			;If an error occurs, return IOB, PFB
					; and tape channels
	BIS	#ICFACT,ICFFLG		;We are now under an ICF	;063
	INC	CMDLVL			;Increment curr level of command proc
	CLR	R0			;Indicate no error occurred
	MOV	IOCHAN,R1		;Get I/O channel # *2 to return to pool
	MOV	IOBCHN,R4		;Load up I/O channels bit mask
	CALL	RTNCHN			;Return the I/O channel to pool, but
					; don't close it (monitor did)
					; (no errors possible)
	MOV	R4,IOBCHN		;Update the bit mask

	CALLX	CLRFQB			;Clear the FIRQB
	MOVB	#'$,FIRQB+FQPROT	;Set the data character to the default
	CALL	SET.DC			;Go do the .PFB directive
	CALLX	CLRFQB			;Clear the FIRQB again
	MOV	#J2NDAT,FIRQB+FQBUFL	;Set bit to clear NO DATA flag
	CALL	SET.DF			;Go do the .PFB directive

	BR	170$			;Exit
	
; The following code performs any cleanup operations that are needed when an
; error occurs anytime along the way.  The user is, in most cases, returned 
; back to the interactive level since the results would be unpredictable.

140$:	MOV	IOCHAN,R1		;Get I/O channel # *2 to return
	MOV	IOBCHN,R4		;Load up I/O channels bit mask
	CALL	RTNRST			;Reset and return the I/O channel
					; (no errors possible)
	MOV	R4,IOBCHN		;Update the bit mask

; Return PFB channel # of where the old ICF was to be kept for safe keeping. 
; To reach here, the old ICF is still active (the new one never became
; active), so don't try to activate it.

150$:
	CMP	NXISTK,#ICFSTK		;Called from another ICF ?
	BHIS	160$			;No, so continue on (at level 0)
	MOVB	@NXISTK,R1		;Get PFB channel number (*2)
	INC	NXISTK			;Address of next available byte on ICF
					;... stack
	MOV	PFBCHN,R4		;Load up PFB channels bit mask
	CALL	RTNCHN			;Return the PFB channel (in R1)
					; (no errors possible)
	MOV	R4,PFBCHN		;Update the bit mask

; Return the I/O channel where the non-disk command file was opened on, and 
; also the I/O channel where the temporary disk scratch file was opened on.

160$:	TST	TPCHAN			;
	IFNZ				;If it was a tape Indirect Command File
	MOV	TPCHAN,R1		;  Get I/O channel # *2 to return
	MOV	IOBCHN,R4		;  Load up I/O channels bit mask
	CALL	RTNRST			;  Reset and return the I/O channel
					;   (no errors possible)
	MOV	R4,IOBCHN		;  Update the bit mask
	ENDIF				;Endif

	TST	DSKCHN			;
	IFNZ				;If a scratch disk file was open
					; (user specified a non-disk ICF)
	MOV	DSKCHN,R1		;  Get I/O channel # *2 to return
	MOV	IOBCHN,R4		;  Load up I/O channels bit mask
	CALL	RTNRST			;  Reset and return the I/O channel
					;   (no errors possible)
	MOV	R4,IOBCHN		;  Update the bit mask
	ENDIF				;Endif

	MOV	R0,R1			;Pass the error message in R1
	CALL	DOCMES			;Print error message on user's terminal

; In the future, if we want to STOP on certain errors, this is
; the place to do it.
		
168$:	MOV	#U.QUIT,R0		;Quit upon returning
170$:	CLRB	RUNCOM			;Finished looking at this flag
					; (RUN of a .COM file)
	MOV	SAVSTP,SP		;Restore the original stack pointer 
	$ENDDO				;This either prints an error and dies,
					; or we are now in the Indirect Command
					; File and doing fine
	$ENDTHR				;
GLOBAL	<U.TOOP,U.CMN,U.QUIT,U.IFIL,UNCP.E,UNCR.E>
GLOBAL	<SCOPE,NAMADR,NAMLNG,NAMABB,NEWENT,EVLTYP,GCA>
GLOBAL	<LX.POS,CMDLVL,SAVSTP,LCLPRM,ENDLP,LCCFLG,DCLFLG>
GLOBAL	<NXISTK,IOCHAN,TPCHAN,DSKCHN,IOBCHN,PFBCHN,RCDSIZ,RCDFMT,ICFPOS>
GLOBAL	<LERFLG,VALLNG,VALADR,LSEVLV,NOSUCH,U.FIEX,STFILE>
GLOBAL	<ICFFLG,LCAPTR,RUNCOM,EODCHR,LDTFLG,LCCFLG>
GLOBAL	<ICFEBL,ICFEBM,ICFEOF,TEMP01,PROFIL>				;075

.SBTTL	CLOSE command
;+
; CLOSE [channel-number]
;
; DESCRIPTION:
; 	This command closes a file or device opened for reading, writing or
;	appending with the OPEN command, and removes its channel number from
;	the list of open channels.  "Channel-number" is an integer expression
;	whose value identifies the file to close.
;
;	When this command is issued, the file has already been saved on the 
;	PFB.  The IOB (if the file is non-disk) and the PFB channels are closed
;	and returned to the pool of channels.  The file entry in the file stack
;	in the global context area is cleared out as well.  The file can be
;	disk or non-disk; only disk files have been implemented so far.
;
; The legal qualifiers are:
; 
;	/ALL   -  indicates to close all data files currently open via the
;	 	  OPEN command.  If no files are currently open, then no 
;		  error is returned (it is considered a cleanup operation).  
;		  If /ALL and a channel number are specified, then the
;		  channel number overrides /ALL.
;
; INPUTS:
;	None.
;
;	The file comes in being saved on the PFB channel.  If it was disk,
;	then there's only a PFB channel.  If it was non-disk, then there is
;	a PFB and an IOB channel to close.  
;
; OUTPUTS:
;	IOBCHN = updated IOB channels bit mask indicating channels being used
;	PFBCHN = updated PFB channels bit mask indicating channels being used
;	GBLNFG = updated to reflect that the global context area was updated
;
;
; Errors returned to the user's terminal are:
;
; 	CHAN.E = "?Invalid channel number"
;	          (user specified a channel number outside the range 1-13)
;
;
; DSKCHN is a working cell, internal to this routine.  It contains the PFB 
; channel # (*2) of where the open file is being kept.
;
;-

; Qualifier list

CLO.QL:	DEFQUAL	ALL.Q,CONF=PARM1	;/ALL (conflicts with parameter)
	ENDQUAL				;

CLO.CMD::$THR				;
	$DEFCMD	QUAL=CLO.QL		;Point to the qualifier list
	$PARM	PARM1,TYPE=U$REST,PROMPT=CHAN$P,CONF=ALL.Q

	$CLR	VALUE			;Assume /ALL was specified
	$FETP	PARM1			;Fetch the channel number
	$IF	PRESENT			;If it was there then
	CHKCHN	PARM1,MINVAL=1,QUAL=CLO.QL;Check channel number in range 1-13, 
					;  quit if not in range
	$ENDIF				;Endif
	$ENDCMD				;

	$DO				;
10$:	MOV	#1,-(SP)		;Set flag assuming closing just 1 chan
	TST	VALUE			;Closing one channel or all channels ?
	BNE	CLSONE			;Jump around if closing 1 channel
	CLR	(SP)			;Set flag = closing all channels (/ALL)
	MOV	#1,VALUE		;Start with the 1st file entry on the
					; file stack (= channel 1)

; Close the open data file(s).  If attempting to close all open files, then
; begin the loop by starting with channel 1 (the user specified channel 1)
; since it is the first entry on the stack, and working forwards to channel 
; 13.  Get the file entry in the global context area associated with the user
; channel.

CLSONE:					;VALUE = user specified chan # to close
	CALB	ENTADR <VALUE>		;Get address of data file entry in
					; global context (returned in R5)
					; (no errors can occur)
	MOV	R5,R2			;Save file's entry address for later
	CLR	R1			;Ensure high byte is clear
	BISB	FILPFB(R5),R1		;Get PFB chan # (*2) where file is
					; kept, whether disk or non-disk
					;Is a file open on this channel ?
	BEQ	40$			;No,40$ so nothing to do for this chan
					; (don't return an error)
	MOV	R1,DSKCHN		;Keep PFB chan here to use throughout
;	BITB	#DSKFIL,FILFLG(R5)	;Is a disk file open on this channel ?
;	IFZE				;If not, then it's non-disk
;	CLR	R1			;  Ensure high byte is clear
;	BISB	FILIOB(R5),R1		;  Get IOB channel # (*2) also
;	MOV	IOBCHN,R4		;  Load up IOB channels bit mask
;	CALL	RTNCHN			;  Return the IOB channel (in R1)
;					;   (no errors possible), sets UPDFLG
;	MOV	R4,IOBCHN		;  Update the bit mask
;	ENDIF				;Endif

; Write out the CBB before closing the channel in case there's any data in
; the buffer associated with this channel.

	CALB	CLSCBB	<VALUE>		;Write out data for this channel 
					;if open for /WRITE, mark this CBB
					;as unused.

; Move the data file (disk or non-disk) from the PFB channel to an IOB 
; channel (P2I.PF) and close the channel.  No need to write out the attributes
; of the open file.  

					;DSKCHN = PFB channel # *2 of where the
					; open file is being kept (disk or not)
	CALB	CLSPFB	<DSKCHN,#CLSFQ>	;Move from PFB to IOB, and close the
					; channel (if error occurs then R0=code
					; and gets printed when hits $ENDDO)
					;Continue on if errors or not

; Return the PFB channel to the pool so it can be reused. 

20$:	MOV	DSKCHN,R1		;R1 = PFB channel # *2
	MOV	PFBCHN,R4		;Load up PFB channels bit mask
					; (error code in R0 is retained)
	CALL	RTNCHN			;Return the PFB channel (in R1)
					; (no errors possible), sets STFNFG
	MOV	R4,PFBCHN		;Update the bit mask

; Zero out the information in the stack entry for the file just closed.

					;R2=addr of file entry in globl context
	MOV	#FENTLN,R1		;# bytes in the file entry
	ASR	R1			;Convert to words
30$:	CLR	(R2)+			;Clear the file entry
	SOB	R1,30$			;Til done

40$:	TST	(SP)			;Closing just 1 channel in this CLOSE ?
	BNE	50$			;Yes,50$ so all done
	INC	VALUE			;No, increment the channel #
	CMP	VALUE,#FILENT		;Reached maximum # of possible open
					; channels ?
	BLE	CLSONE			;No, so close the next one
					;Yes, all done
50$:	TST	(SP)+			;Pop the stack
60$:	$ENDDO				;Print error message if one occurred
	$ENDTHR				;

GLOBAL	<LX.ERP,CHAN.E,PFBCHN,DSKCHN,VALUE>

.SBTTL	CLOSE/LOGFILE command
;+
; CLOSE/LOG_FILE
;
; DESCRIPTION:
; 	This command causes any currently open log file to be closed.  If
;	logging is enabled when this command is issued, then the command
;	itself will be the last line written to the log before it is closed.
;
; 	There are no qualifiers for this command.
;
; Errors: 
;
;	None.
;-

CLL.CMD::$THR				;
	$DEFCMD				;No qualifiers allowed
	$ENDCMD				;No parameters

	$DO				;
	BIC	#LOGACT,ICFFLG		;Logfile is no longer active	;078
	TST	LOGFIL			;Is log file currently open?	;078
	BEQ	10$			;Nope, so we're done		;078
	CLR	LOGFIL			;Indicate log file is closed	;078
	CALB	CLSPFB	<#PF$LOG*2,#CLSFQ>;  Close the PFB channel (*2)
	CMP	R0,#QUOTA		;Did ?Quota exceeded error occur?
	BNE	10$			;Nope, so we're done		;078
	REPAINT	 CMDPOS			;Repaint command, point at command
	CMESSAGE #U.NLOG		;?Unable to write logfile
	CMESSAGE #QUOTA			;?Quota exceeded (clears R0)
10$:	$ENDDO				;
	$ENDTHR				;All done

GLOBAL	<ICFFLG,QUOTA,U.NLOG,CMDPOS,LOGFIL>

.SBTTL	DELETE/SYMBOL command
;+
; DELETE/SYMBOL [symbol-name] [/qualifiers]
;
; DESCRIPTION:
; 	This command deletes a symbol definition from a user's local or global
;	symbol table, or deletes all symbol definitions in either symbol table.
;
; The legal qualifiers are:
; 
;	/ALL   -  used in conjunction with either /GLOBAL or /LOCAL to request 
;		  that all symbol names in the specified table be deleted.  If
;		  /ALL and a symbol name are specified, then the symbol name
;		  overrides /ALL.
;
;	/GLOBAL - 
;		  1. When used in conjunction with /ALL, all names in the
;		      global symbol table are deleted.
;		  2. When a symbol name is specified, then search the global 
;		      symbol table for the symbol name and if found, delete it.
;
;	/LOCAL  - 
;		  1. When used in conjunction with /ALL, all names in the 
;		      local symbol table are deleted.
;		  2. When a symbol name is specified, then search the local 
;		      symbol table for the symbol name and if found, delete it.
;
;	/SYMBOL is a required qualifier on this command.
;
; When /ALL or a symbol name parameter is specified, but no other qualifiers 
; are, then the default algorithm is:
;
;	1. At the interactive level:  search the g.s.t for the symbol(s) to
;	                              delete,
;	2. In an ICF:  search the l.s.t. of the current	command level for the
;	               symbol(s) to delete.
;
; OUTPUTS:
;gmb ;//fix//
;	SYMFLG = symbol table flag indicating which table was specified
;		 = LOCAL  --> use local symbol table
;		 = GLOBAL --> use global symbol table
;		 = ALL    --> /ALL was specified 
;		 = DEFALT --> neither /LOCAL nor /GLOBAL were specified
;		 = NAME   --> a symbol name was specified
;
;	NAMADR   = address of the symbol name string
;	NAMLNG	 = length of the symbol name string, in bytes
;
; Errors returned to the user's terminal are:
;
;       See the SHOW SYMBOL command for a list of errors.
;-

DSYM.CMD::$THR
	$DEFCMD	QUAL=SYM.QL,U.CMDC=1	;Indicate a DELETE/SYMBOL command
	$PARM	PARM1,TYPE=U$SYMN,PROMPT=SYMN$P,CONF=ALL.Q
	$ENDCMD				;

	$GOTO	DOSYM			;Go do the delete
	$ENDTHR				;


.SBTTL	EXIT command
;+
; EXIT  [status-code]
;
; DESCRIPTION:
;	This routine has 2 entry points because it may be entered in one of
;	two ways:  
;
;	EXI.CMD - user issued an exit command.  Ignored at interactive level.
;	EX2.CMD - user is under the control of an Indirect Command File, and 
;		  an "?End of file on device" condition was encountered when 
;		  attempting to read the next command line.  
;
;	The EXIT command provides a way to logically end a command procedure
;	and return control to the next higher command level.  If the command
;	procedure was executed from within another command procedure, then
;	control returns to the calling procedure.  The inclusion of an
; 	exit-code parameter permits a command procedure to set a specific
; 	exit status before returning to a higher-level procedure.  If a
;	status-code is omitted, then the current value of $STATUS and 
;	$SEVERITY are not changed.
;
;  	This command is ignored at the interactive level.  There are no 
;	qualifiers for this command.
;
; INPUTS:
;	CMDLVL = the highest current command procedure level
;	SLPFB  = the PFB channel # that F$SEARCH is using, or 0 if none
;	F$SCHN = bit mask of all currently open PFB channels that were
;		 opened via F$SEARCH (while in command procedures only)
;
; OUTPUTS:
;	CMDLVL = is decremented to reflect that command procedure was exited
;	GBLNFG = updated to reflect that the global context area was updated
;	F$SCHN = updated bit mask of all currently open F$SEARCH PFB channels
;		 if one was opened in this ICF
;	EXTFLG = 1 (indicates the command processed was an EXIT command)
;	ERRFLG = updated if the optional status-code parameter was passed
;
; Errors returned to the user's terminal are:
;
; 	All of the errors that can be returned by the expression evaluator
;	are possible.
;
;
; IOCHAN is a working cell, internal to this routine, for holding the I/O
; channel # (*2) that we're working with throughout.
;
;-

EXI.CMD::$THR
	$DEFCMD 			;No qualifiers for this command
	$PARM	PARM1,TYPE=U$REST,FLAGS=PF.OPT;Parse rest of command line
	$ENDCMD				;

	$CHECK	ICF			;
	$IF	FAILURE			;If not under an Indirect Command File
	$QUIT				;  Quit 
	$ENDIF				;Endif

	$DO				;
	CALBX	FET.P <#PARM1>		;Fetch the status code

; Set the reserved global symbols $SEVERITY and $STATUS to the status-code
; passed on the EXIT command.

	TST	U.CMN+U.PRES		;Is the status-code present ?
	BEQ	EX2.CMD			;No, so continue on
	MOV	U.CMN+U.POS,LX.POS	;Yes, set up the current position
	CALLX	DOEXPI			;Evaluate the expression
	IFCS				;If an error occurred
	MOV	R0,R4			;  Save error code over repaint call
	REPAINT	LX.ERP			;  Repaint command pointing at status
	CMESSAGE R4			;  Display the error
					;   (the values of $SEVERITY, $STATUS
					;    aren't changed) 
	BR	EX2.CMD			;  Continue on with EXIT command

	ENDIF				;Endif

					;R1,R2 = exit status, low and high
	CALBX	$STATUS <R1,R2>		;Update $STATUS & $SEVERITY
	BIC	#^C<7>,R1		;Only save the 1st 3 bits of status
	CALLX	CLRFQB			;Clear the FIRQB
	MOVB	R1,FIRQB+FQPROT		;Set exit status into FIRQB for "worst
	BISB	#200,FIRQB+FQPROT	;Set high bit to indicate "EXIT" ;066
	CALLX	JBFPF3			;Set the exit status
	MOVB	R1,ERRFLG		;Update the severity level

; Before leaving the ICF, if an F$SEARCH was executed anytime while in this
; ICF then close the PFB channel that is currently open.

EX2.CMD::MOV	SP,SAVSTP		;Save the original stack pointer 
	MOVB	#1,EXTFLG		;Set flag indicating an EXIT was seen
					; (used for unnesting when an error or
					;  CTRL/C has occurred)
	CALBX	CLSF$S			;Close any PFB chan opened by F$SEARCH
	;BCS	14$			;No error is possible

; Close the active command procedure.

	BIC	#STSUPD!ICFACT,ICFFLG	;Do not update $SEVERITY after this
					;command (successfully) completes.
					;Assume this will bring us back to
					;interactive level.  If not we will 
					;reset ICFACT bit
	CALB	CLSPFB	<#PF$ICF*2,#RSTFQ>;Reset the active ICF
					; (specify active PFB channel # *2)
	BCC	15$			;Error occur ?  No,15$
14$:	JMP	48$			;Yes,issue a STOP command (R0=error) 
					; (no I/O channel to close)
15$:	CMP	NXISTK,#ICFSTK		;Are there any PFB channels on the ICF
					; stack for holding inactive ICFs ?
	BLO	20$			;Yes,20$ - so return to calling ICF
	DEC	CMDLVL			;No,decrement the current command level
					; (interactive level called this ICF)
	CALLX	NOLOCAL			;Get rid of the local table
	JMP	50$			;Exit  (R0=0)


; Make the higher level ICF active now.

; Pop the ICF stack to get the PFB channel # of the calling ICF, which was
; saved from a STA.PF call.  Then move the calling command file from the 
; inactive PFB channel, where it was kept for safe keeping, to an IOB;
; this is the ICF we want to return to now.  

20$:	MOV	IOBCHN,R4		;Pass the IOB channels bit mask
	CALL	GETCHN			;Get an available I/O channel
					; (returns R1 = I/O channel # *2)
	BCS	14$			;Exit, if an error occurs (shouldn't)
					; (no I/O channel to close)
	MOV	R1,IOCHAN		;Save I/O channel # *2
	MOV	R4,IOBCHN		;Update the bit mask
	CALLX	CLRFQX			;Clear FIRQB and XRB
	MOV	R1,FIRQB+FQPPN		;Specify IOB channel number (*2)
	MOVB	@NXISTK,R1		;Get PFB channel number from ICF stack
	INC	NXISTK			;Update the addr of next available byte
	MOVB	R1,FIRQB+FQNAM1		;Set the PFB channel # (*2) of higher
					; level command procedure
	MOVB	#1,GBLNFG		;Indicate that global context changed
					; (don't care if local table changed 
					;  since it's now gone)
	CALL	P2I			;Move from PFB to IOB
		; R1 =  PFB channel number
	MOV	PFBCHN,R4		;Load up PFB channels bit mask
	CALL	RTNCHN			;Return the PFB channel used for safe
					; keeping (no errors possible)
	MOV	R4,PFBCHN		;Update the bit mask 
       	TST	R0			;
	IFNZ				;If an error occurred on the .PFB
	DEC	CMDLVL			;  Decrement the current level of ICF
	BR	40$			;  Exit, but return I/O channel 1st
	ENDIF				;Endif

; Retrieve the information about the position within the old ICF we left.

	MOV	LCAPTR,R1		;Point to local context area
	MOV	#ICFPOS,R4		;Get offset of ICF position of old ICF 
					; (in local context of ICF being exited)
	ADD	R1,R4			;Compute pointer to ICF position
	MOV	(R4)+,-(SP) 		;Save the LSB of the block #
	MOV	(R4)+,-(SP) 		;Save the MSB of the block #
	MOV	(R4)+,-(SP) 		;Save recordsize of the current record
	MOV	(R4),-(SP)		;Save the byte offset
	MOV	LDTFLG(R1),-(SP)	;Save SET [NO]DATA setting of ICF we're
					; returning to (from local context of
					; ICF we're leaving)
	MOVB	EODCHR(R1),-(SP)	;Save EOD char of ICF we're returning
					; to (from local context of ICF we're
					; leaving)
	DEC	CMDLVL			;Decrement the current level of ICF
	CALBX	POPSTB			;Read local table into core (of ICF
					; we're going back to) over local table
					; (of ICF we're leaving)
	BCS	40$			;Exit, if an error occurs
					; (return I/O channel 1st) 

; Move that IOB to the active PFB channel since we are done with the other one
; and want to return to the calling ICF.

	CALLX	CLRFQX			;Clear FIRQB and XRB
	MOVB	IOCHAN,FIRQB+FQPPN	;Specify IOB channel number (*2)
	MOVB	#PF$ICF*2,FIRQB+FQNAM1	;Specify active PFB channel number (*2)
	MOV	LCAPTR,R4		;Get pointer to local context area
	MOV	RCDSIZ(R4),FIRQB+FQSIZ	;Set up the record size of ICF we're
					; going back to  (in local context of 
					; ICF going back to)
	MOVB	RCDFMT(R4),FIRQB+FQSIZM	;Set up the record format
	MOVB	ICFEBM(R4),FIRQB+FQNAM1+1 ;Set up eof block number (MSB)
	MOV	ICFEBL(R4),FIRQB+FQNAM1+2 ;Set up eof block number (LSB)
	MOV	ICFEOF(R4),FIRQB+FQEXT     ;Set up eof byte number
	CALL	I2P			;Move from IOB to PFB
	BNE	40$			;Exit but return I/O channel first

; No errors occurred.  We're all done with the I/O channel so return it.

	BIS	#ICFACT,ICFFLG		;We are still in a command procedure.
	MOV	IOCHAN,R1		;R1 = I/O channel # *2 to return
	MOV	IOBCHN,R4		;Load up the bit mask for IOB channels
	CALL	RTNCHN			;Return the I/O channel to the pool,
					; but don't close it (monitor did)
					; (no errors possible)
	MOV	R4,IOBCHN		;Update the bit mask 

; Reset the command line flag character (the /END_OF_DATA=" " character) for 
; the ICF we're returning to.

	CALLX	CLRFQB			;Clear the FIRQB
	MOVB	#FLG.PF,FIRQB+FQFIL	;'Set/clear' flag bits
	MOV	#PF$ICF*2,FIRQB+FQNAM1	;Load PFB channel number * 2
	MOVB	(SP)+,FIRQB+FQPROT	;Load up the EOD character
	.PFB				;Do it (if an error occurs, then it
					; defaults to "$")

; Restore the status of the SET [NO]DATA setting for the ICF we're returning
; to.

	CALLX	CLRFQB			;Clear the FIRQB
	MOV	(SP),FIRQB+FQFLAG	;Set up data bit to set
					; (bit set means SET NODATA)
	MOV	(SP)+,FIRQB+FQBUFL	;Set up data bit to clear
					; (bit set means SET DATA)
	COM	FIRQB+FQBUFL		;Set all other bits that aren't set
	BIC	#^C<J2NDAT>,FIRQB+FQBUFL;Clear all bits except DATA bit
	CALLX	JBFPF2			;Reset data setting to what it was

; Reset our position (in the ICF we've returned to) to the beginning of the @
; command line we just processed.  

	CALLX	CLRFQB			;Clear the FIRQB
	MOVB	#POS.PF,FIRQB+FQFIL	;Function = 'Set ICF position'
	MOV	#PF$ICF*2,FIRQB+FQNAM1	;PFB channel # (*2) for the ICF
	MOV	(SP)+,FIRQB+FQBUFL	;Restore the byte offset
	MOV	(SP)+,FIRQB+FQSIZ	;Restore recordsize of current record
	MOV	(SP)+,FIRQB+FQEXT	;Restore MSB of the block #
	MOV	(SP)+,FIRQB+FQNAM1+2	;Restore LSB of the block #
	.PFB				;Set the position
	MOVB	FIRQB,R0		;Set the error code up
       ;TSTB	FIRQB			;Error occur ?
	BNE	48$			;Yes,48$ - exit 
	BR	50$			;No, Skip around cleanup code

; The following performs any cleanup operations that are needed when an
; error occurs along the way.  A STOP command is then issued to return the
; user to the interactive level since the results are so unpredictable.

40$:	MOV	IOCHAN,R1		;R1 = I/O channel # *2 to return
	MOV	IOBCHN,R4		;Load up the bit mask for IOB channels
	CALL	RTNRST			;Return and reset the I/O channel
					; (no errors possible)
	MOV	R4,IOBCHN		;Update the bit mask 

48$:	CMESSAGE R0			;Print error message first
49$:	CALL	ST2.CMD			;Issue a STOP to get back to level 0

	MOV	#U.QUIT,R0		;Quit upon returning

50$:	MOV	SAVSTP,SP		;Restore the original stack pointer
	TSTB	KBMFLG			;Do we need to switch?
	IFNE				;If so then
	CALBX	SAVSTB			;  Save symbol table
	CALLX	CLRFQB			;  Clear FIRQB for .RTS
	.RTS				;  Do a .RTS directive (Might not 
					;  ... return in-line)
	ENDIF				;Endif
	MOV	#U.QUIT,R0		;In any case, quit
	$ENDDO				;
	$ENDTHR				;

GLOBAL	<TYPE,CMNADR,EODCHR,LDTFLG,KBMFLG>
GLOBAL	<CMDLVL,NXISTK,PFBCHN,IOBCHN,ICFSTK>
GLOBAL	<U.QUIT,ICFPOS,ENT.TY,ERRFLG,EXTFLG>
GLOBAL	<RCDSIZ,RCDFMT,SAVSTP,IOCHAN,U.CMN,LX.POS,ICFFLG>

.SBTTL	GOSUB command
;+
; GOSUB label
;
; Description:
;	This command saves the current ICF position on a pseudo (linked
;	list) stack and then behaves like a GOTO command.  See the GOTO
;	command description below for more info.
;
;-

GOSUB.CMD::
	$THR
	$CALL	GOPARM		;Parse the label
	$DO
	;BIT	#GOACT,ICFFLG	;Are we back here a 2nd time?		;067
	;BEQ	5$		;No - go on				;067
        ;REPAINT U.CMN+U.POS     ;Repaint it with arrow at bad label	;067
	;CMESSAGE #ULBL.E	;"?Undefined label"			;067
	;MOV	#U.QUIT,R0	;All done for now			;067
	;BR	20$		;And exit				;067

5$:	BIC	#STSUPD!SEVCHK,ICFFLG
				;Set flags saying we don't want
				;... $STATUS changed or severity checked.
	CALLX	PSHPOS		;Store current ICF position in the symbol
				;... table
	BCS	20$		;Leave if error (like symbol table full)
10$:	CALL	LUPLBL		;Look for the label in the symbol table
				;... at set up FIRQB if found
	IFCC			;If found then
	CALL	GOTOPOS		;  Go to that ICF position (may return error
				;  ... with carry set)
	ELSE			;Else
	CALL	LBLSCAN		;  Scan the ICF for the label and add it to
				;  ... the symbol table if found
	BCC	10$		;  If found, go get the label and go to it
	ENDIF			;Endif

20$:	$ENDDO			;Return with possible error from GOTOPOS or
	$ENDTHR			;... LBLSCAN

GLOBAL	<ICFFLG,ULBL.E>

.SBTTL	GOTO command 
;+
; GOTO label 
;
; DESCRIPTION:
;	This command transfers control to a specified point in a command
;	procedure.  This command is valid when in an ICF, and is ignored at
;	the interactive level.	There are no qualifiers for this command.
;
; 	"label" specifies a 1-255 character label name consisting of $,
;	alphanumeric, or underscore characters, but it cannot start with a $.
;	A command line label identifies a line in a command procedure that can 
;	be reached from other lines in the command procedure; it is the point 
;	in the command procedure where control is to be resumed.  Any DCL 
;	command can optionally be preceded by a label.  The line containing
;	the specified label may precede or follow the GOTO command in the 
;	command procedure.
; 
;	The local symbol table for this ICF is first searched for the label 
;	specified on the GOTO command.  If it doesn't exist there, then a 
;	forward reference is assumed.  Command lines are read, one at a time,
;	until a command line beginning with the specified label is found.  
;	If an EOF is found, then the command procedure is terminated.  Label
;	definitions found during this search are added to the local symbol 
;	table to save time later on, and if an error occurs, then the command 
;	procedure is terminated.
;
; 
; Errors returned to the user's terminal are:
;
;	ULBL.E  = "?Undefined label"
;		    (the label specified was not defined in the Indirect 
;		     Command File or a label was not specified on the GOTO 
;		     command)
;	U.ILBL  = "?Invalid label"
;		    (the label contained invalid characters; returned by
;		     U$CLBL)
;  
;	In addition, the errors returned by the PARLBL and ADDLBL routines 
;	are possible.
;
;-

GOTO.CMD::
	$THR
	$CALL	GOPARM		;Parse label
	$DO
	;BIT	#GOACT,ICFFLG	;Are we back here a 2nd time?		;067
	;BEQ	10$		;No - go on				;067
        ;REPAINT U.CMN+U.POS     ;Repaint it with arrow at bad label	;067
	;CMESSAGE #ULBL.E	;"?Undefined label"			;067
	;MOV	#U.QUIT,R0	;All done for now			;067
	;BR	20$		;And exit				;067

10$:	BIC	#STSUPD!SEVCHK,ICFFLG					;067
				;Set flags saying we don't want
				;... $STATUS changed or severity checked.
	CALL	DOGOTO		;Do the GOTO
20$:	$ENDDO								;067
	$ENDTHR

GLOBAL	<ICFFLG>

.SBTTL	GOPARM	- Parse parameter for GOSUB and GOTO

;+
; GOPARM - Parse parameter for GOSUB and GOTO
;
; Description:
;	This is just your basic parameter parsing code but,
;	it is common code for the GOSUB and GOTO commands so
;	it is done in a subroutine.
;
; Call:
;	$CALL	GOPARM
;
;-

GOPARM:	$DEFCMD				;Begin parameter parse
	$PARM	PARM1,TYPE=U$CLBL,FLAGS=PF.OPT
					;Parse command line label (PF.OPT is
					;... used cause you need to specify
					;... a label, but can't prompt
					;... for it since he's in an ICF)
	$ENDCMD				;End parameter parse
	$NOLOCAL			;Error if not in a command procedure
	$FETP	PARM1			;Fetch the label
	$IF	ABSENT			;If not there then
	$MOVV	LX.POS,LX.ERP		;  Set error position to end of line
	$RETURN	U.ILBL			;  Return error "?Invalid label"
	$ENDIF				;Endif
	$RETURN				;Return

GLOBAL	<LX.POS,LX.ERP,U.ILBL>

.SBTTL	LUPLBL - Look up a label in the local symbol table

;+
; LUPLBL - Look up a label in the local symbol table
;
; Description:
;	Search the local symbol table to see if the entry for this label
;	exists.
;-

.ENABL	LSB

LUPLBL:	MOV	LCAPTR,SCOPE	;Make the scope local so we look in the
				;... local table
				.ASSUME LBLTYP EQ 0
	CLRB	TYPE		;Set entry type to label
	CLRB	SRHABB		;Labels don't have abbreviation points	 
	MOV	#U.CMN+U.STR,NAMADR
				;Get address of label in command line
	MOVB	U.CMN+U.LEN,NAMLNG
				;Get length of label
	CALLX	GETVAL		;Search for the label in symbol table
	IFCC			;If the label was found then
	CALLX	CLRFQB		;  Clear out the FIRQB
	MOV	#FIRQB+FQNAM1+2,R1
				;  Point into the FIRQB
	MOV	(R0)+,(R1)+	;  Set the LSB of block #
	MOV	(R0)+,(R1)+	;  Set the MSB of block #
	MOV	(R0)+,(R1)+	;  Set the record size
	MOV	(R0)+,(R1)+	;  Set the byte offset
	CLC			;  Say no error
	ENDIF			;Endif
	RETURN			;Return with carry set and error code
				;... in R0 if not found
.DSABL	LSB

GLOBAL	<TYPE,SCOPE,NAMADR,NAMLNG,SRHABB>				;064


.SBTTL	DOGOTO - Do the work for GOTO

; DOGOTO is called when you have an /END_OF_FILE=label condition.  The
; only input to DOGOTO is that the label needs to be fetched.  Note that in
; the case of /END_OF_FILE=label the "label" is a qualifier argument and
; in GOTO label, "label" is a parameter.

.ENABL	LSB

DOGOTO:	CALL	LUPLBL		;Look for the label in the symbol table
				;... and set up FIRQB if found
	IFCS			;If not found then
	CALLX	PSHPOS		;  Save current ICF position
	BCS	10$		;  Leave if error (like symbol table full)
	CALL	LBLSCAN		;  Search the ICF for the label and add it to
				;  ... the symbol table if found
	BCS	10$		;  Leave if not found (error msg already
				;  ... printed by LBLSCAN and ICF position
				;  ... has been restored to line w/ label)
	CALLX	POPPOS		;  Pop ICF position (don't reposition, we
				;  ... want to stay at the label we found)
	BR	DOGOTO		;  Go get the label and go to it
	ENDIF			;Endif
	CALL	GOTOPOS		;Reposition the ICF to the label
				;... May return with errors (carry set)
				;... to pass along
10$:	RETURN			;Return with possible errors from GOTOPOS or
				;... LBLSCAN

.DSABL	LSB

.SBTTL LBLSCAN - Search ICF for a label

;+
; LBLSCAN - Search ICF for a label
;
; Description:
;	The label was not in the symbol table.  Search for the label in the
;	Indirect Command File by doing forward reads in the command file
;	attempting to locate it.  Add any labels we encounter along the way
;	to the local symbol table.  Duplicate labels will be also be caught
;	and reported by ADDLBL.
;
;	If we don't find the label, we return to our original position in
;	the ICF, set the GOACT bit, then jump back to DCLCMD to re-read the
;	line using CUI.  This will result in the GOTO or GOSUB code being
;	entered again; the GOACT bit will flag an error.  This hand-waving
;	is necessary to deal with GOSUB's and GOTO's in continued lines.
;
; Inputs:
;	These inputs are typicaly set up a $FETP or equivalent
;	U.CMN+U.STR	-> The label we're looking for
;	U.CMN+U.LEN	=  The length of the label
;	U.CMN+U.POS	=  The position of the beginning of the label
;
; Call:
;	CALL	LBLSCAN
;
; Outputs:
;	If C=0 then
;		R0	=  zero
;
;	If C=1 then
;		R0 = U.QUIT
;
; Side effects:
;	NAMADR -> the name of the last label found.
;	NAMLNG =  the length of the name of the last label.		;057
;	The FIRQB is trashed.
;	Any labels found have been added to the symbol table
;-

.ENABL	LSB

LBLSCAN:
	PUSH	R3		;Save CUI thread pointer
10$:	CALL	READ,R5,<CMDBUF,CMDLEN>
				;Read next command line from the ICF
	IFCS			;If error occurred reading the command
	CMPB	R0,#EOF		;  Is error = "?End of file on device" ?
	IFNE			;  If not then it's unexpected so...
20$:	CMESSAGE R0		;    Give the error message
	CALL	ST2.CMD		;    Issue a STOP to go back to level 0
				;    ... and get out of all higher ICFs
	BR	100$		;    Quit upon returning 
	ENDIF			;  Endif
	CALLX	CLRFQB		;  Clear FIRQB in prep for POPPOS
	CALLX	POPPOS		;  Pop gosub stack and put saved ICF
				;  ... position into FIRQB
	CALL	GOTOPOS		;  Reposition ICF to there
        CALL    READ,R5,<CMDBUF,CMDLEN>
                                ;  Re-read the line into command buf
        REPAINT U.CMN+U.POS     ;  Repaint it with arrow at bad label
        CMESSAGE #ULBL.E        ;  Display "?Undefined label"
        BR      100$            ;  Quit upon returning
	;BIS	#GOACT,ICFFLG	;  Flag GOTO/GOSUB error		;067
	;CALLRX	GETCMD		;  Go re-read the command		;067
	ENDIF			;Endif 

; Process a possible label on this line

	MOV	#1,LX.POS	;Set scan position to beginning of line
	CALLX	PARLBL		;Yes, parse a label - was one found ?	;061
	BCS	10$		;No, so read next command line		;061
	CALLX	ADDLBL		;Add label to ICF's local symbol table	;061
 				;... (NAMADR, NAMLNG are set up and
				;... refer to label just added which
				;... is still in it's original case)
	BCS	20$		;Go issue a STOP if we couldn't add the
				;... label.

; See if label just found matches label we're looking for

	CMPB	U.CMN+U.LEN,NAMLNG
				;Is length of label we're searching for
				;... equal to length of label we just
				;... added to symbol table ?
	BNE	10$		;No, go read next command from ICF
	MOV	NAMADR,R1	;Addr of label name just added to table
	CLR	R0		;Yes, ensure high byte is clear
	BISB	U.CMN+U.LEN,R0	;Use original label length as a counter
	MOV	#U.CMN+U.STR,R5	;Get addr of label we're searching for
60$:	MOVB	(R1)+,R2	;Get next char of label just added
	BICB	#40,R2		;Ensure it is uppercase
 	MOVB	(R5)+,R3	;Get next char of label we're searching
				;... for
	BICB	#40,R3		;Ensure it is uppercase also
	CMPB	R2,R3		;Are the characters the same ?
	BNE	10$		;No, read next command
	SOB	R0,60$		;Continue analyzing all chars in both 
				;... label names til done
; Found the label.

	TST	(PC)+		;Leave with carry clear (no error)
100$:	SEC			;Set carry to indicate error
	MOV	#U.QUIT,R0	;Quit (w/ no error message)
	POP	R3		;Restore R3 before leaving
	RETURN			;Return

.DSABL	LSB

GLOBAL	<ICFFLG,EOF,ULBL.E,U.CMN,U.QUIT,NAMADR,NAMLNG,LX.POS>		;067

.SBTTL	READ - Read next line in command file

.ENABL	LSB

;+
; READ
;
; Description:
;	This routine is used by @ and LBLSCAN to quickly read through the
;	command file.  It is much faster than CUI.
;
; Input:
;	buffer_address = address of buffer to store line
;	length_address = address of word to store length of line read
;
; Call:		CALL	READ,R5,<buffer_address,length_address>
;
; Output:
;	if C=0 then
;		R0 =  Zero
;	If C=1 then
;		R0 =  Monitor error code
;
; Side effects:
;	The FIRQB is trashed.
;	The XRB contains pointers to the stuff we read.
;	The monitor's idea of the ^C position in the ICF is changed to
;	point to the line we read in.
;-

READ:	CALLX	CLRXRB			;Clear the XRB for .READ
	MOV	(R5)+,R0		;Get location of input buffer
	MOV	#CMD.BSIZ,XRB+XRLEN	;Set size of input buffer
	MOV	R0,XRB+XRLOC		;Set location of input buffer
	DEC	XRB+XRTIME		;Negative time means ^C read
	MOV	#200,XRB+XRMOD		;Set read from ICF without echo modifier
	.READ				;Read the line
	SUB	#2,XRB+XRBC		;Don't count the CRLF as part of the
					;... line length
	MOVB	XRB+XRBC,@(R5)+		;Store the line length
	CMP	(R0)+,#'$		;Does line begin with "$<null>"?
	IFEQ				;If so then an error occured
	MOVB	(R0),R0			;  Get the error code
	SEC				;  Set carry
	ELSE				;Else
	CLR	R0			;  Clear error code and carry
	ENDIF				;Endif
	RETURN	R5			;Return (caller will handle errors).

	GLOBAL	<CMD.BSIZ>

.DSABL	LSB

.DSABL	LSB

GOTOPOS:

; FIRQB already contains ICF position information

	MOVB	#POS.PF,FIRQB+FQFIL	;Function = 'Set ICF position'
	MOV	#PF$ICF*2,FIRQB+FQNAM1	;Set PFB channel # (*2) for the ICF
	.PFB				;Go to that position
	CLR	R1			;Ensure high byte is clear 
	BISB	FIRQB,R1		;Set up the error code	
       ;TSTB	FIRQB			;Error occur ?

; If an error occurs, then abort the command procedure by issuing a STOP 
; command in essence, thus returning the user to command level 0, regardless 
; of what level he was at.

	IFNE				;If an error occurred
	CALLX	DOCMES			;  Display it
	CALL	ST2.CMD			;  Stop
	ENDIF				;Endif

	MOV	#U.QUIT,R0		;We've printed any error message
					;... so just quit
	CLR 	LX.ERP			;Clear the error position
	CALLX	U$ITRE			;Initialize the parse tree
					;... ;gmb why?
	RETURN

.ENABL	LSB

GLOBAL	<U.QUIT,LX.ERP>

.SBTTL	IF expression THEN command 
;+
; IF expression THEN [$] command
;
; DESCRIPTION:
;	This command tests the value of an expression and executes the command
;	following the THEN keyword if the test is true.  "command" defines the 
;	DCL or CCL command to be performed, and "expression" defines the test 
;	to be performed.  If the result of the expression is false, then the 
;	command following the THEN keyword is not executed and control resumes 
;	at the first command following the IF ... THEN statement. An expression
;	is true if its integer result is odd, otherwise it is false.  Any valid
;	DCL or CCL command may be specified, and all DCL command syntax rules
;	apply.  The command may optionally be prefixed with a dollar sign ($).
;	A label cannot be specified with the command following the THEN clause.
; 
; 	There are no qualifiers for this command.
;
;
; Errors returned to the user's terminal are:
;
;	CMD.E   = "?Invalid command"
;		    (the command following the THEN keyword was invalid)
;		     - but it doesn't get returned by this routine
;	THRQ.E  = "?THEN keyword required"
;		    (the THEN keyword was missing on the IF <expression> ...
;		     command)
;	OUTOAS  = "?Expression too complicated"
;		    (there were too many IF ... THEN ... statements on one
;		     command line)
;
;	all of the errors that can be returned by the expression evaluator
;	are possible (ex. IEXP.E, U.BIGN, NOCP.E, DIV.E, U.NOCQ)
;-

IFTH.CMD::$THR
	$DEFCMD				;
	$DO				;
	CALLX	DOEXPI			;Evaluate the expression
	MOV	R1,VALUE		;Save result 			;061
	$ENDDO				;Report expression error if any	;061

; If the expression is true, then execute the command following the THEN.
; If it's false, then ignore whatever follows the THEN clause and continue on.

	$PARKEY				;Parse the keyword THEN
	$ONKEY	THEN.K,THEN.CMD		;
	$ENDKEY	FAIL=20$		;Error if it's missing
20$:	$DO				;
	MOV	#THRQ.E,R0		;"?THEN keyword required" error
	MOV	LX.POS,LX.ERP		;Set the error position
	$ENDDO				;

THEN.CMD:$DO				;
	BIC	#STSUPD!SEVCHK,ICFFLG	;Do not update $SEVERITY after this
					;command (successfully) completes, nor
					;go through error check on $SEVERITY
	BIT	#1,VALUE		;True expression?		;061
	BEQ	40$			;No, quit
	CALLX	PARDOL			;Parse dollar signs and spaces
	CALLX	LX.EOS			;Are we at end of string?	;061
	BCC	40$			;Yes ... all done then //Error here?//
	JMPX	TRUEXP			;Go do expression

40$:	MOV	#U.QUIT,R0		;Quit if false
	$ENDDO
;+
; Now this next command might seem a little odd.  When DCL hits the $ENDDO in
; DCLCMD following the TRUEXP, control doesn't flow to the next threaded 
; command, but rather returns here.  Therefore, we will $GOTO the next 
; instruction in DCLCMD after all.  Just a round-about way of getting there.
; The "TST" is to see if the command following the THEN is another "@" command.
;
; Note that if we went to 40$ then we will not hit this command, because
; we "QUIT".
;-

	$GOTO	TSTEXP			;Go right back and finish command
	$ENDTHR				;Necessary but never executed

GLOBAL	<THRQ.E,VALUE,LX.ERP,LX.POS,TSTEXP,CMDPOS,ICFFLG>		;061

.SBTTL	INQUIRE command
;+
;
; INQUIRE symbol-name [prompt-string] [/qualifiers]
;
; DESCRIPTION:
;	This command issues a prompting message at the user's terminal, waits
;	for a response and assigns the response text as a string value to the 
;	specified symbol name in the user's symbol table.  This command is an 
;	alternative to passing parameters directly to a command procedure. 
;
;	A valid symbol name for the INQUIRE command follows the same syntax
;	rules as the symbol name in an assignment statement.  It consists of
; 	1-255 characters in the character set A-Z, a-z, 0-9, $, and underscore.
;	A symbol name cannot start with an integer, dollar sign, underscore 
;	or the characters "F$" (or f$), which represent reserved symbol 
; 	name prefixes.  A hyphen or an asterick can be used to specify an 
; 	abbreviation point for the symbol (that is, the minimum abbreviation
;	allowed when referring to this symbol name in another DCL command).
;	For example, the commands INQUIRE AB*CDE and INQUIRE AB-CDE enable 
;	a user to refer to this symbol using either the names AB, ABC, ABCD 
;	or ABCDE.  Naturally, a symbol name cannot begin with a hyphen or an 
;	asterick character.
;
;
; The legal qualifiers are:
; 
;	/[NO]ECHO -  indicates whether or not the user's response to the 
;		     prompt string should be echoed (displayed) at the
;		     terminal.  
;
;	/EXIT=label - indicates where control is to resume when an end-
;		      of-file condition has been reached on the read.
;
;	/GLOBAL - indicates that the symbol should be placed in the global 
;		  symbol table.  This is the default for the interactive 
;		  level.
;
;	/LOCAL  - indicates that the symbol should be placed in the local
;		  symbol table of the current command procedure.  This is
;		  the default for all command levels except the interactive
;		  level.
;
;	/[NO]PUNCTUATION - indicates whether or not any punctuation should
;			   be appended to the prompt string when it is
;			   displayed.  If /PUNCTUATION is specified, then
;			   a colon (:) and a space are appended to the 
;			   prompt string.
;
;	/WAIT=seconds - indicates that INQUIRE should wait the specified
;			number of seconds before timing out.  The number
;			of seconds must be non-negative (i.e. zero or more.)
;			If a time out occurs it will be treated as if the
;			user hit RETURN (i.e. null string will be returned.)
;
;
; Errors returned to the user's terminal are:
;
;	U.ISYN  = "?Invalid symbol name"
;		    (symbol name did not start with an alphabetic, $ or
;		     underscore, ex. INQUIRE 9abc)
; 	ILVL.E  = "?Invalid at interactive level"
;		    (ex. INQUIRE/LOCAL abc at command level 0)
; 	U.UCHR  = "?Unexpected character"
;		    (symbol name contained an invalid character,
;		     ex. INQUIRE a*bc)
; 	RSVN.E  = "?Reserved symbol name"
;		    (user attempted to assign a symbol name using a reserved
;		     prefix (F$, f$ or $), ex. INQUIRE $ABC)
;-

INQ.QL:	DEFQUAL	ECH.Q,QF.NEG			;/[NO]ECHO
	DEFQUAL	EXI.Q,ARG=OPT			;/EXIT[=label]
	 DEFARG	TYPE=U$CLBL			; =label
	 ENDARG					;
	DEFQUAL	GBL.Q,CONF=LCL.Q		;/GLOBAL
	DEFQUAL	LCL.Q,CONF=GBL.Q		;/LOCAL
	DEFQUAL	PUN.Q,QF.NEG			;/[NO]PUNCTUATION
	DEFQUAL TIM.Q,ARG=REQ			;/TIME_OUT=seconds
	 DEFARG TYPE=U$S16,MINVAL=1		; =seconds
	 ENDARG					;
	ENDQUAL

INQ.CMD::$THR
	$DEFCMD	QUAL=INQ.QL,U.CMDC=2	;U.CMDC is needed for U$SYMN routine
	$PARM	PARM1,TYPE=U$SYMN,PROMPT=SYMN$P
	$PARM	PARM2,TYPE=U$QUOT,FLAGS=PF.OPT
	DFLTCQ	EXI.Q			;Default to /EXIT
	$ENDCMD

	$NOBATCH			;Error if we are in BATCH
	$CHECK	ICF			;Are we under an ICF?
	$IF	ABSENT			;If not then
	$DISALL <LCL.Q> ILVL.E		;  Disallow /LOCAL
	$ENDIF				;Endif  

	$FETP	PARM1			;Fetch symbol name

; Analyze the symbol name for valid characters and an abbreviation point.

	$CHKSN				;Check for valid symbol name	;060
	PUTSTR				;Store string in TRNBUF
	$FETCQ	LCL.Q			;Did he specify /LOCAL?
	$IF	PRESENT			;If so then
	$MOVV	LCAPTR,SCOPE		;  Set scope to local
	$ELSE				;Else
	$FETCQ	GBL.Q			;  Did he specify /GLOBAL?
	$IF	PRESENT			;  If so then
	$MOVV	GCAPTR,SCOPE		;    Set scope to global
	$ELSE				;  Else
	$CHECK	ICF			;    Are we in an ICFP?
	$IF	SUCCESS			;    If so then
	$MOVV	LCAPTR,SCOPE		;      Set scope to local
	$ELSE				;    Else	
	$MOVV	GCAPTR,SCOPE		;      Set scope to global
	$ENDIF				;    Endif
	$ENDIF				;  Endif
	$ENDIF				;Endif

	$FETCQ	ECH.Q			;Did he specify /[NO]ECHO?
	$IF	PRESENT			;If so then
	$IF	NO			;  If /NOECHO then
	$DO				;
	.TTNCH				;    Turn off local echoing	
	$ENDDO				;
	$ENDIF				;  Endif
	$ENDIF				;Endif

	$BIS	PUNCT,ICFFLG		;Assume /PUNCTUATION
	$FETCQ	PUN.Q			;Did he specify /[NO]PUNCTUATION?
	$IF	PRESENT			;If so then
	$IF	NO			;  If /NOPUNCTUATION then
	$BIC	PUNCT,ICFFLG		;    Indicate so
	$ENDIF				;  Endif
	$ENDIF				;Endif

	;Insert a ": " after the prompt string if /NOPUNCTUATION 
	;isn't specified.
	;
	;The next fetches must appear in the order shown - they rely on 
	;CUI common set up with the prompt text going into the RDMOR call.


	$FETP	PARM2			;Was a prompt text specified?
	$IF	ABSENT			;If not then
	$FETP	PARM1			;  Fetch and use the symbol name
					;   (includes an abbreviation char
					;    of - or * if one was specified)
	$ENDIF				;Endif
	$DO				;Insert a <COLON><SPACE> at end
	CMPB	#'",U.CMN+U.STR		;Is first character in prompt a quote?
	IFEQ				;If so then
	MOV	#U.CMN+U.STR,R1		;  Point to string in CUI common
	SUB	#2,U.CMN+U.LEN		;  Strip off first and last quote
	MOV	U.CMN+U.LEN,R2		;  Length of string
	BEQ	20$			;  Prompt was null string 
10$:	MOVB	1(R1),(R1)+		;  Move string over	
	SOB	R2,10$			;  until all characters in prompt gone
	ENDIF				;Endif

20$:	BIT	#PUNCT,ICFFLG		;/PUNCTUATION?
	IFNZ				;If so then
	MOV	#U.CMN+U.STR,R4		;  Point to string
	ADD	U.CMN+U.LEN,R4		;  Point at last character
	MOVB	#':,(R4)+		;  Insert the colon
	MOVB	#<SPACE>,(R4)		;  Insert the space
	ADD	#2.,U.CMN+U.LEN		;  Account for the two extra chars
	ENDIF				;Endif

	;Now the prompt string is located in CUI common.  If no string is given
	;we are using the symbol name as the prompt string.

	.TTRST				;Cancel ^O
	CALB	FWRITE <U.CMN+U.LEN,#U.CMN+U.STR>
	CLR	CMDLEN			;Get new command - zero length  and
	MOV	#CMDBUF,CMDNEX		; make entire command buffer available
	CALLX	CLRXRB			;Zero the XRB
	MOV	#LINBUF,R5		;Store address of LINBUF
	MOV	#LIN.BSIZ,XRB+XRLEN	;Buffer length

	MOV	R5,XRB+XRLOC		;Address of buffer
	;MOV	#0*2,XRB+XRCI		;Read on channel 0
	MOV	#400,XRB+XRMOD		;Want "forced terminal read" 

	CALBX	FET.CQ	<#TIM.Q>	;Did he specify /TIME_OUT?
	TST	U.CMN+U.PRES		;Is this qualifier present?
	IFNE				;If so then
	CALBX	FET.A			;  Fetch the # of seconds to wait
	MOV	U.CMN+U.LOW,XRB+XRTIME	;  Set the wait time.
	;ELSE				;Else
	;CLR	XRB+XRTIME		;  The wait time is infinite
	ENDIF				;Endif

	.READ				;Read command

	CMPB	FIRQB+0,#EOF		;Was error ?End of file on device
	IFEQ				;If so then
	BIT	#ICFACT,ICFFLG		;  Are we in a command procedure?
	IFNZ				;  If so then
	CALBX	FET.CQ	<#EXI.Q>	;    /EXIT present by default
	CALBX	FET.A			;    Fetch the label
	TST	U.CMN+U.PRES		;    Did he specify a label?
	IFNE				;    If so then
	CALL	DOGOTO			;      Goto the label
	ELSE				;    Else
	CALL	EX2.CMD			;      Perform EXIT command
	ENDIF				;    Endif
	ENDIF				;  Endif
	MOV	#U.QUIT,R0		;  Quit because of CTRL/Z
	BR	40$			;  Get out fast
	ENDIF				;Endif

	CMPB	FIRQB+0,#HNGTTY		;?Keyboard wait exhausted?
	BNE	25$			;Not this time			;070
	CALLX	CLRXRB			;Yes - Clear the XRB		;070
	MOV	#7,XRB+XRLEN		;Function "clear type ahead"	;070
	MOVB	#2,XRB+XRBLKM		;Terminal device handler index 	;070
	.SPEC				;Cancel the type ahead		;070

	CLR	R1			;Set input as null string	;073
	BR	30$			;Go assign value

25$:	CALLX	U$CHKE			;Abort if error (shouldn't happen) ;070
	MOV	XRB+XRBC,R1		;Get length of line
	BEQ	40$			;If null then he typed ^C, quit
	DEC	R1			;Trim off last character (delimiter)
	MOV	R5,R2			;Point at first char in buffer
	ADD	R1,R2			;Point at delimiter
	CMPB	(R2),#LF		;Check for <CR><LF> delimiter
	BNE	30$			;Not it
	CMPB	-(R2),#CR		;Maybe
	BNE	30$			;No
	DEC	R1			;Yes, decrement character count

30$:	MOVB	R1,VALLNG		;R1 = character count
	MOV	R5,VALADR		;LINBUF contains string
	MOV	#TRNBUF,NAMADR		;Name address = TRNBUF
	MOVB	TRNLEN,NAMLNG		;Name length = length of TRNBUF string 
	MOVB	#STRTYP,TYPE		;Type = string

; NAMABB was set up by CHKSN routine to allow INQUIRE to use abbreviations

	CALBX	ADDSYM			;Add the symbol to user's symbol table
					;Error code is in R0 and will be handled
					;... by $ENDDO
; Clean things up a bit

40$:	.TTECH				;Re-enable echoing

	MOV	#20,PRTMOD		;Be sure to ignore noecho
	CALLX	U$LMARGIN		;Bring cursor to left margin without
					;  flushing first
	CALLX	INITRN			;Clean up TRNBUF
	$ENDDO				;
	$ENDTHR				;End of command

GLOBAL	<VALLNG,VALADR,NAMADR,NAMLNG,SCOPE,TYPE,CMDBUF,CMDLEN,CMDNEX>
GLOBAL	<U.CMN,ILVL.E,TYPE,TRNBUF,TRNLEN,ICFFLG,LX.POS,PRTMOD>		;073
GLOBAL	<LINBUF,LIN.BSIZ,LX.ERP,HNGTTY,U$LMARGIN,GCAPTR,LCAPTR>		;073

.SBTTL	ON ... THEN commands
;+
; ON severity-level THEN [$] command
;
; DESCRIPTION:
;	This command indicates what action should be taken when a WARNING,
;	ERROR, or SEVERE_ERROR occurs in a command procedure.  Each time a
;	command, task, or command procedure completes, DCL checks its exit
;	status and takes action based on the current setting of the ON command.
;	"command" defines the DCL or CCL command to be performed whenever an
;	error greater than or equal to the specified severity level occurs.
;	Any valid DCL or CCL command may be specified, and all DCL command 
;	syntax rules apply.  The command may optionally be prefixed with a 
;	dollar sign ($).  A label cannot be specified with the command 
;	following the THEN clause.
;
; ON CONTROL_C THEN [$] command 
;
; DESCRIPTION:
;	The ON CONTROL_C command indicates what action should be taken when 
;	a CTRL/C is pressed during the execution of a command procedure.  
;	"command" defines the DCL or CCL command to be performed whenever a
;	CTRL/C occurs.	Any valid DCL or CCL command may be specified, and 
;	all DCL command syntax rules apply.  The command may optionally be 
;	prefixed with a dollar sign ($).  A label cannot be specified with 
;	the command following the THEN clause.
;
;	Each command level has its own ON CONTROL_C setting.
;
;	This command is valid when in an ICF, and is ignored at the interactive
;	level.	There are no qualifiers for this command.
;
;
; OUTPUTS:
;	LSEVLV = indicates the new severity level that error checking is in
;		 affect for
;	LCLNFG = local context and local symbol table changed also
;
; Errors returned to the user's terminal are:
;
;	U.ICMD   = "?Invalid command"
;		    (the command following the THEN keyword was a label or
;		     was invalid)
;	THRQ.E  = "?THEN keyword required"
;		    (the THEN keyword was missing on the ON severity-level ...
;		     command)
;	THCR.E  = "?THEN clause required"
;		    (the command following the THEN keyword was missing on the
;		     ON severity-level ... command)
;
;-

ONC.CMD::$THR
	$DEFCMD	U.CMDC=-1		;ON CONTROL_C THEN ...
	$GOTO	ONTH.CMD		;

ONW.CMD::$THR
	$DEFCMD	U.CMDC=WARNING		;ON WARNING THEN ...
	$GOTO	ONTH.CMD		;

ONE.CMD::$THR
	$DEFCMD	U.CMDC=ERROR		;ON ERROR THEN ...
	$GOTO	ONTH.CMD		;

ONS.CMD::$THR
	$DEFCMD	U.CMDC=SEVERR		;ON SEVERE_ERROR THEN ...

ONTH.CMD:
	$NOLOCAL			;Error if not within a command procedure

	$PARKEY				;Parse the keyword THEN
	$ONKEY	THEN.K,20$		;Continue if found it
	$ENDKEY	FAIL=10$		;Error if it's missing
10$:	$DO				;
	MOV	LX.POS,LX.ERP		;Set error position to end of line
	MOV	#THRQ.E,R0		;"?THEN keyword required" error
	$ENDDO				;

20$:	$PARM	PARM1,U$REST,PF.OPT	;Allow for data that follows the THEN
	$ENDCMD				;

	$FETP	PARM1			;Fetch data following THEN
	$IF	ABSENT			;If no data then
	$DO				;
25$:	MOV	LX.POS,LX.ERP		;  Set up the error position
	MOV	#THCR.E,R0		;  "?THEN clause required" error
	$ENDDO				;
	$ENDIF				;Endif ... we have parameter

	$DO				;If only spaces and $'s then error
	MOV	U.CMN+U.POS,LX.POS	;Reset scan position
	CALBX	LX.SKP <#30$>		;Parse optional dollar signs, spaces
	TMPORG	TEXT			;and tabs
30$:	 .ASCIZ	"$"<SPACE><TAB>		;
	UNORG				;

	CALLX	LX.EOS			;At end of string ?		;061
	BCC	25$			;Yes,25$ so error 
					;No,LX.POS points to command after THEN
35$:	BIC	#STSUPD!SEVCHK,ICFFLG	;Clear flags to say we don't want
					; $STATUS changed or severity checked.
	MOV	LX.POS,R1		;Save beginning of command that follows
					; THEN clause (position of 'error')
	MOV	CMDLEN,R2		;Get length of entire command line
	SUB	R1,R2			;Subtract off everything before command
					; that follows THEN
	INC	R2			;Adjust by 1
	MOVB	R2,VALLNG		;Set up length of command string
	MOV	#CMDBUF,VALADR		;Address of command buffer
	ADD	LX.POS,VALADR		;Point to command following THEN
	DEC	VALADR			;Adjust by 1 since pointing past it
					; (set up address of value)
	MOV	LCAPTR,R2		;Get pointer to local context area
	MOVB	#CCTYP,TYPE		;Guess command entry type = "control/c"
	TST	U.CMN+U.CMDC		;Were we right?
	IFGE				;If not then
	MOVB	#ERRTYP,TYPE		;  Set type to "Error"
	MOVB	U.CMN+U.CMDC,LSEVLV(R2)	;  Indicate the new severity level for
					;  ... this ICF (cell in local context)
	ENDIF				;Endif
	CALLX	ADDCMD			;Change the value of the command entry
	BCS	50$			;Exit if an error occurs
	MOVB	#1,LCLNFG		;Indicate that local context area and
					;... local table needs to be updated
	CLR	R0			;Indicate no error
50$:	$ENDDO				;
	$ENDTHR				;

GLOBAL	<THRQ.E,THCR.E,U.ICMD,VALLNG,VALADR,LSEVLV,CMDBUF,CMDLEN>
GLOBAL	<U.CMN,TYPE,LX.ERP,LX.POS,LX.PMAT,ICFFLG,CCTYP,ERRTYP,LCLNFG>

.SBTTL	OPEN command
;+
; OPEN  channel-number  file-spec [/qualifiers]
;
; DESCRIPTION:
; 	This command opens a file or device for reading, writing or appending,
;	and assigns it a channel number in the range 1-13, as a way to 
;	reference the file with subsequent I/O commands.  The maximum number
;	of data files that can be open at any time is 13.  However, this value
;	is dependent on the number of levels of command procedure nesting used;
;	each open command file also requires one PFB channel.  This command is 
;	available in an ICF or at the interactive level.
;
;	The file can be disk or non-disk (KB, LP, PR, PP or CR), which can be
;	read or written to one block at a time without having to worry about 
; 	record blocking/deblocking.  Only disk files have been implemented so
;	far.  A CBB (Control/Block Buffer) is not set up by the OPEN command,
;	but only when doing I/O to the file; therefore the READ and WRITE
;	commands set it up.
;
;	No explicit OPEN command is needed for a user's terminal.  Channel
;	number 0 is permanently defined and can be used in a READ or WRITE
;	command to read from or write to a user's terminal.  All other files 
;	must be explicitly opened with the OPEN command.  An error message is
;	displayed if an attempt is made to open a file or device on channel 0.
;
;	Note that if a command procedure that opens a file exits without 
;	closing the file, then the file remains open; no automatic closing of
;	files occurs.
;
; The legal qualifiers are:
;
;	/APPEND - indicates that an existing file is to be opened for writing
;		  and positioned at the end of the file.  This qualifier is
;		  only allowed for RSTS/E stream ASCII (native mode) disk 
;		  files; an append cannot be performed to a file with RMS
;		  attributes.  If the file does not exist, then a new file is 
;		  created.
;
;	/READ	- indicates that the file should be opened for reading.  This
;		  is the default if /APPEND, /READ or /WRITE is not specified.
;
;	/WRITE 	- indicates that the file should be opened for writing.  If
;		  the file exists, then it is deleted and a new file is
;		  created.
;
;	/[NO]REPLACE - indicates whether or not an existing file matching the
; 		       the data file-spec should be replaced by the specified
;		       data file.  The /WRITE qualifier is required with this
;		       qualifier, but not vice versa.
; 
; OUTPUTS:
;	IOBCHN = updated IOB channels bit mask indicating channels being used
;	PFBCHN = updated PFB channels bit mask indicating channels being used
;	GBLNFG = updated to reflect that the global context area was updated
;
;
; 	The file, regardless of being disk or non-disk, is moved to the PFB.
; 	In addition, if it's a non-disk file, then an I/O channel is 
;	allocated for it so that subsequent READ and WRITE commands will work
;	(the file needs to be moved from the PFB to an IOB to do the I/O).
;
; Errors returned to the user's terminal are:
;
;	CHAN.E = "?Invalid channel number"
;	          (the channel number was not in the range 1-13)
;
;	U.IFIL = "?Invalid file specification"
;		  (the user's data file was invalid)
;
; 	U.WLD  = "?Wildcards not allowed"  
;		  (ex. OPEN 1 FOO.* or OPEN 10 *.DAT)
;
;	NOCH.E = "?No channels available"
;		  (an I/O or PFB channel is not available; returned by GETCHN
;		   routine)
;
;	U.FIEX = "?File does not exist"
;		  (the user's data file did not exist)
;
;	LDSK.E = "?Device must be disk"  
;		  (the user's data file was not a disk file)
;
;	FATR.E = "?Qualifier conflicts with file type"
;		  (user specified the /APPEND qualifier and the data file had 
;		   RMS attributes)
;
;	NCLS.E = "?Channel already open"
;		  (user specified a channel number which already had an open
;		   file on it)
;
;	U.ADDQ = "?Additional qualifier required"
;		  (user specified the /[NO]REPLACE qualifier but not the /WRITE
;		   qualifier)
;
;	NOAP.E = "?Write access not allowed"
;		  (user specified the /APPEND qualifier and he does not have
;		   write access to the data file)
;
;
; DSKCHN and IOCHAN are working cells, internal to this routine.  DSKCHN 
; contains the PFB channel # (*2) of where the open file is to be kept.
; IOCHAN contains the IOB channel # (*2) of where the file was opened, and
; for non-disk files this I/O channel is reserved for it.  The OPEN command
; has not been implemented for non-disk files yet.
;
;-

OPE.QL:	DEFQUAL	APP.Q,CONF=<REA.Q,WRI.Q,REP.Q>			;/APPEND
	DEFQUAL	REA.Q,CONF=<APP.Q,WRI.Q,REP.Q>			;/READ
	DEFQUAL	WRI.Q,CONF=<APP.Q,REA.Q>			;/WRITE
	DEFQUAL	REP.Q,FLAGS=QF.NEG,CONF=<APP.Q,REA.Q>,REQUIRE=WRI.Q
								;/[NO]REPLACE
	ENDQUAL				;

OPE.CMD::$THR				;
	$DEFCMD	QUAL=OPE.QL		;Point to the qualifier list
	$PARM	PARM2,TYPE=U$REST,PROMPT=CHAN$P ;Prompt with "Channel: "
	CHKCHN	PARM2,MINVAL=1,QUAL=OPE.QL	;Ensure channel number 1-13
					;Quit if not in range
	$PARM	PARM1,TYPE=LF.N,PROMPT=FIL$P				
					;Parse local filespec, name required
					;Prompt with "File: "
	DFLTCQ	REA.Q			;Default to /READ
	$ENDCMD				;

; Get the file entry in the global context area associated with the user 
; channel we are attempting to open.  This address is kept in R5 and is used
; throughout this routine so don't destroy it.

	$FETP	PARM2			;Fetch channel number, point CUI common
					;to it.
20$:					;VALUE = user specified chan # to open
	$DO				;
	MOV	R3,-(SP)		;Save R3 on the stack
	CALB	ENTADR <VALUE>		;Get address of data file entry in
					; global context (returned in R5)
					; (no errors can occur)
					; (keep addr in R5 for use everywhere)
	TSTB	FILPFB(R5)		;Is this channel already open ?
	IFNZ				;If so, then
	MOV	U.CMN+U.POS,LX.ERP	;  Set error position to channel #
	MOV	#NCLS.E,R0		;  "?Channel already open"
	JMP	130$			;  Print the error
					;   (no channels to return)
	ENDIF				;Endif

	CALB	FSSFIL	<#2>		;Fetch and FSS the filespec
					; (.DAT is default file type)
					; (sets FIRQB up with filename, type
					;  which is needed on OPNFQs or CREFQs)
	.ASSUME	DSKHND EQ 0		;Assume disk handler index is 0
	MOV	U.CMN+U.POS,LX.ERP	;Set error position to file spec ;079
	TSTB	XRB+XRMOD		;Is it a disk file ? (from FSS)
	IFNZ				;If not then
	MOV	#LDSK.E,R0		;  "?Device must be disk" error
30$:	JMP	130$			;  Quit (no channels to close)
	ENDIF				;Endif

; Allocate an I/O channel and then open or create the user's file on that 
; channel according to the qualifiers specified.  The file attributes are
; then read.

	MOV	IOBCHN,R4		;Load up bit mask for IOB channels
	CALL	GETCHN			;Get an I/O channel
					; (returns R1 = channel # *2)
	BCS	30$			;If a channel is not available, exit
	MOV	R1,IOCHAN		;Save channel # here for use throughout
	MOV	R4,IOBCHN		;Update the bit mask

; Open the file for reading.  If the file doesn't exist, then error.

	CALBX	FET.CQ <#REA.Q>		;Did he specify /READ ?
	IFCC				;If so then
	MOVB	#OPNFQ,FIRQB+FQFUN	;  'Open a file on a channel'
	MOV	IOCHAN,FIRQB+FQFIL	;  I/O channel number (*2)
	MOV	#OP$MOD!OP$RO,FIRQB+FQMODE; Mode = 'read only' and 'real'
					;  Filename,type was filled in by FSS
	CALL	DOCFIP			;  Open the file		;080
	IFCS				;  If an error occurred
	CMP	R0,#NOSUCH		;    "?Can't find file or account" ?
	IFZE				;    If so
	MOV	#U.FIEX,R0		;      Return "?File does not exist"
	ENDIF				;    Endif
	JMP	110$			;    Exit  (return I/O channel)
	ENDIF				;  Endif - no error occurred

       	;CLR	FILBYT(R5)		;  Clear the current record pointer
       	;CLRB	FILVBH(R5)		;  Clear current VBN (high order)
	MOV	#1,FILVBL(R5)		;  Set up current VBN (low order)
	BISB	#READFN,FILFLG(R5)	;  Indicate file is open for reading
					;   in file stack entry
	BR	70$			;  Read file attributes, move to PFB
	ENDIF				;Endif

; Open the file for writing.  If the file already exists, then conditionally
; delete it.

	CALBX	FET.CQ <#WRI.Q>		;Did he specify /WRITE ?
	IFCC				;If so then
	;CLR	FILBYT(R5)		;  Clear the current record pointer
	;CLRB	FILVBH(R5)		;  Clear current VBN (high order)
	MOV	#1,FILVBL(R5)		;  Set up current VBN (low order)
	BICB	#READFN,FILFLG(R5)	;  Indicate file is open for writing
					;   in stack entry (clear reading)
					;   (filespec is in FIRQB)
	MOV	#OP$MOD!OP$NOS,FIRQB+FQMODE;Real mode, set nosupersede switch
40$:	MOVB	#CREFQ,FIRQB+FQFUN	;  'Create file, open it on a channel'
	MOV	IOCHAN,FIRQB+FQFIL	;  I/O channel number (*2)
	CALL	DOCFIP			;  Create the file		;080
	BCC	70$			;  No error so continue on
					;   (much of file entry already set up)
	CMP	R0,#FIEXST		;  Was it "?Name or account exists ?"
	BNE	60$			;  No, some other error so exit
					;   (return IOB channel), R0=error
	CALB	WRIACC			;  Do we have write access to file?
	BCS	60$			;  No, ?Write access not allowed
	CALBX	FET.CQ	<#REP.Q>	;  Yes,did user specify /[NO]REPLACE ?
	IFCC				;  If so then
	TST	<U.CMN+U.NO>		;    Was it /REPLACE ?
	IFZE				;    If so then
50$:	CLR	FIRQB+FQMODE		;      Clear supersede switch
	BR	40$			;      Create it by superseding old one
	ENDIF				;    Endif - it was /NOREPLACE

	MOV	U.CMN+U.POS,LX.ERP	;    Point to the qualifier
	MOV	#FIEXST,R0		;    "?Name or account now exists"
60$:	JMP	110$			;    Return with error
					;     (return IOB channel)
	ENDIF				;  Endif - neither /[NO]REPLACE

; The file already existed when we attempted to create it, and the user did
; not indicate what action to take, so prompt him.

	CLR	CMDLEN			;  Initialize the command buffer
	MOV	#CMDBUF,CMDNEX		;  Point to start of buffer
	CALBX	U$RDM1 <#LOGX$P>	;  Prompt user with		;068
					;  "%File currently exists,replace it ?"
	BICB	#40,CMDBUF+1		;  Make the answer a capital letter
	CMPB	#'Y,CMDBUF+1		;  Did it begin with "Y" or "y" ?
	BEQ	50$			;  Yes, go replace the file
					;   (FIRQB still contains filespec)
	MOV	#U.QUIT,R0		;  No, quit
	BR	60$			;  Exit  (return IOB channel)
	ENDIF				;Endif

; Open the file for appending.  If it doesn't exist, then create the file.

	CALBX	FET.CQ <#APP.Q>		;Did he specify /APPEND ?
	IFCC				;If so then
	;CLR	FILBYT(R5)		;  Clear the current record pointer
	BICB	#READFN,FILFLG(R5)	;  Indicate file is open for writing
					;   in file stack entry (clear reading)
					;   (FSS filled in filename and type)
	MOVB	#OPNFQ,FIRQB+FQFUN	;  'Open a file on a channel'
	MOV	IOCHAN,FIRQB+FQFIL	;  I/O channel number (*2)
	CLR	FIRQB+FQMODE 		;  Assume no mode bits
	CALL	DOCFIP			;  Open the file		;080
	IFCC				;  If no error occurred
	CALB	WRIACC			;    Make sure he got write access
	BCS	110$			;    He didn't get it, quit with error
	MOVB	FIRQB+FQSIZM,FILVBH(R5)	;    Set MSB of file size into current
					;     VBN (high order)
	MOV	FIRQB+FQSIZ,FILVBL(R5)	;    Set LSB of file size into current
					;     VBN (low order)
	ADD	#1,FILVBL(R5)		;    Add one  (don't do an INC)
	ADCB	FILVBH(R5)		;    Add the carry to MSB if previous
					;     ADD to LSB sets it
	ELSE				;  Else - an error occurred
	CMPB	R0,#NOSUCH		;    "?Can't find file or account" ?
	BNE	110$			;    No, return IOB channel and exit
	;CLRB	FILVBH(R5)		;    Yes,clear current VBN (high order)
	MOV	#1,FILVBL(R5)		;    Set up current VBN (low order)
	BR	50$			;    Go create the file
	ENDIF				;  Endif
	ENDIF				;Endif

; The file is open on a channel.  Get a PFB channel to keep the data file 
; on for safe keeping while it is open.  If this fails, then exit immediately
; (user must first take corrective action such as closing an ICF or another 
; data file).

70$:	MOV	PFBCHN,R4		;Load up bit mask for PFB channels
	CALL	GETCHN			;Get a PFB channel
					; (returns R1 = PFB channel # *2)
	IFCS				;If a channel is not available then
	PUSH	R0			;  Save error code
	CALBX	FET.P	<#PARM1>	;  Point to channel number
	POP	R0			;  Restore error code
	MOV	U.CMN+U.POS,LX.ERP	;  Make it position of error
	BR	110$			;  Close IOB channel and exit
	ENDIF				;Endif
	MOV	R1,DSKCHN		;Save PFB channel # here for now
	MOV	R4,PFBCHN		;Update the bit mask 

; Read the attributes of the open file.

	MOV	IOCHAN,R1		;Get I/O channel of file for GETATR
	CALL	GETATR			;Get file attributes (returns R1,R2)
					;Error occur reading attributes ?
	BCS	100$			;Yes,100$ - report error
					; (return IOB and PFB channels)
	MOVB	FIRQB+RMSEBM,FILEBM(R5)	;Save file size MSB (GETATR returns)
	MOV	FIRQB+RMSEBL,FILEBL(R5)	;Save file size LSB (GETATR returns)
	MOV	FIRQB+RMSEOF,FILEOF(R5)	;Save end-of-fle byte (GETATR returns)
	CALBX	FET.CQ	<#APP.Q>	;No,did he specify /APPEND qualifier ?
	BCS	80$			;No,80$ so continue on
	TST	R2			;Yes,does the file have attributes ?
	BEQ	80$			;No,80$ so continue on (good)
	MOV	U.CMN+U.POS,LX.ERP	;Yes,point to qualifier for repainting
	MOV	#FATR.E,R0		;"?Qualifier conflicts with file type"
	BR	100$			;Do cleanup
					; (return IOB and PFB channels)

; Move the file from the IOB to a PFB for safe keeping.

80$:					;R1 = record size
					;R2 = record format
	CALLX	CLRFQX			;Clear FIRQB and XRB
	MOV	IOCHAN,FIRQB+FQPPN	;Specify IOB channel number (*2)
	MOVB	DSKCHN,FIRQB+FQNAM1	;Specify PFB channel number (*2)
	CALL	I2P			;Move from IOB to PFB
	BNE	100$			;Return PFB and IOB channels if error

; Set up the remaining cells in the file entry for this new open file in the 
; open files stack, which is located in the global context area of the user's
; global symbol table.

					;R5 = file's entry addr in file stack
	MOVB	DSKCHN,FILPFB(R5)	;Save PFB chan # (*2) where file is
					; being kept, whether disk or non-disk
	MOV	R1,FILRSZ(R5)		;Set up record size (GETATR returns)
	MOVB	R2,FILRFM(R5)		;Set up record format (GETATR returns)

; If the file is non-disk, then save the I/O channel.
;
;	MOVB	IOCHAN,FILIOB(R5)	;Save IOB channel # (*2)
;					; (is needed for doing I/O to it)
;					;I/O channel is reserved for this file
;	BR	130$			;Skip around error cleanup code

; Return the I/O channel since done with it (for disk files only).

90$:	MOV	IOCHAN,R1		;I/O channel # (*2) to return to pool
					; (chan we used to open the file on)
	MOV	IOBCHN,R4		;Load up IOB channels bit mask
	CALL	RTNCHN			;Return the IOB channel (in R1), but
					; don't close it (monitor did)
					; (no errors possible), sets STFNFG
	MOV	R4,IOBCHN		;Update the bit mask
	BR	130$			;Skip around error cleanup code

; The following cleanup code is needed if an error occurs along the way.

					;R0 = error code
					;R5=file's entry addr in file stack
; Return the PFB channel.
100$:	MOV	DSKCHN,R1		;R1 = PFB channel # *2
	MOV	PFBCHN,R4		;Load up PFB channels bit mask
					; (error code in R0 is retained)
	CALL	RTNCHN			;Return the PFB channel (in R1)
					; (no errors possible), sets STFNFG
	MOV	R4,PFBCHN		;Update the bit mask

; Close the IOB channel.
110$:	MOV	IOCHAN,R1		;I/O channel # (*2) to return to pool
					; (chan we used to open the file on)
	MOV	IOBCHN,R4		;Load up IOB channels bit mask
	CALL	RTNCLS			;Close and return IOB channel (in R1)
					; (no errors possible), sets STFNFG
	MOV	R4,IOBCHN		;Update the bit mask

; Zero out the data file stack entry.
	MOV	#FENTLN,R1		;# bytes in the file entry
	ASR	R1			;Convert to words
120$:	CLR	(R5)+			;Clear the entry in case any of it 
					; was set up
	SOB	R1,120$			;Til done
					;Report the error, repaint command line
130$:	MOV	(SP)+,R3		;Restore R3
	$ENDDO
	$ENDTHR

WRIACC:	BIT	#DDWLO,FIRQB+FQFLAG	;Granted write access to the file ?
	IFNZ				;If not then
	MOV	U.CMN+U.POS,LX.ERP	;  Point to /APPEND qualifier
	MOV	#NOAP.E,R0		;  "?Write access not allowed"
	ENDIF				;Endif
	RETURN				;

GLOBAL	<CHAN.E,NCLS.E,FATR.E,LDSK.E,U.FIEX,U.QUIT,U.CMN,LX.ERP>
GLOBAL	<IOBCHN,PFBCHN,DSKCHN,IOCHAN,CMDBUF,CMDLEN,CMDNEX>
GLOBAL	<VALUE,NOAP.E>

.SBTTL	OPEN/LOGFILE command
;+
; OPEN/LOG_FILE  file-spec [/qualifiers]
;
; DESCRIPTION:
;	This command opens a disk file for logging, and can be issued either
;	interactively or from within a command procedure.  Only one terminal
;	log file can be opened at any time.  In order to remind a user that
;	his session is being recorded in a log file, DCL changes its normal
;	prompt from "$" to "$." whenever a log file is open and enabled.
;
; Valid qualifiers are:
;
;	/APPEND 	- indicates that terminal data should be appended to 
;			  the end of the file specified.  An error occurs if
;			  /APPEND is specified for a file with RMS attributes.
;
;	/DISABLE	- indicates that terminal or command file output should
;			  not be initially logged to the file specified.  No
;			  logging occurs until the SET LOG_FILE/ENABLE command
;			  is issued to re-enable output.
;
;	/ENABLE		- indicates that terminal or command file output should
;			  be initially logged to the file specified.
;
;	/[NO]REPLACE 	- indicates whether or not an existing file matching 
;			  the log file-spec should be replaced by the specified
;			  log file.
;
;	/[NO]TIME_STAMP - indicates whether or not each line in the log file
;			  should be prefixed with a date/time stamp.
; Errors: 
;	LOGO.E = "?Log file already open"  
;	LDSK.E = "?Device must be disk"  
;	FIEXST = "?Name or account now exists"  
;	FATR.E = "?Qualifier conflicts with file type"
;		  (user specified the /APPEND qualifier and the log file had 
;		   RMS attributes)
;
;-

OPL.QL:	DEFQUAL	APP.Q,CONF=REP.Q		;/APPEND
	DEFQUAL	DSBL.Q,CONF=ENBL.Q		;/DISABLE 
	DEFQUAL	ENBL.Q,CONF=DSBL.Q		;/ENABLE
	DEFQUAL	REP.Q,FLAGS=QF.NEG,CONF=APP.Q	;/[NO]REPLACE
	DEFQUAL	TIMS.Q,FLAGS=QF.NEG		;/[NO]TIME_STAMP
	ENDQUAL

									;080+

OPL.CMD::$THR
	$DEFCMD	QUAL=OPL.QL
	$CHECK	LOG		        ;Is logfile open?
	$IF	PRESENT			;If so then
	$RETURN	LOGO.E			;  ?Log file already open
	$ENDIF				;Endif
	$PARM	PARM1,LF.N,PROMPT=FIL$P	;Parse required filespec 
	DFLTCQ	ENBL.Q			;Default to /ENABLE 
	$ENDCMD				;End of command

	$DO				;
	BIC	#TIMSTP,ICFFLG		;Disable timestamps by default	;072
	CALB	FSSFIL 			;FSS filespec
	MOV	U.CMN+U.POS,LX.ERP	;Point to filespec
	TSTB	XRB+XRMOD		;Is it disk?	
	BEQ	5$			;Yes, continue
	MOV	#LDSK.E,R0		;NO, "?Device must be disk" error
1$:	JMP	45$			;Quit

5$:	MOV	IOBCHN,R4		;Load bit mask for IOB channels
	CALL	GETCHN			;Get next available I/O channel
	BCS	1$			;Exit if an error occured
	MOV	R4,IOBCHN		;Update the bit mask
	MOVB	#LOKFQ,FIRQB+FQFUN	;Function is "Lookup file"	
	MOV	#-1,FIRQB+FQFIL		;Lookup by file name
	CALL	DOCFIP			;Go do it.  Does it exist?
	BCS	30$			;No, go create it.
	CALBX	FET.CQ <#APP.Q>		;Did they specify /APPEND?
	BCS	20$			;No,

;This is the append section of the OPEN/LOG command code.  If we got here
;then we know the file exists and the user specified /APPEND

	MOV	U.CMN+U.POS,R5		;Save /APPEND qualifier position
	CALB	FSSFIL 			;FSS filespec
	MOVB	R1,FIRQB+FQFIL		;R1 = chan*2 returned from GETCHN
	MOV	#OP$MOD!OP$APP,FIRQB+FQMODE; Mode = real and "open with append"
	MOVB	#OPNFQ,FIRQB+FQFUN	;Function is "Open a file"
	CALL	DOCFIP			;Open the file
	BCS	40$			;Quit if couldn't open file 
	CALL	LOADLG			;Save logfile spec
	BIT	#DDWLO,FIRQB+FQFLAG	;Granted write access to the file ?
	BEQ	10$			;Yes, continue
	CALLX	CLRFQB			;Clear the FIRQB
	MOVB	R1,FIRQB+FQFIL		;Pass the channel number to close
	CALL	DOCFIP			;Close the channel
	MOV	#NOAP.E,R0		;"?Write access not allowed"
	BR	15$			;Exit  

	; Read the attributes of the open file.
10$:	MOV	R1,-(SP)		;Save channel # over call
	CALL	GETATR			;Get file attributes (returns R1,R2)
	MOV	(SP)+,R1		;Restore channel #
	BCS	15$			;GETATR error so exit
	TST	R2			;RMS attributes?
	BEQ	35$			;No, so continue
	MOV	#FATR.E,R0		;"?Qualifier conflicts with file type"
	MOV	R5,LX.ERP		;Point to /APPEND qualifier
15$:	CLR	LOGFIL			;Clear logfile spec
	BR	40$			;Do cleanup
	
;/APPEND was NOT specified.  This code is only executed if this is NOT
;a /APPEND on the OPEN/LOG command.

20$:	CALBX	FET.CQ	<#REP.Q>	;Did they specify /[NO]REPLACE?
	BCS	25$			;No, so ask them
	TST	<U.CMN+U.NO>		;Yes, Was it /REPLACE?
	BEQ	30$			; Yes, so create a new one
	MOV	U.CMN+U.POS,LX.ERP	; NO, so Point to qualifier
	MOV	#FIEXST,R0		;?Name or account now exists
	BR	40$			;  Return with error

25$:	CLR	CMDLEN			;Initialize command
	MOV	#CMDBUF,CMDNEX		;... buffer
	CALBX	U$RDM1 <#LOGX$P>	;Prompt user - replace logfile?	;068
	MOV	#U.QUIT,R0		;Assume they will say No
	BICB	#40,CMDBUF+1		;Make character capital
	CMPB	#'Y,CMDBUF+1		;Did it begin with "Y" or "y"?
	BNE	40$			;No, so exit


;This code is executed if the specified log file does not exist.  It doesn't
;matter if they said /APPEND or not, the file doesn't exist and must be created

30$:	CALB	FSSFIL 			;Attempt to create the file
	CLR	FIRQB+FQMODE		;supersede the file
	MOVB	R1,FIRQB+FQFIL		;R1 = chan*2 returned from GETCHN
	MOVB	#CREFQ,FIRQB+FQFUN	;Function is "Create a file"
	CALL	DOCFIP			;Create the file
	BCS	40$			;Got an error so exit
	CALL	LOADLG			;Save the logfile spec

35$:	CALLX	CLRFQX			;Clear FIRQB and XRB
	MOV	R1,FIRQB+FQPPN		;Specify IOB chan number *2
	MOV	#PF$LOG*2,FIRQB+FQNAM1	;Specify PFB chan num *2 for logfile
	CALL	I2P			;Move from IOB to PFB
	CALLX	U$CHKE			;Abort if error, shouldn't happen
	BIS	#LOGACT,ICFFLG		;Logfile is now active

40$:	MOV	IOBCHN,R4		;Load the bit mask for IOB channels
					;(R1 = channel # *2)
	CALL	RTNCLS			;Close and return I/O channel to pool
	MOV	R4,IOBCHN		;Update the bit mask

45$:	$ENDDO				;  
	$GOTO	DOLOG			;Do /ENABLE, /DISABLE, and /TIMESTAMP
	$ENDTHR

LOADLG:	MOV	#LOGFIL,R4		;R4 -> LOG filespec storage	;075
	MOV	FIRQB+FQPPN,(R4)+	;Save PPN			;075
	MOV	FIRQB+FQNAM1,(R4)+	;Save file name			;075
	MOV	FIRQB+FQNAM1+2,(R4)+	; all of it			;075
	MOV	FIRQB+FQEXT,(R4)+	;Save the extension		;075
	MOV	FIRQB+FQDEV,(R4)+	;Save device name		;075
	MOV	FIRQB+FQDEVN,(R4)	; and unit number		;075
	RETURN
									;080-
GLOBAL	<IOBCHN,LDSK.E,LOGX$P,FIEXST,U.QUIT,LOGO.E,NOAP.E>
GLOBAL	<LX.ERP,U.CMN,ICFFLG,CMDLEN,CMDBUF,CMDNEX,FATR.E,LOGFIL>	;075

.SBTTL	READ command
;+
; READ  channel-number  symbol-name [/qualifiers]
;
; DESCRIPTION:
; 	This command reads the next record from a file or device opened for 
;	reading with the OPEN command and assigns its contents to the specified
;	symbol as a string value.  If the symbol name is not defined, then it
;	is created and assigned the record.  If it is already defined, then its
;	current value and type are replaced.  The maximum number of characters
;	that can be read in a single READ command is 255 characters.  An error 
;	message is displayed if an attempt is made to read from a file that 
;	was opened with the /WRITE or /APPEND qualifier. 
;
;	Channel number 0 is permanently defined and can be used in a READ 
;	command to read from a user's terminal (this is not implemented yet).  
;
;
; The legal qualifiers are:
;
;	/END_OF_FILE=label - specifies the line in the command procedure where
;			     control should be passed if an end-of-file 
;			     condition is detected on the read.  No record is
;			     returned when this condition occurs.
;
;	/GLOBAL - indicates that the symbol is a global symbol, and that only
;		  the global symbol table should be searched.  If the symbol
;		  is not found, then it is entered into the global table.  
;		  This is the default for the interactive command level.
;
;	/LOCAL -  indicates that the symbol is a local symbol, and that only
;		  the local symbol table should be searched.  If the symbol
;		  is not found, then it is entered into the local table.  
;		  This is the default for all command levels except the
;		  interactive level.
; 
;
; Errors returned to the user's terminal are:
;
; 	EOF.E   = "?End of file on device"
;		    (an end of file was reached and the user did not specify
;		     /END_OF_FILE=label)
;
;	CHAN.E  = "?Invalid channel number"
;		    (user specified a channel number outside the range 1-13)
;
;	ILVL.E  = "?Invalid at interactive level"
;		    (user specified the /LOCAL qualifier when not in an ICF)
;
;	NORD.E  = "?Channel not open for input"
;		    (the channel the user is attempting to read from was
;		     opened in write or append mode)
;
;-

REA.QL:	DEFQUAL	DEL.Q,QF.NEG			;/[NO]DELIMITER
	DEFQUAL	GBL.Q,CONF=LCL.Q		;/GLOBAL
	DEFQUAL	LCL.Q,CONF=GBL.Q		;/LOCAL
	DEFQUAL	EOF.Q,ARG=REQ			;/END_OF_FILE=label
	 DEFARG TYPE=U$CLBL
	 ENDARG
	ENDQUAL

REA.CMD::$THR
	$DEFCMD	QUAL=REA.QL
	$PARM	PARM1,U$REST,PROMPT=CHAN$P ;Prompt with "Channel: "
	CHKCHN	PARM1,MINVAL=1,QUAL=REA.QL;Ensure channel number 1-13
					;Quit if not in range
	$PARM	PARM2,TYPE=U$SYMN,PROMPT=SYMN$P
	$ENDCMD
	DFLTCQ	DEL.Q,NO		;Default to /NODELIMITER

	$CHECK	ICF			;Are we under an ICF?
	$IF	ABSENT			;If not then
	$DISALL <LCL.Q> ILVL.E		;  Disallow /LOCAL
	$ENDIF				;Endif  

	$MOVB	STRTYP,TYPE		;Set the symbol type to string
	$FETCQ	LCL.Q			;Did he specify /LOCAL?
	$IF	PRESENT			;If so then
	$MOVV	LCAPTR,SCOPE		;  Set scope to local
	$ELSE				;Else
	$FETCQ	GBL.Q			;  Did he specify /GLOBAL?
	$IF	PRESENT			;  If so then
	$MOVV	GCAPTR,SCOPE		;    Set scope to global
	$ELSE				;  Else
	$CHECK	ICF			;    Are we in an ICFP?
	$IF	SUCCESS			;    If so then
	$MOVV	LCAPTR,SCOPE		;      Set scope to local
	$ELSE				;    Else	
	$MOVV	GCAPTR,SCOPE		;      Set scope to global
	$ENDIF				;    Endif
	$ENDIF				;  Endif
	$ENDIF				;Endif

	$FETP	PARM2			;Fetch the symbol name so we can
	$CHKSN				;Check for valid symbol name	;060

	$FETP	PARM1			;Fetch channel number
	$DO				;Ensure channel is open for input
	MOV	U.CMN+U.POS,LX.ERP	;Assume any error from here on will
					;have to do with the to channel number
	CALB	FNDCHN	<VALUE>		;Find status of channel
	CMP	R0,#-1			;Is it open for READ?
	IFNE				;If not then
	MOV	#NORD.E,R0		;  "?Channel not open for input"
	BR	260$			;  Quit	
	ENDIF				;Endif

	CALB	GETCBB	<VALUE>		;Get a CBB for me, please.  Thanks
	CALB	ENTADR	<VALUE>		;Get pointer to data entry

; R1 --> CBB
; R2 =   PFB channel number * 2, set up by FNDCHN earlier
; R5 --> Data entry

	MOV	FILRSZ(R5),PF.RSZ(R1)	;Set record size in CCB
	MOVB	FILRFM(R5),PF.RFM(R1)	;Set record format also
	MOVB	FILEBM(R5),PF.EBM(R1)	;Set file size MSB
	MOV	FILEBL(R5),PF.EBL(R1)	;Set file size LSB
	MOV	FILEOF(R5),PF.EOF(R1)	;Set eof byte number

	CLR	BORFLG			;Assume a full record will get read
	CALLX	CLRFQX			;Clear the FIRQB and XRB
	MOVB	R2,XRB+XRCI		;PFB channel number * 2
	MOV	#SUBBUF,XRB+XRLOC	;Address of buffer to read record into
	MOV	#SUB.BSIZ,XRB+XRLEN	;Length of record buffer
	MOV	R1,XRB+XRMOD		;Address of CBB
40$:	MOVB	#IO.PF,FIRQB+FQFIL	;Function is "I/O, PFB style"
	.PFB				;Fire up PFB	
	BISB	FIRQB+0,R0		;Set any error code
	IFNZ				;If an error occurred
	CMP	R0,#EOF			;  Was error ?End of file on device?
	BNE	60$			;  No, something else so quit
	BIT	#ICFACT,ICFFLG		;  Yes.  Is a command file active?
	BEQ	50$			;  No, return EOF regardless
	CALBX	FET.CQ	<#EOF.Q>	;  Yes.  ?EOF
	TST	U.CMN+U.PRES		;  Did user specify /EOF=label?
	IFEQ				;  If not then
50$:	MOV	#EOF.E,R0		;    Make it DCL's ?EOF else CUI 
					;    traps it and prints nothing.
260$:	BR	60$			;    Quit
	ENDIF				;  Endif
					;  The user specified /EOF=label
	CALBX	FET.A			;  Fetch the label
	.ASSERT	U.CMN+U.PRES EQ #-1	;  The label is present
	CALL	DOGOTO			;  Go to this label
	BR	60$			;  Quit
	ENDIF				;Endif

; Did we read a whole record? The following tests find out.
; They are somewhat complicated because the PFBIO code in the monitor
; does not set the PF.BOR flag properly on RMS files.  We have read a
; whole RMS record if PF.CNT = 0 and bits PF.CR, PF.LF, & PF.C1P are all
; clear.

	TSTB	FILRFM(R5)		;Are we reading from an RMS file?
	BEQ	51$			;No, go look at PF.BOR bit
	TST	PF.CNT(R1)		;Is remaining char count zero?
	BNE	52$			;No, we don't have a full record.
	BIT	#<PF.CR!PF.LF!PF.C1P>,PF.FLG(R1)
					;Are any of this bits set?
	BNE	52$			;Yes, we don't have a full record.
	BR	53$			;No! We have a whole record! Make
					;off with it before something happens...

51$:	BIT	#PF.BOR,PF.FLG(R1)	;Did a whole record get read in?
	IFEQ				;If not then
52$:	MOV	#SUB.BSIZ,BORFLG	;  %Record too long, line truncated
	CALLX	INITRN			;  Ensure TRNBUF is clear
	MOV	#TRNBUF,XRB+XRLOC	;  Address of buffer to read record into
	MOV	#TRN.BSIZ,XRB+XRLEN	;  Length of record buffer
	CLR	XRB+XRBC		;  0 --> READ (was set to byte count)
	BR	40$			;  Continue PFB directives until entire
					;  record is read.
	ENDIF				;Endif

53$:	MOV	BORFLG,R2		;Get number of characters in read
	BNE	55$			;Buffer overflowed, don't stip delimiter
	MOV	XRB+XRBC,R2		;Save number of characters read
	CALBX	FET.CQ	<#DEL.Q>	;Did he specify /[NO]DELIMITER?
	.ASSERT	U.CMN+U.PRES EQ #-1	;(It's there by default)
	TST	U.CMN+U.NO		;Was it /DELIMITER?
	BEQ	55$			;Yes, don't strip delimiter
	TSTB	FILRFM(R5)		;Is this an RMS file?
	BEQ	54$			;No, strip delimiter
	BIT	#RF.IMP,FILRFM(R5)	;Yes. Is carriage control implied?
	BEQ	55$			;No, don't strip delimiter
       ;BR	54$			;Yes. Monitor appended an unwanted
					; <CR><LF>.
54$:	SUB	#2,R2			;Strip off delimiter (assume <CR><LF>)
	CMPB	SUBBUF(R2),#CR		;Was delimiter <CR><LF>?
	BEQ	55$			;Yes, we were right
	INC	R2			;No, increment character count
55$:	MOV	PF.BYT(R1),FILBYT(R5)	;Copy current pointers into global 
	MOV	PF.VBL(R1),FILVBL(R5)	; context area
	MOVB	PF.VBH(R1),FILVBH(R5)	; ...
	MOVB	#1,GBLNFG		;Set global table file no good flag
					;... so stb will get updated
	CALLX	INITRN			;Ensure TRNBUF is clear
60$:	$ENDDO				;	

	$FETP	PARM2			;Fetch symbol name
	PUTSTR				;Store string in TRNBUF
	$DO				;Make assignment
	MOVB	R2,VALLNG		;R2 = character count
	MOV	#SUBBUF,VALADR		;SUBBUF contains string
	MOV	#TRNBUF,NAMADR		;Name address = TRNBUF
	MOVB	TRNLEN,NAMLNG		;Name length = length of TRNBUF string 
	MOVB	#STRTYP,TYPE		;Type = string
	CALBX	ADDSYM			;Add the symbol to user's symbol table
	BCC	70$			;No error occured, continue
	CMP	R0,#U.QUIT		;Was the error "quit"?
	BNE	80$			;No, something else, print that error
70$:	TST	BORFLG			;Did buffer overflow?  
	BEQ	80$			;No, it didn't
	MOV	#NORC.E,R0		;Give warning if symbol overflowed
	CLR	LX.ERP			;No uparrow
80$:	CALLX	INITRN			;Clean up TRNBUF
	$ENDDO				;Done
	$ENDTHR				;Yup

GLOBAL	<NORD.E,VALLNG,SUBBUF,VALADR,TRNBUF,NAMADR,NAMLNG,TYPE>
GLOBAL	<SUB.BSIZ,TRN.BSIZ,EOF,EOF.E,NORC.E,STFNFG>
GLOBAL	<ILVL.E,SCOPE,TYPE,VALUE,U.CMN,LX.ERP,ICFFLG>

.SBTTL	RETURN command

;+
; RETURN [exit_status_expression]
;
; Description:
;	This command returns control to the statement following
;	the matching GOSUB.  The parameter to this command can be an
;	expression which allows you to specify the severity returned by
;	the RETURN command.
;-

RET.CMD::
	$THR
	$DEFCMD
	$NOLOCAL			;Not valid at interactive level
	$PARM	PARM1,U$REST,FLAGS=PF.OPT
	$ENDCMD
	$FETP	PARM1			;Fetch severity expression
	$DO
	TST	U.CMN+U.PRES		;Is expression present?
	IFNE				;If so then
	MOV	U.CMN+U.POS,LX.POS	;  Reset scan position
	PUSH	R3			;  Preserve R3 across call
	CALLX	DOEXPI			;  Evaluate expression and get integer
					;  ... result (R1=low, R2=high)
	POP	R3			;  Restore R3
	BCS	10$			;  Quit if errors
	CALLX	LX.EOS			;  Are we at end-of-line	;061
	BCS	10$			;  No, so error
	CALBX	$STATUS <R1,R2>		;  Update $STATUS & $SEVERITY
	ENDIF				;Endif
	BIC	#STSUPD,ICFFLG		;Set flags saying we don't want
					;... $STATUS changed 
	MOVB	SEVERITY+GCA+GCASIZ-RSVBEG,ERRFLG			;062
					;Get current severity level (or	;062
					; the status specified)		;062
	MOVB	#1,EXTFLG		;Set flag indicating the ERRFLG is to be
					; used to determine severity checks
	CALLX	CLRFQB			;Clear the FIRQB to recieve data
	CALLX	POPPOS			;Pop the position stack and put data
					;... into FIRQB
	BCS	10$			;Return if error
	CALL	GOTOPOS			;Reposition the ICF to the line with
					;... with our GOSUB on it
	BCS	10$			;Return if error
	MOV	#-1,-(SP)		;Set for KBM (^C) read		;067
	;CALLX	GETPMT			;Get prompt string in R3	;067
	CLR	-(SP)			;No prompt string for .COM	;067
	CLR	-(SP)			;Set for no PREFIX		;067
	MOV	SP,R3			;Point to arg list		;067
	MOV	#TI.NCH,RDMOD		;Read without echoing this line	;074
	CALLX	U$RDCMD			;Read a command			;067
	ADD	#6,SP			;Pop arguments off the stack	;067

	;CALLX	READ,R5,<CMDBUF,CMDLEN>	;Skip the GOSUB and get the next
					;... command to be executed
	;BCS	10$			;Return if error
10$:	$ENDDO
	;$RDCMD				;Skip GOSUB command		;067
	$ENDTHR

GLOBAL	<ERRFLG,EXTFLG,SEVERITY,GCA,GCASIZ,RSVBEG,RDMOD>

.SBTTL	SET [NO]CONTROL_C command 
;+
; SET [NO]CONTROL_C 
;
; DESCRIPTION:
;	These commands enable and disable CTRL/C checking.  SET NOCONTROL_C 
;	disables CTRL/C checking within a command procedure.  SET CONTROL_C 
;	reenables CTRL/C checking that has been disabled by the SET NOCONTROL_C
;	command.  Note that SET NOCONTROL_C does not disable CTRL/C trapping
;	in a task; only the action established in an ON CONTROL_C THEN command.
;	Each command level has its own SET [NO]CONTROL_C setting.  When an ICF 
;	is invoked, CTRL/C checking is enabled by default.
; 
;	This command is valid when in an ICF, and is ignored at the interactive
;	level.	There are no qualifiers for this command.
;
;
; OUTPUTS:
;	LCCFLG = set or cleared accordingly
;	LCLNFG = local context and local symbol table changed also
;
; Errors returned to the user's terminal are:
;
;	None.
;
;-

CTC.CMD::$THR				;SET CONTROL_C
	$DEFCMD	U.CMDC=1		;Indicate to enable CTRL/C checking 
					; for the current command procedure
					; (no qualifiers allowed)
	$GOTO	DOCC			;Continue on 

NCTC.CMD::$THR				;SET NOCONTROL_C
	$DEFCMD	U.CMDC=0		;Indicate to disable CTRL/C checking
					; for the current command procedure
					; (no qualifiers allowed)
DOCC:	$NOLOCAL			;Error if not within a command procedure
	$DO				;Allow an optional =C here
	CALLX	LX.BLA			;Parse blanks			;061
	CALLX	LX.EOS			;Are we at end of string?	;061
	BCC	8$			;Yes, quit
	CALBX	LX.MEM	<#5$>		;Match a : or =
	BCS	7$			;Not found ?Unexected character
	CALLX	LX.BLA			;Parse blanks			;061
	CALBX	LX.MEM	<#6$>		;Match an "C"
	 TMPORG	TEXT			
5$:	  .ASCIZ ":="
6$:	  .ASCIZ "Cc"
	 UNORG	
	BCC	8$			;No error found
7$:	MOV	#U.UCHR,R0		;?Unexpected character if error
	MOV	LX.POS,LX.ERP		;Point to bad character
8$:	$ENDDO
	$ENDCMD				;No parameters

	$DO				;
	MOV	LCAPTR,R0		;Get pointer to local context area
	CMPB	U.CMN+U.CMDC,LCCFLG(R0)	;Is the status changing?
	BEQ	10$			;No, nothing to do
	MOVB	U.CMN+U.CMDC,LCCFLG(R0)	;Enable/disable CTRL/C checking
					; (updates cell in local context)
	IFNE				;If this is SET CONTROL=C then
	CALLX	READCC			;  Disregard any control_c's that 
	CLRB	DCLFLG			;  occured during NOCONTROL=C	;076
	ENDIF				;Endif
	MOVB	#1,LCLNFG		;Indicate that local context area and
					; local table needs to be updated
10$:	CLR	R0			;No errors
	$ENDDO				;
	$ENDTHR				;

GLOBAL	<U.CMN,U.QUIT,LCLNFG,LCCFLG,U.UCHR,LX.POS,LX.ERP,DCLFLG>

.SBTTL	SET [NO]DATA command
;+
; SET [NO]DATA [/qualifier]
;
; DESCRIPTION:
;	This command is used within a command procedure to indicate that
;	all terminal data requested by a task be supplied by reading from
;	the user's terminal and not from the command procedure.  The SET DATA
;	command indicates that all data requested be read from the command
;	file.  The SET [NO]DATA setting is local to a command procedure and
;	therefore, when a command procedure exits, the current setting of the
;	higher level procedure is restored.
;
;	When a command procedure is invoked, SET DATA is in effect.  The
;	/END_OF_DATA qualifier is only permitted with the SET DATA command.
;
; The legal qualifiers are:
; 
;	/END_OF_DATA="char" -  when used with the SET DATA command, identifies
;			       an alternate prefix character which signals the 
;			       end of data.  The prefix character is automat-
;			       ically set back to $ once the alternate prefix 
;			       character is encountered and control returns to 
;			       DCL.
;
;
; Errors returned to the user's terminal are:
;
; 	SING.E  = "?Single character expected"
;		    (the user specified more than one character when using the
;		     the /END_OF_DATA="char" qualifier)
;
;-

; Qualifier list
DAT.QL:	DEFQUAL	EOD.Q,ARG=REQ		;/END_OF_DATA="char"
	 DEFARG	TYPE=U$QUOT		;A single char enclosed in quotes 
	 ENDARG
	ENDQUAL				;

DAT.CMD::$THR				;SET DATA
	$DEFCMD	QUAL=DAT.QL		;Point to qualifier list
	$ENDCMD				;
	$NOLOCAL			;Error if not within a command procedure

	$CLRFQB				;Clear the FIRQB
	$FETCQ	EOD.Q			;Fetch /END_OF_DATA qualifier
	$IF	PRESENT			;If present
	$FETA				;  Fetch the argument
	$DO				;
	CMP	#3,U.CMN+U.LEN		;  Arg three characters long?
	BEQ	10$			;  Yes, that's good
	MOV	U.CMN+U.POS,LX.ERP	;  No, that means trouble
	MOV	#SING.E,R0		;  ?Single character expected
	BR	20$			;  Go error

10$:	MOV	#U.CMN+U.STR,R4		;  Point to string
	MOVB	1(R4),FIRQB+FQPROT	;  Put character into place
SET.DC:					;  The @ command uses the remaining
					;  ... portion of this $DO as a routine.
					;  ... This technique is a hack but it
					;  ... saves valuable space.
	MOV	#PF$ICF*2,FIRQB+FQNAM1	;  Load PFB channel number *2
	MOVB	#FLG.PF,FIRQB+FQFIL	;  'Set/clear' EOD character
	.PFB				;  Do PFB
	CLR	R0			;  Any error?
	BISB	FIRQB+0,R0		;  If so then quit
20$:	$ENDDO				;  
	$CLRFQB				;  Re-clear the FIRQB
	$ENDIF				;Endif

	$MOV	J2NDAT,FIRQB+FQBUFL	;Clear the 'nodata' flag (set)
	$GOTO	DODAT			;Go set the flag

NDAT.CMD::$THR				;SET NODATA
	$DEFCMD				;No qualifiers allowed
	$ENDCMD				;No parameters
	$NOLOCAL			;Error if not within a command procedure
	$NOBATCH			;Error if we are in batch

	$CLRFQB				;Clear the FIRQB
	$MOV	J2NDAT,FIRQB+FQFLAG	;Set the 'nodata' flag (clear)
DODAT:	$DO				;
SET.DF:					;@ command uses this $DO as a routine.
					;... This techinique is a hack but it
					;... saves valuable space.
	CALLX	JBFPF2			;Set/Clear job flags
;gmb	CLR	R0			;
;gmb	BISB	FIRQB+0,R0		;Carry over any error
	$ENDDO				;
	$ENDTHR				;

GLOBAL	<U.CMN,LX.ERP,SING.E>

.SBTTL	SET [NO]ECHO command
;+
;-

ECH.QL:	DEFQUAL	WAR.Q,QF.NEG		;/[NO]WARNINGS
	ENDQUAL

NEC.CMD::$THR
	$DEFCMD	QUAL=ECH.QL
	$ENDCMD
	DFLTCQ	WAR.Q			;Default to /WARNINGS
	$CLRFQB				;Clear the FIRQB
	$FETCQ	WAR.Q			;Did he specify /[NO]WARNINGS?
	$IF	NO			;If /NOWARNINGS then
	$MOV	J2NCHO!J2NERR,FIRQB+FQFLAG; Set the PFB 'noecho,noerrors' flag 
	$ELSE				;Else
	$MOV	J2NCHO,FIRQB+FQFLAG	;   Set the PFB 'noecho' flag 
	$MOV	J2NERR,FIRQB+FQBUFL	;   Clear the PFB 'noerrors' flag 
	$ENDIF				;Endif
	$GOTO	DOECH			;Go do PFB

ECH.CMD::$THR
	$DEFCMD
	$ENDCMD
	$CLRFQB				;Clear the FIRQB
	$MOV	J2NCHO,FIRQB+FQBUFL	;Clear the PFB 'noecho' flag

DOECH:	$DO				;
	CALLX	JBFPF2			;Set/Clear job flags
;gmb	CLR	R0			;Clear R0
;gmb	BISB	FIRQB,R0		;Set up the error code
	$ENDDO				;
	$ENDTHR				;

.SBTTL	SET LOGFILE command
;+
; SET LOG_FILE  [/qualifiers]
;
; DESCRIPTION:
;	This command permits a user to control various features in the logfile.
;	Logging to a log file can be selectively enabled and disabled, and
;	time-stamping can be selectively turned on and off.  This command can 
;	be issued either interactively or within a command file.
;
;
; Qualifiers:
;	/DISABLE 	- terminal or command file output should not be output 
;			  to the current log file
;
;	/ENABLE 	- all terminal or command file output is logged 
;
;	/[NO]TIME_STAMP - indicates whether or not each line in the log file
;			  should be prefixed with a date/time stamp
;
;
; Errors: 
;	LGFL.E = "?Log file not currently open"  
;		   (user issued SET LOGFILE/DISABLE or SET LOGFILE/ENABLE and 
;		    a logfile did not exist)
;
;-

						; Qualifier list 
LOGF.QL:DEFQUAL	DSBL.Q,CONF=ENBL.Q		;/DISABLE 
	DEFQUAL	ENBL.Q,CONF=DSBL.Q		;/ENABLE
	DEFQUAL	TIMS.Q,FLAGS=QF.NEG		;/[NO]TIME_STAMP
	ENDQUAL

LOGF.CMD::$THR				;SET LOGFILE
	$DEFCMD	QUAL=LOGF.QL		;Point to qualifier list
	$ENDCMD				;

	$CHECK	LOG			;Is log file open already?
	$IF	ABSENT			;If not then
	$DO				; Go into MACRO			;071
	MOV	CMDPOS,LX.ERP		;  Point to start of command	;071
	MOV	#LGFL.E,R0		;  ?Log file not currently open	;071
	$ENDDO				; And quit			;071
	$ELSE				;Else	
DOLOG:	$CLRFQB				;  Clear the FIRQB
	$FETCQ	DSBL.Q			;  Did he specify /DISABLE?
	$IF	PRESENT			;  If so then
	$BIS	PF.ACT,FIRQB+FQBUFL	;    Clear the 'enable' flag
	$BIC	LOGACT,ICFFLG		;    Indicate logfile not active
	$ENDIF				;  Endif
	$FETCQ	ENBL.Q			;  Did he specify /ENABLE?
	$IF	PRESENT			;  If so then
30$:	$BIS	PF.ACT,FIRQB+FQFLAG 	;    Set the 'enable' flag 
	$BIS	LOGACT,ICFFLG		;    Indicate logfile active
	$ENDIF				;  Endif
40$:	$FETCQ	TIMS.Q			;  Did he specifiy /[NO]TIMESTAMP?
	$IF	PRESENT			;  If so then 
	$IF	YES			;    If /TIMESTAMP then
	$BIS	TIMSTP,ICFFLG		;      Say timestamps enabled	;072
	$BIS	PF.TIM,FIRQB+FQFLAG	;      Enable time stamping 
	$ELSE				;    Else
	$BIC	TIMSTP,ICFFLG		;      timestamps disabled	;072
	$BIS	PF.TIM,FIRQB+FQBUFL	;      Disable time stamping 
	$ENDIF				;    Endif
	$ENDIF				;  Endif
	$PFBFLG				;  Do PFB flags, report errors
	$ENDIF				;Endif
	$ENDTHR				;Done with SET LOGFILE (and OPEN/LOG)

GLOBAL	<LGFL.E,ICFFLG,CMDPOS,LX.ERP>					;071

.SBTTL	SET [NO]ON command
;+
; SET [NO]ON 
;
; DESCRIPTION:
;	These commands enable and disable error checking.  SET NOON indicates
;	that DCL should not check the status code returned from the last
;	command, task or command procedure.  SET ON is specified in order to
;	re-enable error checking that has been disabled by the SET NOON command.
;	Error checking resumes at the severity level specified by the last
;	ON ... THEN ... command.  Each command level has its own SET [NO]ON
;	setting.  When an ICF is invoked, error checking is enabled by default.
; 
;	This command is valid when in an ICF, and is ignored at the interactive
;	level.	There are no qualifiers for this command.
;
;
; OUTPUTS:
;	LERFLG = set or cleared accordingly
;	LCLNFG = local context and local symbol table changed also
;
; Errors returned to the user's terminal are:
;
;	None.
;
;-

ON.CMD::$THR				;SET ON
	$DEFCMD	U.CMDC=1		;Indicate to enable error checking for
					; the current command procedure
					; (no qualifiers allowed)
	$ENDCMD				;No parameters
	$GOTO	DOON			;Continue on 

NOON.CMD::$THR				;SET NOON
	$DEFCMD	U.CMDC=0		;Indicate to disable error checking 
					; for the current command procedure
					; (no qualifiers allowed)
	$ENDCMD				;No parameters
DOON:	$NOLOCAL			;Error if not within a command procedure
	$DO				;
	MOV	LCAPTR,R0		;Get pointer to local context area
	MOVB	U.CMN+U.CMDC,LERFLG(R0)	;Enable/disable error checking
					;(updates cell in local context)
	MOVB	#1,LCLNFG		;Indicate that local context area 
					;and local table needs to be updated
	CLR	R0			;No errors
10$:	$ENDDO				;
	$ENDTHR				;

GLOBAL	<U.CMN,LCLNFG,LERFLG>

.SBTTL	SET [NO]VERIFY command
;+
; SET [NO]VERIFY [/qualifiers]
;
; DESCRIPTION:
;	This command affects the displaying of command lines at the user's 
;	terminal during the exection of a command file.  In a command 
;	procedure, when 'noverify' is in affect, the monitor displays the 
;	command line (and warning and error messages) only when an error 
;	occurs.  
;
;	SET VERIFY controls the displaying of the command line before any
;	substitution has been performed.  SET NOVERIFY is the default.
;
;	The actions of SET VERIFY remain in effect until another SET VERIFY 
;	command changes the settings or until you log out.  The VERIFY 
;	setting is global to all command procedures and remains in effect
;	until it is changed.
;
; The legal qualifiers are:
; 
;	/[NO]DEBUG - indicates whether or not command debugging should be
;		     enabled.  When enabled, DCL displays the command line 
;		     twice:  once as it was read and again as it appears
;		     after all apostrophe substitution has been performed.  
;		     The substituted command line will appear in parentheses.
;		     Without /DEBUG in effect, the substituted command line 
;		     will not be printed out unless an error occurs.
;
;-

; Qualifier list

VER.QL:	DEFQUAL	DEB.Q,FLAGS=QF.NEG	;/[NO]DEBUG
	DEFQUAL	NOP.Q,FLAGS=QF.NEG	;/[NO]NOP
	DEFQUAL	WAT.Q,FLAGS=QF.NEG	;/[NO]WATCH
	ENDQUAL

VER.CMD::$THR				;SET VERIFY
	$DEFCMD	QUAL=VER.QL		;Point to qualifier list
	DFLTCQ	DEB.Q,AFFIRM=NO		;Default to /NODEBUG
	$ENDCMD				;
	
	$FETCQ	WAT.Q			;Did he specify /[NO]WATCH?
	$IF	PRESENT			;If so then
	$IF	YES			;  If /WATCH then
	$DO				;
	BISB	#WATCH,WATFLG		;    Set flag to indicate /WATCH
	$ENDDO				;
	$ELSE				;  Else
	$DO				;
	BICB	#WATCH,WATFLG		;    Clear flag to indicate /NOWATCH
	$ENDDO				;
	$ENDIF				;  Endif
	$ENDIF				;Endif

	$FETCQ	NOP.Q			;Did he specify /[NO]NOP?
	$IF	PRESENT			;If so then
	$IF	YES			;  If /NOP then
	$DO				;
	BISB	#NOP,WATFLG		;    Set flag to indicate /NOP
	$ENDDO				;
	$ELSE				;  Else
	$DO				;
	BICB	#NOP,WATFLG		;    Clear flag to indicate /NONOP
	$ENDDO				;
	$ENDIF				;  Endif
	$ENDIF				;Endif

	$FETCQ	DEB.Q			;Did he specify /[NO]DEBUG?
	$IF	YES			;If /DEBUG then
	$DO				;
	BISB	#DEBUG,WATFLG		;  Set debug flag to indicate /DEBUG
	$ENDDO				;
	$ELSE				;Else
	$DO				;
	BICB	#DEBUG,WATFLG		;  Clear flag to indicate /NODEBUG
	$ENDDO				;
	$ENDIF				;Endif

	$CLRFQB				;Clear the FIRQB
	$MOV	J2VFY,FIRQB+FQFLAG 	;Set the PFB 'verify' flag 
	$GOTO	DOVER			;Go set flag

NVER.CMD::$THR				;SET NOVERIFY
	$DEFCMD				;No qualifiers allowed
	$ENDCMD				;No parameters

	$DO				;
	BICB	#DEBUG!WATCH!NOP,WATFLG	;Clear DEBUG, WATCH, and NOP flags 
	$ENDDO				;
	$CLRFQB				;Clear the FIRQB
	$MOV	J2VFY,FIRQB+FQBUFL	;Clear the PFB 'verify' flag

DOVER:	$DO				;
	MOVB	#1,GBLNFG		;We updated global context- /DEB/WAT/NOP
	CALLX	JBFPF2			;Set/Clear job flags
;gmb	CLR	R0			;Clear R0
;gmb	BISB	FIRQB,R0		;Set up the error code
	$ENDDO
	$ENDTHR				;

GLOBAL	<WATFLG>

.SBTTL  SHOW SYMBOL command
;+
; SHOW SYMBOL [symbol-name] [/qualifiers]
;
; DESCRIPTION:
; 	This command displays the current value of a local or global symbol,
;	or of all symbols in either symbol table on the user's terminal.
;	If a symbol name is not specified, then the entire symbol table is
;	displayed.
;
; The legal qualifiers are:
; 
;	/ALL   -  used in conjunction with either /GLOBAL or /LOCAL to
;		  request that the current values of all symbols in the
;		  specified table be displayed.  If /ALL and a symbol name
;		  are specified, then the symbol name overrides /ALL.
;
;	/GLOBAL - 
;		  1. When used in conjunction with /ALL, all names in the
;		      global symbol table are displayed.
;		  2. When a symbol name is specified, then search the global 
;		      symbol table for the symbol name and display its volume.
;
;	/LOCAL  - 
;		  1. When used in conjunction with /ALL, all names in the local
;		      symbol table are displayed.
;		  2. When a symbol name is specified, then search the local
;		      symbol table for the symbol name and display its value.
;
; When /ALL or a symbol name parameter is specified, but no other qualifiers 
; are, then the default algorithm is:
;
;	1. At the interactive level:  search the g.s.t for the symbol(s) to 
;	                              display,
;	2. In an ICF:  search the l.s.t. of the current	command level for the
;	               symbol(s) to display and then the g.s.t., and display 
;		       both values (or both tables), if found.
;
; OUTPUTS:
;gmb ;//fix//
;	 SYMFLG = symbol table flag indicating which table was specified
;		 = LOCAL  --> use local symbol table
;		 = GLOBAL --> use global symbol table
;		 = ALL    --> /ALL was specified 
;		 = ALLTBL --> neither /LOCAL nor /GLOBAL were specified
;			       so use both symbol tables (when in an ICF)
;		 = NAME   --> a symbol name was specified
;
;	NAMADR   = address of the symbol name string
;	NAMLNG	 = length of the symbol name string, in bytes
;
; Errors returned to the user's terminal are:
;
;	U.ISYN  = "?Invalid symbol name"
;		    (symbol name did not start with an alphabetic, $ or
;		     underscore  ex. SHOW SYMBOL 9abc)
; 	ILVL.E  = "?Invalid at interactive level"
;		    (ex. SHOW SYMBOL/LOCAL/ALL or SHOW SYMBOL/LOCAL abc
;			 at command level 0)
; 	U.UCHR  = "?Unexpected character"
;		    (symbol name contained an invalid character,
;		     ex. SHOW SYMBOL a*bc)
;
;-

; Qualifier list

SYM.QL:	DEFQUAL	ALL.Q			;/ALL
	DEFQUAL GBL.Q,CONF=LCL.Q	;/GLOBAL
	DEFQUAL LCL.Q,CONF=GBL.Q	;/LOCAL
	ENDQUAL

SHSM.CMD::$THR
	$DEFCMD QUAL=SYM.QL,U.CMDC=0	;Point to the qualifier list
					; (U.CMDC is needed by U$SYMN routine
					;  and for below)
	$PARM	PARM1,TYPE=U$SYMN,FLAGS=PF.OPT
					;Parse the optional symbol name 
	DFLTCQ	ALL.Q			;Default to /ALL
	$ENDCMD				;

DOSYM:	$CLR	SCOPE			;Assume /ALL, use 'all' symbols (in the
					;applicable local and/or global tables)
	$CLR	NAMADR			;Used by SHOSYM & DELSYM.  Non-zero
					;... means a symbol name was specified
	$FETP	PARM1			;
	$IF	PRESENT			;If a symbol name was specified, then 
	$DO				;
	MOV	#U.CMN+U.STR,NAMADR	;  Get the address of the symbol name
	MOVB	U.CMN+U.LEN,NAMLNG	;  Get the length of the symbol name
	CLR	LX.POS			;  Clear the current scan position
	BISB	NAMLNG,LX.POS		;  Get length of symbol name
	ADD	U.CMN+U.POS,LX.POS	;  Add in pos of start of symbol name
					;   to point to 1st char past name
					;   (sets up proper scan position
					;    needed by SHOSYM, DELSYM routines)
	$ENDDO				;
	$ENDIF				;Endif

	$CHECK	ICF			;
	$IF	FAILURE			;If not under an Indirect Command File,
	$DISALLOW <LCL.Q>,ILVL.E	;  Disallow the /LOCAL qualifier
					;   ("?Invalid at interactive level")
	$ENDIF				;Endif
	$FETCQ	GBL.Q			;
	$IF	PRESENT			;If /GLOBAL was specified, then
	$MOVV	GCAPTR,SCOPE		;  Set scope to global symbol table
	$ELSE				;Else
	$FETCQ	LCL.Q			;
	$IF 	PRESENT			;  If /LOCAL was specified, then 
	$MOVV	LCAPTR,SCOPE		;    Set scope to local symbol table
	$ENDIF				;  Endif
	$ENDIF				;Endif
	$DO				;
	TST	U.CMN+U.CMDC		;  
	IFZE				;If it's a SHOW SYMBOL command
	BIC	#STSUPD!SEVCHK,ICFFLG	;  Clear flags to say we don't want
					;  $STATUS changed or severity checked.
	CALLX	SHOSYM			;  Go display the symbol (pass flags)
					;   (error code is returned in R0)
	ELSE				;Else - it's a DELETE/SYMBOL
	CALLX	DELSYM			;  Delete the symbol name (pass flags)
					;   (error code is returned in R0)
	ENDIF				;Endif
	$ENDDO				;
	$ENDTHR

GLOBAL	<SCOPE,ILVL.E,LX.POS,NAMADR,NAMLNG,U.CMN,ICFFLG>

.SBTTL	Fatal Error Condition Encountered in an ICF
.SBTTL	STOP command
;+
; STOP 
;
; DESCRIPTION:
;	This routine has 2 entry points because it may be entered in one of
;	two ways:  
;	   1. The STO.CMD entry point is invoked when the user issues 
;	       the STOP command.  
;	   2. The ST2.CMD entry point is invoked:
;		- when the user is under the control of an Indirect Command 
;		  File, and an I/O or some other fatal error was encountered.
;		- in a GOTO command where the label to branch to is not in the
;		  local symbol table for that ICF.  Forward reads of the ICF
;		  are done in an attempt to find the label, and all labels 
;		  along the way are added to the symbol table.   If an error
;		  occurs during that process, then control is transferred to
;		  ST2.CMD in order to return to the interactive level.
;
;	The STOP command ends the current command process and control returns 
;	immediately to the interactive level, thus terminating all higher 
;	level command procedures.  This effectively aborts a command procedure.
;
;	This command is ignored at the interactive level.  There are no 
;	qualifiers for this command.
;
; INPUTS:
;	CMDLVL = the highest current command procedure level
;	F$SCHN = bit mask of all currently open PFB channels that were
;		 opened via F$SEARCH (while in command procedures only)
;	PFBCHN = bit mask of all open PFB channels (via F$SEARCH and inactive
;		 ICFs)
;
; OUTPUTS:
; 	CMDLVL = 0 (indicates that the interactive level is the current command
;		    level; all command procedures have been terminated)
;	GBLNFG = updated to reflect that the global context area was updated
;	F$SCHN = 0 to indicate that all currently open F$SEARCH PFB channels
;		 have been closed before returning back to interactive level
;	PFBCHN = updated bit mask of open PFB channels 
;
; Errors returned to the user's terminal are:
;
;       NOCH.E = "?No channels available"  
;   	           (an I/O channel was not available)
;
;
;-

STO.CMD::$THR
	$DEFCMD 			;No qualifiers for this command 
	$ENDCMD				;

; This entry point is invoked when an error is encountered when DCLCMD 
; is reading the next command line from the ICF or when a fatal error 
; occurs while in an ICF (ex. when adding a label or an I/O error occurs
; when reading/writing to the symbol table file).  Treat it as if a STOP 
; was issued, and flow into the main part of the STOP code.

	$DO				;Must be before ST2.CMD entry point
ST2.CMD::				;
	BIT	#ICFACT,ICFFLG		;Is an ICF currently active ?
	BEQ	29$			;No,29$ so quit

; Pop off all command levels, and go back to command level 0.  Read the global
; symbol table into core.  Return all currently open PFB channels that were 
; opened via the F$SEARCH function when in an ICF.

	MOV	#PF$ICF*2,R2		;Specify active PFB channel # (*2)
	BR	20$			;Close ICF, but don't return channel #

10$:	MOVB	@NXISTK,R1		;Set up R1 = next PFB channel # (*2)
					; to get rid of
	INC	NXISTK			;Update the ICF stack pointer
	MOV	R1,-(SP)		;Save it temporarily 
	MOV	PFBCHN,R4		;Load up PFB channels bit mask
	CALL	RTNCHN			;Return PFB channel # to pool to reuse
					; (no errors possible)
	MOV	(SP)+,R2		;Restore the PFB channel #
	MOV	R4,PFBCHN		;Update the bit mask
20$:					;R2 = PFB channel # *2 to return 
	CALB	CLSPFB	<R2,#RSTFQ>	;Reset the ICF
	;BCS	30$			;Continue if an error occurs 
	DEC	CMDLVL			;Decrement current level of ICF
	BNE	10$			;Continue until all ICFs are gone

; Close all PFB channels that were associated with an F$SEARCH function.

	MOV	F$SCHN,R1		;Get F$SEARCH PFB channel bit mask
       ;TST	F$SCHN			;Any PFB channels still open ?
	BEQ	25$			;No,25$ so continue on
	MOV	#3*2,R4			;R4 = 1st PFB channel # (*2) that
					; F$SEARCH could have used
	MOV	#13.,R2			;Maximum of 13. channels to analyze
	ASH	#-3,R1			;Shift off 1st 3 bits since ignoring
					; channels 0-2 (shift right)
					;Start with PFB channel #3
23$:	ASH	#-1,R1			;Look at next channel (shift right
					; into C-bit)
	IFCS				;If this channel was opened
					;  R4 = channel # (*2)
	CALB	CLSPFB	<R4,#CLSFQ>	;  Close it
       ;BCS	29$			;  Ignore all errors
	ENDIF				;Endif
	ADD	#2,R4			;Increment to next PFB channel # (*2)
	SOB	R2,23$			;More channels to analyze and close ?
					;Yes,23$
	BIC	F$SCHN,PFBCHN		;No, so update PFB bit mask to reflect
					; all the channels just closed
					; (instead of calling RTNCHN and trying
					;  to set up the actual I/O channel #)
	CLR	F$SCHN			;Clear all channels from F$SEARCH
					; bit mask
25$:	MOVB	#1,GBLNFG		;Indicate global context changed
	BIC	#ICFACT,ICFFLG		;Indicate we are at interactive level
	CALLX	NOLOCAL			;Set flags, etc to indicate there is
					;... no local table around
	TSTB	KBMFLG			;Do we need to switch?
	IFNE				;If so then
	CALBX	SAVSTB			;  Save symbol table
	CALLX	CLRFQB			;  Clear FIRQB for .RTS
	.RTS				;  Do a .RTS directive (Might not 
					;  ... return in-line)
	ENDIF				;Endif
29$:	MOV	#U.QUIT,R0		;In any case, quit
30$:	$ENDDO				;
	$QUIT				;Quit if reached here.
	$ENDTHR

GLOBAL	<CMDLVL,GBLNFG,NXISTK,PFBCHN,ICFSTK,ICFFLG,F$SCHN,KBMFLG>

.SBTTL	QCKSTP -- Quick Stop

;+
; QCKSTP
;
; DESCRIPTION:
;	This routine is called when an I/O error occurred when reading from
;	or writing to the user's symbol table file when he was at the inter-
;	active level or in an ICF.  The current command process is terminated
;	and control returns immediately to the interactive level, thus 
;	terminating all higher level command procedures.  This effectively 
;	aborts a command procedure.  This routine is called instead of the
;	actual STOP command routine because the symbol tables have been
;	munged and the data cells that that routine needs are not reliable.
;	There is no way of knowing how many (if any) ICFs are open.  Therefore,
;	all PFB channels must be closed.  This also implies that all currently
;	open PFB channels (indicated in the F$SCHN bit mask) opened via the
;	F$SEARCH function at all command levels are closed down as well.
;
; INPUTS:
;	None.
;
; OUTPUTS:
;	None.
;
; Destroys: R0,R1,R4,R5		;gmb // I doubt R1 & R4 are touched... /
;-
.ENABL	LSB

QCKSTP::

; IOB channel #1 which is used for creating tentative files (GENCHN in CUILOK)
; is the best one for CLSPFB to take for moving from the PFB to an IOB.  The 
; other channels may be being used by OPEN commands for open data files and an
; error would occur if we used them.

;gmb // there may be some bugs here with IOBCHN //

	MOV	#^B01,IOBCHN	;Set up the IOB channels bit mask indicating
				; 1 channel is reserved:
				;   0 --> user's keyboard (KB:)
	MOV	#15.*2,R5	;Start with PFB channel #15.
10$:	CMP	#PF$DAT*2,R5	;Are we about to close the symbol table?
	BEQ	20$		;Yes, Don't close it then!
	CALBX	CLSPFB	<R5,#RSTFQ> ;NO, then close it (R5 = PFB channel # *2)
				; (continue if an error occurs)
20$:	DEC	R5		;R5 is odd now but don't worry SOB is next
	SOB	R5,10$		;R5 contains the next channel to be closed
.ASSUME	PF$LOG*2 EQ 0 		;Don't close log file channel either
	BIC	#ICFACT,ICFFLG	;Indicate an ICF is no longer active
	RETURN			;Return to caller

.DSABL	LSB
GLOBAL	<IOBCHN,ICFFLG>

.SBTTL	WRITE command
;+
; WRITE  channel-number  data[,...] [/qualifiers]
;
; DESCRIPTION:
; 	This command writes records to a file or device that is opened for 
;	writing or appending with the OPEN command.  "Data" specifies the data
;	to be written to the file.  This data list may consist of one or more
;	string expressions, separated by commas.  Each data item is written
;	as a string to the file, with no intervening characters between each
;	item written.
;
;	Channel number 0 is permanently defined and can be used in a WRITE 
;	command to write to a user's terminal.  
;
;
; The legal qualifiers are:
;
;	/[NO]DELIMITER - when used with RSTS stream ASCII files, indicates
;			 whether or not the string should be written with a
;			 trailing <CR><LF>. 
;
;
; Errors returned to the user's terminal are:
;
;	CHAN.E  = "?Invalid channel number"
;		    (user specified a channel number outside the range 0-13)
;
;	NOWR.E  = "?Channel not open for output"
;		    (the channel the user is attempting to write to was
;		     opened in read mode)
;
;	U.UCHR  = "?Unexpected character"
;
;-

WRI.QL:	DEFQUAL	DEL.Q,QF.NEG		;/[NO]DELIMITER
	ENDQUAL

WRI.CMD::$THR
	$DEFCMD	QUAL=WRI.QL		
	$PARM	PARM1,U$REST,PROMPT=CHAN$P
	CHKCHN	PARM1,MINVAL=0,QUAL=WRI.QL;Ensure channel number is between 0-13
					;Quit if not in range
	$FETP	PARM1			;Fetch the parameter
	$DO				;
	TST	R1			;R1 = VALUE = user channel number
	BEQ	10$			;Don't check for open if it's WRITE 0
	CALB	FNDCHN	<R1>		;Find status of this channel
	BCC	10$			;Channel is open for write
	MOV	#NOWR.E,R0		;Error - ?Channel not open for output
	MOV	U.CMN+U.POS,LX.ERP	;Set error position
10$:	$ENDDO				;

	$PARM	PARM2,U$REST,PROMPT=DATA$P,OCCURS=100
	$ENDCMD
	DFLTCQ	DEL.Q			;Default to /DELIMITER

	 TMPORG TEXT	
40$:	  .ASCIZ ""<COMMA>
50$:	  .ASCII <CR><LF>
	 UNORG

	$FETP	PARM2			;Fetch symbol name
	$DO				;
	MOV	U.CMN+U.POS,LX.POS	;Reset scan position
60$:	MOV	VALUE,-(SP)		;Save channel number
	CALLX	DOEXPR			;Evaluate expression
	MOV	(SP)+,VALUE		;Restore channel number
	BCS	90$			;An error occurred
	MOV	VALUE,-(SP)		;Save channel number
	CALLX	NM2STR			;If an integer result, make it string
	MOV	(SP)+,VALUE		;Restore channel number
	;TST	VALUE			;What is channel number?
	IFEQ				;If this is a terminal write then
	CALB	FWRITE	<R2,R1>		;  Force write string
	ELSE				;Else
	MOV	R1,R3			;  Save location of value
	MOV	R2,R4			;  Save length of string value
	CALB	GETCBB 	<VALUE>		;  GET CBB, point to it with R1
	CALB	ENTADR	<VALUE>		;  Point R5 to entry
	CALB	RDCBB	<R1,R5>		;  Read in CBB if necessary 
	CLR	R2			;  Ensure high byte is clear
	BISB	FILPFB(R5),R2		;  Get associated PFB chan # *2 in R2
	CALB	DOPFBW			;  Do PFB 
	BCS	90$			;  Quit //for now// if error
	ENDIF				;Endif

	MOV	#-1,R3			;Flag indicating comma not seen
80$:	INC	R3			;R3 initially 0, R3>0 --> Comma seen
	CALLX	LX.EOS			;Are we at the end of string?	;061
	IFCS				;If not then
	CALBX	LX.EXAC <#40$>		;  Are we looking at a comma?
	BCC	80$			;  Yes.  Look for some more
	TST	R3			;  No.  Have we already seen a comma?
	BGT	60$			;  Yes, parse more data
	MOV	#U.UCHR,R0		;  No, ?Unexpected character
	MOV	LX.POS,LX.ERP		;  Point to that character
	ELSE				;Else
	CALBX	FET.CQ <#DEL.Q>		;  Fetch /DELIMITER
	.ASSERT	U.CMN+U.PRES EQ #-1	;  /DELIMITER is present by default
	TST	U.CMN+U.NO		;  Was it /NODELIMITER?
	IFEQ				;  If not then 
	TST	VALUE			;    What is channel number?
	IFEQ				;    If this is WRITE 0 (terminal)
	CALB	FWRITE <#2,#50$>	;      Write the <CR><LF>
	ELSE				;    Else
	MOV	#<256.*12+15>,SUBBUF	;      Include <CR><LF> in data
	MOV	#2,R4			;      Length is 2
	MOV	#SUBBUF,R3		;      Address is #STRBUF
	CALB	FNDCHN	<VALUE>		;      Get associated PFB channel in R2
	CALB	DOPFBW			;      Do the PFB write
	;BCS	90$			;      Quit if an error occurred
	ENDIF				;    Endif
	ENDIF				;  Endif
	ENDIF				;Endif
90$:	$ENDDO
	$ENDTHR

GLOBAL	<VALUE,LX.ERP,U.CMN,U.UCHR,LX.POS,SUBBUF,NOWR.E>

.SBTTL	MACROS for threaded routines
;+
; M A C R O S   F O R   T H R E A D E D   R O U T I N E S   B E L O W 
;	$NOLOCAL- Threaded "Disallow interactive level" instruction
;	$NOBATCH- Threaded "Disallow batch" instruction
;	$CLRFQB - Threaded CLEAR FIRQB instruction
;	$PFBFLG - Threaded PFB directive
;
; S U B R O U T I N E S    F O R     $ C H E C K    M A C R O S
;	$CHECK	ICF	- Check if a command file is active ($CHKICF)
;	$CHECK  LOG	- Check if log is open  ($CHKLOG)
;-

	.MACRO	$NOLOCAL
	 .WORD	$NOLOCAL
	.ENDM	$NOLOCAL

	.MACRO	$NOBATCH
	 .WORD	$NOBATCH
	.ENDM	$NOBATCH

	.MACRO	$CLRFQB	
	 .WORD	$CLRFQB
	.ENDM	$CLRFQB

	.MACRO	$PFBFLG	
	 .WORD	$PFBFLG
	.ENDM	$PFBFLG

.ENABL	LSB

$NOLOCAL:CALB	$CHKICF			;Are we at the interactive level?
	IFCS				;If so then
	MOV	CMDPOS,LX.ERP		;  Point at command
	MOV	#ILVL.E,R0		;  ?Invalid at interactive level
	ENDIF				;Endif
	RETURN				;Return

$NOBATCH:PUSH	<R3>			;Gets used by DOACCESS
	CALLX	DOACCESS		;Get access type
	CMP	R3,#2			;Are we in batch?
	IFEQ				;If so then
	MOV	CMDPOS,LX.ERP		;  Position of command is error pos
	MOV	#IBAT.E,R0		;  ?Invalid BATCH command
	ENDIF				;Endif
	POP	<R3>			;Restore R3
	RETURN				;Return

$CLRFQB:CALLX	CLRFQB			;Clear the FIRQB
	RETURN				;and return

$PFBFLG:MOVB	#FLG.PF,FIRQB+FQFIL	;Function = 'Set/clear flag bits'
	MOV	#PF$LOG*2,FIRQB+FQNAM1	;Set PFB channel # (*2) for logfile
	.PFB				;Do PFB directive
	CLR	R0			;
	BISB	FIRQB+0,R0		;Report any errors
	RETURN				;Return

$CHKICF::CLR	R0			;Assume command file is active
	BIT	#ICFACT,ICFFLG		;Command file active?
	BNE	10$			;Yup!				;078
	COM	R0			;Nope!				;078
10$:	RETURN				;Done

$CHKLOG::CLR	R0			;Assume logfile is open
	TST	LOGFIL			;Log file open?			;078
	BNE	20$			;Yes, R0 = 0	;PRESENT	;078
	COM	R0			;No, R0 = -1	;ABSENT		;078
20$:	RETURN				;

$CHKSN:	MOV	U.CMN+U.POS,NAMADR	;Get position of symbol name	;060
	ADD	#CMDBUF-1,NAMADR	;Make it an address		;060
	MOVB	U.CMN+U.LEN,NAMLNG	;Set up length of symbol name	;060
	CALLX	CHKSN			;Check symbol name for invalid	;060
					; chars.  Sets up abbreviation	;060
					; point.  Returns with status	;060
	RETURN				;Return with status		;060

.DSABL	LSB

GLOBAL	<IBAT.E,CMDPOS,ICFFLG,LX.ERP,ILVL.E,CMDBUF,NAMADR,NAMLNG>

.SBTTL	FSSFIL - Get FSS from PARM1
;+
; FORMAT:
;	CALB	FSSFIL	[<#extnum>]
;
; INPUTS:
;	PARM1 	  known to be present
; 	extnum	= (not specified) for .LOG extension default
;     		= #1 for .COM extension default
;     		= #2 for .DAT extension default
;
; OUTPUTS:
;	FIRQB set up with filename
;-
 
FSSFIL:	SUBR	<EXT>
	CALLX	CLRFQB			;Clear the FIRQB
	CALBX	FET.P	<#PARM1>	;Fetch file, ensure device is disk
	MOV	CMNADR,R4		;Point to CUI common
	CALLX	FSSCMN			;FSS filespec
	BIT	#F2EXT,XRB+10		;Was a file type given?
	IFZE				;If not then
	TST	(R5)			;  What extension?
	IFZE				;  If .LOG then
	MOV	#^RLOG,FIRQB+FQEXT	;    Set default type to .LOG 
	ELSE				;  Else
	CMP	EXT(R5),#1		;
	IFZE				;    If .COM
	MOV	#^RCOM,FIRQB+FQEXT	;      Set default type to .COM 
	ELSE				;    Else - was .DAT
	MOV	#^RDAT,FIRQB+FQEXT	;      Set default type to .DAT
	ENDIF				;    Endif
	ENDIF				;  Endif
	ENDIF				;Endif
	RETURN				;Return

GLOBAL	<CMNADR>

.SBTTL	FWRITE - Do forced write
;+
; FORMAT:
;	CALB	WRITE <LENGTH,ADDRESS>
;
; INPUTS:
;	LENGTH = Length of string to be output
;	ADDRESS -> Buffer which holds string.
;
; EFFECTS:
;	Output buffer, if any length to it, is displayed on terminal.
;	XRB is wiped out.
;
; This is similar to the $FAP !AD directive except it always does forced
; writes for you.
;-
.ENABL	LSB

FWRITE::SUBR	<LEN,ADR>,CHECK		;				;xxx
	CALLX	CLRXRB			;Clear XRB
	MOV	#40220,XRB+XRMOD	;Set transparent controls mode,
					; forced output, ignore set noecho
	MOV	LEN(R5),XRB+XRLEN	;Indicate how many ...
	MOV	LEN(R5),XRB+XRBC	;... characters to output
	IFNZ				;If there are any then
	MOV	ADR(R5),XRB+XRLOC	;  Point to buffer to output	
	;MOVB	#2*0,XRB+XRCI		;  Output on channel 0
	.WRITE				;  Write it out
	CLR	R0			;  Assume no error
	BISB	FIRQB+0,R0		;  Set error code
	IFNE				;  If error occured (only happen if 
					;    logfile is open and couldn't write
					;    to logfile)
	CMESSAGE R0			;    Write the error
	ENDIF				;  Endif
	ENDIF				;Endif
	RETURN				;Done

.DSABL	LSB

.SBTTL	GETATR - Get file attributes
;+
; DESCRIPTION:
; 	GETATR looks up the attributes for an open file on an IOB supplied
; 	to this subroutine.  This routine is used by the @, OPEN and 
;	OPEN/LOG_FILE commands.
;
; USAGE:
;	CALL	GETATR
;
; INPUTS:
;	R1  =	The IOB channel where the file is already open.  
;
; OUTPUTS:
;	If C = 0, (success)
;		R0 = 0
;	 	R1 = record size of the file
;		R2 = record format of the file
;	If C = 1, (failure)
;		R0 = error code
;		R1 = 0 (stream)
;		R2 = 0 (stream)
;
;-
.ENABL	LSB

GETATR:	CALLX	CLRFQB			;Clear the FIRQB
	MOVB	#UU.ATR,FIRQB+FQFUN	;Function = 'Read file attributes'   
	ASR	R1			;Divide I/O channel # (*2) by 2
	MOVB	R1,FIRQB+FQFIL		;Set up I/O channel (not *2)
       	;CLRB	FIRQB+FQSIZM		;Set it to 'read'
	.UUO				;
	CLR	R0			;Clear R0
	BISB	FIRQB,R0		;Set up the error code
       ;TSTB	FIRQB			;
	BNE	5$			;Exit if an error occurred
	MOV	FIRQB+FQPPN,R2		;Save attribute data for analysis
					; (1st word of attribute data returned)
	MOV	FIRQB+FQPFLG,R1		;Pass record size back to caller in R1
					; (9th word of attribute data returned)

; Set up the ICF record format.

	TST	R2			;Does the file have any attributes ?
	IFNE				;If so then
	BIT	#RF.FIX,R2		;  Does it have fixed length records?
	IFNZ				;  If so then
	BISB	#RF.FIX,FIRQB+FQSIZM	;    Indicate so
	ELSE				;  Else
	BIT	#RF.VAR,R2		;    Does it have variable length recs?
	IFNZ				;    If so then
	BISB	#RF.VAR,FIRQB+FQSIZM	;      Indicate so
	ENDIF				;    Endif
	ENDIF				;  Endif
	ELSE				;Else (no attributes)
5$:	CLR	R1			;  No record size (stream)
	CLR	R2			;  No format (stream)
	MOVB	#-1,FIRQB+RMSEBM	;  Set file size to -1 (for monitor)
	MOV	#-1,FIRQB+RMSEBL	;  Set file size to -1 (for monitor)
	BR	10$			;  Leave
	ENDIF				;Endif

	TSTB	FIRQB+FQSIZM		;
	IFNZ				;If fixed or variable length records
					;  (else stream file is implied)
	BIT	#01000,R2		;
	IFNZ				;  If 'implied carriage control' is set
	BISB	#RF.IMP,FIRQB+FQSIZM	;    Indicate so
	ENDIF				;  Endif
	BIT	#04000,R2		;
	IFZE				;  If 'no span' is not set
	BISB	#RF.SPN,FIRQB+FQSIZM	;    Set 'records span blk boundaries'
	ENDIF				;  Endif
	ENDIF				;Endif

	CLR	R2			;Clear it 1st
	BISB	FIRQB+FQSIZM,R2		;Pass record format back to caller
10$:	CMP	#0,R0			;Set carry if R0 contains error code
	RETURN				;Return with error status

GLOBAL	<IOCHAN>

.DSABL	LSB

.SBTTL	DOCFIP	- Issue a DOCFIP directive and set error
;+
; DOCFIP	- Issue a DOCFIP directive and set error
;
; CALL
;	CALL	DOCFIP		use to be CALB prior to edit 080
; OUTPUT
; 	if no error
;		C bit clear
;	      	R0 = 0
;	if error
;		C bit set
;		R0 = error code
;-
DOCFIP:	CALFIP				;Issue CALFIP directive		;080
	MOVB	FIRQB+0,R0		;Set error code if any		;080
	CMP	#0,R0			;Set/clear C-bit
	RETURN				;Done


.SBTTL	DOCMES	- Print an error message on user's terminal
;+
; DESCRIPTION:
;	This routine prints an error message on the user's terminal and
;	saves R0 (since CMESSAGE destroys it).
;
; USAGE
;	CALL	DOCMES
;
; INPUTS:
;	R1 = error message to print
;
; R0 is saved/restored
;-

DOCMES::
	MOV	R0,-(SP)		;Save R0 over the call
	CMESSAG	R1			;Print error message on user's terminal
	MOV	(SP)+,R0		;Restore R0
	RETURN				;Return to caller


.SBTTL	CLSPFB	- Close the PFB channel
;+
; DESCRIPTION:
; 	This routine fails only if it can not allocate an IOB channel.  It
; 	gets an IOB channel, closes the PFB channel, and returns the IOB 
;	channel to its mother.
;
;	When the PFB that is being closed is the ICF:
;	CLSPFB closes the Indirect Command File associated with the PFB channel
;	passed.  This routine is called when the user issues an EXIT or STOP 
;	command or when an end-of-file condition is reached because there are 
;	no more command lines to read.  A reset is done because the indirect
;	command file may have been a non-disk file, in which case it had to
;	be copied to a temporary scratch disk file (and now we want this file
;	deleted).
;
; USAGE:
; 	CALB	CLSPFB <PFB,FUNC>
;
; INPUTS:
;	PFB  - PFB channel number * 2
;	FUNC - function to perform (CLSFQ or RSTFQ)
;
; OUTPUTS:
;	if C = 0, the PFB was closed
;		R0 = 0
;	if C = 1, the PFB was not closed
;		R0 = error code
;		     NOCH.E = "?No channels available"  
;			       (an I/O channel was not available)
;
; Destroys: FIRQB and XRB
; Saves:    This is a CALB, so all registers (except R3) are preserved.
;
;-

.ENABL	LSB

CLSPFB::SUBR	<PFB,FUNC>,CHECK	;These arguments have to be passed
	MOV	IOBCHN,R4		;Pass the IOB channels bit mask
	CALL	GETCHN			;Get an available I/O channel
					; (returns R1 = I/O channel # *2) 
	BCS	10$			;Exit if an error occurs (shouldn't)
	MOV	R4,IOBCHN		;Update the bit mask
	CALLX	CLRFQX			;Clear FIRQB and XRB
	MOV	R1,FIRQB+FQPPN		;Specify IOB channel number (*2)
	MOV	PFB(R5),FIRQB+FQNAM1	;Specify PFB channel number (*2)
	CALL	P2I			;Move from PFB to IOB
	MOV	IOBCHN,R4		;Load up I/O channels bit mask
					; (R1 = I/O channel # *2) 
	CMP	FUNC(R5),#RSTFQ		;Was a 'reset' function requested ?
	IFZE				;If so
	CALL	RTNRST			;  Reset and return the channel to pool
					;   (no errors possible)
	ELSE				;Else - a 'close' was requested
	CALL	RTNCLS			;  Close and return the channel to pool
					;   (no errors possible)
	ENDIF				;Endif
	MOV	R4,IOBCHN		;Update the bit mask
10$:	RETURN				;Return to caller

.DSABL	LSB

GLOBAL	<IOBCHN>

.SBTTL	GETCHN - Get a Channel 
;+
; GETCHN - get a channel 
;
; DESCRIPTION:
;	GETCHN gets a channel from the appropriate pool of channels for the 
;	IOB or PFB.  This routine tests the state of each bit in the bit mask,
;	starting at bit 0 (for channel #0), and returns to the caller the 
;	number of the first available channel (corresponding to the first bit
;	that was clear).  This channel number must be returned to the pool 
;	when it is no longer needed (by calling the appropriate RTNCLS or 
;	RTNCHN routine).  
;
; USAGE:
; 	CALL	GETCHN
;
; INPUTS:
;	R4 = bit mask of channels
;
; OUTPUTS:
;	If success,
;		C = 0, an available channel was found
;		R0 = 0
;		R1 = the actual channel # (*2)
;		R4 = updated bit mask of channels (reflects the channel just 
;		      allocated)
;		GBLNFG = updated to reflect that the global context area has 
;		          changed 
;	If failure,
;		C= 1, there were no more available channels
;		R0 = error code
;		     NOCH.E   ("?No channels available") 
;		R1 = 0
;		R4 = unchanged bit mask of channels 
;		GBLNFG = unchanged
;		
;
; Saves/restores R2,R5
;
;-

.ENABL	LSB

GETCHN::

; Search for an available channel.

	PUSH	<R2,R5>			;Save some registers 
	MOV	R4,-(SP)		;Save the original bit mask
	CLR	R5			;Start with channel #0
	MOV	#16.,R2			;Maximum # of channels to analyze
10$:	ROR	R4			;Get the next channel #
	BCC	20$			;Is this channel available ?
					;Yes,20$
	INC	R5			;No, increment to get next channel #
	SOB	R2,10$			;Continue searching for available one

; There is not an available channel.
       ;CLR	R2			;Indicate no bits to 'OR' into original
					; bit mask
	CLR	R1			;Zero out the channel # returned
	MOV	#NOCH.E,R0		;"?No channels available" error
	SEC				;Set C-bit
	BR	40$			;Exit

; Found an available channel, so mark it unavailable.

20$:	MOV	R5,R1			;Save actual channel # temporarily
	INC	R5			;Channel # +1 = actual bit to set in
					; the channel bit mask
	CLR	R2			;Start off with a clean bit slate
	SEC				;Indicate that we're taking this channel
30$:	ROL	R2			;Keep shifting til proper bit is set
	SOB	R5,30$			; indicating the channel is taken
					; (R4 has 1 bit set indicating channel #)
	ASL	R1			;Make it channel # *2
	MOVB	#1,GBLNFG		;Indicate that global context changed
	CLR	R0			;Indicate no error
       ;CLC				;Clear C-bit
40$:	MOV	(SP)+,R4		;Restore the original bit mask
	BIS	R2,R4			;Update the bit mask to reflect the
					; channel just allocated (or a no-op if
					; none available)
	POP	<R5,R2>			;Restore the registers
	RETURN				;

.DSABL	LSB

GLOBAL	<NOCH.E,GBLNFG>

.SBTTL	RTNCLS - Return and Close an I/O Channel 
.SBTTL	RTNRST - Return and Reset an I/O Channel 
.SBTTL	RTNCHN - Return a PFB Channel 
;+
; RTNCLS - return and close an I/O channel 
; RTNRST - return and reset an I/O channel 
; RTNCHN - return a PFB channel 
;
; DESCRIPTION:
;	This subroutine has 3 entry points:
;	  1. RTNCLS closes and returns an I/O channel to the appropriate 
;	      pool of IOB channels so that it can be reused again.  The 
;	      commands for closing a data file, a logfile or a file opened
;	      via the F$SEARCH DCL function would call this routine.
;	  2. RTNRST resets and returns an I/O channel to the appropriate 
;	      pool of IOB channels so that it can be reused again.  A reset
;	      would be done in the cases where the user's indirect command 
;	      file may have been a non-disk file, in which case it had to be 
;	      copied to a temporary scratch disk file, and now we want this
;	      file deleted.
;	  3. RTNCHN returns a PFB channel to the appropriate pool of PFB 
;	      channels.
;
; The channel (IOB or PFB) we're working with had been previously allocated 
; by the GETCHN routine.
;
; USAGE:
; 	CALL	RTNCLS
; 	CALL	RTNRST
; 	CALL	RTNCHN
;
; INPUTS:
;	R1 = the actual channel # (*2) to be returned
;	R4 = bit mask of channels
;
; OUTPUTS:
;	R1 = munged
;	R4 = updated bit mask of channels (reflects the channel just returned)
;	GBLNFG = updated to reflect that the global context area was updated
;
;
; No errors are possible.
;
; Destroys:  FIRQB
; Saves/restores R2
;
;-

.ENABL	LSB

RTNCLS:	MOVB	#CLSFQ,-(SP)		;Function = 'Close a channel'
	BR	10$			;Branch around

RTNRST:	MOVB	#RSTFQ,-(SP) 		;Function = 'Reset a channel'

10$:	CALLX	CLRFQB			;Clear the FIRQB
	MOVB	(SP)+,FIRQB+FQFUN	;Function = 'Reset or close a channel'
	MOVB	R1,FIRQB+FQFIL		;IOB channel # to return (*2)
	CALFIP				;If an error occurs on the close, then
					; ignore it since 'close' still worked
RTNCHN::
	MOV	R2,-(SP)		;Save R2 on the stack
	ASR	R1			;Channel #/2 
	INC	R1			;Channel # +1 = actual bit to clear in
					; the channel bit mask
	CLR	R2			;Start off with a clean bit slate
	SEC				;Indicate that we're returning this 
					; channel
20$:	ROL	R2			;Keep shifting til the proper bit is set
	SOB	R1,20$			; indicating the channel to return 
					; (R2 has 1 bit set indicating channel #)
	BIC	R2,R4			;Update the bit mask to reflect channel
					; just returned and made available again
	MOVB	#1,GBLNFG		;Indicate that global context changed
	MOV	(SP)+,R2		;Restore R2
	RETURN				;

.DSABL	LSB

GLOBAL	<GBLNFG>

.SBTTL	GETCBB - Get a Control Block Buffer
;+
;
;  GETCBB - Get a Control Block Buffer
;
; FORMAT:
;	CALB	GETCBB	<channel>
;
; INPUTS:
;	channel	= logical channel number of CBB to fetch.  This is not
;		  channel number * 2.  This is the channel user specified
;		  in his OPEN command.
;
; OUTPUTS:
;	R1	-> CBB
;	CBB	   Possibly set up with control bits cleared if the pointer
;		   to this file did not previously exist.
;	IO.CHN(R1) Filled in with specified channel number
;
;	Previous CBB could have been destroyed (if it was READ) or written
;	out (if we need it and it was WRITE).
;
; All registers preserved
;-
.ENABL	LSB

GETCBB:	SUBR	<CHAN>			;
	MOV	#CBB1,R1		;Point to first CBB
	MOV	R1,R4			;Copy pointer to CBB
	MOV	CHAN(R5),R2		;Get channel number
10$:	CMP	R2,IO.CHN(R1)		;Is this a CBB for our channel?	
	IFNE				;If not then
	ADD	#CBBSIZ,R1		;  Point to next CBB
	CMP	R1,#LSTCBB		;  Was that last CBB?
	BNE	10$			;  No, check next one
	MOV	R4,R1			;  Yes, point to list of CBBs again
20$:	CMP	IO.CHN(R1),#-1		;  Is this one available?
	BEQ	30$			;  Yes, use it
	ADD	#CBBSIZ,R1		;  No, get next CBB
	CMP	R1,#LSTCBB		;  Was that last CBB?
	BNE	20$			;  No, check next one
	MOV	R4,R1			;  Yes, use first one 

; Should use channel that is currently open for /READ if any, because /READ is 
;  easier to get back.

	CALB	WRICBB	<R1>		;  Write out this CBB if necessary
30$:	MOV	CHAN(R5),IO.CHN(R1)	;  Mark this one as ours
	PUSH	<R5>			;  Save register
	MOV	R1,R4			;  Point to CBB
	ADD	#PF$BSZ,R4		;  Point to end of block buffer
	MOV	#CBB$SZ-PF$BSZ,R5	;  Length of data to clear out
40$:	CLRB	(R4)+			;  Clear out control block data
	SOB	R5,40$			;   bits up to next CBB (or end)
	MOV	(SP),R5			;  Restore register 
	CALB	ENTADR	<CHAN(R5)>	;  Find address of this channel entry
	MOV	FILBYT(R5),PF.BYT(R1)	;  Set byte offset into file
	MOVB	FILVBH(R5),PF.VBH(R1)	;  Set block number, high word
	MOV	FILVBL(R5),PF.VBL(R1)	;  Set block number, low word
	BIS	#PF.INV,PF.FLG(R1)	;  The data is invalid because this was
					;  not our CBB.
	POP	<R5>			;  Restore register again
	ENDIF				;Endif
	BIS	#PF.BOR,PF.FLG(R1)	;Set Beginning Of Record flag
	MOV	R1,TOS.R1(SP)		;Save R1 as an output.  R1 --> CBB
	RETURN

.DSABL	LSB

GLOBAL	<IO.CHN,CBBSIZ,CBB1,LSTCBB>

.SBTTL  CLSCBB 	- Close a CBB 
;+
; CLSCBB - Close a CBB if it's open for WRITE, mark else mark it unused
;
; FORMAT:
;	CALB	CLSCBB <channel>
;
; INPUTS:
; 	channel	= Channel number user specified, close only the CBB associated 
;		  with this channel (if any) only if it's open for WRITE
;
;	channel	= #-1 to indicate close ALL CBBs open for WRITE.
;
; OUTPUTS:
;	R0 	= 0
;	IO.CHN(CBB) for EACH CBB
;		= -1 to indicate CBB unused if the data was written out
;		= unchanged if no CBB was associated with the specified channel
;	PF.FLG(CBB)
;		= PF.FLG ! PF.INV set to indicate data is invalid
;-
.ENABL	LSB

CLSCBB::SUBR	<CHAN>
	MOV	#CBB1,R1		;Point to first CBB
10$:	TST	CHAN(R5)		;Check the channel
	IFGE				;If it's not -1 then
	CMP	CHAN(R5),IO.CHN(R1)	;  Is this channel we want?
	BNE	20$			;  No, check next CBB
	ENDIF				;Endif
	CMP	IO.CHN(R1),#-1		;Is CBB not allocated? (= #-1?)
	BEQ	20$			;Yes.  Don't write CBB	
	CALB	WRICBB	<R1>		;Write out CBB if necessary
20$:	ADD	#CBBSIZ,R1		;Point to next CBB
	CMP	R1,#LSTCBB		;Was that the last CBB?
	BNE	10$			;No, write out this one
	RETURN				;Yes, done.

GLOBAL	<IO.CHN,CBB1,LSTCBB>

.DSABL	LSB

.SBTTL	WRICBB  - Write out a CBB if necessary
;+
; WRICBB  - Write out a CBB if necessary
;
; FORMAT:
;	CALB	WRICBB <CBBPTR>
; INPUT:
; 	CBBPTR	= pointer to CBB to write out, if associated channel is
;		  open for WRITE
;
; OUTPUT:
; 	CBB written out if associated channel is open /WRITE
;	IO.CHN(CBB) for EACH CBB
;		= -1 to indicate CBB unused
;	PF.FLG (CBB)
;		= PF.FLG ! PF.INV set to indicate data is invalid
;
; DESCRIPTION:
;	We are going away from DCL and we need to write out anything that's
;	currently open for WRITE in the CBB so no data is lost.  We use a -1
;	as an argument to indicate any CBB gets written out.
;
;	We need the CBB for some other function; either a WRITE or a READ
;	on a channel not currently in use by a CBB and no CBBs are available
;	for this function.  We supply the CBB pointer that we want to write
;	out.  Data is only written if the CBB is open for WRITE.
;-

.ENABL	LSB

WRICBB:	SUBR	<CBBPTR>
	MOV	CBBPTR(R5),R1		;Point R1 to CBB	
	CALB	FNDCHN	<IO.CHN(R1)>	;How was this channel opened?

; C  =  1 if open for READ, 0 if open for WRITE
; R1 -> CBB
; R2 =  PFB channel number * 2 if open for WRITE

	IFCC				;If it was open for write
	CALLX	CLRFQX			;  Clear FIRQB and XRB
	MOVB	#BLK.PF,FIRQB+FQFIL	;  Function = Block/PFB read + write
	MOV	#1,XRB+XRTIME		;  1 --> WRITE
	MOVB	R2,XRB+XRCI		;  PFB channel number * 2
	MOVB	PF.VBH(R1),XRB+XRBLKM	;  MSB Block number (R1 --> CBB)
	MOV	PF.VBL(R1),XRB+XRBLK	;  LSB Block number
	MOV	#PF$BSZ,XRB+XRBC	;  Buffer length (1 block)
	MOV	#PF$BSZ,XRB+XRLEN	;  Buffer length (1 block)
	MOV	R1,XRB+XRLOC		;  Location of CBB block to write
	MOV	R1,R3			;  Point to CBB
	ADD	PF.BYT(R1),R3		;  Compute address of end of valid data
	MOV	#PF$BSZ,R4		;  Compute number of 
	SUB	PF.BYT(R1),R4		;   ... bytes to clear
	BEQ	25$			;  None to clear
22$:	CLRB	(R3)+			;  Clear all invalid
	SOB	R4,22$			;  ... data	
25$:	.PFB				;  Do the PFB write
	BISB	FIRQB+0,R0		;  Set error code
	IFNZ				;  If an error occured
	CMP	R0,#QUOTA		;    Was it ?Quota exceeded?
	IFEQ				;    If so then
	CMESSAGE #DATA.E		;      ?Unable to write to data file
	CMESSAGE #QUOTA			;      ?Quota exceeded
	ENDIF				;    Endif
	ENDIF				;  Endif
	ENDIF				;Endif
	MOV	#-1,IO.CHN(R1)		;Mark this CBB as not used
	BIS	#PF.INV,PF.FLG(R1)	;The data in this CBB is invalid
	RETURN				;Done

.DSABL	LSB

GLOBAL	<IO.CHN,DATA.E,QUOTA>

.SBTTL	FNDCHN	- Find information about channel from channel table
;+
; FNDCHN - Find information about channel from channel table
;
; FORMAT:
;	CALB	FNDCHN <channel>
;
; INPUTS:
; 	channel	= Channel number user specified on his READ, WRITE, OPEN
;	  	  or CLOSE command.  This tells you how channel was opened.
;
; OUTPUTS:
;	R0	= 0	if channel was open /WRITE (or /APPEND)
;	R0	= -1 	if channel was open /READ
;	R0	= NOTOPN if channel was not opened
;	R2	= PFB channel number *2 or 0 if not opened
;
;-
.ENABL	LSB

FNDCHN:	SUBR	<CHAN>,CHECK		;Channel number to look up.
	;CLR	R0			;Assume /WRITE 
	CALB	ENTADR	<CHAN(R5)>	;Get pointer to entry
	TSTB	FILPFB(R5)		;What channel is PFB open on?
	IFZE				;If not open
	MOV	#NOTOPN,R0		;  Indicate not open
	ELSE				;Else
	BITB	#READFN,FILFLG(R5)	;  How was it opened?
	IFNZ				;  If /READ 
	COM	R0			;    We guessed wrong.  Indicate /READ 
	ENDIF				;  Endif
	ENDIF				;Endif		
	CLR	TOS.R2(SP)		;Pre-clear returned R2 value
	MOVB	FILPFB(R5),TOS.R2(SP)	;Return PFB channel number *2
	RETURN				;Right-toe.

.DSABL	LSB

GLOBAL	<NOTOPN>

.SBTTL	DOPFBW	- Do a PFB write
;+
; DOPFBW - Do a PFB write
;
; FORMAT:
;	CALB	DOPFBW
;
; INPUTS:
;	CBB   Set up for a WRITE
;	VALUE user specified channel number
;	R0 =  0 (cleared by CALB)
;	R1 -> CBB 
;	R2 =  PFB channel number * 2
;	R3 -> string to write into PFB buffer
;	R4 =  length of said string
;-
.ENABL	LSB

DOPFBW:	;CLR	R0			;Assume no error
	CALLX	CLRFQX			;Clear the FIRQB and XRB
	MOVB	#IO.PF,FIRQB+FQFIL	;Function is "I/O write, PFB style"
	MOV	R4,XRB+XRBC		;Length of string value
	BEQ	10$			;No characters to write.  Don't bother
	MOV	R3,XRB+XRLOC		;Address of string value to write
	MOVB	R2,XRB+XRCI		;PFB channel number * 2
	MOV	R1,XRB+XRMOD		;Address of CBB
	MOV	R4,XRB+XRLEN		;Max length of string value	;059
	MOV	#1,XRB+XRTIME		;1 indicates this is a WRITE 

; The monitor increments the block count BEFORE writing the block, so I must
; SUBTRACT 1 from the block count to make things jive.  Don't use DEC because
; it doesn't affect the C-bit, then put it back after the .PFB directive.

	SUB	#1,PF.VBL(R1)		;Adjust block count
	SBCB	PF.VBH(R1)		;Adjust high order using C-bit
	.PFB				;Fire up PFB	
	ADD	#1,PF.VBL(R1)		;Set block count back
	ADCB	PF.VBH(R1)		;Set back high order
	BIC	#PF.INV,PF.FLG(R1)	;The data in the CBB is now valid
	BISB	FIRQB+0,R0		;Pass error up to caller
	IFEQ				;If there was no error then
	CALB	ENTADR	<VALUE>		;  Find entry to that channel
	MOV	PF.VBL(R1),FILVBL(R5)	;  Fill in pertinent info
	MOVB	PF.VBH(R1),FILVBH(R5)	;
	MOV	PF.BYT(R1),FILBYT(R5)	;  Save byte count, bytes written out
	MOVB	#1,GBLNFG		;  Indicate that global context changed
	ELSE				;Else
	PUSH	R0			;  Save error code
	CMESSAGE #DATA.E		;  Print ?Unable to write to data file
	POP	R0			;  Restore error code
	ENDIF				;Endif
10$:	RETURN				;Finish with error or success

.DSABL	LSB

GLOBAL	<VALUE,SUB.BSIZ,DATA.E>

.SBTTL	RDCBB - Read in a CBB if necessary
;+
; FORMAT:
; 	CALB	RDCBB	<CBB_pointer,Data_entry>
;
; INPUTS:
;	CBBpointer - Pointer to the CBB
;	Data_entry - Pointer to the data file stack, 
;		     where byte count, etc is stored.
;
; OUTPUTS:
;	CBB read in if the following conditions are true:
;		(1) PF.INV is set in PF.FLG and 
;		(2) PF.BYT is non-zero
;	PF.INV in PF.FLG is clear.
;
; DESCRIPTION:
;	This routine is used only once, right before a WRITE to a PFB channel.  
;
; EFFECTS:
;	Incredible.  FIRQB, XRB munged.  All registers preserved.
;	CBB might be read.
;	
;-
.ENABL	LSB

RDCBB:	SUBR	<CBBPTR,DATAENT>
	MOV	CBBPTR(R5),R1		;R1 --> CBB
	MOV	DATAENT(R5),R2		;R2 --> Data entry
	BIT	#PF.INV,PF.FLG(R1)	;Is data in CBB invalid?
	IFNZ				;If so then
	TST	FILBYT(R2)		;  Any bytes already written out?
	IFNZ				;  If so then
	CALLX	CLRFQX			;    Clear FIRQB and XRB
	MOVB	#BLK.PF,FIRQB+FQFIL	;    Block/PFB read+write directive
	;CLR	XRB+XRTIME		;    Indicate READ
	MOVB	FILPFB(R2),XRB+XRCI	;    PFB channel # (*2) 
	MOVB	FILVBH(R2),XRB+XRBLKM	;    Get block number for read (MSB)
	MOV	FILVBL(R2),XRB+XRBLK	;    Get block number for read (LSB)
	MOV	#PF$BSZ,XRB+XRLEN	;    Buffer size
	MOV	R1,XRB+XRLOC		;    CBB pointer
	.PFB				;    Do PFB
	CALLX	U$CHKE			;    No error should occur
	BIC	#PF.INV,PF.FLG(R1)	;    Data is now valid
	ENDIF				;  Endif
	ENDIF				;Endif
	RETURN				;Finito

.DSABL	LSB

.SBTTL	CHKCHN - Check the channel number
;+
; CHKCHN - Check the channel number
;
; DESCRIPTION:
;	CHKCHN checks the channel number passed on the OPEN, CLOSE, READ or
;	WRITE commands to see if it is in the range MINVAL-13.  
;
; USAGE:
; 	$CHKCHN  parmtag,MINVAL=minval	(threaded call)
;
; INPUTS:
;	parmtag = Parameter tag of the channel number parameter (ex PARM1)
;	MINVAL =  minimum value this parameter can be.  Typically 0 or 1.
;		  The maximum value is always 13.
;
; OUTPUTS:
;	If channel number is in proper range,
;		VALUE = the channel # (not *2)
;		R1    = VALUE (Caution, other threaded routines may also
;			       destroy R1)
;	If failure,
;		If channel number is not in proper range,
;			R0 = CHAN.E   ("?Invalid channel number")
;		or some other error occurred in the expression
;			R0 = error code
;-

.ENABL	LSB

CHKCHN:	CALBX	FET.P	<(R3)+>		;Fetch channel number parameter
	.ASSERT	U.CMN+U.PRES EQ #-1	;Item is present
	MOV	U.CMN+U.POS,LX.POS	;Reset scan position to channel number
	PUSH	<R3>			;Save register
	CALLX	DOEXPF			;Parse it as factor, convert to integer
	POP	<R3>			;Restore register
	BCS	10$			;Quit if an error occurs
					;     else: R1 = low order word
					;           R2 = high order word
	TST	R2			;Was result in proper range 
	BNE	10$			;No, number much too big or small
	CMP	R1,#13.			;Was it > 13?
	BGT	10$			;Yes, error
	CMP	R1,(R3)			;Was it below minimum?
	BLT	10$			;Yes, error
	MOV	R1,VALUE		;No, channel number is good so save it
	BR	20$			;Skip around

	
10$:	MOV	U.CMN+U.POS,LX.ERP	;Set error position to channel number
	MOV	#CHAN.E,R0		;"?Invalid channel number"
	BR	30$			;Quit

20$:	CALBX	PARQUAL	<2(R3),#NO>	;Parse qualifiers
30$:	CMP	(R3)+,(R3)+		;Skip past qualifier table and min value
	RETURN				;Return to caller

.DSABL	LSB

GLOBAL	<U.CMN,LX.POS,LX.ERP,VALUE,CHAN.E>

.SBTTL	ENTADR - Get Data File Entry Address
;+
; ENTADR - Get the data file entry address
;
; DESCRIPTION:
;	ENTADR gets the address of the file entry in the global context area 
;	(of the global symbol table) corresponding to the channel number the 
;	user specified on the OPEN, CLOSE, READ or WRITE command.  The channel
;	number must be in the range 1-13.  
;
; USAGE:
; 	CALB	ENTADR  <CHAN>
;
; INPUTS:
;	CHAN - the user specified channel # 
;
; OUTPUTS:
;	R0 = 0 (no errors can occur)
;	R5 = the address of the data file entry in the global context area 
;
;		
; Saves:  this is a CALB, so all registers (except R3) are preserved.
;
;-

.ENABL	LSB

ENTADR:
	SUBR	<CHAN>,CHECK		;Make sure that this argument is passed
	MOV	CHAN(R5),R1		;R1 = the user specified channel #
	DEC	R1			;Decrement channel # by 1 since file
					; stack starts with channel 1, not 0
	MUL	#FENTLN,R1		;Get offset into data file stack for
					; file entry associated with this chan
	ADD	#FILSTK,R1		;Point to the correct data file entry
					; (add the address of 1st file entry 
					;  on open data files stack)
	MOV	R1,TOS.R5(SP)		;Return entry address in R5
	RETURN				;Return to caller

.DSABL	LSB

GLOBAL	<FILSTK>

.SBTTL	PFB - IOB channel mover (P2I and I2P)
;+
; PFB - IOB channel mover (P2I and I2P)
;
; This does nothing more than the .PFB directives to move the PFB channel
; to the IOB channel (P2I), or vice-versa (I2P).  The FIRQB is set up before
; getting called, though the PFB function code is moved here.
; 
; Basically, the only inputs are:
;	FIRQB+FQNAM1	;PFB channel number (*2)
;	FIRQB+FQPPN	;IOB channel number (*2)
;
; FORMAT:
;	CALL	P2I	;Move PFB channel to IOB
;	CALL	I2P	;Move IOB channel to PFB 
;
; OUTPUTS:
;	Z = 1 indicates no error, R0 = 0
;	Z = 0 indicates error, FIRQB error code is in R0
;-
P2I:	MOVB	#P2I.PF,FIRQB+FQFIL	;Function = 'Move from PFB to IOB'
	BR	MOVPFB			;Go do the PFB
	
I2P:	MOVB	#I2P.PF,FIRQB+FQFIL	;Function = 'Move from IOB to PFB'
MOVPFB:	.PFB				;Do the PFB directive
	CLR	R0			;Clear R0
	BISB	FIRQB,R0		;Set up the error code (if any)
	RETURN				;Return with Z-bit and R0 set

.END
