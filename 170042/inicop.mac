.INCLUDE /CMN:COMMON/							;034
.INCLUDE /CMN:KERNEL/							;034
.INCLUDE /INIT:INIPFX/							;034
.INCLUDE /INIT:DSKDEF/							;034
.INCLUDE /INIT:TAPDEF/							;034
.INCLUDE /CMN:CFGDEF/							;034
TITLE	COPY,<RSTS/E INIT - COPY OPTION>,0A,10-MAY-91,ABC/WBN/RVR/MND/GPK/JHC/DBM/KPH/VAM

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;


.SBTTL	EDIT HISTORY FOR INICOP

;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-08
;  001  SRM  09-Aug-81  Add support of squished SILs.
;  002  MND  09-Aug-81  Change the text and answer for deleting files
;			on copies.
;
;				[RSTS V7.2]
;  000	MND  22-Mar-82	CREATION - COPIED FROM V7.1-11
;  001	MND  22-Mar-82	Added support for MSCP disks - UDA50/RA80
;
;				[RSTS V8.0]
;  000	GPK  07-Jun-82	Create callable bootstraps for smaller INIT
;  001	GPK  01-Jul-82	More of the same, and removed DT/DX input code
;  002	GPK  14-Jul-82	Use BLDBOT module
;  003	GPK  24-Sep-82	New disk structure
;  004	GPK  27-Sep-82	Implement S^3 boot block standard
;  005	GPK  21-Oct-82	Allow booting UDA units other than 0
;  006  JHC  01-Nov-82	Work on the TS11 bootstrap(remove non-PIC instructions)
;			Also enlarge command packet area for TSV05 registers
;  007	JHC  28-Dec-82	Bug fix in MTBOOT; allow EOF error during Skip function,
;			and ignore Record Length Error for TM11.
;  008  JHC  03-Mar-83  Bug fix COPY cluster map code to correct word count of
;			INIT transfer for bootstrap.
;  009	JHC  13-Dec-83  Source clear 1.1.5 (V8.0) by rearranging routines
;			in TS11 bootstrap to clear Red Zone violations.
;
;				[RSTS V9.0]
;  010	MND   1-May-84  Add .TSK and .COM to system files in COPY
;  011	MND   3-Jul-84  Treat .TSKs sizes as a .SIL
;			Always supersede (withot asking) on Updates
;  012	MND   3-Jul-84  Added auto-copy entry point for new RSTS installs
;  013	DBM  17-Jul-84	Make protection codes <124> for .COM and .TSK files
;			Give them an appropriate run-time system of creation too
;  014	DBM  15-Aug-84	Rearrange entry code to fix illegal disk name problem
;  015	MND  31-Aug-84	Fix COMCSZ bug
;  016  VAM  25-Oct-84  Remove controller autosize code from DR/DB boot, and
;			add code to get unit number and CSR from R0 and R1
;			to DR/DB and DU boots.
;  017	MND  10-Dec-84	COPY all .COM files during auto-COPY or COPY/A
;  018  VAM  21-Jan-85	Move code to clear ALLFLG earlier.  Also, change
;			wording of 'Output disk is dirty' message to read
;			'Output disk needs rebuilding'.
;  019  VAM  17-Mar-85	Copy all files as the default (and only) action.
;			Add /Q option.
;			Add error check for invalid COM file formats.
;			Log each filename as it's copied over.
;			Remove some ERFs and replaced them with simpler EXITs.
;			Change prompt messages depending upon update/copy.
;  020  VAM  03-Apr-85	Pass target unit name correctly from DSKINT.
;
;			[RSTS V9.1]
;  021	DBM  04-Feb-85	TMSCP bootstrap work
;	     14-Jun-85	Tertiary bootstraps for magtape
;  022  KPH  17-Jun-85	Multi-volume support
;  023  VAM  11-Jul-85	Change GGBOOT to get secondary boot for tapes
;  024  VAM  15-Jul-85	Have GGBOOT fill in XFERAD (boot transfer address)
;  025  VAM  17-Jul-85	Only log copied files if COPY invoked normally.
;			Also, changes for Micro/RSTS.
;  026  VAM  13-Aug-85	Always start COPYed INIT at address INITGO.
;
;			[RSTS/E V9.2]
;  027  KPH  24-Oct-85	Add copying of MSG files
;
;			[RSTS V9.4]
;  028	GPK  25-Aug-86	Add DZ (GPK RX50) bootstrap
;  029	GPK  20-Sep-86	Add DW (GPK hard disk) bootstrap
;  030	GPK  02-Oct-86	Bugfixes in DW boot, changes for FIP in overlay
;			Copy ODT.SYS as well as INIT.SYS
;
;			[RSTS V9.5]
;  031	PJH  07-Jul-87	Write bootstrap only on INIT.SYS copy, not ODT.SYS copy
;
;			[RSTS V9.6]
;  032  VAM  20-Oct-87	Go back to "Option:" prompt if fatal error occurs
;			during installation or update.
;  033  VAM  02-Dec-88	Allocate flag byte in bootstraps.
;			Code kludges in MGBOOT to enable passing of boot flags.
;			Change B.UNIT and UNIT02 references from word to byte.
;			Allow reboot with full autosize if disk unit not found.
;
;			[RSTS V9.7]
;  034  VAM  29-Jan-89	Set SIL name in CONFIG.SYS to "SYSGEN" before booting.
;			Pass boot flag to auto-START new SIL upon reboot.
;			Special case COPYing of CONFIG.SYS.
;
;			[RSTS V10.0]
;  035  VAM  24-May-90	Clear ASCIZ terminator when putting "SYSGEN" into
;			CONFIG.SYS for auto-start.
;-



;021+
;
;  Our 'extended' DOS label definitions for the tertiary boot code.
;
;-
.DSECT
	.BLKB	14.		;Normal DOS label area
MUBOOT:	.BLKB	1000		;MU boot driver
MSBOOT:	.BLKB	1000		;MS boot driver
MMBOOT:	.BLKB	1000		;MM boot driver
MTBOOT:	.BLKB	1000		;MT boot driver
BOOTSZ:				;Length of the entire DOS label

;021-



.SBTTL	COPY MACROS AND PARAMETERS

.MACRO	I.MESS
	TMPORG	COPTXT
.NLIST	BEX
.ENDM	I.MESS

.MACRO	DEVICE	XX
	 .ASCII	"XX"
	 .WORD	XX'INIT
	 .WORD	XX'SCAN
	 .WORD	XX'READ
	 .IF	IDN	XX,MT
	 .WORD	XX'EOFR
	 .IFF
	 .WORD	XX'EOF
	 .ENDC
.ENDM	DEVICE

.MACRO	FILE	NAM,FL,PR,CRERTS=< RSTS >			;013
	 .RAD50	/NAM/
	 .WORD	NAM'CHK
	 .WORD	NAM'CSZ
	 .BYTE	FL,PR
	 .RAD50	/CRERTS/					;013
.ENDM	FILE


.SBTTL	ORDER THE CSECTS IN MEMORY

	DEFORG	COP
	DEFORG	COPCTL
	DEFORG	COPTXT
	ORG	COP



.SBTTL	Define constants

SYSSUB	=:	'@		;System disk substitution character	;022
VOLSUB	=:	'#		;Volume name substitution character	;022


.SBTTL	COPY OPTION INITIALIZATION

.ENABL	LSB

;014+	Begining of rearranged code

;	auto-chain from DSKINT entry point

COPY2::	CALLX	DATINI		;GET THE DATE & TIME
	CALL	SETUP		;Initialize FIP and other structures.	;012
	MOV	COINDX,R5	;Get the index of DISK just DSKINTed	;012
	MOV	COUNIT,R0	;Get the unit				;012
	MOV	SP,SUPERC	;Pretend we're doing an update.		;025
	MOV	SP,C2ENT	;Say we were entered at COPY2.		;032
	JMP	220$		;Skip the "which disk?" questions.	;012

	TMPORG	COPCTL
C2ENT:	.WORD	0		;Flag saying that we were entered at	;032
				; COPY2.  This implies that we are	;032
				; doing an update or installation.	;032
	UNORG								;032

;	Normal entry point

COPY::	TSTB	SAVDEV		;IS THIS A SAVE RESTORE DISK?
	BEQ	10$		;NO, THE OPTION IS LEGAL
	JMPX	OPNOT		;YES, THEN THIS IS NOT A LEGAL OPTION

10$:	CLR	QFLAG		;Assume we're not doing /Q.		;019
	CLR	C2ENT		;Also say we were entered normally.	;032
	MOVB	UPDATE,SUPERC	;Set switch if performing an Update	;011
	BEQ	15$		;Regular COPY (no update)		;014
	CLRB	UPDATE		;  and clean up				;011
15$:	MOV	#10.,R0		;PRESERVE UP TO 10 CHARACTERS		;014
	MOV	#OUTSAV,R2	; IF HE TYPED THE DEVICE ON THE LINE
20$:	MOVB	(R1)+,(R2)+	;COPY THE REST OF THE LINE
	BEQ	30$		;NO MORE
	SOB	R0,20$		;UP TO 10 TO COPY
	CLRB	OUTSAV+1	;ELSE GIVE AN ERROR IF TOO MUCH
30$:	CALL	SETUP		;Initialize FIP and other structures.	;012
	CALLX	DATINI		;GET THE DATE & TIME

;014-	End of rearranged code

	MOV	#75$,60$	;Assume the normal message.		;019
	MOV	#70$,65$	;Both parts.				;019
	TSTB	SUPERC		;Are we doing an update??		;019
	BEQ	40$		;Nope, leave everything alone.		;019
	MOV	#85$,60$	;Otherwise, fix the message.		;019
	MOV	#80$,65$	;Again, both parts.			;019
40$:	MOV	#OUTSAV,R1	;POINT TO SAVED OUTPUT DISK NAME
	TSTB	(R1)		;IS THERE ANY?
	BNE	90$		;YES, USE IT
50$:	CALLX	ASKER,R5	;**$DISKS**
60$:	 .WORD	0
65$:	 .WORD	0

	I.MESS
70$:	  .ASCII <12>"Type the name of the disk which is to receive the"
	  .ASCII " RSTS/E system."<200>
	  .ASCII "The disk must already be initialized."<200>
	  .ASCII "Valid disk names are DL, DM, DP, DB, DR, DW and DU."<200> ;028
75$:	  .ASCIZ <177><12>"To which disk? "

80$:	  .ASCII <12>"Type the name of the current RSTS/E system disk"
	  .ASCII " which is to be updated."<200>
	  .ASCII "Valid disk names are DL, DM, DP, DB, DR, DW and DU."<200> ;028
85$:	  .ASCIZ <177><12>"Disk to update? "
	UNORG

90$:	MOV	R1,R5		;COPY POINTER TO ANSWER
	CMPB	(R1),#'R	;DISK NAME WITH AN 'R' ?
	BNE	100$		;NO
	MOVB	#'D,(R1)	;YES, FIX IT

GLOBAL	<SYSNDX,SYSNAM,SAVDEV,UPDATE>



100$:	TSTB	(R5)+		;SCAN TO THE END
	BNE	100$
	DEC	R5		;BACK UP TO POINT TO NULL
	CMPB	-(R5),#'Q	;Trailing 'Q'?				;019
	BNE	110$		;No, couldn't be /Q.			;019
	CMPB	-1(R5),#'/	;Is it really '/Q'?			;019
	BNE	110$		;NO
	COM	QFLAG		;Yes, do selective copy.		;019
	CLRB	-(R5)		;SET TERMINATOR NULL
	DEC	R5		;POINT TO REAL LAST BYTE
	BR	115$		;Skip the '/A' stuff.			;019
110$:	CMPB	(R5),#'A	;Is it an 'A'?				;019
	BNE	115$		;No, doesn't seem to be.		;019
	CMPB	-1(R5),#'/	;Do we have a '/A'?			;019
	BNE	115$		;False alarm.				;019
	CLRB	-(R5)		;Put a null at the end again.		;019
	DEC	R5		;Point to the last character again.	;019
115$:	CMPB	(R5),#':	;TRAILING COLON?
	BNE	120$		;NONE
	CLRB	(R5)		;REMOVE IT
120$:	MOV	#DSKNAM,R5	;POINT TO TABLE OF VALID DISK NAMES
130$:	CMP	(R1),(R5)+	;IS THIS IT?
	BEQ	150$		;YUP
	TST	(R5)		;NO, ANY MORE TO CHECK?
	BNE	130$		;YES, DO SO
140$:	MESSAGE	<"Illegal disk name"<200>>
	BR	50$		;TRY AGAIN

150$:	SUB	#DSKNAM+2,R5	;COMPUTE DISK INDEX
	TST	XXBOOT(R5)	;Do we have a bootstrap for it?
	BEQ	140$		;Not a legal system disk if we don't
	TST	DSKCSR(R5)	;DOES IT EXIST? (OR MULTI-CONTROLLER?)
	BNE	170$		;YES

160$:	CALLX	VBCHK		;Are we under a first-time boot?	;033
	BCS	165$		;Yes, so go handle.			;033
	MESSAGE	<"Sorry, but that disk doesn't exist"<200>>		;033
	BR	50$		;Otherwise, just tell 'em and try again.;033

165$:	MESSAGE	<"That disk was not found during limited hardware scan."<200>> ;033
	CALLX	FSZBOT		;See if they want a reboot with full	;033
				; autosize.				;033
	BR	50$		;If we come back, go ask for disk again.;033

170$:	MOV	(R1),COPDEV	;Save the device name.			;025
	MOVB	@SUBUNT(R5),R3	;GET MAX NUMBER OF UNITS FOR THIS DISK TYPE
	MOV	R3,R0		;PUT IN R0 FOR DECSTR
	MOV	R1,-(SP)	;SAVE OUR TEXT POINTER
	MOV	#190$,R1	;  SET ADDRESS TO STORE TEXT
	CALLX	DECSTR		;    AND CONVERT THE MAX UNIT TO ASCII
	MOV	(SP)+,R1	;RESTORE OUR TEXT POINTER
	MOV	(R1)+,R4	;SET R4<>0, POP R1
	CLR	R0		;SET DISK UNIT TO 0
	TSTB	(R1)		;END OF STRING?
	BNE	200$		;NO, PARSE THE UNIT NUMBER
	CLR	R4		;FLAG FOR UNIT FROM UNIT QUESTION
180$:	CALLX	ASKER,R5	;ASK FOR A UNIT
	 GENTXT	<"Unit? ">
	 GENTXT
	 .ASCII	"Physical unit number (0-"
190$:	 .ASCIZ	"??????)? "
	 UNORG
200$:	CALLX	DECINP		;GET DECIMAL NUMBER
	BNE	210$		;ERROR IN UNIT NUMBER
	CMPB	R0,R3		;TOO BIG? (R3 = MAX VALID UNIT NUMBER)
	BLO	220$		;IT'S OK
210$:	TST	R4		;UNIT NUMBER IN FIRST RESPONSE?
	BEQ	140$		;YES, REPEAT THAT QUESTION
	MESSAGE	<"Invalid unit number"<200>>
	BR	180$		;TRY AGAIN



220$:	MOV	R0,R1		;COPY THE DISK UNIT NUMBER
	ASL	R0		;DOUBLE IT
	ADD	DSKMID(R5),R0	;POINT TO MASSBUS ID TABLE
	CMP	(R0),#-1	;MINUS ONE MEANS NONEXISTENT
	BEQ	160$		;NO SUCH DISK
	MOV	R5,OUTNDX	;SAVE OUTPUT DISK INDEX
	MOV	R1,OUTUNT	; AND UNIT
	CMP	R5,SYNXSV	;IS THIS THE SYSTEM DISK TYPE?
	BNE	230$		;NO, DO THE COPY
	CMP	R1,SYSUSV	;MAYBE...
	BNE	230$		;NO, DO IT
	MESSAGE	<"Cannot COPY to the system disk"<200>>
	BR	400$		;And, figure out where to go back to.	;032

230$:	MOV	OUTNDX,R0	;GET OUTPUT DISK INDEX
	MOV	OUTUNT,R1	; AND UNIT
	CALLX	SETFNS		;SELECT DISK AS FIP UNIT
	CALLX	LKBADB		;FIND BADB.SYS
	BCS	240$		;NO GOOD
	CALLX	LKSATT		;FIND SATT.SYS
	BCC	250$		;GOT IT
240$:	MESSAGE	<"Output disk is not a system disk"<200>>
	BR	400$		;And, figure out where to go back to.	;032

250$:	MOV	#1*400+2,-(SP)	;Push PPN [1,2]				;030
	MOV	SP,R0		; and point to it			;030
	CALLX	SDM		;FIND IT IN THE MFD
	INC	(SP)+		;Clean the stack, C unchanged		;030
	BCC	260$		;GOT IT
	MESSAGE	<"Account [1,2] missing from output disk"<200>>
	BR	400$		;And, figure out where to go back to.	;032

260$:	MOVB	OUTUNT,COPUNT	;Get the final output unit number.	;019
	CMPB	COPUNT,#9.	;Is it more than 9?			;019
	BGT	270$		;Yup, go handle it.			;019
	ADD	#'0,COPUNT	;Otherwise, just make it ASCII		;019
	BR	290$		; and go on.				;019

270$:	ADD	#46,COPUNT	;Adjust it for ASCII (with a twist).	;019
	SWAB	COPUNT		;End for end.				;019
	MOVB	#'1,COPUNT	;Make the first digit a '1'.		;019

290$:	CALLX	TYPECR		;Neatness counts.			;019
	CLR	INDEX		;START AT THE BEGINNING
	TST	SUPERC		;Are we doing an update/installation??	;025
	BEQ	300$		;No, so skip the short stuff.		;025
	MESSAG	<"Copying required system files"<200>>			;025

300$:	BR	NEXTIN		;Go					;012

400$:	TST	C2ENT		;Did we come in at COPY2?		;032
	BNE	410$		;Yes, so go back to "Option:" prompt.	;032
	JMP	50$		;Otherwise, go ask disk questions again.;032

410$:	EXIT			;In the event of a nasty error, just	;032
				; go back to the "Option:" prompt.	;032

.DSABL	LSB

GLOBAL	<DSKSZL,DSKSZM,SYNXSV,SYSUSV,DSKNAM,DSKCSR,SUBUNT,COINDX,COUNIT>


.SBTTL	COPY SET-UP CODE

.ENABL	LSB

SETUP:	CALLX	SETFIP		;SELECT THE SYSTEM DEVICE
	MOV	#COPTBL+2,R1	;POINT TO TABLE FOR BOOTABLE DEVICES
	TST	SYSNDX		;IS THE SYSTEM DEVICE DISK?
	BGE	60$		;YES, USE DISK
	ADD	#5*2,R1		;SKIP TO MAGTAPE ENTRY
	CMP	SYSNDX,#TAPMIN	;IS IT MS, MM, OR MT?
	BHIS	60$		;YES, USE MAGTAPE
	ERF	<"Unknown device booted">

60$:	CALL	@(R1)+		;CALL THE INIT ROUTINE
	MOV	(R1)+,XXSCAN	;SET UP SCAN ADDRESS
	MOV	(R1)+,XXREAD	;SET UP READ ADDRESS
	MOV	(R1)+,XXEOF	;SET UP EOF  ADDRESS
	RETURN

.DSABL	LSB

	TMPORG	COPCTL

COPTBL:	DEVICE	DK
	DEVICE	MT
	.WORD	0

XXSCAN:	.WORD	0		;ADDRESS OF SYSTEM DEVICE LOOKUP ROUTINE
XXREAD:	.WORD	0		;ADDRESS OF SYSTEM DEVICE READ ROUTINE
XXEOF:	.WORD	0		;ADDRESS OF SYSTEM DEVICE EOF  ROUTINE

OUTNDX:	.WORD	0		;OUTPUT DISK INDEX
OUTUNT:	.WORD	0		;OUTPUT DISK UNIT

SUPERC:	.WORD	0		;Always supersede if <> zero		;011


FILTBL:	FILE	SYS,US.NOK!US.NOX,60.	;INIT.SYS or ODT.SYS		;030
	FILE	SIL,US.NOX,60.	;MONITOR SIL
	FILE	RTS,US.NOX,60.	;DEFAULT RTS
	FILE	ERR,US.NOX,40.	;ERROR MESSAGE FILE
	FILE	SAV,US.NOX,60.	;LOADABLE SAV IMAGE			;027
	FILE	TSK,US.NOX,124.,<RSX   > ;Backup utility used for installation ;027
	FILE	COM,0,124.,<DCL   > ;Indirect Command File for installation ;013
	FILE	EOV		;Volume change file			;022
	FILE	MSG,US.NOX,40.	;CUI message file			;027
	.WORD	0		;END OF TABLE

FLTYPE:	.WORD	0		;EXTENSION OF FILE
FLFLAG:	.WORD	0		;FLAG BITS, PROTECTION CODE
FILRTS:	.BLKW	2		;RUN-TIME SYSTEM OF CREATION
FILSIZ:	.WORD	0		;FILE SIZE AS COMPUTED AT FLSIZE
QFLAG:	.WORD	0		;Flag to indicate /Q.			;019
OUTSAV:	.BLKB	10.		;SAVED OUTPUT DISK FROM COMMAND
WORKBF:	.BLKW	256.*3		;3 BLOCK WORK BUFFER
SPSAVE:	.BLKW			;Saved SP for multi-volume restarts	;022

	UNORG


.SBTTL	MAIN LOOP FOR COPYING FILES

.ENABL	LSB

NEXTIN:	MOV	SP,SPSAVE	;Save the stack for multi-volume restarts ;022
	CALL	@XXSCAN		;SCAN SYSTEM DEVICE FOR THE NEXT FILE
	BCC	10$		;MORE, TRY IT
	JMP	CPYDNE		;NO MORE, THE COPY IS DONE

10$:	MOV	#1,R1		;GET MASK BIT FOR FILE TYPE
	MOV	#FILTBL-<2*4>,R5 ; AND BIASED POINTER TO TYPE TABLE
20$:	ADD	#8.,R5		;NEXT TABLE ENTRY
	MOV	(R5)+,FLTYPE	;SAVE THE FILE TYPE IN CASE WE HIT
	BEQ	NEXTIN		;WE CAN'T USE THIS FILE, SO SKIP IT
	ASL	R1		;MAYBE. SHIFT THE BIT MASK
	CALL	@(R5)+		;IS THIS FILE USEFUL?
	BCS	20$		;NOPE, TRY FOR ANOTHER USE
	MOV	#FQ...+FQNAM1,R1 ;YES, POINT TO FIRQB FOR OUTPUT FILE
	MOV	(R0)+,(R1)+	;MOVE THE
	MOV	(R0)+,(R1)+	; FILNAM.EXT
	MOV	(R0),(R1)+	;  TO THE FIRQB
	MOV	#256.,R0	;WORD COUNT TO READ
	CALL	@XXREAD		;READ THE FIRST BLOCK
	BCC	30$		;THERE WAS NO ERROR
	JMP	SIZEER		;DIE IF ERROR

30$:	MOV	#256.,R2	;COPY THE BLOCK
	MOV	#SATBUF+10000,R3 ;FROM THE BUFFER AREA
	MOV	#SILBUF,R4	;TO THE MONITOR SIL INDEX BUFFER
40$:	MOV	(R3)+,(R4)+	;MOVE A WORD
	SOB	R2,40$		; AND LOOP
	CLR	FILSIZ		;File size in blocks, pre-clear		;010
	CALL	@(R5)+		;CHECK OUT THE SIZE
	BCC	45$		;Everything's cool.			;019
	JMP	INVFMT		;Branch-out-of-range kludge.		;019

45$:	TST	QFLAG		;Are we doing selective copy (/Q)?	;019
	BEQ	70$		;Nope, skip the question-asking stuff.	;019
50$:	MESSAG	<<177>"Copy file ">					;019
	CALL	PRTNAM							;019
	MESSAG	<" <No>? ">						;019+
	CALLX	GETIN		;Get the input...			;019
	CALLX	ANSWER,R5	; ...and check it.			;019
	  BR	70$		;If they answered 'Y', we copy it.	;019
	  NOP			;If they answered 'N'...		;019
	  NOP			; ...or <CR> or <LF>...			;019
55$:	  BR	NEXTIN		; ...or 'O', we skip this file.		;025
	  MESSAG		;Anything else, they get the help stuff	;019
	   .ASCII <12>"Type 'Y' to copy the specified file to the output disk,"
	   .ASCII <200>
	   .ASCII "type 'N' or RETURN to skip the file, or"<200>
	   .ASCIZ "type CONTROL/C to stop the COPY operation."<200><12>
	 UNORG
	BR	50$		;Go ask 'em again.			;019

70$:	MOV	(R5)+,FLFLAG	;SAVE THE FLAG BITS & PROTECTION CODE
	MOV	(R5)+,FILRTS	;SAVE THE 'CREATING' RTS		;013+
	MOV	(R5)+,FILRTS+2	; BOTH WORDS
	CMP	FQ...+FQEXT,#^RRTS	;DOING AN RTS FILE?
	BNE	80$		;NO - PROCEED
	CMP	FQ...+FQNAM1,#^RDCL	;YES, IS IT DCL.RTS?
	BNE	80$		;NO.
	TST	FQ...+FQNAM1+2	;COULD BE...
	BNE	80$		; BUT IT ISN'T
	MOV	#^RDCL,FILRTS	;IT IS, RTS OF CREATION MUST BE ITSELF
	CLR	FILRTS+2
	MOVB	#232.,FLFLAG+1	;AND ITS PROTECTION CODE MUST BE <232>	;013-
80$:	CMP	FQ...+FQEXT,#^RSYS ;Doing INIT.SYS?			;022
	BNE	90$		;No, not this time			;022
	CMP	FQ...+FQNAM1,#^RINI ;Double check			;030
	BNE	90$		;No, must be some other .SYS file	;030
	CMP	FQ...+FQNAM1+2,#^RT ;One more check			;030
	BNE	90$		;Sorry...				;030
	SUB	#6,SP		;Yes, get a 6 byte scratch area		;022
	MOV	SP,R1		;And point to it			;022
	CLR	R0		;Put booted unit number into R0...	;033
	BISB	B.UNIT,R0	; ...so as to subvert sign extend evil.	;033
	CALLX	DECSTR		;Now convert it to ASCII		;022
	MOV	B.NAME,-(SP)	;Preface the unit number with the device name ;022
	MOV	SP,R1		;And point to the device and unit	;022
	CALLX	RADINP		;Convert the device and unit to RAD-50	;022
	MOV	R0,FILRTS	;Save the first part of it		;022
	MOV	R3,FILRTS+2	;And the second part of it		;022
	ADD	#10,SP		;Clean up the stack			;022
90$:	CALL	SETOUT		;SELECT THE OUTPUT DISK			;022
	CALLX	LOK...		;LOOK FOR THE FILE ON THE DISK
	BCS	160$		;NOT THERE, WE CAN PROCEED
	CMP	FQ...+FQNAM1,#^RCON ;Is this CONFIG.SYS?		;034
	BNE	95$		;No, so treat it normally.		;034
	CMP	FQ...+FQNAM1+2,#^RFIG ;How about here?			;034
	BNE	95$		;Sorry...				;034
	CMP	FQ...+FQEXT,#^RSYS ;And, lastly...?			;034
	BEQ	55$		;Yup, it IS!!  Go back to NEXTIN.	;034


	TMPORG	COPCTL
INDEX:	.WORD	0		;FILE INDEX NUMBER FOR SCAN
	UNORG

GLOBAL	<FQ...,SATBUF,SILBUF>



95$:	TST	SUPERC		;Should we prompt the user?		;034
	BNE	120$		;No, just go ahead and replace it.	;025
100$:	MESSAG	<<177>"File ">
	CALL	PRTNAM		;PRINT THE FILE NAME
	MESSAG	<" already exists - Supersede <No>? ">
	CALLX	GETIN		;Get the input...			;019
	CALLX	ANSWER,R5	; ...and check it.			;019
	  BR	110$		;If they typed 'Y', go delete it.	;019
	  NOP			;If they answered 'N'...		;019
	  NOP			; ...or <CR> or <LF>...			;019
	  BR	55$		; ...or 'O', we skip this file.		;025
	MESSAG			;Anything else, they get help.		;019
	  .ASCII <12>"The file named above already exists on the output disk."
	  .ASCII <200>
	  .ASCII "Type 'Y' to replace it with the new input file"
	  .ASCII " of the same name,"<200>
	  .ASCII "type 'N' or RETURN to leave the file unaltered"
	  .ASCII " on the output disk, or"<200>
	  .ASCIZ "type CONTROL/C to stop the COPY operation."<200><12>
	 UNORG
	BR	100$		;Ask 'em again.				;019

110$:	MESSAGE	<"Superseding file ">					;025
	CALL	PRTNAM		;Print the file name			;025
	CALLX	TYPECR		;Neatness counts.			;025
120$:	CALLX	SAVSAT		;SAVE THIS COPY OF THE SATT
	MOV	FC...+FCWND+UENT,R2 ; GET STARTING DCN OF FILE
	MOV	FQ...+FQSIZC,R1 ; GET NUMBER OF BLOCKS TO FREE
	CLR	R3		;DCN IS A REGISTER PAIR
	CALLX	RETCLU		;RELEASE SPACE TAKEN UP BY FILE
	BCC	140$		;IEEEE!, THE FILE MUST BE THERE
	MOV	FILSIZ,R1	;GET THE SIZE OF THE NEW FILE
	CLR	R0		;WE DON'T CARE WHERE WE PUT IT
	CALLX	GETCLU		;SEE IF IT WILL FIT ANYWHERE
	BCC	170$		;PROBLEMS, IT WON'T FIT
	CALLX	RESSAT		;IT WILL FIT, RESTORE THE DAMAGE DONE

130$:	CALL	DMOUNT		;THE DISK IS DIRTY DURING THIS
	CALLX	DELNAM		;DELETE THE FILE (R4 STILL -> FIRQB)
	BCC	150$		;GOT IT, SO OK
140$:	ERF	<"INIT bug - can't find file to delete">

GLOBAL	<FC...,FQ...>


150$:	CALLX	WOMSAT		;WOMP OUT THE SATT WITH THE DELETION
	CALL	DDISM		;NOW IT'S CLEAN AGAIN
	BR	80$		;TRY AGAIN IN CASE THERE ARE 2

160$:	MOV	FILSIZ,R1	;GET THE FILE SIZE
	MOV	R1,FQSIZN(R4)	;SAVE IT IN THE FIRQB
	CLR	R0		;NO PREFERRED POSITION
	CALLX	GETCLU		;ALLOCATE THE FILE
	BCS	180$		;GOT IT
170$:	MESSAGE	<"No room for file on output disk"<200>>
	EXIT

180$:	MOV	R2,FQALLC(R4)	;SAVE ALLOCATION START
	CALLX	FIXCLU		;CONVERT TO NUMBER OF PACK CLUSTERS
	MOV	R0,FQNPCL(R4)	;SAVE IT FOR CREATE
	CALL	DMOUNT		;DISK IS ABOUT TO BE USED
	CALL	CREATE		;CREATE THE FILE
	CALLX	WOMSAT		;UPDATE THE SAT ON DISK
	CALL	DDISM		;DISK CLEAN AGAIN
	TST	R5		;FAILURE?
	BEQ	190$		;NO, THAT FILE IS CERTAINLY THERE
	MESSAGE	<"No room for directory on output disk"<200>>
	EXIT

190$:	CALLX	LOK...		;LOOK UP THE FILE WE JUST CREATED
	BCC	200$		;GOT IT
	ERF	<"INIT bug - failed to find file just created">


200$:	BISB	#US.NOX,FC...+DDSTS ;WRITE WITH NO WINDOW TURNS
	MOV	FILSIZ,R2	;GET FILE SIZE IN R2
	MOV	#256.,R0	;FIRST WRITE THE 256. WORDS READ EARLIER
	MOV	#FC...,R1	;R1 -> FCB FOR OUTPUT FILE
	CLR	FCNVB(R1)	;START AT BLOCK 0
	CALLX	WRITE.,R5,SILBUF ;WRITE THE FIRST BLOCK
	BCS	SIZEER		;EOF ERROR??
210$:	SWAB	R0		;CONVERT WORDS WRITTEN TO BLOCKS
	SUB	R0,R2		;SUBTRACT FROM BLOCKS LEFT
	BEQ	230$		;DONE WITH THE COPY
	MOV	R2,R0		;R0 = BLOCKS LEFT TO DO
	CMP	R0,#8.		;MORE THAN 8 BLOCKS?
	BLOS	220$		;NO, DO WHAT'S LEFT
	MOV	#8.,R0		;YES, DO ONLY 8 BLOCKS
220$:	SWAB	R0		;CONVERT TO WORD COUNT
	CALL	@XXREAD		;READ A CHUNK INTO SATBUF
	BCS	SIZEER		;NO GOOD
	CALLX	WRITE.,R5,SATBUF+10000 ;WRITE A LARGE CHUNK FROM SATBUF AREA
	BCC	210$		;NO ERROR, SO LOOP
230$:	CALL	@XXEOF		;MAKE SURE WE ARE AT END-OF-FILE
	BCS	SIZEER		;NOPE
	CMP	FLTYPE,#^RSYS	;IS THIS INIT.SYS?
	BNE	240$		;NO, GO DO THE NEXT FILE
	MOV	#FQ...+FQNAM1,R5;Really get the name			;031
	CMP	(R5)+,#^RINI	;Is it really INIT.SYS?			;031
	BNE 	240$		;Not init fur shur			;031
	CMP	(R5)+,#^RT  	;Try last part				;031
	BNE	240$		;And not again				;031
	CALL	SETOUT		;YES -- SELECT OUTPUT DISK
	CALL	WBTSUB		;WRITE BOOT FOR INIT.SYS
240$:	TST	SUPERC		;Do we want to see this??		;025
	BNE	250$		;Nope, so just skip it.			;025
	MESSAG			;Tell 'em the filename.			;019
	 .EVEN			;Make sure it's at a word address.	;019
	 .ASCIZ	"  File "
	UNORG
	CALL	PRTNAM		;It's in RAD50, you know.		;019
	MESSAG								;019+
	.ASCII	" has been copied to "
COPDEV:	.ASCII	"??"		;These two symbols MUST be at even locs	;019
COPUNT:	.ASCII	<176><176>	;Remember that if you mess with any	;019
	.ASCIZ	":"<200>	; text in this module!!			;019
	UNORG								;019-

250$:	JMP	NEXTIN		;NEXT INPUT FILE


SIZEER:	MESSAG	<<177><200>"Header/directory size mismatch in file ">	;019
	CALL	PRTNAM		;Tell 'em there was a size problem.	;019
	MESSAG	<" - COPY cannot continue"<200>>			;019
	EXIT			;It's a fatal error, I guess...		;019

INVFMT:	MESSAG	<"File ">	;Tell 'em it has an invalid format.	;019
	CALL	PRTNAM		;Tell 'em which one.			;019
	MESSAG	<" has invalid format and cannot be copied."<200>>	;019
	BR	250$		;So there.				;019

.DSABL	LSB

GLOBAL	<FC...,SILBUF,SATBUF>


.SBTTL	DONE WITH THE COPY. VERIFY OUTPUT DISK

.ENABL	LSB

CPYDNE:	CLR	INDEX		;RESET THE INDEX
	CALL	SETOUT		;SELECT THE OUTPUT DISK
	MOV	#36,QFLAG	;Use QFLAG for temporary flag holder.	;019
10$:	CALL	OUSCAN		;SCAN FOR NEXT OUTPUT FILE
	BCC	20$		; IF ANY
	MESSAG	<<200>"Target disk is not valid - File(s) missing">	;019
	EXIT

20$:	MOV	#1,R1		;PRESET THE MASK BIT
	MOV	#FILTBL-<2*4>,R5 ;GET A BIASED TABLE POINTER
30$:	ADD	#8.,R5		;NEXT TABLE ENTRY
	MOV	(R5)+,FLTYPE	;SAVE THE EXTENSION
	BEQ	10$		;NO MORE, WE DON'T CARE ABOUT THIS ONE
	ASL	R1		;Shift bit to indicate file type.	;019
	CALL	@(R5)+		;CHECK FOR THIS FILE
	BCS	30$		;NO GOOD, TRY AGAIN
	BIC	R1,QFLAG	;Mark this file type as found.		;019
	BNE	10$		;If flags are still set, keep looking.	;019
	CALL	SETOUT		;Point us to the output device.		;034
	CALLX	READCF		;Read CONFIG.SYS from the output disk.	;034
	MOV	#CFGBUF+CFG$NA,R0 ;Now, R0 -> SIL name in CFGBUF.	;034
.ASSUME	<CFG$NA & 1>  EQ  0	;Must be on a word boundary.		;035
	MOV	#"SY,(R0)+	;Put "SYSGEN" in CONFIG.SYS as name	;034
	MOV	#"SG,(R0)+	; of SIL to be started.			;034
	MOV	#"EN,(R0)+						;034
	CLRB	(R0)		;Clear this to make string ASCIZ.	;035
.ASSUME	CFG$ZE	EQ  CFG$NA+6						;035
	CLRB	CFGBUF+CFG$SM	;And, set new SWAP MAX to 0 (default).	;034
	CALLX	WRITCF		;Write CFGBUF into [0,1]CONFIG.SYS.	;034
	MOV	OUTNDX,R0	;DONE!! GET THE OUTPUT DISK INDEX
	MOV	DSKNAM(R0),R2	;R2 = DISK NAME TO BOOT
	MOV	OUTUNT,R4	;R4 = DISK UNIT TO BOOT
	BISB	#BF.AST,BOFLGS	;Say we want to auto-START after boot.	;034
	JMPX	GOBOFL		;Go boot it!!				;034

.DSABL	LSB

GLOBAL	<DSKNAM,CFGBUF,BOFLGS>						;034


.SBTTL	WRITE-BOOT OPTION

.ENABL	LSB

WBOOT::	CALLX	CKOPT		;IS THIS A LEGAL OPTION?
	TSTB	(R1)+		;ANY ARGUMENT FOLLOWING COMMAND?
	BEQ	10$		;NO -- THAT'S FINE
	MESSAGE	<"Can only write boot on system disk.">
	EXIT

10$:	CALL	SETSYS		;SETUP FIP FOR SYSTEM DISK
	CALL	WBTSUJ		;SUBROUTINE DOES THE WORK (SAVE JMP/MOV)
	JMPX	BOOTSY		;TRY OUT THE NEW BOOTSTRAP

.DSABL	LSB


.SBTTL	GET-BOOT  GET BOOTSTRAP INTO SATBUF FOR A DEVICE

.ENABL	LSB

GGBOOT::REGSCR			;SAVE OUR REGISTERS
	CLR	SATBUF+10000	;Assume we won't find the bootstrap
	MOV	LIMITS+2,R2	;Pick up our high address
	CLC			;No evil influences.			;023
	ROR	R2		;Convert to word count
	MOV	R2,BOOTWC	;Save it away.				;023
	MOV	#INITGO,XFERAD	;Also save away the transfer address.	;024
	MOV	SYSNDX,R0	;Get the device index
	BMI	10$		;It's a magtape
	TST	XXBOOT(R0)	;Have boot?
	BEQ	30$		;No, leave without it
	CALL	WBTSUB		;Construct a disk bootstrap
	BR	20$		; and merge with common code

10$:	MOV	#MGBOOT,R3	;Low-order address of MGBOOT into R3.	;023
	CLR	R2		;There is no high-order address...	;023
	CALLX	BLDMGB,R5,<SATBUF+10000> ;Go get the secondary boot.	;023
	BR	30$		;Don't bother with the address stuff.	;023

20$:	MOV	BOOTWC,B.TWC-B.BOOT+SATBUF+10000 ;Set it in the bootstrap
	MOV	#INITGO,B.XFER-B.BOOT+SATBUF+10000 ;Set start address
30$:	RETURN

LIMITS:	.LIMITS

.DSABL	LSB

GLOBAL	<SATBUF,INITGO,BOOTWC>						;023



.SBTTL	WRITE OUT BOOTSTRAP FOR [0,1]INIT.SYS

.ENABL	LSB

WBTSUB::TST	(PC)+		;SET C=0 FOR ALWAYS USING 'JMP' @ B.JMP
WBTSUJ:	SEC			;SET C=1 FOR SAVING 'JMP/MOV' @ B.JMP
	ROR	-(SP)		;SAVE THE INDICATION FOR B.JMP
	MOV	SYSNDX,R0	;GET THE CURRENT DISK INDEX
	MOV	SYSUNT,R1	;Get unit number
	ASL	R1		; times 2
	ADD	DSKMID(R0),R1	;Point to massbus ID value
	MOV	(R1),MSBSID	;Save it for the bootstrap setup code
	MOV	#INITGO,XFERAD	;Always start at normal entry point.	;026
	CALLX	BLDBOT,R5,<SATBUF+10000> ;Set up the bootstrap code
	BEQ	100$		;No bootstrap, error
	TST	(SP)+		;KEEP THE 'JMP/MOV' STATUS @ B.JMP ?
	BPL	10$		;NO, ALWAYS OUTPUT A 'JMP'
	MOV	@#B.JMP,SATBUF+10000+<B.JMP-B.BOOT> ;YES, SO COPY 'JMP/MOV'
10$:	TSTB	BACKUP		;ARE WE DOING A SAV/RESTORE?
	BNE	80$		;YES, DON'T FILL IN CLUSTERS
	MOV	R0,-(SP)	;Save top of boot pointer

; INSERT DEVICE CLUSTERS FOR INIT.SYS

	CALLX	LKINIT		;LOOK UP INIT.SYS
	MOV	#FCINIT,R1	;POINT TO ITS FCB
	CALLX	RNB		;READ NAME ENTRY FOR INIT.SYS
	MOV	#SATBUF+10000+<B.DATE-B.BOOT>,R2 ;Point to end of pointers
	MOV	UAR(R5),-(SP)	;SAVE RETRIEVAL ENTRY POINTER
	BNE	20$		;IF ANY
	ERF	<"INIT.SYS is empty">

20$:	MOV	UAA(R5),R3	;POINT TO ACCOUNTING ENTRY
	CALLX	RDB		;READ THE ENTRY
	MOV	UCLUS(R5),R5	;GET FILE CLUSTER SIZE
	MOV	R5,FCS		;Save that
	CLR	R4		;CLEAR MSB FOR DIVIDE
	DIV	DCS,R4		;R4 = DEVICE CLUSTERS PER FILE CLUSTER
	MOV	(SP)+,R3	;RESTORE POINTER TO FIRST RETRIEVAL ENTRY
	MOV	R4,FCLRAT	;Save file cluster ratio
	MOV	LIMITS+2,R2	;Get our top
	CLC
	ROR	R2		;Now in words
	MOV	R2,-(SP)	;Save that
	MOV	R2,R4		;Copy size
	ADD	#377,R4		;Round up
	CLRB	R4		; to a block multiple
	SWAB	R4		;Now compute size in blocks
	CLR	R1		;Initialize # device clusters in segment
	CLR	-(SP)		; and starting DCN
	MOV	#SATBUF+10000+<B.DATE-B.BOOT>,R2 ;Point to block map area
30$:	CALLX	RDB		;R5 -> RETRIEVAL ENTRY
	TST	(R5)+		;SKIP LINK TO NEXT RETRIEVAL ENTRY
40$:	MOV	(R5)+,R0	;COPY A FILE CLUSTER
	BEQ	60$		;ZERO MARKS END OF LIST
	SUB	R1,R0		;See if this one is adjacent
	CMP	R0,(SP)		;Well?
	BEQ	50$		;Yes, add it to current chunk
	MUL	DCS,R1		;CONVERT DCS TO BLOCKS			;008
	CALL	EXPAND		;Expand this chunk out into the block map
	MOV	-2(R5),-(SP)	;Set starting DCN of next chunk
	CLR	R1		; and initialize size
50$:	ADD	FCLRAT,R1	;Increase the size of this chunk
	SUB	FCS,R4		;And another file cluster bites the dust
	BLOS	60$		;Branch if we're done
	BIT	R5,#17		;END OF THIS RETRIEVAL ENTRY?
	BNE	40$		;NO, REPEAT
	MOV	-20(R5),R3	;YES, GET LINK TO NEXT
	BIC	#17,R3		;CLEAR FLAG BITS
	BNE	30$		;LOOP IF NOT END OF LIST

60$:	MUL	DCS,R1		;CONVERT DCNs TO BLOCKS			;008
	ADD	R4,R1		;Cut last chunk to only as much as needed
	BEQ	70$		;Nothing needed, skip ahead
	CALL	EXPAND		;Expand the last chunk
	MOV	(SP)+,R0	;Get actual word count to use
	BIC	#^C<377>,R0	;Isolate last partial block's count
	BEQ	70$		;Was a full block, skip
	MOVB	R0,4(R2)	;Update last word count
	DECB	5(R2)		; one less block
70$:	CLR	-(R2)		;Store the end marker
	CMP	R2,(SP)+	;Does the boot fit?
	BLO	90$		;No, error
	CLR	R2		;FIX REGISTERS FOR WRITING BOOT BLOCK
	CLR	R3		;AT FBN 0
	MOV	#256.,I.DSQ+DSQCNT ;ONE BLOCK TRANSFER
	CALLX	PARSEX,R5,<WFUN,SATBUF+10000>
80$:	RETURN			;ALL DONE WRITING BOOT

90$:	ERF	<"INIT.SYS is too fragmented to hook">

100$:	ERF	<"Bootstrap not found">

.DSABL	LSB

	TMPORG	COPCTL

FCS:	.BLKW			;Clustersize of file being hooked
FCLRAT:	.BLKW			;FCS/DCS for file

	UNORG

GLOBAL	<SYSNDX,SYSUNT,XFERAD,DSKMID,MSBSID,BACKUP,SATBUF,FCINIT,DCS,I.DSQ>


.SBTTL	Enter data for a contiguous chunk into the block map

EXPAND::TST	R1		;IS THERE A PREVIOUS CHUNK?		;008
	BEQ	30$		;Skip if there was no previous chunk
	MOV	R4,-(SP)	;Save some registers
	MOV	R5,-(SP)	; another one
	MOV	2+4(SP),R4	;Get starting DCN
	MUL	DCS,R4		;Multiply by DCS to get block number
	BPL	10$		;Branch if no overflow
	ADD	DCS,R4		;Correct for signed multiply
10$:	MOV	#77400/400,R0	;Get max block count
	CMP	R0,R1		;Do we even have that many blocks?
	BLOS	20$		;Yes
	MOV	R1,R0		;No, so do only as many as exist in this chunk
20$:	MOV	R0,-(R2)	;Set block count
	SWAB	(R2)		; now word count
	MOV	R4,-(R2)	;Set high order block number
	MOV	R5,-(R2)	; and low order
	ADD	R0,R5		;Advance block number
	ADC	R4		; in double precision
	SUB	R0,R1		;Compute how many blocks are left
	BNE	10$		;Some, stash another chunk
	MOV	(SP)+,R5	;Restore registers
	MOV	(SP)+,R4	; and another
30$:	MOV	(SP)+,(SP)	;Remove the word passed on the stack
	RETURN			;Done...




.SBTTL	Miscellanea for boot builder

INIWRD::MOV	(SP),-(SP)	;Free up a spot on the stack
	MOV	(R3),2(SP)	;Return the data
	RETURN			;Done

XXBPTR::.WORD	XXBOOT,0	;Pointer to XXBOOT table for BLDBOT


	TMPORG	COPCTL

.MACRO	PTR	SYM
.IF	NDF	SYM
	.WORD	0
.IFF
	.WORD	SYM-.
.ENDC
.ENDM	PTR

	$TAPES
	PTR	B$'NAME'BO
.ENDR
XXBOOT::$DISKS			;PROTOTYPE BOOTSTRAPS FOR ALL DISKS
	PTR	B$'NAME'BO
.ENDR

	UNORG


.SBTTL	SELECT THE OUTPUT DISK, GET SATT INTO MEMORY

.ENABL	LSB

SETOUT:	REGSCR
	MOV	OUTNDX,R0	;R0 = DISK INDEX
	MOV	OUTUNT,R1	;R1 = DISK UNIT
	CMP	R0,SYSNDX	;ALREADY SELECTED?
	BNE	10$		;NO
	CMP	R1,SYSUNT	;MAYBE...
	BEQ	20$		;YUP, JUST GET THE SATT
10$:	CALLX	SETFNS		;SET UP FIP FOR THE DISK
20$:	MOV	#FQSATT,R4	;R4 -> SATT.SYS FIRQB TO ENSURE IT'S OPEN
	CALLX	LOKFIL		;OPEN IT
	BCS	30$		;WHAT? IT ISN'T THERE?
	MOV	FCSATT+FCSIZ,R0	;R0 = NUMBER OF BLOCKS IN SATT
	SWAB	R0		;COMPUTE NUMBER OF WORDS
	CMP	R0,#4*4000/2	;TOO BIG (OVER 4K WORDS) ?
	BHI	40$		;YES
	MOV	#FCSATT,R1	;R1 -> SATT.SYS FCB FOR READ
	CLR	FCNVB(R1)	;START AT BLOCK 0
	CALLX	READ.,R5,SATBUF	;READ INTO SATBUF
	RETURN

30$:	ERF	<"SATT.SYS non-existent at time of read">

40$:	ERF	<"SATT.SYS is over 16. blocks long">

.DSABL	LSB

GLOBAL	<SYSNDX,SYSUNT,FQSATT,FCSATT,SATBUF>


.SBTTL	CHECK FILE NAMES, COMPUTE FILE SIZES

.ENABL	LSB

SYSCHK:	CMP	(R0),#^RINI	;Check for exactly 'INIT  .SYS'
	BNE	5$		;No, but perhaps it's ODT.SYS		;030
	CMP	2(R0),#^RT  	;MAYBE...
	BNE	10$
	BR	SILCHK		; and skip to check extension		;030

5$:	CMP	(R0),#^RODT	;Not INIT, perhaps ODT?			;030
	BNE	7$		;No					;030
	TST	2(R0)		;Check last 3 chars			;030
	BEQ	SILCHK		;Must be blank (0)			;034

7$:	CMP	(R0),#^RCON	;Not ODT or INIT, maybe CONFIG?		;034
	BNE	10$		;Nope.					;034
	CMP	2(R0),#^RFIG	;So far so good - is it really?		;034
	BNE	10$		;Really nope!				;034
	.BR	SILCHK		;Otherwise, it's OK.			;034

SILCHK:				;CHECK FOR PROPER EXTENSION
RTSCHK:
COMCHK:									;010
ERRCHK:
TSKCHK:									;010
MSGCHK:									;027
SAVCHK:	CMP	4(R0),FLTYPE	;EXTENSION MATCH?
	BEQ	20$		;YES, RETURN C=0 FROM CMP
10$:	SEC			;NO MATCH, SET CARRY
20$:	RETURN


EOVCHK:	CMP	4(R0),FLTYPE	;Really a .EOV file?			;022
	BNE	10$		;No, not this time			;022
	TST	SYSNDX		;Are we running off of disk?		;022
	BGT	20$		;Yes, C=0 from TST above		;022
	BR	10$		;No, tape, ignore EOV files		;022

.DSABL	LSB


.SBTTL	COMPUTE SIZE OF FILES

.ENABL	LSB

COMCSZ:	PUSH	<R1,R0>		;Save R1 and R0				;010
	MOV	#SILBUF,R1	;Get pointer to the 1 block of file	;010
	CMPB	(R1)+,#'!	;Is this a RSTS supplied COM file?	;010
	BNE	5$		;Apparently not.  Say it's bogus.	;019
	CALLX	DECINP		;If it's cool, convert the block size.	;019
	TST	R0		;See if it's negative or zero.		;019
	BLE	5$		;If so, it's no good.			;019
	MOV	R0,FILSIZ	;If it's OK, save it away.		;019
	BR	7$		;Skip the error stuff.			;019
5$:	SEC			;Indicate an error.			;019
7$:	POP	<R0,R1>		;Restore R0 and R1			;010
	RETURN

ERRCSZ:	MOV	#16.,FILSIZ	;ERROR FILES ARE ALWAYS LENGTH 16
	CLC			;No errors here.			;019
	RETURN

SYSCSZ:	CMP	FQ...+FQNAM1,#^RCON ;Is this CONFIG.SYS?		;034
	BNE	8$		;No, so go on.				;034
	CMP	FQ...+FQNAM1+2,#^RFIG ;Is it really?			;034
	BNE	8$		;No, really it's not!!			;034
	MOV	#1,FILSIZ	;Yup, so it's 1 block long!		;034
.ASSUME	CFGSIZ	LE 512.							;034
	CLC			;No errors possible...			;034
	RETURN			;Just go back.				;034

8$:	REGSCR			;Compute size of *.SYS.			;034
	CMP	FQ...+FQNAM1,#^RINI ;Checking INIT.SYS?			;030
	BNE	RTSCSZ		;No, must be ODT, skip ahead		;030
	MOV	#SILBUF+60,R0	;CHECK THE FIRST BLOCK TO ENSURE IT'S US
	MOV	#SYSTBL,R1	;TABLE TO CHECK CONSTANTS AGAINST
10$:	CMP	(R0)+,(R1)+	;MATCH?
	BNE	BADFOR		;INVALID FORMAT
	TST	(R1)		;MORE?
	BNE	10$		;YES
	.BR	RTSCSZ		;INIT IS A SIL; FIND ITS SIZE LIKE OTHER SILS

	TMPORG	COPCTL
SYSTBL:	.IRP	$,<DEVTBL,CSRTBL,VECTBL,TYPTBL,HWTABL,SILNAM,DSKSZL,DSKSZM>
	 .WORD	$
.GLOBL	$
.ENDM
	 .WORD	0		;END OF LIST
	UNORG

GLOBAL	<SILBUF>


TSKCSZ:				;TSK files are single-module SILs	;027
MSGCSZ:				;MSG files are single-module SILs	;027
RTSCSZ:				;RTS files are single-module SILs	;027
	CMP	SILBUF,#1	;Does this SIL have one module?
	BNE	BADFOR		;No, invalid format

SILCSZ:
SAVCSZ:	REGSCR			;SAVE THE REGISTERS
	MOV	SILBUF+50,R0	;GET THE RT11 HIGH LIMIT VALUE
	ADD	#777,R0		;ROUND UP TO A BLOCK BOUNDARY
	CLRB	R0		;EVEN IT
	SWAB	R0		;MAKE IT A BLOCK COUNT
	ASR	R0		; BY DIVIDING BY 512
	MOV	R0,FILSIZ	;SAVE THE FILE SIZE IN BLOCKS
	MOV	#SILBUF,R2	;ASSUME WE ARE LOOKING AT A SIL
	MOV	(R2)+,R1	;GET THE NUMBER OF MODULES
	BEQ	BADFOR		;ZERO IS A BAD NUMBER OF MODULES FOR A SIL
	CMP	R1,#SI.NMD	;SEE IF WE HAVE TOO MANY MODULES	;JHCFEK
	BHI	BADFOR		;THIS CAN NOT BE A SIL
20$:	MOV	(R2)+,R0	;FETCH THE NEXT WORD OF THE SIL INDEX
	XOR	R0,R1		;KEEP A RUNNING TOTAL OF THE CHECKSUM
	CMP	R2,#SILBUF+SI.CHK ;ARE WE AT THE END OF THE SIL INDEX?
	BLO	20$		;NO, KEEP COMPUTING THE CHECKSUM
	CMP	R1,(R2)+	;DOES THE CHECKSUM MATCH?
	BNE	BADFOR		;NO, THEN THIS IS NOT A SIL
	CMP	(R2)+,#^RSIL	;THE LAST WORD OF THE INDEX BETTER BE 'SIL'
	BNE	BADFOR		;THIS IS NOT A SIL
	MOV	@#SILBUF+SI.BLS,FILSIZ ;GET THE SIZE OF THE SIL IN BLOCKS
	BNE	60$		;IF IT'S THERE THEN THE REST IS EASY.
	MOV	#SILBUF,R2	;RESET R2 TO THE BEGINNING OF THE SIL INDEX
	MOV	(R2)+,R3	; R3 = NUMBER OF MODULES IN SIL
	MOV	SE.BLK(R2),FILSIZ; INITIALIZE THE FILSIZE COUNTER
30$:	CALL	ADBLKS,R5,<SE.STN,77,-6> ;ADD # OF BLOCKS IN SYMBOL TABLE
	CALL	ADBLKS,R5,<SE.OVN,77,-6> ;ADD # OF BLOCKS IN OVERLAY TABLE
	MOV	SE.SZD(R2),R0	;DOES THIS SIL HAVE AN ON DISK SIZE VARIABLE
	BNE	40$		;YES, THE REST IS EASY
	CALL	ADBLKS,R5,<SE.SIZ,777,-9.> ;ADD # OF BLOCKS IN MODULE IMAGE
	;CLR	R0	
40$:	ADD	R0,FILSIZ	;ADD THE MODULE IMAGE SIZE INTO FILESIZE
	BCS	BADFOR		;WE DO NOT ALLOW SILS TO BE LARGE FILES
	ADD	#SE.LEN,R2	;BUMP R2 TO THE NEXT MODULE DESCRIPTOR
	SOB	R3,30$		;LOOP ON THE NUMBER OF MODULES
	TST	(PC)+		;JUMP OVER THE ERROR CONDITION
BADFOR:	SEC			;INDICATE AN ERROR
60$:	RETURN

.DSABL	LSB

GLOBAL	<SILBUF>


.SBTTL	Multi-volume disk handling

;+
; EOVCSZ - Handle the volume switch
;
; This routine is used to handle volume switch during the COPY option.
; We are implemented as a "size" routine since that way, we can use
; common code in the COPY mainline to read in the first block of the
; file. We will clean up the stack and jump back into the copy mainline
; once we set the new volume up.
;
; Note that the file checker has already verified that we are using
; disk input. As a result, we don't have to worry about tape handling.
;-

.ENABL	LSB

EOVCSZ:	MOV	#SILBUF,R4	;Point to the text to print		;022
	CLRB	1000(R4)	;Be sure it ends with a null		;022
10$:	MOVB	(R4)+,R2	;Get a character			;022
	BEQ	40$		;All done				;022
	CMPB	R2,#VOLSUB	;Is this the volume substitution character? ;022
	BEQ	20$		;Yes, go handle it			;022
	CMPB	R2,#SYSSUB	;How about the system disk substitution? ;022
	BEQ	30$		;Yes, go do that one			;022
	CALLX	TYPE		;No, print out the character		;022
	BR	10$		;And loop...				;022

; If we find the character "VOLSUB", print out the file name that we
; are working on.

20$:	MOV	#FQ...+FQNAM1,R5 ;Point to current file name		;022
	MOV	(R5)+,R0	;Pick up first three characters		;022
	CALLX	RADZER		;Now display it				;022
	MOV	(R5)+,R0	;Now next three characters		;022
	CALLX	RADZER		;And display it				;022
	BR	10$		;Now off to the next character		;022
	
; If we find the character "SYSSUB", print out the device name that we
; are booted off of.

30$:	MOV	B.NAME,R2	;Get the device name we booted from	;022
	CALLX	TYPE2		;And type it out			;022
	MOVB	B.UNIT,R0	;Get the unit number we booted		;022
	CALLX	DECZER		;And type it out			;022
	BR	10$		;Now off to the next character		;022

; Now we've printed out all the text. We will set the flag indicating
; that the system disk has been dismounted, and wait for a delimiter.

40$:	MOVB	#-1,SAVBOO	;Indicate system disk no longer mounted	;022
	CALLX	GETIN		;Go get a line				;022
	MOVB	#-1,NOERR	;Turn off errors from SETFIP		;022
	CALLX	SETFIP		;Go and set up FIP for this disk	;022
	TSTB	NRSTSD		;Is this a RSTS disk?			;022
	BNE	50$		;No, forget it				;022
	CLRB	NOERR		;Turn errors back on			;022
	CALLX	READPL		;Go read in the pack label		;022
	CMP	FIBUF+PCKID,FQ...+FQNAM1 ;Correct volume?		;022
	BNE	50$		;No, not this time			;022
	CMP	FIBUF+PCKID+2,FQ...+FQNAM1+2 ;Really correct?		;022
	BEQ	60$		;Yes, sure is				;022
50$:	MESSAG	<<177>"This is not the correct volume."<200>>		;022
	MESSAG	<"Please mount the correct volume and press Return">	;022
	BR	40$		;Now try again, please...		;022

60$:	MOV	SPSAVE,SP	;Clean up the stack			;022
	CLR	INDEX		;Reset the disk index			;022
	CALL	DKINIT		;Set up for this new disk [0,1]		;022
	JMP	NEXTIN		;And go get the first file...		;022

.DSABL	LSB

GLOBAL	<SILBUF,SAVBOO,NOERR,NRSTSD>					;022


;+
;
; SUBROUTINE FOR COMPUTING THE NUMBER OF BLOCKS USED BY A SIL TABLE
;
;	CALL ADBLKS,R5
;	
;	.WORD	INDEX OFF R2 TO -> # OF SYMBOLS IN TABLE
;	.WORD	AMMOUNT TO ROUND UP TO GET EVEN BLOCK
;	.WORD	AMMOUNT TO SHIFT OVER TO GET A BLOCK COUNT
;
;	R2 -> INDEX FOR MODULE
;
; RETURNS
;
;	R0 = 0
;	FILSIZ = FILSILZ + TABLE LENGTH
;	R1 = BLOCKSIZE OF TABLE
;
;-

.ENABL	LSB

ADBLKS:	MOV	R2,R0		;COPY THE POINTER TO THE MODULE INDEX
	ADD	(R5)+,R0	;R0 -> # SYMBOLS IN TABLE
	MOV	(R0),R1		;R1 = #SYMBOLS IN TABLE
	CLR	R0		;CLEAR R2 FOR DOUBLE PRECISION ADD
	ADD	(R5)+,R1	;ROUND UP TO BLOCK BOUNDARY
	ADC	R0		;BOTH WORDS
	ASHC	(R5)+,R0	;CREATE A BLOCK COUNT
	ADD	R1,FILSIZ	;ADD INTO RUNNING FILESIZE
	BCS	BADFOR		;NO LARGE FILE SILS ALLOWED
	TST	R0		;IS THIS TABLE BIGGER THAN 65536 BLOCKS
	BNE	BADFOR		;THAT IS ALSO NO GOOD
	RETURN	R5

.DSABL	LSB


.SBTTL	PRINT A FILE NAME

.ENABL	LSB

PRTNAM:	REGSCR
	MOV	#FQ...+FQNAM1,R1 ;POINT TO FIRQB WITH NAME
	CALL	10$
	CALL	10$
	MESSAGE	<".">
10$:	MOV	(R1)+,R0
	CALLRX	RADZER

.DSABL	LSB


.SBTTL	CREATE A FILE IN THE UFD

.ENABL	LSB

CREATE:	CLR	R5		;R5 = 0 AS A FLAG FOR GOODNESS
	REGSCR			;NOW SAVE ALL REGISTERS
	MOV	R4,R0		;COPY FIRQB POINTER
	ADD	#FQPPN,R0	;R0 -> PPN IN THE FIRQB
	CALLX	SDU		;FIND THE FILE IN THE MFD
	BCC	80$		;IT EXISTS ALREADY! THAT SHOULDN'T HAPPEN
	CMP	R5,#4		;DOES THE UFD EXIST AT ALL?
	BNE	90$		;NO, NO UFD???
	MOV	R2,-(SP)	;SAVE LINK TO LAST NAME ENTRY
	MOV	PCS,FQCLUS(R4)	;CLUSTERSIZE OF FILE IS PACK CLUSTER SIZE
	CALLX	GDB		;GET A DIRECTORY ENTRY FOR ACCOUNTING
	BCS	70$		;CAN'T GET IT, GO RETURN 2 IN R5
	MARK	FIBUF
	MOV	R3,-(SP)	;SAVE LINK TO ACCOUNTING ENTRY
	INC	(R5)+		;MARK THE ENTRY IN USE
	MOV	I.DATE,(R5)+	;LAST ACCESS DATE
	MOV	FQSIZN(R4),(R5)+ ;SIZE OF FILE
	MOV	I.DATE,(R5)+	;CREATION DATE
	MOV	I.TIME,(R5)+	;CREATION TIME
	MOV	FILRTS,(R5)+	;CREATING RTS				;013
	MOV	FILRTS+2,(R5)+						;013
	MOV	PCS,(R5)+	;CLUSTERSIZE = PCS
	MARK	FIBUF		;REWRITE THE ACCOUNTING ENTRY
	CALLX	GDB		;GET A HOLE FOR THE NAME ENTRY
	BCS	50$		;NO CAN DO, RELEASE THE A.E.
	CLR	(R5)+		;LINK TO NEXT NAME ENTRY = 0
	MOV	FQNAM1(R4),(R5)+ ;SET UP FILNAM.EXT
	MOV	FQNAM1+2(R4),(R5)+
	MOV	FQNAM1+4(R4),(R5)+
	MOV	FLFLAG,(R5)+	;PROTECTION CODE & FLAG BITS
	CLR	(R5)+		;ACCESS COUNT = 0
	MOV	(SP)+,(R5)+	;LINK TO ACCOUNTING ENTRY
	MOV	R3,-(SP)	;SAVE LINK TO NAME ENTRY
	MOV	R5,-(SP)	;SAVE POSITION (IN FIBUF) FOR R.E. LINK
	MOV	R3,-(SP)	;SAVE LINK TO N.E. IN WHICH TO PLUG UAR
	CLR	R5		;R5 = 0 TO FORCE ALLOCATION FIRST TIME
	MOV	FQALLC(R4),R2	;R2 = R.P. TO START OF FILE
	MOV	FQNPCL(R4),R4	;R4 = NUMBER OF PACK CLUSTERS

GLOBAL	<PCS,I.DATE,I.TIME>


10$:	BIT	R5,#17		;NEED A NEW RETRIEVAL ENTRY?
	BNE	20$		;NO
	CALLX	GDB		;YES, GET ONE
	BCS	30$		;NONE TO GET, RETURN EVERYTHING & GO AWAY
	MOV	R3,R1		;R1 = LINK TO R.E. JUST OBTAINED
	MOV	(SP)+,R3	;R3 = LINK TO PREVIOUS ENTRY
	CALLX	RDB		;GET PREVIOUS
	MOV	R1,@(SP)+	;LINK IT TO THIS ENTRY
	MOV	R1,R3		;GET LINK TO THE NEW R.E.
	CALLX	RDS		;READ IT, SAVING THE PREVIOUS
	MOV	R5,-(SP)	;NEXT R.E. LINK GOES HERE
	MOV	R3,-(SP)	;LINK TO THIS R.E. FOR NEXT R.E.
	CLR	(R5)+		;FOR NOW, NEXT R.E. = 0
20$:	MOV	R2,(R5)+	;SET UP RETRIEVAL POINTER
	MARK	FIBUF		;FIBUF HAS CHANGED
	ADD	CLURAT,R2	;UPDATE RETRIEVAL POINTER FOR CTG FILE
	SOB	R4,10$		;LOOP FOR EACH PACK CLUSTER TO ALLOCATE
	CMP	(SP)+,(SP)+	;DUMP POINTERS TO PREVIOUS R.E.
	MOV	(SP)+,R1	;R1 = LINK TO FILE NAME ENTRY
	MOV	(SP)+,R3	;R3 = LINK TO LAST NAME ENTRY IN UFD
	CALLX	RDS		;READ IT
	MOV	R1,(R5)		;FORMERLY LAST FILE LINKS TO THIS NEW ONE
	CALLRX	WRITE		;REWRITE FIBUF, RESTORE REGS, EXIT

30$:	CMP	(SP)+,(SP)+	;COULDN'T GET R.E., SO DUMP PTRS TO PREV
	ADD	#2,TOS.R5+4(SP)	;R5 WILL EVENTUALLY BE 6
	MOV	(SP)+,R3	;R3 = LINK TO NAME ENTRY
	CALLX	RDB		;GET NAME ENTRY
	MOV	UAA(R5),R3	;R3 = A.E. LINK FOR DELETION
	MOV	UAR(R5),R1	;R1 = R.E. LINK FOR DELETION
	CLR	(R5)+		;MAKE THE NAME ENTRY A HOLE
	CLR	(R5)+
	CALLX	RDS		;GET THE ACCOUNTING ENTRY
40$:	CLR	(R5)+		;MAKE IT A HOLE
	CLR	(R5)+
	MOV	R1,R3		;COPY LINK TO (NEXT) RETRIEVAL ENTRY
	BIC	#17,R3
	BEQ	60$		;NO MORE, FINISH UP
	CALLX	RDS		;GET THE R.E.
	MOV	(R5),R1		;SAVE LINK TO NEXT R.E.
	BR	40$		;GO MAKE IT A HOLE

GLOBAL	<CLURAT>


50$:	MOV	(SP)+,R3	;COULDN'T GET NAME ENTRY. LINK TO A.E.
	CALLX	RDS		;GET ACCOUNTING ENTRY
	CLR	(R5)+		;MAKE IT A HOLE
	CLR	(R5)+
60$:	ADD	#2,TOS.R5+2(SP)	;R5 WILL BE 4 FOR NO NAME ENTRY
	MARK	FIBUF
70$:	TST	(SP)+		;DUMP LINK TO LAST NAME ENTRY IN UFD
	ADD	#2,TOS.R5(SP)	;R5 WILL BE 2 FOR NO ACCOUNTING ENTRY
	CALLRX	WRITEC		;WRITE EVERYTHING, GO BACK WITH R5 <> 0

80$:	ERF	<"INIT bug - file exists when trying to create">

90$:	ERF	<"INIT bug - no UFD found in create">

.DSABL	LSB


.SBTTL	MOUNT/DISMOUNT DISK DURING CRITICAL OPERATIONS

.ENABL	LSB

DMOUNT:	CALLX	READPL		;Read the pack label			;003
	TST	FIBUF+PSTAT	;CHECK THE DISK				;003
	BMI	20$		;ALREADY DIRTY, DON'T USE IT
.ASSUME	UC.MNT LT 0							;003
	BIS	#UC.MNT,FIBUF+PSTAT ;MAKE IT DIRTY			;003
	BR	10$		;FORCE IT OUT

DDISM:	CALLX	READPL		;Read the pack label			;003
	BIC	#UC.MNT,FIBUF+PSTAT ;MAKE IT UNDIRTY			;003
10$:	CALLX	WRITE		;FORCE IT OUT
	RETURN

20$:	MESSAGE	<"Output disk needs rebuilding - cannot proceed"<200>>
	EXIT

.DSABL	LSB

GLOBAL	<FIBUF>


.SBTTL	DEVICE ROUTINES FOR DISK INPUT

.ENABL	LSB

SETSYS:	CMP	SYSNDX,SYNXSV	;SELECT THE SYSTEM DISK IF NOT ALREADY DONE
	BNE	10$		;GOTTA DO IT
	CMP	SYSUNT,SYSUSV	;MAYBE...
	BNE	10$		;DO IT
	RETURN			;EASY. IT'S SELECTED

DKINIT:	REGSCR			;TO INITIALIZE, SAVE REGISTERS
10$:	CALLX	SETFIP		;SELECT THE SYSTEM DISK
	MOV	#FQ...+FQPPN,R0	;POINT TO THE [0,1] PPN
	CALLX	RUF		;READ IT
	BCS	20$		;NOT THERE?
	RETURN

20$:	ERF	<"[0,1] UFD not found">

GLOBAL	<SYSNDX,SYNXSV,SYSUNT,SYSUSV,FQ...>


OUSCAN:	REGSCR			;SAVE REGISTERS
	BR	30$		;USE THE SELECTED DISK (OUTPUT)

DKSCAN:	REGSCR			;FIND A FILE ON THE DISK
	CALL	SETSYS		;SELECT THE RIGHT DISK
30$:	MOV	INDEX,R3	;GET THE LINK IN [0,1] TO NEXT FILE
	BNE	40$		;NOT THE FIRST TIME!
	CALLX	RDB		;READ IN THE LIST HEAD
	MOV	(R5),R3		;GET REAL FIRST LINK
40$:	BIC	#17,R3		;REMOVE FLAG BITS
	SEC			;C=1 IN CASE
	BEQ	60$		; THE LINK IS 0, SO NO MORE FILES
	CALLX	RDB		;GET THE NEXT NAME ENTRY
	MOV	(R5)+,INDEX	;SAVE THE NEXT LINK
	BIS	#1,INDEX	;MAKE IT NON-0 TO DISTINGUISH START FROM END
	;ADD	#UNAM-2,R5	;POINT TO THE NAME
.IIF	NE	UNAM-2, .ERROR ;THE ABOVE WON'T WORK
	MOV	R5,TOS.R0(SP)	;RETURN POINTER TO NAME IN R0
	MOV	#FQCOPY,R1	;POINT TO THE FIRQB FOR INPUT		;030
	MOV	#FQ...,R0	;POINT TO THE PROTOTYPE
	MOV	#FQFCB+FCBSIZ/2,R2 ;R2 = NUMBER OF WORDS
50$:	MOV	(R0)+,(R1)+	;SET UP THE FIRQB
	SOB	R2,50$
	MOV	#FQCOPY+FQNAM1,R1 ;NOW PUT THE INPUT FILE NAME IN	;030
	MOV	(R5)+,(R1)+
	MOV	(R5)+,(R1)+
	MOV	(R5)+,(R1)+
	CLR	FQCOPY+FQSTAT	;NOT OPEN YET				;030
	;CLC			;C=0 FROM ABOVE
60$:	RETURN			;DONE

GLOBAL	<FQ...,FQCOPY>							;030


DKREAD:	REGSCR			;READ FROM INPUT FILE
	CALL	SETSYS		;GET THE RIGHT DISK SET UP
	MOV	#FQCOPY,R4	;POINT TO THE FIRQB			;030
	BIT	#FS.OPN,FQSTAT(R4) ;IS IT OPEN YET?
	BNE	80$		;YES, JUST READ
	CALLX	LOKFIL		;NO, GET IT
	BCC	70$		;GOT IT
	ERF	<"INIT bug - failed to find file again">

70$:	CLR	FCCOPY+FCNVB	;ENSURE READ STARTS AT BLOCK 0		;030
80$:	MOV	#FCCOPY,R1	;R1 -> FCB FOR INPUT			;030
	MOV	TOS.R0(SP),R0	;R0 = WORD COUNT
	CALLX	READ.,R5,SATBUF+10000 ;DO THE READ
				;C=1 IF EOF FOUND
	RETURN

DKEOF:	CMP	FC...+FCNVB,FC...+FCSIZ ;ABOUT TO READ JUST PAST FILE?
	BEQ	90$		;YES, PROPERLY AT EOF
	SEC			;NO, C=1 FOR ERROR
90$:	RETURN

.DSABL	LSB

GLOBAL	<FQ...,FC...,FQCOPY,FCCOPY>					;030


.SBTTL	DEVICE ROUTINES FOR MAGTAPE INPUT

.ENABL	LSB

MTINIT:	REGSCR			;REWIND THE TAPE
	MOV	SYNXSV,R0	;DEVICE INDEX
	MOV	SYSUSV,R1	;UNIT NUMBER
	CALLX	SETTAP		;REWIND IT
	BCS	MTERRR		;QUIT IF ANY ERROR
	MOV	SYSDEN,R2	;SET UP THE PARAMTER FOR BOOTED TAPE'S DENSITY
	CALLX	MAGSPC,R5,6	;SET THE TAPES DENSITY
	BCS	MTERRR		;QUIT IF ANY ERROR
	MOV	(PC),ATEOF	;WE ARE LOGICALLY AT AN EOF
	RETURN

MTSCAN:	MOV	#WORKBF,R0	;USE THIS FOR A WORK BUFFER
	REGSCR
	MOV	SYNXSV,R0	;GET DEVICE INDEX
	MOV	SYSUSV,R1	;AND UNIT
	TST	ATEOF		;ARE WE AT EOF NOW?
	BNE	10$		;YUP, DON'T NEED TO SKIP
	CLR	R2		;INIDICATE A LARGE COUNT
	CALLX	MAGSPC,R5,4.	;SKIP FORWARD TO EOF
	BCS	80$		;QUIT IF ANY ERROR
10$:	CLR	ATEOF		;NOT AT EOF AFTER READING THIS LAGEL
	CLR	HIGHBF		;HIGH-ORDER BUFFER ADDRESS = 0
	MOV	#7.,I.DSQ+DSQCNT ;LABEL IS 14 BYTES LONG
	CALLX	MAGIO,R5,<RFUN,WORKBF> ;READ INTO WORKBF
	BCC	20$		;NO ERROR IS GOOD
	CMPB	IOERR,#MAGRLE	;WAS IT ?MAGTAPE RECORD LENGTH ERROR
	BEQ	20$		;YUP, MUST HAVE BEEN 18 BYTE LABELS
	BR	80$		;NOPE, MUST HAVE BEEN EOF


20$:	MOV	WORKBF+6,R3	;NO, GET THE PPN FROM THE LABEL
	DEC	R3		;ARE WE STILL IN [0,1]
	BNE	30$		;NO, BACK OVER THE LABEL AND QUIT
	RETURN

30$:	MOV	#1,R2		;SET REVERSE SKIP COUNT OF 1
	CALLX	MAGSPC,R5,5.	;SKIP REVERSE (BACK OVER THE LABEL)
	BR	80$		;EXIT WITH CARRY SET

40$:	MOV	(PC),ATEOF	;IN CASE EOF, SET THE FLAG
	CMPB	IOERR,#EOF	;AN EOF RETURN
	BEQ	80$		;YES, RETURN CARRY SET FOR END
MTERRR:	ERF	<"Magtape error or invalid format on tape">

GLOBAL	<SYNXSV,SYSUSV,HIGHBF,IOERR,I.DSQ,EOF,MAGRLE,SYSDEN>


MTREAD:	REGSCR
	MOV	R0,R3		;COPY THE WORD COUNT
	SWAB	R3		;R3 = BLOCK COUNT
50$:	MOV	#SATBUF+10000,R2 ;R2 -> INPUT BUFFER
60$:	MOV	R2,70$		;SET BUFFER ADDRESS
	MOV	#256.,I.DSQ+DSQCNT ; 512 BYTE COUNT
	MOV	SYNXSV,R0	;DEVICE INDEX
	MOV	SYSUSV,R1	;AND UNIT
	CALLX	MAGIO,R5	;READ...
	.WORD	RFUN		;FUNCTION CODE
70$:	.WORD	-1		;INTO THIS ADDRESS
	BCS	40$		;SORT OUT EOF ERRORS
	ADD	#1000,R2	;BUMP BUFFER ADDRESS BY 1 BLOCK
	SOB	R3,60$		;DO MORE IF NEEDED
	CLC			;C = 0 FOR GOOD READ
	RETURN

MTEOFR:	REGSCR			;CHECK FOR EOF
	MOV	#1,R3		;R3 = NUMBER OF BLOCKS TO TRY
	CALL	50$		;TRY THE READ
	BCC	80$		;C = 0 MEAS WE GO IT, GO SET C NOT AT EOF
	TST	(PC)+		;SET C = 0
80$:	SEC			;SET C = 1
	RETURN

.DSABL	LSB

	TMPORG	COPCTL
ATEOF:	.WORD	0		;<>0 IF AT EOF
	UNORG

GLOBAL	<SATBUF,I.DSQ,SYNXSV,SYSUSV>


.SBTTL	DISK BOOTSTRAPS

;+
; SOME NOTES ON THESE BOOTSTRAPS:
;
;	1) THESE ARE ALL RSTS/E STYLE BOOTSTRAPS.
;	2) EACH BOOTSTRAP MAY BE UP TO 1000(8) BYTES IN LENGTH.
;	   THERE IS A STANDARD PREFIX, AND A PARAMETER TABLE AT A FIXED
;	   OFFSET INTO THE BOOT, ACCORDING TO THE FORMAT BELOW:
;		OFFSET	CONTENTS
;		    0	NOP - REQUIRED BY DEC STANDARD
;			(HALT for GPK bootstraps)			;028
;		    2	BR XXSETU - BRANCH TO UNIT SELECTION SETUP CODE
;		 4- 6	.WORD  6,0 - HALT AT  6 IF TRAP TO  4 OCCURS
;		10-12	.WORD 12,0 - HALT AT 12 IF TRAP TO 10 OCCURS
;		   14	DEVICE CLUSTER SIZE (FIXED FOR DEVICE TYPE)
;			(IF TAPE, THIS IS 0)
;		   16	DEVICE CONTROL REGISTER BASE (USUALLY FIXED)
;		   20	DEVICE NAME (2 CHARACTERS OF ASCII)
;		   22	JMP @(PC)+  JUMP TO TRANSFER ADDRESS
;		   24	TRANSFER ADDRESS (SET BY HOOK PROGRAM)
;		   26	BOOTED UNIT NUMBER IN BIT POSITIONS 0-2
;		   30	BOOTED UNIT NUMBER SHIFTED FOR DEVICE CONTROLLER 
;		     OR	16 BIT BUFFER ADDR FOR MSCP COMM. AREA FOR UDA DISKS
;		   32	BYTE CONTAINING CODE FOR READ FUNCTION
;		   33	BYTE CONTAINING CODE FOR WRITE FUNCTION
;		   34	WORD WITH FUNCTION CODE (INITIALLY READ)
;		   36-40 Block number to read
;		   42-44 Address to read into
;		   46	Word count for transfer, also bootstrap size
;		   50	Device specific reset
;		   52	Read/write subroutine entry.  This routine uses the
;			data in 36-46 to find what to read.
;			Must preserve R1 if disk.
;		   54	Special function entry -- tapes only
;		   ??	UNIT SELECTION SETUP CODE - SET PR7,
;				SAVE BOOTED UNIT NUMBER IN 26, 30, THEN
;				GO TO RELOCATION CODE
;			Following the unit setup code, HOOK will insert the
;			boot mover code, and the bootstrap mainline for the
;			type of device used (one for disks, another for tape)
;
;	3) THESE BOOTSTRAPS ARE NOT REUSABLE
;	4) THESE BOOTSTRAPS MUST BE STARTED AT LOCATION 0.
;	   THEY MAY NOT BE BUILT ELSEWHERE IN CORE AND STARTED.
;-


.SBTTL	** THE BOOT MACRO **

.MACRO	BOOT	DEV,DEVCLU,DEVCSR,RC,WC,TTL,TRP4,MMUVAL,GPK		;028
.SBTTL	TTL (B$'DEV'BO)
.LIST

B$'DEV'BO:				;NON-GLOBAL TAG
.NLIST
BOOT	= .
.IF	NB	<GPK>							;028
	 HALT			;HALT required for GPK boot		;028
.IFF									;028
	 NOP			;NOP REQUIRED FOR BOOT
.ENDC									;028
	 BR	DEV'SET		;GO DO SETUP AND RELOCATION CODE
.IF	B	<TRP4>
	 .WORD	6,HALT		;IF TRAP TO  4, HALT @  6 W/ 10 IN LIGHTS
.IFF
	 .WORD	TRP4-BOOT,HALT ;IF TRAP TO 4, GO TO TRP4
.ENDC
	 .WORD	12,HALT		;IF TRAP TO 10, HALT @ 12 W/ 14 IN LIGHTS
CLUSTR	= .
	 .WORD	DEVCLU		; 14 CLUSTER SIZE
CSR	= .
	 .WORD	DEVCSR		; 16 CSR BASE
DEVNAM	= .
	 .WORD	"DEV		; 20 DEVICE NAME
GOXFER	= .
	 JMP	@(PC)+		; 22 JUMP TO START ADDRESS
XFER	= .
	 .WORD	0		; 24 TRANSFER ADDRESS (SET BY HOOK)
UNIT02	= .
	 .BYTE	0		; 26 UNIT # IN BITS <2:0> (SET BY BOOT)	;033
FLAGS	= .
	 .BYTE	0		; 27 Flags (definitions are in INIDFN)	;033
.IF	B	<MMUVAL>
UNITNO	= .
	 .WORD	0		; 30 UNIT # IN BITS FOR CSR (SET BY BOOT)
.IFF
BUFMMU	= .
	 .WORD	MMUVAL		; 30 MMU address of start of bootstrap
.ENDC
	 .BYTE	RC,WC		; 32 READ AND WRITE CODES
FCODE	= .
	 .WORD	RC		; 34 FUNCTION CODE: READ
SPFUN	= .
BLKNUM	= .
	 .WORD	0,0		; 36-40 Block number to read, also spec func.
MEMADR	= .
	 .WORD	0,0		; 42-44 Memory address to read into
PARM	= .
WCNT	= .
	 .WORD	0		; 46 Word count, also spec function parameter
RESET	= .			; 50 Do a device reset
READ	= .+2			; 52 Do a single transfer
SPEC	= .+4			; 54 Do a magtape special function
.ENDM	BOOT


.MACRO	EBOOT	DEV
$$$$$$	=	.-BOOT
.IRP	N,<\$$$$$$>
.SBTTL	Bootstrap for DEV is N bytes long
.ENDR
.	=	WCNT
	.WORD	$$$$$$
.	=	BOOT+$$$$$$
.SBTTL
.ENDM	EBOOT


	BOOT	DK,1,177404,5,3,<RK11 BOOTSTRAP>

; Reset entry
.ASSUME	RESET EQ .
	BR	40$		;Device reset entry
; Read entry
.ASSUME	READ EQ .
	MOV	CSR,R0		;Get CSR address
	MOV	MEMADR+2,R5	;Get high order memory address
	ASH	#4,R5		;Shift them into position for RKCS
	BIS	FCODE,R5	;R5 = COMMAND WITH ADDR<17:16>
	ADD	#RKDA,R0	;R0 -> RKDA DISK ADDRESS
	CLR	R2		;CLEAR FOR DIVIDE
	MOV	BLKNUM,R3	;Get block number
	DIV	#12.,R2		;12 SECTORS/TRACK
	MOV	R3,(R0)		;SET SECTOR NUMBER IN DISK ADDRESS
	ASH	#4,R2		;SHIFT TRACK NUMBER INTO POSITION
	BIS	R2,(R0)		;AND ADD TO DISK ADDRESS
	ADD	UNITNO,(R0)	;AND ADD IN UNIT NUMBER (SETS C=0)
	MOV	MEMADR,-(R0)	;Set memory address
	MOV	WCNT,-(R0)	;WORD COUNT
	NEG	(R0)		;Now negative word count
10$:	MOV	R5,-(R0)	;SET FUNCTION, ADDR<17:16>, AND GO
20$:	BIT	#100200,(R0)	;WAIT FOR READY AND/OR ERROR
	BEQ	20$
	BMI	30$		;Error, exit with failure
	TST	(PC)+		;Indicate ok
30$:	SEC			;Indicate error
	RETURN			;Done!!

40$:	MOV	CSR,R0		;POINT TO CONTROL & STATUS
50$:	BIT	#100200,(R0)	;WAIT FOR CONTROLLER READY
	BEQ	50$		; BEFORE CLEARING THE DEVICE
	MOV	#1,(R0)		;RESET THE RK CONTROLLER
60$:	BIT	#100200,(R0)	;WAIT FOR READY CONTROLLER
	BEQ	60$		;NOT READY YET
	BMI	30$		;Error, indicate that
	CLC			;Indicate success
	RETURN			;Done

; Boot entry point (from hardware boot)

	BOOTID	DKSET		;Define boot ID area			;004

	MOV	CSR,R1		;POINT TO CSR
	MOV	6(R1),R1	;RKDA CONTAINS THE UNIT BITS
	BIC	#017777,R1	;EXTRACT THEM
	MOV	R1,UNITNO	;SAVE IN CORRECT POSITION
	ASL	R1		;ROTATE INTO BITS 0-2
	ROL	R1
	ROL	R1
	ROL	R1
	MOVB	R1,UNIT02	;Save that for INIT.			;033

	EBOOT	DK


	BOOT	DL,1,174400,14-6,12-6,<RL01 BOOTSTRAP>

.ENABL	LSB

; Reset entry
.ASSUME	RESET EQ .
	BR	100$		;Device reset entry point
; Read entry
.ASSUME	READ EQ .
	MOV	CSR,R0		;Get CSR address
;
; RLs have the annoying "feature" of not being able to read across tracks.
; Therefore we do some additional kludgery here to help out the poor thing.
;
10$:	MOV	BLKNUM,R3	;Pick up block number
	CLR	R2
	MOV	#20.,R4		;Number of blocks per track
	DIV	R4,R2		;R2 = CYLINDER & TRACK; R3 = SECTOR IN TRACK
20$:	SUB	R3,R4		;Get number of blocks remaining on track
	SWAB	R4		;Now number of words
	CMP	R4,WCNT		;Do we want that many?
	BLOS	30$		;Yes, so transfer one track's worth
	MOV	WCNT,R4		;Otherwise transfer only as much as desired
30$:	SUB	R4,WCNT		;Compute number of words left to do next time
	ASH	#6,R2		;POSITION CYLINDER & TRACK
	ASL	R3		;NOTE THAT ONE BLOCK TAKES 2 SECTORS
	BIS	R2,R3		;R3 = PHYSICAL ADDRESS
	MOV	CSR,R0		;POINT TO DISK CSR
	MOV	MEMADR+2,R5	;Get high order buffer address
	ASH	#4,R5		;Move it into place
	BIS	UNITNO,R5	;Insert unit number
	BIS	#10,R5		;MAKE A READ-HEADER COMMAND
	TST	(R0)+		;Adjust the CSR pointer
40$:	MOV	R5,-(R0)	;ISSUE READ-HEADER COMMAND
50$:	TSTB	(R0)		;CONTROLLER READY?
	BPL	50$		;WAIT FOR READY
	TST	(R0)+		;ANY ERROR?
	BMI	40$		;YES, RETRY THE READ-HEADER
	MOV	MEMADR,(R0)+	;Set RLBA
	TST	(R0)+		;Skip RLDA
	MOV	(R0),-(R0)	;MOVE CURRENT ADDR IN RLMP TO RLDA
	BIC	#177,(R0)	;MASK TO CURRENT CYLINDER
	BIC	#100,R2		;MASK TO DESIRED CYLINDER
	SUB	R2,(R0)		;FORM (CURRENT-DESIRED)
	BHIS	60$		;SKIP IF DESIRED <= CURRENT
	NEG	(R0)		;DESIRED > CURRENT, TAKE ABSOLUTE VALUE
	BIS	#4,(R0)		;INDICATE STEPPING TOWARD HIGHER CYLINDERS
60$:	BIT	#100,R3		;COPY DESIRED HEAD
	BEQ	70$
	BIS	#20,(R0)	;BUT IN A DIFFERENT POSITION!
70$:	INC	(R0)		;SET BIT FOR A DIFFERENCE WORD
				; 10 <= R5 <= 1470, AND R5 IS EVEN
	TST	-(R5)		;R5 = R5+6-10 -- MAKE A SEEK COMMAND
	CALL	DLCMD2		;POINT TO RLCS, SEEK, WAIT, POINT TO RLBA
	BCS	90$		;Exit if error
	CMP	(R0)+,(R0)+	;SKIP RLBA, RLDA
	NEG	R4		;Make word count negative
	MOV	R4,(R0)		;Set it in the multipurpose register
	NEG	R4		;Fix up R4 for later use
	MOV	R3,-(R0)	;SET DESIRED DISK ADDRESS
	ADD	FCODE,R5	;SET DESIRED COMMAND
	CALL	DLCMD2		;POINT TO RLCS, READ/WRITE, WAIT
	BCS	90$		;Exit if error
	ASL	R4		;Convert word count to byte count
	ADD	R4,MEMADR	;Adjust buffer address
	ADC	MEMADR+2	;Doubly precisely
	TST	WCNT		;Did we do the whole transfer?
	BEQ	90$		;Yes
	ASH	#-9.,R4		;Back to block count
	ADD	R4,BLKNUM	;Adjust block number
	BR	10$		;Do another piece

DLCMD2:	CMP	-(R0),-(R0)	;BACK UP FROM RLDA TO RLCS
DLCMD:	MOV	R5,(R0)		;SET COMMAND AND UNIT NUMBER
80$:	TSTB	(R0)		;ENTER WITH R0 POINTING TO CSR
	BPL	80$		;WAIT FOR CONTROLLER READY
	TST	(R0)+		;ANY ERROR?
	BPL	90$		;No, return satisfied
	SEC			;Yes, indicate error
90$:	RETURN			;RETURN WITH R0 -> RLBA

100$:	MOV	CSR,R0		;GET CSR ADDRESS
110$:	TSTB	(R0)		;WAIT FOR CONTROLLER READY
	BPL	110$
	MOV	#13,RLDA(R0)	;SET UP FOR DRIVE RESET
	MOV	UNITNO,R5	;GET UNIT NUMBER (U = 0,400,1000,1400)
	CMP	(R5)+,(R5)+	;BUILD A GET-STATUS COMMAND (04)
	BR	DLCMD		;Do the I/O and leave

	BOOTID	DLSET,<U,Q>	;Boot ID area				;004

	MOV	@CSR,R0		;GET THE CSR CONTENTS
	BIC	#^C<3*400>,R0	;EXTRACT UNIT BITS
	MOV	R0,UNITNO	;SET UP FOR OUR USE
	SWAB	R0		;ALIGN IN BITS 0-1
	MOVB	R0,UNIT02	;Save unit number for rest of INIT.	;033

.DSABL	LSB

	EBOOT	DL


	BOOT	DM,1,177440,21,23,<RK06/07 BOOTSTRAP>

.ENABL	LSB

; Reset entry
.ASSUME	RESET EQ .
	BR	30$		;Device reset entry
; Read entry
.ASSUME	READ EQ .
	MOV	CSR,R0		;Point to the CSR
	MOV	MEMADR,4(R0)	;SET ADDR<15:00> IN CONTROLLER
	MOV	MEMADR+2,R5	;Get high order address
	SWAB	R5		;Move things into place
	MOV	BLKNUM,R3	;Get block number
	CLR	R2		;CLEAR FOR DIVIDE
	DIV	#3.*22.,R2	;FIND CYLINDER
	MOV	R2,RMDCY(R0)	;SET THE CYLINDER NUMBER
	CLR	R2		;CLEAR FOR DIVIDE
	DIV	#22.,R2		;GET SECTOR AND TRACK
	SWAB	R2		;PUT THE TRACK IN THE HIGH BYTE
	ADD	R2,R3		;ADD IN THE SECTOR ADDRESS
	MOV	R3,RMDA(R0)	;SET THE DEVICE ADDRESS
	MOV	WCNT,R4		;Get word count
	NEG	R4		;In proper form
	MOV	R4,RMWC(R0)	;Set it
	BIS	FCODE,R5	;R5 = ADDR<17:16> PLUS READ COMMAND
	BIS	RM07,R5		;SET THE RK06/07 BIT
	MOV	R5,(R0)		;SET THE COMMAND
10$:	BIT	#100200,(R0)	;IS THE COMMAND DONE?
	BEQ	10$		;NO. WAIT
	BMI	20$		;YES
	TST	(PC)+		;Clear carry, skip next
20$:	SEC			;Indicate error
	RETURN			;Done

30$:	MOV	CSR,R0		;GET CONTROL REGISTER ADDRESS
40$:	TSTB	(R0)		;WAIT FOR CONTROLLER READY
	BPL	40$
	MOV	#40,RMCS2(R0)	;CLEAR CONTROLLER AND INIT ALL DRIVES
	MOV	UNITNO,RMCS2(R0);SET THE UNIT NUMBER
	MOV	#RMACK,R2	;SET UP A PACK ACK TO SELECT THE DRIVE
	BIS	(PC)+,R2	;SET UP FOR PROPER UNIT
RM07:	 .WORD	0		;RK06/RK07 BIT
	MOV	R2,(R0)		;ISSUE THE COMMAND
50$:	TSTB	(R0)		;DID WE GET THE RESPONSE?
	BPL	50$		;NOT YET. WAIT
	RETURN			;Done

	BOOTID	DMSET		;Boot block ID area			;004

	MOV	CSR,R0		;GET A POINTER TO THE CONTROL REGISTER
	MOV	#RMACK,(R0)	;PACK ACK THE DRIVE
60$:	TSTB	(R0)		;DID WE GET THE RESPONSE
	BPL	60$		;NOT YET. WAIT
	MOV	RMCS2(R0),R2	;GET THE STATUS
	BIC	#177770,R2	;CLEAR UNWANTED BITS
	MOVB	R2,UNITNO	;SAVE THE UNIT NUMBER
	MOVB	R2,UNIT02	;ITS ALREADY IN THE RIGHT BITS
	MOV	RMDS(R0),R2	;GET THE DRIVE STATUS
	BIC	#177377,R2	;MASK TO DRIVE TYPE (RK06/RK07)
	ASH	#2,R2		;SHIFT THE RK07 BIT OVER
	MOV	R2,RM07		;SAVE IT

.DSABL	LSB

	EBOOT	DM		;SET UP FOR A RK06/07 BOOT


	BOOT	DP,2,176714,4,2,<RP11 BOOTSTRAP>

.ENABL	LSB

; Reset entry
.ASSUME	RESET EQ .
	BR	30$		;Device reset entry
; Read entry
.ASSUME	READ EQ .
	MOV	CSR,R0		;R0 -> CONTROLLER
	MOV	MEMADR,4(R0)	;SET UP ADDR<15:00> IN RPBA
	MOV	BLKNUM,R3	;Get low order block number
	MOV	BLKNUM+2,R2	; and high order
	MOV	MEMADR+2,R5	;Get high order memory address
	ASH	#4,R5		;Shift it into place
	BIS	UNITNO,R5	;ADD IN UNIT NUMBER IN HIGH BYTE
	MOV	R5,(R0)		;SELECT UNIT IN RP CONTROLLER
	BIS	FCODE,R5	;ADD FUNCTION CODE TO COMMAND
	DIV	#200.,R2	;200. SECTORS/CYL.
	MOV	R2,RPCA(R0)	;R2 = QUOTIENT = CYLINDER NUMBER
	CLR	R2		;CLEAR FOR DIVIDE
	DIV	#10.,R2		;10. SECTORS/TRACK
	SWAB	R2		;R2 = QUOTIENT = TRACK NUMBER, SET UP
	BIS	R3,R2		;ADD IN SECTOR NUMBER
	MOV	R2,RPDA(R0)	;SET UP TRACK AND SECTOR
	MOV	WCNT,R4		;Get word count
	NEG	R4		; -(word count)
	MOV	R4,RPWC(R0)	;  set it
	MOV	R5,(R0)		;SET UNIT, ADDR<17:16>, AND FUNCTION
				;(CAN'T SET UNIT & GO ON RP11C)
	INC	(R0)		;UNIT NOW SELECTED, SET GO TO READ
10$:	BIT	#100200,(R0)	;WAIT FOR READY AND/OR ERROR
	BEQ	10$
	BMI	20$		;ERROR!
	TST	(PC)+		;Indicate success, skip next
20$:	SEC			;Indicate error
	RETURN			;Done

30$:	MOV	CSR,R0		;R0 -> CONTROLLER
40$:	BIT	#100200,(R0)	;WAIT FOR CONTROLLER READY
	BEQ	40$		; BEFORE DOING THE RESET
	CLR	(R0)		;SET UP RESET FUNCTION, ADDR<17:16>=0
	INC	(R0)		;SET GO TO RESET RP CONTROLLER
50$:	BIT	#100200,(R0)	;WAIT FOR READY CONTROLLER
	BEQ	50$		;NOT READY YET
	RETURN			;Done

	BOOTID	DPSET		;Boot ID area				;004

	MOV	@CSR,R0		;GET CONTENTS OF RP CSR
	BIC	#174377,R0	;EXTRACT UNIT BITS
	MOV	R0,UNITNO	;SET UP FOR CSR USE
	SWAB	R0		;SHIFT TO BITS 0-2
	MOVB	R0,UNIT02	; and save unit for INIT.		;033

.DSABL	LSB

	EBOOT	DP


	BOOT	DU,4,172150,OP.RD,OP.WR,<MSCP BOOTSTRAP>,,<<B.BOOT/100>&1777>

.ASSUME	B.BOOT&77 EQ 0

.ENABL	LSB

; Reset entry
.ASSUME	RESET EQ .
	BR	DURSET		;Do the reset
; Read entry
.ASSUME	READ EQ .
	MOV	PC,R5		;Point to the packet buffers
	ADD	#BUFS-.,R5	; (PIC)
	MOV	#BUFSZ,R0	;Get size in words
10$:	CLR	(R5)+		;Clear them out
	SOB	R0,10$
	MOV	FCODE,CMD+P.OPCD ;Set operation to perform
	MOV	BLKNUM,CMD+P.LBN ;Set block number
	MOV	BLKNUM+2,CMD+P.LBN+2 ; and high order also
	MOV	WCNT,CMD+P.BCNT	;Copy word count
	ADD	WCNT,CMD+P.BCNT	; but make it a byte count
	MOV	MEMADR,CMD+P.BUFF ;Set address of buffer
	MOV	MEMADR+2,CMD+P.BUFF+2 ; and high order
	.BR	DUIO		;Do the transfer and exit

DUIO:	MOVB	UNIT02,CMD+P.UNIT ;Set in boot unit number.		;033
	MOV	#60.,RSP-4	;Set up length of response packet
	MOV	#36.,CMD-4	; and command packet (36 is enough for ONLINE)
	BIS	#OWN,RING+2	;Mark response packet as owned by UDA
	BIS	#OWN,RING+6	; same for commnd packet
	MOV	CSR,R0		;Get CSR pointer
	TST	(R0)+		;Prod the UDA into polling the ring
20$:	TST	(R0)		;Error?
	BMI	30$		;Yes
	TST	RING+2		;Response yet?
	BMI	20$		;No, wait some more
.ASSUME	OWN EQ 100000
	TST	RSP+P.STS	;Any errors?
	BNE	30$		;Yes, exit with error
.ASSUME	ST.SUC!SS.NOR EQ 0
	;CLC			;Indicate success
	RETURN			;Done

30$:	SEC			;Indicate error
	RETURN			; and leave

;+
;	Initialize the UDA through the 4 steps
;
;		Before any commands can be issued to a UDA controller,
;		the controller must first be brought online to establish
;		a virtual circut between controller and host. The ring
;		buffer address is supplied as a parameter during the
;		initialization. 
;-

DURSET:	MOV	BUFMMU,R2	;Get MMU address of ourselves
	MUL	#100,R2		;Now physical address in R2-R3
	MOV	PC,R5		;Point to rings and such
	ADD	#MSCP-.,R5	; (PIC)
	MOV	#MSCPSZ,R0	;# words to clear
40$:	CLR	(R5)+		;Clear something
	SOB	R0,40$
	ADD	(R5)+,R3	;Point to the rings
	ADC	R2		; double precision
	MOV	R3,STEP+2	;Set the pointer
	MOV	R2,STEP+4	; both parts
	MOV	#STEP1,R4	;SET R4 TO THE UDA'S 1ST STEP BIT INDICATOR
	MOV	CSR,R0		;GET THE CSR REGISTER
	MOV	R4,(R0)+	;WRITE INTO THE IP CSR TO INIT THE RA80
50$:	TST	(R0)		;CHECK THE SA CSR FOR AN ERROR
	BMI	30$		;Indicate error to caller if we get one
	BIT	(R0),R4		;IS THE UDA PORT READY FOR THIS STEP YET?
	BEQ	50$		;NO, LOOP UNTIL READY OR ERROR.
	MOV	(R5)+,(R0)	;READY, ISSUE THE NEXT INITIALIZE STEP CMND	
	ASL	R4		;  AND SHIFT TO NEXT STEP INDICATOR.
	BPL	50$		;LOOP UNTIL ALL 4 STEPS DONE.
60$:	ADD	(R5)+,R3	;Point to the response packet
	ADC	R2		; in 18-bit arithmetic
	MOV	PC,R0		;Set up for a PIC pointer
	ADD	#RING-.,R0	;Point to the rings
	MOV	R3,(R0)+	;Store low order address
	MOV	R2,(R0)+	; and high order
	ADD	(R5)+,R3	;Point to the command packet
	ADC	R2		; in 18-bit arithmetic
	MOV	R3,(R0)+	;Store low order address
	MOV	R2,(R0)+	; and high order
	MOVB	#OP.ONL,CMD+P.OPCD ;SET UNIT ONLINE CHARACTERISTICS
	BR	DUIO		;Perform the operation and exit

.DSABL	LSB

	BOOTID	DUSET,<UMSCP,QMSCP> ;Boot ID area			;004

	MOVB	R0,UNIT02	;Set up unit for rest of INIT.		;033
	MOV	R1,CSR		;Put the CSR address away, too.		;016
	BR	DUBEND		;Go to end of bootstrap			;019


; *** NOTE ***
; Items from here to the the end of the initialization table
; MUST be kept in order!

;+
;	DESCRIPTOR RINGS
;			-4	RSP ring interrupt transition flag
;			-2	CMD ring interrupt transition flag
;			RING:	RSP packet addr (LSB)
;			+2	RSP packet addr (MSB) and OWN bit
;			+4	CMD packet addr (LSB)
;			+6	CMD packet addr (MSB) and OWN bit
;-

MSCP:				;Start of MSCP comm area to be cleared
	.BLKW	2		;INTERRUPT STATUS WORDS FOR RINGS
RING:	.BLKW	4		;RESPONSE AND COMMAND RING DESCRIPTORS

BUFS:
	.BLKW	2		;RESPONSE PACKET ENVELOPE
RSP:	.BLKB	60.		;RESPONSE PACKET AREA
	.BLKW	2		;COMMAND  PACKET ENVELOPE
CMD:	.BLKB	36.		;COMMAND  PACKET AREA

MSCPSZ	=	<.-MSCP>/2
BUFSZ	=	<.-BUFS>/2

;+
;	Initialize and control table for UDA
;-

	.WORD	RING-BOOT	;Offset to rings, for DURSET

STEP:	.WORD	100000		;RING SIZES DEFAULT TO LENGTH 1
	.WORD	0		;LOW  ORDER DESC RING'S ADDRESS
	.WORD	0		;HIGH ORDER DESC RING'S ADDRESS
	.WORD	GO		;GO BIT

	.WORD	RSP-RING	;Offset from ring to response
	.WORD	CMD-RSP		;Offset from response to command

; ** END of ordering requirement

DUBEND:	EBOOT	DU							;019


	BOOT	DZ,1,174200,100,160,<RX50 [GPK] BOOTSTRAP>,,,GPK	;028+

.ENABL	LSB

; Reset entry
.ASSUME	RESET EQ .
	BR	60$		;Device reset entry
; Read entry
.ASSUME	READ EQ .
	MOV	CSR,R0		;Get CSR address
	MOVB	MEMADR+2,R4	;Get MSB of memory address
	MOV	MEMADR,R5	;Get LSB of memory address
	ASHC	#-6,R4		;Shift to get MMU in R5
	MOV	MEMADR,R4	;Get LSB of memory address again
	BIC	#177700,R4	;  Clear off all but last sliver
	BIS	#100000,R4	;    Set Page address to APR4.
	PUSH	<@#MMUSR0,@#KISAR0+10,R1> ;Save some stuff
10$:	MOV	R5,@#KISAR0+10	;MAP requestor's HOST BUFFER address in APR4
	CALL	100$		;Make sure it's ready
	BCS	90$		;Quit if error
	BIT	#4,RX5CS3(R0)	;Is it ready?
	BEQ	10$		;No, wait	
	MOV	WCNT,R2		;Get the WORD COUNT for this chunk,
	ASL	R2		;  RX50  BYTE COUNT.
	MOV	FCODE,R1	;Get the requested FUNCTION code
	MOV	#1,@#MMUSR0	;Turn on memory management
	CMP	R1,#160		;WRITE sector?
	BNE	30$		;  No, then READ sector.
	MOV	SP,RX5CA(R0)	;Now tell the wimp to get ready
	CMP	#512.,R2	;Is write greater than 1 sector?
	BHIS	20$		;  No,  set-up for requested count
	MOV	#512.,R2	;  Yes, set-up for 1 sector only
20$:	MOVB	(R4)+,RX5FB(R0)	;Move another byte into RX50's internal buffer
	SOB	R2,20$		;Only R2 bytes to go...
30$:	CLR	R2		;Get MSB of BLOCK number
	MOV	BLKNUM,R3	;Get LSB of BLOCK number
	DIV	#10.,R2		;Divide for: R2=TRACK, R3=sector (0-9.)
	CMP	#4,R3		;  Set C (BLO=BCS) for 5 <= sector <= 9.
	ROL	R3		;  Sector *2 (+1 if C) = [2:1] interleave
	ADD	R2,R3		;  Adjust for a 3 sector skew between
	ADD	R2,R3		;    tracks by adding track *2. (R3/10. below)
	INC	R2		;Don't use track zero, offset everything by 1
	CMP	#79.,R2		;  Is track beyond the end of disk surface?
	BHIS	40$		;    No, no wrap-around (BHIS=BCC)
	ADD	#-80.,R2	;    Yes, adjust to track 0 (C=1 if side 2).
40$:	MOV	UNITNO,-(SP)	;Get physical unit number *2 (bits [2:1])
;	ADC	(SP)		;  + side (for double sided RX'2)
	BISB	(SP)+,R1	;Merge the unit and side with RX50 function
	MOVB	R1,RX5CS0(R0)	;Load the requested function, unit and side
	MOVB	R2,RX5CS1(R0)	;Load the physical track
	CLR	R2		;Clear for divide
	DIV	#10.,R2		;Determine interleave skew for R3
	INC	R3		;LBN 0-4 maps SEC 1-9. LBN 5-9 maps SEC 2-10.
	MOVB	R3,RX5CS2(R0)	;Load desired sector [1 - 10.]
	MOVB	SP,RX5GO(R0)	;  and kick his nads into action.
	CALL	110$		;GO piss in the wind while this wimp works.
	BITB	#060,R1		;READ sector done?
	BNE	70$		;  No, WRITE sector done.
	MOV	SP,RX5CA(R0)	;Tell the wimp to get ready again
	MOV	WCNT,R2		;Get the WORD COUNT for this chunk just read,
	ASL	R2		;  RX50  BYTE COUNT.
	CMP	#512.,R2	;Is write greater than 1 sector?
	BHIS	50$		;  No,  set-up for requested count
	MOV	#512.,R2	;  Yes, set-up for 1 sector only
50$:	MOVB	RX5EB(R0),(R4)+	;Move another byte into the requestors buffer
	SOB	R2,50$		;Only R2 bytes to go...
	BR	70$		; and do the I/O finish

60$:	BR	100$		;Can't get there in 1 step...

; Boot entry point (from hardware boot)

	BOOTID	DZSET,<GPK>	;Define boot ID area
	BR	130$

70$:	ADD	#512.,MEMADR	;Update memory pointer
	ADC	MEMADR+2	; doubly precisely
	SUB	#256.,WCNT	;More left to do?
	BLOS	80$		;No, exit
	ADD	#1,BLKNUM	;Update control region for next logical sector
	;ADC	BLKNUM+2	;      (double precision)
	ADD	#512./100,R5	;Update MMU value by 1/4KW (256 words)
	SUB	#512.,R4	;Reset to original VIRTUAL address
	BR	10$		;Do the next sector.

80$:	CLR	WCNT		;Indate we updated MEMADR already
	;CLC			;Success (C=0 from CLR)
90$:	POP	<R1,@#KISAR0+10,@#MMUSR0> ;Restore what we saved
	RETURN			; and exit

100$:	MOV	CSR,R0			;Point to CONTROL & STATUS register
	MOV	UNITNO,RX5CS0(R0)	;Read status command
	MOV	SP,RX5GO(R0)		;Go.
110$:	CLC				;Assume success
	BITB	#RXDNE!RXERR,RX5CS0(R0)	;Spin on done bit or error
	BEQ	110$		   	;  to indicate "WIMP READY"
	BPL	120$			;Exit with success indicatator
	SEC				;Indicate error if "RXERR" is set
120$:	RETURN			;Done

130$:	MOV	#15.,R0		;Major loop count
140$:	SOB	R1,140$		;Delay a little bit
	SOB	R0,140$		; to allow I/O board selftests to finish
	CLR	@#MMUSR0	;Make sure MMU is disabled
	MOV	#1400,@#KISAR6	;Make sure we will be mapped
	MOV	#177600,@#KISAR6+2 ; not to mention the I/O page
	MOV	#1,R1		;Bit to test for presence in slot reg
	MOV	#SLOT0,R0	;CSR for slot 0
150$:	BIT	R1,@#OPRES	;Card present in this slot?
	BEQ	160$		;No
	CMPB	(R0),#GPK$DZ	;DZ controller here?
.ASSUME	RX5ID EQ 0
	BEQ	170$		;Yes
160$:	ADD	#SLOT1-SLOT0,R0	;No, advance CSR
	ASLB	R1		;Try next slot
	BPL	150$		; if any
	HALT			;DZ controller not found???

170$:	MOV	R0,CSR		;Save CSR
	MOVB	RX5CS0(R0),R1	;GET RX5CS0
	BIC	#^C<7>,R1	;MASK OUT UNIT BITS
	MOV	R1,UNITNO	;  in bits [2:1] and save for later
	ASR	R1		;MAKE INTO REAL UNIT NUMBER
	MOVB	R1,UNIT02	;  and save that for INIT.		;033

.DSABL	LSB

	EBOOT	DZ							;028-


	BOOT	DW,1,174000,040,060,<RD5x [GPK] BOOTSTRAP>,,,GPK	;029+

.ENABL	LSB

; Reset entry
.ASSUME	RESET EQ .
	BR	120$		;Device reset entry
; Read entry
.ASSUME	READ EQ .
	BR	10$		;Skip over the geometry data

; The following are set by the boot writer according to the geometry
; of the disk in question
SCYL:	.WORD	16.*4.		;Sectors/cylinder (64 for RD50/51)
STRK:	.WORD	16.		;Sectors/track (currently always 16)

10$:	MOV	CSR,R0		;Get CSR address
	MOVB	MEMADR+2,R4	;Get MSB of memory address
	MOV	MEMADR,R5	;Get LSB of memory address
	ASHC	#-6,R4		;Shift to get MMU in R5
	MOV	MEMADR,R4	;Get LSB of memory address again
	BIC	#177700,R4	;  Clear off all but last sliver
	BIS	#100000,R4	;    Set Page address to APR4.
	PUSH	<@#MMUSR0,@#KISAR0+10,R1> ;Save some stuff
20$:	MOV	R5,@#KISAR0+10	;MAP requestor's HOST BUFFER address in APR4
	CALL	120$		;Make sure it's ready
	MOV	BLKNUM,R3	;Get low order block
	MOV	BLKNUM+2,R2	; and high order
	ADD	#1,R3		;Add 1 to skip first sector
	ADC	R2		; in double precision
	DIV	SCYL,R2		;Compute cylinder number
	BIT	#RD50,RD5STS(R0) ;Is this an RD50?
	BEQ	30$		;No
	CMP	R2,#153.	;Is the cylinder number legal?
	BHIS	100$		;Yes, die
				;This bizarre check is here because the
				;RD50 can (allegedly) be physically damaged
				;by attempts to go beyond the highest cylinder
30$:	MOV	R2,RD5CYL(R0)	;Set it
	CLR	R2		;Clear high order
	DIV	STRK,R2		;Track in R0, sector in R1
	MOV	R2,RD5TRK(R0)	;Set track
	MOV	R3,RD5SEC(R0)	; and sector
	MOV	FCODE,R1	;Get the requested FUNCTION code
	MOV	R1,RD5ST2(R0)	;Issue command
	MOV	WCNT,R2		;Get the WORD COUNT for this chunk
	CMP	R2,#256.	;More than one sector left?
	BLOS	40$		;No, do it
	MOV	#256.,R2	;Yes, do just one sector
40$:	MOV	#1,@#MMUSR0	;Turn on memory management
50$:	TST	RD5STS(R0) 	;Still busy?
	BMI	50$		;Yes
.ASSUME	RDBSY LT 0
	BIT	#RDERS,RD5ST2(R0) ;Error detected?
	BNE	100$		;Yes, give up
55$:	BITB	#RDDRQ!RDEND,RD5STS(R0) ;Op ended or DRQ?
	BEQ	55$		;Neither
	BPL	80$		;Op ended, done with sector
.ASSUME	RDDRQ EQ 200
	CMP	R1,#060		;WRITE sector?
	BNE	70$		;  No, then READ sector.
	CLR	R3		;Assume nothing more to write
	TST	R2		;True?
	BEQ	60$		;Yes
	MOV	(R4)+,R3	;No, so get the next word to be done
	DEC	R2		; and count it
60$:	MOV	R3,RD5DAT(R0)	;Move to the buffer
	BR	55$		;Look for more

	BOOTID	DWSET,<GPK>	;Define boot ID area
	BR	150$		;Jump to where setup really is

120$:	MOV	CSR,R0		;Point to CONTROL & STATUS register
130$:	TST	RD5STS(R0)	;Busy?
	BMI	130$		;Yes, wait
.ASSUME	RDBSY LT 0
	BIT	#RDERS,RD5ST2(R0) ;Error?
	BEQ	140$		;No, return C=0 from TST above		;030
	SEC			;Indicate error				;030
140$:	RETURN			;Done

70$:	MOV	RD5DAT(R0),R3	;Get next word
	TST	R2		;Do we care about it?
	BEQ	55$		;No, go look for more
	MOV	R3,(R4)+	;Store it
	DEC	R2		;Count down
	BR	55$		; and look for more

80$:	ADD	#512.,MEMADR	;Update memory pointer
	ADC	MEMADR+2	; doubly precisely
	SUB	#256.,WCNT	;More left to do?
	BLOS	90$		;No
	ADD	#1,BLKNUM	;Update control region for next logical sector
	ADC	BLKNUM+2	;      (double precision)
	ADD	#512./100,R5	;Update MMU value by 1/4KW (256 words)
	SUB	#512.,R4	;Reset to original VIRTUAL address
	BR	20$		;Do the next sector.

90$:	CLR	WCNT		;Indicate we updated MEMADR already
	;CLC			;C=0 from CLR above
	BR	110$		; and leave

100$:	SEC			;Indicate error
110$:	POP	<R1,@#KISAR0+10,@#MMUSR0> ;Restore what we saved
	RETURN			; and exit

; Boot entry point (from hardware boot)

150$:	MOV	#15.,R0		;Major loop count
160$:	SOB	R1,160$		;Delay a little bit
	SOB	R0,160$		; to allow I/O board selftests to finish
	CLR	@#MMUSR0	;Make sure MMU is disabled
	MOV	#1400,@#KISAR6	;Make sure we will be mapped
	MOV	#177600,@#KISAR6+2 ; not to mention the I/O page
	MOV	#1,R1		;Bit to test for presence in slot reg
	MOV	#SLOT0,R0	;CSR for slot 0
170$:	BIT	R1,@#OPRES	;Card present in this slot?
	BEQ	180$		;No
	CMPB	(R0),#GPK$DW	;DW controller here?
.ASSUME	RD5ID EQ 0
	BEQ	190$		;Yes
180$:	ADD	#SLOT1-SLOT0,R0	;No, advance CSR
	ASLB	R1		;Try next slot
	BPL	170$		; if any
	HALT			;DW controller not found???

190$:	MOV	R0,CSR		;Save CSR
	;CLR	UNITNO		;Unit = 0 always (done at assembly time)

.DSABL	LSB

	EBOOT	DW							;029-


.ENABL	LSB

;+
; THIS BOOTSTRAP IS FOR RP04/5/6/7/RM02/3/5/80 DRIVES.  RSTS MAY KNOW THESE
; DRIVES AS DR: OR DB: -- WHOEVER WRITES A BOOT MUST CHOSE ON THE BASIS
; OF DEVICE TYPE.  THE REASON IS THAT THIS BOOT AND THE RM03 BOOT LOOK
; FOR THE FIRST RH CONTROLLER SELECTING A UNIT OF THE CORRECT TYPE.
; ** NOTE **
;	THIS BOOTSTRAP HAS BEEN EXPLICITLY MODIFIED TO ACCOMODATE THE RM80
;	DISK DRIVE, WHICH USES SKIP-SECTORING TO REDUCE THE NUMBER OF
;	USER-VISIBLE BAD BLOCKS. SINCE THIS TECHNIQUE IMPLIES TRANSFER
;	ERRORS, THE ERROR HANDLING HAS BEEN MODIFIED TO CHECK FOR A
;	SKIP-SECTOR ERROR BEFORE HALTING (BOOTSTRAPS NORMALLY HALT ON ANY
;	ERROR). ANY ERROR OTHER THAN A SKIP-SECTOR ERROR WILL CAUSE THE
;	ERROR HANDLER TO HALT AT THE NORMAL HALT LOCATION.
;-

B$DRBO:				;Used for RR and RB both

	BOOT	DB,4,176700,71,61,<RP04/5/6/7/RM02/3/5/80 BOOTSTRAP>

; Reset entry
.ASSUME	RESET EQ .
	BR	30$
; Read entry
.ASSUME	READ EQ .
	BR	5$		;Boot writer expects geometry data to follow

.ASSUME	. EQ READ+2
SECCYL:	.WORD	0		;Sectors/cylinder, set by boot writer
SECTRK:	.WORD	0		;Sectors/track, set by boot writer

5$:	MOV	CSR,R0		;Point to the CSR
	ADD	#RHCS2,R0	; now to CSR2
	MOV	BLKNUM,R3	;Get low order block number
	MOV	BLKNUM+2,R2	; and high order
	DIV	SECCYL,R2	;Compute cylinder, sector in cylinder
	MOV	R2,RBDC-RHCS2(R0) ;SAVE CYLINDER NUMBER
	CLR	R2		;CLEAR FOR DIVIDE
	DIV	SECTRK,R2	;Compute track and sector
	SWAB	R2		;PUT TRACK # IN BITS 8-13
	ADD	R2,R3		;ADD IN SECTOR ADDRESS
	MOV	R3,-(R0)	;INSERT DISK ADDRESS IN RBDA
10$:	MOV	MEMADR,-(R0)	;MEMORY ADDRESS<15:00>
	MOV	WCNT,-(R0)	;Word count
	NEG	(R0)		; now negative for controller happiness
	MOVB	MEMADR+2,R5	;Get high order address
	SWAB	R5		;Move it into the right spot
	BISB	FCODE,R5	;Load function code
	MOV	R5,-(R0)	;Now issue the function
20$:	BIT	#100200,(R0)	;Done or error?
	BEQ	20$		;Neither
	BMI	SKPSEC		;Error, check it out
	CLC			;Indicate success
	RETURN			;Leave

;+
; SPECIAL RM80 SKIP-SECTOR HANDLING ROUTINE
;-
SKPSEC:	BIT	#RBHCE!RBHCRC,RHER(R0) ;IS THE HEADER RELIABLE?
	BNE	FATAL		;NYET
	BIT	#40,RBER3(R0)	;WAS IT A SKIP-SECTOR ERROR?
	BEQ	FATAL		;NOPE, SO REALLY DIE
	MOV	RHWC(R0),R3	;COPY - APPROX # WORDS LEFT TO XFER (-WC)
	MOV	#140011,(R0)	;"DRIVE CLEAR" GETS RID OF SSE FLAG ET. AL.
	MOV	#15000,RBOF(R0)	;22 BIT MODE, ECC INHIBIT, SSE INHIBIT 
	ADD	WCNT,R3		;Compute # words transferred (OLD + -#LEFT)
	BIC	#377,R3		;ROUND DOWN TO NEAREST BLOCK MULTIPLE OF WORDS
	MOV	R3,R2		;COPY # WORDS XFER'D (+)
	ASL	R2		;TRANSFORM IT TO BYTES FOR NEW MEMORY ADDRESS
	SUB	R3,WCNT		;Compute # words left to do
	ADD	R2,MEMADR	;Adjust memory address
	ADC	MEMADR+2	; double precision, of course
	ADD	#RHBA+2,R0	;Point beyond the bus address register
	BR	10$		;Now set up the rest of the transfer

FATAL:	SEC			;Indicate error
	RETURN			;Back to caller

; Reset routine

30$:	MOV	CSR,R0		;Point to the CSR
	TSTB	(R0)		;WAIT FOR CONTROLLER READY
	BPL	30$
	ADD	#RHCS2,R0	;POINT TO CSR2
	MOV	#RHCLR,(R0)	;CLEAR OUT CONTROL
	;CLC			;C=0 FROM 'ADD' ABOVE
	ADC	RHAS-RHCS2(R0)	;CLEAR ANY ACTIVE ATTN LINE
	MOV	UNITNO,(R0)	;SELECT THE CORRECT DRIVE
	MOVB	#23,RHCS1-RHCS2(R0) ;PACK ACK TO CLEAR THE DRIVE JUST IN CASE
	MOV	#014000,RBOF-RHCS2(R0) ;PDP-11 MODE, ECC INHIBIT
	RETURN			;That's it


	BOOTID	DBSET		;Boot ID area				;004

	CMP	#176300,R1	;Are we on the second controller?	;016
	BEQ	50$		;Yup, use the secondary CSR address	;016
	MOV	#176700,R1	;Nope, put primary address in instead.	;016
50$:	MOV	R1,R0		;In any case, put CSR into R0.		;016
	MOV	PC,SP		;Set up a small stack for the trap 4 case
60$:	TSTB	(R0)		;Is the controller ready?		;016
	BPL	60$		;Wait 'till it is.			;016
	BR	DBAOK		;Yup, go get unit number		;016

; The following code checks the "Disk Address" register for a value of 1,
; which should mean "block 0 was just read in.  It would be nice to also
; check the current cylinger register; unfortunately, there is no such
; thing on the RM02/3/5/80/RP07 disks.

;??? it seems not to work!
;?	CMP	#1,RBDA(R0)	;IT'S READY, BUT DID WE JUST READ BLOCK 0?
;?	BNE	DBTRAP		;DOESN'T SEEM LIKE IT, SO TRY OTHER CONTROLLER
DBAOK:	MOV	R0,CSR		;SAVE RBCSR ADDRESS
	MOV	RHCS2(R0),R1	;RBCS2 CONTAINS UNIT BITS (MAY TRAP)
	BIC	#177770,R1	;EXTRACT THE UNIT NUMBER
	MOV	R1,UNITNO	;SAVE IT
	MOVB	R1,UNIT02	;It's already in the right bits.	;033

	EBOOT	DB

.DSABL	LSB

	.WORD	0			;END OF DISK BOOTSTRAPS



;021+
;
; Tape boot drivers
;
; Entry into these drivers is from the secondary boot.
; Registers passed are R0 (Unit #) and R1 (CSR)
;
;-

.SBTTL	TMSCP BOOTSTRAP
.ENABL	LSB

	BOOT	MU,1600.,174500,OP.RD,OP.WR,<TMSCP Bootstrap>,,<<B.BOOT/100>&1777>

.EQUATE	OP.REP	45			;Reposition command		;021
.EQUATE	P.RECC	14			;Record/Object count offset	;021
.EQUATE	MD.RWD	2			;Rewind modifier for repo	;021
.EQUATE	ST.TM	16			;Tape Mark Encountered status	;021
.EQUATE	ST.RDT	20			;Record Data Truncated status	;021

; Reset entry
.ASSUME	RESET EQ .
	BR	MURSET			;OFF TO COMMON [T]MSCP CODE...	;021
; Read entry
.ASSUME	READ EQ .
	BR	30$			;OFF TO COMMON [T]MSCP CODE...
; Spec entry
.ASSUME	SPEC EQ .
	CALL	10$		;Clear out the packet buffers		;021
	MOV	#OP.REP,TCMD+P.OPCD	;All specs are repositions	;021
	MOV	WCNT,R2		;Pick up record count			;021
;	CLR	TCMD+P.MOD	;Assume its a skip forward...		;021
	ROR	SPFUN		;..Rewind (3) or Skip (4) ?		;021
	BCC	40$		;Skip forward it is, go do it		;021
	MOV	#MD.RWD,TCMD+P.MOD ;Set rewind command modifier		;021
	BR	45$		;Go do it...				;021

10$:	MOV	PC,R5		;Point to the packet buffers		;021
	ADD	#TBUFS-.,R5	; (PIC)
	MOV	#TBUFSZ,R0	;Get size in words
20$:	CLR	(R5)+		;Clear them out
	SOB	R0,20$
	RETURN			;Done					;021

30$:	CALL	10$		;Clear out the packet buffers		;021
	MOV	FCODE,TCMD+P.OPCD ;Set operation to perform (Read only)
	MOV	WCNT,R2		;Get word count for transfer		;021
	CMP	R2,#256.	;Too much to do at once?		;021
	BLE	35$		;No, use it				;021
	MOV	#256.,R2	;Do one block at a time			;021
35$:	MOV	MEMADR,TCMD+P.BUFF ;Set address of buffer
	MOV	MEMADR+2,TCMD+P.BUFF+2 ; and high order
	CALL	MUIO		;Read in a record			;021
	BCS	37$		;Error during read, quit		;021
	CMP	R2,TRSP+P.BCNT	;Check byte count			;021
	BNE	30$		;Must have read DOS label, re-read	;021
	ADD	R2,MEMADR	;Adjust buffer address			;021
	ADC	MEMADR+2	;...high order too			;021
	ASR	R2		;Change byte count back to word count	;021
	SUB	R2,WCNT		;Adjust word count			;021
	BGT	30$		;More to transfer, do it		;021
	CLC			;Signify success			;021
37$:	RETURN			;Done					;021

;+
;	Initialize the controller through the 4 steps
;
;		Before any commands can be issued to a TMSCP controller,
;		the controller must first be brought online to establish
;		a virtual circut between controller and host. The ring
;		buffer address is supplied as a parameter during the
;		initialization. 
;-

MURSET:	MOV	BUFMMU,R2	;Get MMU address of ourselves		;021
	MUL	#100,R2		;Now physical address in R2-R3
	MOV	PC,R5		;Point to rings and such
	ADD	#TMSCP-.,R5	; (PIC)
	MOV	#TMCPSZ,R0	;# words to clear
70$:	CLR	(R5)+		;Clear something
	SOB	R0,70$
	ADD	(R5)+,R3	;Point to the rings
	ADC	R2		; double precision
	MOV	R3,TSTEP+2	;Set the pointer
	MOV	R2,TSTEP+4	; both parts
	MOV	#STEP1,R4	;SET R4 TO THE 1ST STEP BIT INDICATOR
	MOV	CSR,R0		;GET THE CSR REGISTER
	MOV	R4,(R0)+	;WRITE INTO THE IP CSR TO INIT THE CONTROLLER
80$:	TST	(R0)		;CHECK THE SA CSR FOR AN ERROR
	BMI	55$		;Indicate error to caller if we get one
	BIT	(R0),R4		;IS THE PORT READY FOR THIS STEP YET?
	BEQ	80$		;NO, LOOP UNTIL READY OR ERROR.
	MOV	(R5)+,(R0)	;READY, ISSUE THE NEXT INITIALIZE STEP CMND	
	ASL	R4		;  AND SHIFT TO NEXT STEP INDICATOR.
	BPL	80$		;LOOP UNTIL ALL 4 STEPS DONE.
90$:	ADD	(R5)+,R3	;Point to the response packet
	ADC	R2		; in 18-bit arithmetic
	MOV	PC,R0		;Set up for a PIC pointer
	ADD	#TRING-.,R0	;Point to the rings
	MOV	R3,(R0)+	;Store low order address
	MOV	R2,(R0)+	; and high order
	ADD	(R5)+,R3	;Point to the command packet
	ADC	R2		; in 18-bit arithmetic
	MOV	R3,(R0)+	;Store low order address
	MOV	R2,(R0)+	; and high order
	MOVB	#OP.ONL,TCMD+P.OPCD ;SET UNIT ONLINE CHARACTERISTICS
	BR	45$		;Perform the operation and exit

MUSET:	BR	MUBEND		;Go to end of boot code			;021

MUIO:	ASL	R2		;Change word count into byte count	;021
40$:	MOV	R2,TCMD+P.BCNT	;Store byte/record count		;021
.ASSUME	P.BCNT	EQ P.RECC
45$:	MOVB	UNIT02,TCMD+P.UNIT ;Set in boot unit number.		;033
	INCB	TCMD-1		;Set tape connection ID			;021
;+
; NOTE:	An INCB was used above to help save every word possible in
;	the bootstrap.  There were two assumptions made here:
;
;	1) The packets are cleared out before every command
;	2) Tape connection ID is a 1
;-
	BIS	#MD.CSE,TCMD+P.MOD ;Clear any previous serious exception ;021
	MOV	#60.,TRSP-4	;Set up length of response packet
	MOV	#36.,TCMD-4	; and command packet (36 is enough for ONLINE)
	BIS	#OWN,TRING+2	;Mark response packet as owned by controller
	BIS	#OWN,TRING+6	; same for commnd packet
	MOV	CSR,R0		;Get CSR pointer
	TST	(R0)+		;Prod the port into polling the ring
50$:	TST	(R0)		;Error?
	BMI	55$		;Yes
	TST	TRING+2		;Response yet?
	BMI	50$		;No, wait some more
.ASSUME	OWN EQ 100000
	MOV	TRSP+P.STS,R0	;Any errors?
	BEQ	60$		;No, exit with C clear for success	;021
.ASSUME	ST.SUC!SS.NOR EQ 0
	CMP	R0,#ST.TM	;Error, was it Tape Mark Encountered?	;021
	BEQ	60$		;Yes, exit with C clear for success	;021
	CMP	R0,#ST.RDT	;No, how about Record Data Truncated?	;021
	BEQ	60$		;Yes, exit with C clear for success	;021
55$:	SEC			;Indicate error
60$:	RETURN			; and leave

; *** NOTE ***
; Items from here to the the end of the initialization table
; MUST be kept in order!

;+
;	DESCRIPTOR RINGS
;			-4	RSP ring interrupt transition flag
;			-2	CMD ring interrupt transition flag
;			RING:	RSP packet addr (LSB)
;			+2	RSP packet addr (MSB) and OWN bit
;			+4	CMD packet addr (LSB)
;			+6	CMD packet addr (MSB) and OWN bit
;-

TMSCP:				;Start of TMSCP comm area to be cleared
	.BLKW	2		;INTERRUPT STATUS WORDS FOR RINGS
TRING:	.BLKW	4		;RESPONSE AND COMMAND RING DESCRIPTORS

TBUFS:
	.BLKW	2		;RESPONSE PACKET ENVELOPE
TRSP:	.BLKB	60.		;RESPONSE PACKET AREA
	.BLKW	2		;COMMAND  PACKET ENVELOPE
TCMD:	.BLKB	36.		;COMMAND  PACKET AREA

TMCPSZ	=	<.-TMSCP>/2
TBUFSZ	=	<.-TBUFS>/2

;+
;	Initialize and control table for TMSCP
;-

	.WORD	TRING-BOOT	;Offset to rings, for DURSET

TSTEP:	.WORD	100000		;RING SIZES DEFAULT TO LENGTH 1
	.WORD	0		;LOW  ORDER DESC RING'S ADDRESS
	.WORD	0		;HIGH ORDER DESC RING'S ADDRESS
	.WORD	GO		;GO BIT

	.WORD	TRSP-TRING	;Offset from ring to response
	.WORD	TCMD-TRSP	;Offset from response to command

; ** END of ordering requirement

.IIF GT	<400-<.-BOOT>>	.BLKB0	<400-<.-BOOT>>,NOP	;Ensure high stack

MUBEND:	EBOOT	MU

.DSABL	LSB


.SBTTL	MAGTAPE BOOTSTRAP FOR TS11/TK25/TU80/TS05
.ENABL	LSB

	BOOT	MS,1600.,172522,0,0,<TS11 Protocol Magtape Boot>

; Reset entry
.ASSUME	RESET EQ .
	BR	MSRSET		;Reset TS11
; Read entry
.ASSUME	READ EQ .
	BR	10$
; Spec entry
.ASSUME	SPEC EQ .
MSSPEC:	ROR	SPFUN		;Function 3(rewind) or 4(skip?)
	BCC	80$		;Skip
	CALL	TS11DO,R5,142010 ;REWIND (MAY ALREADY BE AT BOT)
	BR	90$		;Check the result

10$:	MOV	CSR,R0		;Point to CSR
	MOV	#256.,R2	;Assume we'll do 256 words
	CMP	R2,WCNT		;Do we want that much?
	BLOS	20$		;Yes
	MOV	WCNT,R2		;No, so do only whatever is desired
20$:	MOV	MEMADR,R3	;Get low order address
	CALL	MSIO		;Do I/O on the TS11
	SUB	#256.,WCNT	;One block done, any left?
	BLOS	70$		;No
	ADD	#512.,MEMADR	;Yes, update memory address
	ADC	MEMADR+2	; (double precision)
	BR	10$		;Do another block


; Note: below we spin our wheels for a while to give the TS11 controller(s)
; time to finish their microdiagnostics.  They don't bother to give us
; any sensible status until then, so we just burn up plenty of time to
; give them a chance.  The minor loop below uses R1 which is not initialized
; first (saves a word) but after 1 time through the loop it will be 0 so
; we'll go full circle around 16 bits except possibly the first of the
; 50 times.
MSRSET:	MOV	#50,R2		;Major loop run-around counter
30$:	SOB	R1,30$		;Loop a bit (wait for microdiagnostics to end)
	SOB	R2,30$		;Do some more circles if needed
35$:	TSTB	@CSR		;IS THE TS11 READY?
	BPL	35$		;NOPE, KEEP WAITING
	MOVPIC	#CHRBUF,R3	;Point to command buffer
	MOV	#20,R2		;Set byte count for message buffer
	MOV	R3,(R3)		;we're saving words and setting TSBUF
	ADD	R2,(R3)		;into CHRBUF in a PIC way.
.ASSUME	TSBUF EQ CHRBUF+20
	CALL	TS11DO,R5,140004 ;SET CHARACTERISTICS
	RETURN			;Done

MSIO:	ASL	R2		;Convert word count to byte count
40$:	CALL	TS11DO,R5,140001 ;Read next record
	BPL	70$		;Success, leave
50$:	MOVB	TSBUF+7,R1	;Get XSR0 high byte
	CMPB	R1,#20		;Long record?
	BEQ	70$		;Yes, assume it's ok
	ROLB	R1		;Ignore tape mark, check for short record
	BMI	40$		;It was, so re-read to get a full record
60$:	COM	(SP)+		;Pop return, indicate error
	RETURN			;Ok

70$:	TST	(PC)+		;Indicate success
120$:	SEC			;Indicate failure
	RETURN			;Done


80$:	MOV	PARM,R3		;Pick up parameter
	CALL	TS11DO,R5,140010 ;Do a skip records
90$:	BIT	#12,(R0)	;CHECK THIS OP'S RESULT
	BNE	120$		;ALLOW TERM CLASS 0 OR 2 ONLY
	RETURN			;Done


MSSET:	BR	MSBEND		;To end of boot

TS11DO:	MOV	CSR,R0		;Pick up CSR pointer
	MOVPIC	#TSBUF+20,R4	;POINT TO COMMAND BUFFER (MULTIPLE OF 4)
	MOV	(R5)+,(R4)+	;SET FUNCTION
	MOV	R3,(R4)+	;BUFFER ADDRESS OR PARAMETER
	MOV	MEMADR+2,(R4)+	;Set high order address
	MOV	R2,(R4)		;Set byte count
	SUB	#6,R4		;POINT BACK TO START OF COMMAND
	MOV	R4,-2(R0)	;SET COMMAND PACKET ADDRESS
150$:	BIT	#100200,(R0)	;Ready or error?
	BEQ	150$		;Neither, wait
	RETURN	R5		; AND RETURN




	.BLKB	<.-BOOT>&2	;Align to modulo 4 boundary
CHRBUF:	.WORD	0,0		;Point to status buffer
	.WORD	16.		;Buffer length (enough for TSV05 with XST4)
	.WORD	0,0		;Default characteristics (two words for TSV05)

.=CHRBUF+20
TSBUF:	.BLKB	40		;Message and command buffers

.ASSUME	<<TSBUF-BOOT>&3> EQ 0

.IIF GT	<400-<.-BOOT>>	.BLKB0	<400-<.-BOOT>>,NOP	;Ensure high stack

MSBEND:	EBOOT	MS

.DSABL	LSB


.SBTTL	MAGTAPE BOOTSTRAP FOR 1600 BPI TM02/TM03
.ENABL	LSB

	BOOT	MM,1600.,172440,0,0,<TM02/TM03 MAGTAPE BOOT>

; Reset entry
.ASSUME	RESET EQ .
	RETURN
; Read entry
.ASSUME	READ EQ .
	BR	10$
; Spec entry
.ASSUME	SPEC EQ .
	BR	MMSPC2

10$:	MOV	CSR,R0		;Point to CSR
	MOV	#256.,R2	;Assume we'll do 256 words
	CMP	R2,WCNT		;Do we want that much?
	BLOS	20$		;Yes
	MOV	WCNT,R2		;No, so do only whatever is desired
20$:	MOV	MEMADR,R3	;Get low order address
	CALL	MMIO2		;Do I/O on the TM02/TM03
	SUB	#256.,WCNT	;One block done, any left?
	BLOS	70$		;No
	ADD	#512.,MEMADR	;Yes, update memory address
	ADC	MEMADR+2	; (double precision)
	BR	10$		;Do another block

60$:	COM	(SP)+		;Pop return, indicate error
	RETURN			;Ok

70$:	CLC			;Indicate success
	RETURN			;Done


MMSPC2:	CALL	TUSET		;SET UP THE TU16			;009
	ROR	SPFUN		;Function 3(rewind) or 4(skip?)
	BCC	100$		;Skip
	MOV	#7,(R0)		;START A REWIND
	BR	110$		; and continue

100$:	MOV	PARM,MMFC(R0)	;Set frame count
	NEG	MMFC(R0)	; negate to satisfy the rules
	MOV	#31,(R0)	; Do the skip
110$:	TSTB	(R0)		;WAIT FOR CONTROLLER READY
	BPL	110$		;NOT YET
	TSTB	RHDS(R0)	;IS DRIVE READY IN RHDS?
	BPL	110$		;NO
	TSTB	RHCS2+1(R0)	;ANY CONTROL ERRORS?
	BNE	120$		;YES, DIE FAST
	BIT	#^C<MMFCE>,RHER(R0) ;All off except maybe frame count?
	BEQ	130$		;YUP, RETURN GOODNESS
120$:	SEC			;Indicate error
130$:	RETURN			;Done

MMSET:	BR	MMBEND

MMIO2:	NEG	R2		;Make negative word count
160$:	CALL	TUSET		;SET UP THE TU16
	CMP	(R0)+,(R0)+	;POINT TO MTBA
	MOV	R3,(R0)		;SET UP BUS ADDRESS
	MOV	MEMADR+2,R4	;Get high order address
	SWAB	R4		;Move into place
	BIS	#71,R4		;Insert function code
	MOV	R2,-(R0)	;Set it
	MOV	R4,-(R0)	;FUNCTION IS READ
170$:	CALL	110$		;WAIT FOR READY
	BCS	60$		;Exit to caller's caller if error
	TST	RHWC(R0)	;Read all we wanted?
	BNE	160$		;No, assume label or noise, read another block
	RETURN			;Done

TUSET:	MOV	CSR,R0		;Get CSR address
	TSTB	(R0)		;CONTROLLER READY?
	BPL	TUSET		;NO
	MOV	#40,RHCS2(R0)	;ISSUE CONTROLLER CLEAR
	MOVB	UNIT02,RHCS2(R0)	;Re-select unit.		;033
	MOV	UNITNO,MMTC(R0)	;Re-select formatter, slave, and density
	RETURN



.IIF GT	<400-<.-BOOT>>	.BLKB0	<400-<.-BOOT>>,NOP	;Ensure high stack

MMBEND:	TSTB	(R1)		;Controller ready?
	BPL	MMBEND		;Nope, not yet.
	MOV	MMTC(R1),R2	;Get formatter, slave, and density setting
	BIC	#^C<3767>,R2	;Isolate bits we need
	MOV	R2,UNITNO	;Save formatter/slave/density
	BIC	#^C<1400>,R2	;Check for 1600 BPI
	BEQ	300$		;Yes, so density word is correct
	MOV	#800.,CLUSTR	;Signal that drive is 800 BPI
300$:	EBOOT	MM

.DSABL	LSB


.SBTTL	MAGTAPE BOOTSTRAP FOR 800 BPI TM11/TS03
.ENABL	LSB

	BOOT	MT,800.,172522,0,0,<TS03/TM11 Magtape Bootstrap>

; Reset entry
.ASSUME	RESET EQ .
	RETURN			;Nothing to do
; Read entry
.ASSUME	READ EQ .
	BR	5$
; Spec entry
.ASSUME	SPEC EQ .
	BR	MTSPEC

5$:	MOV	CSR,R0		;Point to CSR
	MOV	#256.,R2	;Assume we'll do 256 words
	CMP	R2,WCNT		;Do we want that much?
	BLOS	10$		;Yes
	MOV	WCNT,R2		;No, so do only whatever is desired
10$:	NEG	R2		;Now negative for controller
	MOV	MEMADR+2,R3	;Get high order memory address
15$:	CALL	MTIO		;Do I/O on the TM11
	BNE	5$		;Not a full block read, do it again
	SUB	#256.,WCNT	;One block done, any left?
	BLOS	70$		;No
	ADD	#512.,MEMADR	;Yes, update memory address
	ADC	MEMADR+2	; (double precision)
	BR	5$		;Do another block

70$:	CLC			;Indicate success
	RETURN			;Done

MTSPEC:	MOV	CSR,R0		;Get CSR address
	CMP	SPFUN,#3	;Rewind?
	BNE	80$		;No, so it must be space forward
	CALL	TM11DO,R3,<60016> ;Do a rewind
60$:	SEC			;Assume failure
	BPL	70$		;Branch if OK
	BIT	#^C<MTEOF!177>, MTAS(R0) ;see if error was not EOF
	BEQ	70$		;was EOF, don't worry	
	RETURN			;Oh-oh, not EOF, go out crying

80$:	MOV	PARM,MTABRC(R0)	;Set skip count
	NEG	MTABRC(R0)	; in proper form
	CALL	TM11DO,R3,<60010> ;Do a skip
	BR	60$		;Check out the status

MTIO:	ASH	#4,R3		;High order address into the right bits
	BIS	#60002,R3	;Put in the function (read)
	MOV	R3,30$		;Set it
	ASL	R2		;Adjust word count to byte count
	MOV	R2,MTABRC(R0)	;Set the count
	MOV	MEMADR,MTACMA(R0) ;SET UP BUS ADDRESS
	CALL	TM11DO,R3	;Do the function
30$:	 .WORD	0
	BPL	35$		;No error, exit cleanly
	BIT 	#^C<MTRLE!177>, MTAS(R0) ;Error, was it Record Length long?
	BEQ	35$		;Yep, so we're okay, exit cleanly
	COM	(SP)+		;No, something BAD, Pop return, set carry
	RETURN			;to Caller's caller (usually BOOT mainline)

35$:	TST	MTABRC(R0)	;We're okay, check residual count,
	RETURN			;and return.

TM11DO:	CALL	90$,R3		;WAIT FOR TAPE UNIT READY
	MOV	UNITNO,R4	;COPY THE UNIT NUMBER
	BIS	(R3)+,R4	;INSERT THE COMMAND
	MOV	R4,(R0)		;SET THE FUNCTION
	INC	R4		;ADD THE GO BIT
	MOV	R4,(R0)		;SET FUNCTION AND GO
90$:	BIT	#MTSELR,MTAS(R0) ;SELECT REMOTE STILL ON?
	BEQ	100$		;NO, RETURN WITH ERROR
	BIT	#MTTUR,MTAS(R0)	;YES, TAPE UNIT READY?
	BEQ	90$		;NOT YET
100$:	BIT	#100200,(R0)	;WAIT FOR READY OR ERROR
	BEQ	100$
	RETURN	R3		;DONE, GO BACK

.IIF GT	<400-<.-BOOT>>	.BLKB0	<400-<.-BOOT>>,NOP	;Ensure high stack

MTSET:	MOV	(R1),UNITNO	;Get unit number
	BIC	#^C<7*400>,UNITNO	;Isolate unit number
	EBOOT	MT

.DSABL	LSB


.SBTTL	FINISH UP BOOTS

.WORD	0				; END OF TAPE BOOTS


;+
;
;	The New and Improved All-Purpose Secondary Magtape Boostrap
;
;	Parameters: (As passed by newer hardware boots and V9.1 INIT)
;
;		R0	= Unit number to boot (Newer bootstraps only)
;		R1	= CSR address of controller
;
;	If an error occurs, and the bootstrap halts with 20 in the
;	"lights", then this bootstrap can be restarted by continuing.
;
;	Note that sections of code used for one type of bootstrap are
;	free space to be used by other bootstraps for command and
;	message buffers.
;
;-


	DEFORG	MGBOOT

MGBOOT::.WORD	<MGBEND-MGBOOT>/2	;Length of MGBOOT in words, including
					; this word!!
	NOP			;NOP required for boot
	BR	CODE		;Go read in boot driver
	.WORD	6		;If trap to 4, make PC = 6...
	HALT			;...and halt with 10 in the "lights"
	.WORD	12		;If trap to 10, make PC = 12...
	HALT			;...and halt with 14 in the "lights"
	BR	CODE		;I guess we could try again
;
; Anything else really need to go in here?
;
HALTER:	HALT			;Bad news.  Halt with 20 in the "lights"
	BR	CODE		;Wanna try again?			;033

;+									;033
; This .BLKW is necessary so that the boot flags can be passed from	;033
; ROOT, through us, and on to the tertiary boot.  ROOT actually puts	;033
; the flags here, in location B.FLGS, before it starts us running.	;033
; Our responsibility is to pass the flags on to location B.FLGS in the	;033
; relocated bootstrap before passing control to it.			;033
;									;033
; The .ASSUMEs are used to insure that location B.FLGS lies within	;033
; the confines of the .BLKW						;033
;									;033
;-									;033

.ASSUME	<.-<MGBOOT+2>>	LE <B.FLGS-B.BOOT>				;033
	.BLKW	3		;Leave room for boot flags.		;033
.ASSUME	<.-<MGBOOT+2>>	GT <B.FLGS-B.BOOT>				;033

CODE:	CMP	R1,#160000	;Is the CSR on the I/O page?
	BLO	HALTER		;I'm afraid not.  Oh well.
	MOV	#2000,SP	;Give us a stack
	MOVPIC	#BOGO,-(SP)	;Load address of BOGO as fake return.	;033
	CMP	R1,#172440	;TM02/TM03?
	BEQ	BOOTMM		;Yep, go to it.
	CMP	R1,#172522	;Nope.  How 'bout TS03/TS04?
	BLO	BOOTMU		;No way, must be TMSCP
;	BEQ	BOOTMT		;Could be MS or MT
.ASSUME	BOOTMT EQ BOOTMS
	CMP	R1,#172522+<7.*4>	;For MS, there are 8 possibilites (0-7)
	BLOS	BOOTMS		;TS11 protocol.  Initialize and go.
	BR	BOOTMU		;TMSCP (Probably)			;033

BOGO:	MOVB	@#<B.FLGS-B.BOOT>,@#B.FLGS ;Get saved flags and put	;033
				; them into the real bootstrap.		;033
	JMP	@#B.BOOT	;And, jump to the real boot!!		;033


BOOTMU:	MOVPIC	#BTMSCP,R5	;Point to rings and such
	MOV	#BTMCPS,R4	;Number of words to clear
10$:	CLR	(R5)+		;Clear a word
	SOB	R4,10$		;Do the whole communication area
	MOVPIC	#<MGBOOT+2>,R3	;Get out physical address
	ADD	(R5)+,R3	;Point to the rings
	MOV	R3,BTSTEP+2	;Set the pointer (No MSB - We're low core)
	MOV	#STEP1,R4	;Set R4 to the first step indicator
	MOV	R1,R2		;Copy CSR pointer
	CLR	(R2)+		;Kick the IP to initialize the controller
20$:	TST	(R2)		;Check the SA for an error
	BMI	NOGOOD		;Uh oh!  Something bad has happened
	BIT	(R2),R4		;Is the port ready for the next step?
	BEQ	20$		;No.  Keep waiting for something to happen
	MOV	(R5)+,(R2)	;Ready, issue the next initialize step command
	ASL	R4		;Shift to next step indicator
	BPL	20$		;Loop until all four steps are done
	ADD	(R5)+,R3	;Point to the response packet
	MOV	R3,BTRING	;Set pointer in ring buffer (No MSB - Low core)
	ADD	(R5)+,R3	;Point to the command packet
	MOV	R3,BTRING+4	;Set pointer in ring buffer (No MSB - Low core)
	CALL	MUCMD,R5	;Issue command to MU controller
	.WORD	OP.ONL		;Command is online
	MOVPIC	#BTBUFS,R4	;Point to the packet buffers
	MOV	#BTBFSZ,R3	;Size in words
30$:	CLR	(R4)+		;Start clearing...
	SOB	R3,30$		;The whole thing
	MOV	#BOOTSZ,BTCMD+P.BCNT	;Set byte count for read
	MOV	#157000-MUBOOT,BTCMD+P.BUFF	;Load MU boot driver @ 157000
	CALL	MUCMD,R5	;Issue command to MU controller
	.WORD	OP.RD		;Command is read
	RETURN			;We're off to see the wizard...


MUCMD:	MOV	(R5)+,BTCMD+P.OPCD	;Set in command
	MOVB	R0,BTCMD+P.UNIT	;Set in booted unit number
	MOVB	#1,BTCMD-1	;Set tape connection ID
	BIS	#MD.CSE,BTCMD+P.MOD	;Clear any previous serious exception
	MOV	#60.,BTRSP-4	;Set length of response packet
	MOV	#36.,BTCMD-4	;Set length of command packet
	BIS	#OWN,BTRING+2	;Mark response packet as owned by controller
	BIS	#OWN,BTRING+6	;Same for command packet
	TST	(R1)		;Prod the port into polling
40$:	TST	(R2)		;Error?
	BMI	NOGOOD		;Yes, get out
	TST	BTRING+2	;Response yet?
	BMI	40$		;No.  Keep waiting.
.ASSUME	OWN EQ 100000
	MOV	BTRSP+P.STS,R4	;Get status
	BNE	NOGOOD		;Never expect an error
	RETURN	R5		;And we're done


BOOTMM:	BR	MMCONT		;Too far to make in one branch

NOGOOD:	BR	HALTER		;If we get an error, call it quits.

BOOTMT:
BOOTMS:	MOV	(R1),R4		;Save CSR in case it's a MT
	CLR	(R1)		;Bounce the CSR
	MOV	#50,R2		;MSB counter
10$:	SOB	R3,10$		;Start wait loop (Minor portion)
	SOB	R2,10$		;Major wait portion
20$:	TSTB	(R1)		;Finish micro-diagnostics yet?
	BPL	20$		;Nope.  Wait for it.
	BIT	#2000,(R1)	;Need buffer address? (TS11 Protocol only)
	BEQ	MTCONT		;No, continue on in MT boot code
30$:	MOVPIC	#CHRBF,R3	;TS11.  Point to characteristics buffer
	MOVPIC	#TSBF,R4	;Point to message buffer
	MOV	R4,(R3)		;Store message pointer in characteristics buffer
	ADD	#20,R4		;Now point to command buffer
	MOV	R3,2(R4)	;Characteristics come from the buffer
	CALL	MSCMD,R5	;Issue a command to the TS04
	.WORD	140004		;Command is set characteristics
	.WORD	12		;Buffer extent is 12 bytes (enough for TS05)
	MOV	#157000-MSBOOT,2(R4)	;Load MS boot driver code @ 157000
	CALL	MSCMD,R5	;Issue the next command...
	.WORD	140001		;A read, since initialize rewound for us.
	.WORD	BOOTSZ		;Buffer extent is our long DOS label
	CLR	(R1)		;Bounce the CSR one last time
	RETURN			;We're off to see the wizard...

MSCMD:	MOV	R4,-(SP)	;Save R4 for a milli-second or two
	MOV	(R5)+,(R4)+	;Set command in packet
	TST	(R4)+		;Skip LSB buffer address
	CLR	(R4)+		;Never an MSB
	MOV	(R5)+,(R4)	;Set buffer extent
	MOV	(SP)+,R4	;Get our command pointer back
	MOV	R4,-2(R1)	;Give command packet address to controller
	.BR	TS0XWT		;Wait for the TS04 to become ready


TS0XWT:	BIT	#100200,(R1)	;Ready or error?
	BEQ	TS0XWT		;Neither, keep waiting.
	BMI	NOGOOD		;Error.  Wait for user interaction.
	RETURN	R5		;All done.

	.BLKB	<.-MGBOOT-2>&2	;Align to modulo 4 boundary
CHRBF:	.WORD	0,0		;Point to status buffer
	.WORD	16.		;Buffer length
	.WORD	0,0		;Default characteristics

TSBF	= CHRBF+20
.ASSUME	<<TSBF-MGBOOT-2>&3> EQ 0

;+
; NOTE:	Beginning of MT boot code is used as TS11 packet area
;
; NOTE:	Latter part of MT boot code and all of MM boot code is
;	used for the MU packet area.
;-

MTCONT:	BIC	#^C<63400>,R4	;Isolate the CSR bits we need (Density & Unit)
	MOV	R4,R0		;Find booted unit number
	BIC	#^C<7*400>,R0	;From saved CSR register
	SWAB	R0		;Get it in low bits
	CALL	MTCMD,R5	;Issue a command the MT drive
	.WORD	17		;The command is rewind
	MOV	#BOOTSZ,MTABRC(R1)	;We'll next read in our DOS label...
	MOV	#157000-MTBOOT,MTACMA(R1)	;So that it loads @ 157000
	CALL	MTCMD,R5	;Issue the command
	.WORD	3		;...Read, of course.
	RETURN			;We're off to see the wizard...

MTCMD:	MOV	R4,(R1)		;Reset density and re-select unit
	BIS	(R5)+,(R1)	;Set desired function and go
10$:	BIT	#MTSELR,MTAS(R1)	; Select remote still on?
	BEQ	NOGOOD		;Nope.  We're out of luck.
	BIT	#MTTUR,MTAS(R1)	;Tape unit ready?
	BEQ	10$		;Not yet, keep waiting
	BR	TS0XWT		;Wait for the TS03 to become ready.


MMCONT:	TSTB	(R1)		;Controller ready?
	BPL	BOOTMM		;Nope, not yet.
	MOV	RHCS2(R1),R0	;Get unit number of booted device
	BIC	#^C<7>,R0	;Only bits we need
	MOV	MMTC(R1),R2	;Save formatter, slave, and density setting
	BIC	#^C<3767>,R2	;Isolate bits we need
	MOV	#40,RHCS2(R1)	;Controller clear
	MOVB	R0,RHCS2(R1)	;Select unit
	MOV	R2,MMTC(R1)	;Re-select old density/formatter/slave
	CALL	MMCMD,R5	;Issue a command to the TM02/TM03
	.WORD	7		;The command is rewind
	MOV	#157000-MMBOOT,RHBA(R1)	;Load MM boot driver code @ 157000
	MOV	#BOOTSZ,RHWC(R1)	;Read our extended DOS label
	CALL	MMCMD,R5	;Issue a command to the TM02/TM03
	.WORD	71		;The command is read
	RETURN			;We're off to see the wizard...

MMCMD:	MOV	(R5)+,(R1)	;Issue the command
10$:	TSTB	(R1)		;Controller ready?
	BPL	10$		;Nope, not yet.
	TST	RHDS(R1)	;Drive ready?
	BPL	10$		;Nope, keep waiting.
	TSTB	RHCS2+1(R1)	;Any controller errors?
	BNE	NOGOOD		;Yes, die fast.
	BIT	#^C<MMFCE>,RHER(R1)	;Any drive errors except frame count?
	BNE	NOGOOD		;Oops!  Sorry.
	RETURN	R5		;All's fine.


TMSCPA:				;Place hold while we jump back...

	.=.-116.		;Set up symbols for TMSCP over other code

; ** These items are to be kept in this order

BTMSCP:				;Start of TMSCP communication area
	.BLKW	2		;Interrupt status words for rings
BTRING:	.BLKW	4		;Response and command ring descriptors
BTBUFS:
	.BLKW	2		;Response packet envelope
BTRSP:	.BLKB	60.		;Response packet area
	.BLKW	2		;Command packet envelope
BTCMD:	.BLKB	36.		;Command packet area

BTMCPS	= <.-BTMSCP>/2
BTBFSZ	= <.-BTBUFS>/2

.ASSUME	<.-TMSCPA> EQ 0		;We should be back where we started.

;+
;	Initialize and control table for TMSCP
;-

	.WORD	BTRING-MGBOOT-2	;Offset to rings
BTSTEP:	.WORD	100000
	.WORD	0		;Low order descriptor ring address
	.WORD	0		;High order descriptor ring address
	.WORD	GO		;Go bit

	.WORD	BTRSP-BTRING	;Offset from ring to response
	.WORD	BTCMD-BTRSP	;Offset from response to command

; ** End of ordering requirement

MGBEND:				;Symbol denoting true end of boot block
	.BLKB	1000-<.-MGBOOT-2>	;Round to block boundary for patch space
;021-


ENDOVL	<COP,COPCTL,COPTXT>,200		;PATCH AREA

.END
