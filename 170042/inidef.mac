.INCLUDE /CMN:COMMON/							;064
.INCLUDE /CMN:KERNEL/							;064
.INCLUDE /INIT:INIPFX/							;064
.INCLUDE /CMN:KBDEF/							;064
.INCLUDE /INIT:DSKDEF/							;064
.INCLUDE /CMN:CFGDEF/							;064
.INCLUDE /CMN:HDRDEF/							;081
.LIBRARY /CMN:NETDEF.SML/						;064
TITLE	DEFALT,<RSTS/E INIT - DEFAULT OPTION>,0K,23-JUN-92,SHG/RVR/MDS/SRM/JTC/MND/GPK/CEK/AWL/AJK/JHC/MNB/FEK/DBM/KPH/VAM/FRL/DSD

;
;		COPYRIGHT (c) 1974, 1992 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR INIDEF

;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-08
;  001	TG   01-Jan-81	Fixed XBUFF spelling
;  002	TG   01-Jan-81	Fixed Cache question on Auto restart bug
;  003	MND  16-Feb-81	Added DMP/DMV support
;  004  MND  16-MAR-81	BYPASS MEMORY PARITY CSR SCANNING ON 11/70 & 11/74
;  005  MDS  18-MAR-81	Save XBUF info in 1st entry of extended mem dump tbl
;  006  SRM  05-May-81	Fix bugs in XBUF sizing code.
;  007	JTC  14-May-81	Remove XBUF dump stuff dealing with Default buffer
;  008	MND  12-Jun-81	Changed Swap Max & Power fail delay defaults
;  009  GPK  01-Jul-81	Changed memory table handling for ODT from ODT.SYS
;  010  CEK  06-Aug-81  Add BUFFERS suboption for data space 
;  011  CEK  03-Sep-81  Fix to report number of small buffers correctly
;  012  CEK  28-Oct-81  Change memory table suboption for FIP pool and
;			dynamic resident overlays
;  013  SRM  20-Oct-81	Add routine to compute size of resident overlays.
;  014  MND  11-Nov-81	Removed XBUF - MAP suboption. (not needed)
;
;				[RSTS V7.2]
;  000  CEK  19-Jan-82  Creation - copied from V7.1-11
;  001  CEK  19-Jan-82	Make memory table suboption relocate XBUF and ODT
;			instead of eliminating them
;  002  AWL  16-JUL-82  Have MTLABL routine decode "MS".
;
;				[RSTS V8.0]
;  003  AJK  28-Jul-82  Changed PARITY: subroutine to recognize MS11-P
;			memory and scan for up to 2 Meg words of memory.
;			Also, changed SETNXM: subroutine to scan for 2 MAG
;			words of memory for non 11/70s.
;  004	GPK  26-Sep-82	Removed SETNXM (to ROOT), reinstated old edit
;			histories
;  005	GPK  11-Nov-82	32K jobs, streamline startup for TAP
;  006  JHC  10-Jan-82  Changed messages produced by descrepencies between
;			memory allocation table and physical memory.
;  007  MNB  21-Feb-83  Prompts with "extension" changed to "filetype"
;  008  JHC  03-Mar-83  Fix up SHFMEM to do real limit checking.
;			Add LDSPAC to verify room for loader.
;
;				[RSTS V9.0]
;  009	GPK  06-May-83	Job headers
;  010	GPK  09-Jun-83	Added missing Global
;  011	FEK  11-Jul-83	Allow 64Kw swapmax for user I/D space if I/D available
;  012	WJS  28-Sep-83	Globalize mapping symbols
;  013	MND  24-Oct-83	Added virtual disk allocation to MEMORY suboption
;  014	MND  01-Nov-83	Defaults for the DEFALTs (auto-DEFALT) finally!
;  015	MND  09-Nov-83	Added more intelligent memory shuffling (FNDHI/FNDLOW)
;  016	MND  01-Dec-83	Removed MTLABL,DATEF,TIMEF, & POWERF. Now online.
;  017	DBM  17-Jan-84	Add VT200 support (No <LF> key)
;  018	MND  01-Feb-84	Always Enable CRASH dump @ DEFALT, warn only @ START
;  019	FEK  17-FEB-84	ALLOW XBUF IN OTHER RANGES
;  020	MND  19-FEB-84	Fix FNDHI & FNDLO to shuffle XBUF in other ranges
;  021	MND  21-FEB-84	Added default for BUFFERs and XBUF 
;  022	MND  14-Mar-84	Show SWAP/JOB MAX DEFALTS on input prompt 
;  023	DBM  27-Mar-84	Add dynamic allocation of SWAP.SYS and CRASH.SYS
;  024	MND  14-May-84	Add RVLOOK routine
;  025	DBM  10-Jun-84	Fix job max default messages
;  026	DBM  03-Jul-84	Remove JOB MAX question altogether (Settable online)
;			And fix my auto-restart bug (INSBUF corruption)
;  027	DBM  09-Aug-84	Replace BASIC with DCL as third choice RTS
;  028	DBM  13-Sep-84	Fix swap max upper limit (64. NOT 64 octal)
;			And add I & D hardware check to allow 33-64K swap max
;  029	KPH  28-Aug-84	Add 4K more to FIP pool on I&D systems
;			Move OVRBUF to before FIPPOL on I&D systems
;			Remove resident overlay stuff (done online)
;  030	DBM  05-Oct-84	Minimum Swap max is now 32K
;			Fix default XBUF allocation
;			Use maximum amount of BUFFERs as default
;			Only valid RTS choices are DCL and RSX
;  031  VAM  11-Feb-85	Remove references to 'NOTTYS' (used in UNISYS)
;  032  MND  21-Feb-85	Set up date and time format defaults
;  033  MND  06-Mar-85	Reinstated RINGS memory table suboption
;  034	DBM  20-Feb-85	Bug fixes: Swap max <0K>, BUFFER on small machines
;			Shuffle XBUF error message.
;  035  VAM  12-Mar-85	Don't rewrite defaults to SIL during an auto-restart.
;			Also, don't set up DV pointers until after memory is
;			shuffled.
;  036  FRL  14-Mar-85  Create BUFF.SYS automatically.
;
;			[RSTS V9.1]
;  037	DBM  07-May-85	Merge TMSCP changes
;  038	KPH  05-Apr-85	Remove primary RTS
;  039	DBM  26-May-85	Dynamic CMT support
;  040  KPH  29-May-85	Conditional phases
;  041  VAM  11-Jul-85	Always write out DEFBUF when starting
;
;			[RSTS V9.2]
;  042  KPH  15-Jul-85	Add Job Control Region
;			Improve the BUFFER suboption HELP text
;			Fix SETFPL for systems without I&D space
;
;			[RSTS V9.3]
;  043  KPH  24-Oct-85	Bugfix in JCR size setup/dynamic DECnet support
;  044  JHC  07-Dec-85	Conditional loading of QNA/UNA phases
;  045  DBM  09-Dec-85  Ethernet Rings suboption (merge by JHC)
;  046  KPH  14-Jan-86	Add EVL phase for DECnet
;  047  KPH  06-Feb-86	Add RDM phase for DECnet
;  048	DBM  24-Mar-86	Finish Ethernet support.  Other fixes
;  049  KPH  23-Apr-86	Pick up exec record offsets from control record
;  050  VAM  30-Apr-86	Move INSBUF fields here and make them local.
;			Remove long START option stuff.
;			Make auto-start "do the right thing" when possible.
;  051	DBM  13-May-86	TK50 ECO check
;  052  FRL  29-Apr-86	Micro/RSTS changes
;  053  VAM  15-May-86	Bugfix in XBUF suboption question.
;			Also, use TOPPHY global for physical address checks.
;  054  VAM  16-May-86	Changes to Memory Table listing.
;			Fix GETTYP to use A.NXM, and to check NXM before LOCK.
;  055  VAM  11-Jun-86	Use DEFFIN to write out DEFBUF when STARTing.
;  056  DBM  26-Aug-86	Ethernet depends upon DECNET. 48K mapped XBUF.
;			Bug fix in UDA option.  Remove 4Kw MSCP restriction.
;			4 MU controllers.
;  057	DBM  13-Oct-86	48K mapped XBUF only for UNA systems
;  058  VAM  13-Nov-86	Back out 051 above.
;			Also remove "This system can address up to..." message.
;  059  VAM  18-Nov-86	Use TOPPHY for address checks in GET2AD/GETADR.
;
;			[RSTS/E V9.4]                          
;  060  KPH  11-Jan-87	Add JCR extension for systems with I&D space
;  061	GPK  01-Oct-86	Changes for RADCNV being in resident overlay
;  	GPK  07-Oct-86	More changes for FIP stuff in resident overlay
;  	GPK  10-Oct-86	PRO changes
;  	GPK  22-Jan-87	Conditional phase handling for PRO phases
;  062	DBM  26-Feb-87	User level Ethernet
;  063	PJH  03-Mar-87	Put in PARLOC sanity check             
;
;			[RSTS/E V9.5]
;  066  VAM  22-Jul-87	Fix prompting for RINGS suboption.
;  067  VAM  07-Oct-87	Fix parity checking for memory >1920K
;
;			[RSTS/E V9.6]
;  064  KPH  13-Oct-87	Add .INCLUDEs
;			Add CONFIG.SYS file support
;			Enforce a valid memory table before exiting
;			Changes for larger jam list/loader area
;			Add table-driven dynamic device support
;			Add dynamic FMS support
;			Add conditional phases for terminal driver
;  065  KPH  02-Nov-87	Add LAT support
;  068  WRM  01-Dec-87	Source clear V9.5 into V9.6
;  069	DSD  20-Jan-88	Add conditional NODVR phase
;  070  VAM  11-Apr-88	Eliminate reference to "install" in message.
;  071  KPH  20-May-88	Add no frills support
;
;			[RSTS/E V9.7]
;  072	DRP  29-Dec-88	Add conditional loading of the KBX phase
;  073  VAM  25-Jan-89	Remove INIT virtual disk support.
;			Look up SWAP MAX from CONFIG.SYS and use if appropriate.
;			Use new configuration routines.
;  074  VAM  21-Mar-89	Fix DEFAULT RINGS question text (again).
;			Fix Swap Max checking logic in JOBSWP.
;  075	FEK  03-Mar-89	Add patch point for I&D RJ2780
;
;			[RSTS/E V10.0]
;  076	FEK  21-Jul-89	Allow V10 single digit BL#
;  077  VAM  04-Aug-89	Change range for SWAP MAX to 34-66K.
;  078	FEK  02-Apr-90	KDJ11-E parity memory support + bug fixes + NOID
;  079  VAM  21-May-90	Prompt for SWAP MAX if value in CONFIG is bogus
;  080  BGN   1-Jun-90  Copy T. space into D. space before checking crash size
;			Check crash file size even on autostart
;  081  VAM  01-Jun-90	Use HDRDEF definition of job header size for SWAP MAX
;			range checks.
;  082  BGN/ 20-Jun-90	Source clear INIT.CMD patch from V9.7, and update 080
;	VAM		so we save all defaults on auto-start.
;-

.SBTTL	Local Definitions

NORMXB	=:	32.		;Maximum amount of XBUF in Kw to map	;056
ETHMXB	=:	48.		;Maximum amount to map if ethernet	;056
MINXBF	=:	3		;Minimum number of K words allowed for	;050
				; XBUF.					;050


.SBTTL	Call any needed macros

.MCALL	$NCPDB,$CTLREC,$EXEREC						;047

	$NCPDB			;Get database definitions		;043
	$CTLREC			;And control record layout		;043
	$EXEREC			;And executor record layout		;047

.SBTTL	MACROS FOR DEFAULT

.MACRO	I.MESS
	TMPORG	DEFTXT
.NLIST	BEX
.ENDM	I.MESS

.MACRO	OPTION	NAME,DESC
	TMPORG	MEMOTB
	 .WORD	M.'NAME
	TMPORG	MEMOTX
.NLIST
.DSABL	CRF
$$$$$$	= 0
.IRPC	X,<NAME>
.IF	LT	$$$$$$-2
	 .BYTE	''X
.IFF
	 .BYTE	''X!200
.ENDC
$$$$$$	= $$$$$$+1
.ENDM
	 .BYTE	377
.ENABL	CRF
.LIST
	UNORG
.LIST
M.'NAME:
.NLIST
.ENDM	OPTION
        
.MACRO	GETPAR	OFFSET,TO
.NLIST
	CLR	-(SP)
	CLR	-(SP)
	MOV	OFFSET,-(SP)
	CALL	GTPAR
	MOV	(SP)+,TO
.LIST
.ENDM	GETPAR

.MACRO	PUTPAR	OFFSET,WHAT
.NLIST
	CLR	-(SP)
	MOV	OFFSET,-(SP)
	MOV	WHAT,-(SP)
	CALL	PTPAR
.LIST
.ENDM	PUTPAR

.MACRO	PHZDEV	DEVNAM
.ASSUME	<<<.-PHZTBL>/12>*12> EQ <.-PHZTBL> ;PHZDEV out of order
.IF	B	DEVNAM
	.WORD	0		;End the table
.IFF	;B	DEVNAM
	.WORD	'DEVNAM'.PKT	;Phase entry for DEVNAM
.GLOBL	'DEVNAM'.PKT
.ENDC	;B	DEVNAM
.ENDM	PHZDEV

.MACRO	LENGTH	INSTAL,DEFALT
.ASSUME	<<<<.-PHZTBL>-2>/12>*12> EQ <<.-PHZTBL>-2> ;LENGTH out of order
	.WORD	INSTAL,DEFALT
.GLOBL	INSTAL
.ENDM	LENGTH

.MACRO	BLOCK	INSTAL,DEFALT
.ASSUME	<<<<.-PHZTBL>-6>/12>*12> EQ <<.-PHZTBL>-6> ;BLOCK out of order
	 .WORD	INSTAL,DEFALT
.GLOBL	INSTAL
.ENDM	BLOCK

.SBTTL	ORDER THE CSECTS

	DEFORG	DEF
	DEFORG	DEFCTL
	DEFORG	DEFTXT
	DEFORG	MEMOTB
	DEFORG	MEMOTX
	ORG	DEF

.SBTTL	Scratch Default Area						;050

;									;050
; This area is used to hold a working copy of the saved defaults.	;050
; It contains the same fields (with different names), in the same	;050
; order as DEFBUF.							;050
;									;050
; ** BEWARE!!  Change nothing here unless it's also changed in ROOT	;050
;		(or vice versa).					;050
;									;050

	TMPORG	DEFCTL							;050

; Following fields must be in same order as comparable fields of DEFBUF	;050

T.JOBM:	.BLKW0			; Start-up Job Max			;050
T.SWPM:	.BLKW0			; Start-up Swap Max			;050
T.CRAS:	.BLKW0			; Start-up crash dump flag		;050
T.XTRA:	.BLKW0			; Extra Monitor size for small buffers	;050
T.EXEC:	.BLKW0	2		; Location & size of Exec		;050
T.ODT:	.BLKW0	2		; Location & size of ODT		;050
T.CACH:	.BLKW0	2		; Location & size of cache memory	;050
T.LOCK:	.BLKW0	<2048./16.>	; Locked Memory bit map (1 bit/K)	;050
				; Note that the UNIBUS area isn't here	;050
T.END:				; End of Temporary Area.		;050

	UNORG								;050

;
; Define as global the corresponding DEFBUF fields (located in ROOT)	;050
;

GLOBAL	<D.JOBM,D.SWPM,D.CRAS,D.XTRA,D.EXEC,D.ODT,D.CACH,D.LOCK>	;050
GLOBAL	<D.NXM,A.NXM>							;050

.SBTTL	CONSTANTS

; ADDRESS LIMITS ARE IN K WORDS.  UPPER LIMITS ARE 1K BEYOND THE HIGHEST
; LEGAL ADDRESS FOR THE MEMORY ITEM

.EQUATE	ODTUPL,124.		;UPPER LIMIT FOR ODT
.EQUATE	XBFUPL,512.		;UPPER LIMIT FOR XBUF
.EQUATE	XBFLOL,16.		;LOWER LIMIT FOR XBUF

.SBTTL	DEFAULT OPTION MAIN DRIVER
                        
DEFALT::NOP			;OPTIONALLY PATCHED TO BPT TO ALLOW ODT ENTRY.
	CALLX	CKOPT		;IS THIS A LEGAL OPTION?
	CLR	STFLAG		;WE ARE NOT STARTING
	CALL	DEFINI		;INITIALIZE DEFAULTS
	CALL	JOBSWP		;GET JOB/SWAP MAXIMA
	CALL	ERRGET		;Get the error file			;038
	CALL	INSNAM		;GET INSTALLATION NAME
	CALL	MEMTBL		;GET MEMORY TABLE
	CALL	CACHCL		;Set CACHE CLUSTER SIZE =4
	CALL	DEFSAV		;Copy defaults from temp to DEFBUF.	;082
	CALL	CRASH		;Enable CRASH DUMP [on]
	CALL	CLOCK		;GET PREFERRED CLOCK
	CALL	DEFFIN		;FINISH WITH DEFAULTS
	EXIT

	TMPORG	DEFCTL
STFLAG:	.WORD	0		;<>0 IF START, 0 IF DEFAULT
BLNRST:	.WORD	0		;BLOCK NUMBER IN DATABF
	UNORG

.SBTTL	INITIALIZE FOR DEFAULT OPTION

.ENABL	LSB

DEFINI:	CALLX	SETFIP		;USE THE SYSTEM DISK
	CALLX	LOKMIN		;Look up minimum file structure and	;050
				; read defaults from SIL into DEFBUF.	;050
	BCC	10$		;NO ERRORS
	MESSAG	<"Defaults cannot be set - Not a valid system disk."<200>>
				;Tell 'em what really happened.		;050
	BR	20$		;EXIT

10$:	TST	SILNAM		;IS THERE A SIL INSTALLED?
	BNE	30$		;YES, WE CAN DO IT
   	MESSAG	<"Defaults cannot be changed until a SIL has been STARTed"<200>>
									;070
20$:	EXIT

30$:	MOV	#I.DFLD,R0	;Point to the beginning of the buffer
	TST	(R0)		;ARE DEFAULTS SET YET?
	BNE	TMPINI		;Yup, so don't clear DEFBUF.		;050
	MOV	#DEFCLR,R2	;GET LENGTH OF DEFAULT AREA TO CLEAR
40$:	CLR	(R0)+		;CLEAR OUT DEFALTS
	SOB	R2,40$
	CLR	-(SP)		;Make room for a byte move		;045
	MOVB	XE.PKT+PK.MXU,(SP)	;Get number of UNA's supported	;045
	MOVB	XH.PKT+PK.MXU,R2	;Get number of QNA's supported  ;045
	ADD	(SP),R2		;Compute total number of Ethernet controllers
50$:	MOV	#6*256.+20.,(R0)+	;Set Ethernet ring entry defaults ;056
	SOB	R2,50$							;045
	MOVB	RU.PKT+PK.MXU,(SP) ;Get number of MSCP controllers supported
	MOVB	MU.PKT+PK.MXU,R2   ;Get number of TMSCP controllers supported
	ADD	(SP)+,R2	;Compute total number of [T]MSCP controllers
60$:	MOV	#2*256.+2,(R0)+	;Set [T]MSCP ring entry defaults	;045
	SOB	R2,60$		;					;045
	CALL	CACHCL		;Set up default cache cluster size	;014	
	CLR	@#D.XTRA	;Initial assumption is no extra buffers.
	MOV	#A.NXM,R0	;R0 -> Actual NXM table.		;050
	MOV	#D.NXM,R1	;R1 -> NXM table in DEFBUF.		;050
	MOV	#<2048./16.>,R2	;R2 = Length of table in words.		;050
70$:	MOV	(R0)+,(R1)+	;Copy from Actual NXM to DEFBUF...	;050
	SOB	R2,70$		; until we're through.			;050
TMPINI:	CALL	FORMAT		;Set up date and time format		;???
	MOV	#D.JOBM,R0	;R0 -> DEFAULT BUFFER TABLES
	MOV	#T.JOBM,R1	;R1 -> Working copy			;050
	MOV	#<T.END-T.JOBM>/2,R2 ;R2 = Length to copy, in words.	;050
90$:	MOV	(R0)+,(R1)+	;Copy defaults to work area.		;050
	SOB	R2,90$
	MOV	#NORMXB,MAPXBF	;Set maximum amount of XBUF to map	;056
	TST	CNT.XE		;Any UNA devices present?		;057
	BEQ	100$		;Nope, all done				;056
	MOV	#ETHMXB,MAPXBF	;Change the maximum amount we'll map	;056
..MXBF	== .-4			;** Patch here to change the value	;056
100$:	CLR	BLNRST		;SET BLOCK NUMBER 0 FOR PAGING RSTS SIL
	RETURN

	TMPORG	DEFCTL
MAPXBF:	.WORD	0		;Maximum amount of mapped XBUF		;056
	UNORG

.DSABL	LSB

GLOBAL	<SILNAM,I.DFLD,DEFCLR,D.XTRA,CNT.XE>				;064


.SBTTL	Copy temp workspace into DEFBUF and/or clean up after DEFAULT	;082

.ENABL	LSB

DEFSAV:	MOV	#I.DFLD,R2	;Point at start of default		;082
	MOV	#-1,(R2)+	;INDICATE THAT DEFAULTS ARE SET,
				; AND POINT AT D.JOBM
	MOV	#T.JOBM,R3	;Point to temporary work area.		;050
10$:	MOV	(R3)+,(R2)+	;Move new defaults to DEFBUF.		;050
	CMP	R3,#T.END	;End of area to copy?			;050
	BLO	10$		;NO
	
	MOV	#A.NXM,R2	;R2 -> Actual NXM.			;050
	MOV	#D.NXM,R3	;R3 -> NXM table in DEFBUF.		;050
	MOV	#<2048./16.>,R5	;R5 = Number of words in table.		;050
20$:	MOV	(R2)+,(R3)+	;Move entries from Actual to Default...	;050
	SOB	R5,20$		; until we hit the end.			;050
	RETURN								;082

DEFFIN:	CALL	DEFSAV		;Move work area into DEFBUF.		;082
	MOV	#D.ERRN,R4	;R4 -> DEFAULT ERR FILE NAME		;038
	MOV	#NEWERR,R5	;R5 -> NEW ERR FILE NAME
	TST	(R5)+		;ANY CHANGE?
	BEQ	30$		;NO
	CALL	NOKOFF,R3,<^RERR> ;YES, TURN OFF NOKILL IN OLD
	MOV	(R5),-(R4)	;MOVE NEW NAME INTO DEFBUF
	MOV	-(R5),-(R4)
	CALL	NOKON,R3,<^RERR> ;TURN ON NOKILL BIT
30$:	CALLRX	DEFALO		;PUT THE DEFAULTS OUT TO DISK

.DSABL	LSB

GLOBAL	<I.DFLD,D.ERRN>							;050

.SBTTL	GET A WORD FROM THE RSTS MODULE OF THE SIL

;+
; RSRSO3 - READ RSTS MODULE GIVEN TABLE OFFSET
;
;	R3 = TABLE OFFSET
;
;	CALL	RDRSO3,R4,<POINTER TO TABLE BASE>
;
;	R0 -> WORD IN BUFFER
;-

RDRSO3:	MOV	R3,R0		;READ OFFSET BY R3
	ADD	@(R4)+,R0	; OFFSET POINTED TO IN LINE
	CALL	RDRSTS		;DO THE READ
	RETURN	R4

;+
; RDRSTS - READ RSTS MODULE AND RETURN A WORD
;
; 	R0 = ADDRESS WITHIN RSTS
;
;	CALL	RDRSTS
;
; 	R0 -> WORD IN BUFFER
;	TO REWRITE THE BUFFER, MAKE RWRITE NON-0
;-

RDRSTS:	REGSCR			;SAVE REGISTERS
	MOV	R0,R2		;COPY ADDRESS
	BIC	#777,R2		;REMOVE BLOCK OFFSET FROM ADDRESS
	BIC	R2,R0		;LEAVE ONLY THE BLOCK OFFSET IN R0
	ADD	#DATABF,R0	;R0 -> LOCATION OF DESIRED WORD IN BUFF
	MOV	R0,TOS.R0(SP)	;RETURN POINTER IN R0
	SWAB	R2		;CONVERT R2 TO RELATIVE BLOCK NUMBER
	ROR	R2		;  WITHIN RSTS MODULE
	ADD	RSTBLK,R2	;R2 = ABSOLUTE BLOCK WITHIN SIL
	CMP	R2,BLNRST	;IS IT ALREADY THERE?
	BEQ	10$		;YUP, THAT'S EASY
	MOV	#256.,R0	;NO, READ IT
	MOV	#FQSIL+FQFCB,R1	;R1 -> FCB FOR READ
	MOV	R2,FCNVB(R1)	;SPECIFY BLOCK TO READ
	CALLX	READ.,R5,DATABF	;READ IT IN
	MOV	R2,BLNRST	;REMEMBER WHAT'S THERE
10$:	RETURN

	TMPORG	DEFCTL
DATABF:	.BLKW	256.
	UNORG

GLOBAL	<RSTBLK,FQSIL>

.SBTTL	SET/CLEAR 'DO NOT KILL' BIT IN DIRECTORY

.ENABL	LSB

NOKOFF:	TST	(PC)+		;CLEAR THE CARRY
NOKON:	SEC			;SET CARRY FOR NOKON
	MOV	(R3)+,-(SP)	;Push extension				;061
	CLR	-(SP)		;Open up a spot				;061
	MOV	(R4)+,-(SP)	;Push name part 1			;061
	MOV	(R4)+,2(SP)	; and part 2				;061
	MOV	#0*400+1,-(SP)	;  and PPN [0,1]			;061
	MOV	R3,10(SP)	;SAVE RETURN ADDRESS			;061
	ROR	R3		;SAVE ON/OFF INDICATOR IN R3 SIGN BIT
	TST	2(SP)		;IS THERE A NAME?			;061
	BEQ	40$		;NO, JUST RETURN
	REGSAV			;PRESERVE REGISTERS			;061
	MOV	R3,R4		;PUT SET/CLEAR FLAG IN SAFE PLACE
	MOV	SP,R0		;POINT TO PPN+NAME.EXT			;061
	ADD	#TOS.PC,R0	; at the appropriate offset from SP	;061
	CALLX	SDU		;SEARCH DIRECTORY FOR FILE
	BCS	20$		;ERROR, PRINT MESSAGE
	BICB	#US.NOK,USTAT(R5) ;CLEAR THE NO-KILL BIT
	TST	R4		;ON OR OFF?
	BPL	10$		;OFF, LEAVE IT
	BISB	#US.NOK,USTAT(R5) ;ON, TURN IT ON
10$:	CALLX	WRITE		;REWRITE THE DIRECTORY BLOCK		;061
	BR	35$		; and exit				;061

20$:	TST	R4		;TURNING ON OR OFF?
	BPL	30$		;OFF, TELL HIM WE CAN'T FIND IT
	MESSAG	<<177>"INIT bug - ">
	MOV	TOS.PC+6(SP),R0	;GET TYPE OF FILE			;061
	CALLX	RADZER		;PRINT IT
	ERF	<" file not found 2nd time">

30$:	MOV	TOS.PC+6(SP),R0	;PRINT A WARNING			;061
	CALLX	RADZER		;FILE TYPE
	MESSAG	<" file not found when removing it"<200>>
35$:	REGRES			;Restore registers			;061
40$:	ADD	#10,SP		;Pop PPN/Filename			;061
	RETURN

50$:	.WORD	<0*400>+1,0,0,0

.DSABL	LSB

.SBTTL	SWAP MAXIMUM CHANGER
.ENABL	LSB
;026+
JOBSWP:	MOV	JOBMAX,JMXGEN	;SAVE GENERATED JOB MAX
	MOV	JOBMAX,T.JOBM	;Save it in working area also.		;050
	CLR	R0		;Get SWAP MAX from CFGBUF...		;079
	BISB	CFGBUF+CFG$SM,R0; ...without sign extend evil.		;079
	BEQ	70$		;Never been set, default to minimum.	;081
	TSTB	@#DSHARD	;D-space on this machine?		;079
	BMI	70$		;No, so it must be minimum - go set it.	;081
	CMP	R0,#<32.+HDRSIZ>;Check it against our legal minimum.	;081
	BLO	20$		;Too low - Let 'em know.		;079
	CMP	R0,#<64.+HDRSIZ>;Is it higher than maximum?		;081
	BLOS	80$		;No, it's OK - go use it.		;074
20$:	MOV	#30$,R1		;Point to place for output message	;079
	CALLX	DECSTR		;Put it thar				;079
	MESSAGE			;Tell user that old value was bogus.	;079
	 .ASCII	<177><12>"Current SWAP MAX value of "			;079
30$:	 .ASCIZ "??????K is invalid."<200>				;079
	UNORG								;079
35$:	CALLX	ASKER,R5	;Go ask the question...			;079
	 .WORD	40$		;SHORT FORM
	 GENTXT
	  .ASCII "    Enter the new value for SWAP MAX, from 3"		;081
	  .BYTE  '2+HDRSIZ	;Construct help text, using HDRSIZ	;081
	  .ASCII "4 to 6"	; to fill in correct values!		;081
	  .BYTE  '4+HDRSIZ						;081
	  .ASCII "."<200> ;079						;081
.ASSUME	HDRSIZ LE 5		;Above will only work if HDRSIZ <= 5	;081
40$:	  .ASCIZ <177><12>"    New value for SWAP MAX? "		;079
	 UNORG
	BEQ	150$		;Ctrl/Z or <LF> was entered, so get out.;079
				;Now, R1 -> string just entered.	;079
	CALLX	DECINP		;Convert to decimal.			;079
				;Now, R0 = decimal "value" of string,	;079
				; and R1 -> one byte past the first	;079
				; character that couldn't be translated.;079
	;TSTB	-1(R1)		;Done by DECINP.			;079
	BNE	60$		;Was first untranslatable character a	;079
				; null?  If not, then user's input had	;079
				; bogus character(s) in it - go gripe.	;079
	CMP	R0,#<32.+HDRSIZ>;Is it within range?			;081
	BLO	60$		;Definitely not, so complain.		;079
	CMP	R0,#<64.+HDRSIZ>;How about this end of the range?	;081
	BLOS	80$		;Yup, it's OK, so use it.		;079
60$:	MESSAG	<"      Invalid value.  Please enter ? for help."<200>>	;079
	BR	35$		;One More Time!!			;079

70$:	MOV	#<32.+HDRSIZ>,R0;Set SWAP MAX to minimum value.		;081
80$:	MOV	R0,T.SWPM	;Change Swap Max.			;079
	MOVB	R0,CFGBUF+CFG$SM;Also, put it back into CFGBUF.		;073
	TST	STFLAG		;Are we STARTing?
	BEQ	150$		;No, so we're done			;079
	.BR	BUFCHK		;Yes, check BUFF & SWAP files		;036

GLOBAL	<JOBMAX,AUTOGO,CFGBUF>						;073

	TMPORG	DEFCTL
JMXGEN:	.WORD	0		;JOB MAX FROM MONITOR SYSGEN
	UNORG


.SBTTL	CHECK OUT BUFF.SYS AND CREATE IF NEEDED				;036

BUFCHK:	CLR	DTAFLG		;Assume disabled			;036
	TST	CNT.DT		;See number of DT units generated	;036
	BEQ	SWPCHK		;None, done				;036
	CALL	CHKFIL,R5	;Check the BUFF.SYS file		;036
	 .RAD50	/BUFF  SYS/						;036
	 .WORD	100$		;Address of minimum size routine	;036
	  BR	110$		; +0, everything's A-ok			;036
	  MESSAGE <"DECtape disabled"<200><12>> ; +2, couldn't		;036
	 BR	SWPCHK		;		  (re-)create file	;036

100$:	MOV	CNT.DT,R1	;Number of DTs				;036
	MUL	#3,R1		;  times 3 for number of blocks needed	;036
	MOV	R1,R0		;R0 = Number of blocks required		;036
	RETURN								;036

110$:	CALLX	LOKFIL		;Reset FCB for BUFF.SYS			;036
	CALL	NOKILW,R5,FC...	;Make sure it is unkillable/unwritable	;036
	COM	DTAFLG		;Enable DECtape				;036
	.BR	SWPCHK		;Now check the swap file		;036

GLOBAL	<DTAFLG,CNT.DT>							;036


.SBTTL	CHECK OUT SWAP.SYS AND CREATE IF NEEDED

SWPCHK:	CALL	CHKFIL,R5	;CHECK OUT THE SWAP FILE
	 .RAD50	/SWAP  SYS/
	 .WORD	130$		;ADDRESS OF MINIMUM SIZE ROUTINE
	  BR	120$		;RETURN + 0 MEANS EVERYTHING'S FINE
	  BR	SWPERR		;RETURN + 2 MEANS COULDN'T (RE-)CREATE FILE

120$:	CALLX	LOKFIL		;RESET FCB
	MOV	FC...+FCWND+2,SWPDCN	;SAVE STARTING DCN OF SWAP.SYS
	MOV	FC...+FCSIZ,SWPSIZ	; AND SIZE OF SWAP.SYS
	CALL	NOKILW,R5,FC...	;TAKE CARE OF THE WRITE AND KILL PRIVS
	RETURN			;ALL DONE

130$:	MOV	T.SWPM,R0	;Minimum size of SWAP.SYS is Swap Max...;050
	ASH	#2,R0		; TIMES 4 FOR BLOCKS (1 JOB)
150$:	RETURN			; RETURN (NOTE THIS RTS IS A COMMON RTS)

GLOBAL	<AUTOQS,SWPDCN,SWPSIZ,FC...>
.DSABL	LSB
;026-

.SBTTL	HANDLE ERROR IN CREATING SWAP.SYS

;+
; SINCE WE WERE UNABLE TO CREATE SWAP.SYS AT SUFFICIENT SIZE
; TO HOLD ONE JOB, WE'LL CHECK AND SEE WHAT THE GREATEST POSSIBLE
; SWAP MAX IS.  IF THE GREATEST POSSIBLE IS LESS THAN 32K, THEN
; WE WILL ABORT STARTUP WILL A FATAL ERROR TELLING THE USER TO
; CREATE SOME ROOM ON HIS DISK.  IF THE GREATEST POSSIBLE SWAP
; MAX IS GREATER THAN OR EQUAL TO 32K, THEN WE'LL LET THE USER
; KNOW THAT HE CAN EITHER REDUCE SWAP MAX, OR HE CAN TYPE A ^C
; TO GET BACK TO OPTION, SO THAT HE CAN MAKE ROOM ON HIS DISK.
;-

.ENABL	LSB

SWPERR:	MOV	SIZTBL+2,R0	;GET THE MINIMUM SIZE BACK FROM CHKFIL
	CALL	GETSAT		;GET A NICE CLEAN SAT FROM THE DISK
	CALL	SETUP		;GET EVERYTHING SET UP AGAIN
	CALLX	LOKFIL		;RESET THE FIRQB
	BCS	10$		;FILE DIDN'T EXIST TO BEGIN WITH
	CALL	DEALLC		;DEALLOCATE EXISTING FILE
	CALL	ALCBAD		;MAKE SURE BADB.SYS IS ALLOCATED
10$:	CALLX	SAVSAT		;SAVE THE DEALLOCATED SAT
20$:	CALLX	RESSAT		;RESTORE THE SAT
	MOV	FRESAV,FREENT	; AND THE FREE ENTRY COUNT
	SUB	#4,R0		;REDUCE SWAP MAX BY 1K
	CMP	R0,#32.*4	;IS THIS A LEGAL VALUE			;030
	BLT	40$		;NO, SO ROOM MUST BE MADE FIRST
	MOV	R0,FQSIZN(R4)	;PUT THIS TRIAL SIZE INTO THE FIRQB
	CALL	TRYCRE		;SEE IF WE CAN CREATE SWAP.SYS NOW
	BCS	20$		;STILL CAN'T, REDUCE SWAP MAX AND TRY AGAIN
	ASH	#-2,R0		;AHH! CONVERT DISK BLOCKS BACK TO Kw
	MOV	R0,T.SWPM	;And save new default Swap Max.		;050
	MOV	#30$,R1		;POINT TO MESSAGE AREA
	CALLX	DECSTR		;PUT THE VALUE IT THE MESSAGE
	MESSAG			;LET HIM KNOW WHAT'S GOING ON
	 .ASCII	"You can start timesharing if SWAP MAX is reduced to "
30$:	 .ASCIZ	"??????K"<200>
	UNORG
	BR	50$		;Oh, well...just go back!		;073

40$:	MESSAG
	 .ASCII	"You must free some contiguous disk space "
	 .ASCIZ	"to start timesharing"<200>
	UNORG
50$:	EXIT			;RETURN TO OPTION PROMPT

.DSABL	LSB

;023-

	TMPORG	DEFCTL
NEWERR:	.BLKW0	2
	UNORG

.SBTTL	CHANGE ERROR FILE

.ENABL	LSB

ERRGET:	CLR	NEWERR		;INDICATE NO NEW ERR YET
	MOV	#D.ERRN,R5	;R5 -> place to store ERR name		;014
	CALL	FNDERR		;Find ERR.ERR				;014
	BCC	7$		;Got it. Only ask if ERR.ERR is missing	;014
5$:	CALL	RTEASK,R5	;CALL COMMON ASKER/OPENER
	 .WORD	D.ERRN		;POINTER TO FORMER NAME
	 GENTXT	<<177><12>"Error message file">
	 GENTXT
	  .ASCII <12>"Specify the name of a file in [0,1] with filetype '.ERR'"<200>
	  .ASCII "which contains the RSTS/E error message text."<200>
	  .ASCIZ <12>"Directory of valid error message files:"<200><12>
	 UNORG
	 GENTXT	<<177><12>"Name of error message file">
	 .RAD50	/ERR/
	BCS	30$		;<LF> MEANT NO CHANGE
7$:	CALL	CHKCTG		;CHECK FOR CONTIGUOUS FILE
	BCS	10$		;NO GOOD
	CMP	FC...+FCSIZ,#8. ;MUST BE THE RIGHT SIZE
	BEQ	20$		;OK
	CMP	FC...+FCSIZ,#16.;MAYBE HE HAS A BIG ERROR FILE
	BEQ	20$		;OK
10$:	MESSAG	<"Error file has an invalid file format"<200>>
	BR	5$		;TRY AGAIN

20$:	MOV	#NEWERR,R5	;R5 -> AREA FOR NEW ERR NAME
	MOV	FQ...+FQNAM1,(R5)+ ;SAVE THE NEW NAME
	MOV	FQ...+FQNAM1+2,(R5)+
30$:	RETURN


FNDERR:	MOV	#VALERR,R0		;Point to list of valid ERR	;014
	MOV	#ERR.SZ,R3		;  and set up a counter		;014
40$:	MOV	#FQ...+FQNAM1,R1	;Set-up a pointer to the FIRQB	;014
	MOV	(R0),(R5)+		;Save 1st wrd of name for RTEASK;014
	MOV	(R0)+,(R1)+		;Move in 1st 3 chars. of name	;014
	MOV	(R0),(R5)+		;Save 2nd wrd of name for RTEASK;014
	MOV	(R0)+,(R1)+		;Move in last 3 chars. of name	;014
	MOV	(R0)+,(R1)+		;Move in file extension		;014
	CALLX	LOK...			;See if this file is out there	;014
	BCC	50$			;Yes, use it			;014
	CLR	-(R5)			;No, clear out the preset answer;014
	CLR	-(R5)			;  both words			;014
	SOB	R3,40$			;Try our next choice		;014
	SEC				;None found, ask for a file name;014
50$:	RETURN				;RTS C clear=success/ C set=fail;014

.DSABL	LSB

.SBTTL	Valid Error file for Auto-DEFALTS

	TMPORG	DEFCTL
VALERR:	.RAD50	/ERR   ERR/		;ERR.ERR is our only choice	;014
ERR.SZ	=	.-VALERR/6.						;014
	UNORG

GLOBAL	<D.ERRN,FC...,FQ...>

.SBTTL	FILE ASKER/OPENER FOR ERR

.ENABL	LSB

RTEASK:	MOV	(R5)+,R2	;GET POINTER TO OLD NAME
10$:	MOV	(R5),R0		;GET FIRST PART OF SHORT TEXT
	CALLX	ASCIZ0		;PRINT IT
	MOV	(R2),R0		;R0 = OLD NAME
	BEQ	20$		;NONE
	MESSAG	^!<40><74>!
	CALLX	RADZER		;PRINT OLD NAME
	MOV	2(R2),R0
	CALLX	RADZER
	MESSAG	^!<76>!
20$:	MESSAG	<"? ">
	CALLX	GETIN		;GET AN ANSWER
	TST	(R2)		;IS LINE FEED LEGAL?
	BEQ	30$		;NO, DON'T CHECK
	CMPB	(R1),#12	;DOES HE WANT NO CHANGE?
	BNE	30$		;NO, HE WANTS CHANGE
	ADD	#10,R5		;FIX RETURN ADDRESS
	SEC			;INDICATE LINE FEED
	RETURN	R5

30$:	CMP	(R1),#'?	;NEED HELP?
	BNE	70$		;NO, NO HELP
40$:	MOV	2(R5),R0	;PRINT LONG TEXT
	CALLX	ASCIZ0
	MOV	6(R5),50$	;PUT IN FILE'S EXTENSION
	CALL	ELIGBL,R5	;GET LIST OF ELIGIBLE FILES
50$:	.RAD50	/ERR/		;ASSUME ERROR FILES
	TST	(R2)		;CAN HE LINE FEED?
	BEQ	60$		;NO
	MESSAG	<"Type <CR> for no change."<200>>,TYPELF
60$:	MOV	4(R5),R0	;GET FINAL TEXT
	CALLX	ASCIZ0		;PRINT IT
	BR	20$		;AND ASK AGAIN

70$:	CALLX	RADINP		;GET INPUT FILE NAME
	TSTB	(R1)		;GOOD?
	BEQ	80$		;YES
	CMPB	(R1),#'.	;DID HE GIVE AN EXTENSION?
	BNE	90$		;NO, NO GOOD
80$:	MOV	#FQ...+FQNAM1,R1 ;R1 -> AREA FOR NAME
	MOV	R0,(R1)+	;SAVE THE NAME
	BNE	100$		;(NON-NULL)
90$:	MESSAG	<"Illegal file name"<200>>
	BR	10$		;TRY AGAIN

100$:	MOV	R3,(R1)+	;MORE FILE NAME
	MOV	6(R5),(R1)+	;EXTENSION
	CALLX	LOK...		;LOOK FOR FILE, OPEN ON FQ...
	BCC	110$		;GOT IT
	MESSAG	<"File not found"<200>>
	BR	10$		;TRY AGAIN

110$:	ADD	#10,R5		;FIX RETURN ADDRESS
	CLC
	RETURN	R5

.DSABL	LSB

GLOBAL	<FQ...>

.SBTTL	INSTALLATION NAME CHANGER

.ENABL	LSB

INSNAM:	TST	@#I.DFLD	;ARE DEFAULTS SET YET?			;014
	BNE	120$		;Yes, so use whatever is there.		;014

;	Set-up the SIL name as the installation name

FNDNAM:	MOV	SILNAM,R0	;Get the 1st 3 chars of the SIL name	;014
	CLR	-(SP)		;Push terminator for the name		;061
	SUB	#6,SP		; and make room on the stack for it	;061
	MOV	SP,R4		;Point to first 3 bytes			;061
	CALLX	RADCNV		;  and convert the RAD50 name to ascii	;014
	MOV	SILNAM+2,R0	;Get the last 3 chars of the SIL name	;014
	ADD	#3,R4		;Advance pointer past first 3 chars	;061
	CALLX	RADCNV		;  and convert the RAD50 name to ascii	;014
	MOV	#D.NAME,R5	;R5 -> PLACE FOR NAME
				;Now set in the standard LOGO		;014
80$:	MOV	#LOGO,R0	;R0 -> STANDARD LOGO
90$:	MOVB	(R0)+,R1	;Get a byte of name			;061
	CMP	R1,#176		;Filler?				;061
	BEQ	90$		;Yes					;061
	MOVB	R1,(R5)+	;MOVE IT IN TO DEFAULT BUFFER		;061
	BNE	90$							;061
	DEC	R5		;BACK UP R5
	TSTB	MICRO		;Micro/RSTS?				;052
	BNE	100$		;Yes, skip edit number			;052
	MOVB	SYSVEN,R0	;R0 = SYSVEN
	BEQ	100$		;NONE
	MOVB	#'-,(R5)+	;DASH
	CMPB	R0,#'0		;Are we going to trash a 0?		;076
	BEQ	95$		; Yes, so trash it			;076
	MOVB	R0,(R5)+	; No, so save it			;076
	MESSAG			;LET HIM KNOW WHAT'S GOING ON		;076
	 .ASCIZ	"INIT Bug - Illegal system baselevel number."<200>	;076
	UNORG								;076
95$:	MOVB	SYSVEN+1,(R5)+	;SYSVEN 2ND DIGIT
	BNE	100$		;IF ANY
	DEC	R5		; ELSE FIX R5
100$:	MOVB	#40,(R5)+	;SPACE
	MOV	R5,D.NPTR	;SET UP OFFSET WORD
	SUB	#D.NAME,D.NPTR	; AS OFFSET TO USER PART OF NAME
	MOV	SP,R1		;Point to name on stack			;061
110$:	MOVB	(R1)+,(R5)+	;MOVE IN THE USER NAME
	BNE	110$
	ADD	#10,SP		;Pop name off stack			;061
120$:	RETURN

.DSABL	LSB
GLOBAL	<LOGO,SYSVEN,D.NPTR,D.NAME,MICRO>				;052

.SBTTL	MEMORY TABLE CHANGER

; INTERNAL VARIABLES:
;	R5		bit flags
;		100000	=>	memory needs to be shuffled
;		1	=>	memory hardware has changed

.ENABL	LSB

MEMTBL:	NOP			;Patch to BPT for testing.		;050
	TST	@#T.EXEC+2	;Is there a monitor size saved??	;050
	BNE	15$		;Yup, everything is cool.		;035
	CLR	@#I.DFLD	;Otherwise, pretend it's our first time	;035
15$:	CALL	PARITY		;Set up the parity table.		;035
	CALL	FNDODT		;Find ODT.SYS and save its size.
	CALL	SETCPH		;Set up conditional phases		;043
	CALL	LAYMON		;Lay out the monitor.
	TST	I.DFLD		;Are there any defaults?
	BNE	20$		;Yes, so use them			;030
	CALL	RSTMEM		;  No, go select some 1st time DEFALTs	;021
	BR	190$		;List table and see if we want to ask	;050
				; for changes.				;050

20$:	CLR	R5		;Assume we don't need to shuffle memory.
	MOV	@#D.XTRA,R0	;Find out how much buffer space he previously
				; asked for.
	CMP	R0,@#T.XTRA	;Can we give him that much?		;050
	BEQ	50$		;Yes, go see if the monitor size has changed.
	MOV	#30$,R1		;Point to place in message for old amount of 
				; buffer space.
	CALLX	DECSTR		;Convert number to ASCII.
	MOV	@#T.XTRA,R0	;Find out how much buffer space we	;050
				; can really give him.
	MOV	#40$,R1		;Point to place in message where that goes.
	CALLX	DECSTR		;Convert it to ASCII.
	MESSAG			;Now say it.
	 .ASCII	<177><12>"Cannot use extra "
30$:	 .ASCII	"??????K of buffers.  Reduced to "
40$:	 .ASCIZ	"??????K."<200>
	 UNORG


;
; Tell him if monitor size has changed.
;
50$:	MOV	@#T.EXEC+2,R0	;Get former size of monitor.
	CMP	R0,@#MONSIZ	;Has it changed?
	BEQ	80$		;No, go see if NXM has changed.
	MOV	#60$,R1		;Point to place in message for old size.
	CALLX	DECSTR		;Convert it to ASCII.
	MOV	@#MONSIZ,R0	;Get new size of monitor.
	MOV	#70$,R1		;Point to place in message for it.
	CALLX	DECSTR		;Convert it to ASCII.
	MESSAG			;Tell him about it.
	 .ASCII	<177><12>"Size of monitor has changed from "
60$:	 .ASCII	"??????K to "
70$:	 .ASCIZ	"??????K."<200>
	 UNORG
	BIS	#100000,R5	;Note that we must shuffle memory table.
;
; TELL HIM IF NXM HAS CHANGED
;
80$:	MOV	#D.NXM,R0	;R0 -> Default NXM.			;050
	MOV	#A.NXM,R1	;R1 -> Actual NXM.			;050
	MOV	#<2048./16.>,R2 ;R2 = # of words in table.		;050
90$:	MOV	(R1),R3		;GET ACTUAL NXM
	BIC	(R0),R3		;ALL THOSE BITS BETTER BE ON IN DEFAULT
	BEQ	100$		;THEY ARE, SKIP
	MESSAG	<<177><12>"Default memory allocation table shows MORE"<200>>
	BR	105$		;Join common message part

100$:	MOV	(R0)+,R3	;GET THE BITS THAT ARE ON IN DEFAULT
	BIC	(R1)+,R3	;DOES DEFAULT NXM SPECIFY EXISTENT MEMORY?
	BEQ	110$		;NO, KEEP LOOKING
	MESSAG	<<177><12>"Default memory allocation table shows LESS"<200>>
105$:	MESSAGE	<"memory than INIT detects on this machine."<200><200>>
	BIS	#100000+1,R5	;NOTE THAT HARDWARE CONFIGURATION HAS CHANGED
	BR	120$		;EXIT LOOP

110$:	SOB	R2,90$		;TRY ALL NXM WORDS
120$:	TST	R5		;DOES TABLE NEED SHUFFLING?		;038
	BNE	160$		;YES, GO DO IT
	CALL	CHKODT		;SEE IF STATUS OF ODT IS OK
140$:	CALL	CHKUSR		;Check out the memory table		;064
	BCS	190$		;Need to change it, go force that	;064
	TST	STFLAG		;Are we STARTing?			;050
	BNE	150$		;Yes, nothing to change			;064
	CALLX	ASKER,R5,<M.MEMS,M.MEML> ;ASK IF HE WANTS TO CHANGE IT
	CALLX	ANSWER,R5	;CHECK OUT THE ANSWER
	 BR	200$		;Y - Change it.				;064
150$:	 RETURN			;N - NO CHANGE
	 RETURN			;<LF> - NO CHANGE
	 RETURN			;O - NO CHANGE
	 BR	140$		;OTHER - ASK AGAIN

160$:	MESSAG	<"Adjusting memory table."<200>>
	ROR	R5		;HAS HARDWARE CONFIGURATION CHANGED?
	BCC	180$		;NO, SKIP
	MOV	#T.LOCK+<2048./8.>,R0 ;POINT TO END OF LOCKED MEMORY	;050
	MOV	#<2048./16.>,R1	;GET TABLE LENGTH IN WORDS		;050
170$:	CLR	-(R0)		;Clear all T.LOCK bits.			;050
	SOB	R1,170$
180$:	CALL	SHFMEM		;SHUFFLE THE TABLE
190$:	CALL	M.LIST		;List the table also.			;050
	TST	STFLAG		;Are we STARTing?			;050
	BNE	210$		;Yes, don't ask for an option		;064
200$:	CALL	MEMOPT		;No, so go ask for option.		;064
210$:	CALL	CHKUSR		;Check out the table			;064
	BCS	200$		;Can't use it, ask again		;064
	RETURN			;All done now				;064

.DSABL	LSB

GLOBAL	<.$PZER,I.DFLD,AUTOQS>						;050

.SBTTL	CHKUSR	Check out user space in the memory control table

;+
; CHKUSR - Check out user space
;
;	CALL	CHKUSR
;
;	C = 0 if memory table OK
;	C = 1 if user must adjust memory table
;
;	All registers are undefined.
;
; This routine checks out the memory table to ensure that there
; is a hole of SWAP maximum size exists, and that there is room
; for the loader. If this isn't true, an error will be printed,
; and our caller will force the user to take corrective action.
;-

.ENABL	LSB

CHKUSR:         

; The first thing that we'll do is look for a hole of swap max size.

	CLR	R0		; Start at the beginning for user memory ;064
	MOV	T.SWPM,R2	; Pick up our swap max			;064
	CLR	R4		; We're looking for user memory		;064
.ASSUME	U.USER	EQ	0
	CALL	FNDLOW		; Now find that hole			;064
	BCS	10$		; Didn't do it, error			;064

; The next thing that we'll look for is space for the loader and the
; jam list. While these entries are actually independant, we treat
; them as if they were one entry since it is too complicated to explain
; all of the rules and the additional flexibility isn't really useful.
;
; The hole must reside after INIT, as it must exist in memory along with
; INIT. We also require the first K-word of the loader to be at or
; below 124K. This is because the MSCP bootstrap must do DMA
; into the bootstrap itself for the controller ring structures, and it
; would be too confusing to vary the loader rules based on the
; system disk.

	MOV	ENDIN$,R0 	; Start looking for space above INIT	;064
	MOV	#4+<JAMSIZ/4000>,R2 ; Get the size of loader & jammer	;064
	CALL	FNDLOW		; Go find that space			;064
	BCS	20$		; Can't find it, complain		;064
	CMP	R0,#124.	; Out of 18-bit mapping range?		;064
	BHIS	20$		; Yes, forget it			;064
	ASH	#11.-6,R0	; Convert buffer address to MMU value	;064
	MOV	R0,LDRMMU	; Save loader address			;064
	ADD	#200,R0		; Get jammer address			;064
	MOV	R0,JAMMMU	; Save the MMU address for the jammer	;064
	CLC			; Indicate success			;064
	RETURN			; Got a hole, go exit 			;064

10$:	MOV	T.SWPM,R0	; Pick up swap maximum			;064
	CALL	60$		; And announce it			;064
	BR	50$		; And join up				;064

20$:	MOV	#4+<JAMSIZ/4000>,R0 ; Get the size of the loader & jammer ;064
	CALL	60$		; Say the please allocate part		;064
	MOV	ENDIN$,R0	; Get the start range for the loader	;064
	MOV	#30$,R1		; And point to the text			;064
	CALLX	DECSTR		; Convert the string			;064
	MOV	#<124.+<4+<JAMSIZ/4000>>>-1,R0 ; Get the end address	;064
	MOV	#40$,R1		; Point to the text			;064
	CALLX	DECSTR		; And convert the string		;064
	MESSAG								;064
	  .ASCII " between "						;064
30$:	  .ASCII "??????K and "						;064
40$:	  .ASCIZ "??????K"						;064
	UNORG								;064
50$:	MESSAG	"."<12><200>	; Pretty up the line			;064
	SEC			; Indicate failure			;064
	RETURN			; And get out				;064

60$:	MOV	#70$,R1		; Point to where text goes		;064
	CALLX	DECSTR		; Convert it to text			;064
	MESSAG								;064
	  .ASCII "Please allocate "					;064
70$:	  .ASCIZ "??????K words of memory for user space"		;064
	UNORG								;064
	RETURN			; All done here				;064

.DSABL	LSB

GLOBAL	<ENDIN$,JAMSIZ,LDRMMU,JAMMMU>					;064

.SBTTL	MEMORY TABLE SUBOPTION DRIVER

.ENABL	LSB

MEMOPT:	CALLX	ASKER,R5,<M.SUBS,M.SUBL> ;Ask for suboption		;058
	BEQ	M.RTN		;GO AWAY ON CTRL/Z OR <LF>
	CALLX	GETUNQ,R5,MEMOTX ;PARSE THE ANSWER AS A STRING
	MOVB	(R1),PREST1	;SAVE POSSIBLE PRESET ANSWER
	CALL	@MEMOTB(R0)	;CALL THE SUBOPTION
	BR	MEMOPT		;LOOP AROUND AGAIN

OPTION	EXIT
	TST	(SP)+		;REMOVE DISPATCH CALL
M.RTN:	RETURN			;Go back.				;058

	GLOBAL	<DU.MAX,MU.MAX>
.DSABL	LSB

	TMPORG	DEFCTL

PREST1:	.WORD	0		;PRESET SUBOPTION ARGUMENT FLAG

	UNORG

.SBTTL	MEMORY TABLE QUESTION TEXT

	I.MESS

M.MEML:
.ASCII	<12>
.ASCII	"If you wish to specify a certain portion of memory as unavailable to"<200>
.ASCII	"RSTS or as dedicated buffer space, answer 'YES'.  To leave the memory"<200>
.ASCII	"allocation unchanged from the last specified table, answer 'NO'."<200>
M.MEMS:
.ASCII	<177><12>
.ASCIZ	"Any memory allocation changes? "

M.SUBL:
.ASCII	<12>
.ASCII	"  Valid table suboptions are:"<200><12>
.ASCII	"  LIST    List the current memory allocation table"<200>
.ASCII	"  PARITY  List the parity memory configuration"<200>
.ASCII	"  RESET   Let RSTS reset the default memory configuration"<200>
.ASCII	"  LOCK    Lock out some memory"<200>
.ASCII	"  UNLOCK  Unlock some locked memory"<200>
.ASCII	"  BUFFERS Change size of small buffer pool"<200>
.ASCII	"  XBUF    Allocate extended buffer space for disk/message caching"<200>
.ASCII	"  IDSPACE Enable or Disable Data space usage in this monitor"<200>
.ASCII	"  EXIT    (or <CR>) when you are satisfied with the table"<200>
.ASCII	<12>
.ASCII	"  Only the first two characters need be typed"<200>
M.SUBS:
.ASCII	<177><12>
.ASCIZ	"  Table suboption? "

	UNORG

.SBTTL	CONVERT RESPONSE TO 1K ADDRESS OR ADDRESS RANGE

;+
; GET2AD - GET 2 ADDRESSES AND RETURN START AND RANGE
;
;	R1 -> RESPONSE
;
;	CALL	GET2AD
;
;	C=0	RESPONSE WAS VALID
;		If R2 does not equal zero;
;			R0 = STARTING K NUMBER
;			R2 = NUMBER OF K ( >= 1)
;		If R2 does equal zero;
;			R0 = NUMBER OK K
;
;	C=1	RESPONSE INVALID, MESSAGE HAS BEEN PRINTED
;-
.ENABL	LSB

GET2AD:	CLR	R2		;Assume INIT will find a range		;020
	CALL	GETADR		;GET THE FIRST ADDRESS
	BEQ	70$		;If only 1 value entered, R0 = No. of K	;020
10$:	CMPB	(R1)+,#40	;SKIP BLANKS
	BEQ	10$		; BEFORE THE DASH
	MOV	R0,R2		;COPY START ADDRESS
	CMPB	-1(R1),#'-	;CHECK FOR A HYPHEN
	BEQ	20$		;IT IS, SO HE TYPED A RANGE
	CMPB	-1(R1),#'+	;CHECK FOR A PLUS
	BNE	130$		;ERROR, GO PRINT MESSAGE
	COM	R0		;HE TYPED A K COUNT, SET FLAG
20$:	CMPB	(R1)+,#40	;SKIP BLANKS
	BEQ	20$		; AFTER THE DASH
	DEC	R1		;THEN FIX TEXT POINTER
	TST	R0		;K COUNT?
	BPL	30$		;NO, RANGE, GO GET HIGH LIMIT
	CALLX	DECINP		;FOR K COUNT, GET NUMBER OF K OF AREA
	BNE	130$		;ERROR, NOT AT END OF STRING
	DEC	R0		;CHANGE TO COUNT-1
	ADD	R2,R0		;COMPUTE HIGH K NUMBER
	CMP	R0,TOPPHY	;Too big?				;059
	BHIS	130$		;Yes, error.				;059
	BR	50$		;NO, FIX UP AND DONE

30$:	CALL	GETADR		;GET ANOTHER ADDRESS
40$:	BNE	130$		;NOT END OF STRING, ERROR (TAG FOR REFERENCE)
50$:	MOV	R0,-(SP)	;SAVE END ADDRESS
	MOV	R2,R0		;RESTORE START ADDRESS
	MOV	(SP)+,R2	;GET END ADDRESS AGAIN
	SUB	R0,R2		;MAKE R2 A NUMBER OF K
	BCS	130$		;OOPS, TOP IS BELOW BOTTOM
60$:	INC	R2		;NUMBER OF K TRULY
70$:	RETURN

;+
; GET1AD - GET 1 ADDRESS
;
;	R1 -> RESPONSE
;
;	CALL	GET1AD
;
;	C=0	RESPONSE WAS VALID
;		R0 = STARTING K NUMBER
;
;	C=1	RESPONSE INVALID, MESSAGE HAS BEEN PRINTED
;-

GET1AD:	CALL	GETADR		;GET ONE ADDRESS
	BNE	130$		;ERROR IF STRING ENDS WRONG
	RETURN

.SBTTL	CONVERT RESPONSE TO 1K ADDRESS

;+
; GETADR - GET A MEMORY ADDRESS
;
;	R1 -> RESPONSE
;
;	CALL	GETADR
;
;	C=0	RESPONSE WAS VALID
;		R0 = ADDRESS (AS A K NUMBER)
;		R1 -> DELIMITER
;		CONDITION CODE Z SET ON DELIMITER
;
;	C=1	RESPONSE WAS INVALID, ERROR HAS BEEN PRINTED
;-

GETADR:	REGSAV			;SAVE THE REGISTERS
	MOV	R1,R5		;REMEMBER START OF STRING
	CALLX	DECINP		;TRY FOR A DECIMAL NUMBER
	CMPB	(R1)+,#'K	;IS IT A K NUMBER?
	BEQ	110$		;YUP, CHECK FOR UPPER LIMIT
	MOV	R5,R1		;NO, RESTORE START OF STRING
	CLR	R4		;CLEAR DOUBLE PRECISION OCTAL ACCUM.
	CLR	R5
80$:	MOVB	(R1)+,R0	;GET A BYTE
	SUB	#'0,R0		;REDUCE FROM ASCII
	CMP	#7,R0		;IS IT VALID OCTAL?
	BLO	90$		;NO (SET CARRY), GET OUT
	ASHC	#3,R4		;MULTIPLY RESULT BY 8
	CMP	#73,R4		;IS IT GONNA BE TOO BIG?
	BLO	120$		;YUP, GO PRINT ERROR
	ADD	R0,R5		;NO, STUFF IN A DIGIT
	BR	80$		;AND LOOP FOR MORE

90$:	;SEC			;PRESET CARRY
	DEC	R1		;BACK UP TO NON-DIGIT
	MOV	R5,R0		;COPY THE LOW ORDER RESULT
	BIC	#^C<3777>,R0	;TRIM OFF THE TOP BITS
	BEQ	100$		;K MULTIPLE IS LEGAL
	CMP	R0,#3777	;ONLY OTHER LEGAL NUMBER IS TOP OF K
	BLO	120$		;ILLEGAL, RETURN ERROR (BLO => BCS)
	CMP	TOS.PC(SP),#40$	;THAT'S ONLY LEGAL FOR SECOND OF RANGE
	SEC			;PRESET CARRY IF ILLEGAL
	BNE	120$		;ILLEGAL, GO GIVE ERROR
100$:	ASHC	#-11.,R4	;SHIFT DOWN TO A K NUMBER
	MOV	R5,R0		;AND PUT K NUMBER IN R0
110$:	MOV	R0,(SP)		;RETURN R0
.IIF NE TOS.R0,	.ERROR	;THE ABOVE WON'T WORK
	MOV	R1,TOS.R1(SP)	;AND R1 TO USER
	CMP	TOPPHY,R0	;Is it below the highest legal address?	;059
				; (Set/Clear C for use later).		;059
.ASSUME	BLO	EQ	BCS						;059
120$:	CALLX	REGRES,R5	;RESTORE REGISTERS
	BITB	(R1),(R1)	;SET Z CONDITION ON TERMINAL BYTE
	BCC	140$		;NO ERROR, RETURN TO GET?AD
	TST	(SP)+		;DUMP RETURN TO GET?AD
130$:	MESSAG	<"    Illegal 1K section address specified."<200>>
	SEC			;ENSURE C=1
140$:	RETURN

.DSABL	LSB

.SBTTL	GET TYPE OF MEMORY BLOCK

;+
; GETTYP - GET THE TYPE OF A K OF MEMORY
;
;	R1 = K NUMBER OF INTEREST
;
;	CALL	GETTYP
;
;	R3 = TYPE OF THAT K
;-
.ENABL	LSB

GETTYP:	MOV	#-1,R3		;-1 IS FLAG FOR END OF TABLE
	CMP	R1,TOPPHY	;Is the K too big?			;053
	BHIS	50$		;Yes, return end of table.		;054
	CLR	R3		;NO, PRESET R3 TO 0 (USER)
.ASSUME	U.USER	EQ	0						;054
	REGSCR			;PRESERVE ALL REGISTERS
	MOV	#T.EXEC-4,R5	;R5 -> Table of memory.			;050
	MOV	#4,R4		;R4 = # ENTITIES (EXEC,ODT,XBUF,VDSK)	;038
10$:	ADD	#4,R5		;Bump to next item.			;054
	CMP	R1,(R5)		;IS IT BELOW THE START OF THIS ITEM?
	BLO	20$		;YES, NOT HERE
	MOV	(R5),R2		;NO, COMPUTE END OF ITEM
	ADD	2(R5),R2	; = START + SIZE
	CMP	R1,R2		;BELOW THE END?
	BLO	30$		;YES, THIS IS IT
20$:	SOB	R4,10$		;AND LOOP
	MOV	#U.NXM,R5	;Set the code to NXM.			;054
	MOV	R1,R0		;COPY THE K NUMBER
	CALLX	FIXREG		;CONVERT TO BIT AND BYTE
	BITB	BITBYT(R2),A.NXM(R4) ;Is it NXM?			;054
	BNE	40$		;Yes, return NXM code.			;054
	BITB	BITBYT(R2),T.LOCK(R4) ;Is it locked?			;054
	BEQ	50$		;No, it's user.  Return the 0 preset.	;054
	MOV	#U.LOCK,R5	;Otherwise, put LOCK code into R5	;054
	BR	40$		; and return it.			;054

30$:	SUB	#T.EXEC-4,R5	;Compute memory code in R5.		;050
40$:	MOV	R5,TOS.R3(SP)	;Save to return in R3.			;054
50$:	RETURN								;054

GLOBAL	<TOPPHY>							;053

.DSABL	LSB

;
; Define Memory Usage Codes						;050
;
; Note that a table like this exists in INISTA also.			;050
; If anything is added to or changed in this one, please		;050
; make the corresponding change in INISTA.				;050
;
; U.LOCK and U.NXM, in that order, must be the last two codes.		;054
;

.DSECT
U.USER:	.BLKB	4		;USER					;050
U.EXEC:	.BLKB	4		;EXEC					;050
U.ODT:	.BLKB	4		;ODT					;050
U.CACH:	.BLKB	4		;XBUF MEMORY				;050
U.VDSK:	.BLKB	4		;VIRTUAL DISK				;050
U.LOCK:	.BLKB	4		;LOCKED MEMORY				;050
U.NXM:	.BLKB	4		;NONEXISTENT MEMORY			;050
	UNORG

GLOBAL	<BITBYT>							;050


.SBTTL	CHKMEM - CHECK A RANGE OF ADDRESSES

;+
; CHKMEM - CHECK A RANGE OF ADDRESSES FOR TYPE OR FREE
;
;	R0 = K NUMBER OF RANGE TO CHECK
;	R2 = LENGTH OF RANGE IN K
;	R4 = TYPE TO CHECK FOR (0 IF ALL MUST BE FREE)
;
;	CALL	CHKMEM
;
;	R2 = LENGTH OF RANGE IN K
;	C=0	RANGE IS ENTIRELY FREE OR OF [R4] TYPE
;	C=1	SOMETHING ELSE IS THERE
;-

CHKMEM:	REGSCR			;SAVE ALL REGISTERS
	MOV	R0,R1		;COPY START ADDRESS
10$:	CALL	GETTYP		;GET TYPE OF THIS K
.ASSUME	U.USER EQ 0		;Code for free memory is 0		;050
	TST	R3		;IS IT FREE?
	BEQ	20$		;YUP
	CMP	R3,R4		;NO, IS IT THE REQUESTED TYPE?
	BNE	30$		;NOPE, SET CARRY AND RETURN
20$:	INC	R1		;UP TO NEXT K
	SOB	R2,10$		;LOOP FOR RANGE
	TST	(PC)+		;SKIP THE SEC, CLEAR THE CARRY
30$:	SEC			;SET THE CARRY
	RETURN

.SBTTL	FNDHI - Find the highest range of free or usable memory		;015

;+
; FNDHI -  Find a range of free or useable memory at the HIGHEST	;015+
;	   possible memory address
;
;	R0 = K number of the upper limit for the memory range
;	R2 = Length of K for search
;	R4 = Type of memory to use (or 0 if only USER memory is usable)
;
;	CALL	FNDHI
;			FNDHI will look for the highest range of free (USER) 
;			memory or memory matching the K type specified in R4.
;
;	C=0	Specified K range found 
;	R0 = 	Starting K of usable memory
;
;	C=1	No memory available from starting K
;	R0 = 	Garbage
;
;	R1, R2 and R3 are preserved
;-

FNDHI:	PUSH	<R1,R3,R2>	;Save R1, R3 and R2 as advertised
	BEQ	50$		;R2 = Zero length? Then, Nothing to do
	MOV	R0,R1		;Copy the starting K for our search
10$:	DEC	R1		;Down to next 1K section of memory
	BMI	50$		;Bottom of memory! Terminate our loop!
	CALL	GETTYP		;Get the type of this K
	CMP	R3,R4		;Is it the type we're searching for?
	BEQ	30$		;  Yes. Continue searching...
	TST	R3		;Was the last 1K segment free?
.ASSUME	U.USER EQ 0		;Code for free memory is zero		;050
	BNE	20$		;  No, restart search			;020
	CMP	#U.CACH,R4	;Are we shuffling XBUF?			;050
	BNE	30$		;  No, so no special check, use this K.	;020
	BIT	#760,R1		;  Yes, is this K in an illegal range?	;020
	BNE	30$		;    No, it's O.K.			;020
20$:	MOV	(SP),R2		;Reset K length for the range we need,
	BR	10$		;      and start the search again

30$:	SOB	R2,10$		;Count down the found K, and go for more.
	MOV	R1,R0		;Return starting K in R0
	TST	(PC)+		;Success! C-bit clear/ skip SEC and RETURN
50$:	SEC			;Failure to find the required range
	POP	<R2,R3,R1>	;Restore R2, R3 and R1, as advertised.
	RETURN		 	;C set no room, C clear for success	;015-

.SBTTL	FNDLOW - Find the lowest range of free or useable memory	;015

;+
; FNDLOW - Find a useable range at the LOWEST  possible memory address	;015+
;
;	R0 = K number to start the search
;	R2 = Length of K for search
;	R4 = Type of memory to use
;
;	CALL	FNDLOW
;			FNDLOW will look for the lowest range of free (USER) 
;			memory or memory matching the K type specified in R4.
;
;	C=0	Specified K range found 
;	R0 = 	Starting K of usable memory
;       
;	C=1	No memory available from starting K
;	R0 = 	garbage
;
;	R1, R2 and R3 are preserved
;-

FNDLOW:	PUSH	<R1,R3,R2>	;Save R1, R2 and R3 as advertised
	BEQ	40$		;R2 = Zero length? Then nothing to do
	MOV	R0,R1		;Copy the starting K for our search
10$:	CALL	GETTYP		;Get the type of this K
	CMP	#U.CACH,R4	;Are we shuffling XBUF?			;050
	BNE	20$		;  No, so no special check, 		;020
	BIT	#760,R1		;  Yes, is this K in an illegal range?	;020
	BNE	20$		;    No, it's O.K.			;020
	MOV	SP,R3		;Force R3 to be an unknown entity type.	;020 
20$:	INC	R1		;Up to next 1K section of memory
	TST	R3		;Was the last 1K segment free?
	BMI	40$		;  Ouch! We're beyond RSTS's 4Meg limit.
	BEQ	30$		;  Yes. U.USER is always free		;050
.ASSUME	U.USER EQ 0		;Code for free memory is zero		;050
	CMP	R3,R4		;Not free. Is it the type we're searching for?
	BEQ	30$		;  Yes. Continue searching...
	MOV	(SP),R2		;  No. Reset K length for the range we need,
	MOV	R1,R0		;      and reset starting K in R0,
	BR	10$		;      now start the search again

30$:	SOB	R2,10$		;Count down the found K, and go for more.
	TST	(PC)+		;Success! C-bit clear/ skip SEC and RETURN
40$:	SEC			;Failure to find the required range
	POP	<R2,R3,R1>	;Restore R2 and R3, as advertised
	RETURN								;015-

.SBTTL	PRINT A RANGE OF ADDRESSES
;+
; PRTRNG - PRINT A RANGE OF MEMORY ADDRESSES (FULL 22 BIT MODE)
;
; CALL:	R5 = K NUMBER OF START OF RANGE
;	R1 = K NUMBER OF END OF RANGE
;	CALL	PRTRNG
;
; BACK:	R0 DESTROYED
;-
.ENABL	LSB

PRTRNG:	MOV	R5,R0		;COPY START OF RANGE
	CALLX	DECPRT		;PRINT AS DECIMAL DIGITS
	MESSAG	<"K: ">		;THE K NUMBER OF THE START
	ASL	R0		;TIMES 4 SINCE 1K = 4000 OCTAL
	ASL	R0
	CALL	10$,R5		;PRINT LOW END, THEN TEXT
	 GENTXT	<"000 - ">
	CMP	R1,TOPPHY	;Is the top = End of Memory?		;054
	BHI	20$		;YES, PRINT - END
	MOV	R1,R0		;NO, COMPUTE HIGH BYTE OF RANGE
	ASL	R0
	ASL	R0
	DEC	R0
	CALL	10$,R5		;PRINT HIGH END IN OCTAL
	 GENTXT	<"777 (">
	MOV	R1,R0		;COMPUTE LENGTH OF RANGE
	SUB	R5,R0
	CALLX	P4DDIG		;PRINT LENGTH AS 4 DECIMAL DIGITS
	MESSAG	<"K) : ">	;END THE TYPEOUT
	RETURN

10$:	MOV	R2,-(SP)	;PRINT 5 OCTAL DIGITS
	MOV	R0,R2		;COPY NUMBER INTO R2
	ASH	#-12.,R2	;SHIFT OFF 4 OCTAL DIGITS
	ADD	#'0,R2		;MAKE IT ASCII
	CALLX	TYPE		;TYPE A CHARACTER
	MOV	(SP)+,R2	;RESTORE R2
	CALLX	OCT4DG		;TYPE 4 MORE DIGITS
	CALLRX	MESSAG		;AND PRINT THE CALLER'S MESSAGE

20$:	MESSAG	<"End              : "> ;END and 13 spaces.
	RETURN

.DSABL	LSB

GLOBAL	<TOPPHY>							;054


.SBTTL	MEMORY TABLE SUBOPTION - LIST THE TABLE

.ENABL	LSB

OPTION	LIST

	MESSAG	<<12>"  Memory allocation table:"<200>>
	CLR	R1		;START AT K NUMBER 0
	MOV	#U.EXEC,R3	;And location 0 is EXEC type.		;050
	MOV	TOPPHY,R4	;R4 = How much memory we can have.	;054
10$:	CALLX	TYPECR		;NEW LINE
	MOV	R1,R5		;R5 = START OF RANGE
	MOV	R3,R2		;R2 = TYPE OF THIS RANGE
	BMI	40$		;End of table!!				;054
20$:	INC	R1		;NEXT K NUMBER
	CALL	GETTYP		;GET THE TYPE OF THIS K
.ASSUME	U.LOCK	GT	U.VDSK						;054
.ASSUME	U.NXM	GT	U.LOCK						;054
	CMP	R2,#U.LOCK	;Is this K LOCKED or NXM?		;054
	BLO	25$		;No, so go on with other checks.	;054
	DEC	R4		;Say that RSTS/E can't use this K.	;054
25$:	CMP	R3,R2		;Is this K same type as the last K was?	;054
	BNE	30$		;NO, MUST PRINT A RANGE
	CMP	R1,TOPPHY	;R1 above highest K for this machine?	;054
	BLO	20$		;NO, KEEP GATHERING
	MOV	#-1,R3		;SET FLAG FOR END OF TABLE
30$:	CALL	PRTRNG		;NO, PRINT OUT THE RANGE R5-R1
	MOV	MSGTYP(R2),R0	;GET THE TYPE
	CALLX	RADZER		;PRINT IT
	MOV	MSGTYP+2(R2),R0	;2 WORDS
	CALLX	RADZER
	CMP	R2,#U.VDSK	;Virtual Disk?				;050
	BNE	10$		;  No, forget it			;038
	MESSAG	<" (Virtual Disk)"> ;Yes, say so.			;013
	BR	10$		;Loop for next range			;013

40$:	MOV	R4,R0		;Find out how much we can use.		;054
	MOV	#50$,R1		;And, where it goes.			;054
	CALLX	DECSTR		;Convert it to ASCII.			;054
	MESSAG
	 .ASCII	<200>"Memory available to RSTS/E is "			;054
50$:	 .ASCIZ "??????K words."<200>					;054
	UNORG								;054
	RETURN								;054


.SBTTL	TABLE OF MEMORY TABLE TYPES

.DSABL	LSB

	TMPORG	DEFCTL

MSGTYP:	.RAD50	/USER  /
	.RAD50	/EXEC  /
	.RAD50	/ODT   /
	.RAD50	/XBUF  /
	.RAD50	/VIRT D/
	.RAD50	/LOCK  /
	.RAD50	/NXM   /
MSGNOP:	.RAD50	/NO    /

	UNORG

GLOBAL	<MAXMEM>							;073

.SBTTL	MEMORY TABLE SUBOPTION - LIST PARITY CONFIGURATION

.ENABL	LSB

OPTION	PARITY

	MESSAG	<<12>"  Parity register usage:"<200>>
	TST	ECC70		;IS THERE ANY 11/70 ECC MEMORY?
	BEQ	10$		;NO -- SKIP
;	MESSAG	<<12>"  Some memory is 11/70 ECC memory"<200>>
	RETURN

10$:	TST	HWSIZE		;IS THIS AN 11/70?
	BEQ	20$		;NO
	MESSAG	<<12>"  All memory is 11/70 parity memory"<200>>
	RETURN

20$:	CLR	R1		;START AT K NUMBER 0
	CALL	GPAR		;GET PARITY TYPE OF 0K
30$:	CALLX	TYPECR		;NEW LINE
	MOV	R1,R5		;R5 = START OF THIS RANGE
	MOV	R3,R2		;R2 = TYPE OF THIS RANGE
	CMP	R1,MAXMEM	;END OF MEMORY?
	BEQ	110$		;Yes, new line and exit.		;054
40$:	INC	R1		;NEXT K NUMBER
	CALL	GPAR		;GET PARITY TYPE
	CMP	R3,R2		;SAME AS PREVIOUS?
	BEQ	40$		;YUP, GATHER YE PARITY
	CALL	PRTRNG		;NO, PRINT THE RANGE
	MOV	R2,R5		;COPY THE TYPE OF THE RANGE
	BPL	50$		;IT ACTUALLY IS PARITY STUFF
	MOVB	R2,R2		;IT'S NON-PARITY OR NXM.  GET CODE
	ADD	#MSGNOP,R2	;POINT TO TEXT
	MOV	(R2)+,R0	;PRINT THE TYPE
	CALLX	RADZER
	MOV	(R2)+,R0
	CALLX	RADZER
	BR	30$		;AND LOOP TO NEXT RANGE

GLOBAL	<HWSIZE,ECC70>

50$:	BIT	R5,#377*400	;IS THERE A HIGH BYTE?
	BEQ	70$		;NO, NOT INTERLEAVED MEMORY
	CALL	90$		;YES, PRINT TYPE FROM R5 LOW (EVEN)
	MOVB	R5,R2		;GET LOW BYTE
	BIT	#010000,PARRNG(R2) ;IS IT ECC
	BEQ	60$		;NOPE, PUT SLASH
	MESSAGE	<"(ECC)">	;INDICATE THIS IS ECC MEMORY
60$:	TYPE	<'/>		;INTERLEAVE DIVIDER
	SWAB	R5		;GET ODD REGISTER NUMBER IN R5
	MOVB	R5,R5		;BYTE ONLY
70$:	CALL	90$		;PRINT ODD OR ONLY PARITY REGISTER
	BIT	#010000,PARRNG(R5) ;ECC MEMORY?
	BEQ	80$		;NO
	MESSAGE	<"(ECC)">	;ECC IS NOTED
80$:	TST	PARRNG(R5)	;CHECK OUT THE RANGE
	BPL	30$		;IT HAS A RANGE
	MESSAG	<"(NA)">	;IT HAS NO ADDRESS RANGE
	BR	30$

90$:	MOV	R5,R2		;COPY 2-DIGIT OCTAL
	ASH	#8.-3,R2	;SHIFT HIGH BITS OVER
	BISB	R5,R2		;GET LOW BITS AGAIN
	SWAB	R2		;CORRECT ORDER
	BIC	#^C<<7*400>+7>,R2;ISOLATE BITS
	ADD	#"00,R2		;2-DIGIT ASCII
	CALLRX	TYPE2		;TYPE 2 OF THEM

GPAR:	CMP	R1,MAXMEM	;END OF MEMORY?
	BHIS	100$		;YES, GIVE IT AN ENDING AND FORCE END OF SCAN
	MOV	R1,R3		;NO, GET K INDEX
	ASL	R3		;* 2
	GETPAR	R3,R3		;GET PARITY TYPE OF THIS K
	RETURN

100$:	MOV	#107774,R3	;HIGH BYTE NEGATIVE, LOW BYTE -4 (NXM)
	RETURN			; BUT DOESN'T MATCH ANY PARTBL ENTRY!

110$:	CALLRX	TYPECR		;Type empty line and get out.		;054

.DSABL	LSB

GLOBAL	<PARRNG,MAXMEM>

.SBTTL	SHFMEM -- Shuffle memory table

;+
; SHFMEM -- Shuffle memory table.
;
; MONSIZ =	size of monitor (K words)
; T.CACH =	desired length of XBUF (K words)			;050
; T.ODT	=	length of ODT (K words) (0 if ODT not present)		;050
;
; CALL	SHFMEM
;		SHFMEM will reallocate memory for the monitor.
;		If there is not enough memory for the EXEC, then
;		the memory table will be reset to our chosen defaults.
;
;		SHFMEM will also search for available memory for each of the
;		other memory entities and reallocate them if there is room.
;		If there is not enough memory for any entity, than it will
;		be ellimated. 
;
;		Relocation criteria;
;			T.CACH	at the highest possible memory address	;050
;				between 16K and 512K
;			T.ODT	at the lowest possible memory address	;050
;
; All registers preserved.
;-

.ENABL	LSB

SHFMEM:	REGSCR
	MOV	#T.EXEC,R5	;Get a pointer to the 1st memory entity	;050
	CLR	(R5)+		;The monitor always starts at zero,	;015
	CLR	(R5)+		;   and clear it's length		;015
	MOV	#XXODT,R4	;Get a pointer to our save area.	;015
10$:	MOV	(R5),(R4)+	;Save the old memory entity's base	;015
	CLR	(R5)+		;  and clear it				;015
	MOV	(R5),(R4)+	;Save the old memory entity's length	;015
	CLR	(R5)+		;  and clear that also			;015
	CMP	R5,#T.CACH+2	;Are we done saving what we need?	;073
	BLT	10$		;  No. Fill up rest of table		;015


;
;		Allocate memory for the EXEC				;015
;
20$:	CLR	R0		;Start allocation check at 0K.		;015
	CLR	R4		;Exec must be free memory only,		;015
	MOV	MONSIZ,R2	;Set lenght of monitor in r2		;015
	CALL	CHKMEM		;  and see if it's there		;015
	BCC	30$		;The monitor fits.			;015
	CALLX	MESSAG,R5,NOEXEC;Not enough room for monitor!!!		;015
	JMP	RESET		;Do a RESET to clear T.XTRA		;050

30$:	;CLR	@#T.EXEC	;Start monitor at 0K.			;050
	MOV	R2,@#T.EXEC+2	;  and the length in K			;050
;
;		Find room for ODT					;015
;               
40$:	MOV	XXODT+2,R2	;Set R2 to ODT's previous length	;015
	MOV	XXODT,R0	;  and R0 to ODT's old base		;015
	CALL	SHFODT		;Find a suitable place for ODT.SYS	;015
	BCC	50$		;We found room for ODT			;015
	MESSAG	<"  No room for ODT in memory."<200>>			;008
;
;		Find room for XBUF					;015
;               
50$:	MOV	XXCACH+2,R2	;Set R2 to XBUF's previous length	;015
	MOV	#MINXBF,R0	;Set R0 to minimum length allowed.	;050
	CMP	R2,R0		;Are we trying for at least minimum?	;050
	BHIS	55$		;Yup, so let it go.			;050
	MOV	R0,R2		;Otherwise, set size at minimum.	;050
55$:	MOV	XXCACH,R0	;Now, set R0 to XBUF's old base.	;050
	CALL	SHFXBF		;Find a suitable place for XBUF		;015
	BCC	60$		;We found enough room for XBUF		;015
	MESSAG	<"Not enough room for current allocation of XBUF."<200>>;050
	JMP	RESET		;If not, go RESET the memory table.	;050

60$:	RETURN			;All done here				;073

; Can't fit everything.  That's the breaks.

RESET:	MESSAG
	 .ASCIZ	"  Resetting memory table."<200>
	 UNORG
	.BR	RSTMEM		;And reset the table.

.DSABL	LSB

	TMPORG	DEFCTL

XXODT:	.WORD	0		;**Previous ODT.SYS base
	.WORD	0		;**Previous ODT.SYS length
XXCACH:	.WORD	0		;**Previous XBUF base
	.WORD	0		;**Previous XBUF length

	UNORG


.SBTTL	M.RESET / RSTMEM -- Reset memory table

;+
; M.RESET -- Memory table suboption: RESET
; RSTMEM  -- Reset memory table.
;
; MONSIZ =	size of monitor (K words)
;
; CALL	RSTMEM/M.RESET
;
; T.LOCK table is clear.  VIRTUAL DISK and ODT are eliminated.		;050
; T.EXEC gives new location and length					;050
;
; Maximum BUFFERs will be allocated and XBUF allocation will be determined ;030
;
; All registers preserved.
;-

.ENABL	LSB

OPTION	RESET

RSTMEM:	REGSCR
	MOV	#T.EXEC,R5	;Reset all memory allocations by	;050
10$:	CLR	(R5)+		;  clearing work area   from T.EXEC	;050
	CMP	R5,#T.LOCK	;                         to T.LOCK - 2.;050
	BLT	10$		;EXEC/ODT/CACH/VDISK will be cleared	;038
	MOV	#T.LOCK+<2048./8.>,R0 ;Point to end of locked memory.	;050
	MOV	#<2048./16.>,R1 ;Get table length in words.		;050
20$:	CLR	-(R0)		;Clear T.LOCK.				;050
	SOB	R1,20$
	CALL	LAYMON		;Layout the monitor with no BUFFERs	;030
	MOV	#T.EXEC,R5	;Point to monitor core control.		;050
	CLR	R0		;Start allocation check at 0K.
	MOV	@#MONSIZ,R2	;R2 = size to check (K words)
	.ASSUME	U.USER EQ 0	;It must all				;050
	CLR	R4		; be free (ie it must exist).
	CALL	CHKMEM		;Check memory.
	BCS	30$		;Exec doesn't fit.  Go announce the bad news.
	CMP	MAXMEM,#124.	;Is this a small system?		;034
	BLOS	25$		;Yes, so use 0K Buffers			;034
	MOV	#99.,T.XTRA	;Request too many BUFFERs		;050
	CALL	LAYMON		;...and relay the monitor.		;030
	ADD	T.XTRA,R2	;Add in buffers				;050
	CALL	CHKMEM		;Check memory again			;030
	BCC	200$		;All is OK				;030
25$:	CLR	T.XTRA		;Can't use that much, eliminate BUFFERs	;050
200$:	CALL	LAYMON		;Lay out the monitor with buffer default;030
	CLR	(R5)+		;Start monitor at 0K.
	MOV	@#MONSIZ,(R5)+	;Length in K.				;030
	MOV	MAXMEM,R3	;The maximum amount of memory		;021
	SUB	T.EXEC+2,R3	;  - Monitor size			;050
	MOV	R3,R1		;Get total user space in R1		;021
	CLR	R0		;Clear R0 for divide			;021
	DIV	#10.,R0		;Calculate 10% of user space.		;021
	MOV	R0,R2		;We will allocate at least that much.	;021
	CMP	R3,#128.	;Should we allocate more?		;021
	BLE	220$		;No, 10% of user space is a good size.	;050
	MOV	R3,R1		;Yes, get total user space again	;021
	CLR	R0		;Clear R0 for divide			;021
	DIV	#20.,R0		;Now calculate another 5% of user space	;021
	ADD	R0,R2		;  to give us a total of 15% user space.;021
;
; The following check (to make sure we don't allocate more than 496K	;050
; of XBUF) has been commented out, because with our current algorithm	;050
; we'll never to allocate more than 305K (15% of 2048K).		;050
; However, if the algorithm is changed in the future, this check	;050
; may have to be put back in.						;050
;
;	CMP	R2,#496.	;Too much?				;021
;	BLE	220$		;No R2 = amount of XBUF to allocate	;050
;	MOV	#496.,R2	;Lets trim it to the Max XBUF allowed	;021
220$:	CMP	R2,#MINXBF	;Too little allocated?			;050
	BLO	230$		;Yes, allocate minimum			;030
	CALL	SHFXBF		;Now lets find a place to put it.	;014
	BCC	50$		;Piece o'cake				;030
230$:	MOV	#MINXBF,R2	;Problems, try a minimal amount of XBUF	;050
	CALL	SHFXBF		;How 'bout now?				;030
	BCC	50$		;Okay, we're starting minimally		;030
	MESSAG	<"Can't RESET memory table - Not enough room"<200>>	;050
	EXIT			;Say we're sorry, and get out.		;050

30$:	MESSAG	<"Not enough room in low memory for monitor"<200>>,NOEXEC
50$:	RETURN

.DSABL	LSB

.SBTTL  SHFODT - Shuffle ODT.SYS to a new memory range			;015

;+
;  SHFODT - Shuffle ODT.SYS to a new memory range			;015+
;
;	R2	= Requested length of memory entity
;
;	CALL	SHFODT
;	
;	If C-bit clear;
;		Requested memory range is allocated to entity
;		T.ODT     = new base for entity				;050
;		T.ODT+2 = requested length for memory entity		;050
;
;	If C-bit set;
;		Requested memory was not allocated to entity
;		T.ODT     is cleared					;050
;		T.ODT+2	  is cleared					;050
;
;	All  registers are preserved
;-

	.ENABL	LSB

SHFODT:	CLR	@#T.ODT		;Assume failure				;050
	CLR	@#T.ODT+2	;  by removing ODT from memory list	;050
	PUSH	<R4,R0,R1,R2>	;Save some registers
	BEQ	60$		;R2 = Zero length? Return with C clear	
	MOV	ENDIN$,R0	;Start searching above the end of INIT
	MOV	#U.ODT,R4	;R4 = the type we can accept as usable	;050
	CALL	FNDLOW		;Allocate ODT memory at lowest possible addr.
	BCS	60$		;Not enough memory! Exit with C-bit set. ;030
	MOV	#ODTUPL,R4	;Get upper limit			;030
	SUB	R2,R4		;Minus size of ODT			;030
	CMP	R4,R0		;Is it below our upper limit?		;034
	BLO	60$		;  No! Exit with C-bit set (BLO = BCS)	;030
	MOV	R0,@#T.ODT	;Reset new base for ODT.SYS		;050
	MOV	R2,@#T.ODT+2	;Reset new length for ODT.SYS		;050
	BR	60$		;Return (Restoring registers)

.SBTTL  SHFXBF - Shuffle XBUF to a new memory range			;015
;+
;  SHFXBF - Shuffle XBUF to a new memory range				;015+
;
;	R2	= Requested length of memory entity
;
;	CALL	SHFXBF
;	SHFXBF will attempt to allocate XBUF at the highest possible 
;	memory address < 512Kw. If there is not at least 8K of free
;	memory left for the RSTS loader between the end of INIT and
;	124Kw, then SHFXBF will attempt to allocate XBUF at the lowest
;	possible memory address. If there is still not enough free
;	memory for the RSTS loader, we will return with C set.		;050
;
;	If C-bit clear:	Requested memory range is allocated to entity
;			T.CACH     = new base for entity		;050
;			T.CACH+2 = requested length for memory entity	;050
;	If C-bit set:	Not enough memory was found for XBUF.
;			T.CACH and T.CACH+2 are undefined.		;050
;
;	All  registers are preserved
;-
SHFXBF:	PUSH	<R4,R0,R1,R2>	;Save some registers
	BEQ	60$		;R2 = Zero length? Return with C clear	
	MOV	MAXMEM,R0	;Set our upper limit for the search	;020
	MOV	#U.CACH,R4	;R4 = the type we can accept as usable	;050
	CALL	FNDHI		;Allocate XBUF memory at highest possible addr
	BCS	50$		;Not enough available memory! Exit with C set.
	MOV	R0,@#T.CACH	;Reset new base for XBUF		;050
	MOV	R2,@#T.CACH+2	;Reset new length for XBUF		;050
	MOV	R2,D.XMAP	;Set default length of perm. MAPPED XBUF
	CMP	R2,MAPXBF	;Is it more than we can map?		;056
	BLE	40$		;No, we'll try to map all of it.
	MOV	MAPXBF,D.XMAP	;  else top it off at what we can map	;056
40$:	CLC			;Clear C-bit for success
	BR	60$		;  the exit
                
50$:	SEC			;Indicate failure			;050
60$:	POP	<R2,R1,R0,R4>	;Restore the registers			;020
	RETURN			;Return					;015-
.DSABL	LSB


.SBTTL	MEMORY TABLE SUBOPTION - IDSPACE

.ENABL	LSB

OPTION	IDSPACE

	BNE	30$		;They already told us			;0xx
10$:	CALLX	ASKER,R5	;They didn't say, so ask		;0xx
	 .WORD	20$		;SHORT FORM
	 GENTXT
	  .ASCII <12>
	  .ASCII "    Enter ON to enable use of monitor D- space."<200>
	  .ASCII "    Enter OFF to disable use of monitor D- space."
	  .ASCII <200>
20$:	  .ASCIZ <177><12>"    ON or OFF? "
	 UNORG
30$:	CMP	(R1),#12	;<LF> TO EXIT?
	BEQ	120$		;YES
	CMP	(R1),#'Z-100	;^Z TO EXIT?
	BEQ	120$		;YES
	CLR	R0		; assume turn D ON			;0xx
	CMPB	(R1)+,#'O	; Is it ON/OFF?				;0xx
	BNE	10$
	CMPB	(R1),#'N	; ON?					;0xx
	BEQ	50$		; YES! we found it			;0xx
	CMPB	(R1)+,#'F	; OFF?					;0xx
	BNE	10$		; NO, so try again			;0xx
	CMPB	(R1),#'F	; Really OFF?				;0xx
	BNE	10$		; NO, so try again			;0xx
	COM	R0		; make it a -1 to turn it off		;0xx
50$:	TSTB	1(R1)		;Anything else?				;0xx
	BNE	10$		; Yes, so try again			;0xx
	CMPB	R0,@#D.LB+LBNODS ;Any changes?				;0xx
	BEQ	120$		; No, so just exit			;0xx
	MOVB	R0,@#D.LB+LBNODS ; set the D- Space state		;0xx
	CALL	LAYMON		;Re-lay the monitor			;0xx
	CALL	MTBLCK		;Check for shuffle or reset memory table;0xx
120$:	RETURN			; All done now, time to go home.	;0xx

.DSABL	LSB

.SBTTL	MEMORY TABLE SUBOPTION - LOCK/UNLOCK MEMORY

.ENABL	LSB

OPTION	LOCK	

	BNE	30$		;SKIP QUESTION IF PRESET ANSWER
10$:	CALLX	ASKER,R5	;ASK A QUESTION
	 .WORD	20$		;SHORT FORM
	 GENTXT
	  .ASCII <12>
	  .ASCII "    Enter the address of the 1K memory section to lock."<200>
	  .ASCII "    Enter two addresses separated by a dash to lock an entire region."
	  .ASCII <200>
20$:	  .ASCIZ <177><12>"    Lock address is? "
	 UNORG
30$:	CALL	70$,R5		;CALL COMMON CODE FOR LOCKED MEMORY
	 .WORD	INUSE		;"PART OF THAT AREA IS ALREADY IN USE"
	 BR	10$		;ERROR, TRY AGAIN
	BISB	R2,(R4)		;CALLED BACK FROM COMMON CODE TO LOCK
	RETURN

OPTION	UNLOCK

	BNE	60$		;SKIP QUESTION IF PRESET ANSWER
40$:	CALLX	ASKER,R5
	 .WORD	50$
	 GENTXT
	  .ASCII <12>
	  .ASCII "    Enter the address of the 1K memory section to unlock."<200>
	  .ASCII "    Enter two addresses separated by a dash to unlock an entire region."<200>
50$:	  .ASCIZ <177><12>"    Unlock address is? "
	 UNORG
60$:	CALL	70$,R5		;CALL COMMON CODE FOR UNLOCKED MEMORY
	 GENTXT	<"    Part of that area is not locked"<200>>
	 BR	40$		;ERROR, TRY AGAIN
	BICB	R2,(R4)		;CALLED BACK FROM COMMON CODE TO UNLOCK
	RETURN

70$:	MOV	(R5)+,R3	;GET ERROR TEXT IN CASE NOT ALL RIGHT
	TST	(SP)+		;DUMP OLD R5
	CMP	(R1),#12	;<LF> TO EXIT?
	BEQ	120$		;YES
	CMP	(R1),#'Z-100	;^Z TO EXIT?
	BEQ	120$		;YES
	CALL	GET2AD		;GET AN ADDRESS RANGE
	BCS	80$		;ERROR, JUST RETURN
	MOV	#U.LOCK,R4	;Type of memory is LOCKED.		;050
	TST	R2		;1K Address specified?			;034
	BNE	75$		;No, so R2 is fine			;034
	INC	R2		;Set lock size = 1K			;034
75$:	CALL	CHKMEM		;CHECK FOR ENTIRE RANGE LOCKED OR USER
	BCC	90$		;OK, GO CHANGE IT
	MOV	R3,R0		;COPY POINTER TO ERROR TEXT
	CALLX	ASCIZ0		;AND PRINT IT
80$:	TSTB	PREST1		;PRESET ANSWER?
	BNE	120$		;YES, DON'T ASK AGAIN
	JMP	(R5)		;BACK TO TRY AGAIN

90$:	MOV	R2,R1		;COPY NUMBER OF K TO DO
	CALLX	FIXREG		;CHANGE START K TO BIT AND BYTE
	MOVB	BITBYT(R2),R2	;GET BIT MASK
	ADD	#T.LOCK,R4	;R4 -> Bit table for LOCKed memory.	;050
100$:	CALL	2(R5)		;SET OR CLEAR A BIT
	ASLB	R2		;NEXT BIT
	BCC	110$		;SAME BYTE
	INC	R4		;NEXT BYTE
	INC	R2		;FIRST BIT
110$:	SOB	R1,100$		;NEXT K
120$:	RETURN

.DSABL	LSB

GLOBAL	<BITBYT>							;050


.SBTTL	RING SUBOPTION - Ethernet/[T]MSCP ring size questions

.ENABL	LSB

OPTION	UDA

	CLR	RLYFLG		;Say monitor is fine			;056
	BR	UDARNG		;Ask [T]MSCP only			;045

OPTION	RINGS

	NOP
	CLR	RLYFLG		;Say monitor is fine			;045
	CALL	DEVASK,R3,<XE.PKT,D.ERNG,40$,50$,60$,70$,80$,RNGASK,140$>
				;Ask for UNA type ring sizes		;045
	BCS	20$		;Early exit				;045
	CALL	DEVASK,R3,<XH.PKT,D.HRNG,40$,50$,60$,70$,80$,RNGASK,140$>
				;Ask for QNA type ring sizes		;045
	BCS	20$		;Early exit				;045
UDARNG:	TST	CNT.DU		;Were any disks genned in this monitor?	;045
	BEQ	10$		;No, then try for tapes			;045
	CALL	DEVASK,R3,<RU.PKT,D.RRNG,90$,100$,110$,120$,130$,MCPASK,170$>
				;Ask for MSCP type ring sizes		;045
	BCS	20$		;Early exit				;045
10$:	TST	CNT.MU		;Were any tapes genned in this monitor?	;045
	BEQ	20$		;No, see if monitor needs re-laying	;045
	CALL	DEVASK,R3,<MU.PKT,D.MRNG,90$,100$,110$,120$,130$,MCPASK,170$>
				;Ask for TMSCP type ring sizes		;045
20$:	TST	(PC)+		;Do we need to re-lay the monitor?	;045
RLYFLG:	.WORD	0		;Flag for re-laying monitor		;045
	BEQ	30$		;No.					;045
	CALL	LAYMON		;Re-lay the monitor
	CALL	MTBLCK		;Check for shuffle or reset of memory table
30$:	RETURN								;045

	GLOBAL	<XE.PKT,D.ERNG,XH.PKT,D.HRNG>				;045
	GLOBAL	<CNT.DU,RU.PKT,D.RRNG,CNT.MU,MU.PKT,D.MRNG>		;045

	I.MESS								;045
40$:	 .ASCII <200>"Ethernet controllers (XE/XH) communicate with the"<200>
	 .ASCII "host processor through a ring queue reserved by each"<200>
	 .ASCII "driver to process transmissions and receptions."<200><12>
	 .ASCII "Inceasing the number of ring entries may improve I/O"<200>
	 .ASCII "performance but will also increase monitor size."<200><12>
	 .ASCII "The number specified can be between 1 and 127"<200><12>
	 .ASCIZ "Enter new number of entries, or <CR> for no change: "

50$:	 .ASCII	" transmit ring entries <"
60$:	 .ASCIZ	"xxx???> "

70$:	 .ASCII	" receive ring entries <"
80$:	 .ASCIZ	"xxx???> "

90$:	 .ASCII <200>"[T]MSCP class (RU/MU) controllers communicate with the"<200>
	 .ASCII "host processor through a ring queue reserved by each"<200>
	 .ASCII "driver for commands and responses to process requests."<200> 
	 .ASCII "Each controller can retrieve and internally store a"<200>
	 .ASCII "number of requests depending upon the controller."<200><12>
	 .ASCII "Inceasing the number of ring entries may improve I/O"<200>
	 .ASCII "performance but will also increase monitor size."<200><12>
	 .ASCII "The number specified can not exceed the maximum number"<200>
	 .ASCII	"of entries the controller can internally store, and must"<200>
	 .ASCII "be specified as a power of 2."<200><12>
	 .ASCIZ "Enter 1, 2, 4, 8 or <CR> for current ring size: "

100$:	 .ASCII	" command ring size <"
110$:	 .ASCIZ	"xxxxx?> "

120$:	 .ASCII	" response ring size <"
130$:	 .ASCIZ	"xxxxx?> "
	UNORG

140$:	CALLX	DECINP		; Get the number typed			;045
	BNE	150$		; Has to be a number			;045
	TST	R0		; Greater than zero?			;045
	BLE	150$		; Bad number				;045
	CMP	R0,#128.	; Less than or equal to 127?		;045
	BLO	160$		; Good number				;045
150$:	MESSAG	<<177>"    Must be between 1 and 127."<200>>		;045
	SEC			; Indicate bad number			;045
	RETURN								;045

170$:	CALLX	DECINP		; Get the number typed			;045
	BNE	190$		; Has to be a number
	TST	R0		; Greater than zero?			;045
	BLE	190$		; Bad number				;045
	CMP	R0,#16.		; Less than 16?				;048
	BGE	190$		; Bad number				;048
	CLR	R2		; Preset answer to 0**2 (1)
	MOV	R0,-(SP)	; Their answer must be a power of 2
	DEC	(SP)		; So get a bit mask from the answer
	BITB	R0,(SP)+	; To test for a valid response
	BNE	190$		; Bad number
180$:	ASR	R0		; Shift real number
	BCS	200$		; Return when we find the bit that was set
	INC	R2		; Increment R2 up to next power of 2
	BR	180$		; Keep shifting

190$:	MESSAG	<<177>"    Must be 1, 2, 4 or 8."<200>>
	SEC			; Indicate bad number
	RETURN			; Go back with C=1

200$:	MOV	R2,R0		; Return good number in R0		;045
160$:	CLC			; Indicate good number			;045
	RETURN

MCPASK:	REGSCR			;Save the world				;045
	MOV	#1,R0		;Initialize R0 to lowest ring size possible ;045
	ASH	TOS.R0(SP),R0	;Make a real number in R0 from default	;045
	BR	210$		;Continue in common code		;045

RNGASK:	REGSCR			;Save the world				;045
210$:	CALLX	DECSTR		;Print the default			;045
220$:	CALLX	TYPDEV		;Type the controller name		;045
	CALLX	ASKER,R5	;Ask the question			;045
230$:	 .WORD	0		;Short form				;045
240$:	 .WORD	0		;Long form				;045
	BCS	260$		;CTRL/Z means quit early		;045
	BEQ	260$		;<LF> or <CR> means no change, R0 valid	;045
	CALL	@2(R3)		;Verify the response			;045
	BCS	220$		;Not a valid answer, re-prompt		;045
	MOV	R0,TOS.R0(SP)	;Store the result			;045
260$:	RETURN			;Done with this question		;045

DEVASK:	MOV	(R3)+,R5	;Get pointer to device packet		;045
.ASSUME	PK.MXU EQ 0
	MOV	PK.CSO(R5),R4	;Get offset into CSRTBL for device	;045
	ADD	#CSRTBL,R4	;Point to begining of CSR's		;045
	MOV	(R3)+,R2	;Get pointer to ring defaults		;045
	MOV	(R3),240$	;Get long form question	(same for both	;066
				; 'Command' and 'Response' sections).	;066
	ADD	#12,R3		;Now, point R3 to the address of the	;066
				; question-asker routine.		;066
	MOVB	(R5),295$	;Get number of controller RSTS supports	;045
.ASSUME	PK.MXU	EQ 0
280$:	TST	(R4)		;Is this controller present?		;045
	BEQ	290$		;No, don't bother asking		;045
	DEC	RLYFLG		;We're gonna ask, so re-lay the monitor	;045
	MOV	-10(R3),230$	;Set up short form 'Command' question...;066
	MOV	-6(R3),R1	; ...and pointer to it's defaults.	;066
	MOVB	1(R2),R0	;Get the old command default		;045
	CALL	@(R3)		;Ask for a change			;045
	BCS	300$		;CTRL/Z typed				;045
	MOVB	R0,1(R2)	;Save the new default			;045
	MOV	-4(R3),230$	;Set up short form 'Response' question..;074
	MOV	-2(R3),R1	; ...and pointer to it's defaults.	;074
	MOVB	(R2),R0		;Get the old response default		;045
	CALL	@(R3)		;Ask for a change			;045
	BCS	300$		;CTRL/Z typed				;045
	MOVB	R0,(R2)		;Save the new default			;045
290$:	CMP	(R2)+,(R4)+	;Advance to next default and controller	;045
	DECB	(PC)+		;Decrement controller count		;045
295$:	.WORD	0
	BNE	280$		;More to do				;045
	CLC			;All done, no errors			;045
300$:	BIT	(R3)+,(R3)+	;Skip 'verify' address without changing	;066
				; the C bit.				;066
	RETURN	R3		;Return					;045

	GLOBAL	CSRTBL

.DSABL	LSB

.SBTTL	MEMORY TABLE SUBOPTION - CHANGE SMALL BUFFER POOL

;+
; INPUTS:
;	PREST1	<>	0 if user gave a preset answer to the "How many 
;			buffers" question.
;	R1	->	user's answer, if any.
;	T.XTRA	=	number of K of extra buffer space last requested by 
;			user, or number of K we can really use, whichever
;			is smaller.  (This is the default.)
;	Memory table (T.EXEC, T.ODT, T.CACH, A.NXM, T.LOCK) set up
;			according to current monitor size.
;
; CALL	M.BUFFERS
;
; OUTPUTS:
;	T.XTRA reflects user's response, but not more than we can really use.
;	T.EXEC updated.
;	Other memory table entries (T.ODT, T.CACH, T.LOCK) reset
;		if necessary.
;	Monitor layout (D.LB, the "load block") updated.
;
; SIDE EFFECTS:
;	All registers preserved.
;-

; INTERNAL VARIABLES:
;	R3	->	T.XTRA
;	R5	=	maximum number of extra K to add to monitor

.ENABL	LSB

OPTION	BUFFERS
	REGSCR			;Preserve all registers.
	MOV	#T.XTRA,R3	;Point at setting for amount of extra buffer
				; space.				;050
	PUSH	(R3)		;Save default setting.
	MOV	#99.,(R3)	;Request an absurd amount of extra space.
	CALL	LAYMON		;LAYMON will trim it to something reasonable.
	MOV	(R3),R5		;Get maximum number of extra K.
	POP	(R3)		;Put back the default.
	CALL	LAYMON		;Put the monitor layout back together.
	TSTB	PREST1		;Preset answer?
	BNE	50$		;Yes, go use it.

; Ask how much buffer space to allow.

	MOV	R5,R0		;Copy maximum number of extra K.
	MOV	#30$,R1		;Point to where it goes in the message.
	CALLX	DECSTR		;Convert it to ASCII.
	MOV	(R3),R0		;Get default number of extra K.
	MOV	#40$,R1		;Point to where it goes in the message.
	CALLX	DECSTR		;Convert it to ASCII.

10$:	MESSAG			;Display our prompt			;042
	  .ASCII <177><12>"  How many K words of extra buffer space (0K-"
30$:	  .ASCII "??????K) <"
40$:	  .ASCIZ "??????K>? "
	UNORG								;042

	CALLX	GETIN		;And get a response			;042
	BNE	50$		;Got something, good			;042

; They asked for help, so we'll give a little introductory text and then
; display a table of buffer counts for them

	 MESSAG								;042
	  .ASCII <177><12>
	  .ASCII "  Small buffers are a critical system resource."<200>
	  .ASCII "  Allocate more if your system is low on them."<200>
	  .ASCII "  The following table shows the total number of"<200>
	  .ASCII "  general and FIP buffers which you will get with"<200>
	  .ASCII "  each additional K-word allocated."<200>
	  .ASCII <12>
	  .ASCII "               General        FIP"<200>
	  .ASCII "  K-words      Buffers      Buffers"<200>
	  .ASCIZ "  =======      =======      ======="<200>
	UNORG

	MOV	(R3),-(SP)	;Save current amount of extra buffers	;042
	CLR	(R3)		;And start off with 0K worth		;042
45$:	MESSAG	<"  ">		;Start with two spaces			;042
	MOV	(R3),R0		;Get number of K-words for this time	;042
	CALL	DECPRT		;Print it out				;042
	MESSAG	<"K       ">	;Now a "K" and seven spaces please	;042
	CALL	SETBUF		;Set up number of buffers		;042
	CALL	DECPRT		;And print out general count		;042
	MESSAG	<"       ">	;Now seven more spaces			;042
	MOV	R2,R0		;Set up FIP pool count			;042
	CALL	DECPRT		;And print it out			;042
	MESSAG	<<200>>		;Now a CR/LF				;042
	INC	(R3)		;Set up for the next K			;042
	CMP	(R3),R5		;Are we done yet?			;042
	BLOS	45$		;No, so loop				;042
	MOV	(SP)+,(R3)	;Yes, so restore original buffer count	;042
	CALL	LAYMON		;Re-set up the monitor			;042
	BR	10$		;And ask again				;042

50$:	MOV	(R3),R0		;Guess that they accept the default	;042
	CMPB	(R1),#12	;Did they?				;042
	BEQ	70$		;Yes, go report number of buffers	;042
	CMPB	(R1),#'Z-100	;Control/Z?				;042
	BEQ	100$		;Yes, so quit				;042
	CALL	GET1AD		;Convert answer to binary, and put it in R0.
	BCS	60$		;Faulty syntax, go decide whether to reprompt.
	CMP	R0,R5		;Does the answer exceed the maximum?
	BLE	70$		;No.  Go tell him how many buffers he has.
	MESSAG	<"  Response too big"<200>>
				;We can't use all that space.  Tell him.
60$:	TSTB	PREST1		;Was it a preset answer?
	BNE	100$		;Yes.  Quit.
	BR	10$		;No.  Ask again.

; Lay out monitor and tell him how many buffers he has.

70$:	CALL	SETBUF		;Set up the buffer pool and get sizes	;042
	MOV	#95$,R1		;Point to general buffer text		;042
	CALL	DECSTR		;And convert it				;042
	MOV	R2,R0		;Get count of FIP pool buffers		;042
	MOV	#96$,R1		;Point to the text			;042
	CALL	DECSTR		;And convert it				;042

	MESSAG			;Now display it				;042
	 .ASCII	"  You have "
95$:	 .ASCII	"?????? general + "
96$:	 .ASCIZ	"?????? FIP small buffers."<200>
	 UNORG

MTBLCK:	CMP	@#MONSIZ,@#T.EXEC+2 ;Did we change the monitor size?
	BEQ	100$		;No, don't shuffle.
	MESSAG	<"  Adjusting memory table."<200>>
	CALL	SHFMEM		;Yes, shuffle memory table.
	CALL	M.LIST		;List it.
100$:	RETURN

.DSABL	LSB
GLOBAL	<D.LB,.$BUFS,.$BUFE,.$MBFE,.$MBFS>				;050

;+
; SETBUF - Set amount of extra memory for small buffer pool
;
;	R0 = Number of K words to use for buffer space
;	R3 -> T.XTRA							;050
;
;	CALL	SETBUF
;
;	R0 = Total number of general buffers
;	R2 = Total number of FIP pool buffers
;
; Monitor layout set up for new number of buffers (see LAYMON).
;-

SETBUF:	MOV	R0,(R3)		;Note how many K of extra space to allow. ;042
	CALL	LAYMON		;Lay out the monitor and get its size.
	MOV	#40-1,R2	;Get bit pattern for rounding to buffer	;042
				; multiples.
	MOV	@#.$BUFE,R0	;Get address of end of BUFPOL pool.
	BIC	R2,R0		;Round down to a small buffer boundary.	;042
	SUB	@#.$BUFS,R0	;Compute length of BUFPOL pool.
	BIC	R2,R0		;Round down to a small buffer multiple.	;042
	ADD	@#.$MBFE,R0	;Add address of end of MORBUF pool.
	BIC	R2,R0		;Round down to a small buffer boundary.	;042
	SUB	@#.$MBFS,R0	;Subtract address of beginning of MORBUF pool.
	BIC	R2,R0		;Round down to a buffer multiple, 	;042
				; giving (bytes of BUFPOL) + (bytes of MORBUF).
	ADD	@#D.LB+LBISPE,R0 ;Add address of end of I-space area.
	BIC	R2,R0		;Round down to a small buffer boundary.	;042
	SUB	@#D.LB+LBISPS,R0 ;Subtract address of beginning of I-space 
				; area.
	ASH	#-5,R0		;Convert to buffer count, rounding down, to get
				; (BUFPOL buffers) + (MORBUF buffers) 
				; + (D-space buffers).
	BIC	#174000,R0	;Clear possible propagation of sign bit.
	SUB	@#D.LB+LBEXPA,R0 ;Deduct buffers we turned into patch space.
	MOV	@#D.LB+LBFPLL,R2 ;Get size of FIP pool (MMU slivers).	;042
	ROL	R2		;Double it for FIP buffer count.	;042
	RETURN			;And we're done				;042

.SBTTL	MEMORY TABLE SUBOPTION - RESERVE XBUF SPACE

.ENABL	LSB

OPTION	XBUF
OPTION	CACHE

	;TSTB	PREST1		;Is there a preset answer?		;053
	BNE	60$		;If preset answer was given, don't	;053
				; ask the question.			;053
10$:	MOV	#MINXBF,R0	;Get minimum size allowed for XBUF.	;050
	MOV	#40$,R1		;And, where it goes.			;050
	CALLX	DECSTR		;Convert it to ASCII and put it in.	;050
	MOV	T.CACH+2,R0	;Latest size				;050
	MOV	#50$,R1		;Place ASCII text in message		;022
	CALLX	DECSTR		;Now, convert it.			;022
20$:	CALLX	ASKER,R5
	 .WORD	30$
	 GENTXT
	  .ASCII <12>
	  .ASCII "    Enter the amount of memory to be reserved for disk block"<200>
	  .ASCII "    caching and other system resources in 1K increments."<200> ;030
30$:	  .ASCII <177><12>"    Enter new extended buffer size ("	;050
40$:	  .ASCII "??????-496K) <"					;050
50$:	  .ASCIZ "??????K>? "
	 UNORG
	BEQ	110$		;QUIT ON CTRL/Z OR <LF>
60$:	MOV	#T.CACH,R5	;R5 -> Memory table element.		;050
	MOV	#U.CACH,R4	;R4 = Type (XBUF)			;050
	CLR	R0		;PRECLEAR IN CASE HE IS REMOVING
	CLR	R2
	CALL	GET2AD		;GET 2 ADDRESSES
	BCS	120$		;Address error, try again.		;053
	TST	R2		;Do they want INIT to find a range?	;020
	BEQ	80$		;Yes, so the rest should be easy.	;020
	CMP	R2,#MINXBF	;Do they want at least the minimum?	;050
	BLO	120$		;No, so go ask again.			;053
	CMP	R0,#XBFLOL	;TOO LOW FOR EXTENDED BUFFER POOL?
	BLO	70$		;YUP, ERROR
; Do more checks on the allocation

	MOV	R0,R1		;COMPUTE HIGH LIMIT
	ADD	R2,R1
	CMP	R1,#XBFUPL	;TOO HIGH FOR EXTENDED BUFFER POOL?
	BLOS	90$		;NO, GO CHECK THAT AREA
	CMP	R0,#XBFLOL+1000	;HOW ABOUT 528-1024			;019
	BLO	70$		;NOPE, TO LOW				;019
	CMP	R1,#XBFUPL+1000	;1024 TOP ADDRESS			;019
	BLOS	90$		;YES, SO OK				;019
	CMP	R0,#XBFLOL+2000	;1040-1536				;019
	BLO	70$		;1024 - 1040 ILLEGAL			;019
	CMP	R1,#XBFUPL+2000	;1536 TOP ADDRESS			;019
	BLOS	90$		;YES, SO OK				;019
	CMP	R0,#XBFLOL+3000	;1552-2048				;019
	BLO	70$		;1536 - 1552 ILLEGAL			;019
	CMP	R1,#XBFUPL+3000	;2048 TOP ADDRESS			;019
	BLOS	90$		;OK!!					;019
70$:	MESSAG
	 .ASCII	"    Extended buffer space not in range 16K to 511K"<200>
	 .ASCII	"                      or               528K to 1023K"<200>
	 .ASCII	"                      or               1040K to 1535K"<200>
	 .ASCIZ	"                      or               1552K to 2047K"<200>
	 UNORG
	BR	120$		;Try again.				;053

80$:	CMP	R0,#MINXBF	;Do they want at least the minimum?	;050
	BLO	120$		;Nope.  Go ask again.			;053
	MOV	R0,R2		;Use the 1st value entered as the size	;020
	CALL	SHFXBF		;Now allocate it			;020
	BCC	110$		;If C bit clear, then XBUF is all set up;020
	ERF	<"Not enough memory for required XBUF!!">		;050

90$:	CALL	CHKMEM		;CHECK OUT MEMORY
	BCC	100$		;IN RANGE
	MESSAG	<"    Part of that area is already in use"<200>>,INUSE	;038
	BR	120$		;Try again.				;053

;	Set-up for a new XBUF range

100$:	MOV	R0,(R5)+	;MOVE IN BASE
	MOV	R2,(R5)+	;AND LENGTH
	MOV	R2,D.XMAP	;SET DEFAULT LENGTH OF MAPPED XBUF
	CMP	R2,MAPXBF	;Is it more than we can map?		;056
	BLOS	110$		;NO, LEAVE IT AS IS
	MOV	MAPXBF,D.XMAP	;Otherwise top it out at what we can map ;056
110$:	RETURN

;+
; Here's where we come if the K or K range specified turns out to be	;053
; bogus.								;053
;-

120$:	TSTB	PREST1		;Was the bogus answer a preset one?	;053
	BEQ	20$		;No, so just ask the question again.	;053
	CLRB	PREST1		;Otherwise, say preset answer is NFG	;053
	BR	10$		; and go back to fill in the proper	;053
				; defaults in the Help text.		;053

.DSABL	LSB

GLOBAL	<D.XMAP>


.SBTTL	CHECK FOR 'REMOVE' AS AN ANSWER

CHKREM:	MOV	R0,-(SP)	;SAVE R0
	CALLX	GETUNQ,R5	;CHECK FOR UNIQUE TEXT
	 GENTXT
	 UNQTXT	<RE\MOVE>
	 .BYTE	0		;END
	 UNORG
	MOV	(SP)+,R0	;RETURN C=0 IF 'REMOVE', C=1 IF NOT
	BITB	(R1),(R1)	;IS THAT ALL?
	BEQ	10$		;YES
	SEC			;NO, FORCE C=1 FOR FAILURE
10$:	RETURN


.SBTTL	MEMORY TABLE SUBOPTION - LOCATE ODT

.ENABL	LSB

OPTION	ODT

	MOV	ODTSIZ,R2	;Did we find ODT.SYS?			;030
	BNE	10$		;YES
	MESSAGE	<"    ODT.SYS does not exist."<200>>
	RETURN

10$:	ADD	#2047.,R2	;Round ODT size up to K			;030
	ASH	#-11.,R2	;Shift it				;030
	BIC	#^C<77>,R2	;Isolate odt bits			;030
	MOV	#ODTUPL,R0	;Get high address for ODT		;030
	SUB	R2,R0		;Minus size of ODT			;030
	MOV	R1,-(SP)	;Save KBUFF pointer			;030
	MOV	#28$,R1		;Point to place for message		;030
	CALLX	DECSTR		;...and put it in			;030
	MOV	ENDIN$,R0	;Get low address for ODT		;030
	MOV	#27$,R1		;Point to place for message		;030
	CALLX	DECSTR		;...and put it in			;030
	MOV	(SP)+,R1	;Restore KBUFF pointer			;030
	TSTB	PREST1		;PRESET ANSWER?
	BNE	40$		;YES, USE IT
20$:	TSTB	PREST1		;PRESET ANSWER?
	BNE	100$		;YES, DON'T ASK AGAIN
	MOVB	#176,30$	;Ensure prompt is how we expect it	;037
	CALLX	ASKER,R5	;ASK FOR ODT ADDRESS
	 .WORD	30$		;SHORT TEXT				;037
	 GENTXT
	  .ASCII <12>
	  .ASCII "    Enter the address at which ODT is to begin."	;030
25$:	  .ASCII <200>"    ODT must be between "			;030
27$:	  .ASCII "??????K and "						;030
28$:	  .ASCII "??????K."<200>					;030
30$:	  .ASCIZ <176><177><12>"    ODT address is? "			;037
	 UNORG
	BEQ	50$		;QUIT ON CTRL/Z OR <LF>
40$:	MOV	#T.ODT,R5	;R5 -> Memory table element for ODT	;050
	CALL	CHKREM		;CHECK FOR 'REMOVE'
	BCS	60$		;NO
	CLR	(R5)+		;YES, DO SO
	CLR	(R5)+
50$:	RETURN

GLOBAL	<ODTSIZ>							;050

60$:	MOV	#U.ODT,R4	;R4 = Type (ODT)			;050
	CALL	GET1AD		;GET THE ANSWER
	BCS	20$		;INVALID, REPEAT THE QUESTION
	CMP	R0,ENDIN$	;TOO LOW?
	BLO	70$		;YES
	MOV	#ODTUPL,-(SP)	;COMPUTE HIGH ADDRESS
	SUB	R2,(SP)		;LESS ODT SIZE
	CMP	R0,(SP)+	;DOES IT ALL FIT?
	BLOS	80$		;YES, IT'S OK BY US
70$:	CLRB	30$		;Make ODT limits an ASCIZ string	;037
	CALLX	MESSAG,R5,25$	;No, tell user where he can put it	;037
	MOVB	#176,30$	;Put string back to normal		;037
	BR	20$		;TRY AGAIN

80$:	CALL	CHKMEM		;CHECK OUT THAT REGION
	BCC	90$		;OK
	CALLX	MESSAG,R5,INUSE	;NO, PART IS IN USE
	BR	20$		;TRY AGAIN

90$:	MOV	R0,(R5)+	;SET UP ODT ADDRESS
	MOV	R2,(R5)		;ODT LENGTH IN K
100$:	RETURN

.DSABL	LSB

GLOBAL	<ODTSIZ>

.SBTTL	LOOK UP ODT.SYS FILE AND VALIDATE IT

.ENABL	LSB

FNDODT:	CLR	ODTSIZ		;ASSUME WE WON'T FIND ODT
	MOV	#FQODT,R4	;POINT TO ODT FIRQB
	CALLX	LOKFIL		;LOOK IT UP
	BCS	10$		;NOT FOUND, TOO BAD
	CALLX	SILNDX,R5,FQODT	;READ AND VALIDATE THE SIL INDEX
	BNE	20$		;BAD INDEX
	MOV	#SILBUF,R1	;POINT TO START OF THE SIL INDEX
	CMP	(R1)+,#1	;SHOULD ONLY BE ONE MODULE THERE
	BNE	30$		;NOT THIS TIME
	CMP	SE.LOD(R1),#140000 ;CHECK LOAD ADDRESS
	BNE	40$		;BAD LOAD ADDRESS
	MOV	SE.SIZ(R1),R0	;GET SIZE (IN BYTES)
	CMP	R0,#100		;IS IT INSANELY SMALL?
	BLO	40$		;YES, REJECT IT
	CMP	R0,#20000	;IS IT TOO LARGE (MAX OF 4K WORDS)?
	BHI	40$		;YES, REJECT THAT TOO
	MOV	R0,ODTSIZ	;OTHERWISE STORE SIZE
10$:	RETURN

20$:	MESSAG	<<177><12>"ODT.SYS is not a SIL."<200>>
	RETURN

30$:	MESSAG	<<177><12>"ODT.SYS has too many modules."<200>>
	RETURN

40$:	MESSAG	<<177><12>"ODT.SYS has invalid size or load address."<200>>
	RETURN

.DSABL	LSB

GLOBAL	<ODTSIZ,FQODT,SILBUF>



.SBTTL	FIX TABLES FOR MEMORY TABLE SUBOPTION

	TMPORG	MEMOTB		;IN THE MEMORY SUBOPTION DISPATCH TABLE
	 .WORD	M.XXXX		;GENERATE POINTER TO ILLEGAL ANSWER
	TMPORG	MEMOTX		;IN THE TEXT TABLE
	 .BYTE	0		;END THE STRING
	UNORG

M.XXXX:	MESSAG	<"  Illegal suboption given"<200>>
	RETURN			;EASY TO DO

; NOW UNDEFINE THE OPTION MACRO SO THAT WE DON'T ASSEMBLE ANY MORE

.MACRO	OPTION	NAME
.ERROR	;TABLE OPTION NOT LEGAL NOW
.ENDM	OPTION

.SBTTL	DETERMINE PARITY CONFIGURATION OF MEMORY

.ENABL	LSB
;+
; ROUND UP THE MEMORY SCANNER BASE ADDRESS
;
;	THE MEMORY PARITY SCANNER ROUTINE SAVES THE FIRST TWO WORDS
;	OF EACH KW OF MEMORY, MODIFIES THEM TO CONTAIN BAD PARITY,
;	ACCESSES THEM, AND CHECKS TO SEE WHICH (IF ANY) CONTROLLER
;	THEY ARE ASSOCIATED WITH. IT THEN RESTORES THE TWO WORDS TO
;	THEIR ORIGINAL STATE. THEREFORE, THE SCANNER ITSELF MUST NOT
;	CROSS A 1K BOUNDARY, SINCE IT WOULD MODIFY ITSELF. THIS
;	ROUNDING FACTOR GUARANTEES THAT SYMBOL MSBNDL AND MSBNDH
;	ARE WITHIN THE SAME 1K OF MEMORY.
;-

	.BLKW0	110,0		;THIS VALUE MUST BE DETERMINED MANUALLY


; CLEAR OUT THE PARITY TABLES

PARITY:	CLR	R0		;CLEAR OUT PARITY MEMORY TABLES
	MOV	#<2048.-4.>,R1	;Initialize the whole table.		;067
10$:	PUTPAR	R0,#177400	;SPECIAL CODE FOR MEMORY W/O PARITY
	TST	(R0)+		;ADVANCE THE TABLE POINTER
	SOB	R1,10$
	PUTPAR	R0,#0		;END TABLE IN A ZERO
	MOV	#PARLOC,R0	;SET EACH CSR POINTER TO NO PARITY REG
	MOV	#16.,R1		;16 TO CLEAR
20$:	CLR	PARRNG-PARLOC(R0) ;EACH RANGE IS PARITY WITH ADDRESSES
	CLR	(R0)+		;SET TO NO REGISTER THERE
	SOB	R1,20$
	CLR	PARUNI		;INDICATE NO UNIBUS PARITY YET
	CLR	ECC70		;INDICATE NO 11/70 ECC YET
30$:	CALLX	KPARSU		;SET UP THE MMU

; LOCATE PARITY CSR'S, DETERMINE WHICH HAVE ADDRESS DATA

	MOV	#PARCSR,R0	;START LOOKING FOR PARITY CSR'S HERE
	MOV	#7750,R1	;BITS EXIST IF PARITY CSR HAS ADDRESSES/ECC
	MOV	#PARLOC,R2	;R2 -> TABLE OF CSR LOCATIONS
	MOV	#16.,R3		;16 POSSIBLE LOCATIONS
;
;BYPASS SCAN ON AN 11/70 OR 11/74'S. THE 11/70 MEMORY CSR'S ON NOT ACCESSABLE
;ON AN 11/70 SO THE CODE WILL ALWAYS TRAP TO 4. ON 11/74'S THE REGISTER'S ARE
;ACCESSABLE HOWEVER SCANNING THEM WILL DISABLE PARITY DETECTION. 
;SEE PATCH SEQ 1.1.7 OF V7.0
;
40$:	TST	HWSIZE		;IF WE ON AN 11/70 OR 11/74
	BNE	80$		;	THEN DON'T DO MEMORY CSR SCANNING.
	CALLX	TRASEC		;SET CARRY ON TRAP
	CLC			;PRECLEAR THE CARRY
	MOV	R1,(R0)		;TRY TO LOAD MAGIC BITS (*MAY TRAP*)
	CALL	@(SP)+		;FIX TRAP TO 4
	BCS	80$		;TRAPPED, SO NO REGISTER THERE
	MOV	R0,(R2)		;AHA, NO TRAP, SO SET CSR ADDR IN PARLOC
	BIT	#10,(R0)	;THIS IS ECC IF INHIBIT MODE POINTER BIT ON
	BEQ	60$		;NO ECC
	BIS	#010000,PARRNG-PARLOC(R2) ;YES, FLAG ECC MEMORY WITH ADDR
	MOV	#1,(R0)		;SET MEMORY IN NORMAL STATE		;003
	BR	70$		;COUNT UNIBUS PARITY REGISTER		;003

60$:	BIT	R1,(R0)		;DID THE MAGIC BITS STAY ON?
	BNE	70$		;YES INDEED, WE FOUND an address PARITY CSR
	BIS	#100000,PARRNG-PARLOC(R2) ;NO, FLAG NON-ADDRESS PARITY
70$:	INC	PARUNI		;COUNT ONE MORE UNIBUS PARITY REGISTER
80$:	ADD	#2,R0		;BUMP TO NEXT POSSIBLE CSR LOCATION
	TST	(R2)+		;AND BUMP OUR TABLE POINTER
	SOB	R3,40$		;TRY 'EM ALL

GLOBAL	<ECC70,PARUNI,PARLOC,PARRNG>

	TST	HWSIZE		;IS THIS AN 11/70?
	BEQ	90$		;NO -- CHECK MEMORY SIZE
	JMP	310$		;YES -- ALL DONE

; CHECK THE CODE LOCATION TO ENSURE THAT IT WON'T CLOBBER ITSELF

90$:	MOV	#270$,R0	;GET HIGH ADDRESS
	MOV	#MSBNDL,R1	;GET LOW ADDRESS
	XOR	R1,R0		;SEE IF ADDRESSES CROSS A K BOUNDARY
	BIT	R0,#^C<3777>	;IS ANY CODE IN THE FIRST 2 WORDS OF A K?
	BEQ	110$		;NO, WE CAN RUN
100$:	ERF	<"INIT bug - can't check parity">

110$:	MOV	#PARLOC,R0	;check PARLOC crossing APR boundary	;063
	BIC	#^C<3777>,R0	;just check LO				;063
	CMP	R0,#3740	;Are we crossing boundary?		;063
	BHI	100$		;no, so everything is a-ok		;063
	CMP	#CACHCL,#140000 ;DOES THIS CODE OVERLAP APR6?
	BHI	100$		;YES, THEN IT WON'T WORK
	TSTB	CACHE		;IS THERE A CACHE?
	BMI	120$		;NO
	MOV	#15,@#CHECTL	;YES, DISABLE IT			;078
	CMP	CPTYP,#5	;IS THIS A J11 SYSTEM?			;078
	BEQ	120$		; YES, so its disabled properly		;078
	MOV	#17,@#CHECTL	;No, so DISABLE IT properly

; LOOP FOR EACH K OF MEMORY

120$:	CLR	R0		;OK, EXAMINE EACH K OF POSSIBLE CORE
130$:	MOV	R0,R1		;COPY K NUMBER * 2
	ASH	#11.-1-6,R1	;SHIFT FOR ADDR (-1 FOR K*2) (-6 FOR MMU)
	MOV	R1,@#KISAR6	;WINDOW THIS K TO 140000-157777
	MOV	#1,@#MMUSR0	;TURN ON THE MMU, PLEASE

; DETERMINE IF THIS K EXISTS

	MOV	#-4,R4		;PRESET R4 TO NXM CODE
	MOV	#140000,R1	;R1 -> WINDOW TO GO TO THIS BANK
	CALLX	TRASEC		;TAKE OVER TRAP TO 4
	CLC			;PRECLEAR CARRY
	MOV	(R1),R2		;GET START WORD OF BANK (**MAY TRAP**)
	CALL	@(SP)+		;RESTORE TRAP TO 4
	BCS	270$		;OOPS, NXM.  GO SET CODE & DONE W/ BANK
	MOV	@#140002,R1	;R1 = SECOND WORD OF BANK
MSBNDL::			;MEMORY SCANNER LOW-END BOUNDARY
	MOV	#3,@#140000	;PRESET 0011110 INTO ECC CHECK BITS
	MOV	#5,@#140002	;OR FUNNINESS IF INTERLEAVED

; K EXISTS.  SET EVERY PARITY REGISTER TO WRITE INVALID PARITY

	MOV	#PARLOC,R3	;WE HAVE THE DATA. NOW, FOR EACH CSR
	MOV	#16.,R4		; OUT OF A POSSIBLE 16
150$:	MOV	(R3)+,R5	;GET A CSR
	BEQ	160$		;IF NONE HERE, SKIP IT
	MOV	#7044,(R5)	;SET PARITY CSR TO WRITE INVALID PARITY (ECC)
160$:	SOB	R4,150$

; REWRITE THE WORDS.  IF THIS K IS PARITY, REWRITE W/ INVALID PARITY

	BIC	#3,@#140000	;WRITE WRONG PARITY OR
	BIC	#5,@#140002	; GIVE DOUBLE BIT ERROR IF ECC

GLOBAL	<CACHE,PARLOC,KTUSR3,CPTYP>					;078

; RESET ALL PARITY REGISTERS TO WRITE WITH VALID PARITY

	MOV	#PARLOC,R3	;ONCE AGAIN, SCAN ALL PARITY CSR'S
	MOV	#16.,R4
170$:	MOV	(R3)+,R5	;GET PARITY CSR
	BEQ	180$		;NONE THERE
	CLR	(R5)		;TURN OFF INVALID PARITY WRITER IN CSR
180$:	SOB	R4,170$		;LOOP

; REREAD FIRST 2 WORDS OF THIS BANK.  IF PARITY, SET ERROR IN PARITY CSR

	TST	@#140000	;NOW READ OUT THE WORDS
	TST	@#140002	;  WHICH MIGHT SET A PARITY ERROR

; SCAN ALL PARITY REGISTERS LOOKING FOR AN ERROR

	MOV	#PARLOC,R3	;ONCE AGAIN, SCAN ALL THE PARITY CSR'S
	MOV	#16.,R5
190$:	MOV	(R3)+,R4	;GET A CSR ADDRESS
	BEQ	200$		;NONE THERE
	TST	(R4)		;CHECK THIS CSR FOR AN ERROR
	BMI	210$		;WE GOT IT! THIS CONTROLS THIS BANK!
200$:	SOB	R5,190$		;LOOK HARD FOR A PARITY CSR W/ERROR ON

; NO REGISTER HAD AN ERROR, SO THIS K IS NON-PARITY

	MOV	(PC)+,R4	;SORRY, NO PARITY HERE
	 .BYTE	0,-1		;SO SET UP FLAG FOR EXISTS BUT PLAIN
	BR	230$		;SET R4=-1 TO FLAG THAT, AND DO NEXT K

; ERROR FOUND, SO MEMORY IS PARITY.
; IF NO ADDRESS, CONTINUE SCAN FOR SECOND ERROR TO CHECK FOR INTERLEAVED

210$:	BIC	#^C<36>,R4	;GET CSR INDEX (0 TO 16*2 STEP 2)
	TST	PARRNG(R4)	;IS THIS A NON-ADDRESS CONTROLLER?
	BMI	230$		;YES, R4=INDEX, AND IT'S NOT INTERLEAVED
220$:	CMP	R3,#PARLOC+<16.*2> ;ARE WE AT THE LAST CSR?
	BHIS	230$		;YES, ONLY ONE ERROR => NOT INTERLEAVED
	MOV	(R3)+,R5	;NO, GET NEXT CSR
	BEQ	220$		;NONE THERE
	TST	(R5)		;DOES THIS CSR HAVE AN ERROR, TOO?
	BPL	220$		;NOPE, KEEP TRYING
	BIC	#^C<36>,R5	;YES YES, 2 ERRORS => INTERLEAVING
	BIS	#040000,PARRNG(R4) ;SET EVEN CSR TO INDICATE INTERLEAVE
	BIS	#060000,PARRNG(R5) ;SET ODD  CSR TO INDICATE ODD INTERLEAVE
	SWAB	R5		;PUT ODD CSR INDEX IN TOP BYTE
	BIS	R5,R4		;  OF R4 (NOTE SIGN BIT IS OFF)

GLOBAL	<PARLOC,PARRNG>

; WHETHER INTERLEAVED OR NOT, ADDRESS OR NOT, REWRITE THE WORDS TO GET
; VALID PARITY IN MEMORY

230$:	MOV	#PARLOC,R3	;POINT TO CSR TABLE
	MOV	#16.,R5		;COUNT, AGAIN
240$:	TST	(R3)+		;IS THERE A CSR HERE?
	BEQ	250$		;NO, SKIP WITH C=0
	MOV	#2,@-(R3)	;YES, DISABLE ECC IF APPLICABLE
	SEC			;INDICATE PARLOC POINTER BACK
250$:	MOV	R2,@#140000	;IN ANY CASE, REWRITE WORDS WITH
	MOV	R1,@#140002	;  THEIR CORRECT PARITY
	BCC	260$		;IF NO CSR, DONE THIS TIME
	CLR	@(R3)+		;ENABLE ECC AGAIN
260$:	SOB	R5,240$		;LOOP FOR ALL CSR'S

; SET DETERMINATION FOR THIS K OF CORE AND LOOP

MSBNDH::			;MEMORY SCANNER HIGH-END BOUNDARY
270$:	PUTPAR	R0,R4		;SET THIS K'S WORD IN PARITY TABLE
	CLR	@#MMUSR0	;TURN OFF THE MMU NOW
	ADD	#2,R0		;BUMP THE K NUMBER
	GETPAR	R0,-(SP)	;GET THE TYPE OF THE NEXT K
	CMP	(SP)+,#<-1*256.>+0;IS THIS K STILL UNDONE?
	BNE	290$		;NOPE, FINISH UP
	JMP	130$		;YUP, DO THIS K

290$:	CALLX	KPARSU		;REMAP MEMORY
	TSTB	CACHE		;IS THERE A CACHE?
	BMI	310$		;NO
	MOV	CCTVAL,@#CHECTL	;YES, RE-ENABLE IT
	MOV	CACHES,R0	;GET CACHE SWEEP COUNT
300$:	TST	-(R0)		;SWEEP A WORD
	TST	R0		;LOOP
	BGT	300$		; UNTIL DONE

GLOBAL	<CACHE,CCTVAL,CACHES,PARLOC,KTUSR3>

; ALL OF MEMORY IS NOW CHECKED.
; IF THERE ARE ANY NON-ADDRESS CONTROLLERS,
; FIND THEIR RANGES BY EXAMINING THE DETERMINATION OF MEMORY

310$:	MOV	#PARLOC,R0	;POINT TO THE CSR LIST AGAIN
	MOV	#PARRNG,R5	;POINT TO THE ADDRESS/RANGE CONTROL LIST
	MOV	#16.,R1		;16 REGISTERS TO CHECK
320$:	MOV	(R0),R2		;GET A CSR
	BEQ	360$		;CHANGE NON-EXISTENT REGISTER TO PARZER
	INC	(R5)		;IS THIS A NON-ADDRESS PARITY CSR?
	BPL	370$		;NO, LEAVE BITS 5-11 0 FOR ADDRESS CSR
	DEC	(R5)		; but don't count this K yet		;078

; FOR A NON-ADDRESS CSR , FIND THE START OF THE MEMORY WHICH IT CONTROLS

	BIC	#^C<36>,R2	;GET CSR INDEX
	CLR	R3		;POINT TO CORE DETERMINATION
	MOV	#<2048.-4.>,R4	;Scan all of memory table.		;067
330$:	GETPAR	R3,-(SP)	;GET PARITY TYPE FOR THIS K
	CMP	R2,(SP)+	;DOES THIS CSR CONTROL THIS K?
	BEQ	340$		;YUP
	TST	(R3)+		;ADVANCE OFFSET IN PARITY TYPE TABLE
	ADD	#40,(R5)	;NO, BUMP ADDRESS IN ADDRESS/RANGE WORD
	SOB	R4,330$		; BY 1K AND LOOK ON
	ERF	<"Parity CSR found, but not relating to memory.">

; FIND THE LENGTH OF THE RANGE IT CONTROLS

340$:	TST	(R3)+		;ADVANCE OFFSET IN PARITY TABLE TO NEXT K
350$:	GETPAR	R3,-(SP)	;GET TYPE OF NEXT K
	CMP	R2,(SP)+	;SCAN TO FIND CSR'S RANGE
	BNE	370$		;GOT IT
	INC	(R5)		;NO, IT'S ANOTHER K BIGGER
	TST	(R3)+		;ADVANCE TO NEXT K
	BIT	#20000,(R5)	;Is it BIG - NOADDRESS memory or ...	;078
	BEQ	356$		; NO, its non-inter or even bank	;078
	BIT	#40000,(R5)	;     or...inter odd bank?		;078
	BNE	356$		;Its the new BIG NOADDRESS CSR		;078
	BIT	#7777,(R5)	;Is it too big to be BIG?		;078
	BNE	350$		; No, its still OK			;078
	ERF	<"INIT BUG - large parity CSR overflow">		;078

356$:	BIT	#37,(R5)	;OVERFLOW?
	BNE	350$		;NO
	CMP	(R5),#100040	;Is it a No address with base = 0?	;078
	BNE	358$		; NO, so it is illegal			;078
	BIS	#20000,(R5)	; Yes, so make it "BIG" 		;078
	BR	350$		;  and keep trying			;078

358$:	ERF	<"Parity CSR controls more than 31K">

360$:	MOV	.$PZER,(R0)	;CHANGE NULL POINTER TO MONITOR PARZER
370$:	CMP	(R0)+,(R5)+	;BUMP TABLE POINTERS
	SOB	R1,320$
	RETURN			;AHHHHHHHHHHHHHHHHHHHHHHH

.DSABL	LSB

GLOBAL	<PARLOC.$PZER,PARRNG>

.SBTTL	ROUTINES FOR READING AND WRITING PARTBL

GTPAR:	MOV	(SP)+,2(SP)	;STORE RETURN ADDRESS
	CALL	PARMAP		;MAP IN PARTBL
	ADD	#140000,(SP)	;ADD IN APR6 OFFSET TO TABL OFFSET
	MOV	@(SP)+,2(SP)	;FETCH CONTENTS OF PARTBL
NOMAP:	CLR	@#MMUSR0	;TURN OFF MEMORY MANAGEMENT
	CALLX	KPARSU		;RESTORE OLD MAPPING
	RETURN

PTPAR:	MOV	(SP)+,4(SP)	;STORE RETURN ADDRESS
	CALL	PARMAP		;MAP IN PARTBL
	ADD	#140000,2(SP)	;ADD IN APR6 OFFSET TO TABLE OFFSET
	MOV	(SP)+,@(SP)+	;STORE DATA INTO TABLE
	BR	NOMAP		;AND WRAP UP THE GAME

PARMAP:	MOV	IOBF15,@#KISAR6	;MAP IN PARTBL				;012
	MOV	#1,@#MMUSR0	;TURN ON MEMORY MANAGEMENT
	RETURN

GLOBAL	<MMUSR0,IOBF15,KISAR6>

.SBTTL	CHECK WHETHER ODT IS PRESENT AND SIZE CORRECT

.ENABL	LSB

CHKODT:	TST	T.ODT		;Did user ask for ODT?			;050
	BEQ	30$		;NO, SO WE'RE ALL SET
	MOV	ODTSIZ,R0	;GET ODT'S SIZE IN BYTES
	BEQ	10$		;IT DIDN'T EXIST, TELL USER ABOUT THAT
	ADD	#2047.,R0	;ROUND UP TO NEXT 1K WORD BOUNDARY
	ASH	#-11.,R0	;CONVERT TO SIZE IN K
	CMP	R0,T.ODT+2	;See if it matches size in mem tables	;050
	BEQ	30$		;YES, ALL CHECKED OUT AND KOSHER
	MESSAG	<<177><12>"ODT.SYS size changed - ODT load disabled."<200>>
	BR	20$		;SO DISABLE IT

10$:	MESSAG	<<177><12>"ODT.SYS not found or invalid - ODT load disabled."<200>>
20$:	CLR	T.ODT		;Mark ODT is not to be loaded.		;050
	CLR	T.ODT+2		;Clear both words for good measure.	;050
30$:	RETURN

.DSABL	LSB

GLOBAL	<ODTSIZ>							;050


.SBTTL	ASK FOR CACHE CLUSTER SIZE

.ENABL	LSB

CACHCL::MOV	.$CBSZ,R0	;GET GENERATED SYMBOL FOR DATA CACHING 
	BEQ	10$		; IT DOES NOT EXIST, SO TURN OFF CACHING;018
	CMP	T.CACH+2,#2	;See if size of XBUF is larger than 2K.	;050
	BLO	10$		; LESS THAN 2K XBUF, SO TURN OFF CACHING;018
	MOV	D.CBSZ,R0	;GET THE CURRENT CACHE CLUSTER SIZE
	BNE	10$		;DEFAULT HAS ALREADY BEEN SET		;018
	MOV	#4,D.CBSZ	;SET THE DEFAULT CLUSTER SIZE
10$:	RETURN	

.SBTTL	CRASH DUMP ENABLE/DISABLE

.ENABL	LSB

;023+

CRASH:;	TST	STFLAG		;Are we starting?			;080
;	BEQ	30$		;No DEFALT, always enable CRASH DUMP	;080
	CALL	CHKFIL,R5	;YES, CHECK OUT CRASH.SYS
	.RAD50	/CRASH SYS/
	.WORD	DMPLEN		;ADDRESS OF MINIMUM SIZE ROUTINE
	 BR	20$		;ALL'S WELL, SO ENABLE DUMP
	 MESSAG	<"Crash dump automatically disabled"<200>> ;FAILED
	 MOV	#-1,T.CRAS	;Disable crash dump.			;050
	 RETURN

20$:	CALLX	LOKFIL		;RESET THE FCB FOR CRASH.SYS
	MOV	FC...+FCWND+2,CRSDCN	;SAVE THE STARTING DCN OF THE FILE
	CALL	NOKILL,R5,FC...	;MAKE SURE IT IS NOT KILLABLE
30$:	CLR	T.CRAS		;Enable crash dump.			;050
	RETURN

GLOBAL	<.$CBSZ,D.CBSZ>							;050
GLOBAL	<AUTOGO,FC...,AUTOQS,CRSDCN,DMPLEN>				;050

;023-

.SBTTL	CLOCK PREFERENCE

.ENABL	LSB

10$:	CALLX	MESSAGE,R5	;PRINT HELP TEXT
	 GENTXT
	 .ASCII	<12>
	 .ASCII	"Choose the clock which, if available, should be used during"
	 .ASCII	" timesharing."<200>
	 .ASCII	"Type 'L' to use the KW11-L line frequency clock."<200>
	 .ASCII	"Type 'P' to use the KW11-P programmable clock."<200>
	 .ASCIZ	"Type <CR> for no change."<200>
	 UNORG
CLOCK:	TSTB	FLGGPK		;Is this a GPK?				;061
	BMI	130$		;Yes, skip question (set L)		;061
	MOV	D.CRAT,R0	;GET CURRENT DEFAULT
	MOV	D.CPRF,R3	;GET CURRENT PREFERENCE
	BNE	20$		;USE IT IF PRESENT
	CLR	R0		;ASSUME NO RATE
	MOV	#1,R3		;ASSUME KW11-L DEFAULT
	TSTB	KW11P		;IS THERE A P CLOCK?
	BMI	20$		;NO, WE WERE RIGHT
	NEG	R3		;YES, SET P CLOCK FLAG
	MOV	#100.,R0	;SET DEFAULT RATE (100HZ)
20$:	TST	STFLAG		;Are we starting?			;014
	BNE	140$		;Yes, so use the rate we selected	;014
	MESSAGE	^!<177><12>"Preferred clock "<74>!
	TST	R3		;KW11-L?
	BMI	30$		;NO
	MESSAGE	^!"L"<76>"? "!	;YES, SAY IT
	BR	50$		;GET CHANGE, IF ANY

30$:	TST	R0		;KW11-P, LINE OR CRYSTAL?
	BNE	40$		;CRYSTAL, GO PRINT IT
	MESSAGE	^!"P line"<76>"? "!	;LINE, SAY SO
	BR	50$		;GET CHANGE, IF ANY

40$:	MESSAGE	<"P ">		;CRYSTAL, PRINT CLOCK NAME
	CALLX	DECZER		;PRINT FREQUENCY
	MESSAGE	^!""<76>"? "!
50$:	CALLX	GETIN		;GET ANSWER
	CMPB	(R1),#'?	;NEED HELP?
	BEQ	10$		;YES, GIVE IT
	CMP	(R1),#12	;<LF>?
	BEQ	140$		;YES, DONE
	CMP	(R1),#'L	;'L' FOR KW11-L?
	BEQ	130$		;YES, USE L-CLOCK
	CMPB	(R1)+,#'P	;'P' FOR KW11-P?
	BNE	60$		;NOPE, ERROR
	MOVB	(R1),PREST1	;YES, IS THE FREQUENCY HERE?
	BEQ	70$		;NOPE, ASK FOR IT
	CMPB	(R1)+,#40	;YES, MUST BE SPACE HERE
	BEQ	90$		;YUP, GO PARSE FREQUENCY
60$:	MESSAGE	<"Invalid response"<200>>,INVRES
	BR	CLOCK		;TRY AGAIN

70$:	CALLX	ASKER,R5	;ASK FOR FREQUENCY
	 .WORD	80$		;SHORT TEXT
	 GENTXT
	 .ASCII "  Type 'LINE' to use the KW11-P at AC line frequency."<200>
	 .ASCII "  Type a multiple of 50 between 50 and 1000 to use the"<200>
	 .ASCII "  KW11-P crystal clock at the specified interrupt frequency."<200>
80$:	 .ASCIZ	<177><12>"  Interrupt frequency? "
	 UNORG
90$:	CALLX	GETUNQ,R5	;CHECK FOR 'LINE'
	 GENTXT
	 UNQTXT	<L\INE>
	 .BYTE	0
	 UNORG
	BCS	110$		;NOT 'LINE'
	MOVB	(R1)+,R0	;END OF REPLY? (SET FOR LINE FREQUENCY IF SO)
	BEQ	120$		;YES, DONE
100$:	MESSAGE <"  Invalid response"<200>>
	TSTB	PREST1		;IN-LINE ANSWER?
	BEQ	70$		;NO, GET FREQUENCY AGAIN
	BR	CLOCK		;YES, ASK THE WHOLE THING AGAIN

110$:	CALLX	DECINP		;GET THE REPLY AS A DECIMAL NUMBER
	BNE	100$		;NOT GOOD
	CMP	R0,#1000.	;TOO BIG?
	BHI	100$		;YES
	MOV	R0,R5		;COPY IT
	BEQ	100$		;ZERO NOT LEGAL
	CLR	R4		;CLEAR FOR DIVIDE
	DIV	#50.,R4		;DIVIDE BY 50.
	TST	R5		;REMAINDER ZERO?
	BNE	100$		;NO, BOOT HIM
120$:	MOV	#-1,R3		;INDICATE P CLOCK
	BR	140$		;DONE

130$:	MOV	#1,R3		;INDICATE L CLOCK
	CLR	R0		;NO FREQUENCY HERE
140$:	MOV	R3,D.CPRF	;SET HIS CLOCK PREFERENCE
	MOV	R0,D.CRAT	; AND PREFERRED RATE
	RETURN

GLOBAL	<FLGGPK>						;061



.SBTTL	SET DATE/TIME FORMAT
;+
;	Set up Date and Time format if none				;???
;-
FORMAT:	TST	LINFRQ		;Do we know the frequency		;0xx
	BNE	145$		; Yes					;0xx
	MOV	D.TIMF,R0	; No, so get the old default
	BNE	150$		;  and use it if its there
145$:	MOV	#-1,R0		;Assume we in Amedica'
	CMP	LINFRQ,#50.	;50 Hertz clock?
	BNE	150$		; No, use American Standard format
	NEG	R0		;Yes, set European format date and time
150$:	MOV	R0,D.TIMF	;Set time format
	MOV	R0,D.DATF	;Set date format
	RETURN

.DSABL	LSB

GLOBAL	<D.CPRF,D.CRAT,D.TIMF,D.DATF,LINFRQ>
GLOBAL	<D.CRAT,D.CPRF,KW11P,DEVNAM,DEVCNT>

.SBTTL	LAYMON--Lay out monitor memory

;+
; LAYMON--Lay out monitor memory.
;
; FIXL	=	length of fixed part of installed monitor (MMU slivers)
; D.LB+LBSCRL = SCRatch area Length (MMU slivers)
; T.XTRA =	amount of extra space to be allotted to buffers (K words).;050
; DSHARD => 0	if this hardware supports data space.
;	< 0	otherwise.
; .$ISPS =	physical address of start of I-space code in root.
; .$ISPE =	physical address of end of I-space code in root.
; .$2780 <> 0	if SIL contains old IBM 2780 package.
; CRAL	=	length of CRA phase (MMU slivers)
; TERL	=	length of TER phase (MMU slivers)
; FIPL	=	length of FIP phase (MMU slivers)
; 
; CALL	LAYMON
;
; DSPACE =	-1 if separate I and D spaces will be used.
;	=	0 otherwise.
; D.LB+LBFIXP = FIXed part of monitor's Physical address (ie 0) (MMU slivers)
; D.LB+LBFIXL =	FIXed part of monitor's Length (MMU slivers)
; D.LB+LBFPLP =	FIP PooL's Physical Address (MMU slivers).
; D.LB+LBFPLL = FIP PooL's Length (MMU slivers).
; D.LB+LBISPP =	root I-SPace area's Physical address (MMU slivers).
;	=	0 if I-space code not being moved
; D.LB+LBISPL =	root I-SPace area's Length (MMU slivers).
;	=	0 if I-space code not being moved
; D.LB+LBISPS = Starting virtual address of code that moves to I-SPace area
;	=	0 if I-space code not being moved
; D.LB+LBISPE = Ending virtual address of code that moves to I-SPace area
;	=	0 if I-space code not being moved
; D.LB+LBRNDP = RouNDoff area's Physical address (MMU slivers).
; D.LB+LBRNDL = RouNDoff area's Length (MMU slivers) (less than 1K).
; D.LB+LBSCRP = SCRatch area's Physical address (MMU slivers).
; D.LB+LBSCRL = SCRatch area's Length (MMU slivers) (unchanged).
; MONSIZ =	MONitor SIZe (K words)
; T.XTRA =	amount of extra space actually allocated to buffers.	;050
;		We reduce caller's request if doing so doesn't lower
;		the number of buffers.
;
; LAYMON returns garbage if no monitor is currently installed.
;
; SIDE EFFECTS:
; All registers preserved.
;-
; INTERNAL VARIABLES:
; R1	=	amount of memory available for FIP pool and/or root I-space 
;		area (MMU slivers).  This is a running total;  at the end
;		it contains amount of memory not being used for anything.
; R5	=	length of FIP pool (MMU slivers)

.ENABL	LSB

LAYMON:	REGSCR			;Save all registers.
	CALL	SETMCP		;Set length of the [T]MSCP region	;037
	CALL	SETJCR		;Set length of the Job Control Region	;042
	CALL	SETSIZ		;Set monitor's overall size.
				;Now R1 = amount of extra space available
				; for buffers.
	CLRB	@#DSPACE	;Assume we're not going to use D-space.
	TSTB	@#DSHARD	;Does hardware support D-space?
	BMI	10$		;No: don't use it.
	TSTB	@#D.LB+LBNODS	;Optional command to disable D-space?
	BNE	10$		;Yes: don't use it.
	TST	@#.$2780	;Old IBM 2780 package in SIL?
	NOP	;BNE	10$	;Yes: don't use D-space.		;075
	COMB	@#DSPACE	;Flag that we're going to use D-space.
10$:	CALL	MOVISP		;Decide what I-space code to move.
	CALL	SETFPL		;Set length of FIP pool.

; Trim the monitor if we can do so without losing any buffers.
;	Currently R1 = amount of unused monitor space (slivers).

	CLR	R0		;Clear MSB for DIV.
	DIV	#4000/100,R0	;Let R0 = unused space in K words, rounded down
				;    R1 = remainder, in slivers.
	SUB	R0,@#MONSIZ	;Trim any excess from the monitor size.
	SUB	R0,@#T.XTRA	;Trim any excess from the caller's	;050
				; request.

;Pick out physical addresses for everything.
;	R0	=	physical address of next free block of memory (slivers)

; First thing to do is to lay out the phases
	CLR	R0		;Start at physical zero			;043
	MOV	#D.LB+LBSEGS,R2	;Point to start of segment table	;043
15$:	TST	(R2)+		;Skip the block number pointer		;043
	MOV	R0,(R2)+	;Allocate the address for the phase	;043
	ADD	(R2)+,R0	;Now account for the length		;043
	CMP	R2,#D.LB+LBSEGE	;Are we done yet?			;043
	BNE	15$		;No, loop for all the phases		;043
; Now set up FIP pool / overlay buffer (must follow FIP in memory if no
; I&D space)

	TSTB	@#DSPACE	;Are we using D-space?			;029
	BEQ	20$		;No, not this time			;029
	MOV	R0,@#D.LB+LBSCRP ;Yes, so set up the overlay buffer	;029
	ADD	@#D.LB+LBSCRL,R0 ;And account for its length		;029
20$:	MOV	R0,(R2)+	;FIP pool goes next.  Note its address.
	.ASSUME	LBFPLL EQ LBFPLP+2
	ADD	(R2)+,R0	;Leave room for FIP pool.
	.ASSUME	LBISPP EQ LBFPLL+2
	CLR	(R2)		;Assume I-space code will not be moved.
	TST	@#D.LB+LBISPL	;Will some of it be moved?
	BEQ	50$		;No.
	MOV	R0,(R2)+	;Yes.  Note its physical address.
	.ASSUME	LBISPL EQ LBISPP+2
50$:	ADD	(R2)+,R0	;Skip length of root I-space area, and
				; point at next free block of memory.
	MOV	#D.LB+LBMCPP,R2	;Point at cell for MSCP region
	MOV	R0,(R2)+	;Note physical address of the MSCP region
				;Used by START to jam CM.BA6 MMU value.
	.ASSUME	LBMCPL EQ LBMCPP+2
	ADD	(R2)+,R0	;Allow for length of the MSCP region.
	.ASSUME	LBRNDP EQ LBMCPL+2
				;R0 is address of next free block of memory.
	MOV	R0,(R2)+	;Note physical address of roundoff area.
	.ASSUME	LBRNDL EQ LBRNDP+2
	MOV	R1,(R2)+	;Note length of roundoff area.
	ADD	R1,R0		;Allow for length of roundoff area.
				;R0 is address of next free block of memory.
	TSTB	@#DSPACE	;Are we using D-space?			;029
	BNE	60$		;Yes, so OVRBUF is all set up		;029
	.ASSUME	LBSCRP EQ LBRNDL+2
	MOV	R0,(R2)+	;Note address of scratch area (OVRBUF).
	.ASSUME	LBSCRL EQ LBSCRP+2 ;Length of scratch area is already here
				; (assembled into DEFALT phase).
	ADD	(R2)+,R0	;Get address of end of monitor (slivers).
60$:	MOV	R0,@#D.LB+LBJCRP ;Set up the address of the JCR		;042
	ADD	@#D.LB+LBJCRL,R0 ;And account for its length		;042
	MOV	@#MONSIZ,R2	;Get size of monitor (K words).		;029
	ASH	#5,R2		;Convert to MMU slivers.
	CMP	R2,R0		;Have we goofed something up?
	BNE	90$		;Oops.
70$:	RETURN			;No, return.

90$:	ERF	<"INIT bug - monitor layout screwed up"<200>>

.DSABL	LSB
GLOBAL	<.$2780,D.LB,DSPACE,DSHARD,FIXL,FIPL,TERL,CRAL,RSTBLK,FIPBLK>	;040
GLOBAL	<TERBLK,CRABLK>							;040

; SETSIZ -- Set overall monitor size.
;
; INPUTS:
;	See LAYMON.
;
; CALL	SETSIZ
;
; OUTPUTS:
;	MONSIZ	=	desired overall monitor size (K words).
;	R1	=	extra space available for buffers (MMU slivers).
;
; SIDE EFFECTS:
;	Other registers preserved.


SETSIZ:	PUSH	<R0>
	CLR	R0		;Initialize our size counter		;043
	MOV	#1000/100,@#D.LB+LBSCRL ;Set up OVRBUF size as 1000 bytes ;045
	MOV	#D.LB+LBSEGS,R1	;Point to start of segment table	;043
10$:	CMP	(R1)+,(R1)+	;Advance to length field		;043
	ADD	(R1)+,R0	;And account for it			;043
	CMP	R1,#D.LB+LBSEGE	;Are we at the end now?			;043
	BNE	10$		;No, so loop				;043
	MOV	#30$,R1		;Yes, point to the special lengths	;043
20$:	ADD	@(R1)+,R0	;Account for the next module		;043
	CMP	R1,#40$		;Are we done yet?			;043
	BNE	20$		;No, go for it...			;043
	MOV	R0,R1		;Copy monitor size.
	ADD	#<4000/100>-1,R1 ;Convert to K words ...
	ASH	#-5,R1		; rounding upward.
	BIC	#174000,R1	;Wipe out any propagation of sign bit.
	ADD	@#T.XTRA,R1	;Allow extra room for buffers.		;050
	MOV	R1,@#MONSIZ	;Save monitor size.
	ASH	#5,R1		;Convert it back to MMU units.
	SUB	R0,R1		;Subtract the space we've already allocated.
	POP	<R0>
	RETURN

30$:	.WORD	D.LB+LBMCPL	;Add length of MSCP area (if UDAs on config) ;043
	.WORD	D.LB+LBSCRL	;Add length of scratch area (OVRBUF)	;043
	.WORD	D.LB+LBJCRL	;Add length of the job control region	;043
40$:				;End of length table			;043

GLOBAL	<D.LB,FIXL>							;050



; MOVISP -- Decide what I-space code to move.
;+
; Everything between $$ISPS (I-SPace Start) and $$ISPE (I-SPace End) can be
; mapped I-only.  Everything between $$IBOT and $$ISPS can be mapped
; D-only.  Everything between $$ISPE and $$ITOP can be mapped D-only.
;
; We can get small buffers by moving some or all of the code between $$ISPS
; and $$ISPE to the I-space area, remapping the appropriate I APRs,
; and turning the corresponding part of D-space into buffers.
;
; In practice the I-space code (from $$ISPS to $$ISPE) is mapped by APR 1 
; or by APRs 1 and 2.  However, nothing in INIT depends on that.
;
; If part of the I-space code is mapped by one APR and part by another,
; we can move the first part or the second part or both to the I-space area,
; depending how many buffers we need.  If we split the area, we do
; so at the first APR boundary above $$ISPS.
;
; We can move the first part of the I-space code only if there is an
; APR boundary between $$IBOT and $$ISPS.  This is because the stuff
; below $$IBOT requires I as well as D mapping.
;
; We can move the second part of the I-space code only if there is an
; APR boundary between $$ISPE and $$ITOP.  This is because the stuff above
; $$IOP requires I as well as D mapping.
;
; If all of the I-space code is mapped by one APR, then we can move 
; the I-space code only if both of the above conditions hold.
;-
; INPUTS:
;	DSPACE = -1 ->	D-space will be used.
;		= 0 ->	D-space will not be used.
;	.$ISPS	->	$$ISPS (start of pure I-space code)
;	.$ISPE	->	$$ISPE (end of pure I-space code)
;	R1	=	monitor space available for buffers (slivers)
;
; CALL	MOVISP
;
; OUTPUTS:
;	D.LB+LBISPV =	virtual address of start of I-space code that
;			will be moved (slivers, rounded down) (undefined
;			if no code will be moved)
;	D.LB+LBISPL =	length of I-space area (the code that will be moved)
;			(slivers, both ends rounded out to sliver boundaries)
;	R1	=	monitor space still available (slivers)
;
; SIDE EFFECTS:
;	Other registers preserved.
;
; INTERNAL VARIABLES:
; 	R5	=	Address of first APR boundary in I-space code, or of 
;			end of I-space code if no APR boundary.

.ENABL	LSB

MOVISP:	REGSCR			;Save all registers.
	CLR	@#D.LB+LBISPL	;Assume we're not ...
	CLR	@#D.LB+LBISPS	; going to move ...
	CLR	@#D.LB+LBISPE	; I-space code.
	MOV	@#.$ISPS,R2	;Point at start of I-space code.
	ADD	#20000-1,R2	;Round up ...
	BIC	#20000-1,R2	; to next APR boundary.
	CMP	R2,@#.$ISPE	;Is all of the I-space code mapped by one APR?
	BLOS	10$		;No.  
	MOV	@#.$ISPE,R2	;Yes.  Get the end of I-space code.
10$:	MOV	R2,R5		;Save the address of end of first part of 
				; I-space code.
	TSTB	@#DSPACE	;Will D-space be used?	
	BEQ	50$		;No.  Forget it.
	CMP	R2,@#.$ISPE	;Is all of the I-space code mapped by one APR?
..SPLT	==	.	;*PATCH* to NOP to prevent splitting I-space code.
				; (In case some PDP-11s don't like it.)
	BNE	20$		;Go see about splitting the code.

; We must move I-space code in one piece if at all.

	MOV	@#.$IBOT,R0	;Point at first location that doesn't
				;need both I- and D-space mapping.
	DEC	R0		;Point at end of low executable code.
	MOV	@#.$ISPS,R2	;Point at start of pure I-space code.
	XOR	R2,R0		;Compare the high bits ...
	BIT	#160000,R0	; to see if there's an APR boundary between.
	BEQ	50$		;Nope.  Can't move I-space area.
	MOV	@#.$ISPE,R2	;Point at start of area that doesn't
				;need I-space mapping.
	DEC	R2		;Point at end of pure I-space code.
	MOV	@#.$ITOP,R0	;Point at start read-only area that needs
				;both I- and D-space mapping.
	XOR	R2,R0		;Compare the high bits ...
	BIT	#160000,R0	; to see if we crossed an APR boundary.
	BEQ	50$		;We didn't; can't move I-space code.

; APR alignment is OK for moving I-space code.  See if caller wants 
; that much buffer space.

	MOV	@#.$ISPE,R4	;Get virtual address of end of root I-space 
				; code.
	ADD	#100-1,R4	;Extend it next higher
	BIC	#100-1,R4	; sliver boundary.
	MOV	@#.$ISPS,R2	;Get address of start of I-space code in root.
	BIC	#100-1,R2	;Extend it down to an sliver boundary.
	SUB	R2,R4		;Compute (end) - (start) of I-space area.
	ASH	#-6,R4		;Convert to MMU slivers.
	BIC	#176000,R4	;Clear possible propagation of sign bit.
	CMP	R4,R1		;Do we have room to move I-space code?
	BHI	50$		;Forget it.  Return.
	MOV	R4,@#D.LB+LBISPL ;Yes.  Note length of I-space area.
	MOV	@#.$ISPS,@#D.LB+LBISPS 
				;Note starting ...
	MOV	@#.$ISPE,@#D.LB+LBISPE
				; and ending virtual addresses of I-space code.
	SUB	R4,R1		;Figure out how much more free space we have.
	BR	50$		;Return.

; The I-space code is mapped by at least two APRs.  Determine whether
; we can move the part mapped by the first APR.

20$:	MOV	@#.$IBOT,R0	;Point at first location that doesn't
				;need both I- and D-space mapping.
	DEC	R0		;Point at end of low executable code.
	MOV	@#.$ISPS,R2	;Point at start of pure I-space code.
	XOR	R2,R0		;Compare the high bits ...
	BIT	#160000,R0	; to see if there's an APR boundary between.
	BEQ	30$		;Nope.  Can't move first part of I-space area.

; APR alignment is OK for moving first part of I-space area.  Does caller
; want that much buffer space?

	MOV	R5,R0		;Get end of first part of I-space code.
	SUB	@#.$ISPS,R0	;Get length of first part of I-space code.
	ADD	#100-1,R0	;Convert to slivers ...
	ASH	#-6,R0		; rounding up.
	BIC	#176000,R0	;Clear possible propagation of sign bit.
	CMP	R0,R1		;Do we have room to move first part of 
				; I-space code?
	BHI	30$		;No, try second part.
	MOV	R0,@#D.LB+LBISPL ;Yes.  Note length of I-space area (so far).
	MOV	@#.$ISPS,@#D.LB+LBISPS
				;Note starting ...
	MOV	R5,@#D.LB+LBISPE ;and ending virtual addresses of I-space area.
	SUB	R0,R1		;Note how much space we have left.
	

; Determine whether we can move second part of I-space area.

30$:	MOV	@#.$ISPE,R2	;Point at start of area that doesn't
				;need I-space mapping.
	DEC	R2		;Point at end of pure I-space code.
	MOV	@#.$ITOP,R0	;Point at start read-only area that needs
				;both I- and D-space mapping.
	XOR	R2,R0		;Compare the high bits ...
	BIT	#160000,R0	; to see if we crossed an APR boundary.
	BEQ	50$		;We didn't; can't move second part of 
				; I-space code.

; APR alignment is OK for moving second part of I-space code.

	MOV	@#.$ISPE,R0	;Get virtual address of end of root I-space 
				; area.
	SUB	R5,R0		;Get length of second part of I-space area.
	ADD	#100-1,R0	;Convert to slivers ...
	ASH	#-6,R0		; rounding up.
	BIC	#176000,R0	;Clear possible propagation of sign.
	CMP	R0,R1		;Do we have room to move this part?
	BHI	50$		;Forget it.  
	ADD	R0,@#D.LB+LBISPL ;Yes.  Adjust length of I-space area.
	TST	@#D.LB+LBISPS	;Did we decide to move first part too?
	BNE	40$		;Yes, so starting address is fine.
	MOV	R5,@#D.LB+LBISPS ;No, so note virtual address of second part.
40$:	MOV	@#.$ISPE,@#D.LB+LBISPE
				;Note ending virtual address of I-space area.
	SUB	R0,R1		;Figure out how much space we have left.
50$:	MOV	R1,TOS.R1(SP)	;Tell caller how much space is still available.
	RETURN

.DSABL	LSB
GLOBAL	<D.LB,DSPACE,.$IBOT,.$ISPS,.$ISPE,.$ITOP>

; SETFPL -- Set length of FIP pool.  
;
; INPUTS:
;	R1	=	available space (slivers)
;	DSPACE	=	-1 if we're going to use D-space
;		=	0 if not
; 
; CALL 	SETFPL
;
; OUTPUTS:
;	D.LB+LBFPLL =	length of FIP pool (slivers)
;	R1	=	remaining available space (slivers)
;
; SIDE EFFECTS:
;	Other registers preserved.
;
; FIP pool should use all of the available space if possible, but cannot
; exceed two APRs minus 1000 bytes minus a sliver if we're using D space,
; nor an APR size minus a sliver minus the length of the FIP phase if
; we're not using D space.

.ENABL	LSB
SETFPL:	PUSH	<R0>
	MOV	#400-10-1,R0	;The FIP pool can be at most two APRs	;042
				;minus 1000 minus a sliver with D space	;029
	TSTB	@#DSPACE	;Are we using D-space?
	BNE	10$		;Yes.
	MOV	#200-1,R0	;No, so set up one APR minus a sliver	;042
	SUB	@#FIPL,R0	;And subtract the size of the FIP phase	;029
	BLE	80$		;What the f---?  FIP phase exceeds an APR size.
				; Fatal.
10$:	CMP	R1,R0		;Does caller want more buffer space than ;042
				; we can map?
	BHI	20$		;Yes.  We'll just give him what we can map.
	MOV	R1,R0		;No.  We'll give him what he asked for.
20$:	MOV	R0,@#D.LB+LBFPLL ;Note length of FIP pool.
	SUB	R0,R1		;Figure out how much memory we can't use for 
				; FIP pool.
	POP	<R0>
	RETURN

;+
; SETMCP -- Set length of the [T]MSCP/Ethernet region
;
; CALL 	SETMCP
; OUTPUTS:
;	D.LB+LBMCPL =	length of the [T]MSCP/Ethernet region (slivers)
;	CM.WKA in the CMT of each cntrlr = length needed for that cntrlr
; SIDE EFFECTS:
;	R0	= Length of the [T]MSCP/Ethernet region
;	R1-R3	= Random
;	
;-

SETMCP:	NOP
	CLR	-(SP)		;CLEAR A WORD FOR AN ACCUMULATOR
;+
; Compute MSCP region size
;-
	TST	CNT.DU		;Any DU disk units from SYSGEN?		;039
	BEQ	40$		;Nope.  Check for tapes			;039
	MOVB	CMT+CM.DCT,50$	;How many controllers did we find?	;039
	BEQ	40$		;None.  Check for tapes			;039
	MOV	#CMT,R3		;R3 -> INIT CMT ENTRY FOR MSCP CONTROLLERS ;039
	CLR	R2		;START WITH CONTROLLER ZERO
	CALL	45$,R5,CSRTBL+RU.CSO ;Compute size of disk controller area ;037
	ADD	#BBRSIZ,(SP)	;PLUS THE BAD BLOCK AREA'S SIZE

;+
; Compute TMSCP region size
;-
40$:	TST	CNT.MU		;Any TMSCP units from SYSGEN?		;039
	BEQ	70$		;None.  Leave region size as is		;037
	CLR	-(SP)		;Clear a word for a byte move		;037
	MOVB	CMT+CM.CCT,(SP)	; Get total controller count on stack	;037
	CLR	-(SP)		;Clear a word for a byte move		;037
	MOVB	CMT+CM.DCT,(SP)	; Get disk controller count on stack	;037
	SUB	(SP)+,(SP)	; Compute tape controller count		;037
	MOV	(SP)+,50$	; We're gonna allocate for the # found	;039
	BEQ	70$		; Which is none... Leave size as is 	;039
	MOVB	#DU.MAX,R2	;First tape controller follows disks	;039
	MOVB	CMT+CM.DCT,R3	;Get # of disk controllers found	;037
	MUL	#CMTSIZ,R3	;Compute offset for 1st tape CMT	;037
	ADD	#CMT,R3		;Point to it				;037
	CALL	45$,R5,CSRTBL+MU.CSO	;Compute size of tape area	;037

70$:	MOV	(SP),R0		;GET THE ACCUMULATED LENGTH THUS FAR..	;045
	MOV	R0,@#CMT+CM.AWS	;STORE THE MSCP REGION IN BYTES.
	ADD	#77,(SP)	;ROUND UP TO A FULL 100 (8) BYTES      +;045
	BIC	#77,(SP)	;UNA region must start on an MMU sliver	;045
	CALL	120$,R5,<XE.PKT,D.ERNG,12,204,0> ;Compute UNA region size
	ADD	R1,(SP)		;Update the running total		;045
	CALL	120$,R5,<XH.PKT,D.HRNG,14,442,100> ;Compute QNA region size
	ADD	R1,(SP)		;Update the running total		;056
75$:	MOV	(SP)+,R0	;Return total size in R0		;056
	ASH	#-6.,R0		;  AND CONVERT IT TO AN MMU SIZE
	MOV	R0,@#D.LB+LBMCPL ;STORE THAT SIZE IN THE DEFALT LOAD BLOCK.
	RETURN

45$:	MOV	(R5)+,R4	;Get pointer to first device CSR	;037
	BR	47$		;Get into loop				;037

46$:	TST	(R2)+		;Increment controller number		;045
47$:	TST	(R4)+		;Is this controller preset?		;037
	BEQ	46$		;No, skip it				;037
	CALL	CLCUDA		;CALCULATE THE AREA NEEDED FOR THIS CONTROLLER
	ADD	R1,2(SP)	;Add it to our running total		;037
	ADD	#CMTSIZ,R3	;  INDEX UP TO THE NEXT CONTROLLER CMT ENTRY
	DEC	(PC)+		;Are we done?				;037
50$:	.WORD	0		;  SAVE THE NO. OF CONTROLLER'S HERE.
	BNE	46$		;  No, there's more to do		;037
	RETURN	R5		;Done with this type			;037

80$:	MESSAGE	<"FATAL - FIP">
100$:	MESSAGE	<" phase exceeds an APR size"<200>>
	ERF	<"">

110$:	MESSAGE	<"FATAL - Ethernet">
	BR	100$

120$:	MOV	(R5)+,R4	;Point to device packet
	MOV	PK.CSO(R4),R2	;Get pointer into CSRTBL
	ADD	#CSRTBL,R2	;Point to first controller
	MOVB	(R4),R4		;Get number of controllers supported
.ASSUME	PK.MXU	EQ 0
	CLR	R3		;Count number of controllers found
	MOV	(R5)+,R0	;Point to ring entry counts
	CLR	R1		;Clear an accumulator
130$:	TST	(R2)+		;This controller present?
	BEQ	140$		;No.
	INC	R3		;Count controller as being present
	CLR	-(SP)		;Get ready for a byte move
	BISB	(R0),(SP)	;Get # of XMT rings
	CLR	-(SP)		;Get ready for a byte move
	BISB	1(R0),(SP)	;Get # of RCV rings
	ADD	(SP)+,(SP)	;Compute total # of ring entries for controller
	ADD	(SP)+,R1	;Update total # of rings
140$:	TST	(R0)+		;Advance pointer for next controller
	SOB	R4,130$		;Do all the controllers
	MUL	(R5)+,R1	;Compute size needed for rings
	MUL	(R5)+,R3	;Compute size needed for CDB's
	BEQ	150$		;No controllers, nothing more to do	;048
	ADD	(R5),R3		;Add any device specific area size	;048
150$:	TST	(R5)+		;Skip device parameter			;048
	ADD	R3,R1		;Total size required by this device
	CMP	R1,#20000	;Must be mappable via one APR
	BGT	110$		;It's not.  Pigeon-s**t!
	ADD	#77,R1		;Round up to a full 100 (8) bytes
	BIC	#77,R1		;Next region must start on an MMU sliver
	RETURN	R5		;Done with this device

.DSABL	LSB
GLOBAL	<XE.PKT,XH.PKT,D.ERNG,D.HRNG>
GLOBAL	<CSRTBL,RU.CSO,MU.CSO,DU.MAX>
GLOBAL	<DSPACE,D.LB,FIPL,CNT.DU,CMT,.CMT,RU.PKT,MU.PKT,CNT.MU>

;-
; CLCMCP -- Calculate the U/Q port controller control area size in bytes
;
; INPUTS: R3 -> Controller's CMT to calculate work area size
;	  R2 =  Controller # * 2 (0 relative - from RU0 to RUn, then MU0 to MUn)
; 	  The following fields are used from the DEFALT buffer to
;	  calculate the work size allocated for each controller.
;	  D.RRNG+1(C): number of command rings (in powers of 2) that the U/Q
;		       controller (C) will use.
;	  D.RRNG(C):   number of response rings (in powers of 2) that the U/Q
;		       controller will use.
;	  Each controller may have a different number of rings & packets.
;
; CALL 	CLCMCP
;
; PROCESS:
;	UDA CTL AREA = CCB              = CCBSIZ
;		     + UCB'S            = UCBSIZ * <CM.FLG&CF.UNT>	;037
;		     + RING HEAD        = 4
;		     + RESP RING        = CM.RSP *<RSPLNG+RNGSIZ+ENVLP>
;		     + CMND RING        = CM.CMD *<CMDLNG+RNGSIZ+ENVLP>
; OUTPUT:
;	R1 = Total area needed for this controller in bytes		;037
;	CM.RSP:
;	CM.CMD: will reflect the contents of those values stored in the
;		DEFALT buffer.
;	CM.WKA of controller's CMT updated with area needed in bytes
;	All other registers preserved
;-
CLCUDA:	MOVB	D.RRNG(R2),CM.RSP(R3)	;CM.RSP = # of response ring entries
					; ... (Expressed in powers of 2)
	MOVB	D.RRNG+1(R2),CM.CMD(R3)	;CM.CMD = # of command ring entries
					; ... (Expressed in powers of 2)
	MOV	#RNGSIZ+ENVLP+RSPLNG,R1	;RING+ENVELOPE+PACKET = Size of RSP area
	CLR	-(SP)			;CLEAR A WORD ON THE STACK FOR SHIFT
	MOVB	CM.RSP(R3),(SP)		;(SP) = # of RSP ring entries for CNTRL
	ASH	(SP)+,R1	        ;R1 = <# RESP ENT> * <1 RESP AREA SIZE>
	MOV	R1,-(SP)		;ACCUMULATE CONTROLLER WORK AREA
	MOV	#RNGSIZ+ENVLP+CMDLNG,R1	;RING+ENVELOPE+PACKET = Size of CMD area
	CLR	-(SP)			;CLEAR A WORD ON THE STACK FOR SHIFT
	MOVB	CM.CMD(R3),(SP)		;(SP) = # of CMD ring entries for CNTRL
	ASH	(SP)+,R1	        ;R1 = <# CMND ENT> * <1 CMND AREA SIZE>
	ADD	R1,(SP)			;ACCUMULATE CONTROLLER WORK AREA
	ADD	#CCBSIZ+4,(SP) 		;Add in the CCB and ring header
	MOVB	CM.FLG(R3),R1		;Get flag byte for controller
	BIC	#^C<CF.UNT>,R1		;Isolate units on this controller
	MUL	#UCBSIZ,R1		;Compute total UCB area needed
	ADD	(SP)+,R1		;Add to existing total
	MOV	R1,CM.WKA(R3)		;Also store it in the CMT
	RETURN

GLOBAL	<CM.CMD,CM.RSP>

.SBTTL	Calculate the size of the job control region

;+
; SETJCR - Set up the size of the job control region
;
;	T.JOBM = Maximum number of jobs					;050
;
;	CALL	SETJCR
;
;	R0 = Undefined
;	R1 = Undefined
;
;	D.LB+LBJCRL = Size of job control region (MMU slivers)
;	D.JCRS = Size of a JCR entry in words
;-

SETJCR:	MOV	.$JCFX,R0	;Pick up fixed size of JCR entry	;042
	TSTB	@#DSHARD	;Running with I&D space?		;060
	BMI	10$		;No, not this time			;060
	ADD	#<MDSIZE*8.*2.>,R0 ;Yes, extend JCR for extra MDEs	;060
10$:	ASR	R0		;Get size of JCR entry in words		;042
	MOV	R0,D.JCRS	;Save the size for START		;042
	MOV	T.JOBM,R1	;Pick up the maximum number of jobs	;050
	INC	R1		;Account for the system job entry	;043
	MUL	R0,R1		;Get the region size in words now	;042
	ADD	#37,R1		;Round up to a sliver multiple		;042
	ASH	#-5,R1		;Now convert to number of slivers	;042
	MOV	R1,D.LB+LBJCRL	;And set it up				;042
	RETURN			;All done now				;042

GLOBAL	<D.JCRS,D.LB,.$JCFX,DSHARD>					;060

                                                                       
.SBTTL	Set up conditional phases
;+
; SETCPH - Set up conditional phases
;-
SETCPH:									;043

; First thing to do is clear out the segment table                      

	MOV	#D.LB+LBSEGS,R0	;Point to start of segment table	;043
10$:	CLR	(R0)+		;Clear out a word			;043
	CMP	R0,#D.LB+LBSEGE	;Are we done yet?			;043
	BNE	10$		;No, loop for the whole thing		;043

; Next thing to do is to set up the phases that are always included.    
; Note that we fill in the length and start block numbers here. The
; address is filled in later.

	MOV	FIXL,D.LB+LBFIXL ;Always give us the fixed part		;043
	MOV	RSTBLK,D.LB+LBFIXB ;Set up the block number		;043
	MOV	TERL,D.LB+LBTERL ;Always give us the TER phase		;043
	MOV	TERBLK,D.LB+LBTERB ;Set up the block number		;043
	MOV	FIPL,D.LB+LBFIPL ;And always give us the FIP phase	;043
	MOV	FIPBLK,D.LB+LBFIPB ;Set up the block number		;043
	MOV	CRAL,D.LB+LBCRAL ;And always give us the CRA phase	;043
	MOV	CRABLK,D.LB+LBCRAB ;Set up the block number		;043
	CALL	CONDVR		;Set up conditional driver phases	;064

;+
; Now Check about including GPK support
;-      

	TSTB	FLGGPK		;Is this a GPK?				;071
	BPL	20$		;No, skip those phases			;071
	MOV	GPKL,D.LB+LBGPKL ;Set up GPK phase length		;071
	MOV	GPKBLK,D.LB+LBGPKB ; and starting block			;071
	MOV	PTBL,D.LB+LBPTBL ;Ditto for GPK tables phase		;071
	MOV	PTBBLK,D.LB+LBPTBB					;071

20$:	TSTB	D.LB+LBNFRL	;Is this a no-frills monitor?		;071
	BNE	80$		;Yes, no more conditional phases then	;071

; Now check to see if we should allocate the DECnet phases              

	CALLX	LOK5..,R5	;Set up to look up			;043
	 .RAD50	/NETPRM/	;The network file			;043
	 .RAD50	/SYS/		; ...					;043
	BCS	70$		;Not found, they don't have DECnet	;043
	MOV	#FC...,R1	;Point to scratch FCB			;043
	MOV	#SB$NCP,FCNVB(R1) ;Set up to read NCP control record	;043
.ASSUME	NC.SIZ	EQ	512.	;We expect it to be exactly one block	;043
	CALLX	READ.B,R5	;Set up to read the record		;043
	 .WORD	SILBUF		;Into SILBUF				;043
	BCS	70$		;Error, they don't have DECnet		;043
	MOV	#SILBUF,R2	;Point to the record			;043
	CMPB	(R2),#NC$VER	;Database version correct?		;043
.ASSUME	NC.VER	EQ	0                                               
	BNE	70$		;No, they don't have DECnet		;043
	CLR	R3		;Yes, set up to accumulate the XOR	;043
30$:	MOV	(R2)+,R4	;Pick up a word from the record		;043
	XOR	R4,R3		;And XOR it				;043
	CMP	R2,#SILBUF+NC.XOR ;Up to the XOR cell?			;043
	BNE	30$		;No, so loop				;043
	CMP	R3,(R2)		;Yes, XOR correct?			;043
	BNE	70$		;No, they don't have DECnet		;043
	CMP	-(R2),#^RNET	;Is this really a network file?		;043
.ASSUME	NC.IDE	EQ	NC.XOR-2
	BNE	70$		;No, they don't have DECnet		;043	
	MOV	SILBUF+NC.EXE,FCNVB(R1) ;Set to read the exec record	;049
	BEQ	70$		;Zero is a strange offset, no DECnet	;049
	MOV	SILBUF+NC.COF,R3 ;And get the offset to check		;049
	CMP	R3,#EXCSIZ	;Reasonable offset?			;049
	BHIS	70$		;No, they don't have DECnet		;049
.ASSUME EXCSIZ	EQ	512.	;Assume that it is one block long	;047
	CALLX	READ.B,R5	;Set up to read the record		;047
	 .WORD	SILBUF		;Into SILBUF				;047
	BCS	70$		;Error, skip DECnet setup		;047
	CMPB	SILBUF(R3),#1	;What kind of node is this?		;047
	BLO	70$		;A strange kind, no DECnet setup	;047
    	BEQ	40$		;An end-node, no routing code needed	;047
	MOV	RDML,D.LB+LBRDML ;Routing, give them the routing code	;047
	MOV	RDMBLK,D.LB+LBRDMB ;In both places			;047

40$:	MOV	SESL,D.LB+LBSESL ;They have DECnet, give them SES	;043
	MOV	SESBLK,D.LB+LBSESB ;In both places			;043
	MOV	NSPL,D.LB+LBNSPL ;And give them NSP			;043
	MOV	NSPBLK,D.LB+LBNSPB ;In both places			;043
	MOV	TRNL,D.LB+LBTRNL ;And transport				;043
	MOV	TRNBLK,D.LB+LBTRNB ;In both places			;043
	MOV	EVLL,D.LB+LBEVLL ;And the event logger			;046
	MOV	EVLBLK,D.LB+LBEVLB ;In both places			;046

; Check to see if they want asynch DECnet support

	MOV	CFGBUF+CFG$01,R0;Read the first flag word		;073
	BIT	#C1$NOD,R0	;Do we want NO driver			;069
	BEQ	50$		;No, go check on LAT			;069
	MOV	NODL,D.LB+LBNODL ;And give them async DDCMP		;069
	MOV	NODBLK,D.LB+LBNODB ;In both places			;069

; They have DECnet, now let's see about giving them LAT as well

50$:	BIT	#C1$LAT,R0	;Supressing LAT?			;069
	BNE	70$		;Yes, don't give it to them		;065
	TST	D.LB+LBUNAL	;No, do they have the UNA phase?	;065
	BNE	60$		;Yes, give them LAT			;065
	TST	D.LB+LBQNAL	;No, how about a QNA phase?		;065
	BEQ	70$		;No, no LAT support			;065
60$:	MOV	LATL,D.LB+LBLATL ;Give them LAT support			;065
	MOV	LATBLK,D.LB+LBLATB ;In both places			;065

; Check to see if they want the KBX phase loaded			;072

70$:	MOV	CFGBUF+CFG$01,R0;Read the first flag word		;073
	BIT	#C1$KBX,R0	;Load the KBX phase?			;072
	BEQ	78$		;No					;072
	MOV	KBXL,D.LB+LBKBXL ;Yes, set up KBX phase length		;072
	MOV	KBXBLK,D.LB+LBKBXB ; and block number			;072

; Check the CONFIG.SYS file for FMS support

78$:	ASR	R0		;Want FMS support?			;064
.ASSUME	C1$FMS	EQ	1
	BCC	80$		;No, not this time, forget it		;064
	MOV	FMSL,D.LB+LBFMSL ;Set up the FMS phase length		;064
	MOV	FMSBLK,D.LB+LBFMSB ;And set up the block number		;064

80$:	RETURN			;All done now				;061

GLOBAL	<D.LB,FIXL,RSTBLK,FIPL,FIPBLK,TERL,TERBLK,CRAL,CRABLK>		;043
GLOBAL	<SESL,SESBLK,NSPL,NSPBLK,TRNL,TRNBLK,FC...,EVLL,EVLBLK>		;046
GLOBAL	<RDML,RDMBLK>							;064
GLOBAL	<GPKL,GPKBLK,PTBL,PTBBLK,FMSL,FMSBLK>				;064
GLOBAL	<LATL,LATBLK,KBXL,KBXBLK>					;072
GLOBAL	<NODL,NODBLK>							;069
GLOBAL	<CFGBUF>							;073

.SBTTL	CONDVR	Set up conditional drivers

;+
; CONDVR - Set up conditional drivers
;
; This routine is used by SETCPH to set up phases which are loaded
; dependant upon device availablility.                                      
;-      

CONDVR:	MOV	#PHZTBL,R1	;Point to start of phase table		;064
10$:	MOV	(R1)+,R4	;Pick up a packet address		;064
	BEQ	40$		;End of table, exit			;064
	MOVB	(R4),R2		;Get number of controllers possible	;064
.ASSUME	PK.MXU	EQ	0
	MOV	PK.CSO(R4),R3	;Now get offset in CSRTBL		;064
	ADD	#CSRTBL,R3	;And now get an actual CSRTBL address	;064
20$:	TST	(R3)+		;Is there a controller here?		;064
	BNE	30$		;Yes, all set				;064
	SOB	R2,20$		;No, loop for all controllers		;064
	ADD	#4*2,R1		;Not present, skip to next table entry	;064
	BR	10$		;Now try the next device
        
30$:	MOV	@(R1)+,@(R1)+	;Device present, set up phase length	;064
	MOV	@(R1)+,@(R1)+	;And set up start block number		;064
	BR	10$		;And loop				;064

40$:	RETURN			;All done...				;064

GLOBAL	<CSRTBL>							;064

.SBTTL	Phase loading table
        
PHZTBL: 
                                                                            
	PHZDEV	DH		;Support for DH11s provided by DHPORT phase
		LENGTH	DHPL,<D.LB+LBDHPL>
		BLOCK	DHPBLK,<D.LB+LBDHPB>

	PHZDEV	DJ		;Support for DJ11s provided by DZPORT phase
		LENGTH	DZPL,<D.LB+LBDZPL>
		BLOCK	DZPBLK,<D.LB+LBDZPB>

	PHZDEV	DZ              ;Support for DZ11s provided by DZPORT phase
		LENGTH	DZPL,<D.LB+LBDZPL>
		BLOCK	DZPBLK,<D.LB+LBDZPB>
        
	PHZDEV	VH              ;Support for DHV11/DHU11s provided by VHPORT
		LENGTH	VHPL,<D.LB+LBVHPL>
		BLOCK	VHPBLK,<D.LB+LBVHPB>

	PHZDEV	XE       	;Support for DEUNAs provided by UNA phase
		LENGTH	UNAL,<D.LB+LBUNAL>
		BLOCK	UNABLK,<D.LB+LBUNAB>

	PHZDEV	XH		;Support for DEQNAs provided by QNA phase
		LENGTH	QNAL,<D.LB+LBQNAL>
		BLOCK	QNABLK,<D.LB+LBQNAB>

	PHZDEV

GLOBAL	<D.LB>

	TMPORG	DEFCTL
MONSIZ:	.BLKW0			;Monitor size (K words)
	UNORG

.SBTTL	CHECK FOR CONTIGUOUS FILE ON FQ...

;+
; CHKCTG - CHECK FOR CONTIGUOUS FILE
;
;	FILE OPEN ON FQ...
;
;	CALL	CHKCTG
;
;	C=0 IF FILE IS CONTIGUOUS
;	C=1 IF FILE IS NOT CONTIGUOUS
;-

CHKCTG:	REGSCR			;SAVE REGISTERS
	MOV	#FQ...+FQFCB,R1	;R1 -> FCB FOR THE SIL
	CALLX	RNB		;READ IN THE NAME ENTRY
	MOVB	FCLUS(R1),R1	;R1 = CLUSTER SIZE - 1
	BIC	#177400,R1	;REMOVE SIGN EXTENSION
	INC	R1		;R1 = CLUSTER SIZE
	CLR	R0		;CLEAR FOR DIVIDE
	DIV	DCS,R0		;FILE CLUSTER SIZE / DEVICE CLUSTER SIZE
				;R0 = # OF DEVICE CLUSTERS PER RP
	MOV	UAR(R5),R3	;R3 = LINK TO RETRIEVAL ENTRIES
	CALLX	RDB		;GET RETREIVAL ENTRY
	MOV	2(R5),R1	;R1 = FIRST RETRIEVAL POINTER
	MOV	R3,-(SP)	;SAVE LINK TO THIS RE
10$:	MOV	(SP)+,R3	;GET LINK TO NEXT RE
	BIC	#17,R3		;REMOVE FLAG BITS
	BEQ	40$		;DONE
	CALLX	RDB		;READ IN THE RETREIVAL ENTRY
	MOV	(R5)+,-(SP)	;SAVE LINK TO NEXT RE
20$:	CMP	R1,(R5)+	;DOES THIS MATCH EXPECTED?
	BEQ	30$		;YES, FILE CONTIGUOUS SO FAR
	COM	(SP)+		;NO, DUMP THE DIRECTORY LINK
	RETURN
        
30$:	ADD	R0,R1		;YES, BUMP DCN BY COUNT
	BIT	R5,#17		;END OF THIS RE?
	BEQ	10$		;YUP
	TST	(R5)		;NO, BUT IS THERE ANOTHER?
	BNE	20$		;YES, TRY AGAIN
	TST	(SP)+		;DUMP THE LINK TO NEXT ENTRY
40$:	CLC			;RETURN C=0
	RETURN			;IT IS CONTIGUOUS

GLOBAL	<DCS>

.SBTTL	PRINT LIST OF FILES ELIGIBLE AS ANSWER

.ENABL	LSB

;	ELIGBLE WILL PRINT THE LIST OF FILES THAT ARE VALID RESPONSES FOR
;	A QUERY THAT TAKES A FILENAME AS A RESPONSE. AN EXCEPTION TO THIS
;	IS A QUERY FOR .SIL FILES WHICH WILL PRINT ALL .SIL FILES IN [0,1].
;	
;	CALL ELIGBL,R5,<^REXT> ; WHERE EXT IS THE EXTENSION TO LOOK FOR


ELIGBL: REGSAV			;SAVE THE REGISTERS
	MOV	(R5)+,-(SP)	;SAVE THE EXTENSION TO SEARCH FOR
	MOV	#1,FQ...+FQPPN	;SET FIRQB -> [0,1]
10$:	MOV	#FQ...+FQPPN,R0	;GET POINTER TO DIRECTORY [0,1]
	CALLX	RUF		;READ FIRST BLOCK OF [0,1]
	BCS	60$		;NO [0,1], DIRECTORY MESSED UP
	CLR	R3		;SET UP TO READ FIRST LINK (WHICH WON'T MATCH)
20$:	CALLX	RDB		;READ NEXT NAME ENTRY
	MOV	(R5),R3		;SAVE N.E. LINK
	CMP	UNAM+4(R5),(SP)	;SEE IF WE HAVE THE CORRECT EXTENSION
	BNE	50$		;NO, GO TO NEXT LINK
	BITB	#US.DEL!US.UFD,USTAT(R5);IS FILE MARKED FOR DELETE OR A UFD?
	BNE	50$		;YES, THEN GET THE NEXT FILE
	MOV	#FQ...+FQNAM1,R1;GET POINTER TO FCB NAME ENTRY
	ADD	#UNAM,R5	;MAKE R5 POINT TO NAME OF FILE
	MOV	(R5)+,(R1)+	;MOVE IN THE FILE NAME
	MOV	(R5)+,(R1)+	;PLUS THE SECOND HALF OF THE NAME
	MOV	(R5)+,(R1)+	;ALSO GET THE EXTENSION
	CALLX	LOK...		;OPEN UP THE FILE
	CMP	(SP),#^RSIL	;SEE IF WE'RE LOOKING FOR SILS
	BEQ	40$		;YES, THEN PRINT OUT THE NAME
	CALL	CHKCTG		;SEE IF THE FILE IS CONTIGOUS
	BCS	50$		;NO, THEN GO LOOK AT THE NEXT FILE
	CMP	(SP),#^RERR	;SEE IF THIS IS AN .ERR FILE
	BNE	40$		;NO, THEN PRINT OUT THE NAME
	CMP	FC...+FCSIZ,#8.	;IS THE ERROR FILE OF LENGTH 8.
	BEQ	40$		;YES, THEN IT IS A GOOD ERROR FILE
	CMP	FC...+FCSIZ,#16.;IS THE ERROR FILE OF LENGTH 16.
	BNE	50$		;NO, THEN IT CAN'T BE USED AS AN ERROR FILE
40$:	MOV	#FQ...,R4	;GET A POINTER TO THE FIRQB
	CALLX	TYPFIL		;AND TYPE OUT THE FILE NAME
	MESSAG	<<200>>		;PUT OUT A CARRIAGE RETURN, LINE FEED
50$:	BIT	#^C<17>,R3	;REMOVE GARBAGE IN N.E POINTER
	BNE	20$		;THERE ARE STILL MORE FILES TO LOOK AT
	TST	(SP)+		;REMOVE EXTENSION FROM STACK
	CALLX	REGRES,R5	;RESTORE THE REGISTERS
	TST	(R5)+		;ADVANCE RETURN OVER PARAMETER
	RETURN	R5		;AND RETURN

60$:	ERF	<"Directory error - [0,1] not found"<200>>

.DSABL	LSB

TITLE	BEGIN,<RSTS/E INIT - START TIMESHARING>,08,23-FEB-82,<ABC/SHG/RVR>

;
;	COPYRIGHT (c) 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR INIBEG
;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;  001  CEK  28-AUG-81  FIP Pool Changes
;
;-

.SBTTL	MACROS FOR BEGIN

.MACRO	I.MESS
	TMPORG	BEGTXT
.NLIST	BEX
.ENDM	I.MESS

.SBTTL	ORDER THE CSECTS

	DEFORG	BEGTXT
	DEFORG	BEG
	DEFORG	BEGCTL
	ORG	BEG

.SBTTL	START MAIN DRIVER

.ENABL	LSB

BEGIN::	CALL	BEGIN0		;YES, DO START-UP DIALOG
	RETURN			;RETURN TO START0 IN ROOT WHICH WILL MAKE 
				; THE CROSS OVERLAY JUMP TO THE REST OF THE
				; BEGIN-START CODE

.SBTTL	DO START-UP DIALOGUE

.ENABL	LSB

BEGIN0:	NOP			;Patch to BPT for testing.		;050
	CALLX	LKBADB		;LOOK FOR IMPORTANT FILES
	BCS	50$
	CALLX	LKSATT
	BCS	50$
	CALLX	LKINIT
	BCS	50$
	CALL	NOKILL,R5,FCINIT ;MAKE SURE INIT IS NOT KILLABLE
	MOV	#1*400+2,-(SP)	;Push library PPN [1,2]			;061
	MOV	SP,R0		;POINT TO THE LIBRARY ACCOUNT WORD	;061
	CALLX	SDM		;FIND IT ON THE DISK
	INC	(SP)+		;Pop PPN leaving C alone		;061
	BCS	60$		;NO [1,2] ON THE DISK
	TST	SILNAM		;IS THERE A SIL INSTALLED?
	BEQ	90$		;TUNA FISH
	CALLX	LKSIL		;YES, LOOK UP THE SIL AGAIN
	BCS	100$
	CALL	NOKILL,R5,FCSIL	;MAKE SURE SIL IS NOT KILLABLE
	CALLX	DEFALI		;AND READ THE DEFAULTS
	TST	I.DFLD		;ANY DEFAULTS SET?
	BEQ	120$		;No? Then let us select the DEFALTS	;015
	TST	D.ERRN		;ERR FILE NAME MUST BE DEFINED
	BEQ	110$
	MOV	(PC),STFLAG	;INDICATE THAT WE ARE STARTING

GLOBAL	<FCINIT,FC...,SILNAM,FCSIL,I.DFLD,D.ERRN,SWPDCN,SWPSIZ>		;038

	CALL	TMPINI		;Make sure Temporary area is all set.	;050
	CALL	JOBSWP		;ASK FOR JOB MAX OR SWAP MAX CHANGES
	CALL	MEMTBL		;ANY MEMORY ALLOCATION CHANGES?
	CALL	CACHCL		;CHANGE CACHE CLUSTERSIZE?
	CALL	CRASH		;CRASH DUMP?
	MOV	MAXMEM,R1	;BACK SCAN THE MEMORY TABLE FOR LCK, NXM
10$:	DEC	R1		;PREVIOUS K
	BEQ	20$
	CALL	GETTYP		;WHAT IS THERE?
	CMP	R3,#U.LOCK	;Is it LOCKED?				;050
	BHIS	10$		;LCK, NXM, OR -1 (HIGH) GET DUMPED
20$:	INC	R1		;INCREMENT TO TRUE MEMORY SIZE
	MOV	R1,MAXMEM	;DONE, FIX MAXMEM
	CALLX	INSTAO		;Write out the Install buffer.		;050
	CALL	DEFFIN		;Set up DEFBUF and write it, too.	;055
	TSTB	AUTOQS		;AUTO RESTART?
	BMI	40$		;Yes, so use current date and time.	;050
	CALLX	DATINI		;Get new date and time.			;035
	BR	45$		;And go back.				;035

40$:	MESSAGE	<<177><200>"System restarted at ">
	CALLX	TIMPRT		;PRINT RESTART TIME
	MESSAGE	<" on ">
	CALLX	DATPRT		;AND DATE
	CALLX	TYPECR
45$:	RETURN			;The end.				;035

GLOBAL	<AUTOQS,I.DFLD>


50$:	ERF	<"One or more system files missing">

60$:	ERF	<"No library account on this disk">

90$:	MESSAGE	<"Please install a monitor SIL."<200>>			;050
	EXIT

100$:	ERF	<"Monitor SIL not found">

110$:	MESSAG	<"Defaults corrupted.  Resetting defaults..."<200>>
	.BR	120$			;Some defaults missing - select them

;+
;	Note:	If I.DFLD = 0 and STFLAG <> 0
;		   then the user is STARTing a SIL for the first
;		        time and defaults will automagically be
;			selected.
;
;		If I.DFLD = 0 and STFLAG = 0 
;		   then the user is using the DEFALT option for 
;			first time on the SIL and all questions
;			will be asked with preselected DEFALTS.
;			
;
;-
120$:	MOV	(PC),STFLAG	;INDICATE THAT WE ARE STARTING		;015
	CALL	DEFINI		;Initialize the DEFALTS			;015
	CALL	JOBSWP		;Select JOB/SWAP MAXIMA			;015
	CALL	ERRGET		;Select the error file			;038
	CALL	INSNAM		;Select INSTALLATION NAME		;015
	CALL	MEMTBL		;Select MEMORY TABLE			;015
	CALL	CACHCL		;Select CACHE CLUSTER SIZE		;015
	CALL	DEFSAV		;Copy defaults into DEFBUF		;082
				;Crash will check the saved defaults	;080
	CALL	CRASH		;Select  CRASH DUMP SETTING		;015
	CALL	CLOCK		;Select PREFERRED CLOCK			;015
	CALL	DEFFIN		;Copy/Save DEFAULTS			;082
	CLR	BLNRST		;SET UP RDRSTS TO FORCE A READ
	MOVB	#1.,@#AUTOQS	;Don't ask for any changes in START	;015
	MOV	MAXMEM,R1	;BACK SCAN THE MEMORY TABLE FOR LCK, NXM;015
	BR	10$		;Now continue in common code.		;015
                                                                           
.DSABL	LSB

GLOBAL	<D.DANS,AUTOQS>							;050

.SBTTL	ENSURE THAT A FILE IS UNKILLABLE

.ENABL	LSB

NOKILL:	REGSAV			;SAVE REGISTERS
	MOV	(R5)+,R1	;R1 -> FCB FOR FILE
	CLR	R0		;NO OTHER PRIVS
10$:	BITB	#US.NOK,DDSTS(R1) ;IS IT ALREADY UNKILLABLE?
	BNE	30$		;YUP, THIS IS EASY
20$:	CALLX	RNB		;GET THE NAME ENTRY INTO MEMORY
	BISB	R0,USTAT(R5)	;TAKE THE WRITE PRIV'S IF ASKED
	BISB	#US.NOK,USTAT(R5) ;TURN ON THE UNKILLABLE BIT
	CALLX	WRITE		;REWRITE THE DIRECTORY
30$:	CALLX	REGRES,R5	;RESTORE REGS
	TST	(R5)+		;POP OVER FCB POINTER
	RETURN	R5		;BACK

NOKILW:	REGSAV			;SAVE REGISTERS
	MOV	(R5)+,R1	;R1 -> FCB FOR FILE
	MOV	#US.WRT,R0	;SET UP FOR THE WRITE PRIVS
	BITB	R0,DDSTS(R1)	;ARE THEY ALREADY GONE?
	BEQ	20$		;NO, WE MUST TAKE THEM NOW
	BR	10$		;YES, SEE IF KILL PRIVS ARE GONE

.DSABL	LSB

;023+

.SBTTL	IMPURE AREA FOR CHKFIL

	TMPORG	DEFCTL
DELFLG:	.WORD	0		;FLAG FOR DELETING THE FILE
SIZTBL:	.BLKW0	3		;TABLE OF SIZE VALUES (CURRENT, MINIMUM, ZERO)
FREENT:	.WORD	0		;NUMBER OF FREE DIRECTORY ENTRIES
FRESAV:	.WORD	0		;SAVE CELL FOR FREENT
NOPREF:	.WORD	0		;FLAG FOR NO PREFERENCE FOR PLACEMENT OF FILE
EXTMAP:	.BLKW	9.		;EXTENDED UFD CLUSTER MAP
	UNORG

.SBTTL	CHECK SWAP OR CRASH FILE FOR VALIDITY

.ENABL	LSB

CHKFIL:
	CALL	SETUP		;GET SETUP
	CALL	GETSAT		;GET CLEAN SAT FROM DISK
	MOV	#SIZTBL,R3	;POINT TO THE SIZE TABLE
	CLR	DELFLG		;ASSUME THE FILE IS FINE
	CALLX	LOKN..		;DO THE LOOKUP ON THE FILE
	MOV	FQSIZC(R4),(R3)+;SAVE CURRENT SIZE
	CALL	@(R5)+		;GET THE MINIMUM SIZE OF THE FILE
	MOV	R0,(R3)		; AND SAVE IT TOO
	BIT	#FS.OPN,FQSTAT(R4)	;WAS THE FILE THERE (DID WE OPEN IT)
	BEQ	20$		;FILE NOT THERE, CREATE IT AT MINIMUM SIZE
	CMP	-2(R3),(R3)	;CHECK SIZE VS. MINIMUM SIZE
	BLO	10$		;TOO SMALL, RE-CREATE IT AT MINIMUM SIZE
	CALL	CHKCTG		;IS IT CONTIGUOUS?
	BCC	40$		;YES, SO EVERYTHING IS HUNKY-DORY
	TST	-(R3)		;NO, SO TRY TO RE-CREATE AT CURRENT SIZE
10$:	CALL	DEALLC		;DEALLOCATE FILE FROM SAT
	COM	DELFLG		;AND SIGNAL WE'RE GONNA DELETE IT
20$:	CALLX	SAVSAT		;SAVE THE DEALLOCATED SAT TO AUXILIARY BUFFER
30$:	CALLX	RESSAT		;RESTORE THE SAVED SAT
	MOV	FRESAV,FREENT	;RESTORE THE SAVED FREE ENTRY COUNT
	MOV	(R3)+,FQSIZN(R4);GET THE TRIAL FILE SIZE
	BNE	50$		;NOT END OF SIZE TABLE, SEE IF IT WORKS
	TST	(R5)+		;END OF TABLE, SO ALLOCATION FAILED, RETURN + 2
	MESSAG	<<200>"?Not enough contiguous disk space to create minimum ">
	CALLX	TYPFIL		;Print out can't create error
	MESSAG	<" file"<200><12>>
40$:	RETURN	R5		;NOTHING CHANGED, RETURN + 0

50$:	CALL	TRYCRE		;DO TRIAL CREATION
	BCS	30$		;WE CAN'T DO IT, TRY SMALLER SIZE
	CALLX	TYPECR		;SKIP A LINE
	MOV	(PC)+,R0	;ASSUME WE'LL HAVE TO DELETE THE FILE
	 GENTXT
	  .ASCII "Re-"
	 UNORG
	TST	DELFLG		;DO WE HAVE TO DELETE IT?
	BNE	60$		;YES
	MOV	(PC)+,R0	;NO, CHANGE THE MESSAGE
	GENTXT	<"creating ">	;Either Re-creating
	MOVB	#'C,(R0)	; or Creating
60$:	CALLX	ASCIZ0		;PRINT OUT THE MESSAGE
	CALLX	TYPFIL		; AND WITH WHAT FILE
	MESSAG	<" file with ">
	MOV	(PC)+,R0	;ASSUME WE'RE NOT CHANGING THE SIZE
	GENTXT	<"old">
	CMP	FQSIZN(R4),FQSIZC(R4)	;NEW SIZE = OLD SIZE?
	BEQ	70$		;YES
	MOV	(PC)+,R0	;NOPE, CHANGE THE MESSAGE
	GENTXT	<"minimum">
70$:	CALLX	ASCIZ0		;PRINT OUT THIS PART
	MOV	FQSIZN(R4),R0	;GET THE SIZE
	MOV	#80$,R1		;POINT TO MESSAGE AREA
	CALLX	DECSTR		;PUT SIZE IN MESSAGE
	MESSAG			;PRINT IT OUT
	 .ASCII	" size of "
80$:	 .ASCIZ	"?????? blocks"<200>	;FINISH UP THE MESSAGE
	UNORG
	CALL	CHANGE		;DO THE CHANGE, KNOWING IT CAN'T FAIL
	RETURN	R5		;ALL DONE, RETURN + 0

.DSABL	LSB


.SBTTL	SET UP CODE FOR CHKFIL

.ENABL	LSB

SETUP:	REGSCR			;SAVE ALL REGISTERS
	MOV	#0*400+1,-(SP)	;Push the PPN				;061
	MOV	SP,R0		;R0 -> [0,1] WORD FOR RUF		;061
	CALLX	RUF		;FIND THE ACCOUNT IN THE MFD
	INC	(SP)+		;Pop the PPN without touching C		;061
	BCC	10$		;THIS SHOULD ALWAYS WORK
	ERF	<"INIT bug - can't find [0,1] again">

10$:	CLR	R4		;R4 = COUNT OF FREE ENTRIES IN [0,1] UFD
	CLR	R0		;R0 = OFFSET INTO DIRECTORY CLUSTER MAP
20$:	CLR	R1		;R1 = BLOCK WITHIN DIRECTORY CLUSTER
	TST	(R0)+		;BUMP TO NEXT DIRECTORY CLUSTER
30$:	MOV	FIBMAP(R0),R2	;R2 = DIRECTORY CLUSTER NUMBER
	BEQ	60$		;NO MORE, DONE WITH THE COUNT
	CALLX	CNVRIB		;CONVERT R.P. TO FBN
	ADD	R1,R2		;ADD OFFSET FOR BLOCK WITHIN CLUSTER
	ADC	R3
	CALLX	READ		;GET THE DIRECTORY BLOCK
	MOV	#FIBUF,R5	;R5 -> DIRECTORY
40$:	MOV	(R5),-(SP)	;SAVE FIRST WORD OF ENTRY
	BIS	2(R5),(SP)+	;ARE THE FIRST TWO WORDS ZERO?
	BNE	50$		;NO, SO THIS ENTRY ISN'T FREE
	INC	R4		;IT'S FREE, SO COUNT IT
50$:	ADD	#20,R5		;POINT TO NEXT DIRECTORY ENTRY
	CMP	R5,#FIBMAP	;UP TO THE MAP YET?
	BLO	40$		;NOPE
	INC	R1		;YES, DONE WITH THIS BLOCK
	CMP	R1,(R5)		;LAST BLOCK IN THE CLUSTER?
	BLO	30$		;NOPE, DO ANOTHER
	CMP	R0,#16		;YES, IS THERE ANOTHER CLUSTER?
	BLO	20$		;YES, SO DO IT
60$:	MOV	R4,FREENT	;SAVE FREE ENTRY COUNT
	MOV	R4,FRESAV	; IN BOTH PLACES
	RETURN			;AND RETURN

GLOBAL	<FIBMAP,FIBUF>

.DSABL	LSB

;023-


.SBTTL	DEALLOCATE FILE FROM SAT

DEALLC:	REGSCR			;SAVE ALL REGISTERS		;023
	MOV	#FC...,R1	;R1 -> FCB FOR FILE		;023
	CALLX	RNB		;GET THE NAME ENTRY OF THE FILE
	INC	FREENT		;COUNT THE ENTRY AS FREE
	MOV	USTAT(R5),R0	;R0 = FILE STATUS FLAGS
	MOV	UAA(R5),R3	;R3 = LINK TO ACCOUNTING ENTRY
	MOV	UAR(R5),-(SP)	;SAVE LINK TO RETIEVAL ENTRY
	CALLX	RDB		;READ THE ACCOUNTING ENTRY
	MOV	UCLUS(R5),R1	;R1 = CLUSTERSIZE OF THE FILE
10$:	INC	FREENT		;ONE MORE FREE ENTRY FOR A.E. OR ATTRIBUTE
	MOV	(R5),R3		;GET LINK TO NEXT ATTIBUTE
	BIC	#17,R3		;WITHOUT FLAG BITS
	BEQ	20$		;NO MORE
	CALLX	RDB		;READ THE ATTRIBUTE
	BR	10$		;AND COUNT IT AS FREE IN THE DIRECTORY

20$:	MOV	(SP)+,R3	;RESTORE LINK TO RETRIEVAL ENTRY
	BIC	#17,R3		;WITHOUT FLAG BITS
	BEQ	50$		;ALL DONE
	CALLX	RDB		;READ IT
	INC	FREENT		;COUNT THE RETRIEVAL ENTRY AS FREE
	MOV	(R5)+,-(SP)	;SAVE LINK TO NEXT R.E.
30$:	MOV	(R5)+,R2	;R2 = RETRIEVAL POINTER
	BEQ	20$		;0, GO DUMP LINK TO NEXT R.E. AND FINISH
	BIT	R0,#US.OUT	;IS THIS FILE OUT OF SAT?
	BNE	40$		;YES, A RELIC OF V6A
	CALLX	RETCLU		;OTHERWISE RETURN THE CLUSTER
40$:	BIT	R5,#17		;DONE WITH THIS R.E.?
	BNE	30$		;NO, GET ANOTHER CLUSTER POINTER
	BR	20$		;YES, GET ANOTHER R.E.

50$:	CALLR	ALCBAD		;ENSURE BADB.SYS IF FULLY ALLOCATED

GLOBAL	<FC...>


.SBTTL	DO TRIAL ALLOCATION OF FILE

;023+

TRYCRE:	REGSCR			;SAVE ALL REGISTERS
	CLR	NOPREF		;SAY WE HAVEN'T TRIED WITH ANY BASE
	MOV	FQPREF(R4),R0	;R0 = PREFERRED (OR CURRENT) BASE (MIGHT BE 0)
10$:	MOV	FQSIZN(R4),R1	;R1 = PREFERRED SIZE (CURRENT OR MINIMUM)
	CALLX	GETCLU		;TRY TO OBTAIN THE CONTIGUOUS SPACE
	BCS	30$		;GOT IT
	TST	R0		;WAS THE START OF THE SEARCH 0?
	BEQ	RTS.SC		;YES, SO ALLOCATION FAILED
20$:	CLR	R0		;SET NO PREFERRED BASE
	COM	NOPREF		;SAY WE'VE BEEN HERE BEFORE
	BR	10$		;AND TRY AGAIN

30$:	MOV	R2,FQALLC(R4)	;SAVE THE ALLOCATED CLUSTER NUMBER
	CALLX	FIXCLU		;CONVERT BLOCK COUNT IN R1 TO PC COUNT
	MOV	R0,FQNPCL(R4)	;SAVE NUMBER OF PACK CLUSTERS REQUIRED
	MOV	R0,R1		;COPY THE PACK CLUSTER COUNT
	CLR	R0		;CLEAR FOR DIVIDE
	DIV	#7,R0		;COMPUTE THE NUMBER OF RETRIEVAL ENTRIES
	NEG	R1		;IF ANY REMAINDER
	ADC	R0		; ROUND UP TO AN INTEGER
	ADD	#2,R0		;+2 DIRECTORY ENTRIES FOR N.E. AND A.E.
	SUB	R0,FREENT	;TAKE THEM FROM THE FREE COUNT
	CLR	EXTMAP+2	;SET FLAG FOR NO EXTENDED CLUSTER MAP
	MOV	FREENT,R1	;GET LEFTOVER COUNT IN R1
	BPL	RTS.PC		;NO SWEAT, SO RETURN WITH C=0 (FROM CLR)
	NEG	R1		;R1 = NUMBER OF ENTRIES STILL NEEDED
	CLR	R0		;CLEAR FOR DIVIDE
	MOV	FIBMAP,R3	;R3 = DIRECTORY CLUSTER SIZE
	MUL	#31.,R3		;R3 = # OF ENTRIES PER UFD CLUSTER
	DIV	R3,R0		;COMPUTE NUMBER OF CLUSTERS REQUIRED
	NEG	R1		;IF ANY REMAINDER
	ADC	R0		; ROUND UP
	MOV	R0,R1		;R1 = NUMBER OF UFD CLUSTERS TO GET
	MOV	#FIBUF+1000,R2	;R2 -> END OF CLUSTER MAP
40$:	TST	-(R2)		;ROOM IN FDCM FOR ANOTHER CLUSTER?
	BNE	70$		;UH OH!  WE COULD BE IN TROUBLE
	SOB	R1,40$		;SO FAR SO GOOD
50$:	TST	-(R2)		;UFD CAN HOLD THEM.  FIND THE HOLE
	BEQ	50$		; IN THE UFD CLUSTER MAP
	MOV	#EXTMAP,R3	;R3 -> EXTENSION OF UFD MAP
	MOV	R2,(R3)+	;EXTMAP HOLDS POINTER TO LAST REAL CLUSTER
	MOV	FIBMAP,R1	;R1 =UFD CLUSTER SIZE TO ALLOCATE
60$:	CALLX	GETDIR		;GET A DIRECTORY CLUSTER
	BCC	70$		;UH OH!  CAN'T GET IT.
	MOV	R2,(R3)+	;GOT IT, REMEMBER THE LAST CLUSTER WE GOT
	SOB	R0,60$		;GET ALL THE CLUSTERS WE NEED
	CLR	(R3)+		;CLEAR THE LAST ENTRY AS A FLAG
	BR	RTS.PC		; AND RETURN WITH C=0 (FROM CLR)

70$:	TST	NOPREF		;DID WE ALREADY TRY USING ANY BASE?
	BNE	RTS.SC		;YEAH, SO ALLOCATION FAILED!
	CALLX	RESSAT		;RESTORE THE SAT TO WHAT IT WAS WHEN WE CAME IN
	MOV	FRESAV,FREENT	;RESTORE THE FREE ENTRY COUNT
	BR	20$		; AND TRY WITH NO BASE PREFERENCE

RTS.SC:	SEC			;SET CARRY AND RETURN
RTS.PC:	RETURN			;JUST RETURN

;023-
.ENABL	LSB

.SBTTL	MAKE A FILE CHANGE KNOWING IT CAN'T FAIL

CHANGE:	REGSCR			;SAVE ALL REGISTERS			;023
	CALL	GETSAT		;READ IN A NICE CLEAN SATT FROM DISK
	CALLX	READPL		;READ IN THE PACK LABEL
	BIS	#UC.MNT,FIBUF+PSTAT ;IT'S DIRTY DURING THIS SEQUENCE
	CALLX	WRITE		;MAKE SURE IT SAYS SO
10$:	BIT	#FS.OPN,FQSTAT(R4) ;WAS THE FILE ALREADY EXISTANT?
	BEQ	20$		; NO, SO YA' CAN'T DELETE IT
	CALLX	DELNAM		;IF IT EXISTS, DELETE IT NOW
	BCS	80$		;CAN'T FIND IT NOW, WHAT GIVES?
	BIC	#FS.OPN,FQSTAT(R4) ;FILE IS NOW CLOSED (NON-EXISTENT)
20$:	CALL	ALCBAD		;ENSURE BADB.SYS IS FULLY ALLOCATED
	MOV	#0*400+1,-(SP)	;Push the PPN				;061
	MOV	SP,R0		;R0 -> [0,1] WORD FOR RUF		;061
	CALLX	RUF		;FIND THE ACCOUNT IN THE MFD
	INC	(SP)+		;Pop the PPN without touching C		;061
	MOV	#EXTMAP,R4	;R4 -> EXTENDED CLUSTERS TO GET
30$:	TST	(R4)+		;POINT TO NEXT CLUSTER TO GET
	MOV	(R4),R2		;R2 = RETREIVAL POINTER TO ALLOCATE
	BEQ	DOCREA		;NO MORE, GO DO THE CREATION
	CALLX	RIB2CN		;CONVERT TO PACK CLUSTER NUMBER
	MOV	R3,R0		;SAVE PCN TO GET
	MOV	FIBMAP,R1	;R1 = UFD CLUSTER SIZE
	CALLX	GETCLU		;ALLOCATE THE CLUSTER
	BCC	90$		;HUH?? WE GOT IT LAST TIME!
	CMP	R2,(R4)		;DID WE GET THE SAME CLUSTER?
	BNE	100$		;NO, WHY NOT???
	CALLX	WRITEC		;FORCE OUT FIBUF IF NECESSARY
	ADD	#2,EXTMAP	;THE CLUSTER GOES IN THE NEXT MAP ENTRY
	CALLX	CNVRIB		;CONVERT THE NEW RP TO FIP BLOCK NUMBER
	MOV	#FIBUF,R5	;R5 -> FIBUF TO BE CLEARED
40$:	CLR	(R5)+		;NEW BLOCKS HAVE NO DATA
	CMP	R5,#FIBMAP	;UP THE THE FDCM YET?
	BLO	40$		;NO
	MOV	(R4),@EXTMAP	;YES, SET THIS CLUSTER'S RP IN THE MAP
	MOV	(R5),R1		;R1 = NUMBER OF BLOCKS IN CLUSTER TO CLEAR

GLOBAL	<FIBUF,FIBMAP>

50$:	MOV	R2,FIBPHS	;SET UP THE FBN TO WRITE
	MOVB	R3,FIBPHS+2
	CALLX	WRITE		;WRITE IT
	ADD	#1,R2		;NEXT BLOCK IN THE NEW UFD CLUSTER
	ADC	R3
	SOB	R1,50$		;FOR EVERY BLOCK
	MOV	EXTMAP,R0	;R0 -> FIBUF @ NEW CLUSTER
60$:	MOV	-(R0),R2	;R2 = R.P. FOR A PREVIOUS CLUSTER
	CMP	R0,R5		;ARE WE DOWN TO THE CLUSTERSIZE IN FDCM?
	BLOS	30$		;YES, DONE WITH THIS ALLOCATION
	CALLX	CNVRIB		;CONVERT UFD R.P. TO FIB BLOCK NUMBER
	MOV	(R5),R1		;R1 = NUMBER OF BLOCKS IN CLUSTER TO FIX
	ADD	R1,R2		;START FIXES AT THE END
	ADC	R3
70$:	SUB	#1,R2		;PREVIOUS BLOCK IN UFD CLUSTR
	SBC	R3
	CALLX	READ		;READ THE CLUSTER
	MOV	(R4),@EXTMAP	;INSERT THE NEW RP IN THE FDCM
	MARK	FIBUF		;FIBUF HAS CHANGED
	SOB	R1,70$		;DO EACH BLOCK IN THE UFD CLUSTER
	BR	60$		;DO ANOTHER UFD CLUSTER IF ANY

80$:	ERF	<"INIT bug - can't find file to delete">

90$:	ERF	<"INIT bug - can't allocate file 2nd time">

100$:	ERF	<"INIT bug - didn't get same cluster 2nd time">

.DSABL	LSB

GLOBAL	<FIBPHS>

.SBTTL	CREATE THE FILE

.ENABL	LSB

DOCREA:	MOV	#FQ...,R4	;R4 -> FIRQB			;023
	MOV	FQSIZN(R4),R1	;R1 = NEW SIZE OF FILE
	MOV	FQALLC(R4),R2	;GET THE CLUSTER ALLOCATED FIRST TIME
	CALLX	RIB2CN		;CONVERT TO A PACK CLUSTER NUMBER
	MOV	R3,R0		;COPY THE PCN FOR GETCLU
	CALLX	GETCLU		;DO THE ALLOCATION
	BCC	30$		;WHY DIDN'T WE GET IT?
	CMP	R2,FQALLC(R4)	;DID WE GET THE ONE WE WANTED?
	BNE	30$		;WHY NOT???
	CALL	CREATE		;YES, CREATE THE FILE
	TST	R5		;DID IT FAIL?
	BNE	40$		;YES, WHY???
	CALLX	WOMSAT		;WRITE OUT THE SATT
	CALLX	READPL		;READ THE PACK LABEL
	BIC	#UC.MNT,FIBUF+PSTAT ;DISK IS AGAIN CLEAN
	CALLRX	WRITE		;REWRITE PACK LABEL AND GO AWAY

30$:	ERF	<"INIT bug - didn't get same file cluster 2nd time">

40$:	ERF	<"INIT bug - failed to create file">

.DSABL	LSB

GLOBAL	<FIBUF>

.SBTTL	CREATE A FILE IN THE UFD

.ENABL	LSB

CREATE:	CLR	R5		;R5 = 0 AS A FLAG FOR GOODNESS
	REGSCR			;NOW SAVE ALL REGISTERS
	MOV	R4,R0		;COPY FIRQB POINTER
	ADD	#FQPPN,R0	;R0 -> PPN IN THE FIRQB
	CALLX	SDU		;FIND THE FILE IN THE MFD
	BCC	80$		;IT EXISTS ALREADY! THAT SHOULDN'T HAPPEN
	CMP	R5,#4		;DOES THE UFD EXIST AT ALL?
	BNE	90$		;NO, NO UFD???
	MOV	R2,-(SP)	;SAVE LINK TO LAST NAME ENTRY
	MOV	PCS,FQCLUS(R4)	;CLUSTERSIZE OF FILE IS PACK CLUSTER SIZE
	CALLX	GDB		;GET A DIRECTORY ENTRY FOR ACCOUNTING
	BCS	70$		;CAN'T GET IT, GO RETURN 2 IN R5
	MARK	FIBUF
	MOV	R3,-(SP)	;SAVE LINK TO ACCOUNTING ENTRY
	INC	(R5)+		;MARK THE ENTRY IN USE
	MOV	I.DATE,(R5)+	;LAST ACCESS DATE
	MOV	FQSIZN(R4),(R5)+ ;SIZE OF FILE
	MOV	I.DATE,(R5)+	;CREATION DATE
	MOV	I.TIME,(R5)+	;CREATION TIME
	MOV	#^R RS,(R5)+	;CREATING RTS = ' RSTS '
	MOV	#^RTS ,(R5)+
	MOV	PCS,(R5)+	;CLUSTERSIZE = PCS
	MARK	FIBUF		;REWRITE THE ACCOUNTING ENTRY
	CALLX	GDB		;GET A HOLE FOR THE NAME ENTRY
	BCS	50$		;NO CAN DO, RELEASE THE A.E.
	CLR	(R5)+		;LINK TO NEXT NAME ENTRY = 0
	MOV	FQNAM1(R4),(R5)+ ;SET UP FILNAM.EXT
	MOV	FQNAM1+2(R4),(R5)+
	MOV	FQNAM1+4(R4),(R5)+
	MOV	FQPROT-1(R4),(R5)+ ;PROTECTION CODE & FLAG BITS
	CLR	(R5)+		;ACCESS COUNT = 0
	MOV	(SP)+,(R5)+	;LINK TO ACCOUNTING ENTRY
	MOV	R3,-(SP)	;SAVE LINK TO NAME ENTRY
	MOV	R5,-(SP)	;SAVE POSITION (IN FIBUF) FOR R.E. LINK
	MOV	R3,-(SP)	;SAVE LINK TO N.E. IN WHICH TO PLUG UAR
	CLR	R5		;R5 = 0 TO FORCE ALLOCATION FIRST TIME
	MOV	FQALLC(R4),R2	;R2 = R.P. TO START OF FILE
	MOV	FQNPCL(R4),R4	;R4 = NUMBER OF PACK CLUSTERS

GLOBAL	<PCS,I.DATE,I.TIME>

10$:	BIT	R5,#17		;NEED A NEW RETRIEVAL ENTRY?
	BNE	20$		;NO
	CALLX	GDB		;YES, GET ONE
	BCS	30$		;NONE TO GET, RETURN EVERYTHING & GO AWAY
	MOV	R3,R1		;R1 = LINK TO R.E. JUST OBTAINED
	MOV	(SP)+,R3	;R3 = LINK TO PREVIOUS ENTRY
	CALLX	RDB		;GET PREVIOUS
	MOV	R1,@(SP)+	;LINK IT TO THIS ENTRY
	MOV	R1,R3		;GET LINK TO THE NEW R.E.
	CALLX	RDS		;READ IT, SAVING THE PREVIOUS
	MOV	R5,-(SP)	;NEXT R.E. LINK GOES HERE
	MOV	R3,-(SP)	;LINK TO THIS R.E. FOR NEXT R.E.
	CLR	(R5)+		;FOR NOW, NEXT R.E. = 0
20$:	MOV	R2,(R5)+	;SET UP RETRIEVAL POINTER
	MARK	FIBUF		;FIBUF HAS CHANGED
	ADD	CLURAT,R2	;UPDATE RETRIEVAL POINTER FOR CTG FILE
	SOB	R4,10$		;LOOP FOR EACH PACK CLUSTER TO ALLOCATE
	CMP	(SP)+,(SP)+	;DUMP POINTERS TO PREVIOUS R.E.
	MOV	(SP)+,R1	;R1 = LINK TO FILE NAME ENTRY
	MOV	(SP)+,R3	;R3 = LINK TO LAST NAME ENTRY IN UFD
	CALLX	RDS		;READ IT
	MOV	R1,(R5)		;FORMERLY LAST FILE LINKS TO THIS NEW ONE
	CALLRX	WRITE		;REWRITE FIBUF, RESTORE REGS, EXIT

30$:	CMP	(SP)+,(SP)+	;COULDN'T GET R.E., SO DUMP PTRS TO PREV
	ADD	#2,TOS.R5+4(SP)	;R5 WILL EVENTUALLY BE 6
	MOV	(SP)+,R3	;R3 = LINK TO NAME ENTRY
	CALLX	RDB		;GET NAME ENTRY
	MOV	UAA(R5),R3	;R3 = A.E. LINK FOR DELETION
	MOV	UAR(R5),R1	;R1 = R.E. LINK FOR DELETION
	CLR	(R5)+		;MAKE THE NAME ENTRY A HOLE
	CLR	(R5)+
	CALLX	RDS		;GET THE ACCOUNTING ENTRY
40$:	CLR	(R5)+		;MAKE IT A HOLE
	CLR	(R5)+
	MOV	R1,R3		;COPY LINK TO (NEXT) RETRIEVAL ENTRY
	BIC	#17,R3
	BEQ	60$		;NO MORE, FINISH UP
	CALLX	RDS		;GET THE R.E.
	MOV	(R5),R1		;SAVE LINK TO NEXT R.E.
	BR	40$		;GO MAKE IT A HOLE

GLOBAL	<CLURAT>

50$:	MOV	(SP)+,R3	;COULDN'T GET NAME ENTRY. LINK TO A.E.
	CALLX	RDS		;GET ACCOUNTING ENTRY
	CLR	(R5)+		;MAKE IT A HOLE
	CLR	(R5)+
60$:	ADD	#2,TOS.R5+2(SP)	;R5 WILL BE 4 FOR NO NAME ENTRY
	MARK	FIBUF
70$:	TST	(SP)+		;DUMP LINK TO LAST NAME ENTRY IN UFD
	ADD	#2,TOS.R5(SP)	;R5 WILL BE 2 FOR NO ACCOUNTING ENTRY
	CALLRX	WRITEC		;WRITE EVERYTHING, GO BACK WITH R5 <> 0

80$:	ERF	<"INIT bug - file exists when trying to create">

90$:	ERF	<"INIT bug - no UFD found in create">

.DSABL	LSB

.SBTTL	GET THE ON-DISK SAT INTO MEMORY

.ENABL	LSB

GETSAT:	REGSCR			;SAVE ALL REGS
	MOV	#FQSATT,R4	;R4 -> SATT.SYS FIRQB TO ENSURE IT'S OPEN
	CALLX	LOKFIL		;OPEN IT
	BCS	10$		;OUCH
	MOV	FCSATT+FCSIZ,R0	;R0 = NUMBER OF BLOCKS IN THE SAT
	SWAB	R0		;COMPUTE A BLOCK COUNT
	CMP	R0,#4*4000/2	;TOO BIG (OVER 4K WORDS) ?
	BHI	20$		;YES
	MOV	#FCSATT,R1	;R1 -> SATT.SYS FCB FOR READ
	CLR	FCNVB(R1)	;START AT BLOCK 0
	CALLX	READ.,R5,SATBUF	;DO IT
	RETURN

10$:	ERF	<"SATT.SYS non-existent at time of read">

20$:	ERF	<"SATT.SYS is over 16. blocks long">

.DSABL	LSB

GLOBAL	<FQSATT,FCSATT,SATBUF>

.SBTTL	ALLOCATE BADB.SYS AFTER DELETING FILES

.ENABL	LSB

ALCBAD:	REGSCR			;SAVE REGISTERS
	MOV	#FCBADB,R1	;POINT TO BADB.SYS FCB
	TST	FCSIZ(R1)	;ANY BADS?
	BEQ	60$		;NO, EASY OUT
	CALLX	RNB		;GET NAME ENTRY FOR BAD BLOCK FILE
	MOV	UAR(R5),R3	;R3 = LINK TO FIRST NAME ENTRY
10$:	BIC	#17,R3		;REMOVE FLAG BITS
	BEQ	60$		;DONE
	CALLX	RDB		;READ THE RETRIEVAL ENTRY
	MOV	(R5)+,R3	;R3 = LINK TO NEXT
20$:	MOV	(R5)+,R0	;NEXT RETRIEVAL POINTER
	BEQ	60$		;NONE, SO DONE
	DEC	R0		;CONVERT DCN TO PCN
	MOV	CLURAT,R1	;BY PCN = (DCN-1)/CLURAT
30$:	ASR	R1		;SHIFT DIVISOR
	BCS	40$
	;CLC
	ROR	R0		;SHIFT DIVIDEND
	BR	30$

40$:	CALLX	FIXREG		;CHANGE TO BIT AND BYTE
	CMP	R4,SATSYS+BYTS	;TOO BIG FOR SATT?
	BHIS	50$		;YES, SKIP IT
	BISB	BITBYT(R2),SATBUF(R4) ;NO, ALLOCATE IT
50$:	BIT	R5,#17		;DONE WITH THIS RETRIEVAL ENTRY
	BNE	20$		;NO
	BR	10$		;YES

60$:	RETURN			;DONE

.DSABL	LSB

GLOBAL	<FCBADB,CLURAT,SATSYS,BITBYT,SATBUF>

ENDOVL	<DEF,DEFCTL,DEFTXT,MEMOTB,MEMOTX,BEGTXT,BEG,BEGCTL>,0

	.TITLE	DEFALT

	.END
