	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
	.INCLUDE /INIT:INIPFX/
TITLE	INITTM,<TELETYPE MAPPED ROUTINES>,0A,10-MAY-91,GPK

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;


.SBTTL	EDIT HISTORY FOR INITTM

;+
;
;  000	GPK  25-Sep-86	Created by splitting from INITTY
;  001	PJH  10-Apr-87	Move QCLOKI code back to (Mapped) INITTY
;
;-


.SBTTL	DEFINITIONS AND MACROS

; COMMON ASCII DEFINITIONS

.EQUATE	BELL	, 7
.EQUATE	TAB	, 11
.EQUATE	LF	, 12
.EQUATE	VT	, 13
.EQUATE	FF	, 14
.EQUATE	CR	, 15
.EQUATE	ESCAPE	, 33
.EQUATE	SPACE	, 40
.EQUATE	BS	, 10

DEFORG	TTMTXT

.MACRO	I.MESS
	 TMPORG	TTMTXT
.NLIST	BEX
.ENDM	I.MESS


.SBTTL	TYPE-OUT SUBROUTINES

;-
; RCTRLO - RESET CONTROL O IF SET
;
;	CALL	RCTRLO
;
; NOTE:	<CR><LF> DONE IF RESET
;-

	DEFORG	TTM

.ENABL	LSB

RCTRLO::CMP	RINGS,RINGE	;IS THERE ANYTHING IN THE INPUT RING?
	BEQ	10$		;NO, DO THE RESET
	CMPB	@RINGS,#'C-100	;YES, IS THERE A ^C PENDING?
	BEQ	110$		;SURE IS, IGNORE THE REQUEST
10$:	TST	CTLOFG		;IS THERE ^O PENDING?
	BEQ	110$		;NO, JUST EXIT
	CLR	CTLOFG		;YES, RESET IT
	.CALLR	TYPECR		; and exit by typing a CR

;+
; TYPE   - TYPE A CHARACTER ON THE TERMINAL
; TYPECR - TYPE CR/LF ON THE TERMINAL
; TYPE2  - TYPE 2 CHARACTERS ON THE TERMINAL
; TYPTAB - TYPE A TAB (SPACE OUT TO NEXT TAB STOP)
;
;	R2 =  CHARACTER TO TYPE (2ND IN HIGH BYTE IF TYPE2)
;
;	CALL	TYPE??
;
;	R2 =  RANDOM IFF TYPE2 CALLED
;
; NOTES: SPECIAL VALUE	FUNCTION
;
;	     177	RESET CTRL/O
;	     176	IGNORED (IN-MEMORY FILL)
;	     200	TYPE <CR><LF>
;	      11	HORIZONTAL TAB
;-

TYPECR::MOV	R2,-(SP)	;SAVE R2
	MOV	#30$,-(SP)	;RESTORE R2 WHEN DONE
	MOV	(PC)+,R2	;TYPE CR/LF
	 .BYTE	CR,LF
TYPE2::	CALL	TYPE		;TYPE THE FIRST CHARACTER
	SWAB	R2		;GET THE SECOND
	BEQ	110$		;DON'T TYPE 2 IF NO SECOND CHARACTER
TYPE::	CMPB	R2,#200		;A SPECIAL <CR><LF> GADGET?
	BEQ	TYPECR		;YUP, TYPE CRLF
	CMPB	R2,#176		;SKIP IT?
	BEQ	110$		;YUP
	CMPB	R2,#177		;FORCE RESET OF ^O?
	BEQ	RCTRLO		;YES, DO IT
	CMPB	R2,#TAB		;TAB?
	BNE	40$		;NO
TYPTAB::MOV	R2,-(SP)	;YES, SAVE IT
	MOV	#SPACE,R2	;DO A SPACE
20$:	CALL	40$		;SEND A CHARACTER
	BIT	TYPEHT,#7	;ARE WE AT A TAB STOP (MULTIPLE OF 8)?
	BNE	20$		;NO
30$:	MOV	(SP)+,R2	;RESTORE R2
	RETURN

40$:	MOV	R0,-(SP)	;SAVE R0
50$:	CALL	GETTTY		;EMPTY THE TTY BUFFER IF HE TYPED
	TST	STALL		;SHOULD WE STALL?
	BNE	50$		;YES, DO SO
	TST	CTLTFG		;Processing a CTRL/T?
	BNE	55$		;Yes, ignore state of CTRL/O flag
	TST	CTLOFG		;SILENCED?
	BNE	90$		;YES, OMIT DOING THE OUTPUT
55$:	TSTB	FLGGPK		;Is this a GPK?
	BPL	57$		;No
	CALLX	OUTPI		;Yes, try output to the display
	BCC	90$		;Exit if that did the job
	TSTB	NOTT0		;No display, do we have a console?
	BMI	90$		;No, so don't output anything at all
57$:	MOV	@#I.TKS,R0	;POINT TO THE CONSOLE TERMINAL
	TSTB	4(R0)		;READY FOR OUTPUT?
	BPL	50$		;NO, GO TRY TYPE-AHEAD AGAIN
	MOVB	R2,6(R0)	;SEND THE CHARACTER
	MOV	TTFILL,R0	;GET THE FILL CHARACTERISTICS
	BEQ	90$		;NONE, DON'T FILL
	CMP	R0,#-1		;IS THIS A SCOPE FILL CHARACTER?
	BEQ	90$		;YES, NO FILLING REQUIRED
	CMPB	R0,R2		;FILL AFTER THIS BYTE?
	BNE	90$		;NO
	MOV	R2,-(SP)	;YES, SAVE THIS CHARACTER
	ASH	#-8.,R0		;GET FILL COUNT FROM HIGH BYTE TO LOW
	BPL	70$		;POSITIVE IS EASY
	MOV	TYPEHT,R2	;GET HORIZONTAL POSITION
	MOV	R2,R0		;ASSUME SHORT FILL FOR 0-11
	ASR	R0		;0-11 FILLS 2+(POS/2)
	ADD	#2,R0		;SHORT FILL COMPUTED
	CMP	R2,#12.		;COLUMNS 0 TO 11?
	BLO	70$		;YES, WE HAVE THE FILL
	MOV	#8.,R0		;NO, ASSUME A FILL OF 8
	SUB	#37.,R2		;IS POSITION 12-36?
	BMI	70$		;YES, FILL IS EXACTLY 8
60$:	INC	R0		;NO, FILL IS 9+((POS-37.)/10.)
	SUB	#10.,R2		;DIVIDE BY 10
	BGT	60$		;GOT MORE TO GO
70$:	CLR	R2		;FILL WITH NULLS
80$:	CALL	TYPE		;SEND OUT A NULL
	SOB	R0,80$		;REPEAT AS NEEDED
	MOV	(SP)+,R2	;NO, RESTORE R2
90$:	MOV	(SP)+,R0	;RESTORE R0
	CMPB	R2,#CR		;RETURN?
	BNE	100$		;NO
	CLR	TYPEHT		;YES, POSITION IS NOW 0
100$:	BITB	R2,#140		;PRINTABLE?
	BEQ	110$		;NOPE
	INC	TYPEHT		;YES, WE ARE ONE MORE OVER
110$:	MOV	#-1,HDRIDX	;DISK CSR HEADER IS NO LONGER VALID
	MOV	#-1,HDRUNT
	RETURN

.DSABL	LSB

GLOBAL	<RINGS,RINGE,CTLOFG,TYPEHT,STALL,CTLTFG>
GLOBAL	<I.TKS,TTFILL,FLGGPK,HDRIDX,HDRUNT>


.SBTTL	INPUT A LINE

;+
; GETIN  - INPUT A LINE FROM THE TERMINAL
; GETINL - INPUT A LINE FROM THE TERMINAL, ALLOW LOWER CASE
;
;	CALL	GETIN?
;
;	R1 -> ASCIZ STRING TYPED (= ADDRESS OF KBUFF) ON WORD BOUNDARY
;
;	Z=1 (BEQ BRANCHES) IF ANSWER WAS <CR> ONLY, OR '?'
;	C=0 ALWAYS
;
; NOTES:HANDLES RUBOUTS, ^U, ^C, ECHOING
;	<LF> AND CTRL/Z ARE LEGAL ONLY AS FIRST CHARACTER
;	<CR> ENDS STRING BUT IS NOT ENTERED INTO BUFFER
;	LOWER CASE IS CONVERTED TO UPPER CASE IF GETIN IS CALLED
;-

.ENABL	LSB

GETINL::CLR	LCFLAG		;ALLOW LOWER CASE
	BR	10$

GETIN::	MOV	#40,LCFLAG	;CONERT LOWER CASE TO UPPER CASE
10$:	TSTB	AUTOQS		;AUTO ANSWERS?
	BPL	20$		;NO, WE CAN DO QUESTIONS
	ERF	<"Question attempted during auto-restart.">

20$:	REGSAV			;SAVE REGISTERS
30$:	MOV	#KBUFF,R1	;POINT TO BUFFER
	MOV	R1,TOS.R1(SP)	;AND RETURN IT IN R1
	CLRB	RUBS		;CLEAR RUBOUT FLAG
40$:	CALL	GETTTY		;SCAN THE TERMINAL FOR A CHARACTER
	MOV	#RINGS,R0	;POINT TO THE RING START
	CMP	(R0)+,(R0)	;START = END?
	BEQ	40$		;YES, SCAN THE TTY AGAIN
	MOVB	@-(R0),R2	;NO, GET A BYTE
	INC	(R0)		;ADVANCE START POINTER
	CMP	(R0),#ENDRNG	;END OF RING?
	BLO	50$		;NO
	MOV	#STRRNG,(R0)	;YES, RESET IT
50$:	CMPB	R2,#'C-100	;^C??
	BNE	60$		;NO
	JMP	250$		;YES, GO EXIT

60$:	CALL	RCTRLO		;NO, ENSURE THAT IT ECHOS
	CMPB	R2,#177		;RUBOUT?
	BNE	120$		;NO

GLOBAL	<LCFLAG,KBUFF,ENDRNG,STRRNG,AUTOQS>


	CMP	TTFILL,#-1	;IS THIS A SCOPE TYPE TERMINAL?
	BNE	70$		;NOPE, DO NORMAL TTY RUBOUTS
	CMP	R1,#KBUFF	;ALREADY AT BEGINNING OF LINE?
	BEQ	40$		;YES, IGNORE RUB (NOTHING TO DO)
	MOV	(PC)+,R2	;GET CHARACTERS TO TYPE FOR RUBOUT
	 .BYTE	BS,SPACE	; BACKSPACE AND A SPACE
	CALL	TYPE2		;RUB THE CHARACTER FROM THE SCOPE
	MOVB	#BS,R2		;GET ONE MORE BACKSPACE
	CALL	TYPE		;TYPE IT
	DEC	R1		;COUNT ONE LESS CHARACTER IN BUFFER
	BR	40$		; AND RESUME SCANNING FOR CHARACTERS

70$:	TSTB	RUBS		;ALREADY INTO RUBOUTS?
	BNE	80$		;YES
	CMP	R1,#KBUFF	;ALREADY AT START?
	BEQ	40$		;YES, IGNORE IT (NOTHING TO RUB OUT)
	MOVB	#'\,R2		;TYPE \ TO BEGIN RUBOUTS
	CALL	TYPE
	COMB	RUBS		;SWITCH THE SWITCH
80$:	CMP	R1,#KBUFF	;AT BEGINNING?
	BNE	100$		;NO
	MOV	#'\,R2		;TYPE \ TO CLOSE RUBOUTS
90$:	CALL	TYPE2
	CALL	TYPECR		;DO CR/LF
	BR	30$		;AND RESTART

100$:	MOVB	-(R1),R2	;GET CHARACTER TO ECHO
110$:	CALL	TYPE		;ECHO IT
	BR	40$		;CONTINUE GETTING INPUT

120$:	TSTB	RUBS		;NOT A RUBOUT. ARE WE INTO RUBOUTS?
	BEQ	130$		;NO
	MOV	R2,-(SP)	;YES, SAVE THE CHARACTER
	MOVB	#'\,R2		;TYPE \ TO CLOSE RUBOUTS
	CALL	TYPE
	MOV	(SP)+,R2	;RESTORE CHAR
	CLRB	RUBS		;CLEAR SWITCH
130$:	CMPB	R2,#'U-100	;^U?
	BNE	140$		;NO
	MOV	#"^U,R2		;YES, ECHO APPROPRIATELY
	BR	90$		;ECHO CR/LF AND RESTART LINE

GLOBAL	<RUBS,KBUFF>




140$:	CMPB	R2,#'R-100	;^R?
	BNE	170$		;NOPE
	MOV	#"^R,R2		;YEP, ECHO AN "^R"
	CALL	TYPE2		; (PRINT IT)
	CALL	TYPECR		;  FOLLOWED BY A CARRIAGE RETURN
	MOV	R3,-(SP)	;SAVE A REGISTER
	MOV	#KBUFF,R3	;GET A POINTER TO THE BEGINNING OF THE BUFFER
150$:	CMP	R3,R1		;ARE WE TO THE END YET?
	BNE	160$		; NOPE, GO PRINT THE CHARACTER
	MOV	(SP)+,R3	;RESTORE R3
	BR	40$		;  AND GET NEXT CHARACTER

160$:	MOVB	(R3)+,R2	;GET A CHARACTER TO TYPE
	CALL	TYPE		; TYPE IT
	BR	150$		;  AND LOOP FOR MORE

170$:	CMPB	R2,#'Z-100	;^Z?
	BNE	180$		;NO
	CMP	R1,#KBUFF	;IT MUST BE ALONE ON THE LINE
	BNE	240$		;NO, BELL HIM
	MOVB	R2,(R1)+	;PUT IT IN
	TYPE2	<"^Z>		;ECHO APPROPRIATELY
	BR	190$		;AND EXIT

180$:	CMPB	R2,#LF		;LF?
	BNE	210$		;NO
	CMP	R1,#KBUFF	;YES, AT START OF LINE?
	BNE	240$		;NO IS ERROR, DING HIM
	MOVB	R2,(R1)+	;YES, SAVE THE LF IN THE LINE
190$:	CLRB	(R1)+		;MAKE INPUT ASCIZ
200$:	CALL	TYPECR		;RESTORE THE CARRIAGE
	CALLX	REGRES,R5	;RESTORE REGISTERS
	MOV	#KBUFF,R1	;POINT HIM TO THE ANSWER
	CMPB	(R1),#'?	;QUESTION MARK?
	CLC			;RETURN C=0 AND Z=?
	RETURN

GLOBAL	<KBUFF,TTFILL>




210$:	CMPB	R2,#CR		;CR?
	BNE	220$		;NO, CHECK CASE
	CMP	R1,#KBUFF	;YES, AT START OF LINE?
	BNE	190$		;NO, NORMAL END
	MOVB	#LF,(R1)+	;MAKE IT A <LF> TO ACCEPT DEFAULT
	BR	190$		;AND FINISH UP

220$:	CMPB	R2,#'A+40	;LOWER CASE?
	BLO	230$		;NO
	BIC	LCFLAG,R2	;YES, CONVERT TO UPPER
230$:	CMP	R1,#KBUFF+70.	;TOO FAR INTO BUFFER?
	BHIS	240$		;YES, DING HIM
	MOVB	R2,(R1)+	;NO, SAVE THE BYTE
	BITB	R2,#140		;PRINTABLE?
	BNE	110$		;YES
	DEC	R1		;NO, DON'T STORE IT
240$:	MOVB	#BELL,R2	;RING A BELL
	BR	110$		;TYPE IT AND CONTINUE

250$:	CLR	CTLOFG		;ENSURE ^O IS OFF
	MOV	#"^C,R2		;ECHO ^C AS ^C
	CALL	TYPE2
	TST	CC.DBL		;^C DISABLED?
	BNE	260$		;YES
	EXIT			;GO AWAY

260$:	MOV	#'C-100,KBUFF	;SHOVE ^C INTO BUFFER
	BR	200$		;SO THAT CALLER CAN HANDLE IT

.DSABL	LSB

GLOBAL	<KBUFF,LCFLAG,CTLOFG,CC.DBL>


.SBTTL	WAIT FOR TTY TO STOP

;+
; TTYSTP - WAIT FOR TTY TO STOP
;
;	CALL	TTYSTP
;
;	R2 =  RANDOM
;-

TTYSTP::TSTB	NOTT0		;Do we lack a console?
	BMI	20$		;Yes, then don't wait for it
	MOVB	#377,R2		;TYPE RUBOUT FOR SYNCHRONIZATION
	CALL	TYPE
	MOV	@#I.TKS,R2	;R2 -> CONSOLE CSR
10$:	TSTB	4(R2)		;READY?
	BPL	10$		;NO
20$:	RETURN			;YES

GLOBAL	<I.TKS,NOTT0>


.SBTTL	GET A CHARACTER FROM THE TERMINAL & BUFFER IT

GETTTY::MOV	R0,-(SP)	;SAVE R0 HERE
	CALLX	GETCLK		;WATCH THE CLOCK CLOSELY		;001
10$:	TSTB	FLGGPK		;Is this a GPK?
	BPL	12$		;No, skip
	CALLX	GETLK		;Try to get from the GPK keyboard
	BCC	13$		;Got something, process it
12$:	MOV	@#I.TKS,R0	;R0 -> TERMINAL CSR
	TSTB	(R0)		;ANYTHING THERE?
	BPL	70$		;NO, RETURN
	MOVB	2(R0),R0	;YES, GET THE DATA
13$:	BIC	#^C<177>,R0	;TRIM THE PARITY BIT
	BEQ	10$		;A NULL, SO TRY AGAIN
	CMP	R0,#'T-100	;^T? (used for debugging purposes only)
	BNE	15$		;No
	TST	CTLTFG		;Are we processing a ^T now?
	BNE	10$		;Yes, do nothing. (^T process calls GETTTY)
	MOV	2(SP),R0	;Yes, put PC in R0
	CALLX	CNTRLT		;  and process it quick
	BR	10$		;Check for any more

15$:	CMP	R0,#'P-100	;ODT ENTRY?
	BNE	20$		;NO
	CMP	HALTER,#BPT	;BREAKPOINTS ALLOWED?
	BNE	20$		;NO
	BPT			;YES, ENTER ODT
	BR	10$		;TRY FOR MORE

20$:	CMPB	R0,#'S-100	;Stall output?
	BNE	25$		;No
	MOV	SP,STALL	;Yes, stall it
	BR	10$		; and back

25$:	CMPB	R0,#'Q-100	;Unstall?
	BNE	27$		;No
	CLR	STALL		;Yes, do it
	BR	10$		; and back

27$:	CMPB	R0,#'O-100	;^O MAYBE?
	BNE	30$		;NO, A REAL CHARACTER
	COM	CTLOFG		;FLIP THE SWITCH
	BNE	10$		;^O TURNED ON, TRY FOR MORE
	MOV	(SP)+,R0	;RESTORE R0
	CALLR	TYPECR		;AND ECHO <CR><LF> FOR ^O

30$:	MOVB	R0,@RINGE	;SAVE THE BYTE IN THE RING
	MOV	#RINGE,R0	;POINT TO THE RING POINTERS
	CMPB	@(R0)+,#'C-100	;^C TYPED?
	BNE	40$		;NO
	MOV	-(R0),-(R0)	;YES, PURGE THE RING
	CMP	(R0)+,(R0)+	;FIX R0
	MOV	#-1,CTLOFG	;TURN OFF ALL ECHOING
	CLR	STALL		; but unstall as if ^Q was used
40$:	INC	-(R0)		;ADVANCE THE FILL SIDE
	CMP	(R0),#ENDRNG	;AT THE END?
	BLO	50$		;NO
	MOV	#STRRNG,(R0)	;YES, POINT TO THE START
50$:	CMP	(R0),-(R0)	;END = START NOW ?
	BNE	10$		;NO, TRY FOR ANOTHER
	TST	(R0)+
	CMP	(R0),#STRRNG	;BACK UP. FROM THE BEGINNING?
	BHI	60$		;NO
	MOV	#ENDRNG,(R0)	;YES, POINT TO THE END
60$:	DEC	(R0)		;BACK UP THE POINTER, DISCARD TYPEAHEAD
70$:	MOV	(SP)+,R0	;RESTORE R0
	RETURN			;GO BACK NOW

GLOBAL	<I.TKS,HALTER,FLGGPK,STRRNG,ENDRNG>


.SBTTL	HEXADECIMAL PRINTERS

;+
; HEXBYT - PRINT A HEXADECIMAL BYTE (2 DIGITS)
;
;	R2 = NUMBER TO PRINT
;	CALL	HEXBYT
;	R2 DESTROYED
;-

HEXBYT::MOV	R2,-(SP)	;Save R2
	ASH	#-4,R2		;Shift high nybble into low
	CALL	10$		;Output high nybble
	MOV	(SP)+,R2	;Get low nybble
	.BR	10$		;Output it and return

10$:	BIC	#^C<17>,R2	;Clear everything but low nybble
	CMPB	R2,#10.		;0-9 or A-F?
	BLO	20$		;0-9.  Leave it alone
	ADD	#<'A-'0-10.>,R2	;Bias value for A-F
20$:	ADD	#'0,R2		;Turn into ASCII
	CALLR	TYPE		;Type the character and return


.SBTTL	OCTAL PRINTERS

;+
; OCTWRD - PRINT AN OCTAL NUMBER (6 DIGITS)
; OCTBYT - PRINT AN OCTAL BYTE (3 DIGITS)
; OCT3DG - PRINT 3-DIGIT OCTAL NUMBER
; OCT4DG - PRINT 4-DIGIT OCTAL NUMBER
;
;	R0 =  NUMBER TO PRINT
;	CALL	OCT???
;	All registers preserved
;-

.ENABL	LSB

OCTWRD::REGSCR			;SAVE REGS
	MOV	#6,R1		;COUNT IS 6
	BR	20$		;DO IT

OCT4DG::REGSCR			;SAVE REGISTERS
	MOV	#4,R1		;PRINT LOW 4 DIGITS
	BR	20$

OCT3DG::REGSCR			;SAVE REGS
	BR	10$		;AND DO 3 DIGITS


OCTBYT::REGSCR			;SAVE REGS
	BIC	#^C<377>,R0	;CLEAR OTHER BITS
10$:	MOV	#3,R1		;COUNT IS 3
20$:	MOV	#-1,-(SP)	;SET STOPPER FLAG
30$:	MOV	R0,-(SP)	;MOVE BITS TO STACK
	BIC	#^C<7>,(SP)	;ISOLATE BOTTOM OCTAL DIGIT
	ADD	#'0,(SP)	;MAKE IT ASCII
	;CLC			;ADD CLEARS THE CARRY
	ROR	R0		;SHIFT RIGHT 3 BITS
	ASR	R0
	ASR	R0
	SOB	R1,30$		;CONTINUE FOR ALL DIGITS
40$:	MOV	(SP)+,R2	;GET A DIGIT
	BMI	50$		;DONE
	CALL	TYPE		;TYPE IT
	BR	40$		;CONTINUE

50$:	RETURN

.DSABL	LSB


.SBTTL	DECIMAL PRINTERS

;+
; DBLPRT - PRINT DOUBLE-PREC NUMBER IN DECIMAL, BLANK FILL
; DBLZER - PRINT DOUBLE-PREC NUMBER IN DECIMAL, NO BLANKS
;
;	R2 = NUMBER TO PRINT (LSB)
;	R3 = NUMBER TO PRINT (MSB)
;
;	CALL	DBL???
;-

.ENABL	LSB

DBLPRT::REGSCR			;SAVE REGISTERS
	MOV	#6,R5		;PRINT INTO A COLUMN 6 SPACES WIDE
	BR	10$

DBLZER::REGSCR			;SAVE REGISTERS
	CLR	R5		;DON'T ADD ANY LEADING SPACES
10$:	MOV	R2,R1		;MOVE LSB TO WHERE WE CAN WORK ON IT
	BR	30$

;+
; DECPRT - PRINT NUMBER IN DECIMAL WITH LEADING BLANKS
; DECZER - PRINT NUMBER IN DECIMAL, BLANK SUPPRESSED
; P4DDIG - PRINT 4-DIGIT NUMBER IN DECIMAL, BLANK FILL
;
;	R0 = NUMBER TO PRINT
;
;	CALL	DEC???
;-

DECPRT::REGSCR			;SAVE REGISTERS
	MOV	#6,R5		;PRINT INTO A COLUMN 6 SPACES WIDE
	BR	20$

P4DDIG::REGSCR			;SAVE REGISTERS
	MOV	#4,R5		;PRINT INTO A COLUMN 4 SPACES WIDE
	BR	20$

DECZER::REGSCR			;SAVE REGISTERS
	CLR	R5		;DON'T ADD ANY LEADING SPACES
20$:	CLR	R3		;MSB ARGUMENT IS ZERO
	MOV	R0,R1		;MOVE LSB TO WHERE WE CAN WORK ON IT


; R1 = LSB OF NUMBER TO BE PRINTED
; R3 = MSB OF NUMBER TO BE PRINTED
; R5 = MINIMUM WIDTH OF COLUMN TO PRINT
;
; DIVIDE THE NUMBER BY 10 (AT LEAST ONCE) UNTIL THE QUOTIENT IS ZERO,
; AND PUSH THE REMAINDERS ON THE STACK.  THESE ARE THE DIGITS OF THE
; NUMBER'S DECIMAL REPRESENTATION, FROM RIGHT TO LEFT.
; R4 WILL COUNT THE DIGITS PUSHED.

30$:	CLR	R4		;NO DIGITS PUSHED YET
	CLR	R2		;HIGH-HIGH ORDER = 0
	ASL	R1		;KEEP ONLY 15 BITS IN LOW WORD
	ROL	R3		;OVERFLOW INTO HIGH WORDS
	ROL	R2
	ROR	R1		;LOW WORD IS KEPT RIGHT-JUSTIFIED
50$:	DIV	#10.,R2		;DIVIDE MSB IN R3, BY 10.  Q -> R2, R -> R3
	MOV	R3,R0		;REMAINDER < 10 IS HIGH WORD FOR NEXT DIV
	MOV	R2,R3		;QUOTIENT IS USED NEXT TIME THRU LOOP
	CLR	R2		;HIGH-HIGH IS ZERO NEXT TIME
	ASL	R1		;LEFT-ADJUST 15-BIT LSB
	ASHC	#-1,R0		;TO PACK SO QUOTIENT FITS IN 15 BITS
	DIV	#10.,R0		;DIVIDE LSB BY 10. Q -> R0, R -> R1
	MOV	R1,-(SP)	;PUSH THE REMAINDER (IT'S A DIGIT)
	INC	R4		;COUNT DIGITS PUSHED
	MOV	R0,R1		;QUOTIENT IS USED NEXT TIME THRU LOOP
	BIS	R3,R0		;IS ENTIRE NUMBER NOW ZERO?
	BNE	50$		;REPEAT UNTIL IT IS ZERO
	SUB	R4,R5		;WIDTH - DIGITS => NUMBER OF LEADING BLANKS
	BLOS	70$		;NO SPACES IF DIGITS >= COLUMN SIZE
	MOV	#SPACE,R2
60$:	CALL	TYPE		;TYPE SPACES
	SOB	R5,60$		;REPEATEDLY

; UNSTACK AND PRINT THE DIGITS (WE KNOW THERE'S AT LEAST ONE)

70$:	MOV	(SP)+,R2	;UNSTACK A DIGIT
	ADD	#'0,R2		;MAKE ASCII
	CALL	TYPE		;TYPE IT
	SOB	R4,70$		;REPEAT
	RETURN

.DSABL	LSB


.SBTTL	PRINT FILE NAME

;+
; TYPFIL - PRINT FILE NAME FROM FIRQB
;
;	R4 -> FIRQB
;
;	CALL	TYPFIL
;-

.ENABL	LSB

TYPFIL::REGSCR			;SAVE REGISTERS
	ADD	#FQNAM1,R4	;POINT TO NAME
	MOV	(R4)+,R0	;GET NAME PART 1
	CALL	10$		;PRINT IT
	MOV	(R4)+,R0	;NAME PART 2
	CALL	10$		;PRINT IT
	MESSAGE	<".">		;DOT
	MOV	(R4)+,R0	;EXTENSION
	BR	10$		;PRINT IT AND RETURN


.SBTTL	RAD50 PRINTERS

;+
; RADPRT - PRINT RAD50 WORD
; RADZER - PRINT RAD50 WORD W/ BLANKS SUPPRESSED
; RADCNV - CONVERT RAD50 WORD TO ASCII
;
;	R0 =  RAD50 WORD
;	R4 -> LOCATION TO STORE ASCII STRING (IF CALL = RADCNV)
;
;	CALL	RAD???
;-

RADCNV::REGSCR			;SAVE REGISTERS
	MOV	#-1,R2		;SET FLAG FOR CONVERSION TO ASCII
	MOV	#SPACE,R5	;FILLER IS SPACE FOR 0
	BR	30$

RADPRT::REGSCR			;SAVE REGISTERS
	MOV	#SPACE,R5	;FILLER IS SPACE FOR 0
	BR	20$

RADZER::REGSCR			;SAVE REGISTERS
10$:	CLR	R5		;SUPPRESS SPACES
20$:	CLR	R2		;SET FLAG FOR NO CONVERSION TO ASCII
30$:	MOV	R2,-(SP)	;PUT FLAG ON THE STACK
	MOV	#110$,R1	;POINT TO TABLE OF DIVISORS
	MOV	R0,R3		;COPY THE WORD TO PRINT
40$:	CLR	R2		;CLEAR FOR DIVIDE
	DIV	(R1)+,R2	;DIVIDE
	;TST	R2		;IS THE RESULT A SPACE? (FROM DIVIDE)
	BNE	50$		;NO
	MOV	R5,R2		;YES, MAKE IT BLANK (MAYBE)
	BEQ	90$		;NO, IGNORE NULLS
	BR	70$		;YES, PRINT IT

50$:	CMP	R2,#26.		;ALPHABETIC?
	BHI	60$		;NO
	ADD	#'A-1,R2	;YES, MAKE IT ASCII
	BR	70$		;AND TYPE IT

60$:	MOVB	100$-27.(R2),R2	;GET SPECIAL CHARACTER OR DIGIT
70$:	TST	(SP)		;SEE IF WE ARE TYPING OR CONVERTING
	BEQ	80$		;WE ARE TYPING, SO CALL THE TYPER
	MOVB	R2,(R4)+	;CONVERTING, STORE THIS CHARACTER
	BR	90$		;DO END OF LOOP TEST

80$:	CALL	TYPE		;TYPE IT AND RETURN
90$:	TST	(R1)		;ANY MORE TO DO?
	BNE	40$		;YES, LOOP ON IT
	TST	(SP)+		;REMOVE FLAG FROM STACK
	RETURN

	I.MESS
100$:	.ASCII	"$.?0123456789"	;RAD50 TRANSLATION FOR 27.-39.
	UNORG

110$:	.WORD	50*50,50,1,0	;DIVISORS FOR RADIX 50 CONVERSION

.DSABL	LSB


.SBTTL	OCTAL & DECIMAL INPUTTERS

;+
; OCTINP - TRANSLATE AN OCTAL NUMBER
; DECINP - TRANSLATE A DECIMAL NUMBER
;
;	R1 -> STRING TO TRANSLATE
;
;	CALL ???INP
;
;	R0 = VALUE
;	R1 = UPDATED POINTER
;	CONDITION CODES SET FROM TSTB OF ENDING CHARACTER
;		(Z=1 MEANS NULL BYTE, USUALLY DESIRED)
;
;	SCAN STOPS ON CHARACTER ILLEGAL FOR SPECIFIED RADIX OR
;		IF OVERFLOW IS ENCOUNTERED
;-

OCTINP::TST	(PC)+		;CLEAR CARRY
DECINP::SEC			;SET CARRY
	REGSAV			;SAVE REGISTERS
	MOV	#4,R5		;R5 = RADIX/2
	ADC	R5		;10. IF ENTERED AT DECINP
	ASL	R5		;R5 = RADIX
	CLR	R3		;CLEAR THE ACCUMULATOR
10$:	MOVB	(R1)+,R0	;GET NEXT BYTE
	SUB	#'0,R0		;CONVERT FROM ASCII
	CMP	R0,R5		;CHECK AGAINST RADIX
	BHIS	20$		;TOO BIG TO BE A DIGIT
	MOV	R3,R2		;PUT OLD VALUE WHERE WE CAN MULTIPLY
	MUL	R5,R2		;PRODUCT MSB -> R2, LSB -> R3
	TST	R2		;DID ANY HIGH-ORDER BITS COME ON?
	BNE	20$		;YES -- UNSIGNED OVERFLOW
	ADD	R0,R3		;ADD IN NEW DIGIT
	BCC	10$		;GOOD, GO FOR ANOTHER BYTE
20$:	MOV	R3,TOS.R0(SP)	;RETURN VALUE IN R0
INPDNE:	MOV	R1,TOS.R1(SP)	;RETURN UPDATED POINTER IN R1
	CALLX	REGRES,R5	;RESTORE REGISTERS
	TSTB	-(R1)		;POINT TO UNUSED CHAR, SET CONDITION CODES
	RETURN


.SBTTL	DOUBLE PRECISION DECIMAL INPUTTER

;+
; DBLINP - SCAN OFF A DOUBLE PRECISION DECIMAL NUMBER
;
;	R1 -> STRING TO SCAN
;
;	CALL DBLINP
;
;	R1 -> FIRST UNSCANNED BYTE
;	R2 =  VALUE (LSB)
;	R3 =  VALUE (MSB)
;	CONDITION CODES SET FROM TSTB OF ENDING CHARACTER
;		(Z=1 MEANS NULL BYTE, USUALLY DESIRED)
;
;	SCAN STOPS ON CHARACTER ILLEGAL FOR SPECIFIED RADIX OR
;		IF OVERFLOW IS ENCOUNTERED
;-

DBLINP::REGSAV			;SAVE REGISTERS
	CLR	R2		;CLEAR ACCUMULATOR
	CLR	R3
	CLR	-(SP)		;ALLOCATE SPACE FOR DIGIT
10$:	MOVB	(R1)+,(SP)	;GET A DIGIT
	SUB	#'0,(SP)	;REDUCE ASCII DIGITS TO RANGE 0-9
	MOV	#9.,R0		;SET COUNTER FOR ADD LOOP BELOW
	CMP	(SP),R0		;IS THE CHARACTER LEGAL?
	BHI	30$		;NO -- RETURN
	MOV	R3,R5		;COPY PARTIAL RESULT FOR ADDING
	MOV	R2,R4
20$:	ADD	R4,R2		;ADD LSB
	ADC	R3
	BCS	30$		;SKIP OUT ON UNSIGNED OVERFLOW
	ADD	R5,R3		;ADD MSB
	BCS	30$		;SKIP OUT ON UNSIGNED OVERFLOW
	SOB	R0,20$		;ADD 9 TIMES TO MAKE 10X TOTAL
	ADD	(SP),R2		;ADD THE DIGIT
	ADC	R3
	BCC	10$		;GET THE NEXT DIGIT
30$:	TST	(SP)+		;REMOVE TEMP SPACE FROM STACK
	MOV	R2,TOS.R2(SP)	;SAVE ON STACK TO RETURN IN REGISTERS
	MOV	R3,TOS.R3(SP)
	BR	INPDNE		;GO RETURN PROPERLY


.SBTTL	RAD50 INPUTTER

;+
; RADINP - SCAN AND CONVERT 2 WORDS OF RADIX 50
; RADWRD - SCAN AND CONVERT 1 WORD  OF RADIX 50
;
;	R1 -> STRING TO SCAN
;
;	CALL	RAD???
;
;	R0 =  FIRST 3 CHARACTERS
;	R1 -> FIRST UNSCANNED CHARACTER
;	R3 =  NEXT 3 CHARACTERS IFF RADINP
;
;	SCAN STOPS AT FIRST NON-RAD50 CHARACTER OR AFTER 3 (OR 6)
;		CHARACTERS HAVE BEEN SCANNED
;	ONLY LETTERS AND DIGITS ARE ALLOWED
;-

.ENABL	LSB

RADINP::REGSCR			;SAVE REGISTERS
	CALL	RADWRD		;GET A WORD
	MOV	R0,TOS.R0(SP)	;RETURN IT IN R0 ON EXIT
	CALL	RADWRD		;GET ANUDDER
	MOV	R0,TOS.R3(SP)	;RETURN IT IN R3 ON EXIT
	BR	10$		;AND EXIT

RADWRD::REGSCR			;SAVE REGISTERS
	CLR	R3		;CLEAR RETURN VALUE
	MOV	#20$,R5		;A HANDY POINTER
	CALL	(R5)		;GET 3 CHARACTERS
	CALL	(R5)
	CALL	(R5)
	MOV	R3,TOS.R0(SP)	;RETURN ANSWER IN R0 ON EXIT
10$:	MOV	R1,TOS.R1(SP)	;UPDATE R1
	RETURN


; SUBROUTINE TO INPUT A SINGLE RAD50 CHARACTER, AND ADD IT TO
; THE WORD IN R3.  AFTER FINDING A NON-RAD50 CHARACTER, THE
; SUBROUTINE ADDS SPACES WHEN IT IS CALLED.

20$:	MOVB	(R1)+,R0	;GET A CHARACTER
	SUB	#'0,R0		;REDUCE DIGITS TO RANGE 0-9
	CMP	R0,#9.		;IS THIS ONE?
	BHI	30$		;NO -- IT MUST BE A LETTER
	ADD	#30.,R0		;YES -- RAD50 DIGITS ARE 30.-39.
	BR	50$		;GO ACCUMULATE

30$:	ADD	#'0-'A+1,R0	;REDUCE LETTERS TO RANGE 1-26.
	BEQ	40$		;ZERO IS ILLEGAL
	CMP	R0,#26.		;IS THIS A LETTER?
	BLOS	50$		;YES -- GO ACCUMULATE

40$:	DEC	R1		;LEAVE R1 POINTING AT THE BAD CHARACTER
	CLR	R0		;AND USE A SPACE INSTEAD
50$:	MUL	#50,R3		;'SHIFT LEFT' THE OLD VALUE
	ADD	R0,R3		;AND ADD IN THE NEW CHARACTER
	RETURN			;EXIT

.DSABL	LSB

.END
