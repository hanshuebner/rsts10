.INCLUDE /CMN:COMMON/							;059
.INCLUDE /CMN:KERNEL/							;059
.INCLUDE /INIT:INIPFX/							;059
.INCLUDE /CMN:KBDEF/							;059
.INCLUDE /CMN:PKDEF/							;059
.INCLUDE /INIT:DSKDEF/							;059
.INCLUDE /CMN:CFGDEF/							;059
.INCLUDE /DSK:MSCPDF/							;085
TITLE	START,<RSTS/E INIT - START TIMESHARING>,0K,23-JUN-92,RVR/MND/JTC/GPK/AWL/JHC/AWL/FEK/WJS/TPT/MNB/DBM/KPH/DRP/FRL/VAM/DSD/PJH

;
;		COPYRIGHT (c) 1974, 1992 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;


.SBTTL	EDIT HISTORY FOR INISTA

;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-08
;  001	MND  16-Feb-81	Added DMP/DMV support
;  002  MDS  18-MAR-81	Change to start an extended memory dumpin SIL
;  003  SRM  06-May-81  Fix bugs in resident monitor crash file size.
;  004	JTC  08-May-81	Change crash table setup
;  005	MND  01-Jul-81	Distinguish DMR and DMC devices in the DDFLAG
;  006  GPK  01-Jul-81	Load ODT from ODT.SYS rather than the monitor SIL
;  007  SRM  20-Jul-81	Have INIT load monitors that use I & D space.
;  008  CEK  21-Oct-81  Load monitor according to load block.  Decouple
;			use of D-space from moving root I-space area.
;  009	SRM  21-Oct-81	Jam the FBB for the Load Block.
;  010  CEK  30-Oct-81  Return YABUF (Yet Another bufpool)
;
;				[RSTS V7.2]
;  000  CEK  07-Jan-82  CREATION - COPIED FROM V7.1-11
;  001  CEK  07-Jan-82  Made FR20 and FR25 buf quotas reflect D-space buffers
;  002  MND  22-Mar-82  Added support for MSCP disk - UDA50/RA80
;  003  AWL  08-Mar-82  Added support for 22 bit Q-bus processors
;  004  JHC  19-Apr-82  Changed jamming for bootstrap to set up UDA boot
;  005  AWL  22-Apr-82  Inserted from ROOT.MAC an abort of INIT if no RLV12 5th register
;
;				[RSTS V8.0]
;  006	GPK  05-Jul-82	Changes for callable bootstraps
;  007	GPK  24-Sep-82	Bugfixes in 006
;  008	GPK  19-Oct-82	Bugfix in DZSTRT, DMCINI, FINAL
;  009	GPK  21-Oct-82	Source clear V7.2 patch 1.1.12
;  010	GPK  29-Oct-82	Start looking for loader space above INIT;
;			fix word reference to FLG22
;  011	GPK  06-Dec-82	Added auto-go for TAP
;  012  AWL  05-Jan-83  Changed comment on use of FLG22
;
;				[RSTS V9.0]
;  013  MND  25-May-83  Source correct seq 1.1.9
;  014	FEK  11-Jul-83	Turn on user I/D space if available
;  015  WJS  19-Aug-83	LTDS changes
;  016  MND  24-OCT-83	Fix UMT jamming bug in JUMT:
;  017  TPT  11-Nov-83	Merge V8.0-07 changes
;  018  TPT  02-Dec-83  Have DTR set with carrier in VHSTRT
;  019  MNB  22-Jan-84  Asynch changes to M.CTRL byte
;  020	DBM  15-Feb-84	Add jamming of TS: drive types
;  021	FEK  13-MAR-84	J11 cache changes
;  022	MND  14-MAR-84	Jam base memory for Virtual Disk
;  023	MND  14-Apr-84	Fix DV: bug. (Jamming DVDINT into location 0)
;  024	DBM  14-Apr-84	Make 1 Job the required Job Max
;  025	MND  14-May-84	Bug fixes in SETCFW
;  026	DBM  10-Jun-84	Change MS jam for extended feature bit
;  027	KPH  29-Aug-84	Jam KDSAR5 into DPAR5J if I&D available
;  028	DRP  02-Nov-84	Always jam the DM11BB CSR address if one is
;			present regardless of TTMODM setting
;  029	DBM  06-Dec-84	Jam BAE list even on Q-Bus machines
;  030  FRL  15-Mar-85  BUFF.SYS now created in INIDEF, here we set up base
;  031	KPH  18-Mar-85	Jam user mode I&D space even if no kernel I&D space
;  032	FEK  13-Feb-85	Add Jamming for software KG11 RJ2780 support
;			and DZ/DZV and DHV/DHU sortout
;
;			[RSTS V9.1]
;  033	DBM  11-Mar-85	TMSCP support
;  034	KPH  05-Apr-85	Remove primary RTS
;			Terminal driver mapping changes
;  035	DBM  26-May-85	Bug fix for TMSCP only monitors
;			Dynamic CMT support.  Return unused UMT$xx entries.
;  036  KPH  29-May-85	Conditional phases
;  037  KPH  08-Jul-85	Remove AODS
;
;			[RSTS V9.2]
;  038  KPH  15-Jul-85	Add job control region
;
;			[RSTS V9.3]
;  039  KPH  26-Sep-85	Add DECnet conditional phases
;  040	JHC  26-Nov-85	Add UNA/QNA conditional phases
;			Set up UMR$XE jamming if no phase.
;  041  DBM  04-Dec-85	Add Ethernet region jamming (merge by JHC)
;  042  KPH  08-Jan-86	Use DDS.XE and DDS.XH as UNA/QNA DDB sizes
;  043  KPH  14-Jan-86	Add EVL conditional phase
;  044  KPH  06-Feb-86	Add flagging of non-loaded phases
;			Add RDM conditional phase
;  045	JHC  14-Feb-86	Fix support for deallocating XE DDBs
;  046	DBM  11-Mar-86	Fix UMR setup code changed in 041
;  047	DBM  06-Apr-86	QNA jamming fix, UNA UMR address fix
;  048  VAM  29-Apr-86	Remove references to S.??? globals.
;			Remove last of the UNISYS code.
;  049	DBM  12-May-86	Return XE DDB's at proper time.
;  050  VAM  15-May-86	Use TOPPHY global to check physical address limits.
;  051  VAM  16-May-86	Changes to GETTYP routine (to match one in INIDEF).
;  052  VAM  19-May-86	Add special J11 null job.
;  053	DBM  26-Aug-86	XH DDB return.  XE/XH physical address jam
;                                       
;			[RSTS/E V9.4]
;  054  KPH  11-Jan-87	Add MDE support
;  055	GPK  07-Oct-86	GPK clock jamming in JMISC, fix crash writer setup
;  056	GPK  22-Jan-87	Add GPK terminal jamming
;  057	DBM  26-Feb-87	User level Ethernet
;  058	PJH  08-May-87	Fix packet compare in DSABLD
;
;			[RSTS/E V9.5]
;  061  VAM  03-Sep-87	Make sure SY:[1,2] is USER and INTERACTIVE.
;
;			[RSTS/E V9.6]
;  059  KPH  13-Oct-87	Add .INCLUDEs
;			Add support for dynamic KB creation
;			Add support for dynamic PK creation
;			Remove lowcore setup from jam list processing
;			Add conditional phases for terminal driver
;			Modularize device vector setup code
;  060  KPH  02-Nov-87	Add LAT support
;  062  WRM  01-Dec-87	Source clear V9.5 into V9.6
;  063  PJH  08-Dec-87  Fix 061 in CHK12 to not trash R5
;  064	PJH  28-Dec-87	Disable KB side of PK devices on startup
;  065	DSD  02-Feb-88	Add conditional NODVR phase
;  			Add KB DDB extension if NODVR phase is present
;  066	PJH  02-Mar-88	Add check in RETSMB for overflow.
;			Add return the LAT root data structures if LAT not
;			in use.  Jam the next KB#*2 for dynamic KB setup.
;  067	PJH  21-Mar-88  Fix DM11-BB jamming bug with unit 0
;  068	PJH  06-May-88	Change FMS DDB offset value
;  069	KCG  01-Jun-88	Change error message when small buffer pool is exhausted
;
;			[RSTS/E V9.7]
;  070  WRM  02-Nov-88	Fix memory table for VDSK addition
;  071	KCG  16-Nov-88	Change OVRERR for second overlay addition.
;  072  DRP  29-Dec-88	Add support for KBX phase.
;  073  VAM  25-Jan-89	Fix register usage in DHSTRT.
;			Remove INIT support for virtual disk.
;			Use new unmapped CFGBUF.
;  074  VAM  22-Feb-89	Fix small buffer check in GETBUF.
;  075  VAM  21-Mar-89	Don't count virtual disk as disabled device.
;  076	DRP  12-Apr-89	Allow system to come up with as many KBs as possible
;			rather than give a fatal error.
;  077	VAM  24-Apr-89	Add revision level check to CHK12.
;  078	DRP  10-May-89	Put lease line support back in.
;			Added 2 second delay after master clear of DHU/DHV.
;
;			[RSTS/E V10.0]
;  079	DSD  31-May-89	Add support for deallocating NO DDB
;  080	DRP  13-Jul-89	Fix sign extend bug in JMENET routine.
;  081	FEK  21-Jul-89	Add FIS bit to X.CON word
;  082  VAM  03-Dec-89	Jam new cell CNT.LT for Outbound LAT
;  083  VAM  21-May-90	Allow disabling of special J11 null job
;  084  VAM  01-Jun-90	Put stall into DHSTRT for DH11 clones.
;
;			[RSTS/E V10.1]
;  085	FEK  13-Jun-91	Do the JAM of the MSCP region UMR pointer
;  086	FEK  08-Jun-92	Jam monitors name so it can protect itself
;-


.SBTTL	Local Definitions

MINXBF	=:	3			;Minimum amount of XBUF allowed	;048
					; in K words.			;048



.SBTTL	MACROS FOR START

.MACRO	I.MESS
	TMPORG	STATXT
.NLIST	BEX
.ENDM	I.MESS

.MACRO	PHZDEF	PHASE,APRJAM
	.WORD	D.LB+LB'PHASE'L,D.LB+LB'PHASE'P
.IF	NB	APRJAM
	.WORD	APRJAM
.GLOBL	APRJAM
.IFF	;NB	APRJAM
	.WORD	'PHASE'AP5
.GLOBL	'PHASE'AP5
.ENDC	;NB	APRJAM
.GLOBL	D.LB
.ENDM	PHZDEF

.MACRO	KBTYPE	DEV,STRTKB=0,VECTOR,UNTPTR,INTF,PARM,CTRL
.IF	IDN	DEV,<END>
	.WORD	0
.IFF	;IDN	DEV,<END>
.IF	DIF	DEV,<PK>
	.WORD	'DEV'.PKT
.GLOBL	'DEV'.PKT
	.WORD	STRTKB
	.WORD	VECTOR
.GLOBL	VECTOR
	.WORD	UNTPTR
.IFF	;DIF	DEV,<PK>
PKPKT:
.ENDC	;DIF	DEV,<PK>
	.WORD	INTF
	.WORD	PARM
	.WORD	CTRL
.ENDC	;IDN	DEV,<END>
.ENDM	KBTYPE

.MACRO	KBSTRT	DEV,UNTPTR,START
.IF	IDN	DEV,<END>
	.WORD	0
.IFF	;IDN	DEV,<END>
	.WORD	'DEV'.PKT
.GLOBL	'DEV'.PKT
	.WORD	UNTPTR
	.WORD	START
.ENDC	;IDN	DEV,<END>
.ENDM	KBSTRT

.SBTTL	ORDER THE CSECTS

	DEFORG	STA
	DEFORG	STATXT
	DEFORG	STACTL
	ORG	STA



                
.SBTTL	START Main Driver

START::	NOP			; Optionally patched to BPT, allow entry 2 ODT
	CLR	BLNRST		; Indicate that DATABF is no good
	CLR	R0		; Load device table with no offset
	CALLX	DSTBLI		; Read in the device table
	CALL	GETSFU		; Get FIP unit number of the system disk
	CALL	CHK12		; Make sure SY:[1,2] is valid.		;061
	CALL	LOWINI		; Initialize the low core map in the list
	CALL	JPARITY		; Jam the parity register setup
	CALL	SMLBUF		; Now return things to small buffer pool
	CALL	JMISC		; Jam miscellaneous stuff (clocks, etc)
	CALL	OVRERR		; Jam OVR and ERR pointers, dump name
	CALL	JLODB		; Jam the FBB for the load block.
	CALL	J11NUL		; Jam the J11 null job.			;052
	CALL	JCIS		; Jam CIS block move routine
	CALL	JSWAPS		; Set up the swapping file parameters
	CALL	JDECT		; Set up DECtape buffering
	CALL	JAMDSK		; Jam disk sizes and DCS values
	CALL	JTMSCP		; Jam [T]MSCP tables			;033
	CALL	RJSTRT		; Do RJ2780 offsetting of II driver
	CALL	JAMDVC		; Jam vector & CSR for all devices
	CALL	JAMKB		; Set up keyboard DDBs			;059
	CALL	JAMDDB		; Jam XM & XD DDB's if DMR's or DMV's config'd
	CALL	JTAPE		; Jam MM: formatters into MM: DDBs
	CALL	JMSTYP		; Jam MS: drive types into MS: DDBs	;020
	CALL	JMENET		; Jam ethernet control regions		;041
	CALL	JCACHE		; Compute cache tag area sizes
	CALL	JXBUF		; Jam XBUF data, UNIBUS map, BAE list, etc.
	CALL	JCRASH		; Set up crash dumps
	CALL	JPHASE		; Jam conditional phases		;036
	CALL	JAMJCR		; Set up job control region		;054
	TST	CNT.XE		; Are there any UNA devices out there?	;040
	BNE	10$		; Yes, we're all set.			;040
	CALL	JUMRXE		; No, so gotta block UMR$XE		;057
10$:	CALL	SETCFW		; Set up the configuration word
	CALL	FIXSML		; Fix up the small pool
	CALL	SETMEM		; Jam the start-up memory control list
	CALL	JAMSML		; Now output the small buffer pool stuff
	CMPB	@RINGS,#'C-100	; Is there a ctrl-C in the input buffer?
	BNE	20$		; No, go ahead and start
	EXIT			; Yes -- quit instead of starting

20$:	CALL	TTSTRT		; Start all the interfaces
	CALL	DMCINI		; Start up the DMC's
	RETURN			; Onward (via the root) with the START

GLOBAL	<RINGS,CNT.XE>							;040




.SBTTL	ENSURE THAT A FILE IS UNKILLABLE

.ENABL	LSB

NOKILL:	REGSAV			;SAVE REGISTERS
	MOV	(R5)+,R1	;R1 -> FCB FOR FILE
	CLR	R0		;NO OTHER PRIVS
10$:	BITB	#US.NOK,DDSTS(R1) ;IS IT ALREADY UNKILLABLE?
	BNE	30$		;YUP, THIS IS EASY
20$:	CALLX	RNB		;GET THE NAME ENTRY INTO MEMORY
	BISB	R0,USTAT(R5)	;TAKE THE WRITE PRIV'S IF ASKED
	BISB	#US.NOK,USTAT(R5) ;TURN ON THE UNKILLABLE BIT
	CALLX	WRITE		;REWRITE THE DIRECTORY
30$:	CALLX	REGRES,R5	;RESTORE REGS
	TST	(R5)+		;POP OVER FCB POINTER
	RETURN	R5		;BACK

NOKILW:	REGSAV			;SAVE REGISTERS
	MOV	(R5)+,R1	;R1 -> FCB FOR FILE
	MOV	#US.WRT,R0	;SET UP FOR THE WRITE PRIVS
	BITB	R0,DDSTS(R1)	;ARE THEY ALREADY GONE?
	BEQ	20$		;NO, WE MUST TAKE THEM NOW
	BR	10$		;YES, SEE IF KILL PRIVS ARE GONE

.DSABL	LSB


.SBTTL	GET A WORD FROM THE RSTS MODULE OF THE SIL

;+
; RSRSO3 - READ RSTS MODULE GIVEN TABLE OFFSET
;
;	R3 = TABLE OFFSET
;
;	CALL	RDRSO3,R4,<POINTER TO TABLE BASE>
;
;	R0 -> WORD IN BUFFER
;-

RDRSO3:	MOV	R3,R0		;READ OFFSET BY R3
	ADD	@(R4)+,R0	; OFFSET POINTED TO IN LINE
	CALL	RDRSTS		;DO THE READ
	RETURN	R4

;+
; RDRSTS - READ RSTS MODULE AND RETURN A WORD
;
; 	R0 = ADDRESS WITHIN RSTS
;
;	CALL	RDRSTS
;
; 	R0 -> WORD IN BUFFER
;	TO REWRITE THE BUFFER, MAKE RWRITE NON-0
;-

RDRSTS:	REGSCR			;SAVE REGISTERS
	MOV	R0,R2		;COPY ADDRESS
	BIC	#777,R2		;REMOVE BLOCK OFFSET FROM ADDRESS
	BIC	R2,R0		;LEAVE ONLY THE BLOCK OFFSET IN R0
	ADD	#DATABF,R0	;R0 -> LOCATION OF DESIRED WORD IN BUFF
	MOV	R0,TOS.R0(SP)	;RETURN POINTER IN R0
	SWAB	R2		;CONVERT R2 TO RELATIVE BLOCK NUMBER
	ROR	R2		;  WITHIN RSTS MODULE
	ADD	RSTBLK,R2	;R2 = ABSOLUTE BLOCK WITHIN SIL
	CMP	R2,BLNRST	;IS IT ALREADY THERE?
	BEQ	10$		;YUP, THAT'S EASY
	MOV	#FQSIL+FQFCB,R1	;R1 -> FCB FOR READ
	MOV	R2,FCNVB(R1)	;SPECIFY BLOCK TO READ
	CALLX	READ.B,R5,DATABF;READ IT IN
	MOV	R2,BLNRST	;REMEMBER WHAT'S THERE
10$:	RETURN

	TMPORG	STACTL
BLNRST:	.WORD	0.
DATABF:	.BLKW	256.
	UNORG

GLOBAL	<RSTBLK,FQSIL>


.SBTTL	GET TYPE OF MEMORY BLOCK

;+
; GETTYP - GET THE TYPE OF A K OF MEMORY
;
;	R1 = K NUMBER OF INTEREST
;
;	CALL	GETTYP
;
;	R3 = TYPE OF THAT K
;-
.ENABL	LSB

GETTYP:	MOV	#-1,R3		;-1 IS FLAG FOR END OF TABLE
	CMP	R1,TOPPHY	;Is the K too big?			;051
	BHIS	50$		;Yes, return end of table.		;051
	CLR	R3		;NO, PRESET R3 TO 0 (USER)
.ASSUME	U.USER	EQ	0						;051
	REGSCR			;PRESERVE ALL REGISTERS
	MOV	#D.EXEC-4,R5	;R5 -> Table of memory.			;051
	MOV	#4,R4		;R4 = # ENTITIES (EXEC,ODT,XBUF,VDSK)
10$:	ADD	#4,R5		;Bump to next item.			;051
	CMP	R1,(R5)		;IS IT BELOW THE START OF THIS ITEM?
	BLO	20$		;YES, NOT HERE
	MOV	(R5),R2		;NO, COMPUTE END OF ITEM
	ADD	2(R5),R2	; = START + SIZE
	CMP	R1,R2		;BELOW THE END?
	BLO	30$		;YES, THIS IS IT
20$:	SOB	R4,10$		;AND LOOP
	MOV	#U.NXM,R5	;Set the code to NXM.			;051
	MOV	R1,R0		;COPY THE K NUMBER
	CALLX	FIXREG		;CONVERT TO BIT AND BYTE
	BITB	BITBYT(R2),D.NXM(R4) ;Is it NXM?			;051
	BNE	40$		;Yes, return NXM code.			;051
	BITB	BITBYT(R2),D.LOCK(R4) ;Is it locked?			;051
	BEQ	50$		;No, it's user.  Return the 0 preset.	;051
	MOV	#U.LOCK,R5	;Otherwise, put LOCK code into R5	;051
	BR	40$		; and return it.			;051

30$:	SUB	#D.EXEC-4,R5	;Compute memory code in R5.		;051
40$:	MOV	R5,TOS.R3(SP)	;Save to return in R3.			;051
50$:	RETURN								;051

GLOBAL	<D.EXEC,D.LOCK,D.NXM,BITBYT,TOPPHY>				;051

.DSABL	LSB

;
; Define Memory Usage Codes						;048
;
; Note that a table like this exists in INIDEF also.			;048
; If anything is added to or changed in this one, please		;048
; make the corresponding change in INIDEF.				;048
;
; U.LOCK and U.NXM, in that order, must be the last two codes.		;051
;

.DSECT
U.USER:	.BLKB	4		;USER					;048
U.EXEC:	.BLKB	4		;EXEC					;048
U.ODT:	.BLKB	4		;ODT					;048
U.CACH:	.BLKB	4		;XBUF MEMORY				;048
U.VDSK:	.BLKB	4		;VIRTUAL DISK				;048
U.LOCK:	.BLKB	4		;LOCKED MEMORY				;048
U.NXM:	.BLKB	4		;NONEXISTENT MEMORY			;048
	UNORG



.SBTTL	COMPUTE SYSTEM DISK FIP UNIT NUMBER

.ENABL	LSB

GETSFU:	CLR	R3		;START WITH OFFSET 0 INTO DEVNAM
10$:	CALL	RDRSO3,R4,DEVNAM ;GET WORD AT DEVNAM+R3 IN RSTS
	CMP	SYSNAM,(R0)	;IS THIS THE SYSTEM DISK?
	BEQ	30$		;YES, GET THE UNIT NUMBER
	ADD	#2,R3		;NO, BUMP R3 TO NEXT DEVNAM OFFSET
	CMP	R3,DEVOKB	;ARE WE UP TO THE KB'S YET?
	BLO	10$		;NO, TRY AGAIN
20$:	ERF	<"Installed monitor does not support this system disk">

30$:	CALL	RDRSO3,R4,DEVCNT ;HOW MANY UNITS DOES IT SUPPORT?
	CMP	SYSUSV,(R0)	;CHECK AGAINST ACTUAL UNIT NUMBER
	BGT	20$		;NOT ENOUGH
	CALL	RDRSO3,R4,DEVPTR ;GET THE DEVPTR ENTRY FOR THIS DISK
	MOV	(R0),R0		; IN R0
	SUB	.UNTCNT,R0	;R0 = SYS DISK FUN *2
	ASR	R0		;MAKE IT *1
	ADD	SYSUSV,R0	;NOW MAKE IT SYS DISK FUN FOR SYS DISK UNIT
	MOV	R0,SYSFUN	;SAVE IT
	ASL	R0		;NOW GET SYSTEM DISK FUN * 2
	ADD	.UNTCNT,R0	;GET ADDRESS OF UNTCNT WORD
	CALL	RDRSTS		;GET THE VALUE
	CMP	(R0),#UC.MNT	;IS THE DISK ENABLED?
	BNE	40$		;NO, THAT WON'T FLY
	RETURN

40$:	MESSAG	<"System disk disabled in monitor"<200>>
	EXIT

.DSABL	LSB

	TMPORG	STACTL
SYSFUN:	.WORD	0		;SYSTEM DISK FIP UNIT NUMBER
	UNORG

GLOBAL	<DEVNAM,SYSNAM,DEVOKB,DEVCNT,SYSUSV,DEVPTR,.UNTCNT>

.ENABL	LSB								;061+

.SBTTL	CHK12 - Make sure SY:[1,2] is an INTERACTIVE USER account

;+
; CHK12 - Make sure SY:[1,2] is an INTERACTIVE USER account
;
; No setup is necessary.
;
;
;	CALL	CHK12
;
; Account [1,2] on the system disk is checked to ensure that it
; is not set NOUSER or NOINTERACTIVE.
;
; We will return only if SY:[1,2] is a legal account.
; Otherwise, we do an EXIT (back to 'Option:' prompt).
;
;	Note: R5 is preserved for Jam list usage			;063
;-

CHK12:	CMPB	DSKREV+1,#1	; Is the disk rev level 1.1 or later?	;077
	BHIS	5$		; Yup, so go with the [1,2] check.	;077
	MESSAG			; Otherwise, print a warning message.	;077
	 .ASCII	"WARNING - System disk will be software write-protected"<200>
	 .ASCIZ	"DCL commands may give unexpected errors"<200>		;077
	UNORG								;077
	BR	7$		; And, just go back.			;077

5$:	MOV	R5,-(SP)	; Preserve R5				;077
	MOV	#30$,20$	; Save the proper error text.
	MOV	#ONETWO,R0	; Point to [1,2].
	CALLX	SDM		; Get the MFD entry for [1,2].
	BCS	10$		; Oops, not there - bogus system disk!!
	MOV	R3,R4		; Save link to name entry (hopefully no one
				;  will blow away R4!)
	MOV	#40$,20$	; Point to next error message.
	MOV	#AA.PAS,R0	; Say we want Password attribute blockette.
	CALLX	SAA		; And, go get it.
	BCS	10$		; Oops, not there - it's a NOUSER account!
	MOV	#50$,20$	; Now, use this one...
	MOV	#AA.DAT,R0	; Say we want Date and Time attributes.
	MOV	R4,R3		; Get link to name entry back.
	CALLX	SAA		; And, go get it.
	BCS	10$		; Oops, not there - bogus account!
	MOV	#60$,20$	; Lastly, use this message.
	BIT	#AT.NLG,AT.PTI(R5)
				; Is this a NOINTERACTIVE account?
	BNE	10$		; Yes, so punt.
	MOV	(SP)+,R5	; Restore R5				;063
7$:	RETURN			; Otherwise, go back happy.		;077

10$:	MESSAGE	<<200>"Account [1,2] is ">
	CALLX	MESSAG,R5	; Explain it to them.
20$:	.WORD	0		; This is loaded with addr of correct message.
	MESSAGE	<" - Timesharing cannot be started"<200>>
				; Finish up the message.
	;MOV	(SP)+,R5	; No need to restore R5 - EXIT resets	;063
				;  the stack.				;063
	EXIT			; And take the nasty way out!!

	I.MESS			; Define the messages we use.
30$:	.ASCIZ	"missing"
40$:	.ASCIZ	"a NOUSER account"
50$:	.ASCIZ	"corrupted"
60$:	.ASCIZ	"set NOINTERACTIVE"
	UNORG

	GLOBAL	<ONETWO,DSKREV>						;077

.DSABL	LSB								;061-


.SBTTL	SET UP THE SWAP MAP FOR SWAP.SYS

JSWAPS:	CALLX	JAMBYN		;JAM CONTROL BLOCKS
	MOV	SWPSIZ,R1	;R1 = SIZE OF SWAP FILE IN BLOCKS
	CLR	R0		;CLEAR FOR DIVIDE, C=0
	ROR	R1		;DIVIDE BY 4 FOR K
	ASR	R1
	DIV	D.SWPM,R0	;Compute number of jobs SWAP.SYS holds.	;048
	CMP	R0,D.JOBM	;Can't use more than (JOB MAX) slots	;048
	BLOS	10$		;AND THERE AREN'T THAT MANY
	MOV	D.JOBM,R0	;Use only one per job.			;048
10$:	MOV	#2,(R5)+	;2 WORDS
	MOV	.$JOBM,(R5)+	;& $$JOBM <- # JOBS THAT FIT IN SWAP.SYS
	MOV	R0,(R5)+	;FIRST, THE NUMBER OF JOBS WE CAN HOLD NOW
	MOV	D.JOBM,(R5)+	;& $$JOBM+2 <- JOB MAX this session.	;048
	MOV	#4,(R5)+	;4 WORDS OF SWAP BIT MAP
	MOV	.$SWMP,(R5)	;& $$SWMP+20 <- 4 WORDS OF SWAP.SYS BIT MAP
	ADD	#2*10,(R5)+	; + 20 FOR SWAP AREA 2
	MOV	R5,R4		;REMEMBER MAP POINTER
	CLR	(R5)+		;INITIALLY, CLEAR THE MAP
	CLR	(R5)+
	CLR	(R5)+
	CLR	(R5)+
	MOV	#2,R1		;START WITH BIT 1 (BIT 0 STAYS 0)
20$:	BISB	R1,(R4)		;SET BIT IN MAP
	ASLB	R1		;SHIFT TO NEXT BIT
	BCC	30$		;IN SAME BYTE
	INC	R1		;ELSE RESET MASK
	INC	R4		; AND GO TO THE NEXT BYTE
30$:	SOB	R0,20$		;SET 1 BIT FOR EACH SWAP SLOT
	MOV	#2,(R5)+	;NOW SET UP THE SWAP FILE FBB
	MOV	.$SWPB,(R5)	;& $$SWPB+20 <- SWAP.SYS FBB @ 0
	ADD	#4*FBBSIZ,(R5)+	;  OFFSET INTO SWAP AREA 2
	MOVB	SYSFUN,(R5)+	;SET SYSTEM DISK FUN
	MOV	SWPDCN,R2	;GET STARTING DCN OF SWAP.SYS
	CALLX	CNVRIB		;CONVERT IT TO A FIP BLOCK NUMBER
	MOVB	R3,(R5)+	;AND SET UP THE FBB
	MOV	R2,(R5)+
	RETURN			;DONE

GLOBAL	<D.SWPM,D.JOBM,.$JOBM,.$SWMP,.$SWPB,SWPDCN,SWPSIZ>		;048


.SBTTL	BUILD PARITY REGISTER JAM LIST

JPARITY:CLR	R2		;ASSUME NO PARITY CSR'S
	TST	ECC70		;ANY 11/70 ECC?
	BEQ	10$		;NO -- HOW ABOUT UNIBUS ECC OR PARITY?
	MOV	#20,R2		;YES -- JAM "CORRECTABLE ERROR" BIT
10$:	TST	PARUNI		;ANY UNIBUS PARITY OR ECC?
	BEQ	20$		;NO -- SKIP
	MOV	#100020,R2	;YES -- JAM "ANY ERROR" BITS
20$:	TST	R2		;ARE THERE ANY CSR'S?
	BEQ	30$		;NO PARITY OR ECC CSR'S AT ALL
	CALLX	JAMNWD,R4,<16.,.$PCSR,PARLOC> ;& $$PCSR <- 16 WORDS OF CSR'S
	CALLX	JAMNWD,R4,<16.,.$PRNG,PARRNG> ;& $$PRNG <- 16 WORDS OF RANGE
	CALLX	JAMBY2		;SINGLE JAMS AHEAD
	MOV	R2,(R5)+	;SET MASK TO CHECK FOR ERRORS
	MOV	.$PMSK,(R5)+	;& $$PMSK <- MASK FOR NONFATAL ERRORS
	BR	40$		;DON'T DISABLE THAT SCAN
30$:	CALLX	JAMBY2		;SINGLE JAM AHEAD:
	MOV	.$RTSP,(R5)+	;ONLY IF NO UNIBUS OR 11/70 ECC OR PARITY
	MOV	.$PSCN,(R5)+	;& $$PSCN <- $$RTSP
40$:	MOV	.$PTBL,R1	;GET ADDRESS OF PARITY CONTROL TABLE IN RSTS
	TSTB	CACHE		;IS THERE A CACHE?
	BMI	50$		;NO, NO CHANGE TO +0, +2
	MOV	#17,(R5)+	;YES, SET UP FIRST WORD
	CMP	CPTYP,#5	;IS THIS A J11 SYSTEM?			;021
	BNE	45$		;NO, SO LEAVE THE 17			;021
	MOV	#15,-2(R5)	;REPLACE IT WITH A 15			;021
45$:	MOV	R1,(R5)+	;& $$PTBL+0 <- 17 IF CACHE EXISTS	;021
	TST	(R1)+		;BUMP TABLE ADDRESS
	MOV	#CHECTL,(R5)+	;ADDRESS OF CACHE CONTROL
	MOV	R1,(R5)+	;& $$PTBL+2 <- CHECTL IF CACHE EXISTS
	TST	(R1)+		;BUMP ADDRESS
	TSTB	CACHEA		;ADDRESS INFORMATION IN THE CACHE?
	BMI	60$		;NO, NO ADDRESS STUFF
	MOV	#CHEERL,(R5)+	;YES, POINT TO ERROR ADDRESS (LSB)
	MOV	R1,(R5)+	;& $$PTBL+4 <- CHEERL IF CACHE ADDRESS INFO
	TST	(R1)+		;BUMP ADDRESS
	MOV	#CHEERM,(R5)+	;POINT TO ERROR ADDRESS (MSB)
	MOV	R1,(R5)+	;& $$PTBL+6 <- CHEERM IF CACHE ADDRESS INFO
	TST	(R1)+		;BUMP ADDRESS
	BR	70$		;ALWAYS CLOBBER SCANNING IF ADDRESS INFO
50$:	CMP	(R1)+,(R1)+	;SKIP +0, +2
60$:	CMP	(R1)+,(R1)+	;SKIP +4, +6
	TST	PARUNI		;ANY UNIBUS PARITY REGISTERS?
	BNE	80$		;YES, DON'T CLOBBER UNIBUS SCANNER
70$:	MOV	.$RTSP,(R5)+	;SET CALL TO RETURN
	MOV	R1,(R5)+	;& $$PTBL+10 <- $$RTSP IF CACHE ADDR OR NO UNIBUS
80$:	TST	(R1)+		;BUMP ADDRESS
	TSTB	CACHE		;ANY CACHE?
	BMI	90$		;NO
	MOV	#CHEERR,(R5)+	;YES, SET ERROR REGISTER ADDRESS
	MOV	R1,(R5)+	;& $$PTBL+12 <- CHEERR IF CACHE
90$:	TST	(R1)+		;BUMP ADDRESS
	MOV	CACHES,(R5)	;LOAD UP CACHE SWEEP BYTE COUNT
	BEQ	100$		;NONE
	TST	(R5)+		;MOVE TABLE POINTER
	MOV	R1,(R5)+	;& $$PTBL+14 <- BYTES TO SWEEP CACHE
100$:	RETURN

GLOBAL	<.$PMSK,.$PCSR,.$PRNG,.$PSCN,.$PTBL,CACHE,CACHEA.$RTSP,CACHES,ECC70>
GLOBAL	<PARUNI,PARLOC,PARRNG,CPTYP>					;021


.SBTTL	BUILD JAM LIST FOR DATES, TIMING, MISCELLANEOUS

.ENABL	LSB

JMISC:	CALLX	JAMBY2		;THESE ARE WORD PAIRS
	MOV	I.DATE,R3	;GET THE CURRENT DATE
	MOV	R3,(R5)+	;SYSTEM DATE
	MOV	.$DATE,(R5)+	;& $$DATE <- CURRENT DATE
	MOV	I.TIME,(R5)+	;SYSTEM TIME
	MOV	.$TIME,(R5)+	;& $$TIME <- SYSTEM TIME
	CLR	R2
	DIV	#1000.,R2	;R2 = YEAR, R3 = DAYS
	MOV	R2,R3		;COPY YEAR
	MUL	#1000.,R3	;COMPUTE YEAR * 1000.
	ADD	#1001.,R3	; + 1001 = FIRST DAY OF NEXT YEAR
	MOV	R3,(R5)+	;SET FOR MONITOR
	MOV	.$NDAY,(R5)+	;& $$NDAY <- FIRST DAY OF NEXT YEAR
	ADD	#366.-1001.,R3	;R3 = FIRST NON-EXISTENT DAY OF THIS YEAR
	ADD	#2,R2		;BUT IF YEAR+2
	BIT	R2,#3		; IS DIVISIBLE BY 4
	BNE	10$		;  THEN
	INC	R3		;   LEAP YEAR IS LONGER
10$:	MOV	R3,(R5)+	;SET UP LAST DAY OF THE YEAR
	MOV	.$LDAY,(R5)+	;& $$LDAY <- LAST DAY OF THIS YEAR + 1
	MOV	D.DATF,(R5)+	;SET UP DATE FORMAT			;081
	MOV	.$CNVF,(R5)+	;& $$CNVF <- DATE FORMAT (-1 ALPHA, +1 ISO)
	MOV	D.TIMF,(R5)+	;SET UP TIME FORMAT			;081
	MOV	.$CNVF,(R5)	;POINT TO AREA
	ADD	#2,(R5)+	;& $$CNVF+1 <- TIME FORMAT (-1 AM/PM, +1 24HR)

GLOBAL	<I.DATE,.$DATE,I.TIME,.$TIME,.$NDAY,.$LDAY,.$CNVF,LINFRQ>
GLOBAL	<D.DATF,D.TIMF>							;081


; COMPUTE CLOCK FREQUENCY INFORMATION

	MOV	LINFRQ,R0	;GET LINE FREQUENCY
	MOV	R0,R1		;COPY IT
	TSTB	FLGGPK		;Is this a GPK?				;055
	BPL	17$		;No, do the "usual" thing		;055
	MOV	(PC)+,(R5)+	;DISABLE CLOCK CHECKING WITH 'NOP'	;055
	 NOP								;055
	MOV	.$CNOP,(R5)+	;& $$CNOP <- 'NOP'			;055
	MOV	#200$,R2	;Setup list for GPK clock		;055
	MOV	#CLKCS2,(R5)+	;Enable test of CLKCS2 to keep ticking	;055
	MOV	.$CLK2,(R5)+	; $$CLK2 <- CLKCS2			;055
	BR	50$		;Go jam the hardware setup data		;055

17$:	TST	D.CPRF		;CHECK PREFERRED CLOCK FLAG		;055
	BMI	30$		;P CLOCK PREFERRED
	TSTB	KW11L		;L CLOCK PREFERRED. IS THERE ONE?
	BPL	40$		;YES, GO USE IT
	MESSAG	<"Using KW11P clock at line frequency"<200>>
20$:	MOV	#160$,R2	;POINT TO KW11P @ LINE PARAMETERS
	TST	D.CRAT		;DO WE WANT KW11-P AT LINE?
	BLE	50$		;IF ZERO, USE LINE FREQUENCY
	MOV	D.CRAT,R0	;GET CRYSTAL FREQ
	MOV	#50.,R1		;SET TICK = 50
	MOV	#10000.,R3	;COMPUTE 10000./FREQ
	CLR	R2
	DIV	R0,R2
	MOV	R2,180$		;QUOTIENT IS REPEAT CNT FOR CRYSTAL
	MOV	#170$,R2	;R2 -> LIST FOR KW11P CRYSTAL
	BR	50$

30$:	TSTB	KW11P		;P CLOCK PREFERRED. IS THERE ONE?
	BPL	20$		;YES
	MESSAG	<"Using KW11L clock"<200>>
40$:	MOV	#190$,R2	;POINT TO KW11L PARAMETERS
	TST	JCLKCS		;Can this CLock be changed?		;081
	BNE	48$		; NO, so skip the funky stuff		;081
	CMP	LINFRQ,#800.	; But do they want the 800 Hz clock?	;081
        BNE     48$		; No, so life stays easy.		;081
	MOV	#50.,R1		;SET TICK = 50				;081
48$:	TSTB	KW11L		;WHAT KIND OF KW11L CLOCK IS THIS?
	BEQ	50$		;NORMAL KIND
	MOV	(PC)+,(R5)+	;Q-BUS KIND, DISABLE CLOCK CHECKING WITH 'NOP'
	 NOP
	MOV	.$CNOP,(R5)+	;& $$CNOP <- 'NOP' FOR Q-BUS CLOCKS
	CMP	LKSCSR,#LKS	;DOES Q BUS L CLOCK HAVE A CSR?
	BEQ	50$		;YEP
	TST	(R2)+		;NOPE, SKIP SETTING THE CLOCK'S CSR
	BR	60$		; IN THE MONITOR

GLOBAL	<LINFRQ,D.CPRF,KW11L,LKSCSR,D.CRAT,KW11P,.$CNOP,.$CLK2,FLGGPK>	;055
GLOBAL	<JCLKCS>							;081


; R0 = FREQ	R1 = TICK

50$:	MOV	(R2)+,(R5)+	;ADDRESS OF CSR
	MOV	.$CCSR,(R5)+	;& $$CCSR <- CSR FOR CLOCK
60$:	MOV	(R2)+,(R5)+	;HOW TO START IT
	MOV	.$CSRT,(R5)+	;& $$CSRT <- COMMAND WORD TO START CLOCK
	MOV	(R2)+,(R5)+	;INTERRUPT RATE
	MOV	.$CPRM,(R5)+	;& $$CPRM <- CLOCK PARAMETER WORD
65$:	MOV	R0,R3		;COMPUTE NULL JOB WAIT			;055
	ADD	#30./2,R3	; AS
	CLR	R2
	DIV	#30.,R2		;  <FREQ + <30./2>> / 30.
	MOV	R2,(R5)+	;INTO $$NULW
	MOV	.$NULW,(R5)+	;& $$NULW <- <FREQ + <30./2>> / 30.
	MOV	R0,R3		;COMPUTE HERZ DIVIDE FACTOR
	CLR	R2
	DIV	#10.,R2		; AS <FREQ/10.>
	MOV	R2,(R5)+
	MOV	.$HZDV,(R5)+	;& $$HZDV <- FREQ/10.
	MOV	R0,R3		;COMPUTE CLOCK QUANTUM
	CLR	R2
	ROR	R3
	ADD	#10000.,R3	; AS
	DIV	R0,R2		;  <10000. + <FREQ/2>> / FREQ
	MOV	R2,(R5)+
	MOV	.$CQNT,(R5)+	;& $$CQNT <- <10000. + <FREQ/2>> / FREQ
	MOV	R0,R3		;COMPUTE CLOCK COUNTER
	CLR	R2
	DIV	R1,R2		; AS FREQ/TICK
	MOV	R2,(R5)+
	MOV	.$CCNT,(R5)+	;& $$CCNT <- FREQ/TICK
	MOV	R1,(R5)+	;SET UP TICK
	MOV	.$TICK,(R5)+	;& $TICK <- TICK RATE (50 OR 60)

GLOBAL	<.$CCSR,.$CSRT,.$CPRM,.$NULW,.$HZDV,.$CQNT,.$CCNT,.$TICK>


; DO OTHER MISCELLANEOUS THINGS

	TST	SWTREG		;IS THE SWITCH REGISTER VOLATILE?
	BPL	70$		;NO
	MOV	#NOP,(R5)+	;YES, SET THE CODE UP
	MOV	.$VSWR,(R5)+	;& $$VSWR <- #NOP IF VOLATILE SWITCH REGISTER
70$:	MOV	SYSFUN,(R5)	;GET SYSTEM DISK FIP UNIT NUMBER
	ASL	(R5)		; *2
	ADD	.UNTCNT,(R5)+	;GET POINTER TO UNTCNT
	MOV	.$SYSP,(R5)+	;& $$SYSP <- POINTER INTO UNTCNT FOR SYS DISK
	MOVB	SYSFUN,(R5)	;SET UP THE SYSTEM DISK SYSPHU WORD
	MOVB	(R5)+,(R5)	;SYSTEM DISK FUN IN LOW BYTE,
	ASLB	(R5)+		; SYSTEM DISK FUN *2 IN HIGH BYTE
	MOV	.$SYSU,(R5)	;& $$SYSU <- SYSFUN*2(HI)/SYSFUN(LO)	;086
	MOV	(R5)+,R0	; Remember this address for later	;086
	MOV	SILNAM,(R5)+	;Part 1 of monitor name			;086
	MOV	R0,(R5)		; at					;086
	ADD	#2,(R5)+	;   this address			;086
	MOV	SILNAM+2,(R5)+	;Part 2 of monitor name			;086
	MOV	R0,(R5)		; at					;086
	ADD	#4,(R5)+	;   this address			;086
	;The above code assumes 3 contiguous words (see RES.MAC)	;086
	MOV	D.SWPM,(R5)+	;Set up system SWAP MAX.		;048
	MOV	.$SWPM,(R5)+	;& $$SWPM <- SWAP MAXIMUM
	TSTB	CP.SID		;IS THERE A SYSTEM ID REGISTER?
	BMI	80$		;NO
	MOV	#CPUSID,(R5)+	;YES, POINT TO IT
	MOV	.$ESID,(R5)+	;& $$ESID <- #CPUSID IF CPUSID EXISTS
80$:	TSTB	CP.ERR		;IS THERE A CPU ERROR REGISTER?
	BMI	90$		;NO
	MOV	#CPUERR,(R5)+	;YES, POINT TO IT
	MOV	.$ECPU,(R5)+	;& $$ECPU <- #CPUERR IF CPUERR EXISTS
	TSTB	CP.ERW		;MAY CPU ERROR REGISTER BE WRITTEN?
	BMI	90$		;NO -- A FLAKY 11/60
	MOV	#CPUERR,(R5)+	;AGAIN
	MOV	.$ECPU,(R5)	;POINT TO IT
	ADD	#2,(R5)+	;& $$ECPU+2 <- #CPUERR IF REG MAY BE WRITTEN
90$:	TST	MEDINS		;DOES 'MED' WORK HERE?
	BPL	100$		;YES
	MOV	.$RTSP,(R5)+	;NO, DON'T DO IT
	MOV	.$EMED,(R5)+	;& $$EMED <- $$RTSP IF NO 'MED'
100$:	TSTB	SWR$R		;IS THERE A SWITCH REGISTER?
	BMI	110$		;NO
	TST	SWTREG		;YES, BUT IS IT DISABLED?
	BGT	110$		;YUP, ACT LIKE NONE
	MOV	#SWR,(R5)+	;POINT $$SREG AT IT
	MOV	.$SREG,(R5)+	;& $$SREG <- #SWR IF SWITCH REGISTER
110$:	TSTB	SWR$W		;IS THERE A DISPLAY REGISTER?
	BMI	120$		;NO
	MOV	#SWR,(R5)+	;POINT $$DREG AT IT
	MOV	.$DREG,(R5)+	;& $$DREG <- #SWR IF DISPLAY REGISTER
120$:	TST	STAKLM		;IS THERE A STACK LIMIT REGISTER?
	BMI	130$		;NO
	MOV	#SL,(R5)+	;POINT $$SL AT IT
	MOV	.$SL,(R5)+	;& $$SL <- #SL IF STACK LIMIT

GLOBAL	<SWTREG,.$VSWR,.UNTCN,.$SYSP,.$SYSU,D.SWPM,.$SWPM>		;048
GLOBAL	<CP.SID,.$ESID,CP.ERR,CP.ERW,.$ECPU,MEDINS,.$RTSP>
GLOBAL	<.$EMED, SWR$R,.$SREG, SWR$W,.$DREG,STAKLM,.$SL  ,SILNAM>	;086


130$:	TSTB	AUTOQS		;RECOVERING FROM A CRASH?
	BPL	140$		;NO
	MOV	#P.CRAS,(R5)+	;YES, START UP AT P.CRASH
	MOV	.$PNEW,(R5)+	;& $$PNEW <- P.CRAS IF CRASH RECOVERY
140$:	CLR	(R5)+		;ASSUME NO ODT AND
	MOV	.$ODTP,(R5)+	;& $$ODTP <- 0 IF NO ODT
	MOV	D.ODT,R0	;Get location of ODT in memory.		;048
	BEQ	150$		;NO ODT
	CMP	-(R5),-(R5)	;DON'T ZERO IT!
	ASH	#11.-6,R0	;YES, COMPUTE MMU ADDRESS FROM K NUMBER
	MOV	R0,(R5)+	;SET ODT'S ADDRESS
	MOV	.$ODT6,(R5)+	;& $$ODT6 <- ODT ADDRESS/100 IF ODT
	MOV	#140020,(R5)+	;SET ODT ENTRY POINT
	MOV	.$ODTE,(R5)+	;& $$ODTE <- 140020 IF ODT
	MOV	#BPT,(R5)+	;SET UP A BPT AS ENTRY
	MOV	.$ODTB,(R5)+	;& $$ODTB <- BPT IF ODT
150$:	MOV	CCTVAL,(R5)+	;SET CACHE CONTROL RESET VALUE
	MOV	.$CCTL,(R5)+	;& $$CCTL <- CACHE CONTROL RESET VALUE
	MOV	@#D.LB+LBSCRP,(R5)+ ;SET ADDRESS OF OVRBUF (SCRATCH AREA)
	MOV	.$OVBF,(R5)+	;& $$OVBF <- ADDRESS OF OVRBUF
	MOV	D.LB+LBJCRP,(R5)+ ;Set address of job control region	;039
	MOV	.$JCR6,(R5)+	;Which will be stored in $$JCR6		;039
	MOV	D.JCRS,(R5)+	;Set up size of a JCR entry in words	;039
	MOV	JCRSIZ,(R5)+	;Which will be stored at JCRSIZ		;039
	RETURN

160$:	.WORD	PKS,115,1	;KW11P @ LINE FREQ

170$:	.WORD	PKS,113		;P CLOCK AT CRYSTAL FREQUENCY
180$:	.WORD	10000./500.

190$:	.WORD	LKS,100,0	;L CLOCK

200$:	.WORD	CLKCS1,PIE!CLKBIN!CLK24,0	; GPK clock		;055
.DSABL	LSB

GLOBAL	<AUTOQS,.$PNEW,.$ODTP,D.ODT,.$ODT6,.$ODTE,.$ODTB>		;048
GLOBAL	<CCTVAL,.$CCTL,.$OVBF,.$JCR6,JCRSIZ,D.LB,D.JCRS>		;039
GLOBAL	<DYNKBN>							;066


.SBTTL	SET UP BUFF.SYS	BASE						;030

.ENABL	LSB

JDECT:	TST	DTAFLG		;DECtape enabled?			;030
	BEQ	10$		;No					;030
	CALLX	LOK5..,R5	;FIND BUFF.SYS
	 .RAD50	/BUFF  SYS/
	BCS	20$		;Should never happen, but just in case	;030
	CALLX	JAMBYN		;Set up BUFF.SYS base			;030
	MOV	#2,(R5)+	;2 WORDS
	MOV	.$BUFB,(R5)+	;& $$BUFB <- BUFF.SYS FBB
	MOVB	SYSFUN,(R5)+	;SYSTEM DISK FUN
	MOV	FC...+FCWND+2,R2 ;GET DCN
	CALLX	CNVRIB		;CONVERT TO FBN
	MOVB	R3,(R5)+	;LIST
	MOV	R2,(R5)+
10$:	RETURN								;030

20$:	CLR	DTAFLG		;Disable DECtape			;030
	MESSAG	<"BUFF.SYS not found - DECtape disabled"<200>>		;030
	RETURN								;030

.DSABL	LSB

GLOBAL	<FC...,.$BUFB,DTAFLG>						;030


.SBTTL	SET UP OVR AND ERR LISTS

.ENABL	LSB

OVRERR:	CALLX	SILNDX,R5,FQSIL	;ENSURE THAT SIL INDEX IS IN MEMORY
	BNE	5$		;OOPS
	CALLX	SILSCN,R5	;FIND OVR IN THE MONITOR SIL
	 .RAD50	/OVR   /
	BCS	5$		;OOPS
	MOV	SE.BLK(R0),-(SP);Save virt addr of phase		;071
	CALL	JAMOV$,,.$OVRB	;Jam the primary overlay table		;071
	MOV	R4,-(SP)	;Save biased block count		;071
				;R2=Block count in phase		;071
	CALLX	SILSCN,R5	;Find OV2 in the monitor sil		;071
	 .RAD50	/OV2   /						;071
	BCS	6$		;Oops					;071
	ADD	2(SP),R2	;Calculate expected virt blk num of OV2	;071
	CMP	R2,SE.BLK(R0)	;Is OV2 in the correct spot?		;071
	BNE	7$		;No, our OVR.SYS file won't work	;071
	CALL	JAMOV$,,.$OV2B	;Jam the second overlay table		;071
	ADD	(SP)+,R4	;Add the total overlay blocks		;071
	TST	(SP)+		;skip past virt addr of OVR		;071
	CALLX	JAMBY2		;SET UP OVR COUNT AND BASE
	MOV	R4,(R5)+	;NUMBER OF BLOCKS IN OVR
	MOV	.$OVRC,(R5)+	;& $$OVRC <- NUMBER OF BLOCKS IN OVR + 2
	BR	15$		;goto error file processing		;071

5$:	ERF	<"OVR not in SIL">
6$:	ERF	<"OV2 not in SIL">
7$:	ERF	<"OV2 not adjacent to OVR">

JAMOV$:	MOV	#FCSIL,R1	;R1 -> FCB FOR SIL
	MOV	SE.BLK(R0),FCNVB(R1) ;STARTING BLOCK OF OVR
	MOV	SE.LOD(R0),R4	;R4 = LOAD ADDRESS OF OVR
	SWAB	R4		;COMPUTE BACKWARD BIAS FOR EXEC
	ROR	R4		;R4 = IMAGINARY BLOCKS
	SUB	R4,FCNVB(R1)	;FIRST BLOCK TO LOCATE IS OVR BIASED
	MOV	SE.SIZ(R0),R2	;GET SIZE OF MODULE IN BYTES
	ADD	#777,R2		;(JUST IN CASE)
	BIC	#777,R2		;ROUND UP TO A BLOCK MULTIPLE
	SWAB	R2		;COMPUTE NUMBER OF BLOCKS IN MODULE
	ROR	R2
	ADD	R2,R4		;R4 = TOTAL NUMBER OF FBB'S TO GENERATE
	MOV	R4,R0		;WE NEED 2* THAT MANY WORDS FOR N FFB'S
	ASL	R0		;*2
	CALL	GETBUF		;GET ROOM FROM SMALL BUFFER POOL
	CALLX	JAMBY2		;SET UP OVR COUNT AND BASE
	MOV	R0,(R5)+	;ADDRESS OF OVR FBB LIST
	MOV	@0(SP),(R5)	;address of base cell address		;071
	MOV	@0(R5),(R5)+	;Now address of OVR FBB (OVBASE or O2BASE);071
	ADD	#2,(SP)		;Correct offset the return address	;071
	CALLX	JAMBYN		;NO GENERATE THE TABLE
	MOV	R4,(R5)		;NUMBER OF FBB'S
	ASL	(R5)+		; *2 = NUMBER OF JAM WORDS
	MOV	R0,(R5)+	;IN THE TABLE JUST ALLOCATED
	MOV	R4,-(SP)	;Save total blocks of Overlays for phase ;071
	MOV	R2,-(SP)	;Save real block count of phase		;071
10$:	MOVB	SYSFUN,(R5)+	;SYSTEM DISK FUN
	MOV	R5,-(SP)	;SAVE R5 AROUND VBNFBN
	CALLX	VBNFBN		;CONVERT VBN TO FBN
	MOV	(SP)+,R5
	MOVB	R3,(R5)+	;FBN MSB
	MOV	R2,(R5)+	;FBN LSB
	INC	FCNVB(R1)	;NEXT BLOCK
	SOB	R4,10$		;MORE
	MOV	(SP)+,R2	;Restore real block count for phase	;071
	MOV	(SP)+,R4	;Restore total blocks of overlays	;071
	RETURN

GLOBAL	<FQSIL,FCSIL,.$OVRC,.$OVRB,.$OV2B>


; NOW LOCATE ERR

15$:	MOV	#FQ...+FQNAM1,R4 ;POINT TO AREA FOR ERR FILE NAME
	MOV	D.ERRN,(R4)+	;SET UP FILE NAME
	MOV	D.ERRN+2,(R4)+
	MOV	#^RERR,(R4)+	;EXTENSION IS ERR
	CALLX	LOK...		;FIND IT
	BCS	60$		;OOPS
	CALL	NOKILL,R5,FC...	;MAKE SURE IT IS UNKILLABLE
	CMP	FC...+FCSIZ,#16.;IS IT PERHAPS A LARGE ERROR FILE?
	BNE	70$		;NO, THE ERROR FILE HAS A BAD SIZE
20$:	CALLX	JAMBYN		;NOW SET UP ANOTHER JAM FOR THE ERROR FILE
	MOV	#1,(R5)+	;JAM THE ERROR FILE SIZE
	MOV	.$ERSZ,(R5)+	; AT THE ERROR FILE SIZE LOCATION IN THE SIL
	MOV	FC...+FCSIZ,(R5)+; SO THAT WE KNOW THE ERROR FILE SIZE
	MOV	#2,(R5)+	;FOR ERR, JAM 2 WORDS
	MOV	.$ERRB,(R5)+	;& $$ERRB <- FBB FOR ERR.SYS (ONE FBB)
	MOV	FC...+FCWND+2,R2 ;GET RP TO FIRST BLOCK
	CALLX	CNVRIB		;CONVERT TO FBN
	MOVB	SYSFUN,(R5)+	;SYSTEM DISK FUN
	MOVB	R3,(R5)+	;ERR FILE FBN MSB
	MOV	R2,(R5)+	;FBN LSB
	CALL	CHKCTG		;ERR MUST BE CONTIGUOUS
	BCS	70$		;ERROR
	MOV	#FC...,R1	;R1 -> FCB FOR READING ERR
	CLR	FCNVB(R1)	;READ BLOCK 0
	CLR	BLNRST		;NO GOOD DATA IN DATABF NOW
	CALLX	READ.B,R5,DATABF ;INTO DATABF, 1 BLOCK

                
	MOV	#DATABF+32.,R0	;POINT TO END OF MESSAGE 0
30$:	CLR	-(R0)		;CLEAR IT OUT
	CMP	R0,#DATABF	;UNTIL DONE
	BHI	30$
	MOV	#D.NAME,R2	;POINT TO THE INSTALLATION NAME
40$:	MOVB	(R2)+,(R0)+	;ADD IN THAT
	BNE	40$
	CLR	FCNVB(R1)	;REWRITE BLOCK 0
	CALLX	WRIT.B,R5,DATABF
	RETURN


60$:	ERF	<"ERR file not found">

70$:	ERF	<"ERR file invalid">

.DSABL	LSB

GLOBAL	<FQ...,D.ERRN,FC...,.$ERRB,.$ERSZ,D.NAME>


	.SBTTL	JAM THE FBB FOR THE LOAD BLOCK

JLODB:	CALLX	SILNDX,R5,FQSIL	;Read in the SIL header.
	BNE	10$		;Die on a error.
	CALLX	SILSCN,R5	;Find the DEFALT module.
	.RAD50	/DEFALT/
	BCS	10$		;Error in the SIL format.
	MOV	#FCSIL,R1	;Point to the FCB and store the
	MOV	SE.BLK(R0),FCNVB(R1) ; starting virtual block for VBNFBN.
	MOV	R5,-(SP)	;Save the Jam List pointer from VBNFBN
	CALLX	VBNFBN		;Convert virtual block to a FBN (in R2 & R3).
	MOV	(SP)+,R5	;Restore the pointer.
	CALLX	JAMBYN		;Set up to generate the FBB.
	MOV	#2,(R5)+	;An FBB is two words
	MOV	.$LODB,(R5)+	; beginning at $$LODB.
	MOVB	SYSFUN,(R5)+	;The first word has the FUN of SY0:
	MOVB	R3,(R5)+	; and the MSBs of the FBN.
	MOV	R2,(R5)+	;The second word is just the LSBs.
	RETURN			;Now wasn't that painless?

10$:	ERF	<"SIL format is invalid; DEFALT phase not found.">

	GLOBAL	<.$LODB,FCSIL,FQSIL>



.SBTTL	CHECK FOR CONTIGUOUS FILE ON FQ...
                
;+
; CHKCTG - CHECK FOR CONTIGUOUS FILE
;
;	FILE OPEN ON FQ...
;
;	CALL	CHKCTG
;
;	C=0 IF FILE IS CONTIGUOUS
;	C=1 IF FILE IS NOT CONTIGUOUS
;-

CHKCTG:	REGSCR			;SAVE REGISTERS
	MOV	#FQ...+FQFCB,R1	;R1 -> FCB FOR THE SIL
	CALLX	RNB		;READ IN THE NAME ENTRY
	MOVB	FCLUS(R1),R1	;R1 = CLUSTER SIZE - 1
	BIC	#177400,R1	;REMOVE SIGN EXTENSION
	INC	R1		;R1 = CLUSTER SIZE
	CLR	R0		;CLEAR FOR DIVIDE
	DIV	DCS,R0		;FILE CLUSTER SIZE / DEVICE CLUSTER SIZE
				;R0 = # OF DEVICE CLUSTERS PER RP
	MOV	UAR(R5),R3	;R3 = LINK TO RETRIEVAL ENTRIES
	CALLX	RDB		;GET RETREIVAL ENTRY
	MOV	2(R5),R1	;R1 = FIRST RETRIEVAL POINTER
	MOV	R3,-(SP)	;SAVE LINK TO THIS RE
10$:	MOV	(SP)+,R3	;GET LINK TO NEXT RE
	BIC	#17,R3		;REMOVE FLAG BITS
	BEQ	40$		;DONE
	CALLX	RDB		;READ IN THE RETREIVAL ENTRY
	MOV	(R5)+,-(SP)	;SAVE LINK TO NEXT RE
20$:	CMP	R1,(R5)+	;DOES THIS MATCH EXPECTED?
	BEQ	30$		;YES, FILE CONTIGUOUS SO FAR
	COM	(SP)+		;NO, DUMP THE DIRECTORY LINK
	RETURN

30$:	ADD	R0,R1		;YES, BUMP DCN BY COUNT
	BIT	R5,#17		;END OF THIS RE?
	BEQ	10$		;YUP
	TST	(R5)		;NO, BUT IS THERE ANOTHER?
	BNE	20$		;YES, TRY AGAIN
	TST	(SP)+		;DUMP THE LINK TO NEXT ENTRY
40$:	CLC			;RETURN C=0
	RETURN			;IT IS CONTIGUOUS

GLOBAL	<DCS>


.SBTTL	Jam the Special J11 Null Job					;052

.ENABL	LSB								;052

J11NUL:	TST	J11LTS		;Have we been told to NOT do this?	;083
	BNE	20$		;Yup, so go back now.			;083
	TST	J11BDR		;Are we on a J11 with a BDR?		;052
	BMI	20$		;No, so just skip this.			;052
	MOV	SYSTIC,60$	;Put the address of SYSTIC in place.	;052
	MOV	#50$,R0		;Address of code to be moved.		;052
	MOV	#$NLLEN,R1	;Number of words to jam.		;052
	CALLX	JAMBYN		;Set up for an n-word jam.		;052
	MOV	R1,(R5)+	;Put in the number of words to jam...	;052
	MOV	NULJOB,(R5)+	; ...and where to jam it.		;052
10$:	MOV	(R0)+,(R5)+	;Put the code into the jam list.	;052
	SOB	R1,10$		;All of it, please.			;052
20$:	RETURN			;And, go back for more.			;052

;+
; Here be the Special J11 null job.  This gets moved in on top of	;052
; the normal null job if applicable.					;052
;-

50$:	.WORD	113737		; MOVB	@#SYSTIC,@#177524		;052
60$:	.WORD	0		;The address of SYSTIC gets put here.	;052
	.WORD	177524		;The address of the 11/84 BDR.		;052
	WAIT			;Sit around for a few cycles.		;052
	BR	50$		;Go do it again.			;052

$NLLEN	= <.-50$>/2		;Length of the above code, in words.	;052

.ASSUME	$NLLEN	LE	5	;The J11 null job must not be more	;052
				; than 5 words long (because that's	;052
				; how long the null job it overlays	;052
				; is).					;052

.DSABL	LSB								;052

GLOBAL	<J11BDR,J11LTS,SYSTIC,NULJOB>					;083



.SBTTL	JAM EXTRA FAST BLOCK MOVE ROUTINES IF WE HAVE CIS

.ENABL	LSB

JCIS:	TSTB	CISINS		;DO WE HAVE CIS?
	BMI	30$		;NO, THEN WE HAVE TO STAY SLOW
	MOV	#40$,R0		;R0 -> FAST BLOCK BYTE MOVE ROUTINE
	MOV	#$MOVBL,R1	;R1 = LENGTH OF THAT ROUTINE
	CALLX	JAMBYN		;JAM THE ROUTINE IN A BLOCK
	MOV	R1,(R5)+	;COUNT OF WORDS TO JAM
	MOV	.$MOVB,(R5)+	;WHERE IN MONITOR TO JAM IT
10$:	MOV	(R0)+,(R5)+	;MOVE THE ROUTINE IN
	SOB	R1,10$		;ALL OF IT
	MOV	#50$,R0		;R0 -> FAST BLOCK WORD MOVE ROUTINE
	MOV	#$MOVWL,R1	;R1 = LENGTH OF THAT ROUTINE
	MOV	R1,(R5)+	;COUNT OF WORDS TO JAM
	MOV	.$MOVW,(R5)+	;WHERE IN MONITOR TO JAM IT
20$:	MOV	(R0)+,(R5)+	;MOVE THE ROUTINE IN
	SOB	R1,20$		;ALL OF IT
	MOV	.$MOVB,-2(R5)	;CHANGE DESTINATION OF JUMP
30$:	RETURN

40$:	MOV	R0,-(SP)
	MOV	R4,-(SP)
	MOV	R2,R0
	CLR	R4
	MOVC
	MOV	(SP)+,R4
	MOV	(SP)+,R0
	RETURN

$MOVBL	= <.-40$>/2

50$:	ASL	R2
	JMP	@#0		;CHANGED TO JMP	@#$$MOVB

$MOVWL	= <.-50$>/2

.DSABL	LSB

GLOBAL	<CISINS,.$MOVB,.$MOVW>


.SBTTL	SET UP THE LOW CORE AREA IN THE BUILD MAP

.ENABL	LSB

LOWINI:	MOV	#FCSIL,R1	;POINT TO FCB FOR READ
	MOV	RSTBLK,FCNVB(R1);READ FIRST BLOCK OF RSTS IMAGE
	CALLX	READ.B,R5,MONLOW ;READ ONE BLOCK			;059
	RETURN			;And we're done				;059

GLOBAL	<FCSIL,MONLOW>


.SBTTL	RETURN UNUSED SPACE TO SMALL BUFFER POOL

.MACRO	RETSMB	START,END
.NLIST
	CALL	RETSMB,R5,<START,END>
.GLOBL	START,END
.LIST
.ENDM	RETSMB

.ENABL	LSB

SMLBUF:	CLR	SMPOOL		;CLEAR OUT INTERNAL SMALL BUFFER LIST
	MOV	@#D.LB+LBEXPA,R0 ;HOW MANY BUFFERS SHALL WE TURN INTO EXTRA
				; PATCH SPACE?
	ASH	#5,R0		;LET'S CONVERT THAT TO BYTES
	ADD	R0,.$BUFS	; AND ADJUST THE START OF THE BUFFER POOL
	RETSMB	.$BUFS,.$BUFE	;INITIALIZE POOL TO BUFFERS FROM SYSGEN
	RETSMB	.$MBFS,.$MBFE	;RETURN 'MORBUF' BUFFERS
	RETSMB	.$YBFS,.$YBFE	; AND 'YABUF' BUFFERS
	TST	PARUNI		;SHOULD WE RETURN THE PARITY /ECC AREA?
	BNE	10$		;NO
	TST	ECC70		;ONE MORE CHECK
	BNE	10$		;DON'T RETURN IT IF THERE'S ANY CSR'S
	RETSMB	.$UPES,.$UPEE	;YES, RETURN THAT SPACE
	RETSMB	.$UPEI,.$UPEJ	;RETURN THIS TO SMALL BUFFERS IF NOT IN I-SPACE
10$:	TST	FPU		;DOES THIS MACHINE HAVE AN FPU?
	BPL	30$		;YES, LEAVE THE FPU CODE ALONE
	RETSMB	.$FPPS,.$FPPE	;NO, RETURN THE FPP CODE TO SMALL BUFFERS
	RETSMB	.$FPPI,.$FPPJ	;RETURN THIS TO SMALL BUFFERS IF NOT IN I-SPACE
20$:	MOV	.$FIS,MONLOW+244 ;SET THE VECTOR AT 244 TO $$FIS	;059
	MOV	#PR3&4340,MONLOW+246 ;AND IT TRAPS AT PR3		;059
	CALLX	JAMBY2		;GENERATING PAIRS
	MOV	.$RTSP,(R5)+	;POINT TO $$RTSP
	MOV	.$SFPP,(R5)+	;& $$SFPP <- #$$RTSP IF NO FPP
	MOV	.$RTSP,(R5)+	;POINT TO $$RTSP
	MOV	.$RFPP,(R5)+	;& $$RFPP <- #$$RTSP IF NO FPP
30$:	TST	MEDINS		;IS THIS AN 11/60?
	BPL	40$		;YUP, LEAVE THE 'MED' CODE ALONE
	RETSMB	.$MEDS,.$MEDE	;NO, RETURN THE MED CODE TO THE SMALL POOL
	RETSMB	.$MEDI,.$MEDJ	;RETURN THIS TO SMALL BUFFERS IF NOT IN I-SPACE
;035+
40$:	CLR	R1		;Say we'll return no CMT's
	MOV	.CMT,46$	;Get address of monitor's CMT
	MOVB	CMT+CM.CCT,R0	;Get total # of [T]MSCP controllers found
	MOVB	CMT+CM.DCT,R2	;Get # of disk controllers found
	SUB	R2,R0		;Compute # of tape controllers found        
	TST	CNT.DU		;Were DU disks genned in this monitor?
	BEQ	42$		;No, check for tapes
	MOV	R2,R1		;Get # of disk controllers found
42$:	TST	CNT.MU		;Were MU tapes genned in this monitor?
	BEQ	44$		;Nope, see if there were disks
	ADD	R0,R1		;Compute total # of controllers to enable
44$:	MUL	#CMTSIZ,R1	;Compute size of area needed for CMT's
	ADD	R1,46$		;Compute beginning of area to return
	MOV	.UMTDU,48$	;Return everything up to UMT$DU
	MOV	CNT.DU,R1	;Were disks genned?
	BEQ	45$		;Nope, so we're all set
	TST	R2		;Yes, did we find any controllers?
	BNE	45$		;Yes, so we need the UMT$DU entries
	MUL	#UMTSIZ,R1	;We don't need these entries either
	ADD	R1,48$		;Compute end of area to return              
45$:	CALL	RETSMB,R5,<46$,48$>	;Return area to small buffer pool

	TMPORG	STACTL
46$:	.WORD	0		;Start of area to return (Filled in)
48$:	.WORD	0		;End of area to return (Filled in)
	UNORG

GLOBAL	<MONLOW>


;035-
50$:	BIT	#40,FLAG22	;IS UNIBUS MAP REQUIRED?
	BNE	55$		;YES, CAN'T RELEASE UNIBUS MAP CODE	;039
	RETSMB	.$UMRS,.$UMRE	;NO, UNIBUS MAP WON'T BE NEEDED
	RETSMB	.$UMRI,.$UMRJ	;RETURN THIS TO SMALL BUFFERS IF NOT IN I-SPACE
	CALLX	JAMBY2		;GENERATING PAIRS
	MOV	.$RTSP,(R5)+	;ALLOCATING UMR'S IS A SNAP
	MOV	.$GUMR,(R5)+	;& $$GUMR <- #$$RTSP IF NOT 22-BIT MODE
	MOV	.$RTSP,(R5)+	;AND SO IS RELEASING THEM
	MOV	.$RUMR,(R5)+	;& $$RUMR <- #$$RTSP IF NOT 22-BIT MODE

GLOBAL	<CMT,CNT.DU,CNT.MU,.UMTDU>					;035
GLOBAL	<FPU,.$FIS,.$RTSP,.$SFPP,.$RFPP,MEDINS,.$GUMR>
GLOBAL	<.$RUMR,ECC70,PARUNI,D.LB,.$BUFS,.$BUFE,.$MBFS,.$MBFE,.$YBFS,.$YBFE>
GLOBAL	<SMPOOL,FLAG22>		; Cells in final loader comm area


55$:	TST	D.LB+LBNSPL	;Running with DECnet?			;039
	BNE	60$		;Yes, we sure are			;039
	RETSMB	.$NETS,.$NETE	;No, so return the data structures	;039
	RETSMB	.$NETI,.$NETJ	;And the code if not using data space	;039
	CALLX	JAMBYN		;Set up to disable DECnet		;039
	MOV	.$NETW,R0	;Pick up number of words to set up	;039
	MOV	R0,(R5)+	;And set up for that jamming		;039
	MOV	.$NETT,(R5)+	;Set up address of table		;039
57$:	MOV	.$CCCR,(R5)+	;Set up the address of the "CCC" routine ;039
	SOB	R0,57$		;Now loop for the whole table		;039
60$:	TST	D.LB+LBLATL	;Are we loading LAT?			;066
	BGT	63$		;Yes, so leave data alone		;079
	RETSMB	.$LATS,.$LATE	;No, so return the structure		;066
63$:	TST	D.LB+LBNODL	;Are we loading Async DDCMP?		;079
	BGT	65$		;Yes, so leave the DDB alone		;079
	MOV	NODDDB,46$	;Get start of NO DDB			;079
	MOV	46$,48$		;Copy start of DDB			;079
	ADD	DDS.NO,48$	;Make it one DDB to return		;079
	CALL	RETSMB,R5,<46$,48$>	;Return area to small buffer pool ;079
65$:	TSTB	DSPACE		;Running with kernel mode data space?	;038
	BEQ	70$		;No, nothing to jam			;031
	CALLX	JAMBYN		;Yes, get ready to jam APR pointers	;031
	MOV	#4,(R5)+	;Four word table			;038
	MOV	.$DSPA,(R5)+	;& $$DSPA <- #KDSAR5,#KDSAR6,		;031
				;		#KDSDR5, KDSAR5		;031
	MOV	#KDSAR0+<5*2>,(R5)+ ;Jam "DPAR5" value
	MOV	#KDSAR0+<6*2>,(R5)+ ;Jam "DPAR6" value
	MOV	#KDSDR0+<5*2>,(R5)+ ;Jam "DPDR5" value
	MOV	#KDSAR0+<5*2>,(R5)+ ;Change DPAR5J from junk to the APR	;027
;+
; Now check out DEUNA counts and free up unused space			;040
;	Return excess DDBs to small buffer pool, set up FAKDDB pointer	;045
;	During JAMDVC when we're traversing DSTBL			;045
;-
70$:	CALL	90$,R0,<XE.PKT,XEDDDB,DDS.XE>				;053
	CALL	90$,R0,<XH.PKT,XHDDDB,DDS.XH>				;053
	MOV	#SMPOOL,R0	;Now change the pool to start/length	;049
80$:	SUB	(R0)+,(R0)+	;Subtract start from end of each	;053
	TST	(R0)		;End?					;049
	BNE	80$		;No					;053
	RETURN			;Yes, done.				;049

90$:	MOV	(R0)+,R2	;Get pointer to packet			;053
	MOVB	(R2),R1		;Get number of controllers supported	;053
.ASSUME	PK.MXU EQ 0
	MOV	PK.CSO(R2),R2	;Get offset into CSR table		;053
	ADD	#CSRTBL,R2	;Point to entry for first CSR		;053
	MOV	@(R0)+,46$	;Get start of region for RETSMB		;053
100$:	TST	(R2)		;Does this controller exist?		;057
	BNE	120$		;Yes, don't return segment		;053
110$:	MOV	46$,48$		;No, so return segment			;053
	ADD	@(R0),48$	; = to one DDB in length		;053
	PUSH	<R0,R1,R2>	;Save working registers			;053
	CALL	RETSMB,R5,<46$,48$>	;Return area to small buffer pool
	POP	<R2,R1,R0>	;Restore working registers		;053
120$:	ADD	@(R0),46$	;Point to next DDB			;053
	TST	(R2)+		;Advance pointer			;053
	SOB	R1,100$		;Maybe more controllers?		;053
	TST	(R0)+		;Skip DDS.Xx word			;053
	RETURN	R0		;Done					;053

GLOBAL	<.$LATS,.$LATE,D.LB>	;LAT structures locator			;066

.DSABL	LSB

.MACRO	RETSMB
.ERROR;	RETSMB CALL IS OUT OF PLACE
.ENDM	RETSMB

GLOBAL	<.$DSPA,DSPACE,D.LB,.$NETS,.$NETE,.$NETI,.$NETJ,.$NETW,.$NETT>	;039
GLOBAL	<.$CCCR,XEDDDB,XHDDDB,CSRTBL,XE.CSO,DDS.XE,XH.CSO,DDS.XH>	;053
GLOBAL	<NODDDB,DDS.NO>							;079
GLOBAL	<SMPOOL>		; Cell in final loader comm area




.SBTTL	ALLOCATE N WORDS FROM THE SMALL BUFFER AREA

;+
; GETBUF - GET N WORDS FROM THE SMALL BUFFER AREA
;
;	R0 =  WORD COUNT (NOT BYTE COUNT) TO OBTAIN
;
;	CALL	GETBUF
;
;	R0 =  ADDRESS OF THE BUFFER
;
; THIS ROUTINE TRIES TO ALLOCATE SPACE FROM LOW MEMORY FIRST.
;-

.ENABL	LSB

GETBUF:	REGSCR			;SAVE REGISTERS
	MOV	#SMPOOL-2,R1	;GET POINTER TO POOL (BIASED)
	ASL	R0		;MAKE WORD COUNT A BYTE COUNT
10$:	TST	(R1)+		;ADVANCE TO NEXT POOL
	TST	(R1)+		;IF ANY
	BNE	20$		;THERE IS ONE, SO PROCEED
NOSMAL:	MESSAGE	<<200>"??Not enough small buffers to start timesharing"<200>>
									;069
	EXIT			;go back to 'Option:' prompt		;069

20$:	CMP	R0,(R1)		;IS THERE ROOM IN THIS POOL?
	BHI	10$		;NO, KEEP TRYING
	MOV	-(R1),TOS.R0(SP) ;YES, SET ADDRESS TO RETURN
	ADD	R0,(R1)		;MOVE FRONT OF POOL UP PAST THE BLOCK
	CMP	(R1)+,.$ISPS	;INTO I-SPACE REGION?
	BLO	25$		;No, not yet, so it's OK.		;074
	CMP	-2(R1),.$ISPE	;But is it AFTER the END of I-space?	;074
	BLO	NOSMAL		;Nope, too bad - go punt.		;074
25$:	SUB	R0,(R1)+	;DECREMENT SIZE OF POOL
	BNE	40$		;STILL SOME LEFT
	TST	(R1)		;DID THE LAST POOL SHRINK TO 0?
	BEQ	NOSMAL		;YES, DIE
30$:	MOV	(R1)+,-6(R1)	;NO, COLLAPSE THE POOL
	BNE	30$		;UNTIL THE END
40$:	RETURN

.DSABL	LSB
GLOBAL	<.$ISPS,.$ISPE>							;074
GLOBAL	<SMPOOL>		; Cell in final loader comm area


.SBTTL	FIX THE SMALL BUFFER POOL TO BE BOUNDARY 40 AND LENGTH 40 AREAS

.ENABL	LSB

FIXSML:	MOV	#SMPOOL,R0	;POINT TO THE POOL LIST
	MOV	R0,R1		;OUTPUT POINTER FOR COLLAPSING TABLE
10$:	ADD	(R0)+,(R0)	;CHANGE LENGTH TO END ADDRESS
	ADD	#37,-(R0)	;ROUND START ADDRESS UP TO MULTIPLE OF 40
	BIC	#37,(R0)
	SUB	(R0)+,(R0)	;SUBTRACT START FROM END TO GIVE LENGTH
	BIC	#37,(R0)+	;AND ROUND LENGTH DOWN TO A NUMBER OF BUFFERS
	BLOS	20$		;THIS REGION IS EMPTY, SO ELIMINATE IT
	CMP	-(R0),-(R0)	;BACK UP TO START/LENGTH
	MOV	(R0)+,(R1)+	;MOVE IT INTO THE TABLE
	MOV	(R0)+,(R1)+
20$:	TST	(R0)		;END OF SMALL LIST?
	BNE	10$		;NO, COLLAPSE MORE
	CLR	(R1)+		;END THE TABLE WITH A 0 WORD
	RETURN			;YES, DONE

.DSABL	LSB

GLOBAL	<SMPOOL>		; Cell in final loader comm area


.SBTTL	DUMP THE SMALL BUFFER POOL POINTERS TO THE JAM LIST

JAMSML:	MOV	#SMPOOL+2,R0	;POINT TO INTERNAL ADDR/LENGTH LIST
	CLR	R1		;ACCUMULATED COUNT = 0
10$:	MOV	(R0)+,R3	;R3 = SIZE OF THIS ONE
	ASH	#-5,R3		;CONVERT LENGTH TO BUFFER COUNT
	BIC	#174000,R3	;AVOID SIGN EXTEND
	ADD	R3,R1		;COUNT THE TOTAL
	TST	(R0)+		;IS THERE A NEXT AREA?
	BNE	10$		;YES, DO ANOTHER
	CALLX	JAMBY2		;NO, SET UP SMALL POOL PARAMETERS
	MOV	R1,(R5)+	;NUMBER OF SMALL BUFFERS
	MOV	.$FR00,(R5)+	;& $$FR00 <- NUMBER OF SMALL BUFFERS
				; (NOT COUNTING D-SPACE BUFFERS)
	MOV	@#D.LB+LBISPE,R3 ;GET VIRTUAL END OF I-SPACE AREA 
				; (0 IF NO D-SPACE BUFFERS)
	BIC	#40,R3		;ROUND DOWN TO A SMALL BUFFER BOUNDARY
	SUB	@#D.LB+LBISPS,R3 ;COMPUTE LENGTH OF I-SPACE AREA 
	ASH	#-5,R3		;CONVERT TO BUFFER COUNT, ROUNDING DOWN
	BIC	#174000,R3	;AVOID SIGN EXTEND
	ADD	R3,R1		;ADD I-SPACE BUFFERS TO TOTAL
	MOV	R1,(R5)		;NUMBER DIVIDED BY 4
	CLR	R0		;CLEAR R0 FOR DIVIDE, C=0
	ROR	(R5)		; /2
	ASR	(R5)		; /4
	CMP	(R5),#50.	;UPPER LIMIT JOB SMALL BUFFER MAX AT 50
	BLOS	20$		;LESS THAN THAT, LET 25% STAND
	MOV	#50.,(R5)	;MAKE FREEBIE MAX 50 BUFFERS
20$:	TST	(R5)+		;BUMP POINTER
	MOV	.$FR25,(R5)+	;& $$FR25 <- .25 * NUMBER OF SMALL BUFFERS
	DIV	#5,R0		;NUMBER OF BUFFERS/5
	MOV	R0,(R5)+	; = 20% OF POOL
	MOV	.$FR20,(R5)+	;& $$FR20 <- .20 * NUMBER OF SMALL BUFFERS
	MOV	SMPOOL,(R5)+	;POINTER TO FIRST FREE BUFFER
	MOV	.$BFRT,(R5)+	;& $$BFRT <- FIRST FREE BUFFER
	RETURN

GLOBAL	<.$FR00,.$FR25,.$FR20,.$BFRT,D.LB>
GLOBAL	<SMPOOL>		; Cell in final loader comm area


.SBTTL	MERGE RETURNED AREA INTO SMALL BUFFER POOL

;+
; RETSMB - MERGE AREA INTO SMALL BUFFER POOL
;
;	D.LB+LBISPS =	virtual start of I-space area (0 if no code is
;			being moved)
;	D.LB+LBISPE =	virtual end of I-space area (0 if no code is 
;			being moved)
;
;	CALL	RETSMB,R5		(START-PTR and END-PTR each point to
;	 .WORD	START-PTR,END-PTR	 a word that contains an address)
;
;	SMPOOL has area merged & collapsed
;	Area not returned if in I-space
;-

.ENABL	LSB

RETSMB:	MOV	@(R5)+,R0	;PICK UP START OF AREA
	MOV	@(R5)+,R1	;PICK UP END OF AREA
	CMP	R0,@#D.LB+LBISPS ;IS ITS START BELOW I-SPACE AREA?
	BLO	10$		;YES, CHECK ITS END
	CMP	R0,@#D.LB+LBISPE ;NO, IS IT IN I-SPACE AREA?
	BLO	60$		;YES, DON'T RETURN IT
10$:	CMP	R1,@#D.LB+LBISPS ;IS ITS END BELOW I-SPACE AREA?
	BLO	20$		;YES, RETURN IT
	CMP	R1,@#D.LB+LBISPE ;NO, IS IT IN I-SPACE AREA?
	BLO	60$		;YES, DON'T RETURN IT	
20$:	MOV	#SMPOOL,R2	;R2 -> SMALL BUFFER POOL
30$:	CMP	R2,#SMPEND	;Is table full?				;066
	BHIS	75$		;Yes, so tell user and die		;066
	TST	(R2)		;END OF POOL?
	BEQ	90$		;YUP, ADD A NEW REGION AT THE END
	CMP	R1,(R2)+	;NO, IS NEW REGION END=TBL REGION START?
	BLO	100$		;IT'S BELOW, GO OPEN UP A HOLE
	BEQ	70$		;EQUAL, SO MERGE DOWNWARD
	CMP	R0,(R2)+	;NO, IS NEW REGION START=TBL REGION END?
	BNE	30$		;NO, GO TRY FOR MORE IN TABLE
	MOV	R1,-(R2)	;YES, EXTEND TBL TO END AT END OF NEW REGION
40$:	CMP	(R2)+,(R2)+	;IS END OF AREA = START OF NEXT?
	BNE	60$		;NO, DON'T NEED TO MERGE THEM
50$:	MOV	(R2)+,-6(R2)	;YES, SET END OF NEXT INTO END OF PREVIOUS
	MOV	(R2)+,-6(R2)	;COPY START OF NEXT REGION
	BNE	50$		;IF NOT NULL, MOVE DOWN REST OF TABLE
60$:	RETURN	R5

70$:	MOV	R0,-(R2)	;SET START OF REGION = START OF NEW
	RETURN	R5		;AND EXIT

75$:	MESSAGE	<"INIT bug - RETSMB table overflow"<200>>		;066
	EXIT			;Tell user the trouble and die		;066

GLOBAL	<D.LB>
GLOBAL	<SMPOOL,SMPEND>		; Cell in final loader comm area	;066



80$:	MOV	R1,(R2)+	;SET UP END OF REGION
	MOV	(SP)+,R0	;RESTORE START OF NEXT
	MOV	(SP)+,R1	; AND END OF NEXT
90$:	TST	(R2)+		;R2 -> NEXT AREA
100$:	MOV	(R2),-(SP)	;SAVE END OF AREA
	MOV	-(R2),-(SP)	;AND START OF AREA
	MOV	R0,(R2)+	;SET START OF LOWER AREA
	BNE	80$		;AND LOOP IF NOT END OF TABLE
	CMP	(SP)+,(SP)+	;DUMP JUNK ON STACK
	RETURN	R5  

.DSABL	LSB


.SBTTL	SET UP MEMORY CONTROL LISTS

.ENABL	LSB

SETMEM:	CALLX	JAMBYN		;WE GENERATE N-WORD JAM LISTS
	CLR	R1		;R1 = K NUMBER = 0
	CLR	R2		;R2 = POINTER TO PREVIOUS MCB = 0
10$:	MOV	(PC),R4		;PREVIOUS K TYPE = JUNK TO FORCE NEW MCB
20$:	CALL	GETTYP		;WHAT TYPE OF ENTITY IS IN THIS K?
	CMP	R3,R4		;SAME AS PREVIOUS K?
	BEQ	50$		;YUP, BUMP SIZE OF PREVIOUS
	TST	R3		;NO, BUT IS IT USER CORE?
	BEQ	50$		;YES, GO EXTEND THE TOTAL SIZE OF THIS REGION
30$:	CALL	GETMCB		;GET ADDRESS OF MCB SO WE CAN BUILD ONE
	MOV	R4,-(SP)	;SAVE THE CONTROL BITS
	TST	R1		;IS THIS THE BEGINNING?
	BEQ	40$		;YES, DON'T CHANGE PREVIOUS AT 0K
	MOV	R0,M.PNXT-MCBSIZ(R5) ;POINT PREVIOUS MCB AT THIS
	MOVB	M.SIZE-MCBSIZ(R5),R4 ;GET SIZE OF AREA IN USE (< 128., NO SXT)
	NEG	R4		; NEGATED
	ADD	M.TSIZ-MCBSIZ(R5),R4 ;COMPUTE TOTAL SIZE - SIZE USED
40$:	MOV	#5,(R5)+	;INDICATE 5 WORDS TO JAM
	MOV	R0,(R5)+	;& EACH MCB <- 5-WORD PARAMETERS AREA
	MOV	R2,(R5)+	;M.PPRV - POINTER TO PREVIOUS + 2 (OR 0)
	MOV	R0,R2		;NEW MCB IS THE CURRENT ONE NOW
	ADD	#2,R2		;REMEMBER POINTER TO BLOCK + 2
	CLR	(R5)+		;M.PNXT - 0 (NO NEXT BLOCK YET)
	CLR	(R5)+		;M.TSIZ - 0 (TOTAL SIZE 0 SO FAR)
	MOV	(SP)+,(R5)+	;M.SIZE/M.CTRL - SIZE 0, CONTROL BY TYPE
	MOV	R1,R0		;COPY K NUMBER
	ASH	#11.-6,R0	;MAKE IT AN MMU ADDRESS
	MOV	R0,(R5)+	;M.PHYA - PHYSICAL ADDRESS AS MMU ADDRESS
50$:	MOV	R3,R4		;COPY TYPE OF THIS K
	BEQ	60$		;USER CORE, JUST LENGTHEN PREVIOUS MCB
	INCB	M.SIZE-MCBSIZ(R5) ;INCREASE SIZE OF LOCKED ITEM
	BNE	60$		;IT'S NOT 256K YET			;070
	DECB	M.SIZE-MCBSIZ(R5) ;256K!!! FIX SIZE AND
	BR	30$		; GO BUILD ANOTHER MCB FOR THIS AREA

60$:	INC	M.TSIZ-MCBSIZ(R5) ;INCREASE TOTAL SIZE OF THIS AREA
	INC	R1		;ADVANCE TO THE NEXT K
	CMP	R1,MAXMEM	;ARE WE AT THE END OF MEMORY?
	BLO	20$		;NOT YET
	BEQ	10$		;YES, FORCE OUT THE TAIL AS A NEW BLOCK
	RETURN

GLOBAL	<D.SWPM,MAXMEM>							;048

.DSABL	LSB


.SBTTL	GET A MEMORY CONTROL BLOCK

;+
;	R1 =  K NUMBER
;	R3 =  TYPE OF ENTITY IN THIS K
;
;	CALL	GETMCB
;
;	R0 =  ADDRESS OF MCB
;	R4 =  STATUS BITS
;
; NOTE:	REGION TYPE CAN BE DETERMINED BY ADDRESS & 37 AS FOLLOWS:
;	0 - EXEC OR ODT (DISTINGUISH BY ADDRESS) OR END (FWD LINK = 0)
;	2 - EXTENDED BUFFER POOL
;	4 - LOCKED MEMORY AND VIRTUAL DISK				;070
;	6 - NXM (BUT NOT AT TOP OF MEMORY!)
;	10 - RTS
;	20 - USER JOB
;-

.ENABL	LSB

GETMCB:	MOV	.$MEMT,R0	;Guess at the tail of memory		;034
	CMP	R1,MAXMEM	;Is it?
	BEQ	10$		;Yes, so all set up
	MOV	.$MEML,R0	;Guess at the top of memory (monitor)	;034
	MOV	R3,R4		;Copy the type code (from GETTYP)	;070
	ASR	R4		;Now get type code / 2 (an even value)
	SUB	#U.ODT/2,R4	;Bias to get proper MCSB offset		;048
	BMI	10$		;Negative, must be monitor		;034
.ASSUME	U.EXEC	LT	U.ODT						;048
	CMP	#6,R4		;Is type LOCKED or NXTMEM?		;070
.ASSUME	6	EQ	<U.LOCK/2-4>					;070
	BGT	5$		;No- result ok as is			;070
	SUB	#2,R4		;Compensate for VDSK not a type in RSTS	;070
5$:	MOV	#40/2,R0	;Get the size of a sml buff for the MCSB ;070
	CALL	GETBUF		;And now allocate it
	ADD	R4,R0		;Set up the correct offset
10$:	MOV	#MC.LCK*400,R4	;Indicate region is to be locked	;034
	RETURN			;And get out				;034

	.DSABL	LSB

GLOBAL	<.$MEML,.$MEMT,MAXMEM>						;034


.SBTTL	SET UP DISK SIZES AND DCS'S

.ENABL	LSB

JAMDSK:	CALLX	JAMBYN		;JAM BY TABLES
	MOV	#SATBUF,R0	;R0 -> TABLE OF GENERATED DEVICES
	MOV	R5,-(SP)	;REMEMBER WHERE THE COUNT GOES
	CLR	(R5)+		;INITIAL COUNT = 0
	MOV	.$DSIZ,(R5)+	;& $$DSIZ <- TABLE OF DISK SIZES IN DCN'S
10$:	CMPB	(R0)+,DEVOKB	;UP TO THE KB'S YET?
	BHIS	50$		;YUP, DONE DISKS
	INC	R0		;SKIP RSTS UNIT # (0)
	MOV	(R0)+,-(SP)	;(SP) = NUMBER OF DISKS OF THIS TYPE
	MOVB	(R0),R2		;PACKET NUMBER
	ASL	R2		; *2 = DISK INDEX + 2 (DISKS 2ND IN TABLE)
	MOV	DSKDCS-2(R2),R4	;R4 -> CLUSTER SIZES FOR THIS DISK TYPE
	MOV	DSKSZL-2(R2),R3	;R3 -> LOW ORDER SIZES FOR THIS DISK TYPE
	MOV	DSKSZM-2(R2),R2	;R2 -> HIGH ORDER SIZES FOR THIS DISK TYPE
20$:	MOV	(R4)+,-(SP)	;GET DISK CLUSTER SIZE
	MOV	(R3)+,(R5)	;LOW ORDER SIZE GOES IN TABLE
	MOV	(R2)+,R1	;R1 = HIGH ORDER SIZE
30$:	ASR	(SP)		;SHIFT THE CLUSTER SIZE
	BEQ	40$		;DONE
	ASR	R1		;SHIFT MSB SIZE RIGHT
	ROR	(R5)		;AND EXTEND TO LSB SIZE IN TABLE
	BR	30$		;TRY AGAIN

40$:	CMP	(SP)+,(R5)+	;DUMP STACK, ADVANCE TABLE
	INC	@2(SP)		;BUMP COUNTER OF TABLE SIZE
	DECB	(SP)		;COUNT DOWN DISKS
	BNE	20$		;DO ANOTHER OF THESE UNITS
	CMP	(SP)+,(R0)+	;DUMP UNIT COUNT, ADVANCE R0
	CMP	(R0)+,(R0)+	;R0 -> NEXT DISK CONTROL BLOCK
	BR	10$		;TRY FOR MORE

GLOBAL	<SATBUF,.$DSIZ,DEVOKB,DSKDCS,DSKSZL,DSKSZM>


50$:	MOV	@(SP)+,R4	;DCS TABLE WILL BE THE SAME SIZE
	MOV	R4,(R5)		;SET TABLE SIZE IN JAM LIST
	ASL	R4		;COMPUTE SIZE IN BYTES
	ADD	R5,R4		;POINT TO NEXT TABLE FOR MASSBUS ID'S
	CMP	(R4)+,(R4)+	;SKIP DCS TABLE HEADER WORDS
	MOV	(R5)+,(R4)+	;SET THE SAME LENGTH
	MOV	.$DDCS,(R5)+	;& $$DDCS <- TABLE OF DISK DCS'S
	MOV	.$DMID,(R4)+	;& $$DMID <- TABLE OF DISK (MASSBUS) ID'S
	MOV	#SATBUF,R0	;R0 -> TABLE OF GENERATED DEVICES
60$:	CMPB	(R0)+,DEVOKB	;UP TO KB'S YET?
	BHIS	80$		;YES, DONE WITH DISK SETUP
	CLR	-(SP)		;Clear for a byte move
	MOVB	(R0)+,(SP)	;Save the starting RSTS unit number 
				;DS.UNT is always DS.CTL * DS.NUN for disks
				; refer to BLDJAM routine in INSTAL.
	ASL	(SP)		;Times 2 for byte offset into DSKDCS table
	MOV	(R0)+,R1	;R1 = NUMBER OF DISKS OF THIS TYPE
	MOVB	(R0),R2		;R2 = PACKET NUMBER = DISK INDEX/2+1
	ASL	R2		;R2 = DISK INDEX + 2
	MOV	DSKMID-2(R2),R3	;R3 -> (MASSBUS) ID TABLE FOR DISK TYPE
	MOV	DSKDCS-2(R2),R2	;R2 -> CLUSTER SIZES FOR DISK TYPE (UNIT ZERO)
	ADD	(SP)+,R2	;  Plus starting unit # *2 on multi-cntrllers	
70$:	MOV	(R2)+,(R5)+	;MOVE IN A CLUSTER SIZE
	MOV	(R3)+,(R4)+	;MOVE IN A MASSBUS ID
	DECB	R1		;ANY OTHER DISK UNITS?
	BNE	70$		;DO AS MANY AS ARE GENERATED
	ADD	#DS.XXX-DS.PKT,R0 ;ADVANCE R0
	BR	60$		;DO MORE DISKS

80$:	MOV	R4,R5		;UPDATE JAM POINTER TO END OF ID TABLE
	RETURN			;DONE WITH DISK SETUP

.DSABL	LSB

GLOBAL	<.$DDCS,.$DMID,SATBUF,DEVOKB,DSKMID,DSKDCS>


;033+
.SBTTL	Jam the [T]MSCP unit and controller mapping tables (UMT/CMT)

.ENABL	LSB

JTMSCP:	MOVB	CMT+CM.DCT,R1	;R1 = # of disk controllers found
	MOVB	CMT+CM.CCT,R0	;R0 = Total # of controllers found
	BEQ	55$		;None is easy
	SUB	R1,R0		;R0 = # of tape controllers found
	TST	CNT.MU		;Are TMSCP tapes genned?		;035
	BNE	40$		;Yes, so leave count alone		;035
	CLR	R0		;None genned, so don't enable them	;035
40$:	CLR	CMTADJ		;Assume no adjustment necessary		;035
	TST	CNT.DU		;Are MSCP disks genned?			;035
	BNE	50$		;Yes, so leave count alone		;035
	MUL	#CMTSIZ,R1	;We're not enabling them, so tape CMT	;035
	MOV	R1,CMTADJ	;...offsets are off by this much	;035
	CLR	R1		;None genned, so don't enable them	;035
50$:	TST	R1		;Are disks enabled?			;035
	BNE	60$		;Yes, go do them			;035
	TST	R0		;Gee Beave, no disks, were there tapes?
	BNE	100$		;Got to do tapes
55$:	RETURN			;Gosh no Wally, we got nuthin' to do


60$:	CALLX	JAMBYN		;Jam UMT$DU table from the ROOT		;035
	MOV	#<UMTSIZ/2>,R3 	;R3 = # of words to jam for 1 unit
	MOV	CNT.DU,R2	;Check out all genned UMT entries
	MUL	R2,R3 		;R3 = Total words to jam (# units * R3)
	MOV	R3,(R5)+	;Set length of the table to jam in words
	MOV	#UMT$DU,R3	;Use the ROOT's copy of the UMT
	MOV	.UMTDU,(R5)+	;Start jamming at monitor's UMT$DU:: global
70$:	MOV	(R3)+,(R5)+	;Jam this entry's CMT offset
	MOV	(R3)+,(R5)+	; and the Phy Unit indicator also
	SOB	R2,70$		;Loop for all entrys in UMT$DU:		;035
100$:	MOV	R0,-(SP)	;Save tape controller count
	BEQ	JCMT		;No tapes, go right to the CMT jamming
	CALLX	JAMBYN		;Set up jamming, if needed
	MOV	#SATBUF-DS.XXX,R4 ;Point to beginning of SIL DEVTBL
110$:	ADD	#DS.XXX,R4	;Point to next device
	TST	DS.NUN(R4)	;End of table?
	BEQ	JCMT		;Yes, all done.  Now jam CMT's
	MOVB	DS.PKT(R4),R3	;No, get the DEVTBL index number
	MUL	#PKTSIZ,R3	;Compute offset to the device packet
	CMP	DEVTBL+PK.NAM(R3),#"MU	;Is this a MU: controller?
	BNE	110$		;Nope
	MOVB	DS.DVN(R4),R3	;Get offset to monitor DEVNAM table
	CALL	RDRSO3,R4,DEVPTR ;Get a pointer to the DDB tables (DEVPTR+R3)
	MOV	(R0),R0		;R0 -> DDB Table entry for MU0:
	MOVB	DS.CTL(R4),R3	;Get unit number
	ASL	R3		;Unit * 2
	ADD	R3,R0		;R0 -> DDB Table entry for this tape
	CALL	RDRSTS		;Read DDB table entry
	MOV	#<UMTSIZ/2>,(R5)+ ;# of words to jam for 1 unit
	MOV	(R0),(R5)	;UMT is to be stored in this DDB...
	ADD	.$UMTM,(R5)+	;At offset $$UMTM
	MUL	#<UMTSIZ/2>,R3	;R3 -> UMTSIZ * Unit #
	ADD	#UMT$MU,R3	;R3 -> UMT entry for this unit
	MOV	(R3)+,(R5)	;Jam unit's CMT offset
	SUB	CMTADJ,(R5)+	;Adjusted by the # of non-used disk controllers
	MOV	(R3)+,(R5)+	;Jam the physical unit indicator
	BR	110$		;Look for more MU: controllers


;+
; Jam the CMT header
;-
JCMT:	MOV	(SP)+,R0	;Restore # of tape controllers
	CALLX	JAMBY2		;Jam the required CMT entries in pairs
	MOV	#CMT,R3		;Point R3 to 1st controller entry in INIT
	MOV	.CMT,R4		;Point R4 to CMT entries in the monitor
	MOV	#-1.,(R5)+	;Jam in the "Ctrlr needs initialization flag"
	MOV	R4,(R5)		;  at the monitor CMT address   (CM.CRQ)
	ADD	#CM.CRQ,(R5)+   ;      in the CM.CRQ offset of the CMT header
	MOV	R0,(R5)		;Jam total controller count = tape count
	ADD	R1,(R5)		;			    + disk count
	TSTB	(R5)+		;Now point to disk controller count
.ASSUME	CM.DCT	EQ <CM.CCT+1>
	MOVB	R1,(R5)+	;Jam the # of disk controllers we'll enable
	MOV	R4,(R5)		;  at monitor CMT addresses (CM.CCT & CM.DCT)
	ADD	#CM.CCT,(R5)+   ;      in the CM.CCT offset of the CMT header
	MOV	CM.AWS(R3),(R5)+ ;Jam in the mscp region's beginning MMU
	MOV	R4,(R5)		;      at the monitor CMT address (CM.AWS)
	ADD	#CM.AWS,(R5)+   ;        in BBR APR6 word of the CMT header
	MOV	@#D.LB+LBMCPP,(R5)+ ;Jam in the MSCP region's beginning mmu
	MOV	R4,(R5)		;      at the monitor CMT address (CM.BA6)
	ADD	#CM.BA6,(R5)+   ;        in BBR APR6 word of the CMT header
	MOV	R1,R2		;Copy number of disk controllers to jam
	BEQ	140$		;None is easy
	CALL	160$		;Jam them
140$:	MOV	R0,R2		;Copy number of tape controllers to jam	;035
	BEQ	170$		;None, so we're done
	MOVB	CMT+CM.DCT,R3	;Get number of disk controllers found	;035
	MUL	#<CMTSIZ>,R3	;Compute size of disk CMT area to skip	;035
	ADD	#CMT,R3		;Point to first tape CMT in INIT	;035
	.CALLR	160$		;Jam them, and return from there


160$:	ADD	#CM.WKA,R4	;R4 -> CM.WKA offset in monitor's CMT
	ADD	#CM.WKA,R3	;R3 -> CM.WKA offset in our CMT
	MOV	(R3)+,(R5)+	;Jam the work area size for this controller
	MOV	R4,(R5)+	;  at this address in the CMT of the monitor
	TST	(R4)+		;Point R4 to the CSR offset of CMT (CM.CSR)
.ASSUME	CM.CSR	EQ <CM.WKA+2>
	MOV	(R3)+,(R5)+	;Jam the CSR assignment for this controller
	MOV	R4,(R5)+	;  at this address in the CMT of the monitor
	TST	(R4)+		;Point R4 to the vector/flag offset   (CM.VTR)
.ASSUME	CM.VTR	EQ <CM.CSR+2>
.ASSUME	CM.FLG	EQ <CM.VTR+1>
	MOV	(R3)+,(R5)+	;Jam the vector assignment/4 and the flag byte
	MOV	R4,(R5)+	;  at this address in the CMT of the monitor
	TST	(R4)+		;Point R4 to the ring size offset  (CM.RSP)
.ASSUME	CM.RSP	EQ <CM.VTR+2>
.ASSUME	CM.CMD	EQ <CM.RSP+1>
	MOV	(R3)+,(R5)+	;Jam the CMD/RSP ring size in power of 2
	MOV	R4,(R5)+	;  at this address in the CMT of the monitor
	TST	(R4)+		;Point R4 to the begining of the next CMT
.ASSUME	CMTSIZ	EQ <CM.RSP+2>
	SOB	R2,160$		;Loop for all controllers found		;035
170$:	RETURN			;All done

	.DSABL	LSB

	TMPORG	STACTL
CMTADJ:	.WORD	0		;Adjustment for non-supported disk controllers
	UNORG

GLOBAL	<CMT,.CMT,UMT$DU,UMT$MU,.UMTDU,CNT.DU,CNT.MU,.$UMTM>
;033-


.SBTTL	Jam Ethernet DDB's and impure regions

;+
;
; NOTE:	INIT jams the controller ID and default physical address
;	into the LAST 4 words of the DDB.  If the DDB size changes,
;	everything will still work correctly as long as things are
;	added BEFORE the last four words.  This fact is noted in
;	both ethernet drivers.
;
;-

JMENET:	MOV	CNT.XE,R0	;UNA's?					;057
	BEQ	50$		;No.  Check QNA's.			;041
	MOVB	XE.PKT+PK.MXU,R4;Number of UNA controllers supported	;041
	CALLX	JAMBYN		;Jam a block of words			;041
	MOV	R4,(R5)		;One word for each controller (Rings)	;041
	ADD	#4,(R5)+	;Plus a 4-word header			;041
	MOV	XECORE,(R5)+	;Starting at XEDCTL in the monitor	;041
	MOV	R0,(R5)+	;First word is # of controllers		;041
	MOV	D.LB+LBMCPL,R1	;Get size of [T]MSCP/Ether region	;041
	MOV	CMT+CM.AWS,R0	;Get [T]MSCP region size		;041
	BEQ	10$		;Nothing, size is Ethernet only		;041
	ADD	#77,R0		;Round [T]MSCP region up to an MMU boundary
	BIC	#77,R0
	ASH	#-6.,R0		;Convert [T]MSCP size to # of slivers	;041
	SUB	R0,R1		;Compute size of Ethernet region	;041
10$:	MOV	D.LB+LBMCPP,(R5);Ethernet region mapping starts at [T]MSCP +
	ADD	R0,(R5)+	; the size of the [T]MSCP region	;041
	MOV	R1,(R5)+	;Jam the size of the Ethernet region (slivers)
	MOV	-4(R5),(R5)+	;Physical = Mapped if <= 124Kw present	;041
				;This location gets jammed again if	;041
				;UMR's are required (See JXBUF)		;041
	MOV	#CSRTBL+XE.CSO,R3	;Point to first UNA CSR		;041
	MOV	#D.ERNG,R2	;Point to UNA ring entries		;041
20$:	TST	(R3)+		;This controller present?		;041
	BEQ	30$		;No. Don't jam ring counts.		;041
	MOV	(R2),(R5)+	;Jam XMT/RCV entries for controller	;041
	BR	40$		;Continue				;041

30$:	CLR	(R5)+		;No rings for a missing controller	;041
40$:	TST	(R2)+		;Advance to next controllers ring counts
	SOB	R4,20$		;Next controller			;041
	CALL	110$,R0,<XE.PKT,CSRTBL+XE.CSO,DDS.XE,XEDDDB,XEADDR>	;053
	;RETURN			;QNA's and UNA's never on same system???????
50$:	MOV	CNT.XH,R0	;QNA's?					;041
	BEQ	100$		;No.					;041
	MOVB	XH.PKT+PK.MXU,R4;Get number of QNA's supported		;041
	CALLX	JAMBYN		;Jam a block of words			;041
	MOV	R4,(R5)		;One word for each controller (Rings)	;041
	ADD	R4,(R5)		;Another word for each (Vectors)	;041
	ADD	#3,(R5)+	;Plus a three word header		;041
	MOV	XHDATA,(R5)+	;Starting at XHDCTL in the monitor	;041
	MOV	R0,(R5)+	;First word is # of controllers		;041
	MOV	D.LB+LBMCPL,R1	;Get size of [T]MSCP/Ether region	;041
	MOV	CMT+CM.AWS,R0	;Get [T]MSCP region size		;041
	BEQ	60$		;Nothing, size is Ethernet only		;041
	ADD	#77,R0		;Round [T]MSCP region up to an MMU boundary
	BIC	#77,R0
	ASH	#-6.,R0		;Convert [T]MSCP size to # of slivers	;041
	SUB	R0,R1		;Compute size of Ethernet region	;041
60$:	MOV	D.LB+LBMCPP,(R5);Ethernet region mapping starts at [T]MSCP +
	ADD	R0,(R5)+	; the size of the [T]MSCP region	;041
	MOV	R1,(R5)+	;Jam the size of the Ethernet region (slivers)
	MOV	#CSRTBL+XH.CSO,R3	;Point to first QNA CSR		;041
	MOV	#D.HRNG,R2	;Point to QNA ring entries		;041
70$:	TST	(R3)		;This controller present?		;053
	BEQ	80$		;No. Don't jam ring counts.		;041
	MOV	(R2),(R5)+	;Jam XMT/RCV entries for controller	;041
	CLR	R0		;Get interrupt vector for the device	;080
	BISB	VECTBL-CSRTBL(R3),R0 ; guarding against sign extension	;080
	ASL	R0		;VECTBL is vector / 2			;047
	INC	R0		;Flag QNA's vs. LQA's			;047
	MOV	R0,<<MAX.XH*2>-2>(R5)	;Jam interrupt vector		;053
	BR	90$		;Continue				;041

80$:	CLR	(R5)+		;No rings for a missing controller	;041
	CLR	<<MAX.XH*2>-2>(R5)	;No vector either		;053
90$:	CMP	(R2)+,(R3)+	;Advance pointers			;053
	SOB	R4,70$		;Next controller			;047
	ADD	#MAX.XH*2,R5	;Skip over interrupt vectors		;053
	CALL	110$,R0,<XH.PKT,CSRTBL+XH.CSO,DDS.XH,XHDDDB,XHADDR>	;053
100$:	RETURN			;Done					-;041

110$:	MOV	(R0)+,R4	;Get pointer to packet			;053
	MOV	(R0)+,R3	;Point to first CSR			;053
	MOVB	(R4),R2		;Number of controllers supported	;053
.ASSUME	PK.MXU	EQ 0
	CLR	-(SP)		;Controller number			;053
120$:	TST	(R3)+		;This controller present?		;053
	BEQ	130$		;No. Don't jam physical address		;053
	MOV	#4,(R5)+	;Jam 4 words				;053
	MOV	@(R0),R1	;Compute starting of the DDB...		;053
	MUL	(SP),R1		; for this controller			;053
	ADD	@(R0),R1	;Now point to the end			;053
	ADD	@2(R0),R1	;Really point to it			;053
	SUB	#4*2,R1		; except for the last four words	;053
	MOV	R1,(R5)+	;Store pointer in the jam list		;053
	MOV	#4*2,R1		;Make pointer from where to jam...	;053
	MUL	(SP),R1		; based on controller number...		;053
	ADD	4(R0),R1 	; Point to it (zero-relative)		;053
	MOV	(R1)+,(R5)+	;Jam a word				;053
	MOV	(R1)+,(R5)+	;Jam a word				;053
	MOV	(R1)+,(R5)+	;Jam a word				;053
	MOV	(R1)+,(R5)+	;Jam a word				;053
130$:	INC	(SP)		;Advance controller number		;053
	SOB	R2,120$		;Next controller			;053
	CMP	(SP)+,(R0)+	;Clean stack and skip a parameter	;053
	CMP	(R0)+,(R0)+	;Skip last two parameters		;053
	RETURN	R0		;And return				;053

	GLOBAL	<CSRTBL,VECTBL,D.ERNG,D.HRNG,XE.CSO,XH.CSO>		;041
	GLOBAL	<XE.PKT,XH.PKT,CNT.XE,CNT.XH,XECORE,XHDATA,D.LB,CMT>	;041
	GLOBAL	<XEDDDB,XHDDDB,DDS.XE,DDS.XE,XEADDR,XHADDR,MAX.XH>	;053


.SBTTL	Jam MMU addresses for conditional phases

JPHASE:	CALLX	JAMBY2		;We jam pairs				;036
	MOV	#40$,R0		;Point to the phase jamming table	;039
	CLR	R2		;Set initial value for non-loaded phases ;044
10$:	TST	@(R0)+		;Phase to be loaded?			;039
	BEQ	20$		;No, not this time			;039
	MOV	@(R0)+,(R5)+	;Yes, set up the MMU address		;039
	BR	30$		;And skip phase skip code		;039

20$:	TST	(R0)+		;Phase not to be loaded, skip MMU address ;044
	DEC	R2		;Get the next non-loaded special value	;044
	MOV	R2,(R5)+	;Set up the special not-loaded value	;044
30$:	MOV	@(R0)+,(R5)+	;Set up the value to jam into		;044
	CMP	R0,#50$		;Done yet?				;039
	BNE	10$		;No, so loop				;039
	RETURN			;Yes, all set				;039

40$:				;Set up phase jamming table		;039
	PHZDEF	CRA		;Jam CRASH phase			;039
	PHZDEF	TER,TERAP6	;Jam TER phase				;059
	PHZDEF	FIP,FIPAP6	;Jam FIP phase				;039
	PHZDEF	SES		;Jam SES phase				;039
	PHZDEF	NSP		;Jam NSP phase				;039
	PHZDEF	TRN		;Jam TRN phase				;039
	PHZDEF	EVL		;Jam EVL phase				;043
	PHZDEF	RDM		;Jam RDM phase				;044

	PHZDEF	DZP,DJPAP5	;Jam DZPORT phase for DJ support	;059
	PHZDEF	DHP,DHPAP5	;Jam DHPORT phase for DH support	;059
	PHZDEF	DZP,DZPAP5	;Jam DZPORT phase for DZ support	;059
	PHZDEF	VHP,VHPAP5	;Jam VHPORT phase for DHU/DHV support	;059
	PHZDEF	FMS		;Jam FMS phase for FMS support		;059
	PHZDEF	LAT		;Jam LAT phase for LAT support		;065

	PHZDEF	KBX,APTAP5	;Jam KBX phase for APT support		;072

	PHZDEF	NOD,NODAP5	;Jam NOD phase for async DDCMP support	;065
	PHZDEF	UNA,XEDAP5	;Jam UNA phase				;040
	PHZDEF	QNA,XHDAP5	;Jam QNA phase				;040

	PHZDEF	GPK		;Jam GPK phase				;056
	PHZDEF	PTB,PTBAP6	;Jam GPK tables phase			;056
50$:				;End of table

.SBTTL	JAMJCR	Set up job control region

;+
; JAMJCR - Set up job control region
;
;	D.LB+LBJCRP = MMU address of JCR
;	D.JCRS = Size of JCR entry, in bytes                                
;
;-

JAMJCR:	CALLX	JAMBY2		;We jam pairs				;054
	MOV	D.LB+LBJCRP,(R5)+ ;Set address of job control region	;054
	MOV	.$JCR6,(R5)+	;Which will be stored in $$JCR6		;054
	MOV	D.JCRS,(R5)+	;Set up size of a JCR entry in words	;054
	MOV	JCRSIZ,(R5)+	;Which will be stored at JCRSIZ		;054

; Note: At present, the only optional JCR entry is the additional MDEs
; used on systems with I&D space. MAPSUB.MAC and SCH.MAC assume that
; these entries are at the start of the JCR optional section (and
; that they follow JCMDE, which must always be at the end of the
; JCR fixed section). Any additional JCR optional entries must account
; for these MDEs.                                                           

	RETURN			;All done for now			;054


.SBTTL	JUMRXE -- Jam to block UMR$XE

;+								      +;040
; JUMRXE --
;	There are no UNA's out there on this system.
;	We jam a RETURN over the JMP instruction at
;	UMR$XE so that UMR freed up won't try to get to
;	a phase that doesn't exist.
;-								     -;040

JUMRXE:	CALLX	JAMBY2		; We just jam a pair.			;040
	MOV	#207,(R5)+	; A RETURN gets jammed			;040
	MOV	UMR$XE,(R5)+	; in at the UMR entry point in XEDINT	;040
	RETURN			; That's all				;040

GLOBAL	<UMR$XE>							;040
                                                                        


.SBTTL	SET UP CSR AND VECTOR ASSIGNMENTS FOR DEVICES

.ENABL	LSB

JAMDVC:	CLR	BAEUWN		;CLEAR FLAG BITS FOR BAE, UNIBUS WINDOW 
	CLR	TOTDSA		;CLEAR THE TOTAL DISABLED COUNT
	MOV	#UWNLST,UWNPTR	;INITIALIZE UNIBUS WINDOW POINTER
	MOV	#31.-7.,UWNCNT	;SET NUMBER OF FREE UNIBUS WINDOWS
	CALLX	JAMBY2		;WE GENERATE PAIRS
	MOV	#SATBUF+DS.NCS,R4 ;R4 -> DEVICE STATUS @ # OF CSR'S
10$:	MOVB	(R4)+,R3	;R3 = NUMBER OF CSR'S TO JAM
	MOVB	(R4)+,R1	;R1 = PACKET NUMBER IN INIT'S TABLES    
	MUL	#PKTSIZ,R1	;R1 = PACKET OFFSET
	ADD	#DEVTBL,R1	;R1 -> PACKET FOR THIS DEVICE
	MOVB	(R4)+,R2	;R2 = CONTROLLER NUMBER
	MOV	R2,PS0123	;NORMALLY, PS BITS 0-3 = CONTROLLER INDEX
20$:	CMPB	DS.DVN-DS.CSR(R4),IIDRVR ;IS THIS AN II DRIVER PACKET?
	BNE	30$		;NOPE, LEAVE ALONE
	ADD	IIOFF,R2	;II DRIVER AND RJ SHARE DUP11'S, YUCK.  
30$:	ASL	R2		; *2
	ADD	PK.CSO(R1),R2	;R2 = OFFSET INTO CSRTBL OF CONTROLLER
	MOV	CSRTBL(R2),(R5)	;Get CSR address into jam list.		;073
	BEQ	170$		;OOPS, NO DEVICE THERE
	TSTB	FLGQBU		;IS THIS A Q-bus SYSTEM?
	BMI	60$		;NO, DON'T WORRY ABOUT THE DEVICE
	CALL	CHKQ22		;YES, SO DO Q-BUS CHECKING
	BCS	170$		; ILLEGAL ON Q-BUS, DISABLE THE THING
60$:	CMP	PK.NAM(R1),#"TC	;IS IT DECTAPE?
	BNE	70$		;NO, ENABLE IT                          
	TST	DTAFLG		;YES, IS BUFF.SYS OK?
	BEQ	170$		;NOPE, DISABLE THE THING
70$:	CMP	PK.NAM(R1),#"XD	;IS IT A DMP/DMV?
	BNE	80$		;NO, CONTINUE
	CALL	DMVCHK		;YES, CHECK FOR TO MANY LINES, (IF IT'S A DMV)
80$:	MOVB	PK.OFF(R1),R0	;GET OFFSET TO MAIN REGISTER
	ADD	R0,(R5)+	;ADD TO CSR ADDRESS IN LIST             
	MOV	(R4)+,(R5)+	;PLACE TO JAM THE CSR IS FROM DS.CSR
	CMP	PK.NAM(R1),#"PI	;Is this the GPK display?		;056
	BNE	100$		;No, go jam CSRs			;056
	CMP	R0,#175400	;Yes, but of the GPK-380 flavor?	;056
	BEQ	100$		;Yes					;056
;;; TBD: disable extra units if -350 display controller			;056
	BR	100$		;**temp**				;056

90$:	MOV	-4(R5),(R5)+	;JAM ANOTHER COPY OF THE SAME CSR
	MOV	-4(R5),(R5)	;INTO THE SAME ADDRESS
	ADD	#2,(R5)+	; +2
100$:	SOB	R3,90$		;LOOP FOR EACH DEVICE
110$:	MOV	(R4)+,R0	;Get interrupt entry from packet	;056
	CALL	BLDVEC		;Build the vector(s)			;059
120$:	TST	(R4)+		;ADVANCE OVER NEXT DEVICE DVN AND UNT
	TSTB	(R4)+		;HOW MANY UNITS CONTROLLED?
	BNE	160$		;IF NON-0, DO ANOTHER CONTROLLER	;055
	TSTB	AUTOGO		;Doing streamline startup?		;011
	BNE	140$		;Yes, so never a message		;011
	MOV	TOTDSA,R0	;R0 = NUMBER OF UNITS DISABLED
	BEQ	140$		;NONE, GO TO SET UP THE CACHE
	CALLX	TYPECR		;ON A NEW LINE
	CALLX	DECZER		;PRINT THE TOTAL
	MESSAG	<" device">
	DEC	R0		;IS THERE ONLY ONE?
	BEQ	130$		;YES
	MESSAG	<"s">
130$:	MESSAG	<" disabled"<200><12>>
140$:	TSTB	FLGGPK		;Is this a GPK?				;055
	BPL	150$		;No, skip				;055
	MOV	#LK.PKT,R1	;Point to keyboard packet		;056
	MOV	PK.CSO(R1),R2	;Get CSRTBL/VECTBL offset		;056
	MOV	CSRTBL(R2),(R5)+ ;Jam the CSR				;056
	MOV	.CSR.LK,(R5)+	; at this address			;056
	MOV	.VEC.LK,R0	;Pick up interrupt entry address	;056
	CALL	BLDVEC		;Jam the vector				;059
	MOV	MONLOW+100,MONLOW+230 ;Copy clock vector for GPK clock	;059
	MOV	MONLOW+102,MONLOW+232 ; and PS value			;059
150$:	RETURN								;055
                
160$:	JMP	10$							;055
170$:	CMP	PK.NAM(R1),#"DU	;IS THIS A DU11?
	BEQ	180$		;YES, TRY FOR A DUP11 INSTEAD
	CMP	PK.NAM(R1),#"XE	; is this a DEUNA/DELUA?		;045
	BEQ	190$		; Yes, don't disable in the usual way	;045
	CMP	PK.NAM(R1),#"XH	; is this a DEQNA/DELQA?		;053
	BEQ	190$		; Yes, don't disable in the usual way	;053
	CMP	PK.NAM(R1),#"NO	;Is this the Async DDCMP device?	;079
	BEQ	200$		;No, continue with other devices	;079
	CALL	DSABLD		;DISABLE DEVICE (R4 -> DS @ DS.CSR)
	BR	120$		;RETURNS W/ R4 -> NEXT DS

180$:	CLR	R2		;SET TO OFFSET 0 TO TRY DUP UNIT 0
	ADD	#PKTSIZ,R1	;FUDGE TO THE DUP11 DEVICE PACKET
	JMP	20$		;AND TRY THAT ONE                           

190$:	CALL	DSAETH		; so disable this ethernet controller	;045
	BR	120$		; print no messages, leave no trail.	;045
				; point to FAKDDB to for returned SMLBUF;045
				; return with R4 -> next DS		;045

200$:	TST	D.LB+LBNODL	;Is the NO driver loaded?		;079
	BLE	190$		;No, so disable				;079
	ADD	#<DS.XXX-DS.CSR>,R4	; advance to start of next Desc ;079
	BR	120$		;Try the next device			;079
                                                                       
.DSABL	LSB
                                
GLOBAL	<SATBUF,DEVTBL,DEVOKB,CSRTBL,VECTBL,IIDRVR,DTAFLG,D.LB>		;079
GLOBAL	<AUTOGO,LK.PKT,.CSR.LK,.VEC.LK,MONLOW>				;059

.SBTTL	JAMKB	Jam keyboard data structures
                                                                        
;+
; JAMKB - Jam keyboard data structures
;
; This routine is used to set up the keyboard data structures. We:
;
;	1. Calculate DDB extension for FMS
;	2. Create DDBs and include in DEV.KB                            
;	3. Load CSR table for keyboards
;	4. Set up UCT table for DDCU style names
;	5. Set up Base KB # tables for multiplexors
;	6. Set up interrupt service routine for each controller
;
; Note: We will create as many keyboards as possible up to the limit	;076
;	of 128. This means that only some lines of a controller may	;076
;	be enabled rather than INIT giving the user a fatal error as	;076
;	it did in V9.6.							;076
;-                                                                      

JAMKB:	MOV	#KBCTXS,R0	;Point to context area			;059
10$:	CLR	(R0)+		;Clear out a word			;059
	CMP	R0,#KBCTXE	;At end of context area?		;059
	BNE	10$		;No, loop for the whole thing		;059

; The first thing that we'll do is set up the FMS DDB extension if necessary
                                
	MOV	#KBDDBS,R0	;Get standard keyboard DDB size		;059
	TST	D.LB+LBFMSL	;Using FMS?				;059
	BEQ	12$		;No, not this time			;072
	INC	DDBXKB		;Yes, extend the DDB by a word		;068
	CALLX	JAMBY2		;And set up to jam pairs		;059
	MOV	R0,(R5)+	;Set FMS DDB offset			;059
	MOV	TTFMSB,(R5)+	;And store it in TTFMSB			;059
	ADD	#1*2,R0		;Now update DDB size for next thing	;068

; The next thing that we'll do is set up the NODVR or APT DDB extension
; if necessary.

12$:	TST	D.LB+LBNODL	;Using Async DDCMP?			;065
	BNE	15$		;Yes, go extend the DDB.		;072
	TST	D.LB+LBKBXL	;How about APT support?			;072
	BEQ	17$		;No, nothing to do.			;072
15$:	ADD	#5,DDBXKB	;Yes, extend the DDB by five words.	;072
	CALLX	JAMBY2		;And set up to jam pairs		;065
	MOV	R0,(R5)+	;Set NODVR DDB offset			;065
	MOV	TTAUXB,(R5)+	;And store it in TTAUXB			;065
	ADD	#5*2,R0		;Now update DDB size for next thing	;072

; We've extended the DDB, now we'll jam the DDB size for the monitor
; to use

17$:	MOV	DDBXKB,(R5)+	;Set size of KB DDB extension		;066
	MOV	KBDDBX,(R5)+	;Now set the address in the monitor	;059

; Now we'll perform the per-controller processing

20$:	MOV	#KBTBL,R4	;Point to keyboard controller table	;059
30$:	CMP	R4,#PKPKT	;Is this the funny PK packet?		;059
	BNE	40$		;No, not this time			;059
	CALL	CPKDDB		;Yes, create the PK DDBs		;059
	BCS	45$		;Max of 128 reached if C set		;076
40$:	MOV	(R4)+,R1	;Get next packet pointer		;059
	BNE	50$		;Got one, good				;059
45$:	CALLX	JAMBY2		;Setup to jam pairs			;076
	MOV	KBCNT,(R5)	;Store Next KB#*1			;066
	ASL	(R5)+		;Then make it *2			;066
	MOV	DYNKBN,(R5)+	;Set addr of Dyn KB start number	;066
	JMP	CKBUCT		;Done, do final jamming now		;059

50$:	MOV	PK.CSO(R1),R2	;Get the table offset value		;059
	MOVB	(R1),-(SP)	;Get the number of units		;059
.ASSUME	PK.MXU	EQ	0
	CLR	PS0123		;Initialize PSW mask for controller	;059
60$:	MOV	CSRTBL(R2),R3	;Get CSR pointer			;059
	BEQ	100$		;None, skip it				;059
	MOV	(R4)+,R0	;Get address of keyboard number start table ;059
	BEQ	70$		;None, just skip it			;059
	INCB	(R0)+		;Got one, count another controller	;059
	ADD	PS0123,R0	;And point to correct controller slot	;059
	MOVB	KBCNT,(R0)	;Set the controller's start KB number	;059
	ASLB	(R0)		;Now make that KB # * 2			;059
70$:	MOV	@(R4)+,R0	;And get vector address			;059
	CMP	R0,DLKINT	;Is this a single line interface?	;059
	BNE	80$		;No, not this time			;059
	MOV	KBCNT,PS0123	;Yes, set vector based on KB number	;059
	CMP	PS0123,#17	;Should this go to the first vector?	;059
	BLOS	80$		;Yes, all set				;059
	ADD	#20,R0		;Second vector, set it up		;059
	SUB	#20,PS0123	;And update the PSW			;059
	CMP	PS0123,#17	;Will this fit in the second vector?	;059
	BHI	110$		;No, give an error			;059
80$:	CALL	BLDVEC		;Build the vector for the controller	;059
	INC	PS0123		;Now update vector PSW for next time	;059
	MOVB	PK.NUN(R1),R0	;Get number of units per controller	;059
	BIT	#1,TYPTBL(R2)	;Is this a "small" controller?		;059
	BEQ	90$		;No, not this time			;059
	ASR	R0		;Yes, update the count			;059
90$:	TST	(R4)+		;R4 -> KB descriptor entry @ Interface type ;076
	CALL	CKBDDB		;Create the DDBs			;059
	ROR	-(SP)		;Preserve our limit reached flag (C bit) ;076
	ADD	KBCTRL,@-(R4)	;Add in the number of lines created	;076
	CLR	KBCTRL		;Reinitialize the KB/Controller counter	;076
	TST	(SP)+		;Max of 128 reached?			;076
	BPL	95$		;No, keep on going			;076
	TST	(SP)+		;Yes, dump controller counter		;076
	BR	45$		; and go finish up			;076

95$:	SUB	#4,R4		;Point to start of descriptor		;076
100$:	TST	(R2)+		;Update the CSRTBL table offset		;059
	DECB	(SP)		;Indicate we did one more controller	;059
	BNE	60$		;More to do, loop for all controllers	;059
	TST	(SP)+		;Done, dump counter			;059
	ADD	#6+6,R4		;Point to next device descriptor	;059
	BR	30$		;And loop				;059
                                                                      
110$:	MESSAG	<"Too many single line interfaces">			;059
TOOMKB:	MESSAG	<" on system - please disable some"<200>>		;059
	EXIT			;Now exit				;059

GLOBAL	<TTFMSB,KBDDBX,TYPTBL,DEV.KB,CSR.KB,UCT.KB,TTAUXB>		;065

                 
.SBTTL	CPKDDB	Create pseudo keyboard DDBs

;+
; CPKDDB - Create pseudo keyboard DDBs
;                           
; Inputs:								;076
;									;076
;	R4 -> Keyboard description entry @ interface type code
;									;076
;	CALL	CPKDDB							;076
;									;076
; Outputs:								;076
;									;076
;	R4 -> Unchanged							;076
;									;076
;	C = 0 All requested PKs successfully created			;076
;	C = 1 Max # of 128 KBs reached not all PKs could be created	;076
;-

.ENABL	LSB

CPKDDB:	MOVB	CFGBUF+CFG$PK,R0;Is there a specified number?		;073
	BEQ	10$		;No, not this time			;059
	BPL	20$		;Yes, and it is in range		;059
	MESSAG	<"CONFIG.SYS value for pseudo keyboards greater than 127. "> ;076
	MESSAG	<" - using default"<200>>				;076
10$:	MOV	#1,R0		;Default to one pseudo keyboard		;059
20$:	MOV	KBCNT,R1	;Get current count of KBs created	;076
	ADD	R0,R1		;Add in the number of PKs requested	;076
	CMP	R1,#128.	;Too many keyboards?			;076
	BLE	25$		;No, good no adjustments needed		;076
	MOV	#128.,R0	;R0 = Max. number of KBs possible	;076
	SUB	KBCNT,R0	;R0 = Number of PKs we can create	;076
	MESSAG	<"Cannot create all requested pseudo keyboards - creating "> ;076
	CALLX	DECZER		;Tell the user how many we'll give him	;076
	MESSAG	<" PKs"<200>>						;076
25$:	MOV	R0,CNT.PK	;Save the count for UCT setup		;059
	MOV	R0,R1		;Get count in a safe place		;059
	CALL	GETBUF		;Now allocate it			;059
	MOV	R0,R2		;Get DDB vector pointer in a safe place	;059
	CALLX	JAMBY2		;Get ready to jam it			;059
	MOV	R0,(R5)+	;Jam the DDB vector			;059
	MOV	DEVPTR,(R5)	;Into the DDB pointer table		;059
	ADD	DEVOKB,(R5)	;Get offset past all disk devices	;059
	ADD	#IDX.PK-IDX.KB,(R5)+ ;Now point to IDX.PK		;059
	MOV	R1,(R5)		;Set up to jam maximum unit number	;059
	DEC	(R5)+		; ...					;059
	MOV	DEVCNT,(R5)	;Into the device count table		;059
	ADD	DEVOKB,(R5)	;Past all disk devices			;059
	ADD	#IDX.PK-IDX.KB,(R5)+ ;Now point to IDX.PK		;059

; Now allocate all the DDBs
;
; R2 -> PK DDB pointer table
; R4 -> Keyboard description packet

	CLR	R1		;Start off with PK0:			;059
30$:	MOV	#PKDSIZ/2,R0	;Get size of PK DDB			;059
	CALL	GETBUF		;Now allocate the space			;059
	CALLX	JAMBY2		;Set up to jam the pointer		;059
	MOV	R0,(R5)+	;Set the DDB pointer			;059
	MOV	R2,(R5)+	;And move it into the table		;059
	TST	(R2)+		;Update table pointer for next time	;059
	MOV	R0,R3		;Set up pseudo CSR pointer		;059
	CALLX	JAMBYN		;Set up to jam the DDB contents		;059
	MOV	#PKDSIZ/2,(R5)+	;Jam the entire DDB			;059
	MOV	R0,(R5)+	;Starting at the DDB address		;059
	MOV	#IDX.PK,(R5)+	;Set up DDIDX and DDSTS			;059
.ASSUME	DDIDX	EQ	0
.ASSUME	DDSTS	EQ	DDIDX+1
	CLRB	(R5)+		;Clear DDJBNO				;059
.ASSUME	DDJBNO	EQ	DDSTS+1
	MOVB	R1,(R5)+	;Set up unit number			;059
.ASSUME	DDUNT	EQ	DDJBNO+1
	CLR	(R5)+		;Clear out DDTIME			;059
.ASSUME	DDTIME	EQ	DDUNT+1
	CLR	(R5)+		;Clear out DDCNT			;059
.ASSUME	DDCNT	EQ	DDTIME+2
	MOVB	KBCNT,(R5)	;Set up corresponding KB number		;059
.ASSUME	DDFLAG	EQ	DDCNT+2
	ASLB	(R5)+		;And make it times two			;059
	CLRB	(R5)+		;High byte of DDFLAG is reserved	;059
	CLR	(R5)+		;Clear PKMODE and PKINWT		;059
.ASSUME	PKMODE	EQ	DDFLAG+2
.ASSUME	PKINWT	EQ	PKMODE+1
.ASSUME	PKDSIZ	EQ	PKINWT+1
	MOV	#1,R0		;Only one PK subline please		;059
	CALL	CKBDDB		;Create the keyboard DDB		;059
	INC	R1		;Advance to next PK number		;059
	CMPB	R1,CNT.PK	;Have we done all the PKs yet?		;059
	BLO	30$		;No, loop				;059
	ADD	#6,R4		;Yes, point to next packet		;059
	CLR	KBCTRL		;Clear lines/controller counter		;076
	TSTB	KBCNT		;Reached our max of 128.? (C=0)		;076
	BPL	40$		;No, good no problems			;076
	SEC			;Yes, flag it for our caller		;076
40$:	RETURN			;And we're done				;076
                              
.DSABL	LSB

GLOBAL	<DEVPTR,DEVOKB,DEVCNT,CFGBUF>					;073

.SBTTL	CKBDDB	Create keyboard DDBs

;+
; CKBDDB - Create keyboard DDBs
;
;	R0 =  Number of sublines to create
;	R3 =  CSR pointer
;	R4 -> Keyboard description entry @ interface type code
;	R5 -> Jam list
;	KBCNT = Unit number to start at
; 
;	CALL	CKBDDB
;
;	R0 =  Undefined  
;	R4 -> Unchanged							;076
;
;	C = 0 All sublines created					;076
;	C = 1 Max. number of 128. Keyboards reached. See KBCTRL for	;076
;	      number of lines successfully created.			;076
;
;	KBCNT contains last keyboard created + 1
;	KBCTRL contains number of sublines created for this controller	;076
;-

CKBDDB:	MOV	R0,-(SP)	;Save the unit count			;059
	CLR	-(SP)		;And initialize subline counter		;059
10$:	MOVB	KBCNT,R0	;Get current keyboard number		;059
	BMI	60$		;Too big, forget startup		;059
	ASL	R0		;Now get keyboard number times two	;059
	CALLX	JAMBY2		;Set up to jam pairs			;059
	MOV	R3,(R5)+	;Jam CSR pointer			;059
	MOV	CSR.KB,(R5)	;Into the CSR.KB table entry		;059
	ADD	R0,(R5)+	;For this unit				;059
	MOV	R0,-(SP)	;Save unit number times two		;059
	MOV	#KBDDBS/2,R0	;Get size of keyboard DDB in words	;059
	ADD	DDBXKB,R0	;Add in the DDB extension		;059
	CALL	GETBUF		;Now allocate that much space		;059
	MOV	R0,(R5)+	;Jam the address			;059
	MOV	DEV.KB,(R5)	;Into the DEV.KB table entry		;059
	ADD	(SP)+,(R5)+	;For this unit				;059
	CALLX	JAMBYN		;Set up to jam the entire DDB		;059
	MOV	#KBDDBS/2,(R5)	;Set size of keyboard DDB in words	;059
	ADD	DDBXKB,(R5)+	;Including DDB extension		;059
	MOV	R0,(R5)+	;And set the address of the buffer	;059
	MOV	#KBTMPS,R0	;Point to the template DDB		;059
	MOV	R5,-(SP)	;Save DDB starting address in jam list	;059
20$:	MOV	(R0)+,(R5)+	;Copy a template word to the jam list	;059
	CMP	R0,#KBTMPE	;Up to the end of the template?		;059
	BNE	20$		;No, loop				;059
	MOV	DDBXKB,R0	;Get size of DDB extension		;059
	BEQ	40$		;None, nothing to zero			;059
30$:	CLR	(R5)+		;Clear out a word of the extension	;059
	SOB	R0,30$		;Loop for the entire DDB extension	;059
40$:	MOV	(SP)+,R0	;Restore DDB starting address		;059
	MOVB	KBCNT,DDUNT(R0)	;Set unit number in DDB			;059
	MOV	(R4)+,TTINTF(R0) ;Set interface type code		;059
	BISB	(SP),TTINTF+1(R0) ;And set the subline number		;059
	MOV	(R4)+,TTPARM(R0) ;Set the parameter word		;059
	CMPB	#TTDZ11,TTINTF(R0) ;Is this a DZ-11?			;059
	BNE	50$		;No, not this time			;059
	BISB	(SP),TTPARM(R0)	;Yes, include subline number in TTPARM	;059
50$:	CMPB	#TTPK11,TTINTF(R0) ;Is it a PK device?			;064
	BNE	55$		;No, so do regular stuff		;064
	MOVB	#1,DDJBNO(R0)	;Set device 'in use'			;064
	MOV	#TTDSBL,MODCLK(R0) ;And disable it			;064
55$:	MOV	TTPARM(R0),TTRING(R0) ;Set the permanent parameter word	;064
	BIS	(R4),TTCTRL(R0) ;Set extra control functions		;059
	BIS	(R4)+,TTRING+10(R0) ;And the permanent version		;059
	SUB	#6,R4		;Now update pointer for next time	;059
	INC	(SP)		;Indicate we did one more unit		;059
	INCB	KBCNT		;Account for another unit		;059
	INC	KBCTRL		;One more for this controller too	;076
	CMP	(SP),2(SP)	;More to do?				;059
	BNE	10$		;Yes, loop				;059
	TST	(PC)+		;Let caller know all units created	;076
	;CLC
60$:	SEC			;Indicate unable to create all units	;076
	BIT	(SP)+,(SP)+	;Dump counters (C not changed)		;076
	RETURN			;And we're done				;059


.SBTTL	CKBUCT	Create keyboard UCT entries

;+                                                                      
; CKBUCT - Create keyboard UCT entries
;
; This routine is called as the final part of keyboard DDB creation.
; At this point, all the DDBs have been created and CSRTBL has been jammed
; into the monitor. All that is left is for us to jam UCTTBL and the
; multiplexor base KB number tables.          
;-                                                                      

CKBUCT:	MOV	#128.,CNT.LT	;Compute CNT.LT (# of available dyn KBs);082
	SUB	KBCNT,CNT.LT	; as 128. - <maximum KB number used>	;082
	MOV	#KBUCT,R0	;Get the word count			;059
	MOV	#CNT.KL,R1	;Point to the start of the table	;059
	CALLX	JAMBYN		;We jam large areas here		;059
	MOV	R0,(R5)+	;Jam the entire UCT area		;059
	MOV	UCT.KB,(R5)+	;Into UCT.KB in the monitor		;059
10$:	MOV	(R1)+,(R5)+	;Copy a word into the jam list		;059
	SOB	R0,10$		;For the whole thing			;059
	MOV	#BASEKB-2,R1	;Point to the base KB setup table	;059
20$:	TST	(R1)+		;Point to entry for next unit		;059
30$:	MOV	(R1)+,R2	;Get pointer to controller count	;059
	BEQ	50$		;Not there, we're done			;059
	MOVB	(R2)+,R3	;Any of this type of controller?	;059
	BEQ	20$		;No, skip to the next one		;059
	MOV	R3,R0		;Yes, get ready to get some table space	;059
	CALL	GETBUF		;Now allocate that space for the table	;059
	CALLX	JAMBY2		;Set up to jam two words		;059
	MOV	R0,(R5)+	;Jam the table address			;059
	MOV	@(R1)+,(R5)+	;Into the table in the monitor		;059
	CALLX	JAMBYN		;Now load the table itself		;059
	MOV	R3,(R5)+	;Set up the table length		;059
	MOV	R0,(R5)+	;And the table address			;059
40$:	MOVB	(R2)+,(R5)+	;Set the keyboard number in the jam list ;059
	CLRB	(R5)+		;And clear the high byte out		;059
	SOB	R3,40$		;Now loop for the whole thing		;059
	BR	30$		;And loop for all controllers		;059

50$:	.CALLR	JAMDMB		;Finish up by setting up DM11BBs	;059


.SBTTL	JAMDMB	Jam DM11BB setup
                  
;+
; JAMDMB - Jam DM11BB table
;
; This routine jams DM11BB information if there are any DM11BBs		;076
; associated with DH11s. It creates a table of one word entries for	;076
; each DH11 line. Each entry will contain the CSR address of the	;076
; associated DM11BB or zero. The table is accessed by using the	the	;076
; address stored at the location pointed to by the symbol CSR.BB along	;076
; with the keyboard number times two. Because the table is accessed by	;076
; KB number times two, the location of the table is offset by the	;076
; number of keyboards times two that precede the first DH11 keyboard.	;076
; The table looks like this in memory:					;076
;									;076
;	CSR.BB ->+---------------------+				;076
;	         |                     |				;076
;	         |      Random         |				;076
;	         |                     |				;076
;	         |                     |				;076
;		 +---------------------+				;076
;		 | Addrs of DM11BB CSR | KB# * 2 1st subline DH0	;076
;		 +---------------------+				;076
;		 | Addrs of DM11BB CSR | KB# * 2 2nd subline DH0	;076
;		 +---------------------+				;076
;		 | Addrs of DM11BB CSR | KB# * 2 nth subline DH0	;076
;		 +---------------------+				;076
;		 |         :           |				;076
;		 |         :           |				;076
;-

JAMDMB:	MOV	CNT.DH,-(SP)	;Get number of DH units			;076
	BEQ	90$		;None, nothing to do			;076
	MOV	#DH.CSO,R1	;Get per-controller table offset	;059
	CLR	R2		;And initialize controller counter	;059
	CLR	PS0123		;Set up PSW mask			;059
10$:	TST	CSRTBL(R1)	;Is there a DH11 here?			;059
	BEQ	80$		;No, not this time			;059
	MOV	#DM.CSO,R3	;Yes, get DM11BB table offset		;059
20$:	TST	CSRTBL(R3)	;Does this DM11-BB exist?		;067
	BEQ	25$		;No, so don't even check it		;067
	CMPB	TYPTBL(R3),R2	;Is this the DM11BB for this DH?	;059
	BEQ	30$		;Yes, go set it up			;059
25$:	TST	(R3)+		;No, advance to next DM11BB		;067
	CMP	R3,#DM.CSO+<16.*2> ;Done all possible DM11BBs?		;059
	BLO	20$		;No, loop				;078
	CALL	100$		;No modem support, update our counter	;076
	BR	70$		;  and skip this DH			;076

30$:	TST	DMBTBL		;Do we have a DM11BB table?		;059
	BNE	50$		;Yes, don't get another one		;059
	MOVB	CNT.DH,R0	;Don't have one, get count of DH11s	;059
	CALL	GETBUF		;Now allocate the space			;059
	MOV	R0,-(SP)	;Save the actual buffer start address	;059
	CLR	R4		;Clear register				;076
	BISB	DHCTL+1,R4	; and get base DH keyboard number * 2	;076
	SUB	R4,R0		;And bias the DM11BB table pointer	;059
	MOV	R0,DMBTBL	;Save the table address for later	;059
	CALLX	JAMBY2		;Set up to jam pairs			;059
	MOV	R0,(R5)+ 	;Load DM11BB table address		;059
	MOV	CSR.BB,(R5)+	;Into CSR.BB				;059
	MOVB	CNT.DH,R0	;Get count of DH11s again		;059
	CALLX	JAMBYN		;Now set up to zero the table		;059
	MOV	R0,(R5)+	;Set up the table length		;059
	MOV	(SP)+,(R5)+	;And the table address			;059
40$:	CLR	(R5)+		;Clear out the table			;059
	SOB	R0,40$		; ...					;059
50$:	MOV	PS0123,R4	;Get DH controller number		;059
	CLR	R0		;Set up to get vector			;059
	BISB	VECTBL(R3),R0	;R0 = Vector address for DM11BB		;059
	ASL	R0		;Unhalved				;059
	ADD	#MONLOW,R0	;R0 -> Vector in low core prototype    	;059
	MOV	DMKINT,(R0)+	;Set up DM11BB interrupt service address ;059
	MOV	#PR5&4340,(R0)	;And interrupt at PR5			;059
	BIS	R4,(R0)		;And set the controller number		;059
	CLR	R0		;Clear register				;076
	BISB	DHCTL+1(R4),R0	; and get base keyboard number for this mux ;076
	MOV	R0,R4		;Get it in the right register		;076
	CALL	100$		;Get the number of units for this DH	;076
	CALLX	JAMBYN		;Set up to jam DM11BB CSR table		;059
	MOV	R0,(R5)+	;Jam all units on the mux		;059
	MOV	DMBTBL,(R5)	;Starting at the DM11BB table 		;059
	ADD	R4,(R5)+	;Offsetting for this unit		;059
60$:	MOV	CSRTBL(R3),(R5)+ ;Jam the CSR pointer			;059
	SOB	R0,60$		;Loop for all units			;059
70$:	INC	PS0123		;Set up PSW mask for next time		;059
80$:	INC	R2		;Count one more controller		;059
	TST	(R1)+		;And point to next DH entry		;059
	TST	(SP)		;More units to do?			;076
	BNE	10$		;Yes, loop				;076
90$:	TST	(SP)+		;No, dump the counter			;076
	RETURN			; and exit this routine			;076

;+									;076
; Inputs:								;076
;	SP -> Return address						;076
;	   +2 Units counter						;076
;									;076
; Outputs:								;076
;	R0 =  # units on this DH to create entries for			;076
;	SP -> Return address						;076
;	   +2 Updated units counter					;076
;-

100$:	MOV	#16.,R0		;Assume the full 16. units		;076
	CMP	R0,2(SP)	;Room for all of them?			;076
	BLE	110$		;Yes, good do that many			;076
	MOV	2(SP),R0	;No, do as many as we can		;076
110$:	SUB	R0,2(SP)	;Update our count			;076
	RETURN			; and return to our caller		;076

GLOBAL	<DH.CSO,DM.CSO,MONLOW,CSR.BB,DMKINT>				;059

.SBTTL	Data structures for keyboard creation
        
	TMPORG	STACTL                                                  

KBTBL:

; First, set up the data structures for each interface type

	KBTYPE	TT,,DLKINT,CNT.KL,TTKL11,0,0
	KBTYPE	KL,,DLKINT,CNT.KL,TTKL11,0,0
	KBTYPE	DL,,DLKINT,CNT.DL,TTDL11,0,0
	KBTYPE	DE,,DLKINT,CNT.DE,TTDE11,0,0
	KBTYPE	PK,,,,TTPK11,0,0
	KBTYPE	DJ,DJCTL,DJKINT,CNT.DJ,TTDJ11!TTMUX,0,0
	KBTYPE	DH,DHCTL,DHKINT,CNT.DH,TTDH11!TTMUX!TTHPRT,33503,TTAUTO
	KBTYPE	DZ,DZCTL,DZKINT,CNT.DZ,TTDZ11!TTMUX!TTHPRT,17030,TTAUTO
	KBTYPE	VH,VHCTL,VHKINT,CNT.VH,TTVH11!TTMUX!TTHPRT,156430,TTAUTO
	KBTYPE	END     
                
; Now, set up the table which we use to jam base kb numbers

BASEKB:	.WORD	DHCTL,DHKBN	;Pointer to jam DH controllers		;059
	.WORD	DJCTL,DJKBN	;Pointer to jam DJ controllers		;059
	.WORD	DZCTL,DZKBN	;Pointer to jam DZ controllers		;059
	.WORD	VHCTL,VHKBN	;Pointer to jam VH controllers		;059
	.WORD	0		;End of table				;059

; This context area is filled in using information in packets and in the
; KBTYPE table above  

KBCTXS:				;Start of keyboard context area		;059
KBCTRL:	.BLKW			;# of KBs for this controller		;076
KBCNT:	.BLKW			;Contains KB number being worked on	;059
DHCTL:	.BLKB			;Count of DH-11 controllers		;059
	.BLKB	16.		;Keyboard number * 2 for each DH-11	;059
DJCTL:	.BLKB			;Count of DJ-11 controllers		;059
	.BLKB	16.		;Keyboard number * 2 for each DJ-11	;059
DZCTL:	.BLKB			;Count of DZ-11 controllers		;059
	.BLKB	16.		;Keyboard number * 2 for each DZ-11	;059
VHCTL:	.BLKB			;Count of DHV-11/DHU-11 controllers	;059
	.BLKB	16.		;Keyboard number * 2 for each DHV-11/DHU-11 ;059

; Note: The order of entries below must match the order of entries in
; UCT.KB within the monitor.

CNT.KL:	.BLKW			;Count of KL-11 type interfaces filled in ;059
CNT.DL:	.BLKW			;Count of DL-11 type interfaces filled in ;059
CNT.DE:	.BLKW			;Count of DE-11 type interfaces filled in ;059
CNT.PK:	.BLKW			;Count of pseudo keyboards filled in	;059
CNT.DJ:	.BLKW			;Count of DJ-11 type interfaces filled in ;059
CNT.DH:	.BLKW			;Count of DH-11 type interfaces filled in ;059
CNT.DZ:	.BLKW			;Count of DZ-11 type interfaces filled in ;059
CNT.VH:	.BLKW			;Count of DHU-11/DHV11 type interfaces filled in ;059
CNT.LT:	.BLKW			;Count of dynamic keyboards available.	;082
KBUCT	=:	<<.-CNT.KL>/2>	;Number of words to jam into UCT.KB

DDBXKB:	.BLKW			;Size of DDB extension in words		;059
DMBTBL:	.BLKW			;DM11BB CSR pointer table address	;059
                  
; End of ordered section

KBCTXE:				;End of context area			;059

; Now define the template DDB                    
                        
KBTMPS:				;Start of template DDB			;059
	DDBDEF	TEMPLATE	;Invoke the template DDB		;059
KBTMPE:				;End of template DDB			;059
                
GLOBAL	<DHKBN,DJKBN,DZKBN,VHKBN>					;059

	UNORG

.SBTTL	BLDVEC	Build a vector for a device

;+
; BLDVEC - Build a vector for a device
;                 
;	R0 =  Base interrupt service routine address
;	R1 -> Device packet
;	R2 =  xx.CSO value from device packet
;	PS0123 = Value to load into vector PSW to determine controller number
;
;	CALL	BLDVEC                                                      
;
;	R0 =  Undefined                                                     
;-

BLDVEC:	MOV	R0,-(SP)	;Save passed interrupt entry address	;059
	CLR	R0		;CLEAR FOR BISB
	BISB	VECTBL(R2),R0	;R0 = VECTOR ADDRESS FOR DEVICE
	ASL	R0		;UNHALVED
	ADD	#MONLOW,R0	;R0 -> VECTOR IN LOW CORE PROTOTYPE	;059
	MOV	(SP)+,(R0)+	;THE VECTOR GOES TO ??DINT
	MOVB	PK.PRI(R1),(R0)	;SET UP THE PRIORITY IN THE NEXT WORD
	BICB	#^C<PS.PRI>,(R0) ;ISOLATE THE PRIORITY
	BISB	#PR4&340,(R0)	;MAKE IT PR4-PR7
	BISB	PS0123,(R0)+	;ADD IN THE CONTROLLER NUMBER
	MOVB	#4000/400,(R0)+	;REGSET 1, PREV & CURRENT = KERNEL
	BITB	#PS.2VC!PS.EVC,PK.FLG(R1) ;DOES THIS WIDGET HAVE 2 VECTORS? ;055
	BEQ	20$		;NO
	MOV	-4(R0),(R0)	;YES, MAKE ANOTHER COPY OF THE ADDRESS
	BITB	#PS.EVC,PK.FLG(R1) ;Extra vector to same entry point?	;055
	BNE	10$		;Yes, so do that			;055
	ADD	#10,(R0)+	;VECTOR TO 4 WORDS LATER
10$:	MOV	-4(R0),(R0)+	;NEW PS IS THE SAME
20$:	RETURN								;056

GLOBAL	<MONLOW>							;059

RJSTRT::CLR	IIOFF		;NO OFFSET YET
	TST	RJDRVR		;IS THERE AN RJ2780 DRIVER
	BMI	100$		;NOPE
	MOV	#SATBUF,R4	;POINT TO BEGINNING OF DSTABLE
10$:	CMPB	(R4),RJDRVR	;IS THIS THE RJ2780?
	BEQ	20$		;YUP, PROCESS IT
	ADD	#DS.XXX,R4	;ADVANCE TO NEXT ENTRY
	TST	DS.NUN(R4)	;ARE WE AT THE END OF THE TABLE?
	BEQ	100$		;YUP, NOTHING TO DO
	BR	10$		;LOOK AT NEXT ENTRY

20$:	MOV	@#KG.PKT+2,R1	;MAKE AN OFFSET INTO THE CSR TABLE FOR KG11'S
	TST	CSRTBL(R1)	;NON-ZERO (KG0: PRESENT)? RJ: REQUIRES KG0:!
				; It really requires the KG at 170700       
	BNE	60$		;YEP, SO STILL DO RJ/II TABLE CHECK 'N SHUFFLE
	MOV	SOFTKG,R0	;GET ADDRESS TO CHANGE FOR DUV11	;029
	BEQ	50$		; NO, SO PROCEDE WITH THE ERROR		;029
	TSTB	@#FLGQBU	;ARE WE IN THE Q-BUS WORLD??		;029
	BMI	60$		;NO, SO NO JAMMING TO DO		;029
	ADD	#54,R0		;POINTER TO READ FROM			;029
	MOV	R0,2(R5)	;PUT THE ADDRESS IN THE JAM LIST	;029
	ADD	#2,2(R5)	; WHERE WE WANT TO STORE THIS VALUE	;029
	CALL	RDRSTS		;NOW READ IT IN				;029
	MOV	(R0),(R5)+	;AND PUT THE VALUE IN THE JAM LIST	;029
	TST	(R5)+		;SKIPPING OVER THE ADDRESS		;029
	BR	60$		;AND CONTINUE ALL FINE AND DANDY	;029
	;THE ABOVE JAM SEQUENCE IS DONE, BECAUSE THE Q-BUS DUV11 IS
	;NOT EXACTLY COMPATIBLE WITH THE UNIBUS DU11.  THE RJ2780
	;SIZING CODE THINKS THE DUV11 IS A DUP11 INSTEAD.  SO, THIS
	;JAM PUTS THE DU11'S CSR VALUE INTO THE PLACE WHERE THE DUP11
	;CSR VALUE GOES.  SO WHEN RJ2780 THINKS IT FINDS A DUP11, IT
	;WILL STUFF THE DU11'S CSR CONTENTS INTO THE DUV11 THAT IS
	;REALLY THERE ON THE Q-BUS, AND EVERYTHING THEN WORKS FINE...

	; THE FOLLOWING IS AN 11'TH HOUR FIX TO DISABLE RJ2780 IF NO
	; KG11 UNIT 0 IS PRESENT. IT DOES THIS BY FORCING THE RJ: ENTRY
	; IN DSTBL TO POINT TO THE KG11 DEVTBL PACKET IF UNIT 0 HAS NO
	; CSR ADDRESS (ADDR IS 0). WHEN THE CSR AND VECTOR SETUP CODE
	; FINDS NO KG0: CSR, IT DISABLES RJ: AND TELLS THE CONSOLE THAT
	; KG0: WAS NOT PRESENT. A SIDE EFFECT IS THAT INSTBL WILL INDICATE
	; THAT RJ: OWNS THE KG11, AND NOT A DU11 OR DUP11. IN THE FUTURE,
	; THE KG11 SHOULD BE CHECKED SEPARATELY (SPECIAL CASE).

50$:	MOV	#<<KG.PKT-DEVTBL>/PKTSIZ>,R1 ;NO KG0: PRESENT, SO FIND KG11
	MOVB	R1,DS.PKT(R4)	; PACKET OFFSET AND POINT RJ: TO THE KG11.
60$:	MOVB	DS.PKT(R4),R1	;GET DEVNAM PACKET OFFSET
	MUL	#PKTSIZ,R1	;MAKE IT A PACKET MULTIPLE
	ADD	#DEVTBL,R1	;R1 -> DEVNAM ENTRY FOR DEVICE
	MOVB	DS.CTL(R4),R2	;R2 = CONTROLLER NUMBER
	ASL	R2		;DOUBLE IT
70$:	ADD	PK.CSO(R1),R2	;ADD IN CSRTBL OFFSET
	TST	CSRTBL(R2)	;IS THERE A CSR?
	BNE	80$		;YES, WE MUST CHECK OUT THIS DEVICE
	CMP	PK.NAM(R1),#"DU	;DO WE HAVE A DU11?
	BNE	100$		;NOPE, NO PROCESSING TO DO
	CLR	R2		;DO FUNNYNESS
	ADD	#PKTSIZ,R1	;TRY DUP11 INSTEAD
	BR	70$		;GO TRY IT OUT

80$:	CMP	PK.NAM(R1),#"D1	;IS THIS A DUP11?
	BNE	100$		;NOPE, LEAVE RJ ALONE
	MOVB	(R4)+,R3	;R3 = DEVNAM TABLE OFFSET
	CALL	RDRSO3,R4,DEVPTR;GET POINTER TO DDB TABLE
	MOVB	(R4),R3		;R3 = UNIT NUMBER OF RJ CONTROLLER
	ASL	R3		;DOUBLE IT
	ADD	(R0),R3		;R3 -> DDB TABLE ENTRY FOR RJ
	MOV	R3,R0		;COPY TO R0
	CALL	RDRSTS		;READ
	MOV	(R0),R0		;R0 -> DDB FOR RJ
	ADD	#DDJBNO,R0	;R0 -> JOB NUMBER OWNING RJ
	CALL	RDRSTS		;READ IN OWNING JOB NUMBER
	CMPB	(R0),#1		;IS IT DISABLED?
	BNE	90$		;NOPE, PUSH II DEVICES DOWN THE CSR LIST
	BR	100$		;ON TO NEXT DSTABLE PACKET

90$:	INC	IIOFF		;MOVE THE II DRIVER DOWN
100$:	RETURN			;ALL DONE

GLOBAL	<RJDRVR,KG.PKT,SOFTKG>

	TMPORG	STACTL

IIOFF:	.WORD	0

	UNORG


.ENABL	LSB

CHKQ22:	CMP	PK.NAM(R1),#"RK	;RKV11-D CONTROLLER ON THIS Q-BUS?
	BNE	5$		;NO, TRY NEXT ONE
	TSTB	AUTOQS		;Doing streamline startup?
	BNE	50$		;Yes, so never a message
	MESSAG	<"RKV11-D can not be used with RSTS"<200>>
	BR	50$		;AND DISABLE THE THING

5$:	BITB	#1,FLG22	;Is physical memory > 248KB?
	BNE	30$		;NO, No problems with Q18 devices like
				; RLV11, 18 bit RLV12, or RXV21
	CMP	MAXMEM,#200-4	;ARE THEY USING > 248KB?
	BLOS	30$		;NO, SO STILL OK.
	CMP	PK.NAM(R1),#"RL	;IS IT THE RL CONTROLLER?
	BNE	40$		;NO, HOW ABOUT THE NEXT ONE
	MOV	@#4,-(SP)	;SAVE TRAP4 VECTOR
	MOV	#TRAPPR,@#4	;SET UP TRAP4 TO SEC C-BIT
	MOV	CSRTBL+RL.GCS,R0 ;IS A RL DISK ON THE SYSTEM?
	BEQ	20$		;NO
	TST	(R0)
	BCS	20$		;NO
	TST	RLBE(R0)	;DOES RL HAVE THE 5TH REG?
	BCS	10$		;NO
	MOV	#2,RLBE(R0)	;SET 1 BIT OF THE EXTENDED ADDR FIELD
	MOV	(R0),-(SP)	;GET THAT PRIMARY REGISTER
	BIC	#177717,(SP)	;LEAVE ONLY EXTENDED ADDR BITS
	CMP	(SP)+,#40	;DID THE RIGHT ONE STAY SET?
	BNE	10$		;NO, IT IS DP30 OR SOMETHING
	MOV	#1,RLBE(R0)	;NOW, TRY THE OTHER EXTD ADDR BIT
	MOV	(R0),-(SP)	;GET THE PRIMARY REGISTER
	BIC	#177717,(SP)	;LEAVING ONLY THE EXTENDED BITS
	CMP	(SP)+,#20	;DID THE RIGHT ONE STAY SET?
	BEQ	20$		;YES, IT IS RLV12
10$:	MOV	(SP)+,@#4	;RESTORE TRAP4 VECTOR
	CMP	SYNXSV,#IDX$DL	;MIGHT SYSTEM DISK BE NOW DISABLED?
	BEQ	15$		;YES, SO TELL THEM NO-MATTER WHAT
	TSTB	AUTOQS		;Doing streamline startup?
	BNE	50$		;Yes, so never a message
15$:	MESSAG	<"RLV disk must be strapped for 22-bit addressing"<200>>
	CMP	SYNXSV,#IDX$DL	;MIGHT SYSTEM DISK BE NOW DISABLED?
	BNE	50$		;NO, SO CONTINUE
	EXIT			;SORRY, CAN'T RUN ON A DISABLED SYSTEM DISK

20$:	MOV	(SP)+,@#4	;RESTORE TRAP4 VECTOR

;THIS IS THE EXIT IF THE DEVICE IS OK
30$:	CLC			;RETURN WITH OK!
	RETURN

40$:	CMP	PK.NAM(R1),#"RX	;IS IT THE FLOPPIES???
	BNE	60$		;NO, SO QUIT HERE
	MOV	CSRTBL(R2),R0	;Q-BUS WITH LOTS OF MEMORY, SO GET CSR
	BIT	#4000,(R0)	;IS IT 18BIT DMA ON Q22 BUS??
	BEQ	30$		;NO, ITS AN RX01 SO LEAVE IT ALONE
	TSTB	AUTOQS		;Doing streamline startup?
	BNE	50$		;Yes, so never a message
	MESSAG	<"RX02's can not be used with over 124Kw of memory."<200>>

;THIS IS THE EXIT IF THE DEVICE IS MUST BE DISABLED
50$:	SEC			;TELL THEM IT CAN'T BE USED
	RETURN

60$:	CMP	PK.NAM(R1),#"TS	;IS IT THE MS TAPES?
	BNE	30$		;NO, THEN CONTINUE AND ENABLE IT
	MOV	R2,R0		;PUT IT WHERE WE CAN MUNG IT
	SUB	#TS.CSO,R0	;FIND THE UNIT # * 2
	ASR	R0		;UNIT # * 1
	TSTB	MS$TYP(R0)	;EXTENDED?
	BMI	30$		;YES, SO LIFE WITH TS11'S IS OK
	TSTB	AUTOQS		;ANY MESSAGE?
	BNE	50$		;THEN JUST DISABLE IT
	MESSAG	<"TS tape must have extended features enabled."<200>>
	BR	50$		;AND DISABLE THE THING

.DSABL	LSB

GLOBAL	<DSKMID,DEVPTR,AUTOQS,CSRTBL,RL.GCS,TRAPPR>			;037
GLOBAL	<FLGQBU,FLG22,SYNXSV,MAXMEM,RK.CSO,TS.CSO,MS$TYP>



.ENABL	LSB

;+
;	IF THE SIL WAS GENERATED WITH DMPs AND THE CONFIGURATION
;	HAS DMVs, THEN WE MUST DISABLE ANY UNITS BEYOND THE DMV's LIMIT.
;-

DMVCHK:	MOV	R2,-(SP)	;SAVE A REGISTER
	MOV	R3,-(SP)	;SAVE ANOTHER REGISTER
	CMPB	PK.SIZ(R1),#DMVSZ ;DOES THE CONFIGURATION HAVE DMVS?
	BNE	30$		;NO, SO JUST RETURN.
	MOVB	DS.NUN-DS.CSR(R4),R2 ;R2 = NUMBER OF LINES
	MOVB	DS.UNT-DS.CSR(R4),R3 ;R3 = STARTING RSTS UNIT NUMBER (0 REL.)
	ADD	#DMVNU,R3	;R3 NOW =  RSTS NUMBER TO START DISABLING.
	MUL	DDS.XD,R3	;* THE XD DDB SIZE = OFFSET INTO XDDDDB LIST
	ADD	XDDDDB,R3	;NOW WE HAVE TRUE ADDRESS
	ADD	#DDJBNO,R3	;@ THE DDJBNO OFFSET.
10$:	CMP	R2,#DMVNU	;DO WE HAVE MORE LINES TO DISABLE?
	BLE	30$		;NO, WE ARE DONE.
	MOV	R3,R0		;R0 = ADDRESS IN SIL.
	MOV	R0,2(R5)	;PLACE ADDRESS TO RECEIVE THE JAM IN LIST
	CALL	RDRSTS		;READ IN THE SIL'S COPY OF THE XD DDJBNO
	BITB	(R0)+,#1	;ALREADY DISABLED?
	BNE	20$		;YES, NO JAM.  GO DO THE NEXT DDB
	MOVB	#1,(R5)+	;SET JOB NUMBER OF 1 TO DISABLE IT,
	MOVB	(R0),(R5)+	;  BUT LEAVE THE UNIT NUMBER AS B4.
	TST	(R5)+		;SKIP ADDRESS ALREADY PLACED IN JAM LIST.
	INC	TOTDSA		;COUNT THIS UNIT AS BEING DISABLED
	TSTB	AUTOQS		;AUTO-ANSWERS (SHORT TEXT)?
	BNE	20$		;YES, SKIP THE ACTUAL MESSAGE.
	MESSAG	<"XD">		;PRINT THE DEVICE NAME AND
	MOVB	(R0),R0		;  RSTS UNIT NUMBER
	CALLX	DECZER		;    OF WHO WE ARE DISABLING.
	CALL	DISMES		;PRINT THE DISABLED MESSAGE		;017
	MESSAG	<"(XD">		;NOW PRINT THE CONTROLLER NAME		;017
	MOVB	DS.CTL-DS.CSR(R4),R0 ;PRINT THE CONTROLLER NUMBER
	CALLX	DECZER		;	 AND WHY.
	MESSAG	<":) maximum"<200>>	;
20$:	ADD	DDS.XD,R3	;ADVANCE TO NEXT DDB
	DEC	R2		;COUNT DOWN THE NUMBER OF UNITS TO DISABLE.
	BR	10$		;GO DO NEXT DDB.

30$:	MOV	(SP)+,R3	;RESTORE OUR NUMBER OF CSR'S TO JAM
	MOV	(SP)+,R2	;RESTORE OUR CONTROLLER NUMBER
	RETURN

DISMES:	MESSAG	<": disabled - line exceeds controller ">		;017
	RETURN								;017

.DSABL	LSB



	TMPORG	STACTL

TOTDSA:	.WORD	0		;TOTAL # OF DEVICES DISABLED
PS0123:	.WORD	0		;Processor status word bits 0-3 for vector
BAEUWN:	.WORD	0		;BAE & UNIBUS WINDOW FLAG
UWNPTR:	.WORD	0		;POINTER INTO UNIBUS WINDOW LIST
UWNCNT:	.WORD	0		;COUNT OF WINDOWS LEFT
UWNLST:	.BLKW	10.*2		;10 POSSIBLE WINDOW DEVICES, FLAG/CSR
UWNLSE:

	UNORG




.SBTTL DSAETH -- Fake Pointers for UNA/LUA disabled DDB

;+
; DSAETH--
;	DISABLE ETHERNET device.  We know (from JAMDVC) that
;	the controller doesn't exist on this system.  We have already
;	deallocated the lowcore DDB space.  We must jam DEV.xx values
;	for the controller to point to FAKDDB -- a two word junk spot
;	in RES which indicates a controller disabled by INIT.
;
;	Also, forget Disabled messages as this device is not
;	expected on most systems.  Certainly not four of them.
;
;	R4 -> DS.CSR of a Descriptor packet
;
;  CALL	DSAETH
;
;	Return with R4 -> start of next DS block
;	R1,R3 are trashed.
;-

DSAETH:	MOVB	DS.CTL-DS.CSR(R4),R1	; get controller number		;045
	ASL	R1			; ... times two			;045
	CALL	DISDDB			; no, so point at FAKDDB in RES	;045
	ADD	#<DS.XXX-DS.CSR>,R4	; advance to start of next Desc ;045
	RETURN				;YES, DONE			;045

.SBTTL	DISDDB -- Jam pointer to Disabled DDB in DEVPTR for dealloc space

;+
;  DISDDB --
;	This routine is used to point DEVPTR entries as FAKDDB in RES.
;	FAKDDB is a two word entry which looks like an INIT DISABLED
;	Device DDB.  At least enough to keep the device in question from
;	being accessed.  This allows the return of actual DDBs for devices
;	which don't exist.  
;
;	CALL	DISDDB
;
;	R1 = controller number times 2
;	R4 -> DSTBL packet @ DS.CSR
;	Jam List previously set up for JAMBY2
;
; On Exit:
;	Address of FAKDDB jammed in at DEV.xx plus the controller
;	offset passed in R1
;	
;	R0,R3 munged.  Other registers okay.
;-

DISDDB:	MOVB	DS.DVN-DS.CSR(R4),R3 ; get offset into DEVPTR table	;045
	CALL	RDRSO3,R4,DEVPTR ; get DEV.xx value from .SIL		;045
	MOV	(R0),R3		; and move it into R3			;045
	ADD	R1,R3		; offset by controller number times 2	;045
	MOV	FAKDDB,(R5)+	; ... Jam address of FAKDDB into	;045
	MOV	R3,(R5)+	; DEV.xx plus controller number times 2	;045
	RETURN			; 					;045

GLOBAL	<FAKDDB,DEVPTR>




.ENABL	LSB

DSABLD:	SUB	#DS.CSR,R4	;BACK UP POINTER TO START OF DESCRIPTOR BLK
	CMPB	(R4),DEVOKB	;IS THIS A TERMINAL?
	BNE	10$		;NO
10$:	MOVB	(R4)+,R3	;R3 = DEVNAM OFFSET
	TSTB	AUTOQS		;IS THE MESSAGE HUSHED UP?
	BNE	20$		;YUP, NO NEED TO GET DEV NAME
	CALL	RDRSO3,R4,DEVNAM ;GET DEVNAM VALUE
	MOV	(R0),100$	;PUT NAME INTO MESSAGE
20$:	CALL	RDRSO3,R4,DEVPTR ;GET DEVPTR VALUE FOR THIS DEVICE
	MOVB	(R4)+,R3	;R3 = FIRST UNIT NUMBER
	MOV	R3,-(SP)	;SAVE UNIT NUMBER ON STACK
	ASL	R3		;DOUBLE IT
	ADD	(R0),R3		;R3 -> DDB POINTERS OR UNTCNT TABLE
	MOVB	(R4),R2		;R2 = NUMBER OF UNITS TO DISABLE
	TST	-(R4)		;BACK UP TO START OF INFO BLOCK
30$:	MOV	R3,R0		;POINT TO DDB LIST OR UNTCNT
	CALL	RDRSTS		;READ A WORD
	CMPB	(R4),DEVOKB	;IS THIS A DISK?
	BLO	40$		;YES, GO DISABLE A DISK
	MOV	(R0),R0		;NO, R0 = ADDRESS OF DDB
	ADD	#DDJBNO,R0	; @ DDJBNO
	MOV	R0,2(R5)	; = ADDRESS TO RECEIVE JAM
	CALL	RDRSTS		;READ IN THE WORD ALREADY THERE
	CMPB	(R0)+,#1	;ALREADY DISABLED?
	BEQ	80$		;YES
	MOVB	#1,(R5)+	;NO, JAM IN A JOB NUMBER OF 1
	MOVB	(R0)+,(R5)+	;BUT LEAVE TOP BYTE UNCHANGED
	TST	(R5)+		;SKIP ADDRESS ALREADY PLACED IN LIST
	BR	50$		;ISSUE MESSAGE

40$:	CMPB	(R1),#1		;Is this a multi-controller type disk?	;058
	BHI	120$		;YES, DON'T DISABLE UNITS UNTIL WE CHECK THEM
	CMP	(R0),#UC.MNT!UC.LCK ;DISK ALREADY DISABLED?
	BEQ	80$		;YES, DONE
	MOV	#UC.MNT!UC.LCK,(R5)+ ;NO, JAM A DISABLING WORD
	MOV	R3,(R5)+	; INTO THE UNTCNT ENTRY FOR THE DISK

GLOBAL	<DEVOKB,AUTOQS,DEVNAM,DEVPTR>					;048


50$:	CMP	PK.NAM(R1),#"RV	;Is this the virtual disk?		;075
	BEQ	80$		;Yup, don't count it (but DO disable it);075
	INC	TOTDSA		;COUNT THE DISABLES
	TSTB	AUTOQS		;AUTO-ANSWERS (SHORT TEXT)?
	BNE	80$		;YES, SKIP THE ACTUAL MESSAGE
	CALLX	MESSAG,R5,100$	;TELL HIM THE RSTS DEVICE NAME
	MOV	(SP),R0		;GET RSTS UNIT NUMBER
	CALLX	DECZER		;PRINT IT
	MESSAG	<": disabled - no ">
60$:	MOV	PK.NAM(R1),110$	;SET UP CONTROLLER NAME
	CALLX	MESSAGE,R5,110$	;PRINT CONTROLLER NAME
	CMP	(R1),#1		;IS IT UNITED?
	BLOS	70$		;NO
	MOVB	DS.CTL(R4),R0	;YES, GET CONTROLLER NUMBER
	CALLX	DECZER		; AND PRINT IT
70$:	MESSAG	<": controller"<200>>
80$:	INC	(SP)		;BUMP THE RSTS UNIT NUMBER
	ADD	#2,R3		;BUMP THE DDB POINTER OR UNTCNT POINTER
	DEC	R2		;COUNT DOWN NUMBER OF UNITS TO DISABLE
	BNE	30$		;DISABLE MORE UNITS IF NECESSARY
	TST	(SP)+		;DUMP THE UNIT NUMBER
	CALLX	RCTRLO		;RESET ^O FOR NEXT CONTROLLER
90$:	ADD	#DS.XXX,R4	;BUMP TO NEXT DEVICE INFO
	RETURN			;RETURN W/ R4 -> NEXT PACKET

100$:	.WORD	0,0		;ROOM FOR ASCIZ NAME OF RSTS DEVICE

110$:	.WORD	0,0		;ROOM FOR ASCIZ NAME OF CONTROLLER

120$:	MOV	#1,R2		;SET R2 TO #1 TO EXIT THE UNIT LOOP
	TSTB	AUTOQS		;AUTO-ANSWER MODE?
	BNE	80$		;YES, NO MESSAGE TO PRINT
	MESSAG	<"No ">		;  ELSE JUST INFORM HIM OF MISSING CONTROLLER
	BR	60$		;  AND DON'T DISABLE UNITS UNTIL WE CHECK THEM
				;  AGAINST THERE ASSIGNED CONTROLLER IN CHKQ22

.DSABL	LSB

GLOBAL	<AUTOQS>


.SBTTL	JAM FORMATTER NUMBER INTO DDB FOR MAGTAPE

.ENABL	LSB

JTAPE:	MOV	#SATBUF-DS.XXX,R4 ;POINT TO BEG'NG OF INSTALLED DEVICE TABLE
10$:	ADD	#DS.XXX,R4	;POINT TO NEXT DEVICE
	TST	DS.NUN(R4)	;ARE WE AT THE END OF THE TABLE?
	BEQ	40$		;YES, NO MAGTAPES IS EASY TO DO!
	MOVB	DS.PKT(R4),R3	;GET THE INDEX TO ITS PACKET
	MUL	#PKTSIZ,R3	;COMPUTE THE OFFSET TO THE DEVICE PACKET
	ADD	#DEVTBL,R3	;R3 -> DEVICE PACKET
	CMP	PK.NAM(R3),#"TU	;HAVE WE FOUND THE MM: STYLE MAGTAPES?
	BNE	10$		;NOPE, KEEP LOOKING
	MOVB	DS.DVN(R4),R3	;GET THE OFFSET IN THE MONITOR DEVNAM TABLE
	CALL	RDRSO3,R4,DEVPTR ;GET A POINTER TO THE MM: DDB'S
	TST	(R4)+		; R4 -> NUMBER OF GENERATED MM'S
	CLR	R3		;START WITH UNIT NUMBER 0
	MOV	R3,R2		;MAKE A COPY OF THE PRESENT UNIT NUMBER
	ADD	(R0),R3		;R3 -> DDB TABLE FOR MM: TYPE MAGTAPES
	MOV	#MM$FOR,R1	;POINTER TO FORMATTER TABLE FOR MAGTAPES
	CALLX	JAMBY2		;SET UP JAMMING
20$:	MOV	R3,R0		;R0 -> DDB TABLE ENTRY FOR THIS MAGTAPE
	CALL	RDRSTS		;READ DDB TABLE ENTRY
	MOV	(R0),R0		;R0 -> DDB FOR THIS MAGTAPE
	MOV	(R1)+,(R5)	;STORE FORMATTER NUMBER
	BPL	30$		;THERE REALLY WAS ONE FOUND; CONTINUE NORMALLY
	CLR	(R5)		;NO FORMATTER, STORE A ZERO
30$:	SWAB	(R5)+		;PUT FORMATTER NUMBER IN HIGH BYTE
	MOV	R0,(R5)		;STORE FORMATTER NUMBER IN THIS DDB
	ADD	.$TMUN,(R5)+	;AT OFFSET $$TMUN
	INC	R2		;ADVANCE TO NEXT MAGTAPE
	TST	(R3)+		;ALSO POINTER INTO DEVTBL
	CMPB	R2,(R4)		;ARE WE DONE WITH ALL TAPES GENERATED
	BLO	20$		;NO, CONTINUE WITH NEXT ONE
40$:	RETURN

.DSABL	LSB

GLOBAL	<SATBUF,DS.XXX,DS.NUN,PKTSIZ,DEVTBL,PK.NAM,DS.DVN,DEVPTR,MM$FOR,.$TMUN>


.SBTTL	JAM MS: DRIVE TYPES INTO MS: DDBs				;020

.ENABL	LSB								;020

JMSTYP:	MOV	#SATBUF-DS.XXX,R4	;POINT TO BEGINNING OF SIL DEVTBL;020
	CLR	R2			;CONTROLLERS FOUND FLAG		;020
10$:	ADD	#DS.XXX,R4		;POINT TO NEXT DEVICE		;020
	TST	DS.NUN(R4)		;END OF TABLE?			;020
	BEQ	30$			;YES, ALL DONE			;020
	MOVB	DS.PKT(R4),R3		;NO, GET THE DEVTBL INDEX NUMBER;020
	MUL	#PKTSIZ,R3		;COMPUTE OFFSET TO THE DEVICE PACKET;020
	CMP	DEVTBL+PK.NAM(R3),#"TS	;IS THIS A TS: CONTROLLER?	;020
	BNE	20$			;NOPE				;020
	DEC	R2			;YES, FLAG TS: CONTROLLERS FOUND;020
	CALLX	JAMBY2			;AND SET UP JAMMING, IF NEEDED	;020
	MOVB	DS.DVN(R4),R3		;GET OFFSET TO MONITOR DEVNAM TABLE;020
	CALL	RDRSO3,R4,DEVPTR	;GET A POINTER TO THE  DDB TABLES;020
	MOV	(R0),R0			;R0 -> DDB TABLE ENTRY FOR TS0:	;020
	MOVB	DS.CTL(R4),R3		;GET CONTROLLER NUMBER		;020
	CLRB	(R5)+			;JAM INTO HIGH BYTE		;020
	MOVB	MS$TYP(R3),(R5)		;STORE TYPE OF THIS CONTROLLER	;026
	BICB	#200,(R5)+		;Don't jam extended features bit;026
	ASL	R3			;CONTROLLER * 2			;020
	ADD	R3,R0			;R0 -> DDB TABLE ENTRY FOR THIS TAPE;020
	CALL	RDRSTS			;READ DDB TABLE ENTRY		;020
	MOV	(R0),(R5)		;TYPE IS TO BE STORED IN THIS DDB...;020
	ADD	.$TMUN,(R5)+		;AT OFFSET $$TMUN		;020
	BR	10$			;LOOK FOR MORE TS: CONTROLLERS	;020

20$:	TST	R2			;FOUND THE TS: CONTROLLERS YET?	;020
	BEQ	10$			;NOPE, KEEP LOOKING		;020
30$:	RETURN				;ALL DONE			;020

.DSABL	LSB								;020

GLOBAL	<SATBUF,DS.XXX,DS.NUN,PKTSIZ,DEVTBL,PK.NAM>			;020
GLOBAL	<DS.DVN,DEVPTR,DS.CTL,MS$TYP,.$TMUN>				;020


.SBTTL	SET UP THE CACHE TAG AREA PARAMETERS

.ENABL	LSB

JCACHE:	CALLX	JAMBYN		;SET UP JAM LIST
	CMP	D.CACH+2,#MINXBF;Do we have the minimum required XBUF?	;048
	BHIS	10$		;YES, THERE IS!
	MOV	#MINXBF,R0	;Get the required minimum XBUF...	;048
	MOV	#5$,R1		; and put it into our message...	;048
	CALLX	DECSTR		; in ASCII form.			;048
	MESSAG			;Otherwise, scream bloody murder.	;048
	 .ASCII <177><12>"RSTS/E requires at least "			;048
5$:	 .ASCIZ "??????K of XBUF!!"					;048
	UNORG								;048
	EXIT			;Say la vee.				;048

10$:	MOV	#20.,CACHON	; Set extended data caching flag on, # w tags
	MOV	#4,(R5)+	; IF CACHING BY JAMMIN CACHE CLUSTER SIZE
	MOV	.$CBSZ,(R5)+	; $$CBSZ IN THE SIL
	MOV	D.CBSZ,R0	;GET CACHE CLUSTER SIZE
	MOV	R0,(R5)+	;& $$CBSZ <- CACHE CLUSTER SIZE
	MOV	R0,R1		;MAKE A COPY OF THE CACHE CLUSTER SIZE
	CLR	R2		;CREATE THE SECOND PARAMETER IN THE JAM
20$:	ASR	R1		; TO BE THE VALUE OF THE CACHE CLUSTER SIZE
	BCS	30$		; LOG BASE 2, AND THEN THE NEGATIVE OF THAT
	DEC	R2		; THUS 1->0, 2->-1, 4->-2, 8->-3
	BR	20$		; DON'T YOU LOVE MAGIC?
30$:	MOV	R2,(R5)+	;& $$CBSZ+2 <- LOG BASE 2 OF CLUSTER SIZE
	MOV	R0,(R5)		;STORE THE CACHE CLUSTER SIZE
	DEC	(R5)		;& $$CBSZ+4 <- CACHE CLUSTER SIZE - 1
	MOV	(R5)+,(R5)	;COPY THIS VALUE
	COM	(R5)+		;& $$CBSZ+6 <- BIC MASK TO ISOLATE BLOCK
40$:	MOV	#TAGSIZ,R3	;R3 -> CACHE TAG AREA PARAMETERS
	MOV	.$CHSZ,R4	;R4 = SIZE OF A CACHE BUFFER TAG
	MOV	R4,(R3)+	;SAVE FOR FINAL LOADER
	CLR	R0		;R0 = NUMBER OF TAGS, 0 IF NO CACHING
	MOV	.$CACH,(R3)+	;SAVE ADDRESS OF CACHE PARAMETERS FOR FINAL LOAD
	BEQ	70$		;NO CACHING, GO USE 0 TAGS
	MOV	D.CACH+2,R1	;R1=XBUF area size in K (Limit=512-16=496K);048
	ASHC	#11.,R0		;COMPUTE AREA SIZE IN BYTES (LIM 3700000)

GLOBAL	<CACHON,TAGSIZ>		; Cells in final loader comm area


	SUB	#4,R1		;4 BYTES OF XBUF LIST HEAD NEEDED
	SBC	R0
	MOV	R4,-(SP)	;COPY TAG SIZE
	ADD	#1000,(SP)	;COMPUTE SIZE FOR 1 BUFFER + 1 TAG
	DIV	(SP)+,R0	;COMPUTE NUMBER OF BUFF/TAGS POSSIBLE
	ADD	CACHON,R0	;EXTENDED CACHING NEEDS 20 EXTRA TAGS
50$:	MUL	R4,R0		;COMPUTE NUMBER OF BYTES REQUIRED BY TAGS
	CMP	R1,#20000-100-4	;MAPPABLE WITH KISAR6, WITH THE END CUT OFF?
	BLO	60$		;YUP
	MOV	#20000-100-4,R1	;NO, LIMIT TAG AREA TO 4K-32W, -2W FOR LINK
60$:	DIV	R4,R0		;COMPUTE FINAL # OF TAGS POSSIBLE
70$:	MOV	R0,(R3)		;SAVE NUMBER OF TAGS FOR FINAL LOAD
	SUB	CACHON,(R3)+	;REMOVE 20 TAGS FOR WRITING IF EXTENDED CACHE
80$:	MUL	R4,R0		;COMPUTE TAG AREA SIZE
	ADD	#4+77,R1	; + 2 WORDS XBUF LINK + ROUND FACTOR
	ASH	#-6,R1		;SHIFTED TO BECOME MMU ADDRESS
	MOV	R1,TAGASZ	;SIZE OF TAG AREA = SIZE OF XBUF PREFIX
	RETURN

.DSABL	LSB

GLOBAL	<.$CHSZ,.$CACH,D.CACH,.$CBSZ,.$CHEN,D.CBSZ,CACHON>		;048
GLOBAL	<CACHON,TAGASZ>		; Cells in final loader comm area


.SBTTL	SET UP UNIBUS MAP, BAE LIST, XBUF TABLE

.ENABL	LSB

JXBUF:	TSTB	KTUSR3		;DOES MMUSR3 EXIST?
	BMI	10$		;NO
	CALLX	JAMBYN		;YES, JAM A TABLE
	MOV	#2,(R5)+	;A 2 WORD TABLE
	MOV	.$M22W,(R5)+	;& $$M22W <- #MMUSR3, VALUE IF MMUSR3 EXISTS
	MOV	#MMUSR3,(R5)+	;FIRST IS ADDRESS
	MOV	FLAG22,(R5)+	;VALUE TO JAM THERE
10$:	MOV	BAEPTR,R0	;R0 -> END OF BAE DEVICE LIST		;029
	MOV	#BAELST,R2	;R2 -> START OF BAE DEVICE LIST
	SUB	R2,R0		;COMPUTE # BAE DEVICES *4 +2
	BEQ	30$		;NONE IS EASY				;029
	CALLX	JAMBYN		;SET UP A BAE TABLE FOR THE MONITOR
	ASR	R0		;R0 = NUMBER OF DEVICES *2 +1
	MOV	R0,R1		;COPY TO R1
	MOV	R0,(R5)+	;   = NUMBER OF WORDS IN THE TABLE
	CALL	GETBUF		;ALLOCATE SPACE FROM THE SMALL POOL
	MOV	R0,(R5)+	;PUT IT IN THE JAM LIST
	MOV	R0,-(SP)	;SAVE IT FOR NOW
40$:	MOV	(R2)+,(R5)+	;JAM A WORD FROM THE PRE-BUILT LIST
	SOB	R1,40$		;INCLUDING THE ZERO WORD AT THE END
	BEQ	50$		;ALL IS WELL IF LAST WORD IS ZERO
	ERF	<"INIT bug - BAELST doesn't end with zero.">

50$:	CALLX	JAMBY2		;GIVE THE MONITOR THE TABLE ADDRESS
	MOV	(SP)+,(R5)+	;PUT THE ADDRESS IN
	MOV	.$BAEL,(R5)+	;& $$BAEL <- ADDRESS OF BAE LIST IF ANY

GLOBAL	<BAEPTR,BAELST,.$BAEL>


30$:	BIT	#40,FLAG22	;ARE UMR'S BEING USED HERE?		;029
	BNE	60$		;YES					;029
	CALLX	JAMBY2		;JAM PAIR(S)
	MOV	#XBUFX,R3	;NO, JUST SET UP ONE EXTENDED POOL
	MOV	D.CACH,R0	;Get pointer to cache as K number.	;048
	ASH	#11.-6.,R0	;MAKE K NUMBER INTO MMU ADDRESS
	MOV	D.CACH+2,R1	;R1 = Size of cache in K.		;048
	BEQ	20$		;NONE, JUST CLEAR THE TABLE
	ASH	#11.-6.,R1	;MAKE IT AN MMU SIZE
	MOV	R0,(R3)+	;SET UP MMU ADDRESS
	MOV	R1,(R3)+	;SET UP LENGTH
	TST	(R3)+		;SKIP PREFIX AREA LENGTH
	MOV	R0,(R5)+	;SET UP JAM LIST FOR EXTENDED POOL ADDRESS
	MOV	.$EXTP,(R5)+	;& $$EXTP <- CACHE ADDRESS FOR NON-11/70
20$:	CLR	(R3)+		;END OF CACHE SETUP TABLE
	RETURN

GLOBAL	<KTUSR3,.$M22W,D.CACH,.$EXTP>					;048
GLOBAL	<FLAG22,XBUFX>		; Cells in final loader comm area



; SET UP THE EXTENDED BUFFER POOL WITH UNIBUS MAPPING REGISTERS

	TMPORG	STACTL
UMRREQ:	.WORD	0		;Save area for the number of UMR's reserved ;041
	UNORG

60$:	MOV	D.LB+LBMCPL,R4	;Get size of MSCP/Ethernet region in slivers
	ADD	#177,R4		;Round to next 4Kw boundary		;041
	ASH	#-7,R4		;Compute how many UMR's are needed	;041
	MOV	R4,UMRREQ	;Save this value			;046
	ADD	#5,R4		;Also reserve the first 5 UMR's for the monitor
	ASH	#2,R4		;R4 = UMR's * 4				;041
	ADD	#UNIWIN,R4 	;R4 -> FIRST AVAILABLE UNIBUS WINDOW   -;041
	CALLX	JAMBY2		;PAIRS OF EXTENDED BUFFER ADDRESSES
	MOV	#XBUFX,R3	;R3 -> FINAL SETUP TABLE
	CLR	(R3)		;EMPTY FOR NOW
	MOV	D.CACH,R0	;R0 = K address of XBUF space.		;048
	ASH	#11.-6.,R0	;R0 = MMU ADDRESS OF XBUF SPACE
	MOV	D.CACH+2,R1	;R1 = K size of XBUF space.		;048
	BEQ	160$		;NONE IS EASY
	ASH	#11.-6.,R1	;R1 = MMU SIZE OF XBUF SPACE
	MOV	MAXWIN,R2	;R2 = UMR'S NEEDED BY GREEDIEST CONTROLLER
	ASL	R2		;DOUBLE IT
	ASL	R2		;R2 = 4*NUMBER OF WINDOWS NEEDED BY GREEDY
	MOV	#UNIWIN+<31.*4>,-(SP) ;END OF WINDOWS
	NEG	R2		;REMOVE 4* WINDOWS NEEDED BY THE GREEDY DEVICE
	ADD	(SP)+,R2	;R2 -> END OF UMR'S (LEAVING ROOM FOR GREEDY)
	SUB	R4,R2		;R2 = 4*NUMBER OF FREE WINDOWS
	BNE	80$		;IF ANY...
	MOV	#160$,-(SP)	;RETURN TO SET UP $$RWIN
70$:	MOV	R0,(R3)+	;TABLE HAS MMU ADDRESS OF UNMAPPED POOL
	MOV	R1,(R3)+	;MMU SIZE OF UNMAPPED POOL
	TST	(R3)+		;SKIP SIZE OF PREFIX AREA
	CLR	(R3)		;MARK END OF TABLE
	MOV	R0,(R5)+	;JAM MMU ADDRESS OF LARGE POOL IN MONITOR
	MOV	.$LRGP,(R5)+	;& $$LRGP <- MMU ADDRESS OF UNMAPPED POOL
	RETURN

GLOBAL	<D.CACH,.$LRGP,MAXWIN>						;048
GLOBAL	<XBUFX>			; Cell in final loader comm area


80$:	CMP	R2,D.XMAP	;DO WE HAVE ENOUGH UMR'S TO MAP ALL WE WANTED?
	BLO	90$		;NO, GIVE A WARNING
	MOV	D.XMAP,R2	;YES, ONLY MAP WHAT WAS REQESTED
	BR	100$		;SET UP AREA

90$:	MESSAG	<"Not enough UMRs to map requested portion of XBUF"<200>>
100$:	ASH	#11.-6.,R2	;R2 = MMU SIZE IN UNIWIN LEFT TO MAP
	CMP	R2,R1		;SIZE LEFT IN MAP : SIZE OF XBUF
	BLO	110$		;SMALLER, ONLY PART OF XBUF GETS MAPPED
	MOV	R1,R2		;LARGER, REDUCE AMT TO MAP TO XBUF SIZE
110$:	SUB	R2,R1		;R1 = MMU SIZE OF UNMAPPED POOL
	BEQ	130$		;WE CAN MAP IT ALL!
	SUB	TAGASZ,R1	;COMPUTE AREA SIZE - TAG PREFIX AREA
	BHIS	120$		;IF TAGS FIT IN UNMAPPED POOL, GOOD
	ADD	R1,R2		;ELSE PUNISH MAPPED POOL SO WE CAN FIT
	CLR	R1		; ALL TAGS IN THE UNMAPPED POOL (EXACTLY)
120$:	ADD	TAGASZ,R1	;R1 INCLUDES THE SIZE OF THE TAG/PREFIX AREA
	CALL	70$		;SET UP JAM LIST FOR UNMAPPED POOL
130$:	ADD	R0,R1		;R1=START OF XBUF+SIZE OF UNMAPPED=START OF MAPPED POOL
	MOV	R1,(R3)+	;FINAL SETUP TABLE GETS ADDRESS OF POOL
	MOV	R2,(R3)+	; AND SIZE OF POOL (MMU)
	TST	(R3)+		;SKIP PREFIX AREA SIZE
	CLR	(R3)		;END OF TABLE
	MOV	R1,(R5)+	;JAM LOCATION OF MAPPED POOL
	MOV	.$EXTP,(R5)+	;& $$EXTP <- MMU ADDR OF MAPPED POOL
	MOV	R4,R3		;COPY ADDRESS OF FIRST MAPPING REG
	SUB	#UNIWIN,R3	;R3 = MAPPED XBUF ADDR ON UNIBUS (K)
	ASH	#11.-6.,R3	;R3 = MMU ADDRESS ON UNIBUS OF XBUF
	SUB	R1,R3		;     - MMU ADDRESS (TRUE) OF XBUF
	MOV	R3,(R5)+	;JAM IT IN
	MOV	.$EXTO,(R5)+	;& $$EXTO <- XBUF UNIBUS ADDR (MMU) - TRUE ADDR
	ADD	#177,R2		;ROUND MMU SIZE UP TO 4K MULTIPLE
	ASH	#-13.+6,R2	;R2 = # of UMR'S required for mapped XBUF ;046
	MOV	UMRREQ,R3	;R3 = # of first available UMR		;046
	ASL	R3		;R3 = OFFSET INTO TABLE
	MOV	.$UMRT,(R5)	;Make the initial pointer skip them	;046
	ADD	R3,(R5)		;  by skipping the MCP/Ethernet ones	;046
	ADD	R2,(R5)		;  and the mapped XBUF ones		;046
	ADD	R2,(R5)+	;POINT TO FIRST AVAILABLE UMR TABLE ENTRY
	MOV	.$UMRP,(R5)+	;& $$UMRP <- START OF TABLE OF AVAILABLE UMR'S
	CALLX	JAMBYN		;NOW MARK THE ONES THAT WE'RE ALLOCATING ;046
	MOV	R2,(R5)+	;THIS MANY WORDS
	MOV	.$UMRT,(R5)	;& $$UMRT+N <- 177777 IF INIT ALLOCATES UMR #N
	ADD	R3,(R5)+
	CLR	R0		;CLEAR R0 FOR ASHC
	ASHC	#6.,R0		;MAKE MMU ADDRESS INTO TRUE 22-BIT ADDR
150$:	MOV	R1,(R4)+	;SET UP THE UNIBUS WINDOW FOR XBUF
	MOV	R0,(R4)+
	MOV	#177777,(R5)+	;MARK THIS UMR IS ALLOCATED
	ADD	#20000,R1	;NEXT 4K
	ADC	R0
	SOB	R2,150$		;REPEAT AS NEEDED

GLOBAL	<.$EXTP,.$EXTO,.$UMRT,.$UMRP,D.XMAP>
GLOBAL	<TAGASZ>		; Cell in final loader comm area


160$:	BIT	#40,FLAG22	;RIGHT?
	BEQ	180$		;YUP
	MOV	#UNIWIN,R3	;R3 -> UNIBUS WINDOW
	CLR	R2		;SET UP NULL MAPPING
	MOV	#5.,R1		;in first 5 windows			;041
170$:	MOV	R2,(R3)+
	CLR	(R3)+		;HIGH ORDER 0
	ADD	#20000,R2	;NEXT 4K
	SOB	R1,170$		;MORE
	MOV	UMRREQ,R3	;Get # of reserved UMR's	        ;046
	BEQ	180$		;None left, no [T]MSCP or Ethernet	;041
	CALLX	JAMBYN		;now mark the ones that we're allocating ;041
	MOV	R3,R2		;Make a copy				;041
	MOV	R3,(R5)+	;this many words			;041
	MOV	.$UMRT,(R5)+	;& $$UMRT+2N <- -1 if init allocates umr #N ;046
	MOV	D.LB+LBMCPP,R1	;Get MMU address of [T]MSCP/Ethernet region ;041
	CLR	R0		;clear R0 for ASHC			;041
	ASHC	#6.,R0		;make mmu address into true 22-bit addr	;041
	MOV	#UNIWIN+<5*4>,R4;Point to UMR #6			;041
175$:	MOV	R1,(R4)+	;set up the unibus window for XBUF	;041
	MOV	R0,(R4)+
	MOV	#-1,(R5)+	;mark this umr is allocated		;041
	ADD	#20000,R1	;next 4K				;041
	ADC	R0
	SOB	R2,175$		;repeat as needed			;041
	CALLX	JAMBY2		;Now jam by pairs			;041
				;High order of first UMR is zero	;041
	MOV	#20000/100*5,R2	;18-bit address of first UMR like MMU	;047
	MOV	CMT+CM.AWS,R1	;Get [T]MSCP area size			;041
	BEQ	177$		;Nothing, must have been UNA's present	;041
	MOV	R2,(R5)+	;18-bit UMR address for [T]MSCP region	;085
	MOV	.CMT,(R5)	;Jam into the CMT for CPH.MAC		;085
	ADD	#CM.UOF,(R5)+	;At offset CM.UOF			;085
	TST	CNT.XE		;UNA's too?				;046
	BEQ	180$		;No. We're done.			;046
177$:	ADD	#77,R1		;Round [T]MSCP region to sliver boundary ;041
	ASH	#-6,R1		;Compute number of slivers		;041
	ADD	R1,R2		;Compute 18-bit address of Ethernet like an MMU
	MOV	R2,(R5)+	;Jam 18-bit UMR address for the Ethernet region
	MOV	XECORE,(R5)	;Jam into the XEDCTL area		;041
	ADD	#6,(R5)+	;At the offset for the UMR address	;041
180$:	RETURN			;and exit			       -;041

.DSABL	LSB

GLOBAL	<CMT,.CMT,D.LB,XECORE>
GLOBAL	<FLAG22>		; Cell in final loader comm area




.SBTTL	SET UP CRASH DUMP FOR MONITOR

; WRITE A BOOT BLOCK STYLE CRASH WRITER OUT TO THE CRA PHASE

JCRASH:	MOV	#B.BOOT,R1	;GET POINTERS TO THE BOOT BLOCK
	MOV	#DATABF,R2	; AND OUR DATA BUFFER
	MOV	#256.,R0	;NUMBER OF WORDS IN A BOOT
10$:	MOV	(R1)+,(R2)+	;MOVE THE BOOT TO OUR DATA BUFFER
	SOB	R0,10$		; ALL OF IT

O	=	DATABF-B.BOOT	;DEFINE OFFSET BETWEEN BOOT AND DATABF

	MOVB	B.WFUN,B.FUNC+O	;42 - WRITE CODE (SINCE THIS IS CRASH DUMP)
	MOV	B.CSR,B.CSR+O	;Make sure we have the correct CSR address ;055
	CMP	#"DU,B.NAME+O	;Is booted device a UDA? (I.e. should we load
	BNE	20$		;NO. GO ON.		the MMU value?)
				;For the MSCP boot, we must supply the MMU
				;address of where it will execute from so it
				;can calculate the physical address of it's
				;ring buffers. This address is required
				;during controller initialization.
	MOV	CRABLK,R1	;Yes, get the crash driver block number
	SUB	RSTBLK,R1	;Account for the SIL index
	ASH	#9.-6,R1	;Convert block to MMU address
	MOV	R1,B.MMU+O	;Drop it into the bootstrap

				;THIS IS ALL WE SET UP.  THE CRASH DUMP CODE
				;IS RESPONSIBLE FOR THE I/O ADDRESS, WORD
				;COUNT AND BLOCK NUMBER

20$:	MOV	#FQSIL+FQFCB,R1	;POINT TO FCB
	MOV	CRABLK,FCNVB(R1) ;SET UP BLOCK TO WRITE
	CALLX	WRIT.B,R5,DATABF ;WRITE OUT THE BOOTSTRAP

; NOW JAM THE REST OF THE CRASH DUMP INFO

	CALLX	JAMBY2		;JAM PAIRS NOW
	MOV	B.DCS,(R5)+	;SYSTEM DISK CLUSTER SIZE
	MOV	.$XSCS,(R5)+	; GOES INTO X.SCS
	MOV	@X.MONS,(R5)+	;SIZE OF ROOT SEGMENT DUMP
	MOV	.$XMOS,(R5)+	; GOES INT X.MONS
	TST	D.CRAS		;Is CRASH DUMPING disabled?		;048
	BNE	40$		;YES, SKIP THE REST.

	MOV	CRSDCN,(R5)+	;STARTING DCN FOR THE CRASH DUMP FILE
	MOV	.$XDCN,(R5)+	; GOES INTO X.DCN
	CALLX	JAMBYN		;JAM A BUNCH NOW
	MOV	#<XMTLEN*XMSEGS>/2,R0 ;LENGTH OF MEMORY DUMP TABLE
	MOV	R0,(R5)+	;PUT IT IN THE JAM LIST
	MOV	.$XTAB,(R5)+	;WITH START ADDRESS OF THE TABLE
	MOV	#X.TAB,R4	;GET THE MEMORY DUMP TABLE
30$:	MOV	(R4)+,(R5)+	;AND COPY THE TABLE
	SOB	R0,30$		;UNTIL IT'S ALL IN THE JAM LIST
40$:	RETURN

GLOBAL	<FQSIL,CRABLK>
GLOBAL	<B.DCS,.$XSCS,X.MONS,.$XMOS,D.CRAS,CRSDCN,.$XDCN,.$XTAB,X.TAB>	;048


.SBTTL	SET UP THE CONFIGURATION WORD

SETCFW:	CALLX	JAMBY2		; Make more pairs of address/data words
	CLR	(R5)		; Start out clear
	TSTB	@#FLGUMR	; Do we have UMR's ?
	BMI	10$		; No
	BIS	#XC$UMR,(R5)	; Yes
10$:	TSTB	@#FLGQBU	; Do we have a Q-bus?
	BMI	20$		; No
	BIS	#XC$QBU,(R5)	; Yes
20$:	BITB	#1,FLG22	; Is physical memory > 248KB?		;012
	BNE	30$		; No
	BIS	#XC$22,(R5)	; Yes
30$:	TSTB	@#DSHARD	; Hardware have I & D spaces?
	BMI	40$		; No.					;014
	BIS	#XC$IDS,(R5)
	TSTB	@#DSPACE	; Monitor will use I&D spaces?		;014
	BEQ	40$
	BIS	#XC$DSP,(R5)	; Yes
40$:	TST	@#FIS		; Floating point instructions?		;081
	BMI	50$		; No					;081
	BIS	#XC$FIS,(R5)						;081
50$:	TST	@#FPU		; Floating point hardware?
	BMI	60$							;025
	BIS	#XC$FPP,(R5)
60$:	TSTB	@#CISINS	; Commercial Instruction Set available?
	BMI	70$
	BIS	#XC$CIS,(R5)
70$:	TSTB	@#CACHE		; Hardware cache?
	BMI	80$
	BIS	#XC$CAC,(R5)
80$:	TSTB	@#ODD.AD	; Processor odd address traps?
	BPL	90$							;025
	BIS	#XC$OAT,(R5)
90$:	TST	(R5)+
	MOV	.$XCON,(R5)+	; Set the address of the configuration word

	RETURN

GLOBAL	<FLGUMR,FLG22,DSHARD,DSPACE,FPU,CISINS,CACHE,ODD.AD,.$XCON,FIS>

.SBTTL	TTSTRT	Start up terminals

TTSTRT:	MOV	R5,-(SP)	;Get a scratch register			;059
	MOV	#KBSTBL,R0	;Point to startup table			;059
5$:	MOV	(R0)+,R1	;Get a packet pointer			;059
	BEQ	40$		;None, all done				;059
	CLR	R4		;Initialize our controller counter	;078
	MOV	PK.CSO(R1),R5	;Get the table offset value		;059
	MOVB	(R1),-(SP)	;Get number of controllers possible	;078
.ASSUME	PK.MXU	EQ	0						;078
	MOV	@(R0)+,-(SP)	;Get total # units for this type	;076
	BEQ	35$		;None, skip to next packet		;076
10$:	MOVB	PK.NUN(R1),R3	;Get max # of units per controller	;078
	BIT	#1,TYPTBL(R5)	;Is this a "small" controller?		;059
	BEQ	20$		;No, not this time			;059
	ASR	R3		;Yes, halve the count			;078
20$:	MOV	CSRTBL(R5),R2	;Get controller's CSR address?		;078
	BEQ	30$		;None, skip this one			;078
	CMP	R3,(SP)		;Max units <= Total?			;078
	BLE	25$		;Yes, good use that count		;078
	MOV	(SP),R3		;No, then we can only enable what's left ;078
25$:	SUB	R3,(SP)		;Subtract # to enable from total	;078
	MOV	R0,-(SP)	;Yes, save table pointer		;059
	CALL	@(R0)+		;Call the service routine		;059
	MOV	(SP)+,R0	;Restore table pointer			;059
30$:	INC	R4		;Bump the controller count		;078
	TST	(R5)+		; and advance to the next unit		;078
	TST	(SP)		;More units to do?			;078
	BEQ	35$		;No, can't enable all of them		;078
	DECB	2(SP)		;One controller done, more to do?	;078
	BNE	10$		;Yes, keep on going			;078
35$:	CMP	(SP)+,(SP)+	;No, discard units and controller count	;078
	TST	(R0)+		; advance to the next table entry	;078
	BR	5$		; and loop				;078

40$:	MOV	(SP)+,R5	;Restore work register			;059
	RETURN			;And exit				;059

;+
; Each entry the following table is comprised of the following		;076
; components:								;076
;
;	Device Packet Pointer, Total number of units, Start routine	;076
;-									;076

KBSTBL:	KBSTRT	TT,CNT.KL,KLSTRT ;Start up TT interfaces in KLSTRT	;076
	KBSTRT	KL,CNT.KL,KLSTRT ;Start up KL interfaces in KLSTRT	;076
	KBSTRT	DL,CNT.DL,DLSTRT ;Start up DL interfaces in DLSTRT	;076
	KBSTRT	DE,CNT.DE,DESTRT ;Start up DL11E interfaces in DESTRT	;076
	KBSTRT	DJ,CNT.DJ,DJSTRT ;Start up DJ11 interfaces in DJSTRT	;076
	KBSTRT	DH,CNT.DH,DHSTRT ;Start up DH11 interfaces in DHSTRT	;076
	KBSTRT	DZ,CNT.DZ,DZSTRT ;Start up DZ11/DZV11 interfaces in DZSTRT ;076
	KBSTRT	VH,CNT.VH,VHSTRT ;Start up DHV/DHU interfaces in VHSTRT	;076
	KBSTRT	END

.SBTTL	KLSTRT	Start up KL11 interfaces
.SBTTL	DLSTRT	Start up DL11 interfaces
.SBTTL	DESTRT	Start up DL11E interfaces                               

;+									;078
;	Start up single line interfaces
;
; Inputs:
;	R2 -> CSR
;
; Ouputs:
;	R2 =  Unchanged
;-									;078

.ENABL	LSB

DLSTRT:	MOV	#106,(R2)	;Set receive interrupt enable, RQS and DTR ;059
				;(RQS and DTR set because this might be
				; a DL11E set at the DL11A/B/C/D CSR
				; address connected to a leased line modem)
 	BR	10$		;And join up				;059

DESTRT:	BIT	#10000,(R2)	;Is CARRIER on?				;078
	BEQ	KLSTRT		;No, go set RC IE and clear output side	;078
	BIS	#140,(R2)	;Yes, OR in IE+DATASET IE in the CSR	;078
	BR	20$		; and exit, let HUNG service pick it up ;078

KLSTRT:	MOV	#100,(R2)	;Set receive interrupt enable 		;059
10$:	BIC	#100!4!1,4(R2)	;Ensure IE, maint, and break are cleared ;059
20$:	RETURN			;And we're done				;059
                                                                        
.DSABL	LSB

.SBTTL	DJSTRT	Start up DJ11 interfaces

;+									;078
;	Start up DJ11 interfaces
;
; Inputs:
;	R2 -> CSR
;
; Ouputs:
;	R2 =  Unchanged
;-									;078

DJSTRT:	MOV	#10,(R2)	;MASTER CLEAR THE DJ11
10$:	BIT	#20,(R2)	;WAIT FOR THE CLEAR TO FINISH
	BNE	10$                                                     
	CLR	4(R2)		;CLEAR THE BAR BITS
	TST	2(R2)		;ANYTHING IN THE SILO?
	BMI	10$		;YES, TRY CLEARING IT AGAIN
	BIS	#2000,(R2)	;SWITCH TO THE BREAK REGISTER               
	CLR	4(R2)		;CLEAR THE BREAK REGISTER               
	MOV	#50501,(R2)	;RE-ENABLE DJ AND DE-SELECT BREAK REG
	RETURN			;DONE					;059

.SBTTL	DHSTRT	Start up DH11 interfaces

;+									;078
;	Start up DH11 interfaces
;
; Inputs:
;	R2 -> CSR
;	R3 =  Number of units to enable
;	R4 =  Controller number
;
; Ouputs:
;	R0 =  Number of units enabled
;	R1 =  Unchanged
;	R2 =  Unchanged
;	R3 =  Unchanged
;	R4 =  Unchanged
;-									;078

DHSTRT:	MOV	R1,-(SP)	;Get a scratch register			;078
	MOV	R4,-(SP)	;Save the controller count		;078
	MOV	#DM.CSO,R4	;R4 = Table offset of DM11BB		;078
10$:	MOV	CSRTBL(R4),R1	;R1 = CSR address for DM11BB or zero	;078
	BEQ	20$		;None, try next one			;078
	CMPB	TYPTBL(R4),(SP)	;DM11BB for this controller?		;078
	BEQ	22$		;Yes					;078
20$:	TST	(R4)+		;No, advance to the next DM11BB		;078
	CMP	R4,#DM.CSO+<16.*2> ;Done all possible DM11BBs?		;078
	BLO	10$		;No, keep checking			;078
	CLR	R1		;Yes, R1 = 0 to indicate no DM11BB	;078
22$:	MOV	#4000,(R2)	;MASTER CLEAR THE DH11
	TST	R1		;Any associated DM11BB?			;078
	BEQ	26$		;No					;078
	MOV	#6000,(R1)	;Yes, master clear the unit		;078
26$:	CLR	R0		;Start with subline 0 for 1st KB.	;073	
30$:	MOV	R0,(R2)		;Select this subline in the DH11.	;073
	MOV	#33503,4(R2)	;Set the line parameter register	;059
	CLR	6(R2)		;Clear address register			;059
	CLR	10(R2)		;And byte count register		;059
40$:	CLR	12(R2)		;ALL BAR'S ARE 0
	CLR	14(R2)		;NO BREAKS
	CLR	16(R2)		;ALARM LEVEL = 0
	TST	2(R2)		;SILO EMPTY?                    
	BMI	40$		;NO, AROUND AGAIN
	TST	R1		;Any DM11BB for this controller?	;078
	BEQ	80$		;No, nothing more to do			;078
	CLR	(R1)		;Turn off scan enable			;078
50$:	BIT	#20,(R1)	;Is DM11BB ready?			;078
	BNE	50$		;No, keep waiting			;078
	MOV	R0,(R1)		;Select the subline			;078
	MOV	#1,2(R1)	;Enable scan on this line		;078
	MOV	(SP),-(SP)	;Waste a few cycles - necessary so that	;084
	CLR	(SP)+		; some 3rd-party DH clones will work!	;084
	BIT	#100,2(R1)	;CARRIER on?				;078
	BEQ	60$		;No, go clear the  subline		;078
	MOV	#7,2(R1)	;Yes, Set DTR+RQS+ENB			;078
	MOV	#140,(R1)	; and enable the DM11BB			;078
	BR	80$		;Go try another subline			;078

60$:	CLR	2(R1)		;Clear the subline			;078
80$:	INC	R0		;Next subline.				;073
	CMPB	R0,R3		;Done all sublines?			;073
	BLO	30$		;NO
	MOV	#030100,(R2)	;Yes, enable the DH11			;059
	MOV	(SP)+,R4	;Restore the controller count		;078
	MOV	(SP)+,R1	; and our scratch register		;078
	RETURN			;And exit				;059

GLOBAL	<DM.CSO,CSRTBL,TYPTBL>						;078

                                                              
.SBTTL	DZSTRT	Start up DZ11 interfaces

;+									;078
;	Start up DZ11 interfaces
;
; Inputs:
;	R2 -> CSR
;	R3 =  Number of units to enable
;
; Ouputs:
;	R0 =  Number of units enabled
;	R2 =  Unchanged
;	R3 =  Unchanged
;-									;078

DZSTRT:	MOV	#20,(R2)	;POWER CLEAR THE DZ11			;059
10$:	BIT	#20,(R2)	;WAIT FOR IT TO SETTLE
	BNE	10$
	CLR	R0		;START WITH SUBLINE 0
20$:	MOV	R0,-(SP)	;Copy subline number			;059
	BIS	#17030,(SP)	;Set parameter word up			;059
	MOV	(SP)+,2(R2)	;SET UP THE LINE			;059
	BITB	BITBYT(R0),7(R2) ;Is CARRIER on?			;078
	BEQ	30$		;No, go turn off DTR			;078
	BISB	BITBYT(R0),5(R2) ;Yes, Set DTR				;078
	BR	40$		;Go join up				;078

30$:	BICB	BITBYT(R0),5(R2) ;Turn off DTR				;078
40$:	INC	R0		;BUMP THE SUBLINE NUMBER		;078
	CMPB	R0,R3		;Done all the sublines?			;059
	BLO	20$		;NOT YET
	MOV	#40140,(R2)	;Yes, enable the DZ11			;059
	RETURN

.SBTTL	VHSTRT	Start DHV11/DHU11 interfaces

;+									;078
;	Start up DHV11/DHU11 interfaces
;
; Inputs:
;	R2 -> CSR
;	R3 =  Number of units to enable
;
; Ouputs:
;	R0 =  Number of units enabled
;	R2 =  Unchanged
;	R3 =  Unchanged
;-									;078

VHSTRT:	MOV	#40,(R2)	;MASTER RESET THE DHV11/DHU11		;017
	MOVB	#-2.,DSS$DV+1	;Wait 2 seconds				;078
5$:	CALLX	GETTTY		;Keep the clock going			;078
	TST	DSS$DV		;Have we timed out?			;078
	BMI	5$		;No, keep waiting			;078
10$:	BIT	#40,(R2)	;HAS IT CALMED DOWN?			;017
	BNE	10$		;NO, IT'S STILL JUMPING			;017
	CLR	R0		;START AT LINE 0			;059
20$:	MOV	R0,(R2)		;LOAD THE CHANNEL NUMBER		;059
	MOV	R0,(R2)		;LOAD THE CHANNEL NUMBER		;059
	MOV	#156430,4(R2)	;SET UP THE LINE			;059
	CLR	10(R2)		;Clear the LCR register (DTR etc.)	;078	
	BIT	#10000,6(R2)	;Is CARRIER on?				;078
	BEQ	30$		;No					;078
	BIS	#11000,10(R2)	;Yes, so set RTS and DTR		;078
30$:	TST	2(R2)		;IS THE SILO EMPTY?			;017
	BMI	30$		;NOPE					;017
	BIS	#4,10(R2)	;ENABLE THE RECEIVER			;017
	MOV	#100000,14(R2)	;ENABLE THE TRANSMITTER			;017
40$:	INC	R0		;BUMP THE SUBLINE NUMBER		;017
	CMPB	R0,R3		;Done all sublines yet?			;059
	BLO	20$		;NOT YET				;017
	MOV	#0,(R2)		;SUBLINE 0				;029
	BIT	#400,6(R2)	;IS THIS A DHU11?			;017
	BEQ	45$		;NOPE					;017
	MOV	#5,2(R2)	;YES, SO SET RX TIMER FOR RX I.E. DELAY ;078
45$:	MOV	#40100,(R2)	;Enable the interface			;059
	RETURN								;017

GLOBAL	<DSS$DV>							;078

.SBTTL	TURN DATASET READY OFF ON ALL DMC'S

.ENABL	LSB

DMCINI:	MOV	#SATBUF-DS.XXX,R4 ;POINT TO THE BEGINNING OF THE DEVICE TABLE
10$:	ADD	#DS.XXX,R4	; ADVANCE TO NEXT DEVICE
	TST	DS.NUN(R4)	;ARE WE AT THE END OF DSTBLE?
	BEQ	40$		;YES, THAT MEANS THERE ARE NO DMCs
	MOVB	DS.PKT(R4),R3	;FETCH PACKET NUMBER FOR DEVICE
	MUL	#PKTSIZ,R3	;MAKE IT INTO AN OFFSET
	ADD	#DEVTBL,R3	;THEN MAKE IT INTO A POINTER
	CMP	PK.NAM(R3),#"XM	;ARE WE UP TO THE DMC'S YET?
	BNE	10$		;NO, KEEP LOOKING
	MOVB	DS.CTL(R4),R2	;GET CONTROLLER NUMBER
	ASL	R2		; *2
	ADD	PK.CSO(R3),R2	;MAKE IT INTO AN OFFSET IN CSRTBL
	MOVB	(R3),R4		;SAVE THE NUMBER OF DMC'S		;008
.ASSUME	PK.MXU EQ 0
20$:	MOV	CSRTBL(R2),R1	;GET ADDRESS OF ONE OF THE CSR'S
	BEQ	30$		;NO DEVICE HERE!
	MOVB	PK.OFF(R3),R0	;GET OFFSET TO MAJOR REGISTER
	ADD	R0,R1		;AND POINT TO THAT MAJOR REGISTER
	MOV	#40000,(R1)	;MASTER CLEAR ON DMC
	MOV	#122013,6(R1)	;INSTRUCTION TO TURN OFF DATASET READY
	MOVB	#202,1(R1)	;AND THEN TELL IT TO RUN
30$:	TST	(R2)+		;ADVANCE TO NEXT DEVICE
	SOB	R4,20$		;AND KEEP DOING TILL WE HAVE HIT ALL DMC'S
40$:	RETURN			;WE ARE REALLY DONE

GLOBAL	<SATBUF,CSRTBL,DEVTBL>						;008

.DSABL	LSB



.SBTTL	JAM THE XD AND XM DDB'S IF DMRS OR DMVS ARE CONFIGURED
;+
;	IF THE HARDWARE CONFIGURATION HAS DMR11'S AND/OR DMV11'S
;	THEN SET A BIT IN THE DDFLAG WORD OF THE XM AND/OR XD DDB'S 
;	TO INDICATE SUCH. JAMDDB IS DRIVEN BY DSTABL.
;
;	THE XM DEVICES HAVE 1 DDB/CONTROLLER
;	THE XD DEVICE CAN HAVE UP TO 32 DDBS/CONTROLLER BUT MAX OF 12 FOR DMVS
;
;		CALL JAMDDB
;
;			R0	Destroyed
;			R3	Destroyed
;			R4	Destroyed
;-
.ENABL	LSB

JAMDDB:	CALLX	JAMBY2		;CHANGES GO INTO THE PAIRED JAM LIST
	MOV	#SATBUF-DS.XXX,R4 ;POINT TO THE BEGINNING OF THE DEVICE TABLE
	MOV	XDDDDB,R0	;GET THE GLOBAL XD DDB ADDRESS IN THE SIL
	BIS	XMDDDB,R0	;AND THE GLOBAL XM ADDRESS IN THE SIL
	BEQ	40$		;0=> NO GLOBALS IN SIL, THUS NO DMR'S OR DMV'S
10$:	ADD	#DS.XXX,R4	; ADVANCE TO NEXT DEVICE
	TST	DS.NUN(R4)	;ARE WE AT THE END OF DSTBLE?
	BEQ	40$		;YES, NO MORE DMV'S OR DMR'S
	MOVB	DS.PKT(R4),R3	;FETCH PACKET NUMBER FOR DEVICE
	MUL	#PKTSIZ,R3	;MAKE IT INTO AN OFFSET
	ADD	#DEVTBL,R3	;THEN MAKE IT INTO A POINTER
	CMP	PK.NAM(R3),#"XM	;IS THIS THE DMC/DMR CONTROLLER?
	BEQ	30$		;YES, GO CHECK THE XM TYPE.
	CMP	PK.NAM(R3),#"XD	;NO, ARE WE UP TO THE DMP/DMV YET?
	BNE	10$		;NO, KEEP LOOKING
	CMPB	PK.SIZ(R3),#DMVSZ ;IT IS AN XD, BUT DOES CONFIG. HAVE DMV'S?
	BNE	10$		;NO, AND THERE'S NO JAMMING 2B DONE ON DMP'S
;
; JAM THE DMV BIT INTO THE XD DDB'S
;  
	MOV	XDDDDB,R0	;GET THE GLOBAL XD DDB ADDRESS IN THE SIL
	BEQ	10$		;0 MEANS NO GLOBAL IN SIL, THUS NO DMP/DMV'S
	MOVB	DS.UNT(R4),R3	;R3 = STARTING RSTS UNIT # FOR THIS CONTROLLER
	MUL	DDS.XD,R3	;COMPUTE THE OFFSET INTO THE 1ST XD DDB
	ADD	R0,R3	; + THE XDDDDB ADDRESS FOR TRUE ADDRESS.
	CLR	R0		;CLEAR COUNTER FOR XD LINES
20$:	CMPB	R0,DS.NUN(R4)	;DOES THIS CONTROLLER HANDLE MORE?
	BGE	10$		;NO, GET NEXT CONTROLLER, IF ANY.
	CMPB	R0,#DMVNU	;CAN THIS CONTROLLER'S HARDWARE HANDLE MORE?
	BGE	10$		;NO, THE REST SHOULD BE DISABLED ANYWAY.
	MOV	#DMVFLG,(R5)+	;PUT THE DMV INDICATOR BIT IN THE JAM LIST
	MOV	R3,(R5)		;AND WHERE TO JAM IT
	ADD	#DDFLAG,(R5)+	; AT THE DDB FLAG WORD.
	ADD	DDS.XD,R3	;BUMP THE POINTER TO THE NEXT DDB
	INC	R0		;NEXT XD LINE
	BR	20$		; AND DO THE NEXT DDB FOR THIS CONTROLLER.


;
; JAM THE DMR BIT INTO THE XM DDB'S
;  

30$:	MOV	XMDDDB,R0	;GET THE GLOBAL XM DDB ADDRESS IN THE SIL
	BEQ	10$		;0 MEANS NO GLOBAL IN SIL, THUS NO DMP/DMV'S
	MOVB	DS.UNT(R4),R3	;R3 = STARTING RSTS UNIT # FOR THIS CONTROLLER
	ASL	R3		;*2 FOR WORD ADDRESS OFFSET
	BIT	BITWRD(R3),@#XM.TYP ;IS THE CONTROLLER A DMR?
	BEQ	10$		;NO, AND NO JAMMING  FOR DMCS.
	ASR	R3		;/2 TO GET BACK REAL NUMBER.
	MUL	DDS.XM,R3	;COMPUTE THE OFFSET INTO THE XM DDB
	ADD	R0,R3		; + THE XMDDDB ADDRESS FOR TRUE ADDRESS.
	MOV	#DMRFLG,(R5)+	;PUT THE DMR INDICATOR BIT IN THE JAM LIST
	MOV	R3,(R5)		;AND WHERE TO JAM IT
	ADD	#DDFLAG,(R5)+	; AT THE DDB FLAG WORD.
	BR	10$		;NEXT CONTROLLER

40$:	RETURN			;WE ARE REALLY DONE

.DSABL	LSB

GLOBAL	<PK.NAM,SATBUF,DEVTBL,DS.XXX,DS.PKT,DS.NUN,BITWRD>
GLOBAL	<XDDDDB,DDS.XD,DMVFLG,DMVSZ,DMVNU>
GLOBAL	<XMDDDB,DDS.XM,DMRFLG,XM.TYP>

ENDOVL	<STA,STATXT,STACTL>,200

.END
