	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
	.INCLUDE /INIT:INIPFX/
TITLE	REFRSH,<RSTS/E INIT - REFRESH OPTION>,0A,10-MAY-91,ABC/MDS/GPK/JHC/MNB/DBM

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;


.SBTTL	EDIT HISTORY FOR INIREF

;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;  001  MDS  20-MAR-81	MAKE CRASH FILE SIZE CALCULATION WORK
;
;				[RSTS V7.2]
;  000	MND  22-Mar-82	CREATION - COPIED FROM V7.1-11
;  001	MND  22-Mar-82	Added support for MSCP disks - UDA50/RA80
;
;				[RSTS V8.0]
;  000	GPK  24-Sep-82	New disk structure mods 
;  001	JHC  04-Jan-82  Restrict modification of run-time systems and SILs
;			when using the FILE and CHANGE options.  Also prevent
;			all modifcation of INSTALLED SIL.
;  002  MNB  21-Feb-83  Change "NAME.EXT" to "NAME.TYP"
;
;				[RSTS V9.0]
;  000	DBM  06-Jan-84	Change <CR> to <LF> for VT200 support
;  001	DBM  26-Apr-84	Change SWAP.SYS minimum for 1 job
;  002	DBM  10-Jun-84	Clear patch 1.1.34 (Bad block of PCN=1 disallowed)
;  003	DBM  17-Dec-84	Update help messages
;  004	FEK  26-Feb-85	REMOVE CHANGE SUB-OPTION
;
;				[RSTS V9.4]
;  005	GPK  23-Sep-86	Add DW for GPK
;  006	GPK  07-Oct-86	Changes for FIP in resident overlay
;
;				[RSTS V9.7]
;  007	KCG  16-Nov-88	Change calculation of minimum OVR.SYS file size
;			as a result of additional overlay phase (OV2).
;  008	JRM  20-Mar-89	Add "/D" switch.
;
;-


.SBTTL	MACROS FOR REFRESH

.MACRO	I.MESS
	TMPORG	REFTXT
.NLIST	BEX
.ENDM	I.MESS

.MACRO	OPTION	N1,N2
.SBTTL	N1'N2 SUBOPTION
	TMPORG	REFOPT
	 .WORD	REF'N1'N2
	TMPORG	REFOTX
	 UNQTXT	<N1\N2>
	UNORG
.LIST
REF'N1'N2:
.NLIST
.ENDM	OPTION

.SBTTL	ORDER THE CSECTS

	DEFORG	REF
	DEFORG	REFCTL
	DEFORG	REFOPT
	DEFORG	REFOTX
	DEFORG	REFTXT
	ORG	REF


.SBTTL	GET SYSTEM DISK SIZE MINIMA

.ENABL	LSB

REFRSH::TSTB	SAVDEV		;ARE WE BOOTED FROM A SAVE/RESTORE DISK?
	BEQ	10$		;NOPE, ALL IS KOSHER
	JMPX	OPNOT		;OTHERWISE THIS OPTION IS NOT AVAILABLE
10$:	CALLX	DATINI		;GET DATE AND TIME
	CALLX	SETFIP		;SET UP FIP FOR THE SYSTEM DISK
	CALLX	LOKMIN		;LOOK UP MINIMA ON THE SYSTEM DISK
	MOV	#SWPMIN,R2	;POINT TO LIST OF MONITOR-RELATED MINIMA
	MOV	#8.*4*2,(R2)+	;SWAP.SYS MINIMUM = 64. IF NO SIL
	CLR	(R2)+		;OVR.SYS UNKNOWN
	CLR	(R2)+		;BUFF.SYS UNKNOWN
	CLR	(R2)+		;CRASH.SYS UNKNOWN
	TST	SILNAM		;IS THERE AN INSTALLED SIL?
	BEQ	REFASK		;NO, LEAVE THE GUESSES ALONE
	CALLX	DMPLEN		;GET LENGTH TO R0
	MOV	R0,-(R2)	;SAVE IT
	MOV	CNT.DT,R1	;GET THE COUNT OF CONFIGURED DT'S
	MUL	#3,R1		;TIMES 3 BLOCKS EACH
	MOV	R1,-(R2)	;= BUFF.SYS SIZE
	CLR	-(R2)		;ASSUME OVR SIZE IS 0
	CALLX	SILNDX,R5,FQSIL	;READ THE SIL INDEX
	BNE	20$		;NOT GOOD, PUNT
	CALLX	SILSCN,R5	;IF THERE, FIND OVR
	 .RAD50	/OVR   /
	BCS	20$		;NOT THERE, PUNT
	MOV	SE.SIZ(R0),R1	;GET THE OVR MODULE SIZE
	ADD	SE.LOD(R0),R1	;COMPUTE HIGH LIMIT
	ADD	#777,R1		;ROUND UP TO A BLOCK MULTIPLE
	CLRB	R1		;COMPUTE BLOCK COUNT
	SWAB	R1		; IN LOW BYTE
	;CLC			;C=0 FROM SWAB
	ROR	R1
	MOV	R1,-(SP)	;Save this count			;007
	CALLX	SILSCN,R5	;IF THERE, FIND OVR			;007
	 .RAD50	/OV2   /						;007
	BCS	20$		;NOT THERE, PUNT			;007
	MOV	SE.SIZ(R0),R1	;GET THE OVR MODULE SIZE		;007
	ADD	SE.LOD(R0),R1	;COMPUTE HIGH LIMIT			;007
	ADD	#777,R1		;ROUND UP TO A BLOCK MULTIPLE		;007
	CLRB	R1		;COMPUTE BLOCK COUNT			;007
	SWAB	R1		; IN LOW BYTE				;007
	;CLC			;C=0 FROM SWAB				;007
	ROR	R1							;007
	ADD	(SP)+,R1	;sum the two counts to find the min size;007
	MOV	R1,(R2)		;SAVE THE OVR SIZE
20$:	TST	I.DFLD		;ARE THERE DEFAULTS SET?
	BEQ	REFASK		;NO, DONE WITH MINIMA
	MOV	D.SWPM,-(R2)	;YES, SET SWAP.SYS MINIMUM
	ASL	(R2)		;* 4 FOR BLOCKS
	ASL	(R2)
;	ASL	(R2)		;* 2 FOR 2 JOBS			;001-V9

.DSABL	LSB

GLOBAL	<SILNAM,.$CRSZ,CNT.DT,FQSIL,I.DFLD,D.SWPM,SAVDEV>


.SBTTL	GET DISK TO REFRESH

.ENABL	LSB
REFASK:	CALLX	ASKER,R5	;ASK FOR DISK TO REFRESH
	 .WORD	10$		;SHORT FORM
	 GENTXT
	  .ASCII "Type the name of the disk to refresh (DK,DL,DM,DP,DR,DB, DW or DU)."<200> ;005
	  .ASCII "Type <CR> to refresh the system disk."<200>
10$:	  .ASCIZ <177><12>"Disk? "
	  UNORG
	MOV	SYSUSV,R0	;PREPARE FOR SYSTEM DISK
	MOV	SYNXSV,R5	;SYSTEM INDEX IN R5
	CLR	CLNDBG		; Clear debug mode flag			;008
	CMP	(R1),#12	;LINE FEED?
	BEQ	140$		;YES, SYSTEM DISK IS SET UP, GO CLEAN IT
	MOV	R1,R5		;COPY TEXT POINTER
	CMPB	(R1),#'R	;DISK NAME WITH AN 'R' ?
	BNE	20$		;NO
	MOVB	#'D,(R1)	;YES, FIX IT
20$:	TSTB	(R5)+		;SCAN TO THE END
	BNE	20$
	DEC	R5		;Check for				;008
	CMPB	-(R5), #'D	; a "D" ?				;008
	BNE	23$		; Nope					;008
	CMPB	-1(R5), #'/	; a "/" ?				;008
	BNE	23$		; Nope					;008
	CLRB	-(R5)		; Yep, remove it			;008
	COM	CLNDBG		; Set switch flag			;008
	DEC	R5		;Check for				;008
23$:	CMPB	(R5),#':	; trailing colon			;008
	BNE	30$		;NONE
	CLRB	(R5)		;REMOVE IT
30$:	MOV	#DSKNAM,R5	;POINT TO TABLE OF VALID DISK NAMES
40$:	CMP	(R1),(R5)+	;IS THIS IT?
	BEQ	60$		;YUP
	TST	(R5)		;NO, ANY MORE TO CHECK?
	BNE	40$		;YES, DO SO
50$:	MESSAGE	<"Illegal disk name"<200>>
	BR	REFASK		;TRY AGAIN

60$:	SUB	#DSKNAM+2,R5	;COMPUTE DISK INDEX
	TST	DSKCSR(R5)	;DOES IT EXIST?
	BNE	80$		;YES
70$:	MESSAGE	<"Sorry, but that disk doesn't exist"<200>>
	BR	REFASK		;TRY AGAIN

80$:	MOV	(R1)+,R4	;SET R4<>0, POP R1
	MOV	R1,-(SP)	;SAVE OUR TEXT POINTER
	MOVB	@SUBUNT(R5),R3	;GET MAX UNIT NO. FOR CONTROLLER
	MOV	R3,R0		;PUT IN R0 FOR DECSTR
	MOV	#100$,R1	;R1 -> PLACE TO STORE ASCII TEXT
	CALLX	DECSTR		;  AND CONVERT MAX UNIT TO ASCII
	CLR	R0		;SET DEFAULT UNIT NO. TO 0
	MOV	(SP)+,R1	;NOW RESTORE THE TT INPUT TEXT POINTER
	TSTB	(R1)		;UNIT NO. IN STRING?
	BNE	110$		;UNIT IS SUPPLIED SO PARSE THE UNIT NUMBER
	CMP	R5,#IDX$DF	; UNIT # NOT GIVEN.  HAVE UNITS?
	BLOS	140$		;NO, USE 0 AND DON'T ASK
	CLR	R4		;FLAG FOR UNIT FROM UNIT QUESTION

GLOBAL	<SYSUSV,SYNXSV,DSKNAM,DSKCSR,CLNDBG>				;008

90$:	CALLX	ASKER,R5	;ASK FOR A UNIT
	 GENTXT	<"Unit? ">
	 GENTXT
	 .ASCII	"Physical unit number (0-"
100$:	 .ASCIZ	"??????)? "
	UNORG
110$:	CALLX	DECINP		;GET DECIMAL NUMBER
120$:	TSTB	(R1)		;END OF STRING?
	BNE	130$		;NO, ERROR IN UNIT NUMBER
	CMPB	R0,@SUBUNT(R5)	;TOO BIG?
	BLO	140$		;IT'S OK
130$:	TST	R4		;UNIT NUMBER IN FIRST RESPONSE?
	BEQ	50$		;YES, REPEAT THAT QUESTION
	MESSAGE	<"Invalid unit number"<200>>
	BR	90$		;TRY AGAIN

140$:	TST	R5		;WERE WE BOOTED FROM TAPE
	BMI	50$		;CAN'T ALLOCATE FILES ON TAPE
	MOV	R0,R1		;COPY THE DISK UNIT NUMBER
	ASL	R0		;DOUBLE IT
	MOV	R0,R2		;COPY THAT
	ADD	DSKSZL(R5),R0	;R0 -> LSB OF DISK SIZE
	ADD	DSKSZM(R5),R2	;R2 -> MSB OF DISK SIZE
	MOV	(R2),R2		;R2 = MSB SIZE
	BIS	(R0),R2		;ZERO SIZE?
	BEQ	70$		;NO SUCH DISK
	MOV	R5,R0		;R0 = DISK INDEX, R1 = UNIT
	CALLX	SETFNS		;SET NON-SYSTEM DISK IN FIP TABLES
	CALLX	LKBADB		;LOOK FOR THE BAD BLOCK FILE
	BCS	150$		;NOT THERE, THAT'S NOT GOOD
	CALLX	LKSATT		;FIND SATT.SYS N THIS DISK
	BCC	PRECLN		;GOT IT, SEE IF DISK NEEDS CLEANING
150$:	MESSAGE	<"Cannot REFRESH this disk"<200>>
	BR	REFASK		;AND TRY AGAIN

.DSABL	LSB

GLOBAL	<DSKSZL,DSKSZM,SUBUNT>


.SBTTL	CLEAN THE DISK IF NECESSARY OR REQUESTED

.ENABL	LSB

PRECLN:	CALL	CLNCHK,R5	;CHECK FOR REQUIRED CLEANING
	 BR	SUBOPT		;REQUIRED AND DONE, DO A SUBOPTION
10$:	CALLX	ASKER,R5	;NOT REQUIRED, ASK IF WE SHOULD
	 .WORD	20$		;SHORT FORM
	 GENTXT
	  .ASCII "Type 'YES' if you want the disk rebuilt before REFRESHing."<200> ;002
	  .ASCII "Type 'NO' to skip the rebuild operation."<200>	;002
20$:	  .ASCIZ <177><12>"Rebuild? "
	  UNORG
	CMPB	(R1),#'Z-100	;^Z ?
REFASL:	BEQ	REFASK
	CALLX	ANSWER,R5	;CHECK THE REPLY
	 BR	30$		;'Y' - CLEAN IT
	 BR	SUBOPT		;'N' - DON'T
	 BR	SUBOPT		;<LF> - DON'T
	 BR	SUBOPT		;'O' - DON'T
	MESSAGE	<"Invalid response"<200>>
	BR	10$		;TRY AGAIN

30$:	CALL	CLEANY		;CLEAN IT

.DSABL	LSB


.SBTTL	REFRESH SUBOPTION MAIN LOOP

.ENABL	LSB

SUBOPT:	CALL	CLNCHK,R5	;CLEAN THE DISK IF IT IS NOW DIRTY
	 NOP			; ELSE IGNORE IT
	CLR	REFSYS		;SAY THAT WE AREN'T DOING THE SYSTEM DISK
	CMP	SYSNDX,SYNXSV	;IS THIS REALLY THE SYSTEM DISK?
	BNE	10$		;NO
	CMP	SYSUNT,SYSUSV	;IS IT, NOW?
	BNE	10$		;NO
	COM	REFSYS		;YES, SET THE FLAG
10$:	CALLX	ASKER,R5	;ASK FOR A SUBOPTION
	 .WORD	20$		;SHORT FORM
	 GENTXT
	 .ASCII	<12>
	 .ASCII	"  Valid REFRESH suboptions are:"<200><12>
	 .ASCII	"  LIST    List the file status table"<200>
	 .ASCII	"  FILE    Change the characteristics of a file in [0,1]"<200>
	 .ASCII	"  BADS    Examine or change the bad block file"<200>
	 .ASCII	"  EXIT    (or <CR>) to exit from REFRESH"<200>
	 .ASCII	<12>
	 .ASCII	"  Only the first two characters need be typed"<200>
20$:	 .ASCIZ	<177><12>"  REFRESH suboption? "
	UNORG
	CMP	(R1),#12	;LINE FEED?
	BEQ	REFEXI
	CMP	(R1),#'Z-100	;^Z ?
	BEQ	REFASL		;YES, GET ANOTHER DISK
	CALLX	GETUNQ,R5,REFOTX ;SCAN THE ANSWER
	CALL	@REFOPT(R0)	;DO THE SUBOPTION
	BR	SUBOPT		;ASK FOR MORE

OPTION	EX,IT
	EXIT			;EXIT FROM REFRESH

.DSABL	LSB

	TMPORG	REFCTL
REFSYS:	.WORD	0		;<>0 IF REFRESHING THE SYSTEM DISK
PREST1:	.WORD	0		;<>0 IF INCOMING PRIMARY ANSWER
PREST2:	.WORD	0		;<>0 IF INCOMING SECOND ANSWER
	UNORG

GLOBAL	<SYSNDX,SYNXSV,SYSUNT,SYSUSV>


OPTION	BA,DS

.ENABL	LSB

	MOVB	(R1),PREST1	;ANSWER ALREADY THERE?
	BNE	30$		;YES, DON'T ASK
10$:	CALLX	ASKER,R5	;ASK FOR WHAT TO DO
	 .WORD	20$		;SHORT TEXT
	 GENTXT
	   .ASCII "    Type 'LIST' to list clusters currently in the bad block file."<200>
	   .ASCII "    Type 'ADD' to add a cluster to the bad block file."<200>
	   .ASCII "    Type 'EXIT' (or <CR>) to continue with the REFRESH dialogue."<200>
20$:	   .ASCIZ <177><12>"    Bads? "
	   UNORG
30$:	CALLX	GETUNQ,R5,BADOTX ;GET BADS THING TO DO
	BCS	50$		;BADDIE
	MOV	R1,-(SP)	;PRESERVE R1
	MOV	#FCBADB,R1	;R1 -> FCB FOR BADB.SYS
	CALLX	RNB		;MAKE SURE NAME ENTRY IS HERE
	MOV	(SP)+,R1	;RESTORE TEXT POINTER
	CALL	@BADOPT(R0)	;DO THE THING
40$:	TSTB	PREST1		;PRESET ANSWER?
	BEQ	10$		;NO, LOOP
	RETURN			;YES, EXIT

50$:	MESSAGE	<"    Invalid response"<200>>,INVRES
	BR	40$		;TRY AGAIN

BADOPT:	.WORD	BBLIST,BBADD ,BBEXIT,BBEXIT,BBEXIT

	I.MESS
BADOTX:	UNQTXT	<LI\ST>
	UNQTXT	<AD\D>
	UNQTXT	<EX\IT>
	.BYTE	12,377
	.BYTE	'Z-100,377
	.BYTE	0
	UNORG

BBEXIT:	TST	(SP)+		;DUMP DISPATCH CALL FROM BADS
	RETURN

.DSABL	LSB

GLOBAL	<FCBADB>


.SBTTL	BAD BLOCK LISTER

.ENABL	LSB

BBLIST:	MOV	UAR(R5),R3	;R3 = LINK TO RETRIEVAL ENTRY
	BNE	10$		;IF ANY
	MESSAGE	<<12>"    There are no bad blocks."<200>>
	RETURN

10$:	MESSAGE	<<12>"    Pack cluster size = ">
	MOV	PCS,R0		;R0 = PCS TO PRINT
	CALLX	DECZER		;PRINT IT
	MESSAGE
	 .ASCIZ	<200><12>"    Bad clusters begin at logical block numbers:"<200><12>
	 UNORG
20$:	CALLX	RDB		;READ A RETRIEVAL ENTRY
	MOV	(R5)+,-(SP)	;SAVE THE LINK
30$:	MOV	(R5)+,R2	;R2 = RP OF BAD BLOCK
	BEQ	60$		;NO MORE
	CLR	R3		;R3 = 0 FOR MULTIPLY
	MOV	DCS,R0		;R0 = DCS TO MULTIPLY BY
40$:	ASR	R0		;SHIFT DCS
	BCS	50$		;COMPUTE RP * DCS = LBN
	ASL	R2		;SHIFT LSB
	ROL	R3		; AND MSB
	BR	40$

50$:	CALLX	DBLPRT		;PRINT IT
	BIT	R5,#17		;END OF THIS R.E.?
	BEQ	60$		;YES, TRY FOR ANOTHER
	MESSAGE	<<11>>		;TYPE A TAB
	BR	30$		;TYPE ANOTHER R.P.

60$:	CALLX	TYPECR		;NEW LINE FOR NEW R.E.
	MOV	(SP)+,R3	;R3 = LINK TO NEXT R.E.
	BIC	#17,R3		;MINUS FLAG BITS
	BNE	20$		;READ IT AND CONTINUE
	RETURN			;DONE

.DSABL	LSB

GLOBAL	<PCS,DCS>


.SBTTL	BAD BLOCK ADDER

.ENABL	LSB

BBADD:	CALL	GETSAT		;ENSURE A GOOD SATT FOR GDB
	MOVB	(R1),PREST2	;ANSWER IN LINE?
	BNE	40$		;YES, USE IT
10$:	TSTB	PREST2		;ANSWER ALREADY USED?
	BNE	30$		;YES, SO EXIT NOW
	CALLX	ASKER,R5	;ASK FOR THE BAD BLOCK NUMBER
	 .WORD	20$		;SHORT TEXT
	 GENTXT
	  .ASCII <12>
	  .ASCII "    Type the logical block number of the bad block."<200>
	  .ASCII "    Type <CR> if there are no more bad blocks to add."<200>
20$:	  .ASCIZ <177><12>"    Block number? "
	  UNORG
	CALLX	GETUNQ,R5,BADOTX ;SCAN FOR AN EXIT
	BCS	40$		;NOT FOUND
	CMP	BADOPT(R0),#BBEXIT ;WAS IT 'EXIT', <LF>, OR ^Z?
	BNE	40$		;NO
30$:	RETURN

40$:	CALLX	DBLINP		;GET IT
	BEQ	50$		;AN OK NUMBER
	MESSAGE	<"    Illegal number"<200>>
	BR	10$		;TRY AGAIN

50$:	MOV	R2,-(SP)	;SAVE THE D.P. BLOCK NUMBER
	MOV	R3,-(SP)
	CMP	R3,SYSSZM	;MSB TOO BIG?
	BHI	60$		;YES
	BLO	70$		;NO, IT'S OK
	CMP	R2,SYSSZL	;EQUAL, COMPARE THE LSB
	BLO	70$		;LOW IS OK
60$:	CMP	(SP)+,(SP)+	;DUMP THE D.P. BLOCK NUMBER
	MESSAGE	<"    Logical block number invalid"<200>>
	BR	10$		;TRY AGAIN

70$:	MOV	DCS,R0		;DIVIDE BY DCS TO GET R.P.
80$:	ASR	R0		;SHIFT DCS FOR DIVIDE
	BCS	90$		;DONE
	;CLC
	ROR	R3
	ROR	R2
	BR	80$

GLOBAL	<SYSSZM,SYSSZL,DCS>


90$:	MOV	R2,R4		;COPY THE DCN TO R4
	BEQ	60$		;IT IS 0, BOOT HIM
	DEC	R4		;REDUCE BY ONE FOR PCN*CLURAT
	MOV	CLURAT,R3	;GET THE CLUSTER RATIO
	DEC	R3		;MAKE IT A MASK
	BIC	R3,R4		;ENSURE THAT DCN IS A PCN MULTIPLE
	BEQ	60$		;PCN = 1 (PACKID PCN) IS ALSO INVALID	;002
	INC	R4		;BACK TO DCN
	MOV	(SP)+,R3	;RESTORE THE D.P. BLOCK NUMBER
	MOV	(SP)+,R2
100$:	MESSAGE	<<177><12>"    Really add logical block ">
	CALLX	DBLZER		;PRINT IT
	MESSAGE	<" to BADB.SYS? ">
	CALLX	GETIN		;WELL, SAY SOMETHING
	TSTB	(R1)		;NEED HELP?
	BEQ	110$		;YES
	CMP	(R1),#'?	;MAYBE
	BNE	120$		;NO
110$:	MESSAGE
	 .ASCIZ	<12>"    Type 'Y' to add the block, anything else to abort the add"<200>
	 UNORG
	BR	100$		;TRY AGAIN

120$:	CMPB	(R1),#'Y	;YES?
	BEQ	130$		;YES
	MESSAGE	<"    Block not added"<200>>
	BR	10$		;TRY AGAIN

130$:	MOV	UAA(R5),-(SP)	;SAVE LINK TO BADB.SYS ACCOUNTING ENTRY
	CLR	R2		;LINK TO PREVIOUS R.E. = 0
	MOV	UAR(R5),R3	;R3 = LINK TO FIRST R.E.
140$:	BIC	#17,R3		;REMOVE FLAG BITS
	BEQ	180$		;END OF CHAIN, GET A NEW R.E. TO ADD
	MOV	R3,R2		;REMEMBER LINK TO THIS R.E.
	CALLX	RDB		;GET THE R.E.
	MOV	(R5)+,R3	;R3 = LINK TO NEXT R.E.
150$:	TST	(R5)		;END OF ENTRIES?
	BEQ	170$		;YES, FILL UP THIS HOLE
	CMP	R4,(R5)+	;NO, IS THIS CLUSTER ALREADY IN BADB.SYS
	BEQ	160$		;YES, DON'T REPRODUCE IT
	BIT	R5,#17		;NO, END OF R.E.?
	BNE	150$		;NO, TRY FOR ANOTHER IN THIS R.E.
	BR	140$		;GET A NEW R.E. IF ANY

160$:	TST	(SP)+		;REMOVE THE A.E. LINK
	MESSAGE	<"    That cluster is already allocated to BADB.SYS."<200>>
	BR	220$		;TRY AGAIN

170$:	MOV	R4,(R5)		;FILL UP THE HOLE IN THE R.E.
	BR	210$		;AND EXIT

GLOBAL	<CLURAT>


180$:	CALLX	GDB		;GET A DIRECTORY ENTRY
	BCC	190$		;GOT IT
	MESSAGE	<"    Too many bad blocks!"<200>>
	TST	(SP)+		;REMOVE A.E. LINK
	RETURN			;DON'T ADD ANY MORE

190$:	MOV	R4,2(R5)	;SET FIRST R.P. IN THIS R.E.
	MARK	FIBUF		;REWRITE FIBUF
	MOV	R3,-(SP)	;SAVE LINK TO THIS NEW R.E.
	MOV	R2,R3		;GET LINK TO PREVIOUS R.E.
	BEQ	200$		;NONE, REREAD THE N.E. AND FILL FIRST
	CALLX	RDB		;RETRIEVE THE PREVIOUS R.E.
	MOV	(SP)+,(R5)	;LINK IT TO THE NEW ONE
	BR	210$		;DONE, UPDATE THE SIZE

200$:	MOV	#FCBADB,R1	;POINT TO THE FCB FOR THE BAD BLOCKS
	CALLX	RNB		;GET THE NAME ENTRY
	MOV	(SP)+,UAR(R5)	;LINK IT TO THE FIRST R.E.
210$:	MOV	(SP)+,R3	;RESTORE THE LINK TO THE A.E.
	CALLX	RDS		;GET IT
	MOV	I.DATE,UDLA(R5)	;SET DATE OF LAST ACCESS
	ADD	PCS,USIZ(R5)	;ADD A CLUSTER OF BLOCKS
	MARK	FIBUF		;FORCE OUT FIBUF LATER
	CALLX	READPL		;Get the pack label			;002
	BIS	#UC.MNT,FIBUF+PSTAT ;THE DISK WILL NEED CLEANING	;002
	CALLX	WRITE		;FORCE OUT THE PACK LABEL NOW
220$:	MOV	#FCBADB,R1	;REREAD THE NAME ENTRY FOR BADB.SYS
	CALLX	RNB
	JMP	10$		;AND TRY FOR ANOTHER BAD BLOCK

.DSABL	LSB

GLOBAL	<FCBADB,I.DATE,PCS,FIBUF>


OPTION	FI,LE

.ENABL	LSB

	MOV	#FQ...,R4	;POINT TO FIRQB
	CALL	CLNFQB		;ENSURE THAT THE EXTENDED WORDS ARE 0
	MOVB	(R1),PREST1	;ANSWER PRESET?
	BNE	40$		;YES
10$:	CALL	CLNFQB		;REALLY MAKE SURE FIRQB IS CLEAN
	TSTB	PREST1		;SECOND TIME AROUND?
	BNE	30$		;YES, PRESET ANSWER CAUSES RETURN
	CALLX	ASKER,R5	;ASK FOR FILE NAME
	 .WORD	20$		;SHORT FORM
	 GENTXT
	  .ASCII "    Type the NAME.TYP of a file in [0,1] to be created,"
	  .ASCII " deleted, or changed."<200>
20$:	  .ASCIZ <177><12>"    File name? "
	 UNORG
	CMP	(R1),#12	;LINE FEED?
	BEQ	30$		;YES, RETURN
	CMP	(R1),#'Z-100	;^Z ?
	BNE	40$		;NO, IT'S A NAME
30$:	RETURN

40$:	MOV	#FILNMB,R4	;POINT TO FILE NAME BUFFER
	MOV	R4,R5		;COPY FOR LATER
	CALLX	RADINP		;GET NAME AS 2 WORDS RAD50
	MOV	R0,(R4)+	;PUT INTO BUFFER
	BEQ	50$		;NO NAME IS BAD NAME
	MOV	R3,(R4)+
	CMPB	(R1)+,#'.	;DOT SEPARATOR?
	BNE	50$		;NO, BAD NAME
	CALLX	RADWRD		;GET ONE WORD RAD50 FOR EXT
	MOV	R0,(R4)+	;SET IT
	TSTB	(R1)		;END OF STRING?
	BEQ	60$		;YES, USE THE NAME
50$:	MESSAGE	<"    Illegal file name"<200>>,MESIFN
	BR	10$		;TRY AGAIN

GLOBAL	<FQ...>


60$:	CALLX	LOKN..		;LOOK FOR FILE WITH NAME @ R5 IN FQ...
	BCS	90$		;IT DOESN'T EXIST, DON'T ASK DELETE!
	CALL	CHKREQ		;IS IT PART OF THE MINIMAL STRUCTURE?
	BCS	10$		;YES, TRY AGAIN
70$:	CALLX	ASKER,R5	;ASK IF HE WANTS TO DELETE IT
	 .WORD	80$		;SHORT FORM
	 GENTXT
	  .ASCII "    Type 'YES' to delete the file, 'NO' to retain it."<200>
80$:	  .ASCIZ <177><12>"    File exists. Delete it? "
	 UNORG
	CMP	(R1),#'Z-100	;^Z ?
	BEQ	10$		;YES, QUIT NOW
	CALLX	ANSWER,R5	;SORT OUT THE ANSWER
	 BR	170$		;YES, DELETE IT
	 BR	90$		;NO, RETAIN IT
	 BR	90$		;<LF>, RETAIN IT
	 BR	90$		;OLD, RETAIN IT
	CALLX	MESSAGE,R5,INVRES
	BR	70$		;TRY AGAIN

	TMPORG	REFCTL
FILNMB:	.BLKW0	3		;ROOM FOR THE FILE NAME
	UNORG

85$:	MESSAG	<<200>"    Can not change or move .RTS or .SIL with REFRESH"<200>>
	BR	10$		;so, try for a different file name

90$:	CMP	R0, #^RRTS	;is the extension .RTS?	(don't try to reallocate )
	BEQ	85$		;yes, don't move it!!!	(files containing code,  )
	CMP	R0, #^RSIL	;no, is it .SIL?	(Refresh won't do it     )
	BEQ	85$		;Yes, don't try to move it, otherwise,
	MOV	#190$,R5	;R5 -> PLACE TO CALL FOR MINIMUM
	CALL	ASKSB		;ASK SIZE AND BASE
	BCS	10$		;^Z TYPED, EXIT FROM THIS FILE
	MOV	FQPROT-1(R4),-(SP) ;SAVE THE JUST CREATED PROT & STATUS
	BIC	#^C<US.PLC>,(SP);ISOLATE THE FILE PLACED BIT
	MOV	#77*400+US.NOX+US.NOK,FQPROT-1(R4) ;RESET PROT & STATUS
	BISB	(SP)+,FQPROT-1(R4) ;RESTORE THE FILE PLACED BIT
	BIT	#FS.OPN,FQSTAT(R4) ;DOES THE FILE EXIST?
	BEQ	100$		;NO, DON'T FIX THE PROT BYTE
	MOVB	FQFCB+DDSTS(R4),R0 ;YES, GET THE OLD STATUS
	BICB	#^C<US.NOK>,R0	;ISOLATE THE 'NO KILL' BIT
	BICB	#US.NOK,FQPROT-1(R4) ;REMOVE 'NO KILL' BIT FROM NEW STAT
	BISB	R0,FQPROT-1(R4)	;SET UP THE OLD


100$:	MESSAGE	<<177><12>"    Deletable? ">
	CALLX	GETIN		;GET REPLY
	CMP	(R1),#'Z-100	;^Z ?
	BEQ	10$		;YES, GET OUT
	CMPB	(R1),#'?	;WANT HELP?
	BNE	120$		;NO, USE THE REPLY
	MESSAGE	<"    The file is currently ">
	BITB	#US.NOK,FQFCB+DDSTS(R4) ;YES, WHAT IS IT NOW?
	BEQ	110$		;DELETABLE NOW
	MESSAGE	<"not ">
110$:	MESSAGE
	 .ASCII	"deletable during timesharing."<200>
	 .ASCII "    Type 'NO' if you want it marked so that it cannot be deleted"<200>
	 .ASCII	"    or renamed during normal timesharing operations."<200>
	 .ASCIZ	"    Type 'YES' if you want it to be deletable."<200>
	 UNORG
	BR	100$		;ASK AGAIN

120$:	CALLX	ANSWER,R5	;SORT OUT THE ANSWER
	 BR	130$		;YES, DELETABLE
	 BR	140$		;NO, NOT DELETABLE
	 BR	150$		;<LF>, NO CHANGE
	 BR	150$		;OLD, NO CHANGE
	CALLX	MESSAGE,R5,INVRES
	BR	100$		;TRY AGAIN

130$:	BICB	#US.NOK,FQPROT-1(R4) ;MAKE IT DELETABLE
	BR	150$

140$:	BISB	#US.NOK,FQPROT-1(R4) ;MAKE IT UNDELETABLE
150$:	BIT	#FS.OPN,FQSTAT(R4) ;DOES IT EXIST NOW?
	BEQ	170$		;NO, DON'T CHECK FOR SIMPLE CHANGE
	CMP	FQFCB+FCSIZ(R4),FQSIZN(R4) ;SAME SIZE?
	BNE	170$		;NO, DELETE & RECREATE
	MOV	FQPREF(R4),R1	;GET PREFERRED LOCATION ON DISK
	BEQ	160$		;NONE, THIS IS A SIMPLE CHANGE
	MUL	CLURAT,R1	;COMPUTE DCN FROM PCN
	INC	R1
	CMP	R1,FQFCB+FCWND+2(R4) ;SAME DCN REQUESTED (OLD) ?
	BNE	170$		;NOPE, DELETE & RECREATE TO MOVE IT

GLOBAL	<CLURAT>


160$:	MOV	#FC...,R1	;NO, A SIMPLE STATUS BYTE CHANGE
	CALLX	RNB		;GET NAME ENTRY OF FILE
	MOVB	FQPROT-1(R4),R0	;GET NEW 'NO KILL' VALUE
	BICB	#^C<US.NOK>,R0	;ISOLATE 'NO KILL' BIT
	BICB	#US.NOK,USTAT(R5) ;REMOVE OLD 'NO KILL' BIT
	BISB	R0,USTAT(R5)	;PUT IN THE NEW ONE
	CALLX	WRITE		;REWRITE THE DIRECTORY
	BR	180$		;GET OUT

170$:	MOV	R4,FQ1		;SET UP LOOPFQ TO DO ONLY THIS FIRQB
	MOV	R4,FQN
	CALL	CHANGE		;DO THE CHANGES ON THE DISK
180$:	JMP	10$		;LOOP FOR ANOTHER FILE

190$:	MOV	#1,R0		;GET MINIMUM SIZE FOR ASKER
	RETURN

.DSABL	LSB

GLOBAL	<FC...>


OPTION	LI,ST

.ENABL	LSB

	CLR	OTHFIL		;NOT DOING NON-SYSTEM FILES NOW
	MESSAGE
.ASCII	<177><12>
.ASCII	"  File                 File         Current  Minimum    Start"<200>
.ASCII	"  Name      Required?  Flags Status   Size     Size      LBN"<200>
.ASCII	<12>
.ASCII	"System files:"<200>
.ASCIZ	<12>
	 UNORG
	MOV	#SYSLST,R4	;R4 -> LIST OF SYSTEM FILES
10$:	CMP	-(SP),-(SP)	;Get some stack space			;006
	MOV	(R4)+,-(SP)	;Push name part 1			;006
	MOV	(R4)+,2(SP)	; and part 2				;006
	MOV	(R4)+,4(SP)	;  and extension			;006
	MOV	#0*400+1,-(SP)	;Push PPN				;006
	MOV	SP,R0		;POINT TO PPN + FILNAM.EXT
	CALLX	SDU		;LOOK FOR IT ON THE DISK
	BCC	20$		;FOUND IT, R5 -> NAME ENTRY
	MOV	R0,R5		;NOT THERE, POINT R5 AT NAME HERE
20$:	TST	(R5)+		;R5 -> FIRST WORD OF RAD50 NAME
	CALL	FPRINT		;PRINT A FILE'S STATUS
	ADD	#10,SP		;Pop filename				;006
	ADD	#SYSLSZ-6,R4	;POINT TO NEXT SYSTEM FILE
	TST	CTLOFG		;DID HE ^O THIS SECTION?
	BNE	30$		;YES, QUIT FAST WITH NO CHECKING
	TST	(R4)		;ANY MORE?
	BNE	10$		;YES, DO ANOTHER
30$:	MESSAGE	<<177><12>"Others:"<200><12>>
	COM	OTHFIL		;NOW DOING NON-SYSTEM FILES
	MOV	#0*400+1,-(SP)	;Push [0,1] PPN				;006
	MOV	SP,R0		; and point to it			;006
	CALLX	RUF		;READ THE UFD				;006
	TST	(SP)+		;Pop the PPN				;006
	MOV	FIBUF,R3	;R3 = LINK TO FIRST FILE
40$:	CALLX	RDB		;GET IT
	MOV	(R5)+,R3	;R3 = LIK TO NEXT FILE
	BITB	#US.DEL!US.UFD,USTAT(R5) ;NOT REALLY A FILE?
	BNE	70$		;NOT REALLY, SO SKIP IT
	MOV	#SYSLST,R4	;DID WE ALREADY LIST THIS GUY?
50$:	CMP	(R5),(R4)+	;TO FIND OUT, CHECK THE NAME.TYP
	BNE	60$		;NOT THIS ONE
	CMP	2(R5),(R4)	;2ND NAME WORD
	BNE	60$		;NO
	CMP	4(R5),2(R4)	;EXTENSION?
	BEQ	70$		;ALREADY DONE, SKIP IT HERE

GLOBAL	<CTLOFG,FIBUF>


60$:	ADD	#SYSLSZ-2,R4	;POINT TO NEXT SYSTEM FILE
	TST	(R4)		;ANY MORE?
	BNE	50$		;YES, IT STILL MIGHT BE ONE
	MOV	#90$,R4		;POINT R4 AT A DUMMY SIZE GETTER
	CALL	FPRINT		;AND PRINT THE FILE STATUS
70$:	TST	CTLOFG		;DID HE ^O THIS SECTION?
	BNE	80$		;YES, QUIT FAST
	BIC	#17,R3		;REMOVE FLAG BITS FROM LINK TO NEXT
	BNE	40$		;IF ANY, DO THEM
80$:	CALLRX	TYPECR		;A NEW LINE AND EXIT TO SUBOPTION

90$:	.WORD	.+2		;DUMMY ROUTINE FOR OTHER FILES
	CLR	R0		;SIZE = 0, CARRY = 0 FOR NOT REQUIRED
	RETURN

.DSABL	LSB

	TMPORG	REFCTL
OTHFIL:	.WORD	0		;<>0 IF LISTING NON-SYSTEM FILES
	UNORG

GLOBAL	<CTLOFG>


.SBTTL	PRINT A FILE'S STATUS LINE

.ENABL	LSB

FPRINT:	REGSCR			;SAVE ALL REGISTERS
	CALLX	MESSAGE,R5,B2	;2 BLANKS
	CLR	-(SP)		;ROOM FOR STARTING DEVICE CLUSTER NUMBER
	CALL	@(R4)+		;CALL FOR REQUIRED, MIN SIZE
	MOV	R0,-(SP)	;STACK THE REQUIRED SIZE
	BIC	-(SP),(SP)	;MAKE ROOM FOR THE FILE'S CURRENT SIZE
	MOV	R5,-(SP)	;SET NON-0 POINTER TO NAME ON STACK
	ROR	(SP)		;SAVE CARRY, ON IF FILE IS REQUIRED
	MOV	(R5)+,R0	;GET AND PRINT THE FILE NAME
	CALLX	RADPRT		;PRINT IN RAD50
	MOV	(R5)+,R0
	CALLX	RADPRT
	TYPE	<'.>		;SEPARATOR
	MOV	(R5)+,R0
	CALLX	RADPRT
	CALLX	MESSAGE,R5,B3	;3 BLANKS
	MOV	#^RYES,R0	;ASSUME REQUIRED IS YES
	TST	(SP)		;TRUE?
	BMI	10$		;TRUE
	MOV	#^R NO,R0	;NO, FALSE
10$:	BIC	OTHFIL,R0	;BUT PRINT BLANKS IF NOT A SYSTEM FILE
	CALLX	RADPRT		;PRINT REQUIREDNESS
	CMP	R5,#FIBUF	;Pointing below FIBUF?			;006
	BLO	15$		;Yes, so not a found file		;006
	CMP	R5,#FIBUF+1000	;IS THE FILE NAME IN A NAME ENTRY?
	BLO	20$		;YUP, THE FILE EXISTS
15$:	CLR	R5		;NO, SET A FLAG				;006
	BIC	#077777,(SP)	;ALSO ON THE STACK
20$:	CALLX	MESSAGE,R5,B3	;TYPE 3 BLANKS
	CLR	R0		;FIRST WORD OF FILE FLAGS IS 0
	CLR	R2		;2ND WORD OF FILE FLAGS IS 0
	CLR	R4		;ASSUME FILE IS CONTIGUOUS
	TST	R5		;DOES THE FILE EXIST?
	BEQ	90$		;NO, FLAGS ARE TRULY BLANK
	BIT	#US.NOX,(R5)	;TRULY CONTIGUOUS?
	BNE	30$		;YES
	COM	6(SP)		;NO, NEVER PRINT START LBN
30$:	BIT	#US.NOK,(R5)+	;IS THE FILE NON-DELETABLE?
	BEQ	40$		;NO, IT IS DELETABLE
	MOV	#^RNOD,R2	;SECOND WORD OF FLAGS IS 'NOD'

GLOBAL	<FIBUF>


40$:	TST	(R5)+		;SKIP ACCESS COUNT
	MOV	(R5)+,R3	;R3 = LINK TO ACCOUNTING ENTRY
	MOV	(R5)+,-(SP)	;SAVE LINK TO RETRIEVAL ENTRY
	CALLX	RDB		;READ THE ACCOUNTING ENTRY
	MOV	USIZ(R5),2+2(SP) ;SAVE THE SIZE OF THE FILE IN THE HOLE
	MOV	UCLUS(R5),R1	;R1 = FILE CLUSTER SIZE
	MOV	(SP)+,R3	;GET LINK TO RETRIEVAL ENTRY
	BIC	#17,R3		;REMOVE FLAG BITS
	BEQ	90$		;A NULL FILE IS EASY. R0 STILL 0
	CALLX	RDB		;READ THE FIRST RETRIEVAL ENTRY
	DIV	DCS,R0		;COMPUTE # OF DEV CLUS/FILE CLU IN R0
	MOV	2(R5),R1	;R1 = FIRST RETRIEVAL POINTER
	MOV	R1,R5		;COPY IT
	BIC	6(SP),R5	;BUT USE 0 IF NOT TRULY CONTIGUOUS
	MOV	R5,6(SP)	;SAVE RETRIEVAL POINTER ON THE STACK
50$:	CALLX	RDB		;READ THE (NEXT) RETRIEVAL ENTRY
	MOV	(R5)+,R3	;R3 = LINK TO NEXT
60$:	TST	(R5)		;A NULL ENTRY?
	BEQ	70$		;YES, DONE. IT IS CONTIGUOUS
	CMP	R1,(R5)+	;NO, DOES IT FIT IN THE CONTIG SCHEME?
	BNE	80$		;NOPE, GO RESET R0=0 SINCE R4 STILL 0
	ADD	R0,R1		;STILL OK, COMPUTE NEXT R.P.
	BIT	R5,#17		;DONE WITH THIS RETRIEVAL ENTRY?
	BNE	60$		;NO
	BIC	#17,R3		;YES, REMOVE FLAGS FROM LINK TO NEXT
	BNE	50$		;IF THERE IS A NEXT, DO IT
70$:	COM	R4		;R4 = -1 AS CONTIGUOUS FLAG
80$:	MOV	R4,R0		;SET R0 TO R4, R0=0 IF NOT CONTIGUOUS
	BEQ	90$		;NOT CTG, LEAVE R0=0
	MOV	R2,R0		;SET 'NOD' OR 0 IN R0
	MOV	#^RCTG,R2	;SET SECOND FLAG WORD TO 'CTG'
90$:	CALLX	RADPRT		;PRINT FIRST FLAG WORD FROM R0
	CALLX	MESSAGE,R5,B1	;BLANK
	MOV	R2,R0		;SECOND FLAG WORD
	CALLX	RADPRT
	CALLX	MESSAGE,R5,B3	;3 BLANKS
	MOV	(SP)+,R5	;GET REQUIRED/EXISTS FLAGS
	ASL	R5		;C=1 IF REQUIRED, R5<>0 IF EXISTS
	BEQ	100$		;ZERO IS ON IF IT DOESN'T EXIST
	MOV	(PC)+,R0	;ASSUME IT NEEDS DELETE/RECREATE
	 GENTXT	<"D/C">
	TST	R4		;IS THE FILE CONTIGUOUS?
	BEQ	110$		;NOPE, DELETE RECREATE IT IS
	CMP	(SP),2(SP)	;COMPARE ACTUAL : MINIMUM SIZE
	BLO	110$		;TOO SMALL, SO DELETE AND RECREATE

GLOBAL	<DCS>


	;CLC			;BLO BRANCHES IF C=1
100$:	MOV	(PC)+,R0	;ASSUME FILE NEEDS CREATION
	 GENTXT	<"CRE">
	BCS	110$		;REQUIRED, SO NECESSARY
	MOV	(PC)+,R0	;PRESENT,OK  OR  NOT PRESENT,OPTIONAL
	 GENTXT	<" OK">
110$:	TST	OTHFIL		;NOT A SYSTEM FILE?
	BEQ	120$		;SYSTEM FILE HAS STATUS
	MOV	#B3,R0		;ELSE PRINT BLANKS
120$:	CALLX	ASCIZ0		;PRINT THE STATUS
	MOV	(SP)+,R0	;R0 = TRUE SIZE
	MOV	(SP)+,R1	;R1 = MINIMUM SIZE
	MOV	(SP)+,R3	;R3 = STARTING DEVICE CLUSTER
	COM	R4		;R4 = -1 IF NOT CONTIGUOUS
	BIC	R4,R3		;SET START DCN = 0 IF NOT CONTIGUOUS
	TST	R5		;DOES THE FILE EXIST?
	BNE	130$		;YUP, PRINT ITS SIZE
	TST	R1		;NO, IS THERE A PRINTABLE MIN SIZE?
	BEQ	210$		;NO, WE ARE DONE HERE
130$:	CALLX	MESSAGE,R5,B3	;SPACE OVER FOR CURRENT SIZE
	TST	R5		;EXISTS?
	BNE	140$		;YUP, PRINT THE NUMBER
	CALLX	MESSAGE,R5,B6	;NO, SPACE OVER
	BR	150$

140$:	CALLX	DECPRT		;PRINT THE SIZE
150$:	MOV	R1,R0		;COPY THE MINIMUM SIZE
	BNE	160$		;IF ANY, PRINT IT
	TST	R3		;IF NONE, IS THERE A START DCN TO PRINT?
	BEQ	210$		;IF NOT, DONE WITH THIS LINE
160$:	CALLX	MESSAGE,R5,B3	;SPACE TO THE MINIMUM SIZE COLUMN
	TST	R0		;IS THE MIN SIZE = 0?
	BNE	170$		;NOPE, GOTTA PRINT IT
	CALLX	MESSAGE,R5,B6	;YES, PRINT 6 SPACES INSTEAD
	BR	180$

170$:	CALLX	DECPRT		;PRINT THE MINIMUM SIZE
180$:	MOV	R3,R2		;COPY THE STARTING DEVICE CLUSTER
	BEQ	210$		;IF NONE, DONE
	CALLX	MESSAGE,R5,B3	;SPACE TO START DCN COLUMN
	MOV	DCS,R0		;GET DEVICE CLUSTER SIZE
	CLR	R3		;HIGH ORDER = 0

GLOBAL	<DCS>


190$:	ASR	R0		;SHIFT DCS
	BCS	200$		;DONE MULTIPLYING
	;CLC
	ASL	R2		;SHIFT LEFT ONE
	ROL	R3
	BR	190$

200$:	CALLX	DBLPRT		;PRINT THE NUMBER IN R3/R2
210$:	CALLRX	TYPECR		;END OF LINE

.DSABL	LSB

	I.MESS
B6:	.ASCII	" "
B5:	.ASCII	" "
B4:	.ASCII	" "
B3:	.ASCII	" "
B2:	.ASCII	" "
B1:	.ASCIZ	" "
	UNORG


.SBTTL	GENERATE THE LIST OF SYSTEM FILES

.MACRO	SYSFIL	NAMEXT,REQMIN,TEXT
	.RAD50	/NAMEXT/
	.WORD	REQMIN
.IF	B	<TEXT>
	GENTXT			;OPEN A MESSAGE
.IFF
	.WORD	TEXT
.ENDC
.ENDM	SYSFIL

SYSLSZ	= 12

.ENABL	LSB

SYSLST:
SYSFIL	<SWAP  SYS>,MINSWP
10$:
.ASCII	"  No help available."<200>
UNORG

SYSFIL	<SWAP0 SYS>,MINZER,10$

SYSFIL	<SWAP1 SYS>,MINZER,10$

SYSFIL	<SWAP3 SYS>,MINZER,10$

SYSFIL	<OVR   SYS>,MINOVR,10$

SYSFIL	<ERR   SYS>,MINERR,10$

SYSFIL	<BUFF  SYS>,MINBUF,10$

SYSFIL	<CRASH SYS>,MINCRS,10$

SYSLSE:	.WORD	0		;END OF LIST

.DSABL	LSB

	TMPORG	REFCTL
FQBBUF:	.BLKW	<FQFCB+FCBSIZ>/2*20.
FQBBFE:
	UNORG


.SBTTL	RETURN FILE SIZE MINIMA

.ENABL	LSB

MINSWP:	MOV	SWPMIN,R0	;GET PRECOMPUTED MINIMUM
	TST	REFSYS		;REFRESHING SYSTEM DISK?
	BNE	20$		;YES, GO SET CARRY FOR REQUIRED FILE
MINZER:	CLR	R0		;MINIMUM SIZE = 0, C=0 FOR NOT REQUIRED
	RETURN

MINOVR:	MOV	OVRMIN,R0	;GET MINIMUM AS COMPUTED
10$:	CLC			;ENSURE C=0
	RETURN			;RETURN OPTIONAL FILE SIZE

MINERR:	MOV	#16.,R0		;ERR IS ALWAYS 16 BLOCKS
	BR	10$		; AND IS OPTIONAL

MINBUF:	TST	REFSYS		;REFRESHING THE SYSTEM DISK?
	BEQ	MINZER		;NO, NOT REQUIRED
	MOV	BUFMIN,R0	;GET MINIMUM AS COMPUTED
	BEQ	30$		;IF 0, THEN NOT REQUIRED (C=0 FROM TST)
20$:	SEC			;C=1 TO INDICATE REQUIRED FILE
30$:	RETURN

MINCRS:	MOV	CRSMIN,R0	;GET COMPUTED MINIMUM
	TST	REFSYS		;REFRESHING THE SYSTEM DISK?
	BEQ	MINZER		;NO, NOT REQUIRED
	RETURN

.DSABL	LSB

	TMPORG	REFCTL		;THE ORDER OF THE FOLLOWING IS VITAL
SWPMIN:	.WORD	0		;SWAP.SYS MINIMUM
OVRMIN:	.WORD	0		;OVR .SYS MINIMUM
BUFMIN:	.WORD	0		;BUFF.SYS MINIMUM
CRSMIN:	.WORD	0		;CRASH.SYS MINIMUM
	UNORG


.SBTTL	ASK FOR DELETE, SIZE, BASE

.ENABL	LSB

ASKDSB:	CALLX	LOKFIL		;R4 -> FIRQB. LOOK FOR THE FILE
	BCS	ASKSB		;NOT THERE, DON'T ASK DELETE
10$:	CALLX	ASKER,R5	;ASK IF HE WANTS IT DELETED
	 .WORD	20$		;SHORT TEXT
	 GENTXT
	  .ASCII "    Type 'YES' to delete the file, 'NO' to retain it."<200>
20$:	  .ASCIZ <177><12>"    Delete? "
	 UNORG
	CMP	(R1),#'Z-100	;^Z ?
	BEQ	40$		;YES, GET OUT WITH C=1
	CALLX	ANSWER,R5	;SORT OUT THE ANSWER
	 BR	30$		;YES, RETURN W/ FQSIZN(R4)=0 AS FLAG
	 BR	ASKSB		;NO, ASK SIZE & BASE
	 BR	ASKSB		;<LF>, ASK SIZE & BASE
	 BR	ASKSB		;OLD, ASK SIZE & BASE
	CALLX	MESSAGE,R5,INVRES ;INVALID RESPONSE
	BR	10$		;TRY AGAIN

30$:	TST	(PC)+		;CLEAR THE CARRY & RETURN
40$:	SEC			;SET THE CARRY AND RETURN
	RETURN


.SBTTL	ASK FOR SIZE AND BASE

45$:	MESSAG	<<200>"    Can not change or move .RTS or .SIL with REFRESH"<200>>
	BR	40$		;Set Carry and return.

50$:	CALLX	MESSAGE,R5,INVRES ;BAD REPLY TO SIZE, TRY AGAIN
ASKSB:	CMP	FQEXT(R4), #^RRTS ;don't allow SIZE or BASE changes to
	BEQ	45$		;.RTS's or .SIL's.  We must keep files
	CMP	FQEXT(R4), #^RSIL ;containing actual code intact, and in
	BEQ	45$		;place, or we risk corruption.
	CALL	(R5)		;GET MINIMUM SIZE
	MOV	R0,FQTMP1(R4)	;SAVE IT FOR LATER
	BIT	#FS.OPN,FQSTAT(R4) ;FILE EXISTS?
	BEQ	60$		;NO, DON'T CHECK CURRENT SIZE
	CMP	R0,FQFCB+FCSIZ(R4) ;YES, MINIMUM VS. CURRENT SIZE
	BLOS	60$		;CURRENT >= MINIMUM, SO OK
	MESSAGE	<<177><12>"    Warning - file is smaller than minimum of ">
	CALLX	DECZER		;PRINT THE MIN
	MESSAGE	<" blocks."<200>>
60$:	MESSAGE	<<177><12>"    Size? ">
	CALLX	GETIN		;GET ANSWER
	CMP	(R1),#'Z-100	;^Z ?
	BEQ	40$		;YES, RETURN C=1
	CMPB	(R1),#'?	;Want help?
	BNE	100$		;NOPE
	BIT	#FS.OPN,FQSTAT(R4) ;YES, IS IT THERE?
	BNE	80$		;YES
	MOV	FQTMP1(R4),R0	;MINIMUM = 0 ?
	BNE	70$		;NO, DEFAULT IS POSSIBLE
	MESSAGE	<"    Enter the file size in 512 byte blocks."<200>>
	BR	ASKSB		;AND DONE

70$:	MESSAGE	<"    Type 'OLD' or <CR> to default to the minimum">
	BR	90$

80$:	MESSAGE	<"    Type 'OLD' or <CR> to retain the existing">
	MOV	FQFCB+FCSIZ(R4),R0 ;ACTUAL SIZE TO R0
90$:	MESSAGE	<" size of ">
	CALLX	DECZER
	MESSAGE
	 .ASCII	" blocks."<200>
	 .ASCIZ	"    Otherwise, enter the file size in 256 word blocks."<200>
	 UNORG
	BR	ASKSB		;ASK AGAIN

100$:	MOV	FQFCB+FCSIZ(R4),R0 ;GET OLD SIZE
	BIT	#FS.OPN,FQSTAT(R4) ;DOES THE FILE EXIST?
	BNE	110$		;YES, IT HAS AN OLD SIZE
	MOV	FQTMP1(R4),R0	;NO, GET MINIMUM SIZE IN R0
110$:	CALLX	ANSWER,R5	;SORT OUT THE ANSWER
	 BR	50$		;YES - HUH?
	 BR	50$		;NO  - HUH?
	 BR	130$		;<LF> - USE OLD
	 BR	130$		;OLD - USE OLD
	CALLX	DECINP		;DECIMAL NUMBER INPUT
	BEQ	130$		;GOOD ANSWER USE AS IS


	CMPB	(R1)+,#'*	;IS IT OF THE FORMAT N*28K?
	BNE	50$		;SO FAR SO BAD
	MOV	R0,-(SP)	;SAVE N FOR MULTIPLY
	CALLX	DECINP		;GET MAX JOB SIZE
	CMPB	(R1),#'K	;DID HE SPECIFY THE K
	BNE	120$		;IF NOT DON'T CRY, JUST MULTIPLY
	MUL	#4,R0		;1K IS 4 BLOCKS
	MOV	R1,R0		;PUT RESULT IN R0
120$:	MUL	(SP)+,R0	;TIMES THE NUMBER OF JOBS
	MOV	R1,R0		;PUT RESULT IN R0
130$:	TST	R0		;MUST BE NON-0
	BEQ	50$		;OOPS
	MOV	R0,FQSIZN(R4)	;SET NEW SIZE IN FIRQB EXTENSION
	MOV	R0,R1		;GET IN R1 AND
	CALLX	FIXCLU		; CONVERT TO PACK CLUSTER COUNT
	MOV	R0,FQNPCL(R4)	;SAVE NUMBER OF PACK CLUSTERS
	CMP	FQSIZN(R4),FQTMP1(R4) ;TOO SMALL FOR MINIMUM?
	BHIS	ASKB		;NO, OK
	MESSAGE
	 .ASCIZ	"    Warning - size specified is smaller than minimum."<200>
	 UNORG
	BR	ASKB		;ASK FOR BASE


.SBTTL	ASK FOR BASE

140$:	CALLX	MESSAGE,R5,INVRES ;INVALID RESPONSE, TRY AGAIN
ASKB:	MESSAGE	<<177><12>"    Base? ">
	CALLX	GETIN		;GET ANSWER
	CMP	(R1),#'Z-100	;^Z ?
	BNE	145$		;No, go ahead
	JMP	40$		;Was ^Z, so exit with carry set
145$:	CMPB	(R1),#'?	;Want help?
	BNE	170$		;NO
	BIT	#FS.OPN,FQSTAT(R4) ;DOES IT ALREADY EXIST?
	BNE	150$		;YUP
	MESSAGE
	 .ASCIZ	"    Type 'OLD', '0', or <CR> to let RSTS find a location."<200>
	 UNORG
	BR	160$

150$:	MESSAGE
	 .ASCII	"    Type 'OLD' or <CR> to use the existing base."<200>
	 .ASCIZ	"    Type '0' to let RSTS find a location."<200>
	 UNORG
160$:	MESSAGE
	 .ASCII	"    Enter a logical block number to locate the file at a specific"<200>
	 .ASCIZ	"    place on the disk."<200>
	 UNORG
	BR	ASKB		;ASK AGAIN

170$:	CLR	R0		;ASSUME DEFAULT OF 0
	BIT	#FS.OPN,FQSTAT(R4) ;DOES THE FILE EXIST?
	BEQ	180$		;NO
	MOV	FQFCB+FCWND+2(R4),R2 ;YES, GET EXISTING BASE (DCN)
	CALLX	RIB2CN		;MAKE IT A PACK CLUSTER NUMBER
	MOV	R3,R0		;AND COPY THE PCN TO R0
180$:	CALLX	ANSWER,R5	;SORT OUT THE ANSWER
	 BR	140$		;YES - HUH?
	 BR	140$		;NO  - HUH?
	 BR	230$		;<LF>- USE OLD
	 BR	230$		;OLD - USE OLD


	CALLX	DBLINP		;GET DOUBLE PRECISION DECIMAL NUMBER
	BNE	140$		;BAD ANSWER
	MOV	DCS,R0		;GET DEVICE CLUSTER SIZE
	TST	R3		;IS HIGH ORDER = 0?
	BNE	190$		;NO, USE IT
	CMP	R2,R0		;YES, IS THE BLOCK # BELOW PACK CLU 0?
	BHIS	190$		;NO, USE IT
	MOV	R0,R2		;YES, USE A 0 ULTIMATELY
190$:	DEC	R0		;FIX LBN TO MAKE IT FBN
	SUB	R0,R2		;FBN = LBN - (DCS-1)
	SBC	R3
	CALLX	SEG2CN		;CONVERT TO PACK CLUSTER NUMBER IN R2
	BEQ	200$		;IT WAS ON A PCN BOUNDARY
	INC	R2		; OTHERWISE, ROUND UP TO PCN
200$:	CMP	R2,SATSYS+BITS	;TOO BIG?
	BHIS	210$		;YUP, ERROR
	MOV	R2,R0		;COPY TO R0
	ADD	FQNPCL(R4),R2	;COMPUTE HIGHEST PCN
	BCS	210$		;OVERFLOW IS EVIL
	CMP	R2,SATSYS+BITS	;WILL IT FIT?
	BLOS	220$		;YES IT WILL
210$:	MESSAGE	<"    Block number too big."<200>>
	BR	ASKB		;ASK AGAIN

220$:	BISB	#US.PLC,FQPROT-1(R4) ;SET THE FILE PLACED BIT
230$:	MOV	R0,FQPREF(R4)	;SET UP PREFERRED CLUSTER NUMBER
	CLC			;C=0 FOR GOOD RETURN
	RETURN

.DSABL	LSB

GLOBAL	<DCS,SATSYS>


.SBTTL	CLEAN OUT THE EXTENDED FIRQB WORDS

CLNFQB:	ADD	#FQSTAT,R4	;POINT TO EXTENDED WORDS
	MOV	#FQFCB-FQSTAT/2,R0 ;NUMBER OF WORDS TO CLEAR
10$:	CLR	(R4)+		;CLEAR IT
	SOB	R0,10$
	SUB	#FQFCB,R4	;POINT TO FIRQB AGAIN
	RETURN


.SBTTL	LOOP FOR EACH FIRQB IN THE LIST

LOOPFQ:	MOV	FQ1,R4		;POINT TO THE FIRST FIRQB
10$:	CALL	@(SP)+		;CALL HIM BACK
	CMP	R4,FQN		;AT THE LAST ONE YET?
	BEQ	20$		;YES, RETURN Z=1
	ADD	#FQFCB+FCBSIZ,R4 ;NO, POINT TO THE NEXT ONE
	BR	10$

20$:	RETURN

	TMPORG	REFCTL
FQ1:	.WORD	0		;ADDRESS OF FIRST FIRQB
FQN:	.WORD	0		;ADDRESS OF LAST FIRQB
	UNORG


.SBTTL	DO THE CHANGES TO THE FILE STRUCTURE

.ENABL	LSB

CHANGE:	MOV	#0*400+1,-(SP)	;Push [0,1]				;006
	MOV	SP,R0		;R0 -> [0,1] WORD FOR RUF		;006
	CALLX	RUF		;FIND THE ACCOUNT IN THE MFD
	INC	(SP)+		;Pop the PPN, leaving C alone		;006
	BCC	10$		;THIS SHOULD ALWAYS WORK
	ERF	<"INIT bug - can't find [0,1] again">

10$:	CLR	R4		;R4 = COUNT OF FREE ENTRIES IN [0,1] UFD
	CLR	R0		;R0 = OFFSET INTO DIRECTORY CLUSTER MAP
20$:	CLR	R1		;R1 = BLOCK WITHIN DIRECTORY CLUSTER
	ADD	#2,R0		;BUMP TO NEXT DIRECTORY CLUSTER
30$:	MOV	FIBMAP(R0),R2	;R2 = DIRECTORY CLUSTER NUMBER
	BEQ	60$		;NO MORE, DONE WITH THE COUNT
	CALLX	CNVRIB		;CONVERT R.P. TO FBN
	ADD	R1,R2		;ADD OFFSET FOR BLOCK WITHIN CLUSTER
	ADC	R3
	CALLX	READ		;GET THE DIRECTORY BLOCK
	MOV	#FIBUF,R5	;R5 -> DIRECTORY
40$:	MOV	(R5),-(SP)	;SAVE FIRST WORD OF ENTRY
	BIS	2(R5),(SP)+	;ARE THE FIRST 2 WORDS ZERO?
	BNE	50$		;NO, THIS ISN'T FREE
	INC	R4		;YES, THIS IS FREE
50$:	ADD	#20,R5		;POINT TO NEXT DIRECTORY ENTRY
	CMP	R5,#FIBMAP	;UP TO THE MAP YET?
	BLO	40$		;NO
	INC	R1		;YES, DONE WITH THIS BLOCK
	CMP	R1,(R5)		;ARE WE AT THE LAST BLOCK IN THE CLUSTER?
	BLO	30$		;NO, DO ANOTHER
	CMP	R0,#16		;YES, BUT IS THIS THE LAST CLUSTER?
	BLO	20$		;NOT YET, TRY ANOTHER CLUSTER
60$:	MOV	R4,FREENT	;SAVE FREE ENTRY COUNT

.DSABL	LSB

	TMPORG	REFCTL
FREENT:	.WORD	0		;NUMBER OF FREE DIRECTORY ENTRIES
	UNORG

GLOBAL	<FIBMAP,FIBUF>


.SBTTL	DO TRIAL DEALLOCATION IN SATBUF

.ENABL	LSB

TRYDEL:	CLR	PASFLG		;PASS ONE OF TRIAL
	CALL	GETSAT		;READ THE CLEAN SATT INTO SATBUF
	CALL	LOOPFQ		;LOOP ON EACH FIRQB
10$:	BIT	#FS.OPN,FQSTAT(R4) ;IS THIS FILE OPEN (I.E. IT EXISTS)?
	BEQ	60$		;YES, NO TRIAL DEALLOCATION
	MOV	R4,R1		;NO, COPY FIRQB POINTER
	ADD	#FQFCB,R1	;R1 -> FCB FOR FILE
	CALLX	RNB		;GET THE NAME ENTRY OF THE FILE
	INC	FREENT		;ONE MORE FREE DIRECTORY ENTRY (N.E.)
	MOV	USTAT(R5),R0	;R0 = FILE STATUS FLAGS
	MOV	UAA(R5),R3	;R3 = LINK TO ACCOUNTING ENTRY
	MOV	UAR(R5),-(SP)	;SAVE LINK TO RETRIEVAL ENTRY
	CALLX	RDB		;READ THE ACCOUNTING ENTRY
	MOV	UCLUS(R5),R1	;R1 = CLUSTERSIZE OF THE FILE
20$:	INC	FREENT		;ONE MORE FREE ENTRY FOR A.E. OR ATTRIBUTE
	MOV	(R5),R3		;GET LINK TO NEXT ATTRIBUTE
	BIC	#17,R3		; WITHOUT FLAG BITS
	BEQ	30$		;NO MORE
	CALLX	RDB		;READ THE ATTRIBUTE
	BR	20$		;AND COUNT IT AS FREE IN THE DIRECTORY

30$:	MOV	(SP)+,R3	;RESTORE LINK TO RETRIEVAL ENTRY
	BIC	#17,R3		;REMOVE FLAG BITS
	BEQ	60$		;DONE TRIAL DEALLOCATION
	CALLX	RDB		;READ IT
	INC	FREENT		;COUNT THE RETRIEVAL ENTRY AS FREE
	MOV	(R5)+,-(SP)	;SAVE LINK TO NEXT R.E.
40$:	MOV	(R5)+,R2	;R2 = RETRIEVAL POINTER
	BEQ	30$		;0, GO DUMP LINK TO NEXT R.E. AND FINISH
	BIT	R0,#US.OUT	;IS THIS FILE OUT OF SAT?
	BNE	50$		;YES, A RELIC OF V6A
	CALLX	RETCLU		;OTHERWISE, RETURN THE CLUSTER
50$:	BIT	R5,#17		;DONE WITH THIS R.E.?
	BNE	40$		;NO, GET ANOTHER CLUSTER POINTER
	BR	30$		;YES, GET ANOTHER RETRIEVAL ENTRY

60$:	CALL	@(SP)+		;DONE WITH THIS FILE, GET ANOTHER FIRQB
	BNE	10$		;PROCESS IT IF ANY
	CALL	ALCBAD		;ENSURE THAT BADB.SYS IS FULLY ALLOCATED

.DSABL	LSB


.SBTTL	DO TRIAL ALLOCATION OF FILES

.ENABL	LSB

TRYALC:	CALLX	SAVSAT		;COPY THE DEALLOCATED SAT TO AUXILIARY BUFFER
10$:	CALL	LOOPFQ		;LOOP FOR EVERY FIRQB
	MOV	FREENT,CREENT	;SET NUMBER OF ENTRIES AVAILABLE TO CREATE IN
20$:	MOV	FQPREF(R4),R0	;R0 = PREFERRED (OR CURRENT) START CLU
	BIC	PASFLG,R0	; BUT MAKE IT 0 IF PASS 2 ALLOCATION
	MOV	FQSIZN(R4),R1	;R1 = PREFERRED NEW SIZE (0 IF DELETE)
	BEQ	60$		;DELETING IT, DON'T TRY TO ALLOCATE IT
30$:	CALLX	GETCLU		;TRY TO OBTAIN THE CONTIGUOUS SPACE
	BCS	50$		;GOT IT
	TST	R0		;WAS THE START OF THE SEARCH = 0?
	BEQ	40$		;YES, THIS PASS AT ALLOCATION FAILED
	CLR	R0		;NO, TRY NO PREFERRED START FOR THIS FILE
	BR	30$		;AND AGAIN TRY ALLOCATING IT

40$:	TST	(SP)+		;DUMP LOOPFQ COROUTINE CALL
TRYAGN:	CALLX	RESSAT		;RESTORE DEALLOCATED SAT INTO SATBUF
	COM	PASFLG		;SWITCH THE PASS FLAG
	BNE	10$		;IF THIS ISN'T PASS 2, TRY AGAIN
ALFAIL:	MESSAGE
	 .ASCIZ	"    Unable to create requested file(s)"<200>
	 UNORG
	RETURN

50$:	MOV	R2,FQALLC(R4)	;SAVE THE ALLOCATED CLUSTER NUMBER
	CALLX	FIXCLU		;CONVERT BLOCK COUNT IN R1 TO PC COUNT
	MOV	R0,FQNPCL(R4)	;SAVE NUMBER OF PACK CLUSTERS REQUIRED
	MOV	R0,R1		;COPY THE PACK CLUSTER COUNT
	CLR	R0		;CLEAR FOR DIVIDE
	DIV	#7,R0		;COMPUTE THE NUMBER OF RETRIEVAL ENTRIES
	NEG	R1		;IF ANY REMAINDER, THEN
	ADC	R0		; ROUND UP TO AN INTEGER
	ADD	#2,R0		;+ 2 DIRECTORY ENTRIES FOR NE, AE
	SUB	R0,CREENT	;COUNT DOWN NUMBER OF ENTRIES AVAILABLE
60$:	CALL	@(SP)+		;NEXT FIRQB
	BNE	20$		; IF ANY

.DSABL	LSB

	TMPORG	REFCTL
CREENT:	.WORD	0		;COUNT OF NUMBER OF DIRECTORY ENTRIES
PASFLG:	.WORD	0		;<>0 IF PASS 2 OF TRIAL ALLCATION
	UNORG


.SBTTL	TRY TO GET ENOUGH DIRECTORY ENTRIES FOR CREATION

.ENABL	LSB

TRYDIR:	CLR	EXTMAP+2	;SET FLAG FOR NO EXTENDED CLUSTER MAP
	MOV	CREENT,R1	;GET NUMBER OF ENTRIES FREE NOW
	BPL	DOALLC		;POSITIVE CAN BE ACCOMODATED NOW!
	NEG	R1		;R1 = NUMBER OF EXTRA ENTRIES REQUIRED
	CLR	R0		;CLEAR FOR DIVIDE
	MOV	FIBMAP,R3	;R3 = DIRECTORY CLUSTER SIZE
	MUL	#31.,R3		;R3 = NUMBER OF ENTRIES PER UFD CLUSTER
	DIV	R3,R0		;COMPUTE NUMBER OF UFD CLUSTERS REQUIRED
	NEG	R1		;IF ANY REMAINDER
	ADC	R0		; ROUND UP
	MOV	R0,R1		;R1 = NUMBER OF UFD CLUSTERS TO GET
	MOV	#FIBUF+1000,R2	;R2 -> END OF CLUSTER MAP
10$:	TST	-(R2)		;ROOM IN FDCM FOR ANOTHER CLUSTER?
	BNE	ALFAIL		;NO, THIS ALLOCATION MUST FAIL!
	SOB	R1,10$		;ELSE COUNT DOWN CLUSTERS
20$:	TST	-(R2)		;UFD CAN HOLD THEM.  FIND THE HOLE
	BEQ	20$		; IN THE UFD CLUSTER MAP
	MOV	#EXTMAP,R3	;R3 -> EXTENSIONS OF UFD MAP
	MOV	R2,(R3)+	;EXTMAP HOLDS POINTER TO LAST REAL CLUSTER
	MOV	FIBMAP,R1	;R1 = UFD CLUSTER SIZE TO ALLOCATE
30$:	CALLX	GETDIR		;GET A DIRECTORY CLUSTER
	BCC	TRYAGN		;CAN'T GET IT, MAYBE TRY AGAIN ...
	MOV	R2,(R3)+	;GOT IT, REMEMBER THE CLUSTER WE GOT
	SOB	R0,30$		;GET ALL THE CLUSTERS WE NEED
	CLR	(R3)+		;CLEAR LAST ENTRY AS A FLAG

.DSABL	LSB

	TMPORG	REFCTL
EXTMAP:	.BLKW	9.		;EXTENDED UFD CLUSTER MAP
	UNORG

GLOBAL	<FIBMAP,FIBUF>


.SBTTL	DO THE ACTUAL ALLOCATION, KNOWING IT CAN'T FAIL

.ENABL	LSB

DOALLC:	CALL	GETSAT		;READ IN A NICE CLEAN SATT FROM DISK
	CALLX	READPL		;READ IN THE PACK LABEL			;002
	BIS	#UC.MNT,FIBUF+PSTAT ;IT'S DIRTY DURING THIS SEQUENCE	;002
	CALLX	WRITE		;MAKE SURE IT SAYS SO
	CALL	LOOPFQ		;DELETE EACH FILE WHICH EXISTS
10$:	BIT	#FS.OPN,FQSTAT(R4) ;IF IT DOESN'T EXIST
	BEQ	20$		; SKIP IT FOR NOW
	CALLX	DELNAM		;IF IT EXISTS, DELETE IT NOW
	BCS	80$		;CAN'T FIND IT NOW, WHAT GIVES?
	BIC	#FS.OPN,FQSTAT(R4) ;FILE IS NOW CLOSED (NON-EXISTENT)
20$:	CALL	@(SP)+		;NEXT FILE
	BNE	10$		; IF ANY
	CALL	ALCBAD		;ENSURE BADB.SYS IS FULLY ALLOCATED
	MOV	#0*400+1,-(SP)	;Push an [0,1]				;006
	MOV	SP,R0		;R0 -> [0,1] PPN TO FIND		;006
	CALLX	RUF		;GET IT
	TST	(SP)+		;Pop the PPN				;006
	MOV	#EXTMAP,R4	;R4 -> EXTENDED CLUSTERS TO GET
30$:	TST	(R4)+		;POINT TO NEXT CLUSTER TO GET
	MOV	(R4),R2		;R2 = RETREIVAL POINTER TO ALLOCATE
	BEQ	DOCREA		;NO MORE, GO DO THE CREATION
	CALLX	RIB2CN		;CONVERT TO PACK CLUSTER NUMBER
	MOV	R3,R0		;SAVE PCN TO GET
	MOV	FIBMAP,R1	;R1 = UFD CLUSTER SIZE
	CALLX	GETCLU		;ALLOCATE THE CLUSTER
	BCC	90$		;HUH?? WE GOT IT LAST TIME!
	CMP	R2,(R4)		;DID WE GET THE SAME CLUSTER?
	BNE	100$		;NO, WHY NOT???
	CALLX	WRITEC		;FORCE OUT FIBUF IF NECESSARY
	ADD	#2,EXTMAP	;THE CLUSTER GOES IN THE NEXT MAP ENTRY
	CALLX	CNVRIB		;CONVERT THE NEW RP TO FIP BLOCK NUMBER
	MOV	#FIBUF,R5	;R5 -> FIBUF TO BE CLEARED
40$:	CLR	(R5)+		;NEW BLOCKS HAVE NO DATA
	CMP	R5,#FIBMAP	;UP THE THE FDCM YET?
	BLO	40$		;NO
	MOV	(R4),@EXTMAP	;YES, SET THIS CLUSTER'S RP IN THE MAP
	MOV	(R5),R1		;R1 = NUMBER OF BLOCKS IN CLUSTER TO CLEAR

GLOBAL	<FIBUF,FIBMAP>


50$:	MOV	R2,FIBPHS	;SET UP THE FBN TO WRITE
	MOVB	R3,FIBPHS+2
	CALLX	WRITE		;WRITE IT
	ADD	#1,R2		;NEXT BLOCK IN THE NEW UFD CLUSTER
	ADC	R3
	SOB	R1,50$		;FOR EVERY BLOCK
	MOV	EXTMAP,R0	;R0 -> FIBUF @ NEW CLUSTER
60$:	MOV	-(R0),R2	;R2 = R.P. FOR A PREVIOUS CLUSTER
	CMP	R0,R5		;ARE WE DOWN TO THE CLUSTERSIZE IN FDCM?
	BLOS	30$		;YES, DONE WITH THIS ALLOCATION
	CALLX	CNVRIB		;CONVERT UFD R.P. TO FIB BLOCK NUMBER
	MOV	(R5),R1		;R1 = NUMBER OF BLOCKS IN CLUSTER TO FIX
	ADD	R1,R2		;START FIXES AT THE END
	ADC	R3
70$:	SUB	#1,R2		;PREVIOUS BLOCK IN UFD CLUSTR
	SBC	R3
	CALLX	READ		;READ THE CLUSTER
	MOV	(R4),@EXTMAP	;INSERT THE NEW RP IN THE FDCM
	MARK	FIBUF		;FIBUF HAS CHANGED
	SOB	R1,70$		;DO EACH BLOCK IN THE UFD CLUSTER
	BR	60$		;DO ANOTHER UFD CLUSTER IF ANY

80$:	ERF	<"INIT bug - can't find file to delete">

90$:	ERF	<"INIT bug - can't allocate file 2nd time">

100$:	ERF	<"INIT bug - didn't get same cluster 2nd time">

.DSABL	LSB

GLOBAL	<FIBPHS>


.SBTTL	CREATE THE FILES

.ENABL	LSB

DOCREA:	CALL	LOOPFQ		;LOOP ON EVERY FIRQB
10$:	MOV	FQSIZN(R4),R1	;R1 = NEW SIZE OF FILE
	BEQ	20$		;NONE, DON'T CREATE IT
	MOV	FQALLC(R4),R2	;GET THE CLUSTER ALLOCATED FIRST TIME
	CALLX	RIB2CN		;CONVERT TO A PACK CLUSTER NUMBER
	MOV	R3,R0		;COPY THE PCN FOR GETCLU
	CALLX	GETCLU		;DO THE ALLOCATION
	BCC	30$		;WHY DIDN'T WE GET IT?
	CMP	R2,FQALLC(R4)	;DID WE GET THE ONE WE WANTED?
	BNE	30$		;WHY NOT???
	CALL	CREATE		;YES, CREATE THE FILE
	TST	R5		;DID IT FAIL?
	BNE	40$		;YES, WHY???
20$:	CALL	@(SP)+		;NEXT FILE
	BNE	10$		; IF ANY
	CALLX	WOMSAT		;WRITE OUT THE SATT
	CALLX	READPL		;Read the pack label			;002
	BIC	#UC.MNT,FIBUF+PSTAT ;DISK IS AGAIN CLEAN		;002
	CALLRX	WRITE		;REWRITE PACK LABEL AND GO AWAY

30$:	ERF	<"INIT bug - didn't get same file cluster 2nd time">

40$:	ERF	<"INIT bug - failed to create file">

.DSABL	LSB

GLOBAL	<FIBUF>


.SBTTL	CREATE A FILE IN THE UFD

.ENABL	LSB

CREATE:	CLR	R5		;R5 = 0 AS A FLAG FOR GOODNESS
	REGSCR			;NOW SAVE ALL REGISTERS
	MOV	R4,R0		;COPY FIRQB POINTER
	ADD	#FQPPN,R0	;R0 -> PPN IN THE FIRQB
	CALLX	SDU		;FIND THE FILE IN THE MFD
	BCC	80$		;IT EXISTS ALREADY! THAT SHOULDN'T HAPPEN
	CMP	R5,#4		;DOES THE UFD EXIST AT ALL?
	BNE	90$		;NO, NO UFD???
	MOV	R2,-(SP)	;SAVE LINK TO LAST NAME ENTRY
	MOV	PCS,FQCLUS(R4)	;CLUSTERSIZE OF FILE IS PACK CLUSTER SIZE
	CALLX	GDB		;GET A DIRECTORY ENTRY FOR ACCOUNTING
	BCS	70$		;CAN'T GET IT, GO RETURN 2 IN R5
	MARK	FIBUF
	MOV	R3,-(SP)	;SAVE LINK TO ACCOUNTING ENTRY
	INC	(R5)+		;MARK THE ENTRY IN USE
	MOV	I.DATE,(R5)+	;LAST ACCESS DATE
	MOV	FQSIZN(R4),(R5)+ ;SIZE OF FILE
	MOV	I.DATE,(R5)+	;CREATION DATE
	MOV	I.TIME,(R5)+	;CREATION TIME
	MOV	#^R RS,(R5)+	;CREATING RTS = ' RSTS '
	MOV	#^RTS ,(R5)+
	MOV	PCS,(R5)+	;CLUSTERSIZE = PCS
	MARK	FIBUF		;REWRITE THE ACCOUNTING ENTRY
	CALLX	GDB		;GET A HOLE FOR THE NAME ENTRY
	BCS	50$		;NO CAN DO, RELEASE THE A.E.
	CLR	(R5)+		;LINK TO NEXT NAME ENTRY = 0
	MOV	FQNAM1(R4),(R5)+ ;SET UP FILNAM.EXT
	MOV	FQNAM1+2(R4),(R5)+
	MOV	FQNAM1+4(R4),(R5)+
	MOV	FQPROT-1(R4),(R5)+ ;PROTECTION CODE & FLAG BITS
	CLR	(R5)+		;ACCESS COUNT = 0
	MOV	(SP)+,(R5)+	;LINK TO ACCOUNTING ENTRY
	MOV	R3,-(SP)	;SAVE LINK TO NAME ENTRY
	MOV	R5,-(SP)	;SAVE POSITION (IN FIBUF) FOR R.E. LINK
	MOV	R3,-(SP)	;SAVE LINK TO N.E. IN WHICH TO PLUG UAR
	CLR	R5		;R5 = 0 TO FORCE ALLOCATION FIRST TIME
	MOV	FQALLC(R4),R2	;R2 = R.P. TO START OF FILE
	MOV	FQNPCL(R4),R4	;R4 = NUMBER OF PACK CLUSTERS

GLOBAL	<PCS,I.DATE,I.TIME>


10$:	BIT	R5,#17		;NEED A NEW RETRIEVAL ENTRY?
	BNE	20$		;NO
	CALLX	GDB		;YES, GET ONE
	BCS	30$		;NONE TO GET, RETURN EVERYTHING & GO AWAY
	MOV	R3,R1		;R1 = LINK TO R.E. JUST OBTAINED
	MOV	(SP)+,R3	;R3 = LINK TO PREVIOUS ENTRY
	CALLX	RDB		;GET PREVIOUS
	MOV	R1,@(SP)+	;LINK IT TO THIS ENTRY
	MOV	R1,R3		;GET LINK TO THE NEW R.E.
	CALLX	RDS		;READ IT, SAVING THE PREVIOUS
	MOV	R5,-(SP)	;NEXT R.E. LINK GOES HERE
	MOV	R3,-(SP)	;LINK TO THIS R.E. FOR NEXT R.E.
	CLR	(R5)+		;FOR NOW, NEXT R.E. = 0
20$:	MOV	R2,(R5)+	;SET UP RETRIEVAL POINTER
	MARK	FIBUF		;FIBUF HAS CHANGED
	ADD	CLURAT,R2	;UPDATE RETRIEVAL POINTER FOR CTG FILE
	SOB	R4,10$		;LOOP FOR EACH PACK CLUSTER TO ALLOCATE
	CMP	(SP)+,(SP)+	;DUMP POINTERS TO PREVIOUS R.E.
	MOV	(SP)+,R1	;R1 = LINK TO FILE NAME ENTRY
	MOV	(SP)+,R3	;R3 = LINK TO LAST NAME ENTRY IN UFD
	CALLX	RDS		;READ IT
	MOV	R1,(R5)		;FORMERLY LAST FILE LINKS TO THIS NEW ONE
	CALLRX	WRITE		;REWRITE FIBUF, RESTORE REGS, EXIT

30$:	CMP	(SP)+,(SP)+	;COULDN'T GET R.E., SO DUMP PTRS TO PREV
	ADD	#2,TOS.R5+4(SP)	;R5 WILL EVENTUALLY BE 6
	MOV	(SP)+,R3	;R3 = LINK TO NAME ENTRY
	CALLX	RDB		;GET NAME ENTRY
	MOV	UAA(R5),R3	;R3 = A.E. LINK FOR DELETION
	MOV	UAR(R5),R1	;R1 = R.E. LINK FOR DELETION
	CLR	(R5)+		;MAKE THE NAME ENTRY A HOLE
	CLR	(R5)+
	CALLX	RDS		;GET THE ACCOUNTING ENTRY
40$:	CLR	(R5)+		;MAKE IT A HOLE
	CLR	(R5)+
	MOV	R1,R3		;COPY LINK TO (NEXT) RETRIEVAL ENTRY
	BIC	#17,R3
	BEQ	60$		;NO MORE, FINISH UP
	CALLX	RDS		;GET THE R.E.
	MOV	(R5),R1		;SAVE LINK TO NEXT R.E.
	BR	40$		;GO MAKE IT A HOLE

GLOBAL	<CLURAT>


50$:	MOV	(SP)+,R3	;COULDN'T GET NAME ENTRY. LINK TO A.E.
	CALLX	RDS		;GET ACCOUNTING ENTRY
	CLR	(R5)+		;MAKE IT A HOLE
	CLR	(R5)+
60$:	ADD	#2,TOS.R5+2(SP)	;R5 WILL BE 4 FOR NO NAME ENTRY
	MARK	FIBUF
70$:	TST	(SP)+		;DUMP LINK TO LAST NAME ENTRY IN UFD
	ADD	#2,TOS.R5(SP)	;R5 WILL BE 2 FOR NO ACCOUNTING ENTRY
	CALLRX	WRITEC		;WRITE EVERYTHING, GO BACK WITH R5 <> 0

80$:	ERF	<"INIT bug - file exists when trying to create">

90$:	ERF	<"INIT bug - no UFD found in create">

.DSABL	LSB


.SBTTL	CLEAN UP AFTER OPTIONS

	TMPORG	REFOPT
	 .WORD	REFXXX		;TRAP INVALID RESPONSES
	TMPORG	REFOTX
	 .BYTE	0		;END OF TEXT
	UNORG

REFXXX:	MESSAGE	<"  Illegal suboption given"<200>>
	RETURN

.MACRO	OPTION	N1,N2
.ERROR	;OPTIONS NOT LEGAL
.ENDM	OPTION


.SBTTL	GET THE ON-DISK SAT INTO MEMORY

.ENABL	LSB

GETSAT:	REGSCR			;SAVE ALL REGS
	MOV	#FQSATT,R4	;R4 -> SATT.SYS FIRQB TO ENSURE IT'S OPEN
	CALLX	LOKFIL		;OPEN IT
	BCS	10$		;OUCH
	MOV	FCSATT+FCSIZ,R0	;R0 = NUMBER OF BLOCKS IN THE SAT
	SWAB	R0		;COMPUTE A BLOCK COUNT
	CMP	R0,#4*4000/2	;TOO BIG (OVER 4K WORDS) ?
	BHI	20$		;YES
	MOV	#FCSATT,R1	;R1 -> SATT.SYS FCB FOR READ
	CLR	FCNVB(R1)	;START AT BLOCK 0
	CALLX	READ.,R5,SATBUF	;DO IT
	RETURN

10$:	ERF	<"SATT.SYS non-existent at time of read">

20$:	ERF	<"SATT.SYS is over 16. blocks long">

.DSABL	LSB

GLOBAL	<FQSATT,FCSATT,SATBUF>


.SBTTL	ALLOCATE BADB.SYS AFTER DELETING FILES

.ENABL	LSB

ALCBAD:	REGSCR			;SAVE REGISTERS
	MOV	#FCBADB,R1	;POINT TO BADB.SYS FCB
	TST	FCSIZ(R1)	;ANY BADS?
	BEQ	60$		;NO, EASY OUT
	CALLX	RNB		;GET NAME ENTRY FOR BAD BLOCK FILE
	MOV	UAR(R5),R3	;R3 = LINK TO FIRST NAME ENTRY
10$:	BIC	#17,R3		;REMOVE FLAG BITS
	BEQ	60$		;DONE
	CALLX	RDB		;READ THE RETRIEVAL ENTRY
	MOV	(R5)+,R3	;R3 = LINK TO NEXT
20$:	MOV	(R5)+,R0	;NEXT RETRIEVAL POINTER
	BEQ	60$		;NONE, SO DONE
	DEC	R0		;CONVERT DCN TO PCN
	MOV	CLURAT,R1	;BY PCN = (DCN-1)/CLURAT
30$:	ASR	R1		;SHIFT DIVISOR
	BCS	40$
	;CLC
	ROR	R0		;SHIFT DIVIDEND
	BR	30$

40$:	CALLX	FIXREG		;CHANGE TO BIT AND BYTE
	CMP	R4,SATSYS+BYTS	;TOO BIG FOR SATT?
	BHIS	50$		;YES, SKIP IT
	BISB	BITBYT(R2),SATBUF(R4) ;NO, ALLOCATE IT
50$:	BIT	R5,#17		;DONE WITH THIS RETRIEVAL ENTRY
	BNE	20$		;NO
	BR	10$		;YES

60$:	RETURN			;DONE

.DSABL	LSB

GLOBAL	<FCBADB,CLURAT,SATSYS,BITBYT,SATBUF>


.SBTTL	CHECK FOR UNCHANGEABLE FILES

.ENABL	LSB

;+
;	This module scans the list following it to determine if the file
;	can be changed.  Both the FILE and CHANGE suboptions use these
;	routines.
;
;	FILE only looks at a subset
;	Neither suboption will allow the installed SIL to be changed
;	in any way.
;-

CHKREQ:	MOV	R0,-(SP)	;SAVE THE REG
	MOV	#70$,R0		;POINT TO STUFF
5$:	CMP	FQEXT(R4), #^RSIL ;is the file a SIL?
	BNE	10$		;No, so check for other illegal files
	CMP	FQNAM1(R4), SILNAM ;Could it be the installed SIL?
	BNE	10$		;No, first part of name doesn't match
	CMP	FQNAM1+2(R4), SILNAM+2 ;Still could be, is it?
	BEQ	55$		;it is, tell him, and try again
10$:	CMP	(R0)+,FQNAM1(R4) ;NAME MATCH? (otherwise, check for other illegal file)
	BNE	20$		;NO
	CMP	(R0),FQNAM1+2(R4) ;MAYBE?
	BNE	20$		;NO
	CMP	2(R0),FQEXT(R4)	;EXTENSION, TOO?
	BEQ	40$		;YUP, THAT'S NO GOOD
20$:	CMP	(R0)+,(R0)+	;BUMP TO NEXT INVALID NAME
	TST	(R0)		;ANY MORE? (& C=0)
	BNE	10$		;YES, DO THEM
30$:	MOV	(SP)+,R0	;RESTORE R0
	RETURN			;C=1 IF BADDIE

40$:	TST	REFSYS		;DOING THE SYSTEM DISK?
	BNE	50$		;YES, NEVER ALLOW INIT.SYS
	CMP	R0,#80$+2	;NO, IS IT INIT.SYS??
	BEQ	30$		;IT IS, ALLOW IT (BEQ=>BHIS=>BCC)
50$:	MESSAGE	<"    That file cannot be changed."<200>>
	SEC			;SAY ITS A BADDY
	BR	30$		; AND EXIT

55$:	MESSAG	<"    That file is the currently installed SIL"<200>>
	MESSAG	<"    and cannot be moved or deleted."<200>>
	SEC			;mark it bad,
	BR	30$		;and exit.

70$:	.RAD50	/BADB  SYS/
	.RAD50	/SATT  SYS/
80$:	.RAD50	/INIT  SYS/
	.WORD	0

GLOBAL	<SILNAM>
.DSABL	LSB


.SBTTL	CHECK FOR CLEAN DISK AND/OR CLEAN IT

;+
; CLNCHK - CHECK FOR CLEAN DISK, CLEAN IT IF NECESSARY
;
;	CALL	CLNCHK,R5
;
;	FIRST  RETURN IF IT NEEDED CLEANING, WITH THE CLEAN DONE
;	SECOND RETURN IF IT IS MARKED CLEAN
;-

CLNCHK:	CALLX	READPL		;GET THE PACK LABEL			;002
	TST	FIBUF+PSTAT	;IS IT CLEAN?				;002
.ASSUME	UC.MNT LT 0							;002
	BMI	10$		;NO, GO CLEAN IT
	TST	(R5)+		;YES, ADVANCE TO SECOND EXIT
	RETURN	R5

10$:	MOV	R5,-(SP)	;SAVE RETURN ADDRESS ON THE STACK

;+
; CLEANY - CLEAN THE DISK
;
;	CALL	CLEANY
;-

CLEANY:	MOV	#SWPMIN,R0	;SAVE LOCAL STUFF ON THE STACK
	MOV	#4,R1		;4 WORDS OF IT
10$:	MOV	(R0)+,-(SP)
	SOB	R1,10$
	JMPX	RCLEAN		;JUMP TO THE ROUTINE IN THE ROOT
CLEANR::MOV	#SWPMIN+<4*2>,R0 ; WHICH JUMPS BACK HERE TO RETURN
	MOV	#4,R1		;RESTORE LOCAL VARIABLES
10$:	MOV	(SP)+,-(R0)
	SOB	R1,10$
	RETURN

GLOBAL	<FIBUF>

ENDOVL	<REF,REFCTL,REFOPT,REFOTX,REFTXT>,100

.END


