	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
	.INCLUDE /INIT:INIPFX/
	.INCLUDE /INIT:DSKDEF/
	.INCLUDE /DSK:MIDDEF/
TITLE	DSKINT,<RSTS/E INIT - DSKINT OPTION>,0K,29-JUN-92,ABC/WBN/SHG/RVR/GPK/DRP/WJS/MND/DBM/FRL/VAM/PJH/WRM

;
;		COPYRIGHT (c) 1974, 1992 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR INIDSK

;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-08
;  001	MND  16-Feb-81	Added DMP/DMV support
;  002  MND  16-MAR-81	Recover system disk parameters after BADB lookup error
;
;				[RSTS V7.2]
;  000  MND  22-Mar-82	CREATION - COPIED FROM V7.1-11
;  001  MND  22-Mar-82	Added support for MSCP disks - UDA50/RA80
;
;				[RSTS V8.0]
;  000	GPK  15-Jul-82	Add missing GLOBAL for FIBUF
;  002	GPK  21-Sep-82	New file structure code
;  003	GPK  27-Sep-82	Implement S^3 boot standard
;  004	GPK  05-Oct-82	Variable MFD/GFD clustersize
;			Position specified as DCN rather than block number
;  005	DRP/GPK  19-Oct-82	DCL/online DSKINT
;  006  JHC  10-Jan-82	Bug fix in EXTEND code to keep DSKINT from
;			overwriting SETTBL with GFD/MFD info.
;  007	JHC  01-Feb-83	Disallow default "no access" password in [1,2]
;			on system disks.  Also added invalid password
;			message for bad entry.
;  008	TWH  20-JUN-83	FIX MSCP BUG (TRAP THRU 4 ON FIRST ACCESS)
;  009	WJS  28-Sep-83	Change AT.CTI to AT.EXP
;
;				[RSTS V9.0]
;  010	MND  01-Nov-83	Added support for Virtual Disk
;  011	DBM  11-JAN-84	CHANGE <CR> TO <LF> FOR VT200 SUPPORT
;  012	GPK  09-May-84	Always allocate date/time attributes
;  013	MND  10-May-84	Save disk index/unit for auto-COPY
;  014	DBM  09-Aug-84	Make <SYS> default disk type for offline DSKINT
;  015	MND  30-Aug-84	Remove check for disks without units
;  016  FRL  11-Oct-84  Set attributes for [1,1] and [1,2] and allow ^ response
;  017  FRL  25-Oct-84  Make work (all the time) for DV disks
;  018	DBM  17-Dec-84	Change missed <LF> references to <CR>
;  019  FRL  11-Jan-85  Bug fix (MFD query restarted off-line DSKINT)
;  020  FRL  06-Feb-85  On-line exit with status
;  021	GPK  25-Feb-85	Change initial password attribute contents to "?"
;			Place [0,1] by MFD rather than at start of disk
;  022  VAM  07-Mar-85	Source clear patch 01.01.042 from V8.0-07.
;  023  VAM  03-Apr-85	Pass booted unit name to INICOP via COADEV
;
;				[RSTS V9.1]
;  024  VAM  24-Aug-85	Fix error handling for Read Check miscompare errors.
;			Also, undo 023 above ("Oh...never mind!!")
;
;				[RSTS V9.2]
;  025  FRL   7-Feb-86	Use factory bad blocks when DCL entry
;  026  FRL  12-Feb-86	Special clustersizes for DV disk
;
;				[RSTS V9.3]
;  027  FRL  29-Apr-86	Micro/RSTS changes
;
;                               [RSTS V9.4]
;  028  PJH  20-Jan-87  Add Large disk support
;  029  PJH  07-Feb-87  Disable large disks for now
;  030  GPK  11-Feb-87	Add DW,DZ for GPK
;
;				[RSTS V9.5]
;  031	PJH  01-Jul-87	Redo Large disk support for clu=16 on large disk
;
;				[RSTS V9.6]
;  032  VAM  03-Feb-88	Allow reboot with full autosize if non-existant disk.
;  033	PJH  18-Feb-88	Add Controller Formatting support
;			Allow underscore in disk name
;  034	PJH  08-Mar-88	Fix so if disk size changes after format, correct SATT
;			is built
;  035	PJH  14-MAR-88	Modify SATT questions so if disk size < 4500 blocks,
;			SATT defaults to 1 and no validation is done.
;
;			[RSTS/E V9.7]
;  036  WRM  12-May-89	Fix bad blks off end of disk caused by 034
;
;			[RSTS/E V10.0]
;  037  FEK  02-Nov-89	Add IGNORE flag to SATT.SYS and BADB.SYS
;  038  VAM  04-Nov-89	Don't allow initialize of disks < 16 blocks long.
;
;			[RSTS/E V10.1]
;  039	FEK  24-Dec-91	Fix RC25 SATT, and floppy default clustersizes,
;			make attributes = online attributes, allow creation
;			of 1.1 disks
;  040	DRP  26-Jun-92	Fix bug in ASKPUB where the pack status attributes
;			established during the DCL command line parsing were
;			getting clobbered.
;-

.SBTTL	ORDER THE DSKINT CSECTS
	DEFORG	DSI
	DEFORG	DSIDAT
	DEFORG	DSITXT
	DEFORG	DSIMU
	ORG	DSI

.SBTTL	DSKINT MACROS AND PARAMETERS

.MACRO	I.MESS
	TMPORG	DSITXT
.NLIST	BEX
.ENDM

.IF	DF	ONLINE							;005
.MACRO	TSTABT								;005
	 CALLX	TSTABT							;005
.ENDM									;005
.IFF									;005
.MACRO	TSTABT								;005
.ENDM									;005
.ENDC									;005

; DEFINE BITS IN DISK TYPE TABLE
.BSECT
TY.FIX:	.BLKB	.		;FIXED HEAD TYPE DEVICE
TY.UNT:	.BLKB	.		;DRIVES ARE ADDRESSED BY UNIT NUMBER
TY.FMT:	.BLKB	.		;DISK IS FORMATTABLE
TY.INT:	.BLKB	.		;DISK MAY BE PROCESSED BY DSKINT

.MACRO	DSKTDF	XX,TYPLST
.DSABL	CRF
.NLIST
TMPTAG	= 0
.IRP	XYZ,<TYPLST>
TMPTAG	= TMPTAG ! TY.'XYZ
.ENDR
.LIST
.EQUATE	XX'$TYP	, TMPTAG
.ENABL	CRF
.ENDM	DSKTDF

	DSKTDF	DV,<INT>
	DSKTDF	DF,<FIX,INT>
	DSKTDF	DS,<FIX,UNT,INT>
	DSKTDF	DK,<FMT,UNT,INT>
	DSKTDF	DL,<UNT,INT>
	DSKTDF	DM,<FMT,UNT,INT>
	DSKTDF	DP,<FMT,UNT,INT>
	DSKTDF	DB,<FMT,UNT,INT>
	DSKTDF	DR,<FMT,UNT,INT>
	DSKTDF	DZ,<UNT,INT>						;030
	DSKTDF	DW,<UNT,INT>		;eventually will be FMT too	;030
	DSKTDF	DU,<UNT,INT>

	TMPORG	DSIDAT

	; PERMANENT TABLE OF DISK TYPE DEFINITIONS

DSKTYP:	$DISKS
	 .WORD	NAME'$TYP
.ENDM
DTTSIZ	= .-DSKTYP	;SIZE OF DISK TYPES TABLE

	; WORKING COPY OF TABLE OF DISK TYPE DEFINITIONS
	; (MODIFIED ON-LINE TO ADJUST FOR PECULIAR DISKS [RP07, RM80])

TMPTYP:	$DISKS
	 .WORD	NAME'$TYP
.ENDM

	UNORG

FLPYSZ =: 4500.		;Minimum size for a non-floppy disk		;035
MINFSZ =: 16.		;Minimum size for a file-structured disk	;038


.SBTTL	MAIN DRIVER FOR DSKINT
;
;	Normal DSKINT entry point
;
.ENABL	LSB								;027

DSKINT::CALL	DSKIN2		;Call the Main code		;013

.IF	DF	ONLINE							;020
	MOV	#EX$SUC,STATUS	;Indicate success			;020

GLOBAL	<EX$SUC,STATUS>							;020
.ENDC									;020

	EXIT			;BACK TO OPTION ?		;013

;
;	Entry point for a 1st time RSTS installation. This
;	allows the main code to auto-chain into the COPY
;	Option when DSKINT completes successfully. Any error
;	encountered during DSKINT will drop the user into
;	the Option: environment.
;
DSKIN2::NOP

.IF	NDF	ONLINE							;027
	; RODISK .EQ. <MICRO + 1> is assumed throughout, see ROOT	;027
	CMP	MICRO,#-1	;Micro & Installation?			;027
	BNE	5$		;No, continue				;027
	MOVB	#'D,OUTSAV	;Yes, set device type DU		;027
	MOVB	#'U,OUTSAV+1	;  ...					;027
	TSTB	FLGGPK		;Is this a GPK?				;030
	BPL	11$		;No					;030
	MOV	#'W,OUTSAV+1	;Yes, so use DW (hard disk) instead	;030
11$:	CLRB	OUTSAV+2	;  ...					;027
	MOV	#LOGO,R0	;Set version number			;027
	CMPB	(R0)+,#'u	;  u/RSTS set?				;027
	BNE	3$		;  No, use ?.?				;027
1$:	TSTB	(R0)		;  Find "V"				;027
	BEQ	3$		;    end of LOGO, bad news just use ?.?	;027
	CMPB	(R0)+,#'V	;    found "V"?				;027
	BNE	1$		;    no, keep looking			;027
	MOV	#3,R2		;  Copy version number, 3 characters	;027
	MOV	#4$,R1		;    into message at 4$			;027
2$:	MOVB	(R0)+,(R1)+	;    ...				;027
	SOB	R2,2$		;    ...				;027
3$:	MESSAGE			;Print header				;027
	 .ASCII <200><200>"              Micro/RSTS V"			;027
4$:	 .ASCII "?.? Installation"<200><200>				;027
	 .ASCII	"Terminate all your responses by pressing the RETURN key."<200> ;027
	 .ASCII	"Default responses appear in angle brackets."<200>	;027
	 .ASCII	"         e.g.,  Proceed?  <yes> "<200>			;027
	 .ASCII "To accept a default, press the RETURN key only."<200>	;027
	 .ASCIZ	"_______________________________________________________"<200><200> ;027
	UNORG								;027
	BR	20$		;Join up				;027

GLOBAL	<MICRO,LOGO>							;027
GLOBAL	<FLGGPK>							;030
.ENDC									;027

5$:	MOV	#10.,R0		;SAVE UP TO 10 CHARACTERS		;027
	MOV	#OUTSAV,R2	;POINT TO AREA TO SAVE PASSED NAME
10$:	MOVB	(R1)+,(R2)+	;COPY THE PASSED TEXT
	BEQ	20$		; UNTIL THE TERMINATING 0 IS FOUND
	SOB	R0,10$		;  BUT NO MORE THAN 10 CHARACTERS
	CLRB	OUTSAV+1	;FORCE ERROR WHEN PARSING
20$:	CALLX	SETFIP		;SET UP THE FIP CONTROL AREA
	CLRB	DSIFLG		;TELL DISK DRIVERS WE'RE DSKINTING
	CALLX	DATINI		;GET TIME AND DATE
	CALL	DIALOG		;ASK ALL DSKINT QUESTIONS
	CALL	FORMAT		;FORMAT PACK IF NECESSARY
	CALL	CKBADB		;DO THE BAD BLOCK CHECKS
	CALL	BUILD		;BUILD THE MINIMUM FILE STRUCTURE
	RETURN

	TMPORG	DSIDAT
OUTSAV:	.BLKB	10.		;AREA FOR PASSED NAME
	UNORG

GLOBAL	<DSIFLG>

.DSABL	LSB								;027


.SBTTL	DSKINT DIALOGGER

.ENABL	LSB

; MOVE DATE AND TIME INTO PROPER PLACE

DIALOG:	MOV	I.DATE,R0	;GET TODAY'S DATE
	MOV	R0,AD.BAD	;BADB.SYS ACCESS DATE
	MOV	R0,CD.BAD	;	  CREATION DATE
	MOV	R0,AD.SAT	;SATT.SYS ACCESS DATE
	MOV	R0,CD.SAT	;	  CREATION DATE
	MOV	R0,AC.0.1	;Set [0,1] creation date		;012
	MOV	R0,AC.1.1	; and [1,1]				;012
	MOV	R0,AC.1.2	;  and [1,2]				;012
	MOV	I.TIME,R0	;GET TIME NOW
	BIS	#UTC.IG,R0	;Set in the IGNORE flag.		;037
	MOV	R0,CT.BAD	;BADB.SYS CREATION TIME
	MOV	R0,CT.SAT	;SATT.SYS	"
	CLR	RL.BAD		;NO BAD BLOCKS YET
	CLR	SZ.BAD		;SIZE OF BADB.SYS IS 0 NOW
	MOV	#RE.SAT,R0	;POINT TO AREA TO CLEAR
	MOV	#<END0.1-RE.SAT>/2,R1 ;WORDS OF [0,1] UFD PROTOTYPE TO CLR
10$:	CLR	(R0)+		;CLEAR OUT RETRIEVAL
	SOB	R1,10$		; ENTRIES IN PROTOTYPE SAT

.IF	DF	ONLINE							;005
	MOV	#DNAME,R1	;Point to device name specified in DCL	;005
.IFF									;005
	MOV	#OUTSAV,R1	;TRY TO USE ORIGINAL NAME
.ENDC									;005

	TSTB	(R1)		;IS THERE ANY?
	BNE	20$		;YES, USE IT WITHOUT QUESTION

; ASK FOR DISK TYPE

ASKTYP:

.IF	NDF	ONLINE							;027
	CMP	MICRO,#-1	;Micro & Installation?			;027
	BEQ	DIALOG	;Yes, then user backed-up so reset disk name	;027

GLOBAL	<MICRO>								;027
.ENDC									;027

	CALLX	ASKER,R5	;ASK HIM WHICH DISK **$DISKS**
	 GENTXT	<<200>"Disk? ">


; Note:  We do not really support GPK, so the helps below listing its' disks
; are commented

.IF	DF	ONLINE							;010
	 GENTXT	<"Disk type (DV,DK,DL,DM,DP,DB,DR,DU)? ">		;021
;	 GENTXT	<"Disk type (DV,DK,DL,DM,DP,DB,DR,DW,DZ,DU)? ">		;030
.IFF									;010
	 GENTXT	<"Disk type (DK,DL,DM,DP,DB,DR,DU)? ">			;021
;	 GENTXT	<"Disk type (DK,DL,DM,DP,DB,DR,DW,DZ,DU)? ">		;030
.ENDC									;010

	BCC	19$		;Response was something other than ^Z	;016

.IF	DF	ONLINE							;020
	MOV	#EX$WAR,STATUS	;Indicate warning			;020
GLOBAL	<EX$WAR,STATUS>							;020
.ENDC									;020

	EXIT			;Leave if ^Z				;005

19$:	BMI	ASKTYP		;Re-ask if response was ^		;016
20$:	MOV	R1,R5		;COPY THE ANSWER POINTER
30$:	TSTB	(R5)+		;FIND THE END OF THE NAME
	BNE	30$		; AT THE NULL
	DEC	R5		;BACK UP AND CHECK
	CMPB	-(R5),#':	; FOR A TRAILING COLON
	BNE	40$		;NO
	CLRB	(R5)		;YES, ELIMINATE IT
40$:	CMPB	(R1),#'_	;Did he enter an underscore?		;033
	BNE	45$		;No, so continue			;033
	MOV	R1,R2		;Save the pointer for restore		;033
	MOV	R1,R5		;Save pointer begin			;033
	INC	R5		;Point to next char after "_"		;033
42$:	MOVB	(R5)+,(R1)+	;Move it down				;033
	BNE	42$		;And do until a null moved		;033
	MOV	R2,R1		;Restore string begin			;033
45$:	MOV	#DSKNAM,R5	;POINT TO LIST OF DISK NAMES
	CMPB	(R1),#'R	;DID HE TYPE 'R' INSTEAD OF 'D'?
	BNE	50$		;NO
	MOVB	#'D,(R1)	;YES, FIX HIM
50$:	CMP	(R1),(R5)+	;DO NAMES MATCH ?
	BEQ	70$		;YES, IT IS A DISK
	TST	(R5)		;NO, ANY MORE?
	BNE	50$		;YES, KEEP LOOKING
60$:	MESSAG	<"?Illegal disk name">					;005
	TSTABT								;005
	BR	ASKTYP		;TRY AGAIN

70$:									;005

.IF	DF	ONLINE							;005
	TST	DCLENT		;DCL entry?				;005
	BNE	75$		;Yes, we have the disk name already	;005
	MOV	(R1),DNAME	;Otherwise store the name		;005
75$:									;005
									;005
GLOBAL	<DCLENT,DNAME>							;005
.ENDC									;005

	SUB	#DSKNAM+2,R5	;R5 = DISK INDEX
	TST	DSKCSR(R5)	;DOES THAT CONTROLLER EXIST? (OR MULT-CNTRLR)?
	BNE	79$		;Yes, go on				;027
	JMP	200$		;NO, SORRY				;027

79$:	MOV	(R1)+,R3	;POP PAST THE DISK NAME			;027
	BIT	#TY.UNT,DSKTYP(R5) ;IS THIS A DISK WITH UNITS?
	BNE	140$		;YES, GO GET THE UNIT

GLOBAL	<I.DATE,I.TIME,DSKNAM,DSKCSR>


; ASK FOR NUMBER OF PLATTERS OF FIXED HEAD DISK

80$:	CLR	R4		;SET UNIT NUMBER 0 FOR NON-UNIT DISKS

.IF	NDF	ONLINE							;017

	MOV	#8.,R3		;ASSUME 8 PLATTER MAX
	MOVB	RFSLSV+1,R0	;R0 = TRUE SIZE OF RF HERE
	ASR	R0		;DIVIDING BY 1024
	ASR	R0
	CMP	R5,#IDX$DF	;RF disk?				;030
	BEQ	90$		;Yes					;030
	JMP	190$		;No, virtual disk or DW (GPK) disk	;030

90$:	MOVB	R0,100$		;SET TRUE SIZE IN MESSAGE
	BISB	#'0,100$	; AS AN ASCII DIGIT
	MOVB	R3,110$		;SET MAX
	BISB	#'0,110$	;MAKE IT A DIGIT
	CALLX	ASKER,R5	;DF, ASK NUMBER OF PLATTERS
	 GENTXT
	  .ASCII "Platters ("
100$:	  .ASCIZ "0)? "
	 UNORG
	 GENTXT
	  .ASCII "Number of disk platters (1-"
110$:	  .ASCIZ "8)? "
	 UNORG
	BCS	ASKTYP		;^Z -- ASK FIRST QUESTION		;016
	BMI	ASKTYP		;^ -- ASK PREVIOUS  QUESTION		;016
	BEQ	120$		;LINE FEED -- USE TRUE NUMBER OF PLATTERS
	CALLX	DECINP		;GET NUMBER OF PLATTERS
	BNE	80$		;ERROR IN NUMBER
120$:	TST	R0		;SAID 0?
	BEQ	80$		;YES, THERE MUST BE A PLATTER
	CMP	R0,R3		;MORE THAN MAXIMUM?
	BHI	80$		;YUP, TOO MANY
	SWAB	R0		;MULTIPLY BY 256 TO GET BLOCKS
130$:	ASL	R0		;RF11 DISK, MULTIPLY BY 1024 BL/PLATTER
	ASL	R0
	MOV	R0,DF$SZL	;SET SIZE OF DISK

GLOBAL	<RFSLSV,DF$SZL>

.ENDC									;005
	BR	190$		;AND USE UNIT 0				;005

; DISK HAS UNITS - ASK FOR UNIT NUMBER

140$:	MOVB	@SUBUNT(R5),R3	;GET MAX NO. OF UNITS FOR THIS DISK
	DEC	R3		;Convert to highest legal unit number	;005

.IF	DF	ONLINE							;005
	TST	DCLENT		;DCL entry?				;005
	BEQ	145$		;No, ask for unit number		;005
	MOV	DUNT,R0		;Yes, get preset unit number		;005
	BR	175$		;Check it out				;005

.ENDC									;005

145$:	MOV	R3,R0		;COPY TO R0 FOR DECSTR
	MOV	R1,-(SP)	;SAVE OUR TEXT POINTER
	MOV	#160$,R1	;GET THE ADDR TO STORE MAXIMUM UNIT NUMBER
	CALLX	DECSTR		;AND CONVERT IT TO AN ASCII STRING
	MOV	(SP)+,R1	;RESTORE OUR TEXT POINTER
	TSTB	(R1)		;UNIT SUPPLIED WITH DISK NAME?
	BNE	170$		;YES, TRY TO USE IT
150$:

.IF	NDF	ONLINE							;027
	CMP	MICRO,#-1	;Micro & Installation?			;027
	BNE	155$		;No, continue				;027
	CALLX	ASKER,R5	;Ask questions				;027
	 .WORD	157$							;027
	 .WORD	157$							;027
	BCS	150$		;^Z -- Re-ask				;027
	BMI	150$		;^ -- Re-ask				;027
	BR	165$		;Join up				;027

GLOBAL	<MICRO>								;027
.ENDC									;027

155$:	MOV	#161$,R1	;Write over Micro Installation text	;027
	MOV	#162$,R2	; ...					;027
156$:	MOVB	(R2)+,(R1)+	; ...					;027
	BNE	156$		; ...					;027
	CALLX	ASKER,R5	;ON DS,DK,DL,DM,DP,DR,DB,DU ASK WHICH UNIT
	 GENTXT	<"Unit? <0> ">
	 GENTXT								;027
157$:	  .ASCII <200>"Enter the physical unit number of the disk you want"<200> ;027
	  .ASCII "to use.  This number must be in the range 0 to "	;027
160$:	  .ASCII "??????. The"<200>"default is unit 0."<200>		;027
	  .ASCII <200>"Please enter the unit number"			;027
161$:	  .ASCII " of your system disk"  ; Text for Micro Installation	;027
162$:	  .ASCIZ ": <0> " 		; Terminate prompt		;027
	 UNORG								;027
	BCS	ASKTYL		;^Z -- ASK FIRST QUES., jmp thru ASKTYL ;033
	BMI	ASKTYL		;^ -- ASK PREVIOUS QUESTION		;033
165$:	BNE	170$		;Not default, check if number		;027
	CLR	R0		;Set default				;027
	BR	175$		;Skip check if number			;027

170$:	CALLX	DECINP		;GET UNIT NUMBER
	BNE	185$		;Illegal number				;005
175$:	CMPB	R0,R3		;COMPARE AGAINST LIMIT FOR THIS DISK. VALID? ;005
	BHI	185$		;No, issue error			;005
	CLR	R4		;PREPARE TO COPY DISK TYPE TABLE TO WORK COPY
180$:	MOV	DSKTYP(R4),TMPTYP(R4) ;COPY A WORD INTO THE WORK TABLE
	TST	(R4)+		;BUMP THE POINTER
	CMP	R4,#DTTSIZ	;COPIED WHOLE TABLE YET?
	BNE	180$		;NOPE, NOT YET.
	MOVB	R0,R4		;SET UNIT NUMBER IN R4

.IF	DF	ONLINE							;005
	TST	DCLENT		;DCL entry?				;005
	BNE	190$		;Yes, we already know unit number	;005
	MOVB	R4,DUNT		;Save unit number for online use	;005
									;005
GLOBAL	<DCLENT,DUNT>							;005
.ENDC									;005

	BR	190$		;Continue				;005

185$:	MESSAGE	<"?Illegal disk unit specified"<200>>			;005
	TSTABT								;005
	BR	150$		;Ask again				;005


; SET UP DISK TYPE AND UNIT IN FIP TABLES

190$:									;005
.IF	DF	ONLINE							;005
	CALLX	CHKMNT		;Is this unit mounted?			;005
	BCS	205$		;Yes, reject it				;005
.ENDC									;005
.IF	NDF	ONLINE							;013
	MOV	R5,COINDX	;Save disk index for auto-COPY		;013
	MOV	R4,COUNIT	;Save disk unit number for auto-COPY	;013
.ENDC									;013
	MOV	R5,SYSNDX	;SET UP FAKE SYSTEM DISK INDEX
	MOV	R4,R0		;COPY UNIT NUMBER
	MOVB	R0,SYSPHU+1	;SET SYSTEM PHYSICAL UNIT FOR FIP
	MOVB	R0,SYSUNT
	CALL	DRESET		;RESET THE DISK
	CALLX	GETDVC,R5,<SYSNDX,SYSUNT,DCS> ;GET DCS OF THIS DISK
	ASL	R0		;UNIT * 2
	MOVB	R0,SYSPHU
	MOVB	R0,I.DSQ+DSQOUN	;SET UNIT NUMBER IN DSQ
	MOV	R0,R1		;COPY UNIT*2
	ADD	DSKSZL(R5),R0	;POINT TO LOW ORDER SIZE FOR DISK
	ADD	DSKSZM(R5),R1	;POINT TO HIGH ORDER SIZE
	MOV	(R0),R0		;R0 = LOW ORDER SIZE
	MOV	(R1),R1		;R1 = HIGH ORDER SIZE
	BNE	210$		;NON-0 SIZE, SO DISK EXISTS
	TST	R0		;IS THE SIZE 0?
	BEQ	200$		;Yes, not there				;027
	CMP	R0,#MINFSZ	;Too small to be file-structured?	;038
	BHI	210$		;No, so go on.				;038
	MESSAGE	<"?Disk is too small to be RSTS file-structured"<200>>	;038
	TSTABT			;See if we want to go on.		;038
	BR	ASKTYL		;Otherwise, try again.			;038

.IF	DF	ONLINE							;032
200$:	MESSAG	<"?Sorry, but that disk doesn't exist">			;032
.IFF									;032
200$:	CALLX	VBCHK		;Is this a virgin boot?			;032
	BCS	202$		;Yes, so handle specifically.		;032
	MESSAG	<"?Sorry, but that disk doesn't exist">			;032
	BR	205$		;And go exit correctly.			;032

202$:	MESSAG	<"That disk was not found during limited hardware scan."<200>> ;032
	CALLX	FSZBOT		;See if they want to reboot w/full scan.;032
				;If we come back inline, they said 'No'	;032
.ENDC	;ONLINE								;032

205$:	TSTABT								;005
ASKTYL:	JMP	ASKTYP		;RESTART

210$:	CMP	R5,SYNXSV	;IS THIS THE SYSTEM DISK?
	BNE	230$		;NO
	CMP	R4,SYSUSV	;IS IT THE BOOTED UNIT ?
	BNE	230$		;NO, RIGHT CONTROLLER - WRONG UNIT
220$:	MESSAG	<"?DSKINT not legal on system disk">			;005
	TSTABT								;005
	BR	ASKTYL		;RESTART

230$:	MOV	DCS,R2		;GET DEVICE CLUSTER SIZE
	DEC	R2		;DCS-1
	SUB	R2,R0		;FIX DISK SIZE FOR WASTE SPACE
	SBC	R1
	MOV	R0,D.SIZL	;SAVE CORRECTED DISK SIZE
	MOV	R1,D.SIZM

.IF	NDF	ONLINE							;005

; SEE IF SELECTED RB/RR UNIT IS ONE OF THE SPECIAL NON-FORMATTABLE TYPES

FMTSPC::MOV	SYSNDX,R1	;COPY CONTROLLER TYPE INDEX
	CMP	R1,#IDX$DB	;MIGHT THE DISK BE AN RP07, RM05 OR RM80?
	BEQ	240$		;IT MIGHT...
	CMP	R1,#IDX$DR	;TRY THE OTHER TYPE OF CONTROLLER
	BNE	260$		;NO CHANCE.
240$:	MOV	DSKMID(R1),R0	;GET A POINTER TO ITS MASSBUS ID TABLE
	MOVB	SYSPHU,R2	;COPY THE UNIT NUMBER * 2,
	BIC	#^C<377>,R2	; AND JUNK EVERYTHING ELSE
	ADD	R2,R0		;NOW ADD IN THE OFFSET INTO THE M.I.D. TABLE
	MOV	(R0),R0		;GOT THE MASSBUS ID FOR THE UNIT NOW
	CMPB	R0,#RP07ID	;WUZZIT AN RP07 DRIVE?
	BEQ	250$		;YEP.
	CMPB	R0,#RM80ID	;MAYBE AN RM80?
	BNE	260$		;NONE OF THE ABOVE, SO LIFE IS STILL SIMPLE
250$:	BIC	#TY.FMT,TMPTYP(R1) ;ONE OF THE ABOVE, SO NO FORMATTING ALLOWED

.ENDC									;005

260$:	CALL	ISRSTS		;CHECK IF DISK ALREADY HAS RSTS FILE STRUCTURE
	CLR	C.FRMT		;Say we cannot controller format	;033
.IF	NDF	ONLINE		;Offline only FORMATTING check		;033
261$:	MOVB	#1,DSIFLG	;Set silent DSKINT error mode		;033
	CALL	CTLINQ		;Check for formatting valid		;033
	BCS	262$		;Fomatting is not valid			;033
	COM	C.FRMT		;Formatting is valid, so set flag	;033
262$:	CLRB	DSIFLG		;Clear to std DSKINT error mode		;033
.ENDC
	CMPB	IOERR,#HNGDEV	;Device not ready?			;033
	BNE 	ASKPAK		;No, ok, so continue			;033
264$:	CALLX	ASKER,R5,<MNORDY,QRETRY> ;NOT READY, ASK IF RETRY	;033
	BCS	267$		;^Z - Start over			;033
	BMI	267$		;^  - Start over			;033
	CMPB	(R1),#12	;TYPED LF?				;033
	BEQ	260$		;YUP					;033
	JMP	FMTABT		;NO, ABORT THE DSKINT			;033

267$:	JMP	DIALOG		;Restart the dialog			;033
.DSABL	LSB

GLOBAL	<SYSNDX,SYSPHU,SYSUNT,DCS,I.DSQ,DSKSZL,DSKSZM,SYNXSV,SYSUSV,SUBUNT>
.IF	NDF	ONLINE							;013
GLOBAL	<COINDX,COUNIT>
.ENDC									;013

; ASK FOR PACK ID AND PACK CLUSTER SIZE

.ENABL	LSB

ASKPAK:									;005

.IF	DF	ONLINE							;005
	TST	DCLENT		;DCL entry?				;005
	BNE	ASKPCL		;Yes, pack ID already set up		;005

.IFF									;027
	CMP	MICRO,#-1	;Micro & Installation?			;027
	BNE	5$		;No, ask the question			;027
	MOV	#^RMIC,PACKID	;Yes, set packid,			;027
	MOV	#^RRO ,PACKID+2	;	both words			;027
	BR	11$		;Set PCS to max(DCS,2)			;027

GLOBAL	<MICRO>								;027
.ENDC									;005

5$:	CALL	GETR50,R5	;GET PACK ID				;027
	 GENTXT	<"Pack ID? ">
	 .WORD	PACKID
	BCS	ASKTYL		;^Z -- ASK FIRST QUESTION		;016
	BMI	ASKTYL		;^ -- ASK PREVIOUS QUESTION		;016
ASKPCL:	MOV	DCS,R0		;Get device clustersize			;005
	MOV	#-1,LRGDSK	;assume large disk (so getcl works)	;028
	MOV	R0,PACKCL	;THIS IS USED AS MINIMUM PCS IN GETCL	;005
	MOV	R0,PCS		;Default if <LF> is anwered		;005
	MOV	#10$,R1		;Store string here			;005
	CALLX	DECSTR		;Convert (R0) to decimal string		;005
.IF	DF	ONLINE							;005
	MOV	#DCLPCS,R1	;Point to DCL's preset PCS if any	;005
GLOBAL	<DCLPCS>							;005
.ENDC									;005
	MOV	#1,QUESNM	;setup as first question to GETCL	;031
	CALL	GETCL,R5	;GET PACK CLUSTER SIZE
	 GENTXT								;005
	  .ASCII "Pack cluster size <"					;005
10$:	  .ASCIZ "??????>? "						;005
	 UNORG
	 .WORD	PCS
	BCS	ASKTYL		;^Z -- ASK FIRST QUESTION		;016
	BMI	ASKPAK		;^ -- ASK PREVIOUS QUESTION		;016
	BR	15$		;Proceed				;027

.IF	NDF	ONLINE							;027
11$:	MOV	DCS,PCS		;Set PCS to DCS				;027
	CMP	#1,DCS		;Is device cluster size = 1?		;027
	BNE	15$		;No, continue				;027
	MOV	#2,PCS		;Yes, set pack cluster size to 2	;027
.ENDC									;027

15$:	CLR	LRGDSK		;assume not a large disk now		;028
	MOV	PCS,R0		;Pick up pack clustersize		;027
	MOV	R0,CL.BAD	;PCS IS USED FOR CLUSTERSIZE OF BADB.SYS
	MOV	R0,CL.SAT	; AND SATT.SYS
	MOV	R0,PACKCL	;AND FOR PACK CLUSTER SIZE
	MOV	#16.,CL.0.1	;[0,1] CLUSTER SIZE IS 16
..CL01	==	.-4		;CLUSTERSIZE FOR SMALL SYSTEMS

	CMP	R0,#16.		;pack clustersize > 16?			;028
	BLOS	17$		;No, so normal				;028
	DEC	LRGDSK		;set flag for this			;028
17$:

.IF	DF	ONLINE							;026
	CMP	SYSNDX,#IDX$DV	;Virtual disk?				;026
	BNE	20$		;No, continue				;026
	MOV	R0,CL.0.1	;Yes, use PCS as [0,1] cluster size	;026
	CMP	R0,#16.		;large virtual disk (oh, commonnow!!!)	;031
	BLOS	18$		;no, so ok				;031
	MOV	#16.,CL.0.1	;yes, so set clustersize		;031
18$:									;031
.ENDC									;026

20$:	MOV	R0,R1		;COPY FOR DIVIDE
	CLR	R0
	DIV	DCS,R0		;COMPUTE CLUSTER RATIO
	MOV	R0,CLURAT
	CALLX	SETSAT		;SET UP THE SAT PARAMETERS
	CMP	SATSYS+SEGS,#16.;Are we dealing with a large disk?	;028
	BLOS	ASKMFD		;No, so std				;028
	MOV	#16.*1000,SATSYS+BYTS ;Yes, set to 16. block value for extend ;028
	MOV	#16.,SATSYS+SEGS   ;ditto				;031

.DSABL	LSB

; Ask for MFD/GFD clustersize						;004

.ENABL	LSB								;026

ASKMFD:	MOV	#16.,R0		;Set default				;026
	CLR	FLOPPY		;Assume not a floppy			;039
	TST	D.SIZM		;A HIGH ORDER SIZE?			;039
	BNE	5$		;HO nonzero, so disk is a biggie	;039
	CMP	D.SIZL,#FLPYSZ	;Is this (probably) a floppy or DV?	;039
	BHI	2$		;No, so do standard SATT defaults	;039
	COM	FLOPPY		;Also flag for later checks		;039
	BR	3$		; and use small clustersize		;039

2$:	CMP	SYSNDX,#IDX$DV	;Virtual disk?				;026
	BNE	5$		;No, continue				;026
3$:	MOV	PCS,R0		;Yes, use MAX(PCS,4) as [0,*]		;026
	CMP	R0,#4		;	GFD cluster size		;026
	BHIS	5$		;	...				;026
	MOV	#4,R0		;	...				;026
5$:	CMP	PACKCL,#4	;Pack clustersize 4 or more?		;026
	BHIS	10$		;Yes					;005
	MOV	#4,PACKCL	;No, set 4 as minimum MFD clustersize	;005
10$:	MOV	#11$,R1		;Put string here			;026
	CALLX	DECSTR		;Convert (R0) to decimal string		;026
	MOV	R0,MFDCLU	;Default clustersize			;026

.IF	DF	ONLINE							;026
	MOV	#DCLMFD,R1	;Point to DCL's preset MFD clustersize	;026

GLOBAL	<DCLMFD>							;026
.IFF									;027
	CMP	MICRO,#-1	;Micro & Installation?			;027
	;CLC			;If BEQ, then C is clear		;027
	BEQ	12$		;Yes, use default, goto SATT question	;027

GLOBAL	<MICRO>								;027
.ENDC									;027

	MOV	#2,QUESNM	;MFD = 2nd question to GETCL		;031
	CALL	GETCL,R5	;Ask for a clustersize			;027
	 GENTXT								;026
	  .ASCII "MFD cluster size <"					;026
11$:	  .ASCIZ "??????>? "						;026
	 UNORG								;026
	 .WORD	MFDCLU		;Store it here				;004
	BMI	20$		;^ -- ASK PREVIOUS QUESTION		;016
12$:	MOV	PCS,PACKCL	;Restore normal minimum clustersize	;005
	BCS	15$		;^Z -- ASK FIRST QUESTION		;027

	BR	ASKSAT		;TO NEXT QUESTION			;016

15$:	JMP	ASKTYL							;027

20$:	MOV	PCS,PACKCL	;Restore normal minimum clustersize	;016
	JMP	ASKPCL		;TO PREVIOUS QUESTION			;016

GLOBAL	<PCS,DCS,CLURAT>

.DSABL	LSB								;026


; ASK FOR BASE OF SATT.SYS ON DISK

.ENABL	LSB

5$:	JMP	ASKTYP		;TO FIRST QUESTION			;019

ASKSAT:	MOV	D.SIZL,R3	;GET LOW ORDER SIZE WORD		;005
	MOV	D.SIZM,R2	;GET HIGH ORDER SIZE WORD		;005
	BNE	7$		;HO nonzero, so disk is a biggie	;035
	TST	FLOPPY		;A floppy				;039
	BEQ	7$		;No, 0 = not a floppy			;039
	MOV	#1,R2		;Yes, so set default to 1		;035
	BR	8$		;Join common display question		;035

7$:	SUB	#21,R3		;MOVE SATT 20 BLOCKS SOUTH OF BORDER	;005
	SBC	R2		;BOTH WORDS				;005
	ASHC	#-1,R2		;Divide by 2 to get the middle		;005
	DIV	DCS,R2		;Divide to get DCN			;005
	CMP	R2,#25442.	;Is an RC25? - not the best check, but	;039
	BNE	8$		;NO		- it will do for now	;039
	ROR	R2		;YES		- /2 again = middle	;039
8$:	MOV	R2,R0		;Copy the value for DECSTR		;035
	MOV	#30$,R1		;Point to where to store string		;005
	CALLX	DECSTR		;Convert to decimal string		;005
	CALLX	RIB2CN		;Convert default DCN to PCN		;005
	MOV	R3,D.PREF	;Set as default position		;005

.IF	DF	ONLINE							;005
	TST	DCLENT		;DCL entry?				;005
	BEQ	10$		;No, ask for SATT base			;005
	MOV	#DCLIND,R1	;Point to DCL's answer for /INDEX	;005
	TSTB	(R1)		;Is there one?				;005
	BEQ	ASKEXT		;No, accept the default			;005
	BR	40$		;Yes, process it			;005

GLOBAL	<DCLIND>

.IFF									;027
	CMP	MICRO,#-1	;Micro & Installation?			;027
	BEQ	ASKEXT		;Yes, accept default			;027

GLOBAL	<MICRO>								;027
.ENDC									;005

10$:	CALLX	ASKER,R5	;ASK FOR BASE OF SATT.SYS
	 .WORD	20$		;SHORT FORM BELOW
	 GENTXT
	  .ASCII "Type a block number to locate the file SATT.SYS at a specific"<200>
	  .ASCII "place on the disk, or type <CR> to let RSTS find a location."<200>
20$:	  .ASCII "SATT.SYS base <"					;005
30$:	  .ASCIZ "??????>? "						;005
	 UNORG
	BCS	5$		;^Z -- ASK FIRST QUESTION		;016
	BMI	ASKMFD		;^ -- ASK PREVIOUS QUESTION		;016
	BEQ	ASKEXT		;Line feed -- use the default		;005
40$:	CALL	GETPOS,R5,D.PREF ;Process that position			;004
	BCC	ASKEXT		;Valid, continue			;005
.IF	DF	ONLINE							;005
	TST	DCLENT		;DCL entry?				;005
	BEQ	50$		;No					;005
	MESSAGE	<"?Illegal argument for /INDEX"<200>>			;005
	BR	60$							;005
.ENDC									;005
									;005
50$:	MESSAGE	<"?Illegal or too large number"<200>>			;005
60$:	TSTABT								;005
	BR	ASKSAT		;Try again				;005

; ASK IF DIRECTORIES SHOULD BE EXTENDED

ASKEXT:	CLRB	P.EXT		;ASSUME NO EXTENDING

.IF	DF	ONLINE							;005
	TST	DCLENT		;DCL entry?				;005
	BNE	ASKPUB		;Yes, pre-extend is off			;005

.IFF									;027
	CMP	MICRO,#-1	;Micro & Installation?			;027
	BEQ	ASKPUB		;Yes, no extending			;027

GLOBAL	<MICRO>								;027
.ENDC									;005

	CALL	YESNO,R5	;ASK				
	.WORD	70$
	GENTXT
	 .ASCII	/Type YES to force the directories to be pre-extended/<200> ;002
	 .ASCII	/to their maximum size when created./<200>		;002
70$:	 .ASCIZ	/Pre-extend directories <NO>? /
	UNORG
	BR	ASKSAT		;^    -- ASK PREVIOUS QUESTION		;016
	BR	ASKPUB		;<LF> -- ASK NEXT QUESTION
	BR	ASKPUB		;NO   -- ASK NEXT QUESTION
	BR	75$		;YES					;016
	JMP	ASKTYP		;^Z   -- ASK FIRST QUESTION		;016

75$:	MOVB	#-1,P.EXT	;SET FLAG FOR EXTENDING DIRECTORIES	;016
	BR	ASKPUB		; and go onto the next question		;039

.DSABL	LSB

GLOBAL	<DCS,SATSYS>

; ASK FOR TYPE (PUBLIC, PRIVATE, OR SYSTEM)

.ENABL	LSB

101$:	JMP	ASKTYP		;TO FIRST QUESTION			;016

ASKPUB:	CLR	SYSFLG							;005
	CLR	QUODSK		;CLEAR FLAG				;039
	MOV	#1*400+2,REVLVL	; Start with the new revlevel		;039

.IF	DF	ONLINE							;005
	TST	DCLENT		;DCL entry?				;005
	BNE	30$		;Yes, type has been set up already	;005

.IFF									;027
	CMP	MICRO,#-1	;Micro & Installation?			;027
	BNE	1$		;No, ask question			;027
	MOV	#^RSYS,R0	;Yes, use system			;027
	BR	15$		;Join up				;027

1$:
GLOBAL	<MICRO>								;027
.ENDC									;005

	CALLX	ASKER,R5						;027
;014+
	 GENTXT
	  .ASCII "PUB, PRI, or SYS <"
.IF	DF	ONLINE
	  .ASCIZ "PRI>? "
.IFF
	  .ASCIZ "SYS>? "
.ENDC
	 UNORG
	 GENTXT
	  .ASCII "Public (PUB), private (PRI), or system (SYS) disk <"
.IF	DF	ONLINE
	  .ASCIZ "PRI>? "
.IFF
	  .ASCIZ "SYS>? "
.ENDC
	 UNORG
;014-
	BCS	101$		;^Z -- ASK FIRST QUESTION		;016
	BMI	ASKEXT		;^ -- ASK PREVIOUS QUESTION		;016
	BNE	10$		;Not <LF>				;005
;014+
.IF	DF	ONLINE
	MOV	#^RPRI,R0	;Set the default			;005
.IFF
	MOV	#^RSYS,R0	;Set the default for INIT
.ENDC
;014-
	BR	15$		;Use it					;005

10$:	CALLX	RADINP		;PICK IT UP IN RAD50			;005
	TSTB	(R1)		;CHECK FOR GOOD RAD50 INPUT
	BNE	24$		;IF NOT, ASK AGAIN			;039
15$:	MOV	#UC.PRI!UC.NEW,PACKST ;ASSUME PRIVATE OR SYSTEM		;040
	CMP	R0,#^RSYS	;DID HE SAY SYSTEM?
	BNE	20$		;No					;002
	MOV	#1*400+2,PP.1.2	;Preset that we want [1,2]		;002
	MOV	#-1,SYSFLG	;FLAG IT
	BR	50$		;Go ask for [1,1] parameters		;002

20$:	CMP	R0,#^RPRI	;HOW ABOUT PRIVATE ?			;002
	BEQ	30$		;YES, ASK IF HE WANTS [1,1] and [1,2]	;002
	CMP	R0,#^RPUB	;IT MUST BE PUBLIC
	BNE	ASKPUB		;IF NOT, ASK HIM AGAIN
	MOV	#UC.NEW,PACKST	;Set the "new pack" status		;039
	BR	30$		; and go do it				;039

24$:	MOV	#UC.PRI!UC.NEW,PACKST ;ASSUME PRIVATE OR SYSTEM		;040
	CMP	R0,#^RPRI	;Only allow switches on private		;039
	BNE	ASKPUB		;  Not private				;039
	CMPB	(R1)+,#'/	;A switch?				;039
	BNE	ASKPUB		;  No					;039
	CMPB	(R1)+,#'N	;/N?					;039
	BNE	ASKPUB		;  No					;039
	CMPB	(R1)+,#'Q	;/NQ?					;039
	BNE	ASKPUB		;  No					;039
	TSTB	(R1)		; Just /NQ?				;039
	BNE	ASKPUB		;  No, so try again			;039
	CALL	YESNO,R5	;ASK IF HE WANTS quotas on this disk	;039
	 GENTXT	<"Use Quotas <YES>? ">					;039
	 GENTXT
	 .ASCII	"Do you plan to use logged in quotas on this disk or"<200>
	 .ASCIZ	"will this disk ever be used as a system disk (Y or N)? <Yes> " ;039
	 UNORG
	 BR	ASKPUB		;^  -- ASK PREVIOUS QUESTION		;039
	 BR	30$		;LF = YES (default)			;039
	 BR	28$		;NO -- No quotas			;039
	 BR	30$		;YES -- Use quotas			;039
	 JMP	ASKTYP		;^Z  -- ASK FIRST QUESTION		;039

28$:	COM	QUODSK		;Set the NOQUOTAS flag			;039
	MOV	#1*400+1,REVLVL	; and an old revlevel			;039
	; .BYTE	1,1		; Rev 1.1 (which has NO quotas)		;039
30$:	CLR	NE.1.1		;Clear attribute link from [1,1]	;002
	CLR	PP.1.1		;FREE UP THE DIRECTORY BLOCKS		;002
	CLR	AE.1.1		;BOTH NAME AND ACCOUNT			;002
	CLR	AP.1.1		;Password block				;016
	CLR	AP.1.1+2	;					;016
	CLR	AQ.1.1		;Quota attribute also			;012
	CLR	AQ.1.1+2						;012
	CLR	A2.1.1		; and second quota attribute		;012
	CLR	A2.1.1+2						;012
	CLR	AN.1.1		; and the account name			;039
	CLR	AN.1.1+2						;039
	CLR	AD.1.1		;Date/time attribute also		;005
	CLR	AD.1.1+2						;005
	CLR	NE.1.2		;Clear attribute link from [1,2]	;002
	CLR	PP.1.2		;FREE UP THE DIRECTORY BLOCKS		;002
	CLR	AE.1.2		;BOTH NAME AND ACCOUNT			;002
	CLR	AP.1.2		;Password block				;016
	CLR	AP.1.2+2	;					;016
	CLR	AV.1.2		;Privilege block			;016
	CLR	AV.1.2+2	;					;016
	CLR	AQ.1.2		;Quota attribute also			;012
	CLR	AQ.1.2+2						;012
	CLR	A2.1.2		; and second quota block		;012
	CLR	A2.1.2+2						;012
	CLR	AN.1.2		; and the account name			;039
	CLR	AN.1.2+2						;039
	CLR	AD.1.2		;Date/time attribute also		;005
	CLR	AD.1.2+2						;005
.IF	DF	ONLINE							;005
	TST	DCLENT		;DCL entry?				;005
	BEQ	40$		;No, go ask questions			;005
	MOV	#-1,D.ERRD	;Set flag saying error records not read	;025
	JMP	DCLFIN		;Skip a lot and get patterns		;005
.ENDC									;005

; Find out if [1,1] should be created					;012

40$:	CLR	PP.1.1		;CLEAR FLAG 
	CALL	YESNO,R5	;ASK IF HE WANTS A [1,1] ACCOUNT	;016
	 GENTXT	<"Create account [1,1] <NO>? ">				;002
	 GENTXT	<"Should account [1,1] be created on this disk (Y or N)? "> ;002
	 BR	64$		;^  -- ASK PREVIOUS QUESTION (ASKPUB)	;039
	 NOP			;LF = NO				;002
	 BR	80$		;NO -- DON'T MAKE [1,1]			;002
	 BR	50$		;YES -- MAKE [1,1]			;002
	 JMP	ASKTYP		;^Z  -- ASK FIRST QUESTION		;016

50$:	MOV	#1*400+1,PP.1.1	;SET UP PPN = [1,1]			;002
	MOV	#1,AE.1.1	;MARK ACCOUNTING BLOCK IN USE		;002
	MOV	#AD.1.1-GFD1,NE.1.1 ; link date/time incase 1.1		;039
	MOVB	#AA.DAT,AD.1.1+UATYP ;Set type = date/time record	;005
	TST	QUODSK		;Check the NOQUOTAS flag		;039
	BNE	60$		; No [1,1] attributes			;039
	MOV	#AQ.1.1-GFD1,NE.1.1 ;Link quota to [1,1] N.E.		;039
	MOV	#AD.1.1-GFD1,AQ.1.1 ; and date/time attr to quota attr.	;039
	MOV	#A2.1.1-GFD1,AD.1.1 ; and second quota to date/time	;039
	MOV	#AN.1.1-GFD1,A2.1.1 ; and account name to 2nd quota	;039
	MOV	#AP.1.1-GFD1,AN.1.1 ; and pass to account name		;039
	MOVB	#AA.PAS,AP.1.1+UATYP ;Set type = password blockette	;016
	MOVB	#'?,AP.1.1+UADAT	; Unusable password		;021
	MOVB	#AA.QUO,AQ.1.1+UATYP ;SET TYPE = QUOTA BLOCKETTE
	MOVB	#-1,AQ.1.1+AQ.DJB ; and reset detached quota to inf.	;012
	MOV	#AA.QT2,A2.1.1+UATYP ;Set type = second quota		;012
	MOVB	#-1,A2.1.1+A2.JOB ; and reset total job quota to inf.	;012
	MOVB	#AA.NAM,AN.1.1+UATYP ;Set type = account name		;039
	MOVB	#'[,AN.1.1+UADAT  ; and reset the name			;039

60$:	MOV	#16.,R0		;setup default				;028
	TST	FLOPPY		;A floppy				;039
	BEQ	61$		;No, 0 = not a floppy			;039
	MOV	#4,R0		; but make it small for floppies	;039
61$:	MOV	R0,CL.1.1	;Default clustersize is 16		;028
	MOV	#62$,R1		;Convert it				;028
	CALLX	DECSTR		;do it					;028

.IF	NDF	ONLINE							;027
	CMP	MICRO,#-1	;Micro & Installation?			;027
	BEQ	70$		;Yes, use default			;027

GLOBAL	<MICRO>								;027
.ENDC									;027

	MOV	#3,QUESNM	;[1,1]=3rd question to GETCL		;031
	CALL	GETCL,R5	;GET [1,1] CLUSTER SIZE		
	 GENTXT								;028
	  .ASCII "[1,1] cluster size <"					;028
62$:	  .ASCIZ "??????>? "						;028
	 UNORG								;028
	 .WORD	CL.1.1
	BCS	65$		;^Z -- ASK FIRST QUESTION		;016
	BPL	70$		;NOT ^, GO ON				;016
	TST	SYSFLG		;SYSTEM DISK?
	BNE	64$		;Yes, so do it				;028
	JMP	40$		;Nope (This was a BEQ-too long)		;028

64$:	JMP	ASKPUB		;YEP

65$:	JMP	ASKTYP		;TO FIRST QUESTION			;027

70$:	TST	SYSFLG		;Did we decide to do [1,2] already?	;027
	BNE	90$		;Yes, so do it				;028
ASK12:
80$:	CLR	PP.1.2		;CLEAR FLAG
	CALL	YESNO,R5	;ASK IF HE WANTS A [1,2] ACCOUNT	;016
	 GENTXT	<"Create account [1,2] <NO>? ">				;002
	 GENTXT	<"Should account [1,2] be created on this disk (Y or N)? "> ;002
	 BR	40$		;^  -- ASK PREVIOUS QUESTION		;016
	 NOP			;LF = NO
	 BR	120$		;NO -- DON'T MAKE [1,2]			;002
	 BR	90$		;YES -- MAKE A LIBRARY
	 JMP	ASKTYP		;^Z   -- ASK FIRST QUESTION		;016

; ASK FOR [1,2] CLUSTER SIZE

90$:	MOV	#1*400+2,PP.1.2	;SET UP PPN = [1,2]
	MOV	#1,AE.1.2	;MARK ACCOUNTING BLOCK IN USE
	MOV	#AD.1.2-GFD1,NE.1.2 ; Link date/time incase 1.1		;039
	MOVB	#AA.DAT,AD.1.2+UATYP ;Set type = date/time record	;005
	TST	QUODSK		;Check the NOQUOTAS flag		;039
	BNE	110$		; No [1,2] creation			;039
	MOV	#AQ.1.2-GFD1,NE.1.2 ;Link quota to [1,2] N.E.		;039
	MOV	#AD.1.2-GFD1,AQ.1.2 ; and date/time attr to quota attr.	;039
	MOV	#A2.1.2-GFD1,AD.1.2 ; and second quota to date/time	;039
	MOV	#AN.1.2-GFD1,A2.1.2 ; and account name to 2nd quota	;039
	MOV	#AP.1.2-GFD1,AN.1.2 ; and pass to account name		;039
	MOV	#AV.1.2-GFD1,AP.1.2 ; and priv. to second quota		;039
	MOVB	#AA.PAS,AP.1.2+UATYP ;Set type = password blockette	;016
	MOVB	#'?,AP.1.2+UADAT	; Unusable password		;021
	MOVB	#AA.PRV,AV.1.2+UATYP ;Set type = privilege blockette	;016
	MOVB	#AA.QUO,AQ.1.2+UATYP ;SET TYPE = QUOTA BLOCKETTE
	MOVB	#-1,AQ.1.2+AQ.DJB ; and reset detached quota to inf.	;012
	MOV	#AA.QT2,A2.1.2+UATYP ;Set type = second quota		;012
	MOVB	#-1,A2.1.2+A2.JOB ; and reset total job quota to inf.	;012
	MOVB	#AA.NAM,AN.1.2+UATYP ;Set type = account name		;039
	MOVB	#'[,AN.1.2+UADAT  ; and reset the name			;039

110$:	MOV	#16.,R0		;Move in standard default		;028
	TST	FLOPPY		;A floppy				;039
	BEQ	111$		;No, 0 = not a floppy			;039
	MOV	#4,R0		; but make it small for floppies	;039
111$:	MOV	R0,CL.1.2	;Default clustersize is 16		;028
	MOV	#112$,R1	;Convert it				;028
	CALLX	DECSTR		;do it					;028


.IF	NDF	ONLINE							;027
	CMP	MICRO,#-1	;Micro & Installation?			;027
	BEQ	ASKBAS		;Yes, use default			;027

GLOBAL	<MICRO>								;027
.ENDC

	MOV	#4,QUESNM	;[1,2]=4th question to GETCL		;031
	CALL	GETCL,R5	;GET LIB CLUSTER SIZE
	 GENTXT								;028
	  .ASCII "[1,2] cluster size <"					;028
112$:	  .ASCIZ "??????>? "						;002;028
	 UNORG								;028
	 .WORD	CL.1.2
	BCS	115$		;^Z -- ASK FIRST QUESTION		;027
	BPL	ASKBAS		;NOT ^, GO ON				;016
	TST	SYSFLG		;IS THIS A SYSTEM DISK?
	BNE	114$		;Yes, ask clustersize			;028
	JMP	80$		;NO-ASK TO CREATE [1,2]			;028
114$:	JMP	60$		;YES-ASK [1,1]CLUSTERSIZE

115$:	JMP	ASKTYP		;TO FIRST QUESTION			;027

ASKBAS:
120$:	MOV	D.PREF,R1	;Default preference is next to SATT	;005
	MOV	R1,D$PREF	;Set that default			;005
	TST	PP.1.1		;ARE WE CREATING 1,1
	BNE	125$ 		;YEP
	TST	PP.1.2		;HOW ABOUT 1,2
	BEQ	ASKDLW		;NO-LET'S NO ASK FOR THE BASE
125$:	MUL	CLURAT,R1	;Multiply by cluster ratio		;005
	INC	R1		; and increment to get DCN		;005
	MOV	R1,R0		;Copy that				;005
	MOV	#140$,R1	;Point to where to store string		;005
	CALLX	DECSTR		;Convert (R0) to decimal string		;005

.IF	NDF	ONLINE							;027
	CMP	MICRO,#-1	;Micro & Installation?			;027
	BEQ	ASKDLW		;Yes, use default			;027

GLOBAL	<MICRO>								;027
.ENDC

	CALLX	ASKER,R5	;ASK WHERE TO PUT [1,1] and [1,2]
	 .WORD	130$
	 GENTXT
	  .ASCII "Type a block number to locate the [1,1] and [1,2] directories"<200> ;002
	  .ASCII "at a specific place on the disk, or type <CR> to let RSTS find"<200> ;002
	  .ASCII "a location."<200>					;002
130$:	  .ASCII "[1,1] and [1,2] account base <"			;005
140$:	  .ASCIZ "??????>? "						;005
	 UNORG
	BCS	150$		;^Z -- ASK FIRST QUESTION		;016
	BMI	145$		;^  -- ASK PREVIOUS QUESTION		;016
	BEQ	ASKDLW		;<LF>, use the preset default		;005
	CALL	GETPOS,R5,D$PREF ;Store position			;004
	BCS	120$		;Ask again if we don't like the answer	;004
	BR	ASKDLW							;004
145$:	TST	SYSFLG		;IS THIS A SYSTEM DISK?
	BNE	110$		;YES-ASK [1,2]CLUSTER
	JMP	80$		;NO-ASK TO CREATE [1,2]

150$:	JMP	ASKTYP		;TO FIRST QUESTION			;016

.DSABL	LSB

GLOBAL	<I.DATE,I.TIME,PCS>						;005

; ASK FOR DATE OF LAST WRITE/DATE OF LAST ACCESS

.ENABL	LSB								;027

ASKDLW:	BIC	#UC.DLW,PACKST	;ASSUME NOT DATE-LAST-WRITE

.IF	NDF	ONLINE							;027
	CMP	MICRO,#-1	;Micro & Installation?			;027
	BEQ	10$		;Yes, use date-last-write		;027

GLOBAL	<MICRO>								;027
.ENDC									;027

	CALL	YESNO,R5				
	 GENTXT	<"Date last modified <YES>? ">
	 GENTXT
	  .ASCII "Type 'YES' to maintain date of last modification in the"<200>
	  .ASCII "directory on this disk."<200>
	  .ASCII "Type 'NO' to maintain the date of last access."<200>
	  .ASCIZ "Should this disk retain last-modified information? "
	 UNORG
	 BR	20$		;^  -- ASK PREVIOUS QUESTION		;016
	 BR	10$		;LF -- TURN ON THE BIT
	 BR	ASKTOP		;NO -- DON'T SET THE BIT
	 BR	10$		;YES -- TURN ON THE BIT			;016
	 JMP	ASKTYP		;^Z   -- ASK FIRST QUESTION		;016

10$:	BIS	#UC.DLW,PACKST	;TURN ON THE BIT			;016
	BR	ASKTOP							;002

20$:	TST	PP.1.2		;ARE WE CREATING [1,2]?
	BNE	25$		;YEP
	TST	PP.1.1		;HOW ABOUT [1,1]?
	BNE	25$		;YEP
	JMP	ASK12		;NO-ASK TO CREATE [1,2]

25$:	JMP	ASKBAS		;ASK FOR [1,1], [1,2]BASE
	
; ASK IF NEW FILES SHOULD BE LINKED TO TOP

ASKTOP:	BIC	#UC.TOP,PACKST	;ASSUME NOT

.IF	NDF	ONLINE							;027
	CMP	MICRO,#-1	;Micro & Installation?			;027
	BEQ	ASKRO		;Yes, use default			;027

GLOBAL	<MICRO>								;027
.ENDC									;027

	CALL	YESNO,R5	;ASK THE QUESTION
	 GENTXT	<"New files first <NO>? ">
	 GENTXT
	 .ASCII	"Type 'YES' to force new directory entries to be"<200>
	 .ASCII	"added to the front of the directory."<200>
	 .ASCII	"Type 'NO' to force new entries to be added to"<200>
	 .ASCII	"the end."<200>
	 .ASCIZ	"Should directory entries be added to the front? "
	 UNORG
	 BR	ASKDLW		;^  -- ASK PREVIOUS QUESTION		;016
	 NOP			;LF = NO
	 BR	ASKRO		;NO -- DON'T SET THE BIT
	 BR	40$		;YES -- TURN ON THE BIT			;027
	 JMP	ASKTYP		;^Z   -- ASK FIRST QUESTION		;016

40$:	BIS	#UC.TOP,PACKST	;YES -- TURN ON THE BIT			;027

.DSABL	LSB								;027

;ASK IF THIS DISK SHOULD BE A READ-ONLY DISK
.ENABL	LSB

ASKRO:	BIC	#UC.RO,PACKST	;Assume not				;027

.IF	NDF	ONLINE							;027
	CMP	MICRO,#-1	;Micro & Installation?			;027
	BEQ	ASKBB		;Yes, use default			;027

GLOBAL	<MICRO>								;027
.ENDC

	CALL	YESNO,R5	;ASK
	.WORD	10$
	GENTXT
	 .ASCII	/Type YES to make this disk default to read-only when/<200>;002
	 .ASCII	/it is mounted.  Type no to make it read-write./<200>		;002
10$:	 .ASCIZ	/Read-only <NO>? /
	UNORG
	BR	ASKTOP		;^    -- ASK PREVIOUS QUESTION		;016
	BR	ASKBB		;<LF> -- ASK NEXT QUESTION
	BR	ASKBB		;NO   -- ASK NEXT QUESTION
	BR	11$		;YES  -- TURN ON BIT			;016
	JMP	ASKTYP		;^Z   -- ASK FIRST QUESTION		;016

11$:	BIS	#UC.RO,PACKST	;TURN ON BIT				;016

.DSABL	LSB

; ASK IF OLD BADB.SYS SHOULD BE USED

.ENABL	LSB

ASKBB:	TSTB	P.RSTS		;IS THIS A RSTS DISK
	BNE	ASKFMT		;NOPE, THEN THIS QUESTION IS USELESS
	CLR	USEBB		;ASSUME NOT

.IF	NDF	ONLINE							;027
	CMP	MICRO,#-1	;Micro & Installation?			;027
	BEQ	20$		;Yes, use prev. BADB			;027

GLOBAL	<MICRO>								;027
.ENDC									;027

	CALL	YESNO,R5	;ASK IF BADB.SYS SHOULD BE USED
	.WORD	10$
	 GENTXT
	 .ASCII	"If the disk you are initializing is already a RSTS"<200>
	 .ASCII	"file-structured disk, there is a file which tells where"<200>
	 .ASCII	"bad pack clusters are on the disk.  Type 'YES' to use"<200>
	 .ASCII	"this information in creating the new bad block file for"<200>
	 .ASCII	"this disk; type 'NO' to ignore the previous bad block"<200>
	 .ASCII	"file.  "
10$:	 .ASCIZ "Use previous bad block info <YES>? "
	 UNORG
	 BR	ASKRO		;^  -- ASK PREVIOUS QUESTION		;016
	 BR	20$		;LF = YES
	 BR	ASKFMT		;NO -- ON TO NEXT QUESTION
	 BR	20$		;YES					;016
	 JMP	ASKTYP		;^Z   -- ASK FIRST QUESTION		;016

20$:	COM	USEBB		;SET FLAG TO USE BADB.SYS		;016
.DSABL	LSB

; ASK FOR FORMAT IF APPLICABLE

ASKFMT:	MOV	#-1,D.ERRD	;SET FLAG SAYING ERROR RECORDS NOT READ
	CLR	D.FRMT		;ASSUME NO FORMATTING
.IF	NDF	ONLINE							;005
	CMP	MICRO,#-1	;Micro & Installation?			;027
	BEQ	ASKPAT		;Yes, don't format			;027
	BIT	#TY.FMT,TMPTYP(R5) ;CAN WE FORMAT THIS TYPE OF DISK ?
	BNE	5$		;Yes, so do it				;033
	TST	C.FRMT		;Can we controller format it?		;033
	BEQ	ASKPAT		;Can't even controller format it	;033
5$:	CALL	YESNO,R5	;ASK IF HE WANTS DISK FORMATTED		;016
	 GENTXT	<"Format <NO>? ">
	 GENTXT	<"Should the pack be formatted (Y or N)? ">
	 BR	ASKRO		;^  -- ASK PREVIOUS QUESTION		;016
	 NOP			;LF = NO
	 BR	ASKPAT		;NO -- DON'T FORMAT
	 BR	10$		;YES -- TURN FORMATTING FLAG ON		;027
	 JMP	ASKTYP		;^Z   -- ASK FIRST QUESTION		;016

10$:	COM	D.FRMT		;TURN FORMATTING FLAG ON		;027

GLOBAL	<MICRO>								;027
.ENDC									;005

; ASK FOR CHECK PATTERN COUNT

.ENABL	LSB

ASKPAT:

.IF	NDF	ONLINE							;027
	CMP	MICRO,#-1	;Micro & Installation?			;027
	BNE	2$		;No, ask question			;027
	MOV	#1,R0		;Yes, run 1 pattern			;027
PATTS == .-2			;For patching number of patterns	;027
	MOV	R0,WRONLY	;Set WRONLY=0 if write-check suppressed	;027
	BNE	1$		;We're doing real pattern checks	;027
	INC	R0		;Otherwise set up for one pattern	;027
1$:	MOV	#PATTBL,R3	;R3 --> Pattern table			;027
	MOV	R0,NSPATS	;Set number of system-defined patterns	;027
	CLR	NUPATS		;There are no user patterns		;027
	JMP	110$		;Join up				;027

GLOBAL	<MICRO>								;027
.ENDC

2$:	CALLX	ASKER,R5	;NOW ASK NUMBER OF PATTERNS		;027
	 GENTXT	<"Patterns <3>? ">
	 GENTXT
	 .ASCII	"Number of patterns to use in checking for bad blocks (0-3)." ;005
	 .ASCII	<200>"Time required per pattern (minutes):"<200>
	 .ASCII	"DK=1/platter, DM=2.5, DP, DB & DR=10."<200>
;
; WE KNOW WHAT KIND OF DISK THE USER HAS, SO WE SHOULD FIGURE IT OUT.
;
	 .ASCIZ	"How many patterns should be used in checking the disk? "
	 UNORG
	BCS	5$		;^Z -- ASK FIRST QUESTION		;016
	BPL	10$		;SKIP IF ANSWER WASN'T ^		;016
.IF	NDF	ONLINE							;005
	BIT	#TY.FMT,TMPTYP(R5) ;SHOULD ^Z GO TO "FORMAT" OR "DLW"?
	BNE	ASKFMT		;^Z -- ASK IF FORMATTING DESIRED	;005
.ENDC									;005
	TSTB	P.RSTS		;Did we ask about bad blocks?		;005
	BNE	ASKRO		;No, so ask about READ ONLY		;005
	BR	ASKBB		;Yes, so ask about bad blocks again	;005

5$:	JMP	ASKTYP		;TO FIRST QUESTION			;016

10$:	BNE	20$		;Not the default, decode the answer	;005
	MOV	#3,R0		;Set answer = 3 patterns		;005
	CLRB	(R1)+		; and no user patterns			;005
	MOV	#PATTBL,R3	;R3 --> PATTERN TABLE
	BR	30$		;Go store that				;005

20$:	MOV	#PATTBL,R3	;R3 -> PLACE FOR USER PATTERNS		;005
	CALLX	DECINP		;GET NUMBER OF PATTERNS
	BEQ	30$		;PROPER DECIMAL NUMBER
	CMPB	(R1)+,#'X	;DOES HE ALSO WANT USER PATTERNS?
	BNE	50$		;NO, IT'S AN ERROR			;005
	TSTB	(R1)		;YES, BUT IS X ALL THERE IS?
	BNE	50$		;NO, INVALID RESPONSE
	TST	R0		;CANNOT HAVE USER PATS & NO SYS PAT
	BEQ	50$		;NO PATTERNS IS INVALID
30$:	CMP	R0,#3		;MORE THAN 3 PATTERNS?
	BHI	50$		;YUP, THAT'S A NO NO
	MOV	R0,WRONLY	;Set WRONLY=0 if write-check suppressed	;005
	BNE	40$		;We're doing real pattern checks	;005
	INC	R0		;Otherwise set up for one pattern	;005
40$:	MOV	R0,NSPATS	;Set number of system-defined patterns	;005
	CLR	NUPATS		;THERE ARE NO USER PATTERNS YET
	CMPB	-(R1),#'X	;NOW, ARE THERE USER PATTERNS?
	BNE	110$		;NO
	BR	80$		;User patterns are legal		;005

50$:	MESSAGE	<"?Illegal number of patterns"<200>>			;005
	BR	ASKPAT		;Ask again				;005

; IF USER PATTERNS ARE REQUESTED, GET UP TO 8 OF THEM

80$:	CALLX	ASKER,R5	;ASK FOR A USER PATTERN
	 GENTXT	<"Your pattern: ">
	 GENTXT	<"Enter your pattern as an octal word, or type line feed if no more: ">
	BCS	5$		;^Z -- ASK FIRST QUESTION		;016
	BMI	ASKPAT		;^ -- ASK PREVIOUS QUESTION		;016
	BEQ	110$		;LINE FEED -- NO MORE PATTERNS
	CALLX	OCTINP		;GET HIS OCTAL NUMBER
	BNE	90$		;A BAD NUMBER
	TST	R0		;WAS IT 0?
	BNE	100$		;NO, IT'S A VALID USER PATTERN
90$:	MESSAG	<"?Illegal number, try again"<200>>			;005
	TSTABT								;005
	BR	80$

100$:	INC	NUPATS		;ONE MORE USER PATTERN
	MOV	R0,-(R3)	;SET UP A USER PATTERN
	MOV	#PATTBL,D.PNDX	;SET UP THE USER PATTERN INDEX
	CMP	R3,#PATUSR+2	;DO WE HAVE ENOUGH?
	BHI	80$		;NO, HE MAY WANT MORE
110$:	CLR	-(R3)		;LAST PATTERN IS 0 AS A FLAG

; ASK FOR PROCEED

120$:									;005
.IF	DF	ONLINE							;005
DCLFIN:	TST	DCLENT		;DCL entry?				;005
	BEQ	130$		;No, so ask LAST TWO QUESTIONS		;005
125$:	TST	P.RSTS		;IS THIS A RSTS DISK?
	BNE	140$		;NO-DON'T ASK TO PROCEED
	TST	DCLQUE		;/Query specified?			;005
	BEQ	140$		;No, so go for it immediately		;005
	BR	135$		;ASK TO PROCEED
	
GLOBAL	<DCLQUE,DCLPAT>							;005

.IFF
	CMP	MICRO,#-1	;Micro & Installation?			;027
	BNE	130$		;No, continue				;027
	CLR	SECRTY		;Assume we erase			;027
	TST	WRONLY		;Running patterns?			;027
	BNE	129$		;Yes, so OK				;027
	MOV	#-1,SECRTY	;No, so don't erase either		;027
129$:	TSTB	P.RSTS		;RSTS disk?				;027
	BNE	139$		;No, make it one			;027
	BR	136$		;Yes, ask first				;027

GLOBAL	<MICRO>								;027

.ENDC									;005

130$:	CLR	SECRTY		;ASSUME WE ERASE			
	TST	WRONLY		;DID WE SAY TO PATTERN CHECK?
	BNE	135$		;YEP, SKIP QUESTION
	CALL	YESNO,R5						;016
	 GENTXT	<"Erase Disk <YES>? ">
	 GENTXT 
	 .ASCII "If you wish to have the disk erased for security, type 'Y'."
	 .ASCII <200>"If you only want to write"
	 .ASCIZ " the RSTS structure, type 'N'."<200>
	 UNORG
	 BR	ASKPAT		;^--ASK PREVIOUS QUESTION		;016
	 BR	135$		;<LF>--YES
	 BR	131$		;NO - DON'T ERASE			;016
	 BR	135$		;YES					;016
	 JMP	ASKTYP		;^Z   -- ASK FIRST QUESTION		;016

131$:	MOV	#-1,SECRTY	;DON'T ERASE				;016

135$:	CALL	YESNO,R5						;016
	 GENTXT	<"Proceed (Y or N)? ">
	 GENTXT	<"Type 'Y' to proceed with DSKINT, 'N' to abort it? ">
	 BR	180$		;^  -- ASK PREVIOUS QUESTION		;016
	 BR	135$		;LF -- ask again			;005
	 BR	170$		;NO -- GO BACK TO 'OPTION?'
	 BR 	140$		;YES -- DO THE DSKINT			;016
	 JMP	ASKTYP		;^Z   -- ASK FIRST QUESTION		;016

.IF	NDF	ONLINE							;027
136$:	CALL	YESNO,R5						;027
	 .WORD	1361$							;027
	  GENTXT							;027
1361$:	   .ASCII <200>"Type: YES to initialize this disk; all data on it will be erased"<200> ;027
	   .ASCII "      NO to skip the initialization"<200> ;027
	   .ASCII "      ^ to return to the previous question"<200>	;027
	   .ASCIZ <200>"Do you want to initialize this disk? "		;027
	  UNORG								;027
	 BR	137$		;^  -- ask unit question		;027
	 BR	136$		;LF -- ask again			;027
	 BR	138$		;NO -- proceed				;027
	 BR 	139$		;YES -- do the dskint			;027
137$:	 JMP	DIALOG		;^Z   -- ask unit question		;027

138$:	TST	(SP)+		;Continue with COPY (pop DIALOGUE call, ;027
	RETURN			;  return to DSKIN2 caller)		;027
	
139$:	MOV	R0,-(SP)	;Save R0 				;027
	MESSAGE	<<200>"Initializing disk _DU">				;027
	MOVB	SYSUNT,R0	;Get unit number			;027
	CALLX	DECZER		; and print it				;027
	MESSAGE	<":, please wait..."<200>>				;027
	MOV	(SP)+,R0	;Restore R0				;027

GLOBAL	<SYSUNT,D.SIZL,D.SIZM>						;027
.ENDC									;027

	;Initialize the disk						;027
140$:				;  THE DSKINT				;016
.IF	NDF	ONLINE							;036
	;Note: If we reformat the disk the size may change therefore at	;036
	;this point the SATBUF will by zeroed and not yet sized, the	;036
	;sizing shall be done in the format pass (whether or not we	;036
	;actually format disk).						;036
	CALLX	ZERSAT		;GET A CLEAN SAT IN MEMORY		;036
.IFF									;036
	;Note: if ONLINE then there will be no formatting at all so	;036
	;we can and must size the disk now.				;036
	CALLX	CLNSAT		;get a clean,sized satbuf in memory	;036
.ENDC		;online							;036

	CALLX	SAVSAT		;MOVE THE REAL SAT INTO AUXILIARY BUFFER
150$:	CALL	DRESET		;RESET THE DISK
	BCC	160$		;GOT IT, GO DO IT
155$:	CALLX	ASKER,R5,<MNORDY,QRETRY> ;NOT READY, ASK IF RETRY	;016
	BCS	157$		;^Z NOT PERMITTED			;016
	BMI	157$		;^ NOT PERMITTED			;016
	CMPB	(R1),#12	;TYPED LF?
	BEQ	150$		;YUP
	JMP	FMTABT		;NO, ABORT THE DSKINT

157$:	MESSAGE	<"No backing up is permitted."<200>>			;016
	BR	155$		;RE-ASK					;016

160$:	RETURN			;END OF DIALOGUE

170$:
.IF	DF	ONLINE							;020
	MOV	#EX$WAR,STATUS	;Indicate warning			;020
GLOBAL	<EX$WAR,STATUS>						;036
.ENDC									;020
	EXIT			;END OF DSKINT

180$:	TST	WRONLY		;SO WOULD ASK ERASE OR PATTERNS?
	BEQ	130$		;ERASE
	JMP	ASKPAT		;PATTERNS				;016
.DSABL	LSB

.ENABL	LSB

GETR50:	MOV	(R5)+,20$	;STORE MESSAGE ADDRESS			;002
10$:	CALLX	ASKER,R5	;ASK FOR PACK ID			;002
20$:	 .WORD	0		;"XX PASSWORD"
	 GENTXT	<"Up to 6 alphanumeric characters? ">
	BCS	30$		;RETURN IF ^Z
	BMI	31$		;RETURN IF ^				;016
	CALLX	RADINP		;GET PACK ID				;002
	TSTB	(R1)		;GOOD RAD50 THING ?
	BNE	40$		;NOPE, ASK AGAIN			;005
	MOV	(R5)+,R1	;PICKUP ADDRESS TO STORE INTO
	MOV	R0,(R1)+	;STORE FIRST RAD50 WORD
	MOV	R3,(R1)+	;AND SECOND
	+	CLC!CLN		;CLEAR C AND N BITS			;016
	RETURN	R5		;RETURN

30$:	INC	R5		;SKIP OVER THE PARAMETER
	INC	R5
	RETURN	R5		;AND RETURN WITH CARRY SET

31$:	TST	(R5)+		;SKIP PARAMETER				;016
	SEN			;RETURN WITH N-BIT SET			;016
	RETURN	R5		;  AND CARRY CLEAR (FROM TST)		;016

40$:	MESSAGE	<"?Illegal Pack ID"<200>>				;005
	TSTABT								;005
	BR	10$		;Ask again				;005

.ENABL	LSB								;005
;+	
;	GETCL - Get a clustersize routine
;
;	Inputs: R5 ---> (Message to display GENTXT)
;			(Default Clustersize)
;
;	Output: (Default clustersize) set to user (or default) entry
;-
GETCL:	MOV	(R5)+,40$	;STORE MESSAGE ADDRESS
	MOV	(R5),R4		;get address of default clustersize	;031
.IF	DF	ONLINE							;005
	TST	DCLENT		;DCL entry?				;005
	BEQ	10$		;No, ask the question			;005
	TSTB	(R1)		;Was there a non-default value?		;005
	BNE	60$		;Yes, go process it			;005
	BR	80$		;No, take the default			;005
.ENDC									;005
10$:	MOV	PACKCL,R1	;GET PACK CLUSTER SIZE			;005
	MOV	#105$,R0	;SET PTR TO 'Type 16' only message	;031
	MOV	(R0),50$	;set it as the msg			;031
	CMP 	QUESNM,#1	;are we doing pack clustersize quest?	;031
	BNE	13$		;no, so use small table			;031
12$:	MOV	#100$,R0	;Yes, so setup large disk (PCS) table	;031
	BR	20$		;and continue				;031
13$:	TST	LRGDSK		;are we on a large disk?		;031
	BEQ	15$		;no, so always small disk msgs		;031
	CMP	(R4),PACKCL	;Are we  doing < PCS as default?	;031
	BLOS	30$		;yes, so use 'Type 16' message		;031
15$:	MOV	#110$,R0	;Set ptr to small disk messages		;028
20$:	MOV	(R0)+,50$	;ASSUME THIS IS THE MESSAGE
	ASR	R1		;SHIFT PCS OUT TO GET MINIMUM CLUSTER
	BCC	20$		;HANG IN THERE
30$:	CALLX	ASKER,R5	;NOW ASK HIM FOR CLUSTER SIZE
40$:	 .WORD	0		;"XX CLUSTER SIZE"
50$:	 .WORD	0		;LONG FORM AS COMPUTED
	BCS	70$		;RETURN IF ^Z
	BMI	71$		;RETURN IF ^				;016
	BEQ	80$		;Line feed -- don't change preset default ;005
60$:	CALLX	DECINP		;PICKUP CLUSTER SIZE IN DECIMAL
	BNE	90$		;Invalid, issue message			;005
	MOV	R0,R1		;COPY CLUSTER SIZE

	CMP	R1,#64.		;cluster size > 64 ?			;031
	BHI	90$		;TIS A SHAME				;005

62$:	DEC	R1		;NOW SEE IF IT'S A POWER OF 2		;031
	BIT	R0,R1		; BY CHECKING N AGAINST N-1
	BNE	90$		;NO BITS SHOULD MATCH, ELSE ERROR	;005

	CMP	QUESNM,#1.	;Are we doing Packclustersize question?	;031
	BEQ	65$		;Yes, so just check against Minimum	;031
	CMP	R0,#8.		;User Entered small or large number?	;031
	BLOS	65$		;Small, so do small checks against PCS	;031
	CMP	R0,#16.		;what else				;031
	BHI	90$		;print an error msg			;031

	TST	LRGDSK		;using large disk?			;031
	BEQ	65$		;no, so do std check			;031
;Large disk with a clustersize 16 specified, so always ok		;031
	BR	68$							;031

65$:	CMP	R0,PACKCL	;DCS<=PCS, PCS<=MCS, PCS<=LCS
	BLO	90$		;ASK AGAIN ON BAD CLUSTER SIZE		;005
68$:	+	CLC!CLN		;CLEAR C AND N BITS			;016
70$:	MOV	R0,@(R5)+	;STORE CLUSTER SIZE
	RETURN	R5		;RETURN

71$:	MOV	R0,@(R5)+	;STORE CLUSTER				;016
	SEN			; AND RETURN WITH N-BIT SET		;016
	RETURN	R5							;016

80$:	TST	(R5)+		;Skip argument				;005
	CLN			;CLEAR N AND C (FROM TST) BIT		;016
	RETURN	R5		;Back to caller				;005

90$:	MESSAGE	<"?Illegal clustersize specified"<200>>			;005
	TSTABT								;005
	BR	30$		;Ask again				;005

;Large disk table							;028
100$:	GENTXT	<"1, ">,,X	;These (thru 16) are used only by	;028
	GENTXT	<"2, ">,,X	;Pack clustersize prompt		;028
	GENTXT	<"4, ">,,X						;028
	GENTXT	<"8, ">,,X						;028
	GENTXT	<"16, ">,,X						;028
	GENTXT	<"32, 64? ">						;028
	GENTXT	<"Type 64? ">						;028

;Small disk table							;028
;
110$:	GENTXT	<"1, ">,,X
	GENTXT	<"2, ">,,X
	GENTXT	<"4, 8 or 16? ">					;028
	GENTXT	<"8 or 16? ">						;028
105$:	GENTXT	<"Type 16? ">	;this line used for large disks too	;031

.DSABL	LSB								;005

GETPOS:	CALLX	DECINP		;Convert string to decimal number	;004
	BNE	20$		;Invalid, exit failing			;004
	TST	R0		;Valid?					;004
	BEQ	10$		;Yes					;004
	INC	R0		;No, but make it so			;004
10$:	MOV	R0,R2		;Copy DCN				;004
	CALLX	RIB2CN		;Convert to PCN				;004
	TST	FLOPPY		;Floppy sized disk?			;035
	BNE	15$		;Yes, so skip position checks, load it	;035
	CMP	SATSYS+BITS,R3	;Legal PCN?				;004
	BLOS	20$		;No, quit				;004
15$:	MOV	R3,@(R5)+	;Store it				;004
	;CLC			;C=0 from CMP or TST above		;035
	RETURN	R5		; and exit				;004

20$:	TST	(R5)+		;Skip the argument			;004
	SEC			;Indicate error				;004
	RETURN	R5		;Quit					;004

.ENABL	LSB

ISRSTS:	MOVB	#-1,P.RSTS	;ASSUME THIS IS NOT A RSTS/E DISK
	CALL	DRESET		;RESET THE DISK
	CLR	FIBPHS		;INDICATE MFD IN FIBUF
	MOVB	#-1,BACKUP	;SET BACKUP FLAG TO SUPPRESS ERROR MESSAGES
	CALLX	READPL		;Read the pack label			;002
	CLRB	BACKUP		;TURN ON ERROR LOGGING
	TSTB	IOERR		;WAS THERE AN ERROR?
	BNE	70$		;YES, THEN IT IS NOT RSTS
	MOV	#FIBUF,R1	;R1 -> MFD LABEL
	TST	(R1)+		;Skip it				;002
	CMP	(R1)+,#-1	;NEXT ENTRY SHOULD BE 177777
	BNE	70$		;NOPE, NOT A RSTS DISK
	MOV	(R1)+,R0	;Get starting DCN field			;002
	MOVB	(R1)+,LEVEL1	;GET LEVEL FIRST PART
	MOVB	(R1)+,LEVEL2	;GET LEVEL SECOND PART
	BEQ	10$		;Old pack, check that out		;002
	BIT	#UC.NEW,FIBUF+PSTAT ;New pack bit set?			;002
	BEQ	70$		;No, that's a bad pack then		;002
	CMPB	FIBUF+PLVL+1,#1	;Level 1 pack?				;002
	BNE	70$		;If not we don't know it
	BR	20$		;Continue				;002

10$:	BIT	#UC.NEW,FIBUF+PSTAT ;New pack bit set?			;002
	BNE	70$		;Yes, but it shouldn't be!		;002
20$:	MOV	(R1),R0		;R0 = PCS				;002
	MOV	R0,PACKCL	;Store it for later check		;028
	CMP	R0,DCS		;IS IT SMALLER THAT DCS?
	BLO	70$		;YUP, NOT RSTS
	CMP	R0,#64.		;IS IT TOO BIG FOR A PCS?		;028
	BHI	70$		;YUP, NOT RSTS
22$:	DEC	R0		;MAKE A MASK FOR TESTING IF PCS IS POWER OF 2
	BIT	R0,(R1)+	;IS IT A POWER OF 2?
	BNE	70$		;NOPE, NOT RSTS
	BIT	#^C<UC.MNT!UC.PRI!UC.DLW!UC.TOP!UC.NEW!UC.RO>,(R1)+ ;REMOVE STATUS BITS ;002
	BNE	70$		;IF NOT ALL GONE, THEN NOT RSTS

GLOBAL	<IOERR,FIBUF,BACKUP>

	MESSAGE
	 .ASCII	<200>"This disk pack appears to be a RSTS/E formatted"<200>
	 .ASCII	/disk with the following characteristics:/<200><200>
	 .ASCIZ /Pack ID :/<11><11>
	UNORG
	MOV	(R1)+,R0	;GET FIRST HALF OF PACK ID
	CALLX	RADZER		;PRINT IT
	MOV	(R1),R0		;GET SECOND HALF OF PACK ID
	CALLX	RADZER		;PRINT IT
	MESSAGE	<<200>"Pack Cluster Size :"<11>>
	SUB	#6,R1		;R1 -> PCS
	MOV	(R1)+,R0	;R0 = PCS FOR PRINTING
	CALLX	DECZER		;PRINT OUT THE PCS
	MESSAGE	<<200>"Pack is currently :"<11>>
	BIT	(R1),#UC.PRI	;IS IT PRIVATE?
	BEQ	30$		;NOPE, A PUBLIC DISK
	MESSAGE	<"Private">
	BR	40$		;CHECK ON ACCESS DATE UPDATED
30$:	MESSAGE	<"Public">
40$:	BIT	(R1),#UC.DLW	;IS IT DATE OF LAST WRITE
	BEQ	50$		;NOPE, DATE OF LAST READ
	MESSAGE	<","<200><11><11><11>"Update access date on writes">
50$:	BIT	(R1),#UC.TOP	;IS IT NFF?
	BEQ	55$		;NOPE, NEW FILES LAST
	MESSAGE	<","<200><11><11><11>"Link new files first">
55$:	BIT	(R1),#UC.RO	;IS IT READ-ONLY?
	BEQ	60$		;NO
	MESSAGE	<","<200><11><11><11>"Read-only">
60$:	MESSAGE	<","<200><11><11><11>"Level: ">
	CLR	R0		;CLEAR R0
	MOVB	LEVEL2,R0	;GET FIRST PART OF LEVEL NUMBER
	CALLX	DECZER		;PRINT IT
	MESSAGE <".">		;STICK THE PERIOD IN
	MOVB	LEVEL1,R0	;GET THE SECOND PART OF LEVEL NUMBER
	CALLX	DECZER		;PRINT IT
	MESSAGE	<<200><200>>
	CLRB	P.RSTS		;THIS IS A RSTS DISK
70$:	RETURN			;GO ASK DIALOG QUESTIONS

.DSABL	LSB

.SBTTL	FORMAT PASS DRIVER

.ENABL	LSB

FORMAT:	CLR	D.HDR		;HEADER NOT PRINTED YET
	CLR	D.BCNT		;NO BAD BLOCKS DETECTED YET
10$:	CALL	READBB,R5	;READ PREVIOUS BADB.SYS IF REQUIRED
	 BR	60$		;COMPLAIN IF DRIVE NOT READY
	TST	D.ERRD		;ARE THE ERROR RECORDS IN?
	BEQ	20$		;YES, NO NEED TO READ THEM AGAIN
	MOV	SYSNDX,R1	;R1 = DISK TYPE
	CALL	@90$(R1),R5	;GO READ IN ERROR TRACK (IF ANY)
	 BR	60$		;ERROR READING ERRORS (OR NOT READY)

20$:									;005
.IF	NDF	ONLINE							;005
	TST	D.FRMT		;FORMAT SWITCH 0N ?
	BEQ	45$		;NOPE, EXIT QUICKLY			;036
				;exit must include satbuf sizing	;036
	MOV	#-1,CC.DBL	;HANDLE ^C'S INTERNALLY
	MESSAG	<"Starting format pass"<200>>
	MOV	SYSUNT,R0	;R0 = UNIT NUMBER
	MOV	SYSNDX,R1	;R1 = DISK TYPE
	CMP	R1,#IDX$DB	;DB and DR require an extra check	;002
	BEQ	25$		;It's DB, so do it			;002
	CMP	R1,#IDX$DR	;SEE IF THIS IS A DR TYPE DISK
	BNE	40$		;IF NOT THEN DON'T MAKE THE RP07/RM80 CHECK
25$:	MOV	R0,R3		;MAKE A COPY OF THE UNIT NUMBER		;002
	ASL	R3		;TIMES 2
	ADD	DSKMID(R1),R3	;R3 -> MASS BUS ID
	MOV	(R3),R3		;R3 = MASS BUS ID
	BIC	#004000,R3	;REMOVE DUAL PORT BIT IF PRESENT
	SUB	#020020,R3	;MAKE R3 AND INDEX

; CHECK FOR UNFORMATTABLE DISK TYPES, JUST IN CASE...

	CMPB	R3,#<RP07ID-20>	;SEE IF DEVICE IS AN RP07
	BNE	30$		;NOPE, SOMETHING ELSE, SO WE'RE O.K. (MAYBE)
	MESSAG	<"INIT bug - Don't know how to format RP07"<200>>
	BR	DLFMT		;DRATS, WE DON'T KNOW HOW TO FORMAT AN RP07
30$:	CMPB	R3,#<RM80ID-20>	;SEE IF DEVICE IS AN RM80
	BNE	40$		;NOPE, SOMETHING ELSE, SO WE'RE O.K. (MAYBE)
	MESSAG	<"INIT bug - Don't know how to format RM80"<200>>
	BR	DLFMT		;DRATS, WE DON'T KNOW HOW TO FORMAT AN RM80
40$:	CALL	@100$(R1),R5	;ON TO FORMATTER FOR THIS DISK TYPE
	 BR	60$		;C=0 IF ERROR OR TIMEOUT, C=1 IF NOT READY
	MESSAG	<"End format pass"<200>> ;success return		;036

	;After a disk is formatted with a controller format command, it is ;035
	;possible that its size has changed, therefore, we reset the drive
	;causing an IFUN driver function to occur, then create a clean SATT
	;again for the (possibly) new size, but include bad blk allocates  ;036

45$:	CALL	DRESET		;Reset the drive to get possible new sizes ;036
	CALLX	SETSAT		;Setup SATT sizes in case CTLFMT chged size ;034
	CALLX	RESSAT		;get the satbuf back			;036
	CALLX	ENDSAT		;properly define disk end in SATBUF	;036
	CALLX	SAVSAT		;MOVE THE REAL SAT INTO AUXILIARY BUFFER ;034
.ENDC									;005

50$:	CLR	CC.DBL		;<LF> - ENABLE NORMAL ^C HANDLING
	RETURN			;BACK TO DSKINT DRIVER

GLOBAL	<REGRES,CC.DBL,SYSUNT,SYSNDX>

60$:									;005
.IF	DF	ONLINE							;005
	ROR	-(SP)		;Save carry				;005
	TST	DCLENT		;Entry from DCL?			;005
	ROL	(SP)+		;Restore carry				;005
	BEQ	68$		;Not DCL, issue normal message		;005
	MOV	(PC)+,R0	;Assume error track problem		;005
	 GENTXT	<"?Unable to read bad block track data"<200>>		;005
	BCC	64$		;Right					;005
	MOV	(PC)+,R0	;Otherwise change text			;005
	 GENTXT	<"?Drive not ready"<200>>				;005
64$:	CALLX	ASCIZ0		;Print it				;005
	TSTABT			;Quit					;005
									;005
68$:									;005
.ENDC									;005
	MOV	(PC)+,R1	;ERROR, GET FAILURE TEXT POINTER
	 GENTXT	<"Formatting failure: ">
	BCC	70$		;IF THAT'S THE ERROR, USE THE TEXT
	MOV	(PC)+,R1	;ELSE SAY DRIVE IS NOT READY
	 GENTXT	<"Drive not ready: ">,MNORDY
70$:	MOV	R1,80$		;SET TEXT
	CALLX	ASKER,R5	;TELL HIM HE HAD AN ERROR
80$:	 .WORD	0		;FILLED IN WITH THE ERROR
	 GENTXT
QRETRY:	 .ASCIZ	"Type <CR> to retry, CONTROL/C to abort DSKINT: "
	 UNORG
	CMPB	(R1),#12	;<LF> REQUIRED FOR RETRY
	BEQ	10$		;OK, RETRY IT
FMTABT:	MESSAG	<"?DSKINT aborted"<200>>				;005
	CLR	CC.DBL		;ENABLE NORMAL ^C HANDLING
	EXIT

90$:	$DISKS
	.WORD	ERR'NAME
.ENDM

.IF	NDF	ONLINE							;005
100$:	$DISKS
	 .WORD	NAME'FMT		;NAME FORMATTER
.ENDM

.DSABL	LSB

;We will only get here if the disk is controller formattable as the FORMAT ;033
;question will only be asked in that case

DVFMT:
DFFMT:
DSFMT:
DLFMT:
DWFMT:									;030
DZFMT:
DVFMT:									;030
DUFMT:	CALL	CTLFMT			;Format using controller format	;033
	BCC	10$			;No Error occurred, so pop ptr	;033
	CMPB	#HNGDEV,IOERR		;Dev Hung (Not ready?)		;033
	BEQ	12$			;Yes, so leave C bit on		;033
	BR	11$			;Else, carry off from CMPB, rtn	;033
10$:	TST	(R5)+			;Point to success return	;033
	CLR	CC.DBL			;Turn off ^C processing		;033
11$:	TST	(PC)+			;Skip the SET carry instruction	;033
12$:	SEC				;Set error carry bit		;033
15$:	RETURN	R5			;Back to caller			;033
.ENDC									;005

GLOBAL	<CC.DBL>

.SBTTL	READ PREVIOUS BADB.SYS FILE

.ENABL	LSB

READBB:	REGSAV			;SAVE REGISTERS
	TST	USEBB		;ARE WE SUPPOSED TO USE PREVIOUS BADB.SYS?
	BEQ	70$		;NO -- ALL DONE
	TSTB	P.RSTS		;Yes, but is this a RSTS pack?		;005
	BNE	70$		;No, so don't try it			;005
	CALL	DRESET		;RESET CONTROLLER & DRIVE
	BCS	90$		;IF THAT FAILED, PRINT MESSAGE & RETRY
	CALLX	WRITEC		;FORCE OUT CURRENT BUFFER IF NEEDED
	CLR	FIBPHS		;MAKE SURE TO FORCE A READ
	CALLX	READPL		;Read the pack label			;002
	MOV	FIBUF+PPCS,R3	;Get old pack clustersize		;002
	CLR	R2		;MSB = 0
	DIV	PCS,R2		;HOW MANY NEW CLUSTERS IN 1 OLD CLUSTER?
	BNE	10$		;QUOTIENT >= 1, THAT'S FINE
	INC	R2		;QUOTIENT < 1, USE 1
10$:	MOV	R2,XPAND	;SAVE EXPANSION FACTOR FOR LATER USE
	MOV	SYSNDX,-(SP)	;SAVE SYSTEM INDEX AND NAME
	MOV	SYNXSV,-(SP)	;  JUST INCASE WE GET AN ERROR
	MOV	SYSNAM,-(SP)	;    LOOKING FOR BADB.SYS
	CALLX	LKBADB		;LOOKUP BADB.SYS
	 BCS	80$		;BAD DISK IF IT'S NOT THERE
	CMP	(SP)+,(SP)+	;POP SYSTEM DISK PARMAMETERS
	TST	(SP)+		;  THAT WERE SAVED B4 THE LOOKUP.
	MOV	#FCBADB,R1	;POINT TO FCB FOR BADB.SYS
	CALLX	RNB		;READ NAME BLOCK
	MOV	UAR(R5),R3	;GET RETRIEVAL ENTRY LINK
	BIC	#^C<UL.BLO!UL.CLO!UL.ENO>,R3				;027
	BEQ	70$		;EMPTY BADB.SYS -- ALL DONE
	MESSAGE
	 .ASCII	<200>"Current BADB.SYS"<200>				;027
	 .ASCII "   DCN       PCN"<200>					;027
	 .ASCIZ "----------------"<200>					;027
	UNORG
20$:	CALLX	RDB		;POINT TO RETRIEVAL POINTERS
	MOV	(R5)+,-(SP)	;SAVE LINK TO NEXT RE
30$:	MOV	(R5)+,R2	;GET A RETRIEVAL POINTER
	BEQ	60$		;END OF LIST -- ALL DONE
	MOV	R0,-(SP)	;Save R0 for a bit			;005
	MOV	R2,R0		;Copy the DCN				;005
	CALLX	DECPRT		;Print the DCN				;005
	MESSAGE	<"    ">	;Space out				;005
	CALLX	RIB2CN		;COMPUTE PACK CLUSTER USING NEW PCS
	MOV	R3,R0		;Copy the PCN				;005
	CALLX	DECPRT		;Print that				;005
	CALLX	TYPECR		;Do a CRLF				;005
	MOV	(SP)+,R0	;Restore R0				;005
	MOV	XPAND,-(SP)	;SAVE REPEAT COUNT FOR EXPANDING
	MOV	R3,-(SP)	;SAVE CLUSTER NUMBER
40$:	MOV	(SP),R0		;GET CLUSTER NUMBER
	CALLX	FIXREG		;CONVERT TO BIT AND BYTE
	MOV	R4,-(SP)	;PUSH SATBUF OFFSET
	CALLX	GETSB2		;GET A BYTE FROM THE SAT
	MOV	(SP)+,R4	;POP THE BYTE
	BITB	R4,BITBYT(R2)	;ALREADY COUNTED AS BAD?
	BNE	50$		;YES -- DON'T COUNT IT AGAIN
	BISB	BITBYT(R2),R4	;NO -- MARK IT AS BAD
	MOV	R4,-(SP)	;PUSH NEW BYTE VALUE
	CALLX	PUTSB2		;REPLACE THE SAT BYTE
	INC	D.BCNT		;COUNT ANOTHER BAD CLUSTER
	CMP	D.BCNT,D.BMAX	;TOO MANY BAD CLUSTERS?
	BLE	50$		;NO -- SKIP
	JMP	EXCBAD		;YES -- HANDLE THE PROBLEM CRUDELY

50$:	INC	(SP)		;SET NEXT CLUSTER NUMBER TO ADD
	DEC	2(SP)		;DO WE NEED TO EXPAND ANOTHER?
	BNE	40$		;YES -- LOOP
	CMP	(SP)+,(SP)+	;POP REPEAT COUNT, CLUSTER NUMBER
	BIT	R5,#17		;AT END OF RETRIEVAL ENTRY?
	BNE	30$		;NO -- GET NEXT RP
60$:	MOV	(SP)+,R3	;RESTORE SAVED LINK TO NEXT RE
	BIC	#17,R3		;WITHOUT FLAGS
	BNE	20$		;IF THERE IS ONE, READ NEXT RETRIEVAL ENTRY
	CALLX	TYPECR		;Do another CRLF			;005
70$:	CALLX	REGRES,R5	;RESTORE REGISTERS
	TST	(R5)+		;TAKE SUCCESS RETURN
	RETURN	R5

80$:	MESSAGE
	 .ASCII	"Disk wasn't already a RSTS file-structured disk."<200>
	 .ASCIZ	"Previous bad block information will not be used."<200>
	UNORG
	MOV	(SP)+,SYSNAM	;LKBADB DESTROYS THE SYSTEM PARAMETERS
	MOV	(SP)+,SYNXSV	;  WHEN IT COULD NOT FIND BADB.SYS
	MOV	(SP)+,SYSNDX	;    SO WE MUST RESTORE THEM B4 WE RETURN.
	BR	70$		;RETURN SUCCESSFULLY

90$:	CALLX	REGRES,R5	;RESTORE REGISTERS
	RETURN	R5		;LET CALLER SAY 'NOT READY', RETRY.

.DSABL	LSB

GLOBAL	<FIBPHS,FCBADB,SYSNDX,SYNXSV,FIBUF,SYSNAM>

.SBTTL	YES/NO CHECKER

;+
; YESNO - CHECK REPLY FOR YES OR NO
;
;	R1 -> STRING TO CHECK
;
;	CALL	YESNO,R5,<PTR TO SHORT TEXT, PTR TO LONG TEXT>
;
;	 RETURN+0  - '^' FOUND						;016
;	 RETURN+2  - LF  FOUND
;	 RETURN+4  - 'N' FOUND
;	 RETURN+6  - 'Y' FOUND
;	 RETURN+10 - ^Z FOUND						;016
;-

.ENABL	LSB

YESNO:	MOV	(R5)+,20$	;GET TEXT POINTERS			;016
	MOV	(R5)+,30$
10$:	CALLX	ASKER,R5	;ASK THE QUESTION			;016
20$:	 .WORD	0
30$:	 .WORD	0
	BCS	60$		;^Z -- RETURN +10			;016
	BMI	50$		;^ -- RETURN +0				;016
	CALLX	ANSWER,R5	;CHECK THE ANSWER			;016
	 TST	(R5)+		;YES -- RETURN +6
	 TST	(R5)+		;NO -- RETURN +4
	 BR	40$		;LF -- RETURN +2
	 NOP			;OLD  ??
	MESSAGE	<"%Please answer 'YES' or 'NO'."<200>>
	BR	10$

40$:	TST	(R5)+
50$:	RETURN	R5

60$:	CMP	(R5)+,(R5)+	;RETURN +10				;016
	CMP	(R5)+,(R5)+	;					;016
	RETURN	R5							;016

.DSABL	LSB

.SBTTL	FIND RECORDED BAD BLOCKS - DL

ERRDL:	CALL	DRESET		;RESET CONTROLLER & DRIVE
	BCS	10$		;RETURN C=1 TO INDICATE DRIVE NOT READY
	MOV	D.SIZL,R2	;FIRST ERROR BLOCK = SIZE OF UNIT
	MOV	D.SIZM,R3
	MOV	#5,R0		;THERE ARE 5 MANUFACTURING ERROR RECORDS
	CALL	RDERR,R5	;READ THE ERROR RECORDS
	 BR	RDFAIL		;NO VALID ERROR RECORDS
	MOV	#2,R0		;2 TRACKS PER CYLINDER
	MOV	#40.,R1		;40 SECTORS PER TRACK
	MOV	#-1,R2		;EACH SECTOR IS 1/2 A LOGICAL BLOCK
	CALL	SETERR,R5	;SET UP BITS IN SAT FOR BAD BLOCKS
	 BR	STFAIL		;TOO MANY BAD BLOCKS
	TST	(R5)+		;TAKE SUCCESSFUL RETURN
10$:	RETURN	R5		;DONE


.SBTTL	FIND RECORDED BAD BLOCKS - DM

; READ THE BAD BLOCK LIST FROM THE LAST TRACK.
; ASSIGN THE BLOCKS TO BAD BLOCK FILE

ERRDM:	CALL	DRESET		;RESET THE CONTROLLER AND DRIVE
	BCC	10$		;OK
	RETURN	R5		;RETURN C=1 TO INDICATE DRIVE NOT READY

10$:	MOV	#3.*22.,D.CYLS	;SAVE NUMBER OF BLOCKS/CYLINDER FOR RK06/07
	MOV	D.SIZL,R2	;FIRST ERROR BLOCK EQUALS SIZE OF UNIT
	MOV	D.SIZM,R3
	MOV	#5,R0		;THERE ARE 5 MANUFACTURING ERROR RECORDS
	CALL	RDERR,R5	;READ THE ERROR RECORDS
	 BR	RDFAIL		;NO VALID ERROR RECORDS
	MOV	#3,R0		;3 TRACKS PER CYLINDER
	MOV	#22.,R1		;22 SECTORS PER TRACK
	CLR	R2		;EACH SECTOR IS A LOGICAL BLOCK
	CALL	SETERR,R5	;SET UP BITS IN SAT FOR BAD BLOCKS
	 BR	STFAIL		;TOO MANY BAD BLOCKS
	TST	(R5)+		;TAKE SUCCESSFUL RETURN
	RETURN	R5		;DONE

GLOBAL	<SYSPHU,DM$MID>

.SBTTL	FIND RECORDED BAD BLOCKS - DB/DR

.ENABL	LSB

ERRDR:
ERRDB:	MOV	SYSNDX,R0	;GET DISK TYPE
	MOVB	SYSPHU,R2	;GET 2* UNIT NUMBER

; SET UP DRIVE-SPECIFIC PARAMETERS FOR BAD BLOCK READER AND FORMATTER

	MOV	R2,R1		;COPY UNIT*2
	ADD	DSKMID(R0),R1	;R2 -> MASSBUS ID OF THIS UNIT
	MOV	(R1),R1		;LOAD MASSBUS ID
	BIC	#004000,R1	;IGNORE DUAL-PORT BIT
	SUB	#020020,R1	;GET IN RANGE
	CMP	R1,#30		;IS IT ONE WE KNOW ABOUT?
	BHIS	30$		;NO, COMPLAIN
	MUL	#6,R1		;SIX-BYTE ENTRIES
	ADD	#40$,R1		;AT THIS ADDRESS
	MOV	(R1)+,D.CYLS	;MAX CYLINDER NUMBER + BITS FOR FORMAT
	BEQ	30$		;ZERO INDICATES UNKNOWN DRIVE
	MOV	(R1)+,D.SECS	;MAX SECTOR (LOW BYTE), TRACK (HIGH BYTE)
	MOV	(R1)+,D.EXTR	;NUMBER OF EXTRA BYTES IN HEADER
	TST	D.CYLS		;DO DISK HEADERS HAVE BAD BLOCK FLAGS?
	BMI	10$		;YES, LET'S READ THE MFG. ERROR RECORDS
	MOV	#-1,SATBUF+10	;NO, MARK AS IF ALL BLOCKS WERE GOOD
	CLR	D.ERRD		;AND MARK AS IF WE READ THE DATA
	BR	20$		;SKIP READING ANY ERRORS

; ERROR RECORD ADDRESS = DISK SIZE

10$:	MOV	D.SIZL,R2	;LOW-ORDER SIZE
	MOV	D.SIZM,R3	;HIGH-ORDER SIZE

; PROCESS ERROR RECORDS

	MOV	#5,R0		;THERE ARE 5 MANUFACTURING ERROR RECORDS
	CALL	RDERR,R5	;READ MFG. ERROR RECORDS
	 BR	RDFAIL		;QUIT IF WE CAN'T SEE ANY
	MOVB	D.TRKS,R0	;R0 = MAX TRACK NUMBER
	INC	R0		;R0 = NUMBER OF TRACKS PER CYLINDER
	MOVB	D.SECS,R1	;R1 = MAX SECTOR NUMBER
	INC	R1		;R1 = NUMBER OF SECTORS PER TRACK
	CLR	R2		;EACH SECTOR IS ONE LOGICAL BLOCK
	CALL	SETERR,R5	;MARK BAD BLOCKS IN THE SAT
	 BR	STFAIL		;QUIT IF TOO MANY BAD BLOCKS
20$:	TST	(R5)+		;SKIP ERROR RETURN
	RETURN	R5		;RETURN SUCCESS

GLOBAL	<SYSNDX,SYSPHU,DSKMID,SATBUF,DSKSZL,DSKSZM>

30$:	MESSAGE <"?Unknown drive type"<200>>				;005
	;CLC
	RETURN	R5		;RETURN FAILURE

	TMPORG	DSIDAT

40$:	;PARAMETERS FOR VARIOUS DISKS

; 20 = RP04
	.WORD	410.!010000	;411 CYLINDERS, PDP-11 MODE
	.BYTE	21.,18.		;22 SECTORS/TRACK, 19 TRACKS/CYLINDER
	.WORD	4		;2 EXTRA WORDS IN HEADER

; 21 = RP05
	.WORD	410.!010000	;411 CYLINDERS, PDP-11 MODE
	.BYTE	21.,18.		;22 SECTORS/TRACK, 19 TRACKS/CYLINDER
	.WORD	4		;2 EXTRA WORDS IN HEADER

; 22 = RP06
	.WORD	814.!010000	;815 CYLINDERS, PDP-11 MODE
	.BYTE	21.,18.		;22 SECTORS/TRACK, 19 TRACKS/CYLINDER
	.WORD	4		;2 EXTRA WORDS IN HEADER

	.WORD	0,0,0		;23 = ILLEGAL

; 24 = RM03
	.WORD	822.!150000	;823 CYLINDERS, GOOD SECTOR, PDP-11 MODE
	.BYTE	31.,4.		;32 SECTORS/TRACK, 5 TRACKS/CYLINDER
	.WORD	0		;NO EXTRA WORDS IN HEADER

; 25 = RM02
	.WORD	822.!150000	;823 CYLINDERS, GOOD SECTOR, PDP-11 MODE
	.BYTE	31.,4.		;32 SECTORS/TRACK, 5 TRACKS/CYLINDER
	.WORD	0		;NO EXTRA WORDS IN HEADER


; 26 = RM80
	.WORD	558.!150000	;559 CYLINDERS, GOOD SECTOR, PDP-11 MODE
	.BYTE	30.,13.		;31 SECTORS/TRACK, 14 TRACKS/CYLINDER
	.WORD	0		;NO EXTRA WORDS IN HEADER

; 27 = RM05
	.WORD	822.!150000	;823 CYLINDERS, GOOD SECTOR, PDP-11 MODE
	.BYTE	31.,18.		;32 SECTORS/TRACK, 19 TRACKS/CYLINDER
	.WORD	0		;NO EXTRA WORDS IN HEADER

	.WORD	0,0,0		;30 = ILLEGAL
	.WORD	0,0,0		;31
	.WORD	0,0,0		;32
	.WORD	0,0,0		;33
	.WORD	0,0,0		;34
	.WORD	0,0,0		;35
	.WORD	0,0,0		;36
	.WORD	0,0,0		;37
	.WORD	0,0,0		;40
	.WORD	0,0,0		;41

; 42 = RP07
	.WORD	629.!150000	;630 CYLINDERS, GOOD SECTOR, PDP-11 MODE
	.BYTE	49.,31.		;50 SECTORS/TRACK, 32 TRACKS/CYLINDER
	.WORD	0		;NO EXTRA WORDS IN HEADER

	.WORD	0,0,0		;43
	.WORD	0,0,0		;44
	.WORD	0,0,0		;45
	.WORD	0,0,0		;46
	.WORD	0,0,0		;47

	UNORG

.DSABL	LSB

.SBTTL	FIND RECORDED BAD BLOCKS - OTHER DISKS

; MOST DISKS HAVE NO ERROR TRACKS
ERRDV:
ERRDF:
ERRDS:
ERRDK:
ERRDZ:									;030
ERRDW:									;030
ERRDU:	;******** WE DON'T KNOW HOW TO READ THE FACTORY FILE YET!! ********;
ERRDP:	CLR	D.ERRD		;ERROR TRACKS READ IN NOW
	TST	(R5)+		;TAKE SUCCESS EXIT
	RETURN	R5

.SBTTL	ERROR MESSAGES FROM BAD BLOCK PROCESSING

; NO VALID ERROR RECORDS WERE READ

.ENABL	LSB								;016

RDFAIL:	BCC	10$		;SKIP IF IT'S A DATA ERROR
	RETURN	R5		;SIMPLY RETURN IF THE DRIVE'S NOT READY
10$:	MOV	(SP)+,R5	;RESTORE R5, DESTROYING RETURN ADDRESS
	MESSAGE			;WARN HIM
	 .ASCII	"?There are no valid error records on this pack."<200>	;005
	 .ASCII	"If you wish to continue the DSKINT, you must specify"<200>
	 .ASCII	"the number of patterns to be used in checking the disk."<200>
	 .ASCIZ	"No factory error information will be used."<200>
	 UNORG
	TSTABT								;005
20$:	CALL	YESNO,R5	;ASK FOR CONTINUE			;016
	 GENTXT	<"Continue with DSKINT? ">
	 GENTXT	<"Type 'Y' to continue, 'N' to abort DSKINT: ">
	 BR	25$		;^ -- RE-ASK				;016
	 BR	30$		;LF -- CONTINUE				;016
	 BR	40$		;NO -- ABORT
	 BR	30$		;YES -- ASK FOR PATTERNS AGAIN		;016
25$:	MESSAGE	<"No backing up is permitted."<200>> ;^Z -- RE-ASK	;016
	BR	20$		;RE-ASK					;016

30$:	CALL	ASKPAT		;
	MOV	#-1,SATBUF+10	;SET UP SATBUF FOR NO ERROR RECORDS
	JMP	FORMAT		;RESTART THE FORMATTER

40$:	JMP	FMTABT		;ABORT THE DSKINT


; TOO MANY BAD CLUSTERS

STFAIL:	JMP	EXCBAD		;THIS ROUTINE WILL HANDLE THE PROBLEM

.DSABL	LSB								;016

GLOBAL	<SATBUF>

.SBTTL	READ AND VERIFY RECORDED BAD BLOCK INFO
;+
; RDERR - READ AND VALIDATE RECORDED BAD BLOCK INFO
;
;	R3 (MSB), R2 (LSB) = STARTING ** FBN **
;	R0 =  NUMBER OF BLOCKS TO READ
;
;	CALL	R5,RDERR
;	 <ERROR RETURN - C=1 IF DRIVE NOT READY, C=0 IF DATA ERROR>
;	 <NORMAL RETURN>
;
;	D.EVLD =  NUMBER OF RECORDS SUCCESSFULLY READ.
;	D.ERRD =  0
;	AT LEAST ONE ERROR RECORD IS IN SATBUF.
;
;	EVERY OTHER RECORD IS READ, STARTING AT THE GIVEN BLOCK NUMBER.
;	THE FIRST RECORD SUCCESSFULLY READ IS CHECKED TO MAKE SURE IT
;	LOOKS LIKE A VALID BAD-BLOCK RECORD.  SUBSEQUENT RECORDS MUST
;	MATCH THE FIRST RECORD EXACTLY TO BE COUNTED.
;-

.ENABL	LSB

RDERR::	REGSAV			;SAVE CALLER'S REGISTERS
	CLR	D.EVLD		;NUMBER OF VALID ERROR RECORDS = 0
	CALL	DRESET		;RESET THE CONTROLLER AND DRIVE
	BCS	150$		;SKIP OUT ON ERROR
	CLR	D.ERRD		;FLAG INDICATES THAT ERROR RECORDS DONE
	MOVB	#'1-1,110$	;ERROR RECORD NUMBER 1 IS FIRST
	MOV	#SATBUF,20$	;FIRST READ IS INTO SATBUF+0
	MOV	R0,D.ERCT	;SET COUNT OF RECORDS TO READ
10$:	MOV	#256.,I.DSQ+DSQCNT ;SET THE COUNT FOR 1 BLOCK
	INCB	110$		;INCREMENT NUMBER IN MESSAGE
	CALLX	PARSEX,R5,RFUN ;READ A BLOCK, FBN IN R2,R3
20$:	 .WORD	0		;BUFFER POINTER FILLED IN HERE
	TSTB	I.DSQ+DSQERR	;WAS THE READ GOOD?
	BMI	30$		;YES
	MESSAGE	<"Error detected while reading">
	BR	100$		;GO PRINT TEXT AND TRY ANOTHER RECORD

; GOOD READ OF ERROR RECORD.  IS THIS THE FIRST (VERIFY IT) OR
;	A LATER ONE (COMPARE AGAINST FIRST GOOD ONE) ?

30$:	MOV	#SATBUF,R4	;POINT TO THE LIST OF BAD BLOCKS
	MOV	#256.,R1	;R1 = COUNT OF WORDS
	TST	D.EVLD		;IS THERE A VALID ERROR RECORD IN SATBUF?
	BEQ	50$		;NO, GO VALIDATE THIS ONE
40$:	CMP	1000(R4),(R4)+	;COMPARE NEWLY READ BLOCK AGAINST FORMERLY GOOD
	BNE	90$		;NO GOOD
	SOB	R1,40$		;OK, TRY MORE
	BR	130$		;GOOD, INCREMENT TO GOOD COUNT AND LOOP

GLOBAL	<SATBUF,I.DSQ>

; VERIFY ERROR RECORD IN SATBUF

50$:	MOV	(R4)+,R0	;GET PACK SERIAL NUMBER
	BIS	(R4)+,R0	; OF WHICH ONE WORD OR BOTH MUST BE <> 0
	BEQ	90$		;ZERO PACK SERIAL NUMBER IS NO GOOD PACK
	TST	(R4)+		;NEXT WORD MUST BE 0
	BNE	90$		; SO GIVE ERROR IF NOT
	MOV	(R4)+,R0	;R0 = ALIGNMENT/DATA FLAG
	BEQ	70$		;0 => THIS IS A DATA CARTRIDGE
	INC	R0		;NOT A DATA CARTRIDGE.  IS FLAG = -1?
	BNE	90$		;NO, IT'S JUST A BADDIE
	MESSAGE
	 .ASCII	"?Can't reformat an alignment cartridge!"<200>		;005
	 .ASCIZ	"Replace with a scratch disk and try again."<200>
	 UNORG
	TSTB	BACKUP		;ARE WE DOING A SAV/RESTORE?
	BEQ	60$		;NO, DON'T TRAP THE ERROR		;005
	CALLX	REGRES,R5	;YES, RESTORE REGISTERS
	RETURN	R5		;AND GO BACK TO CALLER

60$:	JMP	FMTABT		;ABORT


70$:	MOV	(R4)+,R0	;GET A BAD CYLINDER NUMBER
	CMP	R0,#-1		;END OF LIST?
	BEQ	120$		;YES, CHECK FOR -1 FILL TO END
	MOV	(R4)+,R1	;R1 = CORRESPONDING BAD TRACK/SECTOR
	CMP	R0,#SATBUF+1000	;END OF BUFFER?
	BHIS	90$		;YES, WE SHOULD HAVE REACHED A -1
	CMP	R0,(R4)		;COMPARE CYLINDER AGAINST NEXT
	BNE	80$		;CYLINDER DIFFERS
	CMP	R1,2(R4)	;CYLINDER =, COMPARE TRACK/SECTOR
80$:	BLO	70$		;LOW IS OK, >= IS ERROR
90$:	MESSAGE	<"Invalid data in">
100$:	MESSAGE			;FAILING RECORD
	 .ASCII	" error record sector # "
110$:	 .ASCIZ	"0"<200>
	 UNORG
	BR	140$

120$:	CMP	R0,(R4)+	;CHECK FOR -1 IN THE REST OF THE BLOCK
	BNE	90$		;NO GOOD
	CMP	R4,#SATBUF+1000	;OK, DONE?
	BLO	120$		;DO MORE
	MOV	R4,20$		;NEXT TIME, READ INTO SATBUF+1000
130$:	INC	D.EVLD		;VALID COUNT UP BY ONE
140$:	ADD	#2,R2		;BUMP THE ERROR RECORD NUMBER
	ADC	R3		;DOUBLE PRECISION
	DEC	D.ERCT		;COUNT RECORDS READ
	BNE	10$		;REPEAT UNTIL DONE
	;CLC			;INDICATE NO ERROR

; DONE READING ERROR RECORDS.  IF NO VALID ONES, RETURN ERROR

150$:	CALLX	REGRES,R5	;RESTORE REGISTERS
	BCS	160$		;TAKE ERROR RETURN IF WE COULDN'T RESET DRIVE
	TST	D.EVLD		;ARE THERE ANY VALID RECORDS?
	BEQ	160$		;NO, TAKE ERROR RETURN
	TST	(R5)+		;SKIP ERROR RETURN
160$:	RETURN	R5		;RETURN SUCCESS

.DSABL	LSB
GLOBAL	<SATBUF,BACKUP>

.SBTTL	SET UP SAT FROM RECORDED BAD BLOCK INFO
;+
; SETERR - SET UP SAT FROM RECORDED BAD BLOCK INFO
;
;	R0 =  NUMBER OF TRACKS PER CYLINDER
;	R1 =  NUMBER OF SECTORS PER TRACK
;	ERROR RECORDS READ INTO SATBUF
;
;	CALL	SETERR,R5
;	 <ERROR RETURN>
;	 <NORMAL RETURN>
;
;	A BIT SET IN THE SAT FOR EVERY CLUSTER THAT HAS A BAD BLOCK.
;	IF MORE THAN D.BMAX BAD CLUSTERS, TAKES ERROR RETURN; OTHERWISE
;	TAKES NORMAL RETURN.
;	PRINTS LIST OF PHYSICAL AND LOGICAL ADDRESSES OF BAD BLOCKS.
;-

.ENABL	LSB

SETERR:	REGSAV			;SAVE ALL REGISTERS
	MESSAGE	<<200>"Disk pack serial number = ">			;005
	MOV	#SATBUF,R4	;R4 -> A VALID ERROR RECORD
	MOV	(R4)+,R3	;LSB SERIAL #
	MOV	(R4)+,R2	;MSB SERIAL #
	CLR	-(SP)		;SET STOPPER ON STACK
	ROL	R3		;SHIFT ONE BIT LEFT			;010
	CLC			;CLC INCASE SIGN BIT WAS DIRTY		;010
	ASHC	#-1,R2		;MOVE 32 BIT OPERAND (SERIAL NUMBER IGNORES	;010
				;SIGN BIT IN LOW ORDER WORD)
10$:	MOV	R3,-(SP)	;SAVE LSB
	BIC	#^C<7>,(SP)	;ISOLATE LOW BITS
	ADD	#'0,(SP)	; AND MAKE IT AN OCTAL DIGIT
	;CLC			;CARRY IS CLEAR FROM ADD
	ROR	R2		;SHIFT 1 BIT WITH NO SIGN EXTENSION
	ROR	R3		; IN BOTH WORDS
	ASHC	#-2,R2		;SHIFT 2 MORE BITS FAST
	BNE	10$		;MORE IN THE SERIAL NUMBER
	MOVB	(SP)+,R2	;GET THE FIRST DIGIT
20$:	CALLX	TYPE		;TYPE A DIGIT
	MOVB	(SP)+,R2	;GET NEXT DIGIT
	BNE	20$		; AND TYPE IT IF ANY
	CALLX	TYPECR
	CMP	(R4)+,(R4)+	;SKIP MBZ WORD & DATA CARTRIDGE FLAG
	CMP	(R4),#-1	;ANY ERRORS?
	BEQ	70$		;NO, GET OUT QUICKLY
	MESSAGE								;005
	 .ASCII	<12>"Factory bad block data:"<200>			;005
	 .ASCIZ	"   Cyl  Track  Sec   Block  Cluster"<200>		;005
	 UNORG								;005
30$:	MOV	(R4)+,R3	;R3 = CYLINDER NUMBER
	BMI	70$		;SKIP OUT IF END OF LIST
	MOV	R3,R0		;COPY FOR PRINTING
	CALLX	DECPRT		;PRINT CYLINDER NUMBER
	MUL	TOS.R0(SP),R3	;MULTIPLY BY TRACKS PER CYLINDER
	MOV	R3,R2		;USE LSB HERE FOR DOUBLE MULTIPLY LATER
	CLR	-(SP)		;MAKE ROOM FOR SECTOR NUMBER
	BISB	(R4)+,(SP)	;SAVE SECTOR NUMBER
	CLR	R3		;MAKE ROOM FOR TRACK NUMBER
	BISB	(R4)+,R3	;GET TRACK NUMBER
	MOV	R3,R0		;COPY FOR PRINTING
	CALLX	DECPRT		;PRINT TRACK NUMBER
	MOV	(SP),R0		;COPY SECTOR NUMBER FOR PRINTING
	CALLX	DECPRT		;PRINT SECTOR NUMBER
	ADD	R3,R2		;R2 = TRACK NUMBER FROM START OF PACK
	MUL	TOS.R1+2(SP),R2	;MULTIPLY BY SECTORS/TRACK, TO R2,R3
	ADD	(SP)+,R3	;ADD SECTOR WITHIN TRACK
	ADC	R2		; TO GIVE ABSOLUTE SECTOR NUMBER
	ASHC	TOS.R2(SP),R2	;ADJUST FOR MULTIPLE SECTORS PER BLOCK
	XOR	R2,R3		;EXCHANGE R2 AND R3
	XOR	R3,R2		;R2 = LSB LOGICAL BLOCK NUMBER
	XOR	R2,R3		;R3 = MSB LOGICAL BLOCK NUMBER
	MESSAGE	<"  ">		;ADJUST SPACING
	CALLX	DBLPRT		;PRINT LOGICAL BLOCK NUMBER
	MOV	DCS,R0		;FETCH DCS SO THAT WE CAN CONVERT LBN TO FBN
	DEC	R0		;FBN = LBN - DCS + 1
	SUB	R0,R2		;COMPUTE FBN
	SBC	R3		;HIGH WORD ALSO
	BPL	50$		;PCN NOT IT GREY AREA
	ADD	R0,R2		;ADD DCN BACK IN
	BEQ	40$		;MUST BE THE BOOT BLOCK
	MESSAG	<"  Bad Block in unused area - not added to BADB.SYS"<200>>
	BR	30$		;LOOK AT NEXT BLOCK	

40$:	ERF	<"?Boot block can not be bad">

50$:	CALLX	SEG2CN		;COMPUTE ERRING PACK CLUSTER #
	MOV	R4,-(SP)	;SAVE POINTER TO BADS LIST
	MOV	R2,R0		;R0 = PCN
	MESSAGE	<"  ">		;ADJUST SPACING
	CALLX	DECPRT		;PRINT CLUSTER NUMBER
	CALLX	TYPECR		;END OF LISTING FOR THIS BLOCK
	CALLX	FIXREG		;CONVERT IT TO BIT AND BYTE
	MOV	R4,-(SP)	;PUSH SATBUF OFFSET
	CALLX	GETSB2		;GET A BYTE FROM THE REAL SAT
	MOV	(SP)+,R4	;POP SAT BYTE
	BITB	R4,BITBYT(R2)	;ALREADY COUNTED AS BAD?
	BNE	60$		;YES, DON'T COUNT IT AGAIN
	BISB	BITBYT(R2),R4	;NO, MARK IT AS BAD
	MOV	R4,-(SP)	;PUSH NEW BYTE VALUE
	CALLX	PUTSB2		;REPLACE THE SAT BYTE
	INC	D.BCNT		;COUNT ANOTHER BAD CLUSTER
60$:	MOV	(SP)+,R4	;RESTORE LIST POINTER
	CMP	D.BCNT,D.BMAX	;OVER THE MAXIMUM?
	BLE	30$		;NO
	;CLC			;DATA ERROR, NOT 'NOT READY'
	CALLX	REGRES,R5	;RESTORE REGISTERS
	RETURN	R5		;RETURN ERROR

70$:	CALLX	TYPECR		;EXTRA BLANK LINE AT THE BOTTOM
	CALLX	REGRES,R5	;RESTORE REGISTERS
	TST	(R5)+		;TAKE SUCCESSFUL RETURN
	RETURN	R5		;DONE

.DSABL	LSB

GLOBAL	<SATBUF,BITBYT>

.IF	NDF	ONLINE							;005

.SBTTL	DK FORMATTER

.ENABL	LSB

DKFMT:	ASH	#13.,R0		;UNIT INTO BITS 13,14,15
	CALL	DRESET		;RESET DRIVE & CONTROLLER
	BCS	50$		;IF ERROR, ASK ABOUT RETRY
	MOV	DSKCSR+IDX$DK,R1 ;R1 -> DK CSR
	MOV	R0,RKDA(R1)	;SET UNIT
10$:	MOV	#-1,RKWC(R1)	;WORD COUNT GOTTA BE ONE
	CLR	RKMA(R1)	;CLEAR CORE ADDRESS
	MOV	#2002,(R1)	;ISSUE WRITE EMT
	INC	(R1)		;GIVE DA GO
	CALL	DELAY		;AVOID TIMING PROBLEMS
	MOVB	#-5,DSS$DK+1	;TIME OUT AFTER 5 SECONDS
20$:	CALLX	GETTTY		;KEEP CLOCK GOING
	TST	DSS$DK		;TIMEOUT?
	BPL	40$		;YES, SIGNAL ERROR
	BIT	#100200,(R1)	;DISK DONE?
	BEQ	20$		;NO -- LOOP
	BPL	10$		;ON TO NEXT SECTOR
	ADD	#14533,R0	;CHECK IF PAST LAST CYLINDER
	CMP	R0,RKDA(R1)
	BHI	40$		;ERROR IF NOT
	TST	(R5)+		;DONE WITH FORMAT, SO RETURN OK
	RETURN	R5

30$:	BIT	#RKWLO,RKER(R1)	;WRITE LOCKOUT?
	BEQ	40$		;NO, LOG THE ERROR
	MESSAGE	<"Disk not write enabled."<200>>,WLOCK
	;CLC
	BR	50$		;TELL THE USER AND RETURN ERROR

40$:	CALLX	DSKLOG		;LOG THE ERROR
50$:	RETURN	R5		;RETURN C=0 FOR ERROR, C=1 FOR NOT READY


DELAY:	MOV	#100,-(SP)	;SET A COUNTER
60$:	DEC	(SP)		;AND COUNT IT DOWN
	BPL	60$
	TST	(SP)+		;POP COUNT
	RETURN

.DSABL	LSB

GLOBAL	<DSKCSR,DSS$DK>

.SBTTL	RP02/RP03 FORMATTER

.ENABL	LSB

DPFMT:	CALL	DRESET		;RESET DRIVE AND CONTROL
	BCS	100$		;RETURN ERROR IF NOT READY
	CALLX	ASKER,R5	;TELL USER TO FLIP THE SWITCH
	 GENTXT	<"Set FORMAT ENABLE switch, then type <CR>: ">
	 GENTXT
	  .ASCII "The format enable switch is a rocker switch labeled"<200>
	  .ASCII "'FORMAT ENABLE/NORMAL' which is located behind one of"<200>
	  .ASCII "the covers near the RP11 controller.  Please locate"<200>
	  .ASCII "this switch and set it to the 'FORMAT ENABLE' position."<200>
	  .ASCIZ "When you have done that, press RETURN: "
	  UNORG
	CMPB	(R1),#12	;DID USER HIT <LF>?
	BNE	90$		;ASSUME HE DOESN'T WANT TO, EXIT
	CALL	DRESET		;RESET DRIVE AND CONTROL
	BCS	100$		;RETURN ERROR IF NOT READY
	MOV	#3,D.RTRY	;RETRY ONLY TWICE
	SWAB	R0		;UNIT NUMBER TO HIGH BYTE
10$:	MOV	DSKCSR+IDX$DP,R1 ;R1 -> RP11 CSR  (ENTER HERE FOR RETRY)
	CLR	(R1)+		;CLEAR	RPCS  CSR
	CLR	(R1)+		;	RPWC  WORD COUNT
	CLR	(R1)+		;	RPMA  MEMORY ADDRESS
	CLR	(R1)+		;	RPCA  CYLINDER ADDRESS
	CLR	(R1)		;	RPDA  DISK ADDRESS
	MOV	DSKCSR+IDX$DP,R1 ;RESTORE POINTER TO CSR
	MOV	R0,(R1)		;SET UNIT NUMBER IN CONTROLLER
	MOVB	#14,(R1)	;ISSUE HOME SEEK
	INC	(R1)		;SET GO
	CALL	DELAY		;AVOID TIMING PROBLEMS
	MOVB	#-5,DSS$DP+1	;TIME OUT AFTER 5 SECONDS
20$:	CALLX	GETTTY		;KEEP CLOCK GOING
	TST	DSS$DP		;TIMEOUT?
	BPL	70$		;YES -- SIGNAL ERROR
	TST	RPDS(R1)	;WAIT FOR DRIVE READY
	BPL	20$
	TSTB	(R1)		;WAIT FOR CONTROLLER READY
	BPL	20$
	TST	(R1)		;ANY ERRORS?
	BMI	60$		;ERROR -- LOG AND RETRY

GLOBAL	<DSKCSR,DSS$DP>

	MOV	R0,(R1)		;SET UNIT NUMBER IN CONTROLLER
	BIS	#014002,(R1)	;SET PDP-10 MODE, HEADER MODE, WRITE
	MOV	#-3,RPWC(R1)	;WORD COUNT IS -3
	CLR	RPMA(R1)	;CLEAR MEMORY ADDRESS
	INC	(R1)		;SET GO
	CALL	DELAY		;AVOID TIMING PROBLEMS
	MOV	#3,R2		;WE NEED 3* MAXIMUM TIMEOUT
30$:	MOVB	#-200,DSS$DP+1	;MAXIMUM TIMEOUT = 2 MINUTES, 8 SECONDS
40$:	CALLX	GETTTY		;KEEP CLOCK GOING
	TSTB	(R1)		;WAIT FOR READY
	BPL	50$		;NO, CHECK TIMEOUT
	TST	(R1)		;ANY ERRORS?
	BMI	60$		;YES, COMPLAIN
	TST	(R5)+		;NO, SET FOR SUCCESS RETURN
	BR	80$		;GO CLEAN UP

50$:	TST	DSS$DP		;TIMEOUT EXPIRED?
	BMI	40$		;NO -- KEEP WAITING
	SOB	R2,30$		;YES -- HAVE 3 OF THEM EXPIRED?
	BR	70$		;LOG ERROR -- NOT A WRITE-LOCK ERROR

; ERROR DETECTED: LOG IT, MAYBE RETRY

60$:	TST	RPER(R1)	;IS DISK WRITE LOCKED?
	BPL	70$		;NO, LOG AN ERROR
	CALLX	MESSAGE,R5,WLOCK ;YES, TELL THE USER IT'S LOCKED
	BR	80$		;AND RETURN ERROR

70$:	CALLX	DSKLOG		;INDICATE ANOTHER ERROR
	DEC	D.RTRY		;CAN WE RETRY ?
	BEQ	80$		;NO, RETURN C=0 FOR FORMATTING ERROR
	CALL	DRESET		;YES, RESET THE DISK
	BCC	10$		;IF NO ERROR RESETTING, RETRY
80$:	BIC	#014000,(R1)	;TURN OFF HEADER AND PDP-10 BITS
90$:	CALLX	ASKER,R5	;HAVE USER TURN OFF THE FORMAT SWITCH
	 GENTXT	<"Set format switch to NORMAL, then type <CR>: ">,DISFMT
	 .WORD	DISFMT		;THAT'S AS CLEAR AS I CAN GET
	CMP	(R1),#12	;DID HE HIT <LF>?
	BNE	90$		;NO, MAYBE HE DIDN'T UNDERSTAND
	CALL	DRESET		;RESET THE DRIVE
	;BCS	100$		;COMPLAIN IF THAT FAILS
100$:	RETURN	R5

.DSABL	LSB

GLOBAL	<DSS$DP>

.SBTTL	DB/DR FORMATTERS FOR RP04/05/06/RM02/03

.ENABL	LSB

DRFMT:
DBFMT:	MOV	SYSNDX,R2	;GET DISK TYPE
	MOV	DSKCSR(R2),R2	;POINT TO ITS CONTROLLER
	MOV	R5,-(SP)	;WE'LL USE R5 FOR BAD BLOCK POINTER
	CALL	DRESET		;RESET THE DRIVE
	BCS	100$		;QUIT IF THAT FAILS
	MOV	#3,D.RTRY	;RETRY ONLY THRICE
	MOV	#014000,RBOF(R2) ;PDP-11 MODE, ECC INHBIT
	MOV	#SATBUF+2000,R1	;CLEAR THE BUFFER WE'RE GOING TO USE
	MOV	#14.*256.,R0	;ALL OF SATBUF EXCEPT FIRST 2 BLOCKS
10$:	CLR	(R1)+
	SOB	R0,10$
	MOV	#SATBUF+10,R5	;POINT TO LIST OF BAD BLOCKS
	MOV	D.CYLS,R0	;SET FORMAT BITS FOR HEADER
	BIC	#007777,R0	;START WITH CYLINDER ZERO
	CLR	R3		;TRACK 0, SECTOR 0
20$:	MOV	#SATBUF+2000,R1	;POINT TO THE BUFFER
	MOV	#11.,R4		;ONLY BIG ENOUGH TO FORMAT 11 SECTORS
30$:	MOV	R0,(R1)+	;SAVE CYLINDER NUMBER, FLAGS
	MOV	R0,-(SP)	;CYLINDER NUMBER TO STACK
	BIC	#170000,(SP)	;TURN OFF THE EXTRA BITS
	CMP	(SP)+,(R5)	;DOES THIS CYLINDER HAVE A BAD BLOCK?
	BNE	40$		;NO -- SKIP
	CMP	R3,2(R5)	;IS IT THIS ONE?
	BNE	40$		;NO -- SKIP
	CMP	(R5)+,(R5)+	;YES -- BUMP BAD BLOCK POINTER
	BIC	#100000,-2(R1)	;MARK THE BLOCK AS BAD
40$:	MOV	R3,(R1)+	;SAVE TRACK & SECTOR
	ADD	D.EXTR,R1	;SKIP EXTRA PART OF HEADER (ZEROS)
	ADD	#1000,R1	;SKIP DATA FOR BLOCK
	INC	R3		;ON TO NEXT SECTOR
	CMPB	R3,D.SECS	;DONE A FULL TRACK YET?
	BHI	50$		;YES -- ISSUE THE COMMAND
	SOB	R4,30$		;NO -- EVEN SO, DON'T DO MORE THAN 11.
50$:	SUB	#SATBUF+2000,R1	;DETERMINE LENGTH OF DATA IN BYTES
	NEG	R1
	ASR	R1		;DIVIDE BY TWO TO GET WORDS
60$:	MOV	#SATBUF+2000,RHBA(R2) ;SET BUFFER POINTER
	MOV	R1,RHWC(R2)	;SET -(WORD COUNT)
	MOV	SATBUF+2000,RBDC(R2) ;SET STARTING CYLINDER
	BIC	#170000,RBDC(R2) ;WITHOUT EXTRA BITS
	MOV	SATBUF+2002,RBDA(R2) ;SET STARTING TRACK & SECTOR
	MOV	#63,(R2)	;"WRITE HEADER AND DATA"
	CALL	DELAY		;AVOID TIMING PROBLEMS

GLOBAL	<SYSNDX,DSKCSR,SATBUF>

	MOVB	#-5,DSS$DB+1	;TIME OUT AFTER 5 SECONDS
70$:	CALLX	GETTTY		;WATCH TERMINAL & CLOCK
	TST	DSS$DB		;TIMEOUT?
	BPL	90$		;YES -- SIGNAL ERROR
	TSTB	(R2)		;DONE?
	BPL	70$		;NO -- KEEP WAITING
	BIT	#RHTRE!RHMCPE,(R2) ;ANY ERRORS?
	BEQ	110$		;NO -- FORMAT NEXT SECTOR
80$:	BIT	#RBWLE,RHER(R2)	;IS DRIVE WRITE LOCKED?
	BEQ	90$		;NO, LOG AN ERROR
	CALLX	MESSAGE,R5,WLOCK ;YES, GIVE AN APPROPRIATE MESSAGE
	;CLC			;DATA ERROR
	BR	140$		;AND QUIT

90$:	CALLX	DSKLOG		;LOG THE ERROR
	;CLC			;DATA ERROR
	MOV	#RHTRE!11,(R2)	;CLEAR OUT THE ERROR
	DEC	D.RTRY		;MAY WE TRY AGAIN?
	BNE	60$		;YES -- DO SO
100$:	MOV	(SP)+,R5	;RESTORE RETURN POINTER
	RETURN	R5		;TAKE ERROR RETURN

110$:	CMPB	R3,D.SECS	;DONE WITH A TRACK?
	BLOS	20$		;NO -- FORMAT SOME MORE SECTORS
	CLRB	R3		;YES -- RESET TO SECTOR 0
	ADD	#400,R3		;AND INCREMENT TRACK NUMBER
	MOV	R3,-(SP)	;SAVE TRACK NUMBER
	SWAB	(SP)		;WHERE WE CAN ACCESS IT
	CMPB	(SP)+,D.TRKS	;LAST TRACK OF A CYLINDER?
	BLO	20$		;NO -- FORMAT IT
	BEQ	120$		;YES -- HANDLE SPECIALLY
	CLR	R3		;PAST THE LAST TRACK -- RESET TO 0
	INC	R0		;AND FORMAT NEXT CYLINDER
	CMP	R0,D.CYLS	;PAST THE LAST CYLINDER?
	BLOS	20$		;NO -- FORMAT THE TRACK
	BR	130$		;YES -- DONE WITH NON-ERROR PACK

120$:	CMP	R0,D.CYLS	;LAST TRACK OF LAST CYLINDER?
	BLO	20$		;NO -- FORMAT IT
	TST	R0		;YES -- DOES THIS PACK HAVE ERROR RECORDS?
	BPL	20$		;NO -- THIS TRACK IS FOR USER DATA
130$:	CALL	DRESET		;ALL DONE -- RESET THE DRIVE
	MOV	(SP)+,R5	;RESTORE RETURN
	BCS	140$		;DIE IF RESET DIDN'T WORK
	TST	(R5)+		;SKIP TO SUCCESS RETURN
140$:	RETURN	R5

.DSABL	LSB

GLOBAL	<DSS$DB>

.SBTTL	DM FORMATTER

DMFMT:	MOV	R5,-(SP)	;SAVE RETURN ADDRESS
	MOVB	SYSPHU,R2	;PICK UP UNIT NUMBER * 2
	MOV	DM$MID(R2),120$	;SET DRIVE TYPE BIT FROM 'MASSBUS ID'
	MOV	#SATBUF+10,R5	;R5 -> ERROR LIST
	MOV	DSKCSR+IDX$DM,R3 ;SET CSR ADDRESS
	MOV	#-1,R2		;STARTING CYLINDER NUMBER (BEFORE INC)
	CALL	DRESET		;RESET THE DRIVE
	BCS	90$		;SKIP IF ERROR
20$:	CLR	R1		;SET STARTING TRACK/SECTOR
	INC	R2		;NEXT CYLINDER
30$:	MOV	#SATBUF+2000,R4	;INITIALIZE THE BUFFER POINTER
	MOV	#22.,R0		;22 SECTORS PER TRACK
40$:	MOV	R2,(R4)+	;SET THE CYLINDER NUMBER IN THE BUFFER
	MOV	R1,(R4)		;SET THE TRACK/SECTOR NUMBER
	BIS	#140000,(R4)	;SET THE SECTOR VALID BITS
	CMP	R2,(R5)		;DOES THIS CYLINDER HAVE A BAD BLOCK?
	BNE	50$		;NO
	MOV	R1,-(SP)	;MOVE PACKED TRACK/SECTOR TO STACK
	BIC	#177740,(SP)	;MASK TO SECTOR
	MOV	R1,-(SP)	;MOVE PACKED TRACK/SECTOR TO STACK
	ASL	(SP)
	ASL	(SP)		;MOVE TRACK TO HIGH BYTE
	ASL	(SP)
	CLRB	(SP)		;MASK TO TRACK
	BIS	(SP)+,(SP)	;FORM TRACK IN HIGH BYTE, SECTOR IN LOW BYTE
	CMP	(SP)+,2(R5)	;DOES IT MATCH THE BAD BLOCK FILE?
	BNE	50$		;NO
	BIC	#100000,(R4)	;YES. CLEAR BIT TO SAY FACTORY ERROR
	CMP	(R5)+,(R5)+	;MOVE POINTER UP ONE ERROR ENTRY

50$:	MOV	(R4)+,(R4)	;COPY TRACK/SECTOR WORD INTO CHECK WORD
	XOR	R2,(R4)+	;XOR IN THE CYLINDER NUMBER
	INC	R1		;BUMP THE SECTOR NUMBER
	SOB	R0,40$		;LOOP FOR EACH SECTOR ON THE TRACK
	MOV	#8.,D.RTRY	;RETRY 8 TIMES
60$:	MOV	R2,RMDCY(R3)	;SET THE DESIRED CYLINDER
	ADD	#RMDA,R3	;POINT TO DISK ADDRESS REGISTER
	MOV	R1,R0		;COPY TRACK/SECTOR
	ASH	#3,R0		;SHIFT THE TRACK TO HIGH BYTE
	CLRB	R0		;SET SECTOR TO 0
	MOV	R0,(R3)		;SET TRACK NUMBER
	MOV	#SATBUF+2000,-(R3) ;SET BUS ADDRESS
	MOV	#-66.,-(R3)	;SET WORD COUNT
	MOV	#27,R0		;GET THE COMMAND
	BIS	120$,R0		;SET THE DRIVE TYPE
	MOV	R0,-(R3)	;DO THE COMMAND
	CALL	DELAY		;AVOID TIMING PROBLEMS
	MOVB	#-5,DSS$DM+1	;TIME OUT AFTER 5 SECONDS
70$:	CALLX	GETTTY		;KEEP CLOCK GOING
	TST	DSS$DM		;TIMEOUT?
	BPL	80$		;YES -- SIGNAL ERROR
	BIT	#100200,(R3)	;WAIT FOR READY OR ERROR
	BEQ	70$		;NOTHING YET
	BPL	100$		;NO ERROR, TRY FOR MORE

GLOBAL	<SATBUF,DSKCSR,DSS$DM>

; ERROR DETECTED

	BIT	#RMWLE,RMER(R3)	;IS DRIVE WRITE LOCKED?
	BEQ	80$		;NO, LOG AN ERROR
	CALLX	MESSAGE,R5,WLOCK ;YES, TELL THE USER IT'S LOCKED
	;CLC
	BR	90$		;AND RETURN ERROR

80$:	CALLX	DSKLOG		;LOG THE ERROR IN THE LIGHTS
	CALL	DRESET		;RESET THE DRIVE
	BCS	90$		;NOT READY ?
	DEC	D.RTRY		;MAY WE RETRY?
	BNE	60$		;YES, DO SO
90$:	MOV	(SP)+,R5	;NO, RESTORE RETURN ADDRESS
	RETURN	R5		;RETURN ERROR
100$:	ADD	#40-22.,R1	;BUMP TRACK BY ONE, CLEAR SECTOR TO 0
	CMP	R1,#<3-1>*40	;UP TO TOP TRACK?
	BGT	20$		;PAST IT, SO GO TO NEXT CYLINDER
	BNE	30$		;NOT THERE YET, DO A LOWER TRACK
	MOV	#411.-1,R0	;ASSUME 411-CYLINDER RK06
	TST	120$		;IS IT?
	BEQ	110$		;YES
	MOV	#815.-1,R0	;NO -- IT'S AN 815-CYLINDER RK07
110$:	CMP	R2,R0		;IS THIS LAST TRACK OF LAST CYLINDER?
	BNE	30$		;NO, JUST AN ORDINARY TRACK
	MOV	(SP)+,R5	;YES, LEAVE ERROR LOG TRACK ALONE
	TST	(R5)+		;RESTORE RETURN ADDRESS AND FIX IT
	RETURN	R5		;BACK TO DSKINT

120$:	.WORD	0		;FLAG FOR RK06/RK07

.ENDC	;NDF ONLINE							;005

.SBTTL	DSKINT BAD BLOCK CHECKER

.ENABL	LSB

5$:	JMP	100$							;005

CKBADB:	CALL	DRESET		;RESET CONTROLLER AND DRIVE
	BCS	5$		;RESET ERRORS ARE FATAL			;005
	CLR	-(SP)		;PUSH OFFSET OF 0 INTO SAT
	CALLX	GETSB2		;GET A WORD FROM THE SAT (0 IS EVEN!)
	BIT	#1,(SP)+	;Bad pack cluster 1 (for pack label)?	;002
	BEQ	10$		;THE BETTER NOT BE !
	ERF	<"?Cluster 1 (required for pack label) contains a bad block"> ;005

10$:	CALL	LODPAT,R5	;LOAD A PATTERN INTO SATBUF
	 RETURN			;RETURN IF NONE LEFT TO DO
	CLR	ERRHDR		;HAVEN'T PRINTED THE ERROR HEADER YET
	CLR	R2		;ZERO CURRENT FBN COUNTER
	CLR	R3		;DOUBLE PRECISION
	MOV	#1,R5		;SINGLE BLOCK CHECK ON BOOT BLOCK
	CALL	WRITWC		;DO THE WRITE AND WRITE CHECK
	BCC	20$		;BAD NEWS ON BAD BOOT BLOCK
	ERF	<"?Disk block 0 (required for bootstraps) is bad">	;005

20$:	ADD	R5,R2		;BUMP CURRENT BLOCK BY # WE DID
	ADC	R3		;LET CARRY DO ITS THING
30$:	MOV	#D.BFSZ,R5	;NORMALLY WE DO D.BFSZ BLOCKS AT A TIME
	MOV	D.SIZM,R1	;R1 = DISK SIZE (MAX FBN + 1) MSB
	MOV	D.SIZL,R0	;R0 = LSB OF DISK SIZE
	SUB	R2,R0		;SUBTRACT FOR NUMBER OF BLOCKS
	SBC	R1		; YET TO BE CHECKED
	SUB	R3,R1
	BNE	40$		;IF MSB OF DIFF <> 0,GOT LONG WAY TO GO
	CMP	R0,R5		;LESS THAN ONE FULL BUFFER TO DO?
	BHIS	40$		;NOPE, LOTS TO GO
	MOV	R0,R5		;REDUCE BUFFER SIZE
	BNE	40$		;Still more left			;005
	TST	WRONLY		;Are we writing rather than checking?	;005
	BNE	CKBADB		;No, done with a pattern, do another	;005
	INC	WRONLY		;Yes, done zeroing, check from now on	;005
	RETURN			;All done here				;005

40$:	MOVB	#-2,NRETRY	;ONLY 2 RETRIES IF ERROR
	CALL	WRITWC		;Do a write and write check.		;024
	BCC	20$		;No errors, try another block.		;024

GLOBAL	<NRETRY,ERRCTR,HNGDEV>						;022

; ERROR FOUND IN LONG READ. DO SINGLE BLOCK I/O TO ISOLATE IT

	MOV	ERRCTR,D.ERR	;SAVE THE ERROR COUNT BEFORE SINGLE BLOCK CHECK
	MOV	R5,R0		;COPY BLOCK COUNT HERE
	MOV	#1,R5		; AND DO 1-BLOCK TRANSFERS NOW
	CMPB	@#I.DSQ+DSQERR,#HNGDEV	;Is it hung?			;022
	BEQ	100$			;Yup, call it fatal.		;022
	CALL	DRESET		;RESET DRIVE AND CONTROLLER
	BCS	100$		;RESET ERRORS STILL VERY FATAL
50$:	MOVB	#-2,NRETRY	;AGAIN, ONLY 2 RETRIES
	CALL	WRITWC		;WRITE & WRITE CHECK
	BCC	80$		;Block is OK.				;024
	MOV	R0,-(SP)	;SAVE THE BLOCK COUNTER
	MOV	R2,-(SP)	;AND CURRENT BLOCK NUMBER
	MOV	R3,-(SP)
	CALLX	SEG2CN		;CONVERT FIP BLOCK # TO PACK CLUSTER #
	MOV	R2,R0		;COPY THAT FOR FIXREG
	CALLX	FIXREG		;GET SAT POINTERS FOR THE BAD PACK CLU
	MOV	R4,-(SP)	;PUSH OFFSET INTO SAT
	CALLX	GETSB2		;GET A BYTE FROM THE SAT
	BITB	BITBYT(R2),(SP)	;WAS THIS BADDY ALREADY COUNTED ?
	BNE	60$		;YES - FOUND EARLIER IN CLU OR FORMER PATTERN
	BISB	BITBYT(R2),(SP)	;SET THE BIT
	CALLX	PUTSB2		;REPLACE THE UPDATED BYTE IN THE SAT (POPPING)
	INC	D.BCNT		;BUMP THE BAD CLUSTER COUNTER
	CMP	D.BCNT,D.BMAX	;TOO MANY ?
	BLE	70$		;NO, PROCEED NORMALLY
EXCBAD:	ERF	<"?Excessive bad clusters">				;005


60$:	TST	(SP)+		;DUMP THE BYTE FROM THE SAT
70$:	MOV	(SP)+,R3	;GET BACK THE CURRENT BLOCK NUMBER
	MOV	(SP)+,R2
	MOV	(SP)+,R0	;RESTORE BLOCK COUNTER
	TST	ERRHDR		;HAVE WE PRINTED THE ERROR HEADER YET?
	BNE	75$		;YEP
	INC	ERRHDR		;NOW WE HAVE
	MESSAGE	<"Bad block added to BADB.SYS"<200>>
75$:	CALL	TYPERR		;REPORT THE BAD BLOCK EVERY TIME
	CALL	DRESET		;DO DRIVE RESET & CONTROL RESET TO CLEAR ERROR
	BCS	100$		;RESET ERRORS ARE FATAL
80$:	ADD	#1,R2		;BUMP THE BLOCK NUMBER BY ONE
	ADC	R3
	SOB	R0,50$		;DO ALL BLOCKS IN THE BAD LONG CHECK
	CMP	ERRCTR,D.ERR	;WAS A SINGLE BLOCK ERROR FOUND?
	BNE	90$		;YES, THEN NO-ONE WILL BE CONFUSED
	MOV	HDRIDX,-(SP)	;SAVE THE HEADER DRIVE NUMBER
	MOV	HDRUNT,-(SP)	;AND THE UNIT SINCE THIS MESSAGE DOES NO DAMAGE
	MESSAGE	<"Recoverable"<200>>
	MOV	(SP)+,HDRUNT	;RESTORE THE HEADER INFO
	MOV	(SP)+,HDRIDX	;TO KEEP THE ERROR LOGGER FROM PRINTING A NEW INDEX
90$:	CALL	DRESET		;RESET THE DISK
..NOCH	==	.
	BCC	30$		;RETURN TO FAST MODE
100$:	ERF	<"?Fatal disk error during control reset">		;005

.DSABL	LSB

GLOBAL	<NRETRY,BITBYT,HDRUNT,HDRIDX>

.SBTTL	DSKINT DISK BUILDER

.ENABL	LSB

; LINK UP THE BAD BLOCK FILE and verify locations for SATT and [1,*]	;035
; are valid.
;
; We also verify that the arguments for SATT and/or [1,*] accounts are
; legal, as it could not be checked previously for floppy sized devices.
; If they are illegal, we make them legal after displaying a warning message.

BUILD:	CMP	SATSYS+BITS,D.PREF ;Is SATT location OK?		;035
	BHI	5$		;Yes, so try accounts location		;035
	MOV	#1,D.PREF	;Set it to 1				;035
	MESSAGE								;035
	 .ASCII "%Specified SATT.SYS location is invalid - placing at "	;035
2$:	 .ASCIZ "1"<200>						;035
	 UNORG
5$:	CMP	SATSYS+BITS,D$PREF ;Is [1,*] accounts location OK?	;035
	BHI	7$		;Yes, so everything is OK		;035
	MOV	D.PREF,R1	;Get the SATT location			;035
	MOV	R1,D$PREF	;And set [1,*] to SATT location		;035
	MUL	CLURAT,R1	;Multiply by cluster ratio		;035
	INC	R1		; and increment to get DCN		;035
	MOV	R1,R0		;Copy that				;035
	MOV	#6$,R1		;Point to where to store string		;035
	CALLX	DECSTR		;Convert (R0) to decimal string		;035
	MESSAGE								;035
	 .ASCII	"%Specified  [1,*]   location is invalid - placing at "	;035
6$:	 .ASCIZ "??????"<200>						;035
	 UNORG
7$:	INC	WRONLY		;BE SURE TO WRITE CHECK WHEN BUILDING DISK
	CALL	230$,R5,<ZERO,ZERO> ;Zero out SATBUF's first block	;002
	MOV	#1,R2		;We'll wipe the pack label		;002
	CLR	R3		;No high order FBN			;002
	MOV	#256.,I.DSQ+DSQCNT ;Set word count for 1 block		;002
	CALL	PARSEX,R5	;Write it				;002
	+	WFUN		;Function				;002
	+	SATBUF		;From SATBUF				;002
	TSTB	I.DSQ+DSQERR	;Error?					;002
	BPL	80$		;Yes, that's bad news			;002
	CALLX	RESSAT		;GET THE REAL SAT TABLE INTO SATBUF
	MOV	#RL.BAD,-(SP)	;ADDRESS OF INITIAL LINK WORD
	MOV	D.BCNT,R5	;GET COUNT OF BAD PACK CLUSTERS
	MOV	R5,R1		;COPY THAT
	MUL	PCS,R1		;MULTIPLY BY PCS FOR # OF BAD BLOCKS
	MOV	R1,SZ.BAD	;SET LENGTH OF BADB.SYS
	BEQ	40$		;IF ZERO, NO LINKING REQUIRED
	MOV	#RE.BAD-UFD0.1,R1 ;OFFSET OF 1ST RE IN BADB.SYS
	CLR	R0		;ZERO A CLUSTER COUNTER

; LOOP THROUGH ALL CLUSTERS IN SATT UNTIL ENOUGH BAD ONES ARE LINKED IN

10$:	CALLX	FIXREG		;GET SAT POINTERS
	BITB	BITBYT(R2),SATBUF(R4) ;IS IT A BADDIE ?
	BEQ	30$		;NOPE
	BIT	#17,R1		;YES, IS THERE ROOM IN THIS R.E.?
	BNE	20$		;YES
	MOV	R1,@(SP)+	;NO. R1 -> NEW R.E., LINK PREVIOUS TO IT
	MOV	R1,-(SP)	;REMEMBER WHERE LINK WORD OF THIS R.E. IS
	ADD	#UFD0.1,(SP)	; ON THE STACK
	TST	(R1)+		;BUMP R1 TO FIRST RP POSITION IN R.E.
20$:	MOV	R0,R3		;COPY PACK CLUSTER NUMBER
	MUL	CLURAT,R3	;CONVERT TO RETRIEVAL POINTER (DCN)
	INC	R3		;RP=CN*(PCS/DCS)+1
	MOV	R3,UFD0.1(R1)	;SHOVE RETRIEVAL POINTER IN R.E.
	TST	(R1)+		;BUMP TO NEXT R.E. POSITION
	DEC	R5		;DECREMENT BAD CLUSTER COUNTER
	BEQ	40$		;IF NONE LEFT, QUIT
30$:	INC	R0		;ELSE BUMP CLUSTER NUMBER
	BR	10$		;GO FOR MORE

; R.E.'S FOR BAD BLOCK FILE NOW SET IN [0,1] UFD IN SATBUF

40$:	TST	(SP)+		;POP THE LAST LINK WORD
	BIT	#1,SATBUF	;Can we allocate the pack label?	;002
	BNE	70$		;If not, that's a bug			;002
	BIS	#1,SATBUF	;Allocate the pack label		;002
	MOV	MFDCLU,R1	;MFD cluster size			;004
	CALL	GTDIRX,R3,<7*400+1,RB.MFD,D.PREF> ;Allocate 1 or 7	;002
	BCC	70$		;Can't get one, that's bizarre		;002
	MOV	RB.MFD,MFDDCN	;Save starting DCN of MFD		;002
	MOV	SATSYN,R1	;GET NUMBER OF BLOCKS IN SAT
	MOV	R1,SZ.SAT	;SET LENGTH OF SATT.SYS
	MOV	D.PREF,R0	;GET PREFERRED START FOR SATT.SYS
	CALLX	GETCLU		;GET CLUSTERS FOR THE SATT
	BCC	70$		;SHOULD ALWAYS BE ABLE TO GET EM
	MOV	R2,-(SP)	;SAVE RP TO START OF ALLOCATED SATT
	CALLX	FIXCLU		;ROUND UP # OF SAT BLOCKS BY PCS
	MOV	R1,-(SP)	;SAVE THAT COUNT FOR WRITE OF SATT
	MOV	#RE.SAT+2-UFD0.1,R4 ;R4 = RELATIVE PTR TO 1ST RIB POSITION
50$:	MOV	R2,UFD0.1(R4)	;FILL & LINK SAT R.E.'S IN [0,1] UFD
	SUB	PCS,R1		;ANY MORE BLOCKS IN THE SATT ?
	BEQ	60$		;NO, GO WRITE THE [0,1] UFD
	TST	(R4)+		;BUMP RELATIVE POINTER TO R.E.
	ADD	CLURAT,R2	;BUMP RETRIEVAL POINTER
	BIT	#17,R4		;END OF RETRIEVAL ENTRY ?
	BNE	50$		;NO, KEEP FILLING THIS ONE
	MOV	R4,UFD0.1-20(R4) ;YES, SET THE PREVIOUS LINK
	TST	(R4)+		;BUMP TO 1ST R.E. POSITION
	BR	50$		;HANG IN THERE

60$:	MOV	MFDCLU,R1	;GFD cluster size			;004
	CALL	GTDIRX,R3,<7*400+1,RB.GF0,D.PREF> ;Allocate 1 or 7	;021
	BCC	70$		;Can't get one, that's bizarre		;002
	MOV	CL.0.1,R1	;GET [0,1] UFD CLUSTER SIZE		;002
	CALL	GTDIRX,R3,<7*400+1,RB.0.1,D.PREF> ;Get 1 or 7		;021
	BCS	90$		;BAD SCENE IF WE CAN'T DO IT
70$:	ERF	<"?DSKINT or SYSGEN error - DSKINT allocation failure">	;005

80$:	JMP	220$		;Disk error, that's bad news		;002

90$:	CLR	RB.GF1		;Assume no [1,*]			;002
	CLR	RB.1.1		; no [1,1]				;002
	CLR	RB.1.2		;  and no [1,2]				;002
	TST	PP.1.2		;Creating [1,2]?			;002
	BNE	100$		;Yes					;002
	TST	PP.1.1		;How about [1,1]?			;002
	BEQ	120$		;No, so don't bother with [1,*] GFD	;002
100$:	MOV	MFDCLU,R1	;GFD clustersize			;004
	CALL	GTDIRX,R3,<7*400+1,RB.GF1,D$PREF> ;Get 1 or 7		;002
	BCC	70$		;Die if error				;002
	TST	PP.1.1		;Creating [1,1]?			;002
	BEQ	110$		;No, that simplifies things		;002
	MOV	CL.1.1,R1	;Get clustersize			;002
	CALL	GTDIRX,R3,<7*400+0,RB.1.1,D$PREF> ;Get 7 or none	;002
	BCC	70$		;Die if error				;002
110$:	TST	PP.1.2		;IS THERE AN ACCOUNT [1,2]?		;002
	BEQ	120$		;NOPE, DON'T TRY TO PRE-EXTEND
	MOV	CL.1.2,R1	;R1 = [1,2] DIRECTORY CLUSTER SIZE
	CALL	GTDIRX,R3,<7*400+0,RB.1.2,D$PREF> ;Get 7 or none	;002
	BCC	70$		;MAKE A SCENE IF WE CANNOT ALLOCATE
120$:	MOV	(SP)+,R5	;RESTORE NUMBER OF BLOCKS IN SAT
	TST	LRGDSK		;Are we doing a large disk?		;028
	BEQ	125$		;No, so write PCS sized SATT		;028
	MOV	#16.,R5		;Yes, so write 16 block SATT		;028
125$:	MOV	(SP)+,R2	;RECALL THE STARTING RP OF THE SAT
	CALLX	CNVRIB		;CONVERT THAT RIB TO A FIP BLOCK NUMBER
	CALL	WRITWC		;WRITE & WRITE CHECK THE SAT
	BCS	80$		;DIE ON ERROR
	MOV	RB.0.1,RP.0.1	;Copy over [0,1] starting DCN		;002
	CALL	BLDCLU,R5	;Load [0,*] GFD into the SATBUF		;002
	+	GFD0		;Start here				;002
	+	END0		;End here				;002
	+	GFDCLU		;Standard clustersize			;002
	MOV	RP.0.1,SATBUF+1000+2 ;Set up UFD pointer in block 1	;002
	MOV	#NE.0.1-GFD0,SATBUF+2000+2 ;Set up N.E. link in block 2	;002
	MOV	MFDCLU,R1	;Get GFD clustersize			;004
	BIS	#100000,R1	;Set the flag				;004
	CALL	EXTEND,R5,<RB.GF0,7*400+1> ;Write 1 or 7		;002
	CALL	BLDCLU,R5	;LOAD [0,1] UFD INTO SATBUF
	+	UFD0.1		;MOVE WORDS BETWEEN D.UORG AND D.UEND
	+	END0.1		;ZERO FILL THE REST OF CLUSTER
	+	CL.0.1		;ADDRESS OF UFD CLUSTER SIZE
	MOV	CL.0.1,R1	;RECALL [0,1] CLUSTER SIZE
	CALL	EXTEND,R5,<RB.0.1,7*400+1> ;Write 1 or 7		;002

; Now load [1,2] and [1,1] UFDs into SATBUF				;002

130$:	TST	PP.1.2		;IS THERE AN ACCOUNT [1,2]?
	BNE	140$		;Yes					;002
	TST	PP.1.1		;No, but how about [1,1]?		;002
	BEQ	210$		;No, just finish up with MFD and boot	;002
	BR	150$		;Skip [1,2], do [1,1]			;002

140$:	CALL	BLDCLU,R5	;LOAD [1,2] UFD INTO SATBUF
	+	UFD1.2		;MOVE WORDS BETWEEN D.UORG AND D.UEND
	+	END1.2		;ZERO FILL THE REST OF CLUSTER
	+	CL.1.2		;ADDRESS OF UFD CLUSTER SIZE
	MOV	CL.1.2,R1	;Get [1,2] clustersize			;002
	CALL	EXTEND,R5,<RB.1.2,7*400+0> ;Write 7 or none		;002
150$:	TST	PP.1.1		;Is there an account [1,1]?		;002
	BEQ	160$		;No, skip				;002
	CALL	BLDCLU,R5	;NOW BUILD [1,1] IN SATBUF		;002
	+	UFD1.1		;COPY AREA FROM UFD1.1 TO END1.1
	+	END1.1		;AND ZERO FILL THE CLUSTER
	+	CL.1.1		;ADDRESS OF [1,1] CLUSTER SIZE
	MOV	CL.1.1,R1	;GET [1,1] CLUSTER SIZE
	CALL	EXTEND,R5,<RB.1.1,7*400+0> ;Write 7 or none		;002
160$:	MOV	RB.1.1,RP.1.1	;Store [1,1] starting DCN in N.E.	;002
	MOV	RB.1.2,RP.1.2	; likewise for [1,2]			;002
	CALL	BLDCLU,R5	;Load [1,*] GFD into the SATBUF		;005
	+	GFD1		;Start here				;002
	+	END1		;End here				;002
	+	GFDCLU		;Standard clustersize			;002
	MOV	RP.1.1,SATBUF+1000+2 ;Set up UFD pointer in block 1	;002
	TST	PP.1.1		;Did we define [1,1]?			;002
	BEQ	190$		;Skip if not				;002
	MOV	#NE.1.1-GFD1,SATBUF+2000+2 ;Set [1,1] N.E. link		;002
190$:	MOV	RP.1.2,SATBUF+1000+4 ; and another for [1,2]		;002
	TST	PP.1.2		;Did we define [1,2]?			;002
	BEQ	200$		;Skip if not				;002
	MOV	#NE.1.2-GFD1,SATBUF+2000+4 ;Set up [1,2] N.E. link	;002
200$:	MOV	MFDCLU,R1	;Get GFD clustersize			;004
	BIS	#100000,R1	;Set the flag				;004
	CALL	EXTEND,R5,<RB.GF1,7*400+1> ;Write 1 or 7		;002
210$:	CALL	BLDCLU,R5	;Load MFD into the SATBUF		;002
	+	STAMFD		;Start here				;002
	+	ENDMFD		;End here				;002
	+	GFDCLU		;Standard clustersize			;002
	MOV	RB.GF0,SATBUF+1000 ;Set up GFD pointer in block 1	;002
	MOV	RB.GF1,SATBUF+1000+2 ; and another for [1,*]		;002
	MOV	MFDCLU,R1	;Get MFD clustersize			;004
	BIS	#100000,R1	;Set the flag				;004
	CALL	EXTEND,R5,<RB.MFD,7*400+1> ;Write 1 or 7		;002
	CALL	230$,R5,<PAKLBL,LBLEND> ;Set up pack label in SATBUF	;002
	MOV	#1,R2		;We'll write FBN 1			;002
	CLR	R3		; high order				;002
	MOV	R2,R5		;One block				;002
	CALL	WRITWC		;Write and check it			;002
	BCS	220$		;Die if error writing pack label	;002
	CALL	230$,R5,<DUMBOT,BOTEND> ;Move bootstrap to SATBUF	;002
	CLR	R2		;SET UP TRANSFER TO BLOCK ZERO
	CLR	R3
	MOV	#256.,I.DSQ+DSQCNT ;SET WORD COUNT FOR ONE BLOCK
	CALL	PARSEX,R5	;WRITE OUT THE DUMMY BOOT
	+	WFUN		;WRITE FUNCTION
	+	SATBUF		;From the SATBUF			;002
	TSTB	I.DSQ+DSQERR	;ANY ERROR IS FATAL
	BPL	220$		;DIE
	RETURN			;BACK TO DSKINT DRIVER

220$:	ERF	<"?Disk error during DSKINT build phase">		;005

230$:	MOV	#SATBUF+1000,R0	;Point to end of first block		;002
240$:	CLR	-(R0)		;Clear a word				;002
	CMP	R0,#SATBUF	;Done?					;002
	BHI	240$		;No					;002
	MOV	(R5)+,R1	;Get start pointer			;002
250$:	MOV	(R1)+,(R0)+	;Move a word				;002
	CMP	R1,(R5)		;Done?					;002
	BLO	250$		;No					;002
	TST	(R5)+		;Skip end pointer			;002
	RETURN	R5		;Exit					;002

.DSABL	LSB

GLOBAL	<PCS,BITBYT,SATBUF,CLURAT,SATSYN,I.DSQ>				;002

.SBTTL	DSKINT UTILITIES

;+
; LODPAT - PATTERN LOADER
;
;	CALL	LODPAT,R5
;
;	FIRST RETURN IF NO MORE PATTERNS
;	SECOND RETURN, PATTERN LOADED INTO SATBUF
;
;	FOR USER PATTERNS:						;005
;		THE PATTERN IS LOADED INTO THE FIRST WORD OF THE	;005
;		BUFFER AND COPIED FROM LEFT TO RIGHT.			;005
;
;	FOR SYSTEM PATTERNS:						;005
;		The pattern consists of 3 words, each being the		;005
;		previous one left-shifted by 1 bit (MFM worst-case	;005
;		pattern).						;005
;
;		SYSTEM PATTERNS ARE AS FOLLOWS:				;005
;
;			PATTERN #1 - 155555 133333 066666		;005
;				#2 - 133333 066666 155555		;005
;				#3 - 066666 155555 133333		;005
;-

.ENABL	LSB

LODPAT:	TST	SECRTY		;ERASING?
	BNE	70$		;NOPE
	MOV	#90$,R3		;R3 -> PATTERN NUMBER			;005
	TST	NUPATS		;ANY USER PATTERNS?			;005
	BEQ	20$		;NO					;005
	MOV	D.PNDX,R1	;YES, GET INDEX INTO USER PATTERNS	;005
	MOV	#SATBUF,R0	;R0 -> TO THE START OF THE BUFFER	;005
	MOV	-(R1),(R0)	;LOAD PATTERN INTO SATBUF		;005
	MOV	R1,D.PNDX	;SAVE INDEX TO NEXT PATTERN		;005
	MOV	#D.BFSZ*400,R1	;Count of words to load			;005
10$:	MOV	(R0),(R0)+	;Copy another word			;005
	SOB	R1,10$		; until done with bufferfull		;005
	MOVB	#'X,(R3)+	;INDICATE A USER PATTERN "X"		;005
	MOVB	NUPATS,-(SP)	; AND COPY THE PATTERN NUMBER		;005
	DEC	NUPATS		;DECREMENT THE USER PATTERN COUNT	;005
	BR	40$							;005

20$:	TST	NSPATS		;FINISHED WITH SYSTEM PATTERNS?		;005
	BEQ	70$		;YES					;005
	MOV	#D.BFSZ*400,R2	;GET THE BUFFER SIZE			;005
	MOV	#SATBUF,R1	;R1 -> TO THE BUFFER			;005
	MOVB	NSPATS,-(SP)	;COPY THE PATTERN NUMBER		;005
	DEC	NSPATS		;DECREMENT THE COUNTER			;005
	MOV	NSPATS,R0	;Get pattern number - 1			;005
	ASL	R0		;Make into word offset			;005
30$:	MOV	PATTBL(R0),(R1)+   ;LOAD THE FIRST WORD			;005
	MOV	PATTBL+2(R0),(R1)+ ; AND THE SECOND			;005
	MOV	PATTBL+4(R0),(R1)+ ;  AND THE THIRD			;005
	SUB	#3,R2		;WE DONE YET?				;005
	CMP	R2,#3		;LESS THAN 3 WORDS TO GO?
	BGT	30$		;NOPE
	BEQ	40$		;NONE LEFT
35$:	MOV	PATTBL(R0),(R1)+   ;MOVE A WORD
	SOB	R2,35$		;AGAIN

40$:	ADD	#'0,(SP)	;MAKE THE PATTERN NUMBER ASCII		;005
	MOVB	(SP)+,(R3)+	;INDICATE WHICH PATTERN WE'RE RUNNING	;005
	MOV	#100$,R2	;R2--> <CR>
	MOVB	(R2)+,(R3)+	;INDICATE THE END OF THE STRING		;005
	MOVB	(R2)+,(R3)+	;WITH A <CR> AND A ZERO
	TST	WRONLY		;ARE WE WRITING ONLY?			;005
	BNE	50$		;No					;005
	MESSAGE	<<200>"Erasing disk"<200>>				;005
	BR	60$		;Continue				;005

50$:

.IF	NDF	ONLINE							;027
	CMP	MICRO,#-1	;Micro & Installation			;027
	BEQ	60$		;Yes, skip message			;027

GLOBAL	<MICRO>								;027
.ENDC									;027

	CALL	MESSAG,R5,80$	;TELL THE USER				;005
60$:	TST	(R5)+		;BUMP TO SECOND RETURN			;005
70$:	RETURN	R5							;005

80$:	.ASCII	<200>"Pattern "						;005
90$:	.BYTE	0							;005
	.BYTE	0
	.BYTE	0
100$:	.ASCIZ	<200>	
	.EVEN								;005
	RETURN

.DSABL	LSB

GLOBAL	<SATBUF>

.SBTTL	WRITE & WRITE CHECK
;+
;	R2,R3	= STARTING FIP BLOCK NUMBER TO WRITE AND CHECK
;	R5	= NUMBER OF BLOCKS TO DO
;
;	CALL	WRITWC
;
;	C=0	BLOCK(S) WRITTEN AND CHECKED
;	C=1	BAD BLOCK; RETRIES HAVE BEEN DONE
;-

.ENABL	LSB

WRITWC:	MOV	#WFUN,20$	;SET WRITE FUNCTION
	CALL	10$		;AND CALL FUNCTION DOER
	BCS	30$		;ERROR ON WRITE
	TST	WRONLY		;ARE WE WRITING ONLY?			;005
	BNE	5$ 		;NO					;005
	RETURN			;YEP					;005

5$:	MOV	#RFUN.C,20$	;SET WRITE CHECK FUNCTION		;005
10$:	MOV	R5,-(SP)	;STACK BLOCK COUNT
	SWAB	(SP)		;(SP)*256. FOR +WORD COUNT
	MOV	(SP)+,I.DSQ+DSQCNT;STORE WORD COUNT IN DSQ
	CALLX	PARSEX,R5	;DO IT TO IT
20$:	+	0		;FUNCTION
	+	SATBUF		;BUFFER ADDRESS
	TSTB	I.DSQ+DSQERR	;ANY ERROR ?
	BMI	30$		;NOPE, RETURN C=0
	SEC			;ERROR,RETURN C=1
30$:	RETURN

;DISK RESET CALLER


DRESET:	MOV	R1,-(SP)	;SAVE ONE
	MOV	R4,-(SP)	;SAVE ANUDDER
	MOVB	SYSUNT,R4	;SET UP UNIT
	MOV	SYSNDX,R1	;GET DISK INDEX
	CALLX	XXRSET		;RESET THE DISK OF YOUR CHOICE
	MOV	(SP)+,R4	;RESTORE R4
	MOV	(SP)+,R1	;RESTORE R1
	RETURN

.DSABL	LSB

GLOBAL	<ERRCTR,I.DSQ,SATBUF,SYSUNT,SYSNDX>

.SBTTL	DIRECTORY BUILDERS

;+
; BLDCLU - MOVE PROTOTYPE BLOCK INTO SATBUF, ZERO FILL THE REST
;
;	CALL	BLDCLU,R5,<AREA START ADDRESS, END ADDRESS,
;			   POINTER TO DIRECTORY CLUSTERSIZE>
;
;	DESTROYS R0,R1,R3
;-

BLDCLU:	MOV	(R5)+,R0	;PICKUP START ADDR OF AREA TO BE COPIED
	MOV	(R5)+,R3	;AND THE END ADDRESS
	MOV	#SATBUF,R1	;SET POINTER TO BUFFER
10$:	MOV	(R0)+,(R1)+	;MOVE EM OUT
	CMP	R0,R3		;DONE ?
	BNE	10$		;NOT YET
	MOV	@(R5)+,R3	;GET CLUSTER SIZE
	CMP	R3,#16.		;large disk request?			;028
	BLOS	15$		;no, so ok				;028
	MOV	#16.,R3		;only do 16 blocks			;028
15$:	MUL	#512.,R3	;CALCULATE RELATIVE END OF AREA TO CLEAR
	ADD	#SATBUF,R3	;MAKE IT ABSOLUTE
20$:	CLR	(R1)+		;CLEAR THEM WORDS
	CMP	R1,R3		;DONE WITH WHOLE CLUSTER ?
	BNE	20$		;NOPE, HANG IN THERE
	RETURN	R5		;WE'LL BUILD MAP BLOCKS BELOW

GLOBAL	<SATBUF>

;+
; GTDIRX - PRE-ALLOCATE OUT OF SATBUF THE CLUSTERS NEEDED FOR A WHOLE DRECTORY
;
;	R1 =  DIRECTORY CLUSTER SIZE
;
;	CALL	GTDIRX,R3,<CLUSTERS,7 WORD AREA FOR RIB'S,STARTING PCN>	;002
;-

.ENABL	LSB

GTDIRX:	REGSAV			;SAVE THOSE REGISTERS
	ADD	#6,TOS.R3(SP)	;BUMP THE RETURN POINTER		;002
	MOV	(R3)+,R5	;Get cluster counts			;002
	TSTB	P.EXT		;Pre-extend?				;002
	BEQ	10$		;No, so we have the right count		;002
	SWAB	R5		;Yes, use the other count		;002
10$:	MOVB	R5,R5		;Isolate the proper count		;002
	MOV	R5,RBCNT	;Save away the cluster count we want	;002
	MOV	R1,R5		;MAKE A COPY OF THE DIRECTORY CLUSTER SIZE
	CLR	R4		;PREPARE FOR THE DIVIDE
	DIV	PCS,R4		;R5 = DIRECTORY CLUSTER/PCS RATIO
	MOV	R4,R5		;GET RATIO INTO R5
	BNE	15$		;Valid (non-zero) ratio			;031
	INC 	R5		;Zero, so Dir CS<PCS, legal on lrg disks;031
15$:	DEC	R5		;R5 = MASK FOR DIRECTORY CLUSTER BOUNDARY
	MOV	(R3),R4		;Point to RP table			;002
	ADD	#7*2,R4		;Point beyond it			;002
20$:	CLR	-(R4)		;Clear it out				;002
	CMP	R4,(R3)		;Done?					;002
	BHI	20$		;No					;002
	TST	RBCNT		;Any clusters to be allocated at all?	;002
	BEQ	50$		;Exit if none				;002
	MOV	(R3)+,R4	;R4 -> TABLE TO BE FILLED WITH RP'S
	MOV	@(R3)+,R0	;GET PREFERRED STARTING PCN		;002
30$:	CALLX	GETCLU		;ATTEMPT TO GET THIS CLUSTER
	BCC	60$		;CAN'T!?, THIS IS HORRRRRIBLE
	CALLX	RIB2CN		;CONVERT TO A PCN
	BIT	R5,R3		;ON A DIRECTORY CLUSTER BOUNDARY?
	BEQ	40$		;YUP, WE'LL TAKE THIS ONE
	CALLX	RETCLU		;NOPE, RETURN THIS ONE TO THE STORE (SATBUF)
	MOV	R3,R0		;NEXT TIME START LOOKING AT THIS PCN
	INC	R0		; PLUS ONE
	BR	30$		;THEN TRY AGAIN

40$:	MOV	R2,(R4)+	;ADD THE RP TO OUR TABLE
	DEC	RBCNT		;ONE LESS TO DO
	BNE	30$		;IF NOT DONE, THEN CONTINUE
50$:	SEC			;INDICATE HAPPINESS
60$:	CALLX	REGRES,R5	;RESTORE THOSE REGISTERS
	RETURN	R3		;AND RETURN

.DSABL	LSB

;+
; EXTEND - BUILD AND WRITE MAPS FOR 7 DIRECTORY CLUSTERS		;028
;
;	R1 = DIRECTORY CLUSTER SIZE
;
;	CALL	EXTEND,R5,<POINTER TO TABLE OF RP'S,Clusters>		;002
;
;	DESTROYS R0,R1,R3,R4
;-

.ENABL	LSB

EXTEND:	MOV	(R5)+,R0	;R0 -> TABLE OF RP'S FOR DIRECTORY
	MOV	(R5)+,R4	;Get the counts				;002
	TSTB	P.EXT		;Pre-extend?				;002
	BEQ	10$		;No, so we have the right count		;002
	SWAB	R4		;Yes, use the other count		;002
10$:	MOVB	R4,R4		;Isolate the proper count		;002
	BEQ	90$		;None to write, exit quickly		;002
	MOV	R4,CLUCNT	;Save the count				;002
	MOV	R5,-(SP)	;SAVE THE RETURN
	MOV	R1,DIDCS	;SAVE THE DIRECTORY CLUSTER SIZE
	MOV	#SATBUF+1000-20,R4 ;R4 -> FIRST MAP IN CLUSTER
	MOVB	R1,R3		;R3 = NUMBER OF MAPS TO DO		;002
20$:	MOV	R0,R1		;R1 -> TABLE OF RP'S FOR DIRECTORY
	MOV	#7,R2		;R2 = NUMBER OF RP'S IN A MAP
30$:	MOV	DIDCS,(R4)+	;STORE DIRECTORY CLUSTER SIZE IN MAP
40$:	MOV	(R1)+,(R4)+	;ENTER ANOTHER RP IN THE MAP
	SOB	R2,40$		;UNTIL MAP IS FULL
	CMP	R4,#SATBUF+1000	;Did we just fill in block 0?		;002
	BNE	50$		;No					;002
	TST	DIDCS		;Yes, but is this a GFD/MFD?		;002
	BPL	50$		;No					;002
	ADD	#2*1000,R4	;Yes, skip blocks 1 and 2		;002
	SUB	#2, R3		;and remember we skipped them		;006
50$:	ADD	#1000-20,R4	;R4 -> NEXT MAP				;002
	SOB	R3,20$		;UNTIL ALL MAPS ARE FULL
	MOV	CLUCNT,R1	;R1 = NUMBER OF CLUSTER TO BE WRITTEN	;002
60$:	MOV	(R0)+,R2	;R2 IS THE RP FOR THE NEXT CLUSTER
	CALLX	CNVRIB		;CONVERT TO FBN
	CLR	R5		;Lets get rid of sign extends		;028
	BISB	DIDCS,R5	;WRITE ONE CLUSTER OF BLOCKS		;028
	CMPB	R5,#16.		;Large clustersize?			;028
	BLOS	67$		;No, so ok				;028
	MOVB	#16.,R5		;Yes, so write only 16 for now		;028
67$:	CALL	WRITWC		;WRITE WITH WRITE CHECK			;028
	BCS	100$		;COMPLAIN IF WE CAN'T
	MOV	#SATBUF,R4	;R4 -> NAME + ACCOUNT ENTRIES
70$:	CLR	(R4)+		;CLEAR THEM OUT
	CMP	R4,#SATBUF+1000-20 ;ASSUME LESS THAN A BLOCK OF THEM
	BLO	70$		;CONTINUE TILL DONE
80$:	MOV	(R4),1000(R4)	;Make sure block 1 and			;002
	MOV	(R4),2000(R4)	; block 2 clustermaps are set up	;002
	TST	(R4)+		;Pop pointer				;002
	CMP	R4,#SATBUF+1000	;Done?					;002
	BLO	80$		;Not yet				;002
	SOB	R1,60$		;WRITE OUT NEXT CLUSTER
	MOV	(SP)+,R5	;RESTORE RETURN ADDRESS
90$:	RETURN	R5		;THEN GO BACK TO CALLER

100$:	ERF	<"?Disk error during DSKINT build phase">		;005

.DSABL	LSB

.SBTTL	DSKINT DISK STATUS PRINTER

.ENABL	LSB

TYPERR:	REGSCR			;SAVE REGISTERS
	MOV	HDRIDX,-(SP)	;SAVE OUTSTANDING DEVICE REGISTER HEADER
	MOV	HDRUNT,-(SP)	;AND UNIT NUMBER
	TST	D.HDR		;HAS BAD BLOCK HEADER BEEN PRINTED ?
	BMI	10$		;YES, SO DON'T REPEAT IT
	MESSAG	<" Block Cluster"<200>>
	COM	D.HDR		;NOTE WE'VE PRINTED HEADER
10$:	MOV	DCS,R4		;CORRECT FBN TO ACTUAL BLOCK #
	DEC	R4		; BY ADDING IN DCS-1
	ADD	R4,R2		;  TO THE FBN (WHICH ISN'T 0)
	ADC	R3
	CALLX	DBLPRT		;PRINT DOUBLE PRECISION NUMBER
	MESSAG	<"  ">
	SUB	R4,R2		;NOW CORRECT THE
	SBC	R3		; NUMBER BACK AGAIN
	CALLX	SEG2CN		;CONVERT TO A PACK CLUSTER NUMBER
	MOV	R2,R0		;COPY CLUSTER # FOR PRINTING
	CALLX	DECPRT		;PRINT CLUSTER NUMBER IN DECIMAL
	CALLX	TYPECR		;<CR><LF>
	MOV	(SP)+,HDRUNT	;PRETEND WE DIDN'T DISTURB TTY OUTPUT
	MOV	(SP)+,HDRIDX	;SO ERROR LOGS DON'T NEED NEW HEADER
	RETURN

.DSABL	LSB

GLOBAL	<HDRIDX,HDRUNT,SYSNDX,DCS,DSKCSR>

.IF	DF	ONLINE							;033+

CTLFMT:				;Online formatting not supported
CTLINQ:	ERF	<"DSKINT error - Online formatting not allowed">

.IFF

.DSABL	LSB

;+
; CTLINQ - Inquire on controller formatting capabilities
; CTLFMT - FORMAT a drive using controller format command
;
;	CALL	CTLINQ  (or CTLFMT)
;
;	Returns:
;		CTLINQ  - C=1 if drive is NOT formattable
;			  C=0 if drive can be controller formatted
;
;		CTLFMT  - C=0 if successful
;			  C=1 if an error occurred
;
;			For both, actual error encountered is in IOERR
;-
CTLINQ:	CLR	FMTMOD		;Set inquire in the format modifier word
	BR	CMNFMT

CTLFMT:	MOV	#100000,FMTMOD	;Set format function
	TST	D.FRMT		;Are we formatting?
	BNE	CMNFMT		;Yes, so continue
	ERF	<"DSKINT error - attempt to format unformattable disk">

CMNFMT:	CALLX	PARSEX,R5,FMTFUN ;Do the command
FMTMOD:	.WORD	0		;Set by routines for function required
	CMPB	IOERR,#ERRERR	;Can it be done?
	BEQ	20$		;No, so set carry
	TSTB	IOERR		;Any error occurred? (TSTB zeros c-bit)
	BEQ	30$		;No, so everything is ok
	;another error occurred, we will put future tests here
20$:	SEC			;Yes, Indicate failure/not allowed
30$:	RETURN

GLOBAL	<ERRERR>

.ENDC									;033-

.ENABL	LSB


.SBTTL	DUMMY BOOT

	TMPORG	DSIDAT

DUMBOT:	NOP
	RESET			;UGH
	BR	5$		;Go to the real code			;003
									;003
	BOOTID	5$,<>		;Boot ID block, no controllers		;003

	CLR	20$		;COUNT DOWN MEMORY TO DELAY
10$:	DEC	(PC)+		;CHURN
20$:	 .WORD	0
	BNE	10$
	MOV	PC,R0		;GETTA POSITION INDEPENDENT MESSAGE
	ADD	#40$-.,R0	;ADDRESS INTO R0
30$:	TSTB	@#177564	;CONSOLE READY ?
	BPL	30$		;PATIENCE
	MOVB	(R0)+,@#177566	;TALK TO ME
	TSTB	(R0)		;ANY MORE ?
	BNE	30$		;YUP
	HALT			;NOPE
	BR	DUMBOT		;DO IT AGAIN IF HE CONTINUES

.NLIST	BEX
40$:	.ASCIZ	<377><377><7><12>"?PLEASE BOOT FROM THE SYSTEM DISK."<15><12>
	.EVEN
BOTEND:									;002

UNORG

	ORG	DSIDAT

D.FRMT:	.WORD	0	;0=NO FORMATTING -1=FORMAT BEFORE DSKINT
D.BCNT:	.WORD	0	;COUNT OF BAD CLUSTERS
D.HDR:	.WORD	0	;-1 = BAD BLOCK ERROR HEADER HAS BEEN PRINTED
D.ERR:	.WORD	0	;THE COUNT OF ERRORS BEFORE SINGLE BLOCK CHECK

; THE FOLLOWING TWO BYTES MUST BE ADJACENT:

D.SECS:	.BYTE	0	;MAX SECTOR NUMBER ON A TRACK (DB, DR)
D.TRKS:	.BYTE	0	;MAX TRACK NUMBER ON A CYLINDER (DB, DR)

LEVEL1:	.BYTE	0	;LEVEL NUMBER
LEVEL2:	.BYTE	0	;LEVEL NUMBER 
P.RSTS:	.BYTE	0	;<>0 IF DISK NOT RSTS
P.EXT::	.BYTE	0	;<>0 IF DIRECTORY EXTENTION IS DESIRED		;005
D$PREF:	.WORD	0	;PREFERED LOCATION FOR ACCOUNT [1,2]
DIDCS:	.WORD	0	;SCRATCH; CONTAINS CLU SIZE FOR A DIRECTORY
RBCNT:	.WORD	0	;SCRATCH; CONTAINS RP'S LEFT TO DO
CLUCNT:	.WORD	0	;Scratch; contains number of clusters to process ;002
RB.MFD:	.BLKW	7	;RP's for MFD					;002
RB.GF0:	.BLKW	7	;RP's for [0,*] GFD				;002
RB.GF1:	.BLKW	7	;RP's for [1,*] GFD				;002
RB.1.1:	.BLKW	7	;RP'S FOR [1,1]					;002
RB.1.2:	.BLKW	7	;RP'S FOR [1,2]
RB.0.1:	.BLKW	7	;RP'S FOR [0,1]

QUODSK:	.WORD	0	;1.2 (quotas) or 1.1 disk?			;039
D.CYLS:	.WORD	0	;NUMBER OF CYLINDERS OR MAX CYLINDER NUMBER
D.EXTR:	.WORD	0	;NUMBER OF EXTRA BYTES IN HEADER
D.PNDX:	.WORD	0	;INDEX INTO PATTERN TABLE FOR 1ST PATTERN
D.SIZL::.WORD	0	;SIZE OF DISK = MAXIMUM FIP BLOCK NUMBER	;005
D.SIZM::.WORD	0	; (MSB OF ABOVE)				;005
D.ERRD:	.WORD	0	;<>0 IF ERROR TRACK NOT READ YET
D.RTRY:	.WORD	8.	;8 RETRIES ALLOWED
D.PREF:	.WORD	0	;PREFERRED PCN FOR START OF SATT.SYS
D.EVLD:	.WORD	0	;NUMBER OF VALID ERROR RECORDS
D.ERCT:	.WORD	0	;NUMBER OF ERROR RECORDS TO READ
USEBB::	.WORD	0	;<> 0 IF PREVIOUS BADB.SYS TO BE USED		;005
XPAND:	.WORD	0	;NEW PACK CLUSTERS PER OLD PACK CLUSTER
LRGDSK:	.WORD	0	;doing a large disk flag			;028
QUESNM:	.WORD	0	;question number to GETCL			;031
NUPATS::.WORD	0	;NUMBER OF USER-DEFINED PATTERNS
NSPATS::.WORD	0	;Number of system-defined patterns		;005
WRONLY::.WORD	0	;Zero if writing only, non-zero if checking	;005
C.FRMT:	.WORD	0	;Controller formatting command available if -1	;033
FLOPPY:	.WORD	0	;Floppy-sized disk is being DSKINTed		;035
SECRTY::.WORD	0	;ZERO IF ERASING
MFDCLU:	.WORD	0	;MFD/GFD clustersize				;005
SYSFLG:	.WORD	0	;FLAG SET IF IT'S A SYSTEM DISK
NODEF:	.WORD	0	; cell for deciding defaults			;007
ERRHDR:	.WORD	0	;=0 IF ERROR HEADER NOT PRINTED YET
PATUSR:	.BLKW0	8.	;TABLE OF USER PATTERNS
PATTBL:	.WORD	155555	;Three word pattern				;005
	.WORD	133333							;005
	.WORD	066666							;005
	.WORD	155555	;Once more so we can start at PATTBL+2,+4	;005
	.WORD	133333							;005

D.BFSZ	=	16.	;BAD BLOCK CHECKING WILL USE 16 BLOCK XFERS

GFDCLU:	.WORD	16.	;Clustersize for MFD and GFD			;002
ZERO:	.WORD	0	;A zero to indicate no preferred position	;002

.SBTTL	DSKINT label data

	ORG	DSIMU

; Pack, MFD, UFD labels							;002

PAKLBL:	.WORD	0		;No link				;002
	.WORD	-1		;Reserved				;002
MFDDCN:	.BLKW			;MFD starting DCN			;002
REVLVL:	.BYTE	2,1		;Revision level				;002
PACKCL:	.WORD	0		;PACK CLUSTER SIZE
PACKST::.WORD	0		;CLEAN,PUBLIC/PRIVATE BITS		;005
PACKID::.WORD	0,0		;PACK ID IN RAD50			;005
LBLEND:									;002

STAMFD:	.WORD	0		;No link				;002
	.WORD	-1		;Mark as in use				;002
	.BLKW0	4		;Reserved				;002
	.WORD	255.*400+255.	;MFD = [*,*]				;002
	.RAD50	"MFD"							;002
ENDMFD:									;002

UFD1.1:	.WORD	0		;No link to next			;002
	.WORD	-1		;Mark as in use				;002
	.BLKW0	4		;Reserved				;002
	.WORD	1*400+1		;PPN = [1,1]				;002
	.RAD50	"UFD"							;002
END1.1:									;002

UFD1.2:	.WORD	0		;No link to next			;002
	.WORD	-1		;Mark as in use				;002
	.BLKW0	4		;Reserved				;002
	.WORD	1*400+2		;PPN = [1,2]				;002
	.RAD50	"UFD"							;002
END1.2:									;002

.SBTTL	DSKINT GFD data

GFD0:	.WORD	0		;No link to next			;002
	.WORD	-1		;Mark as in use				;002
	.BLKW0	4		;Reserved				;002
	.WORD	0*400+377	;PPN = [0,*]				;002
	.RAD50	"GFD"							;002

; MFD NAME BLOCK FOR [0,1] ACCOUNT
NE.0.1:	.WORD	AD.0.1-GFD0	;Link to date/time block		;012
	.WORD	0*400+1		;PPN = [0,1]
	.WORD	0,0		;Reserved				;002
	.BYTE	US.UFD!US.NOK,074 ;STATUS, PROTECTION			;002
	.WORD	0		;ACCESS COUNT
	.WORD	AE.0.1-GFD0	;LINK TO [0,1] ACCOUNT ENTRY
RP.0.1:	.WORD	0		;RP TO FIRST BLOCK OF [0,1] UFD

; MFD ACCOUNT ENTRY FOR ACCOUNT [0,1]
AE.0.1:	.WORD	1		;+1 = IN USE
	.BLKW0	6		;CPU,CONNECT,KC TICKS,DEV TIME,MSB'S,BLOCK LIMIT
CL.0.1:	.WORD	0		;UFD CLUSTER SIZE FOR [0,1]

AD.0.1:	.WORD	0		;No link to next			;012
	.BYTE	AA.DAT,0	;Date/time info; no last KB		;012
	.BLKW0	3		;No last login; no password date	;012
	.WORD	AT.NLK		;Always hashed password			;012
AC.0.1:	.BLKW			;Creation date				;012
	.WORD	-1		;Expiration (never)			;012
END0:									;002

GFD1:	.WORD	0		;No link to next			;002
	.WORD	-1		;Mark as in use				;002
	.BLKW	4		;Reserved				;002
	.WORD	1*400+377	;PPN = [1,*]				;002
	.RAD50	"GFD"							;002

; Name entry for account [1,1]						;002

NE.1.1:	.WORD	AQ.1.1-GFD1	;Link to account attribute		;002
PP.1.1:	.WORD	1*400+1		;PPN = [1,1]				;002
	.WORD	0,0		;Reserved				;002
	.BYTE	US.UFD!US.NOK,074 ;STATUS, PROTECTION			;002
	.WORD	0		;ACCESS COUNT
	.WORD	AE.1.1-GFD1	;LINK TO ACCOUNT ENTRY
RP.1.1:	.BLKW			;RP TO FIRST BLOCK OF [1,1] UFD		;002

; [1,1] ACCOUNT BLOCK
AE.1.1:	.WORD	1		;+1 = IN USE
	.BLKW0	6		;CPU,CONNECT TIME,KC TICKS,DEV TIME,MSB'S,BLK LIMIT
CL.1.1:	.WORD	0		;MFD CLUSTER SIZE

AQ.1.1:	.WORD	AD.1.1-GFD1	;Link to date/time block		;016
	.BYTE	AA.QUO		;quota attribute blockette		;002
	.BYTE	-1		;Detached job quota = infinite		;012
	.WORD	-1		;Logged out quota = infinite		;012
	.WORD	-1		;Logged in quota = infinite		;012
	.BYTE	-1,-1		;High orders are infinite too		;012
	.BYTE	0,0		;Zero reserve, zero current MSB		;012
	.WORD	0		;Zero reserve quota			;012
	.WORD	0		;Zero current usage			;012

AD.1.1:	.WORD	A2.1.1-GFD1	;Link to second quota block		;016
	.BYTE	AA.DAT,0	;Date/time info; no last KB		;012
	.BLKW0	3		;No last login; no password date	;012
	.WORD	AT.NLK		;Default to hashed passwords		;016
AC.1.1:	.BLKW			;Creation date				;012
	.WORD	-1		;Expiration (never)			;012

A2.1.1:	.WORD	AN.1.1-GFD1	;Link to password block			;016
	.BYTE	AA.QT2		;Second quota block			;012
	.BYTE	-1		;Job quota = infinite			;012
	.WORD	-1		;RIB quota = infinite			;012
	.WORD	-1		;Message quota = infinite		;012
	.BLKW0	4		;Rest reserved				;012

AN.1.1:	.WORD	AP.1.1-GFD1	;Link to password block			;039
	.BYTE	AA.NAM		;Account name block			;039
	.ASCII	/[ 1, 1]/	; the name to use			;039
	.BLKB0	6		; and the rest of the space		;039

AP.1.1:	.WORD	0		;No link to next			;012
	.BYTE	AA.PAS,'?	;Unusable password			;021
	.BLKW0	6		;Space for real password		;016

; MFD NAME BLOCK FOR ACCOUNT [1,2] (LIBRARY)
NE.1.2:	.WORD	AQ.1.2-GFD1	;Link to attributes (quota info)	;012
PP.1.2:	.WORD	1*400+2		;PPN = [1,2] = SYSTEM LIBRARY
	.WORD	0,0		;Reserved				;002
	.BYTE	US.UFD!US.NOK,074 ;STATUS, PROTECTION			;002
	.WORD	0		;ACCESS COUNT
	.WORD	AE.1.2-GFD1	;LINK TO ACCOUNT ENTRY			;002
RP.1.2:	.WORD	0		;RP TO FIRST BLOCK OF [1,2] UFD

; MFD ACCOUNT ENTRY FOR ACCOUNT [1,2] (LIBRARY)
AE.1.2:	.WORD	1		;+1 = IN USE
	.BLKW0	6		;CPU,CONNECT,KC TICKS,DEV TIME,MSB'S,BLOCK LIMIT
CL.1.2:	.WORD	0		;LIBRARY UFD CLUSTER SIZE

AQ.1.2:	.WORD	AD.1.2-GFD1	;Link to date/time block		;012
	.BYTE	AA.QUO		;quota attribute blockette		;002
	.BYTE	-1		;Detached job quota = infinite		;012
	.WORD	-1		;Logged out quota = infinite		;012
	.WORD	-1		;Logged in quota = infinite		;012
	.BYTE	-1,-1		;High orders are infinite too		;012
	.BYTE	0,0		;Zero reserve, zero current MSB		;012
	.WORD	0		;Zero reserve quota			;012
	.WORD	0		;Zero current usage			;012

AD.1.2:	.WORD	A2.1.2-GFD1	;Link to second quota block		;016
	.BYTE	AA.DAT,0	;Date/time info; no last KB		;012
	.BLKW0	3		;No last login; no password date	;012
	.WORD	AT.NLK		;Default to hashed passwords		;016
AC.1.2:	.BLKW			;Creation date				;012
	.WORD	-1		;Expiration (never)			;012

A2.1.2:	.WORD	AN.1.2-GFD1	;Link to account name block		;016
	.BYTE	AA.QT2		;Second quota block			;012
	.BYTE	-1		;Job quota = infinite			;012
	.WORD	-1		;RIB quota = infinite			;012
	.WORD	-1		;Message quota = infinite		;012
	.BLKW0	4		;Rest reserved				;012

AN.1.2:	.WORD	AP.1.2-GFD1	;Link to password block			;039
	.BYTE	AA.NAM		;Account name block			;039
	.ASCII	/[ 1, 2]/	; the name to use			;039
	.BLKB0	6		; and the rest of the space		;039

AP.1.2:	.WORD	AV.1.2-GFD1	;Link to privilege block		;016
	.BYTE	AA.PAS,'?	;Unusable password			;021
	.BLKW0	6		;Space for real password		;016

AV.1.2:	.WORD	0		;No link to next			;016
	.BYTE	AA.PRV,0	;Type, filler				;016
	.WORD	..PRW0,..PRW1	;All privileges				;016
	.WORD	..PRW2,..PRW3						;016
	.WORD	0,0		;Reserved				;016

END1:

.SBTTL	DSKINT [0,1] UFD PARAMETERS

; UFD DUMMY ENTRY
UFD0.1:	.WORD	NE.BAD-UFD0.1	;LINK TO 1ST NAME ENTRY
	.WORD	-1,0,0,0,0	;DUMMY ENTRIES
	.WORD	0*400+1,^RUFD	;UFD PPN AND FLAG WORD

; UFD NAME ENTRY FOR [0,1]BADB.SYS
NE.BAD:	.WORD	NE.SAT-UFD0.1	;LINK TO NEXT NAME ENTRY
	.RAD50	"BADB  SYS"	;FILE NAME IN RAD50
	.BYTE	US.NOK,077	;STATUS,PROTECTION			;002
	.WORD	0		;ACCESS COUNT
	.WORD	AE.BAD-UFD0.1	;LINK TO ACCOUNT ENTRY
RL.BAD:	.WORD	0		;LINK TO RETRIEVAL ENTRY

; UFD ACCOUNT ENTRY FOR [0,1]BADB.SYS
AE.BAD:	.WORD	1		;+1 = IN USE
AD.BAD:	.WORD	0		;DATE OF LAST ACCESS
SZ.BAD:	.WORD	0		;BADB.SYS FILE LENGTH IN BLOCKS
CD.BAD:	.WORD	0		;DATE OF CREATION
CT.BAD:	.WORD	0		;TIME OF CREATION
	.RAD50	" RSTS "	;CREATOR IS THE SYSTEM
CL.BAD:	.WORD	0		;BADB.SYS CLUSTER SIZE=PACK CLUSTER SIZE

; UFD NAME ENTRY FOR [0,1]SATT.SYS
NE.SAT:	.WORD	0		;LINK TO NEXT NAME ENTRY
	.RAD50	"SATT  SYS"	;FILE NAME SATT.SYS
	.BYTE	US.NOK!US.NOX,077 ;STATUS, PROTECTION			;002
	.WORD	0		;ACCESS COUNT
	.WORD	AE.SAT-UFD0.1	;LINK TO ACCOUNT ENTRY
	.WORD	RE.SAT-UFD0.1	;LINK TO RETRIEVAL ENTRY

; UFD ACCOUNT ENTRY FOR [0,1]SATT.SYS
AE.SAT:	.WORD	1		;+1 = IN USE
AD.SAT:	.WORD	0		;DATE OF LAST ACCESS
SZ.SAT:	.WORD	0		;SATT.SYS FILE LENGTH IN BLOCKS
CD.SAT:	.WORD	0		;DATE OF CREATION
CT.SAT:	.WORD	0		;TIME OF CREATION
	.RAD50	" RSTS "	;CREATOR IS THE SYSTEM
CL.SAT:	.WORD	0		;SAT CLUSTER SIZE = PACK CLUSTER SIZE

; MAX SIZE OF SATT = 16. BLOCKS, SO SATT MAY REQUIRE 16/7 R.E.'S,
;	OR 3 RETRIEVAL ENTRIES, BUT NEVER MORE THAN THAT
RE.SAT:	.BLKW	8.*3		;AREA FOR UP TO 3 R.E.'S FOR SATT.SYS
RE.BAD:	.BLKB	<1000-20>-<RE.BAD-UFD0.1> ;AREA FOR BADB.SYS R.E.'S

END0.1:

; WE WANT ALL BADB.SYS RETRIEVAL ENTRIES TO FIT INTO BLOCK 0 OF THE UFD
; SINCE THE LAST UFD ENTRY IS THE FDCM, AND THERE ARE 7 RP'S PER
; RE, WE COMPUTE THE MAXIMUM NUMBER OF BAD BLOCKS ALLOWED:
D.BMAX:	.WORD	<1000-20>-<RE.BAD-UFD0.1>/20*7

ENDOVL	<DSI,DSIDAT,DSITXT,DSIMU>,200 ;ENOUGH PATCH SPACE FOR DSI & COP

.END
