	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
	.INCLUDE /INIT:INIPFX/
TITLE	FIP,<RSTS/E INIT - MINI FIP>,0A,10-MAY-91,ABC/MND/GPK/WJS/JDB/PJH

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;


.SBTTL	EDIT HISTORY FOR INIFIP

;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;  001	MND  14-APR-81	FIX DSQMAL UPDATE BY FIP READS WITH RL01 DISKS
;
;				[RSTS V8.0]
;  000	GPK  12-Jul-82	Changes for callable bootstraps
;  001	GPK  17-Sep-82	Changes for new disk structure
;
;				[RSTS V9.0]
;  000	WJS  09-Sep-83	Changes for LTDS
;  007  JDB  28-Aug-84  Fix SAVRES DV0: bug
;
;				[RSTS V9.4]
;  008	GPK  25-Sep-86	Split into INIFIP and INIFIM
;
;				[RSTS V9.6]
;  009	PJH  18-Feb-88	Add MSCP Format support to PARSEX
;  010	PJH  09-May-88  Fix I/O routine contiguous block check
;
;-


.SBTTL	FIP MACROS AND PARAMETERS

GLOBAL	<FIBUF,FIBENT,FIBMAP,SATBUF>	;FREQUENTLY USED GLOBALS

.MACRO	I.MESS
	TMPORG	FIPTXT
.NLIST	BEX
.ENDM	I.MESS

	DEFORG	FIP		;CODE FOR FIP


.SBTTL	FIND DCS (GETDVC)
;+
; GETDVC - GET DEVICE CLUSTER SIZE FOR DISK AND UNIT
;
; CALL:	CALL	GETDVC,R5
;	+	ADDRESS OF WORD CONTAINING DISK TYPE INDEX
;	+	ADDRESS OF BYTE CONTAINING UNIT NUMBER
;	+	ADDRESS OF WORD TO PUT THE RESULTING DCS
;
; BACK:	DCS SET IN THIRD ARGUMENT
;	THE DEVICE CLUSTER SIZE IS LOCATED IN THE DCS TABLES IN FIP
;-
GETDVC::MOV	R0,-(SP)	;SAVE R0
	MOV	@(R5)+,R0	;GET DISK INDEX
	MOV	DSKDCS(R0),R0	;R0 -> TABLE OF CLUSTER SIZES FOR UNITS
	CLR	-(SP)		;CLEAR WORD FOR UNIT NUMBER
	MOVB	@(R5)+,(SP)	;GET UNIT NUMBER
	ASL	(SP)		; * 2
	ADD	(SP)+,R0	;R0 -> CLUSTER SIZE FOR SPECIFIED UNIT
	MOV	(R0),@(R5)+	;AND SET THE REAL DCS
	MOV	(SP)+,R0	;RESTORE R0
	RETURN	R5

GLOBAL	<DSKDCS>


.SBTTL	FILE STRUCTURED READ/WRITE ROUTINES (READ. AND WRITE.)
;+
; READ. - READ FROM A FILE
; READ.X - READ FROM A FILE INTO EXTENDED MEMORY
; WRITE. - WRITE TO A FILE (NO EXTEND)
;
; CALL:	R0 = WORD COUNT TO DO (NEED NOT BE A BLOCK MULTIPLE)
;	R1 -> FILE'S FCB
;	FCNVB(R1) = FIRST BLOCK TO DO (FIRST BLOCK OF A FILE IS #0)
;	IF READ.X, FILDSQ+DSQMAM = MSB OF MEMORY ADDRESS
;	CALL	READ.,R5	(OR CALL WRITE.,R5)
;	+	BUFFER
;
; BACK:	C=0	'TIS DONE
;	C=1	ATTEMPT TO TRANSFER PAST EOF (PARTIAL I/O NOT DONE)
;-
.ENABL	LSB

READ.B::MOV	#256.,R0	;SET TO READ 1 BLOCK
READ.::	CLRB	FILDSQ+DSQMAM	;CLEAR OUT EXTENDED ADDRESS
READ.X::MOV	#RFUN,FILDSQ+DSQFUN ;SET READ FUNCTION IN DSQ
	BR	10$		;AND MERGE

WRIT.B::MOV	#256.,R0	;SET TO WRITE 1 BLOCK
WRITE.::CLRB	FILDSQ+DSQMAM	;CLEAR OUT EXTENDED ADDRESS
WRIT.X::MOV	#WFUN,FILDSQ+DSQFUN ;SET WRITE FUNCTION IN DSQ
10$:	MOV	(R5)+,FILDSQ+DSQMAL ;POP R5, SET MEMORY ADDR IN DSQ
	REGSAV			;SAVE ALL [EGS
	BIT	#FS.OPN,FQSTAT-FQFCB(R1) ;IS THE FILE OPEN?
	BEQ	70$		;NO (WE SHOULDN'T BE HERE)
	MOV	#FILDSQ,R4	;POINT TO DSQ FOR TRANSFER
	MOV	R0,DSQTOT(R4)	;SET TOTAL WORD COUNT OF TRANSFER
	MOVB	DDIDX(R1),DSQJOB(R4) ;SET UP DISK TYPE INDEX
	MOVB	DDUNT(R1),DSQPUN(R4) ;AND UNIT NUMBER OF DISK
	ADD	#377,R0		;ROUND WORD COUNT UP TO BLOCK COUNT
	CLRB	R0		;AND MAKE IT A BLOCK COUNT
	SWAB	R0
	ADD	FCNVB(R1),R0	;ADD START BLOCK OF TRANSFER
	BCS	60$		;CAN'T READ PAST BLOCK # 65535
	CMP	FCSIZ(R1),R0	;TOO FAR?
	BLO	60$		;YES, PAST EOF ERROR

GLOBAL	<FILDSQ>


20$:	CALLX	VBNFBN		;GET FBN IN R2/R3 (TURN WINDOW IF NEEDED)
	CLR	DSQCNT(R4)	;NO BLOCKS IN COUNT YET
	MOV	R2,DSQFBL(R4)	;SET UP DISK ADDRESS TO START TRANSFER
	MOVB	R3,DSQFBM(R4)
30$:	INC	FCNVB(R1)	;BUMP TO NEXT BLOCK NUMBER IN FCB
	ADD	#400,DSQCNT(R4)	;ADD IN ONE MORE BLOCK TO TRANSFER
	SUB	#400,DSQTOT(R4)	;AND 256. FEWER WORDS TO DO
	BLOS	50$		;DONE WITH TRANSFER, GO DO FINAL I/O
	CALLX	VBNFBN		;GET FBN OF NEXT BLOCK OF XFER IN R2/R3
	SUB	DSQFBL(R4),R2	;GET DIFFERENCE OF BLOCK FROM START OF XFER
	SBC	R3
	CMPB	R3,DSQFBM(R4)	;BETTER HAVE THE SAME HIGH PART OF ADDRESS
	BNE	40$		;NON-CONTIGUOUS, SO DO A PARTIAL READ
	CLR	R3		;Get a clean register			    ;010
	BISB	DSQCNT+1(R4),R3	;Get block being done value, w/o sign extnd ;010
	CMP	R2,R3		;Are they contiquous from start of xfer?    ;010
	BEQ	30$		;YES, MERGE READ INTO A BIGGER ONE
40$:	MOV	DSQCNT(R4),R3	;AND REMEMBER TOTAL XFER SO FAR
	CALLX	DISK		;WELL, DO THE I/O
	CMPB	(R1),#IDX$DL	;IF WE'RE USING RL'S........
	BNE	45$		;NO,  SO USE PREVIOUS DSQCNT TO UPDATE DSQMAL.
	MOV	DSQCNT(R4),R3	;     THEN RL DRIVER MAY HAVE UPDATED DSQMAL,
	NEG	R3		; SO GET THE CURRENT WORD COUNT AND NEGATE IT.
45$:	ASL	R3		;BYTE COUNT JUST DONE
	ADD	R3,DSQMAL(R4)	;BUMP MEMORY ADDRESS
	ADCB	DSQMAM(R4)	;CARRY ON
	BR	20$		;START A NEW XFER

50$:	ADD	DSQTOT(R4),DSQCNT(R4) ;ADJUST IF LAST BLOCK IS PARTIAL
	CALLX	DISK		;DO THE I/O
60$:	CALLX	REGRES,R5	;RESTORE REGS
	RETURN	R5

70$:	ERF	<"I/O to unopened file">

.DSABL	LSB


.SBTTL	LOOKUP A FILE ON THE SCRATCH FIRQB

;+
; LOK5.. - LOOKUP A FILE USING FIRQB FQ..., FILE NAME FOLLOWS CALL
; LOKN.. - LOOKUP A FILE USING FIRQB FQ..., R5 -> FILE NAME
;
; CALL:
;	CALL	LOK5..
;	 .RAD50	/FILNAMEXT/	;3 WORDS OF RAD50 CONTAINING NAME
;   OR
;	R5 -> FILE NAME/EXT (3 WORDS OF RAD50)
;	CALL	LOKN..
;
; BACK:	(SEE LOKFIL)
;-

LOK5..::MOV	#RTSR5,-(SP)	;RETURN TO AN RTS R5
LOKN..::MOV	#FQ...+FQNAM1,R4 ;POINT TO AREA FOR NAME
	MOV	(R5)+,(R4)+	;MOVE IN THE NAME
	MOV	(R5)+,(R4)+
	MOV	(R5)+,(R4)+
	CALLRX	LOK...		; and call the looker-upper		;008

GLOBAL	<RTSR5,FQ...>							;008


.SBTTL	Get FBN from file VBN, turning windows if needed

;+
; FILIX - Convert VBN to FBN or indicate window turn needed
;
; Call:	R1 -> FCB with VBN in FCB @ FCNVB
;	CALL	FILIX,R5
;
; Back:	R0 destroyed
;	If window in memory is ok, R2/R3 = FBN
; 		and return at call+4
; 	If window turn needed, return at call+2
;-

FILIX::	MOV	R1,R0		; Copy FCB pointer			;008
	ADD	#FCNVB,R0	; Point to next logical block (VBN to do)
	MOV	(R0)+,R2	; Block number to R2
	SUB	(R0)+,R2	; Compute FCNVB-FCFVB = block # rel window
	BLO	50$		; Too far down, must turn window
	BITB	#US.NOX,DDSTS(R1) ; Is the file contiguous?
	BEQ	10$		; No, we have to work
	MOV	R2,R0		; Yes, R0 = relative block within file
	CLR	R2		; Use the first window entry
	BR	40$		; Go do it

10$:	CLR	R3		; Clear register to get
	BISB	(R0),R3		;  clustersize-1
	MOV	R2,R0		; Remember block # rel window
	COM	R3		; Make clustersize a mask
	BIC	R3,R0		; R0 = block within cluster
20$:	ASR	R3		; Divide block # by clustersize
	BCS	30$
	;CLC			; No sign extend
	ROR	R2
	BR	20$

30$:	CMP	R2,#6		; R2 = window # relative to in-core
	BHI	50$		; Only 7 r.p.'s in core, sorry
	ASL	R2		; R2 = offset in window of rp
40$:	ADD	R1,R2		; Add in FCB pointer
	MOV	FCWND+2(R2),R2	; Get proper retrieval pointer
	MOVB	(R1),R3		; R3 = DDIDX(R1) = disk index
	MOV	DSKDCS(R3),-(SP) ; Save pointer to DCS table for type
	MOVB	DDUNT(R1),R3	; R3 = disk unit number (0-7)
	ASL	R3		; Make it a word offset
	ADD	(SP)+,R3	; R3 -> DCS for this disk
	MOV	(R3),R3		; R3 = DCS to compute with
	CALLX	CNVRB2		; convert r.p. in R2 to a FBN		;008
	ADD	R0,R2		; Add in block number within clu
	ADC	R3
	TST	(R5)+		; Advance to good return
50$:	RETURN	R5		; Return happy

GLOBAL	<DSKDCS>


.SBTTL	FIP INTERNAL I/O ROUTINE
;+
; PARSEX - DO READ OR WRITE FOR FIP
;
; CALL:	R2/R3 = FIP BLOCK NUMBER OF BLOCK TO DO
;	I.DSQ+DSQCNT = NUMBER OF WORDS TO TRANSFER
;	CALL	PARSEX,R5
;	+	FUNCTION CODE (RFUN OR WFUN or FMTFUN)		;009
;	+	BUFFER ADDRESS (FMTFUN, Modifier to set in DSQ)	;009
;
; NOTE: IF BACKUP IS SET THEN HIGHBF IS USED AS THE HIGH BYTE OF THE ADDRESS
;
; BACK:	'TIS DONE
;	I.DSQ+DSQCNT RESET TO 256.
;-
PARSEX::MOV	R4,-(SP)	;SAVE THE CALLER'S R4 FOR HIM
	MOV	#I.DSQ+DSQFUN,R4 ;SET POINTER TO DSQ @ DSQFUN
	MOV	(R5)+,(R4)	;SET THE SUPPLIED FUNCTION
	CMP	#FMTFUN,(R4)	;Was the function FMTFUN?		;009
	BNE	5$		;No, so do the normal			;009
	MOV 	(R5)+,R2	;Set formatting modifier into R2	;009
	CLR	R3		;And set MSB of it to zero		;009
	CMP	-(R4),-(R4)	;Skip count and buffer address		;009
	BR	10$		;And skip the rest of the stuff		;009
	
5$:	TST	-(R4)		;SKIP THE COUNT
	MOV	(R5)+,-(R4)	;SET THE SUPPLIED BUFFER ADDRESS
	TSTB	BACKUP		;ARE WE DOING A SAV/RESTORE?
	BEQ	10$		;NO, CAN'T USE EXTENDED MEMORY
	TSTB	HIGHBF		;IS HE GOING TO HIGH CORE?
	BEQ	10$		;NO, DON'T USE HIGH CORE THEN.
	ADD	IOBF1$,(R4)	;SAV/RES PASSES OFFSET INTO IOBUF	;000
	MOVB	HIGHBF,-(R4)	;SET HIGH BYTE OF BUFFER
	CLRB	-(R4)		;AND RH FUNCTION
	BR	20$		;CONTINUE WITH SUPPLIED BLOCK

10$:	CLR	-(R4)		;CLEAR EXTENDED ADDRESS AND RH FUNCTION
20$:	MOV	R2,-(R4)	;Set blk num (LSB) or Format Modifier	;009
	MOVB	R3,-(R4)	;Set ext addr(MSB) or zero if FMTFUN	;009
	CLRB	-(R4)		;SKIP UNIT
	CMP	-(R4),-(R4)	;SKIP 2 WORDS
	MOVB	SYSNDX,(R4)	;SET UP SYSTEM DISK INDEX
	CLR	-(R4)		;AND CLEAR THE QUEUE LINK WORD
	MOVB	SYSUNT,DSQPUN(R4) ;SET UP SYSTEM DISK UNIT NUMBER
	CALLX	DISK		;NOW START THE OPERATION
	MOV	#256.,I.DSQ+DSQCNT ;NEXT TIME WE WILL DO 256. WORDS
	MOV	(SP)+,R4	;RESTORE R4
	RETURN	R5		;RETURN NORMALLY

.SBTTL	SAME AS PARSEX ONLY SEXIER

SEXPAR::JMP	PARSEX		;SEE I WASN'T KIDDING!

GLOBAL	<I.DSQ,SYSNDX,SYSUNT,BACKUP,HIGHBF,IOBF1$>			;008

.END	
