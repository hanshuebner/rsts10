.INCLUDE /CMN:COMMON/							;024
.INCLUDE /CMN:KERNEL/							;024
.INCLUDE /INIT:INIPFX/							;024
.INCLUDE /INIT:DSKDEF/							;024
TITLE	HARDWR,<RSTS/E INIT - HARDWR OPTION>,0J,27-MAR-92,WBN/RVR/MND/SRM/GPK/JHC/TPT/DBM/VAM/PJH/KPH/DSD

;
;		COPYRIGHT (c) 1974, 1992 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR INIHAR

;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-08
;  001	RVR  31-AUG-80	Fixed bug in CSR validation
;  002	MND  16-Feb-81	Added DMP/DMV support
;  003	MND  26-May-81	Removed text referencing the "RP07"
;  004  SRM  13-Aug-81  Add test for hardware I & D spaces in LIST.
;  005  MND  08-Nov-81  Corrected bug in 002
;  006  MND  13-Nov-81  Source corrected V7.0 1.1.20
;
;				[RSTS V7.2]
;  000	MND  22-Mar-82	CREATION - COPIED FROM V7.1-11
;  001	MND  22-Mar-82	Added support for MSCP disks - UDA50/RA80
;
;				[RSTS V8.0]
;  000	GPK  21-Jun-82	Reinstated RM80; device packet layout changes
;  001	GPK  06-Jul-82	Changes to RU: unit type display
;  002  JHC  04-Jan-82  Repair maximum units bug in UNITS suboption.
;  003  JHC  04-Jan-82	Source clear patch 1.1.15(V7.2)  on UNITS getting
;			RM80 when user specifies RM05.
;  004	FEK  26-Jul-83	Correct TULIST information
;  005	MND  01-Nov-83	Added Virtual Disk (DV:) support
;
;				[RSTS V9.0]
;  001	TPT  11-Nov-83	Merged V8.0-07 changes
;  002	FEK  02-JAN-84	ADD UNA SUPPORT
;  003	DBM  17-Jan-84	Add VT200 support (No <LF> key)
;  004	DBM  13-Feb-84	Add TSLIST routine and MSDTBL
;  005	DBM  01-May-84	Add TK25 to controller list
;  006	DBM  10-Jun-84	Add extended features enabled flag to TSLIST
;			(TK25 and TS05 only)
;  007	FEK  31-Jan-84	Add FPA display for F11 CPU's
;  008	FEK  26-Feb-85	Add RX, DZ, and VH comment information
;  009  VAM  06-Mar-85	Fix GETDV checking of RV controller name.
;
;				[RSTS V9.1]
;  010	DBM  03-Feb-85	TMSCP support
;  011	MND  03-Jul-85	Add programmable vector indicator to HA LIST
;  012  VAM  31-Jul-85	Remove TU58 from device list.
;			Also, correct spelling of 'Ethernet'.
;  013  VAM  19-Aug-85	Add RQDX3 to hardware list.
;  014	FEK  12-Sep-85	Make VECTOR only allow CR & CD
;  015  VAM  13-Sep-85	Don't let RV or DD show up as valid controllers.
;
;				[RSTS V9.2]
;  016	FEK  20-Oct-85	Add XM & KL list routines, change RK05 list, remove
;			  UNITS except for RS/RK, and up width from 72 to 80.
;
;				[RSTS V9.3]
;  017	DBM  24-Mar-86	Ethernet support (XE and XH list routines)
;  018	FEK  05-Mar-86	Add 11/53 (KDJ11-D) RP02/3,RX01/2 to hardware list
;  019	DBM  28-Oct-86	[T]MSCP controller model table work
;
;				[RSTS V9.4]
;  020	FEK  30-Dec-86	Changes to XM list routine for DMR devices
;			  Add XD list routine
;  021	PJH  11-Feb-87	Add GPK/Init changes from GPK
;  022  WRM  12-Mar-87  DMR/DMC/DMP list process table driven
;  023  WRM  12-May-87  Fix problems in process table
;
;				[RSTS V9.6]
;  024  KPH  13-Oct-87	Add .INCLUDEs
;			Change sense of TYPTBL bit for small DZ and VH
;			interfaces
;  025  VAM  02-Feb-88	Add ECO option.
;
;				[RSTS V10.0]
;  026	DSD  07-Jun-89	Don't allow Async DDCMP driver to be changed
;  027	FEK  13-Jul-89	Add KFQSA (+patch space) to tables
;  028  VAM  21-May-90	Add DDNULL option (enable/disable J-11 idle lights)
;
;				[RSTS V10.1]
;  029	FEK  16-Apr-91	Add more MSCP controllers and XALIST
;  030  VAM  08-Aug-91	Say "Unknown" instead of "Offline" for [T]MSCP
;			units that return no encoded name.
;  031	FEK  16-Sep-91	Add more MSCP names
;-


.SBTTL	MACROS FOR HARDWR

.MACRO	I.MESS
	TMPORG	HARTXT
.NLIST	BEX
.ENDM	I.MESS

.MACRO	OPTION	N1,N2
.SBTTL	N1'N2 SUBOPTION
	TMPORG	HAROPT
	 .WORD	HAR'N1'N2
	TMPORG	HAROTX
	 UNQTXT	<N1\N2>
	UNORG
.LIST
HAR'N1'N2:
.NLIST
.ENDM	OPTION

.SBTTL	ORDER THE CSECTS

	DEFORG	HAR
	DEFORG	HARCTL
	DEFORG	HAROPT
	DEFORG	HAROTX
	DEFORG	HARTXT
	ORG	HAR


.SBTTL	HARDWR OPTION DRIVER

.ENABL	LSB

HARDWR::NOP                     ;for debugging                             ;022
        MOV     R1,PRESET       ;SET POINTER TO PRESET ANSWER              ;022
	TSTB	(R1)		;IS THERE A SUBOPTION THERE?
	BNE	10$		;YES, USE IT
	CLR	PRESET		;NO PRESET ANSWER
10$:	MOV	#SETNEW,R0	;R0 -> OUR NEW TABLE
	MOV	#SETTBL,R1	;R1 -> SOURCE FOR IT
	MOV	#VECTBL,R3	;R3 -> CURRENT VECTOR TABLE
	MOV	R3,R2		;COMPUTE TABLE LENGTH IN R2
	SUB	#CSRTBL,R2
	CMP	R2,#VECNEW-SETNEW ;IS OUR LOCAL TABLE BIG ENOUGH?
	BLOS	20$		;YES
	ERF	<"INIT bug - SETNEW table too small">

20$:	CLC			;COMPUTE LENGTH OF TABLE
	ROR	R2		;IN WORDS
	MOV	R2,SETSIZ	;SAVE IT
30$:	MOV	(R3)+,VECNEW-SETNEW(R0) ;COPY OLD VECTORS
	MOV	(R1)+,(R0)+	;COPY TO OUR TABLE
	SOB	R2,30$
	MOV	#UMIDST,R1	;COPY USER-SET MASSBUS ID'S
	MOV	#UMIDEN,R2
	SUB	R1,R2		;R2 = LENGTH OF TABLE IN ROOT
	CMP	R2,#DMTTBL-MIDNEW ;OUR TABLE SHOULD BE THE SAME LENGTH
	BEQ	40$		;YES -- THAT'S DANDY
	ERF	<"INIT bug - MIDNEW table wrong size">

40$:	ASR	R2		;R2 = NUMBER OF WORDS OF UMID'S
	MOV	#MIDNEW,R0	;R0 -> OUR COPY OF TABLE
50$:	MOV	(R1)+,(R0)+	;SET UP OUR COPY
	SOB	R2,50$
	MOV	#16.,R2		;COPY THE DM11BB TABLE, 16 WORDS
	MOV	#TYPTBL,R1	;FROM TYPTBL IN THE ROOT
	ADD	#DM.CSO,R1	; AT OFFSET FOR DM
	MOV	#DMTTBL,R0	;TO THE DM TYPE TABLE LOCALLY
70$:	MOV	(R1)+,(R0)+
	SOB	R2,70$
	MOV	LINFRQ,NEWFRQ	;COPY THE AC LINE FREQUENCY
	MOV	SWTREG,NEWSWT	;COPY THE SWITCH REGISTER SETTING
	CLR	CHGCNT		;CLEAR THE CHANGE COUNT
	CLR	RSTFLG		;'RESET' HAS NOT BEEN DONE YET
.DSABL	LSB

GLOBAL	<SETTBL,VECTBL,CSRTBL,TYPTBL,DM.CSO,LINFRQ,SWTREG,UMIDST,UMIDEN>

.SBTTL	HARDWR MAIN LOOP

.ENABL	LSB

HARLUP:	MOV	PRESET,R1	;ANY PRESET ANSWER?
	BNE	20$		;YES
	CALLX	ASKER,R5	;ASK FOR SUBOPTION
	 .WORD	10$		;SHORT TEXT
	 GENTXT			;LONG TEXT
	  .ASCII <12>
	  .ASCII "  Valid HARDWR suboptions are:"<200>
	  .ASCII <12>
	  .ASCII "	LIST	List hardware configuration"<200>
	  .ASCII "	ECO	List revision levels of MSCP and TMSCP controllers"<200> ;025
	  .ASCII "	DISABLE	Disable a controller"<200>
	  .ASCII "	ENABLE	Enable a disabled controller"<200>
	  .ASCII "	CSR	Enter non-standard controller address"<200>
	  .ASCII "	VECTOR	Enter non-standard vector address for CD or CR"<200>
	  .ASCII "	UNITS	Associate a disk type with a controller"<200>
	  .ASCII "	DM	Set DM11BB/DH11 associations"<200>
	  .ASCII "	HERTZ	Set AC line hertz"<200>
	  .ASCII "	SWITCH	Set console switch register characteristics"<200>
	  .ASCII "	DDNULL	Select Diagnostic Display null job"<200> ;028
	  .ASCII "	RESET	Reset all user CSR's & vectors, enable all devices"<200>
	  .ASCII "	EXIT	(or <CR>) Exit from HARDWR option"<200>
	  .ASCII <12>
	  .ASCII "  Only the first two characters need be typed"<200>
10$:	  .ASCIZ <177><12>"  HARDWR suboption? "
	 UNORG
	BEQ	HAREXI		;GET OUT ON <LF> OR CTRL/Z
20$:	CALLX	GETUNQ,R5,HAROTX ;SCAN THE ANSWER
	CALL	@HAROPT(R0)	;CALL THE SUBOPTION
	TST	PRESET		;ONE ANSWER?
	BEQ	HARLUP		;NO, TRY FOR MORE
	.BR	HAREXI
HAREXI:

.DSABL	LSB

OPTION	EX,IT

.ENABL	LSB

	MOV	XDCHG,R0	;CHECK FOR ANY CHANGES FOR XD TYPE DEVICES.
5$:	CLC			;CLEAR CARRY FOR SHIFT
	ASL	R0		;SHIFT BIT # CORRESP. TO CONTROLLER INTO C BIT
	ADC	CHGCNT		; AND ADD THE CARRY INTO OR COUNT OF CHANGES.
	TST	R0		;ANY MORE CONTROLLER CHANGES FOR XD DEVICES?
	BNE	5$		;YES GO DO NEXT CONTROLLER.
	MOV	CHGCNT,R0	;ANY CHANGES?
	BNE	10$		;YES
	TST	RSTFLG		;RESETTING TO ENABLE ALL DEVICES?
	BNE	10$		;YES, THAT'S A CHANGE
	EXIT			;JUST EXIT QUIETLY

10$:	TST	SYNXSV		;IS THIS A TAPE?
	BMI	20$		;YES, THEN WE CAN'T MAKE CHANGES
	TSTB	SAVDEV		;WERE WE BOOTED FROM A SAV/RESTORE DISK?
20$:	BEQ	30$		;NO, THEN CHANGES ARE OK
	MESSAGE	<<200>"Changes not allowed for this type of booted device">
	EXIT

30$:	CALLX	TYPECR
	CALLX	MESSAG,R5,B2
	TST	RSTFLG		;RESETTING?
	BEQ	40$		;NO
	MESSAGE	<"Enabling all devices, ">,ENAMSG
40$:	CALLX	DECZER		;TELL HIM HOW MANY CHANGES
	MESSAG	<" change">
	DEC	R0		;CHECK FOR 1 CHANGE
	BEQ	50$		;YUP
	TYPE	<'S+40>		;PLURAL
50$:	MESSAG	<" being made."<200>>
	MOV	#SETNEW,R0	;POINT TO OUR TABLE
	MOV	#SETTBL,R1	;POINT TO MONITOR'S TABLE
	MOV	SETSIZ,R2	;NUMBER OF WORDS TO MOVE
	MOV	#VECTBL,R3	;POINT TO MONITOR'S VECTOR TABLE
60$:	MOV	VECNEW-SETNEW(R0),(R3)+ ;UPDATE DEVICE'S VECTOR
	MOV	(R0)+,(R1)+	;MOVE OUR TABLE INTO INSBUF
	SOB	R2,60$
	MOV	#MIDNEW,R0	;COPY UMID'S FROM OUR TABLE
	MOV	#UMIDST,R1	;TO TABLE IN THE ROOT
70$:	MOV	(R0)+,(R1)+	;MOVE WORDS
	CMP	R1,#UMIDEN	;UNTIL DONE
	BLO	70$

GLOBAL	<SETTBL,VECTBL,TYPTBL,DM.CSO,LINFRQ,SWTREG,UMIDST,UMIDEN>
GLOBAL	<SYNXSV,SAVDEV>

	MOV	#16.,R2		;ALSO COPY THE DM11BB STUFF
	MOV	#DMTTBL,R0	;FROM OUR INTERNAL DM TYPE TABLE
	MOV	#TYPTBL,R1	;TO THE ROOT TABLE
	ADD	#DM.CSO,R1	; AT THE DM OFFSET
90$:	MOV	(R0)+,(R1)+
	SOB	R2,90$
	MOV	NEWFRQ,LINFRQ	;COPY LINE FREQUENCY
	MOV	NEWSWT,SWTREG	;COPY SWITCH REGISTER
	CALLX	INSTAO		;REWRITE THE BUFFER
	CLR	R2		;READ IN THE BOOT BLOCK
	CLR	R3		;(FBN = 0)
	MOV	#256.,I.DSQ+DSQCNT ;1 BLOCK XFER
	CALLX	PARSEX,R5,<RFUN,SATBUF>
	MOV	#12707,SATBUF+<B.JMP-B.BOOT> ;SET MARKER SAYING INSBUF GOOD
	CLR	R2		;REWRITE THE BOOT BLOCK
	CLR	R3
	CALLX	PARSEX,R5,<WFUN,SATBUF>
	MESSAG	<<12>"  Rebooting . . ."<200><12>>
	JMPX	BOOTSY		;REBOOT THE SYSTEM

.DSABL	LSB

GLOBAL	<I.DSQ,SATBUF>

OPTION	LI,ST

.ENABL	LSB

	MOV	CHGCNT,R0	;GET NUMBER OF CHANGES PENDING
	BNE	10$		;PRINT HEADER IF ANY
	TST	RSTFLG		;RESETTING TO ENABLE ALL DEVICES?
	BEQ	40$		;NO, NO CHANGES AT ALL
10$:	TYPE	<12>
	MESSAG	<"  ">,B2
	TST	RSTFLG		;RESETTING?
	BEQ	20$		;NO
	CALLX	MESSAGE,R5,ENAMSG ;YES, SAY SO
20$:	CALLX	DECZER		;TYPE CHANGE COUNT
	MESSAG	<" change">
	DEC	R0		;ONE CHANGE?
	BEQ	30$		;YES
	TYPE	<'S+40>
30$:	MESSAG	<" pending."<200>>

40$:	MESSAG	<<12>"  Name"<11>"Address"<11>"Vector"<11>"Comments"<200>>
	CALLX	DEVLUP		;LOOP THROUGH ALL DEVICES
50$:	MOV	R4,R1		;COMPUTE ACTUAL INDEX IN R1
	SUB	#CSRTBL,R1
	TST	(R4)		;ANY DEVICE ACTUALLY HERE?
	BNE	100$		;YES, PRINT A REAL DEVICE
	MOV	SETTBL(R1),R0	;NO, GET USER CSR SET OPTION
	BNE	60$		;IF GIVEN, LIST THIS THING
	TSTB	VECTBL+1(R1)	;NO, BUT HE MAY HAVE A VECTOR
	BEQ	160$		;NO, SEE IF THERE IS A NEW THING TO LIST
60$:	CALLX	MESSAG,R5,B2
	CALLX	TYPDVN		;TYPE THE DEVICE NAME
	CALLX	TYPTAB		;TAB
	BIC	#1,R0		;REMOVE SET OPTION DISABLE BIT
	BEQ	70$		;NO USER-DEFINED CSR
	TYPE	<'*>
	CALLX	OCTWRD		;TYPE THE USER'S CSR
70$:	CALLX	TYPTAB
	CLR	R0		;GET SET OPTION VECTOR ADDRESS
	BISB	VECTBL+1(R1),R0	;VECTOR/2 IN R0
	BEQ	80$		;NONE
	ASL	R0		;MAKE IT REAL
	TYPE2	<'**400+40>	;BLANK *
	CALLX	OCT3DG		;3-DIGIT OCTAL VECTOR
80$:	MOV	SETTBL(R1),R0	;SET OPTION
	ASR	R0		;GET DISABLED INDICATION
	BCC	90$		;NOT DISABLED, JUST COULDN'T FIND IT
	MESSAG	<<11>"Disabled">,DISMSG ;DISABLED
	BR	150$		;NEW LINE, THEN PRINT NEW STATUS

90$:	BEQ	150$		;NO USER CSR, JUST A USER VECTOR
	MESSAG	<<11>"Not found">
	BR	150$		;NEW LINE

GLOBAL	<CSRTBL,SETTBL,VECTBL>

100$:	CALLX	MESSAG,R5,B2	;2 BLANKS
	CALLX	TYPDVN		;TYPE THE DEVICE NAME
	CALLX	TYPTAB		;MOVE TO CSR FIELD
	MOVB	#40,R2		;NORMALLY, PRINT A SPACE
	CMP	(R4),SETTBL(R1)	;IS THIS HIS SET CSR?
	BNE	110$		;NO
	MOVB	#'*,R2		;YES, SET A FLAG 
110$:	CALLX	TYPE		;
	MOV	(R4),R0		;R0 = CSR ADDRESS
	CALLX	OCTWRD		;PRINT IT
	CALLX	TYPTAB		;VECTOR COLUMN
	MOV	#40*400+40,R2	;ASSUME NOT USER VECTOR
	BITB	#PS.PVC,PK.FLG(R5);Programmable vector register?	;011
	BEQ	115$		;  No, a switch pack or jumper'd vector	;011
	MOV	#'P*400+40,R2	;'P' indicates we selected the vector.	;011
115$:	CLR	R0		;GET VECTOR IN R0			;011
	BISB	VECTBL(R1),R0
	BEQ	130$		;0 MEANS NO VECTOR (E.G. KG11)
	CMPB	R0,VECTBL+1(R1)	;IS THIS HIS SET VECTOR?
	BNE	120$		;NO
	MOV	#'**400+40,R2	;YES, TYPE BLANK *
120$:	CALLX	TYPE2
	ASL	R0		;FIX R0 TO BE VECTOR ADDRESS
	CALLX	OCT3DG		;TYPE IT AS 3-DIGIT OCTAL
130$:	MOV	#LSTTYP,R0	;R0 -> SPECIAL LISTING ROUTINES
140$:	MOV	(R0)+,R3	;GET A DISPATCH ADDRESS
	BEQ	150$		;NONE LEFT, NO SPECIAL LISTING
	CMP	(R0)+,PK.NAM(R5) ;IS THIS IT?
	BNE	140$		;NO
	CALLX	TYPTAB		;YES, SKIP TO COMMENTS FIELD
	CALL	(R3)		;AND DO SPECIAL LISTING
150$:	CALLX	TYPECR		;NEW LINE

GLOBAL	<SETTBL,VECTBL>

160$:	CMP	SETNEW(R1),SETTBL(R1) ;ANY CHANGES?
	BNE	170$		;YES
	CMPB	VECTBL+1(R1),VECNEW+1(R1) ;MAYBE?
	BEQ	230$		;NOPE
170$:	MESSAG	<" (">		;PARENTHESIZE NEW STUFF
	CALLX	TYPDVN		;TELL HIM THE NAME
	CALLX	TYPTAB
	MOV	SETNEW(R1),R0	;R0 = NEW CSR
	BIC	#1,R0		;REMOVE DISABLED INDICATION
	BNE	180$		;THERE IS ONE
	MESSAG	<" System">	;NO NEW CSR, INDICATE SYSTEM FINDS IT
	BR	190$		;AND GO ON

180$:	TYPE	<'*>		;INDICATE USER CSR
	CALLX	OCTWRD		;AND TELL HIM THE CSR
190$:	CLR	R0		;SET TO GET USER VECTOR
	BISB	VECNEW+1(R1),R0	;R0 = USER VECTOR
	BNE	200$		;GOT ONE, SO PRINT IT
	BIT	#1,SETNEW(R1)	;NONE. TAB TO PRINT 'DISABLED'?
	BEQ	220$		;NO, END THE LINE
	CALLX	TYPTAB		;TAB TO START OF VECTOR FIELD
	BR	210$		;AND GO PRINT THE MESSAGE
200$:	ASL	R0		;GET ACTUAL VECTOR
	MESSAG	<<11>" *">	;TAB TO VECTOR FIELD, INDICAT USER VEC
	CALLX	OCT3DG		;PRINT VECTOR
	BIT	#1,SETNEW(R1)	;NEW ONE DISABLED?
	BEQ	220$		;NO
210$:	CALLX	MESSAG,R5,DISMSG ;PRINT DISABLED MESSAGE
220$:	MESSAG	<")"<200>>,RPRMSG ;END OF LINE
230$:	CALL	@(SP)+		;ADVANCE TO NEXT DEVICE
	BEQ	240$		;END OF LINE
	JMP	50$		;DO ANOTHER

GLOBAL	<SETTBL,VECTBL>

240$:	CALLX	TYPECR		;BLANK LINE AFTER THE REAL DEVICES
	TSTB	KW11L		;IS THERE AN L CLOCK?
	BMI	250$		;NO
	CMP	LKSCSR,#LKS	;A Q BUS L CLOCK, DOES IT HAVE A CSR?
	BEQ	243$		;IT DOES, SO SAY SO
	MESSAGE	<"  KW11L"<11>" ******"<11>"  100">
	BR	245$		;CONTINUE

243$:	MESSAGE	<"  KW11L"<11>" 177546"<11>"  100">
	MOVB	KW11L,R0	;IS IT REAL?				;018
	BEQ	245$		;YES, A REAL ONE			;018
	MESSAGE	<<11>"(Write-only)">
	DEC	R0		;CHECK FOR read as -1			;018
	BEQ	245$		; NO, ITS type 1.			;018
	DEC	R0		;NOW CHECK FOR type 2			;018
	BNE	245$		; NO, ITS NOT 2.			;018
	MESSAGE	<" (Read -1)">	;TELL THEM WE FOUND THIS FUNKY THING.	;018
245$:	CALLX	TYPECR
250$:	TSTB	KW11P		;IS THERE A P CLOCK?
	BMI	260$		;NO
	MESSAGE	<"  KW11P"<11>" 172540"<11>"  104"<200>>
260$:	MOV	SWTREG,R0	;IS THERE A USER SWITCH REGISTER SETTING?
	BNE	270$		;YES, WE MUST PRINT A LINE
	TSTB	SWR$R		;NO, BUT IS THERE A SWITCH REGISTER?
	BMI	310$		;NO, PRINT NOTHING
270$:	MESSAGE	<"  SR"<11>>
	TSTB	SWR$R		;DOES THE REGISTER EXIST HERE?
	BMI	280$		;NO, NO CSR ADDRESS
	MESSAGE	<" 177570">	;PRINT ADDRESS
280$:	TST	R0		;ANY USER OPTION?
	BEQ	300$		;NO USER SETTING, DONE HERE
	BMI	290$		;GO IF DISABLED
	CALLX	TYPTAB		;TAB TO THE VECTOR FIELD
	CALLX	MESSAGE,R5,DISMSG ;PRINT DISABLED MESSAGE
	BR	300$		;END OF LINE

290$:	CALLX	TYPTAB		;TAB OVER
	MESSAGE	<<11>"Volatile">,VOLMSG
300$:	CALLX	TYPECR
310$:	CMP	R0,NEWSWT	;ANY CHANGES?
	BEQ	350$		;NO
	MESSAGE	<" (SR"<11><11>>
	TST	NEWSWT		;WHAT IS THE NEW STATE?
	BMI	320$		;VOLATILE
	BNE	330$		;DISABLED
	MESSAGE	<<11>"Enabled">	;ENABLED
	BR	340$

320$:	CALLX	MESSAGE,R5,VOLMSG
	BR	340$

330$:	CALLX	MESSAGE,R5,DISMSG
340$:	CALLX	MESSAGE,R5,RPRMSG ;END THE LINE

GLOBAL	<KW11L,LKSCSR,KW11P,SWTREG,SWR$R>

350$:	TSTB	SWR$W		;IS THERE A DISPLAY REGISTER?
	BMI	360$		;NO
	MESSAGE	<"  DR"<11>" 177570"<200>>
360$:	TSTB	FLGGPK		;is this a GPK?				;021
	BMI	370$		;Yes, no no 'hertz'			;021
	CMP	LINFRQ,#800.	; How about the strange 800Hz J-11	;027
	BEQ	370$		; It has no hertz either		;027
	MESSAGE	<<200>"  Hertz = ">
	MOV	LINFRQ,R0	;GET LINE FREQUENCY
	CALLX	DECZER		;TYPE IT
	MESSAGE	<"."<200>>
	CMP	R0,NEWFRQ	;ANY CHANGE?
	BEQ	370$		;NO
	MESSAGE	<" (Hertz = ">
	MOV	NEWFRQ,R0	;GET IT
	CALLX	DECZER		;TYPE IT
	MESSAGE	<".)"<200>>
370$:	MOV	(PC)+,R0	;GET EXTRA MESSAGE
	 GENTXT	<<200>"  Other: ">,OTHMSG
	TST	FPU		;ANY FPU?
	BMI	380$		;NO
	CALL	490$,R5		;YES
	 GENTXT	<"FPU">
	CMP	CPTYP,#5	;J-11 CHIP CPU??
	BEQ	374$		;NO
	CMP	CPTYP,#3	;F-11 CHIP CPU??			;007
	BNE	380$		;NO					;007
	LDFPS	#20		;PUT IT IN MAINTENANCE MODE		;007
	STFPS	R1		;GET STATUS BACK			;007
	LDFPS	#0		;TURN MAINTENANCE MODE OFF		;007
	BIT	#20,R1		;DID IT STAY IN MAINTENANCE MODE?	;007
	BEQ	380$		;NO, SO ITS THE SLOW FPU CHIP		;007
	BR	376$		;YES, SO ITS THE FPF11 HOT FPU		;007
374$:	BIT	#400,@#177750	;SEE IF THE J HAS FPA
	BEQ	380$		;NO
376$:	MESSAGE	<" with FPA">
380$:	TST	FIS		;ANY FIS?
	BMI	390$		;NO
	CALL	490$,R5		;YES
	 GENTXT	<"FIS">
390$:	TST	STAKLM		;ANY STACK LIMIT?
	BMI	400$		;NO
	CALL	490$,R5		;YES
	 GENTXT	<"SL">
400$:	TST	MEDINS		;ANY 'MED'?
	BMI	410$		;NO
	CALL	490$,R5		;YES
	 GENTXT	<"MED">

GLOBAL	<SWR$W,LINFRQ,FPU,FIS,STAKLM,MEDINS,CPTYP>
GLOBAL	<FLGGPK>							;021

410$:	TSTB	CISINS		;DOES HE HAVE A COMMERCIAL INSTRUCTION SET
	BMI	420$		;NO
	CALL	490$,R5		;YES
	 GENTXT	<"CIS">
420$:	TSTB	FLG22		;DOES HE HAVE 22BIT ADDRESSING
	BMI	430$		;NO
	CALL	490$,R5		;YES
	 GENTXT	<"22-Bit">
430$:	TSTB	DSHARD		;SEPARATE I&D SPACES?
	BMI	435$		;NO
	CALL	490$,R5		;YES
	 GENTXT	<"Data space">
435$:	TSTB	CACHE		;ANY CACHE?
	BMI	440$		;NO
	CALL	490$,R5		;YES
	 GENTXT	<"Cache">
440$:	TSTB	CACHEA		;CACHE ADDRESS INFO?
	BMI	442$		;NO
	MESSAGE	<" w/address">

GLOBAL	<DSHARD,CACHE,CACHEA,CISINS,FLG22>

442$:	MOV	CPTYP,R1	;IS THERE A CHIP SET TYPE?
	BEQ	450$		;NO, SKIP THIS STUFF
	CMP	R1,#1		;11/44??
	BEQ	443$		;YES, SKIP IT
	CMP	R1,#3		;F-11 CHIP
	BEQ	444$		; YES
	CMP	R1,#5		;J-11 CHIP
	BEQ	446$		; YES
	MESSAGE	<", ">
	MOV	R1,R0
	CALL	DECZER		;PRINT THE TYPE
	BR	448$

443$:	CALL	490$,R5		;GIVE THE 11/44 TYPE MESSAGE
	 GENTXT	<"11/44">
	BR	448$

444$:	TSTB	FLGGPK		;is this a GPK?				;021
	BPL	445$		;No, plain old F-11			;021
	CALL	490$,R5		;Yes, so its a -350			;021
	 GENTXT	<"GPK">							;021
	BR	450$							;021

445$:	CALL	490$,R5		;GIVE THE F CHIP TYPE MESSAGE
	 GENTXT <"F11">
	BR	448$

446$:	TSTB	FLGGPK		;Is this a GPK?				;021
	BPL	447$		;No, plain old J-11			;021
	CALL	490$,R5		;Yes, its the GPK-380			;021
	 GENTXT	<"GPK-Plus">						;021
	BR	450$							;021

447$:	CALL	490$,R5		;GIVE THE J CHIP TYPE MESSAGE
	 GENTXT	<"J11">
	MOV	JCPTYP,R2	;Get the J-CPU sub-type			;018
	ADD	(PC)+,R2	;Add the rest of the text to print	;018
	 .ASCII	"@-"		;-@ + 1 = -A  -@ + 2 = -B		;018
	SWAB	R2		;Put them in the right order		;018
	CALLX	TYPE2		;Print the 2 characters.		;018
448$:	MESSAGE	<" CPU">
450$:	TSTB	CP.SID		;SYSTEM ID?
	BMI	470$		;NO
	CALL	490$,R5		;YES
	 GENTXT	<"System ID = ">
	MOV	@#CPUSID,R0	;GET IT
	BPL	460$		;POSITIVE IS OK
	MESSAGE	<"-">		;PRINT MINUS SIGN FOR NEGATIVE ID'S
	NEG	R0		;AND PRINT ITS ABSOLUTE VALUE
460$:	CALLX	DECZER		;PRINT IT IN DECIMAL
470$:	CMP	R0,#OTHMSG	;ANYTHING OUT IN THIS SECTION?
	BEQ	480$		;NO
	CALLX	TYPECR		;YES, NEW LINE
480$:	RETURN

490$:	CALLX	ASCIZ0		;PRINT THE INTRO TEXT
	MOV	(R5)+,R0	;GET THE SPECIFIC TEXT
	CALLX	ASCIZ0		;PRINT IT
	MOV	(PC)+,R0	;NEW INTRO TEXT
	 GENTXT	<", ">
	RETURN	R5

GLOBAL	<JCPTYP,FLGGPK>							;021

.DSABL	LSB

; **$DISKS**	SPECIAL CASES FOR HARDWR LIST SUBOPTION

LSTTYP:	.WORD	RVLIST,"RV
	.WORD	RFLIST,"RF
	.WORD	RKLIST,"RK
	.WORD	RLLIST,"RL
	.WORD	RPLIST,"RP
	.WORD	RMLIST,"RM
	.WORD	RHLIST,"RS
	.WORD	RHLIST,"RB
	.WORD	RHLIST,"RR
	.WORD	RWLIST,"RW						;021
	.WORD	RULIST,"RU
	.WORD	DMLIST,"DM
	.WORD	TULIST,"TU
	.WORD	TSLIST,"TS
	.WORD	MULIST,"MU						;010
	.WORD	TTLIST,"TT						;016
	.WORD	KLLIST,"KL						;016
	.WORD	DLLIST,"DL						;016
	.WORD	DELIST,"DE						;016
	.WORD	RXLIST,"RX						;008
	.WORD	XMLIST,"XM						;016
	.WORD	XDLIST,"XD						;020
	.WORD	DZLIST,"DZ						;008
	.WORD	VHLIST,"VH						;008
	.WORD	XELIST,"XE						;017
	.WORD	XHLIST,"XH						;017
	.WORD	XALIST,"XA						;029
	.WORD	PILIST,"PI						;021
	.WORD	0

GLOBAL	<CP.SID,CPTYP>

.SBTTL	Disk Device listing routines

.ENABL	LSB

RVLIST:	RETURN			;Virtual Disk is not really hardware.	;005

RFLIST:	MOVB	DF$SZL+1,R0	;GET SIZE OF DISK
	ASR	R0		;SHIFT IT
	ASR	R0
	CALLX	DECZER		;PRINT IT
	MESSAG	<" platter">
	DEC	R0		;Is there only one?
	BEQ	20$		;Yup
	MESSAG	<"s">		;No, Plural
20$:	RETURN

GLOBAL	<DF$SZL>

RKLIST:	MESSAGE	<"Units:">
	CLR	R0		;UNIT # = 0
30$:	MOV	R0,R3		;COPY THE UNIT NUMBER
	ASL	R3		;MAKE IT * 2
	CMP	DKUMID(R3),#-1	;did the user specify
	BNE	40$		;YES, SO TELL THEM
	BITB	BITBYT(R0),TYPTBL+RK.CSO ;IS THIS UNIT THERE AT ALL?
	BEQ	80$		;NO, SO SKIP IT.
40$:	MOV	TYPEHT,R2	;SET THE TERMINAL POSITION
	ADD	#10.,R2		;ADD THE LENGTH OF THIS MESSAGE
	CMPB	R2,#80.-1	;ROOM FOR MESSAGE AND SPACE
	BLOS	50$		;YES
	MESSAGE	<<200><11><11><11>"     "> ;NO, MAKE ROOM ON NEXT LINE
50$:	TYPE	<40>		;SPACE IT ALL OUT NICELY
	CMP	DK$MID(R3),DKUMID(R3) ;USER SET THIS?
	BNE	60$		;NOPE
	TYPE	<'*>		;TYPE OUT THE '*' FOR USER SPECIFIED.
60$:	CALLX	DECZER		;FINALLY, TYPE THE UNIT
	MESSAGE	<"(RK05">	;DO THE MESSAGE
	TST	DK$MID(R3)	;CHECK THE ID WORD
	BEQ	70$		;ZERO => RK05J
	TYPE	<'F>		;TELL THEM IT'S AN RK05F
70$:	TYPE	<')>		;AND CLOSE OUT THIS UNIT
80$:	INC	R0		;NEXT UNIT
	CMP	R0,#8.		;DONE?
	BLO	30$		;NO
	RETURN			;ALL DONE

DMLIST:	MOVB	TYPTBL(R1),R0	;R0 = ASSOCIATED DH11 UNIT
	BMI	120$		;NONE
	MESSAGE	<"DH">
	CALLRX	DECZER		;DH UNIT

120$:	MESSAGE	<"NO DH11">
	RETURN

BAECHK:	MOV	#BAELST,R3	;POINT TO LIST OF DEVICES W/ BAE
130$:	MOV	(R3)+,R0	;GET A BAE ADDRESS
	BEQ	140$		;END OF LIST -- WE'RE NOT AN RH70
	CMP	(R4),(R3)+	;IS IT BAE FOR THIS CSR ADDRESS?
	BNE	130$		;NO, KEEP LOOKING
	MESSAG	<"BAE=+">	;YES, PRINT MESSAGE
	SUB	(R4),R0		;COMPUTE OFFSET
	CALLX	OCT3DG		;AND PRINT 3-DIGIT OCTAL
	CLZ			;INDICATE THAT WE PRINTED SOMETHING
140$:	RETURN

.DSABL	LSB

GLOBAL	<DK$MID,DKUMID,TYPTBL,BAELST,BITBYT,RK.CSO>

.ENABL	LSB

RLLIST:	MOV	#RLDTBL,-(SP)	;STACK POINTER TO ID TABLE
	MOV	#4.,90$		;ONLY FOUR UNITS FOR THIS DISK
	BR	20$		;MERGE WITH COMMON CODE

RMLIST:	MOV	#RMDTBL,-(SP)	;STACK POINTER TO ID TABLE
	BR	10$		;MERGE WITH COMMON CODE

RPLIST:	MOV	#RPDTBL,-(SP)	;STACK POINTER TO ID TABLE		;018
	BR	10$		;MERGE WITH COMMON CODE			;018

RHLIST:	CALL	BAECHK		;PRINT BAE OFFSET FOR RH70
	BEQ	5$		;SKIP IF NONE
	TYPE2	<", >		;SEPARATE BAE FROM UNITS
5$:	MOV	#RHDTBL,-(SP)	;STACK POINTER TO ID TABLE
10$:	MOV	#8.,90$		;THESE DISKS HAVE 8 UNITS
20$:	MESSAGE	<"Units:">
	MOV	DSKMID-2(R1),R3	;POINT TO MASSBUS ID TABLE FOR DISK
	CLR	-(SP)		;START WITH UNIT 0
30$:	CMP	(R3),#-1	;IS THIS UNIT NOT HERE?
	BEQ	80$		;NO UNIT, NO MESSAGE
	MOV	2(SP),R2	;POINT TO TABLE/TYPE ASSOCIATIONS
40$:	MOV	(R2)+,R0	;GET TYPE MESSAGE
	CMP	(R2),#-1	;END OF TABLE?
	BEQ	50$		;YES, SAY UNKNOWN
	CMP	(R3),(R2)+	;UNIT MATCH?
	BNE	40$		;NO, TRY FOR MORE
50$:	MOVB	(R0)+,R2	;GET LENGTH OF TEXT
	MOV	(SP),-(SP)	;COPY UNIT NUMBER
	ASL	(SP)		;MAKE IT * 2
	ADD	DSKUID-2(R1),(SP) ;POINT TO USER ASSOCIATIONS
	CMP	(R3),@(SP)+	;USER SET THIS UNIT?
	BNE	60$		;NO
	ADD	#'**400+1,R2	;YES, PRINT A STAR, LENGTH IS ONE MORE
60$:	ADD	TYPEHT,R2	;ADD IN TERMINAL POSITION
	CMPB	R2,#80.-1	;ROOM FOR MESSAGE AND SPACE
	BLOS	70$		;YES
	MESSAGE	<<200><11><11><11>"      "> ;NO, MAKE ROOM ON NEXT LINE
70$:	CLRB	R2		;CLEAR FOR BISB
	BISB	#40,R2		;SPACE TO SEPARATE
	CALLX	TYPE2		;TYPE SPACE, MAYBE STAR
	MOV	R0,R2		;SAVE OUR TEXT POINTER IN R2
	MOVB	(SP),R0		;SET UNIT NUMBER IN R0
	CALLX	DECZER		;  AND PRINT UNIT NUMBER
	MOV	R2,R0		;GET BACK TEXT POINTER 
	CALLX	ASCIZ0		;  AND PRINT THE MEDIA/HARDWR TYPE
80$:	TST	(R3)+		;BUMP THE MASSBUS ID TABLE POINTER
	INC	(SP)		;BUMP THE UNIT NUMBER
	CMP	(SP),(PC)+	;ENOUGH UNITS YET?
90$:	 .WORD	8.		;EIGHT UNITS, EXCEPT FOUR FOR RL01
	BLO	30$		;NO, LOOP
	CMP	(SP)+,(SP)+	;DUMP COUNT & TABLE POINTER
	RETURN

.DSABL	LSB

GLOBAL	<DEV.UN,DSKMID,TYPEHT,CSRTBL,DSKCSR,BITBYT,TYPTBL,RP.CSO>



.ENABL	LSB								;021+

RWLIST:	REGSCR			;Save registers
	MOVB	DW$MID+1,R1	;Get disk type (high byte)
	BMI	10$		;None given, that's strange
	ASL	R1		;Form word offset
	MOV	RWTYPE(R1),R0	;Point to type strings
	CALLX	ASCIZ0		;Print the string
10$:	RETURN			;That's easy!

RWTYPE:	GENTXT	<"RD50">
	GENTXT	<"RD51">
	GENTXT	<"RD31">
	GENTXT	<"RD52">
	GENTXT	<"RD53">
	GENTXT	<"RD54">

PILIST:	REGSCR			;Save registers
	TSTB	PIEBO		;Extended bit map option?
	BEQ	20$		;No
	MESSAGE	<"Extended bit map"> ;Yes...
20$:	RETURN			;That's all

.DSABL	LSB

GLOBAL	<DW$MID,PIEBO>							;021-

.ENABL	LSB
;010+
MULIST:	REGSCR			;Save all registers
	MOV	#DU.MAX,R3	;Tape controllers follow disks
	BR	10$		;Join common code

GLOBAL	<DU.MAX>

RULIST:	REGSCR			;Save useful registers
	CLR	R3		;Disk controllers come first
10$:	ADD	DEV.UN,R3	;R3 = TMSCP controller number
	MOV	R3,R2		;Copy it in R2
	BEQ	18$		;If controller 0, then actual # = physical #
	MOV	R3,R4		;Copy controller #
	MOV	#CSRTBL+RU.CSO,R5	;Point to beginning of CSR's
15$:	TST	(R5)+		;Does this controller exist
	BNE	17$		;Yes, don't modify controller #
	DEC	R3		;Modify actual controller #
17$:	SOB	R4,15$		;Keep checking
18$:	MUL	#CMTSIZ,R3	;  Controller # * CMTSIZ to give CMT offset
	MOV	R3,R4		;Put it in R4
	MOV	#CMVTBL,R1	;R1 => Controller model value table
20$:	TSTB	(R1)		;End of table?
	BEQ	30$		;Yes.
	CMPB	UQCMT(R2),(R1)+	;No, is this the unit's controller?
	BNE	20$		;No, keep looking
	TSTB	-(R1)		;Bump the pointer back
30$:	MOVB	CMT+CM.FLG(R4),-(SP)	;Does this controller support disks?
	BPL	40$		;No, so don't try to print any
.ASSUME	CF.DSK	EQ 200
	CALL	RUNITS,R5,<70$,UMT$DU,DU$MNM,DU.UNC>	;Print all disk units
40$:	ASLB	(SP)+		;Does this controller support tapes?
	BPL	60$		;No, so don't print any
.ASSUME CF.TAP	EQ 100
	BCC	50$		;Yes, but not disks, so carriage is fine
.ASSUME	CF.DSK	EQ 200
	MESSAGE	<<200><11><11><11>> ;Start tapes on a next line after disks...
50$:	CALL	RUNITS,R5,<80$,UMT$MU,MU$MNM,MU.UNC>	;Print all tape units
60$:	RETURN			;Done.

	GLOBAL	<CSRTBL,RU.CSO,UQCMT>
	GLOBAL	<DEV.UN,CMT,UMT$DU,DU$MNM,DU.UNC,UMT$MU,MU$MNM,MU.UNC>

	TMPORG	HARTXT
70$:	.ASCIZ	"Disk "
80$:	.ASCIZ	"Tape "
	UNORG

.DSABL	LSB

;+
;  CMVTBL and CMVTXT tables:
;
;  These tables contain information for all of the UQSSP (RU/MU)
;  controllers we support.  The first table, CMVTBL contains the
;  controller model numbers as defined in the [T]MSCP specification.
;  The second table is the corresponding name of the controller
;  as known to the customer.
;
;  NOTES:  1) The CMVTXT table must be in the same order as CMVTBL
;          2) Controller tables also exist in INIONE and ERRBLD
;
;	One minor warning about the KFQSA.  It is one board, with NO
;	[T]MSCP controllers on it.  It is an adapter that connects to several
;	[T]MSCP controllers.  Each device attached to it has its own
;	controller.  So, it appears like each disk/tape type has its own
;	controller type, since each disk/tape does have its own controller.
;	This table however lists them all as KFQSA since thats sorta what
;	the customer associates with the "controller".
;-
	ORG	HARCTL
CMVTBL:	.BYTE	2,3,5,6,7,9.,10.,11.,13.,14.,16.,17.,19.,20.		;027
	.BYTE	25.,26.,30.,31.,96.,97.,98.,99.,100.,101.		;029
	.BYTE	102.,103.,104.,105.,106.,107.,108.,109.,110.		;031
	.BYTE	111.,112.,113.,114.,0,0,0				;029
	.EVEN

CMVTXT:	;GENTXT	<"HSC50">	;1					;019
	GENTXT	<"UDA50">	;2
	GENTXT	<"RC25">	;3
	;GENTXT	<"VMS">		;4					;019
	GENTXT	<"TU81">	;5
	GENTXT	<"UDA50A">	;6
	GENTXT	<"RQDX">	;7
	;GENTXT	<"TOPS">	;8					;019
	GENTXT	<"TK50">	;9
	;This is NOT just TQK50s.  Some old TUK50s also use this ID.
	GENTXT	<"RUX50">	;10
	GENTXT	<"Unassigned">	;11					;027
	;GENTXT	<"KFBTA">	;12					;019
	GENTXT	<"KDA50">	;13
	GENTXT	<"TQK70">	;14					;019
	;GENTXT	<"RV20">	;15					;019
	GENTXT	<"KRQ50">	;16					;029
	GENTXT	<"Unassigned">	;17					;027
	;GENTXT	<"KDB50">	;18					;019
	GENTXT	<"RQDX3">	;19					;013
	GENTXT	<"Unassigned">	;20					;027
	;GENTXT	<"Unassigned">	;21-24 reserved for UQSSP/DSSI		;019
	GENTXT	<"TUK50">	;25					;027
	GENTXT	<"Unassigned">	;26					;029
	;GENTXT <"KDM70">	;27					;029
	;GENTXT	<"Unassigned">	;28					;019
	;GENTXT <"TM32">	;29					;029
	GENTXT	<"RQZX1">	;30					;029
	GENTXT	<"Unassigned">	;31					;029
	;GENTXT	<"CI Devices">	;32-63					;019
	;GENTXT	<"BI Devices">	;64-95					;019
	GENTXT	<"KFQSA">,KFQ	;96 (RF30)				;027
	.WORD	KFQ		;97 (RF71)				;027
	.WORD	KFQ		;98 (TF85)				;027
	.WORD	KFQ		;99 (TF70)				;027
	.WORD	KFQ		;100 (RF31)				;027
	.WORD	KFQ		;101 (RF72)				;027
	.WORD	KFQ		;102 (RF73)				;027
	.WORD	KFQ		;103 (TF70L)				;027
	.WORD	KFQ		;104 (RF35)				;029
	.WORD	KFQ		;105 (EF51)				;031
	.WORD	KFQ		;106 (????)				;031
	.WORD	KFQ		;107 (????)				;031
	.WORD	KFQ		;108 (RF36)				;031
	.WORD	KFQ		;109 (RF74)				;031
	.WORD	KFQ		;110 (????)				;031
	.WORD	KFQ		;111 (????)				;031
	.WORD	KFQ		;112 (RF75)				;031
	.WORD	KFQ		;113 (????)				;031
	.WORD	KFQ		;114 (????)				;031
	;GENTXT	<"Unassigned">	;113-247				;019
	;GENTXT	<"Sw servers">	;248-255				;019
	GENTXT	<"Unknown">	;0

	ORG	HAR
;010-

.ENABL	LSB

RUNITS:	MOV	R1,-(SP)	;Save R1 (CMVTBL pointer)		;010
	SUB	#CMVTBL,R1 	;R1 = byte index in CMVTBL		;010
	ASL	R1		;Make it a word index			;010
	MOV	CMVTXT(R1),R0	;Get pointer to text			;010
	CALLX	ASCIZ0		;Print out controller's name		;010
	CALLX	TYPTAB		;Skip to next tab margin		;010
	MOV	(R5)+,R0	;Get disk/tape message			;010
	MOVB	#CF.DSK!CF.TAP,-(SP)	;Check CM.FLG if both disk and	;010
	BICB	CMT+CM.FLG(R4),(SP)+	;tape flags are set		;010
	BNE	5$		;Only one flag, don't print disk/tape	;010
	CALLX	ASCIZ0		;Print it out				;010
5$:	MESSAG	<"Units:">	; finish up units text			;010
	CLR	-(SP)		;Set up "units found" flag
	CLR	-(SP)		;START WITH UNIT 0
10$:	MOV	(SP),R0		;COPY THE UNIT NUMBER (R0 DESTROYED LATER)
	ASL	R0		;  *2
	ASL	R0		;    *4
.ASSUME	UMTSIZ	EQ 4
	MOV	R0,R3		;Add unit # * 4 to...			;010
	ADD	(R5),R3		; UMT$xx to get UMT pointer		;010
	TST	UM.UCB(R3)	;Does this unit exist?			;010
	BEQ	90$		;No.					;010
	CMP	(R3),R4		;Yes, does it belong to this controller? ;010
.ASSUME	UM.CMT	EQ 0
	BNE	90$		;    NO - THEN DON'T PRINT THE MESSAGE.
	INC	2(SP)		;Mark that a unit was found
	MOV	R0,R1		;Add unit # * 4 to...			;010
	ADD	2(R5),R1	;MNM$xx to compute media name pointer	;010
	MOV	(R1)+,R3	;Get low order media name		;010
	MOV	(R1),R2		; and high order			;010
	BEQ	60$		;None, so say "Unknown".		;030
	BIC	#177,R3		;Get rid of numeric part of name
	BIC	#177700,R2	; and device mnemonic
	ASHC	#<2*5>-16.,R2	;Shift 3rd character to bottom of R2
	MOV	#MNAME,R0	;Point to the name buffer		;010
	MOVB	#'(,(R0)+	;Put in open paren			;010
	MOV	R5,-(SP)	;Save parameter pointer for a minute	;010
30$:	MOVB	R2,R5		;Pick up a character			;010
	BIC	#^C<37>,R5	;Isolate it				;010
	BEQ	40$		;Null, don't do anything
	ADD	#'A-1,R5	;Convert to ASCII			;010
	MOVB	R5,(R0)+	;Store it				;010
40$:	ASHC	#5,R2		;Shift over to next character
	BNE	30$		;Have one, process it
	MOV	(SP)+,R5	;Restore parameter pointer		;010
	;CLR	R2		;Clear for divide
	MOV	-(R1),R3	;Get identification again		;010
	BIC	#^C<177>,R3	;Isolate numeric part
	DIV	#100.,R2	;Get 100s digit
	BEQ	50$		;None
	MOVB	#'1,(R0)+	;It was a 1 (since max is 127.)		;010
	CLR	R2
50$:	DIV	#10.,R2		;Get 10s and 1s
	ADD	#'0,R2		;Convert to ASCII
	MOVB	R2,(R0)+	;Store tens				;010
	ADD	#'0,R3		;Convert another
	MOVB	R3,(R0)+	;Store units				;010
	MOVB	#'),(R0)+	;Put in closing parenthesis		;010
	CLRB	(R0)		;Put in terminator			;010
	MOV	R0,R2		;Copy pointer				;010
	MOV	#MNAME,R0	;Point to the string again
	SUB	R0,R2		;Compute length of name
	BR	70$		;Go print it

60$:	MOV	UNKNOW,R0	;Point to a string for "Unknown"	;030
	MOVB	(R0)+,R2	;GET LENGTH OF TEXT
70$:	ADD	TYPEHT,R2	;ADD IN TERMINAL POSITION
	CMPB	R2,#80.-1	;ROOM FOR MESSAGE AND SPACE
	BLOS	80$		;YES
	MESSAGE	<<200><11><11><11><11>"      "> ;No, go to next line	;010
	MOVB	#CF.DSK!CF.TAP,-(SP)	;Check CM.FLG if both disk and	;010
	BICB	CMT+CM.FLG(R4),(SP)+	;tape flags are set		;010
	BNE	80$		;Only one flag, don't adjust message	;010
	MESSAGE	<"     ">	;Space past "Disk " or "Tape "		;010
80$:	TYPE	40		;Type a space
	MOV	R0,R2		;SAVE OUR TEXT POINTER IN R2
	MOVB	(SP),R0		;SET UNIT NUMBER IN R0
	CALLX	DECZER		;  AND PRINT UNIT NUMBER
	MOV	R2,R0		;GET BACK TEXT POINTER
	CALLX	ASCIZ0		;  AND PRINT THE MEDIA/HARDWR TYPE
90$:	INC	(SP)		;BUMP THE UNIT NUMBER
	CMP	(SP),4(R5)	;ENOUGH UNITS YET?			;010
	BLO	10$		;NO, LOOP
	TST	(SP)+		;DUMP COUNT
	TST	(SP)+		;Any units found?
	BNE	100$		;Yes, exit
	MESSAGE	<" none">	;No, say so
100$:	ADD	#6,R5		;Skip past UMT$xx,MNM$xx,xx.UNC		;010
	MOV	(SP)+,R1	;Restore R1				;010
	RETURN	R5		;Done with units			;010

.ENABL	LSB

	TMPORG	HARCTL
MNAME:	.BLKB	10.		;Room for (xxxnnn)<null>
	UNORG

GLOBAL	<TYPEHT>

.SBTTL	MM Tape listing routine

.ENABL	LSB

TULIST:	MOV	R1,-(SP)	;SAVE R1
	CALL	BAECHK		;PRINT BAE OFFSET FOR RH70
	BEQ	5$		;SKIP IN NONE
	TYPE2	<", >		;SEPERATE BAE FROM UNITS
5$:	MOV	#MMDTBL,-(SP)	;GET THE TABLE COMMENTS
	MESSAG	<"Units: ">	;SEND THE PROMPT
	MOV	#MM$TYP,R3	;R3 -> MAGTAPE DRIVE NUMBER FOR DRIVE #0
	CLR	-(SP)		;START WITH UNIT #0
10$:	TST	(R3)		;IS THIS DRIVE PRESENT?
	BEQ	60$		;NO, GO TO NEXT DRIVE
	MOV	2(SP),R2	;FETCH POINTER TO COMMENTS TABLE
20$:	MOV	(R2)+,R0	;GET POINTER TO TEXT OF COMMENT
	CMP	(R2),#-1	;ARE WE AT THE END OF THE TABLE
	BEQ	30$		;YES, USE THE UNKNOWN MESSAGE
	CMP	(R3),(R2)+	;IS THIS OUR DRIVE TYPE?
	BNE	20$		;NO, KEEP LOOKING
30$:	MOV	(R2),R1		;SAVE DRIVE TYPE AS A FLAG
	MOVB	(R0)+,R2	;GET NUMBER OF CHARACTERS IN COMMENT
	ADD	TYPEHT,R2	;ADD IN PRESENT COLUMN NUMBER
	CMPB	R2,#80.-1	;IS THERE ENOUGH ROOM ON THIS LINE
	BLOS	40$		;YES, CONTINUE NORMALLY
	MESSAG	<<200><11><11><11>"       "> ;START NEW LINE
40$:	MOVB	(SP),(R0)	;PUT THIS UNIT NUMBER IN THE COMMENT
	BISB	#'0,(R0)	;AS AN ASCII INTEGER
	CMP	R1,#-1		;WAS THIS AN UNKNOWN DRIVE TYPE
	BEQ	50$		;YES, DO NOT ADD IN FORMATTER NUMBER
	MOV	(SP),R1		;GET UNIT NUMBER
	ASL	R1		;*2
	MOVB	MM$FOR(R1),14.(R0) ;SET FORMATTER NUMBER IN COMMENT
	BISB	#'0,14.(R0)	; AS AN ASCII INTEGER
	BICB	#200,14.(R0)	; NO FUNNY 8-BIT STUFF			;004
50$:	CALLX	ASCIZ0		;PRINT THE COMMENT
	MESSAG	<" ">
60$:	TST	(R3)+		;ADVANCE THE DRIVE TYPE TABLE POINTER
	INC	(SP)		;AND THE UNIT NUMBER
	CMP	(SP),#8.	;ARE WE DONE WITH ALL UNITS?
	BLO	10$		;NO, CONTINUE WITH NEXT DRIVE
	CMP	(SP)+,(SP)+	;POP OFF JUNK ON STACK
	MOV	(SP)+,R1	;RESTORE R1
	RETURN

.DSABL	LSB

GLOBAL	<MM$FOR,MM$TYP,TYPEHT>

.SBTTL	MS tape listing routine

.ENABL	LSB

TSLIST:	MOV	R1,-(SP)	;Save R1			;006
	CLR	R1		;R1 = 0 for no extended features;006
	MESSAG	<"Units: ">					;004
	MOV	DEV.UN,R0	;GET UNIT NUMBER		;004
	CALLX	DECZER		;PRINT IT			;004
	MOVB	MS$TYP(R0),R0	;LOOKUP TYPE FOR THIS UNIT	;004
	BMI	10$		;Unit has extended features set	;006
	CMPB	R0,#$TK25	;Does it have them at all?	;006
	BLT	20$		;No, so leave pointer alone	;006
	TST	(R1)+		;R1 = 4 for disabled features	;006
10$:	TST	(R1)+		;R1 = 2 fo extended features	;006
	BIC	#^C<177>,R0	;Need only low 7 bits		;006
20$:	MOV	MSDTBL(R0),R0	;GET POINTER TO DRIVE TYPE	;004
	CALLX	ASCIZ0		;PRINT OUT TYPE			;004
	TST	R1		;Should we print features note?	;006
	BEQ	30$		;No				;006
	MESSAG	<" Extended features ">	;Yes, print part one	;006
	MOV	MSXTBL-2(R1),R0	;Point to disabled/enabled	;006
	CALLX	ASCIZ0		;Print out part two		;006
30$:	MOV	(SP)+,R1	;Restore R1			;006
	RETURN			;All done			;006

GLOBAL	<DEV.UN,MS$TYP>						;004
.DSABL	LSB

.SBTTL	Terminal Mux listing routines

.ENABLE	LSB

DZLIST:	MOV	#TYPTBL+DZ.CSO,R0	;POINT TO DZ TYPE TABLE		;008
	CALL	30$			;CHECK OUT THE TYPE BIT		;008
	BEQ	20$			;Clear, so big (8 line) type	;024
	MESSAG	<"4">			;PRINT 4 LINE MESSAGE		;008
	RETURN				;ALL DONE NOW			;008

VHLIST:	MOV	#TYPTBL+VH.CSO,R0	;POINT TO VH TYPE TABLE		;008
	CALL	30$			;CHECK OUT THE TYPE BIT		;008
	BNE	20$			;Set, so small (8 line) type	;024
	MESSAG	<"16">			;PRINT 16 LINE MESSAGE		;008
	RETURN				;ALL DONE NOW			;008

20$:	MESSAG	<"8">			;PRINT 8 LINE MESSAGE		;008
	RETURN				;ALL DONE NOW			;008

30$:	MESSAG	<"Sub-lines: ">		;PRINT INTRO TEXT		;008
40$:	MOV	DEV.UN,-(SP)		;GET THIS CONTROLLERS UNIT #	;008
	ASL	(SP)			; * 2				;008
	ADD	(SP)+,R0		;GET THIS CONTROLLERS POINTER	;008
	BIT	#1,(R0)			;AND TEST THE TYPE BIT		;008
	RETURN				;DONE HERE, FINISH THE MESSAGE	;008

XALIST:	MESSAG	<"Type: ">		;Get ready to tell them		;029
	MOV	#TYPTBL+XA.CSO,R0	;Get the type table pointer	;029
	CALL	40$			; for the right unit		;029
	CMP	(R0),#2			;Is is the Q-Bus flag?		;029
	BNE	50$			; No, it's the UNIBUS		;029
	MESSAG	<"DRV11">		;Print the Q-bus type		;029
	BR	58$			; and leave			;029

50$:	MESSAG	<"DR11, EIR ">		;Print the Unibus type		;029
	BIT	#1,(R0)			;Did we get the EIR register?	;029
	BNE	52$			; YES				;029
	MESSAG	<"Disabled ">		; Tell them we didn't		;029
	BR	58$			;and continue			;029

52$:	MESSAG	<"Enabled ">		;Tell them it is enabled	;029
54$:	MOVB	#'2,56$			;Set the message		;029
	BIT	#400,(R0)		;Check the N-Cycle Burst Switch	;029
	BEQ	55$			;2 cycle mode			;029
	MOVB	#'N,56$			;Change to N cycle mode		;029
55$:	MESSAG
	 .ASCII	", "
56$:	 .ASCIZ	"2-Cycle Mode"
	UNORG				;ALL DONE WITH THE MESSAGE	;029
58$:	RETURN				;so return			;029

RXLIST:	MOVB	#'1,70$+5		;START WITH RX01		;018
	MOVB	#'1,80$+5		;START WITH RX01		;018
	MOV	DEV.UN,R0		;GET THE CONTROLLER UNIT #	;018
	ASL	R0			; * 2				;018
	ADD	#60,R0			;MAKE IT ASCII 0,2,4,6		;018
	MOVB	R0,70$			;STORE IN THE TEXT		;018
	MOVB	R0,80$			; AND STORE THAT ONE		;018
	INCB	80$			;  FOLLOWED BY UNIT+1		;018
	ADD	#CSRTBL+RX.CSO-60,R0	;GET CSR POINTER FOR RX'S	;018
	BIT	#4000,@(R0)+		;NOW, FIND OUT WHICH IT IS	;018
	BEQ	60$			;NOT RX02, SO TELL THEM		;008
	INCB	70$+5			;CHANGE TO RX02			;018
	INCB	80$+5			;CHANGE THIS TO RX02 ALSO	;018
60$:	MESSAG
	 .ASCII	"Units: "		;START OUT PRETTY		;018
70$:	 .ASCII	"0(RX01) "		;WE FOUND AN RX0?		;008
80$:	 .ASCIZ	"1(RX01)"		;WE FOUND AN RX0?		;008
	UNORG				;ALL DONE WITH THE MESSAGE	;018
	RETURN				;ALL DONE NOW			;008

GLOBAL	<TYPTBL,CSRTBL,DEV.UN,DZ.CSO,VH.CSO,XA.CSO,RX.CSO>		;029

.SBTTL	Single Line terminal device listing routines

TTLIST:	MOV	#CSRTBL+TT.CSO,R0	;GET THE TT: CSR POINTER	;016
	BR	100$			; JOIN THE COMMON CODE		;016

DLLIST:	MOV	#CSRTBL+DL.CSO,R0	;GET THE DL: CSR POINTER	;016
	BR	100$			; JOIN THE COMMON CODE		;016

KLLIST:	MOV	#CSRTBL+KL.CSO,R0	;GET THE KL: CSR POINTER	;016
	BR	100$			; JOIN THE COMMON CODE		;016

DELIST:	MOV	#CSRTBL+DE.CSO,R0					;016
100$:	CALL	40$			;GET THIS UNITS CSR POINTER	;016
	MOV	R0,-(SP)		;SAVE THE POINTER INTO CSRTBL	;016
	MOV	(R0),R0			;R0 NOW CONTAINES THE CSR	;016
	ADD	#4,R0			;GET THE ONE REG WE WANT	;016
	MOV	(R0),-(SP)		;SAVE THE CURRENT STATUS	;016
	CLR	-(SP)			;GET A FLAG			;016
	BIS	#2,(R0)			;SET THE MXV PROG SPEED BIT	;016
	BIT	#2,(R0)			;DID IT STAY SET?		;016
	BNE	120$			; YES, SO ITS AN MXV		;016
	BIS	#4000,(R0)		;SET THE DLV-E/F PROG BIT	;016
	BIT	#4000,(R0)		;DID IT STAY SET?		;016
	BNE	130$			; YES, SO ITS A DLV-E/F		;016
	TST	(SP)+			;TRASH THE FLAG			;016
110$:	TST	(SP)+			;TRASH THE SPEED WORD		;016
	TST	(SP)+			;TRASH THE CSRTBL POINTER	;016
	RETURN

120$:	DEC	(SP)			;SET A FLAG			;016
130$:	MOV	2(SP),(R0)		;AND PUT IT BACK		;016
	MESSAG	<"Type: ">		;START THE MESSAGE		;016
	TST	(SP)+			;CHECK THE FLAG			;016
	BEQ	140$			;DLV11, SO GO TELL THEM		;016
	MESSAG	<"MXV11">		;TELL THEM what we found	;016
	BR	110$			;  ALL DONE NOW			;016

140$:	MESSAG	<"DLV11-">		;TELL THEM WHAT WE FOUND	;016
	MOVB	#'E,160$		;START WITH THE "E"		;016
	CMP	4(SP),#CSRTBL+DE.CSO	;IS IT A DE DEVICE?		;016
	BHIS	150$			;YES, SO TELL THEM		;016
	INCB	160$			;CHANGE THE "E" TO AN "F"	;016
150$:	MESSAG								;016
160$:	 .ASCIZ	"E"			;TELL THEM			;016
	UNORG
	BR	110$			;  ALL DONE			;016

GLOBAL	<CSRTBL,TT.CSO,DL.CSO,KL.CSO,DE.CSO>

.DSABL	LSB

.SBTTL	DMC/DMR Device listing routines

.ENABL LSB
;
;       The type word is assembled by XMLOOK (INIXMC) & XMPOKE (INIONE)    ;022
;                and contains                                              ;022
;
;	bit 0	=   1	- remote line unit
;	    1	=   2	- local line unit
;	    2	=   4	- high (local) micro processor
;	    3	=  10	- low (remote) micro processor
;	    4   =  20	- DMC/DMR mode (DMR)
;	    5	=  40	- 1 Meg mode (DMR)
;	 8-15	=       - Modem connection (DMR)
;

XMLIST:	MESSAG	<"Type: ">		;Tell them what we found	;016
        PUSH    R1                      ;Make working space                ;022
        MOV     #DMCTBL,R1              ;set ptr to DMC bit proc table     ;022
	MOV	DEV.UN,R0		;GET THE CURRENT UNIT #		;016
	ASL	R0			;MAKE IT TIMES 2		;016
	BIT	BITWRD(R0),XM.TYP	;CHECK THE DMC/DMR BIT		;016
	BEQ	170$			;MUST BE A DMC			;016
        MOV     #DMRTBL,R1              ;reset ptr to DMR bit prc table    ;022
170$:   ADD     #TYPTBL+XM.CSO,R0       ;make R0 the type pointer          ;022
        CALL    BITPRC                  ;execute bit state table           ;022
        POP     R1                      ;restore space                     ;022
        RETURN                          ;done with DMR/DMC reporting       ;022

GLOBAL	<CSRTBL,TYPTBL,XM.CSO,DEV.UN,BITWRD,XM.TYP>

.DSABL	LSB

.SBTTL	DMP/DMV Listing routine

.ENABL LSB
;
;	The TYPTBL entry for the DMP will contain the following:
;
;	bit	value
;	0	Low/High speed select
;	1	Power on boot enable
;	2	Remote load detect enable
;	3	Information is VALID
;	4-6	mode selection (pg 2-19 DMP tech manual)
;	7	mode enable
;	8-15	tributary #
;
;       The above register assembled from multiple hardware registers      ;022
;       by XMLOOK (INIXMC)                                                 ;022
;                                                                          ;022

XDLIST: PUSH    R1                      ;make work space                   ;022
        MESSAG  <"Type: ">              ;Tell them what we found           ;022
	MOV	DEV.UN,R0		;GET THE CURRENT UNIT #		;020
	ASL	R0			;MAKE IT TIMES 2		;020
	ADD	#TYPTBL+XD.CSO,R0	;GET THE TYPE POINTER		;020
        CMPB    PK.SIZ(R5),#DMVSZ       ;DID WE FIND A DMV, OR DMP?        ;022
	BEQ	100$			; DMV, SO DO IT DIFFERENTLY	;020
        MOV     #XDLTBL,R1              ;set ptr to DMP bit proc table     ;022
        CALL    BITPRC                  ;execute state table               ;022
        CMP     #XDLTBE,R1              ;did we print word "address"?      ;022
        BNE     90$                     ;no- so don't number               ;022
75$:    PUSH    R0                      ;SAVE THE POINTER                  ;022
	MOVB	1(R0),R0		;GET THE TRIB ADDRESS		;020
	BIC	#177400,R0		;TRASH THE SIGH EXTEND		;020
	CALLX	DECZER			;AS A DECIMAL VALUE		;020
	MOV	(SP)+,R0		;RESTORE THE POINTER		;020
90$:    MOV     #XDLTB2,R1              ;PT TO 2ND TABLE OF THIS GROUP     ;022
        CALL    BITPRC                  ;EXECUTE IT                        ;022
	BR	200$			;ALL DONE!			;020

100$:	MESSAG	<"DMV">			;THIS IS WHAT WE FOUND		;020
200$:   POP     R1                      ;restore space                     ;022
        RETURN                                                             ;022

GLOBAL	<TYPTBL,DEV.UN,XD.CSO,DMVSZ>					;020

.DSABL	LSB

.SBTTL	Ethernet Device listing routines
.ENABL	LSB

XELIST:	MOV	#XEADDR,R3		;Point to data area		;017
	BR	10$			;Join common code		;017

XHLIST:	MOV	#XHADDR,R3		;Point to data area		;017
10$:	MOV	DEV.UN,R0		;Get controller number		;017
	ASH	#3,R0			;Compute offset into data area	;017
	ADD	R0,R3			;Now point to it		;017
	MESSAG	<"DE">			;First part of message		;017
	MOV	(R3)+,R0		;Get first word of data area	;017
	CALLX	RADZER			;DELUA/DEUNA/DELQA/DEQNA	;017
	MESSAG	<" Address: ">		;Next part of message		;017
	MOV	#5,R0			;Five octets for now		;017
20$:	MOVB	(R3)+,R2		;Get one of the octets		;017
	CALLX	HEXBYT			;Print it in hexadecimal	;017
	TYPE	'-			;Follow it by a dash		;017
	SOB	R0,20$			;Do all five octets		;017
	MOVB	(R3)+,R2		;Get the last octet		;017
	CALLRX	HEXBYT			;Print it and return		;017

GLOBAL	<XEADDR,XHADDR>

.DSABL	LSB
                                                                           ;022
.SBTTL  Bit table processor - output routine                               ;022
.ENABLE LSB                                                                ;022
                                                                           ;022
;+                                                                         ;022
;       BITPRC executes a state table of any length with the format:       ;022
; <ptr to text*><value to equal><1's comp mask><0/next table pc>           ;022
;       The following is the table terminator (x is don't care):           ;022
; <   x        ><     -1       ><       0     ><      0        >           ;022
;                                                                          ;022
;               R0 -->  bit pattern to examine                             ;022
;               R1 -->  State table to use to examine @R0                  ;022
;               call    BITPRC                                             ;022
;                                                                          ;022
;                               R1 points to terminating table line        ;022
;                               R0 & (R0) unchanged                        ;022
;                                                                          ;022
;       What happens is this, for each line in table if (@R0 and mask)=value ;022
;       then the text pointed to is printed. Then if (next table pc)=0     ;022
;       execution is terminated (only if state was true) else the next line ;022
;       in the table is test for terminator and the cycle continues.       ;022
;                                                                          ;022
;                                                                          ;022
;       note text ptr--> (1 byte char count) followed by characters        ;022
;       First text pattern in table is used only online over length condition ;022
;       normal processing begins on second table entry, length check done  ;022
;       before print.                                                      ;022
;+                                                                         ;022
                                                                           ;022
                                                                           ;022
BITPRC: PUSH    R3              ;Make working space                        ;022
        PUSH    R1              ;Save ptr to over len text string ptr      ;022
        PUSH    R0              ;save pointer to orignal pattern           ;022
        PUSH    R4              ;make room again                           ;022
        MOV     (R0),R4         ;get copy of pattern to examine            ;022
5$:     ADD     #TBLWID,R1      ;step processing over 1st entry to begin   ;023
10$:    CMP     #-1,TBEQU(R1)   ;is the next line a terminator?            ;022
        BEQ     30$             ;yes- exit                                 ;022
        MOV     R4,R0           ;get clean copy of orig pattern            ;022
        BIC     TBMASK(R1),R0   ;mask off values we don't care about       ;022
        CMP     TBEQU(R1),R0    ;is it = value in table?                   ;022
        BNE     5$              ;no- just advance to next line             ;023
        MOV     (R1),R0         ;get ptr to BC & TEXT                      ;022
        MOVB    (R0)+,R3        ;get text len to print,pt to first char    ;022
        ADD     TYPEHT,R3       ;add to it current column position         ;022
        CMPB    R3,#80.-1       ;is it over 80 columns?                    ;022
        BLOS    15$             ;no- just print it                         ;022
        PUSH    R0              ;save text ptr                             ;022
        MOV     6(SP),R3        ;get ptr to 1st table entry (here's where used) ;022
        MOV     (R3),R0         ;get ptr to new line (BC) & TEXT           ;022
        INC     R0              ;step over (BC)                            ;022
        CALLX   ASCIZ0          ;print new line text                       ;022
        POP     R0              ;restore ptr to current text               ;022
15$:    CALLX   ASCIZ0          ;print the text, ptr in R0                 ;022
        TST     TBNEXT(R1)      ;test for termination on TRUE              ;022
        BEQ     30$             ;yes- exit from this line                  ;022
        MOV     TBNEXT(R1),R1   ;step table count to next line             ;023
        BR      10$             ;continue cycling                          ;022
                                                                           ;023
30$:    POP     R4              ;restore register                          ;022
        POP     R0              ;restore ptr to pattern                    ;022
        TST     (SP)+           ;clear ptr to first line                   ;022
        POP     R3              ;restore work space                        ;022
        RETURN                                                             ;022
                                                                           ;022
GLOBAL  <ASCIZ0>                                                           ;022
                                                                           ;022

.SBTTL	Device listing routine tables
.MACRO  $       MASK,EQUVALUE,TEXT,NEXT                                    ;022
.DSABL  CRF                                                                ;022
        TBEQU=:2                                                           ;022
        TBMASK=:4                                                          ;022
        TBNEXT=:6                                                          ;022
        TBLWID=:10      ;TABLE LINE WIDTH                                  ;022
.NCHR   $$$$$$,<TEXT>                                                      ;022
.IRP    K,<\$$$$$$+2>                                                      ;022
.ENABL  CRF                                                                ;022
         GENTXT <<K>"'TEXT'">                                              ;022
.ENDM                                                                      ;022
         .WORD  EQUVALUE,^C<MASK>                                          ;022
                                                                           ;022
.IF B   <NEXT>                                                             ;022
        .WORD   .+2                                                        ;022
.IFF                                                                       ;022
        .WORD   NEXT                                                       ;022
.ENDC                                                                      ;022
.ENDM   $                                                                  ;022
                                                                           ;022
.nlist meb
                                                                           ;022
DMCTBL: .WORD   200$,0,-1,.+2           ;Print cr & tabs unconditionally   ;023
        $       0,0,<DMC>                                                  ;022
        $       17,5,<, Local micro, Remote line>                          ;022
        $       17,12,<, Remote micro, Local line>                         ;022
        $       17,6,<, Local>                                             ;022
        $       17,11,<, Remote>                                           ;022
        $       0,-1,< >,0                                                 ;022
                                                                           ;022
DMRTBL: .WORD   200$,0,-1,.+2           ;Print cr & tabs unconditionally   ;023
        $       0,0,<DMR,>                                                 ;022
        $       60,20,< DMR mode, 1 megabaud>                              ;022
        $       60,0,< DMR mode, less than 1 megabaud>                     ;022
        $       60,60,< Local DMC mode>                                    ;022
        $       60,40,< Remote DMC mode>                                   ;022
        $       4000,4000,< Integral modem>,0                              ;023
        $       10000,10000,<, V.35>                                       ;022
        $       40000,40000,<, RS232/423>                                  ;022
        $       100000,100000,<, RS422>                                    ;022
        $       154000,0,<, unknown>                                       ;022
        $       0,0,< Interface>,0                                         ;022
        $       0,-1,< >,0                                                 ;022
                                                                           ;022
XDLTBL:                                                                    ;022
        .WORD   200$,0,-1,.+2           ;Print cr & tabs unconditionally   ;023
        $       0,0,<DMP>                                                  ;022
        $       1,1,<, High>                                               ;022
        $       1,0,<, Low>                                                ;022
        $       0,0,< speed,>                                              ;022
        $       200,0,< Programmable>,100$                                 ;022
        $       220,220,< FDX>                                             ;022
        $       220,200,< HDX>                                             ;022
        $       340,340,< tributary>,xdltbe                                 ;022
        $       340,300,< controller>,100$                                  ;022
        $       177400,400,< >,90$              ;test address = 1          ;022
        $       340,240,<point>,XDLTBE                                     ;022
        $       340,200,<DMC>,XDLTBE                                       ;022
90$:    $       340,240,<point>,100$                                       ;022
        $       340,200,<DMC>,100$                                         ;022
100$:   $       0,0,< mode>,0                                              ;022
XDLTBE: $       0,0,< mode, address >,0                                    ;022
        $       0,-1,< >,0                                                 ;022
                                                                           ;022
XDLTB2:                                                                    ;023
        .WORD   200$,0,-1,.+2           ;Print cr & tabs unconditionally   ;023
        $       2,2,<,>                                                    ;022
        $       2,2,< Boot enable>                                         ;022
        $       4,4,<,>                                                    ;022
        $       4,4,< Load enable>                                         ;022
        $       0,-1,< >,0                                                 ;022
                                                                           ;022
                                                                           ;022
                ;Subsequent line margin spacing control                    ;023
200$:   .BYTE   11,200,11,11,11,40,40,40,40,40,0,0,0,0,0                   ;023
                                        ;PRINT <CR> & 4 TABS (CHAR CT INCL) ;023
        .EVEN                                                              ;023

.DSABL  LSB                                                                ;022
                                                                           ;022
                                                                           ;022

.MACRO	$	ID,TEXT
.DSABL	CRF
.NCHR	$$$$$$,<TEXT>
.IRP	K,<\$$$$$$+2>
.ENABL	CRF
	 GENTXT	<<K>"'TEXT'">
.ENDM
	 .WORD	ID
.ENDM	$

RHDTBL:	$	0,<(RS03)>
	$	1,<(RS03 IL)>
	$	2,<(RS04)>
	$	3,<(RS04 IL)>
	$	020020,<(RP04)>
	$	020021,<(RP05)>
	$	020022,<(RP06)>
	$	020024,<(RM03)>
	$	020025,<(RM02)>
	$	020026,<(RM80)>
	$	020027,<(RM05)>
	$	020042,<(RP07)>
	$	024020,<(RP04 DP)>
	$	024021,<(RP05 DP)>
	$	024022,<(RP06 DP)>
	$	024024,<(RM03 DP)>
	$	024025,<(RM02 DP)>
	$	024026,<(RM80 DP)>
	$	024027,<(RM05 DP)>
	$	024042,<(RP07 DP)>
UNKNOW:	$	-1,<(Unknown)>						;030

.list meb

RMDTBL:	$	0,<(RK06)>
	$	2000,<(RK07)>
	$	-1,<(Unknown)>

RLDTBL:	$	0,<(RL01)>
	$	200,<(RL02)>
	$	-1,<(Unknown)>

RPDTBL:	$	0,<(RP02)>
	$	20000,<(RP03)>
	$	-1,<(Unknown)>

MMDTBL:	$	10,< (TU16 @TM02 #0)>
	$	11,< (TE16 @TM02 #0)>
	$	12,< (TU45 @TM02 #0)>
	$	14,< (TU77 @TM02 #0)>
	$	50,< (TU16 @TM03 #0)>
	$	51,< (TE16 @TM03 #0)>
	$	52,< (TU45 @TM03 #0)>
	$	54,< (TU77 @TM03 #0)>
	$	101,< (TU78 @TM78 #0)>
	$	-1,< (Unknown)>

MSDTBL:
.ASSUME	$TS11	EQ	.-MSDTBL	;004
	GENTXT	<"(TS11)">		;004
.ASSUME	$TU80	EQ	.-MSDTBL	;004
	GENTXT	<"(TU80)">		;004
.ASSUME	$TK25	EQ	.-MSDTBL	;004
	GENTXT	<"(TK25)">		;004
.ASSUME	$TS05	EQ	.-MSDTBL	;006
	GENTXT	<"(TS05)">		;006
.ASSUME	$TSEND	EQ	.-MSDTBL	;004
	GENTXT	<"(Unknown)">		;004

MSXTBL:
	GENTXT	<"enabled">	;Features enabled message	;006
	GENTXT	<"disabled">	;Features disabled message	;006

DSKUID:	$DISKS
.IF	GT	IDX$'NAME-IDX$DF
.IF	NE	IDX$'NAME-IDX$DU
	 .WORD	NAME'UMID
GLOBAL	<NAME'UMID>
.IFF
	 .WORD	0
.ENDC
.IFF
	 .WORD	0
.ENDC
.ENDM

;+									;025
;	ECO Option - List rev levels of all UQSSP controllers		;025
;-									;025
OPTION	EC,O								;025

.ENABL	LSB								;025

	REGSCR			;Save registers.			;025
	CLR	R1		;R1 is used as a flag saying that at	;025
				; least one controller has been found,	;025
				; and that the listing header has been	;025
				; printed.				;025
	MOVB	#'R,RUNAM	;Reset controller name to RUn:		;025
	CLR	R5		;Start with controller zero.		;025
10$:	MOV	CSRTBL+RU.CSO(R5),R3 ;Is there a controller out there?	;025
	BPL	60$		;No, check for others.			;025
	MOV	R5,R0		;Copy controller number *2		;025
	ASR	R0		;Now * 1				;025
	CMP	R0,#DU.MAX	;Is this a disk or tape controller?	;025
	BLO	20$		;Disk, so RUx: is correct		;025
	MOVB	#'M,RUNAM	;Tape, change RUx: to MUx:		;025
	SUB	#DU.MAX,R0	;...fix controller number too		;025
20$:	ADD	#'0,R0		;Convert to ASCII			;025
	MOVB	R0,RUNUM	;Store it into message			;025
	TST	R1		;Have we already found at least one?	;025
	BNE	30$		;Yes, so skip the header stuff.		;025
	MESSAG	<<12>"Name"<11>"Address   SW Rev  HW Rev"<200>>;025
	COM	R1		;Say we've printed header.		;025
30$:	CALLX	MESSAGE,R5,RUNAM;Print out controller name and tab.	;025
	MOV	R3,R0		;Get CSR address...			;025
	CALLX	OCTWRD		; ...and print it out.			;025
	CALLX	TYPTAB		;Print out a tab.			;025
	MOV	UQ$REV(R5),R3	;Get revision level.			;025
	CMP	R3,#-1		;Is it -1?				;025
	BNE	50$		;No, so we think it's in revision.	;025
	MESSAG	<"Not Supported"<200>>					;025
	BR	60$		;Go to the next controller.		;025

50$:	CLR	R0		;Set SW revision into R0...		;025
	BISB	R3,R0		; ...without sign-extend evil.		;025
	CALL	100$		;Print decimal number or "None".	;025
	CALLX	TYPTAB		;And then, a tab.			;025
	SWAB	R3		;Now, go for the HW revision.		;025
	CLR	R0		;Same song, second verse!		;025
	BISB	R3,R0		;	...				;025
	CALL	100$		;	...				;025
	CALLX	TYPECR		;And then, go to the next line.		;025
60$:	TST	(R5)+		;Set next UQ port controller number * 2	;025
	CMP	R5,#<DU.MAX+MU.MAX>*2	;More to do?			;025
	BLO	10$		;Yes, go to it				;025
	TST	R1		;Did we find any controllers?		;025
	BNE	70$		;Yes, so just go back.			;025
	MESSAG	<"No MSCP or TMSCP controllers on this system."<200>>	;025
70$:	RETURN		 	;Otherwise, just go back.		;025

100$:	BNE	110$		;If there's something there, print it.	;025
	MESSAG	<"   None">	;Otherwise, say there's no rev...	;025
	RETURN			; ...and then go back.			;025

110$:	CALLX	DECPRT		;Print the rev as a decimal number.	;025
	RETURN			;And, go back.				;025

	TMPORG	HARCTL							;025
RUNAM:	.ASCII	"RU"		;This is where the controller name is	;025
RUNUM:	.ASCIZ	"0:"<11>	; constructed for printing.		;025
	.EVEN								;025
	UNORG								;025

GLOBAL	<UQ$REV,DU.MAX,MU.MAX>						;025

.DSABL	LSB								;025

OPTION	DI,SABLE

.ENABL	LSB

	CALL	GETDV,R5	;GET DEVICE NAME
	 GENTXT	<<12>"    Controller to disable? ">
	CMP	PK.NAM(R3),#"TT	;TRYING TO DISABLE THE CONSOLE?
	BNE	10$		;NO, IT'S SAFE
	MESSAGE	<"    Cannot disable console terminal"<200>>
	RETURN

10$:	BIT	#1,SETNEW(R2)	;ALREADY DISABLED?
	BEQ	30$		;NO
	MESSAG	<"    Controller already disabled"<200>>
20$:	RETURN

30$:	CALL	REMCHG		;UNDO OLD CHANGE
	INC	SETNEW(R2)	;TURN ON THE DISABLE BIT
ADDCHG:	CALL	CHKCHG		;CHECK FOR CHANGE
	ADC	CHGCNT		;INCREMENT COUNT IF ANY
	RETURN


OPTION	EN,ABLE

	CALL	GETDV,R5	;GET THE DEVICE
	 GENTXT	<<12>"    Controller to enable? ">
	BIT	#1,SETNEW(R2)	;DISABLED NOW?
	BNE	40$		;YUP
	MESSAG	<"    Controller not disabled"<200>>
	RETURN

40$:	CALL	REMCHG		;UNDO OLD CHANGE
	DEC	SETNEW(R2)	;TURN OFF THE FLAG
	BR	ADDCHG		;GO CHECK FOR CHANGE

OPTION	CS,R

	CALL	GETDV,R5	;GET DEVICE
	 GENTXT	<<12>"    Controller with non-standard address? ">
	MOVB	(R1),PREST1	;ANSWER IN LINE?
	BNE	70$		;YES, USE IT
50$:	TSTB	PREST1		;ANSWER ALREADY GIVEN?
	BNE	20$		;YES, DON'T ASK AGAIN
	CALLX	ASKER,R5	;ASK FOR NEW ADDRESS
	 .WORD	60$
	 GENTXT
	  .ASCII "    Type the 6 digit octal address of the lowest register in the"<200>
	  .ASCII "    controller's CSR set.  Type 'RE' to remove a non-standard"<200>
	  .ASCII "    address."<200>
60$:	  .ASCIZ <177>"    New controller address? "
	 UNORG
	CMPB	(R1),#'Z-100	;CTRL/Z ?
	BEQ	20$		;YES, GET OUTTA HERE
70$:	CLR	R0		;SET A NEW NON-STANDARD OF 0
	CALL	REMCHK		;ANSWER 'REMOVE' ?
	BCC	90$		;YUP
	CALLX	OCTINP		;CONVERT INPUT TO OCTAL
	BNE	80$		;NOT VALID
	BIT	R0,#1		;EVEN?
	BNE	80$		;NO
	CMP	R0,#160000	;IN RANGE?
	BHI	90$		;YUP
80$:	MESSAG
	 .ASCIZ	"    Address must be an even octal number greater than 160000"<200>
	 UNORG
	BR	50$		;TRY AGAIN

90$:	CMP	PK.NAM(R3),"XD	;IS THIS CSR CHANGE FOR AN XD CONTROLLER?
	BEQ	95$		;YES, INDICATE A CHANGE REGARDLESS
	CALL	REMCHG		;REMOVE OLD CHANGE
	BIC	#177776,SETNEW(R2) ;REMOVE OLD CSR ADDRESS
	BIS	R0,SETNEW(R2)	;PUT IN THE NEW ONE
	BR	ADDCHG		;SET UP NEW CHANGE

; IT'S POSSIBLE THAT WE HAVE A DMP LOCATED AT THE DMV RANK OR VICE-VERSA
; IF SO THEN WE HAVE TO FORCE A RE-BOOT TO DETERMINE PACKET PARAMETERS.
95$:	SUB	PK.CSO(R3),R2	;RE-CREATE CONTROLLER # FROM TABLE INDEX.
	ASR	R2		;R2 NOW= CONTROLLER # OF THE XD DEVICE
	CLR	R0		;USE REGISTER 0 AS A BIT MASK OF CONTROLLERS
	INC	R0		;SET BIT #1 TO INDICATE CONTROLLER 0
	ASH	R2,R0		;	AND SHIFT TO BIT # OF CONTROLLER.
	BIS	R0,XDCHG	;NOW SAY THAT CONTROLLER HAS A CHANGE PENDING.
	BIC	#177776,SETNEW(R2) ;REMOVE OLD XD CSR ADDRESS
	BIS	R0,SETNEW(R2)	;PUT IN THE NEW ONE
	RETURN			;BACK TO "suboption?" PROMPT

XDCHG:	.WORD	0		;XD CHANGES, EACH BIT CORRESPONDS TO A
				;CONTROLLER NUMBER. MAX OF 16.


REMCHG:	CALL	CHKCHG		;CHECK FOR CHANGES (C=1 IF SO)
	SBC	CHGCNT		;IF IT USED TO BE CHANGED, REMOVE INDICATION
105$:	RETURN

CHKCHG:	CMP	SETNEW(R2),SETTBL(R2) ;ANY OLD CHANGE?
	BNE	100$		;YES, GO SET CARRY
	CMPB	VECNEW+1(R2),VECTBL+1(R2) ;REALLY?
	BEQ	110$		;NO CHANGE, C=0
100$:	SEC			;CHANGE, C=1
110$:	RETURN

.DSABL	LSB

OPTION	VEC,TOR

.ENABL	LSB

5$:	CALL	GETDV,R5	;GET A DEVICE
	 GENTXT	<<12>"    Card Reader with non-standard vector? ">	;014
	CMPB	PK.NAM(R3),#'C	;Card reader device?			;014
..VEC::	BNE	45$		;No, so give error.			;014
	MOVB	(R1),PREST1	;ANSWER IN LINE?
	BNE	30$		;YES, USE IT
10$:	TSTB	PREST1		;ANSWER ALREADY GIVEN?
	BNE	60$		;YES, DON'T ASK AGAIN
	CALLX	ASKER,R5	;GET NEW VECTOR
	 .WORD	20$
	 GENTXT
	  .ASCII "    Type the 3 digit octal address of the lowest vector for"<200>
	  .ASCII "    this Card Reader.  Type 'RE' to remove a non-standard vector."<200>
20$:	  .ASCIZ <177>"    New vector address? "
	 UNORG
	CMPB	(R1),#'Z-100	;CTRL/Z ?
	BEQ	60$		;YES, GET OUT OF HERE
30$:	CLR	R0		;SET A NEW NON-STANDARD OF 0
	CALL	REMCHK		;IS IT 'REMOVE'?
	BCC	50$		;YES, NEW ONE IS 0
	CALLX	OCTINP		;NO, GET A NUMBER
	BNE	40$		;BAD NUMBER
	BIT	R0,#1		;ODD?
	BNE	40$		;YES, EVIL
	CMP	R0,#1000	;TOO HIGH?
	BLO	50$		;NO, OK
40$:	MESSAG								;014
	 .ASCIZ	"    Vector must be an even octal number less than 1000"<200>
	 UNORG
	BR	10$		;TRY AGAIN

45$:	MESSAG
	 .ASCIZ	"    The Vector option is only valid for CR or CD devices"<200>
	 UNORG
	BR	5$

50$:	CALL	REMCHG		;REMOVE CHANGE IF POSTED
	ASR	R0		;SHIFT IT
	MOVB	R0,VECNEW+1(R2)	;PUT IT IN TABLE
	JMP	ADDCHG		;POST NEW CHANGE, IF ANY

60$:	RETURN

.DSABL	LSB

GLOBAL	<VECTBL>

OPTION	DM,11BB

.ENABL	LSB

	CALL	CHKDM		;CHECK OUT THE DM11BB CHANGES
	SUB	R0,CHGCNT	;NO CHANGES YET
	CLR	R5		;START WITH DM0
10$:	MESSAGE	<<177>"    DH for DM">
	MOV	R5,R0		;GET THE DM UNIT * 2
	ASR	R0		; *1
	CALLX	DECZER		;TYPE IT
	MESSAGE	<" (">		;SPACER FOR WHAT IT IS
	MOVB	DMTTBL(R5),R0	;GET THE ASSOCIATED DH UNIT
	BMI	20$		;NONE!
	CALLX	DECZER		;GOT ONE, TYPE IT
	BR	30$

20$:	TYPE	<'?>		;UNKNOWN FOR NOW
30$:	MOV	#CSRTBL,R1	;SEE IF THE DM EXISTS
	ADD	#DM.CSO,R1	;POINT TO CSR'S FOR DM11BB'S
	ADD	R5,R1		;THIS UNIT'S CSR
	TST	(R1)		;IS IT THERE?
	BNE	40$		;YUP
	MESSAGE	<", NX">	;NO, ADD NOTATION
40$:	MESSAGE	<")? ">
	CALLX	GETIN		;GET AN ANSWER
	CMPB	(R1),#'?	;NEED HELP?
	BNE	50$		;NO
	MESSAGE
	 .ASCII	"    Type the unit number of the DH11 controller associated with"<200>
	 .ASCII	"    this DM11BB.  Type <CR> to use the unit indicated."<200>
	 .ASCIZ	"    Type CONTROL/Z if there are no more DM11BB's."<200>
	 UNORG
	BR	10$

50$:	CMP	(R1),#'Z-100	;NO MORE?
	BNE	70$		;NOT TRUE, TRY FOR A REAL ANSWER
60$:	MOVB	#-1,DMTTBL(R5)	;NO MORE. SET THE REMAINDER TO ?
	TST	(R5)+		;NEXT DM11BB
	CMP	R5,#16.*2	;DONE?
	BLO	60$		;NO
	BR	160$		;YES, GET OUT OF SUBOPTION

GLOBAL	<CSRTBL,DM.CSO>

70$:	CMP	(R1),#12	;LEAVE IT ALONE?
	BEQ	80$		;YES, LEAVE IT ALONE IN R0
	CALLX	DECINP		;NO, GET A DH NUMBER
	BCS	110$		;INVALID RESPONSE
	CMP	R0,#15.		;0 TO 15?
	BHI	110$		;NOPE, INVALID
80$:	TST	R0		;LEAVE A '?' ALONE?
	BMI	120$		;YES, LEAVE IT ALONE
	CLR	R1		;NO, CHECK FOR DUPLICATIONS EARLIER
90$:	CMP	R1,R5		;UP TO THE CURRENT DM11BB?
	BHIS	120$		;YES, NO DUPLICATIONS
	CMPB	R0,DMTTBL(R1)	;DOES THIS REPEAT?
	BEQ	100$		;YES, ERROR
	TST	(R1)+		;NEXT CHECKER
	BR	90$		;TRY FOR MORE

100$:	MESSAGE	<"    DH11 already assigned to a DM11BB"<200>>
	BR	10$		;TRY AGAIN

110$:	MESSAGE	<"    Invalid response"<200>>
	BR	10$		;TRY AGAIN

120$:	MOVB	R0,DMTTBL(R5)	;SET THE NEW VALUE
	TST	(R5)+		;NEXT DM11BB INDEX
	MOV	R5,R1		;NOW CHECK FOR DUPLICATIONS LATER
130$:	CMP	R1,#16.*2	;DONE THE TABLE?
	BHIS	150$		;YUP, NO MORE DUPLICATIONS
	CMPB	R0,DMTTBL(R5)	;DOES THE NEW ONE DUPLICATE?
	BNE	140$		;NO
	MOVB	#-1,DMTTBL(R5)	;YES, DEASSIGN THIS DM11BB
140$:	TST	(R1)+		;NEXT CHECK
	BR	130$

150$:	CMP	R5,#16.*2	;DONE ASKING?
	BLO	10$		;NO
160$:	CALL	CHKDM		;YES, COUNT THE NUMBER OF CHANGES
	ADD	R0,CHGCNT	;AND UPDATE THE COUNTER
	RETURN

CHKDM:	CLR	R0		;0 CHANGES SO FAR
	MOV	#DMTTBL,R1	;POINT TO OUR TABLE
	MOV	#TYPTBL,R2
	ADD	#DM.CSO,R2	;POINT TO ORIGINAL TABLE
	MOV	#16.,R3		;16 WORDS TO CHECK
170$:	CMP	(R1)+,(R2)+	;ANY DIFFERENCE?
	BEQ	180$		;NO
	INC	R0		;YES
180$:	SOB	R3,170$		;DO IT ALL
	RETURN

.DSABL	LSB

GLOBAL	<TYPTBL,DM.CSO>

OPTION	HE,RTZ

.ENABL	LSB

	TSTB	FLGGPK		;Is this a GPK?				;021
	BPL	5$		;No					;021
	MESSAGE	<"Not a valid option on the GPK"<200>>			;021
	RETURN			;exit					;021

5$:	MOVB	(R1),PREST1	;SAVE PRESET ANSWER FLAG
	BNE	30$		;IF GIVEN, USE IT
10$:	CALLX	ASKER,R5	;ASK
	 .WORD	20$		;SHORT TEXT
	 GENTXT
	  .ASCII "    The AC line hertz may be either 50Hz or 60Hz."<200>
	  .ASCII "    Type the new value, either '50' or '60'."<200>
20$:	  .ASCIZ <177>"    New AC line hertz? "
	 UNORG
	CMPB	(R1),#'Z-100	;CTRL/Z?
	BEQ	50$		;YES, QUIT
	CMPB	(R1),#12	;<LF>?
	BEQ	50$		;YES, QUIT
30$:	CALLX	DECINP		;NO, GET A DECIMAL NUMBER
	BNE	40$		;BAD NUMBER
	CMP	R0,#60.		;IS IT 60?
	BEQ	60$		;YES, GOOD
	CMP	R0,#50.		;NO, IS IT 50?
	BEQ	60$		;YES, GOOD
40$:	MESSAGE	<"    Hertz must be 50 or 60."<200>>
	TSTB	PREST1		;LOOP HERE?
	BEQ	10$		;YES
50$:	RETURN			;NO, DONE

60$:	CMP	NEWFRQ,LINFRQ	;IS THERE CURRENTLY A CHANGE PENDING?
	BEQ	70$		;NO
	DEC	CHGCNT		;YES, REMOVE IT
70$:	MOV	R0,NEWFRQ	;SET THE NEW VALUE
	CMP	R0,LINFRQ	;IS THERE NOW A CHANGE?
	BEQ	80$		;NO
	INC	CHGCNT		;YES, INDICATE IT
80$:	RETURN

.DSABL	LSB

GLOBAL	<LINFRQ,FLGGPK>							;021

OPTION	SW,ITCH

.ENABL	LSB

	MOVB	(R1),PREST1	;CHECK FOR PRESET VALUE
	BNE	30$		;IF PRESENT, USE IT
10$:	CALLX	ASKER,R5	;ASK
	 .WORD	20$		;SHORT FORM
	 GENTXT
	  .ASCII "    Type 'ENABLE' to enable use of the console switches."<200>
	  .ASCII "    Type 'DISABLE' to disable all use of the switches."<200>
	  .ASCII "    Type 'VOLATILE' if the switch register loses its contents"<200>
	  .ASCII "    after power failure.  The switches will be used for"<200>
	  .ASCII "    all functions except power fail recovery."<200>
20$:	  .ASCIZ <177>"    Switch register? "
	 UNORG
	CMPB	(R1),#'Z-100	;CTRL/Z?
	BEQ	50$		;YES, QUIT
	CMPB	(R1),#12	;<LF>
	BEQ	50$		;YES, QUIT
30$:	CALLX	GETUNQ,R5	;CHECK THE ANSWER
	 GENTXT
	 UNQTXT	<V\OLATILE>	;0 VOLATILE
	 UNQTXT	<E\NABLE>	;2 ENABLE
	 UNQTXT	<D\ISABLE>	;4 DISABLE
	 .BYTE	0
	 UNORG
	BCS	40$		;ERROR
	TSTB	(R1)		;END OF LINE?
	BEQ	60$		;YES, USE THE ANSWER
40$:	MESSAGE	<"    Options are 'ENABLE', 'DISABLE', or 'VOLATILE'"<200>>
	TSTB	PREST1		;LOOP?
	BEQ	10$		;YES
50$:	RETURN

60$:	ASR	R0		;COMPUTE RESULT (0, 1, OR 2)
	DEC	R0		;-1 VOLATILE, 0 ENABLE, 1 DISABLE
	CMP	NEWSWT,SWTREG	;IS THERE CURRENTLY A CHANGE?
	BEQ	70$		;NO
	DEC	CHGCNT		;YES, REMOVE IT
70$:	MOV	R0,NEWSWT	;SET UP THE CHANGE
	CMP	R0,SWTREG	;IS THERE NOW A CHANGE?
	BEQ	80$		;NO
	INC	CHGCNT		;YES, COUNT IT
80$:	RETURN

.DSABL	LSB

GLOBAL	<SWTREG>


OPTION	DD,NULL								;028+

.ENABL	LSB

	MOVB	(R1),PREST1	;Has an answer already been supplied?
	BNE	30$		;If so, try it.
10$:	CALLX	ASKER,R5	;Otherwise, ask the question.
	 .WORD	20$		;Pointer to "short form" answer.
	 GENTXT
	  .ASCII <12>
	  .ASCII "    Type 'ENABLE' to enable the use of the Diagnostic Display"<200>
	  .ASCII "      by the null job."<200>
	  .ASCII "    Type 'DISABLE' to disable it; this will leave the display blank"<200>
	  .ASCII "      during normal timesharing."<200>
20$:	  .ASCIZ <177><12>"    Idle display? "
	 UNORG
	BEQ	50$		;Ctrl/Z or <LF> was entered, so just quit.
30$:	CALLX	GETUNQ,R5	;Otherwise, check the answer.
	 GENTXT
	 UNQTXT	<E\NABLE>	;0 = Enable
	 UNQTXT	<D\ISABLE>	;2 = Disable
	 .BYTE	0
	 UNORG
	BCS	40$		;Oops, not a legal option! Ask again.
	TSTB	(R1)		;Did it match completely?
	BEQ	60$		;Yup, answer was OK.  R0 = either 0 or 2.
40$:	MESSAGE	<"    Options are 'ENABLE' and 'DISABLE'"<200>>
	TSTB	PREST1		;Try again?
	BEQ	10$		;Yes.
50$:	RETURN

60$:	CMP	R0,J11LTS	;Did anything change?
	BEQ	70$		;Nope, so just go back.
	MOV	R0,J11LTS	;Otherwise, save their new preference.
	INC	CHGCNT		;Indicate that a change was made.
70$:	RETURN			;Go back for more.

GLOBAL	<J11LTS>

.DSABL	LSB								;028-


OPTION	RE,SET

.ENABL	LSB

	CLR	R2		;START WITH INDEX 0
	MOV	SETSIZ,R1	;R1 = NUMBER TO DO
10$:	CALL	REMCHG		;REMOVE CHANGE
	CLR	SETNEW(R2)	;REMOVE USER CSR, USER DISABLE
	CLRB	VECNEW+1(R2)	;REMOVE USER VECTOR
	CALL	ADDCHG		;SET IF NOW CHANGED
	ADD	#2,R2		;NEXT INDEX
	SOB	R1,10$		;DO 'EM ALL
	MOV	#-1,R3		;RESET USER-SPECIFIED UNIT TYPES
	CLR	R0		;R0 = OFFSET FROM TABLE START
20$:	CALL	CHGMR0		;CHANGE UMID, OFFSET IN R0
	ADD	#2,R0		;SKIP TO NEXT LEGAL OFFSET
	CMP	R0,#DMTTBL-MIDNEW ;UP TO FOLLOWING TABLE?
	BLO	20$		;NO, REPEAT
	CMP	@#B.JMP,#137	;UNMODIFIED BOOT (I.E. TRUNCATED SCAN)?
	BNE	50$		;NO
	MOV	#-1,RSTFLG	;YES, REBOOT TO SCAN ALL DEVICES
50$:	RETURN

.DSABL	LSB

OPTION	UN,ITS

.ENABL	LSB

	MOVB	(R1),PREST1	;REMEMBER WHETHER THERE'S A PRESET ANSWER
	BNE	40$		;DON'T ASK IF SO
10$:	TSTB	PREST1		;WAS ANSWER PRESET?
	BNE	30$		;YES, DON'T ASK AGAIN
	CALLX	ASKER,R5	;ASK FOR DISK TYPE  **$DISKS**
	 .WORD	20$
	 GENTXT
	  .ASCII "    Legal answers are DS and DK."			;014
20$:	  .ASCIZ <200>"    Disk to set units for? "
	 UNORG
	BNE	40$		;SKIP IF NOT LF OR ^Z
30$:	RETURN			;LF OR ^Z -- EXIT THE SUBOPTION

MAXUNT:	.WORD	0		;Save a spot for the maximum # units....
40$:	CMPB	(R1),#'R	;WAS THE FIRST LETTER OF USERS RESPONSE 'R'?
	BNE	50$		;NO, THEN WE DON'T HAVE TO CHANGE IT
	MOVB	#'D,(R1)	;CHANGE 'R' TO A 'D'
50$:	MOV	(R1)+,R0	;FETCH ALL OF USERS RESPONSE
	MOV	#DSKNAM,R5	;POINT TO TABLE OF DISK NAMES
60$:	CMP	R0,(R5)+	;MATCH?
	BEQ	80$		;YES, PROCEED
	TST	(R5)		;ANY MORE DISKS?
	BNE	60$		;YES, KEEP LOOKING
70$:	MESSAGE	<"    Can't set units for that device."<200>>
	BR	10$		;ASK AGAIN UNLESS ANSWER WAS PRESET

80$:	SUB	#DSKNAM+2,R5	;REDUCE R5 TO DISK INDEX
	TST	NAMTBL(R5)	;CAN WE SET UNITS FOR THAT DISK?
	BEQ	70$		;NO -- PRINT ERROR MESSAGE

GLOBAL	<DSKNAM>

	CMPB	(R1),#':	;WAS DISK FOLLOWED BY COLON?
	BNE	90$		;NO, CHECK FOR A NUMBER
	INC	R1		;SKIP THE COLON
	MOVB	(R1),PREST1	;REQUIRE END OF INPUT AFTER COLON
	BNE	130$		;ELSE BAD UNIT NUMBER FORMAT (NO RETRY)
90$:	MOVB	@SUBUNT(R5),R0	;GET MAX NUMBER OF SUBUNITS FOR THIS CNTRLR
	MOV	R0, MAXUNT	;SAVE FOR LIMIT CHECK BELOW
	MOV	R1,-(SP)	;SAVE OUR TEXT POINTER
	MOV	#110$,R1	;GET THE ADDRESS TO STORE THE TEXT
	CALLX	DECSTR		;  AND CONVERT THE UNIT TO AN ASCII STRING.
	MOV	(SP)+,R1	;RESTORE OUR TEXT POINTER
	MOVB	(R1),PREST1	;REMEMBER WHETHER ANSWER WAS GIVEN
	BNE	120$		;SKIP QUESTION IF SO
100$:	TSTB	PREST1		;PRESET ANSWER?
	BNE	30$		;YES -- ALL DONE
	CALLX	ASKER,R5	;GET UNIT NUMBER
	 GENTXT	<"      Unit? ">
	 GENTXT
	 .ASCII	"      Set type of which unit (0-"
110$:	 .ASCIZ	"??????), or <CR> to exit? "
	 UNORG
	BCS	10$		;^Z -- ASK FOR NEW DISK TYPE
	BEQ	30$		;LF -- ALL DONE
120$:	CALLX	DECINP		;PARSE THE NUMBER
	BEQ	140$		;A GOOD NUMBER
	CMPB	(R1)+,#':	;COLON LEGAL HERE
	BEQ	140$
	CMPB	-(R1),#40	;SO IS SPACE
	BEQ	140$
130$:	MESSAGE	<"      Invalid unit number"<200>>
	BR	100$		;YES.  WE'RE GOING TO TRY AGAIN.

140$:	CMPB	R0, MAXUNT	;COMPARE WITH LIMIT FOR THIS DISK
	BHIS	130$		;TOO HIGH -- ERROR
	MOV	R0,R4		;SAVE UNIT NUMBER
	ASL	R4		;DOUBLE IT
	TSTB	(R1)		;A PRESET ANSWER HERE?
	BEQ	ASKTYP		;NO, ASK TYPE OF UNIT
150$:	CMPB	(R1)+,#40	;LOOK FOR END OF SPACES
	BEQ	150$		;WE HAVEN'T REACHED THEM YET
	DEC	R1		;MOVE BACK TO THE NON-SPACE CHARACTER
	BR	200$		;USE AS DEFAULT ANSWER

ASKTYP:	MESSAGE	<<11>"Type of this unit? ">
	CALLX	GETIN
	CMPB	(R1),#'Z-100	;^Z INPUT?
	BEQ	100$		;YES -- BACK UP TO "UNIT?"
	CMPB	(R1),#'?	;"?" FOR HELP?
	BNE	200$		;NO -- PARSE A LEGITIMATE ANSWER

GLOBAL	<SUBUNT>

160$:	MESSAGE	<<11>"Legal answers are: ">
	MOV	NAMTBL(R5),R3	;POINT TO TABLE OF NAMES
170$:	MOVB	(R3)+,R2	;GET ONE BYTE
	CMPB	R2,#377		;377 BYTE DELIMITS CHOICES
	BEQ	180$
	CALLX	TYPE		;ELSE TYPE THE CHARACTER
	BR	170$		;AND REPEAT

180$:	TSTB	(R3)		;IS THIS THE END OF THE LIST?
	BEQ	190$		;YES -- FINISH THE MESSAGE
	MESSAGE	<", ">		;NO -- SEPARATE WITH COMMA-SPACE
	BR	170$		;PRINT NEXT CHOICE

190$:	MESSAGE
	 .ASCII	","<200><11>"REMOVE to not specify any unit type,"<200>
	 .ASCIZ	<11>"or <CR> for the type of the unit now attached."<200>
	UNORG
	BR	ASKTYP		;GO GET AN ANSWER

200$:	CMPB	(R1),#12	;LF?
	BEQ	240$		;YES, USE CURRENT UNIT
	CALL	REMCHK		;'REMOVE'?
	BCS	210$		;NO -- MAYBE IT'S A REAL ANSWER
	;CLC			;YES -- INDICATE IT'S COMPLETELY SPECIFIED
	MOV	#-1,R3		;USE MASSBUS ID OF -1 FOR 'NO SET' OPTION
	BR	260$		;GO PROCESS
210$:	MOV	NAMTBL(R5),220$	;POINTER TO LEGAL RESPONSES
	CALLX	GETUNQ,R5	;CHECK FOR ONE
220$:	 .WORD	0		;FILLED IN WITH POINTER TO LEGAL RESPONSES
	BCC	230$		;LEGAL RESPONSE -- USE IT
	MESSAGE	<<11>"Not a legal unit type for this device."<200>>
	BR	ASKTYP		;GET ANOTHER INPUT

230$:	ADD	MIDTBL(R5),R0	;USE RESPONSE NUMBER AS INDEX INTO TABLE
	SEC			;INDICATE IT MAY NOT BE COMPLETELY SPECIFIED
	BR	250$		;GO LOAD MASSBUS ID OF THAT UNIT TYPE

240$:	MOV	DSKMID(R5),R0	;POINT TO MASSBUS ID TABLE FOR DEVICE
	ADD	R4,R0		;INDEX BY UNIT*2
	CLC			;INDICATE IT'S COMPLETELY SPECIFIED
250$:	MOV	(R0),R3		;LOAD MASSBUS ID TO USE
260$:	CALL	@SPCTBL(R5)	;DO ANY SPECIAL PROCESSING FOR CONTROLLER TYPE
	CALL	CHGMID		;CHANGE UMID FOR DEVICE(R5) UNIT(R4) TO R3.
	BR	100$		;NOW ASK FOR TYPE OF ANOTHER UNIT

.DSABL	LSB

GLOBAL	<DSKMID>

; CHGMID -- ROUTINE TO CHANGE UMID SPECIFIED FOR DISK WITH IDX IN R5,
; UNIT IN R4, TO VALUE GIVEN IN R3.  THIS ROUTINE INCREMENTS OR DECREMENTS
; THE GLOBAL CHANGE COUNT, AS APPROPRIATE.

CHGMID:	CALL	IDXMID		;GENERATE INDEX IN R0 INTO UMID TABLES
CHGMR0:	CMP	MIDNEW(R0),UMIDST(R0) ;WAS THERE A PREVIOUS CHANGE?
	BEQ	10$		;NO
	DEC	CHGCNT		;YES -- DECREMENT CHANGE COUNT
10$:	CMP	R3,UMIDST(R0)	;IS NEW VALUE A CHANGE?
	BEQ	20$		;NO
	INC	CHGCNT		;YES -- INCREMENT CHANGE COUNT
20$:	MOV	R3,MIDNEW(R0)	;MAKE THE CHANGE
	RETURN

; IDXMID -- GENERATE INDEX (IN R0) INTO UMID TABLE FOR DISK(R5), UNIT(R4)

IDXMID:	MOV	R5,R0		;R0 = 2*UNIT
	SUB	#IDX$DF+2,R0	;FIRST DISK FOLLOWS DF:
	ASH	#3,R0		;EIGHT UNITS PER CONTROLLER
	ADD	R4,R0		;ADD 2* UNIT NUMBER
	RETURN

	TMPORG	HARCTL

MIDTBL:	$DISKS
.IF	GT	IDX$'NAME-IDX$DF
.IF	LT	IDX$'NAME-IDX$DL					;014
	.WORD	NAME'MID
.IFF
	.WORD	0
.ENDC
.IFF
	.WORD	0
.ENDC
.ENDM

NAMTBL:	$DISKS
.IF	GT	IDX$'NAME-IDX$DF
.IF	LT	IDX$'NAME-IDX$DL					;014
	.WORD	NAME'NAM
.IFF
	.WORD	0
.ENDC
.IFF
	.WORD	0
.ENDC
.ENDM

SPCTBL:	$DISKS
.IF	GT	IDX$'NAME-IDX$DF
.IF	LT	IDX$'NAME-IDX$DL					;014
	.WORD	NAME'SPC
.IFF
	.WORD	0
.ENDC
.IFF
	.WORD	0
.ENDC
.ENDM

DSMID:	.WORD	0,2		;RS03, RS04
DKMID:	.WORD	0,2		;RK05J, RK05F

DSNAM:	UNQTXT	<RS03>
	UNQTXT	<RS04>
	.BYTE	0
DKNAM:	UNQTXT	<RK05J>
	UNQTXT	<RK05F>
	.BYTE	0
	.EVEN

	UNORG

; SPECIAL CASE ROUTINES
;	R3 = MASSBUS ID
;	R4 = UNIT*2
;	R5 = DISK INDEX
; CALL XXSPC
;	R3 = MASSBUS ID (POSSIBLY CHANGED)
;	R0 RANDOM

; RS03/RS04 -- IS THE DISK INTERLEAVED? (MASSBUS ID BIT 0)

.ENABL	LSB

DSSPC:	BCC	10$		;DON'T ASK IF IT'S COMPLETELY SPECIFIED
	CALLX	YESNO,R5	;ASK IF IT'S INTERLEAVED
	 GENTXT	<<11>"Interleaved? ">
	 GENTXT	<<11>"Does this disk have interleaved sectors? ">
	 BR	ASKTYP		;^Z -- BACK TO 'TYPE?' QUESTION
	 NOP			;LF = NO
	 RETURN			;NO -- LEAVE R3 ALONE
	BIS	#1,R3		;YES -- TURN ON BIT 0
10$:	RETURN			;ALL DONE

.DSABL	LSB

; RK05J/RK05F -- MAKE SURE RK05F'S ALWAYS COME IN PAIRS

.ENABL	LSB

DKSPC:	MOV	R4,R2		;SAVE OLD UNIT*2
	MOV	#2,R4		;XOR DOESN'T WORK FROM MEMORY TO REGISTER
	XOR	R2,R4		;R4 IS BUDDY OF PREVIOUS UNIT
	CALL	IDXMID		;SET R0 TO BE INDEX OF BUDDY UMID TABLES
	MOV	R3,-(SP)	;SAVE MASSBUS ID OF PREVIOUS UNIT
	BGT	10$		;SKIP IF IT WAS RK05F (DOUBLE FIXED DISK)
	TST	MIDNEW(R0)	;WE'RE NOT RK05F -- IS THE BUDDY?
	BLE	30$		;NO -- ALL IS COOL
	MOV	#-1,R3		;BUDDY WAS RK05F -- CHANGE TO NONEXISTENT
	CALL	20$		;AND TELL THE USER
	 GENTXT	<"removed">

10$:	TST	MIDNEW(R0)	;WE ARE RK05F -- IS THE BUDDY?
	BGT	30$		;YES -- ALL IS COOL
	CALL	20$		;BUDDY WASN'T RK05F -- CHANGE TO RK05F
	 GENTXT	<"changed to RK05F">

20$:	CALL	CHGMID		;SET TYPE OF BUDDY TO CONTENTS OF R3
	MESSAGE	<<11>"Unit type set for DK">
	MOV	R4,R0		;WANT TO GIVE BUDDY'S UNIT NUMBER
	ASR	R0
	CALLX	DECZER		;PRINT UNIT NUMBER
	MESSAGE	<" will be ">	;MAKE IT CLEAR THAT USER NEEDN'T DO IT
	MOV	@(SP)+,R0	;PICK UP WORD FOLLOWING CALL
	CALLX	ASCIZ0		;PRINT THAT TEXT
	CALLX	TYPECR		;END THE LINE
30$:	MOV	(SP)+,R3	;RESTORE THE GIVEN MASSBUS ID
	MOV	R2,R4		;AND THE GIVEN UNIT NUMBER
	RETURN			;ALL DONE

.DSABL	LSB

.SBTTL	CLEAN UP AFTER OPTIONS

	TMPORG	HAROPT
	 .WORD	HARXXX		;TRAP INVALID RESPONSES
	TMPORG	HAROTX
	 .BYTE	0		;END OF TEXT
	UNORG

HARXXX:	MESSAGE	<"  Illegal suboption given"<200>>
	RETURN

.MACRO	OPTION	N1,N2
.ERROR	;OPTIONS NOT LEGAL
.ENDM	OPTION

.SBTTL	GETDV - GET A DEVICE NAME

.ENABL	LSB

GETDV:	MOV	(R5)+,20$	;GET PROMPT TEXT
	MOV	R5,(SP)		;SAVE R5
	MOVB	(R1),PREST1	;ANSWER ALREADY THERE?
	BNE	50$		;YES, USE IT
10$:	TSTB	PREST1		;ANSWER GIVEN WRONGLY?
	BNE	30$		;YES, EXIT FROM SUBOPTION
	CALLX	RCTRLO		;SPEAK
	CALLX	MESSAG,R5	;PRINT THE PROMPT
20$:	 .WORD	0
	CALLX	GETIN		;GET A REPLY
	CMPB	(R1),#'Z-100	;CTRL/Z?
	BNE	40$		;NO
30$:	TST	(SP)+		;YES, REMOVE CALL TO US
	RETURN			;RETURN FOR HARDWR SUBOPTION

40$:	CMPB	(R1),#'?	;NEED HELP?
	BNE	50$		;NO
	CALLX	MESSAG,R5	;YES, PRINT A HELPFUL MESSAGE
	 GENTXT
	  .ASCII "    Type the 2-letter name of a device controller."<200>
	  .ASCII "    If more than one controller is possible, type"<200>
	  .ASCII "    the controller number after the name."<200>
	  .ASCIZ "    Type 'LI' for a (long) list of valid controllers."<200>
	 UNORG
	BR	10$		;TRY AGAIN

50$:	MOV	R1,R0		;COPY R1
	CMP	(R1),#"LI	;WANT A LIST?
	BNE	60$		;NO
	CALL	LISTHW		;YES, LIST IT ALL
	BR	10$		;TRY AGAIN

60$:	MOV	(R1)+,R0	;R0 = CONTROLLER NAME
	CMP	R0,#"RV		;Is it the Virtual Disk?		;009
	BEQ	75$		;Yes, This isn't really hardware	;005
	CMP	R0,#"NO		;Is it the Async DDCMP driver?		;026
	BEQ	75$		;Yes, don't let'm change it		;026
	CALLX	DEVLUP		;LOOP THROUGH EVERYTHING
70$:	CMP	R0,PK.NAM(R5)	;IS THIS IT?
	BEQ	80$		;YUP
	CALL	@(SP)+		;NO, TRY FOR MORE
	BNE	70$		;IF ANY
75$:	MESSAG	<"    Invalid controller name"<200>>
	BR	10$

80$:	TST	(SP)+		;PURGE COROUTINE RETURN
	CLR	R0		;ASSUME THE UNIT IS 0
	CMPB	(R1),#40	;SPACE HERE?
	BEQ	90$		;YES, NO UNIT
	CMPB	(R1)+,#':	;COLON SEPARATOR?
	BEQ	90$		;YES, NO UNIT
	TSTB	-(R1)		;ANY UNIT GIVEN?
	BNE	100$		;YUP, GO GET IT
90$:	CMPB	(R5),#1		;NO, IS MORE THAN 1 LEGAL?
.ASSUME	PK.MXU EQ 0
	BEQ	110$		;NOPE, USE UNIT 0
	MESSAG	<"    Controller number missing"<200>>
	BR	10$

100$:	CALLX	DECINP		;PARSE THE CONTROLLER NUMBER
	BEQ	110$		;A GOOD NUMBER
	CMPB	(R1)+,#':	;COLON IS VALID HERE
	BEQ	110$		;GOT IT
	CMPB	-(R1),#40	;MAYBE SPACE HERE?
	BEQ	110$		;YES, GOODIE
	MESSAG	<"    Invalid controller number"<200>>
	BR	10$		;NO GOOD NUMBER, TRY AGAIN

110$:	CMPB	R0,(R5)		;HOKAY NUMBER?
.ASSUME	PK.MXU EQ 0
	BLO	120$		;YUP
	MESSAG	<"    Controller number must be less than ">
	MOVB	(R5),R0		;GET MAXIMUM IN R0
.ASSUME	PK.MXU EQ 0
	CALLX	DECZER
	CALLX	TYPECR
	BR	10$		;TRY AGAIN

120$:	CMPB	(R1)+,#40	;SKIP BLANKS IF ANY
	BEQ	120$
	DEC	R1		;POINT TO FIRST NON-BLANK (MAYBE NULL)
	MOV	R5,R3		;HOKAY, COPY PACKET POINTER TO R3
	MOV	R0,R2		;CONTROLLER NUMBER TO R2
	ASL	R2		; * 2 FOR WORD OFFSET
	ADD	PK.CSO(R3),R2	;ADD IN DEVICE'S OFFSET
	RETURN

.DSABL	LSB

	TMPORG	HARCTL
PREST1:	.WORD	0		;<>0 IF PRESET ANSWER
	UNORG

.SBTTL	CHECK FOR 'REMOVE' AS ANSWER

REMCHK:	MOV	R0,-(SP)	;SAVE R0
	CALLX	GETUNQ,R5	;CHECK THE ANSWER
	 GENTXT
	 UNQTXT	<RE\MOVE>
	 .BYTE	0
	 UNORG
	MOV	(SP)+,R0	;RESTORE R0, C=0 IF 'REMOVE'
	BITB	(R1),(R1)	;IS THAT THE END OF THE LINE?
	BEQ	10$		;YES
	SEC			;NO, FAILURE TO MATCH
10$:	RETURN

.SBTTL	LIST THE HARDWARE CONTROLLER NAMES

.ENABL	LSB

LISTHW:	MESSAG	<<12>"    Name Max no"<11>"Description"<200><12>>
	MOV	#DEVTBL,R5	;POINT TO TABLE
10$:	MOV	PK.NAM(R5),R2	;NAME
	CMP	R2,#"RV		;Virtual Disk?				;015
	BEQ	35$		;Yes, this isn't really hardware	;005
	MESSAG	<"     ">	;Don't type this unless necessary.	;015
	CALLX	TYPE2
	CALLX	TYPTAB
	MOVB	(R5),R0		;MAX UNIT
.ASSUME	PK.MXU EQ 0
	CALLX	P4DDIG		;DECIMAL (4-PLACE NUMBER)
	MOV	#EXPLN,R1	;FIND AN EXPLANATION
20$:	MOV	(R1)+,R0	;POINT TO EXPLANATORY TEXT
	BEQ	30$		;CAN'T FIND IT ???
	CMP	PK.NAM(R5),(R1)+ ;THIS IT?
	BNE	20$		;NO
	CALLX	TYPTAB		;YUP, TAB OVER & PRINT IT
	CALLX	ASCIZ0
30$:	CALLX	TYPECR		;NEW LINE
35$:	ADD	#PKTSIZ,R5	;NEXT PACKET
	TST	(R5)		;DONE?
	BNE	10$		;NO
	RETURN

.DSABL	LSB

GLOBAL	<DEVTBL>

.SBTTL	EXPLANATORY TEXT

.MACRO	$	DV,TXT
	GENTXT	<TXT>
	.WORD	"DV
.ENDM	$

EXPLN:					;**$DISKS**
$	TT,<"Console terminal">
$	RF,<"RF11 fixed head disk">
$	RS,<"RS03/RS04 fixed head disk">
$	RK,<"RK05/RK05F disk">
$	RL,<"RL01/RL02 disk">
$	RM,<"RK06/RK07 disk">
$	RP,<"RP02/RP03 disk">
$	RB,<"RP04/RP05/RP06 disk">
$	RR,<"RM02/03/05/80 disk">	;ALSO RP07s (when supported)
$	RZ,<"GPK-3xx floppy disk">					;021
$	RW,<"GPK-3xx hard disk">					;021
$	RU,<"MSCP Class disk">						;002
$	MU,<"TMSCP Class tape">						;010
$	TS,<"TS11/TS05/TU80/TK25 magtape">				;005
$	TM,<"TU10/TE10/TS03 magtape">
$	TU,<"TU16/TE16/TU45/TU77 magtape">
$	TC,<"TC11/TU56 DECtape">
$	PR,<"Paper tape reader">
$	PP,<"Paper tape punch">
$	LP,<"Line printer">
$	RX,<"RX01/RX02 floppy disk">
$	CR,<"CR11/CM11 card reader">
$	CD,<"CD11 card reader">
$	KL,<"KL11/DL11A/DL11B single line interface">
$	DL,<"DL11C/DL11D single line interface">
$	DE,<"DL11E single line modem interface">
$	DD,<"TU58 DECtape II">
$	DC,<"DC11 single line interface">
$	DP,<"DP11 synchronous line interface">
$	XN,<"DN11 automatic calling unit interface">
$	BS,<"DT07 Bus switch">
$	KG,<"KG11 CRC arithmetic unit">
$	KJ,<"KXJ11 microprocessor">					;027
$	DM,<"DM11-BB modem control for DH11">
$	DJ,<"DJ11 16 line multiplexer">
$	DH,<"DH11 16 line multiplexer">
$	DU,<"DU11 single line synchronous interface">
$	D1,<"DUP11 single line synchronous interface">
$	XM,<"DMC11/DMR11 interprocessor link">
$	DZ,<"DZ11/DZV11/DZQ11/DFA01 4/8 line multiplexer">		;027
$	XK,<"KMC11 microprocessor">
$	XD,<"DMP11/DMV11 interprocessor link">
$	VH,<"DHV/DHU/DHQ/DHF/CXA/CXB/CXY 8/16 line multiplexer">	;027
$	XA,<"DR11/DRV11 interprocessor link">				;027
$	XE,<"UNA Ethernet interface">					;012
$	XH,<"QNA Ethernet interface">					;016
	.WORD	0

.SBTTL	IMPURE AREA

	ORG	HARCTL

SETNEW:	.BLKW	700		;ROOM FOR OUR COPY
VECNEW:	.BLKW	700
MIDNEW:	$DISKS			;USER-SET MASSBUS ID'S
.IF	GT	IDX$'NAME-IDX$DF
  .IF	EQ	IDX$'NAME-IDX$DU
	.BLKW0	16.
  .IFF
	.BLKW0	8.
  .ENDC
.ENDC
.ENDM
DMTTBL:	.BLKW	16.		;DM11BB/DH11 ASSOCIATIONS
NEWFRQ:	.BLKW			;LINE FREQUENCY
NEWSWT:	.BLKW			;SWITCH REGISTER SETTING
SETSIZ:	.WORD	0		;ACTUAL NUMBER OF WORDS IN TABLE
CHGCNT:	.WORD	0		;NUMBER OF CHANGES
PRESET:	.WORD	0		;PRESET ANSWER FLAG/POINTER
RSTFLG:	.WORD	0		;<>0 IF RESETTING TO ENABLE ALL DEVICES

ENDOVL	<HAR,HARCTL,HAROPT,HAROTX,HARTXT>,100

.END
