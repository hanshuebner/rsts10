.INCLUDE /CMN:COMMON/							;026
.INCLUDE /CMN:KERNEL/							;026
.INCLUDE /INIT:INIPFX/							;026
.INCLUDE /INIT:DSKDEF/							;026
.INCLUDE /CMN:CFGDEF/							;034
TITLE	INSTAL,<RSTS/E INIT - INSTALL OPTION>,0L,03-AUG-92,MND/MDS/GPK/CEK/SRM/TPT/KPH/VAM/DBM/JHC/DSD

;
;		COPYRIGHT (c) 1974, 1992 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;


.SBTTL	EDIT HISTORY FOR INIINS

;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-08
;  001	MND  16-Feb-81	Added DMP/DMV support
;  002  MDS  20-MAR-81	ADD LOOKUPS FOR EXTENDED MEMORY DUMPS
;  003	SRM  24-Apr-81	Break up DDCTBL messages that were too long
;			for the V4 MACRO assembler.
;  004	MND  01-Jul-81	Add symbol lookups for distinguishing DMR and DMC
;  005  GPK  01-Jul-81	Don't look for ODT in monitor SIL
;			Fixed bug in CRA phase presence check
;  006  CEK  06-Aug-81  Added check for D-space compatible SIL (CKDSPA)
;  007  SRM  19-Oct-81	Modify for FIP in APR 6.
;  008  CEK  21-Oct-81  Remove check for D-space compatible SIL 
;			(now in INIDEF)
;  009	SRM  21-Oct-81	Add lookup for $$LODB (FBB of load block).
;  010  CEK  30-Oct-81  Add lookup for $$YBFS and $$YBFE (Yet Another bufpool)
;
;				[RSTS V7.2]
;  000  CEK  07-Jan-82  CREATION - COPIED FROM V7.1-11
;  001  CEK  07-Jan-82  Add lookup for $$OVBU (pointer to overlay buffer)
;  002  MND  22-Mar-82  Added support for MSCP disks - UDA50/RA80
;
;				[RSTS V8.0]
;  000	GPK  02-Jul-82	Updated maximum size of OVR phase
;
;				[RSTS V9.0]
;  001	MND  07-Oct-83	Chain to START option if auto-INSTAL is in effect
;  002  TWH  11-Oct-83  Change RDRSTS to cope with multi block SIL index.
;  003	TPT  11-Nov-83	Merged V8.0-07 changes
;  004	MND  22-Jan-84	Make system start-up select and INSTAL a default SIL
;  005	KPH  06-Sep-84	Allow RSTS phase to end at 120000
;  006  VAM  09-Jan-85	Don't allow a SIL to be installed if it has phases
;			between FIP and OVR
;  007	DBM  06-Mar-85	Change "START" prompt to "start"
;			Fix bug when trying to start with no SIL's
;  008	FEK  14-Mar-85	Add RJ2780 soft KG11 symbol, change max sub-line code
;  009	DBM  19-Mar-85	Handle ^C's with no previous SIL installed
;			Check IDENT of monitor vs. INIT
;			List/choose only monitors that match IDENT's with INIT
;
;				[RSTS V9.1]
;  010	DBM  12-Mar-85	TMSCP changes
;  011	KPH  05-Apr-85	Remove primary RTS
;  012  KPH  28-May-85	Conditional phases
;  013  KPH  08-Jul-85	Remove AODS
;
;				[RSTS V9.2]
;  014  KPH  15-Jul-85	Add Job Control Region
;
;				[RSTS V9.3]
;  015  KPH  26-Sep-85	Add DECnet conditional phases
;  016  JHC  26-Nov-85	Add UNA/QNA conditional phases
;  017  KPH  08-Jan-86	Add DDS.XE and DDS.XH lookup for UNA/QNA
;  018  KPH  14-Jan-86	Add EVL and RDM phases
;  019  KPH  06-Feb-86	Add symbol lookup for RDMAP5
;  020	JHC  10-Feb-86	Symbol lookup for FAKDDB
;  021  VAM  19-May-86	Add SYSTIC and NULJOB symbol lookups for J11 null job.
;
;				[RSTS V9.4]
;  022	GPK  07-Oct-86	Changes for FIP in resident overlay   
;  023	GPK  13-Oct-86	Add $$CLK2 for GPK clock handling in RTI
;  024	GPK  23-Jan-87	Add GPK terminal support
;  025  VAM  05-Mar-87	Fix multi-controller check in BLDJAM.
;
;				[RSTS V9.5]
;  028  VAM  31-Aug-87  Uninstall current SIL if error occurs while
;			installing new SIL.
;
;				[RSTS V9.6]
;  026  KPH  13-Oct-87	Add .INCLUDEs
;			Add terminal driver conditional phases
;			Add symbols for dynamic KB devices
;  027  KPH  02-Nov-87	Add LAT conditional phases
;  029  WRM  01-Dec-87	Source Clear V9.5 into V9.6
;  030	DSD  20-Jan-88	Add NOD conditional phase
;  031	PJH  02-Mar-88	Globalize LAT structures root area and DYNKBN
;
;				[RSTS V9.7]
;  032	KCG  16-Nov-88	Add OV2 (another overlay) phase.
;  033	DRP  29-DEC-88	Add support for the KBX phase
;  034  VAM  30-Jan-89	Put newly-installed SIL name into CFGBUF.
;
;				[RSTS V10.0]
;  035  DSD  06-Jun-89	Add NODDDB and DDS.NO lookup for Async DDCMP driver
;  036	FEK  25-Aug-89	Allow alpha in .IDENT check
;  037	FEK  29-Aug-89	Allow alpha in RAD50 to ASCII conversion routine
;  038  VAM  24-May-90	Always print SIL name when doing auto-INSTAL.
;			Replace spaces in SIL name in CONFIG.SYS with nulls.
;-

.REM	*

Layout of DS block build by INSTALL, one per controller used

!-------------------------------!-------------------------------!
!			DS.UNT	!			DS.DVN	!
!	RSTS unit number	!	DEVNAM table offset	!
!	  of first unit		!				!
!				!				!
!-------------------------------!-------------------------------!
!			DS.NCS	!			DS.NUN	!
!	Number of CSR's to	!	Number of units		!
!		jam		!	    controlled		!
!				!				!
!-------------------------------!-------------------------------!
!			DS.CTL	!			DS.PKT	!
!	Controller number	!	INIT internal		!
!   (low 4 PS bits for non-KB)	!	  packet number		!
!				!				!
!-------------------------------!-------------------------------!
!							DS.CSR	!
!		Location in monitor to load with		!
!		    actual CSR base for unit			!
!								!
!---------------------------------------------------------------!
!							DS.DCT	!
!		Address in monitor to load into			!
!		    vector new PC for device			!
!								!
!---------------------------------------------------------------!
							DS.XXX	


Sample layouts of first 6 bytes for various devices


Disk:

!-------------------------------!-------------------------------!
!			DS.UNT	!			DS.DVN	!
!		0		!	   small offset		!
!	(first disk is 0)	!	    (< DEVOKB)		!
!				!				!
!-------------------------------!-------------------------------!
!			DS.NCS	!			DS.NUN	!
!		1		!	    DEVCNT+1		!
!	  (one CSR only)	!  (all units on 1 controller)	!
!				!				!
!-------------------------------!-------------------------------!
!			DS.CTL	!			DS.PKT	!
!		0		!		-		!
!    (only controller is # 0)	!				!
!				!				!
!-------------------------------!-------------------------------!


LPn:, PPn:, PRn:, CRn:

!-------------------------------!-------------------------------!
!			DS.UNT	!			DS.DVN	!
!		n		!		-		!
!				!				!
!				!				!
!-------------------------------!-------------------------------!
!			DS.NCS	!			DS.NUN	!
!		1		!		1		!
!				!				!
!				!				!
!-------------------------------!-------------------------------!
!			DS.CTL	!			DS.PKT	!
!		n		!		-		!
!				!				!
!				!				!
!-------------------------------!-------------------------------!



DXn:/DX(n+1): controller:

!-------------------------------!-------------------------------!
!			DS.UNT	!			DS.DVN	!
!		n		!		-		!
!				!				!
!				!				!
!-------------------------------!-------------------------------!
!			DS.NCS	!			DS.NUN	!
!		2		!		2		!
!				!				!
!				!				!
!-------------------------------!-------------------------------!
!			DS.CTL	!			DS.PKT	!
!	       n/2		!		-		!
!				!				!
!				!				!
!-------------------------------!-------------------------------!

Note that keyboard devices do not use DS packets; they are handled
specially.

*


.SBTTL	MACROS FOR INSTALL

.MACRO	I.MESS
	TMPORG	INSTXT
.NLIST	BEX
.ENDM	I.MESS

.SBTTL	ORDER THE CSECTS

	DEFORG	INS
	DEFORG	INSTXT
	DEFORG	INSCTL
	DEFORG	INSSYN
	ORG	INS


.SBTTL	INSTALL - MAIN LOOP

.ENABL	LSB

; INPUTS:
;	R1	->	null-terminated text that user typed 
;			after the word INSTAL
;
; OUTPUTS:
;	FIPL	=	length of FIP phase (bytes)
;	etc

INSTAL::NOP			;Optionally patched to BPT for debugging.
	CALLX	CKOPT		;Is this option legal?
	MOV	SILNAM,OLDSIL	;Save any current SIL name		;009
	MOV	SILNAM+2,OLDSIL+2 ;Both words				;009
	MOVB	(R1),R5		;Any preset answer?
	MOVB	R5,NORTRY	;Save as a flag				;009
	BEQ	10$		;No preset answer given.
	CMPB	R5,#'?		;Should we just show the default SIL?	;004
	BEQ	15$		;Yes					;004
	TSTB	AUTOIN		;Doing an auto-INSTAL?			;038
	BPL	5$		;No, so skip printing message.		;038
	MESSAG	<"  Starting ">,STRTMS ;Tell which SIL we're doing.	;038
	MOV	R1,R0		;R0 -> ASCIZ SIL name.			;038
	CALLX	ASCIZ0		;Print it.				;038
	MESSAG	<".SIL . . ."<200>>,SILEXT ;Finish the message up.	;038
5$:	CALLX	RADINP		;Convert preset answer to RAD50.	;038
	BR	20$		;Keep going with install.		;038

GLOBAL	<AUTOIN>							;038

10$:	TSTB	NORTRY		;Was there a preset answer?		;009
	BEQ	15$		;No, so ask again.
	MOV	OLDSIL,SILNAM	;Yes, restore the old SIL name, if any	;009
	MOV	OLDSIL+2,SILNAM+2 ;Both words				;009
	EXIT			;Exit to "Option:".

12$:	CLR	OLDSIL		;Fatal error so forget old SIL name	;028
	CLR	SILNAM		; and de-install old sil as well	;028
	MESSAG	<"  Please install a valid monitor SIL."<200>>		;028
				; and ask them to install valid SIL	;028
	BR	10$		;Then take normal path			;028

15$:	CALL	PRESET,R5,SILNAM ;Ask for SIL name to install.
	 GENTXT	<<177><12>"Monitor name to start">
	 GENTXT	
	  .ASCII <12>"Type the filename of the monitor save image library to start."<200>
	  .ASCII <12>"Directory of all V"
	  .IIF NE <<SYSVEL&377>-'0>	.BYTE <SYSVEL&377>
	  .BYTE <SYSVEL/400>,<SYSVEE&377>,<SYSVEE/400>
	  .IIF NE <$$$VER-"00>		.BYTE '-,<$$$VER&377>,<$$$VER/400>
	  .ASCIZ " monitor files in [0,1]:"<200><12>
	 UNORG

20$:	MOV	#FQ...+FQNAM1,R4 ;Point to FIRQB for name.
	MOV	R0,(R4)+	;First word of name.
	BEQ	30$		;Zero name is invalid.
	MOV	R3,(R4)+	;Second word of name.
	MOV	#^RSIL,(R4)+	;Extension must be SIL.
	TSTB	(R1)		;End is right?
	BEQ	40$		;Yup.
	CMPB	(R1),#'.	;Did he also give an extension?
	BEQ	40$		;Yup.

30$:	MESSAG	<"  Illegal file name"<200>>
	BR	10$		;Go decide whether to ask again.

40$:	CALLX	LOK...		;Look for the new SIL.
	BCC	50$		;Got it.
	MESSAG	<"  File not found"<200>>
	BR	10$		;Go decide whether to ask again.

50$:	CALLX	SILNDX,R5,FQ...	;Ensure that the file is a good SIL.
	BEQ	60$		;OK.
	MOV	(PC)+,R0	;Tell user what's wrong
	GENTXT	<"SIL index is corrupt"<200>>
	.BR	55$

55$:	MESSAG	<"  Invalid SIL format - ">
	CALLX	ASCIZ0		;Print it out reason
	BR	12$		;This was a fatal error, so go		;028
				; de-install old SIL and decide		;028
				; whether to ask again			;028

GLOBAL	<FQ...,SILNAM>


60$:	MOV	#SEGTBL,R0	;Point to segment table			;012
61$:	CLR	(R0)+		;Clear out a word			;012
	CMP	R0,#SEGTBE	;Cleared the whole thing?		;012
	BNE	61$		;No, loop for it			;012
	MOV	#R$$MSK,REQFLG	;Initialize required module flags	;012
	MOV	#SILBUF,R0	;Start pointer to sil index.
	MOV	(R0)+,R2	; and save number of modules.
	MOV	#MODRST,R4	;First module must be "RSTS".
	CALL	100$		;Find it.
	BCC	62$		;Found it, check out the IDENT		;009
	JMP	180$		;Error, not there			;009

62$:	CALL	CHKIDE		;Match IDENT with INIT			;009
	BCC	70$		;Versions match.  SIL is okay		;012
	MOV	(PC)+,R0	;No match.  SIL is no good		;009
	GENTXT	<"INIT and monitor are different versions"<200>>	;009
	BR	55$		;Go print it out			;009

65$:	MOV	(PC)+,R0	;Missing requried modules		;012
	GENTXT	<"Monitor is missing required modules"<200>>		;012
	BR	55$		;Go print it out			;012

70$:	CALL	140$		;Process a module.
	BEQ	65$		;Whoops, no more module(s).		;012
	MOV	#MODSPC,R4	;Point to the special module list	;012
	CALL	100$		;Check for special modules		;012
	BCC	80$		;Found one, done with fixed monitor	;012
	MOV	#MODGEN,R4	;Not a special phase, get general pointer ;012
	MOV	R4,R3		;In both places				;012
	BR	70$		;And process it				;012

80$:	CALL	140$		;Process the special module we found	;012
	BEQ	90$		;No more modules, check required flags	;012
	MOV	#MODSPC,R4	;Get special module list again		;012
	CALL	100$		;Check for one				;012
	BCC	80$		;Found one, process it			;012
	ADD	#14,R4		;Not found, set up message index 14	;012
	BR	180$		;And report it				;012

90$:	TST	REQFLG		;Any required modules missing?		;012
	BNE	65$		;Yes, go report that			;012
	BR	SCANST		;No, off to symbol table scanning	;012

	TMPORG	INSCTL
REQFLG:	.WORD	0							;012
	UNORG

GLOBAL	<SEGTBL,SEGTBE,SILBUF>						;012


;+
;	Find a name in a phase format list.
;
;	R0	->	SIL entry.  First two words of entry are 
;			module name in RAD50.
;	R4	->	entry of the phase format list to begin searching from.
;			First two words of entry are module name in RAD50.  
;			Entry length is MODSIZ.  Table ends with a zero word.
;			Table must contain at least one entry.
;
;	CALL	100$
;
;	C=1	Module not found in phase format list.
;	R4	-> 	Zero word marking end of phase format list.
;	R3	->	Zero word marking end of phase format list.
;
;	C=0	Module found in phase format list.
;	R3	->	Second word of entry of phase format list.
;	R4	->	Second word of entry of phase format list.
;	SILENT	->	SIL entry.
;-

100$:	MOV	R0,SILENT	;Remember SIL index pointer.
110$:	CMP	(R0),(R4)+	;Does first part of name match?
	BNE	120$		;No.
	CMP	2(R0),(R4)	;Yes, does second part also match?
	BEQ	130$		;Total match.  Exit with C=0 (from 'BEQ')
120$:	ADD	#MODSIZ-2,R4	;Go to next entry in module list.
	TST	(R4)		;End of list?  
	BNE	110$		;Nope, keep checking.
	SEC			;Yep, exit with C=1.
130$:	MOV	R4,R3		;Save entry pointer +2.
	RETURN			;Exit.


;+
;	Test a phase for being legal and figure out monitor size.
;
;	R0	->	entry of SIL index.
;	R2	=	number of phases left to process, including this one.
;	SILENT	->	SIL name entry.
;	R3	->	second word of entry of phase format list to check 
;			against.
;	R4	->	second word of entry of phase format list to check 
;			against.
;
;	CALL	140$
;
;	R0	->	next entry of SIL index.
;	R1	random.
;	R2	=	number of modules left to process in SIL, excluding 
;			this one.
;	Z=1	if	no modules left to process.
;	R4	->	next entry in phase format list.
;
;	On error 180$ is branched to and the INSTALL aborts and a new
;	SIL name is prompted for.
;-

140$:	TST	SE.OFF(R0)	;Does this begin on a block boundry?	;012
	BEQ	150$		;Yes, everything goes			;012
	CMP	R4,#MODGEN	;Is this a generic phase?		;012
	BEQ	150$		;Yes, that's fine			;012
	ADD	#16,R4		;Set up message index			;012
	BR	180$		;And report the error			;012

150$:	TST	(R4)+		;Skip second part of module name.	;012
	CMP	#1,SE.XFR(R0)	;Check transfer address.
	BNE	180$		;Illegal, must be 1 (Message index = +2).
	MOV	SE.SIZ(R0),R1	;Get the module size.
	BIT	R1,(R4)+	;Check length for a proper multiple.
	BNE	180$		;No (Message index = +4).
	CMP	SE.LOD(R0),(R4)+;Check load address.
	BNE	180$		;Wrong is error (Message index = +6).
	CMP	R1,(R4)+	;Check minimum size of phase.
	BLO	180$		;Too small (Message index = +10).
	CMP	R1,(R4)+	;Check maximum size of phase.
	BHI	180$		;Too big (Message index = +12).
	MOV	SE.BLK(R0),@(R4)+ ;Stash start block number (ind = +14)	;012
	ADD	#77,R1		;Round module size to a MMU boundry
	ASH	#-6,R1		;And convert to a number of slivers
	BIC	#176000,R1	;Wipe out possible propagation of sign.
	ADD	R1,@(R4)+	;Save the size of this module (ind = +16) ;012
	BIC	(R4)+,REQFLG	;Clear out required module flags (ind = +20) ;012
	TST	(R4)		;Is there a required symbol?
	BEQ	170$		;No.
	CALL	GETSYM		;Get symbol in scanned module.
	BCS	180$		;Not there! (Message index = +24)
				;R0	=	value of symbol in SIL.
				;R4 	->	past end of symbol in phase 
				;		table.
	CMP	R0,(R4)+	;Is symbol's value low enough?
	BHI	180$		;Nope, error (Message index = +26).
170$:	MOV	SILENT,R0	;Get current module pointer
	ADD	#SE.LEN,R0	; and go to next module.
	DEC	R2		;Count down number of modules.
	RETURN			;Exit with Z bit indication.


;+
;	Error routine to abort install.
;
;	SILENT ->	SIL index entry that caused the error.
;	R3	->	second word of phase format entry for this module
;	R4	->	component of phase format entry that follows the
;			compoenent that caused the error.
;
;	JMP	180$
;
;	(R4 - R3) is used as index into message table at 190$.
;	Message is printed.  Then we go back to prompt for another SIL name.
;
;	Note that the stack is not cleaned up.  If an install fails enough
;	times, the stack will overflow.
;-

180$:	MOV	SILENT,R1	;Get back pointer to current SIL index entry.
	MESSAG	<"  Module ">
	MOV	(R1)+,R0	;Print name part 1.
	CALLX	RADZER
	MOV	(R1)+,R0	;Print name part 2.
	CALLX	RADZER
	SUB	R3,R4		;Find error message index  
	MOV	190$(R4),R0	; and get its text.
ERRMS:	CALLX	ASCIZ0		;Print it.
	CALLX	TYPECR		;Next line.
	JMP	12$		;This was a nasty error, so go back to	;028
				; de-install old sil and prompt for a 	;028
				; new SIL name.				;028

							; Message index
190$:	GENTXT	<" not found in SIL">			; 0
	GENTXT	<" has invalid transfer address">	; 2
	GENTXT	<" has invalid length">			; 4
	GENTXT	<" has wrong load address">		; 6
	GENTXT	<" too small">				; 10
	GENTXT	<" too large">				; 12
	GENTXT	<" is an unknown non-generic phase">	; 14		;012
	GENTXT	<" is not aligned on a block boundry">	; 16 		;012
	GENTXT	<" ???">				; 20 (unused)	;012
	GENTXT	<" ???">				; 22 (unused)	;012
	GENTXT	<" is missing a required symbol">	; 24		;012
	GENTXT	<" totally mapped portion too large">	; 26		;012

.DSABL	LSB


.SBTTL	MACROs for phase definition

;+
; The PHASE macro is used to declare a phase. The format is:
;
;	PHASE	NAME
;
;	-- or --
;
;	PHASE		(for the generic phase entry)
;
; The PHASE macro sets up a phase entry in the following format:
;
;	Module name as two words of RAD-50 (or a single zero for generic)
;	Required alignment (these bits must be clear in module size)
;	Minimum module size
;	Maximum module size
;	Address to store start block of module
;	Address to store module size
;	Bit flags to clear in REQFLG (required module testing)
;	2 word RAD-50 symbol to look up and one word maximum symbol value
;
; Some of these values have default values, which are established by
; the PHASE macro. The defaults are:
;
;	Parameter		Default		Macro to establish
;	=========		=======		==================
;	Alignment		77		ALIGN	<value>
;	Load address		none		LOAD	<value>
;	Minimum size		0		MIN	<value>
;	Maximum size		none		MAX	<value>
;	Start block		none		BLOCK	<value>
;	Size			none		SIZE	<value>
;	Required module flag	none		REQUIRE	<value>
;	Symbol to check		none		SYMBOL	<symbol>,<value>
;-

.MACRO	PHASE	NAME
$$$$$$	=	.
	.WORD	0	;Name part 1 default
.IF	NB	NAME
	.WORD	0	;Name part 2 default
.	=	$$$$$$
	.RAD50	/NAME/
$$$$$$	=	$$$$$$+2
.	=	$$$$$$+2
.ENDC	;NB	NAME
	.WORD	77	;Default alignment
	.WORD	-1	;Default load address
	.WORD	0	;Default minimum size
	.WORD	0	;Default maximum size
	.WORD	JUNK	;No default place to store start block
	.WORD	JUNK	;No default place to store size
	.WORD	0	;No required module flag to clear
	.WORD	0,0,0	;No default symbol checking
MODSIZ	=:	.-$$$$$$+2
.ENDM	PHASE

.MACRO	ALIGN	BOUND
	DOWORD	BOUND,2
.ENDM	ALIGN

.MACRO	LOAD	ADDR
	DOWORD	ADDR,4
.ENDM	LOAD

.MACRO	MIN	ADDR
	DOWORD	ADDR,6
.ENDM	MIN
	TMPORG	INSCTL

.MACRO	MAX	ADDR
	DOWORD	ADDR,10
.ENDM	MAX

.MACRO	BLOCK	NUMBER
	DOWORD	NUMBER,12
.ENDM	BLOCK

.MACRO	SIZE	WORDS
	DOWORD	WORDS,14
.ENDM	SIZE

.MACRO	REQUIRE	FLAGS
	DOWORD	FLAGS,16
.ENDM	REQUIRE

.MACRO	SYMBOL	SYM,VAL
.SAVE
.	=	$$$$$$+20
	.RAD50	/SYM/
.	=	$$$$$$+24
	.WORD	VAL
.RESTORE
.ENDM	SYMBOL

.MACRO	DOWORD	WORD,WHERE
.SAVE
.	=	$$$$$$+WHERE
	.WORD	WORD
.RESTORE
.ENDM	DOWORD

GLOBAL	<JUNK>


.SBTTL	Declare required module bit definitions

.BSECT	,NOCREF

R$$FIP:	.BLKB	.		;FIP module entry
R$$OVR:	.BLKB	.		;OVR module entry
R$$DEF:	.BLKB	.		;DEFALT module entry
R$$CRA:	.BLKB	.		;CRA module entry
R$$TER:	.BLKB	.		;TER module entry
R$$MSK	=:	.-1		;Currently defined bits
	.BLKB	.		;Reserved
	.BLKB	.		;Reserved
	.BLKB	.		;Reserved
	.BLKB	.		;Reserved
	.BLKB	.		;Reserved
	.BLKB	.		;Reserved
	.BLKB	.		;Reserved
	.BLKB	.		;Reserved
	.BLKB	.		;Reserved
	.BLKB	.		;Reserved
	.BLKB	.		;Reserved
	
	UNORG


.SBTTL	Phase definition table

	TMPORG	INSCTL

MODRST:	PHASE	RSTS			;Phase entry for module RSTS	;012
		LOAD	0		;Load address is zero		;012
		MIN	20000		;Minimum size is 4K		;012
		MAX	140000		;Maximum size is 24K		;012
		SIZE	FIXL		;Size applies to fixed monitor	;012
		SYMBOL	$$EPMM,120000	;Be sure $$EPMM is <= 120000	;012
		BLOCK	RSTBLK		;Save start block number at RSTBLK ;012
        
MODGEN:	PHASE				;Set up generic entry		;012
		LOAD	120000		;Load address is 120000		;012
		MAX	20000		;Maximum size is 4K words	;012
		SIZE	FIXL		;Size applies to fixed monitor	;012

; Note that the generic entry above begins with a zero word. This looks like
; an end of list flag (making the RSTS entry be in a list of its own).
; In addition, we never call the phase searcher for generic phases, but
; call the phase checker directly. Since the phase checker requires a
; pointer to the second part of the name, this single word of zero will
; suffice.

MODSPC:	PHASE	OVR			;Overlay phase			;012
		ALIGN	777		;Must be block alligned		;012
		LOAD	2000		;Must begin at 2000		;012
		MIN	3000		;Must be three blocks at least	;012
		MAX	177000		;Maximum size is 127 blocks	;012
		REQUIRE	R$$OVR		;Clear overlay required bit	;012

	PHASE	OV2			;Another Overlay phase		;032
		ALIGN	777		;Must be block alligned		;032
		LOAD	2000		;Must begin at 2000		;032
		MIN	3000		;Must be three blocks at least	;032
		MAX	177000		;Maximum size is 127 blocks	;032
		REQUIRE	R$$OVR		;Clear overlay required bit	;032

	PHASE	DEFALT			;Default phase			;012
		ALIGN	777		;Must be block alligned		;012
		LOAD	1000		;Must begin at 1000		;012
		MIN	SIZDEF		;Must be SIZDEF in size		;012
		MAX	SIZDEF		;Exactly			;012
		REQUIRE	R$$DEF		;Clear default required bit	;012

	PHASE	TERCLS			;Terminal driver		;026
		LOAD	140000		;Must begin at APR6		;026
		MAX	17700		;Max is 4K - 1 sliver		;026
		SIZE	TERL		;Account for terminal driver size ;012
		BLOCK	TERBLK		;And save start block number	;012
		REQUIRE	R$$TER		;Clear TER required bit		;012

	PHASE	DHPORT			;DH11 port driver		;026
		LOAD	120000		;Must begin at APR5		;026
		MAX	20000		;Max is 4K			;026
		SIZE	DHPL		;Save its size			;026
		BLOCK	DHPBLK		;And save start block number	;026

	PHASE	DZPORT			;DZ11 port driver		;026
		LOAD	120000		;Must begin at APR5		;026
		MAX	20000		;Max is 4K			;026
		SIZE	DZPL  		;Save its size			;026
		BLOCK	DZPBLK		;And save start block number	;026

	PHASE	VHPORT			;DHV11/DHU11 port driver	;026
		LOAD	120000		;Must begin at APR5		;026
		MAX	20000		;Max is 4K			;026
		SIZE	VHPL  		;Save its size			;026
		BLOCK	VHPBLK		;And save start block number	;026

	PHASE	FMS			;FMS-11 support			;026
		LOAD	120000		;Must begin at APR5		;026
		MAX	20000		;Max is 4K			;026
		SIZE	FMSL		;Save its size			;026
		BLOCK	FMSBLK		;And save start block number	;026

	PHASE	KBX			;KBX phase support		;033
		LOAD	120000		;Must begin at APR5		;033
		MAX	20000		;Max is 4K			;033
		SIZE	KBXL		;Save its size			;033
		BLOCK	KBXBLK		;And save start block number	;033

	PHASE	LAT			;LAT support			;027
		LOAD	120000		;Must begin at APR5		;027
		MAX	20000		;Max is 4K			;027
		SIZE	LATL		;Save its size			;027
		BLOCK	LATBLK		;And save start block number	;027

	PHASE	FIP			;File processor			;012
		LOAD	140000		;Must begin at APR6		;012
		MAX	17700		;Max is 4K - 1 sliver		;012
		SIZE	FIPL		;Account for FIP size		;012
		BLOCK	FIPBLK		;And save start block number	;012
		REQUIRE	R$$FIP		;Clear FIP requried bit		;012

	PHASE	CRA			;Crash dumper			;012
		LOAD	120000		;Must begin at APR5		;012
		MAX	20000		;Can be up to 4KW in size	;012
		SYMBOL	$$BOOT,120000	;$$BOOT must be at 120000	;012
		SIZE	CRAL		;Account for CRA size		;012
		BLOCK	CRABLK		;And save start block number	;012
		REQUIRE	R$$CRA		;Clear CRA required bit		;012

	PHASE	SES			;DECnet session control		;015
		LOAD	120000		;Must begin at APR5		;015
		MAX	20000		;Can by up to 4KW in size	;015
		SIZE	SESL		;Account for SES size		;015
		BLOCK	SESBLK		;And save start block number	;015

	PHASE	NSP			;DECnet end communication layer	;015
		LOAD	120000		;Must begin at APR5		;015
		MAX	20000		;Can by up to 4KW in size	;015
		SIZE	NSPL		;Account for NSP size		;015
		BLOCK	NSPBLK		;And save start block number	;015

	PHASE	TRN			;DECnet routing layer		;015
		LOAD	120000		;Must begin at APR5		;015
		MAX	20000		;Can by up to 4KW in size	;015
		SIZE	TRNL		;Account for TRN size		;015
		BLOCK	TRNBLK		;And save start block number	;015

	PHASE	EVL			;DECnet event logger		;018
		LOAD	120000		;Must begin at APR5		;018
		MAX	20000		;Can by up to 4KW in size	;018
		SIZE	EVLL		;Account for EVL size		;018
		BLOCK	EVLBLK		;And save start block number	;018

	PHASE	RDM			;DECnet routing/forwarding	;018
		LOAD	120000		;Must begin at APR5		;018
		MAX	20000		;Can by up to 4KW in size	;018
		SIZE	RDML		;Account for RDM size		;018
		BLOCK	RDMBLK		;And save start block number	;018

	PHASE	NOD			;DECnet async DDCMP		;030
		LOAD	120000		;Must begin at APR5		;030
		MAX	20000		;Can by up to 4KW in size	;030
		SIZE	NODL		;Account for NOD size		;030
		BLOCK	NODBLK		;And save start block number	;030

	PHASE	UNA			; UNA Ethernet Driver		;016
		LOAD	120000		; Starts in APR5		;016
		MAX	20000		; Max size is 4KW		;016
		SIZE	UNAL		; Account for its size		;016
		BLOCK	UNABLK		; And save start block number	;016

	PHASE	QNA			; QNA Ethernet Driver		;016
		LOAD	120000		; APR5 mapping			;016
		MAX	20000		; Max size of 4KW		;016
		SIZE	QNAL		; And account for actual size	;016
		BLOCK	QNABLK		; And save start block number	;016
		
	PHASE	GPK			;GPK display driver		;024
		LOAD	120000		;Mapped via APR5		;024
		MAX	20000		;One APR			;024
		SIZE	GPKL		;Account for actual size	;024
		BLOCK	GPKBLK		;Save block number		;024

	PHASE	GPKTBL			;GPK display tables		;024
		LOAD	2000		;Who cares, it's only data	;024
		MAX	177000		;It's mapped piecemeal		;024
		SIZE	PTBL		;Account for actual size	;024
		BLOCK	PTBBLK		;Save block number		;024

	.WORD	0			;End of table			;012

	UNORG

GLOBAL	<SIZDEF,FIXL,RSTBLK,TERL,TERBLK,FIPL,FIPBLK,CRAL,CRABLK>	;012
GLOBAL	<SESBLK,NSPBLK,TRNBLK,SESL,NSPL,TRNL,RDMBLK,RDML,EVLBLK,EVLL>	;018
GLOBAL	<UNABLK,QNABLK,QNAL,UNAL,GPKL,GPKBLK,PTBL,PTBBLK>		;024
GLOBAL	<DHPL,DHPBLK,DZPL,DZPBLK,VHPL,VHPBLK,FMSL,FMSBLK>		;026
GLOBAL	<LATL,LATBLK,KBXL,KBXBLK>					;033
GLOBAL	<NODL,NODBLK>							;030


.SBTTL	SCAN STB OF NEW FILE FOR ALL REQUIRED SYMBOLS

.ENABL	LSB

SCANST:	CLR	NOGOFG		;CLEAR OUT THE NO-GO FLAG
	CALLX	SILSCN,R5	;Find the last overlay module again	;032
	 .RAD50	/OV2   /						;032
	MOV	R0,SILENT	;All further work is done on OVR
	MOV	SE.STN(R0),R2	;R2 = Number of symbols in OVR
	MOV	SE.STB(R0),FC...+FCNVB ;Next read is of OVR STB
	MOV	#INSSYN,R4	;R4 -> NAMES OF SYMBOLS IN RAD50
	MOV	#INSSYM,R3	;R3 -> GLOBAL LOCATIONS AND VALUES
	MOV	2(R3),R1	;R1 = FIRST GLOBAL LOCATION (FOR CHECK)
10$:	BIS	#1,R1		;ODD FOR COMPARISON WITH FLAGGED ADDRESS
	CLR	(R3)+		;CLEAR VALUE WORD IN TABLE
	BIS	#1,(R3)		;SET FLAG SAYING SYMBOL NOT FOUND
	CMP	R1,(R3)		;WAS INIT LINKED RIGHT?
	BEQ	20$		;YES, ROOT & INSTALL ARE SYNCHRONIZED
	CMP	R3,#INSLCL	;NO, BUT IS THIS A LOCAL WIDGET?
	BHIS	20$		;YES, MONITOR ISN'T INVOLVED
	MESSAG	<"  INIT bug - INSTALL not synchronized at ">
	CALL	120$		;PRINT THE NAME
	CALLX	TYPECR		;NEW LINE
20$:	MOV	(R4)+,R1	;SKIP OVER SYMBOL NAME, CHECKING FOR 0
	BIS	(R4)+,R1
	BNE	30$		;NON-0, LEAVE IT MARKED
	DEC	(R3)		;UNMARKED SINCE NOT REQUIRED
30$:	MOV	(R3)+,R1	;RESYNCH
	ADD	#2,R1		;UPDATE R1
	CMP	R3,#INSSYE	;ANY MORE GLOBALS?
	BNE	10$		;YES
	MOV	#-1,R0		;ALL DONE; FORCE A READ TO START SCANNING STB
40$:	CMP	R0,#SATBUF+3000	;NEED TO READ?
	BLO	50$		;NO
	MOV	#FC...,R1	;YES, POINT TO FCB FOR READ
	CALLX	READ.B,R5,SATBUF+2000 ;READ IN AN STB BLOCK
	MOV	#SATBUF+2000,R0	;POINT TO FIRST SYMBOL IN BLOCK
50$:	MOV	#INSSYM,R3	;POINT TO INTERNAL TABLE TO SCAN
	MOV	#INSSYN,R4	;POINT TO LIST OF NAMES
60$:	CMP	(R0),(R4)+	;IS THIS SYMBOL ONE OF OURS?
	BNE	70$		;NO
	CMP	2(R0),(R4)	;MAYBE...
	BEQ	80$		;YES, INCLUDE IT IN OUR TABLE
70$:	TST	(R4)+		;NO, GO TO NEXT SYMBOL IN OUR TABLE
	ADD	#4,R3		;AND NEXT VALUE ITEM
	CMP	R3,#INSSYE	;DONE TABLE?
	BNE	60$		;NO
	BR	90$		;YES, TRY THE NEXT SYMBOL IN THE STB

GLOBAL	<FC...,SATBUF>


80$:	MOV	6(R0),(R3)+	;GOT A SYMBOL.  SAVE ITS VALUE
	BIC	#1,(R3)+	;TURN OFF NOT-FOUND FLAG
90$:	ADD	#10,R0		;POINT TO NEXT SYMBOL IN STB
	SOB	R2,40$		;TRY FOR MORE
	MOV	#INSSYM,R3	;SCAN THE TABLE ONE MORE TIME FOR NXS
	MOV	#INSSYN,R4
100$:	ADD	#4,R4		;POINT BEYOND SYMBOL NAME
	TST	(R3)+		;SKIP VALUE WORD
	BIT	#1,(R3)+	;NOT-FOUND FLAG ON?
	BEQ	110$		;NOPE, WE FOUND IT
	MESSAG	<"  Symbol ">
	CALL	120$		;PRINT SYMBOL NAME
	MESSAG	<" not found in monitor symbol table."<200>>
110$:	CMP	R3,#INSSYE	;DONE CHECKING?
	BNE	100$		;NO
	BR	BLDJAM		;YES, GO BUILD DEVICE DESCRIPTORS

120$:	MOV	(PC),NOGOFG	;GET ERROR
	CMP	-(R4),-(R4)	;BACK UP R4
	MOV	(R4)+,R0	;PRINT THE SYMBOL
	CALLX	RADZER
	MOV	(R4)+,R0
	CALLX	RADZER
	RETURN

.DSABL	LSB

	TMPORG	INSCTL
NOGOFG:	.WORD	0		;<>0 IF CANNOT COMPLETE THE INSTALL
	UNORG


.SBTTL	BUILD DESCRIPTOR BLOCKS FOR DEVICES GENERATED IN NEW SIL

.ENABL	LSB
                
BLDJAM:	MOV	#DSTBL+3000,R2	;POINT TO LOCATION FOR DESCRIPTOR TABLE
	CMP	R2,#SATBUF+3000	;MAKE SURE WE WERE LINKED RIGHT
	BLO	30$		;NO GOOD
	CLR	BLNRST		;NO BLOCK OF RSTS MODULE IS IN MEMORY YET
	CLR	RWRITE		;NO REWRITE IN MONITOR
	CLR	R3		;START WITH OFFSET 0 INTO DEVNAM TABLE
10$:	CMP	R3,.DEVOKB	;ARE WE UP TO KEYBOARDS YET?
	BEQ	DTJAM		;Yes, look at symbols for device support ;026
	CALL	RDRSO3,R4,.DEVNAM ;STILL DISKS.  GET DEVNAM(R3) FROM SIL
	CMPB	(R0),#'D	;IT HAD BETTER OUGHTA BE A DISK
	BNE	40$		;ALL DISK NAMES START WITH 'D'
	MOV	(R0),R0		;OK, GET ITS NAME
	MOV	R0,XXNAME	;SAVE IT AS THE RSTS NAME
	ADD	#'R-'D,R0	;MAKE IT AN INIT CONTROLLER NAME
	CALL	LOOKDN		;FIND THE CONTROLLER IN INIT'S TABLES   
	BCS	40$		;IF UNKNOWN, GIVE WARNING ERROR AND IGNORE IT
	CALL	RDRSO3,R4,.DEVCNT ;GET DEVCNT FOR THIS DISK
	TST	(R0)		;ARE THERE ANY OF THESE GENERATED?
	BMI	20$		;NO, SKIP IT
	CALL	CSRDCT		;LOOK UP $$CSXX AND XXDINT, PUT IN LIST
	BCS	50$		;NOT FOUND, GIVE WARNING AND SKIP IT
	CLR	XXCNUM		;CLEAR FOR MULTI-CNTRLR DISK DEVICES    
	CLR	XXUNIT		;CLEAR FOR MULTI-CNTRLR DISK DEVICES
	MOV	(R0),MAXUNT	;SET THE NUMBER OF RSTS UNITS CONTROLLED
	INC	MAXUNT		;  = DEVCNT + 1
15$:	MOVB	R3,(R2)+	;DS.DVN = OFFSET INTO DEVNAM
	CLRB	(R2)+		 ;DS.UNT = STARTING RSTS UNIT CONTROLLED = 0
	MOVB	MAXUNT,(R2)+	 ;DS.NUN = NUMBER OF RSTS UNITS CONTROLLED
	CMPB	(R4),#1		 ; Is this a multi-controller device?	;025
	BLE	16$		 ; No, so DS.UNT=0 and DS.NUN=DEVCNT+1	;025
	MOVB	PK.NUN(R4),-(R2) ;DS.NUN = PK.NUN (ALWAYS= CNTRLR'S MAX UNITS)
	MOVB	XXUNIT,-(R2)	 ;DS.UNT = XXUNIT, USED BY SET/START SUBOPTION
	CMPB	(R2)+,(R2)+	 ;	ADJUST THE DS BLOCK POINTER TO DS.DCS
16$:	MOVB	#1,(R2)+	;DS.NCS = NUMBER OF CSR'S TO JAM = 1 FOR DISK
	MOVB	R5,(R2)+	;DS.PKT = PACKET NUMBER IN INIT'S TABLES ;026
	MOVB	XXCNUM,(R2)+	;DS.CTL = CONTROLLER INDEX (MULTI-CNTRLR DISK)
	MOV	CSRXX,(R2)+	;DS.CSR = CSR.D? = PLACE FOR CSR
	MOV	XXDINT,(R2)+	;DS.DCT = D?DINT = PLACE TO VECTOR TO
	CLR	-(SP)		  ;CLEAR FOR A "MOVB"
	MOVB	PK.NUN(R4),(SP)	  ;GET THE NO. OF UNITS SUPPORTED BY 1 CNTRLLR
	ADD	(SP),XXUNIT 	  ;UPDATE OUR NEXT STARTING RSTS UNIT 
	INC	XXCNUM		  ;SET NEXT CONTROLLER INDEX
	SUB	(SP)+,MAXUNT	  ;SUBTRACT UNITS SERVICED BY 1 CONTROLLER
	BGT	15$		  ;MORE UNITS. BUILD ANOTHER CONTROLLER PACKET

20$:	ADD	#2,R3		;NEXT OFFSET INTO DEVTBL
	BR	10$		;TRY FOR ANOTHER DISK

30$:	ERF	<"INIT link bug - DSTBL too low">

GLOBAL	<DSTBL,SATBUF>


40$:	MESSAGE	<"  Error - unknown disk "> ;FUNNY NAME AT INDEX < DEVOKB
	BR	60$

50$:	MESSAGE	<"  Error - no set up for disk "> ;$$CSXX OR XXDINT NOT FOUND
60$:	CALLX	MESSAGE,R5,XXNAME ;TYPE DISK NAME
	CALLX	TYPECR		;NEW LINE
	MOV	(PC),NOGOFG	;CANNOT INSTALL IT
	BR	20$		;NOW SKIP IT

.DSABL	LSB


.SBTTL	BUILD DESCRIPTOR BLOCKS FOR KEYBOARDS

.ENABL	LSB

	TMPORG	INSCTL

MAXUNT:	.WORD	0		;NUMBER OF UNITS GENERATED IN MONITOR
XXUNIT:	.WORD	0		;CURRENT UNIT NUMBER
XXCNUM:	.WORD	0		;CONTROLLER NUMBER
XXSUBL:	.WORD	0		;SUBLINE WITHIN CONTROLLER

	UNORG


.SBTTL	CHECK FOR SUPPORT OF DECTAPE, CACHING

.ENABL	LSB

DTJAM:	CALL	GETSR4,R4	;GET THE NUMBER OF DECTAPES GENERATED	;026
	 .RAD50	/CNT.DT/
	BCS	30$		;NONE, LEAVE CNT.DT=0
	MOV	R0,.CNT.DT	;SET IT TO THE REAL COUNT
30$:	CALL	GETSR4,R4	;FIND OUT IF CACHING IS GENERATED
	 .RAD50	/$$CACH/
	BCS	50$		;NO, LEAVE THE FLAG 0
	MOV	R0,..CACH	;SAVE THE ADDRESS OF CACHE PARAMETERS
	CALL	GETSR4,R4	;AND WE NEED THE SIZE OF A CACHE TAG
	 .RAD50	/$$CHSZ/
	MOV	R0,..CHSZ	;SAVE IT
	BCC	40$		;OK
	CALL	MISMES		;IT'S MISSING?
	MESSAGE	<"$$CHSZ">
	CALL	@(SP)+		;REST OF TEXT
40$:	CALL	GETSR4,R4	;SEE IF EXTENDED CACHING IS SELECTED
	 .RAD50	/$$CBSZ/	;LOOK FOR THIS SYMBOL
	BCS	50$		;NO, HE DOESN'T WANT IT
	MOV	R0,..CBSZ	;SAVE ADDRESS OF EXTENDED CACHE CLUSTER SIZE
50$:	CLR	.SOFTKG		;NO SOFTWARE KG FOUND FOR RJ2780	;008
	CALL	GETSR4,R4	;NOW, LOOK FOR IT			;008
	.RAD50	/KGEMU /	;BY THIS SYMBOL NAME			;008
	BCS	55$		;NOT THERE, SO LEAVE IT CLEAR		;008
	CALL	GETSR4,R4	;NOW GET THE JAMMING LOCATION FOR RJ	;008
	.RAD50	/RJDCTL/	; WHICH IS NEAR THIS SYMBOL		;008
	BCS	55$		;NOT THERE??? - MUST NOT HAVE RJ2780	;008
	MOV	R0,.SOFTKG	;GOT BOTH, SO SAVE THE JAMMING LOCATION	;008
55$:	CALL	GETSR4,R4	;SEE IF DMP/DMV'S ARE SUPPORTED		;012
	 .RAD50	/XDDDDB/	;LOOK FOR THIS SYMBOL
	BCS	65$		;NO, HE DOESN'T WANT IT
	MOV	R0,.XDDDDB	;SAVE DDB ADDRESS OF 1ST XD DDB
	CALL	GETSR4,R4	;GET THE SIZE OF THE XD DDB
	 .RAD50	/DDS.XD/	;LOOK FOR THIS SYMBOL
	MOV	R0,.DDS.XD	;SAVE THE SIZE OF XD'S DDB
65$:	CALL	GETSR4,R4	;SEE IF DMC/DMR'S ARE SUPPORTED
	 .RAD50	/XMDDDB/	;LOOK FOR THIS SYMBOL
	BCS	70$		;NO, HE DOESN'T WANT IT
	MOV	R0,.XMDDDB	;SAVE DDB ADDRESS OF 1ST XM DDB
	CALL	GETSR4,R4	;GET THE SIZE OF THE XM DDB
	 .RAD50	/DDS.XM/	;LOOK FOR THIS SYMBOL
	MOV	R0,.XM.DDS	;SAVE THE SIZE OF XM'S DDB
70$:	CALLX	SILSCN,R5	;FIND RSTS IN THE SIL
	 .RAD50	/RSTS  /
	MOV	SE.IDN+2(R0),R1	;GET THE SECOND WORD OF THE IDENT
	CLR	R0		;CLEAR FOR DIVIDE
	DIV	#50*50,R0	;STRIP HIGH ORDER RAD50 CHARACTER
	CLR	R0		;CLEAR FOR DIVIDE
	DIV	#50,R0		;ISOLATE SYSTEM VERSION DIGITS
	CMPB	R1,#<^R  Z>	;Alpha or numeric RAD50?		;037
	BHI	72$		; Numeric (they are 22 below ascii)	;037
	ADD	#100-22,R1	; Alpha (they are 100 below ascii)	;037
72$:	ADD	#22,R1		; Make the final adjustment		;037
	SWAB	R1		;LOW ORDER TO HIGH BYTE (SECOND PRINTED)
	CMPB	R0,#<^R  Z>	;Alpha or numeric RAD50?		;037
	BHI	74$		; Numeric (they are 22 below ascii)	;037
	ADD	#100-22,R0	; Alpha (they are 100 below ascii)	;037
74$:	ADD	#22,R0		; Make the final adjustment		;037
	BISB	R0,R1		;MERGE THE DIGITS
	MOV	R1,.SYSVEN	;SAVE IT AS SYSTEM VERSION
	BR	XXJAM		;Skip the LK stuff until it is redone... ;026

;	TST	LKFLAG		;Do we have to set up LK stuff?		;024
;	BEQ	XXJAM		;No, skip ahead				;024
	MOV	#^RLKK,R1	;Set up name				;024
	CALL	XXKINT		;Search for "LKKINT"			;024
	CALL	GETSR4,R4	;And also				;024
	 .RAD50	/CSR.LK/	; for the CSR cell			;024
	BCC	80$		;Found it				;024
	CALL	MISMES		;Ouch, required symbol missing		;024
	MESSAGE	<"CSR.LK">						;024
	CALL	@(SP)+		; and finish the message		;024
80$:	MOV	R0,.CSRLK	;Save the CSR cell address		;024
	MOV	XXDINT,.VECLK	; and the interrupt entry address	;024
	.BR	XXJAM

.DSABL	LSB


.SBTTL	BUILD DESCRIPTOR BLOCKS FOR OTHER DEVICES
                        
.ENABL	LSB

XXJAM:	MOV	#-1,RJDRVR	;NO RJ2780 PACKET FOUND
	MOV	#-1,IIDRVR	;NO II DRIVER PACKET FOUND
	CLR	DDCTBL		;GUESS AT NO CONTROLLER CONVERSION TABLE
	CALL	GETSR4,R4	;LOOK FOR CONTROLLER CONVERSION SYMBOL
	 .RAD50	/DDCTBL/
	BCS	5$		;NONE
	MOV	R0,DDCTBL	;ONE, SAVE ITS STARTING ADDRESS
	CLR	UCTTBL		;GUESS AT NO CONTROLLER CONVERSION TABLE
	CALL	GETSR4,R4	;LOOK FOR THE UNIT CONTROLLER TABLE SYMBOL
	 .RAD50	/UCTTBL/
	BCS	65$		;NONE? THATS A TABLE BUG.
	MOV	R0,UCTTBL	;ONE, SAVE ITS STARTING ADDRESS
5$:	MOV	.DEVOKB,R3	;R3 = OFFSET INTO DEVNAM FOR KEYBOARDS
	MOV	..2780,RJNMAP	;DEVICE RJ: MAPS TO THE 2780 DEVICE
	BNE	10$		;IF ANY
	MOV	#"RJ,RJNMAP	; ELSE GIVE AN ERROR IF RJ: EXISTS
10$:	ADD	#2,R3		;NEXT OFFSET IN DEVNAM
	MOV	R3,R0		;CHECK FOR SYNONYMS
	ADD	.DEVNAM,R0	;COMPUTE ADDRESS IN DEVNAM TABLE
	CMP	R0,.DEVSYN	;SYNONYMS?
	BHIS	75$		;YES, WE ARE DONE
	CALL	RDRSO3,R4,.DEVNAM ;GET THE DEVICE NAME
	MOV	(R0),XXNAME	;SET IT UP FOR CSRDCT
	BMI	75$		;NOW DONE
	CMP	(R0),#"RJ	;IS THIS A YUCK RJ2780?
	BNE	20$		;NOPE
	MOV	R3,RJDRVR	;YUP, SAVE DEVNAM OFFSET IN INSBUF
20$:	CMP	(R0),#"II	;IS THIS AN II DRIVER?
	BNE	30$		;NOPE
	TST	IIDRVR		;IS THIS THE FIRST?
	BPL	30$		;NOPE,
	MOV	R3,IIDRVR	;YUP, SAVE DEVNAM OFFSET IN INSBUF
30$:	MOV	#DVNMAP,R5	;GET DEVICE NAME MAPPER
40$:	CMP	(R0),(R5)+	;MAP THIS NAME?
	BEQ	50$		;YES
	TST	(R5)+		;NO, SKIP MAP
	BNE	40$		;TRY FOR MORE
	MOV	R0,R5		;NO MAPPING, USE GIVEN NAME
50$:	MOV	(R5),R0		;R0 = INIT NAME FOR DEVICE
	BMI	10$		;IGNORE 'NL' AND 'PK'
	CALL	LOOKDN		;LOOK FOR THAT NAME
	BCS	60$		;OOPS
	CALL	CSRDCT		;GET CSR.XX AND XXDINT
	BCC	70$		;GOT IT
60$:	MESSAGE	<"  Warning - no set up for device ">
	CALLX	MESSAGE,R5,XXNAME
	CALLX	TYPECR
	BR	10$

65$:	MESSAGE	<" Device controller table (DDCTBL) ">
	MESSAGE <"has an illegal format"<200>>
	MOV	(PC),NOGOFG	;WE CAN'T INSTALL THIS SIL, BUT
	CLR	R0		; MAKE SURE WE DON'T USE THIS TABLE
	BR	10$		;  AND CONTINUE TO SCAN FOR MORE ERRORS.

70$:	CALL	RDRSO3,R4,.DEVCNT ;HOW MANY OF THESE?
	MOV	(R0),MAXUNT	;MAXUNT = NUMBER OF RSTS UNITS
	BMI	10$		;NONE

GLOBAL	<RJDRVR,IIDRVR>


	MOV	DDCTBL,R0	;LOAD CONVERSION TABLE BASE
	BEQ	78$		;(IF ZERO THEN WE CAN'T READ ANY ENTRIES).
	ADD	R3,R0		;  PLUS THE DEVNAM OFFSET
	SUB	.DEVOKB,R0	;    MINUS THE DISK NAMES
	ADD	#2,R0		;      PLUS 2 = OUR DDCTBL DEVICE INDEX.
	CALL	RDRSTS		;NOW READ THE ENTRY
	TST	(R0)		;IS THERE AN ENTRY INTO UCTTBL?
	BEQ	78$		;NO, NO TABLE ENTRY FOR THIS DEVICE TYPE
	MOVB	(R0)+,UCTNUM	;SAVE THE # OF CONTROLLERS 
	MOVB	(R0)+,UCTTBO	;  AND UCTTBL INDEX
	BR	79$		;NOW GO READ THE UCTTBL ENTRY

75$:	BR	100$		;WE ARE DONE, GO ZERO OUT THE DSTABL'S TAIL

78$:	CLR	UCTNUM		;SET NUMBER OF CONTROLLERS TO 0 FOR NO ENTRY
79$:	CLR	XXUNIT		;START UNIT NUMBER AT 0
	MOV	#-1,XXCNUM	;START CONTROLLER NUMBER AT (BIASED) 0  
80$:	INC	XXCNUM		;INCREMENT CONTROLLER NUMBER
	MOV	UCTNUM,R0	;THERE SHOULD BE AT LEAST 1 CONTROLLER
	BEQ	83$		;IF ZERO THEN THERE'S NO ENTRY
	MOV	UCTTBL,R0	;GET THE CONTROLLER UNIT COUNT TABLE BASE.
	ADD	UCTTBO,R0	;ADD IN OUR UCTTBL OFFSET ONLY.
	CALL	RDRSTS		;READ THE TABLE ENTRY
	ADD	#2,UCTTBO	; THEN BUMP OFFSET TO NEXT ENTRY        
	MOV	(R0),R0		;FETCH UNIT MAXIMUM FOR THIS CONTROLLER
	BEQ	65$		;ZERO?  THAT'S A TABLE ENTRY BUG...
83$:	DEC	R0		;FORM (MAXUNIT -1) OR -1 FOR NO TABLE ENTRY
	MOVB	R3,(R2)+	;DS.DVN = DEVNAM OFFSET
	MOVB	XXUNIT,(R2)+	;DS.UNT = STARTING RSTS UNIT NUMBER
	CLR	(R2)+		;NO CSR'S OR UNITS YET
	MOVB	R5,(R2)+	;DS.PKT = PACKET NUMBER			;026
	MOVB	XXCNUM,(R2)+	;PUT IN CONTROLLER NUMBER
	MOV	XXUNIT,(R2)	;PUT IN UNIT NUMBER
	ASL	(R2)		; *2
	ADD	CSRXX,(R2)+	;JAM IN THE CSR HERE
	MOV	XXDINT,(R2)+	;INTERRUPT TO HERE
90$:	ADD	#1*400+1,DS.NUN-DS.XXX(R2) ;1 MORE CSR, 1 MORE UNIT
	INC	XXUNIT		;BUMP THE RSTS UNIT NUMBER
	CMP	XXUNIT,MAXUNT	;ANY MORE OF THESE?
	BLOS	95$		;YES, GO SEE IF WE'RE WITHIN OUR LIMITS.
	JMP	10$		;NO, GO DO NEXT DEVICE TYPE

95$:	CMPB	DS.NUN-DS.XXX(R2),R0 ;SHOULD THIS CONTROLLER HANDLE MORE?
	BHI	80$		;NO
	CMPB	DS.NUN-DS.XXX(R2),PK.NUN(R4) ;CAN THIS CONTROLLER HANDLE MORE?
	BLO	90$		;YES
	CMP	PK.NAM(R4),#"XD	;IS THIS THE VARIABLE PACKET XD?
	BNE	98$		;NO,, MAY BE SOMETHING IS WRONG.
	CMPB	DS.NUN-DS.XXX(R2),#DMPNU ;FOR "XD" WE CHECK THE DMP'S LIMIT
	BLO	90$		;OK. DISABLE LINES OVER DMV'S LIMIT AT START
98$:	TST	R0		;DID WE MISS THE CONVERSION TABLE LIMIT?
	BMI	80$		;NOPE, OK, LOOP FOR NEXT CONTROLLER
	MESSAGE	<" Device controller table (DDCTBL) ">
	MESSAGE <"declares too many units for controller"<200>>
	MOV	(PC),NOGOFG	;DON'T INSTALL THIS SIL,
	BR	80$		;  BUT CONTINUE TO CHECK FOR MORE ERRORS.


100$:	CLR	(R2)+		;ZERO OUT THE TAIL
	CLR	(R2)+
	CLR	(R2)+
	TST	NOGOFG		;CAN WE GO?
	BEQ	110$		;YES
	MOV	(PC)+,R0	;NO, GET ERROR
	 GENTXT	<<177><12>"  SIL cannot be installed">
	JMP	ERRMS		;PRINT IT

110$:	CMP	R2,#DSTBLE+3000	;DO WE WRITE OUTSIDE OF OUR DISK BUFFER?
	BLOS	120$		;OK
	ERF	<"  Too many blocks in device configuration table">

120$:	MOV	#DSTBLO,R0	;R0 -> OVERLAY CALL FOR DS TABLE
	CMP	(R0)+,(R0)+	;ADVANCE TO OVERLAY NUMBER FOR DS TABLE
	MOV	(R0),R0		;FETCH OVERLAY NUMBER
	ADD	#$OVTAB-6,R0	;USE AS AN INDEX INTO OVERLAY DISPATCH TABLE
	TST	(R0)+		;SKIP TO RELATIVE BLOCK NUMBER OF OVERLAY
	MOV	(R0),R0		;FETCH RELATIVE BLOCK NUMBER
	SUB	#DSTBL+3000,R2	;COMPUTE LENGTH OF DS TABLE TO BE WRITTEN
	MOV	#FCINIT,R1	;POINT TO INIT'S FCB
	MOV	R0,FCNVB(R1)	;SET UP BLOCK IN FCB
	MOV	R2,R0		;GET SIZE OF TABLE TO WRITE
	ROR	R0		;MAKE LENGTH A WORD COUNT
	CALLX	WRITE.,R5,DSTBL+3000
	.BR	REMOVE

.DSABL	LSB

	TMPORG	INSCTL
DDCTBL:	.WORD	0		;BASE OF CONTROLLER CONVERSION TABLE
UCTTBL:	.WORD	0		;BASE OF CONTROLLER UNIT COUNT
UCTTBO:	.WORD	0		; [HIGH BYTE] OFFSET IN UCTTBL FOR DEVICE
UCTNUM:	.WORD	0		; [LOW  BYTE] # OF CONTROLLERS IN UCTTBL
DVNMAP:	.WORD	"MT,"TM		;MAP RSTS NAMES TO INIT NAMES
	.WORD	"MM,"TU
	.WORD	"DT,"TC
	.WORD	"MS,"TS
	.WORD	"II,"D1
	.WORD	"DX,"RX
	.WORD	"RJ
RJNMAP:	.WORD	"RJ		;RJ MAPS TO THE 2780 DEVICE
	.WORD	"NL,-1
	.WORD	"PK,-1
	.WORD	0,0
	UNORG

GLOBAL	<DSTBLE,DMPNU,DSTBL,DSTBLO,FCINIT,$OVTAB>


.SBTTL	REMOVE THE OLD SIL
.ENABL	LSB

REMOVE:	MOV	#DEFCPY,R0	;POINT TO DEFAULT PRESERVATION AREA
	MOV	#4,R1		;FOUR WORDS TO CLEAR
10$:	CLR	(R0)+		;CLEAR IT
	SOB	R1,10$		; OUT
	CALLX	LKSIL		;ENSURE THE OLD SIL IS OPEN
	BCS	30$		;NO OLD SIL (OR NOT FOUND)
	CALLX	DEFALI		;ENSURE THAT DEFAULTS ARE IN MEMORY
	BEQ	20$		;NO DEFAULTS SET, SO IT'S EASY
	MOV	#D.ERRN,R4	;Point to the error file name		;007

; NOTE: TURNING OFF THE ERR NO KILL BITS MAY BE DONE AT STARTUP TIME

	CALL	NOKOFF,R3,<^RERR> ;TURN OFF NO KILL BITS

20$:	MOV	#SILNAM,R4	;TURN OFF NO KILL BIT IN OLD SIL
	CALL	NOKOFF,R3,<^RSIL>
	MOV	#DEFCPY,R0	;POINT TO DEFAULTS TO PRESERVE ACROSS INSTALLS
	MOV	D.CPRF,(R0)+	;PRESERVE CLOCK PREFERENCE
	MOV	D.CRAT,(R0)+	; AND FREQUENCY
	CLR	(R0)+		;Advance over old DATE FORMAT		;001
	CLR	(R0)+		;Advance over old TIME FORMAT		;001
30$:	MOV	#FQ...,R0	;COPY TEMP FIRQB TO FQSIL FIRQB
	MOV	#FQSIL,R1
	MOV	#FQFCB+FCBSIZ/2,R3 ;LENGTH INCLUDING FCB
40$:	MOV	(R0)+,(R1)+
	SOB	R3,40$
	MOV	#SILNAM+2,R4	;R4 -> SIL NAME
	MOV	#FQSIL+FQNAM1+2,R1 ;R1 -> NAME OF NEW SIL
	MOV	(R1),(R4)	;PUT IT INTO INSTALL BUFFER
	MOV	-(R1),-(R4)
	CALLX	DEFALI		;READ NEW SIL INDEX, GET DEFAULTS
	CALLX	SILSCN,R5	;FIND THE RSTS MODULE AGAIN
	 .RAD50	/RSTS  /
	MOV	SE.SIZ(R0),RSTSIZ ;SET UP SIZE OF RSTS MODULE
	CALL	NOKON,R3,<^RSIL> ;TURN ON NO KILL BIT IN NEW SIL
	MOV	#INSSYM,R4	;R4 -> GLOBAL VALUES
	MOV	#<INSSYE-INSSYM>/4,R0 ;R0 = NUMBER OF GLOBALS
50$:	MOV	(R4)+,@(R4)+	;FILL DEFAULT BUFFER
	SOB	R0,50$		;ALL OF IT




.SBTTL	Rewrite the LOW CORE table into the SIL				

	CALLX	DEFALO		;REWRITE IT
	MOV	.$LOWE,R4	;GET ADDRESS OF LOW CORE TABLE END
	SUB	.$LOWS,R4	;COMPUTE LENGTH OF TABLE
	ROR	R4		;WORD COUNT
	MOV	.$LOWC,R3	;GET ADDRESS OF STUFF TO PUT THERE
	MOV	R4,R2		;COPY THE WORD COUNT
120$:	MOV	R3,R0		;POINT TO WORD
	CALL	RDRSTS		;READ IT
	MOV	(R0),-(SP)	;SAVE WORD TO JAM
	ADD	#2,R3		;BUMP ADDRESS
	SOB	R2,120$		;DO MORE
	MOV	.$LOWE,R3	;POINT TO END OF DESTINATION
130$:	SUB	#2,R3		;BACK UP A WORD
	MOV	R3,R0
	CALL	RDRSTS		;GET POINTER TO OUTPUT
	MOV	(SP)+,(R0)	;SET UP THE SIL CHANGE
	INC	RWRITE		;WE REQUIRE REWRITE
	SOB	R4,130$
	CALL	WRITRC		;FORCE OUT ANY PARTIAL BUFFER

GLOBAL	<SILNAM,D.ERRN,D.CPRF,D.CRAT,FQ...,FQSIL>			;007
GLOBAL	<RSTBLK,RSTSIZ>							;012
GLOBAL	<SYSUSV,SYNXSV,DSKMID>


	TST	I.DFLD		;ARE THERE DEFAULTS IN THE NEW SIL?
	BPL	140$		;None (or DEFALT does it for you) is easy ;001
	MOV	#D.ERRN,R4	;Point to error file name		;007

				;THIS MAY (OR MAYNOT) BE DONE AT STARTUP TIME

	CALL	NOKON,R3,<^RERR> ;TURN ON NO KILL BIT IN ERR
	BR	150$		;DONE


140$:	MOV	#DEFCPY,R3	;PRESERVE SOME DEFAULTS
	MOV	(R3)+,D.CPRF	;PREFERRED CLOCK
	MOV	(R3)+,D.CRAT	; AND RATE
	TST	(R3)+		;Advance over old DATE FORMAT		;001
	TST	(R3)+		;Advance over old TIME FORMAT		;001
150$:	MOV	#DEFBUF,R3	;POINT TO THE END
	ADD	#SIZDEF,R3	; OF DEFBUF
	CLR	R0		;CLEAR CHECKSUM
160$:	MOV	-(R3),R2	;GET ANOTHER WORD
	XOR	R2,R0		;FORM CHECKSUM OF PERMANENT SYMBOL AREA
	CMP	R3,#DEFBFP	;DOWN TO START OF PERMANENT AREA?
	BHI	160$		;NO
	MOV	R0,SILCKS	;SAVE THE SIL CHECKSUM IN INSBUF
	CALLX	INSTAO		;REWRITE THE INSTALL BUFFER
	MOV	#CFGBUF+CFG$NA,R4 ;R4 -> Start of SIL name in CFGBUF.	;034
	MOV	SILNAM,R0	;Get first word of SIL name.		;034
	CALLX	RADCNV		;Convert from RAD50 to ASCII.		;034
	ADD	#3,R4		;Now, R4 -> last half of ASCII name.	;034
	MOV	SILNAM+2,R0	;Same for second word.			;034
	CALLX	RADCNV							;034
	MOV	#CFGBUF+CFG$ZE,R0 ;R0 -> ASCIZ null terminator.		;038
165$:	CLRB	(R0)		;Clear a byte.				;038
	CMPB	-(R0),#'0	;Now, R0 -> previous byte. Alphanumeric?;038
	BLO	165$		;No, so keep clearing.			;038
	CALLX	WRITCF		;Write CFGBUF back into [0,1]CONFIG.SYS	;034
	CMP	@#B.JMP,#137	;EVER USED INSTALL OR HARDWR?
	BEQ	180$		;NO, GOTTA FIX BOOT BLOCK		
	TSTB	AUTOIN		;Should we START the newly installed SIL?;001
	BMI	170$		;  Yes. So do it.			 ;001
	EXIT			; No, Just go back to "Option:" prompt.	 ;001

170$:	MOV	#KBUFF,R1	; Set R1 to a random buffer (TT: input	 ;001
	CLR	(R1)		;   buffer), & disable pre-answer check. ;001
	JMPX	START0		; Now START-up the newly installed SIL!	 ;001

180$:	CLR	R2		;READ IN BOOT BLOCK
	CLR	R3
	MOV	#256.,I.DSQ+DSQCNT ;ONE BLOCK
	CALLX	PARSEX,R5,<RFUN,SATBUF> ;READ THE BOOT BLOCK
	MOV	#12707,SATBUF+<B.JMP-B.BOOT> ;CHANGE 'JMP @(PC)+' TO 'MOV (PC)+,PC'
	CLR	R2		;REWRITE THE BOOT BLOCK
	CLR	R3
	CALLX	PARSEX,R5,<WFUN,SATBUF> ;WRITE IT
200$:	MESSAGE	<"  Rebooting . . ."<200><12>>
	JMPX	BOOTSY	;REBOOT TO ENABLE ALL DEVICES

.DSABL	LSB

	TMPORG	INSCTL
DEFCPY:	.BLKW	4
	UNORG

GLOBAL	<I.DFLD,D.ERRN,D.CPRF,D.CRAT,DEFBUF,SIZDEF>			;007
GLOBAL	<DEFBFP,SILCKS,I.DSQ,SATBUF,AUTOIN,KBUFF>
GLOBAL	<CFGBUF>							;034

.SBTTL	FIND A DEVICE IN INIT'S TABLES

;+
; LOOKDN - FIND A DEVICE PACKET IN DEVTBL
;
;	R0 = HARDWARE DEVICE NAME AS 2-CHARACTERS OF ASCII
;
;	CALL	LOOKDN
;
;	C=0	DEVICE WAS FOUND
;		R4 -> DEVICE PACKET
;		R5 =  Packet number
;                                                 
;	C=1	DEVICE NOT FOUND
;		R4 =  Undefined
;		R5 =  Undefined
;-

LOOKDN:	CLR	R5		;PACKET NUMBER 0 SO FAR			;026
	MOV	#DEVTBL,R4	;POINT TO TABLE                        	
10$:	CMP	R0,PK.NAM(R4)	;IS THIS IT?                            
	BEQ	20$		;YUP, C=0 FROM CMP                      
	INC	R5		;COUNT PACKETS                          ;026
	ADD	#PKTSIZ,R4	;POINT TO NEXT PACKET          		
	TST	(R4)		;ANY MORE?                              
	BNE	10$		;YUP                                    
	SEC			;NO, INDICATE FAILURE                   
20$:	RETURN                                                          

GLOBAL	<DEVTBL>

.SBTTL	GET A SYMBOL FROM A MODULE STB

;+
; GETSR4--Get a symbol from a module STB.
;
; SILENT ->	SIL index entry.
; FC...	=	FCB for reading STB (??)
;
; CALL	GETSR4,R4
;	 .RAD50	/symbol/	(name symbol to look up--two words of RAD50)
;
; C=1	if symbol not found
;
; C=0	if symbol found
; R0	=	value of symbol
;
; SIDE EFFECTS:
; FC...	munged
; SATBUF munged
;-

;+
; GETSYM--Get a symbol from a module STB.
;
; SILENT ->	SIL index entry for module.
; R4	->	name of symbol to look up (two words of RAD50).
; FC...	=	FCB for reading STB (??)
;
; CALL	GETSYM
;	 .RAD50	/symbol/	(name symbol to look up--two words of RAD50)
;
; R4	bumped past end of symbol
;
; C=1	if symbol not found
;
; C=0	if symbol found
; R0	=	value of symbol
;
; SIDE EFFECTS:
; FC...	munged
; SATBUF munged
;-


.ENABL	LSB

GETSR4::CALL	GETSYM		;ENTRY IF SYMBOL FOLLOWS CALL
	RETURN	R4

GETSYM::REGSCR			;Save registers.
	ADD	#4,TOS.R4(SP)	;Bump returned R4.
	MOV	SILENT,R5	;R5 -> SIL index entry.
	MOV	#-1,R0		;Force a read the first time.
	MOV	SE.STN(R5),R2	;R2 = number of symbols to check.
	BEQ	40$		;None is error.
	MOV	#FC...,R1	;R1 -> FCB for reading STB.
	MOV	SE.STB(R5),FCNVB(R1) ;Read from STB block of module.
10$:	CMP	R0,#SATBUF+3000	;End of STB?
	BLO	20$		;No, same block.
	MOV	#256.,R0	;Read one block
	CALLX	READ.,R5,SATBUF+2000 ; of the STB.
	MOV	#SATBUF+2000,R0	;R0 -> STB.
20$:	CMP	(R0),(R4)	;Is this it?
	BNE	30$		;No.
	CMP	2(R0),2(R4)	;Is it?
	BEQ	50$		;Yes.
30$:	ADD	#10,R0		;No.  Point to next entry.
	SOB	R2,10$		;Loop until no more symbols in STB.
40$:	SEC			;Indicate failure.
	RETURN

50$:	MOV	6(R0),TOS.R0(SP) ;Return value in R0.
	RETURN			;Return with C=0 from CMP.

.DSABL	LSB

	TMPORG	INSCTL
SILENT::.WORD	0		;POINTER TO SIL ENTRY FOR MODULE
	UNORG

GLOBAL	<FC...,SATBUF>


.SBTTL	GET A WORD FROM THE RSTS MODULE OF THE SIL

;+
; RDRSTS - Read RSTS module and return a word.
;
; R0	= 	address within RSTS (virtual ??).
; FC...	is	FCB for SIL.
; FCSIL is	FCB for writing to SIL.
; SATBUF	may contain a block of RSTS module.
; BLNRST =	block number of SIL block currently in SATBUF.
;	=	0 if no block is currently in SATBUF.
; RWRITE <>	0 to rewrite the block currently in SATBUF out to the SIL 
;		before reading a new block in.
;	=	0 if block currently in SATBUF should be thrown away.
;
; CALL	RDRSTS
;
; R0	->	word in buffer.
; SATBUF	contains block that contains requested word of RSTS module.
; BLNRST =	block number of SIL block currently in SATBUF.
;
; SIDE EFFECTS:
;
; FC...+FCNVB changed
; FCSIL+FCNVB changed
;-

;+
; RDRSO3 - Read RSTS module and return a word.
;
; R3	=	offset to address within RSTS module.
; FC...	is	FCB for reading from SIL.
; FCSIL is	FCB for writing to SIL.
; SATBUF	may contain a block of RSTS module.
; BLNRST =	block number of SIL block currently in SATBUF.
;	=	0 if no block is currently in SATBUF.
; RWRITE <>	0 to rewrite the block currently in SATBUF out to the SIL 
;		before reading a new block in.
;	=	0 if block currently in SATBUF should be thrown away.
;
; CALL	RDRSO3,R4
;  .WORD <base address within RSTS module>
;
; R0	->	word in buffer.
; SATBUF	contains block that contains requested word of RSTS module.
; BLNRST =	block number of SIL block currently in SATBUF.
;
; SIDE EFFECTS:
;
; FC...+FCNVB changed
; FCSIL+FCNVB changed
;-



.ENABL	LSB

RDRSO3:	MOV	R3,R0		;Get offset from R3.
	ADD	@(R4)+,R0	;Base address follows the call.
	CALL	RDRSTS		;Get the word
	RETURN	R4		;and return properly.

RDRSTS:	REGSCR			;Save registers.
	MOV	R0,R2		;Copy address.
	BIC	#777,R2		;Remove block offset from address.
	BIC	R2,R0		;Leave only the block offset in R0.
	ADD	#SATBUF,R0	;R0 -> location of desired word in SATBUF.
	MOV	R0,TOS.R0(SP)	;Return pointer in R0.
	SWAB	R2		;Convert R2 to relative block number
	ROR	R2		; within RSTS module.
	ADD	RSTBLK,R2	; and make it relative within the file	;002
	CMP	R2,BLNRST	;Is it already in SATBUF?
	BEQ	10$		;Yup, that's easy.
	CALL	WRITRC		;No, rewrite block if necessary.
	MOV	#FC...,R1	;R1 -> FCB for read.
	MOV	R2,FCNVB(R1)	;Specify block to read.
	CALLX	READ.B,R5,SATBUF ;Read it in.
	MOV	R2,BLNRST	;Remember what's there.
10$:	RETURN

.DSABL	LSB

GLOBAL	<SATBUF,FC...>


.SBTTL	REWRITE MONITOR IF REQUIRED

;+
; WRITRC - Rewrite block to SIL if required.
;
; FCSIL	is	FCB for writing to SIL.
; SATBUF	contains a block of SIL.
; BLNRST =	block number of SIL block currently in SATBUF.
; RWRITE <>	0 to rewrite the block currently in SATBUF out to the SIL.
;	=	0 to do nothing.
;
; CALL	WRITRC
;
; SIL 		updated.
; RWRITE =	0.
;
; SIDE EFFECTS:
;
; FCSIL+FCNVB changed.
;-

.ENABL	LSB

WRITRC:	TST	RWRITE		;Rewrite needed?
	BEQ	10$		;No.
	MOV	#FCSIL,R1	;Yes, R1 -> FCB for write.
	MOV	BLNRST,FCNVB(R1) ;Set block number to write.
	CALLX	WRIT.B,R5,SATBUF ;Do it.
	CLR	RWRITE		;No need any more.
10$:	RETURN

.DSABL	LSB

	TMPORG	INSCTL
BLNRST:	.WORD	0		;Block of SIL in memory.
RWRITE:	.WORD	0		;<>0 if rewrite of block needed.
	UNORG

GLOBAL	<FCSIL,SATBUF>


.SBTTL	GET NEW SIL NAME

.ENABL	LSB

PRESET:	MOV	(R5)+,R2	;FETCH POINTER TO OLD NAME
10$:	MOV	(R5),R0		;FETCH POINTER TO SHORT QUESTION
	TST	(R2)		;SEE IF THERE IS A DEFAULT ANSWER
	BNE	20$		;If so, then use it ( & ask for change).;004
	CALL	FNDSIL		;Select the 1st SIL in [0,1] as default	;004
	BCS	20$		;More than 1 SIL in [0,1], use first	;004
	TST	(R2)		;0 or 1 SIL found, which was it?	;007
	BEQ	55$		;None.  Uh oh!				;007
	CALLX	MESSAG,R5,STRTMS;Only one SIL, so why ask?		;038
	MOV	(R2),R0		;GET FIRST HALF OF DEFAULT SILNAME	;004
	CALLX	RADZER		;TYPE OUT SIL NAME			;004
	MOV	2(R2),R0	;GET SECOND HALF OF SIL NAME		;004
	CALLX	RADZER		;WRITE OUT COMPLETE SIL NAME		;004
	CALLX	MESSAG,R5,SILEXT					;038
	MOV	#KBUFF,R1	;Make sure R1 points to a real buffer	;004
	BR	30$		;  and return

20$:	CALLX	ASCIZ0		;WRITE OUT SHORT QUESTION
	MESSAG	<<40><74>>	;PUT PARENTHESIS AROUND THE DEFAULT	;004
	MOV	(R2),R0		;GET FIRST HALF OF DEFAULT SILNAME
	CALLX	RADZER		;TYPE OUT SIL NAME
	MOV	2(R2),R0	;GET SECOND HALF OF SIL NAME
	CALLX	RADZER		;WRITE OUT COMPLETE SIL NAME
	MESSAG	<<76>>		;BE SURE TO BRACKET WITH PARENTHESIS
	MESSAG	<"? ">		;PRINT OUT QUESTION MARK
	MOV	#-1,CC.DBL	;Disable ^C				;009
	CALLX	GETIN		;GET ANSWER FROM THE USER
	BEQ	40$		;IF <CR> OR '? THEN GIVE HELP
	CLR	CC.DBL		;Re-enable ^C				;009
	CMPB	(R1),#'C-100	;See if he typed a ^C			;009
	BEQ	60$		;Yep, so restore old SIL name and leave	;009
	CMPB	(R1),#'Z-100	;SEE IF HE TYPED A ^Z			;009
	BEQ	60$		;YES, THEN END INSTALL TASK
	CMPB	(R1),#12	;SEE IF HE TYPED A LINE FEED
	BNE	50$		;IF NOT THEN GET STRING INPUT
30$:	CLRB	(R1)		;MAKE STANDARD RADINP RETURN		;004
	CMP	(R5)+,(R5)+	;ADVANCE THE RETURN POINTER BY 4
	MOV	SILNAM,R0	;PUT THE DEFAULT INTO THE RETURN STRING
	MOV	SILNAM+2,R3	;BOTH HALVES OF IT
	RETURN	R5		;THEN RETURN

40$:	CLR	CC.DBL		;Re-enable ^C				;009
	MOV	2(R5),R0	;GET POINTER TO LONGER HELP QUESTION
	CALLX	ASCIZ0		;AND WRITE OUT THE LONG HELP
	CALL	PRTSIL		;Now print a list of all SILs in [0,1]	;004
	BR	10$		;THEN GO GET THE ANSWER AGAIN

50$:	CALLX	RADINP		;GET THE USERS ANSWER IN RAD50
	TSTB	(R1)		;SEE IF THERE WAS AN ERROR
	ADD	#4,R5		;ADVANCE THE RETURN TO THE CORRECT LOCATION
	RETURN	R5		;OTHERWISE RETURN TO HAVE THE STRING CHECKED

55$:	MESSAG			;Tell user there's nothing here		;009
	  .ASCII <200>"??? No valid V"
	  .IIF NE <<SYSVEL&377>-'0>	.BYTE <SYSVEL&377>
	  .BYTE <SYSVEL/400>,<SYSVEE&377>,<SYSVEE/400>
	  .IIF NE <$$$VER-"00>		.BYTE '-,<$$$VER&377>,<$$$VER/400>
	  .ASCIZ " monitor files in [0,1]"<200>
	 UNORG
	.BR	60$		;Cant do much more, go back to Option:	;007

60$:	MOV	OLDSIL,SILNAM	;Make sure we leave things how they were ;009
	MOV	OLDSIL+2,SILNAM+2	;Both words			;009
	EXIT			;Leave INSTALL if ^Z or ^C typed	;009

	TMPORG	INSCTL
OLDSIL:	.BLKW	2		;Save area for previous SIL name	;009
NORTRY:	.BLKB	1		;Flag for retrying option		;009
	.EVEN
	UNORG

.DSABL	LSB

GLOBAL	<SILNAM,CC.DBL>


.SBTTL	CHECK FOR CONTIGUOUS FILE ON FQ...

;+
; CHKCTG - CHECK FOR CONTIGUOUS FILE
;
;	FILE OPEN ON FQ...
;
;	CALL	CHKCTG
;
;	C=0 IF FILE IS CONTIGUOUS
;	C=1 IF FILE IS NOT CONTIGUOUS
;-

CHKCTG:	REGSCR			;SAVE REGISTERS
	MOV	#FQ...+FQFCB,R1	;R1 -> FCB FOR THE SIL
	CALLX	RNB		;READ IN THE NAME ENTRY
	MOVB	FCLUS(R1),R1	;R1 = CLUSTER SIZE - 1
	BIC	#177400,R1	;REMOVE SIGN EXTENSION
	INC	R1		;R1 = CLUSTER SIZE
	CLR	R0		;CLEAR FOR DIVIDE
	DIV	DCS,R0		;FILE CLUSTER SIZE / DEVICE CLUSTER SIZE
				;R0 = # OF DEVICE CLUSTERS PER RP
	MOV	UAR(R5),R3	;R3 = LINK TO RETRIEVAL ENTRIES
	CALLX	RDB		;GET RETREIVAL ENTRY
	MOV	2(R5),R1	;R1 = FIRST RETRIEVAL POINTER
	MOV	R3,-(SP)	;SAVE LINK TO THIS RE
10$:	MOV	(SP)+,R3	;GET LINK TO NEXT RE
	BIC	#17,R3		;REMOVE FLAG BITS
	BEQ	40$		;DONE
	CALLX	RDB		;READ IN THE RETREIVAL ENTRY
	MOV	(R5)+,-(SP)	;SAVE LINK TO NEXT RE
20$:	CMP	R1,(R5)+	;DOES THIS MATCH EXPECTED?
	BEQ	30$		;YES, FILE CONTIGUOUS SO FAR
	COM	(SP)+		;NO, DUMP THE DIRECTORY LINK
	RETURN

30$:	ADD	R0,R1		;YES, BUMP DCN BY COUNT
	BIT	R5,#17		;END OF THIS RE?
	BEQ	10$		;YUP
	TST	(R5)		;NO, BUT IS THERE ANOTHER?
	BNE	20$		;YES, TRY AGAIN
	TST	(SP)+		;DUMP THE LINK TO NEXT ENTRY
40$:	CLC			;RETURN C=0
	RETURN			;IT IS CONTIGUOUS

GLOBAL	<DCS>


.SBTTL	PRINT THE LIST OF ALL THE SIL FILES IN [0,1]
.SBTTL	FIND A VALID SIL IN [0,1] TO START
;+
;  PRTFIL	Print a list of all .SIL files in [0,1]
;+
;  FNDSIL	Find the first .SIL file in [0,1]
;		C-bit set means there is more than one SIL in [0,1]
;		C-bit clear means only 1 (or no) SIL found in [0,1]
;		SILNAM = 1st SIL in [0,1] or zero if no SILs found
;		
;-

.ENABL	LSB

FNDSIL:	REGSCR			;SAVE THE REGISTERS			;004
	CALL	30$		;Find the first SIL			;004
	MOV	FQNAM1(R4),SILNAM     ;We fould at least one, so save it;004
	MOV	FQNAM1+2(R4),SILNAM+2 ;  as our default SIL to start.	;004
	CALL	@(SP)+		;See if this is the only one		;004
	SEC			;  No. there's more than one, set C-bit	;004
	BR	60$		;  and return to caller			;004

PRTSIL:	REGSCR			;SAVE THE REGISTERS
	CALL	30$		;Find the first SIL			;004
20$:	CALLX	TYPFIL		;AND TYPE OUT THE FILE NAME
	MESSAG	<<200>>		;PUT OUT A CARRIAGE RETURN, LINE FEED
	CALL	@(SP)+		;Now get the next SIL in [0,1]		;004
	BR	20$		;  and print it out			;004


30$:	MOV	#1,FQ...+FQPPN	;SET FIRQB -> [0,1]
	MOV	#FQ...+FQPPN,R0	;GET POINTER TO DIRECTORY [0,1]
	CALLX	RUF		;READ FIRST BLOCK OF [0,1]
	BCS	70$		;NO [0,1], DIRECTORY MESSED UP
	CLR	R3		;SET UP TO READ FIRST LINK (WHICH WON'T MATCH)
40$:	CALLX	RDB		;READ NEXT NAME ENTRY
	MOV	(R5),R3		;SAVE N.E. LINK
	CMP	UNAM+4(R5),#^RSIL ;SEE IF WE HAVE THE CORRECT EXTENSION
	BNE	50$		;NO, GO TO NEXT LINK
	BITB	#US.DEL!US.UFD,USTAT(R5);IS FILE MARKED FOR DELETE OR A UFD?
	BNE	50$		;YES, THEN GET THE NEXT FILE
	MOV	#FQ...+FQNAM1,R1;GET POINTER TO FCB NAME ENTRY
	ADD	#UNAM,R5	;MAKE R5 POINT TO NAME OF FILE
	MOV	(R5)+,(R1)+	;MOVE IN THE FILE NAME
	MOV	(R5)+,(R1)+	;PLUS THE SECOND HALF OF THE NAME
	MOV	(R5)+,(R1)+	;ALSO GET THE EXTENSION
	CALLX	LOK...		;OPEN UP THE FILE
	BCS	50$		;File not fould, must be currupt!	;004
	CALL	80$		;Read in SIL index and check the IDENT	;009
	BCS	50$		;Didn't match, try next SIL		;009
	MOV	#FQ...,R4	;GET A POINTER TO THE FIRQB
	CALL	@(SP)+		;Co-routine return to caller		;004
50$:	BIT	#^C<17>,R3	;REMOVE GARBAGE IN N.E POINTER
	BNE	40$		;THERE ARE STILL MORE FILES TO LOOK AT
	CLC			;Clear C-bit for FNDSIL exit		;004
60$:	INC	(SP)+		;Dump co-routine return (C uneffected)	;014
	RETURN			;  and return to caller's caller.	;004

70$:	ERF	<"Directory error - [0,1] not found"<200>>


;+
; 80$	- Read in SIL index and RSTS module, then verify IDENT
;-

80$:	REGSCR			;Save the world to play it safe		;009
	CALLX	SILNDX,R5,FQ...	;Read in the SIL index and check it	;009
	BNE	100$		;No good, can't use it then.		;009
	CALLX	SILSCN,R5	;Find the RSTS module			;009
	 .RAD50	/RSTS  /
	BCS	100$		;Not there.  Can't use it then.		;009

;+
; CHKIDE Verify IDENT against INIT - SIL index and RSTS module already read in
;+

$$0	= '0-^R  0		;Difference between ASCII "0" and RAD50 "0"
				; 100 (used below) is the difference between
				; ASCII "A" and RAD50 "A"

$$1	= <<<SYSVEL&377>-$$0>*3100>+<<<SYSVEL/400>-$$0>*50>+^R  .
	; First assume numeric						;036
$	= <$$$VER/400>-$$0						;036
$$	= <<$$$VER&377>-$$0>*50						;036
	; But, if either piece is alpha then correct it.		;036
.IIF	GT	<$$$VER/400>-100	$ = <$$$VER/400>-100		;036
.IIF	GT	<$$$VER&377>-100	$$ = <<$$VER&377>-100>*50	;036
	; Now, add all the pieces together				;036
$$2	= <<<SYSVEE/400>-$$0>*3100>+$$+$				;036

CHKIDE:	CMP	SE.IDN(R0),#$$1	;Does SIL version match INIT?		;009
	BNE	100$		;No, so we can't use it			;009
	CMP	SE.IDN+2(R0),#$$2 ; Maybe...
	BNE	100$		;No match.  We can't use it		;009
	TST	(PC)+		;Perfect match.  Return with C clear	;009
100$:	SEC			;Failure.  Return with C set		;009
..CKID	== .-2			;Change SEC to CLC to allow differences	;009
	RETURN			;Back to caller				;009

.DSABL	LSB


.SBTTL	CONVERT DEVICE NAME TO RAD50

;+
; DVASR5 - CONVERT DEVICE NAME FROM ASCII TO RAD50
;
;	XXNAME =  DEVICE NAME AS 2-CHARACTER ASCII
;
;	CALL	DVASR5
;
;	R1 = DEVICE NAME AS RAD50 / XX/ (I.E. RIGHT-JUSTIFIED)
;-

DVASR5:	MOV	XXNAME,-(SP)	;SAVE THE NAME
	MOVB	(SP),R1		;GET FIRST BYTE
	CLRB	(SP)		;CLEAN UP STACK WORD
	SWAB	(SP)		;(SP) IS 2ND BYTE
	MUL	#50,R1		;MAKE 1ST SHIFTED FOR RAD50
	ADD	(SP)+,R1
	SUB	#100*50+100,R1	;ADJUST FOR ASCII
	RETURN



.SBTTL	FIND A KEYBOARD INTERRUPT DESTINATION IN RSTS

;+
; XXKINT - FIND ??KINT IN RSTS STB
;
;	R1 = '??K' IN RAD50
;
;	CALL	XXKINT
;
;	XXDINT SET UP WITH VALUE OF '??KINT', OR ERROR PRINTED
;	R0 DESTROYED
;-

.ENABL	LSB

XXKINT:	MOV	R1,10$		;SAVE IT
	CALL	GETSR4,R4	;GET THE SYMBOL NAME
10$:	 .RAD50	/  KINT/
	BCC	20$		;GOT IT
	CALL	MISMES		;MESSAGE THAT IT IS MISSING
	MOV	R1,R0
	CALLX	RADZER
	MOV	#^RINT,R0
	CALLX	RADZER
	CALL	@(SP)+		;REST OF MESSAGE
20$:	MOV	R0,XXDINT	;SAVE INTERRUPT DESTINATION FOR INTERFACE
	RETURN

.DSABL	LSB

MISMES:	MESSAGE	<"  Required symbol '">
	CALL	@(SP)+		;GET THE FILL-IN
	MESSAGE	<"' missing from monitor"<200>>
	MOV	(PC),NOGOFG	;CAN'T FINISH THE INSTALL
	RETURN


.SBTTL	GET $$CS?? AND ??DINT VALUES FROM SYMBOL TABLE

;+
; CSRDCT - FETCH GLOBAL SYMBOLS FROM RSTS STB FOR CSR & VECTOR
;
;	XXNAME <- DEVICE NAME IN ASCII (E.G. XY)
;
;	CALL	CSRDCT
;
;	C=0	BOTH SYMBOLS FOUND
;		CSRXX HAS VALUE OF '$$CSXY'
;		XXDINT HAS VALUE OF 'XYDINT'
;	C=1	ONE OF THE SYMBOLS WAS NOT FOUND
;-

CSRDCT:	REGSCR			;SAVE ALL REGS
	CALL	DVASR5		;CONVERT TO RAD50
	MOV	R1,10$		;SET IT UP
	ADD	#^RS  ,10$	;AS S??
	CALL	GETSR4,R4	;GET SYMBOL VALUE
	 .RAD50	/$$C/
10$:	 .RAD50	/SXX/
	BCS	30$		;OOPS
	MOV	R0,CSRXX	;SAVE VALUE IN CSRXX
	MUL	#50,R1		;SHIFT NAME RAD50
	ADD	#^R  D,R1	;SET UP AS ??D
	MOV	R1,20$		;PUT IN NAME
	CALL	GETSR4,R4	;GET VALUE
20$:	 .RAD50	/XXDINT/
	BCS	30$		;NO GOOD
	MOV	R0,XXDINT	;SAVE VALUE
30$:	RETURN

	TMPORG	INSCTL
XXNAME:	.WORD	0,0		;DEVICE NAME (ASCIZ)
CSRXX:	.WORD	0
XXDINT:	.WORD	0
	UNORG


.SBTTL	SET/CLEAR 'DO NOT KILL' BIT IN DIRECTORY

.ENABL	LSB

NOKOFF:	TST	(PC)+		;CLEAR THE CARRY
NOKON:	SEC			;SET CARRY FOR NOKON
	MOV	(R3)+,-(SP)	;Push extension				;022
	CLR	-(SP)		;Open up a spot				;022
	MOV	(R4)+,-(SP)	;Push name part 1			;022
	MOV	(R4)+,2(SP)	; and part 2				;022
	MOV	#0*400+1,-(SP)	;  and PPN [0,1]			;022
	MOV	R3,10(SP)	;SAVE RETURN ADDRESS			;022
	ROR	R3		;SAVE ON/OFF INDICATOR IN R3 SIGN BIT
	TST	2(SP)		;IS THERE A NAME?			;022
	BEQ	40$		;NO, JUST RETURN
	REGSAV			;PRESERVE REGISTERS			;022
	MOV	R3,R4		;PUT SET/CLEAR FLAG IN SAFE PLACE
	MOV	SP,R0		;POINT TO PPN+NAME.EXT			;022
	ADD	#TOS.PC,R0	; at the appropriate offset from SP	;022
	CALLX	SDU		;SEARCH DIRECTORY FOR FILE
	BCS	20$		;ERROR, PRINT MESSAGE
	BICB	#US.NOK,USTAT(R5) ;CLEAR THE NO-KILL BIT
	TST	R4		;ON OR OFF?
	BPL	10$		;OFF, LEAVE IT
	BISB	#US.NOK,USTAT(R5) ;ON, TURN IT ON
10$:	CALLX	WRITE		;REWRITE THE DIRECTORY BLOCK		;022
	BR	30$		; and exit				;022

20$:	TST	R4		;TURNING ON OR OFF?
	BMI	40$		;OFF, TELL HIM THE NEW SIL IS ICKY
	MESSAG	<"  Warning - file ">
	MOV	SP,R5		;POINT TO NAME.EXT			;022
	ADD	#TOS.PC+2,R5						;022
	MOV	(R5)+,R0	;PRINT NAME
	CALLX	RADZER
	MOV	(R5)+,R0
	CALLX	RADZER
	MESSAG	<".">
	MOV	(R5)+,R0
	CALLX	RADZER
	MESSAG	<" not found when removing old SIL"<200>>
30$:	REGRES			;Restore registers			;022
	ADD	#10,SP		;Pop PPN/Filename			;022
	RETURN


40$:	MESSAG	<"  Warning - ">
	MOV	TOS.PC+6(SP),R0	;PRINT A WARNING			;022
	CALLX	RADZER		;FILE TYPE
	MESSAG	<" file not found - please set defaults"<200>>
	MOV	TOS.R4(SP),R4	;GET POINTER IN DEFBUF TO NAME
	CLR	-(R4)		;CLEAR IT OUT
	CLR	-(R4)
	CALLX	DEFALO		;REWRITE DEFAULTS			;022
	BR	30$		; and exit				;022

.DSABL	LSB


.SBTTL	GLOBAL SYMBOLS TO FIND IN STB

;+
; Table of global symbols to find in STB.
;
; DESCRIPTION OF SOURCE:
;
;	There are two tables that list the global symbols to look up 
;	in the SIL.  INSSYM is defined here, and DEFBFP (permanent 
;	part of DEFBUF) is defined in ROOT.MAC.  These two tables must 
;	contain the same entries in the same order.  Otherwise the message 
;
;		"INIT bug - INSTALL not synchronized at <symbolname>"
;
;	appears when you try to install the SIL.
;
;	Each entry of the following table has this format:
;
; 		$	R50NAM,MONNAM,LCLNAM
;
; 	R50NAM =	1- to 6-character name of global symbol to 
;			look up in SIL.  
;		Omitted--??
;	MONNAM =	name of entry in DEFBFP that holds value of this 
;			symbol.
;		Omitted--there is no corresponding entry in DEFBFP.
;	LCLNAM =	Name for entry of INSSYN that holds 
;			the value of this symbol. ??
;		Omitted--don't name the entry of INSSYN.
;
;	Entries beyond INSLCL do not have corresponding entries
;		in DEFBFP.
;	INSSYE is address of end of table.
;
; DESCRIPTION OF BINARY:
;
;	There are three parallel tables.  
;
;	DEFBFP--permanent part of DEFBUF.  Each entry contains the value
;		of a global symbol in the SIL.  (DEFBFP is apparently updated
;		from INSSYM at the end of the INSTALL.)
;	INSSYN--Names of symbols to look up.  Each entry is two words
;		of RAD50.
;	INSSYM--Each entry is:
;		- Value of symbol.  One word.
;		- Pointer to corresponding entry of DEFBFP.  One word. 
;		  Low-order bit of this word is set if symbol has not been
;		  found.
;-


.MACRO	$	R50NAM,MONNAM,LCLNAM
	TMPORG	INSSYN
	.IF	NB <R50NAM>
	 .RAD50	/R50NAM/
	 .NCHR	$$$,R50NAM
	 .IF	LE	<$$$ - 3>
	 .WORD	0
	 .ENDC
	.IFF
	 .WORD	0,0
	.ENDC
	UNORG
.IF	B	LCLNAM
	 .WORD	0,MONNAM
.GLOBL	MONNAM
.IFF
LCLNAM:
.IF	B	MONNAM
	 .WORD	0,XXXJNK
.IFF
	 .WORD	0,MONNAM
.GLOBL	MONNAM
.ENDC
.ENDC
.ENDM	$

INSSYM:
$	$$2780,.$2780,..2780
$	$$VSWR,.$VSWR
$	$$UMRT,.$UMRT
$	$$UMRP,.$UMRP
$	$$GUMR,.$GUMR
$	$$RUMR,.$RUMR
$	$$UMRS,.$UMRS
$	$$UMRE,.$UMRE
$	$$UMRI,.$UMRI
$	$$UMRJ,.$UMRJ
$	$$UPES,.$UPES
$	$$UPEE,.$UPEE
$	$$UPEI,.$UPEI
$	$$UPEJ,.$UPEJ
$	$$TMUN,.$TMUN
$	$$UMTM,.$UMTM							;010
$	$$TIME,.$TIME
$	$$TICK,.$TICK
$	$$SYSU,.$SYSU
$	$$SYSP,.$SYSP
$	$$SWPM,.$SWPM
$	$$SWPB,.$SWPB
$	$$SWMP,.$SWMP
$	$$STAK,.$STAK
$	$$SROM,.$SROM
$	$$SREG,.$SREG
$	$$SL  ,.$SL
$	$$SFPP,.$SFPP
$	$$RTSP,.$RTSP
$	$$RFPP,.$RFPP
$	$$PZER,.$PZER
;$	$$PWRP,.$PWRP		;Historical				;001
$	$$PTBL,.$PTBL
$	$$PRNG,.$PRNG
$	$$PNEW,.$PNEW
$	$$PCSR,.$PCSR
$	$$PSCN,.$PSCN
$	$$PMSK,.$PMSK
$	$$OVRC,.$OVRC
$	$$OVRB,.$OVRB
$	$$OV2B,.$OV2B							;032
$	$$LODB,.$LODB
$	$$OVBF,.$OVBF
$	$$ODT6,.$ODT6
$	ENTODT,.$ODTP							;026
$	$$ODTE,.$ODTE
$	$$ODTB,.$ODTB
$	$$NULW,.$NULW
$	$$NDAY,.$NDAY
;$	$$MTLB,.$MTLB		;Historical				;001
$	$$MOVW,.$MOVW
$	$$MOVB,.$MOVB
$	$$MEMT,.$MEMT
$	$$MEML,.$MEML
$	$$MEDS,.$MEDS
$	$$MEDE,.$MEDE
$	$$MEDI,.$MEDI
$	$$MEDJ,.$MEDJ
$	$$MBFS,.$MBFS
$	$$MBFE,.$MBFE
$	$$YBFS,.$YBFS
$	$$YBFE,.$YBFE
$	$$M22W,.$M22W
$	$$LRGP,.$LRGP
$	$$LDAY,.$LDAY
$	$$JOBM,.$JOBM
$	$$IBOT,.$IBOT,..IBOT
$	$$ISPS,.$ISPS,..ISPS
$	$$ISPE,.$ISPE,..ISPE
$	$$ITOP,.$ITOP,..ITOP
$	$$HZDV,.$HZDV
$	$$FR25,.$FR25
$	$$FR20,.$FR20
$	$$FR00,.$FR00
$	$$FPPS,.$FPPS
$	$$FPPE,.$FPPE
$	$$FPPI,.$FPPI
$	$$FPPJ,.$FPPJ
$	$$FIS ,.$FIS
$	$$EXTP,.$EXTP
$	$$EXTO,.$EXTO
$	$$ESID,.$ESID
$	$$ERSZ,.$ERSZ
$	$$ERRB,.$ERRB
$	$$EPMM,.$EPMM
$	$$EMED,.$EMED
$	$$ECPU,.$ECPU
$	$$DSPA,.$DSPA
$	$$DSIZ,.$DSIZ
$	$$DREG,.$DREG
$	$$DMID,.$DMID
$	$$DDCS,.$DDCS
$	$$DATE,.$DATE
$	$$CSRT,.$CSRT
$	$$CRSZ,.$CRSZ
$	$$CQNT,.$CQNT
$	$$CPRM,.$CPRM
$	$$CNVF,.$CNVF
$	      ,.$CHSZ,..CHSZ
$	$$CHEN,.$CHEN
$	$$CCTL,.$CCTL
$	$$CCSR,.$CCSR
$	$$CCNT,.$CCNT
$	$$CNOP,.$CNOP
$	      ,.$CBSZ,..CBSZ
$	      ,.$CACH,..CACH
$	$$BUFS,.$BUFS
$	$$BUFE,.$BUFE
$	$$BUFB,.$BUFB
$	$$BFRT,.$BFRT
$	$$BAEL,.$BAEL
$	SATBUF,.SATBU
$	FIBUF ,.FIBUF
$	UNTCNT,.UNTCN
$	      ,SYSVEN,.SYSVEN
$	JOBMAX,JOBMAX
$	DEVSYN,DEVSYN,.DEVSYN
$	DEVPTR,DEVPTR,.DEVPTR
$	DEVOKB,DEVOKB,.DEVOKB
$	DEVNAM,DEVNAM,.DEVNAM
$	DEVCNT,DEVCNT,.DEVCNT
$	      ,CNT.DT,.CNT.DT
$	      ,XDDDDB,.XDDDDB
$	      ,DDS.XD,.DDS.XD
$	      ,XMDDDB,.XMDDDB
$	      ,DDS.XM,.XM.DDS
$	      ,SOFTKG,.SOFTKG
$	$$XTAB,.$XTAB
$	$$XSCS,.$XSCS
$	$$XCON,.$XCON
$	$$XMOS,.$XMOS
$	$$XDCN,.$XDCN
$	CNT.DU,CNT.DU
$	CMT   ,.CMT
$	UMT$DU,.UMTDU
$	CNT.MU,CNT.MU							;010
$	TERAP6,TERAP6							;026
$	CRAAP5,CRAAP5							;012
$	FIPAP6,FIPAP6							;012
$	JCRSIZ,JCRSIZ							;014
$	$$JCR6,.$JCR6							;014
$	$$JCFX,.$JCFX							;014
$	SESAP5,SESAP5							;015
$	NSPAP5,NSPAP5							;015
$	TRNAP5,TRNAP5							;015
$	NODAP5,NODAP5							;030
$	XEDAP5,XEDAP5							;016
$	XHDAP5,XHDAP5							;016
$	$$NETI,.$NETI							;015
$	$$NETJ,.$NETJ							;015
$	$$NETS,.$NETS							;015
$	$$NETE,.$NETE							;015
$	$$NETT,.$NETT							;015
$	$$NETW,.$NETW							;015
$	$$CCCR,.$CCCR							;015
$	UMR$XE,UMR$XE							;016
$	XEDDDB,XEDDDB							;016
$	XECORE,XECORE							;016
$	XHDDDB,XHDDDB							;016
$	XHDATA,XHDATA							;016
$	DDS.XE,DDS.XE							;017
$	DDS.XH,DDS.XH							;017
$	NODDDB,NODDDB							;035
$	DDS.NO,DDS.NO							;035
$	EVLAP5,EVLAP5							;018
$	RDMAP5,RDMAP5							;019
$	FAKDDB,FAKDDB							;020
$	SYSTIC,SYSTIC							;021
$	NULJOB,NULJOB							;021
$	$$CLK2,.$CLK2							;023
$	GPKAP5,GPKAP5							;024
$	PTBAP6,PTBAP6							;024
$	,.CSR.LK,.CSRLK							;024
$	,.VEC.LK,.VECLK							;024
$	CSR.KB,CSR.KB							;026
$	DEV.KB,DEV.KB							;026
$	UCT.KB,UCT.KB							;026
$	DHPAP5,DHPAP5							;026
$	DJPAP5,DJPAP5							;026
$	DZPAP5,DZPAP5							;026
$	VHPAP5,VHPAP5							;026
$	$DHKIN,DHKINT							;026
$	$DJKIN,DJKINT							;026
$	$DLKIN,DLKINT							;026
$	$DMKIN,DMKINT							;026
$	$DZKIN,DZKINT							;026
$	$VHKIN,VHKINT							;026
$	DJKBN,DJKBN							;026
$	DHKBN,DHKBN							;026
$	DZKBN,DZKBN							;026
$	VHKBN,VHKBN							;026
$	FMSAP5,FMSAP5							;026
$	TTFMSB,TTFMSB							;026
$	CSR.BB,CSR.BB							;026
$	KBDDBX,KBDDBX							;026
$	LATAP5,LATAP5							;027
$	TTAUXB,TTAUXB							;030
$	$$LATS,.$LATS							;031
$	$$LATE,.$LATE							;031
$	DYNKBN,DYNKBN							;031
$	APTAP5,APTAP5							;033
INSLCL:
$	$$LOWE,      ,.$LOWE
$	$$LOWS,      ,.$LOWS
$	$$LOWC,      ,.$LOWC
INSSYE:

XXXJNK:	.WORD	0		;GARBAGE PILE FOR NON-GLOBAL VALUES

ENDOVL	<INS,INSTXT,INSCTL,INSSYN>,100

.END
