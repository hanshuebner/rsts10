.INCLUDE /CMN:COMMON/							;057
.INCLUDE /CMN:KERNEL/							;057
.INCLUDE /INIT:INIPFX/							;057
.INCLUDE /INIT:DSKDEF/							;057
.INCLUDE /INIT:TAPDEF/							;057
TITLE	INIONE,<INIT ONE-SHOT CODE>,0J,27-MAR-92,GPK/FEK/MND/TPT/DBM/VAM/FRL/KPH

;
;		COPYRIGHT (c) 1974, 1987 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;
.SBTTL  EDIT HISTORY FOR INIONE                                            ;050

;+
;
;  000	GPK  21-Jun-82	Creation
;  001	MND  21-Oct-82	Correct DCS calculation for UDA disks in RULOOK
;  002	GPK  28-Oct-82	Update RP04/5/6 device sizes
;  003	GPK  06-Dec-82	Add streamline startup for TAP
;  004	FEK  13-JAN-83	Correct updated RP04/5/6 sizes
;  005	MND  26-JAN-83	Bug fixes to RULOOK
;  006	MND  26-JAN-83	Bug fixes to RULOOK/XNPOKE
;  007	MND  25-MAY-83  SOURCE CORRECT PATCH SEQ 1.1.8	
;  008	WJS  28-Sep-83	Globalize mapping symbols
;  009  MND  10-Nov-83  Psychological re-evaluation of changes made so far
;  010  TPT  11-Nov-83  Merged V8.0-07 changes
;  011	FEK  02-JAN-84	ADD DEUNA SUPPORT
;  012	DBM  13-Feb-84	Add TSLOOK routine to TSPOKE
;  013	MND  05-Mar-84	Auto-size DV0: by moving D.VDSK into CSRTBL
;  014	MND  10-May-84  Set switch when booted from Read-only device
;  015	DBM  10-Jun-84	Get extended features bit for TK25's and TS05's (TSPOKE)
;			And fix a bug with the message packet alignment
;  016	DBM  27-Jul-84	Modify DUIO to use controller specified timeout value
;  017	DBM  08-Aug-84	Source clear INIT patch from BL7+
;  018	DBM  30-Oct-84	Fix RULOOK once and for all!
;  019	MND  21-Jan-85	Fix DV DSKCSR table bug
;  020  VAM  21-Feb-85	Fix header line for double-digit unit numbers (0-15).
;  021	FEK  26-Feb-85	ADD 4-8-16 SUBLINE SORTOUT CODE FOR DZ/VH
;  022	DBM  02-Apr-85	Clear reserved fields in MSCP command packets
;  023	MND  05-Apr-85	Allow user settable vectors, for MSDCP controllers
;
;			[RSTS V9.1]
;  024	DBM  03-Oct-84	Add TMSCP capability to RUPOKE/RULOOK
;  025	DBM  11-May-85	Source clear 1.1.1
;  026	DBM  19-May-85	Make [T]MSCP timeout value 10.00001 to 10.99999 seconds
;  027	TPT  18-Jun-85	Always 4 TMSCP units for now...
;  028  VAM  02-Jul-85	Remove TU58 support
;  029  VAM  06-Aug-85	Fix secondary controller MSCP boot (ala DBM)
;  030  VAM  19-Aug-85	Add RQDX3 support.
;  031  VAM  21-Aug-85	Increase timeout value for [T]MSCP controllers.
;  032  VAM  26-Aug-85	Add check for 11/73/83/84 FPA.
;  033  VAM  11-Sep-85	Modify 11/73/83/84 FPA check.
;			Also, clear KMC11 after causing interrupt (in XKPOKE).
;  034  VAM  12-Sep-85	Yet another modification for FPA check.
;  035  VAM  13-Sep-85	Put TU58 stuff back.
;  036  MND  13-Sep-85	Fix ;019
;  037  VAM  17-Sep-85	Good Grief!!  Bug fixes for FPA check.
;  040	FEK  25-Oct-85	Save some DMC/DMR information
;
;			[RSTS V9.3]
;  038	DBM  17-Jan-86	Preliminary ethernet support
;  039	DBM  24-Mar-86	Finish ethernet work, other bug fixes
;  041	FEK  12-Mar-86	RP02/3 looking and make FPA check use T bit
;			trap instead of clock.
;  042	DBM  08-May-86	Bug fix in XELOOK, TK50 ECO check
;  043  FRL  28-May-86	Micro/RSTS messages for TK50 ECO
;  044  DBM  06-Aug-86	Properly re-establish the SETDEN routine
;			QNA ROM check (Rev E boards)
;			TK50/J11A check.
;  045	DBM  28-Oct-86	Non-standard MS/MU booted devices
;			UQLOOK fixes/enhancements
;
;			[RSTS V9.4]
;  046	FEK  29-Dec-86	Save the DMR modem type information, MM for sysgen
;			and some more FPJ checks
;  047	FEK  03-Feb-87	Add the BSPOKE entry point
;  048  VAM  26-Jan-87	Better message for UQPORT initialization failures.
;  049	PJH  15-Feb-87	Add GPK merged code
;  			Fixes for GPK system and others
;  			Support for multiple DW units
;  			"digital" logo stuff for GPK
;  050	WRM  05-Mar-87  DHV/DHU micro diagnostic checks
;  051	FEK  26-Mar-87	More FPJ FCO text added.
;  052  VAM  02-Apr-87	Add Step 4 controller lookup table to UQLOOK.
;  053  VAM  22-Apr-87	More improvements to UQLOOK.
;  054	PJH  04-May-87	Fix GPK bug in CHKCSR
;  055  VAM  15-May-87	Clarify error message in UQUNIT.
;  056  VAM  08-Jun-87	Move INITOK message from here to ROOT.
;			Bugfix in CHKCSR in DN11 check.
;
;			[RSTS V9.5]
;  057  VAM  12-Aug-87	Don't allow startup if we don't know about booted CSR.
;  058  DSD  17-Aug-87	Make QNA/LQA diags run when device is up to rev.
;  059	PJH  18-Aug-87	Make FCO EQ-01440-02 msg only print for KDJ11-B
;
;			[RSTS V9.6]
;  060  KPH  13-Oct-87	Add .INCLUDEs
;			Change sense of TYPTBL for small DZ/VH controllers
;  061  VAM  02-Nov-87	Change B.UNIT reference from word to byte.
;  062	FEK  10-Nov-87	Add KXJ11 poking code
;  063  FEK  20-Apr-88	Add code to recongize UTA (Unibus Trace Analyzer)
;  064	KCG  03-Jun-88	Add new TQK50 FCO warning
;
;			[RSTS V9.7]
;  065  VAM  04-Nov-88	Make RRD50 and RV20/RV60 real in UQDEF tables.
;  066  VAM  26-Jan-89	Remove INIT support for virtual disk.
;  067  VAM  20-May-89	Add poke code for DR11/DRV11.
;
;			[RSTS V10.0]
;  068	FEK  13-Jul-89	Add KFQSA in UQDEF and fix some bugs
;
;			[RSTS V10.1]
;  069	FEK  16-Apr-91	Add more MSCP disks, XV, and fix XA
;  070  VAM  04-Jun-91	Fix bug in UQSCC/UQUNIT for controllers that
;			handle both disks and tapes (for RQZX1).
;  071	FEK  16-Sep-91	Allow [T]MSCP controllers to have correct # of units
;			and add more MSCP device names
;-


AC0	=%0			; Our definitions for FPU accumulators.	;032
AC1	=%1
AC2	=%2								;046
AC3	=%3								;046

.SBTTL Macros

; Macro to set up text strings

.MACRO	I.MESS
	TMPORG	ONETXT
	.NLIST	BEX
.ENDM	I.MESS


; MACRO TO SET UP FLOATER TABLE

.MACRO	FLOAT	NM,SIZ,OPT
	 .WORD	SIZ		;SIZE OF NM CSR SET
.IF IDN <OPT>,<NS>
	 .WORD	-1.		;  *** NM IS NOT SUPPORTED BY ***
.IFF
  .IF IDN <OPT>,<1FIX>
	 .WORD	NM'.CS2		;  OFFSET INTO CSRTBL+2 (1ST CSR IS FIXED)
	GLOBAL	<NM'.CS2>
  .IFF
	 .WORD	NM'.CSO		;  OFFSET INTO CSRTBL
	GLOBAL	<NM'.CSO>
  .ENDC
.ENDC
.IF IDN <OPT>,<NS>
	 .WORD	0		;  ***       RSTS V9.0        ***
.IFF
	 .WORD	NM'.PKT		;  POINTER TO NM PACKET
	GLOBAL	<NM'.PKT>
.ENDC
.ENDM	FLOAT

.SBTTL	Order the PSECTs

DEFORG	ONE
DEFORG	ONECTL
DEFORG	ONETBL
DEFORG	ONETXT
ORG	ONE

.SBTTL	FLOATING ADDRESS TABLE

				;(NS=	NO SUPPORT)
				;(2780= SUPPORTED BY OPTIONAL SOFTWARE ONLY)
				;(NET=	Supported by DECnet/E only)

FLTBA:	FLOAT	DJ,10		;DJ11 16 LINE MUX
	FLOAT	DH,20		;DH11 16 LINE PGM MUX
	FLOAT	DQ,10,NS	;DQ11 SYNC INTERPROCESSOR LINK        *  NS  *
	FLOAT	DU,10		;DU11 SINGLE LINE SYNC INTERFACE      * 2780 *
	FLOAT	D1,10		;DUP11 SINGLE LINE SYNC PGM INTERFACE * 2780 *
	FLOAT	LK,10,NS	;LK11 PGM KEYPAD                      *  NS  *
	FLOAT	XM,10		;DMC11 INTERPROCESSOR LINK
	FLOAT	DZ,10		;DZ11 8 LINE PGM MUX
	FLOAT	XK,10		;KMC11 OUTBOARD MICROPROCESSOR        * 2780 *
	FLOAT	..,10,NS	;LPP11 ?                              *  NS  *
	FLOAT	..,10,NS	;VMV21 VTV01 CHARACTER GENERATOR      *  NS  *
	FLOAT	..,20,NS	;VMV31 VTV01 RAINBOW BITMAP           *  NS  *
	FLOAT	DW,10,NS	;DWR70 RH70 INTERPROCESSOR LINK       *  NS  *
	FLOAT	..,10,NS	;EXTRA RL/RLV11'S RESERVED            *  NS  *
	FLOAT	LA,20,NS	;EXTRA LPA11 DMA PROCESSOR RESERVED   *  NS  *
	FLOAT	KC,10,NS	;KW11-C BATTERY BACKUP CLOCK          *  NS  *
	FLOAT	..,10,NS	;RESERVED (NO ASSIGNMENT)             *  NS  *
	FLOAT	RX,10,1FIX	;EXTRA RX11'S
	FLOAT	XA,10,1FIX	;DR11-W DMA CONTROLLLER               *  NS  *
	FLOAT	..,10,NS	;DR11-B DMA CONTROLLLER               *  NS  *
	FLOAT	XD,10		;DMP11 MULTIDROP INTERPROCESSOR LINK  *  NET *
	FLOAT	XV,10		;DPV11 				      *  NS  *
	FLOAT	..,10,NS	;ISB11 				      *  NS  *
	FLOAT	X3,20,NS	;DMV11 MULTIDROP INTERPROCESSOR LINK  *  NET *
				;The "NS" here is a kludge to keep FLOAT
				;from filling in the packet pointer.
				;It will be filled in later if appropriate.
X3.PKT	=	.-2		;DMV11 USES SAME POKE RTN AS DMP11 
X3.OFF	=	.-4		; we'll fill in the CSR offset also
				;INITIALIZED BY "FNDFLT" RTN
	FLOAT	XE,10,1FIX	;UNA				      *  NET * ;011
	FLOAT	RU,04,1FIX	;UDA
	FLOAT	..,40,NS	;DMF32				      *  NS  * ;010
	FLOAT   ..,20,NS	;KMS11				      *  NS  * ;010
	FLOAT   ..,20,NS	;VS100				      *  NS  * ;010
	FLOAT	MU,04,1FIX	;TMSCP
	FLOAT	..,20,NS	;KMV11				      *  NS  * ;010
	FLOAT	VH,20		;DHV11/DHU11 8/16 LINE MULTIPLEXER  		;010
	.WORD	0,0,0		;FILLER FOR "FNDFLT"
	.WORD	0,0,0		;FILLER FOR "FNDFLT"

	UNORG

.SBTTL	SORT OUT DEVICES

.ENABL	LSB

INIONE::NOP			;PATCHABLE BPT FOR ODT			;010
	CALL	FULSIZ		;See if we can perform full autosize.	;061
	CALL	CHKFPA		;See if CPU/FPA are working correctly	;031
	CALL	CHKCSR		;CHECK OUT CSR'S, BUILD CSRTBL
	TSTB	FLGGPK		;Is this a GPK?				;049
	BPL	5$		;No, skip GPK setup			;049
	CALL	SETGPK		;Do GPK-specific setup			;049
5$:	CALL	DEVSRT		;SORT OUT DL11E'S FROM C/D, CR11'S FROM CD11'S
	CALL	FNDFLT		;FIND FLOATING DEVICES
	CALL	APPSET		;APPLY USER'S SET OPTIONS
	CALL	VECCKA		;CHECK OUT VECTORS
	CALL	PGMVEC		;ASSIGN VECTORS TO THE PROGRAMMABLE DEVICES
	CALL	CHKBAE		;CHECK FOR RH70'S
	MOV	#DSKCSR-2,R2	;POINT TO DISK CSR TABLE-2
				;1 word/disk, 2 MU, 8 MS, 1 MT, 1 MM, 1 DTA ;024
	CALLX	DEVLUP		;LOOP THROUGH THE CSR'S
;	MOV	(R4),I.TKS	;RESET I.TKS FOR HUMOR
	CLR	FLGCSR		;PRESET A FLAG FOR "UNKNOWN CSR" BOOTED 
30$:	CALL	@(SP)+		;NEXT DEVICE'S CONTROLLER
	CMP	R5,#TAPEND+PKTSIZ ;Done with all bootable devices?	;024
	BHIS	90$		;  YES. DSKCSR LOADED.
	CMP	R5,#DSKEND	;  NO,  DONE WITH DISKS?
	BHIS	40$		;    YES, BUMP TABLE POINTER.
				;    (MULTI-CNTRL TAPE CSR'S STORED IN DSKCSR)
	TST	DEV.UN		;    NO.  DOING FIRST CONTROLLR FOR THIS DISK?
	BNE	50$		;      NO, DON'T BUMP TABLE ADDRESS
40$:	TST	(R2)+		;      YES, NEXT CSR TABLE ENTRY

GLOBAL	<DSKCSR,TAPEND,DSKEND,DEV.UN>
GLOBAL	<FLGGPK>							;049

.SBTTL	Identify booted controller

;+
;	Check for booted controller and change boot name accordingly.
;	Also set flag to indicate BOOTed CSR is known to INIT.
;-

50$:	CLR	-(SP)		;CLEAR A WORD
	MOVB	PK.OFF(R5),(SP)	;  TO COMPUTE THE CSR
	ADD	(R4),(SP)	;    AS IT'S REPRESENTED IN THE BOOTSTRAP
	CMP	(SP)+,@#B.CSR	;WAS THIS WHAT WE BOOTED FROM?
	BNE	60$		;NO -- SKIP
	MOV	(R4),FLGCSR	;YES, BOOTED DEVICE OK FOR INIT
	CMPB	@#B.NAME,#'D	;BOOTED FROM DISK?
	BNE	60$		;NO, NO NAME CHANGE
	MOVB	PK.NAM+1(R5),@#B.NAME+1 ;YES -- SET ITS NAME
60$:	MOV	R2,R3		;COPY ADDRESS TO LOAD CSR
	CMP	PK.NAM(R5),#"RV	;Is this the virtual disk?		;019
	BEQ	70$		;  Yes, it could have an odd CSR address.
	BIT	(R3),#1		;IS THIS A MULTI-CONTROLLER DISK?
	BEQ	70$		;NO. SO LOAD 1 CSR FOR THIS DISK TYPE.
	MOV	(R3),R3		;       YES, GET TABLE ADDR FOR THIS DISK
	DEC	R3		;	CLEAR THE MULTI-CNTRL FLAG
	MOV	DEV.UN,-(SP)	;	GET THE CONTROLLER NUMBER (0 REL)
	ASL	(SP)		;	*2 TO INDEX INTO THE MULTI-CNTRL TABLE
	ADD	(SP)+,R3	;	SO WE CAN LOAD THAT TABLE INSTEAD.
70$:	MOV	(R4),(R3)	;SET UP A CSR
	BEQ	80$		;IF THERE IS ONE
	MOVB	PK.OFF(R5),R0	;GET OFFSET OF MAJOR REG (SXTED)
	ADD	R0,(R3)		;POINT TO MOST COMMON
80$:	BR	30$		;CHECK FOR MORE BOOTABLE DEVICES

90$:	TST	(SP)+		;DUMP DEVLUP RETURN
	MOV	@#B.NAME,R0	;GET BOOTED DEVICE NAME FROM BOOTSTRAP
	MOV	#BOONAM,R1	;POINT TO TABLE OF BOOTABLE DEVICES
100$:	CMP	R0,(R1)+	;BE THIS IT?
	BEQ	110$		;YUP
	TST	(R1)		;NO, ANY MORE?
	BNE	100$		;GO IF MORE
	ERF	<"Fatal - Unknown device booted!"<200>>

	TMPORG	ONECTL
FLGCSR:	.WORD	0		;FLAG FOR "KNOWN/UNKNOWN" CSR STATUS
	UNORG

GLOBAL	<DEV.UN,BOONAM>

.SBTTL	Set up disk and tape related tables

110$:	SUB	#DSKNAM+2,R1	;GET INDEX, >= 0 IF DISK
	MOV	R1,SYNXSV	;SAVE IT AS SAVED SYSTEM INDEX
	MOV	R1,SYSNDX	;(BOTH PLACES)
	MOV	R0,SYSNAM	;SAVE SYSTEM DEVICE NAME
	MOVB	@#B.UNIT,SYSUSV	;Remember system unit number...		;061
	MOV	SYSUSV,SYSUNT	; (both places).
	TST	FLGCSR		;DOES INIT KNOW ABOUT THIS BOOTED CSR?
	BNE	160$		;YES, WE'RE OK
	MESSAG
	 .ASCIZ	<200>"Warning - Booted device is at a non-standard CSR address."<200> ;057
	UNORG								;057
	CALLX	VBCHK		;Ever used INSTAL or HARDWR?		;068
	BCS	105$		;Nope, so we don't need to tell them	;068
	MESSAG								;057
	 .ASCII	"You must use the CSR suboption of the HARDWR option to"<200>	;057
	 .ASCIZ	"set the CSR address before timesharing can be started."<200>	;057
	UNORG								;057
105$:	MOV	SP,NOSTAR	;Don't let them start it up.		;057
	MOV	#DSKCSR,R0	;GET A POINTER TO THE DISK CSR TABLE
	TST	R1		;BOOTED FROM DISK?
	BPL	120$		;YES R0 -> CORRECT CSR TABLE
	MOV	#MAGCSR,R0	;NO, GET THE POINTER TO THE MAGTAPE CSR TABLE
	CMP	R1,#IDX$MS	;Booted from MS drive?			;045
	BEQ	107$		;Yep.					;045
	BHI	120$		;Nope.  MM or MT drive			;045
.ASSUME	IDX$MM GT IDX$MS
.ASSUME	IDX$MT GT IDX$MS
	MOV	#CSRMU,R0	;Must be an MU drive			;045
	MOV	#MU.PKT-DEVTBL,R1 ;Set up to join code			;045
	BR	122$		;Go to it				;045

107$:	MOV	#CSRMS,R0	;MS					;045
	MOV	#TS.PKT-DEVTBL,R1 ;Set up to join code			;045
	BR	122$		;Go to it				;045

120$:	ADD	R1,R0		;Point to this device's CSR entry	;045
	BIT	#1,(R0)+	;Multi-controller disk device?		;045
	BEQ	150$		;  NO,  SET THE BOOTED CSR INTO CSR TABLE.
	MOV	-(R0),R0	;  YES, GET THE MULTI-CNTRL TABLE ADDRESS
	DEC	R0		;    AND STRIP OFF THE MULTI-CNTRLR FLAG.
	TST	(R1)+		;GET INDEX INTO PACKETS BY ADDING 2 (TT.PKT)
	ASR	R1		;  SHIFT TO PACKET NUMBER (RELATIVE TO ZERO)
	MUL	#PKTSIZ,R1	;    AND MULTIPLY BY PACKET SIZE IN BYTES.
122$:	MOVB	DEVTBL(R1),R2	;Get max number of controllers supported;045
.ASSUME PK.MXU EQ 0							;045
	MOV	R2,R3		;Make a copy				;045
	ASL	R2		;Make this copy * 2			;045
130$:	TST	(R0)+		;DOES HE ALREADY HAVE ANOTHER CONTROLLER HERE?
	BEQ	140$		;  NO, PUT HIS BOOTED DEVICE CSR HERE
	SOB	R3,130$		;  Yes, don't disable it, try another	;045
	INC	R3		;If too many, wipe out the last one.	;029
140$:	ADD	DEVTBL+PK.CSO(R1),R2	;Get pointer to last slot.	;045
	ASL	R3		;Make this a word offset.		;029
	SUB	R3,R2		;Fudge it to point into CSRTBL.		;029
	MOV	@#B.CSR,CSRTBL(R2)	;Now, move the booted CSR in.	;045
150$:	MOV	@#B.CSR,-(R0)	;INIT will now talk to the booted device;045
160$:	TSTB	FLGGPK		;Are we on a GPK?			;049
	BMI	175$		;Yes, skip lots of non-GPK device stuff	;049
	CALL	SETDEN		;SET THE SYSTEM TAPE DENSITY IF SYNXSV IS TAPE ;038
	CALL	RFLOOK		;SET UP RF DISK SIZE
	CALL	RSLOOK		;SET UP RS03/RS04	TABLES IF ANY
	CALL	RKLOOK		;SET UP RK05/RK05F	TABLE
	CALL	RLLOOK		;SET UP RL01/RL02	TABLES IF ANY
	CALL	RMLOOK		;SET UP RK06/RK07	TABLE
	CALL	RPLOOK		;SET UP RP02/RP03	TABLES IF ANY
	CALL	RBLOOK		;SET UP RP04/RP05/RP06	TABLES IF ANY
	CALL	RRLOOK		;SET UP RM02/RM03/RP07	TABLES IF ANY
	CALL	UQLOOK		;SET UP [T]MSCP		TABLES IF ANY	;024
	CALL	MMLOOK		;SET UP FORMATTER TABLES FOR TAPES IF ANY
	CALLX	XMLOOK		;CHECK OUT THE DMC/DMR TYPES & ECO LEVELS ;046
	CALLX	XDLOOK		;CHECK OUT THE DMP/DMV SWITCH SETTINGS	;046
	CALL	NALOOK		;Ethernet integrity/Get Network Address	;039
	BR	180$		;skip GPK disk stuff			;049

175$:	CALL	DZLOOK		;Set up floppy stuff			;049
	CALL	DWLOOK		;Size up the hard disk			;049
	.BR	180$		; and continue				;049

GLOBAL	<DSKNAM,SYNXSV,SYSNDX,SYSNAM,SYSUSV,SYSUNT,DSKCSR,MAGCSR,DEVTBL>
GLOBAL	<PK.CSO,DEVTBL,B.CSR,CSRTBL>					;029
GLOBAL	<CSRMU,CSRMS,TS.PKT,MU.PKT>					;045

.SBTTL	CONSISTENCY CHECK SYSTEM DISK STRUCTURE, INSTALLED SIL

180$:	RESETB			;Reset things (SP, among others)
	MOVB	#-1.,GOSWIT	;ONE-SHOT BOOT COMPLETE, WE CAN NOW GO.
	CALLX	SETFIP		;SET UP THE SYSTEM DISK AGAIN.
	COMB	RODISK		;Assume a read-only device		;014
	TST	SYSNDX		;Magtape?				;014
	BMI	210$		;Yes, read-only				;014
	CALLX	READPL		;Get the Packlabel			;014
	MOV	FIBUF+PLVL,DSKREV ;Save the rev level of the disk	;021
	BIT	#UC.RO,FIBUF+PSTAT	;Is it initialized as READ ONLY?;017
	BNE	190$		;Yes					;014
	CLRB	RODISK		;Otherwize clear the read-only switch	;014
190$:	CALLX	LOKMIN		;FIND BADB, SATT, AND INIT (IF DISK), AND READ
				;    DEFAULTS FROM SIL (IF ONE IS INSTALLED)
	BCS	210$		;NOT ALL THERE
	TST	SILNAM		;IS THERE AN INSTALLED SIL?
	BEQ	210$		;NO
	MOV	#DEFBFP,R0	;POINT TO PERMANENT PART OF DEFBUF
	MOV	SILCKS,R1	;GET THE CHECKSUM
200$:	MOV	(R0)+,R2	;GET A WORD
	XOR	R2,R1		;COMPUTE CHECKSUM
	CMP	R0,#DEFBUF+SIZDEF ;DONE IT ALL?
	BLO	200$		;NO
	TST	R1		;CHECKSUM 0?
	BEQ	210$		;YES, ALL OK
	CLR	SILNAM		;ZAP THE NAME
	CLR	SILNAM+2
	CLRB	AUTOQS		;DON'T BOTHER W/ AUTO-RESTART
210$:	CALLX	ENDFIP		;SAY FIP AREA IS CLEAN.
	CALLX	MESSAG,R5,260$	;CLEAN UP TERMINAL
;	TSTB	AUTOGO		;Doing streamline startup?		;003
;	BNE	250$		;Yes, skip message			;020

	MOV	#ILOGO+4,R0	;Point to INIT logo			;049
	MOV	SYSUSV,R1	;Get unit number.			;020
	CMP	R1,#9.		;More than 1 digit?			;020
	BHI	230$		;Yup, take special steps.		;020
	ADD	#60,R1		;Otherwise, make it ASCII...		;020
	MOVB	R1,(R0)		;...and move it in.			;020
	BR	240$		;Skip around the 2-digit stuff.		;020

230$:	MOVB	#'1,(R0)+	;First digit's gotta be a 1.		;020
	ADD	#46,R1		;Correct the second digit...		;020
	MOVB	R1,(R0)		;...and put it away.			;020
	DEC	R0		;Point to the beginning again.		;020
240$:	MOV	SYSNAM,-(R0)	;PUT IN BOOTED DEVICE NAME
250$:	JMPX	ONECNT		;Continue in root

.NLIST	BEX

260$:	.ASCIZ	<377><177><200><12>

	.EVEN			;BOUNDARY FOR CODE
	.ASCII	" ("		;START OF BOOTED NAME
	.ASCII	"??"		;THE NAME
265$:	.ASCII	<176><176>	;Unit number (leave room for 2 digits)	;020
	.ASCII	")"							;020

	.ASCIZ	<40>		;TYPE ONLY A <SPACE> IF AODS LOGO
	.EVEN


.DSABL	LSB

GLOBAL	<I.STAK,GOSWIT,SILNAM,DEFBFP,SILCKS,DEFBUF,SIZDEF,SILNAM,AUTOQS>
GLOBAL	<LOGO,I.DFLD,D.NAME,SYSUSV,SYSNAM,AUTOGO,RODISK,FIBUF,DSKREV>
GLOBAL	<ILOGO>								;049

.ENABL	LSB								;061

;+									;061
;	FULSIZ - See if we should perform a full autosize		;061
;									;061
;	This routine checks the flag BF.FSZ which is passed in the	;061
;	bootstrap.  If this is set, B.JMP is set to the value 012707,	;061
;	which causes One-Shot to do a full hardware autosizing.		;061
;
;	Call is:							;061
;		CALL	FULSIZ						;061
;									;061
;	No data is passed or returned.					;061
;	All registers preserved.					;061
;-									;061

FULSIZ:	TSTB	@#B.FLGS	;Do we want to do a full system sizing?	;061
	BPL	10$		;No, so just go back.			;061
.ASSUME	BF.FSZ	EQ 200							;061
	MOV	#<MOV+2707>,@#B.JMP					;061
				;Deflower the bootstrap...		;061
	BICB	#BF.FSZ,@#B.FLGS;Also, make sure it's temporary!	;061
10$:	RETURN			;And go back.				;061

GLOBAL	<B.JMP,B.FLGS>							;061

.DSABL	LSB								;061


SETDEN:	CLR	SYSDEN		;Assume we are a devo disk?????		;044
	CLR	TAPDEN		;Assume we are a devo disk		;044
	TST	SYNXSV		;Are we booted from tape		;044
	BPL	10$		;No, our assumption was right		;044
	MOV	@#B.DCS,TAPDEN	;Move booted density into TAPDEN	;044
	CLR	@#B.DCS		;And clear out device cluster size	;044
GLOBAL	<SYSDEN>
;????????+
	MOV	#256.,SYSDEN	;Assume 1600 BPI tape			;044
	CMP	TAPDEN,#800.	;800 BPI tape?				;044
	BNE	10$		;No, our assumption is "right"		;044
				;(Right enough for old style call)	;044
	MOV	#12.,SYSDEN	;Yes.  Set 800 BPI bits			;044
;????????-
10$:	RETURN			;All done				;044

GLOBAL	<SYNXSV,TAPDEN>

.SBTTL	Check proper operation of 11/73/83/84 FPA			;031+

.ENABL	LSB

;+
; CHKFPA - Check for proper operation of 11/73/83/84 FPA and CPU
;
;	CALL	CHKFPA
;
; R0 - R3 are undefined on exit.
;
; If the FPA/CPU is found to be defective, an error message will be
; issued and INIT will prevent startup from occuring.
;
;-

CHKFPA:	CMPB	CPTYP,#5	;Are we on an 11/73/83/84?
	BNE	60$		;No, so skip the whole thing.		;037
	BIT	#400,@#177750	;If so, do we have an FPA?
	BEQ	30$		;Nope, so once again skip it.
	LDFPS	#40000		;Disable floating exception traps.
	SETF			;Use single precision.
	LDCIF	#0,AC0		;START WITH SOME KNOWN VALUES		;046
	LDCIF	#777,AC1	; "					;046
	LDCIF	#1,AC2		; "					;046
	ADDF	AC2,AC1		;GET THE RIGHT ANSWER			;046
	STF	AC1,AC3		;AND SAVE IT FOR LATER			;046
	SUBF	AC2,AC1		;GET BACK TO WHERE WE STARTED		;046
	MOV	#10.,R1		;GET READY TO WAIT FOR THE FPJ		;046
5$:	SOB	R1,5$		;WASTE SOME TIME			;046
	MULF	TSTVAL,AC0	;PRODUCE A 0 RESULT			;046
	ADDF	AC2,AC1		;PRODUCE WRONG ANSWER IF BUG IS THERE	;046
	CMPF	AC1,AC3		;lets see if we got the right answer	;046
	CFCC								;046
	BEQ	8$		;GOOD, THE FPJ passes this test		;046
	MOV	SP,NOSTAR	;Tell START no can do!!			;046
	MESSAG								;046
	 .ASCII "ADDF after MULF=0 sometimes produces wrong answers."	;046
	 .ASCII	<15><12>"ECOs are missing from this FPJ11."		;046
	 .ASCIZ	<200>							;046
	UNORG			;So there.				;046
8$:	LDF	#0,AC0		;Here's the denominator...
	LDF	#123456,AC1	;And, here's the numerator.
	MOV	#PR7!20,-(SP)	;SET TO TURN T BIT TRAPS ON		;041
	MOV	#10$,-(SP)	; WHEN WE GO HERE			;041
	MOV	@#14,R1		;SAVE TRAP LOCATION			;041
	;NOTE: YOU CAN NOT USE ODT AFTER THIS POINT			;041
	MOV	#20$,@#14	;AND GO HERE FOR THE T BIT TRAPS	;041
	RTT			;AND, GO THERE TO 10$			;041

	TMPORG	ONECTL
FPTST1:	.WORD	0		;One of the words we deal with.
FPTST2:	.WORD	0		;The other one.
TSTVAL:	.WORD	40640
	.WORD	5		;LOW BITS MUST BE 5,6,11, OR 12
	UNORG

10$:	DIVF	AC0,AC1		;A deliberate divide-by-zero!

20$:	INC	FPTST1		;Increment the first location...
	INC	FPTST2		; ...and the second.
	MOV	R1,@#14		;RESTORE THE OLD VECTOR VALUE		;041
	;NOTE: YOU CAN NOW USE ODT AGAIN (BPT TRAPS ARE RESTORED)	;041
	CMP	FPTST1,FPTST2	;Are they the same??			;041
	BNE	70$		; NO, SO IT FAILS			;041
	CMP	(SP)+,#20$	;DID THE PC GET SAVED CORRECTLY		;041
	BNE	80$		; NO, SO IT FAILS			;041
	CMP	(SP)+,#PR7!20	;DID THE PSW GET SAVED CORRECTLY	;041
	BNE	90$		; YES, go on to the next test.		;041
25$:	MOV	#100000,R0	;Try the ASHC test first.		;046
	CLR	R1		;If CPU/FPA is OK, this should return	;034
	ASHC	#137,R0		; 0 in both registers.			;034
	BIS	R0,R1		;Make sure we check both of them.	;034
	BNE	40$		;Oops!! A problem.			;034
30$:	BIS	#4000,@#PS	;Make sure we're on Register Set 1.
	SETD			;Initialize the FPU.
	CLR	R1		;Start out with nothing there.
	LDD	#123456,AC0	;Put something into an FP register...
	STEXP	AC0,R1		; ...and move it into a GPR.
	TST	R1		;Did anything get there?
	BNE	60$		;Yup, so it's OK.
40$:	MOV	SP,NOSTAR	;Tell START no can do!!
	MESSAG
	 .ASCII	"This DCJ11 cannot be used in conjunction with an FPJ11"
	 .ASCII	" accelerator."
	 .ASCIZ	<200>
	UNORG			;So there.
	MOVB	#'1,50$		;USE THE CORRECT EQ- # FOR THIS FCO	;051
60$:	TST	NOSTAR		;DO WE LET THEM START?			;046
	BEQ	65$		; YES!!!				;046
	CMP	JCPTYP,#2	;Is this a KDJ11-B?			;059
	BNE	62$		;No, so no FCO message needed		;059
	MESSAG
	 .ASCII	"Contact Field Service for FCO kit EQ-01440-0"		;051
50$:	 .ASCII	"2 to correct the problem."				;051
	 .ASCIZ	<200><12>						;056
	UNORG								;056
62$:	CALLX	MESSAG,R5,INITOK ;Tell them that INIT will continue.	;059
65$:	RETURN			;Go back.

70$:	TST	(SP)+		;TRASH 2 WORDS WHEN ENTERING HERE	;041
80$:	TST	(SP)+		;TRASH JUST 1 WORD ENTERING HERE	;041
90$:	MOV	SP,NOSTAR	;Otherwise, say it's no good.		;037
	MESSAG	<"The floating exception ECO is missing from this FPJ11."<200>>
	BR	25$		;No can do!!				;046

GLOBAL	<CPTYP,FPU,NOSTAR,INITOK>					;056

.DSABL	LSB
;-									;031-


.SBTTL	CHECK DEVICE CSR'S ON BUS

.ENABL	LSB

;+
; CHKCSR - CHECK CSRTBL AND DISABLE DEVICES WHICH DON'T RESPOND
;
;	CALL	CHKCSR
;
;	ENTRIES IN CSRTBL WHICH DON'T RESPOND ARE ZEROED
;-

CHKCSR:	REGSCR			;SAVE ALL REGISTERS
	CLR	TM.CSO+CSRTBL	;NO TU10 AS OF YET
	CALLX	DEVLUP		;START SCANNING THEM ALL
10$:	CMP	R5,#TAPEND+PKTSIZ ;Done disks and tapes and DECtape?	;024
	BLO	20$		;NOT YET
	TSTB	FLGGPK		;Yes, but is it a GPK?			;049
	BMI	20$		;Yes, so we keep on going regardless	;049
	CALLX	VBCHK		;Is the boot no longer first-time?	;061
				; (i.e. has INSTAL or HARDWR been used?);061
	BCC	20$		;Yes, so carry on.			;061
	JMP	240$		;NOPE, STOP HERE AND NOW		;049

20$:	CALLX	TRASEC		;FIELD ALL TRAPS TO SET CARRY
	MOV	CSRDEC-CSRTBL(R4),R1 ;get prototype CSR value		;054
	TSTB	FLGGPK		;Are we on a GPK?			;066
	BPL	70$		;No, do the other stuff			;049
	BITB	#PS.GPK,PK.FLG(R5) ;GPK type device?			;049
	BEQ	110$		;No, skip it				;049
	BITB	#PS.FIX,PK.FLG(R5) ;Fixed CSR for this device?		;049
	BNE	100$		;Yes, check if it's present		;049
	MOV	R1,R0		;CSRDEC entry is actually ID value	;049
	TST	DEV.UN		;First unit of this device type?	;049
	BEQ	40$		;Yes					;049
	MOV	-2(R4),R1	;No, we'll start beyond the previous one ;049
	BEQ	110$		;None last time, so none left		;049
	MOV	R1,R3		;Copy slot pointer			;049
	SUB	#SLOT0,R3	;Get slot offset			;049
	ASH	#-7,R3		;Convert to slot number			;049
	MOV	#1,R2		;Option present register bit for slot 0	;049
	ASH	R3,R2		;Get bit corresponding to CSR address	;049
	BR	60$		;Now advance to next slot		;049

40$:	MOV	#SLOT0,R1	;Start at first slot			;049
	MOV	#1,R2		; and its bit in option register	;049
50$:	BIT	R2,@#OPRES	;Option present in slot?		;049
	BEQ	60$		;No, skip it				;049
	CLR	2(R1)		;Reset "ROM address" register		;049
	MOV	(R1),R3		;Now we can safely get device type	;049
	CMPB	R3,R0		;Match on type?				;049
	BEQ	120$		;Yes, so we found it			;049
	CMP	R5,#PI.PKT	;No, but is this the PI packet?		;049
	BNE	60$		;No, so indeed no match			;049
	CMPB	R3,#50		;Yes, second chance			;049
	BEQ	120$		; and branch if we found it		;049
60$:	ADD	#SLOT1-SLOT0,R1	;Advance address by 1 slot's worth	;049
	ASLB	R2		;Next bit				;049
	BPL	50$		;Loop if more to check			;049
	BR	110$		;Device not found, exit that way	;049

70$:	BITB	#PS.GPK,PK.FLG(R5) ;GPK specific device?		;049
	BNE	110$		;Yes, so it's absent			;049
	CMP	R5,#TS.PKT	;ARE WE CHECKING OUT THE TS04?
	BNE	80$		;NO, SEE IF IT IS A TU10
	CMP	DEV.UN,#4.	;IS THIS UNIT #4 OR GREATER?
	BGE	110$		;YES, BUT WE DON'T SUPPORT THOSE
	TST	TM.CSO+CSRTBL	;YES, DID WE FIND A TU10 EARLIER?
	BNE	110$		;YES, THEN THERE ARE NO TS04'S
80$:	CMP	R5,#TM.PKT	;ARE WE CHECKING OUT THE TU10?
	BNE	90$		;NO, LOOK INTO THE RP04 PROBLEM
	TST	TS.CSO-TM.CSO(R4) ;DID WE FIND A TS04 EARLIER?
	BNE	110$		;YES, THEN THERE ARE NOT TU10'S
90$:	CMP	R5,#RB.PKT	;ARE WE CHECKING OUT THE RP04/05/06?
	BNE	100$		;NO
	TST	RP.CSO-RB.CSO(R4) ;YES, DID WE FIND AN RP03 EARLIER?
	BNE	110$		;YES, THERE'S NO PRIMARY RH
100$:	TST	(R1)		;TRY TO ACCESS THE ADDRESS
	NOP			;Make sure CCs are OK for all CPUs.	;063
	BCC	120$		;IT RESPONDED
110$:	CLR	R1		;NOTHING THERE, USE 0 AS ADDRESS
120$:	MOV	R1,(R4)		;AND PLUG THE BUILT CSR TABLE
	BEQ	190$		;IF NOTHING THERE, WE ARE DONE

GLOBAL	<CSRDEC,TM.CSO,CSRTBL,TAPEND,TS.PKT,DEV.UN,TM.PKT,TS.CSO,RB.PKT>
GLOBAL	<RP.CSO,RB.CSO>							;066

	CMP	R5,#RM.PKT	;ARE WE CHECKING OUT THE RK06?
	BNE	130$		;NOPE
	MOV	#-2,RMDS(R1)	;YES, IS THIS AN RK06 OR AN RC/RF?
	BCS	140$		;NO, IT ISN'T
	CMP	#-2,RMDS(R1)	;IF THIS IS AN RK06, RMDS IS R/O
	BEQ	140$		;NO, IT'S AN RC, SO DISABLE RK06
	CLR	RF.CSO-RM.CSO(R4) ;IT'S RK06, SO DISABLE THE RF DISK
130$:	CMP	R5,#RP.PKT	;ARE WE CHECKING OUT THE RP03?
	BNE	150$		;NO, THE DEVICE IS REALLY THERE
	MOV	#-1,16(R1)	;YES. TRY PUTTING -1 IN RPWC
	BCS	140$		;THAT LOCATION IS DEAD!
	CMP	#-1,16(R1)	;IF IT'S REALLY AN RP03, IT WILL STAY
	BEQ	150$		;AND IT'S REALLY AN RP03
140$:	CLR	(R4)		;NO, IT'S AN RP04 (WE POKED RBAS)
150$:	CMP	R5,#XN.PKT	;IS THIS A DN11?
	BNE	170$		;NO, IT ISN'T
	MOV	#10,(R1)	;SET MAINTENANCE MODE
	BIT	#10,(R1)	;WAS IT SET?
	BNE	160$		;Yes, then the device really exists.	;056
	CLR	(R4)		;NO, THEN THERE WAS NO DN11 HERE
160$:	CLR	(R1)		;TURN OFF MAINENANCE MODE
170$:	CMP	R5,#TS.PKT	;IS THIS A TS04 MAGTAPE?
	BNE	190$		;NOPE
	MOV	#1000,2(R1)	;YES, SET EXTENDED ADDRESS BIT 17
	BIT	#1000,2(R1)	;DID WE SET IT?
	BEQ	190$		;NOPE, THATS GOOD, WE SHOULDN'T BE ABLE TO
180$:	CLR	(R4)		;YUP, THEN WE SELECTED UNIT #2 FOR A TU10
	MOV	R1,TM.CSO+CSRTBL;INDICATE A TU10 HAS BEEN FOUND
190$:	CMP	R5,#DL.PKT	;Are we looking at the DL11s?		;063
	BNE	210$		;No, so go on to the next device.	;063
	CMP	R1,@#176570	;Is this the standard UTA CSR address?	;063
	BNE	210$		;No, so skip further checking.		;063
	ADD	#2,R1		;Bump R1 to point to the second register;063
	MOV	(R1),-(SP)	;Save what we think is the Addr Comp reg;063
	CLR	(R1)		;Try clearing it.			;063
	TST	(R1)		;Did it really clear?			;063
	BNE	200$		;No, so it's not a UTA - skip it.	;063
	MOV	#-1,(R1)	;Now, try to set all bits.		;063
	CMP	(R1),#-1	;Did they all set?			;063
	BNE	200$		;No, it's not a UTA - skip it.		;063
	CLR	(R4)		;It is a UTA, so clear CSRTBL entry to	;063
				; ignore it.				;063
200$:	MOV	(SP)+,(R1)	;Restore the value we saved.		;063
	SUB	#2,R1		;And, put R1 back the way it was.	;063
210$:	CALL	@(SP)+		;FIX UP 4 FROM TRASEC
	CALLX	GETTTY		;WATCH THE TERMINAL AND THE CLOCK
	CALL	@(SP)+		;ON TO THE NEXT DEVICE
	BEQ	220$		;none left				;049
	JMP	10$							;049

GLOBAL	<DEV.UN,DP.CSO,RM.PKT,RM.CSO,RV.CSO,RF.CSO,RP.PKT>
GLOBAL	<XN.PKT,TS.PKT,TM.CSO,CSRTBL>
GLOBAL	<FLGGPK>							;049

.SBTTL	Check for illegal configurations on Q22 bus systems

; REMOVE ILLEGAL STORAGE-DEVICE COMBINATIONS ON Q-bus WHEN ACTUAL MEMORY IS
;   GREATER THAN 256KB

220$:	TSTB	FLGQBU		;IS THIS A Q-bus SYSTEM?
	BMI	230$		;NO
	TSTB	FLGGPK		;Perhaps, or is it a GPK?		;045
	BMI	230$		;It's a GPK, skip this stuff		;045
	BITB	#1,FLG22	;IS MEMORY > 256KB?
	BNE	230$		;NO
;	DISABLE ANY ILLEGAL DEVICES (This is now done in INISTA)
230$:	RETURN			;GO BACK WITH REGISTERS RESTORED

240$:	TST	(SP)+		;DUMP DEVLUP CALL
	MESSAGE	<"Performing limited hardware scan."<200>>		;061
	CALLRX	TTYSTP		;WAIT FOR TTY TO FINISH PRINTING

.DSABL	LSB

GLOBAL	<FLGQBU,FLG22,FLGGPK>						;049

.SBTTL	SORT OUT DL11 INTERFACES, CARD READERS, DB/DR DISKS

.ENABL	LSB

DEVSRT:	TSTB	FLGGPK		;Is this a GPK?				;049
	BMI	50$		;Yes, nothing to do			;049
	MOV	#CSRTBL+DL.CSO,R3 ;R3 -> DL11C/D/E CSR'S
	MOV	R3,R4		;R4 ->  "
	MOV	#CSRTBL+DE.CSO,R5 ;R5 -> DL11E CSR TABLE
	MOV	#31.,R1		;A POSSIBLE 31 TO DO
10$:	MOV	(R3),R2		;GET A CSR
	CLR	(R3)+		;CLEAR SOURCE
	TST	R2		;IS THERE A CSR?
	BEQ	30$		;NO
	BIS	#2,(R2)		;YES, TRY TO SET DTR
	BIT	#2,(R2)		;DID IT GO ON?
	BEQ	20$		;NO, GO ADD TO DL11C/D LIST
	CMP	R5,#CSRTBL+DE.CSO+<31.*2>				;063
				;See how many DL11-Es we have so far.	;063
	BHIS	20$		;We're at maximum, so we'll call this	;063
				; one a DL11-C/D.			;063
	MOV	R2,(R5)+	;Add this one to the DL11-E list.	;063
	BR	30$

20$:	MOV	R2,(R4)+	;ADD TO DL11C/D LIST
30$:	SOB	R1,10$		;DO ALL OF THEM
	CALL	DDSORT		;Now sort out TU58s.			;035

; NOW SORT OUT THE CARD READER

	MOV	CSRTBL+CR.CSO,R2 ;R2 -> CARD READER CSR
	BEQ	40$		;NONE IS EASY
	MOV	#-1,2(R2)	;TRY TO SET THE COLUMN COUNT
	CMP	#-1,2(R2)	;DID IT STAY SET?
	BNE	40$		;NO, IT REALLY IS A CR11
	MOV	R2,CSRTBL+CD.CSO ;YES, IT'S A CD11
	CLR	CSRTBL+CR.CSO	;AND TURN OFF CR11

; DETERMINE WHICH RH CONTROLLERS SHOULD BE CALLED DB, AND WHICH DR

40$:	MOV	CSRTBL+RR.CSO,R0 ;ADDRESS OF SECONDARY RH CONTROLLER
	CALL	70$		;DETERMINE TYPE OF ITS DRIVES
	MUL	#3,R1		;THREE ROWS IN TABLE
	MOV	R1,R3		;SAVE WHILE WE CALL AGAIN
	MOV	CSRTBL+RB.CSO,R0 ;ADDRESS OF PRIMARY RH CONTROLLER
	CALL	70$		;DETERMINE TYPE OF ITS DRIVES
	ADD	R3,R1		;R1 = 3*ROW + COLUMN
	TSTB	60$(R1)		;0 IF DB,DR; -1 IF DR,DB
	BEQ	50$		;PRIMARY IS DB, SECONDARAY IS DR
	MOV	CSRTBL+RR.CSO,CSRTBL+RB.CSO ;SWAP THE CSR'S
	MOV	R0,CSRTBL+RR.CSO;BOTH OF THEM
50$:	RETURN

GLOBAL	<CSRTBL,DL.CSO,DE.CSO,CR.CSO,CD.CSO,RR.CSO,RB.CSO>

.NLIST	BEX

; PRIMARY WAS:	---N-O-N-E---	-----D-B-----	-----D-R-----	;SECONDARY
; FLAGS FOR DB/DR CSRS  0 MEANS DB = 176700, DR = 176300; -1 MEANS SWAP

60$:	.BYTE	     0,		      0,	      -1	;NONE
	.BYTE	    -1,		      0,	      -1	;DB
	.BYTE	     0,		      0,	      -1	;DR
	
	.EVEN

.LIST	BEX

; SUBROUTINE TO DETERMINE TYPE OF LOWEST-NUMBERED RP04/05/06/07/RM02/03/05/80
; ON THE RH CONTROLLER AT THE ADDRESS IN R0.
; RESULT IN R1:  0 = NONE,  1 = RP04/RP05/RP06,  2 = RM02/03/05/80/RP07
; DESTROYS R1,R2

70$:	TST	R0		;IS THERE A CONTROLLER?
	BEQ	100$		;NO -- RESULT IS 0
	CLR	R2		;START WITH UNIT ZERO
80$:	MOV	#RHCLR,RHCS2(R0) ;CLEAR CONTROLLER
	MOV	R2,RHCS2(R0)	;SELECT A UNIT
	MOV	RHDT(R0),R1	;READ ITS MASSBUS ID
	BIT	#RHMCPE,(R0)	;PARITY ERROR?
	BNE	90$		;YES -- NONEXISTENT DRIVE
	BIT	#RHNED,RHCS2(R0) ;NONEXISTENT DRIVE?
	BNE	90$		;YES
	BIC	#004000,R1	;IGNORE DUAL-PORT BIT
	SUB	#020020,R1	;GET IN RANGE
	CMP	R1,#30		;DOES IT LOOK REASONABLE?
	BHIS	90$		;NO -- CALL IT NONEXISTENT
	MOVB	110$(R1),R1	;GET THE NUMBER TO RETURN
	BEQ	90$		;NOT AN RP04/05/06/07/RM02/03/05/80 -- SKIP IT
	RETURN

90$:	INC	R2		;TRY THE NEXT UNIT
	CMP	R2,#8.		;ONLY 0-7 ARE LEGAL
	BLO	80$		;LOOP WITH NEW UNIT
100$:	CLR	R1		;RETURN ZERO -- NO UNITS FOUND
	RETURN

110$:	.BYTE	1,1,1,0,2,2,2,2	;RP04,RP05,RP06,?,RM03,RM02,RM80,RM05
	.BYTE	0,0,0,0,0,0,0,0	;?,?,?,?,?,?,?,?
	.BYTE	0,0,2,0,0,0,0,0	;?,?,RP07,?,?,?,?,?

.DSABL	LSB


.SBTTL	SORT DL11/A/B/C/D'S FROM TU58'S					;035+

.ENABL	LSB

DDSORT:	MOV	#CSRTBL+KL.CSO,R4 ;GET POINTER TO DL11-A/B ADDRESSES
	CLR	R5		;INDICATE WE ARE NOW WORKING ON DL11-A/B
	MOV	#16.,R3		;THERE ARE 16 OF THEM
10$:	MOV	(R4)+,R2	;GET THE CSR OF ONE OF THEM
	BEQ	20$		;DON'T TRY IT IF THERE ISN'T ONE
	MOV	#1,4(R2)	;TRY SETTING BREAK IN IT
	CALL	80$,R5,<5>	;SEND A CHARACTER
	CALL	80$,R5,<5>	;TWO CHARACTERS WILL CAUSE A FRAMING ERROR
	CALL	80$,R5,<377>	;SYNCH THE LINE BACK UP
	CLR	4(R2)		;CLEAR THE BREAK BIT
	MOV	2(R2),R0	;AND DUMP THE RECIEVER OF ANY GARBAGE
	CALL	80$,R5,<4>	;SEND THE ALLEGED TU58 AN INIT SIGNAL
	MOV	2(R2),R0	;DUMP THE RECIEVER FOR GOOD LUCK
	CALL	80$,R5,<4>	;SEND ANOTHER INIT FOR MORE LUCK
20$:	SOB	R3,10$		;AND DO THIS FOR ALL DL11'S
	TST	R5		;HAVE WE FINISHED THE DL11-C/D'S?
	BNE	30$		;YES, GO DO SOMETHING ELSE
	INC	R5		;NO, INDICATE THAT WE SHALL WORK ON THEM
	MOV	#CSRTBL+DL.CSO,R4 ;SET UP A POINTER TO THEIR ADDRESSES
	MOV	#31.,R3		;THERE ARE 31 OF THEM TO TRY
	BR	10$		;AND GO SEARCH THEM

GLOBAL	<CSRTBL,KL.CSO,DL.CSO>

30$:	MOVB	#-2.,DSS$DV+1	;WAIT 2 SECS BEFORE SEEING IF RESPONSE
40$:	CALLX	GETTTY		;KEEP THE CLOCK GOING
	TST	DSS$DV		;HAVE WE TIMED OUT?
	BMI	40$		;NOPE, KEEP WAITING
	MOV	#CSRTBL+KL.CSO,R4 ;GET A POINTER TO THE DL11-A/B CSR'S
	MOV	#CSRTBL+DD.CSO,R5 ;AND GET A POINTER TO THE DD CSR'S
	MOV	#16.,R3		;THERE ARE 16 OF THEM TO CHECK
	CLR	R0		;INDICATE WE ARE NOW CHECKING DL11-A/B'S
50$:	MOV	(R4)+,R2	;GET ONE OF THE CSR'S
	BEQ	60$		;DON'T TRY IT IF THERE ISN'T ONE
	BIT	#200,(R2)	;HAS IT SENT US ANYTHING?
	BEQ	60$		;NOPE, JUST A NORMAL TERMINAL
	CMP	#20,2(R2)	;DID IT SEND US A CONTINUE?
	BNE	70$		;NOPE, THEN IT PROBABLY WAS AN LSI-11
	CMP	R5,#CSRTBL+DD.CSO+10 ;DO WE ALREADY HAVE 4 DD CONTROLLERS?
	BHIS	60$		;YES, CALL THIS EXTRA ONE A DL11
	MOV	R2,(R5)+	;NOPE, ADD THIS DD CONTROLLER INTO THE LIST
	CLR	-(R4)		;REMOVE IT FROM THE DL11 LIST
	TST	(R4)+		;PUT THE POINTER BACK TO WHERE IT SHOULD BE
60$:	SOB	R3,50$		;AND DO ANOTHER DL11
	TST	R0		;HAVE WE FINISHED WITH THE DL11-C/D'S?
	BNE	110$		;YES, THEN WE ARE ALL DONE
	INC	R0		;NO, FLAG THAT WE WILL BE DOING DL11-C/D'S
	MOV	#CSRTBL+DL.CSO,R4 ;POINT TO THE DL11-C/D CSR'S
	MOV	#31.,R3		;THERE ARE 31 OF THEM TO DO
	BR	50$		;AND GO DO THEM

70$:	CALL	80$,R5,<'P>	;TELL THE LSI-11 TO PROCEED
	BR	60$		;AND GO TO THE NEXT CONTROLLER

80$:	MOVB	#-2.,DSS$DV+1	;SET A TIME-OUT FOR 2 SECONDS
	MOV	(R5)+,6(R2)	;SEND THE REQUESTED CHARACTER
90$:	BIT	#200,4(R2)	;HAS IT GOBBLED IT UP YET?
	BNE	100$		;YES, LETS RETURN
	CALLX	GETTTY		;KEEP THE CLOCK GOING
	TST	DSS$DV		;HAVE WE WAITED LONG ENOUGH?
	BMI	90$		;NO, KEEP WAITING
100$:	RETURN	R5		;YES, LETS GO BACK TO THE CALLER

110$:	RETURN			;ALL DL11-A/B/C/D'S ARE SORTED

.DSABL	LSB

GLOBAL	<CSRTBL,KL.CSO,DD.CSO,DL.CSO>					;035-


.SBTTL	LOCATE FLOATING BUS ADDRESS DEVICES

;+
; FNDFLT - FIND BUS ADDRESSES OF FLOATING DEVICES
;
;	CALL	FNDFLT
;
;	CSRTBL UPDATED FOR FLOATING DEVICES
;-

FNDFLT:	CALLX	VBCHK		;Ever used INSTAL or HARDWR?		;061
	BCS	80$		;Nope, so skip this junk.		;061
	TSTB	FLGGPK		;Is this a GPK?				;049
	BMI	80$		;Yes, no floaters there			;049
	REGSCR			;SAVE REGS
	MOV	#FLTBA,R0	;POINT TO TABLE FOR FLOATERS
	MOV	#160000,R1	;SET START OF FLOATING BUSSES
10$:	MOV	(R0)+,R5	;R5 = SIZE OF A CSR SET
	MOV	(R0)+,R4	;R4 = CSRTBL OFFSET FOR FLOATING CSR
	MOV	(R0)+,R2	;R2 POINTS AT DEVICE PACKET
	BEQ	40$		;THIS IS NOT A RSTS DEVICE
	MOVB	(R2)+,R3	;R3 = NUMBER OF UNITS SUPPORTED
.ASSUME	PK.MXU EQ 0
	INC	R2		;Skip over flags
	CMP	(R2)+,R4	;IS THIS AN ALTERNATE CONTROLLER ADDRESS?
.ASSUME	PK.CSO EQ PK.MXU+2
	BEQ	20$		;NO, CLEAR ALL CSR ENTRIES
	DEC	R3		;YES, ACCOUNT FOR THE 1ST FIXED CSR
20$:	CMPB	(R2)+,R5	;THE BUS ADDRESS SIZE BETTER MATCH
.ASSUME	PK.SIZ EQ PK.CSO+2
	BNE	90$		;OUCH, TABLE ERROR
	ADD	#CSRTBL,R4	;R4 -> CSRTBL ENTRY FOR THIS DEVICE
	MOV	R4,R2		;COPY IT
30$:	CLR	(R4)+		;CLEAR OUT ALL CSR'S FOR THIS DEVICE
	SOB	R3,30$
40$:	ADD	R5,R1		;ROUND UP BUS ADDRESS FROM GAP
	MOV	R5,-(SP)	;GET A MASK
	DEC	(SP)
	BIC	(SP)+,R1	;AND ROUND DOWN TO DEVICE MULTIPLE
50$:	CALLX	TRASEC		;C=1 IF TRAP TO 4
	TST	(R1)		;DOES THIS ADDRESS RESPOND?
	CALL	@(SP)+		;RESTORE THE VECTOR @ 4
	BCS	60$		;NO, WE ARE AT THE DEVICE GAP
	TST	R2		;YES, DOES RSTS SUPPORT IT?
	BEQ	40$		;NO
	MOV	R1,(R2)+	;YES, ENTER A TABLE
	CMP	-2(R0),#XM.PKT	;WAS IT A DMC-11 THAT WE FOUND?
	BNE	40$		;NO, TRY FOR ANOTHER ONE OF THESE

; DMC-11'S NEED TO BE TOLD TO TURN DATA SET READY OFF

	MOV	#40000,(R1)	;MASTER CLEAR THIS DMC
	MOV	#122013,6(R1)	;INSTRUCTION TO TURN OFF DATASET READY
	MOVB	#202,1(R1)	;TELL IT TO EXECUTE
	BR	40$		;TRY FOR ANOTHER ONE OF THESE

60$:	CALLX	GETTTY		;WATCH THE TERMINAL AND THE CLOCK
	MOV	-2(R0),R3	;CHECK PACKET DEVICE NAME FOR SPECIAL HANDLING
	CMP	PK.NAM(R3),#"XD	;WAS THIS GAP FROM THE DMP TYPE DEVICE ?
	BNE	70$		;NO, SO BYPASS SPECIAL HANDLING ALTOGETHER
	SUB	#CSRTBL,R2	;YES, COMPARE THE ORIG. OFFSET TO THE CURRENT
	CMP	R2,PK.CSO(R3)	;  OFFSET TO SEE IF WE FOUND ANY DMPS.
	BNE	70$		;IF THE OFFSETS ARE NOT =, THEN WE FOUND SOME.
				;NO DMPS, BUT THE DMV IS ALSO AN "XD" DEVICE
	MOV 	#XD.PKT,X3.PKT	;   SO... DMP'S & DMV'S USE THE SAME PACKET
	MOV	#XD.CSO,X3.OFF	;     and the same CSRTBL offset
				;WE ALSO HAVE TO RESET THE CSR SIZE IN
	MOVB	#DMVSZ,PK.SIZ(R3);   THE "XD" PACKET TO AGREE WITH A DMV
	MOVB	#DMVNU,PK.NUN(R3);   & THE MAX NUMBER OF SUB-UNITS CONTROLLED
70$:	TST	(R0)		;ARE WE DONE?
	BNE	10$		;NOT YET
80$:	RETURN

90$:	ERF	<"INIT bug - float table error">

GLOBAL	<CSRTBL,XM.PKT,XD.PKT,XD.CSO,DMVSZ,DMVNU>

.SBTTL	POKE EVERY DEVICE TO FIND OUT WHERE IT VECTORS

;+
; VECCKA - CHECK EVERY DEVICE TO MAKE IT INTERRUPT
;
;	CALL VECCKA
;
;	VECTBL SET UP TO CONTAIN VECTOR LOCATIONS
;-

.ENABL	LSB

VECCKA:	MOV	#VECMAP,R4	;POINT TO THE BIT MAP OF VECTORS IN USE
	MOV	#30$,R5		;INITIALIZE IT FROM THIS TABLE
10$:	MOV	(R5)+,(R4)+	;MOVE IN INITIAL VALUE
	CMP	R5,#40$		;DONE?
	BLO	10$		;LOOP UNTIL DONE
	TSTB	FLGGPK		;Is this a GPK?				;049
	BPL	15$		;No					;049
	MOVB	#^B11000000,VECMAP+4 ;Yes, 230/234 are for clock	;049
15$:	CALLX	DEVLUP		;COROUTINE TO LOOP THROUGH ALL DEVICES	;049
20$:	CALL	VECCHK		;CHECK A VECTOR
	CALL	@(SP)+		;ADVANCE TO NEXT DEVICE
	BNE	20$		;  IF ANY
	RETURN			;FINIS

.RADIX	2			;INITIAL BIT MAP

30$:	.BYTE	11111111	;  34  30  24  20  14  10   4   0
				;TRAP EMT PWF IOT BPT ILL TMO HLT
	.BYTE	00001111	;  74  70  64  60  54  50  44  40
				;		  --- --- --- ---
	.BYTE	00001111	; 134 130 124 120 114 110 104 100
				;		  PAR JM0 KWP KWL
	.BYTE	00000010	; 174 170 164 160 154 150 144 140
				;			  CRS
	.BYTE	10000000	; 234 230 224 220 214 210 204 200
				;STAT
	.BYTE	00000111	; 274 270 264 260 254 250 244 240
				;		      MMU FPU PIRQ
	.BYTE	00000000	; 334			      300
	.BYTE	00000000	; 374			      340
	.BYTE	00000000	; 434			      400
	.BYTE	00000000	; 474			      440
	.BYTE	00000000	; 534			      500
	.BYTE	00000000	; 574			      540
	.BYTE	00000000	; 634			      600
	.BYTE	00000000	; 674			      640
	.BYTE	00000000	; 734			      700
	.BYTE	00000000	; 774			      740

40$:

.RADIX	8.

GLOBAL	<VECMAP>

.SBTTL	ASSIGN VECTORS TO DEVICES WITH PROGRAMMABLE VECTORS

;+
; PGMVEC - PROGRAMMABLE VECTOR ASSIGNMENTS
;
;	CALL PGMVEC
;
;	SEARCHES VECMAP AND ASSIGNS UNUSED VECTORS TO DEVICES
;	THAT CAN HAVE PROGRAMMABLE VECTORS. VECTBL UPDATED.
;-

PGMVEC:	TSTB	FLGGPK		;Is this a GPK?				;049
	BMI	75$		;Yes, nothing to do			;049
	MOV	#274/2,R1	;VECTBL HAS VECTOR/2, START AT VEC 274 (OCTAL)
	CALLX	DEVLUP		;LOOP THROUGH ALL DEVICES
50$:	BITB	#PS.PVC,PK.FLG(R5) ;IS THIS A PROGRAMMABLE VECTOR DEVICE?
	BEQ	70$		;NO.
	TST	(R4)		;DOES HE HAVE SOMETHING OUT THERE?
	BEQ	70$		;HE DON'T GET A VECTOR UNLESS HE'S GOT A CSR
	TSTB	VECTBL-CSRTBL(R4) ;DOES HE ALREADY HAVE A VECTOR SET?
	BNE	70$		;YES, THEN NO NEED TO FIND HIM ONE.
60$:	TST	(R1)+		;INCREMENT TO NEXT VECTOR/2
	MOV	R1,R0		;COPY THE VECTOR/2,
	ASR	R0		;  MAKE IT VECTOR/4
	CMP	R0,#1000/4	;ARE WE AT THE END? (INIT DON'T TRUST ANYONE)
	BGE	80$		;YES, TELL HIM WE'RE DISABLING HIS DEVICE.
	MOV	R4,-(SP)	;SAVE OUR TABLE POINTER
	CALLX	FIXREG		;CHANGE TO BIT AND BYTE OFFSETS
	MOV	R4,R0		;COPY THE BYTE OFFSET
	MOV	(SP)+,R4	;RESTORE OUR TABLE POINTER
	MOVB	BITBYT(R2),R2	;GET THE BIT MASK.
	BITB	R2,VECMAP(R0)	;IS THIS VECTOR IN USE?
	BNE	60$		;YES, TRY ANOTHER
	BISB	R2,VECMAP(R0)	;NO, LETS USE IT FOR THIS CONTROLLER
	MOVB	R1,VECTBL-CSRTBL(R4) ;AND SET UP HIS PROGRAMMABLE VECTOR.
70$:	CALL	@(SP)+		;ADVANCE TO NEXT CONTROLLER
	BNE	50$		;  IF ANY.
75$:	RETURN			;FINIS

80$:	MESSAG	<"Vector table full.">
	CALLX	TYPDEV		;TYPE THE DEVICE
	CALLX	MESSAGE,R5,DEVDIS ;AND SAY IT'S DISABLED
	CLR	(R4)		;DISABLE THE CONTROLLER
	JMP	50$		;AND LOOP TO DISABLE ANY OTHERS

.DSABL	LSB

GLOBAL	<VECTBL,CSRTBL,BITBYT,VECMAP>


.SBTTL	Set up all the GPK specific stuff

;+									;049+
; SETGPK - GPK-3xx specific setup
;
;	CALL SETGPK
;
;	Sets up interrupt controllers, clock interrupt rate,
;	and whatever else we need at this point
;-

SETGPK:	MOV	#ICTL0,R0	;Point to int control 0 setup table
	MOV	#I0CSR,R1	; and to its CSR
	CALL	SETINT		;Set it up
	MOV	#SESIMR+0,(R1)	;Disable level 0 clock interrupt (380)	
	MOV	#ICTL1,R0	;Point to int control 1 setup table	
	MOV	#I1CSR,R1	; and to controller 1 CSR
	CALL	SETINT		;Set it up
	MOV	#ICTL2,R0	;Ditto for controller 2			
	MOV	#I2CSR,R1
	CALL	SETINT		;Do that one too
	MOV	#DV1!^B<1010>,@#CLKCS0 ;Set clock rate = 64 Hz
	CALL	SETPRT		;Set up printer port			
	CALL	SETKBD		; and keyboard port			
	MOV	CSRTBL+PI.CSO,R0 ;Point to display controller CSR
	BEQ	40$		;Not there?
10$:	TST	PICSR(R0)	;Busy?					
	BPL	10$		;Yes					
.ASSUME	PIDONE LT 0							
	CALLX	CUROFF		;Cursor off (just in case)		
	CLR	PICSR(R0)	;Set 525 line mode, not interlaced, bit mode
	CLR	PIX(R0)		;Left margin
	MOV	#60.,PIY(R0)	;Initialize Y to be below DEC logo,
				; and multiple of line height from bottom
	MOV	#PIMPAT,PIP1C(R0) ;Opcode = move pattern		
	CLRB	PIEBO		;Assume no EBO				
	BIT	#PIBMAP,PICSR(R0) ;EBO present?				
	BNE	20$		;No (backwards!)			
	COMB	PIEBO		;Yes, record that			
	MOV	#<PIMPAT*400>+PIMPAT,PIP2C(R0) ;Set up planes 2/3 also	
20$:	MOV	#KBBASE,R0	;Point to keyboard port			
30$:	BIT	#PRTR,PRSTAT(R0) ;Keyboard output ready yet for data?	
	BEQ	30$		;No
	MOV	#375,PRDATA(R0)	;Yes, send a "self test request" code	
40$:	RETURN			;All done

GLOBAL	<PI.CSO,CSRTBL,PIEBO>						


.SBTTL	GPK interrupt controller setup

;+
; Set up interrupt controller
;
;	R0 ->	Setup table
;	R1 ->	CSR
;
;	R2,R3	scratch
;-

SETINT:	MOV	#IRESET,(R1)	;Reset the controller
	MOV	#LDM56S,(R1)	;Clear RPx and MM (disable all int)
	MOV	#WSLACR,(R1)	;Select for writing the ACR
	MOV	#377,I0DATA-I0CSR(R1) ; and set it all on (enabled)
	MOV	#8.,R2		;Count of response memory entries
10$:	MOV	#WSLMEM+8.,R3	;Command code to write memory
	SUB	R2,R3		;Set them in order 0..7
	MOV	R3,(R1)		;Set command code (write slot n)
	MOV	(R0)+,I0DATA-I0CSR(R1) ; and load the slot
	SOB	R2,10$		;Loop through the table
	MOV	#CLAIXR,(R1)	;Clear IMR (0 = enable) and IRR
	MOV	#LDM04,R2	;Command code to set mode bits 0-4
	BIS	(R0)+,R2	;Merge in rotating/fixed mode bit
	MOV	R2,(R1)		;Set mode bits 0-4
	MOV	#LDM56S,(R1)	;Finally set MM to enable interrupts
	RETURN

; The setup tables set up the interrupt controller response (vector)
; memory and the rotating/fixed priority flag.  The setup is exactly
; to that documented in the PRO technical manual.

ICTL0:	.WORD	234,200,204,210,214,220,224,230,0			
ICTL1:	.WORD	300,310,320,330,340,350,360,370,RPM			
ICTL2:	.WORD	304,314,324,334,344,354,364,374,RPM			

.SBTTL	GPK keyboard and printer port setup

;+
; Set up keyboard or printer port
;
;	Uses:	R0,R3
;
;-

.ENABL	LSB								

SETPRT:	MOV	#PRBASE,R3	;Point to printer CSR			
	MOV	#PRMOD2!^B1100,R0 ;Parameter word for 4800 baud printer	
	TSTB	NOTT0		;Using printer port for console?	
	BMI	10$		;;No, skip				
	TST	(R0)+		;Yes, use 9600 baud instead		
	BR	10$		; and go set up				

SETKBD:	MOV	#KBBASE,R3	;Point to keyboard CSR			
	MOV	#KBMOD2!^B1100,R0 ;Parameter word for 4800 baud kbd	
10$:	TST	PRCMD(R3)	;Access mode register 1 first		
	MOV	#PRSB1!PRCL8!2,PRMODE(R3) ;Set up mode 1		
	MOV	R0,PRMODE(R3)	;Set up mode 2				
	MOV	#PRRTS!PRRE!PRRXEN!PRDTR!PRTXEN,PRCMD(R3) ;Final touch	
	RETURN			;Done					

.DSABL	LSB								
									;049-

.SBTTL	APPLY USER'S 'SET ADDRESS' OPTIONS TO CSRTBL

;+
; APPSET - APPLY NON-STANDARD BUS ADDRESSES TO CSRTBL
;
;	CALL	APPSET
;
;	SET ADDRESSES ENTERED INTO CSRTBL
;	IF A SET ADDRESS CONFLICTS WITH SOMETHING ELSE IN THE TABLE,
;	THE OTHER DEVICE IS REMOVED
;-

.ENABL	LSB

APPSET:	REGSCR			;SAVE REGS
	CALLX	DEVLUP		;COROUTINE TO LOOP THROUGH ALL DEVICES
10$:	MOV	R4,R1		;COPY CSRTBL POINTER
	SUB	#CSRTBL,R1	;MAKE IT RELATIVE
	MOV	R1,R2		;SAVE OFFSET FOR LATER
	MOV	SETTBL(R1),R1	;GET CORRESPONDING SET OPTION
	BEQ	80$		;NOTHING HERE
	CLR	(R4)		;CLEAR OUT THE OLD CSR
	BIT	#1,R1		;DOES THE OVERRIDE INCLUDE DISABLE?
	BNE	80$		;YES, IT'S EASY
	CALLX	TRASEC		;C=1 IF TRAP TO 4
	TST	(R1)		;NO, IS THE NEW CSR UP THERE?
	CALL	@(SP)+		;RESTORE THE VECTOR @ 4
	BCS	90$		;OOPS, CAN'T FIND HIS DESIRE
	CMP	R2,#XD.CSO	;CSR IS OK. IS THIS THE XD MULTI-POINT DDCMP ?
	BNE	20$		;NO, GO CHECK FOR ILLEGAL OVERLAPS FROM CHANGE
	MOVB	#DMPSZ,PK.SIZ(R5);YES, ASSUME THIS IS A DMP AND
	MOVB	#DMPNU,PK.NUN(R5);	SET CSR SIZE & MAX UNITS CONTROLLED.
	MOV	R1,R2		;SET CSR ADDR IN R2 (R5 ALREADY -> XD PACKET)
	CALL	XDDIAG		;RUN THE XD DIAGNOSTICS TO DETERMINE TYPE.
	CMPB	#DMV,BSEL4(R2)	;IS THIS ACTUALLY A DMV?
	BNE	20$		;NO, WE ASSUMED CORRECT, (OR DEVICE IS SICK).
	MOVB	#DMVSZ,PK.SIZ(R5);RESET PACKET WITH THE CSR SIZE FOR A DMV
	MOVB	#DMVNU,PK.NUN(R5);RESET PACKET WITH THE MAX DMV UNITS CNTRLLED
20$:	MOV	#DEVTBL,R2	;START @ 1ST PACKET TO CHECK ILLEGAL OVERLAPS
30$:	MOV	(R2)+,-(SP)	;STACK NUMBER OF UNITS OF THIS TYPE
.ASSUME	PK.MXU EQ 0
	BIC	#^C<377>,(SP)	;Clear out the high byte
	MOV	(R2)+,R3	;R3 = CSRTBL OFFSET FOR DEVICE TYPE
.ASSUME	PK.CSO EQ PK.MXU+2
	ADD	#CSRTBL,R3	;R3 -> CSRTBL
40$:	MOV	(R3)+,R0	;NEXT CSR IN CSRTBL FOR CONFLICT CHECK
	BEQ	70$		;NONE IS EASY
	CLR	-(SP)		;WE NEED A 0 WORD FOR GETTING CSR SET SIZE
	CMP	R1,R0		;IS OVERRIDE START < TABLE'S CSR?
	BLO	60$		;YES
	MOVB	(R2),(SP)	;NO. SET LENGTH OF CHECKED CSR SET
	ADD	(SP)+,R0	;COMPUTE END OF CHECKED DEVICE
	CMP	R1,R0		;DOES NEW GUY ALSO END LATER?
	BHIS	70$		;YUP, IT'S OK
50$:	CLR	-2(R3)		;CONFLICT!! TURN OFF THE OLD CSR
	BR	70$		;AND TRY FOR MORE

60$:	MOVB	PK.SIZ(R5),(SP)	;SET SIZE OF USER'S DEVICE
	SUB	(SP)+,R0	;USER <= CHECKED.  CHECK USER+USSZ<=CHECKED
	CMP	R1,R0		;(OR USER <= CHECKED-USERSIZ)
	BHI	50$		;ERROR, FIX THE CONFLICT
70$:	DEC	(SP)		;CHECK ANY MORE OF THESE GUYS?
	BNE	40$		;YUP
	ADD	#PKTSIZ-4,R2	;ADVANCE TO NEXT PACKET
	CMP	(SP)+,(R2)	;DUMP STACK (= 0), CHECK FOR END OF LIST
	BNE	30$		;NO, ANOTHER DEVICE TO CHECK AGAINST
	MOV	R1,(R4)		;OK, NOW PUT NEW CSR IN OUR TABLE
80$:	CALLX	GETTTY		;WATCH THE TERMINAL AND THE CLOCK
	CALL	@(SP)+		;ADVANCE TO NEXT DEVICE
	BNE	10$		;  IF ANY
	RETURN

90$:	MESSAG	<"User-defined address for ">
	CALLX	TYPDEV		;TYPE DEVICE NAME
	MESSAG	<" not found">
	MESSAG	<" - device disabled."<200>>,DEVDIS
	BR	80$		;IT'S DISABLED

.DSABL	LSB

GLOBAL	<CSRTBL,SETTBL,XD.CSO,DMPSZ,DMPNU,DMVSZ,DMVNU>

.SBTTL	DISTINGUISH BETWEEN RH11'S AND RH70'S

;+
; CHKBAE - CHECK IF A BAE-TYPE DEVICE HAS A BAE REGISTER
;
;	CALL	CHKBAE
;
;	BAELST SET UP WITH LIST OF THOSE THAT DO
;-

.ENABL	LSB

CHKBAE:	MOV	#BAELST,R3	;HERE'S WHERE TO PUT THE RESULTS
	TSTB	FLGGPK		;Is this a GPK?				;049
	BMI	45$		;Yes, exit with null BAELST		;049
	CALLX	DEVLUP		;LOOP THROUGH ALL DEVICES
10$:	CLR	BAEYES		;CLEAR BAE FOUND FLAG
	BITB	PK.PRI(R5),#PS.BAE ;MIGHT THIS DEVICE HAVE BAE?
	BEQ	30$		;NOPE, TRY THE NEXT ONE
	MOV	(R4),R2		;YES, WE'LL WANT ITS CSR ADDRESS
	BEQ	30$		;NONE, SO SKIP THIS DEVICE
	MOV	#BAEOFF,R0	;LOOK UP ITS TYPE IN THE TABLE
20$:	MOV	(R0)+,R1	;GET A POSSIBLE OFFSET
	BEQ	50$		;END OF LIST -- SHOULDN'T HAPPEN
	CMP	(R0)+,PK.NAM(R5) ;IS IT FOR THIS DEVICE?
	BNE	20$		;NO, KEEP LOOKING
	ADD	R2,R1		;R1 -> POSSIBLE BAE REGISTER
	CALLX	TRASEC		;SET CARRY IF WE TRAP TO 4
	TST	(R1)		;IS THERE A REGISTER THERE?
	CALL	@(SP)+		;RESTORE TRAP HANDLER
	BCS	30$		;NO BAE REGISTER FOR THIS DEVICE
	INC	R2		;POINT TO HIGH BYTE OF CSR
	CLRB	(R2)		;CLEAR BUS ADDRESS <17:16>
	BITB	#3,(R2)		;BE SURE THEY'RE CLEARED
	BNE	30$		;WE DON'T UNDERSTAND
	BIT	#3,(R1)		;ARE THEY CLEAR IN THE BAE REGISTER?
	BNE	30$		;NO, IT'S NOT A BAE REGISTER
	MOVB	#3,(R2)		;SET BUS ADDRESS <17:16>
	MOVB	(R2),-(SP)	;BE SURE WE DID SET THEM
	BISB	#^C<3>,(SP)	;IF THEY WERE SET, (SP) = -1
	INCB	(SP)+		;IS IT?

GLOBAL	<BAELST,BAEOFF>

	BNE	30$		;CAN'T SET BA<17:16> IN CSR
	MOV	(R1),-(SP)	;SEE IF ALLEGED BAE HAS THOSE BITS SET
	BIS	#^C<3>,(SP)	;(SP) SHOULD BE -1
	INC	(SP)+		;IS IT?
	BNE	30$		;ALLEGED BAE DOESN'T RESPOND TO CSR
	CLR	(R1)		;WE DARE TO WRITE THE THING
	BITB	#3,(R2)		;ONE LAST CHECK ...
	BNE	30$		;CSR DOESN'T RESPOND TO BAE
	MOV	R1,(R3)+	;MAKE AN ENTRY IN THE LIST
	MOV	(R4),(R3)+	; (BAE,CSR)
	CMP	R3,#BAELSE	;OUT OF ROOM?
	BHIS	60$		;YES, COMPLAIN
	COM	BAEYES		;INDICATE THAT WE FOUND A BAE REGISTER
30$:	TST	(R4)		;WAS THERE A DEVICE HERE?
	BEQ	40$		;NO, THEN IT NEEDS NO UMR'S
	TST	BAEYES		;DOES IT HAVE A BAE REGISTER?
	BNE	40$		;YES, THEN IT NEEDS NO UMR'S
	BITB	#PS.UWN,PK.PRI(R5)	;DOES THIS DEVICE NEED UMR'S?	;025
	BEQ	40$		;NOPE
	MOVB	PK.PRI(R5),R0	;FETCH THE PRIORITY BYTE		;025
	BIC	#^C7,R0		;AND STRIP OFF THE NUMBER OF WINDOWS NEEDED
	INC	R0		;MAKE THE REAL NUMBER NEEDED
	CMP	R0,MAXWIN	;IS IT MORE THAN THE CURRENT GREEDIEST?
	BLE	40$		;NOPE
	MOV	R0,MAXWIN	;YUP, MAKE IT THE NEW GREEDIEST
40$:	CALL	@(SP)+		;CHECK ANOTHER DEVICE?
	BNE	10$		;YES, LOOP
	CLR	(R3)+		;NO, MARK END OF LIST
45$:	MOV	R3,BAEPTR	;SAVE THE POINTER			;049
	RETURN

50$:	ERF	<"INIT bug - unknown BAE device.">

60$:	ERF	<"Too many BAE devices.">

.DSABL	LSB

	TMPORG	ONECTL

BAEYES:	.WORD	0

	UNORG

GLOBAL	<BAELSE,MAXWIN,BAEPTR>

.SBTTL	CHECK A DEVICE FOR VECTORING

;+
; VECCHK - MAKE A UNIT INTERRUPT TO FIND ITS VECTOR
;
;	R5 -> DEVICE PACKET IN DEVTBL
;	R4 -> ONE OF THE CSR'S FOR THIS DEVICE IN CSRTBL
;
;	CALL	VECCHK
;
;	VECTBL LOADED WITH ADDRESS TO WHICH DEVICE INTERRUPTED
;	R1 ALSO HAS VECTOR
;	BOTH ARE CLEARED IF NO INTERRUPT
;-

.ENABL	LSB

VECCHK:	MOV	@#I.TKS,R2	;R2 -> TTY CSR
	BEQ	20$		;SKIP IF NONE
	TSTB	NOTT0		;Missing console on the GPK?		;049
	BMI	20$		;Yes, so don't wait for one		;049
	MOVB	#-5,DSS$DV+1	;TIME OUT AFTER 5 SECONDS
10$:	TSTB	4(R2)		;WAIT FOR OUTPUT SIDE TO QUIET DOWN
	BMI	20$		;IT DID -- GET ON WITH THE JOB
	CALLX	GETCLK		;WATCH THE CLOCK
	TST	DSS$DV		;TIMEOUT?
	BMI	10$		;NO -- KEEP WAITING
20$:    CLR     POKFLG          ;clear for no error condition              ;050
        CLRB    VECTBL-CSRTBL(R4) ;ASSUME THERE IS NO VECTOR               ;050
	MOV	(R4),R2		;R2 -> THIS GUY'S CSR
        BEQ     1500$           ;NO CSR, IT COULDN'T HAVE A VECTOR         ;050
	MOVB	PK.OFF(R5),R1	;GET OFFSET TO MOST USED REGISTER
	ADD	R1,R2		;R2 -> MOST COMMON CONTROL REG
	CLR	R0		;PRESET R0 TO 0 (NO VECTOR)
	;CLC
	BISB	VECTBL+1-CSRTBL(R4),R0 ;GET SET OPTION VECTOR IF ANY
        BNE     1850$           ;HE SET ONE, DON'T EVEN TRY TO POKE        ;050

; DEVICE EXISTS BUT NO HARDWR VECTOR IS SET, SO WE POKE IT

	CALL	DOPOKE		;Call the poke routine for this device
        BCS     1600$           ;SKIP OUT IF HE COULDN'T POKE IT           ;050
	TST	R0		;WAS THERE A HARDWARE ERROR IN THE POKER
	BMI	100$		;OMIGOSH, WE HAVE A SICK DEVICE
; THE POKER DID NOT HAVE A PRESET IDEA OF THE VECTOR.  OLD R5
; IS ON STACK.  POKER RETURNED WITH:  CALL @(SP)+,R5.

	MOVB	#-6,R1		;Wait for up to 5 seconds		;038
	CMP	(R5),#RDY8	;MSCP class disk controller?		;038
	BEQ	22$		;Yes.					;038
	MOV	(SP),R0		;Get original R5 in R0			;038
	CMP	PK.NAM(R0),#"XE	;UNA device?				;038
	BNE	25$		;5 seconds should do it			;038
	MOVB	#-1,R1		;UNAs will get up to 10 seconds		;038
22$:	SUB	#10.,R1		;MSCP class devices get up to 15 secs	;038
25$:	MOVB	R1,DSS$DV+1	;Store timeout value			;038
	MOV	(R5)+,R1	;GET ADDRESS OF READY-TESTER		;038
30$:	CALLX	GETTTY		;KEEP CLOCK RUNNING/process ^ts		;019
	CLR	R0		;We and GETCLK trash R0			;039
	TST	DSS$DV		;TIMEOUT?
	;CLC
	BPL	40$		;YES, SAY IT'S READY
	CALL	(R1)		;NO, SEE IF IT'S READY
	BCC	30$		;NOT READY, KEEP WAITING
; DEVICE IS READY, SO SEE WHERE THE TRAP COMES

40$:	MOV	#260$,TRPSET	;INTERCEPT TRAPS OURSELVES
	MOV	#PR7&340,R1	;R1 = PRIORITY TO WAIT AT
50$:	MOVB	R1,@#PS		;SET UP PRIORITY TO DAWDLE AT
	MOV	#20,70$		;WAIT A SHORT TIME
60$:	DEC	(PC)+		;DELAY A WHILE
70$:	 .WORD	0
	BNE	60$		;GO IF STILL WAITING
	SUB	#PR1&340,R1	;COUNT R1 DOWN A PRIORITY LEVEL
	CMPB	R1,#PR3&340	;BELOW PR3 YET?
	BHIS	50$		;NO, TRY WAITING AT LOWER PRIORITY
80$:

GLOBAL	<DSS$DV>
; THE DEVICE DID NOT TRAP.  RAISE PRIORITY, QUIESCE IT, THEN GIVE ERROR

	SPL	7		;LOCK OUT EVERYBODY
	SEC			;SET CARRY TO INDICATE NO VECTOR

; FIX TRAP VECTOR INTERCEPT, CALL BACK POKER TO QUIESCE THE DEVICE
; C=0 => DEVICE INTERRUPTED, R0 = VECTOR ADDRESS

90$:	MOV	#UNXTRP,TRPSET	;RESTORE THE UNEXPECTED TRAP TRAP
	CALL	(R5)		;AND CALL THE POKER TO QUIESCE THE UNIT
	MOV	(SP)+,R5	;RESTORE PACKET POINTER
	TST	R0		;WAS THERE A VECTOR?
	BEQ	110$		;NO, TELL HIM IT DOESN'T INTERRUPT

; THE DEVICE DID INTERRUPT.  CHECK OUT THE PRIORITY

	MOVB	PK.PRI(R5),-(SP) ;GET THE NEEDED PRIORITY
	BIC	#^C<PR7&340>,(SP) ;ISOLATE PRIORITY BITS
	BIS	#PR4&340,(SP)	;MAKE PRIORITY 4-7
	CMP	R1,(SP)+	;IS IT INTERRUPTING AT EXPECTED OR LOWER?
	BLO	170$		;YES, WE CAN USE IT
	MESSAGE	<"Priority of "> ;NO, GIVE AN ERROR
	CALLX	TYPDVN		;TYPE THE DEVICE
	MESSAGE	<" interrupt (PR">
	MOV	R1,R0		;COPY THE ACTUAL PRIORITY
	ASH	#-5,R0		;SHIFT TO LOW BITS
	INC	R0		;MAKE IT THE DEVICE PRIORITY
	CALLX	DECZER		;TYPE IT
	MESSAGE	<") is too high">
	BR	140$		;DISABLE IT

100$:	CLR	R0		;A SICK DEVICE, INDICATE NO VECTOR
	BR	80$		;AND TURN IT OFF

1500$:  RETURN                  ;exit from NO CSR condition                ;050

1600$:  BR      160$            ;linkage relay                             ;050

1850$:  BR      185$            ;linkage relay                             ;050

GLOBAL	<I.TKS,VECTBL,CSRTBL,TRPSET,UNXTRP,NOTT0,HALTER>		;049

110$:   ;  Come here if did not interrupt or if micro diagnostic fault     ;050

        CALLX   TYPDEV                                                     ;050
        ;  check if DHV/DHU fault                                          ;050
        BIT     #XVHERR,POKFLG  ;error code here from XVDIAG if fault      ;050
        BEQ     115$            ;NO, not DHV fault, continue reasoning     ;050
        CALLX   MESSAG,R5,MDIAGF ;report micro-diag fault message          ;050
        CALLX   MESSAG,R5,MDIAGC ;report code text                         ;050
        MOV     POKFLG,R0       ;get error code to report                  ;050
        CALLX   OCTWRD          ;report error code                         ;050
        CLR     R0              ;discard error  , indicate no vector       ;050
        BR      140$            ;now go disable unit                       ;050

        ;CHECK FOR DMP, DMV, DMR DIAGNOSTICS FAILURE                       ;050
115$:   BIT     #XDUDCK!XMUDCK,POKFLG   ;DDCMP FAIL ITS INTERNAL MICRO DIAGS? ;050
	.ASSUME XMUDCK EQ KJUDCK	;THE KXJ SHARES THE SAME BIT	;062
	BEQ	130$		;NO, SO REASON FOR FAIL IS NO INTERRUPT
	BIT	#XDUPNC,POKFLG	;WAS THE DEVICE PACKET COMPATABLE?
	BEQ	120$		;YES SO REALLY A MICRO-DIAG FAILURE
	MESSAG	<" CSR must be declared with HARDWR, CSR sub-option">
	BR	140$		;SAY IT'S DISABLED

120$:	MESSAG	<" internal micro-diagnostic failure">,MDIAGF
	BR	140$		;SAY IT'S DISABLED

130$:	MESSAG	<" does not interrupt">
140$:	CALLX	MESSAG,R5,DEVDIS ;" - DEVICE DISABLED"<200>
	CLR	POKFLG		;SAY THIS ONE'S DONE NOW
	CMP	R4,#CSRTBL+TT.CSO ;IS IT THE CONSOLE?
	BEQ	210$		;DON'T DISABLE THE CONSOLE TERMINAL
	CLR	(R4)		;ELSE DISABLE THE DEVICE ENTIRELY
150$:	RETURN
; COME HERE IF THE DEVICE CANNOT BE POKED
; R0=0 => IT HAS NO VECTOR (KG11).  ELSE R0=DEFAULT VECTOR FROM POKER

160$:	TST	R0		;COULDN'T POKE.  DOES IT HAVE A VECTOR?
	BEQ	210$		;NO (E.G. KG11)				;049
170$:	ASR	R0		;HALVE IT (VECTBL HAS VECTOR/2)
180$:	BITB	#PS.PVC,PK.FLG(R5) ;IT TRAPPED. IS HIS VECTOR PROGRAMMABLE?
	BNE	210$		;YES, DON'T UPDATE THE BITMAP OR VECTBL
185$:	MOV	R0,R1		;NO. CHECK FOR DUPLICATE VECTOR
	ASR	R0		;SHIFT
	MOV	R4,-(SP)	;SAVE R4 FOR A MOMENT
	CALLX	FIXREG		;CHANGE TO BIT AND BYTE OFFSETS
	MOV	R4,R0		;COPY BYTE OFFSET
	MOV	(SP)+,R4	;AND RESTORE R4
	MOVB	BITBYT(R2),R2	;GET THE BIT MASK
	BITB	#PS.2VC,PK.FLG(R5) ;ARE THERE 2 VECTORS?
	BEQ	190$		;NO
	MOV	R2,-(SP)	;YES, MAKE A COPY OF R2
	ASL	R2		;SHIFT BIT UP
	BIS	(SP)+,R2	;AND USE A DOUBLE BIT MASK
190$:	CMP	PK.NAM(R5),#"XN	;IS THIS A DN11?
	BEQ	220$		;THIS ICKY DEVICE HAS 4 UNITS VECTOR TO 1 LOCATION
	BITB	R2,VECMAP(R0)	;VECTOR IN USE?
	BNE	250$		;YUP, THAT'S ICKY
200$:	BISB	R2,VECMAP(R0)	;NO, USE IT UP NOW
	MOVB	R1,VECTBL-CSRTBL(R4) ;AND SET UP THE VECTOR
210$:	RETURN

220$:	MOV	(R4),R3		;FETCH THE CSR FOR THIS DN11
	BIC	#7,R3		;POINT TO THE FIRST DN11 ON THIS BACKPLANE
	CMP	R3,DNCSR	;HAVE WE FOUND ONE ALREADY?
	BNE	230$		;NO, THIS IS THE FIRST FOR THIS BACKPLANE
	CMP	R1,DNVEC	;YES, DOES IT INTERRUPT TO WHERE THE OTHERS DID?
	BNE	250$		;NO, GIVE ERROR
	BR	240$		;DON'T CHECK TO SEE IF IT IS IN USE

230$:	BITB	R2,VECMAP(R0)	;IS THIS VECTOR ALREADY IN USE?
	BNE	250$		;YUP, BOY IS THIS ICKY
240$:	MOV	R3,DNCSR	;SET THE CSR FOR THIS BACKPLANE
	MOV	R1,DNVEC	;SET THE VECTOR FOR THIS BACKPLANE
	BR	200$		;SET THE VECTOR IN THE VECTOR MAP
250$:	MESSAG	<"Vector for ">
	CALLX	TYPDEV
	TYPE2	<" (>
	MOV	R1,R0		;RESTORE THE VECTOR
	ASL	R0		;DOUBLE IT FOR PRINTING
	CALLX	OCT3DG		;TYPE VECTOR AS 4-DIGIT NUMBER
	MESSAG	<") already in use">
	BR	140$		;GO DISABLE THE DEVICE

260$:	CMP	(SP),#50$	;WE INTERCEPTED A TRAP. DO WE WANT IT?
	BLO	270$		;NO
	CMP	#80$,(SP)	;MAYBE...
	BLO	270$		;NOPE
	MOV	(SP)+,(SP)+	;YES, DUMP THE VECTOR (WE ARE NOW AT PR7)
	BR	280$		;GO STOP THE DEVICE (C=0 MEANS IT VECTORED)

270$:	JMP	UNXTRP		;WUZZA TRAP?
280$:	JMP	90$		;QUIESCE THE DEVICE.

.DSABL	LSB

	I.MESS
	.EVEN

DNCSR:	.WORD	0
DNVEC:	.WORD	0
POKFLG:	.WORD	0		;SPECIAL PURPOSE FLAGS FOR THE POKE ROUTINE



        .BSECT HIGH                     ;POKFLG: BIT DEFINITIONS           ;050
XDUDCK:	.BLKB	.		;DMP/DMV MICRO DIAGNOSTICS CHECK
XDUPNC:	.BLKB	.		;DMP/DMV NON-COMPATIBLE DEVICE PACKET
KJUDCK:				;KXJ micro Diag Check failure		;062
XMUDCK: .BLKB   .+64000         ;DMR     MICRO DIAGNOSTICS CHECK           ;050
XVHERR: .BLKB .                 ;DHV/DHU MICRO DIAGNOSTIC FAULT FLAG       ;050
                                ; (ERR CODE IN BITS 0:7)                   ;050
        .ASSUME XVHERR EQ 70000                                            ;050

	UNORG

GLOBAL	<CSRTBL,TT.CSO,VECMAP,VECTBL,BITBYT>

.SBTTL	Find a poke routine for a given device

;+
;	R5 ->	Packet
;
;	CALL	DOPOKE
;
;-

DOPOKE:	MOV	R4,-(SP)	;Save a working register
	MOV	#POKTBL,R4	;Point to the poke routine table
	TSTB	FLGGPK		;Is this a Gpk?				;049
	BPL	10$		;No, use normal poke table		;049
	MOV	#PKPTBL,R4	;Yes, use Gpk-specific poke table	;049
10$:	TST	(R4)+		;Skip poke routine pointer; end of table?
	BEQ	20$		;Yes, that's a bug
	CMP	(R4)+,R5	;Routine for this packet?
	BNE	10$		;No
	MOV	-4(R4),R4	;Yes, get its address
	RETURN	R4		;Restore R4 and jump to it

20$:	ERF	<"Poke table error">

.MACRO	POKE	DEVS,GPK						;049
.IRP	NM,<DEVS>
.IF	B	<GPK>							;049
	 .WORD	NM'POKE,NM'.PKT
.IFF									;049
	 .WORD	NM'POKP,NM'.PKT						;049
.ENDC									;049
	GLOBAL	<NM'.PKT>
.ENDR
.ENDM	POKE

	TMPORG	ONETBL

POKTBL:	POKE	TT
	POKE	<RV,RF,RS,RK,RL,RM,RP,RB,RR,RU>
	POKE	<TC,TS,TM,TU,MU>					;024
	POKE	<PR,PP,LP,CR,CD,RX>
	POKE	<KL,DL,DE,DC,DM,DJ,DH,DZ,VH>
	POKE	<DP,KG,DU,D1,XK>
	POKE	<XM,XA,XD,XE,XH>					;067
	POKE	<XN,XV,DD,BS,KJ>					;069
	.WORD	0		;Terminator

PKPTBL:	POKE	TT,GPK							;049
	POKE	<RW,RZ>,GPK						;049
	POKE	<LK,PI,XT,PC>,GPK					;049
	.WORD	0		;Terminator				;049

	UNORG


.SBTTL	ROUTINES FOR EACH DEVICE TO POKE AND MAKE INTERRUPT

;+
; WHEN THE POKE ROUTINE IS CALLED:
;	R0 = 0
;	R2 -> CSR AT MAJOR REGISTER
;	R4 -> CSRTBL
;	R5 -> DEVICE PACKET
;
;	CALL	POKE ROUTINE
;
; THE POKE ROUTINE HAS SEVERAL OPTIONS:
; 1)	IF IT CAN POKE THE DEVICE, IT SETS IT TO INTERRUPT.
;	IT THEN ENTERS THE DELAY LOOP BY A COROUTINE CALL, PASSING THE
;		ADDRESS OF A ROUTINE WHICH TESTS IF THE DEVICE IS READY:
;		CALL	@(SP)+,R5,<RDYTST>
;	THE CALLER THEN REPEATEDLY CALLS THE READY-TESTER UNTIL EITHER
;		IT RETURNS WITH THE C BIT SET TO INDICATE THE DEVICE IS
;		READY, OR A 5 SECOND TIMEOUT EXPIRES.
;	IT THEN CALLS THE POKE ROUTINE BACK WITH ANOTHER COROUTINE CALL.
;	AT THIS ENTRY,
;		C=0 IMPLIES THAT THE DEVICE ACTUALLY INTERRUPTED
;			R0 = VECTOR ADDRESS
;			IF THE DEVICE INTERRUPTED TO ITS SECOND VECTOR,
;			THE POKE ROUTINE MUST AT THIS POINT FIX R0
;		C=1 IMPLIES THAT THE DEVICE DID NOT INTERRUPT
;			NO REGISTERS MAY BE MODIFIED
;		R2 IS STILL THE CSR POINTER
;		THE POKE ROUTINE MUST ATTEMPT TO QUIESCE THE DEVICE
;	RETURN TO THE MAIN CODE WITH
;		RTS	PC
;	R0 = VECTOR ADDRESS OF LOWEST VECTOR OR 0
;
; 2)	IF IT CANNOT POKE THE DEVICE, IT MAY DECLARE A DEFAULT
;	VECTOR ADDRESS BY LOADING THAT ADDRESS IN R0 AND SETTING C.
;	IT RETURNS TO THE MAIN CODE WITH
;		RTS	PC
;
; 3)	IF THE DEVICE HAS NO VECTOR (E.G. KG11), IT RETURNS TO THE
;	MAIN CODE WITH R0 STILL 0 AND C = 1 TO INDICATE THAT NO
;	WAITING IS TO BE DONE.
;
; 4)	IF THE DEVICE IS FOUND NOT TO WORK WHEN SETTING IT UP FOR THE POKE
;	THEN IT RETURNS TO THE MAIN CODE WITH C = 0 AND R0 = -1, WITH
;		RTS	PC
;	R5 MUST STILL POINT TO A ROUTINE TO QUIESCE THE DEVICE.
;-

.ENABL	LSB

DCPOKE:	MOV	#104,4(R2)	;TURN ON INTERRUPT ENABLE, MAINT MODE
	CLR	RDYBIT		;LEAVE IT 0 WHEN WE ARE DONE.		;040
	BR	10$		;ENTER TERMINAL TESTER
TTPOKE:				;CONSOLE TERMINAL
KLPOKE:
DDPOKE:
DEPOKE:
DLPOKE:	MOV	4(R2),R0	;SAVE THE SPEED (IN CASE OF MXV/DLV)	;040
	BIC	#^C<174072>,R0	;CLEAR ALL BUT SPEED BITS		;040
	MOV	R0,RDYBIT	;SAVE IT TO RESTORE LATER		;040
	BIS	#100,R0		;SET IE					;040	
	MOV	R0,4(R2)	;TURN ON INTERRUPT ENABLE IN XMITTER	;040
10$:	MOVB	#377,6(R2)	;SEND A RUBOUT OUT
	CALL	@(SP)+,R5,RDY4	;DELAY FOR AN INTERRUPT
	BCS	20$		;SKIP IF NO INTERRUPT
	CMP	-(R0),-(R0)	;MOVE TO RECEIVER VECTOR
20$:	MOV	RDYBIT,4(R2)	;NO MORE INTERRUPT ENABLE		;040
	BR	80$		;GO REMOVE DATA, STOP DEVICE, RETURN

XMPOKE:	CALL	XMDIAG		;RUN THE MICRO-DIAG. IS DEVICE IS A DMR
	TST	R0		;ARE THERE ANY ERRORS FROM THE DIAGNOSTICS?
	BMI	90$		;YES, GO RETURN WITH ERROR.
	MOV	#MRUN,(R2)	;NO. (OR DMC) SO SET "RUN" AGAIN
	BIS	#XM.IEI!XM.RQI!3,(R2) ;POKE IT BY SPECIFYING BASE ADDRESS
	.ASSUME	BSEL0 EQ 0						;046
	CALL	@(SP)+,R5,RDY2	;WAIT
	MOV	R0,-(SP)	;SAVE THE VECTOR			;040
	MOV	DEV.UN,R0	;SET UP CORRECT CONTROLLER NUMBER	;040
	ASL	R0		;*2 FOR WORD ADDRESS OFFSET		;040
	BIT	BITWRD(R0),XM.TYP ;DMC OR DMR??				;040
	BEQ	70$		; WELL, NOTHING MORE FOR DMC'S		;040
	MOV	#SATBUF,BSEL4(R2) ;USE SATBUF FOR THE BASE TABLE SINCE	;046
	MOV	#0,BSEL6(R2)	; IT ISN'T NEED ANYMORE AFTER HERE	;046
	MOVB	#3,(R2)		;DO THE BASEI & CLEAR RQI		;046
	.ASSUME	BSEL0 EQ 0						;046
	MOV	R4,-(SP)	;GET A WORKING REGISTER			;046
	MOV	#XM.RDI,R4	;BIT TO WAIT FOR TO CLEAR		;046
	CALL	110$		;WAIT TILL THE PORT GOT THE COMMAND	;046
	BCC	50$		;FAILED, RESTORE R4, AND EXIT		;046
	CALL	100$		;NOW REQUEST THE PORT			;046
50$:	MOV	(SP)+,R4	;RESTORE THE REGISTER			;046
	BCC	70$		;DIDN'T WORK				;046
	MOVB	BSEL7(R2),TYPTBL+XM.CSO+1(R0) ;SAVE MODEM STATUS	;040
70$:	MOV	(SP)+,R0	;RESTORE THE VECTOR			;040
80$:	MOV	#MCLR,(R2)	;POWER CLEAR IT AGAIN
	RETURN

90$:	;CLC			;CLEAR THE CARRY (XMDIAG RETURNS R0 AS -1)
	CALL	@(SP)+,R5	;CALL MY CALLER BACK (RTN @+2 TO QUIESCE XM:)
	BR	80$		;RESET THE DMR

100$:	MOVB	#XM.RQI,(R2)	;REQUEST THE PORT			;046
	.ASSUME	BSEL0 EQ 0						;046
	CLR	R4		;START LOOKING FOR THE BIT TO SET	;046
110$:	MOVB	#-3.,DSS$DV+1	;get ready to time 3 seconds		;046
120$:	CALLX	GETTTY							;046
	ASH	#10.,R0		;WASTE SOME TIME			;046
	ASH	#-10.,R0	;BUT GET THE SAME ANSWER		;046
	CLRB	BSEL2(R2)	;CLEAR 'READY OUT' JUST IN CASE		;046
	MOV	R4,-(SP)						;046
	ADD	(R2),(SP)	; SEE IF THE BIT CHANGES		;046
	.ASSUME	BSEL0 EQ 0						;046
	TSTB	(SP)+		;IS BIT 7 SET/CLEAR			;046
	.ASSUME	XM.RDI EQ 200						;046
	BMI	130$		;WE GOT THE PORT, CONTINUE		;046
	TSTB	DSS$DV+1	;TIME UP YET?				;046
	BMI	120$		;NO, SO TRY SOME MORE			;046
	TST	(PC)+		;CLC RETURN WITH ERROR			;046
130$:	SEC			;RETURN ALL OK				;046
	RETURN			;ALL DONE				;046

.DSABL	LSB

GLOBAL	<SATBUF,DSS$DV,DEV.UN,BITWRD,XM.TYP,TYPTBL,XM.CSO>		;046


.ENABL	LSB
;
;	The following is the poke routine for the DMP/DMV.
;

XDPOKE:	CALL	XDDIAG		;RUN THE DMP/DMV INTERNAL MICRO DIAGNOSTICS
	TST	R0		;ARE THERE ANY ERRORS FROM THE DIAGNOSTICS?
	BMI	60$		;YES, GO RETURN WITH THE ERRORS.
	BIS	#XD.RQI!XD.IEI,(R2);REQUEST PORT & INTERRUPT WHEN RDYI IS SET.
	CLC			;SAY POKE OK AND WE'RE WAITING FOR INTERRUPT
	CALL	@(SP)+,R5,RDY7	;WAIT FOR IT TO INTERRUPT
50$:	MOV	#MCLR,(R2)	;LEAVE DMV/DMP IN KNOW STATE
	RETURN			;AND WE ARE DONE

60$:	;CLC			;CLEAR THE CARRY (XDDIAG RETURNS R0 AS -1)
	CALL	@(SP)+,R5	;CALL MY CALLER BACK (RTN @+2 TO QUIESCE XD:)
	BR	50$		;RESET THE DMP/DMV

DPPOKE:	CLR	(R2)		;ENSURE ALL OFF
	MOV	#300,(R2)	;SET READY AND I.E.
	BR	70$		;GO CALL BACK, THEN TURN OFF

XAPOKE:	MOV	#0,(R2)		;Clear without reading it		;069
	MOV	DEV.UN,-(SP)	;GET CURRENT XA UNIT #			;069
	ASL	(SP)		; CONTROLLER # * 2			;069
	ADD	#TYPTBL+XA.CSO,(SP) ;POINT TO TYPE TABLE FOR THIS XA	;069
	MOV	#100000,(R2)	;Try to read the EIR Register		;069
	MOV	(R2),@(SP)	; into the type table word		;069
	MOV	#-1,-4(R2)	;Set a word count of 1			;069
	MOV	#176000,-2(R2)	;To/from NXM				;069
	TSTB	FLGQBU		;Are we a DRV11?			;069
	BMI	65$		; NO, we're a DR11?			;069
	MOV	#77,-2(R2)	; NXM is very high on the Q-bus		;069
	MOV	#2,@(SP)	;Set the DRV11 flag!			;069
	;DR11s will interrupt either with or without a cable.  The DRV11s
	; when in DR<->DRV mode, require either a loopback cable, or
	; another system to be cabled up before they will interrupt.
65$:	MOV	#561,(R2)	;Do the NXM DMA				;069
	TST	(SP)+		;Trash the TYPTBL pointer		;069
	BR	70$		; and wait for the DMA to fail		;069

LPPOKE:	CLR	(R2)		;ENSURE I.E. IS OFF
	MOV	#100,(R2)	;ALLOW IT TO INTERRUPT (READY OR ERROR)	;069
70$:	CALL	@(SP)+,R5,RDY1	;RETURN TO GET THE VECTOR
	BR	80$		;TURN OFF I.E.

PRPOKE:
TCPOKE:				;DECTAPE HAPPENS TO BE THE SAME
PPPOKE:	CLR	(R2)		;TURN OFF I.E.
	MOV	#101,(R2)	;SET I.E. AND GO
	CALL	@(SP)+,R5,RDY1	;WAIT
	TST	2(R2)		;REMOVE THE DATA (NOP IF DECTAPE)
80$:	CLR	(R2)		;STOP IT
	RETURN

DMPOKE:	CLR	(R2)		;DM11BB
	MOV	#300,(R2)	;SET IE & DONE TO FORCE INTERRUPT
	CALL	@(SP)+,R5,RDY2
	MOV	#006000,(R2)	;CLEAR SCAN/CLEAR MUX
	RETURN

RXPOKE:	MOV	#100,(R2)	;ENABLE INTERRUPTS (READY FROM RESET)
	CALL	@(SP)+,R5,RDY5	;WAIT FOR IT TO BE READY?
	BR	80$		;ALL THERE IS TO IT

GLOBAL	<TYPTBL,XA.CSO,FLGQBU>


TPR1 = 2								;062
TPR2 = 4								;062
TPR3 = 6								;062

KJPOKE:	CLR	POKFLG		;CLEAR ANY ERROR FLAGS FOR THIS UNIT	;062
	MOV	#40000,(R2)	;FORCE A HARD INIT			;062
	CALL	200$		;WAIT TILL ITS DONE WITH THE INIT	;062
	BCS	140$		; IT NEVER DID THE COMMAND		;062
	CMP	TPR1(R2),#4	;IS IT WAITING, WITH FIRMWARE ENABLE?	;062
	BNE	130$		; NO, IT'S CONFIGURED WRONG		;062
	CMP	TPR3(R2),#5*20	;IS THE MODE SET CORRECTLY		;062
	BEQ	120$		;YES, SO CONTINUE			;062
	MOV	#5,TPR3(R2)	;NO, SET IT FOR MODE 5			;062
	MOV	#4,(R2)		; AND MAKE IT DO IT			;062
	CALL	200$		;NOW WAIT TILL ITS DONE			;062
	BCS	140$		; UNLESS IT FAILS FIRST			;062
	CMP	TPR1(R2),#4	;IS IT WAITING, WITH FIRMWARE ENABLE?	;062
	BNE	130$		; NO, IT'S CONFIGURED WRONG		;062
120$:	MOV	#2000,(R2)	;ASK IT WHO IT IS?			;062
	CALL	200$		;AND WAIT				;062
	BCS	140$		; IT DIDN'T ANSWER			;062
	CMP	TPR2(R2),#1	;IS IT A KXJ11-CA?			;062
	BNE	140$		;NO, MAYBE ITS A KXT, OR SOMETHING ELSE	;062
	SEC			;poking is all done			;062
	BR	150$		;AND EXIT				;062

130$:	BIT	#154040,TPR1(R2) ;ANY ERRORS SET?			;062
	BEQ	140$		;NO, ITS NOT A FAILURE			;062
	BIS	#KJUDCK,POKFLG	;CALL IT A U-DIAG FAILURE		;062
140$:	MOV	#-1,R0		;SIGNAL THAT ITS BROKEN			;062
	CLC			;MAKE SURE THEY KNOW WE POKED IT	;062
	CALL	@(SP)+,R5	;CALL BACK OUR CALLER			;062
150$:	MOV	#40000,(R2)	;FORCE A HARD INIT			;062
	RETURN			; AND NOW WE'RE DONE			;062

;	Spin on ready for upto 10. seconds.
;
;	On return
;
;	C = Clear	Its ready to go on.
;	C = Set		Its taking to long (Error).
;

200$:	MOVB	#-10.,DSS$DV+1	;SET THE TIMEOUT VALUE			;062
210$:	CALLX	GETTTY		;WATCH CLOCK AND TTY			;062
	TST	(R2)		;IS IT READY YET?			;062
	BNE	220$		; NO, SO KEEP LOOPING			;062
	CMPB	TPR1(R2),#2	;IS IT REALLY READY?			;062
	BHIS	230$		; NO, SO STILL KEEP TRYING		;062
				; BHIS = BCC				;062
220$:	TSTB	DSS$DV+1	;TIMEOUT?				;062
	BMI	210$		; NO, NOT YET				;062
	SEC			;SET CARRY FOR ERROR FLAG		;062
230$:	RETURN			;ALL DONE				;062

.DSABL	LSB

.ENABL LSB

XEPOKE:	MOV	#40,(R2)	;RESET THE DEUNA FIRST			;011
	MOV	#100,(R2)	;NOW INTERRUPT ENABLE IT		;011
	CALL	@(SP)+,R5,RDY2	;WAIT					;011
	MOV	#177400,(R2)	;CLEAR ERRORS AND DISABLE INTERRUPTS	;011
	RETURN			;ALL DONE NOW				;011

	TMPORG	ONECTL
XHXBUF:	.BLKB	6		;Destination address			;038
	.BLKB	6		;Source address				;038
	.WORD	0		;Packet type				;038
	.ASCIZ	"XH Test"	;Data					;038

	.EVEN
XHRBUF:	.BLKB	64.		;Receive area				;038

;Buffer area for QNA commands

QNA.BD:	.BLKW	2		;22-bit bus address			;038

XH.RDS:				;ROM RCV descriptor address		;038
XHXBDL:				;Poke code Xmit buffer			;038
	.BLKW0	4							;038
XH.RS1:				;ROM status word 1			;038
	.BLKW0	2							;038
XH.RS2:				;ROM status word 2			;038
	.BLKW0	6							;038
XHRBDL:				;Poke code Rcv buffer			;038
XH.RS3:				;ROM status word 3			;038
	.BLKW0	12.							;038
	UNORG								;038

XHPOKE:	CLR	QNA.BD		;MSB of INIONE is zero			;038
	MOV	#XHXBUF,QNA.BD+2	;LSB of Xmit buffer		;038
	CALL	QNABDL,R5,<XHXBDL,-<64./2>>	;Set up transmit buffer	;038
	BIS	#020000,XHXBDL+2	;End of Xmit buffer		;038
	MOV	#XHRBUF,QNA.BD+2	;LSB of Rcv buffer		;038
	CALL	QNABDL,R5,<XHRBDL,-<64./2>>	;Set up receive buffer	;038
	MOV	#2,(R2)		;Reset the QNA				;038
	CLR	(R2)		;Stop resetting				;038
	MOV	#1101,(R2)	;IE, int. extended loopback, rcv enable	;038
	MOV	#774,-(R2)	;Set vector to 774			;038
	SUB	#10,R2		;Point to top of rcv buffer desc ptr	;038
	MOV	#XHRBDL,(R2)+	;LSB Receive buffer list pointer	;038
	CLR	(R2)+		;MSB RCV BDL (Activates receive)	;038
	MOV	#XHXBDL,(R2)+	;LSB Transmit buffer list pointer	;038
	CLR	(R2)+		;MSB XMT BDL (Activates transmit)	;038
	TST	(R2)+		;Skip vector (Points R2 back at CSR)	;038
	CALL	@(SP)+,R5,RDY3	;Wait for receive side interrupt	;038
	MOV	#2,(R2)		;Software reset				;038
	CLR	(R2)		;Stop resetting				;038
;Should check and verify that it worked, else call it BROKEN
	RETURN			;All done				;038

XNPOKE:	MOV	R2,-(SP)	;MAKE A COPY OF THE CSR POINTER
	BIC	#7,R2		;POINT TO THE FIRST DN11 ON THIS BACKPLANE
	MOV	#4,(R2)+	;SET MINAB (MASTER INTERRUPT ENABLE ON ALL
	MOV	#4,(R2)+	; DN11'S ON THIS BACKPLANE SINCE IT WILL ONLY
	MOV	#4,(R2)+	; ON ONE OF THEM AND SOME OF THE FOUR DN11'S
	MOV	#4,(R2)+	; ON THIS BACKPLANE MAY BE MISSING
	MOV	(SP)+,R2	;RESTORE THE CSR POINTER
	MOV	#114,(R2)	;SET I.E., MAINTENANCE MODE, MINAB
	BIS	#2001,(R2)	;INDICATE POWER FAIL AND DIGIT PRESENT
	CALL	@(SP)+,R5,RDY2	;WAIT
	CLR	(R2)		;Clear Maint. bit in CSR
	RETURN

RPPOKE:	MOV	#-1,RPDA(R2)	;SET ILLEGAL DISK ADDRESS
	BR	90$		;SAME FUNCTION CODE AS RK

RKPOKE:	MOV	#-1,RKDA(R2)	;SET UP A VERY ILLEGAL DISK ADDRESS
90$:	MOV	#111,(R2)	;DO A SEEK TO NOWHERE (WILL GET ERROR)
	CALL	@(SP)+,R5,RDY1	;WAIT FOR THE TRAP (SHOULD BE IMMEDIATE)
	MOV	#1,(R2)		;RESET THE DRIVE
	RETURN

RLPOKE:	MOV	#3,4(R2)	;PREPARE FOR GET-STATUS
	MOV	#104,(R2)	;GET STATUS,, INTERRUPT ENABLED
	CALL	@(SP)+,R5,RDY1	;WAIT FOR INTERRUPT
	MOV	#200,(R2)	;TURN OFF IE, BUT DON'T ISSUE A COMMAND
	RETURN			;DONE

RFPOKE:	MOV	#101,(R2)	;IE & NOP & GO
	CALL	@(SP)+,R5,RDY1
	BR	100$		;Go Power Clear & Return


RMPOKE:
RBPOKE:
RRPOKE:
TUPOKE:
RSPOKE:	CLR	(R2)		;TURN OFF ANY STUFF
	MOV	#300,(R2)	;IE & RDY & GO
	CALL	@(SP)+,R5,RDY1
	MOV	#RHCLR,RHCS2(R2) ;CONTROLLER RESET
100$:	MOV	#400,(R2)	;POWER CLEAR RC/RF, TURN OFF I.E. ALL
	RETURN

MUPOKE:									;024
RUPOKE:	CLR	(R2)+		;Initialize the U/Q port by poking IP	;024
	MOVB	#-15.,DSS$DV+1	;TIME OUT AFTER 15 SECONDS
110$:	BIT	#104000,(R2)	;ERROR OR READY IN THE CSR(SA)?
	BMI	130$		; FATAL CONTROLLER ERROR!
	BNE	115$		; READY, SO GO DO IT.
	CALLX	GETTTY		;WATCH CLOCK AND TTY
	TSTB	DSS$DV+1	;TIMEOUT?
	BMI	110$		;NO, SO KEEP TRYING.
130$:	MOV	#-1.,R0		;THIS ONE'S SMOKING ROPE, SET THE ERROR.
	CALL	@(SP)+,R5	;BACK TO VECCHK TO DISABLE IT.
	BR	120$		;NOW PUT IT TO SLEEP FOR GOOD.

115$:	MOV	#100354,(R2)	;READY. ISSUE STEP 2, E.I., AND VECTOR TO 154
	CALL	@(SP)+,R5,RDY8	;WAIT FOR INTERRUPT
120$:	CLR	-(R2)		;QUIESCE THE CONTROLLER
	RETURN			;ICE CREAM.

DZPOKE:	CALL	140$		;CLEAR OUT THE DZ11
	MOVB	#1,4(R2)	;TRANSMIT ENABLE LINE 0
	MOV	#040040,(R2)	;SET TRANSMITTER ENABLE
	CALL	@(SP)+,R5,RDY3	;WAIT FOR TRANSMITTER READY
	BCS	140$		;IF NONE, DON'T ADJUST THE VECTOR
	CMP	-(R0),-(R0)	;BACK UP TO THE RECEIVER VECTOR
	MOV	DEV.UN,-(SP)	;GET CURRENT DZ UNIT #			;021
	ASL	(SP)		; CONTROLLER # * 2			;021
	ADD	#TYPTBL+DZ.CSO,(SP) ;POINT TO TYPE TABLE FOR THIS DZ	;021
	CLR	@(SP)		;ASSUME 8 LINE DZ11			;060
	MOVB	#360,4(R2)	;TRANSMIT ENABLE 4-7			;021
	BIT	#360,4(R2)	;ANY STAY SET?				;021
	BNE	138$		;YES, SO MUST REALLY BE 8 LINES		;021
	INC	@(SP)		;CLEAR 8 LINE FLAG (MAKE IT 4)		;060
138$:	TST	(SP)+		;TRASH THE POINTER NOW			;021
140$:	MOV	#20,(R2)	;CLEAR OUT THE DZ11
	MOV	#20,RDYBIT	;SAVE DZ11 'READY' VALUE		;010
	BR	180$		;WAIT FOR CLEAR TO SETTLE

VHPOKE:	CALL	145$		;START WITH A CLEAR DEVICE		;021
	MOV	#40000,(R2)	;SET TRANSMIT I.E.			;010
	MOV	#200,10(R2)	;SET LOOPBACK MODE			;010
	CLR	12(R2)		;SET DMA ADDRESS = 0			;010
	MOV	#1,16(R2)	;SET DMA CHARACTER COUNT TO 1		;010
	MOV	#100200,14(R2)	;SET TX ENABLE AND DMA START		;010
	CALL	@(SP)+,R5,RDY9	;WAIT FOR INTERRUPT			;010
	BCS	145$		;NO INTERRRUPT				;010
        CALL    VHDIAG          ;CHECK FOR FAULT CODE, CARRY SET IF ERROR  ;050
        BCS     145$            ;YES, ERROR -CODE IN POKFLG                ;050
	CMP	-(R0),-(R0)	;ADJUST VECTOR FOR RECEIVER SIDE	;010
	MOV	DEV.UN,-(SP)	;GET THE CONTROLLER NUMBER		;021
	ASL	(SP)		; * 2					;021
	ADD	#TYPTBL+VH.CSO,(SP) ;POINT TO THIS CONTROLLER IN TYPTBL	;021
	CLR	@(SP)		;ASSUME 16 LINE MUX			;060
	MOV	#10,(R2)	;NO IE, SUBLINE 8.			;021
	TST	4(R2)		;DOES THE LPR HAVE ANYTHING?		;021
	BNE	142$		;YES, MUST BE DHU, GUESSED RIGHT	;021
	INC	@(SP)		;SET AS 8 LIN DHV MUX			;060
142$:	TST	(SP)+		;TRASH THE POINTER			;021
145$:	MOV	#40,(R2)	;MASTER RESET, CLEAN HOUSE		;010
	MOV	#40,RDYBIT	;SAVE DHV11 'READY' VALUE		;010
	CALL	180$		;WAIT FOR CLEAR TO SETTLE		;010
	CLR	(R2)		;ENSURE THAT TX I.E. IS CLR		;010
	RETURN			;AND EXIT				;010

DHPOKE:	MOV	#120000,(R2)	;TRANSMITTER IE & INTERRUPT
	CALL	@(SP)+,R5,RDY1
	BCS	150$		;NO INTERRUPT
	CMP	-(R0),-(R0)	;ADJUST VECTOR FOR RECEIVER SIDE
150$:	MOV	#004000,(R2)	;MASTER CLEAR THE DH
	RETURN

GLOBAL	<DEV.UN,TYPTBL,DZ.CSO,VH.CSO>

TMPOKE:	MOV	#010000,(R2)	;POWER CLEAR THE MAGTAPE
	MOV	#100,(R2)	;SET INTERRUPT ENABLE (MANUAL SAYS THIS WORKS)
	CALL	@(SP)+,R5,RDY1
	MOV	#010000,(R2)	;POWER CLEAR IT AGAIN
	RETURN

XVPOKE:	MOV	#1,(R2)		;Clear the DPV				;069
	MOV	#100,(R2)	;Set XMIT Interrupt Enable		;069
	CALL	@(SP)+,R5,RDY0	;Wait for the interrupt			;069
	BCS	155$		;Broken, so exit			;069
	CMP	-(R0),-(R0)	;Reset to lowest vector			;069
155$:	MOV	#1,(R2)		;Clear it again				;069
	RETURN			; and we're all done			;069

D1POKE:				;DUP11 IS LIKE DU11
DUPOKE:	CLR	4(R2)		;ENSURE I.E. IS OFF
	MOV	#100,4(R2)	;SET I.E.
	CALL	@(SP)+,R5,RDY4
	BCS	160$		;GO IF NO INTERRUPT
	CMP	-(R0),-(R0)
160$:	MOV	#400,4(R2)	;POWER CLEAR IT
	RETURN

DJPOKE:	CALL	170$		;RESET THE DJ
	MOV	#-1,4(R2)	;ENABLE SCAN OF ALL LINES
	MOV	#040400,(R2)	;ENABLE THE TRANSMITTER
	CALL	@(SP)+,R5,RDY1	;WAIT FOR THE GO
	BCS	170$		;NO INTERRUPT
	CMP	-(R0),-(R0)	;BACK UP TO RECEIVER VECTOR
170$:	MOV	#10,(R2)	;MASTER CLEAR THE DJ
	MOV	#20,RDYBIT	;SAVE THE DJ11 'READY' VALUE		;010
180$:	MOVB	#-5.,DSS$DV+1	;TIME OUT AFTER 5 SECONDS
190$:	CALLX	GETTTY		;WATCH CLOCK AND TTY
	BIT	RDYBIT,(R2)	;WAIT FOR CLEAR DONE			;010
	BEQ	200$		;RETURN WHEN DONE
	TSTB	DSS$DV+1	;TIMEOUT?
	BMI	190$		;WAIT FOR 5 SECONDS OR CLEAR DONE
200$:	RETURN

LKPOKP:	MOV	#200,R0		;Standard keyboard interrupt vector	;049
	BR	KGPOKE		;Don't poke it				;049

TTPOKP:				;Pro console terminal port is the same	;049
PCPOKP:	MOV	#220,R0		;Standard printer port vector		;049
	BR	KGPOKE		;Don't poke it				;049

XTPOKP:	MOV	#210,R0		;Standard comm port vector		;049
	BR	KGPOKE		;Don't poke it				;049

CDPOKE:
CRPOKE:	ADD	#230,R0		;USE STANDARD VECTOR IF NONE SET
BSPOKE:				;Can't poke DT07, it might switch	;047
RVPOKE:				;Can't poke the virtual disk.		;009
KGPOKE:	SEC			;INDICATE NO POKING
	RETURN			;Exit with R0=Zero (No Vector)		;009

; Anything that goes into a GPK option slot is "poked" here		;049

PIPOKP:				;Display controller			;049
RWPOKP:				;Hard disk				;049
RZPOKP:				;Floppy					;049
	MOV	R2,R0		;Copy CSR address			;049
	SUB	#SLOT0,R0	;Make into slot offset			;049
	ASH	#-7+3,R0	;Convert to vector offset		;049
	ADD	#300,R0		; and form slot INTA vector		;049
	BR	KGPOKE		;Exit without poking			;049

.DSABL	LSB

XKPOKE:	MOV	R3,-(SP)	;SAVE R3
	MOV	R4,-(SP)	;AND R4
	CLR	(R2)		;CLEAR OUT CSR THAT READY WILL SET
	CLR	R3		;SET UP ADDRESS COUNT
	MOV	#40$,R4		;R4 -> TABLE OF MICROCODE
	MOVB	#100,1(R2)	;CLEAR MICRO PROCESSOR
10$:	MOVB	#4,1(R2)	;SET RAM OUTPUT
	MOV	R3,4(R2)	;SET ADDRESS TO CRAM
	MOV	(R4),6(R2)	;SET MICRO-INSTRUCTION TO CRAM
	BISB	#40,1(R2)	;SETS INSTRUCTION INTO CRAM
	BICB	#40,1(R2)	;CLEAR INTIATES CRAM WRITE
	CMP	(R4)+,6(R2)	;SEE IF THE CRAM WORKED
	BNE	30$		;NO, WE HAVE A BAD KMC
	INC	R3		;ADVANCE ADDRESS COUNT
	CMP	R3,#10		;HAVE WE CRAMMED ALL 7 WORDS
	BLO	10$		;NO, CONTINUE TO CRAM
	MOV	(SP)+,R4	;YES, POP AND RESTORE R4
	MOV	(SP)+,R3	;AND POP AND RESTORE R3
	MOVB	#200,1(R2)	;START THE KMC
	CALL	@(SP)+,R5,RDY2	;WAIT UNTIL KMC SAYS ITS READY
20$:	CLRB	1(R2)		;STOP KMC ORDERLY
	MOVB	#100,1(R2)	;Clear microprocessor again.		;033
	RETURN			;AND RETURN VECTOR IT INTERRUPTED AT

30$:	MOV	#-1,R0		;SIGNAL A BAD DEVICE
	MOV	(SP)+,R4	;POP AND RESTORE R4
	MOV	(SP)+,R3	;POP AND RESTORE R3
	CLC			;INDICATE THAT DEVICE ISN'T KG11-STYLE
	CALL	@(SP)+,R5	;RETURN TO CALLER
	BR	20$		;STOP THE KMC

;033+
;	The following words represent the code that is loaded into the KMC11
;	that causes it to interrupt and signal READY.  Here is the blow-by-blow
;	for each instruction;
;
;	BRWRTE	IMM,0		;Move immediate 0 into BRG (Branch Register)
;	OUT	BR,SELB,ONPR	;Move BRG into OUTBUS NPR Register (clear it).
;	OUT	BR,SELB,OBR	;Same thing with OUTBUS uPMISC Register.
;	BRWRTE	IMM,200		;Move immediate 200 into BRG.
;	OUT	BR,SELB,OICOM	;Move BRG into OUTBUS CSR0 (sets Bit 7 in CSR).
;	OUT	BR,SELB,OBR	;Move BRG into OUTBUS uPMISC (causes interrupt).
; LOOP:	ALWAYS	LOOP		;Does a self-branch (ALWAYS is the mnemonic for
;				; the KMC-11 unconditional branch).
;
;	If everything goes according to plan, the KMC11 should interrupt at
;	it's proper vector, and Bit 7 ('Ready') should be set at the CSR
;	address.
;033-

40$:	.WORD	000400		; BRWRTE	IMM,0
	.WORD	061230		; OUT		BR,SELB,ONPR
	.WORD	061231		; OUT		BR,SELB,OBR
	.WORD	000600		; BRWRTE	IMM,200
	.WORD	061220		; OUT		BR,SELB,OICOM		;033
	.WORD	061231		; OUT		BR,SELB,OBR		;033
	.WORD	100406		; LOOP:		ALWAYS	LOOP

.DSABL	LSB

.ENABL	LSB

;+
; NOTE:	This routine not only does a POKE, but it does a LOOK as well.	;012
;	This is because there is a one-to-one correspondence between	;012
;	TS controllers and number of drives on them.  Also, we won't	;012
;	have to wait another 10 seconds per controller while they do	;012
;	their micro-diagnostics, and the method used to make the TS	;012
;	controller interrupt will give us all the information needed	;012
;	in order to identify it.					;012
;-
TSPOKE:	MOV	R0,-(SP)	;SAVE R0
	MOV	#80$,R0		;R0 -> MESSAGE BUFFER SPACE
10$:	CLR	(R0)+		;CLEAR OUT THE MESSAGE BUFFER
	CMP	R0,#90$		;ARE WE DONE?
	BLO	10$		;NOT YET
	MOV	R1,-(SP)	;Save R1
	MOV	#60$,R0		;Point to the packet
	MOV	R0,R1		;Copy the address
	BIC	#3,R1		;Compute doubleword aligned address to move to
	CMP	(R1),#140204	;Already aligned or packet already moved? ;015
	BEQ	17$		;Yes, so don't move the packet		;015
15$:	MOV	(R0)+,(R1)+	;Move the packet into alignment
	CMP	R0,#70$		;Done?
	BLO	15$		;Branch if not
17$:	MOV	(SP)+,R1	;Restore R1
	MOVB	#-120.,DSS$DV+1	;SET A TWO MINUTE TIMEOUT (TS REWIND TIME)
20$:	CALLX	GETTTY		;KEEP THE CLOCK GOING
	TST	DSS$DV		;DID WE TIMEOUT?
	BPL	50$		;YES, CALL DEVICE A SICKIE
	CMPB	#-110.,DSS$DV+1	;HAS 10 SECONDS GONE BY YET?		;007
	BNE	30$		;NO, GO SEE IF IT'S READY.		;007
	INCB	DSS$DV+1	;INSURE THAT WE PRINT THIS MESSAGE ONLY ONCE
	MESSAG	<" INIT will wait up to 2 minutes for">	;TELL HIM HE MAY;007
	MESSAG	<" TS tape to become ready"<200>>	;HAVE LONG WAIT.;007
30$:	BIT	#200,(R2)	;IS THE TAPE DRIVE READY YET?
	BEQ	20$		;NOPE, WAIT FOR IT
	MOV	#60$&<^C3>,-2(R2) ;SET TSDA ( PACKET ADDRESS )
	MOV	(SP)+,R0	;POP POINTER OFF STACK
	CLC			;MAKE SURE THAT CARRY IS CLEAR
	CALL	@(SP)+,R5,RDY6	;WAIT FOR IT TO INTERRUPT

	BCS	55$		;Didn't interrupt, we can't identify it	;015
	MOV	R0,-(SP)	;Save R0				;015
	CLRB	-(SP)		;Push a zero for no features flag	;015
	MOV	80$+12,R0	;GET XSTAT2				;012
	BIC	#^C<5200>,R0	;Isolate bits 7, 9 and 11		;015
	MOVB	R0,(SP)		;Save bit 7 on the stack		;015
	ASH	#-10.,R0	;Put bit 9 into carry, and 11 into 1	;015
	ADC	R0		;Put carry into bit 1 (result is 0-3)	;015
	BNE	37$		;NON-ZERO IS GREAT			;012
	TSTB	FLGQBU		;BUT TSV05 AND TS11 ARE BOTH ZERO...	;012
	BMI	37$		;BUT THE TSV05 IS ONLY ON THE Q-BUS...	;012
	MOV	#3,R0		;make it respond like the TSU05		;015
37$:	TSTB	(SP)		;Was bit 7 set in XSTAT2?		;015
	BPL	40$		;Nope, don't worry about it		;015
	CMPB	90$(R0),#$TK25	;Does this drive has extended features?	;015
	BGE	40$		;Yes, so leave flag byte on stack	;015
	CLRB	(SP)		;Put no features flag on top of stack	;015
40$:	BISB	90$(R0),(SP)	;LOOK UP AND STORE TYPE ON STACK	;015
	MOV	DEV.UN,R0	;R0 = MS DRIVE NUMBER			;012
	MOVB	(SP)+,MS$TYP(R0);Store combined ID code in ROOT		;015
45$:	MOV	(SP)+,R0	;Retsore R0				;012
	CLR	(R2)		;DO A DATO, SUBSYSTEM INITIALIZE
	RETURN			;AND WE ARE DONE

50$:	MOV	#-1,R0		;SET FLAG FOR A SICK DEVICE
	TST	(SP)+		;POP JUNK OFF STACK
	CLC			;CLEAR THE CARRY
	CALL	@(SP)+,R5	;CALL MY CALLER BACK
55$:	MOV	R0,-(SP)	;SAVE R0				;015
	MOV	DEV.UN,R0	;R0 = MS DRIVE NUMBER			;015
	MOVB	#$TSEND,MS$TYP(R0) ;Call it unknown			;015
	BR	45$		;...AND TURN OFF THE TS04		;015

	TMPORG	ONECTL

RDYBIT: .WORD	0		;DEVICE 'READY' FLAG			;010
60$:	.WORD	140204		;WRITE CHARACTERISTICS +IE+ACK+CVC
	.WORD	70$		;LOW WORD OF CHARACTERISTICS DATA POINTER
	.WORD	0		;HIGH WORD "
	.WORD	8.		;LENGTH IN BYTES "

70$:	.WORD	80$		;LOW WORD OF MESSAGE BUFFER POINTER
	.WORD	0		;HIGH WORD "
	.WORD	14.		;LENGTH IN BYTES "
	.WORD	0		;CHARACTERISTICS WORD
80$:	.BLKW0	7.		;SEVEN WORDS FOR MESSAGE AREA
;
MSDLF 	=	80$+2		;DATA LENGTH FIELD OF MESSAGE AREA
;
; TS DRIVE TYPE LOOKUP TABLE						;015
;
90$:	.BYTE		$TS11,	$TK25,	$TU80,	$TS05			;015
;
; XSTAT2 bit 11:	0	1	0	1			;015
; XSTAT2 bit  9:  	0	0	1	0			;015
;
	UNORG								;010

GLOBAL	<FLGQBU,MS$TYP,DEV.UN>						;015

.DSABL	LSB

.SBTTL	COMMON ROUTINES TO CHECK IF A DEVICE IS READY

.ENABL	LSB

RDY0:	BIT	#4,(R2)		;Is Bit 2 set?				;069
	BNE	10$		; Yes					;069
	RETURN								;069

RDY1:	BIT	#100200,(R2)	;CHECK FOR BIT 7 OR 15
	BNE	10$		;IF EITHER SET, RETURN C=1
	RETURN

RDY2:	TSTB	(R2)		;CHECK FOR BIT 7
	BMI	10$		;IF SET, RETURN C=1
	RETURN

RDY3:	TST	(R2)		;CHECK FOR BIT 15
	BMI	10$		;IF SET, RETURN C=1
	RETURN

RDY4:	TSTB	4(R2)		;CHECK TRANSMITTER READY
	BMI	10$		;IF SET, RETURN C=1
	RETURN

RDY5:	BIT	#100040,(R2)	;CHECK FOR BIT 5 OR 15
	BNE	10$		;IF SET, RETURN C=1
	RETURN

RDY6:	TST	MSDLF		;CHECK DATA LENGTH FIELD OF TS04 MESSAGE
	BNE	10$		;IF ANYTHING SET, RETURN C=1
	RETURN

RDY7:	BITB	#XD.RDI,BSEL2(R2);IS THE PORT READY? (C CLEARED BY CALLER)
.ASSUME	XD.RDI	EQ	20	;AT LEAST, WE THINK IT SHOULD BE 20....
	BNE	10$		;NAY, TIS PERHAPS A SAD AFFAIR.
	RETURN			;HAH! IT'S READY! NOW DOWN TO BUSINESS...

RDY8:	BIT	#010000,(R2)	;STEP 1 DONE YET?
	BNE	10$		;STEP 1 IS DONE.
	RETURN			;NOT READY OR ERROR

RDY9:	TSTB	14(R2)		;CHECK FOR BIT 7 (DMA START)		;010
	BPL	10$		;IF NOT SET, RETURN C=1			;010
	RETURN			;NOT READY OR ERROR			;010

10$:	SEC			;INDICATE DEVICE IS READY
	RETURN

.DSABL	LSB

.SBTTL	XDDIAG - EXECUTE THE DMP/DMV MICRO DIAGNOSTICS


;+
; XDDIAG - RUN'S THE DMP/DMV MICRO-DIAGNOSTICS AND TEST THE RESULTS
;	   FOR ERRORS. IF THE DEVICE PACKET DOES NOT AGREE WITH THE
;	   DEVICE TYPE DETERMINED BY THE MICRO-DIAGNOSTICS AN ERROR
;	   WILL BE RETURNED IN "POKFLG".
;	   ALSO RESETS THE XD PACKET CONTENTS ACCORDINGLY: 
;				DMP HAS MAX # UNITS OF 32/CSR SIZE=8.
;				DMV HAS MAX # UNITS OF 12/CSR SIZE=16.
;	   NOTE: CSR LOCATION MUST BE TESTED FOR UNIBUS TIME-OUT FIRST.
;		R5 ->  XD PACKET
;		R2 ->  CSR ADDRESS
;		CALL XDDIAG
;		R0 =   ZERO	;IF DIAGNOSTICS RAN SUCCESSFULLY
;		R0 =   NEGATIVE	;IF ANY ERRORS OCCURRED
;-


	.DSECT	,NOCREF		; SYMBOLS TO ADDRESS CSRS BY BYTES
BSEL0:	.BLKB
BSEL1:	.BLKB
BSEL2:	.BLKB
BSEL3:	.BLKB
BSEL4:	.BLKB
BSEL5:	.BLKB
BSEL6:	.BLKB
BSEL7:	.BLKB


	.BSECT	,NOCREF		; 
XD.IEI:	.BLKB	.	;= 1 CSR0 (WORD)	XD Interupt enable in
	.BLKB	.	;
	.BLKB	.	;
	.BLKB	.	;
XD.RDI:	.BLKB	.	;= 20 BSEL2 (BYTE)	XD Ready in
XM.RQI:	.BLKB	.	;= 40 BSEL2 (BYTE)	XM Request in
XM.IEI:	.BLKB	.	;= 100 CSR0 (WORD)	XM Interupt enable in
XM.RDI:			;			XM Ready in
XD.RQI:	.BLKB	.	;= 200 CSR0 (WORD)	XD Request in
	.BLKB	.	;
	.BLKB	.	;
	.BLKB	.	;
	.BLKB	.	;
	.BLKB	.	;
MDIAG:	.BLKB	.	;
MCLR:	.BLKB	.	;= 40000 CSR0 (WORD)	[XD/XM] ;MASTER POWER CLEAR
MRUN:	.BLKB	.	;= 100000 CSR0 (WORD)	[XD/XM] ;RUN


DMP	=	77	;BSEL4 (BYTE) INDICATES DEVICE IS A DMP
DMV	=	33	;BSEL4 (BYTE) INDICATES DEVICE IS A DMV
DMC	=	66	;BSEL3 (BYTE) INDICATES DEVICE IS A DMC
DMR	=	200	;BSEL3 (BYTE) INDICATES DIAG. TEST COMPLETE ON A DMR

		UNORG

XDDIAG:	MOV	#MCLR,(R2)	;MASTER CLEAR DMP/DMV
	MOV	#10.,XDPTMO	;SETUP FOR TEN ONE-SECOND TIMEOUTS
	BIC	#XDUDCK,POKFLG	;SAY MICRO-DIAGNOSTICS HAVEN'T FAILED YET
10$:	MOVB	#-1,DSS$DV+1	;ONE SECOND TIMEOUT ALLOWS MICRODIAGS TO RUN
20$:	TST	(R2)		;- IS THE DMP/DMV READY YET?
.ASSUME	MRUN	EQ	100000	;READY/RUN SHOULD BE SIGN BIT
	BMI	40$		;YES, SO CHECK MICRODIAGNOSTIC STATUS
	DEC	XDPTMO		;NOT YET READY. HAVE WE WAITED 10 SECS YET?
	BMI	70$		;'FRAID SO -- THAT'S A MICRODIAG TIMEOUT THEN
30$:	CALLX	GETTTY		;KEEP THE CLOCK GOING
	TST	DSS$DV		;DID (APPROX) ONE SECOND PASS YET?
	BMI	30$		;NO, KEEP LOOKING (DMP/DMV NEEDS TIME TO RUN)
	BR	10$		;NOT YET 10 SECS, SO WAIT ANOTHER SECOND

40$:	CMPB	#305,BSEL6(R2)	;ANY ERRORS FROM DIAGNOSTICS?
	BNE	70$		;YEP, DISABLE DEVICE
	CMPB	#DMP,BSEL4(R2)	;IS THIS A "DMP" TYPE XD?
	BNE	50$		;NO, MUST BE THE "DMV"
	CMPB	#DMPSZ,PK.SIZ(R5);CHECK THE XD PACKET TO ASSURE CSR SIZE = 8b.
	BNE	60$		;PACKET NOT DMP COMPATABLE, DISABLE DEVICE
	BR	80$		;PACKET OK, NOW GO ENABLE INTERRUPT

50$:	CMPB	#DMV,BSEL4(R2)	;IS THIS THE "DMV" TYPE XD
	BNE	70$		;NOT A DMV EITHER, MICRO-DIAGS MUST OF FAILED.
	CMPB	#DMVSZ,PK.SIZ(R5);CHECK THE XD PACKET TO ASSURE CSR SIZE= 16b.
	BNE	60$		;PACKET NOT DMV COMPATABLE, DISABLE DEVICE
	BR 	80$		;AND WE ARE DONE

60$:	BIS	#XDUPNC,POKFLG	;SET FLAG FOR A NON-COMPATABLE PACKET
70$:	MOV	#-1,R0		;SET FLAG FOR A SICK UNIT (MICRODIAGS FAILED)
	BIS	#XDUDCK,POKFLG	;SAY MICRO-DIAGNOSTICS CAUSED THE FAILURE
80$:	RETURN

XDPTMO:	.WORD	0		;TIMEOUT BUCKET FOR DDCMP COM. DIAGNOSTICS


.SBTTL	XMDIAG - EXECUTE THE DMR MICRO DIAGNOSTICS
;+
; XMDIAG - RUN'S THE DMR MICRO-DIAGNOSTICS AND TEST THE RESULTS
;	   FOR ERRORS. AN ARBITRARY VALUE IS LOADED INTO BSEL3 OF
;	   THE CSR SET TO DISTINGUISH A DMC FROM THE DMR. A DMC
;	   WILL NOT ALTER THE CONTENTS OF BSEL3 AFTER A MASTER CLEAR.
;	   DMR CONTROLLERS ARE INDICATED BY ITS CORRESPONDING BIT
;	   VALUE IN "XM.TYP:".  SET => DMR, CLEAR => DMC. ANY MICRO-
;	   DIAGNOSTIC ERROR WILL BE RETURNED IN "POKFLG".
;
;	   NOTE: CSR LOCATION MUST BE TESTED FOR UNIBUS TIME-OUT FIRST.
;		R5 ->  XD PACKET
;		R4 ->  CSRTBL OF DEVICE'S CSR ADDRESS
;		R2 ->  CSR BASE REGISTER
;		R0 =   ZERO	
;		CALL XMDIAG
;		R0 =   ZERO	;IF DIAGNOSTICS RAN SUCCESSFULLY
;		R0 =   NEGATIVE	;IF ANY ERRORS OCCURRED
;-

XMDIAG:	MOVB	#DMC,BSEL3(R2)	;LOAD AN ARBITRARY VALUE TO DETERMINE TYPE
	BIC	#XMUDCK,POKFLG	;SAY MICRO-DIAGNOSTICS HAVEN'T FAILED YET
	MOV	#MCLR,(R2)	;MASTER CLEAR DMC/DMR
10$:	MOV	#2.,XDPTMO	;SETUP FOR TWO ONE-SECOND TIMEOUTS
20$:	MOVB	#-1,DSS$DV+1	;1 SECOND TIMEOUT ALLOWS DMR MICRODIAGS TO RUN
	TST	(R2)		;- IS THE DMC/DMR READY YET?
.ASSUME	MRUN	EQ	100000	;READY/RUN SHOULD BE SIGN BIT
	BMI	40$		;YES, SO CHECK MICRODIAGNOSTIC STATUS
	DEC	XDPTMO		;NOT YET READY. HAVE WE WAITED 2 SECS YET?
	BMI	40$		;'FRAID SO -- THAT'S A MICRODIAG TIMEOUT THEN
30$:	CALLX	GETTTY		;KEEP THE CLOCK GOING
	TST	DSS$DV		;DID (APPROX) ONE SECOND PASS YET?
	BMI	30$		;NO, KEEP LOOKING (DMR NEEDS TIME TO RUN)
	BR	20$		;NOT YET 2 SECS, SO WAIT ANOTHER SECOND

40$:	CMPB	#DMC,BSEL3(R2)	;IF CSR DID'NT CHANGE THEN DEVICE IS A DMC
	BEQ	70$		;   AND NO CHANGES TO THE DDB'S EITHER.
	TST	(R2)		;IS THE DMR READY BIT SET?
	BPL	60$		;NO, SO REALLY A DEVICE TIMED-OUT ERROR.
	CMPB	#100,BSEL3(R2)	;DID WE GET A "TEST INHIBITED" ?
	BNE	50$		; NO, SO CHECK FOR DIAGNOSTIC ERRORS
	TST	R0		;DID WE GET A "TEST INHIBITED" THE LAST TIME?
	BNE	60$		;YES, SO MICRO-DIAGNOSTICS REALLY FAILED.
	MOV	#MCLR!MDIAG,(R2);MSTR/CLEAR AGAIN WITH THE MICRO-DIAG. BIT SET
	COM	R0		;SET A SWITCH SAYING 2ND TIME AROUND
	BR	10$		; AND GIVE IT ONE MORE TRY.

50$:	MOV	DEV.UN,R0	;SET UP CORRECT CONTROLLER NUMBER <DEVLOP:>
	ASL	R0		;*2 FOR WORD ADDRESS OFFSET
	BIS	BITWRD(R0),XM.TYP;AND SET CORRESPONDING BIT TO INDICATE A DMR
	CLR	R0		;CLEAR FOR ERROR INDICATOR
	CMPB	#DMR,BSEL3(R2)	;IF BSEL3 =  200
	BEQ	70$		;   THEN THE DIAGNOSTICS COMPLETED SUCCESFULLY
60$:	MOV	#-1,R0		;SET FLAG FOR A SICK UNIT (MICRO-DIAG FAILED)
	BIS	#XMUDCK,POKFLG	;SAY THE MICRO-DIAGNOSTICS CAUSED THE FAILURE
70$:	RETURN			;RETURN

GLOBAL	<DSS$DV,DEV.UN,BITWRD,XM.TYP>

.sbttl XVDIAG  -DHV/DHU analysis of internal micro code fault              ;050
                                                                           ;050
;+                                                                         ;050
; VHDIAG       Looks at the results of the DHV/DHU micro diagnostic to     ;050
;      determine if a sick device is present. If so it puts the            ;050
;      first non null error code from the silo in POKFLG along             ;050
;      a signature (070000) for later reporting, clears the vector         ;050
;      and regardless of error state drains silo of daignostic             ;050
;      data.                                                               ;050
;                                                                          ;050
;      R2 -> csr                                                           ;050
;      CALL VHDIAG                                                         ;050
;      R0 = 0 AND CARRY SET IF FAULT FOUND                                 ;050
;      R0 = VECTOR, CARRY CLEAR IF NO FAULT                                ;050
;                                                                          ;050
;       note that 70000 comes from HW silo and is signaure of micro diag   ;050
;       result code.                                                       ;050
;                                                                          ;050
                                                                           ;050
                                                                           ;050
VHDIAG: PUSH    R0              ;save vector data to make work register    ;050
        MOV     (R2),R0         ;Get base csr data                         ;050
        BIT     #20000,R0       ;look for fault bit in csr                 ;050
        BEQ     40$             ;Not fault, so skip to silo clear          ;050
20$:    mov     2(R2),R0        ;GET DATA WORD FROM DH SILO                ;050
        BPL     40$             ;IF ZERO ITS EMPTY, REPORT WHAT YOU HAVE   ;050
        BIC     #7400,R0        ;DISCARD EXCESS KNOWLEDGE                  ;050
        CMP     #170203,R0      ;WAS IT A SKIP-NOP FUNCTION                ;050
        BEQ     20$             ;YES, EXTRANIOUS, SO LOOK TO NEXT          ;050
        CMP     #170201,R0      ;WAS IT A REAL NULL                        ;050
        BEQ     20$             ;YES, ALSO EXTRANIOUS-KEEP GOING           ;050
        MOV     R0,POKFLG       ;SAVE THE VALID,NON NULL DATA              ;050
        CLR     (SP)            ;WAS VALID- CLEAR VECTOR                   ;050
40$:    MOV     2(R2),R0        ;WE HAVE WHAT WE NEED SO DRAIN SILO        ;050
        BMI     40$             ;NOT 0 MEANS MORE TO DRAIN                 ;050
        CLC                     ;SET FOR NO PROBLEM EXIT                   ;050
        POP     R0              ;DRAINING DONE, RESTORE R0 WITH VECTOR     ;050
        BNE     50$             ;NO,VECTOR PRESENT , ALL OK                ;050
        SEC                                                                ;050
50$:    RETURN  ;R0 IS VECTOR,CARRY IS STATUS,POKFLG IS ERROR              ;050
                                                                           ;050

.SBTTL	RFLOOK - FIND SIZE OF RF DISK

RFLOOK:	CLR	DF$SZL		;ASSUME THERE ARE 0 RF PLATTERS
	MOV	#-1,DF$MID	;ASSUME NO SUCH DISK
	MOV	DSKCSR+IDX$DF,R1 ;POINT TO RF CSR
	BEQ	40$		;NONE THERE, 0 IS A GOOD GUESS
	MOV	#IDX$DF,R1	;R1 = DISK INDEX; R4 = UNIT # (UNUSED)
	CALLX	XXRSET		;RESET THE DISK
	CLR	10(R1)		;START WITH DISK UNIT 0
	CLR	-(SP)		;MAKE ROOM FOR THE DISK READ
10$:	CLR	6(R1)		;SET DISK ADDRESS 0
	MOV	SP,4(R1)	;SET ADDRESS FOR READ
	MOV	#-1,2(R1)	;ONE WORD READ
	MOVB	#5,(R1)		;READ THE WORD (IF WE CAN)
	MOVB	#-5,DSS$DF+1	;TIME OUT AFTER 5 SECONDS
20$:	CALLX	GETTTY		;WATCH THE TERMINAL AND THE CLOCK
	TST	DSS$DF		;TIMEOUT?
	BPL	30$		;YES, TREAT LIKE NONEXISTENT PLATTER
	BIT	#100200,(R1)	;WAIT FOR READY
	BEQ	20$		;NOT READY YET
	BMI	30$		;ERROR, NO DISK THERE
	ADD	#4,10(R1)	;ADVANCE DISK ADDRESS TO NEXT PLATTER
	ADD	#1024.,DF$SZL	;AND ONE MORE PLATTER IS 1024 MORE BLOX
	CMP	DF$SZL,#1024.*8. ;DID WE FIND 8 PLATTERS?
	BLO	10$		;TRY FOR MORE IF NOT
30$:	MOV	#IDX$DF,R1	;R1 = DISK INDEX; R4 = UNIT # (UNUSED)
	CALLX	XXRSET		;RESET THE DISK AGAIN
	TST	(SP)+		;DUMP THE SHORT BUFFER
	MOV	DF$SZL,RFSLSV	;AND SAVE IT AGAIN
	CLR	DF$MID		;INDICATE EXTANT DISK
40$:	RETURN

GLOBAL	<DF$SZL,DF$MID,DSKCSR,RFSLSV,DSS$DF>

.SBTTL	RSLOOK - DETERMINE RS03/RS04 DRIVE TYPE

RSLOOK:	MOV	#DS$SZL,R2	;POINT TO TABLE OF LSB RS SIZES
	MOV	#8.,R0		;INITIALLY, CLEAR THEM OUT
10$:	MOV	#-1,DS$MID-DS$SZL(R2) ;ASSUME NO SUCH UNIT
	CLR	(R2)+		; WITH SIZE = 0
	SOB	R0,10$
	CLR	TYPTBL+RS.CSO	;CLEAR OUT FLAG WORD
	TST	DSKCSR+IDX$DS	;CHECK RS03/04 CSR'S
	BEQ	70$		;NO RS, JUST RETURN
	MOV	#7,R4		;START WITH UNIT 7
20$:	CLR	-(R2)		;NO RS IN THIS SLOT YET
	MOV	DSUMID-DS$SZL(R2),R0 ;GET USER ID IN CASE WE CAN'T ACCESS IT
	MOV	#IDX$DS,R1	;R1 = DISK INDEX; R4 = UNIT NUMBER
	CALLX	XXRSET		;TRY TO RESET THE UNIT
	BCS	30$		;NO GO
	MOV	RHDT(R1),R5	;GET DRIVE TYPE
	BIT	#RHMCPE,(R1)	;PARITY ERROR ON ACCESS?
	BNE	30$		;YES, NO SUCH UNIT
	BIT	#RHNED,RHCS2(R1) ;NON-EXISTENT DRIVE BIT ON?
	BEQ	40$		;NOPE, WE GOT A WINNER
30$:	CMP	R0,#-1		;IS THERE A USER OVERRIDE?
	BEQ	60$		;NOPE, THERE IS NO DRIVE HERE
	MOV	R0,R5		;USE THE USER'S VALUE
40$:	CMP	R5,#3		;IS DRIVE TYPE 0-3 ?
	BHI	60$		;NO, NOT INTERESTED IF NOT RS
	MOV	#1024.,(R2)	;YES, ASSUME IT'S AN RS03
	BISB	BITBYT(R4),TYPTBL+RS.CSO ;SET FLAG FOR UNIT EXISTS
	BIT	R5,#2		;DRIVE TYPE 0 OR 1 ?
	BEQ	50$		;YES, WE WERE RIGHT
	ASL	(R2)		;NO, RS04 IS TWICE AS BIG
50$:	MOV	R5,DS$MID-DS$SZL(R2) ;SET MASSBUD ID CODE
	CMP	R5,R0		;USER SAME AS REAL?
	BEQ	60$		;YES
	INC	R0		;NOPE, USER VALUE EXIST?
	BEQ	60$		;NO, NO ERROR
	CALL	UNTERR,R5,"DS	;USER SET ERROR FOR DS UNIT
60$:	DECB	R4		;NEXT UNIT DOWN
	BPL	20$		;GO IF MORE TO DO
70$:	RETURN

GLOBAL	<DS$SZL,DS$MID,TYPTBL,RS.CSO,DSKCSR,DSUMID,BITBYT>

.SBTTL	RKLOOK - DETERMINE RK05/RK05F DRIVE TYPE

RKLOOK:	MOV	#DK$MID+<8.*2>,R3 ;POINT TO TABLE OF ID WORDS
	MOV	#8.,R0		;INITIALLY, CLEAR THEM OUT
10$:	MOV	#-1,-(R3)	;ID INDICATES NO SUCH DRIVE
	CLR	DK$SZL-DK$MID(R3) ; AND SIZE IS 0
	SOB	R0,10$
	CLRB	TYPTBL+RK.CSO	;SET NO RK05F'S FOR NOW
	MOV	DSKCSR+IDX$DK,R1 ;GET RK05 CSR ADDRESS
	BEQ	100$		;NO RK05, OUT FAST
	CLR	R4		;CLEAR UNIT COUNTER
	CLR	R0		;START WITH UNIT 0
20$:	CALL	120$		;SELECT THE EVEN UNIT
	BCS	40$		;GOT IT
	CALL	110$		;CANNOT DO IT, TRY SELECTING THE ODD
	BCC	70$		;NO CAN DO, CAN'T DETERMINE TYPE, USE USER SET
30$:	CLR	(R3)+		;CAN SELECT ONLY ONE, CAN'T BE RK05F
	CLR	(R3)		;SET BOTH UNITS TO RK05J
	BR	90$		;GO CHECK AGAINST USER SETS

40$:	CALL	110$		;GOT THE EVEN, TRY SELECTING THE ODD
	BCC	30$		;NO CAN DO, DEFINITELY NOT RK05F
	MOV	#15,(R1)	;GOT IT, TRY HOME SEEK ON ODD UNIT
	BIC	#020000,R0	;GET EVEN UNIT NUMBER
	MOVB	#-5,DSS$DK+1	;TIME OUT AFTER 5 SECONDS
50$:	CALLX	GETTTY		;WATCH TERMINAL AND CLOCK
	TST	DSS$DK		;TIMEOUT?
	BPL	60$		;YES, PRETEND IT'S READY
	BIT	#100200,(R1)	;WAIT FOR CONTROLLER READY
	BEQ	50$		; OR ERROR
60$:	MOV	R0,RKDA(R1)	;SELECT EVEN UNIT
	BIT	#100,RKDS(R1)	;IS THAT UNIT BUSY NOW?
	BNE	30$		;DEFINITELY NOT, SO NO RK05F
	MOV	#2,(R3)		;SET RK05F
	MOV	(R3)+,(R3)	; ON BOTH UNITS
	BR	90$		;GO CHECK AGAINST USER SET OPTIONS

70$:	MOV	DKUMID-DK$MID(R3),(R3)+ ;GET USER OPTION FOR EVEN UNIT
	BPL	80$		;IF PRESENT, USE IT
	BIC	-(R3),(R3)+	;IF NONE, USE RK05J
80$:	MOV	DKUMID-DK$MID(R3),(R3) ;GET USER OPTION FOR ODD UNIT
	BPL	90$		;IF PRESENT, USE IT
	CLR	(R3)		;IF NONE, USE RK05J
90$:	TST	-(R3)		;BACK UP TO EVEN UNIT
	CALL	150$		;SET SIZE, CHECK USER SET
	BIC	#020000,R0	;GET EVEN UNIT NUMBER
	ADD	#040000,R0	;ADD 2 TO UNIT NUMBER
	BCC	20$		;IF NO OVERFLOW, TRY HIGHER UNITS
100$:	RETURN

GLOBAL	<DK$MID,DK$SZL,TYPTBL,RK.CSO,DSKCSR,DKUMID,DSS$DK>

110$:	BIS	#020000,R0	;FORCE ODD UNIT
120$:	MOVB	#-5,DSS$DK+1	;TIME OUT AFTER 5 SECONDS
130$:	CALLX	GETTTY		;WATCH THE TERMINAL AND THE CLOCK
	TST	DSS$DK		;TIMEOUT?
	BPL	140$		;YES -- TREAT LIKE NONEXISTENT UNIT
	BIT	#100200,(R1)	;WAIT FOR CONTROLLER READY
	BEQ	130$		; OR (IGNORED) ERROR
	MOV	R0,RKDA(R1)	;SELECT THE UNIT
	BIT	#4000,RKDS(R1)	;RK05 OR RK03?				;021
	BEQ	138$		; MUST BE RK03, OR NOTHING		;021
	BIT	#20000,R0	;ODD OR EVEN?				;021
	BEQ	134$		;EVEN					;021
	BISB	BITBYT+1(R4),TYPTBL+RK.CSO ;SET THE BIT FOR THE ODD UNIT;021
	BR	138$		;AND QUIT				;021

134$:	BISB	BITBYT(R4),TYPTBL+RK.CSO ;SET THE BIT FOR THE EVEN UNIT	;021
138$:	TSTB	RKDS(R1)	;DRIVE READY?
	BPL	140$		;NO, NO DISK IS SPINNING
	BIT	#100,RKDS(R1)	;YES, IS IT READY TO BE ACCESSED?
	BEQ	130$		;NOPE, WAIT A WHILE
	SEC			;YES, TURN ON CARRY TO SAY ACCESS READY
140$:	RETURN

150$:	MOV	PC,-(SP)	;DO THIS ONCE FOR EVEN, ONCE FOR ODD UNIT
	MOV	#4800.,DK$SZL-DK$MID(R3) ;SET SIZE OF THIS UNIT
	MOV	(R3)+,R5	;IS THIS AN RK05F?
	MOV	DKUMID-DK$MID-2(R3),R2 ;GET USER SET VALUE
	BMI	160$		;NONE, SO NO MISMATCH
	CMP	R5,R2		;DO THE THINGS MATCH?
	BEQ	160$		;YES, NO PROBLEM
	CALL	UNTERR,R5,"DK	;ERROR
160$:	INC	R4		;BUMP UNIT NUMBER
	RETURN			;DONE

GLOBAL	<DSS$DK,DK$SZL,DK$MID,DKUMID,TYPTBL,RK.CSO>

.SBTTL	RLLOOK - DETERMINE RL01/RL02 DRIVE TYPE

RLLOOK:	MOV	#DL$SZL,R3	;POINT TO TABLE OF SIZE WORDS
	MOV	#4,R0		;ONLY FOUR UNITS ON THIS DEVICE!
10$:	MOV	#-1,DL$MID-DL$SZL(R3) ;MARK AS NONEXISTENT
	CLR	(R3)+		;(SIZE=0)
	SOB	R0,10$		;FOR EACH UNIT
	CLR	TYPTBL+RL.CSO	;FLAG NONEXISTENT FOR SYSGEN
	MOV	DSKCSR+IDX$DL,R1 ;GET CSR ADDRESS
	BEQ	80$		;EXIT IF NONE
	MOV	#3,R0		;START WITH UNIT 3
20$:	CLR	-(R3)		;NO UNIT HERE YET
	MOV	#3,RLDA(R1)	;SET UP FOR A GET-STATUS
	MOV	R0,R2		;COPY UNIT NUMBER
	SWAB	R2		;TO BITS 8-9
	BIS	#RLGSTS,R2	;SET COMMAND
	MOV	R2,(R1)		;ISSUE GET-STATUS FOR THIS DRIVE
	MOVB	#-5,DSS$DL+1	;TIME OUT AFTER 5 SECONDS
30$:	CALLX	GETTTY		;WATCH TERMINAL AND CLOCK
	TST	DSS$DL		;TIMEOUT?
	BPL	40$		;YES, TREAT LIKE NONEXISTENT UNIT
	TSTB	(R1)		;CONTROLLER READY?
	BPL	30$		;NO, WAIT FOR IT
	BIT	#002000,(R1)	;OPERATION INCOMPLETE?
	BNE	40$		;YES, NONEXISTENT DRIVE
	MOV	RLMP(R1),R2	;GET THE DRIVE'S STATUS
	BIT	#000400,R2	;DRIVE SELECT ERROR (2 WITH SAME UNIT#)
	BNE	40$		;YES, TREAT LIKE NONEXISTENT DRIVE
	BIC	#^C<000200>,R2	;MASK TO DRIVE TYPE BIT
	BR	50$		;SKIP NONEXISTENT-DRIVE ENTRY
40$:	MOV	DLUMID-DL$SZL(R3),R2 ;GET USER DRIVE TYPE
	CMP	R2,#-1		;IS THERE ANY?
	BEQ	70$		;NO, REALLY NONEXISTENT DRIVE
50$:	MOV	DLUMID-DL$SZL(R3),R4 ;GET USER DRIVE TYPE FOR CHECKING
	CMP	R4,#-1		;DID HE CARE?
	BEQ	60$		;NO, IGNORE IT
	CMP	R4,R2		;YES, WAS HE RIGHT?
	BEQ	60$		;LOOKS OK, SO DON'T COMPLAIN
	CALL	UNTERR,R5,"DL	;HE WAS WRONG, TELL HIM WE'RE IGNORING HIM
60$:	BISB	BITBYT(R0),TYPTBL+RL.CSO ;MARK THAT THIS UNIT EXISTS
	MOV	#<256.*2.*20.>-20.,(R3) ;ASSUME RL01, SIZE = 10220
	MOV	R2,DL$MID-DL$SZL(R3) ;SET ITS 'MASSBUS ID'
	BEQ	70$		;WAS RL01, ALL OK
	MOV	#<512.*2.*20.>-20.,(R3) ;WAS RL02, SIZE = 20460
70$:	DEC	R0		;TRY ANOTHER UNIT
	BPL	20$
80$:	RETURN

GLOBAL	<DL$SZL,DL$MID,TYPTBL,RL.CSO,DSKCSR,DLUMID,BITBYT,DSS$DL>

.SBTTL	RMLOOK - DETERMINE RK06/RK07 DRIVE TYPE

RMLOOK:	MOV	#DM$SZL,R2	;POINT TO DM SIZE TABLE (LSB)
	MOV	#8.,R0		;WE'LL SET 8 NONEXISTENT UNITS
10$:	MOV	#-1,DM$MID-DM$SZL(R2) ;MID = -1 TO INDICATE NO UNIT
	CLR	(R2)+		;SIZE = 0 FOR NOW
	SOB	R0,10$
	CLR	TYPTBL+RM.CSO	;INDICATE NO UNITS FOR SYSGEN
	MOV	DSKCSR+IDX$DM,R1 ;POINT TO RK611 CONTROLLER
	BEQ	90$		;NO CONTROLLER -- WE'RE DONE
	MOV	#7,R4		;START BY TRYING UNIT 7
20$:	CLR	-(R2)		;BACK UP TABLE POINTER, ZERO ENTRY (AGAIN)
	CLR	R3		;ASSUME IT'S AN RK06
30$:	MOV	#RMSCLR,RMCS2(R1) ;SUBSYSTEM CLEAR
	MOV	R4,RMCS2(R1)	;SET UNIT NUMBER
	MOV	#1,R0		;COMMAND IS 'SELECT DRIVE'
	BIS	R3,R0		;COPY DRIVE TYPE BIT
	MOV	R0,(R1)		;ISSUE COMMAND
	MOVB	#-5,DSS$DM+1	;TIME OUT AFTER 5 SECONDS
40$:	CALLX	GETTTY		;WATCH TERMINAL AND CLOCK
	TST	DSS$DM		;TIMEOUT?
	BPL	50$		;YES -- TREAT LIKE NONEXISTENT DRIVE
	TSTB	(R1)		;UNTIL CONTROLLER READY
	BPL	40$
	TST	RMDS(R1)	;DRIVE STATUS VALID?
	BPL	50$		;NO -- ASSUME THERE'S NO DRIVE
	TST	(R1)		;ANY KIND OF ERROR?
	BPL	60$		;NO -- WE MUST HAVE CORRECT DRIVE TYPE
	BIT	#RMNED+RMMDS,RMCS2(R1) ;NONEXISTENT OR MULTIPLE DRIVE?
	BNE	50$		;YES -- DISABLE IT
	TST	R3		;DID WE TRY RK07 YET?
	BNE	50$		;YES, EVEN TYPE MISMATCH IS BAD
	MOV	#RMCDT,R3	;NO, GET THE RK07 TYPE BIT
	BIT	#RMDT,RMER(R1)	;DRIVE TYPE MISMATCH?
	BNE	30$		;TRY AGAIN WITH RK07
50$:	MOV	DMUMID-DM$SZL(R2),R3 ;NO DRIVE -- ACCEPT USER'S STATEMENT
	CMP	R3,#-1		;ANY USER DEFAULT?
	BEQ	80$		;NOPE, NO UNIT HERE
60$:	MOV	DMUMID-DM$SZL(R2),R0 ;GET USER DRIVE TYPE FOR CHECKING
	CMP	R0,#-1		;DID HE GIVE ONE?
	BEQ	70$		;NO -- DON'T BOTHER COMPARING
	CMP	R0,R3		;DID USER'S TYPE MATCH WHAT WE FOUND?
	BEQ	70$		;YES
	CALL	UNTERR,R5,"DM	;NO -- TELL THE USER WE'RE IGNORING HIM
70$:	BISB	BITBYT(R4),TYPTBL+RM.CSO ;MARK THAT IT EXISTS
	MOV	#27104.,(R2)	;ASSUME RK06 SIZE
	MOV	R3,DM$MID-DM$SZL(R2) ;SET MASSBUS ID
	BEQ	80$		;RK06 -- SET SIZE
	MOV	#53768.,(R2)	;RK07 SIZE
80$:	DEC	R4		;TRY ANOTHER UNIT
	BPL	20$
90$:	RETURN			;ALL DONE
GLOBAL	<DM$SZL,DM$MID,TYPTBL,RM.CSO,DSKCSR,DMUMID,BITBYT,DSS$DM>

.SBTTL	RPLOOK - DETERMINE RP02/RP03 DRIVE TYPE

RPLOOK:	MOV	#DP$SZL,R2	;POINT TO LSB DISK SIZE
	MOV	#DP$SZM,R3	;AND   TO MSB DISK SIZE
	MOV	#TYPTBL+RP.CSO,R5 ;GET AN ADDRESS			;041
	MOV	#8.,R0		;INITIALLY, CLEAR THEM
10$:	MOV	#-1,DP$MID-DP$SZL(R2) ;FLAG NO UNIT HERE
	CLR	(R2)+
	CLR	(R3)+
	SOB	R0,10$
	CLR	(R5)		;CLEAR OUT THE INDICATOR TO START	;041
	TST	DSKCSR+IDX$DP	;IS THERE AN RP03 CONTROLLER?
	BEQ	60$		;NO, DONE
	MOV	#7,R4		;START WITH UNIT 7
20$:	CLR	-(R2)		;INITIALLY NO DEVICE HERE
	CLR	-(R3)
	MOV	#IDX$DP,R1	;R1 = DISK INDEX; R4 = UNIT #
	CALLX	XXRSET		;TRY RESETTING THE DRIVE
	MOV	#40000.,(R2)	;GUESS AT RP02 SIZE
	MOV	RPDS(R1),R0	;GET UNIT IDENTIFICATION
	BEQ	50$		; MUST BE SOMETHING THERE		;021
	BISB	BITBYT(R4),(R5)	;YES, SO FLAG IT AS FOUND		;041
	BIC	#^C<020000>,R0	;ISOLATE THE RP03 BIT
	BEQ	40$		;BUT IF ZERO, THEN RP02 GUESS IS CORRECT ;041
	ASL	(R2)		;SET RP03 SIZE = 80000. BLOCKS
	ROL	(R3)
40$:	MOV	R0,DP$MID-DP$SZL(R2) ;SAVE THE ID WORD
50$:	DEC	R4		;DOWN TO NEXT UNIT
	BPL	20$		;REPEAT IF MORE
	TSTB	(R5)		;DID WE FIND ANY?			;041
	BNE	60$		;YES, THEN USE THEM			;041
	BISB	#200,(R5)	; NO, SO MAKE IT LOOK LIKE IT USED TO	;041
60$:	RETURN

GLOBAL	<DP$SZL,DP$SZM,DP$MID,DSKCSR,TYPTBL,RP.CSO>

.SBTTL	RBLOOK, RRLOOK - DETERMINE RP04/05/06/RM02/03 DRIVE TYPE

.ENABL	LSB

RBLOOK:	MOV	#IDX$DB,R0	;DISK TYPE INDEX HELPS US FIND TABLES
	MOV	#DBUMID,R5	;BUT THIS ONE ISN'T INDEXED
	BR	10$

RRLOOK:	MOV	#IDX$DR,R0	;DISK TYPE INDEX
	MOV	#DRUMID,R5	;USER-SPECIFIED DRIVE TYPES
10$:	CMP	#RB.CSO,#IDX$DB+2 ;We depend on this relation
	BNE	95$		;Die if it's wrong
	CMP	#RR.CSO,#IDX$DR+2 ;Same here
	BNE	95$
	MOV	#8.,R1		;CLEAR 8 UNITS
	MOV	DSKMID(R0),R2	;MASSBUS ID TABLE
	MOV	DSKSZL(R0),R3	;LSB SIZE TABLE
	MOV	DSKSZM(R0),R4	;MSB SIZE TABLE
20$:	MOV	#-1,(R2)+	;MASSBUS ID OF NONEXISTENT DRIVE
	CLR	(R3)+		;LSB SIZE
	CLR	(R4)+		;MSB SIZE
	TST	(R5)+		;BUMP POINTER TO USER-SPECIFIED STUFF
	SOB	R1,20$		;REPEAT FOR 8 UNITS
	CLR	TYPTBL+2(R0)	;MARK NO EXISTENT UNITS
	TST	DSKCSR(R0)	;IS THERE A CONTROLLER?
	BEQ	90$		;NO -- ALL DONE
	MOV	#7,R4		;START WITH UNIT #7
30$:	TST	-(R5)		;KEEP THIS POINTER CURRENT
	MOV	DSKCSR(R0),R1	;GET CSR ADDRESS
	MOV	#RHCLR,RHCS2(R1) ;CLEAR CONTROLLER
	MOV	R4,RHCS2(R1)	;SELECT A UNIT
	MOV	RHDT(R1),R3	;GET MASSBUS ID
	BIT	#RHMCPE,(R1)	;MASSBUS PARITY ERROR?
	BNE	40$		;YES -- TREAT AS NONEXISTENT DRIVE
	BIT	#RHNED,RHCS2(R1) ;NONEXISTENT DRIVE?
	BNE	40$		;YES, USE USERS'S INPUT
	BIT	#RHDPR,RHDS(R1)	;IS DISK DRIVE PRESENT?
	BNE	50$		;YES -- SKIP
40$:	MOV	(R5),R3		;NONEXISTENT DRIVE -- USE USER'S INPUT
	CMP	R3,#-1		;IF THERE ISN'T ONE...
	BEQ	80$		; THEN THE DRIVE REALLY ISN'T THERE
50$:	MOV	R3,R2		;COPY MASSBUS ID
	BIC	#004000,R2	;IGNORE DUAL-PORT BIT FOR COMPARISON
	SUB	#020020,R2	;GET ID IN RANGE
	CMP	R2,#27		;ONLY 0-27 HAVE ANY CHANCE
	BHI	80$		;NO -- REALLY NOT OUR KIND OF DISK
	ASL	R2		;MAKE A WORD INDEX FROM MASSBUS ID
	MOV	R4,R1		;COPY UNIT NUMBER
	ASL	R1		;MAKE WORD INDEX FROM UNIT NUMBER
	ADD	DSKSZM(R0),R1	;R1 -> MSB SIZE TABLE ENTRY FOR THIS UNIT
	MOV	100$(R2),(R1)	;COPY FROM TABLE BELOW
	BEQ	80$		;NOT A VALID TYPE OF DISK

GLOBAL	<DBUMID,DRUMID,RB.CSO,RR.CSO,DSKMID,DSKSZL,DSKSZM,TYPTBL,DSKCSR>

	ASL	R4		;DOUBLE UNIT NUMBER TO SIMPLIFY INDEXING
	MOV	R4,R1		;COPY 2*UNIT
	ADD	DSKSZL(R0),R1	;R1 -> LSB SIZE FOR THIS UNIT
	MOV	110$(R2),(R1)	;SET FROM TABLE BELOW
	MOV	R4,R1		;COPY 2*UNIT
	ADD	DSKDCS(R0),R1	;R1 -> DEVICE CLUSTER SIZE FOR THIS UNIT
	MOV	120$(R2),(R1)	;SET FROM TABLE BELOW
	MOV	R4,R1		;COPY 2*UNIT
	ADD	DSKMID(R0),R1	;R1 -> MASSBUS ID FOR THIS UNIT
	MOV	R3,(R1)		;SET FROM CONTROLLER OR USER INPUT
	ASR	R4		;R4 = UNIT NUMBER, NO LONGER *2
	BISB	BITBYT(R4),TYPTBL+2(R0) ;MARK THAT THIS UNIT EXISTS FOR SYSGEN
	BIT	R3,#004000	;WAS UNIT DUAL-PORTED?
	BEQ	60$		;NO -- SKIP
	MOVB	R4,150$		;YES -- SET UNIT NUMBER
	BISB	#'0,150$	;MAKE ASCII
	MOV	DSKNAM(R0),140$	;SET NAME OF CONTROLLER (DB OR DR)
	CALLX	MESSAGE,R5,130$ ;ANNOUNCE DUAL PORTED DRIVE
60$:	CMP	(R5),#-1	;DID USER SET A TYPE FOR THIS DRIVE?
	BEQ	80$		;NO -- NO CHECK NEEDED
	CMP	(R5),R3		;YES -- WAS HE RIGHT?
	BEQ	80$		;YES -- ALL IS WELL
	MOV	DSKNAM(R0),70$	;NO -- TELL HIM WE IGNORED HIS INPUT
	CALL	UNTERR,R5	;ERROR IN USER UNIT SET
70$:	 .WORD	"XX		;FILL IN CONTROLLER NAME HERE
80$:	DEC	R4		;TRY NEXT DRIVE
	BPL	30$		;IF ANY
90$:	RETURN			;ALL DONE

95$:	ERF	<"RP/RR disk index consistency check failed">

GLOBAL	<DSKSZL,DSKDCS,DSKMID,BITBYT,TYPTBL,DSKNAM>

.NLIST	BEX

;+
;
;	DISK DRIVE SIZE TABLES -- ORDER IS SIGNIFICANT! (by Massbus ID)
;
;	The drive size tables are used to calculate the last
;	RSTS/E addressable block on the disk. In most cases, this
;	will be the block just before the DEC std. 144 bad block
;	file (DEC Std. 144 requires Bad Sector file to be on last
;	track of last cylinder). In that case, the algorithm is:
;
;	(#Cyls * #Trks/Cyl * #Secs/Trk) - (1 * #Secs/Trk)
;
;	Since the Bad Block file begins on the last track of the last
;	cylinder.							;002
;
;	Disk	Decimal	 Octal	Octal	#Cyls/	#Trks/	#Secs/	Clustr DEC Std
;	Name	 Size	  MSB	 LSB	 Pack	 Cyl	 Trk	 Size	  144
;
;	RP04	171798.	    2	117424	411	  19	  22	   4	  no
;	RP05	171798.	    2	117424	411	  19	  22	   4	  no
;	RP06	344014.	    5	 31270	815	  19	  22	   8	  no
;	RP07   1008000.	   17	 60600	630	  32	  50	  16	  yes
;	RM02	131680.	    2	  1140	823	   5	  32	   4	  yes
;	RM03	131680.	    2	  1140	823	   5	  32	   4	  yes
;	RM05	500384.	   10	121240	823	  19	  32	   8	  yes
;	RM80	242606.	    3	131535	559(561)  14	  31(32)   4	  yes
;-

;	MSB SIZES FOR RB/RR CONTROLLER DISKS

100$:	.WORD	    2.,    2.,    5.,    0.	;RP04, RP05, RP06, ?
	.WORD	    2.,    2.,    3.,    7.	;RM03, RM02, RM80, RM05
	.WORD	    0.,    0.,    0.,    0.	;?, ?, ?, ?
	.WORD	    0.,    0.,    0.,    0.	;?, ?, ?, ?
	.WORD	    0.,    0.,   15.,    0.	;?, ?, RP07, ?
	.WORD	    0.,    0.,    0.,    0.	;?, ?, ?, ?

;	LSB SIZE

110$:	.WORD	40724.,40724.,12984.,    0.	;RP04, RP05, RP06, ?
	.WORD	  576.,  576.,45967.,41600.	;RM03, RM02, RM80, RM05
	.WORD	    0.,    0.,    0.,    0.	;?, ?, ?, ?
	.WORD	    0.,    0.,    0.,    0.	;?, ?, ?, ?
	.WORD	    0.,    0.,24910.,    0.	;?, ?, RP07, ?
	.WORD	    0.,    0.,    0.,    0.	;?, ?, ?, ?

;	DCS

120$:	.WORD	    4.,    4.,    8.,    0.	;RP04, RP05, RP06, ?
	.WORD	    4.,    4.,    4.,    8.	;RM03, RM02, RM80, RM05
	.WORD	    0.,    0.,    0.,    0.	;?, ?, ?, ?
	.WORD	    0.,    0.,    0.,    0.	;?, ?, ?, ?
	.WORD	    0.,    0.,   16.,    0.	;?, ?, RP07, ?
	.WORD	    0.,    0.,    0.,    0.	;?, ?, ?, ?


130$:	.ASCII	<200>"Warning ** "
140$:	.WORD	"XX
150$:	.ASCIZ	"0: is dual ported, proceed with caution!"<200>
	.EVEN

.LIST	BEX

.DSABL	LSB

.SBTTL	UQLOOK - DETERMINE UQ PORT MEDIA TYPES				;024

.ENABL	LSB

UQLOOK:	NOP			;For debugging
	MOV	#DU.UNC,R5	;R5 = Highest disk unit number		;024
	MOV	#DU$MID,R4	;R4 -> DU Media ID table
	MOV	#DU$MNM,R3	;R3 -> DU Media name table
	CLR	R0		;Initialize unit index
10$:	MOV	#-1.,(R4)+	;Pre-set table with unknown units
	CLR	(R3)+		; and no name
	CLR	(R3)+		;  which is stored in doublewords
	CLR	DU$SZL(R0)	;Indicate no size yet
	CLR	DU$SZM(R0)	; in either word
	CLR	DU$DCS(R0)	;No currently computed DCS		;024
	TST	(R0)+		;Bump the index
	SOB	R5,10$		;Do all units
	MOV	#MU.UNC,R5	;R5 = Highest tape unit number		;024
	MOV	#MU$MNM,R3	;R3 -> MU Media name table		;024
20$:	CLR	(R3)+		; No name yet				;024
	CLR	(R3)+		;  which is stored in doublewords	;024
	SOB	R5,20$		;Do all units				;024
	;CLR	R5		;Start with controller zero.
	CLR	R4		;R4 = Virtual controller number		;024
30$:	MOV	R5,R0		;Copy controller number *2
	ASR	R0		;Now * 1
	MOV	R0,R2		;Copy controller * 1			;024
	CMP	R2,#DU.MAX	;Is this a disk or tape controller?	;024
	BLO	40$		;Disk, so RUx: is correct		;024
	MOVB	#'M,RUNAM	;Tape, change RUx: to MUx:		;024
	SUB	#DU.MAX,R0	;...fix controller number too		;024
40$:	ADD	#'0,R0		;Convert to ASCII
	MOVB	R0,RUNUM	;Store it into message			;024
	CLRB	UQCMT(R2)	;Say controller is unknown type		;024
	CLR	UQ$REV(R5)	;Say controller is unknown revision	;042
	MOV	CSRTBL+RU.CSO(R5),R3 ;Is there a controller out there?	;024
	BPL	125$		;No, check for others (without doing the;052
				; CF.DSK/CF.TAP flag check).		;052

;+									;070+
;	Check controllers for disk/tape units.
;
; The UQSTEP routine returns with the controller model code in UQCID.
; We use that to look up the controller's UQFLAG value.  This value is
; then copied into UQCFLG, which is a byte table having one byte for
; each possible [T]MSCP controller on the system.
;
; As we scan through the controllers, we check UQCFLG for that controller.
; If the flag is set saying it will handle disk units, we look for disk
; units on it; likewise for tapes.  If UQCFLG shows that the controller
; supports disks (or tapes), but when we ask for disk (or tape) units the
; controller rejects the request, we then clear the CF.DSK (or CF.TAP)
; flag in UQCFLG (this is done by UQSCC).
;
; After looking for disk and/or tape units, we then check UQCFLG to see if
; either CF.DSK or CF.TAP is set.  If not, then we say the controller is
; broken and skip it.
;
; If the controller responded correctly to disk and/or tape connects,
; and no other errors happened, we count it as good.
;
; Later, INICMT will get the UQCFLG entry and will put it into the
; CMT CM.FLG byte for this controller's CMT.
;
;-									;070-

	CALL	UQSTEP		;Go through 4-step initialization.	;052
	BCS	128$		;Controller is sick - skip it.		;068
	CLR	R1		;Select MSCP (disk) connect ID.		;070
	CLR	R0		;Get controller model code...		;070
	BISB	UQCID,R0	; ...without sign extend.		;070
	MOVB	UQFLAG(R0),UQCFLG(R2)					;070
				;Save working copy of flags in UQCFLG.	;070
	BEQ	130$		;UNSUPPORTED, so skip it.		;070
	BPL	50$		;Doesn't support disks, go try tapes.	;070
.ASSUME	CF.DSK	EQ 200							;053
	CALL	UQUNIT		;Yes, go find all disk units.		;052
	BCS	128$		;If evil happened, go disable controller;068
50$:	INC	R1		;Select TMSCP (tape) connect ID.	;052
	BITB	#CF.TAP,UQCFLG(R2)					;070
				;Does this controller support tapes?	;070
	BEQ	90$		;No, so on to next controller.		;052
	CALL	UQUNIT		;Find all the tape units		;052
	BCS	128$		;If evil happened, go disable controller;070

	TMPORG	ONECTL							;070
									;070
UQCFLG:	.BLKB0	DU.MAX+MU.MAX		;Controller flags - indexed by	;070
	.EVEN				; controller number * 1		;070
	UNORG								;070

GLOBAL	<DU.UNC,DU$MID,DU$MNM,RU.CSO,DU$SZL,DU$SZM,DU$DCS>		;070
GLOBAL	<MU.UNC,MU$MNM,UQCMT,CSRTBL>					;070


;+									;064+
; Here we check to see if the tape controller is in revision.  If it
; isn't, then we do one of the following;
;
;	Rev 3 and older and;
;		Boot device : print message and hang.
;		Normal device : print message and disable.
;
;	Rev 4;
;		Always print warning message.  No disable.
;
;-									;064-

	TSTB	FLGQBU		;Q-Bus?					;042
	BMI	90$		;No, don't worry			;042
	CMPB	UQCMT(R2),#9.	;TQK50?					;042
	BNE	90$		;Nope.					;042
	CMPB	UQ$REV(R5),#4	;Software rev <= 4?			;064
	BHI	90$		;Nope.					;064
	CALLX	MESSAG,R5,RUNAM	;Print controller name			;064
	MESSAGE
	 .ASCII	" is missing the following FCO:"<200>
	 .ASCIZ "  TQK50-R002 (EQ-01494-01)"<200>
	UNORG
	CMPB	UQ$REV(R5),#3	;Software rev <=3?			;064
	BHI	90$		;No, it is 4.  Warning will suffice.	;064
	MOV	#-1,UQ$REV(R5)	;yes, Flag it as bad			;064
	CMP	CSRTBL+RU.CSO(R5),@#B.CSR ;Booted from this TK50?	;064
	BNE	70$		;No, disable it to continue		;064
	MESSAGE			;Yes, give message and HALT		;064
	 .ASCII <7><7><7><200>"BOOT cannot continue from this"		;064
	 .ASCIZ <200>"drive unless missing FCO is applied."<200><200>	;064
	 UNORG								;064
60$:	BR	60$		;Die (loop forever)			;064

70$:	MESSAGE	<<200>"Device disabled."<200>>				;064
	BR	110$		;Join up				;064

GLOBAL	<UQ$REV,CPTYP,JCPTYP,FLGQBU,NOSTAR,MICRO>			;070


;+									;052+
;	Here's where we end up if the controller was OK.
;-									;052-
90$:	INC	R4		;Count controller as present		;042
	CLR	@CSRTBL+RU.CSO(R5)
				;Break the virtual circuit for this guy ;042
	BR	120$		;On to next controller			;042

;+									;052+
;	Here's where we end up if the controller was sick, and we
;	want to disable it.
;-									;052-
110$:	CLR	@CSRTBL+RU.CSO(R5)
				;Break the virtual circuit for this guy ;042
	CLR	CSRTBL+RU.CSO(R5) ;Disable the controller		;042
	BR	125$		;Skip the flag check (if it's broken,	;052
				; we don't care whether it responded	;052
				; to SCC commands or not!)		;052

;+									;052+
;	Here to go check the next controller.
;-									;052-
120$:	BITB	#CF.DSK!CF.TAP,UQCFLG(R2)				;070
				;Did either kind of connect work OK?	;052
	BEQ	140$		;No, so controller is broken!!		;052
125$:	TST	(R5)+		;Set next UQ port controller number * 2	;024
	CMP	R5,#<DU.MAX+MU.MAX>*2	;More to do?			;024
	BLO	30$		;Yes, go to it
	CALL	INICMT		;Initialize the CMT
	CALL	INIUMT		;CMT initialized.  Initialize the UMT tables
	RETURN		 	;  and then it's Miller time!

;+									;052+
;	Here, we handle a couple of different fatal errors.
;-									;052-

128$:	CALLX	MESSAGE,R5,RUNAM	;Print controller name.		;068
	MESSAGE	<" failed during units lookup">				;068
	BR	135$							;068

130$:	CALLX	MESSAGE,R5,RUNAM	;Print controller name.		;052
	MESSAGE <" controller type is UNSUPPORTED by RSTS/E">		;052
135$:	CALLX	MESSAGE,R5,DEVDIS	;Say it's disabled.		;052
	BR	110$			;And go disable it for real.	;052

140$:	CALLX	MESSAGE,R5,RUNAM	;Print controller name.		;052
	MESSAGE	<" does not respond to disk or tape connects">		;052
	BR	135$			;Finish up the error.		;052

GLOBAL	<RU.CSO,CSRTBL>							;070


.ENABL	LSB								;052+
;+
;	UQUNIT - Get information about units on a controller.
;
; Data passed:		R1 = Connect ID (0=disk, 1=tape)
;			R2 = Controller number * 1			;070
;			R5 = Controller number * 2 (which -> CSR table	;070
;				entry for this controller).		;070
;
; Data returned:
;			DU.TBL or MU.TBL updated to include all units
;			on this controller.
;
;			C=0	Success
;			C=1	Some fatal error occurred
;
; All registers preserved.
;-									;052-

UQUNIT:	PUSH	<R0,R3,R4>	;Get a couple of work registers.	;052
				; Note: R4 must be on top of the stack	;052
				; (see below).				;052
	MOV	#-1,R4		;Set up to look for unit # 0		;024
10$:	CALL	UQSCC		;Get controller online and set up.	;052
	BLOS	70$		;Fatal error, skip to next controller.	;070
				; (BLOS is (C=1 or Z=1))		;070
20$:	INC	R4		;Get next unit # to look for
	MOV	CSRTBL+RU.CSO(R5),R3 ;Set R3 to this controller's CSR	;024
	CALL	UINFO		;Get info for this unit (or next higher one)
	BCS	70$		;If fatal error, go on to next controller
	CMP	R4,#-1		;Did we find anything more?
	BEQ	70$		;No, on to the next controller (C Clear)
	TST	DSS$DV		;Did this command crap-out on us?
	BPL	10$		;Yes, then we don't have valid unit info;024
	MOV	#DU.TBL,R0	;Assume we're looking at disks		;024
	TST	R1		;Are we?				;024
	BEQ	30$		;Yep					;024
	MOV	#MU.TBL,R0	;Tapes, change our table pointer	;024
30$:	CMP	R4,(R0)+	;Legal unit number?			;024
	BHIS	60$		;No, too high for RSTS, give message
	MOV	(R0)+,R3	;Get pointer to unit map table		;024
	ADD	R4,R3		;R3 -> Controller number for this unit	;024
	TSTB	(R3)		;Already a unit here?			;024
	BPL	80$		;Yes, error
	MOVB	(SP),(R3)	;Set this unit number as "IN USE"	;024
				;Flag byte is the virtual controller #	;045
				; (This is why R4 must be on top of the	;052
				; stack...)				;052
	MOV	R4,R3		;Copy unit number
	ASL	R3		;Convert to unit *2
	TST	R1		;Doing disks?				;024
	BNE	40$		;No, tapes				;024
	MOV	#7777,DU$SZL(R3) ;Fake a low order size to allow access	;024
	INC	DU$MID(R3)	;Indicate unit present
40$:	ASL	R3		;Now unit *4				;024
	ADD	(R0)+,R3	;R3 -> Media name table			;024
	MOV	RMSG+P.MEDI,(R3)+ ;Set low order			;024
	MOV	RMSG+P.MEDI+2,(R3)+ ; and high order
	BR	20$		;Go look for another unit		;024

60$:	CALL	UQERR,R5	;Print unit error message		;024
	GENTXT	<" - Unit number is too large">				;055
	CLC			;Indicate controller still OK		;024
70$:	POP	<R4,R3,R0>	;Get original registers back.		;052
	RETURN			;Done with this controller		;024

80$:	CALL	UQERR,R5	;Print unit error message		;024
	GENTXT	<" is duplicated on another controller">		;024
	BR	20$		;On to next unit

.DSABL	LSB

GLOBAL	<DU.UNC,DU$MNM,DU$SZL,DU$MID,MU.UNC,MU$MNM,DSS$DS>		;070

	TMPORG	ONECTL

DU.TBL:	.WORD	DU.UNC,DUMAP,DU$MNM					;024
MU.TBL:	.WORD	MU.UNC,MUMAP,MU$MNM					;024

RUNAM:	.ASCII	"RU"
RUNUM:	.ASCIZ	"0:"							;024
	.EVEN

DUMAP:	.BLKB0	256.,-1.	;ENOUGH FOR ALL POSSIBLE UNITS, PRESET WITH -1
MUMAP:	.BLKB0	256.,-1.	;Enough for all possible units, preset with -1
	.EVEN
	UNORG

.SBTTL	U/Q port initialization						;024

.ENABL	LSB								;052+
;+
;	UQSTEP - Perform 4-Step Initialization
;
; Data passed:		R3 -> Controller IP register
;
; Data returned:	UQCID contains "real" controller model
;			code from UQCVT table (see UQDEF macro).
;
;			C=0	Success
;			C=1	Failure
;
; All registers preserved on normal exit (C clear).			;053
; R3 -> SA register on error exit (C set).				;053
;
;-									;052-

UQSTEP:	REGSCR				;Save the world.		;052
	CLRB	RETRY			;Say this is our first time.	;052

;
;	bring the U/Q port controller on-line				;024
;
10$:	MOV	#UQ4STP,R2		;GET => to U/Q INIT word table.	;068
	MOV	#4000,R0		;R0 = UQ'S 1ST STEP BIT INDICATOR ;045
	CLR	(R3)+			;WRITE INTO THE IP CSR TO INIT CNTRLR
	MOVB	#-16.,UQPTMO		;Set timeout value of ~ 15 secs.;045
20$:	MOVB	UQPTMO,DSS$DS+1		;Set time-out for this step 	;045
30$:	TST	(R3)			;CHECK THE SA CSR FOR AN ERROR.
	BMI	50$			;If so, go retry or die!!	;052
	CALLX	GETTTY			;UPDATE THE CLOCK
	TST	DSS$DS			;IS HE TAKING TOO LONG?
	BPL	200$			;Yes, fatal controller error.	;045
	BIT	(R3),R0			;IS THE UQ READY FOR NEXT STEP?	;024
	BEQ	30$			;NO, LOOP UNTIL READY OR ERROR.
	BIT	R0,#40000		;Are we ready to do Step 4?	;052
	BEQ	40$			;No, so just go on.		;052
;+
; At the beginning of Step 4, the controller returns a model code in	;070+
; the SA register.  This is not the same model code as the one returned
; by most other [T]MSCP commands; we refer to it here at the Step 4
; model code.  In order to get the "real" model code, we use the Step
; 4 model code to index into the UQCVT table (which is built by the
; UQDEF macro).  The UQCVT entry contains the "real" model code, which
; we then return in UQCID.
;-									;070-
	MOV	(R3),R1			;Save contents of CSR...	;052
	ASH	#-4,R1			;Right-justify Model ID code.	;052
	BIC	#^C<S4CIDM>,R1		;Clear out unwanted bits.	;052
	MOVB	UQCVT(R1),UQCID		;Get real model code from UQCVT.;070
40$:	MOV	(R2)+,(R3)		;READY, ISSUE THE NEXT INIT COMMAND
	ASL	R0			;  AND SHIFT TO NEXT STEP INDICATOR.
	BPL	20$			;Loop until all 4 steps done	;045
	RETURN				;And then, go back.		;052

50$:	TSTB	RETRY			;Have we already tried this?	;052
	BNE	100$			;Yup, so exit unhappily.	;052
	COMB	RETRY			;We never pass this way again...;052
	SUB	#2,R3			;Point R3 back to IP register.	;053
	BR	10$			;Try again.			;052

;+									;053+
; Note:
;	Notice that an actual SUB instruction is used to decrement R3
;	instead of the more usual TST -(R3) construct.  This is done
;	to avoid a read access of the SA register; normally, this would
;	have no ill effects, but since we only get here in the event of
;	a controller error, the controller may be in a funny state and
;	accessing the SA register may cause unpredictable results.
;
;-									;053-

	TMPORG	ONECTL							;052
UQCID:	.BLKB				;Controller model code.		;052
RETRY:	.BLKB				;Retry flag.			;052
	.EVEN								;052
	UNORG								;052

;+									;070+
;	UQSCC - Set U/Q Port controller characteristics
;
; Data passed:	R1 = Connect ID (0=disk, 1=tape)
;		R2 = Controller number
;		R3 -> IP register
;		R5 = Controller number * 2
;
; Data returned:
;	C = 1	Fatal error of some sort.
;		An appropriate error message is printed.
;	C = 0	Controller worked OK, and...
;		Z = 0	Controller did accept connections for this
;			connect ID.
;		Z = 1	Controller did NOT accept connections for this
;			connect ID.  Corresponding bit in UQCFLG is
;			cleared.
;
; If C = 0, all registers preserved.
; If C = 1, R0 random, all others preserved.
;
; Note that this routine depends on having virtual address = physical address
; (i.e. it does not do any work to map one to the other).  So long as it lives
; in INIT's root or in an ordinary overlay segment this will be the case.
;-									;070-

UQSCC:	MOVB	#OP.SCC,RCMD+P.OPCD	;Put 'SCC' opcode in place.	;052
	CLR	RCMD+P.MOD		; No modifiers			;022
	CLR	RCMD+P.UNIT		; No unit field for an SCC	;022
	CLR	RCMD+P.CNTF		;CLEAR ALL CONTROLLER FLAGS,
	CLR	RCMD+P.HTMO		;  DISABLE HOST TIMEOUTS
	CALL	UQIO			;    AND ISSUE THE COMMAND.
	BCS	80$			;Controller error, check it out	;024
	TST	DSS$DS			;Did it take too long?		;045
	BPL	300$			;Yes, fatal controller error.	;052
	MOV	RMSG+22,UQ$REV(R5)	;Save hard & soft rev levels	;042
	MOVB	RMSG+P.CNTI+6,UQCMT(R2)	;Copy controller model value	;024
	MOVB	RMSG+P.HTMO,UQPTMO	;Copy controller timeout value	;016
	INCB	UQPTMO			;Add one for us			;044
	BGT	60$			;Less than 128, fine		;044
	MOVB	#127.,UQPTMO		;Greater than 127, we can't do it ;016
60$:	NEGB	UQPTMO			;Make it negative for DDS$DS	;016
	CLC				;Otherwise exit smiling		;018
	CLZ				;Really!			;070
70$:	RETURN				;All done

80$:	PUSH	<R0>			;Save R0.			;070
	MOV	2(R3),R0		;Get contents of SA register.	;052
	BIC	#^C<3777>,R0		;Error code in bits 0-10 of SA	;052
	CMP	R0,#14.			;Was it Invalid Connection ID?	;052
	BNE	95$			;No, so go print real error.	;070
	MOV	#CF.DSK,R0		;Put disk connect ID into R0.	;052
	TST	R1			;Did we try a disk connect?	;052
	BEQ	90$			;Yes, so leave R0 alone.	;052
	ROR	R0			;Otherwise, change disk connect	;052
					; ID into tape connect ID.	;052
.ASSUME	CF.TAP	EQ <CF.DSK/2>						;052
90$:	BICB	R0,UQCFLG(R2)		;Say we can't do this type.	;070
	POP	<R0>			;Get original R0 back.		;070
	CALL	UQSTEP			;Re-init controller.		;070
	BCS	70$			;Leave unhappily if this dies!	;070
	CLC				;Controller worked, but...	;070
	SEZ				; ...connect ID was bogus.	;070
	RETURN				;Exit fairly happily.

95$:	TST	(SP)+			;Clean up stack, leave R0 alone.;070
	BR	110$			;Join common error code.	;070

;+
;Let's pray that the controller returned time out value doesn't exceed 127,
;if it does, we'll have to use 127 since DDS$DS is a byte and we need the
;sign bit to signal timeouts.  Luckily, UQ-Port timeouts will never be
;greater than one signed byte (255)
;-

;+									;052+
;	Common Error Handling for UQSTEP and UQSCC
;
; At this point:
;			R3 should -> controller SA register.
;-									;052-

100$:	MOV	(R3),R0			;Grab the SA			;024
	BIC	#^C<3777>,R0		;Error code in bits 0-10 of SA	;024
110$:	CALLX	MESSAGE,R5,RUNAM	;Print controller name		;024
	CALLX	MESSAGE,R5,MDIAGF	;Say that it's not working	;024
120$:	CALLX	MESSAGE,R5,MDIAGC	;Say why it's not working	;048
130$:	CALLX	OCTWRD			;Print the error code		;052
140$:	CALLX	MESSAGE,R5,DEVDIS	;Say we're disabling it		;053
	SEC				;Exit unhappily			;052
	RETURN								;052

200$:	CALLX	MESSAGE,R5,RUNAM	;Print controller name.		;052
	MESSAGE	<" timeout during ">,TIMOUT				;052
	MESSAGE	<"initialization, step ">;Say when it happened.		;052
	SWAB	R0			;Put step bit in lower byte...	;053
	ASH	#-3,R0			; ...and right justify.		;053
	CLR	R2			;Initialize a counter.		;053
210$:	ROR	R0			;Rotate a bit into the carry.	;053
	INC	R2			;Say we did another.		;053
	BCC	210$			;If C is still clear, try again.;053
	MOV	R2,R0			;R0 = step number.		;053
	BR	130$			;Finish up.			;053

300$:	CALLX	MESSAGE,R5,RUNAM	;Print controller name		;045
	CALLX	MESSAGE,R5,TIMOUT	;Say what happened.		;052
	TST	R1			;Was it a disk connect??	;053
	BEQ	310$			;Yup, so go print "disk".	;053
	MESSAG	<"tape ">		;Otherwise, it's "tape".	;053
	BR	320$			;Join common code.		;053

310$:	MESSAG	<"disk ">		;You guessed it!		;053
320$:	MESSAGE	<"SCC">			;Say when it happened.		;053
	BR	140$			;Finish up.			;053

GLOBAL	<DSS$DS,UQCMT>

.DSABL	LSB								;052

	TMPORG	ONECTL
UQPTMO:	.BLKB				;Timeout value for I/O		;016
	.EVEN								;016
	UNORG

.SBTTL	Get unit info

;+
; This routine is used by UQLOOK to scan through the units on a controller
; and obtain information about them.  Given a unit number, it obtains info
; for that unit or the next higher numbered one.
;
;	R1 =	Connection ID (0 for disk, 1 for tape)			;024
;	R3 ->	IP Register						;052
;	R4 = 	Unit number to start at
;
;	CALL	UINFO
;
;	C = 0	Controller OK
;		R4 =	Unit number (-1 if none left)
;
;	C = 1	Controller dead
;
; All registers preserved.
;-

.ENABL	LSB

UINFO:	REGSCR			;Save registers
10$:	CMP	R4,#255.	;Unit number still in range?		;024
	BHI	40$		;No, leave (done scanning)		;024
	MOV	#OP.GUS,RCMD+P.OPCD	;GET THE UNIT'S STATUS
	MOV	#MD.NXU,RCMD+P.MOD	; Modifier = next unit
	MOV	R4,RCMD+P.UNIT	;LOAD THE UNIT NUMBER PASSED TO US
	CALL	UQIO		;    AND ISSUE THE COMMAND
	BCS	30$		;Controller error!			;024
	TST	DSS$DV		;Did the command time-out?
	BEQ	20$		;Unit timed out				;024
	CMP	RMSG+P.UNIT,R4	;What unit number came back?
	BLO	40$		;Lower, so we reached the end		;024
	MOV	RMSG+P.UNIT,R4	;Pick up the unit number found
	BIT	RMSG+P.STS,#SS.DUP ;Duplicate unit on controller?	;024
	BNE	50$		;Yes, error, skip this unit		;024
	TST	RMSG+P.UNTI+6	;Valid media name?			;024
	BEQ	60$		;No, since class/model bytes are zero	;024
20$:	MOV	R4,TOS.R4(SP)	;Info valid for this unit.  Update R4	;024
	CLC			;CLEAR CARRY FOR SUCCESS
30$:	RETURN			;Done

40$:	MOV	#-1,R4		;Indicate done with the scan
	BR	20$		;Exit

50$:	CALL	UQERR,R5	;Print controller, unit, and error text	;024
	GENTXT	<" found more than once on this controller">
60$:	INC	R4		;Skip this unit
	BR	10$		; and look for another one

.DSABL	LSB

;+
;
; Print error message for controller and unit
;
;	R4	=  Unit number
;	R5	=> Message text
;	RUNAM	=  Controller name, RUn: or MUn:
;
;	CALL	UQERR,R5,PTR
;
; Prints:	xxn: Unit xx 'message' - unit skipped
;
;-

UQERR:	CALLX	MESSAGE,R5,RUNAM	;Display controller name	;024
	MESSAG	<" Unit ">
	MOV	R4,R0			;Copy unit number
	CALLX	DECZER			;Print it
	MOV	(R5)+,R0		;Copy message text		;024
	CALLX	ASCIZ0			;Print message			;024
	MESSAGE	<" - Unit skipped"<200>>				;024
	RETURN	R5			;Done				;024

.SBTTL	UQIO - Perform I/O operation on an [T]MSCP class device		;024

;+
; UQIO - Issue an I/O request to a [T]MSCP device			;052
;
;	R1 =  Connection ID (0 for disk, 1 for tape)			;024
;	R3 -> IP register						;052
;
; All registers preserved.						;052
;-

UQIO:	PUSH	<R3,R5>			;Save us some work registers.	;052
	MOVB	R1,RCMD-1		;Select tape/disk connection ID	;024
	MOV	#<RLEN>,RCMD-4.		;Load the command packet length	;024
	MOV	#<RLEN>,RMSG-4.		;Load the response packet length
	MOV	#UQRING,R5		;Point to ring descriptor	;024
	MOV	#RMSG,(R5)+		;Set message packet address	;024
	MOV	#OWN,(R5)+		; high order = 0, controller owned ;024
	MOV	#RCMD,(R5)+		;Set command packet address	;024
	MOV	#OWN,(R5)		; high order = 0, controller owned ;024
	CMP	-(R5),-(R5)		;Point R5 to RESP ring flags	;024
	TST	(R3)+			;Now tell him to start polling.	;052
	MOVB	UQPTMO,DSS$DS+1		;Set time-out value from controller ;016
10$:	CALLX	GETTTY			;WATCH THE TERMINAL AND THE CLOCK
	TST	DSS$DS			;TIMEOUT?
	BPL	30$			;YES, UNIT ERROR.
	TST	(R3)			;Controller still online?	;052
	BMI	20$			;NO! FATAL CONTROLLER ERROR
	TST	(R5)			;Do we own the RESP packet yet?	;024
	BMI	10$			;NO, KEEP WAITING FOR RESPONSE
	BITB	#OP.END,RMSG+P.OPCD	;IS IT AN END PACKET MESSAGE
	BNE	30$			;YES, RETURN
	BIS	#OWN,(R5)		;No, it's an unsolicited MSG, so ;024
	BIC	#40000,(R5)		;  release ring, ignore message	;024
	BR	10$			;    AND KEEP WAITING

20$:	SEC				;SET FATAL ERROR
30$:	POP	<R5,R3>			;Get registers back.		;052
	RETURN				;RETURN TO OUR CALLER 


	TMPORG	ONECTL

;	Initialize and control table

UQ4STP:	.WORD	OWN			;RING SIZES DEFAULT TO LENGTH 1	;024
	.WORD	UQRING			;LOW ORDER DESC RING'S ADDRESS	;024
	.WORD	0			;HIGH ORDER DESC RING'S ADDRESS
	.WORD	GO			;GO BIT

;	Descriptor rings

	.BLKW	2
UQRING:	.BLKW	4							;024

;	Response packets

	.BLKW	2
RMSG::	.BLKB	60.
	.BLKW	2
RCMD:	.BLKB	60.
RLEN	=	. - RCMD

	UNORG

GLOBAL	<DSS$DS>

.SBTTL	INIUMT INITIALIZE THE UMT TABLES FOR [T]MSCP DEVICES

;+
;	INIUMT	Initialize the UMT tables for all [T]MSCP devices
;-

INIUMT:	MOV	#UMTTBL-2,R5	;Get a pointer to UMT setup table (-2)	;024
5$:	TST	(R5)+		;Point to next UMT device section	;024
	MOV	(R5)+,R3	;Get a pointer to unit map table	;024
	BNE	10$		;Got one, process it			;024
	RETURN			;Done with all the UMT's		;024

10$:	MOV	(R5)+,R4	;Get a pointer to the UMT table		;024
15$:	CLR	(R4)+	 	;CLEAR THE CONTROLLER OFFSET
	CLR	(R4)+	 	;PRESET UNKNOWN UNIT INDICATOR
	MOVB	(R3)+,R1	;Copy controller #			;024
	BMI	20$		;  IF MINUS THEN THIS IS AN UNKNOWN UNIT.
	MUL	#CMTSIZ,R1	;Compute the CMT offset for unit	;024
	COM	-(R4)		;INDICATE A KNOWN UNIT (NON 0 WILL DO)
	MOV	R1,-(R4)	;LOAD THE CMT TABLE OFFSET INTO THIS UMT ENTRY
	CMP	(R4)+,(R4)+	;  AND POINT TO NEXT UNIT ENTRY (R4+UMTSIZ)
20$:	CMP	R4,(R5)		;At end of this device's UMT table?	;024
	BLO	15$		;  NO,  DO THE NEXT UNIT
	BR	5$		;  Yes, now go do the next UMT device	;024

.ASSUME	UM.CMT	EQ	0
.ASSUME	UM.UCB	EQ	2
.ASSUME	UMTSIZ	EQ	4

TMPORG	ONECTL

UMTTBL:	.WORD	DUMAP,UMT$DU,UME$DU
	.WORD	MUMAP,UMT$MU,UME$MU	
	.WORD	0
UNORG

GLOBAL	<UMT$DU,UME$DU,UMT$MU,UME$MU>

.SBTTL	MSCP region size algorithms

;+
;	The MSCP region size varies depending upon controller and user
;	specified parameters. The following calculations use fixed
;	values for ring entries, No. of units per controller. The number
;	of units per controller and maximum command buffer used are
;	stored in a table.  The number of ring entries is normally
;	specified as a dynamic parameter that may increase controller
;	performance or decrease MSCP region size as needed. During
;	controller initialization, the ring size is specified as a power
;	of 2, therfore the number of ring entries must be a number 
;	representative of a power of 2.
;
;	FIXED:	RINGHD		(Size of the ring header area in bytes)
;
;	GIVEN:	RNGS		(No. of ring entries)
;		UNITS		(No. of units per controller = 4)
;-

REXP	=0
RNGS	=1

CRING=	<RNGS*<CMDLNG+RNGSIZ+ENVLP>>
RRING=	<RNGS*<RSPLNG+RNGSIZ+ENVLP>>
INIWKA=	<UCBSIZ*UNITS>+RINGHD+CRING+RRING+CCBSIZ

;+
;	INICMT WILL INITIALIZE THE CMT FOR USE WITHIN INIT ONLY
;
;	For each controller:
; 	 CM.WKA = The MSCP area in bytes allocated for controller
; 	 CM.CSR = The CSR assignment in CSRTBL
;	 CM.VEC = The vector assignment/2 in VECTBL (VECTBL HOLDS VEC/2)
;	 CM.FLG	= The flag byte for this controller.			;070
;	 CM.RSP = RING SIZE REPRESENTED AS A POWER OF 2 
;	 CM.CMD = RING SIZE REPRESENTED AS A POWER OF 2 
;	For the CMT header:
;	 CM.CRQ = -1. MSCP area needs initialization flag
;	 CM.IC6 = -1. 
;	 CM.BA6 = INIT'S MSCP REGION MMU
;	 CM.DCT is calculate by adding RU CSRs with a valid entry
;	 CM.CCT is calculate by adding RU/MU CSRs with a valid entry
;	 CM.AWS is calculated using a CM.CMD and CM.RSP value of 2
;-

.ENABL	LSB

INICMT:	CLR	R1			;R1 = controller number * 1	;070
	CLR	R2			;R2 = controller number * 2	;070
	MOV	#CMT,R3			;GET A POINTER TO THE CMT TABLE	
	MOV	#BBRSIZ+<<MU.MAX+DU.MAX>*INIWKA>,CM.AWS(R3)
					;LOAD INIT'S MSCP IN BYTES	;024
	CLR	CM.CCT(R3)		;COUNTROLLER COUNT INITIALLY ZERO
.ASSUME	CM.DCT	EQ <CM.CCT+1>		;...Both disk and total counts	;024
	MOV	MCPAP6,CM.BA6(R3)	;LOAD INIT'S MSCP REGION MMU	;008
	CLR	CM.QMR(R3)		;CLEAR CM.QMR IN CMT HEADER	;024
	MOV	#-1,CM.CRQ(R3)		;SAY CONTROLLER NEEDS INITIALIZATION;024
	MOV	#-1,CM.IC6(R3)		;PRESET "CONTROLER INITIALIZING" STATE
10$:	TST	CSRTBL+RU.CSO(R2)	;Is there a controller here?	;070
	BEQ	30$			;No, then move later ones up	;024
	ADD	#CM.WKA,R3		;POINT R3 AT WORK AREA OFFSET
	MOV	#INIWKA,(R3)		;LOAD THAT CNTRLR'S WORK AREA SIZE
	MOVB	UQCFLG(R1),R5		;Get the flag byte		;071
	BIC	#^C<CF.UNT>,R5		; but just the number of units	;071
	SUB	#4,R5			; that are not there		;071
	NEG	R5			; -(X-4)= # not there		;071
	MUL	#UCBSIZ,R5		; remove these UCBs		;071
	SUB	R5,(R3)+		; from the work area size	;071
	MOV	CSRTBL+RU.CSO(R2),(R3)+	;Load that controller's CSR (IP) ;070
.ASSUME	CM.CSR EQ <CM.WKA+2>
	INCB	CMT+CM.CCT		;Count total number of controllers ;024
	CMP	R1,#DU.MAX		;It this one disk or tape?	;024
	BHIS	20$			;Tape, no separate count	;024
	INCB	CMT+CM.DCT		;Count disk controllers		;024
20$:	CLR	R4			;start with a 0			;068
	BISB	VECTBL+RU.CSO(R2),R4	;Get Vector/2 for controller	;070
	ASR	R4			;  AND MAKE IT VEC/4
	MOVB	R4,(R3)+		;LOAD THE VEC/4
.ASSUME	CM.VTR EQ <CM.CSR+2>
	MOVB	UQCFLG(R1),(R3)+	;Stick flag byte away.		;070
.ASSUME	CM.FLG EQ <CM.VTR+1>
	MOVB	#REXP,(R3)		;SET DEFALT RESPONSE RING VALUE	
.ASSUME	CM.RSP EQ <CM.FLG+1>
	MOVB	(R3)+,(R3)+		;COMMAND RING VALUE INITIALLY THE SAME
.ASSUME	CM.CMD EQ <CM.RSP+1>
30$:	TST	(R2)+			;Next controller number * 2...	;070
	INC	R1			; ...and * 1			;070
	CMP	R1,#MU.MAX+DU.MAX	;Do we have more to do?		;024
	BLO	10$			;Yes, load the next entry	;024
	RETURN				;Done loading CMT table		;024

.DSABL	LSB

GLOBAL	<CMT,VECTBL,RU.CSO,MCPAP6,CSRTBL,UQCMT>

.SBTTL	UQCVT and UQFLAG - Model code conversion and flag tables
;+									;070+
; Both of these tables are filled in by the UQDEF macro.
;
; The UQCVT table is necessary because the controller model code returned
; in Step 4 is not the same as the model code that the controller normally
; uses to identify itself.  UQCVT is indexed using the Step 4 value, and it
; gives us the "real" model code for the controller.
;
; The UQFLAG table is 255. bytes long (one byte for each possible MSCP
; or TMSCP controller ID).  It is indexed by the "real" controller model
; code.  The entry contains info that describes that particular type of
; controller to us.  For example, the RQDX3 has a model code of 19.
; Indexing UQFLAG(19.) gives us the entry for the RQDX3.
;
; This byte is used as follows:
;	Bits 0-2	- Number of units allowed on this controller.
;	Bits 3,4,5	- Reserved.
;	Bit 6		- CF.TAP; flag indicating that this controller
;			  supports tape units.
;	Bit 7		- CF.DSK; flag indicating that this controller
;			  supports disk units.
;
; Because this info byte will eventually be put into CMT+CM.FLG for
; some controller, it has the same layout as CM.FLG (which is
; described in MSCPDF.MAC).
;
; Entries in the UQCVT table for undefined controller types will be zero.
; Conveniently enough, UQFLAG entry zero is defined as "UNASSIGNED", so if we
; get a Step 4 controller ID that we don't know about, we'll end up trying
; both disk and tape connects to it to see what we get!
;
; NOTE: Other controller model tables exist in INIHAR and ERRBLD
;
;-									;070-

	TMPORG	ONECTL
	.EVEN

S4CIDM	= 37				;This is the value used to mask	;052
					; out the controller ID in Step	;052
					; 4 of the initialization.	;052

UQCVT:	.BLKB0	S4CIDM			;Used to convert the model code	;052
					; returned in Step 4 to the	;052
					; "real" model code.		;052

UQFLAG:	.BLKB0	255.,CF.DSK!CF.TAP!4	; All entries default to	;068
					; UNASSIGNED (which means,	;070
					; "supports both disks and	;070
					; tapes, up to 4 units").	;070
	.EVEN								;052


.SBTTL	UQDEF - Macro that sets up UQFLAG and UQCVT tables
;+
;	UQDEF
;
; This is the macro which sets up the UQFLAG and UQCVT tables.
;
; Use is as follows;
;
;	UQDEF	CNAME,KEY,CIDL,CIDH,UNITS,S4ID
;
; where
;
;	'CNAME'	is the controller name.  This argument is not used by
;		the macro, and is there for informational purposes
;		only.
;	'KEY'	is the controller type keyword.  Legal ones are
;		DISK, TAPE, BOTH, UNSUPPORTED, and UNASSIGNED.
;	'CIDL'	is the Controller ID (for DISK, TAPE or BOTH), or
;		the low number of a range of controller IDs (for
;		UNSUPPORTED or UNASSIGNED).  This is the same controller
;		ID that is returned by most [T]MSCP commands.
;	'CIDH'	is the high number of a range of controller IDs.
;		Valid only for UNSUPPORTED or UNASSIGNED.
;	'UNITS'	is the number of units allowed per controller.
;	'S4ID'	is the "fake" model value returned by this controller
;		during Step 4 of the 4-step initialization process.  This
;		value and CIDL are used to build the UQCVT table.
;		
;
; Based on the information, the macro sets up the UQFLAG entry for that
; controller type by setting the proper bits and including the unit
; information (if applicable).  The controller type is defined by the
; keyword ('KEY') argument of the macro.  To whit;
;
;	DISK		- Sets CF.DSK and unit info
;	TAPE		- Sets CF.TAP and unit info
;	BOTH		- Sets CF.DSK, CF.TAP and unit info
;	UNSUPPORTED	- Clears all bits
;	UNASSIGNED	- Sets CF.DSK and CF.TAP (the theory here is
;			  that if we don't know what kind of controller
;			  it is, we should size it for both disk and
;			  tape units).
;
; Rudimentary error checking is done on the arguments.  To whit;
;
;	- CIDL and CIDH must be in the range 0-255.
;	- If CIDH is included, it must be greater than CIDL.
;	- CIDH is only legal for UNSUPPORTED and UNASSIGNED types.
;	- The keyword must be valid.
;	- S4ID must be less than or equal to the value of S4CIDM
;	  (defined above, near UQFLAG and UQCVT).
;-

.MACRO	UQDEF	CNAME,KEY,CIDL,CIDH,UNITS,S4ID				;052

.IF	NE	<CIDL&177400>
	.ERROR				;Illegal controller ID CID
	.MEXIT
.ENDC

.IF	EQ	CIDL
	.ERROR				;Illegal controller ID CID
	.MEXIT
.ENDC

.IF	NB	CIDH
	.IF	NE	<CIDH&177400>
		.ERROR			;Illegal controller ID CID
	.MEXIT
	.ENDC
.ENDC

.IRP	CHK,<DISK,TAPE,BOTH>
.IF	IDN	<KEY>,CHK
	.IF	NB	CIDH	.ERROR	;Range not allowed with KEY keyword
	.MEXIT
	.ENDC
.ENDC
.ENDM

.IF	NB	CIDH
	.IF	LE	<CIDH-CIDL>
		.ERROR			;Invalid range specified
	.ENDC
.ENDC

.IF	NB	S4ID
	.IF	LT	<S4CIDM-S4ID>
		.ERROR			;Illegal value S4ID for Step 4 byte
		.MEXIT
	.ENDC
.ENDC

.IF	B	CIDH
	$$$$$$=1
.IFF
	$$$$$$=<CIDH-CIDL>+1
.ENDC

.SAVE

.IF	IDN	<KEY>,DISK
.IF	NB	S4ID
	.=UQCVT+S4ID
	.BYTE	CIDL
.ENDC
	.=UQFLAG+CIDL
	.BYTE	CF.DSK!UNITS
.ENDC

.IF	IDN	<KEY>,TAPE
.IF	NB	S4ID
	.=UQCVT+S4ID
	.BYTE	CIDL
.ENDC
	.=UQFLAG+CIDL
	.BYTE	CF.TAP!UNITS
.ENDC

.IF	IDN	<KEY>,BOTH
.IF	NB	S4ID
	.=UQCVT+S4ID
	.BYTE	CIDL
.ENDC
	.=UQFLAG+CIDL
	.BYTE	CF.DSK!CF.TAP!UNITS
.ENDC

.IF	IDN	<KEY>,UNSUPPORTED
	.=UQFLAG+CIDL							;068
	.IRP	REPCNT,<\$$$$$$>
		.REPT	REPCNT
			.BYTE	0
		.ENDR
	.ENDM
.ENDC

.IF	IDN	<KEY>,UNASSIGNED
	.=UQFLAG+CIDL							;068
	.IRP	REPCNT,<\$$$$$$>
		.REPT	REPCNT
			.BYTE	CF.DSK!CF.TAP!4				;068
		.ENDR
	.ENDM
.ENDC

.IF	EQ	.-UQFLAG-CIDL
	.ERROR				;Illegal keyword KEY
	.RESTORE
	.MEXIT
.ENDC
.RESTORE
.ENDM	UQDEF

.NLIST	MEB								;052+
;+
;                                             Controller               Model
;                               Disk,Tape     Model Code               Code
;                               Both, or      (or range    Drives per  from
;	Description             Unsupported   of codes)    controller  Step 4
;
UQDEF	<HSC50>,		UNSUPPORTED,	1
UQDEF	<UDA50>,		DISK,		2,,		4,	0
UQDEF	<RC25>,			DISK,		3,,		4,	1
UQDEF	<VMS (Software)>,	UNSUPPORTED,	4
UQDEF	<TU81>,			TAPE,		5,,		1,	5
UQDEF	<UDA50-A>,		DISK,		6,,		4,	6
UQDEF	<RQDX1/RQDX2>,		DISK,		7,,		4,	7
UQDEF	<TOPS 10/20 (Software)>,UNSUPPORTED,	8.
UQDEF	<TQK50>,		TAPE,		9.,,		1,	3
UQDEF	<RUX50>,		DISK,		10.,,		4,	2
UQDEF	<Unassigned>,		UNASSIGNED,	11.
UQDEF	<KFBTA>,		UNSUPPORTED,	12.
UQDEF	<KDA50>,		DISK,		13.,,		4,	13.
UQDEF	<TQK70>,		TAPE,		14.,,		1,	14.
UQDEF	<RV20/RV60>,		TAPE,		15.,,		4,	15.
UQDEF	<KRQ50>,		DISK,		16.,,		2,	16.
UQDEF	<Unassigned>,		UNASSIGNED,	17.
UQDEF	<KBD50>,		UNSUPPORTED,	18.
UQDEF	<RQDX3>,		DISK,		19.,,		4,	19.
UQDEF	<Unassigned>,		UNASSIGNED,	20.
; KFQSAs are an unusual beast.  While the "disk" controller will report 21.
; at the end of step 4, it might report 96., 97., or some other ID later on
; since the controller ID actually depends on what type of disk it is.  This
; also goes for the tape connections.  So, this is why KFQSA devices appear
; to be listed twice; once under KFQSA, and once under the disk type itself.
UQDEF	<KFQSA-disk>,		DISK,		21.,,		1,	21. ;068
UQDEF	<KFQSA-tape>,		TAPE,		22.,,		1,	22. ;068
UQDEF	<KFQSA-both>,		BOTH,		23.,,		1,	23. ;068
UQDEF	<KFQSA-other>,		BOTH,		24.,,		1,	24. ;068
UQDEF	<TUK50>,		TAPE,		25.,,		1,	25. ;071
UQDEF	<Unassigned>,		UNASSIGNED,	26.
UQDEF	<KDM70>,		UNSUPPORTED,	27.			;068
UQDEF	<Reserved>,		UNASSIGNED,	28.			;068
UQDEF	<TM32>,			UNSUPPORTED,	29.			;068
UQDEF	<RQZX1>,		BOTH,		30.,,		4,	30. ;069
UQDEF	<Reserved>,		UNASSIGNED,	31.			;069
UQDEF	<CI Devices>,		UNSUPPORTED,	32.,63.
UQDEF	<BI Devices>,		UNSUPPORTED,	64.,95.
UQDEF	<RF30>,			DISK,		96.,,		1	;068
UQDEF	<RF71>,			DISK,		97.,,		1	;068
UQDEF	<TF85>,			TAPE,		98.,,		1	;068
UQDEF	<TF70>,			TAPE,		99.,,		1	;068
UQDEF	<RF31>,			DISK,		100.,,		1	;068
UQDEF	<RF72>,			DISK,		101.,,		1	;068
UQDEF	<RF73>,			DISK,		102.,,		1	;068
UQDEF	<TF70L>,		TAPE,		103.,,		1	;068
UQDEF	<RF35>,			DISK,		104.,,		1	;071
UQDEF	<EF51>,			DISK,		105.,,		1	;071
UQDEF	<Unassigned>,		UNASSIGNED,	106.,,		1	;071
UQDEF	<Unassigned>,		UNASSIGNED,	107.,,		1	;071
UQDEF	<RF36>,			DISK,		108.,,		1	;071
UQDEF	<RF74>,			DISK,		109.,,		1	;071
UQDEF	<Unassigned>,		UNASSIGNED,	110.,,		1	;071
UQDEF	<Unassigned>,		UNASSIGNED,	111.,,		1	;071
UQDEF	<RF75>,			DISK,		112.,,		1	;071
UQDEF	<Unassigned>,		UNASSIGNED,	113.,247.		;068
UQDEF	<Software Servers>,	UNSUPPORTED,	248.,255.

.LIST	MEB

	UNORG

.MDELET	UQDEF								;052-


.SBTTL	PRINT ERROR IF USER UNIT DOESN'T MATCH REAL UNIT

.ENABL	LSB

UNTERR:	MOV	(R5)+,10$	;SAVE DISK NAME
	MOVB	#'0,20$		;SET UNIT NUMBER
	BISB	R4,20$		; AS ASCII DIGIT
	CALLX	MESSAGE,R5,10$	;PRINT THE MESSAGE
	RETURN	R5		;DONE

.NLIST	BEX

10$:	.ASCII	"XX: disk unit "
20$:	.ASCIZ	"0 does not match user defined unit type - user ignored"<200>
	.EVEN

.LIST	BEX

.DSABL	LSB


.SBTTL	Determine GPK disk sizes

DZLOOK:	MOV	#-1,DZ$MID	;Assume no floppy unit 0		;046+
	MOV	#-1,DZ$MID+2	; nor unit 1
	TST	CSRTBL+RZ.CSO	;Is the controller present?
	BEQ	10$		;No, so that was right
	CLR	DZ$MID		;Yes, we have two units now...
	CLR	DZ$MID+2	; 0 and 1
10$:	RETURN			;Sizes are preset, nothing left to do

;+
; DWLOOK figures out the size of the GPK hard disk by counting the
; number of heads and, if necessary, doing a seek test.  The head
; count distinguishes all except RD50/51, and RD51/31.  50/51 are
; told apart based on the "RD50" bit in the CSR (called "Reserved"
; in the technical manual).  51/31 are told apart by a seek test,
; where the address being accessed wraps back to the first sector
; on the RD51 but not on the RD31.  Since the first sector is unused
; (except by GPK selftest) we can scribble on it to ensure there
; is no accidental match in the RD31 case.
;
; The DW$MID word is set up as two bytes: the low byte is the head
; count, and the high byte is the type code for use by the Hardware
; List option.
;-

;*** temp *** just RD51 now

DWLOOK:	REGSCR			;Save those registers
	MOV	#-1,DW$MID	;Assume no hard disk
	MOV	CSRTBL+RW.CSO,R0 ;Get the controller CSR
	BEQ	100$		;Indeed, no controller...

	MOV	#1*400+4,DW$MID	;Set type = RD51, 4 heads
100$:	RETURN			;All done

GLOBAL	<DZ$MID,DW$MID,CSRTBL,RZ.CSO,RW.CSO>				;049-

.SBTTL	DETERMINE WHICH FORMATTERS ARE CONNECTED WITH WHICH MM: TRANSPORTS

.ENABL	LSB

MMLOOK:	CLR	R0		;CLEAR OUT THE TABLES
10$:	MOV	#-1,MM$FOR(R0)	;SET THE UNIT/FORMATTER ASSOCIATION TO NIL
	CLR	MM$TYP(R0)	;SET THE FORMATTER TYPE TO NIL
	TST	(R0)+		;BUMP THE POINTER
	CMP	R0,#20		;ARE WE DONE?
	BLO	10$		;NO, KEEP INITIALIZING
	MOV	#TU.PKT,R0	;R0 -> PACKET FOR RH MAGTAPES
	MOV	PK.CSO(R0),R0	;R0 = OFFSET FOR TU'S IN CSRTBL
	MOV	CSRTBL(R0),R0	;R0 -> CSR FOR MM'S
	BEQ	50$		;NO CSRS, THIS IS EASY
	CLR	R1		;START AT TRANSPORT 0
	CLR	R2		;START AT FORMATTER 0
	CLR	R4		;START AT TRANSPORT OFFSET 0
20$:	MOV	#RHCLR,RHCS2(R0);CLEAR THE CONTROLLER
	MOVB	R2,RHCS2(R0)	;SELECT THE NEXT FORMATTER
	MOVB	R1,MMTC(R0)	;SELECT THE NEXT TRANSPORT
	MOV	RHDT(R0),R3	;GET THE DRIVE TYPE REGISTER
	BIT	#002007,R3	;IS THERE A SLAVE PRESENT (or offline TU45)?
	BEQ	40$		;NO, GO TO NEXT FORMATTER
	BICB	#7,R3		;REMOVE TRANSPORT TYPE BITS
	CMPB	#10,R3		;IS THIS A TM02 FORMATTER?
	BEQ	30$		;YUP, ENTER IT IN OUR TABLES
	CMPB	#50,R3		;IS THIS A TM03 FORMATTER?
	BNE	40$		;NOPE, GO TO THE NEXT FORMATTER
30$:	TST	MM$FOR(R4)	;HAVE WE ALREADY FOUND A UNIT FOR IT?
	BPL	60$		;YES, BAD NEWS, 2 UNITS WITH SAME NUMBER
	MOV	R2,MM$FOR(R4)	;NO, SET THE FORMATTER # FOR THIS TRANSPORT
	MOV	RHDT(R0),R3	;RESTORE THE MAGTAPE DRIVE TYPE
	MOVB	R3,MM$TYP(R4)	;SET THE FORMATTER TYPE FOR THIS TRANSPORT
	BISB	BITBYT(R1),TYPTBL+TU.CSO ;SAVE UNIT # FOR SYSGEN	;046
40$:	INC	R2		;ADVANCE FORMATTER NUMBER
	CMP	R2,#8.		;HAVE WE TRIED ALL OF THEM?
	BLO	20$		;NOPE, TRY NEXT FORMATTER
	CLR	R2		;GO BACK TO FORMATTER 0
	INC	R1		;AND TRY NEXT TRANSPORT NUMBER
	TST	(R4)+		;ADVANCE THE TRANSPORT OFFSET IN MM$FOR TABLE
	CMP	R1,#8.		;HAVE WE TRIED ALL OF THEM?
	BLO	20$		;NO, TRY THIS TRANSPORT UNIT
50$:	RETURN

60$:	MESSAG	<"2 magtape transports have the same unit number"<200>>
	BR	40$		;CONTINUE WITH NEXT FORMATTER

.DSABL	LSB

GLOBAL	<MM$FOR,MM$TYP,TU.PKT,CSRTBL,TYPTBL,BITBYT,TU.CSO>		;046

.SBTTL	Ethernet integrity/Network address saver

NALOOK:	CALL	10$,R0,<XE.PKT,XEADDR,CNT.XE,XELOOK,XESHUT>		;039
	CALL	10$,R0,<XH.PKT,XHADDR,CNT.XH,XHLOOK,XHSHUT>		;039
	RETURN								;039

10$:	MOV	(R0)+,R5	;Get device packet pointer		;039
	MOV	(R0)+,R2	;Pointer to store physical addresses	;039
	CLR	@(R0)		;No devices found yet			;039
	MOV	PK.CSO(R5),R4	;Get CSRTBL offset			;039
	ADD	#CSRTBL,R4	;Make CSRTBL pointer			;039
	MOVB	(R5),R3		;Get number of controllers possible	;039
.ASSUME	PK.MXU	EQ 0
20$:	MOV	(R4),R1		;Get CSR for device, if present		;039
	BEQ	30$		;Not here, look for others		;039
	INC	@(R0)+		;Assume it works			;039
	CALL	@(R0)		;Check it out				;039
	SBC	@-(R0)		;Don't count it if it didn't work	;039
	CALL	@4(R0)		;Quiesce the device			;039
30$:	ADD	#10,R2		;Advance pointers			;039
	TST	(R4)+		;...					;039
	SOB	R3,20$		;Next controller			;039
	ADD	#6,R0		;Skip count, look and quiesce routine	;039
	RETURN	R0		;Back to caller				;039

.ENABL	LSB
XHLOOK:	REGSCR			;Save the world				;039
	MOV	#^RQNA,(R2)+	;Assume device is a QNA			;039
	MOV	#6,R3		;Station address is 6 bytes long	;039
	CLR	QNA.BD		;MSB of 22-bit diagnostic load address	;039
	MOV	#BBR$P2,QNA.BD+2 ;Pick up APR for diag. code		;058
120$:	MOV	(R1)+,-(SP)	;Pick up a word out of the CSR		;039
	MOVB	(SP)+,(R2)+	;Store byte away			;039
	ASL	QNA.BD+2	;Change APR value into 22-bit address	;039
	ROL	QNA.BD		;...by shifting it six times		;039
	SOB	R3,120$		;Get all 6 bytes/bits			;039
	MOV	#1,(R1)		;Set Bit 0 in vector register		;039
	BIT	#1,(R1)+	;Did it stay set?			;039
	BEQ	130$		;Nope.  So it is a QNA			;039
	MOV	#^RLQA,-10(R2)	;It's an LQA.  Save that fact		;039
130$:	CALL	QNABDL,R5,<XH.RDS,-<10000/4>>	;Load first half of BDL	;039
	ADD	#<10000/2>,QNA.BD+2 ;Compute where second half loads	;039
	ADC	QNA.BD							;039
	CALL	QNABDL,R5,<XH.RS2,-<10000/4>>	;Load second half of BDL;039
	MOV	#XH.RDS,-12(R1)	;Validate receive descriptor		;039
	CLR	-10(R1)		;MSB					;039
	MOV	#1011,(R1)	;Load diagnostic ROM			;039
	MOV	-16(R1),-(SP)	;Get first byte of address checksum	;039
	MOV	-14(R1),-(SP)	;Get second byte of address checksum	;039
	;CLR	R3		;Start long wait loop			;039
140$:	DEC	R3		;Begin wait loop			;039
	BNE	140$		;Wait					;039
	CLR	(R1)		;Clear Boot/Diagnostic bits		;039
	;CLR	R3		;Start second long wait loop		;039
150$:	DEC	R3		;Begin wait loop			;039
	BNE	150$		;Wait					;039
	MOV	#2,(R1)		;Reset the QNA				;039
	CLR	(R1)		;Stop resetting.  Diag. load is done.	;039
	;CLR	R3		;Place to compute checksum		;039
	SUB	#6,R2		;Point back to first two bytes of addr	;039
	MOV	(R2)+,R3	;Pick up two bytes			;039
	SWAB	R3		;256.*LO + HI				;039
	ASL	R3		;Shift by a power of 2			;039
	ADC	R3		;MOD 65535.				;039
	MOV	(R2)+,R0	;Pick up two bytes			;039
	SWAB	R0		;256.*LO + HI				;039
	ADD	R0,R3		;Add to current checksum		;039
	ADC	R3		;MOD 65535.				;039
	ASL	R3		;Shift by a power of 2			;039
	ADC	R3		;MOD 65535.				;039
	MOV	(R2)+,R0	;Pick up two bytes			;039
	SWAB	R0		;256.*LO + HI				;039
	ADD	R0,R3		;Add to current checksum		;039
	ADC	R3		;MOD 65535.				;039
	CMP	#65534.,R3	;65535?					;039
	ADC	R3		;If so, make it 0 (MOD 65535.)		;039
.ASSUME	BLO EQ BCS
	MOVB	(SP)+,R0	;Get high byte of checksum in lo byte	;039
	ASH	#8.,R0		;Put it in high byte			;039
	BISB	(SP)+,R0	;"Add" in lo byte of checksum		;039
	CMP	R0,R3		;Checksums match?			;039
	BNE	15$		;Nope.					;039
	BIC	#037777,XH.RS1	;Mask out bits 0-13			;039
	CMP	#140000,XH.RS1	;Check first descriptor receive status	;039
	BNE	15$		;? Status check				;039
	BIC	#037777,XH.RS2	;Mask out bits 0-13			;039
	CMP	#140000,XH.RS2	;Check second descriptor receive status	;039
	BNE	15$		;? Status check				;039
	MOV	TOS.R2(SP),R2	;Point back to XH work space		;058
	CMP	#^RLQA,(R2)	;Was this an LQA?			;058
	BEQ	155$		;Yes, skip last BDL QNA check, QNA only	;058
				;QNA hardware bug generate an extra BDL	;058
	BIC	#037777,XH.RS3	;Mask out bits 0-13			;039
	CMP	#100000,XH.RS3	;Check last descriptor receive status	;039
	BNE	15$		;? Status check				;039
155$:	MOV	TOS.R1(SP),R1	;Point back at top of CSR set		;058
	CALLX	QNAROM		;Do diagnostics from ROOT		;039
	BCS	50$		;Diagnostics failed			;044
	TST	R0		;ROM Checksum error?			;039
	BMI	15$		;Yes.					;044
	RETURN			;No, back to caller			;058

50$:	CMP	R0,#100000	;External loopback failure		;044
	BNE	55$		;Nope.  Honest to goodness failure	;044
	MOV	#160$,-(SP)	;Set up to print out probable cause	;044
55$:	MOV	#OCTWRD,-(SP)	;QNA error codes are a full word	;039
60$:	CALLX	TYPECR		;Print a blank line first for neatness	;044
	CALLX	TYPDEV		;Type the device name			;039
	CALLX	MESSAG,R5,MDIAGF	;Say there was a failure	;039
	MESSAG	<", code ">,MDIAGC					;045
	CALL	@(SP)+		;Print the error code (OCTBYT or OCTWRD);039
	BR	25$		;Go disable it				;039

XECMD:	MOVB	#377,1(R1)	;Clear interrupts			;039
	MOV	(R0)+,(R1)	;Issue the command			;039
	MOVB	#-16.,DSS$DS+1	;Set time-out value from controller 	;044
10$:	CALLX	GETTTY		;Watch the terminal and the clock	;044
	TST	DSS$DS		;Timeout?				;044
	BPL	13$		;Yes, controller error			;044
	TSTB	(R1)		;Done yet?				;039
	BPL	10$		;Nope					;039
	BIT	#173400,(R1)	;Any errors?				;039
	BEQ	RTSR0		;Nope					;039
	CMP	-2(R0),#40	;Error.  On a reset?			;039
	BEQ	RTSR0		;Yes, go back and print diagnostic code	;039
13$:	POP			;Junk top of stack			;039
15$:	MOV	(PC)+,R0	;Get message to print			;039
	GENTXT	<" initializaton failure">,INFAIL			;045
20$:	CALLX	TYPECR		;Add a carriage return for good measure	;044
	CALLX	TYPDEV		;Print out the device name		;039
	CALLX	ASCIZ0		;Print out the message			;039
25$:	CALLX	MESSAG,R5,DEVDIS ;Say we're disabling it		;039
	CLR	(R4)		;Disable the device			;039
27$:	SEC			;Indicate that it doesn't work		;039
	RETURN			;Return to mainstream			;039

RTSR0:	RETURN	R0		;Return to caller			;039

30$:	MOV	(PC)+,R0	;Get message to print			;039
	GENTXT	<" transceiver power failure">
	BR	20$		;Go disable it				;039

40$:	MOV	(PC)+,R0	;Get message to print			;039
	GENTXT	<" port/link cable problem">
	BR	20$		;Go disable it				;039

160$:	MESSAGE	<"  Probable cause:  Device not connected to transceiver"<200>>
	BR	27$		;Now really return			;044

XELOOK:	REGSCR			;Save the world, but don't destroy r4,r5;039
	CALL	XECMD,R0,40	;Reset the UNA, let it run it's diag.	;039
	MOV	2(R1),-(SP)	;Grab PCSR1				;039
	MOV	(SP),R3		;Working copy				;039
	BIC	#^C<17>,R3	;Check the status			;039
	CMP	R3,#2		;Diagnostics complete w/o error?	;039
	BEQ	70$		;Yes					;039
	MOVB	3(R1),R0	;Get high byte of PCSR1			;039
	MOV	#OCTBYT,(SP)	;Only print out a byte			;042
	CMPB	R0,#205		;UNA external loopback failure?		;044
	BEQ	170$		;Yes.					;044
	CMPB	R0,#5		;LUA external loopback failure??????????;044
	BNE	60$		;No.  Real diagnostic error		;044
170$:	MOV	(SP),-(SP)	;Make room for another routine		;044
	MOV	#160$,2(SP)	; to print out probable cause		;044
	BR	60$		;Go print out diagnostic code		;039

70$:	BIC	#^C<160>,(SP)	;Isolate ID area			;039
	MOV	#^RLUA,R3	;Assume it's a LUA			;039
	CMP	(SP)+,#20	;LUA?					;039
	BEQ	80$		;Yes.  Get the device's physical address;039
	MOV	#^RUNA,R3	;Nope.  Save that fact			;039
	MOVB	3(R1),R0	;Check high byte of PCSR1		;039
	BMI	30$		;Power unit failure.  Tell user		;039
	BIT	#100,R0		;Port/Link Cable problem?		;039
	BNE	40$		;Yes.  Tell user			;039
80$:	MOV	R2,4(R1)	;LSB PCBB				;039
	CLR	6(R1)		;MSB PCBB				;039
	CALL	XECMD,R0,1	;Get PCBB				;039
	MOV	#2,(R2)		;Read Default Physical Address command	;039
	CALL	XECMD,R0,2	;Get CMD				;039
	MOV	R3,(R2)		;Store LQA/UNA status			;039
	RETURN			;All done				;039

XESHUT:	MOV	#177400,(R1)	;Clear any interrupts			;039
	RETURN								;039

XHSHUT:	MOV	#2,16(R1)	;Reset QNA				;039
	CLR	16(R1)		;Stop resetting				;039
	RETURN								;039

QNABDL:	MOV	R0,-(SP)	;Save R0				;039
	MOV	(R5)+,R0	;Get address of BDL			;039
	MOV	#100000,(R0)	;QNA not yet using this buffer		;039
	MOV	(R0)+,(R0)	;Valid buffer				;039
	BIS	QNA.BD,(R0)+	;MSB address				;039
	MOV	QNA.BD+2,(R0)+	;LSB address				;039
	MOV	(R5)+,(R0)+	;Length					;039
	CLR	(R0)+		;Status word 1				;039
	CLR	(R0)+		;Status word 2				;039
	MOV	#100000,(R0)+	;Blank buffer to account for hdwr bug	;039
	CLR	(R0)+		;Blank buffer to account for hdwr bug	;039
	CLR	(R0)+		;Blank buffer to account for hdwr bug	;039
	CLR	(R0)+		;Blank buffer to account for hdwr bug	;039
	MOV	#100000,(R0)+	;Blank buffer to account for hdwr bug	;039
	CLR	(R0)+		;Blank buffer to account for hdwr bug	;039
	MOV	(SP)+,R0	;Restore R0				;039
	RETURN	R5		;Back to caller				;039

GLOBAL	<XE.PKT,XEADDR,XH.PKT,XHADDR,CNT.XE,CNT.XH>
GLOBAL	<CSRTBL,IOBF15,OCTBYT,OCTWRD>

.DSABL	LSB

ENDOVL	<ONE,ONECTL,ONETXT>,200

.END
