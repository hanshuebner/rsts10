	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
	.INCLUDE /INIT:INIPFX/
	.INCLUDE /INIT:DSKDEF/
	.INCLUDE /INIT:TAPDEF/
	.INCLUDE /DSK:MSCPDF/
TITLE	INIDSK,<RSTS/E INIT COMMON DISK CODE>,0H,20-DEC-91,ABC/WBN/SHG/SJK/HNS/GPK/MND/WJS/FRL/BGN/TPT/DBM
;
;		COPYRIGHT (c) 1974, 1984 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;


.SBTTL	EDIT HISTORY FOR INIDSK

;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-08
;  001	MND  16-Feb-81	Added DMP/DMV support
;  002  MDS  02-Apr-81	Fixed phase offset for extended memory dumps
;  003  HNS  07-AUG-81  Fixed phase offset for new ODT
;  004  MND  09-Nov-81  Removed DPAR6 global, (moved to ROOT)
;
;				[RSTS V7.2]
;  000	MND  22-Mar-82	CREATION - COPIED FROM V7.1-11
;  001  MND  22-Mar-82	Added support MSCP disks UDA50/RA80
;
;				[RSTS V8.0]
;  000	GPK  24-Jun-82	Removed UDA50 mini-driver
;  001	GPK  13-Aug-82	Source clear patch 1.1.8
;  002	MND  28-Feb-82	Modified DU wait rtn. to work with MSCPPH changes
;
;				[RSTS V9.0]
;  003	WJS  09-Sep-83	LTDS changes
;  004	MND  01-Nov-83	Added changes for Virtual Disk
;  005	MND  28-Nov-83	DURSET clean-up
;  006  FRL  12-Dec-83  Made L3Q work in INIT as it does in monitor
;  007  BGN  02-Mar-83  Source clear PATCH 1.1.28
;  008  JHC  09-Oct-84	Change DEFORGs to include ECCDSK at head of DSK
;			module.
;  009  MND  10-Dec-83  Fix DURSET bug
;				[RSTS V9.1]
;  009  MND  20-Dec-84	Reworked DUWAIT routine for TMSCP support
;  010	TPT  13-Jan-85	More work for TMSCP support 
;  011	DBM  27-Jan-85	Even more TMSCP work
;  012  MND  28-Jan-85	Stuff INIDNE in DSQL3Q for DUDSK
;  013  MND  29-Jan-85	Remove BGBUFR and BUFCTL (put in ROOT)
;  014	TPT  07-Feb-85	Misc. entries moved to ROOT
;  015	DBM  18-May-85	Move RTI3, DMPJOB, SAVJOB, and DEV.M? to ROOT
;			to solve auto-load vector problem
;  016  MND  20-May-85  Fix V9.0 -> V9.1 merge bug
;  017	TPT  17-Jun-85	Have PTRSET do a magset, also misc. changes
;
;				[RSTS V9.2]
;  018	TPT  10-Jan-86	Fix bug in MURSET routine
;
;				[RSTS V9.3]
;  019  VAM  15-Jul-86	Move MUDVR into BBR phase, and DUDSK into MCP phase.
;
;				[RSTS V9.4]
;  020	GPK  17-Sep-86	Add DW, DZ drivers for GPK
;  021	GPK  02-Oct-86	Move DFINT1, 3, 4, 9 to ROOT (for LINK bug)
;
;				[RSTS V9.5]
;  022	WRM  01-Jul-87	Add large disk support
;
;				[RSTS V9.6]
;  023	PJH  04-Jan-88	Fix PERRLG mapping for EMT check
;  024	VAM  05-Feb-88	Fix DURSET bug (non-existant unit causes trap to 4)
;  025	PJH  18-Feb-88	Add Controller formatting command support
;			Remove patch space (Ouch!)
;
;				[RSTS V10.0]
;  026	FEK  06-Aug-90	Fix MSCP error message formatting
;
;				[RSTS V10.1]
;  027	FEK  03-Dec-91	Fix TMSCP error message formatting
;-



.SBTTL	MACROS

.MACRO	I.MESS
	TMPORG	DSKTXT
.NLIST	BEX
.ENDM	I.MESS

	DEFORG	DSKRND
	DEFORG	DSKTXT
	ORG	ECCDSK							;008
	DEFORG	INIDSK

	ORG	DZDINT			; These 4 must come early	;020
	ORG	DZDSK			;  (because they remap APR6)	;020
	ORG	DWDINT							;020
	ORG	DWDSK							;020

	$DISKS
.IF	DIF	<NAME>,<DR>
.IF	DIF	<NAME>,<DU>
	DEFORG	NAME'DINT
	ORG	NAME'DSK
.ENDC
.ENDC
.ENDM
	DEFORG	DSKPAT
	$TAPES
.IF	DIF	<NAME>,<MU>						;011
	ORG	NAME'DCTL
	ORG	NAME'DINT
	ORG	NAME'DVR
.ENDC
.ENDM
	ORG	INIDSK


;GLOBALS IN THE ROOT

GLOBAL	<DSO$XX,MID$XX,UNTCNT,DQS$XX,DSS$DF,DQS$DF,DSS$DB>
GLOBAL	<DSS$DK,DSS$DP,DSS$DS,DSS$DW,DSS$DZ>				;020



.SBTTL	MACRO TO SET UP DISK DISPATCH ADDRESS
.MACRO	DSPTCH	ENTRY
$DISKS
.IF	DIF	<NAME>,<DR>
  .IF	IDN	ENTRY , DINT
	 .WORD 	'NAME''ENTRY'
  GLOBAL	<'NAME''ENTRY'>
  .IFF
    .IF	DIF	<NAME>,<DU>
	 .WORD	'ENTRY'$'NAME'		;NAME DISK DRIVER'S ENTRY ADDRESS
     GLOBAL	<'ENTRY'$'NAME'>
    .IFF
	 .WORD	J'ENTRY''NAME'		;ADDRESS OF ENTRY'$'NAME (ANOTHER PHASE)
     GLOBAL	<J'ENTRY''NAME'>
    .ENDC
  .ENDC
.IFF
  .IF	IDN	ENTRY , DINT
	 .WORD 	DB'ENTRY'
  .IFF
	 .WORD	ENTRY'$DB		;HANDLE DR: LIKE DB:
  .ENDC
.ENDC
.ENDM	DSPTCH

.SBTTL	MACRO TO SET UP TAPE DISPATCH ADDRESS
.MACRO	TDSPCH	ENTRY							;011
$TAPES
  .IF	DIF	<NAME>,<MU>
    .WORD	'ENTRY'$'NAME'		;NAME TAPE DRIVER'S ENTRY ADDRESS
    GLOBAL	<'ENTRY'$'NAME'>
  .IFF
    .WORD	J'ENTRY''NAME'		;ADDRESS OF ENTRY'$'NAME (ANOTHER PHASE)
    GLOBAL	<J'ENTRY''NAME'>
  .ENDC
.ENDM	TDSPCH


	RNDAPR	5,DSK

.SBTTL	Patch area for phase

;	TMPORG	DSKPAT							;066

;	.BLKB	200		; Patch area				;066

;	UNORG								;066

	TMPORG	DSKTXT


	UNORG


.SBTTL	COMMON DISK FRONT-END

;+
; PDISK - START UP A DISK REQUEST.
;
;	R4 -> DSQ
;		(ON LINE: DSQJOB =  JOB NUMBER TIMES 2)
;		DSQJOB = DISK INDEX (IDX$D?) [INIT ONLY]
;		(ON LINE: DSQL3Q -> COMPLETION L3Q BIT(S)/QUEUE ROOT)
;		(ON LINE: DSQUNT =  FIP UNIT NUMBER)
;		DSQFBM, DSQFBL = FIP BLOCK NUMBER
;		DSQMAM, DSQMAL = MEMORY ADDRESS BITS <21-0>
;		DSQCNT =  +(WORD COUNT)
;		DSQFUN =  LOGICAL FUNCTION (RFUN/WFUN/WCFUN)
;		(ON LINE: DSQFAR =  FAIRNESS COUNT (USUALLY 0))
;		DSQPUN = UNIT NUMBER (0-7) [INIT ONLY]
;	PDISK MAPPED THROUGH APR5
;
;	CALL	PDISK
;-

.ENABL	LSB

PDISK::	NOP			;FOR DEBUGGING
	CALLX	GETTTY		;EAT UP ANY TYPE AHEAD FIRST
	REGSCR			;SAVE ALL REGISTERS
	MOVB	DSQJOB(R4),R2	;R2 = DISK INDEX
	BMI	10$		;ERROR, BAD INDEX
	CMPB	R2,#DSKMAX*2	;TOO BIG?
	BLO	20$		;NO, IT'S OK
10$:	ERF	<"INIT bug - bad disk index">





20$:	MOV	R4,-(SP)	;SAVE OUR DSQ POINTER
	MOVB	DSQPUN(R4),R4	;NOW GET PHYSICAL UNIT IN R4
	MOV	R2,R5		;  AND DISK INDEX IN R5
	CALLX	GETCSR		;    TO GET THE DISK'S CSR
	MOV	R3,CSR.XX	;      IN CSR.XX
	MOV	(SP),R4		;RESTORE DSQ, POPPED AF CO-ROUTINE CALL LATER
	MOV	DSKDCS(R2),R5	;R5 -> DCS TABLE FOR THIS DISK TYPE
	MOVB	DSQPUN(R4),R3	;R3 = UNIT NUMBER
	ASL	R3		;  *2
	ADD	R3,R5		;R5 -> DCS FOR THIS DISK UNIT
	MOVB	DSQFBM(R4),R0	;R0 = THE FBN (MSB) AND
	MOV	DSQFBL(R4),R1	; R1 = (LSB)
	BNE	30$		;NON-ZERO, SO DO THE DCS-1 CORRECTION
	TST	R0		;REALLY A ZERO?
	BEQ	40$		;YES, LEAVE IT ALONE
30$:	MOV	(R5),R5		;NO, GET DCS FOR THIS UNIT
	DEC	R5		; FIND (DCS-1)
	ADD	R5,R1		;NOW ADD IN (DCS-1) AND
	ADC	R0		; CARRY IF NEEDED
40$:	MOVB	R3,DSQOUN(R4)	;SET THE PHYSICAL UNIT *2
	MOV	DSKMID(R2),R5	;R5 -> MID TABLE FOR THIS DISK TYPE
	ADD	R3,R5		;R5 -> MASSBUS ID FOR THIS UNIT
	MOV	(R5),MID$XX	;SET MASSBUS ID FOR DRIVERS
	CMP	R2,#IDX$DK
	BNE	50$
	CLR	MID$XX		;EXCEPT THAT RK05F SHOULD LOOK LIKE RK05J

GLOBAL	<DSKDCS,DSKMID,DSKCSR,CSR.XX>


50$:	MOV	#110000,UNTCNT	;F.U.N.=zero, UC.MNT!UC.NFS are set
	MOV	#INIDNE,DSQL3Q(R4) ;Setup pointer for MSCP deque	;012
	MOVB	DSQFUN(R4),R5	;GET THE (LOGICAL) FUNCTION CODE
	MOVB	R5,DSQSAV(R4)	; AND SAVE IT IN THE SAVE LOCATION
	MOVB	120$-WFUN(R5),DSQRFN(R4) ;SET THE RH11 TYPE FUNCTION
	CLRB	DSQUNT(R4)	; ALSO IN THE DSQ
	CLR	(R4)		;THERE IS NO OFFSET INTO THE QUEUE ROOT
	MOV	DSKPTR(R2),R5	;GET POINTER TO 'D?DINT' @ DQS$OO
	MOV	4(R5),R5	;  SKIP 'JSR R5,@#INTSVX'.  TO GET THE
				;    ADDR OF THE DRIVER'S PHASE MMU
	CMP	(R5),@#KISAR5	;IS IT IN OUR MAPPED PHASE?
	BNE	53$		;NO. SO WE HAVE TO DO A MAPPED CALL
	CLR	R5		;R5 = A PHONY FIP UNIT NUMBER OF 0
	CALL	@DSKDSP(R2)	;ASK OUR MAPPED DRIVER TO CHECK-OUT DSQ
 	BR	55$		;NOW GO DO THE CO-ROUTINE CALL FOR 1ST IN Q

53$:	MOV	(R5),SAVPHZ	;SAVE THE DRIVER'S PHASE MMU
	MOV	#57$,-(SP)	;  SET RETURN ADDRESS FOR A MAPPED CALL
	MOV	@#KISAR5,-(SP)	;    REMEMBER OUR PHASE FOR THAT RETURN
	MOV	@DSKDSP(R2),-(SP) ;    STACK THE DRIVER'S ENTRY POINT (QDS$xx)
	MOV	(PC)+,-(SP)	;        NOW STACK THE DRIVER'S PHASE MMU
SAVPHZ:	.WORD	0		;JAM THIS GUY FOR NOW...(DRIVER PHASE MMU) ;017
	CLR	R5		;R5 = A PHONY FIP UNIT NUMBER OF 0
	JMPX	CALLMX		;CALL MAPPED INTO DRIVER TO CHECK IT OUT

;+
; WHEN THE DISK DRIVER IS CALLED:
;
;	R0 =  MSB OF THE STARTING LBN
;	R1 =  LSB OF THE STARTING LBN
;	R2 =  DISK DRIVER INDEX
;	R3 =  PHYSICAL UNIT NUMBER * 2
;	R4 -> DSQ
;		DSQRFN =  RH11 FUNCTION
;		DSQSAV =  DSQFUN
;		DSQOUN =  PHYSICAL UNIT *2
;		DSQPUN =  PHYSICAL UNIT
;	R5 =  FIP UNIT NUMBER *2
;	(R4) = 0
;	PRIORITY LEVEL IS PR3
;
;	...
;
;	CALL	@(SP)+
;
;	R2 =  DISK DRIVER INDEX (UNCHANGED)
;	R4 -> DSQ
;	(R4) = OFFSET TO QUEUE ROOT
;-


55$:	MOV	CSR.XX,R3	;SET THE DISK CSR ADDRESS IN R3
	MOVB	NRETRY,DSQERR(R4) ;SET UP THE RETRY COUNT THAT INIT WANTS
	NEG	DSQCNT(R4)	;MAKE THE WORD COUNT A -(WORD COUNT)
	MOV	#DQS$XX,R0	;R0 -> QUEUE ROOT (A SHORT QUEUE)
	MOV	R4,(R0)		;SET THIS DSQ AS THE QUEUE
	CLR	(R4)		; AND ONLY THIS DSQ
	CALL	@(SP)+		;FIRST IN QUEUE, CALL DRIVER BACK AGAIN
57$:	MOV	(SP)+,R4	;RESTORE POINTER TO DSQ
	BR	70$		;DRIVER MAY HAVE ABORTED THE OPERATION



;+
; CONTROL IS RETURNED TO DRIVER IF REQUEST IS FIRST IN QUEUE.
;	R0 -> QUEUE ROOT
;	R2 =  PHYSICAL UNIT NUMBER * 2
;	R3 =  CSR OF DISK
;	R4 -> DSQ
;		DSQCNT = -(WORD COUNT)
;	(ON LINE: PRIORITY LEVEL IS PR5)
;
;	...
;
;	RETURN
;-


60$:	CALL	DSKRDY		;WAIT FOR THE DISK TO BE READY
70$:	TST	DQS$XX		;IS THE REQUEST COMPLETE?
	BNE	60$		;NO, IT'S RETRYING, SO WAIT SOME MORE
	TSTB	DSQERR(R4)	;YES, WAS THERE AN ERROR?
	BMI	80$		;NOPE, AOK
	TSTB	DSIFLG		;YES, BUT IN DSKINT (Reg or SILENT)?	;025
	BGE	80$		;YES, SUPRESS those errors		;025
	TSTB	NOERR		;ARE WE SUPRESSING DISK ERRORS?
	BEQ	110$		;NOPE, THAT'S A FATAL DISK ERROR
80$:	MOVB	DSQERR(R4),IOERR;COPY THE ERROR THE DISK GOT
	BMI	90$		;A GOOD I/O TRANSFER 
	CMPB	IOERR,#HNGDEV	;WAS IT A HUNG DEVICE?
	BEQ	100$		;YES
	CMPB	IOERR,#ERRERR	;Was it a Missing Special Feature?	;025
	BEQ	100$		;Yes, so leave it alone			;025
	MOVB	#DATERR,IOERR	;MUST HAVE BEEN A DATA ERROR
	BR	100$		;AND LEAVE
90$:	CLRB	IOERR		;INIDICATE GOOD I/O TRANSFER
100$:	RETURN			; AND EXIT, RESTORING REGISTERS

110$:	MESSAGE	<<177><200>"Unrecoverable disk error on ">
	MOVB	DSQJOB(R4),R2	;GET DISK INDEX
	MOV	DSKNAM(R2),R2	;GET NAME IN R2
	CALLX	TYPE2		;TYPE IT
	MOVB	DSQPUN(R4),R0	;GET UNIT NUMBER
	CALLX	DECZER		;TYPE IT
	CALLX	TYPECR		;NEW LINE
	ERF	<"">		;TRAP OUT

120$:	.WORD	61		;RH11 WRITE
	.WORD	71		;RH11 READ
	.WORD	51		;RH11 WRITE CHECK

.DSABL	LSB

GLOBAL	<DATERR,IOERR,NOERR,BACKUP,HNGDEV,ERRERR,KISAR5>		;025
GLOBAL	<DSKCSR,NRETRY,DSIFLG,DSKNAM,INIDNE>


.SBTTL	DISK DISPATCH TABLES

DSKDSP:	DSPTCH	QDS
.ENDM

DSKINT:	DSPTCH	INT
.ENDM

DSKTMO:	DSPTCH	TMO
.ENDM

DSKPTR:	DSPTCH	DINT
.ENDM


.SBTTL	TAPE DISPATCH TABLES

	TDSPCH	SER							;011
.ENDM
MAGSER:

	TDSPCH	SPC							;011
.ENDM
MAGSPD:

	TDSPCH	ASN							;011
.ENDM
MAGASD:

	TDSPCH	INT							;011
.ENDM
MAGINT:

	TDSPCH	TMO							;011
.ENDM
MAGTMO:


.SBTTL	WAIT FOR DISK READY, THEN FAKE AN INTERRUPT

;+
; DSKRDY - LOOP UNTIL DISK READY, THEN ENTER INTERRUPT SERVICE
;
;	R4 -> DSQ
;
;	CALL	DSKRDY
;
;	RETURNS AS FROM DISK INTERRUPT:
;	R4 -> LAST DSQ PROCESSED
;	OTHER REGISTERS RANDOM
;-

.ENABL	LSB

DSKRDY:	MOV	R4,-(SP)	;SAVE DSQ POINTER
	MOVB	DSQJOB(R4),R5	;GET THE REQUESTED DISK INDEX
	MOVB	DSQPUN(R4),R4	;GET THE PHYSICAL UNIT
	CALLX	GETCSR		; AND GET THE CSR FOR THAT CONTROLLER IN R3
10$:	MOV	(SP),R4		;RESTORE DSQ POINTER
	MOVB	DSQJOB(R4),R2	;GET THE REQUESTED DISK INDEX
	MOV	DSS$DF,-(SP)	;SAVE THE DISK'S STATUS AND TIMER
	CALLX	GETTTY		;GRAB ANY TYPE-AHEAD
	TST	(SP)+		;ARE WE PROCESSING TIMEOUTS YET?
	BPL	15$		;NO,  NEED TO ENTER DRIVER TO SET TIMER
	TST	DSS$DF		;YES, TIMER EXPIRED?
	BPL	90$		;YES, PERFORM DRIVER TIMEOUT SERVICE
15$:	JMP	@100$(R2)	;     DISPATCH TO THE WAIT ROUTINE

WAITDZ:	BIT	#RXDNE,RX5CS0(R3) ;Done yet?				;020
	BEQ	10$		;No					;020
	BR	20$		;Yes, fake the interrupt		;020

WAITDW:	TST	RD5STS(R3)	;Still busy?				;020
.ASSUME	RDBSY LT 0							;020
	BMI	10$		;Yes, wait more				;020
	BR	20$		;No, so we're done			;020

WAITDV:
WAITDF:
WAITDS:
WAITDK:
WAITDM:
WAITDP:
WAITDB:
WAITDR:	BIT	#1,(R3)		;GO BIT DROPPED YET?
	BNE	10$		;NO
WAITDL:	TSTB	(R3)		;IS THE CONTROLLER READY?
	BPL	10$		;NO
20$:	CLR	R0		;SET R0 = 0 FOR THE INTERRUPT (PER INTSAV)
	CALL	@DSKINT(R2)	;AND ENTER THE DRIVER
30$:	MOV	(SP)+,R4	;RESTORE R4
	RETURN			;BACK



WAITDU:	CALL	UQPORT		;Call the common MSCP simulation rtn	;009
	BR	10$		;Continue waiting			;009
	BR	70$		;Returning from interrupt		;009
	.BR	60$		;Interrupt driver			;009

60$:	MOV	(SP),R4		;RESTORE DSQ POINTER (DESTROYED BY L3 PROCESS)
	MOVB	DSQJOB(R4),R2	;  TO GET THE DISK INDEX
	MOV	#70$,-(SP)	;SET RETURN ADDRESS FOR A MAPPED CALL
	MOV	@#KISAR5,-(SP)	; REMEMBER OUR PHASE FOR THAT RETURN
	MOV	@DSKINT(R2),-(SP);   STACK THE DRIVER'S ENTRY POINT (INT$xx)
	MOV	SAVPHZ,-(SP)	;      STACK THE DRIVER'S PHASE MMU
	MOVB	DSQPUN(R4),R0	;GET THE UNIT NUMBER
	ASL	R0		;  *2
	ASL	R0		;    *4
	MOV	UMT$DU(R0),R1	;      TO GET THE CMT OFFSET IN R1
	CLR	R0		;        CLEAR R0 FOR DIVIDE
	DIV	#CMTSIZ/2,R0	;          NOW COMPUTE CONTROLLER NO. *2 IN R0
	JMPX	CALLMX		;CALL MAPPED INTO DRIVER TO CHECK IT OUT
				;....CALLMX returns here...
70$:	MOV	CMT+CM.IC6,R2	;Is controller online?
	BMI	10$		;  No. Keep INTerupting driver until it is.
	MOV	R2,@#KISAR6	;Map to the MSCP region. (already mapped?)
	MOV	(SP),R4		;Get our saved DSQ pointer
	MOVB	DSQPUN(R4),R2		;GET THE UNIT NUMBER
	ASL	R2			;  *2
	ASL	R2			;    *4
	MOV	UMT$DU+UM.CMT(R2),R2	;      TO GET THE CMT OFFSET IN R1
	MOV	CMT+CM.COF(R2),R2 	;Get offset to this controller's CCB
	TST	C.OLDL(R2)	;Is our request still in the outstanding Q?
	BEQ	30$		;  No. Restore DSQ pointer and exit to check
				;      DQS$XX. If both = 0, I/O is done.
	BR	10$		;Request is still outstanding, call driver

	GLOBAL	<DSKAP6,L3QUE,L3QEND>



.SBTTL	MSCP/TMSCP INTERRUPT SIMULATION ROUTINE
;+
;	UQPORT
;	INPUT:	CMT simulation data from driver 
;		CM.ICS = CSR, 
;		CM.IC6 = MMU map to MSCP region
;		CM.IMK = Current step bit of PORT init sequence
;		CM.IRG = pointer to current response packet
;
;	OUTPUT: Returns to "RETURN" if driver is still waiting
;					(Update clock and timers)
;		Returns to "RETURN+2" if driver is returning from CON$PH
;					(Check for I/O done)
;		Returns to "RETURN+4" if driver is ready for an interrupt 
;					(dispatch to INT$??)
;-

UQPORT:	NOP			;~~~FOR DEBUGGING, REMOVE
	MOV	R0,-(SP)	;SAVE R0				;006
	MOV 	#L3QUE,R0	; TO USE AS POINTER			;006
75$:	TST	(R0)+		;ANYTHING PENDING?			;010
	BEQ	80$		;NO, NEXT WORD				;010
	MOV	(SP)+,R0	;YES, RESTORE R0 AND			;006
	MOV	#CHECK,-(SP)	; SET RETURN ADDRESS from CALLMX	;009
	JMP	DOL3Q		; SIMULATE "DSQ PROCESSING AT LEVEL3"   ;006

80$:	CMP	R0,#L3QEND	;ANY MORE L3Q?				;010
	BLO	75$		;YES, KEEP CHECKING			;011
	MOV	(SP)+,R0	;NO, SKIP L3 EMULATION			;006
	MOV	CMT+CM.ICS,R0	;R0=CSR ADDRESS
	TST	CMT+CM.IC6	;IS CONTROLLER SUPPOSED TO BE ONLINE?
	BPL	85$		;  YES. CHECK THE RESPONSE RING Q FOR DONE;010
	BIT	CMT+CM.IMK,UDASA(R0) ;NO, INITIALZING. IS DESIRED STEP BIT UP?
	BEQ	WAITUQ		;     NO, KEEP WAITING...		;010
	CLR	CMT+CM.IMK	;YES, CLEAR IT FOR NEXT STEP CHECK
	BR	INTRPT		;  AND LET IT RRRIPPP (Hungarian)
	
85$:	TST	UDASA(R0) 	;IS CONTROLLER REALLY ONLINE?		;010
	BMI	INTRPT		;FATAL CONTROLLER ERROR! ENTER INTERRUPT SERV.
	MOV	CMT+CM.IC6,@#KISAR6 ;MAP TO CCB OF ACTIVE CONTROLLER
	MOV	@CMT+CM.IRG,R0	;GET THE CURRENT RESPONSE RING POINTER
	MOV	DSKAP6,@#KISAR6	;RESTORE APR6 DISK PHASE MAPPING	;003
	TST	R0		;RESPONSE PACKET OWNED BY CONTROLLER?
	BMI	WAITUQ		;YES, KEEP WAITING UNTIL IT'S OUR'S	;010
	.BR	INTRPT		;NO, HE'S DONE WITH IT, SO FAKE THE INTERRUPT

INTRPT:	ADD	#2,(SP)		;Driver requires an interrupt, Return+4	;009
CHECK:	ADD	#2,(SP)		;Returning from interrupt, Return+2	;009
WAITUQ:	RETURN			;Continue waiting for I/O done		;010




90$:	MOV	R2,R5		;COPY DISK INDEX
	INCB	DSS$DF+1	;SET TIMEOUT INDICATOR TO 1
	MOV	#140000,R1	;SET ADDRESS FOR DISK TIMEOUT
	JMP	@110$(R2)	;DISPATCH TO THE DRIVER TMO ENTRY

TIMO:	MOV	#DQS$DF,R0	;POINT TO QUEUE ROOT
	CLR	R2		;SET R2=0, Z=1, C=0
	MOV	(SP),R4		;RETRIEVE THE DSQ POINTER FOR THE ERROR LOGGER
	CALL	@DSKTMO(R5)	;CALL TIMEOUT SERVICE
	BR	30$		;RESTORE DSQ POINTER AND EXIT

TIMODU:	MOV	#70$,-(SP)	;SET RETURN ADDRESS FOR A MAPPED CALL
	MOV	@#KISAR5,-(SP)	; REMEMBER OUR PHASE FOR THAT RETURN
	MOV	@DSKTMO(R2),-(SP);  STACK THE DRIVER'S ENTRY POINT (TMO$xx)
	MOV	SAVPHZ,-(SP)	;      STACK THE DRIVER'S PHASE MMU
	MOV	#DQS$DF,R0	;POINT TO QUEUE ROOT
	CLR	R2		;SET R2=0, Z=1, C=0
	JMPX	CALLMX		;CALL MAPPED INTO DRIVER TO CHECK IT OUT
				;RESTORE DSQ POINTER & EXIT (CALLMX RTNS 70$)




;+
;	I/O WAIT AND TIME-OUT ROUTINE DISPATCHING FOR DSKRDY
;
100$:	$DISKS
	.WORD	WAIT'NAME						;020
.ENDM

110$:	$DISKS
.IF	DIF	<NAME>,<DU>
	.WORD	TIMO
.IFF
	.WORD	TIMO'NAME
.ENDC
.ENDM

GLOBAL	<CMT,UMT$DU>

.DSABL	LSB


;+
; DSKSRU - START A DISK WITH PARAMETERS ON STACK.
;
;	R0 -> QUEUE ROOT
;	R1 =  HIGH ADDRESS
;	R2 =  LOW ADDRESS
;	R3 -> CSR
;	R4 -> DSQ
;	SP -> PARAMETERS, RETURN ADDRESS, ...
;
;	JMP	DSKSRU
;
;	ALL REGISTERS ARE RANDOM.
;-

DSKSRU::MOVB	#-5.,DSO$XX+1(R0) ;;SET FIVE SECOND TIMEOUT
	ASH	#4,R1		;;MEMORY ADDRESS <17-16> INTO <5-4>
	BIS	(SP)+,R1	;;.OR. PARAMETERS INTO FUNCTION WORD
	MOV	R2,4(R3)	;;SET LOW MEMORY ADDRESS
	MOV	DSQCNT(R4),2(R3) ;;SET -(COUNT)
	BISB	DSQFUN(R4),R1	;;BUILD FUNCTION
	MOV	R1,(R3)		;;NOW SET FUNCTION INTO CONTROL
	INC	R1		;;TURN ON THE "GO" BIT
	MOV	R1,(R3)		;; AND GO...
	RETURN			;;NOW EXIT

.DSABL	LSB


.SBTTL	HANDLE UNIBUS MAPPING REGISTERS

;+
; DSKUMR - ALLOCATE UMR'S FOR ADDRESSING A DISK TRANSFER
;
;	R0 -> QUEUE ROOT
;	R4 -> DSQ
;		DSQMAM = HIGH PHYSICAL ADDRESS
;		DSQMAL = LOW PHYSICAL ADDRESS
;		DSQCNT = -(WORD COUNT)	[-28K <= DSQCNT < 0]
;	PRIORITY IS PR5
;
;	CALL	DSKUMR
;
;	IF SUCCESS:
;		R1 =  HIGH ADDRESS
;		R2 =  LOW ADDRESS
;		DSO$XX(R0) [BYTE] =  0
;		C = 0
;-

DSKUMR::CLRB	DSO$XX(R0)		;;MARK THAT DRIVE IS DOING I/O
	MOVB	DSQMAM(R4),R1		;;PICK UP HIGH ADDRESS
	MOV	DSQMAL(R4),R2		;;PICK UP LOW ADDRESS
	;CLC				;;RETURN SUCCESS
	RETURN				;;SIMPLE ISN'T IT?

;+
; RHADR - HANDLE ADDRESSING FOR RH11 MAGTAPE
;
;	R0 = -(WORD COUNT)
;	R1 = HIGH ADDRESS
;	R2 = LOW ADDRESS
;	R3 -> CSR
;
;	CALL RHMADR	:	PRIORITY IS PR5
;
;	BACK	C = 0
;		CONTROLLER SET UP WITH ADDRESS AND COUNT
;-

RHMADR::MOV	R0,RHWC(R3)	;;SET WORD COUNT
	MOVB	R1,1(R3)	;;SET HIGH ADDRESS
	MOV	R2,RHBA(R3)	;;SET LOW ADDRESS
	CLC			;;RETURN SUCCESS
	RETURN


;+
; RHDADR - HANDLE ADDRESS ING FOR RH11 DISK
;	
;	R3 -> CSR
;	R4 -> DSQ
;		DSQMAM = HIGH ADDRESS
;		DSQMAL = LOW ADDRESS
;		DSQCNT = -(WORD COUNT)
;
;	CALL	RHDUMR	:	PRIORITY IS PR5
;
;	BACK	C = 0
;		CONTROLLER SET UP WITH ADDRESS AND COUNT
;
;-

.ENABL	LSB

RHDADR::MOV	DSQCNT(R4),RHWC(R3)	;;SET -(WORD COUNT)
	MOVB	DSQMAM(R4),1(R3)	;;SET HIGH ADDRESS
	MOV	DSQMAL(R4),RHBA(R3)	;;SET LOW ADDRESS
10$:	CLC				;;RETURN SUCCESS
	RETURN				;;SIMPLE ISN'T IT?

.DSABL	LSB


;+
; RHDSEL - SELECT RH11 DISK
;
;	R3 -> CSR
;	R4 -> DSQ
;
;	CALL	RHDSEL
;
;	R1 -> CSR @ RHCS2
;	R2 =  FIP UNIT NUMBER TIMES 2
;
;	IF Z=1 THEN CORRECT MASSBUS ID
;	IF Z=0 THEN MASSBUS ID MISMATCH
;-

RHDSEL::MOV	R3,R1		;;COPY THE CSR POINTER
	ADD	#RHCS2,R1	;; AND INDEX TO RHCS2
	MOV	#RHCLR,(R1)	;;DO A SUBSYSTEM CLEAR
	;CLC			;;C=0 FORM 'ADD' ABOVE
	ADC	RHAS(R3)	;;CLEAR ANY ACTIVE ATTN LINE
	MOVB	DSQPUN(R4),(R1)	;;SELECT THE MASSBUS UNIT
	MOVB	#RHESET,(R3)	;;NOW DO A DRIVE RESET
	MOVB	DSQUNT(R4),R2	;;GET FIP UNIT NUMBER
	ASL	R2		;; TIMES 2
	CMP	RHDT(R3),MID$XX(R2) ;;SET Z=1 IF MASSBUS ID MATCHES
	RETURN


;+
; RHDSRT - START RH11 DISK.
;
;	R0 -> QUEUE ROOT
;	R3 -> CSR
;	R4 -> DSQ
;	SP -> RETURN ADDRESS, ...
;
;	JMP	RHDSRT
;
;	ALL REGISTERS ARE RANDOM.
;-

RHDSRT::MOVB	#-5.,DSO$XX+1(R0) ;;SET 5. SECOND TIMEOUT
	ADD	#DSQCNT,R4	;;INDEX TO DSQ PARAMETERS

.DSECT	DSQRFN		;VERIFY ORDER IN THE DSQ

DSQRFN:	.BLKB		;RH11 FUNCTION
DSQMAM:	.BLKB		;MEMORY ADDRESS BITS <21-16>
DSQMAL:	.BLKW		;MEMORY ADDRESS BITS <15-0>
DSQCNT:	.BLKW		;-(COUNT)

	UNORG

	MOV	(R4),RHWC(R3)	;;SET THE -(COUNT)
	MOV	-(R4),RHBA(R3)	;;SET BITS <15-0> OF BUS ADDRESS
	MOVB	-(R4),1(R3)	;;SET BITS <17-16> OF BUS ADDRESS
	MOVB	-(R4),(R3)	;;LOAD FUNCTION AND GO...
	SUB	#DSQRFN,R4	;;RESET R4 -> DSQ
	RETURN			;; THEN EXIT


.SBTTL	ERROR LOGGING
;+
; PERRLG - LOG AN ERROR IN THE LIGHTS, AND PRINT DEVICE CSR'S
;
; SP -> RETURN ADDRESS FROM CALL, PREVIOUS PC+2, PREVIOUS PS
;
; ENTRY: CALL PERRLG	(DIRECTLY FROM EMT TRAP ENTRY)
;	 IF LOG$D?	is from a conventional disk driver, APR5 and APR6
;			map the Disk phase.
;	 IF LOG$DU	from the UDA phase, R1 points to packet in MSCP
;			region, and APR6 maps that region.
;
; BACK:	ERROR COUNTER (ERRCTR) INCREMENTED & PLACED IN LIGHTS (IF ANY).
;	CSR'S LISTED ON CONSOLE TERMINAL.
;+

.ENABL	LSB

PERRLG::INC	ERRCTR		;ANUDDER ERROR
	NOP								;023
	TSTB	SWR$W		;CAN WE WRITE THE SWITCHES (LIGHTS)?
	BMI	10$		;NO
	MOV	ERRCTR,@#SWR	;YES, PUT THE ERROR IN LIGHTS
10$:	REGSAV			;SAVE REGISTERS
	TSTB	DSIFLG		;Suppress DSKINT error display?		;025
	BGT	50$		;Yes, so no display, restore regs, rtn	;025
	CMP	@#KISAR6,#DSK$P2;Is DSK Phase mapped in APR6?		;023
	BNE	20$		;No, so must by MSCP disk		;023

; Note:  The following code assumes that the stack is setup and cleaned	;023
; up by the calling routine.  The following is done to determine whether;023
; a disk or tape error occurred.					;023

	MOV	TOS.PC+2(SP),R5	;GET PC+2 OF TRAP 
	MOV	-(R5),R1	;Get word of code (if mapped)		;023
	CMP	R1,#EMT+LOG$SZ 	;IS IT A PRE-DEFINED (I.E. DISK) ERROR?	;023
	BLO	24$		;YES, SET UP FOR DISKS			;027
12$:	MOV	MAGNDX,R5	;NO, GET MAGTAPE INDEX
	BEQ	15$		;Bad index, something is wrong		;023
	MOV	MAGUNT,R4	; AND UNIT NUMBER
	BR	30$		;GO PRINT HEADER FOR IT

15$:	MESSAGE <"Invalid device for error"<200>>			;023
	BR	50$		;Restore regs and return		;023

20$:	TSTB	E.CRDT+1(R1)	;Tape or disk?				;027
	BNE	12$		; TAPE - TMSCP				;027
	TST	R4		;Is there a DSQ?			;026
	BNE	24$		; Yes, so not an MSCP controller error	;026
	MOV	C.OLDL(R5),R4	; No, MSCP controller error, get DSQ	;026
24$:	MOVB	DSQJOB(R4),R5	;GET DISK TYPE INDEX
	MOVB	DSQPUN(R4),R4	; AND UNIT NUMBER
30$:	CALL	ERRHDR		;PRINT HEADER IF NECESSARY, AND SET R1 & R2
	CALLX	TYPTAB		;LEAVE BLANK SPACE ON LEFT
	TST	(R1)+		;SKIP FIRST WORD OF FIRST NAME
	CALL	DMPREG		;DUMP ALL THE REGISTER ON THE CONSOLE
	CMP	R5,#IDX$DU	;IS THIS AN MSCP DEVICE?
	BEQ	35$		;Yes, more to do			;011
	CMP	R5,#IDX$MU	;No, how 'bout TMSCP device?		;011
	BNE	40$		;NO, CSR'S IS ALL WE PRINT
35$:	MOV	TOS.R1(SP),R2	;GET THE PACKET ADDRESS FROM MSCP ERRORS
				;  APR6 STILL MAPS MSCP REGION.
	BEQ	40$		;NO PACKET, SO ALL WE CAN PRINT IS CSR REGS
	TST	(R1)+		;SKIP OVER THE "END OF CSRS" FLAG WORD
	CALL	DMPREG		;DUMP ALL THE PACKET PARAMETERS ON THE CONSOLE
40$:	CALLX	TYPECR		;DONE -- FINISH THE LINE
	MOV	R5,HDRIDX	;RESTORE FLAGS THAT CURRENT HEADER
	MOV	R4,HDRUNT	;REALLY IS CURRENT
50$:	CALLX	REGRES,R5	;RESTORE REGISTERS
	RETURN			;RETURN TO CALLER




;+
;	DMPREG		Dump an octal register to the console
;			R2= Base address of CSR or Packet, R1 -> offset table
;-
DMPREG:	TST	(R1)+		;SKIP SECOND WORD OF NAME
	CALLX	TYPTAB		;SKIP TO PRINTING COLUMN
	MOV	(R1)+,R0	;PICK UP OFFSET TO A REGISTER
	ADD	R2,R0		;ADD MAJOR DEVICE ADDRESS
	MOV	(R0),R0		;PICK UP ITS CONTENTS
	CALLX	OCTWRD		;PRINT IT
	TST	(R1)+		;IS THERE ANOTHER NAME? (SKIP IT)
	BNE	DMPREG		;YES -- REPEAT
	RETURN

GLOBAL	<ERRCTR,SWR$W,HDRIDX,HDRUNT>


; ERRHDR -- PRINT HEADER FOR A DEVICE IF NECESSARY.
;
;	R5 = IDX$XX
;	R4 = UNIT #
; CALL	ERRHDR
;	R2 -> MAJOR REG
;	R1 -> LIST OF NAMES & OFFSETS
;	HEADER PRINTED UNLESS THE LAST THING PRINTED WAS AN ERROR
;	FOR THIS DRIVE.

.ENABL	LSB

ERRHDR:	NOP			;debug					;023
	CMP	R5,HDRIDX	;IS HEADER FOR THIS CONTROLLER OUTSTANDING?
	BNE	10$		;NO -- WE MUST PRINT A HEADER
	CMP	R4,HDRUNT	;YES -- IS HEADER FOR THIS UNIT OUTSTANDING?
	BEQ	40$		;YES -- PERFECT MATCH -- JUST SET REGS
10$:	MOV	R5,HDRIDX	;FLAG THIS HEADER IS OUTSTANDING
	MOV	R4,HDRUNT	;FOR THIS UNIT
	MOV	(PC)+,R2	;PRINT CR LF LF
	 .BYTE	200,12
	CALLX	TYPE2
	MOV	DSKNAM(R5),R2	;PRINT DEVICE TYPE
	CALLX	TYPE2
	MOV	R4,R0		;COPY UNIT NUMBER
	CALLX	DECZER		;PRINT IT -- WE NOW HAVE 'DK3'
	MESSAGE	<" Error">
	MOV	DSKHDR(R5),R1	;POINT TO LIST OF CSR NAMES & OFFSETS
	CALL	DMPRAD		;  AND GO PRINT THE TEXT HEADER LINE
	CMP	R5,#IDX$DU	;MSCP FLAVOR DEVICE?
	BEQ	20$		;Yes, more to do			;011
	CMP	R5,#IDX$MU	;No, TMSCP flavor?			;011
	BNE	30$		;NO, FINISH UP
20$:	TST	TOS.R1+2(SP)	;Is there a [T]MSCP Packet?		;026
	BEQ	30$		; No, so we are all done then		;026
	CALL	DMPRAD		;YES, PRINT THE PACKET PARAMETER HEADER
30$:	CALLX	TYPECR		;PRINT CR LF
40$:	MOV	DSKHDR(R5),R1	;SET UP REGISTERS AS ADVERTISED
	CALLX	GETCSR		;GET THE 1ST CSR FOR THIS DEVICE
	MOV	R3,R2		;  AND SAVE IT IN R2
	TST	R5		;DISK?
	BPL	50$		;YES, WE GOT ITS CSR
	MOV	MAGCSR(R5),R2	;MAGTAPE, LOOK ELSEWHERE FOR CSR
	CMP	R5,#IDX$MU	;TMSCP device?				;011
	BNE	45$		;No, maybe TS04				;011
	MOV	R4,-(SP)	;Yes, get unit #			;011
	ASL	(SP)		;		* 2			;011
	ASL	(SP)		;		  * 4			;011
.ASSUME UMTSIZ	EQ 4
	ADD	#UMT$MU,(SP)	;Point to UMT for this unit		;011
	MOV	@(SP)+,R3	;Now get CMT offset			;011
	CLR	R2		;Clear for divide			;011
	DIV	#CMTSIZ/2,R2	; by CMTSIZ/2 to get controller # * 2	;011
	BEQ	42$		;CONTROLLER # IS CORRECT		;017
	MOVB	CMT+CM.DCT,-(SP) ;GET THE TOTAL # OF DISK CONTROLLERS	;017
	BIC	#^C<377>,(SP)	;GET RID OF EXTRANEOUS BITS		;017
	ASL	(SP)		;MAKE IT MAX DISK CTRLR # * 2		;017
	SUB	(SP)+,R2	;GET REAL TAPE CNTRLR #*2		;017
42$:	MOV	CSRTBL+MU.CSO(R2),R2	;Now get CSR (Finally!)		;011
	BR	50$		;Finish up				;011

45$:	CMP	R5,#IDX$MS	;TS04 DEVICE?
	BNE	50$		;NO, RETURN
	MOV	#MAGDDB+MTDDSP+MTFQB+2,R2 ;YES, PRETEND DDB CONTAINS CSR'S
50$:	RETURN			;ALL DONE

DMPRAD:	MOV	(R1)+,R0	;R0 = FIRST PART OF NAME IN RAD50
	BEQ	50$		;EXIT IF NONE
	CALLX	TYPTAB		;SKIP TO NEXT COLUMN
	CALLX	RADZER		;PRINT IT IF IT'S THERE
	MOV	(R1)+,R0	;R0 = SECOND PART OF NAME
	CALLX	RADZER		;PRINT IT
	TST	(R1)+		;SKIP OVER CSR OFFSET
	BR	DMPRAD		;REPEAT

GLOBAL	<HDRIDX,HDRUNT,MAGDDB,CSRTBL,MU.CSO,UMT$MU>

.DSABL	LSB


	$TAPES
	.WORD	NAME'.HDR
.ENDM
DSKHDR:	$DISKS
	.WORD	NAME'.HDR
.ENDM

.MACRO	$	NAME,OFFSET
$$$$$$=	.
	.RAD50	/NAME/
.IF	GT	$$$$$$+4-.
	.WORD	0			;ENSURE 2 WORDS OF RAD50
.ENDC
.IF	B	OFFSET
	.WORD	NAME
.IFF
	.WORD	OFFSET
.ENDC
.ENDM	$

.NLIST	MEB				;WE DON'T ALWAYS WANT TO SEE THIS

DV.HDR:	.WORD	0			;No error logging for DV:

DF.HDR:	$	DCS,RFCS
	$	WC,2
	$	CMA,4
	$	DAR,RFDAR
	$	DAE,RFDAE
	$	MA,14
	$	ADS,RFADS
	.WORD	0

DS.HDR:	$	RSCS1,RHCS1
	$	RSWC,RHWC
	$	RSBA,RHBA
	$	RSDA,6
	$	RSCS2,RHCS2
	$	RSDS,RHDS
	$	RSER,RHER
	.WORD	0


DK.HDR:	$	RKDS
	$	RKER
	$	RKCS,0
	$	RKWC
	$	RKBA,RKMA
	$	RKDA
	.WORD	0

DL.HDR:	$	RLCS
	$	RLBA
	$	RLDA
	$	RLMP
	.WORD	0

DM.HDR:	$	RKCS1,RMCS1
	$	RKWC,RMWC
	$	RKDA,RMDA
	$	RKCS2,RMCS2
	$	RKDS,RMDS
	$	RKER,RMER
	$	RKDCYL,RMDCY
	.WORD	0

DP.HDR:	$	RPDS
	$	RPER
	$	RPCS,0
	$	RPWC
	$	RPBA,RPMA
	$	RPCA
	$	RPDA
	.WORD	0

DR.HDR:	$	RMCS1,RHCS1
	$	RMWC,RHWC
	$	RMDA,RBDA
	$	RMCS2,RHCS2
	$	RMDS,RHDS
	$	RMER1,RHER
	$	RMDC,RBDC
	.WORD	0

DB.HDR:	$	RPCS1,RHCS1
	$	RPWC,RHWC
	$	RPDA,RBDA
	$	RPCS2,RHCS2
	$	RPDS,RHDS
	$	RPER1,RHER
	$	RPDC,RBDC
	.WORD	0

DZ.HDR:	$	RX5ID							;020
	$	RX5CS0							;020
	$	RX5CS1							;020
	$	RX5CS2							;020
	$	RX5CS3							;020
	$	RX5CS4							;020
	.WORD	0							;020

DW.HDR:	$	RD5ID							;020
	$	RD5ERR							;020
	$	RD5SEC							;020
	$	RD5DAT							;020
	$	RD5CYL							;020
	$	RD5TRK							;020
	$	RD5ST2							;020
	$	RD5STS							;020
	.WORD	0							;020

MU.HDR:					;TMSCP/MSCP ERROR PACKET	;010
DU.HDR:	$	UDASA
	.WORD	0			;END OF CSRS
	$	P.OPCD			;THESE PARAMETERS STORED IN PACKET
	$	P.STS
	$	P.BCNT
	$	P.BUFF
	$	P.BUF2,P.BUFF+2
	$	P.LBN
	.WORD	0			;END OF MSCP PACKET


MS.HDR:	$	TSRBPC,4		;THESE MESSAGE WORDS ARE STORED IN DDB
	$	TSXSR0,6
	$	TSXSR1,10
	$	TSXSR2,12
	$	TSXSR3,14
	$	TSXSR4,14						;011
	$	TSSR,20							;011
	.WORD	0

MT.HDR:	$	MTS,MTAS
	$	MTC,MTAC
	$	MTBRC,MTABRC
	$	MTCMA,MTACMA
	$	MTD,MTARDB
	$	MTRD,MTARDL
	.WORD	0

MM.HDR:	$	MTCS1,RHCS1
	$	MTWC,RHWC
	$	MTFC,MMFC
	$	MTCS2,RHCS2
	$	MTDS,RHDS
	$	MTER,RHER
	$	MTTC,MMTC
	.WORD	0

.LIST	MEB


.SBTTL	DISK RESETTERS

;+
; PXRSET - RESET DISK
; ??RSET - RESET SPECIFIC DISK TYPE
;
; CALL:	R1 = DISK INDEX
;	R4 = UNIT NUMBER (*1)
;	CALL	XXRSET
;
;	DISK PHASE MAPPED THROUGH APR5
;
; BACK:	R1 = DISK CSR
;	C=1 IFF ERROR
;-

PXRSET::JMP	@10$(R1)	;AN EASY DISPATCH TO THE RIGHT RESETTER
10$:	$DISKS
	 .WORD	NAME'RSET		;NAME RESETTER
.ENDM


.SBTTL	DF RESETTER

DFRSET::MOV	DSKCSR+IDX$DF,R1 ;GET ADDRESS OF CONTROLLER STATUS REGISTER
	BEQ	NODISK		;NO SUCH DEVICE
	MOV	#RFCLR,(R1)	;CLEAR RF CONTROLLER
	MOVB	#-5,DSS$DS+1	;TIME OUT AFTER 5 SECONDS
	CALL	RSWAIT		;WAIT FOR READY OR ERROR
DZRSET::								;020
DWRSET::								;020
DVRSET::RETURN			;RETURN WITH C=0 IF NO ERROR

.SBTTL	DR/DB RESETTER

.ENABL	LSB

DRRSET::MOV	DSKCSR+IDX$DR,R1 ;DR RESETTER IS IDENTICAL TO DB RESETTER
	BR	10$		;EXCEPT FOR CONTROLLER ADDRESS
DBRSET::MOV	DSKCSR+IDX$DB,R1 ;SET POINTER TO RH/RB CS1
10$:	CALL	RHCOM		;CLEAR CONTROLLER
	BCS	RSETXC		;ERROR, RETURN C=1
	MOV	#21,(R1)	;DO READ-IN PRESET
	MOV	#14000,RBOF(R1)	;SET PDP-11 MODE AND ECC INHIBIT
	MOV	#7,(R1)		;NOW RECALIBRATE UNIT
	MOVB	#-5,DSS$DB+1	;TIME OUT AFTER 5 SECONDS
20$:	CALLX	GETTTY		;WATCH THE TERMINAL AND THE CLOCK
	TST	DSS$DB		;TIMEOUT?
	BPL	RSETXC		;YES -- RETURN WITH CARRY SET
	MOV	RHDS(R1),-(SP)	;GET STATUS
	BIC	#^C<RHERR!RHDRY>,(SP) ;LEAVE ONLY ERR AND DRY
	ASL	(SP)+		;CHECK IT
	BMI	RSETXC		;ERROR, SO EXIT C=1
	BEQ	20$		;NOTHING, SO WAIT
	MOV	RHAS(R1),RHAS(R1) ;O.K., SO CLEAR ATA
	BR	RSETXT		;EXIT, SETTING CARRY

.DSABL	LSB
GLOBAL	<DSKCSR>


.SBTTL	DS RESETTER

DSRSET::MOV	DSKCSR+IDX$DS,R1 ;POINT TO RHCS1 FOR RS04
RHCOM::	TST	R1		;ANY CONTROLLER?
	BEQ	NODISK		;NO
	MOV	#RHCLR,RHCS2(R1) ;CLEAR CONTROL AND ALL DRIVES
	MOV	RHAS(R1),RHAS(R1) ;CLEAR ANY ACTIVE ATTN LINE
	MOVB	R4,RHCS2(R1)	;SELECT UNIT
	MOV	#11,(R1)	;DRIVE CLEAR UNIT
RHMCOM:	MOVB	#-5,DSS$DS+1	;TIME OUT AFTER 5 SECONDS
10$:	CALLX	GETTTY		;WATCH THE TERMINAL AND THE CLOCK
	TST	DSS$DS		;TIMEOUT?
	BPL	RSETXC		;YES -- RETURN WITH CARRY SET
	BIT	#160200,(R1)	;WAIT?
	BEQ	10$		;YES
	BR	RSETXT		;NO

NODISK:	TSTB	NOERR		;ARE WE SUPPRESSING ERRORS?
	BEQ	10$		;NOPE, GIVE HIM A BAD ERROR
	SEC			;INDICATE THAT WE CANNOT RESET THIS DEVICE
	RETURN			;AND RETURN

10$:	ERF	<"Requested device drive not found.">

GLOBAL	<DSKCSR>


.SBTTL	DK RESETTER

DKRSET::MOV	DSKCSR+IDX$DK,R1 ;GET RK CONTROLLER STATUS REGISTER ADDRESS
	BEQ	NODISK		;NO CONTROLLER
	CLR	(R1)		;SET CONTROL RESET FUNCTION
	INC	(R1)		;GIVE 'ER THE GO
	MOVB	#-5,DSS$DK+1	;TIME OUT AFTER 5 SECONDS
10$:	CALLX	GETTTY		;WATCH THE TERMINAL AND THE CLOCK
	TST	DSS$DK		;TIMEOUT?
	BPL	RSETXC		;YES -- RETURN WITH CARRY SET
	TSTB	(R1)		;CONTROLLER READY
	BPL	10$		;NOT YET
	MOV	R4,-(SP)	;SAVE THE UNIT NUMBER
	ASH	#13.,R4		;SHIFT UNIT BITS INTO BITS 13,14,15
	MOV	R4,RKDA(R1)	;NOW SET THE UNIT
	MOV	(SP)+,R4	;RESTORE R4
	MOV	#14,(R1)	;LOAD THE DRIVE RESET FUNCTION
	INC	(R1)		;GO
	MOVB	#-5,DSS$DS+1	;TIME OUT AFTER 5 SECONDS
20$:	CALL	RSWAIT		;WAIT FOR READY, RETURN IF NO ERROR
	BITB	#100,RKDS(R1)	;WAIT FOR ACCESS READY
	BEQ	20$		;

.ENABL	LSB

RSETXT:	TST	(R1)		;ANY ERRORS
	BPL	10$		;NOT THIS TIME
RSETXC:	SEC			;YES, RETURN C=1
10$:	RETURN			;WITH CARRY INDICATING ERROR

.DSABL	LSB

GLOBAL	<DSKCSR>


.SBTTL	DL RESETTER

DLRSET::MOV	DSKCSR+IDX$DL,R1 ;GET RL CONTROLLER ADDRESS
	BEQ	NODISK		;EXIT IF NO CONTROLLER
	MOV	#13,RLDA(R1)	;RESET THE DRIVE
	MOV	#RLGSTS,-(SP)	;MAKE A "GET-STATUS" COMMAND
	BISB	R4,1(SP)	;FOR THE PROPER UNIT
	MOV	(SP)+,(R1)	;SEND COMMAND TO THE CONTROLLER
	MOVB	#-5,DSS$DS+1	;TIME OUT AFTER FIVE SECONDS
	CALL	RSWAIT		;WAIT FOR READY BIT
	RETURN			;ALL DONE


.SBTTL	DP RESETTER

DPRSET::MOV	DSKCSR+IDX$DP,R1 ;GET ADDRESS OF RP CONTROLLER STATUS
	BEQ	NODISK		;NO CONTROLLER
	CLR	(R1)		;SET CONTROL RESET FUNCTION
	INC	(R1)		;AND GIVE THE GO
	MOVB	#-5,DSS$DP+1	;TIME OUT AFTER 5 SECONDS
10$:	CALLX	GETTTY		;WATCH THE TERMINAL AND THE CLOCK
	TST	DSS$DP		;TIMEOUT?
	BPL	RSETXC		;YES -- RETURN WITH CARRY SET
	TSTB	(R1)		;CONTROLLER READY ?
	BPL	10$		;SOON
	MOV	#14,-(SP)	;GET DRIVE RESET FUNCTION
	MOVB	R4,1(SP)	;PUT UNIT NUMBER IN HIGH BYTE
	MOV	(SP)+,(R1)	;LOAD THE FUNCTION
	INC	(R1)		;AND GO
	MOVB	#-5,DSS$DS+1	;TIME OUT AFTER 5 SECONDS
20$:	CALL	RSWAIT		;WAIT FOR READY, RETURN IF NO ERROR
	TST	RPDS(R1)	;WAIT FOR SELECTED UNIT READY
	BPL	20$		;
	BR	RSETXT		;TAKE COMMON EXIT

RSWAIT:	CALLX	GETTTY		;WATCH THE TERMINAL AND THE CLOCK
	TST	DSS$DS		;TIMEOUT?
	BPL	10$		;YES, RETURN WITH CARRY SET
	TSTB	(R1)		;CONTROLLER READY?
	BPL	RSWAIT		;NO, WAIT
	TST	(R1)		;ERROR?
	BPL	20$		;NO, TAKE NORMAL RETURN
10$:	COM	(SP)+		;DUMP RETURN AND SET CARRY
20$:	RETURN			;RETURN C=0 TO CALLER OR C=1 TO HIS CALLER

GLOBAL	<DSKCSR>


.SBTTL	DM RESETTER

DMRSET::MOV	DSKCSR+IDX$DM,R1 ;GET CSR ADDRESS
	BEQ	NODISK		;NO CONTROLLER
	MOV	#RMSCLR,RMCS2(R1) ;CLEAR CONTROLLER, INIT ALL DRIVES
	MOV	R4,RMCS2(R1)	;SET THE UNIT NUMBER
	ASL	R4		;DOUBLE THE UNIT
	MOV	DM$MID(R4),-(SP) ; AND GET THE UNIT TYPE
	ASR	R4		;FIX R4
	MOVB	#RMACK,(SP)	;FUNCTION IS ACK
	MOV	(SP)+,(R1)	;DO IT
	MOVB	#-5,DSS$DS+1	;TIMEOUT AFTER 5 SECONDS
	CALL	RSWAIT		;WAIT A WHILE
	MOV	RMDS(R1),-(SP)	;GET DRIVE STATUS
	COM	(SP)		;REQUIRE FOLLOWING BITS TO BE ON
	;SEC
	BIT	#RMSVAL!RMDRDY!RMVV!RMDRA,(SP)+
	BNE	10$		;FAIL WITH C=1 IF ANY WERE OFF
	CLC
10$:	RETURN			;IF NO ERROR, RETURN C=0

GLOBAL	<DSKCSR,DM$MID>


.SBTTL	MM RESETTER

.ENABL	LSB

MMRSET:	MOV	CSRMM,R1	;GET THE CSR ADDRESS
	BNE	20$		;GOOD, THERE IS ONE
10$:	JMP	NODISK		;BAD, THERE IS NONE
20$:	MOV	#RHCLR,RHCS2(R1) ; CLEAR ENTIRE SUBSYSTEM
	ASL	R4		;DOUBLE THE UNIT NUMBER
	MOV	MM$FOR(R4),RHCS2(R1) ;SET THE FORMATTER NUMBER
	ASR	R4		;UNDOUBLE UNIT NUMBER
	MOV	R4,MMTC(R1)	;SET SLAVE #
	MOV	RHAS(R1),RHAS(R1) ;CLEAR ALL ATTN LINES
	CALL	RHMCOM		;NOW TREAT LIKE RH11 DEVICE
	BCS	RSETXC		;ON ERROR, RETURN C=1
	MOV	RHDT(R1),-(SP)	;GET DRIVE TYPE
	BIC	#47,(SP)	;CLEAR TM03 & SLAVE BITS
	CMP	(SP)+,#RHNSA!RHTAP!RHSPR!10 ;REALY A TAPE
	BNE	RSETXC		;NO, ERROR
	BIT	#RHMOL,RHDS(R1)	;ON LINE?
	BEQ	RSETXC		;NO, ERROR
	BR	RSETXT		;YES, WE'RE HAPPY

.SBTTL	MT RESETTER

MTRSET:	MOV	CSRMT,R1	;GET THE CSR ADDRESS
	BEQ	10$		;IF NONE THEN WE HAVE AN ERROR
	CLC			;INDICATE A GOOD RESET
	RETURN			;AND RETURN

.SBTTL	MS RESETTER

MSRSET:	MOV	#CSRMS,R1	;GET A POINTER TO THE CSR
	ASL	R4		;DOUBLE THE UNIT NUMBER
	ADD	R4,R1		;POINT TO THE CORRECT CSR
	MOV	(R1),R1		;GET THE CSR
	BEQ	10$		;NO CSR, THIS IS A BIG MISTAKE
	CLC			;INDICATE A GOOD RESET
	RETURN			;AND RETURN

.DSABL	LSB

GLOBAL	<CSRMM,MM$FOR,CSRMT,CSRMS>


.SBTTL	DU RESETTER

.ENABL	LSB

DURSET::NOP			;Let the driver do the reset, if it needs it.
				;Patch to NOP [MSCP ECO 19-Jan-83 Unit sizes]
	MOVB	NOERR,-(SP)	;Save the previous NOERR indicator	;005
	MOVB	BACKUP,-(SP)	;Save the previous BACKUP indicator	;005
	MOVB	#-1.,NOERR	;Say fatal errors are really non-fatal	;005
	MOVB	#-1.,BACKUP	;  we're not going to print them anyway	;005
	MOV	R1,-(SP)	;Save the controller index for later
	MOV	R4,-(SP)	;Save the unit number for later
	ASL	R4		;Unit no. * 2 to index into the size tables
	TST	DU$MID(R4)	;Does this unit exist			;007
	BEQ	10$		;Yes.					;007
	SEC			;No - error				;007
	BR	60$		;Exit					;024
	
;
;	Call the DU driver directly to bring a unit online		
;
10$:	MOV	#FILDSQ+DSQFUN,R4	;Set pointer to the file DSQ @ DSQFUN
	MOVB	(SP),DSQPUN-DSQFUN(R4)	;Set Physical unit number in DSQ
	MOV	#IFUN,(R4)		;Set the initialize function	;009
	MOV	#DSQFUN-DSQL3Q/2,R1	;Clear DSQFUN			;009
20$:	CLR	-(R4)			;         Through DSQL3Q	;009
	SOB	R1,20$			;				;009
	MOV	#IDX$DU,-(R4)		;Set up the disk index		;009
	CLR	-(R4)			;Zero link word
	CALL	PDISK			;  and kick his NADS into action
	MOV	CMT+CM.IC6,@#KISAR6	;Map APR6 into CCB of the MSCP region
	MOV	(SP),R4			;Get the unit # *1
	ASL	R4			;		*2
	MOV	R4,R1			;		and save for index
	ASL	R4			;		*4
	ADD	#UMT$DU,R4		;Point into the unit's UMT entry
	MOV	UM.UCB(R4),R4		;  now get the UCB pointer
	MOV	U.UNSZ+2(R4),-(SP)	;Stack the unit size [MSB]
	MOV	U.UNSZ(R4),DU$SZL(R1)	;Store the unit size [LSB]
	BNE	30$			;If it's non-zero then it's valid;009
	TST	(SP)			;We better have a valid size.	 ;009
	BNE	30$			;If it's non-zero then it's valid;009
	MOV	#800.,DU$SZL(R1)	;Set RX50 size to permit access	 ;009
30$:	MOV	#1,R4			;Initial DCS =1
	SUB	R4,DU$SZL(R1)		;Max LBN = disk size -1
	SBC	(SP)			;  Double precision
	MOV	(SP),DU$SZM(R1)		;Store the unit size [MSB]
	BEQ	50$			;If MSB is zero,, then DCS =1
40$:	ASL	R4			;If not, then DCS = DCS * 2
	CMP	R4,#64.			;Is disk to big for RSTS	 ;022
	BHI	70$			;Yes.
	ASR	(SP)			;Now shift MSB (MSB = MSB / 2)
	BNE	40$			;  and if it's not zero, double DCS
50$:	MOV	R4,DU$DCS(R1)		;Store this unit's Device Cluster Size
	TST	(SP)+			;Dump the shifted MSB size
60$:	MOV	(SP)+,R4	;Restore the Unit number
	MOV	(SP)+,R1	;Restore disk index
	MOVB	(SP)+,BACKUP	;Restore the previous BACKUP indicator	;005
	MOVB	(SP)+,NOERR	;Restore the previous NOERR indicator	;005
	RETURN			;  and return.

70$:	PUSH	<R0>			;Save R0
	MESSAG	<"DU">			;Issue error
	MOV	R1,R0			;Copy unit *2
	ASR	R0			;  now * 1
	CALLX	DECZER			;Print the unit
	MESSAG	<" disk capacity is too large.">
	POP	<R0>			;Restore R0
	ASR	R4			;Back to last DCS
	BR	50$			;	and exit
; Note: Warning message is printed, however access is still permitted	;009

.DSABL	LSB
GLOBAL	<DU$MID,DU$SZL,DU$SZM,DU$DCS,FILDSQ,UMT$DU>


.SBTTL	MU RESETTER
;+
; MURSET - RESET THIS TMSCP DEVICE.  AS IT STANDS NOW
;	   WE DON'T DO MUCH HERE.
;-
.ENABL	LSB

MURSET::NOP			;BPT FOR ODT			;010
	MOV	R4,-(SP)	;Get unit #			;011
	ASL	(SP)		;	    * 2			;011
	ASL	(SP)		;	      * 4		;011
.ASSUME	UMTSIZ	EQ 4
	ADD	#UMT$MU,(SP)	;Point to UMT for this unit	;011
	MOV	@(SP)+,R1	;Get CMT offset			;011
	MOV	R0,-(SP)	;Save R0			;011
	CLR	R0		;Clear for divide		;011
	DIV	#CMTSIZ/2,R0	; by CMTSIZ/2 to get cont # * 2	;011
	BEQ	5$		;CONTROLLER # * 2 IS CORRECT	;017
	MOVB	CMT+CM.DCT,-(SP) ;GET THE TOTAL # OF DISK CONTROLLERS ;017
	BIC	#^C<377>,(SP)	;GET RID OF EXTRANEOUS BITS		;017
	ASL	(SP)		;MAKE IT MAX DISK CTRLR # * 2	;017
	SUB	(SP)+,R0	;GET REAL TAPE CNTRLR #*2	;017
	MOV	R0,R1		;Copy back to R1		;011
5$:	MOV	(SP)+,R0	;Restore R0			;018
	MOV	CSRTBL+MU.CSO(R1),R1	;Now get CSR		;011
	BNE	10$		;IT EXISTS			;010
	JMP	NODISK		;NOTHING, AHHHHHHH!		;010

10$:	CLC			;INDICATE A GOOD RESET		;010
	RETURN			;AND RETURN...			;010

.DSABL	LSB


GLOBAL	<DU$SZL,DU$SZM,DU$DCS,CSRTBL,MU.CSO>			;017
.SBTTL	CONVERT VIRTUAL ADDR INTO A UNIBUS ADDR
;+
; UNIMAP - CONVERT VIRTUAL ADDR INTO A UNIBUS ADDR
;
;	R2 	= Address to store 2 word unibus address
;
;	CALL	UNIMAP,R5,LABEL
;		Where LABEL = the virtual address to convert
;
;	R2	= R2+2
;		= Low order unibus address of virtual PC.
;		= High order unibus address of virtual PC.
;
;-
.ENABL	LSB

UNIMAP:	MOV	R0,-(SP)		;SAVE A WORKING REGISTER
	MOV	R1,-(SP)		;SAVE A WORKING REGISTER
	MOV	R2,-(SP)		;SAVE DESTINATION ADDR OF RESULT
	MOV	(R5)+,R2		;GET THE VIRTUAL ADDR
	MOV	R2,R0			;COPY THE VIRT PC TO R0
	BIC	#160000,R2		;CLEAR OUT THE PAF, R2= DISPL FIELD
	ASH	#-12.,R0		;SHIFT TO GET PAF *2
	BIC	#^C17,R0		;CLEAR ANY PROPAGATION.
	MOV	KISAR0(R0),R1		;NOW GET KERNEL'S MMU FOR THAT PAGE
	CLR	R0			;CLEAR FOR HIGH ORDER VALUE
	ASHC	#6.,R0			;SHIFT MMU TO GET TO BYTE ADDR
	ADD	R2,R1			;  AND ADD THE DISPL FIELD
	ADC	R0			;  WITH CARRY TO HIGH ORDER.
	MOV	(SP)+,R2		;RESTORE OUR DESTINATION ADDR
	MOV	R1,(R2)+		;MOVE IN LOW ORDER UNIBUS ADDR
	MOV	R0,(R2)			;MOVE IN HIGH ORDER UNIBUS ADDR
	MOV	(SP)+,R1		;AND RESTORE OUR WORKING REGISTER
	MOV	(SP)+,R0		;AND RESTORE OUR WORKING REGISTER
	RETURN	R5

GLOBAL	<KISAR0>
.DSABL	LSB


;+
; PMAGIO - READ OR WRITE MAGTAPE
;
;	R0 = MAGTAPE INDEX
;		-2 = MM -4 = MT -6 = MS -10 = MU		
;	R1 = UNIT NUMBER
;	I.DSQ+DSQCNT = NUMBER OF WORDS TO TRANSFER
;	HIGHBF = HIGH ORDER BUFFER ADDRESS
;
;	MAGTAPE HAS BEEN 'SET UP' WITH SETTAP
;	DISK PHASE MAPPED THROUGH APRS 5 AND 6
;
;	CALL	PMAGIO,R5,<FUN,LOWADDR>
;		FUN = 2 FOR WRITE, 4 FOR READ
;		LOWADDR = LOW-ORDER BUFFER ADDRESS
;
;	BACK	IOERR = ERROR CODE
;		C = 0 IF NO ERROR, 1 IF SOME ERROR
;-

.ENABL	LSB

PMAGIO::REGSAV
	MOV	R0,MAGNDX	;SAVE MAGTAPE TYPE INDEX
	MOV	R1,MAGUNT	;AND UNIT
	MOVB	R1,MAGDDB+DDUNT	;SAVE UNIT NUMBER IN DDB
	CALL	ZAPXRB		;CLEAR XRB & POINT TO IT
	MOV	#6,R2		;PREPARE FOR ARITHMETIC
	SUB	(R5)+,R2	; BECAUSE USER PASSES RFUN/WFUN
.ASSUME	<.READ &377> EQ <6-RFUN>
.ASSUME	<.WRITE&377> EQ <6-WFUN>
	MOV	(R5)+,XRLOC(R3)	;GET LOW-ORDER BUFFER ADDRESS
	MOV	R5,TOS.R5(SP)	;SAVE PROPER R5 VALUE FOR RETURNING
	MOV	I.DSQ+DSQCNT,(R3) ;GET WORD COUNT
.ASSUME	XRLEN	EQ	0
	ASL	(R3)		;MAKE A BYTE COUNT
	MOV	(R3),XRBC(R3)	;USE FOR LENGTH AND ALSO BYTE COUNT
	MOV	R1,R0		;COPY UNIT
	CALL	MAGSET		;SET UP ...
	CMP	R5,#IDX$MU	;IS THIS A TMSCP DEVICE?		;014
	BNE	3$		;NOPE, SO NO MAPPED CALL		;014
	MOV	#4$,-(SP)	;YES, SO SAVE RETURN ADDRESS		;014
	MOV	@#KISAR5,-(SP)	;REMEMBER OUR PHASE			;014
	MOV	@MAGSER(R5),-(SP) ;STACK THE DRIVER'S ENTRY POINT	;014
	MOV	BBRAP5,-(SP)	;Stack the driver's phase MMU		;019
	JMPX	CALLMX		;AND CALLED MAPPED TO THE DRIVER...	;014

3$:	CALL	@MAGSER(R5)	;CALL THE ROUTINE			;014

;+
; WHEN THE MAGTAPE DRIVER IS CALLED:
;
;	R0 =  UNIT NUMBER * 2
;	R1 -> DDB
;	R2 =  2 (READ) OR 4 (.WRITE)
;	R3 -> XRB
;	R4 =  0 (ONLINE JOB NUMBER * 2)
;	R5 =  MAGTAPE INDEX (ONLINE: POINTS TO BUFFER THRU KISAR6)
;-

4$:	CALL	MAGRDY							;014
	BR	10$

MAGNDX:	.WORD	0		;INDEX OF MAGTAPE WE'RE DEALING WITH
MAGUNT:	.WORD	0		;UNIT NUMBER

GLOBAL	<I.DSQ,MAGDDB,BBRAP5>						;019


;+
; PMGSPC - SPECIAL FUNCTION SERVICE FOR MAGTAPE
;
;	R0 = MAGTAPE INDEX
;	R1 = MAGTAPE UNIT
;	R2 = PARAMETER
;
;	CALL	MAGSPC,R5,<FUN>
;
;	WHERE FUN IS:				AND R2 IS:
;		1 - REWIND AND OFFLINE		(UNUSED)
;		2 - WRITE EOF			(UNUSED)
;		3 - REWIND			(UNUSED)
;		4 - SKIP FORWARD		RECORDS TO SKIP
;		5 - BACKSPACE			RECORDS TO BACKSPACE
;		6 - SET DENSITY			DENSITY
;		7 - RETURN STATUS		(UNUSED)
;
;	BACK:	C  = 0 - NO ERROR
;		R3 = VALUE RETURNED AT XRB+2
;
;		C = 1 IF ERROR
;		IOERR = ERROR CODE
;-

PMGSPC::REGSAV
	MOV	R0,MAGNDX	;SAVE MAGTAPE INDEX
	MOV	R1,MAGUNT	;AND UNIT
	MOVB	R1,MAGDDB+DDUNT	;SAVE UNIT NUMBER IN DDB
	CALL	ZAPXRB		;CLEAR OUT XRB & POINT TO IT
	MOV	R2,XRBC(R3)	;SET PARAMETER (COUNT)
	MOV	(R5)+,R2	;PICK UP FUNCTION CODE
	DEC	R2		;TRANSLATE FROM 1-BASE TO 0-BASE
	MOV	R5,TOS.R5(SP)	;SAVE CORRECT RETURN ADDRESS
	MOV	R0,R5		;SAVE MAGTAPE INDEX
	MOV	R1,R0		;GET UNIT
	CALL	MAGSET		;GET READY ...
	CMP	R5,#IDX$MU	;IS THIS A TMSCP DEVICE?		;014
	BNE	5$		;NOPE, SO NO MAPPED CALL		;014
	MOV	#7$,-(SP)	;YES, SO SAVE RETURN ADDRESS		;014
	MOV	@#KISAR5,-(SP)	;REMEMBER OUR PHASE			;014
	MOV	@MAGSPD(R5),-(SP) ;STACK THE DRIVER'S ENTRY POINT	;014
	MOV	BBRAP5,-(SP)	;Stack the driver's phase MMU		;019
	JMPX	CALLMX		;AND CALLED MAPPED TO THE DRIVER...	;014

5$:	CALL	@MAGSPD(R5)	;CALL THE DRIVER			;014

;+
; WHEN THE MAGTAPE DRIVER IS CALLED:
;
;	R0 =  UNIT NUMBER * 2
;	R1 -> DDB
;	R2 =  SPECIAL FUNCTION CODE
;	R3 -> XRB
;	R4 =  0 [ONLINE: JOB NUMBER * 2]
;	R5 =  MAGTAPE INDEX
;-

7$:	CALL	MAGRDY		;WAIT FOR READY				;014
	MOV	MAGXRB+2,TOS.R3(SP) ;SET RETURNED VALUE
10$:	CALLX	REGRES,R5	;RESTORE REGS
	RETURN	R5		;ALL DONE

GLOBAL	<MAGXRB>							;014
.DSABL	LSB


; ZAPXRB -- CLEAR XRB.  RETURNS R3 = MAGXRB

ZAPXRB:	MOV	#MAGXRB+XRBSIZ,R3 ;POINT TO XRB
10$:	CLR	-(R3)		;CLEAR IT
	CMP	R3,#MAGXRB	;DONE?
	BHI	10$		;NOT YET
	RETURN

MAGSET:	ASL	R0		;GET UNIT*2
	MOV	#MAGDDB,R1	;POINT TO DDB
	MOV	MAGNDX,R5	;GET DRIVER INDEX
	CMP	R5,#IDX$MM	;IS THIS AN MM TYPE TAPE DRIVE?
	BNE	10$		;NOPE, DON'T SET FORMATTER NUMBER
	MOVB	MM$FOR(R0),MTDDSP+MTTM02(R1) ;SET FORMATTER NUMBER
10$:	CMP	R5,#IDX$MS	;IS THIS A TS04 TYPE TAPE DRIVE?
	BNE	15$		;Nope, see if it's TMSCP		;011
	MOV	MAGCSR+IDX$MS-14.(R0),CSR.XX  ;SET CSR FOR TS04
	CLRB	DDUNT(R1)	;FAKE UNIT NUMBER OF 0
	BR	30$		;FINISH SET UP

15$:	CMP	R5,#IDX$MU	;TMSCP device?				;011
	BNE	20$		;NOPE, GET CSR NORMALLY
	MOV	R1,-(SP)	;Save DDB pointer
	MOV	R0,-(SP)	;Save unit # * 2			;011
	ASL	R0		;Now make it * 4			;011
	MOV	UMT$MU(R0),MTDDSP+MTFQB+2(R1)	;Copy UMT into DDB	;014
	MOV	UMT$MU+2(R0),MTDDSP+MTFQB+4(R1)	; both words		;014
.ASSUME	UMTSIZ	EQ 4
	ADD	#UMT$MU,R0	;Point to UMT for this unit		;011
	MOV	(R0),R1		;Now get CMT offset			;011
	CLR	R0		;Clear for divide			;011
	DIV	#CMTSIZ/2,R0	; by CMTSIZ/2 to get controller # * 2	;011
	BEQ	17$		;CONTROLLER # * 2 IS CORRECT		;017
	MOVB	CMT+CM.DCT,-(SP) ;GET THE TOTAL # OF DISK CONTROLLERS	;017
	BIC	#^C<377>,(SP)	;GET RID OF EXTRANEOUS BITS		;017
	ASL	(SP)		;MAKE IT MAX DISK CTRLR # * 2		;017
	SUB	(SP)+,R0	;GET REAL TAPE CNTRLR #*2		;017
17$:	MOV	CSRTBL+MU.CSO(R0),CSR.XX ;Now get CSR (Finally!)	;011
	MOV	(SP)+,R0	;Restore R0				;011
	MOV	(SP)+,R1	; and R1				;011
	BR	30$		;Finish up				;011


20$:	MOV	MAGCSR(R5),CSR.XX ;SET CSR FOR MAGTAPE
30$:	CLR	R4		;INDICATE JOB 0
	CLR	IODNE		;INDICATE NOT YET DONE
	CALLR	GETTTY		;COLLECT TYPE-AHEAD & TICKS

GLOBAL	<MM$FOR,MAGCSR,MAGDDB,CSRTBL,MU.CSO,IODNE>


;+
;MAGRDY - SIMULATE MAGTAPE INTERRUPTS WHILE HANDLING LEVEL-3-QUEUE BITS
;-

.ENABL	LSB

10$:	CLR	TIM.XX		;NO LONGER GIVE TIMEOUTS TO DRIVERS
	;CLC
	MOVB	JDB+JDIOST,IOERR ;COPY ERROR CODE, IF ANY
	BEQ	20$		;NONE, RETURN WITH CARRY CLEAR
	SEC			;AN ERROR, SO SET CARRY
20$:	RETURN			;DONE

MAGRDY:	MOV	MAGNDX,R2	;GET MAGTAPE INDEX
	CMP	R2,#IDX$MU	;[T]MSCP tape?				;011
	BEQ	WAITMU		;Yep, special handling			;011
	MOV	CSR.XX,R3	;GET CSR ADDRESS
	MOV	#177400,TIM.XX	;SET A 1 SECOND DISK TIMEOUT
	CALLX	GETTTY		;KEEP CLOCK & TYPEAHEAD
	TST	TIM.XX		;TIMED OUT YET?
	BMI	PRTI3		;No, skip				;015
	TST	TIM.MX		;IS THERE A TAPE TIMEOUT SET?
	BMI	30$		;ALREADY TIMED-OUT, GIVE TIMEOUT
	BEQ	PRTI3		;Turned off, ignore			;015
	DEC	TIM.MX		;COUNT ONE SECOND
	BNE	PRTI3		;Not done, continue			;015
30$:	MOV	MAGUNT,R0	;GET UNIT
	ASL	R0		; *2
	CMP	R2,#IDX$MS	;IS IT A TS04?
	BNE	40$		;NO, THE UNIT NUMBER IS OK
	CLR	R0		;FAKE A UNIT NUMBER OF ZERO
40$:	MOV	#MAGDDB,R1	;POINT TO DDB
	CALL	@MAGTMO(R2)	;YES, CALL THE DRIVER
PRTI3::				;RTI3 processing emulation	;015
	MOV	MAGNDX,R2	;GET MAGTAPE INDEX
	MOV	CSR.XX,R3	;GET CSR ADDRESS
	MOV	#L3QUE,R0	;CHECK FOR PENDING BITS IN L3Q	;006
43$:	TST	(R0)+		;ANY BITS SET?			;006
	BNE	DOL3Q		;YES, DO IT			;006
	CMP	R0,#L3QEND	;NEXT L3Q WORD			;006
	BLO	43$						;006
	MOV	#WAIT2T,R0	;CHECK FOR PENDING DELAYED BITS ;006
45$:	TST	(R0)+		;ANY BITS SET?			;006
	BNE	MAGRDY		;YES, WAIT			;006
	CMP	R0,#WAIT2E	;NEXT DELAYED WORD		;006
	BLO	45$						;006
	MOV	#WAIT1T,R0	;CHECK FOR SLIGHTLY DELAYED BITS;006
47$:	TST	(R0)+		;ANY BITS SET?			;006
	BNE	MAGRDY		;YES, WAIT			;006
	CMP	R0,#WAIT1E	;NEXT DELAYED WORD		;006
	BLO	47$						;006
	TST	IODNE		;IS THE DRIVER FINISHED?
	BNE	10$		;YES, EXIT
	BIT	#1,(R3)		;GO BIT DROPPED?		;010
	BNE	MAGRDY		;NO DON'T CHECK READY YET
	TSTB	(R3)		;READY?
	BPL	MAGRDY		;NO, KEEP WAITING
	CLR	R0		;ALL DRIVERS THINK THEY HAVE ONE CONTROLLER
50$:	CALL	@MAGINT(R2)	;AND SIMULATE AN INTERRUPT
	BR	MAGRDY		;NOW SEE WHAT TO DO

GLOBAL	<IOERR,TIM.XX,L3QUE,L3QEND,WAIT1T,WAIT1E,WAIT2T,WAIT2E,MAGDDB,TIM.MX,JDB>


WAITMU:	MOV	DSS$DF,-(SP)	;SAVE THE DISK'S STATUS AND TIMER
	CALLX	GETTTY		;GRAB ANY TYPE-AHEAD
	TST	(SP)+		;ARE WE PROCESSING TIMEOUTS YET?
	BPL	55$		;NO,  NEED TO ENTER DRIVER TO SET TIMER
	TST	DSS$DF		;YES, TIMER EXPIRED?
	BPL	TIMOMU		;Yes, perform driver timeout service	;011
55$:	CALL	UQPORT		;Call the common MSCP simulation rtn	;009
	BR	WAITMU		;Continue waiting			;009
	BR	70$		;Returning from interrupt		;009
	.BR	60$		;Interrupt driver			;009

60$:	MOV	MAGNDX,R2	;GET OUR TAPE INDEX			;010
	MOV	#70$,-(SP)	;SET RETURN ADDRESS FOR A MAPPED CALL
	MOV	@#KISAR5,-(SP)	; REMEMBER OUR PHASE FOR THAT RETURN
	MOV	@MAGINT(R2),-(SP);   STACK THE DRIVER'S ENTRY POINT (INT$xx)
	MOV	BBRAP5,-(SP)	;      Stack the driver's phase MMU	;019
	MOV	MAGUNT,R0	;GET THE UNIT NUMBER			;010
	ASL	R0		;  *2
	ASL	R0		;    *4
	MOV	UMT$MU(R0),R1	;      TO GET THE CMT OFFSET IN R1	;010
	CLR	R0		;        CLEAR R0 FOR DIVIDE
	DIV	#CMTSIZ/2,R0	;          NOW COMPUTE CONTROLLER NO. *2 IN R0
	BEQ	65$		;CONTROLLER # * 2 IS CORRECT		;017
	MOVB	CMT+CM.DCT,-(SP) ;GET THE TOTAL # OF DISK CONTROLLERS	;017
	BIC	#^C<377>,(SP)	;GET RID OF EXTRANEOUS BITS		;017
	ASL	(SP)		;MAKE IT MAX DISK CTRLR # * 2		;017
	SUB	(SP)+,R0	;GET REAL TAPE CNTRLR #*2		;017
65$:	JMPX	CALLMX		;CALL MAPPED INTO DRIVER TO CHECK IT OUT
				;....CALLMX returns here...
70$:	MOV	CMT+CM.IC6,R2	;Is controller online?
	BMI	WAITMU		;  No. Keep INTerupting driver until it is.
	TST	IODNE		;Is our request done?			;011
	BNE	10$		;Yes, so let's exit			;011
	BR	WAITMU		;No, keep waiting...			;011

TIMOMU:	MOV	MAGNDX,R2	;GET OUR TAPE INDEX			;011
	MOV	#70$,-(SP)	;SET RETURN ADDRESS FOR A MAPPED CALL
	MOV	@#KISAR5,-(SP)	; REMEMBER OUR PHASE FOR THAT RETURN
	MOV	@MAGTMO(R2),-(SP);  STACK THE DRIVER'S ENTRY POINT (TMO$xx)
	MOV	BBRAP5,-(SP)	;      Stack the driver's phase MMU	;019
	MOV	#DQS$DF,R0	;POINT TO QUEUE ROOT
	CLR	R2		;SET R2=0, Z=1, C=0
	JMPX	CALLMX		;CALL MAPPED INTO DRIVER TO CHECK IT OUT
				;(CALLMX RTNS 70$)

	GLOBAL	<DSKAP6,L3QUE,L3QEND>					;017

.DSABL	LSB


;+
; DOL3Q -  PROCESS REQUESTED L3Q TASK
;-

DOL3Q:	MOV	#L3QUE,R0	;L3Q control word pointer		;006
	CLR	R2		;No initial offset			;006
5$:	MOV	(R0)+,R1	;Anything on here?			;006
	BNE	10$		;Yes, go do it				;006
	ADD	#20,R2		;Initial offset for next word		;006
	BR	5$		;Check next word			;006

10$:	NEG	R1		;ALTER LOWEST 1 BIT
	BIC	R1,-(R0)	;CLEAR BIT IN THE CONTROL WORD
	TSTB	R1		;ANY BIT ON IN THE LOW BYTE
	BNE	20$		;YES
	SWAB	R1		;NO SWAB TO HIGH BYTE
	ADD	#10,R2		; AND BUMP INDEX TO 8 BITS WORTH
20$:	INC	R2		;INCREMENT THE OFFSET VALUE
	ROR	R1		; AND CHECK FOR A 1 BIT
	BCC	20$		;NOT HERE, LOOP.
	ASL	R2		;NOW MAKE OFFSET INTO WORD VALUE
	CMP	@L3QPAR-2(R2),@#KISAR5 ;DO WE NEED TO DO A MAPPED JMP
	BNE	30$		;YES, LEVEL3 PROCESSING IS IN ANOTHER PHASE
	CCC			;ENSURE CC'S ALL 0 ON L3Q DISPATCH
	JMP	@L3QTBL-2(R2)	; AND GO OF TO IT...

30$:				    ; (SP) SHOULD ALREADY CONTAIN RETURN ADDR
	MOV	@#KISAR5,-(SP)	    ;REMEMBER OUR PHASE FOR RETURN
	MOV	@L3QTBL-2(R2),-(SP) ;  PICK-UP THE L3 VIRTUAL ADDR ENTRY
;	MOV	L3QTBL-2(R2),R0     ;  PICK-UP THE POINTER TO THE JSR $OVRH
;	MOV	6(R0),-(SP)	    ;  AND STACK THE REAL VIRTUAL ADDRESS
	MOV	@L3QPAR-2(R2),-(SP) ;    NOW STACK THE L3PROC'S PHASE MMU
	CCC			    ;ENSURE CC'S ALL 0 ON L3Q DISPATCH
	JMPX	CALLMX		    ;CALL MAPPED INTO L3 PROCESSOR


.SBTTL	GLOBALS FOR THE DRIVERS

OPTDSK::MOV	(R0),R4
	TST	(R5)+
	RETURN	R5

; A Do-nothing routine							;015

CLRRSQ::CLC								;014
	RETURN
GLOBAL	<HIGHBF>


.SBTTL	TAPE ERROR LOG CODES, L3Q BITS, AND L3 PROCESS ENTRY POINTS
; DEFINE ERROR LOGGING CODE FOR TAPES

.DSECT	+EMT+LOG$SZ
	$TAPES
LOG$'NAME::	.BLKW
.ENDM

.SBTTL	L3Q BITS AND ENTRY POINTS

; DEFINE L3Q BITS AND ENTRY POINTS FOR TAPES AND UDA

.MACRO	DEVICE NN,L3QBIT
	.IRP	ITEM,<L3QBIT>
.IF	IDN	<NN>,<PH>				;006
	L3QENT	Q'NN''ITEM,J'ITEM''NN,MCPAP5 
.GLOBL	J'ITEM''NN
.ENDC							;014
.IF	IDN	<NN>,<MU>				;006
	L3QENT	Q'NN''ITEM,J'ITEM''NN,BBRAP5		;019
.GLOBL	J'ITEM''NN					;014
.IFF							;014
	.IF	DIF	<NN>,<PH>			;014
		L3QENT	Q'NN''ITEM,ITEM'$'NN,DSKAP5	;014
	.GLOBL	ITEM'$'NN				;014
	.ENDC						;014
.ENDC
.ENDM
.ENDM	DEVICE

GLOBAL	<DSKAP5,MCPAP5,BBRAP5>				;019

DEVICE	PH,<CON>					;006
DEVICE	MT,<CON,DNE>
DEVICE	MM,<CON,DNE>
DEVICE	MS,<DNE,CON>
DEVICE	MU,<DNE>					;014

UNORG


;+
; PTRSET - RESET MAGTAPE
;
; CALL:	R0 = DEVICE INDEX
;	R1 = UNIT NUMBER (*1)
;	DISK PHASE MAPPED THROUGH APRS 5 AND 6
;
;	CALL PTRSET
;
; NOTE:	FOR TMSCP DEVICES WE HAVE TO HAVE UMT ENTRIES SET UP IN THE DDB
;	WHEN ENTERING THE ASN$MU ENTRY POINT.
;-
PTRSET::MOV	R0,MAGNDX	;SAVE MAGTAPE TYPE INDEX
	MOV	R1,MAGUNT	;SAVE MAGTAPE UNIT NUMBER
	MOVB	R1,MAGDDB+DDUNT	;SAVE UNIT NUMBER IN DDB
	MOV	#MAGDDB,R1	;POINT TO DDB
	CMP	#IDX$MU,R0	;IS THIS A TMSCP DEVICE?		;014
	BNE	5$		;NOPE, NO MAPPED CALL			;014
	PUSH	<R0>		;SAVE INDEX				;017
	MOV	MAGUNT,R0	;GET UNIT #				;017
	ASL	R0		;*2					;017
	ASL	R0		;NOW MAKE IT * 4			;017
	MOV	UMT$MU(R0),MTDDSP+MTFQB+2(R1)	;COPY CMT OFFSET	;017
	MOV	UMT$MU+2(R0),MTDDSP+MTFQB+4(R1)	;AND UCB POINTER	;017
.ASSUME	UMTSIZ	EQ 4
	POP	<R0>		;RESTORE INDEX				;017
	MOV	#6$,-(SP)	;SAVE RETURN ADDRESS			;014
	MOV	@#KISAR5,-(SP)	;REMEMBER OUR PHASE			;014
	MOV	@MAGASD(R0),-(SP) ;STACK THE DRIVER'S ENTRY POINT	;014
	MOV	BBRAP5,-(SP)	;Stack the driver's phase MMU		;019
	JMPX	CALLMX		;AND CALLED MAPPED TO THE DRIVER...	;014

5$:	CALL	@MAGASD(R0)	;ASSIGN IT -- WAKE UP DRIVER

6$:	BICB	#^C<MT.DEN!MT.PAR>,DDFLAG(R1) ;CLEAN UP SOMEWHAT	;014
	MOVB	DDFLAG(R1),MTDDSP+MTOFLG(R1) ;USE THESE AS 'OPEN' FLAGS
	BISB	DDUNT(R1),MTDDSP+MTOFLG(R1) ;TOGHETHER WITH UNIT NUMBER
	BISB	#MT.OPN,MTDDSP+MTOFLG(R1) ;INDICATE IT'S OPEN
	MOV	MAGNDX,R1	;SET REGS FOR RESETTERS
	MOV	MAGUNT,R4	;UNIT NUMBER IN R4
	JMP	@10$(R1)	;AN EASY DISPATCH TO THE RIGHT RESETTER

	$TAPES
	.WORD	NAME'RSET	;NAME RESETTER
.ENDM
10$:

GLOBAL	<MAGDDB>
.END
