TITLE	SET,<RSTS/E INIT--SET OPTION>,0A,10-MAY-91,ABC/GPK/JHC/TPT/DBM/PRL

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR INISET

;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;
;				[RSTS V7.2]
;  000	MND  22-Mar-82	CREATION - COPIED FROM V7.1-11
;  001	MND  22-Mar-82	Added support for MSCP disks - UDA50/RA80
;
;				[RSTS V8.0]
;  000	GPK  21-Jun-82	Device packet layout changes
;  001  JHC  23-Sep-82  Added LP RESET characteristic, added 8BIT
;			characteristic, removed VTAB capability to make
;			room for 8BIT as VTAB was a characteristic only
;			required for LS11, an unsupported printer. Also
;			removed macros for unsupported printers, and 
;			references to them.
;			
;				[RSTS V9.0]
;  001	TPT  11-Nov-83	Merged V8.0-07 changes
;  002	DBM  06-Jan-84	Change <CR> to <LF> for VT200 support
;  003	PRL  05-Mar-84	Remove references to LPTPUC in LP's DDB
;-

.SBTTL	SET MACROS AND PARAMETERS

.MACRO	I.MESS
	TMPORG	SETTXT
.NLIST	BEX
.ENDM	I.MESS

.MACRO	OPTION	N1,N2
.SBTTL	N1'N2 SUBOPTION
	TMPORG	SETOPT
	 .WORD	SET'N1'N2
	TMPORG	SETOTX
	 UNQTXT	<N1\N2>
	UNORG
.LIST
SET'N1'N2:
.NLIST
.ENDM	OPTION

.SBTTL	ORDER THE CSECTS IN MEMORY

	DEFORG	SET
	DEFORG	SETCTL
	DEFORG	SETOPT
	DEFORG	SETOTX
	DEFORG	SETTXT
	ORG	SET

.EQUATE	PKKBNO,	10		;OFFSET IN PK DDB OF KB# * 2

.SBTTL	SET OPTION INITIALIZATION

.ENABL	LSB

INISET::CALLX	CKOPT		;IS THIS A LEGAL OPTION?
	MOV	R1,-(SP)	;SAVE R1 FOR NOW
	TST	SILNAM		;IS THERE AN INSTALLED SIL?
	BNE	20$		;YES
	MESSAGE	<"Please install a monitor SIL."<200>>
10$:	EXIT

20$:	CALLX	LKSIL		;ENSURE THAT THE SIL IS OPEN
	BCS	10$		;NO SUCH LUCK
	MOV	#3000,R0	;SET OFFSET FOR READ AT SATBUF + 3000
	CALLX	DSTBLI		;READ THE DS TABLE INTO DSTBL AREA OF SATBUF
	CLR	BLNRST		;FORCE A READ IN RDRSTS
	CLR	RWRITE		;CLEAR THE REWRITE FLAG
	MOV	#-1,PKLAST	;ASSUME THERE ARE NO PK'S IN THE SYSTEM
	MOV	DEVOKB,R3	;GET THE KB OFFSET TO START THE SEARCH
30$:	ADD	#2,R3		;NEXT DEVICE INDEX
	CALL	RDRSO3,R4,DEVNAM ;GET A DEVICE NAME
	CMP	(R0),#-1	;END OF TABLE?
	BEQ	SETLUP		;YES, NO PK'S
	CMP	(R0),#"PK	;NO, IS THIS THE PK NAME?
	BNE	30$		;NO, TRY MORE
	CALL	RDRSO3,R4,DEVCNT ;GET THE NUMBER OF PK'S GENERATED
	MOV	(R0),PKLAST	;REMEMBER IT
	BMI	SETLUP		;NEGATIVE, SO NONE
	CALL	RDRSO3,R4,DEVPTR ;GET ADDRESS OF DDB LIST
	MOV	(R0),R0		;READ FIRST WORD
	CALL	RDRSTS		; TO GET ADDRESS OF PK0: DDB
	MOV	(R0),R0		;IN THAT DDB,
	ADD	#PKKBNO,R0	; AT THE CORRECT OFFSET
	CALL	RDRSTS		;  LOOK AT A WORD
	MOVB	(R0),R0		;GET THE KB*2 OF THE KB FOR PK0:
	ASR	R0		;KB*1
	BIC	#^C<177>,R0	;NO SIGN BITS
	MOV	R0,PKFRST	;SAVE THE LOW KB# FOR PSEUDO KB'S
	ADD	R0,PKLAST	;COMPUTE THE HIGH KB #

.DSABL	LSB

	TMPORG	SETCTL
PKFRST:	.WORD	0		;KB# OF FIRST PSEUDO
PKLAST:	.WORD	-1		;KB# OF LAST PSEUDO, -1 IF NONE
	UNORG

GLOBAL	<SILNAM,DEVOKB,DEVNAM,DEVCNT,DEVPTR>

.SBTTL	SET OPTION MAIN LOOP

.ENABL	LSB

SETLUP:	MOV	(SP)+,R1	;RESTORE INCOMING TEXT POINTER
	MOVB	(R1),PRESET	;ANY ANSWER PASSED?
	BNE	30$		;YES, TRY TO USE IT
10$:	CALLX	ASKER,R5	;ASK FOR SUBOPTION
	 .WORD	20$		;SHORT FORM
	 GENTXT
	  .ASCII <12>
	  .ASCII "  Valid SET suboptions are:"<200>
	  .ASCII "	LIST	List the status of a device"<200>
	  .ASCII "	MODEM	Enable modem control for keyboards"<200>
	  .ASCII "	LOCAL	Disable modem control for keyboards"<200>
	  .ASCII "	LP	Set line printer characteristics"<200>
	  .ASCII "	DISABLE	Disable a device unit"<200>
	  .ASCII "	ENABLE	Enable a device unit"<200>
	  .ASCII "	PRIV	Make device ownership privileged"<200>
	  .ASCII "	UNPRIV	Make device ownership non-privileged"<200>
	  .ASCII "	EXIT	(or <CR>) exit from SET option"<200>
	  .ASCII <12>
	  .ASCII "  Only the first two characters need be typed"<200>
20$:	  .ASCIZ <177><12>"  SET suboption? "
	 UNORG
	BEQ	SETEXI		;DONE IF <LF> OR CTRL/Z
30$:	CALLX	GETUNQ,R5,SETOTX ;SCAN THE ANSWER
	CLR	R2		;R2 = 0 UPON ENTRY
	CALL	@SETOPT(R0)	;CALL THE SUBOPTION
	TSTB	PRESET		;JUST ONE THING TO DO?
	BEQ	10$		;NO, MANY THINGS

OPTION	EX,IT
	EXIT			;YES, EXIT NOW

.DSABL	LSB

	TMPORG	SETCTL
PRESET:	.WORD	0		;<>0 IF ENTERED WITH ARGUMENT
	UNORG

OPTION	LI,ST

.ENABL	LSB

	MOVB	(R1),PREST1	;DEVICE NAME IN LINE?
	BNE	30$		;YES, USE IT
10$:	CALLX	ASKER,R5	;ASK FOR DEVICE TO LIST
	 .WORD	20$		;SHORT TEXT
	 GENTXT
	  .ASCII "  Type the name of the device to be listed."<200>
	  .ASCII "  To list selected units, type a unit number or range."<200>
	  .ASCII "  Type <CR> to list all devices."<200>
20$:	  .ASCIZ <177>"  Device? "
	 UNORG
30$:	CLR	LISTAL		;ASSUME NOT LISTING EVERYTHING
	CLR	HDRDON		;HEADER NOT PRINTED
	CMP	(R1),#'Z-100	;CONTROL Z?
	BEQ	50$		;YES, JUST LEAVE
	CLR	R3		;ASSUME DEVICE INDEX = 0
	CMP	(R1),#12	;LINE FEED?
	BEQ	100$		;YES, ENTER THE LOOP
	CALL	ALLCHK		;CHECK FOR 'ALL'
	BEQ	100$		;YES, ENTER THE 'ALL' LOOP
	CALL	GETDVC		;PARSE THE DEVICE NAME AND FIND IT
	BCS	40$		;ERROR, ASK AGAIN
	TSTB	(R1)		;ANY UNIT INFORMATION?
	BEQ	70$		;NO, USE ALL UNITS (MAXUNT SET UP)
	CALL	CVTUNT		;YES, CONVERT THE UNIT
	BCC	60$		;NO ERROR, GO LIST THEM
40$:	TSTB	PREST1		;ANSWER CAME FROM CALLER?
	BEQ	10$		;NO, ASK HIM AGAIN
50$:	RETURN			;RETURN TO CALLER FOR ANOTHER SUBOPTION

60$:	CMP	R5,MAXUNT	;IS THERE ONLY ONE UNIT TO LIST?
	BNE	70$		;NO, MORE, LEAVE FLAG TO PRINT HEADER
	COM	HDRDON		;YES, DON'T PRINT A HEADER
70$:	CALL	RDRSO3,R4,DEVPTR ;GET THE DEVPTR VALUE FOR THIS DEVICE
	MOV	(R0),XXXPTR	;SAVE IT
80$:	CALL	LISTDV		;LIST A SINGLE DEVICE (R3) UNIT (R5)
	TST	CTLOFG		;TYPED HE ^O ?
	BNE	50$		;YES, QUIT FASTLY
	INC	R5		;NEXT UNIT
	CMP	R5,MAXUNT	;UP TO THE MAXIMUM?
	BLOS	80$		;NO, DO ANOTHER
	TST	LISTAL		;LISTING EVERYTHING?
	BEQ	50$		;NOPE, RETURN
90$:	ADD	#2,R3		;NEXT DEVPTR OFFSET
	MOV	R3,R0		;CHECK FOR DONE
	ADD	DEVNAM,R0	; BY SEEING IF WE ARE
	CMP	R0,DEVSYN	;  UP TO THE SYNONYM NAMES
	BHIS	50$		;YES, GET OUT
100$:	MOV	(PC),LISTAL	;SET FLAG TO LIST EVERYTHING
	CLR	R5		;START WITH UNIT 0 OF THIS DEVICE
	CALL	RDRSO3,R4,DEVCNT ;GET THE NUMBER OF UNITS
	MOV	(R0),MAXUNT	;SET IT UP FOR A TERMINATOR
	BMI	90$		;NONE, SKIP IT
	CALL	RDRSO3,R4,DEVNAM ;GET THE NAME OF THIS ONE
	MOV	(R0),R4		; INTO R4
	BR	70$		;GO GET DEVPTR AND PRINT THEM ALL

.DSABL	LSB

	TMPORG	SETCTL
LISTAL:	.WORD	0		;<>0 IF LISTING EVERYTHING
PREST1:	.WORD	0		;<>0 IF DEVICE NAME PASSED IN
PREST2:	.WORD	0		;<>0 IF UNIT NUMBER PASSED
HDRDON:	.WORD	0		;< 0 IF HEADER HAS BEEN PRINTED
	UNORG

GLOBAL	<DEVPTR,CTLOFG,DEVNAM,DEVSYN,DEVCNT>

.SBTTL	LIST A SINGLE DEVICE UNIT

.ENABL	LSB

LISTDV:	MOV	#HDRDON,R2	;POINT TO A FLAG
	TST	(R2)		;HAS THE HEADER BEEN PRINTED?
	BNE	10$		;YES
	COM	(R2)		;NO, SAY IT HAS
	MESSAGE	<<177><12>"  Name  Control Comments"<200><12>>
10$:	MESSAGE	<"  ">
	CLRB	(R2)		;NOT TABBED TO COMMENTS
	MOV	R4,R2		;COPY THE DEVICE NAME
	CALLX	TYPE2		;TYPE IT
	MOV	R5,R0		;COPY THE UNIT NUMBER
	CALLX	DECZER		;PRINT IT
	CALLX	TYPTAB		;NEXT COLUMN
	CALL	PKBCHK		;IS THIS A PHONY KB?
	BCS	20$		;NO
	MESSAGE	<"PK">		;YES, PRINT OWNER
	MOV	R5,R0		;COMPUTE KB# - FIRST PSEUDO
	SUB	PKFRST,R0
	CALLX	DECZER
	CALLX	MESSAGE,R5,MESCLN ;COLON
20$:	CALL	GETDS		;GET THE DS BLOCK FOR THE DEVICE UNIT
	BCS	40$		;NONE, NOT A CONTROLLER TYPE (PK, NL)
	MOV	R2,-(SP)	;SAVE R2 A MOMENT
	MOV	PK.NAM(R1),R2	;GET THE CONTROLLER NAME
	CALLX	TYPE2		;TYPE IT
	MOV	(SP)+,R2	;RESTORE R2
	CMPB	(R1),#1		;MORE THAN ONE CONTROLLER POSSIBLE?
.ASSUME	PK.MXU EQ 0
	BLOS	30$		;NO, NO UNIT
	MOVB	DS.CTL(R2),R0	;YES, GET THE CONTROLLER INDEX
	CALLX	DECZER		;PRINT IT
30$:	MESSAGE	<":">,MESCLN	;COLON
	CMPB	PK.NUN(R1),#1	;MORE THAN ONE SUBLINE?
	BLOS	40$		;NO, IT MUST BE THE ONE CONTROLLED UNIT
	CMPB	(R1),#1		;YES, BUT MORE THAN ONE CONTROLLER?
.ASSUME	PK.MXU EQ 0
	BLOS	40$		;NO, DEVICE INDEX = CONTROLLER SUBLINE
	MOVB	DS.UNT(R2),R0	;GET FIRST CONTROLLED UNIT NUMBER
	NEG	R0		;COMPUTE UNIT - (FIRST UNIT)
	ADD	R5,R0		; TO GET SUBLINE
	CALLX	DECZER		;PRINT IT

40$:	MOV	XXXPTR,R0	;GET VALUE OF DEVPTR WORD
	ADD	R5,R0		;INDEXED BY UNIT * 2
	ADD	R5,R0
	CALL	RDRSTS		;GET THE DEVTBL (OR UNTCNT) VALUE
	CMP	R3,DEVOKB	;IS IT A DISK?
	BHIS	60$		;NO, GO DO NON-DISK
	CMP	(R0),#UC.MNT!UC.LCK ;YES, IS IT DISABLED?
	BNE	50$		;NOPE, JUST NORMAL
	CALL	100$,R5
	 GENTXT	<"Disabled ">,MESDIS
50$:	CALLRX	TYPECR		;END OF LINE

60$:	MOV	(R0),R1		;R1 = DDB ADDRESS
	MOV	R1,XXXDDB	;SAVE DDB ADDRESS
	MOV	R1,R0		;GET FIRST WORD OF DDB
	CALL	RDRSTS		; INCLUDING THE DDPRVO FLAG
	MOV	(R0),-(SP)	;SAVE IT
	CALL	PKBCHK		;IS IT PSEUDO KB?
	BCC	70$		;YUP, DON'T SAY DISABLED
	MOV	R1,R0		;GET THE SECOND WORD OF THE DDB
	TST	(R0)+
	CALL	RDRSTS
	BIT	#1,(R0)		;DISABLED?
	BEQ	70$		;NOT DISABLED
	CALL	100$,R5,MESDIS	;TAB OVER AND TYPE
70$:	BIT	#DDPRVO,(SP)+	;IS OWNERSHIP PRIVILEGED?
	BEQ	80$		;NO
	CALL	100$,R5		;TAB OVER AND TYPE
	 GENTXT	<"Privileged ">
80$:	CMP	R3,DEVOKB	;IS THIS A KEYBOARD?
	BNE	90$		;NO
	MOV	R1,R0		;YES, GET THE TTINTF WORD
	ADD	#TTINTF,R0
	CALL	RDRSTS
	BIT	#TTMODM,(R0)	;IS MODEM CONTROL ON?
	BEQ	50$		;NO
	CALL	100$,R5		;YES, SAY SO
	 GENTXT	<"Modem">
	BR	50$		;DONE

GLOBAL	<DEVOKB>

90$:	CMP	R4,#"LP		;LINE PRINTER?
	BNE	50$		;NO, DONE
	CALL	100$,R5		;TAB OVER IF NECESSARY
	 GENTXT	<"">
	CALL	LPTYPP		;PRINT LP TYPE
	MESSAGE	<", width ">	;WIDTH MESSAGE
	CLR	R0		;R0 CLEAR FOR BISB
	BISB	XXHORC,R0	;GET HORIZONTAL COUNT
	DEC	R0		;UNBIASED
	CALLX	DECZER		;PRINT WIDTH
	BIT	#LPTALC,LP.CHR	;IS IT LOWER CASE?
	BEQ	50$		;NO
	MESSAGE	<", lower case">
	BR	50$		;END OF LINE

100$:	TSTB	HDRDON		;TABBED OVER YET?
	BNE	110$		;YES
	CALLX	TYPTAB		;NO, DO IT
	COMB	HDRDON
110$:	JMPX	MESSAGE		;SEND MESSAGE, RETURN TO CALLER

.DSABL	LSB

	TMPORG	SETCTL
XXXPTR:	.WORD	0		;VALUE OF DEVPTR WORD FOR DEVICE TYPE
XXXDDB:	.WORD	0		;DDB ADDRESS OF DEVICE
	UNORG

.SBTTL	LP TYPE PRINTER

.ENABL	LSB

LPTYPP:	REGSCR			;SAVE THESE
	CALL	LPCGET		;GET LP CHARACTERISTICS
	CLR	R3		;CLEAR R3 FOR BISB OF LPTCHR
	BISB	(R0),R3		;GET CHARACTERISTICS BYTE AS A WORD
	MOV	#LMACRO,R1	;POINT TO THE MACRO NAMES
	CLR	R2		;CLEAR FLAG IN CASE INDIVIDUAL CHARACTERISTICS
10$:	MOV	(R1)+,R0	;GET THE MACRO NAME
	BEQ	30$		;IF NONE, PRINT INDIVIDUALS
	CMP	R3,(R1)+	;IS THIS THE SAME TYPE?
	BNE	10$		;NO, LOOK MORE
	CALLX	ASCIZ0		;TYPE THE NAME
20$:	RETURN

30$:	MOV	(R1)+,R0	;GET CHARACTERISTIC NAME
	BEQ	20$		;NO MORE, DONE
	MOV	R3,R5		;COPY CHARACTERISTICS
	BIC	(R1)+,R5	;ISOLATE USEFUL BITS
	CMP	R5,(R1)+	;DO THEY MATCH THE REQUIRED VALUE?
	BNE	30$		;NO, THIS ISN'T TRUTH
	TST	R2		;COMMA TO SEPARATE?
	BEQ	40$		;NO
	CALLX	TYPE		;YES, PRINT IT
40$:	MOV	#',,R2		;USE COMMA NEXT TIME
	CALLX	ASCIZ0		;YES, PRINT THE NAME
	BR	30$		;TRY ANOTHER CHARACTERISTIC

.DSABL	LSB

.SBTTL	LINE PRINTER TYPE TABLE

.EQUATE	LP.FLG,	LPTSCR!LPTCRF!LPTALC
; ADD LN01 HERE???
.EQUATE	LA.FLG,	LPTSCR!LPTCRF!LPTRBS!LPTALC

LMACRO:	GENTXT	<"LP">
	 .WORD	LP.FLG
	GENTXT	<"LA180">
	 .WORD	LA.FLG
	.WORD	0

; FOLLOWED IMMEDIATELY BY MICRO-ENCODED TABLE

.MACRO	$	NAME,BITS,VALUE,NEG
	GENTXT	<"NAME">
	 .WORD	^C<BITS>
.IF IDN	<VALUE>,<ON>
	 .WORD	BITS
.IF NB	<NEG>
$	NO'NAME,BITS,OFF
.ENDC
.IFF
.IF IDN	<VALUE>,<OFF>
	 .WORD	0
.IF NB	<NEG>
$	NO'NAME,BITS,ON
.ENDC
.IFF
	 .WORD	VALUE
.ENDC
.ENDC
.ENDM	$

;+
; THIS TABLE MUST IMMEDIATELY FOLLOW THE MACRO-ENCODED TABLE
;
;	NAME is the name of the characteristic.
;	BITS is the bit(s) in the LPTCHR which are effected
;	     by this characteristic.
;	ON/OFF indicates the bit state for the characteristic to be
;	     invoked.  ON means that characteristic is on when the bit
;	     is set.  OFF means that characteristic is on when the bit
;	     is reset.  LPTCHR byte is zero by default, ON/OFF here is
;	     used to determine default characteristic.   
;	'NO' -- If this is non-blank, then a NO'name' condition
;	     is set up with the opposite bit setting.
;
;	EXAMPLE: NOOMITCR is default of the OMITCR characteristic 
;		since OMITCR is ON, and CR is the default as OFF 
;		means that the characteristic is set when the bit is zero.
;		BSEMULATE has a blank NO column because there is not a
;		NOBSEMULATE characteristic.
;-

;	NAME		BITS		ON/OFF	'NO'?

$	OMITCR		LPTSCR		ON	Y
$	CR		LPTCRF		OFF	Y
$	EOT		LPTEOT		ON	Y
$	FILL		LPTSFF		OFF	Y
$	CONTROL		LPTNPC		ON	Y
$	8BIT		LPT8BT		ON	Y
$	BSEMULATE	LPTRBS!LPTNBS	0
$	BSREAL		LPTRBS!LPTNBS	LPTRBS
$	BSCONTROL	LPTRBS!LPTNBS	LPTNBS

	.WORD	0

.SBTTL	READ/REWRITE LP CHARACTERISTICS

.ENABL	LSB

LPCGET:	MOV	XXXDDB,R0	;POINT TO THE DDB
	ADD	#DDHORC-1,R0	;POINT TO WORD WITH DDHORC
.IIF	EQ	DDHORC&1,	.ERROR	;THE ABOVE WON'T WORK
	CALL	RDRSTS		;GET THE WORD
	MOV	(R0),XXHORZ	;SAVE IT
	MOV	XXXDDB,R0	;GET DDB ADDRESS AGAIN
	ADD	#LPTCHR,R0	;POINT TO THE CHARACTERISTICS
.IIF	NE	LPTCHR&1,	.ERROR	;THE ABOVE WON'T WORK
	CALL	RDRSTS
	MOV	(R0),LP.CHR	;SAVE CHARACTERISTICS
	RETURN			;WITH R0 -> CHARACTERISTICS

LPCPUT:	MOV	XXXDDB,R0	;GET DDB ADDRESS
	ADD	#DDHORC-1,R0	;GET HORIZONTAL SIZE ADDRESS
	CALL	RDRSTS
	MOV	XXHORZ,(R0)	;CHANGE DDHORZ/DDHORC
	INC	RWRITE		;FORCE IT OUT
	MOV	XXXDDB,R0	;DDB ADDRESS FOR CHARACTERISTICS
	ADD	#LPTCHR,R0
	CALL	RDRSTS
	MOV	LP.CHR,(R0)	;CHANGE TO NEW ONES
	INC	RWRITE
	CALLR	WRITRC		;FORCE EVERYTHING OUT

	TMPORG	SETCTL
XXHORZ:	.BYTE	0		;HORIZONTAL POSITION
XXHORC:	.BYTE	0		;WIDTH+1
LP.CHR:	.WORD	0		;CHARACTERISTICS WORD			;003
	UNORG

.SBTTL	UNPRIV/ENABLE ALL DEVICES

.ENABL	LSB

UNPALL:	MOV	DEVOKB,R3	;0 UNPRIV, DO ONLY NON-DISKS
ENAALL:	CALL	RDRSO3,R4,DEVCNT ;GET COUNT FOR THIS DEVICE
	MOV	(R0),R1		; IN R1
	BMI	60$		;NONE, SKIP IT
	CALL	RDRSO3,R4,DEVPTR ;GET DEVPTR VALUE
	MOV	(R0),R4		; IN R4
	CLR	R5		;START WITH UNIT 5
10$:	CALL	PKBCHK		;DON'T ALTER PKB'S
	BCC	50$		; IF IT IS PSEUDO, SKIP TO NEXT UNIT
	MOV	R5,R0		;COPY UNIT NUMBER
	ASL	R0		; * 2
	ADD	R4,R0		;POINT TO DEVTBL ENTRY
	CALL	RDRSTS		;GET IT
	CMP	R3,DEVOKB	;IS THIS A DISK?
	BHIS	20$		;NO
	CMP	#UC.MNT,(R0)	;YES, ALREADY ENABLED?
	BEQ	50$		;YES, DON'T FORCE A REWRITE
	MOV	#UC.MNT,(R0)	;YES, ENABLE IT BY FIXING UNTCNT
	BR	40$		;GO FORCE REWRITE

GLOBAL	<DEVOKB,DEVCNT,DEVPTR>

20$:	MOV	(R0),R0		;GET DDB ADDRESS
	ADD	R2,PC		;DISPATCH ON UNPRIV, ENABLE
	 BR	30$		;0 UNPRIV
	TST	(R0)+		;2 ENABLE, USE WORD 2 OF DDB
	CALL	RDRSTS
	TSTB	(R0)		;ALREADY ENABLED?
	BEQ	50$		;YES, DON'T FORCE A REWRITE
	CLRB	(R0)		;ENABLE BY CLEARING OWNER
	BR	40$

30$:	CALL	RDRSTS		;GET FIRST DDB WORD
	BIT	#DDPRVO,(R0)	;ALREADY UNPRIV?
	BEQ	50$		;YES, DON'T FORCE A REWRITE
	BIC	#DDPRVO,(R0)	;UNPRIV BY CLEARING BIT
40$:	INC	RWRITE		;FORCE A REWRITE
50$:	INC	R5		;NEXT UNIT
	CMP	R5,R1		;UP TO MAXIMUM?
	BLOS	10$		;NO, DO ANOTHER
60$:	TST	(R3)+		;BUMP THE DEVNAM OFFSET
	MOV	R3,R0		;COMPUTE DEVNAM ADDRESS
	ADD	DEVNAM,R0
	CMP	R0,DEVSYN	;UP TO THE SYNONYMS?
	BLO	ENAALL		;NO, DO MORE DEVICES
	RETURN			;MAY AS WELL LEAVE, SINCE ALL DONE

.DSABL	LSB

GLOBAL	<DEVNAM,DEVSYN>

.ENABL	LSB

OPTION	DI,SABLE
	TST	(R2)+		;R2=6 FOR DISABLE
OPTION	EN,ABLE
	TST	(R2)+		;R2=4 FOR ENABLE
OPTION	UN,PRIVILEGE
	TST	(R2)+		;R2=2 FOR UNPRIV
OPTION	PR,IVILEGE
				;R2=0 FOR PRIV
	MOVB	(R1),PREST1	;IS THE DEVICE GIVEN?
	BNE	30$		;YES, USE IT
10$:	CALLX	ASKER,R5	;ASK FOR DEVICE
	 .WORD	20$		;SHORT TEXT
	 GENTXT
	  .ASCII "  Type a device name or range of device names to alter."<200>
20$:	  .ASCIZ <177>"  Device? "
	 UNORG
	BEQ	70$		;RETURN IF <LF> OR CTRL/Z
30$:	CALL	ALLCHK		;IS IT 'ALL'
	BNE	40$		;NO
	CLR	R3		;START WITH R3=0 FOR ALL DEVICES
	SUB	#2,R2		;IS IT UNPRIV?
	BEQ	UNPALL		;YES, USE R3=DEVOKB, R2=0
	CMP	R2,#2		;NO, IS IT ENABLE?
	BEQ	ENAALL		;YES, USE ALL DEVICES, R2=2
40$:	CMP	(R1),#"NL	;CLOBBER NL: TO MAKE IT ILLEGAL
	BNE	50$
	MOV	#"??,(R1)
50$:	CALL	GETDVC		;GET DEVICE NAME
	BCS	60$
	CMP	R3,DEVOKB	;IS IT A DISK?
	BHIS	80$		;NO, ALL FUNCTIONS LEGAL
	CMP	R2,#2		;PRIV OR UNPRIV?
	BHI	80$		;NO, ENABLE/DISABLE ARE LEGAL
	MESSAGE	<"  Not possible on disk unit"<200>>
60$:	TSTB	PREST1		;ANSWER FROM CALLER?
	BEQ	10$		;NO, ASK AGAIN
70$:	RETURN

GLOBAL	<DEVOKB>

80$:	MOVB	(R1),PREST2	;SAVE PRESET POINTER
	BNE	110$		;YES, USE IT
90$:	MOV	MAXUSV,MAXUNT	;RESTORE MAXIMUM UNIT # FOR THIS DEVICE
	CALLX	ASKER,R5	;ASK FOR UNIT NUMBER
	 .WORD	100$		;SHORT TEXT
	 GENTXT
	  .ASCII "  Type the device unit number or type a range of unit"<200>
	  .ASCII "  numbers separated by a dash."<200>
100$:	  .ASCIZ <177>"  Unit? "
	 UNORG
	BEQ	60$		;DONE IF <LF> OR CTRL/Z
	CLR	R5		;ASSUME 0 TO MAXUNT FOR 'ALL'
	CALL	ALLCHK		;IS IT 'ALL'
	BEQ	130$		;YES, USE IT
110$:	CALL	CVTUNT		;CONVERT THE UNIT NUMBERS
	BCC	140$		;OK, USE THEM
120$:	TST	PREST2		;WAS THE UNIT NUMBER PRESET?
	BEQ	90$		;NO, TRY ASKING AGAIN
	BR	60$		;YUP, RETURN TO DEVICE QUESTION

130$:	MOVB	#-1,PREST2	;ENSURE WE DON'T RETURN TO 'UNIT'
140$:	CALL	RDRSO3,R4,DEVPTR ;GET DEVPTR VALUE FOR DEVICE
	MOV	(R0),R4		; IN R4
150$:	MOV	R4,R0		;GET VALUE IN UNTCNT OR DEVTBL
	ADD	R5,R0		;INDEXED BY UNIT
	ADD	R5,R0		; *2
	CALL	RDRSTS		;POINT R0 TO IT
	CMP	R3,DEVOKB	;IS IT A DISK?
	BLO	220$		;YES, DO DISK THINGS
	MOV	(R0),R0		;R0 = ADDRESS OF DDB
	CMP	R2,#2		;PRIV OR UNPRIV?
	BLOS	160$		;YES, USE FIRST WORD
	TST	(R0)+		;NO, ENABLE/DISABLE USE 2ND WORD
160$:	CALL	RDRSTS		;GET THE VALUE IN THE DDB WORD
	ADD	R2,PC		;DO THE THING
	 BR	210$		;0 PRIV
	 BR	200$		;2 UNPRIV
	 BR	190$		;4 ENABLE
	CMP	R3,DEVOKB	;6 DISABLE, BUT NOT KB0
	BNE	170$		;NOT A KB
	TST	R5		;KB. IS IT 0?
	BEQ	180$		;YES, ERROR HIM
170$:	CMPB	(R0),#1		;ALREADY DISABLED?
	BEQ	250$		;YES, DON'T FORCE A REWRITE
	MOVB	#1,(R0)		;DISABLE BY SETTING OWNER TO 1
	BR	240$		;DONE

GLOBAL	<DEVPTR,DEVOKB>

180$:	MESSAGE	<"    Can't disable KB0:"<200>>
	BR	250$

190$:	CALL	PKBCHK		;DON'T ENABLE PKB'S
	BCC	250$
	TSTB	(R0)		;ALREADY ENABLED?
	BEQ	250$		;YES, DON'T FORCE A REWRITE
	CLRB	(R0)		;ENABLE BY CLEARING OWNER
	BR	240$

200$:	BIT	#DDPRVO,(R0)	;ALREADY UNPRIV?
	BEQ	250$		;YES, DON'T FORCE A REWRITE
	BIC	#DDPRVO,(R0)	;UNPRIV BY CLEARING DDPRVO
	BR	240$

210$:	BIT	#DDPRVO,(R0)	;ALREADY PRIV?
	BNE	250$		;YES, DON'T FORCE A REWRITE
	BIS	#DDPRVO,(R0)	;PRIV BY SETTING DDPRVO
	BR	240$

220$:	ADD	R2,PC		;DISK DISPATCH
	 IOT			;0 PRIV IS ILLEGAL ON DISK
	 IOT			;2 UNPRIV IS ILLEGAL ON DISK
	 BR	230$		;4 ENABLE
	CMP	#UC.MNT!UC.LCK,(R0) ;6 DISABLE. ALREADY DISABLED?
	BEQ	250$		;YES, DON'T FORCE A REWRITE
	MOV	#UC.MNT!UC.LCK,(R0) ;DISABLE BY SETTING BITS
	BR	240$

230$:	CMP	#UC.MNT,(R0)	;ALREADY ENABLED?
	BEQ	250$		;YES, DON'T FORCE A REWRITE
	MOV	#UC.MNT,(R0)	;ENABLE BY SETTING TO DISMOUNTED STATE
240$:	INC	RWRITE		;FORCE IT TO BE REWRITTEN
250$:	INC	R5		;BUMP THE UNIT NUMBER
	CMP	R5,MAXUNT	;DONE?
	BLOS	150$		;NO, DO MORE
	CALL	WRITRC		;FORCE OUT ANY PARTIAL BUFFER
	BR	120$		;TRY FOR MORE

.DSABL	LSB

.ENABL	LSB

OPTION	MO,DEM
	TST	(R2)+		;R2=2 FOR MODEM
OPTION	LO,CAL
				;R2=0 FOR LOCAL
10$:	MOV	DEVOKB,R3	;R3 = KEYBOARD DEVNAM INDEX
	CALL	RDRSO3,R4,DEVCNT ;GET MAXIMUM KB NUMBER
	MOV	(R0),R4		;SAVE MAXIMUM
	MOV	R4,MAXUNT	; ALSO THERE
	MOVB	(R1),PREST1	;ANSWER GIVEN?
	BNE	40$		;YUP, USE IT
20$:	MOV	R4,MAXUNT	;SAVE MAXUNT FOR CVTUNT
	CALLX	ASKER,R5
	 .WORD	30$
	 GENTXT
	  .ASCII "  Type a keyboard number or a range of keyboard numbers"<200>
	  .ASCII "  separated by a dash.  Keyboards should be DH11, DZ11,"<200> ;001
	  .ASCII "  DHV11 or DHU11 sublines."<200>				;001
	  .ASCII "  Type <CR> to exit from this suboption."<200>
30$:	  .ASCIZ "  KB? "
	 UNORG
	BEQ	60$		;EXIT ON <LF> OR CTRL/Z
	CLR	R5		;ASSUME ALL
	CALL	ALLCHK		;ALL?
	BEQ	70$		;YES, USE ALL
40$:	CALL	CVTUNT		;CONVERT UNIT NUMBERS
	BCC	70$		;VALID ANSWER
50$:	TSTB	PREST1		;PRESET ANSWER?
	BEQ	20$		;NO, ASK AGAIN
60$:	RETURN			;BACK TO SUBOPTION

GLOBAL	<DEVOKB,DEVCNT>

70$:	MOV	R2,-(SP)	;SAVE SUBOPTION INDEX
	CALL	GETDS		;FIND THE DS BLOCK FOR THIS KB
	MOV	(SP)+,R2	;RESTORE IT
	CMP	PK.NAM(R1),#"DH	;IT BETTER BE A DH11
	BEQ	80$		;GOOD
	CMP	PK.NAM(R1),#"DZ	; OR A DZ11
	BEQ	80$		;GOOD AGAIN
	CMP	PK.NAM(R1),#"VH	; OR A DHV11/DHU11			;001
	BEQ	80$		;GOOD AGAIN				;001
	MESSAGE	<"  KB">
	MOV	R5,R0		;PRINT UNIT
	CALLX	DECZER
	MESSAGE	<" is not a DH11, DZ11, DHV11 or DHU11 subline"<200>>	;001
	BR	100$		;SKIP THIS UNIT

80$:	MOV	R5,R1		;COPY THE UNIT NUMBER
	MUL	DDS.KB,R1	;COMPUTE OFFSET TO THIS KB'S DDB
	ADD	KBDDDB,R1	;R1 = ADDRESS OF DDB
	ADD	#TTINTF,R1	;R1 = INTERFACE WORD ADDRESS
	MOV	R1,R0		;GET THE INTERFACE WORD
	CALL	RDRSTS		; AT R0
	BIC	#TTMODM,(R0)	;ASSUME WE ARE LOCAL
	ADD	R2,PC		;DISPATCH ON MODEM/LOCAL
	 BR	90$		;0 LOCAL, GOOD GUESS. LEAVE TTMODM OFF
	BIS	#TTMODM,(R0)	;2 MODEM CONTROL TURNED ON
90$:	INC	RWRITE		;FORCE OUT THE CHANGE
100$:	INC	R5		;NEXT KB UNIT
	CMP	R5,MAXUNT	;DONE?
	BLOS	70$		;NO
	CALL	WRITRC		;FORCE OUT ANY POSSIBLE CHANGE
	BR	50$		;TRY FOR MORE

.DSABL	LSB

GLOBAL	<DDS.KB,KBDDDB>

OPTION	LP

.ENABL	LSB

	MOV	DEVNAM,R3	;FIND THE INDEX OF THE FIRST LP
10$:	MOV	R3,R0		;GET A NAME FROM THE SIL
	CALL	RDRSTS
	CMP	(R0),#"LP	;IS THIS THE LP?
	BEQ	40$		;YES
	ADD	#2,R3		;NO, NEXT NAME
	CMP	R3,DEVSYN	;DONE WITH DEVICE NAMES?
	BLO	10$		;NO, TRY AGAIN
20$:	MESSAGE	<"  This monitor does not support line printers"<200>>
30$:	RETURN

40$:	SUB	DEVNAM,R3	;COMPUTE THE LP DEVTBL OFFSET
	CALL	RDRSO3,R4,DEVCNT ;GET THE LP COUNT
	MOV	(R0),MAXUNT	;SAVE IT
	BMI	20$		;NEGATIVE, GET OUT
	CALL	RDRSO3,R4,DEVPTR ;GET POINTER TO DDB POINTERS
	MOV	(R0),R4		;SAVE IT IN R4
	MOV	MAXUNT,R0	;GET THE MAXIMUM
	BEQ	80$		;IF ZERO, ONLY ONE LP, SO SKIP THE QUESTION
	ADD	#'0,R0		;MAKE IT ASCII
	MOVB	R0,50$		;PUT INTO TEXT
LPNEXT:	CALLX	ASKER,R5	;ASK FOR UNIT
	 .WORD	60$		;SHORT TEXT
	 GENTXT
	  .ASCII "  Type the unit number of the line printer to change."<200>
	  .ASCII "  Valid unit numbers for this monitor are 0 to "
50$:	  .ASCII "N."<200>
	  .ASCII "  Type <CR> to exit from this suboption."<200>
60$:	  .ASCIZ <177><12>"  Unit? "
	 UNORG
	BEQ	30$		;EXIT ON <LF> OR CTRL/Z
	CALLX	DECINP		;PARSE DECIMAL NUMBER
	BNE	70$		;ERROR
	CMP	R0,MAXUNT	;TOO BIG?
	BLOS	80$		;NO, JUST RIGHT
70$:	MESSAGE	<"  Invalid unit number"<200>>
	BR	LPNEXT		;TRY AGAIN

GLOBAL	<DEVNAM,DEVSYN,DEVCNT,DEVPTR>

80$:	MOV	R0,R5		;COPY THE UNIT NUMBER
	ASL	R0		;COMPUTE DDB POINTER ADDRESS
	ADD	R4,R0		;R0 = ADDRESS OF DDB POINTER
	CALL	RDRSTS		;GET THE DDB ADDRESS
	MOV	(R0),XXXDDB	; FOR LATER
90$:	MESSAGE	<"  Type (">
	CALL	LPTYPP		;PRINT THE TYPE (AND GET VALUES)
100$:	CALLX	ASKER,R5	;ASK
	 GENTXT	<")? ">
	 GENTXT
.ASCII	"  Specify the line printer type (LP, or LA180)."<200>
.ASCII	"  If the line printer is none of these, type individual"<200>
.ASCII	"  characteristic names, separated by commas."<200>
.ASCII	"  The characteristics are:"<200>
.ASCII	"    RESET     Reset printer to RSTS defaults"<200>
.ASCII	"    OMITCR    Omit sending <CR> if next character is <LF>"<200>
.ASCII	"    NOOMITCR  Always send <CR> to the printer"<200>
.ASCII	"    CR        Insert <CR> before <LF>, <VT>, and <FF>"<200>
.ASCII	"    NOCR      Printer performs implied <CR> before <LF>, <VT>, <FF>"<200>
.ASCII	"    FILL      Insert fill after form feeds"<200>
.ASCII	"    NOFILL    Fill is not required after form feeds"<200>
.ASCII	"    CONTROL   Send non-printing characters to the printer"<200>
.ASCII	"    NOCONTROL Discard non-printing characters or use uparrow mode"<200>
.ASCII	"    EOT       Send EOT (^D) to the printer"<200>
.ASCII	"    NOEOT     Treat EOT like other non-printing characters"<200>
.ASCII	"    8BIT      Allow 8-bit characters to be sent to printer"<200>
.ASCII	"    NO8BIT    Don't allow 8-bit characters (allow formatting)"<200>
.ASCII	"    BSEMULATE Emulate the action of 'backspace' on the printer"<200>
.ASCII	"    BSREAL    Printer has real backspace (carriage moves left)"<200>
.ASCII	"    BSCONTROL Treat backspace like other non-printing characters"<200>
.ASCII	"  Characteristics not specified are not changed."<200>
.ASCII	"  RSTS default printer characteristics:"<200>
.ASCII	"	NOOMITCR, CR, NOEOT, FILL, NOCONTROL, NO8BIT, BSEMULATE"<200>
.ASCII	"  Type <CR> to leave the characteristics alone."<200>
.ASCII	"  The defined printer types are:"<200>
.ASCII	"  LP = OMITCR, NOCR, NOEOT, FILL, NOCONTROL, NO8BIT, BSEMULATE"<200>
.ASCII	"  LA180 = OMITCR, NOCR, NOEOT, FILL, NOCONTROL, NO8BIT, BSREAL"<200>
.ASCII	<12>
.ASCIZ	<177>"  What is the type of this line printer? "
	UNORG
	BEQ	LPWIDE		;GO TO THE WIDTH QUESTION ON <LF> OR CTRL/Z
	MOV	LP.CHR,R2	;GET UNIT'S CURRENT CHARACTERISTICS
110$:	MOV	R1,R0		;SCAN FOR A COMMA
120$:	TSTB	(R0)		;END OF LINE?
	BEQ	130$		;YUP, NO COMMA
	CMPB	(R0)+,#',	;NO, IS IT A COMMA?
	BNE	120$		;NO, LOOK MORE
	CLRB	-1(R0)		;NULLIFY THE COMMA
130$:	CMPB	(R0)+,#40	;SKIP SPACES AFTER COMMAS
	BEQ	130$
	DEC	R0		;POINT AT NON-SPACE
	MOV	R0,-(SP)	;SAVE POINTER TO MORE TEXT
	CALLX	GETUNQ,R5,LNAMES ;SCAN FOR ONE OF THE VALID NAMES
	MOV	(SP)+,R1	;RESTORE POINTER TO MORE TEXT
	BCC	140$		;GOT IT
	MESSAGE	<"  Invalid response"<200>>
	BR	90$		;TRY AGAIN

140$:	BIS	LTYPES(R0),R2	;SET SOME BITS
	BIC	LTYPEC(R0),R2	;CLEAR OTHERS
	TSTB	(R1)		;ANY MORE CHARACTERISTICS?
	BNE	110$		;YES, TRY THEM
	MOV	R2,LP.CHR	;SAVE CHARACTERISTICS			;003
	CALL	LPCPUT		;REWRITE TO DISK
	;BR	LPWIDE
LPWIDE:

.DSABL	LSB

;+
;	A subroutine in the ROOT takes LNAMES, and scans the
;	strings in it's list for a match up with characteristics
;	entered at the terminal.  No match sets the CARRY, and invalid 
;	response is given.  A match returns R0 as the number of incorrect
;	strings scanned * 2 for a word count.  
;
;	Hence, for the nth characeristic, R0 = (n*2), and 
;		LTYPES(R0) = bits to set, and
;		LTYPEC(R0) = bits to clear
;	in order to assert this characteristic in LPTCHR.
;
;	The ordering is important and must be preserved. 
;
;-

	I.MESS
LNAMES:	UNQTXT	<LP>
	UNQTXT	<LA\180>
	UNQTXT	<RE\SET>
	UNQTXT	<OM\ITCR>
	UNQTXT	<NOO\MITCR>
	UNQTXT	<NOCR>
	UNQTXT	<CR>
	UNQTXT	<EO\T>
	UNQTXT	<NOE\OT>
	UNQTXT	<NOF\ILL>
	UNQTXT	<FI\LL>
	UNQTXT	<CO\NTROL>
	UNQTXT	<NOCO\NTROL>
	UNQTXT	<8B\IT>
	UNQTXT	<NO8B\IT>
	UNQTXT	<BSE\MULATE>
	UNQTXT	<BSR\EAL>
	UNQTXT	<BSC\ONTROL>
	.BYTE	0

	TMPORG	SETCTL
				;Bits to set to assert:
LTYPES:	.WORD	LP.FLG		;characteristics of LP11 printer
	.WORD	LA.FLG		;characteristics of LA180 printer
	.WORD	0		;RESET, don't set anything (default LPTCHR = 0)
	.WORD	LPTSCR,0	;OMITCR,NOOMITCR
	.WORD	LPTCRF,0	;NOCR,CR
	.WORD	LPTEOT,0	;EOT,NOEOT
	.WORD	LPTSFF,0	;NOFILL,FILL
	.WORD	LPTNPC,0	;CONTROL, NOCONTROL
	.WORD	LPT8BT,0	;8BIT,NO8BIT
	.WORD	0		;BSEMULATE
	.WORD	LPTRBS		;BSREAL
	.WORD	LPTNBS		;BSCONTROL
				;Bits to clear to assert:
LTYPEC:	.WORD	^C<LP.FLG>	;LP11 characteristics
	.WORD	^C<LA.FLG>	;LA180 characteristics
	.WORD	-1		;Clear all characteristics to RESET
	.WORD	0,LPTSCR	;OMITCR,NOOMITCR
	.WORD	0,LPTCRF	;NOCR,CR
	.WORD	0,LPTEOT	;EOT,NOEOT
	.WORD	0,LPTSFF	;NOFILL,FILL
	.WORD	0,LPTNPC	;CONTROL,NOCONTROL
	.WORD	0,LPT8BT	;8BIT,NO8BIT
	.WORD	LPTRBS!LPTNBS	;BSEMULATE
	.WORD	LPTNBS		;BSREAL
	.WORD	LPTRBS		;BSCONTROL

	UNORG

.ENABL	LSB

LPWIDE:	MESSAGE	<"  Width (">
	CLR	R0		;CLEAR FOR BISB
	BISB	XXHORC,R0	;GET WIDTH+1
	BEQ	10$		;OOPS, GOTTA DEFAULT TO 80
	DECB	R0		; -1
	BNE	20$		;NOT 0 OR 1
10$:	MOV	#132.,R0	;GET THE DEFAULT
20$:	CALLX	DECZER		;PRINT IT
	CALLX	ASKER,R5
	 GENTXT	<")? ">
	 GENTXT
.ASCII	"  Specify the width of the printer line as a number between"<200>
.ASCII	"  1 and 254."<200>
.ASCII	"  Type <CR> to leave the width unchanged."<200>
.ASCIZ	<177><12>"  What is the width of the line printer? "
	UNORG
	BEQ	40$		;NO CHANGE ON <LF> OR CTRL/Z
	CALLX	DECINP		;GET INPUT AS DECIMAL NUMBER
	BNE	30$		;NOT VALID
	TST	R0		;ZERO?
	BNE	40$		;NOPE, MIGHT BE VALID
30$:	MESSAGE	<"  Invalid response"<200>>
	BR	LPWIDE		;TRY AGAIN

40$:	INCB	R0		;MAKE IT WIDTH+1
	BEQ	30$		;OOPS, 255 IS NOT VALID
	CMPB	R0,XXHORC	;UNCHANGED?
	BEQ	LPCASE		;YES, THAT'S EASY
	MOVB	R0,XXHORC	;CHANGE, SO CHANGE OUR VALUES
	MOVB	R0,XXHORZ
	CALL	LPCPUT		;PUT OUT LP CHARACTERISTICS
	;BR	LPCASE
LPCASE:

.DSABL	LSB

.ENABL	LSB

LPCASE:	MESSAGE	<"  Lower case (">
	MOV	LP.CHR,R2	;GET CHARACTERISTICS IN R2
	MOV	(PC)+,R0	;GET TEXT
	 GENTXT	<"no">
	BIT	R2,#LPTALC	;IS IT LOWER CASE?
	BEQ	10$		;NO, 'NO' IS RIGHT
	MOV	(PC)+,R0
	 GENTXT	<"yes">
10$:	CALLX	ASCIZ0
	CALLX	ASKER,R5
	 GENTXT	<")? ">
	 GENTXT
	  .ASCII "  Type 'YES' if the line printer has lower case capability."<200>
	  .ASCII "  Type 'NO' if it does not.  Type <CR> for no change."<200>
	  .ASCIZ <177><12>"  Does this printer have lower case? "
	 UNORG
	BEQ	50$		;NO CHANGE ON <LF> OR CTRL/Z
	CALLX	ANSWER,R5
	 BR	20$		;YES
	 BR	30$		;NO
	 BR	50$		;<LF>
	 BR	50$		;OLD
	MESSAGE	<"  Invalid response"<200>>
	BR	LPCASE

20$:	BIT	R2,#LPTALC	;ALREADY YES?
	BNE	50$		;YUP, NO CHANGE
	BIS	#LPTALC,R2	;NO, SET IT
	BR	40$

30$:	BIT	R2,#LPTALC	;ALREADY NO?
	BEQ	50$		;YUP, NO CHANGE
	BIC	#LPTALC,R2	;NO, RESET IT
40$:	MOV	R2,LP.CHR	;SAVE CHARACTERISTICS
	CALL	LPCPUT		;WRITE THEM OUT
50$:	TST	MAXUNT		;MORE THAN ONE LP?
	BEQ	60$		;NOPE, JUST RETURN
	JMP	LPNEXT		;YUP, GET ANOTHER

60$:	RETURN			;FROM LP SUBOPTION

.DSABL	LSB

.SBTTL	CLEAN UP AFTER OPTIONS

	TMPORG	SETOPT		;TRAP INVALID RESPONSES
	 .WORD	SETXXX
	TMPORG	SETOTX
	 .BYTE	0		;END OF TEXT
	UNORG

SETXXX:	MESSAGE	<"  Illegal suboption given"<200>>
	RETURN

.MACRO	OPTION	N1,N2
.ERROR	;OPTIONS NOT LEGAL
.ENDM	OPTION

.SBTTL	GET A DEVICE NAME FROM THE INPUT LINE

;+
;	R1 -> INPUT STRING
;
;	CALL	GETDVC
;
;	C=0 =>	DEVICE NAME FOUND
;	R0 =  RANDOM
;	R1 -> CHARACTER AFTER DEVICE NAME
;	R3 =  DEVTBL OFFSET
;	R4 =  DEVICE NAME
;	R5 =  0
;	MAXUNT = DEVCNT VALUE FOR DEVICE (MAX UNIT NUMBER)
;
;	C=1 =>	NOT A VALID NAME, ERROR MESSAGE HAS BEEN PRINTED
;-

.ENABL	LSB

GETDVC:	MOV	R1,R3		;COPY THE NAME POINTER
10$:	TSTB	(R3)+		;SCAN TO THE END
	BNE	10$
	DEC	R3		;BACK UP
	CMPB	-(R3),#':	;IS THERE A TRAILING COLON?
	BNE	20$		;NO
	CLRB	(R3)		;YES, ELIMINATE IT
20$:	MOV	(R1)+,R4	;R4 = DEVICE NAME
	MOV	DEVNAM,R3	;R3 = ADDRESS OF DEVNAM TABLE IN RSTS
30$:	MOV	R3,R0		;COPY FOR RDRSTS
	CALL	RDRSTS		;READ A WORD FROM THE SIL
	CMP	R4,(R0)		;IS THIS THE NAME?
	BEQ	50$		;YES, SUCCESS
	ADD	#2,R3		;NEXT DEVNAM VALUE
	CMP	R3,DEVSYN	;UP TO THE SYNONYMS YET?
	BLO	30$		;NO
40$:	MESSAGE	<"  Invalid response"<200>>,INVRES
	SEC			;C=1 FOR FLAG
	RETURN

50$:	SUB	DEVNAM,R3	;R3 = DEVNAM OFFSET
	CALL	RDRSO3,R4,DEVCNT ;GET THE DEVCNT VALUE FOR THIS DEVICE
	MOV	(R0),MAXUNT	;SAVE IT IN MAXUNT
	BMI	40$		;NONE LEGAL, BOOT HIM
	MOV	(R0),MAXUSV	;SAVE A BACKUP VALUE
	CLR	R5		;R5 = 0 AS A CONVENIENCE
	RETURN			;C=0 FROM CLR

.DSABL	LSB

GLOBAL	<DEVNAM,DEVSYN,DEVCNT>

	TMPORG	SETCTL
MAXUNT:	.WORD	0		;MAXIMUM UNIT NUMBER BEING USED
MAXUSV:	.WORD	0		;SAME, BUT NOT CHANGED IN SUBOPTIONS
	UNORG

.SBTTL	CONVERT UNIT NUMBER IN STRING

;+
;	R1 -> UNIT NUMBER(S)
;	MAXUNT = HIGHEST LEGAL VALUE
;
;	CALL	CVTUNT
;
;	C=0 =>	UNIT NUMBER VALID
;	R0, MAXUNT = HIGH UNIT NUMBER
;	R5 = LOW UNIT NUMBER
;
;	C=1 =>	UNIT NUMBER INVALID, ERROR MESSAGE PRINTED
;-

.ENABL	LSB

CVTUNT:	CLR	R5		;ASSUME ALL
	CMPB	(R1),#'*	;IS IT ALL?
	BNE	10$		;NO
	TSTB	1(R1)		;MAYBE?
	BEQ	30$		;YUP, USE ALL
10$:	MOV	R1,R5		;COPY TEXT POINTER
	CALLX	DECINP		;PARSE THE FIRST NUMBER
	CMP	R1,R5		;DID THE POINTER MOVE?
	BEQ	50$		;NO, ERROR
	MOV	R0,R5		;COPY THE LOW UNIT
	CMP	R0,MAXUNT	;TOO BIG FOR THIS DEVICE?
	BHI	50$		;YES IS AN ERROR
	TSTB	(R1)		;DONE WITH STRING?
	BEQ	20$		;YUP, LOW IN R5 = HIGH IN R0
	CMPB	(R1)+,#'-	;MUST BE A DASH
	BNE	50$		;NO IS ERROR
	MOV	R1,-(SP)	;SAVE THE TEXT POINTER
	CALLX	DECINP		;GET HIGH UNIT NUMBER IN R0
	BNE	40$		;NOT END OF STRING, SO ERROR
	CMP	R1,(SP)+	;DID THE POINTER MOVE?
	BEQ	50$		;NO, ERROR
	CMP	R0,R5		;IS THE HIGH > LOW?
	BLOS	50$		;NO, ERROR
	CMP	R0,MAXUNT	;IS THE HIGH TOO BIG?
	BHI	50$		;YES, ERROR
20$:	MOV	R0,MAXUNT	;SET UP THE HIGH LIMIT
	CLC			;C=0 FOR FLAG
30$:	RETURN

40$:	TST	(SP)+		;POP THE STACK
50$:	MESSAGE	<"  Invalid unit number"<200>>
	SEC
	RETURN

.DSABL	LSB

.SBTTL	LOCATE THE DS PACKET FOR A DEVICE

;+
;	R3 =  DEVTBL OFFSET
;	R5 =  DEVICE UNIT NUMBER
;
;	CALL	GETDS
;
;	C=0 =>	FOUND
;	R1 -> DEVTBL PACKET FOR DEVICE
;	R2 -> DS PACKET
;
;	C=1 =>	NOT FOUND
;	R1 =  0
;	R2 =  0
;-

.ENABL	LSB

GETDS:	MOV	#DSTBL+3000,R2	;POINT TO DS TABLE
10$:	CMPB	R3,(R2)		;IS THIS THE DEVICE?
	BNE	20$		;NO, TRY THE NEXT ONE
	MOVB	DS.UNT(R2),R1	;GET THE FIRT UNIT CONTROLLED
	NEG	R1		;COMPUTE UNIT - (FIRST ON THIS CONTROLLER)
	ADD	R5,R1		; IN R1
	BMI	20$		;NEGATIVE, SO TOO LOW
	CMPB	R1,DS.NUN(R2)	;IN RANGE OF NUMBER CONTROLLED?
	BLO	30$		;YES, WE FOUND IT
20$:	ADD	#DS.XXX,R2	;NEXT DS PACKET
	TST	2(R2)		;ANYTHING THERE?
	BNE	10$		;YES
	CLR	R1		;NO, CLEAR R1
	CLR	R2
	SEC
	RETURN

30$:	MOVB	DS.PKT(R2),R1	;GET THE PACKET NUMBER
	MUL	#PKTSIZ,R1	;COMPUTE PACKET OFFSET
	ADD	#DEVTBL,R1	;ADD DEVICE TABLE ADDESS
	RETURN

.DSABL	LSB

GLOBAL	<DSTBL,DEVTBL>

.SBTTL	CHECK FOR PSEUDO KEYBOARD

;+
;	R3 =  DEVTBL OFFSET
;	R5 =  DEVICE UNIT NUMBER
;
;	CALL	PKBCHK
;
;	C=0 IF IT IS A KB WITH PSEUDO KEYBOARD TYPE
;	C=1 IF IT IS ANYTHING ELSE
;-

PKBCHK:	CMP	R3,DEVOKB	;IS IT A KEYBOARD?
	BNE	10$		;NO, SEC
	CMP	R5,PKLAST	;ABOVE THE HIGHEST NUMBER?
	BGT	10$		;YES, SEC (ALWAYS TRUE IF PKLAST = -1)
	CMP	R5,PKFRST	;BELOW THE LOWEST?
	BLT	10$		;YES, SEC
	TST	(PC)+		;NO, SKIP THE SEC, C=0, AND RETURN
10$:	SEC
	RETURN

GLOBAL	<DEVOKB>

.SBTTL	CHECK FOR 'ALL'

ALLCHK:	CMP	(R1),#"AL
	BNE	10$		;NO, Z=0
	CMP	2(R1),#'L
10$:	RETURN

.SBTTL	GET A WORD FROM THE RSTS MODULE OF THE SIL

;+
; RDRSTS - READ RSTS MODULE AND RETURN A WORD
;
;	R0 =  ADDRESS WITHIN RSTS
;
;	CALL	RDRSTS
;
;	R0 -> WORD IN BUFFER
;
; NOTE: TO REWRITE THE BUFFER, MAKE RWRITE NON-0
;-

.ENABL	LSB

RDRSO3:	MOV	R3,R0		;READ OFFSET FROM R3
	ADD	@(R4)+,R0	;OFFSET POINTER FOLLOWS THE CALL
	CALL	RDRSTS		;GET IT
	RETURN	R4		;AND RETURN PROPERLY

RDRSTS:	REGSCR			;SAVE REGISTERS
	MOV	R0,R2		;COPY ADDRESS
	BIC	#777,R2		;REMOVE BLOCK OFFSET FROM ADDRESS
	BIC	R2,R0		;LEAVE ONLY THE BLOCK OFFSET IN R0
	ADD	#DATABF,R0	;R0 -> LOCATION OF DESIRED WORD IN BUFF
	MOV	R0,TOS.R0(SP)	;RETURN POINTER IN R0
	SWAB	R2		;CONVERT R2 TO RELATIVE BLOCK NUMBER
	ROR	R2		;  WITHIN RSTS MODULE
	ADD	RSTBLK,R2	;R2 = ABSOLUTE BLOCK WITHIN SIL
	CMP	R2,BLNRST	;IS IT ALREADY THERE?
	BEQ	10$		;YUP, THAT'S EASY
	CALL	WRITRC		;REWRITE BLOCK IF NECESSARY
	MOV	#FCSIL,R1	;R1 -> FCB FOR READ
	MOV	R2,FCNVB(R1)	;SPECIFY BLOCK TO READ
	CALLX	READ.B,R5,DATABF ;READ IT IN
	MOV	R2,BLNRST	;REMEMBER WHAT'S THERE
10$:	RETURN

.DSABL	LSB

GLOBAL	<FCSIL,RSTBLK>

.SBTTL	REWRITE MONITOR IF REQUIRED

.ENABL	LSB

WRITRC:	TST	RWRITE		;REWRITE NEEDED?
	BEQ	10$		;NO
	MOV	#FCSIL,R1	;YES, R1 -> FCB FOR WRITE
	MOV	BLNRST,FCNVB(R1) ;SET BLOCK TO WRITE
	CALLX	WRIT.B,R5,DATABF ;DO IT
	CLR	RWRITE		;NO NEED ANY MORE
10$:	RETURN

.DSABL	LSB

	TMPORG	SETCTL
BLNRST:	.WORD	0		;BLOCK OF SIL IN MEMORY
RWRITE:	.WORD	0		;<>0 IF REWRITE OF BLOCK NEEDED
DATABF:	.BLKW	256.		;BLOCK BUFFER
	UNORG

GLOBAL	<FCSIL>

ENDOVL	<SET,SETCTL,SETOPT,SETOTX,SETTXT>,100

.END
