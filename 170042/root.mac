.INCLUDE /CMN:COMMON/							;097
.INCLUDE /CMN:KERNEL/							;097
.INCLUDE /INIT:INIPFX/							;097
.INCLUDE /INIT:DSKDEF/							;097
.INCLUDE /INIT:TAPDEF/							;097
.INCLUDE /CMN:CFGDEF/							;112
.INCLUDE /CMN:HDRDEF/							;117
TITLE	INIT,<INIT ROOT CODE FOR RSTS/E>,0L,03-AUG-92,MHB/MND/JTC/GPK/CEK/JHC/FEK/WJS/TPT/FRL/DBM/VAM/KPH/PJH/DSD

;
;		COPYRIGHT (c) 1974, 1992 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR ROOT

;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-08
;  001	MND  16-Feb-81	Added DMP/DMV support
;  002  MND  16-MAR-81	FIX DMP AUTO-SIZING BUG
;  003  MDS  20-MAR-81	ADD CODE FOR EXTENDED MEMORY DUMPS
;  004  MDS  04-APR-81	MOVE IDENT CODE OUT OF ROOT
;  005  SRM  06-May-81	Correct the crash file sizing routine.
;  006	JTC  13-May-81	Remove Crash Table from Default Buffer.
;  007	MND  01-JUN-81	Add TS11 time-out notification and HERTZ feature patch
;  008	MND  29-JUN-81	Distinguish DMR and DMC, XM micro-diag. routine XMDIAG
;  009  GPK  01-Jul-81	Load ODT from ODT.SYS instead of system SIL
;  010  MDS  19-MAY-81	Add PC dumping on error
;  011  CEK  06-Aug-81  Add cells and SIZMON routine for data space
;  012  SRM  06-Aug-81  Fix bugs for checking odd address trapping 
;			on the current processor.
;  013  MND  10-Aug-81  Set "Need Buffer Address" bit for TS11 after SAV/RES
;  014  CEK  03-Sep-81  Compute MONSIZ correctly
;  015  CEK  20-Oct-81  Remove SIZMON routine, DSSOFT and SIZMON cells
;			(replaced by code in INIDEF)
;  016	SRM  21-Oct-81	Add crash dumping of FIP Pool and .$LODB (FBB address
;			of the Load Block in the monitor)
;
;				[RSTS V7.2]
;  000  CEK  07-Jan-82  CREATION - COPIED FROM V7.1-11
;  001  CEK  07-Jan-82  Added .$OVBF cell
;  002  MND  22-Mar-82  Added support for MSCP disks - UDA50/RA80
;  003  AWL  08-Mar-82  Added Q22 support for RLV12
;  004  JHC  19-Apr-82  Source clear patches 1.1.7 and 1.1.8
;  005  AWL  23-Apr-82  Move memory-size algorithm to be after test of
;			memory management
;  006  AWL  23-Apr-82  Move abort of INIT if no RLV12 5th register to INISTA
;
;				[RSTS V8.0]
;  007	GPK  16-Jun-82	Connections from driver dispatch to bootstraps
;			device packet layout changes
;  008	GPK  30-Jun-82	Change ODT interface to user RSTS-style calling 
;			convention
;  009	GPK  03-Aug-82	Removed LOAD option
;  010	GPK  05-Aug-82	Changed the way ODT is invoked in one-shot code
;  011	GPK  12-Aug-82	Bigger DCNLST
;  012	GPK  24-Sep-82	New disk structure; bugfix
;  013	GPK  26-Sep-82	Clear all of memory in one-shot code
;  014	GPK  30-SEP-82	Bugfix in ERFTRP
;  015	JHC  23-sep-82  Source clear TS11 SAVRES patch (V7.1 1.1.10)
;  016	GPK  29-Nov-82	Source clear SPR 11-49932, and other fixes
;  017	GPK  06-Dec-82	Add streamline startup for TAP
;  018  AWL  07-Jan-83  Set FLG22<0> if physical memory <= 124KW (was 128KW)
;  019  MND  25-Jan-83  Reinstalled INIT's LOAD option overlay
;  020	JHC  28-Jan-83	Handle traps to 114 in SETNXM (for 11/70 hardware)
;  021  JHC  17-Feb-83	Reinstalled the FILL option within the LOAD overlay.

;				[RSTS V9.0]
;  022	JHC  11-Jul-83	Added BBRAP5 for BBR phase loading.  Also add routine
;			in DSKSET to get BBR loaded as a phase.  Moved Globals
;			from INIMCP to get rid of link errors.
;  023	JHC  13-Jul-83	Add CALLM and CALLMI to the root for use when MSCP
;			dispatches to BBR. Also set up BBRDSP and $BBREP
;			as well as $RSMBR.
;  024	MND  14-Aug-83	Added bus auto-size codes to device packets
;  025  WJS  19-Aug-83	LTDS changes
;  026	MND  07-Oct-83	I.INI0 - now automatically chains to INSTAL if 
;			starting W/O an INSTALled SIL or chains to START
;			if involked (EXITs) from an auto-INSTAL.
;  027  MND  07-Nov-83	Back-out some changes put in by 025
;  028  TPT  11-Nov-83	Merge V8.0-07 changes (DHU/DHV support)
;  029  FRL  12-Dec-83  Made L3Q in INIT work as it does in the monitor
;  030  FEK  02-JAN-84	ADD SUPPORT FOR J11 CHIPS AND XE: UNA DEVICE
;  031  MND  03-Feb-84	More easy start-up changes
;  032  MND  21-Feb-84	Added Date option, change Date & Time prompts
;  033	DBM  01-Mar-84	Add MS$TYP and TSQ blocks, and IOT for MS driver
;			And clear patch 1.1.29
;  034	FEK  01-Mar-84	Handle bad memory in SETNXM
;  035	MND  10-Mar-84	Auto-chain to COPY when installing RSTS on new disk
;  036	DBM  17-May-84	Make RETTSQ global so MSDVR can call it
;  037	MND  03-Jul-84  More Installation/Update changes in dialogue
;  038	DBM  14-Aug-84	Add UNLOC0 global for MSDVR
;  039	DBM  17-Aug-84	Change time format (AM/PM/M) to VMS style (AM/PM)
;  			And modify installation/update questions
;  040  JHC  08-Oct-84	Repair RETTSQ routine so MSDVR can make it.
;  041	DBM  10-Oct-84	Change DATINI to print date and time like F$TIME
;  042  VAM  16-Jan-85	Fix spelling errors in dialogue.  Also, change parity
;			error reporting to give K range in decimal.
;  043  VAM  18-Jan-85	Remove definition of 'NOTTYS' (used by UNISYS)
;  044	DBM  20-Feb-85	Remove INSTALL and SET options from help list
;			Make ? give help at Option:
;			Add DSKREV global for FEK
;  045	FEK  13-Mar-85	Add RJ2780 softkg symbol, + other misc things
;  046  FRL  14-Mar-85  Move DECtape flag here
;  047  VAM  03-Apr-85	Add COADEV loc to hold ASCII device name for COPY
;
;			[RSTS V9.1]
;  048	TPT  07-Feb-85	FNDJOB/IOFIN4 moved here from INIDSK ; misc. changes
;  049	TPT  12-Mar-85	Added entries to fudge TMSCP for now...
;  050	DBM  06-May-85	Merge TMSCP changes with V9.0-14
;  051	KPH  05-Apr-85	Remove primary RTS
;  052  VAM  15-May-85	Change MAGDEN to TAPDEN (new format default density)
;  053  MND  18-May-85	Add the CALLMR routine for MSCP/TMSCP split
;  054	DBM  18-May-85	RTI3, DMPJOB, SAVJOB, and DEV.M? moved from INIDSK
;			BBRDSP entries for DUDSK
;  055	DBM  21-May-85	Bug fix in GETCSR, allow KPARSU calls with mem mgt on
;  056  KPH  28-May-85	Conditional phases
;  057  TPT  12-Jun-85	Have DMPJOB just return
;  058  VAM  18-Jun-85	Speed up SETNXM
;  059  VAM  02-Jul-85	Remove SET option
;  060  KPH  08-Jul-85	Remove AODS globals
;			Bugfix in SAVBOO handling at Option: prompt
;  061  VAM  27-Aug-85	Fix handling for [T]MSCP error log EMTs.
;			Clear seconds when user resets time.
;			Also, remove COADEV (see 047 above - "Never mind!!").
;  062  VAM  11-Sep-85	Don't allow starting if One-Shot found anything wrong.
;  063	TPT  15-Sep-85	Change MU packet to allow only 1 unit
;			Allow MSCP errors from BBR to be logged
;
;			[RSTS V9.2]
;  064  KPH  15-Jul-85	Add Job Control Region
;
;			[RSTS V9.3]
;  065  KPH  26-Sep-85	Add DECnet conditional phases
;  066	JHC  26-Nov-85	Add Ethernet Conditional phase loading
;  067  DBM  05-Dec-85	Various defs for making XE/XH work on Earth.
;  068  KPH  08-Jan-86	Add jam symbols for DDS.XE and DDS.XH
;  069  FEK  13-Jan-86	Merge in FEK last minute V9.2 stuff
;  070  KPH  14-Jan-86	Add RDM and EVL phases
;  071	TPT  15-Jan-86	Add BLDTSQ from MS/MU drivers, fix CALLM to work
;			with non-autoload vector calls
;  072  KPH  06-Feb-86	Add RDMAP5 to the root
;  073	JHC  10-Feb-86	Add FAKDDB to .SIL tables
;  074	DBM  24-Mar-86	Ethernet support
;  075	FEK  05-Mar-86	Add 11/53 support + fix some other bugs
;  076  VAM  28-Apr-86	Handle memory >1920Kw.
;			Get rid of S.??? globals and long START option.
;  077	DBM  12-May-86	Add global table for [T]MSCP ECO check
;  078	FRL  28-Apr-86	Changes for Micro/RSTS
;  079  VAM  15-May-86	Make 2040Kw limit actually 2044Kw.
;  080  VAM  19-May-86	Add SYSTIC and NULJOB symbols for J11 null job poke.
;			Add sizing for J11 Boot and Diagnostic Register (BDR).
;  081	DBM  21-May-86	Clean up low core after QNA diagnostics call
;  082	DBM  27-May-86	Fix GETCSR for non-existant DU disks
;  083  VAM  11-Jun-86	Fix SETNXM top memory address for 11/24 CPUs.
;  084  VAM  08-Jul-86	Catch unexpected interrupts.
;			Simplify J11 frequency table (by FEK).
;  085  VAM  09-Jul-86	Don't perform J11BDR sizing again if KW11-L doesn't
;			work.
;  086	DBM  18-Jul-86	MU and XH CSR's.  QNA ROM check.
;  087  VAM  13-Aug-86	Fix BBRDSP table and RT11 $OTABL for new phase layout.
;			Also add CALMCP and MCPJMP.
;  088	FEK  03-Nov-86	Fix 083 for 11/24's proper memory size
;  089  VAM  10-Nov-86	Changes to DEFALI/DEFALO; allow it to read/write
;			non-contiguous DEFALT regions, and expand error
;			trapping to give more descriptive error information.
;
;			[RSTS V9.4]
;  090  VAM  13-Jan-87	Fix parity error trapping in SETNXM.
;			Also, use MEMTRP to detect cache errors.
;  091	FEK  05-Feb-87	Allow INIT to find DT07 bus switches
;  092	PJH  10-Feb-87	Merge in GPK changes.
;  093	PJH  20-Mar-87	Fix B.READ/B.SPEC mapping, Remove old code in ERRLOG
;  094	PJH  05-May-87	Fix 093 for mapping in magtape calls
;
;			[RSTS V9.5]
;  095	PJH  03-Jun-87	Fix message displayed on autorestart (T9.4-05 patch)
;  096  VAM  09-Jun-87	Check for Unibus memory on J11 CPUs.
;			Also, move INITOK message from INIONE to here.
;  099  DSD  17-Aug-87	Make QNA/LQA diags run when device is up to rev.
;  100  VAM  02-Sep-87	Add global ONETWO (a word containing [1,2]).
;
;			[RSTS V9.6]
;  097  KPH  13-Oct-87	Added .INCLUDEs
;			Added terminal driver conditional phases
;			Added symbols for dynamic KB DDB creation
;			Always use 22-bit addressing when using MMU
;			Remove lowcore setup from jam list
;			Changes for large jam list support
;  098  KPH  02-Nov-87	Add LAT conditional phases
;  101  WRM  01-Dec-87	Source merge V9.5 into V9.6
;  102  VAM  26-Jan-88	Add routines FSZBOT and VBCHK for reboot with
;			full autosize.
;  103	FEK  06-Nov-87	Add the KXJ11 device packet
;  104  DSD  20-Jan-88	Add conditional NODVR phase
;  105	PJH  08-Feb-88	Fix sign extend problem with ..DSEG
;  106	PJH  02-Mar-88	Globalize LAT control area and DYNKBN in DEFBUF
;  107	PJH  22-Mar-88	Fix UPDATE flag setting in dialogue routine
;  108	KCG  02-Jun-88	Don't clear PMG bits in BCSR for KDJ11-B CPUs.
;
;			[RSTS V9.7]
;  109	KCG  16-Nov-88	Add symbol for OV2 phase.
;  110	DRP  29-Dec-88	Add KBX conditional phase support
;  111	BGN  23-Jan-89	Modify SAVRES help
;  112  VAM  25-Jan-89	Look for new SIL name in CONFIG.SYS during START.
;  113  VAM  22-Feb-89	Enable Control-C during auto-START of SYSGEN.SIL so
;			that customer can get to HARDWR if necesssary.
;  114  JRM  20-Mar-89  Add CLNDBG (debug mode flag)
;  115  VAM  20-May-89	Add XA (DR11/DRV11) device packet
;
;			[RSTS V10.0]
;  116	DSD  31-May-89	Add NO device symbols
;  117	FEK  21-Mar-90	Add KDJ11-E TOY clock, header dumping, & other stuff
;  118  VAM  21-May-90	Add J11LTS (status of special J-11 null job)
;  119  VAM  08-Aug-90	Fix XA.PKT to correct number of addresses
;
;			[RSTS V10.1]
;  120	FEK  15-May-91	Add ^T label, J-11 clock CSR check, and XV packet
;  121  VAM  16-Aug-91	Remove explicit definition of MU.MAX (it's been
;			moved to MSCPDF).
;  122	FEK  30-Oct-91	Enhance check for J-11 clock change CSR (120 above).
;  123	FEK  30-Dec-91	Allow ONLCLN to try and clean SY0:
;-

ROOT$L	  =	1		; List INIT's prefix file

.SBTTL	Define Root macros
.SBTTL	Device packet format

; Each device supported by RSTS has a packet of information in DEVTBL
; and a list of bus addresses in CSRTBL
;
; Packet format for controller type "xx":
;
; xx.PKT:
;	!---------------------------------------------------------------!
;	!			PK.FLG	!			PK.MXU	!
;	!      Device flags		!  Max units on controller	!  0
;	!				!				!
;	!---------------------------------------------------------------!
;	!							PK.CSO	!
;	! Offset into tables organized per unit (CSRTBL, VECTBL,TYPTBL)	!  2
;	!			(value is xx.CSO)			!
;	!-------------------------------!-------------------------------!
;	!			PK.NUN	!			PK.SIZ	!
;     5	!	Number of subunits	!	Size of CSR set on	!  4
;	!	  per controller	!	   the I/O page		!
;	!-------------------------------!-------------------------------!
;	!			PK.PRI	!			PK.OFF	!
;     7	!	 Device priority	!    Offset to major register	!  6
;	!	    and flags		!	    in CSR set		!
;	!-------------------------------!-------------------------------!
;	!							PK.NAM	!
;	!		    Controller name in ASCII			! 10
;	!								!
;	!---------------------------------------------------------------!
;								PK.XXX
;
; PK.FLG byte layout:
;
;        7        6        5        4        3        2        1        0
;   !-----------------------------------------------------------------------!
;   !        !        ! PS.EVC ! PS.GPK ! PS.FLT ! PS.FIX ! PS.PVC ! PS.2VC !
;   !        !        !        !        !        !        !        !        !
;   ! resv'd ! resv'd ! Extra  ! GPK-bus! 2nd-nth!1ST CSR !Program-! Has 2  !
;   !        !        ! vector ! device !  CSRs  ! always ! mable  ! vectors!
;   !        !        !        !        !  float ! fixed  ! vector !        !
;   !-----------------------------------------------------------------------!
;
;
; PK.PRI byte layout:
;
;        7        6        5        4        3        2        1        0
;   !-----------------------------------------------------------------------!
;   ! PS.XBF !      PS.PRI     ! PS.BAE ! PS.UWN !          PS.NUW          !
;   !        !        !        !        !        !        !        !        !
;   !Requires! Device priority ! Has BAE!Requires! Number of UNIBUS windows !
;   ! mapped !  & 140 (PRI>=4) !register! UNIBUS ! minus 1 (1 to 8 windows) !
;   !  XBUF  !        !        ! (RH11) ! windows!   (ignored if PS.UWN=0)  !
;   !-----------------------------------------------------------------------!

.SBTTL	DEVDEF - Macro to build DEVTBL and CSRTBL

; Define DEVTBL and CSRTBL
;
; Macro DEVTBL arguments:
;
;	NM	2-character controller name
;	MAXU	Maximum number of controllers
;	BUSZ	Size of CSR set on I/O page
;	BA1	Starting controller address (0 if float, 2nd address if BA0)
;		or base for nth-last sequential if BA0 contains more than 1 CSR
;	BA0	Address of first controller if 1st not sequential with 2nd-nth
;	OFF	Offset in CSR set to most frequently used register
;	VEC2	'2VEC' if 2 vectors (terminals, etc.)
;		'PVEC' if programmable vectors (e.g. UDA50)
;	NUN	Number of units per controller
;	P	Interrupt priority of controller
;	GPK	'GPK' if device is for GPK only				;092
;
; Macro generates packet in DEVTBL
;	and loads the setup table 'CSRDEC' (in SATBUF)
;	with initial assumed values for controller addresses
;
; xx.CSO is an offset for 1st controller into CSRTBL and VECTBL for device "xx"
;
; If BA0 is non-blank, and BA1 = 0 then the label xx.CS2 will point 
;	to CSRTBL at the 2nd controller's entry (xx.CSO+2).  PS.FIX and PS.FLT
;	flags will be set in the PK.FLG byte.
; 
; If BA0 is blank, and BA1 = 0 then just the PS.FLT flag is set in PK.FLG
;
; If both BA0 and BA1 are non-blank then just the PS.FIX flag is set in PK.FLG
; 
;			PS.FLT - PS.FIX    (Bits 3 and 2 of the PK.FLG byte)
;			  0        1    -> All CSRs for the device are fixed
;			  1        0    -> All CSRs for the device float
;			  1        1    -> 1st CSR is fixed, 2nd -Nth float
;
; CT (Gpk) devices use these fields somewhat differently, since some	;092
; of them are not fixed, but not floating in the normal sense of the	;092
; word either.  Instead, a CT peripheral can live in any of the 6 	;092
; backplane slots, with the address defined by the slot it lives in.	;092
; To tell them apart, each has a device code in the first CSR, which	;092
; uniquely identifies the controller.					;092
; CT devices of this type have the type code in BA0, 0 in BA1, and	;092
; PS.FLG set.  Other CT devices (those with fixed CSR assignments) have	;092
; the CSR in BA1 as usual, with BA0 blank and PS.FIX set in PK.FLG.	;092
;
; Symbol xx.MAX: = MAXU for all disk devices with support of multi-controllers
;
; Note that CSR address are always kept as the lowest responding
;	address on the I/O page

.MACRO	DEVDEF	NM,MAXU,BUSZ,BA1,BA0,OFF,VEC2,NUN,P,GPK			;092
.DSABL	CRF
	TMPORG	SATBUF
.DSABL	CRF	;1. DEVDEF MACRO - ALLOCATE & LOAD CSRDEC TABLE
NM'.CSO	== .-CSRDEC
$$$	= .								;086
$$	= MAXU
.IF NB	<GPK>								;092
 .IF NB	<BA0>								;092
$	=	BA0							;092
.REPT	MAXU								;092
	 .WORD	$		; Fixed CSR				;092
$	=	$ + BUSZ						;092
.ENDR									;092
 .IFF									;092
	 .BLKW0	MAXU,BA1	; Slot ID for movable option		;092
 .ENDC	;BA0								;092
.IFF	;GPK								;092
.IF NB	<BA0>								;086
	 .WORD	BA0		; FIRST BUS ADDRESS
 .IF EQ	 BA1
  .IF GT MAXU-1
NM'.CS2	== .-CSRDEC-<<.-$$$>-2>	; OFFSET INTO CSRTBL AT ALT. BUS ADDRESS ;086
  .ENDC
 .ENDC
$$	= MAXU-<<.-$$$>/2>						;086
.ENDC
$	= BA1
.IRP	NREP,<\$$>
.REPT	$$
.IF EQ	$$-1
 .IRP	TMPTAG,<\$>
	  .WORD	TMPTAG		; BUS ADDRESS
 .ENDM
.IFF
 .IF EQ	BA1
	  .WORD	0		; NREP WORDS OF 0 (FLOAT OR NONE)
 .IFF
  .IRP	TMPTAG,<\$>
	  .WORD	TMPTAG		; NREP BUS ADDRESSES IN STEPS OF BUSZ
  .ENDM
 .ENDC
.ENDC
.NLIST	MEB
.IIF NE BA1,	$	= $+BUSZ
.ENDR
.ENDM
.ENDC	;GPK								;092-
.LIST	MEB
	UNORG
.LIST

.NLIST		;2. DEVDEF MACRO - BUILD DEVICE PACKETS
NM'.PKT::	 .BYTE	MAXU		;  MAXIMUM # OF UNITS
TMPTAG	= 0
.IF NB	 <GPK>								;092
	TMPTAG	= PS.GPK						;092
.IF B	 <BA0>								;092
	TMPTAG	= TMPTAG!PS.FIX						;092
.IFF									;092
	TMPTAG	= TMPTAG!PS.FLT						;092
.ENDC	;BA0								;092
.IIF IDN <VEC2>,<2VEC>,	TMPTAG	= TMPTAG!PS.2VC				;092
.IIF IDN <VEC2>,<EVEC>,	TMPTAG	= TMPTAG!PS.EVC				;092
.IFF	;GPK								;092
.IIF IDN <VEC2>,<2VEC>,	TMPTAG	= PS.2VC                                    
.IIF IDN <VEC2>,<PVEC>,	TMPTAG	= PS.PVC
.IIF NB  <BA0>,		TMPTAG	= TMPTAG!PS.FIX				;024
.IIF NE  <BA1>,		TMPTAG	= TMPTAG!PS.FLT				;024
.ENDC	;GPK								;092
	.BYTE	TMPTAG		;   DEVICE FLAGS
	 .WORD	NM'.CSO		;    OFFSET INTO CSRTBL OR CSRDEC
.IF LT	BUSZ
	 .BYTE	-BUSZ		;     SIZE OF CSR SET
.IFF
	 .BYTE	BUSZ		;     SIZE OF CSR SET
.ENDC
	 .BYTE	NUN		;      NUMBER OF UNITS CONTROLLED
	 .BYTE	OFF+0		;       OFFSET OF MAJOR REGISTER
	 .BYTE	PS.PRI&PR'P	;        DEVICE HARDWARE PRIORITY
	 .WORD	"NM		;         NAME OF DEVICE
.ENABL	CRF


.LIST
.NLIST		;3. DEVDEF MACRO - CREATE DISK xx.MAX symbols
.IF	NDF	DSKEND		
$	=0
.IRPC	X,<'NM>
    .IF	EQ	$
    $	=1	;SET A 1ST TIME SWITCH TO IGNORE THE "R"
    .IFF
   .LIST
D'X'.UNC	==	NUN*MAXU
	.IF	GT	MAXU-1
D'X'.MAX	==	MAXU
	.ENDC
    .ENDC
    .NLIST
.ENDM
.ENDC
.LIST
.NLIST
.ENDM	DEVDEF

; MACRO TO ROUND A CSECT TO A MULTIPLE OF 1 BLOCK
.MACRO	ROUND	CS
	TMPORG	CS
.LIST
SZ.'CS	= <.-CS+777>/1000	;COMPUTE # OF BLOCKS (ROUNDED UP)
SIZ'CS	== 1000*SZ.'CS		;COMPUTE ACTUAL SIZE
.NLIST
.	= SIZ'CS+CS	;GO TO THE END
	UNORG
.ENDM	ROUND

.MACRO	I.MESS
	TMPORG	ROOTXT
.NLIST	BEX
.ENDM	I.MESS

.SBTTL	Order the CSECTs in memory

	DEFORG	ROOT		; Root code
	DEFORG	ROOTBL		; Root code tables & FIP tables (pure)
	DEFORG	ERRTBL		; Error logging table
	DEFORG	DUDINT		; Interrupt save area for UDA devices
	DEFORG	BUFCTL		; BUFFER CTL  area for magtapes
	DEFORG	BGBUFR		; BIG BUFFER CTL  area for magtapes
	DEFORG	ROOOPT		; Option dispatch
	DEFORG	ROOOTX		; Option name text
	DEFORG	ROOTXT		; Root text
	DEFORG	ROOIMP		; Root code tables & FIP tables (impure)
	DEFORG	ROOCTL		; Root scratch area (impure)
	DEFORG	L3QPAR		; Level 3 emulation mapping table
	DEFORG	L3QTBL		; Level 3 emulation dispatch table
	DEFORG	BBRDSP		; BBR dispatch table.			;023
	ORG	STACOM		; START option communications area (impure) ;025
	ORG	SRROO		; SAV/REStore root data (impure)
	ORG	SRODAT		; SAV/REStore SAVE data (impure)
	ORG	SROADR		; SAV/REStore context save (impure)
	ORG	FIP		; FIP code
	ORG	FIPTXT		; FIP error text
	ORG	SILNDX		; SIL Index load/verify routine		;025
	ORG	JAMCOD		; Jamlist-build code, for START overlays ;025
	DEFORG	PATCH		; Patch space
	.BLKW	100		; 64. words is plenty
	DEFORG	CFGBUF		; Buffer for CONFIG.SYS info.		;112
	 .BLKW	CFGSIZ		; Only make it as large as necessary.	;112

; The following sections are aligned on 1000 boundaries by rounding PATCH

	DEFORG	FIBUF		; FIP buffer (& one-shot text)
	DEFORG	SILBUF		; Buffer for SIL index (& more one-shot text)
	DEFORG	SATBUF		; SAT buffer
	DEFORG	INSBUF		; INSTALL buffer (including SET table)
	DEFORG	DEFBUF		; DEFAULT buffer (from the SIL, if any)
	DEFORG	DCNLST		; DCN's for INIT.SYS on a SAV/RES disk
	.BLKW	3*256.		; Room for all DCN's for INIT.SYS

; The following global is used to indicate each use of the RNDAPR macro
PHZRNG	==:	0

.SBTTL	LOAD THE ASECT

.ASECT

.	= 60

	.WORD	DEVTBL		; 60 DEVTBL
	.WORD	CSRTBL		; 62 CSRTBL
	.WORD	VECTBL		; 64 VECTBL
	.WORD	TYPTBL		; 66 TYPTBL
	.WORD	HWTABL		; 70 HWTABL
	.WORD	SILNAM		; 72 SILNAM
	.WORD	DSKSZL		; 74 DSKSZL
	.WORD	DSKSZM		; 76 DSKSZM
	.WORD	DSKDCS		;100 DSKDCS
	.WORD	DSKMID		;102 DSKMID
	.WORD	1		;104 BOOTSTRAPS  (BOOTS OBSOLETE)
	.WORD	DCNLST		;106 DCNLST

.	= 1000
DATE:	.WORD	0		;1000 RSTS/E DATE WORD
TIME:	.WORD	0		;1002 RSTS/E TIME WORD
I.SEC::
TIMSEC:	.WORD	0		;1004 RSTS/E SECONDS TO NEXT MINUTE
	.WORD	0		;1006 JOB RUNNING NOW/NEXT JOB TO RUN
	.WORD	JUNK		;1010 POINTER TO JOB DATA BLOCK
	.WORD	JUNK		;1012 POINTER TO CURRENT FLAGS (JDB @ JDFLG)
	.WORD	JUNK		;1014 POINTER TO CURRENT I/O STATUS
	.WORD	JUNK		;1016 POINTER TO JOB'S WORK BLOCK
	.WORD	JUNK		;1020 POINTER TO JOB'S SECOND JOB DATA BLOCK
	.WORD	JUNK		;1022 POINTER TO JOB'S RUN TIME SYSTEM
	.WORD	JUNK		;1024 POINTER TO CURRENT CPU TIME BUCKET

.SBTTL	SATBUF:	START-UP TABLES
.SBTTL		CSRDEC:	STANDARD CSR LOCATIONS
.SBTTL	ROOTBL:	ROOT TABLE DEFINITIONS (READ-ONLY)

	ORG	ROOTBL

.SBTTL		DEVTBL:	PROTOTYPE CSR INFORMATION

; GENERATE THE CSR TABLES
;	NOTE: TT MUST BE FIRST, FOLLOWED BY DISKS, THEN MT, MM, DT

	TMPORG	SATBUF		;PUT DEC CSR TABLE IN THE 1-SHOT CODE

CSRDEC::

	UNORG

DEVTBL::

;      NAME   SIZE      1ST CSR    VEC     PRIORITY
;	  MAXU      CSR       OFFSET    SUBL
DEVDEF	TT, 1.,10,177560,      ,  ,2VEC, 1.,4	;CONSOLE TERMINAL
DEVDEF	RV, 1., 0,     0,      , 0,    , 1.,5	;Virtual Disk "DV"

DEVDEF	RF, 1.,20,177460,      ,  ,    , 1.,5!PS.UWN!7	;RF11 FIXED HEAD DISK
DEVDEF	RS, 1.,40,172040,      ,  ,    , 8.,5!PS.BAE!PS.UWN!7 ;RS03/RS04 DISK
DEVDEF	RK, 1.,20,177400,      , 4,    , 8.,5!PS.UWN!7	;RK11 DISK
DEVDEF	RL, 1.,10,174400,      ,  ,    , 4.,5!PS.UWN!1	;RL11 DISK
RL.GCS==RL.CSO	;OFFSET INTO CSRTBL OR CSRDEC FOR RLCS
;NOTE:  If the system is Q22, the 'size of CSR set' and PS.UWN bit for the
;       RL11 disk are changed in the SATBUF one-shot setup code.  The
;       following two equates define offsets used in changing those values.
RL.SCS=4	;OFFSET FOR 'SIZE OF CSR SET'
RL.DHP=7	;OFFSET FOR DEVICE HARDWARE PRIORITY


DEVDEF	RM, 1.,40,177440,      ,  ,    , 8.,5!PS.UWN!7	;RK06/RK07 DISK
DEVDEF	RP, 1.,40,176700,      ,14,    , 8.,5!PS.UWN!7	;RP11C DISK
DEVDEF	RB, 1.,54,176700,      ,  ,    , 8.,5!PS.BAE!PS.UWN!7 ;RP04/5/6 DISK
DEVDEF	RR, 1.,54,176300,      ,  ,    , 8.,5!PS.BAE!PS.UWN!7 ;RM02/3/5/80/RP07 DISK


DEVDEF	RZ, 1.,200,     0,GPK$DZ,  ,EVEC, 2.,5,	GPK	;GPK floppy	;092
DEVDEF	RW, 1.,200,     0,GPK$DW,  ,EVEC, 1.,5,	GPK	;GPK hard disk	;092
DEVDEF	RU, 4.,04,     0,172150,  ,PVEC, 4.,5!PS.UWN!7  ;UDA - RA80 DISK
;+									;121
; NOTE: The symbol DU.MAX, defined here when the DEVDEF RU above is	;121
; expanded at assembly time, is also explicitly defined in MSCPDF.MAC.	;121
;-									;121

DSKEND::			;LAST DISK ENTRY

DEVDEF	MU, 4.,04,     0,174500,  ,PVEC, 1.,5!PS.UWN!7	;TMSCP TAPES	;086
.ASSUME	MU.CSO	EQ <RU.CSO+<DU.MAX*2>>	;TMSCP devices MUST follow MSCP	;050

MU.UNC	==	4.							;086


DEVDEF	TS, 8., 4,172520,      , 2,    , 1.,5!PS.UWN!3	;TS11 MAGTAPE
DEVDEF	TM, 1.,20,172520,      , 2,    , 8.,5!PS.UWN!3	;TM11 MAGTAPE
DEVDEF	TU, 1.,40,172440,      ,  ,    , 8.,5!PS.BAE!PS.UWN!3 ;TU/TE16 MAGTAPE
TAPEND::			;LAST TAPE ENTRY
DEVDEF	TC, 1.,20,177340,      , 2,    , 8.,6	;TC11 DECTAPE		;050


DEVDEF	PR, 8., 4,     0,177550,  ,    , 1.,4	;PAPER TAPE READER
DEVDEF	PP, 8., 4,     0,177554,  ,    , 1.,4	;PAPER TAPE PUNCH
DEVDEF	LP, 8.,10,164004,177514,  ,    , 1.,4	;LINE PRINTER
DEVDEF	RX, 4.,10,     0,177170,  ,    , 2.,5!PS.UWN!0 ;RX11 FLOPPY DISK


DEVDEF	CR, 8.,10,     0,177160,  ,    , 1.,6	;CR11/CM11 CARD READER
DEVDEF	CD, 8.,10,     0,     0,  ,    , 1.,4	;CD11 CARD READER
DEVDEF	KL,16.,10,176500,      ,  ,2VEC, 1.,5	;KL11/LC11/DL11A/DL11B SINGLE LINE INTERFACE
DEVDEF	DL,31.,10,175610,      ,  ,2VEC, 1.,5	;DL11C/DL11D SINGLE LINE INTERFACE


DEVDEF	DE,31.,10,     0,      ,  ,2VEC, 1.,5	;DL11E SINGLE LINE INTERFACE
DEVDEF	DD,4. ,10,     0,      ,  ,2VEC, 2.,5	;TU58 TAPE DRIVE (DECTAPE II)
DEVDEF	DC, 2.,10,174000,      ,  ,2VEC, 1.,5	;DC11 SINGLE LINE MODEM INTERFACE
DEVDEF	DP, 2.,-10,174770,     ,  ,2VEC, 1.,6	;DP11 SYNCHRONOUS LINE INTERFACE (2780)
;DC should be 32., and DP should be 16.  This was reduced to make INIT fit.
;+      
;050
;NOTE:  The number of DP11 devices has been reduced from 31. to 16., this
;       was done to eliminated a bunch of sort out code since a lot of new
;       devices are found in the DP17-31 range
;-


DEVDEF	XN, 8., 2,175200,      ,  ,    , 1.,4	;DN11 AUTOMATIC CALLING UNIT INTERFACE
DEVDEF	BS, 4., 2,177420,      ,  ,    , 1.,0	;DT07 BUS SWITCH	;091
DEVDEF	KG, 8.,10,170700,      ,  ,    , 1.,0	;KG11 CRC ARITHMETIC (2780)
DEVDEF	KJ, 4.,40,175400,      ,  ,PVEC, 1.,5	;KXJ11-CR IOP		;103


DEVDEF	XA,16.,10,     0,172410, 4,    , 1.,5	;DR11 Parallel DMA	;120
DEVDEF	DM,16.,10,170500,      ,  ,    ,16.,5	;DM11-BB MODEM CONTROL
DEVDEF	DJ,16.,10,     0,      ,  ,2VEC,16.,5	;DJ11 16 LINE MULTIPLEXER


DEVDEF	DH,16.,20,     0,      ,  ,2VEC,16.,5	;DH11 16-LINE MULTIPLEXOR 
DEVDEF	DU,16.,10,     0,      ,  ,2VEC, 1.,6	;DU11 SINGLE LINE SYNCH INTERFACE (2780)
; There are many places that depend on D1: coming immediatly after DU:
;	so don't change this order (unless you fix them all first)
DEVDEF	D1,16.,10,     0,      ,  ,2VEC, 1.,6	;DUP11 SINGLE LINE SYNCH INTERFACE (2780)

DEVDEF	XM,16.,10,     0,      ,  ,2VEC, 1.,5!PS.XBF	;DMC11 SYNCHRONOUS LINE INTERFACE
DMRFLG	==	000200


DEVDEF	DZ,16.,10,     0,      ,  ,2VEC, 8.,5	;DZ11 8-LINE MULTIPLEXOR
DEVDEF	XK,16.,10,     0,      ,  ,2VEC, 1.,5!PS.XBF    ;KMC11 MICROPROCESSOR
DEVDEF	XV, 4.,10,     0,      , 4,2VEC, 1.,5	;DPV sync line interface    ;120
DEVDEF	XD,16.,10,     0,      ,  ,2VEC,32.,5!PS.XBF;DMP/DMV SYNC MICRO
DMPSZ	==	10				;DMP CSR SET SIZE, USES XD.PKT
DMPNU	==	32.				;DMP MAX # UNITS CONTROLLED
DMVSZ	==	20				;DMV CSR SET SIZE, USES XD.PKT
DMVNU	==	12.				;DMV MAX # UNITS CONTROLLED
DMVFLG	==	000200				;DMV BIT OF THE XD DDB FLAG 
X3.CSO	==	XD.CSO				;DMV uses same table entries


DEVDEF	VH,16.,20,     0,      ,  ,2VEC,16.,5	;DHV11/DHU11 8/16 line MUX. ;028
DEVDEF	XE, 4.,10,     0,174510,  ,    , 1.,5!PS.XBF		;DEUNA LINK ;067
MAX.XE	=:	4			;Local definition for ROOT	;086

DEVDEF	XH, 4.,20,174520,<174440,174460>,16,PVEC, 1.,5!PS.XBF	;DEQNA link ;086
MAX.XH	==:	4			;Global definition for INISTA	;086

DEVDEF	NO, 1., 0,     0,      ,  ,    , 1.,5	;Async DDCMP device	;116

                      
DEVDEF	PI, 1.,200,     0,GPK$PI,  ,2VEC, 5.,5,	GPK	;GPK disp control ;092
DEVDEF	LK, 1.,200,173500,      ,  ,2VEC, 1.,5,	GPK	;GPK keyboard	  ;092
DEVDEF	PC, 1.,200,173400,      ,  ,2VEC, 1.,5,	GPK	;GPK printer ctl  ;092
DEVDEF	XT, 1.,200,173300,      ,  ,2VEC, 1.,5,	GPK	;GPK comm port	  ;092
..XTMX	==	XT.PKT+PK.NUN	;**Patch** for 2-channel comm port	  ;092

	.WORD	0		;END THE DEVTBL


	TMPORG	SATBUF		;CALCULATE NUMBER OF CSR'S IN TABLE
CSRTBS	= <.-CSRDEC>/2
	UNORG

; CHECK THAT THE CSR'S ARE SET UP RIGHT FOR DISKS
.DSABL	CRF
$DISKS
$	= 0			;LOOP FOR SECOND CHARACTER
	.IRPC	X,<NAME>	;LOOP ON DISK NAME (D?)
		.IF EQ	$	;IF FIRST CHARACTER (D), SET A FLAG
			$	= 1
		.IFF		;ELSE CHECK FOR ORDERING
			.IF NE <<R'X'.PKT-RV.PKT>/PKTSIZ>*2-IDX$'NAME
				.ERROR	;DISK NAME OUT OF ORDER IN DEVTBL
			.ENDC
		.ENDC
	.ENDM			;END OF LOOP ON 2-CHARACTER DISK NAME
.ENDM				;END OF LOOP ON DISK TYPE
.ENABL	CRF

GLOBAL	<DM.CSO,HERTZ>

.SBTTL	ROOTBL:	DDCMP CONTROLLER TYPE FLAGS

	$DDCMP		
NAME'.TYP::.WORD	0	;FLAG FOR NAME'[0:15] CONTROLLER TYPE
.ENDM

.SBTTL	ROOTBL:	DSKSZL, DSKSZM, DSKDCS, DSKNAM: FIXED POINTERS

; POINTERS AND OTHER FIXED DATA FOR DISK CONTROL

DSKSZL::$DISKS		;DISK SIZE TABLE POINTERS (LSB) [FIXED]
	.WORD	NAME'$SZL		;NAME DISK LSB SIZE TABLE POINTER
.ENDM
	.WORD	BT$SZL		;Boot driver has "infinite" size

DSKSZM::$DISKS		;DISK SIZE TABLE POINTERS (MSB) [FIXED]
	.WORD	NAME'$SZM		;NAME DISK MSB SIZE TABLE POINTER
.ENDM
	.WORD	BT$SZM		;Boot driver has "infinite" size

DSKDCS::$DISKS		;DEVICE CLUSTER TABLE POINTERS [FIXED]
	.WORD	NAME'$DCS		;NAME DISK DCS TABLE
.ENDM
	.WORD	BT$DCS		;Boot device clustersize




DSKMID::$DISKS		;MASSBUS/UNIT ID TABLE POINTERS [FIXED]
	.WORD	NAME'$MID		;NAME DISK ID TABLE
.ENDM

BOONAM::
	$TAPES
	.WORD	"NAME
.ENDM
DSKNAM::$DISKS			;DISK NAMES IN ASCII [FIXED]
  .IF	IDN	<NAME>,<DV>
	.WORD	-1.
  .IFF
	.WORD	"NAME
  .ENDC
.ENDM
BTDNAM:	.WORD	"XX		;Booted device's name
	.WORD	0		;ENDS WITH 0

	$TAPES		;POINTERS TO NUMBER OF UNITS PER TAPE TYPE
	.WORD	<<IDX$DB/2>*PKTSIZ>+RV.PKT+PK.NUN 	;SAME NUMBER AS DB
.ENDM

SUBUNT::$DISKS		;POINTERS TO NUMBER OF UNITS PER DISK TYPE
.IF	DF	'NAME'.MAX
	.WORD	'NAME'UNTS
.IFF
	.WORD	<<IDX$'NAME/2>*PKTSIZ>+RV.PKT+PK.NUN
.ENDC
.ENDM

	$DISKS
.IF	DF	'NAME'.MAX
'NAME'UNTS:	.BYTE	'NAME'.UNC
.ENDC
.ENDM
.EVEN


.SBTTL		MISC. FIXED POINTERS

DPAR6::	.WORD	KISAR6		;D-SPACE APR 6 VALUE  (INIT USES ONLY I SPACE)

.SBTTL		BITBYT:	BITS WITHIN BYTE

BITBYT::.BYTE	1,2,4,10,20,40,100,200,0
	.EVEN

.SBTTL		BITWRD: BITS WITHIN WORD

BITWRD::.WORD	1,2,4,10,20,40,100,200
	.WORD	400,1000,2000,4000,10000,20000,40000,100000,0

ONETWO::.WORD	<1*400>+2		; A word containing [1,2].	;100

.SBTTL		PROTOTYPE BAE TABLE

	TMPORG	SATBUF

BAEOFF::.WORD	50,"RB
	.WORD	30,"RS
	.WORD	34,"TU
	.WORD	50,"RR
	.WORD	0		;END MARKER
	.BLKW0	4		;TWO PATCH SPACES

	UNORG

.SBTTL		OPTLST:	OPTION LIST

.SBTTL	ROOTXT:	HELPMS:	HELP MESSAGE TEXT

.MACRO	OPTION	DSP,N1,N2,DESC
.IF NB	<DESC>
	I.MESS
	 .ASCII	<11>"N1'N2"<11>"DESC"<200>
	UNORG
.ENDC
	TMPORG	ROOOPT
	 .WORD	DSP
.GLOBL	DSP
	TMPORG	ROOOTX
	 UNQTXT	<N1\N2>
	UNORG
.ENDM	OPTION

	I.MESS
HELPMS:	.ASCII	<12>"The valid RSTS initialization options are:"<200>
	UNORG

OPTLST:	OPTION	DSKINT,DS,KINT,<Initialize disk to RSTS file structure>
	OPTION	COPY  ,CO,PY  ,<Copy minimal system to disk>
	OPTION	INIPAT,PA,TCH ,<Patch a file>
	OPTION	HARDWR,HA,RDWR,<Set controller characteristics>
	OPTION	HARDWR,HA,RDWARE
	OPTION	INSTAL,IN,STALL		;,<Install a monitor SIL>	;044
	OPTION	REFRSH,RE,FRESH,<Manipulate files in [0,1]>
	OPTION	DEFALT,DE,FAULT,<Set monitor defaults>
				;SET option removed			;059

	OPTION	START0,ST,ART ,<Start timesharing, showing list of disabled devices> ;076
	I.MESS
	 .ASCII	<11>"<CR>"<11>"Start timesharing"<200>			;076
	UNORG
	OPTION	BOOT  ,BO,OT  ,<Bootstrap a device>
	OPTION	SRDIAL,SA,VRES,<RESTORE SAVRES saveset. To create recovery medium use RECOVR.COM> ;111
	OPTION	IDNTFY,ID,ENT ,<Display version of INIT and installed SIL>
	OPTION	REDATE,DA,TE  ,<Reset Date and Time>
	OPTION	HELP  ,HE,LP  ,<Type this HELP message>
	OPTION	OPTODT,OD,T
	OPTION	LOAD  ,LO,AD
	OPTION	FILL  ,FI,LL
	OPTION	WBOOT ,WB,OOT
	OPTION	WBOOT ,WR,ITEBOOT

	I.MESS			;CLOSE OUT THE HELP MESSAGE
	 .ASCIZ	"Only the first two characters need be typed."<200>

	TMPORG	ROOOPT
	 .WORD	ILLOPT		;CATCH ILLEGAL OPTIONS

	TMPORG	ROOOTX
	 .BYTE	0		;END OPTION TEXT

.SBTTL		LOGO:	HEADER LOGO TEXT

	I.MESS
LOGO::	.ASCII	<176><176>"RSTS "	;Space for "u/"			;092
SDCFLG::.ASCII	"V"		;Patched to V for SDC, T for fieldtest	;092
	.IIF	NE,<SYSVEL&177>-'0,.ASCII	<SYSVEL&177>
	.ASCII	<SYSVEL/400&177><SYSVEE&177><SYSVEE/400&177>
	.BYTE	0		;LOGO IS ASCIZ
	.EVEN

ILOGO::	.ASCIZ	" (??"<176><176>") " ;Filled in by INIONE

	UNORG

.SBTTL	ROOIMP:	ROOT TABLE DEFINITIONS (IMPURE TABLES)
.SBTTL		CONTROL INFORMATION & STACK

ES.CNT	=	6		;NUMBER OF ITEMS OF STACK TO SAVE ON ERROR

	ORG	ROOIMP
I.TKS::	.WORD	0		;LOCATION OF CONSOLE TERMINAL
ERRCTR::.WORD	0		;ERROR COUNTER
CC.DBL::.WORD	0		;<>0 IF ^C DISABLED
CTLCGO::.WORD	I.INI0		;WHERE TO GO IF ^C IS TYPED
XXXTRP:	.WORD	0		;<>0 IF IN TRAP HANDLING SEQUENCE
UNXVEC:	.WORD	0		;VECTOR LOCATION OF UNEXPECTED TRAP
ERRPC:	.WORD	0		;PC OF UNEXPECTED TRAP OR ERF 
ERRPS:	.WORD	0		;PS OF UNEXPECTED TRAP OR ERF 
ERROV:	.WORD	0		;OVERLAY NUMBER OF ERF OR UNEXPECTED TRAP
ERRM5:	.WORD	0		;KERNAL ADDRESS PAGE REGISTER 5 OF TRAP
ERRM6:	.WORD	0		;KERNAL ADDRESS PAGE REGISTER 6 OF TRAP
ERRSP:	.WORD	0		;SP OF UNEXPECTED TRAP OR ERF 
ERRREG:	.BLKW0	6		;REGISTERS AFTER UNEXPECTED TRAP OR ERF
ERRSTA:	.BLKW0	ES.CNT		;SAVED STACK AFTER UNEXPECTED TRAP OR ERF
JUNK::	.WORD	0		;FILLED IN WITH JUNK
COINDX::.WORD	0		;Save index of disk being DSKINTed	;035
				;<> means system INSTAL in progress	;037
COUNIT::.WORD	0		;Save unit of disk being DSKINTed	;035
DSKREV::.WORD	0		;Rev level of booted disk		;044
				;
UPDATE::.BYTE	0		;<> means UPDATE in progress (supersede);037
GOSWIT::.BYTE	0		;<>0 IF START-UP CODE IS COMPLETE
	.EVEN			;Next two cells must be word aligned	;078
MICRO::	.BYTE	0		;-1 if Micro/RSTS			;078
RODISK::.BYTE	0		;-1 if booted from a Read-Only Disk	;078
.ASSUME	RODISK EQ <MICRO+1>	;RODISK must follow MICRO		;078
AUTOIN::.BYTE	0		;<0 IF auto-INSTAL in progress		;026
AUTOST::.BYTE	0		;<0 IF auto- START is in progress	;026
AUTOQS::.BYTE	0		;<0 IF AUTO-RESTART IN PROGRESS
				;>0 IF <LF> (FAST) START
				;=0 IF NORMAL START
SAVDEV::.BYTE	0		;<>0 IF BOOTED OFF A SAV/RES DISK
NRSTSD::.BYTE	0		;<> IF FIP I/O WAS ATTEMPTED TO NON-RSTS DISK
	.EVEN
;	Virtual address for DISK phase, extracted from $OTABL built by RT link
JDISK:	.WORD	0		;Addr of disk I/O routine (PDISK) in INIDSK.
JXRSET:	.WORD	0		;Addr of disk resetter (PXRSET) in INIDSK.
JTRSET:	.WORD	0		;Addr of tape resetter (??????) in INIDSK.
JMAGIO:	.WORD	0		;Addr of tape I/O routine (PMAGIO) in INIDSK.
JMGSPC:	.WORD	0		;Addr of tape .SPEC routine (PMGSPC) in INIDSK.
JERRLG:	.WORD	0		;Addr of error log routine (PERRLG) in INIDSK.
JRTI3:	.WORD	0		;Address of the RTI3 routine in INIDSK.	;054
;	Virtual address for MSCP phase, extracted from $OTABL built by RT link
;	These addresses are used by the common disk handler to do mapped calls
JQDSDU::.WORD	0		;ADDRESS OF QDS$DU ENTRY
JINTDU::.WORD	0		;Address of INT$PH entry (for MSCP)	;087
JTMODU::.WORD	0		;Address of TMO$PH entry (for MSCP)	;087
JCONPH::.WORD	0		;ADDRESS OF [T]MSCP L3Q CON$ PROCESSING	;050
JASNMU::.WORD	0		;Address of ASN$MU entry		;050
JSPCMU::.WORD	0		;Address of SPC$MU entry		;050
JSERMU::.WORD	0		;Address of SER$MU entry		;050
JINTMU::.WORD	0		;Address of INT$MU entry		;050
JTMOMU::.WORD	0		;Address of TMO$MU entry		;050
JDNEMU::.WORD	0		;Address of DNE$MU entry		;048
JXHROM: .WORD	0		;Address of CITQNA entry		;086

;+
; Miscellaneous MSCP/BBR error logging information.  Must be in the
; ROOT to satisfy RT11 link requirements.
;
; 			*** NOTE ***
; DO NOT DISTURB THE ORDER OF THE MSCP ERROR LOG SAVE AREA	;022
;-
			;*** MSCP ERROR LOG SAVE AREAS ***	;022
MSCPPK::.BLKW		;MSCP PACKET SAVE AREA			;022
MSCPCS::.BLKW		;INTERNAL MSCP CONTROLLER STATUS WORD (C.STAT)	;022
MSCPUS::.BLKW		;INTERNAL MSCP UNIT STATUS WORD (U.STAT)	;022
MSCPER::.BLKW		;CLASS DRIVER ERROR CODE			;022
BBRFLG::.BLKW		;BBR FLAG WORD					;022
BADLBN::.BLKW	2	;LBN BEING REPLACED				;022
RBN::	.BLKW	2	;REPLACEMENT BLOCK NUMBER			;022
BADRBN::.BLKW	2	;RBN BEING REPLACED				;022
MSCPWC==<.-MSCPPK>/2	;***END MSCP ERROR LOG SAVE AREA ***		;022

DEVCLU::		;JUST RESOLVE THIS DURING INIT			;022
UNTSIZ::		;JUST RESOLVE THIS DURING INIT			;022
UNTERR::		;JUST RESOLVE THIS DURING INIT			;022

ERLPKT::RETURN		;RESOLVE ERROR LOG PACKET ROUTINE ADDR		;022

JODT:	.WORD	0		;Address of ODT's entry point (ODT+20)
SVPAR6:	.WORD	0,0		;APR6 save area for breakpoints
SVMMR0:	.WORD	0		;MMUSR0 save area for breakpoints
HIGHBF::.WORD	0		;DSQMAM FOR PARSEX I/O DURING SAV/RES
I.DATE::.WORD	0		;CURRENT DATE
I.TIME::.WORD	0		;CURRENT TIME
MAXWIN::.WORD	0		;NUMBER OF UMR'S NEEDED BY GREEDIEST DEVICE
DEV.UN::.WORD	0		;FOR SET OPTION, DEVICE UNIT #
XFERAD::.WORD	0		;For COPY option, transfer address of INIT
BOOTWC::.WORD	0		;Word count for GGBOOT/SAVRES
MSBSID::.WORD	0		;For COPY option, Massbus ID of unit
UQ$REV::.BLKW0	<MU.MAX+DU.MAX>	;[T]MSCP software and hardware rev level ;077
DTAFLG::.WORD	0		;<>0 if DECtape enabled			;046
SAVBOO::.BYTE	0		;<>0 IF NOT RUNNING FROM BOOTABLE MEDIA
BACKUP::.BYTE	0		;<>0 SAVE/RESTORE IN PROGRESS
JDATE:	.BYTE	0		;<>0 IF JUST GETTING A DATE FROM USER
VOLSWR::.BYTE	0		;<>0 IF AUTO-RESTART UNCONDITIONAL
AUTOGO::.BYTE	0		;<>0 to indicate streamline startup	;017
	.BYTE	0		;(RESERVED)
	.EVEN
	.BLKW	200		;STACK
I.STAK::

.SBTTL		FIP SCRATCH AREA

; FIP IMPURE AREA - NOT REWRITTEN TO DISK

; THE FOLLOWING PARAMETER WORDS ARE WORKING COPIES OF PERMANENT VALUES
; THEY ARE SET UP BY SETFIP AND SETDSK, BUT MAY BE MODIFIED (E.G. BY DSKINT)

; SYSTEM DISK SAT PARAMETERS

SATSYS::.WORD	0		;* + SEGS = # OF BLOCKS
	.WORD	0		;* + BYTS = # OF BYTES
	.WORD	0		;* + BITS = # OF BITS OR CLUSTER @PCS
SATSYN::.WORD	0		;# OF CLUSTERS OF SAT THAT ARE USEFUL

FIBIDX::			;FIBUF DISK INDEX SAME AS SYSTEM DISK INDEX
SYSNDX::.WORD	0		;SYSTEM DISK INDEX.
FIBUNT::			;FIBUF DISK UNIT NUMBER SAME AS SYS DISK
SYSUNT::.WORD	0		;SYSTEM DISK UNIT NUMBER
DCS::	.WORD	0		;SYSTEM DISK DEVICE CLUSTER SIZE
PCS::	.WORD	0		;SYSTEM DISK PACK CLUSTER SIZE
CLURAT::.WORD	0		;CLUSTER RATIO = PCS/DEVICE CLUSTER SIZE
BADFLG:	.WORD	0		;FILE BAD BLOCK FLAG FOR CLEAN
FIPFLG::.WORD	-1		;FLAG SAYING FIP AREA DIRTY (INITIALLY SET)

SETFP0::			;START OF FIP CLEARED AREA

FIBPHS::.WORD	0,0		;BLOCK NUMBER CURRENTLY IN 'FIBUF'

FIPCLU::.WORD	0		;CURRENT FILE CLUSTER SIZE
FIPMUC::.WORD	0		;CURRENT MFD/UFD CLUSTER SIZE

;****** I,J,K ARE GROUPED
I::	.WORD	0		;LINK OFFSET INTO BUFFER (0-777)
J::	.BYTE	0		;LINK ?
K::	.BYTE	0		;LINK ?

;****** FIBUNT,FIBSTA ARE GROUPED
	.EVEN
	.BYTE	0		;FIBUNT: UNIT # OF BLOCK CURRENTLY IN 'FIBUF'
FIBMOD::
FIBSTA::.BYTE	0		;MARKER FOR 'FIBUF' (MUST BE ODD ADDR!)

SYSSZL::.WORD	0		;SELECTED DISK SIZE LSB
SYSSZM::.WORD	0		;  "        "    "  MSB

SYSPHU::.BYTE	0,0		;LOW BYTE=UNIT*2, HIGH BYTE = UNIT
NRETRY::.BYTE	-8.		;NUMBER OF DISK RETRIES
DSIFLG::.BYTE	-1		;0 IF DSKINT IS RUNNING (<>0 => I/O ERR FATAL)
NOERR::	.BYTE	0		;<>0 IF DISK ERROR ARE TO BE TRAPPED
IOERR::	.BYTE	0		;SET TO RSTS ERROR CODE AFTER EACH I/O CALL
	.EVEN
SETFP1::			;END OF FIP CLEARED AREA


MAGXRB::.BLKB0	FQBSIZ		;Magtape work block in common area	;049

; JOB-RELATED GLOBALS FOR MAGTAPE DRIVERS

JOBTBL::.WORD	JDB		;ONLY JOB 0 EXISTS			;049
JDB::	.WORD	0							;049
	.WORD	0							;049
	.WORD	0							;049
	.WORD	MAGXRB		;POINTER TO XRB				;049
	.BLKW	12.							;049
						
JBSTAT::.WORD	0							;049
JBWAIT::.WORD	0							;049

WAIT1T::.BLKW0	L3QLEN		;BITS TO SET ONE TICK FROM NOW		;092
WAIT1E::								;092
WAIT2T::.BLKW0	L3QLEN		;BITS TO SET TWO TICKS FROM NOW		;092
WAIT2E::								;092
L3QUE::	.BLKW0	L3QLEN		;LEVEL-3-QUEUE SERVICE FLAGS		;092
L3QEND::								;092

.SBTTL		FIP CONTROL DSQ, FILE I/O DSQ, MS DRIVER TSQ's

I.DSQ::	.WORD	0	;LINK WORD & CSR CONTENTS FOR INIT ERROR CHECKS
	.BYTE	0	;+DSQJOB (IN INIT, DISK INDEX)
	.BYTE	0	;+DSQERR
	.WORD	0	;+DSQL3Q
	.BYTE	0	;+DSQUNT
	.BYTE	0	;+DSQFBM - EXTENDED DISK ADDRESS
	.WORD	0	;+DSQFBL - DISK ADDRESS
	.BYTE	0	;+DSQRFN - RH11 FUNCTION CODE
	.BYTE	0	;+DSQMAM - EXTENDED MEMEORY ADDR. R.H.JUSTIFIED
	.WORD	0	;+DSQMAL - CORE MEMORY ADDRESS
	.WORD	256.	;+DSQCNT - +WORD COUNT OF TRANSFER
	.BYTE	0	;+DSQFUN - FUNCTION
	.BYTE	0	;+DSQFAR - FAIRNESS COUNT
	.WORD	0	;+DSQMSC -
	.WORD	0	;+DSQTOT -
	.WORD	0	;+DSQPDA - PHYSICAL DISK ADDRESS
	.WORD	0	;+DSQOPT - OPTIMIZATION WORD
	.BYTE	0	;+DSQOUN - UNIT NUMBER * 2
	.BYTE	0	;+DSQSAV - FUNCTION SAVE
	.WORD	0	;+DSQPTO -
	.BYTE	0	;+DSQCTO -
	.BYTE	0	;+DSQPUN - PHYSICAL UNIT

FILDSQ::.BLKW0	20	;DSQ FOR DOING FILE I/O

TSQLEN	= 40			;LENGTH OF A TSQ (SMALL BUFFER)		;033
TSQ0:	.BLKB0	TSQLEN,-1	;FIRST TSQ (-1 SIGNIFIES OWNERSHIP)	;033
TSQ1:	.BLKB0	TSQLEN,-1	;SECONDARY TSQ, IF NEEDED		;033

.SBTTL		FIRQB'S

.MACRO	FQBGEN	TAG,NAMEXT,SIZ
.NLIST	BEX
.LIST
FQ'TAG::
.NLIST
	.WORD	0		;LINK (UNUSED)
	.BYTE	0,0		;FUNCTION, JOB
	.WORD	0		;CHANNEL
	.WORD	<0*400>+1	;PPN [0,1]
	.RAD50	"NAMEXT"	;FILE NAME & EXTENSION
	.WORD	SIZ+0		;REQUIRED SIZE (IF ANY)
	.WORD	0,0,0
	.BYTE	60,77		;STATUS, PROTECTION (?)
	.WORD	0,0,0,0		;REMAINDER OF STANDARD FIRQB

	.WORD	0		;REFRESH STATUS BITS
	.WORD	0		;CURRENT FILE SIZE
	.WORD	0		;CURRENT START CLUSTER
	.WORD	0		;PREFERRED START CLUSTER
	.WORD	0,0,0		;EXTRA WORDS FOR SCRATCH
	.WORD	0
.LIST
FC'TAG::
.NLIST
	.WORD	0,0,0,0,0,0,0,0	;FILE'S FCB
	.WORD	0,0,0,0,0,0,0,0
.IIF NE <.-FC'TAG>-FCBSIZ, .ERROR ;BAD FCB
.LIST

.NLIST
.LIST	BEX
.ENDM	FQBGEN

	FQBGEN	INIT,<INIT  SYS>

	FQBGEN	SATT,<SATT  SYS>
	FQBGEN	BADB,<BADB  SYS>

	FQBGEN	SIL ,<      SIL>

IDXBLX::.WORD	0			; Number of blocks in SIL index	;025


	FQBGEN	ODT ,<ODT   SYS>

	FQBGEN	... ,<         > ; Scratch FIRQB for general files
	FQBGEN	COPY,<         >	; Scratch FIRQB for COPY	;092


.SBTTL	Area to hold actual NXM values found during SETNXM		;076

	TMPORG	ROOIMP							;076

A.NXM::	.BLKW0	<2048./16.>	;Actual NXM on this system (filled in	;076
				; by SETNXM).				;076

TOPPHY::.BLKW			;Filled in by SETNXM with the actual	;076
				; number of K words this machine is	;076
				; capable of addressing.		;076

ROMEM:	.WORD	177777		;Flag used in SETNXM to say that we're	;090
				; checking memory that INIT resides in,	;090
				; and therefore we should do the	;090
				; non-destructive check.		;090
				; Starts out as non-zero, and is set to	;090
				; zero by SETNXM as soon as we go above	;090
				; INIT.					;090

	UNORG								;076


.SBTTL	Installed Monitor parameters

	ORG	INSBUF

SETTBL::.BLKW0	CSRTBS		; User'S SET options
SILNAM::.BLKW0	2		; Name of installed Save Image Library
RSTSIZ::.BLKW0			; RSTS module size, in words
SEGTBL::			; Beginning of segment table		;056
RSTBLK::.BLKW0			; RSTS module block start (first segment) ;056
FIXL::	.BLKW0			; Size of fixed part of monitor		;056
FIPBLK::.BLKW0			; FIP phase block start			;056
FIPL::	.BLKW0			; FIP phase length (MMU slivers)	;056
CRABLK::.BLKW0			; CRA phase block start			;056
CRAL::	.BLKW0			; CRA phase length (MMU slivers)	;056
TERBLK::.BLKW0			; TER phase block start			;056
TERL::	.BLKW0			; TER phase length (MMU slivers)	;056
SESBLK::.BLKW0			; SES phase block start			;065
SESL::	.BLKW0			; SES phase length (MMU slivers)	;065
NSPBLK::.BLKW0			; NSP phase block start			;065
NSPL::	.BLKW0			; NSP phase length (MMU slivers)	;065
TRNBLK::.BLKW0			; TRN phase block start			;065
TRNL::	.BLKW0			; TRN phase length (MMU slivers)	;065
RDMBLK::.BLKW0			; RDM phase block start			;070
RDML::	.BLKW0			; RDM phase length (MMU slivers)	;070
EVLBLK::.BLKW0			; EVL phase block start			;070
EVLL::	.BLKW0			; EVL phase length (MMU slivers)	;070
NODBLK::.BLKW0			; NOD phase block start			;104
NODL::	.BLKW0			; NOD phase length (MMU slivers)	;104
UNABLK::.BLKW0			; UNA phase block start			;066
UNAL::	.BLKW0			; UNA phase length (MMU slivers)	;066
QNABLK::.BLKW0			; QNA phase block start			;066
QNAL::	.BLKW0			; QNA phase length (MMU slivers)	;066
GPKBLK::.BLKW0			; GPK phase block start			;092
GPKL::	.BLKW0			; GPK phase length (MMU slivers)	;092
PTBBLK::.BLKW0			; PTB phase block start			;092
PTBL::	.BLKW0			; PTB phase length (MMU slivers)	;092
DHPBLK::.BLKW0			; DHPORT phase block start		;097
DHPL::	.BLKW0			; DHPORT phase length (MMU slivers)	;097
DZPBLK::.BLKW0			; DZPORT phase block start		;097
DZPL::	.BLKW0			; DZPORT phase length (MMU slivers)	;097
VHPBLK::.BLKW0			; VHPORT phase block start		;097
VHPL::	.BLKW0			; VHPORT phase length (MMU slivers)	;097
FMSBLK::.BLKW0			; FMS phase block start			;097
FMSL::	.BLKW0			; FMS phase length (MMU slivers)	;097
LATBLK::.BLKW0			; LAT phase block start			;098
LATL::	.BLKW0			; LAT phase length (MMU slivers)	;098
KBXBLK::.BLKW0			; KBX phase block start			;110
KBXL::	.BLKW0			; KBX phase length (MMU slivers)	;110
SEGTBE::			; End of segment table			;056

SILCKS::.BLKW0			; Checksum of permanent part of DEFBUF

.SBTTL	Start-up Parameters (for auto-restart)

S.DATE::.BLKW0			; Start-up date
S.TIME::.BLKW0			; Start-up time

CSRTBL::.BLKW0	CSRTBS		; Built table of CSR's
VECTBL::.BLKW0	CSRTBS		; Built table of vector addresses
TYPTBL::.BLKW0	CSRTBS		; Table of per-unit characteristics
VECMAP::.BLKW0	10		; 8 words of vectors in use

UMIDST::			; Start user disk unit overrides (for HARDWR)
	$DISKS			; Generate user disk unit overrides
.IF	GT	IDX$'NAME-IDX$DF
  .IF	EQ	IDX$'NAME-IDX$DU
NAME'UMID::.BLKW0	'NAME'.UNC,-1	;NAME DISK IDENTIFICATION TABLE
  .IFF
NAME'UMID::.BLKW0	8.,-1.		;NAME DISK IDENTIFICATION TABLE
  .ENDC
.ENDC
.ENDM
UMIDEN::			; End of user disk overrides
BAELST::.BLKW0	<<6*2>+1>	; Pairs of (BAE,CSR) terminated with 0
BAELSE::
BAEPTR::.WORD	0		; Points to first unused word in BAELST
LINFRQ::.WORD	60.		; AC frequency, reset w/HERTZ below	;007
SWTREG::.WORD	0		; 0 => normal, 1 => disabled, -1 => volatile
J11LTS::.WORD	0		; J-11 lights =0 enabled, <>0 disabled	;118
CCTVAL::.WORD	0		; Cache control put in CHECTL.  0 = normal.

HWTABL::			; Table of HARDWARE options
CACHE::	.BYTE	0		; If bit 7=1 then no cache
CACHEA::.BYTE	0		; If bit 7=1 then no cache parity address info
HWSIZE::.WORD	0		; If <>0 then have hardware size register value
KW11P::	.BYTE	0		; If bit 7=1 then no KW11P
KW11L::	.BYTE	0		; If bit 7=1 then no KW11L
STAKLM::.WORD	0		; If bit 7=1 then no stack limit option
FPU::	.WORD	0		; If bit 7=1 then no FPU
FIS::	.WORD	0		; IF bit 7=1 then no FIS
SWR$R::	.BYTE	0		; If bit 7=1 then cannot read  SWR
SWR$W::	.BYTE	0		; If bit 7=1 then cannot write SWR
MEDINS::.WORD	0		; If bit 7=1 then 'MED' instruction doesn't work (not 11/60)
CACHES::.WORD	0		; Number of bytes to sweep when enabling cache
REGST1::.BYTE	0		; If bit 7=1 then no register set 1
KTUSR3::.BYTE	0		; If bit 7=1 then no MMUSR3
CP.SID::.BYTE	0		; If bit 7=1 then no CPUSID (system ID register)
ODD.AD::.BYTE	0		; If bit 7=1 then CPU will do odd address traps
CISINS::.BYTE	0		; If bit 7=1 then no CIS instruction set
FLGUMR::.BYTE	0		; If bit 7=1 then no UMR
FLGQBU::.BYTE	0		; If bit 7=1 then no Q-Bus
FLG22::	.BYTE	0		; If bit 7=1 then no 22-bit addressing
				; If bit 0=1 & Q-bus then physical memory <= 248KB	;018
				; If bit 0=1 & UNIBUS then do not have UMR
DSHARD::.BYTE	0		; If bit 7=1 then no separate I&D space registers
CP.ERR::.BYTE	0		; If bit 7=1 then no CPUERR (error register)
CP.ERW::.BYTE	0		; If bit 7=1 then CPUERR may not be written
DSPACE::.BYTE	0		; If =0 then enable D-space
				; If =-1 then don't enable D-space
FLGGPK::.BYTE	0		; If bit 7=1 then not a GPK		;092
NOTT0::	.BYTE	0		; If bit 7=1 then no console present (GPK) ;092
PIEBO::	.BYTE	0		; If 0 then no EBO present (GPK)	;092
	.EVEN
TTFILL::.WORD	0		; Low byte = fill after, high byte = count
				; -1 = scope, no fill, fancy rubouts
X.CON::	.WORD	0		; Dummy configuration word for 22-bit Q-bus disk drivers
				; X.CON is hard coded with the zero value!  This
				;  represents 18-bit addressing and physical
				;  memory <= 248KB

.SBTTL		DEVICE INFORMATION (FOR SYSGEN) WRITTEN TO DISK

;  CSR TABLE FOR MULTI-CONTROLLER DISK DEVICES
	$DISKS
.IF	DF	'NAME'.MAX
CSR'NAME::
$$	= 0
  .REPT	'NAME'.MAX
  .RADIX 10
    .IRP	N,<\$$>
CS'NAME''N:	.WORD	0
    .ENDR
$$	= $$+1
  .RADIX  8
  .ENDR
.ENDC
.ENDM

; THESE CSR'S MUST BE IN THE SAME ORDER AS THE DEVICE PACKET TABLE !!

DSKCSR::			;ONE WORD PER DISK FOR CSR'S
	$DISKS
.IF	DF	'NAME'.MAX
	.WORD	CSR'NAME'+1	;ADDRESS OF NAME CSR TABLE
.IFF
CSR'NAME::	.WORD	0	;NAME CSR
.ENDC
.ENDM
.ASSUME	IDX$MU	EQ	-10
CSRMU::	.WORD	0		;MU0 CSR				;050
	.BLKW0	MU.MAX-1	;MU1-n CSR'S				;050
CSRMS::	.WORD	0		;MS0 CSR
	.BLKW0	7		;MS1-7 CSR'S
CSRMT::	.WORD	0		;MT CSR
CSRMM::	.WORD	0		;MM CSR
MAGCSR::			;ONE WORD PER TAPE FOR CSR'S
DTACSR::.WORD	0		;DECTAPE CSR

DV$MID::.BLKW0	1.,-1		;RV (0 -> Memory reserved for DV:)	
DV$SZL::.BLKW0	DV.UNC		;RV Size depends upon the amount of 	;009
				;   memory that was reserved by DEFALT.	;009

; CAUTION: DSKINT MAY CHANGE DF$SZL. RESET FROM RFSLSV
DF$MID::.BLKW0	1.,-1		;RF IDENTIFICATION (0 => EXISTS, -1 => NONE)
DF$SZL::.BLKW0	DF.UNC		;RF = 1024 BLOCKS/PLATTER [VARIABLE]	;092

DS$MID::.BLKW0	DS.UNC,-1	;RS MASSBUS ID TABLE (-1 => NO UNIT)
DS$SZL::.BLKW0	DS.UNC		;RS04=2048, RS03=1024.ORDRD BY PHY UNIT [BOOT]

DK$MID::.BLKW0	DK.UNC,-1	;RK ID TABLE (0 => RK05J, 2 => RK05F)
DK$SZL::.BLKW0	DK.UNC,4800.	;RK = 4800. SEGMENTS [FIXED]

DL$MID::.BLKW0	DL.UNC,-1	;RL ID TABLE (0 => RL01, 200 => RL02)
DL$SZL::.BLKW0	DL.UNC,10220.	;RL01 = 10220, RL02 = 20460 [BOOT]

DM$MID::.BLKW0	DM.UNC,-1	;RK06 ID TABLE (0 => RK06, 002000 => RK07)
DM$SZL::.BLKW0	DM.UNC,27104.	;RK06 = 27104

DP$MID::.BLKW0	DP.UNC,-1	;RP ID TABLE (0 => RP02, 020000 => RP03)
DP$SZL::.BLKW0	DP.UNC,14464.	;RP03=80000, RP04=40000 [BOOT]
DP$SZM::.BLKW0	DP.UNC,1	;HIGH ORDER RP SIZE [BOOT]
DP$DCS::.BLKW0	DP.UNC,2	;RP02/03 DCS IS ALWAYS 2 [FIXED]

DB$MID::.BLKW0	DP.UNC,-1	;RB MASSBUS ID TABLE (-1 => NO UNIT)
DB$SZL::.BLKW0	DP.UNC,36128.	;RB=167,200 SEGMENTS [BOOT]
DB$SZM::.BLKW0	DP.UNC,2	;RB SIZE (MSB) [BOOT]
DB$DCS::.BLKW0	DP.UNC,1	;DEV CLU SIZES FOR RP04/05/06'S [BOOT]

DZ$MID::.BLKW0	DZ.UNC,-1	;DZ identification (0 => exits, -1 => none) ;092
DZ$SZL::.BLKW0	DZ.UNC,800.	;DZ size always 800. blocks		;092

DW$MID::.BLKW0	DW.UNC,0 ;***temp***	;DW identification (-1 => none)	;092
DW$SZL::.BLKW0	DW.UNC,19519. ;***temp***		;DW low size (variable) ;092
DW$SZM::.BLKW0	DW.UNC		;DW high size (variable)		;092
DW$DCS::.BLKW0	DW.UNC,1 ;***temp***		;DW dev clu size (variable) ;092
                                                                            
DU$MID::.BLKW0	DU.UNC,-1 	;UDA MASSBUS ID TABLE (-1 => NO UNIT)
DU$SZL::.BLKW0	DU.UNC,0. 	;UDA SIZE DEPENDS ON MEDIA TYPE
DU$SZM::.BLKW0	DU.UNC,0. 	;UDA SIZE DEPENDS ON MEDIA TYPE
DU$DCS::.BLKW0	DU.UNC,0.	;UDA DEV CLU  DEPENDS ON MEDIA TYPE
DU$MNM::.BLKW0	DU.UNC*2	;UDA Media name table (2 words/unit)
MU$MNM::.BLKW0	MU.UNC*2	;TMSCP Media name table (2 words/unit)	;050

.SBTTL	MASS STORAGE CONTROL PROTOCAL TABLES (UMT AND CMT)

;	UNIT MAPPING TABLES FOR MSCP DEVICES
;	At present we only know of UDA50 type devices
UMT$XX::
UMT$DU::.BLKW0	UMTSIZ/2*DU.UNC,0.	;UMT INDEXED BY UNIT NO. * ENTRY SIZE
UME$DU::
UMT$MU::.BLKW0	UMTSIZ/2*MU.UNC,0	;TMSCP UMT save area (Moved to DDB) ;050
UME$MU::
UME$XX::

;	CONTROLLER MAPPING TABLE FOR MSCP DEVICES
	.BLKW	<-CM.HDR>/2		;CMT header area		;050
CMT::	.BLKW	CMTSIZ*<DU.MAX+MU.MAX>	;CMT INDEXED BY CNTRL #  * ENTRY SIZE
UQCMT::	.BLKB0	DU.MAX+MU.MAX	;UQ port controller model values	;050
	.EVEN
DR$MID::.BLKW0	8.,-1		;RR MASSBUS ID TABLE (-1 => NO UNIT)
DR$SZL::.BLKW0	8.,586.		;RR=131,656 SEGMENTS
DR$SZM::.BLKW0	9.,2		;HIGH ORDER RR SIZE
DR$DCS::.BLKW0	8.,4		;RR DCS

; DEVICE CLUSTER SIZE IS 1 FOR ALL SMALL DISKS
DV$DCS::
DF$DCS::
DS$DCS::
DK$DCS::
DL$DCS::
DM$DCS::
DZ$DCS::.BLKW0	8.,1		;DCS 1 FOR ALL 8 UNITS [FIXED]		;092
; MSB OF SIZE OF ALL SMALL DISKS IS 0
DV$SZM::
DF$SZM::
DS$SZM::
DK$SZM::
DL$SZM::
DM$SZM::
DZ$SZM::.BLKW0	8.		;ALL 8 UNITS ARE SMALL [FIXED]		;092

; Boot driver entries are "infinite" to suppress any checks
BT$SZL:
BT$SZM:	.WORD	77777
BT$DCS:	.WORD	1		;Filled in by one-shot code

MM$FOR::.BLKW0	8.,-1		; FORMATTER UNIT NUMBER FOR RH TYPE TAPES
MM$TYP::.BLKW0	8.,0		; FORMATTER TYPE FOR RH TYPE TAPES
MS$TYP::.BLKB0	8.,0		;TS: DRIVE TYPES - COMPUTED BY INIONE	;033

RJDRVR::.WORD	-1		;DEVNAM OFFSET FOR RJ2780
IIDRVR::.WORD	-1		;DEVNAM OFFSET FOR II2780

; THE FOLLOWING VALUES DESCRIBE THE BOOTED DEVICE.
; THEY ARE ALL SET UP BY THE ONE-SHOT CODE, AND NEVER MODIFIED
SYNXSV::.WORD	0		;SAVE SYSTEM DISK INDEX [BOOT]
SYSUSV::.WORD	0		;SAVE SYSTEM DISK UNIT NUMBER [BOOT]
;RCSLSV::.WORD	0		;SAVE RC SIZE [BOOT]			;092
RFSLSV::.WORD	0		;SAVE RF SIZE [BOOT]
SYSNAM::.WORD	0		;SYSTEM DISK NAME IN ASCII [BOOT]
SYSDEN::.WORD	0		;SAVE SYSTEM TAPE DENSITY [BOOT]

CNT.XE::.WORD	0		;Number of UNA controllers found	;067
CNT.XH::.WORD	0		;Number of QNA controllers found	;067

XEADDR::.BLKB0	<MAX.XE*10>	;UNA/LUA default physical address	;086
XHADDR::.BLKB0	<MAX.XH*10>	;QNA/LQA default physical address	;086

	ROUND	INSBUF		;ROUND UP TO A BLOCK BOUNDARY


.SBTTL	DEFBUF:	DEFAULT BUFFER DEFINITIONS

	ORG	DEFBUF

; THE FOLLOWING PARAMETERS ARE READ FROM THE SIL & REWRITTEN THERE

D.LB::	.BLKB	LBLEN		;LOAD BLOCK (PARAMETERS FOR LOADING MONITOR)
	.EVEN
I.DFLD::.WORD	0		;DEFAULT FLAG (<> 0 IF DEFAULTS SET)

; The following fields must be in the same order as their counterparts	;076
; in the DEFALT work area (located in INIDEF).				;076

D.JOBM::.WORD	0		;DEFAULT JOB MAX
.ASSUME	D.JOBM EQ <I.DFLD+2>	;D.JOBM must follow I.DFLD or DEFALT	;076
				; will break!!				;076
D.SWPM::.WORD	0		;DEFAULT SWAP MAX
D.CRAS::.WORD	0		;CRASH DUMP ENABLED 0 DISABLED -1
D.XTRA::.BLKW0			;EXTRA MONITOR SIZE FOR SMALL BUFFERS(K WORDS) ;013
D.EXEC::.BLKW0	2		;LOCATION & SIZE OF MONITOR
D.ODT::	.BLKW0	2		;LOCATION & SIZE OF ODT
D.CACH::.BLKW0	2		;LOCATION & SIZE OF CACHE MEMORY
D.LOCK::.BLKW0	<2048./16.>	;Locked-out memory bit map		;076

; End of ordering requirement.						;076

D.NXM::	.BLKW0	<2048./16.>	;Non-existent memory bit map		;076
D.DANS::.BLKW0			;MAGTAPE LABELING DEFAULT
D.NAME::.BLKW0	32./2		;INSTALLATION NAME
D.NPTR::.BLKW0			;OFFSET OF USER PART OF NAME
D.CBSZ::.WORD	4		;SIZE OF CACHE CLUSTER
D.XMAP::.BLKW0			;AMOUNT OF XBUF TO MAP WITH UMR'S
D.CLNF::.BLKW0			;<>0 IF CLEAN AFTER CRASH TAKES AUTO ACTION
D.ERRN::.BLKW0	2		;ERROR FILE NAME (RAD50) (ASSUMES [0,1].ERR)

DEFCLR	==	<. - I.DFLD> / 2 ;NUMBER OF WORDS TO CLEAR IF NO DEFAULTS

D.ERNG::.BLKW0	MAX.XE,20.*400+6	; UNA XMT/RCV ring entries	;086
D.HRNG::.BLKW0	MAX.XH,20.*400+6	; QNA XMT/RCV ring entries	;086
D.RRNG::.BLKW0	DU.MAX,4*400+4	; # of CMD/RSP ring entries for RU0-RU3	;067
D.MRNG::.BLKW0	MU.MAX,4*400+4	; # of CMD/RSP ring entries for MU0-MU3	;086
D.CPRF::.BLKW0			;PREFERRED CLOCK (1 => KW11-L, -1 => KW11-P)
D.CRAT::.BLKW0			;KW11-P RATE (0 => LINE, 50.*N = RATE)
D.DATF::.BLKW0			;DEFAULT DATE FORMAT (<=0 => ALPHA, >0 => ISO)
D.TIMF::.BLKW0			;DEFAULT TIME FORMAT (<=0 => AM/PM, >0 => 24)
D.PWRP::.BLKW0			;POWER FAIL DELAY IN SECONDS (0 - 300)
D.JCRS::.BLKW0			;# of words in a job control entry	;064

.MACRO $ NLST
.IRP NAME,<NLST>
NAME::.BLKW0
.ENDR
.ENDM $                                                                     

DEFBFP:: 	  ;PERMANENT PART OF DEFBUF

$	 <.$2780, .$VSWR, .$UMRT, .$UMRP, .$GUMR, .$RUMR, .$UMRS>
$	 <.$UMRE, .$UMRI, .$UMRJ, .$UPES, .$UPEE, .$UPEI, .$UPEJ>
$	 <.$TMUN, .$UMTM, .$TIME, .$TICK, .$SYSU, .$SYSP, .$SWPM, .$SWPB> ;050
$	 <.$SWMP, .$STAK, .$SROM, .$SREG, .$SL,   .$SFPP, .$RTSP>           
$	 <.$RFPP, .$PZER, .$PTBL, .$PRNG, .$PNEW, .$PCSR>
$	 <.$PSCN, .$PMSK, .$OVRC, .$OVRB, .$OV2B>			;109
$	 <.$LODB, .$OVBF, .$ODT6, .$ODTP>
$	 <.$ODTE, .$ODTB, .$NULW, .$NDAY, .$MOVW, .$MOVB>
$	 <.$MEMT, .$MEML, .$MEDS, .$MEDE, .$MEDI, .$MEDJ>
$	 <.$MBFS, .$MBFE, .$YBFS, .$YBFE, .$M22W, .$LRGP, .$LDAY>
$	 <.$JOBM, .$IBOT, .$ISPS, .$ISPE, .$ITOP, .$HZDV, .$FR25>           
$	 <.$FR20, .$FR00, .$FPPS, .$FPPE, .$FPPI, .$FPPJ, .$FIS >
$	 <.$EXTP, .$EXTO, .$ESID, .$ERSZ, .$ERRB, .$EPMM, .$EMED>
$	 <.$ECPU, .$DSPA, .$DSIZ, .$DREG, .$DMID, .$DDCS>		;051
$	 <.$DATE, .$CSRT, .$CRSZ, .$CQNT, .$CPRM, .$CNVF, .$CHSZ>
$	 <.$CHEN, .$CCTL, .$CCSR, .$CCNT, .$CNOP, .$CBSZ, .$CACH>
$	 <.$BUFS, .$BUFE, .$BUFB, .$BFRT, .$BAEL, .SATBU, .FIBUF>
$	 <.UNTCN, SYSVEN, JOBMAX> 					;097
$	 <DEVSYN, DEVPTR, DEVOKB, DEVNAM, DEVCNT>			;097
$	 <CNT.DT, XDDDDB, DDS.XD, XMDDDB, DDS.XM>			;060
$	 <SOFTKG>
$	 <.$XTAB, .$XSCS, .$XCON, .$XMOS, .$XDCN, CNT.DU, .CMT  >
$	 <.UMTDU, CNT.MU, TERAP6, CRAAP5, FIPAP6, JCRSIZ, .$JCR6>	;097
$	 <.$JCFX, SESAP5, NSPAP5, TRNAP5, NODAP5, XEDAP5, XHDAP5>	;104
$	 <.$NETI, .$NETJ, .$NETS>					;065
$	 <.$NETE, .$NETT, .$NETW, .$CCCR, UMR$XE>			;066
$	 <XEDDDB, XECORE, XHDDDB, XHDATA, DDS.XE, DDS.XH>		;068
$	 <NODDDB, DDS.NO>						;116
$	 <EVLAP5, RDMAP5, FAKDDB>					;073
$	 <SYSTIC, NULJOB>						;080
$	 <.$CLK2, GPKAP5, PTBAP6, .CSR.LK,.VEC.LK>			;092
$	 <CSR.KB, DEV.KB, UCT.KB, DHPAP5, DJPAP5>			;097
$	 <DZPAP5, VHPAP5, DHKINT, DJKINT, DLKINT>			;097
$	 <DMKINT, DZKINT, VHKINT>					;097
$	 <DJKBN,  DHKBN,  DZKBN,  VHKBN>				;097
$	 <FMSAP5, TTFMSB, CSR.BB, KBDDBX>				;097
$	 <LATAP5>							;098
$	 <TTAUXB>							;104
$	 <.$LATS, .$LATE, DYNKBN>					;106
$	 <APTAP5>							;110

	ROUND	DEFBUF		;ROUND UP TO A BLOCK BOUNDARY

	TMPORG	ROOTBL
..XMOS	==	.	;** PATCH ** TO CHANGE ROOT DUMP SIZE
X.MONS::.WORD	.$EPMM		;INDIRECT POINTER TO WORD WITH ROOT DUMP SIZE

.SBTTL	DEFINITIONS FOR ONE-SHOT CODE

.MACRO	I.MESS
	TMPORG	FIBUF
	.NLIST	BEX
.ENDM	I.MESS

.SBTTL	SATBUF:	ONE-SHOT SETUP CODE

	ORG	SATBUF		;THIS CODE GETS ASSEMBLED INTO SATBUF

.ENABL	LSB

	COMB	AUTOST		;-32 Enter here for auto START-up	;026
	BR	INITGO		;    now go start			;026
INITWR::COMB	AUTOGO		;-24 Enter here for streamline startup	;017
	BR	INITGO		;    now go start			;017
	COMB	SAVDEV		;-16 ENTER HERE FOR BOOT FROM SAV/RES DISK!
	BR	INITGO		;    NOT AN AUTO RESTART
	COMB	VOLSWR		;-10 ENTER HERE FOR RESTART REGARDLESS OF SWR!
	COMB	AUTOQS		; -4 ENTER HERE FOR AUTO-RESTART!
INITGO::BR	10$		;  0 Normal entry point
	MOV	#NOP,ODTGO	; +2 ODT (debugging) entry point
10$:	MOV	#-1,KW11P	;NO CLOCKS FOR TIMING
	CLR	FLGGPK		;Assume it's not a GPK			;092
	MOV	#177560,CSRDEC+TT.CSO ;Assume normal PDP11 console	;092
	CLR	CSRTBL+PI.CSO	;Don't use display until we find it	;092
	CLR	CSRTBL+LK.CSO	;Keyboard ditto				;092
	MOVB	SAVDEV,BACKUP	;SAV/RES OVERLAYS IF BOOTED FROM SAV/RES DISK!
	MOVB	#200,CACHE	;NO CACHE FOR TRAP-HANDLING
	RESET			;STOP THE WORLD, I WANNA GET ON		;075
	RESETB
	MOV	#-1.,CC.DBL	;Disable ^C, we haven't finished booting;075
	MOV	SETTBL,R0	;FIRST SET UP THE TERMINAL
	BNE	20$		;(NON-STANDARD!)
	MOV	CSRDEC+TT.CSO,R0 ;USE THE STANDARD CONSOLE
20$:	MOV	R0,I.TKS	;SET IT UP SO WE CAN PRINT ERRORS
	TST	B.BOOT		;Is this a GPK (funny bootstrap)?	;092
	BNE	30$		;No					;092
.ASSUME	HALT EQ 0							;092
	COMB	FLGGPK		;Yes, flag that for later		;092
	MOV	CSRDEC+PC.CSO,CSRDEC+TT.CSO ;Use console port CSR	;092
;									;092
; Note that RSTS (online) uses the printer port CSR set (at 173400)	;092
; whether the port is being used as a printer (BCC05 cable) or as	;092
; a debug console (BCC08 cable).  However, within INIT we refer to	;092
; that console via I.TKS, which has already been set to point to	;092
; the standard PDP11 console address.  So if the display isn't		;092
; found for some strange reason, but a BCC08 console is connected,	;092
; then the standard PDP11 console output handing in INITTY/INITTM	;092
; will access it regardless of the "strange" value in CSRDEC+TT.CSO	;092
;									;092
	CLR	R1		;Counter for a short delay		;092
	MOV	R1,6(R0)	;Output a null to clear "ready"		;092
25$:	TSTB	4(R0)		;Is the console "ready"?		;092
	BMI	30$		;Yes, so BCC08 (console) cable in use	;092
	SOB	R1,25$		;Wait a little while in case xmit busy	;092
	COMB	NOTT0		;No, so BCC05, i.e. only a printer port	;092
30$:	CALL	TRASEC		;Set C=1 if NXM trap
	CLR	@#MMUSR0	;Do we have a MMU?			;075
	BCC	40$		;Yes, good
	HALT			;Die (too early to do typing)		;092

40$:	CALL	@(SP)+		;Revert to normal trapping
	CALL	KPARSU		;Set up the MMU
	CALL	ODTSET		;Set up ODT in its phase
ODTGO:	BR	50$		;Changed to NOP above if debugging wanted
	MOV	#BPT,HALTER	;PUT ON THE RING OF ELFIN KINGS
	BPT			;A HOLLOW VOICE SAYS 'PLUGH'
50$:	MESSAGE	<<377><177><200>> ;SYNCH UP THE TERMINAL, RESTORE IT	;092
	MOV	#IDX$..,SYSNDX	;Set up sysdev index to use bootstraps
	MOV	#IDX$..,SYNXSV	; the "saved" one also
	CLR	SYSUNT		;Fake a unit of 0 since we only
	CLR	SYSUSV		; have one table entry
	MOV	B.NAME,BTDNAM	;Set booted device's name
	MOV	B.DCS,BT$DCS	;Set device's clustersize
	TSTB	FLGGPK		;Is this a GPK?				;092
	BMI	60$		;Yes, so scope type console		;092
	TSTB	MICRO		;Micro/RSTS?				;078
	BEQ	70$		;No					;078
	MOV	#"u/,LOGO	;Set micro-RSTS style logo		;092
60$:	MOV	#-1,TTFILL	;Yes, set fill scope			;092
70$:	CALL	VBCHK		;Is this a first-time boot??		;102
	BCC	120$		;No, so leave INSBUF and DEFBUF alone.	;102
	MOV	#INSBUF,R0	;CLEAR OUT INSBUF, SINCE THIS IS A NEW INIT
	MOV	#<HWTABL-INSBUF>/2,R1
80$:	CLR	(R0)+
	SOB	R1,80$
	MOV	#UMIDST,R0	;CLEAR OUT USER UNIT OVERRIDES
	MOV	#<UMIDEN-UMIDST>/2,R1
90$:	COM	(R0)+		;SET EACH OVERRIDE TO -1
	SOB	R1,90$
	MOV	@#HERTZ,LINFRQ	;AC LINE FREQUENCY (50hz or 60hz)	;007
	MOV	#DEFBUF,R0	;CLEAR OUT DEFBUF, SINCE NO DEFAULTS
	MOV	#SIZDEF/2,R1
100$:	CLR	(R0)+
	SOB	R1,100$
	MOV	#TYPTBL+DM.CSO+<16.*2>,R0 ;SET UP DEFAULT DM11BB ASSOC
	MOV	#15.,R1		;DM15 GOES WITH DH15
110$:	MOV	R1,-(R0)	;SET UP AN ASSOCIATION
	DEC	R1		;COUNT DOWN DM11BB'S
	BPL	110$		;DO 15 TO 0

; PERFORM THE BUS-TYPE ALGORITHM
;   THIS ALGORITHM USES THE MFPT INSTRUCTION TO DETERMINE THE TYPE OF
;   PROCESSOR OR CHIP-SET BEING USED.  AS RSTS/E SUPPORT FOR NEW PROCESSORS
;   IS ADDED, THIS CODE WILL HAVE TO BE EXPANDED BY DECODING THE VALUE RETURNED
;   IN R0.

120$:	MOV	#QBUS,@#4	;BUS-TIMOUT INDICATES Q-bus BEING USED
	MOV	#UNIBUS,@#10	;UNDEFINED INSTRUCTION INDICATES Unibus BEING USED
	CLR	R1		;MAKE SURE WE START WITH 0		;075
	CLR	R0		;START AT 0 IN CASE IT DOESN'T WORK
	MFPT			;IF CPU DOESN'T SUPPORT MFPT, TRAP10 TO UNIBUS
	CMP	R0,#1		;IS THIS AN 11/44			;030
	BEQ	200$		;YES!!					;030
	TSTB	FLGGPK		;Is this a GPK?				;092
	BMI	210$		;Yes, that's similar to Q-bus so say so	;092
	CMP	R0,#3		;IS THIS A 11/23 OR 11/24? (F-11 CHIP)
	BNE	180$		;NO, IT IS A UNIBUS SYSTEM		;030
	CLR	@#SWR		;IF 11/23, TRAP4 TO Q-bus
	BR	200$		;IF 11/24, DON'T TRAP4

180$:	CMP	R0,#5		;IS THIS A 11/73/83/84 (J11 CHIP)	;030
	BNE	190$		;THEN I DON'T KNOW  (CHANGE FOR NEW PROCESSORS) ;030
	MOV	@#177750,R1	;GET THE BOARD TYPE			;075
	BIT	#1000,R1	;IS THIS A UNIBUS J SYSTEM		;075
	BNE	200$		;YES					;030
	BR	210$		;NO, IT'S Q-BUS				;030

190$:	MESSAG	<<200>"Unknown CPU type."<200>>				;030
	BR	200$		;TELL THEM, BUT CONTINUE ASSUMING UNIBUS ;030
	BR	210$		;ASSUME Q-BUS (PATCH BR 200$ TO NOP)	;030
	NOP			;And yet allow a third assumption	;092

UNIBUS:	CMP	(SP)+,(SP)+	;REMOVE TRAP STUFF FROM STACK
200$:	MOVB	#200,FLGQBU	;FLAG UNIBUS SYSTEM
	BR	220$

QBUS:	CMP	(SP)+,(SP)+	;REMOVE TRAP STUFF FROM STACK
210$:	CLRB	FLGQBU		;FLAG Q-bus SYSTEM
220$:				;END OF BUS-TYPE ALGORITHM
	MOV	#TRAP.4,@#4	;Restore vector at 4			;117
	MOV	#TRAP.10,@#10	;Restore vector at 10			;117
	MOV	R0,CPTYP	;STORE THE CPU TYPE			;030
	ASH	#-4,R1		;MOVE IT OVER				;075
	BIC	#^C<17>,R1	;SAVE JUST CPU TYPE			;075
	MOV	R1,JCPTYP	;AND STASH IT AWAY FOR LATER		;075

	TMPORG	ROOCTL							;030
CPTYP::	.WORD	0							;030
JCPTYP::.WORD	0							;075
JCPSPD::.WORD	0							;075
	UNORG								;030


.SBTTL	Check out validity of date/time

	MOV	#B.DATE,R0	;POINT TO TIME INFORMATION IN BOOT
	CLRB	1(R0)		;CLEAR TICKS ACCUMULATED
	CMP	(R0),#60.	;BAD VALUE OF TIMSEC?
	BLOS	130$		;NO, IT'S OK
	MOV	#30.,(R0)	;APPROXIMATE 1/2 WAY INTO THE MINUTE
130$:	CALL	TOYCLK		;Read the TOY clock, if there is one	;088
	MOV	(R0)+,@#TIMSEC	;SECONDS TO NEXT MINUTE
	BCS	135$		; If TOYCLK returns "C" then it worked	;117
	CMPB	BTDNAM,#'M	;Booted from tape?
	BEQ	140$		;Yes, never a valid date/time then
135$:	CMP	(R0),#1440.	;Legal value of time?
	BLOS	150$		;Yes
140$:	CLR	(R0)		;No, mark it
	CLR	2(R0)		; and force date to be invalid also
150$:	MOV	2(R0),R3	;Get date
	CLR	R2		;For divide
	DIV	#1000.,R2	;Get year and day
	CMP	R2,#90.-70.	;1990 or later?				;117
	BLO	160$		;No, bad
	CMP	R2,#135.-70.	;2035 or before?			;117
	BHI	160$		;No
	TST	R3		;Valid day?
	BEQ	160$		;Zero isn't
	CMP	R3,#366.	;Small enough?
	BHI	160$		;No
	BLO	170$		;Yes, definitely
	ASR	R2		;Year<1:0> should = 2
	BCS	160$		;Error if not
	ASR	R2		;One more check...
	BCS	170$		;Fine!
160$:	CLR	2(R0)		;Clear out date to mark it invalid
	CLR	(R0)		;Clear out time also to force real time entry
170$:	MOV	(R0),I.TIME	;INTERNAL TIME
	MOV	(R0)+,@#TIME	;RSTS TIME WORD
	MOV	(R0),I.DATE	;INTERNAL DATE
	MOV	(R0),@#DATE	;RSTS DATE WORD

; CHECK FOR VARIOUS HARDWARE OPTIONS
;
; Here, we drop priority to 0 for a brief period to catch any		;084
; undesirable interrupts that may be hanging around on the bus.		;084
; The only thing that can legally interrupt us is the clock, which	;084
; comes in at vector 100; if we get a clock interrupt, we ignore it	;084
; and try again.							;084
;
; On a GPK, we may well have pending interrupts left around, since they	;092
; stay around across RESET for some reason.  So we start out by		;092
; clearing any that may be around.  This routine then effectively 	;092
; checks for interrupts that won't go away.  Note also that on the	;092
; GPK, the clock interrupts at 230, not 100...				;092
;                                                                           

230$:	TSTB	FLGGPK		;Is this a GPK?				;092
	BPL	235$		;No					;092
	MOV	#SESIMR+0,@#I0CSR ;Yes, disable the GPK-380 clock	;092
				;   interrupt to 234 (leave 230)	;092
	MOV	#CLAIRR,@#I0CSR	;Cancel any active interrupt requests	;092
	MOV	#CLAIRR,@#I1CSR						;092
	MOV	#CLAIRR,@#I2CSR						;092
235$:	CLR	R0		;Preset R0 to say nothing happened.	;084
	MOV	#240$,TRPSET	;We'll catch all interrupts ourselves.	;084
	MOVB	#PR0,@#PS	;Now, enable all interrupts!!		;084
	NOP			;Give 'em a chance to happen.		;084
240$:	MOVB	#PR7,@#PS	;Turn interrupts back off...		;084
	MOV	#UNXTRP,TRPSET	; ...and restore the old trap catcher.	;084
	TST	R0		;Did we get any interrupts?		;084
	BEQ	260$		;No, so on with the show!!		;084
	CMP	R0,#100		;If we got one, was it from the clock?	;084
	BEQ	230$		;Yup, so go try again.			;084
				;R0 = vector of unexpected interrupt.	;084
	MESSAG	<"Unexpected interrupt through the vector at ">		;092
	CALLX	OCT3DG		;Print vector as 3-digit octal		;092
	BR	230$		;Go back and try again.			;084

260$:	MOV	#TRAPPR,@#4	;Point vector at 4 to TRAPPER.		;080
	TST	JCPTYP		;Are we on a J11 CPU chip (not GPK)?	;088
	BEQ	270$		;No, so skip these tests.		;096
	;CLC			;Clear C from TST above.		;080
	MOVB	#377,@#177524	;Turn off the Boot and Diagnostic	;080
				; Display (if any).			;080
	ROR	J11BDR		;Rotate carry into J11/BDR flag.	;080
	;CLC			;Clear C from ROR above.		;096
	BIT	#37,@#177734	;Is Unibus memory present on this CPU?	;096
	BLOS	270$		;No, or register is not there.		;096
				; (BLOS = BCS or BEQ)			;096
	MESSAG	<"Unibus memory is not supported on this system."<200>>	;096
				;Say that the configuration is illegal.	;096
	CALLX	MESSAG,R5,INITOK;But say that INIT will continue.	;096
	MOV	SP,NOSTAR	;Don't let timesharing be started.	;096

	TMPORG	ROOCTL		;Save away our global.			;080
J11BDR::.WORD	100000		;This is minus if no J11 BDR present.	;080
JCLKCS::.WORD	-1		;This is -1 unless KDJ11-B or E		;117
	UNORG								;080

GLOBAL	<INITOK,NOSTAR>							;096

.SBTTL	Clock checkout code

270$:	TSTB	FLGGPK		;Is this a GPK?				;092
	BEQ	290$		;No, so normal clocks			;092
	TST	@#CLKCS0	;Is the clock there?			;092
	NOP			; Let the 'CCs' on some CPUs catchup	;117
	BCC	280$		;Yes, as it should be			;092
	JMP	720$		;What, no clock???			;092
                                                                            
280$:	MOV	#64.,LINFRQ	;Funny line frequency			;092
	JMP	FNDOPT		; and done with all clock stuff		;092

290$:	CMP	CPTYP,#3	; 11/23 or 11/24? (KDF11 CPU)		;122
	BEQ	296$		; Yes - so NO J-11 changer		;122
	CMP	JCPTYP,#1	; KDJ11-A?				;122
	BEQ	296$		; No J-11 compatible clock changer	;122
	TST     @#177520        ;Is there a J clock change CSR?         ;120
        NOP                     ; Let the CCs on some CPUs catchup      ;120
        BCS     296$            ;No, there is no clock changing CSR     ;120
	CMP	JCPTYP,#2	;A KDJ11-B?				;117
	BEQ	294$		; Yes, so set up the flag		;117
	CMP	JCPTYP,#5	; No, howabout a KDJ11-E		;117
	BEQ	294$		; Yes, so set up the flag		;122
	TST	@#CHEERR	;OK, cache error register?		;122
	BCS	296$		; NO, then not a QED 11/70		;122
	TST	@#CHEERL	; how about an error address register	;122
	BIT	@#CHEERM,R1	;  (but check both parts of it)		;122
	BCS	296$		;  No, then not a QED 11/70		;122
294$:	CLR	JCLKCS		;Yes, there is a J-11 CLOCK CSR 	;117
296$:	CLRB	KW11L		;ASSUME THERE'S A KW11-L CLOCK		;092
	MOV	#LKS,R1		;POINT TO IT
	CLR	R2		;CLEAR COUNTER LSB
	MOV	#200.,R3	;RUNS FOR ABOUT 20 SEC ON 11/70		;117
	MOV	R2,(R1)		;CLEAR THE TICKER (WITHOUT READING IT!!!)
	TST	(R1)		;WAS IT REALLY CLEARED?
	NOP			; Let the 'CCs' on some CPUs catchup	;117
	BCC	300$		;AT LEAST IT EXISTS...
	MOV	#PKS,R0		;ELSE POINT TO KW11-P CLOCK
	TST	(R0)		;IS THERE A P CLOCK?
	NOP			; Let the 'CCs' on some CPUs catchup	;117
	BCC	360$		;MARK KW11-L CLOCK AS NON-EXISTENT IF P CLOCK
	MOV	#JUNK,R1	;ELSE SET L CLOCK POINTER TO JUNK
300$:	MOV	#100,(R1)	;INTERRUPT ENABLE THE L CLOCK
	MOV	#3,R4		;GET 3 INTERRUPTS TO GET IN SYNC	;117
310$:	MOV	#380$,TRPSET	;CATCH UNEXPECTED TRAPS OURSELVES
	MOVB	#PR5,@#PS	;ALLOW L CLOCK TO INTERRUPT
320$:	SOB	R2,320$		;COUNT LSB OF THIS GROSS TIMEOUT
	SOB	R3,320$		;COUNT MSB OF THE TIMEOUT
330$:	MOVB	#PR7,@#PS	;GO BACK TO PR7 BY NOW
	MOV	#UNXTRP,TRPSET	;RESTORE UNEXPECTED TRAP HANDLING
	CLR	(R1)		;CLEAR OUT L CLOCK AGAIN
	TST	JCLKCS		;IS there a clock changing CSR?		;117
340$:	BEQ	370$		; YES, SO DO SOMETHING SPECIAL		;075
350$:	MESSAG	<"KW11-L doesn't work."<200>>
360$:	COMB	KW11L		;MARK KW11-L AS NONEXISTENT
	BR	440$		;CONTINUE

370$:	MOV	#NOP,340$	;MAKE SURE WE DON'T DO THIS AGAIN	;075
	BIC	#36000,@#177520	;TURN THE CLOCK ON TO			;075
	BIS	#4000,@#177520	; 60Hz crystal clock			;117
	MESSAG	<"RSTS/E requires ">,RSTREQ ;Tell them we require	;092
	MESSAGE	<"a clock">,CLKMSG					;075
	MESSAGE	<", enabling KW11-L at 60Hz."<200>>			;117
	BR	296$							;085

; Prior to V10.0 the above code changed it to Line Frequence.  This	;117
; was changed in V10.0 due to a short term problem where some 11/84	;117
; power supplies were loosing the LTC signal, which "broke" the Line	;117
; Frequency clock.  Now we use the crystal, so it will continue to	;117
; work properly even if the LTC is broken.				;117


380$:	MOV	#UNXTRP,TRPSET	;RESTORE UNEXPECTED TRAP HANDLING
	CMP	(SP),#320$	;THE INTERRUPT WE WANT?
	BLO	390$		;NOPE
	CMP	(SP),#330$	;REALLY?
	BHIS	390$		;NOPE
	CMP	R0,#100		;VECTORED TO 100??
	BEQ	400$		;YEP, ALL O.K.
390$:	JMP	UNXTRP		;GO DIE...

400$:	DEC	R4		;DO IT ENOUGH TO SYNC WITH THE CLOCK	;075
	BNE	310$		; NOT ENOUGH YET, TRY AGAIN		;075
	MOV	(R1),R0		;SAVE THE CSR STATUS			;075
	CMP	(SP)+,(SP)+	;YEP, POP THE PC/PS (WE'RE AT PR7 AGAIN)
	CMP	JCPTYP,#4	;ARE WE A KDJ11-D?			;075
	BEQ	420$		; YES, SO WE KNOW ITS A Q		;075
	CMP	R0,#-1		;IS IT THE FUNKY MXV CLOCK?		;075
	BNE	410$		; NO, SO CONTINUE CHECKING		;075
	CLR	R0		; YES, SO FAKE AS Q CLOCK		;075
	INCB	KW11L		;  BUT LET US TELL THE DIFFERENCE LATER	;075
410$:	TSTB	R0		;A REAL L CLOCK?			;075
	BMI	430$		;YES
	TST	JCLKCS		;HOW ABOUT A KDJ11-B/E?			;117
	BNE	420$		;NO, SO ITS A Q THEN			;075
	CMP	R1,#JUNK	; YES, BUT IS IT LIKE A U OR Q CLOCK	;075
	BNE	430$		;ITS A U CLOCK				;075
420$:	INCB	KW11L		;NO, Q-BUS L CLOCK
430$:	MOV	R1,LKSCSR	; AND REMEMBER THE CSR POINTER
	CLR	(R1)		;TURN L CLOCK OFF AGAIN
	TST	(R1)		;REALLY TURN OFF?			;075
	BEQ	440$		;YES, SO EVERYTHING IS FINE		;075
	TSTB	KW11L		;REAL KW11-L?				;075
	BEQ	350$		; YES, SO BROKEN!			;075

GLOBAL	<LKSCSR,DECSTR>							;084


440$:	CLRB	KW11P		;ASSUME THERE'S A KW11-P CLOCK
	MOV	#PKS,R0		;POINT TO IT
	TST	(R0)		;IS IT THERE?
	BCS	510$		;NO, MARK AS MISSING
	CLR	(R0)+		;STOP CLOCK IF IT'S RUNNING
	MOV	#^C0,(R0)	;START COUNTER AT 177777
	MOV	#13,-(R0)	;GO, 10 KHZ, DOWN, REPEAT
	CMP	(R0)+,(R0)+	;SKIP TO COUNTER REGISTER
	TSTB	KW11L		;IS THERE A REAL KW11-L CLOCK?
	BEQ	460$		;YES -- USE IT FOR TIMEOUT
	CLR	R2		;NO -- USE CPU FOR TIMEOUT
	MOV	(R0),R4		;SAVE PRESENT COUNT ON CLOCK
	MOV	#200.,R3	;RUNS ABOUT 20 SEC ON 11/70		;117
450$:	CMP	R4,(R0)		;WAIT FOR COUNTER TO CHANGE
	BNE	520$		;IT DID -- CLOCK IS OK
	SOB	R2,450$		;COUNT LSB OF THIS GROSS TIMEOUT
	SOB	R3,450$		;COUNT MSB OF THIS TIMEOUT
	BR	500$		;EXPIRED -- KW11-P DOESN'T WORK

460$:	MOV	#3,R2		;USE BOTH CLOCKS TO DETERMINE LINE FREQUENCY
	CLR	(R1)		;GET IN SYNCH WITH KW11-L
470$:	TSTB	(R1)		;PROCEED ONLY WHEN IT TICKS
	BPL	470$
	MOV	(R0),R3		;GET KW11-P COUNTER VALUE
480$:	CLR	(R1)		;WAIT FOR 3 TICKS OF KW11-L
490$:	TSTB	(R1)		;HAS KW11-L TICKED?
	BPL	490$		;NO -- KEEP WAITING
	SOB	R2,480$		;YES -- COUNT, AND RESET KW11-L
	;CLR	R2		;MSB DIVIDEND = 0
	MOV	(R0),R4		;GET KW11-P COUNTER VALUE
	SUB	R3,R4		;DETERMINE DIFFERENCE
	BEQ	500$		;NONE -- KW11-P DOESN'T WORK
	CALL	VBCHK		;First-time boot??			;102
	BCC	520$		;No -- Don't set line frequency.	;102
	MOV	#30000.,R3	;R2,R3 = 10 KHZ * 3 LINE CYCLES
	DIV	R4,R2		;DIVIDE BY NUMBER OF KW11-P TICKS
	MOV	#60.,LINFRQ	;ASSUME RESULT IS ABOUT 60 HZ
	SUB	#40.,R2		;SEE IF ...
	CMP	R2,#15.		;40 <= HZ < 55  ??
	BHIS	520$		;NO -- USE 60 HZ			;075
	MOV	#50.,LINFRQ	;YES -- USE 50 HZ
	BR	520$		;SKIP OUT

500$:	MESSAG	<"KW11-P doesn't work."<200>>
510$:	COMB	KW11P		;MARK KW11-P AS NONEXISTENT

520$:	TST	JCLKCS		;IS there a clock changing CSR?		;117
	BNE	FNDOPT		; NO, SO CAN'T FIND HERTZ USING IT.	;075
	MOV	#177520,R5	;GET A FREQUENTLY USED CSR ADDRESS	;075
	MOV	(R5),R0		;Save the current clock status.		;075
	NOP			; Let the 'CCs' on some CPUs catchup	;117
	BCS	FNDOPT		;Oops, no clock changing CSR present!	;085
	CMP	R1,#JUNK	;DID WE FIND THE Q VERSION BEING USED	;075
	BEQ	530$		; YES, SO LEAVE FORCE INTERRUPT ALONE	;075
	BIC	#20000,R0	; NO, SO CLEAR FORCE INTERRUPT		;075
	MOV	R0,(R5)		;make sure FRC LCIE is cleared in BCSR	;108
530$:	MOV	#LKS,R1		;now make sure we POINT TO IT		;075
	MOV	#6000,R4	;TWO BITS TO CHECK FOR			;075
	BIC	R0,R4		;TRY TO CLEAR THEM BOTH			;075
	BNE	540$		; OK, BOTH DIDN'T CLEAR			;075
	MOV	#800.,LINFRQ	;Set the frequency to 800		;117
	BR	FNDOPT		; and we're all done			;117

	MESSAG								;075
         .ASCIZ "800 Hz clock invalid, using 60Hz."<200>		;117
	UNORG								;075
	BIC	#6000,R0	;NOW, CHANGE IT TO LINE FREQUENCY	;075
	BIS	#4000,R0	;Now select the 60HZ internal clock 	;117
	MOV	R0,(R5)		;Restore fixed clock stuff		;117
540$:	MOV	#60.,LINFRQ	;assume line freq is 60 HZ		;108
	BIT	#4000,R0	;Is the 60HZ internal clock selected?	;108
	BNE	FNDOPT		;Yes, don't calc speed of line clock.	;108
	BIT	#2000,R0	;Is the 50HZ internal clock selected?	;108
	BNE	610$		;Yes, don't calc speed of line clock.	;108
	BIC	#30000,(R5)	;Enable the line clock for calculation	;108
	CLR	R4		;START WITH NO COUNT HERE		;075
550$:	MOV	#3,R2		;USE 2 RATES TO DETERMINE LINE FREQ.	;075
	CLR	(R1)		;GET IN SYNCH WITH KW11-L		;075
	MOV     R5,-(SP)        ;Get a register to use as a counter     ;117
	MOV     R0,-(SP)        ; a real big counter                    ;117
	CLR     R0              ; starting at 0                         ;117
	MOV     #200.,R5        ;RUNS ABOUT 20 SEC ON 11/70             ;117
560$:	TSTB	(R1)		;PROCEED ONLY WHEN IT TICKS		;075
        BMI     565$            ; It ticked!                            ;117
        SOB     R0,560$         ; It didn't, so count it.               ;117
        SOB     R5,560$         ; lets give it plenty of time           ;117
        MESSAG                                                          ;117
         .ASCIZ "Line clock broken, using 60Hz."<200>			;117
        UNORG                                                           ;117
        BIS     #4000,(SP)      ;Select the 60HZ internal clock         ;117
        MOV     (SP)+,@(SP)+    ; and put it back in the H/W            ;117
        BR      FNDOPT          ; and exit                              ;117

565$:   MOV     (SP)+,R0        ;Done counting, so restore the register ;117
        MOV     (SP)+,R5        ; and don't forget the other one        ;117
570$:	CLR	R3		;GET A COUNTER VALUE			;075
	CLR	(R1)		;WAIT FOR 3 TICKS OF KW11-L		;075
580$:	ADD	#1,R3		;AND INC THE COUNTER (SLOWLY)		;075
	TSTB	(R1)		;HAS KW11-L TICKED?			;075
	BPL	580$		;NO -- KEEP WAITING			;075
	SOB	R2,570$		;YES -- COUNT, AND RESET KW11-L		;075
	TST	R4		;DID WE SAVE IT YET?			;075
	BNE	590$		;YES, SO COMPARE THEM			;075
	MOV	R3,R4		;SAVE LINE RATE IN R4			;075
	BIS	#2000,(R5)	;NOW, TRY IT AT 50 HZ (SAVE INTO R3)	;075
	BR	550$		; AND DO IT AGAIN			;075

590$:	MOV	R0,(R5)		;Restore original clock stuff		;075
	MOV	R3,JCPSPD	;STORE TO CALCULATE CPU SPEED LATER	;075
			;						;108
			; NOTE:  JCPSPD will NOT be calculated when 	;108
			; using the on board clock.			;108
			;						;108
	;
	;	R3 = 50 Hz
	;	R4 = Line Frequency
	;
	;	CPU Clock Freq		at 60Hz, R4 ~=	at 50Hz, R4 ~=
	;
	;	15.206 Mhz		12236		14277
	;	15.361 Mhz		12325		14400
	;	18.000 MHz		14154		16512
	;
	SUB	R3,R4		;USING LINE, SO CALC DIFFERENCE		;075
	BPL	600$		;IF POSITIVE, THEN JUST USE IT		;075
	NEG	R4		; ELSE MAKE IT POSITIVE			;075
600$:	ASH	#-4,R3		;DIVIDE BY 16. (ABOUT 6%)		;075
	CMP	R4,R3		; IS IT WITHIN 6% OF THE 50HZ VALUE?	;075
	BHI	FNDOPT		;NO, ITS UP IN THE 60HZ RANGE		;075
610$:	MOV	#50.,LINFRQ	;SET RESULT AS 50HZ			;075


FNDOPT:	MOV	#-1,R5		;Assume Date format of alphabetic	;117
	CMP	LINFRQ,#50.	;Is this a 50 Hertz system?		;117
	BNE	611$		; No, so leave the defaults alone	;117
	NEG	R5		;Make it +1 for European format		;117
611$:	MOV	R5,D.DATF	;Set the Date format			;117
	MOV	R5,D.TIMF	; and the time format also		;117
	MOV	#HWTABL,R5	;R5 -> TABLE OF HARDWARE OPTIONS	;075
	CMP	JCPTYP,#5	;Is this a KDJ11-E?			;117
	BEQ	612$		; Yes, then it's faking the cache	;117
	TSTB	FLGGPK		;Is this a GPK?				;092
	BPL	615$		;No, skip				;092
612$:	MOV	#0,@#CHECTL	;Don't let the J-11 run in slow mode	;117
	MOV	#200*400+200,(R5)+ ;Yes, never cache (even though they	;092
				; look like they have cache)		;092
.ASSUME	CACHE-INSBUF&1 EQ 0						;092
.ASSUME	CACHEA EQ CACHE+1						;092
	BR	655$		; and skip ahead			;092

615$:	CLR	R0		;ASSUME CACHE IS TO BE ENABLED		;092
	TST	@#CHEERR	;IS THERE A MEMORY SYSTEM ERROR REGISTER?
	MOV	@#CHECTL,R1	;AND ALSO A CACHE CONTROL REGISTER?
.ASSUME	CACHE	EQ	HWTABL
	RORB	(R5)+		;SET FLAG IF NOT
	BMI	640$		;SKIP OUT IF NO CACHE
	BIT	R1,#44		;ANY BITS SET TO DISABLE GROUP 0?
	BEQ	620$
	BIS	#44,R0		;YES -- SET THEM ALL
620$:	BIT	R1,#30		;ANY BITS SET TO DISABLE GROUP 1?
	BEQ	630$
	BIS	#30,R0		;YES -- SET THEM ALL
630$:	MOV	R0,@#CHECTL	;SET THE BITS IN THE CONTROL REGISTER
640$:	MOV	R0,CCTVAL	;SET VALUE TO JAM TO MONITOR
	BEQ	650$		;NONE DISABLED -- SKIP
	CALL	CHENAM,R5	;CACHE (PARTIALLY) DISABLED -- SAY SO
	 GENTXT	<" disabled at startup">
650$:	TST	@#CHEERL	;CHECK FOR BOTH WORDS OF
	BIT	@#CHEERM,R0	; CACHE PARITY ADDRESS INFORMATION
.ASSUME	CACHEA	EQ	CACHE+1
	RORB	(R5)+		;SET FLAG FOR CACHE PARITY ADDRESS
655$:	CLR	R0		;SET FLAG FOR NO MEMORY SIZE REGISTER
	TST	@#CPUSZL	;TRY TO GET MEMORY SIZE
	NOP			; Let the 'CCs' on some CPUs catchup	;117
	BCS	660$		;THERE IS NONE
	MOV	@#CPUSZL,R0	;GET MEMORY SIZE AS MAXIMUM P.A.R. BLOCK
	INC	R0		;MAKE THAT FIRST ILLEGAL 32-WORD BLOCK
	ASH	#6.-11.,R0	;CONVERT TO NUMBER OF K (ROUNDING DOWN)
	BIC	#^C<3777>,R0	;TRIM BITS
.ASSUME	HWSIZE	EQ	CACHEA+1
660$:	MOV	R0,(R5)+	;SET MEMORY SIZE OR 0

; Perform the memory-size algorithm.  If Q-bus, complete algorithm is	;018
; done here.  If UNIBUS, algorithm is done when test for UMR is made.	;018

	CLRB	FLG22		;Assume 22-bit addressing & memory > 248 KB ;018
	TSTB	FLGQBU		;IS SYSTEM USING Q-bus?	
	BMI	700$		;NO, SKIP THIS ALGORITHM (FLG22 WILL BE SETUP LATER)
	MOV	#BIT18,@#4	;SET TRAP4 TO 18-BIT ADDRESSING (IF MMUSR3 GONE)
	MOV	#123456,@#0	;PUT KNOWN PATTERN INTO LOC 0
	MOV	#10000,@#KISAR6	;WINDOW APR6 INTO 1000000-1017777 REAL MEMORY
	MOV	#20,@#MMUSR3	;Enable 22-bit addressing (trap if none) ;097
	MOV	#BIT22,@#4	;SET TRAP4 TO 22-BIT ADDRESSING
	MOV	#1,@#MMUSR0	;TURN ON THE MMU
	MOV	#070707,@#140000 ;TRY TO PUT PATTERN IN 1ST WORD ABOVE 256KB
	CMP	@#0,#123456	;DOES LOC 0 STILL HAVE ITS PATTERN?
	BNE	670$		;NO, WE MAY HAVE 18-BIT ADDRESSING
	CMP	@#140000,#070707 ;DOES HIGH MEMORY STILL HAVE ITS PATTERN?
	BNE	680$		;NO, ALARM
	BR	700$		;Yes, we have 22-bit addressing & > 256KB ;018

BIT22:	CMP	(SP)+,(SP)+	;REMOVE TRAP STUFF FROM STACK
	MOV	#SMLMEM,@#4	;Set up for test of 248KB		;018
	MOV	#7600,@#KISAR6	;Window APR6 into 760000-777777 physical;018
	MOV	#070707,@#140000 ;Is memory > 248KB? (TRAP4 if not)	;018
	CMP	#070707,@#140000 ;Yes, is it good memory?		;018
	BNE	680$		;No, alarm				;018
	BR	700$		;Yes, done				;018

SMLMEM:	CMP	(SP)+,(SP)+	;No, remove trap stuff from stack	;018
	BISB	#1,FLG22	;  and flag physical memory <= 248KB	;018	
	BR	700$		;Done					;018

670$:	CMP	@#0,#070707	;DOES LOC 0 HAVE PATTERN FROM HIGH MEMORY?
	BEQ	690$		;YES, WE HAVE 18-BIT ADDRESSING
680$:	CLR	@#MMUSR0	;TURN OFF MMU AND ALARM
	ERF	<"Memory addressing problem">

BIT18:	CMP	(SP)+,(SP)+	;REMOVE TRAP STUFF FROM STACK
690$:	MOVB	#201,FLG22	;18-BIT ADDRESSING

700$:	CLR	@#MMUSR0	;TURN OFF MMU
	MOV	#TRAPPR,@#4	;END OF MEMORY-SIZE ALGORITHM

; CONTINUE CHECKING FOR HARDWARE OPTIONS

	MOV	#5600,@#KISAR6	;WINDOW APR6 INTO 560000-577777 REAL MEMORY ;045
	MOV	#1,@#MMUSR0	;TURN ON THE MMU
	TST	@#157776	;TRY FOR THE LAST WORD WITHIN 96K
	NOP			; Let the 'CCs' on some CPUs catchup	;117
	BCC	710$		;GOT IT
	CALLX	MESSAGE,R5,RSTREQ 	;     "RSTS/E requires 96K words"
	ERF	<<176>"at least 124K words of memory">

710$:	CLR	@#MMUSR0	;OFF THE MMU
.ASSUME	KW11P	EQ	HWSIZE+2
.ASSUME	KW11L	EQ	KW11P+1
	CMP	(R5)+,#-1	;DOES HE HAVE A CLOCK AT ALL?
	BNE	730$		;WE REQUIRE A CLOCK
	TSTB	FLGGPK		;Is this a GPK?				;092
	BMI	730$		; Yes, it just looks a little different	;092
	TST	JCLKCS		;Can it be changed?			;117
	BNE	720$		; NO, SO JUST GIVE THE ERROR		;075
	MESSAGE	<"Enable clock CSR via the Boot ROM setup."<200>>	;075
720$:	CALLX	MESSAGE,R5,RSTREQ 	;     "RSTS/E requires a clock"
	CALLX	MESSAGE,R5,CLKMSG	;				;075
	ERF	<<176>"!">

730$:	TST	@#SL		;DOES HE HAVE STACK LIMIT?
.ASSUME	STAKLM	EQ	KW11L+1
	ROR	(R5)+		;SET <0 IF NOT
	MOV	#TRAPPR,@#10	;Point vector at 10 to TRAPPER		;117
	MOV	#3,R1		;TRY DOING AN EIS INSTRUCTION
	; Most bootstraps, and TOYCLK have already used EIS instructions.
	MUL	R1,R1		;I.E. 3*3
	BCS	740$		;THAT TRAPPED, SO NO EIS
	CMP	#9.,R1		;IT DIDN'T TRAP, BUT DID IT WORK?
	BEQ	750$		;EIS IS FINE
	MESSAGE	<"MUL didn't work">	; OH no, it doesn't work	;075
740$:	CALLX	MESSAGE,R5,RSTREQ 	;     "RSTS/E requires EIS!"
	ERF	<<176>"EIS!">
750$:	TSTF	%0		;DO WE HAVE AN FPP?
.ASSUME	FPU	EQ	STAKLM+2
	ROR	(R5)+		;SET <0 IF NOT
	MOV	SP,R1		;SAVE THE SP FOR A SEC
	CLR	-(SP)		;MAKE ROOM FOR POSSIBLE FIS POP
	CLR	-(SP)
	CLR	-(SP)
	CLR	-(SP)
	FADD	SP		;DO AN FIS THING
	MOV	R1,SP		;RESTORE THE STACK
.ASSUME	FIS	EQ	FPU+2
	ROR	(R5)+		;AND SET <0 IF NO FIS
	TST	@#SWR		;TRY TO READ THE SWITCHES
.ASSUME	SWR$R	EQ	FIS+2
	RORB	(R5)+		;SET <0 IF NO SWITCHES
	CLC			;PRECLEAR THE CARRY
	MOV	#0,@#SWR	;TRY TO WRITE LIGHTS (NOTE: 'CLR' DOES DATAI)
.ASSUME	SWR$W	EQ	SWR$R+1
	RORB	(R5)+		;SET <0 IF NO LIGHTS
.ASSUME	MEDINS	EQ	SWR$W+1
	MOV	#100000,(R5)+	;INDICATE NO 'MED' INSTRUCTION
	MOV	#760$,@#10	;SET UP VECTOR AT 10
	.WORD	076600,22	;TRY TO DO A 'MED'
	BIC	#200,R0		;IT WORKED, R0 = WHAMI
	.WORD	076600,222	;WRITE IT BACK (DISABLE WCS FOR INIT)
	CLR	-2(R5)		;EGAD, IT WORKED
760$:	MOV	#TRAPPR,@#10	;RESTORE VECTOR AT 10 (to catch them)
.ASSUME	CACHES	EQ	MEDINS+2
	CLR	(R5)+		;ASSUME NO SWEEP WHEN ENABLING CACHE
	TSTB	CACHE		;IS THERE A CACHE?
	BMI	770$		;NO, NEVER SWEEP IT
	TST	MEDINS		;**KLUDGE** SWEEP CACHE ON 11/60 ONLY
	BMI	770$		;NO CACHE SWEEP REQUIRED
	MOV	#10000,-2(R5)	;AMOUNT = 2* SIZE IN BYTES (11/60 = 2K **KLUDGE**)
.ASSUME	REGST1	EQ	CACHES+2
770$:	CLRB	(R5)+		;ASSUME REGISTER SET 1 EXISTS
	BIS	#4000,@#PS	;SET REGISTER SET 1 (IT SHOULD BE ON ALREADY!)
	BIT	#4000,@#PS	;DO WE HAVE IT?
	BNE	780$		;YES
	COMB	-1(R5)		;NO, SET FLAG
780$:	CLC			;Guess at having MMUSR3			;097
	MOV	#20,@#MMUSR3	;And enable it				;097
.ASSUME	KTUSR3	EQ	REGST1+1
	RORB	(R5)+		;SET FLAG IF NONE
	TST	@#CPUSID	;IS THERE A SYSTEM ID REGISTER?
.ASSUME	CP.SID	EQ	KTUSR3+1
	RORB	(R5)+		;FLAG IT
	TST	@#1		;DOES CPU ODD ADDRESS TRAP
.ASSUME	ODD.AD	EQ	CP.SID+1
	RORB	(R5)+		;FLAG IT
	MOV	#2,R0		;SET LENGTH FOR MOVC INSTRUCTION
	MOV	#830$,R1	;SET SOURCE ADDRESS FOR STRING
	MOV	R0,R2		;SET LENGTH OF DESTINATION
	MOV	#840$,R3	;SET DESTINATION ADDRESS FOR STRING
	CLR	R4		;AND SET FILL TO ZERO
	MOVC			;CIS MOVE CHARACTER INSTRUCTION
	BCS	800$		;DIDN'T WORK (don't have it)
	CMP	#"YE,830$	;DID IT CHANGE THE SOURCE
	BNE	790$		;THEN IT CAN'T BE WORKING CORRECTLY
	CMP	#"SY,840$-1	;DID IT MOVE THE FIRST PART CORRECTLY?
	BNE	790$		;NO, THEN IT MUST BE SICK
	CMP	#"E!,840$+1	;DID IT MOVE THE REST IN CORRECTLY
	CLC			;ASSUME EVERTHING WILL WORK OUT
	BEQ	810$		;BY GEORGE, WE'VE GOT CIS
790$:	MESSAGE	<"MOVC didn't work!"<200>>
	MESSAGE <"RSTS/E will not use CIS."<200>>
800$:	SEC			;IT DIDN'T WORK
.ASSUME	CISINS	EQ	ODD.AD+1
810$:	RORB	(R5)+		;SET THE FLAG
	MOV	#TRAP.10,@#10	;RESTORE VECTOR AT 10 (to give errors)
	CLRB	(R5)		;CLEAR FLGUMR<0>
	TST	@#UNIWIN	;SEE IF THERE ARE UNIBUS WINDOWS
.ASSUME	FLGUMR	EQ	CISINS+1
	RORB	(R5)+		;YES, SET UMR
.ASSUME	FLGQBU	EQ	FLGUMR+1
	TSTB	(R5)+		;DO I HAVE A Q-bus? (FLGQBU IS ALREADY SET UP)
.ASSUME FLG22	EQ	FLGQBU+1
	BPL	820$		;YES, THEN FLG22 IS ALREADY SET UP
	MOVB	FLGUMR,(R5)	;NO, FLG22 IS COPY OF FLGUMR PLUS BIT 0
	BPL	820$		;UMR means memory > 248 KB (by definition);018
	BISB	#1,(R5)		;No UMR means memory <= 248KB		;018
820$:	TSTB	(R5)+		;BUMP POINTER PAST FLG22
	TST	@#KDSAR0	;D-SPACE APR'S PRESENT?
.ASSUME	DSHARD	EQ	FLG22+1
	RORB	(R5)+		;SET SIGN BIT IF NOT
.ASSUME	CP.ERR	EQ	DSHARD+1
	TST	@#CPUERR	;IS THERE AN ERROR REGISTER?
	RORB	(R5)		;FLAG IT
.ASSUME	CP.ERW	EQ	CP.ERR+1
	MOVB	(R5)+,(R5)	;FLAG WRITING ERROR REGISTER THE SAME WAY
	BPL	850$		;IF THERE IS ONE, CONTINUE
	JMP	NO1160		;NO, NO PROBLEM

830$:	.BYTE	'Y,'E,'S	;TEST DATA FOR CIS
840$:	.BYTE	'@,'@,'!	;WHERE TO PUT THE TEST DATA
	.EVEN			;LETS BE DOUBLY SURE OF OURSELVES

850$:	JMP	CHK1160		;THIS MAY BE FAR AWAY

.DSABL LSB

.SBTTL	TOY clock reader

.ENABL LSB

;+									;092+
; This routine reads the Time of Year clock (aka. TOY clock)
; and sets the RSTS date/time accordingly.  If no valid date/time is
; found, or the "dead battery" flag is set, the date/time info is
; invalidated to force new date/time info to be entered -- which will
; reset the TOY clock.  (See ASKDAT, ASKDAY and ASKTIM.)
;
;	The location of this routine does not matter a whole lot.
;	It was put here because there was room just before the 11/60 ECO
;	check code.  If things change, and SATBUF code gets to big, this
;	code can be moved (in part or whole).
;
; Entry:
;	R0 ->	TIMSEC, TIME, DATE
;
; Exit:
;	R0	Preserved
;	R1-4	Munged
;+

TOYCLK:	TSTB	FLGGPK		;Is this a GPK?
	BNE	10$		;Yes, so it has a TOY clock		;117
	CMP	JCPTYP,#5	;Are we a KDJ11-E?			;117
	BNE	8$		; No, so we don't have a TOY		;117
	CALL	TOYINI		;Go initialize the TOY clock		;117
	MOV	#JTOYD,R2	;Pass J-11 TOY data area pointer	;117
	CALL	TOYGET		; and read what it has to say		;117
	MOV	#JTOYD,R2	;Get the J-11 TOY data area pointer	;117
	MOV	#80$,R3		;Get destination and bounds checks	;117
2$:	MOVB	(R2)+,R1	;get a byte from the data area		;117
	CMP	(R3),#TOYHR	;is this the funny hour field?		;117
	BNE	4$		; No, go continue normally		;117
	BITB	#200,R1		; Is it AM/PM?				;117
	BEQ	4$		;  No.					;117
	BIC	#240,R1		;  Yes, so leave just the raw number	;117
4$:	CALL	BCDBIN		;Now convert to binary			;117
	CMP	(R3),#TOYHR	;Was that the hour we just converted?	;117
	BNE	6$		; No, so life is easy			;117
	BITB	#200,JTOYD+3	; Yes, was it AM/PM time?		;117
	BEQ	6$		;  No, so life stays easy		;117
	CMP	R1,#12.		;  Is it 12AM or PM?			;117
	BNE	5$		;   No, so calculations are easy	;117
	CLR	R1		;   Yes, make it 0			;117
5$:	BITB	#40,JTOYD+3	;   Now, is it PM?			;117
	BEQ	6$		;    No, its AM, so life stays easy	;117
	ADD	#12.,R1		;    Yes, so make it 24 hour		;117
6$:	MOV	R1,@(R3)+	; so we can store it away to use later	;117
	CMP	(R3)+,(R3)+	;but skip the bounds checks for now	;117
	TST	(R3)		;Any more to do?			;117
	BNE	2$		;Yes, do all the bytes			;117
	BIC	#^C<7>,TOYDAY	;Cleanup any flag bits here.		;117
	MOV	#80$,R1		;Assume the KDJ11-E			;117
	CLR	R3		;start with a 0 offset to copy		;117
	BR	15$		; and continue with common code		;117

8$:	BR	50$		; and now we're all done.		;117

10$:	TSTB	@#CLKCS0	;Check "update in progress" flag
	BMI	10$		;Loop if set
.ASSUME	UIP EQ 200
	MOV	#DV1!^B<1010>,@#CLKCS0 ;Set divider control and rate = 64 Hz
	MOV	@#CLKCS1,R1	;Get mode flags
	BIC	#^C<DSE!CLK24!CLKBIN>,R1 ;We want these three flags
	CMP	R1,#CLK24!CLKBIN ;Should be binary, 24 hour, no DST
	BNE	40$		;Something else we can't hack
	MOV	#70$,R1		;Point to test table
	MOV	#3*2,R3		;skip the 100ths word			;117
	CLR	TOYSML		; since the GPK doesn't keep those	;117
15$:	ADD	#80$,R3		; And placement table			;117
16$:	TST	(R1)		;Done checking?
	BEQ	18$		;Yes, all ok
	MOV	@(R1)+,R2	;Get this CSR
	CMP	R2,(R1)+	;Too low?
	BLO	40$		;Yes, error
	CMP	R2,(R1)+	;Too high?
	BHI	40$		;Yes, error
	MOV	R2,@(R3)+	;Copy the word into the common area	;117
	CMP	(R3)+,(R3)+	;and skip the bounds checkers		;117
	BR	16$		;Ok so far, go on

18$:	MOV	#60.,(R0)	;Seconds count back from 60
	SUB	@#TOYSEC,(R0)	;Set seconds RSTS style			;117
	MOV	#1440.,2(R0)	;Time counts back from 1440
	MOV	@#TOYHR,R1	;Get hours				;117
	MUL	#60.,R1		; times 60 for minutes
	ADD	@#TOYMIN,R1	;Add in minutes into the hour		;117
	SUB	R1,2(R0)	;Set time RSTS style
	MOV	@#TOYDAT,R3	;Get day of the month			;117
	MOV	@#TOYMON,R2	;Month					;117
	MOV	@#TOYYR,R1	; and year				;117
	CMP	R2,#2		;After February?
	BLOS	20$		;No, so no leap checks
	BIT	#3,R1		;Leap year?
	BNE	20$		;No
	INC	R3		;Yes, advance the day
20$:	MOV	#60$,R4		;Point to month length table
30$:	ADD	(R4)+,R3	;Advance date by length of previous month
	SOB	R2,30$		; and loop until up to this month
	CMP	R1,#99.		;Is it 1999 or strange?			;117
	BHI	40$		; Yes, then its illegal			;117
	CMP	R1,#90.		;Is it 1990 or later?			;117
	BHIS	35$		; YES, so the old way works fine	;117
	CMP	R1,#65.		;  2035 or earlier?			;117
	BHI	40$		;   No, so its illegal.			;117
	ADD	#30.+70.,R1	;Bias the century			;117
35$:	SUB	#70.,R1		;Bias the year
	BLOS	40$		;Oops, bad year
	MUL	#1000.,R1	;Times 1000
	ADD	R3,R1		; plus day makes a RSTS date
	MOV	R1,4(R0)	;Store that
	SEC			; and signal that all is well		;117
	RETURN			;Done

40$:	CLR	2(R0)		;Indicate no valid time
	CLR	4(R0)		; nor date
	MOV	#80$,R1		;Assume the KDJ11-E			;117
	TSTB	FLGGPK		;Is this a GPK?				;117
	BEQ	45$		;No,					;117
	MOV	#70$,R1		;Yes, use the GPK table			;117
	MOV	#SET!CLK24!CLKBIN,@#CLKCS1 ;Force correct clock setting
45$:	CLR	@(R1)+		;Give it an invalid date		;117
	CMP	(R1)+,(R1)+	; skip the bounds check words		;117
	TST	(R1)		;and see if there is more to zero.	;117
	BNE	45$		; Yes, so go zero more			;117
	TSTB	FLGGPK		;Is this a GPK?				;117
	BEQ	50$		;No,					;117
	BIC	#SET,@#CLKCS1	;No longer setting (clearing)
50$:	CLC			;and tell the caller it didn't work	;117
	RETURN

60$:	.WORD	0,31.,28.,31.,30.,31.,30.,31.,31.,30.,31.,30. ;,31.

70$:	.WORD	CLKSEC,0.,59.	;Register, low limit, high limit
	.WORD	CLKMIN,0.,59.
	.WORD	CLKHR, 0.,23.
	.WORD	CLKDAY,0.,7.						;117
	.WORD	CLKDAT,1.,31.
	.WORD	CLKMON,1.,12.
	.WORD	CLKYR,90.,99.	;90 is current year			;117
	.WORD	0		;End of table				;092-

80$:	.WORD	TOYSML,0.,99.	;Register, low limit, high limit	;117
	.WORD	TOYSEC,0.,59.						;117
	.WORD	TOYMIN,0.,59.						;117
	.WORD	TOYHR, 0.,23.						;117
	.WORD	TOYDAY,0.,7.						;117
	.WORD	TOYDAT,1.,31.						;117
	.WORD	TOYMON,1.,12.						;117
	.WORD	TOYYR, 0.,99.	;90 is current year			;117
	.WORD	0		;End of table				;117

.DSABL	LSB

.SBTTL	11/60 ECO Check

.MACRO	I.MESS			;Now, start putting text into SILBUF	;084
	TMPORG	SILBUF		; instead of FIBUF.			;084
	.NLIST	BEX							;084
.ENDM	I.MESS								;084

; THE BR BELOW MUST BE AT AN ADDRESS WITH 3 LOW DIGITS ZERO.
.	= <.-SATBUF+777+4>&177000+SATBUF-4 ;ROUND TO 4 BELOW DESIRED BOUNDARY

CHK1160:CLR	@#CPUERR	;WRITE TO CPU ERROR REGISTER
.IIF	NE	<.-SATBUF>&777,	.ERROR	;MICROCODE BUG DETECTOR REQUIRES THIS
	BR	NO1160		;DIDN'T SKIP, ALL IS WELL
	MESSAG			;SOME 11/60'S HAVE A PROBLEM HERE ...
	 .ASCII	"This PDP-11/60 is missing the following ECO's:"<200>
	 .ASCIZ "  Module M7872: ECO #7   Module M7873: ECO #6"<200><12>
	UNORG
	COMB	(R5)		;DISALLOW WRITING TO THE REGISTER

.SBTTL	RL11 versus RLV11 versus RLV12 sortout

; MODIFY DEVDEF VALUES FOR THE RLV12 AND THE DP11

.ENABL	LSB

NO1160:	TSTB	FLGQBU		;IS THIS A Q-bus SYSTEM?
	BMI	880$		;NO, DON'T MODIFY DEVDEF OR REMOVE ILLEGAL COMBINATIONS
	TSTB	FLGGPK		;Is it actually a GPK?			;092
	BMI	880$		;Yes, no RL on a GPK			;092
	MOV	CSRDEC+RL.CSO,R0;IS A RL DISK ON THE SYSTEM?
	BEQ	880$		;NO
	TST	(R0)
	NOP			; Let the 'CCs' on some CPUs catchup	;117
	BCS	880$		;NO
	TST	RLBE(R0)	;DOES RL HAVE THE 5TH REG?
	NOP			; Let the 'CCs' on some CPUs catchup	;117
	BCS	880$		;NO
	MOV	#2,RLBE(R0)	;IS THIS REGISTER THE 5TH RL REG?
	MOV	(R0),R3
	BIC	#177717,R3
	CMP	R3,#40
	BNE	880$		;NO, IT IS DP30 OR SOMETHING
	MOV	#1,RLBE(R0)
	MOV	(R0),R3
	BIC	#177717,R3
	CMP	R3,#20
	BNE	880$		;NO, IT IS DP30 OR SOMETHING
	MOVB	#16.,RL.PKT+RL.SCS	;CHANGE SIZE OF CSR SET FOR RL11 DISK
	BICB	#PS.UWN,RL.PKT+RL.DHP	;CLEAR PS.UWN BIT FOR RL11 DISK
880$:	CALL	SETNXM		;Set up NXM table and zero memory	;013

.SBTTL	INIT - Buffer and consistency bug checks

; CHECK THAT BUFFERS ARE PROPERLY ALIGNED

	RESETB			;FIX UP LOW MEMORY AGAIN
	MOV	#-1.,CC.DBL	;Disable ^C, we haven't finished booting;075
	MOV	#777,R0		;MASK TO CHECK FOR PROPER ALIGNMENTS
	BIT	R0,#FIBUF	;FIBUF ALIGNED?
	BNE	900$		;NO
	BIT	R0,#INSBUF	;INSBUF ALIGNED?
	BNE	910$		;NO
	BIT	R0,#DEFBUF	;DEFBUF ALIGNED?
	BNE	920$		;NO
	BIT	R0,#SATBUF	;SATBUF ALIGNED?
	BNE	890$		;NO
	CMP	LIMITS+2,#157000 ;DOES ALL OF INIT FIT BELOW BOOTSTRAP?
	BLOS	940$		;YES, GO FINISH CONSISTENCY CHECKS NOW
	ERF	^/"INIT link bug -- high limit > 157000"/,INLINE

890$:	MESSAG	<"FATAL - SATBUF">
	BR	930$

900$:	MESSAG	<"FATAL - FIBUF">
	BR	930$

910$:	MESSAG	<"FATAL - INSBUF">
	BR	930$

920$:	MESSAG	<"FATAL - DEFBUF">
930$:	ERF	<<176>" not aligned. INIT link bug">

LIMITS:	.LIMIT			;FIRST WORD = LOW LIMIT, SECOND = HIGH

940$:	CALL	B.RSET		;Reinitialize the boot loader
	CALLX	SETFIP		;Set up FIP for the I/O
	CMPB	BTDNAM,#'M	;Booted from tape?
	BEQ	950$		;Yes, skip open
	TSTB	SAVDEV		;Running from saveset disk?
	BNE	950$		;Yes, skip the open
	MOV	#FQINIT,R4	;Point to INIT.SYS FIRQB		;012
	CALLX	LOKFIL		;Look up that file			;012
	BCS	960$		;Die if not there			;012
950$:	MOV	#APR5CK,R1	;Check out the disk phase		;025
	CMP	6(R1),#120000	;Is it linked properly?
	BHIS	970$		;So long as it's high enough we're happy
	ERF	<"Disk Phase linked incorrectly">

960$:	ERF	<"INIT.SYS not found">					;012

.SBTTL	Jump into the ONE Shot overlay to finish auto-sizing hardware

970$:	CALL	SETPHZ		;Load & Relocate INIT's phases		;027
	JMPX	INIONE		; Go execute one-shot overlay code

; Note that we JMP to INIONE rather than CALL because in various places
; that code does a RESETB which resets the stack pointer...
; ....INIONE will jump back into SATBUF at ONECNT: when done....	;026

ONECNT::CLR	CC.DBL		;O.K. to enable ^C now			;031
	TSTB	AUTOGO		; Doing streamline startup?		;017
	BNE	1010$		;   Yes, no message (& no auto-restart)	;017
	TSTB	FLGGPK		;Is this a GPK?				;092
	BPL	975$		;No					;092
	CALLX	CTLOGO		;Yes, display "digital" logo		;092
975$:	MOV	#LOGO,R0	;Point to default RSTS logo		;092
	TST	SILNAM		;Is there an installed SIL?		;092
	BEQ	977$		;No					;092
	TST	I.DFLD		;Defaults set up yet?			;092
	BEQ	977$		;No					;092
	MOV	#D.NAME,R0	;Yes, so point to name that was set up	;092
977$:	CALLX	ASCIZ0		;Display the RSTS logo			;092
	CALLX	MESSAG,R5,<ILOGO> ; and then the INIT logo		;092
	CALLX	IDEKIT		; Now print out the identification

; CHECK FOR AUTO-RESTART AND POSSIBLE USER ABORT THEREOF

980$:	TSTB	AUTOQS		;ARE WE AUTO RESTARTING?		;017
	BPL	990$		;NOPE, continue with other checks	;031
	CALLX	MESSAG,R5,1050$	;Yes, tell him of auto-restart.		;095
	TSTB	SWR$R		;DOES HE HAVE A SWITCH REGISTER?
	BMI	1020$		;NO, JUST GO
	TST	SWTREG		;IS IT DISABLED?
	BGT	1020$		;YES, JUST GO
	TSTB	VOLSWR		;YES, BUT IS IT VOLATILE AFTER POWER FAIL?
	BMI	1020$		;AH SO, ITS CONTENTS ARE UNRELIABLE
	BIT	#SW.AUT,@#SWR	;REAL TOGGLES, DOES HE WANT IT AUTO RESTARTED?
	BNE	1020$		;Yes, get the START option running	;031
	CALLX	MESSAG,R5,1060$	;Tell him of the abort.			;095
990$:	TSTB	GOSWIT		;CAN WE GO?
	BEQ	1000$		;No, somethings wrong			;031
	MOV	#-1.,CC.DBL	;Disable ^C, we must have a date & time	;032
	CALL	TYPECR		;Return the Carriage			;035
	CALL	DATINI		;Prompt for Date and Time		;032
	CLR	CC.DBL		;O.K. to enable ^C now			;032
	MOV	#KBUFF,R1	;Set-up a real KB buffer, as ASKER would;026
	CLR	(R1)		;Terminate fake input string with NULL	;026
	TSTB	AUTOST		;Is it an auto START (after re-boot)?	;026
	BNE	1010$		;Yes, Do a FAST START			;031
	TSTB	SAVDEV		;Is this a SAVE/RESTORE DISK?		;031
	BNE	1030$		;Yes, so go to the SAVRES overlay	;031
	TSTB	RODISK		;Is this a Read Only disk?		;031
	BNE	1040$		;Yes, Distro-Kit, so go to DSKINT	;031
	JMP	I.INIT		;Ask to Start or Get an Option.		;031


1000$:	JMP	I.INI0		;Go reset and abort			;031

1010$:	INCB	AUTOQS		;Quick START without any changes	;031
1020$:	CALLX	READCF		;Read the CONFIG.SYS file.		;112
	JMP	START0		;Get the START option running.		;031

1030$:	JMP	SRDIAL		;SAV/RES Disk, get SAVRES running.	;031

1040$:	JMP	I.INST		;Distribution KIT, get DSKINT running.	;031

.NLIST	BEX

1050$:	.ASCII	<200><200><7><7><7><7><7>
	.ASCII	"System has been reloaded; attempting auto-restart."
	.ASCIZ	<200><7><7><7><7><7><200>

1060$:	.ASCIZ	"Auto-restart has been aborted."<200><12>
	.EVEN

GLOBAL	<APR5CK>

.DSABL	LSB

.SBTTL	Move ODT into high memory to use as a phase

.ENABL	LSB

ODTSET:	MOV	#ODTBAS,R1	;ODT phase starts segment #1, so R1 really ->
	CMP	(R1)+,(R1)+	; CALL $OVRH,R5,<overlay #>,<real address> ;092
	CMP	(R1)+,#1*6	;Overlay number better be #1		;092
	BNE	20$		;We can't work if this is not true
	CMP	(R1),#140000	;We depend on being APR 6 aligned
	BLO	20$		;So long as it's high enough we're happy
	MOV	#ODT,R1		;Pick up the autoload vector for ODT's entry
	MOV	6(R1),R1	;Get the real address
	ADD	#20,R1		;We'll want to go to ODT+20
	MOV	R1,JODT		;Store the pointer
	MOV	#OVLY1,R0	;Start with the first half of Misc	;092
	MOV	#MSC$P1,R1	; which goes here			;092
	CALL	RELC4K		;Move it				;092
	MOV	#OVLY2,R0	;Now for the second half		;092
	MOV	#MSC$P2,R1	; which goes here			;092
	CALL	RELC4K		;Now move it
	MOV	#MSC$P2,@#KISAR6 ;Set up ODT's mapping			;092
	MOV	#1,@#MMUSR0	;Turn the MMU on
	MOV	#O.RELT,R0	;Point to ODT's relocation registers
	MOV	6(R0),R0	;Get the real pointer from the autoload vector
	MOV	#CLEAN,R1	;Point to CLEAN loader (at bottom of overlays) ;012
	MOV	6(R1),(R0)+	;(overlay region);0R
	MOV	#ROOT,(R0)+	;(root);1R
	MOV	#SATBUF,(R0)+	;(satbuf);2R
	MOV	#FIP,(R0)+	;(fip);3R
	CLR	@#MMUSR0	;Turn the MMU off again
	CALLR	KPARSU		;Restore mapping to normal

20$:	ERF	<"MSC phase linked incorrectly">			;092

.DSABL	LSB

GLOBAL	<ODTBAS,ODT,O.RELT>

.SBTTL	SETNXM -- Set up table of nonexistent memory.

;+
; SETNXM -- Set up table of nonexistent memory.
;
; CALL	SETNXM
;
; A.NXM  tables set to bit map of the K words of memory.		;076
;	0 means the K exists.
;	1 means the K does not exist or is in I/O page.			;076
;
; TOPPHY is set to the number of K words this machine is capable of	;076
;  addressing.								;076
;
; SIDE EFFECT: All registers random, all memory above INIT zeroed	;013
;-

.ENABL LSB

SETNXM:	MOV	#A.NXM+<2048./8.>,R4 ; R4 -> End of actual NXM table	;076
	MOV	#<2048./16.>,R1	; R1 = table length in words		;076
10$:	MOV	#-1,-(R4)	; Set all memory to nxm
	SOB	R1,10$
;	MOV	#A.NXM,R4	; Now, R4 -> Beginning of NXM table	;076
	CLR	MAXMEM		; Clear top address
	CALL	KPARSU		; Set up null kernel mapping		;013
	MOV	#160$,@#4	; Set up NXM intercept			;013
	MOV	#180$,@#114	; Catch traps to 114 (11/70 memory)	;020
	CLR	R2		; Start checking at 0K
	MOV	#1,R5		; R5 = bit within table
	MOV	HWSIZE,R3	; R3 = size of memory
	BGT	20$		;  if this is an 11/70
	MOV	#124.,R3	; Else check up to 124 K
	TSTB	FLG22		; 22-bit addressing?
	BMI	20$		; No, 124 K is enough
	MOV	#<<2048.-4.-12.-64.>&<-64.>>,R3 ; Assume it's a GPK	;092
				;  which has 4 K I/O, 12 more K ROM,	;092
				;  64 K video memory (on the 380) and	;092
				;  has to have its video memory aligned	;092
				;  on a 64 K boundary.			;092
	TSTB	FLGGPK		; Is it a GPK?				;092
	BMI	20$		; Yes, so scan that much		;092
	MOV	#<2048.-4.>,R3	; Assume this processor has a 4Kw I/O	;079
				;  page, so we can use up to 2044Kw.	;079
	MOVB	CPTYP,R0	; Save a copy of the CPU type.		;076
				;  The two we're looking for are	;076
				;  Q-bus and/or J11.			;090
				;  But NOT 11/24's			;088
	CMPB	R0,#5		; Is this a J11 CPU?			;090
	BEQ	20$		; Yup, use 2044Kw size.			;090
	TSTB	FLGQBU		; Or, are we on a Q-bus system?		;090
	BPL	20$		; Yes, same thing.			;076
	MOV	#<2048.-128.>,R3; If none of the above, then we have a	;076
				;  128K I/O page, so we can only use	;076
				;  up to 1920Kw.			;076
20$:	MOV	R3,TOPPHY	; Save the number of K words we can see.;076
30$:	MOV	R4,-(SP)	; Store away R4...			;090
	MOV	R5,-(SP)	;  ...and R5 for use later.		;090
35$:	MOV	R2,@#KISAR6	; APR 6 (140000) -> memory being checked;076
	MOV	#140000,R0	; R0 -> memory to check
	MOV	#1024.,R1	; Check the entire K.
	MOV	#1,@#MMUSR0	; Turn on the MMU.			;090
	CMP	R2,#ENDINI	; Above top of INIT?			;013
	BLO	90$		; No, do non-destructive check.		;013
	CLR	ROMEM		; Otherwise, note that we're doing	;090
				;  "normal" (read/write) memory test.	;090
	MOV	#-2,R5		; R5 holds our -2 constant.		;058
	CLR	R4		; R4 holds a zero.			;058
50$:	MOV	R4,(R0)		; Write zeroes without reading.		;058
60$: ; This symbol must immediately follow the MOV instruction above	;090
     ;  for the trapcatcher to work correctly!!				;090
	TST	(R0)		; Did we really put a zero out there??	;058
	BNE	80$		; Pretend we got a parity error		;034
	MOV	R5,(R0)		; try changing the parity		;058
	CMP	R5,(R0)		; did it change correctly		;058
	BNE	80$		; no, so parity error it		;034
	CLR	(R0)+		; Reset it to 0				;058
70$:	SOB	R1,50$		; Loop the entire K			;013
	BR	120$		; Now continue				;013

80$:	CLR	-(SP)		; Stick a fake PSW on the stack		;090
	MOV	#60$,-(SP)	;  but use a "valid" PC.		;090
	BR	180$		; Pretend a parity error occurred.	;034

GLOBAL	<MAXMEM>							;025

90$:	MOV	#<1024./16.>,R1	; Mung the loop counter.		;058
100$:
.REPT	16.			; Generate the following 16. times...	;090
	MOV	(R0),(R0)+	; Move an INIT word to itself.		;090
.ENDR				; So there!!				;090
	SOB	R1,100$		; Loop for entire K.			;090
120$:	MOV	(SP)+,R5	; Restore R5...				;058
	MOV	(SP)+,R4	;  ...and R4.				;058
	BICB	R5,(R4)		; It's all good, turn off the NXM bit	;013
	MOV	R2,R0		; Get K number
	ASH	#-5,R0		;  by shifting MMU address
	BIC	#174000,R0	; Clear out possible sign extension
	INC	R0		;  plus 1
	MOV	R0,MAXMEM	; First non-existent memory block
130$:	CLR	@#MMUSR0	; Turn off the MMU now
	ROLB	R5		; Advance to next bit in NXM table	;013
	BCC	150$		; Same byte
	INC	R4		; Overflow, go to next byte
	INC	R5		; Set R5 to low bit
150$:	ADD	#4000/100,R2	; Advance R2 To NEXT K (MMU address)
	DEC	R3		; See if we're done.			;058
	BNE	30$		; Nope, go back for the next K.		;076
	CALLR	KPARSU		; Restore normal mapping		;092

GLOBAL	<MAXMEM>							;025
	;+
	;	Trap handling for SETNXM:
	;	
	;	Handle traps to 4 (NXM or bus problems) here.
	;	  Note that on the GPK, these also occur if you write	;092
	;	  the boot ROM.  Actually we shouldn't scan that high,	;092
	;	  but if we do, it will just look like non-existent	;092
	;	  memory which is what we're after.			;092
	;
	;	Traps to 4 are obvious and expected when sizing memory.	;090
	;	However, there's only one place where a trap to 4 is	;090
	;	actually legal; that's at 50$, where we first write	;090
	;	a zero to the location under test.  Anywhere else means	;090
	;	that something nasty has happened.
	;-

160$:	MOV	#4,R0		; Preset 4 = vector we trapped to	;013
	CMP	(SP),#60$	; "Expected" trap?			;090
	BEQ	230$		; Yes, so go mark this K as NXM.	;090
	MOV	4+0(SP),R5	; Otherwise, restore R5...		;058
	MOV	4+2(SP),R4	;  ...and R4...				;058
	JMP	UNXTRP		;  and die with unexpected trap.	;058

	;+
	;	Handle traps to 114 (parity errors) here.		;090
	;
	;	Traps to 114 can be caused by main memory or cache.	;090
	;	Fortunately, there already exists a routine elsewhere	;090
	;	in ROOT that will take care of cache parity errors (by	;090
	;	printing out a warning message and disabling the part	;090
	;	of cache that's failing).  So, we simply jump off to	;090
	;	this routine (MEMTRP).  If cache was at fault, MEMTRP	;090
	;	will print messages, disable cache, and then return	;090
	;	with an RTI.  If cache was not the problem, MEMTRP will	;090
	;	return with a JMP @TRPSET; we will then print a warning	;090
	;	message and set the bad K as NXM.			;090
	;
	;	Traps to 114 can also occur on the 11/70 when the	;090
	;	Memory Size Register is set to a value higher than	;090
	;	actual physical memory.  This error will not cause the	;090
	;	sizing procedure to fail; the non-existant memory will	;090
	;	simply be marked as such.				;090
	;-

180$:	MOV	#190$,TRPSET	; TRPSET -> the place to go if MEMTRP	;090
				;  finds no cache problems.		;090
				; Now we need to fake a trap so that	;090
				;  SETNXM will come back correctly (it	;090
				;  does an RTI instead of an RTS...).	;090
	MOV	@#PS,-(SP)	; Use our current PSW.			;090
	CALL	MEMTRP		; Go see if cache was at fault.		;090
	CMP	(SP)+,(SP)+	; Yup, looks like it was!		;090
				; Throw away "real" trap info.		;090
	MOV	#UNXTRP,TRPSET	; Reset "normal" unexpected error trap.	;090
				;  (MEMTRP will have already printed a	;090
				;  warning message about cache errors,	;090
				;  and will have disabled cache, if	;090
				;  applicable).				;090
	BR	35$		; Go reset to try this K over again	;090
				;  without storing R4 and R5 again	;090
				;  (they're already on the stack).	;090

	;+
	;	Here's where we end up if cache was not the problem.	;090
	;-

190$:	CMP	(SP)+,(SP)+	; Get rid of "fake trap" information.	;090
	MOV	#UNXTRP,TRPSET	; Restore "normal" unexpected trap.	;090
	MESSAG
	.ASCII	"A parity error has occurred while checking memory."<200>
	.ASCIZ	"Range of failing address is "				;042
	UNORG
	MOV	R2,R0		; Get K number
	ASH	#-5,R0		;  by shifting right out of MMU's
	BIC	#174000,R0	; Clear out possible sign extension
	CALLX	DECZER		;  and write it out in decimal		;042
	MESSAG
	.ASCIZ	"K."<200>						;042
	UNORG
	TST	ROMEM		; Are we still in INIT memory??		;090
	BEQ	200$		; Nope, so mark it NXM and continue.	;090
	MESSAG								;090
	 .ASCII	<200>							;090
	 .ASCII	"The error has occurred within a section of memory"	;090
	 .ASCIZ	" occupied by INIT."<200>				;090
	UNORG								;090
195$:	MESSAG			; We can't go on like this...		;090
	 .ASCIZ	"INIT cannot continue."<200>				;090
	UNORG								;090
	JMP	HALTER		; Go to the main halt point.		;090

200$:	CMP	(SP),#50$	; Are we outside of test area??		;090
	BLOS	210$		; Yup, so die with an unexpected trap.	;090
	CMP	(SP),#70$	; Is it really in the right area?	;090
	BLOS	220$		; Yup, so go on.			;090
210$:	MESSAG
	 .ASCII	"The error has occurred at an unknown address."<200>	;090
	 .ASCIZ	<200>							;090
	UNORG
	BR	195$		; And, go punt.				;090

220$:	MESSAG
	.ASCII	"This K-word of memory will be marked non-existent."<200> ;090
	.ASCIZ	"Continuing bootstrap procedure...."<200><200>		;090
	UNORG
230$:	CMP	(SP)+,(SP)+	; Pop trap off the stack		;013
	MOV	(SP)+,R5	; Restore R5...				;058
	MOV	(SP)+,R4	;  ...and R4.				;058
	BR	130$		; Advance to next K.			;090

.DSABL 	LSB

.SBTTL	SETPHZ - Set-up and load INIT's phases

.ENABLE	LSB

SETPHZ:	MOV	#PHENTR,R1	; Point to table of phase entry points		
	MOV	#JDISK,R2	;   and where to store their values.		
10$:	MOV	(R1)+,R0	; Pick up pointer to auto-load vector
	BEQ	20$		; End of table, then read & relocate phases
	MOV	6(R0),(R2)+	; Set the virtual address of this phase
	BR	10$		; Repeat

PHZTBL:				;Table of MMU addresses for INIT phases

.IRP	$,	<MCP,BBR,DSK,QNA>					;120
	.WORD	$'FCH		; Autoload vector for $ phase
	.WORD	$'$P1		; MMU address of start of $'s first APR
	.WORD	$'$P2		; MMU address of start of $'s second APR
.GLOBL	 $'FCH
.ENDM
	.WORD	0		; End of control table

20$:	MOV	#PHZTBL,R3	; Point to MMU table of INIT's phases

30$:	CALL	KPARSU		; Restore null kernel mapping
	MOV	(R3)+,R0	; Pick up address of autoload vector
	BNE	40$		; Relocate the next phase.
	RETURN

40$:	CALL	(R0)		;Read the phase, as if it was an overlay
	MOV	#OVLY1,R0	;R0 = MMU address of overlay region
	MOV	(R3)+,R1	;Set the MMU of where the phase should reside
	CALL	RELC4K		;  and fling the first 4k of phase into memory
	MOV	#OVLY2,R0	;Set MMU of where the last 4K hsould go
	MOV	(R3)+,R1	;Set the MMU of where the rest should reside
	CALL	RELC4K		;  and fling the last 4k of phase into memory
	BR	30$		; Repeat for each phase in the table

.DSABLE	LSB

.MACRO	$	ENTRY
.ASSUME	.-PHENTR EQ J'ENTRY-JDISK
	.WORD	P'ENTRY
.GLOBL	P'ENTRY
.ENDM

PHENTR:	$	DISK		;DISK TRANSFERS FOR BOTH PHASES
	$	XRSET		;DISK RESETTER
	$	TRSET		;TAPE RESETTER
	$	MAGIO		;TAPE I/O
	$	MGSPC		;TAPE FUNCTIONS
	$	ERRLG		;ERROR LOGGER
	$	RTI3		;RTI3 Routine				;054
.ASSUME	.-PHENTR EQ JQDSDU-JDISK
	.WORD	QDS$DU		; RT11 $OTABL JSR FOR "QDS$DU"
.ASSUME	.-PHENTR EQ JINTDU-JDISK
	.WORD	INT$PH		; RT11 $OTABL JSR for "INT$PH"		;087
.ASSUME	.-PHENTR EQ JTMODU-JDISK
	.WORD	TMO$PH		; RT11 $OTABL JSR for "TMO$PH"		;087
.ASSUME	.-PHENTR EQ JCONPH-JDISK					;029
	.WORD	CON$IP		; RT11 $OTABL JSR FOR "CON$IP"		;120
.ASSUME .-PHENTR EQ JASNMU-JDISK					;050
	.WORD	ASN$MU		; RT11 $OTABL JSR FOR "ASN$MU"		;050
.ASSUME	.-PHENTR EQ JSPCMU-JDISK					;050
	.WORD	SPC$MU		; RT11 $OTABL JSR FOR "SPC$MU"		;050
.ASSUME	.-PHENTR EQ JSERMU-JDISK					;050
	.WORD	SER$MU		; RT11 $OTABL JSR FOR "SER$MU"		;050
.ASSUME	.-PHENTR EQ JINTMU-JDISK					;050
	.WORD	INT$MU		; RT11 $OTABL JSR FOR "INT$MU"		;050
.ASSUME	.-PHENTR EQ JTMOMU-JDISK					;050
	.WORD	TMO$MU		; RT11 $OTABL JSR FOR "TMO$MU"		;050
.ASSUME	.-PHENTR EQ JDNEMU-JDISK					;048
	.WORD	DNE$MU		; RT11 $OTABL JSR FOR "DNE$MU"		;048
.ASSUME	.-PHENTR EQ JXHROM-JDISK					;086
	.WORD	CITQNA		; RT11 $OTABL JSR FOR "CITQNA"		;086
	.WORD	0		;END OF TABLE

GLOBAL	<QDS$DU,INT$PH,TMO$PH,CON$IP>
GLOBAL	<ASN$MU,SPC$MU,SER$MU,INT$MU,TMO$MU,DNE$MU>
									;087
GLOBAL	<CITQNA>							;086

.SBTTL	Bootstrap I/O driver

;+
; These routines are used during the one-shot code phase; they are entered
; by the driver dispatch routines when the driver index is IDX$.. .
; These routines can live in SATBUF since they are only used during one-shot
; setup.
;-

BTDISK:	REGSCR			;Save the registers
	MAP	PUSH,APR=6,CODE	;Save current APR6 mapping		;092
	MAP	#1400,APR=6,CODE ;Set up default mapping to map boot	;092
	MOV	DSQFBL(R4),R0	;Get low order FBN
	MOVB	DSQFBM(R4),R1	; and high order FBN, extend to word
	MOV	BT$DCS,R2	;Get DCS of boot device
	DEC	R2		; minus 1
	ADD	R2,R0		;Add to FBN
	ADC	R1		; to get LBN
	MOV	R0,B.BLKL	;Set it
	MOV	R1,B.BLKH	; both words
	MOV	DSQMAL(R4),B.MEML ;Set low order memory address
	MOVB	DSQMAM(R4),R0	;Get high order memory address, extend to word
	MOV	R0,B.MEMH	;Set it
	MOV	DSQCNT(R4),B.TWC ;Set word count for this transfer
	MOVB	B.RFUN,B.FUNC	;Assume function = read
	CMPB	DSQFUN(R4),#RFUN ;Correct?
	BEQ	10$		;Yes, go for it
	CMPB	DSQFUN(R4),#WFUN ;No, is it a write?
	BHI	ILBFUN		;No, so we can't do it!			;092
.ASSUME	WFUN.C LT WFUN		;WFUN.C is done as if WFUN		;092
	MOVB	B.WFUN,B.FUNC	;Yes, set function to write
10$:	CALL	B.READ		;Do the transfer
	BCS	20$		;Error!
	MAP	POP,APR=6,CODE	;Restore mapping			;092
	RETURN

20$:	ERF	<"Disk error during boot phase">

.ENABL	LSB

BTTAPE:	CMP	(R5)+,#RFUN	;Read?
	BNE	ILBFUN		;No, so die
	MOV	(R5)+,B.MEML	;Set low order memory address
	TSTB	BACKUP		;Is this SAV/RES?
	BEQ	10$		;No, things are clean
	TSTB	HIGHBF		;Yes, do we want I/O to high memory?
	BEQ	10$		;No
	ADD	IOBF1$,B.MEML	;Yes, add in the base address		;025
10$:	CLR	B.MEMH		;Clear out high order address
	MOV	I.DSQ+DSQCNT,B.TWC ;Set up word count
	REGSAV			;Save registers
	MAP	PUSH,APR=6,CODE	;Save mapping				;093
	MAP	#OVLY2,APR=6,CODE ;Set up correct mapping		;094
	CALL	B.READ		;Do the transfer
	MAP	POP,APR=6,CODE	;restore mapping			;093
	BR	30$		;Now leave

BTSPEC:	MOV	(R5)+,B.SPFC	;Set special function subcode
	CMP	B.SPFC,#6	;Set characteristics?
	BEQ	40$		;Yes, that's a NOP
	CMP	B.SPFC,#3	;Rewind?
	BEQ	20$		;Yes, do it
	CMP	B.SPFC,#4	;Skip forward is the only alternative
	BNE	ILBFUN		;Sorry, can't do that!
20$:	MOV	R2,B.PARM	;Now set up parameter value
	REGSAV			;Save registers
	MAP	PUSH,APR=6,CODE	;Save mapping				;093
	MAP	#OVLY2,APR=6,CODE ;Set up correct mapping		;094
	CALL	B.SPEC		;Do the function
	MAP	POP,APR=6,CODE	;restore mapping			;093
30$:	REGRES			;Restore registers
40$:	RETURN	R5		;Done

.DSABL	LSB

ILBFUN:	ERF	<"INIT bug -- illegal function in boot driver">

.SBTTL	Finish one-shot code; round SATBUF, SILBUF, FIBUF

.	= SATBUF+<.+777-SATBUF&177000>

.IF GT	.-<SATBUF+<1000*16.>>
.ERROR	;Set-up code does not fit in SATBUF
.ENDC

$$$$$	= .
.	= SATBUF
DSTBL::	.BLKW	5*256.		; Installed device table (swap in area)
DSTBLE::			; End of DS table
.	= $$$$$
DSTBLL	== 5*256.		; Length of DS table in words

MONLOW::.BLKB	1000		; Monitor's prototype lowcore goes here	  ;097

JAMLST::			; Jam list starts here			;097

.	= SATBUF+<1000*16.>	; Extend to end of SATBUF

	ORG	SILBUF		; Round up SILBUF

.IF GT	.-<SILBUF+SI.SIZ>						;025
.ERROR	;Set-up text does not fit in SILBUF
.ENDC

.	= SILBUF+SI.SIZ

	ORG	FIBUF		; Round up FIBUF

.IF GT	.-<FIBUF+1000>
.ERROR	;Set-up text does not fit in FIBUF
.ENDC

.	= FIBUF+760
FIBMAP::.BLKW			; Define start of map entry
FIBENT::.BLKW	7		; File directory cluster map
FIBEND::			; End of FIBUF

.SBTTL	DEFINE ROOT CODE MACROS

.MACRO	I.MESS
	 TMPORG	ROOTXT
.NLIST	BEX
.ENDM	I.MESS

	ORG	ROOT

.SBTTL	KDJ11-E TOY clock common routines

TOYINI:	TST	@#TOYCSR	;Read the clock CSR bit			;117
	MOV	#2,R2		;We must load 2 sets of 2 words each	;117
	CLR	-(SP)		;Make a place for			;117
	MOVB	@#TOYCSR+1,(SP)	; the old stuff from the TOYCSR		;117
10$:	MOV	#35305,R1	;First pattern word to load		;117
	CALL	TOYLOD		; and go load it			;117
	MOV	#56243,R1	;Second pattern word to load		;117
	CALL	TOYLOD		; and go load it			;117
	SOB	R2,10$		;Make sure we do both sets.		;117
	TST	(SP)+		;Trash the old TOYCSR stuff		;117
	RETURN			; All done, so return home		;117

;	Send the word in R1 to the TOY clock				;117
;	and 2(SP) contains the old TOYCSR contents (so we don't		;117
;	change anything in it).						;117

TOYLOD:	MOV	#16.,R3		;Number of bits to load			;117
	BIC	#1,2(SP)	; Making sure the TOY bit is clear	;117
10$:	MOV	R1,R4		;Copy the bit to send			;117
	BIC	#^C<1>,R4	;Clear out all but the bit to send	;117
	BIS	2(SP),R4	;Put the other TOYCSR bits back		;117
	MOVB	R4,@#TOYCSR+1	; into the register (with the TOY bit)	;117
	ROR	R1		;Move down the bits to send		;117
	SOB	R3,10$		; until we do all of the bits		;117
	RETURN			; and then we are done.			;117

;	Read the KDJ11-E TOY clock to see what it says			;117
;	Put the data into the area pointed to by R2			;117

TOYGET:	MOV	R0,-(SP)	;Save a working register		;117
	MOV	#4,R4		;We have 4 words to read		;117
10$:	CALL	20$		; so go read a word			;117
	MOV	R1,(R2)+	;  and store it away			;117
	SOB	R4,10$		; but when we are all done...		;117
	MOV	(SP)+,R0	; restore our working register and	;117
	RETURN			; go back to our caller.		;117

20$:	MOV	#16.,R3		;Number of bits to read			;117
30$:	MOVB	@#TOYCSR+1,R0	;Now, get the bit.			;117
	ASHC	#-1,R0		;Move the others in R1 down		;117
	SOB	R3,30$		; and do all the necessary bits		;117
	RETURN			;So we can go exit			;117

;	Convert the TOYs BCD into something useful			;117
;	The BCD comes in in R1 and binary goes out in R1		;117

BCDBIN:	BIC	#377*400,R1	;we only do one byte at a time		;117
	MOV	R1,-(SP)	;and save a copy of it			;117
	BIC	#^C<17>,(SP)	;but only the ones BCD part		;117
	ASH	#-4,R1		; now move down the 10s digit		;117
	MUL	#10.,R1		; and fix it up right			;117
	ADD	(SP)+,R1	; also adding in the 1s digit		;117
	RETURN			; and we are DONE (boy is BCD ugly!)	;117

;	Convert Binary to BCD.  The Binary comes in in R1		;117
;	R0 is destroyed, and the BCD goes out in R1.			;117

BINBCD:	BIC	#^C<177>,R1	;Get rid of real junk			;117
	CLR	R0		;Get a register for the divide		;117
	DIV	#10.,R0		;Divide by 10.				;117
	ASH	#4,R0		; Move the 10s digit up			;117
	BIS	R0,R1		;  and put it where it belongs		;117
	RETURN			; and all done				;117

.SBTTL	SET UP THE VECTOR REGION

.ENABL	LSB

I.CORE::REGSCR			;SAVE REGISTERS
	CLR	R0		;START AT LOCATION 0
	MOV	#PR7,R1		;NEW PS IS PR7, REGSET 1, KM, PREV UM
10$:	MOV	#8.,R2		;VECTORS COME IN GROUPS OF 8
	MOV	#70$,R3		;AND GO TO THE EIGHT JSR'S
20$:	MOV	R3,(R0)+	;SET NEW PC
	MOV	R1,(R0)+	;AND NEW PS
	ADD	#4,R3		;NEXT PC POSSIBLE
	SOB	R2,20$		;LOOP FOR 8
	INC	R1		;NOW BUMP CONDITION CODES IN NEW PS
	CMP	R0,#1000	;DONE YET?
	BLO	10$		;NO
	MOV	#3,(R2)		;BPT AT 0: T14 ON J0, DOUBLE TRAP ON T0
				; (if cpu is not an F-11, anyway!)
	TSTB	KW11L		;Q-BUS L CLOCK ENABLED?
	BLE	30$		;NOPE
	MOV	#QCLOKI,@#100	;YEP, CATCH IT SPECIAL
	MOV	#PR7,@#102	;PR7, REGSET 1, KM, PREV = UM
	MOV	#100,@LKSCSR	;START Q-BUS CLOCK RUNNING...
30$:	MOV	#MEMTRP,@#114	;MEMORY TRAPS GO TO MEMORY TRAP HANDLER
	MOV	#PR7,@#116	;PR7, REGSET 1, KM, PREV = UM
	MOV	#IOTRAP,@#20	;I/O TRAPS FOR MS DRIVER GO TO HANDLER	;033
	MOV	#PR7,@#22	;PR7, REGSET 1, KM, PREV = UM		;075
	MOV	#30,R0		;NOW SET UP INTERMEDIATE REBOOT REGION
	MOV	#50$,R1		;FROM THE PROTOTYPE
40$:	MOV	(R1)+,(R0)+	;MOVE IT INTO 30-57
	CMP	R0,#60
	BLO	40$
	MOV	#UNXTRP,TRPSET	;ALL TRAPS GO TO THE UNEXPECTED TRAPPER
	MOV	#I.INI0,CTLCGO	;^C TRAPS TO I.INI0
	RETURN

; THE FOLLOWING GOES INTO LOCATIONS 30 & UP

50$:	.WORD	ERRLOG,PR7	;EMT traps go to the error logger	;092
	.WORD	ERFTRP,PR7	;TRAPS TRAPS MEAN ERROR MESSAGE
	JMPX	BOOTSY		;@ 40 FOR RESARTING INIT
60$:	JMPX	BOOTSY		;@ 44 TO REBOOT THE SYSTEM
	BR	60$		;@ 50 FOR REBOOT OF SYSTEM
	HALT			;@ 52 (YOU CAN'T TAKE A CRASH DUMP!)
	HALT			;@ 54 (STANDARD HALT)
	BR	60$		;       AND THEN REBOOT

GLOBAL	<QCLOKI,LKSCSR>


; The following code intercepts all traps through the vectors in 60-774
; It computes the vector address in R0 and jumps to the trap handler specified
; in TRPSET.  This is usually the message printer for fatal traps, but may
; be the 'poke-a-device-and-see-where-it-interrupts' code.

70$:	CALL	80$,R0		; Save R0, put trap address in R0
TRAP.4::CALL	80$,R0
TRAP.10:CALL	80$,R0
	CALL	80$,R0
	CALL	80$,R0
	CALL	80$,R0
	CALL	80$,R0
	CALL	80$,R0

80$:	JSR	R0,(PC)		; Push R0 (trap addr), don't change C.codes
	MOV	@#PS,R0		; The PS has part of the vector location
	BIC	#^C<17>,R0	;  in the condition codes
	ASH	#5,R0		; Shift to position
	ADD	(SP)+,R0	; Bias by location vectored to
	SUB	#70$+4,R0	; Now the bias is the vector location
	CMP	R0,#14		; Was it a BPT?
	BNE	90$		; No
	CMP	2(SP),#2	; Yes. Perhaps we got a jump to 0?
	BEQ	90$		; Sure did. Report J0 as trap to 14
	MOV	(SP)+,R0	; No, a true BPT. Let's restore R0
	NOP
	MOV	@#KISAR6,SVPAR6	; Save current APR6 mapping
	MOV	SVPAR6,SVPAR6+2	; ODT expects to see 2 copies (one I, one D)
	MOV	@#MMUSR0,SVMMR0	; Save the MMU state also
	MOV	#MSC$P2,@#KISAR6 ; Set ODT's mapping			;092
	MOV	#1,@#MMUSR0	; Turn the MMU on in case it was off
	CALL	@JODT		; Go to ODT
	MOV	@#SVPAR6,@#KISAR6 ; Restore APR6 (ODT wants this exact code)
	MOV	SVMMR0,@#MMUSR0	; Restore MMU state
	RTT			; Exit from the breakpoint

90$:	MOV	(SP)+,ERRREG	; Move saved R0 to here for error reporting
	CMP	R0,#4		; Was it trap to 4?
	BNE	100$		; Nope
	CMP	(SP),#5		; Yes, perhaps a double trap after trap to 0
	BHI	100$		; No, a true trap to 4
	CMP	(SP)+,(SP)+	; T0 trapped again from PC=3. Purge 2nd trap
	CLR	R0		;  and report a trap to 0
100$:	JMP	@(PC)+		; No, go to the trap handler
TRPSET:: .WORD	UNXTRP

.DSABL	LSB

.SBTTL	MEMORY SYSTEM TRAPS (@ 114)

.ENABL	LSB

MEMTRP:	TSTB	CACHE		;DOES THIS SYSTEM HAVE CACHE?
	BMI	40$		;NO -- HANDLE TRAP NORMALLY
	BIT	#100360,@#CHEERR;Check abort and data/addr group bits.	;090
	BMI	40$		;CPU abort - call it a hard error.	;090
	BEQ	40$		;No cache errors at all, so call it	;090
				; a "normal" error.			;090
	BIS	#1,@#CHECTL	;DISABLE CACHE TRAPS WHILE WE PROCESS ONE
	REGSAV			;SAVE REGISTERS SO WE CAN RESTART
	CLR	R0		;R0 WILL BE BITS TO DISABLE FAILING GROUP
	MOV	@#CHEERR,R1	;GET THE ERROR BITS
	MOV	#50$-1,R2	;POINT (OFFSET) TO CONTROL TABLE
10$:	TSTB	(R2)+		;SKIP TO START OF AN ENTRY
	MOVB	(R2)+,R3	;BITS TO DISABLE A GROUP
	BEQ	20$		;ZERO FLAGS END OF LIST
	BITB	R1,(R2)+	;SEE IF THAT GROUP HAD AN ERROR
	BEQ	10$		;NO -- TRY NEXT GROUP
	DECB	(R2)		;HAS ITS GRACE PERIOD EXPIRED?
	BNE	10$		;NO -- TRY NEXT GROUP
	BIS	R3,R0		;YES -- SET BITS IN R0 TO DISABLE IT
	BR	10$		;AND TRY NEXT GROUP

20$:	TST	R0		;DID WE DECIDE SOME CACHE WAS BAD?
	BEQ	30$		;SKIP IF NONE DISABLED
	CALL	CHENAM,R5	;PRINT A MESSAGE
	 GENTXT	<" is failing repeatedly">
	BIS	R0,CCTVAL	;ACCUMULATE DISABLE BITS
	MOV	CCTVAL,@#CHECTL	;DISABLE SOME CACHE
30$:	MOV	R1,@#CHEERR	;UNLOCK THE ERROR TRACKER
	CALLX	REGRES,R5	;RESTORE REGISTERS
	BIC	#1,@#CHECTL	;RE-ENABLE CACHE TRAPS
	RTI			;RETURN FROM INTERRUPT

40$:	MOV	#114,R0		;REPORT TRAP TO 114
	JMP	@TRPSET		;GO WHEREVER WE SHOULD ON NORMAL TRAPS

50$:	.BYTE	44,120		;REPLACE 1, MISS 0; DATA/ADDRESS ERROR 0
	.BYTE	4		;GIVE IT 4 STRIKES
	.BYTE	30,240		;REPLACE 0, MISS 1; DATA/ADDRESS ERROR 1
	.BYTE	4		;GIVE IT 4 STRIKES
	.WORD	0		;END OF LIST

.DSABL	LSB

; SUBROUTINE TO PRINT A MESSAGE ABOUT BAD CACHE
;
; R0 = BITS TO DISABLE THE BAD PART OF CACHE: 74, 30, OR 44
;
; CALL CHENAM,R5
;  GENTXT <what's wrong>

.ENABL	LSB

CHENAM:	MOV	(R5)+,20$	;SAVE MESSAGE POINTER
	MOV	(PC)+,-(SP)	;ASSUME THE WHOLE CACHE IS BAD
	 GENTXT	<"cache">
	CMP	R0,#74		;IS IT?
	BEQ	10$		;YES -- PRINT MESSAGE
	MOV	(PC)+,(SP)	;ASSUME GROUP 0 IS BAD
	 GENTXT	<"cache group 0">
	BIT	R0,#4		;IS IT?
	BNE	10$		;YES -- PRINT MESSAGE
	MOV	(PC)+,(SP)	;OTHERWISE GROUP 1 IS BAD
	 GENTXT	<"cache group 1">
10$:	MESSAGE	<"Warning - main memory ">
	MOV	(SP),R0		;PRINT PART OF CACHE THAT'S BAD
	CALLX	ASCIZ0
	CALLX	MESSAGE,R5	;PRINT WHY IT'S BAD
20$:	 .WORD	0		;(SUPPLIED BY CALLER)
	MESSAGE	<"."<200>"RSTS/E will not use ">
	MOV	(SP)+,R0	;REPEAT NAME OF BAD CACHE
	CALLX	ASCIZ0
	MESSAGE	<"."<200>"System may run slowly."<200>>
	RETURN	R5

.DSABL	LSB

.SBTTL	I/O TRAPS (@ 20)						;033

;	Handle IOT's that MS driver does for BUFFER GETSML and RETSML	;033

.ENABL	LSB								;033

IOTRAP:	MOV	R0,-(SP)	;SAVE R0				;033
	MOV	2(SP),R0	;GET THE OLD PC				;033
	CMP	(R0)+,#RETSML	;CHECK THE PARAMETER			;033
	BEQ	RETTSQ		;IT WAS A BUFFER RETSML			;033
;
GETTSQ:	MOV	R0,2(SP)	;UPDATE THE PC				;033
	BIC	#V,4(SP)	;CLEAR THE V-BIT FROM THE PSW		;033
	MOV	#TSQ0,R4	;POINT TO THE FIRST TSQ			;033
	CMP	(R4),#-1	;IS THIS ONE BEING USED?		;033
	BEQ	10$		;NO					;033
	MOV	#TSQ1,R4	;YES, SO USE THE SECOND ONE		;033
10$:	ADD	#TSQLEN,R4	;POINT TO THE END OF THE TSQ		;033
	MOV	#TSQLEN/2,R0	;GET SIZE OF A TSQ			;033
20$:	CLR	-(R4)		;START CLEARING IT OUT			;033
	SOB	R0,20$		;KEEP GOING 'TIL IT'S ALL CLEAR		;033
	;MOV	#TSQn,R4	;R4 -> BEGINNING OF TSQ			;033
	MOV	(SP)+,R0	;RESTORE R0				;033
	RTT			;RETURN FROM TRAP			;033
;+
; RETTSQ is hand done for MSDVR, and is not a generic RETSML routine.
; Follow MSDVR example or change the convention
;-

RETTSQ::MOV	(SP)+,R0	;RESTORE R0				;033
	MOV	#-1,(R4)	;MARK TSQ AS INIT-OWNED			;033
	RTT			;RETURN FROM TRAP			;033

.DSABL	LSB								;033

.SBTTL	FATAL TRAPS

;	Handle set up for ERF and unexpected trap handling.

.ENABL	LSB

;	Handle unexpected traps.  R0 contains the vector that was violated

UNXTRP::CLR	@#MMUSR0	;NO MEMORY MANAGEMENT
	MOV	R5,ERRREG+<5*2>	;GOT TO SAVE IT HERE TO USE COMMON ERF CODE
	MOV	R0,UNXVEC	;SAVE THE VECTOR ADDRESS
	MOV	ERRREG,R0	;GET BACK R0
	BR	10$		;AND PRINT THE REST OF THE FATALITY

;	ERF entry

ERFTRP::MOV	#-1,UNXVEC	;REMEMBER THIS WAS ERF NOT AN UNEXPECTED TRAP ;014
	MOV	R5,ERRREG+<5*2>	;FREE UP A REGISTER WITHOUT LOOSING IT
	MOV	(SP),R5		;GET TRAPPING PC
	MOV	(R5),60$	;SET POINTER TO ERROR TEXT
	MOV	-(R5),R5	;R1 = TRAP INSTRUCTION
	TSTB	R5		;WAS IT AN INSENSITIVE ERROR?
	BEQ	10$		;NO, IT WAS A MESSAGE
	MOV	#34,R0		;YES, REPORT AS A STRAY TRAP
	BR	UNXTRP

10$:	CLRB	NOERR		;CLEANLINESS
	CLRB	BACKUP		;SAVE/RESTORE IS DEFINITELY OVER
	MOV	(SP)+,ERRPC	;SAVE THE FAILING PC
	MOV	(SP)+,ERRPS	; AND THE PS
	MOV	KISAR5,ERRM5	;  AND APR5
	MOV	KISAR6,ERRM6	;   AND APR6
	MOV	SP,ERRSP	;    AND SP
	MOV	#ERRREG,R5	;Point to register save area		;014
	MOV	R0,(R5)+	;Save R0				;016
	MOV	R1,(R5)+	;  and R1				;016
	MOV	R2,(R5)+	;   and R2				;016
	MOV	R3,(R5)+	;    and R3				;016
	MOV	R4,(R5)+	;     and R4				;016
	MOV	#ES.CNT,R1	;SET COUNTER
	MOV	#ERRSTA,R2	;SET PLACE TO SAVE IT
20$:	MOV	(SP)+,(R2)+	;SAVE SOME STACK
	SOB	R1,20$		;LOOP
	MOV	@$OVTAB+6,R1	;GET OVERLAY NUMBER TIMES 6
	CLR	R0		;PREPARE FOR A DIVIDE
	DIV	#6,R0		;DIVIDE BY 6 TO GET OVERLAY NUMBER
	MOV	R0,ERROV	;SAVE OVERLAY NUMBER
	.BR	30$

GLOBAL	<$OVTAB>


;	Print the headline for either an ERF or an unexpected trap

;	UNXVEC is -1 for an ERF 					;014
;	UNXVEC is the vector number for an unexpected trap		;014
;	       and can range from 60-774

30$:	TST	XXXTRP		;ARE WE IN A TERRIBLE LOOP?
	BEQ	40$		;NO
	MOV	HALTER,(PC)	;YES, HALT OR GO TO ODT
	HALT			;BUT HOLD IT
40$:	INC	XXXTRP		;CATCH LATER ERF'S
	RESETB			;CLEAN UP
	TST	UNXVEC		;SEE WHAT THE FIRST LINE SHOULD BE
	BMI	50$		;BRANCH IF ERF

	MESSAG	<<177><200>"Unexpected trap through the vector at ">
	MOV	UNXVEC,R0	;GET VECTOR ADDRESS
	CALLX	OCTWRD		;PRINT IT
	BR	70$		;SKIP ERF CODE AND JOIN COMMON CODE

50$:	CALLX	RCTRLO		;SPEAK
	CMPB	@60$,#176	;IS IT THE SPECIAL CONTINUATION?	;075
	BEQ	55$		;YES, SO NOT ON A NEW LINE		;075
	CALLX	TYPECR		; ON A NEW LINE
55$:	CALLX	MESSAG,R5	;PRINT THE ERROR TEXT
60$:	 .WORD	0
;	Print registers and overlay number

70$:	CALLX	TYPECR		;NEW LINE
	MOV	#ERRPC,R4	;GET POINTER TO VALUES
	MOV	#ERRLAB,R1	;GET POINTER TO LABELS

	TMPORG	ROOTBL
ERRLAB:	 .RAD50	/ PC PS OV M5 M6 SP R0 R1 R2 R3 R4 R5/
	 UNORG

	MOV	#^B1111101111100000,R3 ;SET UP LOOP CONTROL
	MOV	#'=,R2		;EQUAL SIGN FOR PRINTING

80$:	MOV	(R1)+,R0	;GET NEXT LABEL
	CALLX	RADPRT		;OUTPUT LABEL FROM R0, (NO REGS MUNGED)
	CALLX	TYPE		;OUTPUT "=" FROM R2,   (NO REGS MUNGED)
	MOV	(R4)+,R0	;GET NEXT VALUE
	CALLX	OCTWRD		;OUTPUT VALUE FROM R0, (NO REGS MUNGED)
	ROL	R3		;SEE HOW THE LOOP IS DOING
	BCS	80$		;LOOP IF MORE TO THIS LINE
	CALLX	TYPECR		;NEW LINE,             (NO REGS MUNGED)
	TST	R3		;SEE IF DONE
	BNE	80$		;BRANCH IF ANOTHER LINE TO DO

	MESSAG			;DO THE STACK POINTS HEADER (NO REGS MUNGED)
	 .ASCII	<200>
	 .ASCIZ	"SP-> "
	 UNORG

	MOV	#ES.CNT,R1	;GET MAX COUNTER
	MOV	#' ,R2		;SPACES BETWEEN VALUES ON STACK
	MOV	#I.STAK,R3	;FIGURE OUT HOW
	SUB	ERRSP,R3	; MUCH IS ON THE STACK
	BEQ	100$		;SKIP IT IF THE STACK IS EMPTY
	ASR	R3
	CMP	R3,R1		;TAKE THE SMALLER VALUE BETWEEN
	BHI	90$		; ES.CNT AND THE AMOUNT
	MOV	R3,R1		;  ACTUALLY ON THE STACK
90$:	MOV	(R4)+,R0	;GET NEXT WORD
	CALLX	OCTWRD		;PRINT IT
	CALLX	TYPE		;SPACES BETWEEN
	SOB	R1,90$		;LOOP

.ASSUME	ERRPS	EQ	ERRPC+2
.ASSUME	ERROV	EQ	ERRPS+2
.ASSUME	ERRM5	EQ	ERROV+2
.ASSUME	ERRM6	EQ	ERRM5+2
.ASSUME	ERRSP	EQ	ERRM6+2
.ASSUME	ERRREG	EQ	ERRSP+2
.ASSUME	ERRSTA	EQ	ERRREG+<2*6>


;	Sum the whole mess up with the last line or lines

100$:	MESSAG
	 .ASCII	<200><200>
	 .ASCIZ	"Fatal RSTS/E system initialization error!"<200>
	 UNORG
	CLRB	AUTOQS		; Auto-restart can't happen
	TSTB	GOSWIT		; Can we go?
	BEQ	110$		; No, this is a fatal thing
	CMP	HALTER,#BPT	; Are breakpoints allowed?
	BEQ	HALTER		; Yes => go to ODT			;025
	JMP	I.INI0		; No => try for an option		;025
110$:	MESSAG
	 .ASCII	"The fatal error occurred during the bootstrap phase"<200>
	 .ASCIZ	"of system initialization; there is no recovery."<200>
	 UNORG
	CALLX	TTYSTP		; Quiesce the console
120$:	MOV	ERRPC,R0	; Display the offense in the lights via R0
HALTER::HALT			; (BPT if ODT is in effect)
	JMPX	BOOTSY		; Try rebooting

.ENABL	LSB

.SBTTL	START option - clean the disk first if needed

START0:	CALL	VBCHK		;Is this a first-time boot??		;117
	BCS	5$		;Yes, so allow a re-boot to try it	;117
	TST	NOSTAR		; Are we allowed to START anything?	;062
	BEQ	5$		; Yup, so go do it.			;062
	MESSAG
	 .ASCII	"Timesharing cannot be started due to problems discovered"<200>
	 .ASCIZ "during the boot/autosizing process."<200>
	UNORG
	JMPX	I.INI0		; Sorry!!				;062

;+									;096+
; Here is the message that gets printed if INIT finds something that
; is nasty enough to disallow timesharing.  It's globalized here
; because it's used by SATBUF one-shot and by the ONE overlay.
;-									;096-

	I.MESS								;096
INITOK:: .ASCII	"INIT will continue, but timesharing cannot be started.";096
	 .ASCIZ	<200><12>						;096
	UNORG								;096

5$:	CALLX	CKOPT		; Is this a legal option?		;062
				; (CKOPT returns here if it is, and	;112
				;  goes to "Option:" if it's not).	;112
	TSTB	AUTOQS		; Are we in an auto Re-START (Crash?)	;026
	BMI	20$		; Yes. Skip check on INSTALled SIL	;112
	TSTB	AUTOIN		; Did we just install a SIL?		;112
	BNE	25$		; Yup, so skip CONFIG lookup and SIL	;112
				;  name check.				;112
	TSTB	(R1)		; Has user specified a SIL to start?	;112
	BNE	7$		; Yes, go check the name.		;112
	MOV	#CFGBUF+CFG$NA,R1 ; Now, R1 -> SIL name in CFGBUF.	;112
	TSTB	(R1)		; Anything there?			;112
	BEQ	20$		; No, so NEVER MIND!			;112
7$:	PUSH	<R1>		; Save pointer to ASCII SIL name	;112
	CALLX	RADINP		; Convert the SIL name to RAD50		;026
	POP	<R1>		; Restore pointer to ASCII SIL name	;026
	CMP	R0,SILNAM	; Is it the same as the 1 installed?	;026
	BNE	10$		; No. Do an auto-INSTAL			;026
	CMP	R3,SILNAM+2	; Maybe, last 3 characters match?	;026
	BEQ	20$		; Yes. Continue starting this SIL	;026
10$:	MOVB	#-1.,AUTOIN	; No. set switch for auto-INSTAL	;026
	JMPX	INSTAL		; and INSTAL SIL before starting...	;026
				; INSTAL will jump to START0 when done	;026
				;   or ReBoot if installing for 1st time;026

20$:	TST	SILNAM		; Is there an INSTAlled SIL?		;031
	BEQ	10$		; No, INSTAL one for them.		;031
25$:	CLRB	AUTOIN		; SIL installed, clear auto-INSTAL swtch;026
	CLRB	AUTOST		; Clear auto-START (incase START aborts);026
	CALLX	SETFIP		; Set up FIP for system disk
	CALL	LOKMIN		; Open BADB.SYS and SATT.SYS
	CALLX	READPL		; Read the pack label			;012
	TST	FIBUF+PSTAT	; Is the disk clean?			;012
	BPL	30$		; Yes, don't clean it
.ASSUME	UC.MNT LT 0							;012
	CMP	FIBUF+WHOCLN,#1	; Should we give ONLCLN a try?		;123
	BEQ	30$		; Yes!!!				;123
	CALLX	CLEAN		; Call CLEAN (in INIDEF) for START option
30$:

GLOBAL	<NOSTAR>							;062


.SBTTL	START option - mainline control

;+
;	The following subroutines, which make up the START processing,
;  are controlled from here in the root to allow them to be linked into
;  more than one RT11-flavored overlay.
;-

				; Do procesing common between DEFAULT, START:
	CALLX	BEGIN		; Call BEGIN (in INIDEF) with clean disk

	CALLX	WRITCF		; Write out CFGBUF to CONFIG.SYS.	;112

	CALLX	JAMINI		; Initialize the jam list		;097

	CALLX	INIBLD		; Build Load-Time Data Structures	;025

	CALLX	START		; Do mainline START processing		;025

	CALLX	JAMEND		; End the jam list			;097

	CALLX	INILDI		; Initialize the loader			;025

	JMPX	INILDR		; Invoke the loader			;025
				;   ...return is to RSTS !		;025

.ENABL	LSB

.SBTTL	DISPATCHES BETWEEN SAV/RES DIALOG AND SAV/RES MAIN CODE

SRDOIT::MOV	OPFLG,R0	;GET THE OPERATION DESIRED
	ASR	R0		;MAKE IT A WORD POINTER
	BIC	#1,R0		;WORDS ARE NOT ODD
	JMP	@DISPAT(R0)	;BRING IN CORRECT OVERLAY

SRDONE::RESETB			;CLEANLINESS
	CALL	SAVCLN		;CLEAN UP FROM SAVE/RESTORE
SRREDO:	TSTB	SAVBOO		;DID HE BOOT A SAVE TAPE/DISK?
	BNE	10$		;YUP, DON'T LET HIM RETRY
	JMPX	SVRST		;ASK FOR MORE SAV/RESTORE
10$:	MESSAG	<<200><200>>
	MOV	#KBUFF,R1	;POINT TO TEXT BUFFER
	CLRB	(R1)		;INDICATE NO PRESET ANSWER
	JMP	BOOT		;ASK FOR WHAT TO BOOT
	

GLOBAL	<SVRST,OPFLG,DISPAT,KBUFF>


.SBTTL	GET BOOT BLOCK INTO SATBUF

;+
; GBOOT - GET THE BOOT BLOCK FOR A DEVICE AND PUT IT IN SATBUF
;
;	JMP	GBOOT
;
;	SATBUF+10000 = BOOT BLOCK
;-

.ENABL	LSB

GBOOT::	CALLX	GGBOOT		;GET THE BOOT FROM THE COPY OVERLAY
	CALLRX	BOORET		;RETURN TO CORRECT OVERLAY

.DSABL	LSB

.SBTTL	GET BOOT BLOCK INTO SATBUF

;+
; SAVCLN - CLEAN UP AFTER A SAVE/RESTORE
;
;	CALL	SAVCLN
;
;-
.ENABL	LSB

SAVCLN:	CLRB	HIGHBF		;CLEAR HIGH MEMORY FLAG
	CLRB	NOERR		;ALLOW ERRORS
	CLRB	BACKUP		;TURN OFF BACKUP FLAG
	CLRB	AUTOQS		;NO AUTORESTART
	CLR	@#MMUSR0	;NO MAPPING
	CALL	KPARSU		;SET UP NULL MAPPING
	CMP	TAPNDX,#IDX$MS	;WAS SAV/RES DEVICE A TS11?		  ;013
	BNE	10$		;NO, THEN NO NEED TO SET "NBA" BIT IN CSR ;013
	MOV	#CSRMS,R0	;GET => TO THE TS11 BASE CSR ADDR, UNIT 0 ;013
	MOV	TAPUNT,R1	;AND GET THE TS11 UNIT NUMBER		  ;013
	ASL	R1		;* 2 FOR BYTE ADDRESSING		  ;013
	ADD	R1,R0		;ADD UNIT *2 FOR => TO THIS UNIT'S CSR 	  ;013
	MOV	(R0),R0		;NOW GET TS11 CSR USED FOR THE SAV/RES	  ;013
	BEQ	10$		;JUST 2B SURE...			  ;013
5$:	BIT	#200,(R0)	;TS11 CSR SIGNALLING REWIND COMPLETE?	;015
	BEQ	5$		;NO, WAIT FOR READY.... (TS11-SAVRES BUG) ;015
	CLR	(R0)		;SUB-SYSTEM INIT WILL ALWAYS SET "NBA"    ;013
10$:	CLR	TAPNDX		;REMOVE THE OLD TAPE SAVE INDEXT
	CLR	TAPUNT		;AND REMOVE THE OLD TAPE SAVE UNIT
	CALLX	SETFIP		;SET UP FIP AREA
	CALLX	ENDFIP		;AND MARK IT CLEAN
	CALL	LOKMIN		;FIND SYSTEM FILES AGAIN
	RETURN			;AND NOW ALL IS CLEAN

.DSABL	LSB

.SBTTL	INIT DIALOGUE (Instal/Update)

.ENABL	LSB

;	INSTALLATION / UPDATE Prompts for Read-Only system disk

I.INST:	CALLX	TYPECR		;RETURN THE CARRIAGE			;031
	TSTB	MICRO		;Micro installation?			;078
	BEQ	5$		;No, continue				;078
	CALLX	DSKIN2		;Check/initailize the system disk	;078
	JMPX	COPY2		;  then chain into the COPY option	;078

5$:	CALLX	YESNO,R5	;Ask if installing RSTS for 1st time	;078
	.WORD	10$							;031
	 GENTXT								;031
	  .ASCII "Type 'Yes' or <CR> if installing RSTS on a new system"<200>
	  .ASCII "disk for the 1st time. Type 'No' if you are updating"<200>
	  .ASCII "an existing RSTS system or copying the RSTS system"<200>
	  .ASCII "files to your system disk."<200>			;037
10$:	  .ASCIZ <200>"Installing RSTS on a new system disk? <Yes> "	;031
	  UNORG								;031
	BCS	I.INI0		; ^Z means go to "Option:"		;037
	BR	20$		;<CR> or <LF> means Yes.		;031
	BR	30$		;No.					;031
	.BR	20$		;Yes.					;031

20$:	CLRB	(R1)		;Terminate the input string here!	;037
	CALLX	DSKIN2		;Initailize the system disk		;031
	JMPX	COPY2		;  then chain into the COPY option	;031

30$:	CALLX	YESNO,R5	;Ask if Updating a RSTS system		;037
	.WORD	40$							;037
	 GENTXT								;037
	  .ASCII "Type 'Yes' or <CR> if you are updating an existing"<200>	;042
	  .ASCII "RSTS system. Type 'No' if you want to perform one of"<200> ;039
	  .ASCII "the valid INIT options."<200>				;039
40$:	  .ASCIZ <200>"Are you updating an existing RSTS system disk? <Yes> "	;042
	  UNORG								;037
	BCS	I.INI0		; ^Z means go to "Option:"		;037
	BR	50$		;<CR> or <LF> means Yes.		;031
	BR	I.INI0		;No now means goto "Option:"		;039
	.BR	50$		;Yes.					;031

50$:	INCB	UPDATE		;Set flag to say "always supercede"	;107
	CLRB	(R1)		;Terminate the input string here!	;037
;	MESSAGE	<"Please specify the system disk to COPY the RSTS files to.">
	JMPX	COPY		;Skip the DSKINT			;037



.SBTTL	INIT DIALOGUE (Start Timesharing?)

I.INIT:	CALLX	READCF		;Read [0,1]CONFIG.SYS into CFGBUF.	;112
	BITB	#BF.AST,@#B.FLGS;Is this an auto-START after boot?	;112
	BEQ	60$		;Nope, so go on.			;112
	MOV	#KBUFF,R1	;Point to input text buffer.		;112
	CLRB	(R1)		;Indicate no preset answer.		;112
	CLR	CC.DBL		;Enable ^C in case they want to get to	;113
				; "Option:" prompt to use HARDWR.	;113
	JMP	START0		;Start SIL in CONFIG.SYS.		;112

60$:	CALLX	TYPECR		;Return the carriage.			;112
	CALLX	ASKER,R5	;Ask to start timesharing		;031
	.WORD	80$							;031
	 GENTXT								;031
	  .ASCII "Type 'Yes' or <CR> to start RSTS timesharing."<200>	;031
	  .ASCII "Type 'No' to select an initialization option."<200>	;031
80$:	  .ASCIZ <200>"Start timesharing? <Yes> "			;031
	  UNORG								;031
	CALLX	ANSWER,R5	;Parse the reply  . . . .		;031
	BR	STRTUP		;Yes.					;031
	BR	I.INI0		;No.					;031
	BR	STRTUP		;<CR> or <LF> means Yes.		;031
	BR	I.INI0		;'OLD'? means No.			;031
	BR	OPTION		;Parse anything else as an Option	;037

.DSABL	LSB


.SBTTL	INIT MAIN LOOP

.ENABL	LSB

I.INI0::RESETB			;MORE CLEANLINESS
	CLRB	AUTOIN		;  and even more.			;026
	CALL	KPARSU		;Initialize null mapping		;092
	CLR	@#MMUSR0	; and disable MMU			;092
	TSTB	SAVBOO		;CAN THIS PERSON DO ANYTHING OTHER THAN BOOT?
	BEQ	10$		;YES, LET HIM GO
	MESSAG	<<200>"You must choose a device to boot!"<200><200>>
	MOV	#KBUFF,R1	;Point to the keyboard buffer.		;060
	CLRB	(R1)		;And make him answer the question.	;060
	JMP	BOOT		;FORCE HIM TO BOOT

10$:	CLR	XXXTRP		;NO RECURSIVE TRAP NOW
	CALL	SAVCLN		;CLEAN UP OLD SAVE/RESTORE STUFF
	TSTB	GOSWIT		;CAN WE GO?
	BNE	20$		;YES
	ERF	<"Option attempted during bootstrap phase.">

20$:	CALLX	TYPECR		;RETURN THE CARRIAGE
	MESSAG	<<200>"Option: <Start> ">				;045
	CALLX	GETIN		;Get an option				;044
	BEQ	HELP		;Wants help, give it			;044
	CMPB	(R1),#'Z-100	;^Z?					;044
	BEQ	I.INI0		;Ignore ^Z				;044
	CMPB	(R1),#12	;<LF>?					;044
	BNE	OPTION		;REGULAR OPTION IF NOT <LF>
STRTUP:	CLRB	(R1)		;Say there's no default answer.		;112
60$:	INCB	AUTOQS		;ANSWER FASTLY
	JMP	START0		;

OPTION:	CALLX	GETUNQ,R5,ROOOTX ;PARSE ON THE ROOT OPTION TEXT
	CLR	ERRCTR		;CLEAR THE ERROR COUNT
	TSTB	SWR$W		;CAN WE WRITE THE DISPLAY REGISTER?
	BMI	80$		;NO
	MOV	ERRCTR,@#SWR	;YES -- CLEAR WITHOUT READING SWITCHES
80$:	JMP	@ROOOPT(R0)	;GO TO THE OPTION

GLOBAL	<COPY2,KBUFF>							;060

.DSABL	LSB

.SBTTL	TRAP ILLEGAL OPTIONS

ILLOPT:	MESSAG	<"Invalid option.  Type 'HELP' for help.">
	BR	I.INI0		;GET OPTION AGAIN

CKOPT:: TST	SYNXSV		;IS THIS A MAGTAPE?
	BMI	10$		;YES, THIS OPTION NOT LEGAL
	TSTB	SAVDEV		;IS THIS A SAV/RESTORE DISK?
	BNE	10$		;YES, THIS OPTION IS NOT LEGAL
	RETURN			;NO, GO AHEAD WITH THE OPTION
10$:	TST	(SP)+		;DUMP THE RETURN
OPNOT::	MESSAG	<"Option not available"<200>>
	JMP	I.INI0		;AND GO BACK TO OPTION

.SBTTL	HELP OPTION

HELP:	CALLX	MESSAG,R5,HELPMS ;HELP IS AN EASY OPTION
	BR	I.INI0

.SBTTL	ODT OPTION

OPTODT:	BPT			;ENTER ODT
	MOV	#BPT,HALTER	;CHANGE THE SYSTEM HALT TO A BPT
	BR	I.INI0		;DONE

.SBTTL	DISPATCHES TO CLEAN FROM OTHER OPTIONS

	TMPORG	ROOCTL							;114
CLNDBG::.BLKW			;Clean debug mode flag			;114
	UNORG								;114

RCLEAN::CALLX	CLEAN		;CALL CLEAN FOR REFRESH OPTION
	JMPX	CLEANR		;REENTER TO DO RTS PC

.SBTTL	OVERLAYER FOR RT-11 OVERLAY SCHEME

.ENABL	LSB

				;R0 = WORD COUNT OF OEVERLAY
RSTOVL:	BIT	#FS.OPN,FQINIT+FQSTAT ;DO WE HAVE AN INIT?
	BEQ	NAVAIL		;NO, CAN'T DO OVERLAYS
	MOV	BLKNO,FCINIT+FCNVB ;SAVE THE BLOCK NUMBER OF THE OVERLAY
	MOV	LOADTO,10$	;10$ -> WHERE TO PUT THE OVERLAY
	MOV	#FCINIT,R1	;R1 -> FCB FOR READ
	CALLX	READ.,R5	;READ FROM INIT.SYS ON SYSTEM DISK
10$:	 .WORD	0		;FILLED WITH BUFFER ADDRESS
	BCS	20$		;EOF??
	JMP	COMEND		;DO COMMON FINISHING UP CODE

NAVAIL:	MESSAG	<"Option not available - no INIT.SYS">
	EXIT

20$:	ERF	<"EOF reading INIT.SYS">

.DSABL	LSB

.SBTTL	DO AN RT11 OVERLAY FROM A SAVE/RESTORE DISK

.ENABL	LSB

				;R0 = WORD COUNT OF OVERLAY
SAVOVL:	CLR	HIGHBF		;NO EXTENDED MEMORY I/O DURING OVERLAYS
	MOV	DCS,R3		;SET DCS FOR THIS DISK
	MOV	BLKNO,R5	;R5 = STARTING BLOCK OFFSET OF OVERLAY
	CLR	R4		;PREPARE FOR DIVIDE
	DIV	R3,R4		;R4 = DCN ; R5 = BLOCK IN CLUSTER
	ASL	R4		;R4 = OFFSET IN DCNLIST FOR CLUSTER
	ADD	#DCNLST,R4	;R4 -> FIRST BLOCK OF OVERLAY
	MOV	LOADTO,30$	;30$ -> WHERE TO PUT OVERLAY
10$:	MOV	DCS,R1		;MAKE A COPY OF THE DEVICE CLUSTER SIZE
	SUB	R5,R1		;R1 = BLOCKS LEFT IN CLUSTER
	SWAB	R1		;R1 = WORDS LEFT IN CLUSTER
	MOV	(R4)+,R2	;R2 = NEXT DCN TO READ
	CALLX	CNVRIB		;GET FBN INTO R3,R2
	ADD	R5,R2		;ADD BLOCK IN CLUSTER
	ADC	R3		;DON'T FORGET HIGH WORD
	CLR	R5		;NO BLOCKS LEFT IN CLUSTER NOW
	CMP	R0,R1		;DO WE HAVE A FULL CLUSTER LEFT TO READ?
	BHI	20$		;YES, DO THE READ
	MOV	R0,R1		;NO, DO WHAT IS LEFT TO DO
20$:	MOV	R1,I.DSQ+DSQCNT	;SET THE NUMBER OF WORDS TO READ
	CALLX	PARSEX,R5,RFUN	;DO THE READ
30$:	.WORD	0		;WHERE TO READ INTO
	TSTB	IOERR		;WAS THERE AN ERROR?
	BEQ	40$		;NO, PROCEED WITH REST
OVRER2:	JMP	OVRERR		;YES, GO FIGURE IT OUT			;092
40$:	ADD	R1,30$		;ADVANCE POINTER TO WHERE NEXT READ GOES
	ADD	R1,30$		;ADVANCE POINTER A BYTE AMMOUNT
	SUB	R1,R0		;R0 = WORDS LEFT TO READ
	BNE	10$		;IF SOME STILL LEFT THEN DO MORE READS
	JMP	COMEND		;IF NOT, THEN DO THE COMMON FINISH UP

.DSABL	LSB

.SBTTL	DO AN RT11 OVERLAY FROM A TAPE UNIT 

.ENABL	LSB

TAPOVL:	MOV	R0,R4		;MAKE A COPY OF THE SIZE OF THE OVERLAY
	CALL	SAVTAP		;SAVE THE OLD TAPE'S DENSITY
	MOV	SYSNDX,R0	;R0 = DEVICE INDEX OF SELECTED DEVICE
	MOV	SYSUNT,R1	;R1 = UNIT NUMBER FOR DEVICE
	CALLX	SETTAP		;SET UP THE TAPE DRIVE
	BCS	25$		;ALLOW NO ERRORS
	CLR	HIGHBF		;NO EXTENDED MEMORY I/O DURING OVERLAYS
	CALLX	MAGSPC,R5,3	;REWIND THE TAPE
	BCS	OVRER2		;WE DON'T LIKE ERRORS			;092
	MOV	SYSDEN,R2	;SET TAPE UP AT BOOTED DENSITY
	CALLX	MAGSPC,R5,6	;DO THE DENSITY SETTING
	BCS	OVRER2		;THIS WORKED BEFORE!			;092
	MOV	#-1,R2		;SET UP FOR INFINITE FORWARD SKIPS	;033
	CALL	MAGSPC,R5,4	;AND SPACE FORWARD INFINITE # OF RECORDS
	BCS	OVRER2		;WE DON'T LIKE ERRORS			;092
	MOV	BLKNO,R2	;GET BLOCK NUMBER FOR START OF OVERLAY
	INC	R2		;PLUS THE DOS FILE LABEL
	CALLX	MAGSPC,R5,4	;FORWARD THE TAPE TO THE DESIRED RECORD
	BCS	OVRER2		;DON'T ALLOW ERRORS			;092
	MOV	#256.,I.DSQ+DSQCNT ;SET LENGTH OF 1 TAPE RECORD
	MOV	LOADTO,R2	;R2 -> WHERE START OF OVERLAY SHOULD BE
10$:	MOV	#256.,I.DSQ+DSQCNT ;SET LENGTH OF 1 TAPE RECORD
	MOV	R2,20$		;R2 -> WHERE REST OF OVERLAY IS TO GO
	CALLX	MAGIO,R5,RFUN	;GET NEXT TAPE RECORD OF OVERLAY
20$:	.WORD	0		;WHERE TO PUT DATA
25$:	BCS	OVRERR		;CAN'T STAND THOSE ERROR'S
	ADD	#512.,R2	;ADVANCE POINTER TO WHERE REST OF OVERLAY GOES
	SUB	#256.,R4	;COUNT THESE PART OF THE OVERLAY AS DONE
	BHI	10$		;KEEP GOING IF THERE IS MORE TO DO
30$:	CALL	RESTAP		;RESTORE THE OLD TAPE'S DENSITY
	JMP	COMEND		;THEN DO THE COMMON END OF OVERLAY CODE

.DSABL	LSB

.ENABL	LSB

;+									;092
; This is the INIT overlay handler.  It has the same calling 		;092
; and global symbol references as the standard RT11 overlay handler,	;092
; and therefore is treated by the LINKer as the genuine article.	;092
; The reason for doing things this way, rather than simply emulating	;092
; the RT11 overlay handler's .READ call, is that it allows us to have	;092
; complete control of the environment, most importantly the stack,	;092
; which makes it possible to transform an overlay dispatch into a call	;092
; to a resident overlay with saved mapping, restoring it on return.	;092
; This is used for code in the MSC (Miscellaneous) phase to allow all	;092
; that to be referenced without forcing me to write dozens of transfer	;092
; vectors.								;092
;									;092
; Note, however:							;092
; The MSC mapped overlay dispatching works ONLY for routines that	;092
; do not reference arguments on the stack, do not change the stack,	;092
; and exit with a RETURN (RTS PC).					;092
;									;092
; And also:								;092
; This overlay handler is actually a subset of the real McCoy!  It	;092
; only handles a single overlay region, i.e. it assumes that the one	;092
; and only overlay region starts immediately after the root.  It	;092
; doesn't seem likely that INIT will ever want to have more than one	;092
; overlay region, but if it does you'll have to spiff up this code.	;092
; (Actually, it's not that bad.  The only place this assumption is	;092
; made is at 3$:, with the comment "(in region 1)" ... )		;092
;									;092
; Finally, a note on SILUS:						;092
; SILUS wants to be able to find the overlay table, but doesn't have	;092
; the symbols available yet when it does this.  So it looks starting	;092
; at the program base address, where it expects to find either the	;092
; standard RT11 overlay handler, or the overlay tables.  In other	;092
; words, the overlay handler here must NOT be at the start of INIT	;092
; but somewhere else, above the autoload vectors -- and the overlay	;092
; tables and autoload vectors must be at the base of INIT.  This is	;092
; set up that way with the INIT.MAC module, so be careful in that	;092
; area.									;092
;									;092
; Calling sequence:							;092
;									;092
;	JSR	R5,$OVRH						;092
;	 .WORD	overlay number * 6,entry point				;092
;									;092
; Overlay number * 6 is the offset (+6) within the overlay table, which	;092
; has the following format:						;092
;									;092
; $OVTAB:: .WORD overlay region address, block, word count		;092
;									;092
;	overlay region address is the address to read into		;092
;	block is the VBN (0-based) of the start of the overlay		;092
;	word count is the length to read for this segment		;092
;									;092
;	Note that there is a copy of the overlay number * 6 at the	;092
;	first word of each overlay segment, which is used to check if	;092
;	the overlay in question is already loaded.			;092
;									;092
; For more details on all this stuff, see the RT11 System Support	;092
; manual, part of the RT11 documentation set.				;092
;-									;092

$OVRH::				;Label that LINK looks for		;092
	CMP	(R5),#1*6	;Referencing the first overlay?		;092
	BNE	3$		;No, check for a real overlay read	;092
	MAP	PUSH,APR=5,CODE	;Push current mapping			;092
	MAP	PUSH,APR=6,CODE	; both APRs				;092
	MOV	@#MMUSR0,-(SP)	;  and also the MMUSR0 setting		;092
	MAP	#MSC$P1,APR=5,CODE ;Map the Misc (ODT and stuff) phase	;092
	MAP	#MSC$P2,APR=6,CODE ; both APRs				;092
	MOV	#1,@#MMUSR0	;Ensure MMU is enabled			;092
	MOV	2(R5),-(SP)	;Push overley entry address		;092
	MOV	10(SP),R5	;Restore caller's R5			;092
	CALL	@(SP)+		;Coroutine call to the overlay (C=0)	;092
	;The following label is for ^T processing in INITTY		;120
OVRRTN::MOV	@#PS,6(SP)	;Save current PSW on top of old R5	;092
	MOV	(SP)+,@#MMUSR0	;Restore state of MMU			;092
	MAP	POP,APR=6,CODE	;Restore APR6				;092
	MAP	POP,APR=5,CODE	; and APR5				;092
	MOV	(SP)+,@#PS	;Restore condition codes		;092
	RETURN			;Back to caller!			;092

3$:	CMP	(R5)+,@$ODF1	;Is overlay resident (in region 1)?	;092
	BEQ	35$		;Yes, just enter it			;092
	REGSAV			;NOW SAVE THE REGISTERS
	MOV	-(R5),R0	;Get overlay table offset + 6		;092
	ADD	#$OVTAB-6,R0	;Point to entry				;092
	MOV	(R0)+,LOADTO	;Get address into which to load		;092
	MOV	(R0)+,BLKNO	; and block number			;092
	MOV	(R0),R0		;Get word count				;092
	MOV	SYSNDX,20$	;SAVE THE CURRENT DEVICE INDEX
	MOV	SYSUNT,30$	;AND ALSO SAVE THE CURRENT UNIT
	MOV	R0,R4		;SAVE THE LENGTH IN WORDS OF THE OVERLAY
	MOVB	#-1,NOERR	;HANDLE ERROR TRAPS
	CALL	SETFIP		;SET UP THE SYSTEM DISK
	MOV	R4,R0		;RESTORE THE LENGTH IN WORDS OF THE OVERLAY
	CLRB	NOERR		;TURN OFF ERROR HANDLING
	TSTB	IOERR		;WAS THERE AN I/O ERROR?
	BNE	OVRERR		;YES, THAT IS UNFORGIVABLE!
	TST	SYSNDX		;WHAT SORT OF DEVICE WAS THE BOOTED DEVICE?
	BMI	TAPOVL		;MAGTAPE, THEN DO A MAGTAPE TYPE OVERLAY
	CMP	SYSNDX,#IDX$..	;Using boot driver still?
	BNE	5$		;No
	CMPB	B.NAME,#'M	;Yes, so is it a tape bootstrap?
	BNE	5$		;No, it's disk				;092
	JMP	TAPOVL		;Yes, so use appropriate overlay handler
5$:	TSTB	SAVDEV		;WAS THIS A SAV/RES DISK?
	BEQ	10$		;NO, DO NOT DO A SAV/RESTORE TYPE OVERLAY
	JMP	SAVOVL		;YES, DO A SAV/RESTORE TYPE OVERLAY
10$:	TSTB	NRSTSD		;WAS THIS A RSTS DISK?
	BNE	50$		;NO, THEN WE DON'T KNOW WHAT TO DO
	JMP	RSTOVL		;YES, DO A RT11 OVERLAY

$ODF1::	.WORD	$OVDF1		;First word of first overlay region	;092
$ODF2::	.WORD	$OVDF2		;First word after last region (unused)	;092

GLOBAL	<$OVDF1,$OVDF2,$OVTAB>						;092

COMEND:	MOVB	#-1,NOERR	;HANDLE ERROR TRAPS
	MOV	(PC)+,R0	;FETCH OLD SYSNDX
20$:	.WORD	0		;JAMMED WITH SYSNDX BEFORE OVERLAY'S
	MOV	(PC)+,R1	;FETCH OLD SYSUNT
30$:	.WORD	0		;JAMMED WITH SYSUNT BEFORE OVERLAY'S
	CALLX	SETFNS		;SET UP OLD DISK
	CLRB	NOERR		;TURN OFF ERROR TRAPPING
	TSTB	IOERR		;WAS THERE AN I/O ERROR?
	BNE	OVRERR		;YES, THAT IS UNFORGIVABLE!
	CALL	REGRES,R5	;RESTORE THE REGISTERS
35$:	MOV	(R5),R5		;Get overlay entry point into R5	;092
	RETURN	R5		;Restore caller's R5 and enter overlay	;092

50$:	ERF	<"Unknown booted device - during overlay">

OVRERR:	CMPB	IOERR,#HNGDEV	;WAS THE DISK HUNG?
	BEQ	60$		;YES, GIVE HIM THAT MESSAGE
	ERF	<"Data error on booted device">

60$:	ERF	<"Booted device hung or write locked">

	TMPORG	ROOCTL

LOADTO:	.WORD	0
BLKNO:	.WORD	0

	UNORG

.DSABL	LSB

GLOBAL	<HNGDEV>

.ENABL LSB

SAVTAP:	REGSCR			;SAVE THOSE OLD REGISTERS
	MOV	TAPNDX,R0	;R0 = INDEX OF TAPE WHOSE DENSITY WE SAVE
	MOV	TAPUNT,R1	;R1 = UNIT "
	TST	R0		;IS IT TAPE?
	BPL	50$		;NOPE, DON'T SAVE IT
	CALL	MAGSPC,R5,<7>	;FIND IT'S DENSITY
	BCS	80$		;WE DON'T TAKE ERRORS
	BIC	#117767,R3	;ISOLATE USEFUL BITS
	CMP	#10,R3		;IS IT 1600 BPI?
	BEQ	10$		;YUP, SET UP PARAMETER
	CMP	#020000,R3	;IS IT 7 TRACK 800 BPI?
	BEQ	20$		;YUP, SET UP PARAMETER
	MOV	#3,R2		;SET PARAMETER FOR 800 BPI DUMP
	BR	30$		;AND SET REST OF PARAMETER

10$:	MOV	#256.,R2	;SET PARAMETER FOR 1600 BPI PHASE ENCODED
	BR	40$		;AND SET REST OF PARAMETER

20$:	MOV	#3,R2		;SET PARAMETER FOR 800 BPI (7 TRACK)
30$:	ASL	R2		;MULTIPLY BY 2
	ASL	R2		;I MEANT BY 4
40$:	MOV	R2,60$		;SAVE THIS FOR RESTORING TAPE DENSITY
50$:	RETURN

RESTAP:	MOV	TAPNDX,R0	;GET TAPE INDEX
	MOV	TAPUNT,R1	;AND TAPE UNIT
	TST	R0		;IS THIS A TAPE?
	BPL	70$		;NOPE, DO NO RESETTING
	CALL	MAGSPC,R5,<3>	;REWIND THE TAPE
	BCS	80$		;WE DON'T LIKE THOSE ERRORS
	MOV	(PC)+,R2	;GET PARAMETER FOR DENSITY
60$:	.WORD	0		;SAVED TAPE DENSITY PARAMETER
	CALL	MAGSPC,R5,<6>	;RESTORE TAPE DENSITY
	BCS	80$		;ERROR, SCREAM OUT LOUD
70$:	RETURN			;AND THEN WE ARE DONE

80$:	ERF	<"Selected tape taken offline">

.DSABL	LSB

GLOBAL	<TAPNDX,TAPUNT>

.SBTTL	REGISTER SAVE/RESTORE
;+
; REGSAV - SAVE ALL REGISTERS ON STACK.
;
;	REGSAV
;
;	-OR-
;
;	CALL	REGSAV,R5
;
; NOTE: THE REGSAV MACRO DEFINES THE SYMBOLS:
;		TOS.R0,TOS.R1,...,TOS.R5
;	TO BE TO SP STACK OFFSETS TO GET AT THOSE REGISTERS.
;-
REGSAV::;MOV	R5,-(SP)	;R5 WAS SAVED BY THE 'JSR R5,'
	MOV	R4,-(SP)	;SAVE R4,
	MOV	R3,-(SP)	; AND R3,
	MOV	R2,-(SP)	;  AND R2,
	MOV	R1,-(SP)	;   AND R1,
	MOV	R0,-(SP)	;    AND R0
	MOV	5*2(SP),-(SP)	;REPLICATE SAVED R5
RTSR5::	RETURN	R5		;AND EXIT

;+
; REGSCR - SAVE ALL REGISTERS ON STACK AND SET UP CO-ROUTINE EXIT.
;
;	REGSCR
;
;	-OR-
;
;	CALL	REGSCR,R5
;
; NOTE: THE REGSCR MACRO DEFINES THE SYMBOLS:
;		TOS.R0,TOS.R1,...,TOS.R5,TOS.RA
;	TO BE TO SP STACK OFFSETS TO GET AT THOSE REGISTERS.
;-
REGSCR::;MOV	R5,-(SP)	;R5 WAS SAVED BY THE 'JSR R5,'
	MOV	R4,-(SP)	;SAVE R4,
	MOV	R3,-(SP)	; AND R3,
	MOV	R2,-(SP)	;  AND R2,
	MOV	R1,-(SP)	;   AND R1,
	MOV	R0,-(SP)	;    AND R0
	MOV	R5,-(SP)	;SAVE RETURN ADDRESS ON STACK
	MOV	6*2(SP),R5	;NOW RESTORE THE REAL R5 VALUE
	CALL	@(SP)+		;NOW CALL OUR CALLER

;+
; RESRPC - RESTORE ALL REGISTERS AND RETURN.
;
;	JMP	RESRPC
;-
RESRPC::CALL	REGRES,R5	;RESTORE R0 THROUGH R5
	RETURN			;AND RETURN

;+
; REGRES - RESTORE ALL REGISTERS FROM STACK.
;
;	CALL	REGRES,R5
;-
REGRES::MOV	(SP)+,R0	;DUMMY TO REMOVE SAVED R5
	MOV	(SP)+,R0	;RESTORE R0,
	MOV	(SP)+,R1	; AND R1,
	MOV	(SP)+,R2	;  AND R2,
	MOV	(SP)+,R3	;   AND R3,
	MOV	(SP)+,R4	;    AND R4
	RETURN	R5		;RESTORE R5 AND EXIT

;039+
.SBTTL	DATE AND TIME INPUTTER
.ENABL	LSB

REDATE:	CALLX	RCTRLO			;Speak up
	CALLX	TYPECR			;New line
	MOV	I.DATE,R1		;Get current date
	CALL	DATCHK			;Check it out
	CALL	ASKDAT			;Ask appropriately
	CALL	ASKDAY			;See if we need to know the day	;117
	MOV	I.TIME,R1		;Get current time
	CALL	TIMCHK			;Check it out
	CALL	ASKTIM			;Ask time appropriately
	EXIT				;Now back to Option:

DATINI::
	CMP	I.DATE,DATLST		;Was the last date same as this?
	BNE	5$			;No, go ahead
	CMP	I.TIME,TIMLST		;Same date, same time?
	BNE	5$			;No, so print out date and time
	RETURN				;Why bother?

5$:	CALLX	RCTRLO			;Speak up
	CALLX	TYPECR			;New line
	MOV	I.DATE,R1		;Get current date
	CALL	DATCHK			;Is it valid?
	BCC	20$			;Yep, all's well
	CALL	ASKDAT			;Get a valid date
	CALL	ASKDAY			;See if we need to know the day	;117
	MOV	I.TIME,R1		;Get current time
	CALL	TIMCHK			;Valid?
	BCS	30$			;No, gotta ask
10$:	MOV	R1,TIMLST		;Save the last time printed
	CALL	TIMPR2			;Print out the time
	CALLRX	TYPECR			;New line, and return to caller

20$:	CLRB	WHRTYP			;Output to terminal
	CALL	DATPR2			;Print it out
	MOV	I.DATE,DATLST		;Save the last date printed
	MOV	#40,R2			;Separate with a space, like DCL ;041
	CALLX	TYPE			;Print it out			;041
	MOV	I.TIME,R1		;Get current time
	CALL	TIMCHK			;Is it valid?
	BCC	10$			;Okay
	CALLX	TYPECR			;New line
30$:	.CALLR	ASKTIM			;Get a valid time and return

.DSABL	LSB

.ENABL	LSB

ASKTIM:	MOV	#70$,R0			;Point to place for output string
	MOV	#14.,R2			;Length of time field		;078
10$:	MOVB	#176,70$-1(R2)		;Preset with ignores
	SOB	R2,10$
	TSTB	VALFLG			;Current time valid?
	BMI	30$			;No, end prompt and ask		;078
	MOV	I.TIME,R1		;Valid, use current time as default
	MOVB	#'<,(R0)+		;Open angle bracket		;078
	MOVB	#-1,WHRTYP		;Flag to say type to buffer
	MOV	R0,DATPTR		;Point to the buffer
	CALL	TIMOUT			;Convert it
	MOVB	#'>,@DATPTR		;Close angle bracket		;078
	INC	DATPTR			;Update pointer			;078
	BR	50$			;Now go ask for time

30$:	CLRB	(R0)			;End prompt			;078
50$:	MESSAGE				;Prompt				;078
	  .ASCII <200>"Current time? "					;078
70$:	  .ASCIZ "xxxxxxxxxxxxxx "					;078
	 UNORG								;078
	CLR	TIMTOY			;No TOY time to set yet		;092
	CALLX	GETIN			;Get input			;078
	BEQ	80$			;He wants help			;078
	CMPB	(R1),#12		;Defaulted?			;078
	BNE	90$			;No, check what was typed	;078
	MOV	I.TIME,R1		;Get old time value
	TSTB	VALFLG			;Was old value valid?
	BPL	140$			;Yes, so use it
80$:	MESSAG								;078
85$:	  .ASCII <200>"Enter the current time as HOUR:MINUTES AM or"	;078
	  .ASCII " PM (e.g., 1:15 PM)"<200>				;078
	  .ASCIZ "or in 24-hour format as HOUR:MINUTES (e.g., 13:15)"	;078
	 UNORG								;078
	BR	ASKTIM			;Ask again

90$:	CALLX	DECINP			;Get decimal number
	CMP	R0,#23.			;Valid?
	BHI	80$			;Nope.
	MOV	R0,R3			;Save hours
	CMPB	(R1)+,#':		;Check delimiter
	BNE	80$			;No good
	CALLX	DECINP			;Get minutes
	CMP	R0,#59.			;Valid?
	BHI	80$			;Nope
	MOV	R3,TOYHR		;Save hours for TOY		;092
	MOV	R0,TOYMIN		; and minutes too		;092
	MOV	SP,TIMTOY		;Flag that time should be set	;092
	MUL	#60.,R3			;Hours * 60
	ADD	R0,R3			;Plus minutes
100$:	CMPB	(R1)+,#40		;Skip any spaces
	BEQ	100$
	TSTB	-(R1)			;End in <NUL> (24-hour format?)
	BEQ	130$			;Yes, go compute it
	CMP	R3,#1*60.		;AM/PM, 0 is illegal hour
	BLO	80$			;Ouch!
	CMP	R3,#13.*60.		;Hours past 12 are illegal
	BHIS	80$			;Ouch!
	CMP	R3,#12.*60.		;Hours past 12 are illegal
	BLO	110$			;12:xx?
	SUB	#12.*60.,R3		;Yes, so make it 00:xx
	CLR	TOYHR			;Saved one also			;092
110$:	CMPB	(R1)+,#'A		;AM?
	BEQ	120$			;Could be...
	CMPB	-1(R1),#'P		;No, better be PM
	BNE	80$			;Ouch!
	ADD	#12.*60.,R3		;Noon or later
	ADD	#12.,TOYHR		;Saved one also			;092
	BIS	#100000,TOYHR		;Set a PM flag			;117
120$:	CMPB	(R1)+,#'M		;The trailing M is required
	BNE	80$			;Whoops!
	TSTB	(R1)			;End of line?
	BNE	80$			;Nope
130$:	SUB	#1440.,R3		;Set base time
	NEG	R3			;(1440 - R3) = -(R3 - 1440)
	MOV	R3,I.TIME		;Set INIT's time
	MOV	R3,TIME			;RSTS time too
	MOV	(PC)+,R1		;Get date and reset it
NEWDAT:	.WORD	0
	MOV	R1,I.DATE		; in case midnight rolled over
	MOV	R1,DATE			;RSTS location too
	MOV	#60.,TIMSEC		;Start seconds over again.	;061
	CALL	SETTOY			;Update TOY clock		;092
140$:	RETURN				;All done

.DSABL	LSB

.ENABL	LSB

DATCHK:	CMP	R1,#20001.		;After 01-Jan-90?		;117
	BLO	30$			; No, invalid			;117
	CMP	R1,#65366.		;Before end of 2035?		;117
	BHI	30$			; No, invalid			;117
	CLR	R0			;Clear for divide
	DIV	#1000.,R0		;Unpack date
	ADD	#70.,R0			;Bias year to 1970
	CMP	R0,#100.		; but did it exceed 2 digits?	;120
	BLO	5$			; No, so proceed		;120
	SUB	#100.,R0		; Yes, so adjust 2000 = 100 = 0 ;120
5$:	CALL	FEBCHK			;Fix length of February
	MOV	R1,R2			;Copy day count
	BEQ	30$			;Day 0 isn't valid
	MOV	#MONTHS-3,R5		;Point to month table
10$:	ADD	#3,R5			;Point to next month
	MOVB	(R5)+,R1		;Get days in month
	BEQ	30$			;Off end of table, so day too high
	SUB	R1,R2			;Decrease days left
	BHI	10$			;Keep going
	ADD	R2,R1			;Get day within month
20$:	CLRB	VALFLG			;All's well (And C-clear)
	RETURN

TIMCHK::TST	R1			;Time = 0?
	BEQ	30$			;Yes, invalid
	CMP	R1,#1440.		;Out of range?
	BLOS	20$			;Nope, it's a good number
30$:	SEC				;Set flag for invalid date/time
	MOVB	#-1,VALFLG		;...both C-bit and a cell
	RETURN				;Return to caller

ASKDAT:	CLRB	JDATE			;Clear flag to say asking new date
	MOV	#60$,R0			;Point to place for output string ;078
	TSTB	VALFLG			;Current date valid?		;078
	BMI	40$			;No, end prompt and ask		;078
	MOV	I.DATE,R1		;Valid, use current date as default
	MOVB	#'<,(R0)+		;Open angle bracket		;078
	CALL	DATSTR			;Convert it
	BR	50$			;Now go ask for date		;078

40$:	CLRB	(R0)			;End prompt			;078
50$:	MESSAGE				;Prompt				;078
	  .ASCII <200>"Today's date? "					;078
60$:	  .ASCIZ <176>"xxxxxxxxx> "					;078
	 UNORG								;078
	CALLX	GETIN			;Get input			;078
	BEQ	90$			;He wants help			;078
	CMPB	(R1),#12		;Defaulted?			;078
	BNE	110$			;No, check what was typed	;078
70$:	MOV	I.DATE,R1		;Get old date value		;078
	TSTB	VALFLG			;Was old value valid?
	BEQ	170$			;Yes, so use it
80$:	TSTB	JDATE			;String scan or input
	BNE	30$			;String scan, go tell caller it's bad
90$:	TST	D.DATF			;Which format should we use?	;078
	BGT	100$			;Numeric 			;078	
	MESSAG	<<200>"Enter today's date as DAY-MONTH-YEAR (e.g., 7-SEP-85)"> ;078
	BR	ASKDAT			;Ask again			;078

100$:	MESSAG	<<200>"Enter today's date as YEAR.MONTH.DAY (e.g., 85.9.13)"> ;078
	 UNORG								;078
	BR	ASKDAT			;Ask again			;078

CKDATE::MOVB	#1,JDATE		;Flag string check only
110$:	CALLX	DECINP			;Get day or year
	CMPB	(R1),#'.		;Numeric format used?
	BNE	120$			;Nope, it better be alphabetic
	INC	R1			;Skip the dot
	MOV	R0,R2			;Save the year
	CALLX	DECINP			;Parse the month
	CMP	R0,#12.			;Too high?
	BHI	80$			;Yep, that's illegal
	MOV	R0,R5			;Save it
	BEQ	80$			;Whoops!  Zero isn't legal either
	ASH	#2,R5			;Month * 4
	ADD	#MONTHS+1-4,R5		;Point to month name for later check
	CMPB	(R1)+,#'.		;Separator correct?
	BNE	80$			;Nope, error
	CALLX	DECINP			;Fine, now parse the day
;	BNE	80$			;Didn't end with a null <- do we care?
	MOV	R0,R3			;Copy the day
	MOV	R2,R0			;Put year back in R0
	BR	150$			;Join common range checking code

120$:	MOV	R0,R3			;Save the day (Like Mighty Mouse)
	CMPB	(R1),#'-		;Proper delimiter?
	BNE	80$			;Nope, error
	MOV	R1,R5			;Copy pointer to month name
	ADD	#4,R1			;Don't check it yet
	CMPB	(R5),(R1)+		;Proper delimiter again?	;078
	BEQ	140$			;Yes, go ahead			;078
130$:	CMPB	(R5),(R1)+		;Check next, delimiter?		;078
	BEQ	140$			;Yes, go ahead			;078
	BGT	80$			;Invalid character, error	;078
	BR	130$			;Next character			;078

140$:	TSTB	(R5)+			;Skip past delimiter		;078
	CALLX	DECINP			;Get the year
;	BNE	80$			;Didn't end with a null <- do we care?

150$:	CALL	FEBCHK			;Fix length of February
	MOV	R0,TOYYR		;Save year for TOY		;092
	MOV	R3,TOYDAT		; and date			;092
	CLR	TOYMON			;Initialize for month-finding loop ;092
	CMP	R0,#99.			;Year in 20th century?
	BHI	80$			;Sorry, we're not that futuristic
	CMP	R0,#90.			; Is it before 1990		;117
	BHIS	155$			;  Yes, so OK.			;117
	CMP	R0,#65.			;   2035 or earlier?		;117
	BHI	80$			;   NO, 1965-1990		;117
	ADD	#30.+70.,R0		;Adjust to make 0=30, 1=31...	;117
155$:	SUB	#70.,R0			;Bias year for Julian-70 format
	MUL	#1000.,R0		;R1 = Year * 1000, R0 = 0
	TST	R3			;Bad day?
	BEQ	80$			;Yes, error
	MOV	#MONTHS-2,R2		;Point to table of month names
160$:	ADD	R0,R1			;Add length of skipped month into date
	CMPB	(R2)+,(R2)+		;Skip the previous month
	MOVB	(R2)+,R0		;Get length of month
	BEQ	80$			;Whoops! end of table
	CMPB	(R5),(R2)+		;First char match for month?
	BNE	160$			;No
	CMPB	1(R5),(R2)		;2nd character match?
	BNE	160$			;No
	CMPB	2(R5),1(R2)		;Last character match?
	BNE	160$			;No
	CMP	R3,R0			;Day too high for this month?
	BHI	80$			;Yes
	ADD	R3,R1			;Add in day of month to the date
	SUB	#MONTHS+2-4,R2		;Compute month * 4		;117
	ASH	#-2,R2			;Now * 1			;117
	MOV	R2,TOYMON		; and save for the TOY		;117
	TSTB	JDATE			;String scan? (Clear carry too)
	BNE	180$			;Yes, return to caller with C-clear
	MOV	R1,I.DATE		;Store it away for INIT
	MOV	R1,DATE			;...and for RSTS
	CALL	SETTOY			;Save the TOY clock		;092
170$:	MOV	R1,NEWDAT		;Save date in case time changes
180$:	RETURN				;All done for here

.DSABL	LSB

.ENABL	LSB

ASKDAY:	MOV	TOYYR,R2	;Get the already legal year		;117
	MOV	R2,R1		;COPY THE YEAR AGAIN			;117
	SUB	#68.,R1		;MAKE IT 1968 BASED FOR LEAPYEAR CHECK	;117
	SUB	#70.,R2		;MAKE YEAR SINCE 1970			;117
	MOV	R2,R5		;COPY THE YEAR				;117
	MUL	#365.,R5	;# DAYS SINCE 1970 (-LEAP YEARS)	;117
	CLR	R0		;GET SET FOR THE DIVIDE			;117
	DIV	#4,R0		;CHECK FOR LEAP YEARS			;117
	ADD	R0,R5		;ADD IN THE RIGHT NUMBER OF LEAPYEARS	;117
	TST	R1		;DID WE HIT A LEAP YEAR EXACTLY		;117
	BNE	20$		;NO					;117
	CMP	TOYMON,#2	;ARE WE IN JAN OR FEB OF LEAPYEAR	;117
	BLO	10$		;Jan, SO WE'RE ALL SET			;117
	BHI	20$		; After Feb, so all set.		;117
	CMP	TOYDAT,#28.	; Is it before the 29.?			;117
	BHI	20$		; No, its after.			;117
10$:	DEC	R5		;SO DON'T COUNT THIS YEARS DAY		;117
20$:	MOV	NEWDAT,R1	;Get the newly specified date		;117
	CLR	R0		;Get set for the divide			;117
	DIV	#1000.,R0	; and get just the remainder		;117
	ADD	R5,R1		;ADD IN THE DAYS OF THE CURRENT YEAR	;117
	CLR	R0		;Get ready for the divide		;117
	DIV	#7.,R0		; to calculate the day of week		;117
        ADD     #3.,R1          ; and adjust for 1-Jan-70=Thursday	;117
        CMP     R1,#7.          ;Did we walk past the end of week?      ;117
        BLE     30$             ; No                                    ;117
        SUB     #7.,R1          ; Yes, so backup to start of week.      ;117
30$:	MOV	R1,TOYDAY	;Now store the day away			;117
	RETURN			; all done with DAY figuring		;117

.DSABL	LSB

.SBTTL	DATSTR - Put an alphanumeric date in a string
;+
; DATSTR - Put a specified date in a specified 9-byte string
;
;	R0 -> 9-byte buffer
;	R1 =  Desired date
;
;	CALL	DATSTR
;
;	All registers preserved
;
;-

.ENABL	LSB

DATSTR::REGSCR				;Save the world
	MOV	R0,DATPTR		;DATPTR -> buffer to fill with date
	MOVB	#-1,WHRTYP		;Flag that says to type to the buffer
	MOV	#9.,R2			;Fill the buffer with
10$:	MOVB	#176,(R0)+		; ignore characters
	SOB	R2,10$
	BR	20$			;Convert the date and return to caller

TMPORG	ROOCTL

DATLST:	.WORD	-1
TIMLST:	.WORD	-1
DATPTR:	.WORD	0
WHRTYP:	.BYTE	0
VALFLG:	.BYTE	0
	.EVEN
TIMTOY:	.WORD	0		;Flag to force time update into TOY clock ;092
TOYSML:	.WORD	0		;TOY clock 100ths of a second		;117
TOYSEC:	.WORD	0		;TOY clock seconds			;117
TOYMIN:	.WORD	0		;Minutes to go into TOY			;092
TOYHR:	.WORD	0		;Hours for TOY				;092
TOYDAY:	.WORD	0		;TOY clock day				;117
TOYDAT:	.WORD	0		;Date for TOY (0 not to set date)	;092
TOYMON:	.WORD	0		;Month for TOY				;092
TOYYR:	.WORD	0		;Year for TOY				;092

JTOYD:	.BLKW	4		;4 words for KDJ11-E TOY clock data	;117

UNORG

DATPRT::MOV	I.DATE,R1		;Get current date
PRTDAT::CLRB	WHRTYP			;Flag for terminal type
20$:	CALL	DATCHK			;Check out the date
	BCC	DATPR2			;Okay
	CALLR	ASKDAT			;Go out setting the date

DATPR2:	TST	D.DATF			;Which format
	BLE	30$			;Alphabetic
	CALL	90$			;Type the year
	SUB	#MONTHS+1-4,R5		;Compute month * 4
	ASH	#-2,R5			;Now * 1
	MOV	R5,R0			;Copy month number
	MOV	#'.,R2			;First type a dot
	CALL	70$			;Then the month
	MOV	R1,R0			;Copy day
	MOV	#'.,R2			;First type a dot
	BR	70$			;Then the day, and we're done

30$:	MOV	R1,R2			;Copy the day
	CALL	DEC2DG			;Output as 2 decimal digits
	MOV	#'-,R2			;Delimiter is a dash
	CLR	R1			;First alphabetic is upper case
40$:	CALL	WHRTP1			;Print the character
	MOVB	(R5),R2			;Get a character of month name
	BIS	R1,R2			;Make it lower case if 2nd or 3rd
	MOV	#40,R1			;Any further are lower case
	CMPB	(R5)+,#'A		;Still doing the name
	BHIS	40$			;Yes, so keep going
	MOV	#'-,R2			;Get the delimiter
70$:	CALL	WHRTP1			;Print the delimiter
90$:	MOV	R0,R2			;Copy the number to type
DEC2DG:	SWAB	R2			;Put number in high byte
100$:	ADD	#<-10.*256.>+1,R2	;Count decimal
	BPL	100$
	ADD	#<10.*256.>-1+"00,R2	;Adjust for ASCII
	CALLR	WHRTP2			;Return thru 2-char output routine

.DSABL	LSB

.ENABL	LSB

TIMPRT::MOV	I.TIME,R1		;Get current time
PRTTIM::CALL	TIMCHK			;Check validity
	BCC	TIMPR2
	CALLR	ASKTIM			;Go out asking time

TIMPR2:	CLRB	WHRTYP			;Output to terminal
TIMOUT:	CLR	R2			;Pre-clear high order
	MOV	#12.*60.,R3		;Pre-set number of minutes at noon
	TST	D.TIMF			;Which format
	BLE	10$			;Alphabetic
	ASL	R3			;Number of minutes at midnight
	SUB	R1,R3			;Minus number of minutes 'til midnight
	DIV	#60.,R2			;Get hours and minutes
	BR	30$			;Go do it

10$:	MOV	#"PM,R0			;Assume noon or after-noon
	SUB	R1,R3			;Noon minus minutes 'til midnight
	BHIS	20$			;Noon or after-noon
	MOV	#"AM,R0			;Before noon, set AM trailer
	ADD	#12.*60.,R3		;Fix time back to positive
20$:	DIV	#60.,R2			;Get hours and minutes
	BNE	30$			;Non-zero hour is fine
	MOV	#12.,R2			;Else use 12:xx
30$:	CALL	DEC2DG			;Output the hour...
	MOV	#':,R2			; the separator...
	CALL	WHRTP1
	MOV	R3,R2			;Copy the minutes
	CALL	DEC2DG			; output minutes...
	TST	D.TIMF			;Which format
	BGT	50$			;24-hour, so we're done
	MOV	#40,R2			; output a a space...
	CALL	WHRTP1
	MOV	R0,R2			;Get AM/PM indicator
	.CALLR	WHRTP2			;Exit thru 2-character output routine

WHRTP2:	CALL	WHRTP1			;Output first char
	SWAB	R2			;Get second
	BEQ	50$			;Ignore if it's a null
WHRTP1:	TSTB	WHRTYP			;Where does it go?
	BNE	40$			;Buffer
	CALLR	TYPE			;Terminal use type routine

40$:	MOVB	R2,@DATPTR		;Store the character
	INC	DATPTR			;Bump the pointer
50$:	RETURN				;Done

.DSABL	LSB

FEBCHK:	MOVB	#28.,MONFEB		;Assume not a leap year (3 out of 4)
	BIT	#3,R0			;Is the year a multiple of 4?
	BNE	10$			;No, so we were right
	INCB	MONFEB			;Yes, so February has 29 days
10$:	RETURN								;039-

	I.MESS
MONTHS:	.ASCII	<31.>"JAN"
MONFEB:	.ASCII	<28.>"FEB"<31.>"MAR"<30.>"APR"<31.>"MAY"<30.>"JUN"<31.>"JUL"
	.ASCIZ	<31.>"AUG"<30.>"SEP"<31.>"OCT"<30.>"NOV"<31.>"DEC"
	UNORG


.SBTTL	Update the TOY clock to reflect user-supplied date/time

;+									;092+
; Update the Time of Year clock with the new date/time supplied
; by the user.  Data that was defaulted is not changed.  Note that
; when the time is set, the date is set (again) as well, to ensure
; that end of day wrap doesn't kill us.
;-

SETTOY:	TSTB	FLGGPK		;Is this a GPK?
	BEQ	40$		;No, so it has no TOY clock
	CLR	TOYDAY		;zero for the GPK			;117
10$:	TSTB	@#CLKCS0	;Update in progress?
	BMI	10$		;Yes, wait until done
.ASSUME	UIP EQ 200
	BIS	#SET,@#CLKCS1	;Set the bit to say we're setting the TOY
	MOV	TOYDAT,R0	;Get date
	BEQ	20$		;None to be set
	MOV	R0,@#CLKDAT	;Set it
	MOV	TOYDAY,@#CLKDAY	;Set the day of the week (if any)	;117
	MOV	TOYMON,@#CLKMON	;Set month
	MOV	TOYYR,@#CLKYR	; and year
20$:	TST	TIMTOY		;Need to set time?
	BEQ	30$		;No
	CLR	TIMTOY		;Yes, but not next time
	MOV	TOYMIN,@#CLKMIN	;Set minutes
	MOV	TOYHR,R1	;get hours				;117
	BIC	#100000,R1	; clearing any PM flag			;117
	MOV	R1,@#CLKHR	; and store the hours			;117
	CLR	@#CLKSEC	;Seconds is always zeroed when setting
30$:	BIC	#SET,@#CLKCS1	;Done setting
40$:	CMP	JCPTYP,#5	;Are we working on a KDJ11-E?		;117
	BNE	100$		; No, so just exit now			;117
	MOV	R1,-(SP)	;Save R1 for the caller			;117
	CALL	TOYINI		;Go initialize the TOY			;117
	MOV	#JTOYD,R2	;Pass J-11 TOY data area pointer	;117
	CALL	TOYGET		; and read it so we can update it	;117
	BICB	#^C<7>,JTOYD+4	;Set the clock to turn on!		;117
	MOV	TOYDAY,R1	;New day to set?			;117
	BEQ	45$		; NO					;117
	MOVB	R1,JTOYD+4	; Yes, so set it			;117
45$:	TST	TIMTOY		;Need to set time?			;117
	BEQ	70$		;No					;117
	CLR	TIMTOY		;Yes, but not next time			;117
	CLR	JTOYD		;Seconds and 100ths always zeroed 	;117
	MOV	TOYMIN,R1	;Get the minutes			;117
	CALL	BINBCD		; into the right format			;117
	MOVB	R1,JTOYD+2	;  to give to the KDJ11-E TOY		;117
	CLRB	JTOYD+3		;Assume Numeric				;117
	TST	D.TIMF		;Which Time format?			;117
	BR	50$		; (Change to BGT 50$ to allow AM/PM)	;117
	BISB	#200,JTOYD+3	;Change to Alphabetic			;117
50$:	MOV	TOYHR,R1	;Get the hours				;117
	BR	60$		; (Change to BPL 60$ to allow AM/PM)	;117
	BISB	#40,JTOYD+3	; Set as PM				;117
	SUB	#12.,R1		;  and adjust to the correct hour	;117
60$:	CALL	BINBCD		; into the right format			;117
	BISB	R1,JTOYD+3	;  to give to the KDJ11-E TOY		;117
70$:	MOV	TOYDAT,R1	;Get the date				;117
	BEQ	75$		;None to update				;117
	CALL	BINBCD		; into the right format			;117
	MOVB	R1,JTOYD+5	;  to give to the KDJ11-E TOY		;117
	MOV	TOYMON,R1	;Get the month				;117
	CALL	BINBCD		; into the right format			;117
	MOVB	R1,JTOYD+6	;  to give to the KDJ11-E TOY		;117
	MOV	TOYYR,R1	;Get the year				;117
	CALL	BINBCD		; into the right format			;117
	MOVB	R1,JTOYD+7	;  to give to the KDJ11-E TOY		;117
75$:	CLR	-(SP)		;Prepare to get the old CSR contents	;117
	MOVB	@#TOYCSR+1,(SP)	; the old stuff from the TOYCSR		;117
	CALL	TOYINI		;Go initialize the TOY			;117
	MOV	#4,R0		; 4 words must be loaded		;117
	MOV	#JTOYD,R2	;Get the pointer to the data		;117
80$:	MOV	(R2)+,R1	; so get each word			;117
	CALL	TOYLOD		; and go load this one			;117
	SOB	R0,80$		; making sure we get them all		;117
	TST	(SP)+		;and trash the old CSR contents		;117
	MOV	(SP)+,R1	;Restore the callers R1			;117
100$:	RETURN			;Done					;117


.SBTTL	MAKE DUMP TABLE + RETURN NEEDED CRASH FILE SIZE

;+
; DMPLEN - Create dump table and return needed crash file size in blocks
;
;
;	CALL	DMPLEN
;
;	Table at X.TAB filled in for crash dumping.
;
;	R0 = Number of DCN's required for crash if SIL installed
;	   = 0  if no SIL installed
;-

.DSECT	,NOCREF		;VERIFY MEMORY DUMP SEGMENT ORDERING

XM.ADD:	.BLKW		;ADDRESS OF THE AREA/64.
XM.LEN:	.BLKW		;LENGTH OF THE AREA/64.
XMTLEN:			;LENGTH OF THE TABLE ENTRY

UNORG

DMPLEN::CLR	R0		;GUESS NO SIL INSTALLED
	TST	SILNAM		;HOW WAS OUR GUESS?
	BEQ	10$		;BRANCH IF IT WAS CORRECT
	REGSCR			;ELSE SAVE REGISTERS IN COROUTINE
	MOV	#X.TAB,R5	;PREPARE TO SET UP DUMP TABLE		;016
	CLR	(R5)+		;Root dump starts at 0			;016
	MOV	@X.MONS,R2	;GET SIZE OF ROOT DUMP IN BYTES
	ADD	#777,R2		;ROUND UP ROOT DUMP AREA
	BIC	#777,R2		; TO THE NEXT BLOCK BOUNDARY
	;CLC			;(THE ADD CLEARED CARRY)
	ROR	R2		;AND CONVERT ROOT DUMP SIZE
	ASH	#-5,R2		; TO MMU UNITS
	CALL	30$		;  PUT ROOT LENGTH IN THE TABLE
	MOV	@#D.LB+LBFPLP,R1 ;GET THE MMU ADDRESS OF FIP'S POOL	;016
	MOV	@#D.LB+LBFPLL,R2 ; AND THE LENGTH OF THE POOL IN SLIVERS ;016
	CALL	25$		;Store that				;016
	MOV	@#D.LB+LBMCPP,R1 ;GET THE MMU ADDRESS OF THE MSCP REGION ;016
	MOV	@#D.LB+LBMCPL,R2 ; AND THE LENGTH OF THE MSCP REGION	;016
	CALL	25$		;Store that				;016
	MOV	@#D.CACH,R1	;Get XBUF address in K words...		;076
	MOV	@#D.CACH+2,R2	; and XBUF length in K words.		;076
..NXBF	==	.-2	;***PATCH TO X.TAB TO DISABLE XBUF DUMPING
	CALL	20$		;  FINISH OUT THE ENTRY
	MOV	@#D.LB+LBJCRP,R1 ;Get the MMU address of the JCR	;064
	MOV	@#D.LB+LBJCRL,R2 ;Get the length of the JCR		;064
	CALL	25$		;Go set that up				;064
	MOV	#0,R1		;Location of "JOB" header		;117
	MOV	#HDRSIZ,R2	; and its size in K			;117
.ASSUME	SEG.JH+1  EQ	6.	;Job header segment not 6th		;117
	CALL	22$		; and close it				;117
	MOV	#0,R1		;Location of "FIJOB" header		;117
	MOV	#HDRSIZ,R2	; and its size in K			;117
.ASSUME	SEG.FH+1  EQ	7.	;FIP Job header segment not 7th		;117
	CALL	22$		; and close it				;117
	MOV	@#..DSEG,R1	;GET OPTIONAL SEGMENT ADDRESS IN K WORDS
	MOV	@#..DSEG+2,R2	; AND OPTIONAL SEGMENT LENGTH IN K WORDS
	CALL	20$		;  FINISH OUT THE ENTRY

.ASSUME	XMSEGS	EQ	8.	;Mismatch between ROOT and KERNEL	;117

	MOV	R0,TOS.R0(SP)	;RETURN R0 - # CRASH FILE BLOCKS NEEDED
10$:	RETURN


;	R1 = Address of segment in K words
;	R2 = Length of segment in K words
;	Make the table entry and update the current crash file size.

20$:	ASH	#5,R1		;CONVERT K WORDS ADDRESS TO MMU UNITS
22$:	ASH	#5,R2		;CONVERT K WORDS LENGTH TO MMU UNITS
25$:	MOV	R1,(R5)+	;PUT THE ADDRESS IN THE TABLE		;016

;	Round our current block count up to the next
;	device cluster of the system disk.

	MOV	B.DCS,R4	;GET BOOT DISK DEVICE CLUSTER SIZE
	DEC	R4		;AND ROUND OUR CURRENT
	ADD	R4,R0		; BLOCK COUNT
	BIC	R4,R0		;  TO THE NEXT DEVICE CLUSTER
        
;	R2 = Length in MMU units (bytes/64.)
;	Put the length entry into the table.
;	Add the length entry to the block count.

30$:	MOV	R2,(R5)+	;NOW PUT MMU LENGTH INTO DUMP TABLE
	ADD	#7,R2		;ROUND MMU LENGTH UP TO THE NEXT BLOCK
	ASH	#-3,R2		; AND CONVERT IT TO A BLOCK COUNT
	BIC	#^C<17777>,R2	; without sign extend problems		;105
	ADD	R2,R0		;NOW ADD IT TO OUR RUNNING BLOCK COUNT
	RETURN

..DSEG::.BLKW0	2	;***PATCH FOR OPTIONAL DUMP AREA
			;..DSEG   = ADDRESS OF AREA IN K WORDS
			;..DSEG+2 = LENGTH OF AREA IN K WORDS

TMPORG	ROOCTL

X.TAB::	.BLKW0	XMSEGS*2	;DEFINE THE DUMP TABLE

UNORG

.SBTTL	SET UP THE MMU TO THE NULL MAPPING

;+
; KPARSU - SET UP THE KERNEL MMU MAPPING TO NIL
;
;	CALL	KPARSU
;
;	MMU SET UP SO THAT TURNING IT ON MAPS TO LOW 28K & I/O PAGE
;-

KPARSU::MOV	R0,-(SP)	;SAVE R0
	MOV	R1,-(SP)	;SAVE R1
	MOV	MMUSR0,-(SP)	;Save current mapping state (On/Off)	;055
	CLR	MMUSR0		;Turn mapping off			;055
	MOV	#KISAR0,R0	;R0 -> KERNEL ADDRESS REG
	CLR	R1		;R1 = ADDRESS, STARTING AT 0K
10$:	MOV	#<<128.-1>*256.>+6,KISDR0-KISAR0(R0) ;4K R/W
	MOV	R1,(R0)+	;ADDRESS / 100
	ADD	#200,R1		;NEXT 4K BLOCK
	CMP	R0,#KISAR0+20	;DONE?
	BLO	10$		;NO
	MOV	#177600,-(R0)	;YUP, MAKE HIGH 4K MAP TO THE I/O PAGE
	MOV	(SP)+,MMUSR0	;Turn mapping back on if desired	;055
	MOV	(SP)+,R1	;RESTORE REGS
	MOV	(SP)+,R0
	RETURN

.SBTTL	LOOK UP THE MINIMAL SET OF FILES

LOKMIN::TST	SYSNDX		;ARE WE RUNNING FROM TAPE?
	BMI	10$		;YES, DISABLE EVERYTHING
	TSTB	SAVDEV		;ARE WE RUNNING FROM A SAV/RESTORE DISK
	BNE	10$		;YES, DISABLE EVERYTING
	CALL	LKBADB		;MAKE SURE WE HAVE BADB.SYS
	BCS	10$		;NO, TURN OFF SYSTEM DISK
	CALL	LKSATT		;MAKE SURE WE HAVE SATT.SYS
	BCS	10$		;NO, NO SYSTEM DISK
	CALL	LKINIT		;MAKE SURE WE HAVE INIT.SYS
	BCS	10$		;NO, NO SYSTEM DISK!
	TST	SILNAM		;IS THERE A SIL?
	BEQ	10$		;NO, DON'T READ IN DEFAULTS
	CALL	LKSIL		;YES, OPEN THE SIL
	BCS	10$		;ERROR, COULDN'T FIND IT
	CALL	DEFALI		;READ IN THE DEFAULTS
10$:	RETURN

.SBTTL	LOOK UP CRITICAL SYSTEM FILES

.ENABL	LSB

LKBADB::MOV	#FQBADB,R4	;POINT TO THE FIRQB
10$:	CALLX	LOKFIL		;LOOK UP THE FILE
	BCC	20$		;GOT IT
	MOV	#<BOONAM-2>-DSKNAM,SYSNDX ;SYSTEM DEVICE IS ??
	MOV	SYSNDX,SYNXSV	;ANYWHERE
	MOV	#"??,SYSNAM	;NO SYSTEM NAME
	CALLX	TYPFIL		;TYPE THE FAILING FILE NAME
	MESSAG	<" not found - results are unpredictable"<200>>
	SEC			;INDICATE FAILURE
20$:	RETURN

LKSATT::MOV	#FQSATT,R4	;POINT TO THE FIRQB
	BR	10$		;COMMON CODE

LKINIT::MOV	#FQINIT,R4	;POINT TO THE FIRQB
	BR	10$

LKSIL::	MOV	#SILNAM+2,R1	;POINT TO THE INSTALLED NAME
	MOV	#FQSIL,R4	;POINT TO THE FIRQB
	MOV	(R1),FQNAM1+2(R4) ;MOVE THE NAME INTO THE FIRQB
	MOV	-(R1),FQNAM1(R4)
	BEQ	30$		;NO NAME!
	CALLX	LOKFIL		;LOOK UP THE FILE
	BCC	40$		;GOT IT
	CALLX	TYPFIL		;TYPE THE FILE NAME
	MESSAG	<" not found - please install a SIL"<200>>
	CLR	(R1)		;NO SIL NAME
	CLR	2(R1)
30$:	SEC			;INDICATE NOTHINGNESS
40$:	RETURN

.DSABL	LSB

;+
;
;	ROUTINE FOR SWAPPING IN INSTALLED DEVICE TABLE FROM ITS NORMAL HOME
; IN THE INIDST OVERLAY INTO SATBUF. 
;
;	R0 = OFFSET IN SATBUF TO PLACE DSTBL
;	
;	CALLX	DSTBLI
;
;	RETURNS:	DSTBL IN SATBUF
;			REGISTERS PRESERVED
;
;-

.ENABL	LSB

DSTBLI::REGSCR			;SAVE THOSE VALUABLE REGISTERS
	MOV	#DSTBL,R1	;FETCH THE DEFAULT LOCATION FOR DSTBL
	ADD	R0,R1		;ADD IN OFFSET IN SATBUF TO PUT DSTBL
	MOV	R1,10$		;AND STORE AS A PARAMETER TO READ.
	MOV	#DSTBLO,R4	;R4 -> START OF OVERLAY CALL
	CMP	(R4)+,(R4)+	;ADVANCE TO OVERLAY NUMBER
	MOV	(R4),R4		;FETCH OVERLAY NUMBER
	ADD	#$OVTAB-6,R4	;USE AS INDEX INTO OVERLAY DISPATCH TABLE
	TST	(R4)+		;ADVANCE TO RELATIVE BLOCK FOR OVERLAY
	MOV	(R4),R2		;SAVE RELATIVE BLOCK IN R2
	MOV	#FCINIT,R1	;R1 -> FCB FOR INIT.SYS
	MOV	R2,FCNVB(R1)	;STORE BLOCK FOR NEXT READ IN FCB
	MOV	#DSTBLL,R0	;R0 = LENGTH IN WORDS TO READ IN
	CALLX	READ.,R5	;READ DS TABLE INTO SATBUF
10$:	.WORD	DSTBL		;DEFAULT LOCATION TO READ IN DS TABLE
	RETURN

.DSABL	LSB

	GLOBAL	<DSTBLO,$OVTAB>


.SBTTL	WRITE OUT INSTALL BUFFER

;+
; INSTAO - WRITE THE INSTALL BUFFER BACK TO INIT.SYS ON DISK
;
;	CALL	INSTAO
;
;	R0 =  RANDOM
;	R1 =  RANDOM
;-

.ENABL	LSB

INSTAO::MOV	#FQINIT+FQFCB,R1 ;POINT TO THE FCB FOR INIT.SYS I/O
	MOV	#INSBUF,R0	;GET ADDRESS OF INSBUF
	SWAB	R0		;CONVERT TO BLOCK NUMBER IN INIT.SYS
	ROR	R0
	MOV	R0,FCNVB(R1)	;SET UP BLOCK TO WRITE
	MOV	#SZ.INS*256.,R0	;SET UP NUMBER OF WORDS TO WRITE
	CALLX	WRITE.,R5,INSBUF ;WRITE FROM INSBUF
	RETURN

.DSABL	LSB


.SBTTL	READ BAD BLOCK RECORD FOR SAV/RESTORE

;+
; BBLOK	- READ THE BAD BLOCK RECORD FOR SAVE/RESTORE
;
;	SATBUF CLEAR, SYSNDX,SYSUNT SET UP
;	R0 = 0 (CAME FROM DIALOG OVERLAY); 1 (CAME FROM SAV OVERLAY)
;
;	JMP	BBLOK,R5
;	R1 =
;	0 I/O DATA ERROR 	
;	1 DRIVE NOT READY	
;	2 TOO MANY BAD BLOCKS	
;	3 UNKNOWN DISK TYPE	
;	4 HAS NO BAD BLOCKS	
;	5 NORMAL		
;		SATBUF+1000 CONTAINS LIST OF LOGICAL BAD BLOCKS
;		TERMINATED BY TWO WORDS OF ZERO
;-

.ENABL	LSB

BBLOK::	REGSAV			;SAVE THE REGISTERS
	MOVB	#-1,NOERR	;TRAP ALL ERROR RETURNS
	CLR	-(SP)		;ERROR CODE FILLED IN HERE
	MOV	SYSNDX,R4	;FIND OUT WHAT KIND OF DISK THIS IS
	MOV	R4,R3		;MAKE IT INTO A BYTE POINTER
	ASR	R3		;R3 OFFSET FOR # OF BAD BLOCK TRACK BLOCKS
	MOVB	150$(R3),R0	;R0 = # BAD BLOCK TRACK BLOCKS
	BEQ	90$		;DOES NOT CONFORM TO DEC STD 144
	MOV	SYSUNT,R2	;R2 = UNIT # FOR DISK
	ASL	R2		;DOUBLE UNIT NUMBER IT
	CMP	R0,#6		;IS THIS A MAYBE DEC STD 144 DISK?
	BNE	10$		;NO, GO LOOK FOR BLOCKS
	DEC	R0		;LOOK FOR 5 BLOCKS
	MOV	R2,R3		;MAKE A COPY OF THE UNIT NUMBER
	ADD	DSKMID(R4),R3	;GET MASS BUSS ID# POINTER
	MOV	(R3),R3		;GET MASS BUSS ID#
	BIC	#4000,R3	;REMOVE DUAL PORT BIT
	SUB	#20020,R3	;GET ID INTO RANGE
	CMP	R3,#2		;IS IT AN RP04/5/6?
	BLOS	90$		;YES, THEN IT HAS NO DEC STD 144 TRACK
10$:	MOV	R2,R3		;MAKE A COPY
	MOV	R2,R1		;ANOTHER ONE
	ADD	DSKSZL(R4),R2	;R2 -> LSB OF DISK SIZE
	ADD	DSKSZM(R4),R3	;R3 -> MSB OF DISK SIZE
	MOV	(R2),R2		;R2 = LSB OF DISK SIZE
	MOV	(R3),R3		;R3 = MSB OF DISK SIZE
	MOV	DCS,-(SP)	;GET THE CLUSTER SIZE
	DEC	(SP)		;COMPUTE WASTED SPACE
	SUB	(SP)+,R2	;SUBTRACT FROM LBN
	SBC	R3		;TO GET FBN (FBN=LBN-DCS+1)
	CALLX	RDERR,R5	;READ THE BAD BLOCK TRACK INTO SATBUF
	BR	70$		;ERROR RETURN

	CMP	#IDX$DL,R4	;ARE WE LOOKING AT A DL?
	BEQ	20$		;YES
	CMP	#IDX$DM,R4	;ARE WE LOOKING AT A DM?
	BEQ	30$		;YES
	ADD	DSKMID(R4),R1	;R1 -> MASS BUS ID FOR THIS DISK UNIT
	MOV	(R1),R3		;R3 = MASS BUS ID FOR THIS DISK UNIT
	BIC	#4000,R3	;REMOVE DUAL PORT BIT
	SUB	#020020,R3	;AND GET IT INTO RANGE
	CMP	R3,#27		;DO WE KNOW ABOUT THIS DISK?
	BHIS	100$		;NO, SCREAM QUIETLY
	ASL	R3		;2 BYTES PER ENTRY
	ADD	#160$,R3	;R3 -> TRACKS/CYLINDER
	MOVB	(R3)+,R0	;R0 = TRACKS/CYLINDER
	MOVB	(R3)+,R1	;R1 = SECTORS/TRACK
	CLR	R2		;1 BLOCK PER SECTOR
	BR	40$		;INTERPRET BAD BLOCK TRACK

20$:	MOV	#2,R0		;2 TRACKS/CYLINDER
	MOV	#40.,R1		;40 SECTORS/TRACK
	MOV	#-1,R2		;2 SECTORS/BLOCK
	BR	40$		;INTERPRET BAD BLOCK TRACK
	
30$:	MOV	#3,R0		;3 TRACKS/CYLINDER
	MOV	#22.,R1		;22 SECTORS/TRACK
	CLR	R2		;1 BLOCK PER SECTOR
40$:	REGSAV			;SAVE OUR REGISTERS AGAIN
	MOV	#SATBUF+10,R4	;POINT TO THE BAD SECTOR INFORMATION
	MOV	#SATBUF+1000,R0	;R0 -> LIST OF BAD LOGICAL BLOCKS
50$:	MOV	(R4)+,R3	;R3 = CYLINDER NUMBER
	BMI	60$		;END OF LIST, RESTORE REGISTERS
	MUL	TOS.R0(SP),R3	;R3 = TRACK NUMBER
	MOV	R3,R2		;MAKE A COPY
	CLR	-(SP)		;MAKE ROOM FOR THE SECTOR NUMBER
	BISB	(R4)+,(SP)	;FETCH THE SECTOR NUMBER
	CLR	R3		;MAKE ROOM FOR THE TRACK NUMBER
	BISB	(R4)+,R3	;R3 = TRACK NUMBER
	ADD	R3,R2		;ADD IN CYLINDER OFFSET
	MUL	TOS.R1+2(SP),R2	;R2,R3 = SECTOR NUMBER
	ADD	(SP)+,R3	;ADD IN SECTOR OFFSET
	ADC	R2		;INTO HIGH WORD ALSO
	ASHC	TOS.R2(SP),R2	;SHIFT BY NUMBER OF SECTORS/BLOCK
	MOV	R3,(R0)+	;STORE IN LOGICAL BAD BLOCK LIST
	MOV	R2,(R0)+	;STORE HIGH ORDER BLOCK NUMBER TOO
	BR	50$		;ELSE CONTINUE

60$:	CLR	(R0)+		;INDICATE END OF LIST
	CLR	(R0)+		;WITH 2 WORDS OF ZERO
	CALLX	REGRES,R5	;RESTORE THE REGISTERS
	BR	80$		;LEAVE WITH NORMAL RETURN

70$:	BCS	120$		;HUNG DEVICE ERROR RETURN
	BR	130$		;DATA I/O ERROR

80$:	INC	(SP)
90$:	INC	(SP)
100$:	INC	(SP)
110$:	INC	(SP)
120$:	INC	(SP)
130$:	MOV	(SP)+,TOS.R1(SP)
	CALLX	REGRES,R5
	CLRB	NOERR
	TST	R0
	BNE	140$
	JMPX	BBDIA

140$:	JMPX	BBSAV

150$:	.BYTE	0		;DC BLOCKS IN BAD BLOCK TRACK
	.BYTE	0		;DF
	.BYTE	0		;DS
	.BYTE	0		;DK
	.BYTE	5		;DL
	.BYTE	5		;DM
	.BYTE	0		;DP
	.BYTE	6		;DB (*KLUDGE*) SOMETIMES NOT DEC STD 144
	.BYTE	6		;DR (*KLUDGE*) SOMETIMES NOT DEC STD 144
	.BYTE	0		;DZ has no bad block data		;092
	.BYTE	0		;DW **temp** no bad block data		;092
	.BYTE	0		;DU CANNOT READ FACTORY BAD BLOCK ON UDAs
	.EVEN

160$:	.BYTE	22.,19.		;RP04 SECTORS/TRACK, TRACKS/CYLINDER
	.BYTE	22.,19.		;RP05
	.BYTE	22.,19.		;RP06
	.BYTE	0  ,0
	.BYTE	32.,5.		;RM03
	.BYTE	32.,5.		;RM02
	.BYTE	31.,14.		;RM80 LOGICAL SECTORS/TRACK, TRACKS/CYLINDER
	.BYTE	32.,19.		;RM05
	.BYTE	0  ,0
	.BYTE	0  ,0
	.BYTE	0  ,0
	.BYTE	0  ,0
	.BYTE	0  ,0
	.BYTE	0  ,0
	.BYTE	0  ,0
	.BYTE	0  ,0
	.BYTE	0  ,0
	.BYTE	0  ,0
	.BYTE	50.,32.		;RP07
	.BYTE	0  ,0
	.BYTE	0  ,0
	.BYTE	0  ,0
	.BYTE	0  ,0
	.BYTE	0  ,0

.DSABL	LSB
GLOBAL	<NOERR>

.SBTTL	DEFALI/DEFALO - Read in/write out Default Buffer

.ENABL	LSB								;089
;+
; DEFALO - Write Default Buffer from DEFBUF
; DEFALI - Read Default Buffer into DEFBUF
;
;	Caller must ensure that SIL is open on FQSIL
;
;	CALL	DEFALO
;            or
;	CALL	DEFALI
;
;	Defaults written/read from/into Default Buffer into/from SIL
;	SIL index read into SILBUF
;	IDXBLX = number of blocks in SIL index
;
;	If SIL index is corrupt, SIL has no DEFALT module, DEFALT module is
;	too small, or an error occurs during the write/read, an error message
;	is printed and INIT is restarted.
;
;-

DEFALO::MOV	#WRIT.B,-(SP)	; Push address of WRITE routine...	;089
	BR	10$		;  ...and join common code.		;089

DEFALI::MOV	#READ.B,-(SP)	; Push address of READ routine.		;089
10$:	PUSH	<R2,R3>		; Save a couple of scratch registers.	;089
				; R3 is pre-loaded before each operation;089
				;  with a pointer to the specific error	;089
				;  text for that operation.		;089
	MOV	(PC)+,R3	; Pre-load error text pointer.		;089
	GENTXT	<"SIL index is corrupt"<200>>
	CALLX	SILNDX,R5,FQSIL	; Get SIL index into SILBUF and check it
	BNE	50$		; Oops, installed SIL has bad format.	;089
	MOV	R0,IDXBLX	; Record number of blocks in SIL index	;025
	MOV	(PC)+,R3	; Pre-load error text pointer.		;089
	GENTXT	<'Cannot find module "DEFALT" in SIL index'<200>>
	CALL	SILSCN,R5	; Scan SIL index for the DEFALT module
	 .RAD50	/DEFALT/
	BCS	50$		; Oops, installed SIL is incomplete.	;089
	MOV	#FQSIL+FQFCB,R1	; Point to FCB again
	MOV	SE.BLK(R0),FCNVB(R1) ; Get starting block of defaults
	MOV	SE.SIZ(R0),R0	; and get size of region
	MOV	(PC)+,R3	; Pre-load error text pointer.		;089
	GENTXT	<"Default area is too small"<200>>
	CMP	R0,#SIZDEF	; Is the default area big enough?
	BLO	50$		; No, bug in installed SIL.		;089
	MOV	#SZ.DEF,R2	; Get number of blocks to read in R2.	;089
	MOV	#DEFBUF,30$	; Set up the correct buffer address.	;089
	MOV	(PC)+,R3	; Pre-load error text pointer.		;089
	GENTXT	<"Error while reading/writing default area"<200>>
20$:	CALL	@4(SP),R5	; Read or write a block of defaults.	;089
30$:	.WORD	0		; Buffer address (set up above).	;089
	BCS	50$		; If something evil happened, punt.	;089
	DEC	R2		; We've done one more - count it.	;089
	BEQ	40$		; If we're through, get out.		;089
	ADD	#512.,30$	; Now bump the buffer addr up a block.	;089
;	INC	FCNVB(R1)	; Say to do the next virtual block.	;089
				;  (READ.B/WRIT.B does this for us).	;089
	BR	20$		; And, go back for more.		;089

40$:	POP	<R3,R2>		; Get our original registers back.	;089
	TST	(SP)+		; Get rid of unneeded stuff, too.	;089
	TST	I.DFLD		; Set Z on defaults present.		;089
	RETURN			; And, go back.				;089

50$:	MESSAG	<"Installed SIL invalid - "> ; General error header.	;089
	MOV	R3,R0		; Get pointer to specific error text...	;089
	CALLX	ASCIZ0		;  ...and print it out.			;089
	JMP	I.INI0		; Go restart INIT.			;089

GLOBAL	<READ.B,WRIT.B>							;089

.DSABL	LSB								;089


.SBTTL	SILSCN - Scan SIL for module name

;+
; SILSCN - scan a SIL index for a named module
;
;	SILBUF must contain the SIL index block
;
;	CALL	SILSCN,R5
;	 .RAD50	/MODNAM/
;
;	C=0	Module found, R0 -> SIL index entry
;	C=1	Module not found, R0 random
;	R1 is destroyed
;-

SILSCN::MOV	#SILBUF,R0	; R0 -> SIL index block
	MOV	(R0)+,R1	; R1 = # of entries in SIL
10$:	CMP	(R0),(R5)	; Name match?
	BNE	20$		; No
	CMP	2(R0),2(R5)	; Both halves?
	BEQ	30$		; Yup, we got it
20$:	ADD	#SE.LEN,R0	; Bump R0 by size of SIL entry
	SOB	R1,10$		;  and try again
	SEC			; Indicate not found
30$:	BIT	(R5)+,(R5)+	; Skip over the name
	RETURN	R5		;  and return

.SBTTL	ROUTINES TO MAINTAIN AUXILIARY SAT BUFFER

.ENABL	LSB

;+
; GETSB2 - GET A BYTE FROM THE AUXILIARY SAT BUFFER
;
;	MOV	OFFSET,-(SP)	;WHERE OFFSET IS 0 TO 17777
;
;	CALL	GETSB2
;
;	(SP) CONTAINS THE BYTE FROM THE AUXILIARY BUFFER
;		IF THE OFFSET IS EVEN, A FULL WORD IS FETCHED
;-

GETSB2::CALL	SETSB2		;SET UP THE MMU
	ADD	#140000,2(SP)	;RELOCATE OFFSET TO BE MAPPED ABSOLUTE
	MOV	2(SP),SB2ADR	;SAVE THE ADDRESS FOR FUTURE PUTSB2 CALL
	BIT	#1,2(SP)	;WORD OFFSET?
	BNE	10$		;NO
	MOV	@2(SP),2(SP)	;YES, GET A WHOLE WORD
	BR	RSTSB2		;GO TURN OFF MMU

10$:	MOVB	@2(SP),2(SP)	;REPLACE ADDRESS WITH BYTE OF DATA
	BR	RSTSB2		;GO TURN OFF MMU

;+
; PUTSB2 - PUT A BYTE TO THE AUXILIARY SAT BUFFER
;
;	MOV	DATA,-(SP)	;PUT BYTE OF DATA ON THE STACK
;
;	CALL	PUTSB2
;
;	THE DATA BYTE IS POPPED FROM THE STACK AND REPLACES THE
;		BYTE MOST RECENTLY FETCHED BY GETSB2
;-

PUTSB2::CALL	SETSB2		;SET UP THE MMU
	MOVB	2(SP),@SB2ADR	;REPLACE THE BYTE OF DATA
	MOV	(SP)+,(SP)	;DUMP THE DATA BYTE
	BR	RSTSB2		;GO TURN OFF THE MMU

.SBTTL	HIGH MEMORY MANIPULATION ROUTINES
;+
; SAVSAT - COPY SATBUF TO THE AUXILIARY SAT BUFFER
;
;	CALL	SAVSAT
;-

SAVSAT::REGSCR			;SAVE REGISTERS
	MOV	#SATBUF,R0	;SOURCE IS SATBUF
	MOV	#140000,R1	;DESTINATION IS MAPPED AUXILIARY BUFFER
	BR	20$		;GO TO MERGE WITH OTHER LOOP



;+
; RESSAT - RESTORE SATBUF FROM AUXILIARY SAT BUFFER
;
;	CALL	RESSAT
;-

RESSAT::REGSCR			;SAVE REGISTERS
	MOV	#140000,R0	;SOURCE IS MAPPED AUXILIARY BUFFER
	MOV	#SATBUF,R1	;DESTINATION IS SATBUF
20$:	CALL	SETSB2		;SET UP THE MMU
MOV4K:	MOV	#<16.*256.>/2,R2;COUNT OF DOUBLE WORDS TO MOVE		;027
30$:	MOV	(R0)+,(R1)+	;MOVE A
	MOV	(R0)+,(R1)+	; DOUBLE WORD
	SOB	R2,30$		;  UNTIL DONE
RSTSB2::CLR	@#MMUSR0	;TURN OFF THE MMU
	RETURN

;+
; RELC4K - Relocate 4KW of memory within INIT
;
;	Source and destination are specified in MMU units ("slivers")
;
;	To relocate an entire 4KW page:
;
;	R0  =	"From" MMU address
;	R1  =	"To"   MMU address
;	CALL	RELC4K
;	R0, R1 and R2 = random
;
;	Note: If the source and destination 4K pages overlap, (and the
;	      the destination address starts above the source address),
;	      than a reverse copy will be done. (i.e. the copy will start
;	      from the highest virtual address and end at the lowest
;	      virtual address). Otherwize a foward copy will be done.
;-

RELC4K::CALL	KPARSU		;Set up null Kernel mapping		;027+
	MOV	R0,@#KISAR5	;  FROM this MMU.
	MOV	R1,@#KISAR6	;    TO this MMU.
	MOV	#1,@#MMUSR0	;Turn on the memory management
	SUB	R1,R0		;Do the source and destinations overlap?
	BPL	40$		;Destination is lower, so it doesn't matter
	CMP	R0,#<-4.*32.>	;They might... Is it a full page away?
	BHI	60$		;  No, they overlap, so do the copy in reverse
40$:	MOV	#120000,R0	; Set FROM virtual address.			
	MOV	#140000,R1	; Set TO   virtual address.	
	CALL	MOV4K		;  and go do a foward copy.
50$:	CLR	@#MMUSR0	;Turn of Memory Management
	RETURN

60$:	MOV	#140000,R0	;Set from Virtual address (Virt. APR5+2)
	MOV	#120000,R1	;Set to   Virtual address (Virt. APR6+2)
	MOV	#<16.*256.>/2,R2;Set R2 to the number of double words to move
70$:	MOV	-(R0),-(R1)	;Now move a double word
	MOV	-(R0),-(R1)	;			in reverse
	SOB	R2,70$		;				until done.
	BR	50$		;Restore mapping and return.		;027-


;+
; PTRSB2 - POINT TO THE AUXILIARY SAT BUFFER WITH MAPPING SET UP
;
;	CALL	PTRSB2
;
;	(SP) PUSHED IS THE ADDRESS OF THE AUXILIARY SAT BUFFER
;
; NOTE - CALLER MUST CALL RSTSB2 TO TURN OFF MMU WHEN DONE
;	 CALLER MAY NOT DO I/O WHILE AUXILIARY BUFFER IS MAPPED
;-

PTRSB2::MOV	(SP),-(SP)	;MAKE ROOM ON THE STACK
	MOV	#140000,2(SP)	;GIVE HIM THE MAPPED ADDRESS
SETSB2:	CALL	KPARSU		;SET UP THE MMU WITH THE NULL MAPPING
	MOV	#SATBF2,@#KISAR6 ;MAP 140000-157777 TO PHYSICAL LOC FOR SATBF2
	MOV	#1,@#MMUSR0	;TURN ON THE MMU
	RETURN

.DSABL	LSB

	TMPORG	ROOTBL
SB2ADR:	.WORD	0		;SAVE ADDRESS FROM GETSB2
	UNORG

.SBTTL	ROUTINES FOR PEEKING AND POKING IOBUFF

;+
; GETIOB - GET A WORD FROM THE HIGH MEMORY I/O BUFFER
;
;	MOV	OFFSET,-(SP)	;WHERE OFFSET IS 0 TO 16384.
;
;	CALL	GETIOB
;
;	(SP) CONTAINS THE WORD FROM IOBUFF.
;-

.ENABL	LSB

GETIOB::MOV	2(SP),-(SP)	;MAKE A COPY OF THE OFFSET
	CALL	20$		;MAP THE I/O BUFFER
	MOV	@(SP)+,2(SP)	;FETCH THE DATA
	BR	10$		;AND UNMAP THE BUFFER

;+
; PUTIOB - PUT A WORD INTO THE HIGH MEMORY I/O BUFFER
;
;	MOV	OFFSET,-(SP)	;WERE OFFSET IS 0 TO 16384.
;	MOV	DATA,-(SP)	;DATA IS WHAT TO PUT IN THE BUFFER
;
;	CALL	PUTIOB	
;
;	(SP) CONTAINS THE OFFSET
;+

PUTIOB::MOV	4(SP),-(SP)	;MAKE A COPY OF THE OFFSET
	CALL	20$		;MAP THE I/O BUFFER
	MOV	4(SP),@(SP)+	;JAM IN THE DATA
	MOV	(SP)+,(SP)	;AND REMOVE THE DATA FROM THE STACK
10$:	CLR	@#MMUSR0	;TURN OFF MEMORY MANAGEMENT
	RETURN	

20$:	CALL	KPARSU		;SET UP KERNEL MAPPING
	CMP	2(SP),#4096.*2	;FIRST 4K PAGE OF I/O BUFFER?
	BLO	30$		;YES, MAP IT IN
	ADD	#-4096.*2,2(SP)	;NO, CHANGE OFFSET TO SECOND PAGE
	MOV	#IOBUF2,@#KISAR6 ;AND MAP IN SECOND PAGE
	BR	40$		;TURN ON MEMORY MANAGEMENT
30$:	MOV	#IOBUF1,@#KISAR6 ;SET MAPPING FOR FIRST PAGE OF IOBUFF
40$:	ADD	#140000,2(SP)	;MAKE (SP) -> BUFFER WORD
	MOV	#1,@#MMUSR0	;TURN ON MEMORY MANAGEMENT
	RETURN

.DSABL	LSB

.SBTTL	DISK PHASE INTERFACE ROUTINES

KPARDK:	MAP	PUSH,APR=5,CODE	;Save APR5 mapping			;092
	MAP	PUSH,APR=6,CODE	; and APR6				;092
	MOV	@#MMUSR0,-(SP)	;  and MMU state			;092
	MAP	#DSK$P1,APR=5,CODE ;Map the disk phase			;092
	MAP	#DSK$P2,APR=6,CODE ; in APR6 also			;092
	MOV	#1,@#MMUSR0	;Ensure MMU is enabled			;092
	CALL	@6(SP)		;Coroutine call back to caller		;092
	MOV	(SP),10(SP)	;Update return address			;092
	INC	(SP)+		; and clean the stack (C untouched)	;092
	MOV	(SP)+,@#MMUSR0	;Restore MMU state			;092
	MAP	POP,APR=6,CODE	; and APR6				;092
	MAP	POP,APR=5,CODE	;  and APR5				;092
	RETURN

XXRSET::CALLX	GETTTY		;GET THE CLOCK UP TO DATE
	CMPB	R1,#IDX$..	;Using boot driver index?
	BNE	10$		;No
	RETURN			;Yes, that's a NOP then

10$:	CALL	KPARDK		;TURN ON DISK PHASE MAPPING
	CLC			;In case Reset is a NOP			;092
	CALL	@JXRSET		;RESET THE DISK
	CALL	@(SP)+		;Restore mapping			;092
	RETURN			;ALL DONE

DISK::	CALLX	GETTTY		;GET THE CLOCK UP TO DATE
	CMPB	DSQJOB(R4),#IDX$.. ;Using boot driver index?
	BNE	10$		;No
	JMP	BTDISK		;Yes, so use the bootstrap

10$:	CALL	KPARDK		;TURN ON DISK PHASE MAPPING
	CALL	@JDISK		;DO THE I/O
	CALL	@(SP)+		;Restore mapping			;092
	RETURN

.SBTTL	COMMON DISK END OF TRANSFER HOUSEKEEPING

;+									;092+
; DFINT9 - SAY IDLE, DE-QUEUE, AND HOUSEKEEP.
;
;	R0 -> QUEUE ROOT
;	R4 -> DSQ
;
;	CALL	DFINT9
;-

DFINT9::CLR	DSO$XX(R0)	;;SAY DRIVE IS NOW IDLE
	CLR	(R0)		;;DE-QUEUE THIS REQUEST
	MOVB	DSQSAV(R4),DSQFUN(R4) ;;ENSURE CORRECT RETURNED FUNCTION
				;;INIT HAS NO ACTION ON COMPLETION
	RETURN			;;AND EXIT


.SBTTL	COMMON DISK ERROR CHECKING

;+
; DFINT4 - CHECK FOR MASSBUS PARITY ERROR ALSO.
;
;	R3 -> RHCS1 OF THE MASSBUS CONTROLLER
;	R4 -> DSQ
;	Z-BIT = 1 IF A SOFT ERROR
;
;	CALL	DFINT4
;
;	R1 =  RANDOM
;
;	IF N=1 THEN A SOFT ERROR AND MORE RETRIES ALLOWED
;	IF N=0 THEN A HARD ERROR OR NO MORE RETRIES LEFT
;-

.ENABL	LSB

DFINT4::BEQ	DFINT3		;;Z=1, SO CALL IT A SOFT ERROR
	MOV	#10$,-(SP)	;;Z=0, HARD, SET SPECIAL RETURN ADDRESS
	MOV	#RHMCPE,R1	;;GET THE MASSBUS PARITY ERROR BIT
	BIC	(R3),R1		;;IF MASSBUS PARITY THEN SET Z=1

;+
; DFINT1 - CHECK FOR SOFT TYPE ERROR.
;
;	R4 -> DSQ
;	Z-BIT = 1 IF A SOFT ERROR
;
;	CALL	DFINT1
;
;	R1 =  RANDOM
;
;	IF N=1 THEN A SOFT ERROR AND MORE RETRIES ALLOWED
;	IF N=0 THEN A HARD ERROR OR NO MORE RETRIES LEFT
;-

DFINT1::BEQ	DFINT3		;;Z=1 (NO MATCH) => SOFT ERROR (POSSIBLE RETRY)
	MOVB	#HNGDEV-1,DSQERR(R4) ;;SET THE HARD ERROR CODE (-1 FOR INC BELOW)
	.BR	DFINT3		;; AND COUNT AS AN ERROR

GLOBAL	<HNGDEV>


;+
; DFINT3 - CHECK FOR MORE RETRIES.
;
;	R4 -> DSQ
;
;	CALL	DFINT3
;
;	R1 =  RANDOM
;
;	IF N=1 THEN A SOFT ERROR AND MORE RETRIES ALLOWED
;	IF N=0 THEN A HARD ERROR OR NO MORE RETRIES LEFT
;-

DFINT3::INCB	DSQERR(R4)	;;NOW CHECK FOR POSSIBLE RETRY
	RETURN			;;IF N=1 THEN RETRY POSSIBLE

10$:	BMI	20$		;;MORE RETRIES, SO RETRY
	MOVB	#HNGDEV,DSQERR(R4) ;;ELSE SET THE HARD ERROR CODE
20$:	RETURN			;;AND EXIT

.DSABL	LSB

GLOBAL	<HNGDEV>							;092-


.SBTTL	DISK ERROR LOGGING ROUTINES

.ENABL LSB
;+
;	DSKLOG used by disk formatters in INIDSI
;-
DSKLOG::MOV	R4,-(SP)	;SAVE R4
	MOV	#I.DSQ,R4	;HERE'S A DSQ WE CAN USE
	MOV	SYSNDX,DSQJOB(R4) ;DISK TYPE
	MOV	SYSUNT,DSQUNT(R4) ;UNIT NUMBER
	CALL	KPARDK		;TURN ON DISK PHASE MAPPING
	LOG$DK			;ENTER LOGGER VIA EMT
	CLR	@#MMUSR0	;TURN OFF MAPPING
	CALL	KPARSU		; AND RESTORE NORMAL MAPPING
	MOV	(SP)+,R4	;RESTORE R4
CLCRTS:	CLC			;INDICATE DATA ERROR
	RETURN			;RETURN TO CALLER

;+
;	ERRLOG -  LOG$D? EMTs are directed to this routine
;-

ERRLOG:	TSTB	BACKUP		;ARE WE RUNNING SAVRES?
	BNE	10$		;YES, DON'T MESS UP PRETTY LISTING
..ERLG	==	.-2		;Feature **PATCH** to NOP for SAVRES error log
	CMP	@#KISAR5,DSKAP5	;ERROR FROM CONVENTIONAL DISK/TAPE PHASE?
	BEQ	20$		;YES, ERROR LOGGER ALREADY MAPPED
	CMP	@#KISAR5,BBRAP5	;ERROR FROM MSCP  - BBR PHASE?			;063
	BEQ	30$		;YES, DO A MAPPED CALL INTO THE ERROR LOGGER
	CMP	@#KISAR5,MCPAP5 ;ERROR FROM TMSCP - MCP PHASE?			;063
	BEQ	30$		;YES, DO A MAPPED CALL INTO THE ERROR LOGGER	;063
	ERF	<"INIT bug -- Error logged outside disk/tape driver">

10$:	RTI			;RETURN FROM INTERRUPT

20$:	CALL	@JERRLG		;CALL THE (already mapped) ERROR LOGGER
	BR	10$		;AND RETURN FROM THE INTERRUPT

;
;	For MSCP devices, a pointer to the response packet in error
;	is passed in R1. If R1 is zero, then the error is a hard
;	controller error encoded in the SA CSR register.
;	
30$:	TST	R1		;IS THIS A HARD CONTROLLER ERROR
	BEQ	40$		;YES, SA REGISTER IS ALL WE HAVE
	BIT	#MSGTP,E.CRDT(R1) ;IS THIS AN I/O RELATED ERROR? (SEQUENTIAL)?
	BNE	10$		;NO, COULD BE DATAGRAM, OR CREDIT NOTE, IGNORE
40$:	MOV	#10$,-(SP)	;STACK THE RETURN ADDRESS FOR A MAPPED CALL
	MOV	@#KISAR5,-(SP)	;STACK THE MAPPING FOR THAT CALL
	MOV	JERRLG,-(SP)	;STACK THE ERROR LOG ROUTINE'S ADDRESS
	MOV	DSKAP5,-(SP)	;STACK THE DISK'S PHASE MAPPING
	BR	CALLMX		;  AND PERFORM ERROR LOGGING		;JHC023

.DSABL LSB

GLOBAL	<BACKUP>

.SBTTL	HANDLE MAPPED CALLS

.ENABL LSB

;+
; CALLMI - Call mapped indirect.
;
;	Set up stack for CALLMX through a dispatch table.
;
;	CALLMI 	INDIRECT-SUBR,XXXAP5
;
;	in INIT we don't bother with all of the I & D space stuff.
;-

CALLMI::PUSH	@#KISAR5	; save current apr5 value		;JHC023
	PUSH 	@(R5)+		; stack the subroutine's address	;JHC023
	BR	10$		; and merge with CALLM			;JHC023

;+
; CALLM - CALL MAPPED (DIRECT)
;
;	CALLM SUBR,XXXAP5
;
;	Set up stack for CALLMX
;
;	You should not need to alter anything for other CALLM's.  I use the
;	RT11 autoload vector, and offset to the virtual address.
;
;	DANGER!!! If the RT11 linker ever changes the autoload vector set-up
;		then strange things will happen here.  I can't think of any
;		way to watch for this during assembly.  Keep yo' eyes peeled.
;
;	Also note, all registers are preserved through the call.  We do not
;	even sacrifice the contents of R5 (note neat little hacks).
;								JHC
;
;	FURTHER NOTE: This code references the symbol "INIT" which is	;092
;	arranged to be the first thing linked (from INIT.MAC). Make	;092
;	sure it stays that way.						;092
;-

CALLM::	PUSH	@#KISAR5	; Save current apr5			;023
	PUSH	(R5)+		; get the autoload vector or subr addr	;071
	CMP	(SP),#INIT	;Autoload vector?			;092
	BHIS	10$		;Nope, normal address in INIT		;092
	ADD	#6,(SP)		; and offset to the subroutine address	;023
	MOV	@(SP)+,-(SP)	; and get the address. FM		;023
10$:	PUSH	@(R5)+		; finally, stack the new APR value	;023
20$:	MOV	6(SP),-(SP)	; get actual R5 value (from JSR 'R5')	;023
	MOV	R5,10(SP)	; Replace with final return address	;087
				;  (for RTS PC)				;087
	MOV	(SP)+,R5	; so we actually pass R5 untouched (more FM)
	.BR	CALLMX		; annd branch into common routine	;023

GLOBAL	<INIT>								;092

;+
; CALLMX - CALL MAPPED (NON-STANDARD)
;	
;	SP-> NEW PAR5 VALUE, SUBR, OLD PAR5 VALUE, RETURN ADDRESS ....
;
;	JMP 	CALLMX
;	
;	SP-> ....
;-

;+
; RTI3PH - RETURN FROM L3 SIMULATION
;	THIS GLOBAL IS USED AS THE ENTRY FOR THE COMPLETION OF ALL LEVEL 3
; 	SIMULATION PROCESSES THAT TAKE PLACE OUTSIDE OF THE DISK PHASE.
;	INIT DISPATCHES TO THE PROCESS BY PERFORMING A JMPX	CALLMX. 
;	RETURN BY THAT PROCESS IS USUALLY DONE BY A MOV	#RTI3PH,-(SP)
;-

CALLMX::MOV	(SP)+,@#KISAR5	;MAP INTO THE REQUESTED SUBROUTINE
	CALL	@(SP)+		;CALL THE REQUESTED SUBROUTINE
	MOV	(SP)+,@#KISAR5	;RESTORE THE CALLER'S MAPPING
RTI3PH::RETURN			; AND RETURN TO CALLER (we doctored JSR R5
				; so that this would go cleanly)
;+
; CALLMR - CALL MAPPED AND RETURN (DIRECT)
;
;	CALLM SUBR,XXXAP5
;-
CALLMR::PUSH	@#KISAR5	; Save current apr5			;053
	PUSH	(R5)+		; get the autoload vector		;053
	ADD	#6,(SP)		; and offset to the subroutine address	;053
	MOV	@(SP),(SP)	; and get the address. FM		;053
	PUSH	@(R5)+		; finally, stack the new APR value	;053
	MOV	#RTI3PH,R5	;-Set up a dummy return			;053
	BR	20$		;-   and do the FM			;053

.DSABL	LSB


.SBTTL	CALMCP and MCPJMP - Speedy mapped BBR -> MCP phase calls

;+									;087
; CALMCP - Speedier-than-normal mapped call into MCP phase.		;087
;									;087
;	CALMCP	addr							;087
;									;087
; C-bit is passed unaffected from callee to caller.			;087
;									;087
; This routine performs the same function as the one in DSASUB that's	;087
; used by the monitor.  It's more complicated than the one in DSASUB	;087
; because it has to contend with autoload vectors.  However, it doesn't	;087
; have to deal with D-space APRs.					;087
;-									;087

CALMCP::MOV	2(SP),-(SP)		; Make a copy of the address	;087
					;  we're going to (really an	;087
					;  autoload vector).		;087
	ADD	#6,(SP)			; Point to the real address...	;087
	MOV	@(SP)+,-(SP)		;  and get it.			;087
	MAP	MCPAP5,APR=5,CODE	; Set mapping for MCP phase...	;087
	CALL	@(SP)+			; And, we're off!!		;087
	MAP	BBRAP5,APR=5,CODE	; When we get back here, restore;087
					;  the old mapping values.	;087
	MOV	(SP)+,(SP)		; Clean up the stack;		;087
					;  Get rid of address we called,;087
					;  and put return address on top;087
	RETURN				; And, go back to caller.	;087

;+									;087
; MCPJMP - Jump mapped into MCP phase					;087
;									;087
; Format:	MCPJMP	addr						;087
;									;087
;-									;087

MCPJMP::ADD	#6,(SP)			; Point to the real address...	;087
	MOV	@(SP)+,-(SP)		;  and get it.			;087
	MAP	MCPAP5,APR=5,CODE	; Set mapping for MCP phase...	;087
	JMP	@(SP)+			; And, we're off!!		;087


.SBTTL	Magtape I/O Routines

MXRSET::CALLX	GETTTY		;GET THE CLOCK UP TO DATE
	CMP	SYSNDX,#IDX$..	;Using boot driver?
	BEQ	2$		;Yes, so it's a no-op
	CALL	KPARDK		;TURN ON DISK PHASE MAPPING
	CALL	@JTRSET		;DO THE RESET
	CALL	@(SP)+		;Restore mapping			;092

2$:	RETURN			;Leave

MAGIO::	CALLX	GETTTY		;GET THE CLOCK UP TO DATE
	CMP	SYSNDX,#IDX$..	;Using bootstrap?
	BNE	5$		;No
	JMP	BTTAPE		;Yes, use bootstrap tape driver

5$:	MOV	(R5)+,20$	;SAVE FIRST PARAMETER
	MOV	(R5)+,30$	;SAVE SECOND PARAMETER
	TSTB	BACKUP		;IS THIS A SAV/RES?
	BEQ	10$		;NOPE, DO NOTHING STUPID
	TSTB	HIGHBF		;DO WE WANT I/O TO HIGH MEMORY
	BEQ	10$		;NO, THEN DO NO ICKY OFFSETTING
	ADD	IOBF1$,30$	;SAV/RES PASSES OFFSET INTO IOBUF	;025
10$:	CALL	KPARDK		;TURN ON DISK PHASE MAPPING
	CALL	@JMAGIO,R5	;DO THE MAGTAPE I/O
20$:	.WORD	0		;MAGTAPE FUNCTION
30$:	.WORD	0		;LOW WORD BUFFER ADDRESS
	BR	SVCRY		;SAVE CARRY; RETURN ON R5

MAGSPC::CALLX	GETTTY		;GET THE CLOCK UP TO DATE
	CMP	SYSNDX,#IDX$..	;Using bootstrap drivers still?
	BNE	5$		;No
	JMP	BTSPEC		;Yes, so do it that way

5$:	MOV	(R5)+,10$	;SAVE FIRST PARAMETER
	CMP	R0,#IDX$MS	;IS THE MAGTAPE A TS11?			;015
	BNE	7$		;NO,SO DON'T WORRY			;015
	CMP	#1,10$		;YES, IS FUNCTION REWIND-OFFLINE?	;015
	BNE	7$		;NO, IT'S OKAY AS IS			;015
	MOV	#3,10$		;IT IS REW-OFF, CHANGE TO REWIND FOR TS11 ;015
7$:	CALL	KPARDK		;TURN ON DISK PHASE MAPPING		;015
	CALL	@JMGSPC,R5	;DO MAGTAPE SPECIAL FUNCTION CALL
10$:	.WORD	0		;SPECIAL FUNCTION
SVCRY:	CALL	@(SP)+		;restore mapping			;092
	RETURN	R5		;RETURN THROUGH R5

;048+ Misc. stuff	
FNDJOB::MOVB	HIGHBF,R2	;GET HIGH ADDRESS
	MOV	R5,R3
	ADD	#2,(SP)		;RETURN SUCCESS
	;CLC
	RETURN			;DIDN'T SET UP KISAR6 / R5 TO POINT TO BUFFER

; INDICATE THAT DRIVER IS FINISHED

IOFIN4::TST	(R5)+		;SKIP JS FLAGS TO SET
	MOV	(PC),IODNE	;MARK THAT I/O IS DONE
	RETURN	R5		;AND EXIT

IODNE::	.WORD	0		;I/O COMPLETED FLAG

CHKASY::			;All I/O in INIT is synchronous		;064
UNLOCK::CLC
	RETURN

;048-
SAVJOB::RETURN	R5							;054

.SBTTL	Globals for the drivers

TMPORG	ROOCTL

	$DISKS
CSR.'NAME::
.ENDM
	$TAPES
CSR.'NAME::
.ENDM
CSR.XX::	.BLKW0	8.		; CSR save area tape & disk drivers

;054+
	$TAPES
DEV.'NAME::
.ENDM
	.BLKW0	8.,MAGDDB	;ALL UNITS SHARE ONE DDB IN INIT
;054-

DLDPOS::.BLKW0	4		; RL11 current position buckets

DQS$XX::$DISKS			; Disk queue start
.IF	DIF	<NAME>,<DR>
DQS$'NAME::
.ENDC
.ENDM

	.WORD	0		; An easy and common queue

	$DISKS			; Disk queue ends
.IF	DIF	<NAME>,<DR>
DQE$'NAME::
.ENDC
.ENDM

	$DISKS			; Optimization list
.IF	DIF	<NAME>,<DR>
OPT$'NAME::
.ENDC
.ENDM

	.WORD	0		; Common OPT lists

	$TAPES
TIM.'NAME::
.ENDM

TIM.MX::.WORD	0		; Timeout flag

	$DISKS			; Status list
.IF	DIF	<NAME>,<DR>
DSS$'NAME::
.ENDC
.ENDM

TIM.XX::.WORD	0		; Common status/time out word

	$DISKS			; End of status list
.IF	DIF	<NAME>,<DR>
DSE$'NAME::
.ENDC
.ENDM

OPO$XX	==	OPT$DF-DQS$DF	; Offset from queue to optimization
DSO$XX	==	DSS$DF-DQS$DF	; Offset from queue to status
MID$XX::.WORD	0		; Massbus ID
UNTCNT::.WORD	0		; Unit status
MAGLBL::.WORD	0		; System labeling default
TAPDEN::.WORD	0		; System density default		;052
MAGDDB::.BLKW0	132		; Magtape DDB
INIDNE::.WORD	0		;DSQL3Q dummy L3Q root & L3 bits to set	;050
	.WORD	0		;   (required for MSCP driver)		;050


.SBTTL	Globals for APR's, "phase" dispatches

DSKAP5::.WORD	DSK$P1		; Disk phase APR5 MMU value
DSKAP6::.WORD	DSK$P2		; Disk phase APR6 MMU value		;025
MCPAP5::.WORD	MCP$P1		; UDA/MSCP phase APR5 MMU value
MCPAP6::.WORD	MCP$P2		; UDA/MSCP phase APR6 value		;025
BBRAP5::.WORD	BBR$P1		; BBR phase APR5 MMU value		;022
MSCAP5::.WORD	MSC$P1		; MSC phase APR5 MMU value		;102
MSCAP6::.WORD	MSC$P2		; MSC phase APR6 MMU value		;102
IOBF15::.WORD	IOBUF1		; IOBUF1 APR5 MMU value			;025

IOBF1$::.WORD	<IOBUF1&1777>*100	; IOBUF1 offset for SAV/RES	;025
ENDIN$::.WORD	ENDINI/<4000/100>	; End of INIT's "map" in K	;026

;+
;	BBRDSP, and $BBREP are used to dispatch from MSCPPH into the
;	BBR phase.  $BBREP is initialized at link time with the entry
;	point for the BBR code and dispatches into it are made with
;	CALLMI $BBREP,BBRAP5
;-

	TMPORG	BBRDSP						;023

$BBREP::.WORD	0
$RSMBR::.WORD	0
$MUSRV::.WORD	0			; TMSCP request processing.	;087
$MURSP::.WORD	0			; TMSCP response processing.	;087
$QUMTD::.WORD	0			; Queue a TSQ to TMSCP.		;087
$LOGMU::.WORD	0			; Log a TMSCP error.		;087

	TMPORG	ROOCTL
; The following are not used or are irrelevant, but are referenced by drivers

	$TAPES
DDS.'NAME	== 0
.ENDM

	$TAPES
JS.'NAME	== 0
.ENDM

QDS$DV::
INT$DV::
TMO$DV::
ERLDSK::
ERLDVR::
INTSVX::
INTSAV::
CMNDSK::
FIPSYS::
GETBIG::
UNIDSK::
RHDDSK::
IOREDO::
UNLOC0::	;038
	BPT			; Stop (enter ODT) if called

IE	==	0		; Interrupt enable is always off

	UNORG

.SBTTL	COROUTINE TO LOOP THROUGH ALL HARDWARE DEVICES

;+
; DEVLUP - LOOP THROUGH ALL POSSIBLE DEVICES IN DEVTBL
;
; THIS COROOUTINE IS USED AS FOLLOWS:
;
;		CALL	DEVLUP
;	XX$:	R4 -> CSRTBL AT DEVICE CSR
;		R5 -> DEVTBL AT PACKET FOR THIS DEVICE
;		PROCESS DEVICE (IF (R4)=0, NOTHING FOUND!)
;		CALL	@(SP)+	;COROUTINE CALL TO GET NEXT DEVICE
;		BNE	XX$	;LOOP IF MORE
;		[DONE WITH ALL DEVICES]
;
;	IF A BRANCH OUT OF THE LOOP IS DONE, A WORD FOR THE COROUTINE
;	MUST BE POPPED FROM THE STACK
;	NORMAL ENDING LEAVES THE STACK CLEAN
;-

DEVLUP::MOV	#DEVTBL,R5	;INITIALIZE TO POINT TO FIRST PACKET
	MOV	#CSRTBL,R4	;AND FIRST CSR
10$:	CLR	DEV.UN		;CLEAR OUT THE CURRENT UNIT NUMBER
20$:	CLZ			;LET HIM KNOW
	CALL	@(SP)+		;COROUTINE CALL
	TST	(R4)+		;TO THE NEXT CSR
	INC	DEV.UN		;TO THE NEXT UNIT
	CMPB	DEV.UN,(R5)	;IF THERE ARE MORE OF THIS TYPE
.ASSUME	PK.MXU EQ 0
	BLO	20$		;JUST CALL HIM
	ADD	#PKTSIZ,R5	;ELSE GO TO NEXT PACKET
	TST	(R5)		;AND IF THERE ARE ANY MORE
	BNE	10$		;THEN CALL HIM
	RETURN			;ELSE RETURN TO HIM (CLEAN STACK)

.SBTTL	SET UP INTERCEPT FOR TRAPS TO 4

;+
; TRASEC - SET UP TO INTERCEPT TRAPS TO 4
;
;	CALL	TRASEC		;SET UP INTERCEPT
;	(CODE WHICH MIGHT TRAP)
;	(IF IT DOES, CARRY WILL BE SET.  PRECLEAR CARRY OR ENSURE THAT
;		THE CODE, IF SUCCESSFUL, CLEARS THE CARRY)
;	CALL	@(SP)+		;TO RESTORE THE STANDARD VECTOR @ 4
;	(CARRY LEFT SET IF TRAP OCCURRED)
;-

TRASEC::MOV	#TRAPPR,@#4	;SET UP THE VECTOR
	CALL	@(SP)+		;CALL THE GUY BACK
	MOV	#TRAP.4,@#4	;RESTORE THE VECTOR @ 4
	RETURN

TRAPPR::BIS	#1,2(SP)	;ON TRAPPING, SET CARRY
	RTI			;AND RETURN

.SBTTL	TYPE A HARDWARE DEVICE NAME

;+
; TYPDEV - TYPE A DEVICE NAME WITH LEADING MESSAGE
; TYPDVN - TYPE A DEVICE NAME
;
;	R5 -> DEVICE PACKET
;	R4 -> CSRTBL AT DEVICE CSR
;
;	CALL	TYPD??
;
;	IF TYPDEV,	"DEVICE XXN:" PRINTED
;	IF TYPDVN,	"XXN:" PRINTED
;	NO NUMBER PRINTED IF ONLY ONE UNIT IS ALLOWED
;-

TYPDEV::MESSAG	<"Device ">	;PART OF MESSAGE
TYPDVN::MOV	R2,-(SP)	;SAVE R2
	MOV	PK.NAM(R5),R2	;GET DEVICE IDENTIFIER
	CALLX	TYPE2		;TYPE IT
	CMP	(R5),#1		;IS MORE THAN 1 UNIT POSSIBLE?
	BLOS	10$		;NO, NO UNIT
	MOV	R0,-(SP)	;YES, SAVE R0
	MOV	R4,R0		;COPY POINTER TO CSRTBL
	SUB	#CSRTBL,R0	;GET OFFSET INTO TABLE
	SUB	PK.CSO(R5),R0	;GET OFFSET INTO THIS UNIT'S SET
	ASR	R0		;NOT TIMES 2
	CALLX	DECZER		;TYPE IT
	MOV	(SP)+,R0	;RESTORE R0
10$:	TYPE	<':>		;TYPE THE MANDATORY COLON
	MOV	(SP)+,R2	;RESTORE R2
	RETURN

.SBTTL	FIND UNIQUE/CORRECT TEXT STRING

;+
; GETUNQ - FIND UNIQUE STRING FROM TABLE OF UNIQUE/CORRECT TEXT
;
;	R1 -> TEXT
;
;	CALL	GETUNQ,R5,<PTR TO UNQTXT TO MATCH>
;
;	C=0	MATCH FOUND
;		R1 UNCHANGED, BUT TEXT PAST BLANKS MOVED DOWN
;		R0 = INDEX * 2 OF MATCHING TEXT
;
;	C=1	NO MATCH
;		R0 = (HIGHEST INDEX + 1) * 2
;-

GETUNQ::MOV	(R5)+,R0	;GET MATCH TEXT POINTER IN R0
	REGSAV			;SAVE REGISTERS
	MOV	R1,R4		;COPY POINTER TO PASSED TEXT
	CLR	(SP)		;CLEAR RETURNED R0
10$:	MOV	R4,R1		;RESTORE POINTER TO PASSED TEXT
20$:	MOVB	(R0)+,R3	;GET MATCH TEXT CHARACTER
	BIC	#^C<177>,R3	;ISOLATE IT
	CMPB	R3,(R1)+	;COMPARE AGAINST PASSED TEXT
	BEQ	20$		;GOT IT?
	TSTB	-(R0)		;NO MATCH. IS MATCH TEXT CHARACTER OPTIONAL?
	BMI	50$		;YES, WE PROBABLY FOUND IT
30$:	CMPB	(R0)+,#377	;NO, SKIP TO END OF THIS MATCH STRING
	BNE	30$
	ADD	#2,(SP)		;NEXT INDEX
	TSTB	(R0)		;ANY MORE MATCH TEXT?
	BNE	10$		;YES, TRY AGAIN
	SEC			;NO, INDICATE FAILURE IN CARRY
40$:	CALLX	REGRES,R5	;RESTORE REGISTERS
	RETURN	R5		;BACK

50$:	TSTB	-(R1)		;FOUND DISCREPANCY AT OPTIONAL CHARACTER
	BEQ	70$		;THAT WAS THE END OF THE PASSED STRING
	CMPB	(R1),#57	;WAS IT A "/" THAT STARTS A SWITCH
	BEQ	70$		;YES IT WAS, LETS MOVE THE SWITCH DOWN
	CMPB	(R1),#72	;WAS IT A ":" WHICH IS ALSO A GOOD ENDING
	BEQ	70$		;YES IT WAS, LETS MOVE THE SWITCH DOWN
	CMPB	(R1),#'=	;WAS IT A "=" WHICH IS ALSO A GOOD ENDING
	BEQ	70$		;YES IT WAS, LETS MOVE THE SWITCH DOWN
	CMPB	(R1),#40	;IT WASN'T THE END, SO GOTTA BE A BLANK
	BNE	30$		;NO LUCK, NOT THIS MATCH TEXT

60$:	CMPB	(R1)+,(R1)	;SCAN PAST N BLANKS
	BEQ	60$		;UNTIL R1 -> NOT A BLANK
70$:	MOVB	(R1)+,(R4)+	;MOVE THE REST OF THE STRING DOWN
	BNE	70$		;UNTIL END OF ASCIZ
	CLC			;C=0 FOR SUCCESS
	BR	40$		;GO BACK TO THE CALLER

.SBTTL	GET CSR ASSIGNMENT FOR DISKS WITH MULTIPLE CONTROLLERS

;+
; GETCSR - GET CSR ASSIGNMENT FOR DISKS WITH MULTIPLE CONTROLLERS
;
;	R4 =  unit NUMBER		The DSKCSR table is in 
;	R5 =  DISK INDEX		Disk index sequence. The
;					entry for each disk type is
;	CALL	GETCSR			either the CSR for that disk
;					or an address of another table
;	R3 =  CSR ASSIGNMENT		of CSRs if the disk can have
;	R4 =  unit NUMBER		multiple controllers.
;	R5 =  DISK INDEX		
;
;-

.DSABL	LSB

GETCSR::MOV	DSKCSR(R5),R3		;GET ADDRESS OF CSRS FOR THIS DISK
	BIT	#1,R3			;IS IT A MULTI-CNTRLR DISK?
	BEQ	10$			; NO, THEN WE HAVE THE CSR IN R3
	MOV	R4,R3			;Copy the unit number
	ASH	#2,R3			; * 4				;055
.ASSUME	UMTSIZ	EQ	4
	ADD	#UMT$DU,R3		; + The UMT table address	;055
	TST	UM.UCB(R3)		;Does this unit even exist?	;082
	BNE	5$			;Sure does, go ahead		;082
	CLR	R3			;No disk, no CSR		;082
	BR	10$			;...and get out			;082

5$:	MOV	(R3),R3			; = The unit's CMT offset	;055
.ASSUME	UM.CMT EQ 0
	MOV	CMT+CM.CSR(R3),R3	;Now get the CSR for this unit	;055
10$:	RETURN				;RETURN

.DSABL	LSB


.SBTTL	GET/RELEASE UMR'S

;+
; GETUMR - ALLOCATE UMR'S FOR ADDRESSING AN NPR TRANSFER
;
;	R4 -> DSQ
;	CALL	@GETUMR
;
;-

;+
; RELUMR - RELEASE WINDOWS ALLOCATED TO THIS DSQ
;
;	R4 -> DSQ
;
;	CALL	@RELUMR
;-

GETUMR::
RELUMR::.WORD	CLCRTS		;;Never anything to do

.SBTTL	QUEUE MANAGEMENT

;+
; QUEUER - QUEUE AN ITEM INTO A QUEUE (FIFO).
;
;	R4 -> ITEM TO QUEUE
;
;	CALL QUEUER,R5,<QUEUE ROOT>
;
; BACK
;	IF C=0 THEN ITEM IS NOT FIRST IN QUEUE
;	IF C=1 THEN ITEM IS FIRST (AND ONLY) ITEM IN QUEUE
;-

.ENABL	LSB

QUEUER::MOV	R0,-(SP)	;GET A WORKING REGISTER
	MOV	(R5)+,R0	; TO GET A POINTER TO THE QUEUE ROOT
10$:	CLR	(R4)		;ENSURE A 0 LINK IN THIS ITEM
	TST	(R0)		;SET Z-BIT=1 IF QUEUE NOW EMPTY
	SEC			;PRE-INDICATE FIRST IN QUEUE (C=1)
	BEQ	30$		;QUEUE NOW EMPTY, ENTER IN QUEUE AND C=1
20$:	MOV	(R0),R0		;ELSE GET NEXT IN THE QUEUE LIST
	TST	(R0)		;THE END YET? ( AND C=0 )
	BNE	20$		;NOT THE END, CONTINUE LOOKING
30$:	MOV	R4,(R0)		;PUT NEW ITEM IN TO THE QUEUE
	MOV	(SP)+,R0	;RESTORE WORKING REGISTER
	RETURN	R5		; AND EXIT (C=1 OR C=0)

;+
; QUEUE0 - QUEUE AN ITEM INTO A VARIABLE QUEUE (FIFO)
;
;	R0 -> QUEUE ROOT
;	R1 -> ITEM TO QUEUE
;
;	CALL 	QUEUE0,R5
;
;	IF C=0 THEN ITEM IS NOT FIRST IN QUEUE
;	IF C=1 THEN ITEM IS FIRST (AND ONLY) ITEM IN QUEUE
;-

QUEUE0::MOV	R0,-(SP)	;SAVE THE QUEUE ROOT
	BR	10$		;NOW JOIN COMMON CODE

.DSABL	LSB



.SBTTL	QUEUE AND SET LEVEL 3 QUEUE BIT(S)

;+
; QUEL3Q - QUEUE AND SET LEVEL 3 QUEUE BIT(S).
;
;	R4 -> LINK, XXX, ->ROOT/BITS
;
;	CALL	QUEL3Q
;-

QUEL3Q::MOV	R0,-(SP)	;GET TWO
	MOV	R1,-(SP)	; WORKING REGISTERS
	MOV	DSQL3Q(R4),R1	;GET POINTER TO ROOT/BITS
.ASSUME	DSQL3Q	EQ	4
	MOV	(R1)+,R0	;NOW GET THE QUEUE ROOT
	BEQ	10$		;NO ROOT, JUST GO SET THE BIT(S)
	CALL	QUEUE0,R5	;ROOT EXISTS, QUEUE INTO IT
	BCC	20$		;NOT FIRST IN QUEUE, SKIP L3Q BIT SET
10$:	MOV	(R1),R0		;GET THE L3Q BIT(S) TO SET
	CALL	L3QSE0,R5	; AND GO SET THEM
20$:	MOV	(SP)+,R1	;RESTORE THE
	MOV	(SP)+,R0	; WORKING REGISTERS
	RETURN			;NOW EXIT



.ENABL	LSB

;+									;029
; L3QSE0 - SET L3Q BIT SPECIFIED 					;029
;									;029
;	R0 = BYTE OFFSET IN HIGH BYTE					;029
;	     BIT IN LOW BYTE						;029
;									;029
;	CALL	L3QSE0,R5						;029
;-									;029
									;029
L3QSE0::MOV	R1,-(SP)	;Save R1				;029
	MOV	R0,R1		;Extract offset				;029
	CLRB	R1		;					;029
	SWAB	R1		;					;029
	BISB	R0,L3QUE(R1)	;Set the bits				;029
	MOV	(SP)+,R1	;Restore R1				;029
	RETURN	R5							;029

.DSABL	LSB

GLOBAL	<L3QUE>

;054+
;
;	DMPJOB and RTI3 entry points.
;
;	Moved here from INIDSK to stop auto-load vectors.
;-

RTI3::	JMP	@JRTI3		;Now go to INIT's RTI3 in INIDSK
DMPJOB:: RETURN			;DMPJOB just return			;057

;054-


;+071

.SBTTL   BLDTSQ - BUILD A TSQ
;+
;
; BLDTSQ
;   R1 -> DDB @MTQPTR
;   R3 -> XRB
;   R4 =  JOB # * 2
;
;	CALL BLDTSQ
;
;   R3 -> XRB
;   R4 -> TSQ (initialized)
;
;   IF NO SMALL BUFFER IS AVAILABLE; EXIT WITH CARRY SET, R4 NOT CHANGED.
;
; NOTE:	IN THE CASE OF AN ERROR CHECK STATE, THE OPEN BIT WILL SHOW AS A
;	MTU REQUEST BECAUSE IT IS SENDING IN REQUESTS, BUT AN ASYNCHRONOUS
;	USER CAN STILL ISSUE REQUESTS.  SINCE MTU ALWAYS PROVIDES THE TSQ,
;	ANYTIME THIS ROUTINE IS CALLED IS FOR A USER REQUEST, THEREFORE WE
;	CAN ENSURE THAT THE OPEN BIT IS SET PROPERLY SO THE REQUEST CAN BE
;	ANSWERED CORRECTLY
;-

BLDTSQ::PUSH	R4		; SAVE R4			
	BUFFER	GETSML,,15	; GET A SMALL BUFFER (CLEARED)	
	BVS	20$		; NO BUFFERS, UGH, DIE OR WAIT	
	CLRB	TSQSTS(R4)	; WE GOT ONE, CLEAR THE STATUS  
	BIT	#1,XRBCRA(R3)	; IS THIS AN ASYNCH REQUEST?
	BEQ	10$		; NO				
	BISB	#TS$ASY,TSQSTS(R4) ; YES, SO REMEMBER THAT	
10$:	MOV	R3,TSQASY(R4)	; SET UP THE ASYWRK POINTER	
	ASR	R0		; GET UNIT # TIMES 1		
	MOVB	R0,TSQPUN(R4)	; AND SAVE IT			
	ASL	R0		; RESTORE UNIT #*2		
	MOVB	MTOFLG(R1),TSQMTO(R4) ; REMEMBER OPEN STATUS WHEN ISSUED 
;	BITB	#MT.ECK,MTFLAG(R1) ;ARE WE IN AN ERROR CHECK STATE?
;	BEQ	15$		; NOPE, NO WORRY	
;*** REMEMBER USER/MTU DIFFERENTIATION	
	BISB	#MT.OPN,TSQMTO(R4) ; YES, SO REMEMBER THIS IS A USER REQ 
15$:	MOVB	#MTRTCT,TSQRTY(R4) ;AND SET THE RETRY COUNT	
	MOVB	(SP)+,TSQJOB(R4) ; GET RID OF OLD R4, STORING JOB # * 2
	;CLC			; CLEAR THE CARRY (DONE BY THE ASL)
	RETURN			; AND QUIT HAPPY		

20$:	POP	R4		; RESTORE JBNO *2 TO R4		
	SEC			; OH-OH, NOT HAPPY		
	RETURN			; GET OUT OF HERE		

;-071

;+
;	QNAROM - Execute the QNA ROM self-test code
;
;	Called from INIONE.  Maps ROM code instead of INIONE, verifies
;	the checksum of the ROM code and the ROM version, saves the
;	contents of SATBUF, then calls the mapped code.  Restores
;	mapping and returns to INIONE.
;
;	Returns with carry set and R0 = failure code if diagnostics failed.
;
;	Otherwise R0 contains result:
;
;		R0 = 0		No error
;		R0 > 0		Old ROM, but diagnostics passed
;		R0 < 0		Checksum failure, diagnostics not run
;-

QNAROM::CLR	R0			;Assume diagnostics will pass	;086
	REGSCR				;Save the world			;074
	MOV	#BBR$P2,@#KISAR5	;Map the BD ROM code via APR5	;099
	MOV	#1,@#MMUSR0		;Turn on mapping		;074
	MOV	#7776,R4		;Number of bytes to add up	;074
	CLR	R3			;Place to compute the checksum	;074
	CLR	R2			;Pointer to BD ROM bytes	;074
10$:	CLR	R5			;Get ready for a byte move	;074
	BISB	120000(R2),R5		;Fetch a byte of the ROM	;074
	INC	R2			;Count it			;074
	ADD	R5,R3			;Add it to our checksum		;074
	CMP	R2,@#120006		;Now pointing at checksum?	;074
	BNE	20$			;No, so no worries		;074
	TST	(R2)+			;Yes, don't include checksum	;074
20$:	SOB	R4,10$			;Loop until all bytes added	;074
	MOV	@#120006,R5		;Get offset to checksum		;074
	CMP	120000(R5),R3		;Checksums match?		;074
	BEQ	30$			;Yes.  Check for old ROM	;086
	DEC	TOS.R0(SP)		;Signal checksum failure	;086
	CALL	KPARSU			;Restore null mapping		;086
	CLC				;Signal diagnostic not run	;086
	RETURN				;Now exit			;086

30$:	MOV	TOS.R2(SP),R2		;Get pointer to device type	;099
	CMP	#^RLQA,(R2)		;Is this an LQA?		;099
	BNE	35$			;No, go do QNA testing		;099
33$:	CALL	SAVSAT			;Save SATBUF into SATBF2	;099
	MOV	#BBR$P2,@#KISAR5	;Map the BD ROM code via APR5	;099
	MOV	#QNA$P2,@#KISAR6	;Map the BD ROM code via APR6	;099
	MOV	#1,@#MMUSR0		;Turn on mapping		;099
	MOV	#SATBUF,R2		;Point to work space for BD ROM	;099
	CALL	@#120004		;Call the citizenship test	;099
					; mapped in BBR$P2 via APR5	;099
	BR	45$			;Join common completion		;099

35$:	CMP	@#120462,#12700		;Old ROM was MOV #q.pri,r0	;099
	BNE	33$			;Not it				;099
	CMP	@#120464,#340		;q.pri was PR7, reg set 0	;086
	BNE	33$			;New code, return diagnostic	;099
	INC	TOS.R0(SP)		;Change code to old ROM		;086
40$:	CALL	SAVSAT			;Save SATBUF into SATBF2	;086
	MOV	#QNA$P1,@#KISAR5	;Map the BD ROM code via APR5	;086
	MOV	#QNA$P2,@#KISAR6	;Map the BD ROM code via APR6	;086
	MOV	#1,@#MMUSR0		;Turn on mapping		;074
	MOV	#SATBUF,R2		;Point to work space for BD ROM	;074
	CALL	@JXHROM			;Call the citizenship test	;086
45$:	SPLC	7			;Ensure PR7 			;099
	CALL	RESSAT			;Restore SATBUF and null mapping;074
	CALL	I.CORE			;Clean up low core		;081
	TST	R0			;Did diagnostics pass?		;086
	BEQ	100$			;Yes, return with C=0, R0=0,	;086
					; or C=0, R0=1 for old ROM	;086
	MOV	R0,TOS.R0(SP)		;Save the failure code		;086
	SEC				;Signal diagnostics failed	;086
100$:	RETURN				;Now back to caller		;086

.SBTTL	Bootstrap checking/deflowering routines				;102

;+
; VBCHK is used to see if this is a first-time boot.			;102
; FSZBOT is used to cause a reboot with full autosize (if wanted).	;102
;									;102
; Normally, when a disk or tape is first booted, the boot is considered	;102
; to be a "first-time" boot, and INIT does not act the same as for a	;102
; normal boot.  A bootstrap can be made non-first-time in two ways.	;102
; One way is by using either the INSTAL or HARDWR option, explicitly or	;102
; implicitly.  This causes a permanent change to the bootstrap on the	;102
; disk, and any subsequent boots will be non-first-time.  The other way	;102
; is by passing the BF.FSZ flag in the boot flags during a boot		;102
; operation.  This is temporary and will mark the boot as non-first-time;102
; only for the duration of this boot.					;102
;-									;102

;+
;	VBCHK - See if this is a first-time boot.			;102
;									;102
; No setup is necessary.						;102
;									;102
;	CALL	VBCHK							;102
;									;102
; Returns:	C=0	This is not a first-time boot.			;102
;		C=1	This IS a first-time boot.			;102
;									;102
; All registers are preserved.						;102
;-									;102

VBCHK::	CMP	@#B.JMP,#137		;Is it a first-time boot?	;102
	;CLC				;From CMP above.		;102
	BNE	10$			;No, so go back with C clear.	;102
	SEC				;Otherwise, set C.		;102
10$:	RETURN				;And go back.			;102

GLOBAL	<B.JMP>								;102

.DSABL	LSB								;102

.ENABL	LSB								;102
;+									;102
;	FSZBOT (pronounced "Fizz-Bot") - See if user wants to reboot	;102
;		with full autosize.					;102
;									;102
; No setup is necessary.						;102
;									;102
;	CALL	FSZBOT							;102
;									;102
; If the answer is NO, then we will return.				;102
; If the answer is YES, then we will reboot (not come back at all!).	;102
;									;102
; No data is passed or returned.					;102
; All registers preserved.						;102
;-									;102

FSZBOT::CALLX	ASKER,R5	;Ask the question...			;102
	 .WORD	20$		;Point to the short-form text.		;102
	GENTXT			;And, also define the long-form text.	;102
	 .ASCII	<200>							;102+
	 .ASCII	"Enter YES (or press Return) to cause a reboot with full hardware scan."<200>
	 .ASCII "Enter NO to try another device."<200>
20$:	 .ASCIZ	<200>"Do you want to perform a reboot with full hardware scan <YES>? "
	UNORG								;102-
	CALLX	ANSWER,R5	;Now check out the answers.		;102
	 BR	30$		;YES - Go reboot!			;102
	 RETURN			;NO - Just go back.			;102
	 BR	30$		;<LF> - Same as YES.			;102
	 NOP			;OLD - Nonsense, so just fall through.	;102
	 MESSAG	<"Please answer YES or NO, or enter '?' for help."<200><12>>
				;Other - give 'em a little help		;102
	 BR	FSZBOT		; and go ask question again.		;102

30$:	BISB	#BF.FSZ,BOFLGS	;Set flag saying to do full autosize.	;102
	JMPX	BOOTSF		;Reboot system device, saving flags.	;102

	TMPORG	ROOCTL							;102
BOFLGS::.BYTE	0		;This is where boot flags are held.	;102
	.EVEN								;102
	UNORG								;102

.DSABL	LSB								;102

.ENABL	LSB								;102
;+									;102
;	JMPTO0 - Start just-loaded bootstrap				;102
;									;102
; This routine was moved here from INIBOO when INIBOO was moved into	;102
; a memory-resident overlay.  It was also modified to turn off memory	;102
; management before starting the new bootstrap.				;102
;									;102
; No setup is necessary.						;102
;									;102
;	JMP	JMPTO0							;102
;-									;102

JMPTO0::CLR	@#MMUSR0	;Turn off memory management.		;102
	CLR	@LKSCSR		;Turn off L-clock if running.		;102
	MOVB	BOFLGS,@#B.FLGS-B.BOOT					;102
				;Pass boot flags (if any).		;102
	TST	FLGGPK		;GPK boot?				;102
	BEQ	10$		;No, so do standard thing.		;102
	JMP	@#2		;Otherwise, enter GPK boot		;102
				; (skip GPK HALT).			;102
10$:	CLR	PC		;Non-GPK boot, so jump to 0.		;102

	.END	INITGO
