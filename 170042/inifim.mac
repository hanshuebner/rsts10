	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
	.INCLUDE /INIT:INIPFX/
TITLE	INIFIM,<RSTS/E INIT - MAPPED MINI FIP>,0A,10-MAY-91,GPK/VAM/WRM

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;


.SBTTL	EDIT HISTORY FOR INIFIM

;+
;
;  000	GPK  25-Sep-86	Created by splitting from INIFIP
;  001  PJH  01-Jul-87  Checks for PCS>16. Change WOMSAT to only do
;			16 blocks in SATT if large disk.
;
;			[RSTS/E V9.5]
;  002  VAM  02-Sep-87	Add SAA and related routines.
;
;			[RSTS/E V9.7]
;  003	WRM  12-MAy-89	Add ZERSAT routine
;-


.SBTTL	FIP MACROS AND PARAMETERS

GLOBAL	<FIBUF,FIBENT,FIBMAP,SATBUF>	;FREQUENTLY USED GLOBALS

.MACRO	I.MESS
	TMPORG	FIMTXT
.NLIST	BEX
.ENDM	I.MESS

	DEFORG	FIM


.SBTTL	RESET FIP CONTROL AREA (SETFIP)
;+
; SETFIP - SET UP CONTROL AREA FOR MINI-FIP FOR BOOTED (SYSTEM) DISK
; SETFNS - SET UP CONTROL AREA FOR NON-SYSTEM DISK
;
; CALL:	IF CALLING SETFNS,
;		R0 = DISK INDEX (IDX$D?)
;		R1 = DISK UNIT NUMBER (0 TO 7)
;	CALL	SETF??
;
; BACK:	FIP CONTROL AREA SET UP:
;	DISK PARAMETERS SET IN SYSNDX, SYSUNT, SYSPHU
;	FIP CONTROL AREA MARKED IN-USE
;	DSQ, ETC. CLEARED
;	PCS, DCS (FROM DISK), CLURAT SET UP
;
; NOTE:	THIS ROUTINE NEED NOT BE CALLED IF THE FIP AREA IS ALREADY CLEAN
;	(I.E. FIPFLG = 0)
;
; NOTE: IF NOERR = -1 AND THIS IS NOT A RSTS DISK, THEN NRSTSD = -1
;
; ERRORS: IF THE PCS IS THE MFD PACK LABEL IS NOT 1,2,4,8, 16, 32 or 64:
;	"PACK CLUSTER SIZE IS NOT 1, 2, 4, 8, 16, 32, or 64."
;-

.ENABL	LSB

SETFIP::MOV	SYNXSV,R0	;R0 = DISK INDEX
	MOV	SYSUSV,R1	;R1 = DISK UNIT
SETFNS::REGSCR			;SAVE REGISTERS
	CLRB	NRSTSD		;ASSUME IT IS A RSTS DISK
	MOV	#SETFP0,R5	;START OF CLEAR AREA
	MOVB	NOERR,-(SP)	;SAVE THE NO ERROR FLAG
10$:	CLR	(R5)+		;CLEAR IT
	CMP	R5,#SETFP1	;END?
	BLO	10$		;NOPE
	MOVB	(SP)+,NOERR	;RESET THE NO ERROR FLAG
	MOV	#256.,I.DSQ+DSQCNT ;NORMALLY 256 WORD TRANSFERS
	MOV	#-8.,NRETRY	;SET BIG RETRY COUNT AND NOT DSKINT
	MOV	#-1,FIPFLG	;SET THE FIP FLAG
	MOVB	#-1,DSIFLG	;SET THE NO-DSKINT FLAG
	MOV	RFSLSV,DF$SZL	;RESTORE RF SIZE
	MOV	R1,R4		;R4 = DISK UNIT
	MOV	R1,SYSUNT	;SET DISK UNIT NUMBER
	MOVB	R1,SYSPHU+1	;SAVE PHYSICAL UNIT
	ASL	R1		;R1 = DISK UNIT * 2
	MOVB	R1,SYSPHU	;ALSO SAVE THAT
	MOV	R0,SYSNDX	;SET DISK INDEX
	BMI	80$		;NOT A DISK, HOW SAD
	CMP	R0,#IDX$..	;Using boot driver?
	BNE	15$		;No
	CMPB	B.NAME,#'M	;Yes, booting from tape?
	BEQ	80$		;Yes, so it's not a disk!
15$:	MOV	R0,R1		;R1 = DISK INDEX (FOR RESETTER)
	CALLX	XXRSET		;RESET THE DISK (ACK IT), UNIT IN R4
	BCS	50$		;DISK TIMED OUT, GIVE ERROR
	CALLX	READPL		;Read pack label
	TSTB	IOERR		;WAS THERE AN ERROR?
	BNE	50$		;YES, GIVE AN ERROR MESSAGE
	ASL	R4		;R4 = DISK UNIT * 2
	MOV	FIBUF+10,R1	;R1 = PCS FROM PACK LABEL
	MOV	R1,R2		;VERIFY LEGAL PCS
	BEQ	20$		;0 IS A REAL ERROR
	CMP	R2,#64.		;LEGAL PCS=1,2,4,8,16,32,64		;001
	BHI	20$		;No- error				;001
	DEC	R2		;MAKE A MASK 				;001
	BIT	R1,R2		;IS IT A POWER OF 2?
	BNE	20$		;NO, DIE
	MOV	R1,PCS		;SET PACK CLUSTER SIZE
	MOV	R4,R3		;COPY UNIT * 2
	ADD	DSKSZL(R0),R3	;R3 -> SIZE LSB FOR THIS DISK UNIT
	MOV	(R3),SYSSZL	;SET IT
	MOV	R4,R3		;COPY UNIT * 2
	ADD	DSKSZM(R0),R3	;R3 -> SIZE MSB FOR THIS DISK UNIT
	MOV	(R3),SYSSZM	;SET IT
	ADD	DSKDCS(R0),R4	;R4 -> CLUSTER SIZE OF THIS DISK
	CMP	R1,(R4)		;PCS MUST BE >=DEVICE CLUSTER SIZE (DCS)
	BLO	20$		;COMPLAIN IF NOT
	MOV	(R4),DCS	;STORE DEVICE CLUSTER SIZE (DCS)
	CLR	R0		;CLEAR FOR DIVIDE
	DIV	(R4),R0		;R0 = CLUSTER RATIO=PCS/DCS
	MOV	R0,CLURAT	;STORE CLUSTER RATIO
	BNE	SETST0		;SET UP SAT PARAMETERS & EXIT		;001
	.BR	20$		;If =0 then error			;001

GLOBAL	<SYNXSV,SYSUSV,SETFP0,SETFP1,I.DSQ,NRETRY,FIPFLG,DSIFLG,SYSPHU,SYSUNT>
GLOBAL	<SYSNDX,RFSLSV,DF$SZL,NRSTSD>



20$:	TSTB	NOERR		;ARE WE SUPRESSING ERRORS?
	BNE	30$		;YES, DON'T GIVE AN ERROR MESSAGE
	TSTB	SAVDEV		;ARE WE A SAV/RESTORE DISK?
	BEQ	40$		;NO, THEN WE ARE RSTS, AND THIS IS AN ERROR
30$:	ADD	DSKDCS(R0),R4	;R4 -> DCS FOR THIS DISK
	MOV	(R4),DCS	;SET THE DEVICE CLUSTER SIZE
	BR	80$		;INDICATE WE ARE NOT RSTS

40$:	ERF	<"Pack cluster size is not 1, 2, 4, 8, 16, 32 or 64.">	;001

50$:	TSTB	NOERR		;ARE WE SUPRESSING ERRORS?
	BEQ	60$		;NO, GIVE A FATAL ERROR
	MOVB	#HNGDEV,IOERR	;GIVE THE HUNG DEVICE ERROR
	BR	80$		;AND INDICATE THAT IT IS NON-RSTS DISK
60$:	MESSAGE	<"Disk ">
	MOV	DSKNAM(R0),R2	;GET THE DISK NAME
	CALLX	TYPE2		;AND TYPE OUT THE NAME
	MOV	R4,R0		;AND GET THE UNIT NUMBER
	CALLX	DECZER		;PRINT THE UNIT NUMBER
	MESSAGE	<": is hung">
	TRAP
	.WORD	0

GLOBAL	<HNGDEV,PCS,DSKSZL,SYSSZL,DSKSZM,SYSSZM,DSKDCS,DCS,CLURAT,NOERR,IOERR>
GLOBAL	<DSKNAM,SAVDEV>


;+
; ENDFIP - MARK FIP CONTROL AREA CLEAN & FINISH UP
;
; CALL:	CALL	ENDFIP
;
; BACK:	FIP CONTROL AREA MARKED CLEAN
;
; NOTE:	CALL THIS ROUTINE ONLY IF THE FIP AREA REALLY IS CURRENT!
;-
ENDFIP::CLR	FIPFLG		;CLEAR THE FIP FLAG
70$:	RETURN			;A BIGGIE

80$:	MOVB	#-1,NRSTSD	;INDICATE THAT THIS IS NOT A RSTS DISK
	RETURN

.DSABL	LSB

GLOBAL	<FIPFLG,NRSTSD>


;+
; SETTAP - SET UP FIP CONTROL AREA FOR TAPES
;
; 	R0 = TAPE INDEX (IDX$??)
;	R1 = TAPE UNIT
;
; CALL:	SETTAP
;
; BACK: FIP AREA SET UP, TAPE REWOUND TO BOT
;
; NOTE: IF ERROR C = 1 AND IOERR CONTAINS TAPE ERROR
;-

.ENABL	LSB

SETTAP::REGSCR			;SAVE REGISTERS
	MOVB	NOERR,-(SP)	;SAVE THE NO ERROR INDICATOR
	MOV	#SETFP0,R5	;R5 -> FIP CONTROL AREA
10$:	CLR	(R5)+		;CLEAR OUT FIP CONTROL AREA
	CMP	R5,#SETFP1	;DONE?
	BLO	10$		;NOPE
	MOVB	(SP)+,NOERR	;RESTORE THE NO ERROR INDICATOR
	MOV	#256.,I.DSQ+DSQCNT ;NORMALLY 256. WORD TRANSFERS
	MOV	#-8.,NRETRY	;NORMALLY 8 RETRYS
	MOVB	#-1,DSIFLG	;SET THE NO DSKING FLAG
	MOV	R1,SYSUNT	;SET THE TAPE UNIT
	MOVB	R1,SYSPHU+1	;BOTH PLACES
	ASL	R1		;DOUBLE THE UNIT
	MOVB	R1,SYSPHU	;AND SET IT HERE ALSO
	MOV	R0,SYSNDX	;SET THE SYSTEM INDEX
	MOVB	#-1,NRSTSD	;THIS IS NOT A DISK
	ASR	R1		;MAKE UNIT SINGLE AGAIN
	CALLX	MXRSET		;DO A TAPE RESET
	BCC	20$		;NO ERROR, REWIND TAPE
	MOVB	#HNGDEV,IOERR	;INDICATE A HUNG TAPE
	BR	30$		;AND LEAVE WITH CARRY SET

20$:	MOV	SYSNDX,R0	;RESTORE INDEX
	MOV	SYSUNT,R1	;AND UNIT
	CALLX	MAGSPC,R5,<3.>	;REWIND THE TAPE
30$:	RETURN			;AND RETURN

.DSABL	LSB


.SBTTL	Set up SAT parameters (SETSAT)

;+
; SETSAT - Set up table of SAT parameters
;
; Call:	CALL	SETSAT
;
; Back:	SAT tables set up:
;	SATSYS contains info for system disk
;		+ SEGS = number of blocks in SAT (rounded to pack clus)
;		+ BYTS = number of bytes in SAT (512.*SEGS)
;		+ BITS = number of bits in SAT = # of pack clus in SAT
;			 = disk size-1/PCS
;-

SETSAT::REGSCR			; Save all regs
SETST0:	MOV	SYSNDX,R3	; Get the system disk index
	MOV	SYSUNT,R5	; Get unit
	ASL	R5		;  times 2
	MOV	DSKSZL(R3),R1	; Get ptr to LSB of disk sizes
	ADD	R5,R1		; Index down to proper unit
	MOV	(R1),R1		; Get disk size (LSB)
	MOV	DSKSZM(R3),R0	; Get ptr to MSB of disk sizes
	ADD	R5,R0		; Index down to unit
	MOV	(R0),R0		; Get disk size (MSB)
	MOV	PCS,R5		; Pack cluster size
	SUB	DCS,R1		; Subtract DCS blocks used in clu 0
	SBC	R0
20$:	ASR	R5		; Divide size by PCS
	BCS	30$		;  til Carry sets
	;CLC
	ROR	R0		; Shift size right
	ROR	R1
	BR	20$		; Hang in there

30$:	MOV	R1,SATSYS+BITS	; Save number of pack clusters
	CLR	R0		; Set up for divide
	ADD	#7777,R1	; Round up by 4095 and
	ADC	R0
	ASHC	#-12.,R0	;  divide by 4096. bits per block
	MOV	R1,SATSYN	; Save number of blocks with free clus
	CALL	FIXCLU		; Round up to nearest cluster @PCS
	MOV	R1,SATSYS+SEGS	; Store  # blocks in sys disk SAT
	MUL	#512.,R1	;   at 512. bytes per block
	CMP	R1,#16.*1000	; At 16 block limit?			;001
	BLOS	32$		; no, so ok				;001
	MOV	#16.*1000,R1	; yes, so set it as the limit		;001
32$:	MOV	R1,SATSYS+BYTS	;   gives # bytes in sys disk SAT
	RETURN

GLOBAL	<SYSNDX,SYSUNT,DSKSZL,DSKSZM,PCS,SATSYN>


.SBTTL	GET A CLEAN SAT INTO CORE (CLNSAT)
;+
; CLNSAT - LOAD IN-CORE SAT BUFFER WITH CLEAN (NOTHING ALLOCATED) SAT
;
; CALL:	SETSAT MUST HAVE BEEN CALLED
;	CALL	CLNSAT
;
; BACK:	IN-CORE SATBUF LOADED WITH SAT BITS:
;	ALL SYSTEM DISK CLUSTERS ARE DEALLOCATED
;	ALL BITS CORRESPONDING TO NON-EXISTENT BLOCKS ARE ALLOCATED
;	through block 16						;001
;
; NOTE:	THE SAT IS KEPT IN CORE AS A MULTIPLE OF PCS BLOCKS,
;	EVEN THOUGH ITS FILE LENGTH REFLECTS ITS TRUE EXTENT
;-
.ENABL	LSB

ZERSAT::MOV	#SATBUF,R4	;set word offset pointer at SATBUF base	;003
	MOV	#<16.*1000/2>,R0 ;number of words to zero for 16. blks	;003
5$:	CLR	(R4)+		;zero each word in satbuf		;003
	SOB	R0,5$		;untill all 16.blks cleared		;003
	RETURN			;that's all we do here			;003

ENDSAT::MOV	R3,-(SP)	;get a register for a flag		;003
	CLR	R3		;set clear bits flag to no (zero)	;003
	BR	7$		;now process satbuf only doing end sizing ;003

CLNSAT::MOV	R3,-(SP)	;get a register for a flag		;003
	MOV	#-1,R3		;set clear bit flag to yes (non zero)	;003
7$:	CLR	R4		;ZERO SAT BYTE POINTER			;003
	MOV	R2,-(SP)	;get a register				;001
	MOV	#1,R5		;START AT BIT ZERO
	MOV	SATSYS+BITS,R0	;R0 = # CLUSTERS IN SYS DISK SAT

; THIS ROUTINE DEALLOCATES BITS IN THE SAT. NUMBER OF BITS IS IN R0

10$:	CMP	R4,SATSYS+BYTS	;ROOM IN SAT ?
	BHIS	35$		;NO, QUIT, restoring R2& R3		;003
	TST	R3		;should we preserve satdata?		;003
	BEQ	15$		;yes					;003
	BICB	R5,SATBUF(R4)	;No, CLEAR A BIT			;003
15$:	CALL	30$		;ADVANCE TO NEXT BIT			;003
	SOB	R0,10$		;CLEAR AS MANY AS NEEDED

; NOW TO FINISH UP BY ALLOCATING ALL BITS BEYOND PHYSICAL END OF DISK

20$:	MOV	SATSYS+BYTS,R2	;save the byts to be cleared		;001
	CMP	R2,#16.*1000	;At the limit?				;001
	BLOS	25$		;no, so ok				;001
	MOV	#16.*1000,R2	;yes, so set the valid limit		;001
25$:	CMP	R4,R2		;FINISHED YET ?				;001
	BHIS	35$		;YES, FINAL EXIT			;001
	BISB	R5,SATBUF(R4)	;SET A BIT
	CALL	30$		;ADVANCE TO NEXT BIT
	BR	25$		;LOOP MORE				;001

; THIS ROUTINE ADVANCES TO THE NEXT BIT

30$:	ASLB	R5		;SHIFT BIT LEFT ONE
	BCC	40$		;STILL IN BYTE ?
	INC	R4		;NO, ON TO NEXT BYTE
	INC	R5		;AND SET MASK TO BIT 0 AGAIN
	BR	40$		;and return				;001

35$:	MOV	(SP)+,R2	;restore register			;001
	MOV	(SP)+,R3	;restore register			;003
40$:	RETURN
.DSABL	LSB


.SBTTL	SEARCH UFD FOR PPN + FILE.EXT  (SDU)
;+
; SDU - SEARCH UFD FOR [PPN]FILNAM.EXT
;
; CALL:	R0 -> PPN+FILNAM.EXT
;	CALL	SDU
;
; BACK:	C=0	FILE FOUND IN UFD
;		R2 = LINK IN UFD TO PREVIOUS NAME ENTRY
;		R3 = LINK IN UFD TO FOUND NAME ENTRY
;		R5 -> NAME ENTRY
;		FIPMUC = UFD CLUSTER SIZE
;	C=1	FILE NOT FOUND
;		R5=0	PPN NOT FOUND IN MFD
;			FIPCLU = LINK IN MFD TO LAST NAME ENTRY
;			FIBUF CONTAINS BLOCK WHICH FIPCLU POINTS TO
;		R5=2	PPN FOUND IN MFD, BUT UFD NOT ALLOCATED
;			FIBUF CONTAINS MFD BLOCK W/ ACCOUNT'S NAME ENTRY
;			FIPCLU = ABSOLUTE POINTER TO
;				ACCOUNT'S NAME ENTRY + UAR
;				(I.E. @FIPCLU IS DCN OF UFD = 0)
;			FIPMUC = UFD CLUSTER SIZE (FROM ACCOUNT'S AB)
;		R5=4	UFD EXISTS, BUT FILE NOT FOUND
;			R2 = LINK IN UFD TO LAST NAME ENTRY
;			R3 = 0
;			FIBUF CONTAINS UFD BLOCK WHICH R2 POINTS TO
;			FIPMUC = UFD CLUSTER SIZE
;-
SDU::	CALL	RUF		;RUF WILL GET THE UFD
	BCS	30$		;EXIT IF PPN NOT FOUND OR NO UFD
	CLR	R2		;INIT UFD SCAN
	CLR	R3		;ZERO LINK
10$:	CALL	RDB		;GET A NAME BLOCK
	BCS	30$		;WE CAN NOT ACCEPT BAD LINKS
	CMP	2(R0),UNAM(R5)	;MATCH ON NAME FIRST WORD ?
	BNE	20$		;NO,GET ANOTHER NAME BLOCK
	CMP	4(R0),UNAM+2(R5);GO FOR 2 ?
	BNE	20$		;NOPE
	CMP	6(R0),UNAM+4(R5);TRY THE EXTENSION
	BNE	20$		;SORRY CHARLIE
	BITB	#US.DEL!US.UFD,USTAT(R5) ;MARKED FOR DELETION OR UFD?
	BEQ	30$		;IF NOT, THEN WE FOUND IT
				;IF SO , IGNORE IT
20$:	MOV	R3,R2		;NEW LAST LINK
	MOV	(R5),R3		;NEW THIS LINK
	BIC	#17,R3		;WITHOUT FLAG BITS
	BNE	10$		;IF NOT END OF UFD, LOOP
	MOV	#4,R5		;IF END, SET R5=4 FOR EOF
	SEC			;INDICATE BADNESS
30$:	RETURN			;RETURN


.SBTTL	READ UFD GIVEN A PPN  (RUF)
;+
; RUF	- READ FIRST BLOCK OF UFD GIVEN PPN
;
; CALL:	R0 -> PPN
;	CALL	RUF
;
; BACK:	C=0	UFD WAS FOUND
;		FIBUF CONTAINS FIRST BLOCK OF UFD
;		FIPMUC = UFD CLUSTER SIZE
;		FIPCLU = LINK IN MFD POINTING TO NB ENTRY FOR PPN
;		R5 = 0
;	C=1	UFD COULD NOT BE READ
;		R5=0	PPN NOT FOUND IN MFD
;			FIPCLU = LINK IN MFD TO LAST NAME ENTRY
;			FIBUF CONTAINS BLOCK WHICH FIPCLU POINTS TO
;		R5=2	PPN FOUND IN MFD, BUT UFD NOT ALLOCATED
;			FIBUF CONTAINS MFD BLOCK W/ ACCOUNT'S NAME ENTRY
;			FIPCLU = ABSOLUTE POINTER TO
;				ACCOUNT'S NAME ENTRY + UAR
;				(I.E. @FIPCLU IS DCN OF UFD = 0)
;			FIPMUC = UFD CLUSTER SIZE (FROM ACCOUNT'S NB)
;-
RUF::	CLR	R5		;SET R5 TO ZERO INITIALLY
	REGSCR			;SAVE REGS
	MOV	(R0),-(SP)	;PUT SUPPLIED PPN ON STACK
	MOV	SP,R0		;R0 -> COPY OF PPN FOR SDM
	CALL	SDM		;SEARCH MFD FOR THIS PPN
	MOV	R2,FIPCLU	;STORE POSSIBLE LAST LINK IN TEMP
	BCS	30$		;NO PPN WAS FOUND, ACCOUNT DOESN'T EXIST
	ADD	#UAR,R5		;R5 -> RB LINK WORD
	MOV	(R5),R2		;GET THE UFD START DCN
	BNE	10$		;IF UFD EXISTS, BRANCH
	MOV	R5,FIPCLU	;STORE NB POINTER INTO A TEMP
	MOV	R3,-(SP)	;SAVE LINK TO ACCOUNT'S UFD NAME ENTRY
	MOV	-(R5),R3	;GET THE AB LINK
	CALL	RDB		;NOW GET ACCOUNT'S MFD ACCOUNTING ENTRY
	BCS	40$		;BAD ACCOUNTING ENTRY
	MOV	UCLUS(R5),FIPMUC;SET THE UFD CLUSTER SIZE FROM THAT
	MOV	(SP)+,R3	;RESTORE NAME ENTRY LINK
	CALL	RDB		;READ NAME ENTRY AGAIN
	BCS	30$		;BAD LINK GIVE BAD FILE
	COM	(SP)+		;SET THE CARRY, DUMP STACK
	MOV	#2,TOS.R5(SP)	;SET R5 TO 2 (ACCOUNT BUT NO UFD)
	RETURN			;RETURN WITH BADNESS NOTED

GLOBAL	<FIPCLU,FIPMUC,UCLUS>


10$:	CALL	CNVRIB		;CONVERT DCN TO FIP BLOCK #
20$:	CALL	READ		;READ IN FIRST BLOCK OF UFD
	MOV	FIBMAP,FIPMUC	;SET UFD CLUSTER SIZE FROM MAP
      ; CLC			;INDICATE GOODNESS
30$:	INC	(SP)+		;DUMP STACK LEAVING CARRY ALONE
	RETURN

40$:	INC	(SP)+		;DUMP STACK LEAVING CARRY ALONE
	INC	(SP)+		;DUMP STACK LEAVING CARRY ALONE
	RETURN

GLOBAL	<FIBMAP,FIPMUC>


.SBTTL	READ NAME ENTRY FOR OPEN FILE (RNB)
;+
; RNB - READ NAME ENTRY OF OPEN FILE
;
; CALL:	R1 -> FCB
;	CALL	RNB
;
; BACK:	R5 -> NAME ENTRY OF FILE IN FIBUF
;-
RNB::	MOV	R2,-(SP)	;SAVE REGS
	MOV	R3,-(SP)
	CMPB	(R1),SYSNDX	;IS THIS THE RIGHT DISK?
	BNE	10$		;NO, BOOT
	CMPB	DDUNT(R1),SYSUNT ;YES, RIGHT UNIT?
	BNE	10$		;NO, BOOT
	MOV	FCUFND+F.FBNL(R1),R2 ;GET LSB OF FBN FOR NAME ENTRY
	MOVB	FCUFND+F.FBNM(R1),R3 ;GET MSB
	CALL	READ		;READ IN THE RIGHT BLOCK
	CLR	R5		;CLEAR R5 FOR BISB
	BISB	FCUFND+F.UNT(R1),R5 ;GET OFFSET/2 IN R5
	ASL	R5		;R5 = OFFSET OF N.E. IN FIBUF
	ADD	#FIBUF,R5	;R5 -> N.E.
	MOV	(SP)+,R3	;RESTORE REGS
	MOV	(SP)+,R2
	RETURN

10$:	ERF	<"INIT bug - RNB to wrong disk">

GLOBAL	<SYSNDX,SYSUNT>


.SBTTL	SEARCH UFD FOR PPN  (SDM)
;+
; SDM - SEARCH MFD FOR PPN
;
; CALL:	R0 -> PPN
;	CALL	SDM
;
; BACK:	C=0	PPN FOUND IN MFD
;		R2 = LINK IN MFD TO PREVIOUS NAME ENTRY (TO DELETE ACCT)
;		R3 = LINK IN MFD TO THIS NAME ENTRY
;		R5 -> NAME ENTRY
;		FIBUF CONTAINS MFD BLOCK W/ THIS ACCOUNT'S NAME ENTRY
;		FIPMUC = MFD CLUSTER SIZE
;	C=1	PPN NOT FOUND IN MFD
;		R2 = LINK IN MFD TO LAST NAME ENTRY
;		R3 = 0
;		R5 DESTROYED
;		FIBUF CONTAINS LAST BLOCK OF MFD
;		FIPMUC = MFD CLUSTER SIZE
;-
SDM::	CALL	READPL		;Read the pack label
	BIT	#UC.NEW,FIBUF+PSTAT ;New pack?
	BNE	SDMNEW		;Yes, do it that way
	MOV	FIBMAP,FIPMUC	;SET MFD CLUSTER SIZE
	CLR	R2		;PREVIOUS LINK IS MFD'S DUMMY ENTRY
	MOV	FIBUF,R3	;R3 = LINK TO FIRST NAME ENTRY IN MFD
10$:	CALL	RDB		;READ A NAME ENTRY
	BCS	30$		;BAD NAME ENTRY
	CMP	(R0),UNAM(R5)	;TEST ARGS
	BNE	20$		;THIS IS NOT THE ACCOUNT NAME ENTRY
	BITB	#US.UFD,USTAT(R5) ;NAME MATCHES. MAYBE IT'S A FILE?
	BNE	30$		;NO, IT'S REALLY A UFD, SO EXIT WITH C=0
20$:	MOV	R3,R2		;SET NEW LAST LINK
	MOV	(R5),R3		;NEW CURRENT LINK
	BIC	#17,R3		; WITHOUT FLAG BITS
	BNE	10$		;CONTINUE IF NON ZERO
	SEC			;ELSE INDICATE BADNESS
30$:	RETURN

GLOBAL	<FIPMUC,FIBUF,FIBMAP>


SDMNEW:	MOV	FIBUF+MDCN,R2	;Get MFD DCN
	CALL	CNVRIB		;Convert to FBN
	ADD	#1,R2		;Point to GFD DCN table
	ADC	R3
	CALL	READ		;Read that
	CLR	R5		;Avoid sign extension
	BISB	1(R0),R5	;Get group number
	ASL	R5		; times 2 for word indexing
	MOV	FIBUF(R5),R2	;Get GFD DCN
	BEQ	10$		;Exit if no GFD
	CALL	CNVRIB		;Convert DCN to FBN
	ADD	#2,R2		;Point to UFD name entry link table
	ADC	R3
	CALL	READ		;Read it in
	CLR	R5		;Avoid sign extension
	BISB	(R0),R5		;Get user number
	ASL	R5		;Word offset
	MOV	FIBUF(R5),R5	;Get the link
	BEQ	10$		;Error if no account there
	SUB	#2,R2		;Point back to start of GFD
	SBC	R3
	CALL	READ		;Read it for the cluster map
	MOV	R5,R3		;Copy saved link for RDB
	CALLR	RDB		;Read the name entry and return

10$:	CLR	R5		;Indicate PPN doesn't exist
	SEC			;Error
	RETURN

;+									;002+
; RDECHK - CONDITIONALLY READ ENTRY.
;
;	R3 =  LINK OF ENTRY
;	FIBUF HAS ANY BLOCK OF THE DIRECTORY
;
;	CALL	RDECHK
;
;	R5 -> ENTRY
;
;	IF Z=0 THEN ENTRY READ, C=0
;	IF Z=1 THEN LINK WAS NULL, C=UNCHANGED
;-

RDECHK::BIT	R3,#UL.BLO!UL.CLO!UL.ENO ;NULL LINK?
	BNE	RDE		;NO, DO A REAL READ (EXIT Z=0)
	RETURN			;YES, EXIT Z=1, C UNCHANGED		;002-


.SBTTL	READ A DIRECTORY ENTRY (RDS AND RDB)
;+
; RDB or RDE - READ ENTRY FROM A DIRECTORY GIVEN LINK			;002
; RDS - READ ENTRY FROM A DIRECTORY GIVEN LINK, MARK CURRENT BLOCK DIRTY
;
; CALL:	FIBUF MUST CONTAIN ANY BLOCK OF THIS DIR (SO FIBENT IS VALID)
;	FIBPHS CONTAINS CURRENT FIBUF FBN (AS USUAL)
;	R3 = LINK TO DESIRED ENTRY
;	CALL	RDB OR RDS
;
; BACK:	BLOCK WITH DESIRED ENTRY IS IN FIBUF
;	R5 -> DESIRED ENTRY
;	C=0
;
; ERRORS: IF A LINK IS DECODED AND SPECIFIES AN UNALLOCATED DIRECTORY
;	CLUSTER, OR SPECIFIES A BLOCK WITHIN CLUSTER WHICH IS
;	GREATER THAN THIS DIRECTORY CLUSTER SIZE:
;	"DIRECTORY ERROR DETECTED IN RDB"
;	C=1 IF NOERR IS SET (NOERR = -1)
;-
.ENABL	LSB

RDS::	BISB	(PC),@#FIBSTA	;MARK FIBUF FOR WRITE (MBFW)
RDE::				;For compatibility with real FIP.	;002
RDB::	MOV	R2,-(SP)	;SAVE CALLING R2
	MOV	R3,-(SP)	;SAVE LINK FOR LATER RESTORING
	BIC	#17,R3		;CLEAR OFF FLAG BITS
	MOV	R3,R5		;COPY LINK INTO R5
	BIC	#^C<777>,R5	;LEAVE ONLY BUFFER OFFSET IN R5
	BIC	R5,R3		;AND REST ONLY IN R3
	ADD	#FIBUF,R5	;R5 IS NOW THE ABS POINTER FOR EXIT
	SWAB	R3		;GET REST OF LINK INTO LOW BITS
	MOV	R3,R2		;COPY WHAT IS LEFT OF LINK
	BIC	#-16-1,R2	;LEAVE ONLY CLUSTER NUMBER * 2 IN R2
	MOV	FIBENT(R2),R2	;NOW GET MAP ENTRY
	BNE	20$		;MUST BE NON-ZERO
10$:	TSTB	NOERR		;ARE RSTS DISK ERRORS BEING SUPRESSED
	BNE	30$		;YUP
RDBERR: ERF	<"Directory error detected in RDB">

GLOBAL	<FIBSTA,NOERR>


20$:	ASH	#-4,R3		;SHIFT TO GET BLOCK WITHIN CLUSTER
	CMPB	R3,FIBMAP	;IS IT VALID FOR THIS DIRECTORY?
	BHIS	10$		;NO, DIRECTORY IS BAD
	MOV	R3,-(SP)	;SAVE THAT OFFSET
	CALL	CNVRIB		;CONVERT DEVICE CLUSTER # TO FIP BLOCK #
	ADD	(SP)+,R2	;ADD OFFSET INTO DIRECTORY CLUSTER
	ADC	R3		;(DOUBLE PRECISION)
	CALL	READ		;READ IN THE BLOCK OF THE DIRECTORY
	MOV	(SP)+,R3	;RESTORE ORIGINAL LINK WORD
	MOV	(SP)+,R2	;AND CALLING R2
	RETURN

30$:	CMP	(SP)+,(SP)+	;DUMP THE STACK
	SEC			;INDICATE AN ERROR
	RETURN

.DSABL	LSB


.SBTTL	LOOKUP A FILE ON THE SCRATCH FIRQB
;+
; LOK... - LOOKUP A FILE USING FIRQB FQ...
;
; CALL:	PRESET FILE NAME AND EXTENSION IN FQ...
;	CALL	LOK...
;
; BACK:	(SEE LOKFIL)
;-

LOK...::MOV	#FQ...,R4	;POINT TO START OF FIRQB
	.CALLR	LOKFIL		;FALL INTO LOKFIL

GLOBAL	<FQ...>


.SBTTL	LOOKUP A FILE
;+
; LOKFIL - LOOKUP A FILE ON THE DISK
;
; CALL:	R4 -> FIRQB CONTAINING PPN+FILNAM.EXT
;	CALL	LOKFIL
;
; BACK:	C=0	FILE FOUND ON DISK
;		FCB ASSOCIATED WITH FIRQB SET UP FOR READING
;		FQSIZC SET UP WITH FILE'S SIZE
;	C=1	FILE NOT FOUND
;-
LOKFIL::REGSCR			;SAVE ALL REGISTERS
	BIC	#FS.OPN,FQSTAT(R4) ;MARK IT NOT OPEN FOR NOW
	MOV	R4,R0		;COPY FIRQB POINTER
	ADD	#FQPPN,R0	;R0 -> PPN+FILNAM.EXT
	CALL	SDU		;LOOK UP THE FILE BY NAME
	BCS	40$		;CAN'T FIND IT, RETURN C=1
	ADD	#FQFCB+FCBSIZ,R4 ;R4 -> END OF ASSOCIATED FCB
	MOV	#FCBSIZ/2,R3	;R3 = NUMBER OF WORDS TO CLEAR
10$:	CLR	-(R4)
	SOB	R3,10$
	MOVB	FIBIDX,(R4)+	;SAVE DISK TYPE INDEX
	MOVB	USTAT(R5),(R4)+	;FILE FLAGS (CONTIGUOUS)
	INC	R4		;SKIP PENDING XFER
	MOVB	FIBUNT,(R4)+	;SAVE FIP UNIT NUMBER
	MOV	R4,R0		;REMEMBER THIS POINTER
	ADD	#FCUFND-FCSIZ,R4 ;POINT TO UFD NAME ENTRY DESCRIPTOR
	MOV	R5,R2		;COPY NAME ENTRY POINTER
	SUB	#FIBUF,R2	;GET OFFSET TO N.E. WITHIN FIBUF
	ASR	R2		;MAKE IT A BYTE
	MOVB	R2,(R4)+	;SAVE IT IN FCB
	MOVB	FIBPHS+2,(R4)+	;SAVE CURRENT FIP BLOCK NUMBER
	MOV	FIBPHS,(R4)+	;(23 BITS)
	MOV	UAA(R5),R3	;R3 = LINK TO ACCOUNT ENTRY
	MOV	UAR(R5),R2	;R2 = LINK TO FIRST RETRIEVAL ENTRY
	CALL	RDB		;POINT TO ACCOUNT ENTRY
	BCS	40$		;BAD RETRIEVAL ENTRY

GLOBAL	<FIBIDX,FIBUNT,FIBPHS>


	MOV	USIZ(R5),(R0)	;SAVE FILE SIZE IN FCB
	MOV	(R0)+,FQSIZC-<FQFCB+FCWND>(R4) ; ALSO IN FQB EXTENSION
	CMP	(R0)+,(R0)+	;SKIP NEXT VIRTUAL BLOCK & FIRST V.B.(0)
	MOV	UCLUS(R5),(R0)	;GET FILE CLUSTER SIZE
	DEC	(R0)+		;MAKE IT A BYTE (AND FLAGS = 0)
	MOV	R2,R3		;R3 = LINK TO RETRIEVAL ENTRY
	BIC	#17,R3		; WITHOUT FLAG BITS
	BEQ	30$		;NONE (NULL FILE)
	CALL	RDB		;READ IT IN
	BCS	40$		;BAD RETRIEVAL ENTRY
20$:	MOV	(R5)+,(R4)+	;MOVE IN A WINDOW
	BIT	R5,#17		;DONE (ONLY FIBUF IS ALIGNED!)
	BNE	20$
30$:	CLC			;CLEAR CARRY FOR DONE
	BIS	#FS.OPN,FQSTAT-<FQFCB+FCUFND>(R0) ;MARK THE FILE OPEN
40$:	RETURN


.SBTTL	LOOK FOR MINIMAL SET OF FILES FOR A RSTS DISK

.ENABL LSB

;+
; LOKRST - LOOK FOR MINIMAL FILE SET FOR RSTS DISKS
;
; CALL: R0 = IDX$D?
;	R1 = DISK UNIT NUMBER (0-7)
;
;	CALL LOKRST
;
; BACK: NRSTSD = 0 (RSTS DISK) FIP CONTROL AREA SET UP
;	NRSTSD = -1 (NON-RSTS DISK) NOTHING SET UP
;	REGISTERS PRESERVED
;-

LOKRST::REGSCR			;LETS SAVE EVERYTHING
	MOVB	#-1,NOERR	;SET FLAG TO CATCH DATA ERRORS
	CLRB	NRSTSD		;ASSUME THIS IS A RSTS DISK
	CALL	SETFNS		;ATTEMPT TO SET UP FIP CONTROL AREA
	CLRB	NOERR		;TURN OFF ERROR TRAPPING
	MOV	R1,R4		;COPY THE UNIT NUMBER
	ASL	R4		;DOUBLE IT
	MOV	R4,R5		;AND MAKE A COPY OF IT
	MOV	R4,R3		;MAKE TWO COPIES
	TST	R0		;IS THIS A TAPE?
	BMI	10$		;THEN IT IS NOT A GOOD RSTS DISK!
				; 4 lines removed			;JDB007
	ADD	DSKDCS(R0),R3	;R3 -> CLUSTER SIZE FOR THIS DISK UNIT
	MOV	(R3),DCS	;SET IT
	TSTB	NRSTSD		;WAS IT A RSTS DISK OR I/O ERROR
	BNE	10$		;NO, GIVE BACK NON-RSTS FLAG
	MOV	#FQBADB,R4	;LOOK FOR BADB.SYS
	CALL	LOKFIL		;IS IT THERE?
	BCS	20$		;NO
	MOV	#FQSATT,R4	;LOOK FOR SATT.SYS
	CALL	LOKFIL		;IS IT THERE?
	BCS	20$		;NO
	MOV	#FQINIT,R4	;LOOK FOR INIT.SYS
	CALL	LOKFIL		;IS IT THERE?
	BR	30$		;ALL IS HERE
10$:	SEC			;BAD DISK
20$:	MOVB	#-1,NRSTSD	;INIDICATE THIS IS NOT A RSTS DISK
30$:	RETURN

.DSABL	LSB

GLOBAL	<NOERR,NRSTSD,DSKSZL,DSKSZM,DSKDCS,DCS,FQBADB,FQSATT,FQINIT>



.SBTTL	Convert VBN to FBN

;+
; VBNFBN - Convert virtual block number to FIP block number
;
; Call:	R1 -> FCB
;	Virtual Block Number in FCB @ FCNVB
;
; Back:	FCB has correct window
;	R2/R3 = FBN of block
;	R0 destroyed
;-

VBNFBN::PUSH	R5		; R5 may be used by RNB
	BR	35$		; Join the loop

10$:	MOV	R4,-(SP)	; Save R4
	CALL	RNB		; R1 -> FCB. Get file's name entry in
	CLR	R3		; Get clustersize from FCB
	BISB	FCLUS(R1),R3
	INC	R3
	MUL	#7,R3		;  times 7 for 7 entries per window
	MOV	R3,-(SP)	; Save number of blocks per window
	MOV	FCWND(R1),-(SP)	;  and link to next window
	MOV	R1,R4		; Point FCB to NVB entry
	ADD	#FCNVB,R4	;   which contains the block to window to
	CMP	(R4)+,(R4)	; Do we turn back the window?
	BHIS	20$		; No, forward
	MOV	2(SP),(R4)	; Set FCFLB to -(CLUSIZ) so that
	NEG	(R4)		;  it will be 0 after the read
	MOV	UAR(R5),(SP)	; Set up link to first window
20$:	MOV	(SP)+,R3	; Get retrieval entry link
	CALL	RDB		; Point to it
	BCS	40$		; Bad retrieval entry
	ADD	(SP),(R4)	; Bump block number of window by window sz
	MOV	(R5),-(SP)	; Save link to next r.e.
	CALLX	FILIX,R5	; Check for a valid window
	 BR	20$		; Not yet, keep turning windows
	CMP	(SP)+,(SP)+	; Dump junk from stack
	MOV	R1,R0		; Copy FCB pointer
	ADD	#FCWND,R0	; R0 -> FCB @ FCWND
30$:	MOV	(R5)+,(R0)+	; Copy the window to the FCB
	BIT	R5,#17		; Done?
	BNE	30$		; No
	MOV	(SP)+,R4	; Restore R4 (DSQ pointer)
35$:	CALLX	FILIX,R5	; Attempt the conversion
	 BR	10$		; No, must turn windows
	POP	R5		; Restore saved R5
	RETURN			; Return w/ FBN in R2/R3

40$:	JMP	RDBERR		; Give fatal error on bad retrieval entry


.SBTTL	GET DIRECTORY ENTRY (GDB)
;+
; GDB - GET A FREE DIRECTORY ENTRY (EXTEND DIRECTORY IF NEEDED)
;
; CALL:	FIBUF HAS ANY BLOCK OF THE DIRECTORY (FBN IN FIBPHS)
;	CALL	GDB
;
; BACK:	C=0	EMPTY ENTRY FOUND
;		R3 = LINK TO THIS ENTRY
;		R5 -> ENTRY IN FIBUF
;		ENTRY POINTED TO BY R5 IS ZEROED (NOT MARKED IN USE)
;	C=1	NO EMPTY ENTRY: DIRECTORY FULL OR NO CLUSTER ON DISK
;		(NO REGISTERS ALTERED)
;-
.ENABL	LSB

GDB::	CALLX	REGSAV,R5	;SAVE EM ALL
	MOV	FIBPHS,R2	;FIBUF MUST CONTAIN FIRST BLOCK TO CHECK
	MOV	FIBPHS+2,R3	;GET FIP BLOCK # INTO R2 AND R3
	CALL	CJK		;COMPUTE J & K FOR FIBPHS
	CLR	R4		;INDICATE FIRST TIME THROUGH
10$:	CALL	READ		;GET BLOCK R2,R3 INTO FIBUF
	CLR	R5		;START AT BEGINNING OF BLOCK
20$:	MOV	FIBUF(R5),-(SP)	;CHECK THE FIRST TWO WORDS
	BIS	FIBUF+2(R5),(SP)+ ;IF EITHER ONE IS NON-0
	BNE	50$		;THEN THIS IS NOT A HOLE
	MOV	R5,I		;GOT A HOLE. SET OFFSET WITHIN BLOCK
	CALLX	REGRES,R5	;RESTORE CALLER, LIMIT REG'S
	CALL	PLK		;PACK I, J, K INTO A LINK
	TST	R3		;IS THIS THE FIRST?
	BNE	30$		;IF LINK 0 THEN 1ST BLK,1ST SEG,1ST CLU
	MOV	#20,R3		;IF SO, FUDGE LINK TO 20
	MOV	R3,I		;SET I FOR FUDGE
	COM	FIBUF+2		;SET UP FIRST ENTRY TO BE DUMMY ENTRY
30$:	BISB	(PC),@#FIBSTA	;MARK BUFFER FOR WRITING
	MOV	I,R5		;RECALL OFFSET INTO BLOCK
	ADD	#FIBUF+20,R5	;R5 -> END OF FOUND ENTRY
40$:	CLR	-(R5)		;NOW CLEAR OUT THE HOLE
	BIT	R5,#17		;AT END?
	BNE	40$		;NO, CLEAR ALL 8. WORDS
	;CLC			;SET C TO 0 FOR GOOD ONE
	RETURN

GLOBAL	<FIBPHS,FIBUF,I,FIBSTA>


50$:	ADD	#20,R5		;BUMP THE BUFFER OFFSET TO NEXT
	CMP	R5,#760		;ARE WE INTO THE DIRECTORY CLUSTER MAP?
	BNE	20$		;IF NOT, THEN CONTINUE LOOKING

; SEGMENT IN MEMORY IS FULL. GET A NEW ONE

	TST	R4		;IS THIS THE FIRST TIME THROUGH?
	BEQ	60$		;YES, RESTART SEARCH FROM BEGINNING
	INCB	J		;NO, ADVANCE TO NEXT BLOCK IN CLUSTER
	CMPB	J,FIBMAP	;ARE WE DONE WITH THIS CLUSTER?
	BEQ	70$		;YES, GO GET THE NEXT ONE
	TST	FIBMAP		;MFD/GFD flag set?
	BPL	65$		;No, so it's an old disk or UFD
	TSTB	K		;First cluster?
	BNE	65$		;No, so it's normal
	CMPB	J,#1		;Pointing at block 1?
	BNE	65$		;No, so nothing doing
	MOVB	#3,J		;Skip the table blocks
	ADD	#2,R2		;Fix up the FBN
	ADC	R3		; double precision
65$:	ADD	#1,R2		;BUMP THE FIP BLOCK NUMBER
	ADC	R3		;(DOUBLE PRECISION FOR DEM BIG DISKS)
	BR	10$		;GO READ IT IN

; IF NO HOLE IS FOUND THE FIRST TIME THROUGH, RETRY FROM START OF DIR

60$:	INC	R4		;OFF WITH FIRST TIME SWITCH
	MOVB	#-1,K		;FUDGE K SO NEXT CLUSTER IS 0
70$:	INCB	K		;ADVANCE TO NEXT CLUSTER (0 FIRST TIME)
	CLRB	J		;BLOCK 0 WITHIN CLUSTER
	MOVB	K,R2
	CMP	R2,#7		;ARE DIRECTORY CLUSTERS 0-6 FULL?
	BEQ	150$		;SO SOLLY, DIRECTORY FULL
	ASL	R2		;GOODY, DOUBLE CLUSTER NUMBER
	MOV	FIBENT(R2),R2	;R2 = MAP ENTRY
	BEQ	80$		;IF NO MORE, GO EXTEND DIRECTORY
	CALL	CNVRIB		;CONVERT MAP DCN TO FIP BLOCK #
	BR	10$		;NOW GO READ THAT BLOCK

; EXTEND DIRECTORY AND UPDATE ALL DIRECTORY MAPS

80$:	MOV	FIBMAP,R1	;R1 = DIRECTORY CLUSTER SIZE
	CALL	GETDIR		;GET A CLUSTER ON THE DISK (R2 = DCN)
	BCC	150$		;DISK TOO FULL TO FIND ONE
	CLR	R0		;R0 COUNTS CLUSTERS FOR FIXING MAPS
	MOV	R2,R4		;SAVE THE DCN OF THE NEW CLUSTER
	MOVB	K,R2		;K = CLUSTER NUMBER (0-6) BEING CREATED
	ASL	R2		;R2 = OFFSET INTO DIRECTORY CLUSTER MAP
	MOV	R4,FIBENT(R2)	;PLANT THE MAP ENTRY
90$:	CLR	R1		;RESET BLOCK WITHIN CLUSTER
	CMPB	R0,K		;TIME TO CLEAR OUT THE NEW DIR CLUSTER?
	BEQ	130$		;YES, GO ZERO IT OUT
	MOV	R0,R2		;NO, GET DIR CLUSTER NUMBER
	ASL	R2		; * 2
	MOV	FIBENT(R2),R2	;GET A MAP ENTRY
	CALL	CNVRIB		;CONVERT DCN TO FBN OF DIR CLUSTER

GLOBAL	<J,FIBMAP,K,FIBENT>


100$:	CALL	READ		;READ BLOCK OF DIRECTORY CLUSTER
	MOVB	K,R5		;WHICH MAP ENTRY GETS PLUGGED?
	ASL	R5
	MOV	R4,FIBENT(R5)	;PLUG NEW CLUSTER INTO MAP
	BISB	(PC),FIBSTA	;MAKE SURE IT GETS WRITTEN
	TST	FIBMAP		;New pack MFD/GFD?
	BPL	105$		;No
	TST	R0		;First cluster?
	BNE	105$		;No
	TST	R1		;Did we just write first block?
	BNE	105$		;No
	MOV	#2,R1		;Yes, skip next 2 which are table blocks
	ADD	R1,R2		;Advance FBN by 2 also
	ADC	R3		; (double precision)
105$:	ADD	#1,R2		;NEXT BLOCK IN THIS DIR CLUSTER
	ADC	R3		;(I.E. BUMP FBN IN R2 AND R3)
	INC	R1		;COUNT BLOCKS WITHIN DIR CLUSTER
	CMPB	R1,FIBMAP	;DONE WITH THIS CLUSTER?
	BNE	100$		;NO, DO NEXT BLOCK IN CLUSTER
	INC	R0		;YES, ADVANCE TO NEXT CLUSTER
	BR	90$		;GO GET IT'S DISK ADDRESS

; WRITE OUT ANOTHER EMPTY BLOCK IN THE NEW CLUSTER (IF ANY)

110$:	CMPB	R1,FIBMAP	;CHECK FOR END OF CLUSTER
	BNE	115$		;If not, continue writing
	JMP	10$		;Go back to get an entry

115$:	ADD	#1,FIBPHS	;NEXT BLOCK IN THIS DIR CLUSTER
	ADC	FIBPHS+2	;(DOUBLE PRECISION)
120$:	INC	R1		;NEXT BLOCK WITHIN CLUSTER
	BISB	(PC),@#FIBSTA	;MARK BUFFER FOR WRITE

; CLEAR FIBUF, SET UP EMPTY ENTRIES WITH MAP AT END, AND WRITE IT OUT

130$:	CALL	WRITEC		;CLEAR OLD FIBUF OUT
	TST	R1		;IS THIS THE FIRST BLOCK IN THE NEW CLUSTER?
	BNE	110$		;NO, FIBUF IS ALREADY SET UP
	MOV	R4,R2		;NEW DIR CLUSTER'S DCN INTO R2
	CALL	CNVRIB		;CONVERT TO FIP BLOCK #
	MOV	R2,FIBPHS	;SET FIP BLOCK # FOR WRITE
	MOV	R3,FIBPHS+2	;BOTH WORDS AGAIN
	MOV	#FIBUF,R5	;THE MAP IN FIBUF IS, OF COURSE, GOOD
140$:	CLR	(R5)+		;ZERO OUT ALL WORDS BELOW THE MAP
	CMP	#FIBMAP,R5
	BNE	140$
	BR	120$		;FORCE A WRITE AND DO NEXT

; EXIT WITH ERROR

150$:	SEC			;SET CARRY FOR BADNESS
	CALLRX	RESRPC		;RESTORE REGS AND RETURN

.DSABL	LSB

GLOBAL	<K,FIBPHS,FIBSTA>


.SBTTL	DELETE A FILE BY NAME (DELNAM)
;+
; DELNAM - DELETE A FILE BY NAME
;
; CALL:	R4 -> FIRQB
;	CALL	DELNAM
;
; BACK:	C=0	FILE LOCATED AND DELETED AS REQUESTED
;	C=1	FILE NOT FOUND
;-
DELNAM::REGSCR			;SAVE REGS
	MOV	R4,R0		;COPY FIRQB POINTER
	ADD	#FQPPN,R0	;POINT TO PPN+NAME.EXT
	CALL	SDU		;SEARCH FOR THE FILE
	BCC	XFL2		;IF FOUND, THEN DELETE IT
	RETURN			;IF FILE NOT FOUND, EXIT WITH C=1


.SBTTL	DELETE USER FILE SPACE (XFL)
;+
; XFL - DELETE A FILE GIVEN LINK TO FILE'S NAME ENTRY
;
; CALL:	R2 = LINK TO PREVIOUS NAME ENTRY IN UFD
;	R3 = LINK TO NAME ENTRY OF FILE TO DELETE
;	FIBUF CONTAINS ANY BLOCK OF THE UFD
;	CALL	XFL
;
; BACK:	FILE DELETED AS REQUESTED
;-
.ENABL	LSB

XFL::	REGSCR			;SAVE REGS
XFL2:	CALL	60$		;FIRST WIPE NAME & ACCOUNT ENTRIES

; GET RID OF FILE SPACE
;	R1 = FILE CLUSTER SIZE
;	R0 = LINK IN UFD TO FIRST RETRIEVAL ENTRY

10$:	MOV	R0,R3		;COPY LINK TO NEXT (FIRST) RETRIEVAL ENTRY
	BIC	#17,R3		; WITHOUT FLAG BITS
	BEQ	40$		;ZERO MEANS END OF RETRIEVAL ENTRIES
	CALL	RDB		;GET NEXT (FIRST) RIB
	BCS	50$		;BAD RETRIEVAL ENTRY
	MOV	(R5),R0		;GET NEXT LINK
	CLR	(R5)+		;WIPE OUT RIB LINK ENTRY
	BISB	(PC),@#FIBSTA	;MARK FIBUF TO WRITE
20$:	MOV	(R5),R2		;GET CLUSTER TO RETURN
	BEQ	40$		;DONE, LAST RIB ONLY PARTIALLY FULL
	BIT	R4,#US.OUT	;IS THIS FILE OUT OF SATT?
	BNE	30$		;YUP, THAT CLUSTER DOESN'T EXIST
	CALL	RETCLU		;RETURN FILE SPACE
30$:	CLR	(R5)+		;CLEAR CLUSTER ENTRY
	BIT	R5,#17		;IS THIS THE RIB'S END?
	BNE	20$		;IF NOT, THEN KEEP GOING
	BR	10$		;LOOP TO GET THE NEXT RIB

40$:	CLC			;INDICATE GOODNESS
	RETURN

50$:	JMP	RDBERR		;GIVE FATAL ERROR ON BAD RETRIEVAL ENTRY

GLOBAL	<FIBSTA>


; ROUTINE TO WIPE NAME AND ACCOUNT ENTRIES,
;	LINK PREVIOUS NAME ENTRY TO NEXT ONE,
;	AND RETURN LINK TO RIB (OR RP TO START OF UFD)

60$:	CALL	RDB		;POINT TO NAME ENTRY IN R5
	BCS	50$		;BAD RETRIEVAL ENTRY
	MOV	(R5),-(SP)	;SAVE LINK TO THE NEXT ENTRY
	MOV	USTAT(R5),R4	;SAVE THE FILE'S STATUS
	MOV	UAA(R5),R3	;GET ACCOUNTING ENTRY LINK
	MOV	UAR(R5),R0	;AND GET RETRIEVAL LINK
	CLR	(R5)+		;NOW MAKE THE NAME ENTRY A HOLE
	CLR	(R5)		;BY CLEARING FIRST TWO WORDS OF IT
	CALL	RDS		;READ ACCT ENTRY
	MOV	UCLUS(R5),R1	;GET CLUSTER FACTOR
70$:	MOV	(R5),R3		;R3 -> ATTRIBUTES (IF ANY)
	CLR	(R5)+		;AND MAKE ACCOUNTING ENTRY A HOLE
	CLR	(R5)		;BY CLEARING 2 WORDS
	BIC	#17,R3		;R3 = LINK TO ACCOUNTING ENTRY
	BEQ	80$		;IF NONE, GO ZAP RETRIEVAL ENTRIES
	CALL	RDS		;ELSE GET THE ATTRIBUTE
	BR	70$		;AND CLEAR THAT, TOO

80$:	MOV	R2,R3		;GET LINK TO PREVIOUS ENTRY
	CALL	RDS		;AND READ IT
	MOV	(SP)+,(R5)	;AND RELINK TO NEW NEXT ENTRY
	BISB	(PC),@#FIBSTA	;MARK BUFFER FOR WRITE
	RETURN

.DSABL	LSB

GLOBAL	<FIBSTA>


.SBTTL	READ FOR FIP (READ,READSV,READRF,READMF)

;+
; READ   - READ BLOCK INTO FIBUF GIVEN FBN (WRITE FIRST IF MARKED)
; READSV - READ BLOCK INTO FIBUF GIVEN FBN, ALWAYS WRITE CURRENT BUF
; READRF - READ BLOCK INTO FIBUF GIVEN DCN (RP)
; READMF - READ FIRST BLOCK OF MFD INTO FIBUF
; READPL - Read pack label into FIBUF
;
; CALL:	FIPUNT = DISK UNIT NUMBER
;	FOR READ AND READSV -
;		R2 = LSB OF FBN OF BLOCK TO READ
;		R3 = MSB OF FBN OF BLOCK TO READ
;	FOR READRF -
;		R2 = DCN OF BLOCK TO READ
;	FOR READMF - NO SETUP
;	CALL	READ??
;
; BACK:	R2/R3 AND FIBPHS = FBN OF BLOCK READ
;	FIBUF CONTAINS THE BLOCK
;	FIBUNT = UNIT NUMBER
;	C=0
;-

.ENABL	LSB

READSV::BISB	(PC),@#FIBSTA	;FORCE A WRITE
READ::	CMP	R2,@#FIBPHS	;CHECK TO SEE IF SEGMENT ALREADY THERE
	BNE	10$		;IF NOT EQUAL, THEN DO THE I/O
	CMP	R3,@#FIBPHS+2	;CHECK MSB'S
	BEQ	20$		;IT'S ALREADY THERE, SO RETURN CARRY=0
10$:	CALL	WRITEC		;CHECK FOR WRITE BEFORE READ
	MOV	#256.,I.DSQ+DSQCNT ;INSURE CORRECT LENGTH OF READ
	CALLX	PARSEX,R5,<RFUN,FIBUF> ;DO A DISK OPERATION
	MOV	R2,@#FIBPHS	;SET LSB OF THE FIP BLOCK #
	MOV	R3,@#FIBPHS+2	; AND THE MSB'S
20$:	CLC			;MUST EXIT WITH C AT 0
	RETURN

; ENTRY TO READ THE FIRST BLOCK OF THE MFD

READMF::CALL	READPL		;Read the pack label first
	BIT	#UC.NEW,FIBUF+PSTAT ;Old pack?
	BEQ	20$		;Yes, so that is the MFD as well
	MOV	FIBUF+MDCN,R2	;Get the starting DCN of the MFD
	.CALLR	READRF		;Go read it and exit

; ENTRY TO READ IF R2 CONTAINS A RETRIEVAL POINTER (DCN) RATHER THAN
; R2,R3 CONTAINING THE FIP BLOCK NUMBER TO BE READ

READRF::CALL	CNVRIB		;CONVERT RIB ENTRY TO FIP BLOCK #
	BR	READ		;AND DO A NORMAL READ

; Entry to read the pack label

READPL::MOV	#1,R2		;Set up to read pack label
	CLR	R3		;WHICH IS FIP BLOCK # 1
	BR	READ		;OTHERWISE NORMAL READ

.DSABL	LSB

GLOBAL	<FIBSTA,FIBPHS,I.DSQ,FIBUF>


.SBTTL	WOMP THE IN-CORE SAT TO DISK (WOMSAT)
;+
; WOMSAT - WOMP THE IN-CORE SAT TO DISK
;
; CALL:	SAT SET UP IN SATBUF
;	CALL	WOMSAT
;
; BACK:	SAT HAS BEEN WOMPED
;	BITS CORRESPONDING TO THINGS PAST THE END-OF-DISK ALWAYS SET
;	up to and including the 16th block (even on large disks)	;001
;
; ERRORS: IF THE FILE SATT.SYS[0,1] DOES NOT EXIST (FIRQB NOT SET),
;	"INIT BUG - SATT.SYS NON-EXISTENT AT TIME OF WOMP"
;-
WOMSAT::REGSCR			;SAVE REGS
	BIT	#FS.OPN,FQSATT+FQSTAT ;SATT.SYS HAD OUGHTA EXIST
	BEQ	40$		;ELSE WE SHOULDN'T TRY TO WRITE INTO IT
	MOV	SATSYS+BYTS,R5	;R5 = TOTAL # BYTES IN SYSTEM DISK SATT
	CMP	R5,#16.*1000	;greater than 16 blocks?		;001
	BLOS	5$		;no, so ok				;001
	MOV	#16.*1000,R5	;yes, so only do 16 blocks worth	;001
5$:	ADD	#SATBUF,R5	;R5 -> END OF SATT (ABSOLUTE)
	MOV	SATSYS+BITS,R0	;R0 = REAL # OF BITS (TRUE CLUSTERS)
	MOV	R0,R1		;COPY THAT
	BIC	#7,R0		;ROUND R0 TO A BYTE MULTIPLE OF BITS
	BIC	R0,R1		;R1 = BIT NUMBER WITHIN LAST BYTE
	CLC
	ROR	R0		;R0 = RELATIVE BYTE POINTER INTO SATT
	ASR	R0
	ASR	R0
	ADD	#SATBUF,R0	;R0 -> FIRST BYTE WITH NX BLOCKS
	TST	R1		;IS THE BIT NUMBER 0?
	BEQ	20$		;YES, END OF SATT OR FILL BY BYTES
10$:	BISB	BITBYT(R1),(R0)	;SET ALL BITS FOR CLUSTERS ABOVE
	INC	R1		;  SYSTEM DISK BOUNDARY
	CMP	R1,#10		;DONE 8TH BIT IN THIS BYTE YET?
	BNE	10$		;NO
	INC	R0		;BUMP TO NEXT BYTE
20$:	CMP	R0,R5		;DONE WITH ALL BYTES ?
	BEQ	30$		;YEP
	MOVB	#-1,(R0)+	;SET THE WHOLE BYTE
	BR	20$		;AND LOOP

30$:	MOV	#FCSATT,R1	;POINT TO FCB FOR THE WRITE
	MOV	FCSIZ(R1),R0	;R0 = SIZE OF SATT.SYS IN BLOCKS
	SWAB	R0		; CONVERTED TO WORD COUNT
	CLR	FCNVB(R1)	;START WRITING SAT AT BLOCK 0
	CALLX	WRITE.,R5,<SATBUF> ;WRITE FROM SATBUF
	RETURN

40$:	ERF	<"INIT bug - SATT.SYS non-existent at time of WOMP">

GLOBAL	<SATSYS,FQSATT,BITBYT,FCSATT>


.SBTTL	WRITE FOR FIP (WRITE,WRITEC)
;+
; WRITE  - WRITE OUT CONTENTS OF FIBUF
; WRITEC - WRITE OUT CONTENTS OF FIBUF ONLY IF FIBSTA IS NON-0
;
; CALL:	FIBPHS = FIB BLOCK NUMBER OF BLOCK IN BUFFER
;	FIBUNT = DISK UNIT NUMBER
;	CALL	WRITE?
;
; BACK:	BLOCK WRITTEN
;	FIBSTA = 0
;-
.ENABL	LSB

WRITEC::TSTB	@#FIBSTA	;CHECK STATUS OF BUFFER
	BEQ	30$		;IF 0, NOTHING THERE OR NO CHANGE
WRITE::	CLRB	@#FIBSTA	;INDICATE BUFFER WRITTEN
	MOV	R2,-(SP)	;PUSH OLD R2
	MOV	R3,-(SP)	;AND  R3
	MOV	@#FIBPHS+2,R3	;GET MSB OF BLOCK # TO WRITE
	MOV	@#FIBPHS,R2	;GET THEM OTHER BITS TOO
	BNE	10$		;IF BLOCK # NOT ZERO,THEN DO THE I/O
	TST	R3		;ARE YOU SURE IT'S ZERO?
	BEQ	20$		;IF SO THEN SKIP THE WRITE
10$:	MOV	#256.,I.DSQ+DSQCNT ;INSURE CORRECT LENGTH OF WRITE
	CALLX	PARSEX,R5,<WFUN,FIBUF> ;FINISH PARAMS AND DO IT
20$:	MOV	(SP)+,R3	;POP OLD R3
	MOV	(SP)+,R2	;AND R2
30$:	RETURN

.DSABL	LSB

GLOBAL	<FIBSTA,FIBPHS,I.DSQ>


.SBTTL	CONVERT RETRIEVAL POINTER (DCN) TO FIP BLOCK #
;+
; CNVRIB - CONVERT RETRIEVAL POINTER (DEV CLU) TO FIP BLOCK #
; CNVRB2 - CONVERT RETRIEVAL POINTER TO FBN, PASSING DCS
;
; CALL:	R2 = RP TO CONVERT
;	DCS = DEVICE CLUSTER SIZE IF CNVRIB
;	R3  = DEVICE CLUSTER SIZE IF CNVRB2
;	CALL	CNVR??
;
; BACK:	R2/R3 = CORRESPONDING FBN
;-
CNVRIB::MOV	DCS,R3		;GET DEVICE CLUSTER SIZE
CNVRB2::MOV	R3,-(SP)	;SAVE DCS ON THE STACK
	CLR	R3		;CLEAR MSB OF FBN
	DEC	R2		;R2 = DCN - 1
10$:	ASR	(SP)		;MULTIPLY BY DEVICE CLUSTER SIZE (DCS)
	BCS	20$		; AND THEN ADD 1 TO GET
	ASL	R2		;  FIP BLK # = DCS*(DCN -1) + 1
	ROL	R3
	BR	10$

20$:	ADD	#1,R2		;R2 NOW HAS LSB OF BLOCK #
	ADC	R3		;R3 HAS MSB
	TST	(SP)+		;POP GARBAGE
	RETURN

.SBTTL	CONVERT DEVICE CLUSTER NUMBER TO PACK CLUSTER NUMBER (RIB2CN)
;+
; RIB2CN - CONVERT DEVICE CLUSTER NUMBER (R.P.) TO PACK CLUSTER NUMBER
;
; CALL:	R2 = DCN TO CONVERT
;	CLURAT = CLUSTER RATIO (PCS/DCS)
;	CALL	RIB2CN
;
; BACK:	R3 = PACK CLUSTER NUMBER
;	NO ERROR IF DCN TO CONVERT IS NOT ON PACK CLUSTER BOUNDARY
;-
RIB2CN::MOV	R2,-(SP)	;SAVE R2 FOR RETURN
	MOV	R2,R3		;NEED IT IN R3 FOR DIVIDE
	DEC	R3		;RETRIEVAL POINTER - 1
	MOV	CLURAT,R2	;PCN = (R.P. - 1)/(PCS/DCS)
10$:	ASR	R2		;NOW DIVIDE
	BCS	20$		;ALL DONE
	;CLC			;AVIOD SIGN EXTENSION ON
	ROR	R3		;THIS SHIFT
	BR	10$

20$:	MOV	(SP)+,R2	;RESTORE RETRIEVAL POINTER TO R2
	RETURN


.SBTTL	CONVERT PACK CLUSTER NUMBER TO FIP BLOCK NUMBER (CN2SEG)
;+
; CN2SEG - CONVERT PACK CLUSTER NUMBER TO FIP BLOCK NUMBER
;
; CALL:	R2 = PACK CLUSTER NUMBER TO CONVERT
;	PCS = PACK CLUSTER SIZE
;	CALL	CN2SEG
;
; BACK:	R2/R3 = FIP BLOCK NUMBER
;-
CN2SEG::CLR	R3		;BLK # = CN * PCS + 1
	MOV	PCS,-(SP)	;CLEAR MSB (R3) AND STACK PCS
10$:	ASR	(SP)		;NOW MULTIPLY
	BCS	20$		;ALL DONE
	ASL	R2		;DOUBLE
	ROL	R3		; SHIFT
	BR	10$

20$:	TST	(SP)+		;DUMP STACK ITEM
	ADD	#1,R2		;ADD 1
	ADC	R3		; AND CARRY
	RETURN

.SBTTL	CONVERT FIP BLOCK NUMBER TO PACK CLUSTER NUMBER
;+
; SEG2CN - CONVERT FIP BLOCK NUMBER TO PACK CLUSTER NUMBER
;
; CALL:	R2/R3 = FBN TO CONVERT
;	PCS = PACK CLUSTER SIZE
;	CALL	SEG2CN
;
; BACK:	R2 = PACK CLUSTER NUMBER
;	R3 <> 0 IF FBN WAS NOT ON A PACK CLUSTER BOUNDARY
;	CONDITION CODES SET ON R3 (Z=1 IF BOUNDARY OK)
;-
SEG2CN::SUB	#1,R2		;PCN = (BLK - 1)/PCS
	SBC	R3
	MOV	PCS,-(SP)	;GET PCS
10$:	ASRB	(SP)		;DIVIDE BY PCS
	BCS	20$
	ASR	R3		;SHIFT MSB
	ROR	R2		; BRING BITS INTO LSB
	ROLB	1(SP)		;SHIFTED OUT BITS TO STACK
	BR	10$

20$:	MOV	(SP)+,R3	;SET CC'S AND R3
	RETURN


.SBTTL	GET CLUSTER FOR DIRECTORY (ALIGNED ON CLUSTER BOUNDARY)
;+
; GETDIR - GET CLUSTER FOR DIRECTORY (ALIGNED ON CLUSTER BOUNDARY)
;
; CALL:	R1 = CLUSTER SIZE TO GET
;	CALL	GETDIR
;
; BACK:	C=1	CLUSTER HAS BEEN GOTTEN
;		R2 = DCN = R.P. TO START OF CLUSTER
;	C=0	NO CLUSTER AVAILABLE (R2 UNCHANGED)
;-
GETDIR::REGSCR			;SAVE ALL REGS
	MOV	R1,R5		;UFD CLUSTER SIZE TO R5
	CLR	R4		;SETUP DIVIDE
	DIV	PCS,R4		;(UFD CLU SIZE)/(PCS) = # OF PACKCLU'S TO GET
	MOV	R4,R5		;ALLOCATION BOUNDARY MUST BE MULTIPLE OF SIZE
	DEC	R5		;MAKE MASK TO CHECK FOR MULTIPLE OF SIZE
	CLR	R0		;NO PREFERRED START CLUSTER
10$:	CALL	GETCLU		;GET A REAL CLUSTER
	BCC	30$		;IF NO MORE THEN DIE
	CALL	RIB2CN		;CONVERT DCN TO PACK CLUSTER #
	BIT	R5,R3		;CHECK FOR BOUNDARY
	BEQ	20$		;YUP, ON BOUNDARY
	CALL	RETCLU		;NOPE, RETURN THE CLUSTER
	MOV	R3,R0		;SET PREFERRED TO LAST FOUND
	INC	R0		;BUT DON'T GET IT AGAIN
	BR	10$		;NOW TRY AGAIN

20$:	SEC			;INDICATE POSITIVE HAPPINESS FACTOR
	MOV	R2,TOS.R2(SP)	;RETURN RETRIEVAL POINTER IN R2
30$:	RETURN


.SBTTL	GET A CLUSTER (GETCLU)
;+
; GETCLU - ALLOCATE CONTIGUOUS SPACE ON DISK (ALIGNED ONLY ON PACK CLU)
;
; CALL:	R0 = PREFERRED STARTING PACK CLUSTER NUMBER ON DISK
;	R1 = NUMBER OF BLOCKS TO ALLOCATE
;	CALL	GETCLU
;
; BACK:	C=1	SPACE HAS BEEN ALLOCATED
;		R2 = DCN OF START OF ALLOCATED SPACE (RP)
;		SATBUF UPDATED TO MARK CLUSTERS IN USE
;	C=0	NO SPACE AVAILABLE (R2 UNCHANGED)
;-
GETCLU::REGSAV			;SAVE EM ALL
	CALL	FIXCLU		;CALCULATE # OF BITS (PACK CLUS) TO GET
	MOV	R0,R1		;# OF PACK CLUSTERS TO R1
	MOV	SATSYS+BITS,R5	;SET UPPER CN LIMIT FOR SYSTEM DISK
	MOV	(SP),R0		;RESTORE PREFERREED START PCN

; R0 = START CLU #, R1 = NUMBER OF CLUSTERS, R5 = HIGH LIMIT

	CLR	-(SP)		;CLEAR ROOM FOR COUNTER ON STACK
10$:	MOV	R1,(SP)		;RESET COUNTER TO # OF BITS NEEDED
	MOV	R0,R3		;SAVE CURRENT PACK CLUSTER NUMBER
20$:	CMP	R0,R5		;HAVE WE REACHED LIMIT?
	BHIS	60$		;IF SO, ALLOCATION FAILS
	CALL	FIXREG		;GET THE SAT POINTERS
	INC	R0		;BUMP TO NEXT CLUSTER IN SAT
	BITB	BITBYT(R2),SATBUF(R4) ;CLUSTER FREE?
	BNE	10$		;NO, START ALL OVER
	DEC	(SP)		;GOT EM ALL ?
	BNE	20$		;NOPE, CONTINUE

; CONTIGUOUS SPACE FOUND. DO THE ACTUAL ALLOCATION

	MOV	R3,R0		;START PCN OF STRING OF BITS FOUND
30$:	CALL	FIXREG		;GET THE SAT POINTERS AGAIN
	BISB	BITBYT(R2),SATBUF(R4);ALLOCATE A CLUSTER
	INC	R0		;BUMP TO NEXT CLUSTER IN SAT
	DEC	R1		;HAVE WE SET EM ALL YET ?
	BNE	30$		;NO, HANG IN THERE A WHILE LONGER
	MOV	CLURAT,R2	;GET CLUSTER RATIO FOR DISK
40$:	ASR	R2		;RETRIEVAL POINTER =
	BCS	50$		; PCN * (DCS/PCS)
	ASL	R3
	BR	40$

50$:	INC	R3		;  + 1
	MOV	R3,TOS.R2+2(SP)	;STORE DCN IN R2 ON STACK
	SEC			;INDICATE GOODNESS
60$:	INC	(SP)+		;DUMP STACK LEAVING CARRY BIT ALONE
	CALLRX	RESRPC		;RESTORE REGS & RETURN


.SBTTL	RETURN A CLUSTER (RETCLU)
;+
; RETCLU - RETURN CONTIGUOUS SPACE TO SAT AND DEALLOCATE
;
; CALL:	R1 = NUMBER OF BLOCKS BEING RETURNED
;	R2 = DCN (RP) OF START OF REGION
;
; BACK:	C=1	SUCCESSFUL DEALLOCATION
;	C=0	DIRECTORY ERROR: PART OF CLUSTER IS NOT IN THE SAT
;-
RETCLU::REGSCR			;SAVE REGS
	CALL	FIXCLU		;CALCULATE # OF BITS (PACK CLUS) TO RETURN
	MOV	R0,R1		;R1 = # OF PACK CLUSTERS
	CALL	RIB2CN		;CONVERT DCN TO PCN
	MOV	R3,R0		;R0 WILL STEP THROUGH THE CLUSTERS
	MOV	SATSYS+BITS,R5	;SET UPPER LIMIT ON CN'S
10$:	CMP	R0,R5		;REACHED LIMIT ?
	BHIS	20$		;YES, BAD DIRECTORY ERROR
	CALL	FIXREG		;SET THE SAT POINTERS
	BICB	BITBYT(R2),SATBUF(R4) ;FREE A CLUSTER IN THE SAT
	INC	R0		;BUMP CURRENT CLUSTER NUMBER
	SOB	R1,10$		;AND GRIND
	SEC			;INDICATE GOODNESS
20$:	RETURN


.SBTTL	ROUND UP BLOCK COUNT TO CLUSTER MULTIPLE (FIXCLU)
;+
; FIXCLU - ROUND UP BLOCK COUNT TO AN EVEN NUMBER OF PACK CLUSTERS
;
; CALL:	R1 = NUMBER OF BLOCKS
;	CALL	FIXCLU
;
; BACK:	R0 = NUMBER OF PACK CLUSTERS AT CURRENT PCS (ROUNDED UP)
;	R1 = NUMBER OF BLOCKS = R0*PCS
;-
FIXCLU::MOV	PCS,R0		;GET PCS IN R0 FOR DIVIDE
10$:	ASR	R0		;SHIFT PCS
	BCS	20$		;DONE DIVIDE
	;CLC
	ROR	R1		;# OF BITS = (CLUSTER SIZE + PCS -1)/PCS
	ADC	R1		;AND ROUND UP IF ANY REMAINDER
	BR	10$

20$:	MOV	R1,R0		;NUMBER OF PACK CLUS TO R0
	MOV	PCS,-(SP)	;COMPUTE NUMBER OF BLOCKS AGAIN IN R1
30$:	ASR	(SP)		;MULTIPLY BY PCS
	BCS	40$
	ASL	R1
	BR	30$

40$:	TST	(SP)+		;POP THE 0 WORD
	RETURN

.SBTTL	COMPUTE SAT POINTERS GIVEN PACK CLUSTER NUMBER (FIXREG)
;+
; FIXREG - COMPUTE SAT BYTE OFFSET AND BIT NUMBER FROM PCN
;
; CALL:	R0 = PACK CLUSTER NUMBER
;	CALL	FIXREG
;
; BACK:	R2 = BIT NUMBER (USED FOR INDEXING INTO BITBYT)
;	R4 = OFFSET INTO SAT
;-
FIXREG::MOV	R0,R2		;CURRENT CN TO R2
	MOV	R0,R4		;AND R4
	BIC	#177770,R2	;ONLY BYTE REMAINDER IN R2
	CLC
	ROR	R4		;BYTE NUMBER = BIT NUMBER / 8.
	ASR	R4		;
	ASR	R4		;
	RETURN


.SBTTL	PACK I, J, AND K INTO A LINK (PLK)
;+
; PLK - PACK DIRECTORY INFO (OFFSET IN BLOCK, BLOCK IN CLUSTER,
;	AND CLUSTER NUMBER) INTO A LINK
;
; CALL:	I = OFFSET OF ENTRY WITHIN DIRECTORY BLOCK (0 TO 740 STEP 20)
;	J = BLOCK NUMBER IN DIRECTORY CLUSTER (0 TO DIR CLUSTER SIZE)
;	K = DIRECTORY CLUSTER NUMBER (0 TO 6)
;	CALL	PLK
;
; BACK:	R3 = LINK
;-
PLK::	MOVB	J,R3		;BLOCK NUMBER TO LOW R3, CLEAR HI R3
	ASL	R3		;MAKE ROOM FOR 3 BITS FOR CLUSTER
	ASL	R3		;
	ASL	R3		;
	BISB	K,R3		;PACK IN THE CLUSTER NUMBER
	ASL	R3		;BLK + CLUSTER IN LO BYTE
	SWAB	R3		;NOW HIGH
	BIS	I,R3		;JAM IN OFFSET WITHIN BLOCK
	RETURN

GLOBAL	<I,J,K>


.SBTTL	COMPUTE DIRECTORY CLUSTER # AND BLOCK IN CLU FROM FBN (CJK)
;+
; CJK - COMPUTE DIRECTORY CLUSTER # AND BLOCK WITHIN CLUSTER FROM FIP BN
;
; CALL:	R2/R3 = FIP BLOCK NUMBER
;	FIBUF CONTAINS ANY DIRECTORY BLOCK (VALID CLUSTER MAP)
;	CALL	CJK
;
; BACK:	R0 = K = DIRECTORY CLUSTER NUMBER (0 TO 6)
;	R1 = J = BLOCK NUMBER WITHIN THAT CLUSTER
;
; ERRORS: IF SPECIFIED BLOCK IS NOT IN THE DIRECTORY:
;		"BAD [0,1] DIRECTORY"
;-
.ENABL	LSB

CJK::	MOV	R2,-(SP)	;SAVE CALLER'S R2 (MSB OF BLOCK #)
	MOV	R3,-(SP)	;AND R3		  (LSB OF BLOCK #)
	SUB	#1,R2		;R2,R3 = FBN - 1
	SBC	R3		;
	CLR	R0		;sign extend...				;001
	BISB	FIBMAP,R0	;GET DIRECTORY CLUSTER SIZE (FCS)	;001
	DEC 	R0		;R0 = FCS-1
	COM	R0		;MAKE IT A MASK
	MOV	R2,R1		;LSB OF BLOCK NUMBER INTO R1
	BIC	R0,R1		;R1 = BLOCK OFFSET WITHIN CLUSTER
	MOVB	R1,J		;(WHICH GETS STORED IN J)
	BIC	R1,R2		;NOW CLEAR THOSE BITS IN BLOCK NUMBER
	MOV	DCS,R0		;DEVICE CLUSTER SIZE (DCS)
10$:	ASR	R0		;COMPUTE DCN = (FBN-1)/DCS+1
	BCS	20$		;DONE DIVIDING BY DEVICE CLUSTER SIZE?
	ASR	R3		;NO, SHIFT BLOCK NUMBER
	ROR	R2		;
	BR	10$		;

20$:	ADD	#1,R2		;NOW WE HAVE RETRIEVAL POINTER IN R2
	MOV	#FIBENT,R0	;LOOK FOR THIS ENTRY IN MAP
30$:	CMP	R2,(R0)+	;GOT IT ?
	BEQ	40$		;YOU BETCHA
	CMP	R0,#FIBEND	;IF NOT KEEP LOOKING
	BLO	30$		;GOTTA BE HERE SOMEWHERE
	ERF	<"Bad [0,1] directory]">

40$:	SUB	#FIBENT+2,R0	;COMPUTE DIRECTORY CLUSTER NUMBER
	ASR	R0		;MAKE IT CLUSTER  (0-6)
	MOVB	R0,K		;SET CLUSTER NUMBER
	MOV	(SP)+,R3	;RESTORE ORIGINAL BLOCK # TO
	MOV	(SP)+,R2	;R2 AND R3
	RETURN

.DSABL	LSB

GLOBAL	<I,J,K,FIBEND>

;+									;002+
; SAA - Search GFD for account attributes
;
;	R0 = Type to get
;	R3 = Link to name entry for account
;
;	CALL	SAA
;
;	R2 =  Link previous to entry
;	R3 =  Link of entry
;	R5 -> Entry
;
;	C = 0	if entry found
;	C = 1	if entry not found (R3,R5 meaningless)
;-

SAA::	CALL	RDE		;Make sure we have the name block
10$:	MOV	R3,R2		;Save the previous link
	MOV	(R5),R3		;Pick up the link to next item
.ASSUME	ULNK EQ 0
	CALL	RDECHK		;Read it, checking
	BEQ	20$		;None left, exit in error
	CMPB	UATYP(R5),R0	;Does the type match?
	BNE	10$		;No, keep looking
	;CLC			;Indicate success (C=0 from CMPB)
	RETURN

20$:	SEC			;Indicate failure
	RETURN			;Done					;002-


.END
