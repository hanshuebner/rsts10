	.IF	DF	RSTS		;++RSTS V9.4
TITLE	ODTID,<OCTAL DEBUGGING TOOL - RSX-11M & RSTS/E>,06,03-SEP-87,SSS/KMF/KPH/WRM
	.IFTF				;++RSTS V9.4
;
; MIKE SMITH	3/24/73
;
; PREVIOUSLY MODIFIED BY:
;
;	H. LEV
;	J. HARPER
;	E. BAATZ
;	IVAN ZATKOVICH
;	CHRIS PETROVIC
;
; MODIFIED BY:
	.IFF				;++RSTS V9.4
.TITLE	ODTID, I & D SPACE OCTAL DEBUGGING TOOL -  FOR RSX-11
	.ENDC				;++RSTS V9.4


	.IF	DF O$$DFL	; BUILD FULL ODT?

	.IF	NDF	RSTS		;++RSTS V9.4

	.IF	DF R$$11M
	.IDENT	/M02.01/
	.IFF
	.IDENT	/D02.01/
	.ENDC

	.ENDC
	.IFF

	.IF	NDF	RSTS		;++RSTS V9.4

	.IF	DF R$$11M
	.IDENT	/MS02.01/
	.IFF
	.IDENT	/DS02.01/
	.ENDC

	.ENDC

	.IFTF


;
;		COPYRIGHT (c) 1982,1983 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD
;	 MASSACHUSETTS.  ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE  IS  FURNISHED  UNDER  A LICENSE AND MAY BE USED
; AND  COPIED  ONLY IN  ACCORDANCE WITH THE TERMS OF SUCH LICENSE
; AND WITH  THE INCLUSION  OF THE ABOVE  COPYRIGHT  NOTICE.  THIS
; SOFTWARE  OR ANY OTHER  COPIES  THEREOF, MAY NOT BE PROVIDED OR
; OTHERWISE MADE  AVAILABLE TO ANY OTHER PERSON.  NO TITLE TO AND
; OWNERSHIP OF THE SOFTWARE IS HEREBY TRANSFERRED.
;
; THE INFORMATION  IN THIS DOCUMENT IS SUBJECT  TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT  BY  DIGITAL
; EQUIPMENT CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF
; ITS SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.
;
;
; VERSION 02.01
;
; MIKE SMITH	3/24/73
;
; PREVIOUSLY MODIFIED BY:
;
;	H. LEV
;	J. HARPER
;	E. BAATZ
;	B. SCHREIBER
;
; MODIFIED BY:
;
;	IVAN ZATKOVICH 22-JUL-81
;
;	C.B. PETROVIC	17-FEB-82
;			CBP037	-	CHANGE ODTS' LUN ASSIGNMENT
;					GLOBALS TO RESIDE IN D-SPACE
;					RATHER THAN I-SPACE IN ORDER
;					TO FACILITATE PATCHING DURING
;					TKB PHASE 5 END-OF-SEGMENT
;					CLEANUPS.
;
;++RSTS V9 003 KMF	20-JAN-84	UPDATE FOR 8-BIT TERMINAL COMPATIBILITY
;++RSTS V9 004 KPH	04-Apr-84	Assemble ENAR$S and DSAR$S on RSTS

;
;	B. S. MCCARTHY	10-SEPTEMBER-1984
;
;		BM315 -- INTEGRATE CHANGE (ORIGINALLY FROM MULP) TO
;		CHANGE DECODE TO USE TRAP 0 INSTEAD OF IOT SO THAT ODT
;		CAN BE USED WITH FAST MAP.
;
;
;	L. M. Peterson	9-Sep-85
;
;		LMP032 -- Correct access to event flag
;
;++RSTS V9.4 005 WRM	22-APR-87	Merge with RSX-11 ver 2.01, Add FASTMAP
;++RSTS V9.5 006 WRM	20-AUG-87	Fix clobbered firqb from AST's
;
	.LIST	MEB		;LIST ALL BINARY EXPANSIONS
	.MCALL	DSAR$S,ENAR$S,GTSK$S,MVTS$S,CSM$

R0	=	%0	; REGISTER
R1	=	%1	;  NAMING
R2	=	%2	;   CONVENTIONS
R3	=	%3
R4	=	%4
R5	=	%5
SP	=	%6
PC	=	%7


;
; DEFINE BPT OPCODE
;
BPT	=	3		; BREAK POINT TRAP CODE


;USED IN LOCATING "JMP"'S AS OPPOSED TO "BR"'S

.MACRO	JUMP	A
	 JMP	A
.ENDM

;USED TO CALL RSX-11 FOR HELP

.MACRO	RSX11
	 EMT	377
.ENDM

;CAUSE ERROR RESPONSE, INTERNAL CODE SAVER

.MACRO	ERROR
	 EMT 0;JMP O.ERR
.ENDM

;CALL COMMAND DE-CODER, INTERNAL CODE SAVER

.MACRO	DECODE
	 TRAP 0;JMP O.DCD
.ENDM

	.SBTTL	USER STATE AREA AND DATA CONTROL

;SOME ODT TYPE DEFINITIONS (THESE ARE NOT PARAMETERS).

O.BKP	=16		;NUMBER OF BREAKPTS-1 X 2
O.RLR	=16		;NUMBER OF CORE RELOC. REGISTERS -1 X 2
O.TBT	=20		;T-BIT MASK, PROCESSOR STATUS


; EVENT FLAG FOR ODT TO WAIT ON WHEN DOING I/O
ODTEFN	=28.		;SOMETHING TO WAIT AROUND FOR

;
; DEFINE ODT STACK SIZE IF NOT DEFINED ALREADY
;
	.IF NDF	STKSIZ

STKSIZ	=	60		;USE 48. BYTES FOR STACK

	.ENDC

;DATA SPACE****************************************************

	.PSECT	$ODTDT,D


;SET UP THE REAL THING FINALLY

ORGODT	=	.		;DEFINE RELOCATABLE ZERO
ODTSTK	=	ORGODT+STKSIZ	;DEFINE BASE OF THE STACK
	.=ODTSTK		;IN THE BEGINNING


;THE ORDER OF THESE ITEMS IS INTENTIONAL, SEE REGISTER MAPPING SCHEME

INTBEG	=.	;STARTING ADDRESS OF INTERNAL REGISTERS

O.UR0:	0	;USER R0			$0
O.UR1:	0	;     R1			$1
O.UR2:	0	;     R2			$2
	0	;     R3			$3
	0	;     R4			$4
	0	;     R5			$5
O.USP:	0	;USER SP			$6
O.UPC:	0	;USER PC			$7
O.UST:	0	;USER PS			$S
O.DSW:	0	;USER $DSW			$W

	.IFT

O.ARG:	0	;ARGUMENT REGISTER		$A
O.MSK:	-1	;MASK				$M
O.LOW:	0	;LOW LIMIT			$L
O.HI:	0	;HIGH LIMIT			$H

	.IFTF

O.CNST:	O.ODT	;CONSTANT REGISTER		$C
O.QUAN:	0	;QUANTITY REGISTER		$Q
O.FORM:	0	;FORMAT REGISTER		$F
ENFLAG:	-1	;ENTRY FLAG			$X
.IF	DF,RSTS
O.CC:	0
.ENDC

	.SBTTL	BREAKPOINT, RELOCATION AND SST VECTOR TABLES

INTINX	=.		;STARTING ADDRESS OF INTERNAL TABLES

;BREAKPOINT CONTROL LISTS, AND EXTRA SLOT FOR SINGLE STEP

O.ADR1:		;ADDRESS OF THE BREAKPOINT	($0B-$7B)
	.WORD	O.TRTC,O.TRTC,O.TRTC,O.TRTC,O.TRTC,O.TRTC,O.TRTC,O.TRTC,O.TRTC

O.CT:		;PROCEED COUNT	($0G-$7G)
	.WORD	1,1,1,1,1,1,1,1,1

O.UIN:		;USER INSTRUCTION SAVE LOCATION	($0I-$7I)
	.WORD	BPT,BPT,BPT,BPT,BPT,BPT,BPT,BPT,BPT

;RELOCATION REGISTERS

O.RELT:		;RELOCATION TABLES	($0R-$7R)
	.WORD	-1,-1,-1,-1,-1,-1,-1,-1

;USER'S SST VECTOR ADDRESSES (SEE "RESSST" ROUTINE FOR REAL COPY)

SSTVEC:		;SST VECTORS FOR USER WHILE RUNNING ($0V-$7V)
	 +	V.ODDA		;0-ODD ADDRESS, OR HALT, VECTOR @4
	.IF	DF M$$MGE
	.IFT
	 +	V.SGMT		;1-SEGMENT FAULT
	.IFF
	+	0		; NO SEGMENT FAULT POSSIBLE
	.ENDC
SSTBPT:	 +	V.BPTI		;2-T-BIT OR BPT
	+	V.IOTX		;3-IOT
	 +	V.ILLI		;4-RESERVED OR ILLEGAL INSTRUCTION
	+	V.NEMT		;5-NONRSX EMT
	 +	0;V.TRAP	;6-TRAP
	+	V.FPPE		;7-PDP 11/40 FLOATING POINT

;USER'S STACK VALUES ON SST ENTRIES

SSTSTK:		;TOP STACK ITEMS ON SST ERRORS UPON ENTRY ($0E-$2E)
	.WORD	0,0,0

;LOGICAL UNIT BUCKETS TO USE FOR I/O

IOLUNS:		;LOGICAL UNIT SLOTS		($0D-$2D)
;	THESE NEXT TWO LOCATIONS ARE FILLED WITH THE CONTENTS
;	OF .ODTL1 AND .ODTL2 RESPECTIVELY. (IN I SPACE)
;	THOSE IN TURN WHERE FILLED BY TKB WHEN IT
;	SAW THE /DA SWITCH IN THE OUTPUT SIDE OF THE COMMAND STRING
;
.ODTL1::.BLKW	1		; PLUGGED BY TKB WITH LUN # FOR TI:		;CBP037
.ODTL2::.BLKW	1		; PLUGGED BY TKB WITH LUN # FOR CL:		;CBP037
L.UN1:	.WORD	0		; LUN FOR TTY
L.UN2:	.WORD	0		; LUN FOR LINE PRINTER
	.IF	NDF	RSTS		;++RSTS V9
ODTEVT:
	.ENDC				;++RSTS V9
	.WORD	ODTEFN		; EVENT FLAG FOR ODT

INTEND	=.-2	;END OF INTERNAL REGISTERS AND TABLES

GTSKBF:	.BLKW	16.		; GET TASK PARAMETER BUFFER

	.SBTTL	INTERNAL DIRTY DATA AREA

;WORDS AND ORDERED BYTES, ITEMS MUST BE KEPT FROM COMMAND TO COMMAND

O.CAD:	.WORD	0	;ADDRESS OF CURRENTLY OPEN REGISTER
O.DOT:	.WORD	0	;ADDRESS OF LAST EXPLICITLY OPENED CELL
O.BW:	.WORD	0	;LAST OPEN MODE 1=BYTE, 2=WORD
O.OPN:	.WORD	0	; LOCATION OPEN FLAG 0=NOT OPEN, NON-ZERO=OPEN
O.LAST:	.WORD	0	; 0= LAST SST NOT A BREAK POINT, 1=LAST SST WAS
D.ARGS:	.WORD	0	;SEMI COLON PUSH WORD
ENTRAN:	.WORD	0	;TRANSFER ADDRESS OF USER PROGRAM


;THE FOLLOWING ITEMS NEED NOT BE KEPT FROM COMMAND TO COMMAND
;THEIR ORDER IS INTENTIONAL SO KNOW THY MAKER!

O.OP:	.BYTE	0	;CURRENT ARITHMETIC OPERATOR
O.SMFD:	.BYTE	0	;SEMI-COLON COUNTER
O.EXP:	.WORD	0	;EXPRESSION BUCKET
ENPRFX	=	O.EXP	;ENTRY PREFIX TEMP STORE

;THE FOLLOWING ITEMS MUST BE KEPT FROM COMMAND TO COMMAND.

O.T:	.BYTE	0	;T BIT IN USE FLAG
O.P:	.BYTE	-1	;PROCEED ALLOW FLAG
O.S:	.BYTE	0	;SINGLE INSTRUCTION MODE, 0=NORMAL, >0=ENABLE
O.FM:	.BYTE	2	;OUTPUT FORMAT MODE, BYTE, WORD, ANSII, RAD50
O.OBW:	.BYTE	2	;OPEN CELL TYPE, 1=BYTE, 2=WORD
O.SEQ:	.BYTE	0	;CHANGE SEQUENCE INDICATIOR

	.EVEN

;USED FOR I AND D SPACE

O.ADMD:	.WORD	0,0,0,0,0,0,0,0		;BREAKPOINT MODES

O.CWD:	.WORD	0	;TEMP STORAGE FOR DATA
O.DPNT:	.WORD	0	;POINTER FOR O.CWD
ACC:	.WORD	0	;TEMP ACCESS MODE
INTFL:	.WORD	0	;ACCESS INTERNAL REGISTER FLAG
O.MD:	.BYTE	0	;MODE FLAG,  0=USER, 1=SUPERVISOR
O.SP:	.BYTE	0	;SPACE FLAG, 0=INTRUCTION, 2=DATA

	.EVEN
;
; THE FOLLOWING WORD IS SET BY INITIALIZATION TO SELECT THE
; CORRECT FORM OF RETURN FROM INTERRUPT FOR THE HARDWARE
; THAT ODT IS RUNNING ON.
;	RTT	IS USED FOR 11/03/34/35/40/45/50/55/70
;	RTI	IS USED FOR 11/04/05/10/15/20
;
O.RTN:	.WORD	0		; THE ADDRESS OF THE CORRECT
				; RETURN INSTRUCTION

;THE BELOW LOCATION IS USED IN BREAKPOINT PROCESSING AND IS DIRTY

O.TRTC:	BPT		;TRACE TRAP PROTOTYPE

;
;MISC TABELS (PUT HERE FOR I/D* CONVERSION)
;

LOOKER:	.WORD	0	;ADDRESS OF LOOKUP TABLE (USED BY LOOKUP)

;JUMP TABLE FOR WORD FORMAT OUTPUT

TYFORM:	+	O.CADB	;BYTE OCTAL - 0
	+	O.CADW	;WORD OCTAL - 2
	+	O.BANS	;BYTE ANSII - 4
	+	O.WANS	;WORD ANSII - 6
	+	O.RADF	;RADIX 50  - 10


;COEFFICENT TABLE, RADIX 50 CONVERT

RADCON:	.WORD	+1600.,+40.,+1.	;40.^2, 40.^1, 40.^0


;COPY OF THE VECTORS TO RESTORE WITH  (V COMMAND)

RESTBL:	+	V.ODDA		;0-ODD ADDRESS
	.IF	DF M$$MGE
	.IFT
	+	V.SGMT		;1-SEGMENT FAULT
	.IFF
	+	0		; NO SEGMENT TRAP POSSIBLE IN NON-MAPPED SYSTEM
	.ENDC
	+	V.BPTI		;2-BPT OR T-BIT
	+	V.IOTX		;3-IOT
	+	V.ILLI		;4-RESERVED OR ILLEGAL INSTRUCTION
	+	V.NEMT		;5-NON RSX-11 EMT
	+	V.TRAP		;6-TRAP
	+	V.FPPE		;7-PDP 11/40 FLOATING POINT EXCEPTION

	.IFTF


	.SBTTL	RSX-11 DPB'S AND INTERFACE DIRTY DATA

.IF	NDF,RSTS

;RSX-11 DIC DATA STUFF

DPBQIO:	.BYTE	01.,12.		;TYPE, WD CNT
DPBIOF:	.WORD	0		;FUNC (TTYRD,TTYWRT)
DPBLUN:	.WORD	0		;LUN (MUST BE TTY)
DPBEFN:	.BYTE	0,0		;EVENT NUM, PRIORITY = USER'S
	.WORD	IOSTAT		; I/O STATUS BLOCK ADDRESS
	.WORD	0		; AST'S
	.WORD	CHRBUF		;I/O BUFF ADDR
	.WORD	1		;BYTE COUNT
	.WORD	0		;CARRIAGE CONTROL CHARACTER

IOSTAT:	.BLKW	2		; I/O STATUS BLOCK

	.IFF			;++RSTS V9
O.IOSTS:.BLKW			;++RSTS V9	SAVE AREA FOR IOSTS
O.FQJOB:.BLKW			;++RSTS V9	SAVE AREA FOR FQJOB
O.XRB:	.BLKB	XRBSIZ		;++RSTS V9	SAVE AREA FOR XRB
	.IFTF			;++RSTS V9
CHRBUF:	.WORD	0		;I/O BUFFER
	.IFT			;++RSTS V9

;BEGIN PURE REGION OF RSX VERSION OF ODT *************************

;COMMANDS AND Q I/O SYMBOLS

IO.WLB	=000400		;WRITE LOGICAL BLOCK, VERY SHORT ONE
	.IF	DF	R$$11M
	.IFT
IO.RLB	=001010		;READ LOGICAL, PASS ALL (IF ITS IN SYSTEM)
	.IFF
IO.RLB	=001030		; READ LOGICAL, NO ECHO, PASS ALL
	.ENDC
	.ENDC		;++RSTS V9

;DPB'S FOR SETTING THE DE-BUGGING SST VECTORS

DPSSTU:	.BYTE	103.,03.	;SST IN USE WHILE USER RUNS
	.WORD	SSTVEC
	.WORD	8.

DPSSTO:	.BYTE	103.,03.	;SST IN USE WHILE ODT RUNS
	.WORD	SSTODT
	.WORD	8.

;ALL ODT TYPE ERRORS JUST GO TO "O.ERR" OR SOMEWHERE ELSE

SSTODT:	 +	O.ERR		;0-ODD ADDRESS
	 +	O.ERR		;1-SEGMENT FAULT
	 +	O.ERR		;2-BPT OR T-BIT ("MCR" CALL)
	 +	O.ERR		;3-IOT
	 +	O.ERR		;4-RESERVED OR ILLEGAL INSTRUCTION
	 +	O.ERR		;5-NON RSX EMT ("ERROR")
	 +	O.DCD		;6-TRAP ("DECODE")
	 +	O.ERR		;7-PDP 11/40 FLOATING POINT EXCEPTION

	.SBTTL	INTERNAL REGISTER NAME AND CONTROL TABLES

;NON-INDEXED REGISTER NAMES

NIXMAP:	.ASCII	/01234567/	;USER REGISTER NAMES FOR MAPPING

NIXREG:	.BYTE	'S	;O.UST	USER STATUS
	.BYTE	'W	;O.DSW	USER $DSW

	.IFT

	.BYTE	'A	;O.ARG	ARGUMENT
	.BYTE	'M	;O.MSK	MASK REGISTER
	.BYTE	'L	;O.LOW	LOW SCAN LIMIT
	.BYTE	'H	;O.HI	HIGH SCAN LIMIT

	.IFTF

	.BYTE	'C	;O.CNST	CONSTANT
	.BYTE	'Q	;O.QUAN	QUANTITY
	.BYTE	'F	;O.FORM	FORMAT CONTROL
	.BYTE	'X	;ENFLAG	ENTRY FLAG FIX CONTINIOUS DE-BUG
	.IF	DF,RSTS	;++RSTS V9
	.BYTE	'^	;++RSTS V9	O.CC	CTRL/C TRAP
	.ENDC		;++RSTS V9

	.BYTE	00	;END OF THIS LIST

;INDEXED REGISTER NAMES

INXREG:	.BYTE	'B	;O.ADR1	BKPT ADDRESSES
	.BYTE	'G	;O.CT	BKPT PROCEED COUNTS
	.BYTE	'I	;O.UIN	BKPT USER INSTRUCTIONS
	.BYTE	'R	;O.RELT	RELOCATION REGISTERS
	.BYTE	'V	;SSTVEC	USER'S SST TRAPPING VECTORS
	.BYTE	'E	;SSTSTK	SST STACK CONTENTS
	.BYTE	'D	;IOLUNS	LOGICAL UNITS FOR I/O

	.BYTE	00	;END OF THIS LIST

;INDEXED REGISTER TABLE BASES

	.EVEN
INXTBL:	.WORD	O.ADR1		;BKPT ADDRESS TABLE
	.WORD	O.CT		;BKPT PROCEED COUNTS
	.WORD	O.UIN		;BKPT'D INSTRUCTION
	.WORD	O.RELT		;RELOCATION TABLES
	.WORD	SSTVEC		;USER SST VECTOR TABLE
	.WORD	SSTSTK		;ERROR SST STACK VALUES
	.WORD	IOLUNS		;LOGICAL UNIT NUMBERS
	.WORD	INTEND+2	;END OF TABLE AREA FOR ADDRESS MAPPING

;CHARACTER CONVERSION LISTS.

ALTTAB:	.BYTE	033,175,176	;ALTERNATE ALT-MODE FORMS

	.BYTE	000		;END OF THIS LIST TOO

	.SBTTL	COMMAND NAME AND DISPATCH TABLES

COMTAB:		;ADDRESS OF THE CHARACTER TABLE

;OPEN REGISTER COMMANDS (ORDER AND POSITION CRITICAL)

	.BYTE	'\,'/,'','",'%

;CLOSE REGISTER COMMANDS

	.BYTE	015,012,'^,'_,'@,'>,'<

;SPECIAL FORMS


	.IFT

	.BYTE	'$,'=,'C,'Q,'.

	.IFF

	.BYTE	'$

	.IFTF


;OPERATORS (ORDER OF -+* IS CRITCAL)


	.IFT

	.BYTE	';,'-,'+,'*,',

	.IFF

	.BYTE	';,'-,'+,',

	.IFTF


;COMMANDS


	.IFT

	.ASCII	/BDEFGIKLNOPRSUVWXZ/

	.IFF

	.ASCII	/BGPRSX/

	.IFTF


	.BYTE	00	;******* END OF THE LIST *******

;THE DISPATCH TABLE, ORDERED ON ABOVE TABLE

	.EVEN ;THIS CAN HAPPEN TO YOU!!!!

;OPEN REGISTER COMMANDS

COMDIS:	+	OCBYTE	;\	OPEN OCTAL BYTE
	+	OCWORD	;/	OPEN OCTAL WORD
	+	ANBYTE	;'	OPEN ANSII BYTE
	+	ANWORD	;"	OPEN ANSII WORD
	+	MODULO	;%	OPEN RADIX 50 WORD

;CLOSE REGISTER COMMANDS

	+	CLCRET	;<CR>	CLOSE, NO SUCESSIVE OPEN
	+	CLLNFD	;<LF>	CLOSE, OPEN NEXT
	+	CLUPAR	;^	CLOSE, OPEN PREVIOUS
	+	CLBACK	;_	CLOSE, OPEN PC RELATIVE MODE
	+	CLATSG	;@	CLOSE, OPEN INDIRECT
	+	CLGRTH	;>	CLOSE, OPEN PC OFFSET AS BRANCH
	+	CLLSTH	;<	CLOSE, OPEN OLD SEQUENCE

;SPECIAL FORMS

	+	O.REGT	;$	INTERNAL REGISTER REFERENCE

	.IFT

	+	EQUALS	;=	PRINT LEFT SIDE IN OCTAL
	+	CHRCEE	;C	CONSTANT REGISTER CONTENTS
	+	CHRQUE	;Q	QUANTITY REGISTER CONTENTS
	+	CHRDOT	;.	LAST OPENED LOCATION'S ADDRESS

	.IFTF


;OPERATORS

	+	O.SEMI	;;	MULTIPLE ARGUMENT DELIMITER
	+	O.MINS	;-	SUBTRACTION
	+	O.PLUS	;+	ADDITION

	.IFT

	+	O.STAR	;*	MULTIPLY BY 50

	.IFTF

	+	O.COMM	;,	RELOCATION COMPUTE

;COMMANDS


	.IFT

	+	O.SEBK	;B	SET / CLEAR BREAKPOINTS
	+	O.DSP	;D	SET TO D-SPACE
	+	O.EFFA	;E	EFFECTIVE ADDRESS SEARCH
	+	O.FILL	;F	MEMORY FILL
	+	O.GOTO	;G	GO TO USER'S DATA
	+	O.ISP	;I	SET TO I-SPACE
	+	O.KILO	;K	KOMPUTE AND TYPE RELOCATION DATA
	+	O.LIST	;L	LIST MEMORY ON SPECIFIED DEVICE
	+	O.NOTW	;N	NOT WORD SEARCH
	+	O.OFST	;O	TYPE PC RELATIVE OFFSETS
	+	O.PROC	;P	PROCEED FROM BREAKPOINT
	+	O.RELO	;R	SET / RESET RELOCATION REGISTERS
	+	O.SNGL	;S	SET / RESET SINGLE STEP MODE
	+	O.UMD	;U	SWITCH TO USER MODE
	+	O.SSTR	;V	RESTORE ORIGINAL SST VECTORS
	+	O.WSCH	;W	MEMORY WORD SEARCH
	+	O.EXIT	;X	EXIT TASK TO RSX-11
	+	O.ZMD	;Z	SWITCH TO SUPERVISOR MODE

	.IFF

	.WORD	O.SEBK		; B SET BREAK POINTS
	.WORD	O.GOTO		; G GOTO
	.WORD	O.PROC		; P PROCEED
	.WORD	O.RELO		; R RELOCATION REGISTER SET
	.WORD	O.SNGL		; S SINGLE STEP
	.WORD	O.EXIT		; X EXIT TO EXECUTIVE

	.IFTF


;INSTRUCTION SPACE ****************************************************

	.PSECT	$ODTCD,I

	.SBTTL	MAIN ENTRY POINT TO ODT FOR RSX-11

;START ODT FROM SCRATCH, CLEAN SLATE

O.ODT:	CLR	O.UST		;SAVE STATUS AND RUN AT ENTRY STATUS
	CLR	O.LAST		; SET LAST SST WAS NOT A BPT

	MOV	.ODTL1,L.UN1	; COPY LUN FOR TI:				;CBP037
	MOV	.ODTL2,L.UN2	; AND THE LUN FOR CL:				;CBP037
	TST	SP		;SEE IF THERE IS A STACK TO USE			;**-5
	BNE	10$		;YES SO USE IT
	MOV	#ODTSTK,SP	;SET UP ODT'S FOR A WHILE
10$:	TST	ENFLAG		;SEE WHAT KIND OF ENTRY TO USE
	BMI	12$		;IF MINUS FRESH LOAD, SET TRANSFER
	MOV	ENTRAN,R0	;ELSE USE OLD TRANSFER FORM FIRST 1
12$:	MOV	R0,ENTRAN	;REFRESH THE TRANSFER ADDRESS
	.IF	NDF,RSTS	;++RSTS V9
	MOV	IOLUNS+0,DPBLUN	;RESET TERMINAL LUN
	.ENDC			;++RSTS V9
	MOV	R0,O.UPC	;SET UP USER'S TRANSFER ADDRESS
	JSR	R0,O.SVR	;SAVE REGISTERS (MAINLY SP),SET SST'S


;TYPE OUT AN ANNOUNCEMENT THAT WE ARE HERE

18$:	TST	ENFLAG		;AVOID TYPE OUT IN CONTINIOUS MOOD
	BGT	20$		;MINUS IS CONTINIOUS MOOD
	JSR	PC,O.CRLF	;RESET CONSOLE
	MOV	#"OD,R0		;TYPE MY NAME
	JSR	PC,O.TYPE	;TWO CHARACTERS
	MOV	#"T:,R0		;ALL OF IT
	JSR	PC,O.TYPE
	TST	ENFLAG		;SKIP NAME OUTPUT ON SECOND TIME
	BPL	20$		;AS REGISTERS ARE GARBAGE
	 .if	DF,RSTS		;++RSTS V9.5
	JSR	PC,SETXRB	;Protect FIRQB from being clobbered ;++RSTS V9.5
	 .iftf			;++RSTS V9.5
	GTSK$S	#GTSKBF		; GET TASK PARAMETERS
	 .ift			;++RSTS V9.5
	JSR	PC,@(SP)+	;Restore firqb			;++RSTS V9.5
	 .endc			;++RSTS V9.5
	BCS	20$		; ERROR
	MOV	GTSKBF+G.TSTN,R0 ; GET TASK NAME
	MOV	R0,O.UR1	;PUT CORRECT TASK NAME IN USER REGS
	JSR	PC,TYRADX	; PRINT 1ST THREE CHARACTERS
	MOV	GTSKBF+G.TSTN+2,R0 ;
	MOV	R0,O.UR2	;
	JSR	PC,TYRADX	; PRINT LAST 3 CHARACTERS

;SEE WHAT TO DO ABOUT BREAKS AND START-UP ETC.

;
; SELECT CORRECT RETURN FROM INTERRUPT
;
20$:	CLR	O.RTN		; ZERO RETURN INSTRUCTION ADDRESS
	CLR	-(SP)		; ZERO PS
	MOV	#30$,-(SP)	; RETURN TO 30$ IF RTT EXISTS
	RTT			; TRY IT
30$:	MOV	#O.RTT,O.RTN	; GOT BACK, SO SET TO USE RTT
O.ODT1:	TST	ENFLAG		;CHECK FOR FIRST TIME ENTRY
	BPL	25$		;DO NOT CLEAR BREAKS AND RELOC
	CLR	ENFLAG		;FIRST IS FIRST ONLY ONCE
	JSR	PC,O.RUAL	;RESET RELOC AND UNIT
	MOV	#O.TRTC,R0	;BREAKS MAY BE LEFT IF USER EXITS
	CLR	R4
22$:	JSR	PC,SETBRK	;CLEAR BREAKPOINT TABLES
	BCC	22$
25$:	CLRB	O.S		;NO SINGLE STEP
	MOVB	#-1,O.P		;NO ALLOW PROCEED
	JSR	PC,O.REM	;GET RID OF ANY BREAKPOINTS
	TST	ENFLAG		;SEE HOW TO DO THIS
	BGT	30$		;CONTINUOUS
	DECODE			;GO ASK FOR A COMMAND
30$:	CLR	R2		;GO TO THE USER'S PROGRAM
	JMP	O.GOTO		;AND SEE WHAT HAPPENS

	.SBTTL	COMMAND PROCESSORS, SECTION ONE ( $ B R K A Q . )

.SBTTL "$,<ALT-MODE>" PROCESSOR - INTERNAL REGISTER MAPPER

;SYNTAX--
;$L		DELIVER INTERNAL ADDRESS OF L
;$NL		DELIVER INTERNAL ADDRESS OF L+2N
;$N		DELIVER INTERNAL ADDRESS OF USER REGISTER N

;SEE MAPPING TABLES, RANGE OF N IS 0-7

O.REGT:	JSR	PC,GETNUM	;GET AN OCTAL NUMBER
	JSR	PC,O.RTST	;CHECK FOR ERROR
	BCS	O.ERR0		;MPY R4 X 2
	TST	R2		;SEE IF ANYTHING TYPED
	BNE	10$		;IF SO IS INDEXED OR USER REGISTER

	MOV	#NIXREG,LOOKER	;GET ADDRESS OF LOOK TABLE
	JSR	PC,LOOKUP	;SEE IF ITS THERE

	BCS	12$		;NON-INDEXED TURNS INTO A COMMAND
	MOV	R1,R4		;PLACE IN LIST IS INTERNAL ORDER
	ADD	#O.UST,R4	;GET ADDRESS IN R4, GOTTA READ CHAR
	BR	20$
10$:
	MOV	#INXREG,LOOKER	;GET ADDRESS OF INDEX REG. TABLE
	JSR	PC,LOOKUP	;SEE IF ITS THERE

	BCC	15$		;WAS TRULY INDEXED
12$:	CMP	#7+7,R4		;INTERNAL USER REGISTER RANGE CHECK
	BLO	O.ERR0
	ADD	#O.UR0,R4	;SET ACCESS TO R0-R7 OF THE USER
	BR	25$		;AVOID READING OF COMMAND
15$:	ADD	INXTBL(R1),R4	;COMPUTE ADDRESS TO INDEXED TABLE
20$:	JSR	PC,O.GET	;GET THE ASSUMED TERMINATOR
25$:	INC	R2		;SHOW THEM THAT R4 GOT VALID DATA
	INC	INTFL		;INDICATE INTERNAL REGISTER ACCESS
	JUMP	O.CLGL		;RE-USE CHARACTER, R2 IS NON-ZERO

.SBTTL "B" PROCESSOR - SET AND REMOVE BREAKPOINTS

;SYNTAX--
;B			CLEAR ALL BREAKPOINTS
;NB			CLEAR BKPT N
;A;B			SET BKPT AT A, USE FIRST FREE  BKPT
;A;NB			SET BKPT N AT A

;DEPENDS MIGHTILY UPON LOCATION "O.TRTC" CONTAINING A TRAP INST.
;AND THAT A FREE BKPT CONTAINS THE ADDRESS "O.TRTC".

O.SEBK:	ASL	R4		;MPY R4 X2, JUST IN CASE ALL IS GO
	MOV	#O.TRTC,R0	;SET MAGIC VALUE IN R0, JUST IN CASE
	TST	R3		;CHECK FOR THE REAL CASE
	BEQ	O.REMB		;REMOVAL CASES, CLEAR THEM UP
	BIT	#1,R5		;LOOK AT ADDRESS
	BNE	O.ERR		;THAT'S ODD ?
	TST	R2		;SEE IF I GET TO PICK IT OR NOT
	BNE	15$		;OR NOT, DISAPPOINTMENT
10$:	CMP	R0,O.ADR1(R4)	;LOOK FOR LOCATION WITH FREE ADDRESS
	BEQ	15$		;A HIT
	TST	(R4)+		;KEEP AT FOR A LONG WHILE
	BR	10$		;LOOOOOOOOP
15$:	MOV	R5,R0		;R0 HAS ADDRESS OF BREAKPOINT
	BR	O.RE02		;GO TUCK IT IN

;REMOVE SOME BREAKPOINTS

O.REMB:	TST	R2		;SEE IF ONE OR ALL
	BEQ	O.RALL		;ALL
O.RE02:	JSR	PC,SETBRK	;SET THE ONE SET UP TO SET
	BCC	O.DCD		;IT HAPPENED
O.ERR0:	ERROR			;SOME THING WENT WRONG

;REMOVE ALL BREAKPOINTS  (N.B. CALLED BY THE INIT CODE)

O.RALL:	MOV	#O.TRTC,R0	;MAGIC IN R0
	CLR	R4		;R4 IS ZERO
10$:	JSR	PC,SETBRK	;SET THEM TILL
	BCC	10$		;THEY GET OUTTA
	DECODE			;HAND!!!!

.SBTTL "R" PROCESSOR - RELOCATION REGISTER PROCESSING

;DETERMINE IF CLEAR OR SET

O.RELO:	TSTB	O.SMFD		;SEMI-COLON ABSENT MEANS CLEAR
	BEQ	10$		;CLEAR DISPATCH, OR FALL TO SETTING

;FORMS HERE--
; A;NR			SET RELOC(N) TO A
;ABSENT A OR N DEFAULTS TO 0

	JSR	PC,O.RTST	;PROTECTION EDITING
	BCS	O.ERR		;ILLEGAL REGISTER NUMBER ?
	MOV	R5,O.RELT(R4)	;SET THE APPROPRIATE REGISTER
	DECODE			;GO GET NEXT COMMAND

;FORMS HERE--
;R			RESET ALL TO -1 FOR RELOC(0-7)
;NR			RESET ONLY RELOC(N)

10$:	TST	R2		;SEE IF NR OR JUST R
	BEQ	15$		;CLEAR ALL
	JSR	PC,O.RUCL	;CLEAR THE ONE IN R4
	BCS	O.ERR		;ERROR, INVALID REGISTER ?
	DECODE			;NEXT COMMAND
15$:	JSR	PC,O.RUAL	;DO THEM ALL
	DECODE			;OFF AND ON

.SBTTL "K" PROCESSOR - COMPUTE AND PRINT RELOCATION

	.IFT


;SYNTAX--
;AK				TYPE RELOCATION DEAL FROM DOT TO A
;L;AK				TYPE RELOCATION DEAL FROM L TO A

;IF A IS NULL THE THE OLD BEST FIT RULE APPLIES
;TYPES	=N,DDDDDD	WHERE N IS THE RELOCATION REGISTER
;				AND D-D IS THE RELOCATION BIAS

O.KILO:	TST	R2		;SEE WHO PICKS THE REGISTER
	BNE	10$
	TST	R3		; ADDRESS SPECIFIED?
	BNE	5$		; YES
	MOV	O.CAD,R4	; NO, GET CURRENT ADDRESS
	BR	7$		;
5$:	MOV	R5,R4		; GET ADDRESS SPECIFIED ON COMMAND
7$:	JSR	PC,O.LOCA	; GET CLOSEST RELOCATION REGISTER
	TST	R0		; DID WE FIND A RELOCATION REGISTER?
	BMI	O.ERR		;CAN'T FIND ONE THATS GOOD
	MOV	R0,R4		;R4 HAS OUR PICK
10$:	BIC	#177770,R4	;EDIT REGISTER
	MOV	#" =,R0		;TYPE CUE
	JSR	PC,O.TYPE
	MOVB	R4,R0		;TYPE REGISTER & A ,
	ADD	#"0,,R0
	JSR	PC,O.TYPE
	ASL	R4		;GO GET IT AS TABLE INDEX
	TST	R3		;SEE WHO TYPED THE ADDRESS
	BNE	15$
	MOV	O.CAD,R5	;THAT CAD!
15$:	SUB	O.RELT(R4),R5
	MOV	R5,R0		;BIAS COMPUTE
	JSR	PC,O.CADW	;PRINT AS WORD
	DECODE

.SBTTL "A-Q-." PROCESSORS - SPECIAL VALUES

;MERELY SUBSTITUTE THE VALUE IN R4 WITH THE CONTENTS OF THE SPECIFIED
;REGISTER.

CHRQUE:	MOV	O.QUAN,R4	;LAST QUANTITY PRINTED
	BR	CHR001
CHRCEE:	MOV	O.CNST,R4	;CONSTANT REGISTER
	BR	CHR001
CHRDOT:	MOV	O.CAD,R4	;CURRENT LOCATION
	;BR	CHR001

CHR001:	INC	R2		;ALLOW AS R4 IS REAL
	JSR	PC,O.GET	;GET NEXT CHARACTER AND ASSUME
	BR	O.CLGL		;IT IS A TERMINATOR

	.IFTF


	.SBTTL	COMMAND DE-CODER AND MAIN LOOP OF ODT

; COMMAND DECODER - ODT

;  ALL REGISTERS MAY BE USED (R0-R5),

;ERROR ENTRY, TYPE FLAG AND GO DO COMMAND

O.ERR:	MOV	#ODTSTK,SP	;FORCE A NEW STACK
	.IF	NDF,RSTS	;++RSTS V9
	MOV	IOLUNS+0,DPBLUN	;FORCE THE CONSOLE
	.IFF			;++RSTS V9
	JSR	PC,SETXRB	;++RSTS V9	SAVE XRB,IOSTS AND FQJOB
	.TTRST			;++RSTS V9	CANCEL AND ^O IN EFECT
	JSR	PC,@(SP)+	;++RSTS V9	RESTORE XRB,IOSTS AND FQJOB
	.ENDC			;++RSTS V9
	TST	O.RTN		; ARE WE LOOKING FOR CORRECT RTI?
	BNE	10$		; NO
	MOV	#O.RTI,O.RTN	; YES, NO RTT(CAUSED TRAP) SO SET RTI
	JMP	O.ODT1		; CONTINUE INITIALIZATION
10$:	MOV	#" ?,R0		;  ? TO BE TYPED
	JSR	PC,O.TYPE	; OUTPUT ?

;DECODE FROM THE TOP, CLOSE ALL AND DO CR/LF/_

O.DCD:	MOV	#ODTSTK,SP	;SET THE STACK FOR SANITY
	.IF	NDF,RSTS	;++RSTS V9
	MOV	IOLUNS+0,DPBLUN	;FORCE THE CONSOLE
	.IFTF			;++RSTS V9
	JSR	PC,O.CRLF	;TYPE  <CR><LF>
	.IFF			;++RSTS V9
O.DCD1:	MOV	#ODTSTK,SP	;++RSTS V9	RESET STACK
	JSR	PC,SETXRB	;++RSTS V9	SAVE XRB, IOSTS AND FQJOB
	.TTRST			;++RSTS V9	CANCEL ANY ^O IN EFFECT
	.TTECH			;++RSTS V9	ENABLE ECHO
	JSR	PC,@(SP)+	;++RSTS V9	RESTORE XRB, IOSTS AND FQJOB
	.ENDC			;++RSTS V9
	CLR	O.OPN		;SET NO LOCATION OPEN
	MOVB	#'_,R0		;_ TO GO NEXT
	JSR	PC,O.FTYP
	.IF	DF,RSTS		;++RSTS V9
	CMP	CCTRAP,#O.DCD	;++RSTS V9	CHECK THE CTRL/C TRAP
	BEQ	O.NEWC		;++RSTS V9	ALREADY SET UP
	TST	CCTRAP		;++RSTS V9	CLEARED BY RSX RTS?
	BEQ	10$		;++RSTS V9	GUESS SO
	MOV	CCTRAP,O.CC	;++RSTS V9	SAVE THE CTRL/C TRAP
10$:	MOV	#O.DCD,CCTRAP	;++RSTS V9	SET OUR OWN TRAP
	.ENDC			;++RSTS V9

;MAINTAIN OPENED LOCATION, RE-INIT INPUT

O.NEWC:	CLRB	O.SMFD		;CLEAR SEMI-COLON FLAG/COUNT
	CLR	R3		;ZERO SECONDARY ARGUMENT FLAG
	CLR	R5		;AND ARGUMENT

;NEW SUB-EXPRESSION ENTRY

O.NEWE:	CLRB	O.OP		;CLEAR OPERATOR FOUND
	CLR	O.EXP		;SET ZERO IN EXPRESSION SO FAR LOCATION

;GET NUMBER AND THEN SCAN FOR COMMAND

O.NEWN:	JSR	PC,GETNUM	;GET AN OCTAL NUMBER AND TERMINATOR

;NON-OCTAL CHAR TYPED WHAT ARE WE TO DO?

O.CLGL:
	MOV	#COMTAB,LOOKER	;GET ADDRESS OF COMMAND TABLE
	JSR	PC,LOOKUP	;GO SEE IF IT IS REAL
	BCS	O.ERR		;EASY ENOUGH IF NOT REAL
	TST	R2		;IF NOTHING TYPE BOTHER NOT
	BEQ	O.CL01		;WITH THE EXPRESSION
	JSR	PC,EXPCOM	;COMPUTE EXPRESSION
O.CL01:	JMP	@COMDIS(R1)	;GO TO PROPER ROUTINE

;FOR THE BENEFIT ALL REGISTERS ARE AS FOLLOWS

;R0	LAST CHARACTER TYPED, THE COMMAND ITSELF!
;R1	TABLE INDEX TO COMMAND ADDRESSES, IT IS USED.
;R2,R4	FIRST ARGUMENT, IF R2<>0 THEN R4 IS DATA
;R3,R5	SECOND ARGUMENT, IF R3<>0 THEN R5 IS DATA

	.SBTTL	EXPRESSION SETUP COMMANDS ( ; + - * , )

;SEMI-COLON PROCESSOR

O.SEMI:	INCB	O.SMFD		;COUNT SEMI-COLON
	CMPB	#2,O.SMFD	;PUSH CONTENTS INTO MULTI
	BNE	O.SEM1		;SEMI COLON ARG LIST
	MOV	R5,D.ARGS
O.SEM1:	MOV	R2,R3		;PUSH R2 AND R4 INTO
	MOV	R4,R5		;R3 AND R5 (FLAG AND CONTENTS)
	BR	O.NEWE		;CONTINUE SCANNER

;ADDITION SETUP

O.PLUS:	CLRB	O.OP		;OP IS 0 FOR +
	BR	O.CO00

;SUBTRACT SET UP

O.MINS:	MOVB	#2,O.OP

	.IFT

	BR	O.CO00

;MULTIPLY BY 50 AND ADD

O.STAR:	MOVB	#-2,O.OP	;OP IS -2 FOR *


	.IFTF

O.CO00:	CLR	R4		;R4 IS RESET
	BR	O.NEWN

;MEMORY RELOCATION CHECK

O.COMM:	ASL	R4		;ALL NEED IT X 2
	CMP	R4,#O.RLR	;SEE IF REGISTER IS OUT OF RANGE
	BGT	O.ERR
	MOV	O.RELT(R4),O.EXP	;COMPUTE REAL CORE ADDRESS
	BR	O.PLUS

	.SBTTL	OPEN AND CLOSE PROCESSORS

.SBTTL "\-/-'-"-%-:" PROCESSOR - OPEN AND TYPE CONTENT COMMANDS

;SYNTAX--
;NC				OPEN LOC N IN MODE C, SET MODE FOR NEXT
;C				TYPE LAST OPENED LOC IN MODE C

OCWORD:		;OCTAL WORD -		R1=2
ANWORD:		;ANSII WORD -		R1=6
MODULO:		;RADIX 50 WORD -	R1=10

;OPEN WORD MODE ENTRY, R1 CONTAINS FORMAT INDEX

	MOV	#2,R0		;SET BYTE FLAG TO WORD FLAG
	BR	OPE004		;GO TO IT ACE HOLE

OCBYTE:		;OCTAL BYTE -		R1=0
ANBYTE:		;ANSII BYTE -		R1=4

OPE001:	MOV	#1,R0		;SET WORD FLAG TO BYTE FLAG

OPE004:	TST	R2		;IF NO VALUE TYPED NO MODE SET
	BEQ	10$
	MOV	R0,O.BW		;SET MODE AND FORMAT FLAGS
	MOVB	R0,O.OBW	;SET THE LATER USE MODE
	MOVB	R1,O.FM		;SET THE MODE FLAG FOR SOOTH
	MOV	R4,O.CAD	;SET ADDRESS FOR EXPLICIT OPEN
	MOV	R4,O.DOT	;RESET RETURN PTR.
10$:	CMP	#1,R0		;CHECK ON BYTE MODE
	BEQ	15$		;NOT BYTE MODE
	BIT	#1,O.CAD	;SEE IF ADDRESS IS ODD
	BEQ	15$		;ALL IS GOOD
	CLR	R1		;THEY GET BYTE MODE ONLY
	BR	OPE001
15$:	MOV	R1,-(SP)	;SAVE FORMAT MAINLY
	JSR	PC,GETCAD	;GET THE DATA
	MOV	(SP)+,R1	;GET FORMAT
	JSR	PC,@TYFORM(R1)	;PRINT DATA IN PROPER FORMAT
	BR	O.NEWC		;GO GETTA NEW COMMAND TO DO

.SBTTL "<CR>-<LF>->-<-^-_-@" PROCESSOR - CLOSE AND OPEN REGISTERS

;CARRIAGE RETURN

CLCRET:	JSR	PC,PUTCAD	;CLOSE LOCATION
	BR	O.DCD		;RETURN TO DECODER

;LESS THAN, BACK TO MAIN STREAM

CLLSTH:	INCB	O.SEQ	;SET FLAG TO LATER RESTORE CAD

;LINE FEED, NEXT ONE DOWN

CLLNFD:	JSR	PC,PUTCAD	;CLOSE PRESENT CELL
	TSTB	O.SEQ		;SHOULD CAD BE RESTORED?
	BEQ	O.OP5		;BRANCH IF NOT
	MOV	O.DOT,O.CAD	;RESTORE PREVIOUS SEQUENCE
	CLRB	O.SEQ		;RESET FLAG; NO LONGER NEEDED
	BR	O.OP2A		;
O.OP5:	ADD	O.BW,O.CAD	;GENERATE NEW ADDRESS
O.OP2:	MOV	O.CAD,O.DOT	;INITIALIZE DOT
O.OP2A:	JSR	PC,O.CRLF	;<CR><LF>
	MOV	O.CAD,R0	;NUMBER TO TYPE
	JSR	PC,O.RORA	; CHECK FORMAT
	MOVB	O.FM,R0		;SET FORMAT
	ASR	R0		;SPLIT R0 IN HALF
	MOVB	COMTAB(R0),R0	;SET SUFFIX CHARACTER
	JSR	PC,O.FTYP	;PRINT IT
	MOV	O.CAD,R4	;SET UP THE DATA
	CLR	R2		; SET TO USE O.CAD ADDRESS
	CLRB	O.OP		;THIS IS BECUZE
	CLR	O.EXP
	JUMP	O.CLGL		;R0 HAS TERMIN, R4- DATA, R2= FLAG

;UP ARROW, NEXT ONE UP

CLUPAR:	JSR	PC,PUTCAD
	SUB	O.BW,O.CAD	;GENERATE NEW ADDRESS
	BR	O.OP2		;GO DO THE REST

;BACK ARROW, PC RELATIVE COMPUTE

CLBACK:	JSR	PC,O.TCLS	;TEST WORD MODE AND CLOSE
	ADD	@R2,R2		;COMPUTE
	INC	R2
	INC	R2		;   NEW ADDRESS
O.PCS:	MOV	R2,O.CAD	;UPDATE CAD
	BR	O.OP2A		;GO FINISH UP

;AT SIGN, ABSOLUTE OR INDIRECT CHAIN

CLATSG:	JSR	PC,O.TCLS	;TEST WORD MODE AND CLOSE
	MOV	@R2,R2		;GET ABSOLUTE ADDRESS
	BR	O.PCS

;GREATER THAN, PC OFFSET BRANCH ADDRESS

CLGRTH:	JSR	PC,O.TCLS	;TEST AND CLOSE
	MOVB	@R2,R1		;COMPUTE NEW ADDRESS, EXTEND SIGN
	ASL	R1		;R2=2(@R2)
	INC	R1		;   +2
	INC	R1
	ADD	R1,R2		;   +PC
	BR	O.PCS

;HANDY DANDY TO DO SOME LEG WORK

O.TCLS:	JSR	PC,PUTCAD	;CLOSE CURRENT CELL
	CMP	#2,O.BW		;ONLY WORD MODE ALLOWED
	BNE	O.ERR1		;BRANCH IF ERROR
	MOV	O.CAD,R2	;CURRENT ADDRESS IN R2
	RTS	PC

	.SBTTL	I,D,U,Z - COMMANDS, SWITCH ACCESS SPACE

; SYNTAX
;	I	ACCESS INSTRUCTION SPACE
;	D	ACCESS DATA SPACE
;	U	SWITCH TO USER MODE
;	Z	SWITCH TO SUPERVISOR MODE

O.DSP:	MOVB	#2,O.SP		;SET FLAG TO D-SPACE
	BR	SW99

O.ISP:	MOVB	#0,O.SP		;SET FLAG TO I-SPACE
	BR	SW99

O.UMD:	MOVB	#0,O.MD		;SWITCH TO USER MODE
	BR 	SW99

O.ZMD:	MOVB	#1,O.MD		;SWITCH TO SUPERVISOR MODE
SW99:	JMP	O.DCD


	.SBTTL	COMMAND PROCESSORS, SECTION TWO ( O = G S P )

	.IFT


.SBTTL "O" PROCESSOR - COMPUTE AND PRINT OFFSETS

;SYNTAX--
;AO				TYPE OFFSETS FROM . TO A
;L;AO				TYPE OFFSETS FROM L TO A

;TYPES	_PPPPPP >DDDDDD			WHERE P-P IS PC RELATIVE
;					AND D-D IS BRANCH OFFSET

O.OFST:	TST	R3		;HOW ABOUT A VALUE OTHER
	BNE	10$		;THAN CAD
	MOV	O.CAD,R5	;RELUCTANTLY
10$:	SUB	R5,R4
	SUB	#2,R4		;NO TRICKS, ODD AND NON-EXIST THINGS
	MOV	#" _,R0		;TYPE PC RELATIVE CUE
	JSR	PC,O.TYPE
	MOV	R4,R0
	MOV	R4,-(SP)	;GOOD IDEA TO SAVE THIS
	JSR	PC,O.CADW	;TYPE VALUE + BLANK
	MOVB	#'>,R0		;TYPE OFFSET BRANCH CUE
	JSR	PC,O.FTYP
	MOV	(SP)+,R0
	ASR	R0		;DIVIDE
O.OF09:	JSR	PC,O.CADW	;16 BITS SO YOU CAN SEE HOW FAR OFF
	JMP	O.NEWC		; GET NEXT COMMAND

.SBTTL "=" PROCESSOR - PRINT LEFT SIDE EXPRESSION ON RIGHT SIDE

EQUALS:	MOV	R4,R0		;PROPER PRIOR PLANNING PREVENTS
	BR	O.OF09		;PSSS POOR PERFORMANCE

	.IFTF


;JUST ANOTHER ERROR CALL

O.ERR1:	ERROR

.SBTTL "G" PROCESSOR - GO TO PROGRAM COMMAND

;SYNTAX--
;LG			START PROGRAM AT LOCATION L
;G			START PROGRAM AT CURRENT PC

O.GOTO:	TST	R2		;SEE IF SPECIFIC ADDRESS
	BEQ	10$		;NO
	MOV	R4,O.UPC	;SET THE PC
10$:	CLRB	O.S		;NO SINGLE INSTRUCTIONS
	MOVB	#O.BKP+3,O.P	;GOTTA BREAK TO PROCEED
O.TBIT:	CLRB	O.T		;CLEAR T-BIT FLAGS
	BIS	#O.TBT,O.UST	;BOTH
	TSTB	O.S		;SEE IF WE NEED A T-BIT BIT
	BNE	O.GRTT		;NO GO ON
	BIC	#O.TBT,O.UST	;SET THE TEE BIT
	JSR	PC,O.RSB	;RESTORE BREAKPOINTS
O.GRTT:	JSR	PC,O.RSR	;RESTORE USER REGISTERS
	MOV	O.UST,-(SP)	;	AND STATUS
	MOV	O.UPC,-(SP)	;	AND PC
	TST	O.LAST		; SST LAST A BPT?
	BEQ	10$		;IF EQ NO
	DEC	O.LAST		; YES, ZERO FLAG
	TST	GTSKBF+2	;AT V.BPTI, WERE AST'S ALREADY DISABLED?
	BMI	10$		; YES, DON'T REENABLE THEM
	 .if	DF,RSTS		;++RSTS V9.5
	MOV	R0,-(SP)	;save user R0 from setxrb clobber  ;++RSTS V9.5
	JSR	PC,SETXRB	;Protect FIRQB from being clobbered ;++RSTS V9.5
	 .iftf			;++RSTS V9.5
	ENAR$S			; NO, REENABLE ASTS
	 .ift			;++RSTS V9.5
	JSR	PC,@(SP)+	;Restore firqb			;++RSTS V9.5
	MOV	(SP)+,R0	;restore R0 after setxrb	;++RSTS V9.5
	 .iftf			;++RSTS V9.5
10$:	MOV	O.DSW,$DSW	;RESTORE USER'S DSW
	 .ift			;++RSTS V9.5
	MOV	O.CC,CCTRAP	;++RSTS 6B-02	RESTORE CTRL/C TRAP
	BNE	12$		;++RSTS V9	AND THERE IS ONE
	MOV	#V.CC,CCTRAP	;++RSTS V9	ELSE USE OURS
12$:				;++RSTS V9	RETURN TO USER
	.ENDC			;++RSTS V9
	BIT	#140000,2(SP)	; ARE WE RETURNING TO USER MODE ?
	BGT	20$		; IF GT NO, SUPERVISOR MODE
	JMP	@O.RTN		;RETURN TO USER
20$:	CLR	-(SP)		; PUSH ADDRESS OF SUPERVISOR MODE
				; ENTRY VECTOR
	CSM$	(SP)+		; AND ENTER SUPERVISOR MODE

O.RTI:	RTI			;FOR 11/04/05/10/15/20

O.RTT:	RTT			; BACK TO USER


.SBTTL "S" PROCESSOR - SINGLE STEP PROCEED COMMAND

;SYNTAX--
;NS				EXECUTE N INSTRUCTIONS AND THEN STOP
;S				EXECUTE ONE INSTRUCTION

O.SNGL:	MOVB	#O.BKP+2,R0	;FAKE THE BREAK
	MOVB	R0,O.S		;SET THE FLAG FOR S.I. MODE
	BR	O.PR01		;FAKE A PROCEED IN S.I. MOOD

.SBTTL "P" PROCESSOR - PROCEED FROM BREAKPOINT COMMAND

;SYNTAX--
;NP				PROCEED THRU THIS BREAKPOINT N TIMES
;P				ASSUME N=1

O.PROC:	CLRB	O.S		;SET FAST MODE
	MOVB	O.P,R0		;GET NUMBER OF BREAK
	BMI	O.ERR1		;THERE WASN'T ONE SO FAR ?
O.PR01:	TST	R2		;SEE IF VALUE IN R4 VIA R2
	BNE	10$		;SEE IF AND WHAT SETTING FOR COUNT
	MOV	#1,R4		;INIT IT TO ONE FOR A START
10$:	MOV	R4,O.CT(R0)	;SET USER'S COUNT
O.C990:	CMPB	O.P,#O.BKP	;SEE IF A REAL ONE OR A FAKE
	BGT	O.TBIT		;BRANCH IF FAKE
	TSTB	O.S		;SEE IF SINGLE INSTRUCTION MODE
	BNE	O.TBIT		;IF SO EXIT NOW
	INCB	O.T		;SET T-BIT FLAG
	BIS	#O.TBT,O.UST	;SET T-BIT
	BR	O.GRTT

	.SBTTL	SST INTERRUPT ROUTINES, COMMON SERVICE

;COMMON INTERRUPT SERVICE AND DISPATCHER

V.INTR:	MOV	(SP)+,O.UPC	;SET THE USER PC VALUE
	MOV	(SP)+,O.UST	;AND HIS ENTRY STATUS
	JSR	R0,O.SVR	;SAVE REGISTERS 0-6

;TRY AND FIND OUT WHAT TO DO

	TSTB	O.P		;SEE IF CONTROLLED BREAKPOINT
	BNE	10$		;NOT DUE TO A PLANNED INTERRUPT
	TSTB	O.T		;IS A BPT OR T-BIT, SEE IF A PROCEED
	BNE	O.TBIT		;COMMAND IS BEING DONE, GO FINISH IT
	TSTB	O.S		;NO REMOVAL OF BREAKS ON S.I. MODE
	BNE	12$		;SKIP NEXT TWO WORDS
10$:	JSR	PC,O.REM	;REMOVE BREAKPOINTS
12$:	MOV	O.UPC,R5	;GET A COPY OF THE PC AT INTERRUPT
	TSTB	O.P		;BREAKPOINT OR T-BIT CHECK
	BNE	30$		;DEFINITELY NOT A BREAKPOINT
	MOVB	O.S,R4		;SEE IF SINGLE STEPPING
	BNE	22$		;AND PRETEND

;AT THIS POINT IT MAY BE DUE TO USER'S T-BIT OR A BPT

	MOVB	#O.BKP+2,O.P	;SET ALLOW TO THE 8'TH ONE
	SUB	#2,R5		;ADJUST BACKWARDS TO INSTRUCTION
	MOV	#MV.FUI,R4	;ASSUME USER I SPACE
	TST	O.UST		;TRAP OCCUR IN USER MODE
	BMI	13$		;IF MI WAS USER MODE
	MOV	#MV.FSI,R4	;SUPER I SPACE
13$:	 .if	DF,RSTS		;++RSTS V9.5
	JSR	PC,SETXRB	;Protect FIRQB from being clobbered ;++RSTS V9.5
	 .iftf			;++RSTS V9.5
	MVTS$S	R4,R5,#O.CWD	;GET INSTRUCTION BACK
	 .ift			;++RSTS V9.5
	JSR	PC,@(SP)+	;Restore firqb			;++RSTS V9.5
	 .endc			;++RSTS V9.5
	BCC	14$		; CC MEANS NO ERRORS
	MOV	(R5),O.CWD	;ELSE DO REGULAR MOVE
14$:	CMP	O.CWD,O.TRTC	;WAS IT A BPT INSTR ?
	BEQ	30$		;IT WAS A NON-BREAK BPT
	MOV	#O.BKP,R4	;SET ADDRESS OF LEGIT BREAKS
15$:	CMP	R5,O.ADR1(R4)	;LOOK IT UP IN THE TABLE
	BEQ	20$		;FOUND THE NASTY LITTLE BUGGER
	SUB	#2,R4		;KEEP AT IT
	BGE	15$		;UNLESS NO MORE
	MOV	#"TE,R4		;NOT THERE, MUST BE USER'S T-BIT
	TST	(R5)+		;RESET PC TO MAKE IT RIGHT
	BR	26$		;LABOR
20$:	MOV	R5,O.UPC	;BACK-UP PC FOR BREAKPOINT
22$:	MOVB	R4,O.P		;BREAKPOINT IS A REAL ONE
	DEC	O.CT(R4)	;CHECK OUT THE PROCEED COUNT
	BNE	O.C990		;LABOR ON A MIS-CONCEPTION
	INC	O.CT(R4)	;RESET PROCEED COUNT
	ASR	R4		;OCTAL TO UN-BIASED ASCII
	ADD	#"0B,R4		;BIAS TO ASCII
26$:	MOV	R4,ENPRFX	;SET THE PREFIX UP

;COMMON TYPE ROUTINE FOR SST VECTORS USED UP

	.IF	NDF,RSTS	;++RSTS V9
30$:	JSR	PC,O.CRLF	;CARRIAGE FEED AND LINE RETURN
	.IFF			;++RSTS V9
30$:	JSR	PC,SETXRB	;++RSTS V9	SAVE XRB, IOSTS AND FQJOB
	.TTRST			;++RSTS V9	CANCEL ANY ^O IN EFFECT
	JSR	PC,@(SP)+	;++RSTS V9	RESTORE XRB, IOSTS AND FQJOB
	JSR	PC,O.CRLF	;++RSTS V9	CARRIAGE RETURN LINE FEED
	.ENDC			;++RSTS V9
	MOV	ENPRFX,R0	;THE PREFIX
	JSR	PC,O.TYPE
	MOV	#':,R0		;THE MIDDLE OF THE ENTRY CLUE
	JSR	PC,O.FTYP
	MOV	R5,R0		;TYPE ADDRESS OF INTERRUPT
	JSR	PC,O.RORA	;AND THE REST OF THE ENTRY
	DECODE

	.IF	DF	RSTS		;++RSTS V9
GLOBAL	<MV.FUI,MV.FSI>
	.ENDC				;++RSTS V9

.SBTTL	SST INTERRUPT VECTOR ENTRY POINTS

	.IF	DF M$$MGE

;SEGMENT FAULT			- V1 - "MP" - NO PROCEED

;	SP+	12,10,6	REAL DATA, PS, PC
;		4,2,0	SR0,SR2,SR1

V.SGMT:	MOV	(SP)+,SSTSTK+4	;SR1 TO $2E
	MOV	(SP)+,SSTSTK+2	;SR2 TO $1E
	MOV	(SP)+,SSTSTK+0	;SR0 TO $0E
	MOV	#"MP,ENPRFX	;ENTRY PREFIX

	.ENDC

V.NIXP:	MOVB	#-1,O.P		;NO PROCEED
	BR	V.INTR		;COMMON INTERRUPT

;ODD ADDRESS			- V0 - "OD" - NO PROCEED
;BPT OR T-BIT			- V2 - "BE" - SPECIAL CASES
;IOT				- V3 - "IO" - PROCEED
;RESERVED OR ILLEGAL		- V4 - "IL" - NO PROCEED
;PDP 11/40 FLOATING POINT	- V7 - "FP" - PROCEED

;	SP+	4,2,0	LIVE DATA, PS, PC

V.ODDA:	MOV	#"OD,ENPRFX	;"OD:" FOR ODD ONE
	BR	V.NIXP		;NIX ON PROCEED

V.BPTI:	MOV	$DSW,-(SP)	; SAVE USER'S DSW
	 .if	DF,RSTS		;++RSTS V9.5
	MOV	R0,-(SP)	;save user R0 from setxrb clobber  ;++RSTS V9.5
	JSR	PC,SETXRB	;Protect FIRQB from being clobbered ;++RSTS V9.5
	 .iftf			;++RSTS V9.5
	DSAR$S			; DISABLE AST'S
	 .ift			;++RSTS V9.5
	JSR	PC,@(SP)+	;Restore firqb			;++RSTS V9.5
	MOV	(SP)+,R0	;restore R0 after setxrb	;++RSTS V9.5
	 .endc			;++RSTS V9.5
	MOV	$DSW,GTSKBF+2	;SAVE STATUS OF AST'S
	MOV	(SP)+,$DSW	;RESTORE USER'S $DSW
	INC	O.LAST		; SET LAST SST WAS A BPT
	MOV	#"BE,ENPRFX	;"BE:" FOR MAYBE A BAD ENTRY
	CLRB	O.P		;ALLOW PROCEED DEAL
	JMP	V.INTR		;SPECIAL NUMBER FOR THIS ONE

V.IOTX:	MOV	#"IO,ENPRFX	;"IO:" FOR IOTEE
	BR	V.ALOP		;ALLOW PROCEED

V.ILLI:	MOV	#"IL,ENPRFX	;"IL:" FOR ILL INSTRUCTION
	BR	V.NIXP		;NO GO

V.FPPE:	MOV	#"FP,ENPRFX	;"FP:" FOR 11/40 FLOATING POINT
	BR	V.ALOP		;ALLOW PROCEED

;NON RSX EMT			- V5 - "EM" - PROCEED
;TRAP				- V6 - "TR" - PROCEED

;	SP+	6,4,2	HONEST DATA, PS, PC
;		0	LO BYTE X 2 INTO $0E

V.NEMT:	MOV	#"EM,ENPRFX	;"EM:" FOR EMTEE
	BR	V.V700

V.TRAP:	MOV	#"TR,ENPRFX	;"TR:" FOR TRAPPED
V.V700:	MOV	(SP)+,SSTSTK+0	;SET UP $0E
	.IF	DF,RSTS		;++RSTS V9
	BR	V.ALOP		;++RSTS V9
V.CC:	MOV	#"CC,ENPRFX	;++RSTS V9	"CC:" FOR CTRL/C
	MOV	#V.CC,CCTRAP	;++RSTS V9	AND RE-ENABLE CTRL/C TRAP
	.ENDC			;++RSTS V9
V.ALOP:	MOVB	#O.BKP+2,O.P	;ALLOW PROCEED
	JMP	V.INTR		;PROCESS IT COMMONLY

	.SBTTL	COMMAND PROCESSORS, SECTION THREE ( L V X W N E F )

	.IFT


.SBTTL "L" PROCESSOR - LIST MEMORY ON THE SPECIFIED DEVICE

;SYNTAX--
; D;S;FL		WHERE	D IS DEV, <> OR 0 = CONSOLE, 1 = LPT
;				S IS START ADDRESS, SETS $L IF THERE
;				F IS STOP ADDRESS, SETS $H IF THERE

O.LIST:	TST	R2		;SET UPPER AND LOWER LIMITS
	BEQ	10$		;IF SPECIFIED TO DO SO
	MOV	R4,O.HI
10$:	TST	R3		;DO THE LOW ONE
	BEQ	15$
	MOV	R5,O.LOW
15$:	CMPB	#2,O.SMFD	;SEE IF AN EXTRA ARGUMENT
	.IF	NDF,RSTS	;++RSTS V9
	BNE	17$		;USE THE CONSOLE
	TST	D.ARGS		;LOOK AT THE ARGUMENT
	BEQ	17$		;DO NOT ARGUE
	MOV	IOLUNS+2,DPBLUN	;SET THE LPT UP
	MOV	(PC)+,R0	;FEED THE HUNGRY LINE PRINTER
	.BYTE	014,014		;A COUPLE OF FORMS
	JSR	PC,O.FTYP	;ALL THE WAY
	.ENDC			;++RSTS V9
17$:	JSR	PC,SARSET	;SET UP THE LIMITS TO START
	TST	-(SP)		;MAKE A HOLE IN THE STACK
20$:	CLR	(SP)		;NEW LINE UP
	JSR	PC,SNAGIT	;ACCESS DEVICE FOR DATA
	JSR	PC,SPRINT	;PRINT ADDRESS AND FIRST ITEM
25$:	JSR	PC,SNAGIT	;GET MORE DATA
	JSR	PC,DPRINT	;JUST PRINT THE DATA
	INC	(SP)		;COUNT THE DATA
	CMP	#7,(SP)		;CHECK THE COUNT
	BNE	25$		;JUST LIKE THEY TOLD YOU AT THE
	BR	20$		;FAMOUS PROGRAMMERS SCHOOL

.SBTTL "V" PROCESSOR - RESTORE USER SST VECTORS

;SYNTAX--
; V			WHERE IT AIN'T GOT BUT ONE THING TO DO

O.SSTR:	JSR	PC,RESSST	;REST
	DECODE

;COMMON RESTORE THEM ROUTINE

RESSST:	MOV	#10,R0		;TEN VECTORS
	MOV	#RESTBL,R1	;CLEAN COPY
	MOV	#SSTVEC,R2	;DIRTY COPY
10$:	MOV	(R1)+,(R2)+	;CLEAN TO DIRTY
	DEC	R0		; DONE?
	BNE	10$		; NO, LOOP
	RTS	PC

.SBTTL "X" PROCESSOR - EXIT THE WORKS TO RSX-11

;SYNTAX--
; X

O.EXIT:	JSR	PC,O.CRLF	;SAY GOOD BYE IN OUR OWN WAY
	JSR	PC,O.DET	;DETACH THE TERMINAL, PLEASE
	MOV	(PC)+,-(SP)	;VERY SIMPLE, THIS ONE
	.BYTE	51.,01.		;DPB FOR EXIT TASK
	RSX11
	ERROR

.SBTTL "W" PROCESSOR - MASKED EQUAL WORD SEARCH

	.IFT


;SYNTAX--
;M;AW				SET $M TO M, SET $A TO A, DO SEARCH
;AW				SET $A TO A, DO SEARCH
;W				USE $L, $H, $M, $A TO SEARCH. PRINT HITS

O.WSCH:	JSR	PC,SARGUS	;SET UP $A, $M AND R5
10$:	JSR	PC,SNAGIT	;R5 IS MEMORY INDEX, CHECK FOR IT
	BNE	10$		;NOT EQUAL IS NOT THE OBJECTIVE
	JSR	PC,SPRINT	;PRINT LOCATION AND VALUE
	BR	10$		;MOVE ON

.SBTTL "N" PROCESSOR - MASKED NOT EQUAL WORD SEARCH

;SYNTAX--
;N				COMMAND IS "N", FORMS AS ARE FOR "W"

O.NOTW:	JSR	PC,SARGUS
10$:	JSR	PC,SNAGIT
	BEQ	10$		;THE ONLY DIFFERENCE
	JSR	PC,SPRINT
	BR	10$

.SBTTL "E" PROCESSOR - MASKED EFFECTIVE ADDRESS

;SYNTAX--
;E		COMMAND IS "E", FORMS ARE AS ABOVE IN "W" AND "N"

O.EFFA:	JSR	PC,SARGUS	;SET IT ALL UP PLEASE
10$:	JSR	PC,SNAGIT	;GET THE DATA VIA R5
	BEQ	15$		;SAME ABSOLUTE ADDRESS FOUND
	MOV	R5,R0		;DO THE PC REL
	JSR	PC,SRCHEF	;GO SEE IF MASKED SAME
	BEQ	15$		;SAME PC RELATIVE ADDRESS
	MOVB	R5,R0		;DISPLACEMENT INTO R1, SIGN EXTEND
	ASL	R0		;CARRY IS CLEAR
	JSR	PC,SRCHEF	;CHECK IT
	BNE	10$		;SAME BRANCH DISPLACE IN FALL THRU
15$:	JSR	PC,SPRINT
	BR	10$

.SBTTL "F" COMMAND - FILL MEMORY WORDS

;AF			SET ARG REGISTER, FILL WITH $A FROM $L TO $H

O.FILL:	CLR	R3		;NO MASK IS TO BE SET
	JSR	PC,SARGUS	;SET UP ARG AND R5
10$:	JSR	PC,SNAGIT	;GET LOC IN R5
	MOV	SP,R2		;PRETEND DATA IS HERE
	MOV	O.ARG,R4	;THIS IS WHY
	MOVB	O.OBW,O.BW	;OPEN THE ITEM
	JSR	PC,PUTCAD	;PUT THE DATA
	BR	10$		;GO TILL BROKEN

	.IFTF


	.SBTTL	UTILITIES - SAVE AND RESTORE USER DATA.

;SAVE USER'S $DSW AND R0-R6.  SET UP ODT'S STACK	JSR R0,O.SVR
;AND SST VECTOR.

O.SVR:	MOV	$DSW,O.DSW	;SAVE USER'S $DSW
	MOV	(SP)+,GTSKBF	;PICK UP R0 FROM USER STACK AND SAVE
	MOV	SP,O.USP	;SAVE USER STACK ADDRESS
	MOV	#O.USP,SP	;SET TO INTERNAL STACK
	MOV	R5,-(SP)	;SAVE
	MOV	R4,-(SP)	; REGISTERS
	MOV	R3,-(SP)	;5
	MOV	R2,-(SP)	; THRU
	MOV	R1,-(SP)	;     1
	MOV	GTSKBF,-(SP)	;SAVE R0 IN PROPER PLACE
	MOV	(SP),-(SP)	;PREPARE FOR RTS R0

	MOV	#DPSSTO,-(SP)	;ADDRESS OF DPB
	RSX11			; GO SET SST VECTOR FOR ODT

	JSR	PC,O.ATT	;ATTACH THE TERMINAL
	RTS	R0

;RESTORE REGISTERS R0-R6, SET UP USER'S SST	JSR PC,O.RSR

O.RSR:	MOV	#V.BPTI,SSTBPT	;USER CAN'T SET THAT ONE
	JSR	PC,O.DET	;DETACH THE TERMINAL

	MOV	#DPSSTU,-(SP)	;ADDRESS OF DPB
	RSX11			; SET THE USER'S SST VECTORS

	MOV	(SP)+,GTSKBF	;SAVE RETURN ADDRESS
	MOV	(SP)+,R0	;RESTORE R0
	MOV	(SP)+,R1	;RESTORE
	MOV	(SP)+,R2	; REGISTERS
	MOV	(SP)+,R3	;  1
	MOV	(SP)+,R4	;  THRU
	MOV	(SP)+,R5	;    5
	MOV	(SP)+,SP	;POINT AT USER'S STACK
	JMP	@GTSKBF		;RETURN

;RESTORE BREAKPOINTS 7-0			JSR PC,O.RSB

O.RSB:	MOV	#O.BKP,R4	;RESTORE ALL BREAKPOINTS

10$:	MOV	#O.ADR1,R1	;GET START OF BREAK. ADDRESS TABLE
	ADD	R4,R1		;ADD THE OFFSET
	MOV	(R1),R1		;GET THE ADDRESS IN THE TABLE
	MOV	#O.UIN,R2	;START OF SAVED CONTENTS TABLE
	ADD	R4,R2		;PLUS OFFSET
	MOV	#0,R0		;INDICATE A GET OPERATION
	JSR	PC,BRMV		;SAVE INTRUCTION BEFORE PUTTING BREAK.

	MOV	O.TRTC,R2	;THIS IS OUR BREAKPOINT INSTR.
	MOV	#4,R0		;INDICATE A PUT OPERATION
	JSR	PC,BRMV		;SET THE BREAKPOINT

	SUB	#2,R4		;DE CRE MEN T LOOOOP COUNTER
	BGE	10$		;RE-LOOP UNTIL DONE
	RTS	PC		;  THEN QUIT

;REMOVE BREAKPOINTS 0-7, OPPOSITE ORDER!!	JSR PC,O.REM

O.REM:	CLR	R4		;REMOVE ALL START WITH 0

10$:	MOV	#O.ADR1,R1	;GET START OF BREAK. ADDRESS TABLE
	ADD	R4,R1		;ADD OFFSET
	MOV	(R1),R1		;THIS IS OUR BREAK. ADDRESS
	MOV	O.UIN(R4),R2	;THIS IS THE REMOVED INTRUCTION
	MOV	#4,R0		;INDICATE A PUT OPERATION
	JSR	PC,BRMV		;RESTORE THE OLD INSTRUCTION

	TST	(R4)+		;BUMP BUMP
	CMP	#O.BKP,R4	;ARE WE DONE?
	BHIS	10$		;   NO, THEN LOOP
	RTS	PC		;   YES, THEN SPLIT

	.SBTTL	UTILITIES - COMMAND SUPPORT ROUTINES

;TEST FOR VALID RELOCATION REGISTER IN R4

O.RTST:	TST	R4
	BMI	O.RTS9		;LOW IS NO GOOD
	CMP	R4,#O.RLR/2	;GET A GOOD NUMBER FOR A REGISTER
	BHI	O.RTS9		;NOT TOO GOOD, QUESTION IT
	ASL	R4
O.RTS8:	CLC
	RTS	PC
O.RTS9:	SEC
	RTS	PC

;RESET RELOCATION BASE AND UNIT REGISTER

O.RUCL:	JSR	PC,O.RTST	;TEST REGISTER TYPE
	BCS	O.RU99		;BAD REGISTER, JUST GO
	MOV	#-1,O.RELT(R4)	;R4 IS INTEGER X2
	ASR	R4		;R4 BACK TO ST INTEGER
O.RU99:	RTS	PC

;CLEAR ALL RELOC AND UNIT REGISTERS

O.RUAL:	CLR	R4		;START WITH 0
10$:	JSR	PC,O.RUCL	;DO THIS ONE ONLY AT A TIME
	BCS	O.RU99		;SAME AS RTS PC
	INC	R4		;NEXT ONE AT A TIME
	BR	10$

;RESET BREAKPOINT VIA VALUE IN R4 AND R0

SETBRK:	CMP	#O.BKP,R4	;SEE IF LEGAL REFERENCE
	BLO	O.RTS9		;NO GO SIGNAL ON SPLIT
	MOV	R0,-(SP)	;SAVE R0
	MOV	R0,O.ADR1(R4)	;SET THE ADDRESS

	MOVB	O.MD,O.ADMD(R4)	;SAVE THE MODE OF THE BREAKPOINT
	MOV	R0,R1		; AND THE ADDRESS
	MOV	#O.UIN,R2	;GOOD INSTRUCTION SAVED IN TABLE
	ADD	R4,R2		; AT THIS OFFSET
	MOV	#0,R0		;INDICATE GET OPERATION
	JSR	PC,BRMV		;SAVE IT

	MOV	#1,O.CT(R4)	;RESET PROCEED COUNT TO 1
	TST	(R4)+
	MOV	(SP)+,R0
	BR	O.RTS8		;GOOD SPLIT

;SNAG MEMORY LOCATION AND CHECK FOR =	JSR PC,SNAGIT

	.IFT


;NEEDS--
;O.CAD		POINTS TO MEMORY WORD (APPROXIMATELY THAT IS)
;R0,R5		CONTAINS REAL WORD UPON EXIT TO "SRCHEK"

;FALLS THRU TO "SRCHEK" FOR THE NITTY GRITTY

SNAGIT:	MOVB	O.OBW,R0	;SET THE INCREMENT
	ADD	R0,O.CAD	;INCREMENT AND NOW
	CMP	O.CAD,O.HI	;SEE IF MORE TO DO
	BLOS	10$		;IF NOT DO NOT
	DECODE			;GO RESET STACK AND NO NEXT COMMAND
10$:	JSR	PC,GETCAD	;ACCESS METHOD
	MOV	R0,R5		;MAKE A COPY FOR LATER

;MASKED SEARCH CHECKER				JSR PC,SRCHEK

;NEEDS--
;R0		HAS OBJECT UNDER TEST
;SEES IF R0 UNDER MASK IS SAME AS ARGUMENT UNDER MASK

;RETURNS--
;CODES SET FOR	BEQ GOOD FOR SAME, R0=0
;		BNE GOOD FOR NOT SAME, R0<>0

SRCHEK:	MOV	R0,R2		;MAKA COPY
	MOV	O.ARG,R1	;DE ARGUMENT TO COMPARE AGAINST
	BIC	R1,R0		; (NOT A) AND O = X
	BIC	R2,R1		; (NOT O) AND A = Y
	BIS	R0,R1		; X IOR Y = Z
	MOV	O.MSK,R0
	COM	R0
	BIC	R0,R1		;(NOT (NOT M)) AND Z = R1
	RTS	PC		;BACK TO NEXT ONE

;FINISH EFFECTIVE ADDRESS COMPUTE AND CHECK IT, R0 HAS THE ADDRESS

SRCHEF:	ADD	#2,R0		;TWO CAUSE THE PC GETS TWO TOO
	ADD	O.CAD,R0	;RELOCATION PLEASE
	BR	SRCHEK		;DO THE LOGICAL COMPARE

;SET UP SEARCH ARGUMENTS			JSR PC,SARGUS
;JUST SET UP LIMIT				JSR PC,SARSET

;SETS UP--
;O.ARG IF R4 IS VALID
;O.MSK IF R5 IS VALID
;O.CAD,O.OBW	USED TO GET THE ADDRESS TO START OUT WITH

SARGUS:	TST	R2
	BEQ	10$
	MOV	R4,O.ARG	;SET THE SEARCH ARGUMENT
10$:	TST	R3
	BEQ	SARSET
	MOV	R5,O.MSK
SARSET:	MOV	O.LOW,R5	;SET THE START OF START
	MOVB	O.OBW,R0	;NO SUCHA THING AS A "SUBB"
	SUB	R0,R5
	MOV	R5,O.CAD
	RTS	PC

;SEARCH HIT PRINT			JSR PC,SPRINT

;O.CAD POINTS TO THE LOC TO BE PRINTED
;R5 CONTAINS THE CONTENTS OF THE LOCATION TO BE PRINTED

SPRINT:	JSR	PC,O.CRLF
	MOV	O.CAD,R0	;THE LOCATION
	JSR	PC,O.RORA	;THE MODE
	MOVB	O.FM,R0		;PICK UP OLD CURENT MODE
	ASR	R0		;HALVES
	MOVB	COMTAB(R0),R0	;AH HA
	JSR	PC,O.FTYP	;TYPE THE MODE DESIGNATOR

;DATA PRINT ROUTINE			JSR PC,DPRINT

;PRINTS DATA IN R5 IN CURRENT MODE

DPRINT:	MOVB	O.FM,R1		;SET THE MODE
	MOV	R5,R0		;THIS IS THE POOR DATA
	MOV	R5,-(SP)	;SAVE THE DATA
	JSR	PC,@TYFORM(R1)	;DO THAT __ TO THE POOR DATA
	MOV	(SP)+,R5	;RESTORE THE DATA
	RTS	PC		;RESTORE THE PC

	.IFTF


;EXPRESSION COMPUTATION ROUTINE		JSR PC,EXPCOM

;NEEDS--
;O.OP			THE OPERATION (-2=*, 0=+, *=2)
;O.EXP			THE LEFT SIDE
;R4			THE RIGHT SIDE

;SETS UP--
;O.OP			BACK TO 0 FOR ADD
;O.EXP,R4		ALL SO FAR

EXPCOM:	TSTB	O.OP		;SEE WHAT'S UP CHUCK

	.IFT

	BMI	20$		;

	.IFTF

	BEQ	10$
	NEG	R4		;MINUS, OP=2
10$:	ADD	O.EXP,R4	;PLUS, OP=0
15$:	MOV	R4,O.EXP	;COMMON OUT, SET EXP TO WHATEVER
	CLRB	O.OP		;IS IN R4 TOO
	INC	R2		;SET R2 SO THAT R4 IS, OP=0
	RTS	PC
20$:	MOV	R3,-(SP)	;SAVE AN ODD AND END

	.IFT

	MOV	O.EXP,R3	;GET THE LEFT SIDE OF EXPRESSION
	.IF	DF R$$11M
	.IFF
	MUL	#50,R3		;SHIFT IT OVER BY 50
	.IFT
	ASL	R3		; MULTIPLY BY 10
	ASL	R3		;
	ASL	R3		;
	ADD	R3,R4		; ADD IT
	ASL	R3		; MULTIPLY BY 40
	ASL	R3		; WHICH IS LIKE MULTIPLYING BY 50
	.ENDC
	ADD	R3,R4		;AND ADD IT TO THE RIGHT
	MOV	(SP)+,R3	;PUT R3 BACK, THANK YOU
	BR	15$		;COMMON OUT

	.IFTF


;BUILD AN OCTAL NUMBER		JSR PC,GETNUM

;NEEDS AND RETURNS--
;R0	NON-OCTAL TERMINATING CHARACTER
;R2	OCTAL CHARACTER COUNT
;R4	OCTAL NUMBER THAT I GOT, YOU GET

GETNUM:	CLR	R2		;NEW R2 AND R4
	CLR	R4
10$:	JSR	PC,O.GET	;GET 1 CHARACTER
	CMPB	#'0,R0		;NON-OCTAL, LESS THAN "0"
	BHI	GETC99
	CMPB	#'7,R0		;NON-OCTAL, LESS THAN "7"
	BLO	GETC99
	BIC	#177770,R0	;MAKE INTO ACCEPTABLE RANGE
	.IF	DF R$$11M
	.IFF
	ASH	#+3,R4		;MPY BY 10 TO MAKE ROOM
	.IFT
	ASL	R4		; SHIFT LEFT
	ASL	R4		; 3 BITS
	ASL	R4		;
	.ENDC
	ADD	R0,R4		;PLANT LO PLACE
	INC	R2		;ACCOUNT FOR NEW ONE
	BR	10$		;NEXT ONE OR OTHER

;SCAN A LIST OF CHARACTERS	JSR R5,LOOKUP

;CALL--
;		R0	HAS THE CHARACTER
;	JSR	PC,LOOKUP	;THAT IS IT
;
;		LOOKER: HAS THE TABLE ADD.
;			00 BYTE IS END OF LIST

;RETURNS AT CALL + 2 WITH--
;R0	STILL HAS CHARACTER
;R1	HAS INDEX X2 OF FOUND CHARACTER IF C=0
;C=1	CHARACTER WAS NOT FOUND

LOOKUP:	MOV	LOOKER,R1	;GET ADDRESS OF TABLE
10$:	CMPB	R0,(R1)		;IS THIS THE ONE
	BNE	20$		;RIGHT IT WASN'T
	SUB	LOOKER,R1	;COMPUTE INDEX AND RETURN
	ASL	R1		;DO THIS FOR EVERBODY, C=0
	BR	30$
20$:	TSTB	(R1)+		;CHECK FOR END OF LIST
	BNE	10$		;IF NOT LOOK AT NEXT ITEM
	SEC			;SECURITY EXCHANGE COMMISION
30$:	RTS	PC		;SECURITY ELSEWHERE

;GET CONTENTS OF ADDRESS IN THE MODE		JSR PC,GETCAD

;NEEDS--
;R0		THE MODE 1=BYTE, 2=WORD
;O.CAD		THE ADDRESS
;O.DEVI		THE DEVICE CODE

;RETURNS--
;R0		HAS THE DATA YOU ASKED FOR

GETCAD: CMP	#INTBEG,O.CAD	; FIND OUT IF INTERNAL REGISTER
	BHI	5$		;  TOO LOW
	CMP	#INTEND,O.CAD	; COMPARE TO END OF TABLE
	BHI	7$		; IF HI THEN INTERNAL REGISTER
5$:	CLR 	INTFL		; OTHERWISE CLEAR FLAG
7$:	MOV	#O.CWD,O.DPNT	;POINT TO DATA'S TEMP. STORAGE WORD
	MOV	R0,ACC		;SAVE FLAG FOR WORD OR BYTE MODE
	MOV	O.CAD,R1	; GET CORE ADDRESS
	MOV	SP,O.OPN	; SET LOCATION OPEN
	BIT	#1,O.CAD	; ODD LOCATION ?
	BEQ	10$		;   NO,
	DEC	R1		;   YES, MADE R3 POINT TO PREV. EVEN LOC.
	INC	O.DPNT		; BUT POINT TO HIGH ORDER BYTE

10$:	MOV	#O.CWD,R2	;ADDRESS OF TEMP BUFF
	MOV	#0,R0		;INDICATE A GET OPERATION
	JSR	PC,DTMV		;GO GET IT

20$:	BIT	#1,ACC		;DID WE WANT A BYTE?
	BEQ	30$		;   NO, GET A WORD
	MOVB	@O.DPNT,R0	;   YES, GET THE BYTE
	BR	GETC99		;THAT'S IT
30$:	MOV	@O.DPNT,R0	;GET THE WORD
GETC99:	RTS	PC		;LEAVE

;PUT R4 INTO ADDRESS IN THE MODE		JSR PC,PUTCAD
;  DEPENDS ON O.DPNT REMAINING THE SAME SINCE THE LAST GETCAD

;NEEDS--
;R2		CONTENT FLAG, 0 FOR NONE, ELSE R4 IS GOLD
;R4		THE DATA
;O.BW		THE MODE FLAG, IF 0 THEN NO LOCATION OPEN

PUTCAD:	TST	R2		;CHECK FOR TYPED VALUE
	BEQ	40$		;NO DATA NO DODO
	MOV	O.BW,R0		;PICK UP MODE AN CC'S
	TST	O.OPN		; IS A LOCATION OPEN AT PRESENT?
	BEQ	40$		;NOT OPEN NOT STORED

	BIT	#1,R0		;CHECK IF BYTE OR WORD
	BEQ	10$		;BRANCH IF WORD
	MOVB	R4,@O.DPNT	;ITS A BYTE, SAVE IN TEMP. STORAGE
	BR	20$		;GO FOR ADDRESS
10$:	MOV	R4,@O.DPNT	;PUT THE WORD HERE FOR NOW

20$:	MOV	O.CAD,R1	;GET OUR ADDRESS
	BIT	#1,R1		;IS IT ODD?
	BEQ	30$		;   NO, LEAVE IT ALONE
	DEC	R1		;   YES, MAKE IT PREV. EVEN LOC.
30$:	MOV	O.CWD,R2	;GET THE DATA (O.DPNT POINTS TO O.CWD)
	MOV 	#4,R0		;INDICATE A PUT OPERATION
	JSR	PC,DTMV		;MOVE IT INTO MEMORY

40$:	RTS	PC



;
; GET AND PUT TO MEMORY ROUTINES
;
; INPUTS
;	R0 - OPERATION FLAG   0=GET, 4=PUT
;	R1 - ADDRESS OF MEMORY LOCATION
;	R2 - BUFFER ADD. TO GET TO,  OR  , VALUE TO PUT TO
;	R4 - OFFSET FOR BREAKPOINT TABLE  (BRMV)
;

BRMV:
	CMP	#O.TRTC,R1	;JUST A RESET ?
	BEQ	DTMV2		; YES, GO INTERNAL ROUTE
	BIS	O.ADMD(R4),R0	;SET MODE OF BREAKPOINT
	BR	DTMV1

DTMV:
	TST	INTFL		;ACCESSING INTERNAL REGISTER?
	BNE	DTMV2		;  IF NE, YES, DON'T USE MVTS$S
	BISB	O.MD,R0		;SET MODE OF DATA ACCESS  U OR S
	BISB	O.SP,R0		;SET ACCESS SPACE  I OR D
DTMV1:	MVTS$S	R0,R1,R2	;MOVE THE DATA
	BCC	RET		;CARRY CLEAR MEANS NO ERRORS
	CMPB	$DSW,#235	; WAS IT ILLEGAL DIC ?
	BEQ	DTMV2		;  YES, DO A REGULAR MOVE
	JSR	PC,O.CRLF	;  NO, MOVE DOWN BEFORE PRINTING "?"
	JMP 	O.ERR		; SOMTHING WENT WRONG

DTMV2:	TST	R0		;WHAT TYPE OF OPERATION
	BEQ	10$		; 0 MEANS GET
	MOV	R2,(R1)		; ELSE PUT IT
	BR	RET		;OK
10$:	MOV	(R1),(R2)	;WE GOT IT

RET:	RTS	PC		;LEAVE


	.SBTTL	UTILITIES - TELETYPE I/O ROUTINES

.IF	DF,RSTS			;++RSTS V9
O.ATT:				;++RSTS V9
O.DET:				;++RSTS V9
	RTS	PC		;++RSTS V9
.IFF				;++RSTS V9
;ATTACH THE TERMINAL

O.ATT:	MOV	#IO.ATT,DPBIOF	;SET ATTACH FUNCTION
	BR	O.ATDT		;EXECUTE THE QIO

;DETACH THE TERMINAL

O.DET:	MOV	#IO.DET,DPBIOF	;SET DETACH FUNCTION
O.ATDT:	MOV	ODTEVT,-(SP)	;SET UP THE STACK
	MOV	(SP),DPBEFN	;SET UP EVENT FLAG IN DPB
	MOV	#DPBQIO,-(SP)	;PUSH DPB ONTO STACK
	RSX11			;CALL RSX FOR THE QIO
	BCC	WTQIO		;IF OK, WAIT FOR QIO TO FINISH
	RTS	PC		;ELSE JUST RETURN
.ENDC				;++RSTS V9
;TYPE CARRIAGE RETURN LINE FEED			JSR PC,O.CRLF

O.CRLF:	MOV	(PC)+,R0
	.BYTE	015,012

;TYPE TWO CHARS IN R0 PLEASE			JSR PC,O.TYPE

O.TYPE:	JSR	PC,O.FTYP	;DO ONE
	SWAB	R0

;TYPE ONLY ONE CHARACTER IN R0			JSR PC,O.FTYP

	.IF	NDF,RSTS	;++RSTS V9
O.FTYP:	MOV	#IO.WLB,DPBIOF	;SET WRITE FUNCTION
	.IFF			;++RSTS V9
O.FTYP:				;++RSTS V9
	.IFTF			;++RSTS V9
	MOVB	R0,CHRBUF	;PUT CHAR IN BUFF
	.IFF			;++RSTS V9
	MOV	R0,-(SP)	;++RSTS V9	SAVE A WORK REGISTER
	JSR	PC,SETXRB	;++RSTS V9	SAVE XRB, IOSTS AND FQJOB
	INC	@#XRB+XRBC	;++RSTS V9	SET BYTE COUNT TO 1
	BIS	#1000,@#XRB+XRMOD ;++RSTS V9	SET RSX-STYLE I/O
	.WRITE			;++RSTS V9	TYPE THE CHARACTER
	JSR	PC,@(SP)+	;++RSTS V9	RESTORE XRB, IOSTS AND FQJOB
	MOV	(SP)+,R0	;++RSTS V9	AND THE WORK REGISTER
	RTS	PC		;++RSTS V9	THEN RETURN
	.IFT			;++RSTS V9

;GENERAL QIO TO CONSOLE ROUTINE

DOAQIO:
	MOV	ODTEVT,-(SP)	;SET UP THE EVENT ON THE STACK
	MOV	(SP),DPBEFN	;SET UP EVENT IN THE DPB
10$:				;REF LABEL
	MOV	#DPBQIO,-(SP)	;POINT TO THE DPB
	RSX11			;POINT TO THE EXEC
	BCS	10$		;ONLY DIRECTIVE ERRORS WE GET ARE
				; TRANSIENT SYSTEM PROBLEMS (NO DYNAMIC
				; MEMORY) OR TOTAL SYSTEM CATASTROPHES
WTQIO:				;REF LABEL
	MOV	(PC)+,-(SP)	;PUSH A WAITFOR SINGLE EVENT
	.BYTE	41.,02.		;WAITFOR=41., SIZE=2.
	RSX11			;GO WAIT
	.IF	DF	R$$11M
10$:	TST	IOSTAT		;HAS FUNCTION COMPLETED?
	BEQ	10$		;NO
	.ENDC
	RTS	PC		;GO BACK

;GENERAL CHAR INPUT ROUTINE

	.IFF			;++RSTS V9
O.GET:	JSR	PC,O.GET1	;++RSTS V9	GET A CHARACTER
	.IFT			;++RSTS V9
O.GET:	MOV	#IO.RLB,DPBIOF	;SET READ
	JSR	PC,DOAQIO	;DO A QIO
	TSTB	IOSTAT		;ALL OKAY?
	BPL	1$		;IF PL YES
	JMP	O.EXIT		;ASSUME EOF AND GET OUT
1$:	MOVB	CHRBUF,R0	;GET CHAR INPUT
				;DO NOT CLEAR PARITY	;++RSTS V9 003
	.IF	NDF	RSTS			;++RSTS V9
	BIC	#177600,R0	;INTERESTED ONLY IN 7-BIT ASCII
	.ENDC
	.IF	DF	R$$11M
	TST	IOSTAT+2	;IF NON-ZERO, GOT A CHARACTER
	BNE	5$		; WE GOT ONE
	MOVB	IOSTAT+1,R0	; IF ZERO, GET CONTROL CHARACTER
	.ENDC
5$:	CMPB	R0,#12		;BRANCH IF <LF>
	BEQ	15$		;NO ECHO <LF>'S

	MOV	#ALTTAB,LOOKER	;GET ALTMODE TABLE ADDRESS
	JSR	PC,LOOKUP	;CHECK IF ALTMODE

	.IF	DF R$$11M
	.IFT
	BCS	11$
	.IFF
	BCS	10$		;
	.ENDC
	.IFF			;++RSTS V9
	CMPB	#15,R0		;++RSTS V9	IF CHARACTER IS <CR>
	BNE	10$		;++RSTS V9
	JSR	PC,O.GET1	;++RSTS V9	A <LF> WILL FOLLOW
	MOV	#15,R0		;++RSTS V9	RESTORE THE <CR>
10$:	CMPB	#33,R0		;++RSTS V9	IF CHARACTER IS <ESC>
	BNE	11$		;++RSTS V9
	.IFTF			;++RSTS V9
	MOVB	#'$,R0		;CHANGE TO $ IF SO
	.IFT			;++RSTS V9
10$:	JSR	PC,O.FTYP	; AND ECHO
	.ENDC			;++RSTS V9
11$:	CMPB	R0,#141		; LOWER CASE?
	BLT	13$		; NO
	CMPB	R0,#172		; MAYBE
	BGT	13$		; NO
	SUB	#40,R0		; YES, CONVERT TO UPPER CASE
13$:	CMPB	#' ,R0		;CVT BLANK
	BNE	15$
	MOVB	#'+,R0		;INTO +
15$:	RTS	PC


	.SBTTL	RSTS SOUBROUTINES

	.IF	DF,RSTS		;++RSTS V9
O.GET1:	JSR	PC,SETXRB	;++RSTS V9	SAVE XRB, IOSTS AND FQJOB
	.TTDDT			;++RSTS V9	SET ODT INPUT MODE
	BIS	#1000,@#XRB+XRMOD ;++RSTS V9	SET RSX-STYLE I/O
	.READ			;++RSTS V9	GET A CHARACTER
	JSR	PC,@(SP)+	;++RSTS V9	RESTORE XRB, IOSTS AND FQJOB
	MOVB	CHRBUF,R0	;++RSTS V9	GIVE USER THE CHARACTER
	BIC	#^C<377>,R0	;++RSTS V9	CLEAR SIGN EXTEND 	;003
	BEQ	O.GET1		;++RSTS V9	AND IGNORE NULLS
	RTS	PC		;++RSTS V9	RETURN TO CALLER
SETXRB:	MOV	@#FIRQB,O.IOSTS ;++RSTS V9	SAVE IOSTS
	MOV	@#FIRQB+FQJOB,O.FQJOB ;++RSTS V9	SAVE FQJOB
	MOV	#XRBSIZ,R0	;++RSTS V9	SET SIZE OF XRB IN BYTES
10$:	MOVB	XRB-1(R0),O.XRB-1(R0);++RSTS V9	SAVE XRB
	CLRB	XRB-1(R0)	;++RSTS V9	THEN CLEAR IT
	SOB	R0,10$		;++RSTS V9
	INC	@#XRB+XRLEN	;++RSTS V9	SET BUFFER LENGTH TO 1
	MOV	#CHRBUF,@#XRB+XRLOC ;++RSTS V9	SET THE BUFFER ADDRESS
	JSR	PC,@(SP)+	;++RSTS V9	CO-ROUTINE FOR THE I/O
	MOV	#XRBSIZ,R0	;++RSTS V9	RESTORE THE XRB
20$:	MOVB	O.XRB-1(R0),XRB-1(R0);++RSTS V9
	SOB	R0,20$		;++RSTS V9
	MOV	O.FQJOB,@#FIRQB+FQJOB ;++RSTS V9	RESTORE FQJOB
	MOV	O.IOSTS,@#FIRQB	;++RSTS V9	RESTORE IOSTS
	RTS	PC		;++RSTS V9	RETURN TO CALLER
	.ENDC			;++RSTS V9

	.SBTTL	UTILITIES - PRETTY PRINTERS

;PRINT ADDRESS- RELOC, SYMBOLIC, OR ABSL	JSR PC.O.RORA

;R0	ADDRESS TO BE PRINTED
;O.FORM	CORE ADDRESS FORMAT (0-RELOC  1-ABSOL)

;REGISTER	'$R ' OR '$DR '
;CORE		'D,XXXXXX ' OR 'XXXXXX '

O.RORA:	MOV	R0,-(SP)	;CALLING VALUE ONA TOPPA SATCK
	TST	INTFL		; POSSIBLE INTERNAL REGISTER
	BEQ	50$		; IF EQ NO
	CMP	#INTBEG,(SP)	;
	BHI	50$		;BELOW FIRST NON-INDEXED
	CMP	#INTEND,(SP)
	BLO	50$		;ABOVE LAST NON-INDEXED
	MOV	#'$,R0		;ANNOUNCE INTENTIONS
	JSR	PC,O.FTYP
	CMP	#INTINX,(SP)
	BLOS	20$		;GO TO DO INDEXED
	MOV	(SP)+,R0	;NON-INDEXED REGISTER ----- "$R "
	SUB	#INTBEG,R0	;CLEANED UP STACK, GET OFFSET
	ASR	R0		;BYTE THAT WORD, WORD THAT BYTE
	MOVB	NIXMAP(R0),R0	;MAGIC CHARACTER FROM TABLE
15$:	BIS	(PC)+,R0
	.BYTE	000,' 		;CHARACTER PLUSSA BLANK
	BR	O.TYPE		;NAME PLUS BLANK AND SPLIT
20$:	CLR	R1		;SEE WHICH SET OF TABLES WE GOT
22$:	CMP	INXTBL+2(R1),(SP)	;LOOK ON AHEAD TO FIND BEHIND
	BHI	24$		;R1 POINTS TO BASE OF SET
	TST	(R1)+		;THINK ABOUT THOSE DUMMY ENTRIES DUMMY
	BR	22$
24$:	MOV	(SP)+,R0	;INDEXED REGISTER ---- "$DR "
	SUB	INXTBL(R1),R0	;GET ADDRESS AND COMPUTE OFFSET IN WORDS
	ASR	R0		;AND FINALLY IN PLAIN TALK
	ADD	#'0,R0		;CONVERT TO ASCII
	JSR	PC,O.FTYP	;TYPE OUT REGISTER NUMBER
	ASR	R1
	MOVB	INXREG(R1),R0	;PICK UP THE REAL CHARACTER
	BR	15$		;GO PRINT REST OF IT
50$:	TST	O.FORM		;CORE ADDRESS SEE WHAT USER WANTS
	BNE	80$		;TYPE AS ABSOLUTE.
	MOV	(SP),R4		;RELOCATE ---- "R,XXXXXX "
	JSR	PC,O.LOCA	;WE ALWAYS PICK, ODT KNOWS BEST
	BMI	80$		;BUT NOT ALL THE TIME
	MOV	R1,(SP)		;SET THE DISPLACEMENT
	ADD	#"0,,R0		;PRINT REGISTER AND COMMA
	JSR	PC,O.TYPE	;DISK AND CORE
80$:	MOV	(SP)+,R0	;PRINT R0 AS A WORD
	;JSR	PC,O.CADW
	;RTS	PC

;TYPE R0 AS BYTE OR WORD, TWO ENTRIES
;	FOR A WORD				JSR PC,O.CADW
;	FOR A BITE				JSR PC,O.CADB

O.CADW:	MOV	R0,O.QUAN	;SET THE FAMOUS QUANTITY VALUE
	MOV	#6,R3		;# OF DIGITS
	MOV	#-2,R4		;# OF BITS FIRST-3
	BR	O.CA01		;DO THE COMMON THING
O.CADB:	CLR	O.QUAN		;SET FOR ALL OF QUAN A BYTE
	MOVB	R0,O.QUAN	;SET THE QUANTITY THING AGAIN
	MOV	#3,R3		;THERE ARE THREE DIGITS
	MOV	#-1,R4		;AND ONLY TWO BITS
	SWAB	R0		;SWITCH ENDS
O.CA01:	MOV	R0,-(SP)	;SAVE R0
10$:	ADD	#3,R4		;COMPUTE THE NUMBER OF BITS TO DO
	CLR	R0
15$:	ROL	(SP)		;GET A BIT
	ROL	R0		;STORE IT AWAY
	DEC	R4		;DECREMENT COUNTER
	BGT	15$		;LOOP IF MORE BITS NEEDED
	ADD	#'0,R0		;CONVERT TO ASCII
	JSR	PC,O.FTYP	;TYPE IT
	DEC	R3		;SEE IF MORE DIGITS TO DO
	BGT	10$		;LOOP IF SO
	MOVB	#' ,R0		;SET UP FOR TRAILING SPACE
	TST	(SP)+		;GET RID OF JUNK
O.FT01:	JUMP	O.FTYP

;TYPE CONTENTS OF WORD IN FORMAT	JSR PC,@TYFORM(R1)

;R0		WORD OR BYTE TO BE TYPED, RHJ
;R1	CODE-	ENTRY PT,	FORMAT,	CODE
;
; JUMP TABLE LOOKS LIKE THIS
;
;	TYFORM:	+	O.CADB	;BYTE OCTAL - 0
;		+	O.CADW	;WORD OCTAL - 2
;		+	O.BANS	;BYTE ANSII - 4
;		+	O.WANS	;WORD ANSII - 6
;		+	O.RADF	;RADIX 50  - 10
;

O.RADF:	JSR	PC,TYRADX	;R0 GETS THE RADIX 50 TREATMENT
	BR	TSPC		;APPEND A BLANK TO 3 CHAR'S

O.WANS:	JSR	PC,O.FTYP	;TYPE BYTE IN R0
	SWAB	R0		;SWAP EM AND TYPE IT

O.BANS:	JSR	PC,O.FTYP	;TYPE OF BYTE IN R0
TSPC:	MOVB	#' ,R0		;SAVE SPACE
	BR	O.FT01		;ALSO SAVE SPACE

;TYPE CONTENTS OF R0 IN RADIX 50		JSR PC,TYRADX

TYRADX:	MOV	#3,R5		;COUNT OF CHARACTERS
	MOV	#RADCON,R2	;POINTER TO COEFFICENT TABLE
	MOV	R0,R1		;COPY OF RADIX 50 WORD
	.IF	DF R$$11M
	.IFF
10$:	CLR	R0		;RHJ IN R0 R1
	DIV	(R2)+,R0	;R0 HAS QUO(CHAR) R1 HAS REMAINDER
	.IFT
10$:	MOV	R1,R0		; GET DIVIDEND
	MOV	(R2)+,R1	; GET DIVISOR
;
; THIS IS AN IN-LINE COPY OF $DIV.  IT IS HERE TO AVOID LINKING TO THE
; SUBJECT TASK'S GLOBAL $DIV, IF ANY.  ITS PRESENCE ALSO AVOIDS THE
; NEED FOR ENOUGH STACK TO AUTOLOAD THE SUBJECT TASK'S $DIV.
;
	MOV	#20,-(SP)	;SET LOOP COUNT
	MOV	R1,-(SP)	;SAVE DIVISOR FOR SUBTRACTS
	CLR	R1		;CLEAR REMAINDER
30$:	ASL	R0		;DOUBLE LEFT SHIFT
	ROL	R1		;
	CMP	R1,(SP)		;SUBTRACT OUT DIVISOR?
	BLO	40$		;IF LO NO
	SUB	(SP),R1		;SUBTRACT OUT DIVISOR
	INC	R0		;ADD IN LOW BIT
40$:	DEC	2(SP)		;DECREMENT REPEAT COUNT
	BGT	30$		;IF GT MORE TO GO
	CMP	(SP)+,(SP)+	;CLEAN STACK
	TST	R0		; IS QUOTIENT ZERO? (SP)?
	.ENDC

;RADIX 50 CHAR IN R0, COUNT TO ASCII

	BEQ	12$		;"SP" = 040
	CMPB	R0,#33		;RAD50-$ =33
	BEQ	16$		;"$" = 044
	BGT	14$		;"." OR "0-9" = 056 OR 060-071
	ADD	#40,R0		;RAD50-A = 1, "A" = 101
12$:	ADD	#16,R0		;40+16+11+11 = 100 + (A-Z)
14$:	ADD	#11,R0		;16+11+11 = 40 + (SP)
16$:	ADD	#11,R0		;11+11 = 22 + (.,0-9)
	JSR	PC,O.FTYP	;TYPE CHARACTER IN R0
	DEC	R5		;COUNT THE CHARACTERS
	BNE	10$		; LOOP
	RTS	PC


;SELECT RELOCATION REGISTER			JSR PC,O.LOC

;O.CAD		ADDRESS TO USE IN SELECTION

;RETURNS--
;R0				REGISTER NUMBER FOUND, -1 IF NONE FOUND
;R1				DISTANCE, RELOCATION FACTOR

;SUBROUTINE TO LOCATE RELOCATION REGISTER NEAREST BUT STILL
;BELOW THE ADDRESS IN O.CAD.  RETURNS WITH THE REGISTER
;NUMBER IN R0, AND WITH THE DISTANCE BETWEEN THE REGISTER
;AND (O.CAD) IN R1
;IF NO GOOD RELOC. REG. FOUND, R0 WILL = -1

O.LOC:	MOV	O.CAD,R4	;SET UP CAD DATA
O.LOCA:	CLR	R0
	MOV	#-1,-(SP)	;INITIALIZE RELOC. REG. INDEX
	MOV	(SP),R1		;INITIALIZE DISTANCE TO A HIGH VALUE
10$:	CMP	R0,#O.RLR	;ARE WE DONE COMPARING?
	BHI	20$		;BRANCH IF DONE
	CMP	O.RELT(R0),R4	;IS CURR. RELOC. BIAS > (R4)?
	BHI	15$		;IF SO, BRANCH -- DON'T SUBTRACT, GET NEXT
	MOV	R4,R2		;OTHERWISE TAKE THE DIFFERENCE
	SUB	O.RELT(R0),R2	;OF CURR. RELOC. REG. AND O.CAD
	CMP	R1,R2		;IS THE RESULT THE SMALLEST SO FAR?
	BHI	25$		;BRANCH IF YES (UNSIGNED CONDITIONAL)
15$:	TST	(R0)+		;OTHERWISE, BUMP R0 FOR NEXT RELOC. REG.
	BR	10$		;LOOP BACK FOR NEXT COMPARISON
20$:	MOV	(SP)+,R0	;PUT REG.# IN R0
	RTS	PC		;JOB OVER, RETURN
25$:	MOV	R2,R1		;REMEMBER SMALLEST DIFFERENCE IN O.XXY
	ASR	R0		;AND ASSOCIATED REGISTER NUMBER
	MOV	R0,(SP)		; IN (SP)
	ASL	R0		;RESTORE R0 TO ORIGINAL VALUE
	BR	15$		;GO FO NEXT COMPARISON.

	.SBTTL	ODT SIZE SYMBOLS AND END STUFF

ENDODT	=.-2		;LAST LOCATION USED


	.ENDC
	.END	O.ODT


