	.TITLE	ALSCT
	.IDENT	/02/
;
; COPYRIGHT (C) 1976
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ONLY ON A
; SINGLE COMPUTER SYSTEM AND MAY  BE  COPIED   ONLY  WITH  THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE,  OR
; ANY OTHER COPIES THEREOF, MAY NOT BE PROVIDED  OR  OTHERWISE
; MADE AVAILABLE TO ANY OTHER PERSON   EXCEPT FOR  USE ON SUCH
; SYSTEM AND TO ONE WHO AGREES TO THESE LICENSE  TERMS.  TITLE
; TO AND OWNERSHIP OF THE SOFTWARE SHALL AT ALL  TIMES  REMAIN
; IN DEC.
;
; THE INFORMATION IN THIS DOCUMENT IS SUBJECT TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT BY DIGITAL
; EQUIPMENT CORPORATION.
;
; DEC ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF
; ITS SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DEC.
;         
; VERSION 02
;
; C. MONIA 09-JUL-76
;
;
; MODIFIED BY:
;
;	T. M. MARTIN	5-APR-81
;			ADD SUPPORT FOR USER I&D SPACE TASKS
;
;	T. M. MARTIN	9-NOV-81
;			PLACE CODE IN PIC I-SPACE PSECT
;
;	W.R.  Main	11-May-90
;			Modify for RSTS, add create multiple dyn regions
;
; FORTRAN CALLABLE SUBROUTINE TO ALLOCATE PHYSICAL MEMORY TO A VIRTUAL SECTION
;
; MACRO LIBRARY CALLS
;
 
	.MCALL	DIR$,CRRG$S,GMCX$S,GTSK$S,RDBDF$,WDBDF$,.PICOD
	RDBDF$
	WDBDF$
	R$$11M=0	;need /ID form 
;
; EQUATED SYMBOLS
;
; OFFSET TO REGION DESCRIPTOR THREAD WORD
;
 
	.ASECT
.=R.GPRO+2
RGNXT:	.BLKW	1		;
 
;
; ADDITIONAL WINDOW DESCRIPTOR OFFSETS
;
 
.=W.NSRB+2
WNBAS:	.BLKW	1		; OFFSET TO BLOCK OF PHYSICAL MEMORY
WNSIZ:	.BLKW	1		; TOP PHYSICAL ADDRESS/SIZE OF BLOCK
WNXT:	.BLKW	1		; THREAD WORD
 
	.PICOD			;PLACE CODE IN PIC I-SPACE PSECT
;+
;
; **-ALSCT-FORTRAN CALLABLE SUBROUTINE TO ALLOCATE PHYSICAL MEMORY
; 	    TO A VIRTUAL SECTION.
;
; THIS SUBROUTINE IS CALLED BY A FORTRAN TASK TO ALLOCATE PHYSICAL MEMORY
; TO A VIRTUAL PROGRAM SECTION. THE VIRTUAL ATTRIBUTE IS ATTACHED TO A
; PROGRAM SECTION (FORTRAN COMMON BLOCK) BY MEANS OF THE TASK BUILDER
; VSECT KEYWORD. USE OF THIS KEYWORD ALLOWS THE USER TO:
;
;	A) ALIGN A FORTRAN COMMON BLOCK (NAMED PROGRAM SECTION) ON AN
;	   ARBITRARY ADDRESS BOUNDARY.
;
;	B)  SET AN UPPER LIMIT ON THE VIRTUAL ADDRESS SPACE ALLOCATED TO THE
;	    COMMON BLOCK OR PROGRAM SECTION (WINDOW SIZE).
;
;	C) PRE-ALLOCATE ANY AMOUNT OF PHYSICAL MEMORY TO THE SECTION.
;
; THE PHYSICAL MEMORY CAN BE PART OF THE TASK IMAGE OR CAN RESIDE
; WITHIN A SEPERATE REGION.  IN EITHER CASE, SUCH MEMORY CAN BE THOUGHT
; OF AS A CORE POOL, PORTIONS OF WHICH CAN BE ALLOCATED TO MAP ONE OR
; MORE VIRTUAL SECTIONS. THE PURPOSE OF THIS SUBROUTINE IS TO PERFORM THE
; ALLOCATION TO A VIRTUAL SECTION FROM A CONTIGOUS POOL OF SUCH MEMORY.
; THE COMPANION ROUTINE, RLSCT, IS CALLED TO RETURN A BLOCK OF MEMORY
; TO THE CORE POOL.  IT IS THE RESPONSIBILITY OF THE PROGRAM TO MAP THE
; PHYSICAL MEMORY INTO VIRTUAL ADDRESS SPACE BY MEANS OF THE APPROPRIATE
; SYSTEM MAPPING DIRECTIVES.
;
; THE KEY DATA ELEMENTS IN THIS STRUCTURE ARE THE REGION AND WINDOW
; DESCRIPTOR ARRAYS DISCUSSED BELOW. THESE DATA ELEMENTS SERVE TWO PUR-
; POSES:
;
;	1) THEY ARE USED BY THE PROGRAM AS ARGUMENTS TO THE FORTRAN-CALL-
;	   ABLE SUBROUTINES THAT ISSUE THE MAPPING DIRECTIVES;
;
;	2) THEY ARE USED BY RLSCT AND ALSCT WHEN ALLOCATING AND DEALLOCATING
;	    THE PHYSICAL MEMORY REFERENCED BY THE MAPPING DIRECTIVES.
;
; THE CORE POOL FROM WHICH THE ALLOCATION IS MADE IS DEFINED BY
; THE REGION DESCRIPTOR. ATTACHED TO EACH REGION WILL BE ONE OR MORE
; WINDOW DESCRIPTORS THAT ARE REFERENCED WHEN THE ACTUAL MAPPING DIREC-
; TIVES ARE ISSUED. THE PROCESS OF ATTACHING A WINDOW DESCRIPTOR TO A
; REGION AND ALLOCATIONG A PORTION OF THE PHYSICAL MEMORY OWNED BY THE
; REGION TO THE WINDOW DESCRIPTOR IS PERFORMED BY ALSCT. THE NET EFFECT OF
; OF SEVERAL CALLS, EACH WITH THE SAME REGION DESCRIPTOR, IS TO THREAD
; TOGETHER ALL WINDOWS THAT USE MEMORY WITHIN THE REGION. A WINDOW MUST
; BE DETACHED THROUGH A CALL TO RLSCT BEFORE IT CAN BE ATTACHED TO ANO-
; THER REGION.
; 
; CALLING SEQUENCE:
; 
;	CALL ALSCT (IREG,IWND[,ISTS])
;
; ARGUMENT DESCRIPTIONS:
;
;	IREG  IS A ONE-DIMENSIONAL INTEGER ARRAY NINE WORDS IN LENGTH.
;	      WORDS 1 THROUGH 8 CONTAIN A REGION DESCRIPTOR IN THE
;	      FOLLOWING FORMAT:
;
;		IREG(1) - REGION I/D
;		IREG(2) - SIZE OF REGION IN UNITS OF 64-BYTE BLOCKS
;		IREG(3), IREG(4) - REGION NAME IN 2-WORD, RADIX-50 FORMAT
;		IREG(5), IREG(6) - NAME OF MAIN PARTITION CONTAINING REGION
;				   IN 2-WORD, RADIX-50 FORMAT.
;		IREG(7) - REGION STATUS WORD
;		IREG(8) - PROTECTION CODE OF REGION
;
;	IREG(9) IS A THREAD WORD THAT LINKS ALL WINDOW BLOCKS  HAVING
;	SPACE ALLOCATED WITHIN THE REGION.
;
;	ON THE FIRST CALL TO ALSCT, ELEMENTS OF IREG MUST BE SETUP AS FOLLOWS:
;
;	IREG(1) = REGION IDENTIFICATION  (0=TASK REGION in RSX-11M/M+)
;		on RSTS 0 is the automatic region and the size will be returned
;		in IREG(2) after the first call. If the region ID is minus
;		the System will create a new dynamic region of the size in
;		IREG(2) and return the its region ID in IREG(1). For each
;		region used an seperate RDB (IREG) array must used.
;	IREG(2) = SIZE OF REGION OR 0 IF TASK REGION ( I/D = 0)
;	IREG(9) = 0
;
;	THE CONTENTS OF THESE ELEMENTS MUST NOT BE ALTERED BY THE CALLER.
;
;	IWND  IS A ONE-DIMENSIONAL INTEGER ARRAY 11 WORDS IN LENGTH.
;	THE ONLY ELEMENT SUPPLIED BY THE CALLER IS ALLOCATION SIZE
;	IN IWND(10). ARRAY CONTENTS ARE AS FOLLOWS:
;
;	      WORDS 1 THROUGH 8 CONTAIN A WINDOW DESCRIPTOR IN THE
;	      FOLLOWING FORMAT:
;
;		IWND(1) - BITS 8 - 15 CONTAIN THE NUMBER OF THE LOWEST
;		          APR REGISTER THAT IS USED TO MAP THE WINDOW.
;			  BITS 0 - 7 ARE RESERVED FOR USE BY THE EXECU-
;			  TIVE.
;
;		IWND(2) - VIRTUAL BASE ADDRESS OF THE WINDOW.
;
;		IWND(3) - WINDOW SIZE IN UNITS OF 64-BYTE BLOCKS
;		IWND(4) - REGION I/D
;		IWND(5) - WINDOW OFFSET INTO PARTITION IN UNITS OF 64-
;			  BYTE BLOCKS.
;		IWND(6) - LENGTH TO MAP IN UNITS OF 64-BYTE BLOCKS.
;		IWND(7) - WINDOW STATUS WORD
;		IWND(8) - ADDRESS OF SEND/RECEIVE BUFFER
;
;	THE REMAINING ELEMENTS CONTAIN INFORMATION UTILIZED BY ALSCT
;	AS DESCRIBED BELOW:
;
;		IWND(9) - BASE OFFSET OF WINDOW IN UNITS OF 64-BYTE BLOCKS;
;		IWND(10) - LENGTH/NEXT FREE OFFSET ABOVE BLOCK ASSIGNED
;			   TO WINDOW IN UNITS OF 64-BYTE BLOCKS.
;		IWND(11) - THREAD WORD
;
;	THE CALLER MUST SUPPLY THE PHYSICAL LENGTH OF THE ALLOCATION IN
;	IWND(10). THIS VALUE IS IN UNITS OF 64-BYTE BLOCKS.
;
;	IWND(11) IS A THREAD WORD THAT LINKS TOGETHER ALL WINDOW BLOCKS
;	HAVING PHYSICAL MEMORY ALLOCATED WITHIN THE REGION.
;
;	UPON SUCCESFUL COMPLETION, THE FOLLOWING ELEMENTS OF IWND ARE
;	SETUP:
;
;		IWND(4) = REGION I/D
;		IWND(5) = INITIAL OFFSET INTO REGION
;		IWND(9) = BASE OFFSET OF ALLOCATION
;		IWND(10) = OFFSET TO NEXT LOCATION ABOVE ALLOCATED MEMORY
;		IWND(11) = THREAD WORD CONNECTING DESCRIPTOR TO OTHER
;		           WINDOWS OWNING SPACE IN THE REGION.
;
;
;		OFFSETS ARE IN UNITS OF 64-BYTE BLOCKS.
;
;		THE CALLER MUST NOT ALTER THE CONTENTS OF THE LAST THREE
;		ARRAY ELEMENTS.
;
;	ISTS IS AN INTEGER TO RECEIVE THE RESULTS OF THE CALL. ONE OF
;	THE FOLLOWING VALUES IS RETURNED:
;
;		ISTS = 1; SUCCESFUL COMPLETION. ELEMENTS OF IWND
;		       ARE SETUP AS DESCRIBED ABOVE.
;
;		ISTS = -200; INSUFFICIENT MEMORY WAS AVAILABLE TO SATISFY
;		       THE ALLOCATION REQUEST. THE CONTENTS OF IWND(9)
;		       AND IWND(11) ARE UNDEFINED. IWND(10) IS UN-
;		       CHANGED.
;
;
;-
 
ALSCT::				;Fortran entry point
	MOV	#3,R2		; SPECIFY MAX ARG CT
	MOV	#6,R1		; SPECIFY REQ'D ARG BITMASK
	CALL	.X.PA1		; PUSH ARGUMENT ADDRESSES
	MOV	(SP)+,R1	; GET REGION DESCRIPTOR ADDRESS
	MOV	(SP)+,R2	; GET WINDOW DESCRIPTOR ADDRESS
ALSCTM::			;MACRO-11 entry point
	MOV	R.GSIZ(R1),R3	; GET LENGTH OF REGION
	TST	R.GID(R1)	; check Region ID for setup etc
		.IF	DF,RSTS	; create new dynamic region option
	BPL	5$		;if minus we will create region
	CLR	R.GID(R1)	;preset for new region ID
	MOV	#<RS.ATT!RS.WRT!RS.RED>,R.GSTS(R1)
	MOV	SP,R5
	MOV	R1,-(SP)	;descriptor address
	MOV	#<2*400!55.>,-(SP)	; DIC,DPBSIZ for CRRG$
	DIR$			;create the needed region
	MOV	@#$DSW,R.GPRO(R1)
	MOV	R5,SP		;clean up stack
	CMP	#IS.SUC,@#$DSW
	BNE	50$
	BR	10$
		.ENDC		;RSTS -create new region option

5$:	BNE	10$		;if positive skip the region 0 sizing
	MOV	R.GSIZ(R1),R3	; GET LENGTH OF REGION
	BNE	10$		; if region size <>0 no need to find it
	MOV	SP,R5		; SAVE STACK POINTER
	SUB	#8.*<W.NSRB+2>+2,SP ; ALLOCATE MAPPING CONTEXT BUFFER
	MOV	SP,R0		; COPY BUFFER ADDRESS
		.IF	DF,RSTS
	GTSK$S	R0		; GET MAPPING CONTEXT
	MOV	10(R0),R3	; SET REGION SIZE

		.IFF		;RSX version
	GMCX$S	R0		; GET MAPPING CONTEXT
	MOV	W.NOFF(R0),R3	; SET REGION SIZE
		.ENDC		;RSTS
	MOV	R3,R.GSIZ(R1)	; SAVE REGION SIZE
	MOV	R5,SP		; CLEAN STACK
10$:				;
	MOV	R.GSIZ(R1),R3	; GET LENGTH OF REGION
	MOV	WNSIZ(R2),-(SP)	; GET SIZE OF REQUESTED ALLOCATION
	MOV	R.GID(R1),W.NRID(R2) ; SET REGION I/D
	ADD	#RGNXT-WNXT,R1	; COMPUTE OFFSET TO LINK-NEXT
		;above makes reg-desc link appear as first previous value
	CLR	R4		; CLEAR CURRENT BASE OFFSET
20$:				;
	MOV	R1,R0		; SET ADDRESS OF PREVIOUS
	MOV	R3,R5		; ASSUME AT END OF CHAIN
	MOV	WNXT(R1),R1	; GET LINK TO NEXT
	BEQ	30$		; IF EQ AT END OF CHAIN
	MOV	WNBAS(R1),R5	; SET UPPER LIMIT OF HOLE
30$:				;
	MOV	R4,WNBAS(R2)	; ASSUME ALLOCATION FITS, SET BASE
	ADD	(SP),R4		; BIAS TOP ADDRESS
	CMP	R5,R4		; ALLOCATION FIT IN THIS HOLE?
	BHIS	40$		; IF HIS YES (CARRY CLEAR)
	TST	R1		; HAVE NEXT WINDOW?
	BEQ	50$		; IF EQ AT END OF LIST
	MOV	WNSIZ(R1),R4	; SET BASE OF NEXT HOLE
	BR	20$		; GO AGAIN
40$:				;
	MOV	WNBAS(R2),W.NOFF(R2) ; SET INITIAL REGION OFFSET
	MOV	R4,WNSIZ(R2)	; SET NEXT-AVAILABLE OFFSET
	MOV	R2,WNXT(R0)	; SET PREVIOUS TO THIS WINDOW DESCRIPTOR
	MOV	R1,WNXT(R2)	; POINT TO NEXT
	MOV	#1,R1		; SET SUCCESS
	BR	60$		;
50$:				;
	MOV	#-200.,R1	; SET ERROR RETURN
60$:				;
	INC	(SP)+		; CLEAN STACK
	MOV	(SP)+,R0	; GET ADDRESS OF STATUS VARIABLE
	BEQ	70$		; IF EQ NONE
	MOV	R1,(R0)		; RETURN STATUS
70$:				;
	RETURN			;
 
	.END
