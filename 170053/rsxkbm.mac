TITLE	RSXKBM,<RSX KEYBOARD MONITOR>,05,29-AUG-85,SSS/MJG/SJM/TWH/KPH

;
;		COPYRIGHT (c) 1974, 1985 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

	ORG	RSXKBM

..KBM:					;GLOBAL SYMBOL IN RSXRTS

.ENABL	GBL,AMA

.SBTTL	KEYBOARD MONITOR DECLARATION

O.FLAG==PF.KBM				;DEFINE THIS RTS AS A KEYBOARD MONITOR


.SBTTL	SET UP FIRQB ROUTINE

;+
; ROUTINE TO SET UP FIRQB
; CALLING SEQUENCE:
;	CALL	..STFQ
;	 .WORD	POINTER TO MESSAGE TEXT 
;	 	.WORD	FILENAME STRING ADDRESS
;	 	.WORD	FILENAME STRING LENGTH
;	 	.ASCII /TEXT/
; INPUTS:
;	R0	CONTAINS ENTRY PARAMETER FOR PROGRAM TO BE RUN.
; OUTPUTS:
;	REGISTERS DESTROYED
;-

..STFQ::
	MOV	(R5)+,R3		;GET POINTER TO MESSAGE TEXT BLOCK
	MOV	(R3)+,R2		;GET FILENAME STRING ADDRESS
	MOV	(R3),R3			;GET STRING LENGTH
	CALL	PARSE			;PARSE THE FILENAME
	BIT	#10,-(R1)		;WAS A DOT FOUND?
	BEQ	10$			;NOPE
	BIT	#40,(R1)		;WAS EXTENSION WILD?
	BEQ	20$			;NOPE
10$:	MOV	#-1,FIRQB+FQEXT		;USE ANY EXTENSION
20$:	TST	R0			;TEST ENTRY PARAMETER
	BEQ	30$			;JUST TAKE IT FROM THE TOP
	BIS	#100000,R0		;SET THE PRIVILEGE BIT
	MOV	R0,FIRQB+FQNENT		;DEFINE ENTRY PARAMETER
30$:	RETURN	R5			;RETURN TO CALLER

	TMPORG	RSXAT

..AT::
	RETURN				;UNLESS OVERLAID BY REAL CODE

	UNORG

; 'NEW' ENTRY POINT

..NEW::
	BIT	#JFNOPR,KEY		;ARE WE ALREADY LOGGED IN?	   ;TWH
	BEQ	3$			;Yes, so off to the keyboard monitor
	TST	XRB+2			;Is this a brand new job?
	BEQ	10$			;Yes, so run LOGIN or something
3$:	CALL	INIJOB			;INITIALIZE JOB IMAGE
	CALL	..AT			;SEE IF WE WANT TO RUN A PROGRAM
5$:	CALLX	..KMON			;DO A KEYBOARD MONITOR COMMAND
	BR	5$			;AND ANOTHER ...

10$:	TST	FIRQB+FQPPN		;AM I A SPAWNED JOB?
	BEQ	30$			;NO, RUN LOGIN
	MOV	#CORCMN,R0		;POINT R0 TO CORCMN
	MOV	#11.,R2			;MOVE 10 BYTES
	MOVB	R2,(R0)+		;PLUS CREATOR'S JOBNO*2
20$:	MOVB	FIRQB+16-<CORCMN+1>(R0),(R0)+ ;FILL CORE COMMON
	SOB	R2,20$
	MOVB	FIRQB+FQFIL,-(R0)	;LAST BYTE IS CREATE JOBNO*2
	.RUN				;DO WHAT I'M SUPPOSED TO
	BR	40$			;POOF, JOB VANISHES

30$:	MOV	#32000.,R0		;ENTER 'LOGIN' AT LINE 32000.
	CALL	LOGIN			;INVOKE LOGIN
40$:	JMPX	..TEST			;TOO BAD IF WE GET HERE

INIJOB:	CLR	KEY			;IN CASE OF CALLR ..NEW
	PUSH	FIRQB+FQFIL		;SAVE CREATE JOBNO*2
	PUSH	FIRQB+FQNAM1+2		;.... FILE NAME, SECOND WORD
	PUSH	FIRQB+FQNAM1		;.... FILE NAME, FIRST WORD
	MOV	#1,XRB			;SHRINK SIZE TO 1K WORDS
	.CORE
	MOV	..NAM,FIRQB+FQNAM1
	MOV	..NAM+2,FIRQB+FQNAM1+2
	.NAME				;SET THE KEYBOARD MONITOR NAME
	CLRB	FIRQB+FQFIL
	DOFIP	RST			;RESET ALL CHANNELS
	CLEAR	NSTORG,<<4000-NSTORG>/2> ;CLEAR CORE
	CLEAR	0,30			;CLEAR JOB CONTROLLED AREA
	POP	FIRQB+FQNAM1 		;POP FILE NAME
	POP	FIRQB+FQNAM1+2 		;
	POP	FIRQB+FQFIL		;POP CREATE JOBNO*2
20$:	RETURN

.SBTTL	KEYBOARD COMMAND PROCESSOR

;+
; CALLING SEQUENCE:
;	CALL	..CCL
; INPUTS:
;	XRB+XRLEN	LENGTH OF COMMAND LINE BUFFER
;	XRB+XRBC	LENGTH OF COMMAND LINE
;	XRB+XRLOC	ADDRESS OF COMMAND LINE
; OUTPUTS:
;	ABOVE 3 WORDS PRESERVED
;	R0 THROUGH R5 DESTROYED
;	IOSTS		RSTS ERROR CODE
;			TLCNTD (?WHAT?) MEANS COMMAND LINE DOES NOT CONTAIN
;			EITHER A CCL COMMAND OR A COMMAND THE BUILT-IN
;			TABLE UNDERSTANDS.
;			NOTCLS (?I/O CHANNEL OPEN) MEANS COMMAND LINE IS
;			EITHER A VALID CCL COMMAND OR A RUN COMMAND BUT
;			CHANNEL 15. IS STILL OPEN.
;			OTHER ERRORS ARE ERRORS FROM ATTEMPTING A VALID
;			KEYBOARD MONITOR COMMAND.  THE ERROR MESSAGE SHOULD
;			BE PRINTED.
;-
..CCL::
	MOV	#XRB,R1			;SAVE XRB PARAMETERS
	PUSH	(R1)+			; ...
	PUSH	(R1)+			;    ...
	PUSH	(R1)			;       ...
	.CCL				;EXECUTE CCL COMMAND
	TSTB	IOSTS			;CHECK FOR ERRORS IF ANY
	BNE	10$			;RETURN ON CCL ERROR
	MOV	SP,R1			;TRY ANOTHER APPROACH
	MOV	(R1)+,XRB+XRLOC		;RESTORE THE LINE LOCATION
	MOV	(R1)+,XRB+XRBC		;AND THE LINE LENGTH
	CALL	..CMD,R5,<..CMTB>	;CALL THE COMMAND DISPATCHER
					;  USE BUILT-IN COMMAND TABLE
10$:	MOV	#XRB+XRLOC,R1		;RESTORE XRB PARAMETERS
	POP	(R1)			; ...
	POP	-(R1)			;    ...
	POP	-(R1)			;       ...
	RETURN

.SBTTL	DISPATCH COMMAND BY TABLE

;+
; CALLING SEQUENCE:
;	CALL	..CMD,R5
;	 .WORD	COMMAND TABLE ADDRESS
;		COMMAND TABLE ENTRY FORMAT:
;		.WORD	ADDRESS TO DISPATCH TO
;		.ASCIZ	\COM-MAND\	COMMAND STRING, WHERE '-' INDICATES
;					UNIQUE ABBREVIATION POINT
;		.EVEN
; INPUTS:
;	XRB+XRLEN	LENGTH OF COMMAND LINE BUFFER
;	XRB+XRBC	LENGTH OF COMMAND LINE
;	XRB+XRLOC	ADDRESS OF COMMAND LINE
; OUTPUTS:
;	ABOVE 3 WORDS PRESERVED
;	R0 THROUGH R5 DESTROYED
;	IOSTS		RSTS ERROR CODE
;			TLCNTD (?WHAT?) MEANS COMMAND LINE DOES NOT CONTAIN
;			EITHER A CCL COMMAND OR A COMMAND THE BUILT-IN
;			TABLE UNDERSTANDS.
;			NOTCLS (?I/O CHANNEL OPEN) MEANS COMMAND LINE IS
;			EITHER A VALID CCL COMMAND OR A RUN COMMAND BUT
;			CHANNEL 15. IS STILL OPEN.
;			OTHER ERRORS ARE ERRORS FROM ATTEMPTING A VALID
;			KEYBOARD MONITOR COMMAND.  THE ERROR MESSAGE SHOULD
;			BE PRINTED.
;-
..CMD::
	MOV	(R5)+,R1		;GET COMMAND TABLE ADDRESS
	MOV	R5,(SP)			;PUT RETURN ADDRESS ON STACK
	MOV	#XRB,R5			;SAVE XRB FIRST 3 WORDS
	PUSH	(R5)+			;XRLEN
	MOV	(R5),R3			;GET THE COMMAND LINE LENGTH
	PUSH	(R5)+			;XRBC
	MOV	(R5),R2			;AND COMMAND LINE ADDRESS
	PUSH	(R5)			;XRLOC
	PUSH	#90$			;SAVE XRB RESTORE ADDRESS

10$:	CLR	R0			;CLEAR THE ABBREVIATION FLAG
	MOV	(R1)+,R5		;GET DISPATCH ADDRESS
	BEQ	WHAT			;COMMAND NOT FOUND
20$:	CMPB	(R2),#40		;IS LEADING CHARACTER A SPACE?
	BEQ	30$			; YES
	CMPB	(R2),#11		;IS IT A TAB?
	BNE	40$			; NO SO GO ON
30$:	INC	R2			;SKIP OVER THE SPACE OR TAB
	DEC	R3			;SHORTEN THE LENGTH
	BR	20$			;TRY FOR ANOTHER SPACE OR TAB

40$:	CMPB	(R1),#'-		;CHECK FOR ABBREVIATION POINT
	BNE	50$
	MOVB	(R1)+,R0		;SET THE ABBREVIATION FLAG
50$:	TST	R3			;CHECK FOR END OF COMMAND LINE
	BEQ	80$
	CMPB	(R2),#'/		;SLASH TERMINATES COMMAND
	BEQ	80$
	MOVB	(R2)+,R4		;GET NEXT CHARACTER IN LINE
	DEC	R3			;ONE LESS CHARACTER LEFT
	CMP	R4,#11			;CHECK FOR A TAB
	BEQ	80$			;TAB TERMINATES COMMAND
	CMPB	R4,#40			;CHECK FOR A BLANK
	BEQ	80$			;BLANK TERMINATES COMMAND
	BLO	50$			;IGNORE OTHER CONTROL CHARACTERS
	TSTB	(R1)			;CHECK FOR END OF COMMAND
	BEQ	70$			;IF SO GO ON TO NEXT COMMAND
	CMPB	R4,#'A+40		;CHECK FOR LOWER CASE ALPHA
	BLO	60$
	CMPB	R4,#'Z+40
	BHI	60$
	BIC	#40,R4			;CHANGE TO UPPER CASE
60$:	CMPB	(R1)+,R4		;MATCH THIS CHARACTER
	BEQ	40$			;IF MATCHED DO NEXT CHARACTER

70$:	TSTB	(R1)+			;NOT A MATCH, SKIP TO END OF COMMAND
	BNE	70$
	INC	R1			;ROUND UP TO NEXT ENTRY IN TABLE
	BIC	#1,R1
	MOV	XRB+XRLOC,R2		;RESTORE LINE ADDRESS
	MOV	XRB+XRBC,R3		;RESTORE LINE LENGTH
	BR	10$			;TRY NEXT COMMAND

80$:	TST	R0			;CHECK FOR ABBREVIATION SEEN
	BEQ	70$			;IF INCOMPLETE MATCH TRY NEXT COMMAND
	CALLR	(R5)			;DISPATCH TO COMMAND HANDLER

90$:	MOV	#XRB+XRLOC,R5		;RESTORE XRB BEFORE RETURN
	POP	(R5)			;XRLOC
	POP	-(R5)			;XRBC
	POP	-(R5)			;XRLEN
	RETURN

WHAT:	MOV	#TLCNTD,IOSTS		;RETURN THE"?WHAT?" ERROR CODE
	RETURN

.SBTTL	KEYBOARD MONITOR COMMAND TABLE

	.PSECT	.99994

..CMTB::				; ORDER IS NOT IMPORTANT!!!

	KBMCMD	ASSIGN,ASS-IGN
	KBMCMD	BYE,BYE-
	KBMCMD	DEASSN,DEA-SSIGN
	KBMCMD	DISMNT,DIS-MOUNT
	KBMCMD	EXIT,EXI-T
..XCMD==KB.CMD				;** PATCH ** FOR BP2 TO BLANK THIS
	KBMCMD	HELLO,HEL-LO
	KBMCMD	MOUNT,MOU-NT
	KBMCMD	REASSN,REA-SSIGN
	KBMCMD	RUN,RUN-
	KBMCMD	SHUTUP,SHU-TUP
	KBMCMD	SWITCH,SW-ITCH
	KBMCMD	UNSAVE,UNS-AVE

	UNORG

.SBTTL	THE 'EXIT' COMMAND

EXIT:
	CALLRX	..EXIT			;RETURN TO JOB DEFAULT RTS

.SBTTL	THE 'SWITCH' COMMAND

SWITCH:
	TST	R3			;ANYTHING TO SWITCH TO?
	BEQ	20$			;NO, EXIT TO SYSTEM DEFAULT RTS
	CALL	NAMCHK			;GET NAME OF RTS TO SWITCH TO
	MOV	#-1,FIRQB+FQEXT		;INDICATE A PERMANENT SWITCH
10$:	.RTS				;GO TO THE OTHER RTS
	TSTB	IOSTS			;IF THERE WAS NO ERROR
	BEQ	EXIT			;THEN RETURN TO JOB DEFAULT RTS (I.E. US)
	RETURN				;ELSE RETURN ERROR TO CALLER
20$:	.EXIT				;TO THE SYSTEM DEFAULT RTS

.SBTTL	THE 'RUN' COMMAND

RUN:
	CALL	NAMCHK			;GET A FILENAME AND CHECK IT
	BIT	#10,(R1)		;GOT A DOT?
	BEQ	10$			;NOPE
	BIT	#40,(R1)		;WAS IT WILD?
	BEQ	15$			;NOPE
10$:	MOV	#-1,FIRQB+FQEXT		;WE'LL SETTLE FOR ANYTHING
15$:	.RUN				;GO RUN IT
	RETURN				;RETURN ON ERROR

.SBTTL	THE 'UNSAVE' COMMAND

UNSAVE:
	CALL	NAMCHK			;GET A FILENAME AND CHECK IT
	DOFIP	DLN			;DELETE THE FILE
	RETURN

NAMCHK:
	TST	R3			;IS THERE ANYTHING TO PARSE?
	BNE	10$			;YES, DO IT
	POP				;ELSE POP THE SUBROUTINE RETURN
	BR	WHAT			;SET THE ERROR AND EXIT DIRECTLY

10$:	CALL	PARSE			;PARSE THE FILENAME
	MOV	#IOSTS,R4		;POINT TO THE ERROR CODE
	TSTB	(R4)			;CHECK FOR ERROR
	BNE	20$			;ON ERROR EXIT DIRECTLY
	TST	-(R1)			;TEST RESULT OF PARSE
	BPL	30$			;EXIT IF THERE'S NO FUNNY DEVICE NAME
	MOV	#NODEVC,(R4)		;SET THE INVALID DEVICE NAME ERROR
20$:	POP				;POP THE SUBROUTINE RETURN
30$:	RETURN

PARSE:
	PUSH	R3			;SAVE BUFFER POINTER
	CLEAR	FIRQB,FQBSIZ/2		;CLEAR FIRQB (R1 -> END OF FIRQB)
	POP	R3			;RESTORE BUFFER POINTER
.ASSUME	XRB	EQ	FIRQB+FQBSIZ
	MOV	R3,(R1)+		;XRLEN PUT LENGTH IN XRB
	MOV	R3,(R1)+		;XRBC TWICE 
	MOV	R2,(R1)+		;XRLOC POINT TO FILENAME STRING 
	CLR	(R1)+			;XRB+6
	CLR	(R1)+			;XRB+10 USE STANDARD LOCATION FOR LOGICALS
	.FSS				;PARSE THE FILE NAME
	RETURN

.SBTTL	THE 'HELLO' COMMAND

HELLO:
	CLR	R0			;ENTER 'LOGIN' AT LINE 0
	CALL	..SYS8			;PUT REMAINDER OF STRING IN CORE COMMON
LOGIN:	CALL	..STFQ,R5,$LOGIN	;SET UP FIRQB
	.RUN				;CALL LOGIN
	RETURN

$LOGIN:	MSGTXT	<"      :[001,002]LOGIN .*  ">
..LGIN==M.TEXT				;** PATCH ** FOR ANOTHER NAME

..SYS8::
	MOV	XRB+XRLOC,R2		;GET LINE ADDRESS
	MOV	XRB+XRBC,R3		;GET LINE LENGTH
	MOV	#CORCMN,R4		;POINT TO CORE COMMON
	CMPB	R3,#127.		;CHECK FOR LONG LINES
	BLOS	5$
	MOVB	#127.,R3		;TRUNCATE TO 127. CHARACTERS
5$:	MOVB	R3,(R4)+		;PUT CORE COMMON STRING LENGTH
	BEQ	20$			;LEAVE IF ZERO LENGTH STRING
10$:	MOVB	(R2)+,(R4)+		;COPY STRING INTO CORE COMMON
	SOB	R3,10$
20$:	RETURN


.SBTTL	THE 'BYE' COMMAND

BYE:
	CLR	R0			;ENTER 'LOGOUT' AT LINE 0
	CALL	..SYS8			;PUT REMAINDER OF STRING IN CORE COMMON
	CALL	..STFQ,R5,$LOGOT	;SET UP FIRQB
	.RUN				;CALL LOGOUT
	RETURN

$LOGOT:	MSGTXT	<"      :[001,002]LOGOUT.*  ">
..LGOT==M.TEXT				;** PATCH ** FOR ANOTHER NAME

.SBTTL	THE 'ASSIGN' COMMAND

ASSIGN:
;	CLR	R5			;LOGICAL NAME MUST HAVE A DEVICE(WHY?)
	CALL	DEVCHK			;PARSE AND CHECK DEVICE NAME
	BR	ULOG			;LET RSTS DO IT

DEVCHK:	MOV	#TLNOFN,R4		;PRESET ERROR CODE
	TST	R3			;ANY ARGUMENTS?
	BEQ	30$			;TOO FEW ARGUMENTS
	CALL	PARSE			;PARSE THE DEVICE NAME
	TSTB	IOSTS			;PARSED OKAY?
	BNE	40$			;EXIT ON ERROR
	MOV	#BADNAM,R4		;PRESET ERROR
	TST	XRB+XRBC		;ANY UNPARSED STRING LEFT?
	BNE	30$			;YES, ERROR
	TST	(R1)			;ANYTHING WILD?
	BMI	30$			;YUP, ILLEGAL FILE NAME
	BIT	#4000,-(R1)		;DEFAULT PROTECTION SUPPLIED?
	BEQ	10$			;NO, LEAVE IT ALONE
	CLR	FIRQB+FQPROT-1		;CLEAR OUT DEFAULT PROTECTION
10$:	MOVB	#UU.ASS,FIRQB+FQFUN	;GUESS AT ASSIGN/REASSIGN
	BIT	#1,(R1)			;FOUND A FILENAME?
	BEQ	50$			;NOPE, SIMPLY EXIT
	MOV	#TLCNTD,R4		;PRESET ERROR
	CMP	#30000,(R1)		;FOUND A DEVICE NAME?
	BLOS	20$			;YUP, GO CHECK FOR VALID DEVICE
	TST	R5			;IS A DEVICE NAME REQUIRED?
	BNE	50$			;NO, SIMPLY EXIT
	BR	30$			;YES, GIVE BACK AN ERROR

20$:	MOV	#NODEVC,R4		;PRESET ERROR
	TST	(R1)			;IS IT A VALID DEVICE?
	BPL	50$			;A VALID DEVICE
30$:	MOV	R4,IOSTS		;PUT IN THE ERROR CODE
40$:	POP				;POP THE STACK TO RETURN DIRECTLY
50$:	RETURN

.SBTTL	THE 'REASSIGN' COMMAND

REASSN:
	CLR	R5			;LOGICAL NAME MUST HAVE A DEVICE
	CALL	DEVCHK			;PARSE AND CHECK DEVICE NAME
	MOV	FIRQB+FQNAM1,R5		;GET JOB NUMBER IN RAD50
	CLR	R4			;CLEAR HIGH ORDER WORD FOR DIVIDE
	DIV	#50,R4			;DO RAD50 REDUCTION
	TST	R5			;IS THERE A THIRD CHARACTER?
	BNE	20$			;SHOULDN'T
	MOV	R4,R5			;MOVE ANSWER TO LOW ORDER WORD
	CLR	R4			;CLEAR HIGH ORDER WORD AGAIN
	DIV	#50,R4			;DO ANOTHER REDUCTION
	SUB	#36,R4			;MAKE FIRST CHARACTER INTO A DIGIT
	BLE	20$			;ERROR IF NOT A DIGIT OR 0
	MOV	R5,R3			;PUT SECOND CHARACTER IN SAFE PLACE
	BEQ	10$			;BRANCH IF NO SECOND CHARACTER
	SUB	#36,R3			;MAKE SECOND CHARACTER INTO DIGIT
	BLT	20$			;ERROR IF NOT A DIGIT
	MUL	#10.,R4			;MULTIPLY FIRST DIGIT BY TEN
	MOV	R3,R4			;GET THE SECOND DIGIT
10$:	ADD	R4,R5			;ADD THE TWO DIGITS TOGETHER
	MOV	R5,FIRQB+FQNAM1		;PUT RESULT IN FIRQB
	BR	ULOG			;LET RSTS DO IT

20$:	MOV	#BDNERR,IOSTS		;SET THE ILLEGAL NUMBER ERROR
	RETURN

.SBTTL	THE 'DEASSIGN' COMMAND

DEASSN:
	TST	R3			;ANY ARGUMENTS?
	BNE	10$			;YES, GO CHECK ARGUMENTS
	MOVB	#UU.DAL,FIRQB+FQFUN	;DEASSIGN ALL
	BR	ULOG			;LET RSTS DO IT

10$:	MOV	R3,R5			;LOGICAL NAME DOESN'T NEED A DEVICE
	CALL	DEVCHK			;PARSE THE DEVICE NAME
	MOVB	#UU.DEA,FIRQB+FQFUN	;DEASSIGN
ULOG:	CLR	XRB			;USE STANDARD LOGICAL AREA
	.ULOG				;LET RSTS DO IT
	RETURN				;DONE

;	CLEAR LOGICAL DEVICE, ASSIGN PPN, AND DEFAULT PROTECT CODE

..CLOG::
	CLEAR	USRPPN,<<NSTORG-USRPPN>/2> ;CLEAR ALL LOGICALS
	RETURN

.SBTTL	THE 'MOUNT' COMMAND

MOUNT:
	CALL	DEVCHK			;PARSE AND CHECK DEVICE NAME
	CALL	UUOMNT,R5,0		;UUO SUBCODE FOR MOUNT
	CALL	UUOMNT,R5,6		;UUO SUBCODE FOR UNLOCK
	RETURN

.SBTTL	THE 'DISMOUNT' COMMAND

DISMNT:
	CALL	DEVCHK			;PARSE AND CHECK DEVICE NAME
	CALL	UUOMNT,R5,2		;UUO SUBCODE FOR DISMOUNT
	RETURN

UUOMNT:	MOV	(R5)+,FIRQB+FQERNO	;GET THE UUO SUBCODE
	UUO	MNT			;MOUNT, UNLOCK, OR DISMOUNT
	TSTB	IOSTS			;CHECK STATUS
	BEQ	20$
	MOV	#RTSPC,R5		;IF ERROR, RETURN DIRECTLY
20$:	RETURN	R5

.SBTTL	THE 'SHUTUP' COMMAND

SHUTUP:
	CLRB	FIRQB+FQFIL		;CLOSE ALL CHANNELS
	DOFIP	RST
	UUO	DIE			;KILL SYSTEM
RTSPC:	RETURN				;RETURN ON ERROR

.END
