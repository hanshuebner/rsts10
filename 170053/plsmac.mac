;
; COPYRIGHT (C) 1989
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ONLY ON A
; SINGLE COMPUTER SYSTEM AND MAY  BE  COPIED   ONLY  WITH  THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE,  OR
; ANY OTHER COPIES THEREOF, MAY NOT BE PROVIDED  OR  OTHERWISE
; MADE AVAILABLE TO ANY OTHER PERSON   EXCEPT FOR  USE ON SUCH
; SYSTEM AND TO ONE WHO AGREES TO THESE LICENSE  TERMS.  TITLE
; TO AND OWNERSHIP OF THE SOFTWARE SHALL AT ALL  TIMES  REMAIN
; IN DEC.
;
; THE INFORMATION IN THIS DOCUMENT IS SUBJECT TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT BY DIGITAL
; EQUIPMENT CORPORATION.
;
; DEC ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF
; ITS SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DEC.
;         
;
; VERSION 01.02
;
; CLARK A. D'ELIA  07-SEP-76
;
; MACRO DEFINITIONS TO SUPPORT THE RSX-11M PROGRAM LOGICAL
; ADDRESS SPACE EXTENSION DIRECTIVES.
;
; MODIFIED FOR RSX-11M-PLUS VERSION 2.0 BY:
;
;	T. M. MARTIN
;
; MODIFIED FOR RSX-11M-PLUS VERSION 2.0 BY:
;
;	B. S. MCCARTHY	29-JUN-89	01.02
;
;		BM421 -- ADD RS.RES FLAG TO MAKE THE COMMON RESIDENT
;			UPON CREATION OR RETURN ERROR.
;
 
 
;
; RDBDF$ - DEFINE THE REGION DEFINITION BLOCK SYMBOLS
;
 
	.MACRO	RDBDF$	GBL
;
; REGION DEFINITION BLOCK OFFSETS
;
	.MCALL	.BLKW.,.BLK.
	.BLK.
	.BLKW.	1,R.GID,GBL	;REGION ID
	.BLKW.	1,R.GSIZ,GBL	;SIZE OF REGION (32W BLOCKS)
	.BLKW.	2,R.GNAM,GBL	;NAME OF REGION (RAD50)
	.BLKW.	2,R.GPAR,GBL	;REGION'S MAIN PARTITION NAME (RAD50)
	.BLKW.	1,R.GSTS,GBL	;REGION STATUS WORD
	.BLKW.	1,R.GPRO,GBL	;PROTECTION CODE OF REGION
	.BLKW.	0,R.GLGH,GBL	;LENGTH OF REGION DEFINITION BLOCK
;
; REGION STATUS WORD SYMBOLS
;
 
	.IF IDN	<DEF$G>,<GBL>
 
	.GLOBL	RS.CRR,RS.UNM,RS.RES,RS.MDL,RS.NDL,RS.ATT
	.GLOBL	RS.NEX,RS.EXT,RS.DEL,RS.WRT,RS.RED
 
	.ENDC
 
 
RS.CRR=^O<100000>		;REGION WAS SUCCESSFULLY CREATED
RS.UNM=^O<40000>		;ONE OR MORE WINDOWS WERE UNMAPPED ON A DETACH
 
RS.RES=^O<400>			;MAKE REGION RESIDENT UPON CREATION
RS.MDL=^O<200>			;MARK REGION FOR DELETE ON LAST DETACH
RS.NDL=^O<100>			;CREATED REGION IS NOT TO BE MARKED FOR DETACH
RS.ATT=^O<40>			;ATTACH TO CREATED REGION
RS.NEX=^O<20>			;CREATED REGION IS NOT EXTENDABLE
RS.DEL=^O<10>			;DELETE ACCESS DESIRED ON ATTACH
RS.EXT=^O<4>			;EXTEND ACCESS DESIRED ON ATTACH
RS.WRT=^O<2>			;WRITE ACCESS DESIRED ON ATTACH
RS.RED=^O<1>			;READ ACCESS DESIRED ON ATTACH
;
; REDEFINE MACRO TO NULL
;
	.MACRO	RDBDF$	X
	.ENDM
 
	.ENDM	RDBDF$
 
 
;
; RDBBK$ - GENERATE A REGION DEFINITION BLOCK
;
 
	.MACRO	RDBBK$	SIZ,NAM,PAR,STS,PRO
 
	.MCALL	RDBDF$,R50$
	RDBDF$			;DEFINE REGION DEFINITION BLOCK SYMBOLS
 
	.WORD	0		;REGION ID
	.WORD	SIZ		;SIZE OF REGION (32W BLOCKS)
	R50$	NAM		;NAME OF REGION (RAD50)
	R50$	PAR		;REGION'S MAIN PARTITION NAME (RAD50)
	.WORD	STS		;REGION STATUS WORD
	.WORD	PRO		;REGION PROTECTION WORD
 
	.ENDM	RDBBK$
 
 
;
; ATRG$/ATRG$C/ATRG$S - ATTACH A REGION
;
 
	.MACRO	ATRG$	RDB
	.MCALL	OFF$
	.IF NDF	$$$GLB
	.BYTE	57.,2
	.WORD	RDB
	.ENDC
	.IF NDF	A.TRBA
	OFF$
	OFF$	A.TRBA,2
	.ENDC
	.ENDM	ATRG$
 
 
	.MACRO	ATRG$C	RDB,CS,ERR
	.MCALL	ATRG$,DIR$
	.IF NDF	$$$GLB
	.PSECT	$DPB$$
$$$=.
	.IFTF
	ATRG$	RDB
	.IFT
	.PSECT	CS
	DIR$	#$$$,ERR
	.ENDC
	.ENDM	ATRG$C
 
 
	.MACRO	ATRG$S	RDB,ERR
	.MCALL	DIR$,MOV$
	MOV$	RDB
	MOV	(PC)+,-(SP)
	.BYTE	57.,2
	DIR$	,ERR
	.ENDM	ATRG$S
 
 
 
;
; CPCR$/CPCR$C/CPCR$S -- CHECKPOINT COMMON REGION
;
 
	.MACRO	CPCR$	NAME
	.MCALL	R50$,OFF$
	.IF NDF	$$$GLB
	.BYTE	205.,3
	R50$	NAME
	.ENDC
	.IF NDF	S.RETN
	OFF$
	OFF$	C.PCNM,2
	.ENDC
	.ENDM	CPCR$
 
 
	.MACRO	CPCR$C	NAME,CS,ERR
	.MCALL	CPCR$,DIR$
	.IF NDF	$$$GLB
	.PSECT	$DPB$$
$$$=.
	.IFTF
	CPCR$	NAME
	.IFT
	.PSECT	CS
	DIR$	#$$$,ERR
	.ENDC
	.ENDM	CPCR$C
 
 
	.MACRO	CPCR$S	NAME,ERR
	.MCALL	DIR$,MOV$,RFA$
	RFA$	NAME
	MOV	(PC)+,-(SP)
	.BYTE	205.,3
	DIR$	,ERR
	.ENDM	CPCR$S
 

;
; CRRG$/CRRG$C/CRRG$S - CREATE A REGION
;
 
	.MACRO	CRRG$	RDB
	.MCALL	OFF$
	.IF NDF	$$$GLB
	.BYTE	55.,2
	.WORD	RDB
	.ENDC
	.IF NDF	C.RRBA
	OFF$
	OFF$	C.RRBA,2
	.ENDC
	.ENDM	CRRG$
 
 
	.MACRO	CRRG$C	RDB,CS,ERR
	.MCALL	CRRG$,DIR$
	.IF NDF	$$$GLB
	.PSECT	$DPB$$
$$$=.
	.IFTF
	CRRG$	RDB
	.IFT
	.PSECT	CS
	DIR$	#$$$,ERR
	.ENDC
	.ENDM	CRRG$C
 
 
	.MACRO	CRRG$S	RDB,ERR
	.MCALL	DIR$,MOV$
	MOV$	RDB
	MOV	(PC)+,-(SP)
	.BYTE	55.,2
	DIR$	,ERR
	.ENDM	CRRG$S
 
 
;
; DTRG$/DTRG$C/DTRG$S - DETACH A REGION
;
 
	.MACRO	DTRG$	RDB
	.MCALL	OFF$
	.IF NDF	$$$GLB
	.BYTE	59.,2
	.WORD	RDB
	.ENDC
	.IF NDF	D.TRBA
	OFF$
	OFF$	D.TRBA,2
	.ENDC
	.ENDM	DTRG$
 
 
	.MACRO	DTRG$C	RDB,CS,ERR
	.MCALL	DTRG$,DIR$
	.IF NDF	$$$GLB
	.PSECT	$DPB$$
$$$=.
	.IFTF
	DTRG$	RDB
	.IFT
	.PSECT	CS
	DIR$	#$$$,ERR
	.ENDC
	.ENDM	DTRG$C
 
 
	.MACRO	DTRG$S	RDB,ERR
	.MCALL	DIR$,MOV$
	MOV$	RDB
	MOV	(PC)+,-(SP)
	.BYTE	59.,2
	DIR$	,ERR
	.ENDM	DTRG$S
 
 
;
; GREG$/GREG$C/GREG$S - GET REGION PARAMETERS
;
;	(NOTE:  THESE MACROS ARE A SPECIAL CASE OF THE
;	GET PARTITION PARAMETERS MACRO.)
;
 
	.MACRO	GREG$	RID,BUF
	.MCALL	OFF$
	.IF NDF	$$$GLB
	.BYTE	65.,4
	.WORD	0,RID
	.WORD	BUF
	.ENDC
	.IF NDF	G.RGID
	.NLIST
	OFF$
	OFF$	,2
	OFF$	G.RGID,2
	OFF$	G.RGBA,2
	.IF NDF	G.RGRB
$$$OST=0
	.IRP	X,<<G.RGRB,2>,<G.RGRS,2>,<G.RGFW,2>>
	OFF$	X
	.ENDM
	.ENDC
	.LIST
	.ENDC
	.ENDM	GREG$
 
 
	.MACRO	GREG$C	RID,BUF,CS,ERR
	.MCALL	GREG$,DIR$
	.IF NDF	$$$GLB
	.PSECT	$DPB$$
$$$=.
	.IFTF
	GREG$	RID,BUF
	.IFT
	.PSECT	CS
	DIR$	#$$$,ERR
	.ENDC
	.ENDM	GREG$C
 
 
	.MACRO	GREG$S	RID,BUF,ERR
	.MCALL	MOV$,DIR$,OFF$
	MOV$	BUF
	MOV$	RID
	CLR	-(SP)
	MOV	(PC)+,-(SP)
	.BYTE	65.,4
	DIR$	,ERR
	.IF NDF	G.RGRB
	.NLIST
$$$OST=0
	.IRP	X,<<G.RGRB,2>,<G.RGRS,2>,<G.RGFW,2>>
	OFF$	X
	.ENDM
	.LIST
	.ENDC
	.ENDM	GREG$S
 
 
;
; WDBDF$ - DEFINE THE WINDOW DEFINITION BLOCK SYMBOLS
;
 
	.MACRO	WDBDF$	GBL
;
; WINDOW DEFINITION BLOCK OFFSETS
;
	.MCALL	.BLKW.,.BLKB.,.BLK.
	.BLK.
	.BLKB.	1,W.NID,GBL	;WINDOW ID
	.BLKB.	1,W.NAPR,GBL	;BASE APR
	.BLKW.	1,W.NBAS,GBL	;VIRTUAL BASE ADDRESS (BYTES)
	.BLKW.	1,W.NSIZ,GBL	;WINDOW SIZE (32W BLOCKS)
	.BLKW.	1,W.NRID,GBL	;REGION ID
	.BLKW.	1,W.NOFF,GBL	;OFFSET IN PARTITION (32W BLOCKS)
	.BLKW.	1,W.NLEN,GBL	;LENGTH TO MAP (32W BLOCKS)
	.BLKW.	1,W.NSTS,GBL	;WINDOW STATUS WORD
	.BLKW.	1,W.NSRB,GBL	;SEND/RECEIVE BUFFER VIRTUAL ADDR (BYTES)
	.BLKW.	0,W.NLGH,GBL	;LENGTH OF WINDOW DEFINITION BLOCK
;
; WINDOW STATUS WORD SYMBOLS
;
 
	.IF IDN	<DEF$G>,<GBL>
 
	.GLOBL	WS.CRW,WS.UNM,WS.ELW,WS.RRF,WS.64B,WS.SIS
	.GLOBL	WS.MAP,WS.RCX,WS.DEL,WS.EXT,WS.WRT,WS.RED
	.GLOBL	WS.BPS,WS.NBP,WS.UDS,WS.NAT,WS.RES
 
	.ENDC
 
 
WS.CRW=^O<100000>		;ADDRESS WINDOW WAS SUCCESSFULLY CREATED
WS.UNM=^O<40000>		;ONE OR MORE WINDOWS WERE UNMAPPED IN
				;CREATE ADDRESS WINDOW OR MAP.
WS.ELW=^O<20000>		;ONE OR MORE WINDOWS WERE ELIMINATED IN
				;CREATE ADDRESS WINDOW
WS.RRF=^O<10000>		;REFERENCE WAS SUCCESSFULLY RECEIVED
 
WS.BPS=^O<4000>			;DO NOT BYPASS CACHE ON MAP
WS.NBP=^O<4000>			;DO NOT BYPASS CACHE ON CRAW
WS.RES=^O<2000>			;MAP ONLY IF RESIDENT
WS.NAT=^O<1000>			;CREATE ATT DESCR ONLY IF NECESSARY
WS.64B=^O<400>			;64 BYTE ALIGNMENT ALLOWED
WS.MAP=^O<200>			;MAP AFTER CREATE WINDOW OR RECEIVE BY REF
WS.RCX=^O<100>			;EXIT IF NO REFERENCES TO RECEIVE
WS.SIS=^O<40>			;CREATE WINDOW IN SUPERVISOR I SPACE
WS.UDS=^O<20>			;CREATE WINDOW IN USER D SPACE
WS.DEL=^O<10>			;SEND WITH DELETE ACCESS
WS.EXT=^O<4>			;SEND WITH EXTEND ACCESS
WS.WRT=^O<2>			;SEND WITH WRITE ACCESS OR MAP WITH WRITE ACCESS
WS.RED=^O<1>			;SEND WITH READ ACCESS
WS.EDS=WS.SIS!WS.UDS		;EFFECTIVE DATA SPACE
;
; REDEFINE MACRO TO NULL
;
	.MACRO	WDBDF$	X
	.ENDM
 
	.ENDM	WDBDF$
 
 
;
; WDBBK$ - GENERATE A WINDOW DEFINITION BLOCK
;
 
	.MACRO	WDBBK$	APR,SIZ,RID,OFF,LEN,STS,SRB
 
	.MCALL	WDBDF$
	WDBDF$			;DEFINE WINDOW DEFINITION BLOCK SYMBOLS
 
	.BYTE	0,APR		;WINDOW ID / BASE APR.
	.WORD	0		;VIRTUAL BASE ADDRESS (BYTES)
	.WORD	SIZ		;WINDOW SIZE (32W BLOCKS)
	.WORD	RID		;REGION ID
	.WORD	OFF		;OFFSET IN PARTITION (32W BLOCKS)
	.WORD	LEN		;LENGTH TO MAP (32W BLOCKS)
	.WORD	STS		;STATUS WORD
	.WORD	SRB		;SEND/RECEIVE BUFFER VIRTUAL ADDRESS
 
	.ENDM	WDBBK$
 
 
;
; CRAW$/CRAW$C/CRAW$S - CREATE ADDRESS WINDOW
;
 
	.MACRO	CRAW$	WDB
	.MCALL	OFF$
	.IF NDF	$$$GLB
	.BYTE	117.,2
	.WORD	WDB
	.ENDC
	.IF NDF	C.RABA
	OFF$
	OFF$	C.RABA,2
	.ENDC
	.ENDM	CRAW$
 
 
	.MACRO	CRAW$C	WDB,CS,ERR
	.MCALL	CRAW$,DIR$
	.IF NDF	$$$GLB
	.PSECT	$DPB$$
$$$=.
	.IFTF
	CRAW$	WDB
	.IFT
	.PSECT	CS
	DIR$	#$$$,ERR
	.ENDC
	.ENDM	CRAW$C
 
 
	.MACRO	CRAW$S	WDB,ERR
	.MCALL	DIR$,MOV$
	MOV$	WDB
	MOV	(PC)+,-(SP)
	.BYTE	117.,2
	DIR$	,ERR
	.ENDM	CRAW$S
 
 
;
; ELAW$/ELAW$C/ELAW$S - ELIMINATE ADDRESS WINDOW
;
 
	.MACRO	ELAW$	WDB
	.MCALL	OFF$
	.IF NDF	$$$GLB
	.BYTE	119.,2
	.WORD	WDB
	.ENDC
	.IF NDF	E.LABA
	OFF$
	OFF$	E.LABA,2
	.ENDC
	.ENDM	ELAW$
 
 
	.MACRO	ELAW$C	WDB,CS,ERR
	.MCALL	ELAW$,DIR$
	.IF NDF	$$$GLB
	.PSECT	$DPB$$
$$$=.
	.IFTF
	ELAW$	WDB
	.IFT
	.PSECT	CS
	DIR$	#$$$,ERR
	.ENDC
	.ENDM	ELAW$C
 
 
	.MACRO	ELAW$S	WDB,ERR
	.MCALL	DIR$,MOV$
	MOV$	WDB
	MOV	(PC)+,-(SP)
	.BYTE	119.,2
	DIR$	,ERR
	.ENDM	ELAW$S
 
 
;
; GMCX$/GMCX$C/GMCX$S - GET MAPPING CONTEXT
;
 
	.MACRO	GMCX$	WVEC
	.MCALL	OFF$
	.IF NDF	$$$GLB
	.BYTE	113.,2
	.WORD	WVEC
	.ENDC
	.IF NDF	G.MCVA
	OFF$
	OFF$	G.MCVA,2
	.ENDC
	.ENDM	GMCX$
 
 
	.MACRO	GMCX$C	WVEC,CS,ERR
	.MCALL	GMCX$,DIR$
	.IF NDF	$$$GLB
	.PSECT	$DPB$$
$$$=.
	.IFTF
	GMCX$	WVEC
	.IFT
	.PSECT	CS
	DIR$	#$$$,ERR
	.ENDC
	.ENDM	GMCX$C
 
 
	.MACRO	GMCX$S	WVEC,ERR
	.MCALL	DIR$,MOV$
	MOV$	WVEC
	MOV	(PC)+,-(SP)
	.BYTE	113.,2
	DIR$	,ERR
	.ENDM	GMCX$S
 
 
;
; MAP$/MAP$C/MAP$S - MAP ADDRESS WINDOW
;
 
	.MACRO	MAP$	WDB
	.MCALL	OFF$
	.IF NDF	$$$GLB
	.BYTE	121.,2
	.WORD	WDB
	.ENDC
	.IF NDF	M.APBA
	OFF$
	OFF$	M.APBA,2
	.ENDC
	.ENDM	MAP$
 
 
	.MACRO	MAP$C	WDB,CS,ERR
	.MCALL	MAP$,DIR$
	.IF NDF	$$$GLB
	.PSECT	$DPB$$
$$$=.
	.IFTF
	MAP$	WDB
	.IFT
	.PSECT	CS
	DIR$	#$$$,ERR
	.ENDC
	.ENDM	MAP$C
 
 
	.MACRO	MAP$S	WDB,ERR
	.MCALL	DIR$,MOV$
	MOV$	WDB
	MOV	(PC)+,-(SP)
	.BYTE	121.,2
	DIR$	,ERR
	.ENDM	MAP$S
 
 
;
; RREF$/RREF$C/RREF$S - RECEIVE BY REFERENCE
;
 
	.MACRO	RREF$	WDB
	.MCALL	OFF$
	.IF NDF	$$$GLB
	.BYTE	81.,2
	.WORD	WDB
	.ENDC
	.IF NDF	R.REBA
	OFF$
	OFF$	R.REBA,2
	.ENDC
	.ENDM	RREF$
 
 
	.MACRO	RREF$C	WDB,CS,ERR
	.MCALL	RREF$,DIR$
	.IF NDF	$$$GLB
	.PSECT	$DPB$$
$$$=.
	.IFTF
	RREF$	WDB
	.IFT
	.PSECT	CS
	DIR$	#$$$,ERR
	.ENDC
	.ENDM	RREF$C
 
 
	.MACRO	RREF$S	WDB,ERR
	.MCALL	DIR$,MOV$
	MOV$	WDB
	MOV	(PC)+,-(SP)
	.BYTE	81.,2
	DIR$	,ERR
	.ENDM	RREF$S
 
 
;
; SREF$/SREF$C/SREF$S - SEND BY REFERENCE
;
 
	.MACRO	SREF$	TASK,WDB,EFN
	.MCALL	R50$,OFF$
	.IF NDF	$$$GLB
	.BYTE	69.,5
	R50$	TASK
	.WORD	EFN
	.WORD	WDB
	.ENDC
	.IF NDF	S.RETN
	.IRP	X,<,<S.RETN,4>,<S.REEF,2>,<S.REBA,2>>
	OFF$	X
	.ENDM
	.ENDC
	.ENDM	SREF$
 
 
	.MACRO	SREF$C	TASK,WDB,EFN,CS,ERR
	.MCALL	SREF$,DIR$
	.IF NDF	$$$GLB
	.PSECT	$DPB$$
$$$=.
	.IFTF
	SREF$	TASK,WDB,EFN
	.IFT
	.PSECT	CS
	DIR$	#$$$,ERR
	.ENDC
	.ENDM	SREF$C
 
 
	.MACRO	SREF$S	TSKADR,WDB,EFN,ERR
	.MCALL	DIR$,MOV$,RFA$
	MOV$	WDB
	MOV$	EFN
	RFA$	TSKADR
	MOV	(PC)+,-(SP)
	.BYTE	69.,5
	DIR$	,ERR
	.ENDM	SREF$S
 
 
;
; SRRA$/SRRA$C/SRRA$S - SPECIFY RECEIVE BY REFERENCE AST
;
 
	.MACRO	SRRA$	AST
	.MCALL	OFF$
	.IF NDF	$$$GLB
	.BYTE	21.,2
	.WORD	AST
	.ENDC
	.IF NDF	S.RRAE
	.NLIST
	OFF$
	OFF$	S.RRAE,2
	.LIST
	.ENDC
	.ENDM	SRRA$
 
 
	.MACRO	SRRA$C	AST,CS,ERR
	.MCALL	SRRA$,DIR$
	.IF NDF	$$$GLB
	.PSECT	$DPB$$
$$$=.
	.IFTF
	SRRA$	AST
	.IFT
	.PSECT	CS
	DIR$	#$$$,ERR
	.ENDC
	.ENDM	SRRA$C
 
 
	.MACRO	SRRA$S	AST,ERR
	.MCALL	MOV$,DIR$
	MOV$	AST
	MOV	(PC)+,-(SP)
	.BYTE	21.,2
	DIR$	,ERR
	.ENDM	SRRA$S
 
 
;
; UMAP$/UMAP$C/UMAP$S - UNMAP ADDRESS WINDOW
;
 
	.MACRO	UMAP$	WDB
	.MCALL	OFF$
	.IF NDF	$$$GLB
	.BYTE	123.,2
	.WORD	WDB
	.ENDC
	.IF NDF	U.MABA
	OFF$
	OFF$	U.MABA,2
	.ENDC
	.ENDM	UMAP$
 
 
	.MACRO	UMAP$C	WDB,CS,ERR
	.MCALL	UMAP$,DIR$
	.IF NDF	$$$GLB
	.PSECT	$DPB$$
$$$=.
	.IFTF
	UMAP$	WDB
	.IFT
	.PSECT	CS
	DIR$	#$$$,ERR
	.ENDC
	.ENDM	UMAP$C
 
 
	.MACRO	UMAP$S	WDB,ERR
	.MCALL	DIR$,MOV$
	MOV$	WDB
	MOV	(PC)+,-(SP)
	.BYTE	123.,2
	DIR$	,ERR
	.ENDM	UMAP$S
 
 
;
; .BLK./.BLKB./.BLKW.  - DEFINE BLOCK OFFSET SYMBOL
;
 
	.MACRO	.BLKB.	NUM,SYM,GBL
	.IF NB	<SYM>
	.IF IDN	<DEF$G>,<GBL>
SYM==$$$
	.IFF
SYM=$$$
	.ENDC
	.ENDC
$$$=$$$+NUM
	.ENDM	.BLKB.
 
 
	.MACRO	.BLKW.	NUM,SYM,GBL
	.IF NB	<SYM>
	.IF IDN	<DEF$G>,<GBL>
SYM==$$$
	.IFF
SYM=$$$
	.ENDC
	.ENDC
$$$=$$$+<2*NUM>
	.ENDM	.BLKW.
 
 
	.MACRO	.BLK.
$$$=0
	.ENDM	.BLK.
