.MCALL	.MODULE
.MODULE	LINK,VERSION=21,COMMENT=<PASS2 INITIALIZATION> IDENT=NO,MODNAME=LINK6,GLOBAL=.LINK6

;                       COPYRIGHT (c) 1989 BY
;           DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;                        ALL RIGHTS RESERVED
;
;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
;ONLY  IN  ACCORDANCE  WITH  THE TERMS  OF  SUCH  LICENSE AND WITH THE
;INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY OTHER
;COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS HEREBY
;TRANSFERRED.
;
;THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT NOTICE
;AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT
;CORPORATION.
;
;DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF ITS
;SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.

.SBTTL	PASS2 INITIALIZATION
.ENABL	GBL

; CER,MAS,SHD,DBB

.IIF NDF LDA$	LDA$=	1	;TURN ON LDA FEATURE
.IIF NDF REL$	REL$=	1	;TURN ON REL OUTPUT FEATURE
.IIF NDF EIS$	EIS$=	0	;SAY EIS NOT AVAILABLE
.IIF NDF RST$	RST$=	0	;TURN OFF RSTS/E SAV PARAMETER FUNCTION	;MAS17

; EDIT LOG SINCE LINK V05.02
; FIX OVERLAYED REL INFORMATION FROM LIBRARIES				;CER03
; PUT OVERLAY HANDLER IN SYSLIB						;MAS07
; XM OVERLAYS (ADDED FUNCTION)						;MAS15
; ADD RSTS/E SAV PARAMATERS FUNCTION					;MAS17
; ADD PROTECTION VIOLATION TO .ENTER AND .CLOSE				;MAS24
; FIX REL FILE RELOCATION OF OVERLAY HANDLER INFORMATION		;MAS25
; SAVE /V SEGMENET ADDR IN OVERLAY HANDLER TABLE FOR USE BY SIPP.SAV	;MAS28
; FIX .LIMIT FOR SETTOP ON /V FILES					;MAS30
; ADD /XM, /V ON FIRST LINE						;MAS35
; FIX VSECT RELOCATION BUG						;SHD01
; ADD GLOBAL CROSS REFERENCE						;DBB01
; CLEAN UP END-OF-FILE PROCESSING AND STACK MAINTENANCE			;DBB02
; STANDARDIZE PROGRAMMED REQUESTS					;DBB03
; ALLOW VALUE FOR /V ON FIRST LINE					;DBB04

.SBTTL	MISCELLANEOUS MACRO DEFINITIONS

.MCALL	.ENTER,.READW,.WRITW						;DBB03

.MACRO	ERROR$	ERNB,SEV,ETYP,R
	.IF NB R
	.IIF DIF <R>,<R0> 	MOV 	R,R0
	.IFF
	.IIF IDN <ETYP>,<E$FIL>	CLR	R0
	.ENDC
	JSR	R5,ERROOT
	.BYTE	ERNB,	SEV*100!ETYP
.ENDM

.IF Z EIS$
.MACRO	SOB	R,L
	DEC	R
	BNE	L
.ENDM
.ENDC

.PSECT 	DATA,D

	.WORD	12	;ERROR HANDLER INDEX(1ST PHYSICAL LOC OF OVLY)

.SBTTL	-	POST PASS TABLES AND MESSAGES

.NLIST	BEX
.ENABL	LC

	; THE FOLLOWING RAD50 VALUES ARE FOR THE OVERLAY HANDLER
	; THEY MUST BE IN THE FOLLOWING ORDER!!!!!!
.EVEN
PTBL:	.RAD50	/$OTABL/	;OVERLAY TABLE PSECT NAME		;MAS07
GDF5:	.RAD50	/$OVDF5/	;LOC AFTER WDB'S
GDF4:	.RAD50	/$OVDF4/	;START ADDR WDB'S
GREG:	.RAD50	/$OVDF3/	;/V XM REGION SIZE			;MAS15-
GHIO:	.RAD50	/$OVDF2/	;HIGH LIMIT OF /O OVERLAYS		;MAS07
GHIR:	.RAD50	/$OVDF1/	;HIGH ADDR OF ROOT SEGMENT		;MAS07
GSTRT:	.RAD50	/$OVRH/		;/O OVERLAY HANDLER ENTRY POINT		;MAS15
GSTRT1:	.RAD50	/$OVRHV/	;/V OVERLAY HANDLER ENTRY POINT		;MAS15

.PSECT 	CODE

.SBTTL	DOCASH	SETUP THE BUFFER CACHING I/O VARIABLES

DOCASH::CLR	LRUNUM		;INIT LEAST RECENTLY USED TIME STAMP
	MOV	LMLPTR,R4	;END OF LIBRARY MODULE LIST
	TST	(R4)+		;SKIP OVER 0 AT END
	MOV	STLML,-(SP)	;SAVE MAX # OF SECTIONS IN ANY ONE MODULE
	MOV	R4,STLML	;START OF MODULE SECTION LIST
	ASL	@SP		;TIMES 4 TO GET SPACE REQUIRED
	ASL	@SP		; (2 WDS PER ENTRY)
	ADD	(SP)+,R4	;SIZE OF MSL
	MOV	R4,BITBAD	;START OF SAV FILE MASTER BITMAP
	MOV	YSWNAM+2,R0	;SIZE OF SAV FILE IN BLOCKS
	MOV	R0,ENDRT	;SAVE FOR CACHE ROUTINES
	ADD	#15.,R0		;(SIZE + 15)/16. = WDS REQUIRED FOR BITMAP
	ASR	R0		;DIV BY 16.
	ASR	R0
	ASR	R0
	ASR	R0
10$:	CLR	(R4)+		;ZERO BLOCKS WRITTEN BITMAP OF SAV FILE
	DEC	R0		;WORD COUNTER
	BGT	10$		;HANDLE THE 1 WD CASE WHERE R0 STARTED 0
	MOV	R4,CACHER	;START OF CACHE CONTROL BLK
	MOV	R4,-(SP)	;SAVE IT FOR LATER
	MOV	NUMBUF,R0	;NUMBER OF BUFFERS TO CACHE
	MOV	R0,R1		;COPY IT
	ASL	R0		;TIMES 6 GIVES SIZE OF CACHE CTRL BLK
	ADD	R1,R0
	ASL	R0
	ADD	R0,R4		;END OF CACHE CTRL BLK

.IF NE REL$
	TSTB	SWITCH		;REL FILE OUTPUT ?
	BPL	20$		;NO IF +
	MOV	R4,ESZRBA	;START OF REL INFO OUTPUT BUFR
	MOV	R4,MODNAM	;INIT REL BUFFER PTR
	ADD	#512.,R4	;1 BLK IN SIZE
	MOV	R4,ENDLML	;END OF REL INFO BUFR
20$:
.ENDC				;REL$

	TST	CBPTR		;IS A CREF DESIRED?			;DBB01+
	BEQ	40$		;IF EQ NO
	MOV	R4,CBUF		;SET UP POINTER TO 1 BLK CREF BUFFER
	MOV	R4,CBPTR	;SET UP INITIAL CHARACTER POINTER
	ADD	#512.,R4	;UPDATE ADDRESS PTR BY 1 BLK
	MOV	R4,CBEND	;SET UP END OF BUFFER POINTER
	MOV	#-1,CBLK	;INITIALIZE CREF BLK NUMBER
40$:									;DBB01-
	MOV	(SP)+,R0	;R0 -> CACHE CTRL BLK
30$:	MOV	#-1,(R0)+	;INIT REL BLK # OF CACHE CTRL BLK
	CLR	(R0)+		;LEAST RECENTLY USED STAMP
	MOV	R4,(R0)+	;START BUFFER ADDRESS
	ADD	#512.,R4	;SIZE OF 1 BLK BUFR UPDATE ADR PTR
	SOB	R1,30$		;LOOP FOR # OF CACHED BUFRS
	CMP	OBUF,R4		;IF OBUF .GE. R4 THEN ALL ABOVE FITS
	BHIS	70$
	MOV	R4,IBUF		;UPDATE START OF INPUT BUFR
	SUB	OBUF,R4		;DETERMINE AMOUNT TO REDUCE I/O BUFR SPACE
	BIC	#777,R4		;DIV BY 512.
	SWAB	R4
	ASR	R4
	INC	R4		;# OF BLKS TO REDUCE IBUF BY
	SUB	R4,IBKINC	;# OF BLKS IN INPUT BUFR
	BLE	50$		;NOT ENOUGH I/O BUFR SPACE
	SWAB	R4		;WORD COUNT REDUCED BY
	SUB	R4,IBFSIZ	;INPUT READ WORD COUNT

.SBTTL	-	CLEAR & SETUP SYSCOM AREA OF IMAGE FILE

70$:	MOV	ZSWVAL,-(SP)	;SAVE /Z VALUE
	CLR	ZSWVAL		;BLOCK 0 MUST BE ZEROED
	CLR	R0		;R0 = REL BLK # TO ALLOCATE
	CALL	GETBUF		;GET ADR OF BLOCK 0 BUFR
	MOV	(SP)+,ZSWVAL	;RESTORE IT
	MOV	R1,R4		;COPY BUFR ADR
									;MAS30+
	BIT	#SW.V,FLGWD	;IS IT /XM?				;DBB04+
	BEQ	80$		;EQ -> NO
	MOV	LOC0,@R4	;IT IS, SO PUT VALUE IN LOC 0
	BR	90$

80$:	BIT	#XM.OVR,FLGWD	;IS IT /V OVERLAY?
	BEQ	100$		;EQ -> NO
	MOV	#^RVIR,@R4	;IT IS, PUT RAD50 VIR IN LOC 0

90$:	MOV	SEGBLK,2(R4)	;SEGBLK = NEXT FREE LOC, SO SUBTRACT	;DBB04-
	SUB	#2,2(R4)	;TO MAKE IT THE LAST LOCATION USED IN LOC 2
100$:	MOV	BEGBLK+S$YVAL,BEGIN(R4)	;PROG START ADDR		;MAS30-
110$:	MOV	#STKBLK,R3	;GET USER SUPLIED STK SYM ADR
	TST	@R3		;SYMBOL SUPPLIED ?
	BEQ	120$		;NO
	CLR	LKWD		;MUST BE A GLOBAL SYMBOL
	CALL	LOOKUP
	MOV	-(R0),R1	;GET SYMBOL'S ADDRESS
	BCC	140$		;ERROR IF UNDEF STACK ADR
	ERROR$	ERR32,E$W,E$PRT	;STACK ADDRESS UNDEFINED OR IN OVERLAY
	BR	130$		;USE DEFALULT ADR

120$:	MOV	4(R3),R1	;GET USER'S SUPPLIED STK ADR
	BNE	140$		;VALUE WAS GIVEN IF NE
130$:	MOV	BOTTOM,R1	;IND DEFAULT STACK ADR
140$:	MOV	R1,STACK(R4)	;STACK ADR IN SYSCOM AREA
	ADD	#HIGH,R4	;R4 -> HIGH LIMIT OF PROGRAM IN SYSCOM AREA
	MOV	HGHLIM,R1	;GET NEXT FREE ADDRESS			;MAS30
	SUB	#2,R1		;MAKE IT LAST LOCATION USED		;MAS30
	MOV	R1,(R4)+	;HIGH LIMIT				;MAS15
	BIT	SWITCH,#SW.K	;WAS /K GIVEN ?
	BEQ	150$		;NO IF EQ
	MOV	KSWVAL,4(R4)	;STORE IT AT LOC. 56 IN SYSCOM AREA
150$:	MOV	YSWNAM+2,R2	;R2 = 1ST FREE BLK AFTER PROGRAM PROPER
	TSTB	FLGWD		;IS PROGRAM OVERLAID?			;MAS07+
	BPL	180$		;NO IF +

;+
;		!!!!!! CAUTION !!!!!!					;MAS15+
; THE FOLLOWING CODE PICKS UP PTBL,GDF5,GDF4,GREG,
; GHIO,GHIR IN ORDER FROM THE TABLE ON PAGE 3. THAT TABLE
; AND THE CODE USING IT MUST REMAIN IN PROPER ORDER.
; IT DEPENDS ON LOOKUP:: ADDING 4 TO R3 IF IT WAS A SUCCESS.
;-

	MOV	#SY.SEC,LKWD	;SET UP TO LOOK UP OVERLAY TABLE
	MOV	#^CSY.SEC,LKMSK	;PSECT AND GET ITS START ADDRESS
	MOV	#PTBL,R3	;GET OVERLAY TABLE PSECT $OTABL
	CALL	LOOKUP		;LOOK IT UP
	BCC	51$		
50$:	ERROR$	ERR0,E$F,E$PRT	;FATAL INTERNAL ERROR			;MAS07
51$:	MOV	S.YVAL(R0),R1	;GET START ADDR OF PSECT
	MOV	R1,12(R4) 	;PUT VALUE INTO LOC 64 OF SYSCOM AREA
	MOV	LOC66,R0	;GET # /O SEGMENTS			;MAS28+
	BMI	160$		;MI -> NEVER WAS SET, DON'T INCLUDE IT
	ASL	R0		;MULT THIS BY THE # OF BYTES /SEG ENTRY,
	ADD	LOC66,R0	;WHICH IS SIX (THREE WORDS), AND THEN
	ASL	R0		;ADD IN START ADDR OF TABLE TO GIVE START
	ADD 	R1,R0		;ADDRESS OF THE /V SEGMENTS IN THE TABLE
	MOV	R0,14(R4)	;PUT VALUE INTO LOC 66 OF SYSCOM AREA	;MAS28-
160$:	ADD	OVCOUN,R1	;ADD IN TOTAL SIZE OF TABLES
	MOV	R1,HSWVAL	;SAVE VALUE FOR RELOCATION		;MAS25
	CLR	LKWD		;AND INSERT THAT VALUE INTO $OVDF5
	CALL	LOOKUP		;R3 -> GDF5: -> LOOKUP $OVDF5
	BCS	50$		;C=1 -> NOT FOUND -> ERROR
	MOV	R1,S.YVAL(R0)	;SET VALUE = TO END OF $OTABL PSECT + 2
	SUB	WDBCNT,R1	;GET START ADDR WDB'S
	CALL	LOOKUP		;R3 -> GDF4: -> LOOKUP $OVDF5
	BCS	50$		;C=1 -> NOT FOUND -> ERROR
	MOV	R1,S.YVAL(R0)	;SET VALUE = TO START OF WDB'S
	MOV	R1,WDBCNT	;SAVE START ADDR FOR USE IN CREATING SAV FILE
	CALL	LOOKUP		;R3 -> GREG: -> LOOKUP $OVDF3
	BCS	50$		;C=1 -> SYMBOL NOT FOUND -> ERROR
	MOV	HIPHYS,S.YVAL(R0) ;SET XM REGION SIZE			;MAS15-
	CALL	LOOKUP		;R3 -> GHIO: -> LOOKUP $OVDF2
170$:	BCS	50$		;SYMBOL NOT FOUND-SHOULDN'T HAPPEN
	MOV	HGHLIM,S.YVAL(R0) ;SET VALUE
	CALL	LOOKUP		;R3 -> GHIR: -> LOOKUP $OVDF1
	BCS	170$		;C=0 SYMB FOUND
	MOV	HLRT,S.YVAL(R0)	;SET VALUE
180$:	MOV	HLRT,R0		;HIGH LIMIT OF ROOT SEGMENT		;MAS07-

.IF NE REL$

.SBTTL	-	SYSCOM AREA FOR REL FILE

;+
;	OFFSET FROM BEGINNING OF BLOCK 0 ARE:
; 52	ACTUAL SIZE OF PROGRAM ROOT SEGMENT CODE IN BYTES
; 54	STACK SIZE IN BYTES (VALUE TO /R OR DEFAULT OF 128. BYTES)
; 56	SIZE OF /O OVERLAY REGIONS IN BYTES, 0 IF NO OVERLAYS
; 60	RAD50 /REL/ IDENTIFICATION WORD
; 62	RELATIVE BLOCK NUMBER OF START OF RELOCATION INFORMATION
;
; INPUT:R0 -> HIGH LIMIT OF ROOT
;-

	TSTB	SWITCH		;FOREGROUND LINK ?
	BPL	190$		;NO
	MOV	R0,@R4		;IND ROOT SIZE OF PROGRAM
	SUB	BOTTOM,(R4)+	;LESS BASE TO GET ACTUAL CODE SIZE
	MOV	KSWVAL,(R4)+	;SIZE OF STACK IN BYTES
	MOV	HGHLIM,@R4	;GET HI LIMIT /O OVERLAYS + ROOT & SUBT.;MAS15
	SUB	R0,(R4)+	;HI LIMIT OF ROOT -> SIZE /O OVERLAYS	;MAS15
	MOV	#^RREL,(R4)+	;REL FILE ID
	MOV	R2,(R4)+	;REL BLK # OF START OF RELOCATABLE INFO
	ASL	R2		;GUESS AT MAX SIZE OF FB REL FILE
190$:
.ENDC				;REL$

.IF NE LDA$
	TST	SWITCH		;IS THIS LDA OUTPUT ?
	BMI	INITP2		;YES, FILE WAS ENTERED & DON'T WRITE BLK 0
.ENDC				;LDA$

.SBTTL	-	ENTER SAV OR REL FILE IF ANY

	TST	ODBLK		;BINOUT REQUESTED?
	BEQ	INITP2		;NO

.IF NE RST$								;MAS17+
	MOV	@#RMON,R4	;GET RSTS/E R/W AREA POINTER
	TST 	@R4		;IS THIS RSTS/E?
	BNE	210$		;= -> RSTS/E

.IF NE REL$
	TSTB	SWITCH		;IS THIS FOREGROUND?
	BPL	200$		;+ -> NOT FORGROUND
	CLR	R2		;GUESS AT THE SIZE
200$:
.ENDC				;REL$

	MOV	#RSTSAV,R0	;GET RSTS/E SAV PARAMETER BLOCK POINTER
.REPT	5			;MOVE 5 PARAMETERS
	MOV	(R0)+,(R4)+	;PPN,PROTECT. CODE,USER MODE(TRY CTG IF DISK)
.ENDR				;CLUSTER SIZE,DCN POSITION TO CREATE AT	;MAS17-
.ENDC				;RST$

210$:	MOV	ODBLK+8.,R4	;WAS FILE SIZE GIVEN ?
	BEQ	220$		;NO IF EQ
	CMP	R4,R2		;IS IT .GT. THAN SIZE CALCULATED ?
	BLOS	220$		;IF YES, USE SUPPLIED SIZE FOR FILE
	MOV	R4,R2
220$:	.ENTER	#PRAREA,#0,#ODBLK,R2 ;ENTER BINOUT ON CHAN 0		;DBB03
	BCC	INITP2
	MOV	#ODBLK,R1	;POINT AT FILE NAME			;MAS24+
	CMPB	#PROTCT,@#ERRBYT ;IS THIS A PROTECTION VIOLATION?
	BNE	230$		;NE -> NOT PROTECTION PROBLEM
	ERROR$	ERR67,E$F,E$FIL,R1 ;PROTECTION VIOLATION

230$:	ERROR$	ERR16,E$F,E$FIL,R1 ;SAV DEV FULL			;MAS24-

.SBTTL	INITP2	SOME INITIALIZATION BEFORE GOING TO PASS 2

VSEC:	.RAD50	\. VIR.\	;VIRTUAL SECTION SYMBOL NAME

INITP2:
.IF NE REL$
	BIC	#FG.TT,FLGWD	;INIT VSECT FLAG			;SHD01
	MOV	#ASECT,OVSPTR	;-> 1ST OVERLAY SEGMENT BLK
	CLR	YSWNAM		;INIT OVERLAY REL COUNTER FOR "BLDREL"	;CER03
	MOV	#RELBAS+4,MODNAM+2 ;WORD OFFSET CORRECTION VALUE FOR "BLDREL"
	CLRB	NUMCOL		;ALL POSITIVE RELOCATIONS
.ENDC				;REL$

	CLR	VIRSIZ		;INITIALIZE FOR PASS 2			;MAS15
	BIT	#<XM.OVR!SW.V>,FLGWD ;/V OVERLAY, OR /XM?	;MAS35/MAS30+
	BEQ	10$		;EQ -> NO, HGHLIM IS OK
	MOV	SEGBLK,HGHLIM	;RESET .LIMIT VALUE TO /V HIGH		;MAS30-
10$:	CLR	SEGBLK		;INITIALIZE FOR PASS 2			;MAS15
	MOV	PA2LML,LMLPTR	;INIT FOR LIBRARY PROCESSING
	CLR	ESWVAL		;RESET NUMBER OF ENTRIES IN MODULE SECTION TBL
	MOVB	#1,LIBNB	;INITIAL LIBRARY FILE # FOR LML

.IF NE LDA$			;PTR ALREADY IN USE IF REL FILE
	TST	SWITCH		;ARE WE DOING AN LDA OUTPUT ?
	BPL	20$		;NO IF +
	MOV	IBUF,R0		;LDA OUTPUT BUFR JUST BEFORE
	SUB	#512.,R0	; OBJ INPUT BUFR
	MOV	R0,OBUF		;INIT OUTPUT BUFR ADR FOR LDA
	MOV	R0,MODNAM	;INIT THE LDA BUFR PTR
	CLR	OBLK		;INIT OUTPUT REL BLK #
20$:
.ENDC				;LDA$

.SBTTL	-	FORCE BASE OF ZERO FOR VSECT IF ANY

	MOV	#VSEC,R3	;R3 -> VIRTUAL SECTION SYMBOL
	MOV	#SY.SEC,LKWD	;SECTION NAME LOOKUP
	MOV	#^CSY.SEC,LKMSK	;CARE ABOUT SECTION FLG
	CALL	LOOKUP		;LOOK IT UP BUT DON'T ENTER IT
	BCS	30$		;C=1 IF NOT FOUND
	CLR	-(R0)		;CLEAR IT'S VALUE WORD (BASE = 0)
30$:	TSTB	FLGWD		;OVERLAID?				;DBB02
	BMI	PA2INT		;MI -> YES
40$:	JMP	PASS2

.SBTTL	PA2INT:: OVERLAY HANDLER AND TABLE SET UP FOR PASS2

; INITIALIZE TEXT INFORMATION FOR OUTPUT OF OVERLAY TABLE		;MAS07+

PA2INT::MOV	#2,TXTLEN	;MARK TEXT BLOCK EMPTY
	MOV	#TXTBLK+2,R4	;SET TEXT POINTER
	MOV	#SY.SEC,LKWD	;SET UP TO LOOKUP OVERLAY TABLE
	MOV	#^CSY.SEC,LKMSK ;PSECT IN ROOT AND
	MOV	#PTBL,R3	;GET ITS BASE
	CALL	LOOKUP		;SO WE KNOW WHERE TO START TXTBLK
	BCS	ILERR		;C=1->PSECT NOT FOUND->ERROR
	MOV	S.YVAL(R0),TXTBLK ;PICK UP BASE AND SAVE

;+
; IF DOING /V OVERLAYS, LINK INSERTED /V ENTRY POINT, $OVRHV,		;MAS15+
; BUT IT MAY NOT HAVE BEEN DEFINED IF THE HANDLER WAS NOT FOUND.
; THUS, THE /O ENTRY POINT, $OVHR, MAY NEVER HAVE BEEN INSERTED IF
; THE OVERLAY HANDLER WAS NOT FOUND.
;
; IF DOING /O OVERLAYS ONLY, LINK INSERTED THE /O ENTRY POINT, $OVRH,
; AND IT WILL BE PRESENT ON LOOKUP, ALTHOUGH IT MAY NOT BE DEFINED.
; $OVRHV MAY OR MAY NOT BE PRESENT IN THIS CASE, BUT IT ISN'T NEEDED.
;-

	CLR	LKWD		;SET UP FOR GLOBAL LOOKUP
	MOV	#GSTRT,R3	;LOOKUP /O ENTRY POINT
	CALL	LOOKUP
	BCC	10$		;C=1 -> SYMBOL NOT FOUND -> POSSIBLE ERROR
	BITB	#XM.OVR,FLGWD	;CAN BE MISSING IF DOING /V (THIS MEANS PROPER
				;OVERLAY HANDLER IS NOT PRESENT, AND /V ENTRY
				;POINT WILL PROBABLY BE UNDEFINED AS WELL.)
	BEQ	ILERR		;NOT = -> /V, OK TO BE MISSING
	CLR	HIPHYS		;CLEAR ENTRY POINT
	BR	20$

10$:	MOV	S.YVAL(R0),HIPHYS ;SAVE LOCATION OF /O ENTRY
	BITB	#XM.OVR,FLGWD	;TEST FOR /V OVERLAY
	BEQ	30$		;= -> NO /V OVERLAYS
20$:	MOV	#GSTRT1,R3	;LOOKUP /V ENTRY POINT
	CALL	LOOKUP
	BCS	ILERR		;C=1 -> SYMBOL NOT FOUND -> ERROR (MUST
				;BE PRESENT IF DOING /V)
	MOV	S.YVAL(R0),REGION ;SAVE LOCATION OF /V ENTRY		;MAS15-
30$:
.IF NE REL$
	MOV	#RELBAS+2,R2	;SETUP R2 WITH FIRST REL
	ADD	TXTBLK,R2	;INFORMATION
	SUB	BOTTOM,R2	;ADDRESS				;MAS07-
.ENDC
	SUB	#14.,WDBCNT	;BACKUP TO INITIALIZE			;MAS15+
	MOV	OVRG1,R5	;R5 -> OVERLAY REGION 1 BLK
	JMP	PA2OVL		;CREATE OVERLAY TABLE			;MAS15-

ILERR:	ERROR$	ERR0,E$F,E$PRT	;ILLEGAL ERROR				;MAS07

.SBTTL	OV6DUM:: DUMMY ENTRY POINT TO MAKE IT RESIDENT

OV6DUM::RTS	R5

.PSECT	PATCH

	.BLKW	64.	;PSECT FOR PATCHES

.END
