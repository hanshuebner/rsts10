.MCALL	.MODULE
.MODULE	LINK,VERSION=21,COMMENT=<INITIALIZATION LOGIC> IDENT=NO,MODNAME=LINK2,GLOBAL=.LINK2

;                       COPYRIGHT (c) 1989 BY
;           DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;                        ALL RIGHTS RESERVED
;
;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
;ONLY  IN  ACCORDANCE  WITH  THE TERMS  OF  SUCH  LICENSE AND WITH THE
;INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY OTHER
;COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS HEREBY
;TRANSFERRED.
;
;THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT NOTICE
;AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT
;CORPORATION.
;
;DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF ITS
;SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.

.SBTTL	INITIALIZATION LOGIC
.ENABL	GBL

; CER,MAS,SHD,DBB

.IIF NDF LDA$	LDA$=	1	;TURN ON LDA FEATURE
.IIF NDF REL$	REL$=	1	;TURN ON REL OUTPUT FEATURE
.IIF NDF EIS$	EIS$=	0	;SAY EIS NOT AVAILABLE
.IIF NDF RST$	RST$=	0	;TURN OFF RSTS/E SAV PARAMETERS FEATURE ;MAS17

; EDIT HISTORY:

; FIX /K BUG, SYMBOL TABLE SIZE HANDLING & EPT SIZE FOR RSTS		;CER01
; PUT OVERLAY HANDLER IN SYSLIB						;MAS07
; LIBRARY MODULES INTO OVERLAYS						;MAS10
; ADD /X LIBRARY PROCESSING						;MAS13
; XM OVERLAYS								;MAS15
; RSTS/E SAV PARAMETERS FEATURE						;MAS17
; /Q SWITCH ADDED							;MAS20
; ADD PROTECTION VIOLATION ON .ENTER AND .CLOSE				;MAS24
; FIX SEGMENT SELECTION FOR LAYERED REFERENCES TO LIBRARY		;MAS23
; FIX RSTS CONDITIONAL ERROR						;MAS26
; MORE RSTS/E FIXES							;MAS31
; RSTS/E FIXES								;SHD01
; MORE RSTS/E FIXES (STB FILE ERROR)					;SHD02
; CHANGE SYMBOL STATUS WORD FORMAT					;DBB01
; ALLOW /D PROMPTING							;DBB02
; ADD GLOBAL CROSS REFERENCE						;DBB03
; STANDARDIZE PROGRAMMED REQUESTS					;DBB04

.SBTTL 	****	MEMORY ORGANIZATION

;+
; THE LINK MEMORY MAP IS AS FOLLOWS AFTER THIS OVERLAY HAS COMPLETED
; INITIALIZATION.
;
; LOW
;		+-----------------------------------------------+
;		!	INTERRUPT VECTORS, SYSCOM AREA		!
;		*-----------------------------------------------*
;		!	OVERLAY LOADER, LINKER VARIABLES	!
;		!	& ROOT SEGMENT				!
;		*-----------------------------------------------*
;		!	ACTIVE OVERLAY AREA			!
;		*-----------------------------------------------*
;		!	DEVICE HANDLERS (WHEN REQUIRED) MIXED	!
;		!  WITH OVERLAY REGION & SEGMENT DESCRIPTORS	!
;		*-----------------------------------------------*
;	FILPT1-	!						!
;		!	SAVESTATUS AREA				!
;		!						!
;		*-----------------------------------------------*
;	QSWVAL-	!	/Q SWITCH BUFFER AREA			!	;MAS20
;		!						!
;		*-----------------------------------------------*
;	PA2LML-	!						!
;		!	LIBRARY MODULE LIST			!
;	ENDLML-	!						!
;		*-----------------------------------------------*
;	 IBUF -	!						!
;	EIB512-	!		INPUT BUFR			!
;		*-----------------------------------------------*
;	UNDLST-	!						!
;		!	SYMBOL TABLE (ALL THAT REMAINS)		!
;		!	-	-	-	-	-	!
;		!	USR SWAP AREA WHEN REQUIRED 2K		!
;	 HIGH -	!						!
;		*-----------------------------------------------*
;		!	FOREGROUND JOB IF ANY			!
;		*-----------------------------------------------*
;		!	RT-11 RESIDENT MONITOR			!
;		+-----------------------------------------------+
;
; THE INPUT BUFR, RESIDENT LIBRARY DIRECTORY, LIBRARY MODULE
; LIST, AND SYMBOL TABLE SIZES CAN BE DETERMINED DYNAMICALLY
;-

.SBTTL	****	MACRO DEFINITIONS

.MCALL	.SETTOP,.GTLIN,.ENTER						;DBB04

.MACRO	ERROR$	ERNB,SEV,ETYP,REG
	.IF NB REG
	.IIF DIF <REG>,<R0> 	MOV 	REG,R0
	.IFF
	.IIF IDN <ETYP>,<E$FIL>	CLR	R0
	.ENDC
	JSR	R5,ERROOT
	.BYTE	ERNB,	SEV*100!ETYP
.ENDM

.IF Z EIS$
.MACRO	SOB	REG,LABEL
	DEC	REG
	BNE	LABEL
.ENDM
.ENDC


.PSECT	DATA,D

	.WORD	2	;ERROR OVERLAY INDEX
			;MUST BE PHYSICALLY 1ST WD OF OVERLAY


.SBTTL	-	INITIALIZATION  & PROMPT MESSAGES

MINUS1	=	-1	;NAME FOR -1

; /Y temporary variable

COLFLG:	.WORD	0	;WHEN NONZERO, SAYS THAT THERE IS A : ON THE LINE

.NLIST	BEX
.ENABL	LC
STKMSG:	.ASCII	/Stack symbol? /<200>	;NO AUTO CR & LF
TAM:	.ASCII	/Transfer symbol? /<200>
IMSG:	.ASCII	/Library search? /<200>
DMSG:	.ASCII	/Duplicate symbol? /<200>				;011
EMSG:	.ASCII	/Extend section? /<200>
YMSG:	.ASCII	/Boundary section? /<200>
UMSG:	.ASCII	/Round section? /<200>
QMSG:	.ASCIZ	/Load section:address? /<200>				;MAS20

.EVEN

PHNDL:	.RAD50	/$OHAND/		;OVERLAY HANDLER PSECT		;MAS07+
PTBL:	.RAD50	/$OTABL/		;OVERLAY TABLE PSECT
GHNDL:	.RAD50	/$OVRH/			;/O OVERLAY HANDLER GBL ENTRY
GHIR:	.RAD50	/DF0/			;LOW LIMIT OVERLAY HANDLER GBL	;MAS07-
GBLS:	.RAD50	/$OV/			;1ST WD OF OVERLAY HANDLER GBLS	;MAS15
LOCTMP:	.WORD	0			;WORD TO STUFF FOR GLOBALS	;MAS15
GVHNDL:	.RAD50	/$OVRHV/		;/V OVERLAY HANDLER GBL ENTRY	;MAS15

.PSECT	CODE

.SBTTL	INIT	BUFFER INITIALIZATION

.SBTTL	-	ENTER OUTPUT FILES

INIT::

.IF NE	LDA$
	TST	SWITCH		;LDA PUTPUT?
	BPL	20$		;NO IF +
	TST	ODBLK		;OUTPUT WANTED?
	BEQ	20$

.IF NE RST$								;MAS17+;MAS26+
	MOV	#RSTLDA,R0	;GET POINTER TO RSTS/E SAVED PARAMETERS
	CALL	MOVRST		;MOVE TO R/W AREA IF RSTS/E		;MAS17-
.ENDC				;RST$					;MAS26-

	.ENTER	#PRAREA,#0,#ODBLK,ODBLK+8. ;AND ENTER LDA FILE		;DBB04
	BCC	20$
	MOV	#ODBLK,R1	;POINT AT FILE NAME FOR ERROR		;MAS24+
	CMPB	#PROTCT,@#ERRBYT ;IS THIS A PROTECTION VIOLATION?
	BNE	10$		;NE -> YES, PROTECTION ERROR
	ERROR$	ERR67,E$F,E$FIL,R1 ;FILE PROTECTION VIOLATION		;MAS24-

10$:	ERROR$	ERR16,E$F,E$FIL,R1 ;SAV DEV FULL
20$:

.ENDC				;LDA$

.IF NE RST$								;MAS17+
.IF NE REL$
	TSTB	SWITCH		;IS THIS A REL FILE?
	BMI	30$		;- -> YES
.ENDC				;REL$

	TSTB	RSTLDA+12	;IS THE .SAV DEVICE A DISK?
	BNE	30$		;= -> YES IT IS A DISK
	BIS	#64.!100000,RSTSAV+4 ;TRY FOR CTG SAV FILE
30$:									;MAS17-
.ENDC				;RST$

	MOV	#ODBLK+10.,R2	;POINT TO MAP FILE SPEC
	TST	@R2		;ANY MAP OUTPUT SPECIFIED?
	BEQ	60$		;IF EQ NO
	CMP	@R2,#^RTT 	;IS IT "TT:"?
	BNE	40$		;IF NE NO
	BIS	#FG.TT,FLGWD	;SET FLAG SAYING MAP DEVICE IS TERMINAL
40$:

.IF NE RST$								;MAS17+
	MOV	#RSTMAP,R0	;GET POINTER TO RSTS/E SAVED PARAMETERS
	CALL	MOVRST		;MOVE PARAMETERS IF RSTS/E		;MAS17-
.ENDC				;RST$

	.ENTER	#PRAREA,#1,R2,ODBLK+18.	;YES, ENTER IT			;DBB04
	BCC	60$
	MOV	#ODBLK+10.,R1	;POINT AT FILE NAME			;MAS24+
	CMPB	#PROTCT,@#ERRBYT ;IS THIS A PROTECTION VIOLATION?
	BNE	50$		;NE -> NOT PROTECTION VIOLATION
	ERROR$	ERR67,E$F,E$FIL,R1 ;FILE PROTECTION VIOLATION

50$:	ERROR$	ERR17,E$F,E$FIL,R1 ;MAP DEV FULL			;MAS24-

60$:	TST	ODBLK+20.	;STB FILE REQUESTED?
	BEQ	90$		;NO
	BIS	#FG.STB,FLGWD	;STB FILE REQUESTED
	BIT	SWITCH,#SW.S	;ALLOW FOR MAXIMUM SYMBOL TBL SPACE ?
	BEQ	70$		;NO IF 0
	TST	MBPTR		;MAP REQUESTED ALSO
	BEQ	70$		;NO IF 0
	ERROR$	ERR53,E$F,E$PRT	;STB NOT ALLOWED WITH /S AND A MAP

70$:

.IF NE RST$								;MAS17+
	MOV	#RSTSTB,R0	;GET POINTER TO RSTS/E SAVED PARAMETERS	;SHD02
	CALL	MOVRST		;MOVE PARAMETERS IF RSTS/E		;MAS17-
.ENDC				;RST$

	.ENTER	#PRAREA,#2,#ODBLK+20.,ODBLK+28. ;ENTER THE STB FILE	;DBB04
	BCC	90$		;NO ERROR
	MOV	#ODBLK+20.,R1	;POINT AT FILE NAME			;MAS24+
	CMPB	#PROTCT,@#ERRBYT ;PROTECTION VIOLATION?
	BNE	80$		;NE -> NOT PROTECTION PROBLEM
	ERROR$	ERR67,E$F,E$FIL,R1 ;PROTECTION VIOLATION

80$:	ERROR$	ERR20,E$F,E$FIL,R1 ;STB DEV FULL			;MAS24-

90$:	TST	CBPTR							;DBB03+
	BEQ	110$		;IF EQ NO
	.ENTER	#PRAREA,#11,#CRFSPC,#0	;ENTER THE CREF FILE		;DBB04
	BCC	110$		;C=0 -> NO ERROR
	MOV	#CRFSPC,R1	;POINT AT FILE NAME
	CMPB	#PROTCT,@#ERRBYT ;PROTECTION VIOLATION?
	BNE	100$		;NE -> NOT PROTECTION PROBLEM
	ERROR$	ERR67,E$F,E$FIL,R1 ;PROTECTION VIOLATION

100$:	ERROR$	ERR75,E$F,E$FIL,R1 ;CROSS REFERENCE DEVICE FULL

110$:	BIS	#100000,<-F.LNM-2>(R4)	;SET END OF INPUT BIT(R4-> 1ST WD OF FILENAME)

.SBTTL	-	MOVE SAVESTATUS AREA DOWN

120$:	MOV	(R4)+,(R3)+	;MOVE ALL FILE BLKS
	CMP	@R5,R4		;DONE?
	BHI	120$		;NO
	MOV	R3,R0		;R3 = 1ST FREE LOC ABOVE TBLS & CODE
	ADD	#-10.-4,R0	;R0 -> SAVESTATUS INFO OF 1ST FILE
	MOV	R0,FILPT1	; AND SAVE FOR PASSES(OVERLAY SEGMENT BLK PTR)
	.SETTOP	#-2		;GET ALL WE CAN IF IT ALREADY HAS NOT

.SBTTL	-	SETUP BUFFER FOR /Q SWITCH PARAMETERS

	MOV	R3,QSWVAL	;INITIALIZE START OF /Q BUFFER AREA	;MAS20+
	MOVB	QSWNUM,R1	;GET NUMBER OF /Q PSECTS ALLOWED
	ASL	R1		;AND THEN MULTIPLY TIMES
	ADD 	R1,R3		;SIX (6) AND ADD
	ASL	R1		;TO R3 FOR THE SIZE OF THE BUFFER
	ADD	R1,R3		;2 WORDS RAD50 NAME, 1 WORD ADDRESS
	MOV	QSWVAL,R1	;GET START OF /Q BUFFER
130$:	CLR	(R1)+		;NOW CLEAR THE BUFFER
	CMP	R1,R3		;ARE WE AT THE END OF THE BUFFER?
	BLO	130$		;LO -> NOT DONE YET			;MAS20-

.SBTTL	-	SETUP LML AREA

	MOV	#PA2LML,R1	;R1 -> LIBR MOD LIST INFO
	CLR	@R3		;0 END OF LIST
	MOV	R3,(R1)+	;BEGINNING OF LML BUFR
	MOV	R3,(R1)+	;INIT PTR TO LML
	MOV	R3,(R1)+	;INIT START OF LML (STLML)
				;R1 -> ENDLML WHERE SIZE OF LML IS STORED
	ASL	@R1		;SIZE OF LML LIST TIMES 6 TO MAKE BYTES
	ADD 	@R1,R3							;MAS10
	ASL	@R1
	ADD	@R1,R3		;SIZE OF LML TABLE
	MOV	R3,@R1		;ADR OF END OF LML (ENDLML)
	TST	(R3)+		;ALLOW FOR THE 0 AT THE END OF LIST

.SBTTL	-	SETUP INPUT BUFR PTRS

	BIT	SWITCH,#SW.L!SW.S ;IF /L OR /S GIVEN THEN
	BEQ	140$		;YES IF EQ, SO NUMBUF ALREADY SET
	MOV	#1,NUMBUF	;ONLY 1 CACHE OUTPUT BUFR
140$:	MOV	R3,IBUF		;START OF INPUT BUFR
	MOV	#<BUFSIZ*2>-512.,R2 ;GUESS AT BIG (BIASED) EPT SIZE	;CER01
	BIT	#SW.X,SWITCH	;GOOD GUESS?
	BNE	150$		;YES IF /X GIVEN (RSTS OPTIMIZATION)
	MOV	#BUFSIZ-512.,R2	;USE THIS (BIASED) FOR NOW (BYTES)	;CER01-
150$:	BIT	#SW.S,SWITCH	;WAS /S GIVEN ?
	BEQ	170$		;NO IF EQ
	MOV	#BUFMIN-512.,R2	;MINIMUM SPACE (BIASED) REQUIRED	;CER01
160$:	TSTB	SWITCH		;WAS /R GIVEN ALSO ?
	BPL	170$		;NO IF +
	ADD	#512.,R2	;REL INFO BLK REQUIRED

;+
; ALL THE NORMAL INPUT BUFFER SIZE CALCULATIONS ARE DONE. NOW,		;MAS13+
; CHECK TO SEE IF THERE IS ENOUGH ROOM FOR THE LARGEST /X
; LIBRARY EPT. IF THERE IS, THEN USE THE CALCULATED SIZE, IF NOT,
; USE THE SIZE OF THE LARGEST /X EPT FOR THE SIZE OF THE INPUT BUFFER.
; IF THERE ARE NO /X LIBRARIES IN THE LINK, THEN HIPHYS = 0,
; AND THE CALCULATED INPUT BUFFER SIZE WILL BE USED.
;-

170$:	MOV	HIPHYS,R1	;R1 = LARGEST /X EPT SIZE REQUIRED
	BIC	#511.,R1	;ROUND TO BIASED BLOCK BOUNDARY
	CMP	R2,R1		;IS CALCULATED EPT SIZE OK?
	BHIS	180$		;HIS -> OK, CALC. IS BIGGER
	MOV	R1,R2		;USE /X SIZE, SINCE ITS LARGER		;MAS13-
180$:	ADD	#512.,R2	;CORRECT FOR THE BIAS			;CER01+
	MOV	@R5,R1		;GET HIGH MEMORY LIMIT
	SUB	R3,R1		;LESS CURRENT FREE CORE PTR
	BLOS	190$		;UNDERFLOW, QUIT
	SUB	R2,R1		;LESS EPT SIZE
	BLOS	190$		;UNDERFLOW, QUIT
	CMP	R1,#40960.-10.	;MORE THAN ENOUGH LEFT?
	BHI	180$		;YES, GIVE THE EPT SOME MORE...		;CER01-
190$:	ADD	R2,R3		;UPDATE FREE CORE PTR
	ASR	R2		;NOW WORD SIZE
	MOV	R2,IBFSIZ	;INIT INPUT BUFR SIZE(WD CNT FOR .READ)
	SWAB	R2		;GIVES # OF BLOCKS THAT BUFR SIZE =
	MOV	R2,IBKINC	;INIT REL BLK UPDATE AMOUNT
	MOV	#-1,MBLK	;INIT REL BLK # OF MAP FILE
	MOV	R3,R1		;GET START OF SYMBOL TBL AREA(UNDEFINED LISTHEAD)
	TST	(R3)+		;0 TO END EPT SEARCH ROUTINE FOR LIBRARIES
	CMP	@R5,R3		;CHECK BEFORE CLEARING MEMORY
	BLOS	NOROOM		;IF PTR .GE. HIGH LIMIT, GIVE ERROR

.SBTTL	-	CLEAR SYMBOL TABLE AREA

	MOV	@R5,R2		;SET HIGH CORE LIMIT
200$:	CLR	(R1)+		;SET SYMBOL TBL TO ZEROES
	CMP	R1,R2		;DONE INITIALIZATION ?
	BLOS	200$

.SBTTL	SYPARM	DETERMINE SYMBOL TABLE PARAMETERS

;+
; THE SYMBOL TABLE END(LAST USED LOCATION) IS THE SAME AS THE
; VALUE IN LOC 50 OF THE SYSCOM AREA "HIGH". THE ABS ADR OF A SYMBOL =
; ENTRY # * 10. + ST OF SYM TBL, ALSO THE "ENTRY #" = (ABS ADR OF SYM
; - ST OF SYM TBL)/10. THIS DIFFERENCE MUST DIVIDE EVENLY BY 10..
; 2 WORDS MUST BE SET ASIDE FOR THE HEADCELL OF THE UNDEFINED LIST AND
; THIS IS ENTRY # 0.
;
; INPUT:R3 = FIRST LOCATION OF AVALABLE SPACE
;	R2 = HIGHEST LOCATION AVAILABLE FOR USE
;
; OUTPUT: STLEN, STSIZE, STINCR, STDIV
;-

.ENABL	LSB

SYPARM:	TST	(R3)+		;BESURE ROOM FOR UNDEF HEADCELL
	CMP	R3,R2		;LOW CORE ADR .LT. HIGH LIMIT?
	BHIS	NOROOM		;NO
	MOV	R2,R5		;COPY HIGH ADR
	SUB	R3,R5		;SPACE FOR SYM TBL
	CMP	#40960.-10.,R5	;LIMIT SIZE TO 4095. ENTRIES		;CER01
	BLO	SYPARM		;TOO BIG, THIS WAY IS SLOW BUT IT WORKS
	SUB	#10.,R5		;DON'T COUNT UNDEFINED HEADER ENTRY
	MOV	R5,R1		;PREPARE FOR DIV
	JSR	R5,DIV10
	BIT	#SY.ENB,R1	;SIZE MUST DIVIDE EVEN ?
	BNE	SYPARM		;NO IT DIDN'T, TRY AGAIN
	BIT	#1,R1		;# OF ENTRIES ODD ?
	BEQ	SYPARM		;NO, "ADD #10.,R3"
	MOV	R5,STLEN	;TABLE LENGTH IN BYTES
	MOV	R1,STSIZE	;SYMBOL TABLE SIZE  (# OF ENTRIES)

; DETERMINE SYM TBL INCREMENT(GREATEST POWER OF 2 .GT. # OF ENTRIES)/4 X 10.

	MOV	#10000,R2	;LARGEST POWER OF 2 = 4K
10$:	CMP	R2,R1		;POWER OF 2 .LE. TABLE LENGTH?
	BLOS	20$		;YES
	ASR	R2		;SMALLER POWER OF 2
	BR	10$

NOROOM:	ERROR$	ERR11,E$F,E$PRT	;INSUFFICIENT MEMORY

20$:	ASR	R2		;DIV BY 2
	MOV	R2,-(SP)	;TIMES 5
	ASL	R2
	ASL	R2
	ADD	(SP)+,R2
	CMP	#10.,R2		;MAKE SURE INCR IS AT LEAST 1 NODE
	BLOS	30$
	MOV	#10.,R2
30$:	TST	-(R2)		;LOOKUP PTR ALREADY HAD 2 ADDED
	MOV	R2,STINCR	;SYMBOL TABLE INCREMENT
40$:	ASL	R1		;NORMALIZE THE TABLE LENGTH TO THE LEFT
	BPL	40$
	MOV	R1,STDIV	;TO USE FOR DIVISIONS IN LOOKUP

.DSABL	LSB

.SBTTL	-	SET UP HEADCELL OF UNDEFINED SYMBOLS, ETC...

;+
; THE UNDEFINED SYMBOLS ARE BOTH FORWARD AND BACKWARD LINKED.
; R3 = ENTRY # 0(HEADCELL OF UNDEFINES)
;-

	MOV	R3,R0
	TST	-(R3)		;R3 -> VALUE WORD OF UNDEF ENTRY
	MOV	R3,UNDLST	;START OF THE FORWARD PTR LIST
	MOV	R0,(R3)+	;POINT HEADCELL TO ITSELF FOR START
	MOV	R3,SYEN0	;ENTRY # * 10. + THIS = PHY ADR OF SYM NODE
	CLR	(R3)+		;ENTRY # 0 PTR
	MOV	R3,SYNB1	;ADR OF 1ST REAL TBL ENTRY SYMBOL NAME


;+
; AT THIS POINT THE SYMBOL TABLE LOOKS LIKE THIS:
;		!	0	! AT LEAST ONE ZERO AT END OF INPUT BUFR TO STOP EPT SEARCHING
; 	 UNDLST-!   VALUE WD	! VALUE WD OF UNDEF SYM PTS TO PREVIOUS UNDEF SYM
; 		+---------------+ (ALSO ENTRY # PTR * 10. + THIS = ENTRY VALUE WD)
; 	SYEN0-	! STATUS WD	! ENTRY # OF STATUS WD PTS TO NEXT UNDEF SYM
;	SYNB1-	! 1ST WD OF NAME!
;		! 2ND WD OF NAME!
;		!  FLAGS	!
;		!  VALUE	!
;		!  STATUS	! ENTRY # 1
;			.
;			.
;	 HIGH-	! LAST ENTRY	!
;-

.SBTTL	DOABS	ENTER . ABS. INTO SYMBOL TABLE

DOABS:	MOV	#BEGBLK,R3	;R3 -> . ABS.
	MOV	#<CS$GBL+CS$ALO>*400+SY.SEC,LKWD ;SET PSECT FLAG BITS FOR ASECT
	CALL	LOOKE		; & IN ROOT SEGMENT
	MOV	R0,ASECT	;SET UP PTRS TO IT
	TST	SEGNUM		;OVERLAID IF NOT 0			;MAS07+
	BEQ	30$

;+
; IF THE PROGRAM IS OVERLAID, THEN THE OVERLAY HANDLER GLOBAL SYMBOLS
; $OVDF1,2,3,4,AND 5 MUST BE INSERTED IN THE ABS PSECT. THEY WILL
; BE GIVEN A VALUE OF 0 UNTIL THE MAP PASS, WHERE THEY WILL BE
; CORRECTLY DEFINED. ALSO THE OVERLAY HANDLER PSECT ($OVLHD) AND THE
; GLOBAL ENTRY POINT ($OVHR FOR /O, AND $OVHRV FOR /V) MUST BE
; ENTERED. THESE ARE FOLLOWED BY THE OVERLAY TABLE PSECT ($OTABL).
; THIS WILL ENSURE THAT THE OVERLAY HANDLER IS INSERTED FROM SYSLIB,
; AND THAT THE REQUIRED DEFINITIONS ARE AVAILABLE TO THE HANDLER.
;-

	MOV	R0,ENDOL	;CURRENT END OF SYMBOL TABLE LIST
	BIS	#FG.OVR,FLGWD	;PROGRAM IS OVERLAID
	MOV	#5,R2		;SET UP FOR 5 UNDF GBLS			;MAS15+
	MOV	GHIR,LOCTMP	;LOCTMP -> DF0
10$:	MOV	#GBLS,R3	;R3 -> STORAGE OF OVERLAY HANDLER GBLS
	INC	LOCTMP		;DO $OVDF1 TO $OVDF5
	CALL	DEFGBL		;INSERT AS DEFINED GBL
	DEC	R2		;GLOBAL COUNT
	BNE	10$		;0 -> DONE ALL 5 GLOBALS		;MAS15-
	MOV	#PHNDL,R3	;R3->$OVLHD
	MOV	#<CS$GBL+CS$REL>*400+SY.SEC,LKWD;SET PSECT FLAGS
	CALL	LOOKE		;AND IN ROOT SEGMENT
	JSR	R5,GEN		;LINK IN PSECT
	BIS	R1,@ENDOL	;CURRENT END OF SYB TBL LIST
	CLR	S.YVAL(R0)	;SET VALUE=0
	MOV	R0,ENDOL	;NEW END OF THIS SECTION
	MOV	#PTBL,R3	;R3->$OTABL
	MOV	#<CS$ALO+CS$GBL+CS$REL+CS$TYP>*400+SY.SEC,LKWD	;SET PSECT FLAGS
	CALL	LOOKE		;AND ROOT SEGMENT
	JSR	R5,GEN		;LINK IN PSECT
	BIS	R1,@ENDOL	;SET CURRENT END OF SYMBOL TBL LIST
	CLR	S.YVAL(R0)	;SET VALUE=0
30$:	MOV	R0,ENDOL	;CURRENT END OF SYMBOL TBL LIST		;MAS07-

.SBTTL	PROMPT	GET TRANSFER ADDRESS SYMBOL(DO PROMPTS IN A DOCUMENTED ORDER)

PROMPT:	MOV	SWITCH,R3	;R3 = SWITCH WORD
	BIT	#SW.T,R3	;GET /T SYMBOL ?
	BEQ	10$		;NO
	MOV	#TAM,R5		;R5 -> PROMPT MESSAGE
	MOV	#BEGBLK+6,R4	;R4 -> AREA FOR TRANSFER ADR
	CLR	@R4		;INDICATE BEGIN SYMBOL HAS BEEN SEEN
	MOV	#4*400,-(R4)	;SAY GLOBAL SYMBOL GIVEN FOR LOOKUP LATER
	CMP	-(R4),-(R4)	;BACK UP R4 TO SYMBOL AREA
	CALL	RPACK		;INTO (R4)

.SBTTL	-	GET STACK ADDRESS SYMBOL /M

10$:	BIT	#SW.M,R3	;/M ?
	BEQ	20$		;NO
	MOV	#STKMSG,R5	;YES, ASK FOR STACK ADDRESS
	MOV	#STKBLK,R4	;GET PTR
	CALL	RPACK		;AND PACK IT THERE.

.SBTTL	-	EXTEND SECTION NAME FOR /E

20$:	BIT	#SW.E,R3	;/E?
	BEQ	30$		;NO
	MOV	#EMSG,R5	;YES
	MOV	#ESWNAM,R4	;GET PTR
	CALL	RPACK

.SBTTL	-	BOUNDARY SECTION NAME FOR /Y

;+
; /Y LIST FORMAT: (THIS IS THE SAME FORMAT AS /Q)
;
; YSWNAM -> 	!-----------------------! 
;		! TWO WORD RAD50 	! 
;		! BOUNDARY NAME		!
; YSWVAL	!-----------------------!
;		! BOUNDARY VALUE	!
;		!-----------------------!
;			   :
;			   : REPEAT FOR EACH /Y BOUNDARY DEFAULT = 8 
;			   :
; 
;-

30$:	BIT	#SW.Y,R3	;/Y ?
	BEQ	40$		;NO
	MOVB	#MINUS1,YSWT	;SAY WE'RE PROCESSING /Y
	MOV	#YSWNAM,R4	;GET PTR TO SECTION NAME ARRAY 
	CMP	YSWVAL,#MINUS1	;DO WE PROMPT ?
	BNE	38$		;IF NOT, BRANCH
	MOV	#1000,DEFALT	;SET UP DEFAULT BOUNDARY VALUE
	MOVB	#8.,YCNT	;NUMBER OF TIMES TO PROMPT
32$:	TSTB	YCNT		;DO WE PROMPT ANY MORE?
	BEQ	39$		;IF NOT, BRANCH
	MOV	#YMSG,R5	;POINT TO THE PROMPT
33$:	CALL	RPACK		;PACK BOUNDARY NAME INTO RAD50
	BEQ	40$		;IF ONLY CR WE'RE DONE, SO BRANCH
	CMP	(R4)+,(R4)+	;POINT TO YSWVAL
	TST	COLFLG		;DID WE GET A : ON THE LINE?
	BNE	36$		;IF YES, BRANCH
	MOV	DEFALT,@R4	;PUT DEFAULT VALUE INTO YSWVAL
	BR	37$		;MERGE BELOW

36$:	CLR	COLFLG		;CLEAN UP FOR NEXT TIME
	CALL	ASCOCT		;CONVERT THE VALUE TO OCTAL
	BCS	33$		;IF ERROR, START THIS ENTRY AGAIN
	MOV	-(R4),DEFALT	;SAVE NEW DEFAULT VALUE
37$:	TST	(R4)+		;POINT TO NEXT YSWNAM
	DECB	YCNT		;DECREMENT PROMPT COUNT
	BR	32$		;GO AGAIN

38$:	MOV	#YMSG,R5	;POINT TO THE FIRST PROMPT
	CALL	RPACK
39$:	CLR	YSWT		;CLEAR FLAGS

.SBTTL	-	ROUND SECTION NAME FOR /U

40$:	BIT	#SW.U,R3	;/U?
	BEQ	50$		;NO					;MAS20
	MOV	#UMSG,R5	;YES, ASK FOR ROUND SECTION
	MOV	#USWNAM,R4	;GET PTR
	CALL	RPACK		;AND PACK IT THERE.

.SBTTL	-	/Q SWITCH TO ROUND PSECTS TO ABSOLUTE ADDRESSES

;+
; /Q LIST FORMAT:							;MAS20+
;
; QSWVAL -> 	!-----------------------! START OF /Q PSECT LIST IS RIGHT
;		! TWO WORD RAD50 PSECT	! AFTER SAVESTATUS BLOCKS
;		!     	NAME		!
;		!-----------------------!
;		! LOAD ADDRESS OF PSECT	!
;		!-----------------------!
;			   :
;			   : REPEAT FOR EACH /Q PSECT, DEFAULT = 8 ==QNUM
;			   :
; PA2LML ->	POINTS TO START OF NEXT BUFFER
;-

50$:	MOV	#QMSG,R5	;REQUEST PSECT/ADDRESS
	MOV	QSWVAL,R4	;IND INPUT PTR TO RPACK ROUTINE (LINK0)
60$:	TSTB	REGION		;ARE WE DONE WITH /Q SWITCH?
	BEQ	80$		;YES, NEXT SWITCH
	BIS	#100000,REGION	;SET BIT 15 AS FLAG TO RPACK THAT /Q
				;SWITCH IS THE ONE BEING PROCESSED
70$:	CALL	RPACK		;GET RAD50 PSECT NAME
	BEQ	80$		;DONE WITH INPUT
	CMP	(R4)+,(R4)+	;POINT TO AREA TO STORE ADDRESS
	CALL	ASCOCT		;INPUT ASCII ADDRESS, AND MAKE OCTAL

;+
; RETURN ON ERROR CONDITION -> POINTERS ARE ALREADY RESET
; PROPERLY. QUESTION WILL BE REPEATED, WITH ANSWER STORED
; IN SAME PLACE, AND QUESTION COUNT NOT DECREASED.
; THIS WILL OCCUR IF AN INVALID CHARACTER WAS ENTERED (NOT
; AN OCTAL CHARACTER), OR IF THE NUMBER ENTERED WAS ODD.
;
; R4 -> POINT TO AREA TO STORE RAD50 CHARACTER AGAIN
; R5 -> MESSAGE TO PROMPT WITH
; R0,R1,R2 -> RANDOM USELESS VALUES
;-

	BCS	70$		;C = 1 -> ERROR ON ADDR, REPEAT QUESTION
	DECB	REGION		;DECREASE QUESTION COUNT
	BR	60$		;AND LOOP UP TO QNUM TIMES

.SBTTL	-	/I SWITCH MODIFICATIONS START HERE

80$:	TST	REGION		;/Q SWITCH PROCESSED?
	BEQ	90$		;NO, OK
	MOV	#1,REGION	;SET /Q SWITCH NOT MINUS FOR RPACK	;MAS20-
90$:	BIT	#SW.I,R3	;INCLUDE GLOBALS ?
	BEQ	110$		;NO-BRANCH

; REQUEST THE USER TO ENTER THE GLOBALS TO BE SEARCHED FROM THE LIBRARY

	MOV	#IMSG,R5	;REQUEST USER SPECIFICATION
100$:	MOV	#TEMP,R4	;IND INPUT PTR TO RPACK RTN
	CALL	RPACK		;GET USER INPUT
	BEQ	110$		;NO BRANCH
	MOV	#SY.SWI,R2	;SET /I BIT				;MAS07+
	CALL	CRGBL		;CREATE SYMBOL TABLE ENTRY
	BR	100$		;LOOK FOR MORE GLOBALS TO LINK		;MAS07-

110$:	BIT	#SW.D,SWIT1	;DUPLICATE SYMBOLS?			;DBB02+
	BEQ	130$		;NO.  BRANCH
	MOV	#DMSG,R5	;POINT TO PROMPT MESSAGE
120$:	MOV	#TEMP,R4	;IND INPUT PTR TO RPACK RTN
	CALL	RPACK		;GET USER INPUT
	BEQ	130$		;IF NO INPUT, BRANCH
	CLR	R2		;DON'T SET /I BIT
	CALL	CRGBL		;CREATE SYM TBL ENTRY IN UNDEFINED LIST
	BCC	120$		;C=0 -> OLD SYMBOL, SO DON'T SET DUP BIT
	BIS	#SY.DUP,@R0	;SET DUP SYMBOL BIT
	BR	120$		;PROMPT FOR MORE DUPLICATE SYMBOLS	;DBB02-

.SBTTL	-	CALL PASS1 OVERLAY

130$:	BIT	#FG.OVR,FLGWD	;CHECK FOR OVERLAID PROGRAM		;MAS23+
	BEQ	140$		;EQ -> NOT OVERLAID -> SW.LML=0
	MOV	#GHNDL,R4	;R4->$OVHR (ASSUME /O TYPE)
	TST	TXTLEN		;/V OVERLYS?				;MAS15+
	BEQ	220$		;0 -> NOT /V CONTINUE
	BIS	#FG.OVR+XM.OVR,FLGWD ;/V -> SET OVERLAY AND XM BITS IN FLGWD
	MOV	#GVHNDL,R4	;RESET R4 TO /V ENTRY POINT ($OVRHV)
220$:	CLR	R2		;DON'T SET /I BIT			;MAS15-
	CALL	CRGBL		;INSERT INTO LIST UNDF GBL
	MOV	#1,SW.LML	;SW.LML=1 SETS UP FOR LIBRARY MODULES INTO
				;OVERLAYS, AND ALSO SLOWS PROCESSING 	;MAS23-
140$:	BIC	#GTLIN$,@#JSW	;RESET GET LINE BIT
	JMP	PASS1


.SBTTL	CRGBL	CREATE A GLOBAL SYMBOL ENTRY IN UNDEFINED LIST

;+
; THE FOLLOWING CODE CREATES A SYMBOL TABLE ENTRY IN THE
; UNDEFINED SYMBOL TABLE LIST. (THE USER HAS SPECIFIED THE
; SYMBOL NAMES THAT ARE PLACED IN THE UNDEFINED SYMBOL TABLE)
;
;	C=0 -> SYMBOL ALREADY IN TABLE
;	C=1 -> SYMBOL WAS CREATED
;-

CRGBL:	MOV	R4,R3		;SAVE INPUT PTR				;MAS07
	CLR	LKWD		;ATTRIBUTES WORD IS 0
	MOV	#^CSY.SEC,LKMSK	;CARE ABOUT SECTION FLAG		;DBB01
	CALL	LOOKE		;PUT UNDEF IN SYM. TAB.
	BCC	10$		;SYMBOL ALREADY IN TABLE, SO DO NOTHING	;DBB01
	MOV	UNDLST,R1	;START OF UNDEF LIST
	MOV	@R1,-(SP)	;SAVE PTR TO HEAD OF LIST
	MOV	R0,@R1		;ADR OF SYM TAB IN UNDEF LIST
	MOV	#SY.UDF,@R0	;MAKE CUR SYM UNDEFINED AND SET ITS	;DBB01+
				; LINK FIELD TO POINT TO UDF LIST HEAD
	BIS	R2,S.YSN(R0) 	;R2>1 SYMBOL DONE BY /I
	JSR	R5,GEN		;PRODUCE AN ENTRY # PTR			;MAS07
	MOV	(SP)+,-(R0)	;IND BKWD PTR TO HEAD UNDEF LIST
	BIC	#^CSY.ENB,@(R0)	;SET LINK FIELD OF OLD LAST UNDEF SYM
	BIS	R1,@(R0)+	; TO POINT TO CURRENT SYM
	SEC			;SET CARRY TO INDICATE NEW SYMBOL	;DBB01-
10$:	RETURN

.SBTTL	DEFGBL	INSERT DEFINED GLOBAL INTO SYMBOL TABLE

;+
; $OVDF1 AND $OVDF2 IN OVERLAY HANDLER MUST BE INSERTED INTO		;MAS07+
; THE SYMBOL TABLE AS DEFINED GLOBALS. THE VALUE WILL BE SET
; AT ZERO INITIALLY. THE MAP OVERLAY WILL INSERT THE CORRECT VALUE
; WHEN IT IS KNOWN. THESE TWO GLOBAL SYMBOLS WILL NOT APPEAR
; ON THE MAP.THIS IS BECAUSE THE CORRECT VALUE FOR THEM WILL NOT BE KNOWN
; WHEN THE MAP IS PRINTED.
;-

DEFGBL:	CLR	LKWD		;GLOBAL SYMBOL LOOKUP
	MOV	#^CSY.SEC,LKMSK	;CARE ABOUT SECTION FLAG
	CALL	LOOKE		;ENTER SYMBOL
	JSR	R5,GEN		;GET ENTRY POINTER
	BIS	R1,@ENDOL	;CURRENT END OF LIST POINTER
	MOV	R0,ENDOL	;NEW END OF ROOT
	BIC	#SY.SEG,S.YSN(R0) ;CLEAR SECTION NUMBER
	CLR	S.YVAL(R0)	;CLEAR VALUE
	BIC	#^CSY.ENB,@R0	;CLEAR ENTRY POINTER BITS
	RETURN								;MAS07-

.SBTTL	RPACK	PACK RAD50 SYMBOL FROM TTY

;+
; INPUT: R4 -> AREA TO PUT 2-WORDS OF RAD50 FROM TTY
;	 R5 -> PROMPT MESSAGE
;
; OUTPUT:R4 & R5 UNCHANGED
;	 CONDITION CODES SET FROM FIRST RAD50 WORD
; CLOBBERS R0, R1, R2
;-

RPACK:	TST	-(SP)		;SPACE FOR CONTROL WORD
10$:	MOV	#40.*2+ODBLK,R1	;R1 -> INPUT LINE TEMP STORAGE AREA
	.GTLIN	R1,R5		;PRINT PROMPT MESG & GET A LINE
	MOV	#44,@SP		;@SP = MASK TO CONTROL PACKING
20$:	CLR	R2		;R2 = ACCUMULATOR, CLEAR IT
30$:	TST	@SP		;DID WE ALREADY HIT A LF?
	BMI	110$		;YES, DO NOT TRY A TTYIN
40$:	MOVB	(R1)+,R0	;GET ANOTHER CHARACTER, 0 IF END OF LINE
	BEQ	110$		;YES, CAN'T GET A CHARACTER
	SUB	#' ,R0		;CHECK FOR BLANK
	BEQ	90$		;YES, USE 0 RAD50 CODE
	SUB	#'$-40,R0	;CHECK FOR $
	BEQ	60$		;YES, USE 33 RAD50 CODE
	SUB	#'.-'$,R0	;CHECK FOR .
	BEQ	50$		;YES, USE 34 RAD50 CODE
	SUB	#'9+1-'.,R0	;CHECK FOR NUMERIC
	ADD	#'9+1-'0,R0	;C=1 IF 0 TO 9
	BCC	80$		;NO, GO TRY FOR ALPHA
	CMPB	(R0)+,(R0)+	;ADD 2, NUMERIC, ADD DELTA OF 36
50$:	INC	R0
60$:	ADD	#33,R0
	BR	90$		;AND PUT IT INTO THE WORD

70$:	SUB	#20,R0		;ADJUST DOWN BY 40 FOR LOWER CASE
80$:	SUB	#20,R0		;WE SUBTRACTED 60, NOW TRY FOR ALPHA
	BLE	120$		;100 OR 140 OR BADDIE
	CMP	#'Z-100,R0	;TRY ALPHA?
	BLO	70$		;NO, BUT MAY BE LOWER CASE
90$:	TSTB	@SP		;GOT A CHARACTER. ARE WE SKIPPING?
	BEQ	30$		;YES, IGNORE IT
100$:	ASL	R2		;MULTIPLY ACCUMULATOR BY 50
	ASL	R2
	ASL	R2
	ADD	R2,R0		;ADDING IN THE CHARACTER
	ASL	R2
	ASL	R2
	ADD	R0,R2
	ASRB	@SP		;SHIFT MASK FOR WHAT TO DO
	BCC	30$		;STILL INSIDE A WORD, GET A CHARACTER
	MOV	R2,(R4)+	;DONE A WORD, GIVE IT TO CALLER
	BR	20$		;AND LOOP WITH CLEAN ACCUMULATOR

110$:	CLR	R0		;HERE IF GOT END OF LINE
	BIS	#100000,@SP	;SET FLAG SAYING END OF LINE FOUND
	TSTB	@SP		;ARE WE STILL WORKING?
	BNE	100$		;YES, USE A 0 BYTE FOR BLANK PADDING
	CMP	(SP)+,-(R4)	;NO, DONE POP STACK & ALINE R4
	TST	-(R4)		;SET CONDITION CODES
	RETURN

120$:	TST	REGION		;ARE WE DOING /Q SWITCH NOW?		;MAS20+
	BMI	125$		;IF YES, BRANCH
	TSTB	YSWT		;ARE WE DOING /Y
	BEQ	130$		;IF NOT, BRANCH
125$:	CMPB	#':,-(R1)	;IS CHAR A ":"
	BNE	130$		;NOT EQUAL -> ERROR
	MOV	SP,COLFLG	;SAY WE GOT A :
	TSTB	(R1)+		;RESET POINTER PAST /
	BR	110$		;TREAT LIKE A <CR> WAS ENTERED		;MAS20-

130$:	MOVB	(R1)+,R0	;ERROR, SKIP TO END OF LINE
	BNE	130$
	ERROR$	ERR43,E$W,E$PRT	;ILLEGAL CHARACTER
	CMPB	#4,@SP		;DID WE MOVE R4?
	BLO	10$		;NO, RESTART
	TST	-(R4)		;YES, FIX IT
	TSTB	@SP		;WAS THE ERROR DURING SKIP?
	BNE	10$		;NO
	TST	-(R4)		;YES, FIX AGAIN
	BR	10$

.SBTTL	GEN	GET ENTRY NUMBER

;+
; INPUT: R1= PHYSICAL ADDR OF A SYMBOL TABLE NODE			;MAS07+
;
; OUTPUT:R1= 12 BIT ENTRY NUMBER
;-

GEN:	MOV	R0,R1
	SUB	SYEN0,R1	;TAKE AWAY ADR OF NODE 0
				;FALL INTO DIV10			;MAS07-

.SBTTL	DIV10	DIVIDE BY 10. FOR ENTRY NUMBER DETERMINATIONS

;+
; INPUT: R1 = VALUE TO DIVIDE, MUST BE LESS THAN 40960. OR 120000 OCTAL.
;
; OUTPUT: R1 = HIGH 4 BITS IS REMAINDER, LOW 12 BITS IS QUOTIENT
; ***** NOTE: THE INPUT MUST BE A MULTIPLE OF 10. SO THE REMAINDER BITS
; ARE ZERO FOR THIS PARTICULAR APPLICATION.
;-

DIV10:	MOV	#14,-(SP)	;SET LOOP COUNTER
10$:	CMP	#50000,R1	;DOES N/10 GO, CLEAR C IF NOT
	BHI	20$		;NO, DON'T SUBTRACT 10
	ADD	#130000,R1	;SUBTRACT OUT 10 SETTING C
20$:	ROL	R1		;MOVE IN NEW QUOTIENT BIT
	DEC	@SP		;LOOP UNTIL DONE
	BGT	10$
	TST	(SP)+		;POP CTR OFF

.SBTTL	OV2DUM:: DUMMY ENTRY POINT TO MAKE IT RESIDENT

OV2DUM::RTS	R5

.SBTTL	ASCOCT	ASCII TO OCTAL CONVERSION

;+
; THIS ROUTINE CHECKS A LINE OF INPUT FOR OCTAL CHARACTERS, AND THEN	;MAS20+
; ASSEMBLES THE ASCII CHARACTERS INTO A ONE WORD OCTAL NUMBER.
; THE RESULTING NUMBER IS THEN CHECKED TO SEE IF IT IS ODD.
; IF THE NUMBER IS ODD, OR AN ILLEGAL CHARACTER IS ENTERED, THEN
; AN ERROR MESSAGE IS PRINTED, AND THE ENTIRE LINE MAY BE ENTERED AGAIN
; (PSECT/ADDRESS).
;
; IF NO ADDRESS IS SPECIFIED, AN ERROR MESSAGE IS GIVEN, AND THE WHOLE
; LINE CAN BE REENTERED.
;
; THE LINE OF TEXT IS INPUT BY THE RPACK ROUTINE USING A GTLIN.
;
; INPUT IS TERMINATED AUTOMATICALLY AFTER 6 PSECT/ADDRESSES HAVE
; BEEN ENTERED, OR A <CR> IS INPUT ON A LINE BY ITSELF.
;
; INPUTS:
;	 R1 -> POINTS TO NEXT CHARACTER IN GTLIN BUFFER
;	 R4 -> POINTS TO STORAGE WORD FOR OCTAL NUMBER
;	 R5 -> MESSAGE FOR GTLIN IN RPACK ROUTINE
;
; OUTPUTS:
;	R5 - UNCHANGED
;	R4 -> NEXT WORD FOR /Q SWITCH STORAGE
;	R1 -> POINTER TO NEXT OR LAST CHAR IN GTLIN BUFFER
;	R0,R2 -> RANDOM
;-

ASCOCT:	CLR	@R4		;CLEAR STORAGE WORD
	TSTB	-1(R1)		;CHECK LAST CHAR FOR 0
	BEQ	10$		;0 -> RPACK GOT END OF LINE -> NO ADDRESS
	MOVB	(R1)+,R0	;SOMETHING MUST ALWAYS BE ENTERED FOR ADDRESS
	BNE	30$		;IF THE FIRST CHAR IS NOT A ZERO -> OK
10$:	ERROR$	ERR62,E$W,E$PRT	;NO ADDRESS GIVEN
	BR	70$		;REDO THIS LINE

20$:	MOVB	(R1)+,R0	;GET NEXT CHARACTER FROM INPUT LINE
	BEQ	40$		;0 -> DONE
30$:	CMPB	R0,#'0		;IS THE CHARACTER > OR = 0?
	BLO	50$		;LO -> NO, NOT VALID CHAR
	CMPB	R0,#'7		;IS IT LESS THAN 8?
	BHI	50$		;HI -> NO, NOT VALID CHAR
	BICB	#370,R0		;CLEAR ASCII BITS LEAVING OCTAL NUMBER
	ASL	@R4		;ROTATE STORAGE WORD
	ASL	@R4		;TO LET IT RECEIVE THE
	ASL	@R4		;NEXT DIGIT
	ADD	R0,@R4		;ADD IN NEW DIGIT
	BR	20$		;LOOP UNTILL INVALID CHAR, OR END OF LINE

; REACHED VALID TERMINATION. NOW CHECK FOR ODD NUMBER.

40$:	BIT	#1,@R4		;IS THE NUMBER ODD?
	BNE	60$		;NE -> ODD, ERROR
	TST	(R4)+		;RESET POINTER FOR NEXT PSECT/ADDRESS,
	;CLC			;AND TST CLEARS CARRY FOR VALID RETURN
	RETURN

; ERROR RETURNS

50$:	ERROR$	ERR43,E$W,E$PRT	;ILLEGAL CHARACTER
	BR	70$		;RESET POINTERS BEFORE RETURN

60$:	ERROR$	ERR61,E$W,E$PRT	;ODD ADDRESS
70$:	CMP	-(R4),-(R4)	;RESET STORAGE POINTER TO REPEAT THIS QUESTION
	SEC			;SET CARRY FOR REPEAT OF QUESTION
	RETURN								;MAS20-

.IF NE RST$								;MAS17+

.SBTTL	MOVRST	MOVE RSTS/E PARAMETERS FOR OUTPUT FILE TO R/W AREA

;	R0 -> RSTS/E SAVED PARAMETER AREA FOR OUTPUT FILE

MOVRST:	MOV	@#RMON,R1	;GET POINTER TO RSTS/E R/W AREA
	TST	@R1		;IS THIS RT-11 OR RSTS/E?
	BNE	10$		;= -> RSTS/E				;MAS31
.REPT	5			;MOVE 5 PARAMETERS
	MOV	(R0)+,(R1)+	;TO THE R/W AREA
.ENDR
10$:	RETURN								;MAS31

.PSECT	IMPURE,D,GBL

.SBTTL	IMPURE SAVE PARAMETER BLOCKS FOR RSTS

;+
; THESE WILL END UP IN THE ROOT BECAUSE OF THE PSECT DEFINITION
;-

RSTLDA::.BLKW	6		;RSTS/E .LDA PARAMETER BLOCK		;SHD01
RSTMAP:	.BLKW	6		;RSTS/E .MAP PARAMETER BLOCK		;SHD01
RSTSTB:	.BLKW	6		;RSTS/E .STB PARAMETER BLOCK		;MAS17-
.ENDC				;RST$

.PSECT 	PATCH

	.BLKW	64.		;PSECT FOR PATCHES

.END
