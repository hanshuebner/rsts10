.MCALL	.MODULE
.MODULE	LINK,VERSION=21,COMMENT=<LINK ROOT SEGMENT> AUDIT=YES,MODNAME=LINK0,GLOBAL=.LINK0

;                       COPYRIGHT (c) 1989 BY
;           DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;                        ALL RIGHTS RESERVED
;
;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
;ONLY  IN  ACCORDANCE  WITH  THE TERMS  OF  SUCH  LICENSE AND WITH THE
;INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY OTHER
;COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS HEREBY
;TRANSFERRED.
;
;THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT NOTICE
;AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT
;CORPORATION.
;
;DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF ITS
;SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.

.AUDIT	.LINK0,.LINK1,.LINK2,.LINK3,.LINK4
.AUDIT	.LINK5,.LINK6,.LINK7,.LINK8,.LNKEM
.SBTTL	ROOT SEGMENT
.ENABL	GBL

;CER,MAS,SHD,DBB

.IIF NDF LDA$	LDA$=	1	;TURN ON LDA FEATURE
.IIF NDF REL$	REL$=	1	;TURN ON REL OUTPUT FEATURE
.IIF NDF EIS$	EIS$=	0	;SAY NO EIS AVAILABLE
.IIF NDF RST$	RST$=	0	;TURN OFF RSTS/E SAV PARAMETER FUNCTION ;MAS17

; EDIT HISTORY

; COMMENT IMPURE AREA USES						;MAS06
; XM OVERLAYS								;MAS15
; ADD RSTS/E SAV PARAMETER FUNCTION					;MAS17
; ADD /Q SWITCH								;MAS20
; FIX SEGMENT SELECTION FOR LAYERED REFERENCES TO LIBRARY MODULES	;MAS23
; ADD PROTECTION VIOLATION ERROR ON .ENTER AND .CLOSE			;MAS24
; SAVE ADDR OF /V SEGMENTS IN OVERLAY HANDLER TABLE FOR USE BY SIPP.SAV	;MAS28
; FIX NEWBLK TO READ FORMATTED BINARY BLOCKS CORRECTLY			;SHD01
; FIX LOOKUP ROUTINES TO WORK WITH DUPLICATE SYMBOLS			;DBB01
; ADD GLOBAL LOCATIONS FOR DUPLICATE LIBRARY MODULE PROCESSING		;DBB02
; ADD GLOBAL CROSS REFERENCE						;DBB03
; CLEAN UP END-OF-FILE PROCESSING AND STACK MAINTENANCE			;DBB04
; REORGANIZE OVERLAY SCHEME						;DBB05
; STANDARDIZE PROGRAMMED REQUESTS					;DBB06
; ALLOW VALUES ON /V IN FIRST LINE					;DBB07

.SBTTL	 MISCELLANEOUS MACRO DEFINITIONS

TAB==	11
RECSIZ==128.	;MAXIMUM SIZE OF A FORMATTED BINARY RECORD IN BYTES
		;DOES NOT COUNT LEADING 1ST WORD OF 1 OR THE CHECKSUM BYTE
QNUM=	8.	;NUMBER OF /Q PSECTS ALLOWED				;MAS20

.MCALL	.CLOSE,.SRESET,.RCTRLO,.PRINT,.READW				;DBB06

.MACRO	ERROR$	ERNB,SEV,ETYP,REG	;THIS IS SPECIAL FOR ROOT
	.IF NB REG
	.IIF DIF <REG>,<R0> 	MOV 	REG,R0
	.IFF
	.IIF IDN <ETYP>,<E$FIL>	CLR	R0
	.ENDC
	JSR	R5,ERROVR		;ENTRY WHEN CALLED FROM ROOT
	.BYTE	ERNB,	SEV*100!ETYP
.ENDM

.IF Z EIS$
.MACRO	SOB	A,B
	DEC	A
	BNE	B
.ENDM
.ENDC

.SBTTL	-	LINK FLOW CHART FOR NEW OVERLAY STRUCTURE

;+
;	The following chart has the general flow of code for the RT-11 V05
;	LINKer, and a brief description of the function of each segment of
;	code. LINK0 is the root, all other modules are separate overlays.
;
;
;
; LINK0->	!-----------------------!	    !-----------------------!
;		!START::		!<----------!RESTRT::		    !
;		!entry point to LINK;	!	    !reset control O	    !
;		!root code		!	    !-----------------------!
;		!-----------------------!			.
;			    !				       /!\
;			   \!/					!
;			    "					!
; LINK1->	!-----------------------!			!
;		!START1::		!			!
;		!initialization code;	!			!
;		!CSI,FETCH,SAVESTATUS;	!			!
;		!switch processing	!			!
;		!-----------------------!			!
;			    !					!
;			   \!/					!
;			    "					!
; LINK2->	!-----------------------!			!
;		!INIT::			!			!
;		!buffer initialization;	!			!
;		!. ABS. psect,symbol	!			!
;		!table, and overlay 	!			!
;		!handler setup; switch	!			!
;		!prompts		!			!
;		!-----------------------!			!
;			    !					!
;			   \!/					!
;			    "					!
; LINK3->	!-----------------------!			!
;		!PASS1::		!			!
;		!GSD processing		!			!
;		!-----------------------!			!
;			    !					!
;			   \!/					!
;			    "					!
; LINK4->	!-----------------------!			!
;		!ENDP1::		!			!
;		!flag overlay table	!			!
;		!symbols; do . VIR.;	!			!
;		!/E extend section;	!			!
;		!initialization for map;!			!
;		!/Q, /U, /Y, /V, /H	!			!
;		!switch processing	!			!
;		!-----------------------!			!
;			    !					!
;			   \!/					!
;			    "					!

; LINK5->	!-----------------------!			.
;		!RESOLV::		!		       /!\
;		!resolve section starts;!			!
;		!output map		!			!
;		!-----------------------!			!
;			    !					!
;			   \!/					!
;			    "					!
; LINK6->	!-----------------------!			!
;		!DOCASH::		!			!
;		!cache buffer and syscom!------>!		!
;		!setup; pass2 init.	!	!		!
;		!-----------------------!	!		!
;			    !			! 		!
;			   \!/			! no		!
;			    "			!		!
;		!-----------------------!	! /O		!
;		!PA2INT::		!	!		!
;		!overlay initialization;!	! or		!
;		!only done with /O or /V!	!		!
;		!-----------------------!	! /V		!
;			    !			!		!
;			   \!/			! s		!
;			    "			! w		!
; LINK7->	!-----------------------!	! i 		!
;		!PA2OVL::		!	! t		!
;		!only with /O or /V;	!	! c		!
;		!create overlay tables	!	! h		!
;		!-----------------------!	! 		!
;			    !			!		!
;			   \!/			!		!
;			    "			!		!
;		!-----------------------!	!		!
;		!PASS2::		!<------!		!
;		!create output file;	!			!
;		!do TXT and RLD blocks;	!			!
;		!output cref temp file	!			!
;		!update syscom area;	!			!
;		!write cache buffers;   !			!
;		!switch processing	!			!
;		!-----------------------!			!
;			    !					!
;			   \!/					!
;			    "					!
; LINK8->	!-----------------------!			!
;		!GBLCRF::  output global!			!
;		!cref in map file if /N;!---------------------->!
;		!close files		!
;		!-----------------------!
;
; LNKEM->	!-----------------------!
;		!ERROVR::		!
;		!entered by any overlay	!
;		!(or root), via root	!
;		!-----------------------!
;
; LNKLB1 is an object library module that contains SAV file I/O
; routines that are duplicated in modules LINK6 and LINK7.
;-

.SBTTL	-	IMPURE TABLE

;+
;			IMPURE AREA IN LINK ROOT CODE
;		   AVAILABILITY FOR FUTURE USE OF LOCATIONS
;
; The accuracy of this table is not guaranteed.  Any new uses of impure
; root locations in LINK must be carefully studied. This table is to be
; used only as a guide.
;
; All locations are one (1) word in length, unless otherwise specified.
;
; KEY:
;
; SET=	OVERLAY SETS/USES LOCATION
; USES=	OVERLAY ONLY USES LOCATION
; CLR=	OVERLAY ONLY CLEARS LOCATION
; SAV=	MUST BE SAVED FOR USE IN ANOTHER OVERLAY
; (N)=	LENGTH IN WORDS
; -=	NOT ACCESSED BY ROOT
; ?=	LOCATION MAY BE AVAILABLE FOR USE IN OVERLAY

; LOCATION	SEGMENT
;			LINK1
;		LINK0	;END2	LINK2	LINK3	LINK4	LINK5	LINK6	LINK7
;
; BASE           -	?	?	SET	SAV	SAV	SAV	SET
; BEGBLK(4)      -	SET	USED	USED	SAV	USED	USED	USED
; CKSUM		 -	SET	?	?	?	SET	?	SET
; CSECT	     	 -	?	?	SET	?	SET	?	?
; EIB512	 -	?	?	?	SET	USED	?	?
; ENDLML	 -	SET	SAV	USED	?	?	SET	USED
; ENDRT	    	 -    CLR;USED	?	SET	?	?	SET	SAV
; ESWNAM(2)    	 -	SET	USED	SAV	USED	USED	?	SET
; ESWVAL	 -	SET	USED	SAV	USED	USED	SET	SET
; ESZRBA	 -	?	?	SET	?	?	SET	USED
; FILPT1	 -    SET;USED	USED	USED	?	?	?	USED
; HGHLIM	 -	?	?	SET	USED	SET	USED	USED
; HIPHYS	 -	SET	USED	?	SET	SET	SET	SET
; HSWVAL	 -	SET	SAV	SAV	USED	?	SET	USED
; IDENT(2)	 -	SET?	?	USED	USED	?	?	?
; KSWVAL	 -	SET	SAV	SAV	SAV	SAV	USED	?
; LIBNB(1/2)	 -	?	?	SET	?	?	SET	SET
; LMLPTR	 -	SET	?	SET	?	?	SET	SET
; LOC66		 - 	SET	SAV	SAV	SAV	SAV	USED	?
; MBLK		 -	?	SET	?	?	?	?	?
; MBPTR		 -	?	SET	?	SET	SET	?	SET
; MODNAM(2)	 -	SET?	?	USED	USED	?	SET	SET
; NUMCOL(1/2)	 -	SET	SAV	SAV	USED	USED	SET	SET
; ODBLK(5)	 USED	SET?	USED	?	USED	?	USED	USED
; OVCOUN	 -	SET	SAV	SAV	SET	SAV	USED	?
; OVSPTR	 -	SET	?	?	?	SET	SET	USED
; PA2LML	 -	SET	USED	SAV	USED	SAV	USED	?
; PAS1.5(1/2)	 SET	?	?	SET	SET	SAV	USED	SET
; QSWVAL	 -  	SET	USED	SAV	USED	?	?	?
; REGION	 -	SET	SET	?	SET	SET	SET	USED
; RSTSAV(5)*	 -	SET	SAV	SAV	SAV	USED	?	?
; SEGBAS	 -	CLR	?	SET	SET	SET	?	SET
; SEGBLK	 -	CLR	?	?	SET	SET	SET	SET
; STKBLK(5)	 -	SET	USED	SAV	SAV	SAV	USED	USED
; STLML		 -	SET	?	SET	SET	?	SET	USED
; SVLML		 - 	?	?	SET/L	?	?	?	?
; SWITCH	 -	SET	USED	USED	USED	USED	USED	USED
; SW.LML	 -	SET 	SAV	USED	?	?	?	?
; SYEN0		 -	?	SET	USED	USED	USED	SAV	USED
; TEMP(2)	 -	USED	USED	?	?	?	?	USED
; TXTBLK(RECSIZ/2) -	?	?	SET	SET	SET	SET	USED
; TXTLEN	 -	SET	USED	SET	?	?	SET	SET
; UNDLST	 -	?	SET	USED	SAV	USED	?	?
; USWNAM(2)	 -	SET	USED	SAV	USED	?	?	?
; USWVAL	 -	SET	SAV	SAV	USED	?	?	?
; VIRSIZ	 -	?	?	?	SET	SET	SET	SET
; WDBCNT	 -	SET	SAV	SAV	SAV	SAV	SET	SET
; YSWNAM(2)	 -	SET	USED	SAV	USED	SET	SET	SET
; YSWVAL	 -	SET	SAV	SAV	USED	?	?	?
;
; * 	RSTSAV is only present when RST$=1
;-

.SBTTL	-	ASECT THE RESTART BIT OF JSW

.ASECT
	.=44
	.WORD	20000

.SBTTL	-	INTERNAL VARIABLES FOR LINKER

.PSECT	DPURE,D								;MAS20+

.IF EQ	RST$								;SHD03+
LMLSIZ:: 252	;DEFAULT NUMBER OF LIBRARY MOD LIST ENTRIES
		; EACH ENTRY IS 6 BYTES LONG
.IFF
LMLSIZ:: 525	;RSTS NEEDS MUCH MORE FOR SYSTEM BUILDS
.ENDC									;SHD03-
LINPPG::.WORD	60.		;NUMBER OF LINES PER PAGE FOR MAP
QSWNUM::.BYTE 	QNUM		;NUMBER OF /Q PSECTS. CAN BE PATCHED
	.BYTE	0		; AND RAISED UP TO 177 OCTAL		;MAS20-
NOBOUT::.BYTE	0		; FLAG SET IF BIN OUTPUT TO NL:
	.EVEN

.PSECT	IMPURE,D,GBL

;+
; EVERYTHING IN THIS SECTION IS CLEARED AT THE START AND
; INITIALIZED AS REQUIRED.
;-

IMPURE::

	;DO NOT CHANGE ORDER OF FOLLOWING 3 AREAS
ODBLK::	.BLKW	15.		;BLOCK TO HOLD BINOUT SPEC		;MAS27
				;LNKOV1->STORE TIME TO ROLL OVER DATE	;MAS06
TEMP::	.BLKW	2		;TEMPORARY STORAGE
TXTBLK::.BLKB	RECSIZ		;SPACE FOR A FORMATTED BINARY RECORD
	.EVEN

	;SYMBOL TABLE PARAMETERS:
UNDLST::.BLKW		;START OF UNDEFINED SYMBOL LIST
SYEN0::	.BLKW		;ADR OF SYMBOL TABLE ENTRY NUMBER 0
			;REL PTR + THIS = ABS ADDR OF SYMBOL NODE
CSECT::	.BLKW		;PTR TO LATEST SECTION (PASS1)
	;NEXT 4 IN THIS ORDER
PA2LML::.BLKW		;START OF LML BUFR
			;LNKOV1->TEMP. SEGMENT POINTER			;MAS06
LMLPTR::.BLKW		;CURRENT PTR TO LIBRARY MOD LIST
STLML::	.BLKW		;CURRENT START OF LMLPTR IF MULTI-LIBR FILES
ENDLML::.BLKW		;END OF LIB MOD LIST
ESZRBA::.BLKW		;SIZE OF CURRENT LIBRARY EPT
			;RELOCATION INFO OUTPUT BUFR ADR
OVCOUN::.BLKW		;NO. OF OVERLAY ENTRY PTS.
OVSPTR::.WORD	ASECT	;PTR TO OVERLAY SEGMENT BLK
PAS1.5::.BLKB		;PASS 1.5 SWITCH(0 ON PASS1, 1 IF TO DO LIBRARY,
			;BIT 7 SET IF DOING LIBRARIES
DUPMOD::.BLKB		;1 IF LIB MOD IS DUP				;DBB02
			;0 IF LIB MOD IS NOT DUP			;DBB02
NUMCOL::.BLKB		;NUMBER OF COLUMNS WIDE FOR MAP
			;IND + OR - RELOCATION DURING PASS 2
LIBNB::	.BLKB		;LIBRARY FILE NUMBER FOR LML
	.EVEN
SWITCH::.BLKW		;SWITCHES FROM CSI (SEE "LINK1" FOR DETAILS)
SWIT1::	.BLKW		;SWITCHES FROM CSI (SEE "LINK1" FOR DETAILS)	;DBB02
FILPT1::.BLKW		;START OF SAVESTATUS AREA -4
.SBTTL	-	VARIABLES FOR PROGRAM BEING LINKED

HGHLIM::.BLKW		;MAX # OF SECTIONS IN ANY MODULE PROCESSED
			;HIGHEST LOCATION USED BY PROGRAM
BEGBLK::.BLKW	4	;TRANSFER ADDRESS BLOCK (4 WD GSD ENTRY)
			; TRANS ADDR OR REL OFFSET FROM PSECT

; KEEP STKBLK & HSWVAL TOGETHER FOR 4 WD GSD AREA USED IN SAV & REL OUTPUT

STKBLK::.BLKW	3	;USER STACK ADDRESS BLOCK(SYMBOL & VALUE)
			;LNKSAV->TEMP 4 WORD STORAGE FOR GSD RECORD	;MAS06
HSWVAL::.BLKW		;/H SWITCH VALUE
	; ESWVAL & ESWNAM MUST BE IN THAT ORDER
ESWVAL::.BLKW		;/E SWITCH VALUE
ESWNAM::.BLKW	2	;/E SWITCH NAME
KSWVAL::.BLKW		;/K SWITCH VALUE OR STACK SIZE FOR REL FILE
;YSWNAM::.BLKW	2	;/Y SECTION NAME ARRAY(TEMP OVERLAY # IN OV1 & SAV)
			;+2 NEXT ASSIGNABLE OUTPUT BLK(LNKMAP)
			;   RELOCATION INFO BLOCK #(LNKSAV)
;YSWVAL::.BLKW	22.	;/Y SWITCH VALUE ARRAY
YSWNAM::.BLKW	24.	;/Y SECTION NAME ARRAY(TEMP OVERLAY # IN OV1 & SAV)
			;+2 NEXT ASSIGNABLE OUTPUT BLK(LNKMAP)
			;   RELOCATION INFO BLOCK #(LNKSAV)
YSWVAL==YSWNAM+4	;/Y SWITCH VALUE ARRAY
	.WORD	0	;TERMINATOR
YSWT::	.BYTE	0	;SAY WE ARE USING /Y
YCNT::	.BYTE	0	;NUMBER OF TIMES TO PROMPT FOR /Y (SET IN LINK2)
DEFALT::.WORD	0	;DEFAULT BOUNDARY VALUE FOR /Y (SET IN LINK2)
USWVAL::.BLKW		;/U SWITCH VALUE
USWNAM::.BLKW	2	;/U SWITCH NAME
QSWVAL::.BLKW		;/Q BUFFER POINTER				;MAS20
ZSWVAL::.BLKW		;/Z SWITCH VALUE				;DBB05+
LRUNUM::.BLKW		;USED TO COUNT MAX # OF SECTIONS AND AS
			; TIME STAMP FOR SAV FILE CACHING
BITBAD::.BLKW		;-> START OF BITMAP TABLE
CACHER::.BLKW		;-> CACHE CONTROL BLOCKS
NUMBUF::.WORD	3	;NUMBER OF AVAILABLE CACHING BLOCKS (DEF=3)	;DBB05-
BASE::	.BLKW		;BASE OF CURRENT SECTION
CKSUM::	.BLKW		;CHECKSUM FOR STB & LDA OUTPUT
			;LNKOV1->TEMP LINK POINTER TO NEW REGION BLK	;MAS06
			;CURRENT REL BLK OVERLAY NUM
ENDRT::	.BLKW		;REMEMBERED END-OF-ROOT SYMBOL TBL LIST
VIRSIZ::.BLKW		;LARGEST REGION IN A PARTITION			;MAS15+
REGION::.BLKW		;XM REGION NUMBER
WDBCNT::.BLKW		;WDB TABLE SIZE ( 14. * NUMBER OF PARTITIONS)
HIPHYS::.BLKW		;HIGH LIMIT FOR EXTENDED MEMORY (96K MAX)	;MAS15-
SVLML::	.BLKW		;START OF LML LIST FOR WHOLE LIBRARY		;MAS23
SW.LML::.BLKW		;LML INTO OVERLAY SWITCH, AND PASS INDICATOR	;MAS23
LOC0::	.BLKW		;USED FOR CONTENTS OF LOC 0 IN SAV HEADER	;DBB07
LOC66::	.BLKW		;# /O SEGMENTS SAVED FOR CONVERSION TO ADDR OF	;MAS28
			; /V SEGS IN OVERLAY HANLDER TABLE		;MAS28
LSTFMT::.BLKW		;CREF LISTING FORMAT (0=80COL, -1=132COL)	;DBB03

	; NEXT 2 IN THIS ORDER FOR STB OUTPUT

MODNAM::.BLKW	2	;MODULE NAME
			;LDA OUTPUT BUFR PTR OR REL INFO BUFR PTR
IDENT::	.BLKW	2	;PROGRAM IDENTIFICATION
			;"RELADR" ADR OF RELOCATION CODE IN TEXT OF REL FILE
			;+2 "RELOVL" NEXT REL BLK OVERLAY #

.IIF NE RST$	RSTSAV::.BLKW	5 ;RSTS .SAV FILE PARAMETER BLOCK	;MAS17

.SBTTL	-	DUMMY OVERLAY SEGMENT DESCRIPTOR BLOCK (OSDB)

;+
; (ADDED ONES FOR EACH /O SWITCH) THIS ONE IS FOR THE ROOT
;-

ASECT::	.BLKW		;-> SYMBOL TABLE LIST FOR THIS SEG
			;ADDR OF . ABS. IN SYMTAB
			;ENTRY NUMBER POINTER WHEN NOT ROOT SEGMENT
	.WORD	BOTTOM	;-> ORDB FOR THIS SEG
	.WORD	0	;ID NO. OF SEGMENT
	.WORD	0	;BASE BLOCK OF SEGMENT
	.BLKW		;LENGTH OF SEGMENT
	.WORD	0	;-> NEXT OSDB THIS REGION OR 0 IF NONE

.SBTTL	-	OFFSETS OF OVERLAY SEGMENT DESCRIPTOR BLOCK (OSDB)

.ASECT
.=0
	.BLKW		;SYMBOL TABLE ENTRY # POINTER FOR THIS SEGMENT
S.GRGP::.BLKW		;-> ORDB FOR THIS SEGMENT
S.GID::	.BLKW		;SEGMENT ID # = 6*SEGMENT #
S.GBSB::.BLKW		;BASE BLOCK OF SEG IN SAVE FILE
S.GHCL::.BLKW		;HIGH CORE LIMIT OF SEGMENT
S.GNXP::.BLKW		;-> NEXT OSDB THIS REGION OR 0 IF NONE

.PSECT	IMPURE,D,GBL

.SBTTL	-	DUMMY OVERLAY REGION DESCRIPTOR BLOCK (ORDB)

;+
; THIS ONE IS FOR THE ROOT REGION, ONE FOR EACH DIFFERENT REGION
;-

	.BLKW		;REGION NUMBER (R.GNB)
OVRG1::	.BLKW		;-> NEXT ORDB (R.GNXP)
	.WORD	ASECT	;-> OSDB THIS REGION (R.GSGP)
HLRT::	.BLKW		;HIGH LIMIT OF AREA (R.GHL)
BOTTOM::.WORD	1000	;ST ADDR OF REGION AREA

IMPSIZ==.-IMPURE	;SIZE OF IMPURE AREA IN BYTES TO CLEAR

CBUF::	.BLKW		;START OF CREF BUFFER
CBEND::	.BLKW		;CBUF + 512. BYTES FOR A 1 BLOCK CREF BUFFER
QAREA::	.BLKW	10.	;EXTRA QUEUE ELEMENT				;DBB03-
PRAREA::.BLKW	5.	;AREA FOR PROGRAMMED REQUESTS			;DBB06

EIB512::.BLKW		;IBUF + 512. BYTES FOR A 1 BLOCK MAP BUFR
SEGBAS::.BLKW		;PASS 2 BASE ADR OF OVERLAY SEGMENT
SEGBLK::.BLKW		;PASS 2 BASE BLK OF OVERLAY SEGMENT
TXTLEN::.BLKW		;LENGTH OF TXT BLK FROM OBJ
LINLFT::.BLKW		;NUMBER OF LINES LEFT ON CURRENT MAP PAGE

.SBTTL	START, ERROR, END & RESTART

.PSECT	MAIN		;ROOT CODE

;+
; ENTER HERE TO CALL START OVERLAY
;-

	BR	RESTRT
START::	JMP	START1		;OVERLAY TO INITIALIZE & STARTUP

ERROR::	.PRINT			;PRINT FATAL ERROR MSG & RESTART
RESTRT::.RCTRLO
	.SRESET
	BR	START

.SBTTL	ERROOT:: ROOT ERROR TRANSFER ROUTINE

;+
; THIS ROUTINE IS IN THE ROOT SEGMENT TO TRANSFER CONTROL TO THE
; ERROR MESSAGE OVERLAY. THE RETURN PATH IS SAVE SINCE THE
; ERROR OVERLAY IS IN THE SAME REGION AS THE ORGINAL CALLING ROUTINE.
; THIS ROUTINE IS CALLED BY THE ERROR$ MACRO DEFINED IN EACH OVERLAY
; ROUTINE. A DUMMY ENTRY POINT IS CALLED TO ASSURE THE CALLING OVERLAY
; IS MADE RESIDENT AGAIN.  OV1DUM MUST BE A "RTS	R5"
; CALLING SEQUENCE:
;	JSR	R5,ERROOT
;	.WORD	ERROR CODE WORD
;-

ERROOT::MOV	(R5)+,(PC)+	;SAVE THE ERROR CODE WORD
ERCODE:: .BLKW
	MOV	ERRIDX,-(SP)	;GET THE OVERLAY INDEX #
			;***THIS MUST BE THE 1ST LOCATION IN EACH OVERLAY***
	ADD	#DUMTBL,@SP	;ADD IN START OF VECTOR TABLE
	MOV	@(SP)+,-(SP)	;THE RETURNS WILL CALL IT SINCE THE ADR IS ON STACK
	JMP	ERROVL		;PROCESS THE ERROR VIA THE ERROR OVERLAY

.PSECT	DPURE,D

DUMTBL:	.WORD	OV1DUM		;OVERLAY DUMMY ENTRY POINT VECTOR TABLE
	.WORD	OV2DUM		; ONE FOR EACH OVERLAY THAT HAS NON-FATAL ERRORS
	.WORD	OV3DUM
	.WORD	OV4DUM
	.WORD	OV5DUM
	.WORD	OV6DUM
	.WORD	OV7DUM
	.WORD	OV8DUM							;DBB03

.PSECT	MAIN

.SBTTL	LOOKUP:: SYMBOL TABLE SEARCH ROUTINE

;+									;DBB01+
; THIS ROUTINE HAS 4 ENTRY POINTS:
; 'DLOOKE' DOES A LOOKUP & IF NOT FOUND THEN ENTERS THE NEW SYMBOL INTO
;	   THE SYMBOL TABLE.  DOES NOT REQUIRE A SEGMENT NUMBER MATCH
;	   WHETHER THE SYMBOL IS A DUPLICATE OR NOT.
;
; 'LOOKUP' ONLY SEARCHES THE SYMBOL TABLE FOR A SYMBOL MATCH.  IF SYMBOL
;	   IS A DUPLICATE, THIS ROUTINE REQUIRES A SEGMENT NUMBER MATCH.
;
; 'LOOKE'  DOES A LOOKUP & IF NOT FOUND THEN ENTERS THE NEW SYMBOL INTO
;	   THE SYMBOL TABLE.  IF SYMBOL IS A DUPLICATE, THIS ROUTINE
;	   REQUIRES A SEGMENT NUMBER MATCH.
;
; 'SEARCH' THIS ROUTINE DOES A LOOKUP ONLY AND DOES NOT CARE WHETHER THE
;	   SYMBOL IS A DUPLICATE OR NOT.  THIS ROUTINE IS USED REPEATEDLY
;	   AFTER A SINGLE CALL TO 'DLOOKE'.
;
; NOTE!!!  INPUTS TO 'SEARCH' ARE THE SAME AS LISTED BELOW EXCEPT RO AND
;	   R3 MUST BE AS THEY ARE RETURNED BY 'DLOOKE'.
;	   
;
; ENTRY # = MOD(WD1 + WD2, STSIZE)
;
; INPUT:   R3  ->  1ST WORD OF SYMBOL TO BE LOOKED UP (2 RAD50 WORDS)
;	   LKWD =  VALUE TO ENTER OR LOOK FOR AS A MATCH ON THE SYM TBL
;		   FLAGS & SEGMENT # WORD
;	   LKMSK = MASK WORD WITH BITS SET WE DO NOT CARE ABOUT WHEN
;		   COMPARING FLAGS & SEGMENT # WORD WITH "LKWD"
;
; OUTPUT:  R0  ->  SYMBOL TABLE ENTRY STATUS WORD
;	   R3      ADD 4 IF FOUND (NOT ADDED IF LOOKUP & NOT FOUND)
;	   C = 0   IF SYMBOL FOUND (FOR LOOKE & DLOOKE ALREADY ENTERED)
;	   C = 1   IF SYMBOL NOT FOUND (FOR LOOKE & DLOOKE NOT FOUND BUT
;		   ENTERED)
;-

.SBTTL	LOOKE::  LOOKUP WITH ENTER

.ENABL	LSB

SEARCH::SUB	#6,R0		;ADJUST POINTER TO SYM'S WORD 2
	CMP	-(R3),-(R3)	;ADJUST POINTER TO SYMBOL NAME
	CLR	-(SP)		;JUST A LOOKUP
				; SO PUT A POSITIVE VALUE ON STACK
	BR	60$		;FIND NEXT OCCURRENCE OF SYMBOL

DLOOKE::SEC			;LOOKUP AND ENTER IF NOT FOUND
	ROR	-(SP)		;>=0 IF JUST A LOOKUP
	CLR	DUPMSK		;IGNORE DUP BIT
	BR	10$		;JOIN MAIN ROUTINE

LOOKUP::TST	(PC)+		;SKIP "SEC" & CLEAR CARRY
LOOKE::	SEC			;LOOKUP AND ENTER IF NOT FOUND
	ROR	-(SP)		;>=0 IF JUST A LOOKUP
	MOV	#SY.DUP,DUPMSK	;CONSIDER DUP BIT IN MATCH CRITERIA
10$:	CLR	DUPWD		;ASSUME SYMBOL IS NOT DUP		;DBB01-
	MOV	R5,-(SP)	;SAVE IT
	MOV	@R3,R0		;1ST RAD50 WORD
	BNE	20$		;0 = BLANK NAME
	MOV	(PC)+,R0	;USE SEGMENT # FOR BLANK SECTION NAME
SEGNUM:: .BLKW			;SEGMENT # CURRENTLY PROCESSING
	INC	R0		;SEG # START AT 0
	ASL	R0		;TIMES 4 (UP TO 3100/4 OCTAL SEGMENTS
				; CAN BE PROCESSED)
	ASL	R0
	MOV	R0,@R3		;REPLACE 0
20$:	ADD	2(R3),R0	;ADD 2ND WORD OF SYMBOL TO 1ST
	MOV	(PC)+,R5	;NORMALIZED SYMBOL TABLE SIZE
STDIV::  .BLKW			;NORMALIZED STSIZE USED FOR DIVISION
30$:	CMP	R5,R0		;CAN SUBTR BE DONE?
	BHI	40$		;YES
	SUB	R5,R0		;NO
40$:	CLC
	ROR	R5		;SHIFT DIVISOR
	CMP	(PC)+,R0	;SMALLER THAN TABLE SIZE?
STSIZE:: .BLKW			;LENGTH OF TABLE IN ITEMS (5 WDS/ITEM)
	BLOS	30$		;NO
	ASL	R0		;YES, R0 = ENTRY #
	MOV	R0,R5		; NOW TIMES 10
	ASL	R0
	ASL	R0
	ADD	R5,R0
	ADD	(PC)+,R0	;CALC ADDR OF TABLE ENTRY
SYNB1::  .BLKW			;ADDR OF ENTRY # 1 WD 1 ON SYM NAME
	MOV	(SP)+,R5	;RESTORE IT
	MOV	STSIZE,STCNT	;NUMBER OF ENTRIES TO SEARCH
50$:	TST	@R0		;EMPTY CELL?
	BEQ	100$		;YES
	CMP	(R0)+,@R3	;ARE THEY THE SAME 1ST WD
	BNE	60$		;NO, TRY NEXT NODE
	CMP	2(R3),@R0	;ARE 2ND WDS OF SYMBOL THE SAME?
	BEQ	70$		;YES
60$:	DEC	(PC)+		;ARE ALL ENTRIES USED?
STCNT:	 .BLKW			;SYMBOL TBL ENTRIES COUNTER
	BEQ	130$		;YES, ERROR: SYMBOL TABLE FILLED
	ADD	(PC)+,R0	;NO, INCREMENT SEARCH POINTER, LESS 2
STINCR:: .BLKW			;SYM TBL INC TO FIND NEXT EMPTY SLOT
	CMP	@#HIGH,R0	;AT END OF TABLE?
	BHI	50$		;NO
	SUB	(PC)+,R0	;YES, LENGTH OF TBL
STLEN::  .BLKW			;LENGTH OF TABLE IN BYTES
	BR	50$		;LOOK AGAIN

	; AT THIS POINT HAVE FOUND A MATCHING SYMBOL NAME, NOW
	; MUST CHECK FOR MATCHING ATTRIBUTES. R0 -> 2ND WD OF NAME

70$:	MOV	2(R0),-(SP)	;GET SYM TBL ATTRIBUTE WD
	BIC	(PC)+,@SP	;GET RID OF BITS WE DO NOT CARE ABOUT
LKMSK::  .BLKW			;MASK OF BITS DO NOT CARE ABOUT FOR A MATCH
	CMP	(PC)+,(SP)+	;DO THE ATTRIBUTES OF CONCERN MATCH ?
LKWD::   .BLKW			;FLAGS & SEGMENT # MATCH WORD
	BNE	60$		;NO, TRY AGAIN

	BIT	6(R0),(PC)+	;IS DUP BIT SET AND CARED ABOUT?	;DBB01+
DUPMSK:: .BLKW			;DUPMSK = SY.DUP IF DUP BIT IS CARED ABOUT
	BEQ	90$		;.EQ. -> NO.  RETURN FOUND SYMBOL
	MOV	#SY.DUP,DUPWD	;IF WE ENTER, IT MUST BE DUP
	BIT	#SY.SEG,2(R0)	;IS SYMBOL IN ROOT?
	BEQ	80$		;BRANCH IF SO
	MOV	2(R0),-(SP)	;GET SYM TBL ATTRIBUTE WD
	BIC	#^CSY.SEG,@SP	;ISOLATE SEG # OF ENTRY
	CMP	(SP)+,SEGNUM	;IF SEG # = SEGNUM, THEN WE HAVE A MATCH
	BNE	60$		;BRANCH IF NOT A MATCH TO TRY AGAIN

80$:	BIS	SEGNUM,2(R0)						;DBB01-
90$:	CMP	(R3)+,(R3)+	;ADD 4
	ADD	#6,R0		;R0 -> LAST WORD OF NODE
	TST	(SP)+		;GET RID OF CALLED ROUTINE INDICATOR
	RETURN			;C=0, SYMBOL FOUND RETURN

	; SYMBOL NOT FOUND, POSITIONED AT AN EMPTY TBL NODE

100$:	TST	(SP)+		;JUST A LOOKUP REQUESTED?
	BPL	110$		;+ IF NO ENTER WANTED
	MOV	(R3)+,(R0)+	;PUT NEW SYMBOL INTO TBL
	MOV	(R3)+,(R0)+
	MOV	LKWD,(R0)+	;ALSO THE ATTRIBUTE WORD
	TST	(R0)+		;R0 -> LAST WORD OF NODE
	MOV	(PC)+,@R0	;SET DUP BIT IF NECESSARY		;DBB01
DUPWD:	 .BLKW			;EITHER 0 OR SY.DUP			;DBB01
	BR	120$		;NOT FOUND BUT ENTERED

110$:	ADD	#8.,R0		;R0 -> LAST WORD OF NODE
120$:	SEC			;C=1 SYMBOL NOT FOUND
	RETURN			;SYMBOL NOT FOUND RETURN

130$:	ERROR$	ERR1,E$F,E$PRT	;SYMBOL TABLE OVERFLOW

.DSABL	LSB

.SBTTL	BYTE::	 GET NEXT INPUT BYTE INTO R0

;+
; INPUT: R4 -> CURRENT BUFFER POSITION
;	ENDBUF -> THE BYTE AFTER THE LAST BYTE OF THE CURRENT INPUT BUFFER
;
; OUTPUT:R0 = NEXT INPUT BYTE
;-

.ENABL	LSB
10$:	CALL	NEWBUF		;GET ANOTHER BUFFER
BYTE::	CMP	(PC)+,R4	;END OF INPUT BUFFER?
ENDBUF:: .BLKW
	BLOS	10$		;YES
	CLR	R0		;BECAUSE OF SIGN EXTEND
	BISB	(R4)+,R0	;GET BYTE IN R0
	RETURN
.DSABL	LSB

.SBTTL	NEWBLK:: GET NEXT FORMATTED BINARY BLOCK FOR INPUT

;+
; DATA STRUCTURE IS:	.BYTE 1,0	.WORD <LENGTH>	.BYTE <TYPE>,0
;
; INPUT: R4 -> CURRENT BUFFER POSITION
;
; OUTPUT:R4 -> 1ST DATA WORD OF NEW BLOCK
;	R5 = NUMBER OF DATA BYTES IN THE BLOCK.
;	R0 = TYPE CODE OF THE BLOCK
;-

NEWBLK::
10$:	CALL	BYTE		;GET NEXT INPUT BYTE
;	TSTB	R0		;IS BYTE A 0 ?				;SHD01
	BEQ	10$		;YES, SKIP ALL NULL BYTES
	DECB	R0		;NEW BLK ST WITH A 1
	BNE	10$		;MODE ERROR, NOT FB BLOCK
	CALL	BYTE		;SKIP HIGH BYTE OF F.B.
;	TSTB	R0		;HIGH BYTE A ZERO?			;SHD01
	BNE	10$		;INSURE ITS A FB BLOCK			;SHD01
	CALL	GETWD		;ASSEMBLE THE LENGTH WORD
	MOV	R0,R5		;COPY OF LENGTH
	SUB	#4,R5		;CALC CORRECTED LENGTH
	;BR	GETWD		;GET TYPE & IGNORE NULL BYTE
				; 'GETWD' WILL RETURN

.SBTTL	GETWD::	GET A WORD FROM OBJ FILE INTO R0

;+
; INPUT:	R4 -> CURRENT BUFFER POSITION
;	R5 = # OF DATA BYTES IN THE F.B. BLOCK
;
; OUTPUT:R5 IS REDUCED BY 2
;-

GETWD::	CALL	BYTE		;GET NEXT INPUT BYTE (LOW ORDER)
	MOV	R0,-(SP)	;SAVE IT
	CALL	BYTE		;GET HIGH ORDER BYTE
	SWAB	R0		;PROPER PLACE
	BIS	(SP)+,R0	;SET IN LOW ORDER PART
	SUB	#2,R5		;BOOKKEEP THE BYTE COUNT
RTSPC:	RETURN

.SBTTL	SKPBLK:: SKIP FB BLOCKS ON INPUT

;+
; INPUT:	R4 = CURRENT BUFR POSITION
;	ENDBUF = END OF CURRENT INPUT BUFFER
;	R5 = LENGTH OF BLOCK
;
; OUTPUT:R4 & ENDBUF UPDATED IF REQUIRED
;     DESTROYS R0
;-

SKPBLK::INC	R5		;INCLUDE CHECKSUM BYTE
10$:	ADD	R5,R4		;LENGTH TO CURRENT POSITION
	CMP	ENDBUF,R4	;GONE PAST END OF BUFR?
	BHI	RTSPC		;NO, JUST RETURN
	MOV	R4,R5		;YES, HOW MUCH INTO NEXT BUFR
	SUB	ENDBUF,R5	;# TO PASS OVER IN NEXT BUFR
	CALL	NEWBUF		;GET MORE
	BR	10$		;TRY AGAIN

.SBTTL	-	READ ERROR FOR INPUT FILE

HARDER:	ERROR$	ERR2,E$F,E$FIL	;READ ERROR IN <FILENAME>

.SBTTL	CLOSE::  READ/WRITE ERROR RECOVERY

CLOSE:: .CLOSE	#3		;CLOSE INPUT CHANNEL
	BCC	10$		;NO PROTECTION VIOLATION		;MAS24+
	CMPB	#PROTCT,@#ERRBYT	;IS THIS A PROTECTION VIOLATION?
	BNE	10$		;NE -> NO
	ERROR$	ERR66,E$W,E$FIL	;DUPLICATE FILES CREATED		;MAS24-
10$:	MOV	(PC)+,R0	;R0 -> LAST OPEN FILE
FILPT::  .BLKW			;PTR TO CURRENT INPUT FILE BLK
	TST	-(R0)		;IS THIS THE LAST INPUT FILE ?
	BMI	ENDPAS		;YES
	SUB	#S.VSIZ+2,R0	;R0 -> NEXT FILE BLK
	CALL	@(PC)+		;INIT NEXT FILE & VARIABLES
NXTFIL:: .BLKW			;ADR OF ROUTINE TO GOTO ON NEXT FILE
	;BR	NEWBUF		;AND GO READ FROM NEW FILE

.SBTTL	NEWBUF:: READ NEXT INPUT BUFFER

;+
; INPUT:CURBLK = RELATIVE INPUT BLK #
; 	WHILE PROCESSING R4 -> NEXT AVAILABLE BYTE
;	ENDBUF = END OF CURRENT BUFR(IF R4.GE.ENDBUF, BUFR IS EXHAUSTED
;
; OUTPUT: R4 -> START OF INPUT BUFR
;	ENDBUF = END OF INPUT BUFR
;	CURBLK = CURBLK + IBKINC
; DESTROYS R0!!!
;-

.ENABL	LSB
NEWBUF::MOV	(PC)+,R4	;STATUS OF BUFFER
IEOI::   .BLKW			;0=NORMAL, N = BUFR BEGINS AN
				;OVERLAY SEGMENT, PTS TO SEGMENT BLK
	BEQ	20$		;0 = NORMAL CASE
	;BUFFER BEGINS AN OVERLAY SEGMENT SO SET IT UP
	CLR	IEOI		;RESET BUFFER STAT
	TST	(PC)+		;DECIDE PASS(+=PASS1)
FLGWD::  .WORD	0		;VARIOUS FLAGS (SEE "LNKOV1" FOR DETAILS)
	BPL	10$		;PASS 1 IF +
	CALL	DMPID		;OUTPUT OVERLAY ID WORD
	BR	20$

10$:	MOV	R4,(PC)+	;START NEW SYMTAB LIST FOR OVERLAY
ENDOL::  .BLKW			;CURRENT END OF SYMTAB LIST
20$:	MOV	IBUF,R4		;ADDR OF BUFFER
	.READW	#IRAREA,#3	;READ A BUFFER FULL			;DBB06
	BCC	30$		;NO ERROR
	TSTB	@#ERRBYT	;0=EOF, 1=HARDWARE, 2=CHAN NOT OPEN
	BNE	HARDER		;NOT EOF SO GIVE ERROR
30$:	ASL	R0		;WORDS READ TO BYTES READ
	BEQ	CLOSE		;IF=0 THEN EOF SO CLOSE & CONT
	ADD	R4,R0		;NOW THE END OF BUFR
	MOV	R0,ENDBUF	;UPDATE ENDBUF
	ADD	(PC)+,@(PC)+	;UPDATE REL BLK #
IBKINC:: .BLKW			;INPUT BLOCK INCREMENT  IBFSIZ/256.
	 .WORD	CURBLK		;ADR OF CURRENT INPUT BLOCK
	RETURN
.DSABL	LSB

.PSECT	MAIN

.SBTTL	-	ENDPAS	END OF INPUT PASS

ENDPAS:: MOV	(PC)+,SP	;RESTORE SP AS IT WAS BEFORE FILE OPEN	;DBB04
EOFSP::	 .WORD	0		;SAVED SP TO MAKE STACK CLEAN UP EASIER	;DBB04
	BISB	#200,PAS1.5	;MARK BEGINING OF 2ND HALF OF PASS
	TST	FLGWD		;ARE WE ON PASS 2?
	BMI	10$		;YES
	JMP	PASS1		;GO FINISH UP PASS 1

10$:	JMP	PASS2		;GO FINISH UP PASS 2			;DBB04

.SBTTL	-	INPUT BUFFER INFORMATION

.PSECT	IMPURE,D,GBL

		;NEXT 5 WORDS MUST BE IN THIS ORDER
IRAREA:	.BLKW		;CHANNEL NUMBER AND .READ EMT CODE		;DBB06
CURBLK::.BLKW		;RELATIVE INPUT BLOCK NUMBER
IBUF:: 	.BLKW		;INPUT BUFR ADR(ALSO END OF OUTPUT BUFR (OBUF+512))
IBFSIZ::.BLKW		;INPUT BUFR SIZE (MULTIPLE OF 256) WORD COUNT
	.BLKW		;.READ WAIT INDICATOR				;DBB06

.SBTTL	-	CHANNEL 0 EMT REQUEST AREA

.PSECT	IMPURE,D,GBL

		;NEXT 5 WORDS MUST BE IN THIS ORDER
OAREA::	.BYTE	0		;CHANNEL 0
	.BYTE	10		;10 FOR READ, 11 FOR WRITE
OBLK::	.BLKW			;RELATIVE OUTPUT BLOCK #
OBUF::	.BLKW			;OUTPUT BUFR ADR
	.WORD	256.		;WORD COUNT
	.WORD	0		;0 TO INDICATE WAIT

.SBTTL	-	MAP OUTPUT .WRITW REQUEST AREA

		;NEXT 5 WORDS MUST BE IN THIS ORDER
	.BYTE	1	;OUTPUT CHANNEL #
	.BYTE	11	;WRITE EMT CODE
MBLK::	.BLKW		;OUTPUT BLK # (INIT TO -1 FOR BUMP BEFORE WRITE)
MBPTR::	.BLKW		;OUTPUT BUFR POINTER (0 MEANS NO MAP OUTPUT)
	.WORD	256.	;WORD COUNT
	.BLKW		;WAIT FOR COMPLETION INDICATOR			;DBB06

.SBTTL	-	CREF OUTPUT .WRITW REQUEST AREA

		;NEXT 5 WORDS MUST BE IN THIS ORDER
	.BYTE	11	;OUTPUT CHANNEL #				;DBB03+
	.BYTE	11	;WRITE EMT CODE
CBLK::	.BLKW		;OUTPUT BLK # (INIT TO -1 FOR BUMP BEFORE WRITE)
CBPTR::	.BLKW		;OUTPUT BUFR POINTER (0 MEANS NO MAP OUTPUT)
	.WORD	256.	;WORD COUNT
	.WORD	0	;INDICATE WAIT FOR COMPLETION

CRFSPC::.RAD50	/DK CREF  TMP/	;CREF FILE SPEC				;DBB03
FORLIB::.RAD50	/SY FORLIBOBJ/	;FORTRAN LIBRARY FILENAME
SYSLIB::.RAD50	/SY SYSLIBOBJ/	;DEFAULT SYSTEM LIBRARY FILENAME

.PSECT	PATCH

	.BLKW	64.		;PSECT FOR PATCHES

.END	START
