.MCALL	.MODULE
.MODULE	LINK,VERSION=21,COMMENT=<COMMON CODE FOR SAV FILE I/O> IDENT=NO,LIB=YES,MODNAME=LNKLB1

;                       COPYRIGHT (c) 1989 BY
;           DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;                        ALL RIGHTS RESERVED
;
;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
;ONLY  IN  ACCORDANCE  WITH  THE TERMS  OF  SUCH  LICENSE AND WITH THE
;INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY OTHER
;COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS HEREBY
;TRANSFERRED.
;
;THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT NOTICE
;AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT
;CORPORATION.
;
;DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF ITS
;SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.

.SBTTL	I/O ROUTINES FOR SAVE FILE
.ENABL	GBL

; DBB

.IIF NDF EIS$	EIS$=	0	;SAY NO EIS AVAILABLE

; EDIT HISTORY

.SBTTL	MISCELLANEOUS MACRO DEFINITIONS

.MCALL	.READW,.WRITW

.MACRO	ERROR$	ERNB,SEV,ETYP,R
	.IF NB R
	.IIF DIF <R>,<R0> 	MOV 	R,R0
	.IFF
	.IIF IDN <ETYP>,<E$FIL>	CLR	R0
	.ENDC
	JSR	R5,ERROOT
	.BYTE	ERNB,	SEV*100!ETYP
.ENDM

.IF Z EIS$
.MACRO	SOB	R,L
	DEC	R
	BNE	L
.ENDM
.ENDC

	.PSECT	CODE

.SBTTL	GETBUF:	GET AN OUTPUT BUFFER FOR SAVE FILE

;+
; DO SAVE FILE BLOCK CACHEING VIA A 3 WORD TABLE FOR EACH CACHED BLOCK OF
;	REL BLK #
;	LEAST RECENTLY USED COUNT
;	BUFFER ADDR
;
; INPUT:R0 = REL BLK # OF SAV FILE
;	NUMBUF = NUMBER OF BLOCKS TO CACHE
;	BITBAD = ADR OF MASTER SAV FILE BIT TABLE OF BLOCKS WRITTEN
;	CACHER = ADR OF CACHE CONTROL BLOCKS (3 WDS FOR EACH BLK)
;	LRUNUM = TIME STAMP FOR BUFFERS
;
; OUTPUT:R1 = BUFFER ADDRESS
;	CLOBBERS R0
;-

GETBUF::INC	LRUNUM		;BUMP LEAST RECENTLY USED COUNT
	MOV	R2,-(SP)	;SAVE USED REG
	MOV	R3,-(SP)
	MOV	R0,-(SP)	;SAVE REL BLK NUM
	CALL	BUFMAT		;IS BLK IN MEMORY
	BCC	20$		;C=0 IF YES
	CALL	BITST		;IS THIS 1ST ACCESS ?
	BNE	10$		;NO IF NE (NO EMPTY IN MEMORY IF NE)
	CALL	NWBF		;GET A NEW BUFR
	BR	20$

10$:	CALL	GETLRU		;NEED TO GET BACK USED BLOCK
	MOV	@SP,OBLK	;BLOCK TO READ
	CALL	READ0		;GET IT IN MEMORY
20$:	MOV	(SP)+,(R1)+	;SET REL BLOCK # IN CACHE TBL
	MOV	LRUNUM,(R1)+	;SET LRU COUNT IN CACHE TBL
	MOV	@R1,R1		;BUFFER ADR TO RETURN
	MOV	(SP)+,R3
	MOV	(SP)+,R2
	RETURN

.SBTTL	NWBF:	GET A NEW BUFFER FROM CACHE CTRL BLK LIST

;+
;	CLOBBERS R0,R1,R2,R3
;-

.ENABL	LSB
NWBF:	MOV	#-1,R0		;SETUP TO SEE IF EMPTY IN MEM
	CALL	BUFMAT		;GET EMPTY ?
	BCC	10$		;C=0 IF EMPTY AVAILABLE
	CALL	GETLRU		;GET LRU BLOCK
				;FILL BUFFER WITH /Z SWITCH VALUE
10$:	MOV	4(R1),R2	;BUFFER ADDR FROM CACHE CTRL BLK
ZSWFIL::MOV	#256.,R3	;WORD COUNT FOR BLK SIZE
20$:	MOV	ZSWVAL,(R2)+	;INIT BUFR
	SOB	R3,20$
	RETURN
.DSABL	LSB

.SBTTL	BUFMAT:	GET NUMBER OF AVAILABLE CACHING BLOCKS

;+
; INPUT:	R0 = REL BLOCK #
;
;OUTPUT:C = 0 IF REL BLOCK # CURRENTLY IN MEMORY
;	C = 1 IF NOT
;	CLOBBERS R2,R3
;-

BUFMAT:	MOV	NUMBUF,R2	;GET NUMBER OF AVAILABLE CACHING BLOCKS
	MOV	CACHER,R1	;ADDR OF CACHE CONTROL BLOCKS
10$:	CMP	@R1,R0		;IS DESIRED BLOCK IN THIS CACHE BLOCK
	BEQ	20$		;YES IF EQ & C = 0
	ADD	#6,R1		;BUMP TO NEXT CACHE CTRL BLK
	SOB	R2,10$		;LOOP FOR ALL CACHED BLOCKS
	SEC			;C = 1 FOR REL BLK # NOT IN MEMORY
20$:	RETURN

.SBTTL	BITST:	TEST AND SET BITS IN SAV FILE MASTER BIT MPA

;+
; TESTS AND SETS ACCESS BIT IN SAV FILE MASTER BITMAP
; INPUT:	R0 = REL BLK #
;
; OUTPUT:Z = 0 (NE) IF BLOCK ALREADY WRITTEN
;	Z = 1 (EQ) IF BLOCK NOT WRITTEN INTO
;	CLOBBERS R2 & R3
;-

BITST::	MOV	R0,R3		;MAKE COPIES OF REL BLK #
	MOV	R0,R2
	BIC	#^C7,R2		;CALC BIT IN BYTE
	BIC	R2,R3
	ASR	R3		;CALC BYTE # OFFSET IN BITMAP
	ASR	R3
	ASR	R3
	ADD	BITBAD,R3	;ADD IN START OF BITMAP TABLE
	MOVB	@R3,-(SP)	;GET OLD BYTE
	BISB	BITTBL(R2),@R3	;SET PROPER BIT
	BITB	BITTBL(R2),(SP)+ ;TEST IF BIT WAS SET
RTN:	RETURN

.PSECT	DPURE,D

BITTBL:	.BYTE	200,100,40,20,10,4,2,1

.PSECT	CODE

.SBTTL	GETLRU:	GET LEAST RECENTLY USED BLOCK FROM CACHED LIST

GETLRU:	MOV	NUMBUF,R2	;GET NUMBER OF CACHE BLOCKS
	MOV	CACHER,R0	;CONTROL BLOCK ADDR
	TST	(R0)+		;R0 -> LRU FIELD IN CTRL BLK
10$:	MOV	R0,R1		;NEW LRU PTR
20$:	ADD	#6,R0		;R0 -> NEXT LRU CTRL BLK
	DEC	R2		;LOOP TILL END OF LIST
	BEQ	WRTLRU		;BR IF DONE (IT RETURNS), R1->LRU CTRL BLK
	CMP	@R0,@R1		;IS NEW LRU < OLD LRU ?
	BHIS	20$		;BR IF NEWER
	BR	10$		;BR WITH NEW CANDIDATE

.ENABL	LSB

.SBTTL	WRIT0: & READ0: WRITE & READ ON CHANNEL 0
;+
;	CLOBBERS R0
;-

READ0:	TST	ODBLK		;OUTPUT FILE REQUESTED?
	BEQ	RTN		;NO IF 0
	TSTB	NOBOUT		; YEH, BUT IS OUTPUT TO NL: ?
	BNE	RTN		; THEN REALLY NOT ANY OUTPUT
	.READW	#OAREA,#0	;DO A READ ON CHANNEL 0
	BR	10$

.SBTTL	WRTLRU: WRITE LEAST RECENTLY USED BLOCK

;+
; INPUT: R1 -> CACHE CONTROL BLOCK LRU ENTRY
;
; OUTPUT:R1 -> CACHE CTRL BLK REL BLK #
;-

WRTLRU::MOV	-(R1),OBLK	;OUTPUT BLK #
	MOV	4(R1),OBUF	;OUTPUT BUFR ADR
WRIT0::	TST	ODBLK		;OUTPUT FILE REQUESTED?
	BEQ	RTN		;NO IF 0
	TSTB	NOBOUT		; YEH, BUT IS OUTPUT TO NL: ?
	BNE	RTN		; THEN REALLY NOT ANY OUTPUT
	.WRITW	#OAREA,#0	;DO A WRITE ON CHANNEL 0
10$:	BCC	RTN		;NO ERROR SO RETURN
	TSTB	@#ERRBYT	;READ OR WRITE BEYOND EOF?
	BEQ	20$		;YES
	ERROR$	ERR6,E$F,E$PRT	;SAV FILE I/O ERROR

20$:	ERROR$	ERR44,E$F,E$PRT	;STORING TEXT OUTSIDE OF PROGRAM BOUNDS

.DSABL	LSB

	.END
