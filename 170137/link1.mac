.MCALL	.MODULE
.MODULE	LINK,VERSION=21,COMMENT=<START LOGIC> IDENT=NO,MODNAME=LINK1,GLOBAL=.LINK1

;                       COPYRIGHT (c) 1989 BY
;           DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;                        ALL RIGHTS RESERVED
;
;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
;ONLY  IN  ACCORDANCE  WITH  THE TERMS  OF  SUCH  LICENSE AND WITH THE
;INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY OTHER
;COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS HEREBY
;TRANSFERRED.
;
;THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT NOTICE
;AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT
;CORPORATION.
;
;DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF ITS
;SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.

.SBTTL	START LOGIC
.ENABL	GBL

; CER,MAS,SHD,DBB,SMD

.IIF NDF LDA$	LDA$=	1	;TURN ON LDA FEATURE
.IIF NDF REL$	REL$=	1	;TURN ON REL OUTPUT FEATURE
.IIF NDF EIS$	EIS$=	0	;SAY EIS NOT AVAILABLE
.IIF NDF RST$	RST$=	0	;TURN OFF RSTS/E SAV PARAMETERS FEATURE ;MAS17

; EDIT HISTORY

; FIX /K BUG, SYMBOL TABLE SIZE HANDLING & EPT SIZE FOR RSTS		;CER01
; FIX /Y BUG, TEST FOR SWITCH H 					;MAS01
; FIX STATE RESTORATION ON BAD INPUT FILE				;MAS03
; PUT OVERLAY HANDLER IN SYSLIB						;MAS07
; LIBRARY MODULES INTO OVERLAYS						;MAS10
; ADD /X LIBRARY PROCESSING						;MAS13
; XM OVERLAYS								;MAS15
; RSTS/E SAV PARAMETERS FEATURE						;MAS17
; ADD SWITCH /G, DON'T SIZE EPT'S ON RT-11				;MAS18
; NEW ERROR MESSAGE ON SEGMENT NUMBER OVERFLOW				;MAS19
; /Q SWITCH ADDED							;MAS20
; FIX READ ERROR MESSAGE, AND SOME MINOR BUG FIXES			;MAS16
; ADD FILE PROTECTION ERROR ON .ENTER AND .CLOSE			;MAS24
; MAKE ERROR MESSAGES PRINT DD:FILNAM.EXT				;MAS27
; SAVE ADDR OF /V SEGMENTS IN OVERLAY HANDLER TABLE FOR SIPP.SAV TO USE	;MAS28
; SAVE STATUS OF // AND /C FOR RETYPING OF INCORRECT INPUT LINES	;MAS29
; MORE RSTS/E FIXES							;MAS31
; ADD /XM (/V ON 1ST LINE)						;MAS35
; FIX RESETTING OF SYSLIB/FORLIB IF ERROR IN 1ST OVERLAY LINE		;MAS36
; ADD FLAG BIT FOR /I LIBRARY PROCESSING				;SHD01
; FIX ILLEGAL SWITCH WHEN /C IS BEFORE /O OR /V ON A LINE		;SHD02
; INCREASE LML SIZE FOR RSTS						;SHD03
; CHANGE SYMBOL STATUS WORD FORMAT					;DBB01
; ALLOW /D PROMPTING							;DBB02
; CHANGE SOME GLOBALS FOR ERROR$					;DBB03
; FIX STACK POINTER MAINTENANCE BUG					;DBB04
; STANDARDIZE ERROR MESSAGES						;DBB05
; ADD GLOBAL CROSS REFERENCE						;DBB06
; ADD SUPPORT FOR WEAK GLOBAL SYMBOLS AND PSECTS WITH SAVE ATTRIBUTE	;DBB07
; STANDARDIZE PROGRAMMED REQUESTS					;DBB08
; ALLOW VALUES FOR /V ON FIRST LINE					;DBB09
;
;	19-APR-85	GEORGE THISSELL JR.
;	ALLOW FOR LOWER TO UPPER CASE CONVERSION OF SWITCHES
;

.SBTTL	****	LINK DEFINITIONS		****

;+
; THESE ARE THE GLOBAL DEFINITIONS USED THROUGH OUT THE LINKER.
; THE ONES THAT ARE NOT GLOBAL ARE USED ONLY IN THE INITIALIZATION OVERLAY.
;-

.SBTTL	****	OFFSETS INTO JOB'S SYSTEM COMMUNICATION AREA

BEGIN==	40	;JOB STARTING ADDRESS
STACK==	42	;INITIAL VALUE OF STACK POINTER
JSW==	44	;JOB STATUS WORD
	OVJOB==	1000	;BIT IN JSW TO INDICATE	AN OVERLAY JOB
	GTLIN$==10	;GETLINE FROM TTY IF NOT IN @ FILE
HIGH==	50	;PROGRAM'S HIGHEST AVAILABLE LOCATION(ROOT+/O OVERLAYS);MAS15
ERRBYT==52	;MONITOR ERROR INDICATOR
	PROTCT==3	;PROTECTION VIOLATION ERROR CODE		;MAS24
USERRB==53	;SYSTEM USER ERROR BYTE
	SUCCS$	==	1	;SUCCESS BIT
	WARN$	==	2	;WARNING GIVEN
	ERROR$	==	4	;ERROR GENERATED
	FATAL$	==	10	;FATAL ERROR OCCURED
	UNCON$	==	20	;Unconditional
RMON==	54	;CONTAINS THE START OF THE RESIDENT MONITOR

STOTAB==64	;START OF OVERLAY TABLE ($OTABL)			;MAS15

B$TMAP==360	;START OF CORE USE BITMAP OF IMAGE FILE

U$SRLC==266	;OFFSET INTO RMON = START OF USR

BUFSIZ==8.*512.	;SIZE OF INPUT BUFFER FOR PASS 1
BUFMIN==4*512.	;MINIMUM BUFFER SPACE REQUIRED
RELBAS==1000	;BASE ADDRESS OF REL FILE LINK
RELSTK=	128.	;DEFAULT REL FILE STACK SIZE IN BYTES

.SBTTL	****	OBJECT LIBRARY HEADER DEFINITIONS

F.BRHC=	1	;FORMATTED BINARY BLOCK FOR LIBRARY			;MAS13+
L.HLEN= 42	;RECORD LENGTH OF LIBRARY HEADER BLOCK
L.BR=	7	;LIBRARIAN CODE
L.HVER==305	;LIBRARY VERSION NUMBER (VERSION # = V03.05)
L$HEPT==40	;END OF LBR HEADER (1ST EPT ENTRY SYMBOL NAME)
L$HX==	10	;OFFSET OF /X FLAG IN LIBRARY HEADER
L$HEAB==30	;OFFSET OF EPT SIZE IN LIBRARY HEADER			;MAS13-

.SBTTL	****	RSTS/E DEFINITIONS

FIRQB=	402	;BASE LOCATION AT 402 OCTAL
FQFLAG=	24	;HANDLER INDEX OFFSET

.IF NE RST$								;MAS17+
FQPPN=	6	;PROJECT/PROGRAMMER NUMBER OFFSET
FQMODE=	22	;OFFSET OF MODE TO OPEN FILE WITH 
FQPROT=	26	;PROTECTION CODE OFFSET AND FLAG
FQCLUS=	34	;CLUSTER SIZE FOR FILE OFFSET
FQNENT=	36	;POSITION FOR FILE OFFSET
.SETFQB=	EMT!360	;SPECIAL SET FIRQB EMT TO RT11.RTS		;MAS17-
.ENDC		;RST$

.SBTTL	****	COMMAND STRING SWITCH MASKS

;+
; THE FOLLOWING ARE GLOBAL MASKS FOR THE "SWITCH" WORD IN THE ROOT SEGMENT,
; INDICATING VARIOUS SWITCHES WHICH WERE SPECIFIED IN THE COMMAND STRING.
;
; SWITCH::
;-

SW.A==	1	;ALPHABETIZE LOAD MAP ENTRIES
SW.B==	2	;SPECIFY BOTTOM ADRS (N)
SW.C==	4	;CONTINUE INPUT LINE
SW.E==	10	;EXTEND PROGRAM SECTION (NAME & SIZE)
SW.F==	20	;USE FORTRAN LIBRARY "SY:FORLIB.OBJ"
SW.I==	40	;INCLUDE SYMBOLS TO BE SEARCHED FROM LIBRARY
SW.H==	100	;LINK TO HIGH ADR (N)
SW.R==	200	;OUTPUT REL FORMAT & STACK SIZE		*** MUST BE BIT 7 ***
SW.K==	400	;PUT VALUE (N) IN HEADER BLOCK OF IMAGE FILE
SW.S==	1000	;MAXIMUM SYMBOL TABLE SIZE
SW.M==	2000	;USER'S STACK ADR (NUMBER OR NAME)
SW.T==	4000	;TRANSFER ADR (NUMBER OR NAME)
SW.U==	10000	;ROUND SECTION (N POWER OF 2)
SW.X==	20000	;DON'T XMIT BITMAP
SW.Y==	40000	;START SECTION ON MULTIPLE OF VALUE GIVEN
SW.L==	100000	;OUTPUT FILE IN "LDA" FORMAT	*** MUST BE BIT 15 ***

;+									;DBB02+
; THE FOLLOWING ARE GLOBAL MASKS FOR THE "SWIT1" WORD IN THE ROOT SEGMENT,
; INDICATING VARIOUS SWITCHES WHICH WERE SPECIFIED IN THE COMMAND STRING.
;
; SWIT1::
;-

SW.D==	1	;DUPLICATE SYMBOL					;DBB02-

.SBTTL	****	ADDITIONAL FLAG WORD BIT MASKS

;+
; THE FOLLOWING ARE BIT ASSIGNMENTS FOR VARIOUS FLAGS IN "FLGWD" WORD.
;
; FLGWD::
;-

XM.OVR==1	;SET IF /V OVERLAYS ARE USED				;MAS15
SW.V==	2	;SET IF /XM OR /V ON FIRST LINE ONLY			;MAS35
HD.EPT==4	;SET IF EPT HEADER IS NOT CURRENTLY IN CORE
LB.OBJ==10	;SET WHEN PROCESSING A LIBRARY FILE
AD.LML==20	;SET TO ADD TO LML LATER
FG.LIB==40	;SET WHEN FORLIB OR SYSLIB ENTERED IN SAVESTATUS AREA
NO.SYS==100	;SET WHEN SYSLIB NOT FOUND
FG.OVR==200	;INDICATE PROGRAM IS OVERLAYED	*** MUST BE BIT 7 ***
FG.NWM=	400	;SET SO NO WARNING MSG FOR FILE NOT FOUND ON SYSLIB
FG.STB==1000	;STB FILE REQUESTED
FG.XX==	2000	;DO NOT DUMP CCB (USED WITH /X SWITCH)
FG.TT==	4000	;MAP OUTPUT IS TO TT:
FG.IP== 10000	;/I LIBRARY PASS INDICATOR				;SHD01
PA.SS2==100000	;SET WHEN DOING PASS 2		*** MUST BE BIT 15 ***

.SBTTL	****	SAVESTATUS AREA FORMAT

;+
; THE SAVESTATUS AREA STARTS AT HIGH CORE AND MOVES DOWNWARD.
; A CHECK IS MADE SO AS NOT TO OVERRUN HANDLERS. THE SAVESTATUS AREA
; WILL BE MOVED DOWN AFTER ALL CSI INPUT IS MADE AND THE LEVEL AND SEGMENT
; BLOCKS ARE CREATED.
;-

		;-------------------------------+
F.LNM==	-12.	; 4 WD RAD50 FILENAME FOR ERROR	! ;ADD 2 WDS (4 BYTES)	;MAS27
		;-------------------------------!
F.LOV==	-4	; PTR TO OVERLAY SEG BLK OR 0	!<- FILPT1 PTS TO 1ST FILE BLK
		;-------------------------------!
		;E!L! ! !	SEGMENT #	!
		;-------------------------------!
		;	5 WD SAVESTATUS BLK	!<- FILPT, CURRENT FILE PROCESSING
		;-------------------------------+
		;E SET IF END OF INPUT
FL.IB==	40000	;L IS SET FOR LIBRARY
S.VSIZ==11.*2	;SIZE OF SAVESTATUS BLOCK AREA(11. WORDS)		;MAS27

.SBTTL	****	FORMAT & OFFSETS OF /O OVERLAY REGION BLOCK.

;+
; /V PARTITION BLOCKS ARE LINKED IN FOLLOWING /O OVERLAY REGION BLOCKS,
; AND USE THE SAME FORMAT AND OFFSETS AS THE /O OVERLAY REGION BLOCKS.
;-

		;--------------------------------
R.GNB==	-8.	;BIT 15 !	REGION #	! ;BIT 15=0 /O;=1 /V	;MAS15
		;--------------------------------
R.GNXP==-6	; PTR TO NEXT REGION BLK	!
		;--------------------------------
R.GSGP==-4	; PTR TO SEG BLK THIS REGION	!
		;--------------------------------
R.GHL==	-2	; HIGH ADR LIMIT OF REGION	! ;TEMP N VALUE (V:N:M)	;MAS15
		;--------------------------------
	;BOTTOM-; ST ADR OF REGION AREA		!
		;--------------------------------

.SBTTL	****	FORMAT & OFFSETS OF OVERLAY SEGMENT BLOCK

		;--------------------------------
		;SYMBOL TABLE ENTRY PTR THIS SEG!
		;--------------------------------
S.GRGP== 2	;PTR TO REG BLK THIS SEGMENT	!
		;--------------------------------
S.GID==	 4	;SEG ID # = 6 * SEGMENT #	!
		;--------------------------------
S.GBSB== 6	;BASE BLK OF SEG. IN SAVE FILE	!
		;--------------------------------
S.GHCL== 8.	;HIGH CORE LIMIT OF SEGMENT	!
		;--------------------------------
S.GNXP==10.	;PTR NXT OSDB THIS REG OR 0	!
		;--------------------------------

.SBTTL	****	ERROR MESSAGE TYPES

E$PRT==	0	;JUST PRINT A MESSAGE
E$REG==	1	;PRINT MSG PLUS CONTENTS OF REG
E$SYM==	2	;PRINT MSG & REG -> 2 WD RAD50 SYMBOL TO PRINT
E$FIL==	3	;PRINT MSG & CURRENT INPUT FILENAME
E$DEV==	4	;PRINT MSG AND CURRENT DEV:
E$N==	0	;ERROR MESSAGE HAS NO PREFIX (NON-FATAL)		;DBB03+
E$W==	1	;ERROR IS A WARNING MESSAGE
E$F==	2	;ERROR IS FATAL & WILL RESTART THE LINKER		;DBB03-

.SBTTL	****	SECTION INPUT FLAG BYTE BIT ASSIGNMENTS

CS$SAV==1	;SAVE (1=ROOT, 0=NORMAL)	FORCES CS$GBL BIT ON	;DBB07
CS$LIB==2	;LIBRARY SECTION (1=YES)	NOT SUPPORTED
CS$ALO==4	;ALLOCATION (1=OVR, 0=CON)
CS$NU==	10	;NOT USED EXTERNALLY (INITIALLY CLEARED THEN SY.SEC BIT)
CS$ACC==20	;ACCESS (1=RO, 0=RW)
CS$REL==40	;RELOCATIABILITY (1=REL, 0=ABS)
CS$GBL==100	;SCOPE	(1=GLOBAL, 0=LOCAL)
CS$TYP==200	;TYPE (1=DATA, 0=INSTRUCTIONS)
	;FOR SYMBOL TABLE FLAGS, TAKE ABOVE SYMBOLS * 400(8)

.SBTTL	****	GLOBAL SYMBOL INPUT FLAG BYTE BIT ASSIGNMENTS

SY$WK== 1	;WEAK SYMBOL (1=WEAK, 0=STRONG)				;DBB07
SY$DEF==10	;DEFINITION (1=DEF, 0=REFERENCE)
SY$REL==40	;RELOCATABILITY (1=REL, 0=ABS)

.SBTTL	****	GSD ENTRY STRUCTURE

.ASECT
.=0
	.BLKW	;SYMBOL CHARS 1-3(RAD50)
	.BLKW	;SYMBOL CHARS 4-6(RAD50)
S$YFLG::.BLKB	;FLAGS
S$YCOD::.BLKB	;CODE BYTE
S$YVAL::.BLKW	;SIZE OR OFFSET

.SBTTL	****	SYMBOL TABLE STRUCTURE

		;------------------------
S.YNAM==-10	; 2 WD RAD50 NAME	!
		;------------------------
S.YSN==	-4	; PSECT FLAGS !  SEG #	!  FLAGS WORD
S.YFLG==-3	;------------------------
S.YVAL==-2	;  VALUE		!  VALUE WORD
		;------------------------
	; ->	;A!B!C!D!  ENTRY # PTR  !  STATUS WORD
		;------------------------

.SBTTL	****	INTERNAL SYMBOL TABLE FLAGS BIT ASSIGNMENT

SY.UDF==100000	;SET TO DECLARE SYMBOL IS UNDEFINED			;DBB01
SY.DUP==40000	;SET TO ALLOW DUPLICATE LIBRARY SYMBOLS			;DBB02
SY.IND==20000	;SET TO PUT SYMBOL IN OVERLAY HANDLER TABLE
SY.WK== 10000	;SET TO INDICATE SYMBOL IS WEAK				;DBB07
SY.SAV==SY.WK	;SET TO INDICATE PSECT HAS SAV ATTRIBUTE		;DBB07
SY.ENB==170000	;MASK TO ISOLATE SYMBOL ENTRY NUMBER PTR

SY.SEC==4000	;CS$NU POSITION IN PSECT FLAGS INDICATING SYMBOL IS A SECTION
SY.SWI==10000	;(CS$ACC)SET IF THIS SYMBOL PUT IN SYMBOL TABLE BY /I UNDEF SYMBOL
SY.SEG==1777	;SEGMENT NUMBER BITS IN FLAGS WORD

;+
; A - SY.UDF (SYMBOL IS UNDEFINED WHEN BIT IS SET)
; B - SY.DUP (DUPLICATE SYMBOL WHEN BIT IS SET)
; C - SY.IND (INDIRECT REFERENCE WHEN BIT IS SET)
; D - SY.WK  (WEAK SYMBOL WHEN BIT IS SET AND SY.SEC IS CLEARED)
; D - SY.SAV (PSECT HAS SAV ATTRIBUTE WHEN BIT IS SET AND SY.SEC IS SET)
;
; TO GET THE ABSOLUTE ADDR OF THE SYMBOL TABLE BLOCK BEING POINTED TO,
; MASK OFF BITS A,B,C, AND D, MULTIPLY ENTRY NUMBER PTR BY 10.,
; AND ADD TO THE CONTENTS OF LOCATION "SYEN0".
; THE ENTRY # = (PHYSICAL ADDR OF SYM - ST OF SYM TBL)/10.
; THE ENTRY # POINTER USES BITS 0-11.
; THE FLAG WORD HAS THE PSECT FLAGS IN BITS 10-15.
; SINCE LIBRARY PSECT AND THE LOW/HIGH SPEED MEMORY BITS ARE NOT USED
; THEY ARE FREE FOR THE SYMBOL SEGMENT NUMBER (BITS 0-9).
;-

.SBTTL	****	TYPES OF SYMBOL TABLE BLOCKS:

;+
; 1. UNUSED BLOCKS - ALL 5 WORDS ARE ZERO
; 2. NEW SYMBOL (NEVER SEEN BEFORE) - FLAGS, VALUE & STATUS WORDS ARE ZERO
; 3. UNDEFINED SYMBOL (REFERENCED BEFORE, BUT NEVER DEFINED) - BIT A IS
;    SET, ENTRY # POINTS TO NEXT UNDEFINED SYMBOL, AND VALUE HAS 
;    ABSOLUTE ADDR OF PREVIOUS UNDEF SYMBOL.
;    THE LIST OF UNDEFINES IS CURCULAR AND STARTS WITH A DUMMY BLOCK
;    POINTED TO BY [UNDLST]+2.
; 4. PSECT - ENTRY # PTS TO LIST OF ENTRY POINTS IN SECTION
;    (IF ANY), OTHERWISE POINTS TO NEXT SECTION.  DURING PASS1, VALUE
;    CONTAINS BYTE LENGTH OF SECTION, DURING PASS2 IT CONTAINS THE
;    BASE ADDR OF THE SECTION.
; 5. ENTRY SYMBOL - BIT A CLEARED.  ENTRY # POINTS TO NEXT ENTRY
;    SYMBOL IN SAME SECTION (ORDERED BY RELATIVE ENTRY ADDR), OR TO THE
;    NEXT SECTION, OR IT IS ZERO (END-OF-LIST). VALUE CONTAINS RELATIVE ENTRY
;    ADDR ON PASS1, ABSOLUTE ENTRY ADDR ON PASS2. THERE MAY BE SEVERAL
;    END-OF-LIST MARKERS IN THE SYMBOL TABLE. THERE IS ONE LIST FOR EACH
;    OVERLAY SEGMENT PLUS ONE FOR THE ROOT.
;-

.SBTTL	****	MACRO DEFINITIONS

.MCALL	.RELEAS,.CSISPC,.SETTOP,.FETCH,.PRINT				;DBB08
.MCALL	.LOOKUP,.SAVESTATUS,.DATE,.GTIM,.READW,.DSTATUS			;DBB08

.MACRO	ERROR$	ERNB,SEV,ETYP,REG
	.IF NB REG
	.IIF DIF <REG>,<R0> 	MOV 	REG,R0
	.IFF
	.IIF IDN <ETYP>,<E$FIL>	CLR	R0
	.ENDC
	JSR	R5,ERROOT
	.BYTE	ERNB,	SEV*100!ETYP
.ENDM

.IF Z EIS$
.MACRO	SOB	REG,LABEL
	DEC	REG
	BNE	LABEL
.ENDM
.ENDC

.MACRO	SWTGEN	L,ARG

.PSECT	DATA,D

.IF B	ARG
	.WORD	SW.'L
.IFF
	.WORD	ARG
.ENDC
	.BYTE	<SWT.'L-SWTPRO>/2
	.BYTE	''L

.PSECT	CODE

SWT.'L:
.ENDM

.PSECT	DATA,D

ERRIDX::.WORD	0	;ERROR OVERLAY INDEX
			;MUST BE PHYSICALLY 1ST WD OF OVERLAY

.SBTTL	****	END OF LINK DEFINITIONS		****

.SBTTL	-	VERSION IDENTIFICATION FOR NULL INPUT


VERSON::.NLCSI
PATLEV=:.-2
.IF NE	RST$
.=.-2			;DELETE BLANK AND NULL
	.ASCIZ	\R \	;BLANK IS FOR PATCH LEVEL
.EVEN
.ENDC
.SBTTL	-	INITIALIZATION  & PROMPT MESSAGES

.NLIST	BEX
.ENABL	LC

BADMSG:	.NLCSI	TYPE=I,PART=PREFIX
	.ASCII	"W-Invalid option: /"				;DBB05
SWTBAD:	.ASCIZ	"X"
ODDMSG:	.NLCSI	TYPE=I,PART=PREFIX
	.ASCII	"F-/"
SWTODD:	.ASCIZ	"M odd value"
NOVMSG:	.NLCSI	TYPE=I,PART=PREFIX
	.ASCII	"F-/"
SWTNOV:	.ASCIZ	"B no value"
VALMSG:	.NLCSI	TYPE=I,PART=PREFIX
	.ASCII	"F-/"
SWTVAL:	.ASCIZ	"K invalid value"
	; BIT MASK TABLE TO CLEAR MASTER BITMAP NON-ROOT BITS
BTMSK:	.BYTE	377,177,77,37,17,7,3,1
.EVEN

PTBL:	.RAD50	/$OTABL/		;OVERLAY TABLE PSECT		

DEFEXT:	.RAD50	/OBJ/			;CSI
	.WORD	-1			;  DEFAULT (SAV,REL,LDA)
	.RAD50	/MAPSTB/		;    EXTENSIONS
LIMIT:	.LIMIT
NLDEV	= 25		; DEVICE CODE ID FOR NL:


.SBTTL	START1::  PROGRAM START

.PSECT	CODE
.ENABL	LSB
START1::MOV	@#STACK,SP	;INIT THE STACK PTR
	.GTIM	#PRAREA,#ODBLK	;FOR FUSSY USERS WHO COMPLAIN ABOUT THE ;DBB08
	.DATE			;MIDNIGHT ROLL-OVER PROBLEM		;MAS07
	MOV	#IMPURE,R1	;ADR OF IMPURE AREA TO BE CLEARED
	MOV	#IMPSIZ/2,R0	;SIZE OF IMPURE AREA IN WORDS
10$:	CLR	(R1)+
	SOB	R0,10$
	CLR	FLGWD		;INTERNAL FLAG WORD
	CLR	SEGBLK		;BASE BLK OF OVERLAY SEGMENT
	CLR	SEGBAS		;BASE OF OVERLAY SEGMENT
	CLR	ENDOL		;USE FOR CONTINUE SWITCHES /C OR //
	CLR	SEGNUM		;KEEP TRACK OF INPUT SEGMENT #'S
	CLR	ENDRT		;END OF ROOT SYMBOL TBL LIST
	CLR	TXTLEN		;TEMP FOR /V SWITCH			;MAS15
	CLR	CBPTR		;DEFAULT IS NO CREF			;DBB06
	INC	LMLPTR		;SET UP FOR NO READ FOR /X EPT SIZE	;MAS18
	DEC	LOC66		;INIT LOC66 TO -1			;MAS28
	MOV	LMLSIZ,ENDLML	;INIT DEFAULT LML SIZE			;MAS10
..WDSZ==.+2
	MOVB	#3,NUMCOL	;3-COLUMN MAP IS NORMAL
	CMPB	#6,NUMCOL	;***PATCH CHECK FOR WIDE SIPP PATCH
	BNE	5$		
	DEC	LSTFMT		;***PATCH CREF LIST SIZE TOO
5$:	MOV	#3,NUMBUF	;DEFAULT # OF CACHE OUTPUT BUFFERS
	MOV	#BEGBLK,R0	;R0 -> TRANSFER ADDRESS BLK
	MOV	(PC)+,(R0)+	;DEFAULT SECTION IS . ABS.
	.RAD50	/. A/
	MOV	#^RBS.,(R0)+
	MOV	#5*400+CS$GBL+CS$ALO,(R0)+ ;CODE & FLAG BYTES
	INC	@R0		;INITIAL TRANSFER ADR TO 1
	MOV	#ASECT,OVSPTR	;PTR TO OVERLAY SEGMENT BLK
	MOV	#BOTTOM,ASECT+S.GRGP ;PTR TO DUMMY OVERLAY REGION BLK
	MOV	#ASECT,BOTTOM+R.GSGP ;PTR TO ROOT SEGMENT BLK
	MOV	#1000,BOTTOM	;INITIAL BOTTOM ADR
	MOV	#RELSTK,KSWVAL	;DEFAULT REL FILE STACK SIZE
.DSABL	LSB
.SBTTL	-	CALL CSI, FETCH HANDLERS, & LOOKUP INPUT FILES

	MOV	LIMIT+2,R3	;R3 = TOP OF LINKER CODE
	.SETTOP	R3		;CAUSES LESS KMON SWAPPING IF EXIT
	MOV	#ODBLK,R1	;R1 -> DEV:FILENAME.EXT[LENGTH]
	.CSISPC	R1,#DEFEXT	;REQUEST 1ST COMMAND

.IIF NE RST$ 	CALL	SAVRST 	;SAVE RSTS/E PARAMETERS			;MAS17

	MOV	@#RMON,R0	;R0 -> START OF MONITOR
	MOV	U$SRLC(R0),R0	;START OF WHERE USR WILL LOAD
	TST	-(R0)		;HIGHEST WORD NOT IN USR AND ASK FOR IT SO
	.SETTOP			; USR WILL NOT SWAP DURING INITIAL DIALOGUE
	MOV	#3,R5		;SETUP OUTPUT FILE CTR
20$:	CALL	FETCH		;LOAD OUTPUT DEVICE IF REQUIRED
	TST	(R1)+		;R1 -> OUTPUT FILE DESCRIPTOR BLK
30$:	SOB	R5,20$		;DO ALL 3 OUTPUT DEVICES
	MOV	(SP)+,STLEN	;GET SWITCH COUNT FROM CSI

.SBTTL	SWLOOP	PROCESS COMMAND STRING SWITCHES ON 1ST LINE

.ENABL	LSB
SWLOOP:	DEC	STLEN		;COUNT DOWN SWITCHES
	BPL	10$		;MORE
	JMP	SWEND		;NO MORE

10$:	CMPB	@SP,#'a		;BETWEEN A AND Z ?
	BLO	15$		;YES, BRANCH
	CMPB	@SP,#'z		;BETWEEN A AND Z ?
	BHI	15$		;YES, BRANCH
	BICB	#40,@SP		;MAKE IT AN UPPERCASE SWITCH
15$:	MOVB	@SP,SWTBAD	;SET NAME OF OFFENDER IF BAD
	MOVB	@SP,SWTODD	;IN 2 MESSAGES
	MOVB	@SP,SWTNOV	;IN 3 MESSAGES
	MOVB	@SP,SWTVAL	;IN 4 MESSAGES
	MOV	#SWTTBL,R0	;R0 -> DISPATCH TABLE
20$:	MOV	(R0)+,R4	;GET ARGUMENT WORD IN R4
	CLR	R1		;CLEAR FOR NO SIGN EXTEND
	BISB	(R0)+,R1	;AND GET DISPATCH OFFSET
	CMPB	(R0)+,@SP	;IS THIS THE RIGHT SWITCH?
	BEQ	30$		;YES
	CMP	#SWTTBE,R0	;NO, ARE THERE MORE?
	BHI	20$		;YES, TRY FOR MORE
BADSWT:	MOV	#BADMSG,R0	;BAD SWITCH MSG ADR
	BISB	#WARN$,@#USERRB	;SET WARNING BIT IN USER ERROR BYTE
ERR:	JMP	ERROR		;CALL ERROR PRINTER FOR FATAL ERROR

30$:	MOV	#SWITCH,R5	;R5 -> SWITCH FLAG WORD
	MOV	#ODBLK+6,R0	;THIS IS USEFUL SOMETIMES
	ASL	R1		;DOUBLE THE DISPATCH OFFSET
	ADD	R1,PC		;AND GO TO SWITCH ROUTINE

.PSECT	DATA,D

SWTTBL:				;START OF SWITCH TABLE

.PSECT	CODE

.ENABL	LSB
SWTPRO:
SWTGEN	T,BEGBLK+6		;/T - SPECIFY TRANSFER ADR
	TST	(SP)+		;ANY VALUE GIVEN?
	BMI	10$		;YES
	BIS	#SW.T,@R5	;SET /T SWITCH BIT TO GET SYMBOL
	BR	SWLOOP

SWTGEN	M,STKBLK+4		;/M - MODIFY INITIAL STACK
	TST	(SP)+		;VALUE GIVEN?
	BPL	30$		;NO
10$:	BIT	#1,@SP		;YES, BUT IS IT ODD?
	BEQ	20$		;NO, STORE IT
	MOV	#ODDMSG,R0	;ODD VALUE ERROR
FERR:	BISB	#FATAL$,@#USERRB ;SET FATAL BIT IN USER ERROR BYTE
	BR	ERR

20$:	MOV	(SP)+,@R4	;STORE SWITCH VALUE
	BR	SWLOOP

30$:	BIS	#SW.M,@R5	;SET /M SWITCH BIT TO GET SYMBOL
	BR	SWLOOP

SWTGEN	B,BOTTOM		;/B - SPECIFY BOTTOM ADR FOR LINK
	BIS	#SW.B,@R5	;INDICATE BOTTOM SWITCH FOUND
	BIT	#SW.H!SW.R,@R5	;BOTH /H OR /R ARE ILLEGAL
40$:	BNE	BADSWT		;OOPS
50$:	TST	(SP)+		;VALUE MUST BE PRESENT
	BMI	10$		;AND IT IS SO CHECK IF EVEN
60$:	MOV	#NOVMSG,R0
	BR	FERR		;GENERATE ERROR

SWTGEN	U,USWVAL		;/U - ROUND SECTION
	BIS	#SW.U,@R5	;INDICATE SWITCH ON
	BR	70$		;AND GO CHECK VALUE

SWTGEN	E,ESWVAL		;/E - EXTEND SECTION
	BIS	#SW.E,@R5	;INDICATE SWITCH ON
	BR	50$		;AND GO CHECK VALUE

SWTGEN	Y,YSWVAL		;/Y - START SECTION ON MULTIPLE OF VALUE
	BIS	#SW.Y,@R5	;INDICATE SWITCH ON
	BIT	#SW.H,@R5	;/H NOT ALLOWED WITH /Y
	BNE	BADSWT							;MAS01
70$:	TST	(SP)+		;IS THERE A VALUE?
	BPL	75$		;NO VALUE IF +
	MOV	@SP,R0		;CHECK IF POWER OF 2
	MOV	R0,-(SP)
	NEG	@SP
	BIC	(SP)+,R0
	BEQ	10$		;IF EQ THEN POWER OF 2
	ERROR$	ERR45,E$F,E$PRT	;/U OR /Y VALUE NOT A POWER OF 2

75$:	MOV	#-1,-(SP)	;FLAG THAT WE HAVE TO PROMPT FOR THE VALUE
	BR	20$		;SAVE THE FLAG

SWTGEN	H,HSWVAL		;/H - SPECIFY TOP ADR FOR LINK
	BIS	#SW.H,@R5	;INDICATE /H FOUND
	CLR	BOTTOM		;TURN OFF BOTTOM VALUE OF 1000
	TST	REGION		;WAS /Q SWITCH SET YET?			;MAS20
	BNE	BADSWT		;NE -> YES, ERROR			;MAS20
	BIT	#SW.B!SW.R!SW.Y,@R5 ;CHECK ILLEGAL COMBINATIONS
	BR	40$		;COMMON CODE

SWTGEN	K,KSWVAL		;/K - SPECIFY MINIMUM SIZE
	BIS	#SW.K,@R5	;INDICATE ON
	TSTB	@R5		;/R TOO ?
	BMI	BADSWT		;OOPS					;CER01
	TST	(SP)+		;VALUE?
	BPL	60$		;NO VALUE
	CMP	@SP,#2		;< 2K (TOO SMALL)?
	BLO	80$		;OOPS					
	CMP	@SP,#28.	; > 28K (TOO BIG)?			
	BLOS	20$		;DO IT
80$:	MOV	#VALMSG,R0	;INVALID VALUE ERROR
	BR	FERR

SWTGEN	P,ENDLML		;/P:N  SIZE OF LML TABLE
				; IF NO VALUE GIVEN USE DEFAULT

SWTGEN	Z,ZSWVAL		;/Z - ZERO UNFILLED LOCATIONS
	TST	(SP)+		;ANY VALUE ?
	BPL	SWLOOP		;NO, 0 WILL BE USED
	MOV	(SP)+,@R4	;YES, USE VALUE GIVEN
	BR	SWLOOP

.IF NE REL$
SWTGEN	R,KSWVAL		;/R - INDICATE FOREGROUND LINK
	BIS	#SW.R,@R5	;INDICATE ON
	BIT	#SW.B!SW.H!SW.K!SW.L,@R5 ;/B, /H, /K OR /L ARE ILLEGAL
	BNE	BADSWT
;	BITB	#SW.V,FLGWD	;/V USED?				;MAS35
;	BNE	BADSWT		;NE ->YES, ILLEGAL COMBINATION		;MAS35
	TST	REGION		;WAS /Q SWITCH USED YET?		;MAS20
	BNE	BADSWT		;NE -> YES, ERROR			;MAS20
	CMP	#-1,@R0		;IS THE OUTPUT EXTENSION DEFAULT?
	BNE	90$		;NO, USE HIS EXPLICIT EXTENSION
	MOV	#^RREL,@R0	;YES, CHANGE IT TO "REL"
90$:	TST	(SP)+		;WAS A STACK SIZE GIVEN ?
	BPL	130$		;NO
	BR	10$		;CHECK IF EVEN
.ENDC				;REL$

SWTGEN	V,LOC0			;/XM, OR /V ON 1ST LINE			;DBB09+
;	BIT	#SW.R!SW.L,@R5	;NOT ALLOWED WITH /R OR /L
	BIT	#SW.L,@R5	;NOT ALLOWED WITH /L
	BNE	100$		;NE -> ONE IS SET, ERROR
	BISB	#SW.V,FLGWD	;SET BIT IN FLAG WORD
	TST	(SP)+		;WAS A VALUE GIVEN?
	BMI	20$		;IF MI YES, SO PROCESS IT
	MOV	#^RVIR,@R4	;NO VALUE, SO "VIR" GOES IN LOC 0
	BR	130$		;RETURN TO PROCESSING SWITCHES		;DBB09-

.IF NE	LDA$
SWTGEN	L			;/L - INDICATE LDA OUTPUT
	TSTB	@R5		;/L IS ILLEGAL FOR FOREGROUND LINKS
	BMI	BADSWT		;OOPS
	BITB	#SW.V,FLGWD	;IS /V SET?				;MAS35
100$:	BEQ	101$
	JMP	BADSWT		;NE -> YES, ILLEGAL COMBINATION		;MAS35

101$:	CMP	#-1,@R0		;IS THE OUTPUT EXTENSION DEFAULT?
	BNE	110$		;NO, USE EXPLICIT EXTENSION
	MOV	#^RLDA,@R0	;YES, CHANGE TO "LDA"
	BR	110$
.ENDC				;LDA$

SWTGEN	W,NUMCOL		;/W - SPECIFY WIDE MAP LISTING
	MOVB	#6,@R4		;6 COLUMNS
	DEC	LSTFMT		;WIDE CREF				;DBB06
	BR	120$		;IF ANY VALUE IGNORE IT

SWTGEN	C			;/C - CONTINUE ON ANOTHER LINE
	MOV	R4,ENDOL	;FORCE "BIC ENDOL,SWITCH" TO WORK
	;BR	110$

;SWTGEN	/

.PSECT	DATA,D

	.WORD	SW.C
	.BYTE	<SWT.CC-SWTPRO>/2
	.BYTE	'/

.PSECT	CODE

SWT.CC:
SWTGEN	X			;/X - DO NOT EMIT BIT MAP
SWTGEN	I			;/I - INCLUDE MODULES FROM LIBRARY
SWTGEN	F			;/F - INCLUDE FORLIB.OBJ IN LINK
SWTGEN	A			;/A - ALPHABETIZE MAP
	BR	110$
SWTGEN	S			;/S - SYMBOL TABLE AS LARGE AS POSSIBLE
	TST	ODBLK+10.	;YES, MAP FILE?			;SMD005
	BNE	105$		;YES - ERROR			;SMD005
	TST	ODBLK+20.	;NO, STB FILE?			;SMD005
	BEQ	110$		;NO.				;SMD005
105$:	ERROR$	ERR53,E$W,E$PRT	;YES, ISSUE /S WARNING MESSAGE	;SMD005
	CLR	ODBLK+10.	;ZAP MAP AND STB		;SMD005
	CLR	ODBLK+20.	; FILESPECS			;SMD005

110$:	BIS	R4,@R5		;TURN ON SWITCH BIT
120$:	TST	(SP)+		;DISCARD SWITCH
	BPL	130$		;NO VALUE
	TST	(SP)+		;IGNORE POSSIBLE VALUE
130$:	JMP	SWLOOP

SWTGEN	D			;/D - ALLOW DUPLICATE SYMBOLS		;DBB02+
	BIS	R4,SWIT1	;SET APPROPRIATE BIT IN AUX. SWITCH WD
	BR	120$		;IGNORE POSSIBLE VALUE			;DBB02-

SWTGEN	N,CBPTR			;/N - GENERATE CROSS REFERENCE		;DBB06+
	INC	@R4		;CBPTR<>0 MEANS CREF REQUESTED
	BR	120$		;IGNORE ANY VALUES			;DBB06-

SWTGEN	G,LMLPTR		;/G - CALC. EPT SIZE ON RT-11		;MAS18+
	CLR	@R4		;CLEAR FLAG TO ENABLE READ OF FILES
	BR	120$		;IGNORE ANY VALUES			;MAS18-

SWTGEN	Q,REGION		;/Q - SET PSECTS TO ABSOLUTE ADDRESSES	;MAS20+
	BIT	#SW.R!SW.H,@R5	;ARE /R OR /H SET?
	BNE	100$		;NE-> AT LEAST ONE IS SET, ERROR 
	MOVB	QSWNUM,@R4	;SET AS FLAG, AND AS RIGHT NUMBER OF QUESTIONS
	BR	120$		;TAKE CARE OF VALUES, ETC		;MAS20-
.DSABL	LSB

.PSECT	DATA,D

SWTTBE:

.PSECT	CODE

;+
; THE FIRST COMMAND LINE SWITCHES HAVE BEEN PROCESSED, NOW THE REMAINING
; THING TO DO IS FETCH, LOOKUP & SAVESTATUS INPUT FILES.
;-

SWEND:	MOV	#ODBLK+6,R1	;R1 -> 1ST OUTPUT FILE EXTENSION
	CMP	#-1,@R1		;IS EXTENSION DEFAULT?
	BNE	10$		;BRANCH IF NOT AND USE EXPLICIT EXTENSION
	MOV	#^RSAV,@R1	;OTHERWISE, USE ".SAV"
10$:	MOV	#ODBLK+30.,R1	;R1 -> 1ST INPUT FILENAME
	MOV	@#HIGH,R4	;R4 -> SAVESTATUS AREA
	MOV	#6,R5		;6 POSSIBLE INPUT FILES PER LINE
20$:	CALL	FLKSV		;FETCH, LOOKUP & SAVESTATUS THIS FILE
	BCC	30$
	JMP	RESTRT		;FILE NOT FOUND ON 1ST LINE, SO RESTART

30$:	SOB	R5,20$		;LOOP FOR ALL
	BIS	#GTLIN$,@#JSW	;PROMPT FROM TT IF NOT IN @ FILE
	BR	SWPRO		;CHECK & DO CONTINUATION LINES

.SBTTL	GETHND	FETCH HANDLERS & LOOKUP INPUT FILES

;+
; INPUT:R1 -> 1ST INPUT FILE DEV:FILENAME.EXT
;	R3 = FREE CORE PTR WORKING UP
;	R4 = HIGH CORE AREA WORKING DOWN FOR SAVESTATUS
;
; THE FOLLOWING ROOT LOCATIONS ARE USED IN GETHND AND ITS RELATED ROUTINES
;
;	CKSUM 	-> TEMP-REGION LINK POINTER TO ENABL STATE RESTORATION ON 
;		   FILE/DEVICE NOT FOUND
;	HIPHYS  -> EPT SIZE STORAGE
;	TPSP	-> IS NOW THE TEMP STACK STORAGE
;	OVCOUN	-> SIZE OF $OTABL PSECT=OVERLAY SEGMENT DATA/ENTRY POINTS/WDBS
;	SEGNUM	-> CURRENT SEGMENT NUMBER
;	STLEN	-> CSI SWITCH COUNT
;	STLML	-> TEMP-M VALUE FOR /V:N:M USED FOR /V SWITCH ONLY
;	TXTLEN	-> TEMP-BIT 15 SET FOR NO NEW PARTITION, LOW BYTE PART. COUNT
;		   USED FOR /V SWITCH ONLY
;	YSWNAM 	-> TEMP-FOR /O VALUE OR N VALUE FOR V:N:M (INIT=0)
;	WDBCNT 	-> WDB SIZE = 14. * NUMBER OF PARTITIONS
;
; INFORMATION IS STORED ON THE STACK IN THE FOLLOWING ORDER
;
;	1. 	R3
;	2. 	R4
;	3.	FLGWD
;	4.	SWITCH
;	5.	TXTLEN
;	6.	STLML
;	7.	WDBCNT
;	8.	YSWNAM
;	9.	SEGNUM
;	10.	OVCOUN
;-

.ENABL	LSB

GETHND:	MOV	R5,-(SP)	;SAVE POSSIBLE SEGMENT POINTER		;SHD02
	MOV	#ODBLK+60.,R1	;R1 -> INPUT FILENAMES
	MOV	#6,R5		;6 POSSIBLE INPUT FILES PER LINE
10$:	CALL	FLKSV		;FETCH, LOOKUP & SAVESTATUS THIS FILE
	BCC	30$
	.RELEAS	R1		;RECLAIM FREE MEMORY SPACE		;MAS03+
	MOV	(SP)+,R5	;CHECK FOR AN ATTEMPTED SEG. CREATION
	BEQ	20$		;EQ -> NONE DONE
	CLR	@R5		;OTHERWISE, CLEAR OUT LINK TO IT	;MAS03-

; ADDITIONS TO LIST REQUIRE CHANGES TO LISTS IN SWPRO: AND OTYPE:

20$:	MOV	(SP)+,OVCOUN	;FILE NOT FOUND SO RESTORE STATE
	MOV	(SP)+,SEGNUM						
	MOV	(SP)+,YSWNAM	;VALUE TO /O AND  N VALUE TO /V:N:M	
	MOV	(SP)+,WDBCNT	;NUMBER OF WDB ENTRIES			;MAS15+
	MOV	(SP)+,STLML	;M VALUE TO /V:N:M
	MOV	(SP)+,TXTLEN	;TEMP /V SWITCH	
	MOV	(SP)+,SWITCH	;RESTORE ANY //, /C CHANGES THIS LINE	;MAS29
	MOV	(SP)+,FLGWD	;IF 1ST LINE IS BAD SO LIBRARIES ARE OK	;MAS36
	MOV	(SP)+,R4	;REDO SAVESTATUS AREA			;MAS15-
	MOV	(SP)+,R3	;RESET FREE CORE PTR
	TST	CKSUM		;NEW REGION CREATED IN THIS INPUT LINE? ;MAS03+
	BEQ	50$		;NO					;MAS29
	MOV	CKSUM,R5	;YES-CLEAR POINTER TO NEW REGION BLOCK	
	CLR	R.GNXP(R5)	;FROM PREVIOUS REGION BLOCK		;MAS03-
	BR	50$		;GET THE LINE AGAIN			;MAS29

30$:	SOB	R5,10$		;LOOP UNTIL ALL 6 INPUT FILES PROCESSED
	ADD	#11.*2,SP	;LINE OK ->REMOVE STATE INFO	 ;MAS29 ;DBB04

.SBTTL	SWPRO	CALL CSI FOR CONTINUATION LINES

SWPRO:	TST	LOC66		;HAS LOC 66 INFORMATION BEEN SAVED YET?	;MAS28+
	BPL	40$		;PL -> YES, LOC66 INIT AT -1
	CMP	#14.,WDBCNT	;ARE WE AT THE 1ST WDB (1ST /V SEGMENT)
	BNE	40$		;NE -> NO, BEFORE IT
	ADD	SEGNUM,LOC66	;1ST -> SAVE SEGMENT # -1 = # /O SEGS	;MAS28-
40$:	BIT	SWITCH,#SW.C	;ANY MORE COMMAND STRINGS??
	BNE	50$		;INITIAL DIALOGUE COMPLETE
	JMP	DIADUN		;0 -> DIADUN	(TOO FAR FOR BR)

50$:	BIC	ENDOL,SWITCH	;CLEAR /C FLAG, MAYBE NOT IF //		

; ADDITIONS TO THIS LIST REQUIRES CHANGES TO LIST IN GETHND: AND OTYPE:

	MOV	R3,-(SP)	;SAVE STATE BEFORE EACH LINE OF INPUT
	MOV	R4,-(SP)	; IN CASE FILE NOT FOUND
	MOV	FLGWD,-(SP)	;SAVE IF 1ST LINE IS BAD		;MAS36
	MOV	SWITCH,-(SP)	;SAVE //, /C RESET IF FILE NOT FOUND	;MAS29
	MOV	TXTLEN,-(SP)	;TEMP /V SWITCH				;MAS15
	MOV	STLML,-(SP)	;M VALUE ON /V SWITCH			;MAS15
	MOV	WDBCNT,-(SP)	;WDB SIZE				;MAS15
	MOV	YSWNAM,-(SP)
	MOV	SEGNUM,-(SP)
	MOV	OVCOUN,-(SP)
	MOV	SP,CSECT	;SAVE SP IN CASE BAD LINE		;MAS15
	.CSISPC	#ODBLK+30.,#DEFEXT ;IGNORE ALL OUTPUT FILES NOW
	CLR	PA2LML		;TEMP FOR OVERLAY SEGMENT PTR
	CLR	R5		;INDICATE NO NEW SEGMENT		;SHD02
	MOV	(SP)+,STLEN	;SWITCH COUNT
NXTSWT:	BEQ	GETHND		;NONE
	CMPB	@SP,#'a		;BETWEEN A AND Z ?
	BLO	15$		;YES, BRANCH
	CMPB	@SP,#'z		;BETWEEN A AND Z ?
	BHI	15$		;YES, BRANCH
	BICB	#40,@SP		;MAKE IT AN UPPERCASE SWITCH
15$:	CMPB	#'O,@SP		;/O OVERLAY SWITCH?
	BEQ	OTYPE		;YES					;MAS15+
	CMPB	#'V,@SP		;/V SWITCH
	BEQ	60$		;= -> /V; NOT = -> NOT /V	
	JMP	NOTOVR		;NOT /O OR /V OVERLAY				
60$:
;	TSTB 	SWITCH		;CAN NOT HAVE REL FILE WITH /V
;	BPL	70$		;PL -> /R WAS NOT USED, /V IS OK
;	MOVB	@SP,SWTBAD	;SET UP MESSAGE
;	MOV	#BADMSG,R0	;GET READY TO PRINT BAD SWITCH MSG
;	.PRINT			;OUTPUT IT
;	BR	160$		;ALLOW LINE TO BE REENTERED

70$:	TST	(SP)+		;VALUE?				
	BPL	150$		;+ -> NO -> ERROR

;+
; TXTLEN IS USED AS A TEMP LOCATION TO INDICATE  THE FOLLOWING
;	IF /V SWITCH HAS BEEN USED -> INC TXTLEN = LOW BYTE (MAX 7 WINDOWS)
;	THE NUMBER OF PARTITIONS -> EACH INC IS A NEW PARTITION
;	IF A NEW PARTITION BLOCK IS NOT NEEDED -> SET BIT 15
; FOR /O:N & /V:N, N VALUES MUST BE ASCENDING ACROSS THE /O AND /V SWITCHES
;-

	TST	TXTLEN		;IS THIS THE 1ST /V
	BNE	80$		;NOT = -> NO; = -> YES, 1ST /V
	CLR	STLML		;MAKE SURE THIS IS 0 = M VALUE

;+
; BIT 15 OF TXTLEN IS USED TO INDICATE THAT NO NEW PARTITION BLOCK IS TO BE 
; CREATED. IT IS SET IF M AND N VALUES ARE GIVEN, AND M+1=M.
; THIS -> OVERLAYS IN XM, NO NEW PARTITION BLOCK, NEW SEGMENT BLOCK IN OLD 
; PARTITION. IF BIT IS NOT SET, A NEW /V PARTITION BLOCK IS ALWAYS CREATED.
;-

80$:	BIC	#100000,TXTLEN	;CLEAR SPECIAL PARTITION FLAG 
	DEC 	STLEN		;SWITCH COUNT
	BEQ	120$		;0 -> NO M VALUE
	CMPB	#'V,2(SP)	;IS NEXT SWITCH /V ALSO?
	BNE	120$		;NOT = -> NO M VALUE
	TST	2(SP)		;VALUE ON 2ND /V?
	BPL	150$		;+ -> NO VALUE -> ERROR	

;+
; NOW HAVE N AND M VALUES FOR /V SWITCH, PROCESS THESE FOR VALID ENTRIES
; WHEN BOTH N AND M VALUES ARE PRESENT THE FOLLOWING RULES APPLY:
; WHERE  N+1 AND M+1 MEAN THE NEXT VALUE OF N AND M
;	IF N+1 < N -> /V IGNORED
;	IF N+1 = N AND M+1 = 0 -> /V IGNORED
;		   AND M+1 > M -> RESET M TO M+1 AND CREATE NEW PARTITION
;		   AND M+1 = M -> SET BIT 15 TXTLEN, NO NEW PARTITION
;		   AND M+1 < M -> /V IGNORED
;	IF N+1 > N AND M+1 = 0 -> /V IGNORED
;		   AND M+1 IS POSITIVE -> M+1 IS VALID (RESET M TO M+1)
;		   AND M+1 IS NEGATIVE -> /V IGNORED
;-

	CMP	YSWNAM,4(SP)	;TEST N VALUE (V:N:M)
	BGT	150$		;GT -> INVALID N
	BEQ	100$		;= -> M+1 MUST BE > OR = M
	CMPB	#7,TXTLEN	;THIS IS A NEW REGION, CAN WE DO ONE MORE?
	BEQ	90$		;= -> NO - CAN ONLY HAVE 7 REGIONS
	INC	TXTLEN		;OK -> INDICATE NEW REGION
	BR	110$

90$:	ERROR$	ERR65,E$F,E$PRT	;TOO MANY VIRTUAL OVERLAY REGIONS	

100$:	TST 	TXTLEN		;N+1 = N, AND 1ST /V -> SPECIAL CASE
	BEQ	150$		;= -> 1ST /V, ->INVALID (N+1 MUST BE > N)	
	CMP	STLML,@SP	;TEST M SWITCHES
	BGT	150$		;GT -> M INVALID
	BNE	110$		;NOT = -> 2 PARTITIONS HERE
	BIS	#100000,TXTLEN	;OTHERWISE, SET SINGLE PARTITION FLAG
110$:	TST	@SP		;M+1 POSITIVE? MUST CHECK IF JUST RESETTING M
	BLE	150$		;M CAN NOT BE = 0
				;NEG -> /V IGNORED
	MOV	(SP)+,STLML	;N+1 > N -> M IS RESET TO CURRENT M
	TST	(SP)+		;SKIP /V ON N SWITCH
	BR	140$		;GO SAVE N AND RETURN

;+
; HAVE ONLY N VALUE FOR /V SWITCH, PROCESS THIS SWITCH FOR VALID ENTRY
; WHEN THERE IS JUST THE N SWITCH THE FOLLOWING RULES APPLY:
; WHERE N+1 AND M+1 MEAN THE NEXT VALUE OF N AND M
;	IF N+1 < N -> /V IGNORED
;	IF N+1 = N AND M = 0 -> NEW PARTITION
;		   AND M NOT = 0 -> /V IGNORED
;	IF N+1 > N -> RESET M TO 0
;-

120$:	INC	STLEN		;MAKE SWITCH COME OUT RIGHT		
	CMP	YSWNAM,@SP	;TEST N VALUE
	BGT	150$		;GT -> N INVALID
	BEQ	130$		;= -> M MUST BE 0 NOW
	CMPB	#7,TXTLEN	;NEW REGION CREATED, ROOM FOR ONE MORE?
	BEQ	90$		;= -> NO - CAN ONLY HAVE 7 REGION
	INC	TXTLEN		;OK -> INDICATE NEW REGION
	CLR	STLML		;N+1 > N -> RESET M TO 0
	BR	140$		;FINISH PROCESSING

130$:	TST 	TXTLEN		;N+1 = N, AND 1ST /V -> SPECIAL CASE
	BEQ	150$		;= -> 1ST /V, ->INVALID (N+1 MUST BE > N)	
	TST	STLML		;TEST M
	BNE	150$		;M=0 ONLY VALID ENTRY
	BR	140$		;FINISH PROCESSING	

.SBTTL	OTYPE	/O TYPE OVERLAY WAS INDICATED

OTYPE:	TSTB	TXTLEN		;HAS /V BEEN DONE ALREADY?
	BNE	150$ 		;= -> NO; NOT = -> YES -> /O IGNORED	;MAS15-
	TST	(SP)+		;VALUE?
	BPL	150$		;ERROR - /O NO VALUE
	CMP	YSWNAM,@SP	;OVERLAY ORDER ASCENDING ?
	BGT	150$		;NO INDICATE ERROR
140$:	CALL	ADDLIB		;PUT FORLIB/SYSLIB JUST BEFORE OVERLAYS ;MAS15
	MOV	@SP,YSWNAM	;SAVE LAST OVERLAY NUMBER
	MOV	(SP)+,R0	;OVERLAY REGION NUMBER
	BLE	150$		;ERROR - INVALID OVERLAY REGION
	TST	PA2LML		;PREVIOUS /O OR /V THIS COMMAND
.IF NE	LDA$
	BNE	150$		;YES, ERROR
	BIT	SWITCH,#SW.L	;LDA OUTPUT?
.ENDC				;LDA$
	BEQ	NEWREG		;NO, OKAY
150$:	ERROR$	ERR42,E$W,E$PRT	; /O  OR /V SWITCH ERROR		;MAS15+	
160$:	MOV	CSECT,SP	;RESTORE SP				;MAS15

; ADDITIONS TO THIS LIST REQUIRE CHANGES TO  LISTS IN GETHND: AND SWPRO:

	MOV	(SP)+,OVCOUN	;FILE NOT FOUND SO RESTORE STATE
	MOV	(SP)+,SEGNUM
	MOV	(SP)+,YSWNAM	;VALUE TO /O AND  N VALUE TO /V:N:M	
	MOV	(SP)+,WDBCNT	;SIZE OF WDB AREA
	MOV	(SP)+,STLML	; M VALUE TO /V:N:M			
	MOV	(SP)+,TXTLEN	;TEMP /V SWITCH				
	MOV	(SP)+,SWITCH	;RESTORE // OR /C CHANGES		;MAS29
	MOV	(SP)+,FLGWD	;RESTORE IF 1ST LINE IS BAD		;MAS36
	MOV	(SP)+,R4	;REDO SAVESTATUS AREA
	MOV	(SP)+,R3	;RESET FREE CORE PTR
	JMP	50$							;MAS15-;MAS29

.SBTTL	NEWREG	OVERLAYED, SO CREATE REGION & SEGMENT BLOCKS AS NEEDED

NEWREG:	MOV	#BOTTOM,R2	;R2 -> OVERLAY REGION LIST
	TSTB	TXTLEN		;IS THIS /V OVERLAY?			;MAS15
	BNE	VCRREG		;0 -> NOT /V				;MAS15
170$:	CMP	R.GNB(R2),R0	;CREATE NEW REGION BLOCK IF DIFFERENT
	BNE	180$		;YES, R2 -> REGION BLK			;MAS03+
	CLR	CKSUM		;CLEAR REGION LINK POINTER		
	BR	CRSEG							

180$:	MOV	R2,CKSUM	;SAVE LINK PNTR TO NEW REGION BLOCK	;MAS03-
	MOV	R2,R5		;SAVE PTR
	MOV	R.GNXP(R2),R2	;LINK TO NEXT REGION
	BNE	170$		;IF THERE IS ONE
	CLR	-(SP)		;MOVE 0 INTO REGION HIGH LIMIT		;MAS15

.DSABL	LSB

.SBTTL	CRREG	CREATE A NEW REGION BLOCK (OR /V PARTITION BLOCK)

CRREG:	MOV	R0,(R3)+	;REGION #				
	CLR	(R3)+		;PTR TO NEXT REGION BLK
	CLR	(R3)+		;PTR TO SEGMENTS THIS REGION
	MOV	(SP)+,(R3)+	;SEGMENT LENGTH(SET TO N VALUE IF /V)	;MAS15
	MOV	R3,R.GNXP(R5)	;LINK NEW BLK INTO LIST
	MOV	R3,R2		;SAVE ADR OF NEW BLK
	CLR	(R3)+		;ADR OF REGION AREA(SET LATER)

.SBTTL	CRSEG	CREATE A NEW SEGMENT BLOCK

CRSEG:	MOV	R2,R0		;SAVE PTR TO REGION BLK
	ADD	#R.GSGP,R2	;R2 -> SEGMENT PTR
	BR	20$

10$:	ADD	#S.GNXP,R2	;R2 -> SEGMENT PTR
20$:	MOV	R2,R5		;SAVE PTR				;SHD02
	MOV	@R2,R2		;GET LINK TO NEXT SEGMENT
	BNE	10$		;UNTIL END OF LIST IS FOUND
	MOV	R3,@R5		;LINK NEW SEGMENT INTO LIST
	MOV	R3,PA2LML	;AND SAVE SEGMENT PTR
	CLR	(R3)+		;SYMBOL TABLE PTR(SET LATER)
	MOV	R0,(R3)+	;POINT TO REGION BLK
	INC	SEGNUM		;INCREMENT SEGMENT NUMBER
	CMP	#SY.SEG,SEGNUM	;HAS THE SEGMENT NUMBER OVERFLOWED?	;MAS19+
	BGE	30$		;GE -> NO, CONTINUE
	ERROR$	ERR57,E$F,E$PRT	;YES, TOO MANY SEGMENTS -> FATAL 	;MAS19-

30$:	ADD	#6,OVCOUN	;EACH SEG ADDS 3 WDS TO OVERLAY TBL SPACE
	MOV	OVCOUN,(R3)+	;ALSO SEGMENT ID # = SEG # *6
	CLR	(R3)+		;BASE BLOCK OF SEG
	CLR	(R3)+		;HIGH CORE LIMIT OF SEG
	CLR	(R3)+		;NO NEXT SEGMENT PTR
	BR	NXTOUT

.SBTTL	NOTOVR	NOT A /O OR A /V SWITCH

NOTOVR:	CMPB	#'C,@SP		;NOT AN OVERLAY SWITCH
	BEQ	10$
	CMPB	#'/,@SP		;WAS A // GIVEN ?
	BNE	20$		;NO
	BIC	#SW.C,SWITCH	;GET US OUT OF INPUT GETTING
	BR	30$

10$:	BIS	#SW.C,SWITCH	;/C WAS GIVEN
	BR	30$

20$:	MOVB	@SP,SWTBAD	;BAD SWITCH CHAR
	.PRINT	#BADMSG		;WARNING: BAD SWITCH
30$:	TST	(SP)+		;ANY VALUE GIVEN ?
	BPL	NXTOUT		;NO IF +
	TST	(SP)+		;SKIP VALUE GIVEN
NXTOUT:	DEC	STLEN		;COUNT DOWN SWITCHES
	JMP	NXTSWT		;BEQ	GETHND

.SBTTL	VCRREG	CREATE /V PARTITION BLOCK IF REQUIRED

VCRREG:	BIS	#100000,R0	;SET /V FLAG IN PARTITION ID		;MAS15+
10$:	MOV	R2,CKSUM	;SAVE POINTER TO NEW PARTITION
	MOV	R2,R5		;SAVE POINTER
	MOV	R.GNXP(R2),R2	;LINK TO NEXT PARTITION
	BNE	10$		;REPEAT IF ITS NOT THE LAST PARTITION
	TST	TXTLEN		;LAST REG, CREATE NEW ONE?
	BPL	20$		;+ -> NEW PARTITION NEEDED
	MOV	CKSUM,R2	;RESTORE R2
	CMP	R.GNB(R2),R0	;ARE PARTITION ID'S THE SAME?
	BNE	ILERR		;NOT = -> ILLEGAL ERROR (SHOULD NEVER HAPPEN)
	CLR	CKSUM		;CLEAR PARTITION LINK POINTER
	BR	CRSEG		;GO DO JUST NEW SEGMENT

20$:	ADD	#14.,WDBCNT	;ADD SPACE FOR WDB BLOCK
	MOV	YSWNAM,-(SP)	;SET UP TO PUT N IN HIGH LIMIT OF PART. BLOCK
	BR	CRREG		;GO CREATE PARTITION

ILERR:	ERROR$	ERR0,E$F,E$PRT	;ILLEGAL ERROR				;MAS15-

.SBTTL	DIADUN	ALL INPUT DIALOGUE COMPLETE

.ENABL	LSB								;DBB06
DIADUN:	ADD 	WDBCNT,OVCOUN	;ADD WDB SIZE TO OVCOUN FOR LATER	;MAS15
	MOV	#HIGH,R5	;R5 -> HIGH CORE ADR VALUE
	CMP	@R5,R4		;R4 -> END OF SAVESTATUS AREA
	BHI	10$
	.PRINT	#VERSON		;NO INPUT WAS GIVEN, SO PRINT VERSION
	JMP	RESTRT		; # & RESTART

10$:	CALL	ADDLIB		;INCLUDE FORLIB & SYSLIB IF NOT ALREADY DONE

.SBTTL	JMP TO LINK2 OVERLAY

	CLR	MBPTR		;0 FOR NO MAP OUTPUT			;DBB06+
	TST	ODBLK+10.	;ANY MAP OUTPUT SPECIFIED?
	BEQ	20$		;IF EQ NO
	INC	MBPTR		;IND A MAP DESIRED.  SET TO IBUF LATER
	BR	30$		;SEE IF CREF TEMPORARY FILE IS NEEDED

20$:	CLR	CBPTR		;NO MAP SO GET RID OF POSSIBLE /N
30$:	TST	CBPTR		;IS CREF DESIRED?
	BEQ	50$		;IF EQ NO
	MOV	#^RDK ,CRFSPC	;MAKE SURE DEFAULT CREF DEVICE IS DK:
	.DSTATUS #PRAREA,#CF	;DO A .DSTATUS ON CF:			;DBB08
	BCS	40$		;C=1 -> CF: IS NOT DEFINED
	MOV	(PC)+,@(PC)+	;USE CF: AS CREF DEVICE
CF:	 .RAD50	/CF /
	 .WORD	CRFSPC
40$:	MOV	#CRFSPC,R1	;SETUP POINTER TO FILE DESCRIPTOR
	CALL	FETCH		;FETCH CREF DEVICE

50$:	JMP 	INIT		;GO TO BUFFER INITIALIZATION
.DSABL	LSB								;DBB06-

.SBTTL	ADDLIB	INCLUDE FORLIB & SYSLIB AS REQUIRED

ADDLIB:	BIT	FLGWD,#FG.LIB	;HAVE THEY ALREADY BEEN INCLUDED ?
	BNE	20$		;YES IF NE
	BIT	SWITCH,#SW.F	;FORTRAN LIBR DEFAULT ?
	BEQ	10$		;NO
	MOV	#FORLIB,R1	;R1 -> FORTRAN LIBRARY FDB
	CALL	FLKSV		;SAVESTATUS FORLIB ALSO
10$:	MOV	#SYSLIB,R1	;R1 -> SYSTEM LIBRARY FDB
	BIS	#FG.LIB+FG.NWM,FLGWD ;INDICATE LIBRARIES INCLUDED & NO WARNING MSG
	CALL	FLKSV		;LOOKUP SYSLIB
	BIC	#FG.NWM,FLGWD	;WARNING MESSAGES ENABLED
	BCC	20$		;C=0 IF SYSLIB WAS FOUND
	BIS	#NO.SYS,FLGWD	;SAY NOT FOUND
20$:	RETURN

.SBTTL	FETCH	LOAD DEVICE HANDLER

;+
; SEE IF HANDLER IS RESIDENT, IF NOT; CHECK MEMORY LIMITS TO SEE IF
; HANDLER WILL FIT & LOAD IT.  IF CURRENTLY NOT ENOUGH ROOM THEN TRY
; TO GET MORE. IF NO MORE AVAILABLE GIVE ERROR & EXIT
;-

.SBTTL	FLKSV	FETCH HANDLER, LOOKUP FILE, & SAVESTATUS IT

;+
; INPUT:R1 -> FILE DISCRIPTOR BLK
;	R3 = ADR TO LOAD HANDLERS(FREE CORE PTR)
;	R4 = HIGH AREA WORKING DOWN FOR SAVESTATUS INFO
;	SEGNUM = SEGMENT # ASSOCIATED WITH FILE
;	PA2LML = TEMP FOR OVERLAY SEGMENT PTR
;
; OUTPUT:C = 1 FILE NOT FOUND, WARNING WAS GIVEN
;        C = 0 FILE FOUND ON LOOKUP, R1 -> NEXT INPUT FDB,
;        R3 & R4 UPDATED
;        DEVICE NOT FOUND IN FATAL & CAUSES RESTART
; CLOBBERS R0 & R2
;-

FETCH:	TST	(PC)+		;SKIP "SEC" & CLEAR CARRY
FLKSV:	SEC			;DO LOOKUP & SAVESTATUS AS WELL
	ROR	-(SP)		;SAVE FUNCTION REQUIRED
	TST	@R1		;ANY FILE GIVEN HERE?
	BNE	10$		;YES, CONTINUE
	JMP	150$		;NO, SO RETURN
10$:	.DSTATUS #PRAREA,R1	;DETERMINE SIZE OF HANDLER		;DBB08
	BCC	20$		;DEVICE IS VALID
	JMP	160$		;DEVICE IS NOT IN SYSTEM TABLES
20$:	CMP	#ODBLK,R1	; IS THIS THE BINARY FILE ?
	BNE	21$		; NO, BRANCH
	CMPB	#NLDEV,PRAREA	; IS DEVICE NL: ?
	BNE	21$		; NO, GO CONTINUE
	MOVB	#1,NOBOUT	; SET FLAG FOR NOT REALLY BINARY OUTPUT
21$:	TST	PRAREA+4	;IS HANDLER RESIDENT?			;DBB08
	BNE	60$		;YES, DON'T NEED TO LOAD IT
30$:	MOV	PRAREA+2,R0	;HANDLER SIZE				;DBB08
	ADD	R3,R0		;CURRENT HIGH LIMIT TO SIZE
	CMP	@#HIGH,R0	;WILL HANDLER FIT?
	BHI	50$		;YES, DON'T NEED TO TRY FOR USR SPACE
	MOV	@#HIGH,-(SP)	;SAVE OLD HIGH
	.SETTOP	#-2		;GET ALL WE CAN, MAKE USR SWAP
	CMP	(SP)+,R0	;DID WE GET MORE THAN BEFORE?
40$:	BLO	30$		;YES, CHECK IF IT WILL FIT NOW
	ERROR$	ERR11,E$F,E$PRT	;NO, INSUFFICIENT MEMORY

50$:	.FETCH	R3,R1		;FETCH HANDLER
	BCS	160$		;DEVICE NOT FOUND
	MOV	R0,R3		;UPDATE FREE CORE PTR
60$:	TST	@SP		;JUST A FETCH REQUESTED ?
	BPL	150$		;YES IF +
	.LOOKUP	#PRAREA,#3,R1	;LOOKUP (SAVESTATUS FREES CHAN 3)	;DBB08
	BCC	90$
	MOV	R1,R0		;COPY FILESPEC PTR
	BIT	FLGWD,#FG.NWM	;SHOULD WARNING MESSAGE BE PRINTED ?
	BNE	70$		;NO IF NE
	ERROR$	ERR13,E$W,E$FIL,R0 ;FILE NOT FOUND <FILENAME>
70$:	ROL	(SP)+		;SINCE DOING LOOKUP, SET CARRY
80$:	RETURN

;+
; LMLPTR:: = 1 IF NOT TO DO READ ON RT-11 (NO /G SWITCH USED)		;MAS18+
; 	   = 0 IF /G SWITCH USED -> DO A READ ON RT-11
;
; IF THE PROGRAM IS RUNNING ON RSTS/E, THEN THE /G SWITCH MAKES NO DEFERENCE,
; AND THE READS ARE ALWAYS DONE IF A DISK IS IN USE.
;-

90$:	MOV	LMLPTR,-(SP)	;ASSUME RT-11, SET UP PROPER CONDITION	;MAS18-
	TST	@RMON		;IS IT RSTS/E?				;MAS13+
	BNE	100$		;0 -> RSTS/E, AND RESET
	MOVB	@#FIRQB+FQFLAG,@SP ;FOR RSTS/E, STACK <> 0 IF NOT DISK	;MAS13-
100$:	MOV	R4,R0		;DETERMINE IF NEEDED AREA WILL
	SUB	#S.VSIZ,R0	; MEET HANDLERS
	TST	@SP		;ARE WE GOING TO DO A READ?		;MAS13+
	BNE	110$		;= -> YES, READ
	SUB	#15*2,R0	;ENSURE READING ROOM			;MAS13-
110$:	CMP	R0,R3		;GROWING DOWN AREA MEET UP AREA?
	BHI	130$		;NO, IT FITS SO CONTINUE
	MOV	@#HIGH,-(SP)	;NEED MORE SPACE, SAVE CURRENT HIGH
	.SETTOP	#-2		;GET ALL WE CAN
	CMP	@SP,R0		;DID WE GET MORE THAN BEFORE?
	BHIS	40$		;NO
	MOV	R4,R2		;YES, SAVE OLD R4
	MOV	R0,R4		;R4 = NEW HIGH LIMIT
	MOV	(SP)+,R0	;OLD HIGH LIMIT WHERE SAVESTATUS AREA STARTED
	CMP	(R4)+,(R0)+	;ADD 2 TO R4 & R0
120$:	MOV	-(R0),-(R4)	;MOVE AREA UP HIGHER
	CMP	R0,R2		;HAVE WE MOVED IT ALL?
	BHI	120$		;NO
	BR	100$		;TRY AGAIN

.SBTTL	-	GET EPT SIZE FOR /X LIBRARIES

;+
; CHECK THE 1ST BLOCK OF EACH FILE TO MAKE SURE THAT WE HAVE A LIBRARY	;MAS13+
; FILE, AND THAT IT IS A /X LIBRARY. THEN GET THE SIZE OF THE LARGEST 
; EPT FOR ALL /X LIBRARIES. THIS SIZE, WILL BE USED IF IT IS LARGER THAN THE
; OTHERWISE CALCULATED BUFFER SIZE. IF /S IS USED, THIS SIZE WILL BE USED IF
; IT IS LARGER THAN THE DEFAULT MINIMUM BUFFER SIZE
;
; HIPHYS WILL BE USED AS A TEMP TO STORE THE EPT SIZE
;-

130$:	TST	(SP)+		;TRYING A READ?				
	BNE	140$		;= -> YES
	MOV	R0,R2		;SET BUFFER AREA
	.READW	#PRAREA,#3,R2,#15,#0 ;READ BLOCK 0 ON CHANNEL 3		;DBB08
	BCS	170$		;C=1 -> ERROR ON READ
	CMP	#F.BRHC,(R2)+	;CHECK FOR FORMATTED BINARY BLOCK
	BNE	140$		;= -> CONTINUE WITH THIS FILE
	CMP	#L.HLEN,(R2)+	;CHECK RECORD LENGTH
	BNE	140$		;= -> CONTINUE WITH THIS FILE
	CMP	#L.BR,(R2)+	;CHECK FOR LIBRARY FB BLOCK ID
	BNE	140$		;= -> CONTINUE WITH THIS FILE
	CMP	#L.HVER,(R2)+	;CHECK FOR CURRENT LIBRARY VERSION NUMBER
	BHI	140$		;CURRENT OR NEWER ONLY PERMITTED
	
; NOW WE HAVE A LIBRARY FILE, IS IT A /X LIBRARY?

	TST	@R2		;IS THIS A /X LIBRARY?
	BEQ	140$		;= -> NOT /X LIBRARY
	MOV	<L$HEAB-L$HX>(R2),R2 ;R2 -> CURRENT LIBRARY EPT SIZE
	CMP	R2,HIPHYS	;IS CURRENT LARGER?
	BLOS	140$		;LOS -> OLD SIZE IS BIGGER
	MOV	R2,HIPHYS	;SET HIPHYS TO BIGGER EPT SIZE		;MAS13-

.SBTTL	-	SAVESTATUS INPUT CHANNEL

140$:	SUB	#10.,R4		;POINT INTO NEW SAVESTATUS BLK
	.SAVESTATUS #PRAREA,#3,R4 ;.SAVESTATUS ON CHAN 3		;DBB08
	MOV	SEGNUM,-(R4)	;SEGMENT # ASSOCIATED WITH FILE
	MOV	PA2LML,-(R4)	;OVERLAY SEG PTR(IF ANY)
	MOV	6(R1),-(R4)	;GET EXTENSION OF FILE			;MAS27+
	MOV	4(R1),-(R4)	;2ND PART OF FILE NAME
	MOV	2(R1),-(R4)	;1ST WD OF FILENAME
	MOV	@R1,-(R4)	;DEVICE NAME				;MAS27-
	CLR	PA2LML		;RESET OVERLAY SEGMENT PTR, MUST START ZERO !
150$:	ADD	#8.,R1		;R1 -> NEXT INPUT FILE
	TST	(SP)+		;GET RID OF FUNCTION REQUESTED
	RETURN

160$:	ERROR$	ERR12,E$F,E$DEV,R1 ;DEVICE NOT FOUND

170$:	ERROR$	ERR2,E$F,E$FIL,R1 ;READ ERROR IN FILENM	;MAS13	;MAS16	;MAS27

.SBTTL	OV1DUM	DUMMY ENTRY POINT FOR ERROR OVERLAY

OV1DUM::RTS	R5

.IF NE	RST$								;MAS31+

.SBTTL	SAVRST	SAVE RSTS/E FILE SPEC INFORMATION

SAVRST:	TST	@RMON		;IS THIS RSTS/E?
	BNE	20$		;= 0 ON RSTS/E
	MOV	R0,-(SP)	;SAVE REGISTERS
	MOV	R1,-(SP)
	MOV	#ODBLK,R0	;GET POINTER TO RT11 CSI BLOCK
	MOV	#RSTLDA,R1	;GET POINTER TO START OF SAV AREAS
10$:	MOV	R0,-(SP)	;SAVE CURRENT AREA POINTER
	.SETFQB			;RT11.RST SETS UP FIRQB
	MOV	@#FIRQB+FQPPN,(R1)+ ;SAVE PPN
	MOV	@#FIRQB+FQPROT,(R1)+ ;SAVE PROTECTION CODE
	MOV	@#FIRQB+FQMODE,(R1)+ ;SAVE FILE OPEN MODE
	MOV	@#FIRQB+FQCLUS,(R1)+ ;SAVE FILE CLUSTER SIZE
	MOV	@#FIRQB+FQNENT,(R1)+ ;SAVE DCN POSITION
	MOV	@#FIRQB+FQFLAG,(R1)+ ;SAVE HANDLER INDEX
	MOV	(SP)+,R0	;RESTORE POINTER TO AREA BLOCK
	ADD	#5*2,R0		;POINT TO NEXT FILE
	CMP	R0,#ODBLK+<3*5*2> ;MORE TO DO?
	BLO	10$		;LO -> NOT DONE
	MOV	#RSTLDA,R0	;POINT FIRST AREA
	MOV	#RSTSAV,R1	;POINT TO SAV PARAMETER AREA IN ROOT
.REPT	5			;MOVE FIVE PARAMETERS
	MOV	(R0)+,(R1)+	;TO THE ROOT AREA
.ENDR
	MOV	(SP)+,R1	;RESTORE REGISTERS
	MOV	(SP)+,R0
20$:	RETURN

.ENDC	;RST$								;MAS31-

.PSECT	PATCH

	.BLKW	64.		;PSECT FOR PATCHES

.END
