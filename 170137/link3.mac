.MCALL	.MODULE
.MODULE	LINK,VERSION=21,COMMENT=<PROCESS GSD ITEMS> IDENT=NO,MODNAME=LINK3,GLOBAL=.LINK3

;                       COPYRIGHT (c) 1989 BY
;           DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;                        ALL RIGHTS RESERVED
;
;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
;ONLY  IN  ACCORDANCE  WITH  THE TERMS  OF  SUCH  LICENSE AND WITH THE
;INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY OTHER
;COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS HEREBY
;TRANSFERRED.
;
;THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT NOTICE
;AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT
;CORPORATION.
;
;DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF ITS
;SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.

.SBTTL	PROCESS GSD ITEMS
.ENABL	GBL

; CER,MAS,SHD,DBB

.IIF NDF EIS$	EIS$=	0	;SAY EIS NOT AVAILABLE

; EDIT HISTORY

; CHANGE TO SUPPORT ABSOLUTE PSECT (ZERO LENGTH & DON'T STORE TEXT)
; FIX PROBLEM WHEN PSECTS MOVED TO THE ROOT DURING LINK			;MAS08
; LIBRARY MODULES INTO OVERLAYS (ADDED FUNCTION)			;MAS10
; SKIP LIBRARY MODULE NAMES IN EPT					;MAS12
; ADD /X LIBRARY PROCESSING						;MAS13
; ADD /G SWITCH FOR CONDITIONAL /X LIBRARY PROCESSING IN RT-11		;MAS18
; FIX EPT SIZE BUG, AND OTHERS FOUND BY RSTS				;MAS16
; FIX LIBRARY MODULE SEGMENT SELECTION FOR LAST UNDF. GBL		;MAS22
; FIX SEGMENT SELECTION FOR LAYERED REFERNCES TO LIBRARY		;MAS23
; LIBRARY ORDERING ERROR CORRECTION					;MAS32
; BUG FIX FOR ERROR ON PSECT MOVED TO ROOT				;MAS33
; BUG FIX FOR /X LIBRARY PROCESSING					;MAS34
; MORE LINKED LIST AND LIBRARY FIXES (SINCE V03)			;MAS37
; FIX LML SORT ALGORITHM						;SHD01
; FORCE READ OF DIRECTORY ON NEW UNDEFINED GLOBALS FROM LIBRARY MODULE	;SHD02
; LIBRARY TRANSFER ADDRESS FIX						;SHD03
; FIX PROBLEM WITH OVERLAY SEGMENT LINKED LIST OF GLOBAL SYMBOLS	;DBB01
; FIX PROBLEM WITH TADDR SOMETIMES DESTROYING CONTEXT			;DBB02
; FIX PROBLEM WITH LIBRARY MODULE PLACEMENT IN WRONG SEGMENT		;DBB03
; MOVE SECTION TO ROOT, BUT LEAVE SYMBOLS IN THE SEGMENT THEY WERE IN	;DBB04
; FIX TRANSFER ADDRESS IN LIBRARY MODULE BUG				;DBB05
; CHANGE SYMBOL TABLE STATUS WORD FORMAT				;DBB06
; GET RID OF TSTEXT SUBROUTINE						;DBB07
; DUPLICATE SYMBOL PROCESSING IN PATHOLOGICAL CASES			;DBB08
; FIX ORLIB FOR DUP MODULES						;DBB09
; ADD LMLADJ TO FORCE LIB MOD TO ROOT WHEN ORLIB CAN'T			;DBB10
; FIX ORLIB1 TO INCLUDE DUP MODULES IN FINAL LML LIST			;DBB11
; MAKE SYMBOLS DEFINED IN DUP MOD TO BE DUP				;DBB12
; DON'T SEARCH EPT FOR DUMMY DUPLICATES					;DBB13
; FIX BUG IN SEGMENT SYMBOL LIST MAINTENANCE FOR LOCAL PSECTS		;DBB14
; ADD SUPPORT FOR WEAK GLOBAL SYMBOLS AND PSECTS WITH SAVE ATTRIBUTE	;DBB15
; CLEAN UP END-OF-FILE PROCESSING AND STACK MAINTENANCE			;DBB16
; STANDARDIZE PROGRAMMED REQUESTS					;DBB17
;
; George Thissell 	29-JUL-85
; FIX /D SWITCH HAVING MULTIPLE LISTINGS ON MAP WITH ABSOLUTE SYMBOLS
;
; .WEAK SYMBOL HAD NONZERO VALUE IN OVERLAID (/O) FILES			;LB
; FIX TRANSFER ADDRESS IN FIRST PROCESSED MODULE IN A LIBRARY BUG	;DBB18
;


.SBTTL	*	DEFINITIONS FOR THIS MODULE

BT.OFF=	177000	;MASK TO ISOLATE EPT BYTE OFFSET
GBLSYM=	4*2	;GLOBAL SYMBOL NAME CODE FOR GSD RECORD * 2		;MAS23

BLK=	16.	;TEMP OFFSET INTO TXTBLK TO STORE BLOCK #
BYT=	18.	;	"	"	"	BYTE OFFSET

.MCALL	.REOPEN								;DBB17

.MACRO	ERROR$	ERNB,SEV,ETYP,REG
 .IF NB REG
  .IIF DIF <REG>,<R0> 		MOV 	REG,R0
 .IFF
  .IIF IDN <ETYP>,<E$FIL>	CLR	R0
 .ENDC
	JSR	R5,ERROOT
	.BYTE	ERNB,	SEV*100!ETYP
.ENDM

;+
; CONVERTS AN ENTRY # INTO THE PHYSICAL ADR OF THE SYMBOL.
; PHYSICAL ADR = 10.*ENTRY # + STARTING ADR OF SYMBOL TBL
; INPUT:R = ENTRY # (MUST BE AN ODD REGISTER FOR EIS)
;
; OUTPUT:R = PHYSICAL ADR OF SYMBOL
;-

.MACRO	SYMADR	R
	ASL	R
	MOV	R,-(SP)
	ASL	R
	ASL	R
	ADD	(SP)+,R
	ADD	SYEN0,R
.ENDM

.IF Z EIS$
.MACRO	SOB	A,B
	DEC	A
	BNE	B
.ENDM
.ENDC

;+
; SUBROUTINE CALL AND RETURN TO MAIN PROGRAM, EQUIVILENT TO:
;	CALL	SUBR
;	RETURN
;-

.MACRO	CALLR	SUBR
	JMP	SUBR
.ENDM

.PSECT	DATA,D

	.WORD	4	;ERROR HANDLING INDEX WORD
			;MUST BE 1ST LOCATION OF EACH OVERLAY
.PSECT	CODE

.SBTTL	NXTP1	REOPEN NEXT FILE & INIT VARIABLES

; INPUT: R0 = START OF SAVESTATUS AREA - 4

.ENABL	LSB
10$:	TST	@R0		;IS THIS LAST FILE ?
	BMI	50$		;YES IF -, SO PREPARE FOR MAP OUTPUT	;DBB16
	SUB	#S.VSIZ+2,R0	;R0 -> NEXT FILE BLK
NXTP1:	MOV	(R0)+,IEOI	;SET OVERLAY PTR IN BUFFER STATUS
	MOV	(R0)+,SEGNUM	;EXTRACT THE SEGMENT # FROM END
	BIC	#^CSY.SEG,SEGNUM ; FLAG WORD, CURRENT INPUT SEGMENT #
	BEQ	20$		;WHEN SEGMENT # BECOMES NE 0 THEN
	TST	ENDRT		; REMEMBER END OF SYMBOL TBL FOR ROOT
	BNE	20$		;IF NE THEN ALREADY HAVE IT
	MOV	ENDOL,ENDRT	;END OF SYMBOL TABLE LIST FOR ROOT
20$:	CLR	TXTBLK+BYT	;SET FLAG FOR START OF NEXT MODULE	;DBB05
				; FOR TRANSFER ADR PROCESSING		;DBB05
	TSTB	PAS1.5		;ARE WE ON LIBRARY PASS ?
	BPL	30$		;NO IF +
	BIT	#FL.IB,-(R0)	;SKIP ALL NON-LIBRARY FILES ON LIBRARY PASS
	BEQ	10$		;LIBR FILE IF BIT SET
	INCB	LIBNB		;BUMP LIBRARY FILE # FOR LML
	TST	(R0)+		;R0 -> 5 WDS SAVESTATUS PART
30$:	MOV	R0,FILPT	;UPDATE FILE PTR
	CLR	CURBLK		;RESET RELATIVE BLK COUNTER
	.REOPEN	#PRAREA,#3,FILPT ;REOPEN CHAN 3				;DBB17
	BCS	40$		;SHOULD NOT HAPPEN
	RETURN

40$:	ERROR$	ERR2,E$F,E$FIL	;READ ERROR IN <FILENAME>

50$:	JMP	ENDPAS		;FINISH UP PASS 1			;DBB16

.DSABL	LSB

.SBTTL	-	SCAN ONLY LIBRARIES

; PASS 1.5 SCANS ONLY LIBRARIES

.ENABL	LSB
10$:	CLRB	LIBNB		;RESET LIBRARY FILE #
	TSTB	FLGWD		;IF NOT OVERLAIED THEN ENDOL IS OK
	BPL	20$		;IF + THEN NOT OVERLAID
	MOV	ENDRT,ENDOL	;RESET END OF LIST PTR FOR LIBS
20$:	JMP	PA1		;GO DO MAIN LOOP PROCESSING

.SBTTL	PASS1::	DETERMINE WHAT PHASE OF PASS1 WE ARE DOING

PASS1::	MOV	#PAS1.5,R0	;R0 -> PASS 1 PHASE INDICATOR
	TSTB	@R0		;PAS1.5 = 0 IF STARTING PASS1
	BEQ	20$		;	BIT 0 SET IF TO DO 1.5
				;	< 0 IF DOING 1.5 (BIT 7 SET)
	ASRB	@R0		;BIT 0 INTO CARRY & CLEAR IT, STILL NEG
	BCS	10$		;C = 1 IF LIBRARY PASS REQUIRED
	CALL	ANYUND		;ARE THERE ANY UNDEFINED GLOBALS LEFT?	;DBB15+
	BEQ	40$		;IF EQ NO.  SO, NO WEAK SYMBOLS LEFT


; GET A WEAK SYMBOL FROM THE UNDEFINED SYMBOL TABLE LIST

30$:	MOV	@R1,R1		;PICK UP STATUS WORD
	BIC	#SY.ENB,R1	;ISOLATE ENTRY #
	BEQ	40$		;ENTRY # = 0 -> END OF UNDEF SYM LIST	;DBB06
	SYMADR	R1		;GET PHYSICAL ADR

	BIT	#SY.WK,@R1	;IS THIS A WEAK SYMBOL?
	BEQ	30$		;IF EQ NO

; WE HAVE A WEAK SYMBOL POINTED TO BY R1
; NOW DEFINE IT WITH ABS VALUE OF 0

	MOV	ASECT,CSECT	;ALL WEAK SYMBOLS GO IN . ABS. PSECT
	CLR	BASE		;CLEAR BASE SINCE WE ARE IN .ABS PSECT
	MOV	R1,R0		;SET UP R0 FOR "DEFREF"
	MOV	-(R1),-(SP)	;SAVE UNDEFINED SYMBOL POINTER
	MOV	#TXTBLK,R3	;GENERATE A FAKE GLOBAL SYMBOL NAME ENTRY
	MOV	S.YNAM(R0),(R3)+ ;PUT FIRST WORD OF SYMBOL NAME IN ENTRY
	MOV	S.YNAM+2(R0),(R3)+ ;PUT SECOND WORD OF SYMBOL NAME IN ENTRY
	MOV	#<4*400+SY$DEF>,(R3)+ ;PUT ENTRY TYPE AND FLAG BYTES IN ENTRY
	CLR	@R3		;VALUE WORD IS 0
	TST	-(R3)		;R3 -> FLAG BYTE
	CALL	DEFREF		;DEFINE A REFERENCED SYMBOL
	MOV	(SP)+,R1	;RESTORE UNDEFINED SYMBOL POINTER
	BR	30$		;GO DO NEXT SYMBOL

40$:	JMP	ENDP1		;FINISH PASS 1				;DBB15-



.DSABL	LSB

.SBTTL	PA1	PROCESS FORMATTED BINARY RECORDS

PA1:	MOV	SP,EOFSP	;SAVE SP FOR END-OF-FILE PROCESSING	;DBB16
	MOV	FILPT1,R0	;R0 -> START OF SAVESTATUS AREA -4
	CALL	NXTP1		;SETUP 1ST FILE INFORMATION
	MOV	#NXTP1,NXTFIL	;SETUP ADR FOR NEXT FILE PROCESSING
	CALL	NEWBUF		;START READ OF 1ST BUFR

.SBTTL	* MAJOR LOOP TO PROCESS ALL FILE'S BINARY RECORDS *

;+
; DURING OBJECT FILE INPUT
; R4 -> NEXT INPUT BUFFER BYTE
; R5 = # OF BYTES IN FORMATTED BINARY BLK
;-

10$:	CALL	NEWBLK		;START NEW FORMATED BINARY BLK		;DBB05+
	TST	TXTBLK+BYT	;NEW MODULE?
	BNE	20$		;IF NE NO
	MOV	CURBLK,TXTBLK+BLK ;STORE START OF MODULE
	MOV	R4,TXTBLK+BYT	;STORE START OF MODULE
	SUB	#6,TXTBLK+BYT	; (NEWBLK ADDED 6)
20$:	ASL	R0		;MAKE WORD INDEX			;DBB05+
	CMP	#DSPTBE-DSPTBL,R0 ;LEGAL BLOCK TYPE?
	BLOS	ILFMT		;NO
	CALL	@DSPTBL(R0)	;CALL BLOCK DEPENDENT ROUTINE
	BR	10$		;GO AGAIN

ILFMT:	ERROR$	ERR4,E$F,E$FIL	;ILLEGAL RECORD TYPE IN <FILENAME>

.PSECT	DATA

.SBTTL	 FORMATTED BINARY RECORD TYPE DISPATCH TABLE

DSPTBL:	.WORD	ILFMT		; 0 - ILLEGAL BLOCK TYPE
	.WORD	GSD		; 1 - START GSD RECORD
	.WORD	SKPBLK		; 2 - END OF GSD
	.WORD	SKPBLK		; 3 - TXT
	.WORD	SKPBLK		; 4 - RLD
	.WORD	SKPBLK		; 5 - ISD (INTERNAL SYMBOL DEFINITION)
	.WORD	MODND		; 6 - MODULE END
	.WORD	LIBRA		; 7 - LIBRARY HEADER RECORD
	.WORD	SKPBLK		;10 - END OF LIBRARY FILE
DSPTBE:				;END OF TABLE

.PSECT	CODE

.SBTTL	GSD	PROCESS GSD TYPES

; ENTER HERE TO START NEW GSD ITEM

.ENABL	LSB

10$:	MOV	#4,R2		;4 WORDS IN EACH GSD ITEM
	MOV	#TXTBLK,R3	;R3 ->STORAGE AREA FOR GSD BLK
	MOV	R3,R1		;(COPY POINTER)
20$:	CALL	GETWD		;GET A WORD FROM GSD RECORD
	MOV	R0,(R1)+	;PUT GSD ITEM INTO TXTBLK AREA
	SOB	R2,20$
	MOVB	S$YCOD(R3),R0	;NO, TEST CODE FOR LEGALITY
	ASL	R0		;TIMES 2
	CMP	#PA1TBE-PA1TBL,R0 ;INSIDE TABLE?
	BLOS	40$		;ERROR - BAD GSD CODE
	TST	SW.LML		;LIBRARY MODULES TO GO INTO OVERLAYS?	;MAS23+
	BPL	30$		;PL -> NOT DOING LIBRARY PREPROCESS PASS
	CMP	#GBLSYM,R0	;MI -> ONLY PROCESS GBL SYMBOLS
	BNE	GSD		;NE -> SKIP THIS GSD RECORD, EQ -> DO GBL SYM
30$:	CALL	@PA1TBL(R0)	;CALL ROUTINE TO HANDLE GSD ENTRY	;MAS23-
GSD:	TST	R5		;ANY BYTES REMAINING IN F.B. BLK?
	BGT	10$		;YES, PROCESS NEXT GSD ITEM
	CALLR	BYTE		;GET CHECKSUM BYTE
				;RETURN TO GET NEW DATA BLOCK

40$:	ERROR$	ERR21,E$F,E$FIL	;BAD GSD IN <FILENAME>

.DSABL	LSB

.PSECT	DATA

;+
; INPUT TO THE FOLLOWING ROUTINES IS:
; R0, R1, & R2 ARE FREE TO USE
; R3 -> START OF GSD ITEM (1ST WD OF SYM NAME)
;-

PA1TBL:	.WORD	MODNME		; 0 - MODULE NAME
	.WORD	CSECNM		; 1 - CSECT NAME
	.WORD	ISDNAM		; 2 - ISD ENTRY (IGNORED)
	.WORD	TADDR		; 3 - TRANSFER ADDRESS
	.WORD	SYMNAM		; 4 - GLOBAL SYMBOL
	.WORD	PSECNM		; 5 - PSECT NAME
	.WORD	PGMIDN		; 6 - IDENT DEFINITION
	.WORD	VSECNM		; 7 - VIRTUAL SECTION
PA1TBE:				;END OF TABLE

.PSECT	CODE

.SBTTL	CSECNM	CONTROL SECTION NAME

;+
; THIS WILL MAKE THE CSECT AN EQUILAVENT PSECT BY SETTING THE FLAG BITS.
; NAMED .CSECT = .PSECT NAME,  GBL,REL,I,OVR,RW
; 	.ASECT = .PSECT . ABS.,GBL,ABS,I,OVR,RW
; BLANK .CSECT = .PSECT       ,LCL,REL,I,CON,RW
; THE ASECT WAS SETUP IN THE SYMBOL TABLE BY THE INITILAZITION OVERLAY.
;-

CSECNM:	MOV	#CS$REL,R1	;SET FLAGS AS A BLANK PSECT
	TST	@R3		;IS THIS A BLANK NAME?
	BEQ	30$		;YES
	CMP	(R3)+,(PC)+	;IS IT AN ASECT ?
	.RAD50	/. A/
	BNE	10$		;NO
	CMP	#^RBS.,@R3
	BNE	10$
	MOV	#CS$GBL+CS$ALO,R1 ;YES, SET BITS FOR ABS PSECT
	BR	20$

10$:	MOV	#CS$GBL+CS$ALO+CS$REL,R1 ;FLAG FOR NAMED SECTION
20$:	TST	-(R3)		;R3 -> 1ST WD OF NAME
30$:	MOVB	R1,S$YFLG(R3)	;SET FLAGS BYTE IN GSD BLK
				;GO PROCESS AS A PSECT

.SBTTL	PSECNM	PROGRAM SECTION NAME

;+
; SECTION NAMES ARE ALWAYS DEFINITIONS THUS NEVER FOUND IN THE UNDEFINED
; SYMBOL LIST.
;-

.ENABL LSB

PSECNM:	INC	LRUNUM		;COUNT SECTIONS IN A MODULE
	MOV	#^CSY.SEC,LKMSK ;CARE ABOUT SECTION FLG
	MOV	#SY.SEC,LKWD	;SECTION NAME LOOKUP
	BITB	#CS$SAV,S$YFLG(R3) ;DOES PSECT HAVE SAVE ATTRIBUTE?	;DBB15+
	BEQ	10$		;IF EQ NO
	BISB	#CS$GBL,S$YFLG(R3) ;FORCE PSECT TO ROOT VIA GBL ATTRIBUTE
10$:	BITB	#CS$GBL,S$YFLG(R3) ;LOCAL OR GLOBAL SECTION ?		;DBB15-
	BNE	20$		;LCL IF 0
	MOV	#^C<SY.SEC+SY.SEG>,LKMSK ;CARE ABOUT SECTION FLG & SEGMENT #
	BIS	SEGNUM,LKWD	;LOCAL SECTION QUALIFIED BY SEGMENT #
20$:	CALL	LOOKE		;PUT SECTION NAME IN SYMBOL TBL IF NEW

; THE FOLLOWING BRACKETED INSTRUCTIONS MUST NOT DIDDLE THE CARRY BIT!!!

	BITB	#CS$SAV,@R3	;DOES PSECT HAVE SAV ATTRIBUTE?		;DBB15
	BEQ	30$		;BRANCH IF NOT
	BIS	#SY.SAV,@R0	;INDICATE SAV ATTRIBUTE IN PSECT ENTRY	;DBB15
30$:	BICB	#<CS$NU+CS$LIB+CS$SAV>,@R3 ;ALL UNSUPPORTED FLAG BITS	;DBB15
	MOV	R0,CSECT	;PTR TO SYM TBL ENTRY
	BCC	OLDPCT		;C=1 FOR NEW SYMBOL, C=0 FOR OLD SYMBOL

; CARRY IS SAFE TO DIDDLE NOW!

	TSTB	PAS1.5		;TEST IF DOING LIBRARY MODULE		;MAS10+
	BMI	LIBPCT		;YES->HANDLE SPECIAL CASE
SEG0:	BIS	SEGNUM,S.YSN(R0) ;SET SEGMENT # INDEPEND. OF LCL OR GBL	;MAS10-
	CALL	GEN0		;CREATE FORWARD ENTRY # PTR TO NEW NODE
	BIC	#^CSY.ENB,@ENDOL ;INSURE PTR CLEARED
	BIS	R1,@ENDOL	;ENDOL -> CURRENT END OF LIST
	MOV	R0,ENDOL	;NEW END OF LIST FOR THIS SECTION
P1:	BISB	@R3,S.YFLG(R0)	;SECTION FLAGS BYTE IN SYMBOL TBL
	CLR	-2(R0)		;LENGTH=0 INITIALLY FOR NEW SECTION

PLOOP:	CALL	CHKRT		;PUT PSECT IN ROOT IF NECESSARY		;DBB15
	MOV	(R3)+,R1	;SECTION FLAGS IN R1
	BIT	#CS$REL,R1	;ABSOLUTE SECTION?
	BNE	40$		;NO
	BIT	SWITCH,#SW.X	;YES, /X TOO?
	BEQ	40$		;NO /X
	CLR	@R3		;/X, SAY SIZE =0
40$:	BIT	#CS$TYP,R1	;INSTRUCTION SECTION?
	BEQ	50$		;YES, ROUND IT
	BIT	#CS$ALO,R1	;CON SECTION ?
	BEQ	60$		;YES, BOTH A DATA & CON SECTION DON'T GET ROUNDED
50$:	INC	@R3		;ROUND SECTION SIZE TO WORD BOUNDARY
	BIC	#1,@R3
60$:	BIT	#CS$ALO,R1	;OVERLAYED SECTION?
	BEQ	80$		;NO, ADD UP SIZE CONTRIBUTION
	CLR	BASE		;OVR PSECT, GBL SYM OFFSET IS
				; FROM START OF SECTION
	CMP	-(R0),@R3	;YES, KEEP LARGEST SIZE OF OVR SECTION FOUND
	BHIS	70$
	MOV	@R3,@R0		;SAVE NEW LENGTH
70$:	RETURN

80$:	MOV	-(R0),BASE 	;BASE SIZE OF SECT FOR GBL SYM OFFSET CALC
	ADD	@R3,@R0		;CON CONTRIBUTION TO SIZE OF SECTION
	BCC	90$		;C=1 IF SIZE OVERFLOW
	ADD	#S.YNAM+2,R0	;R0 -> SECTION NAME
	ERROR$	ERR47,E$W,E$SYM,R0 ;SIZE OVERFLOW OF SECTION <SYMBOL>
90$:	RETURN

.DSABL LSB

;+
; INSERT LIBRARY MODULE INTO THE CORRECT SEGMENT.			;MAS10+
; MUST FIND THE END OF THE OVERLAY SEGMENT FOR THE
; LIBRARY MODULE, THEN LINK IN THE MODULE.
;-

LIBPCT:	MOV	SEGNUM,R2	;R2->SEGMENT # FOR LIBRARY MODULE
	BEQ	SEG0		;R2=0 THEN ALL SET FOR LIB INTO ROOT	;DBB06
	MOV	R3,-(SP)	;SAVE GSD SYMBOL POINTER
	CALL	SEGFND		;GO FIND THE CORRECT SEGMENT NUMBER
	MOV	@R3,R1		;R1->ENTRY # POINTER TO 1ST SYM. IN SEG
10$:	SYMADR	R1		;GET PHYSICAL ADDR
	MOV	R1,R2		;SAVE LAST SYM ADDR
	MOV	@R1,R1		;GET NEXT ENTRY POINTER
	BIC	#SY.ENB,R1	;CLEAR EXTRA BITS
	BNE	10$		;=0 -> END OF SECTION, OTHERWISE KEEP TRYING
	CALL	GEN0		;FOR LIBRARY SECTION
	BIS	R1,@R2		;AND LINK IT IN
	BIC	#^CSY.ENB,@R0	;CLEAR END OF SEGMENT IN LIBRARY MOD
	MOV	(SP)+,R3	;RESTORE REGISTERS
	BIS	SEGNUM,S.YSN(R0) ;SET SEGMENT NUMBER
	BR	P1		;NOW SIZE NEW SECTION			;MAS10-

; AT THIS POINT SYMBOL WAS ALREADY ENTERED INTO SYMBOL TBL		;DBB15+

OLDPCT:	MOVB	S.YFLG(R0),R2	;GET PSECT FLAG BITS IN R2
	BICB	#<CS$NU+CS$LIB+CS$SAV>,R2 ;GET RID OF UNUSED FLAG BITS
	CMPB	R2,@R3		;ARE SECTION ATTRIBUTES THE SAME?
	BEQ	10$		;YES IF EQ
	MOV	R0,-(SP)	;SAVE IT
	ADD	#S.YNAM,R0	;R0 -> SECTION NAME
	ERROR$	ERR10,E$W,E$SYM,R0 ;CONFLICTING SECTION ATTRIBUTES <SYMBOL>
	MOV	(SP)+,R0
10$:	BR	PLOOP

CHKRT:	MOV	S.YSN(R0),R2	;SEGMENT # & ATTRIBUTES WORD OF SYM
	BIT	#CS$GBL*400,R2	;GLOBAL SECTION?
	BEQ	90$		;NO IF 0, SO RETURN
	BIC	#^CSY.SEG,R2	;CLEAR NON-SEGMENT # BITS
	BEQ	90$		;ALREADY DEFINED IN ROOT SEGMENT, SO OK
	BIT	#SY.SAV,@R0	;IS THIS A SAV PSECT?
	BNE	10$		;IF NE YES; IT MUST BE PUT IN THE ROOT
	CMP	SEGNUM,R2	;ARE THE SEGMENTS DIFFERENT?
	BEQ	90$		;NO IF EQ
10$:	MOV	R0,-(SP)	;SAVE PTR TO LINK WORD

;+
; A GLOBAL SECTION IS REFERENCED IN 2 DIFFERENT SEGMENTS OR AND WAS NOT
; DEFINED IN THE ROOT.  OR, A SAV PSECT WAS NOT DEFINED IN THE ROOT.
; SUCH A SECTION AND ALL ITS GLOBAL SYMBOLS MUST BE ALLOCATED IN THE
; ROOT.  REMOVE THE SECTION(& GLOBALS) FROM THE OVERLAY SEGMENT LIST
; (DETERMINED BY SEG # OF FOUND SYMBOL), RELINK THAT FORWARD LINKED
; LIST, AND PLACE THE GLOBAL SECTION IN THE ROOT SEGMENT LINKED LIST.
;
;	ENDRT = END OF SYMBOL TABLE LIST FOR ROOT BEFORE LIBRARY PASS
;	ENDOL = END OF SYMBOL TABLE LIST FOR ROOT DURING LIBRARY PASS
;	R0 -> SECTION TO MOVE TO ROOT
;	R1  USED AS POINTER THRU LIST
;	R2 = SEGMENT # WHERE SECTION IN SYM TBL WAS DEFINED
;-

	MOV	R3,-(SP)	;SAVE GSD POINTER			;MAS10

; FIND THE OVERLAY SEGMENT BLOCK WHICH MATCHES THE SEGMENT #

	CALL	SEGFND		;GET PROPER SEGMENT			;MAS10
	CALL	GEN0		;TO AN ENTRY # PTR & LINK FORWARD THE
	TSTB	PAS1.5		;LIBRARY PASS?				;MAS37+
	BPL	20$		;PL-> NO, ADJUST ENDRT
	BIS	R1,@ENDOL	;OTHERWISE DO ENDOL WHICH IS NOW BEING
	BR	30$		;USED AS THE END OF LIST		;MAS37-

20$:	BIS	R1,@ENDRT	;ROOT LIST TO THIS GBL SECTION
30$:	MOV	@R3,R1		;R1 = ENTRY # PTR FOR 1ST SYM OF SEG LIST
40$:	BIC	#SY.ENB,R1	;ISOLATE THE ENTRY # PTR		;DBB01+
	BEQ	ILERR		;END-OF-LIST IF 0, SHOULD HAVE MATCHED
	SYMADR	R1		;CONVERT ENTRY # PTR TO PHYSICAL ADDR
	CMP	R0,R1		;ARE WE AT THE CORRECT SECTION
	BEQ	50$		;YES IF EQUAL
				; R3 -> SYMBOL BEFORE SECTION TO MOVE
	MOV	R1,R3		;REMEMBER PREVIOUS SYM TBL ADR
	MOV	@R1,R1		;GO TO NEXT SYMBOL IN LIST
	BR	40$		;CONTINUE SEARCH

50$:	BIC	#^CSY.ENB,@R3	;CLEAR LINK TO NEXT PTR
	CALL	SUNS		;SCAN UNTIL NEXT SECTION OR END OF LIST
	BEQ	60$		;END OF LIST IF EQ
	CALL	GEN		;NOW HAVE THE BOUNDS OF SECTION AND
				;GLOBALS TO LINK INTO THE ROOT
	BIS	R1,@R3		;LINK PREVIOUS SYMBOL TO NEXT SYMBOL
				;LIST WHERE REMOVING SECTION
				;R0 -> LAST SYMBOL OF SECTION MOVED
60$:	BIC	#^CSY.ENB,@R0	;INDICATE END OF LIST FOR ROOT LIST	;MAS08
	TSTB	PAS1.5		;LIBRARY PASS?				;MAS37+
	BPL	70$		;PL-> NO, ADJUST ENDRT
	MOV	R0,ENDOL	;OTHERWISE DO ENDOL WHICH IS NOW BEING
	BR	80$		;USED AS THE END OF LIST		;MAS37-
									;DBB01-
70$:	MOV	R0,ENDRT	;UPDATE END OF ROOT LIST
	CMP	R0,ENDOL	;DID WE MOVE THE LAST PSECT ON CURRENT
	BNE	80$		; SEGMENT LIST TO ROOT?  BRANCH IF NOT
	MOV	R3,ENDOL	;POINT END-OF-SEG PTR TO PREV. ELEMENT
80$:	MOV	(SP)+,R3	;RESTORE GSD PTR
	MOV	(SP)+,R0	;PTR TO LINK WORD
90$:	RETURN								;DBB15-

ILERR:	ERROR$	ERR0,E$F,E$PRT	;THIS SHOULD NEVER HAPPEN, IF IT DOES, THEN A BUG

.SBTTL	SEGFND	ROUTINE TO FIND PROPER OVERLAY SEGMENT			;MAS10+

;+
; EXCLUDING ROOT SEGMENT.USED TO LINK IN LIBRARY MODULES, AND
; FOR REMOVAL OF PSECTS TRANSFERED TO ROOT.
;-

SEGFND:	MOV	#ASECT,R3	;R3 -> ROOT SEGMENT BLK
	MOV	R2,-(SP)	;SEGMENT ID = SEGMENT # *6
	ASL	R2
	ADD	(SP)+,R2
	ASL	R2		;ROOT SEGMENT ALREADY EXCLUDED
10$:	MOV	S.GNXP(R3),R1	;NEXT SEGMENT BLK THIS REGION
	BNE	20$		;IF NE THEN THERE IS A NEXT
	MOV	S.GRGP(R3),R3	;R3 -> OVERLAY REGION BLK
	MOV	R.GNXP(R3),R3	;NEXT REGION BLK ADR
	BEQ	ILERR		;NO MORE REGIONS IF 0,
				; * SHOULD FIND PROPER SEGMENT BEFORE NOW
	MOV	R.GSGP(R3),R1	;ADR OF SEGMENT BLK THIS REGION
20$:	MOV	R1,R3		;SAVE SEGMENT BLK ADR
30$:	CMP	S.GID(R3),R2	;AT THE PROPER OVERLAY SEGMENT BLK ?
	BNE	10$		;NO IF NE
	RETURN								;MAS10-

;+
; LOCAL SUBROUTINE TO SCAN UNTIL NEXT SECTION FOUND OR
; END-OF-LIST. IF END OF LIST THEN Z =1
;-

SUNS:	BIT	#SY.DUP,@R1	;IS IT A DUP SYMBOL?			;DBB04+
	BNE	10$		;.NE. -> YES, LEAVE SEG. NUM. ALONE
	BIC	#SY.SEG,S.YSN(R1) ;SYMBOL NOW DEFINED IN ROOT SEGMENT
10$:	MOV	R1,R0		;SAVE ADR OF CURRENT SYMBOL		;DBB04-
	MOV	@R1,R1		;GO THRU LIST UNTIL FIND NEXT SECTION
	BIC	#SY.ENB,R1	;OR END OF LIST
	BEQ	20$		;IF 0, NO FORWARD LINK REQUIRED
	SYMADR	R1		;R1 -> NEXT SYMBOL IN LIST
	BIT	S.YSN(R1),#SY.SEC ;IS SYMBOL A SECTION ?
	BEQ	SUNS		;NO IF 0
20$:	RETURN

.SBTTL	VSECNM	VIRTUAL SECTION

;+
; A VIRTUAL SECTION HAS BEEN FOUND WHICH IS PROCESSED SIMILAR TO
;	.PSECT	. VIR.,RW,D,GBL,REL,CON
; THE SIZE IS THE NUMBER OF 32 WORD AREAS REQUIRED.
; THE SEGMENT # IS DEFINED AS THE ROOT (ZERO).
; THERE WILL NEVER BE ANY GLOBALS UNDER THIS SECTION AND THE SECTION
; STARTS AT A BASE OF ZERO.
;-

VSECNM:	MOV	R3,-(SP)	;SAVE RECORD PTR
	CALL	PSECNM		;HANDLE AS A P-SECTION
	MOV	(SP)+,R3

;+
; IF $VIRSZ ALREADY IN SYM TBL THEN JUST ADD SIZE OF CURRENT VSECT TO IT
; ELSE ENTER NEW SYMBOL "$VIRSZ" WITH VALUE EQUAL TO CURRENT SIZE.
;-

	MOV	S$YVAL(R3),BASE	;SAVE SIZE OF CURRENT SECTION
	MOV	#VIRSZ,R3	;R3 -> SYMBOL NAME
	CLR	LKWD		;GLOBAL SYMBOL LOOKUP
	MOV	#^CSY.SEC,LKMSK	;CARE ABOUT SECTION BIT
	CALL	LOOKE		;ENTER SYMBOL IN NOT THERE
	BCS	SYMV		;C=1 IF NOT FOUND
				; TREAT AS ABSOLUTE GLOBAL SYM,(ONLY ONCE)
				; BASE IS THE SYMBOLS VALUE, IT WILL RETURN
	ADD	BASE,-(R0)	;$VIRSZ ALL READY IN TABLE, ADD NEW SECTION
				; TO CURRENT VALUE OF $VIRSZ
RTN:	RETURN			;ALL DONE WITH VSECT'S

.PSECT	DATA

VIRSZ:	.RAD50	\$VIRSZ\	;GLOBAL SYMBOL NAME FOR SIZE OF VIRTUAL SECTION
	.BYTE	SY$DEF		;FLAGS BYTE
	.BYTE	4		;GLOBAL SYMBOL
	.WORD	0		;VALUE WORD

.PSECT	CODE

.SBTTL	SYMNAM	GLOBAL SYMBOL

;+
; DUPLICATE SYMBOLS DEFINED OR REFERENCED IN THE ROOT MUST BE MADE	;DBB08+
; NON-DUPLICATE EXCEPT WHERE A REFERENCE IS TO A DEFINED SYMBOL.
; ALL DEFINITIONS OF DUPLICATE SYMBOLS BY A NON-LIBRARY MODULE ARE
; ALSO MADE NON-DUPLICATE.  IN ALL CASES WHERE A DUPLICATE SYMBOL IS
; MADE NON-DUPLICATE, A WARNING MESSAGE IS GENERATED.			;DBB08-
;
; INPUT:R3 -> START OF GSD ITEM (1ST WD OF SYMBOL NAME)
; VALUE = RELATIVE TO THE SECTION UNDER WHICH IT IS DEFINED.
;-
.ENABL	LSB

SYMNAM:	CLR	LKWD		;GLOBAL SYM LOOKUP
	MOV	#^CSY.SEC,LKMSK	;CARE ABOUT SECTION FLG ON LOOKUP
	BIT	#SY$DEF,S$YFLG(R3) ;IS SYMBOL DEFINED HERE?		;DBB06+
	BNE	50$		;NE -> YES
	TST	SEGNUM		;REFERENCE FROM ROOT?			;DBB08+
	BNE	30$		;.NE. -> NO.  NORMAL LOOKUP

	CALL	DLOOKE		;YES.  ADDR OF SYMBOL IN R0
	ROR	-(SP)		;SAVE CARRY ON STACK AS SIGN BIT
	BIT	#SY.DUP,@R0	;IS IT A DUP SYMBOL?
	BEQ	20$		;= -> NO
	TST	@R0		;IS SYMBOL DEFINED?
	BMI	10$		;NO.  MAKE NON-DUP
	BIS	#SY.IND,@R0	;EXT. REF.
	BR	20$

10$:	CALL	DELETE		;DELETE ALL OTHER COPIES OF SYMBOL
	CALL	FORCE0
20$:	ROL	(SP)+		;RESTORE CARRY BIT (SYMBOL ENTERED BIT)
	BR	40$

30$:	CALL	LOOKE		;ADDR OF SYMBOL IN R0
				;R3 -> VALUE WORD OF INPUT GSD ITEM
40$:	JMP	DOREF		;SYMBOL IS REFERENCED HERE		;DBB08-

50$:	TST	SW.LML		;LIBRARY PREPROCESS PASS?
	BMI	RTN		;MI -> YES.  IGNORE PREPROCESS PASS DEFS
	TSTB	PAS1.5		;LIBRARY DEFINITION?			;DBB08+
	BPL	60$		;>=0 -> NO.  GET RID OF DUPS
	TST	SEGNUM		;ROOT DEF?
	BNE	90$		;NE -> NO, NORMAL LOOKUP

60$:	CALL	DLOOKE		;NO.  ADDR OF SYMBOL IN R0
				;R3 -> VALUE WORD OF INPUT GSD ITEM
	ROR	-(SP)		;SAVE CARRY ON STACK AS SIGN BIT
	BIT	#SY.DUP,@R0	;IS IT A DUP SYMBOL?
	BEQ	80$		;= -> NO
	CALL	DELETE		;DELETE ALL OTHER COPIES OF SYMBOL
	TSTB	PAS1.5		;LIBRARY DEF?
	BMI	70$		;MI -> YES, MUST BE A ROOT DEF
	ADD	#S.YNAM,R0	;R0 -> 1ST WORD OF RAD50 SYMBOL NAME
	ERROR$	ERR70,E$W,E$SYM,R0 ;DUP SYMBOL DEFINED IN
	CLR	R0		   ; NON-LIBRARY FILE
	ERROR$	ERR71,E$N,E$FIL	;R0=0 INDICATES CURRENT FILE
	MOV	R2,R0		;RESTORE R0 ('DELETE' SAVED IT IN R2)
	BR	80$

70$:	CALL	FORCE0		;ROOT DEF. FORCES LIB MOD TO ROOT
80$:	ROL	(SP)+		;RESTORE CARRY BIT (SYMBOL ENTERED BIT)
	BR	100$		;PROCESS AS NORMAL DEFINITION		;DBB08-

90$:	CALL	LOOKE		;ADDR OF SYMBOL IN R0
100$:	BCS	140$		;C=1 -> NEW SYMBOL
DEFREF:	MOV	@R0,R1		;OLD SYMBOL.  DEFINED BEFORE?		;DBB15
	BMI	130$		;MI -> DEFINES A REFERENCED SYMBOL	;DBB06-

;+
; SYMBOL WAS DEFINED BEFORE, ABSOLUTE SYMBOLS WITH SAME VALUE NOT
; MULTIPLY DEFINED.
;-

	BIT	#SY$REL,@R3	;ABSOLUTE SYMBOL ?
	BNE	110$		;NO
	CMP	2(R3),S.YVAL(R0);IF VALUES = THEN OK
	BEQ	120$
110$:	ADD	#S.YNAM,R0	;POINT TO SYMBOL
	ERROR$	ERR24,E$W,E$SYM,R0 ;MULT DEF OF <SYMBOL>
120$:	RETURN

130$:	CALL	REMOVE		;REMOVE ENTRY FROM UNDEFINED LIST
	BIC	#<SY.UDF+SY.WK+^CSY.ENB>,@R0 ;DEFINE SYM AND
					     ; CLEAR LINK FIELD		;DBB06
	MOV	S.YSN(R0),R1	;GET SYMBOL FLAG WD &
	BIC	#^CSY.SEG,R1	;ISOLATE SEGMENT #
	CMP	SEGNUM,R1	;IF INPUT SEG # .NE. SYM SEG # THEN
	BEQ	140$		;SET EXTERNAL REFERENCE BIT
	BIS	#SY.IND,@R0
140$:	BIC	#SY.SEG,S.YSN(R0) ;CLEAR SEGMENT # BITS &
	BIS	SEGNUM,S.YSN(R0) ;SET SEGMENT # WHERE DEFINED
	TSTB	DUPMOD		;IS THIS A DUP MOD?			;DBB12+
	BEQ	SYMV		;EQ -> NO
	BIS	#SY.DUP,@R0	;MAKE DEFINED SYMBOL DUP		;DBB12-
	BIT	#SY$REL,@R3	;ABSOLUTE SYMBOL ?
	BNE	SYMV		;NO
	BIC	#SY.DUP,@R0	;MAKE DEFINED SYMBOL UNDUP
SYMV:	CALL	GEN0		;DETERMINE THE ENTRY #
	MOV	R1,-(SP)	;SAVE ENTRY # PTR
	MOV	R0,-(SP)	;SAVE CURRENT SYMBOL TBL ADR
	MOV	S$YVAL-4(R3),-(R0) ;SYMBOL VALUE
	ADD	BASE,@R0	;FOR CON SECTION, THE SECTION SIZE BEFORE
				;THIS MODULE'S CONTRIBUTION
	MOV	@R0,-(SP)	;SAVE SYMBOL VALUE

.DSABL	LSB

;+
; START AT BEGINNING OF CURRENT SECTION AND ORDER SYMBOLS IN THIS
; SECTION BY INCREASING VALUE OR ALPHABETICALLY IF /A
;-

.ENABL LSB

ORDER:	MOV	R0,R1		;COPY SYM TBL PTR
	MOV	CSECT,R0	;R0 -> ST OF CURRENT SECTION LIST FOR SEG
	BIT	#SY$REL,@R3	;ABSOLUTE SYMBOL ?
	BNE	10$		;NO
	BIT	#CS$REL*400,S.YSN(R0) ;CURRENT SECTION AN ABS ONE?	;CER02
	BEQ	10$		;YES IF EQ THEN PLACE SYMBOLS UNDER IT	;CER02
	MOV	ASECT,R0	;R0 -> ASECT ENTRY IN SYM TBL
10$:	MOV	S.YSN(R0),-(SP)	;GIVE GLOBAL SYMBOL THE
	MOV	@SP,R2		;SAVE FOR ENDOL/ENDRT UPDATE		;DBB14
	BIC	#SY.SEC,@SP	;ATTRIBUTES OF ITS SECTION
	BIT	#SY.DUP,2(R1)	;IF DUP SYMBOL DO NOT CHANGE SEG NUM	;DBB14+
	BEQ	20$		;EQ -> NOT DUP
	BIC	#SY.SEG,@SP	;CLEAR SEG # BITS SO THEY DON'T GET BIS
	BIC	#^CSY.SEG,-(R1)	;LEAVE SEG NUM IN SYMBOL ENTRY ALONE
	BIS	(SP)+,@R1	;STORE NEW FLAGS WORD IN SYMBOL ENTRY
	BR	30$		;GO ORDER SEGMENT LIST			;DBB14-

20$:	MOV	(SP)+,-(R1)
30$:	MOV	@R0,R1		;STATUS WD OF SYMBOL IN SECTION
	BIC	#SY.ENB,R1	;ISOLATE PTR PART
	BEQ	60$		;END-OF-LIST
	SYMADR	R1		;CONVERT ENTRY # TO PHYSICAL ADDR
	BIT	S.YSN(R1),#SY.SEC ;ENTRY A SECTION?
	BNE	50$		;YES, DON'T NEED TO ORDER IT
	BIT	SWITCH,#SW.A	;ALPHABETICAL LISTING?
	BNE	ALPHA		;YES IF NE
	CMP	S.YVAL(R1),@SP	;OLD SYM VALUE .GT. NEW VALUE?
	BHI	50$		;YES, SO PLACE NEW SYM IN LIST HERE
40$:	MOV	R1,R0		;NO, UPDATE ENTRY PTR
	BR	30$		;LOOP THRU ORDERING UNTIL END-OF-LIST OR
				;NEXT SECTION FOUND

; ALPHABETICALLY SINCE /A GIVEN

ALPHA:	CMP	S.YNAM(R1),-4(R3) ;ORDER THE SYMBOLS ALPHABETICALLY
	BHI	50$		;IF HI INSERT IT HERE
	BLO	40$		;IF LO THEN GOTO NEXT SYMBOL
	CMP	S.YNAM+2(R1),-2(R3) ;2ND WORD OF SYMBOL
	BLOS	40$		;IF HI INSERT IT HERE

; NEXT SECTION TERMINATED ORDERING LOOP

50$:	CALL	GEN		;GET ENTRY #
	TST	(SP)+		;POP SYM VALUE
	BIS	R1,@(SP)+	;MOVE POINTER INTO NEW NODE
	BR	110$

; END-OF-LIST TERMINATED ORDERING LOOP

60$:	TST	(SP)+		;POP SYM VALUE

;+
; IF A LIBRARY MODULE IS PUT INTO THE ROOT, THEN ENDOL MUST BE
; RESET TO NEW END OF ROOT. (ENDRT WAS MOVED TO ENDOL
; WHEN LIBRARY PROCESSING STARTED.) IF THE LIBRARY MODULE GOES
; INTO AN OVERLAY, ENDOL MUST NOT BE UPDATED.
;-

	TST	ENDRT		;NON ZERO --> STARTED OVERLAY SEGMENTS	;MAS33+
	BEQ	90$		;= -> OK, STILL DOING ROOT SEGMENT (ENDOL)
	TSTB	PAS1.5		;ARE WE DOING A LIBRARY PASS?
	BMI	80$		;MI -> YES, PL -> NO
70$:	BIT	#SY.SEG,R2	;TEST SEGMENT WORD FOR SEGMENT 0	;DBB14
	BNE	90$		;SYMBOL NOT GOING INTO SEGMENT 0 -> OK
	MOV	@SP,ENDRT	;OTHERWISE, HAVE TO EXTEND SEGMENT 0 LIST
	BR	100$		;AND NOT OVERLAY SEGMENT LIST

80$:	BIT	#SY.SEG,R2	;IS LIBRARY MODULE GOING INTO SEG 0?	;DBB14
	BNE	100$		;NE -> NO, DO NOT ADJUST/EQ -> YES DO ENDOL
90$:	MOV	@SP,ENDOL	;END-OF-LIST PTR & CURRENT TBL ENTRY ADR ;MAS33-
100$:	TST	(SP)+		;POP ADDR OF STATUS WORD		;DBB06
110$:	BIC	#^CSY.ENB,@R0	;UPDATE THIS ENTRY WITH
	BIS	(SP)+,@R0	;ENTRY NUMBER PTR
	RETURN

.DSABL 	LSB

.SBTTL	-	PROCESS SYMBOL REFERENCE

DOREF:	BCS	ADDUDF		;C=1 IF NEW SYMBOL
	BIT	#SY$WK,@R3	;IS THIS A STRONG REFERENCE?		;DBB15+
	BNE	10$		;IF NE NO
	BIC	#SY.WK,@R0	;YES, SO MAKE SURE WEAK BIT IS CLEARED	;DBB15-
10$:	MOV	S.YSN(R0),R1	;GET SYMBOL FLAG WD &
	BIC	#^CSY.SEG,R1	;ISOLATE SEGMENT #
	CMP	SEGNUM,R1	;IF INPUT SEG # .NE. SYM SEG # THEN
	BEQ	20$		; SET EXTERNAL REFERENCE BIT		;DBB03+
	BIT	#SY.IND,@R0	;IS THIS SYMBOL ALREADY EXT. REF'D
	BNE	20$		;.NE. -> YES -> RETURN TO GSD PROCESSING
	BIS	#SY.IND,@R0	;SET EXT. REF. BIT
	TST	SW.LML		;ARE WE ON LIB. PREPROCESS PASS?
	BPL	20$		;+ -> NO -> RETURN TO GSD PROCESSING
	TST	@R0		;IS SYMBOL UNDEFINED?
	BMI	MORLML		;- -> SYMBOL IS UNDEFINED, SO FORCE
				; ANOTHER LIBRARY PREPROCESS PASS
20$:	RETURN								;DBB03-

.SBTTL	-	ADD A REFERENCED SYMBOL TO THE UNDEFINED LIST

ADDUDF:	MOV	UNDLST,R1	;ADD TO UNDEF LIST			;DBB06+
				; GET PTR TO TAIL OF UDEF LIST
	MOV	@R1,-(SP)	;SAVE PTR TO LAST SYMBOL
	MOV	R0,@R1		;SET TAIL PTR TO POINT TO CURRENT SYMBOL
	BIS	#SY.UDF,@R0	;MAKE CUR SYM UNDEFINED (ITS LINK FIELD
				; ALREADY POINTS TO UDF LIST HEAD)
	CALL	GEN0		;ENTRY # IS FORWARD PTR
	MOV	(SP)+,-(R0)	;BACKWARD PTR
	BIC	#SY.SEG,-(R0)	;CLEAR SEGMENT # BITS &
	BIS	SEGNUM,(R0)+	;SET SEGMENT # WHERE INITIAL REF
	BIC	#^CSY.ENB,@(R0)	;SET LINK FIELD OF OLD LAST UNDEF SYM
	BIS	R1,@(R0)+	; TO POINT TO CURRENT SYM
	BIT	#SY$WK,@R3	;IS REFERENCE WEAK?			;DBB15
	BEQ	MORLML		;IF EQ NO				;DBB15
	BIS	#SY.WK,@R0	;SET WEAK BIT				;DBB15
MORLML:	BIS	#AD.LML,FLGWD	;IND TO ADD TO LML LATER
				;IF LIBRARY CAUSED A NEW UNDEF SYM
				;TRY TO RESOLVE IT WITHIN CURRENT LIBR	;DBB06-
	RETURN

.SBTTL	DELETE - MAKE A DUPLICATE SYMBOL NON-DUPLICATE
;+									;DBB08+
; DELETE IS CALLED TO DELETE ALL COPIES OF A DUPLICATE SYMBOL EXCEPT
; FOR THE FIRST FROM THE SYMBOL TABLE AND FROM THE UNDEFINED LIST
; A SPECIAL (-1,0,0,0,0) ENTRY IS PLACED IN THE SYMBOL TABLE FOR
; EACH DELETED SYMBOL SO THAT LINEAR PROBE LISTS ARE NOT BROKEN FOR
; LOOKUP ROUTINES.  THE REMAINING SYMBOL IS MADE NON-DUPLICATE AND
; ITS EXTERNAL REFERENCE BIT IS SET IF THE SYMBOL HAS REFERENCES FROM
; MORE THAN 1 SEGMENT.
;
; INPUT:	R0 -> STATUS WORD OF SYMBOL TO BE MADE NON-DUPLICATE
;		R3 -> WORD FOLLOWING 2 WORD RAD50 SYMBOL NAME
;
; OUTPUT:	R0 UNCHANGED
;		R2 = R0
;		R3 UNCHANGED
;-

.ENABL	LSB

DELETE:	BIC	#SY.DUP,@R0	;MAKE SYMBOL NON-DUP
	MOV	R0,R2		;SAVE POINTER TO SYMBOL
	MOV	S.YSN(R0),R1	;SAVE FLAG AND SEGMENT WORD
10$:	BIC	#^CSY.SEG,R1	;ISOLATE SEG. NUM. IN R1
	CMP	SEGNUM,R1	;IS SYMBOL SEG. NUM. = CURRENT SEG.
	BEQ	20$
	BIS	#SY.IND,@R2	;IF NOT, SET EXT. REF. BIT
20$:	CALL	SEARCH		;FIND NEXT SYMBOL ENTRY OF DUP SYMBOL
	BCS	30$		;C=1 -> NOT FOUND
	MOV	@R0,R1		;PUT FLAGS AND LINK IN R1 FOR REMOVE
	CALL	REMOVE		;REMOVE THIS ENTRY FROM UNDEF LIST
	CLR	@R0		;MARK ENTRY DELETED
	CLR	-(R0)		;CLEAR VALUE WORD
	MOV	-(R0),R1	;SAVE FLAG AND SEGMENT WORD IN R1
	CLR	@R0		;CLEAR FLAG AND SEGMENT WORD
	CLR	-(R0)		;CLEAR 2ND WORD OF SYM NAME
	MOV	#-1,-(R0)	;PUT DELETED FLAG IN SYM NAME WD 1
	ADD	#8.,R0		;R0 -> STATUS WD.  NECESSARY FOR "SEARCH"
	BR	10$		;LOOP

30$:	MOV	R2,R0		;RESTORE R0
	CMP	(R3)+,(R3)+	;WHEN SEARCH FAILS IT DOESN'T BUMP R3
	RETURN								;DBB08-

.DSABL	LSB

.SBTTL	REMOVE & FORCE0 ROUTINES

;+									;DBB06+
; REMOVE A ENTRY FROM THE UNDEFINED LIST
;
; INPUT:	R0 -> STATUS WORD OF ENTRY
;		R1 = FORWARD PTR
;
; OUTPUT:	R0 UNCHANGED
;		R1 DESTROYED
;-

.ENABL	LSB

REMOVE:	BIC	#^CSY.ENB,@-(R0) ;CLEAR LINK FIELD OF PREVIOUS GBL SYM
	BIC	#SY.ENB,R1	;ISOLATE LINK FIELD OF CURRENT GBL SYM
	BIS	R1,@(R0)	;REPLACE PREVIOUS FORWARD LINK
	ASL	R1		;TIMES 10.
	MOV	R1,-(SP)	;SAVE TIMES 2 VALUE
	ASL	R1
	ASL	R1
	ADD	(SP)+,R1	;ADD IN  TIMES 2 VALUE
	ADD	UNDLST,R1	;PHYSICAL ADDR OF NEXT ENTRY'S BACKWARD PTR
	MOV	(R0)+,@R1	;REPLACE NEXT SYMBOL'S BACKWARD LINK
	RETURN								;DBB06-


;+									;DBB08+
; FORCE0 IS CALLED TO GENERATE THE FOLLOWING WARNING MESSAGE:
;
;	?LINK-W-DUPLICATE SYMBOL "SYMBOL" IS FORCED TO THE ROOT
;
; INPUT:	R0 -> STATUS WORD OF "SYMBOL"
;		R2 = R0
;
; OUTPUT:	R0 UNCHANGED
;		R2 UNCHANGED
;-

FORCE0:	ADD	#S.YNAM,R0
	ERROR$	ERR72,E$W,E$SYM,R0 ;DUPLICATE SYMBOL
	ERROR$	ERR73,E$N,E$PRT	   ; IS FORCED TO ROOT
	MOV	R2,R0		;RESTORE R0 ('DELETE' SAVED IT IN R2)
	RETURN								;DBB08-

.DSABL	LSB

.SBTTL	PGMIDN	PROGRAM .IDENT

.ENABL	LSB
PGMIDN:	MOV	#IDENT,R0	;R0 -> PLACE FOR IDENT
	BR	10$		;AND ENTER IT

.SBTTL	MODNME	MODULE NAME FROM .TITLE

MODNME:	MOV	#MODNAM,R0	;R0 -> PLACE FOR NAME
10$:	TST	@R0		;ALREADY HAVE ONE?
	BNE	ISDNAM		;YUP
	MOV	(R3)+,(R0)+	;COPY 2 WORDS OF SYMBOL NAME
	MOV	@R3,@R0

.SBTTL	ISDNAM	INTERNAL SYMBOL DIRECTORY(IGNORED)

ISDNAM:	RETURN
.DSABL	LSB


.SBTTL	TADDR	TRANSFER ADDRESS BLOCK

;+
; THE TRANSFER ADDRESS SECTION DEFINITION MUST APPEAR BEFORE TA BLK.
;	R0,R1,R2 FREE TO USE
; R3 -> STORAGE AREA FOR CURRENT GSD BLK
;-

TADDR:	BIT	BEGBLK+S$YVAL,#1 ;USE ONLY 1ST EVEN ONE ENCOUNTERED
	BEQ	ISDNAM		;WE ALREADY HAVE AN EVEN ONE.  RETURN
	MOV	#^CSY.SEC,LKMSK ;CARE ABOUT SECTION FLG
	MOV	#SY.SEC,LKWD	;SECTION NAME LOOKUP IN THE ROOT
	CALL	LOOKUP		;LOOKUP SECTION NAME
	BCC	10$		;C=1 IF NOT FOUND
	ERROR$	ERR31,E$W,E$PRT	;TRANSFER ADR UNDEFINED OR IN OVERLAY
	BR	ISDNAM		;RETURN

10$:	CMP	-(R3),-(R3)	;R3 -> SYMBOL NAME
	CMP	#^RA  ,@R3	;WAS IT A BLANK SECTION NAME ?
	BLOS	20$		;NO IF .GE. RAD50 "A"
	CLR	@R3		;SEGMENT # WAS USED AS FONEY NAME
20$:	BITB	S.YFLG(R0),#CS$ALO ;OVERLAY SECTION ?
	BNE	110$		;YES IF NE, NO PROBLEM WITH OFFSET
	BITB	S.YFLG(R0),#CS$REL ;IF ABS SECTION THEN OFFSET IS
				;ACTUAL TRANSFER ADDR
	BEQ	110$		;ABS IF 0
	TST	S.YVAL(R0)	;IF CURRENT SIZE IS 0 THEN OK
	BEQ	110$

;+
; MUST SCAN CURRENT MODULE TO FIND SIZE CONTRIBUTION TO
; TRANSFER ADDR SECTION TO CALCULATE PROPER OFFSET
;-

	MOV	R5,-(SP)	;SAVE CURRENT POSITION CONTEXT
	MOV	R4,-(SP)
	MOV	CURBLK,-(SP)
	MOV	@SP,R1		;CURRENT BLK - BLK INCREMENT
	SUB	IBKINC,R1	;GIVES BLOCKS CURRENTLY IN MEMORY
	MOV	R0,-(SP)	;SAVE SYMBOL TBL PTR
	MOV	TXTBLK+BLK,R5	;BLK NUMBER OF START OF MODULE
	SUB	IBKINC,R5	;BLOCK AT START OF BUFFER DESIRED	;DBB05+
	MOV	TXTBLK+BYT,R4	;BUFFER PTR
40$:	CMP	R5,R1		;IS CURRENT MODULE START ALREADY IN MEMORY ?
	BEQ	50$		;YES IF .EQ.
	MOV	R5,CURBLK	;MUST READ START OF MODULE INTO BUFR
	MOV	R4,R5		;SAVE BUFFER PTR
	CALL	NEWBUF		;READ IN THE START OF THIS MODULE
	MOV	R5,R4		;R4 -> 1ST BYTE OF MODULE
50$:	CALL	NEWBLK		;GET F.B. RECORD
	DEC	R0		;GSD RECORD = 1
	BEQ	60$		;EQ -> GSD RECORD
	CALL	SKPBLK		;SKIP ALL NON-GSD RECORDS
	BR	50$							;DBB05-

60$:	MOV	#4,R2		;4 WORDS PER GSD ITEM
	MOV	#TXTBLK+8.,R1	;TEMP STORAGE PLACE
70$:	CALL	GETWD
	MOV	R0,(R1)+	;COPY A GSD ITEM
	SOB	R2,70$
	MOVB	TXTBLK+8.+S$YCOD,R0 ;GSD ITEM CODE
	DEC	R0		;CSECT = 1
	BEQ	90$		;YES IF 0
	CMP	#5-1,R0		;PSECT = 5
	BEQ	90$
80$:	TST	R5		;ANY BYTES REMAINING IN F.B. BLK ?
	BGT	60$		;YES IF GT
	CALL	BYTE		;GET CHECKSUM BYTE
	BR	50$		;KEEP GOING

90$:	CMP	TXTBLK+8.,@R3	;PROPER SECTION NAME ?
	BNE	80$		;NO IF NE
	CMP	TXTBLK+8.+2,2(R3)
	BNE	80$

; FOUND THE PROPER SECTION

	MOV	(SP)+,R0	;RESTORE PTR TO SYMBOL TBL
	MOV	#TXTBLK+8.+S$YVAL,R4 ;R4 -> TMP STORAGE FOR FND SECTION VALUE WD
	INC	@R4		;ROUND SECTION SIZE TO WORD BOUNDARY
	BIC	#1,@R4
	MOV	-(R0),R0	;SECTION SIZE FROM SYMBOL TBL
	SUB	@R4,R0		;BASE SIZE BEFORE THIS MODULE'S CONTRIBUTION
	ADD	R0,S$YVAL(R3)	;UPDATE OFFSET VALUE
	MOV	CURBLK,R4	;SAVE IT TMP
	MOV	@SP,CURBLK	;RESTORE CONTEXT BEFORE THIS MESS
	CMP	(SP)+,R4	;IS THE CORRECT BLOCK IN CORE NOW ?
	BEQ	100$		;YES IF EQ
	SUB	IBKINC,CURBLK	;ADJUST CURBLK TO ORIGINAL BUFFER	;DBB02
	CALL	NEWBUF		;READ BACK ORIGINAL BUFFER CONTENTS	;DBB02
100$:	MOV	(SP)+,R4
	MOV	(SP)+,R5
110$:	MOV	#BEGBLK,R1	;R1 -> TRANSFER ADDR BLK
	MOV	(R3)+,(R1)+	;NAME OF THE SECTION
	MOV	(R3)+,(R1)+
	MOV	(R3)+,(R1)+	;FLAG & CODE
	MOV	@R3,@R1		;RELATIVE OFFSET FROM THE SECTION
	RETURN

.SBTTL	GEN	GET ENTRY NUMBER

;+
; INPUT:R1 = PHYSICAL ADDRESS OF A SYMBOL TABLE NODE
;
; OUTPUT:R1 = 12 BIT ENTRY NUMBER
;-

GEN0:	MOV	R0,R1		;SET UP FOR ROUTINE
GEN:	SUB	SYEN0,R1	;TAKE AWAY ADR OF NODE 0
				;FALL INTO DIV10 CODE

.SBTTL	DIV10	DIVIDE BY 10. FOR ENTRY NUMBER DETERMINATIONS

;+
; INPUT: R1 = VALUE TO DIVIDE, MUST BE LESS THAN 40960. OR 120000 OCTAL.
;
; OUTPUT: R1 - HIGH 4 BITS IS REMAINDER, LOW 12 BITS IS QUOTIENT
; ***** NOTE: THE INPUT MUST BE A MULTIPLE OF 10. SO THE REMAINDER BITS
; ARE ZERO FOR THIS PARTICULAR APPLICATION.
;-

DIV10:	MOV	#14,-(SP)	;SET LOOP COUNTER
10$:	CMP	#50000,R1	;DOES N/10 GO, CLEAR C IF NOT
	BHI	20$		;NO, DON'T SUBTRACT 10
	ADD	#130000,R1	;SUBTRACT OUT 10 SETTING C
20$:	ROL	R1		;MOVE IN NEW QUOTIENT BIT
	DEC	@SP		;LOOP UNTIL DONE
	BGT	10$
	TST	(SP)+		;POP CTR OFF
	RETURN			;QUOTIENT IN LOW 12 BITS OF R1

.SBTTL	MODND	MODULE END RECORD

MODND:	CLR	TXTBLK+BYT	;SET FLAG FOR START OF NEXT MODULE	;DBB05
	CMP	LRUNUM,HGHLIM	;DETERMINE THE MAXIMUM # OF SECTIONS
	BLO	10$		;IN ANYONE MODULE
	MOV	LRUNUM,HGHLIM	;THIS IS THE CURRENT MAX
10$:	CLR	LRUNUM		;RESET FOR COUNTING
	BIT	FLGWD,#LB.OBJ	;END OF OBJECT MODULE FROM LIBR ?
	BNE	20$		;SET IF YES
				;GO CHECK LML FOR MORE LIBRARY MODS
	CALLR	SKPBLK		;SKIP R5 BYTES WHEN NOT GSD
				;SKPBLK WILL RETURN TO CONTINUE INPUT
20$:	JMP	LIBPRO


; THE ROUTINES THAT FOLLOW ARE USED WHEN LIBRARIES ARE INVOLVED.

.SBTTL	LIBRA	LIBRARY SEARCH ROUTINE

;+
; THIS ROUTINE CHECKS FOR UNDEFINED SYMBOLS. SETTING OF THE SWITCH TO
; ENABLE LIBRARY MODULES TO GO INTO OVERLAY SEGMENTS, WILL ALTER THE
; PROCESSING OF LIBRARY MODULES.
;
; 1. LIBRARY MODULES ALL IN ROOT (SW.LML = 0)
;
; 	A. IF UNDEFINED GLOBAL SYMBOLS EXIST, THE FOLLOWING IS DONE:
;		1. THE UNDEFINED SYMBOLS ARE MATCHED WITH A LIBRARY ENTRY.
;		2. THE LIBRARY MODULE LIST IS BUILT
;		3. MORE UNDEFINED SYMBOL RESOLUTION IS ATTEMPTED.
;		4. AFTER ALL UNDEF. SYMBOLS HAVE BEEN PLACED IN THE LML,
;		   THE LML IS ORDERED.
;		5. LIBRARY MODULES ARE BROUGHT INTO CORE ACCORDING TO THE LML.
;
; 	B. IF THERE ARE NO UNDEFINED GLOBAL SYMBOLS. THE LIBRARY
;	   FILE IS CLOSED AND NO LIBRARY PROCESSING IS PERFORMED.
;
; 2. LIBRARY MODULES MAY GO INTO OVERLAYS (SW.LML = 1)
;
;	A. IF UNDEFINED GLOBAL SYMBOLS EXIST, THE FOLLOWING IS DONE:
;		1. THE UNDEFINED SYMBOLS ARE MATCHED WITH A LIBRARY ENTRY.
;		2. THE LIBRARY MODULE LIST IS BUILT
;		3. MORE UNDEFINED SYMBOL RESOLUTION IS ATTEMPTED.
;		4. AFTER ALL UNDEF. SYMBOLS HAVE BEEN PLACED IN THE LML,
;		   THE LML IS ORDERED. DUPLICATES ARE COMBINED IF POSSIBLE.
;		5. THE LIBRARY MODULES ARE PRE-PROCESSED FOR ANY NEW UNDEFINED
;		   GLOBAL SYMBOLS, AND ALL REFERNCES.
;			A. IF THERE ARE NO NEW UNDEFINED GLOBALS, SEGMENT
;			   NUMBERS ARE RESOLVED, AND ALL DUPLICATE MODULES ARE
;			   COMBINED. THE ENTIRE LIBRARY LML LIST IS ORDERED.
;			B. IF THERE ARE NEW UNDEFINED GLOBALS, THEN THE
;			   NEW UNDEFINED GLOBALS ARE PROCESSED FROM 2.A.1.
;		6. LIBRARY MODULES ARE BROUGHT INTO CORE ACCORDING TO THE LML.
;
; 	B. IF THERE ARE NO UNDEFINED GLOBAL SYMBOLS. THE LIBRARY
;	   FILE IS CLOSED AND NO LIBRARY PROCESSING IS PERFORMED.
;
; INPUT:
;	R4 	-> 	FIRST DATA WORD OF NEW BUFFER
; 	R0 - R3		CLOBBERED
;-

.ENABL	LSB

LIBRA:	CLR	TXTBLK+BYT	;RESET TO ALLOW FIRST LIBRARY MODULE	;DBB18
				; START TO BE REMEMBERED		;DBB18
	TSTB	PAS1.5		;PROCESS LIBRARY FILES THIS PASS ?
	BMI	20$		;IF NEG THEN DO LIBRARIES
	CMP	#L.HVER,@R4	;OLD VERSIONS OF LIBRARY NOT ALLOWED
	BHI	10$		;IT IS OLD
	MOV	FILPT,R0	;R0 -> CURRENT INPUT SAVESTATUS BLK
	BIS	#FL.IB,-(R0)	;INDICATE FILE IS A LIBRARY
	CLR	-(R0)		;PTS TO OVERLAY SEGMENT BLK, 0 IS NORMAL CASE
	BISB	#1,PAS1.5	;ALSO SAY LIBRARY FILE PROCESSING REQUIRED
	CALLR	CLOSE		;SKIP LIBRARY IF NOT PASS 1.5
				;GET NEXT FILE (CLOSE WILL RETURN)

10$:	ERROR$	ERR23,E$F,E$FIL	;OLD LIBRARY FORMAT IN <FILENAME>

; WE ARE ON PASS 1.5 , SO PROCESS LIBRARIES

20$:	MOV	STLML,SVLML	;SAVE START OF ALL LML'S FOR THIS LIB	;MAS23
	BIS	#LB.OBJ,FLGWD	;IND LIB FILE TO LINKER
	SUB	#6,R4		;R4 -> 1ST WD OF BUFR & C=0
	BIT	#SW.I,SWITCH	;ANY /I MODULES?			;SHD02+
	BEQ	30$		;IF EQ NO
	BIS	#FG.IP,FLGWD	;SET FLAG INDICATING /I PASS FIRST	;SHD02-
30$:	TST	SW.LML		;IS SW.LML SET?				;MAS23+
	BEQ	40$		;NO, OK
	BIS	#100000,SW.LML	;MAKE SURE BIT IS SET, /I TURNS IT OFF	;MAS23-
40$:	MOV	L$HEAB(R4),ESZRBA ;SIZE OF EPT IN BYTES
	CLR	SEGBAS		;SEGBAS->TEMP FOR /X LIB FLAG		;MAS13+
	ROR	ESZRBA		;NOW WORDS	??? C MUST = 0	???	;MAS16
	TST	L$HX(R4)	;IS /X SWITCH SET IN LIB. HEADER?
	BEQ	50$		;NO, NORMAL LIBRARY
	BIC	#100000,SW.LML	;NO PREPROCESSING ON /X LIBRARIES	;MAS23
	INC	SEGBAS		;/X LIBRARY ->SEGBAS=1			;MAS13-
	CMP	ESZRBA,IBFSIZ	;WILL  /X EPT FIT IN BUFFER?		;MAS16
	BLE	50$		;LE -> YES IT WILL FIT, CONTINUE
	CALL	ANYUND		;IF NO UNDEFS,
	BEQ	ENDLIB		; DON'T WORRY ABOUT EPT NOT FITTING
	ERROR$	ERR60,E$F,E$PRT	;/X EPT WILL NOT FIT IN BUFFER		;MAS18-

50$:	ADD	#L$HEPT,R4	;R4 -> 1ST EPT ENTRY			;MAS16

60$:	CALL	ANYUND		;IF NO UNDEFS,
	BEQ	ENDLIB		; THEN END LIBRARY

; GET AN UNDEFINED SYMBOL FROM THE UNDEFINED SYMBOL TABLE LIST

70$:	MOV	@R1,R1		;PICK UP STATUS WORD
	BIC	#SY.ENB,R1	;ISOLATE ENTRY #
	BEQ	150$		;ENTRY # = 0 -> END OF UNDEF SYM LIST	;DBB06
	SYMADR	R1		;GET PHYSICAL ADR
	BIT	#SY.WK,@R1	;IS THIS A WEAK SYMBOL?			;DBB15
	BNE	70$		;IF NE YES.  SKIP WEAK SYMBOL		;DBB15
	BIT	#SY.DUP,@R1	;IS SYMBOL A DUP SYMBOL?		;DBB13+
	BEQ	80$		;EQ -> NO, LOOK FOR SYMBOL IN EPT
	BIT	#SY.SEG,S.YSN(R1) ;IS SEG NUM FIELD ZERO?
	BEQ	70$		;EQ -> NON-REF'ED DUP SYMBOL.  SKIP IT	;DBB13-
80$:	ADD	#S.YNAM,R1	;R1 -> NEW UNDEF SYMBOL NAME WD
	BIT	#FG.IP,FLGWD	;/I PASS?				;SHD02+
	BEQ	90$		;IF EQ NO
	BIT	-S.YSN(R1),#SY.SWI ;DONE WITH /I PASS IN THIS DIRECTORY?
	BEQ	150$		;IF EQ YES
90$:	CALL	EPTSER		;SEARCH FOR SYMBOL MATCH		;SHD02-
	BCS	140$		;C=1 IF SYMBOL NOT FOUND

;+
; THE UNDEFINED SYMBOL HAS BEEN FOUND IN THE CURRENT ENTRY POINT TABLE.
; THE ASSOCIATED MODULE'S ADDRESS AND BLOCK # ARE PLACED IN THE LML.
;	R3 -> FOUND SYMBOL IN EPT
;-

	MOV	R3,-(SP)	;SAVE EPT POINTER			;MAS13
	CALL	LMLBLD		;PLACE MOD ADR IN LML
	MOV	(SP)+,R3	;RESTORE POINTER			;MAS13+
	BIT	-S.YSN(R1),#SY.SWI ;IS THIS A /I SYMBOL
	BEQ	140$		;NO
	TST	SEGBAS		;/X LIBRARY?
	BEQ	190$		;NO, PROCESS /I NOW
	MOV	R1,-(SP)	;SAVE R1				;MAS16
	BR	105$		;GO SEARCH FOR MODULE NAME

100$:	SUB	#8.,R3		;BACK ONE EPT
105$:	TST	4(R3)		;MODULE NAME?
	BPL	100$		;+ -> NOT MOD. NAME-LOOP TILL ONE FOUND
	MOV	R3,R1		;POINT TO MODULE NAME
	MOV	R1,-(SP)	;SAVE STARTING ADDR
	BR	120$		;START AT ONE AFTER THE MODULE NAME

110$:	CALL	EPTSER		;FIND THAT SYMBOL
	BCS	120$		;C=1-> NOT FOUND
	CMP	R3,@SP		;FOUND-AN EARLIER OCCURANCE?
	BHIS	120$		;NO
	MOV	#-1,@R3		;YES, CLOBBER NAME
	BR	110$		;GO AGAIN

120$:	ADD	#8.,R1		;GO TO NEXT SYMBOL
	TST	@R1		;END OF EPT?
	BEQ	130$		;0-> YES
	CMP	#-1,@R1		;HAS THE NAME ALREADY BEEN CLOBBERED?	;MAS34
	BEQ	120$		;YES, TRY NEXT ONE			;MAS34
	TST	4(R1)		;NEXT MODULE NAME?
	BPL	110$		;+ -> NOT MOD. NAME
130$:	TST	(SP)+		;POP LIMITING ADDR
	MOV	(SP)+,R1	;RESTORE R1			;MAS13-	;MAS16
140$:	ADD	#8.,R1		;R1 -> ENTRY # PTR WORD (FORWARD PTR)
	BR	70$		;CONTINUE THRU UNDEF LIST

150$:	SUB	IBFSIZ,ESZRBA	;ANY MORE EPT BUFRS TO SEARCH
	BGT	160$		;IF GT YES				;SHD02+
	BIT	#FG.IP,FLGWD	;/I PASS?
	BEQ	200$		;IF EQ NO
	BIC	#FG.IP,FLGWD	;RESET /I PASS FLAG
	MOV	#LMLPTR,R4	;SETUP TO ORDER /I
	BR	170$		;GO DO NON-/I SYMBOLS			;SHD02-

160$:	CALL	ORLIB		;ORDER LML TO KEEP IT SMALL
	CALL	NEWBUF		;YES, GET NEXT PART OF EPT & SEARCH IT
	BR	60$		;START AT BEGINNING OF UNDEF LIST AGAIN

;+
; THE END OF AN OBJECT MODULE HAS BEEN REACHED AND THERE ARE STILL MORE
; UNDEFINED SYMBOLS TO BE RESOLVED. THEREFORE, THE LIBRARY HEADER AND
; DIRECTORY MUST BE BROUGHT BACK INTO THE CURRENT BUFFER.
;-

170$:	BIC	#AD.LML,FLGWD	;RESET ADDITIVE LML SWITCH
	MOV	@R4,STLML	;SAVE LML PTR FOR ORDERING
	CLR	CURBLK		;IND LIBR HDR BLK #
	CALL	NEWBUF		;GET LIB HDR BLK
	JMP	30$							;SHD02

ANYUND:	MOV	UNDLST,R1	;R1 -> START OF UNDEFINED SYMBOL LISTHEAD
	MOV	(R1)+,R0	;ADR OF UNDEF SYMBOL
	CMP	R1,R0		;ANY UNDEFINED SYMBOLS IN LIST ?
	RETURN			;Z=1 -> NO UNDEFINED GLOBALS

; TERMINATE LIBRARY

ENDLIB:	MOV	#LMLPTR,R4	;R4 = LIBR MOD LIST PTR
	BIT	#AD.LML,FLGWD	;NEW UNDEF'S ADDED WHILE PROCESSING LIBR ?
	BNE	170$		;SET IF YES
	TST	SW.LML		;LIBRARY PREPROCESS PASS?		;MAS23+
	BPL	180$		;PL -> NO
	CALL	ORLIB1		;ORDER ALL MODULES FROM LIB/SET SEG. NUMBERS
	BIC	#100000,SW.LML	;RESET FOR FINAL OBJ. PROCESSING
	BIC	#AD.LML,FLGWD	;CLEAR NEW UNDF FLAG
	MOV	SVLML,LMLPTR	;LML POINTER -> START FOR THIS LIBRARY FILE
	MOV	SVLML,STLML	;ALSO RESET START OF LML CORRECTLY
	BR	LIBPRO		;DO FINAL LIBRARY OBJ PROCESSING	;MAS23-

180$:	BIC	#LB.OBJ+AD.LML,FLGWD ;ZERO LIBRARY FLAGS
	CLR	@(R4)+		;IND END OF LIST FOR NEXT LIBRARY
	MOV	-(R4),STLML	;UPDATE STLML WITH CURRENT LMLPTR
	CALLR	CLOSE		;GET NEXT FILE
				;CLOSE WILL RETURN TO MAIN LOOP

; END OF LIBRARY SEARCH, ORDER THE LML & READ MODULES FROM THE LIBRARY

190$:	MOV	LMLPTR,SVLML	;SET START LML PAST /I MODS, OR 	;MAS23
				;THEY WILL BE DUPLICATED		;MAS23
	BIS	#AD.LML,FLGWD	;FORCE THIS LIBRARY TO CONTINUE BEING
				;PROCESSED WHEN ENTER TERMINATE LIBRARY
200$:	CALL	ORLIB		;ORDER THIS LIBRARY LML
	MOV	STLML,LMLPTR	;START GSD PROCESSING AT CURRENT LIST

.DSABL 	LSB

LIBPRO:	CLRB	DUPMOD		;ASSUME THIS IS NOT A DUP MOD		;DBB12
	MOV	LMLPTR,R1	;GET CURRENT LML PTR
	MOV	IBUF,R2		;START ADDR OF INPUT BUFR
	MOV	CURBLK,R4	;REL BLK # OF NEXT READ
	MOV	IBKINC,R0	;# OF BLKS IN CURRENT BUFR
	SUB	R0,R4		;GIVES THE CURRENT BLK IN CORE NOW
10$:	MOV	(R1)+,R5	;LIBRARY FILE # & HIGH PART OF BLK #
	SWAB	R5		;ISOLATE LIBRARY FILE #
	CMPB	LIBNB,R5	;START OF NEW LIBRARY ?
	BNE	ENDLIB		;YES IF NE
	TST	SW.LML		;PREPROCESS PASS?
	BEQ	30$		;NO.  NO DUP MODS POSSIBLE
	BPL	20$		;PL -> NO.  CHECK FOR DUP MOD		;DBB12
	CMP	STLML,LMLPTR	;1ST LML THIS PASS THRU THE LIBRARY?
	BEQ	30$		;EQ -> YES
	CMP	-2(R1),-8.(R1)	;LML'S FOR SAME BLOCK/ SAME LIB?
	BNE	30$		;NO, DO THIS NEW ONE
	CMP	@R1,-6(R1)	;SAME OFFSET?
	BNE	30$		;NE -> NO
	MOV	2(R1),R3	;GET PTR TO SYM				;DBB11+
	BEQ	90$		;0 -> ORLIB OR LMLADJ ERROR
	MOV	S.YSN(R3),R3	;GET FLAG AND SEG NUM WORD
	BIC	#^CSY.SEG,R3	;ISOLATE SEG NUM
	CMP	SEGNUM,R3	;SAME SEG NUM?
	BNE	30$		;.NE. -> NO				;DBB11-
	CMP	(R1)+,(R1)+	;YES, DON'T DO IT TWICE, SKIP THIS ONE
	BR	10$		;TRY NEXT MODULE IN LML			;MAS23-

20$:	CMP	-2(R1),4(R1)	;IS NEXT LML FOR SAME LIB AND BLOCK?	;DBB12+
	BNE	30$		;NE -> NO.  NOT A DUP MOD
	CMP	@R1,6(R1)	;IS NEXT LML FOR SAME BYTE OFFSET?
	BNE	30$		;NE -> NO.  NOT A DUP MOD
	INCB	DUPMOD		;EQ -> YES.  SET DUP MOD FLAG		;DBB12-
30$:	CLRB	R5		;BECAUSE OF SIGN EXTEND
	BISB	1(R1),R5	;LOW ORDER BLK #
	ROR	R5		;C=0 FROM CLRB
40$:	CMP	R5,R4		;REQUESTED MOD IN BUF ?
	BEQ	80$		;YES
	BLO	50$		;LOOKING FOR IS .LT. CURRENT
	ADD	#512.,R2	;.GT. BUT MAY BE IN CORE, NEXT BLK'S BUFR ADDR
	INC	R4		;BUMP BLK # LOOKING FOR
	SOB	R0,40$		;LOOP, IT MAY BE HERE
				;NOT IN CORE, SO READ IT IN
50$:	MOV	R5,CURBLK	;IND BLK # OF LIBR OBJ MOD
	CALL	NEWBUF		;GET LIBR OBJ MOD
60$:	MOV	(R1)+,R0	;ISOLATE BYTE OFFSET
	BIC	#^C777,R0
	ADD	R0,R4		;INDEX TO PROPER BYTE OF INPUT BUFR
	MOV	(R1)+,R0	;GET SEGMENT # WORD FOR THIS MODULE	;MAS23+
	BEQ	70$		;0 -> ROOT SEGMENT (SWITCH OR NOT)
	TST	SW.LML		;PREPROCESS PASS?
	BPL	70$		;PL -> NO
	MOV	S.YSN(R0),R0	;YES, GET SEGMENT NUMBER FROM GBL SYM
	BIC	#^CSY.SEG,R0	;CLEAR EXTRANEOUS BITS
70$:	MOV	R0,SEGNUM	;SET SEGNUM PROPERLY			;MAS23-
	MOV	R1,LMLPTR	;UPDATE LML PTR
	RETURN			;PROCESS LIBRARY'S OBJ MOD

; REQUIRED MODULE IS IN THE BUFR

80$:	MOV	R2,R4		;R4 = START ADR OF BUFFER
	BR	60$

90$:	JMP	ILERR		;ILLEGAL ERROR.

.SBTTL	LMLBLD	PLACE THE ADDR OF A LIBR SYMBOL INTO THE LML

;+
; EACH ENTRY IN LML IS 3 WORDS LONG					;MAS10
;
;	LIBRARY FILE # (8 BITS) 1-255	! REL BLK # (8 BITS) HIGH ORDER PART
;	REL BLK # (7 BITS) LOW ORDER	! BYTE OFFSET (9 BITS)
;	SEGMENT NUMBER FOR THIS MODULE					;MAS10
;
; THE LIBRARY FILE # MUST START AT 1 SO THAT THE 1ST WORD IS NON-ZERO.
; THE LML ENDS WITH A ZERO BLK #. THE LIBRARIAN ONLY PUTS THE HEADER AND
; EPT IN BLK ZERO. THE OBJECT CODE STARTS AT LEAST IN BLK 1 OR LATER.
; INPUT: R3 -> FOUND SYMBOL NAME IN LIBRARY HEADER
;	 LMLPTR = CURRENT PTR INTO LML
;
; OUTPUT: UPDATE LMLPTR
; CLOBBERS R0
;-

LMLBLD:	MOV	R1,-(SP)	;SAVE R1
	ADD	#4,R3		;PT TO BLK ADR IN EPT
	MOV	LMLPTR,R2	;GET LML PTR
	CMP	ENDLML,R2	;END OF LML ?
	BLOS	90$		;YES IF .LE.

	; PLACE LIBRARY MODULE ADR IN LML

	MOV	@R3,R0		;REL BLK # IN LIBRARY FILE
	ASL	R0		;GET RID OF MODULE NAME FLAG
	CLRB	R0
	BISB	LIBNB,R0	;LIBRARY FILE #
	SWAB	R0		;NOW ALIGNED PROPER
	MOV	R0,(R2)+	;PLACE BLK ADR IN LML
	MOV	(R3)+,R0	;LOW ORDER REL BLK #
	BIC	#^C177,R0
	ASL	R0
	SWAB	R0
	BIC	#BT.OFF,@R3	;ISOLATE BYTE OFFSET BITS IN EPT
	BIS	@R3,R0		;SET BYTE OFFSET BITS
	MOV	R0,(R2)+	;PLACE BYTE ADR IN LML
	CLR	@R2		;SET SEGMNT NUMBER TO ZERO=ROOT
	BIT	-S.YSN(R1),#SY.SWI ;WAS THIS A /I MODULE?		;MAS10+
	BNE	50$		;YES->SEGMENT NUMBER=0=ROOT
	TST	SEGBAS		;IS THIS A /X LIBRARY?			;MAS13
	BNE	50$		;NOT = -> YES -> ROOT SEGMENT		;MAS13
	TST	SW.LML		;MODULES INTO OVERLAYS?			;MAS23+
	BEQ	50$		;EQ -> NO, ALL GO INTO ROOT
	ADD	#-S.YNAM,R1	;GET ADDR STATUS WD FOR UNDF GBL AND
	BIT	#SY.IND,@R1	;IS UNDEFINED SYMBOL EXT. REFERENCED?	;DBB03+
	BNE	10$		;NE -> YES. -> ROOT
	MOV	R1,@R2		;SET POINTER TO UNDEF SYMBOL IN LML
10$:	MOV	SVLML,R1	;GET START OF LML FOR THIS LIBRARY FILE ;DBB03-
	MOV	R1,-(SP)	;AND SAVE IT
20$:	CMP	R1,STLML	;IS IT = TO START FOR THIS TIME THRU LIBRARY?
	BEQ	60$		;EQ -> YES, DIDN'T FIND DUPLICATE, CONTINUE
	CMP 	(R1)+,-4(R2)	;SEARCH ALL PREVIOUS LML'S FOR A DUPLICATE
	BNE	40$		;NE -> NOT SAME, TRY NXT LML
	CMP	(R1)+,-2(R2)	;TRY 2ND WORD LML FOR MATCH
	BNE	40$		;NE -> NO MATCH
	TST	@R1		;SEGMENT NUMBER OF THE LML IN THE LIST = 0?
	BEQ	30$		;YES -> DON'T ADD THIS LML TO LIST
	CMP	@R1,@R2		;TRY 3RD WORD LML FOR MATCH
	BNE	40$		;NE -> NO MATCH
30$:	CMP	-(R2),-(R2)	;MATCH, BACK UP R2 -> DON'T ADD LML TO LIST
	TST	(SP)+		;CLEAN STACK
	BR	80$		;AND RETURN

40$:	ADD	#6,@SP		;GO TO NEXT LML
	MOV	@SP,R1		;AND RESET POINTER
	BR	20$		;TRY NEXT LML IN LIST

50$:	BIC	#100000,SW.LML	;CLEAR PREPROCESS BIT FOR /I OR /X
	BR	70$

60$:	TST	(SP)+		;CLEAN STACK
70$:	TST	(R2)+		;POSITION R2 TO WD AFTER LAST LML	;MAS10-;MAS23-
	MOV	R2,LMLPTR	;UPDATE LML PTR
80$:	CLR	@R2		;SET IN CASE LIBR END
	MOV	(SP)+,R1	;RESTORE R1
	RETURN

90$:	ERROR$	ERR22,E$F,E$PRT	;LIBRARY LIST OVERFLOW INCREASE SIZE WITH /P

.SBTTL	ORLIB	ORDER LIBRARY MODULE LIST

;+
; THIS ROUTINE ORDERS LML ENTRIES, AND COMBINES ENTRIES AS FOLLOWS:
;
; 1. LIBRARY MODULES ALL GO IN ROOT (SW.LML = 0).
;    ONLY THE FIRST TWO WORDS OF THE LML ENTRIES ARE USED IN THE CHECKING.
;    THE THIRD WORD (SEGMENT NUMBER) WILL ALWAYS BE ZERO IN THIS CASE.
;
;	A. IF THE ENTRIES ARE IDENTICAL, THEY ARE MERGED.
;	B. IF THEY ARE NOT IDENTICAL THAY ARE PUT IN ASCENDING ORDER.
;
; 2. MODULES MAY GO IN OVERLAYS, AND IN PREPROCESSING PASS (SW.LML = 100001).
;    ALL 3 WORDS OF THE LML ENRTIES ARE USED IN THE CHECKING.
;
;	A. IF THE ENTRIES ARE IDENTICAL, THEY ARE MERGED.
;	B. IF THE ENTRIES ARE NOT IDENTICAL:
;	   1. IF EITHER LML'S SEGMENT WORD = 0 (3RD WORD OF LML), OR
;	      IF EITHER UNDF GLOBAL HAS BEEN EXTERNALLY REFERENCED, OR
;	      IF THE SEGMENT NUMBERS OF THE 2 LML'S ARE NOT THE SAME AND
;		AT LEAST ONE OF THE REFERENCES IS NOT OF A DUP SYMBOL
; 		THEN, THE LML'S ARE MERGED WITH THE SEGMENT WORD = 0.
;	   2. IF THE LML'S CAN NOT BE MERGED THEY ARE ORDERED, BASED ON
;	        THE 1ST 2 WORDS AND ON THE SEGMENT NUMBER OF THE REFERENCE.
;		THE 3RD WORD OF THE LML IS SET TO 0 IF THE SEGMENT NUMBER 
;	        IS 0, OR IF THE EXT REF BIT IS SET.
;
;    THE 3RD WORD OF EACH LML CONTAINS	EITHER 0 (SEGMENT NUMBER WILL BE 0),
;    OR THE ADDRESS OF THE STATUS WORD OF THE UNDEFINED GLOBAL SYMBOL THAT
;    CAUSED THE LIBRARY MODULE TO BE INCLUDED IN THE LIBRARY MODULE LIST.
;    LATER THIS WILL BE CONVERTED TO THE CORRECT SEGMENT NUMBER FOR THE
;    LIBRARY MODULE.
;
; INPUT:
; 	R1 	-> 	2ND WORD OF 2ND LML
;	R2 	= 	3RD WORD 1ST LML (SEGMENT WORD)
;	STLML 	= 	START OF CURENT LML TO ORDER
;
; OUTPUT:
;	2ND LML SEGMENT NUMBER SET TO 0 IF REQUIRED 2(R1)
;	RETURNS TO MERGE OR ORDER LML'S AS INDICATED
;	R3	IS CLOBBERED
;	LMLPTR 	-> 	NEXT FREE POSITION IN LIST
;-
.ENABL	LSB								;SHD01
									;SHD01
ORLIB:
10$:	MOV	STLML,R1	;R1 -> START OF LML			;DBB09
20$:	MOV	(R1)+,R0	;GET BLOCK ADDRESS
	BEQ	150$		;NOTHING TO ORDER.  RETURN		;DBB09
	MOV	(R1)+,R5	;GET BYTE ADR
	MOV	(R1)+,R2	;GET SEGMENT NUMBER			;MAS10
	BEQ	30$		;EQ -> VALID LML			;DBB09+
	TST	@R2		;IS GLOBAL UNDEFINED?
	BMI	30$		;MI -> YES.  VALID LML
	CALL	MRGLM1		;GET RID OF INVALID LML ENTRY
	BR	20$		;TRY AGAIN FOR A VALID LML ENTRY.

30$:	MOV	(R1)+,R3	;ARE WE AT THE END?
	BEQ	140$		;.EQ. -> WE'RE AT THE END OF LML
	TST	2(R1)		;IS 2ND LML VALID?
	BEQ	40$		;EQ -> YES.
	TST	@2(R1)		;IS GLOBAL SYM UNDEFINED?
	BMI	40$		;MI -> YES, SO LML IS VALID
	CMP	(R1)+,(R1)+	;ADJUST R1 FOR "MRGLM1" ROUTINE
	CALL	MRGLM1		;GET RID OF INVALID LML ENTRY
	BR	30$		;SEE IF WE HAVE A VALID LML ENTRY NOW

40$:	CMP	R3,R0		;BLK # IN CORRECT ORDER ?		;DBB09-
	BEQ	80$		;YES, BLOCK # ARE THE SAME
	BLO	50$		;OUT OF ORDER
	CALL	SETONE		;IN ORDER, CHECK SEGMENT NUMBER
	BCS	60$		;C=1 -> NEW 0 SEG CREATED,SORT AGAIN	;SHD01
	BR	20$							;SHD01

; OUT OF ORDER, EXCHANGE PLACES, AND START AGAIN

50$:	TST	-(R1)		;POINT TO START OF LIST
	MOV	R1,R3
	SUB	#6,R3		;PT TO OUT OF ORDER ADR			;MAS10
	MOV	(R1)+,(R3)+	;MOVE 1ST WORD
	MOV	(R1)+,(R3)+	;MOVE 2ND WORD OF LML			;MAS10
	MOV	@R1,(R3)+	;EXCHANGE PLACES IN LML (MOVE SEG #)
	MOV	R0,(R3)+	;MOVE WORD 1
	MOV	R5,(R3)+	;MOVE WORD 2
	MOV	R2,@R3		;MOVE SEGMENT NUMBER			;MAS10
	SUB	#4,R1		;R1->FIRST WD OF 2ND LML		;SHD01+
60$:	SUB	#6,R1		;R1->FIRST WD OF 1ST LML
70$:	SUB	#6,R1		;R1->FIRST WD OF PREVIOUS LML
	CMP	R1,STLML	;PAST BEGINNING OF LML LIST?
SRT::	BLO	10$		;IF LO YES, START AGAIN
	BR	20$		;MERGE

; NOTE: ;SHD01 CHANGES SLOW BUBBLE SORT TO A MODIFIED SHUTTLE SORT.  IF
;	LOCATION SRT IS CHANGED TO A BR 10$, THE OLD ALGORITHM RETURNS	;SHD01-

; BLOCK # ARE THE SAME, CHECK THE BYTE OFFSETS

80$:	CMP	@R1,R5		;MOD APPEAR MORE THAN ONCE IN LML
	BEQ	90$		;YES - DUPLICATE MOD ADR ?
	BLO	50$		;YES - MOD OUT OF ORDER ?
	CALL	SETONE		;IN ORDER, CHECK FOR SEGMENT = 0
	BCS	60$		;C=1 -> NEW 0 SEG CREATED,SORT AGAIN	;SHD01
	BR	20$							;SHD01

;+
; BOTH THE BLK # & THE BYTE OFFSET ARE THE SAME,CHECK IF SEG#=.
; CHECK FOR SWITCH (SW.LML=100001). IF SET THEN DO MORE TESTING FOR
; SEGMENT NUMBER DIFFERENCES, AND EXT REFERENCE BITS SET.
; IF SW.LML = 0, THEN JUST MERGE THE TWO LML'S, AS THE SEGMENT NUMBER
; WILL ALWAYS BE = 0 IN THIS CASE.
;-

90$:	TST 	SW.LML		;SWITCH SET?				;MAS23+
	BEQ	130$		;= -> NO, SEGMENT NUMBER IS OK
	MOV	2(R1),R3	;R3 = 3RD WORD 2ND LML
	BEQ	130$		;EQ -> MERGE WITH SEGMENT NUMBER = 0
	CMP	R3,R2		;ARE THE ADDRESSES THE SAME?
	BEQ	130$		;EQ -> YES, MERGE THE TWO LML'S
	MOV	S.YSN(R3),-(SP)	;GET 2ND SEGMENT NUMBER WORD		;DBB09+
	BIC	#^CSY.SEG,@SP	;ISOLATE SEGMENT NUMBER
	MOV	R2,-(SP)	;SAVE ON STACK IN CASE SEG NUM IS 0
	BEQ	110$		;1ST LML IS FOR SEG 0.  MERGE AS SEG 0
	MOV	S.YSN(R2),@SP	;GET 1ST SEGMENT NUMBER WORD
	BIC	#^CSY.SEG,@SP	;ISOLATE SEGMENT NUMBER
	BIT	#SY.DUP,@R3	;IS 2ND LML ENTRY REFED BY DUP SYM?
	BEQ	100$		;EQ  -> NO, MERGE IS POSSIBLE
	BIT	#SY.DUP,@R2	;IS 1ST LML ENTRY REFED BY DUP SYM?
	BNE	120$		;NE -> YES. DON'T MERGE
100$:	CMP	@SP,2(SP)	;DO THEY HAVE THE SAME SEG NUMS?
	BNE	110$		;NE -> MERGE MODULES WITH SEG. NUM=0	;DBB09-
	BIT	#SY.IND,@R3	;TEST 2ND STATUS WORD FOR EXT REF	;DBB07+
	BNE	110$		;NE -> EXT REF SET -> MERGE WITH SEG=0
	BIT	#SY.IND,@R2	;EQ -> TEST 1ST STATUS WORD FOR EXT REF
	BEQ	120$		;EQ -> NO EXT REF, DO NOT MERGE LML'S	;DBB07-
110$:	CLR	2(R1)		;NE -> SET SEGMENT NUMBER TO ZERO
120$:	MOV	2(R1),R3	;GET SEGMENT NUMBER, IF = 0, THEN YOU KNOW
	BEQ	1303$		;THAT THE LML'S WILL ALWAYS BE MERGED.
	SUB	(SP)+,(SP)+	;2ND MINUS 1ST SEG NUMS (IN ORDER?)	;DBB09
	BMI	50$		;MI -> NOT IN ORDER, EXCHANGE LML ORDER	;DBB09
	TST 	-(R1)		;RESET R1 PROPERLY
	BR	20$		;IN ORDER, DO NEXT LML ENTRY.

; SW.LML = 0, THE SEGMENT NUMBER WILL ALWAYS BE = 0, MERGE LML ENTRIES

1303$:	CMP	(SP)+,(SP)+	;PURGE SEG NUMS FROM STACK		;DBB09
130$:	CALL	MRGLML		;MERGE THE TWO LML'S
	TST	4(R1)		;SEG 0 -> START SORT AGAIN		;MAS32
	BEQ	70$							;SHD01
	BR	20$		;RECALL SORT IN MIDDLE			;SHD01

; LAST LML ENTRY. CHECK IT FOR SEGMENT = 0

140$:	CALL	SETONE		;CHECK LAST LML FOR SEGMENT = 0
	BCS	60$		;C=1 -> NEW 0 SEG CREATED,SORT AGAIN	;SHD01
	BR	160$							;DBB09

150$:	TST	-(R1)							;DBB09
160$:	MOV	R1,LMLPTR	;-> NEXT FREE POSITION IN LIST		;SHD01
									;MAS23-
.DSABL	LSB								;SHD01

;+									;DBB10+
; ORLIB IS NOT CAPABLE OF FORCING ALL LIBRARY MODULES TO THE ROOT
; THAT SHOULD BE BECAUSE OF ITS DOING A SORT AT THE SAME TIME.
; THUS, A SCAN OF THE SORTED LML IS NECESSARY IN ORDER TO DO THIS AND
; THIS IS WHAT LMLADJ DOES.
;
; LMLADJ MERGES LML ENTRIES TO A SINGLE ENTRY WITH A SEGMENT NUMBER OF
; 0 ONLY WHEN NOT ALL LML ENTRIES TO A SINGLE LIBRARY MODULE ARE
; REFERENCED BY A DUP SYMBOL AND NOT ALL OF THE SEGMENT NUMBERS OF
; THESE REFERENCES ARE THE SAME.
;-

.ENABL	LSB

LMLADJ:	MOV	STLML,-(SP)	;START SCANNING AT START OF LML
10$:	MOV	(SP)+,R1	;R1 -> START OF LML ENTRY BLOCK
	BR	30$		;CONTINUE SCANNING ENTRIES

20$:	ADD	#6,R1		;R1 -> START OF NEXT LML ENTRY
30$:	MOV	R1,R5		;MAKE A COPY OF POINTER
	TST	@R1		;END OF LML?
	BEQ	90$		;.EQ. -> YES, JUST RETURN
	MOV	4(R1),R2	;GET PTR TO SYMBOL
	BEQ	20$		;0 -> SEG. 0.  START A NEW LML BLOCK
	CLR	-(SP)		;NO NON-DUP REFS SEEN
	BIT	#SY.DUP,@R2	;IS IT A DUP SYMBOL?
	BNE	40$		;.NE. -> YES.
	MOV	R2,@SP		;WE HAVE SEEN A NON-DUP REF
40$:	MOV	S.YSN(R2),R3	;GET FLAG AND SEG NUM WORD
	BIC	#^CSY.SEG,R3	;ISOLATE SEG NUM
	BEQ	100$		;ORLIB MADE A BOO-BOO
50$:	ADD	#6,R1		;MOVE PTR TO START OF NEXT LML ENTRY
	CMP	@R1,@R5		;SAME LIB AND HI BLOCK NUM?
	BNE	70$		;.NE. -> NO.  TERMINATE BLOCK SCAN
	CMP	2(R1),2(R5)	;SAME LO BLOCK AND BYTE OFFSET?
	BNE	70$		;.NE. -> NO. TERMINATE BLOCK SCAN
	MOV	4(R1),R2	;GET PTR TO SYMBOL
	BEQ	100$		;ORLIB MADE A BOO-BOO
	BIT	#SY.DUP,@R2	;IS IT A DUP SYMBOL?
	BNE	60$		;.NE. -> YES.
	MOV	R2,@SP		;WE HAVE SEEN A NON-DUP REF
60$:	MOV	S.YSN(R2),R2	;GET FLAG AND SEG NUM WORD
	BIC	#^CSY.SEG,R2	;ISOLATE SEG NUM
	CMP	R2,R3		;SAME SEG NUM?
	BEQ	50$		;.EQ. -> YES.  KEEP SCANNING LML BLOCK
	CLR	R3		;SEG. NUM. IS DIFFERENT.  FORCED TO ROOT
	BR	50$		;KEEP SCANNING LML BLOCK

70$:	TST	(SP)+		;HAVE WE SEEN ANY NON-DUP REFS?
	BEQ	30$		;EQ -> NO, ALL DUPS, SO LEAVE ALONE
	TST	R3		;IS MODULE FORCED TO ROOT?
	BNE	30$		;.NE. -> NO.  SCAN NEXT LML BLOCK
	CMP	(R5)+,(R5)+	;R5 -> LML ENTRY SEG NUM WORD
	CLR	(R5)+		;CLEAR SEG NUM WORD (FORCED TO ROOT)
	MOV	R5,-(SP)	;SAVE START OF NEXT LML BLOCK
80$:	MOV	(R1)+,(R5)+	;MOVE SUBSEQUENT BLOCKS OVER DUPLICATE
				; LML ENTRIES IN CURRENT BLOCK
	BEQ	10$		;.EQ. -> END OF LML.  SCAN NEXT BLOCK
	MOV	(R1)+,(R5)+	;MOVE 2ND WORD OF LML ENTRY
	MOV	(R1)+,(R5)+	;MOVE 3RD WORD OF LML ENTRY
	BR	80$		;MOVE NEXT LML ENTRY

90$:	RETURN

100$:	JMP	ILERR		;ILLEGAL ERROR

.DSABL	LSB								;DBB10-

.SBTTL	SETONE	HAVE A UNIQUE LML ENTRY, CHECK FOR SEGMENT NUMBER = 0

;+
; HAVE UNIQUE, IN ORDER LML ENTRY. IF SW.LML IS SET, THEN CHECK OUT ITS
; SEGMENT NUMBER AND EXT. REF. IF SEGNUM=0 OR IF EXT. REF. IS SET, THEN
; SET 3RD WORD OF LML TO 0.
;
; INPUT:
;	R1 -> POINTER TO SEG WORD + 4 OF LML TO SET SEGMENT NUMBER IN
;
; OUTPUT:
;	R1 -> POINTER TO SEGMENT WORD + 2 OF LML
;	LML SEGMENT WORD IS CONVERTED TO ACTUAL SEGMENT NUMBER
;-

SETONE:	TST	-(R1)		;RESET R1 TO BLOCK #			;MAS23+
	MOV	-2(R1),R3	;GET 3RD WORD
	BEQ	20$		;EQ -> NO FURTHER CHECKING REQUIRED
				;(SW.LML=0 DOES THIS)
	MOV	S.YSN(R3),R5	;GET SEGMENT WORD
	BIC	#^CSY.SEG,R5	;ISOLATE SEGMENT NUMBER
	BEQ	10$		;0 -> SET 3RD WORD LML = 0
	BIT	#SY.IND,@R3	;CHECK EXT. REF BIT			;DBB07
	BEQ	20$		;EQ -> NOT EXT REF. LEAVE 3RD WORD AS IS;DBB07
10$:	CLR	-2(R1)		;CLEAR 3RD WORD OF LML
	SEC			;NEW SEG 0 CREATED			;MAS32
20$:	RETURN			;C=0 FROM TST -(R1) OR BCC		;MAS23-


.SBTTL 	ORLIB1	ORDER LML AND CALCULATE SEGMENT NUMBERS

;+
; WHEN ALL PREPROCESSING ON THE CURRENT LIBRARY HAS BEEN COMPLETED,
; THE LML IS PREPARED FOR FINAL LIBRARY MODULE PROCESSING.
;
; 	1. THE LML LIST FOR THIS LIBRARY IS ORDERED.
;	2. IDENTICAL ENTRIES ARE MERGED.
;	3. ENTRIES WHERE THE SEGMENT NUMBER WILL BE ZERO ARE MERGED.
;	4. REMAINING ENTRIES HAVE THE PROPER SEGMENT NUMBER SET, AND
;	   DUPLICATES ARE MERGED.
;
; INPUT:
;	SVLML -> POINTS TO START OF LML FOR THE ENTIRE LIBARARY FILE
;
; OUTPUT:
;	LML IS ORDERED, AND MERGED, WITH ALL SEGMENT NUMBERS PROPERLY SET
;-

ORLIB1:	MOV	SVLML,STLML	;SET START OF LML FOR THIS LIBRARY BACK	;DBB11+
	CALL	ORLIB		;ORDER LML, AND MERGE THOSE WITH SEG=0
	MOV	STLML,R1	;GET START OF THIS LIBRARY LML LIST
10$:	MOV	(R1)+,R0	;GET 1ST LML BLOCK NUMBER
	BEQ	50$		;.EQ. -> END OF LML, JUST RETURN
	MOV	(R1)+,R5	;GET 1ST LML BYTE OFFSET
	MOV	@R1,R2		;GET 1ST LML SEGMENT WORD
	BEQ	20$		;IF SEG=0 THEN NO CALCULATION NEEDED
	MOV	S.YSN(R2),R2	;GET FLAG AND SEG NUM WORD
	BIC	#^CSY.SEG,R2	;ISOLATE SEG NUM
20$:	MOV	R2,(R1)+	;REPLACE PTR WITH REAL SEG NUM
	CMP	(R1)+,R0	;BLK NUMBER THE SAME?
	BNE	40$		;NE -> NO, SET SEGMENT NUMBER FOR THIS LML
	CMP	@R1,R5		;BYTE THE SAME?
	BNE	40$		;NE -> NO, SET SEGMENT NUMBER FOR THIS LML
	MOV	2(R1),R3	;GET POINTER UND GBL (R3 -> STATUS WD)
	MOV	S.YSN(R3),R3	;GET SEG WORD
	BIC	#^CSY.SEG,R3	;ISOLATE SEGMENT BITS
	CMP	R2,R3		;ARE BOTH ENTRIES' SEG NUMS THE SAME?
	BNE	30$		;.NE. -> NO.  DON'T MERGE ENTRIES
	CALL	MRGLML		;ELIMINATE DUPLICATE REFERNCE TO SAME MODULE
	CMP	(R1)+,(R1)+	;R1 -> SEG NUM WORD IN MERGED LML ENTRY
	BR	20$		;GO PLACE THE CORRECT SEG NUM IN LML ENTRY

30$:	TST	(R1)+		;R1 -> 2ND LML ENTRY'S SEG NUM WORD
	MOV	R3,R2		;GET PROPER SEGMENT IN R2
	BR	20$		;GO PLACE THE CORRECT SEG NUM IN LML ENTRY

40$:	TST	-(R1)		;R1 -> 1ST WORD OF NEXT LML ENTRY
	BNE	10$		;.NE. -> ANOTHER LML ENTRY.  PROCESS IT
50$:	RETURN								;DBB11-

.SBTTL	MRGLML	COMBINE TWO LML ENTRIES

;+
; REMOVED FROM ORLIB FOR USE BY ORLIB AND ORLIB1.
; THERE ARE 2 ENTRY POINTS TO THIS ROUTINE: MRGLML AND MRGLM1
;
; MRGLML
;
; INPUT:	R1 -> 2ND WORD OF THE 2ND LML
;
; OUTPUT:	1ST LML OVER WRITTEN BY 2ND LML
;		R1 -> POINTS TO START OF 2ND LML IN ITS NEW POSITION
;
; MRGLM1
;
; INPUT:	R1 -> 1ST WORD OF THE 2ND LML
;
; OUTPUT:	1ST LML OVER WRITTEN BY 2ND LML
;		R1 -> POINTS TO START OF 2ND LML IN ITS NEW POSITION
;-

MRGLML:	TST	-(R1)		;LML SAME, SEG=0, SAME GBL ,OR		;DBB09+
MRGLM1:	MOV	R1,R3		;ENTRY FOR INVALID LML ENTRY
				;R3->2ND LML, BLK # THAT IS THE SAME
	SUB	#6.,R1		;R1->POSITION OF LML TO OVERLAY		;DBB09-
	MOV	R1,-(SP)	;SAVE SORT ADDR				;MAS23+
	BR	20$		;TEST BLK 1ST- SAVES TIME

10$:	MOV	(R3)+,(R1)+	;BYTE OFFSET
	MOV	(R3)+,(R1)+	;SEGMENT NUMBER
20$:	MOV	(R3)+,(R1)+	;BLK #
	BNE	10$		;0 = END OF LIST
	MOV	(SP)+,R1	;RESTORE SORT ADR			;MAS23-
	RETURN

.SBTTL	EPTSER	ENTRY POINT SEARCH ROUTINE

;+
; SEARCH THE ENTRY POINT TABLE FOR A MATCH OF THE INDICATED SYMBOL.
; INPUT: R1 -> SYMBOL TO BE SEARCHED FOR
;	 R4 -> 1ST EPT ENTRY IN BUFR
;
; OUTPUT:C = 0	SYMBOL FOUND
;	 C = 1	SYMBOL NOT FOUND
;	 R1 & R4 UNCHANGED
;	 R3 -> THE FOUND SYMBOL
;	 NOTE:	ZERO ENDS THE LIST OF EPT'S
; CLOBBERS R0, R2
;-

EPTSER:	MOV	R4,R3		;COPY IT
	MOV	(R1)+,R2	;PUT 1ST WD OF SYMBOL IN REG FOR SPEED
	BR	20$		;INTO LOOP

10$:	ADD	#8.,R3		;4 WORDS FOR EACH ENTRY PT.
20$:	MOV	@R3,R0		;1ST WD SYMBOL
	BEQ	30$		;IF 0 AT END OF TBL
	CMP	R2,R0		;1ST WD MATCH?
	BNE	10$		;NO, TRY NEXT
	CMP	2(R3),@R1	;YES, 2ND WD MATCH?
	BNE	10$		;NO, TRY NEXT
	TST	SEGBAS		;/X LIBRARY BEING PROCESSED?		;MAS13
	BNE	40$		;1-> YES -> MOD. NAMES VALID 		;MAS13
				;(C=0 FROM TST)
	TST	4(R3)		;SKIP MODULE NAMES IN EPT, THEY		;MAS12
	BMI	10$		;ARE NOT VALID ENTRY POINTS		;MAS12
	BR	40$		;C=0 FROM CMP

30$:	SEC			;SYMBOL NOT FOUND
40$:	MOV	-(R1),R2	;BACKUP R1 & DON'T CHANGE CARRY
	RETURN

.SBTTL	OV3DUM:: DUMMY ENTRY PT FOR ERROR PROCESSING

OV3DUM::RTS	R5

.PSECT	PATCH			;THIS IS A PATCH PSECT,

	.BLKW	64.		;TO BE USED FOR BUG FIXES

.END
