TITLE	FMS,<FMS FIELD PRIMITIVES>,0A,10-MAY-91,CAV/FEK/PBM/KPH/DWF

	.ENABL	GBL

;
;
;		      COPYRIGHT (C) 1987 BY
;		DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.                                                 
;
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;
;
;
; MODULE:	RSTSPR - RSTS Specific Module for FMS Field Primitives
;
; VERSION:	V2.1                                           
;
; AUTHOR:	Cheryl Vedoe
;
; DATE:		06-March-82
;
; MODIFIED BY:
;
;	Paul Morgan	22-May-87	Moved escape sequence parsing to here
;					from the RSTS terminal driver.  Also
;					added 8-bit character and VT220/VT330
;					support.

	.SBTTL	FMS FIELD PRIMITIVES EDIT HISTORY

;+
;
;  001	CAV  24-Apr-81	Base Level 1
;  002	CAV  29-May-81	Base Level 2
;  003	CAV  10-Jul-81	Base Level 3
;  004	CAV  03-Aug-81	Base Level 4
;  005	CAV  27-Sep-81	Set escape sequence parsing for VT52
;  006	CAV  12-Nov-81	Final edits for FMS/RSTS V1.5 release
;  007	CAV  06-Mar-82	Update to correct problems found during
;	     		  FMS/RSTS V1.5 field test (for release
;	     		  with RSTS/E V7.2)
;  008	FEK  25-FEB-83	SOURCE CLEAR V7.2 PATCHES
;
;			[RSTS V9.6]
;  009  KPH  13-Oct-87	Include FMS support which was in TTDVR.MAC
;			Changes for dynamic DDB extension
;			Changes for APR6 class driver
;  010	DRP  07-Dec-87	Remove references to TTESCT
;  011	DWF  21-Jan-88	Fix character output handling
;  012	DWF  07-Apr-88	Set no-wrap in addition to FMS mode in FMS open
;  013	PBM  13-Apr-88	Correct UP/DOWN ARROW processing within scrolled areas
;-

	.SBTTL
	.SBTTL
	.SBTTL	FMS/RSTS SPECIFIC CODE
	.SBTTL
	.SBTTL

	.SBTTL	FMS Macros

;+
; $SAV50
;
;	Save registers R5-R0 on the stack. Use the RSTS macro
;	and coroutine.
;
;-

	.MACRO	$SAV50
	REGSCR
	.ENDM	$SAV50

;+
; ESCSEQ
;
;	Call routine to output an escape sequence to the terminal.
;	All escape sequence strings are terminated with a null byte.
;-

	.MACRO	ESCSEQ	SEQ
	JSR	R3,ESCSEQ
	.WORD	SEQ
	.ENDM	ESCSEQ

;+
; PRTSTR
;
;	Call routine to print a string at the terminal at interrupt
;	level.
;
; INPUT:
;
;	R3 -> String to output
;	R4 =  0 if ASCIZ string, else character count
;	R5 -> Data area
;
; OUTPUT:
;
;	All registers preserved.
;-

	.MACRO	PRTSTR
	CALL	PRTSTR
	.ENDM	PRTSTR

;+
; PRTZST
;
;	Call routine to print an ASCIZ string at the terminal at
;	interrupt level.
;
; INPUT:
;
;	R3 -> String to output
;	R5 -> Data area
;
; OUTPUT:
;
;	All registers preserved.
;-

	.MACRO	PRTZST
	CALL	PRTZST
	.ENDM	PRTZST

;+
; PRTBYT
;
;	Call routine to print a character at the terminal at
;	interrupt level.
;
; INPUT:
;
;	R2 =  Character to output in low byte
;	R5 -> Data area
;
; OUTPUT:
;
;	All registers preserved.
;-

	.MACRO	PRTBYT
	CALL	PRTBYT
	.ENDM	PRTBYT

;+
; STRBYT
;
;	Call routine to store a character in the print buffer.
;
; INPUT:
;
;	R2 =  Character in low byte
;	R5 -> Data area
;-

	.MACRO	STRBYT
	CALL	STRBYT
	.ENDM	STRBYT

;+
; Macros for routines also used by Form Driver kernel.
;-

	.MACRO	FXDLEN
	CALL	FXDLEN
	.ENDM	FXDLEN

	.MACRO	FILCHR
	CALL	FILCHR
	.ENDM	FILCHR

	.MACRO	TXTCHR
	CALL	TXTCHR
	.ENDM	TXTCHR

	.MACRO	CLRCHR
	CALL	CLRCHR
	.ENDM	CLRCHR

	.MACRO	VIDEO
	CALL	VIDEO
	.ENDM	VIDEO

	.MACRO	FLDVAL
	CALL	FLDVAL
	.ENDM	FLDVAL

	.MACRO	CLRESP
	CALL	CLRESP
	.ENDM	CLRESP

	.MACRO	PRTRSP
	CALL	PRTRSP
	.ENDM	PRTRSP

	.MACRO	MOVCUR
	CALL	MOVCUR
	.ENDM	MOVCUR

	.MACRO	SETCUR
	CALL	SETCUR
	.ENDM	SETCUR

	.MACRO	OUTPRM
	CALL	OUTPRM
	.ENDM	OUTPRM

	.MACRO	PRTLST
	CALL	PRTLST
	.ENDM	PRTLST

	.MACRO	INITBF
	CALL	INITBF
	.ENDM	INITBF

	.MACRO	PRTBUF
	CALL	PRTBUF
	.ENDM	PRTBUF

	.MACRO	SGNLER
	CALL	SGNLER
	.ENDM	SGNLER


	.SBTTL	Define the Error Message Macro

;
; The symbol FMS$E is defined to be 0 in this module so that the
; error message macro is defined to print messages on the last
; line of the terminal screen.
;

	FMS$E	= 0

;
; Initialize the error message number.
;

	.ER.N	= 1

;
; The following code has no effect here. It is included here to be
; pulled out by a TECO macro to be included in the error message
; module.
;

.IF NE,0				; Don't assemble here

;+
; ERROR
;

	.TITLE	FMSERR	- FMS FIELD PRIMITIVES ERROR MESSAGES
	.SBTTL	FMSERR	- FMS FIELD PRIMITIVES ERROR MESSAGES
	.SBTTL
	.IDENT	/V2.1/
	.SBTTL

	.ENABL	LC,GBL
;
;
;		      COPYRIGHT (C) 1987 BY
;		DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
;
;
; MODULE:	FMS Field Primitives Error Messages
;
; VERSION:	V2.1
;
; AUTHOR:	Cheryl Vedoe
;
; DATE:		12-November-81
;
;

;
; Define the PSECT for the error text.
;

	.PSECT	FMSERR,D

;
; Define the error symbol to indicate this is the error module.
;

	FMS$E	= 1

;
; Initialize the error message number.
;

	.ER.N	= 1

;-

.ENDC		; NE,0

;
; The following code is included as an error section so that it will
; be pulled out and assembled in the error module also. In this module,
; the error macro is defined to print the error messages. In the error
; module, the macro is defined to assemble the message text.
;

;+
; ERROR
;
;	Define the error macro.
;
;	There are two definitions for the error macro, one for the
;	source and one for the error module. To determine which form
;	of the macro is appropriate, it is assumed the symbol FMS$E
;	is equal to 1 in the error module and equal to 0 in all other
;	modules which invoke the error macro.
;

	.MACRO	ERROR	MSG

.IF	EQ,FMS$E			; If not error module

;
;	Process keyboard error.
;
; 	Ring the bell and output the error message to the last line
;	if a message is	associated with the error; otherwise, ring
;	the bell and clear the last line.
;
;	All registers preserved.
;

	JSR	R3,ERROR
	.IRP	N,\.ER.N
	.WORD	FMSE'N
	.ENDM
	.ER.N	= .ER.N + 1

.IFF					; If error module

;
; Assemble the error message in the error module.
;

	.PSECT	FMSERR
	.IRP	N,\.ER.N
FMSE'N::
	.ENDM
	.ASCIZ	\MSG\
	.ER.N	= .ER.N + 1

.ENDC					; EQ,FMS$E

	.ENDM	ERROR

;-

	.SBTTL	Equated Symbols

;
; Primitives error codes
;

	DATLNG	= -1			; Data passed too long
	INVFCN	= -2			; Invalid function code
	INVTRM	= -3			; Invalid terminal type
	NOFLD	= -4			; No field defined for continue
	INVFLD	= -5			; Invalid field descriptor

;
; Length of print buffer 
;
; The buffer must be long enough to hold the longest escape sequence
; to be output.
;

	I$PBLN	= 24			; Length of print buffer

;
; Offsets for FMS data area
;
;
;	Word 1				; Size of buffer in bytes
;	Words 2-4 			; Reserved for use by RSTS
;	FMS.PC				; PC  --
;	FMS.R3				; R3   |  Defined in KBDEF
;	FMS.R4				; R4  --
;	FMSHDR	
;

	.DSECT	FMSHDR

KBN:		.BLKW			; KB number * 2
DDB:		.BLKW			; DDB address
I$MISC:		.BLKW			; Miscellaneous status
I$FDST:					; Field status
I$FMST:		.BLKW			; Form status
I$CURP:		.BLKB			; Current cursor position
I$CURC:		.BLKB			; Current column position
I$VATT:		.BLKW			; Current video attributes
TERM:		.BLKW			; Temp storage for terminator
I$ROFF:		.BLKW			; Offset in response
I$FOFF:		.BLKW			; Offset in field
I$LPTR:		.BLKW			; Pointer to line/col entry
LNCL:		.BLKW	3		; Line/col entry (3 words)
I$BPTR:		.BLKW			; Print buffer pointer
I$BCNT:		.BLKW			; Print buffer character count
I$PBUF:		.BLKB	I$PBLN		; Start of print buffer
I$FXPT:		.BLKW			; Pointer to dummy line/col entry
I$FXLN:		.BLKW			; Length of left part of fixed dec fld
I$FXDS:		.BLKW	11		; Dummy field desc for fixed decimal
I$FXLC:		.BLKW	3		; Dummy line/col entry for fixed dec
USRDAT:		.BLKW			; Start of data passed by user
ESCBUF:		.BLKW			; buffer for multi-digit escape seq.

;
;  Data for define field request
;

	.DSECT	USRDAT

FCNCOD:		.BLKW			; Primitives function code (DFN)
CONTRL:		.BLKW			; Control word
REQDAT:
FDESC:					; Field descriptor

; Bit settings for control word

	.BSECT

DMYFLD:		.BLKB	.		; Dummy field
LSTSTS:		.BLKB	.		; Status of last line (0 => clear)
FLDOFF:		.BLKB	.		; Use current field offsets (to
					;   restore cursor position after
					;   help form and screen refresh)

;
; Data for continue field processing request
;

	.DSECT	REQDAT

;FCNCOD:	.BLKW			; Primitives function code (CON)
;CONTRL:	.BLKW			; Control word

;
; Data for terminal attributes request
;
;	ESCSTS, PRMSTS, PRMPTR, PARM1, and PARM2 constitute the data
;	area used by the primitives in processing the request.
;

	.DSECT	REQDAT

;FCNCOD:	.BLKW			; Primitives function code (ATT)
;CONTRL:	.BLKW			; Control word
ESCSTS:		.BLKW			; Status for escape seq parsing
PRMSTS:		.BLKW			; Parameter status
PRMPTR:		.BLKW			; Parameter value pointer
PARM1:		.BLKW			; First parameter value
PARM2:		.BLKW			; Second parameter value

; 
; Data for terminal function request
;

	.DSECT	REQDAT

;FCNCOD:	.BLKW			; Primitives function code (FCN)
;CONTRL:	.BLKW			; Control word
FCLLIN:		.BLKW			; First line to clear
LCLLIN:		.BLKW			; Last line to clear

; Bit settings for control word 

	.BSECT

ERSSCR:		.BLKB	.		; Clear specified area of screen
SETSIZ:		.BLKB	.		; Set screen size
SCRSIZ:		.BLKB	.		; 0 => 80 column; 1 => 132 column
SETBCK:		.BLKB	.		; Set screen background
SCRBCK:		.BLKB	.		; 0 => white on black; 1 => black
					;   on white
RESTOR:		.BLKB	.		; Restore terminal attributes

;
; Signal terminal operator
;

	.DSECT	REQDAT

;FCNCOD:	.BLKW			; Primitives function code (SGN)
;CONTRL:	.BLKW			; Control word

;
; Data for scroll request
;

	.DSECT	REQDAT

;FCNCOD:	.BLKW			; Primitives function code (SCL)
;CONTRL:	.BLKW			; Control word
FSCLIN:		.BLKW			; First line of scrolled area
LSCLIN:		.BLKW			; Last line of scrolled area

; Bit settings for control word

	.BSECT

SCLDIR:		.BLKB	.		; 0 => scroll forward; 1 =>
					;   scroll backward

;
; Bit settings in miscellaneous status word (I$MISC)
;
; This word is returned to the kernel to reply to the terminal
; attributes request. The first three bits are all that the kernel
; is concerned with. All the bits are used by the primitives.
;
; Only the low order byte is used for status. The high byte is used
; to return the FMS field primitives patch level to the Form Driver
; kernel to ensure compatibility between the field primitives and
; the Form Driver kernel.
;

	.BSECT

IM$TRM:		.BLKB	.		; 0 => VT100, 1 => VT52
IM$AVO:		.BLKB	.		; 1 => VT100 has advanced video
IM$WID:		.BLKB	.		; 0 => 80 columns , 1 => 132 columns
IM$GLD:		.BLKB	.		; Gold key sequence started
IM$BUF:		.BLKB	.		; Buffer output at user level
IM$ESC:		.BLKB	.		; Parsing escape sequence
IM$FLD:		.BLKB	.		; 1 => Field defined to primitives

;
; Offsets for field descriptor
;

	.DSECT

D$ATT2:		.BLKW			; Attributes word 2
D$FID:		.BLKW	3		; Field name
D$LNCL:		.BLKW			; Line/col entry pointer
D$VATT:		.BLKB			; Video attributes
D$CLRC:		.BLKB			; Clear character
D$ATT1:		.BLKW			; Attributes word 1
D$RLEN:		.BLKW			; Length of response
D$FXLN:					; Fixed length of desc
D$PLEN:		.BLKB			; Length of picture
D$PICT:					; Start of picture

;
; Bit settings for attributes word 2 (D$ATT2)
;

	.BSECT

		.BLKB	.
		.BLKB	.
		.BLKB	.
		.BLKB	.
D2$VRT:		.BLKB	.		; Vertical array
D2$DEC:		.BLKB	.		; Fixed decimal
D2$ZFL:		.BLKB	.		; Zero-fill
D2$TAB:		.BLKB	.		; Autotab
D2$DIS:		.BLKB	.		; Display only
D2$RTJ:		.BLKB	.		; Right justified
D2$REQ:		.BLKB	.		; Required field
D2$FUL:		.BLKB	.		; Full field required
D2$NEC:		.BLKB	.		; No-echo
D2$SPO:		.BLKB	.		; Supervisor only

;
; Bit settings for video attributes byte (D$VATT)
;

	.BSECT

DV$UND:		.BLKB	.		; Underline
DV$REV:		.BLKB	.		; Reverse
DV$BLD:		.BLKB	.		; Bold
DV$BLK:		.BLKB	.		; Blink

;
; Bit settings for attributes word 1 (D$ATT1)
;

	.BSECT

		.BLKB	.
		.BLKB	.
		.BLKB	.
		.BLKB	.
		.BLKB	.
D1$ARY:		.BLKB	.		; Array field
D1$SCR:		.BLKB	.		; Scrolled field
D1$COM:		.BLKB	.		; Field definition complete
D1$SNM:		.BLKB	.		; Signed numeric required
D1$ALN:		.BLKB	.		; Alphanumeric required
D1$ALP:		.BLKB	.		; Alphabetic required
D1$NUM:		.BLKB	.		; Numeric required
D1$MIX:		.BLKB	.		; Mixed picture

;
; Offsets for line/col entry
;

	.DSECT

L$LNCL:		.BLKW			; Line/col value
L$RESP:		.BLKW			; Pointer to response buffer
L$DESC:		.BLKW			; Pointer to field desc

;
; Bit settings for field status word
;

	.BSECT

IS$ALT:		.BLKB	.		; Field contents altered
IS$INS:		.BLKB	.		; Input mode (= 0 => overstrike)


;
; Bit settings for escape sequence parsing
;

IS$CSI:		.BLKB	.		; escape sequence begins with CSI
IS$ESC:		.BLKB	. 		; escape sequence begins with ESC
IS$SS3:		.BLKB	. 		; escape sequence begins with SS3

IS$LEV:		.BLKB	.		; depth into string, 0 -> first char
					; 	1 -> second char
;
; Bit mask for escape sequence flag bits
;

	ESCMSK	= 000034			;  = 0000 0000 0001 1100 binary
;
; Bit settings for form status word
;

	.BSECT	HIGH

IS$CLR:		.BLKB	.		; Screen cleared (this bit is always 0
					;   in the FMS/RSTS field primitives
					;   but is required by the system
					;   independent code)
IS$LST:		.BLKB	.		; Status of last line (= 0 => last
					;   line clear)

;
; Terminator word bit settings
;
;	The terminator value is returned in the low byte; the
;	bit settings are in the high byte. 
;

	ESCKEY	= 400			; Terminator was escape sequence key
	GLDKEY	= 1000			; Terminator was gold sequence
	RETLST	= 10000			; Bit set => last line not clear
	FLDALT	= 20000			; Bit set => field altered
	
	TRMKEY	= 100000		; Used internally to indicate
					;   terminator

;
; Symbol Definitions
;

	ESC	= 33			; Escape for RSTS output
	CSI	= 233 			; 8-bit escape introducer
	SS3	= 217			; single shift 3
	TILDE	= 176			; CSI escape sequence terminator
	ESC33	= 33			; Escape on input
	NUL	= 0			; Null
	CR	= 15			; Carriage return
	LF	= 12			; Linefeed
	BKSP	= 10			; Backspace
	TAB	= 11			; Tab
	DEL	= 177			; Delete character
	SPC	= 40			; Space
	BEL	= 7			; Bell
	FLDPTN	= 52525			; Field definition pattern
	AVO	= 2			; Bit setting in second parameter of
					;   device attributes report for AVO

	                                                             
	DEFORG	FMSTIO


.SBTTL	FMSOPN	Open a terminal in FMS mode

;+
; FMSOPN - Open a terminal in FMS mode
;
;	R1 -> DDB
;	R2 =  Requested open mode (will include TTFMS bit)
;
;	CALL	FMSOPN
;
;	R2 =  Open mode to set in DDB (just TTFMS bit)
;	R3 =  Undefined
;	R4 =  Undefined
;
; This routine is called by KBDVR when an open request includes FMS
; mode. We will allocate the FMS data structures if possible, and return
; to KBDVR with success. If there are any errors, we declare them
; here which causes our user to get an error.
;-

FMSOPN::BIT	#TTFMS,TTMODE(R1)	; Already in FMS mode?		;009
	BNE	10$			; Yes, that's an error		;009
	MOV	R1,-(SP)		; No, save DDB pointer		;009
	BUFFER	GETLRG,600,-1,LRGPOL	; Get an FMS buffer		;009
	BCS	20$			; No space, give an error	;009
	MOV	R4,R3			; Copy contorted buffer address	;009
	ASHC	#-7,R3			; Now turn it into MMU address	;009
	MOV	(SP),R1			; Get DDB address		;009
	ADD	TTFMSB,R1		; Point to FMS buffer		;009
	MOV	R3,(R1)			; And save the buffer address	;009
	MOV	(SP)+,R1		; Restore DDB address		;009
	MOV	#TTFMS!TTCRLF,R2	; Set up FMS mode, with no-wrap	;012
	RETURN				; And we're done		;009

10$:	TRAP+DTOOOF			; Only one FMS open at a time	;009

20$:	TRAP+NOBUFS			; No room for an FMS buffer	;009

GLOBAL	<LRGPOL,TTFMSB,DTOOOF,NOBUFS>					;009

.SBTTL	FMSCLS	Close a terminal open in FMS mode

;+
; FMSCLS - Close a terminal open in FMS mode
;
;	R1 -> DDB
;
;	Priority is PR5
;
;	CALL	FMSCLS
;
;	R3 =  Undefined
;
; This routine is used by KBDVR to deactivate FMS mode on a terminal.
; It is called by the close service, as well as anything which would
; stop FMS mode (such as doing I/O to channel zero).
;-

FMSCLS::BICB	#FMSFLD!FMSRDY,DDFLG2(R1) ;;Deactivate any field in progress ;009
	MOV	R4,-(SP)		;;Get a work register		;009
	MOV	R1,R4			;;Copy DDB address		;009
	ADD	TTFMSB,R4		;;And point to buffer pointer	;009
	MOV	(R4),R3			;;Get MMU address of FMS buffer	;009
	CLR	(R4)			;;And clear out buffer pointer	;009
	ASHC	#-11,R3			;;Convert MMU to contorted address ;009
	MOV	R3,R4			;;Set up to return the buffer	;009
	BUFFER	RETURN			;;Now do it			;009
	MOV	(SP)+,R4		;;Restore work register		;009
	RETURN				;;And exit			;009

GLOBAL	<TTFMSB>							;009

.SBTTL	FMSSPC	Handle .SPEC calls for terminals in FMS mode

;+
; FMSSPC - Handle .SPEC calls for terminals in FMS mode
;
;	R1 -> DDB
;	R3 -> Work block (containing a copy of the XRB)
;
;	C = 0 if initial entry
;	C = 1 if redo entry
;
;	JMP	FMSSPC
;
; KBDVR jumps here when the FMS special function is issued, and the
; terminal is already open in FMS mode.
;-      

FMSSPC::ROR	R4			; Save redo indication		;009
	CMPB	DDJBNO(R1),JOB		; Really attached to this job?	;009
	BNE	70$			; No, error			;009
	ROL	R4			; Is this a redo?		;009
	BCS	50$			; Yes, go process it		;009
	MOV	XRBC(R3),(R3)		; No, set up XRB like .WRITE	;009
.ASSUME	XRLEN EQ 0
	CLC				; And indicate read-only checking ;009
	CALLX	CHKXRB			; Check out the XRB		;009
	TST	(R3)+			; Advance to XRB @XRBC		;009
.ASSUME	XRBC EQ 2                                           
	MOV	(R3)+,-(SP)		; Save write length		;009
	MOV	(R3),-(SP)		; Save write address            ;009
.ASSUME	XRLOC EQ XRBC+2                                                 
	MOV	XRMOD-XRLOC(R3),(R3) 	; Get read address              ;009
	CLR	-(R3)			; Clear read count              ;009
	MOV	XRTIME-XRBC(R3),-(R3) 	; Get read count in XRLEN       ;009
	BEQ	10$			; No return data                ;009
	SEC				; Set carry for RW check      	;009
	CALLX	CHKXRB			; Check out the XRB		;009
10$:	MOV	(SP)+,XRLOC(R3)		; Restore write address		;009
	MOV	(SP)+,XRBC(R3)		; Restore write length		;009
	MOV	#10,(R3)		; Restore function code 	;009
.ASSUME	XRLEN EQ 0
	BIS	#JFPOST,@JOBF		; Post status to user		;009
	CALL	FMSSER			; Process the initial entry	;009

;  Return is to code below for both re-do and initial entry

20$:	BITB	#FMSFLD,DDFLG2(R1) 	; See if field declared		;009
	BEQ	40$			; Nope, don't stall user	;009
	BITB	#FMSRDY,DDFLG2(R1) 	; Yep, but is field ready	;009
	BNE	40$			; Yes, post back status		;009
	MOVB	JOB,R4			; Get job number times two	;009
	CLR	JBSTAT(R4)		; Set keyboard			;009
	MOV	#JS.KB,JBWAIT(R4) 	; Input stall			;009
	MAP	TERAP6,APR=6,CODE,DATA	; Ensure class driver is mapped	;009
	SPLC	5			; Lock out terminal interrupts	;009
	CALLX  	FMSQ			;;Queue this DDB for typeahead	;009
	CALLX	ASKINP			;;Ensure input is turned on	;009
	SPLC	3			;;Enable interrupts		;009
	CMPB	#TTPK11,TTINTF(R1) 	; Is this a PK?			;009
	BNE	30$			; No, not this time		;009
	CALLMI	SETPKW,PKDAP5		; Yes, set the PK wait flag	;009
30$:	JMPX	IOREDO			; Set up for I/O redo		;009

40$:	MOV	R2,XRBC(R3)		; Post status word		;009
	BMI	60$			; Return an error               ;009
	JMPX	IOEXIT			; All done                      ;009

50$:	CALL	FMSCNT			; Continue this suspended request ;009
	BR	20$			; and finish up			;009

60$:	TRAP+BADFUO		       	; Fms didn't like this		;009

70$:	TRAP+DETKEY			; Line is hung up		;009

GLOBAL	<BADFUO,DETKEY>							;009

	.SBTTL	FMSSER	- FMS Initial Service Entry

;++              
; FMSSER
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called when a field primitives request is
;	initiated. The user data is copied into the FMS buffer and the
;	data structures are initialized for processing the request.
;
;	If an output request at this level (user level) cannot complete
;	due to a lack of small buffers, etc., the FMSCNT entry point
;	will be called to complete the output. In order for control to 
;	be returned to the correct place and context to be restored
;	correctly, all calls to the routine to do output at this level
;	(PRTUSL) must be called directly from this routine with nothing
;	on the stack but the registers saved on entry to FMSSER and the
;	return PC. In order to do this, the routines to process the
;	specific field primitives requests are entered via a JMP rather
;	than a CALL. Control is returned to the RSTS/E terminal service
;	via a RETURN in each routine.
;
; INPUT:
;
;	R0 =  Terminal number * 2
;	R1 -> DDB
;	R3 -> XRB (in work block)
;
; OUTPUT:
;               
;	R2 = 0 if success
;	R2 < 0 if error
;		DATLNG => Data passed too long
;		INVFCN => Invalid function code
;		INVTRM => Invalid terminal type
;		NOFLD  => No field defined for continue field
;		INVFLD => Invalid field descriptor
;	R2 = Terminal attributes if terminal attribute request and VT52
;     
;	All other registers preserved.
;--

	.ENABL	LSB

                
FMSSER:                                              
	CLR	R2			; Assume success
	$SAV50				; Save all registers

; Map the user data

	CALLX	SCRUMX			; Map the user data
					;   (R5 -> user data mapped via APR6)
	MOV	@DPAR6,R0		; Get MMU value for user data
	MOV	XRBC(R3),R2		; Get user data byte count

; Map the FMS buffer

	MOV	R1,R4			; Copy DDB pointer		;009
	ADD	TTFMSB,R4		; And point to the FMS buffer	;009
	MAP	(R4),APR=6,DATA		; Map the FMS buffer		;009

; Check for valid data length

	MOV	R2,R4			; Get byte count for user data
	ADD	#USRDAT,R4		; Add fixed overhead
	CMP	@#140000,R4		; Is buffer large enough?
	BLO	10$			; Error if not

; Move the user data to the FMS buffer

	MOV	#<140000+USRDAT>,R3	; Data goes here
	MOV	R5,R1			; Copy pointer to user buffer
	SUB	#20000,R1		; Convert to APR5 value
	CALLX	MOVMEM			; Transfer data to FMS buffer

; Set everything up to process

	MOV	TOS.R0(SP),R0		; Get terminal number * 2
	MOV	TOS.R1(SP),R1		; Get DDB address
	MOV	R1,R5			; Copy DDB address		;009
	ADD	TTFMSB,R5		; And point to FMS buffer	;009
	MAP	(R5),APR=6,DATA		; Map FMS buffer		;009
	MOV	#140000,R5		; Point to it
	MOV	R0,KBN(R5)		; Save terminal number * 2
	MOV	R1,DDB(R5)		;   and DDB address
	BIS	#IM$BUF,I$MISC(R5)	; Buffer output at user level
	BIC	#<IM$ESC!IM$GLD>,I$MISC(R5) ; Clear escape seq and gold seq
					;   processing bits just in case
	INITBF				; Initialize print buffer
	CLR	I$CURP(R5)		; Cursor position might not be right
	MOV	#-1,I$VATT(R5)		; Video attributes might not be right

; Now do the primitive request

	MOV	FCNCOD(R5),R2		; Get function code
	CMP	#VLDCOD,R2		; Check for valid function code
	BLOS	20$			; Br if not
	JMP	@DSPTCH(R2)		; Else jump to the right routine
					;   (Can't call or else print
					;   routines won't work)

;
; Data passed too long for FMS buffer
;

10$:	MOV	#DATLNG,TOS.R2(SP)	; Return error in R2
	RETURN				;

;
; Invalid function code
;

20$:	MOV	#INVFCN,TOS.R2(SP)	; Return error in R2
	RETURN				;
	.DSABL	LSB

GLOBAL	<TTFMSB,DPAR6>							;009

	.SBTTL	DSPTCH	- Dispatch Table for Primitive Requests

DSPTCH:
DFN	= . - DSPTCH
	.WORD	DFNFLD			; Define a field 
CON	= . - DSPTCH
	.WORD	CONFLD			; Continue field processing 
ATT	= . - DSPTCH
	.WORD	TRMATT			; Terminal attributes request 
FCN	= . - DSPTCH
	.WORD	TRMFCN			; Terminal function request 
SGN	= .-DSPTCH
	.WORD	SGNLOP			; Signal terminal operator 
SCL	= .-DSPTCH
	.WORD	SCROLL			; Scroll terminal screen 

VLDCOD	= . - DSPTCH

	.SBTTL	DFNFLD	- Define a Field for Processing

;++
; DFNFLD
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine processes a request to define a field to the
;	FMS primitives and to process input for the field.
;
; CALLING SEQUENCE:
;
;	JMP DFNFLD	from FMSSER entry point
;
; INPUT:
;
;	R0 =  Terminal number * 2
;	R1 -> DDB
;	R5 -> Data area
;
;	FCNCOD(R5) = Function code (DFN)
;	CONTRL(R5) = Control word
;	FDESC(R5)  = Field descriptor
;	             Field value
;		     Pattern word (FLDPTN)
;
;	All registers saved on stack at FMSSER entry point.
;
;	TOS.R2(SP) = 0 assuming successful completion
;
; OUTPUT:
;
;	R2 = INVFLD if field descriptor is invalid
;	R2 = 0 otherwise indicating request completed
;
;	All other registers preserved.
;--

	.ENABL	LSB
DFNFLD:

; Check for valid field descriptor

	CALL	VALFLD			; Validate field descriptor
	BCC	10$			; Br if ok
	MOV	R2,TOS.R2(SP)		; Else return error code
	BR	110$			;

; Get status of last line

10$:	BIS	#IS$LST,I$FMST(R5)	; Assume last line not clear
	BIT	#LSTSTS,CONTRL(R5)	; Check it
	BNE	20$			; Br if not clear
	BIC	#IS$LST,I$FMST(R5)	; Else indicate it's clear

; Set up for processing dummy field

20$:	BIT	#DMYFLD,CONTRL(R5)	; Dummy field?
	BEQ	30$			; Br if not
	ESCSEQ	ENDLST			; Else position cursor in lower 
					;   right corner
	CALL	PRTUSL			; Print escape sequence
	BR	100$			;

; Set up for normal field processing

30$:	MOV	#<140000+FDESC>,R4	; Get pointer to field desc
	MOV	#<140000+LNCL>,R3	; Get pointer to line/col entry
	MOV	D$LNCL(R4),L$LNCL(R3)	; Move line/col value to entry
	MOV	R3,D$LNCL(R4)		; Set pointer to line/col entry
	MOV	R4,L$DESC(R3)		; Init field desc pointer
	CLR	R2			; Avoid sign extend
	BISB	D$PLEN(R4),R2		; Get picture length
	ADD	#<140000+FDESC+D$FXLN+1>,R2 ; Get pointer past picture
	MOV	R2,L$RESP(R3)		; Set pointer to response buffer	
	MOVB	D$VATT(R4),R2		; Get video attributes for field
	VIDEO				; And set 'em up
	CALL	PRTUSL			; Print the string
	MOV	#<140000+FDESC>,R4	; Get pointer to field desc
	MOV	#<140000+LNCL>,R3	; Get pointer to line/col entry
	MOV	R3,I$LPTR(R5)		; Save line/col entry pointer

; Set up for fixed decimal field
                 
	BIT	#D2$DEC,(R4)		; (D$ATT2) Fixed decimal field?
	BEQ	40$			; Br if not
	CALL	INITFX			; Initialize for fixed decimal field

; Position cursor for input
;
; The define field request provides an option which uses the field
; offsets currently known to the primitives rather than the initial
; position for a field. This option is used by the Form Driver to
; restore the cursor position correctly after a help form is displayed
; or the screen refresh function is processed. Since a form is displayed
; in both these cases, the field descriptor in the primitives is
; corrupted and the continue field processing request cannot be used.
; The special option uses the offset in the response buffer and the
; offset in the field left from the previous define field request (which
; was for the same field).

40$:	BIT	#FLDOFF,CONTRL(R5)	; Use current field offsets?
	BEQ	80$			; If not, use initial position
	CMP	I$ROFF(R5),D$RLEN(R4)	; Current response offset valid?
	BHI	80$			; If not, use initial position
	MOV	I$ROFF(R5),I$FOFF(R5)	; Make sure field offset correct
	TSTB	D$PLEN(R4)		; Field picture included?
	BEQ	70$			; Br if not
	ADD	#D$PICT,R4		; Else get pointer to picture
	MOV	I$ROFF(R5),R3		; Get offset in response
	INC	R3			; Exit loop at the correct time	;008
50$:	MOVB	(R4)+,R2		; Get character from picture
	TXTCHR				; Is it a text character?
	BCC	60$			; Br if not
	INC	I$FOFF(R5)		; Else inc offset in field
	BR	50$			; And check next character
60$:	SOB	R3,50$			; Dec offset in response and check
					;   next character
70$:	MOV	I$FOFF(R5),R2		; Get offset in field
	SWAB	R2			; Move to high byte
	ADD	<140000+LNCL+L$LNCL>,R2	; Add start of field = cursor position
	SETCUR				; Move the cursor there
	BR	90$			; And print the string

80$:	CALL	INIPOS			; Position cursor for input
90$:	CALL	PRTUSL			; Print the string

100$:	BIS	#IM$FLD,I$MISC(R5)	; Indicate field defined
	BISB	#FMSFLD,DDFLG2(R1)	; Indicate there's a field
	BICB	#FMSRDY,DDFLG2(R1)	; But it's not ready
110$:	RETURN				;
	.DSABL	LSB

	.SBTTL	CONFLD	- Continue Processing Current Field

;++
; CONFLD
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine allows the Form Driver to continue processing
;	in the field currently defined to the primitives. For 
;	FMS/RSTS V1.5, the other options of the modify field
;	context request (display field value, modify video attributes
;	or current cursor position, etc.) are not implemented since
;	they are not required by the Form Driver.
;
;	The high bit of the first byte of the field value may be set
;	when this routine is entered. That bit is set when a field
;	is terminated and the field value returned to the user to
;	indicate the field has been altered.
;
; CALLING SEQUENCE:
;
;	JMP CONFLD	from FMSSER entry point
;
; INPUT:
;
;	R0 =  Terminal number * 2
;	R1 -> DDB
;	R5 -> Data area
;
;	FCNCOD(R5) = Function code (CON)
;	CONTRL(R5) = Control word
;	FDESC(R5)  = Field descriptor
;		     Field value
;		     Pattern word (FLDPTN)
;
;	All registers saved on stack at FMSSER entry point.
;
;	TOS.R2(SP) = 0 assuming successful completion
;
; OUTPUT:
;
;	R2 = NOFLD if no field is currently defined
;	R2 = INVFLD if field descriptor is invalid
;	R2 = 0 otherwise indicating request completed
;
;	All other registers preserved.
;--

	.ENABL	LSB
CONFLD:

; Check for a valid field defined

	BIT	#IM$FLD,I$MISC(R5)	; Check for a defined field
	BEQ	60$			; Error if not
	CALL	VALFLD			; Check for valid field desc
	BCC	10$			; Br if so
	MOV	R2,TOS.R2(SP)		; Else return error code
	BR	50$			;

10$:	BIS	#IS$LST,I$FMST(R5)	; Assume last line not clear
	BIT	#LSTSTS,CONTRL(R5)	; Check it
	BNE	20$			; Br if not clear
	BIC	#IS$LST,I$FMST(R5)	; Else indicate it's clear

; Dummy field

20$:	BIT	#DMYFLD,CONTRL(R5)	; Dummy field?
	BEQ	30$			; Br if not
	ESCSEQ	ENDLST			; Else position cursor in lower 
					;   right corner
	CALL	PRTUSL			; Print escape sequence
	BR	40$			;

; Other fields

30$:	MOV	I$FOFF(R5),R2		; Get current offset in field
	SWAB	R2			; Move to high byte
	ADD	<LNCL+L$LNCL>(R5),R2	; Add line/col for start of field =
					;   current cursor position
	SETCUR				; Move cursor to correct position
	CALL	PRTUSL			; Print the string
	MOVB	<FDESC+D$VATT>(R5),R2	; Get video attributes for field
	VIDEO				; And set 'em up
	CALL	PRTUSL			; Print the string

40$:	BISB	#FMSFLD,DDFLG2(R1)	; Indicate there's a field
	BICB	#FMSRDY,DDFLG2(R1)	; But it's not ready
50$:	RETURN


;
; No field defined to FMS primitives
;

60$:	MOV	#NOFLD,TOS.R2(SP)	; Return error in R2
	RETURN				;

	.DSABL	LSB

	.SBTTL	VALFLD	- Check for Valid Field Descriptor

;++
; VALFLD
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine validates the field descriptor in the FMS
;	data area. If the field descriptor is valid, the word
;	following the field value should be the pattern word
;	FLDPTN. The data in the field descriptor (picture length,
;	response length, etc.) is used to locate that word. If
;	it is not the correct pattern word, the field descriptor
;	is considered invalid.
;
; INPUT:
;
;	140000 + FDESC = Start of field descriptor
;
; OUTPUT:
;
;	R2, R3, R4 modified
;
;	C-CLR if valid field descriptor
;	C-SET if invalid field descriptor
;	    R2 = INVFLD (error code)
;--

	.ENABL	LSB
VALFLD:
	CLC				; Assume valid field descriptor
	BIT	#DMYFLD,CONTRL(R5)	; Check for dummy field
	BNE	10$			; If so, valid descriptor
	MOV	#<140000+FDESC>,R4	; Get field desc pointer
	MOV	R4,R3			; Save it
	ADD	#D$PLEN,R3		; Pointer to picture length
	CLR	R2			; Avoid sign extend
	BISB	(R3)+,R2		; Get picture length
	ADD	R2,R3			; Add it in
	ADD	D$RLEN(R4),R3		; Add response length to point
					;   past response
	INC	R3			; Round up to word
	BICB	#1,R3			;
	CMP	#FLDPTN,(R3)		; Is this the pattern word?
	BEQ	10$			; If so ok
	MOV	#INVFLD,R2		; Else return error code
	SEC				; And indicate error
10$:	RETURN				;
	.DSABL	LSB

	.SBTTL	TRMATT	- Terminal Attribute Request

;++
; TRMATT
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine determines the attributes of the terminal
;	and returns them to the Form Driver. The following
;	information is determined:
;
;		o terminal type
;		o current screen size (if VT100)
;		o whether terminal has advanced video option (if VT100)
;
;	If the escape sequences to determine the screen size and the
;	device attributes cannot be successfully parsed, the terminal
;	is set to 80 column mode and it assumed the terminal does not
;	have the advanced video option.
;
;	This routine also initializes certain data in the FMS buffer.
;	It is called by the Form Driver each time a form is displayed
;	(since there is no Form Driver initialization call for V1.5).
;
; CALLING SEQUENCE:
;
;	JMP TRMATT	from FMSSER entry point
;
; INPUT:
;
;	R0 =  Terminal number * 2
;	R1 -> DDB
;	R5 -> Data area
;
;	FCNCOD(R5) = Function code (ATT)
;
;	All registers saved on stack at FMSSER entry point.
;
;	TOS.R2(SP) = 0 assuming successful completion
;
; OUTPUT:
;
;	R2 = INVTRM if terminal not VT100 or VT52 compatible
;	R2 = 0 otherwise indicating request completed
;
;	All other registers preserved.
;--

	.ENABL	LSB
TRMATT:

; Determine terminal type

	CLR	I$FMST(R5)		; Clear form and field status word
	MOV	#IM$BUF,I$MISC(R5)	; Buffer output at user level but
					;   clear rest of misc status word
					;   (Indicate no field defined)

; Determine terminal type

	BIT	#TTSCOP,TTCHAR(R1)	; Is terminal VT100 or VT52?
	BEQ	30$			; Invalid terminal type if not
	BIT	#TTLCIN,TTCHAR(R1)	; Is terminal VT100 or VT52?
	BEQ	30$			; Invalid terminal type if not
	BIT	#TTXON,TTCHAR(R1)	; Is it a VT100?
	BNE	10$			; Br if so
	BIS	#IM$TRM,I$MISC(R5)	; Else indicate VT52


; Initialize terminal

10$:	ESCSEQ	INITRM			; Initialize terminal
	CALL	PRTUSL			; Print escape sequence
	BIT	#IM$TRM,I$MISC(R5)	; Is terminal VT100?
	BEQ	20$			; Br if so
	MOV	I$MISC(R5),TOS.R2(SP)	; Else return terminal info in R2
	MOVB	#<177&PATLVL>,TOS.R2+1(SP) ; Return patch level in high byte
					   ;   and make sure it's not negative
	RETURN				; And we're done

PATLVL	= 1				; Patch level for RSTS/E V7.2 field
					;   primitives

;
; IMPORTANT: The high bit of R2 must never be set on return at this point.
;            If R2 is negative on return (the high bit set), it indicates
;            an error. Therefore, the maximum value for the patch level
;            is 127.
;

; Get device attributes and current screen size for VT100

20$:	BISB	#FMSFLD,DDFLG2(R1)	; Indicate there's a field and
	BICB	#FMSRDY,DDFLG2(R1)	;   that it's not ready so we
					;   get input for reply
	BIS	#IM$ESC,I$MISC(R5)	; Indicate parsing escape sequence
	MOV	#1,ESCSTS(R5)		; Starting escape sequence
	MOV	#-1,PRMSTS(R5)		; Initialize parameter status
	CLR	PARM1(R5)		; Initialize first parameter value
	MOV	#<140000+PARM1>,PRMPTR(R5) ; Set pointer to it
	ESCSEQ	DEVATT			; Get device attributes
	CALL	PRTUSL			; Print escape sequence
	RETURN				; And wait for terminal reply


;
; Invalid terminal type (only VT100 or VT52 compatible terminals
; supported)
;

30$:	MOV	#INVTRM,TOS.R2(SP)	; Return error in R2
	RETURN				;
	.DSABL	LSB

	.SBTTL	TRMFCN	- Terminal Function Request

;++
; TRMFCN
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine provides the following general terminal
;	functions:
;
;		o clear a portion of the screen
;		o set the screen width (VT100 only)
;		o set the screen background (VT100 only)
;		o restore terminal attributes (VT100 only)
;
; CALLING SEQUENCE:
;
;	JMP TRMFCN	from FMSSER entry point
;
; INPUT:
;
;	R0 =  Terminal number * 2
;	R1 -> DDB
;	R5 -> Data area
;
;	FCNCOD(R5) = Function code (FCN) 
;	CONTRL(R5) = Control word
;	    ERSSCR = 1 => erase portion of screen
;	    SETSIZ = 1 => set screen size
;	    SCRSIZ = 1 => 132 column mode
;	    SETBCK = 1 => set screen background
;	    SCRBCK = 1 => black on white
;	    RESTOR = 1 => restore terminal attributes
;	FCCLIN(R5) = First line to clear (0 => entire screen)
;	LCLLIN(R5) = Last line to clear
;
;	All registers saved on stack at FMSSER entry point.
;
;	TOS.R2(SP) = 0 assuming successful completion
;
; OUTPUT:
;
;	R2 = 0 indicating request completed
;
;	All registers preserved.
;--

	.ENABL	LSB
TRMFCN:
	BIC	#IM$FLD,I$MISC(R5)	; No field defined
	BIT	#ERSSCR,CONTRL(R5)	; Clear screen?
	BEQ	30$			; Br if not
	MOV	FCLLIN(R5),R2		; Get first line to clear
	BEQ	20$			; Entire screen if zero

; Clear portion of screen

	SETCUR				; Move cursor to first line
	CALL	PRTUSL			; Print escape sequence
	INC	LCLLIN(R5)		; Inc to get correct count
	SUB	FCLLIN(R5),LCLLIN(R5)	; Get number lines to clear
	BLE	30$			; Ignore if invalid numbers
10$:	ESCSEQ	CLRLIN			; Clear line
	CALL	PRTUSL			; Print escape sequence
	DEC	LCLLIN(R5)		; Dec counter
	BGT	10$			; Next line until done
	BR	30$			; Done

; Clear entire screen

20$:	ESCSEQ	CLRSCR			; Clear entire screen
	CALL	PRTUSL			; Print escape sequence

; Set screen size (VT100 only)

30$:	BIT	#IM$TRM,I$MISC(R5)	; Terminal VT100?
	BNE	100$			; Br if not
	BIT	#SETSIZ,CONTRL(R5)	; Set screen size?
	BEQ	60$			; Br if not
	BIT	#SCRSIZ,CONTRL(R5)	; 80 column mode?
	BNE	40$			; Br if not
	BIT	#IM$WID,I$MISC(R5)	; Already 80 column mode?
	BEQ	60$			; Br if so
	ESCSEQ	COL80			; Else set 80 column mode
	BIC	#IM$WID,I$MISC(R5)	;   and indicate it
	BR	50$			;
40$:	BIT	#IM$WID,I$MISC(R5)	; Already 132 column mode?
	BNE	60$			; Br if so
	ESCSEQ	COL132			; Else set 132 column mode
	BIS	#IM$WID,I$MISC(R5)	;   and indicate it
50$:	CALL	PRTUSL			; Print escape sequence

; Set screen background (VT100 only)

60$:	BIT	#SETBCK,CONTRL(R5)	; Set screen background?
	BEQ	90$			; Br if not
	BIT	#SCRBCK,CONTRL(R5)	; White on black screen?
	BNE	70$			; Br if not
	ESCSEQ	NRMVID			; Set white on black
	BR	80$			;
70$:	ESCSEQ	RVSVID			; Set black on white
80$:	CALL	PRTUSL			; Print escape sequence

; Restore terminal attributes (VT100 only)

90$:	BIT	#RESTOR,CONTRL(R5)	; Restore terminal attributes?
	BEQ	100$			; Br if not
	CLR	R2			; Clear video attributes
	VIDEO				; Go do it
	CALL	PRTUSL			; Print escape sequence
	CLR	R3			; Restore scrolled area to
	CLR	R4			;   entire screen
	CALL	SCRLAR			; Go do it
	CALL	PRTUSL			; Print escape sequence
100$:	RETURN				;
	.DSABL	LSB

	.SBTTL	SGNLOP	- Signal Terminal Operator

;++
; SGNLOP
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine rings the terminal bell to signal the
;	terminal operator.
;
; CALLING SEQUENCE:
;
;	JMP SGNLOP	from FMSSER entry point
;
; INPUT:
;
;	R0 =  Terminal number * 2
;	R1 -> DDB
;	R5 -> Data area
;
;	FCNCOD(R5) = Function code (SGN)
;
;	All registers saved on stack at FMSSER entry point.
;
;	TOS.R2(SP) = 0 assuming successful completion
;
; OUTPUT:
;
;	R2 = 0 indicating request completed
;
;	All other registers preserved.
;--

	.ENABL	LSB
SGNLOP:
	MOV	#BEL,R2			; Ring terminal bell
	STRBYT				; Buffer it
	CALL	PRTUSL			; And print it
	RETURN				; And done
	.DSABL	LSB

	.SBTTL	SCROLL	- Scroll the Terminal Screen

;++
; SCROLL
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine causes the specified area of the screen to
;	scroll one line in the direction indicated.
;
; CALLING SEQUENCE:
;
;	JMP SCROLL	from FMSSER entry point
;
; INPUT:
;
;	R0 =  Terminal number * 2
;	R1 -> DDB
;	R5 -> Data area
;
;	FCNCOD(R5) = Function code (SCL)
;	CONTRL(R5) = Control word
;	    SCLDIR = 1 => scroll backward
;	FSCLIN(R5) = First line of scrolled area
;	LSCLIN(R5) = Last line of scrolled area
;
;	All registers saved on stack at FMSSER entry point.
;
;	TOS.R2(SP) = 0 assuming successful completion
;
; OUTPUT:
;
;	R2 = 0 indicating request completed
;
;	All other registers preserved.
;--

	.ENABL	LSB
SCROLL:
	BIC	#IM$FLD,I$MISC(R5)	; No field defined
	BIT	#IM$TRM,I$MISC(R5)	; Terminal VT100?
	BNE	30$			; Ignore request if not
	MOV	FSCLIN(R5),R3		; First line of scrolled area
	MOV	LSCLIN(R5),R4		; Last line of scrolled area
	CALL	SCRLAR			; Define scrolled area
	CALL	PRTUSL			; Print the string to do it
	BIT	#SCLDIR,CONTRL(R5)	; Scroll forward?
	BNE	10$			; Br if not

; Scroll forward

	MOV	LSCLIN(R5),R2		; Last line number; col = 0
	SETCUR				; Position cursor there
	CALL	PRTUSL			; Print the string
	ESCSEQ	SCLFWD			; Scroll forward (up)
	BR	20$			; 

; Scroll backward

10$:	MOV	FSCLIN(R5),R2		; First line number; col = 0
	SETCUR				; Position cursor there
	CALL	PRTUSL			; Print the string
	ESCSEQ	SCLBWD			; Scroll backward (down)
20$:	CALL	PRTUSL			; Print the string
30$:	RETURN				;
	.DSABL	LSB                     

	.SBTTL	FMSINT	- FMS Interrupt Service Routine

;++
; FMSINT
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called by the RSTS/E terminal service at
;	interrupt level when a field is active to process characters
;	as they are entered at the terminal.
;
;	All escape sequence parsing has been moved from the RSTS/E
;	terminal service into this module
;                                       
; INPUT:
;
;	R0 =	Terminal number * 2
;	R1 ->	DDB 
;	R2 = 	Character in low byte
;
; OUTPUT:
;
;	All registers preserved.
;--

	.ENABL	LSB
$FMSIN::
FMSINT:
	$SAV50				;; Save all registers

; Initialize

	MOV	R1,R5			;; Copy DDB pointer		;009
	ADD	TTFMSB,R5		;; Point to buffer address	;009
	MAP	(R5),APR=6,DATA		;; Map the FMS buffer		;009
	MOV	#140000,R5		;; Point to it
	BIC	#IM$BUF,I$MISC(R5)	;; Don't buffer output
	INITBF				;; Initialize print buffer

; Check for parsing escape sequences for device attributes and screen size

	BIT	#IM$ESC,I$MISC(R5) 	;; Parsing expected escape sequence?
	BNE	90$			;; Br if so
                                        
; Clear last line on each keystroke

	CLR	R4			;; Indicate clear last line
	PRTLST				;; Clear the last line

; Process GOLD key sequence
;

	BIT	#IM$GLD,I$MISC(R5)	;; Processing gold key sequence?
	BEQ	20$			;; Br if not
	MOVB	CHRTBL(R2),R0		;; get the validation code for the char
	BIC	#177400,R0		;; cancel the sign extend
	CMP	R0,#7			;; escape sequence next?
	BNE	10$			;; branch if not
;                                       
; process GOLD-ESCAPE sequence
;
	MOV	#CHRLST,R0		;; get the address of the gold-esc table
	BR 	30$			;; process gold-escape sequence
;
; process GOLD-CHARACTER sequence
;
10$:	MOV	#GLDCHR,R0		;; Else point to other list
	BIC	#IM$GLD,I$MISC(R5)	;; clear the bit
	BR	30$			;; And process input
	

;       
; Check for valid character to echo
;                                     
20$:	MOVB	CHRTBL(R2),R0		;; get the validation code for the char
	BIC	#177400,R0		;; cancel the sign extend
	CMP	R0,#7			;; else check for valid char to echo
	BLOS	25$			;; process special character
	MOV	#ECHO,R0		;; get the address of the ECHO routine
;	BR	60$			;; process echo character
;
; Process dummy field
;
;60$:
	BIT	#DMYFLD,CONTRL(R5)	;; Processing dummy field?
	BEQ	70$			;; Br if not

;	CALL	(R0)			;; process special character

;	TST	R2			;; Field terminator?
;	BMI	TRMINP			;; if so, then continue

	SGNLER				;; else signal error
	JMP	210$			;; And wait for input
;
; Determine which special character was entered.
;
25$:	MOV	#CHRLST,R0		;; point to list of special characters
30$:	TST	(R0)			;; End of list?
	BEQ	40$			;; Br if so
	CMPB	R2,(R0)			;; Else check for match in list
	BEQ	40$			;; Br if found
	CMP	(R0)+,(R0)+		;; Else point to next entry
	BR	30$			;; And check it

40$:	TST	(R0)+			;; Point to routine to call
	MOV	(R0),R0			;; get the address from the pointer

; Set up and process input for field    

70$:	MOV	I$LPTR(R5),R3		;; Get line/col entry pointer
	MOV	L$DESC(R3),R4		;; Get field desc pointer
	BIT	#D2$DEC,(R4)		;; (D$ATT2) Fixed decimal field?
	BEQ	80$			;; Br if not
	JMP	FIXDEC			;; Else special processing
80$:	CALL	(R0)			;; Else call routine to process input

; Process field terminator

85$:	TST	R2			;; Field terminator?
	BMI	TRMINP			;; if so, then continue
	JMP	210$			;; If not, wait for next character
TRMINP:	BIC	#100000,R2		;; Else clear high bit
	MOV	R2,TERM(R5)		;; Save the terminator
	JMP	200$			;; Wake the user

; Get device attributes and screen size (parse escape sequences here)

90$:	BITB	#ESCMSK,I$FDST(R5)	;; parsing terminal attribute sequence?
	BEQ	98$			;; branch if so
;
; parse keyboard escape sequences
;
	MOVB	CHRTBL(R2),R0		;; get the mode value for character
	BIC	#MODMSK,R0		;; clear any field validation bits
	ASL	R0			;; convert from byte to word offset
	ADD	#ESCDIS,R0		;; get the pointer to the routine 
					;; address from ESCDIS
	MOV	(R0),R0			;; make direct
	BR	70$			;; process the input

;; else must be terminal attribute request

98$:	MOVB	#ESC33,R3		;; Escape character
	TST	ESCSTS(R5)		;; Where are we?
	BGT	100$			;; Just starting
	BLT	110$			;; Parsing parameters
	MOVB	#'[,R3			;; Finishing CSI
100$:	CMPB	R2,R3			;; Do we have the right thing?
	BNE	140$			;; Forget it if not
	DEC	ESCSTS(R5)		;; Else dec to get new status
	BR	210$			;; And wait for input

110$:	CMPB	R2,#100			;; Final character?
	BHIS	130$			;; Process if so
	TST	PRMSTS(R5)		;; Second parameter done?
	BGT	210$			;; If so, wait for terminator	
	CMPB	R2,#';			;; Else check for separator?
	BNE	120$			;; No, process parameter
	INC	PRMSTS(R5)		;; Another parameter done
	TST	PRMSTS(R5)		;; Second parameter done?
	BGT	210$			;; If so, wait for terminator
	ADD	#2,PRMPTR(R5)		;; Else point to next parameter
	CLR	@PRMPTR(R5)		;; Else initialize second parameter
	BR	210$			;; And wait for input

120$:	CMPB	R2,#'0			;; Valid parameter?
	BLO	140$			;; Forget it if not, we're done
	CMPB	R2,#'9			;; Check other limit
	BHI	210$			;; Ignore it if another valid char
	MOV	@PRMPTR(R5),R4		;; Get parameter value
	ASL	R4			;; Multiply value by 10
	ASL	R4			;;   10X = (4X + 1X) * 2
	ADD	@PRMPTR(R5),R4		;;
	ASL	R4			;;
	SUB	#60,R2			;; Convert input to binary value
	ADD	R2,R4			;; Add it in
	MOV	R4,@PRMPTR(R5)		;; And save it
	BR	210$			;; Wait for input

130$:	INC	PRMSTS(R5)		;; Terminator => parameter done
	CMPB	R2,#'c			;; Device attributes report?
	BEQ	150$			;; Process if so
	CMPB	R2,#'R			;; Cursor position for screen size?
	BEQ	180$			;; Process if so
140$:	ESCSEQ	COL80			;; Else assume 80 column mode and
					;;   make sure it is
	BR	190$			;; We're done

; Process device attributes

150$:   CMP	PARM1(R5),#1		;; terminal above VT100 family? 
	BHI	160$			;; branch if so                 
	TST	PRMSTS(R5)		;; Only one parameter?
	BLE	160$			;; If so assume AVO (VT102 case)
	BIT	#AVO,PARM2(R5)		;; Test for AVO
	BEQ	170$			;; Br if not
160$:	BIS	#IM$AVO,I$MISC(R5)	;; Else indicate terminal has AVO

; Set up to determine screen size
                                      
170$:	MOV	#1,ESCSTS(R5)		;; Starting over
	MOV	#-1,PRMSTS(R5)		;; Parameter status
	CLR	PARM1(R5)		;; Initialize first parameter value
	MOV	#<140000+PARM1>,PRMPTR(R5) ;; And set pointer to it
	ESCSEQ	SIZSCR			;; Move cursor to lower right and
					;;   request cursor position report
	BR	210$			;; And wait for input

; Process screen size

180$:	TST	PRMSTS(R5)		;; Both parameters?
	BLE	140$			;; If not assume 80 columns
	CMP	PARM2(R5),#132.		;; Wide screen mode?
	BLT	190$			;; Nope
	BIS	#IM$WID,I$MISC(R5)	;; Else indicate wide screen

190$:	BIC	#IM$ESC,I$MISC(R5)	;; Done parsing escape sequences

; Wake the user

200$:	BICB	#FMSFLD,DDFLG2(R1)	;; Deactivate field
	BISB	#FMSRDY,DDFLG2(R1)	;; Indicate field is ready

210$:	RETURN				;;

GLOBAL	<TTFMSB>							;009

	.DSABL	LSB

	.SBTTL	FMSCNT	- FMS Continuation Service Entry 

;++
; FMSCNT
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to complete the processing of a field
;	primitive request after the user is woken up following the
;	termination of terminal input for a request.
;
;	This routine may also be called to complete an output request
;	at user level.
;
; INPUT:
;                                       
;	R0 =  Terminal number * 2
;	R1 -> DDB
;	R3 -> XRB (in work block)
;
; OUTPUT:
;
;	Field value returned in user buffer if define field or
;	continue field processing request. High bit of first byte
;	of field value set if field was altered. The continue
;	field processing request always clears the high bit of the
;	first byte of the field value just in case it was set.
;
;	R2 = Field terminator or terminal attributes
;	     (High bit always clear to indicate success)
;                                  
;	All other registers preserved.
;--

	.ENABL	LSB
FMSCNT:
	CLR	R2			; Assume success
	$SAV50				; Save all registers

; Check for completion of user level output

	MOVB	JOB,R4			; Get job number * 2
	BIT	#JSTEL,JBWAIT(R4)	; Are we finishing a write?
	BEQ	5$			; continue if so
	JMP	PRTAGN			; If so, go do it
                                        
; Complete field primitives request

5$:	MOV	R1,R5			; Copy DDB pointer		;009
	ADD	TTFMSB,R5		; Point to FMS buffer		;009
	MAP	(R5),APR=6,DATA		; Map the FMS buffer		;009
	MOV	#140000,R5		; Point to it
	BICB	#FMSRDY,DDFLG2(R1) 	; Say field is not ready
	BIS	#IM$BUF,I$MISC(R5)	; Buffer output at user level

	CMP	#DFN,FCNCOD(R5)		; Define field request?
	BEQ	10$			; Br if so
	CMP	#CON,FCNCOD(R5)		; Continue field processing request?
	BEQ	10$			; Br if so
	CMP	#ATT,FCNCOD(R5)		; Terminal attributes request?
	BNE	40$			; If not ignore it

; Return terminal attributes

	MOV	I$MISC(R5),TOS.R2(SP)	; Return terminal info in R2
	MOVB	#<177&PATLVL>,TOS.R2+1(SP) ; Return patch level in high byte
					   ;   and make sure it's not negative
	BR	40$			; Done

; Return field value and terminator for define field and continue
; field processing

10$:	MOV	TERM(R5),TOS.R2(SP) 	; Return terminator in R2
	BIT	#IS$LST,I$FMST(R5)	; Check status of last line
	BEQ	20$			; Br if clear
	BIS	#RETLST,TOS.R2(SP)	; Else indicate not clear
20$:	BIT	#DMYFLD,CONTRL(R5)	; Processing dummy field?
	BNE	40$			; Br if so, done
	BIT	#IS$ALT,I$FDST(R5)	; Was field altered?
	BEQ	30$			; Br if not
	BIS	#FLDALT,TOS.R2(SP)	; Else return indicator             
	BIC	#IS$ALT,I$FDST(R5)	; Clear field altered bit
30$:	MOV	R1,R0			; Copy DDB pointer		;009
	ADD	TTFMSB,R0		; Advance to FMS buffer pointer	;009
	MOV	(R0),R0			; Now get MMU address for MOVMEM ;009
	MOV	<LNCL+L$RESP>(R5),R1	; Get pointer to response to return
	SUB	#20000,R1		; Convert to APR5 value
	MOV	<FDESC+D$RLEN>(R5),R2	; Get length of data
	MOV	TOS.R3(SP),R3		; Restore XRB value
	MOV	XRMOD(R3),XRLOC(R3) 	; Get buffer return address
	CALLX	SCRUMX			; Map the user
	MOV	R5,R3			; Copy pointer to user's buffer
	CALLX	MOVMEM			; Transfer data
40$:	RETURN
	.DSABL	LSB

GLOBAL	<JSTEL,JBWAIT,TTFMSB>						;009

	.SBTTL 	LK201 FUNCTION KEY ESCAPE SEQUENCE PARSING ROUTINES

	.SBTTL	EDISEQ	- routine to parse an edit-key escape sequence
	.ENABL	LSB
;++
; EDISEQ
;
; FUNCTIONAL DESCRIPTION:
;
;	Parses the escape sequences for the top-row function keys and the
;	edit keys.
;
; INPUT:
;
; 	R2 	= incoming character
;
; OUTPUT:
;
;	ESCBUF is used as a buffer to store the first digit in the event
;	of an escape sequence containing two digits.
;--


EDISEQ:	BITB 	#IS$LEV,I$FDST(R5)	; first character after CSI?
	BNE	10$			; branch if not
;
; process first digit in escape sequence
;
	MOV 	R2,ESCBUF		; save first character of CSI sequence
	ADD	#-20,ESCBUF		; add offset for terminator code
	BIS	#IS$LEV,I$FDST(R5)	; ready for second character
	RETURN				; get next character
;
; process second digit in escape sequence
;
10$:	CMP	R2,#TILDE		; end of string (~ is delimiter)?
	BEQ	20$			; branch if so

	CMP	#<'1-16.>,ESCBUF	; was the first character a '1?
	BNE	12$			; branch if not
;
; calculate terminator value for sequences with a '1 as first digit
;
	ADD	#-47,ESCBUF		; offset for top-row terminator
	ADD	R2,ESCBUF		; add the second character
	RETURN

12$:	CMP	#<'2-16.>,ESCBUF	; was the first character a '2?
	BNE	14$			; branch if not
;
; calculate terminator value for sequence with a '2 as the first digit
;
	ADD	#-36,ESCBUF		; offset for top-row terminator
	ADD	R2,ESCBUF		; add the second character
	RETURN
;
; calculate terminator value for sequence with a '3 as the first digit
; 
; NOTE: terminator values in this case are temporarily shifted up six to
;       prevent conflict with the cursor-key terminator values.  Correction
;	occurs in the application form-driver kernel.
;
14$:    ADD	#-17,ESCBUF		; offset for top-row terminator
	ADD	R2,ESCBUF		; add the second character
	RETURN
;
; return the terminator value, checking for keys that require immediate action
;
20$:	MOV	ESCBUF,R2		; get terminator code
	BIT	#DMYFLD,CONTRL(R5)	; are we in a dummy field?
	BNE	40$			; branch if so
	CMP	#'8,R2			; F12 (BACKSPACE) key?
	BNE 	30$			; branch if not
;
; BACKSPACE (F12) key was pressed
;
	MOV	#10,R2			; return a BACKSPACE 
	CALL 	ESCCLR			; clear the escape flag bits
	JMP	CHRTRM			; process as a character terminator

30$:	CMP	#'9,R2			; F13 (LINEFEED) key?
	BNE	40$			; branch if not
;
; LINEFEED (F13) key was pressed
;	
	CALL	ESCCLR			; clear the escape flags
	JMP	DELFLD

40$:	CMP	#'<,R2			; F15 (HELP) key?
	BNE	50$			; branch if not
;
; HELP (F15) key was pressed - return as a PF2
;
	MOV	#'Q,R2			; return a PF2

50$:	JMP	ESCTRM			; return code to user as escape term.
	
	.DSABL	LSB
	

	.SBTTL	CURSEQ	- routine to parse a cursor-control key escape sequence
	.ENABL	LSB
;++
; CURSEQ
;
; FUNCTIONAL DESCRIPTION:
;
;	Parses the escape sequences for the cursor keys.
;
; INPUT:
;
;	R2	= incoming character
;
; OUTPUT:
;
;--                       

; The following section of commented code was in the SDC version of RSTS V9.5
;
;CURSEQ:	BIT	#DMYFLD,CONTRL(R5)	; are we in a dummy field?
;	BNE	30$			; branch if so
;	CMPB	R2,#'C			; right-arrow key?
;	BNE 	10$			; branch if not
;;
;; RIGHT-ARROW key was pressed
;;
;	CALL	ESCCLR			; clear the escape sequence flags
;	JMP	CURGHT			; move the cursor to the right
;
;10$:	CMPB	R2,#'D			; left-arrow key?
;	BNE 	20$			; branch if not
;;
;; LEFT-ARROW key was pressed
;;
;	CALL	ESCCLR			; clear the escape sequence flags
;	JMP	CURLFT			; move the cursor to the left
;;
;; UP-ARROW or DOWN-ARROW key was pressed
;;	
;20$:	BIT	#IM$GLD,I$MISC(R5)	; GOLD (up-arrow|down-arrow) sequence?
;	BEQ	30$
;;
;; process GOLD (up-arrow|down-arrow) sequence
;;
;	BIC	#IM$GLD,I$MISC(R5)	; clear the GOLD sequence flag bit
;	CALL 	ESCCLR			; clear the ESCAPE sequence flag bits
;	JMP	GETERM			; process as a GOLD-ESCAPE terminator
;
;30$:	JMP	ESCTRM			; process as a escape terminator

CURSEQ:	BIT	#DMYFLD,CONTRL(R5)	; are we in a dummy field?          ;013
	BNE	30$			; branch if so                      ;013
                                                                            ;013
	BIT	#IM$GLD,I$MISC(R5)	; GOLD (up-arrow|down-arrow) sequence?;013
	BNE	25$			; branch if so                      ;013
                                                                            ;013
	CMPB	R2,#'C			; right-arrow key?                  ;013
	BNE 	10$			; branch if not                     ;013
;                                                                           ;013
; RIGHT-ARROW key was pressed                                               ;013
;                                                                           ;013
	CALL	ESCCLR			; clear the escape sequence flags   ;013
	JMP	CURGHT			; move the cursor to the right      ;013
                                                                            ;013
10$:	CMPB	R2,#'D			; left-arrow key?                   ;013
	BNE 	30$			; branch if not                     ;013
;                                                                           ;013
; LEFT-ARROW key was pressed                                                ;013
;                                                                           ;013
	CALL	ESCCLR			; clear the escape sequence flags   ;013
	JMP	CURLFT			; move the cursor to the left	    ;013
;									    ;013
; UP-ARROW or DOWN-ARROW key was pressed				    ;013
;									    ;013
;									    ;013
; process GOLD (up-arrow|down-arrow) sequence				    ;013
;									    ;013
25$:	BIC	#IM$GLD,I$MISC(R5)	; clear the GOLD sequence flag bit  ;013
	CALL 	ESCCLR			; clear the ESCAPE sequence flag bits;013
	JMP	GETERM			; process as a GOLD-ESCAPE terminator;013
 									    ;013
30$:	JMP	ESCTRM			; process as a escape terminator    ;013
 									    ;013
	.DSABL 	LSB


	.SBTTL	KPSEQ	- routine to parse an auxilliary keypad escape sequence
	.ENABL	LSB
;++
; KPSEQ
;
; FUNCTIONAL DESCRIPTION:
;
;	Parses the escape sequences from the auxilliary key pad.
;
; INPUT:
;
;	R2	= incoming character
;
; OUTPUT:
;
;--

KPSEQ:	CMPB	#'M,R2			; keypad ENTER key?
	BNE	10$			; branch if not
;
; keypad ENTER key
;
	CALL	ESCCLR			; clear the escape flags
	MOV	#CR,R2			; pretend its a RETURN
	JMP	CHRTRM

10$:	JMP	ESCTRM			; process as an escape terminator

	.DSABL	LSB


.SBTTL	PFSEQ	- routine to parse a PF function key escape sequence
.ENABL 	LSB
;++
; PFSEQ
;
; FUNCTIONAL DESCRIPTION:
;
;	Parses the escape sequences from the PF function keys.
;
; INPUT:
;                         
;	R2	= incoming character
;
; OUTPUT:
;
;--

PFSEQ:	BIT	#DMYFLD,CONTRL(R5)	; are we in a dummy field?
	BNE	20$			; branch if so
	CMPB	R2,#'P			; 'P => PF1
	BNE	10$			; branch if not
;
; GOLD (PF1) key was pressed
;
	CALL	ESCCLR			; clear the escape sequence flags
	JMP	GOLD			; process GOLD key (PF1)

10$:	CMPB	R2,#'R			; 'R => PF3
	BNE	20$			;  branch if not
;
; PF3 key was pressed
;
	CALL	ESCCLR			; clear the escape sequence flags
	BIT	#IM$GLD,I$MISC(R5)	; is this a GOLD-PF3 sequence?
	BEQ	15$			; branch if not
;
; GOLD-PF3 sequence
;
	BIC	#IM$GLD,I$MISC(R5)	; clear the GOLD sequence bit
	JMP	OVRSTK			; process OVERSTRIKE mode 
;
; PF3 with no preceeding GOLD
;                         
15$:	JMP	INSERT			; process PF3
;
; the rest are processed as escape terminators
;
20$:	JMP	ESCTRM			; process as an escape terminator

	.DSABLE	LSB



	

	.SBTTL	PRTUSL	- Print a String at User Level

;++                       
; PRTUSL
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine prints a string at the terminal from user
;	level. If the output cannot complete (due to a lack of 
;	small buffers, etc.), the FMS field primitives will be
;	reentered at the FMSCNT entry point. The FMSCNT routine
;	will branch to PRTAGN to complete the output.
;
;	This routine must be called from FMSSER or FMSCNT with 
;	nothing on the stack other than the return PC and the
;	registers saved on entry to FMSSER or FMSCNT.
;
; INPUT:
;
;	R0 =  Terminal number * 2
;	R1 -> DDB
;	R5 -> Data area
;
;	I$BCNT(R5) = Number of characters to print
;	140000 + I$PBUF = Start of print buffer
;
; OUTPUT:
;
;	R2, R3, R4 modified
;
;	Print buffer initialized.
;-- 

	.ENABL	LSB

PRTUSL:
	MOV	I$BCNT(R5),R4		; Get number characters to print
	BEQ	20$			; Done if nothing
	MOV	#<140000+I$PBUF>,R3	; Else get pointer to print buffer
	MOV	(SP),FMS.PC(R5)		; Save return PC
10$:	MAP	PUSH,APR=6,DATA		; Save DPAR6 mapping		;009
	MAP	TERAP6,APR=6,CODE,DATA	; Map class driver		;009
	CALLX	CHKFRE			; Check for buffers		;009
	MAP	POP,APR=6,DATA		; Restore DPAR6 mapping		;009
	BCS	30$			; No buffers, stall		;009
	CALL	FMSCHR			; Print the character		;009
	BCC	10$			; More characters, process them	;011
20$:	INITBF				; Initialize the print buffer	;009
	RETURN				; And go back there

30$:	MOV	R3,@#140000+FMS.R3 	; Save buffer pointer for re-do	;009
	MOV	R4,@#140000+FMS.R4 	; And byte count		;009
	MOVB	JOB,R4			; Get caller's job # * 2	;009
	CLR	JBSTAT(R4)		; Put job into			;009
	MOV	#JSTEL,JBWAIT(R4) 	;  a terminal output wait	;009
	MAP	TERAP6,APR=6,CODE,DATA	; Map the class driver		;009
	SPLC	5			; Lock out interrupts		;009
	CALLX	CHKLIN			;;Start up any output		;009
	SPLC	3			;;Enable interrupts		;009
	JMPX	IOREDO			; And stall for I/O redo	;009

;
; Entry point to complete an output operation from user level
;

PRTAGN: MOV	R1,R5			; Copy DDB pointer		;009
	ADD	TTFMSB,R5		; Point to FMS buffer		;009
	MAP	(R5),APR=6,DATA		; Map the FMS buffer again	;009
	MOV	#140000,R5		; Restore buffer pointer
	MOV	FMS.PC(R5),-(SP)	; Set the return address
	MOV	FMS.R3(R5),R3		; Get updated string pointer
	MOV	FMS.R4(R5),R4		; Get updated string length
	BR	10$			; Try it again

	.DSABL	LSB
	
GLOBAL	<FMSAP5>

	.SBTTL	PRTSTR	- Print a String at Interrupt Level

;++
; PRTSTR
;
; FUNCTIONAL DESCRIPTION:                                                   
;
;	This routine prints a string at the terminal. It
;	is used by the interrupt service routines.
;
;	This routine ensures that all strings printed at
;	interrupt level are mapped via APR 6. Strings passed
;	to this routine may be mapped via either APR 5 (if 
;	fixed text in the primitives) or APR 6 if the string
;	is stored in the FMS data area.
;
; INPUT:
;
;	R3 -> String
;	R4 =  0 if ASCIZ string, else character count
;	R5 -> Data area                                                     
;
; IMPLICIT INPUT:
;               
;	KBN(R5) = Terminal number * 2
;	DDB(R5) = DDB address
;
; OUTPUT:
;
;	All registers preserved.
;--

	.ENABL	LSB

PRTSTR:
	$SAV50				; Save all registers
	MOV	KBN(R5),R0		; Get terminal number * 2
	MOV	DDB(R5),R1		; Get DDB address
10$:	CALL	FMSCHR			; Output a character		;009
	BCC	10$			; More to do			;011
	RETURN				; And we're done		;009

.DSABL	LSB

.SBTTL	FMSCHR	Send a FMS character to the RSTS terminal driver

;+
; FMSCHR - SEND AN FMS CHARACTER
;
;	R3 -> Character to output (may be mapped)
;	R4 =  Zero to not check byte count, else remaining byte count
;
;	CALL	FMSCHR
;
;	R3 -> Just past character output
;	R4 =  R4 - 1 (unless it was zero, in which case it is unchanged)
;
;	C = 0 means that caller should call again for more data
;	C = 1 means that all output is finished
;-

	.ENABL	LSB

FMSCHR:	MOVB	(R3)+,R2		; Get the character to output	;009
	MOV	R3,-(SP)		; Save buffer pointer		;011
	MAP	PUSH,APR=6,DATA		; and DPAR6 mapping		;011
	TST	R2			; Is this a null?		;011
	BEQ	10$			; Yes, go start the line	;009
	MOV	R4,-(SP)		; Save byte count		;011
	MAP	TERAP6,APR=6,CODE,DATA	; Map the class driver		;011
	SPLC	5			; Lock out terminal interrupts	;009
	CALLX	CHROUT			;;Output the character		;009
	SPLC	3			;;Enable interrupts		;009
	MOV	(SP)+,R4		; Restore byte count		;011
	BEQ	20$			; Not counting, get out (C=0 from SPLC) ;009
	DEC	R4			; Count another character	;009
	BNE	20$			; More to do, get out (C=0 from SPLC) ;009
10$:	MOV	R4,-(SP)		; Save updated byte count 	;011
	MAP	TERAP6,APR=6,CODE,DATA	; Map the class driver		;011
	SPLC	5			; Lock out interrupts		;011
	CALLX	CHKLIN			;;Get that output going		;009
	MOV	#PR3!C,@#PS		;;Enable interrutps and set C	;009
	MOV	(SP)+,R4		; Restore byte count		;011
20$:	MAP	POP,APR=6,DATA		; Restore buffer mapping	;011
	MOV	(SP)+,R3		; And buffer pointer		;011
	RETURN				; All done now			;009

	.DSABL	LSB

GLOBAL	<TERAP6>

	.SBTTL	PRTZST	- Print an ASCIZ String at Interrupt Level

;++
; PRTZST
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine prints an ASCIZ string at the terminal at
;	interrupt level.
;
; INPUT:
;                                                                      
;	R3 -> ASCIZ string
;	R5 -> Data area
;
; OUTPUT:
;
;	All registers preserved.
;--

	.ENABL	LSB
PRTZST:
	MOV	R4,-(SP)		; Save R4
	CLR	R4			; Indicate ASCIZ string
	PRTSTR				; Print the string
	MOV	(SP)+,R4		; Restore R4
	RETURN				;
	.DSABL	LSB

	.SBTTL	PRTBYT	- Print a Byte at Interrupt Level

;++
; PRTBYT
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine prints a byte at the terminal. It is used
;	from the interrupt service routines.
;
; INPUT:
;
;	R2 =  Character to output in low byte
;	R5 -> Data area
;
; IMPLICIT INPUT:
;
;	KBN(R5) = Terminal number * 2
;	DDB(R5) = DDB address
;
; OUTPUT:
;
;	All registers preserved.
;--

	.ENABL	LSB
PRTBYT:
	$SAV50				; Save all registers
	MOV	KBN(R5),R0		; Get terminal number * 2
	MOV	DDB(R5),R1		; Get DDB address
	MAP	PUSH,APR=6,DATA		; Save DPAR6 mapping		;009
	MAP	TERAP6,APR=6,CODE,DATA	; Map the class driver		;009
	SPLC	5			; Lock out interrupts		;009
	CALLX	CHROUT			;;Output the character (binary)	;009
	CALLX	CHKLIN			;;Start the output going	;009
	SPLC	3			;;Enable interrupts		;009
	MAP	POP,APR=6,DATA		; Restore DPAR6 mapping		;009
	RETURN				;And exit			;009

GLOBAL	<TERAP6>							;009

.DSABL	LSB

	.SBTTL	STRBYT	- Store a Character in the Print Buffer

;++
; STRBYT
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine stores a character in the print buffer to be
;	printed at the terminal.
;
; INPUT:
;               
;	R2 =  Character to print in low byte
;	R5 -> Data area
;
;	I$BCNT(R5) =  Number of characters in print buffer
;	I$BPTR(R5) -> Next position in print buffer
;
; OUTPUT:
;
;	All registers preserved.
;--

	.ENABL	LSB
STRBYT:
	CMP	I$BCNT(R5),#I$PBLN	; Buffer full
	BEQ	10$			; If so ignore output
	MOVB	R2,@I$BPTR(R5)		; Else store character in buffer
	INC	I$BPTR(R5)		; Update buffer pointer
	INC	I$BCNT(R5)		; Update character count
10$:	RETURN				;
	.DSABL	LSB

	.SBTTL
	.SBTTL
