;  DEC/CMS REPLACEMENT HISTORY, Element LSTNG.MAC
;  *5     2-SEP-1987 14:40:20 STEVENS "CHANGED .ENABL/.DSABL HEX COMMAND TO .LIST/.NLIST HEX"
;  *4     2-SEP-1987 14:38:42 STEVENS "CHANGED .ENABL/.DSABL HEX COMMAND TO .LIST/.NLIST HEX"
;  *3    18-AUG-1986 11:23:25 WORRALL "Complete HEX listing support for version 5.5 fieldtest"
;  *2    14-APR-1986 23:29:44 SYSTEM "Update 5.4 of MACRO-11"
;  *1    28-MAR-1986 02:39:43 SYSTEM "Load MACRO-11 sources from V5.3"
;  DEC/CMS REPLACEMENT HISTORY, Element LSTNG.MAC
	.NLIST							;Edit Level 02
	.ENABL	LC,GBL
	.LIST
	.TITLE	LSTNG - Assembly listing routines
	.SBTTL	LSTNG - Assembly listing routines
	.SBTTL
	.SBTTL		.IDENT	/V05.05/
	.SBTTL
	.IDENT	/V05.05/
;****************************************************************************
;*									    *
;*                   COPYRIGHT (c)  1983, 1986                              *
;*          BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.                *
;*                   ALL RIGHTS RESERVED.                                   *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED  *
;*  ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE  *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER  *
;*  COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY  *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY  *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE  *
;*  AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT  *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS  *
;*  SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.		    *
;*									    *
;****************************************************************************


;++
;  Facility:	MACRO-11  The PDP-11 macro assembler for RT/RSX/VMS and RSTS/E
;
;    Author:	Too many people to list here
;
;   Created:	From the dust and dirt
;
;  Abstract:	LSTNG - Assembly listing routines
;
;     Externals	 Description
;     ---------	 -----------
;
;      Edit	Who	Date		Description of modification
;      ----	---	----		---------------------------
;	001	Jrw	27-Jul-83	Update for 8-bit support.
;	002	Jrw	12-Dec-85	Add HEX support conditionalized.
;--


	PURE	PUREI,I		;++017

;+
; **-SETPF0-SET PRINT FIELD ZERO
; **-SETPF1-SET PRINT FIELD ONE
; **-SETWDB=SET WORD OR BYTE
; **-SETWRD-SET WORD
; **-SETBYT-SET BYTE
;-

.IF	DF,RT11			;If RT-11
	.MCALL	.PRINT
.ENDC;	DF,RT11			;If RT-11


SETPF0::MOV	CLCFGS,PF0	;SET CURRENT LOCATION FLAGS
	BISB	#100,PF0+1	;ASSUME WORD
	MOV	CLCLOC,PF0+2	;SET LOCATION
	RETURN
SETPF1::MOV	MODE,PF1	;SET MODE OF CURRENT VALUE
	BISB	#100,PF1+1	;ASSUME WORD
	MOV	VALUE,PF1+2
	RETURN
SETWDB::TST	(R1)		;POSITIVE?
	BMI	SETBYT		;  NO, BYTE
SETWRD::MOV	R1,-(SP)	;STACK INDEX
	MOV	2(R1),R1	;GET ACTUAL VALUE
.IF	DF,YHEX
	BIT	#LC.HEX,LCMASK	;Hex listing?
	BEQ	SETWDH		;Branch if so
.ENDC;	DF,YHEX
	MOVB	#DIG.0/2,(R2)	;SET PRIMITIVE
	ASL	R1
	ROLB	(R2)+		;MOVE IN BIT
	MOV	#5,R0
	BR	SETBYX

SETBYT::MOV	#SPACE,R0
	MOVB	R0,(R2)+	;PAD WITH SPACES
	MOVB	R0,(R2)+
	MOVB	R0,(R2)+
SETBYZ::MOV	R1,-(SP)	;STACK INDEX
	MOVB	2(R1),R1	;GET VALUE
.IF	DF,YHEX
	BIT	#LC.HEX,LCMASK	;Hex mode?
	BEQ	SETBYH		;Branch if so
.ENDC;	DF,YHEX
	SWAB	R1		;MANIPULATE TO LEFT HALF
	RORB	R1		;GET THE LAST GUY
	CLC
	ROR	R1
	MOV	#3,R0
SETBYX:	SWAB	R0
	ADD	#3,R0
	MOVB	#DIG.0/10,(R2)
1$:	ASL	R1
	ROLB	(R2)
	DECB	R0
	BGT	1$
	TSTB	(R2)+
	SWAB	R0
	SOB	R0,SETBYX
	MOV	(SP)+,R1
	RETURN

.IF	DF,YHEX
.ENABL LSB

SETWDH:	SEC
30$:	MOV	#4003,R0	;Initialize R0
40$:	ROL	R1		;Shift out a bit
	BEQ	100$		;Branch if done
	ROL	R0		;Roll in the bit
	BPL	40$
	CMPB	#'9,R0		;Still a digit?
	BHIS	50$		;Yes (C=0)
	ADD	#'A-'9-1,R0	;Convert to a-f (c=0)
50$:	MOVB	R0,(R2)+	;Store character
	BR	30$

SETBYH:	SWAB	R1		;Move data to high byte
	CLRB	R1
	BIS	#200,R1		;Set bit to terminate loop
	BR	30$		;and convert

100$:	MOV	(SP)+,R1
	RETURN

.DSABL LSB
.ENDC;	DF,YHEX

	.PSECT	IMPLIN,D,GBL,RW
PF0::	.BLKW	2
PF1::	.BLKW	2
	PURE	PUREI,I

;+
; **-PUTKB-LIST ON KB
; **-PUTLP-LIST ON LP
; **-PUTKBL-LIST ON KB AND LP
; **-PUTLIN-OUTPUT LINE
;-

PUTKB::	MOV	#LST.KB,LSTREQ	;SET REQUEST
	BR	PUTLIN
PUTKBL::MOV	#LST.KB,LSTREQ	;SET REQUEST
PUTLP::	BISB	LSTDEV,LSTREQ	;SET LP REQUEST
PUTLIN::SAVREG			;SAVE REGISTERS
	MOV	R0,R1		;ARG TO R1
	MOVB	LSTREQ,R4	;GET REQUEST
	CLR	LSTREQ		;CLEAR IT
	TST	R4
	BEQ	PUTLI9		;JUST EXIT IF EMPTY
	BGT	PUTLI2		;OMIT HEADER IF NOT LISTING
	DEC	LPPCNT		;YES, DECREMENT COUNT
	BGT	PUTLI2		;SKIP IF NOT TIME

PUTLI1:	MOV	LINPPG,LPPCNT	;Reset lines counter to the default
	MOV	R1,-(SP)	;STACK CURRENT POINTER
	MOV	TTLBRK,R2	;GET END OF PRESET TITLE
	TST	PASS
	BEQ	11$
	MOV	#PAGMNE,R1
	MOVBYT			;MOVE "PAGE" INTO POSITION
	MOV	PAGNUM,R1
	DNC			;CONVERT TO DECIMAL
	INC	PAGEXT
	BEQ	11$
	MOVB	#'-,(R2)+	;SET SEPARATOR
	MOV	PAGEXT,R1	;GET CURRENT PAGE EXTENSION NUMBER
	DNC			;CONVERT TO DECIMAL
11$:	CLRB	(R2)
	PUTLP	#TTLBUF		;PRINT TITLE

.IF	DF,RT11			;If RT-11
	MOVB	#20014, FFLOC	;(EGP) MAKE IT FF NOW
	MOVB	#20014, TTLBUF	;(EGP) FORCE IT!
.ENDC;	DF,RT11			;If RT-11

	PUTLP	#STLBUF		;  SUB-TITLE,
	PUTLP	#CRLF		;  AND A BLANK LINE
	MOV	(SP)+,R1
PUTLI2:				;++014
	MOV	R1,R2		;++015 USE THE TEXT BUFFER AS OUTPUT BUFFER
	MOV	R2,R3		;SAVE A COPY
21$:	MOVB	(R1)+,(R2)+	;MOVE CHARACTER TO OUTPUT BUFFER
	BGT	21$		;LOOP IF NOTHING SPECIAL
	MOVB	-1(R2),R0	;Find out what it was
	BEQ	28$		;End if null
	CMPB	R0,#200		;Flag for invalid character?
	BNE	21$		;If not, go on
	DEC	R2		;Move destination back one too!
	MOVB	#'?,-(R1)	;Illegal character, replace with "?"
	BR	21$

28$:	DEC	R2		;Adjust pointer to EOL
22$:	CMP	R2,R3		;AT BEGINNING?
	BEQ	24$		;  YES, DON'T RETREAT
	CLR	R0		;Clear for BISB
	BISB	-(R2),R0	;Fetch preceding character
	BITB	#CT.SPT,CTTBL(R0);SPACE OR TAB?
	BNE	22$		;  YES, TRIM IT
	INC	R2		;R2 -> Past last character in buffer
24$:	CLRB	@R2		;.ASCIZ please - for possible .PRINT
	SUB	R3,R2		;COMPUTE CHARACTER COUNT

	.IF LT	LSTLEN-<SRCLEN+40.>  ;++015
	CMP	R2,#LSTLEN	;++015 IS OUTPUT LARGER THAN ALLOWABLE?
	BLE	30$		;++015 BRANCH IF NOT
	MOV	#LSTLEN,R2	;++015 ELSE, RESET OUTPUT LENGTH
30$:				;++015
	.ENDC			;++015

.IF	NDF,RT11		;If not RT-11

	MOV	R2,@CNTTBL+LSTCHN	;SET COUNT
	ASR	R4		;KB REQUESTED?
	BCC	25$		;  NO
	MOV	R3,BUFTBL+CMOCHN  ;++015 SET OUTPUT BUFFER POINTER
	$WRITE	CMO		;++014 SEND LINE TO COMMAND OUTPUT
25$:	ASR	R4		;LISTING REQUESTED?
	BCC	PUTLI9		;  NO
	MOV	R3,BUFTBL+LSTCHN  ;++015 SET OUTPUT BUFFER POINTER
	$WRITE	LST		;LIST IT
PUTLI9:	RETURN

	.PSECT	IMPURE,D,RW	;++017
LSTREQ::.BLKW	1		;LIST REQUEST FLAGS
LSTDEV::.BLKB	2		;ERROR(LH), LISTING (RH)

.IFF;	NDF,RT11		;If not RT-11

	ASR	R4		;KB REQUESTED?
	BCC	25$		;  NO
	.PRINT	R3		;Print string -> by R3.
25$:	ASR	R4		;LISTING REQUESTED
	BCC	PUTLI9		;  NO
	TST	R2		;Anything to stuff into buffer?
	BEQ	50$		;Branch if not, don't do it!
	CALL	100$		;Go write it out.
50$:	MOV	#CRLF2,R3	;R3 -> <CR><LF>
	MOVB	(R3)+,R2	;R2  = Count (2)
	CALLR	100$		;Stuff in a <CR><LF> too, return to caller.

100$:	MOV	R3,LSTDAT+2	;Stuff -> to buffer
	MOV	R2,LSTDAT	;Set count	(@CNTTBL+LSTCHN)
	MOV	#LSTCHN,R0	;R0 -> Channel #
	CALL	$WRITE		;Write it in!
PUTLI9:	RETURN			;Return to caller.

.ENDC;	NDF,RT11		;If not RT-11

	.PSECT	MIXED,RW,D

CRLF:	.ASCIZ	//		;and a CRLF via a zero string.
.EVEN
	PURE	TXTBYT,D
PAGMNE:	.ASCIZ	/  Page /	;The page count header
CRLF2:	.BYTE	2
	.ASCII	<CR><LF>


	.END
