;  DEC/CMS REPLACEMENT HISTORY, Element EXPRS.MAC
;  *6    21-JUL-1987 14:09:05 STEVENS "FIX DECIMAL nnn. FORM WHEN IN HEX RADIX"
;  *5    20-AUG-1986 14:40:24 WORRALL "Add ^X temporary radix switch operator"
;  *4    20-AUG-1986 00:57:51 WORRALL "Correct infinite loop due to HEX numbers in CVTNUM"
;  *3    18-AUG-1986 11:19:52 WORRALL "Complete HEX listing support for version 5.5 fieldtest"
;  *2    14-APR-1986 23:20:39 SYSTEM "Update 5.4 of MACRO-11"
;  *1    28-MAR-1986 02:35:44 SYSTEM "Load MACRO-11 sources from V5.3"
;  DEC/CMS REPLACEMENT HISTORY, Element EXPRS.MAC
	.NLIST							;Edit Level 03
	.ENABL	LC,GBL
	.LIST
	.TITLE	EXPRS - Main expression processing
	.SBTTL	EXPRS - Main expression processing
	.SBTTL
	.SBTTL		.IDENT	/V05.05/
	.SBTTL
	.IDENT	/V05.05/
;****************************************************************************
;*									    *
;*                   COPYRIGHT (c)  1983, 1986                              *
;*          BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.                *
;*                   ALL RIGHTS RESERVED.                                   *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED  *
;*  ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE  *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER  *
;*  COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY  *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY  *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE  *
;*  AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT  *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS  *
;*  SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.		    *
;*									    *
;****************************************************************************


;++
;  Facility:	MACRO-11  The PDP-11 macro assembler for RT/RSX/VMS and RSTS/E
;
;    Author:	Too many people to list here
;
;   Created:	From the dust and dirt
;
;  Abstract:	EXPRS - Main expression processing
;
;     Externals	 Description
;     ---------	 -----------
;
;      Edit	Who	Date		Description of modification
;      ----	---	----		---------------------------
;	001	Jrw	25-Jul-83	Update for 8-bit support
;	002	Jrw	15-Jul-84	Correct ABS psect FOO==.-BAR bug
;					reported by RSTS/KONING.
;	003	Jrw	20-Aug-86	Prevent infinite loop to CVTNUM
;					on decode of hex number when not
;					in RADIX 16.
;	004	Jrw	20-Aug-86	Add ^X radix switch operand.
;--


	PURE	PUREI,I

;+
; **-GLBTRM-GLOBAL TERM
; **-GLBEXP-GLOBAL EXPRESSION
; **-RELTRM-RELATIVE TERM
; **-RELEXP-RELATIVE EXPRESSION
; **-RELTST-RELATIVE TEST
; **-ABSTRM-ABSOLUTE TERM
; **-ABSEXP-ABSOLUTE EXPRESSION
; **-ABSTST-ABSOLUTE TEST
; **-ABSERF-SET ADDRESS ERROR FLAG
;-


GTRMI:	CALL	TERMI		;INTERNAL ENTRY TO GET GLOBAL TERM
	CALL	SETXPR		;RESTORE EXPRESSION MODE REGISTERS
	TST	R0		;TEST SUCCESS/FAIL
	BR	GTRMCK		;BRANCH INTO COMMON CODE

GLBEXP::EXPR			;GLOBAL EXPRESSION
	BR	GTRMCK		;Now validate the global expression.

GLBTRM::TERM			;GLOBAL TERM
GTRMCK:				;REF LABEL TO VALIDATE TERM
	BEQ	ABSERR
	BR	ABSERX

;;;GEXPCK:				;INTERNAL ENTRY TO VALIDATE EXPR
;;;	BEQ	ABSERR
;;;	BIT	#CPXFLG,FLAGS	;++001 IS EXPRESSION COMPLEX?
;;;	BEQ	ABSERX		;++001 NO, JUST LEAVE
;;;	CMP	#RLDLEN-2,CPXSTL ;++001 YES, IS THE COMPLEX STRING TOO LONG...
;;;				;++001 ... FOR A SINGLE RLD RECORD?
;;;	BLT	ABSERR		;++001 YES, FLAG EXPRESSION IN ERROR
;;;	BR	ABSERX

RELTRM::GLBTRM			;RELATIVE TERM
	BR	RELTST
RELEXP::GLBEXP			;RELATIVE EXPRESSION
RELTST::BITB	#CPXFLG!GLBFLG,FLAGS	;++001 EXPR CAN'T BE COMPLEX OR GLOBAL
	BEQ	ABSERX
	BR	ABSERR
ABSTRM::GLBTRM			;ABSOLUTE TERM
	BR	ABSTST
ABSEXP::GLBEXP			;ABSOLUTE EXPRESSION
ABSTST::BITB	#CPXFLG!GLBFLG!RELFLG,FLAGS ;++001 EXPR MUST BE ABSOLUTE
	BEQ	ABSERX
ABSERR::CLR	MODE		;
	CLR	RELLVL
	CALL	ZAPCPX		;++001 CLEAR CPXROL & INIT STRING LENGTH
ABSERF:	ERROR	A
ABSERX:	MOV	VALUE,R0	;RETURN WITH VALUE IN R0
	RETURN


ABXTST:	BITB	#RELFLG,FLAGS	;++019 IS EXPRESSION RELOCATABLE?
	BNE	SETCPX		;++019 YES, ABSOLUTE TEST FAILS
REXTST:	BITB	#GLBFLG!CPXFLG,FLAGS ;++001 IS EXPR GLOBAL OR COMPLEX?
	BEQ	CPXRTN		;++001 YES, CONTINUE EVALUATING IT
SETCPX:	BISB	#CPXFLG,FLAGS	;++001 SET COMPLEX RELOCATION EXPRESSION
CPXRTN:	RETURN			;++001

;+
; **-EXPR-EXPRESSION EVALUATION
;-

EXPR::	SAVREG			;SAVE REGISTERS
EXPI:	CALL	TERMI		;GET FIRST TERM
	TST	R0		;TEST RESULT
	BEQ	5$		;EXIT IF NULL
	CLR	-(SP)		;NON-NULL, SET REGISTER FLAG STORAGE
1$:	SETXPR			;SET EXPRESSION REGISTERS
	BIS	(R3),(SP)	;SAVE REGISTER FLAG
	CHSCAN	BOPTBL		;SCAN THE BINARY OPERATOR TABLE
	BEQ	2$		;  BRANCH IF NOT FOUND
	CALL	10$		;FOUND, CALL HANDLER
	BR	1$		;TEST FOR MORE
2$:	BIC	#-1-REGFLG,(SP)	;MASK ALL BUT REGISTER FLAG
	BEQ	6$		;BRANCH IF NOT REGISTER
	BIT	#177770,(R4)	;IN BOUNDS?
	BNE	7$		;  NO, ERROR
6$:	ASR	RELLVL		;TEST RELOCATON LEVEL
	BNE	3$		;BRANCH IF NOT 0 OR 1
	BCC	4$		;BRANCH IF 0
	TST	(SP)		;RELOCATABLE, TEST REGISTER FLAG
	BEQ	4$		;BRANCH IF NOT SET
7$:	ERROR	R		;REL AND REG, ERROR
	CLR	(SP)		;CLEAR REGISTER BIT
	BR	4$
3$:	BISB	#CPXFLG,(R3)	;++001 SET COMPLEX RELOCATION EXPRESSION
4$:	BIS	(SP)+,(R3)	;MERGE REGISTER BIT
	SETNZ	R0		;SET TRUE
5$:	RETURN
10$:	MOV	#STXOPC,-(SP)	;++001 RETURN THRU COMPLEX OPCODER ROUTINE
	MOV	R0,-(SP)	;++001 STACK OPERATOR ROUTINE ADDRESS
	MOV	(R1)+,-(SP)	;STACK SYMBOL
	MOV	(R1)+,-(SP)
	MOV	(R1)+,-(SP)	;  MODE,
	MOV	(R1)+,-(SP)	;  VALUE,
	MOV	(R1)+,-(SP)	;  AND REL LEVEL
	CALL	STKCHK		;CHECK FOR STACK OVERFLOW		;CD056
	CALL	GTRMI		;GET NEXT TERM
	MOV	#EXPBAK+10.,R3	;POINT TO EXPRESSION SCRATCH AREA
	MOV	(SP)+,-(R3)	;UNSTACK PREVIOUS RELOCATION LEVEL,
	MOV	(SP)+,-(R3)	;	VALUE,
	MOV	R3,R2		;LEAVE R2 POINTING TO PREVIOUS VALUE
	MOV	(SP)+,-(R3)	;	MODE (FLAGS & PSECT),
	MOV	(SP)+,-(R3)	;	AND SYMBOL.
	MOV	(SP)+,-(R3)	;
	CMPB	-(R2),-(R4)	;++019 ARE PSECT'S THE SAME?
	BEQ	100$		;++019 YES, PSECT TEST SUCCESS

;;;	BITB	#RELFLG,-1(R2)	;Is first value ABS (Constant)?
;;;	BEQ	100$		;Branch if so, not complex.
;;;	BITB	#RELFLG,-1(R4)	;Is second value ABS (Constant)?
;;;	BEQ	100$		;Branch if so, also not complex.

	TSTB	@R2		;Is first value a constant? (Section #0)
	BEQ	100$		;Branch if so, PSECT test succeeds
	TSTB	@R4		;Is second value a constant? (Section #0)
	BEQ	100$		;Branch if so, PSECT test succeeds
	CALL	SETCPX		;++019 ELSE, EXPRESSION WILL BE COMPLEX
100$:	CMPB	(R2)+,(R4)+	;++019 RESTORE REGISTERS
	ASR	(SP)		;IS OPERATOR FOR ABSOLUTE VALUES ONLY?
	BCS	12$		;  NO
	MOVB	-(R2),-(R4)	;Copy SECTOR value
	BISB	-(R2),-(R4)	;Merge FLAGS value
;;;	BIS	-(R2),-(R4)	;MERGE ATTRIBUTES AND PSECT NUMBERS
	CALL	ABXTST		;++001 COMPLEX IF BOTH NOT ABSOLUTE
	CMP	(R2)+,(R4)+	;RESTORE REGISTERS
12$:	ASL	(SP)		;RESTORE DISPATCH ADDRESS
	JMP	@(SP)+		;DISPATCH TO BINARY OPERATOR FUNCTION

.IF	NDF,RT11		;If NOT RT-11

	.PSECT	IMPURE,D,RW	;++017
EXPBAK:	.BLKW	5		;PREVIOUS TERM STORAGE

.ENDC;	NDF,RT11		;If NOT RT-11

	PURE	DPURE,D		;++017
BOPTBL:				;BINARY OP TABLE
	GCHTBL	CH.ADD,	BOPADD+1	; "+"
	GCHTBL	CH.SUB,	BOPSUB+1	; "-"
	GCHTBL	CH.MUL,	BOPMUL		; "*"
	GCHTBL	CH.DIV,	BOPDIV		; "/"
	GCHTBL	CH.AND,	BOPAND		; "&"
	GCHTBL	CH.IOR,	BOPIOR		; "!"
	.WORD	0
	PURE	PUREI,I		;++017

BOPSUB:	CALL	REXTST		;++001 TEST FOR COMPLEX EXPRESSION
	NEG	(R4)		; -, NEGATE VALUE
	NEG	RELLVL		;  AND RELLVL
	MOV	#CPXSUB*400!CPXOPC,R0 ;++001 SET COMPLEX OPCODE FOR SUB
	BR	ADDX		;++001 BRANCH INTO COMMON CODE
BOPADD:	MOV	#CPXADD*400!CPXOPC,R0 ;++001 SET COMPLEX OPCODE FOR ADD
ADDX:	ADD	(R2)+,(R4)+	;++001 + ADD VALUES
	ADD	(R2),(R4)	;  AND RELOCATION LEVELS
	CMP	-(R2),-(R4)	;POINT BACK TO VALUES
	BIT	#177400!GLBFLG!CPXFLG,-(R2)  ;First value constant?
	BEQ	3$		;Branch if so, consider addition done
	BIT	#177400!GLBFLG!CPXFLG,-(R4)  ;Second value constant?
	BEQ	4$		;Branch if so, use attributes of first value
;;;	BIT	#RELFLG!GLBFLG!CPXFLG,-(R2)  ;++019 FIRST VALUE CONSTANT?
;;;	BEQ	3$		;++019 YES, CONSIDER ADDITION DONE
;;;	BIT	#RELFLG!GLBFLG!CPXFLG,-(R4)  ;++019 SECOND VALUE CONSTANT?
;;;	BEQ	4$		;++019 YES, USE ATTRIBUTES OF FIRST VALUE
	BISB	(R2),(R4)	;++019 NO CONSTANTS--MERGE ATTRIBUTES
	CALL	REXTST		;++019 COMPLEX IF ANY GLOBALS
	TST	RELLVL		;CHECK RELOCATION LEVEL
	BNE	3$
	BITB	#CPXFLG!GLBFLG,(R4)  ;++019 IS EXPR GLOBAL OR COMPLEX?
	BNE	3$		;++019 YES, LEAVE
	BIC	#177400!RELFLG,(R4) ;Make ABS and Sector #0
3$:	RETURN

4$:	MOV	(R3)+,(R1)+	;TRANSFER PREVIOUS SYMBOL NAME
	MOV	(R3)+,(R1)+	;
	BISB	(R3)+,(R1)+	;Merge flags attributes, but
	MOVB	(R3)+,(R1)+	; copy SECTOR number
	RETURN


BOPAND:	COM	(R2)
	BIC	(R2),(R4)
	MOV	#CPXAND*400!CPXOPC,R0 ;++001 SET COMPLEX OPCODE FOR AND
	RETURN
BOPIOR:	BIS	(R2),(R4)
	MOV	#CPXIOR*400!CPXOPC,R0 ;++001 SET COMPLEX OPCODE FOR OR
	RETURN
BOPMUL:	MOV	(R2),R0		;FETCH FIRST ARGUMENT
	MOV	#CPXMUL*400!CPXOPC,-(SP) ;++001 STK COMPLEX OPCODE FOR MULT
	MOV	R0,-(SP)	;SAVE A COPY
	BPL	1$		;POSITIVE?
	NEG	R0		;  NO, MAKE IT SO
1$:	MOV	(R4),R3		;SET SECOND ARG
	BPL	2$		;BRANCH IF POSITIVE
	NEG	R3		;NEGATIVE, MAKE IT +
	COM	(SP)		;TOGGLE RESULT SIGN
2$:	MUL	R3,R0		;MULTIPLY
	MOV	R1,R0		;SET FOR EXIT
	BR	BOPDVX		;EXIT THROUGH DIVIDE
BOPDIV:	MOV	(R4),R3		;SET DIVISOR
	MOV	#CPXDIV*400!CPXOPC,-(SP) ;++001 STK COMPLEX OPCODE FOR DIV
	MOV	R3,-(SP)	;SAVE A COPY
	BPL	1$		;BRANCH IF PLUS
	NEG	R3		;MAKE IT THUS
1$:	MOV	(R2),R1		;SET QUOTIENT
	BPL	2$		;AGAIN!!!
	NEG	R1
	COM	(SP)
2$:	CLR	R0		;OPERATE
	DIV	R3,R0
BOPDVX:	TST	(SP)+		;TEST RESULT
	BPL	1$		;  OK AS IS
	NEG	R0		;NO, NEGATE IT
1$:	MOV	R0,(R4)		;SET RESULT
	MOV	(SP)+,R0	;++001 SET THE COMPLEX OPCODE
	RETURN

;+
; **-TERM-TERM EVALUATION
;-

TERM::	SAVREG			;SAVE REGISTERS
TERMI:				;REF LABEL FOR INTERNAL ENTRY
	SETXPR			;  AND SET "EXPRESSION" TYPE
	CLR	(R3)		;CLEAR MODE
	CLR	(R4)		;  AND VALUE
	CALL	TERM10		;PROCESS
	BIC	#DEFFLG!LBLFLG!MDFFLG,(R3)	;CLEAR EXTRANEOUS
	CLR	RELLVL		;ASSUME ABSOLUTE
	BIT	#RELFLG,(R3)	;TRUE?
	BEQ	1$
	INC	RELLVL		;  NO, RELOCATABLE
1$:	INC	EXPFLG		;MARK AS EXPRESSION
	JMP	SETNB		;EXIT WITH NON-BLANK AND R0 SET
TERM10:	GETSYM			;TRY FOR A SYMBOL
	BEQ	TERM20		;BRANCH IF NOT A SYMBOL
	CMP	SYMBOL,#^R.  	;LOCATION COUNTER?
	BEQ	14$		;  YES, TREAT SPECIAL
	SSRCH			;SEARCH THE HASH SYMBOL TABLE		;JR
	BEQ	16$		;BRANCH IF NOT FOUND
	BIT	#NCRFLG,@R3	;Is this symbol set .NOCRF?
	BEQ	8$		;Branch if not, cross ref it then.
	BIC	#NCRFLG,@R3	;Else turn off flag in working area
	BR	10$		; and continue

8$:	CALL	CRFREF		;Cref a reference
10$:
	BIT	#MDFFLG,(R3)	;MULTIPLY DEFINED?
	BEQ	11$		;  NO
	ERROR	D		;++012 ERROR-REF TO MULTI-DEFINED LABEL
11$:	BIT	#DEFFLG,(R3)	;DEFINED?
	BNE	12$		;  YES
	BIT	#GLBFLG,(R3)	;NO, GLOBAL?
	BNE	TERM28		;IF NE YES--COMPLETE TERM PROCESSING
	ERROR	U		;NO, UNDEFINED ERROR
12$:	BIC	#GLBFLG,(R3)	;CLEAR INTERNAL GLOBAL FLAG
	BR	TERM28		;COMPLETE TERM PROCESSING

14$:	MOV	#CLCNAM,R1	;DOT, MOVE TO WORKING AREA
	MOV	#SYMBOL,R2
	CALL	XMIT4
	BICB	#^C<RELFLG>,(R3) ;++017 CLEAR ALL BUT RELOCATION FLAG
	BR	TERM28
16$:				;++008
	.IF NDF	XOPEXP		;++018

	MOV	SYMVRP,-(SP)	;PRESERVE VIRTUAL HASH TABLE POINTER	;JR+
	CALL	OSRCH		;SEARCH THE OPCODE/MACRO NAME HASH TABLE
	MOV	(SP)+,SYMVRP	;RESTORE USER HASH TABLE POINTER NOW
	TST	(R3)		;TEST IF DEFINED AS OPCODE
	BMI	17$		;YES
	MOV	#SYMLST,ROLNDX	;UNDEFINED, RESET SYMBOL LIST FOR CREF	;JR-

	.ENDC			;++018 (XOPEXP -- NO OPCODES IN EXPRESSIONS)

	CLR	(R3)		;CLEAR ALL SYMBOL MODE BITS
	CLR	(R4)		;AND VALUE
	BIT	#ED.GBL,EDMASK	;AUTO GLOBAL SYMBOL DEFAULT ENABLED?
	BNE	18$		;IF NE NO DEFAULT GLOBALS
	BIS	#DFGFLG!GLBFLG,(R3)  ;ELSE, SET THE FLAGS
	BR	20$		;AND BRANCH TO INSERT ENTRY
18$:				;
	ERROR	U
20$:	CALL	VINSRT		;NOT IN HASH TABLE, INSERT AS UNDEFINED	;JR
	BIT	#ED.GBL,EDMASK	;AUTO GLOBAL ENABLED?
	BEQ	180$		;Branch if so, complete term processing.
17$:	CLR	(R3)		;BE SURE MODE IS ZERO
180$:	CRFREF			;Generate cref reference
	BR	TERM28

TERM20:	MOV	CRADIX,R2	;ASSUME NUMBER IS IN CURRENT RADIX
21$:	CVTNUM			;CONVERT
	BEQ	TERM30		;  NOPE, MISSED AGAIN
	BPL	23$		;NUMBER, ANY OVERFLOW?
	CMP	R2,#16.		;  YES, IS CURRENT RADIX HEX?
	BNE	22$		;       NO, TRUNCATION ERROR
	CMP	R5,#CH.DOT	;	YES, IS NUMBER DECIMAL?
	BEQ	24$		;	     YES, REPARSE IN DECIMAL
22$:	ERROR	T		;	     NO, TRUNCATION ERROR
23$:	CMP	R5,#CH.DOT	;NUMBER, DECIMAL?
	BEQ	24$		;  YES
	.IF NDF	XEDLSB
	CMP	R5,#CH.DOL	;NO, LOCAL SYMBOL?
	BEQ	24$		;  YES
	.ENDC
;+
; Note:
; If the lower byte of R0 <> 0 then CVTNUM is saying that the
; string contained valid numeric characters in the range of
; 0 -> F but that a number or letter in the string was INVALID
; for the CURRENT radix passed in R2.
;
; If the lower byte of R0 is <> 0 then we declare a 'N' error and
; cycle through DECIMAL and HEX radix to properly decode the number.
;
; An infinite loop cannot occur here unless the output of CVTNUM is
; modified.
;-
	TSTB	R0		;NO, ANY NUMBERS OUT OF RANGE?
	BEQ	TERM28		;  NO
	ERROR	N		;YES, FLAG IT

.IF	DF,YHEX
	CMP	R2,#10.		;Time to try DECIMAL?
	BLT	241$		;Branch if so
	MOV	#16.,R2		;Else try again with HEX radix
	BR	242$

.IFF;	DF,YHEX
	BR	241$		;Force DECIMAL radix and re-scan
.ENDC;	DF,YHEX

24$:	CMP	R2,#10.		;"." OR "$", WERE WE DECIMAL?
	BEQ	25$		;  YES
241$:	MOV	#10.,R2		;Else force DECIMAL radix next time
242$:	SETSYM			;NO,
	BR	21$

25$:	CMP	R5,#CH.DOT	;DECIMAL?
	BEQ	TERM27		;  YES
	.IF NDF	XEDLSB
	LSRCH			;NO, LOCAL SYMBOL
	BNE	TERM27		;BRANCH IF FOUND
	.ENDC
TERM26:	ERROR	U		;  NO, FLAG AS UNDEFINED
TERM27:	GETCHR			;BYPASS DOT OR DOLLAR
TERM28:	ADD	#2,CPXSTL	;++001 UPDATE COMPLEX STRING LENGTH FOR CONST
	MOV	(R3),-(SP)	;++001 SAVE FLAGS/SECTOR WORD
	BICB	#^C<RELFLG!GLBFLG>,(R3) ;++001 SAVE ONLY GLOBAL/REL FLAGS
	BEQ	2$		;++001 BRANCH IF TERM IS ABSOLUTE
	BITB	#GLBFLG,(R3)	;++001 IS THE TERM GLOBAL?
	BEQ	1$		;++001 SKIP IF NOT
	INC	CPXSTL		;++001 INCR COMPLEX STRING LENGTH BY 2 MORE...
1$:	INC	CPXSTL		;++001 ... FOR GLOBAL & 1 MORE FOR RELATIVE
2$:	CALL	APPCPX		;++001 PUT ELEMENT IN COMPLEX ROLL
	MOV	(SP)+,(R3)	;++001 RESTORE FLAGS/SECTOR WORD
ALT28:	SETNB			;++001 RETURN POINTING TO NON-BLANK
	SETNZ	R0		;FLAG AS FOUND
TERM29:	RETURN
TERM30:	CHSCAN	UOPTBL		;SCAN UNARY OPERATOR TABLE
	BEQ	TERM29		;  NOT THERE
	CALL	STKCHK		;CHECK FOR STACK OVERFLOW		;CD056
	CLR	R2		;CLEAR FOR FUTURE USE			;**-2
	CALL	(R0)		;FOUND, GO AND PROCESS
	BR	ALT28		;++001 EXIT TRUE VIA ALTERNATE EXIT
									;**-1
	PURE	DPURE,D		;++017
UOPTBL:
	GCHTBL	CH.ADD,	GTRMI	; "+"
	GCHTBL	CH.SUB,	TERM42	; "-"
	GCHTBL	CH.QTM,	TERM44	; """
	GCHTBL	CH.XCL,	TERM45	; "'"
	GCHTBL	CH.PCT,	TERM46	; "%"
	GCHTBL	CH.LAB,	TERM47	; "<"
	GCHTBL	CH.UAR,	TERM50	; "^"
	.WORD	0
	PURE	PUREI,I		;++017

TERM42:	MOV	#1,-(SP)	;++001 INDICATE NEGATE BY 1 ON STACK
	BR	COMTRX		;++001 USE COMMON CODE TO PROCESS
TERM44:	INC	R2		; """, MARK IT
TERM45:	MOV	R4,R1		; "'", SET TEMP STORE REGISTER
	SETSYM			;POINT BACK TO OPERATOR
1$:	CALL	GETCH8		;Get the next character
	BEQ	TERM48		;ERROR IF EOL
	MOVB	R5,(R1)+	;Stuff it away
	DEC	R2		;ANOTHER CHARACTER
	BEQ	1$		;  YES
	BR	TERM27		;BYPASS LAST CHAR

TERM46:	ABSTRM			;REGISTER EXPRESSION
	BIS	#REGFLG,(R3)	;FLAG IT
	RETURN
TERM47:				;LEFT ANGLE BRACKET SEEN
	CALL	EXPI		;EVALUATE EXPRESSION
	CALL	GTRMCK		;Validate the expression.
	CMP	R5,#CH.RAB	;">"?
	BNE	TERM48		;++001 NO, REPORT ERROR
	GETCHR			;++001 YES, BYPASS IT
	BR	ALT28		;++001 EXIT
TERM48:	JMP	ABSERF		;ERROR, FLAG IT
TERM50:	CHSCAN	UARTBL		;"^"-SCAN ON NEXT CHARACTER
	BEQ	TERM48		;  INVALID, ERROR
	JMP	(R0)		;CALL ROUTINE

	PURE	DPURE,D		;++017
UARTBL:				;UP ARROW TABLE
	GCHTBL	LET.C,	TERM51	;  ^C
	GCHTBL	LET.D,	TERM52	;  ^D
	GCHTBL	LET.O,	TERM53	;  ^O
	GCHTBL	LET.B	TERM54	;  ^B
	.IF NDF	XFLTG
	GCHTBL	LET.F,	TERM55	;^F
	.ENDC
	GCHTBL	'R,	TERM56	;++019  ^R
.IF	DF,YHEX
	GCHTBL	'X,	TERM60	;^X (HEX radix)
.ENDC;	DF,YHEX
	.WORD	0
	PURE	PUREI,I		;++017

TERM51:	CLR	-(SP)		;++001 INDICATE COMPLEMENT BY 0 ON STACK
COMTRX:	CALL	GTRMI		;GET GLOBAL TERM
	CALL	ABXTST		;If relocatable, declare complex expr
	COM	(R4)		;++001 COMPLEMENT VALUE
	ADD	(SP),(R4)	;++001 MAKE IT NEGATE IF 1 ON STACK
	NEG	RELLVL		;++001 NEGATE THE RELOCATION LEVEL
	MOV	#CPXOPC*400!CPXCOM,R0 ;++001 SET CPX OPCODE COMPL (BKWDS)
	SUB	(SP)+,R0	;++001 MAKE IT NEGATE IF 1 ON STACK
	SWAB	R0		;++001 STRAIGHTEN OUT THE BYTES
	BR	STXOPC		;++001 STORE OPCODE IN CPXROL

.IF	DF,YHEX
TERM60:	ADD	#6.,R2		;HEX radix
.ENDC;	DF,YHEX
TERM52:	ADD	#2.,R2		;DECIMAL radix
TERM53:	ADD	#6.,R2		;OCTAL radix
TERM54:	ADD	#2.,R2		;BINARY radix

	MOV	CRADIX,-(SP)	;STACK CURRENT RADIX
	MOV	R2,CRADIX	;REPLACE WITH LOCAL
	CALL	GTRMI		;EVALUATE TERM
	MOV	(SP)+,CRADIX	;RESTORE RADIX
	RETURN

	.IF NDF	XFLTG
TERM55:	CALL	FLTG1W		;++018 PROCESS ONE WORD FLOATING
	BEQ	TERM48		;ERROR IF NULL
	RETURN
	.ENDC

TERM56:				;^R
	CALL	SETSYM		;BACKUP CHAR PTR TO THE "R"
	MOV	#64,R2		;SET CONTROL MASK IN R2
10$:	CALL	GETR50		;FETCH A RADIX-50 CHAR
	BMI	TERM28		;IF MI NON-RAD50 ENCOUNTERED
	TST	R2		;CHECK CONTROL MASK
	BEQ	10$		;IF EQ SKIP CHARS PAST 3
20$:	ASR	R2		;SHIFT CONTROL MASK
	BCS	30$		;IF CS PROPER RAD50 POWER REACHED
	CALL	MULR50		;ELSE, MULTIPLY BY 50
	BR	20$		;REPEAT MULTIPLY LOOP
30$:	ADD	R0,(R4)		;ADD RESULT TO ACCUMULATED VALUE
	BR	10$		;REPEAT FOR 3 RADIX-50 CHARACTERS


;+
; STKCHK
; This routine checks the stack, to assure us that the expression
; being examined is not INSANE. If it is, we abort though the
; routine $OFVL in module ASSEM.
;-

STKCHK:
.IF	DF,RT11			;If RT-11

	CMP	SP,#$STKGD	;Has stack gone below the yellow zone?

.IFF;	DF,RT11			;If RT-11

	CMP	SP,$STKGD	;Has expression stack OVERFLOWED?

.ENDC;	DF,RT11			;If RT-11

	BHI	RTN		;Branch if not, continue.
	JMP	$OFVL		;Process overflow and terminate scan

STXOPC:	MOV	#FLAGS,R3	;++001 POINT R3 TO FLAGS
	MOV	(R3),-(SP)	;++001 SAVE FLAGS/SECTOR WORD
	MOV	R0,(R3)		;++001 SET OPCODE FLAG & NUMBER
	CALL	APPCPX		;++001 PUT ELEMENT IN CPXROL
	MOV	(SP)+,(R3)	;++001 RESTORE FLAGS/SECTOR WORD
	RETURN			;++001

APPCPX:	INC	CPXSTL		;++001 INCR COMPLEX STRING LENGTH FOR OPCODE
	BIT	#RELFLG!GLBFLG!CPXFLG,2(SP)  ;Is this expression ABS?
	BEQ	10$		;Branch if so, don't bother checking length.
	CMP	#RLDLEN-2,CPXSTL ;Is complex string now too long for a
				 ; single RLD record?
	BGE	10$		;Branch if not, OK.
	CLR	2(SP)		;Zap mode value on the stack (??)
	CALLR	ABSERR		;and flag line with "A" error.

10$:	APPEND	CPXLST		;APPEND COMPLEX EXPRS ELE TO LIST
RTN:	RETURN			;Return to caller


	.END
