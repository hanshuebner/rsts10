;  DEC/CMS REPLACEMENT HISTORY, Element CODHD.RSX
;  *3    18-AUG-1986 11:18:06 WORRALL "Complete HEX listing support for version 5.5 fieldtest"
;  *2    14-APR-1986 23:12:50 SYSTEM "Update 5.4 of MACRO-11"
;  *1    28-MAR-1986 02:34:00 SYSTEM "Load MACRO-11 sources from V5.3"
;  DEC/CMS REPLACEMENT HISTORY, Element CODHD.RSX
	.NLIST							;Edit Level 00
	.ENABL	LC,GBL
	.LIST
	.TITLE	CODHD - Code roll processing
	.SBTTL	CODHD - Code roll processing
	.SBTTL
	.SBTTL		.IDENT	/V05.05/
	.SBTTL
	.IDENT	/V05.05/
;****************************************************************************
;*									    *
;*                   COPYRIGHT (c)  1983, 1986                              *
;*          BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.                *
;*                   ALL RIGHTS RESERVED.                                   *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED  *
;*  ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE  *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER  *
;*  COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY  *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY  *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE  *
;*  AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT  *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS  *
;*  SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.		    *
;*									    *
;****************************************************************************


;++
;  Facility:	MACRO-11  The PDP-11 macro assembler for RT/RSX/VMS and RSTS/E
;
;    Author:	Too many people to list here
;
;   Created:	From the dust and dirt
;
;  Abstract:	CODHD - Code roll processing
;
;     Externals	 Description
;     ---------	 -----------
;
;      Edit	Who	Date		Description of modification
;      ----	---	----		---------------------------
;--


	PURE	PUREI,I

;+
; **-STCODE-STORE CODE
; **-PCROLL-PROCESS CODE ROLL
;-

STCODE::TST	PASS		;++001 IS THIS FIRST PASS?
	BEQ	4$		;++001 YES, IGNORE COMPLEX ROLL
	TST	OBJPNT		;++001 OBJECT CODE NEEDED?
	BEQ	4$		;++001 NO, JUST STORE CODE
	SAVREG			;++001 SAVE REGISTERS
	SETXPR			;++001 SET EXPRESSION REGISTERS
	BITB	#CPXFLG,(R3)	;++001 COMPLEX RELOCATION EXPRESSION?
	BEQ	4$		;++001 NO, BRANCH TO APPEND CODE ONLY
	MOV	(R4),-(SP)	;++001 SAVE VALUE--IT REVEALS MODE
	MOVB	$LSCNT+CPXLST,(R4)+  ;++021 PUT # OF CPX ELEMENTS IN VALUE
	MOVB	CPXSTL,(R4)+	;++001 PUT SIZE OF COMPLEX STRING IN VALUE
	CALL	APPCOD		;++001 APPEND EXPR VALUE TO CODE ROLL
	CLR	$LSPNT		;++021 INIT POINTER TO START OF LIST
2$:	NEXT	CPXLST		;++021 FETCH NEXT COMPLEX EXPR ELEMENT
	BEQ	3$		;++001 BRANCH IF NONE LEFT
	MOV	$LSPNT,-(SP)	;++021 SAVE LIST POINTER
	CALL	APPCOD		;++001 APPEND ELEMENT TO CODE ROLL
	MOV	(SP)+,$LSPNT	;++021 RESTORE LIST POINTER
	BR	2$		;++001 BRANCH TO GET NEXT CPX ELEMENT
3$:	MOV	#<CPXOPC*400!CPXSTO>,(R3) ;++001 FORM CPX STORE OPCODE (BKWDS)
	ADD	(SP)+,(R3)	;++001 MAKE STORE DISPLACED IF 1 ON STACK
	SWAB	(R3)		;++001 STRAIGHTEN OUT THE BYTES
	CLR	-(R4)		;++001 SET COSMETIC VALUE OF ZERO
4$:	CALL	APPCOD		;++001 APPEND IT TO CODROL
	INCB	INSIZE		;++014 INCREMENT INSTRUCTION SIZE

ZAPCPX::ZAP	CPXLST		;++021 EMPTY COMPLEX EXPR LIST
	MOV	#<1*2+1>,CPXSTL ;++001 INIT COMPLEX STRING LENGTH
	RETURN			;++001


APPCOD::APPEND	CODLST		;++021 APPEND TO GENERATED CODE LIST
PCR3A:	RETURN			;++001


PCROLL::NEXT	CODLST		;++021 FETCH NEXT ITEM OF GENERATED CODE
	BEQ	PCR3A		;++001 END
	SAVREG
	CLR	R5		;ASSUME BYTE
	CLR	R4
	BISB	SECTOR,R4	;GET THE RLD TYPE
	BMI	1$		;BRANCH IF BYTE
	INC	R5		;  WORD, BUMP TO 1
1$:	TST	PASS		;PASS ONE?
	BEQ	9$		;++001 YES, JUST UPDATE PC
	INC	PCRCNT		;EXTENSION LINE?
	BMI	2$		;  YES
	SETPF0			;LIST COLUMN ZERO
2$:	SETPF1			;SET PRINT FIELD ONE
	ASLB	R4		;BYTE?
	TST	OBJPNT		;ANY OBJECT CODE CALLED FOR?
	BEQ	9$		;++001 NO
	.IF NDF	XEDPNC
	BIT	#ED.PNC,EDMASK	;PUNCH DISABLED?
	BNE	9$		;++001 YES
	.ENDC
	.IF NDF	XREL
	MOV	PCRTBL(R4),R4	;GET PROPER TABLE ENTRY
	CMPB	CLCSEC,OBJSEC	;SECTOR CHANGE?
	BEQ	10$		;  NO
	CALL	EVNRLD		;++004 INSURE EVEN RLD POINTER
	MOV	#4*2,R0
	CALL	TSTRLD		;SOFTEN UP RLD BUFFER
	MOV	#RLDT07,(R2)+	;SET RLD TYPE 7
	MOV	CLCNAM,(R2)+	;  AND NEW SECTOR NAME
	MOV	CLCNAM+2,(R2)+
	MOVB	CLCSEC,OBJSEC
	BR	12$
	.IFTF
9$:	JMP	PCROL2		;++001
10$:	CMP	CLCLOC,OBJLOC	;DID PC MOVE ON US?
	BEQ	14$		;  NO
	.IFT
	CALL	EVNRLD		;++004 INSURE EVEN RLD POINTER
	MOV	#2*2,R0
	CALL	TSTRLD		;MAKE ROOM
	MOV	#RLDT10,(R2)+
12$:	.IFTF
	MOV	CLCLOC,(R2)	;SET NEW PC
13$:	CALL	OBJDMP		;DUMP BUFFER
14$:	MOV	OBJPNT,R0	;GET CODE POINTER
	ADD	R5,R0		;COMPUTE NEW END
	SUB	BUFTBL+BINCHN,R0
	CMP	R0,#OBJLEN-1	;ROOM?
	BHI	13$		;  NO
	.IFT
	MOVB	R4,R0		;YES, GET RLD SIZE
	BPL	90$		;++001 IF NEGATIVE, RLD IS COMPLEX
	MOVB	VALUE+1,R0	;++001 GET THE COMPLEX STRING LENGTH
90$:				;++001
	CALL	TSTRLD		;BE SURE WE HAVE ROOM
	.IFTF
	MOV	OBJPNT,R1
	CMP	R1,BUFTBL+BINCHN	;FIRST ITEM?
	BNE	16$		;  NO
	.IFT
	.IF NDF	XEDABS
	BIT	#ED.ABS,EDMASK	;ABS OUTPUT?
	BEQ	15$		;  YES
	.ENDC
	MOV	#BLKT03,(R1)+	;NO, SET BLOCK TYPE
15$:	MOV	CLCLOC,(R1)+	;SET NEW PC
16$:	.IFT
	ASL	R4		;ANY RLD?
	BCC	PCROL1		;  NO
	MOVB	SECTOR,(R2)+	;YES, SET CODE
	MOV	R1,R0
	SUB	BUFTBL+BINCHN,R0	;COMPUTE INDEX
	MOVB	R0,(R2)+
	TSTB	R4		;++001 IS RLD FOR COMPLEX EXPRESSION?
	BPL	PCROL1		;++001 NO, CONTINUE NORMAL PROCESSING
	MOVB	VALUE,-(SP)	;++001 PUT # OF CPX ELEMENTS ON STACK
GCODX:	NEXT	CODLST		;++021 FETCH NEXT COMPLEX EXPR ELEMENT
	MOVB	FLAGS,R4	;++001 PUT FLAGS BYTE IN R4
	BITB	#CPXOPC,R4	;++001 IS THIS A COMPLEX OP CODE?
	BNE	RELX1		;++001 YES, STORE IT IN RLD
	MOV	R2,R0		;++001 SAVE RLD POINTER--FORM CPX STACK CMD
	MOVB	#CPXGLB,(R2)+	;++001 ASSUME 'STACK GLOBAL' COMMAND
	BITB	#GLBFLG,R4	;++001 IS THIS A GLOBAL SYMBOL?
	BEQ	50$		;++001 NO, TRY RELOCATABLE
	CALL	RLDSYM		;++001 PUT SYMBOL NAME IN RLD
	BR	XMORE		;++001 BRANCH TO GET NEXT ELEMENT
50$:	INCB	(R0)		;++001 'STACK' COMMAND IS RELOC OR CONSTANT
	TSTB	R4		;++001 IS IT CONSTANT?
	BEQ	CONSTX		;++001 YES, BRANCH TO MOVE ITS VALUE
RELX1:	MOVB	SECTOR,(R2)+	;++001 MOVE INTO RLD, SECTOR # IF RELOCATABLE
				;++001      	..., OPCODE # IF OPCODE
	BITB	#RELFLG,R4	;++001 IS IT RELOCATABLE VALUE?
	BEQ	XMORE		;++001 NO, GET NEXT ELEMENT FROM ROLL
	BR	CONS1X		;++001 YES, MOVE ITS OFFSET
CONSTX:	INCB	(R0)		;++001 'STACK' COMMAND IS FOR CONSTANT
CONS1X:	MOVB	VALUE,(R2)+	;++001 MOVE THE VALUE ...
	MOVB	VALUE+1,(R2)+	;++001 ... INTO THE RLD
XMORE:	DECB	(SP)		;++001 DECREMENT ELEMENT COUNT
	BPL	GCODX		;++001 IF NON-NEGATIVE, GET NEXT ELEMENT
	TST	(SP)+		;++001 CLEAN STACK
	CLR	PF1+2		;++001 SET VALUE TO BE PRINTED TO ZERO
	BR	MVOBJ		;++001 BRANCH TO PUT VALUE IN OBJECT RECORD
PCROL1:	ASL	R4		;ANY SYMBOL REQUESTED?
	BCC	21$		;  NO
	CALL	RLDSYM		;++001 PUT SYMBOL NAME IN RLD
21$:	ASL	R4		;ANY VALUE?
	BCC	22$		;  NO
	MOVB	VALUE,(R2)+	;++001 MOVE THE VALUE ...
	MOVB	VALUE+1,(R2)+	;++001 ... INTO THE RLD
22$:	.ENDC
MVOBJ:				;++001
	MOVB	VALUE,(R1)+
	TST	R5
	BEQ	29$		;BRANCH IF BYTE INSTRUCTION
	MOVB	VALUE+1,(R1)+
29$:	MOV	R1,OBJPNT
PCROL2:	INC	R5		;MAKE COUNT 1 OR 2
	ADD	R5,CLCLOC	;UPDATE PC
	MOV	CLCLOC,OBJLOC	;SET SEQUENCE BREAK
	SETNZ	R0		;SET TRUE RETURN
PCROL3:	RETURN

RLDSYM:	MOV	#SYMBOL,R3	;++001 PUT SYMBOL ADDR IN R3
	.REPT	4		;++001 PUT 4 BYTES OF SYMBOL IN RLD
	MOVB	(R3)+,(R2)+	;++001
	.ENDR			;++001
	RETURN			;++001

	.PSECT	IMPLIN,D,GBL,RW	;++017
PCRCNT::.BLKW	1		;EXTENSION LINE FLAG
INSIZE::.BLKB	1		;++014 INSTRUCTION SIZE (WORD COUNT)
	.BLKB	1		;++014 -- UNUSED --


	.PSECT	MIXED,D,RW	;++021

$OPCOD::.BLKW	1		;++021 SAVES OPCODE VALUE IN 'PROPC'


	.IF NDF	XREL

	PURE	DPURE,D		;++017
PCRTBL::			;REF LABEL
	.WORD	0
	.WORD	120004		;RLDT01
	.WORD	140006		;RLDT02
	.WORD	120004		;RLDT03
	.WORD	140006		;RLDT04
	.WORD	160010		;RLDT05
	.WORD	160010		;RLDT06
	.WORD	0
	.WORD	0
	.WORD	100002		;RLD11 (.LIMIT)
	.WORD	0
	.WORD	0
	.WORD	0
	.WORD	160010		;RLDT15
	.WORD	160010		;RLDT16
	.WORD	100377		;++001 RLDT17
	.ENDC

	.PSECT	IMPPAS,D,GBL,RW	;++017
	.ODD
OBJSEC::.BLKB	1		;OBJECT FILE SECTOR
OBJLOC::.BLKW	1		;OBJECT FILE LOCATION

	PURE	PUREI,I		;++017

	.IF NDF	XEDPNC
PNCSET::MOVB	#-1,OBJSEC	;FORCE SEQUENCE BREAK
	RETURN
	.ENDC

;+
; **-OBJDMP-DUMP OBJECT BUFFER
; **-RLDDMP-DUMP RELOCATION BUFFER
; **-TSTRLD-TEST RELOCATION BUFFER
;-

OBJDMP::MOV	OBJPNT,@CNTTBL+BINCHN;POINT TO COUNT SLOT
	BEQ	OBJINX		;EXIT IF NOT PRE-SET
	SUB	BUFTBL+BINCHN,@CNTTBL+BINCHN	;COMPUTE ACTUAL COUNT
	BEQ	1$		;  EMPTY, FORGET IT
	$WRITE	BIN		;+;014 ELSE, WRITE OUT OBJECT BUFFER
1$:
	.IF NDF	XREL
	MOV	BUFTBL+RELCHN,R0
	TST	(R0)+		;IGNORE FIRST WORD
	CMP	RLDPNT,R0	;ANYTHING IN RLD?
	BLOS	OBJINI		;  NO, JUST INIT
RLDDMP::			;REF LABEL
	.IF NDF	XEDABS
	BIT	#ED.ABS,EDMASK	;ABS OUTPUT?
	BEQ	OBJINI		;  YES, NO RLD
	.ENDC
	MOV	RLDPNT,@CNTTBL+RELCHN
	SUB	BUFTBL+RELCHN,@CNTTBL+RELCHN	;COMPUTE BYTE COUNT
	$WRITE	REL		;++014 ELSE, WRITE OUT RLD BUFFER
	.IFTF
OBJINI::MOV	BUFTBL+BINCHN,OBJPNT;SET BUFFER POINTER
	.IFT
	MOV	BUFTBL+RELCHN,RLDPNT
	ADD	#2,RLDPNT	;RESERVE WORD FOR BLOCK TYPE
	.IFTF
OBJINX:	RETURN
	.IFT
TSTRLD::MOV	R0,-(SP)	;SAVE BYTE COUNT
	ADD	RLDPNT,R0
	SUB	BUFTBL+RELCHN,R0
	CMP	R0,#RLDLEN	;ROOM TO STORE?
	BLOS	1$		;  YES
	CALL	OBJDMP		;NO, DUMP CURRENT
1$:	MOV	RLDPNT,R2	;RETURN WITH POINTER IN R2
	ADD	(SP)+,RLDPNT	;UPDATE POINTER
	RETURN
EVNRLD:	BIT	#1,RLDPNT	;++004 IS RLD POINTER ODD?
	BEQ	1$		;++004 NO, JUST RETURN
	CALL	OBJDMP		;++004 YES, DUMP CURRENT BUFFER
1$:	RETURN			;++004
	.IFTF

	.PSECT	IMPURE,D,RW	;++017
CPXSTL::.BLKW	1		;++001 LENGTH OF COMPLEX STRING
OBJPNT::.BLKW	1		;
	.IFT
RLDPNT::.BLKW	1		;
	.ENDC


	.END
