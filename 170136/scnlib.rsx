;  DEC/CMS REPLACEMENT HISTORY, Element SCNLIB.RSX
;  *3    18-AUG-1986 11:27:00 WORRALL "Complete HEX listing support for version 5.5 fieldtest"
;  *2    14-APR-1986 23:54:41 SYSTEM "Update 5.4 of MACRO-11"
;  *1    28-MAR-1986 02:45:14 SYSTEM "Load MACRO-11 sources from V5.3"
;  DEC/CMS REPLACEMENT HISTORY, Element SCNLIB.RSX
	.NLIST							;Edit Level 00
	.ENABL	LC,GBL
	.LIST
	.TITLE	SCNLIB - Scan macro library for .mcall statement
	.SBTTL	SCNLIB - Scan macro library for .mcall statement
	.SBTTL
	.SBTTL		.IDENT	/V05.05/
	.SBTTL
	.IDENT	/V05.05/
;****************************************************************************
;*									    *
;*                   COPYRIGHT (c)  1983, 1986                              *
;*          BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.                *
;*                   ALL RIGHTS RESERVED.                                   *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED  *
;*  ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE  *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER  *
;*  COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY  *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY  *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE  *
;*  AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT  *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS  *
;*  SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.		    *
;*									    *
;****************************************************************************


;++
;  Facility:	MACRO-11  The PDP-11 macro assembler for RT/RSX/VMS and RSTS/E
;
;    Author:	Too many people to list here
;
;   Created:	From the dust and dirt
;
;  Abstract:	SCNLIB - Scan macro library for .mcall statement
;
;     Externals	 Description
;     ---------	 -----------
;
;      Edit	Who	Date		Description of modification
;      ----	---	----		---------------------------
;--


	.MCALL	FDAT$R,FDRC$R

;
; LOCAL ASSIGNMENTS
;

L$TYP = 0			;LIBRARY TYPE FIELD
L$ID = 1			;LIBRARY LBR ID FIELD
L$MS = 32			;LIBRARY MNT ENTRY SIZE FIELD
L$MT = 34			;LIBRARY MNT LOW VBN FIELD
L$MI = 36			;LIBRARY MNT ALLOCATED FIELD
L$MA = 40			;LIBRARY MNT AVAILABLE FIELD

ID$ = 2				;LBR ID BYTE VALUE
M$MAC = 8.			;SIZE OF MACRO LIBRARY MNT ENTRIES
TY$MAC = 1			;MACRO LIBRARY TYPE VALUE


;+
;
; *-SCNLIB-*-VERIFY AND SCAN MACRO LIBRARY FILE
;
;-

	PURE	PUREI,I

SCNLIB::FDAT$R	#SMLFDB,#R.FIX,,#512.  ;SET FILE ATTRIBUTES
	FDRC$R	R0,#FD.PLC	;READ LIBRARY HEADER IN LOCATE MODE
	CALL	RDLIB		;READ LIBRARY HEADER RECORD
	MOV	F.NRBD+2(R0),R1	;PUT ADDR OF RECORD IN R1
	CMPB	#TY$MAC,L$TYP(R1)  ;CHECK FOR PROPER LIBRARY TYPE
	BNE	VFYERR		;BAD LIBRARY/FILE IF NO MATCH
	CMPB	#ID$,L$ID(R1)	;CHECK FOR VALID LBR ID BYTE
	BNE	VFYERR		;ERROR IF NO MATCH
	CMPB	#M$MAC,L$MS(R1)	;CHECK FOR PROPER MNT ENTRY SIZE
	BNE	VFYERR		;ERROR IF NO MATCH
	MOV	L$MI(R1),MNCNT	;GET NUMBER OF MNT'S ALLOCATED
	SUB	L$MA(R1),MNCNT	;CALC NUMBER OF MNT'S USED
	BLT	VFYERR		;ERROR IF NEGATIVE
	MOV	L$MT(R1),R2	;GET LOW VBN OF MNT IN R2
	CLR	R3		;BYTE-IN-BLOCK POINTER IS ZERO
	CLR	MCLPNT		;++021 INIT .MCALL LIST POINTER
	CLR	-(SP)		;INDICATE THAT MNT READ IS REQUIRED

SCNMNT:	FDAT$R	#SMLFDB,#R.FIX,,#M$MAC  ;RESET FILE ATTRIBUTES
	FDRC$R	R0,#0		;READ MNT IN MOVE MODE
	CLR	R1		;CLEAR HIGH ORDER OF VBN
	CALL	.POINT		;POSITION INTO MNT
	BCS	PNTERR		;BRANCH IF ERROR
	MOV	MCLPNT,$LSPNT	;++021 SET LIST POINTER
10$:	NEXT	MCLLST		;++021 FETCH NEXT .MCALL NAME
	BEQ	SCNDON		;NONE LEFT FOR THIS LIBRARY
	TST	MODE		;GOT ONE, IS IT ALREADY DEFINED?
	BNE	10$		;YES, BRANCH FOR ANOTHER NAME
	TST	(SP)		;IS MNT READ REQUIED?
	BNE	30$		;NO, SKIP READ OF MNT ENTRY
20$:	DEC	MNCNT		;DECREMENT MNT COUNT
	BLT	SCNDON		;TABLE EXHAUSTED, LEAVE TO GET NEXT FILE
	CALL	RDLIB		;ELSE, READ NEXT MACRO NAME FROM MNT
	INC	(SP)		;INDICATE MNT ENTRY WAS READ
30$:	MOV	SMLFDB+F.NRBD+2,R4  ;GET ADDR OF MACRO NAME IN R4
	CMP	(R4)+,SYMBOL	;COMPARE WITH UNDEFINED .MCALL NAME
	BNE	40$		;++021 IF NE NO MATCH
	CMP	(R4)+,SYMBOL+2	;MATCH, COMPARE WITH SECOND HALF
40$:				;++021
	BLO	20$		;TOO SMALL, READ NEXT MNT ENTRY
	BHI	10$		;TOO HIGH, GET NEXT .MCALL NAME
	INC	MODE		;INDICATE MACRO DEFN FOUND
	MOV	$LSPNT,MCLPNT	;++021 SAVE LIST POINTER
	INSERT			;REWRITE .MCALL NAME ENTRY
	MOV	#SMLFDB,R0	;PUT ADDRESS OF FDB IN R0
	CALL	.MARK		;MARK POSITION OF NEXT MNT ENTRY IN FILE
	MOV	R3,-(SP)	;AND SAVE THE INFORMATION ...
	MOV	R2,-(SP)	;... IN THE STACK
	MOV	(R4)+,R2	;GET POSITION OF MACRO MODULE ...
	MOV	(R4)+,R3	;... HEADER IN LIBRARY FILE
	CALL	.POINT		;POSITION TO READ THE MODULE HEADER
	BCS	PNTERR		;BRANCH ON ERROR
	FDAT$R	R0,#R.VAR	;RESET FILE ATTRIBUTES
	CALL	RDLIB		;READ THE MACRO MODULE HEADER RECORD
	CALL	GETLIN		;READ MACRO DEFINITION LINE
	BNE	VFYERR		;ERROR, PREMATURE EOF
	CALL	SETMAC		;BYPASS THE .MACRO FIELD
	BEQ	VFYERR		;ERROR, NOT MACRO TYPE DIRECTIVE
	CMP	#^R.MA,SYMBOL	;BE SURE DIRECTIVE IS MACRO TYPE
	BNE	VFYERR		;ERROR IF NOT .MACRO
	GSARG			;GET THE MACRO NAME FIELD
	BEQ	VFYERR		;ERROR IF IT IS NULL
	CALL	MACROF		;Process macro definition from library
	MOV	(SP)+,R2	;RESTORE MNT INFO FROM STACK
	MOV	(SP)+,R3	;
	CLR	(SP)		;INDICATE MUST READ FROM MNT
	DEC	SMLLVL		;DECREMENT OUTSTANDING .MCALL COUNT
	BNE	SCNMNT		;REPEAT IF UNSATISFIED
SCNDON:	MOV	SMLLVL,(SP)+	;SET RETURN STATUS AND CLEAN STACK
	RETURN			;

RDLIB:	$READ	SML		;READ FROM LIBRARY FILE
EOFCK:	CMPB	#IE.EOF,F.ERR(R0)  ;WAS END OF FILE DETECTED?
	BEQ	VFYERR		;ERROR, PREMATURE EOF
	RETURN			;OTHERWISE, JUST RETURN

PNTERR:	CALL	EOFCK		;PROCESS EOF ERROR (IF APPROPRIATE)
	MOV	#LIBM2,R3	;ELSE, DECLARE LIBRARY FILE I/O ERROR
	BR	RSTRT		;BRANCH TO LEAVE

VFYERR:	MOV	#LIBM1,R3	;DECLARE INVALID LIBRARY ERROR
RSTRT:	JMP	RESTRT		;CLEANUP, SEND ERROR, AND RESTART


;+
; SMLTST
; SCAN .MCALL STATEMENT AND CREATE NAME LIST IN 'MCLLST'
;-

SMLTST::GSARG			;GET MACRO NAME
	BEQ	30$		;NONE LEFT, LEAVE
	OSRCH			;FOUND ONE, SEARCH OPCODE/MACRO NAME LIST ;JR
	BEQ	10$		;BRANCH IF NOT THERE, MAKE ENTRY	;JR
	BIT	#M$FLAG,MODE	;TEST IF DEFINED AS MACRO ALREADY	;JR
	BEQ	10$		;BRANCH IF NOT, REPLACE THIS OPCODE WITH MACRO
	TST	VALUE		;TEST IF MACRO IS DEFINED		;JR
	BNE	20$		;BRANCH IF SO, JUST CREF THE DEFINITON	;JR
	TST	PASS		;IS THIS SECOND PASS?
	BNE	15$		;IF NE YES -- SKIP INSERT
10$:	CLR	VALUE		;SET VALUE TO NULL DEFINITION		;JR
	MOV	#M$FLAG,MODE	;SET THE MACRO TYPE FLAG		;JR
	CALL	VINSRT		;INSERT .MCALL NAME INTO THE HASH TABLE ;JR
	SEARCH	MCLLST		;FIND SLOT IN NAME LIST
	INSERT			;INSERT .MCALL NAME IN PROPER ORDER
15$:	INC	SMLLVL		;INCREMENT UNDEFINED MACRO NAME COUNT
20$:	MOV	#MACLST,ROLNDX	;SET ROLL INDEX TO MACRO TYPE FOR CREF	;JR
	CRFDEF			; AND CREF THE DEFINITION NOW		;JR
	BR	SMLTST		;GET ANOTHER NAME ARGUMENT
30$:	MOV	SMLLVL,R0	;RETURN STATUS IS NUMBER OF UNDEFINED NAMES
	RETURN


	.END
