;  DEC/CMS REPLACEMENT HISTORY, Element MACRS.MAC
;  *6    23-OCT-1989 15:59:52 STEVENS "INCREASE BUFFER FOR AUTO LABEL GENERATION"
;  *5     2-SEP-1987 14:34:30 STEVENS "CHANGED CODING OF '\' OPERATOR CHANGE"
;  *4    14-AUG-1987 10:54:07 STEVENS "Fixed '\' operator when .RADIX is 16."
;  *3    18-AUG-1986 11:24:04 WORRALL "Complete HEX listing support for version 5.5 fieldtest"
;  *2    14-APR-1986 23:33:06 SYSTEM "Update 5.4 of MACRO-11"
;  *1    28-MAR-1986 02:40:30 SYSTEM "Load MACRO-11 sources from V5.3"
;  DEC/CMS REPLACEMENT HISTORY, Element MACRS.MAC
	.NLIST							;Edit Level 01
	.ENABL	LC,GBL
	.LIST
	.TITLE	MACRS - Resident macro processing routines
	.SBTTL	MACRS - Resident macro processing routines
	.SBTTL
	.SBTTL		.IDENT	/V05.05/
	.SBTTL
	.IDENT	/V05.05/
;****************************************************************************
;*									    *
;*                   COPYRIGHT (c)  1983, 1986                              *
;*          BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.                *
;*                   ALL RIGHTS RESERVED.                                   *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED  *
;*  ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE  *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER  *
;*  COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY  *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY  *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE  *
;*  AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT  *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS  *
;*  SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.		    *
;*									    *
;****************************************************************************


;++
;  Facility:	MACRO-11  The PDP-11 macro assembler for RT/RSX/VMS and RSTS/E
;
;    Author:	Too many people to list here
;
;   Created:	From the dust and dirt
;
;  Abstract:	MACRS - Resident macro processing routines
;
;     Externals	 Description
;     ---------	 -----------
;
;      Edit	Who	Date		Description of modification
;      ----	---	----		---------------------------
;	001	Jrw	27-Jul-83	Update for 8-bit support.
;--


;+
; EQUATED SYMBOLS
;-

MT.RPT==177601			;End of repeat block flag character
MT.IRP==177602			;End of .IRP/C block flagcharacter
MT.MAC==177603			;Macro block terminator flag
MT.MAX==177603			;Maximum macro terminator flag number (GETLN)
MT.DMA==177604			;Dummy agrument flag (Followed by argument #)
MT.EOA==177605			;End of argument flag

GENBAS=	30000.			;Base for local symbol generation

.IF	NDF,RT11		;If NOT RT-11

;
; LOCAL DATA
;
	.PSECT	MIXED,D,RW
GENBUF:	.BLKB	96.		;GENERATED ARGUMENT BUFFER

.ENDC;	NDF,RT11		;If NOT RT-11

	PURE	PUREI,I
;+
;  **-PROMA-PROCESS MACRO DEFINITION ARGUMENTS
;-

PROMA::				;++010
	ZAP	DMALST		;++021 EMPTY DUMMY ARGUMENT LIST
	CLR	ARGCNT		;GET A FRESH START WITH ARGUMENTS
	CLR	MACGSB		;CLEAR GENERATED BIT PATTERN
	MOV	#100000,-(SP)	;STACK FIRST GENERATED SYMBOL BIT
1$:	TSTARG			;ANY MORE ARGS?
	BEQ	3$		;  NO, QUIT AND GO HOME
	CMP	#'?,R5		;YES, GENERATED TYPE?
	BNE	2$		;  NO
	BIS	(SP),MACGSB	;YES, SET PROPER BIT
	GETNB			;BYPASS IT
2$:	CALL	GSARGF		;GET SYMBOLIC ARGUMENT
	BEQ	20$		;++025 IF EQ NO LEGAL DUMMY ARG
	SEARCH	DMALST		;++021 FIND LIST SLOT FOR DUMMY ARGUMENT
	BNE	15$		;++025 IF NE DUPICATE DUMMY ARG FOUND
	MOV	ARGCNT,MODE	;++021 STORE ARGUMENT NUMBER
	CMP	#'=,R5		;++025 TERMINATOR EQUAL SIGN?
	BNE	10$		;++025 IF NE NO
	GETNB			;++025 BYPASS EQUAL SIGN
	CALL	GMARGF		;++025 GET MACRO ARGUMENT
	MOV	CHRPNT,VALUE	;++025 SET ADDRESS OF DEFAULT ARGUMENT
	CALL	RMARG		;++025 REMOVE MACRO ARGUMENT
	MOVB	$ARGSZ,SECTOR	;SET DEFAULT ARG STRING SIZE
	BIC	(SP),MACGSB	;++025 CLEAR POSSIBLE GENERATION FLAG
10$:	INSERT			;++025 INSERT ENTRY IN DUMMY ARGUMENT ROLL
	CLC
	ROR	(SP)		;SHIFT GENERATED SYM BIT
	BR	1$
15$:	ERROR	A		;++025 DUPLICATE DUMMY ARG FOUND
20$:	DEC	ARGCNT		;++025 DECR TO ACCOUNT FOR ILLEGAL ARG
3$:	TST	(SP)+		;PRUNE STACK
	RETURN


;+
; **-PROMC/PROMCF-PROCESS MACRO CALL ARGUMENTS
;-

PROMC::				;++026
	COM	R3		;++025 SET NEGATIVE VALUE TO SIGNIFY MACRO
PROMCF::CLR	ARGCNT		;++017 CLEAR MACRO CALL ARGUMENT COUNT
	CALL	GETBLK
	MOV	R1,-(SP)	;++021 SAVE VIRT LOCN OF FIRST ARG BLK
	MOV	R0,MACWRT	;++021 FOR BLK BEING WRITTEN, SAVE ...
	MOV	R1,MACWTV	;++021 BOTH VIRT LOCN AND REAL ADDR
	SUB	R0,R2		;++010 CONVERT R2 FROM ADDR TO OFFSET
	MOV	R4,-(SP)	;++025 SAVE REGISTER R4
	MOV	#GENBUF,R4	;++025 GET ADDRESS OF GENERATION BUFFER
	MOV	R3,-(SP)	;++025 SAVE REGISTER R3
	BGT	7$		;++025 IF GT IRPC
	CLR	$LSPNT		;++025 CLEAR LIST POINTER

1$:	CMPB	ARGMAX,ARGCNT	;++013 MAX ARGS FOR THIS MACRO?
	BLOS	120$		;++025 IF LOS YES
	TSTARG			;BYPASS ANY COMMA
	BNE	9$		;OK IF NON-NULL
	TST	MACGSB		;NULL, ANY GENERATED STUFF LEFT?
	BEQ	120$		;++025 IF EQ NO
	INC	ARGCNT		;++025 INCREMENT ARGUMENT COUNT
	INC	NULCNT		;++031 INCREMENT COUNT OF NULL ARGS IN CALL
9$:	NEXT	DMALST		;++025 GET NEXT ENTRY IN DUMMY ARGUMENT ROLL
	CMP	#'\,R5		;++025 BACKSLASH?
	BEQ	20$		;  YES
	TST	(SP)		;++025 IRP?
	BEQ	110$		;++025 IF EQ YES

2$:	GETSYM			;++025 GET SYMBOL
	BEQ	95$		;++025 IF EQ NONE
	CMP	#'=,R5		;++025 TERMINATOR EQUAL SIGN?
	BNE	100$		;++025 IF NE NO
	SEARCH	DMALST		;++025 SEARCH DUMMY ARGUMENT ROLL
	BEQ	100$		;Branch if undefined keyword referenced.
	MOVB	MODE,R5		;++025 GET ARGUMENT NUMBER
	DEC	ARGCNT		;DON'T TALLY KEYWORD ARGS POSITIONALLY
	SUB	ARGCNT,R5	;TEST FOR POSSIBLE AUTOGEN SYMBOL
	BLE	92$		;BRANCH IF PASSED THAT ARG
	CLR	R3		;++025 CLEAR ARGUMENT BIT
	SEC			;++025 SET CARRY FOR MASK FORMATION
90$:	ROR	R3		;++025 SHIFT MASK
	DEC	R5		;++025 ANY MORE SHIFTS TO PERFORM?
	BGT	90$		;++025 IF GT YES
	BIC	R3,MACGSB	;++025 CLEAR GENERATED SYMBOL BIT

92$:	GETNB			;++025 BYPASS EQUAL SIGN
	CALL	UPDMAR		;++025 UPDATE DUMMY ARGUMENT ROLL ENTRY
	CALL	RSDMAR		;++025 RESET DUMMY ARGUMENT TO PROPER ENTRY
	TST	ARGCNT		;++025 ANY POSITIONAL ARGUMENTS?
	BNE	1$		;++025 IF NE NOT FIRST ARGUMENT
	CMP	#',,R5		;++025 NEXT CHARACTER A COMMA?
	BNE	1$		;++025 IF NE NO
	GETNB			;++025 BYPASS COMMA
	BR	1$		;++025
95$:
	.IF NDF	XEDLSB
	TST	R5		;TEST IF END OF LINE
	BEQ	98$		;BRANCH IF YES
	BITB	#CT.COM!CT.SMC,CTTBL(R5) ;ELSE TEST IF SEMICOLON OR COMMA
	BEQ	100$		;BRANCH IF NEITHER
98$:	TST	MACGSB		;TEST GENERATED SYM FLAG
	BMI	30$		;BRANCH IF YES, DO THE GENERATION
	BR	5$		;ELSE JUST LOOP
	.ENDC			;(XEDLSB)

100$:	SETSYM			;++025 RESET CHARACTER POINTER
110$:	CALL	RSDMAR		;++025 RESET DUMMY ARGUMENT ROLL
	CALL	UPDMAR		;++025 UPDATE DUMMY ARGUMENT ROLL ENTRY
5$:	ASL	MACGSB		;MOVE GENERATION BIT OVER ONE
	BR	1$

6$:	INC	ARGCNT
	GETCHR
7$:	CALL	WCIMTL		;++022 PUT (LOWER CASE) CHAR IN TXT BLK
	BEQ	10$
	CLR	R5
	CALL	WCIMT
	BR	6$

120$:	CLR	$LSPNT		;++025 CLEAR LIST POINTER
130$:	NEXT	DMALST		;++025 GET NEXT ENTRY IN DUMMY ARGUMENT ROLL
	BEQ	160$		;++025 IF EQ END OF LIST
	MOVB	SECTOR,R3	;++025 GET LENGTH OF ARGUMENT
	MOV	VALUE,R4	;++025 GET ADDRESS OF ARGUMENT
140$:	DEC	R3		;++025 ANY MORE CHARACTERS IN ARGUMENT?
	BLT	150$		;++025 IF LT NO
	MOVB	(R4)+,R5	;++025 GET NEXT ARGUMENT CHARACTER
	CALL	WCIMT		;++025 WRITE CHARACTER IN MACRO TREE
	BR	140$		;++025
150$:	CLR	R5		;++025 SET ZERO CHARACTER
	CALL	WCIMT		;++025 WRITE CHARACTER IN MACRO TREE
	BR	130$		;++025

160$:	SETCHR			;++025 RESTORE R5
10$:	MOV	R5,-(SP)	;Save character
	MOV	#MT.EOA,R5	;Get marker for "end of arglist"
	CALL	WCIMT		;Write it
	MOV	(SP)+,R5	;Restore character
	MOV	MACWTV,R1	;++021 GET VIRT LOCN OF CURRENT TEXT BLK
	UNLPG			;++021 UNLOCK ITS PAGE
	MOV	(SP)+,R3	;++025 RESTORE R3 AND R4
	MOV	(SP)+,R4	;++025
	MOV	(SP)+,R1	;++021 RESTORE VIRT LOCN OF 1ST ARG BLK
	BIT	#LC.MC,LCMASK	;MACRO CALL SUPPRESSION?
	BEQ	12$		;  NO
	MOV	LBLEND,LCENDL	;++013 ASSUME LABEL ON MACRO CALL LINE
	BNE	12$		;++013 SKIP IF ASSUMPTION IS CORRECT
	BIS	#LC.MC,LCFLAG	;++013 INDICATE LINE IS A MACRO CALL
12$:				;++013
	RETURN

20$:	GETNB			; "\", BYPASS
	ABSEXP			;EVALUATE EXPRESSION, ABS
	CLR	EXPFLG		;++017 CLR EXPR FLG -- COMMA NOT R'QD
	MOV	R5,-(SP)	;STACK CHARACTER
	MOV	R0,R1		;VALUE TO R1
	CALL	RSDMAR		;++025 RESET DUMMY ARGUMENT ROLL
	MOV	CRADIX,R3	;++025 SET CONVERSION RADIX
	CALL	35$		;++025 CONVERT AND STORE ARGUMENT
	MOV	(SP)+,R5
	BR	5$

	.IF NDF	XEDLSB
30$:	SETSYM			;RESET CHARACTER POINTER
	MOV	LSGBAS,R1	;Get local symbol generation base
	INC	R1		;++017 INCREMENT IT
	CMP	R1,#<65535.-GENBAS> ;Compare with upper limit of local symbols
	BLOS	32$		;Branch if in range, OK.
	CLR	R1		; Else start over
32$:	MOV	R1,LSGBAS	;Save new generation base
	ADD	#GENBAS-1,R1	;Start at base value
	MOV	R5,-(SP)	;STACK CURRENT CHAR
	MOV	#10.,R3		;MAKE IT DECIMAL
	CALL	35$		;++025 CONVERT AND STORE ARGUMENT
	MOVB	#'$,(R4)+	;++025 INSERT DOLLAR SIGN
	INCB	SECTOR		;++025 UPDATE LENGTH
	INSERT			;++025 UPDATE ROLL ENTRY
	MOV	(SP)+,R5
	BR	5$		;RETURN
	.ENDC

35$:	MOV	R4,VALUE	;++025 SET ADDRESS OF GENERATED ARGUMENT
	CALL	40$		;++025 GENERATE ARGUMENT
	MOV	R4,R0		;++025 GET CURRENT GENERATION POINTER
	SUB	VALUE,R0	;CALCULATE SIZE OF ARG STRING
	MOVB	R0,SECTOR	;STORE ARGUMENT LENGTH
	BR	UPDMAC		;++025 FINISH IN COMMON CODE

40$:	CLR	R0		;MACRO NUMBER CONVERTOR
	DIV	R3,R0
	MOV	R1,-(SP)	;STACK REMAINDER
	MOV	R0,R1		;SET NEW NUMBER
	BEQ	41$		;DOWN TO ZERO?
	CALL	40$		;  NO, RECURSE
41$:	MOV	(SP)+,R5	;GET NUMBER
	CMP	#10.,R5		;IS NUMBER GREATER THAN 10?
        BHI	42$		;  NO, USE 0 - 9
	ADD	#'A-'9-1,R5	;  YES, OFFSET FOR A - F
42$:	ADD	#'0,R5		;CONVERT TO ASCII
	MOVB	R5,(R4)+	;++025 STORE CHARACTER IN GENERATION BUFFER
	RETURN			;++025


;
; RESET DUMMY ARGUMENT ROLL TO "ARGCNT" ENTRY
;

RSDMAR:	CLR	$LSPNT		;++025 CLEAR LIST POINTER
	MOV	ARGCNT,R3	;++025 GET ARGUMENT COUNT
	BEQ	20$		;++025 IF EQ NO ARGUMENTS YES
10$:	NEXT	DMALST		;++025 GET NEXT DUMMY ARGUMENT ROLL ENTRY
	DEC	R3		;++025 ANY MORE TO BYPASS?
	BGT	10$		;++025 IF GT YES
20$:	RETURN			;++025

;
; UPDATE DUMMY ARGUMENT ROLL ENTRY
;

UPDMAR:	CALL	GMARGF		;PARSE THE MACRO ARGUMENT
	MOV	CHRPNT,VALUE	;STORE START ADDR OF ARG
	CALL	RMARG		;NOW REMOVE THE ARGUMENT
	MOVB	$ARGSZ,SECTOR	;STORE THE SIZE OF THE ARG STRING

UPDMAC:	INSERT			;++025 UPDATE ROLL ENTRY
	RETURN			;++025


;+
; PROMT
; PROCESS MACRO DEFINITION TEXT
; THE BODY OF THE MACRO OR REPEAT BLOCK IS STORED IN VIRTUAL MEMORY
; Dummy arguments are flagged with a byte of <204> followed by a byte
; of argument number.
; APOSTROPHES ADJACENT TO DUMMY ARGS ARE DELETED
; A CURSORY SCAN IS DONE TO HANDLE POSSIBLE NESTED MACRO DIRECTIVES
;-

PROMT::	CLR	R3		;++010 CLEAR LEVEL COUNT
	SUB	MACWRT,R2	;++021 CONVERT R2 FROM ADDR TO OFFSET
1$:	INC	GETFLG		;INHIBIT FILE CROSSING
	CALL	GETLIN		;GET NEXT LINE
	DEC	GETFLG		;ENABLE FILE CROSSING
	TST	R0		;TEST GETLIN RETURN STATUS
	BNE	2$
	BIS	#LC.MD,LCFLAG	;INDICATE PRESENCE OF MACRO DEFINITION ON LINE
	CALL	SETMAC		;++008 CHECK FOR MACRO-TYPE DIRECTIVE
	BEQ	3$		;++010 NOT TRUE, BRANCH
	INC	R3
	CMP	SYMBOL,#^R.EN	;.ENDM OR .ENDR?
	BNE	3$		;BRANCH IF NOT
	SUB	#2,R3		;REDUCE LEVEL COUNT
	BPL	3$
2$:	RETURN			;++021

3$:	MOV	#LINBUF,CHRPNT	;SET POINTER TO START OF LINE
	SETCHR
4$:	GETSYM			;TRY TO GET SYMBOL
	BEQ	7$		;BRANCH IF NOT AT SYMBOL
	SEARCH	DMALST		;++021 LOOK FOR MATCHING DUMMY ARGUMENT
	MOV	R0,R4
	BEQ	5$		;BRANCH IF NO MATCHING DUMMY ARGUMENT
	DEC	CONCNT
	MOV	#MT.DMA,R5	;Set up for dummy argument marker
	CALL	WCIMT		;Write it
	MOV	MODE,R5		;++021 GET ARGUMENT NUMBER IN R5
	CALL	WCIMT		;Now write argument number
	DEC	CONCNT
5$:	SETSYM			;RESET SCAN POINTER TO START OF SYMBOL
6$:	TST	R4		;TEST IF MATCHED A DUMMY ARG
	BNE	61$		;SKIP WRITING SYMBOL IF IT IS DUMMY ARG
	CALL	WCIMTL		;ELSE WRITE POSSIBLE LOWER CASE CHAR	;JR
61$:	GETR50
	BGT	6$		;ITERATE FOR CHARS IN SYMBOL
7$:	CMP	R5,#''		;TEST IF DUMMY ARG CONCATENATION
	BEQ	8$		;BRANCH IF YES, REMOVE ADJACENT APOSTROPHE
	CALL	WCIMT
	BNE	9$		;CONTINUE SCANNING IF NOT EOL
	CALL	ENDLIN		;EOL FLAGGED BY NULL, LIST LINE IF PASS 2
	BR	1$		;GET NEXT LINE OF MACRO BODY

8$:	INC	CONCNT
9$:	GETCHR
	BR	4$


;+
; **-WCIMT/WCIMTL-WRITE CHARACTER IN MACRO TEXT BLOCK
;-

WCIMTL:				;++022 STORE MACRO CALL (LOWER CASE) CHAR
	CLR	R5		;Clear for BISB
	BISB	@CHRPNT,R5	;Get original character
WCIMT::				;++017 WRITE CHARACTER INTO MACRO TEXT
	DEC	CONCNT		;++010 ANY CONCATENATED CHARS PENDING?
	BMI	1$		;  NO
	MOV	R5,-(SP)	;YES, STACK CURRENT CHARACTER
	MOV	#'',R5		;FLUSH OUT CONSECUTIVE APOSTROPHES
	CALL	2$
	MOV	(SP)+,R5
	BR	WCIMT

1$:	CLR	CONCNT
2$:	CMP	R2,#BPMB	;++010 IS CURRENT MACRO TEXT BLOCK FULL?
	BLT	3$		;++010 BRANCH IF THERE'S STILL ROOM
	CALL	GETBLK
	MOV	R1,@MACWRT	;++021 PUT VIRT LOCN OF NEW TEXT BLK ...
				;++021 INTO LINK WORD OF OLD ONE
	MOV	MACWTV,R1	;++021 GET VIRT LOCN OF OLD TEXT BLK
	UNLPG			;++021 UNLOCK ITS PAGE
	MOV	@MACWRT,MACWTV	;++021 MAKE NEW TEXT BLK CURRENT ONE
	MOV	R0,MACWRT	;++010 SAVE ADDR OF BLOCK BEING WRITTEN
	SUB	R0,R2		;++010 CONVERT R2 FROM ADDR TO OFFSET
3$:	MOV	MACWRT,-(SP)	;++010 GET ADDR OF BLOCK BEING WRITTEN
	ADD	R2,(SP)		;++010 ADD OFFSET OF NEXT CHARACTER
	INC	R2		;++010 INCREMENT THE OFFSET
	MOVB	R5,@(SP)+	;++010 STORE THE CHARACTER
	RETURN


;+
; GETBLK
; GET A MACRO STORAGE TEXT BLOCK
; IF THERE ARE NO OLD BLOCKS IN THE FREELIST, VIRTUAL MEMORY IS ALLOCATED
; RETURN R1, R0 AS VIRTUAL AND REAL BLOCK ADDRESSES, R2 POINTING TO
; SECOND WORD. BLOCK IS WRITE MARKED IN ANTICIPATION OF ITS USE.
;-

GETBLK::			;++010
	MOV	MACNXT,R1	;++021 GET VIRT LOCN OF NEXT FREE BLOCK
	BEQ	1$		;++021 IF EQ NONE LEFT
	CVRL			;++021 ELSE, GET ITS REAL ADDR IN R0
	MOV	(R0),MACNXT	;++021 REMOVE BLOCK FROM FREE LIST
	BR	2$
1$:	MOV	#BPMB,R1	;++021 SPECIFY SIZE OF BLOCK NEEDED
	ALVRT			;++021 ALLOC A BLOCK FROM VIRTUAL MEMORY
2$:	MOV	R0,R2		;++021 PUT REAL ADDR OF BLOCK IN R2
	CLR	(R2)+		;CLEAR LINK CELL, POINT PAST IT
	BR	WRMLCK		;++021 BRANCH INTO COMMON CODE

;+
; INCMAC, DECMAC
; ALTER CURRENT MACRO USAGE (LOCKING) COUNT
; IF MACRO BODY IS NO LONGER NEEDED, ITS SPACE IS RETURNED TO THE FREELIST
; WARNING: ASSUMPTION IS THAT MACRO TEXT BLOCK WAS JUST REFERENCED
; VIA A CVRL CALL TO ALLOW FAST WRITE-MARK AND LOCK OPERATION
;-

DECMAC::CVRL2			;++021 GET REAL ADDR OF BASIC TEXT BLK
	DECB	2(R0)		;++021 DECREMENT MACRO REFERENCE COUNT
	BPL	WRM		;++021 IF PL MACRO IN EXPANSION ...
				;++021 (WILL BE REMOVED LATER)
	JMP	REMMAC		;++ REMOVE MACRO DEFN AND RETURN

INCMAC::INCB	2(R0)		;++026 INCREMENT MACRO LEVEL COUNT
WRMLCK:	LOCPG			;LOCK CURRENT PAGE
WRM:	WMCPG			;MARK CURRENT PAGE DIRTY AND RETURN
	RETURN

;+
; INTERNAL SUBROUTINE -- CHECK FOR MACRO-TYPE DIRECTIVE
;-

SETMAC::MOV	R2,-(SP)	;++008 SAVE R2
	CALL	SETDIR		;++008 TEST FOR DIRECTIVE
	BEQ	2$		;++008 NOT TRUE -- RETURN FAILURE
	MOV	#SETMCL-2,R2	;++008 PNT R2 TO MACRO-TYPE DIRECTIVES
1$:	TST	(R2)+		;++008 ADVANCE POINTER
	MOV	(R2),R0		;++008 PUT NEXT IN LIST IN R0
	BEQ	2$		;++008 IF NULL RETURN FAILURE
	CMP	SYMBOL,(R2)+	;++008 CMP THE FIRST HALF OF EACH
	BNE	1$		;++008 BRANCH IF NOT A MATCH
	CMP	SYMBOL+2,(R2)	;++008 NOW CMP THE LAST HALF OF EACH
	BNE	1$		;++008 BRANCH IF NOT A MATCH
2$:	MOV	(SP)+,R2	;++008 RESTORE R2
	TST	R0		;++008 SET RETURN STATUS
	RETURN			;++008 (R0 NON-ZERO MEANS FOUND A MATCH)

	PURE	DPURE,D		;PUT IN DATA PSECT FOR I/D SPACE	;JR
SETMCL:	.IRP	X,<ENDM,ENDR,IRP,IRPC,MACRO,REPT>
	.RAD50	/.'X/		;++008
	.ENDR			;++008

	.WORD	0		;++008 END-OF-LIST


	.END
