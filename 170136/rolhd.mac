;  DEC/CMS REPLACEMENT HISTORY, Element ROLHD.MAC
;  *3    18-AUG-1986 11:26:21 WORRALL "Complete HEX listing support for version 5.5 fieldtest"
;  *2    14-APR-1986 23:42:18 SYSTEM "Update 5.4 of MACRO-11"
;  *1    28-MAR-1986 02:44:06 SYSTEM "Load MACRO-11 sources from V5.3"
;  DEC/CMS REPLACEMENT HISTORY, Element ROLHD.MAC
	.NLIST							;Edit Level 00
	.ENABL	LC,GBL
	.LIST
	.TITLE	ROLHD - Symbol table handling
	.SBTTL	ROLHD - Symbol table handling
	.SBTTL
	.SBTTL		.IDENT	/V05.05/
	.SBTTL
	.IDENT	/V05.05/
;****************************************************************************
;*									    *
;*                   COPYRIGHT (c)  1983, 1986                              *
;*          BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.                *
;*                   ALL RIGHTS RESERVED.                                   *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED  *
;*  ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE  *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER  *
;*  COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY  *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY  *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE  *
;*  AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT  *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS  *
;*  SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.		    *
;*									    *
;****************************************************************************


;++
;  Facility:	MACRO-11  The PDP-11 macro assembler for RT/RSX/VMS and RSTS/E
;
;    Author:	Too many people to list here
;
;   Created:	From the dust and dirt
;
;  Abstract:	ROLHD - Symbol table handling
;
;     Externals	 Description
;     ---------	 -----------
;
;      Edit	Who	Date		Description of modification
;      ----	---	----		---------------------------
;--


	PURE	PUREI,I

	.IF NDF	XEDLSB
;+
; LSRCH
; SEARCH THE LOCAL SYMBOL LIST
; THE LOCAL SYMBOL LIST CONTAINS UP TO 85. 3 WORD ENTRIES PER PAGE
; THE END OF A LOCAL SYMBOL BLOCK (AND THE END OF THE TABLE) IS DELIMITED
; BY AN ALL ZERO ENTRY. OVERFLOW PAGES ARE THREADED ON THE LAST WORD OF
; THE PAGE SINCE 85.*3 = 255.
; CALL LSRCH
; Z SET IF NOT FOUND; ELSE SYMBOL SCRATCHPAD SET TO VALUE OF SYMBOL
;-

LSRCH::	CLR	SYMBOL		;FLAG AS LOCAL LABEL IN CASE OF LATER INSERT
	MOV	VALUE,SYMBOL+2	;SAVE VALUE AS SYMBOL
	MOV	LSYBLK,R1	;GET VIRTUAL LOC OF CURRENT BLOCK
	CVRL			; AND GET REAL ADDR IN R0
	TSTB	LSFLAG		;TEST IF NEW BLOCK FLAGGED
	BNE	30$		;BRANCH IF NO, SEARCH FOR SYMBOL
				; ELSE SCAN AHEAD LOOKING FOR NULL DELIMITER
	INCB	LSFLAG		;RESET FLAG
10$:	TST	(R0)		;SEE IF AT AN EMPTY SLOT
	BEQ	20$		;BRANCH IF SO
	CALL	LSYBMP		;BUMP TO NEXT SLOT
	BR	10$		;TRY AGAIN
20$:	CALL	LSYBMP		;BUMP PAST EMPTY, IT DELIMITS PREV BLOCK
	MOV	R1,LSYBLK	;SET NEW BLOCK
30$:	TST	(R0)		;GET NEXT LOCAL SYMBOL VALUE
	BEQ	40$		;BRANCH IF END OF BLOCK, NOT FOUND
	CMP	(R0),SYMBOL+2	;COMPARE TO OUR SYMBOL
	BEQ	40$		;BRANCH IF FOUND, EXIT POINTING AT IT
	CALL	LSYBMP		;BUMP LOCAL SYMBOL TABLE POINTER
	BR	30$		;REITERATE

40$:	MOV	R0,LSYRLP	;SET POINTER TO REAL ADDR OF SYMBOL
	MOV	(R0)+,-(SP)	;SAVE TABLE KEY, BUMP POINTER
	MOV	(R0)+,FLAGS	;COPY FLAGS AND SECTOR
	MOV	(R0)+,VALUE	;COPY VALUE
	MOV	(SP)+,R0	;SET Z IF NOT FOUND, VALUE AND FLAGS CLEARED
	RETURN

;+
; LINSRT
; SET VALUE OF CURRENT LOCAL SYMBOL AT LABEL DEFINITION TIME
; CALL WITH LSYRLP SET BY LSRCH.
; WARNING: ASSUMES PAGE IS STILL RESIDENT
;-

LINSRT::WMCPG			;WRITE MARK OUR CURRENT PAGE
	MOV	LSYRLP,R0	;NOW GET REAL ADDR
	MOV	#SYMBOL+2,R2	;POINT AT SYMBOL SCRATCHPAD
	MOV	(R2)+,(R0)+	;STORE LOCAL SYMBOL
	MOV	(R2)+,(R0)+	;FLAGS AND SECTOR
	MOV	(R2)+,(R0)+	;VALUE
	RETURN

;INTERNAL ROUTINE TO BUMP TO NEXT LOCAL SYMBOL TABLE ENTRY
;IF CROSSES PAGE BOUNDRY, THE NEW PAGE IS FETCHED.

LSYBMP:	ADD	#6,R0		;BUMP REAL BYTE POINTER
	ADD	#3,R1		;BUMP VIRTUAL POINTER
	CMPB	#377,R1		;SEE IF AT END OF PAGE
	BNE	10$		;BRANCH TO RETURN IF NO
	TST	(R0)		;SEE IF LINK TO NEW PAGE EXISTS
	BNE	20$		;BRANCH IF YES
	MOV	R0,-(SP)	;SAVE POINTER TO LINK
	WMCPG			;WRITE MARK CURRENT PAGE
	ALPAG			;ALLOCATE FRESH PAGE
	MOV	R1,@(SP)+	;SET LINK TO NEW PAGE
				; ABOVE ASSUMES FORMER PAGE STILL RESIDENT
10$:	RETURN			;RETURN R0,R1 ADDRESSING NEXT SLOT
20$:	MOV	(R0),R1		;GET VIRTUAL LINK
	CVRL			;GET REAL ADDR
	RETURN

;+
; LOCAL SYMBOL DATA
;-

	.PSECT	IMPPAS,D,GBL,RW
LSFLAG::.BLKB	1		;CLEARED WHEN NEW BLOCK IS NEEDED
	.BLKB	1		;Reserved space
LSGBAS::.BLKW	1		;Base for auto-generated local symbols
LSYBLK::.BLKW	1		;POINTER TO START OF CURRENT LOCAL SYM BLOCK
LSYRLP:	.BLKW	1		;SAVED REAL ADDR OF CURRENT SYMBOL FOR LABEL
				; DEFINITIONS

.IF	DF,RT11			;If RT-11

	.PSECT	IMPURE,D,GBL,RW

.IFF;	DF,RT11			;If RT-11

	.PSECT	IMPURE,D,RW

.ENDC;	DF,RT11			;If RT-11

LSYBAS::.BLKW	1		;INITIALLY ALLOCATED LOCAL SYMBOL PAGE

	PURE	PUREI,I

	.ENDC


;+
; OSRCH
; SEARCH PERMANENT/MACRO NAME SYMBOL TABLE
;-

OSRCH::	MOV	$HPSBS,HSHBAS	;SET BASE PAGE ADDR FOR PST
	MOV	$HPSLM,R0	;SET LIMIT OF PRIMARY PAGES TO SEARCH
	MOV	#$HPOFL,OVFLPG	;SET POINTER TO OVERFLOW PAGE POINTER
	MOV	#PSTROL,ROLNDX	;ASSUME PERMANENT SYMBOL FOR CREF
	BR	SRCH		;NOW DO THE SEARCH

;+
; SSRCH
; SEARCH USER SYMBOL TABLE OR THE DEFAULT REGISTER LIST
; EXIT WITH Z SET IF NOT FOUND
; SYMRLP AND SYMVRP ARE SET TO THE REAL AND VIRTUAL ADDRESSES OF
; THE SYMBOL
;-
	.ENABL	LSB

	N$PRBS==8.		;NUMBER OF PROBES TO TRY PER PAGE

SSRCH::	BIT	#1007,SYMBOL	;HACK TO BYPASS MOST REGISTER ROLL SCANS
				; THESE BITS ARE OFF IN ALL RAD50 REG NAMES
	BNE	20$		;BRANCH IF NOT POSSIBLE REGISTER
	TST	SYMBOL+2	;TEST IF POSSIBLE REG
	BNE	20$		;BRANCH IF NOT
	BIT	#ED.REG,EDMASK	;TEST IF REGISTERS ENABLED
	BNE	20$		;BRANCH IF NO, SEARCH USER TABLE

	CLR	SYMRLP		;FLAG NO USER SYMBOL IN CASE OF
				; POSSIBLE INSERT
	MOV	#REGNMS,R0	;POINT AT LIST OF NAMES
	MOV	#7,VALUE	;SET INITIAL VALUE TO PC
10$:	CMP	SYMBOL,(R0)+
	BEQ	95$		;BRANCH IF FOUND			;JR
	DEC	VALUE		;SEE IF STILL IN RANGE
	BPL	10$		;YES, TRY AGAIN
				;FALL IN TO SEARCH NORMAL SYMBOL TABLE

20$:	MOV	$HSYBS,HSHBAS	;SET BASE PAGE
	MOV	$HSYLM,R0	;SET PRIMARY PAGE LIMIT
	MOV	#$HSOFL,OVFLPG	;SET POINTER TO OVERFLOW POINTER
	MOV	#SYMLST,ROLNDX	;SET TO USER SYMBOL FOR CREF

SRCH:	SAVREG			;PRESERVE R1-R4
	CALL	HASH		;COMPUTE HASH INDEXES
	BIC	#^C<177*400>,R1	;USE 7 BIT HASH INDEX
				; MAY WANT TO OPTIMIZE ABOVE CALCULATION ;JR
30$:	SUB	R0,R1		;SEE IF WITHIN ALLOCATION
	BCC	30$		;BRANCH IF NO
	ADD	R0,R1		;RESTORE THE INDEX
	ADD	HSHBAS,R1	;PAGES START AT NONZERO ADDRESS
40$:	CVRL			;GET REAL ADDR OF PAGE
50$:	MOV	#N$PRBS,PRBCNT	;SET RETRY COUNT
60$:	ADD	R4,R3		;POINT TO NEXT ENTRY
	BIC	#^C770,R3	;OFFSET MODULO 64. 8. BYTE ENTRIES
	BEQ	60$		;BRANCH IF HAPPENS TO BE LINK WORD
	ADD	R3,R0		;OFFSET INTO CURRENT PAGE
	MOV	(R0),R2		;SEE IF POINTING AT EMPTY
	BEQ	110$		;BRANCH IF YES, NOT FOUND
	CMP	SYMBOL,R2	;COMPARE FIRST WORD
	BNE	70$		;BRANCH IF NO MATCH
	CMP	SYMBOL+2,2(R0)	;TRY SECOND WORD
	BEQ	110$		;BRANCH IF MATCH, RETURN TO CALLER
70$:	SUB	R3,R0		;REMOVE OFFSET INTO PAGE
	DEC	PRBCNT		;REDUCE PROBE COUNTER
	BNE	60$		;TRY AGAIN
	MOV	R1,R2		;COPY CURRENT VIRTUAL ADDR
	MOV	(R0),R1		;GET VIRTUAL LINK WORD
	BNE	40$		;BRANCH IF HAVE OVERFLOW PAGE ALLOCATED
	WMCPG			;WRITE MARK CURRENT PAGE NOW
	MOV	R0,-(SP)	;SAVE REAL POINTER TO LINK WORD
	CMP	R2,@OVFLPG	;SEE IF PREV PAGE WAS CURRENT OVERFLOW PAGE
	BEQ	80$		;BRANCH IF YES, MUST ALLOCATE NEW ONE
	MOV	@OVFLPG,R1	;TEST IF OVERFLOW PAGE ALLOCATED YET
	BNE	90$		;BRANCH IF HAVE ONE
80$:	ALPAG			;ALLOCATE FRESH PAGE
	MOV	R1,@OVFLPG	;SAVE POINTER TO IT
90$:	MOV	R1,@(SP)+	;SET LINK IN PREV PAGE
				; ASSUMES PREV PAGE STILL RESIDENT
	BR	40$		;CONTINUE SEARCHING

95$:	.IF NDF	XRGERR							;JR+
	MOV	VALUE,REGVAL	;SAVE REGISTER VALUE FOR POSSIBLE "R" ERROR
	.ENDC			;(XRGERR)				;JR-

100$:	MOV	#DEFFLG+REGFLG,MODE ;SET TYPE OF SYMBOL TO REG
	MOV	#REGROL,ROLNDX	;SET SYMBOL TYPE TO REG FOR CREF
	RETURN			;Z CLEAR MEANS FOUND MATCH

110$:	MOV	R0,SYMRLP	;SET REAL POINTER TO SYMBOL FOR POSSIBLE
				; INSERT
	ASR	R3		;CALCULATE VIRTUAL ADDR OF SYMBOL
	ADD	R3,R1
	MOV	R1,SYMVRP	;SET VIRTUAL POINTER AS WELL
	CMP	(R0)+,(R0)+	;POINT AT FLAGS AND VALUE
	MOV	(R0)+,MODE	;SET FLAGS IN SYMBOL SCRATCHPAD
	MOV	(R0)+,VALUE	;SET VALUE
	MOV	@SYMRLP,R0	;SET Z IF NOT FOUND, WE ARE AT AN EMPTY SLOT
SRETN:	RETURN

	.DSABL	LSB

	PURE	DPURE,D

REGNMS:	.IRP	R <PC,SP,R5,R4,R3,R2,R1,R0>
	.RAD50	/R/
	.ENDR

	PURE	PUREI,I

	.ENABL	LSB
;+
; VINSRT
; INSERT SYMBOL TABLE DEFINITION VIA VIRTUAL POINTER
; DOES NOT ASSUME PAGE IS STILL RESIDENT, FOR MACRO DEFINITIONS
; SYMVRP SET TO VIRTUAL ADDR OF SYMBOL.
;-

VINSRT::SAVREG			;PRESERVE R1-R4
	MOV	SYMVRP,R1	;GET SAVED VIRTUAL ADDRESS
	CVRL			;GET REAL ADDR
	MOV	R0,R2		;COPY REAL ADDR
	BR	5$		;FINISH IN INSERT ROUTINE

;+
; SINSRT
; INSERT DEFINITION INTO USER SYMBOL TABLE
; CALLED BY ASSIGNMENT OR LABEL PROCESSORS
; ASSUMES PAGE IS STILL RESIDENT; BE CAREFULL.
;-

SINSRT::SAVREG			;PRESERVE R1-R4
	MOV	SYMRLP,R2	;GET POINTER TO SYMBOL
	BEQ	10$		;BRANCH IF WAS REGISTER ROLL
5$:	WMCPG			;WRITE MARK THE PAGE
	MOV	#SYMBOL,R1	;SET SOURCE POINTER FOR MOVE
	JMP	XMIT4		;MOVE THE SYMBOL INTO THE HASH TABLE,
				; RESTORE REGS, EXIT

10$:	.IF NDF	XRGERR		;TEST FOR INVALID REG REDEFINITION	;JR+
	CMP	#DEFFLG+REGFLG,MODE ;TEST IF CONSISTENT MODE
	BNE	20$		;BRANCH IF NOT, GIVE "R" ERROR
	CMP	REGVAL,VALUE	;TEST IF CONSISTENT VALUE
	BEQ	30$		;BRANCH IF SO, USER'S REG DEFINITION IS OK
20$:	ERROR	R		;ELSE GIVE "R" ERROR
30$:
	.ENDC			;(XRGERR)
	RETURN			;EXIT					;JR-

	.DSABL	LSB
;+
; HASH FUNCTION (UNNECESSARILY ELABORATE AT PRESENT)
;-

HASH:	MOV	SYMBOL,R3	;GET HI ORDER
	MOV	SYMBOL+2,R4	;GET LO ORDER
	MOV	R3,R1		;COPY HIGH ORDER
	SWAB	R1
	ADD	R4,R1
	ROL	R1
	ADD	R3,R1		;SETS HIGH BYTE TO PRIMARY INDEX
	ROR	R4
	ADD	R1,R4
	BIS	#10,R4		;ODD INDEX INTO 64 ENTRY PAGE
	RETURN

;+
; HASH TABLE STORAGE
;-

.IF	DF,RT11			;If RT-11

	.PSECT	IMPURE,D,GBL,RW

.IFF;	DF,RT11			;If RT-11

	.PSECT	IMPURE,D,RW

.ENDC;	DF,RT11			;If RT-11

HSHBAS:	.BLKW	1		;VIRTUAL ADDR OF BASE OF PRIMARY ALLOCATION
SYMRLP:	.BLKW	1		;SAVED REAL ADDR OF SYMBOL SLOT FOR INSERTS
SYMVRP::.BLKW	1		;SAVED VIRTUAL ADDR OF SYMBOL SLOT FOR INSERTS
OVFLPG:	.BLKW	1		;POINTER TO VIRTUAL ADDR OF CURRENT
				; OVERFLOW PAGE
PRBCNT:	.BLKW	1		;PROBE COUNTER
	.IF NDF	XRGERR		;					;JR+
REGVAL:	.BLKW	1
	.ENDC			;(XRGERR)				;JR-

	PURE	PUREI,I


;
; SEARCH  SCAN A VIRTUAL MEMORY LIST
;
;
;	IF A REAL MEMORY TABLE IS CONCERNED, A BINARY SEARCH IS
;	PERFORMED.  FOR THIS THE TABLE ENTRIES MUST BE 4-WORDS LONG.
;

SEARCH::SETROL			;BINARY SEARCH
	CMP	R5,#VM$LST	;++021 IS THIS A VIRTUAL MEMORY LIST?
	BLE	VSCAN		;++021 IF LE YES
	HALT			;UNREACHABLE, FOR NOW	***TEMP***
;
; **-NEXT--GET NEXT ENTRY IN (VIRTUAL MEMORY) LIST
;

NEXT::	CALL	SETLST		;++021 SETUP FOR LIST OPERATIONS
	MOV	$LSPNT,R1	;++021 GET VIRT LOCN OF CURRENT ENTRY
	BNE	100$		;++021 IF NE NOT AT START OF LIST
	MOV	$LSBAS(R5),R1	;++021 ELSE, GET VIRT LOCN OF 1ST ENTRY
	BEQ	SCANXF		;++021 IF EQ LIST IS EMPTY--EXIT FAIL
	BR	200$		;++021 ELSE, BRANCH INTO COMMON CODE
100$:	CVRL			;++021 GET REAL ADDR OF ENTRY IN R0
	TST	(R0)		;++021 TEST FOR END OF LIST
	BEQ	SCANXF		;++021 IF EQ END--EXIT FAIL
	MOV	(R0),R1		;++021 ELSE, GET VIRT LOCN OF NEXT ENTRY
200$:	CVRL			;++021 GET REAL ADDR OF NEXT ENTRY
	BR	VSCANX		;++021 USE COMMON SUCCESS EXIT CODE

VSCAN:	CLR	-(SP)		;++021 USE LISTHEAD AS VIRT LOCN OF PREV
	TST	R1		;++021 CHECK VIRT LOCN OF FIRST ENTRY
	BEQ	200$		;++021 IF EQ EMPTY LIST--EXIT FAIL
50$:	CVRL			;++021 GET REAL ADDR OF ENTRY IN R0
	CMP	2(R0),(R4)	;++021 COMPARE W/ 1ST HALF OF SYMBOL
	BNE	100$		;++021 IF NE NO MATCH
	CMP	4(R0),2(R4)	;++021 COMPARE W/ 2ND HALF OF SYMBOL
	BEQ	300$		;++021 IF EQ MATCH--EXIT SUCCESS

	.IF DF XMACRO		;++025

100$:	BHI	200$		;++025	IF HI NOT IN TABLE--EXIT FAIL

	.IFF			;++025

100$:	BLO	110$		;++025 IF LO MAY BE IN TABLE
	CMP	#DMALST,R5	;++025 SEARCHING DUMMY ARGUMENT ROLL?
	BNE	200$		;++025 IF NE NO--EXIT FAIL
110$:				;++025 REF LABEL
	.ENDC			;++025

	MOV	R1,(SP)		;++021 ELSE, SAVE THIS VIRT LOCN (FOR
				;++021 NEXT PREVIOUS ENTRY)
	MOV	(R0),R1		;++021 GET VIRT LOCN OF NEXT ENTRY
	BNE	50$		;++021 IF NE NOT AT END OF LIST
200$:	CLR	R0		;++021 SET FAILURE INDICATOR
	MOV	(SP),R1		;++021 RETURN VIRT LOCN OF PREV ENTRY
300$:	TST	(SP)+		;++021 CLEAN STACK

VSCANX:	MOV	R1,$LSPNT	;++021 RETURN VIRT LOCN OF A LIST ENTRY
	MOV	R0,$LSFLG	;++021 SAVE SUCCESS/FAIL INDICATOR
	BEQ	SCANYF		;++021 IF EQ FAIL, USE COMMON EXIT CODE
	MOV	R0,R1		;++021 ELSE, PUT REAL ADDR OF ENTRY IN R0
	TST	(R1)+		;++021 BYPASS LINK WORD
	BR	SCANY		;++021 USE COMMON EXIT CODE

;
; **-SCANW--SCAN (REAL MEMORY) TABLE FOR 1-WORD MATCH
;

SCANW::	SETROL			;SCAN ONE WORD
	CLR	R0		;ASSUME FALSE
1$:	INC	R0		;TALLY ENTRY COUNT
	CMP	(R4),(R1)	;MATCH?
	BEQ	SCANY		;  YES
	ADD	R3,R1		;NO, INCREMENT POINTER
	CMP	R1,R2		;FINISHED?
	BLO	1$		;  NO
EXITF:	CLR	R0		;++017 SET FAIL INDICATOR
RTN:	RETURN			;++017

;
; RANDOM SEARCH EXIT CODE
;

SCANXF:	CLR	R0		;FALSE EXIT
SCANX:	MOV	R1,ROLPNT	;SET ENTRY POINTER
	MOV	R0,ROLUPD	;SAVE FLAG
	BEQ	SCANYF		;++021 BRANCH IF NOT FOUND
SCANY:	MOV	R4,R2		;POINTER TO "SYMBOL"
	NEG	R3		;NEGATE ENTRY SIZE
	JMP	XMIT0(R3)	;FOUND, XFER ARGUMENTS

SCANYF:	CMP	(R4)+,(R4)+	;++021 BYPASS THE SYMBOL NAME
	ASR	R3		;GET WORD COUNT
	SUB	#2,R3		;COMPENSATE FOR ABOVE CMP
	BLE	3$		;BRANCH IF END
2$:	CLR	(R4)+		;CLEAR WORD
	SOB	R3,2$
3$:	RETURN

;
; **-APPEND--PLACE A NEW ENTRY AT END OF (VIRTUAL MEMORY) LIST
;

APPEND::CALL	SETLST		;++021 SETUP FOR LIST OPERATIONS
	MOV	R2,$LSPNT	;++021 SET LIST POINTER TO END
	CLR	$LSFLG		;++021 SET SEARCH FAIL FLAG FOR INSERT
	BR	INSERF

;
; **-INSERT--PLACE OR REPLACE AN ENTRY IN (VIRTUAL MEMORY) LIST
;

INSERT::CALL	SETLSA		;++021 SETUP FOR LIST OPERATIONS

INSERF:	MOV	$LSPNT,-(SP)	;++021 SAVE VIRT LOCN OF LIST ENTRY
	BNE	100$		;++021 IF NE NOT AT START OF LIST
	MOV	R5,R0		;++021 ELSE, POINT R0 TO THE ...
	ADD	#$LSBAS,R0	;++021 LIST HEAD
	BR	200$		;++021 BRANCH INTO COMMON CODE
100$:	MOV	(SP),R1		;++021 GET VIRT LOCN OF ENTRY IN R1
	CVRL			;++021 GET ITS REAL ADDR IN R0
	TST	$LSFLG		;++021 IS THIS INSERT OR REPLACE?
	BEQ	200$		;++029 IF EQ INSERT
	TST	(R0)+		;++029 BYPASS LINK WORD
	CLR	R1		;++029 INITIALIZE SIZE
150$:	TST	(R1)+		;++029 INCREMENT SIZE BY WORD
	CMP	R1,R3		;++029 ENTIRE ENTRY COMPARED?
	BGT	SETRTN		;++029 IF GT YES -- DON'T REPLACE
	CMP	(R0)+,(R4)+	;++029 DOES THE ENTRY MATCH?
	BEQ	150$		;++029 IF EQ YES
	SUB	R1,R0		;++029 NO, ADJUST ENTRY POINTERS
	SUB	R1,R4		;++029
	BR	315$		;++029 REPLACE ENTRY IN LIST
200$:	MOV	R0,-(SP)	;++021 INSERT--SAVE REAL ADDR OF LINK
	CMP	R5,#ZP$LST	;++021 CAN THIS LIST BE 'ZAPPED'
	BLE	210$		;++021 IF LE NO
	MOV	ZAPLST,R1	;++021 YES, GET VIRT LOCN OF A FREE BLOCK
	BEQ	210$		;++021 IF EQ FREE LIST IS EMPTY
	CVRL			;++021 ELSE, GET ITS REAL ADDR IN R0
	MOV	(R0),ZAPLST	;++021 REMOVE ENTRY FROM LIST
	WMCPG			;++021 MARK ITS PAGE DIRTY (IN ADVANCE)
	BR	220$		;++021 BRANCH INTO COMMON CODE
210$:	MOV	R3,R1		;++021 GET SIZE OF ENTRY NEEDED
	ADD	#2,R1		;++021 ACCOUNT FOR EXTRA LINK WORD
	ALVRT			;ALLOC A BLOCK FROM VIRT MEMORY
220$:	MOV	@(SP),(R0)	;++021 LINK BLOCK TO NEXT ENTRY
	MOV	R1,@(SP)+	;++021 LINK BLOCK TO PREVIOUS ENTRY
	INC	$LSCNT(R5)	;++021 INCREMENT LIST ENTRY COUNT
	CMP	(SP),$LSTOP(R5)	;++021 WAS PREVIOUS ENTRY END OF LIST?
	BNE	300$		;++021 IF NE NO
	MOV	R1,$LSTOP(R5)	;++021 ELSE, RESET END OF LIST POINTER
300$:	TST	(SP)		;++021 WAS PREVIOUS ENTRY THE LIST HEAD?
	BNE	310$		;++021 IF NE NO
	MOV	R1,$LSBAS(R5)	;++021 ELSE, RESET START OF LIST POINTER
310$:	TST	(R0)+		;++021 BYPASS ENTRY LINK WORD
315$:	ASR	R3		;++021 CONVERT ENTRY SIZE TO WORDS
320$:	MOV	(R4)+,(R0)+	;++021 COPY DATA INTO NEW LIST ENTRY
	SOB	R3,320$		;++021
	MOV	(SP)+,R1	;++021 GET VIRT LOCN OF MODIFIED ENTRY
;	BEQ	400$		;++021 IF EQ IT WAS LIST HEAD
	BEQ	INSRTN		;++ IF EQ IT WAS LIST HEAD
	WRMPG			;++021 MARK ITS PAGE DIRTY

;400$:	CMP	R5,#LSYLST	;++ IS THIS THE SYMBOL (USER/LOCAL) TABLE?
;	BHI	INSRTN		;++ IF BHI NO
;	MOV	$LSBAS(R5),@SUBLHD  ;++021 ELSE, UPDATE SUB-LIST POINTER

INSRTN:	RETURN			;++021

;
; **-ZAP--EMPTY A (VIRTUAL MEMORY) LIST
;

ZAP::	MOV	R1,-(SP)	;++021 SAVE R1
	MOV	$LSTOP(R0),R1	;++021 PUT VIRT LOCN OF LAST ENTRY IN R1
	BEQ	200$		;++021 IF EQ LIST IS EMPTY
	MOV	R3,-(SP)	;++021 ELSE, SAVE R3
	MOV	$LSBAS(R0),-(SP)  ;++021 SAVE VIRT LOCN OF FIRST ENTRY
	CLR	$LSBAS(R0)	;++021 CLEAR START OF LIST POINTER
	CLR	$LSTOP(R0)	;++021 CLEAR END OF LIST POINTER
	CLR	$LSCNT(R0)	;++021 CLEAR LIST ENTRY COUNT
	MOV	ZAPLST,R3	;++021 GET VIRT LOCN OF FIRST FREE BLOCK
	BEQ	100$		;++021 IF EQ FREE LIST IS EMPTY
	CVRL2			;++021 ELSE, GET REAL ADDR OF LAST ...
				;++021 ENTRY IN LIST TO ZAP
	MOV	R3,(R0)		;++021 LINK IT TO START OF FREE LIST
	WMCPG			;++021 MARK ITS PAGE DIRTY
100$:	MOV	(SP)+,ZAPLST	;++021 RESET START OF FREE LIST
	MOV	(SP)+,R3	;++021 RESTORE R3
200$:	MOV	(SP)+,R1	;++021 RESTORE R1
	RETURN			;++021


SETLST:				;++021 REF LABEL
SETROL:	MOV	R0,ROLNDX	;++017 SET ROLL NUMBER
SETLSA:				;++021 REF LABEL
SETROF:	MOV	(SP)+,R0	;++017 SAVE RETURN ADDRESS
	SAVREG			;SAVE REGISTERS
	MOV	R5,-(SP)	;  AND CURRENT CHARACTER
	MOV	ROLNDX,R5	;SET INDEX
	MOV	ROLBAS(R5),R1	;CURRENT BASE
	MOV	ROLTOP(R5),R2	;CURRENT TOP
	MOVB	ROLSIZ(R5),R3	;ENTRY SIZE
	MOV	#SYMBOL,R4	;POINTER TO SYMBOL
	CALL	(R0)		;CALL PROPER ROUTINE
SETRTN:	MOV	(SP)+,R5	;++029 RESTORE CHAR
	RETURN			;  AND REST OF REGS

.IF	NDF,RT11		;If not RT-11

	.PSECT	IMPURE,D,RW	;++017
$LSNDX::			;++021 REF LABEL
ROLNDX::.BLKW	1		;ROLL INDEX

$LSPNT::			;++021 REF LABEL
ROLPNT::.BLKW	1		;++021 LIST/ROLL INSERT POINTER

$LSFLG::			;++021 REF LABEL
ROLUPD::.BLKW	1		;ROLL UPDATE

ZAPLST:	.BLKW	1		;++021 LIST HEAD FOR FREE BLOCKS

.ENDC;	NDF,RT11		;If not RT-11


	.END
