;  DEC/CMS REPLACEMENT HISTORY, Element ENDPS.MAC
;  *5     2-SEP-1987 14:37:47 STEVENS "CHANGED .ENABL/.DSABL HEX COMMAND TO .LIST/.NLIST HEX"
;  *4    25-JUN-1987 17:39:20 STEVENS "Fixed problem of .PSECTs corrupting symbol table"
;  *3    18-AUG-1986 11:19:28 WORRALL "Complete HEX listing support for version 5.5 fieldtest"
;  *2    14-APR-1986 23:20:13 SYSTEM "Update 5.4 of MACRO-11"
;  *1    28-MAR-1986 02:35:35 SYSTEM "Load MACRO-11 sources from V5.3"
;  DEC/CMS REPLACEMENT HISTORY, Element ENDPS.MAC
	.NLIST							;Edit Level 02
	.ENABL	LC,GBL
	.LIST
	.TITLE	ENDPS - End of pass processing
	.SBTTL	ENDPS - End of pass processing
	.SBTTL
	.SBTTL		.IDENT	/V05.05/
	.SBTTL
	.IDENT	/V05.05/
;****************************************************************************
;*									    *
;*                   COPYRIGHT (c)  1983, 1986                              *
;*          BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.                *
;*                   ALL RIGHTS RESERVED.                                   *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED  *
;*  ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE  *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER  *
;*  COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY  *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY  *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE  *
;*  AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT  *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS  *
;*  SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.		    *
;*									    *
;****************************************************************************


;++
;  Facility:	MACRO-11  The PDP-11 macro assembler for RT/RSX/VMS and RSTS/E
;
;    Author:	Too many people to list here
;
;   Created:	From the dust and dirt
;
;  Abstract:	ENDPS - End of pass processing
;
;     Externals	 Description
;     ---------	 -----------
;
;      Edit	Who	Date		Description of modification
;      ----	---	----		---------------------------
;	001	Jrw	04-Nov-83	Don't call SETMAX. Allow ENDLN
;					to call SETMAX on last line.
;	002	Jrw	12-Dec-85	Add hex support conditionalized.
;--


	PURE	PUREI,I

; Local macro to move a symbol

.MACRO	MOV4	SRC,DST
.REPT	4
	MOV	SRC,DST
.ENDR
.ENDM

;+
; ENDP1
; END OF PASS1 PROCESSING
; OUTPUT MISC OBJ FILE ITEMS ALONG WITH GSD AND ISD AS REQUIRED
;-

ENDP1::				;REF LABEL
;;;	CALL	SETMAX		;SET MAX LOCATION
	TSTB	IOFTBL+BINCHN	;ANY OBJ FILE?
	BEQ	ENDP1B		;  NO
	CALL	OBJINI		;INIT OUTPUT
	MOV	#BLKT01,@BUFTBL+RELCHN	;SET BLOCK TYPE 1
	MOV	#PRGTTL,R1	;SET "FROM" INDEX
	CALL	GSDDMP		;OUTPUT GSD BLOCK
	MOV	#PRGIDN,R1	;POINT TO SUB-TTL BUFFER
	TST	4(R1)		;SET?
	BEQ	10$		;  NO
	CALL	GSDDMP		;YES, STUFF IT

10$:	CLR	$LSPNT		;SET TO SCAN THE PSECT LIST NOW
	MOV	#GSDOUT,DOSYM	;SET COROUTINE TO DUMP GSD ITEM NOW
20$:	NEXT	SECLST		;GET THE NEXT PSECT
	BEQ	EOGSD		;BRANCH IF END OF LIST SEEN
	MOV	#SECTOR,R1	;POINT AT SECTOR BYTE
	MOVB	(R1),THISEC	;SAVE THE CURRENT SECTOR WHILE WE SCAN
				; THE HASH TABLE

	MOVB	#GSDT05/400,(R1)+ ;NOW SET GSD TYPE, POINT AT LENGTH WORD
	CLR	(R1)+		;ASSUME ABS SECTION, ZERO THE LENGTH	;JR+

.IF	NE,0
.IF	NDF,RT11		;If not RT-11
	BITB	#CSTREL,MODE	;TEST IF ABS PSECT
ABSSZ==.			;GLOBAL PATCH: NOP TO PASS TKB ABS PSECT SIZES
				; THIS ALLOWS RT-11 ASSEMBLIES TO BE DONE
				; UNDER RSX FOR EMULATOR WORK.
	BEQ	11$		;BRANCH IF ABS, PASS TKB ZERO LENGTH
.ENDC;	NDF,RT11		;If not RT-11
.ENDC;	NE,0

	MOV	(R1),-(R1)	;IF REL PSECT, PUT MAX SIZE IN GSD ENTRY
11$:									;JR-

30$:	CALL	SYMDMP		;DUMP OUT THE PSECT SYMBOL
	CALL	SCANSY		;NOW SCAN THE HASH TABLE FOR MATCHING GLOBALS
	BR	20$		;REITERATE FOR NEXT PSECT
EOGSD:

ENDP1A:	BIC	#^C<RELFLG>,ENDVEC+4	;CLEAR ALL BUT REL FLAG
	BIS	#GSDT03+DEFFLG,ENDVEC+4
	MOV	#ENDVEC,R1
	CALL	GSDDMP		;OUTPUT END BLOCK
	CALL	OBJDMP		;DUMP IT

.IF	NDF,XISD
	BIT	#ED.DBG,EDMASK	;TEST IF DEBUGGING INFORMATION ENABLED
	BNE	123$		;BRANCH IF DISABLED, BYPASS ISD OUTPUT
	CALL	OUTISD		;DUMP OUT ISD RECORDS NOW
123$:
.ENDC;	NDF,XISD

	MOV	#BLKT02,@BUFTBL+RELCHN	;SET "END OF GSD"
	CALL	RLDDMP
	MOV	#BLKT04,@BUFTBL+RELCHN	;INIT FOR TEXT BLOCKS

ENDP1B:	CLR	$LSPNT		;INIT POINTER TO START OF LIST
10$:	NEXT	SECLST		;FETCH NEXT SECTOR
	BEQ	20$		;  BRANCH IF FINISHED
	CLR	VALUE		;FOUND, RESET PC
	INSERT			;PUT BACK IN TABLE
	BR	10$
20$:
30$:
	INC	PASS		;SET FOR PASS 2
ENDRTN:	RETURN

;+
; GSDOUT
; DUMP A GSD ENTRY DURING PASS 1
; ENTER WITH SYMBOL SCRATCHPAD SETUP
;-

GSDOUT::BIT	#GLBFLG,MODE	;TEST IF GLOBAL
	BEQ	ENDRTN		;BRANCH IF NO, SKIP SYMBOL
	CMPB	SECTOR,THISEC	;SEE IF MATCHING SECTOR
	BNE	ENDRTN		;BRANCH IF NO, SKIP SYMBOL
	BIC	#^C<DEFFLG!RELFLG!GLBFLG>,MODE	;CLEAR MOST BITS
	BIS	#GSDT04,MODE	;SET TYPE 4

.IF	DF,W$$EK		;If .WEAK directive

	MOV	$WEAHD,R1	;R1 -> .WEAK symbols listhead
	BEQ	SYMDMP		;Branch if listhead not setup, done.
90$:	CVRL			;Convert R1 to address in R0
	MOV	#255.,R5	;R3 -> Count of # possible entrys
95$:	TST	@R0		;End of list?
	BEQ	SYMDMP		;Branch if so, done.
	CMP	(R0)+,SYMVIR	;Is this symbol WEAK?
	BEQ	98$		;Branch if so, say so
	SOB	R5,95$		;Loop though all possible entries.
	MOV	@R0,R1		;Is there another page linked to this one?
	BNE	90$		;Branch if so, follow it!
	BR	SYMDMP		;Not a .WEAK symbol.

98$:	BIS	#1,MODE		;Set weak symbol type flag.

.ENDC;	DF,W$$EK		;If .WEAK directive
				;FALL IN TO DUMP SYMBOL

SYMDMP:	MOV	#SYMBOL,R1	;DUMP A SYMBOL GSD BLOCK
GSDDMP:				;DUMP A GSD BLOCK
	MOV	#4*2,R0		;FOUR WORDS PER GSD ENTRY
	CALL	TSTRLD		;ROOM?
	JMP	XMIT4		;WE HAVE NOW.  STUFF ENTRY


;+
; ENDP2
; FINISH OFF THE OBJ FILE, PRINT SYMBOL TABLE AND PSECT SYNOPSIS
;-

ENDP2::

.IF	NDF,RT11		;If not RT-11
	CALL	CLOSRC		;CLOSE SOURCE FILES NOW			;JR
.ENDC;	NDF,RT11		;If not RT-11

;;;	CALL	SETMAX		;SET MAX LOCATION
	TST	OBJPNT		;ANY OBJECT OUTPUT?
	BEQ	10$		;  NO
	CALL	OBJDMP		;YES, DUMP IT
	MOV	#BLKT06,@BUFTBL+RELCHN	;SET END
	CALL	RLDDMP		;DUMP IT

	.IF NDF	XEDABS
	BIT	#ED.ABS,EDMASK	;ABS OUTPUT?
	BNE	10$		;  NO
	MOV	OBJPNT,R0
	MOV	ENDVEC+6,(R0)+	;SET END VECTOR
	MOV	R0,OBJPNT
	CALL	OBJDMP
	.ENDC
10$:	TSTB	LSTDEV		;ANY LISTING OUTPUT?
	BEQ	ENDRTN		;NO, BRANCH TO LEAVE
	BIT	#LC.SYM,LCMASK	;SYMBOL TABLE SUPPRESSION?
	BNE	ENDRTN		;YES, BRANCH TO LEAVE

	MOV	#SYMTXT,R1	;GET ADDR OF SYMBOL TABLE TEXT
	MOV	#STLBUF,R2	;AND ADDR OF SUB-TITLE BUFFER
	MOVBYT			;SET SYMBOL TABLE SUB-TITLE
	CLR	LPPCNT		;FORCE NEW PAGE
;
; CHAIN THROUGH THE PSECT LIST AND MOVE THEM TO THE PERMANENT SYMBOL
; TABLE AREA SO WE MAY SHUFFLE MEMORY WHILE CONDENSING THE USER HASH TABLE
;
	CLR	$LSPNT		;START AT HEAD OF PSECT LIST
	CLR	SECCT		;CLEAR COUNT OF PSECTS
	MOV	$HPSBS,R4	;START MOVING THEM TO PST PRIMARY PAGES
20$:	MOV	R4,R1		;COPY VIRTUAL PAGE ADDR
	CVRL			;GET REAL ADDR
	LOCPG			;LOCK THE PAGE IN CORE
	WMCPG			;WRITE MARK IT TOO
	MOV	R0,R2		;MAKE WORKING REAL ADDR COPY
	MOV	#51.,R3		;SET COUNT OF PSECTS TO FIT IN A PAGE
30$:	NEXT	SECLST		;GET NEXT PSECT FROM LINKED LIST
	BEQ	40$		;BRANCH IF END OF LIST
	MOV	#SYMBOL,R1	;POINT AT SYMBOL SCRATCHPAD
	CALL	XMIT5		;MOVE SYMBOL TO NEW LOCATION
	INC	SECCT		;TALLY THE PSECT
	DEC	R3		;DOWN PSECT/PAGE COUNTER
	BNE	30$		;ITERATE IF MORE ROOM
	MOV	R4,R1
	UNLPG			;UNLOCK THE OLD PAGE NOW
	ADD	#400,R4		;POINT AT NEXT CONSECUTIVE PAGE
;	BR	20$		;REITERATE					[-GTS]
	CMP	$HSYBS,R4	;OVERFLOW?					[+GTS]
	BNE	20$		;NO, REITERATE					[+GTS]
	BR	DOSORT		;SORT ONLY 1ST 355. PSECTS			[+GTS]

40$:	MOV	R4,R1
	UNLPG			;UNLOCK THE LAST TARGET PAGE NOW

DOSORT:	CALL	SSORT		;CONDENSE AND SORT SYMBOL TABLE

	MOV	#3,R3		;ASSUME TELETYPE MODE (3 COLUMN LISTING)
	MOV	#LINBUF,R2	;BUF ADDR (IN CASE OF NULL TABLE)

	.IF NDF	XLCTTM
	BIT	#LC.TTM,LCMASK	;USING TELETYPE MODE?
	BEQ	10$		;YES, SKIP
	CMPB	(R3)+,(R3)+	;NO, UPDATE TO 5 COLUMN LISTING
	.ENDC

10$:	MOV	R3,NUMCOL	;SET NUMBER OF SYMBOL COLUMNS PER PAGE
	MOV	LINPPG,MAXROW	;CALCULATE NUMBER OF SYMBOLS IN A FULL COLUMN
	SUB	#3,MAXROW	;LESS TOP-OF-PAGE HEADING

	MOV	$HSYBS,ROWPT	;INITIALIZE THE ROW POINTER TO START OF TABLE

20$:	MOV	LSTVA,R1	;CALCULATE NUMBER OF REMAINING SYMBOLS
	SUB	ROWPT,R1
	ASR	R1
	ASR	R1
	CLR	R0		;MAKE DOUBLE WORD
	MOV	NUMCOL,R3	;GET NUMBER OF COLUMNS
	DIV	R3,R0		;DIVIDE TO GET NUMBER OF ROWS NEEDED
	MOV	R0,R3		;COPY QUOTIENT
	TST	R1		;TEST REMAINDER FOR PRINTING ROWS
	BEQ	12$		;BRANCH IF NO ODD SYMBOLS
	INC	R3		;TALLY THE EXTRA ROW IF REMAINDER
12$:	CMP	R3,MAXROW	;SEE IF WILL FIT IN PAGE
	BLE	13$		;BRANCH IF YES
	MOV	MAXROW,R3	;ELSE TRUNCATE TO MAX PAGE SIZE
	MOV	R3,R0
	CLR	R1		;CLEAR POSSIBLE REMAINDER
13$:	MOV	R3,ROWCT	;SET ROW COUNTER FOR PRINTING THE PAGE
	MOV	R1,REMCOL	;SAVE NUMBER OF REMAINDER COLUMNS
	ASL	R0		;GENERATE VIRTUAL MEMORY OFFSET TO NEXT COL
	ASL	R0
	MOV	R0,COLSEP	;SET THE COLUMN SEPERATOR

30$:	MOV	ROWPT,COLPT	;SET CURRENT COLUMN POINTER
	MOV	NUMCOL,COLCT	;SET COUNT OF COLUMNS
	MOV	REMCOL,REMCT	;SET REMAINDER FOR FUDGING EXTRA SYMBOLS

40$:	CMP	COLPT,LSTVA	;CHECK IF PAST END OF SYMBOL TABLE
	BHIS	ENDSYT		;BRANCH IF YES, FINISHED WITH SYMBOLS
	MOV	COLPT,R1	;GET THE CURRENT SYMBOL
	MOV	#4,R5		;SET NUMBER OF WORDS/SYMBOL
	CALL	MOVSYM		;MOVE SYMBOL INTO SYMBOL SCRATCHPAD
	MOV	#ENDP2T,R3
	CALL	ENDP2C
	MOV	#MODE,R1	;POINT TO MODE BITS
	BIT	#DEFFLG,(R1)	;DEFINED?
	BEQ	50$		;  NO
	CALL	SETWRD
	BR	60$
50$:	MOV	#STARS,R1
.IF	DF,YHEX
	BIT	#LC.HEX,LCMASK	;Hex mode listing?
	BNE	55$		;No
	CMPB	(R1)+,(R1)+	;Make it 4 stars, not 6
	MOVBYT			;Insert ****
	MOVB	#TAB,(R2)+	;and an extra tab to make it even
	BR	60$		;Skip ahead

.ENDC;	DF,YHEX
55$:	MOVBYT			;UNDEFINED, SUBSTITUTE ******
60$:	CALL	ENDP2C
	CALL	ENDP2X
	MOV	#SECTOR,R1
	CMPB	#1,(R1)		;ABS psect ?
	BGE	70$		;Branch if so, no sector number please.
	CMPB	-(R1),-(R1)
	CALL	SETBYT
70$:	MOVB	#TAB,(R2)+	;SEPARATOR

	ADD	COLSEP,COLPT	;BUMP POINTER TO SYMBOL IN ADJACENT COLUMN
	DEC	REMCT		;SEE IF EXTRA SYMBOL IS AT BOTTOM OF COL
	BLT	16$		;BRANCH IF NO
	BNE	17$		;BRANCH IF NOT POSSIBLE END OF SYMBOL TABLE
	CMP	#1,ROWCT	;SEE IF LAST LINE OF SYMBOLS
	BEQ	ENDSYT		;BRANCH IF YES, NOW OUTPUT PSECTS
17$:	ADD	#4,COLPT	;COMPENSATE FOR REMAINDER SYMBOLS ON LAST LINE
16$:	DEC	COLCT		;ELSE DOWN THE COLUMN COUNTER
	BNE	40$		;ITERATE IF MORE TO DO

	CALL	PRTLIN		;PRINT THE LINE NOW
	ADD	#4,ROWPT	;BUMP THE ROW POINTER TO NEXT SYMBOL DOWN
	DEC	ROWCT		;DOWN THE ROW COUNTER
	BNE	30$		;REITERATE IF MORE ROOM ON PAGE

	MOV	COLPT,-(SP)	;NOW UPDATE ROW POINTER INTO NEXT PAGE, IF ANY
	SUB	COLSEP,(SP)	;COMPENSATE FOR EXTRA COLUMN WE BUMPED
	ADD	#4,(SP)		; BUT BUMP POINTER INTO NEXT PAGE
	MOV	(SP)+,ROWPT	;
	BR	20$		;NOW REPEAT PROCEDURE ON NEXT PAGE
;
; SYMBOL TABLE IS DONE BEING PRINTED, NOW OUTPUT PSECT SYNOPSIS
;
ENDSYT:	CALL	PRTLIN		;FORCE LAST LINE OUT

ENDP2A:
	MOV	$HPSBS,SECBS	;SET POINTER TO SECTOR AREA
10$:	CALL	PRTLIN		;OUTPUT LINE
	MOV	SECBS,R1	;POINT AT START OF SECTORS WE SAVED
	MOV	#5,R5		;SET NUMBER OF WORDS TO MOVE
	CALL	MOVSYM		;MOVE SYMBOL INTO SCRATCHPAD
	MOVB	#TAB,(R2)+
	MOV	#VALUE,R1
	CALL	SETWRD		;  THE VALUE,
	MOVB	#SPACE,(R2)+	;Insert separator
	MOV	#SECTOR-2,R1
	CALL	SETBYT		;Stuff entry number
	MOVB	#TAB,(R2)+	;Insert separator
	MOVB	#'(,(R2)+	;Stuff beginning "("
	MOV	#ATRTAB,R0	;Point to list of .PSECT attribute names
12$:	MOV	(R0)+,R1	;Point to message for bit on
	BEQ	17$		;Branch if end of list, done.
	BIT	(R0)+,MODE	;Is this flag set?
	BNE	15$		;Branch if so
	MOV	@R0,R1		;Else use other message (IF THERE)
	BEQ	17$		;Branch if done (NOSAV)
15$:	MOVBYT			;Move the string
	TST	(R0)+		;Skip a pointer
	MOVB	#',,(R2)+	;Insert separator
	BR	12$		; and do next bit

17$:	MOVB	#'),-1(R2)	;Stuff trailing ")" over trailing ","
	CLRB	@R2		;Set end of line.
	ADD	#5,SECBS	;Bump pointer to next psect
	CMPB	#377,SECBS	;TEST IF AT END OF PAGE
	BNE	20$		;BRANCH IF NO
	INC	SECBS		;BUMP TO FOLLOWING PAGE IF YES
20$:	DEC	SECCT		;DOWN THE SECTOR COUNTER
	BNE	10$		;LOOP IF MORE PSECTS TO DO
				;ELSE FALL THROUGH TO PRINT LAST LINE, EXIT

; Print a line

PRTLIN:	CLRB	(R2)		;MAKE AN ASCIZ STRING
	PUTLP	#LINBUF		;PUT THE LINE ON LPT
	MOV	#LINBUF,R2	;RESET TO START OF BUFFER
ENDP2D:	RETURN

ENDP2C:	CALL	(PC)
ENDP2X:	MOV	(R3)+,R0
	BIT	(R3)+,MODE
	BNE	10$
	SWAB	R0
10$:	MOVB	R0,(R2)+
	RETURN

;+
; MOVE SYMBOL FROM VIRTUAL MEMORY TO SCRATCHPAD BUFFER
;-

MOVSYM:	MOV	R2,-(SP)	;SAVE PRINT LINE POINTER
	CVRL			;GET REAL ADDR OF SYMBOL
	MOV	#SYMBOL,R2	;POINT AT SYMBOL SCRATCHPAD
10$:	MOV	(R0)+,(R2)+	;SHIFT THE SYMBOL IN
	DEC	R5		;DOWN COUNT OF WORDS TO MOVE
	BNE	10$		;ITERATE IF MORE
	MOV	(SP)+,R2	;RESTORE LINE POINTER
	JMP	R50UNP		;UNPACK SYMBOL TO LINE, RETURN


.MACRO	ATR	FLAG,SET,CLR,?A,?B
.ENABL LSB
	PURE	DPURE,D
.IF	NB,SET
.IF	NB,CLR
	.WORD	A,FLAG,B
	PURE	TXTBYT,D
A:	.ASCIZ	/SET/
B:	.ASCIZ	/CLR/
.IFF;	NB,CLR
	.WORD	A,FLAG,0
	PURE	TXTBYT,D
A:	.ASCIZ	/SET/
.ENDC;	NB,CLR
.IFF;	NB,SET
.IF	NB,CLR
	.WORD	0,FLAG,B
	PURE	TXTBYT,D
B:	.ASCIZ	/CLR/
.IFF;	NB,CLR
	.ERROR	;MACRO ATR called with both SET and CLR args missing!
.ENDC;	NB,CLR
.ENDC;	NB,SET
.DSABL LSB
.ENDM	ATR


	PURE	DPURE,D

ATRTAB:	ATR	CSTACC,RO,RW
	ATR	CSTTYP,D,I
	ATR	CSTGBL,GBL,LCL
	ATR	CSTREL,REL,ABS
	ATR	CSTALO,OVR,CON
	ATR	CSTSAV,SAV

	PURE	DPURE,D
	.WORD	0		;Terminator for DPURE list.

ENDP2T:	.ASCII	/ =/
	.WORD	LBLFLG
	.ASCII	/% /
	.WORD	REGFLG
	.ASCII	/R /
	.WORD	RELFLG
	.ASCII	/G /
	.WORD	GLBFLG
	.ASCII	/X /
	.WORD	DFGFLG

	PURE	TXTBYT,D
								;[+GTS]
.IF NDF RT11							;[+GTS]
								;[+GTS]
;+								;[+GTS]
; .ASCID							;[+GTS]
; Generate a ASCII descriptor string.				;[+GTS]
;-								;[+GTS]
								;[+GTS]
.MACRO	.ASCID	STRING						;[+GTS]
	.NCHR	......,<STRING>					;[+GTS]
	.BYTE	......						;[+GTS]
	.ASCII	~STRING~					;[+GTS]
.ENDM	.ASCID							;[+GTS]
								;[+GTS]
INTERR:	.ASCID	< -- Internal error>				;[+GTS]
								;[+GTS]
.IFF;	NDF,RT11		;If not RT-11			;[+GTS]
								;[+GTS]
INTERR:	.ASCIZ	/?MACRO-F-Internal error/			;[+GTS]
								;[+GTS]
.ENDC								;[+GTS]
								;[+GTS]
SYMTXT:	.ASCIZ	/Symbol table/		;Header for symbol table.
STARS:	.ASCIZ	/******/		;For undefined value field printing


;+
; SSORT
; PERFORM SHELL SORT ON SYMBOL TABLE
; THE INCREMENTS USED ARE FORMED BY THE RECURRANCE N(K+1)=3*N(K)+1
;+
	PURE	PUREI,I
SSORT::	CALL	SCANSY		;CONDENSE THE TABLE FIRST

	MOV	LSTVA,R1	;CALCULATE SIZE OF TABLE
	SUB	$HSYBS,R1
	BEQ	NOSYMS		;BRANCH IF NO SYMBOLS

	CLR	-(SP)		;CREATE LIST OF INCREMENTS ON STACK
10$:	MOV	(SP),R2
	MOV	R2,-(SP)
	ASL	R2
	ADD	R2,(SP)
	ADD	#4,(SP)		;N(K+1)=3*N(K)+1
	CMP	(SP),R1
	BLO	10$		;BRANCH IF INCREMENT STILL IN RANGE

20$:	TST	(SP)+		;JUNK THE PREVIOUS INCREMENT
	MOV	(SP),R1		;GET THE NEXT SMALLER INCREMENT
	BEQ	FINSRT		;BRANCH IF SORT FINISHED
	ADD	$HSYBS,R1	;POINT INTO ARRAY, J=H TO N-1 BY 1
				; H IS ON THE STACK
30$:	MOV	R1,-(SP)	;STACK THE POINTER TO N(J)
	CVRL
	WMCPG
	MOV	R1,R3		;J2=J
	MOV	R0,R4
	ADD	#10,R0		;PREPARE TO COPY N(J2)
	MOV4	-(R0),-(SP)	;STACK V=N(J2)

40$:	SUB	12(SP),R1	;J1=J2-H
	BLO	60$		;BRANCH IF PASSED BEGINNING OF VIRTUAL MEMORY
	CMP	R1,$HSYBS
	BLO	60$		;BRANCH IF PAST BEGINNING OF ARRAY
	CVRL			;GET REAL ADDR AND WRITE MARK PAGE AT ONCE
	WMCPG
	CMP	(SP),(R0)	;COMPARE V TO N(J1)
	BNE	50$
	CMP	2(SP),2(R0)
50$:	BHIS	60$		;BRANCH IF V>N(J1)
	MOV4	(R0)+,(R4)+	;ELSE MOVE N(J2)=N(J1)
	SUB	#10,R0
	MOV	R0,R4
	MOV	R1,R3		;J2=J1
	BR	40$

60$:	MOV4	(SP)+,(R4)+	;NOW MOVE V BACK INTO ARRAY, N(J2)=V
	MOV	(SP)+,R1	;GET J FROM STACK
	ADD	#4,R1		;MOVE J UP ONE ENTRY, J=J+1
	CMP	R1,LSTVA
	BNE	30$		;ITERATE WHILE  J.NE.N

	BR	20$		;REPEAT FOR NEXT INCREMENT

FINSRT:	TST	(SP)+		;DISCARD THE LAST INCREMENT

NOSYMS:	RETURN

;+
; SCAN THE HASH TABLE IN ORDER OF ASCENDING PAGE ADDRESSES
; IF PASS1, LOOK FOR GLOBAL SYMBOLS
; IF PASS2, CONDENSE THE SYMBOL TABLE FOR SUBSEQUENT SORTING IN PLACE
; INITIALLY, CREATE A SORTED LIST OF OVERFLOW BLOCKS ON THE STACK
; (THIS SHOULD BE ELIMINATED BY LINKING THE PAGES AT ALLOCATION TIME)
;-

SCANSY::MOV	$HSYBS,R1
	MOV	R1,CURVA	;SET POINTER TO CURRENT VIRT ADDR
	ADD	$HSYLM,R1	;VIRT POINTER TO END OF PRIMARY PAGES
	MOV	R1,LSTVA

	MOV	#-1,-(SP)	;STACK DELIMITER MARKERS
	CLR	-(SP)

10$:	MOV	CURVA,R1	;GET NEXT PRIMARY PAGE
	CMP	R1,LSTVA	;SEE IF PAST END
	BEQ	CONDNS		;BRANCH IF YES
20$:	CVRL
	MOV	(R0),R1
	BEQ	50$		;GO TO NEXT PRIMARY PAGE IF END OF CHAIN
	MOV	SP,R2		;POINT AT NULL ENTRY IN STACK
30$:	TST	(R2)+		;SCAN LIST FOR PROPER SLOT
	CMP	R1,(R2)
	BHI	30$		;LOOP IF BLOCK GOES FURTHER DOWN
	BEQ	20$		;IGNORE IF IN LIST ALREADY
	TST	-(R2)		;POINT R2 BACK TO PROPER SLOT FOR THIS PAGE
	MOV	SP,R5
	CLR	-(SP)		;MAKE ROOM FOR NEW ENTRY BY SHIFTING
				; PRECEDING ENTRIES UP
	MOV	SP,R4
40$:	MOV	(R5)+,(R4)+	;SHIFT AN ENTRY UP
	CMP	R4,R2
	BNE	40$		;KEEP GOING IF MORE TO SHIFT
	MOV	R1,(R2)		;INSERT NEW BLOCK IN PLACE
	BR	20$
50$:	INCB	CURVA+1		;BUMP VIRTUAL PAGE ADDR BY ONE
	BR	10$		;ITERATE

;+
; CONDNS
; CONDENSE THE HASH TABLE TO A SET OF CONTIGUOUS PAGES FOR SORTING, OR
; SCAN FOR GLOBALS WHILE DUMPING GSD
;-

CONDNS::TST	(SP)+		;DISCARD THE NULL MARKER
	MOV	$HSYBS,R1	;INITIALIZE TARGET PAGE POINTER AND COUNTER
	TST	PASS		;TEST IF SORT OR GSD DUMP
	BEQ	10$		;BRANCH IF PASS 1, GSD DUMP IN PROGRESS
	CALL	SETTGT		;SET THE FIRST TARGET PAGE UP
10$:	MOV	R1,SRCPG	;SET NEW SOURCE PAGE
	CVRL			;GET REAL POINTER AND LOCK IN CORE
	LOCPG
.IF	DF,W$$EK		;If .WEAK directive
	MOV	R0,SYMLOC	;Save real symbol location base
.IFTF;	DF,W$$EK		;If .WEAK directive
	MOV	R0,R5		;COPY REAL POINTER
	MOV	#64.,SRCCT
20$:	ADD	#8.,R5
	BR	40$
30$:	TST	(R5)		;TEST IF NULL ENTRY OR NOT
	BEQ	20$		;BRANCH IF NULL ENTRY
	TST	PASS		;TEST IF PASS 1
	BNE	35$		;BRANCH IF NO, CONDENSE TABLE
;
; DUMP A GSD OR ISD ENTRY DURING PASS 1
;
.IFT;	DF,W$$EK		;If .WEAK directive

	MOV	R5,R4		;R4 -> Current symbol entry
	SUB	SYMLOC,R4	;R4 = Byte bias from start of page
	ASR	R4		;R4 = Virtual bias from start of page
	ADD	SRCPG,R4	;R4 = Virtual address of this symbol
	MOV	R4,SYMVIR	;Save virtual symbol address

.ENDC;	DF,W$$EK		;If .WEAK directive

	MOV	#SYMBOL,R4	;POINT AT SYMBOL SCRATCHPAD
	MOV4	(R5)+,(R4)+	;GET SYMBOL
	MOV	R5,-(SP)	;PRESERVE R5 JUST IN CASE
	CALL	@DOSYM		;CALL THE PROPER ROUTINE
	MOV	(SP)+,R5	;RESTORE R5
	BR	40$		;CONTINUE THE SCAN

;
; SHIFT A SYMBOL TO NEXT AVAIL EMPTY IF PASS 2
;

35$:	MOV4	(R5)+,(R4)+	;SHIFT THE SYMBOL DOWN
	DEC	TGTCT		;DOWN THE TARGET PAGE COUNTER
	BNE	40$		;BRANCH IF MORE ROOM
	MOV	TGTPG,R1	;ELSE UNLOCK PAGE
	UNLPG
	ADD	#400,R1		;POINT AT NEXT PAGE
	CALL	SETTGT		;SET IT UP

40$:	DEC	SRCCT		;DOWN THE SOURCE PAGE COUNTER
	BNE	30$		;BRANCH IF MORE TO SCAN IN IT
	MOV	SRCPG,R1	;UNLOCK IT
	UNLPG
	ADD	#400,R1
	CMP	R1,LSTVA	;SEE IF PAST END OF PRIMARY PAGES
	BLO	60$
	MOV	(SP)+,R1	;GET NEXT PAGE FROM ORDERED LIST ON STACK
	TSTB	R1		;SEE IF MARKER ENTRY
	BEQ	60$		;ITERATE IF NOT
	CMP	#-1,R1		;SEE IF REALLY MARKER ENTRY			[+GTS]
	BNE	70$		;NO, INTERNAL INCONSISTENCIES - ERROR		[+GTS]
	TST	PASS		;TEST IF PASS 2
	BEQ	50$		;BRANCH IF NO, JUST RETURN
	MOV	TGTPG,R1	;UNLOCK LAST TARGET PAGE
	CVRL
	ULCPG
	SUB	R0,R4		;CALCULATE NEXT AVAILABLE ENTRY ADDR
	ASR	R4
	ADD	R4,R1		;STORE THE VIRTUAL ADDR AS A LIMIT
	MOV	R1,LSTVA
50$:	RETURN			;RETURN WITH TABLE CONDENSED
60$:	JMP	10$		;Fix out of range branch.

70$:	MOV	#INTERR,R0	;REPORT ERROR					[+GTS]
	JMP	RESTRT		;   AND ABORT					[+GTS]

SETTGT:	MOV	R1,TGTPG	;SAVE VIRTUAL ADDR OF TARGET PAGE
	CVRL			;GET REAL ADDR
	LOCPG			;LOCK PAGE AND WRITE MARK IT
	WMCPG
	MOV	R0,R4		;COPY REAL POINTER INTO PAGE
	MOV	#64.,TGTCT	;INITIALIZE COUNT OF EMPTY SLOTS IN PAGE
	RETURN

.IF	NDF,RT11		;If not RT-11

	.PSECT	IMPURE,D,RW


.IFF;	NDF,RT11		;If not RT-11

	.PSECT	IMPURE,D,GBL,RW

.ENDC;	NDF,RT11		;If not RT-11

DOSYM::	.BLKW			;POINTS TO ENTRY POINT FOR GSD OR ISD ENTRY
				; PROCESSING IN "SCANSY" DURING PASS1

CURVA:	.BLKW
LSTVA:	.BLKW
MAXROW:
SRCPG:	.BLKW			;SOURCE PAGE POINTER FOR HASH TABLE SCAN
REMCOL:
SRCCT:	.BLKW			;COUNT OF REMAINING ENTRIES IN SOURCE PAGE
REMCT:
TGTPG:	.BLKW			;TARGET PAGE FOR HASH TABLE CONDENSATION
TGTCT:	.BLKW			;COUNT OF REMAINING FREE ENTRIES IN PAGE
SECBS:	.BLKW
SECCT:	.BLKW			;LOCAL COUNT OF PSECTS
NUMCOL:	.BLKW			;NUMBER OF SYMBOL TABLE COLUMNS TO LIST
NUMROW:	.BLKW			;NUMBER OF SYMBOL TABLE ROWS TO LIST/PAGE
SYMVIR:				;-> Virtual address of current symbol
COLCT:	.BLKW			;COLUMN COUNTER WHILE LISTING SYMBOLS
SYMLOC:				;-> Real start of virtual symbol page
ROWCT:	.BLKW			;ROW COUNTER WHILE LISTING
COLSEP:	.BLKW			;VIRTUAL MEMORY OFFSET TO SYMBOL IN NEXT COL
THISEC::			;CURRENT SECTOR DURING GSD/ISD DUMP TIME
ROWPT:	.BLKW			;POINTER TO LEFTMOST SYMBOL IN A ROW
COLPT:	.BLKW			;TEMPORARY POINTER TO SYMBOL IN A COLUMN


	.END
