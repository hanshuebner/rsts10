TITLE	RUNOFF,<RUNOFF TRANSLATED FROM PDP-10 VERSION>,14,18-APR-85,DNC/CM

;
;		COPYRIGHT (c) 1974, 1985 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

;
; VERSION M0101
;
; AUTHOR: L. WADE 1-JUN-72
;
; MODIFIED BY:
;
;	E. POLLACK U. OF W. 19-DEC-73
;
;	D. N. CUTLER 27-JUL-75
;
; THIS PROGRAM WAS TRANSLATED FROM THE PDP-10 VERSION OF RUNOFF
; AUTHORED BY B. CLEMENTS.
;
; SIMULATED ACCUMULATOR DEFINITIONS

F.1::	.WORD	0
S1::	.WORD	0

;
; FLAG BITS IN F.1
;
;	NOTE: THE LOW ORDER BYTE CORRESPONDS TO A LEGAL COMMAND MASK
;		THAT IS TESTED AGAINST THE TRAILING BYTE OF THE
;		APPROPRIATE COMMAND NAME.
;
 
NOTF==1				;NOTE PROCESSING ACTIVE
FOTF==2				;FOOTNOTE PROCESSING ACTIVE
RELF==4				;RELATIVE NUMBER CONVERSION (1=YES)
FPGF==20			;FLUSH PENDING PAGE (1=YES)
ENDF==40			;CORRESPONDS TO END FLAG IN TRAILING BYTE
BRKF==100			;CORRESPONDS TO BREAK FLAG IN TRAILING BYTE
JUSTF==400
PJUSTF==1000
FILLF==2000
LITFG==4000			;LITERAL PROCESSING FLAG
SPECF==20000			;SPECIAL COMMAND PROCESSING
 
;
; SWITCH WORD FLAG BIT DEFINITIONS
;
 
FFDSW==1			;SIMULATE FORM FEEDS (0=YES)
HYPSW==2			;HYPHENATE OUTPUT TEXT (1=YES)
PAUSW==4			;PAUSE BETWEEN PAGES (1=YES)
SPLSW==10			;SPOOL TEXT FILE (1=YES)
UPCSW==20			;FORCE ALL TEXT TO UPPER CASE (1=YES)
 
;
; SWITCH FLAGS (BYTE)
;
 
$HDSSW::.BLKB	1		;DISABLE PAGE HEADER (0=NO)
$GCISW::.BLKB	1		;INPUT FROM REREAD BUFFER (0=NO)
$SDISW::.BLKB	1		;INPUT FROM SECONDARY INPUT BUFFER (0=NO)
$ULMSW::.BLKB	1		;UNDERLINE MODE (0=NO BACKSPACE)
$ULNSW::.BLKB	1		;UNDERLINE SUPPRESS (0=NO)
$ULSSW::.BLKB	1		;UNDERLINE SIMULATE (0=NO)
	.EVEN
 
;
; SWITCH FLAGS (WORD)
;
 
HPHSW:	.BLKW	1		;HYPHENATION ENABLED FOR OUTPUT (0=NO)
TJFSW:	.BLKW	1		;TEMPORARY JUSTIFY FLAG (0=NO)
$AUTSW::.BLKW	1		;AUTOPARAGRAPH ACTIVE (0=NO)
$CFLSW::.BLKW	1		;FLAG CAPITALIZE ENABLE (0=NO)
$HDRSW::.BLKW	1		;PRINT PAGE HEADERS (0=NO)
$HFLSW::.BLKW	1		;FLAG HYPHENATE ENABLE (0=NO)
$HPHSW::.BLKW	1		;HYPHENATION ACTIVE (0=NO)
$NUMSW::.BLKW	1		;NUMBER PAGES (0=NO)
$PGPSW::.BLKW	1		;PAGE PENDING (0=NO)
$PERSW::.BLKW	1		;PUNCTUATION DOUBLE SPACING (0=NO)
$SBPSW::.BLKW	1		;SUBPAGE MODE ACTIVE (0=NO)
$ULLSW::.BLKW	1		;UNDERLINE LOCK ON (0=NO)

;IMPURE STORAGE


RMARG::	.WORD	0
LMARG::	.WORD	0
PRMRG::	.BLKW	1		;PERMANENT RIGHT MARGIN
CAS::	.WORD	0
WCAS::	.BLKW	1		;WORD CAPITALIZE CONVERSION VALUE
APNDN::	.BLKW	1		;CURRENT APPENDIX LETTER
CHPTN::	.BLKB	1		;CURRENT CHAPTER NUMBER
	.BLKB	5		;CURRENT HEADING LEVEL NUMBERS
CMADR::	.BLKW	1		;SPECIAL PROCESSING COMMAND ADDRESS
PAGENO::.WORD	0
PARPT::	.BLKW	1		;PARAGRAPH PAGE TEST COUNT
PARSP::	.BLKW	1		;PARAGRAPH SPACING COUNT
PARIND::.WORD	0
NSPNG::	.WORD	0
LINEC::	.WORD	0
SUBPGE::.WORD	0
LITCM::	.BLKW	1		;SAVED EXPECTED COMMAND ADDRESS (LITERAL)
LITSV::	.BLKW	1		;SAVED FLAGS MASK ON LITERAL PROCESSING
LSTPT::	.BLKW	1		;LIST ELEMENT PAGE TEST COUNT
LSTVS::	.BLKW	1		;LIST ELEMENT VERTICLE SPACING
LSTKP::	.BLKW	1		;CURRENT LIST STACK POINTER
LSTK::	.BLKW	5*3		;LIST STACK (5 ENTRIES)
LSTCT::	.BLKW	1		;CURRENT LIST ELEMENT COUNT
NOTCM::	.BLKW	1		;SAVED EXPECTED COMMAND ADDRESS (NOTE)
NOTLM::	.BLKW	1		;NOTE SAVED LEFT MARGIN
NOTRM::	.BLKW	1		;NOTE SAVED RIGHT MARGIN
NOTSV::	.BLKW	1		;SAVED FLAG WORD ON NOTE PROCESSING


TABTL==32.
TABTAB::.BLKB	TABTL
NTABS::	.WORD	0

NLPG::	.WORD	0
PNLPG::	.WORD	0

FOOTC::	.WORD	0
FOOTP1::.WORD	0
FOOTP2::.WORD	0
XBOT::	.BLKW	1		;BEGINNING OF ALLOCATED INDEX AREA
FOOTP3::.WORD	0
XTOP::	.BLKW	1		;HIGHEST VIRTUAL ADDRESS IN PROGRAM
FOOTWB::.BLKB	242.
FOOTS1::.WORD	FOOTWB-1
FOOTS2::.WORD	FOOTWB-1
	.WORD	FOOTWB+240.
XFIRST::.WORD	0


; USER-SET TEMPS

INDCT::	.WORD	0
TTLIN==72.
TTBUF::	.BLKB	TTLIN
TTILIN==82.
TTIBUF::.BLKB	TTILIN
 
 
	.IF NDF RSTS
 
HFIN::	.WORD	160.,0,0	;
INBUF::	.BLKB	162.		;INPUT BUFFER
HFOUT::	.WORD	80.,0,0		;
OUBUF::	.BLKB	80.		;OUTPUT BUFFER
 
	.IFF
 
HFIN::	.WORD	512.,0,0	;
INBUF::	.BLKB	514.		;INPUT BUFFER
HFOUT::	.WORD	512.,0,0	;
OUBUF::	.BLKB	512.		;OUTPUT BUFFER
 
	.ENDC
 
 

; GENERAL

T1::	.WORD	0
T2::	.WORD	0

LCH::	.WORD	0
NCNT::	.WORD	0
LOWPAG::.WORD	0		;LOWEST PAGE TO PRINT
HGHPAG::.WORD	0		;HIGHEST PAGE TO PRINT
PAGHD::	.BLKB	6		;PAGE NUMBER TEXT PROTOTYPE

; LINE TEMPS
LINBK::	.WORD	0
SPCNT::	.WORD	0
LSTSP::	.WORD	0
LINNSC::.WORD	0

LNIN1::	.WORD	LINBF-1
LNIN2::	.WORD	LINBF-1
	.WORD	LINBF+240.
LOUT1::	.WORD	0
LOUT2::	.WORD	0
LINBF::	.WORD	0
	.BLKB	242.

GCINP::	.WORD	0
GCIN2::	.WORD	0
GCSCH::	.BLKB	1		;SAVED CHARACTER FOR REPROCESSING
ULMCH::	.BLKB	1		;SAVED CHARACTER FOR UNDERLINING

	.WORD	0		;COUNTER
SDINP::	.WORD	SDBUF-1		;SECONDARY INPUT LINE DESCRIPTOR
	.WORD	SDBUF-1		;
	.WORD	SDBUF+240.	;SECONDARY INPUT BUFFER GUARD WORD
SDBUF::	.BLKB	242.		;SECONDARY INPUT BUFFER

	.WORD	0		;COUNTER
CMSTP::	.WORD	CMBF-1
CMST2::	.WORD	CMBF-1
	.WORD	CMBF+240.
CMBF::	.BLKB	242.
ECMBF=.-1

TTLLEN::.WORD	0		;TITLE LINE COUNTER
TTLP1::	.WORD	TTLBUF-1
TTLP2::	.WORD	TTLBUF-1
	.WORD	TTLBUF+240.
TTLBUF::.BLKB	242.

STLLEN::.WORD	0		;SUB-TITLE LINE COUNTER
STTLP1::.WORD	STTLBF-1
STTLP2::.WORD	STTLBF-1
	.WORD	STTLBF+240.
STTLBF::.BLKB	242.
EXSP1::	.WORD	0
EXSP2::	.WORD	0
EXSP3::	.WORD	0

NSPCH::	.WORD	0
LSTNSP::.WORD	0
ULPOS::	.WORD	0
CPOS::	.WORD	0
ULPBF::	.BLKB	162.

;PARAMETERS

SHUP=='^			;UPPER CASE INDICATOR
SHDN=='\			;LOWER CASE INDICATOR
CWARN=='_			;QUOTE NEXT CHARACTER
ULCHI=='&			;UNDERLINE COMMAND IN INPUT DATA
ULCHS==32			;UNDERLINE CHARACTER IN INTERNAL STORAGE
				; MUST BE .LT. QTS
QTSP=='#			;QUOTED (NONEXPANDABLE) SPACE IN INPUT FILE

HWPLN==66.			;HARDWARE LINES PER PAGE
ILSTTP==2			;INITIAL LIST ELEMENT PAGE TEST COUNT
ILSTVS==1			;INITIAL LIST ELEMENT VERTICLE SPACING
IPARIN==5			;INITIAL PARAGRAPH INDENT
IPARTP==2			;INITIAL PARAGRAPH PAGE TEST
IPARVS==1			;INITIAL PARAGRAPH VERTICLE SPACING
IRMRG==60.			;INITIAL RIGHT MARGIN
ILMRG==0			;INITIAL LEFT MARGIN
INLPG==58.			;INITIAL LENGTH OF PAGE
LOLMAR==9.			;INITIAL LEFT MARGIN INDENT ON LISTS
LFSPAC==1			;FINAL VERTICLE SPACING ON LISTS
LSLMAR==4			;LEFT MARGIN INDENT ON EMBEDDED LISTS
NASPAC==1			;VERTICLE SPACING AFTER NOTES
NFSPAC==2			;FINAL VERTICLE SPACING AFTER NOTES
NHSPAC==2			;INITIAL VERTICLE SPACING BEFORE NOTES
NPMARG==15.			;PRIMARY MARGIN CHANGE ON NOTES
NSMARG==4			;SECONDARY MARGIN CHANGE ON NOTES
SDLPG==64.			;STANDARD LINES PER PAGE
SPARIN==0			;STANDARD COMMAND PARAGRAPH INDENT
SPCNG==1			;STANDARD LINE SPACING

;CHARACTERS FOR CREF

CR==15
LF==12
SPC==40
FF==14
TAB==11
CMA==',
ALT==33
BS==10				;BACKSPACE CHARACTER
NXS==177			;NON-EXPANDABLE	SPACE (INTERNAL)
QTS==37				;QUOTED SPACE. MUST BE SPC-1 FOR COMPARES
PD=='.				;PERIOD. FOR SPECIAL SPACING AFTER PERIOD
EOFC=='Z-100			;END-OF-FILE CHARACTER
LPUS=='_			;LINE-PRINTER UNDERSCORE IN OUTPUT FILE
SEMI==';			;SEMICOLON
WCAP=='<			;WORD CAPITALIZE CHARACTER


;INPUT LINE

LIN::	CALL	GCIN		;READ CHARACTER WITH PRE-TRANSLATE
	BITNE	#LITFG,F.1,10$	;PROCESING LITERAL?
	CMPEQ	R1,#TAB,LTAB	;TAB?
10$:	CMPNE	R1,#CR,20$	;NOT CARRIAGE RETURN?
	JMP	LCR		;YES. GO LOOK FOR LF
20$:	CMPEQ	R1,#NXS,LSPAC	;NON EXPANDABLE	SPACE?
	CMPEQ	R1,#SPC,LSPAC	;REGULAR SPACE?
	CMP	R1,#QTS		;SOME OTHER CONTROL CHARACTER?
	BGE	LIN3		;IF GE NO
	INC	LINBK		;ACCOUNT FOR NONSPACING CHARACTER
	INC	LINNSC		;
LIN3:	CALL	WLNIN1		;WRITE CHAR IN INPUT BUFFER
	MOV	R1,LCH		;SAVE AS LAST CHARACTER
	DEC	LINBK		;TIME TO BREAK LINE YET?
	BGE	LIN		;NO. LOOP FOR MORE
 
 
	.IF DF	H$$PHN
 
	CLR	HPHSW		;CLEAR HYPHENATE ENABLE
	TSTEQ	$HPHSW,LIN3A	;NO HYPHENATION ACTIVE?
	BITEQ	#JUSTF,F.1,LIN3A ;NO JUSTIFICATION?
	BITEQ	#HYPSW,$SWTCH,LIN3A ;NO HYPHENATION SELECTED?
	MOV	LNIN2,-(SP)	;REMEMBER END OF LINE
FIN10:	CALL	GCIN		;GET A CHARACTER
	MOV	R1,R2		;COPY CHARACTER
	BIC	#^C<177>,R2	;CLEAR ALL EXTRANEOUS BITS
	CALL	ALPH2		;ALPHABETIC?
	BCS	FINEX		;IF CS NO
	CALL	WLNIN1		;PUT CHARACTER IN BUFFER
	MOV	R1,LCH
	BR	FIN10
FINEX:	MOV	LSTSP,R0	;GET ADDRESS OF LAST WORD
	CMPB	(R0)+,(R0)+	;
	TSTB	(R0)		;IS WORD TO BE HYPHENATED IF POSSIBLE?
	BMI	FIN06		;IF MI NO
	MOV	R1,-(SP)	;SAVE LAST CHARACTER
	MOV	LNIN2,R1	;CONVERT LAST WORD TO ASCIZ
	CLRB	1(R1)		;
10$:	BICB	#200,(R1)	;ERASE ALL POSSIBLE HYPHENATE DISABLES
	DEC	R1		;BACKUP ONE BYTE
	CMP	R1,LNIN1	;AT FRONT OF LINE?
	BHI	10$		;IF HI NO
	MOV	SP,HPHSW	;ENABLE HYPHENATE ON OUTPUT
	CALL	HYPHEN		;TRY TO HYPHENATE THE WORD
	MOV	LSTSP,R1	;ADDRESS OF LAST SPACE
	MOV	2(SP),R0	;ADDRESS OF REAL END OF LINE
FIN02:	TSTB	-(R0)		;IS THIS A PLACE TO INSERT A HYPHEN?
	BMI	FIN03		;YES
	CMP	R0,R1		;NO, SHOULD I LOOK FARTHER?
	BHI	FIN02		;YES
	CLR	R1		;CLEAR MASK
	BR	FIN05
FIN03:	DEC	R0
	MOV	R0,LSTSP	;SET POINTER TO FAKE SPACE
	INC	SPCNT		;COUNT THE FAKE SPACE
	MOV	R1,R0		;GET START OF WORD
	MOV	#200,R1		;SET BIT	MASK
FIN05:	BICB	#200,(R0)+	;CLEAR HYPHEN FLAG AND TEST
	BNE	FIN05		;IF NE MORE TO GO
FIN04:	BISB	R1,@LSTSP	;RESET THE DESIRED ONE ONLY
	MOV	(SP)+,R1	;RETRIEVE SAVED CHARACTER
FIN06:	TST	(SP)+		;CLEAN STACK
	CALL	WLNIN1		;WRITE CHARACTER INTO BUFFER
LIN3A:
 
	.ENDC
 
 
	CALL	OUTLJ		;OUTPUT LINE,JUSTIFIED IF FLAGS
	BR	LIN		;PROCESS NEXT LINE.
 
;SPECIAL CHARACTERS DURING LINE INPUT

	.ENABL	LSB
LTAB:	MOV	LNIN2,R2	;DETERMINE PRESENT POSITION
	SUB	LNIN1,R2
	SUB	LINNSC,R2
	ADD	LMARG,R2
	ADD	INDCT,R2
	CALL	TABB		;FIND WHERE NEXT TAB STOP IS
	CMP	R2,LINBK	;WOULD THAT MANY EQUAL OR EXCEED LINE SIZE?
	BGE	LSPAC		;YES. TREAT AS SPACE, NOT TAB
	SUB	R2,LINBK	;AND DECREMENT LINBK COUNT BY THAT AMOUNT
	MOV	#QTS,R1		;PUT N QUOTED SPACES IN BUFFER
10$:	CALL	WLNIN1		; ..
	DEC	R2		; ..
	BGT	10$
20$:	JMP	LIN

;HERE ON SPACE IN INPUT FILE, OR ON NON-EXPANDABLE	SPACE. ALSO HERE ON
;TAB WHICH COULDN'T BE SATISFIED SO IS MADE A SPACE
;NOT HERE ON QUOTED SPACES.

LSPAC:	BITEQ	#FILLF,F.1,30$	;NO FILLING INPUT BEYOND BREAKS?
	MOV	LNIN2,R2	;FILTER OUT LEADING SPACES
	DEC	R2		;GET START OF BUFFER MINUS ONE
	CMP	R2,LSTSP	;IS THAT WHERE LAST SPACE IS?
	BLOS	20$		;IF LOS YES
	MOV	LCH,R1		;GET PREVIOUS CHARACTER WHAT WAS IT?
	CMPEQ	R1,#SPC,20$	;SPACE?
	CMPEQ	R1,#NXS,20$	;NON-EXPANDABLE	SPACE?
	CMPEQ	R1,#QTS,20$	;QUOTED SPACE?
	TSTEQ	$PERSW,30$	;ONE SPACE AFTER PUNCTUATION?
	CMPEQ	#':,R1,25$	;COLON FOLLOWED BY A SPACE?
	CMPEQ	#SEMI,R1,25$	;SEMICOLON FOLLOWED BY A SPACE?
	CMPEQ	#'!,R1,25$	;EXCLAMATION POINT FOLLOWED BY A SPACE?
	CMPEQ	#'?,R1,25$	;QUESTION MARK FOLLOWED BY A SPACE?
	CMPNE	R1,#PD,30$	;NOT PERIOD FOLLOWED BY SPACE?
25$:	TST	LINBK		;YES. ANY MORE ROOM LEFT?
	BLOS	30$		;NO. JUST STORE THE SPACE
	CALL	50$		;
	CALL	WLNIN1		; ..
	DEC	LINBK		;AND COUNT FOLLOWING CHARACTER
	MOV	#NXS,R1		;NON-EXPANDABLE	SPACE
	BR	40$		;
30$:	CALL	50$		;
40$:	JMP	LIN3		;
50$:	MOV	LNIN2,LSTSP	;HERE TO STORE AND COUNT A SPACE
	MOV	LINNSC,LSTNSP	;AND NON-SPACING CHAR POSN
	INC	SPCNT		;COUNT THIS SPACE
	MOV	#SPC,R1		;SPACE CHARACTER (EXPANDABLE)
	RETURN			;
	.DSABL	LSB
;+
; ENDBCM--END OF BREAK COMMAND
;-
 
	.ENABL	LSB
ENDBCM::CALL	LINSET		;SET FOR NEW LINE (BREAK COMMAND)
 
;+
; ENDCM--END OF COMMAND
;-
 
ENDCM::	CALL	$FRCND		;FORCE TO LOGICAL END OF LINE
	CMPEQ	#PD,R1,LGO	;PERIOD NEXT CHARACTER?
	CMPEQ	#SEMI,R1,LGO	;MORE TEXT ON LINE?
	BR	LCR		;
 
;+
; END OF LINE PROCESSING
;-
 
COMNT::	TST	(SP)+		;REMOVE RETURN FROM STACK
LCR::	CALL	GCIN		;GET FILE CHARACTER
LCR1:	CMPNE	R1,#LF,LCR	;NOT A LINEFEED?

;+
; READ AND PROCESS NEXT LINE
;-

LGO::	MOV	SPSAV,SP	;RELOAD STACK POINTER
	CALL	CCIN		;READ INITIAL CHARACTER ON LINE
5$:	MOV	#F.1,R5		;POINT TO FLAG MASK WORD
	CMPNE	R1,#EOFC,20$	;NOT END OF FILE?
	BITEQ	#FOTF,(R5),10$	;NOT PROCESSING FOOTNOTE?
	JMP	FOOTND		;GO FINISH FOOTNOTE PROCESSING
10$:	CALL	OUTNJ		;FLUSH OUT LAST LINE
	CLR	$HDRSW		;CLEAR HEADER PRINT ENABLE
	CALL	PAGEC		;FORCE A PAGE
	JMP	ENDFIL		;END OF FILE
20$:	CMPEQ	R1,#FF,LGO	;FORMFEED ON INPUT?
	BITNE	#LITFG,(R5),70$	;PROCESSING LITERAL?
	BITEQ	#FILLF,(R5),60$	;NOT FILLING FROM INPUT FILE?
	TSTEQ	$AUTSW,60$	;AUTOPARAGRAPH NOT ACTIVE?
	CMPEQ	#CR,R1,40$	;NULL LINE?
	CMPEQ	#TAB,R1,30$	;LEADING TAB?
	CMPNE	#SPC,R1,70$	;NOT LEADING SPACE?
30$:	CALL	CCIN		;READ NEXT CHARACTER
	CMPEQ	#SPC,R1,30$	;SPACE?
	CMPEQ	#TAB,R1,30$	;TAB?
	CMPNE	#CR,R1,50$	;NOT CARRIAGE RETURN?
40$:	CALL	CCIN		;BYPASS LINE FEED
45$:	CALL	CCIN		;READ NEXT CHARACTER
	CMPEQ	#SPC,R1,45$	;SPACE?
	CMPEQ	#TAB,R1,45$	;TAB?
	CMPEQ	#PD,R1,90$	;LEADING PERIOD?
50$:	MOVB	R1,GCSCH	;SAVE FIRST CHARACTER
	CALL	OUTNJ		;BREAK CURRENT LINE
	CALL	PARTP		;PERFORM PARAGRAPH BREAK
	MOV	PARIND,INDCT	;SET PARAGRAPH INDENT
	CALL	LINSET		;RESET LINE PARAMETERS
	BR	TEXT		;PROCESS TEXT
60$:	CMPEQ	#CR,R1,LCR	;NULL LINE?
70$:	CMPEQ	R1,#PD,90$	;PERIOD AS FIRST CHAR?
	MOVB	R1,GCSCH	;SAVE CHARACTER
TEXT::	TSTEQ	$PGPSW,80$	;NO PAGE PENDING?
	CALL	PAGEC		;BREAK PAGE
80$:	BITNE	#FILLF,F.1,85$	;FILLING FROM INPUT FILE?
	CALL	OUTLIN		;OUTPUT LINE
	JMP	LIN		;AND START ANOTHER
85$:	JMP	LSPAC		;
90$:	CALL	CMN		;PARSE COMMAND
	MOV	#ENDCM,-(SP)	;ASSUME NONBREAK COMMAND
	MOV	(R3),-(SP)	;SET ADDRESS OF COMMAND ROUTINE
	MOVB	(R2),-(SP)	;GET FLAG BYTE
	BITEQB	#BRKF,(SP),100$	;NOT BREAK COMMAND?
	CALL	OUTNJ		;BREAK CURRENT LINE
	MOV	#ENDBCM,4(SP)	;SET FOR BREAK COMMAND
100$:	BITEQB	#FPGF,(SP),110$	;DON'T PERFORM PENDING PAGE?
	TSTEQ	$PGPSW,110$	;NO PAGE PENDING?
	CALL	PAGEC		;PERFORM PAGE OPERATION
110$:	MOV	#RCNO,R4	;SET ADDRESS OF NUMBER CONVERSION ROUTINE
	BITEQB	#RELF,(SP)+,120$ ;ABSOLUTE CONVERSION REQUIRED?
	MOV	#RCNR,R4	;SET ADDRESS OF RELATIVE CONVERSION ROUTINE
120$:	JMP	@(SP)+		;DISPATCH TO COMMAND ROUTINE
	.DSABL	LSB
 
;
; ILLEGAL COMMAND
;
 
ILCM::	CALL	$ERMSG		;ILLEGAL COMMAND
	+ILCMM
	MOV	#PD,R1		;SET TO OUTPUT A PERIOD
10$:	CALL	TTC1		;OUTPUT CHARACTER
	MOV	#CMSTP,R4	;READ OUT COMMAND BUFFER
	CALL	GCI		; TO TELETYPE
	.WORD	20$		;END OF LINE
	BR	10$		;LOOP FOR WHOLE LINE
20$:	CALL	TTC33
	MOV	#LCR,-(SP)	;SET EXIT ADDRESS
ONPAG::	CALL	$ERMSG		;OUTPUT ERROR MESSAGE
	+ILCMM2
	MOV	APNDN,R1	;GET CURRENT APPENDIX LEVEL
	BEQ	10$		;IF EQ NONE
	ADD	#'A-1,R1	;CONVERT TO ASCII LETTER
	CALL	TTC1		;OUTPUT LETTER
	BR	20$		;
10$:	MOVB	CHPTN,R0	;GET CURRENT CHAPTER NUMBER
	BEQ	30$		;IF EQ NONE
	CALL	DECTY		;OUTPUT CHAPTER NUMBER
20$:	MOV	#'-,R1		;OUTPUT A DASH
	CALL	TTC1		;
30$:	MOV	PAGENO,R0
	MOV	#TTC33,-(SP)	;SET EXIT ADDRESS
DECTY:	MOV	#12,R1		;SET DIVISOR
	CALL	$DIV		;DIVIDE
	MOV	R1,-(SP)	;SAVE REMAINDER
	TSTEQ	R0,10$		;NO MORE DIGITS TO CONVERT?
	CALL	DECTY
10$:	MOV	(SP)+,R1
	ADD	#60,R1
	JMP	TTC1
 
;
; EXPAND MEMORY
;
 
EXPAND::CALL	$ERMSG		;OUTPUT ERROR MESSAGE
	.WORD	CORERR		;
	JMP	ENDFIL		;

;+
; ROUTINE TO CHECK A CHARACTER FOR UPPER OR LOWER CASE
;	ALPHABETICS
;-
 
ALPH1::	MOV	R2,-(SP)	;SAVE R2
	MOV	R1,R2		;SET CHARACTER TO CHECK
	CALL	ALPH2		;CHECK FOR ALPHABETIC
	MOV	(SP)+,R2	;RESTORE R2
	RETURN			;
ALPH::	MOVB	(R0),R2		;GET CHARACTER TO CHECK
ALPH2::	CMP	R2,#'A
	BLO	20$
	CMP	R2,#'Z
	BLOS	10$
	CMP	R2,#'A+40
	BLO	20$
	CMP	R2,#'Z+40
	BHI	20$
10$:	CLC			;INDICATE ALPHABETIC
	RETURN			;
20$:	SEC			;INDICATE NONALPHABETIC
	RETURN			;
 
;SUBROUTINE TO INITIALIZE COUNTS AND POINTERS FOR A NEW LINE

LINSET::MOV	RMARG,R2	;COMPUTE REAL WIDTH OF LINE
	SUB	LMARG,R2	;AS DIFFERENCE OF MARGINS
	SUB	INDCT,R2	;MINUS INDENTING
	MOV	R2,LINBK	;STORE IN LINE-BREAK COUNT
	MOV	#-1,SPCNT	;INITIAL COUNTS OF SPACING
	CLR	NSPCH		; AND NON-SPACING CHARS
	CLR	CPOS		;CARRIAGE POSITION IS FAR LEFT
	CLR	LINNSC		;NO NON-SPACING CHARACTERS
	MOV	LNIN1,LNIN2	;CLEAR LINE INPUT BUFFER
	MOV	LNIN1,LSTSP	;SET LAST SPACING CHARACTER BACK HERE
	DEC	LSTSP		;MINUS ONE, SO OFF START OF BUFFER
ULBSET::MOV	#ULPBF,ULPOS	;RESET UNDERLINE POSITION BUFFER
	RETURN			;
 
;+
; RCNR--RELATIVE DECIMAL CONVERSION ROUTINE
;
; INPUTS:
;
;	R3=BASE VALUE TO BE AUGMENTED.
;
; OUTPUTS:
;
;	NONSKIP RETURN IF NO NUMBER IS PRESENT.
;
;	SKIP RETURN WITH R3 UPDATED TO NEW VALUE.
;-
 
	.ENABL	LSB
RCNR::	MOV	R3,-(SP)	;SAVE BASE VALUE
	CALL	RCNO		;CONVERT DECIMAL NUMBER
	JMP	40$		;NONSKIP RETURN IF NULL
	BEQ	30$		;IF EQ NO SIGN SPECIFIED
	ADD	(SP),R3		;AUGMENT BASE VALUE
	BR	30$		;SKIP RETURN
 
;
; READ SIGNED DECIMAL NUMBER FOR COMMAND DECODER
; NON-SKIP RETURN IF NONE FOUND
;
 
RCNO::	CLR	R3		;CLEAR ANSWER AC
	CLR	-(SP)		;AND SIGN FLAG
RCN1:	CALL	CCIN		;READ CHARACTER FROM COMMAND LINE
	CMPEQ	R1,#CR,RCN5	;LEADING CARRIAGE RETURN?
	CMPEQ	#PD,R1,RCN5	;LEADING PERIOD?
	CMPEQ	#SEMI,R1,RCN5	;LEADING CHARACTER SEMICOLON?
	CMPEQ	R1,#CMA,40$	;LEADING COMMA?
	CMPEQ	R1,#SPC,RCN1	;SPACES AND TABS?
	CMPEQ	R1,#TAB,RCN1	;LEADING TAB?
	CMPNE	#'+,R1,10$	;NOT PLUS SIGN?
	INC	(SP)		;SET PLUS SIGN PRESENT
10$:	CMPNE	R1,#'-,20$	;NOT MINUS SIGN?
	COM	(SP)		;SET NEGATE FLAG
20$:	TSTEQ	(SP),RCN2	;SIGN NOT SPECIFIED?
RCN3:	CALL	CCIN		;READ ANOTHER CHARACTER
RCN2:	CMP	R1,#'9		;THIS CHAR A DIGIT?
	BGT	RCN4
	CMP	R1,#'0		; ..
	BLT	RCN4		;NO.  STOP HERE.
	ASL	R3		;MULTIPLY BY 10.
	MOV	R3,-(SP)	;
	ASL	R3		;
	ASL	R3		;
	ADD	(SP)+,R3	;
	SUB	#60,R1		;SUBTRACT OUT CHARACTER BIAS
	ADD	R1,R3		;ADD IN DIGIT
	BR	RCN3		;AND LOOP FOR MORE.
RCN4:	CMPNE	R1,#CMA,25$	;NOT COMMA?
	CALL	CCIN		;READ NEXT CHARACTER
25$:	TST	(SP)		;SIGN NEGATIVE?
	BPL	30$		;IF PL NO
	NEG	R3		;NEGATE NUMBER
30$:	ADD	#4,2(SP)	;SET SKIP RETURN
RCN5:	MOVB	R1,GCSCH	;STORE BREAK CHARACTER
40$:	TST	(SP)+		;CLEAN STACK
	RETURN			;
	.DSABL	LSB

;+
; $FRCND-FORCE TO LOGICAL END OF COMMAND
;-
 
$FRCND::CALL	CCIN		;READ CHARACTER FROM FILE
	CMPEQ	#SPC,R1,$FRCND	;SPACE?
	CMPEQ	#TAB,R1,$FRCND	;TAB?
	CMPEQ	#SEMI,R1,10$	;SEMICOLON?
	MOVB	R1,GCSCH	;SAVE BREAK CHARACTER
10$:	RETURN			;
 
;LINE OUTPUT ROUTINE. THREE ENTRY POINTS

OUTNJ::	MOV	LNIN2,R2	;HERE TO OUTPUT CURRENT LINE, NOT JUSTIFIED
	CALL	OUTNJ2		;CALL BODY OF ROUTINE
	CLR	EXSP3		;CLEAR LEFT RIGHT SPACING FLAG
OUTNJ3:	RETURN			;
OUTLJ:	MOV	LSTSP,R2	;END OF LINE IS LAST SPACE, IF ANY
	CMP	R2,LNIN1	;..
	BHI	..036
OUTLIN:	MOV	LNIN2,R2	;ELSE END OF INPUT LINE
..036:	MOV	SP,TJFSW	;COPY JUSTIFY FLAG
	BITNE	#JUSTF,F.1,..037 ;JUSTIFYING?
OUTNJ2: CLR	TJFSW		;CLEAR JUSTIFY FLAG
 
 
	.IF DF	H$$PHN
 
	CLR	HPHSW		;CLEAR HYPHENATE ENABLE
 
	.IFTF
 
..037:	MOV	R2,LOUT2	;SAVE END OF LINE TO CONSIDER
	MOV	LNIN1,LOUT1	;AND BEGINNING.
	CMP	R2,LOUT1	;LINE EMPTY?
	BLOS	OUTNJ3		;IF LOS YES
	TSTEQ	TJFSW,OUTNJ1	;NOT JUSTIFYING LINE?
	TST	SPCNT		;YES, ANY SPACES IN LINE?
	BGT	30$		;IF GT YES
	CALL	$ERMSG		;OUTPUT ERROR MESSAGE
	.WORD	JUSRM1		;
	MOV	LOUT1,T1	;COPY LINE DESCRIPTOR
	MOV	LOUT2,T2	;
10$:	MOV	#T1,R4		;READ A CHARACTER FROM LINE
	CALL	GCI		;
	.WORD	20$		;END OF LINE
	CALL	TTC1		;OUTPUT CHARACTER
	BR	10$		;
20$:	CALL	TTC33		;FORCE LINE OUT
	CALL	ONPAG		;INDICATE WHAT PAGE
	CLR	TJFSW		;CLEAR JUSTIFICATION
	BR	OUTNJ1		;
30$:	MOV	RMARG,R0	;YES. COMPUTE WHERE TO EXPAND THEM
	SUB	LMARG,R0	;SIZE OF LINE
	SUB	INDCT,R0	; ..
	ADD	LOUT1,R0	;SUBTRACT SIZE OF DATA
	SUB	LOUT2,R0	;..
	ADD	LSTNSP,R0	;COMPENSATE FOR NON-SPACING CHARACTERS
 
	.IFT
 
	TSTEQ	HPHSW,..040	;NO HYPHENATION ON OUTPUT?
	TSTB	@LSTSP		;DO WE ACCOUNT FOR A HYPHEN?
	BPL	..040		;IF PL NO
	DEC	R0		;YES, DECREMENT COUNT
..040:
 
	.IFTF
 
	MOV	SPCNT,R1	;NOW FIND HOW MANY MULT SPACES EACH SPACE IS
	CALL	$DIV		;DIVIDE
	MOV	R0,EXSP1	;MULTIPLIER FOR ALL SPACES
	TSTNE	EXSP3,10$	;EXTRAS TO LEFT?
	NEG	R1		;RIGHT. GET SPACES BEFORE EXTRAS
	ADD	SPCNT,R1	;..
10$:	MOV	R1,EXSP2	;STORE FOR LATER
OUTNJ1:	MOV	INDCT,R2	;GET INDENTING IN CASE OF PARAGRAPH
	CLR	INDCT		;(ONCE ONLY)
	ADD	LMARG,R2	;PLUS LEFT MARGIN
	CALL	NSPAC		;OUTPUT THAT MANY SPACES
OUTL1:	CALL	GLOUT		;READ A CHARACTER FROM OUTPUT BUFFER
	.WORD	OUTLE		;END OF OUTPUT BUFFER
	CMPEQ	R1,#SPC,OUTSP	;REAL SPACE?
	CMPNE	R1,#NXS,10$	;NOT NON-EXPANDABLE SPACE?
	MOV	#SPC,R1		;YES. MAKE IT ONE SPACE
10$:
 
	.IFT
 
	MOV	R1,-(SP)
	BIC	#200,R1		;CLEAR POSSIBLE HYPHENATION FLAG
 
	.IFTF
 
	CALL	CCOUT		;OUTPUT THE CHARACTER
 
	.IFT
 
	TSTB	(SP)+		;SHOULD HYPHEN BE TYPED?
	BPL	OUTL1		;IF PL NO
	TSTEQ	HPHSW,OUTL1	;NO HYPHENATION ON OUTPUT?
	MOV	#'-,R1
	CALL	CCOUT		;OUTPUT IT
 
	.ENDC
 
 
	BR	OUTL1		;LOOP BACK FOR MORE.
OUTSP:	CALL	CCSPC		;OUTPUT A SPACE
	TSTEQ	TJFSW,OUTL1	;NOT JUSTIFYING LINE?
	MOV	EXSP1,R2	;YES. HOW MANY MULTIPLE SPACES?
	CALL	NSPAC		;IF ANY, SEND THEM.
	DEC	EXSP2		;TO EXTRA BLANKS YET?
	BGE	OUTS1		;NO.
	TSTEQ	EXSP3,OUTS2	;SPACES TO RIGHT?
	BR	OUTL1		;LEFT. NO MORE EXTRAS, JUST LOOP
OUTS1:	TSTEQ	EXSP3,OUTL1	;NO SPACES LEFT OR RIGHT?
OUTS2:	CALL	CCSPC		;OUTPUT A SPACE
	BR	OUTL1		;AND LOOP FOR REST OF LINE
 
;END OF LINE, AND FOOTNOTE PROCESSING

OUTLE:	COM	EXSP3		;COMPLEMENT LEFT RIGHT FLAG
	MOV	LNIN2,R2
	MOV	LNIN1,LNIN2
	CMP	R2,LOUT2	;ANY LEFT TO OUTPUT?
	BLOS	OUTLE4		;NO.
	MOV	R2,GCIN2	;YES. SAVE POINTER
	MOV	LOUT2,GCINP	;FOR GET CHARACTER ROUTINE
	COMB	$GCISW		;SET TO REREAD BUFFER
OUTLE4:	CALL	SKIPS		; ..
	TSTEQ	FOOTC,OUTFT1	;NO FOOTNOTE LINE COMMANDS DECLARED?
OUTFT:	BITNE	#FOTF,F.1,OUTFT1 ;DOING THEM ALREADY?
	MOV	NLPG,R2		;GET STARTING FOOTNOTE LINE
	SUB	FOOTC,R2	;REDUCE BY REQUESTED LINES
	CLR	FOOTC		;CLEAR REQUESTED LINES
	MOV	R2,NLPG		;SAVE STARTING FOOTNOTE LINE
	SUB	NSPNG,R2	;MINUS NORMAL SPACING
	CMP	R2,LINEC	;ROOM ON THIS PAGE FOR FOOTNOTE?
	BHI	OUTFT1		;IF HI YES
	CALL	BPAGE		;BREAK PAGE HERE.
OUTFT1:	JMP	LINSET		;RESET LINE PARAMATERS


;SUBROUTINE TO SKIP N LINES ON OUTPUT FILE

	.ENABL	LSB
SKIPS::	MOV	NSPNG,R2	;SET TO SKIP TO NEXT LINE
	BR	SKIPN		;
SKIP1::	MOV	#1,R2		;SET TO SKIP ONE LINE
SKIPN::	MOV	R3,-(SP)	;SAVE R3
	TSTNEB	$ULMSW,50$	;NO NEED TO CONSIDER SAVED UNDERLINES?
	MOV	#ULPBF,R3	;POINT TO START OF UNDERLINE POSITION BUFFER
	CMPEQ	R3,ULPOS,50$	;NO UNDERLINES IN THE BUFFER?
	MOV	R2,-(SP)	;SAVE NUMBER OF LINES TO BE OUTPUT
	TSTNEB	$ULNSW,40$	;UNDERLINES SUPPRESSED?
	MOV	#LPUS,-(SP)	;ASSUME UNDERLINE VIA UNDERLINE CHARACTER
	TSTEQB	$ULSSW,10$	;USE UNDERLINE CHARACTER?
	MOV	#'-,(SP)	;SET CHARACTER TO DASH
	INC	LINEC		;ACCOUNT FOR EXTRA LINE
	CALL	CRLF		;SPACE TO NEXT LINE
	BR	20$		;
10$:	MOV	#CR,R1		;OUTPUT A CARRIAGE RETURN
	CALL	FOUT		;
20$:	CLR	CPOS		;START AT BEGINNING OF LINE
30$:	MOVB	(R3)+,R2	;GET POSITION WHERE UNDERLINE GOES
	SUB	CPOS,R2		;HOW FAR TO IT?
	CALL	NSPAC		;SPACE TO THE UNDERLINE
	MOV	(SP),R1		;GET PROPER UNDERSCORE CHARACTER
	CALL	FOUT		;SEND TO FILE
	INC	CPOS		;COUNT POSITION
	CMPNE	R3,ULPOS,30$	;NOT TO LAST UNDERLINE?
	TST	(SP)+		;CLEAN STACK
40$:	CALL	ULBSET		;RESET UNDERLINE BUFFER POINTER
	MOV	(SP)+,R2	;RESTORE NUMBER OF LINES
50$:	ADD	R2,LINEC	;COUNT LINES
	CLR	NSPCH		;CLEAR PER-LINE COUNTS
	CLR	CPOS		; ..
60$:	CALL	CRLF		;SPACE TO NEXT LINE
	DEC	R2		;OUTPUT AS MANY AS REQUESTED
	BGT	60$		;IF GT YES
	MOV	NSPNG,R3	;GET SPACING COUNT TO NEXT LINE
	CALL	TESTP		;TEST IF PAGE SHOULD BE BROKEN
	MOV	(SP)+,R3	;RESTORE R3
70$:	RETURN			;

;
; ROUTINE TO OUTPUT SPACES TO FILE
;

NSPAC::	DEC	R2		;ANY MORE SPACES TO OUTPUT?
	BLT	70$		;IF LT NO
	CALL	CCSPC		;OUTPUT A SPACE
	BR	NSPAC		;

;
; ROUTINES TO OUTPUT A STRING TO THE OUTPUT FILE
;

PSTRPA::MOV	(R4)+,S1	;GET ADDRESS OF STRING MINUS 1
	MOV	(R4),R4		;GET ENDING ADDRESS OF STRING MINUS 1
	CLRB	1(R4)		;SET SENTINEL BYTE
80$:	INC	S1		;POINT TO NEXT BYTE
PSTRAZ::MOVB	@S1,R1		;GET A CHARACTER
	BEQ	70$		;IF EQ END OF STRING
	CALL	CCOUT		;OUTPUT TO FILE
	BR	80$		;LOOP FOR WHOLE STRING
	.DSABL	LSB
 
;
; SUBROUTINE TO OUTPUT CHARACTER TO FILE, AFTER SOME TESTS
;

	.ENABL	LSB
CCOUT:	CMPNE	R1,#ULCHS,10$	;NOT UNDERLINE CHARACTER?
	TSTEQB	$ULMSW,30$	;BY LINE?
	MOV	#LPUS,R1	;CONVERT TO OUTPUT UNDERLINE
	CALL	FOUT		;YES, SEND UNDERLINE
	MOV	#BS,R1		;AND FOLLOW WITH BACKSPACE
10$:	CMPNE	R1,#QTS,20$	;NOT QUOTED SPACE?
CCSPC::	MOV	#SPC,R1		;MAKE REAL SPACE
20$:	INC	CPOS		;COUNT POSITION OF CARRIAGE
	JMP	FOUT		;OUTPUT CHARACTER
30$:	MOVB	CPOS,@ULPOS	;INTO UNDERLINE BUFFER
	INC	ULPOS		;STEP BUFFER POINTER  (SHOULD CHECK IT)
	RETURN			;
	.DSABL	LSB


;GET INPUT CHARACTER FROM SOURCE FILE

	.ENABL	LSB
GCIN::	TSTEQB	$GCISW,GCIN3	;NOT REREADING FROM BUFFER?
	CALL	GGCINP		;GET  CHARACTER FROM BUFFER
	.WORD	10$		;NONE
	RETURN			;
10$:	CLRB	$GCISW		;CLEAR REREAD FLAG
GCIN3:	TSTNEB	GCSCH,GCIN5	;SAVED CHARACTER?
	MOVB	ULMCH,R1	;SAVED UNDERLINE CHARACTER?
	BEQ	GCIN5		;IF EQ NO
	CLRB	ULMCH		;CLEAR SAVED UNDERLINE CHARACTER
	BR	80$		;
GCIN5:	CALL	CCIN		;NO.  GET CHARACTER FROM FILE.
GCIN6:	CMP	#'Z+40,R1	;LOWER CASE?
	BLO	30$		;IF LO NO
	CMP	#'A+40,R1	;LOWER CASE?
	BHI	20$		;IF HI NO
	SUB	WCAS,R1		;CONVERT CASE IF NECESSARY
	BR	GCINR		;
20$:	CMP	#'A,R1		;UPPER CASE?
	BHI	30$		;IF HI NO
	CMP	#'Z,R1		;UPPER CASE?
	BLO	30$		;IF LO NO
	TSTNE	WCAS,GCINR	;CONVERTING TO UPPER CASE FOR THIS WORD?
	ADD	CAS,R1		;CONVERT TO LOWER CASE IF NECESSARY
	BR	GCINR		;
30$:	TSTEQ	$CFLSW,60$	;FLAGS CAPITALIZE NOT ENABLED?
	CMPEQ	#QTSP,R1,40$	;QUOTED SPACE?
	CMPEQ	#SPC,R1,40$	;SPACE?
	CMPEQ	#TAB,R1,40$	;TAB?
	CMPNE	#LF,R1,50$	;NOT LINE FEED?
40$:	CLR	WCAS		;CLEAR WORD CASE CONVERSION
50$:	CMPNE	#WCAP,R1,60$	;NOT WORD CAPITALIZE?
	MOV	#40,WCAS	;SET WORD CAPITALIZE CONVERSION VALUE
	BR	GCIN3		;
60$:	CMPEQ	R1,#CWARN,CWR1	;QUOTING A CHARACTER?
	CMPEQ	R1,#SHUP,SHFUP	;UPSHIFT CHARACTER?
	CMPEQ	R1,#SHDN,SHFDN	;DOWNSHIFT CHARACTER?
	CMPEQ	R1,#ULCHI,ULCH	;UNDERLINE REQUEST?
 
 
	.IF DF	H$$PHN
 
	TSTEQ	$HFLSW,70$	;FLAGS HYPHENATE NOT ENABLED?
	CMPEQ	#'=,R1,FLHYP	;FLAGS HYPHENATE?
 
	.IFTF
 
70$:	CMPNE	R1,#QTSP,GCINR	;NOT QUOTED SPACE?
	MOV	#QTS,R1		;SET QUOTED SPACE
GCINR:	TSTEQ	$ULLSW,80$	;UNDERLINE SHIFT-LOCK NOT ON?
	CMPEQ	#QTS,R1,80$	;QUOTED SPACE?
	CMP	#SPC,R1		;PRINTING CHARACTER?
	BGE	80$		;IF GE NO
	MOVB	R1,ULMCH	;SAVE UNDERLINED CHARACTER
ULCH:	MOV	#ULCHS,R1	;SET TO UNDERLINE CHARACTER
	INC	NSPCH		;COUNT NONSPACING CHARACTERS
80$:	RETURN			;
	.DSABL	LSB
 
	.IFT
 
;
; FLAG HYPHENATE CHARACTER
;
 
FLHYP:	CALL	GCIN		;GET NEXT CHARACTER WITH TRANSLATE
	CALL	ALPH1		;ALPHABETIC CHARACTER?
	BCS	GCINR		;IF CS NO
	BISB	#200,R1		;DISABLE HYPHENATION ON THIS WORD
	BR	GCINR		;
 
	.ENDC
 
 
;SPECIAL CASES OF INPUT CHARACTER

CWR1:	CALL	CCIN		;READ CHARACTER  NO TRANSLATION
	BR	GCINR		;AND RETURN IT.  MAYBE UNDERLINED

;MORE SPECIAL CASES OF GET-CHARACTER ROUTINE

	.ENABL	LSB
SHFUP:	CALL	CCIN		;READ A CHARACTER
	CMPEQ	R1,#ULCHI,ULMON	;LOCK ON UNDERLINE?
	CMPNE	R1,#SHUP,20$	;NOT DOUBLE UPSHIFT?
	CALL	UPCAS		;SET UPPER CASE
10$:	BR	GCIN3		;AND GO READ ANOTHER CHARACTER
20$:	CALL	ALPH1		;ALPHABETIC CHARACTER?
30$:	BCS	GCIN6		;IF CS NO
	CMP	#'A+40,R1	;LOWER CASE?
40$:	BHI	GCINR		;IF HI NO
	CMP	#'Z+40,R1	;LOWER CASE?
50$:	BLO	GCINR		;IF LO NO
	SUB	#40,R1		;CONVERT TO UPPER CASE
	BR	GCINR		;
SHFDN:	CALL	CCIN		;GET ANOTHER CHARACTER
	CMPEQ	R1,#ULCHI,ULMOF	;UNLOCK UNDERLINE?
	CMPNE	R1,#SHDN,60$	;NOT SECOND DOWNSHIFT?
	CALL	LWCAS		;SET LOWER CASE
	BR	10$		;
60$:	CALL	ALPH1		;ALPHABETIC CHARACTER?
	BCS	30$		;IF CS NO
	CMP	#'A,R1		;IN RANGE FOR LOWERING?
	BHI	40$		;IF HI NO
	CMP	#'Z,R1		;IN RANGE FOR LOWERING?
	BLO	50$		;IF LO NO
	ADD	#40,R1		;YES.  MAKE IT LOWER CASE
	BR	GCINR		;
ULMON:	MOV	SP,$ULLSW	;UNDERLINE LOCKED ON
	BR	10$
ULMOF:	CLR	$ULLSW		;UNDERLINE LOCKED OFF
	BR	10$		;
	.DSABL	LSB
 
;ROUTINE TO READ INPUT FROM FILE OR FOOTNOTE AS APPROPRIATE

CCIN::	MOVB	GCSCH,R1	;ANY CHARACTER SAVED FROM EARLIER PASS?
	BNE	30$		;IF NE YES
	TSTEQB	$SDISW,20$	;INPUT NOT FROM SECONDARY BUFFER?
	MOV	#SDINP,R4	;SET ADDRESS OF LINE DESCRIPTOR
	CALL	GCI		;GET CHARACTER FROM BUFFER
	.WORD	10$		;NONE
	RETURN			;
10$:	CLRB	$SDISW		;CLEAR INPUT FROM SECONDARY BUFFER
20$:	BITNE	#FOTF,F.1,40$	;CHARACTERS COMING FROM FOOTNOTE?
	JMP	FIN		;NO.  READ FROM FILE
30$:	CLRB	GCSCH		;CLEAR SAVED CHARACTER
	RETURN			;
40$:	MOV	#FOOTP1,R4	;GET CHARACTER FROM FOOTNOTE STRING
	CALL	GCI		;GET THE CHARACTER
	.WORD	50$		;NONE LEFT
 	RETURN			;
50$:	CALL	$ERMSG		;GIVE THE HALT MESSAGE
	+HALTM
	JMP	RUNOFF		;RESTART RUNOFF


;ROUTINE TO FIND NEXT TABSTOP FOR OUTLIN ROUTINE.

TABB:	CLR	R0		;START AT FIRST TABSTOP
	BR	20$		;PRE-ENDCHECK, IN CASE NONE.
10$:	MOVB	TABTAB-1(R0),R4	;GET CURRENT TAB STOP
	CMP	R2,R4		;THIS STOP BEYOND CURRENT POS?
	BLO	40$		;YES.  GET DIFFERENCE
20$:	CMP	R0,NTABS	;LOOKED AT ALL TAB STOPS?
	BHIS	30$
	INC	R0		;ADVANCE TO NEXT ENTRY
	BR	10$
30$:	MOV	RMARG,R4	;YES.  ASSUME A TABSTOP AT RIGHT END
40$:	SUB	R2,R4		;GET DISTANCE TO TABSTOP
	MOV	R4,R2		;ANSWER IN A
	RETURN			;


;ROUTINE TO SPACE TO TOP OF FORM

FORM:	MOV	LINEC,R2	;GET CURRENT LINE POSITION
	BEQ	50$		;IF EQ ALREADY AT TOP
	BITEQ	#FFDSW,$SWTCH,10$ ;SPACING WITH LINE FEEDS?
	MOV	#FF,R1		;OUTPUT A FORMFEED
	CALL	FOUT		;
	BR	30$		;ADJUST COUNTS
10$:	SUB	#HWPLN,R2	;GET - NUMBER OF LINES TO TOP OF PAGE
	BPL	10$		;IF PL LOOP
20$:	CALL	CRLF		;SPACE TO NEXT LINE
	INC	R2		;..
	BLT	20$
30$:	CLR	LINEC		;CURRENT LINE NOW ZERO
	TSTNE	$SBPSW,40$	;SUBPAGE?
	INC	PAGENO		;COUNT PAGE NUMBER
40$:	BITEQ	#PAUSW,$SWTCH,50$ ;DON'T WAIT FOR NEW PAPER?
	CALL	OUTPUT		;FLUSH ANY OUTPUT
	BITEQB	#FD.TTY,TTIBLK+F.RCTL,50$ ;COMMAND INPUT FROM OTHER THAN TERMINAL?
	CALL	TTC4N		;READ A CHARACTER
50$:	RETURN			;

;ROUTINE TO BREAK PAGE AND OUTPUT HEADING

	.ENABL	LSB
PAGEC::	CLR	$SBPSW		;CLEAR SUBPAGE FLAG
	MOV	#SPC,SUBPGE	;RESET SUBPAGE NUMBER
	BR	BPAGE		;
TPAGE::	MOV	SP,$SBPSW	;SET SUBPAGE FLAG
	INC	SUBPGE		;INCREMENT SUBPAGE
BPAGE::	CLR	$PGPSW		;CLEAR PAGE PENDING FLAG
	BITNE	#FOTF,F.1,50$	;ALREADY PROCESSING A FOOTNOTE?
	CMPEQ	FOOTP1,FOOTP2,50$ ;NO DATA IN FOOTNOTE BUFFER?
	MOV	NLPG,R2		;GET STARTING FOOTNOTE LINE
	MOV	#100.,NLPG	;SET LARGE COUNT
	SUB	LINEC,R2	;CALCULATE DISTANCE TO FIRST FOOTNOTE
	BLOS	10$		;IF LOS SOME LEFT TO GO
	CALL	SKIPN		; SKIP TO END OF PAGE BEFORE FOOTNOTES
10$:	MOV	R5,-(SP)	;SAVE REGISTER R5
	MOV	#F.1,R5		;POINT TO FLAG WORD
	MOV	RMARG,-(SP)	;SAVE THESE ITEMS OVER FOOTNOTE PROCESSING
	MOV	LMARG,-(SP)
	MOV	PARIND,-(SP)	;SAVE PARA INDENTING
	MOV	NSPNG,-(SP)
	MOVB	GCSCH,-(SP)
	MOV	INDCT,-(SP)	;OCCASSIONALLY WE NEED TO SAVE THIS
	MOV	(R5),-(SP)	;SAVE CURRENT FLAG WORD
	CLR	INDCT		;CLEAR IT FOR RANDOM FAILURES
	CLR	LMARG		;RESET LEFT MARGIN
	MOV	PRMRG,RMARG	;RESET RIGHT MARGIN
	CLRB	GCSCH		;CLEAR SAVED CHARACTER
	MOV	FOOTS1,FOOTS2	;BUFFER IS EMPTY
	MOVB	$GCISW,-(SP)	;SAVE REREAD FLAG
	BEQ	30$		;IF EQ NOT SET
20$:	CALL	GGCINP		;GET A CHARACTER FROM SAVED BUFFER
	.WORD	30$		;NONE LEFT
	MOV	#FOOTS1,R4	;SAVE BUFFER
	CALL	WCI
	BR	20$		;LOOP UNTIL SAVED BUFFER ALL MOVED
30$:	CLRB	$GCISW		;CLEAR REREAD BUFFER FLAG
	MOV	SPSAV,-(SP)	;SAVE BASE OF STACK
	MOV	SP,SPSAV	;SET NEW STACK BASE
	BIS	#FOTF,(R5)	;SET FOOTNOTE PROCESSING ACTIVE
	CALL	LINSET		;INITIALIZE LINE FOR START OF FOOTNOTE
40$:	JMP	LGO		;AND GO PROCESS SAVED FOOTNOTE COMMANDS

;
; END OF FOOTNOTE PROCESSING
;

FOOTND:	CALL	OUTNJ		;YES. FINISH UP LINE
	CMPNE	FOOTP1,FOOTP2,40$ ;ANY MORE FOOTNOTES TO PROCESS?
	MOV	FOOTP3,FOOTP1	;RESET FOOTNOTE BUFFER POINTERS
	MOV	FOOTP3,FOOTP2	;
	CLR	EXSP3		;CLEAR LEFT RIGHT FLAG
	MOV	SPSAV,SP	;RESET STACK TO CURRENT BASE
	MOV	(SP)+,SPSAV	;RESTORE OLD STACK BASE
	MOVB	(SP)+,$GCISW	;RESTORE REREAD FLAG
	MOV	(SP)+,(R5)	;RESTORE FLAG WORD
	MOV	(SP)+,INDCT	;RESTORE INDENT COUNT
	MOVB	(SP)+,GCSCH	;RESTORE SAVED CHARACTER
	MOV	(SP)+,NSPNG	;RESTORE CURRENT SPACING
	MOV	(SP)+,PARIND	;RESTORE PARAGRAPH INDENT
	MOV	(SP)+,LMARG	;RESTORE LEFT MARGIN
	MOV	(SP)+,RMARG	;RESTORE RIGHT MARGIN
	BIC	#FOTF,(R5)	;CLEAR FOOTNOTE PROCESSING FLAG
	MOV	(SP)+,R5	;RESTORE REGISTER R5
	MOV	PNLPG,NLPG	;RESET LENGTH OF PAGE
	MOV	FOOTS1,GCINP	;RESTORE REREAD DESCRIPTOR
	MOV	FOOTS2,GCINP+2	;
50$:	CALL	FORM		;OUTPUT FORMFEEDS OR LINEFEEDS
	CALL	SKIP1		;SKIP ONE LINE
	TSTEQ	$HDRSW,160$	;NO HEADERS TO BE PRINTED?
	MOV	#4,R2		;ASSUME HEADER NOT ENABLED
	TSTNEB	$HDSSW,130$	;HEADER DISABLED?
	MOV	#TTLP1,R4	;OUTPUT TITLE TO FILE
	CALL	PSTRPA		;PRINT STRING FROM PA
	TSTEQ	$NUMSW,120$	;NO PAGE NUMBER?
	MOV	RMARG,R2	;FIND POSITION WHERE THIS LEFT US
	BITEQ	#SPECF,F.1,55$	;NO SPECIAL HANDLING IN PROGRESS?
	CMPNE	ENOTE,CMADR,55$	;NOT PROCESSING A NOTE?
	MOV	NOTRM,R2	;GET RIGHT MARGIN BEFORE NOTE
55$:	SUB	TTLLEN,R2	;deduct for TITLE CHARACTERS
	TSTEQ	$SBPSW,60$	;NO SUBPAGE?
	DEC	R2		;MAKE ROOM FOR LETTER
60$:	SUB	#5.,R2		;ADJUST FOR SPACE REQUIRED BY 'PAGE '
	MOV	APNDN,R3	;GET CURRENT APPENDIX LEVEL
	BEQ	70$		;IF EQ NONE SPECIFIED
	SUB	#2,R2		;ADJUST FOR APPENDIX LETTER AND DASH
;	CMPB	-(R2),-(R2)	;ADJUST FOR APPENDIX LETTER AND DASH
	BR	80$		;
70$:	MOVB	CHPTN,R3	;GET CURRENT CHAPTER NUMBER
	BEQ	80$		;IF EQ NONE SPECIFIED
	MOV	R3,R0		;CALCULATE SPACE COUNT FOR CHAPTER NUMBER
	CALL	PPGNO		;
	DEC	R2		;ADJUST FOR DASH
80$:	MOV	PAGENO,R0	;GET CURRENT PAGE NUMBER
	CMPEQ	#1,R0,120$	;PAGE NUMBER ONE?
	CALL	PPGNO		;CALCULATE SPACE COUNT FOR PAGE NUMBER
	CALL	NSPAC		;SPACE TO PAGE NUMBER
	MOV	#PAGHD,S1	;SET ADDRESS OF OUTPUT MESSAGE
	CALL	FMSG		;OUTPUT 'PAGE '
	TSTEQ	R3,110$		;NO CHAPTER OR APPENDIX SPECIFIED?
	MOV	APNDN,R1	;GET CURRENT APPENDIX LETTER
	BEQ	90$		;IF EQ NONE SPECIFIED
	ADD	#'A-1,R1	;CONVERT TO UPPER CASE ASCII
	CALL	FOUT		;OUTPUT APPENDIX LETTER
	BR	100$		;
90$:	MOV	R3,R0		;SET CHAPTER NUMBER
	CALL	DECPRT		;OUTPUT CHAPTER NUMBER
100$:	MOV	#'-,R1		;OUTPUT A DASH
	CALL	FOUT		;
110$:	MOV	PAGENO,R0	;GET CURRENT PAGE NUMBER
	CALL	DECPRT		;OUTPUT PAGE NUMBER
	TSTEQ	$SBPSW,120$	;NO SUBPAGE?
	MOV	SUBPGE,R1	;RETRIEVE THE LETTER
	ADD	#' ,R1		;MAKE AN ASCII LETTER
	CALL	FOUT		;GET IT INTO OUTPUT BUFFER
120$:	CALL	SKIP1		;SKIP ONE LINE
	MOV	#STTLP1,R4	;OUTPUT THE SUBTITLE, IF ANY
	CALL	PSTRPA		;..
	MOV	#3,R2		;AND OUTPUT THIS LINE.
130$:	CLRB	$HDSSW		;ENABLE HEADER
	JMP	SKIPN		;INCLUDING SUBTITLE, AND RETURN FROM BPAGE
 
;SUBROUTINE FOR PAGE NUMBER OUTPUT

PPGNO:	CMP	#100.,R0	;THREE DIGIT NUMBER
	BGT	140$		;IF GT NO
	DEC	R2		;ADJUST FOR HUNDREDS DIGIT
140$:	CMP	#10.,R0		;TWO DIGIT NUMBER?
	BGT	150$		;IF GT NO
	DEC	R2		;ADJUST FOR TENS DIGIT
150$:	DEC	R2		;ADJUST FOR ONES DIGIT
160$:	RETURN			;
	.DSABL	LSB
DECPRT::MOV	#12,R1		;STANDARD DECIMAL PRINT ROUTINE
	CALL	$DIV		;DIVIDE
	MOV	R1,-(SP)
	TSTEQ	R0,10$		;NO MORE DIGITS TO CONVERT?
	CALL	DECPRT		;NO
10$:	MOV	(SP)+,R1	;GET A DIGIT
	ADD	#60,R1		;MAKE ASCII DIGIT
	JMP	FOUT		;OUTPUT TO FILE.

; ROUTINES TO GET CHARACTER AND INCREMENT STRING POINTER
 
GGCINP:	MOV	#GCINP,R4
	BR	GCI
GLOUT:	MOV	#LOUT1,R4	;PARTICULAR ARGUMENT
GCI::	CMP	(R4)+,(R4)	;ANYTHING IN STRING
	BHIS	10$		;IF HIS NO
	INC	-(R4)		;YES.  COUNT AND GET FIRST POINTER
	CLR	R1		;PICKUP NEXT CHARACTER
	BISB	@(R4)+,R1	;
	ADD	#2,(SP)		;FORCE SKIP RETURN
	RETURN			;
10$:	MOV	@(SP)+,PC	;SET SKIP RETURN

;ROUTINES TO WRITE CHARACTER AND INCREMENT POINTERS

WCIFTN::MOV	#FOOTP1,R4	;POINT TO FOOTNOTE DESCRIPTOR
	BR	WCI		;
WLNIN1::MOV	#LNIN1,R4	;STANDARD ARG
WCI::	TST	(R4)+		;POINT TO SECOND WORD OF DESCRIPTOR
	INC	(R4)		;INCREMENT TO NEXT BYTE
	CMP	(R4)+,(R4)	;BUFFER OVERFLOW?
	BHIS	10$		;IF HIS YES
	MOVB	R1,@-(R4)	;STORE BYTE
	RETURN			;
10$:	CALL	$ERMSG		;OUTPUT ERROR MESSAGE
	.WORD	BFOVF		;
	JMP	RUNOFF		;

;
; START OF RUNOFF 
;
 
START:	JMP	$START		;
                                                                                
	.END START
