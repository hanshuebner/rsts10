TITLE	FMTCM,<RUNOFF COMMANDS>,14,18-APR-85,DNC/CM

;
;		COPYRIGHT (c) 1974, 1985 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

;
; VERSION M01
;
; AUTHOR: D. N. CUTLER 22-SEP-75
;
; RUNOFF COMMANDS
;
; ALL COMMAND ROUTINES ARE ENTERED WITH:
;
;	R4=ADDRESS OF NUMBER CONVERSION ROUTINE.
;	R5=ADDRESS OF FLAG WORD F.1.
;
; LOCAL DATA
;
; OUTPUT TEXT
;

APNMG:	.ASCIZ	/APPENDIX /	;APPENDIX HEADING PROTOTYPE
CHAPT:	.ASCIZ	/CHAPTER /	;CHAPTER HEADING PROTOTYPE
LOWER:	.ASCIZ	/LOWER/<0><'P+40><'A+40><'G+40><'E+40><' > ;LOWER CASE PAGE
MIXED:	.ASCIZ	/MIXED/<0><'P><'A+40><'G+40><'E+40><' > ;MIXED CASE PAGE
NOTET:	.ASCIZ	/NOTE/		;NOTE HEADING PROTOTYPE
UPPER:	.ASCIZ	/UPPER/<0>/PAGE/<' > ;UPPER CASE PAGE
	.EVEN

;
; APPENDIX COMMAND
;

	.ENABL	LSB
APNDX::	MOV	#APNMG,-(SP)	;SET ADDRESS OF APPENDIX HEADING
	BR	10$		;

;
; CHAPTER COMMAND
;

CHPTR::	MOV	#CHAPT,-(SP)	;SET ADDRESS OF CHAPTER HEADING
10$:	CLR	TTLLEN		;CLEAR TITLE LENGTH
	MOV	TTLP1,TTLP2	;CLEAR TITLE BUFFER
	MOV	STTLP1,STTLP2	;CLEAR SUBTITLE BUFFER
	CLR	LMARG		;SET LEFT MARGIN
	MOV	PRMRG,RMARG	;SET RIGHT MARGIN
	MOV	#SPCNG,NSPNG	;SET INITIAL SPACING
	BIS	#FILLF!JUSTF!PJUSTF,(R5) ;SET FILL AND JUSTIFY FLAGS
	CLR	PAGENO		;SET INITIAL PAGE NUMBER
	TSTNE	LINEC,15$	;NOT AT TOP OF PAGE ALREADY?
	INC	PAGENO		;INCREMENT PAGE NUMBER
15$:	CALL	PAGEC		;BREAK CURRENT PAGE
	MOV	#7.,R2		;SET LINE COUNT
	CALL	SKIPN		;SKIP SEVEN LINES
	MOV	RMARG,R2	;CALCULATE SPACE COUNT TO HEADING
	ASR	R2		;
	SUB	#5.,R2		;
	CALL	NSPAC		;SPACE TO CHAPTER HEADING
	MOV	(SP),S1		;SET ADDRESS OF OUTPUT HEADING
	CALL	FMSG		;OUTPUT HEADING
	MOV	#CHPTN+4,R0	;POINT TO LAST LEVEL NUMBER
	CLR	(R0)		;CLEAR LEVEL NUMBERS
	CLR	-(R0)		;
	CLRB	-(R0)		;
	CMPEQ	#CHAPT,(SP)+,20$ ;CHAPTER COMMAND?
	INC	APNDN		;INCREMENT APPENDIX LETTER
	MOVB	APNDN,R1	;GET APPENDIX LETTER
	ADD	#'A-1,R1	;CONVERT TO UPPER CASE LETTER
	CALL	FOUT		;OUTPUT LETTER
	BR	30$		;
20$:	INCB	-(R0)		;INCREMENT CHAPTER NUMBER
	MOVB	(R0),R0		;GET CHAPTER NUMBER
	CALL	DECPRT		;OUTPUT CURRENT CHAPTER NUMBER
30$:	MOV	#2.,R2		;SET LINE COUNT
	CALL	SKIPN		;SKIP TWO LINES
	CALL	SETTL		;MOVE TITLE TO BUFFER
	MOV	RMARG,R2	;CALCULATE SPACE TO CENTER TEXT
	SUB	TTLLEN,R2	;DEDUCT for TITLE characters
	ASR	R2		;
	CALL	NSPAC		;SPACE TO START OF TEXT
	MOV	#TTLP1,R4	;POINT TO TITLE DESCRIPTOR
	CALL	PSTRPA		;OUTPUT CONTENTS OF TITLE BUFFER
	MOV	#4.,R2		;SET LINE COUNT
	JMP	SKIPN		;SKIP FOUR LINES
	.DSABL	LSB

;
; HEADER COMMAND
;

HEADP::	CALL	$FRCND		;FORCE TO LOGICAL END OF LINE
	MOV	#UPPER,R2	;ASSUME UPPER CASE SPECIFIED
	CMPEQ	#CR,R1,25$	;CARRIAGE RETURN?
	CMPEQ	#SEMI,R1,25$	;SEMICOLON?
	CALL	50$		;READ FIRST CHARACTER
	CMPEQB	R1,(R2)+,10$	;FIRST CHARACTER MATCH?
	MOV	#MIXED,R2	;ASSUME 'MIXED' KEYWORD
	CMPEQB	R1,(R2)+,10$	;FIRST CHARACTER MATCH?
	MOV	#LOWER,R2	;ASSUME 'LOWER' KEYWORD
	CMPNEB	R1,(R2)+,10$	;FIRST CHARACTER MISMATCH?
10$:	TSTEQB	(R2),30$	;NO MORE CHARACTERS TO MATCH?
	CALL	50$		;READ ANOTHER CHARACTER
	CMPEQB	R1,(R2)+,10$	;CHARACTER MATCH?
20$:	JMP	ILCM		;ILLEGAL COMMAND
25$:	TSTNEB	(R2)+,25$	;SEARCH FOR END OF STRING
	DEC	R2		;ADJUST FOR FOLLOWING INCREMENT
30$:	INC	R2		;POINT TO PAGE PROTOTYPE
	MOV	#PAGHD,R1	;POINT TO PAGE HEADER AREA
40$:	MOVB	(R2)+,(R1)+	;MOVE PROTOTYPE
	BNE	40$		;IF NE MORE TO GO
	MOV	#5,$HDRSW	;SET TO PRINT PAGE HEADERS
	RETURN			;
50$:	CALL	CCIN		;READ NEXT CHARACTER
	CMP	#'A+40,R1	;LOWER CASE?
	BHI	60$		;IF HI NO
	CMP	#'Z+40,R1	;LOWER CASE?
	BLO	60$		;IF LO NO
	BIC	#40,R1		;CONVERT TO UPPER CASE
60$:	RETURN			;

;
; NOHEADER COMMAND
;

NHEAD::	CLR	$HDRSW		;SET TO NOT PRINT PAGE HEADERS
	RETURN			;

;
; HEADER LEVEL COMMAND
;

HEADR::	CALL	(R4)		;GET HEADING LEVEL NUMBER
10$:	JMP	ILCM		;MUST BE LEVEL NUMBER
	DEC	R3		;REDUCE LEVEL BY ONE
	CMP	R3,#4.		;LEGAL LEVEL NUMBER?
	BHI	10$		;IF HI NO
	ADD	#CHPTN+1,R3	;POINT TO LEVEL COUNTER
	INCB	(R3)+		;INCREMENT LEVEL NUMBER
20$:	CMP	R3,#CHPTN+5	;END OF LEVEL NUMBERS?
	BHI	30$		;IF HI YES
	CLRB	(R3)+		;CLEAR NEXT LEVEL NUMBER
	BR	20$		;
30$:	TSTEQB	-(R3),30$	;ZERO LEVEL?
	MOV	R3,-(SP)	;SAVE ADDRESS OF LAST LEVEL TO PRINT
	MOV	#8.,R3		;SET TEST PAGE VALUE
	CALL	TESTP		;TEST IF PAGE SHOULD BE BROKEN
	CMP	$HDRSW,LINEC	;IN HEADER REGION OF PAGE?
	BGE	33$		;IF GE YES
	MOV	#3.,R2		;SET LINE COUNT
	CALL	SKIPN		;SKIP THREE LINES
33$:	MOV	#SDINP+2,R5	;GET ADDRESS OF SECONDARY BUFFER DESCRIPTOR
	MOV	#SDBUF-1,(R5)	;INITIALIZE DESCRIPTOR
	MOV	(R5),-(R5)	;
	MOV	#SDWCI,R3	;SET ADDRESS OF WRITE CHARACTER ROUTINE
	CMP	#CHPTN+3,(SP)	;HEADING LEVEL 1 OR 2?
	BLOS	35$		;IF LOS NO
	MOV	LMARG,R2	;GET VALUE OF LEFT MARGIN
	ADD	INDCT,R2	;ADD IN INDENTATION
	CLR	INDCT		;
	CALL	NSPAC		;SPACE TO LEFT MARGIN
35$:	MOV	#CHPTN,R2	;POINT TO CHAPTER/LEVEL TABLE
	MOVB	APNDN,R1	;GET CURRENT APPENDIX NUMBER
	BEQ	37$		;IF EQ NONE
	INC	R2		;POINT PAST CHAPTER NUMBER
	ADD	#'A-1,R1	;CONVERT TO ASCII CHARACTER
	CALL	(R3)		;WRITE CHARACTER IN BUFFER
	BR	55$		;
37$:	MOVB	(R2)+,R0	;GET CHAPTER NUMBER
	BNE	50$		;IF NE CHAPTER ORIENTED DOCUMENT
	CMPNE	R2,(SP),40$	;NOT HEADER LEVEL 1?
	INC	(SP)		;PRINT TRAILING ZERO
40$:	MOVB	(R2)+,R0	;GET NEXT LEVEL NUMBER
50$:	CALL	CVTNM		;CONVERT CHAPTER/LEVEL NUMBER
	CMP	R2,(SP)		;LAST NUMBER CONVERTED?
	BHI	60$		;IF HI YES
55$:	MOV	#PD,R1		;WRITE PERIOD INTO BUFFER
	CALL	(R3)		;
	BR	40$		;
60$:	CMP	#CHPTN+3,(SP)+	;HEADING LEVEL 3, 4, OR 5?
	BHI	80$		;IF HI NO
	MOV	#'#,R1		;WRITE TWO QUOTED SPACES INTO BUFFER
	CALL	(R3)		;
	CALL	(R3)		;
	CALL	$FRCND		;FORCE TO LOGICAL END OF COMMAND
70$:	CALL	CCIN		;READ CHARACTER FROM FILE
	CMPEQ	#CR,R1,75$	;CARRIAGE RETURN?
	CALL	(R3)		;WRITE CHARACTER IN BUFFER
	BR	70$		;
75$:	MOV	(PC)+,R1	;GET QUOTED SPACE AND DASH
	.ASCII	/#-/		;
	CALL	(R3)		;WRITE QUOTED SPACE INTO BUFFER
	SWAB	R1		;SWAP DASH TO RIGHT BYTE
	CALL	(R3)		;WRITE DASH INTO BUFFER
	SWAB	R1		;SWAP QUOTED SPACE TO RIGHT BYTE
	CALL	(R3)		;WRITE QUOTED SPACE INTO BUFFER
	MOV	#CR,R1		;WRITE CARRIAGE RETURN INTO BUFFER
	CALL	(R3)		;
	BR	LINEP		;FINISH IN COMMON CODE
80$:	MOV	#' ,R1		;GET A SPACE CHARACTER
	CALL	(R3)		;WRITE TWO SPACES INTO BUFFER
	CALL	(R3)		;
	CALL	SHFUC		;SHIFT TO UPPER CASE FOR HEADING LINE
	CALL	SETBF		;TRANSFER REMAINDER OF LINE TO BUFFER
	MOV	R5,R4		;SET ADDRESS OF LINE DESCRIPTOR
	CALL	PSTRPA		;OUTPUT HEADING LINE
	MOV	#2.,R2		;SET LINE COUNT
	JMP	SKIPN		;SKIP TWO LINES

;
; LIST COMMAND
;

	.ENABL	LSB
LISTC::	CALL	(R4)		;GET LIST VERTICLE SPACING
	MOV	LSTVS,R3	;DEFAULT TO CURRENT SPACING
	CMP	R3,#5		;LEGAL VALUE?
	BHI	30$		;IF HI NO
	MOV	LSTKP,R0	;GET CURRENT LIST STACK POINTER
	MOVB	LMARG,(R0)+	;SAVE LEFT MARGIN
	MOVB	LSTCT,(R0)+	;SAVE LIST ELEMENT COUNT
	MOV	F.1,(R0)+	;SAVE FLAG WORD
	MOV	CMADR,(R0)+	;SAVE EXPECTED COMMAND ADDRESS
	CMP	R0,#LSTK+<5*3*2> ;LIST STACK OVERFLOW?
	BHI	30$		;IF HI YES
	MOV	R0,LSTKP	;SAVE NEW LIST STACK POINTER
	MOV	R3,LSTVS	;SET NEW LIST VERTICLE SPACING
	BIS	#SPECF,(R5)	;SET SPECIAL PROCESSING FLAG
	CLRB	LSTCT		;CLEAR CURRENT LIST ELEMENT NUMBER
	MOV	#LSLMAR,R4	;ASSUME EMBEDDED LIST INDENT
	CMPNE	#LSTK+<3*2>,R0,10$ ;NOT FIRST ITEM IN STACK?
	MOV	#LOLMAR,R4	;SET FOR INITIAL LIST INDENT
10$:	ADD	LMARG,R4	;CALCULATE NEW LEFT MARGIN
	CMP	R4,RMARG	;OVERLAP RIGHT MARGIN?
	BLT	20$		;IF LT NO
	CALL	$ERMSG		;WARN USER ABOUT OVERLAP
	.WORD	LSTERR		;
	CALL	ONPAG		;INDICATE WHICH PAGE IT WAS ON
	MOV	LMARG,R4	;REINITIALIZE TO LEFT MARGIN
20$:	MOV	R4,LMARG	;SET NEW LEFT MARGIN
	MOV	ELSTC,CMADR	;SET EXPECTED COMMAND ADDRESS
	RETURN			;
30$:	JMP	ILCM		;

;
; LIST ELEMENT COMMAND
;

LSTEL::	CALL	(R4)		;GET LIST PAGE TEST COUNT
	MOV	LSTPT,R3	;DEFAULT IS CURRENT VALUE
	CMP	R3,PNLPG	;VALUE WITHIN REASON?
	BHI	30$		;IF HI NO
	MOV	R3,LSTPT	;SET NEW LIST PAGE TEST COUNT
	CALL	TESTP		;TEST IF PAGE SHOULD BE BROKEN
	MOV	LSTVS,R1	;GET LIST ELEMENT VERTICLE SPACING
	CALL	LSTTP		;PERFORM LIST SPACING
	MOV	#-4,INDCT	;INDENT LIST ELEMENT FOUR SPACES
	INCB	LSTCT		;INCREMENT LIST ELEMENT NUMBER
	MOV	#SDINP+2,R5	;POINT TO SECONDARY INPUT LINE DESCRIPTOR
	MOV	#SDBUF-1,(R5)	;INITIALIZE DESCRIPTOR
	MOV	(R5),-(R5)	;
	MOVB	LSTCT,R0	;GET CURRENT ELEMENT NUMBER
	CALL	CVTNM		;CONVERT NUMBER TO ASCII
	MOV	(PC)+,R1	;GET QUOTED SPACE AND PERIOD
	.ASCII	/.#/		;
	CALL	SDWCI		;WRITE PERIOD INTO BUFFER
	SWAB	R1		;SWAP QUOTED SPACE TO LEFT BYTE
	CALL	SDWCI		;WRITE QUOTED SPACE INTO BUFFER
	CMPB	LSTCT,#10.	;TWO DIGIT NUMBER?
	BGE	40$		;IF GE YES
	CALL	SDWCI		;WRITE ANOTHER QUOTED SPACE
40$:	CALL	$FRCND		;FORCE TO LOGICAL END OF COMMAND
	CALL	CCIN		;READ BREAK CHARACTER
	CALL	SDWCI		;WRITE CHARACTER INTO SECONDARY BUFFER
LINEP:	COMB	$SDISW		;SET SECONDARY INPUT FLAG
	TST	(SP)+		;CLEAN STACK
	CALL	LINSET		;RESET LINE PARAMETERS
	JMP	TEXT		;PROCESS TEXT
	.DSABL	LSB

;
; END LIST COMMAND
;

ELIST::	MOV	LSTKP,R0	;GET CURRENT LIST STACK POINTER
	MOV	-(R0),CMADR	;RESTORE EXPECTED COMMAND ADDRESS
	MOV	-(R0),R1	;GET FLAG BYTE AND SPACING COUNT
	BITNE	#SPECF,R1,10$	;SPECIAL PROCESSING PREVIOUSLY ACTIVE?
	BIC	#SPECF,(R5)	;CLEAR SPECIAL PROCESSING ACTIVE FLAG
10$:	MOVB	-(R0),LSTCT	;RESTORE PREVIOUS LIST ELEMENT NUMBER
	MOVB	-(R0),LMARG	;RESTORE PREVIOUS LEFT MARGIN
	MOV	R0,LSTKP	;SAVE NEW LIST STACK POINTER
	MOV	#LFSPAC,R2	;SET FINAL SKIP COUNT
	JMP	SKIPN		;SKIP LINES

;
; NOTE COMMAND
;

NOTE::	MOV	#8.,R3		;SET PAGE TEST COUNT
	CALL	TESTP		;TEST IF PAGE SHOULD BE BROKEN
	CMP	$HDRSW,LINEC	;IN HEADER REGION OF PAGE?
	BGE	3$		;IF GE YES
	MOV	#NHSPAC,R2	;SET LINE COUNT
	CALL	SKIPN		;SKIP LINES
3$:	MOV	#NPMARG*2,R3	;ASSUME AT LEFT MARGIN
	MOV	#RMARG,R4	;POINT TO RIGHT MARGIN COUNT
	MOV	(R4)+,-(SP)	;CALCULATE SPREAD IN MARGINS
	TSTEQ	(R4),7$		;AT LEFT MARGIN?
	MOV	#NSMARG*2,R3	;SET SECONDARY INDENT VALUE
7$:	SUB	(R4),(SP)	;
	CMP	R3,(SP)+	;SPREAD LARGE ENOUGH?
	BLT	10$		;IF LT YES
	CALL	$ERMSG		;WARN USER ABOUT MARGIN
	.WORD	NOTERR		;
	CALL	ONPAG		;OUTPUT PAGE NUMBER
	CLR	R3		;INDICATE NO ADJUSTMENT
10$:	MOV	(R4),NOTLM	;SAVE CURRENT LEFT MARGIN
	MOV	-(R4),NOTRM	;SAVE CURRENT RIGHT MARGIN
	ASR	R3		;REDUCE TO ACTUAL MARGIN REDUCTION
	SUB	R3,(R4)+	;REDUCE RIGHT MARGIN
	ADD	R3,(R4)		;INCREASE LEFT MARGIN
	MOV	(R5),NOTSV	;SAVE CURRENT FLAGS WORD
	BIS	#FILLF!JUSTF!PJUSTF!SPECF!NOTF,(R5) ;SET FLAGS
	MOV	CMADR,NOTCM	;SAVE CURRENT EXPECTED COMMAND ADDRESS
	MOV	ENOTE,CMADR	;SET EXPECTED COMMAND ADDRESS
	MOV	#SDINP+2,R5	;GET ADDRESS OF SECONDARY INPUT DESCRIPTOR
	MOV	#SDBUF-1,(R5)	;INITIALIZE DESCRIPTOR
	MOV	(R5),-(R5)	;
	CALL	SETBF		;TRANSFER TEXT TO BUFFER
	CMPNE	(R5),2(R5),30$	;ANY TEXT GIVEN?
	MOV	#NOTET,R3	;POINT TO NOTE TEXT PROTOTYPE
20$:	MOVB	(R3)+,R1	;GET NEXT CHARACTER IN STRING
	BEQ	30$		;IF EQ DONE
	MOV	R5,R4		;SET DESCRIPTOR ADDRESS
	CALL	WCI		;WRITE CHARACTER IN BUFFER
	BR	20$		;
30$:	MOV	RMARG,R2	;CALCULATE SPACE COUNT TO CENTER NOTE TEXT
	ADD	(R5),R2		;
	SUB	2(R5),R2	;
	SUB	LMARG,R2	;
	ASR	R2		;
	ADD	LMARG,R2	;
	CALL	NSPAC		;SPACE TO TEXT POSITION
	MOV	R5,R4		;SET ADDRESS OF LINE DESCRIPTOR
	CALL	PSTRPA		;OUTPUT NOTE TEXT
	MOV	#NASPAC+1,R2	;SET LINE COUNT
	JMP	SKIPN		;SKIP LINES

;
; END NOTE COMMAND
;

ENOTC::	MOV	NOTSV,(R5)	;RESTORE FLAGS WORD
	MOV	NOTCM,CMADR	;RESTORE PREVIOUS EXPECTED COMMAND ADDRESS
	MOV	NOTRM,RMARG	;INCREASE RIGHT MARGIN
	MOV	NOTLM,LMARG	;DECREASE LEFT MARGIN
	MOV	#NFSPAC,R2	;SET SKIP COUNT
	JMP	SKIPN		;SKIP LINES

;
; NUMBER APPENDIX COMMAND
;

	.ENABL	LSB
NAPDX::	CALL	CCIN		;READ NEXT CHARACTER
	CMPEQ	#SPC,R1,NAPDX	;SPACE?
	CMPEQ	#TAB,R1,NAPDX	;TAB?
	CMP	#'A,R1		;LETTER?
	BHI	10$		;IF HI NO
	CMP	#'Z,R1		;LETTER?
	BLO	10$		;IF LO NO
	SUB	#'A,R1		;SET FOR NEXT APPENDIX COMMAND
	MOVB	R1,APNDN	;
	RETURN			;

;
; NUMBER CHAPTER COMMAND
;

NCHPT::	CALL	(R4)		;GET CHAPTER NUMBER
10$:	JMP	ILCM		;MUST BE A CHAPTER NUMBER
	DEC	R3		;BACK OFF NUMBER BY ONE
	CMP	#255.,R3	;LEGAL CHAPTER NUMBER?
	BLOS	10$		;IF LOS NO
	MOVB	R3,CHPTN	;SET FOR NEXT CHAPTER COMMAND
	RETURN			;
	.DSABL	LSB

;
; SUBROUTINE TO CONVERT A NUMBER TO ASCII ZERO SUPRESSED
;

CVTNM:	MOV	#10.,R1		;SET DIVISOR
	CALL	$DIV		;DIVIDE
	MOV	R1,-(SP)	;SAVE REMAINDER
	TSTEQ	R0,10$		;NO MORE DIGITS TO CONVERT?
	CALL	CVTNM		;CONVERT ANOTHER
10$:	MOV	(SP)+,R1	;RETRIEVE CHARACTER
	ADD	#'0,R1		;CONVERT TO ASCII
SDWCI:	MOV	R5,R4		;SET ADDRESS OF LINE DESCRIPTOR
	JMP	WCI		;WRITE CHARACTER IN BUFFER

	.END
