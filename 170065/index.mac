TITLE	INDEX,<INDEX COMMAND>,14,18-APR-85,DNC/CM

;
;		COPYRIGHT (c) 1974, 1985 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

;
; VERSION M01
;
; AUTHOR: L. WADE 1-JUN-72
;
; MODIFIED BY:
;
;	E. POLLACK U. OF W. 19-DEC-73
;
;	D. N. CUTLER 27-JUL-75
;
; INDEX COMMAND
;
; LOCAL DATA
;
; INDEX FLAGS
;
 
IDXCF:	.BLKW	1		;CASE DIFFERENCE FLAG
IDXRF:	.BLKW	1		;REPEATED ITEM FLAG
ICBUF:	.BLKB	52.		;INDEX ITEM BUFFER
ICBFE=.-2
 
;+
; **-INDEX-ADD INDEX ITEM TO INDEX DATA
;-

INDEX::	MOV	#ICBUF,R0	;GET ADDRESS OF INDEX ITEM BUFFER
	MOV	R0,R5		;COPY INDEX ITEM BUFFER ADDRESS
10$:	CLR	(R0)+		;CLEAR INDEX ITEM BUFFER
	CMP	R0,#ICBFE
	BLOS	10$
	MOV	#<ICBFE-ICBUF>*2,R3 ;END TEST ON BUFFER
	CLR	IDXRF		;CLEAR REPEATED ITEM FLAG
	CALL	$FRCND		;FORCE TO LOGICAL END OF COMMAND
INDX1:	CALL	GCIN		;READ CHARACTER FROM FILE
	CMPEQ	R1,#CR,INDX2	;END OF LINE?
	MOVB	R1,(R5)+	;STORE CHARACTER OF INDEX DATA
	DEC	R3		;LOOP IF ROOM
	BGT	INDX1
INDX2:	BITEQ	#1,R5,10$	;CHECK FOR BOUNDARY ALIGNMENT
	DEC	R5		;BACK UP ONE BYTE
10$:	SUB	#ICBUF-2,R5	;CALCULATE LENGTH OF ASCIZ STRING
	MOV	R5,S1		;SAVE FOR LATER USE
	MOV	XFIRST,R2	;GET ADDRESS OF FIRST ITEM SO FAR
	BEQ	INDXV		;IF NONE, LIST IS EMPTY. START IT.
INDXL2:	CLR	IDXCF		;CLEAR CASE DIFFERENCE FLAG
	MOV	4(R2),R3	;ADDRESS OF ASCIZ OF OLD ITEM
	MOV	#ICBUF,R4	;POINTER TO NEW ITEM
INDXL1:	MOVB	(R3)+,R1	;GET CHAR OF OLD
	MOVB	(R4)+,R0	;AND ONE OF NEW
	CMPEQ	R1,R0,10$	;SAME BEFORE CASE MERGE?
	MOV	SP,IDXCF	;SET CASE DIFFERENCE FLAG
10$:	CMP	R1,#141		;CONVERT LC TO UC
	BLT	20$
	BIC	#40,R1		; ..
20$:	CMP	R0,#141		; ..
	BLT	30$
	BIC	#40,R0		; ..
30$:	CMPNE	R1,R0,40$	;NOT SAME?
	TSTNE	R1,INDXL1	;END OF STRINGS?
40$:	CMPEQ	R1,R0,INDX4	;WHICH IS FIRST?
	BGT	INDX3		;NEW ONE IS FIRST, AND DIFFERENT
IDX4A:	MOV	(R2),R3		;NO. OLD ONE IS FIRST. LOOK FURTHER
	BEQ	INDX5		;END OF LIST. NEW IS LAST
	MOV	R3,R2		;MOVE LINK TO A
	BR	INDXL2		;LOOK FURTHER

;
; HEADER LAYOUT FOR INDEX ENTRY IS
;
;	.WORD FORWARD LINK
;	.WORD BACKWARD LINK
;	.WORD POINTER TO ASCIZ TEXT
;	.WORD PAGE NUMBER
;	.WORD CHAPTER/APPENDIX NUMBER
;

INDX3:	TSTNE	IDXRF,IDX4B	;REPEATED ITEM?
	CALL	INDXAD		;ADD ITEM WITH PAGE NO TO STORAGE (UNLINKED?
	MOV	2(R2),R0	;WHO PRECEDED OLD?
	BNE	10$		;ANYONE?
	MOV	R4,XFIRST	;NO. NEW IS FIRST OF ALL.
10$:	MOV	R4,2(R2)	;NEW IS PREDECESSOR OF OLD
	MOV	R2,(R4)		;OLD IS SUCCESSOR OF NEW, NO PREDECESSOR
	MOV	R0,2(R4)	;SET OLD PREDECESSOR
	BEQ	20$		;IF EQ NONE
	MOV	R4,(R0)		;MAKE NEW ONE BE HIS SUCCESSOR
20$:	RETURN			;
INDX4:	TSTNE	IDXCF,INDX3	;CASE DIFFERENCE?
	MOV	SP,IDXRF	;SET REPEATED ITEM FLAG
	BR	IDX4A		;GO LOOK FOR LAST OCCURRENCE.
IDX4B:	MOV	2(R2),R2	;AT END OF REPEAT. GET LAST ONE.
IDX4C:	CALL	INDXAP		;ADD POINTERS ONLY (WITH PAGE. NO LINK)
	MOV	4(R2),4(R4)	;NEW POINTS TO SAME TEXT AS OLD
	MOV	(R2),R0		;GET PREVIOUS SUCCESSOR OF OLD
	MOV	R4,(R2)		;MAKE NEW SUCCEED OLD
	TSTEQ	R0,10$		;NO OLD NEXT?
	MOV	R4,2(R0)
10$:	MOV	R0,(R4)+	;OLD SUCCESSOR IS SUCCESSOR OF NEW
	MOV	R2,(R4)		;OLD IS PREDECESSOR OF NEW
	RETURN			;
INDX5:	TSTNE	IDXRF,IDX4C	;REPEATED ITEM?
	CALL	INDXAD		;CREATE TEXT AND POINTER BLOCK WITH PAGENO
	MOV	R4,(R2)		;MAKE NEW FOLLOW OLD
	CLR	(R4)+		;CLEAR FORWARD LINK
	MOV	R2,(R4)		;AND OLD PRECEDE NEW.
	RETURN			;
INDXV:	CALL	INDXAD		;CREATE TEXT AND POINTER BLOCK, PAGE NO
	MOV	R4,XFIRST	;THIS IS FIRST ITEM (AND ONLY)
	CLR	(R4)+		;NO LINKS AT ALL
	CLR	(R4)
	RETURN			;
INDXAD:	CALL	INDXAX		;ALLOCATE ITEM AND BUFFER
	MOV	R4,-(SP)	;SAVE BASE OF NEW ITEM
	CLR	(R4)+		;CLEAR FORWARD LINK
	CLR	(R4)+		;CLEAR BACKWARD LINK
	MOV	#ICBUF,R0	;TRANSFER TEXT INTO BUFFER
	MOV	S1,R1		;GET COUNT OF BYTES IN INDEX ITEM
	ADD	#6,R4		;POINT TO TEXT AREA
	MOV	R4,-6(R4)	;STORE POINTER TO TEXT
10$:	MOVB	(R0)+,(R4)+	;TRANSFER INDEX ITEM
	DEC	R1		;ANY MORE BYTES TO MOVE?
	BGT	10$		;IF GT YES
	MOV	(SP)+,R4	;RESTORE BASE OF INDEX.
	RETURN			;

;
; SUBROUTINE TO ALLOCATE ONLY LINK BLOCK
;
 
	.ENABL	LSB
INDXAP:	CLR	-(SP)		;INDICATE NO ADDITIONAL STORAGE
	BR	10$		;
 
;
; SUBROUTINE TO ALLOCATE LINK BLOCK AND ASCIZ BUFFER
;
 
INDXAX:	MOV	S1,-(SP)	;INDICATE BUFFER STORAGE NEEDED
10$:	MOV	XBOT,R4		;GET STARTING ADDRESS OF STORAGE POOL
	ADD	#10.,(SP)	;ALLOCATE LINK BLOCK STORAGE
	SUB	(SP),R4		;CALCULATE NEW ENDING POOL ADDRESS
	CMP	R4,FOOTP2	;OVERLAY WITH FOOTNOTE STORAGE POOL?
	BHI	20$		;IF HI NO
	CALL	EXPAND		;EXPAND MEMORY
20$:	SUB	(SP)+,XBOT	;ALLOCATE STORAGE FROM POOL
	MOV	XBOT,R4		;GET ADDRESS OF LINK BLOCK
	MOV	PAGENO,6(R4)	;INSERT PAGE NUMBER
	CLR	10(R4)		;ASSUME NO CHAPTER/APPENDIX
	MOVB	APNDN,10(R4)	;INSERT CURRENT APPENDIX
	BNE	30$		;IF NE OKAY
	MOVB	CHPTN,10(R4)	;INSERT CHAPTER NUMBER
	BEQ	30$		;IF EQ NONE
	COMB	11(R4)		;DESIGNATE CHAPTER NUMBER
30$:	RETURN			;
	.DSABL	LSB
 
	.END
