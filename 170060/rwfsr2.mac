	$BEGIN	RWFSR2,<28.4>,<READ/WRITE FSR2>
;
; THIS  SOFTWARE  IS FURNISHED UNDER A LICENSE AND MAY
; BE USED OR COPIED ONLY IN ACCORDANCE WITH THE  TERMS
; OF SUCH LICENSE.
;
; COPYRIGHT (c) 1985, 1987 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
;
; PETER H. LIPMAN 17-AUG-73
;
; PREVIOUSLY MODIFIED BY
;
;	B. A. O'CONNELL
;
;	T. Schoeller	29-MAY-85	Create the default UIC string in the
;					FSR2 region.  TMS016 Ident 28.2.
;
;	P. K. M. WEISS	8-MAY-1987	Issue an SDIR$ for WDFDR and WDFUI,
;					Decrease module size.
;
;	B. S. MCCARTHY	7-APR-1988	Issue a new SDIR$ (SD.MOD) for WDFDR
;					and WDFUI that doesn't create a DDS
;					if one didn't exist.
;	S. RUZICH
	.PAGE
;+
; READ ROUTINES.
; THESE ROUTINES ALL READ A FIELD FROM THE FSR REGION.  
;
; INPUTS:
;	NONE
; OUTPUTS:
;	R1=DESIRED FSR FIELD
;	R2=ADDRESS OF DEFAULT DIRECTORY STRING FOR .RDFDR ONLY
;	OTHER REGISTERS PRESERVED
;
; READ DEFAULT DIRECTORY DESCRIPTOR
;-
.RDFDR::MOV	@#.FSRPT,R1
	BEQ	10$		;BRANCH IF USER FORGOT FSRSZ$
	MOV	A.DFDR+2(R1),R2 ;GET THE ADDRESS OF THE STRING
	MOV	A.DFDR(R1),R1	;AND THE LENGTH
	BGE	10$		;IF IT'S INITIALIZED, JUST RETURN
	CLR	R1		;IF NOT INITIALIZED, RETURN NONE
10$:	RETURN
;
; READ DEFAULT FILE PROTECTION
;
.RDFFP::MOV	@#.FSRPT,R1
	BEQ	10$		;BRANCH IF USER FORGOT FSRSZ$
	MOV	A.FIPR(R1),R1
10$:	RETURN
;
; READ FILE OWNER
; FORMAT = .BYTE PROGRAMMER, PROJECT
;
.RFOWN::
	MOV	@#.FSRPT,R1
	BEQ	10$		;BRANCH IF USER FORGOT FSRSZ$
	MOV	A.OWUI(R1),R1
10$:	RETURN
;
; READ DEFAULT DIRECTORY UIC 
; FORMAT = .BYTE PROGRAMMER, PROJECT
;
.RDFUI::MOV	@#.FSRPT,R1	;ADDR FSR
	BEQ	10$		;BRANCH IF USER FORGOT FSRSZ$
	MOV	A.DFUI(R1),R1	;DEFAULT DIR UIC
10$:	RETURN

;
;+
; WRITE FSR ROUTINES.  THESE ROUTINES ALL WRITE A VALUE INTO THE FSR REGION
; INPUTS:
;	R1=VALUE TO BE WRITTEN
;	R2=ADDRESS OF DEFAULT DIRECTORY STRING FOR .WDFDR ONLY
; OUTPUTS:
;	ALL REGISTERS PRESERVED
;-
	.ENABL LSB
;
; WRITE DEFAULT FILE PROTECTION
;
.WDFFP::MOV	R0,-(SP)	;SAVE R0
	MOV	@#.FSRPT,R0	;GET THE FSR POINTER
	BEQ	20$		;IF NONE, EXIT
	MOV	R1,A.FIPR(R0)	;SET DEFAULT FILE PROTECTION
	BR	20$		;EXIT
;
; WRITE FILE OWNER
;
.WFOWN::MOV	R0,-(SP)	;SAVE R0
	MOV	@#.FSRPT,R0	;GET THE FSR POINTER
	BEQ	20$		;IF NONE, EXIT
	MOV	R1,A.OWUI(R0)	;SET FILE OWNERSHIP
	BR	20$		;EXIT
;
; WRITE DEFAULT DIRECTORY
;
.WDFDR::MOV	R0,-(SP)	;SAVE R0
	MOV	@#.FSRPT,R0	;GET THE FSR POINTER
	BEQ	20$		;IF NONE, EXIT
	ADD	#A.DFDR,R0	;R0=DEFAULT DIRECTORY STRING DESCRIPTOR
	MOV	R1,(R0)		;SET DEFAULT DIRECTORY LENGTH
	MOV	R2,2(R0)	;SET DEFAULT DIRECTORY ADDRESS
	MOV	R2,-(SP)	;PUT R2 ON THE STACK TO MATCH CONDITIONS AT 30$
	BR	30$		;GO ISSUE AN SDIR IF NAMED DIRECTORIES SUPPORTED
;
; WRITE DEFAULT DIRECTORY UIC 
;

.WDFUI::MOV	R0,-(SP)	;SAVE R0
	MOV	@#.FSRPT,R0	;GET THE FSR POINTER
	BEQ	20$		;IF NONE, EXIT
	MOV	R2,-(SP)	;R2 WILL GET CHANGED
	MOV	R1,A.DFUI(R0)	;WRITE NEW DEF DIR UIC
	ADD	#A.DFDR+2,R0	; POINT TO OUTPUT AREA+2 (ADDRESS OF STRING)
	MOV	R0,R2		; COPY FOR STRING CREATION
	TST	(R2)+		; MOVE TO STRING STARTING AREA
	MOV	R2,(R0)		; SET STRING ADDRESS
	MOV	R5,-(SP)	;R5 IS DESTROYED BY BYTASC
	MOV	R1,-(SP)	;SAVE THE UIC
	MOVB	#'[,(R2)+	;PUT LEFT BRACKET IN STRING
	SWAB	R1		;TRANSLATE THE PROJECT NUMBER FIRST
	CALL	BYTASC		;TRANSLATE FIRST BYTE TO ASCII
	MOVB	#',,(R2)+	;PUT COMMA IN STRING
	MOV	(SP),R1		;R1=PROGRAMMER NUMBER
	CALL	BYTASC		;CONVERT IT TO ASCII
	MOVB	#'],(R2)+	;PUT RIGHT BRACKET IN STRING
	MOV	(SP)+,R1	;RESTORE THE UIC
	MOV	(SP)+,R5	;AND R5
	SUB	(R0),R2		; COMPUTE LENGTH OF STRING
	MOV	R2,-(R0)	; FILL IT IN STRING DESC

30$:	CLR	D.DFDV(R0)	;BOC FORCE FIND TO GET DIR ID

	.IF NE R$$NAM		;IF NAMED DIRECTORIES SUPPORTED

	MOV	R0,R2		;COPY POINTER
	ADD	#A.DPB-A.DFDR,R2 ;POINT TO DPB AREA
	MOV	R2,-(SP)	;SAVE POINTER TO THE DPB
	MOV	(PC)+,(R2)+	;DIC,DPB SIZE
	.BYTE	207.,5	
	MOV	(PC)+,(R2)+	;INSERT SUBFUNCTION AND MODIFIER
	.BYTE	3,7		;SUBFUNCTION FOR SET DIR, AND SD.MOD MOIDIFIER
	CLR	(R2)+		;RESERVED
	MOV	2(R0),(R2)+	;ADDRESS OF DIRECTORY STRING
	MOV	(R0),(R2)+	;LENGTH OF DIRECTORY STRING
	DIR$			;ISSUE THE DIRECTIVE

	.ENDC	;R$$NAM

	MOV	(SP)+,R2	;RESTORE ORIGINAL R2
20$:	MOV	(SP)+,R0
	RETURN
	.DSABL	LSB

BYTASC:	BIC	#177400,R1	;CLEAR UPPER BYTE
	.IF	GT,R$$EIS
	ASH	#2,R1		;FIRST DIGIT ONLY 2 BITS
	.IFF
	ASL	R1
	ASL	R1
	.ENDC
	MOV	#3,R5		;CONVERT 3 DIGITS
5$:	BIT	#177400,R1	;THIS DIGIT ZERO?
	BNE	10$		;BRANCH IF NO, END SUPPRESS LOOP
	.IF	GT,R$$EIS
	ASH	#3,R1
	.IFF
	ASL	R1
	ASL	R1
	ASL	R1
	.ENDC
	SOB	R5,5$		;CHECK NEXT CHARACTER
	INC	R5		;BYTE WAS 0, PUT ONE DIGIT OF 0
10$:	SWAB	R1
	ADD	#'0,R1		;CONVERT TO ASCII DIGIT
	MOVB	R1,(R2)+	;STORE THE BYTE
	CLRB	R1		;ZERO THE BYTE
	SWAB	R1		;AND SET UP FOR NEXT DIGIT
	.IF	GT,R$$EIS
	ASH	#3,R1
	.IFF
	ASL	R1
	ASL	R1
	ASL	R1
	.ENDC
	SOB	R5,10$
	RETURN

;
;
	$END	RWFSR2
;
;
	.END
