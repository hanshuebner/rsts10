	$BEGIN	WTWAIT,<29.0>,<WRITE VBN AND WAIT>
; 
; THIS  SOFTWARE  IS FURNISHED UNDER A LICENSE AND MAY
; BE USED OR COPIED ONLY IN ACCORDANCE WITH THE  TERMS
; OF SUCH LICENSE.
;  
; COPYRIGHT (c) 1985 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
; 
; PETER H. LIPMAN 16-AUG-73
;
; PREVIOUSLY MODIFIED BY
;
;	G. H. KUENNING
;	S. RUZICH
;
; UPDATE C FOR RSX-11M V4.1 AND RSX-11M PLUS V2.1
;
; MODIFICATIONS:
;
;	SMT055 -- WITH MULTI-BUFFERING ALWAYS RETURN TO THE USER WITH
;		  F.BDB POINTING TO A BUFFER THAT IS NOT IN USE.
;
	.PAGE
;+
;
; WRITE VBN AND RETURN WITH NEXT BUFFERS SET UP TO
; PUT DATA IN
; CALLING SEQUENCE:
;	CALL	..WTWA
; INPUTS:
;	R0=FDB
;	F.BDB+#S.BFHD=ADDRESS OF DATA
;	F.BBFS(R0)=NO. OF BYTES TO WRITE
;	0=CARRIAGE CONTROL
; ALTERNATE ENTRY:
;	CALL	..WTW1
; INPUTS;
;	R0=FDB
;	R1=ADDRESS OF DATA
;	R2=NO. OF BYTES TO WRITE
;	R3=CARRIAGE CONTROL BUFFER
; OUTPUTS:
;	C=0 IF OK, C=1 IF ERROR, F.ERR(R0) SET
;	R0=PRESERVED, R1-R5 ALTERED
;	F.NREC(R0),F.EOBB(R0)SET FOR NEXT PUT'S
;	F.BDB(R0)SET TO BUFFER DESCRIPTOR IN USE
;
; OPERATION:
; IF WRITE ERROR OCCURRED WITH WRITE BEHIND LOGIC
; ENABLED, THEN F.BDB WILL POINT TO THE BAD BUFFER.
; THIS WILL HAPPEN ON A SUBSEQUENT WRITE AS SOON AS THE ERROR IS NOTICED.
;-
..WTWA::CALL	..BKRG
..WTW1::
	.IF	GT,R$$BBF
	BITB	#FD.BGB,F.MBFG(R0) ;BIG BUFFERS ACTIVE?
	BEQ	30$		;BRANCH IF NO.
	BITB	#FD.BGD,F.MBFG(R0) ;DUMP THE BIG BUFFER?
	BNE	30$		;BRANCH IF YES
	MOV	F.BDB(R0),R4
	MOV	R4,R5
	ADD	#S.BFHD,R5
	ADD	B.BBFS(R4),R5	;R5=END OF BIG BUFFER
	CMP	F.EOBB(R0),R5	;IS EOBB AT END OF BIG BUFFER?
	BHIS	30$		;BRANCH IS YES, WRITE IT
	MOV	F.EOBB(R0),R4	;THIS BECOMES BEGINNING OF NEXT VBN
	MOV	R4,F.NREC(R0)	;
	ADD	F.VBSZ(R0),R4	;R4=END OF NEXT VBN				; GK003
	CMP	R4,R5		;BEYOND END OF BUFFER?
	BLOS	20$		;BRANCH IF NO
	MOV	R5,R4		;YES, USE END OF BIG BUFFER
20$:	MOV	R4,F.EOBB(R0)
	ADD	#1,F.VBN+2(R0)
	ADC	F.VBN(R0)
	BR	85$
	.ENDC
30$:	BITB	#FD.EFB,F.BKP1(R0) ;PUTTING AT EOF?				; GK003
	BEQ	35$		;BRANCH IF NO					; GK003
	BITB	#FD.REC,F.RCTL(R0) ;RECORD ORIENTED DEVICE?			; GK003
	BNE	35$		;IF NE YES, DON'T TRY TO EXTEND IT		; GK003
	CALL	..ALOC		;ALLOCATE SPACE IF NECESSARY			; GK003
	BCS	90$		;BRANCH IF FAILED TO ALLOCATE			; GK003
; WRITE THIS BLOCK, R1,R2,R3 ALL SET MUST SAVE
; FOR RETRY IF NO NODES AVAILABLE
;
35$:	MOV	R1,-(SP)							; GK003
	MOV	R2,-(SP)
	MOV	R3,-(SP)
	CALL	..WBLK		;ISSUE QIO WRITE VIRTUAL BLOCK

	.IF	GT,R$$BBF
	CALL	..RSEF		;SUPRESS EOF ERROR IF BIG BUFFERED FILE
	.ENDC			;CC= NO ERROR OR EOF SUPRESSED CS= ERROR

	BCC	40$		;BRANCH IF SUCCESSFUL
	MOV	(SP)+,R3	;FAILED TO QIO
	MOV	(SP)+,R2
	MOV	(SP)+,R4	;
	CALL	..WAND		;OUT OF NODES? -WAIT IF YES
	BCS	82$		;BRANCH IF SOME OTHER ERROR
	MOV	R4,R1
	BR	30$		;TRY QIO AGAIN
40$:	ADD	#6,SP
	BICB	#FD.WRT,F.BKP1(R0) ;RESET "DIRTY"BUFFER BIT
	.IF	GT,R$$MBF
	BITB	#FD.WBH,F.MBFG(R0) ;IS WRITE BEHIND ACTIVE?
	BNE	48$		;IF NE, YES, GOTO 48$
	.ENDC
	BITB	#FD.NAD,F.MBFG(R0) ;TEST FLAG - ADVANCE VBN?
	BNE	90$		;NE - FLUSH BUFFER TO DISK - DO NOT ADVANCE VBN
				;EQ - ADVANCE VBN
	.IF	GT,R$$BBF							; GK004
	BISB	#BD.FRE,B.BFST(R1) ;MARK THAT BUFFER IS NOW INVALID		; GK004
	.ENDC									; GK004
	.IF	GT,R$$MBF	;MULTIPLE BUFFERING
	BR	80$
48$:	
	.IF	GT,R$$BBF
	BISB	#BD.FRE,B.BFST(R1) ;MARK BUFFER AS INVALID
	.ENDC
; WITH WRITE AHEAD, SCAN ENTIRE BUFFER RING LOOKING
; FOR BUFFER WITH I/O STATUS NON ZERO. SAVE
; FIRST OF THESE IN F.BDB-IF FIND ONE WITH
; NEGATIVE STATUS (UNLESS EOF IN R$$BBF) SET THAT
; ONE UP AS F.BDB AND RETURN ERROR.
50$:	MOV	F.BDB(R0),R4
	CLR	R5
	BISB	F.MBC1(R0),R5
	CLR	R1		;INITIALIZE TO NO BUFFER AVAILABLE
55$:
	TSTB	@R4		;SCAN ENTIRE BUFFER RING
	BEQ	60$		;
	BLT	70$		;NEGATIVE MEANS WRITE ERROR
	MOV	R4,R1		;R1=BUFFER THAT IS AVAILABLE
60$:	MOV	B.NXBD(R4),R4
	SOB	R5,55$
	TST	R1		;FOUND A FREE BUFER?
	BNE	75$		;BRANCH IF YES
	CALL	..WAEF		;WAIT FOR EVENT FLAG
	BR	50$		;AND TRY AGAIN
70$:	MOV	R4,R1
	.IF	GT,R$$BBF	;IF BIG BUFFERS
	CALL	..RSEF		;IGNORE EOF ERROR				; GK003
	BCC	60$		;BRANCH IF IT WS EOF
	.ENDC
75$:	MOV	R1,F.BDB(R0)
	BITB	#FD.NAD,F.MBFG(R0) ;TEST FLAG - ADVANCE VBN?
	BNE	83$		;NE - FLUSH BUFFER TO DISK - DO NOT ADVANCE VBN
	.ENDC

80$:
; R1=F.BDB=BUFFER DESCRIPTOR ADDRESS
82$:	ADD	#1,F.VBN+2(R0)	;INCREMENT VIRTUAL BLOCK NUMBER
	ADC	F.VBN(R0)
83$:	CALL	..BDRC
85$:	MOVB	@F.BDB(R0),F.ERR(R0)

90$:	CALLR	..FCSX			;RETURN STATUS
;
;
	$END	WTWAIT
;
;
	.END
