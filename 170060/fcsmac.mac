	.TITLE	FCSMAC-FILE CONTROL SERVICES MACRO DEFINITIONS
	.IDENT	/30.8/
;
; THIS  SOFTWARE  IS FURNISHED UNDER A LICENSE AND MAY
; BE USED OR COPIED ONLY IN ACCORDANCE WITH THE  TERMS
; OF SUCH LICENSE.
;
; COPYRIGHT (c) 1985, 1987, 1990, 1991  BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
;
; PETER H LIPMAN		5-DEC-72
;
; PREVIOUSLY MODIFIED BY
;
;	ELLEN R. SIMICH
;	ANDREW C. GOLDSTEIN
;	B. LEAVITT
;	S. RUZICH
;	E. POLLACK
;	LONI BROWN
;	S. RUZICH
;
; MODIFIED:
;
;	S. M. THOMAS	30-APR-83
;
;	SMT033 - NAMED DIRECTORY SUPPORT BASED ON SIMON SZETO'S CHANGES
;
;	P. K. M. WEISS	22-AUG-84
;
;	PKW065 - LOGICAL NAME SUPPORT
;
;	PKW070 - ADD CSI4 OFFSETS
;
;	PKW086 - MAKE CSI4 OFFSETS REFERENCE FSR5
;
;	PKW121 - MAKE BUFFERS BIGGER FOR CPR				30.3
;	PKW124 - MAKE PARSE BLOCK BIGGER AND ADD FIELDS FROM AME	30.4
;	PKW128 - MOVE A.FLAG SO A.EXDS IS ALWAYS THE SAME		30.5
;	PKW132 - CONDITIONALIZE OFFSETS IN FSR5				30.6
;	PKW133 - ADD TWO WORDS TO PARSE BLOCK RETURNED			30.7
;
; MODIFIED FOR RSX-11M-PLUS V4.3 BY:
;
;	J. C. FRANZINI	 6-OCT-1989
;		JCF352 -- INCLUDE EXPLICIT RADIX CONTROL OPERATORS
;				FOR VAX-11 RSX
;
; MODIFIED FOR RSTS V10.1 BY:
;
;	S. LeVan	18-Apr-1991	V30.8
;		Merge RSTS-specific code into RSX V4.3 version of module.
;

; MCALL ALL THE FCS MACROS USED AT TOP LEVEL.

	.MACRO	FCSMC$
	.MCALL	OPEN$R,OPEN$W,OPEN$M,OPEN$U,OPEN$A,CLOSE$
	.MCALL	OPNS$R,OPNS$W,OPNS$M,OPNS$U,OPNS$A
	.MCALL	READ$,WRITE$,WAIT$,GET$,PUT$,DELET$,FINIT$
	.MCALL	FSRSZ$,FDBDF$,FDAT$A,FDRC$A,FDOP$A,FDBF$A,FDBK$A
	.MCALL	FDAT$R,FDRC$R,FDOP$R,FDBF$R,FDBK$R,NMBLK$
	.MACRO	FCSMC$
	.ENDM	FCSMC$
	.ENDM	FCSMC$

;  OPEN FILE FOR READING

	.MACRO	OPEN$R FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OPEN$
	OPEN$	FDB,#FO.RD,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OPEN$R

; OPEN FILE FOR WRITING

	.MACRO	OPEN$W FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OPEN$
	OPEN$	FDB,#FO.WRT,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OPEN$W

; OPEN FILE AS A TASK - BY FILE NAME BLOCK			;++RSTS 7.2
	.MACRO	OFNB$T FDB,LUN,FNPT,RACC,URBA,URBS,ERR 		;++RSTS 7.2
	.MCALL	OFNB$						;++RSTS 7.2
	OFNB$	FDB,#<FO.WRT!FO.TSK>,LUN,FNPT,,RACC,URBA,URBS,ERR ;++RSTS 7.2
	.ENDM	OFNB$T						;++RSTS 7.2

; OPEN FILE FOR MODIFY

	.MACRO	OPEN$M FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OPEN$
	OPEN$	FDB,#FO.MFY,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OPEN$M

; OPEN FILE FOR UPDATE

	.MACRO	OPEN$U FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OPEN$
	OPEN$	FDB,#FO.UPD,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OPEN$U

; OPEN FILE FOR APPEND

	.MACRO	OPEN$A FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OPEN$
	OPEN$	FDB,#FO.APD,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OPEN$A



;  OPEN FILE FOR READING - SHARED

	.MACRO	OPNS$R FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OPEN$
	OPEN$	FDB,#FA.SHR!FO.RD,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OPNS$R

; OPEN FILE FOR WRITING - SHARED

	.MACRO	OPNS$W FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OPEN$
	OPEN$	FDB,#FA.SHR!FO.WRT,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OPNS$W

; OPEN FILE FOR MODIFY - SHARED

	.MACRO	OPNS$M FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OPEN$
	OPEN$	FDB,#FA.SHR!FO.MFY,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OPNS$M

; OPEN FILE FOR UPDATE - SHARED

	.MACRO	OPNS$U FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OPEN$
	OPEN$	FDB,#FA.SHR!FO.UPD,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OPNS$U

; OPEN FILE FOR APPEND - SHARED

	.MACRO	OPNS$A FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OPEN$
	OPEN$	FDB,#FA.SHR!FO.APD,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OPNS$A

; OPEN A TEMP FILE AND MARK IT FOR DELETE
; CREATE, ACCESS, AND MARK FOR DELETE A NEW FILE
; NOT ENTERED IN A DIRECTORY
; WILL BE DELETED WHEN CLOSED (DEACCESSED)
; WILL EVEN BE PROPERLY DELETED IF PROGRAM SHOULD TERMINATE ABNORMALLY

	.MACRO	OPNT$D	FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OPNT$W
	OPNT$W	FDB,LUN,FNPT,RACC,URBA,URBS
	BCS	.+6
	JSR	PC,.MRKDL
	ERR$	ERR
	.ENDM	OPNT$D
;
; OPEN A TEMP FILE
; CREATE AND ACCESS A NEW FILE, DON'T ENTER IT IN A DIRECTORY
; FILE MAY BE CLOSED AND REOPENED BY FILE ID
; FILE SHOULD BE DELETED BEFORE THE PROGRAM EXITS OTHERWISE IT
; WILL REMAIN IN THE INDEX FILE WITH NO DIRECTORY ENTRY

	.MACRO	OPNT$W FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OPEN$
	OPEN$	FDB,#FA.TMP!FO.WRT,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OPNT$W

; OPEN FILE

	.MACRO	OPEN$ FDB,FACC,LUN,FNPT,DFNB,RACC,URBA,URBS,ERR
	.MCALL	FDOP$R,FDRC$R,ERR$,CMOV$B
	FDOP$R	FDB,LUN,FNPT,DFNB,FACC
	FDRC$R	,RACC,URBA,URBS
	.GLOBL	.OPEN
	JSR	PC,.OPEN
	ERR$	ERR
	.ENDM	OPEN$


; OPEN FILE FOR READING - BY FILE ID

	.MACRO	OFID$R FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OFID$
	OFID$	FDB,#FO.RD,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OFID$R

; OPEN FILE FOR WRITING - BY FILE ID

	.MACRO	OFID$W FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OFID$
	OFID$	FDB,#FO.UPD,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OFID$W

; OPEN FILE FOR MODIFY - BY FILE ID

	.MACRO	OFID$M FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OFID$
	OFID$	FDB,#FO.MFY,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OFID$M

; OPEN FILE FOR UPDATE - BY FILE ID

	.MACRO	OFID$U FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OFID$
	OFID$	FDB,#FO.UPD,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OFID$U

; OPEN FILE FOR APPEND - BY FILE ID

	.MACRO	OFID$A FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OFID$
	OFID$	FDB,#FO.APD,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OFID$A

; OPEN FILE - BY FILE ID

	.MACRO	OFID$ FDB,FACC,LUN,FNPT,DFNB,RACC,URBA,URBS,ERR
	.MCALL	FDOP$R,FDRC$R,ERR$,CMOV$B
	FDOP$R	FDB,LUN,FNPT,DFNB,FACC
	FDRC$R	,RACC,URBA,URBS
	.GLOBL	.OPFID
	JSR	PC,.OPFID
	ERR$	ERR
	.ENDM	OFID$


; OPEN FILE FOR READING - BY FILE NAME BLOCK

	.MACRO	OFNB$R FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OFNB$
	OFNB$	FDB,#FO.RD,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OFNB$R

; OPEN FILE FOR WRITING - BY FILE NAME BLOCK

	.MACRO	OFNB$W FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OFNB$
	OFNB$	FDB,#FO.WRT,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OFNB$W

; OPEN FILE FOR MODIFY - BY FILE NAME BLOCK

	.MACRO	OFNB$M FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OFNB$
	OFNB$	FDB,#FO.MFY,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OFNB$M

; OPEN FILE FOR UPDATE - BY FILE NAME BLOCK

	.MACRO	OFNB$U FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OFNB$
	OFNB$	FDB,#FO.UPD,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OFNB$U

; OPEN FILE FOR APPEND - BY FILE NAME BLOCK

	.MACRO	OFNB$A FDB,LUN,FNPT,RACC,URBA,URBS,ERR
	.MCALL	OFNB$
	OFNB$	FDB,#FO.APD,LUN,FNPT,,RACC,URBA,URBS,ERR
	.ENDM	OFNB$A

; OPEN FILE - BY FILE NAME BLOCK

	.MACRO	OFNB$ FDB,FACC,LUN,FNPT,DFNB,RACC,URBA,URBS,ERR
	.MCALL	FDOP$R,FDRC$R,ERR$,CMOV$B
	FDOP$R	FDB,LUN,FNPT,DFNB,FACC
	FDRC$R	,RACC,URBA,URBS
	.GLOBL	.OPFNB
	JSR	PC,.OPFNB
	ERR$	ERR
	.ENDM	OFNB$


; CLOSE THE FILE

	.MACRO	CLOSE$ FDB,ERR
	.MCALL	LDFDB$,ERR$
	LDFDB$	FDB
	.GLOBL	.CLOSE
	JSR	PC,.CLOSE
	ERR$	ERR
	.ENDM	CLOSE$

; READ A VIRTUAL BLOCK

	.MACRO	READ$ FDB,BKAD,BKSZ,BKVB,BKEF,BKST,BKDN,ERR
	.MCALL	FDBK$R,ERR$
	FDBK$R	FDB,BKAD,BKSZ,BKVB,BKEF,BKST,BKDN
	.GLOBL	.READ
	JSR	PC,.READ
	ERR$	ERR
	.ENDM	READ$

; WRITE VIRTUAL BLOCK

	.MACRO	WRITE$ FDB,BKAD,BKSZ,BKVB,BKEF,BKST,BKDN,ERR
	.MCALL	FDBK$R,ERR$
	FDBK$R	FDB,BKAD,BKSZ,BKVB,BKEF,BKST,BKDN
	.GLOBL	.WRITE
	JSR	PC,.WRITE
	ERR$	ERR
	.ENDM	WRITE$

; WAIT FOR I/O COMPLETION AFTER READ$ OR WRITE$

	.MACRO	WAIT$	FDB,EFN,BKST,ERR
	.MCALL	LDFDB$,CMOV$W,CMOV$B,ERR$
	LDFDB$	FDB
	CMOV$B	EFN,F.EFN
	CMOV$W	BKST,F.BKST
	.GLOBL	.WAIT
	JSR	PC,.WAIT
	ERR$	ERR
	.ENDM	WAIT$


; GET A RECORD

	.MACRO	GET$ FDB,INADR,MAXCNT,ERR
	.MCALL	LDFDB$,CMOV$W,ERR$
	LDFDB$	FDB
	CMOV$W	INADR,F.URBD+2	;USER RECORD BUFFER ADDRESS
	CMOV$W	MAXCNT,F.URBD	;USER RECORD BUFFER SIZE
	.GLOBL	.GET
	JSR	PC,.GET
	ERR$	ERR
	.ENDM	GET$

; GET A RECORD - IN RANDOM MODE

	.MACRO	GET$R FDB,INADR,MAXCNT,LRCNM,HRCNM,ERR
	.MCALL	LDFDB$,CMOV$W,ERR$
	LDFDB$	FDB
	CMOV$W	INADR,F.URBD+2	;USER RECORD BUFFER ADDRESS
	CMOV$W	MAXCNT,F.URBD	;USER RECORD BUFFER SIZE
	CMOV$W	LRCNM,F.RCNM+2	;LOW ORDER RECORD NUMBER
	CMOV$W	HRCNM,F.RCNM	;HIGH ORDER RECORD NUMBER
	.GLOBL	.GET
	JSR	PC,.GET
	ERR$	ERR
	.ENDM	GET$R

; GET A RECORD  - SEQUENTIAL MODE STRICTLY

	.MACRO	GET$S FDB,INADR,MAXCNT,ERR
	.MCALL	LDFDB$,CMOV$W,ERR$
	LDFDB$	FDB
	CMOV$W	INADR,F.URBD+2	;USER RECORD BUFFER ADDRESS
	CMOV$W	MAXCNT,F.URBD	;USER RECORD BUFFER SIZE
	.GLOBL	.GETSQ
	JSR	PC,.GETSQ
	ERR$	ERR
	.ENDM	GET$S


; PUT A RECORD - RANDOM OR SEQUENTIAL

	.MACRO	PUT$ FDB,OUTADR,OUTCNT,ERR
	.MCALL	LDFDB$,CMOV$W,ERR$
	LDFDB$	FDB
	CMOV$W	OUTADR,F.NRBD+2	;NEXT RECORD BUFFER ADDRESS
	CMOV$W	OUTCNT,F.NRBD	;NEXT RECORD BUFFER SIZE
	.GLOBL	.PUT
	JSR	PC,.PUT
	ERR$	ERR
	.ENDM	PUT$

; PUT A RECORD - RANDOM MODE

	.MACRO	PUT$R FDB,OUTADR,OUTCNT,LRCNM,HRCNM,ERR
	.MCALL	LDFDB$,CMOV$W,ERR$
	LDFDB$	FDB
	CMOV$W	OUTADR,F.NRBD+2	;NEXT RECORD BUFFER ADDRESS
	CMOV$W	OUTCNT,F.NRBD	;NEXT RECORD BUFFER SIZE
	CMOV$W	LRCNM,F.RCNM+2	;LOW ORDER RECORD NUMBER
	CMOV$W	HRCNM,F.RCNM	;HIGH ORDER RECORD NUMBER
	.GLOBL	.PUT
	JSR	PC,.PUT
	ERR$	ERR
	.ENDM	PUT$R

; PUT A RECORD - SEQUENTIAL MODE STRICTLY

	.MACRO	PUT$S FDB,OUTADR,OUTCNT,ERR
	.MCALL	LDFDB$,CMOV$W,ERR$
	LDFDB$	FDB
	CMOV$W	OUTADR,F.NRBD+2	;NEXT RECORD BUFFER ADDRESS
	CMOV$W	OUTCNT,F.NRBD	;NEXT RECORD BUFFER SIZE
	.GLOBL	.PUTSQ
	JSR	PC,.PUTSQ
	ERR$	ERR
	.ENDM	PUT$S


; DELETE A FILE

	.MACRO	DELET$	FDB,ERR
	.MCALL	LDFDB$,ERR$
	LDFDB$	FDB
	.GLOBL	.DELET
	JSR	PC,.DELET
	ERR$	ERR
	.ENDM	DELET$

; TRUNCATE A FILE

	.MACRO	TRUNC$	FDB,ERR
	.MCALL	LDFDB$,ERR$
	LDFDB$	FDB
	.GLOBL	.TRUNC
	JSR	PC,.TRUNC
	ERR$	ERR
	.ENDM	TRUNC$

; INITIALIZE THE FILE CONTROL SERVICES

	.MACRO	FINIT$
	.GLOBL	.FINIT
	JSR	PC,.FINIT
	.ENDM	FINIT$



	.MACRO	FSRSZ$ NFILES,BFSPAC,PSECT
	.MCALL	BDOFF$,DEF$L
	.IF	NDF,S.BFHD
	BDOFF$	DEF$N
	DEF$L	S.BFHD
	.ENDC
	.GLOBL	.FSRCB
	.PSECT	$$FSR1,GBL,OVR,D
	.IF	NB,<BFSPAC>
	.BLKB	NFILES*S.BFHD+<BFSPAC>
	.IFF
	.BLKB	NFILES*<S.BFHD+512.>
	.ENDC

	.PSECT	PSECT
	.ENDM	FSRSZ$

; FILE DESCRIPTOR BLOCK - ALLOCATION OF SPACE AT ASSEMBLY TIME

	.MACRO	FDBDF$
	.MCALL	FDBSZ$
	FDBSZ$
	...PC1=.
	.BLKB	S.FDB
	.ENDM	FDBDF$


; FILE ATTRIBUTE SECTION OF FDB-ASSEMBLY TIME INITIALIATION

	.MACRO	FDAT$A RTYP,RATT,RSIZ,CNTG,ALOC
	.MCALL	FDOFF$,CBYTE$,CWORD$
	FDOFF$	DEF$L
	CBYTE$	<RTYP>,F.RTYP
	CBYTE$	<RATT>,F.RATT
	CWORD$	<RSIZ>,F.RSIZ
	CWORD$	<CNTG>,F.CNTG
	CWORD$	<ALOC>,F.ALOC
	.ENDM	FDAT$A

; RECORD ACCESS SECTION OF FDB-ASSEMBLY TIME INITIALIZATION

	.MACRO	FDRC$A RACC,URBA,URBS
	.MCALL	FDOFF$,CBYTE$,CWORD$
	FDOFF$	DEF$L
	CBYTE$	<RACC>,F.RACC
	CWORD$	<URBA>,F.URBD+2
	CWORD$	<URBS>,F.URBD
	.ENDM	FDRC$A

; FILE OPEN SECTION OF FDB-ASSEMBLY TIME INITIALIZATION

	.MACRO	FDOP$A LUN,FNPT,DFNB,FACC,FACTRL
	.MCALL	FDOFF$,CBYTE$,CWORD$
	FDOFF$	DEF$L
	CBYTE$	<LUN>,F.LUN
	CWORD$	<FNPT>,F.DSPT
	CWORD$	<DFNB>,F.DFNB
	CBYTE$	<FACC>,F.FACC
	CWORD$	<FACTRL>,F.ACTL
	.ENDM	FDOP$A

; BUFFER DECRIPTOR SECTION OF FDB-ASSEMBLY TIME INITIALIZATION

	.MACRO	FDBF$A EFN,OVBS,MBCT,MBFG
	.MCALL	FDOFF$,CBYTE$,CWORD$
	FDOFF$	DEF$L
	CBYTE$	<EFN>,F.EFN
	CWORD$	<OVBS>,F.OVBS
	CBYTE$	<MBCT>,F.MBCT
	CBYTE$	<MBFG>,F.MBFG
	.ENDM	FDBF$A

; BLOCK ACCESS SECTION OF FDB ASSEMBLY TIME INITIALIZATION

	.MACRO	FDBK$A BKAD,BKSZ,BKVB,BKEF,BKST,BKDN
	.MCALL	FDOFF$,CBYTE$,CWORD$
	FDOFF$	DEF$L
	CWORD$	<BKAD>,F.BKDS+2
	CWORD$	<BKSZ>,F.BKDS
	CWORD$	<BKVB>,F.BKVB+2	;STORE LOW ORDER ONLY
	CBYTE$	<BKEF>,F.BKEF
	CWORD$	<BKST>,F.BKST
	CWORD$	<BKDN>,F.BKDN
	.ENDM	FDBK$A


; FILE ATTRIBUTE SECTION OF FDB-RUNTIME INITIALIZATION

	.MACRO	FDAT$R FDB,RTYP,RATT,RSIZ,CNTG,ALOC
	.MCALL	LDFDB$,CMOV$W,CMOV$B

	LDFDB$	FDB		;SAVE R0 AND LOAD FDB
	CMOV$B	RTYP,F.RTYP
	CMOV$B	RATT,F.RATT
	CMOV$W	RSIZ,F.RSIZ
	CMOV$W	CNTG,F.CNTG
	CMOV$W	ALOC,F.ALOC
	.ENDM	FDAT$R

; RECORD ACCESS SECTION OF FDB-RUNTIME INITIALIZATION

	.MACRO	FDRC$R FDB,RACC,URBA,URBS
	.MCALL	LDFDB$,CMOV$W,CMOV$B
	LDFDB$	FDB
	CMOV$B	RACC,F.RACC
	CMOV$W	URBA,F.URBD+2
	CMOV$W	URBS,F.URBD
	.ENDM	FDRC$R

; FILE OPEN SECTION OF FDB-RUNTIME INITIALIZATION

	.MACRO	FDOP$R FDB,LUN,FNPT,DFNB,FACC,FACTRL
	.MCALL	LDFDB$,CMOV$W,CMOV$B
	LDFDB$	FDB
	CMOV$B	LUN,F.LUN
	CMOV$W	FNPT,F.DSPT
	CMOV$W	DFNB,F.DFNB
	CMOV$B	FACC,F.FACC
	CMOV$W	FACTRL,F.ACTL
	.ENDM	FDOP$R

; BLOCK BUFFER SECTION OF FDB-RUNTIME INITIALIZATION.

	.MACRO	FDBF$R FDB,EFN,OVBS,MBCT,MBFG
	.MCALL	LDFDB$,CMOV$W,CMOV$B
	LDFDB$	FDB
	CMOV$B	EFN,F.EFN	;EVENT FLAG TO USE
	CMOV$W	OVBS,F.OVBS	;SIZE OF BLOCK BUFFER
	CMOV$B	MBCT,F.MBCT	;NO. OF BUFFERS
	CMOV$B	MBFG,F.MBFG	;READ AHEAD OR WRITE BEHIND
	.ENDM	FDBF$R

; BLOCK ACCESS SECTION OF FDB-RUNTIME INITIALIZATION

	.MACRO	FDBK$R FDB,BKAD,BKSZ,BKVB,BKEF,BKST,BKDN
	.MCALL	LDFDB$,CMOV$B,CMOV$W,CMOV$2
	LDFDB$	FDB
	CMOV$W	BKAD,F.BKDS+2	;BLOCK ADDRESS-MEMORY BUFFER
	CMOV$W	BKSZ,F.BKDS	;SIZE OF TRANSFER IN BYTES
	CMOV$2	BKVB,F.BKVB	;ADDRESS OF 2 WORD VIRTUAL
				;BLOCK NUMBER, MOVE BOTH WORDS
	CMOV$B	BKEF,F.BKEF	;EVENT FLAG
	CMOV$W	BKST,F.BKST	;ADR OF I/O STATUS BLOCK
	CMOV$W	BKDN,F.BKDN	;ADR OF I/O DONE AST
	.ENDM	FDBK$R


; DEFINE THE SIZE OF THE FDB AS A LOCAL SYMBOL (S.FDB)

	.MACRO	FDBSZ$		;DEFINE S.FDB AS SIZE OF FDB
	.IIF	DF,S.FDB,.MEXIT
	.MCALL	FDOFF$,DEF$L
	FDOFF$	DEF$N		;INVOKE OFFSET DEFINITIONS BUT DON'T
				;ACTUALLY DEFINE THE OFFSET NAMES
	DEF$L	S.FDB		;NOW DEFINE S.FDB
	.ENDM	FDBSZ$

; INVOKE FDOFF$ TO DEFINE OFFSETS AS LOCAL - DO IT ONCE ONLY

	.MACRO	FDOF$L
	.MCALL	FDOFF$
	FDOFF$	DEF$L
	.ENDM	FDOF$L

; DEFINE FILE NAME BLOCK AT ASSEMBLY TIME

	.MACRO	NMBLK$	FNAME,FTYPE,VERS,DEVNAM,UNIT
	.MCALL	RAD50$,CWORD$,NBOFF$
	NBOFF$	DEF$L		;DEFINE NAME BLOCK OFFSETS LOCALLY
	.IIF	NDF,...PC1,...PC1=0
	...PC3=...PC1		;PRESERVE ...PC1
	...PC1=.
	.=...PC1+N.FNAM
	RAD50$	<FNAME>,S.FNAM/2
	.=...PC1+N.FTYP
	RAD50$	<FTYPE>,S.FTYP/2
	CWORD$	<VERS>,N.FVER
	.IF	NB,DEVNAM
	.=...PC1+N.DVNM
	.WORD	"DEVNAM
	.ENDC
	CWORD$	<UNIT>,N.UNIT
	.=...PC1+S.FNB
	...PC1=...PC3		;RESTORE ...PC1
	.ENDM	NMBLK$

; INVOKE NBOFF$ TO DEFINE OFFSETS AS LOCAL - DO IT ONCE ONLY

	.MACRO	NBOF$L
	.MCALL	NBOFF$
	NBOFF$	DEF$L
	.ENDM	NBOF$L


; IF THE FDB PARAM IS NULL OR R0, THEN DON'T
; GENERATE A MOVE OF FDB TO R0.  OTHERWISE
; GENERATE THE MOVE

	.MACRO	LDFDB$ FDB
	.IIF	B,FDB,.MEXIT	;IF NULL THEN EXIT
	.NTYPE	PAR$$$,FDB
	.IIF	EQ,PAR$$$,.MEXIT ;IF R0 THEN EXIT
	MOV	FDB,R0		;ELSE GENERATE THE MOVE
	.ENDM	LDFDB$


; CONDITIONALLY MOVE A WORD TO THE SPECIFIED OFFSET OF R0

	.MACRO	CMOV$W VAR,OFFSET
	.IF	IDN,<#0>,<VAR>
	CLR	OFFSET(R0)
	.MEXIT
	.ENDC
	.IIF	NB,VAR,	MOV	VAR,OFFSET(R0)
	.ENDM	CMOV$W

; CONDITIONALLY GENERATE A MOVE BYTE TO THE SPECIFIED OFFSET OF R0

	.MACRO	CMOV$B VAR,OFFSET
	.IF	IDN,<#0>,<VAR>
	CLRB	OFFSET(R0)
	.MEXIT
	.ENDC
	.IIF	NB,VAR,	MOVB VAR,OFFSET(R0)
	.ENDM	CMOV$B

; CONDITIONALLY MOVE 2 WORDS FROM VAR TO THE SPECIFIED OFFSET OF R0

	.MACRO	CMOV$2 VAR,OFFSET
	.IIF	B,VAR,.MEXIT
	MOV	VAR,-(SP)	;ADDRESS OF 2 WORDS TO STATE
	MOV	@(SP),OFFSET(R0) ;FIRST WORD TO FDB
	ADD	#2,(SP)		;CALCULATE ADR OF 2ND WORD
	MOV	@(SP)+,OFFSET+2(R0) ;2ND WORD TO FDB
	.ENDM	CMOV$2

; CONDITIONALLY ASSEMBLE .BYTE DIRECTIVE FOR VAR
; AT THE SPECIFIED OFFSET FROM THE BEGINNING OF THE FDB

	.MACRO	CBYTE$ VAR,OFFSET
	.IF	NB,VAR		;IF NON NULL
	...PC2=.		;SAVE PC
	.=...PC1+OFFSET		;SET PC TO SPECIFIED OFFSET
	.BYTE	VAR		;ASSEMBLE THE BYTE
	.=...PC2		;RESTORE PC
	.ENDC
	.ENDM	CBYTE$

; CONDITIONALLY ASSEMBLE WORD DIRECTIVE FOR VAR
; AT THE SPECIFIED OFFSET FROM THE BEGINNING OF THE FDB

	.MACRO	CWORD$ VAR,OFFSET
	.IF NB,VAR		;IF VAR IS NOT NULL
	...PC2=.		;SAVE THE PC
	.=...PC1+OFFSET		;SET THE PC TO THE SPECIFIED OFFSET
	.WORD	VAR		;ASSEMBLE THE WORD
	.=...PC2		;RESTORE THE PC
	.ENDC
	.ENDM	CWORD$

; MACRO TO INSERT AN ASCII STRING AT SPECIFIED OFFSET

	.MACRO CSTRG$ VAR,OFFSET,MAXLG,FILL=0
	.IF NB,<VAR>		; IF THE STRING TO INSERT IS NON NULL
	 .NCHR ...PC3,<VAR>	; PICK UP STRING LENGTH
	 .IF GE MAXLG-...PC3	; VERIFY IT IS NOT TOO LONG
	  ...PC2=.		; SAVE CURRENT PC
	  .=...PC1+OFFSET	; ADDRESS DESIRED OFFSET
	  .ASCII ^VAR^		; INSERT VALUE AT OFFSET
	  .REPT MAXLG-...PC3	; PAD TO MAXIMUM LENGTH
	  .BYTE FILL
	  .ENDR
	  .=...PC2		; RETURN TO PREVIOUS PC
	 .IFF
	  .ERROR 		; ARGUMENT TOO LONG
	 .ENDC
	.ENDC
	.ENDM	CSTRG$

; MACROS TO ACCESS FIELDS IN THE STRUCTURE CURRENTLY POINTED TO BY R0.

	.MACRO	CGET$B	OFFSET,VAR
	.IIF NB <VAR>	MOVB	OFFSET(R0),VAR
	.ENDM

	.MACRO	CGET$W	OFFSET,VAR
	.IIF NB <VAR>	MOV	OFFSET(R0),VAR
	.ENDM



; DEFINE FCS BITS AND VALUES LOCALLY OR GLOBALLY
; CALL WITH DEF$G FOR GLOBAL DEFINITIONS, CONVENTIONALLY
; CALLED WITH DEF$L FOR LOCAL, BUT ANYTHING NOT EQUAL TO DEF$G
; WILL DO

; ** NOTE WELL **
;
;	YOU MUST INCLUDE EXPLICIT RADIX CONTROL OPERATORS (^O) BEFORE
;	ALL NONDECIMAL NUMBERS.  THIS MACRO IS USED BY VAX-11 RSX AND
;	MUST ASSEMBLE CORRECTLY UNDER VAX MACRO WHICH ASSUMES ALL
;	NUMBERS ARE DECIMAL.

	.MACRO	FCSBT$	GLOBL
	.MCALL	DEFIN$
	...GBL=0
	.IIF	IDN,<GLOBL>,<DEF$G>,...GBL=1

; F.RATT BITS - RECORD ATTRIBUTE BYTE

	DEFIN$	FD.FTN,<^O1>	;FORTRAN CARRIAGE CONTROL BIT
	DEFIN$	FD.CR, <^O2>	;INSERT CARRIAGE RETURNS BETWEEN RECORDS
	DEFIN$	FD.PRN,<^O4>	; R.SEQ/VFC PRINT FILE
	DEFIN$	FD.BLK,<^O10>	;1 IF RECORDS CANNOT CROSS BLOCK BOUNDAR

; F.RACC BITS - RECORD ACCESS BYTE

	DEFIN$	FD.RWM,<^O1>	;ON IF READ/WRITE,OFF IF GET/PUT
	DEFIN$	FD.RAN,<^O2>	;ON IF RANDOM,OFF IF SEQUENTIAL
	DEFIN$	FD.PLC,<^O4>	;ON IF PARTIAL LOCATE,OFF IF SEQUENTIAL
	DEFIN$	FD.INS,<^O10>	;ON IF PUT SEQUENTIAL INSERT MODE
				;OFF IF TRUNCATE MODE

; F.RCTL BITS - RECORD CONTROL BYTE - DEVICE CHARACTERISTICS

	DEFIN$	FD.REC,<^O1>	;ON IF RECORD ORIENTED DEV, OFF IF BLK O
	DEFIN$	FD.CCL,<^O2>	;ON IF CARRIAGE CONTROL OUTPUT DEVICE
				;OFF IF NOT
	DEFIN$	FD.TTY,<^O4>	;ON IF THIS DEVICE IS A TTY
	DEFIN$	FD.DIR,<^O10>	;ON IF DIRECTORY DEVICE, OFF IF NOT
	DEFIN$	FD.SDI,<^O20>	;ON IF SINGLE DIRECTORY DEVICE
	DEFIN$	FD.SQD,<^O40>	;ON IF SEQUENTIAL DEVICE
	DEFIN$	FD.ISP,<^O2000>	;INPUT SPOOLING
	DEFIN$	FD.OSP,<^O4000>	;OUTPUT SPOOLING
	DEFIN$	FD.PSE,<^O10000>
	DEFIN$	FD.COM,<^O20000>
	DEFIN$	FD.F11,<^O40000>
	DEFIN$	FD.MNT,<^O100000>

; N.STAT BITS - FILE NAME BLOCK STATUS WORD - SET BY PARSE

	DEFIN$	NB.VER,<^O1>	;SET IF FILE VERSION WAS EXPLICIT
	DEFIN$	NB.TYP,<^O2>	;SET IF FILE TYPE WAS EXPLICIT
	DEFIN$	NB.NAM,<^O4>	;SET IF FILE NAME WAS EXPLICIT
	DEFIN$	NB.SVR,<^O10>	;SET IF * IN VERSION FIELD
	DEFIN$	NB.STP,<^O20>	;SET IF * IN TYPE FIELD
	DEFIN$	NB.SNM,<^O40>	;SET IF * IN NAME FILED
	DEFIN$	NB.DIR,<^O100>	;SET IF EXPLICIT DIRECTORY SPECIFIED
	DEFIN$	NB.DEV,<^O200>	;SET IF DEVICE NAME WAS EXPLICIT
	DEFIN$	NB.SD1,<^O400>	;SET IF * IN PROJECT NUMBER OF PPN
	DEFIN$	NB.SD2,<^O1000>	;SET IF * IN PROGRAMMER NUMBER OF PPN
	DEFIN$	NB.ANS,<^O2000>	;SET IF QUOTED NAME FOUND
	DEFIN$	NB.WCH,<^O4000>	;WILD CHARACTER PROCESSING REQUIRED
	DEFIN$	NB.WLV,<^O10000>;WILDCARD VERSION NUMBER.  USED BY PIP AND
				;THE AME.
	DEFIN$	NB.SUP,<^O20000>;CAN SUPERSEDE ON COMBINDED CREATE/ENTER
				;OPERATION.  THIS IS USED ONLY BY FCS UNDER
				;THE AME, AND THE AME ITSELF.

; ***** BEWARE MORE BITS IN N.STAT USED BY FCS AND PIP LOCALLY
; CHECK DEFINITION SECTION IN FCSPRE

; F.RTYP VALUES - RECORD TYPE BYTE - ***** NOTE THESE ARE VALUES, NOT BITS

	DEFIN$	R.FIX,<^O1>	;FIXED LENGTH RECORDS
	DEFIN$	R.VAR,<^O2>	;VARIABLE LENGTH RECORDS
	DEFIN$	R.SEQ,<^O3>	;SEQUENCED RECORDS
	DEFIN$	R.STM,<^O4>	;STREAM ASCII RECORDS

; F.FACC BITS - FILE ACCESS BYTE

	DEFIN$	FA.RD, <^O1>	;SET IF READ ONLY
	DEFIN$	FA.WRT,<^O2>	;SET IF ACCESSED FOR WRITE
	DEFIN$	FA.EXT,<^O4>	;SET IF ACCESS FOR EXTEND
	DEFIN$	FA.CRE,<^O10>	;SET IF CREATING NEW FILE
	DEFIN$	FA.TMP,<^O20>	;SET IF CREATING TEMP FILE
	DEFIN$	FA.SHR,<^O40>	;SET IF SHARED ACCESS
;
; THE FOLLOWING TWO NAMES APPLY TO THE SAME CONTROL BIT IN F.FACC
; FA.APD IS ONLY USED IF THE FILE IS AN EXISTING FILE (FA.CRE=0)
; FA.NSP IS ONLY USED IF THE FILE IS BEING CREATED (FA.CRE=1)
;
; BIT VALUE 200 IN F.FACC IS RESERVED FOR USE BY RSTS/E, FOR THEIR FO.TS
; TASK IMAGE FILE ACCESS.
;
	DEFIN$	FA.APD,<^O100>	;SET IF APPENDING (POSIT TO EOF)
	DEFIN$	FA.NSP,<^O100>	;SET IF INHIBITING SUPERSEDE ON FILE CRE

	DEFIN$	FO.RD,FA.RD			;OPEN FOR READ
	DEFIN$	FO.WRT,FA.WRT!FA.EXT!FA.CRE	;OPEN FOR WRITE (CREATE)
	DEFIN$	FO.APD,FA.WRT!FA.EXT!FA.APD	;OPEN FOR APPEND
	DEFIN$	FO.MFY,FA.WRT			;OPEN FOR MODIFY
	DEFIN$	FO.UPD,FA.WRT!FA.EXT		;OPEN FOR UPDATE
	DEFIN$	FO.TSK,200	;++RSTS V7.2 CREATE A TASK IMAGE
;
; DEFINE THE NEW BITS IN F.ACTL IN THE FDB
; SEVERAL OF THESE BITS ALSO HAVE LOCAL
; DEFINITIONS IN FCSPRE.MAC. HOWEVER ALL
; DEFINITONS ARE MUTUALLY EXCLUSIVE.
;
	DEFIN$	FA.ENB,<^O100000>;ENABLE USE OF F.ACTL WORD
	DEFIN$	FA.SEQ,<^O40000>;ENABLE SEQUENTIAL PROCESSING ONLY (NON-
	DEFIN$	FA.WCK,<^O20000>;ENABLE WRITE CHECK
	DEFIN$	FA.POS,<^O10000>;FILE CREATION POS. CTRL FOR MAGTAPE
	DEFIN$	FA.RWD,<^O4000>	;ENABLE REWIND CONTROL FOR MAGTAPE
	DEFIN$	FA.EXL,<^O4000>	;ENABLE MANUAL BLOCK LOCKING
	DEFIN$	FA.LKL,<^O2000>	;ENABLE BLOCK BLOCKING
	DEFIN$	FA.EXC,<^O2000>	;EXCLUSIVE USE BIT
	DEFIN$	FA.DLK,<^O1000>	;ENABLE NO LOCK ON ABNORMAL CLOSE
	DEFIN$	CH.AND,<^O1>	;ANSI FORMAT MAG TAPE: 'D' (VARIABLE LEN
				; OR 'F' (FIXED LENGTH, INCLUDING BLOCK I

; F.MBFG BITS - MULTIPLE BUFFERING FLAG WORD - USER CONTROLLED AND SET B

	DEFIN$	FD.RAH,<^O1>	;READ AHEAD IF SET - THIS OR WRITE BEHIN
	DEFIN$	FD.WBH,<^O2>	;WRITE BEHIND IF SET - NOT BOTH

; ***** BEWARE MORE BITS IN F.MBFG USED IN FCS LOCALLY

; F.FLG BITS - GENERAL PURPOSE FLAGS

	DEFIN$	FL.AEX,<^O1>	;STRING TO BE PARSED HAS ALREADY BEEN EXPANDED 
				; FOR LOGICAL NAMES
	DEFIN$	FL.VCP,<^O2>	;THIS FILE IS PARSED USING THE VMS ACP

; DEFINE THE .CTRL FUNCTION CODES

	DEFIN$	FF.RWD,<^O1>	;REWIND
	DEFIN$	FF.POE,<^O2>	;POSITION TO END OF VOLUME (SET)
	DEFIN$	FF.NV, <^O3>	;NEXT VOLUME
	DEFIN$	FF.SPC,<^O4>	;SPACE
	DEFIN$	FF.CHR,<^O5>	;GET APC CHARACTERISTICS
	DEFIN$	FF.RWF,<^O6>	;ERS REWIND FILE

; DEFINE BITS USED IN .FCTYP TO DESCRIBE FCS CONDITIONAL ASSEMBLY OPTION

	DEFIN$	FT.ANI,<^O1>	;ANSI MAG TAPE FCS (CONDITIONAL R$$ANI
	DEFIN$	FT.BBF,<^O2>	;BIG BUFFERED FCS (R$$BBF > 1)
	DEFIN$	FT.MBF,<^O4>	;MULTI BUFFERED FCS (R$$MBF > 1)


	.MACRO	FCSBT$	ARG
	.ENDM	FCSBT$
	.ENDM	FCSBT$




; EQUATE THE SYMBOL WITH ITS SPECIFIED VALUE
; DEFINE IT GLOBALLY IF ...GBL=1, OTHERWISE LOCALLY

; NOTE:  VAX-11 RSX HAS ITS OWN COPY OF THE DEFIN$ MACRO IN RSXSYMBOL.MAR.
; IT CAN'T USE THIS VERSION OF THE MACRO BECAUSE MANY OF THE VALUES PASSED
; TO IT HAVE A TRAILING DECIMAL POINT TO INDICATE DECIMAL RADIX AND VAX
; MACRO CAN'T HANDLE ^O<NUMBER.>.  SO THE VAX-11 RSX VERSION LEAVES OFF
; THE ^O OPERATOR.

	.MACRO	DEFIN$	SYM,VAL
	.IIF	EQ,...GBL-1,.GLOBL SYM
	SYM=^O<VAL>
	.ENDM	DEFIN$


; FILE DESCRIPTOR BLOCK OFFSETS DEFINITION MACRO
; CALL WITH ONE OF THE FOLLOWING MACRO NAMES DEF$L,DEF$G,DEF$N
; TO DEFINE LOCAL OFFSETS, DEFINE TOTAL OFFSETS,
; OR DEFINE NO OFFSETS.  THE LATTER SETS THINGS UP
; SO THAT ONLY THE SIZE OF THE FDB CAN BE
; DEFINED

	.MACRO	FDOFF$ OFFSET
	.MCALL	OFFSET,DEF$I,NBOFF$
	NBOFF$	OFFSET
	DEF$I	0		;INIT THE DEFINITION MACRO

; FILE ATTRIBUTE SECTION

	; F.RTYP IS ASSUMED TO BE AT OFFSET ZERO BY SEVERAL MODULES.  DO NOT
	; CHANGE IT

	OFFSET	F.RTYP,1	;RECORD TYPE
	OFFSET	F.RATT,1	;RECORD ATTRIBUTES
	OFFSET	F.RSIZ,2	;RECORD SIZE
	OFFSET	F.HIBK,4	;HIGHEST VIRTUAL BLOCK NO. ALLOCATED
	OFFSET	F.EFBK,4	;END OF FILE BLOCK NUMBER
	OFFSET	F.FFBY,2	;FIRST FREE BYTE IN LAST BLOCK
	OFFSET	S.FATT		;SIZE OF FILE ATTRIBUTE SECTION

; RECORD ACCESS SECTION

	OFFSET	F.RACC,1	;RECORD ACCESS
	OFFSET	F.RCTL,1	;RECORD CONTROL
	OFFSET	F.BKDS		;BLOCK I/O - BUFFER DESCRIPTOR
	OFFSET	F.URBD,4	;USER'S RECORD BUFFER DESCRIPTOR
	OFFSET	F.BKST		;BLOCK I/O - I/O STATUS BLOCK ADDRESS
	OFFSET	F.NRBD,2	;NEXT RECORD BUFFER DESCRIPTOR
	OFFSET	F.BKDN		;BLOCK I/O - I/O DONE AST ADDRESS
	OFFSET	,2		;2ND WORD OF NRBD
	OFFSET	F.OVBS		;OVERRIDE BLOCK BUFFER SIZE
	OFFSET	F.NREC,2	;NEXT RECORD ADDRESS IN BLOCK BUFFER
	OFFSET	F.EOBB,2	;END OF BLOCK BUFFER
	OFFSET	F.CNTG		;SIZE IN BLOCKS OF CONTIGUOUS FILE
	OFFSET	F.RCNM,2	;RECORD NUMBER FOR RANDOM RECORDS
	OFFSET	F.STBK		;ADDRESS TO READ IN STATISTICS BLOCK
	OFFSET	,2		;2ND WORD OF RCNM
	OFFSET	F.ALOC,2	;ALLOCATE THIS MUCH SPACE WHEN NEED
				;TO EXTEND, + = CONTIG, - = NOT

; FILE OPEN SECTION

	OFFSET	F.LUN,1		;LOGICAL UNIT NUMBER
	OFFSET	F.FACC,1	;FILE ACCESS
	OFFSET	F.DSPT,2	;FILE DESCRIPTOR POINTER
	OFFSET	F.DFNB,2	;DEFAULT FILE NAME BLOCK ADDRESS

; BLOCK BUFFER SECTION

	OFFSET	F.BKEF		;BLOCK I/O - EVENT FLAG NUMBER
	OFFSET	F.EFN,1		;EVENT FLAG USED IN QIO
	OFFSET	F.BKP1,1	;BOOKKEEPING BITS
	OFFSET	F.ERR,2		;1ST BYTE ERROR RETURN CODE
				;2ND BYTE FOR QI/O ERROR INDICATOR
	OFFSET	F.MBCT,1	;NUMBER OF BUFFERS TO USE (DESIRED)
	OFFSET	F.MBC1,1	;NO. OF BUFFERS IN USE
	OFFSET	F.MBFG,1	;MULTIPLE BUFFERING CONTROL FLAGS
	OFFSET	F.BGBC,1	;BIG BUFFER BLOCK COUNT (SIZE IN BLOCKS)
				;ALSO USED FOR ANSI TAPE INPUT BUFFER OF
	OFFSET	F.VBSZ,2	;VIRTUAL BLOCK SIZE IN BYTES
	OFFSET	F.BBFS,2	;BLOCK BUFFER SIZE
	OFFSET	F.BKVB		;BLOCK I/O - VIRTUAL BLOCK NUMBER
	OFFSET	F.VBN,4		;VIRTUAL BLOCK NUMBER
	OFFSET	F.BDB,2		;BLOCK BUFFER DESCRIPTOR BLOCK
	OFFSET	F.EXT		;FDB EXTENSION
	OFFSET	F.SPDV,2	;SPOOL DEVICE INDICATOR
	OFFSET	F.FLG		;FDB FLAG BYTE
	OFFSET	F.SPUN,1	;SPOOL UNIT DESIGNATOR
	OFFSET	F.CHR,1		;ACP VOLUME CHARACTERISTICS SUMMARY BYTE
	OFFSET	F.ACTL,2	;ACCESS CONTROL WORD
	OFFSET	F.SEQN,2	;SEQUENCE NUMBER FOR SEQUENCED FILES

; FILE NAME BLOCK SECTION

	OFFSET	F.FNB,S.FNB	;BEGINNING OF FILE NAME BLOCK
	.IIF	IDN,<OFFSET>,<DEF$N>,.MEXIT
	.IF	IDN,<OFFSET>,<DEF$G>
	.GLOBL	F.FNAM,F.FTYP,F.FVER,F.DVNM,F.UNIT
	.ENDC
	F.FNAM=N.FNAM+F.FNB
	F.FTYP=N.FTYP+F.FNB
	F.FVER=N.FVER+F.FNB
	F.DVNM=N.DVNM+F.FNB
	F.UNIT=N.UNIT+F.FNB
	OFFSET	S.FDB		;SIZE OF FDB

; DEFINE OFFSETS IN THE FDB EXTENSION

	DEF$I	0		;REINITIALIZE THE OFFSET DEFINITIONS
	OFFSET	FX.LEN,2	;LENGTH OF EXTENSION 
	OFFSET	FX.DMX,1	;MAXIMUM SIZE OF DIRECTORY STRING
	OFFSET	FX.DLN,1	;LENGTH OF DIRECTORY STRING
	OFFSET	FX.DIR,2	;DIRECTORY STRING
	.MACRO	FDOFF$	ARG
	.ENDM	FDOFF$
	.ENDM	FDOFF$


; BUFFER DESCRIPTOR OFFSETS-SAME TYPE OF CALL AS FOR FILE DESCRIPTOR OFF

	.MACRO	BDOFF$ OFFSET
	.MCALL	OFFSET,DEF$I
	DEF$I	0
	OFFSET	,4
	OFFSET	B.VBN,4		;VIRTUAL BLOCK NUMBER FOR THIS BUFFER
	OFFSET	B.BBFS,2	;NUMBER OF BYTES READ OR WRITTEN
	OFFSET	B.NXBD,2	;POINTER TO NEXT BUFFER DESCRIPTOR
	OFFSET	,1		;SPARE BYTE
	OFFSET	B.BFST,1	;BUFFER STATUS BYTE
	OFFSET	,2
	OFFSET	S.BFHD
	.IIF	IDN,<DEF$N>,<OFFSET>,.MEXIT
	.MACRO	BDOFF$	ARG
	.ENDM	BDOFF$
	.ENDM	BDOFF$

; NAME BLOCK OFFSET - LIKE FDOFF

; ** NOTE WELL **
;
;	YOU MUST INCLUDE EXPLICIT RADIX CONTROL OPERATORS (^O) BEFORE
;	ALL NONDECIMAL NUMBERS.  THIS MACRO IS USED BY VAX-11 RSX AND
;	MUST ASSEMBLE CORRECTLY UNDER VAX MACRO WHICH ASSUMES ALL
;	NUMBERS ARE DECIMAL.
;
;	IN ADDITION, ALL SIZE PARAMETERS TO THE "OFFSET" MACRO THAT ARE
;	DECIMAL NUMBERS MUST SPECIFY THE ^D RADIX CONTROL OPERATOR
;	INSTEAD OF USING A TRAILING DECIMAL POINT.  THIS IS BECAUSE
;	THE DEF$L MACRO WHICH CAN BE PASSED AS "OFFSET" INCLUDES THE
;	CODE ^O<SIZE>.  VAX MACRO CAN HANDLE ^O<^D10> CORRECTLY, BUT IT
;	CANNOT HANDLE ^O<10.>.

	.MACRO	NBOFF$	OFFSET
	.MCALL	OFFSET,DEF$I,DEF$L
	DEF$I	0
	OFFSET	S.FNAM		;DEFINE AS GLOBAL IF PARAMETER
	OFFSET	S.FTYP		;IS DEF$G
	OFFSET	S.FNTY
	OFFSET	S.FNBW
	OFFSET	S.ANM1
	OFFSET	S.ANM2
	S.FNAM=6		;SIZE OF FILENAME IN BYTES
	S.FTYP=2		;SIZE OF FILE TYPE IN BYTES
	S.ANM1=12.		;SIZE OF ANSI NAME FIELD 1
	S.ANM2=5.		;SIZE OF ANSI NAME FIELD 2
	S.FNTY=<S.FNAM+S.FTYP>/2  ;SIZE OF FILENAME + TYPE IN WORDS
	OFFSET	N.FID,2		;FILE ID (REALLY 6 BYTES, FOR DISK)
	OFFSET	N.ANM1,4	;ANM1 OVERLAYS FID WORDS 2 AND 3, FNAM,
	OFFSET	N.FNAM,S.FNAM	;FILENAME
	OFFSET	N.FTYP,S.FTYP	;TYPE
	OFFSET	N.FVER,2	;VERSION
	OFFSET	S.NFEN		;SIZE OF NAME FILE ENTRY IN BYTES
	DEF$L	S.NFEN		;FORCE AT LEAST A LOCAL DEFINITION
	OFFSET	N.STAT,2	;STATUS
	OFFSET	N.NEXT,2	;TEMP CELL FOR FIND NEXT
	OFFSET	N.ANM2		;ANSI NAME 2 OVERLAYS DID
	OFFSET	N.DID,6		;DIRECTORY ID
	OFFSET	N.DVNM,2	;DEVICE NAME IN ASCII
	OFFSET	N.UNIT,2	;UNIT NUMBER
	OFFSET	S.FNB		;SIZE OF FNB IN BYTES
	DEF$L	S.FNB		;FORCE LOCAL DEFINITION AT LEAST
	S.FNBW=S.FNB/2		;SIZE OF FNB IN WORDS
	.IIF	IDN,<DEF$N>,<OFFSET>,.MEXIT ;DON'T REDEFINE THE MACRO
	.MACRO	NBOFF$	ARG
	.ENDM	NBOFF$
	.ENDM	NBOFF$


; FILE STORAGE REGION OFFSETS - LIKE FDOFF

	.MACRO	FSROF$	OFFSET
	.MCALL	OFFSET,DEF$I,DEF$L,DEFIN$
	...GBL=0
	.IIF	IDN,<OFFSET>,<DEF$G>,...GBL=1

; DEFINE THE OFFSETS FOR $$FSR2

	DEF$I	0

	OFFSET	,4		;LIST HEAD FOR ALLOCATION
	OFFSET	A.BFSR,2	;FIRST ADDRESS IN FSR1
	OFFSET	A.EFSR,2	;LAST ADDRESS IN FSR1
;
; ***** DO NOT SEPARATE THE FOLLOWING 2 DEFINITIONS
;
	OFFSET	A.OWUI,2	;UIC OF OWNER (FROM TASK HEADER)
	OFFSET	A.FIPR,2	;DEFAULT FILE PROTECTION WORD
;
; DO NOT SEPARATE THE PRECEEDING 2 DEFINITIONS
;

;
; ***** DO NOT SEPARATE THE FOLLOWING 3 DEFINTIONS
;
	OFFSET	A.DPB,24.	;QI/O DPB AND SCRATCH AREA
	OFFSET	A.IOST,4	;SCRATCH I/O STATUS BLOCK
	OFFSET	A.DFDR,26.	;DEFAULT DIRECTORY INFORMATION
;
; DO NOT SEPARATE THE PRECEEDING 3 DEFINITIONS
;
	OFFSET	A.DFBC,2	;DEFAULT BUFFER CNT (MULTIPLE BUFFERING)
	OFFSET	A.DFUI,2	;DEFAULT UIC (TASK UIC)
;
; ***WARNING*** NO SPACE MAY BE ADDED OR SUBTRACTED BEFORE A.JUMP.  A.JUMP IS
; FILLED IN AT ASSEMBLY TIME SO FOR FCSRES TASKS TO WORK IT MUST STAY AT A 
; CONSTANT OFFSET.
;
	OFFSET	A.JUMP,4	;ADDRESS OF JUMP TABLE AND SIZE
;
; DEFINE M-PLUS SUPERVISOR MODE LIBRARY FLAG WORD
;
	OFFSET	A.MODE,2	; 0 = USER MODE, 1 = SUPERVISOR MODE

	.IF DF L$$GCL		;IF LOGICAL NAMES SUPPORTED

	.IF DF V$$ACP		;IF BUILT FOR USE WITH VMS ACP

	OFFSET	A.EXDS,52.	; AREA FOR STORAGE OF DIRECTORY STRING
	DEFIN$	S.EXDS,52.	;LENGTH OF DIRECTORY STORAGE AREA
	OFFSET	A.LGBK,80.	;LOGICAL NAME STORAGE BLOCK
	DEFIN$	S.LGBK,80.	;LENGTH OF BLOCK
	OFFSET	A.PRS,34.	;LOGICAL NAME PARSE BLOCK
	DEFIN$	S.PRS,34.	;LENGTH OF PARSE BLOCK
	OFFSET	A.FLAG,2	;FLAG WORD
	DEFIN$	AF.CCR,1	;FLAG TO INDICATE COMBINED CREATE
	DEFIN$	AF.RLG,2	;FLAG TO INDICATE REMOTE LOGICALS

	.IFF	;IF NO V$$ACP

	OFFSET	A.EXDS,12.	; AREA FOR STORAGE OF DIRECTORY STRING
	DEFIN$	S.EXDS,12.	;LENGTH OF DIRECTORY STORAGE AREA
	OFFSET	A.LGBK,40.	;LOGICAL NAME STORAGE BLOCK
	DEFIN$	S.LGBK,40.	;LENGTH OF BLOCK
	OFFSET	A.PRS,28.	;LOGICAL NAME PARSE BLOCK
	DEFIN$	S.PRS,28.	;LENGTH OF PARSE BLOCK

	.ENDC	;V$$ACP

	.IFF			;IF NO LOGICAL NAME SUPPORT

	OFFSET	A.EXDS,12.	;AREA FOR STORAGE OF DIRECTORY STRING
	DEFIN$	S.EXDS,12.	;LENGTH OF DIRECTORY STORAGE AREA

	.ENDC	;L$$GCL

	OFFSET	S.FSR2		;SIZE OF FILE STORAGE REGION 2
	DEF$L	S.FSR2
	DEF$I	0		;REINITIALIZE FOR CSI OFFSETS IN FSR5
	OFFSET	A.F5SZ,2	;SIZE OF FSR5
	OFFSET	A.LDVL,2	;LAST DEVICE LENGTH
	OFFSET	A.LDVA,2	;LAST DEVICE ADDRESS
	OFFSET	A.LDIL,2	;LAST DIRECTORY LENGTH
	OFFSET	A.LDIA,2	;LAST DIRECTORY ADDRESS

	.IF DF V$$ACP		;IF VMS ACP SUPPORT

	OFFSET	A.OUBK,80.	;CSI OUTPUT BUFFER
	OFFSET	A.LODV,6	;LAST OUTPUT DEVICE
	OFFSET	A.LODI,52.	;LAST OUTPUT DIRECTORY
	OFFSET	A.LIDV,6	;LAST INPUT DEVICE
	OFFSET	A.LIDI,52.	;LAST INPUT DIRECTORY
	OFFSET	A.INBK,80.	;CSI INPUT BUFFER
	DEFIN$	S.LDV,6		;LENGTH OF LAST DEVICE
	DEFIN$	S.LDI,52.	;LENGTH OF LAST DIRECTORY

	.IFF	;V$$ACP

	OFFSET	A.OUBK,40.	;CSI OUTPUT BUFFER
	OFFSET	A.LODV,6	;LAST OUTPUT DEVICE
	OFFSET	A.LODI,12.	;LAST OUTPUT DIRECTORY
	OFFSET	A.LIDV,6	;LAST INPUT DEVICE
	OFFSET	A.LIDI,12.	;LAST INPUT DIRECTORY
	OFFSET	A.INBK		;CSI INPUT BUFFER:NOT USED, BUT NEED THE OFFSET
	DEFIN$	S.LDV,6		;LENGTH OF LAST DEVICE
	DEFIN$	S.LDI,12.	;LENGTH OF LAST DIRECTORY

	.ENDC	;V$$ACP
	OFFSET	S.FSR5		;LENGTH OF FSR5

; DEFINE OFFSETS RELATIVE TO BEGINNING OF THE DEFAULT DIRECTORY INFO

	DEF$I	0

	OFFSET	,16.
	OFFSET	D.DFID,6	;DEFAULT DIRECTORY ID
	OFFSET	D.DFDV,2	;DEV NAME FOR DFLT DIR ID
	OFFSET	D.DFUN,2	;UNIT NUMBER FOR DFLT DIR ID

	.IIF	IDN,<DEF$N>,<OFFSET>,.MEXIT
	.MACRO	FSROF$	ARG
	.ENDM	FSROF$
	.ENDM	FSROF$

; DEFINE OFFSETS RELATIVE TO THE FILE DESCRIPTOR POINTER, F.DSPT

	.MACRO	FDSOF$	OFFSET
	.MCALL	OFFSET,DEF$I,DEF$L
	DEF$I	0

	OFFSET	N.DEVD,4	;DEVICE STRING DESCRIPTOR
	OFFSET	N.DIRD,4	;DIRECTORY STRING DESCRIPTOR
	OFFSET	N.FNMD,4	;FILE NAME STRING DESCRIPTOR
	OFFSET	S.FIDS
	.IF	IDN,<DEF$N>,<OFFSET>
	DEF$L	S.FIDS
	.MEXIT
	.ENDC
	.MACRO	FDSOF$	ARG
	.ENDM	FDSOF$
	.ENDM	FDSOF$


	.MACRO	DEF$G VAR,SIZ	;DEFINE GLOBAL OFFSET
	.MCALL	DEF$L
	.IIF	NB,VAR,.GLOBL VAR
	DEF$L	VAR,SIZ
	.ENDM	DEF$G


	.MACRO	DEF$N VAR,SIZ	;DEFINE NO OFFSET-CALCULATE THE SIZE
	.MCALL	DEF$L
	DEF$L	,SIZ
	.ENDM	DEF$N


; ** NOTE **
;
;	THIS MACRO IS USED BY VAX-11 RSX AND MUST ASSEMBLE CORRECTLY
;	UNDER VAX MACRO.

	.MACRO	DEF$I IVAL	;INITIALIZE DEFINITION
	...TPC=^O<IVAL>		;MACROS PROGRAM COUNTER
	.ENDM	DEF$I


; ** NOTE **
;
;	THIS MACRO IS USED BY VAX-11 RSX AND MUST ASSEMBLE CORRECTLY
;	UNDER VAX MACRO.

	.MACRO	DEF$L SYM,SIZ
	.IF NB,SYM
	SYM=^O<...TPC>
	.ENDC
	.IF NB,SIZ
	...TPC=^O<...TPC+SIZ>
	.ENDC
	.ENDM	DEF$L


	.MACRO	RAD50$	STRING,MAXWRD
	...PC2=.
	.RAD50	/STRING/
	.IF	GT,<.-...PC2>-^O<2*MAXWRD>
	.ERROR	;STRING		RAD50 - STRING TOO LONG, TRUNCATED;
	.=^O<...PC2+<2*MAXWRD>>
	.MEXIT
	.ENDC
	.REPT	^O<MAXWRD-<<.-...PC2>/2>>
	.WORD	0
	.ENDR
	.ENDM	RAD50$
