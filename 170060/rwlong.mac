	$BEGIN	RWLONG,<28.1>,<FCS READ/WRITE VIRTUAL BLOCK LONG>
; 
; THIS  SOFTWARE  IS FURNISHED UNDER A LICENSE AND MAY
; BE USED OR COPIED ONLY IN ACCORDANCE WITH THE  TERMS
; OF SUCH LICENSE.
;  
; COPYRIGHT (c) 1982 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
; 
;
; PREVIOUSLY MODIFIED BY
;
;	ELLEN R SIMICH
;	B A O'CONNELL
;	S. RUZICH
	.PAGE
;


;+
; ISSUE QI/O TO READ OR WRITE VIRTUAL BLOCK READ/WRITE MODE
; IF BYTE COUNT IS GREATER THAN ONE BLOCK.  THERE IS A CERTAIN
; AMOUNT OF OVERLAP BETWEEN THIS MODULE AND READ AND WRITE.
; HOWEVER, IT WAS NECESSARY TO SEPARATE THIS PROCESSING FROM THE 
; SINGLE BLOCK PROCESSING TO PRESERVE THE NECEASSARY
; SIZE REQUIREMENT FOR 11M'S UTILITIES. THIS MODULE IS JUMPED TO RATHER 
; THAN CALLED FROM READ OR WRITE AND RETURNS TO THE ORIGINAL CALLER.
; INPUTS:
;	F.BKVB(R0),F.BDVB+2(R0)=DESIRED VIRTUAL BLOCK NUMBER
;	F.BKDS(R0)=NO OF BYTES TO READ
;	F.BKDS+2(R0)ADDRESS TO READ DATA INTO
;	F.BKEF(R0)=EVENT FLAG USE FCS DEFAULT IF 0
;	F.BKST(R0)=ADDRESS OF I/O STATUS BLOCK OR 0
;	F.BKDN(R0)=ADDRESS OF I/O DONE AST OF 0
;	R4=IO FUNCTION CODE
; OUTPUTS:
;	C=0 IF QI/O WAS ISSUED SUCCESSFULLY
;	C=1 IF ERROR, F.ERR(R0) SET TO ERROR CODE
;	ALL REGISTERS PRESERVED
;	F.BKVB(R0),F.BKVB+2(R0) IS INCREMENTED AFTER QI/O
; OPERATION:
;	WILL RETURN EOF ERROR IF THE SPECIFIED VBN
; IS BEYOND THE END OF FILE. RETURNS THE LOW BYTE OF
; THE DIRECTIVE STATUS WORD IN F.ERR(R0) IF QI/O FAILED.
; ALSO WILL RETURN EOF ERROR IF NOT ENOUGH SPACE COULD 
; BE ALLOCATED ON A WRITE AT EOF.
; INCREMENTS THE VIRTUAL BLOCK NUMBER AFTER ISSUING THE
; QI/O FOR AUTOMATIC SEQUENTIAL ACCESS. THE FOLLOWING
; RESTRICTIONS APPLY:
;	1) THIS ROUTINE ONLY WORKS FOR BLOCK ORIENTED
; DEVICE, RECORD ORIENTED DEVICES ARE EXPLICITLY EXCLUDED.
;-
	.PAGE
..RWLG::
	MOV	F.VBN(R0),-(SP)		;SAVE DESIRED VBN
	MOV	F.VBN+2(R0),-(SP)	

	.IF	GT,R$$ANI
	BITB	#CH.AND,F.CHR(R0)	;ANSI TAPE?
	BNE	10$			;YES TREAT AS ONE BLOCK
	.IFTF

	CALL	BLOCKS			;CALCULATE NUMBER OF BLOCKS 
10$:	CALL	..SEFB			;CHECK END OF FILE
	BCS	40$			;ERROR
	MOV	(SP)+,F.VBN+2(R0)	;RESTORE ORIGINAL
	MOV	(SP)+,F.VBN(R0)
20$:	CALL	DOQIO			;ISSUE QIO
	JMP	70$
;
40$:	CMP	#IO.WVB,R4		;WRITE
	BEQ	60$			;YES 
	MOV	(SP)+,F.VBN+2(R0)	;RESTORE
	MOV	(SP)+,F.VBN(R0)

	.IFT
	BITB	#CH.AND,F.CHR(R0)	;ANSI TAPE?
	BNE	80$			;YES ERROR
	.IFTF

	CALL	..SEFB			;BOC CHECK START VBN NOT > EOF
	BCS	80$			;BOC EOF=ERROR
	MOV	F.EFBK+2(R0),R1		;GET EOF BLOCK
	SUB	F.VBN+2(R0),R1		;NUMBER TO READ
;	..SEFB VERIFIED NOT PAST EOF SO 
;		1NGL PREC OK  &  # BLOCKS >0
	CLR	R2			;CALCULATE BYTE COUNT
	TST	F.FFBY(R0)		;READ EOF BLOCK
	BEQ	50$			;NO
	INC	R1			;YES
50$:	ADD	F.VBSZ(R0),R2		
	DEC	R1			;ANY MORE BLOCKS
	BGT	50$			;YES
	MOV	F.BKDS(R0),-(SP)	;BOC SAVE USER BYTE COUNT
	MOV	R2,F.BKDS(R0)		;ADJUST BYTE COUNT
	CALL	DOQIO			;BOC DO I/O
	MOV	(SP)+,F.BKDS(R0)	;BOC RESTORE USER BYTE COUNT
	BR	70$			;BOC
;
60$:	MOV	F.VBN(R0),R1		;SET UP TO EXTEND
	MOV	F.VBN+2(R0),R2
	CALL	..ALC1
	MOV	(SP)+,F.VBN+2(R0)	;RESTORE
	MOV	(SP)+,F.VBN(R0)
	BCS	30$			;COULDNT DO IT
	CALL	DOQIO			;ISSUE QIO
	BITB	#FD.EFB,F.BKP1(R0)	;WRITING EOF
	BEQ	70$			;NO
	MOV	F.VBN(R0),F.EFBK(R0)	;RESET EOF BLOCK
	MOV	F.VBN+2(R0),F.EFBK+2(R0)
	CLR	F.FFBY(R0)
70$:	TST	F.ERR(R0)		;ERRORS
	BGT	30$			;NO
80$:	SEC				;YES
30$:	RETURN
;
;+
;	THIS ROUTINE COMPUTES THE NUMBER OF BLOCKS A USER REQUESTED
; IN A SINGLE READ OR WRITE.
;-
BLOCKS:
	MOV	F.BKDS(R0),R1		;GET BYTE COUNT
10$:	SUB	F.VBSZ(R0),R1		;CLACULATE #BLOCKS
	BLE	20$			;DONE
	ADD	#1,F.VBN+2(R0)		;ADJUST VBN
	ADC	F.VBN(R0)
	BR	10$
20$:	RETURN
;
;+
;	THIS ROUTINE ISSUES THE QIO AND ADJUSTS THE VBN
; FOR PROPER SEQUENTIAL OPERATION.
;-
DOQIO:
	CALL	..WTRD			;ISSUE QIO

	.IFT
	BITB	#CH.AND,F.CHR(R0)	;ANSI TAPE?
	BNE	10$			;YES TREAT AS ONE BLOCK
	.ENDC	;R$$ANI

	CALL	BLOCKS			;GET INCREMENT TO VBN
10$:	RETURN
;
;
	$END	RWLONG
;
;
	.END
