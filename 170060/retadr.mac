	$BEGIN	RETADR,<28.2>,<RETURN BUF ADDRESS TO USER>
; 
; THIS  SOFTWARE  IS FURNISHED UNDER A LICENSE AND MAY
; BE USED OR COPIED ONLY IN ACCORDANCE WITH THE  TERMS
; OF SUCH LICENSE.
;  
; COPYRIGHT (c) 1982, 1991 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
; 
; PETER H. LIPMAN 11-AUG-73
;
; PREVIOUSLY MODIFIED BY
;
;	G. KUENNING
;	S. RUZICH
;
; Modified for RSTS/E V10.1 by:
;
;	S. LeVan	21-Oct-91	V28.2
;		SEL001 - Shrink code by assuming F.RTYP=0.
;+
; RETURN BUFFER ADDRESS TO USER IN PARTIAL LOCATE MODE
; CALLING SEQUENCE:
;	CALL	..RTAD
; INPUTS:
;	R0=FDB ADDRESS
; OUTPUTS:
;	CC -	BLOCK BUFFER OR USER BUFFER USED OR RANDOM ACCESS
;	CS -	USER BUFFER REQUIRED AND NOT SPECIFIED
;	F.NRBD+2 =POINTER TO BLOCK BUFFER OR USER'S RECORD BUFFER
;		IF RECORD WOULDN'T FIT IN BLOCK BUFFER
;	R2 DESTROYED, ALL OTHERS PRESERVED
;-
..RTAD::BITB	#FD.PLC,F.RACC(R0) ;IF NOT LOCATE MODE, THEN NOP
	BEQ	30$
	MOV	F.NREC(R0),R2
	BITB	#FD.REC,F.RCTL(R0) ;RECORD ORIENTED DEVICE?
	BNE	5$		;BRANCH IF YES - SKIP VARIABLE LEN LOGIC
	;CMPB	#R.FIX,F.RTYP(R0) ;IF FIXED LENGTH RECORDS; SEL001
	CMPB	#R.FIX,(R0) 	;IF FIXED LENGTH RECORDS; SEL001
	ASSUME	F.RTYP,0	;SEL001
	BEQ	5$		;THEN NO RECORD HEADER
	CMPB	(R2)+,(R2)+	;RECORD HEADER IS AT LEAST
				;2 BYTES
	;CMPB	#R.SEQ,F.RTYP(R0) ;IF SEQUENCED RECORD; SEL001
	CMPB	#R.SEQ,(R0) 	;IF SEQUENCED RECORD; SEL001
	ASSUME	F.RTYP,0	;SEL001
	BNE	2$
	CMPB	(R2)+,(R2)+	;HEADER IS 2 BYTES BIGGER
2$:
	.IF	GT,R$$ANI
	BITB	#CH.AND,F.CHR(R0) ;AND IF ANSI D REC
	BEQ	5$
	CMPB	(R2)+,(R2)+	;RECORD HEADER IS 2 BYTES
	.ENDC			;BIGGER
5$:	MOV	R2,F.NRBD+2(R0)	;ASSUME MAX SIZE RECORD FITS
	MOV	F.URBD(R0),F.NRBD(R0) ;RETURN SIZE OF BUFFER
	;CMPB	#R.FIX,F.RTYP(R0) ;IF FIXED LENGTH; SEL001
	CMPB	#R.FIX,(R0) 	;IF FIXED LENGTH; SEL001
	ASSUME	F.RTYP,0	;SEL001
	BNE	10$
	MOV	F.RSIZ(R0),F.NRBD(R0) ;USE FIXED SIZE
10$:	ADD	F.NRBD(R0),R2	;SEE IF RECORD WILL FIT
	.IF	EQ,R$$BBF							; GK001
	CMP	R2,F.EOBB(R0)	;WILL IT FIT?
	.IFF									; GK001
	MOV	F.EOBB(R0),-(SP) ;ASSUME NOT ALLOWED TO SPAN BLOCKS		; GK001
	BITB	#FD.BLK,F.RATT(R0) ;CAN RECORDS SPAN BLOCKS?			; GK001
	BNE	20$		;IF NE NO, COMPARE AGAINST BLOCK END		; GK001
	MOV	F.BDB(R0),(SP)	;YES, FIND END OF LARGE BLOCK BUFFER		; GK001
	ADD	#S.BFHD,(SP)	;...						; GK001
	ADD	F.BBFS(R0),(SP)	;...						; GK001
20$:	CMP	R2,(SP)+	;SEE IF RECORD WILL FIT				; GK001
	.ENDC									; GK001
	BLOS	30$		;BRANCH IF IT WIL
	MOV	F.URBD+2(R0),F.NRBD+2(R0) ;MAX RECORD WON'T FIT
				;POINT HIM AT HIS RECORD BUFFER
	BNE	30$			;RETURN IF USER HAS A NON-ZERO URBD
	BITB	#FD.RAN,F.RACC(R0) 	;NO URBD - USING RANDOM ACCESS?
	BNE	30$			;YES- USER HAD BETTER .POSRC 
	MOVB	#IE.RBG,F.ERR(R0) 	;NO - PREVENT USER FROM OVERWRITING 
	SEC				;INDICATE FAILURE
	BR	40$			;USE COMMON EXIT
30$:	CLC				;INDICATE SUCCESSFUL 
40$:	RETURN				;
;
;
	$END	RETADR
;
;
	.END
