	$BEGIN	WTWATD,<28.1>,<WRITE & WAIT, DUMPING BIG BUFFER>
; 
; THIS  SOFTWARE  IS FURNISHED UNDER A LICENSE AND MAY
; BE USED OR COPIED ONLY IN ACCORDANCE WITH THE  TERMS
; OF SUCH LICENSE.
;  
; COPYRIGHT (c) 1982 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
; 
; STEVE RUZICH 22-MAY-81
;
; PREVIOUSLY MODIFIED BY
;
;	S. RUZICH
;
;+
;
; FCS INTERNAL ENTRY POINT:
;	CALL	..WTWD
; OPERATION:
; SIMILAR TO ..WTWA IN WTWAIT EXCEPT THAT IT FORCES A WRITE OF A BIG BUFFER
; EVEN IF THE WRITE WOULD NORMALLY HAVE BEEN DELAYED BY JUST POSITIONING TO
; THE NEXT BLOCK IN THE BUFFER, AND IT CORRECTLY WRITES THE SHORT BLOCK AT THE
; END OF AN ANSI TAPE FILE.  ..WTWD IS INTENDED TO BE CALLED BY .FLUSH, POINT
; (WHEN WRITING THE FINAL BLOCK), AND CLOSE. 
;
;    INPUT:	R0=FDB
;		F.BDB+#S.BFHD=ADDRESS OF DATA
;		F.BBFS(R0)=NO. OF BYTES TO WRITE
;		F.BKP1(R0) BIT FD.OER MAY BE SET IF CALLED FROM .FLUSH
;		0=CARRIAGE CONTROL
;
;-
..WTWD::CLC				;
	BITB	#FD.WRT,F.BKP1(R0)	;DOES THE BLOCK NEED TO BE WRITTEN?
	BEQ	60$			;NO - ALL DONE

	.IF	GT,R$$BBF		;IF BIG BUFFERS ALLOWED
	BISB	#FD.BGD!FD.NAD,F.MBFG(R0) ;FORCE ENTIRE BUFFER OUT ...
					;... DO NOT ADVANCE VBN AFTER WRITE
	.IFF	;R$$BBF
	BISB	#FD.NAD,F.MBFG(R0)	;DO NOT ADVANCE VBN AFTER WRITE
	.ENDC

	.IF	GT,R$$ANI
	CALL	..BKRG			;SET UP REGISTERS FOR BUFFER WRITE

	.IF	GT,R$RSTS
	BITB	#FD.EOF,F.BKP1(R0) ;LAST PUT AS EOF?
	BEQ	4$		 ;NO, DON'T CLEAR REST OF BLOCK
	MOVB	F.RTYP(R0),R4	;GET RECORD TYPE
	BEQ	1$		;BR IF UNATTRIBUTED STREAM
	CMPB	#R.STM,R4	;ATTRIBUTED STREAM?
	BNE	4$		;NO SO SKIP ZERO PAD BUFFER
1$:	MOV	F.NREC(R0),R4	;GET NEXT RECORD POINTER
	MOV	F.EOBB(R0),R3	;GET END OF BLOCK POINTER
	SUB	R4,R3		;# OF NULLS TO PAD
	BLOS	4$		;NONE SO DO NOTHING
3$:	CLRB	(R4)+		;CLEAR REST OF BUFFER
	SOB	R3,3$
4$:
	.ENDC

	BITB	#CH.AND,F.CHR(R0) 	;IS THIS ANSI TAPE?
	BEQ	50$			;BRANCH IF NO
;
; FOR FIXED LENGTH RECORDS, WRITE A SHORT BLOCK (ONLY DATA ACTUALLY PUT)
; FOR VARIABLE LENGTH RECORDS, PUT AN EOF RECORD AND WRITE THE FULL BLOCK.
;
	BICB	#FD.NAD,F.MBFG(R0)	;MUST ADVANCE TO NEXT VBN ON TAPE
	CMPB	#R.FIX,F.RTYP(R0)	;FIXED OR VARIABLE LENGTH RECORDS?
	BNE	40$			;BR IF VARIABLE - PAD OUT THE BLOCK

	.IF	GT,R$RSTS
	CMPB	#R.STM,F.RTYP(R0) 	;IS FILE ASCII STREAM?
	BEQ	50$			;YES, SO SKIP ON
	.ENDC

	MOV	F.NREC(R0),R2	;GET NEXT RECORD ADDRESS
	SUB	R1,R2		;CALCULATE R2=SIZE OF SHORT BLOCK
	CMP	R2,#TAPMIN	;SEE IF BLOCK SIZE IS LESS THAN LEGAL MINIMUM
	BGE	20$		;GE - LEGAL SIZE
				;LT - PAD OUT THE BLOCK TO MINIMUM SIZE
	MOV	#TAPMIN,R2	;NEW BLOCK SIZE
20$:	INC	R2		;
	BIC	#1,R2		;ROUND R2 UP TO EVEN SIZE IF IT WAS ODD
				;R3 IS STILL ZERO, SO DON'T NEED ..BKRG
				;F.EOBB MAY BE A BIT HIGH, BUT WHO CARES
40$:	CALL	..ANSP		;PAD TO END-OF-BLOCK-BUFFER
50$:	CALL	..WTW1		;WRITE OUT THE BUFFER; GET ERROR STATUS
	.IFF	;NON-ANSI

	CALL	..WTWA		;SET UP REGS, WRITE BUFFER
	.ENDC	;R$$ANI

	.IF	GT,R$$BBF
	BICB	#FD.BGD!FD.NAD,F.MBFG(R0) ;CLEAR DUMP & NO-ADVANCE FLAGS

	.IFF	;R$$BBF
	BICB	#FD.NAD,F.MBFG(R0) ;CLEAR NO-ADVANCE FLAG, PRESERVE CARRY
	.ENDC

60$:	RETURN			;

;
;
	$END	WTWATD
;
;
	.END
