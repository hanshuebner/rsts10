	$BEGIN	CLOSE,<29.5>,<FCS CLOSE FILE ROUTINE>
; 
; THIS  SOFTWARE  IS FURNISHED UNDER A LICENSE AND MAY
; BE USED OR COPIED ONLY IN ACCORDANCE WITH THE  TERMS
; OF SUCH LICENSE.
;  
; COPYRIGHT (C) 1988, 1991 BY DIGITAL EQUIPMENT CORPORATION
; ALL RIGHTS RESERVED.
; 
; PETER H. LIPMAN 13-JULY-73
;
; PREVIOUSLY MODIFIED BY
;
;	M. GONSALVES
;	SHAO-SUN CHIEN
;	S. RUZICH
;	J. PAINTER
;	S. RUZICH
;	LONI BROWN
;	S. RUZICH
;	A. GROUPE
;
; MODIFICATIONS:
;
;	S. M. THOMAS	15-JUL-83	18.0
;
;		SMT042 -- HANDLE DEVICE FULL ERROR FROM ..WTWD
;
;	S. M. THOMAS	27-SEP-83	18.1
;
;		SMT054 -- FIX MULTI-BUFFERING PROBLEM.  R1 SHOULD
;			  BE SET UP BEFORE CALLING '..WAIT'.
;			  ALSO, SET FD.EFB BEFORE CALLING ..WTWD.
;			  THIS GUARANTEES ANY NECESSARY FILE EXTENSION.
;
; Modified for RSX-11M-PLUS V4.1 by:
;
;	R. W. SPINNEY	3-MAY-88	29.3
;		RWS009 -- Correct misplaced label - so CLOSE will wait
;			for all I/O to complete before closing multi-
;			buffered file
;
; Modified for RSTS/E V10.1 by:
;
;	S. LeVan	15-May-91	29.4
;		SEL001- Merge RSTS-specific code into RSX V4.3 version 
;
;	S. LeVan	21-Oct-91	29.5
;		SEL002- Shrink code by assuming F.RTYP and CLSFQ=0
;
	.PAGE
;+
; CLOSE A FILE
; CALLING SEQUENCE:
;	CALL	.CLOSE
; INPUTS:
;	R0=FDB
; OUTPUTS:
;	ALL REGISTERS PRESERVED
;	C=0 IF SUCCESSFUL, C=1 IF AN ERROR OCCURRED WRITING THE HEADER
;	F.BDB, F.BBFS, F.FNB=0
; OPERATION:
;	IF THE FILE IS OPEN, THEN F.BDB IS NON-ZERO.  IF THERE IS
; A PARTIAL BLOCK BUFFER THEN IT IS WRITTEN, THEN THE HEADER IS WRITTEN
; TO VIRTUAL BLOCK ZERO.  FINALLY THE BLOCK BUFFER IS RELEASED.
;-

.CLOSE::.SAVR1			;SAVE REGISTER R1-R5
	MOV	#1,F.ERR(R0)	;INIT ERROR RETURN CODE
	MOV	#1,-(SP)	;INITIALIZE SAVED ERROR CODE TO SUCCESS
	MOV	F.BDB(R0),R1	;FILE ALREADY CLOSED?
	.IF	GT,R$RSTS	;DO RIGHT BRANCH FOR RSTS			;FEK001
	BEQ	60$		;BRANCH TO THE END				;FEK001
	.IFF									;FEK001
	BEQ	341$		;RETURN WITH SUCCESSFUL STATUS			; SR196
				;(DO TWO BRANCHES TO AVOID A JUMP)		; SR196
	.ENDC									;FEK001

2$:	BITB	#FD.RWM,F.RACC(R0) ;IF READ/WRITE MODE, SKIP THIS
	BNE	23$

	.IF	GT,R$RSTS	;++RSTS 7.2					;FEK002
	BITB	#FD.WRT,F.BKP1(R0) ;DOES IT NEED TO BE WRITTEN			;FEK002
	BEQ	4$		   ;NO, SO SKIP IT				;FEK002
	BITB	#FD.EOF,F.BKP1(R0) ;LAST PUT AS EOF?				;FEK002
	BEQ	4$		 ;NO, DON'T CLEAR REST OF BLOCK			;FEK002
	;MOVB	F.RTYP(R0),R4	;GET RECORD TYPE; FEK002; SEL002 
	MOVB	(R0),R4		;GET RECORD TYPE ;FEK002; SEL002
	ASSUME	F.RTYP,0	;SEL002
	BEQ	1$		;BR IF UNATTRIBUTED STREAM			;FEK002
	CMPB	#R.STM,R4	;ATTRIBUTED STREAM?				;FEK002
	BNE	4$		;NO SO SKIP ZERO PAD BUFFER			;FEK002
1$:	MOV	F.NREC(R0),R4	;GET NEXT RECORD POINTER			;FEK002
	MOV	F.EOBB(R0),R3	;GET END OF BLOCK POINTER			;FEK002
	SUB	R4,R3		;# OF NULLS TO PAD				;FEK002
	BLOS	4$		;NONE SO DO NOTHING				;FEK002
3$:	CLRB	(R4)+		;CLEAR REST OF BUFFER				;FEK002
	SOB	R3,3$								;FEK002
4$:										;FEK002
	.ENDC			;++RSTS 7.2 END					;FEK002

	.IF	GT,R$$MBF
	BISB	#FD.EFB,F.BKP1(R0)
				;SET FD.EFB IN CASE IT WAS RESET BY
				;A RANDOM GET.  THIS ENSURES NECESSARY
				;FILE EXTENSION.
	.ENDC
	CALL	..WTWD		;IF BUFFER IS DIRTY, WRITE OUT FINAL BLOCK
	MOVB	F.ERR(R0),(SP)	;SAVE STATUS
	.IF 	EQ,R$RSTS	
	BCS	34$		;SEL001 - Goto RSX code on error
	.IFF			;SEL001 - Goto RSTS code on error
	BCS	37$		;SEL001 - Branch needed if Multiple Buffering
	.ENDC			
;
10$:
	.IF	GT,R$$MBF	;IF MULTIPLE BUFFERING
	CLR	R5
	BISB	F.MBC1(R0),R5	;NO. OF BUFFERS
	MOV	F.BDB(R0),R1	;POINT TO BDB
;
20$:	CALL	..WAIT		;WAIT FOR I/O DONE
	BCC	22$		;BRANCH IF NO ERROR
	TST	(SP)		;ALREADY HAVE AN ERROR?
	BLT	22$		;BRANCH IF YES, REPORT 1ST
	BITB	#FD.WBH,F.MBFG(R0) ;WRITE BEHIND ERROR?
	BEQ	22$		;NO - PROBABLY ERROR WAS MULTIBUF READ PAST EOF
	MOVB	@R1,(SP)	;YES- REPORT IT
22$:	MOV	B.NXBD(R1),R1
	SOB	R5,20$		;SCAN ALL BUFFERS
	BITB	#FD.REC,F.RCTL(R0) ; RECORD ORIENTED DEVICE
	BEQ	23$		; NO
	MOVB	#1,F.ERR(R0)	; YES, DON'T REPORT ANY ERRORS
	CLC
	.ENDC
;
; TRUNCATE THE FILE IF FD.TRN IS SET
;
23$:
	.IF	EQ,R$RSTS	; RSTS CAN NOT DO TRUNCATES			;FEK001

	BITB	#FD.TRN,F.BKP1(R0) ; AUTO TRUNCATE TURNED ON?
	BEQ	34$		; NO, THEN BRANCH AROUND TRUNCATE PROCESSING
;+
;
; NOTES:
;	THE USER MUST HAVE THE FILE WRITE
;	ACCESSED, AND HAVE EXTEND PRIVILEGES
;	OR THE TRUNCATE WILL FAIL
;
; OPERATION:
;	THE FILE IS TRUNCATED BACK TO F.EFBK
; OR F.EFBK-1 IF F.FFBY = 0. THEN F.HIBK IS
; SET TO THE NEW ALLOCATION LENGTH WHICH IS
; THE SPECIFIED VBN FOR THE TRUNCATION ADJUSTED
; BY THE ROUNDUP FACTOR RETURNED BY THE ACP
; (IOSTATUS +2) TO ACCOUNT FOR CLUSTERING.
;
;-
	MOV  F.BDB(R0),R1	;GET I/O STATUS BLK ADDR
	CALL	..IDPB		;INIT THE DPB, SET R5 TO PARAM BLOCK
	MOV  R0,(R5)		;STORE ADDR OF FILE ID
	ADD  #F.FNB,(R5)+	
	TST  (R5)+		;SKIP OVER ATTR LIST PTR
; 
; CALCULATE AND SAVE ON STACK THE VBN TO TRUNCATE TOO.
;
	MOV  F.EFBK(R0),-(SP)	;GET EOF VBN ON STACK
	MOV  F.EFBK+2(R0),-(SP)
	TST  F.FFBY(R0)		;IF F.FFBY = 0 THEN
	BNE  24$
	SUB  #1,(SP)		;SUBTRACT ONE FROM VBN
	SBC  2(SP)
24$:	MOV  2(SP),(R5)		;STORE VBN IN DPB
	BIS  #100000,(R5)+	;SET EXTEND ENABLE
	MOV  (SP),(R5)
	MOV  #IO.DEL,R4		;ISSUE TRUNCATE CALL
	CALL  ..QIOW		;AND WAIT
	MOVB  4(SP),(R1)	;RESTORE STATUS TO I/O STATUS BLOCK
	BCC  27$		;BRANCH IF NO ERRORS
	CMPB	#IE.EOF,F.ERR(R0) ;WAS THE ERROR AN END-OF-FILE?
	BEQ	25$		;YES- TRUNCATE WAS REDUNDANT - NOT AN ERROR
	CMPB	#IE.LCK,F.ERR(R0) ;IS SOMEONE ELSE READING THE FILE NOW?
	BEQ	25$		;YES- TRUNCATE WAS NOT DONE, BUT FILE IS OK
				;(REMOVE THE IE.LCK TEST IF F11ACP IS FIXED)
	ADD	#4,SP		;NO - REAL ERROR - POP VBN FROM STACK
	BR	33$		;AND CONTINUE
25$:	MOV	#1,F.ERR(R0)	;TURN THE ERROR CODE INTO SUCCESS
;
; ADJUST F.HIBK
;
27$:	ADD  2(R1),(SP)		;ADJ VBN BY ROUNDUP FACTOR
	ADC  2(SP)
	MOV  (SP)+,F.HIBK+2(R0)	;STORE NEW F.HIBK IN FDB
	MOV  (SP)+,F.HIBK(R0)
;
33$:	TSTB	(SP)		; IS THERE AN ERROR FROM FLUSH?
	BLT	34$		; YES- KEEP IT STACKED
	MOVB	F.ERR(R0),(SP)	; NO - STACK TRUNCATE ERROR OR SUCCESS CODE
;
; END OF TRUNCATE PROCESSING
;
;
; IF THIS WAS A NEW FILE AND THE VERSION NUMBER WAS DEFAULTED, THEN
; WRITE THE ATTRIBUTES SO THE VERSION IS ON THE FILE HEADER
; THIS SHOULD BE FIXED SO THAT IT CAN BE DONE AT DEACCESS.
; CAN'T WRITE ATTRIBUTES IF RECORD OR SEQUENTIAL DEVICE
34$:	BITB	#FD.MNT,F.MBFG(R0) ;SHOULD THIS FILE BE DEACCESSED?
341$:	BEQ	60$		;EQ- NOT MOUNTABLE - DON'T DEACCESS IT
	CALL	..IDPB		;INIT THE DPB, SET R5 TO PARAM BLOCK
	CLR	(R5)+		;NEVER A FILE ID POINTER
	MOV	SP,R4		;SAVE CURRENT STACK POINTER
	CLR	-(SP)		;0 TERMINATES ATTRIBUTE LIST
	BITB	#FA.CRE,F.FACC(R0) ;WAS THIS A CREATE?
	BEQ	36$		;IF NOT, SKIP REST OF ATTRIBUTES
	BITB	#FD.SQD!FD.REC,F.RCTL(R0) ;SEQUENTIAL OR RECORD DEVICE?
	BNE	36$		;YES, NO VERSION ATT WRITE
	BITB	#FD.DVR,F.BKP1(R0) ; CREATING DEFAULT VERSION?
	BEQ	35$		;NO
	MOV	R0,-(SP)	;SET FDB ADDRESS
	ADD	#F.FVER,(SP)	;AND POINT TO THE VERSION NUMBER
	MOV	(PC)+,-(SP)	;YES, SO SET THE WRITE ATTRIBUTE
	.BYTE	HA.VER,2
35$:	MOV	@#.FSRPT,R2	;GET ADDRESS OF FSR
	ADD	#A.OWUI,R2	;POINT TO FILE OWNER WORD
	TST	(R2)		;ZERO MEANS DEFAULT
	BEQ	36$		;BRANCH IF YES
	MOV	R2,-(SP)	;PUT FILE OWNER IN ATTRIBUTE LIST
	MOV	(PC)+,-(SP)
	.BYTE	HA.UI,2
	.ENDC									;FEK001

36$:				; ACP WILL IGNORE ATTRIBUTES IF READ ACCESS
	.IF	EQ,R$RSTS
	.IFF
37$:				;SEL001 - Added label for prior branch on error
	CALL	..IFQB		;SET UP FIRQB AND POINTER	
	BITB	#FA.RD,F.FACC(R0) ;IS ACCESS READ ONLY?
	BNE	40$		; BR IF /RONLY
	CLR	R4		; SET COUNT TO 0 FOR READ
	CALL	..ATR		; READ FILE ATTRIBUTES INTO FIRQB
	TSTB	@#IOSTS		; IF ERROR ON READ
	BNE	38$		; THEN NOT A DISK DEVICE
	TST	FQPPN(R5)	; IF ATTIRBUTES ARE 0
	BEQ	38$		; THEN FILE HAS NO ATTRIBUTES
	MOV	#7,R4		; # OF WORDS OF ATTRIBUTES TO
$.NOA1==.-2			;PATCH LOCATION FOR NO ATTRIBUTES ON CLOSE	;FEK003
	CALL	..ATR		; WRITE OUT ATTRIBUTES
38$:	MOVB	F.LUN(R0),R4	; GET LUN NUMBER
	ASL	R4		; TIMES 2
	MOV	R4,FQFIL(R5)	; IS CHANNEL TIMES 2
	.IFT
	MOV	R0,-(SP)	;ADDRESS OF DATA
	MOV	(PC)+,-(SP)	;NO, SO WRITE RECORD I/O ATTRIBUTE
	.BYTE	HA.UAT,S.FATT
40$:	MOV	SP,(R5)+	;SET ATTRIBUTE LIST IN DPB
	MOV	R4,-(SP)	;SAVE OLD STACK POINTER
	MOV	#IO.DAC,R4	;DEACCESS I/O FUNCTION CODE
	.IFF
40$:	;MOV	#CLSFQ,R4	;SET FIP CODE FOR CLOSE; SEL002
	CLR 	R4		;SET FIP CODE FOR CLOSE; SEL002
	ASSUME	CLSFQ,0		;SEL002
	.IFTF
	.IF	GT,R$$ANI
	TST	F.ACTL(R0)	; ARE USER ACCESS CONTROL BITS ENABLE
	BPL	48$		; BRANCH IF NOT
	.IF	EQ,R$RSTS
	ADD	#4,R5		;ACCESS CONTROL WORD IN DPB
	MOV	F.ACTL(R0),(R5)	;MOV ACCESS CONTROL WORD FROM FDB
	BIC	#FA.ENB,(R5)	;BUT DISABLE ACCESS
	.IFF
	BIT	#FA.RWD,F.ACTL(R0)	; REWIND AFTER CLOSE?
	BEQ	48$			; NO
	MOV	#8.,@#XRB+XRLEN		; SET REWIND AFTER CLOSE
	MOVB	FQFIL(R5),@#XRB+XRCI	; SET CHAN*2
	MOVB	#MTAHND,@#XRB+XRCI+1	; FILL IN MAGTAPE INDEX
	.SPEC
	.ENDC	;EQ,R$RSTS
	.ENDC	;GT,R$$ANI
	.IFT
48$:	CALL	..QIOW		;ISSUE THE DEACCESS QI/O AND WAIT
	MOV	(SP)+,SP	;CLEAN THE STACK
	.IFF
48$:	CALL	..FIP		; CALL FIP TO CLOSE FILE
	.ENDC	;EQ,R$RSTS
60$:				;
	MOVB	(SP)+,R1	;RECOVER SAVED ERROR STATUS
	BGT	70$		;BRANCH IF SAVED STATUS WAS NOT AN ERR
	MOVB	R1,F.ERR(R0)	;REPORT THIS ERROR
70$:
80$:				; REF TAG
		CALL	..RFDB
	CALLR	..FCSX
;
;
	$END	CLOSE
;
;
	.END
