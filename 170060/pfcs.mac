	$BEGIN	PFCS,<1.3>,<CALL THE LOGICAL NAME EXPANSION DIRECTIVE>
;
; THIS  SOFTWARE  IS FURNISHED UNDER A LICENSE AND MAY
; BE USED OR COPIED ONLY IN ACCORDANCE WITH THE  TERMS
; OF SUCH LICENSE.
;
; COPYRIGHT (c) 1984, 1987 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
;
; P. K. M. WEISS
;
; MODIFIED BY:
;
;	PAUL K. M. WEISS	13-MAY-1987	1.2
;
;		PKW126	- MAKE SURE WE DON'T OVERRUN BUFFER
;
;	PAUL K. M. WEISS	27-OCT-1987	1.2
;
;		PKW139	- SET FS$DID BIT FOR PARSE
;
	.MCALL	PFCS$S,LNBDF$

	LNBDF$		;DEFINE LOGICAL NAME OFFSETS
;+
; PFCS ROUTINE - SET UP AND CALL THE PFCS DIRECTIVE
;
; CALLING SEQUENCE
;	CALL	..PFCS
; INPUTS:
;	R0=LUN
;	R2=POINTER TO INPUT DSD
;	R3=DEFAULT FILE NAME BLOCK OR 0 IF NONE SPECIFIED
;	R4=SIZE OF EXPANDED STRING BUFFER
;	R5=ADDRESS OF EXPANDED STRING BUFFER
; OUTPUTS:
;	R1=EXPANDED STRING FLAGS WORD
;	R2=POINTER TO OUTPUT DSD
;	R3 PRESERVED
;	R4=DRPFN SUB-STATUS
;	OTHER REGISTERS ALTERED
;	C=0 FOR SUCCESSFUL DIRECTIVE EXECUTION
;	C=1 IF DIRECTIVE FAILED
; OPERATION:
;	IF R4 OR R5 IS ZERO, THE PARSE AREA IN THE FSR IS USED FOR THE EXPANDED
;	STRING.  OTHERWISE, THE USER SPECIFIED AREA IS USED.
;	ALL PARTS OF THE DSD ARE ASSEMBLED INTO ONE STRING IN THE EXPANSION
;	BUFFER, THEN THE PFCS$ DIRECTIVE IS SET UP AND CALLED.
;
;-
..PFCS::MOV	R3,-(SP)	;SAVE DEFAULT NAME BLOCK
	MOV	@#.FSRPT,R1	;GET POINTER TO FSR
	ADD	#A.PRS,R1	;R1 POINTS TO THE PARSE BLOCK
	MOV	R1,-(SP)	;SAVE PARSE BLOCK ADDRESS
	MOV	R5,-(SP)	;AND THE EXPANSION BLOCK
	BEQ	10$		;IF NONE, USE THE ONE IN THE FSR
	TST	R4		;HOW ABOUT A LENGTH?
	BNE	20$		;WE'RE OK
10$:	MOV	R1,(SP)		;CHANGE EXPANSION BLOCK POINTER ON THE STACK
	ADD	#A.LGBK-A.PRS,(SP) ;TO THE EXPANSION BLOCK IN THE FSR
	MOV	#S.LGBK,R4	;R4 IS THE LENGTH OF THE FSR EXPANSION BLOCK
20$:	MOV	R4,(R1)+	;STORE THE LENGTH IN THE PARSE BLOCK
	MOV	#FS$DID,(R1)	;IF WE HAVE A LUN, WE WANT THE DIRECTORY ID
	TST	R0		;DID WE GET A LUN TO ASSIGN?
	BNE	30$		;YES, CONTINUE
	MOV	#FS$NDF,(R1)	;TELL PFCS NOT TO USE DEFAULTS
30$:	TST	R2		;IS THERE A DSD?
	BNE	33$		;YES, CONTINUE
	CLR	R4		;MARK NO LENGTH
	BR	80$		;AND SKIP ASSEMBLING THE DSD
33$:	MOV	(R2),R1		;LENGTH OF DEV
	ADD	4(R2),R1	;PLUS LENGTH OF DIR
	ADD	10(R2),R1	;PLUS LENGTH OF NAME
	CMP	R1,R4		;IS THERE ENOUGH ROOM?
	BLT	35$		;YES, CONTINUE *THIS SHOULD BE BLT NOT BLE 
				;BECAUSE WE MAY ADD A COLON TO THE DEVICE*
	MOV	#IE.RBS,@#$DSW	;SET THE ERROR STATUS
	ADD	#6,SP		;CLEAN THE STACK
	BR	110$		;AND EXIT
35$:	MOV	(SP),R4		;GET THE ADDRESS OF THE EXPANSION BLOCK
40$:	MOV	#3,R1		;DEV, DIR, AND FILE
50$:	MOV	(R2)+,R5	;GET THE LENGTH OF THIS PART
	MOV	(R2)+,R3	;GET THE ADDRESS
	TST	R5		;WAS THE LENGTH ZERO?
	BEQ	70$		;YES, DO THE NEXT ONE
60$:	MOVB	(R3)+,(R4)+	;MOVE A BYTE
	SOB	R5,60$		;...
	CMP	#3,R1		;ARE WE DOING THE DEVICE?
	BNE	70$		;NOPE, JUST CONTINUE
	CMPB	#':,-1(R4)	;WAS THE LAST CHARACTER A COLON?
	BEQ	70$		;YES, WE DON'T NEED TO ADD ONE
	MOVB	#':,(R4)+	;ADD THE COLON
70$:	SOB	R1,50$		;DO ALL THREE PARTS
	SUB	(SP),R4		;GET THE TOTAL LENGTH IN R4
80$:	MOV	(SP)+,R5	;RESTORE EXPANSION BLOCK ADDRESS
	MOV	(SP)+,R2	;PARSE BLOCK ADDRESS
	MOV	(SP)+,R3	;AND DEFAULT NAME BLOCK ADDRESS
	MOV	R3,R1		;IF NO DFNB, THE LENGTH SHOULD BE ZERO
	BEQ	90$		;IF EQ, LEAVE LENGTH A ZERO
	MOV	#S.FNB,R1	;WE HAVE A DFNB, USE THE FNB LENGTH
90$:	PFCS$S	,,R0,R5,R4,R5,@R2,,R2,#S.PRS,R3,R1,2(R2)
;
; PFCS HAS SEPARATE ENTRIES FOR NAME, TYPE, AND VERSION, BUT DSD HAS ONLY ONE
;
	TST	O$NAMA(R2)	;DID IT FIND A NAME?
	BNE	100$		;YES, CONTINUE
	MOV	O$TYPA(R2),O$NAMA(R2) ;GET THE ADDRESS OF THE TYPE
	BNE	100$		;IF THAT WAS THERE, THEN GO ON
	MOV	O$VERA(R2),O$NAMA(R2) ;LAST CHANCE - WAS A VERSION SPECIFIED?
100$:	ADD	O$TYPS(R2),O$NAMS(R2) ;ADD THE LENGTHS OF THE FILE TYPE
	ADD	O$VERS(R2),O$NAMS(R2) ;VERSION TO THE FILE NAME LENGTH
	MOV	O$FLAG(R2),R1	;MOVE FLAGS TO R1
	MOV	O$STAT(R2),R4	;MOVE THE STATUS INTO R4
	ADD	#O$DEVS,R2	;POINT TO THE DEVICE DESCRIPTOR
	TST	(R2)		;WAS THERE A DEVICE FOUND?
	BEQ	110$		;NOPE, JUST EXIT
	DEC	(R2)		;A DSD DOESN'T INCLUDE THE COLON, BUT PFCS DOES
110$:	TST	@#$DSW		;TEST THE DSW
	BGE	120$		;IF NOT NEGATIVE, OK
	SEC			;INDICATE FAILURE
120$:	RETURN
	$END	PFCS
	.END
