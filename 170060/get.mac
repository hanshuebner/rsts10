	$BEGIN	GET,<28.4>,<FCS GET RECORD ROUTINE>,R$$SEQ,<GET,GETSQ>
; 
; THIS  SOFTWARE  IS FURNISHED UNDER A LICENSE AND MAY
; BE USED OR COPIED ONLY IN ACCORDANCE WITH THE  TERMS
; OF SUCH LICENSE.
;  
; COPYRIGHT (c) 1982, 1987, 1991 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
; 
; PETER H. LIPMAN 13-JULY-73
;
; PREVIOUSLY MODIFIED BY
;
;	SHAO-SUN CHIEN
;	B. O'CONNELL
;	G. KUENNING
;	S. RUZICH
;	LONI BROWN
;	S. RUZICH
;
; MODIFICATIONS:
;
; S. M. THOMAS	14-FEB-83	(28.2)
;
;	SMT020 -- PROCESS MAG TAPE RECORDS (CH.AND) AS 
;		  "CANNOT CROSS BLOCK BOUNDARY"
;		  REGARDLESS OF FD.BLK BIT.
;
; P. K. M. WEISS 18-MAY-1987	28.3
;
;	PKW126 -- SHRINK CODE BY ASSUMING F.RTYP=0
;
; S. LeVan	21-May-1991	28.4
;
;	SEL001 -- Merge RSTS code into RSX V4.3 of module. Code merged is from:
; 		R. E. GOODWIN	25-AUG-87
;		REG001 - RETURN IE.RBG ERROR IF INPUT RECORD TOO BIG FOR BUFFER
;
;+
; .GET IS A SUBROUTINE TO READ A LOGICAL RECORD FROM A FILE.
;
; CALLING SEQUENCE:
;	JSR PC,.GET
; INPUTS:
;	R0=FILE DESCRIPTOR BLOCK ADDRESS
; OUTPUTS:
;	F.NRBD+2	= ADDRESS OF RECORD IF IN LOCATE MODE
;	F.NRBD	= SIZE  IN BYTES OF RECORD READ
;	F.ERR	= +1 IN NO ERRORS
;		= -N IF ERROR, WHERE N DESCRIBES WHAT HAPPENED
;	C BIT	= 0 IF NO ERROR
;		= 1 IF ERROR
; OPERATION:
;	ALL PARAMETERS ARE ASSUMED TO BE IN THE FILE DESCRIPTOR BLOCK
; THESE INCLUDE THE ADDRESS AND SIZE OF THE USER'S RECORD BUFFER.
;
;-



	.IF	EQ,R$$11M	; RSX-11D ONLY
	.IF	GT,R$$RSL	;IF ASSEMBLING FOR RESIDENT LIBRARY
	.IF	EQ,R$$SEQ	;AND NOT SEQUENTIAL ONLY
.GETSQ::
	.ENDC
	.ENDC
	.ENDC
	.IF	EQ,R$$SEQ
.GET::	.SAVR1			;SAVE REGISTERS R1-R5
	CALL	..PGCR		;VERIFY THAT PUT/GET IS LEGAL
	.ENDC
;
	.IF	GT,R$$SEQ
.GETSQ::.SAVR1
	CALL	..PGCS		;VERIFY THAT PUT GET IS LEGAL
	.ENDC
;
	BCS	GETX		;BRANCH IF ILLEGAL
	BITB	#FD.EF1,F.BKP1(R0) ;DELAYED EOF TO REPORT?
	BNE	EOFERR		;BRANCH IF YES
	BITB	#FD.REC,F.RCTL(R0) ;RECORD ORIENTED?
	BEQ	GTBLK		;BRANCH IF BLOCK ORIENTED
;
; RECORD ORIENTED DEVICE
;
	CALL	..RWAT		;READ THE NEXT RECORD
	MOV	F.BDB(R0),R1
	MOV	2(R1),R3	;RECORD SIZE FROM 2ND I/O
				;STATUS WORD
	MOV	F.NREC(R0),R1	;SOURCE ADDRESS OF RECORD
	CALL	RETREC
20$:	CMPB	#IE.EOF,F.ERR(R0) ;END OF FILE TO REPORT?
	BNE	GETX
	BISB	#FD.EF1,F.BKP1(R0) ;YES, SET THE EOF BIT FOR FUTURE
	TST	F.NRBD(R0)	;IS THERE DATA TOO?
	BEQ	GETX		;IF EQ NO, REPORT EOF
	MOV	#1,F.ERR(R0)	;INDICATE A SUCCESSFUL "GET"
;
GETX:	CALLR	..FCSX
EOFERR:	MOVB	#IE.EOF,F.ERR(R0) ;REPORT EOF
	BR	GETX		;AND EXIT


; GET THE NEXT RECORD FROM THE BLOCK BUFFER
GTBLK:
	.IF	EQ,R$$SEQ
	BITB	#FD.RAN,F.RACC(R0) ;RANDOM OR SEQUENTIAL
	BEQ	GTBKSQ		;BRANCH IF SEQUENTIAL
	CALL	..PSRG		;POSITION FOR THE RECORD
	BCS	GETX		;BRANCH IF ERROR (F.ERR SET)
	.IF GT,R$$ANI
	CALL	CHKBUF		;ERS CHECK FOR INVALID BUFFER
	.ENDC
	BR	GTBKS1
	.ENDC
;
; SEQUENTIAL GET FROM BLOCK BUFFER
GTBKSQ:
	.IF	GT,R$$ANI
	CALL	CHKBUF		;ERS CHECK FO INVALID BUFFER
	.ENDC
	CALL	..EFC1
	BCS	GETX		;BRANCH IF YES
GTBKS1:
	ADD	#1,F.RCNM+2(R0)	;INCREMENT THE RECORD # SO THAT
	ADC	F.RCNM(R0)	;NEXT RANDOM GET WILL GET THE NEXT ONE
	MOV	F.NREC(R0),R1
5$:	CMP	R1,F.EOBB(R0)	;IS CURRENT BUFFER EMPTY?
	BLO	20$		;BRANCH IF NO
10$:
	CALL	RDNXBK		;READ THE NEXT BLOCK
	BCS	GETX
20$:
	MOV	F.RSIZ(R0),R3	;R3=RECORD SIZE
	ASSUME	F.RTYP,0
	CMPB	#R.FIX,(R0)	;ASSUMING FIXED LENGTH RECORDS
	BEQ	80$		;BRANCH IF FIXED
;
; GET THE RECORD SIZE FROM THE FRONT OF THE RECORD.
; THE RECORD SIZE IN BYTES IS A 15 BIT BINARY VALUE STORED
; AS THE FIRST WORD (WORD ALIGNED) OF THE RECORD. THE
; SIZE DOES NOT INCLUDE THE 2 BYTE SIZE FIELD.
; BUT IT DOES INCLUDE THE SEQUENCE NUMBER FIELD IF PRESENT
; A SIZE OF -1 MEANS END OF BLOCK, AND ANY OTHER
; NEGATIVE VALUE IS ILLEGAL. FOR ANSI "D" RECORDS
; THE SIZE FIELD IS 4 BYTES OF ASCII DECIMAL. THIS
; SIZE INCLUDES THE 4 BYTE SIZE FIELD. THE CHARACTER
; "^" MEANS END OF BLOCK.
;
	.IF	GT,R$$ANI
	BITB	#CH.AND,F.CHR(R0) ;IF ANSII "D"
	BEQ	60$
	MOV	#4,R4		;PEEL OFF THE 4 BYTE SIZE FIELD
	CLR	R3
30$:	MOVB	(R1)+,R5	;CHECK THAT THE CHARACTER
	CMPB	R5,#'9		;ERS IS BETWEEN CHARACTERS 9 AND 0
	BLOS	50$
	CMPB	#'^,R5		;IF PAD CHARACTER
	BEQ	10$		;THEN GET NEXT BUFFER
40$:	MOVB	#IE.NNC,F.ERR(R0) ;ILLEGAL CHARACTER IN SIZE FIELD
	BR	GETX
50$:	SUB	#'0,R5
	BLT	40$
	.IF	GT,R$$EIS	;IF EIS IS AVAILABLE
	MUL	#10.,R3		;MULTIPLY BY 10. USING MUL
	.IFF
	ASL	R3		;
	ADD	R3,R5		;R5=2*R3+R5
	ASL	R3
	ASL	R3		;R3=8*R3
	.ENDC			;THEN R3=8*R3+2*R3+R5=10.*R3+R5
	ADD	R5,R3
	SOB	R4,30$
	SUB	#4,R3		;SUBTRACT OUT SIZE FIELD FROM REC SIZE
	BR	80$
	.ENDC
	.IF	GT,R$RSTS
	ASSUME	<R.VAR!R.SEQ>,3
	ASSUME	F.RTYP,0
60$:	BITB	#3,(R0)		;CHECK FOR STREAM ASCII OR BINARY
	BNE	65$		;BRANCH IF R.VAR OR R.SEQ
	ASSUME	F.RTYP,0
	CMPB	#R.STM,(R0)	;CHECK FOR STREAM ASCII
	BEQ	GETASC
63$:	CALL	GETBYT		;GET FIRST NON-NULL
	TSTB	(R1)+
	BEQ	63$
	CMPB	#1,-(R1)	;CHECK FOR FORMATTED BINARY
	BNE	GETASC		;IF FIRST BYTE NE 1 ASSUME ASCII
	INC	R1		;SKIP OVER THE 1
	CALL	GETBYT		;GET THE NEXT BYTE
	TSTB	(R1)+		;MUST BE 0
	BNE	170$		;ELSE RETURN AN ERROR
	CALL	GETBYT		;GET NEXT BYTE
	MOVB	(R1)+,R2	;AS LOW ORDER OF RECORD LENGTH
	CALL	GETBYT		;THEN THE NEXT ONE
	MOVB	(R1)+,R3	;GET HIGH ORDER OF LENGTH
	SWAB	R3		;...AND MAKE IT HIGH BYTE
	CLRB	R3		;MAKE READY THE LOW BYTE
	BISB	R2,R3		;...AND MOVE IN LOW ORDER LENGTH
	SUB	#4,R3		;SUBTRACT 4 FOR HEADER BYTES
	BR	80$
65$:	MOV	(R1)+,R3	; GET RECORD SIZE FIELD
	.IFF
60$:	MOV	(R1)+,R3	;GET RECORD SIZE FIELD
	.ENDC
	BGE	100$		;AND BRANCH IF IT'S REASONABLE
	INC	R3		;IF IT WAS -1 (END OF BLOCK)
	BEQ	10$		;THEN GO READ NEXT BLOCK
80$:	TST	R3		;SEE IF SIZE FIELD IS REASONABLE
	BLT	170$		;ERROR IF IT'S NEGATIVE
;
; R1=POINTER TO DATA IN BLOCK BUFFER
; R3=# BYTES OF DATA
; IF RECORDS MAY NOT CROSS BLOCKS, SEE IF IT DOES AND IS ILLEGAL
;
100$:	BITB	#CH.AND, F.CHR(R0)	; IF TAPE THEN
	BNE	101$			;   BR, REC. CANNOT CROSS
	BITB	#FD.BLK, F.RATT(R0)	; IF CAN CROSS THEN
	BEQ	200$			;   BR, 
101$:	CALL	CROSBK			; ELSE CALL CROSBK
	BLE	200$		;BRANCH IF IT DOESN'T CROSS
	ASSUME	F.RTYP,0
	CMPB	#R.FIX,(R0)	;IF FIXED LENGTH
	BNE	170$
	CMP	R3,F.VBSZ(R0)	;AND SIZE IS NOT LARGER THAN A BLOCK
	BLE	10$		;THEN GET RECORD FROM NEXT BLOCK
170$:	MOVB	#IE.RBG,F.ERR(R0) ;ILLEGAL RECORD SIZE
175$:	BR	GETX
	ASSUME	F.RTYP,0
200$:	CMPB	#R.FIX,(R0)	;FIXED/VARIABLE LENGTH RECORD?
	BNE	220$			;BRANCH IF VARIABLE LENGTH
	BITB	#CH.AND,F.CHR(R0)	;FIXED LENGTH RECORDS
	BEQ	220$			;BRANCH IF NOT ANSII "D"
	MOV	R3,R4			;COPY RECORD SIZE
	MOV	R1,R5			;COPY RECORD ADDRESS
;
; A FIXED LENGTH ANSI TAPE RECORD OF ALL PADS IS EFFECTIVELY A NULL RECORD;
; USE NEXT RECORD IN THIS CASE.
;
210$:	CMPB	#'^,(R5)+		;IS THE RECORD ALL PAD CHARACTERS?
	BNE	220$			;NO - CONTINUE
	SOB	R4,210$			;MAYBE- DECR THE COUNT AND TRY AGAIN
	MOV	R5,R1			;YES- RECORD IS ALL PADS - IGNORE IT
	BR	5$			;GO BACK AND SEE IF AT END OF BLOCK

;
; NOW GET THE SEQUENCE NUMBER OUT OF THE RECORD IF IT IS
; PRESENT
;
	ASSUME	F.RTYP,0
220$:	CMPB	#R.SEQ,(R0)	;IF RECORD HAS A SEQUENCE NUMBER
	BNE	240$
	MOV	R3,-(SP)	;SAVE THE BYTE COUNT
	MOV	R0,R2
	ADD	#F.SEQN,R2	;R2=ADDRESS TO STORE SEQUENCE #
	MOV	#2,R3		;R3 = # BYTES TO STORE
	SUB	R3,(SP)		;ADJUST REMAINING BYTE COUNT
	CALL	GTMVRC		;MOVE THE SEQUENCE # JUST LIKE A RECORD
	MOV	(SP)+,R3	;R3 = SIZE OF DATA PORTION OF RECORD
	BCS	175$		;EXIT IF ERROR
240$:	CALL	RETREC		;RETURN RECORD TO USER
				;ERRORS WILL BE CAUGHT BY ..FCSX LATER
;
; NOTE HERE THAT EVEN THOUGH C=0, F.ERR MAY BE SET TO IE.RBG
;
	.IF	GT,R$$ANI
	BITB	#CH.AND,F.CHR(R0) ;UNLESS ANSI "D" RECORDS
	BNE	260$
	.ENDC
	.IF	GT,R$RSTS
	ASSUME	<R.FIX!R.VAR!R.SEQ>,3 
	ASSUME	F.RTYP,0
	BITB	#3,(R0)		; CHECK FOR FORMATTED BINARY
	BNE	250$
	CALL	GETBYT		;IF SO GET NEXT BYTE IS CHECKSUM
	INC	R1		; SKIP PAST AND IGNORE IT!
	BR	260$
250$:
	.ENDC
	INC	R1		;ROUND NEXT RECORD ADDRESS UP
	BIC	#1,R1		;TO NEXT WORD BOUNDARY
260$:	MOV	R1,F.NREC(R0)	;STORE NEXT RECORD ADDRESS
	BR	175$
	.PAGE
;GET A RECORD FROM STREAM ASCII FILE
;FOR SIMPLICITY, THE RECORD IS ALWAYS MOVED
;NOT MUCH WOULD BE GAINED BY LOCATE MODE IN THIS CASE
;
	.IF	GT,R$RSTS
	.ENABL	LSB
GETASC:	MOV	F.URBD+2(R0),R2	;GET USER BUFFER ADDRESS
	MOV	R2,F.NRBD+2(R0)	;RECORD WILL BE PUT HERE
	MOV	F.URBD(R0),R3	;GET BUFFER SIZE FOR COUNTER
	MOV	R3,F.NRBD(R0)	;PRESET MAX RECORD SIZE
	CALL	SETCTR		;SET COUNTER FOR BYTES LEFT
	BITB	#FD.EF1,F.BKP1(R0) ;DELAYED EOF SET ?
	BNE	80$		;YES, WILL RETURN EOF
;
;MAIN LOOP FOR MOVING CHARACTERS TO USER BUFFER
;CHECKS FOR CTRL/Z, ESCAPE, LINE FEED, (W OR W/O PRECEEDING
;CARRIAGE RETURN), VERTICAL TAB AND FORM FEED
;-- FIRST STRIP OFF LEADING NULLS
;
	MOVB	#1,F.ERR(R0)	;INDICATE GOODNESS AT START
10$:	TSTB	(R1)+		;CHECK FOR LEADING NULLS
	BNE	20$		;NO MORE
	DEC	R5		;ONE LESS CHAR IN BUFFER
	BGT	10$		;MORE CHARS IN CURRENT BUFFER
	CALL	GETNXT		;NEED A BUFFER REFILL
	BR	10$		;CHECK NEXT CHARACTER
20$:	DEC	R1		;BACK UP A CHARACTER
;									;REG001
; Process the rest of the buffer.  If a character is a terminator,	;REG001
; take action as follows:						;REG001
;	Character, code		Action					;REG001
;									;REG001
;	ESC, 33			Transfer it to output buffer and exit	;REG001
;	CR,  15			<CR><LF> - Exit without transfer	;REG001
;				<CR><NUL>- Skip both and continue	;REG001
;				<CR> - Transfer normally and continue	;REG001
;	LF,  12			Transfer and exit			;REG001
;	VT,  13			Transfer and exit			;REG001
;	FF,  14			Transfer and exit			;REG001
;									;REG001
; If the output buffer gets full, then input buffer processing		;REG001
; continues normally except that data is not transferred to the output	;REG001
; buffer.  That allows us to take appropriate action with terminators	;REG001
;									;REG001
25$:	MOVB	(R1)+,R4	; Copy the next character for testing	;REG001
	DEC	R5		; Count down the input buffer		;REG001
	CMPB	#33,R4		; Is this bigger than <ESC> ?		;REG001
	BLT	50$		; Yes, transfer it normally		;REG001
	CMPB	#15,R4		; Is this a <CR> ?			;REG001
	BNE	45$		; No, then do the next check		;REG001
	TST	R5		; Any input left ?			;REG001
	BNE	30$		; Yes, proceed				;REG001
	MOV	R4,-(SP)	; SAVE R4				;REG001
	CALL	GETNXT		; No, go get some more			;REG001
	MOV	(SP)+,R4	; BRING IT BACK				;REG001
30$:	TSTB	(R1)		; Is next char a <NUL> ?		;REG001
	BNE	35$		; No, next test				;REG001
	CMP	R2,F.URBD(R0)	; Is <CR><NUL> first on new line ?	;REG001
	BNE	40$		; No, output them normally		;REG001
	TSTB	(R1)+		; Yes, skip <CR><NUL>			;REG001
	DEC	R5		; Count down input buffer		;REG001
	BR	60$		; Do some more				;REG001
35$:	CMPB	#12,(R1)	; Is next char a <LF> ?			;REG001
	BNE	40$		; No, treat <CR> as any other character	;REG001
	TSTB	(R1)+		; Step past the <LF>			;REG001
	DEC	R5		; and reduce the input buffer count	;REG001
	BR	100$		; Exit, don't transfer <CR><LF>		;REG001
40$:	DEC	R3		; More room in buffer ?			;REG001
	BLT	60$		; No, don't do the transfer		;REG001
	MOVB	R4,(R2)+	; Yes, send <CR> to the output buffer	;REG001
	BR	60$		; Go do some more			;REG001

45$:	CMPB	#33,R4		; Is this an <ESC> ?			;REG001
	BEQ	90$		; Yes, exit with transfer		;REG001
	CMPB	#32,R4		; Is this a CTRL-Z ?			;REG001
	BEQ	70$		; Yes, deal with it.			;REG001
	CMPB	#14,R4		; Is this a <FF> or below ?		;REG001
	BLT	50$		; No, transfer it normally		;REG001
	CMPB	#12,R4		; Yes, then is it <LF>, <VT> or <FF> ?	;REG001
	BLE	90$		; Yes, then exit with transfer		;REG001
50$:	DEC	R3		; More room in buffer ?			;REG001
	BLT	60$		; No, don't do the transfer		;REG001
	MOVB	R4,(R2)+	; Yes, send char to the output buffer	;REG001
60$:	TST	R5		; Anything left in input buffer ?	;REG001
	BGT	25$		; Yes, process it			;REG001
	CALL	GETNXT		; Go get some more input		;REG001
	BR	25$		; And process it			;REG001
;									;REG001
; CTRL-Z, set error and exit						;REG001
;									;REG001
70$:	CMP	R2,F.URBD(R0)	; Was CTRL-Z the only char input ?	;REG001
	BNE	DLYEOF		;NO, GO SET UP DELAYED EOF		;REG001
80$:	MOVB	#IE.EOF,F.ERR(R0) ;YES, INDICATE AN EOF ERROR		;REG001
	BR	100$		;AND EXIT				;REG001
;									;REG001
DLYEOF:	BISB	#FD.EF1,F.BKP1(R0) ;SET UP DELAYED EOF			;REG001
	BR	100$		;AND EXIT				;REG001
;									;REG001
; Transfer terminator character and exit				;REG001
;									;REG001
90$:	DEC	R3		; More room in the output buffer ?	;REG001
	BLT	100$		; No, don't do the transfer		;REG001
	MOVB	R4,(R2)+	; Yes, transfer char to output buffer	;REG001
100$:	TST	R3		;MORE ROOM IN BUFFER ?				;LEB001
	BLT	110$		;NO - NO CORRECTION NECESSARY			;LEB001
	SUB	R3,F.NRBD(R0)	;CORRECT OUR CHAR COUNT				;LEB001
110$:	MOV	R1,F.NREC(R0)	;STORE NEXT RECORD ADDRESS			;LEB001
	TST	R3		; Did we overflow buffer ?		;REG001
	BGE	115$		; No, don't indicate too-big error	;REG001
	MOV	#IE.RBG,F.ERR(R0); Yes, set too-big error		;REG001
115$:	CMP	F.NRBD(R0),F.RSIZ(R0);IF THIS RECORD IS BIGGER			;LEB001
	BLE	GETXIT		;THAN PREVIOUS BIGGEST
	MOV	F.NRBD(R0),F.RSIZ(R0);THEN UPDATE THE RECORD SIZE
	.DSABL	LSB
GETXIT:	CALLR	..FCSX		;EXIT
;
;GETBYT:	GET NEXT BYTE IN FILE
;GETNXT:	GET NEXT BLOCK IN FILE
;SETCTR:	SET COUNTER FOR BYTES LEFT IN BUFFER
;
GETBYT:	CMP	R1,F.EOBB(R0)	;CHECK FOR END OF BUFFER
	BHIS	10$		;IF SO READ NEXT BLOCK
	RETURN			;ELSE RETURN TO CALLER
10$:	MOV	F.NRBD(R0),R3	;ENSURE THESE WILL BE EQUAL
GETNXT:	MOV	R2,-(SP)	;SAVE DESTINATION POINTER
	CALL	RDNXBK		;READ NEXT BLOCK
	MOV	(SP)+,R2	;RESTORE DESTINATION POINTER
	BCC	SETCTR		;IF NO ERROR GO SET COUNTER
	TST	(SP)+		;ELSE POP RETURN ADDRESS
	CMPB	#IE.EOF,F.ERR(R0) ;ERROR END OF FILE ?
	BNE	GETXIT		;NO, EXIT
	CMP	R3,F.NRBD(R0)	;ANYTHING IN OUTPUT BUFFER YET?
	BEQ	GETXIT		;NO, EXIT
	MOVB	#1,F.ERR(R0)	;YES, POST GOOD GET THIS TIME
	BR	DLYEOF		;AND SET DELAYED EOF
SETCTR:	MOV	F.EOBB(R0),R5	;GET END OF BUFFER
	SUB	R1,R5		;CALCULATE BYTES LEFT IN BUFFER
	BLOS	GETNXT		;MAKE SURE IT IS GT 0
	RETURN
	.ENDC


;
; RETURN RECORD DATA AND INFORMATION
;
; CORRECTLY HANDLES PARTIAL LOCATE MODE.  IF THE RECORD
; MUST BE MOVED AND IT WILL NOT FIT IN THE USER BUFFER,
; THIS ROUTINE RETURNS AS MUCH AS WILL FIT IN THE USER
; BUFFER WITH C=0 AND F.ERR = IE.RBG.  ALSO EVEN IF THE
; RECORD IS TOO BIG, THE NEXT RECORD POINTER IS CORRECTLY
; SET UP FOR THE NEXT GET.
;
; INPUTS
;	R1=ADDRESS IN BUFFER OF DATA
;	R3=# OF BYTES
;
; OUTPUTS:
;	C=0 IF OK, EVEN IF ONLY PART OF RECORD FIT IN USER BUFFER
;	C=1 IF ERR F.ERR SET
;	R1=POINTER TO NEXT BYTE IN INPUT BUFFER
;	R2-R5 ALTERED
RETREC:
	BITB	#FD.PLC,F.RACC(R0) ;IF PARTIAL LOCATE MODE
	BEQ	10$
										; GK003
	.IF GT	R$$BBF		;IF BIG-BUFFERED FCS				; GK003
										; GK003
	BITB	#FD.SQD!FD.REC,F.RCTL(R0) ;IS THIS A SEQ OR RECORD DEVICE?	; SR019
	BNE	6$		;YES - F.EOBB IS OK - AVOID BIG BUF CODE	; SR019
	MOV	F.BDB(R0),R2	;PICK UP POINTER TO BDB				; GK003
	ADD	#S.BFHD,R2	;POINT IT AT START OF BUFFER			; GK003
	MOV	R1,R5		;CALCULATE LBA+1 OF RECORD IN R5		; GK003
	ADD	R3,R5		;...						; GK003
	ADD	F.VBSZ(R0),R5	;ADD VBN SIZE - 1 TO ROUND UP TO NXT BLK	; GK003
	DEC	R5		;...						; GK003
	SUB	R2,R5		;FIND NO. OF BYTES NEEDED IN BUFFER TO		; GK003
				;..ALLOW ENTIRE RECORD TO FIT IN CORE		; GK003
	CLR	R4		;NOW, CONVERT THAT TO A VBN COUNT:		; GK003
										; GK003
	 .IF GT	R$$EIS		;IF EIS						; GK003
										; GK003
	DIV	F.VBSZ(R0),R4	;DIVIDE BY BLOCK SIZE				; GK003
										; GK003
	 .IFF			;IF NO EIS, DO IT THE HARD WAY			; GK003
										; GK003
1$:	SUB	F.VBSZ(R0),R5	;WILL ANOTHER VBN FIT?				; GK003
	BLO	2$		;IF LO NO, WE'RE DONE
	INC	R4		;ELSE INCREMENT VBN COUNT			; GK003
	BR	1$		;AND LOOP					; GK003
2$:										; GK003
										; GK003
	 .ENDC									; GK003
										; GK003
	CMPB	R4,F.BGBC(R0)	;ARE THERE THAT MANY BLOCKS IN BFR?		; GK003
	BGT	10$		;IF GT NO, JUST COPY RECORD TO USER		; GK003
										; GK003
	 .IF GT	R$$EIS		;IF EIS						; GK003
										; GK003
	MOV	R4,R5		;SAVE VBN COUNT FOR LATER			; GK003
	MUL	F.VBSZ(R0),R5	;FIND NO. OF BYTES FROM BFR STRT TO EOB		; GK003
										; GK003
	 .IFF			;IF NOT EIS					; GK003
										; GK003
	CLR	R5		;THIS WILL BE BYTES IN BUFFER			; GK003
	MOV	R4,-(SP)	;SAVE VBN COUNT FOR LATER			; GK003
3$:	ADD	F.VBSZ(R0),R5	;ADD A VBN TO BYTE COUNT			; GK003
	DEC	R4		;COUNT BLOCKS					; GK003
	BGT	3$		;LOOP UNTIL ALL HAVE BEEN COUNTED		; GK003
	MOV	(SP)+,R4	;RECOVER VBN COUNT				; GK003
										; GK003
	 .ENDC									; GK003
										; GK003
	ADD	R2,R5		;POINT R2 AT END OF FINAL VBN OF RECORD		; GK003
	MOV	R5,F.EOBB(R0)	;..AND USE THAT TO SET UP F.EOBB		; GK003
	DEC	R4		;NOW ADD R4 (VBN COUNT) TO B.VBN (VBN OF	; GK003
	ADD	B.VBN+2-S.BFHD(R2),R4 ;..1ST BLOCK IN BUFFER) TO GET		; GK003
	MOV	R4,F.VBN+2(R0)	;..F.VBN (VBN OF CURRENT BLOCK AFTER		; GK003
	MOV	B.VBN-S.BFHD(R2),F.VBN(R0) ;..CURRENT RECORD IS RETURNED	; GK003
	ADC	F.VBN(R0)	;..TO THE USER.					; GK003
	CALL	..SEFB		;SINCE F.VBN IS ALTERED, WE MUST CHECK IF IT
				;IS THE EOF BLOCK (NORMALLY DONE IN RDWAIT).
										; GK003
	.IFF			;IF NOT BIG BUFFERS				; GK003
										; GK003
	CALL	CROSBK		;AND RECORD DOES NOT CROSS BLOCKS
	BGT	10$
										; GK003
	.ENDC									; GK003
										; GK003
6$:				;						; SR019
	.IF	GT,R$RSTS
	BLT	7$		;AND RECORD DOES NOT
	ASSUME	F.RTYP,0
	TSTB	(R0)		;FILE HAS NO ATTRIBUTES
	BEQ	10$
7$:	BIT	R1,#1		;ODD STARTING ADDRESS?
	BNE	10$		;YES BETTER MOVE IT
	.ENDC
	MOV	R3,F.NRBD(R0)	;RETURN RECORD SIZE
	MOV	R1,F.NRBD+2(R0)	;AND ADDRESS
	BR	50$
10$:	MOV	F.URBD+2(R0),R2	;OTHERWISE MOVE THE RECORD
	MOV	R2,F.NRBD+2(R0)	;RECORD WILL BE IN USER BUFFER
	MOV	F.URBD(R0),R4
	MOV	R3,-(SP)
	CMP	R3,R4		;DOES RECORD FIT IN USER BUFFER?
	BLOS	20$		;IF LOS YES
	MOV	R4,R3		;NO MOVE WHAT WILL FIT
20$:	MOV	R3,F.NRBD(R0)	;RETURN NO. OF BYTES TO USER
	SUB	R3,(SP)
	CALL	GTMVRC
	MOV	(SP)+,R3
	BLOS	60$		;BRANCH IF C=1 FROM GTMVRC
				;OR IF Z=1 (R3=0, ENTIRE RECORD MOVED)
30$:	CALL	CROSBK		;END OF THIS RECORD IN THIS BLOCK?
	BLE	40$		;BRANCH IF YES
	SUB	R4,R3
	CALL	RDNXBK		;READ AND THROWAWAY THE BLOCKS
	BCC	30$		;BRANCH IF NO ERROR
	BR	60$		;REPORT ERROR FROM RDNXBK
40$:	MOVB	#IE.RBG,F.ERR(R0) ;RETURN C=0 FOR THIS CASE
50$:	ADD	R3,R1		;POINT R1 TO END OF RECORD (C=0)
60$:	RETURN


; READ THE NEXT DATA BLOCK
; INPUT:
;	R0=FDB
; OUTPUTS C=0 IF OK, C=1 IF ERROR F.ERR SET
;	R3 PRESERVED
;	R1-POINTS TO BEGINING OF BUFFER IF C=0
;	R2,R4-R5 ALTERED
RDNXBK:
	.IF	EQ,R$$SEQ
	MOV	R3,-(SP)
	CALL	..RDRN		;READ NEXT BLOCK, WRITE THIS ONE IF DIRTY
	.IFF
	BITB	#FD.WRT,F.BKP1(R0) ;IF THIS BLOCK IS DIRTY
	BEQ	10$
	CALLR	..SQER		;THEN ILLEGAL SEQUENTIAL OPERATION
10$:	MOV	R3,-(SP)	;PRESERVE R3
	CALL	..RWAT		;OTHERWISE READ THE NEXT BLOCK
	.ENDC
	MOV	(SP)+,R3	;RESTORE R3
	MOV	F.NREC(R0),R1	;POINT R1 TO THE BEGINNING OF THE BUFFER
	RETURN
;
; MOVE RECORD FROM SOURCE TO DESTINATION POTENTIALLY CROSSING
;	SOURCE BLOCKS
; INPUT:
;	R1=SOURCE ADDRESS
;	R2=DESTINATION ADDRESS
;	R3=# BYTES TO MOVE
; OUTPUT: C=0 IF OK, C=1 IF ERR F.ERR SET
;	R1=UPDATED SOURCE POINTER
;	R2=UPDATED DESTINATION POINTER
;	R3-R5 ALTERED
GTMVRC:	MOV	R3,-(SP)	;SAVE # OF BYTES TO MOVE
10$:	MOV	F.EOBB(R0),R3
	SUB	R1,R3		;CALCULATE # OF BYTES LEFT IN BUFFER
	CMP	(SP),R3		;MOVE THE SMALLER OF
	BGE	20$		;WHAT IS LEFT IN BUFFER
	MOV	(SP),R3		;AND WHAT IS LEFT TO MOVE
20$:	SUB	R3,(SP)
	CALL	..MVR1
	TST	(SP)
	BEQ	30$		;RETURN IF DONE C=0
	MOV	R2,-(SP)
	CALL	RDNXBK		;OTHERWISE READ THE NEXT BLOCK
	MOV	(SP)+,R2
	BCC	10$		;AND GO MOVE SOME MORE
30$:	INC	(SP)+		;CLEAN STACK, PRESERVE CARRY
	RETURN
;
; DOES THIS PIECE OF A RECORD CROSS THE BLOCK
;
; INPUT R1=ADDRESS OF THIS PORTION IN BLOCK BUFFER
;	R3=# BYTES IN THIS PORTION OF RECORD
; OUTPUT: R0-R3,R5 PRESERVED
;	R4=SPACE LEFT IN THIS BUFFER
;	CONDITION CODES
;		LE-MEANS IT FITS
;		GT-MEANS IT CROSSES
CROSBK:
	MOV	F.EOBB(R0),R4
	SUB	R1,R4
	CMP	R3,R4
	RETURN
;
; THIS ROUTINE CHECKS FOR AN INVALID BUFFER AND FORCES
; A READ OF THE VBN IF NECESSARY
;
	.IF	GT,R$$ANI
CHKBUF:
	BITB	#FD.INV,F.BKP1(R0)	;ERS INVALID BUFFER
	BEQ	10$			;ERS NO
	DEC	F.VBN+2(R0)		;ERS YES SET UP VBN FOR READ
	MOV	#37777,F.EFBK(R0)	;ERS RESET EOF TO APPRORIATE VALUE
	MOV	F.NREC(R0),F.EOBB(R0)	;ERS FORCE EMPTY BUFFER
	BICB	#FD.INV!FD.EFB,F.BKP1(R0)  ;ERS TURN OFF INVALID AND EOF BITS
10$:	RETURN
	.ENDC
;
;
	$END	GET
;
;
	.END
