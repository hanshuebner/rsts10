	$BEGIN	ASSLUN,<28.3>,<ASSIGN LOGICAL UNIT TO DEVICE>
; 
; THIS  SOFTWARE  IS FURNISHED UNDER A LICENSE AND MAY
; BE USED OR COPIED ONLY IN ACCORDANCE WITH THE  TERMS
; OF SUCH LICENSE.
;  
; COPYRIGHT (c) 1982, 1987, 1991 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
; 
; PETER H. LIPMAN 17-AUG-73
;
; PREVIOUSLY MODIFIED BY
;
;	M. GONSALVES
;	SHAO-SUN CHIEN
;	E. MARISON
;	P. H. LIPMAN
;	ELLEN SIMICH
;	E. MARISON
;	S. RUZICH
;
; MODIFIED FOR RSX-11M-PLUS V4.0 BY:
;
;	P. K. M. WEISS	12-JUN-87	28.2
;		PKW131 - SET FL.VCP BIT BY CHECKING GF.VCP IN GLUN FLAG BYTE
;		       - MOVE CHRLUN INLINE
;
; MODIFIED FOR RSTS V10.1 BY:
;
;	S. LeVan	21-May-91	28.3
;		SEL001 - Merge RSTS-specific code into RSX V4.3 of this module.
;
;
;
.PAGE
;+ ASSLUN - ASSIGN LUN AND FILL IN FDB
;
; THE LUN IS ASSIGNED, AND APPROPRIATE FIELDS ARE FILLED IN IN THE FDB.  IF
; NO DEVICE IS SPECIFIED, JUST A GLUN$ IS DONE.  IF THE GLUN FAILS, THE LUN IS
; ASSIGNED TO SY:
;
; INPUTS: 
;
;	R0=FDB
;	R1=FNB
;
; OUTPUTS:
;
; LUN ASSIGNED, FDB FIELDS FILLED IN.
;
; R0,R1 UNCHANGED, R2-R5 DESTROYED
;-
.ASLUN::.SAVR1				;SAVE REGISTERS
..ALUN::
	MOV	N.UNIT(R1),R2		;R2=UNIT NUMBER
	MOV	N.DVNM(R1),R3		;R3=DEVICE NAME
	BEQ	20$			;BRANCH IF DEFAULT DEVICE
10$:	MOVB	F.LUN(R0),R4
	ALUN$S	R4,R3,R2		;LUN, DEVICE NAME, UNIT
	BCS	70$			;BRANCH IF ERROR
20$:	MOV	@#.FSRPT,R5		; FCS ALLOCATION LISTHEAD ADDRESS
	BNE	30$			; BRANCH IF .FSRPT IS INITIALIZED
	MOVB	#IE.NBF,F.ERR(R0)	; USER FORGOT FSRSZ$ - NO BUF SPACE
	BR	90$			; RETURN C=0 - ERROR WILL BE DETECTED 
					; WHEN ROUTINE EXITS THROUGH ..FCSX
30$:	ADD	#A.DPB,R5		; POINT TO SCRATCH DPB AREA
	MOVB	F.LUN(R0),R2
	GLUN$S	R2,R5			; GET LUN INFORMATION
	BCC	40$

	.IF	EQ,R$RSTS
	MOV	#SYUNIT,R2	;ASSIGN LUN TO DEFAULT DEVICE
	.IFF
	MOV	#-1,R2		;NO UNIT FOR "SY:"
	.ENDC

	MOV	#SYDEV,R3
	BR	10$		;RETRY THE LUN ASSIGNMENT

40$:	MOV	(R5)+,N.DVNM(R1)	;STORE DEVICE NAME IN FNB
	.IF	EQ,R$RSTS		;SEL001 - not for RSTS
	MOVB	(R5)+,N.UNIT(R1)	;STORE UNIT NUMBER IN FNB
	CLRB	N.UNIT+1(R1)		;MAKE SURE HIGH BYTE IS CLEAR
	BITB	#GF.VCP,(R5)+		;DEVICE USING VMS ACP?
	BEQ	50$			;IF EQ NO
	BISB	#FL.VCP,F.FLG(R0)	;MARK AS USING VMS ACP
	.IFF				;SEL001 - RSTS code path
	MOVB	(R5)+,R2		;SEL001 - Extend sign when unit = -1
	MOV	R2,N.UNIT(R1)		;SEL001 - Store unit number in FNB
	TSTB	(R5)+			;SEL001 - Make sure R5 is popped!
	.ENDC	;R$RSTS

50$:	MOVB	(R5),F.RCTL(R0)		;INIT CONTROL BYTES
	MOVB	(R5)+,R2		;SET R2 TO TEST FOR ANSI TAPE
	TSTB	(R5)+			;IS THE DEVICE MOUNTABLE?
	BGE	60$			;BR IF DEVICE NOT MOUNTABLE
	BISB	#FD.MNT,F.MBFG(R0)	;NOTE DEVICE IS MOUNTABLE
60$:	MOV	4(R5),F.VBSZ(R0)	;SIZE OF VIRTUAL BLOCKS
	MOV	4(R5),F.BBFS(R0)	;BLOCK BUFFER SIZE, TOO
70$:	MOV	@#$DSW,F.ERR(R0)	;GET SUCCESS/ERROR CODE
	BCS	90$			;IF ERROR, EXIT

	.IF	EQ,R$RSTS
	.IF	GT,R$$ANI
	CLRB	F.CHR(R0)		;ASSUME NOT ANSI TAPE
	.ENDC				;R$$ANI
;
; DETERMINE IS DEVICE IS ANSI TAPE: (FD.SQD AND FD.SDI) = ANSI TAPE
;
; 1) ANSI FCS, MOUNTED ANSI TAPE:      SET CH.AND BIT IN F.CHR TO NOTE THIS.
; 2) ANSI FCS, UNMOUNTED TAPE:         TREAT DEVICE AS RECORD-ORIENTED.
; 3) NON-ANSI FCS, MOUNTED ANSI TAPE:  RETURN PRIVILEGE VIOLATION.
; 4) NON-ANSI FCS, UNMOUNTED TAPE:     TREAT DEVICE AS RECORD-ORIENTED.
;
	BIC	#^C<FD.SQD!FD.SDI>,R2	; CLEAR ALL BUT SEQUENTIAL AND SDI BITS
	CMP	#FD.SQD!FD.SDI,R2	; ARE BOTH BITS SET?
	BNE	90$			; NO - CANNOT BE ANSI TAPE - RETURN

	.IF	GT,R$$ANI
	BISB	#CH.AND,F.CHR(R0)	; SET ANSI RECORD FORMAT BIT
	.IFF				; NON-ANSI FCS
	MOVB	#IE.PRI,F.ERR(R0)	; ANSI VOLUME - VERBOTEN
	.ENDC				; R$$ANI
	.ENDC				; R$RSTS

90$:	CALLR	..FCSX			; SET CARRY APPROPRIATELY AND RETURN

	$END	ASSLUN
;
;
	.END
