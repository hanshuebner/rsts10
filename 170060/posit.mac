	$BEGIN	POSIT,<28.12>,<CALCULATE FILE POSITION>
; 
; THIS  SOFTWARE  IS FURNISHED UNDER A LICENSE AND MAY
; BE USED OR COPIED ONLY IN ACCORDANCE WITH THE  TERMS
; OF SUCH LICENSE.
;  
; COPYRIGHT (c) 1982, 1986, 1991 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
; 
; PETER H. LIPMAN 11-AUG-73
;
; PREVIOUSLY MODIFIED BY
;
;	LONI BROWN
;
; Last Modification Date :  29-JAN-86
; Modified for RSX-11M-PLUS Update C by :
;
; Todd Schoeller	28.11
;		TMS029 -- Make room in REST segment for csi changes.
;
; Last Modification Date :  21-Oct-1991
; Modified for RSTS/E V10.1 by:
;
; S. LeVan		28.12
;		SEL001 -- Shrink code by assuming F.RTYP=0
;
;+
; POSIT ALGORITHM

; CALCULATE  RCNM*RSIZ  IN TRIPLE PRECISION
;   THEN DIVIDE BY BLKSZ
;
; RH = HIGH ORDER RECNUM
; RL = LOW ORDER RECNUM
; BS = BLOCK SIZE
; RS = RECORD SIZE
;
;
; RS*RH = P1,P2
; RS*RL = P3,P4
; P2+P3 = P5
; C(P2+P3)+P1 = P6
; PRODUCT = P6,P5,P4
;
; P6 GREATER OR EQUAL BS  THEN ERROR
;
; (P6,P5)/BS = D2,L2
;
; (L2,P4)/BS = D3,L3
;
;
; D2,D3 = VBN
; L3 = BYTE NO.
;-
;
.POSIT::CALL	.SUCSS		;INDICATE SUCCESS AT START
	MOV	R4,-(SP)
	MOV	R5,-(SP)
	CALL	..PSIT
	MOV	(SP)+,R5
	MOV	(SP)+,R4
	RETURN
;

	.IF	EQ,R$$EIS

..PSIT::MOV	R0,R5		; SAVE AWAY FDB POINTER
	MOV	F.RSIZ(R5),R4	; GET RECORD SIZE
	INC	R4		; ROUND UP TO NEXT WORD
	BIC	#1,R4
	MOV	R4,R0		; AND MAKE A COPY
	BITB	#FD.BLK,F.RATT(R5) ;CAN RECORDS CROSS BLOCK BOUDARIES?
	BNE	70$		;BRANCH IF NO

; COMPUTE RECORD POINTER FOR NORMAL CASE.

	MOV	F.RCNM(R5),-(SP) ; GET HIGH ORDER RECORD NUMBER
	MOV	F.RCNM+2(R5),R3	; GET LOW ORDER RECORD NUMBER
	SUB	#1,R3		; RECORD NUMBERS START AT 1
	SBC	(SP)
	BLT	50$		; RECORD NUMBER MUST BE 31 BITS, NON-ZERO
	CLR	R2		; CLEAR HIGH ORDER MULTIPLICAND
	CALL	$DMUL		; COMPUTE LOW ORDER PRODUCT (P3,P4)

	MOV	(SP)+,R3	; GET HIGH ORDER RECORD NUMBER AGAIN
	BNE	10$		; UNLESS ZERO, PROCEED WITH REST OF MULTIPLY
	MOV	R1,R2		; MOVE PRODUCT INTO POSITION FOR DIVIDE
	MOV	R0,R1
	CLR	R4		; CLEAR HIGH ORDER QUOTIENT
	BR	20$		; AND GO RIGHT TO LOW ORDER DIVIDE

10$:	MOV	R1,-(SP)	; SAVE P4
	MOV	R0,-(SP)	; SAVE P3
	CLR	R2
	MOV	R4,R0		; GET RECORD SIZE AGAIN
	CALL	$DMUL		; COMPUTE HIGH ORDER PRODUCT (P1,P2)

	MOV	R1,R2		; MOV PRODUCT INTO POSITION FOR DIVIDE
	MOV	R0,R1
	ADD	(SP)+,R2	; COMPUTE P5
	ADC	R1		; AND P6
	MOV	F.VBSZ(R5),R0	; GET DIVISOR (BLOCK SIZE)
	CALL	$DDIV		; COMPUTE (D2,L2)

	TST	R1		; TEST HIGH ORDER QUOTIENT
	BNE	50$		; THREE WORDS OF VBN IS TOO MUCH!

	MOV	R0,R1		; GET REMAINDER FOR NEXT DIVIDE
	MOV	R2,R4		; SAVE AWAY REST OF QUOTIENT
	MOV	(SP)+,R2	; GET P4 (REMEMBER P4?)
20$:	MOV	F.VBSZ(R5),R0	; AND THE DIVISOR (BS)
	CALL	$DDIV		; AND COMPUTE (D3,L3)
	ADD	R4,R1		; PUT BACK HIGH ORDER VBN (D2)
	MOV	R0,R3		; AND GET REMAINDER FOR BYTE NO.

60$:	MOV	R5,R0		; RESTORE THE FDB ADDRESS
	ADD	#1,R2		; FIX VBN TO START WITH 1
	ADC	R1
	RETURN

; THIS LEG OF CODE DOES THE COMPUTATION FOR RECORDS WHICH DO NOT CROSS
; BLOCK BOUNDARIES.

70$:	CLR	R1		; CLEAR HIGH ORDER DIVIDEND
	MOV	F.VBSZ(R5),R2	; GET BLOCK SIZE
	CALL	$DDIV		; COMPUTE NUMBER OF RECORDS PER BLOCK
	MOV	R2,R0		; AND MOVE TO DIVISOR

	MOV	F.RCNM(R5),R1	; GET HIGH ORDER RECORD NUMBER
	MOV	F.RCNM+2(R5),R2 ; GET LOW ORDER RECORD NUMBER
	SUB	#1,R2		; FIX #1 RECORD BIAS
	SBC	R1
	BLT	45$		; RECORD NUMBER MUST BE 31 BITS, NON-ZERO
	CALL	$DDIV		; AND COMPUTE THE BLOCK NUMBER
	MOV	R2,-(SP)	; SAVE THE RESULT
	MOV	R1,-(SP)
	CLR	R1
	MOV	R4,R3		; GET RECORD SIZE
	CALL	$DMUL		; AND COMPUTE BYTE OFFSET
	MOV	R1,R3		; POSITION FOR RETURN
	MOV	(SP)+,R1	; RECOVER VBN
	MOV	(SP)+,R2
	BR	60$		; AND USE COMMON EXIT

; ERROR RETURNS FOR BAD RECORD NUMBERS

50$:	TST	(SP)+		; CLEAN OFF THE STACK
45$:	MOV	R5,R0		; FIX FDB POINTER
	MOVB	#IE.RCN,F.ERR(R0) ; SET ERROR CODE
	SEC
	RETURN


	.IFF

..PSIT::MOV	F.RSIZ(R0),R1
	.IF	GT,R$RSTS
	;TSTB	F.RTYP(R0)	;CHECK FOR ATTRIBUTES
	TSTB	(R0)		;CHECK FOR ATTRIBUTES; SEL001
	ASSUME	F.RTYP,0	;SEL001	
	BNE	1$
	ADD	#5,R1		;IF NONE ASSUME 5 EXTRA BYTES
	BR	2$
1$:
	.IFTF
	INC	R1
	BIC	#1,R1
	.IFT
2$:
	.ENDC
	BITB	#FD.BLK,F.RATT(R0) ;CAN RECORDS CROSS BLOCK BOUDARIES?
	BNE	70$		;BRANCH IF NO
	TST	F.RCNM(R0)
	BNE	10$		;IF DBL PRECISION, NEED FULL CALCULATION
	MOV	F.RCNM+2(R0),R2
	BLE	5$		;IF NEG, NEED DBL PRECISION, 0 ILLEGAL
	DEC	R2
	MUL	R1,R2
	DIV	F.VBSZ(R0),R2
	BVS	15$		;V BIT INDICATES NEED FOR DBL PRECISION
	CLR	R1
	BR	30$
5$:	BEQ	50$		;RECORD NOS. START AT 1
	BR	15$
10$:	BLT	50$		;MAX OF 31 BIT RECORD NO.
15$:	MOV	F.RCNM+2(R0),-(SP)
	MOV	F.RCNM(R0),-(SP)
	SUB	#1,2(SP)
	SBC	@SP
	MOV	@SP,R2		;RH
	MUL	R1,R2		;P1,P2
	MOV	R2,@SP		;P1
	MOV	R3,-(SP)	;P2
	MOV	4(SP),R2	;R2=RL
	CLR	-(SP)		;ZERO THE CARRY BIT TOO
	ROR	R2		;DIVIDE BY 2
	ADC	@SP		;SAVE CARRY
	MUL	R1,R2		;MUL BY RECSIZ
	ASHC	#1,R2		;MUL BY 2
	TST	(SP)+		;IF IT WAS ODD
	BEQ	20$
	ADD	R1,R3		;ADD BACK IN THE MULTIPLIER
	ADC	R2
20$:				;AT LAST, R2,R3 =P3,P4
	ADD	R2,@SP		;P5=P2+P3
	ADC	2(SP)		;P6=P1+C
	MOV	R3,4(SP)
;0(SP)=P5, 2(SP)=P6, 4(SP)=P4

	MOV	2(SP),R2
	MOV	F.VBSZ(R0),R1
	MOV	@SP,R3
	DIV	R1,R2		;D2,L2
	BVS	45$		;BLOCK NO MUST FIT IN 31 BITS
	MOV	R2,@SP		;D2
	MOV	R3,R2
	MOV	4(SP),R3	;FORM L2,P4
	DIV	R1,R2		;D3,L3
	BVC	25$
; V BIT SET MEANS RESULT WILL HAVE SIGN BIT SET
	MOV	R1,R4
	CLR	R5
	ASHC	#-1,R4
	SUB	R4,R2		;SUBTRACT 100000*R1 FROM DIVIDEND
	BCS	45$
	SUB	R5,R3
	SBC	R2
	BCS	45$
	DIV	R1,R2
	BVS	45$		;V BIT SHOULN'T BE SET THIS TIME
	BIS	#100000,R2	;FIX THE RESULT
25$:	MOV	@SP,R1		;R1=HVBN, R2=LVBN, R3=BYTE
	ADD	#6,SP

30$:	ADD	#1,R2		;INCREMENT VBN SINCE START AT 1
	ADC	R1		;C IS CLEARED
	RETURN

45$:	ADD	#6,SP
50$:	MOVB	#IE.RCN,F.ERR(R0)
	SEC
	RETURN
;
; RECORDS ARE BLOCK ALLIGNED
70$:	CLR	R4
	MOV	F.VBSZ(R0),R5
	DIV	R1,R4		;R4=NO. OF RECORDS PER BLOCK
	MOV	F.RCNM+2(R0),R3
	MOV	F.RCNM(R0),R2
	SUB	#1,R3
	SBC	R2
	BCS	50$		;BRANCH IF RECNUM WAS 0
	BNE	80$		;BRANCH IF DOUBLE PRECISION
	DIV	R4,R2		;R2=BLOCK NO (BASE 0),
				;R3= NO OF RECORDS IN THAT BLOCK
	MUL	R1,R3		;R3=NO. OF BYTES IN THAT BLOCK
	CLR	R1
	BR	30$
;
; DOUBLE PRECISION BLOCK ALLIGNED
80$:	BLT	50$		;31 BIT RECORD NUMBERS
	ASHC	#1,R2
	MOV	R2,R5
	MOV	R4,-(SP)
	CLR	R4
	DIV	@SP,R4		;HIGH BIT *2/NREC PER BLOCK
	MOV	R5,R2		;USE REMAINDER AS NEW HIHG BITS
	ASHC	#-1,R2		;AND SHIFT BACK
	DIV	(SP)+,R2	;GUARANTEED 15 BIT RESULT IN R2
	MUL	R1,R3		;R3=REC SIZE *NO. OF RECS IN LAST BLOCK
	MOV	R4,R1		;HIGH ORDER BITS * 2
	ASL	R2		;C BIT CLEARED
	ROR	R1		;DIVIDE HIGH BITS BY 2, SET C
	ROR	R2		;ROTATE C BIT INTO HIGH BIT
	BR	30$

	.ENDC
;
;
	$END	POSIT
;
;
	.END
