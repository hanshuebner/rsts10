	$BEGIN	PUT,<30.03>,<PUT RECORD ROUTINE>,R$$SEQ,<PUT,PUTSQ>
; 
; THIS  SOFTWARE  IS FURNISHED UNDER A LICENSE AND MAY
; BE USED OR COPIED ONLY IN ACCORDANCE WITH THE  TERMS
; OF SUCH LICENSE.
;  
; COPYRIGHT (c) 1985, 1987, 1988, 1991 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
; 
; PETER H. LIPMAN 13-JULY-73
;
; PREVIOUSLY MODIFIED BY
;
;	SHAO-SUN-CHIEN
;	J. PAINTER
;	S. RUZICH
;	LONI BROWN
;	S. RUZICH
;	S. M. THOMAS
;	J. C. FRANZINI
;	T. SCHOELLER
;
; Modified for RSX-11M-PLUS V4.1 by:
;
;	Paul K. M. Weiss 18-May-1987	30.02
;		PKW126 -- Make more room by assuming F.RTYP=0
;
; Modified for RSTS/E V10.1 by:
;
;	S. LeVan	21-Oct-91	30.03
;		SEL001 -- Shrink RSTS code too, by assuming F.RTYP=0.
;


;+
; .PUT IS A SUBROUTINE TO WRITE LOGICAL RECORDS TO A FILE.
;
; CALLING SEQUENCE:
;	JSR PC,.PUT
; INPUTS:
;	R0=FDB ADDRESS
; OUTPUTS:
;	F.NRBD+2=ADDRESS OF NEXT RECORD BUFFER IF IN PARTIAL LOCATE MODE.
; OPERATION:
;	ALL INFORMATION REQUIRED BY THE .PUT ROUTINE MUST BE
; PRESENT IN THE FDB.  THIS INCLUDES THE ADDRESS OF THE RECORD
; BUFFER, AND THE NUMBER OF BYTES TO BE WRITTEN.
;
;-
	.IF	EQ,R$$11M	;RSX11D ONLY
	.IF	GT,R$$RSL	;IF ASSEMBLING FOR RESIDENT LIBRARY
	.IF	EQ,R$$SEQ	;AND NOT SEQUENTIAL ONLY
.PUTSQ::
	.ENDC
	.ENDC
	.ENDC
;
	.IF	EQ,R$$SEQ	;IF SEQUENTIAL OR RANDOM ALLOWED
.PUT::	.SAVR1			;SAVE REGISTERS R1-R5
	CALL	..PGCR		;VERIFY THAT PUT/GET IS LEGAL
	.ENDC
;
	.IF	GT,R$$SEQ	;IF SEQUENTIAL ONLY
.PUTSQ::.SAVR1
	CALL	..PGCS
	.ENDC
;
	BCS	PUTX		;BRANCH IF IT ISN'T
	MOV	F.BDB(R0),R3
	MOV	F.BBFS(R0),B.BBFS(R3)		; SET UP BUFFER SIZE
	MOV	F.NRBD(R0),R3	;R3=SIZE OF RECORD IN BYTES
	BLT	PTBIG		;BRANCH IF RECORD TOO BIG
	BITB	#FD.REC,F.RCTL(R0) ;RECORD ORIENTED DEVICE?
	BEQ	PTBLK		;BRANCH IF BLOCK ORIENTED
; RECORD ORIENTED DEVICE
; CALCULATE CARRIAGE CONTROL CHARACTER ON TOP OF STACK
	CLR	-(SP)		;SAVE SPACE FOR A RECORD POINTER
	CLR	-(SP)		;INIT CARRIAGE CONTROL FOR LAST LINE		; GK001
	CLR	-(SP)		;INIT CARRIAGE CONTROL CHARACTER
	MOV	F.NRBD+2(R0),R1	;R1=RECORD ADDRESS
	MOV	F.NREC(R0),R2	;R2=BLOCK BUFFER ADDRESS
	CMP	R1,R2		;IS RECORD ALREADY IN BLOCK BUFFER?
	BNE	20$		;BRANCH IF NO
	DECB	1(SP)		;INDICATE NO MOVE NECESSARY
	CMP	R3,F.BBFS(R0)	;IS RECORD LARGER THAN BLOCK BUFFER
	BGT	PTBIG1		;BRANCH IF YES
20$:	BITB	#FD.CCL,F.RCTL(R0) ;IS THIS A CARRIAGE CONTROL DEVICE?
	BEQ	40$		;BRANCH IF NO
	BITB	#FD.FTN!FD.CR!FD.PRN,F.RATT(R0) ; ANY CARRAIGE CONTROL THERE?
	BEQ	40$		;BRANCH IF NO
	MOVB	#' ,(SP)	;ASSUME A BLANK
	MOVB	(SP),2(SP)	;..FOR ALL LINES				; GK001
	BITB	#FD.FTN,F.RATT(R0) ;IF FORTRAN CARRIAGE CONTROL
	BEQ	40$
	TST	R3		;AND IF NOT A NULL RECORD
	BEQ	40$
	MOVB	(R1)+,(SP)	;PICK UP THE CARRIAGE CONTROL CHARACTER
	DEC	R3		;AND UPDATE THE RECORD SIZE
	CMPB	#'$,(SP)	;IS CARRIAGE CONTROL A DOLLAR SIGN?		; GK001
	BNE	40$		;IF NE NO, LAST LINE WILL USE BLANK		; GK001
	MOVB	(SP),2(SP)	;YES, LAST LINE WILL USE THE DOLLAR SIGN	; GK001
	MOVB	#' ,(SP)	;AND LINES 1 THRU N-1 WILL USE BLANKS		; GK001
;
; LOW BYTE OF (SP) = CARRIAGE CONTROL CHARACTER
; HIGH BYTE OF (SP) = NEGATIVE IF NO MOVE IS NECESSARY
;
40$:	MOV	R3,R5		;R5=INITIAL NO. OF BYTES LEFT TO MOVE
	CMP	R3,F.BBFS(R0)	;MOVE THE LESSER OF BLOCK BUFFER SIZE
	BLOS	50$		;AND WHAT IS LEFT TO BE MOVED
	MOV	F.BBFS(R0),R3
50$:	SUB	R3,R5		;BYTE COUNT LEFT AFTER THIS MOVE
	BHI	55$		;IF HI, THIS IS NOT THE LAST LINE		; GK001
	CMPB	#' ,(SP)	;IS LAST LINE ALSO FIRST (NONBLK CC)		; GK001
	BNE	55$		;IF NE YES, DON'T ZAP CARRIAGE CONTROL!		; GK001
	MOVB	2(SP),(SP)	;LAST LINE:  USE SPECIAL CARR. CNTRL CHR	; GK001
55$:	TST	(SP)		;IS IT REALLY NECESSARY TO MOVE DATA?		; GK001
	BMI	60$		;BRANCH IF NO, IT'S ALREADY IN BLOCK BUF
	MOV	R3,-(SP)	;SAVE THE SIZE TO BE WRITTEN
	CALL	..MVR1		;MOVE THIS FRAGMENT INTO BLOCK BUFFER
	MOV	(SP)+,R3	;AND RESTORE THE FRAGMENT SIZE
	MOV	R1,4(SP)	;SAVE ADDRESS OF NEXT PIECE OF RECORD		; GK001
	MOV	F.NREC(R0),R1	;R1=ADDRESS OF FRAGMENT TO WRITE
60$:	MOV	R3,R2		;IF THE RECORD IS NULL
	BGT	70$
	CLRB	(R1)		;MUST SEND AT LEAST ONE NULL
	INC	R2
70$:	MOVB	(SP),R3		;PICK UP CARRIAGE CONTROL CHARACTER
	BEQ	80$		;IF NULL, DON'T PUT ONE ON OTHERS EITHER	; GK004
	MOVB	#' ,(SP)	;SUBSEQUENT FRAGMENTS USE BLANK CARR CTL	; GK004
80$:	MOV	R5,-(SP)	;SAVE # BYTES LEFT AFTER THIS FRAGMENT		; GK004
	CALL	..WTW1		;WRITE THIS FRAGMENT
	MOV	(SP)+,R3	;R3 = # BYTES LEFT TO WRITE
	BLE	90$		;BRANCH IF THIS RECORD IS FULLY WRITTEN
	MOV	4(SP),R1	;RECOVER ADDRESS OF NEXT PIECE TO WRITE		; GK001
	MOV	F.NREC(R0),R2	;R2 = ADDRESS TO MOVE NEXT PIECE TO
	BR	40$		;GO PROCESS NEXT FRAGMENT OF RECORD
90$:	ADD	#6,SP		;CLEAN 3 WORDS OFF STACK			; GK001
	CALL	..RTAD		;RETURN NEXT RECORD ADR TO USER IF LOCATE MODE
	CMPB	#IE.DAO,F.ERR(R0) ;IGNORE DATA OVERFLOW FROM REC DEVICE
	BNE	PUTX
	CALL	.SUCSS		;Indicate success.
	BR	PUTX

; USER OVER-FILLED THE BLOCK BUFFER BY WRITING TOO MANY BYTES
; INTO IT IN PARTIAL LOCATE MODE - INDICATE RECORD TOO BIG
PTBIG1:	ADD	#6,SP		;CLEAN 3 WORDS OFF STACK			; GK001
PTBIG:	MOVB	#IE.RBG,F.ERR(R0)
;
; EXIT FROM PUT
PUTX:	CALLR	..FCSX


; THIS IS A BLOCK ORIENTED DEVICE, ADD THE RECORD TO THE BLOCK.
PTBLK:
	.IF	GT,R$$ANI
	BICB	#FD.INV,F.BKP1(R0)	;ERS CLEAR BUFFER INVALID BIT SINCE PUT WILL VAL
	.ENDC
	.IF	EQ,R$$SEQ	;SEQUENTIAL OR RANDOM ALLOWED
	BITB	#FD.RAN,F.RACC(R0) ;RANDOM MODE PUT?
	BEQ	20$		;BRANCH IF NO
	CALL	..PSRC		;CALC NEW VBN AND NREC, AND POSITION THE FILE
	BCC	25$		;BRANCH IF NOT POSITIONED AT EOF
; ERROR INDICATION FROM ..PSRC MIGHT BE EOF WHICH WOULD INDICATE THAT FILE
; IS POSITIONED AT OR BEYOND THE CURRENT END OF FILE
	CMPB	#IE.EOF,F.ERR(R0) ;IF EOF ERROR, THEN VBN > EFBK
	BEQ	30$		;BRANCH IF EOF CONDITION
	BR	PUTX		;IT'S SOME OTHER ERROR
	.ENDC
;
; SEQUENTIAL PUT - IF IN INSERT RECORD MODE, THEN IT MAY NOT BE PUTTING AT EOF
; IF IN PUT TRUNCATE MODE, THEN BY DEFINITION THIS PUT IS AT EOF
20$:	CMP	F.NREC(R0),F.EOBB(R0)
	BNE	22$
; NREC = EOBB IN THE SPECIAL CASE THAT USER DID GET, GET, ..., GET, PUT
; AND THE LAST RECORD GOTTEN ENDED AT EOBB.  PERFORM THE
; WRITE OF THE BUFFER IF DIRTY, AND READ THE NEXT EVEN IF PUTTING
; AT EOF.  THIS IS THE ONLY CASE OF A POSSIBLY UNNECESSARY
; I/O OPERATION.  IT COULD RETURN A SPURIOUS EOF CONDITION. IGNORE IT
	.IF	EQ,R$$SEQ
	CALL	..RDRN
	CALL	EOFOK		;ALLOW FOR EOF ERROR
	BCS	PUTX
	.ENDC
;
	.IF	GT,R$$SEQ
	CALL	..RWAT		; READ IN THE NEXT BLOCK			; GK002
	CALL	EOFOK		; ALLOW FOR EOF ERROR				; GK002
	BCS	PUTX								; GK002
	.ENDC
;
22$:	BITB	#FD.INS,F.RACC(R0) ;SEQUENTIAL INSERT MODE?
	BEQ	40$		;BRANCH IF NO, TRUNCATE MODE
; MUST SEE IF POSITIONED AT OR BEYOND EOF
	CALL	..EFCK
	BCS	30$		;BRANCH IF AT OR BEYOND EOF
25$:	BICB	#FD.EOF,F.BKP1(R0) ;NOT PUTTING AT EOF
	BR	PTBLK1
30$:	CALL	.SUCSS		;Indicate success.
40$:	BISB	#FD.EOF!FD.EFB,F.BKP1(R0) ;SAY "PUTTING AT EOF"



PTBLK1:
	BITB	#FD.BLK,F.RATT(R0)
	BEQ	40$		;BRANCH IF RECORDS CAN SPAN BLOCKS
;
; RECORDS CANNOT CROSS BLOCK BOUNDARIES.
; CHECK FOR POSSIBLE "RECORD TOO BIG" ERROR
; CALCULATE SIZE OF RECORD HEADER
;

	CLR	R3		;ZERO LENGTH RECORD HEADER IF FIXED LENGTH
	ASSUME	F.RTYP,0
	CMPB	#R.FIX,(R0)	;BRANCH IF FIXED LENGTH RECORDS
	BEQ	20$		;BRANCH IF FIXED LENGTH RECORDS
	.IF	GT,R$RSTS
	;CMPB	#R.STM,F.RTYP(R0);IF STREAM ASCII RECORDS; SEL001
	CMPB	#R.STM,(R0)	;IF STREAM ASCII RECORDS; SEL001
	ASSUME	F.RTYP,0	;SEL001
	BEQ	20$		;THEN NO HEADER
	.ENDC
	TST	(R3)+		;RECORD HEADER IS AT LEAST 2 FOR BYTE COUNT

	.IF	GT,R$$ANI
	BITB	#CH.AND,F.CHR(R0)
	BEQ	10$
	TST	(R3)+		;4 FOR BYTE COUNT IF ANSI "D"
10$:
	.ENDC

	ASSUME	F.RTYP,0
	CMPB	#R.SEQ,(R0)	;SEQUENCED RECORDS?
	BNE	20$
	TST	(R3)+		;2 MORE FOR SEQUENCE NUMBER
;
; ADD IN USER RECORD SIZE HERE, TO AVOID ILLEGAL
; SIDE EFFECT REFERENCE OF THE AUTO INCREMENT (BOTH
; ODD ADDRESS AND ACCESS VIOLATION)
;

20$:	ADD	F.NRBD(R0),R3	;R3=ACTUAL SIZE OF RECORD
	CMP	R3,F.VBSZ(R0)	;IF RECORD IS LARGER THAN BLOCK SIZE
	BGT	PTBIG		;THEN CLEARLY TOO BIG
	ADD	F.NREC(R0),R3	;SEE IF RECORD WILL FIT IN THIS BLOCK
	BCS	24$		;If CS, record does not fit. [If F.NREC is large
				;...(say 177664), the addition of the record
				;...size (say 120) will wrap around zero.  The
				;...BCS catches this case.]
	CMP	R3,F.EOBB(R0)	;Will record extend beyond end of block?
	BLOS	40$		;If LOS, no, the record fits
24$:
;
; MUST PAD THIS BUFFER, WRITE IT, AND SET UP FOR NEXT ONE
; PAD OF LAST BYTE IN BUFFER IS NECESSARY FOR FIXED LEN ANSI FILE IF
; BLOCK SIZE WAS ROUNDED UP TO AN EVEN NUMBER IN OPEN.
;
	.IF	GT,R$$ANI
	CALL	..ANSP		;IF ANSI MAG TAPE, PAD WITH ANSI PAD CHAR
	BCC	30$		;BRANCH IF ANSI MAG TAPE
	.ENDC
	ASSUME	F.RTYP,0
	CMPB	#R.FIX,(R0)	;IF FIXED LENGTH
	BEQ	30$		;THEN DON'T PAD WITH -1 
	MOV	#-1,@F.NREC(R0)	;OTHERWISE NOTE END OF BUFFER
30$:	CALL	CHNGBF
	BCS	PUTX


;
; BUILD THE RECORD HEADER INCLUDING RECORD SIZE FIELD
; IF NOT FIXED LENGTH AND SEQUENCE NUMBER IF SEQUENCED
;
40$:	MOV	F.NREC(R0),R2	;ADDRESS TO BUILD RECORD HEADER
	MOV	F.NRBD(R0),R3	;USER'S RECORD SIZE
	ASSUME	F.RTYP,0
	CMPB	#R.FIX,(R0)	;IF FIXED LENGTH, NO HEADER
	BEQ	100$
	CMP	R3,F.RSIZ(R0)	;UPDATE MAX RECORD SIZE
	BLE	50$
	MOV	R3,F.RSIZ(R0)
50$:
	.IF	GT,R$RSTS
	;CMPB	#R.STM,F.RTYP(R0);IF STREAM ASCII RECORDS; SEL001
	CMPB	#R.STM,(R0)	;IF STREAM ASCII RECORDS; SEL001
	ASSUME	F.RTYP,0	;SEL001
	BEQ	100$		;THEN NO HEADER
	.ENDC
	.IF	GT,R$$ANI	;IF ANSI "D" CODE
	ASSUME	F.RTYP,0
	CMPB	#R.SEQ,(R0)	;IF SEQUENCED RECORD TYPE
	BNE	55$
	ADD	#2,R3		;INCLUDE SEQUENCE # IN RECORD SIZE
55$:	MOV	R0,-(SP)
	BITB	#CH.AND,F.CHR(R0) ;IF ANSI "D" RECORDS
	BEQ	70$
;
; CALCULATE AND STORE ANSI "D" SIZE FIELD
;
	MOV	#4,R5		;PRODUCE 4 CHARACTERS OF RECORD SIZE
	ADD	R5,R2		;POINT R2 TO END OF SIZE FIELD
	MOV	R3,R0		;R0=SIZE OF RECORD
	ADD	R5,R0		;ANSI SIZE INCLUDES SIZE FIELD
	.IF	EQ,R$$EIS	;IF NO EIS AVAILABLE
60$:	MOV	#10.,R1		;GET SIZE MOD 10.
	CALL	$DIV
	.IFF			;IF EIS AVAILABLE
	MOV	#10.,R4
60$:	MOV	R0,R1
	CLR	R0
	DIV	R4,R0		;GET SIZE MOD 10.
	.ENDC
	ADD	#'0,R1		;MAKE INTO ASCII DIGIT
	MOVB	R1,-(R2)	;AND STORE BACKWARDS INTO SIZE FIELD
	SOB	R5,60$		;REPEAT FOR 4 CHARACTERS
	ADD	#4,R2		;RESTORE POINTER TO END OF SIZE FIELD
	BR	80$
70$:	MOV	R3,(R2)+	;STORE BINARY SIZE FIELD
80$:	MOV	(SP)+,R0
	ASSUME	F.RTYP,0
	CMPB	#R.SEQ,(R0)
	BNE	100$		;BRANCH IF NOT SEQUENCED RECORDS
	.IFF			;IF NO ANSI "D" CODE
	MOV	R3,(R2)+	;STORE RECORD SIZE
	ASSUME	F.RTYP,0
	CMPB	#R.SEQ,(R0)
	BNE	100$		;BRANCH IF NOT SEQUENCED RECORDS
	ADD	#2,-2(R2)	;COUNT SEQUENCE # IN RECORD SIZE
	.ENDC
	MOV	R0,R1
	ADD	#F.SEQN,R1	;R1=ADDRESS OF SEQUENCE NO.
	MOV	#2,R3		;STORE 2 BYTES JUST LIKE
	CALL	BLDREC		;THE RECORD DATA
	.IF	GT,R$RSTS
	BCS	106$
	.IFF
	BCS	210$
	.ENDC


;
; NOW PUT THE USERS PART OF THE RECORD IN THE BUFFER
;
100$:	MOV	F.NRBD(R0),R3	;SIZE
	MOV	F.NRBD+2(R0),R1	;AND ADDRESS OF RECORD
	CALL	BLDREC
	.IF	GT,R$RSTS
	BCS	106$
	.IFF
	BCS	210$
	.ENDC
	.IF	GT,R$RSTS
	;CMPB	#R.STM,F.RTYP(R0);IF STREAM ASCII RECORDS; SEL001
	CMPB	#R.STM,(R0)	;IF STREAM ASCII RECORDS; SEL001
	ASSUME	F.RTYP,0	;SEL001
	BNE	105$
	BITB	#FD.CR,F.RATT(R0) ;WITH CR INSERTION
	BEQ	104$
;
;INSERT CR/NUL AFTER LF ONLY IF NOT PRECEEDED BY CR,
;NOTHING AFTER VT, FF, ESC OR CR/LF, CR/LF OTHERWISE
;
	TST	F.NRBD(R0)	;
	BEQ	102$		;EMPTY RECORD -- PUT CR/LF
	CMPB	#33,-1(R1)	;CHECK FOR ESCAPE
	BEQ	104$		;++RSTS7.1	<ESC> - ADD NOTHING
	CMPB	#14,-1(R1)	;THEN CHECK LAST BYTE
	BLO	102$
	CMPB	#12,-1(R1)	;FOR VERTICAL FORM EFFECTOR
	BHI	102$		;NOT THERE -- PUT CR/LF
	BNE	104$		;VT OR FF -- PUT NOTHING
	DEC	R1		;LF - BACK UP BUFFER POINTER
	CMP	R1,F.NRBD+2(R0)	;LF ONLY THING IN BUFFER
	BEQ	101$		;YES, INSERT CR/NUL
	INC	R1		;BACK TO END OF RECORD
	CMPB	#15,-2(R1)	;LF PRECEEDED BY CR ?
	BEQ	104$		;YES - ADD NOTHING
101$:	MOV	#CRNUL,R1	;LF W/O CR - PUT CR/NUL
	BR	103$
102$:	MOV	#CRLF,R1	;ELSE STORE <CR><LF>
103$:	MOV	#2,R3		;LENGTH OF CR/LF OR CR/NUL
	CALL	BLDREC
106$:	BCS	210$
104$:	BR	110$		;DON'T ROUND UP TO NEXT WORD
105$:
	.ENDC
;
; PUT IS COMPLETE, SET UP FOR NEXT ONE.
;
	.IF	GT,R$$ANI
	BITB	#CH.AND,F.CHR(R0) ;UNLESS ANSII "D" RECORDS
	BNE	110$
	.ENDC
	.IF	EQ,R$RSTS
	INC	R2		;ROUND POINTER UP TO NEXT WORD
	BIC	#1,R2
	.IFF
	BIT	#1,R2		;IF POINTER IS ODD
	BEQ	110$
	CLRB	(R2)+		;PAD WITH A NULL
	.ENDC
110$:	MOV	R2,F.NREC(R0)	;SAVE POINTER TO NEXT RECORD
	.IF	GT,R$$BBF							; GK003
	MOV	F.BDB(R0),R3	;POINT R3 AT START OF BIG BUFFER		; GK003
	BICB	#BD.FRE,B.BFST(R3)	; BUFFER IS NOT FREE
	ADD	#S.BFHD,R3	;...						; GK003
	MOV	R2,R5		;COPY NEXT-RECORD POINTER			; GK003
	ADD	F.VBSZ(R0),R5	;ADD F.VBSZ-1 TO ROUND UP TO NEXT VBN		; GK003
	DEC	R5		;...						; GK003
	SUB	R3,R5		;CALCULATE NO. BYTES THAT IS FROM START		; GK003
	CLR	R4		;AND ROUND TO AN INTEGRAL NO. OF VBNS:		; GK003
	 .IF	GT,R$$EIS							; GK003
	DIV	F.VBSZ(R0),R4	;DIVIDE BY F.VBSZ				; GK003
	MOV	R4,R5		;COPY QUOTIENT FOR MULTIPLICATION		; GK003
	MUL	F.VBSZ(R0),R5	;MULTIPLY BY F.VBSZ TO GET A BYTE COUNT		; GK003
	 .IFF									; GK003
	CLR	-(SP)		;THIS WILL BE BYTE COUNT OF VBNS		; GK003
120$:	SUB	F.VBSZ(R0),R5	;WILL ANOTHER VBN FIT?				; GK003
	BLO	130$		;IF LO NO, WE ARE DONE				; GK003
	INC	R4		;YES, COUNT VBN'S				; GK003
	ADD	F.VBSZ(R0),(SP)	;AND ACCUMULATE BYTE COUNT			; GK003
	BR	120$		;LOOP FOR MORE					; GK003
130$:	MOV	(SP)+,R5	;PUT BYTE CNT INTO R5 TO MATCH EIS CODE		; GK003
	 .ENDC									; GK003
	ADD	R3,R5		;POINT R5 AT END OF VBN TO GET F.EOBB		; GK003
	MOV	R5,F.EOBB(R0)	;AND STORE IT IN THE FDB			; GK003
	DEC	R4		;CALCULATE CURRENT VBN = B.VBN + VBN		; GK003
	ADD	B.VBN+2-S.BFHD(R3),R4 ;..CNT IN R4 - 1				; GK003
	MOV	R4,F.VBN+2(R0)	;...						; GK003
	MOV	B.VBN-S.BFHD(R3),F.VBN(R0) ;...					; GK003
	ADC	F.VBN(R0)	;...						; GK003
	.ENDC									; GK003
	CALL	UPDEOF		;UPDATE END OF FILE
	ADD	#1,F.RCNM+2(R0)	;INCREMENT RECORD NUMBER FOR NEXT PUT
	ADC	F.RCNM(R0)
	BISB	#FD.WRT,F.BKP1(R0) ;NOTE THAT BUFFER IS "DIRTY"
	MOV	F.EOBB(R0),R3
	SUB	F.NREC(R0),R3	;R3=ROOM LEFT IN BUFFER
	BEQ	160$		;BRANCH IF BUFFER FULL
	BHI	135$		;BR IF BUFFER IS UNDERFULL
	JMP	PTBIG		;OVERFULL - REPORT ERROR
135$:				;
	BITB	#FD.BLK,F.RATT(R0) ;IF RECORDS CANNOT SPAN BLOCKS
	BEQ	180$
	.IF	GT,R$$ANI
	ASSUME	F.RTYP,0
	CMPB	#R.FIX,(R0)
	BEQ	140$		;BRANCH IF FIXED LENGTH
	CMP	#4,R3		;IF LESS THAN 4 BYTES LEFT
	BLE	180$
	CALL	..ANSP		;AND IF ANSI "D", THEN PAD
	BCC	160$		;AND TREAT BUFFER AS FULL
	BR	180$		;OTHERWISE CONTINUE USING THIS BUFFER
	.IFF			;ELSE IF NO ANSI "D" CODE
	ASSUME	F.RTYP,0
	CMPB	#R.FIX,(R0)
	BNE	180$
	.ENDC

140$:	CMP	F.RSIZ(R0),R3	;IF ENOUGH ROOM FOR FIXED RECORD SIZE
	BLE	180$		;THEN DON'T FLUSH THE BUFFER
	.IF	GT,R$$ANI
	CALL	..ANSP		;IF ANSI MAG TAPE, MAYBE PAD 1 BYTE
	.ENDC
;
; THIS BUFFER IS FULL, OR AT LEAST THE NEXT RECORD
; CAN'T POSSIBLY FIT IN IT
;
160$:	CALL	CHNGBF		;SET UP NEW BUFFER FOR NEXT PUT
	.IF	EQ,R$$SEQ
	CALL	EOFOK		;AND IGNORE POSSIBLE EOF ERROR
	.ENDC
	BCS	210$
180$:	CALL	..RTAD		;RETURN NEXT ADDRESS FOR LOCATE MODE
210$:	JMP	PUTX		;EGRESS
	.IF	GT,R$RSTS
CRLF:	.BYTE	15,12		;CARRIAGE RETURN, LINE FEED
CRNUL:	.BYTE	15,0		;CARRIAGE RETURN, NULL
	.ENDC


; IN R3=NO. OF BYTES TO BE PUT IN NEXT BUFFER
; OUT C=0 IF OK C=1 IF ERR, F.ERR SET
;	R0	PRESERVED
;	OTHERS	ALTERED
CHNGBF:
	CALL	..WTWA		;WRITE THIS BUFFER
	BCS	20$
	CALL	UPDEOF		;ADJUST EOF
	.IF	EQ,R$$SEQ
	BCC	20$		;BRANCH IF AT EOF
	CALL	..RWAC		;OTHERWISE READ THE NEXT BLOCK
	.IFF
	BCC	20$		;IF NOT AT EOF
	CALLR	..SQER		;ILLEGAL SEQUENTIAL OPERATION
	.ENDC
20$:
	RETURN


; IN	R1=SOURCE PTR
;	R2=DEST PTR IN BLOCK BUFF
;	R3=BYTE COUNT
; OUT R1,R2 UPDATED TO REFLECT THE MOVE
;	R0 PRESERVED R3-R5 ALTERED
;	C=0 IF OK C=1 IF ERR F.ERR SET
BLDREC:
	CMP	R1,R2
	BEQ	40$		;BRANCH IF NO MOVE IS NECESSARY
	MOV	R3,-(SP)	;NO. OF BYTES TO TRANSFER
10$:	MOV	F.EOBB(R0),R3
	SUB	R2,R3		;R3=ROOM LEFT IN BUFFER
	CMP	(SP),R3		;MORE LEFT TO TRANSFER THAN SPACE IN BUFFER
	BGE	20$		;BRANCH IF YES, FILL THE BUFFER
	MOV	(SP),R3		;NO TRANSFER THE REST
20$:	SUB	R3,(SP)		;UPDATE TRANSFER COUNT LEFT
	CALL	..MVR1
	TST	(SP)		;IF NO MORE TO TRANSFER
	BEQ	30$		;THEN LEAVE THE LOOP
	MOV	R1,-(SP)
	CALL	CHNGBF
	MOV	(SP)+,R1
	MOV	F.NREC(R0),R2	;DESTINATION IS BEGINNING OF NEXT BUFFER
	BCC	10$
30$:	INC	(SP)+		;CLEAN UP THE STACK
	RETURN
40$:	ADD	R3,R2		;UPDATE BUFFER POINTER, SET C=0
	RETURN			;AND RETURN DOING NO WORK


EOFOK:
	CMPB	#IE.EOF,F.ERR(R0) ;RESET EOF ERROR
	BNE	10$
	CALL	.SUCSS		;Indicate success.
10$:	CALLR	..FCSX		;AND EXIT SETTING C IF OTHER ERROR
;+
; UPDATE EOF IF FD.EOF IN F.BKP1 IS SET
; CALLING SEQUENCE:
;	CALL	UPDEOF
; INPUTS:
;	R0 = FDB
; OUTPUTS:
;	C=1 IF NOT AT EOF (FD.EOF IS ZERO)
;	C=0 IF FD.EOF = 1 AND IN THIS CASE, EFBK AND FFBY ARE UPDATED
;	R0,R1-R5 PRESERVED
;	R2 ALTERED IF EFBK AND FFBY ARE UPDATED (C=0)
;-
UPDEOF:	SEC
	BITB	#FD.EOF,F.BKP1(R0) ;PUTTING AT EOF?
	BEQ	20$
	MOV	F.VBN(R0),F.EFBK(R0) ;UPDATE END OF FILE BLOCK NUMBER
	MOV	F.VBN+2(R0),F.EFBK+2(R0)
	MOV	F.NREC(R0),R2	;CALCULATE FIRST FREE BYTE
	ADD	F.VBSZ(R0),R2
	SUB	F.EOBB(R0),R2	;C BECOMES 0 HERE
	MOV	R2,F.FFBY(R0)	;NOTE WHERE CURRENT EOF IS
20$:	RETURN
;
;
	$END	PUT
;
;
	.END
