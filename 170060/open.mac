	$BEGIN	OPEN,<32.02>,<OPEN FILE ROUTINE>,R$$OPT,<OPEN,OPFNB,OPFID,OPENR>
;
; THIS  SOFTWARE  IS FURNISHED UNDER A LICENSE AND MAY
; BE USED OR COPIED ONLY IN ACCORDANCE WITH THE  TERMS
; OF SUCH LICENSE.
;
; COPYRIGHT (c) 1985, 1990, 1991 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
;
; PETER H. LIPMAN 13-JULY-73
;
; PREVIOUSLY MODIFIED BY
;
;	E. MARISON
;	P. H. LIPMAN
;	ELLEN R SIMICH
;	ANDREW C. GOLDSTEIN
;	BRIAN O'CONNELL
;	G. H. KUENNING
;	B. LEAVITT
;	S. RUZICH
;	J. PAINTER
;	LONI BROWN
;	T. Lekas
;	M. S. Harvey
;	D. L. Ballenger
;	T. M. Schoeller
;	P. K. M. Weiss
;	R. W. Spinney
;
; Last Modification Date :  22-May-1989
; Modified for RSX-11M-PLUS V4.3 by :
;
;	T. M. Schoeller		22-May-1989		32.00
;		TMS067 -- Expand code written by R. Spinney to check for
;			available FSR region buffer space before file
;			creation to include disk devices also.  This will
;			prevent the case when there is an open failure on
;			a transparently spooled file from being printed if
;			the open fails.
;
; Last Modification Date :  03-May-1991
; Modified for RSTS V10.1 by :
;
;	S. LeVan		03-May-1991		32.01
;		SEL001 - Merge RSTS-specific code into RSX V4.3 of this module.
;	S. LeVan		21-Oct-1991		32.02
;		SEL002 - Shrink code by assuming CLSFQ, N.FID and F.RTYP=0.
;
;+
; OPEN A FILE
; CALLING SEQUENCE:
;	CALL	.OPEN
; INPUTS:
;	R0=FDB
; OUTPUTS:
;	ALL REGISTERS PRESERVED
;	C=0 IF SUCCESSFULL, C=1 IF FAILED TO OPEN, F.ERR SET TO WHY
;	FDB SET UP
; OPERATION:
;	USES THE GET INFORMATION PER LUN DIRECTIVE TO GET THE
; DEVICE NAME AND UNIT NUMBER AND SET UP THE BLOCK SIZE AND
; DEVICE DEPENDENT BITS IN F.RCTL.  INITIALIZES SOME OF THE FDB, AND
; THEN DOES EITHER A PARSE, FIND SEQUENCE ON AN EXISTING FILE OR
; A PARSE, ENTER SEQUENCE ON A NEW FILE.
;  FINALLY THE BLOCK BUFFER IS ALLOCATED,
; THE REST OF THE FDB INITIALIZED, AND THE FILE ACCESSED.
;-
	.PAGE
	.IF	GT,R$RSTS
;
; RSTS LOCAL SYMBOL DEFINITIONS
;
	TY.D	=	100000	; ANSI D TYPE
	TY.F	=	040000	; ANSI F TYPE
	FC.SP	=	020000	; ANSI SP FORM CONTROL
	FC.A	=	010000	; ANSI A FORM CONTROL
	.ENDC	;R$RSTS

	.IF	EQ,R$$OPF	;NORMAL OPEN
	.IF	EQ,R$$11M+R$$RSL-3 ; 11M RESIDENT LIBRARY
.OPENR::			;
	.ENDC			;
	.IF	NE,R$$11M+R$$RSL-3 ; NOT 11M RESIDENT LIBRARY
.OPEN::
	.ENDC	;R$$OPF
	.SAVR1			; SAVE REGISTERS R1 - R5
	.IF	EQ,R$$RSL-2	; RESIDENT LIBRARY ONLY
	CLR	-(SP)		; PUT NORMAL OPEN BY FILE NAME FLAG ON S
	BR	OPCOM		; JOIN COMMON CODE
	.IF	GT,R$$11M	; 11M RESIDENT LIBRARY
.OFNBR::			;
	.ENDC	;R$$RSL
	.IF	EQ,R$$11M	; 11D
.OPFNB::
	.ENDC	;R$$11M
	.SAVR1			; SAVE REGISTERS R1 - R5
	MOV	PC,-(SP)	; PUT OPEN BY FNB FLAG ON STACK
OPCOM:
	.ENDC
	.ENDC
;
;
	.IF	EQ,R$$OPF-1	;OPEN BY FILE NAME BLOCK
	.IF	EQ,R$$11M	; RSX11D CODE
	.IF	EQ,R$$RSL
.OPFNB::
	.SAVR1			; SAVE REGISTERS R1 - R5
	.ENDC
	.IFF			; RSX11M CODE
.OPFNB::
	.SAVR1
	.ENDC
	.ENDC
;
	.IF	EQ,R$$OPF-2	;OPEN BY FILE ID
.OPFID::
	.SAVR1			; SAVE REGISTERS R1 - R5
	.ENDC
;
	MOV	@#.FSRPT,R1	;SEE IF ALLOC CONTROL BLOCK HAS BEEN INI
	BEQ	10$		;ERROR, BUT DON'T BOTHER REPORTING IT -
				;..ALUN OR ..STFN WILL CATCH IT LATER
5$:	TST	A.DFUI(R1)	;UIC WORD SHOULD BE NON ZERO
	BNE	10$		;BRANCH IF IT IS
	CALL	..FINI		;INIT THE FILE SYSTEM
10$:				; REF TAG
	.IF	EQ,R$$OPF
	.IF	EQ,R$$RSL-2	;RESIDENT LIBRARY CODE
	MOV	(SP)+,R5	; GET OPEN CALL FLAG
	.ENDC
	.ENDC
	TST	F.BDB(R0)	; IS FILE ALREADY OPEN?
	BNE	302$		;NE - ERROR - ALREADY OPEN
20$:	BITB	#^C<FD.RWM!FD.RAN!FD.PLC!FD.INS>,F.RACC(R0)
	BNE	304$		;NE - ILLEGAL RECORD ACCESS BITS
24$:	BITB	#FA.CRE,F.FACC(R0) ;IF CREATING NEW FILE
	BEQ	40$
	BITB	#FD.RWM,F.RACC(R0) ;IF READ/WRITE MODE
	BNE	40$		;IGNORE RECORD TYPE AND ATTR
	ASSUME	F.RTYP,0
	MOVB	(R0),R4		; GET RECORD TYPE
	BLE	28$		; MUST BE NON-ZERO
;
; ENSURE THAT ONLY ONE KIND OF CARRIAGE CONTROL IS SPECIFIED.
; (SPIN BITS OFF OF THE RECORD ATTRIBUTES BYTE INTO CARRY.)
;
	ASSUME	FD.FTN,1
	ASSUME	FD.CR,2
	ASSUME	FD.PRN,4
	MOVB	F.RATT(R0),R3	; GET RECORD ATTRIBUTES
	BICB	#FD.BLK,R3	; LEAVE ONLY CARRIAGE CONTROL BIT(S)
	ASRB	R3		; IS FD.FTN BIT THERE?
	BCS	245$		; CS - YES- LOOK FOR OTHERS
	ASRB	R3		; IS FD.CR BIT THERE?
	BCS	245$		; CS - YES- LOOK FOR OTHERS
	ASRB	R3		; IS FD.PRN BIT THERE?
	BCC	26$		; CC - NO CARRIAGE CONTROL, WHICH IS LEG
	BNE	306$		; CS - R3=0 IF ONLY ONE CARRIAGE CONTROL
	CMPB	#R.SEQ,R4	; EQ - FD.PRN IS PRESENT; LEGAL ONLY IF
				; EQ - YES, R.SEQ
245$:	BNE	306$		; NE - NO, ERROR
				; R3=0 IF ONLY ONE CARRIAGE CONTROL
26$:
	ASSUME	R.FIX,1
	ASSUME	R.VAR,2
	ASSUME	R.SEQ,3

	.IF	GT,R$RSTS
	ASSUME R.STM,4		;STREAM MUST = 4
	CMPB	#R.STM,R4

	.IFF	;NO R$RSTS
	CMPB	#R.SEQ,R4
	.ENDC	;R$RSTS

	BHIS	32$		; BRANCH IF OK
	.PAGE
;
; ERROR ROUTINES - SET ERROR CODE AND JOIN COMMON CODE
;
;
; ILLEGAL RECORD TYPE
28$:	MOVB	#IE.BTP,-(SP)
	BR	308$
;
; FILE ALREADY OPEN
302$:	MOVB	#IE.FOP,-(SP)
	BR	308$
;
; ILLEGAL RECORD ACCESS CODE - UNUSED BITS MUST BE ZERO
304$:	MOVB	#IE.RAC,-(SP)
	BR	308$
;
; ILLEGAL RECORD ATTRIBUTES BITS SET - UNDEFINED BITS MUST BE ZERO
306$:	MOVB	#IE.RAT,-(SP)
308$:	JMP	BADOP1			;JOIN COMMON ERROR EXIT

;
	ASSUME	R.FIX,1
	.IF	GT,R$RSTS
32$:
	.IFF	;NO R$RSTS
32$:	DEC	R4		;IF NOT FIXED
	BEQ	40$
	CLR	F.RSIZ(R0)	;INIT LARGEST RECORD IN FILE
	.ENDC	;R$RSTS

40$:	MOV	#1,F.ERR(R0)	;INIT ERROR INDICATION TO SUCCESSFUL
	CLR	F.SEQN(R0)	;CLEAR SEQUENCE NO. IN CASE RECORD DEV
	ASSUME	F.HIBK,4	;
	ASSUME	F.EFBK,10	;
	ASSUME	F.FFBY,14	;
	MOV	R0,R1		; COPY FDB ADDRESS...
	CMP	(R1)+,(R1)+	;... AND MAKE R1 POINT TO HIGH BLOCK FIE
	CLR	(R1)+		;ZERO F.HIBK
	CLR	(R1)+		;ZERO F.HIBK+2
	CLR	(R1)+		;ZERO F.EFBK
	MOV	#1,(R1)+	;INIT F.EFBK+2 TO 1
	CLR	(R1)+		;ZERO F.FFBY
	CLR	F.VBN(R0)	;ZERO THE INITIAL VBN
	CLR	F.VBN+2(R0)
	CLRB	F.BKP1(R0)	; CLEAR BOOKEEPING BYTE NO. 1
	BISB	#FD.EFB,F.BKP1(R0) ;AND SET "IN BLOCK THAT HAS EOF" FLAG
	.PAGE
OPDIR:				; RESET LOCAL SYMBOL TABLE
	.IF	EQ,R$$OPF	;REGULAR OPEN (BY FILE NAME)
	.IF	LE,R$$RSL-1	;NOT FOR RESIDENT LIBRARY

	.IF	GT,R$RSTS	;++RSTS 7.2					;FEK001
	CLRB	F.CHR(R0)	;++RSTS 7.2					;FEK001
	.ENDC			;++RSTS 7.2					;FEK001

	CALL	..STFN		;PARSE INTO FNB UNLESS ALREADY SET UP
	.ENDC
	.ENDC
;
	.IF	EQ,R$$OPF-1	;OPEN BY FILE NAME BLOCK
	.IF	LE,R$$RSL-1	;NOT FOR RESIDENT LIBRARY
	MOV	R0,R1
	ADD	#F.FNB,R1	;R1=ADDR OF FNB
	CALL	..ALUN
	.ENDC
	.ENDC
;
	.IF	EQ,R$$OPF	; RESLBR OPEN AND OPFNB
	.IF	EQ,R$$RSL-2	;
	TST	R5		; TEST CALL FLAG
	BNE	5$		; BRANCH IF OPFNB
	CALL	..STFN		; PARSE INTO FNB
	BR	10$
;
5$:	MOV	R0,R1		; OPFNB SETUP TO CALL ..ALUN
	ADD	#F.FNB,R1
	CALL	..ALUN
10$:				; REF TAG
	.ENDC
	.ENDC
	.IF	LE,R$$OPF-1 ;OPEN BY NAME OR FNB
	.IF NDF V$$ACP		;IF RSX ONLY
				; NO
	BCS	17$		; BRANCH ON ERROR
	.IFF			;V$$ACP - IF POTENTIALLY USING VMS ACP
				; YES
	.IF	EQ,R$$OPF-1	; OPEN BY FNB
	BCS	17$		; BRANCH ON ERROR
	.IFF			; FULL OPEN
;
; IF ERROR AND ERROR IS NO SUCH FILE (IE DIRECTORY) THEN
; IGNORE ERROR IF WE ARE CREATING A TEMP FILE
;
	BCC	15$		; BRANCH IF NO ERROR
	CMPB	#IE.NSF,F.ERR(R0)
	BEQ	17$		; BRANCH IF UNEXPECTED ERROR
	BITB	#FL.VCP,F.FLG(R0) ;IS THIS DEVICE USING THE VMS ACP?
	BEQ	17$		;NO, SKIP TEMP FILE CHECK
	BITB	#FA.TMP,F.FACC(R0)
	BEQ	17$		; IF EQ THEN NOT A TEMP FILE
	BITB	#FA.CRE,F.FACC(R0) ;AND
	BEQ	17$		; IF EQ THEN NOT CREATING A TEMP FILE
	CALL	..ALUN		; ASSIGN THE LUN
	BCS	17$		; BRANCH ON ASSIGN ERROR
	.ENDC
	.ENDC
15$:	CALL	OVBFSZ		;USE OVERIDE BUFFER SIZE IF SPECIFIED

	ASSUME	N.FID,0
	TST	(R1)		;IS FILE ID ALREADY SET?
	BEQ	16$
	JMP	80$
16$:	BITB	#FA.CRE,F.FACC(R0) ;CREATING A NEW FILE?

	.IF	GT,R$$ANI
	BNE	20$		;BRANCH IF YES

	.IFF	;NO R$$ANI
	BNE	40$		;BRANCH IF YES
	.ENDC	;R$$ANI
;
; OPENING AN EXISTING FILE
;
	CALL	..FIND
	BCS	17$
	JMP	80$
17$:	MOVB	F.ERR(R0),-(SP)	;PUSH ERROR CODE ON THE STACK

	.IF	GT,R$$ANI
	BR	26$		;JOIN COMMON ERROR PATH
;
; OPENING A NEW FILE
;
20$:	BITB	#CH.AND,F.CHR(R0)	;ANSI TAPE?
	BEQ	40$
	ASSUME	F.RTYP,0
	CMPB	#R.FIX,(R0)	;AND FIXED LENGTH RECORDS
	BNE	40$
	MOV	F.RSIZ(R0),R3	;CHECK RECORD SIZE
	BGT	30$		;0 < LEGAL-RECORD-SIZE < 100000(8)
	MOVB	#IE.RBG,-(SP)	;PUSH "BAD RECORD SIZE" ERROR ON STACK
	.IFTF	;R$$ANI

26$:	JMP	BADOP2
;
; CALCULATE NEW BLOCK SIZE. INTEGER MULTIPLE OF RECORD SIZE
;
	.IFT	;R$$ANI
	.IF	GT,R$$EIS
30$:	CLR	R4
	MOV	F.BBFS(R0),R5
	DIV	R3,R4		;R4=RECORDS / BLOCK
	BNE	35$
	INC	R4		;AT LEAST 1
35$:	MUL	R3,R4
	.IFF
30$:	CLR	R5		;START AT 0
35$:	ADD	R3,R5		;NOW ADD IN RECORD SIZE
	CMP	R5,F.BBFS(R0)	;OVER LIMIT?
	BLOS	35$		;NOPE
	SUB	R3,R5		;YES, SO CORRECT DOWN
	BNE	36$		;NON-ZERO
	MOV	R3,R5		;MAKE AT LEAST 1
36$:
	.ENDC	;R$$EIS
	INC	R5		;ROUND BLOCK SIZE UP TO AN EVEN NUMBER
	BIC	#1,R5		;SO DRQIO WON'T GIVE US IE.BYT ON WRITE
	CMP	R5,#TAPMIN	;HOW DOES PROSPECTIVE BLOCK SIZE COMPARE
	BGE	37$		;... TO THE LEGAL MINIMUM?  BRANCH IF OK
	MOV	#TAPMIN,R5	;TOO SMALL - USE THE MINIMUM INSTEAD.
37$:				;
	MOV	R5,F.VBSZ(R0)
	MOV	R5,F.BBFS(R0)	;STORE NEW BLOCK SIZE
	.ENDC	;R$$ANI

; ISSUE THE QI/O TO CREATE THE NEW FILE
;
; IF THE FILE IS NOT TEMPORARY AND IS BEING CREATED ON A DIRECTORY DEVICE ON
; A VAX/VMS SYSTEM, DO NOT USE THE CREATE AND ENTER FUNCTIONS AS SEPARATE
; OPERATIONS. THIS WOULD RESULT IN THE ACLS FOR THE FILE NOT BEING SET UP
; AT ALL SINCE NO DIRECTORY CONTEXT IS AVAILABLE DURING THE FILE CREATION,
; SOMETHING THAT IS REQUIRED TO PROPAGATE THE ACLS CORRECTLY. USE THE COMBINED
; FORM OF THESE FUNCTIONS TO AVOID THIS PROBLEM. THIS ALSO HAS THE SIDE EFFECT
; OF IMPROVING PERFORMANCE SINCE A QIO IS AVOIDED.
;

40$:
;
; CHECK IF ENOUGH BUFFER SPACE AVAILABLE BEFORE ALLOCATING FILE HEADER
;
401$:	BIT	#FD.RWM,F.RACC(R0) ;ARE WE IN READ/WRITE MODE?
	BNE	404$		;NE = YES.  NO (DE)BLOCKING DONE
	MOV	F.BBFS(R0),R3	;GET BLOCK BUFFER SIZE
	ADD	#S.BFHD,R3	;ADD IN BLOCK BUFFER HEADER
	MOV	@#.FSRPT,R2	;POINT TO FSR REGION
402$:	BEQ	403$		;ERROR... END OF THE LIST
	CMP	R3,2(R2)	;IS BLOCK BIG ENOUGH?
	BLOS	404$		;IF LO - YES... CONTINUE
	MOV	(R2),R2		;GET ADDRESS OF NEXT BLOCK
	BR	402$		;TRY NEXT BLOCK
403$:	MOVB	#IE.NBF,-(SP)	;"NO BUFFER SPACE" ERROR
	BR	26$		;JOIN COMMON ERROR PATH	
404$:

	.IF	GT,R$RSTS
	.IFF	;NO R$RSTS
	.IF DF V$$ACP		;IF WE COULD BE USING THE VMS ACP

	MOV	@#.FSRPT,R2	;POINT TO FSR REGION
	BITB	#FL.VCP,F.FLG(R0) ;IS THIS DEVICE USING THE VMS ACP?
	BEQ	44$		;NO, DO IT UNCOMBINED WAY
	BITB	#FA.TMP,F.FACC(R0) ;TEMPORARY FILE BEING CREATED?
	BNE	44$		;IF NE YES, DON'T CARE ABOUT ACL PROPAGATION
	BITB	#FD.DIR,F.RCTL(R0) ;DIRECTORY DEVICE?
	BEQ	44$		;IF EQ NO, TREAT CREATION ATTEMPT IN THE OLD WAY
	BITB	#FD.REC,F.RCTL(R0) ;RECORD ORIENTED DEVICE?
	BNE	44$		;IF NE YES, DON'T BOTHER, USE THE OLD WAY
	BIS	#AF.CCR,A.FLAG(R2) ;MARK THAT WE ARE DOING COMBINED CREATE
	MOV	N.STAT(R1),-(SP)	; SAVE N.STAT
	BIC	#NB.SUP,N.STAT(R1)	; ASSUME THAT NOT SUPERSEDING
	BITB	#FA.NSP,F.FACC(R0)	; IS SUPERCEDE INHIBITED?
	BNE	41$			; NOT EQ YES
	BIS	#NB.SUP,N.STAT(R1)	; CAN SUPERECEDE, LET THE AME KNOW
41$:	CALL	..CREA			; CREATE AND ENTER THE FILE
	MOV	(SP)+,N.STAT(R1)	; RESTORE N.STAT
	BCS	17$			; IF CS GO HANDLE ERROR
	TST	F.FVER(R0)	;CREATING DEFAULT VERSION NUMBER?
	BNE	80$		;IF NE NO
	BISB	#FD.DVR,F.BKP1(R0) ;CREATING DEFAULT VERSION NUMBER
42$:	BR	80$		;FILE CREATED, LET'S CONTINUE
44$:
	.ENDC	;V$$ACP

	CALL	..CREA		;CREATE THE NEW FILE
	BCS	17$			; BRANCH ON ERROR
	BITB	#FA.TMP,F.FACC(R0)	;IF CREATING TEMP FILE
	BNE	80$			;SKIP THE ENTER

	.IFT	;R$RSTS			;DON'T CREATE FILE YET
	BITB	#FA.TMP,F.FACC(R0)	;IF CREATING TEMP FILE
	BNE	70$			;GO CREATE TEMP FILE
	BITB	#FD.SQD,F.RCTL(R0)	;IS THIS A NON-DISK DEVICE?		;FEK001
	BNE	70$			;YES, SO DON'T DO THE ..ENTR		;SRM001
	.ENDC	;R$RSTS

	TST	F.FVER(R0)
	BNE	45$
	BISB	#FD.DVR,F.BKP1(R0) ;CREATING DEFAULT VERSION NUMBER
45$:	CALL	..ENTR		;MAKE THE DIRECTORY ENTRY

	.IF	GT,R$RSTS
	BCC	70$		;FILE DOES NOT EXIST ALREADY

	.IFF	;NO R$RSTS
	BCC	80$		;BRANCH IF NO ERROR FROM ..ENTR
	.ENDC	;R$RSTS

; IF THE ENTER ERROR WAS THAT FILE ALREADY EXISTS BY THAT NAME, THEN DEL
	BITB	#FA.NSP,F.FACC(R0) ;SUPERSEDE INHIBITED?
	BNE	60$		;BRANCH IF YES,INDICATE OPEN FAILURE
	CMPB	#IE.DUP,F.ERR(R0)

	.IF	GT,R$RSTS
	BEQ	70$		;OK TO SUPERSEDE OLD FILE

	.IFF	;NO R$RSTS
	BNE	60$		;OTHER KIND OF ERROR, REAL ERROR
	MOV	#1,F.ERR(R0)	;RESET THE ERROR CONDITION
	ASSUME	N.FID,0
	MOV	(R1),-(SP)	;SAVE THE FILE ID
	MOV	2(R1),-(SP)
	MOV	4(R1),-(SP)
	CALL	..DEL1		;DELETE THE FILE
	MOV	(SP)+,4(R1)
	MOV	(SP)+,2(R1)
	MOV	(SP)+,(R1)
	BCS	60$		;BRANCH IF DELETE FAILED
	CALL	..ENTR		;REISSUE THE ..ENTR, NOW IT SHOULD WORK
	BCC	80$		;BRANCH IF OK
	.ENDC	;R$RSTS

60$:	MOVB	F.ERR(R0),-(SP)	;SAVE ERROR CODE
	JMP	BADOP4		;GO REPORT IT

	.IF	GT,R$RSTS
70$:	CALL	..CREA		;NOW CREATE THE FILE
	BCS	17$		; BRANCH ON ERROR
	.ENDC	;R$RSTS

	.ENDC
;
	.IF	EQ,R$$OPF-2	;OPEN BY FILE ID
	MOV	R0,R1
	ADD	#F.FNB,R1
	CALL	..ALUN
	BCC	65$
	MOVB	F.ERR(R0),-(SP)	;PUSH ERROR CODE ON STACK
	BR	66$		;JOIN COMMON ERROR PATH
65$:	CALL	OVBFSZ		;USE OVERRIDE BUF SIZE IF SPECIFIED
	ASSUME	N.FID,0
	TST	(R1)		;FILE ID MUST BE NON ZERO
	BNE	75$
	BITB	#FD.REC,F.RCTL(R0) ;UNLESS RECORD DEVICE
	BNE	67$
	MOVB	#IE.NFI,-(SP)	;NO FILE ID ERROR
66$:	JMP	BADOP2		;JOIN COMMON ERROR EXIT
	ASSUME	N.FID,0
67$:	INC	(R1)		;IN WHICH CASE MAKE IT 1
75$:
	.ENDC
;
80$:
	.PAGE
	.ENABLE	LSB
ACCALO:	
	.IF	EQ,R$RSTS		;NOT FOR RSTS				;SRM001

	BITB	#FD.MNT,F.MBFG(R0)	;MOUNTABLE DEVICE?			; SR183
	BEQ	5$			;NO - NO ACCESS NEEDED			; SR183

	.ENDC
	CALL	ACCESS			;YES- ACCESS THE FILE
	BCS	588$			;AVOID A JMP WITH TWO BRANCHES
5$:	BIT	#FD.RWM,F.RACC(R0) 	;READ/WRITE MODE?
	BEQ	10$		;BRANCH IF PUT/GET MODE
; PUT ADDRESS OF SCRATCH I/O STATUS BLOCK IN F.BDB
	MOV	@#.FSRPT,F.BDB(R0)
	ADD	#A.IOST,F.BDB(R0)
	JMP	80$
;
; ALLOCATE BLOCK BUFFER
10$:
	.IF	EQ,R$$MBF	;IF NO MULTIPLE BUFFERING
	MOV	F.BBFS(R0),R1	;R1=BLOCK SIZE FOR THIS DEVICE
	BPL	20$		;BRANCH IF LEGAL
	MOVB	#IE.ILL,-(SP)	;STACK ERROR CODE
	BR	593$		;DEACCESS AND RETURN
20$:	MOV	R0,-(SP)	;SAVE THE FDB ADDRESS
	MOV	@#.FSRPT,R0	;ALLOCATION CONTROL BLOCK FOR FSR
	ADD	#S.BFHD,R1	;ADD IN BUFFER HEADER
	CALL	$RQCB		;REQUEST A CORE BLOCK
	MOV	R0,R1		;ADDRESS ALLOCATED TO R1
	MOV	(SP)+,R0	;RESTORE FDB FROM STACK
	BCC	30$		;CC - CONTINUE
	MOVB	#IE.NBF,-(SP)	;CS - "NO BUFFER SPACE" ERROR
	BR	593$		;DEACCESS THE FILE
30$:	MOV	R1,F.BDB(R0)	;SET UP BUFFER DESCRIPTOR BLOCK POINTER
	MOV	#1,(R1)		;INIT I/O STATUS TO +1
	MOV	R1,B.NXBD(R1)	;CHAIN BUFFER TO ITSELF
	.IF	GT,R$$BBF
	MOVB	#BD.FRE,B.BFST(R1) ;NOTE THAT BUFFER IS EMPTY
	.ENDC
	.ENDC
;
	.IF	GT,R$$MBF	;IF MULTIPLE BUFFERING
	TST	F.BBFS(R0)	;ENSURE BUFFER SIZE IS LEGAL
	BPL	17$		;BRANCH IF IT IS
	MOVB	#IE.ILL,-(SP)	;STACK ERROR CODE
	BR	593$		;DEACCESS AND RETURN
17$:
; ALLOCATE NUMBER OF BUFFERS SPECIFIED IN F.MBCT, AND
; SET UP THE BUFFER RING
	MOV	R0,R4		;PRESERVE THE FDB ADDRESS
	CLR	R3		;NO BUFFERS ALLOCATED YET
	CLR	R5
	BISB	F.MBCT(R0),R5	;R5=NO. OF BUFFERS DESIRED
	BNE	20$
	MOV	@#.FSRPT,R5
	MOVB	A.DFBC(R5),R5	;USE DEFAULT NO. OF BUFFERS FROM FSR2
20$:	CLRB	F.MBC1(R0)
	CMP	#1,R5		;IF SINGLE BUFFERING
	BGE	23$		;DON'T SET READ AHEAD, WRITE BEHIND
	BITB	#FD.RAH!FD.WBH,F.MBFG(R0) ;IF USER SET THESE
	BNE	23$		;DON'T CHANGE THEM
	MOV	#FD.RAH,R1	;DEFAULT TO READ AHEAD IF READ ONLY
	BITB	#FA.RD,F.FACC(R0)
	BNE	22$
	MOV	#FD.WBH,R1	;OTHERWISE USE WRITE BEHIND
22$:	BISB	R1,F.MBFG(R0)
23$:	MOV	@#.FSRPT,R0	;POINTER TO ALOOCATION CONTROL BLOCK
	MOV	F.BBFS(R4),R1
	ADD	#S.BFHD,R1	;R1=NO. OF BYTES TO ALLOCATES
	CALL	$RQCB		;REQUEST A CORE BLOCK
	BCS	58$		;BRANCH IF NO MORE MEMORY AVAILABLE
	TST	R3		;FIRST BUFFER?
	BNE	35$		;BRANCH IF NO
	MOV	R0,F.BDB(R4)	;YES, SET UP  F.BDB
	BR	47$
35$:	MOV	R0,B.NXBD(R3)	;LINK THE BUFFERS
47$:	MOV	R0,R3
	MOV	#1,@R3		;INIT THE BUFFER DESCRIPTOR
	MOVB	#BD.FRE,B.BFST(R3) ;NOTE BUFFER AVAILABLE
	INCB	F.MBC1(R4)	;COUNT THE BUFFERS ALLOCATED
	SOB	R5,23$		;ALLOCATE THE NEXT ONE
58$:	MOV	R4,R0		;RESTORE FDB ADDRESS
	TST	R3		;ANY BUFFERS ALLOCATED?
	BNE	583$			;YES- CONTINUE
	MOVB	#IE.NBF,-(SP)		;NO - "NO BUFFER SPACE" ERROR
	BR	BADOP5			;DEACCESS THE FILE
583$:	MOV	F.BDB(R0),B.NXBD(R3)	;CLOSE THE BUFFER RING
	.ENDC	;R$$MBF

	BITB	#FD.REC,F.RCTL(R0)	;RECORD DEVICE?
	BNE	596$			;BR IF YES
	BITB	#FA.CRE,F.FACC(R0)	;SKIP READ OF VBN
	BNE	598$			;IF NEW FILE

	.IF	GT,R$$ANI
	BITB	#CH.AND,F.CHR(R0)	;ANSI TAPE?
	BEQ	586$			;ERS NO
;
; OPEN$M, OPEN$U, AND OPEN$W ARE EQUIVALENT FOR ANSI TAPE - DON'T READ 1
; OPEN$R, OPEN$A REQUIRE READING FIRST VBN.
;
	BITB	#FA.RD!FA.APD,F.FACC(R0)  ;ERS AND READ ONLY OR APPEND
	BNE	586$			;ERS GO READ VBN
	BISB	#FD.INV,F.BKP1(R0)	;ERS SET INVALID BUFFER TO INDIC
	BR	598$			;GO SET UP BUFFER DESCRIPTORS
	.ENDC	;R$$ANI

;
; EXISTING BLOCK ORIENTED FILE - READ VBN 1 OR LAST VBN IF OPEN FOR APPE
; THIS IS NECESSARY SO THAT TASK CAN USE F.NRBD+2 AS RECORD ADDRESS BEFO
; FIRST LOCATE MODE PUT$.  BUFFER AND RECORD POINTERS WILL BE SET UP.
;
586$:	CALL	..RWAC			;READ THE 1ST OR LAST BLOCK
	BCC	590$			;BRANCH IF SUCCESSFUL
	CMPB	#IE.EOF,F.ERR(R0)	;END-OF-FILE IS OK HERE
588$:	BNE	BADOP6			;NE - NOT EOF - REPORT OTHER ERR
	MOV	#IS.SUC,F.ERR(R0)	;EQ - TURN EOF INTO SUCCESS...
	BISB	#FD.EFB,F.BKP1(R0)	;AND ENSURE GET WILL RETURN EOF
590$:	BITB	#FA.APD,F.FACC(R0) 	;IF APPENDING
	BEQ	60$
	ADD	F.FFBY(R0),F.NREC(R0)	;SET NEXT RECORD POINTER TO EOF
591$:	BR	60$

;
; BAD RECORD TYPE ERROR - NOT AN FCS FILE
;
BADRTY:	MOVB	#IE.BTP,-(SP)		; SET ERROR CODE
593$:	BR	BADOP5			; DEACCESS AND GET OUT


;
; RECORD ORIENTED DEVICE MUST SET UP RECORD ATTRIBUTES IF
; READING AN EXISTING FILE.
;
596$:	BITB	#FA.CRE,F.FACC(R0)	;NEW FILE?
	BNE	598$			;BR IF YES
	MOV	F.BBFS(R0),F.RSIZ(R0) 	;MAX RECORD SIZE
	ASSUME	F.RTYP,0
	MOVB	#R.VAR,(R0)	;ASSUME VARIABLE LENGTH
	BITB	#FD.FTN!FD.CR!FD.PRN,F.RATT(R0)	; DOES USER HAVE RATTS S
	BNE	598$			;...
	BISB	#FD.CR,F.RATT(R0) 	;NO, SET CARRIAGE RETURNS BETWEE
;
; INIT BUFFER DESCRIPTOR AND RECORD POINTERS FOR 1ST GET, PUT
;
598$:	MOV	F.BDB(R0),R1
	CALL	..BDRC
60$:
;
; SET UP NRBA AND NRBS BASED ON PARTIAL LOCATE MODE OR MOVE MODE
	MOV	F.URBD(R0),F.NRBD(R0) ;ASSUME MOVE MODE
	MOV	F.URBD+2(R0),F.NRBD+2(R0)
	ASSUME	F.RTYP,0
	MOVB	(R0),R4		; GET RECORD TYPE

	.IF	GT,R$RSTS
	.IFF	;NO R$RSTS
	BEQ	65$		; IF UDF REC MAKE R.FIX (FOR COMPAT. WIT

	.IFTF	;R$RSTS
	ASSUME	R.FIX,1
	ASSUME	R.VAR,2
	ASSUME	R.SEQ,3
	CMPB	#R.SEQ,R4	; IS THIS AN FCS FILE
	BHI	62$		; YES CONTINUE

	.IFF	;NO R$RSTS
	BLO	BADRTY		; NO -- GET OUT

	.IFT	;R$RSTS
	BEQ	61$		; EQ- VFC (R.SEQ) - CHECK CONTROL FIELD
	ASSUME	R.STM,4		; HI- FILE IS STREAM ASCII OR BAD RECORD
	CMPB	#R.STM,R4	; SEL001 - STREAM ASCII?
	BEQ	75$		; YES- RECORD TYPE IS VALID
	BR	BADRTY		; NO - RETURN "BAD RECORD TYPE" ERROR
61$:				; SEQUENCED FILE (VARIABLE WITH FIXED CO
	.ENDC	;R$RSTS

	MOVB	F.SEQN+1(R0),R4	; MAYBE IF FIXED SIZE = 0 OR 2
	BEQ	75$		; 0 -- OK CONTINUE
	CMPB	#2,R4
	BNE	BADRTY		; NO -GET OUT
; WE WILL FALL THRU TO 62$ BUT R4 = 2 SO WILL END UP AT 75$
; THIS SAVES ONE WORD. IF YOU DON'T LIKE THIS PUT
; A BR	75$ HERE.

62$:				; REF TAG
	ASSUME	R.FIX,1
	DECB	R4
	BNE	75$		;BRANCH IF NOT FIXED
	TST	F.RSIZ(R0)	;IF FIXED LENGTH SIZE=0
	BNE	70$
	ASSUME	F.RTYP,0
65$:	MOVB	#R.FIX,(R0)	; FORCE FIXED LENGTH RECORDS
	MOV	F.VBSZ(R0),F.RSIZ(R0) ;USE THE VIRTUAL BLOCK SIZE
70$:	MOV	F.RSIZ(R0),F.NRBD(R0) ;SET NXT REC BUF SIZ TO FIXED SIZE
75$:	CALL	..RTAD		;RETURN ADDRESS FOR NEXT RECORD TO USER
77$:	BCS	BADOP6		;IF ERROR, DEACCESS AND REPORT IT
80$:	CLR	F.SEQN(R0)	; CLEAN UP F.SEQN AND CLEAR C-BIT
	CLR	F.RCNM(R0)	; INIT RECORD NUMBER
	MOV	#1,F.RCNM+2(R0)	;
	RETURN
	.PAGE
;
; *** ERROR EXITS FROM OPEN - ENTER VIA JMP
;
; BADOP6 - DEACCESS FILE, REMOVE & DELETE IF NEW, RELEASE BUFFER, SET CA
;
;	INPUT: F.ERR(R0) = ERROR CODE
;
; BADOP5 - DEACCESS FILE, REMOVE & DELETE IF NEW, RELEASE BUFFER, SET CA
;
;	INPUT: (SP) = ERROR CODE
;
; BADOP4 - DELETE FILE, RELEASE BLOCK BUFFER, SET CARRY
;
;	INPUT: (SP) = ERROR CODE
;
; BADOP2 - RELEASE BLOCK BUFFER, SET CARRY
;
;	INPUT: (SP) = ERROR CODE
;
; BADOP1 - SET CARRY AND RETURN
;
;	INPUT: (SP) = ERROR CODE
;
BADOP6:	MOVB	F.ERR(R0),-(SP)	;SAVE ERROR CODE
BADOP5:	CLR	F.SEQN(R0)	;CLEAN UP SEQUENCE NUMBER

	.IF	GT,R$RSTS
	CALL	..IFQB			;SET UP FIRQB AND POINTER
	;MOV	#CLSFQ,R4		;SET FIP CODE TO CLOSE; SEL002
	CLR	R4			;SET FIP CODE TO CLOSE; SEL002
	ASSUME	CLSFQ,0			;SEL002
	CALL	..FIP			;CALL FIP TO CLOSE

	.IFF	;NO R$RSTS
	CALL	..IDPB			; INIT DPB

	.IF NDF V$$ACP		;RSX ONLY SYSTEM
;
; F11ACP EXPECTS ATTRIBUTES TO BE WRITTEN UPON DEACCESS OF A FILE OPEN F
; WRITE, ELSE IT WILL LOCK THE FILE.  TRICK F11ACP BY SPECIFYING AN ATTR
; LIST POINTER, BUT POINT IT TO A ZERO, SO THAT NO ATTRIBUTE WRITE OCCUR
; THIS WILL ALLOW A REDUCTION IN THE AMOUNT OF CODE IN THIS MODULE.
;
; THE DEACCESS IS ATTEMPTED WHETHER OR NOT IT IS REALLY NEEDED, BECAUSE
; ERROR IS IGNORED.
;
	MOV	R5,2(R5)		; SPECIFY A DUMMY ATTRIBUTE LIST

	.IFF	;V$$ACP - IF POTENTIALLY USING THE VMS ACP
;
; THE TRICK USED ABOVE TO PREVENT F11ACP FROM LOCKING THE FILE WILL NOT
; ON A VMS SYSTEM. TO AVOID LOCKING THE FILE, WE WILL WRITE THE FIRST BY
; OF THE RECORD I/O AREA CHARACTERISTICS ATTRIBUTE. NOTE THAT THE FIRST
; WORDS OF THE RECORD I/O AREA CHARACTERISTICS CAN BE FOUND IN THE FIRST
; WORDS OF THE FDB, SO THEY ARE ALREADY AVAILABLE FOR WRITING.
;
	CLR	-(SP)			;TERMINATE ATTRIBUTE LIST
	MOV	R0,-(SP)		;PUSH ATTRIBUTE BUFFER (FDB ADDR
	MOV	#<HA.UAT+<1*256.>>,-(SP) ;PUSH TYPE AND LENGTH OF ONE
	MOV	SP,2(R5)		;PUT ATTRIBUTE LIST POINTER INTO

	.IFTF	;V$$ACP

	MOV	#IO.DAC,R4		; ISSUE DEACCESS QIO
	CALL	..QIOW

	.IFF	;V$$ACP

	ADD	#6,SP			;CLEAN THE STACK

	.ENDC	;V$$ACP

	.ENDC	;R$RSTS


	.IF	NE,R$$OPF-2	;NOT NEEDED FOR OPFID
	BITB	#FA.CRE,F.FACC(R0) ; MARK FOR DELETE IF CREATING NEW FIL
	BEQ	BADOP2		;BRANCH IF EXISTING FILE
	MOV	R0,R1
	ADD	#F.FNB,R1	;SET UP FILE NAME BLOCK ADDRESS

	.IF	EQ,R$RSTS
	MOV	F.FNB(R0),-(SP)	;SAVE FILE ID NUMBER
	CALL	..RMOV		;REMOVE FROM DIRECTORY
	MOV	(SP)+,F.FNB(R0)	;RESTORE FILE ID NUMBER
	.ENDC
BADOP4:	CALL	..MKDL		;DELETE THE EMBRYONIC FILE
	.ENDC	;R$$OPF

BADOP2:	CALL	..RFDB		;RESET THE FDB, RELEASING BUFFER IF NECE
BADOP1:	MOVB	(SP)+,F.ERR(R0)	;RESTORE ERROR CODE
	SEC
	RETURN

	.DSABL	LSB
	.PAGE
;+
; ACCESS THE FILE
; CALLING SEQUENCE:
;	CALL	ACCESS
; INPUTS:
;	R0=FDB
;	F.VBN,F.VBN+2=0
;	F.SHAR,F.STBK SET UP AS APPROPRIATE
;
;
;
;
; OUTPUTS:
;	C=0 IF SUCCESSFUL, C=1 IF ERROR F.ERR SET
;	R0 PRESERVED, R1-R5 ALTERED
;	F.VBN SET
;	F.NREC,F.EOBB SET
;	IF EXISTING ANSI MAG TAPE FILE, THEN
;		F.VBFS, F.BBFS = BLOCK SIZE
;		F.BGBC = BUFFER OFFSET
;	F.SEQN = 8'TH ATTR WORD
;		LOW BYTE = BUCKET SIZE (NOT USED)
;		HI BYTE = SIZE OF FIXED HEADERFOR VFC RECORDS (R.SEQ)
;
;
;
;
; OPERATION:
; ISSUES QIO ACCESS WITH READ OF RECORD ATTRIBUTES
; FOR EXISTING BLOCK ORIENTED FILE, SETS UP RECORD
; ATTRIBUTES FOR EXISTING RECORD ORIENTED FILE. IF CREATING
; NEW FILE, RECORD ATTRIBUTES WERE ALL SET. IF ACCESSING
; AN EXISTING BLOCK ORIENTED FILE READS THE 1ST
; OR LAST (FOR APPEND) VIRTUAL BLOCK. NO READ INITIATED
; FOR RECORD ORIENTED DEVICE.
;-
ACCESS:
	.IF	GT,R$RSTS
	.IFF	;NO R$RSTS
	CALL	..IDPB		;INIT THE DPB AND SET R5 TO PARAM BLOCK
	.IFT	;R$RSTS

	.IF	GT,R$$ANI	; RESET FILE ID TO ZERO FOR MT
	BITB	#FD.DIR,F.RCTL(R0) ;NOP IF IT IS DIRECTORY DEVICE
	BNE	6$		; YES, IT IS
	CLR	F.FNB+N.FID(R0)	; RESET FILE IS TO ZERO
6$:
	.ENDC	;R$$ANI
;
; PRESET THE ATTRIBUTES
;
	BITB	#FA.CRE,F.FACC(R0)	;NEW FILE?				;SRM001
	BNE	600$			;BR IF YES				;SRM001
	MOV	F.BBFS(R0),F.RSIZ(R0) 	;MAX RECORD SIZE			;SRM001
	;MOVB	#R.VAR,F.RTYP(R0) 	;ASSUME VARIABLE LENGTH; SRM001; SEL002
	MOVB	#R.VAR,(R0) 		;ASSUME VARIABLE LENGTH; SEL002
	ASSUME	F.RTYP,0		;SEL002
	BITB	#FD.FTN!FD.CR!FD.PRN,F.RATT(R0)	; DOES USER HAVE RATTS SET UP?	;SRM001
	BNE	600$			;...					;SRM001
	BISB	#FD.CR,F.RATT(R0) 	;NO, SET CARRIAGE RETURNS BETWEEN RECS	;SRM001

600$:										;FEK001
	CALL	..IFQB		; SET UP FIRQB AND POINTER

	.IFF	;NO R$RSTS
	MOV	R0,(R5)
	ADD	#F.FNB,(R5)+	;STORE THE ADDRESS OF THE FILE ID
	.ENDC	;R$RSTS

	.IF	EQ,R$RSTS
	SUB	#18.,SP		;MAKE ROOM ON STACK FOR READ ATT LIST
	MOV	SP,(R5)+	;STORE ADDRESS OF ATT LIST
	ADD	#4,R5		;INDEX TO ACCESS CONTROL WORD
	MOV	F.ACTL(R0),R4	;GET CONTROL WORD FROM FDB
	BMI	7$		; BRANCH IF ENABLED
	MOV	#FA.ENB,R4	; GET BASIC DEFAULT VALUE
7$:	MOV	R4,(R5)		; STORE ACCESS VALUE
	INC	R5		;R5 POINTS TO ACCESS CONTROL BITS
	BITB	#FA.SHR,F.FACC(R0) ;SHARED ACCESS DESIRED?
	BNE	10$		;BRANCH IF YES
	BISB	#WI.LCK,(R5)	;NO, REQUEST LOCKED ACCESS
10$:	MOV	#IO.ACR,R4	;ASSUME ACCESS FOR READ
	BITB	#FA.RD,F.FACC(R0) ;READ ONLY ACCESS DESIRED?
	BNE	25$		;YES, R4 ALL SET
;
; WRITE ACCESS DESIRED
;
	MOV	#WI.DLK,R4	; GET DEACCESS LOCK BIT
	BICB	(R5),R4		; PERFORM XOR OF BIT WITH ACCESS VALUE
	BICB	#WI.DLK,(R5)
	BISB	R4,(R5)
	MOV	#IO.ACE,R4	;ASSUME ACCESS FOR EXTEND DESIRED
	BITB	#FA.EXT,F.FACC(R0) ;EXTEND ACCESS REQUESTED?
	BNE	20$		;BRANCH IF YES, R4 ALL SET
	MOV	#IO.ACW,R4	;ACCESS IS FOR READ, WRITE
20$:
	.IF GT,R$$ANI
	BITB	#CH.AND,F.CHR(R0)	;ANSI TAPE?
	BEQ	25$			;ERS NO
	CLRB	F.BGBC(R0)		;BUFFER OFFSET (INIT TO 1 FOR BI
	BITB	#FA.APD!FA.CRE,F.FACC(R0)	;ERS CREATE OR APPEND
	BNE	25$			;ERS YES
	BISB	#WI.UPD,(R5)		;ERS NO SET UPDATE MODE IN CONTR
	.ENDC
	.ENDC	;R$RSTS

25$:
	.IF	GT,R$RSTS
	BITB	#FD.REC,F.RCTL(R0);IF NOT RECORD ORIENTED
	BNE	26$
	BITB	#FA.CRE,F.FACC(R0);AND CREATING NEW FILE
	BNE	30$		;THEN FILE IS ALREADY OPEN
26$:
;
; BY DEFAULT, A RSTS ASSEMBLY OF FCS DOES NOT INCLUDE ANSI MAG TAPE SUPP
; THE FOLLOWING CODE IS CONDITIONAL UPON BOTH RSTS AND ANSI MAG TAPE.
;
	.IF	GT,R$$ANI
	TST	F.ACTL(R0)	;ACCESS CONTROL ENABLE?
	BPL	2600$		;NO
	BIT	#FA.RWD,F.ACTL(R0) ; REWIND WHEN OPEN AND AFTER CLOSE?
	BEQ	2600$		;NO
	BIS	#100140,FQMODE(R5) ; SET MODE IN FIRQB
2600$:
	.ENDC	;R$$ANI
	MOV	#OPNFQ,R4	;ELSE SET FIP CODE TO OPEN
	CALL	..FIP		;OPEN THE FILE
	BCS	26000$		;EXIT ON ERROR
	BITB	#FD.REC,F.RCTL(R0);IF RECORD ORIENTED
	BEQ	260$		;WELL TOO FAR TO BRANCH
26000$:	JMP	90$		;ALL DONE
260$:	MOV	R0,R1
	ADD	#F.FNB+N.FID,R1	;POINT TO FILE ID IN FNB
	MOV	FQPPN(R5),(R1)+	;SET UP FILE ID
	MOV	FQCLUS(R5),@R1
	MOV	FQSIZ(R5),R4	;GET SIZE OF FILE
	MOV	R4,F.HIBK+2(R0)	;PUT IT IN FDB
	INC	R4
	MOV	R4,F.EFBK+2(R0)	;PUT EOF AT LAST BLOCK + 1
	;CLR	F.RTYP(R0)	;CLEAR FILE AND RECORD ATTRIBUTES; SEL002
	CLR	(R0)		;CLEAR FILE AND RECORD ATTRIBUTES; SEL002
	ASSUME	F.RTYP,0	;SEL002
	.IF	GT,R$$ANI	;SET UP RECORD ATTRIBUTE
	BITB	#FD.SQD,F.RCTL(R0) ; IF NOT SEQUENTIAL DEVICE
	BEQ	268$		;JUST LEAVE
	MOV	#7,@#XRB+XRLEN	;ELSE GET CHARACTERISTIC
	MOVB	FQFIL(R5),@#XRB+XRCI
	MOVB	FQFLAG(R5),@#XRB+XRCI+1
	.SPEC			;IF DOS MT, RETURN AS ZERO
	TSTB	@#IOSTS		;ANY ERROR?
	BNE	268$		;YES, JUST LEAVE
	MOV	@#XRB+XRBC,R4	;IS IT DOS MT?
	BNE	261$		;NO, IT IS ANSI
	MOV	F.VBSZ(R0),R4	;YES, USE VIRTUAL BL SIZE AS REC SIZE
	BR	267$
261$:	BISB	#CH.AND,F.CHR(R0) ;MARK AS ANSI MT
	BISB	#FD.BLK,F.RATT(R0) ; RECORD CAN'T CROSS BLK
	MOV	FQBUFL(R5),F.VBSZ(R0) ; SET BLOCK LENGTH
	BIT	#TY.F,R4	;FIXED LENGTH RECORD?
	BEQ	262$		;NO
	MOVB	#R.FIX,F.RTYP(R0) ;SET TYPE
	BR	264$
262$:	BIT	#TY.D,R4	;VARIABLE LENGTH RECORD?
	BEQ	264$		;NO
	MOVB	#R.VAR,F.RTYP(R0) ;SET TYPE
264$:	BIT	#FC.A,R4	;FORMAT A?
	BEQ	265$		;NO
	BISB	#FD.FTN,F.RATT(R0) ; SET RECORD ATTRIBUTE
	BR	266$
265$:	BIT	#FC.SP,R4	;FORMAT SP?
	BEQ	266$		;NO, MUST BE EMBEDDED
	BISB	#FD.CR,F.RATT(R0) ;SET RECORD ATTRIBUTE
266$:	BIC	#170000,R4	;GET RECORD SIZE
267$:	MOV	R4,F.RSIZ(R0)	;SET RECORD SIZE
	BR	30$
	.ENDC	;R$$ANI
268$:	MOV	#1,F.RSIZ(R0)	;A GOOD RECORD SIZE FOR STARTERS
269$:	CLR	R4		;CLEAR COUNT TO READ
	CALL	..ATR		;FILE ATTRIBUTES INTO FIRQB
	TSTB	@#IOSTS		;IF ANY ERRORS
	BNE	30$		;THEN DON'T TOUCH FDB
	MOV	R0,R1		;PUT ATTRIBUTES IN FDB
	ADD	#FQPPN,R5	;START OF ATTRIBUTES IN FIRQB
	MOV	#7,R4		;NUMBER OF WORDS TO COPY
	TST	@R5		;BUT WAIT - IF NO ATTRIBUTES
	BEQ	30$		;THEN FDB IS ALL SET
27$:	MOV	(R5)+,(R1)+	;ELSE COPY THE ATTRIBUTES
	SOB	R4,27$
30$:
	.IFF	;NO R$RSTS

	MOV	SP,R5		;GET POINTER TO ATT LIST
	MOV	F.RACC(R0),-(SP)	; GET SPACE FOR 8'TH ATTR WORD
	CLR	F.RACC(R0)		; AND INIT 8'TH WORD (IN CASE FA
	BITB	#FA.CRE,F.FACC(R0) ;READ ATT UNLESS CREATING
	BNE	30$
	MOV	(PC)+,(R5)+	;SET READ REC I/O CODE
	.BYTE	-HA.UAT,S.FATT+2 ; READ 8 WORDS
	MOV	R0,(R5)+	;TO THIS ADDRESS
	.IF	GT,R$$ANI
	BITB	#CH.AND,F.CHR(R0)	;ANSI MAG TAPE?
	BEQ	30$			;NO - PROCEED
	MOV	(PC)+,(R5)+		;READ BLOCK SIZE AND BUFFER OFFS
	.BYTE	-BL.SZ,3		;2 BYTES FOR BLOCK SIZE, 1 FOR O
	MOV	R0,(R5)			;
	ADD	#F.VBSZ,(R5)+		;READ INTO FDB
	.ENDC	;R$$ANI

30$:	MOV	F.STBK(R0),(R5)	;ADDRESS OF STATISTICS BLOCK IF DESIRED
	BEQ	33$		;NOT DESIRED...
	MOV	(PC)+,(R5)+	;DESIRED, SET THE CODE
	.BYTE	-11,12
	MOV	F.STBK(R0),(R5)+
	CLR	(R5)
33$:	CALL	..QIOW			;ISSUE THE ACCESS QI/O AND WAIT
	MOV	F.RACC(R0),F.SEQN(R0)
34$:	MOV	(SP)+,F.RACC(R0) ; RESTORE F.RACC WORD
;
	ADD	#18.,SP		;POP STACK ITEMS
	.ENDC	;R$RSTS

	INC	F.VBN+2(R0)	;VBN=1

	.IF	GT,R$$ANI
	BITB	#CH.AND,F.CHR(R0)	;ANSI TAPE?
	BEQ	35$		;BRANCH IF NOT
	BITB	#FA.CRE,F.FACC(R0)	;IF EXISTING FILE...
	BNE	346$			;
	MOVB	F.BBFS(R0),F.BGBC(R0)	;...MOVE BUFFER OFFSET TO ITS PL
	MOV	F.VBSZ(R0),F.BBFS(R0)	;BLOCK SIZE IS ALSO BLOCK BUFFER
346$:	MOV	#77777,F.HIBK(R0) ;FAKE LARGE ALLOCATION
	BITB	#FA.CRE,F.FACC(R0) ;AND IF OPENING EXISTING FILE
	BNE	38$
	MOV	#1,F.EFBK+2(R0)	; FAKE EOF AT BEGINNING IF APPENDING
	BITB	#FA.APD,F.FACC(R0)
	BNE	35$		; ELSE
	MOV	#37777,F.EFBK(R0) ;FAKE EOF SHORT OF ALLOCATED SPACE
	.ENDC	;R$$ANI

35$:	BITB	#FA.APD,F.FACC(R0) ;IF APPENDING
	BEQ	38$
	MOV	F.EFBK(R0),F.VBN(R0) ;SET NEXT VBN
	MOV	F.EFBK+2(R0),F.VBN+2(R0)
38$:
90$:	CALLR	..FCSX			;RETURN AND SET CARRY APPROPRIAT


; USE OVERRIDE BUFFER SIZE IF SPECIFIED
; DESTROYS R4,R5, R0-R3 PRESERVED
OVBFSZ:
	.IF	GT,R$$BBF
	MOVB	#1,F.BGBC(R0)	;ASSUME SINGLE-VBN BUFFERS
	.ENDC
	MOV	F.OVBS(R0),R5
	BEQ	50$		;BRANCH IF NO OVERRIDE SPECIFIED
;
	.IF	EQ,R$$BBF	;NO BIG BUFFERS ALLOWED
	BITB	#FD.REC!FD.SQD,F.RCTL(R0)
	BEQ	50$		;NO OVERRIDE FOR BLOCK DEVICE
	.ENDC
;
	.IF	GT,R$$BBF	;BIG BUFFERS ALLOWED
	BITB	#FD.REC!FD.SQD,F.RCTL(R0) ;IF RECORD DEVICE
	BNE	40$		;ALLOW THE OVERRIDE
	.IF	GT,R$$EIS
	CLR	R4
	DIV	F.VBSZ(R0),R4	;NO. OF VIRT BLOCKS IN BUFFER
	TST	R5		; Is there a remainder?
	BEQ	20$		; EQ = No.
	INC	R4		; Yes.  We'll need one more block.
20$:	TST	R4		; Do we have at least 1 block?
	BNE	25$		; NE = Yes.
	INC	R4		; We must have at least 1 block.
25$:	MOVB	R4,F.BGBC(R0)	; Save VB count of buffer
	MUL	F.VBSZ(R0),R4	;R5=SIZE OF BUFFER
	.IFF
	CLRB	F.BGBC(R0)	;START AT 0
	CLR	R4		;START AT 0
20$:	ADD	F.VBSZ(R0),R4	;ADD
	INCB	F.BGBC(R0)	;AND INC
	CMP	R4,R5		;AGAIN?
	BLO	20$		; Yes
	MOV	R4,R5		; Match conventions
	.ENDC
	CMP	R5,F.VBSZ(R0)	;IS THE BUFFER ACTUALLY OVER 1 VBN?
	BEQ	45$		;IF EQ NO, DON'T SET FD.BGB
	BISB	#FD.BGB,F.MBFG(R0) ;NOTE USING BIG BUFFERS
	BR	45$
40$:
	.ENDC
;
	.IF	GT,R$$ANI
	BITB	#CH.AND,F.CHR(R0)	;ANSI TAPE?
	BEQ	45$
	MOV	R5,F.VBSZ(R0)	;SET VIRTUAL BLOCK SIZE TOO IF ANSI TAPE
	.ENDC	;R$$ANI

45$:	MOV	R5,F.BBFS(R0)
50$:	RETURN
;
;
	$END	OPEN
;
;
	.END
