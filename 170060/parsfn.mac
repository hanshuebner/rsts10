	$BEGIN	PARSFN,<30.01>,<PARSE FILE NAME DESCRIPTOR>
;
; THIS  SOFTWARE  IS FURNISHED UNDER A LICENSE AND MAY
; BE USED OR COPIED ONLY IN ACCORDANCE WITH THE  TERMS
; OF SUCH LICENSE.
;
; COPYRIGHT (c) 1985, 1991 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
;
; PETER H. LIPMAN
;
; E.H. MARISON 1-SEP-78
; S. RUZICH	29-JAN-81
; LONI BROWN	29-APR-81
;
; MODIFIED
;
; SIMON SZETO	20-JAN-82
;
;	       SSS002 -	ALLOW DOT BETWEEN FILE TYPE AND VERSION NUMBER
;
; MODIFIED FOR RSTS/E V10.1 BY:
;
; S. LeVan	03-May-1991	V30.02
;		Merge latest RSTS-specific code into RSX V4.3 version of module.
;
;+
; PARSE FILE NAME DESCRIPTOR - CALLED BY PARSE TO ESTABLISH THE
; FILE NAME AND VERSION NUMBER ENTRIES OF FNB.
;
; INPUTS:
;	R0=FDB ADDRESS
;	R1=ADDRESS OF FILE NAME BLOCK
;	R2=POINTER TO DEV, DIR, AND NAME DESCRIPTORS
;	R3=DEFAULT FILE NAME BLOCK OR ZERO IF NONE SPECIFIED
; OUTPUTS:
;	C=0 IF SUCCESSFUL, C=1 IF ERROR, F.ERR SET TO REASON
;	ALL REGISTERS PRESERVED.
;-
.PRSFN::.SAVR1
	MOV	#1,F.ERR(R0)
..PSFN::MOV	R3,-(SP)
	TST	R2		;NO DESCRIPTOR POINTER?
	.IF	EQ,R$RSTS
	BEQ	10$		;BRANCH IF YES
	.IFF
	BEQ	PRSDF1		;BR IF YES
	.IFTF
	MOV	N.FNPT(R2),R3	;R3=ADDRESS OF STRING
	MOV	N.FNSZ(R2),R2	;R2=SIZE OF STRING
	.IFF
	BLE	PRSDF1		;IS NO STRING USE DEFAULT
	.IFT
10$:	MOV	R3,-(SP)	;SAVE STRING POINTER
	MOV	R2,-(SP)	;SAVE STRING SIZE

	.IF	GT,R$$ANI
	BEQ	PARS1		;DO DEFAULT PROCESSING IF NULL FILENAME
	CMPB	(R3),#'"	;FILENAME BEGINS WITH QUOTE CHARACTER?
	BNE	PARS2		;NO - NORMAL FILENAME
	JMP	QUOTE		;YES- ANSI MAG TAPE QUOTED STRING FILENA
	.ENDC

PARS1:	BLE	BRDEF		;BRANCH IF STRING IS NOW NULL (DO DEFAUL
PARS2:	MOVB	(R3)+,R4	;GET NEXT CHARACTER OF STRING
	CMP	#'.,R4		;IS IT A DOT?
	BEQ	DOT		;BRANCH IF YES
	CMP	#';,R4		;IS IT A SEMICOLON?
	BEQ	SEMI		;BRANCH IF IT IS
	SOB	R2,PARS2	;GO LOOK AT NEXT CHARACTER

; NO MORE CHARACTERS IN STRING.  THE STRING PASSED OVER IS A
; FILE NAME IF WE HAVN'T ALREADY SEEN ONE; A FILE TYPE IF WE HAVN'T
; SEEN THAT, OR A VERSION.
	INC	R3		;POSITION POINTER AS IF THERE WERE
				;A DELIMITER ON THE END.
; HAVE WE ALREADY PASSED THE FILE NAME?
	BIT	#NB.NAM!NB.DOT!NB.SMI,N.STAT(R1)
	BEQ	FNAME		;BRANCH IF NO.
; HAVE WE ALREADY PASSED THE FILE TYPE?
	BIT	#NB.SMI,N.STAT(R1) ;ONLY SEMICOLON OR EOLN DELIMITS FILE
	BEQ	FTYPE		;EQ - JUST PASSED FILE TYPE
;
; THE FIELD JUST SCANNED IS A VERSION NUMBER.
; THE ERROR IN A STRING LIKE "A";X WILL BE DETECTED BY .VRCVT BELOW.
;
VERSN:	MOV	2(SP),R5	;R5=ADDRESS OF STRING
	MOV	R3,R4		;CALCULATE R4=SIZE OF STRING
	SUB	R5,R4
	DEC	R4
	CMPB	#'*,@R5		;WILD CARD VERSION?
	BEQ	10$
	MOV	R1,R3
	ADD	#N.FVER,R3	;R3=ADDRESS TO RETURN NUMBER IN
	CALL	.VRCVT		;CONVERT THE STRING TO A NUMBER
	BCS	15$
	BR	PRSDF		;ALL DONE WITH FILE NAME-
				;FILL IN DEFAULTS
10$:	CMP	#1,R4		;* SEEN, ONLY 1 CHAR?
	BEQ	20$		;YES, IT'S OK
15$:	JMP	PRSBX		;SYNTAX ERROR
20$:	BIS	#NB.SVR,N.STAT(R1)
BRDEF:	BR	PRSDF
; FOUND DOT, NAME IN FRONT, ALSO NOTE THAT A TYPE WAS FOUND.  IF NULL
; THEN THAT'S DIFFERENT FROM NULL AND NO DOT.  (I.E. NULL VS.  NOT SPECI

DOT:	BIT	#NB.SMI,N.STAT(R1) ;IS THIS DOT PART OF VERSION NO.?
	BEQ	10$		;BRANCH IF NO
	INC	R3		;ASSUME DECIMAL VERSION NUMBER
	BR	VERSN		;DOT IS PART OF THE STRING
10$:	BIT	#NB.DOT,N.STAT(R1)	;HAVE WE ALREADY SEEN A DOT?
	BNE	SEMI			;YES- TREAT DOT AS SEMICOLON		;SSS002
	BIS	#NB.DOT,N.STAT(R1)	;NOTE THAT DOT WAS SEEN			;**-1

FNAME:	MOV	R3,R4		;CALCULATE SIZE OF STRING
	SUB	2(SP),R4	;TO SEE IF IT'S NULL
	DEC	R4
	BEQ	10$		;BRANCH IF IT IS NULL
	BIS	#NB.NAM,N.STAT(R1) ;WE HAVE FOUND A FILE NAME
	CMPB	#'*,@2(SP)	;WILD CARD IN FIRST CHARACTER?
	BNE	10$
	BIS	#NB.SNM,N.STAT(R1) ;INDICATE THAT A * WAS SEEN
10$:	MOV	#N.FNAM,R4	;R4=OFFSET FOR FILE NAME
	MOV	#9.,R5		;R5=MAX SIZE OF FILE NAME
	BR	PRSMV

;
; FOUND A SEMICOLON, THE PRECEEDING STRING IS A FILE NAME
; IF NO FILE NAME WAS SEEN OR IT IS A FILE TYPE.
SEMI:	BIT	#NB.SMI,N.STAT(R1)	;HAVE WE ALREADY SEEN A SEMI?
	BNE	PRSBX			;YES- THIS IS AN ERROR
	BIS	#NB.SMI!NB.VER,N.STAT(R1) ;INDICATE THAT SEMI WAS FOUND
	BIT	#NB.NAM!NB.DOT,N.STAT(R1)  ;PAST A FILE NAME YET?
	BEQ	FNAME		;BRANCH IF NO,THIS IS A FILE NAME
; THIS IS A FILE TYPE STRING
FTYPE:	MOV	R3,R4		;CALCULATE STRING SIZE
	SUB	2(SP),R4
	DEC	R4		;TO SEE IF IT'S NULL
	BEQ	10$		;BRANCH IF IT IS

	.IF	GT,R$$ANI
	BIT	#NB.ANS,N.STAT(R1) ;HAVE WE PASSED A QUOTED STRING?
	BNE	PRSBX		   ;YES- BAD NAME LIKE "A"X. OR "A"X; OR
	.ENDC

	BIS	#NB.TYP,N.STAT(R1) ;NOTE THAT WE SAW A FILE TYPE
	CMPB	#'*,@2(SP)
	BNE	10$
	BIS	#NB.STP,N.STAT(R1) ;NOTE WILD CARD TYPE
10$:	MOV	#N.FTYP,R4	;R4=OFFSET FOR FILE TYPE STRING
	MOV	#3,R5		;R5=MAX SIZE STRING
	.PAGE
; MOVE FILE NAME OR TYPE INTO ITS PLACE IN THE FILE NAME BLOCK
; R1=FILE NAME BLOCK ADDRESS, R3=POINTER TO TERMINATING CHARACTER
; R4=OFFSET IN FILE NAME BLOCK TO STORE STRING, R5=MAX NO.  OF BYTES IN
; STRING.  0(SP)=PREVIOUS SIZE OF STRING, 2(SP)=STRING POINTER TO
; BEGINNING OF NAME

PRSMV:	MOV	2(SP),R2	;R2=PTR TO BEGINNING OF STRING
	MOV	R3,2(SP)	;UPDATE STRING POINTER
	SUB	R2,R3		;R3=NEW POINTER-OLD POINTER
	SUB	R3,@SP		;UPDATE BYTE REMAINING IN STRING
	DEC	R3		;R3=SIZE OF STRING,EXCLUDING DELIMITER
	BEQ	10$		;BRANCH IF STRING IS NULL
	CMPB	#'*,@R2		;DOES NAME START WITH WILD CARD?
	BNE	2$		;BRANCH IF NO
	CMP	#1,R3		;MUST BE THE ONLY CHAR
	BEQ	10$		;IT IS,  IF NOT, ILL RAD50 CHAR
2$:	CMP	R5,R3		;SIZE LEGAL?
	BLT	PRSBX		;BRANCH IF TOO BIG
	ADD	R1,R4		;R4=ADDRESS TO MOVE STRING TO
	CALL	..SGR5		;CONVERT ASCII STRIN TO RAD50
	BCS	PRSBX		;BRANCH IF SYNTAX ERROR
; DONE PUTTING NAME IN NAME BLOCK, GO DO THE NEXT PART OF THE STRING
10$:	MOV	2(SP),R3	;R3=ADDRESS OF STRING
	MOV	@SP,R2		;R2=REMAINING SIZE OF STRING
	JMP	PARS1

	.IFF
	MOV	#273,-(SP)	;SET THE MASK					;FEK001
	MOV	SP,R5		;POINT TO THE MASK				;FEK001
	CALL	..FSS		; CALL RSTS FILE STRING SCANNER			;FEK001
	INC	(SP)+		;DUMP THE MASK SAVINE CARRY			;FEK001
	BCS	PRSBX		; EXIT IF ERROR					;LEB001
	MOV	R1,R5								;LEB001
	ADD	#N.STAT,R5	; POINT TO STATUS WORD IN FNB			;LEB001
	BIT	#1,R2		; WAS FILENAME FOUND				;LEB001
	BEQ	10$		; BR IF NO					;LEB001
	BIS	#NB.NAM,@R5	; INDICATE FILENAME FOUND			;LEB001
	BIT	#2,R2		; CHECK FOR WILDCARD NAME			;LEB001
	BNE	9$		; BR IF YES					;LEB001
	MOV	FQNAM1(R3),N.FNAM(R1); COPY THE FILENAME			;LEB001
	MOV	FQNAM1+2(R3),N.FNAM+2(R1)					;LEB001
	BR	10$								;LEB001
9$:	BIS	#NB.SNM,(R5)	; INDICATE WILDCARD FOUND			;LEB001
10$:	BIT	#10,R2		; WAS FILE TYPE FOUND?				;LEB001
	BEQ	20$		; BR IF NO					;LEB001
	BIS	#NB.TYP,(R5)	; INDICATE FILE TYPE FOUND			;LEB001
	BIT	#20,R2		; CHECK FOR NULL FILE TYPE			;LEB001
	BEQ	20$		; BR IF NULL FILE TYPE				;LEB001
	BIT	#40,R2		; CHECK FOR WILD FILE TYPE			;LEB001
	BNE	19$		; BR IF FOUND					;LEB001
	MOV	FQEXT(R3),N.FTYP(R1); PUT FILE TYPE IN FNB			;LEB001
	BR	20$								;LEB001
19$:	BIS	#NB.STP,(R5)	; INDICATE WILD FILE TYPE			;LEB001
20$:	BIT	#200,R2		; CHECK FOR SPECIAL PPN				;LEB001
	BEQ	PRSDF1		; BR IF PPN NOT FOUND				;LEB001
	MOV	FQPPN(R3),N.DID(R1); MOVE PPN TO FNB				;LEB001
	.IFT

;
; STRING PARSE IS COMPLETE-SET UP DEFAULT FIELDS.
PRSDF:	ADD	#4,SP		;GET RID OF STRING PTR AND SIZE
	.IFTF
PRSDF1:	MOV	N.STAT(R1),R3	;R3 = STATUS BITS
	.IFT
	BIT	#NB.DOT,R3	;IF DOT WAS SEEN
	BEQ	2$
	BIS	#NB.TYP,N.STAT(R1) ;INDICATE EXPLICIT TYPE FOUND
	.IFTF
2$:	MOV	(SP)+,R2	;R2=DEFAULT NAME BLOCK ADDRESS
	BEQ	8$		;BRANCH IF NO DEFAULT NAME BLOCK
	BIT	#NB.NAM,R3 	;WAS A FILE NAME SPECIFIED?
	BNE	4$		;BRANCH IF YES-NO DEFAULT NEEDED
	MOV	N.FNAM(R2),N.FNAM(R1) ;MOV DEFAULT NAME FIELD INTO
	MOV	N.FNAM+2(R2),N.FNAM+2(R1) ;FILE NAME BLOCK
	MOV	N.FNAM+4(R2),N.FNAM+4(R1)
; IF AN EXPLICIT FILE TYPE WAS FOUND OR IF A DOT WAS SEEN THEN
; ASSUME FILE TYPE WAS EXPLICIT AND DON'T USE DEFAULT.
; THIS ALLOWS   FILE.   TO MEAN AN EXPLICIT NULL TYPE.
4$:	BIT	#NB.TYP!NB.DOT,R3 ;WAS A FILE TYPE SPECIFIED?
	BNE	6$		;BRANCH IF YES-NO DEFAULT NEEDED
	MOV	N.FTYP(R2),N.FTYP(R1) ;MOVE THE DEFAULT FILE TYPE
	.IFT
6$:	BIT	#NB.VER!NB.SMI,R3  ;WAS A VERSION SPECIFIED?
	BNE	8$		;BRANCH IF YES-
	MOV	N.FVER(R2),N.FVER(R1) ;MOVE THE DEFAULT VERSION NUMBER
	.IFF
6$:
	.IFTF
8$:	RETURN
	.PAGE
; ERROR EXIT
	.IFT
PRSBX:	ADD	#6,SP
	.IFF
PRSBX:	TST	(SP)+
	.ENDC
	MOVB	#IE.BNM,F.ERR(R0)
	SEC
	RETURN

;+
; QUOTE - ANSI MAG TAPE QUOTED ASCII STRING FILENAME PROCESSING
;
; ENTERED BY JMP.
;
; FILENAME IS INDICATED BY INITIAL DOUBLE QUOTE IN DSPT FILENAME STRING.
; A PAIR OF DOUBLE QUOTES IN THE DSPT REDUCES TO A ONE DOUBLE QUOTE IN T
; FINAL DOUBLE QUOTE IS OPTIONAL AT END OF STRING (IF NO VERSION NUMBER)
; VERSION NUMBER CAN FOLLOW FINAL QUOTE, AS IS CAN FOLLOW NORMAL FILENAM
; ROUTINE WILL JMP TO PARS1 IF VERSION NUMBER MIGHT FOLLOW; BAD SYNTAX
; FOLLOWING QUOTED STRING WILL BE DETECTED THERE.
;
; THE FILENAME MAY BE BROKEN UP INTO TWO SEGMENTS IN ORDER TO FIT THE
; PROCRUSTIAN BED OF THE FNB.
;
; QUOTED FILENAME SETS STATUS BITS FOR ANSI FILENAME, EXPLICIT FILENAME,
; EXPLICIT FILETYPE (TO AVOID DFNB FILETYP BEING APPLIED), AND DOT FOUND
;
;    INPUT:	R0 -	FDB ADDRESS
;		R1 -	FNB ADDRESS
;		R2 -	INPUT FILENAME STRING SIZE
;		R3 -	INPUT FILENAME STRING ADDRESS
;		(SP) -	INPUT FILENAME STRING SIZE
;		2(SP) -	INPUT FILENAME STRING ADDRESS
;		4(SP) -	FNB ADDRESS
;
;    OUTPUT, IF JMP TO PRSDF OR PRSBX:
;		R0,R1,SP - PRESERVED
;		R2-R5 -	ALTERED
;
;    OUTPUT, IF JMP TO PARS1:
;		Z BIT -	SET/CLEAR FROM TEST OF R2 (FILENAME STRING SIZE)
;		R0,R1 -	PRESERVED
;		R2 -	CURRENT FILENAME STRING SIZE
;		R3 -	CURRENT FILENAME STRING ADDRESS
;		(SP) -	CURRENT FILENAME STRING SIZE
;		2(SP) -	CURRENT FILENAME STRING ADDRESS
;		4(SP) -	PRESERVED
;		R4,R5 - ALTERED
;
;-
	.IF	GT,R$$ANI
QUOTE:	BITB	#CH.AND,F.CHR(R0) ;ANSI MAG TAPE?
	BEQ	PRSBX		;IF NOT, THEN ERROR
	BIS	#NB.NAM!NB.TYP!NB.DOT!NB.ANS,N.STAT(R1) ;SET STATUS BITS
	MOV	#S.ANM1,R4	;MAX SIZE OF FIRST SEGMENT IN FNB
	MOV	R1,R5		;GET ADDRESS OF FNB
	ADD	#N.ANM1,R5	;CALCULATE ADDRESS OF FIRST FILENAME SEG
	CLR	-(SP)		;CLEAR FLAG TO INDICATE INPUT EXISTS
	CALL	ANSMV1		;MOVE CHARACTERS INTO FIRST SEGMENT
	MOV	#S.ANM2,R4	;NE - MORE INPUT - GET MAX 2ND FNB SEGME
	MOV	R1,R5		;GET ADDRESS OF FNB
	ADD	#N.ANM2,R5	;CALCULATE ADDRESS OF SECOND FILENAME SE
	CALL	ANSMV2		;MOVE CHARACTERS INTO SECOND SEGMENT
	TST	(SP)+		;TEST FLAG; RESTORE SP
	BGT	PRSDF		;GT = NO MORE INPUT
	BLT	10$		;LT = CLOSED QUOTES, MORE INPUT: LOOK FO
				;EQ = NOT END OF INPUT
	CMPB	#'",(R3)+	;ONLY TERMINAL QUOTE CAN BE LEGAL HERE
	BNE	PRSBX		;NO - BAD FILE NAME
	DEC	R2		;YES- TERMINAL QUOTE FOUND - CORRECT CHA
10$:	MOV	R3,2(SP)	;UPDATE THE STACKED STRING ADDRESS
	MOV	R2,(SP)		;UPDATE THE STACKED STRING SIZE
	JMP	PARS1		;SEARCH FOR VERSION NUMBER, OR END OF IN
	.PAGE
;+
; ANSMV1 - MOVE INPUT STRING CHARACTERS INTO FNB SEGMENT; IGNORE INITIAL
; ANSMV2 - MOVE INPUT STRING CHARACTERS INTO FNB SEGMENT
;
;	TERMINAL QUOTE CHARACTER IN INPUT STRING IS OPTIONAL.
;	ANY UNUSED SPACE IN THE FNB NAME FIELD WILL BE PADDED WITH SPACE
;
;
;    INPUT:	R2 -	INPUT STRING SIZE
;		R3 -	INPUT STRING ADDRESS
;		R4 -	FNB SEGMENT SIZE
;		R5 -	FNB SEGMENT ADDRESS
;		2(SP) -	FLAG: 0 = NOT END OF INPUT STRING, NOT CLOSED QU
;			      1 = END OF INPUT STRING
;			     -1 = CLOSED QUOTES, BUT NOT END OF INPUT ST
;
;    OUTPUT:	R2 -	UPDATED INPUT STRING SIZE
;		R3 -	UPDATED INPUT STRING ADDRESS
;		R4,R5 -	ALTERED
;		2(SP) -	UPDATED; SAME CODES AS ON INPUT
;
;-
	.ENABL	LSB
ANSMV2:	TST	2(SP)		;TEST FLAG
	BNE	50$		;NE = NO MORE INPUT; PAD WITH SPACES
10$:	CMPB	#'",(R3)	;EXAMINE CURRENT CHAR - DOUBLE QUOTE?
	BNE	20$		;NO - MOVE IT INTO FNB
	DEC	R2		;YES- IS IT THE LAST CHAR IN STRING?
	BEQ	30$		;YES- IT IS TERMINAL QUOTE - CLEAN UP
	INC	R3		;NO - INCR INPUT STRING POINTER...
	CMPB	#'",(R3)	;...TO LOOK FOR ANOTHER QUOTE
	BEQ	20$		;PAIR OF QUOTES - MOVE ONE INTO FNB
	DEC	2(SP)		;NOTE TERMINAL QUOTE, BUT NOT END OF STR
	BR	50$		;PAD REMAINING FNB BYTES WITH SPACES
20$:	MOVB	(R3)+,(R5)+	;MOVE THE CURRENT CHAR INTO THE FNB
	DEC	R4		;DECREMENT COUNT OF OUTPUT BYTES REMAINI
	DEC	R2		;ADJUST INPUT STRING CHAR COUNT
	BEQ	30$		;EQ - END OF INPUT
	TST	R4		;LOOK AT COUNT OF OUTPUT BYTES REMAINING
	BNE	10$		;NE - MORE SPACE LEFT, PROCESS NEXT CHAR
	BR	60$		;EQ - RETURN 2(SP) = 0, SINCE MORE INPUT
ANSMV1:	INC	R3		;BUMP INPUT STRING POINTER PAST THE QUOT
	DEC	R2		;ADJUST INPUT STRING CHAR COUNT
	BNE	10$		;IF NOT AT END OF STRING, GET ANOTHER CH
30$:	INC	2(SP)		;NOTE END OF INPUT; NO VERSION NUMBER FO
	BR	50$		;SEE IF WE NEED TO PAD THE FNB WITH SPAC
40$:	MOVB	#40,(R5)+	;PAD REST OF THIS FDB SEGMENT WITH SPACE
50$:	DEC	R4		;DECREMENT COUNT OF OUTPUT BYTES REMAINI
	BGE	40$		;GE - MORE ROOM TO FILL
60$:	RETURN			;
	.DSABL	LSB
	.ENDC

;
;
	$END	PARSFN
;
	.END
