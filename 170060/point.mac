	$BEGIN	POINT,<28.2>,<SET FILE POSIT TO SPECIFIED VBN AND BYTE>
; 
; THIS  SOFTWARE  IS FURNISHED UNDER A LICENSE AND MAY
; BE USED OR COPIED ONLY IN ACCORDANCE WITH THE  TERMS
; OF SUCH LICENSE.
;  
; COPYRIGHT (c) 1982, 1991 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
; 
; Modified for RSTS/E V10.1 by:
;
;	S. LeVan	10/21/91	V28.2
;		SEL001 - Shrink code by assuming F.RTYP=0.
;
; PETER H. LIPMAN 11-AUG-73
;
; PREVIOUSLY MODIFIED BY
;
;	ELLEN R SIMICH
;	GEOFF KUENNING
;	S. RUZICH
;	LONI BROWN
;	S. RUZICH
;
; MODIFICATIONS:
;
; A. GROUPE	23-JUL-82
;
;	AG101 -- FIX RANDOM PUT PAST EOF
;
;
;+
; POINT - POSITION FILE AT SPECIFIED BLOCK ANG BYTE NUMBER
; CALLING SEQUENCE
;	CALL	..PNT1
; INPUTS:
;	R0=FDB ADDRESS
;	R1=HIGH ORDER BITS OF NEW VIRTUAL BLOCK NUMBER (VBN)
;	R2=LOW ORDER BITS OF NEW VBN
;	R3=BYTE NUMBER TO POSITION TO IN THE BLOCK, BETWEEN 0
;		AND BBFS-1
;
; OUTPUTS:
;	R0 PRESERVED, R1-R5 ALTERED
;	F.VBN, F.VBN+2 SET TO NEW BLOCK NO.
;	F.NREC SET TO BYTE IN BLOCK
;	C=0 IF OK, C=1 IF ERROR, F.ERR TELLS ABOUT KIND OF ERROR
;
;
;
; OPERATION:
;	IF THE BLOCK DESIRED IS DIFFERENT FROM THE CURRENT NO, THE
; CURRENT ONE IS WRITTEN IF FD.WRT OF F.BKP1 IS SET AND THE NEW BLOCK
; IS READ.  IF THE NEW POSITION IS AT OR BEYOND THE EOF, THEN
; THE EOF ERROR CONDITION IS RETURNED WITH THE C BIT SET
;-
..PNT1::
	.IF	GT,R$$ANI
	BITB	#CH.AND,F.CHR(R0)	;ANSI TAPE?
	BNE	20$		;ERS YES IGNORE VBN SPECIFICATION AND DO PHYSICAL REWIND
	.ENDC

	.IF	EQ,R$$BBF	;NO BIG BUFFERS
	.IF	GT,R$RSTS
	BITB	#FD.EOF,F.BKP1(R0); LAST BLOCK OF FILE?
	BEQ	5$		; NO SO GO ON
	BITB	#FD.RWM,F.RACC(R0); READ/WRITE MODE?
	BNE	5$		; YES SO GO ON
	BITB	#FO.RD,F.FACC(R0); READ ONLY ACCESS?
	BNE	5$		; YES SO GO ON
	;MOVB	F.RTYP(R0),R4	; GET RECORD TYPE; SEL001
	MOVB	(R0),R4		; GET RECORD TYPE; SEL001
	ASSUME	F.RTYP,0	; SEL001
	BEQ	3$		; RTYP=0 (STRM) GO ZERO PAD BLOCK
	CMPB	#R.STM,R4	; IS IT STREAM?
	BNE	5$		; NO SO SKIP OVER ZERO PAD CODE
3$:	MOV	F.NREC(R0),R5	; GET POINTER TO NEXT FREE BYTE
	MOV	F.EOBB(R0),R4	; GET POINTER TO END OF BLOCK
	SUB	R5,R4		; MAKE IT A COUNT OF UNUSED BYTES
	BLOS	5$		; DON'T ZERO PAD IF ALREADY AT END
4$:	CLRB	(R5)+		; ZERO PAD BUFFER
	SOB	R4,4$		; TILL DONE
	BISB	#FD.WRT,F.BKP1(R0); MARK BUFFER AS DIRTY
	JMP	20$		; GO PUT OUT THIS BLOCK
5$:
	.ENDC
	CMP	R2,F.VBN+2(R0)	;SAME BLOCK AS CURRENT ONE?
	BNE	20$		;BRANCH IF NO.
	CMP	R1,F.VBN(R0)	;HIGH ORDER BITS TOO?
	BNE	20$		;BRANCH IF NOT THE SAME VBN
; VBN IS THE CURRENT ONE, JUST SET NREC
	MOV	F.EOBB(R0),R1
	SUB	F.VBSZ(R0),R1
	ADD	R3,R1
	MOV	R1,F.NREC(R0)
	CALL	..EFCK
10$:	RETURN
;
	.IFF			;BUFFERS GREATER THAN 1 BLOCK
	MOV	R1,R4		;DESIRED VBN IN R4,R5
	MOV	R2,R5
	CALL	..IBB1		;DESIRED VBN IN THIS BUFFER?			; GK001
	BCS	20$		;BRANCH IF NO
	ADD	R3,F.NREC(R0)	;EOBB AND NREC WERE SET UP
	MOV	R1,F.VBN(R0)
	MOV	R2,F.VBN+2(R0)
	CALL	..EFCK
10$:	RETURN
	.ENDC

;
; RESET THE VIRTUAL BLOCK NUMBER-WRITE (IF NECESSARY), THEN READ
20$:	MOV	R3,-(SP)	;SAVE THE BYTE OFFSET
	MOV	R1,-(SP)	;HIGH ORDER BITS OF VBN
	MOV	R2,-(SP)	;LOW ORDER BITS OF VBN
; WRITE THE DIRTY BUFFER, IF NECESSARY, FORCING THE WRITE OF A BIG BUFFER OR
; A SHORT BLOCK ON ANSI TAPE.
	CALL	..WTWD
;
; IF THE DEVICE IS SEQUENTIAL REPOSTION IT BEFORE
; READING THE NEW BLOCK
;
40$:
	MOV	(SP)+,F.VBN+2(R0)	;POINT TO DESIRED VBN
	MOV	(SP)+,F.VBN(R0)		;
	BCS	60$			;BR ON ERROR FROM WRITE
	.IF GT,R$$ANI
	BITB	#CH.AND,F.CHR(R0)	;ANSI TAPE?
	BEQ	50$		;ERS NO
	.IF	EQ,R$RSTS
	MOV	#FF.RWF,R1	;ERS SET UP PARAMETERS TO REWIND FILE
	CLR	R2
	CLR	R3
	CALL	..CTRL		;ERS ISSUE THE QIO
	.IFF
	MOV	#4,@#XRB+XRLEN	; SET XRB FOR BACKSPACE
	MOVB	F.LUN(R0),@#XRB+XRCI; TO BEGINNING OF FILE
	ASLB	@#XRB+XRCI
	MOVB	#MTAHND,@#XRB+XRCI+1
45$:	MOV	#32767.,@#XRB+XRBC; SET NUM OF REC TO BACKSPACE
	.SPEC
	TST	@#XRB+XRBC	; IF 0, MORE TO BACKSPACE
	BEQ	45$		; YES
	DEC	@#XRB+XRLEN	; FORWARD JUST PAST THE EOF
	.SPEC
	SUB	#1,R2
	SBC	R1
	BR	49$
46$:	SUB	#32767.,R2	; FIND OUT IF WE CAN FWD MAX
	SBC	R1
	BPL	47$
	ADD	#32767.,R2	; RESTORE THE VBN
	MOV	R2,@#XRB+XRBC	; FORWARD THAT MANY BLOCKS
	.SPEC
	BR	500$
47$:	MOV	#32767.,@#XRB+XRBC; FORWARD MAX
48$:	.SPEC
49$:	TST	R1		; DONE?
	BNE	46$		; NO
	TST	R2
	BNE	46$
500$:
	.ENDC
	BISB	#FD.INV,F.BKP1(R0)  ;ERS SET BUFFER INVALID BIT TO INDICATE NO READ OCCU
	MOV	#1,F.EFBK+2(R0)		;ERS SET EOF FOR A PUT
	CLR	F.EFBK(R0)
	TST	(SP)+			;ERS POP COUNT
	MOV	F.BDB(R0),R1		;ERS SET UP BUFFER DESCRIPTORS
	CALLR	..BDRC			;
	.ENDC
;
; PERHAPS ALLOCATE SPACE, THEN READ THE NEW VIRTUAL BLOCK NUMBER IN
;
50$:	CALL	..CEFB			;ARE WE POSITIONED BEYOND EOF?
	BLOS	55$			;CC - NO - BEFORE OR AT EOF
	MOV	F.VBN(R0),R1		; GET VBN TO ALLOCATE TO
	MOV	F.VBN+2(R0),R2
	CALL	..ALC1			; AND TRY TO ALLOCATE SPACE
	BCS	60$			;     CS - FAILED TO ALLOCATE SPACE
55$:
	.IF	GT,R$$BBF							; GK002
	MOV	F.BDB(R0),R1	;POINT AT BDB					; GK002
	BISB	#BD.FRE,B.BFST(R1) ;SET BUFFER-INVALID BIT			; GK002
	.ENDC									; GK002
	CALL	..RWAC			;READ NEW BLOCK - MAYBE GET EOF ERROR
	ADD	(SP)+,F.NREC(R0) ;ADD IN BYTE OFFSET TO RECORD POINTER
	TSTB	F.ERR(R0)
	BLT	70$		;BRANCH IF ERROR FROM READ
	CALLR	..EFC1		;FINISH CHECK FOR EOF, ..SEFB DONE BY ..RWAT
;
60$:	TST	(SP)+		;CORRECT STACK
70$:	SEC
	RETURN
;
;
	$END	POINT
;
;
	.END
