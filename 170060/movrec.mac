	$BEGIN	MOVREC,<28.1>,<MOVE RECORD TO/FROM USER BUFFER>
; 
; THIS  SOFTWARE  IS FURNISHED UNDER A LICENSE AND MAY
; BE USED OR COPIED ONLY IN ACCORDANCE WITH THE  TERMS
; OF SUCH LICENSE.
;  
; COPYRIGHT (c) 1982 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
; 
; PETER H. LIPMAN 11-AUG-73
;


;+
; SUBROUTINE TO MOVE A RECORD
; CALLING SEQUENCE
;	CALL	..MVR1
; INPUTS:
;	R0=FDB
;	R1=BYTE ADDR OF SOURCE RECORD
;	R2=BYTE ADDR OF DESTINATION
;	R3=SIZE OF RECORD IN BYTES
; OUTPUTS:
;	R1=ADDRESS OF NEXT BYTE NOT MOVED FROM
;	R2=ADDRESS OF NEXT BYTE NOT MOVED TO
;	R0,R5 PRESERVED
;	R3,R4 DESTROYED
;
; OPERATION:
;	THIS ROUTINE MOVES THE DATA A WORD AT A TIME IF NEITHER
; MEMORY ADDRESS IS ODD.  IT WILL HANDLE AN ODD BYTE COUNT IN THIS 
; CASE BY MOVING ONE EXTRA BYTE AFTER THE WORD MOVE LOOP.
; IF EITHER ADDRESS IS ODD, THE DATA IS MOVED A BYTE AT A TIME.
; IT WORKS OUT THAT THE CASE OF BOTH ADDRESSES BEING ODD WILL NOT
; OCCUR BECAUSE THE ADDRESS IN THE FCS BUFFER IS ALWAYS EVEN.
;
;-
;
; THIS NEXT INSTRUCTION SETS THE C BIT TO THE LOW ORDER BIT OF THE
; BYTE COUNT.  C MUST BE PRESERVED THROUGHOUT THE REMAINING
; ALGORITHM SO IT CAN BE CHECKED FOR THE FINAL MOVE BYTE INSTRUCTION.
;
..MVR1::ASR	R3		;R3=WORD COUNT, C=0 OF EVEN, 1 IF ODD
	BEQ	20$		;TAKE CARE OF 0 OR 1  BYTE
	BMI	30$		;NO MOVES IF NEGATIVE
	MOV	R1,R4
	BIS	R2,R4
	BIT	#1,R4
	BNE	40$		;BRANCH IF EITHER ADDRESS IS ODD
10$:	MOV	(R1)+,(R2)+	;MOVE A WORD AT A TIME
	SOB	R3,10$
20$:	BCC	30$		;BRANCH IF BYTE COUNT WAS EVEN
	MOVB	(R1)+,(R2)+	;MOVE THE LAST BYTE
30$:	RETURN
;
; HAVE TO MOVE BYTE AT A TIME
40$:	MOVB	(R1)+,(R2)+
	MOVB	(R1)+,(R2)+
	SOB	R3,40$		;REMEMBER R3=WORD COUNT
	BR	20$		;MOVE LAST BYTE IF ODD COUNT
;
;
	$END	MOVREC
;
;
	.END
