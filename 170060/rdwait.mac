	$BEGIN	RDWAIT,<28.1>,<READ VBN AND WAIT>
; 
; THIS  SOFTWARE  IS FURNISHED UNDER A LICENSE AND MAY
; BE USED OR COPIED ONLY IN ACCORDANCE WITH THE  TERMS
; OF SUCH LICENSE.
;  
; COPYRIGHT (c) 1982 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
; 
; PETER H. LIPMAN 16-AUG-73
;
; PREVIOUSLY MODIFIED BY
;
;	ED MARISON
;	G. KUENNING
;	S. RUZICH


;+
; READ AND WAIT FOR I/O DONE
; CALLING SEQUENCE:
;	CALL	..RWAT		;READ NEXT VBN
;	CALL	..RWAC		;READ CURRENT VBN
; INPUTS:
;	RO=FDB
;	F.BDB(R0)+#S.BFHD = BUFFER ADDRESS
;	F.BBFS(R0) = NO. OF BYTES TO READ
; OUTPUTS:
;	C=0 IF NO ERROR C=1 IF ERROR, F.ERR SET
;	R0 PRESERVED R1-R5 ALTERED
;	F.NREC(R0)=ADDRESS OF 1ST BYTE OF DATA FOR VBN
;	F.EOBB(R0)=ADDR OF LAST +1 BYTE IN DESIRED VBN
; OPERATION:
;	USE ..RWAT FOR RECORD ORIENTED TRANSFERS
; NOT RWDATC.
;-
..RWAT::
	BITB	#FD.REC,F.RCTL(R0)
	BNE	RDWA05
	ADD	#1,F.VBN+2(R0)
	ADC	F.VBN(R0)
..RWAC::CALL	..SEFB
	BCC	10$
	MOV	F.BDB(R0),R1
	CALL	..BDRC		;SET NREC AND EOBB
	SEC
	RETURN
10$:
	.IF	GT,R$$BBF	;BUFFERS BIGGER THAN 1 BLOCK
	CALL	..INBB		;IS DESIRED VBN IN THIS BUFFER?			; GK001
	BCC	RDWA15		;IF YES, ALL DONE, EXIT				;**-1
	.ENDC
RDWA05:
	.IF	GT,R$$MBF	;MULTIPLE BUFFERING
	BITB	#FD.RAH,F.MBFG(R0) ;ARE WE DOING READ AHEAD?
	BNE	RDWTMB		;BRANCH IF YES
	MOV	F.BDB(R0),R1
	CALL	..BDRC
	.ENDC
; SINGLE BUFFERING
RDWA10:										; GK001
	.IF	GT,R$$BBF							; GK001
	MOV	F.BDB(R0),R1	;POINT AT BUFFER HEADER				; GK001
	MOV	F.VBN(R0),B.VBN(R1) ;COPY VBN TO BUFFER				; GK001
	MOV	F.VBN+2(R0),B.VBN+2(R1) ;...					; GK001
	.ENDC									; GK001
	CALL	..BKRG								; GK001
	CALL	..RBLK								;**-1
	.IF	GT,R$$BBF							; GK001
	BICB	#BD.FRE,B.BFST(R1)						; GK001
	.ENDC									; GK001
	CALL	..WAST
	BCS	RDWA20
RDWA15:	RETURN
RDWA20:	CALL	..WAND		;WAIT FOR NODE IF OUT OF NODES
	BCC	RDWA10
	.IF	GT,R$$BBF
	CALL	..RSEF		;IGNORE EOF ERROR				; GK001
	.ENDC									;**-1
	RETURN
; THIS CODE HANDLES MULTIPLE BUFFERS AND READ AHEAD
	.IF	GT,R$$MBF
RDWTMB:
	MOV	F.BDB(R0),R4	;R4=ADR OF BUFFER CONTROL BLOCK
	CLR	R5
	BISB	F.MBC1(R0),R5	;R5=NO OF BUFFERS IN RING
	BR	40$		;GOT TO BOTTOM OF LOOP-SKIP 1ST BUFFER
; SEE IF NEXT BUFFER IN BUFFER RING HAS I/O DONE AND
; CONTAINS THE DESIRED VBN
10$:	TSTB	@R4		;WAIT FOR I/O DONE
	BNE	20$
	CALL	..WAEF
	BR	10$
20$:	BITB	#BD.FRE,B.BFST(R4)
	BNE	45$		;BRANCH IF BUFFER CONTAINS NO DATA
; NEXT BUFFER IS READY - IF RECORD MODE THEN THIS IS THE
; DESIRED ONE - OTHERWISE CHECK VBN
	BITB	#FD.REC,F.RCTL(R0)
	BNE	50$
	.IF	GT,R$$BBF
	MOV	R5,-(SP)
	CALL	..INBB								; GK001
	MOV	(SP)+,R5							;**-1
	MOV	F.BDB(R0),R4
	BCC	60$
	.ENDC
	.IF	EQ,R$$BBF
	CMP	F.VBN(R0),B.VBN(R4)
	BNE	40$
	CMP	F.VBN+2(R0),B.VBN+2(R4)
	BEQ	50$
	.ENDC
40$:	BISB	#BD.FRE,B.BFST(R4)
45$:	MOV	B.NXBD(R4),R4	;GET NEXT BUFFER ADDR
	MOV	R4,F.BDB(R0)
	SOB	R5,10$
; NOTE THAT DESIRED VBN MUST ALSO BE READ
	CLR	F.EOBB(R0)
	BR	RDWTRA
; BUFFER IN R4=F.BDB CONTAINS DESIRED VBN,
; MUST  SET F.NREC, F.EOBB
50$:	MOV	R4,R5
	ADD	#S.BFHD,R5
	MOV	R5,F.NREC(R0)
	.IF	GT,R$$ANI
	BITB	#CH.AND,F.CHR(R0)	;ANSI MAG TAPE?
	BEQ	55$			;NO - BRANCH
	CLR	-(SP)			;YES
	BISB	F.BGBC(R0),(SP)		;AVOID EXTENDING SIGN BIT OF BUF OFFSET
	ADD	(SP)+,F.NREC(R0)	;ADD BUFFER OFFSET TO NEXT REC POINTER
55$:
	.ENDC
	ADD	2(R4),R5
	MOV	R5,F.EOBB(R0)
; IF MULTIPLE BLOCK BUFFER REENTERS THE STREAM HERE WITH
; F.NREC, F.EOBB ALL SET UP
	.IF	GT,R$$BBF
60$:	MOV	R4,R1
	MOVB	@R1,F.ERR(R0)
	CALL	..RSEF								; GK001
	BCC	RDWTRA								;**-1
	RETURN
	.ENDC
	.IF	EQ,R$$BBF
	MOVB	@R4,F.ERR(R0)
	BGT	RDWTRA
	SEC
	RETURN
	.ENDC
; START READ AHEAD FOR ALL FREE BUFFERS IN RING
; R4=F.BDB(R0)=BUFFER ADDRESS
RDWTRA:
	CLR	R5
	BISB	F.MBC1(R0),R5	;R5=NO. OF BUFFERS IN RING
; EOBB CONTAINS 0  WHEN ALL BUFFERS NEED TO BE READ INTO
	TST	F.EOBB(R0)
	BNE	50$		;BRANCH IF 1ST BUFFER IS ALL SET.
	MOV	F.VBN(R0),R1	;DESIRED VBN FOR 1ST BUFFER
	MOV	F.VBN+2(R0),R2
	BR	40$
; R1,R2=VBN USED IN LAST READ, R4=NEXT BUFFER
20$:	BITB	#FD.REC,F.RCTL(R0) ;IF RECORD DEVICE
	BNE	26$		;DON'T CHECK VBN FOR END OF FILE
	.IF	GT,R$$BBF	;LARGE BLOCK BUFFERS
				; **** THE FOLLOWING LINE IS HIGHLY QUESTIONABLE
				; IT WILL AT LEAST CHANGE FOR BUFFER OFFSET
	MOVB	F.BGBC(R0),R3	;BIG BUFFER BLOCK COUNT
	ADD	R3,R2
	.ENDC
	.IF	EQ,R$$BBF
	ADD	#1,R2
	.ENDC
	ADC	R1		;R1,R2=NEXT VNB TO USE
; TERMINATE READ AHEAD SCAN IF BEYOND EFBK
	CMP	R1,F.EFBK(R0)
	BNE	24$
	CMP	R2,F.EFBK+2(R0)
24$:	BHI	80$		;BRANCH IF BEYOND EOF
	BLO	26$		;BRANCH IF BEFORE EOF
	TST	F.FFBY(R0)	;IF ZERO, THEN BEYOND EOF
	BEQ	80$
26$:	BITB	#BD.FRE,B.BFST(R4) ;IF BUFFER IS BUSY
	BNE	40$		;BRANCH IF FREE
; THIS BUFFER CONTAINS DATA OR WILL WHEN IO DONE.
; IF ITS THE RIGHT VBN, THEN PROCEED WITH SCAN.
; IF NOT AND IO IS DONE, THEN ISSUE QIO FOR DESIRED
; VBN, AND FINALLY IF IO PENDING, THEN TERMINATE
; READ AHEAD SCAN.
	CMP	R1,B.VBN(R4)
	BNE	30$
	CMP	R2,B.VBN+2(R4)
	BEQ	50$		;BRANCH IF VBN IS THE SAME
				; NOTE: WE WILL RESET R1 AND R2
				; BACK TO THEMSELFS FOR BLOCK DEVICES
				; THIS SAVES SPACE FOR RECORD DEVICES
				; WHICH MUST WAIT UNLESS THIS IS THE
				; LAST BUFFER.
30$:	TSTB	@R4
	BEQ	80$		;IF IO PENDING, STOP SCAN
40$:	MOV	R1,B.VBN(R4)	;SET DESIRED VBN
	MOV	R2,B.VBN+2(R4)
	MOV	F.BBFS(R0),B.BBFS(R4) ;NO OF BYTES TO READ
	BICB	#BD.FRE,B.BFST(R4) ;NOTE BUFFER BUSY
45$:	MOV	F.BDB(R0),-(SP)
	MOV	R5,-(SP)
	MOV	R4,F.BDB(R0)
	CALL	..BKRG
	CALL	..RBLK
	MOV	F.BDB(R0),R4
	MOV	(SP)+,R5
	MOV	(SP)+,F.BDB(R0)
	BCC	50$
; IF OUT OF NODE ERROR AND IF THIS BUFFER IS THE ONE THE
; USER WANTS NEXT (AS OPPOSED TO READ AHEAD) THEN
; WAIT FOR A NODE. OTHERWISE TERMINATE THE READ
; AHEAD
	CMP	R4,F.BDB(R0)
	BNE	80$		;BRANCH IS READ AHEAD BUFFER
	CALL	..WAND		;WAIT FOR A NODE
	BCC	45$		;TRY THE QIO AGAIN
	BR	80$		;BRANCH IF NOT OUT OF NODE ERROR
;
; R4 = BUFFER ADDRESS OF PENDING OR COMPLETE READ
; SET UP TO START A READ ON THE NEXT BUFFER
; ON RECORD DEVICE, MUST NOT START NEXT READ UNLESS PREVIOUS
; IS COMPLETE AND SUCCESSFUL
;
50$:	BITB	#FD.REC,F.RCTL(R0) ;IF RECORD DEVICE
	BEQ	55$
	CMP	#1,R5		;AND NOT THE LAST BUFFER
	BEQ	55$
	MOV	R4,R1
	CALL	..WAIT		;WAIT FOR I/O DONE
	BCS	80$		;TERMINATE READ AHEAD SCAN IF ERROR
55$:	MOV	B.VBN(R4),R1
	MOV	B.VBN+2(R4),R2
	MOV	B.NXBD(R4),R4
	DEC	R5
	BNE	20$
; END OF READ AHEAD SCAN, IF EOBB CONTAINS 0, THEN
; DESIRED VBN IS NOT READY. IF EOBB CONTAINS 1
; THEN DON'T WAIT FOR THIS VBN TO BE READY
; CALLED BY OPEN TO START READ AHEAD
80$:	TST	F.EOBB(R0)
	BNE	90$
	MOV	F.BDB(R0),R1
	.IF	EQ,R$$BBF
	CALLR	..WAST		;WAIT AND SET NREC,EOBB
	.IFF
	CALL	..WAST
	CALLR	..RSEF								; GK001
	.ENDC
90$:	CALLR	..FCSX
	.ENDC			;END OF MULTIPLE BUFFER READ AHEAD CODE
;
;
	$END	RDWAIT
;
;
	.END
