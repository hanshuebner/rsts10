	$BEGIN	PARSE,<30.14>,<PARSE THE FILE NAME>
;
; THIS  SOFTWARE  IS FURNISHED UNDER A LICENSE AND MAY
; BE USED OR COPIED ONLY IN ACCORDANCE WITH THE  TERMS
; OF SUCH LICENSE.
;
; COPYRIGHT (c) 1985, 1988, 1991 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
;
; PETER H. LIPMAN 16-AUG-73
;
; PREVIOUSLY MODIFIED BY
;
;	SHAO-SUN CHIEN
;	ANDREW C. GOLDSTEIN
;	S. RUZICH
;	T. Lekas
;	P. K. M. WEISS
;	T.Schoeller
;
; MODIFIED FOR RSX-11M-PLUS V4.1 BY :
;
;	PAUL WEISS		12-DEC-1986		30.06
;		PKW121 -- ADD CODE FOR DIRECTORY ALREADY FILLED IN BY PFCS$
;	PAUL WEISS		20-APR-1987		30.07
;		PKW124	- SAVE THREE WORDS OF DID
;	PAUL WEISS		12-JUN-1987		30.08
;		PKW131	- FIX BECAUSE GLUN NOW SETS THE FL.VCP BIT
;	PAUL WEISS		20-JUN-1987		30.09
;		PKW133	- USE O$ACCS INSTEAD OF O$TRLS FOR THIRD DID WORD
;	PAUL WEISS		27-OCT-1987		30.10
;		PKW140	- SET DIRECTORY NOT FOUND ERROR CODE
;
; MODIFIED FOR CPRSX V1.0 BY:
;
;	PAUL WEISS		13-JUN-1988		30.11
;		PKW157 - WHO'D HAVE THOUGHT 'NO SUCH DIRECTORY' WOULD BE IE.NSF?
;
;	PAUL WEISS		22-JUN-1988		30.12
;		PKW158 - WHO'D HAVE THOUGHT WILDCARD DIRS WOULD BE IE.BDI?
;
;	PAUL WEISS		16-DEC-1988		30.13
;		PKW172 - CALL ..ALUN TO SET FL.VCP FOR DIRECTORY ERRORS
;
; Modified for RSTS V10.1 by:
;
;	S. LeVan		19-Apr-1991		30.14
;		SEL001 - Merged RSTS-specific code into RSX V4.3 version.
;
;+
; SET UP FILE NAME BLOCK BY PARSING IF NECESSARY OR BY
; ASSIGNING THE LUN IF THE FILE ID IS SET UP
; CALLING SEQUENCE:
;	CALL	..STFN
; INPUTS:
;	R0=FDB
;OUTPUTS:
;	R1=FILE NAME BLOCK ADDRESS
;	R0 PRESERVED, R2-R5 DESTROYED
;-
	.IF DF L$$GCL		;LOGICAL NAME SUPPORT

	.MCALL LNBDF$
	LNBDF$			;DEFINE LOGICAL NAME OFFSETS

	.ENDC			;L$$GCL
..STFN::MOV	R0,R1
	ADD	#F.FNB,R1	;FORM R1=ADDRESS OF FILE NAME BLOCK
	TST	@R1		;IS FILE ID ALREADY SET UP
	BEQ	10$		;BRANCH IF NO
	TST	F.BDB(R0)	;IF FILE IS ALREADY OPEN
	BNE	5$		;SKIP THE ASSIGN LUN
	CALL	..ALUN		;ASSIGN THE LUN ANYWAY
5$:	RETURN
; FILE ID NOT SET UP, DO THE PARSE
10$:	MOV	F.DSPT(R0),R2
	MOV	F.DFNB(R0),R3
	BR	..PARS


;+
; PARSE ROUTINE - ACCEPTS ADDRESS OF DEVICE, DIRECTORY, AND
; FILE NAME DESCRIPTORS
;
; CALLING SEQUENCE
;	CALL	..PARS
; INPUTS:
;	R0=FDB ADDRESS
;	R1=ADDRESS OF FILE NAME BLOCK
;	R2=POINTER TO DEV, DIR, AND NAME DESCRIPTORS
;	R3=DEFAULT FILE NAME BLOCK OR ZERO IF NONE SPECIFIED
; OUTPUTS:
;	R0,R1 PRESERVED
;	R2-R5 ALTERED
;	C=0 FOR SUCCESSFUL PARSE
;	C=1 FOR FAILURE IN PARSE, F.ERR SET TO REASON.
; OPERATION:
;	FILLS IN THE FILE NAME BLOCK FROM THE STRING AND FILLS IN
; UNSPECIFIED FIELDS FROM THE DEFAULT FILE NAME BLOCK, IF PRESENT.
; ALSO ASSIGNS THE LUN TO THE SPECIFIED DEVICE
;
; ALTERNATE ENTRY POINT:
;	CALL	.PARSE
; OPERATION:
;	SAME AS ..PARS, EXCEPT IT PRESERVES ALL REGISTERS.  THIS ENTRY IS
; INTENDED FOR THE USER LEVEL CALL.
;
;-
.PARSE::.SAVR1			;SAVE REGISTERS R1-R5
	MOV	#1,F.ERR(R0)
..PARS::

; DO LOGICAL NAME PARSE
;
; THIS ROUTINE SETS ALL THE BITS IN N.STAT BEFORE DOING THE PARSE SO THAT THE
; BITS REFER TO WHAT IS ACTUALLY IN THE DSD AND NOT TO WHAT IS IN THE EXPANDED 
; STRING.  THE N.STAT WORD IS SAVED BEFORE FINISHING THE PARSE AND IS RESTORED 
; BEFORE EXITING.
;
	.IF DF L$$GCL		;LOGICAL NAME SUPPORT

	.IF DF V$$ACP		;IF THIS CAN BE USED WITH VMS ACP

	MOV	@#.FSRPT,R4	;GET POINTER TO FSR
	BIT	#AF.RLG,A.FLAG(R4) ;IF REMOTE LOGICALS, ALWAYS EXPAND
	BNE	101$		;YES, IGNORE FL.AEX BIT

	.ENDC	;V$$ACP

	BITB	#FL.AEX,F.FLG(R0) ;IS THE STRING ALREADY EXPANDED?
	BNE	10$		;YES, GO DO IT THE OLD WAY
101$:	CLR	N.STAT(R1)	;WE'RE GOING TO MESS WITH THE N.STAT BITS
	MOV	R2,-(SP)	;SAVE THE DATA SET DESCRIPTOR
	BEQ	4$		;IF NONE, JUST GO DO THE DIRECTIVE
	TST	(R2)		;IS THERE A DEVICE STRING?
	BEQ	2$		;NOPE
	BIS	#NB.DEV,N.STAT(R1) ;WE DO, SO SET THE BIT 
2$:	TST	N.DIRD(R2)	;HOW ABOUT A DIRECTORY STRING?
	BEQ	3$		;NOPE
	BIS	#NB.DIR,N.STAT(R1) ;SET THE BIT
3$:	TST	N.FNSZ(R2)	;HOW ABOUT A FILENAME STRING?
	BEQ	4$		;NOPE
	MOV	R3,-(SP)	;..PSFN WIL CLOBBER R2 AND R3
	CALL	..PSFN		;DO THE PARSE JUST TO SET THE BITS
	MOV	(SP)+,R3	;RESTORE DEFAULT NAME BLOCK
	MOV	(SP),R2		;RESTORE DSD, BUT LEAVE IT ON THE STACK
4$:	MOV	R1,-(SP)	;SAVE FNB
	MOV	R0,-(SP)	;AND FDB
	MOVB	F.LUN(R0),R0	;GET THE LUN
	CLR	R4		;USE THE PARSE AREA IN THE FSR
	CALL	..PFCS		;GO SET UP AND DO THE DIRECTIVE
	MOV	(SP)+,R0	;RESTORE FDB
	MOV	(SP)+,R1	;AND FNB
	BCC	7$		;IF CLEAN, CONTINUE
	MOV	(SP)+,R2	;RESTORE ORIGINAL DSD
	CMP	@#$DSW,#IE.SDP	;DIRECTIVE NOT SUPPORTED?
	BEQ	10$		;YES, GO DO IT THE OLD WAY
	CMP	@#$DSW,#IE.LNF	;WAS IT LOGICAL NOT FOUND?
	BEQ	5$		;YES, WE NEED TO CHECK FURTHER FOR ERROR CODE
	MOV	@#$DSW,F.ERR(R0) ;PUT THE DIRECTIVE ERROR CODE IN F.ERR
	BR	6$		;JOIN COMMON CODE
5$:	MOV	#IE.BNM&377,F.ERR(R0) ;ASSUME BAD FILENAME

	.IF DF V$$ACP	;IF VMS ACP SUPPORTED

	CMP	#ER$DNF,R4	;WAS IT DIRECTORY NOT FOUND?
	BNE	55$		;NOPE
	MOV	#IE.NSF&377,F.ERR(R0) ;DIRECTORY NOT FOUND
	BR	57$		;EXIT
55$:
	.IFTF	;V$$ACP

	CMP	#ER$DIR,R4	;WAS IT DIRECTORY ERROR?
	BNE	6$		;NOPE
56$:	MOV	#IE.BDI&377,F.ERR(R0) ;CALL IT BAD DIRECTORY SYNTAX

	.IFT	;V$$ACP
57$:
	MOV	R2,-(SP)	;SAVE R2 AND R3 BECAUSE...
	MOV	R3,-(SP)	;..ALUN DESTROYS THEM
	MOV	F.ERR(R0),-(SP)	;SAVE F.ERR BECAUSE ..ALUN WILL SET TO IS.SUC
	CALL	..ALUN		;CALL TO SET THE FL.VCP BIT IF NECESSARY
	MOV	(SP)+,F.ERR(R0)	;RESTORE ERROR CODE
	MOV	(SP)+,R3	;RESTORE...
	MOV	(SP)+,R2	;REGISTERS

	.IFTF	;V$$ACP

6$:	SEC			;MAKE SURE WE INDICATE ERROR
	RETURN			;AND RETURN
7$:	
	.IFT	;V$$ACP

	BIT	#FS$WDI,O$FLAG-O$DEVS(R2) ;WAS IT A WILDCARD DIRECTORY?
	BEQ	75$		;NOPE, OK
	MOV	(SP)+,R2	;RESTORE THE ORIGINAL DSD
	BR	56$		;CALL IT BAD DIRECTORY
75$:
	.ENDC	;V$$ACP

	MOV	N.STAT(R1),(SP)	;COPY ORIGINAL N.STAT BITS OVER ORIGINAL DSD
	MOV	R1,R4		;CLEAR OUT THE FILE NAME BLOCK
	MOV	#S.FNBW,R5	;LENGTH OF FDB
9$:	CLR	(R4)+		;CLEAR IT
	SOB	R5,9$		;ALL OF IT
	MOV	R2,-(SP)	;SAVE R2 AND R3 BECAUSE...
	MOV	R3,-(SP)	;...ALUN CLOBBERS THEM
	CALL	..ALUN		;N.DVNM IS CLEAR SO ..ALUN WILL JUST DO THE GLUN
	MOV	(SP)+,R3	;RESTORE R3
	MOV	(SP)+,R2	;AND R2

	.IF DF V$$ACP

	BITB	#FL.VCP,F.FLG(R0) ;DOES THIS FILE USE THE VMS ACP?
	BEQ	94$		;NO, CONTINUE NORMALLY
	MOV	O$NODS-O$DEVS(R2),N.DID(R1)     ;GET THE DIRECTORY ID FROM...
	MOV	O$NODA-O$DEVS(R2),N.DID+2(R1) ;THE PARSE BLOCK
	MOV	O$ACCS-O$DEVS(R2),N.DID+4(R1)	;ALL THREE WORDS OF THE DID

	.ENDC	;V$$ACP

94$:	CALL	15$		;DO THE REST OF THE PARSE AND RETURN HERE
	BIC	#^C<NB.ANS>,N.STAT(R1) ; Make sure NB.ANS makes it through.
	BIS	(SP)+,N.STAT(R1) ;PUT THE ORIGINAL BITS BACK
	RETURN

	.ENDC			;L$$GCL
				;SEL001 - Merged following code back in.
.PAGE									;**-6
10$:									;FEK001
	.IF	GT	R$RSTS						;FEK001
	CLR	-(SP)		;CLEAR A FLAG ON THE STACK		;FEK001
	.IFTF		;DO ALWAYS					;FEK001
	CALL	..PSDV		;PARSE THE DEVICE NAME			; AG001
	.IFT		;DO FOR RSTS NOW				;FEK001
	BCC	12$		;CONTINUE IF NO ERROR			;FEK001
	MOV	F.ERR(R0),(SP)	;REPLACE THE FLAG WITH THE ERROR CODE	;FEK001
12$:									;FEK001
	.IFF		;NOW FOR NOT RSTS				;FEK001
	BCS	20$							; AG001
	.IFTF		;DO ALWAYS					;FEK001
	CALL	..PSDI		;PARSE THE DIRECTORY NAME		;**-4
	.IFT		;DO FOR RSTS NOW				;FEK001
	BCC	14$		;CONTINUE IF NO ERROR			;FEK001
	TST	(SP)		;ANY PREVIOUS ERROR			;FEK001
	BNE	14$		; YES, SO REMEMBER THAT ONE		;FEK001
	MOV	F.ERR(R0),(SP)	;NO, SO STORE THIS ERROR		;FEK001
14$:									;FEK001
	.IFF		;NOW FOR NOT RSTS				;FEK001
	BCS	20$							; AG001
	.IFTF		;DO ALWAYS					;FEK001
	CALL	..PSFN		;PARSE THE FILE NAME DESCRIPTOR		; AG001
	.IFT		;DO FOR RSTS NOW				;FEK001
	BCC	16$		;NO ERROR, GO CHECK FOR PREVIOUS ERRORS	;FEK001
	TST	(SP)		;ANY PREVIOUS ERROR			;FEK001
	BNE	16$		; YES, SO REMEMBER THAT ONE		;FEK001
	MOV	F.ERR(R0),(SP)	;NO, SO STORE THIS ERROR		;FEK001
16$:	MOV	(SP)+,R5	;GET ANY PREVIOUS ERROR CODE		;FEK001
	BEQ	20$		;NO, SO ALL IS WELL JUST EXIT		;FEK001
	MOV	R5,F.ERR(R0)	;YES, SO GIVE THE CALLER THE REAL ERROR	;FEK001
	SEC			;AND FLAG IT AS AN ERROR TO THE CALLER	;FEK001
	.ENDC		;ALL DONE NOW					;FEK001
20$:	RETURN								; AG001
;
;
	$END	PARSE
;
	.END

