	.NLIST
	.MCALL	PSECT
	PSECT
	.IF	NDF	ID$$$
	.MACRO	TITLE SEG,NAME,NUM,DAT,WHOM
	.TITLE	SEG NAME
	.SBTTL	SEG NAME
	.SBTTL	EDIT NUM DONE ON DAT BY WHOM
	.NCHR	Q$$$,NUM
	.IF	EQ  Q$$$-2
	.IDENT	/'NUM'CM/
	.IFF
	.IDENT	/'NUM'/
	.ENDC
	.ENDM

	.MACRO	SUBTL	SEG,NUM,DAT,WHOM
	.SBTTL	SEG
	.SBTTL	EDIT NUM DONE ON DAT BY WHOM
	.SBTTL
	.ENDM
	.ENDC

 
	.IF	DF  ID$$$
	.LIST
	SUBTL	<COMMON PREFIX FILE FOR ALL SYSTEMS>,105,17-OCT-84,VOGEL
	.NLIST
	.IFF
	.LIST
	TITLE	COMMON,<PREFIX FILE FOR ALL SYSTEMS>,105,17-OCT-84,VOGEL
	.NLIST
	.ENDC
 
; 44 09-JAN-79 HENDERSON: ADDED ILLRES ERROR
; 45 29-JAN-79 HENDERSON: UPDATED PUSH/POP MACROS AND ERRDEF
; 46 25-APR-79 HENDERSON: ADD BP2OTS PSECT AND MOVPIC MACRO
; 47 28-MAR-81 SCARPELLI: MAKE BP2OTS PSECT READ-ONLY
; 50 29-APR-81 GALLAGHER: ADD IBUF TO END OF WORK AREA; ADD
;					IDENTIFIER FOR READ CHANNEL
; 51 06-MAY-81 GALLAGHER: INCREASE MSTACK OFFSET BY 1 WORD FOR CURCHN ENTRY
; 52 18-JUN-81 GALLAGHER: ADD XTRAM CONSTANT.
; 53 16-SEP-81 BOEBINGER: ADD LOCATION FOR DEBUGGER TO STORE CURRENT
;					STATEMENT NUMBER AND R4JSAV
;					TO SAVE R4 WHEN STACK IN USE
; 54 16-NOV-81 SCARPELLI: ADD ILLSMT ERROR
; 55 04-JAN-82 REILLY: ADD ERROR 246
; 56 22-JAN-82 KRUPINSKI: Add error 180 NOSUP
; 57 02-FEB-82 KRUPINSKI: Define RBLCK as 154
; 60 03-FEB-82 KRUPINSKI: Add error 175 BADNOD
; 61 04-FEB-82 KRUPINSKI: Add error 182 BADNET
; 62 10-FEB-82 KRUPINSKI: Add IF.EOF, CTRLZ
; 63 16-FEB-82 KRUPINSKI: Define ILFLOP
; 64 09-MAR-82 MCQUESTEN: ADD CT SPECIFIC CODE, REDIRECT DEBUGGER I/O
; 65 18-MAR-82 VOGEL: ADD DEF FUNCTION TYPE FOR M STACK ENTRIES
; 66 29-MAR-82 REILLY: OVERLAY IREMAP WITH CURCHN
; 67 21-MAY-82 REILLY: MODIFY EDIT 64
; 70 26-MAY-82 REILLY: ADD NEW OPERATING SYSTEM
; 71 03-JUN-82 REILLY: REDID THE OPEN BLOCK
; 72 10-JUN-82 REILLY: ADD ERROR 185
; 73 11-JUN-82 BOEBINGER: ADD LOCATIONS CURNOD AND ERRNOD, REMOVE XABSTX
;			  CHANGE M-STACK SIZE FOR DEF'S AND CALLS
; 74 24-JUN-82 BOEBINGER: ADD ERROR 186 - IMPROPER ERROR RECOVERY
; 75 28-JUL-82 KRUPINSKI: O.NON IS MULTIPLY DEFINED....
; 76 09-AUG-82 VOGEL: CHANGE FABSTX OFFSET TO CTEROR
; 77 16-SEP-82 REILLY: ADD CT AS OPERATING SYSTEM
;100 23-NOV-82 REILLY: DEFINE USE MAX CHANNEL NUMBER
;101 06-DEC-82 BOEBINGER: SET SIZOTS = 800.
;102 17-FEB-83 REILLY: ADD NEW ERROR MESSAGE STRLNG
;103 27-APR-84 VOGEL: WE'LL NEVER BE PIC, SO CHANGE MACRO MOVPIC
;		TO SAVE SOME SPACE (EXCEPT ON CT)
;104 02-MAY-84 VANDEPAS: ADD DATA SPACE PSECT
;105 17-OCT-84 VOGEL: RE-DO M STACK
;
;
	.MACRO PSECT
	.PSECT	BP2OTS,RO,I,LCL,REL,CON	; *47*46* ADD PSECT FOR RESLIB'S
	.ENDM	PSECT


	.MACRO PSECTD
	.PSECT	BP2OTD,RO,D,LCL,REL,CON	; *104* D SPACE PSECT
	.ENDM	PSECTD
;

	.NLIST	TTM,BEX,MEB
	.DSABL	CRF


;	NOSSCK=1
;
; MACRO DEFINITIONS
;
	.MACRO	POP	ARG
	.IF	NB	<ARG>
	 MOV	(SP)+,ARG
	.IFF
	TST	(SP)+
	.ENDC
	.ENDM	POP

	.MACRO	PUSH	ARG
	.IF	NB	<ARG>
	 MOV	ARG,-(SP)
	.IFF
	CLR	-(SP)
	.ENDC
	.ENDM	PUSH

	.MACRO	CALL5	ARG
	 JSR	R5,ARG
	.ENDM	CALL5
 
	.MACRO	GETOTS	ARG
	 .GLOBL	$OTSV
	 MOV	@#$OTSV,ARG
	.ENDM	GETOTS
 
	.MACRO	ERROR	ERRNUM
	 TRAP+ERRNUM
	.ENDM	ERROR
 
	.MACRO	CALLI	A
	 MOV	R3,-(SP)
	 GETOTS	R3
	 MOV	AJMPV(R3),R3
	 MOV	IOFLG2(R0),-(SP)
	 BIC	#177770,@SP
	 ADD	(SP)+,R3
	 JSR	PC,@A(R3)
	 MOV	(SP)+,R3
	.ENDM
 
	.MACRO	CALLIR	B
	 MOV	R3,-(SP)
	 GETOTS	R3
	 MOV	AJMPV(R3),R3
	 MOV	IOFLG2(R0),-(SP)
	 BIC	#177770,@SP
	 ADD	(SP)+,R3
	 ADD	B,R3
	 JSR	PC,@0(R3)
	 MOV	(SP)+,R3
	.ENDM
 
	.MACRO	FILJPV  ORG,FUN,SYMB
	.MCALL	PSECT
	 .PSECT	$ICIO1,D,RW,GBL,OVR
	 .IIF NDF  ..02$, ..02$=.
	 .IIF IDN ORG,VIR  ..ORG$=0
	 .IIF IDN ORG,SEQ  ..ORG$=2
	 .IIF IDN ORG,REL  ..ORG$=4
	 .IIF IDN ORG,IDX  ..ORG$=6
	 .=..02$+..ORG$+FUN'F$
	 .WORD	SYMB
	PSECT
	.ENDM	FILJPV

	.IF	DF	CT			; *103* FOR CT
						; *103* LEAV ALONE
	.MACRO	MOVPIC	CNST,DEST
	MOV	PC,DEST
	ADD	CNST-.,DEST
	.ENDM	MOVPIC

	.IFF					; *103* FOR ALL OTHERS

	.MACRO	MOVPIC	CNST,DEST
	MOV	CNST,DEST			; *103* CHANGE TO THIS
	.ENDM	MOVPIC

	.ENDC					; *103* END OF CONTITION


	.SBTTL	I/O BUFFER DEFINITIONS

; RAB DEFINITIONS
 
	RABSTR	= 4		; TWO WORD PARAM BLOCK ON TOP

	BYTCNX	=  6+RABSTR	; SPECIAL 'BYTCNT' FOR INPUT
	CURLOX	= 10+RABSTR	; SPECIAL 'CURLOC' FOR INPUT
 
	RECLEN	= 24+RABSTR	; SIZE OF BUFFER OR MAP		(RB$USZ)
	LENGTH	= RECLEN
	RECADR	= 26+RABSTR	; POINTER TO THE MAP OR BUFFER	(RB$UBF)
	BYTCNT	= 30+RABSTR	; RECORDSIZE			(RB$RSZ)
	CURLOC	= 32+RABSTR	; CURRENT BUFFER LOCATION
	RECAD2	= 32+RABSTR	; ALSO RECORD BUFFER		(RB$RBF)
	CURBLK	= 46+RABSTR	; CURRENT BLOCK-REL/BLK I/O	(RB$BKT)
;				; TWO WORDS LO ORDER FIRST
	TMPRFM	= 60+RABSTR	; TEMP STORE FOR REC-FORM	(RB$RT0)
	TMPORG	= 61+RABSTR	; TEMP STORE FOR FILE ORGANIZATION
	TMPBLS	= 62+RABSTR	; TEMP STORE FOR BLOCK SIZE
	TMPBKS	= 64+RABSTR	; TEMP STORE FOR BUCKET SIZE
	TMPMBF	= 66+RABSTR	; TEMP STORE FOR MULTI-BUF

	RABLEN	= 120		; RECORD ACCESS BLOCK LENGTH

	HEDSTR	= RABLEN+RABSTR	; START OF HEADER
 
; I/O BUFFER HEADER DEFINITION


	TEMP1	= HEDSTR	; TEMPORARY STORE
	MARGIN	= HEDSTR+2	; (BYTE) TERM RIGHT MARGIN
	DEFMRG	= MARGIN+1	; (BYTE) DEFAULT TERM MARGIN
	CURALQ	= HEDSTR+4	; *40* (RSX ONLY) CURRENT ALLOCATION
	RBYTES	= HEDSTR+4	; REMAINING BYTES
	FMTCHR	= HEDSTR+6	; VERT FORMAT CHAR (RSX ONLY)
	CURALX	= HEDSTR+7	; *40* (RSX ONLY) HI BYTE OF CURALQ
	SLOT 	= HEDSTR+10	; CHANNEL NUMBER
		READCH = -2	; *50* CHANNEL NUMBER FOR READS IS -2
	NKEYS	= HEDSTR+11	; NUMBER OF KEYS
	ODTSUB  = 4		; ODT SUBMODE SET (RSX ONLY)
	IOFLG1	= HEDSTR+12	; IOFLAGS
	IOFLG2	= HEDSTR+14	; IOFLAGS
	LSTBLK	= HEDSTR+16	; LAST BLOCK (RSX ONLY)
;				; TWO WORDS (RSX ONLY)
	POSITN	= HEDSTR+22	; LINE POSITION
	ALTCHN	= HEDSTR+24	; *43* ALTERNATE CHANNEL PTR
	PBFPTR	= HEDSTR+26	; *43* PERMANENT BUFFER POINTER
	BSTART	= HEDSTR+30	; *43* START OF DATA

; IOFLG1 I/O FLAGS WORD 1 DEFINITION
; THIS WORD IF FILLED DURING I/O OPERATIONS AND AT OPEN TIME

	IF.IIN	=     1		; INPUT		
	IF.LIS	=     2		; LINPUT
	IF.ILS	=     4		; INPUT LINE
	IF.INP	=     7		; ANY INPUT
	IF.POS	=    10		; MONITOR KEEPS LINE POSITION 
	IF.ROK	=    10		; *40* VIRTUAL BLOCK READ OKAY
	IF.WRT	=    20		; BUFFER WRITE FLAG
	IF.FRC	=    40		; FORCIBLE DEVICE
	IF.TRM	=   100		; TERMINAL DEVICE
	IF.RND	=   200		; RANDOM ACCESS DEVICE	
	IF.IPT	=   400		; IPT$ DONE
	IF.AMP	=   400		; '&' SEEN AT EOL
	IF.VIR	=  1000		; VIRTUAL ARRAY FLAG
	IF.BIO	=  2000		; BLOCK I/O USAGE
	IF.MAT	=  4000		; MATRIX
	IF.NCR	= 10000		; NO CR-LF NEEDED ON OUTPUT
	IF.FLB	= 20000		; FULL BUFFER DEVICE(MUST DUMP ALL BUFFER)
	IF.EOF	= 40000		; END OF FILE WAS REACHED
	IF.NEG	=100000		; *41* NEG CHAN # IN CLOSE


;	VIRTUAL I/O RING BUFFER OFFSETS
;
	IOFLGX	= -6		; IOFLG1
	CURBMX	= -5		; CURBLK+2
	CURBKX	= -4		; CURBLK
	POSITX	= -2		; POSITN (POINTER TO NEXT HEADER)
;

; IOFLG2 I/O FLAGS WORD 2 DEFINITION
;  ALL OF THIS WORD FILLED IN AT OPEN TIME

	IF.BLK	=      0	; ORGANIZATION VIRTUAL BLOCK
	IF.SEQ	=      2	; ORGANIZATION SEQUENTIAL
	IF.REL	=      4	; ORGANIZATION RELATIVE
	IF.IND	=      6	; ORGANIZATION INDEXED SEQUENTIAL
	IF.RMS	=      6	; RMS FILES
	IF.TRF	=     10	; TERMINAL FORMAT FILE

	IF.UDF	=     20	; UNDEFINED RECORD FORMAT
	IF.FIX	=     40	; FIXED RECORD FORMAT
	IF.VAR	=    100	; VARIABLE RECORD FORMAT
	IF.VFC	=    200	; VARIABLE-WITH-FIXED-CONTROL
	IF.STR	=    400	; STREAM ASCII FORMAT

	IF.UNS	=   1000	; ORGANIZATION IS UNSPECIFIED
	IF.FEX	=   2000	; FILE EXISTS
	IF.USM	=   4000	; USER MAP SUPPLIED
	IF.SMP	=  10000	; MAP BUFFER IS SYSTEM'S
	IF.IGE	=  20000	; IGNORE ANY ERRORS
	IF.NKY	=  40000	; NO KEYS SPECIFIED(DEFAULT INDEXED)
	IF.ECC	= 100000	; EXPLICIT CARRIAGE CONTROL (CR-LF ALLOWED)
	IF.CON  = 100000	; FILE IS MULTI-STREAM CONNECTED

	.SBTTL	OPEN PARAMETERS


; OPEN PARAMETER BLOCK


;BLOCK OFFSET	! SEQUENTIAL	! RELATIVE	! INDEXED	!VIRTUAL
		;---------------!---------------!---------------!---------------
O.FID = 0	; FILE ID	! FILE ID	! FILE ID	! FILE ID
		;---------------!---------------!---------------!---------------
;O.FID+ 2	; FILE ID	! FILE ID	! FILE ID	! FILE ID
		;---------------!---------------!---------------!---------------
;O.FID+ 4	; FILE ID	! FILE ID	! FILE ID	! FILE ID
		;---------------!---------------!---------------!---------------
O.RTY = 6	;RECORDTYPE	!RECORDTYPE	!RECORDTYPE	!  0
		;---------------!---------------!---------------!---------------
O.LUN = 10	; CHANNEL #	! CHANNEL #	; CHANNEL #	! CHANNEL #
		;---------------!---------------!---------------!---------------
O.NAM = 12	;FILE SPEC 	!FILE SPEC	!FILE SPEC	!FILE SPEC
		;---------------!---------------!---------------!---------------
O.MAP = 14	; MAP		!MAP		!MAP		!MAP	
		;---------------!---------------!---------------!---------------
O.REC = 16	;RECORDSIZE	!RECORDSIZE	!RECORDSIZE	!RECORDSIZE
		;---------------!---------------!---------------!---------------
O.MSZ = 20	;MAPSIZE	!MAPSIZE	!MAPSIZE	!MAPSIZE
		;---------------!---------------!---------------!---------------
O.FIL = 22	;FILESIZE	!FILESIZE	!FILESIZE	!FILESIZE
		;---------------!---------------!---------------!---------------
O.CLU = 24	;CLUSTERSIZE	!CLUSTERSIZE	!CLUSTERSIZE	!CLUSTERSIZE
		;---------------!---------------!---------------!---------------
O.BKS = 26	;BUCKETSIZE	!BUCKETSIZE	!BUCKETSIZE	!BUCKETSIZE
		;---------------!---------------!---------------!---------------
O.BLK = 30	;BLOCKSIZE	!  0		!  0		!  0
		;---------------!---------------!---------------!---------------
O.MODS= 32	;  0		!  0		!  0		!MODE
O.BUF= 32	;BUFFER		!BUFFER		!BUFFER		!BUFFER
		;---------------!---------------!---------------!---------------
O.CON = 34	;CONNECT	!CONNECT	!CONNECT	!  0
		;---------------!---------------!---------------!---------------
O.DFN = 36	;DEFAULTNAME	!DEFAULTNAME	!DEFAULTNAME	!DEFAULTNAME
		;---------------!---------------!---------------!---------------
O.EXS = 40	;EXTENDSIZE	!EXTENDSIZE	!EXTENDSIZE	!EXTENDSIZE
		;---------------!---------------!---------------!---------------
O.USO = 42	;USEROPEN	!USEROPEN	!USEROPEN	!USEROPEN  
		;---------------!---------------!---------------!---------------
O.KNM = 44					;# KEYS		!
;						;---------------!
;O.KSZ = 46					;MAX KEYSIZE	!  ** THIS FIELD IS NO LONGER NEEDED **
;						;---------------!
O.KHD = 46					;KEYHEADER LIST	!
						;---------------!

OP.SIZ	= 44		; SIZE OF FIXED PORTION OF OPEN PAR BLOCK

; FILE IDENTIFICATION WORDS


;---------------------------------------!-------------------------------!
;	FILE ORGANIZATION (O.ORG)	!	MODE (O.MOD)		!
;---------------------------------------!-------------------------------!
;	RECORD FORMAT (O.FMT)		!	ACCESS (O.ACC)		!
;---------------------------------------!-------------------------------!
;	SPAN (O.SPN)			!	ALLOW (O.ALW)		!
;---------------------------------------!-------------------------------!




O.RTY	= 6		; RECORD ATTRIBUTE

	O.DFT	= 0	; DEFAULT
	O.FTN	= 1	; RECORDTYPE FORTRAN
	O.LST	= 2	; RECORDTYPE LIST
	O.NONE	= 3	; RECORDTYPE NONE		*75* NON -> NONE
	O.ANY	= 4	; RECORDTYPE ANY

O.MOD	= 0		; OPEN FOR MODE

	O.NUL	= 0	;NULL
	O.OUT	= 1	;OUTPUT
	O.INP	= 2	;INPUT

O.ORG	= 1		; FILE  ORGANIZATION

	O.TRM	= 0	;TERMINAL FORMAT (OP SYS DEPENDENT)
	O.VIR	= 1	;VIRTUAL BLOCK
	O.SEQ	= 2	;SEQUENTIAL
	O.REL	= 3	;RELATIVE
	O.IND	= 4	;INDEXED
	O.UNS	= 5	;UNSPECIFIED

O.ACC	= 2		; ACCESS

;		  0	;MODIFY (DEFAULT)
	O.MFY	= 1	;MODIFY
	O.WRI	= 2	;WRITE
	O.RED	= 3	;READ
	O.TRN	= 4	;TRUNCATE(SCRATCH)
	O.APP	= 5	;APPEND


O.RMT	= 3		; RECORD FORMAT

	O.UDF	= 0	;UNDEFINED
	O.FIX	= 1	;FIXED
	O.VAR	= 2	;VARIABLE
	O.VFC	= 3	;VFC
	O.STR	= 4	;STREAM

O.ALW	= 4		; ALLOW

;		  0	;ALLOW READ (DEFAULT)
	O.MFY	= 1	;ALLOW MODIFY
	O.WRI	= 2	;ALLOW WRITE
	O.RED	= 3	;ALLOW READ
	O.TRN	= 4	;ALLOW TRUNCATE
	O.NON	= 6	;ALLOW NONE

O.SPN	= 5		; SPAN

	O.SPA	= 0	;SPAN
	O.NSP	= 1	;NO SPAN
	O.CTG	= 2	;CONTIGUOUS
	O.NRW	= 4	;NO REWIND(ANSI TAPE FILES ONLY)
	O.TMP	= 8.	;TEMPORARY FILES
	O.TSK	= 16.	; TASK FILES FOR RSTS/E


; KEY HEADER

;-------------------------------!-------------------------------!
;	KEY DATATYPE		!	KEY NUMBER		!
;-------------------------------!-------------------------------!
;	KEY SEGMENT(S)		!	DUPLICATE/CHANGE	!
;-------------------------------!-------------------------------!
;			  O F F S E T				!
;-------------------------------!-------------------------------!
;			     L  E  N				!
;---------------------------------------------------------------!
;				.				!
;				.				!
;				.				!
;---------------------------------------------------------------!
;			  O F F S E T 				!
;---------------------------------------------------------------!
;			     L  E  N				!
;---------------------------------------------------------------!

K.NUM	= 0		; PRIMARY  = 0 AND ALTERNATE KEYS 1 THRU 254
 
K.DTY	= 1		; DATATYPE OF KEY

	K.STR	= 0	; STRING DATATYPE
	K.INT	= 1	; SIGNED WORD
	K.LNG	= 2	; SIGNED LONGWORD
 
;	SEGMENTED KEYS

K.SEG	= 3		; NUMBER OF SEGMENTS FOR THE KEY

;	DUPLICATE KEYS

K.DUP	= 3		;  DUPLICATE KEY
	K.NDP	= 0	;NO DUPLICATE KEYS ALLOWED
	K.ADP	= 1	;DUPLICATE KEYS ALLOWED

; 	CHANGE KEYS

K.CHG	= 2		; CHANGE KEYS

	K.NCG	= 0	;NO CHANGES ALLOWED
	K.ACH	= 2	;CHANGES ALLOWED


K.OFF	= 0
 
K.LEN  	= 2


KH.SIZ	= 4	;SIZE OF FIX PORTION OF KEY BLOCK
KH.SGS  = 4	;SIZE OF EACH PORTION THE SEGMENT

; JUMP VECTOR OFFSETS
 
RMSIF$	= 0		; ADDR OF RMS INIT ROUTINE IF USED
UOPF$	= 4		; *31* SPECIAL ENTRY FOR ORGANIZATION UNDEFINED
VRDF$	= 6		; SPECIAL ENTRY FOR VIRTUAL READ
OUTF$	= 10		; OUTPUTS
INPF$	= 20		; INPUTS
OPNF$	= 30		; OPENS
CLSF$	= 40		; CLOSES
GTSF$	= 50		; GET SEQUENTIAL
GTRF$	= 60		; GET RANDOM
PTSF$	= 70		; PUT SEQUENTIAL
PTRF$	= 100		; PUT RANDOM
FNSF$	= 110		; FIND SEQUENTIAL
FNRF$	= 120		; FIND RANDOM
UPDF$	= 130		; UPDATE
DELF$	= 140		; DELETE
RESF$	= 150		; RESTORE
ULKF$	= 160		; UNLOCK
;SPARE	= 170		; SPARE
IC1LEN	= 200		; LENGTH OF THE JUMP VECTOR

;
; BASIC+2 OTS WORK AREA OFFSETS
;

	LINNUM	= 0.		; LINE NUMBER

	NMPTR	= 2.		; PTR TO MODULE NAME ( 3 ASCII WORDS )

	MFPTR	= 4.		; M STACK FPTR
	MLEN	= 6.		; M STACK LEN
	MOFST	= 8.		; M STACK OFFSET

	TOPSTR	= 10.		; ADR OF TOP OF STRINGS + FREE SPACE
	BOTSTR	= 12.		; ADR OF BOTTOM OF STRINGS
	TOPIOB	= 14.		; ADR OF TOP OF I/O BUFFER AREA
	BOTIOB	= 16.		; ADR OF BOTTOM OF I/O BUFFER AREA
				;	AND BOTTOM OF FREE SPACE

	CHATBL	= 18.		; ADR OF CHANNEL NUMBER TABLE
	IREMAP	= 20.		; *66* OVERLAY CURCHN WITH THE REMAP LOCAL
				; *66* STORAGE PTR BECAUSE THIS LOCATION IS
				; *66* SAVED ON THE M-STACK DURING FUNCTION
				; *66* CALLS
	CURCHN	= 20.		; ADR OF CURRENT I/O BUFFER
	IBUF	= 22.		; STASH BUFFER

	SDATA	= 24.		; START OF DATA AREA
	EDATA	= 26.		; END OF DATA AREA
	DATLOC	= 28.		; CURRENT DATA LOCATION
	DATHDR	= 30.		; READ HEADER POINTER
	JOBNUM	= 32.		; JOB NUMBER(TTY # ON RSX)
	OPSYS	= 33.		; OPERATING SYSTEM
		RSXSYS	= 1	; RSX-11M 
		RSSSYS	= 2	; RSX-11S
		IASSYS	= 3	; IAS
		RSTSYS	= 4	; RSTS/E
		TPSSYS	= 5	; TPS
 		CTSYS	= 11;	; *77* P/OS
		
	AJMPV	= 34.		; ADDRESS OF THE I/O JUMP VECTOR IN 
				;  USER SPACE -  ADDR($ICIO1)
;	XABSTX	= 36.		; POINTER TO XAB'S SET UP BY XABSET
				; *73* REMOVED

				; *73* NOTE - FOR THE FOLLOWING, A NODE
				; *73* IS USED TO DENOTE A FUNCTION NUMBER
	CURNOD  = 36.		; *73* NUMBER OF THE CURRENT NODE
	ERRNOD  = 37.		; *73* NODE NUMBER WHERE ERROR OCCURRED

	LOSTAK	= 38.		; HOLDS THE LOWEST STACK ADDRESS
	TMPW11	= 40.
	CTEROR	= 42.		; *76* USED TO HOLD LOCATION OF 
				; *76* CT ERROR ROUTINE. USED DURINT
				; *76* ON ERROR HANDLING, CT ONLY!!!
	TMPW13	= 44.
;	COTHRD  = 44.		; *** UNUSED ***

	DFLAG	= 46.		; ARITHMETIC FLAG ( 2 = REAL, 1 = DBLE )
	R4JSAV	= 48.		; *53* CONVENIENT PLACE TO SAVE R4
	SCAVAL	= 50.
	SCAFAC	= 52.		; NUMER1 = 52.
				; NUMER2 = 54.
				; NUMER3 = 56.
				; NUMER4 = 58.
	SCATHP	= 60.		; TEMP FOR THREAD POINTER-R4 = 60.
	SCARTA	= 62.		; TEMP FOR RETURN ADDRESS IN SCALE ROUTINE
				; NOTE:  THIS IS SAME AS NEXT LOCATION, BUT
				; THERE IS NO CONFLICT SINCE IT IS CLEARED.
;		  62.		; NOT USED

; NOTE: THE FOLLOWING 4 LOCS MUST BE CONTIGUOUS
;
	FPTR1	= 64.		; TEMP FPTR TO BE MARKED NOT-IN-USE
	LEN1	= 66.		; TEMP LEN  TO BE MARKED NOT-IN-USE
	FPTR2	= 68.		; TEMP FPTR TO BE MARKED NOT-IN-USE
	LEN2	= 70.		; TEMP LEN  TO BE MARKED NOT-IN-USE

	ONERGO	= 72.		; HOLDS ON ERROR GO TO ADR

;
; NOTE: FOLLOWING 10. WORDS MUST BE CONTIGUOUS
;
	PUADR	= 74.		;PRINT USING STRING ADDR
	PULEN	= 76.		;PRINT USING STRING LEN
	PUTBL	= 78.		;PRINT USING TABLE ( 16 WORDS )

	ERRNUM	= 94.		; ERROR NUMBER
	ERLNUM	= 96.		; ERROR LINE NUMBER
	ERLPTR	= 98.		; ERROR LINE POINTER
	CURSTM	= 100.		; *53* CURRENT STATEMENT NUMBER (USED
				;	BY THE DEBUGGER)

	STATUS	= 102.		;OPEN STATUS
	RECOUN	= 104.		;#BYTES READ

	BSTRP	= 106.		; DEBUGGER
	BSTRL	= 108.
	STCNT	= 110.
	FLGDP	= 112.
	TRCP	= 114.
	TRCL	= 116.
	SYMTBL	= 118.		; SYMBOL TABLE PTR

	WATIM	= 120.		; WAIT TIME FOR WAIT AND READ OPERATIONS
	RNDML	= 122.		; LOW ORDER WORD OF RANDOM NUMBER SEED
	RNDMH	= 124.		; HIGH ORDER WORD OF RANDOM NUMBER SEED
 
; THE FOLLOWING 4 WORDS ARE USED ONLY BETWEEN ARRAY MOVES AND CAN 
;     BE REUSED ANY OTHER TIME.
 
	CURS1	= 126.		; CURRENT SUBSCRIPT 1
	LIMS1	= 128.		; UPPER LIMIT SUBS 1
	CURS2	= 130.		; CURRENT SUBSCRIPT 2
	LIMS2	= 132.		; UPPER LIMIT SUBS 2
 
	ERN1	= 134.		; MODULE NAME WHERE ERROR OCCURRED
	ERN2	= 136.		; MODULE NAME WHERE ERROR OCCURRED
	ERN3	= 138.		; MODULE NAME WHERE ERROR OCCURRED

	IOFLHD	= 140.		; I/O FREE LIST HEAD
;		  142.		; I/O FREE LIST WD 2
	BITWRD	= 144.		; BIT WORD FROM COMPILER TO $INITM(ALSO STATUS)
				;	BIT 0	1 = ENTERED VIA RUN
		DEBGR	=     2	;	BIT 1	1 = DEBUGGER PRESENT
		GOBACK  =   100	; *105*	BIT 6	1 = ON ERROR GO BACK ACTIVE
		DOPMD	=   200 ;	BIT 7	1 = REQUEST PMD(rsx)
		SLPST	=   400	;	BIT 8	1 = IN SLEEP STATE
		MATOPR	=  1000 ;	BIT 9	1 = IN A MATRIX OPERATION
		EPEND	=  2000 ;	BIT 10	1 = ERROR PENDING
		FPAST	=  4000	;	BIT 11	1 = IN FPU AST MODE
		FLFDFL	= 10000	;	BIT 12	1 = FILE "FIELDED"
		VRERIT	= 20000	;	BIT 13	1 = VIRTUAL OPERATION IS A WRITE
		CRITAL	= 40000 ;	BIT 14  1 = IN A CRITICAL SECTION
		CCPEND	=100000 ;	BIT 15	1 = CTRL/C PENDING
 
; SEE ABOVE FOR ARRAY MOVES
 
	LOPADR	= 146.		; LOOPBACK ADDRESS
	SAVR4	= 148.		; TEMP STORAGE FOR POINTER
 
	THREAD	= 150.		; DEBUGGER THREAD BLOCK
	CVTTHR	= THREAD+16.	; 8 WDS
	FINMOV	= THREAD+42.	; 21 WDS
	IND	= THREAD+48.	; 24 WDS
	SUBSAV	= THREAD+60.	; SAVE AREA FOR SUBROUTINE NAME FOR UNR UNBREAK
	INTSAV	= THREAD+60.	; INTEGER/FLOAT/STRING HEADERS
	FLTSAV	= THREAD+60.	;
	TYPE	= THREAD+68.	;
	FLGS	= THREAD+70.	;
	LOOKAD	= THREAD+72.	;
	SPSAV	= THREAD+74.	; SP SAVE CELL FOR DEBUGGER
	R4SAV	= THREAD+76.	; DEBUGER ENTRY PSEUDO PC (R4)
	DEBUG	= THREAD+78.	; 0 OR ADDRESS OF STP$ IN DEBUGGER (WHEN PRESENT)
	ONERDB	= THREAD+80.	; ADDRESS OF ERROR ENTRY TO DEBUG

	SBVAL	= THREAD+82.	; TEMPS FOR MISC OPERATIONS
	SBADD	= SBVAL+12.	; 6 WDS
	DET	= SBADD+8.	; 4 WDS
	MTMP1	= DET +2	; 1 WD
	MTMP2	= MTMP1 +2	;
	MTMP3	= MTMP2 +2	;
	MTMP4	= MTMP3 +2	;
	MTMP5	= MTMP4 +2	;
	MTMP6	= MTMP5 +2	;
	MTMP7	= MTMP6 +2	;
	MTMP8	= MTMP7 +2	;
	MTMP9	= MTMP8 +2	;
	MTMP10	= MTMP9 +2	;
	MTMP11	= MTMP10+2	;
	MTMP12	= MTMP11+2	;
	MTMP13	= MTMP12+2	;
	MTMP14	= MTMP13+2	;
	MTMP15	= MTMP14+2	; *64* LUN # FOR DEBUGGER I/O

	TMPHDR	= MTMP15+2	; TEMPORARY STRING HDR (2 WDS).
				; UNSED BY MOS$01 ENTRY POINT ONLY.
	BEGIBF	= TMPHDR+4	; *50* MUST BE LAST WORD OF OTS WORK AREA
				; FOR RSX SYSTEMS THERE MUST BE 512 BYTES
				; BETWEEN HERE AND THE END (FOR READ ERR FILE)
				; FOR RSTS THERE MUST BE AT LEAST SIZIBF BYTES
				; BOTH SYSTEMS USE THE FIRST SIZIBF BYTES FOR
				; IBUF.
		SIZIBF	= 256.		; SIZE OF IBUF IN WORDS
	BEGRHD	= BEGIBF+SIZIBF	;*50* BEGINNING OF THE READ DATA HEADER
;
; SIZES
;
	SIZOTS	= 800.		; *101*50* SIZE OF OTS
	SIZCHT	= 16.*4.	; SIZE OF CHANNEL TABLE ( 4 BYTES EACH )
	SIZHDR	= BSTART	; HEADER SIZE
	SIZTBF	= SIZHDR+256.	; SIZE OF HEADER +MAX LEN IS TERMINAL
				; BUFFER SIZE
 	SIZMG	= 8.		; *105* SIZE OF GOSUB ENTRY ON MSTACK IN BYTES
 	SIZMDS	= 10.		; *105* SIZE OF DEF* ENTRY ON MSTACK IN BYTES
 	SIZMD	= 14.		; *105* SIZE OF DEF ENTRY ON MSTACK IN BYTES
 	SIZMC	= 24.		; *105* SIZE OF CALL ENTRY ON MSTACK IN BYTES
	SIZMST	= 8.*SIZMG+2.	; *105* INITIAL SIZE OF M STACK, PLUS 2 BYTES FOR INITIAL SP

 ;*105*	XTRAM	= 12.		; *73* *52* EXTRA M-STACK NEEDED FOR CALL STATEMENTS
		; *52* THIS USED TO BE GOTTEN BY THE EXPRESSION <SIZM*2>,
		; *52* BUT THIS EXPRESSION WON'T WORK WHEN THE BASE M-STACK
		; *52* SIZE IS CHANGED.
 ;*105*	DEXTRA = 6.		; *73* *65* SIZE OF DEF M STACK ENTRY
;
; SIZALL IS THE TOTAL SIZE OF THE OTS WORK AREA AT INITIALIZATION
;
	SIZALL	= SIZCHT +SIZTBF +SIZMST+20.
		; *50* IBUF AND READ DATA HEADER NOW PART OF STATIC WORK AREA
		; 20 BYTES(10 WDS) TO INSURE SOME STRING SPACE

; BASIC+2 ERROR DEFINITIONS
;

;
; ERROR NUMBER IS IN IOSTS
;
	IOERR	= 0		; I/O ERROR
;
; ERROR NUMBER SAME AS BASIC PLUS
;
	BADDIR	= 1.		; BAD DIRECTORY FOR DEVICE
	BADNAM	= 2.		; ILLEGAL FILE NAME
	INUSE	= 3.		; ACCOUNT OR DEVICE IN USE
	NOROOM	= 4.		; NO ROOM FOR USER ON DEVICE
	NOSUCH	= 5.		; CAN'T FIND FILE OR DEVICE
	NODEVC	= 6.		; NOT A VALID DEVICE
	NOTCLS	= 7.		; I/O CHANNEL ALREADY OPEN
	NOTAVL	= 8.		; DEVICE NOT AVAILABLE
	NOTOPN	= 9.		; I/O CHANNEL NOT OPEN
	PRVIOL	= 10.		; PROTECTION VIOLATION
	EOF	= 11.		; END OF FILE ON DEVICE
	ABORT	= 12.		; FATAL SYSTEM I/O FAILURE
	DATERR	= 13.		; USER DATA ERROR ON DEIVCE
	HNGDEV	= 14.		; DEVICE HUNG OR WRITE LOCKED
	HNGTTY	= 15.		; KEYBOARD WAIT EXHAUSTED
	FIEXST	= 16.		; NAME OR ACCOUNT NOW EXISTS
	DTOOOF	= 17.		;TOO MANY OPEN FILES ON UNIT
	BADFUO	= 18.		; ILLEGAL SYS() USAGE
	INTLCK	= 19.		; DISK BLOCK IS INTERLOCKED
	WRGPAK	= 20.		; PACK ID'S DON'T MATCH
	NOTMNT	= 21.		; DISK PACK IS NOT MOUNTED
	PAKLCK	= 22.		; DISK PACK IS LOCKED OUT
	BADCLU	= 23.		; ILLEGAL CLUSTER SIZE
	PRIVAT	= 24.		; DISK PACK IS PRIVATE
	INTPAK	= 25.		; DISK PACK NEEDS CLEANING
	BADPAK 	= 26.		; FATAL DISK PACK MOUNT ERROR
	DETKEY	= 27.		; I/O TO DETACHED KEYBOARD
	CTRLCE	= 28.		; PROGRAMMABLE CONTROL C TRAP
	SATTBD	= 29.		; CORRUPTED FILE STRUCTURE
	DEVNFS	= 30.		; DEVICE NOT FILE STRUCTURED
	BADCNT	= 31.		; ILLEGAL BYTE COUNT FOR I/O
	NOBUFS	= 32.		; NO BUFFER SPACE AVAILABLE
	B.4	= 33.		; UNIBUS TIMEOUT FATAL TRAP
	B.10	= 34.		; RESERVED INSTRUCTION TRAP
	B.250	= 35.		; MEMORY MANAGEMENT VIOLATION
	B.STAK	= 36.		; SP (R6) STACK OVERFLOW
	B.SWAP	= 37.		; DISK ERROR DURING SWAP
	MAGSEL	= 38.		; MAGTAPE SELECT ERROR
	MAGRLE	= 40.		; RSTS MAG TAPE RECORD LENGTH
	VCSERR	= 42.		; VIRTUAL ARRAY BUFFER TOO LARGE(SMALL?)
	VCAERR	= 43.		; VIRTUAL ARRAY NOT ON DISK
	SIZERR	= 44.		; MATRIX OR ARRAY TOO BIG
	VCOERR	= 45.		; VIRTUAL ARRAY NOT YET OPEN
	BSERR	= 46.		; ILLEGAL I/O CHANNEL
	LINERR	= 47.		; LINE TOO LONG
	FLTERR	= 48.		; FLOATING POINT ERROR
	FMTERR	= 50.		; DATA FORMAT ERROR
	FIXERR	= 51.		; INTEGER ERROR
	BDNERR	= 52.		; ILLEGAL NUMBER
	LOGERR	= 53.		; ILLEGAL ARGUMENT IN LOG
	SQRERR	= 54.		; IMAGINARY SQUARE ROOT
	SUBERR	= 55.		; SUBSCRIPT OUT OF RANGE
	MINVER	= 56.		; CAN'T INVERT MATRIX
	ODD	= 57.		; OUT OF DATA
	ONBAD	= 58.		; ON STATEMENT OUT OF RANGE
	NEDERR	= 59.		; NOT ENOUGH DATA IN RECORD
	IOLERR	= 60.		; INTEGER OVERFLOW, FOR LOOP
	DIVBY0	= 61.		; DIVISION BY 0
	FZDIV	= 61.		; ** DIVISION BY 0
	FIELDE	= 63.		; FIELD OVERFLOWS BUFFER
	NORACS	= 64.		; NOT A RANDOM ACCESS DEVICE
	NOTMTA	= 65.		; ILLEGAL MAGTAPE USAGE
	EXITTM	= 72.		; RETURN WITHOUT GOSUB
	EXITNR	= 73.		; ILLEGAL RETURN FROM A FUNCTION
	FUNERR	= 88.		; ARGUMENTS DON'T MATCH
	SUBARG	= 88.		; ** SUBROUTINE CALLED WITH WRONG NUMBER OF ARGS
	PTADW	= 88.		; ** ARGUMENTS DON'T MATCH
				; ADW INCORRECT FOR SPECIFIED POINTER MODE ENTRY
	PTTAB	= 88.		; ** DISPATCH TO ILLEGAL ENTRY IN PTR MODE TABLE
	TLTMAF	= 89.		; TOO MANY ARGUMENTS
	TLNOFN	= 97.		; TOO FEW ARGUMENTS
	FUCORE	= 103.		; PROGRAM LOST - SORRY
	RESERR	= 104.		; RESUME AND NO ERROR
				; TRIED TO RESUME INTO A SUBROUTINE
	DIMED2	= 105.		; REDIMENSIONED ARRAY
	TLCNTD	= 109.		; WHAT?
	EDBMCE	= 111.		; NOT ENOUGH AVAILABLE MEMORY
	EDEXON	= 112.		; EXECUTE ONLY FILE
	PRERRS	= 116.		; PRINT USING ERROR
	ILLSMT	= 121.		; *54* ILLEGAL STATEMENT
	NOMATH	= 125.		; WRONG MATH PACKAGE
	XCDCOR	= 126.		; MAXIMUM MEMORY EXCEEDED
	SCAERR	= 127.		; SCALE FACTOR INTERLOCK
;
; ERROR NUMBER FOR BASIC PLUS 2
;
	FOVRFL	= 48.		; FLOATING OVERFLOW
	FUNDFL	= 48.		; FLOATING UNDERFLOW
	PSTFLT	= 48.		; STRING ARITH FLOATING ERROR
	RMERBG	= 128.		; BEGINNING OF RMS ERRORS
	INCV	= 128.
	ILLACC	= 136.		; ILLEGAL ACCESS
	ILFLOP  = 139.		; INVALID FILE OPERATION
	ILLOPR	= 141.		; ILLEGAL OPERATION
	BADKEY	= 143.		; BAD KEY ON FIND/GET
	BADMRN	= 147.		; BAD MRN FIELD
	BADRSZ	= 148.		; BAD (OR 0) RECORDSIZE
	NOPRKY	= 150.		; NO PRIMARY KEY
	RBLCK	= 154.		; RECORD/BUCKET LOCKED
	MISATR	= 160.		; MISMATCHED ATTRIBUTES
	BUFOFL	= 161.		; MOVE OVERFLOWS BUFFER
	BADOPN	= 162.		; CANNOT OPEN FILE
	TRFREQ	= 164.		; TERMINAL FORMAT FILE REQUIRED
	NEGLEN	= 166.		; NEGATIVE OR ZERO FILL
	ILLRFM	= 167.		; ILLEGAL RECORD FORMAT
	ILLSHR	= 168.		; ILLEGAL SHARE(ALLOW) FIELD
	BADRFA	= 173.		; INVALID RFA FIELD
;
; NEW ERRORS
;
	BADNOD  = 175.		; *60* BAD NODENAME
	NOSUP	= 180.		; *56* NO SUPPORT FOR OPERATION IN TASK
	BADNET	= 182.		; *61* NET OPERATION REJECTED
	REMOVR	= 183.		; *66* REMAP OVERFLOW BUFFERS
	REMUNA	= 184.		; *66* UNALIGNED REMAP VARIABLE
	RCOVMP	= 185.		; *72* RECORDSIZE OVERFLOWS MAP
	IMPERR	= 186.		; *74* IMPROPER ERROR RECOVERY
	STRLNG  = 227.		; *102* STRING TO LONG
	UNDEXP	= 243.		; EXPONENTIATE
	ERRRES	= 246.		; *55* ERROR TRAP NEEDS RESUME
	ILLRES	= 247.		; ILLEGAL RESUME TO SUBROUTINE
	ILLSBE	= 248.		; ILLEGAL RETURN FROM A SUBROUTINE
	NOTIMP	= 250.		; NOT IMPLEMENTED
	SUBREC	= 251.		; SUBROUTINE CAN'T BE CALLED RECURSIVELY
	ACPERR	= 252.		; RSX-11 F11ACP FAILURE
	DIRERR	= 253.		; DIRECTIVE ERROR , STATUS IN STATUS
	RMSERR	= 255.		; RMS ERROR, CODE IN R0

;
; M STACK DEFINITIONS
;
				; *105* OFFSETS INTO M-STACK
	MSP	= 0		; *105* CURRENT STACK POINTER
	MCODE   = -2		; *105* TYPE OF ENTRY (DEFINED BELOW)
		MGOSUB	= 1	; *105* GOSUB CODE FOR M STACK
		MDEFS	= 2	; *105* DEF* CODE FOR M STACK
		MDEF    = 3	; *105* DEF CODE FOR M STACK (REAL DEFS)
		MSUB	= 4	; *105* SUBROUTINE CODE FOR M STACK
	MLINE   = -4		; *105* CURRENT LINE NUMBER
	MRETAD	= -6		; *105*	RETURN ADDRESS OF GOSUB
	MCHAN   = -10		; *105* CURRENT CHANNEL #
	MERRST	= -12		; *105* CURRENT ERROR STATUS
				; *105* 1 = ERROR PENDING ON INVOCATION
				; *105* 2 = ON ERROR GO BACK WAS SET
	MNODE   = -13		; *105* CURRENT NODE 
	MERRH   = -14		; *105* CURRENT ERROR HANDLER
	MPNAME  = -15		; *105* POINTER TO NAME OF CURRENT MODULE

;	THE LUN ASSIGNED TO CHANNEL 0 - USER TERMINAL
;
	$$MAXC  = 15.			; *64* MAX CHANNELS
	$$UMC	= 12.			; *100* USER MAX CHANNEL

	CHAN0	= 13.			; TERMINAL I/O LUN
	SCRLUN	= 14.			; SCRATCH LUN

	.IF	DF 	RST
	RDRLUN	= 13.			; *67*64* REDIRECTED DEBUGGER I/O LUN
	.IFF
	RDRLUN	= 15.			; *67*
	.ENDC

	EFN0	= 23.			; EVENT FLAG FOR I/O
	EFN0B	= 100			; BINARY WORD FOR ABOVE
	EFN1	= 24.			; EVENT FLAG FOR SLEEP/WAIT SYNCH
	EFN1B	= 200			; BINARY WORD FOR ABOVE
;
;	OTHER DEFINITIONS
;
	CTRLZ	= 32			; CTRL Z
	.ENABL	CRF
	.DSABL	GBL
	PSECT
	.LIST
