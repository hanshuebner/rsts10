	.TITLE	P5IMG
	.IDENT	/14.04/
;
; COPYRIGHT (c)	1983 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE IS FURNISHED  UNDER A LICENSE AND MAY BE USED OR
; COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;
; D.N. CUTLER 30-OCT-72
;
;
; MODIFIED FOR RSX-11M/M-PLUS V4.0/V2.0 BY:
;
;	J. A. KASSON
;	C. B. PETROVIC
;
; MODIFIED BY:
;
;	C. B. PETROVIC	26-FEB-82	14.01
;		CBP039		ADD CORRECT .PSECT DEFINITIONS TO
;				ALLOW TKB TO BE LINKED AS AN I/D TASK.
;
;
;	C. B. PETROVIC	7-JUN-82	14.02
;		CBP051		ADD AUTOLOAD SUPPORT FOR USER-MODE
;				I/D TASKS.
;
;	C. B. PETROVIC	03-SEP-82	14.03
;		CBP056		ADD AUTOLOAD SUPPORT FOR USER-MODE
;				I/D TASKS, PHASE 2. CREATION AND
;				OUTPUT OF TASK-RESIDENT SEGMENT
;				DESCRIPTORS, ADD D-SPACE COMPRESSION
;				ROUTINE FOR R/O SEGMENTS.
;
;	C. B. PETROVIC	22-APR-83	14.04
;		CBP085		ELIMINATE CALLING $FLUSH, RESETTING THE
;				OUTPUT BUFFER POINTER AND CALLING 'CLRBUF'
;				WHEN PROCESSING A MEMORY-RESIDENT OVERLAID
;				MULTI-USER I/D TASK. THIS AUGMENTS AUDIT
;				CBP056...
;
;
; PHASE 5 TASK IMAGE OUTPUT ROUTINES
;
; MACRO LIBRARY CALLS
;

	.MCALL	READ$,WTSE$S,WRITE$

;
; LOCAL DATA
;
	IMPURE			; READ/WRITE D-SPACE

	.NLIST	CND


BLKNM:	.WORD	0		;HIGH ORDER PART OF VIRTUAL BLOCK NUMBER
BLK:	.BLKW	1		;CURRENT DISK BLOCK NUMBER
BLKNM2:	.WORD	0		; HIGH ORDER PART OF VIRTUAL BLOCK NUMBER
BLK2:	.BLKW	1		; CURRENT DISK BLOCK NUMBER OF SECOND BUFFER
BUF:	.BLKW	256.		;OUTPUT BUFFER
ENDBUF=.
BUF2:	.WORD	1		; ADDRESS OF INPUT BUFFER
VDSK:	.BLKW	1		;STARTING DISK ADDR (BYTE)
VEND:	.BLKW	1		;ENDING DISK ADDR (BYTE)
IOSTS:	.BLKW	2		;I/O STATUS DOUBLEWORD
ROF:	.BLKW	1		; R/O BUFFER FLAG (0=RW, 1=RO)
ROFD:	.BLKW	1		; R/O D-SPACE BUFFER FLAG (RW=0, RO=1)
BTYP:	.BLKW	1		; BUFFER TYPE FLAG (0=INSTRUCTION, 1=DATA)
ERELM:	.BLKW	1		; VIRTUAL ADDRESS OF LAST MODULE TO
				; HAVE 'LOAD ADDRESS OUT OF RANGE'

	.IF DF D$P5IM

	PURE.D

	.NLIST	BEX
FMT0:	.ASCII	/$WRBYT:	TKADR=%P DATA= %P $STYP=%P CRELM=%P%N/
	.ASCIZ	/	LOWRW=%P ENDRW=%P BEGRO=%P ENDRO=%P%N/
FMT1:	.ASCII	/$DISK:	BLK =%P	BLK2=%P	VDSK=%P	VEND=%P	ROF= %P%N/
	.ASCIZ	/	BTYP=%P	IOSB=%2P%N/
	.EVEN
	.LIST	BEX

	.ENDC

;+
; **-$FINFL-FINISH TASK IMAGE FILE
;
; THIS ROUTINE IS CALLED AT THE END OF PHASE 5 TO FINISH THE WRITING
; OF THE TASK IMAGE FILE. THE CURRENT BUFFER IS FLUSHED AND A SCAN
; OF THE BITMAP IS EXECUTED. A ZERO BLOCK IS WRITTEN INTO THE IMAGE
; FOR EACH BLOCK THAT HAS NOT YET BEEN WRITTEN.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	WRITING OF THE TASK IMAGE FILE IS FINISHED.
;-
	PURE.I			; READ-ONLY I-SPACE

$FINFL::
	SAVRG			; SAVE NON-VOLATILE REGISTERS
	CALL	$FLUSH		;FLUSH CURRENT BUFFER
	CALL	CLRBF		;CLEAR BUFFER
	CLR	R1		;CLEAR STARTING VIRTUAL BLOCK NUMBER
	MOV	$BITMP+2,R2	;GET ADDRESS OF BITMAP
	MOV	$BITMP,R3	;GET SIZE OF BITMAP
10$:	MOV	#8.,R4		;SET REPEAT COUNT FOR ONE BYTE
	MOVB	(R2)+,R5	;GET NEXT BITMAP BYTE
20$:	INC	R1		;INCREMENT VIRTUAL BLOCK NUMBER
	ROR	R5		;CAPTURE LOW BIT IN CARRY
	BCC	30$		;IF CC ALREADY WRITTEN
	MOV	R1,BLK		;SET VIRTUAL BLOCK NUMBER
	INC	$BFFLG		;SET BUFFER FLAG "TRUE"
	CALL	$FLUSH		;FLUSH BUFFER
30$:	SOB	R4,20$		;REPEAT (BYTE)
	SOB	R3,10$		;REPEAT (MAP)
	MOV	BLK,$REBLK	; SAVE LAST BLK
	RETURN			;

;+
; **-$FLUSH-FLUSH BUFFER
;
; THIS ROUTINE IS CALLED TO FLUSH THE CURRENT CONTENTS OF THE IMAGE
; BUFFER. THE BUFFER IS WRITTEN TO DISK AND THE BUFFER FLAG IS SET
; TO "FALSE".
;
; INPUTS:
;
;	$BFFLG=TRUE/FALSE BUFFER FLAG.
;	BUF=OUTPUT BUFFER.
;
; OUTPUTS:
;
;	THE CURRENT BUFFER IS WRITTEN OUT AND THE BUFFER FLAG IS
;	SET TO "FALSE".
;	NOTE: REGISTERS R0 AND R1 ARE NOT DESTROYED.
;-

$FLUSH::
	TST	$BFFLG		; ANYTHING IN BUFFER?
	BEQ	10$		;IF EQ NO
	MOV	R0,-(SP)	;SAVE R0
	MOV	$TSKPT,R0	;GET TASK IMAGE FILE RECORD BLOCK
	WRITE$	R0,#BUF,#<256.*2>,#BLKNM,#1,#IOSTS;WRITE OUT BUFFER
	CALL	CHKST		;CHECK WRITE STATUS
	MOV	(SP)+,R0	;RESTORE R0
	INC	BLK		; UPDATE THE BLOCK COUNTER
10$:	CLR	$BFFLG		;SET BUFFER FLAG "FALSE"
	RETURN			;

;+
; **-$WRBYT-WRITE BYTE INTO TASK IMAGE FILE
;
; THIS ROUTINE IS CALLED TO WRITE A BYTE OF TEXT INTO THE TASK
; IMAGE FILE.
;
; INPUTS:
;
;	R0=VIRTUAL ADDRESS OF THE BYTE TO BE WRITTEN.
;	R1=BYTE TO BE WRITTEN.
;	$CRELM=ADDRESS OF CURRENT ELEMENT DESCRIPTOR.
;	$WRFLG=SEGMENT DESCRIPTOR FLAGS WORD
;	$STYP=TYPE OF BYTE TO BE WRITTEN (0=INSTRUCTION, 1=DATA)
;		(TYPE WILL ALWAYS BE INSTRUCTION UNLESS /ID TASK)
;
; OUTPUTS:
;
;	BYTE IS WRITTEN INTO THE TASK IMAGE FILE.
;-

$WRBYT::			;
	BITB	#SG$DSK,$WRFLG	; SEGMENT HAVE DISK ALLOCATION
	BNE	20$		; IF NE NO
	CLR	R2		; CLEAR TYPE OFFSET
	TSTB	$STYP		; IS THIS AN INSTRUCTION?
	BEQ	5$		; IF EQ YES
	MOV	#2,R2		; NO - SET FOR DATA OFFSET
5$:				;
	.IF DF D$P5IM

	CMP	$RTSEG,$CRVSG	 ; TRACE ONLY OVERLAY SEGMENTS
	BEQ	153$
	MOV	$ENDRO(R2),-(SP) ; SAVE THE ADDRESS RANGES
	MOV	$BEGRO(R2),-(SP)
	MOV	$ENDRW(R2),-(SP)
	MOV	$LOWRW(R2),-(SP)
	MOV	$CRELM,-(SP)	; AND THE CURRENT ELEMENT POINTER
	MOV	R2,-(SP)	; NOW DO THE DATA/INSTRUCTION SWITCH
	MOV	R1,-(SP)	; THE DATA BYTE TO BE WRITTEN TO ABOVE ADDRS.
	BIC	#177400,(SP)	; DUMP THE HIGH DATA BYTE
	MOV	R0,-(SP)	; FINALLY THE ADDRESS TO WHICH THE BYTE IS WRIT
	MOV	#FMT0,-(SP)	; OF COURSE, THE FORMAT STRING
	MOV	#5.,$DVDEB	; PHASE 5 TRACE ONLY
	CALL	$DVDBP		; WRITE IT TO TI:
	ADD	#2*9.,SP	; CLEAN UP THE STACK BEFORE PROCEEDING
	CLR	$DVDEB		; ZERO OUT THE PHASE-TO-TRACE-ON LOCATION
153$:

	.ENDC

	CMP	R0,$ENDRW(R2)	; IN RW AREA?
	BHI	10$		;IF HI NO

	.IF	NDF	R$$11M

	CMP	R0,$BEGRW	;WITHIN LIMITS?

	.IFF

	CMP	R0,$LOWRW(R2)	; WITHIN LIMITS?

	.ENDC

	BLO	20$		;IF LO NO
	BR	40$		;
10$:
	CMP	R0,$BEGRO(R2)	; IN RO AREA?
	BLO	20$		;IF LO NO
	CMP	R0,$ENDRO(R2)	; WITHIN LIMITS?
	BLOS	30$		;IF LOS YES
20$:
	CMP	$CRELM,ERELM	; MESSAGE PRINTED FOR MODULE
	BEQ	25$		; IF EQ YES
	MOV	$CRELM,ERELM	; SAVE ADDRESS OF MODULE
	MOV	$CRELM,R2	; GET ADDRESS OF ELEMENT DESCRIPTOR
	ADD	#E$LMOD,R2	;POINT TO MODULE NAME
	MOV	(PC)+,R1	;GET ERROR/SEVERITY
	.BYTE	E$R26,S$V0	; DIAG. MESSAGE
	JMP	$ERMSG		; PRINT MESSAGE
25$:
	RETURN
30$:
	SUB	$BEGRO(R2),R0	; NORMALIZE TO START OF R/O SEGMENT
	CMP	R2,BTYP		; CURRENT BUFFER TYPE THE SAME?
	BEQ	33$		; IF EQ YES
	MOV	R2,BTYP		; RESET BUFFER TYPE
	MOV	#2,R2		; SET FOR R/0
	BR	50$		; FLUSH OLD BUFFER
33$:
	MOV	#2,R2		; SET FOR R-O
	TST	$BFFLG		; ANYTHING IN BUFFER?
	BEQ	60$		; IF EQ NO
	TST	ROF		; CURRENT BUFFER R-O?
	BNE	45$		; IF NE YES
	BR	50$		; NO - FLUSH BUFFER
	.IIF  NDF  R$$11M, SUB	$BIAS,R0	; SUBTRACT RO ADDRESS BIAS
40$:
	SUB	$BEGRW(R2),R0	; NORMALIZE TO START OF SEGMENT
	CMP	R2,BTYP		; CURRENT BUFFER TYPES THE SAME
	BEQ	43$		; IF EQ YES
	MOV	R2,BTYP		; RESET BUFFER TYPE
	CLR	R2		; SET FOR R/W
	BR	50$		; FLUSH BUFFER
43$:
	.IIF  NDF  R$$11M, ADD	$HDOFF,R0	; ADD IN HEADER OFFSET
	CLR	R2		; SET FOR R-W
	TST	$BFFLG		; ANYTHING IN BUFFER?
	BEQ	60$		; IF EQ NO
	TST	ROF		; CURRENT BUFFER R-W?
	BNE	50$		; IF NE NO - FLUSH
45$:
	CMP	R0,VDSK		;IN CURRENT BUFFER?
	BLO	50$		;IF LO NO
	CMP	R0,VEND		;IN CURRENT BUFFER?
	BLOS	80$		;IF LOS YES
50$:	CALL	$FLUSH		;FLUSH CURRENT CONTENTS OF BUFFER
60$:
	MOV	R2,ROF		; SET FLAG TO CURRENT BUFFER TYPE
	MOV	#$RLBLK,-(SP)	; GET ADDRESS OF RELATIVE BLOCK
	TST	BTYP		; DATA OR INSTRUCTION?
	BEQ	62$		; IF EQ INSTRUCTION
	MOV	#$RLDBK,(SP)	; DATA - GET ADDR. OF RELATIVE DATA BLOCK
62$:
	ADD	R2,(SP)		; ALSO GET CURRENT BUFFER TYPE (R/O OR R/W)
	MOV	R0,R2		; COPY DISK BYE ADDRESS
	BIS	#777,R2		;CALCULATE ENDING BUFFER ADDRESS
	MOV	R2,VEND		;SET ENDING BUFFER ADDRESS
	BIC	#777,R2		;CALCULATE STARTING BUFFER ADDRESS
	MOV	R2,VDSK		;SET STARTING BUFFER ADDRESS
	SWAB	R2		;DIVIDE BY 256. BYTES
	ASR	R2		;CALCULATE RELATIVE BLOCK NUMBER
	ADD	@(SP)+,R2	; ADD IN BASE RELATIVE BLK NUMBER
	INC	R2		;CONVERT TO VIRTUAL BLOCK NUMBER
	MOV	R2,BLK		;SET CURRENT BLOCK NUMBER
	INC	$BFFLG		;SET BUFFER FLAG TO "TRUE"
	MOV	R0,-(SP)	;SAVE R0
	MOV	R1,-(SP)	;SAVE R1
	DEC	R2		;CONVERT TO RELATIVE BLOCK NUMBER


	.IF	DF	V1145

	MOV	R2,R1		;SET LOW PART OF DIVIDEND
	CLR	R0		;CLEAR HIGH PART OF DIVIDEND
	DIV	#8.,R0		;CALCULATE RELATIVE BYTE AND BIT

	.IFF

	MOV	R2,R0		;SET DIVIDEND
	MOV	#8.,R1		;SET DIVISOR
	CALL	$DIV		;CALCULATE RELATIVE BYTE AND BIT

	.ENDC


	ADD	$BITMP+2,R0	;POINT TO BYTE IN BITMAP
	MOV	#1,R2		;GET MASK BIT


	.IF	DF	V1145

	ASH	R1,R2		;SHIFT MASK BIT INTO PLACE

	.IFF

65$:	DEC	R1		;DECREMENT SHIFT COUNT
	BLT	70$		;IF LT DONE
	ASL	R2		;SHIFT MASK BIT INTO PLACE
	BR	65$		;

	.ENDC


70$:	BITB	R2,(R0)		;BLOCK ALREADY WRITTEN?
	BEQ	73$		;IF EQ YES
	BICB	R2,(R0)		;CLEAR BIT IN BITMAP
	CALL	CLRBF		;CLEAR BUFFER
	BR	77$		;
73$:	MOV	$TSKPT,R0	;GET TASK IMAGE FILE RECORD BLOCK
	READ$	R0,#BUF,#<256.*2>,#BLKNM,#1,#IOSTS;READ IN BLOCK
	CALL	CHKST		;CHECK READ STATUS
77$:	MOV	(SP)+,R1	;RESTORE R1 AND R0
	MOV	(SP)+,R0	;
80$:	SUB	VDSK,R0		;CALCULATE ADDRESS IN BUFFER
	MOVB	R1,BUF(R0)	;STORE BYTE

	.IF DF D$P5IM

	CMP	$RTSEG,$CRVSG	; TRACE ONLY THE OVERLAY SEGMENTS
	BEQ	288$		; BYPASS THIS STUFF!
 	MOV	IOSTS+2,-(SP)	; SAVE THE IO STATUS DOUBLEWORD
	MOV	IOSTS,-(SP)
	MOV	BTYP,-(SP)	; BUFFER TYPE (0=CODE, 1=DATA)
	MOV	ROF,-(SP)	; READ-ONLY FLAG (0=RW, 1=RO)
	MOV	VEND,-(SP)	; ENDING DISK BYTE ADDRESS
	MOV	VDSK,-(SP)	; STARTING DISK BYTE ADDRESS
	MOV	BLK2,-(SP)	; BUFFER #2 DISK BLOCK ADDRESS
	MOV	BLK,-(SP)	; BUFFER #1 DISK BLOCK ADDRESS
	MOV	#FMT1,-(SP)	; OF COURSE, THE FORMAT STRING
	MOV	#5.,$DVDEB	; PHASE 5 TRACE ONLY
	CALL	$DVDBP		; WRITE IT TO TI:
	ADD	#2*9.,SP	; CLEAN UP THE STACK BEFORE PROCEEDING
	CLR	$DVDEB		; ZERO OUT THE PHASE-TO-TRACE-ON LOCATION
288$:

	.ENDC

	RETURN			;

;+
; **-$WRWRD-WRITE WORD INTO TASK IMAGE FILE
;
; THIS ROUTINE IS CALLED TO WRITE A WORD OF TEXT INTO THE TASK
; IMAGE FILE.
;
; INPUTS:
;
;	R0=VIRTUAL ADDRESS OF WORD TO BE WRITTEN.
;	R1=WORD TO BE WRITTEN.
;
; OUTPUTS:
;
;	WORD IS WRITTEN INTO THE TASK IMAGE FILE.
;-

$WRWRD::
	MOV	R1,-(SP)	; SAVE R0 AND R1
	MOV	R0,-(SP)	;
	CALL	$WRBYT		;WRITE FIRST BYTE
	MOV	(SP)+,R0	;RESTORE R0 AND R1
	MOV	(SP)+,R1	;
	INC	R0		;INCREMENT VIRTUAL ADDRESS
	SWAB	R1		;SWAP BYTES
	CALL	$WRBYT		;WRITE SECOND BYTE
	RETURN			;

;
; SUBROUTINE TO CHECK STATUS OF I/O OPERATION
;

CHKST:	BCS	10$		;IF CS I/O ERROR
	WTSE$S	#1		;WAIT FOR I/O TO COMPLETE
	DECB	IOSTS		;I/O ERROR?
	BNE	10$		;IF NE YES
	RETURN			;
10$:

	.IF DF D$P5IM

 	MOV	IOSTS+2,-(SP)	; SAVE THE IO STATUS DOUBLEWORD
	MOV	IOSTS,-(SP)
	MOV	BTYP,-(SP)	; BUFFER TYPE (0=CODE, 1=DATA)
	MOV	ROF,-(SP)	; READ-ONLY FLAG (0=RW, 1=RO)
	MOV	VEND,-(SP)	; ENDING DISK BYTE ADDRESS
	MOV	VDSK,-(SP)	; STARTING DISK BYTE ADDRESS
	MOV	BLK2,-(SP)	; BUFFER #2 DISK BLOCK ADDRESS
	MOV	BLK,-(SP)	; BUFFER #1 DISK BLOCK ADDRESS
	MOV	#FMT1,-(SP)	; OF COURSE, THE FORMAT STRING
	MOV	#5.,$DVDEB	; PHASE 5 TRACE ONLY
	CALL	$DVDBP		; WRITE IT TO TI:
	ADD	#2*9.,SP	; CLEAN UP THE STACK BEFORE PROCEEDING
	CLR	$DVDEB		; ZERO OUT THE PHASE-TO-TRACE-ON LOCATION

	.ENDC

	MOV	R$NAME(R0),R2	; GET ADDRESS OF TASK NAME STRING
	MOV	(PC)+,R1	;I/O ERROR
	.BYTE	E$R25,S$V2	;FATAL-NO RETURN
CHKST1:	CALL	$ERMSG		;OUTPUT ERROR MESSAGE

;
; SUBROUTINE TO CLEAR BUFFER
;

CLRBF:	MOV	#BUF,R0		;GET ADDRESS OF BUFFER
	MOV	#256.,R1	;SET REPEAT COUNT
10$:	CLR	(R0)+		;CLEAR BUFFER
	SOB	R1,10$		;REPEAT
	RETURN			;


;+
;
; **-$CMPRS-READ ONLY DISK COMPRESSION ROUTINE
;
; THIS ROUTINE IS CALLED AT THE END OF PHASE FIVE
; TO COMPRESS THE R-O PORTION OF THE TASK FILE.
; BEFORE COMPRESSION EACH R-O SEGMENT STARTED ON
; A BLOCK BOUNDRY,AFTERWARDS THE SEGMENTS ARE CON-
; CATINATED IN THE TASK FILE. THIS FACILATATES
; LOADING THE SHARED SEGMENTS.
;
; INPUT:
;	R0= RELATIVE BLOCK NUMBER TO OUTPUT COMPRESSED BLKS
;
; OUTPUT:
;	NONE
;
;
;-
$CMPRS::
	SAVRG			; SAVE VOLATILE REGISTERS
	MOV	R0,R4		; SAVE OFFSET TO R-W OR R-O
	CLR	ROF		; FLAG USED FOR FIRST I-SPACE SEGMENT
	CLR	ROFD		; FLAG USED FOR FIRST D-SPACE SEGMENT
	MOV	#N$DLGH,R1	; GET LENGTH OF BUFFER
	CALL	$ALBLK		; ALLOCATE BUFFER SPACE
	MOV	R0,BUF2		; SET ADDRESS OF BUFFER
	MOV	#BUF,BLK2	; SAVE TOP OF OUTPUT BUFFER
	MOV	#CMPRS,R0	; ADRESS OF COMPRESSION ROUTINE
	CALL	$PCTRL		; CALL PHASE CONTROL ROUTINE
	CALL	$FLUSH		; WRITE LAST BUFFER
	MOV	#N$DLGH,R1	; SIZE OF BUFFER
	MOV	BUF2,R2		; ADDRESS OF BUFFER
	MOV	#$FRHD,R0	; ADDRESS OF FREE SPACE LISTHEAD
	CALL	$RLCB		; RELEASE BUFFER FROM POOL
	CLR	ROF		; RESET FLAG USED FOR FIRST I-SPACE SEGMENT
	CLR	ROFD		; RESET FLAG USED FOR FIRST D-SPACE SEGMENT
	MOV	BLK,$REBLK	; SAVE LAST BLK AFTER COMPRESSION
	SUB	#2,$REBLK	; CORRECT THE BLOCK COUNT FOR THE MAP
	MOV	$TSKPT,R0	; FDB ADDRESS OF TASK FILE
	MOV	BLK,F.EFBK+2(R0)	; END OF FILE BLOCK NUMBER
	CALL	.TRNCL		; TRUNCATE AND CLOSE TASK FILE
	RETURN			; COMPRESSION COMPLETE

;+
;
; CMPRS - READS IN R-O SEGMENTS FROM TASK IMAGE FILE AND
;	  REWRITES THEM, ILLIMINATING THE USED PORTIONS.
;
;-
CMPRS:
	SAVRG			; SAVE THE VOLATILE REGISTERS...
	MOV	R4,-(SP)	; SAVE THE R/O OR R/W OFFSET
	CALL	CMPRSI		; COMPRESS THE I-SPACE R/O SEGMENTS FIRST
	MOV	(SP)+,R4	; FETCH OFFSET VALUE BEFORE WE CALL CMPRSD.
	BIT	#ID$ATA,$SWTCH	; NOW, ARE WE BUILDING AN I/D TASK??
	BEQ	10$		; IF EQ, NO...JUST RETURN
	CALL	CMPRSD		; AND COMPRESS THE D-SPACE R/O SEGMENTS
10$:
	RETURN
;
;

	.ENABL	LSB

CMPRSD:				; D-SPACE COMPRESSION ROUTINE
	MOV	BLK2,R2		; SAVE PLACE IN THE OUTPUT BUFFER
	MOV	$CRSEG,R5	; GET THE SEGMENT DESCRIPTOR ADDRESS
	ADD	R4,R5		; ADD IN THE R/O OFFSET VALUE
	MOV	S$GRWD(R5),R3	; GET THE R/O (R/W) LENGTH
	BEQ	60$		; EXIT IF ZERO...
	MOV	S$GDBK(R5),BLK2 ; GET RELATIVE BLOCK NUMBER OF R/O SEGMENT
	INC	BLK2
	CLR	R4		; KEEP TRACK OF THE BYTES WE'VE MOVED
	TST	ROFD		; FIRST D-SPACE SEGMENT
	BNE	45$		; IF NE, NO...
	MOV	BLK2,BLK	; SET RELATIVE BLOCK NUMBER FOR OUTPUT
	MOV	BLK2,$RODBK	; SAVE FIRST R/O D-SPACE DISK BLOCK
	DEC	$RODBK
	INC	ROFD		; SET 'NOT-FIRST-SEGMENT' FLAG
	BR	45$		; AND JOIN THE COMMON CODE TO READ IN BLOCK
;
;
CMPRSI:				; I-SPACE COMPRESSION ROUTINE
	MOV	BLK2,R2		; GET PLACE IN OUT BUFFER
	MOV	$CRSEG,R5	; SAVE REAL ADDRESS OF SEGMENT
	ADD	R4,R5		; ADD IN R-O OFFSET
	MOV	S$GRW(R5),R3	; GET R-O (R-W) LENGTH
	BEQ	60$		; IF EQ NO R-O
	MOV	S$GBLK(R5),BLK2 ; RELATIVE BLK NUM OF SEGMENT
	INC	BLK2		;
	CLR	R4		; KEEP COUNT OF BYTES MOVED
5$:
	TST	ROF		; IS THIS FIRST SEGMENT?
	BNE	45$		; IF NE NO
	MOV	BLK2,BLK	; SET RELATIVE BLK NUM FOR OUTPUT
	MOV	BLK2,$ROBLK	; SAVE FIRST R-O DISK BLK
	DEC	$ROBLK		;
	INC	ROF		; SET NOT FIRST SEGMENT
10$:
	BR 	45$		; GO READ IN BLOCK
20$:
	DEC	R5		; INPUT BUFFER EMPTY?
	BLE	40$		; IF LE YES
25$:
	INC	$BFFLG		; SET BUFFER NOT EMPTY FLAG
	MOVB	(R1)+,(R2)+	; MOVE BYTE FROM INPUT TO OUTPUT BUFFER
	INC	R4		; KEEP COUNT
	CMP	R2,#ENDBUF	; OUTPUT BUFFER FULL?
	BLT	20$		; IF NE NO
30$:
	MOV	R1,-(SP)	; SAVE ADDRESS IN INPUT BUFFER
	CALL	WRTBLK		; WRITE OUTPUT BUFFER
	MOV	(SP)+,R1	; RESTORE ADDRESS
	BR	20$		; GO AGAIN
40$:
	TST	R3		; ANY MORE INPUT BLKS?
	BEQ	50$		; IF EQ NO
45$:
	MOV	R0,-(SP)	; SAVE R0
	MOV	$TSKPT,R0	; GET TASK IMAGE FILE RECORD BLOCK
	READ$	R0,BUF2,#<256.*2>,#BLKNM2,#1,#IOSTS  ; READ BLOCK
	CALL	CHKST		; CHECK READ STATUS
	MOV	(SP)+,R0	; RESTORE R0
	INC	BLK2		; INCREMENT RELATIVE BLOCK NUMBER
	MOV	BUF2,R1		; ADRESS OF INPUT BUFFER
	MOV	R3,R5		;
	CMP	#<256.*2>,R3	; LESS THEN A BLOCK LEFT?
	BLO	46$		; IF LO NO
	CLR	R3		; SET FOR END
	BR	25$		;
46$:
	SUB	#<256.*2>,R3	; GET LENGTH OF BLK
	MOV	#<256.*2>,R5	; LOOP COUNT WAS LARGER THEN BUFFER SIZE
	BR	25$		; GO PROCESS BLOCK READ
50$:
	MOV	R4,R0		;
	DEC	R4		; DECREMENT IN CASE IT FALLS ON BLK BOUNDARY.
	BIS	#77,R4		; MOVE TO A 32 WORD BOUNDARY
	INC	R4		;
	SUB	R0,R4		;
	ADD	R4,R2		;
	MOV	R2,BLK2		; SAVE POSITION IN OUT BUFFER
	CMP	R2,#ENDBUF	; GO PAST END OF BUFFER?
	BLO	60$		; IF LOWER, THEN DON'T SCRIBBLE IT OUT...
	CALL	WRTBLK		; WRITE OUT BUFFER
	MOV	R2,BLK2		; GET ADDRESS IN BUFFER
60$:
	RETURN

	.DSABL	LSB

WRTBLK:				; FLUSH BUFFER
	CALL	$FLUSH		;
	MOV	#BUF,R2		; ADDRESS OF OUT BUFFER
	CALL	CLRBF		; INITIALIZE OUTPUT BUFFER
	RETURN


	.END
