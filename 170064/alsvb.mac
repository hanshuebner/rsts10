	.TITLE	ALSVB
	.IDENT	/01.01/
;
;		COPYRIGHT (c) 1983 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD
;	 MASSACHUSETTS.  ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE  IS  FURNISHED  UNDER  A LICENSE AND MAY BE USED
; AND  COPIED  ONLY IN  ACCORDANCE WITH THE TERMS OF SUCH LICENSE
; AND WITH  THE INCLUSION  OF THE ABOVE  COPYRIGHT  NOTICE.  THIS
; SOFTWARE  OR ANY OTHER  COPIES  THEREOF, MAY NOT BE PROVIDED OR
; OTHERWISE MADE  AVAILABLE TO ANY OTHER PERSON.  NO TITLE TO AND
; OWNERSHIP OF THE SOFTWARE IS HEREBY TRANSFERRED.
;
; THE INFORMATION  IN THIS DOCUMENT IS SUBJECT  TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT  BY  DIGITAL
; EQUIPMENT CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF
; ITS SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.
;
;
;
; C. MONIA 05-MAR-75
;
; MODIFIED BY:
;
;	C. B. PETROVIC	26-FEB-82	01.01
;		CBP039		ADD CORRECT .PSECT DEFINITIONS TO
;				ALLOW TKB TO BE LINKED AS AN I/D TASK.
;
;
; ALLOCATE SMALL VIRTUAL CORE BLOCK
;
; LOCAL DATA
;
; OFFSET INTO CURRENT LARGE BLOCK
;
	IMPURE			; READ/WRITE D-SPACE

BLOFF:	.BLKW	1		;

;
; VIRTUAL ADDRESS OF CURRENT LARGE BLOCK
;

BLVAD:	.BLKW	1		;

;+
; **-$ALSVB-ALLOCATE SMALL VIRTUAL CORE BLOCK
;
; THE PURPOSE OF THIS SUBROUTINE IS TO ALLOCATE SMALL BLOCKS OF
; VIRTUAL MEMORY WITHOUT EXCESSIVE FRAGMENTATION AND WASTED VIRTUAL
; ADDRESS SPACE WHEN HIGHLY DIVERGENT ALLOCATION SIZES ARE ENCOUNTERED
;
; INPUTS:
;
;	R1=SIZE OF BLOCK TO ALLOCATE IN BYTES
;
; THIS ROUTINE MUST BE CALLED INITIALLY WITH A VALUE OF ZERO IN
; R1 TO FORCE THE ALLOCATION OF THE FIRST LARGE BLOCK. THE SIZE MAY
; NOT EXCEED THE SIZE OF A LARGE BLOCK
;
;
; OUTPUTS:
;
;	R0=REAL ADDRESS OF BLOCK
;	R1=VIRTUAL ADDRESS OF BLOCK
;
; PAGE CONTAINING BLOCK IS WRITE-MARKED
;
;
; R3 - R5 ARE PRESERVED
;
; THE ROUTINE INITIALLY ALLOCATES A BLOCK OF SIZE N$DLGH, PERFORMS
; THE SUB-ALLOCATION THEN RETURNS CONTROL TO THE CALLER. SUBSE-
; QUENT CALLS CAUSE ADDITIONAL BLOCKS TO BE ALLOCATED UNTIL
; SPACE WITHIN THE LARGE BLOCK IS EXHAUSTED. A NEW LARGE BLOCK
; IS THEN ALLOCATED.
;
;-
	PURE.I			; READ-ONLY I-SPACE

$ALSVB::			;
	INC	R1		; ROUND BLOCK SIZE TO WORD BOUNDARY
	ASR	R1		; CONVERT TO WORDS
	BEQ	10$		; IF EQ, FIRST CALL
	MOV	BLOFF,R2	; GET CURRENT OFFSET INTO BLOCK
	ADD	R1,R2		; UPDATE CURRENT OFFSET
	CMP	R2,#N$DLGH/2	; ALLOCATION EXCEED REMAINING SPACE?
	BHI	10$		; IF HI YES
	MOV	R2,BLOFF	; SAVE OFFSET INTO BLOCK
	MOV	BLVAD,R0	; GET VIRTUAL BLOCK ADDRESS
	ADD	R1,BLVAD	; UPDATE VIRTUAL ADDRESS
	MOV	R0,R1		; SET ADDRESS
	CALL	$CVRL		; CONVERT TO REAL
	CALL	$WRMPG		; WRITE-MARK PAGE
	BR	20$		;
10$:				;
	MOV	R1,BLOFF	; SET BLOCK OFFSET
	MOV	#N$DLGH,R1	; GET SIZE OF LARGE BLOCK
	CALL	$ALVRT		; ALLOCATE VIRTUAL MEMORY
	MOV	R1,BLVAD	; SAVE VIRTUAL ADDRESS
	ADD	BLOFF,BLVAD	; POINT TO NEXT FREE VIRTUAL ADDRESS
20$:				;
	RETURN			;

	.END
