	.TITLE	P6STB
	.IDENT	/24.18/
;
; COPYRIGHT (c)	1988,1991 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE IS FURNISHED  UNDER A LICENSE AND MAY BE USED OR
; COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;
;
; D. N. CUTLER/C. MONIA	21-JAN-74
;
; MODIFIED FOR RSX-11M/M-PLUS V4.0/V2.0 BY:
;
;	J. A. KASSON
;	J. E. POLLACK
;	C. B. PETROVIC
;
; MODIFIED BY:
;
;	C. B. PETROVIC	26-FEB-82	24.01
; 		CBP039		ADD CORRECT .PSECT DEFINITIONS TO
;				ALLOW TKB TO BE LINKED AS AN I/D TASK.
;
;	C. B. PETROVIC	26-MAR-82	24.02
;		CBP045		CHANGE AUTOLOAD VECTOR FORMAT TO USE
;				THE IMPURE AREA POINTER .NAUTO TO
;				ACCESS THE ROUTINE $AUTO IN PREPARATION
;				FOR I/D AUTOLOAD SUPPORT.
;
;	C. B. PETROVIC	22-APR-82	24.03
;		CBP048		ADD CHECK OF WEAK/STRONG DEFINITION FROM AN
;				OVERLAID SUPER-MODE LIBRARY TO PREVENT THE
;				GENERATION OF SUPER-MODE VECTORS FOR THE AUTO-
;				LOADABLE UP-TREE SUPERMODE ROUTINES.
;
;	C. B. PETROVIC	23-APR-82	24.04
;		CBP049		MAKE THE GBLINC OPTION OUTPUT A REAL
;				GLOBAL REFERENCE ACCORDING TO THE
;				BIT ASSIGNMENTS DEFINED IN MODULE 'TABLS.'
;
;	J. M. SALMAN	08-JUN-82	24.05
;		JMS049		CLEAN STACK BEFORE RETURNING WHEN VIRTUAL ARRAY
;				SECTION IS ENCOUNTERED.
;
;	J. M. SALMAN	16-JUN-82	24.06
;		JMS050		SUPPORT SELECTIVE INCLUSION OF AUTOLOAD VECTORS
;				USING NEW TKB-GENERATED ISD RECORD.
;
;	J. M. SALMAN	12-JUL-82	24.07
;		JMS053		FIX LENGTH FIELD IN TASK-ID ISD ITEM
;				(34. TO 22. BYTES).
;
;	C. B. PETROVIC	07-JUN-82	24.08
;		CBP051		ADD AUTOLOAD SUPPORT FOR USER-MODE
;				I/D TASKS.
;
;	J. M. SALMAN	06-OCT-82	24.09
;		JMS077		COMPLETE CBP039.
;
;	J. M. SALMAN	10-OCT-82	24.10
;		JMS080		FIX VALUE OF TASK-RESIDENT SEGMENT DESCRIPTOR
;				FIELD IN ISD GLOBAL SYMBOL ITEM AND IN ISD
;				INTERNAL SYMBOL ITEM.
;
;	J. M. SALMAN	26-OCT-82	24.11
;		JMS081		DON'T OUTPUT TXT AND RLD RECORDS IF WE ARE
;				NOT BUILDING A LIBRARY OR A COMMON.
;
;	J. M. SALMAN	08-DEC-82	24.12
;		JMS091		FIX GBLINC SO THAT ALL SYMBOLS IN LIST ARE
;				INCLUDED.
;
;	J. M. SALMAN	08-DEC-82	24.13
;		JMS092		ALLOW ISD RECORDS TO BE LONGER THAN 132. BYTES.
;
;	C. B. PETROVIC	05-JAN-83	24.14
;		CBP073		ADD CHECK OF GLOBAL EXCLUDE LISTHEAD TO THE
;				GENERATION OF AUTOLOADABLE GLOBAL SYMBOL
;				ISD ENTRIES.
;
;	J. M. SALMAN	12-JAN-83	24.15
;		JMS095		SET LI$BRY IF /-HD/-PI WAS SPECIFIED AND SET
;				CO$MON IF /-HD/PI WAS SPECIFIED.
;
;	C. B. PETROVIC	15-MAR-84	24.16
;		CBP122		SET LIBRARY PSECT ACCESS ATTRIBUTE
;				TO READ-ONLY RATHER THAN READ-WRITE.
;
;	L. M. PETERSON	31-MAY-88	24.17
;		LMP112		PUT TKB ISD RECORDS IN OVERLAID COMMON STB'S
;				AND FLAG THEM AS SUCH SO I/D TASKS CAN LINK 
;				TO THEM
;
;	C. M. KATZ	23-APR-91	24.18
;		CMK001		ADD RSTS CONDITIONAL CODE
;
; SYMBOL TABLE OUTPUT
;
; EQUATED SYMBOLS
;
; COMPLEX RELOCATION COMMANDS
;

CMPADD=1			; ADDITION
CMPAND=5			; LOGICAL AND
CMPDIV=4			; DIVISION
CMPFTC=20			; FETCH CONSTANT
CMPFTL=21			; FETCH LIBRARY RELOCATION BIAS
CMPSTO=12			; STORE RESULT

;
; GSD ENTRY FORMAT
;

	.DSECT

GSDNM:	.BLKW	2		; RADIX-50 NAME
GSDFL:	.BLKB	1		; FLAGS BYTE
GSDTP:	.BLKB	1		; TYPE CODE
GSDVL:	.BLKW	1		; VALUE WORD


;
; GSD ENTRY TYPES
;

IDNTYP=6			;IDENTIFICATION
SECTYP=5			;P-SECTION NAME
SYMTYP=4			;SYMBOL NAME
TTLTYP=0			;MODULE NAME

CMPTYP=10			; COMPLETION ROUTINE
;
; OBJECT FILE BLOCK TYPES
;

GSDSTR=1			;GSD START
GSDEND=2			;GSD END
MODEND=6			;MODULE END
RLDIR=4				; RELOCATION DIRECTIVE
ISDTYP=5			; INTERNAL SYMBOL DIRECTORY
TXTREC=3			; TEXT STRING

;
; RLD RECORD TYPES
;

CMPLX=17			; COMPLEX RELOCATION
GBLDIS=4			; GLOBAL DISPLACED RELOCATION
GBLADD=5			; GLOBAL ADDITIVE
LIBADD=20			; RESIDENT LIBRARY ADDITIVE
LOCDEF=7			; LOCATION COUNTER DEFINITION
SECADD=15			; P-SECTION ADDITIVE


;
; MACRO LIBRARY CALLS
;

	.MCALL	CLOSE$,OFNB$W,PUT$S

;
; LOCAL DATA
;
; AUTOLOAD VECTOR TEXT AND RLD TEMPLATES
;
; ADJACENCY REQUIRED
;

	IMPURE			; READ/WRITE D-SPACE

	.ENABL	LSB

ALRLD0:	.WORD	RLDIR		; RLD RECORD TYPE
	.WORD	LOCDEF		; SET LOCATION COUNTER
	.RAD50	/$$ALVC/	; AUTOLOAD SECTION
	.WORD	0		; OFFSET INTO SECTION IS ZERO
ALTXT:	.WORD	TXTREC		; AUTOLOAD TEXT TEMPLATE
	.BLKW	1		; OFFSET FROM BASE OF SECTION
10$:	JSR	PC,@.NAUTO	; TRANSFER OF CONTROL INSTRUCTION
20$:	.WORD	40$		; ADDRESS OF SEGMENT DESCRIPTOR
30$:	.WORD	ALVAL		; ADDRESS OF SYMBOL
ALRLD1:	.WORD	RLDIR		; START OF AUTOLOAD VECTOR RLD
	.BYTE	GBLDIS		; GLOBAL DISPLACED RELOCATION
	.BYTE	<10$+2>-ALTXT	; DISPLACEMENT INTO TEXT RECORD
	.RAD50	/.NAUTO/	; INDIRECT AUTOLOAD ENTRYPOINT
	.BYTE	SECADD		; SECTOR ADDITIVE RELOCATION
	.BYTE	20$-ALTXT	; OFFSET INTO TEXT RECORD
	.RAD50	/$$SGD1/	; NAME OF SECTION CONTAINING DESCRIPTOR
40$:	.BLKW	1		; OFFSET INTO SECTION
ALRLD2:	.BLKB	1		; SYMBOL RLD TEMPLATE
	.BYTE	30$-ALTXT	; OFFSET INTO TEXT RECORD
ALVAL:	.BLKW	2		; SYMBOL OFFSET INTO LIBRARY
	.WORD	0		; OFFSET INTO SECTION
ALRLD3:	.BLKW	0		; LENGTH OF RLD RECORD

;
; REGION DESCRIPTOR TEXT AND RLD
;
; ADJACENCY REQUIRED
;

	.ENABL	LSB

REGRL0:	.WORD	RLDIR		; INITIAL RELOCATION DIRECTIVE
	.WORD	LOCDEF		; SET LOCATION COUNTER TO REGION SECTION
	.RAD50	/$$RGDS/	; ADDRESS OF REGION DESCRIPTOR
	.WORD	0		; OFFSET=0
REGTXT:	.WORD	TXTREC		; REGION DESCRIPTOR TEXT
	.WORD	0		; OFFSET MUST BE ZERO
	.WORD	0		; REGION IDENTIFICATION
	.BLKW	1		; REGION SIZE
REGTX0:	.BLKW	2		; REGION NAME
REGTX1:	.BLKW	2		; NAME OF PARTITION
	.WORD	0		; REGION STATUS
	.WORD	0		; REGION PROTECTION
	.WORD	0		; OVERLAY RUNTIME FLAGS
REGTX2:	.BLKW	0		; END OF REGION DESCRIPTOR

	.DSABL	LSB

;
; SEGMENT DESCRIPTOR TEXT AND RLD
;
; ADJACENCY REQUIRED
;

	.ENABL	LSB

SEGRL0:	.WORD	RLDIR		; INITIAL RLD
	.WORD	LOCDEF		; SET LOCATION COUNTER
	.RAD50	/$$SGD1/	; SEGMENT DESCRIPTOR SECTION
	.WORD	0		; OFFSET OF ZERO
SEGTXT:	.WORD	TXTREC		; SEGMENT DESCRIPTOR TEXT
SEGOFF:	.BLKW	1		; OFFSET INTO SECTION
SEGDES:	.BLKW	1		; FLAGS AND DISK ADDRESS
SEGVAD:	.WORD	50$		; SEGMENT VIRTUAL ADDRESS
	.BLKW	1		; LENGTH OF SEGMENT (BYTES)
10$:	.WORD	60$		; LINK-UP
20$:	.WORD	70$		; LINK-DOWN
30$:	.WORD	80$		; LINK-NEXT
	.BLKW	2		; SEGMENT NAME
40$:	.WORD	90$		; ADDRESS OF WINDOW DESCRIPTOR
SEGRL1:	.WORD	RLDIR		; RELOCATION DIRECTIVE
	.BYTE	LIBADD		; LIBRARY ADDITIVE
	.BYTE	SEGVAD-SEGTXT	; DISPLACEMENT INTO TEXT RECORD
50$:	.BLKW	1		; OFFSET OF SEGMENT
	.BYTE	SECADD		; SECTION ADDITIVE RELOCATION
	.BYTE	10$-SEGTXT	; OFFSET INTO TEXT RECORD
	.BLKW	2		; NAME OF SEGMENT DESCIPTOR SECTION
60$:	.BLKW	1		; OFFSET TO LINK-UP
	.BYTE	SECADD		; SECTOR ADDITIVE RELOCATION
	.BYTE	20$-SEGTXT	; OFFSET INTO TEXT RECORD
	.BLKW	2		; NAME OF SEGMENT DESCRIPTOR SECTION
70$:	.BLKW	1		; OFFSET TO LINK-NEXT
	.BYTE	SECADD		; SECTOR ADDITIVE RELOCATION
	.BYTE	30$-SEGTXT	; OFFSET INTO TEXT RECORD
	.BLKW	2		; NAME OF SEGMENT DESCRIPTOR SECTION
80$:	.BLKW	1		; OFFSET TO LINK DOWN
	.BYTE	SECADD		; SECTOR ADDITIVE RELOCATION
	.BYTE	40$-SEGTXT	; OFFSET INTO RECORD
	.BLKW	2		; NAME OF WINDOW DESCRIPTOR SECTION
90$:	.BLKW	1		; OFFSET INTO WINDOW DESCRIPTOR SECTION
SEGRL2:	.BLKW	0		; END OF SEGMENT TEXT AND RLD

	.DSABL	LSB

;
; WINDOW DESCRIPTOR TEXT AND RLD
;
; ADJACENCY REQUIRED
;

	.ENABL	LSB

WNDRL0:	.WORD	RLDIR		; INITIAL RELOCATION DIRECTIVE
	.WORD	LOCDEF		; SET LOCATION COUNTER
	.RAD50	/$$WNDS/	; NAME OF WINDOW DESCRIPTOR SECTION
	.WORD	0		; SECTION BIAS OF ZERO
WNDTXT:	.WORD	TXTREC		; WINDOW DESCRIPTOR TEXT
WNDOFF:	.BLKW	1		; OFFSET INTO SECTION
10$:	.WORD	40$		; WINDOW I/D, WINDOW APR
20$:	.WORD	50$		; WINDOW BASE ADDRESS
	.BLKW	1		; WINDOW SIZE
	.WORD	0		; REGION I/D
	.BLKW	1		; WINDOW OFFSET INTO REGION
	.WORD	0		; LENGTH TO MAP
	.BLKW	1		; WINDOW STATUS
	.WORD	0		; ADDRESS OF SEND/RECIEVE BUFFER
	.BLKW	1		; OVERLAY RUNTIME FLAGS
30$:	.WORD	0		; REGION BACKPOINTER
WNDRL1:	.WORD	RLDIR		; REGION RELOCATION DIRECTIVE
	.BYTE	CMPLX		; COMPLEX RELOCATION FOR REGION APR
	.BYTE	10$-WNDTXT	; OFFSET INTO TEXT RECORD
	.BYTE	CMPFTL		; PUSH LIBRARY BIAS
	.BYTE	CMPFTC		; PUSH CONSTANT
40$:	.BLKB	1		; LOW BYTE OF VIRTUAL OFFSET
	.BLKB	1		; HIGH BYTE OF VIRTUAL OFFSET
	.BYTE	CMPADD		; ADD VIRTUAL OFFSET TO LIBRARY BASE
	.BYTE	CMPFTC		; PUSH CONSTANT
	.BYTE	32.		; LOW BYTE OF CONSTANT
	.BYTE	0		; HIGH BYTE OF CONSTANT
	.BYTE	CMPDIV		; CONVERT TO NUMBER OF APRS
	.BYTE	CMPFTC		; PUSH MASK
	.BYTE	0		; FIRST HALF OF MASK
	.BYTE	7		; SECOND HALF OF MASK
	.BYTE	CMPAND		; MASK OUT EXTRANEOUS BITS
	.BYTE	CMPSTO		; STORE RESULT
WNDRL2:	.BLKB	0		;

	.EVEN

WNDRL3:	.WORD	RLDIR		; RELOCATION DIRECTIVE
	.BYTE	LIBADD		; LIBRARY ADDITVE RELOCATION
	.BYTE	20$-WNDTXT	; OFFSET TO WINDOW BASE
50$:	.BLKW	1		; WINDOW BASE OFFSET
	.BYTE	SECADD		; SECTOR ADDITIVE RELOCATION
	.BYTE	30$-WNDTXT	; OFFSET TO REGION DESCRIPTOR BACKPOINTER
	.RAD50	/$$RGDS/	;
	.WORD	0		; OFFSET MUST BE ZERO
WNDRL4:	.BLKW	0		; END OF RLD

	.DSABL	LSB


CRSCT:	.BLKW	1		; VIRTUAL ADDRESS OF CURRENT SECTION
EOGSD:	.WORD	GSDEND		; END-OF-GSD
EOMOD:	.WORD	MODEND		; END-OF-MODULE
LCLSYM:	.BLKW	10.		; DATA FROM CURRENT SECTION.
PASS:	.BLKW	1		; PASS FLAG
RTSNM:	.RAD50	/$$RTS/		; NAME OF 'RTS' SECTION
RTSLOC:	.BLKW	1		; VIRTUAL ADDRESS OF RTS SECTION
SCTLH:	.BLKW	3		; SECTOR SYMBOL EDIT LISTHEAD
SYMLH:	.BLKW	3		; GLOBAL SYMBOL EDIT LISTHEAD
GSDREC:	.WORD	GSDSTR		; START OF GSD
STBBF:	.BLKW	63.		; GSD RECORD BUFFER
STBSW:	.BLKW	1		; STB FILE SWITCHES

;
; SYMBOLS AND DATA AREAS FOR ISD COPY SUB-PHASE
;
ITMLEN:	.BLKW	1		; LENGTH OF CURRENT ISD ITEM
ISDPTR:	.BLKW	1		; POINTER TO ISD BUFFER
CRPSVA:	.BLKW	1		; CURRENT PSECT DESCRIPTOR VA
TSKID:	.WORD	ISDTYP,1	; TASK IDENTIFICATION RECORD
	.BYTE	2,22.		; ID ITEM IN TKB-CREATED RECORD
	.BLKW	8.		; AREA FOR TIME-STAMP
	.BLKW	2.		; AREA FOR OTHER IDENTIFICATION
TSKIDL=.-TSKID
SEGNAM:	.WORD	ISDTYP,1	; SEGMENT NAME RECORD
	.BYTE	1,8.		; SEGMENT ITEM IN TKB-CREATED RECORD
	.RAD50	/SEGNAM/	; SPACE FOR SEGMENT NAME
	.WORD	0		; SPACE FOR DESCRIPTOR ADDRESS
SGNAML=.-SEGNAM			; LENGTH OF RECORD
;+
; **-$P6STB-PHASE 6 SYMBOL TABLE OUTPUT
;
; THIS ROUTINE IS CALLED AT THE END OF PHASE 5 TO OUTPUT A SYMBOL
; TABLE FILE. THE FILE IS WRITTEN IN OBJECT MODULE FORMAT SO THAT
; IT MAY BE READ BY THE TASK BUILDER.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	SYMBOL TABLE FILE IS WRITTEN.
;-
	PURE.I			; READ-ONLY I-SPACE

$P6STB::SAVRG			;SAVE NONVOLITILE REGISTERS
	MOV	$STBPT,R0	; GET RECORD BLOCK POINTER
	MOV	R0,R4		; SAVE POINTER
	CALL	$STRCB		; SETUP OUTPUT FILE
	MOV	R4,R0		; RETRIEVE POINTER
	OFNB$W	R0		; OPEN SYMBOL FILE
	BCC	5$		; IF C/C OK
	MOV	R$NAME(R0),R2	;GET ADDRESS OF NAME STRING
	MOV	(PC)+,R1	;GET ERROR/SEVERITY
	.BYTE	E$R11,S$V0	;DIAGNOSTIC
	CALL	$ERMSG		;OUTPUT ERROR MESSAGE
	RETURN
5$:				;
	MOV	R$SWTH(R4),STBSW ; COPY FILE SWITCH WORD
	BIT	#SW$NH,STBSW	; TASK IMAGE HAS A HEADER?
	BEQ	7$		; IF EQ YES
	BIT	#<LI$BRY!CO$MON>,$SWOVR ; WAS /LI OR /CO SPECIFIED?
	BNE	7$		; IF NE YES
	BIT	#SW$PI,STBSW	; PIC OUTPUT?
	BNE	6$		; IF NE YES
	CMP	$NUMSG,#1	; OVERLAID TASK IMAGE?
	BEQ	7$		; IF EQ NO - IT MIGHT BE AN EXEC OR DRIVER
	BIS	#LI$BRY,$SWOVR	; DEFAULT TO /LI
	BR	7$		;
6$:	BIS	#CO$MON,$SWOVR	; DEFAULT TO /CO
7$:
	MOV	$RTSEG,R1	; GET VIRTUAL ADDRESS OF ROOT
	CALL	$CVLOK		; CONVERT TO REAL, LOCK IN MEMORY
	MOV	R0,R5		; SAVE REAL ADDRESS
	MOV	#STBBF,R4	; GET ADDRESS OF GSD BUFFER
	MOV	S$GNME(R5),(R4)+ ; SET MODULE NAME
	MOV	S$GNME+2(R5),(R4)+ ; ...
	MOV	#<TTLTYP*400!0>,(R4)+ ; SET RECORD TYPE
	CLR	(R4)+		; CLEAR VALUE FIELD
	MOV	#$IDENT,R0	; POINT TO IDENT.
	MOV	(R0)+,(R4)+	; SETUP IDENT
	MOV	(R0),(R4)+	; ...
	MOV	#<IDNTYP*400!0>,(R4)+ ; SET RECORD TYPE
	CLR	(R4)+		; CLEAR VALUE FIELD
	TST	$CMPRT		; BUILDING SUPERVISOR MODE LIBRARY?
	BEQ	8$		; IF EQ NO
	MOV	$CMPRT,(R4)+	; INSERT SPECIAL GSD ENTRY FOR COMPLETION
	MOV	$CMPRT+2,(R4)+	; ROUTINE
	MOV	#<CMPTYP*400>,(R4)+ ; SET ENTRY TYPE
	MOV	$RTSEG,R1	; LOOK FOR COMPLETEION ROUTINE IN ROOT
	CALL	$CVRL		; CONVERT TO REAL
	ADD	#S$GSTB,R0	; GET ADD OF SYMBOL TABLE
	MOV	#$CMPRT-S$YM,R1	; GET ADDRESS OF SYMBOL
	CALL	$SRCH		; SEARCH FOR SYMBOL
	BCS	40$		; IF CS NOT FOUND
	MOV	S$YVAL(R0),(R4)+ ; GET SYMBOL VALUE
	BIT	#SW$PI,STBSW	; PIC OUTPUT?
	BNE	8$		; IF NE YES
	ADD	$OFFST,-2(R4)	; RELOCATE SYMBOL
8$:
	CLRB	GSDFL(R4)	; CLEAR FLAGS BYTE
	CLR	PASS		; CLEAR PASS FLAG
	BIT	#SW$PI,STBSW	; PIC OUTPUT?
	BNE	10$		; IF NE YES
	BIT	#CO$MON,$SWOVR	; BUILDING COMMON?
	BEQ	9$		; IF EQ, NO
	CMP	$NUMSG,#1	; ABS COMMON OVERLAID?
	BEQ	15$		; IF EQ, NO
9$:	MOV	#$ABSCT,R3	; GET ADDRESS OF ABS SECTION PROTOTYPE
	CALL	OUTSEC		; WRITE SECTION INTO STB FILE
	CALL	P6STB		; OUTPUT SYMBOL TABLE
	INC	PASS		; SET FOR SECOND PASS
10$:				;
	BIT	#LI$BRY,$SWOVR	; BUILDING LIBRARY?
	BNE	11$		; IF NE YES - PRESERVE PSECT NAMES
	BIT	#CO$MON,$SWOVR	; BUILDING COMMON OR JUST CREATING STB FILE?
	BEQ	15$		; IF EQ, JUST CREATING STB FILE
	CMP	$NUMSG,#1	; PIC COMMON OVERLAID?
	BEQ	15$		; IF EQ, NO
11$:	MOV	S$GNME(R5),(R4)+ ; SET PSECT NAME
	MOV	S$GNME+2(R5),(R4)+ ; SET REMAINDER OF NAME
	BISB	#<CS$GBL!CS$ACC!CS$LIB>,(R4)+ ; SET FLAGS TO GBL,RO,LIB
	BIT	#SW$PI,STBSW	; IS THE LIBRARY ALSO PIC?
	BEQ	12$		; IF EQ, NO...ABSOLUTE
	BISB	#CS$REL,-1(R4)	; IF NE, YES...FLAG IT AS RELOCATABLE
12$:
	MOVB	#SECTYP,(R4)+	;SET RECORD TYPE
	MOV	S$GRW(R5),(R4)+	; SET ROOT SEGMENT LENGTH AS PSECT LENGTH
	CALL	PUTGSD		; OUTPUT SECTION NAME
	CMP	$NUMSG,#1	; IS LIBRARY OVERLAID?
	BEQ	15$		; IF EQ NO
	CALL	FLSH		; OUTPUT GSD RECORD
	CALL	P6ATL		; OUTPUT AUTOLOADABLE ENTRY POINTS
	MOV	#STBBF,R4	; GET ADDRESS OF GSD BUFFER
15$:
	CALL	P6STB		; OUTPUT SYMBOL TABLE
	CALL	P6INC		; ADD GLOBAL REFERENCES TO STB FILE
	CALL	FLSH		; FLUSH SYMBOL TABLE BUFFER
	MOV	#EOGSD,R1	; POINT TO END-OF-GSD TEMPLATE
	MOV	#2,R2		; GET BYTE COUNT
	CALL	PUT		; TERMINATE GSD
;
; NOTE:	THE FOLLOWING TWO INSTRUCTIONS INSURE THAT THE OVERLAY DATA BASE
;	IS OUTPUT ONLY WHEN A SHARED REGION IS BEING BUILT.  BY REMOVING
;	THEM, THE OVERLAY DATA BASE WILL BE OUTPUT FOR ANY OVERLAID TASK
;	IMAGE.
;
	.IF	NDF,R$RSTS
	BIT	#<LI$BRY!CO$MON>,$SWOVR ; BUILDING LIBRARY OR COMMON?
	BEQ	20$		; IF EQ NO
	.ENDC
;
	CMP	$NUMSG,#1	; TASK OVERLAID?
	BEQ	20$		; IF EQ NO
	CALL	P6RLD		; WRITE TEXT, RLD FOR OVERLAY STRUCTURE
	BR	25$		;
20$:				;
	MOV	$RTSEG,R1	; GET ADDRESS OF ROOT SEGMENT
	CALL	$UNLPG		; UNLOCK PAGE
25$:				;
	CMP	$ODTAD,#1	; TASK HAVE DEBUGGING AID?
	BEQ	27$		; J IF NOT
	CALL	$P6ISD		; ELSE SCAN OBJECT MODULES COPYING ISD INFO
27$:
	MOV	#EOMOD,R1	; POINT TO END-OF-MODULE TEMPLATE
	MOV	#2,R2		; SET BYTE COUNT
	CALL	PUT		; WRITE END-OF-MODULE RECORD
	CLOSE$	$STBPT		;
30$:				;
	RETURN			;

40$:
	MOV	#<S$V2*400!E$R98>,R2
	CALL	$ERMSG		; FATAL NO RETURN


;
; OUTPUT AUTOLOADABLE LIBRARY ENTRY POINTS IN ISD RECORDS TO BE READ
; DURING PHASE 3 PROCESSING.
;

P6ATL:
	MOV	#STBBF,R4	; USE GSD BUFFER TO CREATE ISD RECORD
	MOV	#ISDTYP,(R4)+	; SET "ISD" RECORD
	MOV	#1,(R4)+	; SET "TKB GENERATED ISD"
	MOV	R5,R3		; COPY SEGMENT DESCR. ADDRESS OF ROOT
	ADD	#S$GATL,R3	; POINT TO THE AUTOLOAD LISTHEAD
10$:
	MOV	(R3),R3		; GET ADDRESS OF NEXT AUTOLOAD ENTRY
	BEQ	40$		; IF EQ NO MORE
	MOV	2(R3),R1	; GET THE V.A. OF THE REAL SYMBOL
	CALL	$CVRL		; CONVERT TO REAL
;
; SEARCH GLOBAL EXCLUDE LIST FOR SYMBOLS TO EXCLUDE FROM THE ISD RECORDS
; FOR AUTOLOADABLE LIBRARY ENTRY POINTS
;

	MOV	#$XCLHD,R1	; GET ADDRESS OF LISTHEAD
12$:

	MOV	(R1),R1		; GET NEXT SYMBOL TO EXCLUDE
	BEQ	14$		; IF EQ NO MORE
	TST	6(R1)		; IS THIS AN INCLUDE OR EXCLUDE ENTRY?
	BNE	12$		; SKIP IT IF "INCLUDE"
	CMP	S$YM(R0),2(R1)	; SYMBOLS MATCH
	BNE	12$		; IF NE NO MATCH - TRY NEXT
	CMP	S$YM+2(R0),4(R1) ; MATCH?
	BEQ	10$		; IF EQ YES - GET NEXT SYMBOL TO PUT IN STB
	BR	12$		; NO MATCH - TRY NEXT SYMBOL IN LIST
14$:
	MOV	(PC)+,(R4)+	; SET ITEM TYPE AND ITEM LENGTH
	.BYTE	3,14		; ITEM 3, 14 BYTES LONG
	MOV	S$YM(R0),(R4)+	; COPY NAME, FIRST HALF
	MOV	S$YM+2(R0),(R4)+ ; COPY THE SECOND HALF
	MOVB	S$YFLG(R0),(R4)+ ; SET SYMBOL FLAGS
	CLRB	(R4)+		; LEAVE THIS BYTE EMPTY
	MOV	S$YVAL(R0),(R4)+ ; SET SYMBOL'S REAL VALUE
	BIT	#SW$PI,STBSW	; PIC OUTPUT?
	BNE	15$		; IF NE YES
	ADD	$OFFST,-2(R4)	; ADD IN THE BIAS
	BICB	#SY$REL,-4(R4)	; MAKE THE SYMBOL ABSOLUTE
15$:
	BIT	#CO$MON,$SWOVR	; OVERLAID COMMON?
	BEQ	16$		; IF EQ, NO
	MOV	#-1,-2(R4)	; FLAG AS ENTRY POINT TO COMMON
16$:
	MOV	S$YSEG(R0),R1	; GET V.A. OF SEGMENT
	CALL	$CVRL		; CONVERT TO REAL
	MOV	S$GSEG(R0),(R4)+ ; SET ADDRESS OF SYMBOL'S SEG. DESCR.
	CALL	30$		; OUTPUT THE ITEM
	BR	10$		; GO AGAIN FOR NEXT SYMBOL...
30$:
	CMP	#STBSW-14,R4	; ROOM FOR ANOTHER ITEM?
	BHI	60$		; IF HI YES
40$:
	MOV	#STBBF+4,-(SP)	; PUSH ADDRESS OF BUFFER (PAST ISD HEADER)
	CMP	R4,(SP)		; ANYTHING IN BUFFER?
	BEQ	50$		; IF EQ NO
	MOV	#STBBF,R1	; POINT TO ISD RECORD
	MOV	R4,R2		; COPY BUFFER POINTER
	SUB	R1,R2		; COMPUTE BYTE COUNT
	CALL	PUT		; OUTPUT THE RECORD
50$:
	MOV	(SP)+,R4	; RESET BUFFER ADDRESS
60$:
	RETURN

;
; OUTPUT OVERLAY DATA BASE IN OBJECT FORMAT
;

P6RLD:				;
	MOV	#RTSNM-S$YM,R1	; POINT TO AUTOLOAD SEGMENT SECTION
	MOV	R5,R0		; GET ADDRESS OF ROOT SEGMENT
	ADD	#S$GCST,R0	; POINT TO SECTION TABLE FOR ROOT
	CALL	$SRCH		; SEARCH FOR SECTION
	MOV	R1,RTSLOC	; SAVE ADDRESS OF SECTION
	CLR	ALTXT+2		; RESET OFFSET INTO AUTOLOAD SECTION
	MOV	R5,R4		; COPY ADDRESS OF ROOT
	ADD	#S$GATL,R4	; POINT TO AUTOLOAD LIST
10$:				;
	MOV	(R4),R4		; GET ADDRESS OF NEXT AUTOLOAD ENTRY
	BEQ	50$		; IF EQ NO MORE
	MOV	#ALTXT+2+10+2,R3 ; POINT TO SYMBOL ADDRESS PLUS OFFSET
	MOV	2(R4),R1	; GET ADDRESS OF REAL SYMBOL
	CALL	$CVRL		; CONVERT TO REAL
	MOV	S$YVAL(R0),@-(R3) ; SET SYMBOL VALUE
	MOV	S$YCMT(R0),-(SP) ; SAVE VIRTUAL ADDRESS OF SECTION
	MOV	S$YSEG(R0),R1	; GET VIRTUAL ADDRESS OF SEGMENT
	CALL	$CVRL		; CONVERT TO REAL
	MOV	S$GSEG(R0),@-(R3) ; SET OFFSET INTO DESCRIPTOR SECTION
	MOV	(SP),R1		; GET ADDRESS OF SECTION
	CALL	$CVRL		; CONVERT SECTION ADDRESS TO REAL
	MOVB	#LIBADD,ALRLD2	; ASSUME NOT AUTOLOADABLE SECTION
	MOV	#ALVAL+2-ALRLD1,(SP) ; SET RECORD LENGTH
	BITB	#CS$IND,C$SFLG(R0) ; INDIRECT DEFINITION?
	BEQ	20$		; IF EQ NO
	MOV	C$SBSE(R0),R1	; GET REAL ADDRESS
20$:				;
	CMP	R1,RTSLOC	; AUTOLOADABLE SEGMENT?
	BNE	30$		; IF NE NO
	MOV	#RTSNM,R0	; POINT TO SECTION NAME
	MOV	2(R3),R1	; GET ADDRESS OF NAME
	MOV	(R0)+,(R1)+	; COPY NAME
	MOV	(R0),(R1)	; ...
	MOV	#ALRLD3-ALRLD1,(SP) ; RESET BYTE COUNT
	MOVB	#SECADD,ALRLD2	; RESET RLD RECORD TYPE
30$:				;
	MOV	#ALRLD0,R1	; POINT TO INITIAL RLD
	MOV	#ALTXT-ALRLD0,R2 ; GET BYTE COUNT
	CALL	PUT		; PUT THE RECORD
	MOV	#ALRLD1-ALTXT,R2 ; SET BYTE COUNT
	CALL	PUT		; PUT THE RECORD
	MOV	(SP)+,R2	; SET BYTE COUNT
	CALL	PUT		; PUT THE RECORD
	ADD	#S$ZATL,ALTXT+2	; RESET AUTOLOAD VECTOR OFFSET INTO SECTION
	BR	10$		; GO AGAIN

;
; OUTPUT SEGMENT DESCRIPTOR TEXT AND RLD
;

50$:				;
	MOV	$RTSEG,R1	; GET ADDRESS OF ROOT SEGMENT
	CALL	$UNLPG		; UNLOCK PAGE
	MOV	#P6SEG,R0	; GET ADDRESS OF PHASE DEPENDANT ROUTINE
	CALLR	$PCTRL		; CALL PHASE DEPENDANT ROUTINE

;
; PHASE DEPENDANT ROUTINE TO OUTPUT SEGMENT DESCRIPTOR TEXT AND RLD
; TO THE STB FILE.
;

P6SEG:				;
	SAVRG			; SAVE THE NON-VOLATILE REGISTERS
	MOV	$CRSEG,R5	; GET ADDRESS OF CURRENT SEGMENT
	MOV	R5,R3		; COPY ADDRESS
	MOV	#SEGOFF,R4	; POINT TO DESCRIPTOR TEXT OFFSET
	MOV	S$GSEG(R5),(R4)+ ; SET OFFSET INTO SECTION

;
; SETUP SEGMENT FLAGS AND RELATIVE DISK BLOCK ADDRESS
;

	MOV	(R3)+,(R4)	; COPY FLAGS
	BIC	#^C<SG$DES!SG$MEM>,(R4) ; CLEAR EXTRANEOUS BITS
	BIS	#<SG$DSK!SG$LOD>,(R4) ; SET SEGMENT LOADED, NO DISK
	SWAB	(R4)		; POSITION SEGMENT FLAGS
	BIT	#SG$RO,(R5)	; R/O SEGMENT?
	BEQ	5$		; IF EQ NO
	TST	(R3)+		; SKIP TO R/0 BLK NUM
	BIS	(R3)+,(R4)+	; COMBINE WITH DISK BLK ADDRESS
	BR	6$		;
5$:
	BIS	(R3)+,(R4)+	; COMBINE WITH DISK BLOCK ADDRESS
	TST	(R3)+		; SKIP OVER R/O DISK BLK ADDRESS
6$:

;
; SETUP VIRTUAL ADDRESS AND SIZE OF SEGMENT
;

	MOV	(R3)+,@(R4)+	; COPY RELATIVE BASE ADDRESS OF SEGMENT
	MOV	(R3)+,(R4)+	; SET SIZE OF SEGMENT IN BYTES

;
; SETUP ADDRESS OF LINK-UP, LINK-DOWN AND LINK-NEXT
;

	MOV	#3,-(SP)	; SET LOOP COUNT
10$:				;
	MOV	#$ABSNM+2,R0	; POINT TO NAME OF ABS. SECTION
	MOV	(R4)+,R2	; POINT TO RLD TEMPLATE
	CLR	(R2)		; CLEAR OFFSET INTO SECTION
	MOV	(R0),-(R2)	; SET NAME OF SECTION
	MOV	-(R0),-(R2)	; ...
	MOV	(R3)+,R1	; GET ADDRESS OF LINK
	BEQ	20$		; IF EQ NONE
	MOV	#^R$$S,(R2)+	; SET NAME OF REL. SECTION
	MOV	#^RGD1,(R2)	; ...
	CALL	$CVRL		; CONVERT TO REAL
	MOV	S$GSEG(R0),@-2(R4) ; GET DISPLACMENT INTO SECTION
20$:				;
	DEC	(SP)		; DECREMENT COUNT
	BGT	10$		; IF GT GO AGAIN
	INC	(SP)+		; CLEAN STACK
	TST	(R3)+		; STEP PAST LINK-PREVIOUS

;
; WRITE SEGMENT NAME INTO TEXT RECORD
;

	MOV	(R3)+,(R4)+	; WRITE FIRST HALF OF NAME
	MOV	(R3)+,(R4)+	; WRITE SECOND HALF OF NAME

;
; WRITE OFFSET INTO WINDOW BLOCK SECTION
;

	MOV	#$ABSNM+2,R0	; POINT TO NAME OF ABS SECTION
	MOV	(R4),R2		; POINT TO RLD TEMPLATE
	CLR	(R2)		; CLEAR OFFSET INTO SECTION
	MOV	(R0),-(R2)	; SET SECTION NAME
	MOV	-(R0),-(R2)	; ...
	CMP	S$GWDP(R5),$RTWDP ; ROOT WINDOW?
	BEQ	25$		; IF EQ YES
	MOV	#^R$$W,(R2)+	; SET NAME OF DESCRIPTOR
	MOV	#^RNDS,(R2)+	; ...
	MOV	S$GWND(R5),(R2)	; SET OFFSET INTO SECTION

;
; NOW EMIT THE TEXT AND RLD INFORMATION FOR THIS SEGMENT
;

25$:				;
	MOV	$SZSEG,R4	; GET SIZE OF SEGMENT DESCRIPTOR
	MOV	#SEGRL0,R1	; GET ADDRESS OF INITIAL RLD
	MOV	#SEGTXT-SEGRL0,R2 ; SET BYTE COUNT
	CALL	PUT		; OUTPUT THE RECORD
	MOV	#4,R2		; ACCOUNT FOR TEXT RECORD HEADER
	ADD	R4,R2		; COMPUTE RECORD LENGTH
	CALL	PUT		; WRITE TEXT RECORD
	MOV	#SEGRL1,R1	; POINT TO RLD
	MOV	#SEGRL2-SEGRL1,R2 ; SET LENGTH OF RECORD
	CMP	R4,#S$ZSEG+2	; WINDOW INFORMATION INCLUDED?
	BHIS	27$		; IF HIS YES
	SUB	#10,R2		; EXCLUDE RLD FOR WINDOW BLOCK
27$:				;
	CALL	PUT		; OUTPUT RLD RECORD

;
; OUTPUT REGION AND WINDOW DESCRIPTORS
;

	CMP	$CRVSG,$RTSEG	; AT MAIN ROOT?
	BNE	30$		; IF NE NO
	TST	$TSKWD		; TASK HAVE RESIDENT OVERLAYS
	BEQ	30$		; IF EQ NO
	MOV	#REGTX0,R0	; POINT TO TEXT BLOCK
	MOV	#REGTX1,R1	; ....
	MOV	#$PNAME,R2	; POINT TO PARTITION NAME
	MOV	(R2),(R0)+	; SETUP NAME
	MOV	(R2)+,(R1)+	; ...
	MOV	(R2),(R0)	; ...
	MOV	(R2),(R1)	; ...
	MOV	#REGRL0,R1	; POINT TO INITIAL RLD
	MOV	#REGTXT-REGRL0,R2 ; SET BYTE COUNT
	CALL	PUT		; OUTPUT THE RECORD
	MOV	#REGTX2-REGTXT,R2 ; SET BYTE COUNT
	CALL	PUT		;

;
; OUTPUT WINDOW DESCRIPTOR IF SEGMENT IS RESIDENT
;

30$:				;
	BITB	#SG$RES,S$GSTS(R5) ; SEGMENT RESIDENT?
	BEQ	40$		; IF EQ NO
	MOV	#WNDOFF,R3	; POINT TO WINDOW SECTION OFFSET
	MOV	S$GWND(R5),(R3)+ ; SET WINDOW DESCRIPTOR OFFSET
	MOV	S$GWDP(R5),R1	; GET ADDRESS OF WINDOW DESCRIPTOR
	CALL	$CVRL		; CONVERT TO REAL
	MOV	W.NBAS(R0),R1	; GET BASE ADDRESS
	MOV	R1,@W.NBAS(R3)	; SET WINDOW BASE
	MOV	W.NID(R3),R2	; GET ADDRESS TO RECEIVE I/D  AND APR
	MOVB	R1,(R2)+	; SET LOW PART OF VIRTUAL BIAS
	SWAB	R1		; POSITION HIGH BYTE
	MOVB	R1,(R2)		; SET HIGH PART OF VIRTUAL BIAS
	MOV	W.NSIZ(R0),W.NSIZ(R3) ; SET WINDOW SIZE
	MOV	W.NOFF(R0),W.NOFF(R3) ; SET REGION OFFSET
	ADD	$LBOFF,W.NOFF(R3) ; INCLUDE BIAS INTO REGION
	MOV	W.NSTS(R0),W.NSTS(R3) ; SET WINDOW STATUS
	MOV	W$NFLG(R0),W$NFLG(R3) ; SET WINDOW FLAGS
	MOV	#WNDRL0,R1	; SET LOCATION OF RECORD
	MOV	#WNDTXT-WNDRL0,R2 ; SET BYTE COUNT
	CALL	PUT		; OUTPUT THE RECORD
	MOV	#WNDRL1-WNDTXT,R2 ; SET BYTE COUNT
	CALL	PUT		; OUTPUT THE TEXT RECORD
	MOV	#WNDRL2-WNDRL1,R2 ; SET BYTE COUNT
	CALL	PUT		; OUTPUT THE RECORD
	MOV	#WNDRL3,R1	; POINT TO RLD RECORD
	MOV	#WNDRL4-WNDRL3,R2 ; SET BYTE COUNT
	CALL	PUT		; OUTPUT THE RECORD
40$:				;
	RETURN			;

;
; OUTPUT SYMBOL TABLE FOR ROOT SEGMENT
;

P6STB:				;
	MOV	R5,R0		; COPY ADDRESS OF ROOT SEGMENT
	BIT	#SE$QA,$SWTCH	; SEQUENCE OUTPUT
	BNE	20$		; IF NE YES
	ADD	#S$GCST,R0	; POINT TO SECTION TABLE LISTHEAD
	MOV	#$ISD,-(SP)	; PUSH ADDRESS OF SYMBOL EDIT ROUTINE
10$:				;
	MOV	#SCTLH,R2	; GET LISTHEAD ADDRESS
	CALL	@(SP)+		; SCAN SECTION TABLE
	MOV	(SP)+,R2	; CLEAN STACK IN CASE SCAN IS COMPLETE
	BCS	40$		; IF C/S DONE
	MOV	R2,-(SP)	; RESTORE STACK
	CALL	50$		; WRITE SECTION INTO STB FILE
	BR	10$		; GO AGAIN
20$:				;
	ADD	#S$GSEQ,R0	; POINT TO SEQUENCE ALLOCATION LISTHEAD
	MOV	R0,-(SP)	; PUSH ADDRESS OF LISTHEAD
30$:				;
	MOV	@(SP)+,R0	; GET ADDRESS OF NEXT ENTRY
	BEQ	40$		; IF EQ DONE
	MOV	R0,-(SP)	; SAVE ENTRY ADDRESS
	MOV	2(R0),R1	; GET ADDRESS OF NEXT
	CALL	$CVRL		; CONVERT TO REAL
	CALL	50$		; OUTPUT SECTION
	BR	30$		; GO AGAIN
40$:				;
	RETURN			;

;
; WRITE SECTION TABLE ENTRY INTO STB FILE AND INITIATE SYMBOL
; TABLE SCAN
;

50$:				;
	MOV	C$SELM(R0),-(SP) ; PUSH ADDRESS OF ELEMENT DESCRIPTOR
	BITB	#CS$IND,C$SFLG(R0) ; INDIRECT DEFINITION?
	BEQ	55$		; IF EQ NO
	MOV	C$SBSE(R0),R1	; GET ADDRESS OF REAL DEFINITION
	CALL	$CVRL		; CONVERT TO REAL
55$:				;
	BITB	#CS$VAS,C$SFLG+1(R0) ; VIRTUAL ARRAY?
	BEQ	57$		; IF EQ NO
	TST	(SP)+		; CLEAN STACK
	BR	67$		; RETURN
57$:
	MOV	R1,CRSCT	; COPY ADDRESS OF CURRENT SECTION
	MOV	#LCLSYM,R3	; GET ADDRESS OF LOCAL SYMBOL BUFFER
	MOV	R3,R1		; COPY BUFFER ADDRESS
	MOV	#C$SLGH/2,R2	; GET LENGTH OF ENTRY IN BYTES
60$:				;
	MOV	(R0)+,(R1)+	; COPY TABLE ENTRY
	SOB	R2,60$		; LOOP
	BITB	#CS$VSC,C$SFLG+1(R3) ; VIRTUAL SECTION?
	BEQ	65$		; IF EQ NO
	BICB	#CS$REL,C$SFLG(R3) ; CLEAR RELOCATABLE FLAG
	CLR	C$SBSE(R3)	; CLEAR SECTION BASE ADDRESS
	CLR	C$SLTH(R3)	; CLEAR LENGTH
65$:				;
	MOV	(SP)+,R1	; GET ADDRESS OF ELEMENT DESCRIPTOR
	CLRB	GSDFL(R4)	; RESET GSD RECORD FLAGS BYTE
	BITB	#CS$RES,C$SFLG+1(R3) ; SECTION TASK-RESIDENT?
	BEQ	70$		; IF EQ NO
	BIT	#SW$PI,STBSW	 ; PIC OUTPUT?
	BNE	90$		; IF NE YES
	TST	PASS		; SECOND PASS?
	BNE	90$		; IF NE YES
67$:				;
	JMP	P6RET		; IGNORE TKB DEFINED SECTIONS ON FIRST PASS
70$:				;
	TST	R1		; ELEMENT DEFINED FOR THIS SECTION?
	BEQ	80$		; IF EQ NO
	MOVB	#CS$LIB,GSDFL(R4) ; SET LIBRARY FLAG
	CALL	$CVRL		; CONVERT ELEMENT ADDRESS TO REAL
	BIT	#SW$RL,E$LSWT(R0) ; LIBRARY ELEMENT?
	BNE	67$		; IF NE, YES, IGNORE THE SECTION...
				; (THIS JUST CORRECTS FOR OUT OF RANGE BRANCH)!
80$:				;
	TST	PASS		; FIRST PASS?
	BNE	67$		; IF NE, NO...IGNORE THE SECTION
				; (THIS JUST CORRECTS FOR OUT OF RANGE BRANCH)!
	BIT	#SW$PI,STBSW	; PIC OUTPUT?
	BNE	85$		; IF NE	YES
	BIT	#CO$MON,$SWOVR	; BUILDING NON-PIC COMMON?
	BEQ	P6SCN		; IF EQ	NO, OUTPUT SYMBOLS ONLY
85$:
	BIT	#LI$BRY,$SWOVR	; BUILDING PIC LIBRARY?
	BNE	P6SCN		; IF NE	YES, OUTPUT SYMBOLS ONLY
90$:				;
	CALL	OUTSEC		; OUTPUT PROGRAM SECTION
	BCS	P6RET		; IF C/S-BLANK SECTION

;
; SCAN SYMBOL TABLE, WRITE ALL GLOBAL SYMBOLS INTO STB FILE
; THAT ARE DEFINED IN CURRENT SECTION.
;

P6SCN:				;
	MOV	R5,R0		; COPY ADDRESS OF ROOT SEGMENT
	ADD	#S$GSTB,R0	; POINT TO GLOBAL SYMBOL TABLE
	MOV	#$ISD,-(SP)	; PUSH ADDRESS OF SYMBOL EDIT ROUTINE
10$:				;
	MOV	#SYMLH,R2	; POINT TO SYMBOL EDIT LISTHEAD
	CALL	@(SP)+		; GET NEXT SYMBOL
	MOV	(SP)+,R2	; CLEAN STACK IN CASE SCAN IS COMPLETE
	BCS	P6RET		; IF C/S DONE
	MOV	R2,-(SP)	; RESTORE STACK
	CLRB	GSDFL(R4)	; CLEAR GSD FLAGS BYTE
	BITB	#SY$IND,S$YFLG(R0) ; INDIRECT DEFINITION?
	BEQ	15$		; IF EQ NO
	CMP	CRSCT,$ASCT	; PROCESSING ABS SECTION?
	BNE	10$		; IF NE NO
	MOV	S$YVAL(R0),R1	; POINT TO REAL DEFINITION
	CALL	$CVRL		; CONVERT TO REAL
	BITB	#SY$REL,S$YFLG(R0) ; SYMBOL RELOCATABLE?
	BEQ	17$		; IF EQ NO
	BICB	#SY$REL,S$YFLG(R0) ; CLEAR RELOCATABLE FLAG
	BISB	#SY$LIB,GSDFL(R4) ; SET LIBRARY BIT
	BR	17$		;
15$:				;
	CMP	S$YCMT(R0),CRSCT ; SYMBOL DEFINED IN CURRENT SECTION?
	BNE	10$		; IF NE NO
17$:				;
	BITB	#SY$LIB,S$YFLG(R0) ; SYMBOL DEFINED IN LIBRARY?
	BNE	10$		; IF NE YES
	MOV	R0,R2		; COPY ADDRESS OF SYMBOL
	ADD	#S$YM,R2	; POINT TO SYMBOL NAME

;
; SEARCH LIST FOR SYMBOLS TO EXCLUDE FOR STB
;

	MOV	#$XCLHD,R1	; GET ADDRESS OF LISTHEAD
18$:

	MOV	(R1),R1		; GET NEXT SYMBOL TO EXCLUDE
	BEQ	19$		; IF EQ NO MORE
	TST	6(R1)		; IS THIS AN INCLUDE OR EXCLUDE ENTRY?
	BNE	18$		; SKIP IT IF "INCLUDE"
	CMP	(R2),2(R1)	; SYMBOLS MATCH
	BNE	18$		; IF NE NO MATCH - TRY NEXT
	CMP	2(R2),4(R1)	; MATCH?
	BEQ	10$		; IF EQ YES - GET NEXT SYMBOL TO PUT IN STB
	BR	18$		; NO MATCH - TRY NEXT
19$:
	MOV	(R2)+,(R4)+	; COPY NAME
	MOV	(R2)+,(R4)+	; ...
	BISB	(R2),(R4)	; COPY FLAGS
	BICB	#^C<SY$GBL!SY$DEF!SY$LIB!SY$REL>,(R4)+ ; CLEAR EXTRANEOUS BITS
	MOVB	#SYMTYP,(R4)+	; SET TYPE=GLOBAL SYMBOL
	MOV	S$YVAL(R0),(R4)+ ; SET SYMBOL VALUE
	BIT	#SW$PI,STBSW	; PIC OUTPUT?
	BNE	20$		; IF NE YES
	BITB	#CS$REL,C$SFLG(R3) ; SECTION RELOCATABLE?
	BEQ	40$		; IF EQ NO
	TST	C$SELM(R3)	; TKB DEFINED SECTION?
	BEQ	25$		; IF EQ YES
193$:
	ADD	$OFFST,-(R4)	; RELOCATE SYMBOL
	BIC	#SY$REL,-(R4)	; MAKE SYMBOL ABSOLUTE
	CMP	(R4)+,(R4)+	; ADJUST BUFFER POINTER
	BR	30$		;
20$:				;
	BITB	#CS$REL,C$SFLG(R3) ; SECTION RELOCATABLE?
	BEQ	40$		; IF EQ NO
25$:				;
	TST	$CMPRT		; WE BUILDING A SUPER-MODE LIBRARY?
	BNE	40$		; IF .NE. YES, DON'T STRIP OFF THE
				; CONTROL SECTION BASE ADDRESS.
				; BUT CHECK THE REST
	BIT	#LI$BRY,$SWOVR	; BUILDING LIBRARY?
	BNE	30$		; IF NE YES - DO SAME AS ABOVE FOR SYMBOLS
;
; NOTE:	THE FOLLOWING TWO INSTRUCTIONS INSURE THAT, WHEN AN OVERLAID
;	RUNNABLE TASK IS BEING BUILT, AN AUTOLOADABLE SYMBOL IS
;	OUTPUT AS ABSOLUTE WHERE THE VALUE IS THE ASSOCIATED AUTOLOAD VECTOR
;	ADDRESS.  REMOVING THEM WILL CAUSE AN AUTOLOADABLE SYMBOL TO APPEAR
;	AS RELOCATABLE WHERE THE VALUE IS AN OFFSET FROM THE PSECT $$ALVC.
;
	.IF	NDF,R$RSTS
	BIT	#CO$MON,$SWOVR	; BUILDING A COMMON?
	BEQ	193$		; IF EQ NO
	.ENDC
;
	SUB	C$SBSE(R3),-2(R4) ; MAKE SYMBOL RELATIVE TO START OF SECTION
30$:				;
	CALL	PUTGSD		; WRITE GSD RECORD
	BR	10$		; PROCESS NEXT SYMBOL
40$:
	TST	$CMPRT		; BUILDING SUPERVISOR LIBRARY
	BEQ	30$		; IF EQ NO
	BIT	#SY$DEF,-4(R4)	; DEFINITION?
	BEQ	30$		; IF EQ NO
	BIT	#SY$ATR,(R2)	; IS THIS DEFINED THRU AN AUTOLOAD VECTOR
	BNE	50$		; IF NE, YES...WANT A WEAK REFERENCE
	BIT	#SY$REL,(R2)	; IF EQ, NO...BUT IS IT AN ABSOLUTE SYMBOL?
	BNE	30$		; IF NE, NO...RELOCATABLE, NO WEAK BIT NEEDED
50$:
	BIS	#SY$WK,-4(R4)	; FLAG AS SUP LIB ABSOLUTE
	BR	30$		;
P6RET:				;
	RETURN			;
;
; ROUTINE TO INSERT GLOBAL REFERENCES INTO THE .STB FILE RESULTING
; FROM THE "GBLINC=SYMBOL" OPTION SPECIFICATIONS
;
P6INC:
	MOV	#$XCLHD,R1	; GET THE INCLUDE/EXCLUDE LISTHEAD
10$:
	MOV	(R1),R1		; LINK TO NEXT ENTRY
	BEQ	20$		; RETURN IF END OF LIST
	TST	6(R1)		; IS THIS AN INCLUDE OR EXCLUDE ENTRY
	BEQ	10$		; SKIP IF "GBLXCL"

	MOV	2(R1),(R4)+	; PUT SYMBOL NAME TO BUFFER
	MOV	4(R1),(R4)+	;
	MOVB	#SY$GBL,(R4)+	; MAKE A REAL GLOBAL REFERENCE OUT OF THIS!
				; 'CAUSE THIS IS WHERE THE FLAGS BYTE IS...
	MOVB	#SYMTYP,(R4)+	; TYPE = GLOBAL SYMBOL
	CLR	(R4)+		; VALUE = 0

	MOV	R1,-(SP)	; SAVE R1
	CALL	PUTGSD		; PUT THE GSD ENTRY OUT
	MOV	(SP)+,R1	; RESTORE R1
	BR	10$		; AND GO FOR THE NEXT "INCLUDE REFERENCE" ENTRY
20$:
	RETURN			; RETURN TO CALLER
	.PAGE
;+
; ROUTINE TO SCAN ALL OBJECT MODULES, SEGMENT BY SEGMENT, COPYING ISD
; RECORDS INTO STB FILE. WHERE NECESSARY, THEY WILL BE REFORMATTED
; FROM RELOCATABLE TO RELOCATED RECORDS. WE WILL ALSO GENERATE TWO
; TYPES OF ISD RECORDS: ONE WHICH CONTAINS THE TIME-STAMP USED TO ENSURE
; TASK IMAGE/STB-FILE CORRELATION, AND ONE FOR EACH SEGMENT IDENTIFYING
; THE SEGMENT.
;-
$P6ISD:
	MOV	#512.,R1	; NUMBER OF BYTES TO ALLOCATE
	CALL	$ALBLK		; ALLOCATE ISD RECORD BUFFER
	MOV	R0,ISDPTR	; SAVE ADDRESS OF BUFFER
	MOV	#$DBTS,R0	; GET TIME STAMP AREA
	MOV	#TSKID+6,R1	; GET OFFSET INTO TASK ID RECORD
	MOV	#8.,R2		; SET WORD COUNT
10$:	MOV	(R0)+,(R1)+	; COPY A WORD AT A TIME...
	SOB	R2,10$		; AND LOOP
	MOV	#TSKID,R1	; SET ADR OF RECORD
	MOV	#TSKIDL,R2	; AND LENGTH
	CALL	PUT		; AND OUTPUT THE RECORD
	MOV	#P6RSC,R0	; SCAN ALL SEGMENTS RESETTING CURRENT
	CALL	$PCTRL		; PSECT BASES
	MOV	#P6ISD,R0	; GET PER-SEGMENT ROUTINE
	CALL	$PCTRL		; AND GO SCAN SEGMENTS
	RETURN			; ALL DONE...
;+
; PER SEGMENT ROUTINE FOR ISD COPY OPERATION. OUTPUT SEGMENT IDENTIFICATION,
; THEN SCAN ALL MODULES IN THE SEGMENT
;-

P6ISD:
	SAVRG		; SAVE NON-VOLATILE REGISTERS
	MOV	$CRSEG,R0	; GET DESCRIPTOR FOR CURRENT SEGMENT
	MOV	S$GNME(R0),SEGNAM+6 ; SET NAME INTO SEGMENT ITEM
	MOV	S$GNME+2(R0),SEGNAM+10 ; AND SECOND WORD...
	MOV	$CRVSG,R0	; GET VA OF CURRENT SEGMENT
	CALL	SEGADR		; GET TASK ADR OF DESCRIPTOR
	MOV	R1,SEGNAM+12	; SET INTO ITEM
	MOV	#SEGNAM,R1	; GET ADDRESS OF RECORD
	MOV	#SGNAML,R2	; AND LENGTH
	CALL	PUT		; AND PUT IT OUT
	CALL	$WSINI		; INITIALISE WHOLE-SEARCH ALGORITHM
;
; NOW SCAN ALL THE OBJECT MODULES
;
	MOV	#$STINP,-(SP)	; PUSH SCAN COROUTINE
10$:	CALL	@(SP)+		; GET NEXT MODULE
	BCS	70$		; J IF NO MORE
20$:	CALL	$GTBYT		; GET LENGTH OF A RECORD
	BCC	25$		; J IF OK
	JMP	ILFMT		; ELSE COMPLAIN
25$:	CALL	$GTWRD		; GET RECORD TYPE
	CMP	R0,#ISDTYP	; IS THIS AN ISD?
	BEQ	30$		; J IF SO
	CLR	$NBYTE		; WHATEVER IT IS, WE DON'T NEED TO COPY IT
	CMP	R0,#MODEND	; IS IT END OF MODULE?
	BNE	20$		; J IF NOT, IGNORE RECORD
	CALL	UPDPSC		; ELSE UPDATE PSECTS
	BR	10$		; AND GO GET NEXT RECORD
30$:	MOV	ISDPTR,R4	; POINT TO COPY BUFFER FOR OUTPUT
	CALL	PUTWRD		; COPY ISD TYPE INTO OUTPUT BUFFER
	CALL	$GTWRD		; GET ISD SUB-TYPE
	CMP	R0,#2		; IS IT A RELOCATABLE RECORD?
	BEQ	45$		; J IF SO, MUST PROCESS IT
	CMP	R0,#1		; TKB GENERATED ISD RECORD?
	BNE	35$		; IF NE NO
	CLR	$NBYTE		; SKIP TO THE NEXT RECORD
	BR	20$		;
35$:
	CALL	PUTWRD		; MOVE TYPE TO BUFFER
40$:	TST	$NBYTE		; ANY MORE DATA?
	BEQ	60$		; NO - GO OUTPUT RECORD
	CALL	$GTBYT		; ELSE GET ANOTHER BYTE
	MOVB	R0,(R4)+	; COPY TO OUTPUT
	BR	40$		; AND LOOP
45$:	MOV	#3,(R4)+	; SET TYPE CODE TO 'RELOCATED'
50$:	TST	$NBYTE		; ANY MORE ISD ITEMS LEFT?
	BEQ	60$		; J IF NOT
	CALL	$GTBYT		; ELSE GET TYPE INFO
	MOVB	R0,(R4)+	; PUT INTO BUFFER
	MOV	R0,R5		; AND SAVE IT
	CALL	$GTBYT		; GET ITEM LENGTH
	MOVB	R0,(R4)+	; INTO BUFFER
	SUB	#2,R0		; ACCOUNT FOR ISD ITEM HEADER WHEN COPYING
	MOV	R0,ITMLEN	; AND STORE IT
	CMP	R5,#MAXITM	; ISD ITEM TYPE IN RANGE?
	BHI	ILFMT		; J IF NOT
	ASL	R5		; MAKE INTO WORD OFFSET
	BEQ	ILFMT		; ALSO ILLEGAL IF ZERO
	CALL	@ISDVCT-2(R5)	; DISPATCH ON ISD TYPE
	BR	50$		; LOOP FOR ANOTHER ITEM
60$:	MOV	R4,R2		; COPY CURRENT BUFFER POSITION
	MOV	ISDPTR,R1	; GET BASE ADDRESS
	SUB	R1,R2		; FORM LENGTH
	CALL	PUT		; OUTPUT THE RECORD
	BR	20$		; AND LOOP - GET ANOTHER RECORD
70$:	RETURN			; NO MORE MODULES IN THIS SEGMENT - ALL DONE

	PURE.D			; READ-ONLY D-SPACE

ISDVCT:				; RELOCATABLE ISD RECORD ITEM DISPATCH TABLE
	.WORD	MODNAM		; MODULE NAME
	.WORD	GBLSYM		; GLOBAL SYMBOL
	.WORD	PSECTN		; PSECT NAME
	.WORD	PCLN		; PC/LINE-NUMBER CORRELATION
	.WORD	INTSYM		; INTERNAL SYMBOL NAME
MAXITM=<.-ISDVCT>/2		; MAXIMUM LEGAL ITEM NUMBER

	PURE.I			; READ-ONLY I-SPACE

MODNAM:	CALLR	CPYITM		; MODULE NAME - JUST COPY THE ITEM
GBLSYM:	CALL	GTSVL		; GLOBAL SYMBOL - GET SYMBOL VALUE
	MOV	R1,R0		; COPY THE VALUE
	CALL	PUTWRD		; COPY VALUE INTO OUTPUT
	MOV	R2,R0		; GET SEGMENT DESCRIPTOR ADDRESS
	CALL	PUTWRD		; OUTPUT THAT TOO
	MOV	#4,R0		; SET NO OF BYTES TO SKIP IIN INPUT
	CALL	SKPBYT		; AND DO SO
	CALLR	CPYITM		; COPY REST OF ITEM
PSECTN:				; PSECT - PERFORM RELOCATION
	CALL	GTCVL		; GET NAME AND INFORMATION FOR PSECT
	MOV	C$SCUR(R1),R0	; GET CURRENT BASE
	CLR	R5		; ASSUME NO RELOCATION
	BIT	#<CS$VAS!CS$VSC*400!CS$LIB>,C$SFLG(R1) ; NEED RELOCATION?
	BNE	10$		; J IF NOT
	BIT	#CS$REL,C$SFLG(R1) ; RELOCATABLE SECTION?
	BEQ	10$		; J IF ABSOLUTE - DON'T RELOCATE
	MOV	$OFFST,R5	; ELSE SET RELOCATION
10$:	ADD	R5,R0		; PERFORM RELOCATION IF REQUIRED
	CALL	PUTWRD		; FOUND BASE - OUTPUT IT
	MOV	C$SBSE(R1),R0	; GET ABSOLUTE SECTION BASE
	ADD	R5,R0		; PERFORM RELOCATION IF REQUIRED
	CALL	PUTWRD		; AND OUTPUT THE WORD
	MOV	R2,-(SP)	; SAVE SEGMENT INFO
	MOV	$CRELM,R2	; GET ELEMENT DESCRIPTOR
	MOV	E$LNUM(R2),R3	; GET SIZE OF PSECT MAPPING TABLE
	INC	R3		; MAKE INTO LOOP COUNT
	MOV	E$LCMT(R2),R2	; GET PSECT MAPPING TABLE
20$:	CMP	(R2)+,CRPSVA	; ENTRY FOR CURRENT PSECT?
	BEQ	30$		; J IF SO
	TST	(R2)+		; ELSE SKIP LENGTH
	SOB	R3,20$		; LOOP
	BR	ILFMT		; ARGH! - PSECT NOT IN CMT
30$:	MOV	(R2)+,R0	; GET LENGTH FOR THIS MODULE
	CALL	PUTWRD		; AND OUTPUT THE WORD
	MOV	(SP)+,R0	; RETRIEVE SEGMENT INFO
	BEQ	40$		; J IF IN CURRENT SEGMENT
	CALL	SEGADR		; ELSE CONVERT TO TASK IMAGE ADR
	MOV	R1,R0		; AND GET TO CORRECT REGISTER
40$:	CALL	PUTWRD		; PUT WORD INTO ISD
	MOV	#8.,R0		; SET COUNT OF BYTES TO SKIP
	CALL	SKPBYT		; AND DO SO
	CALLR	CPYITM		; GO COPY ITEM
PCLN:				; PC/LINE-NUMBER CORRELATION ITEM
	CALL	RELADR		; RELOCATE PSECT/OFFSET INFORRMATION
	CALLR	CPYITM		; OUTPUT THE REST OF THE ITEM
INTSYM:				; INTERNAL SYMBOL ITEM
	CALL	CPYWRD		; COPY OFFSETS
	CALL	$GTBYT		; GET NUMBER OF ADDRESSES TO RELOCATE
	MOV	R0,R5		; SAVE FOR LATER
	MOVB	R0,(R4)+	; AND PUT INTO OUTPUT BUFFER
	DEC	ITMLEN		; ACCOUNT FOR BYTE
	CALL	CPYBYT		; COPY USELESS BYTE
10$:	TST	R5		; AND MORE ADDRESSES TO RELOCATE
	BEQ	20$		; J IF NOT
	CALL	RELADR		; RELOCATE PSECT/OFFSET/SEGMENT INFO
	DEC	R5		; DEC NO OF ADDRESSES
	BR	10$		; AND LOOP
20$:	CALLR	CPYITM		; GO COPY REST OF ITEM
ILFMT:	MOV	$INPPT,R2	; GET INPUT RECORD BLOCK
	MOV	R$NAME(R2),R2	; GET NAMEBLOCK FOR MESSAGE
	MOV	#<S$V2*400!E$R14>,R1 ; SET ERROR/SEVERITY
	CALL	$ERMSG		; REPORT ERROR - FATAL, NO RETURN
;
; OUTPUT A CONTROL SECTION TO THE STB FILE. IF SECTION IS UNNAMED
; AND HAS ZERO LENGTH, THEN BYPASS OUTPUT AND RETURN WITH CARRY SET.
;

	.ENABL	LSB

OUTSEC:				;
	MOV	R4,R0		; COPY ADDRESS OF BUFFER POINTER
	MOV	R3,R1		; COPY ADDRESS OF SECTION DATA
	ADD	#S$YM,R1	; POINT TO SYMBOL NAME
	MOV	(R1)+,(R0)+	; COPY NAME
	BNE	10$		; IF NE NOT BLANK SECTION?
	TST	C$SLTH(R3)	; SECTION HAVE LENGTH?
	SEC			; ASSUME NO
	BEQ	30$		; IF EQ NO
10$:				;
	MOV	(R1)+,(R0)+	; COPY REMAINDER OF NAME
	BISB	(R1)+,(R0)+	; MERGE FLAGS
	MOVB	#SECTYP,(R0)+	; SET RECORD TYPE
	MOV	C$SLTH(R3),(R0)+ ; SET LENGTH OF SECTION
	MOV	R0,R4		; RESET BUFFER POINTER

;
; OUTPUT A GSD RECORD
;

PUTGSD:				;
	CMP	#STBSW-8.,R4	; ROOM FOR ANOTHER ENTRY?
	BHI	30$		; IF HI (CARRY CLEAR) YES

;
; FLUSH CONTENTS OF GSD RECORD BUFFER
;

FLSH:				;
	MOV	#STBBF,-(SP)	; PUSH ADDRESS OF BUFFER
	CMP	R4,(SP)		; ANYTHING IN BUFFER?
	BEQ	20$		; IF EQ NO
	MOV	#GSDREC,R1	; POINT TO GSD RECORD ENTRY
	MOV	R4,R2		; COPY BUFFER ADDRESS
	SUB	R1,R2		; COMPUTE BYTE COUNT
	CALL	PUT		; OUTPUT THE RECORD
20$:				;
	MOV	(SP)+,R4	; RESET BUFFER ADDRESS
30$:				;
	RETURN			;

	.DSABL	LSB


;
; OUTPUT A RECORD TO THE STB FILE
;
;	R1=BUFFER ADDRESS
;	R2=BYTE COUNT
;
; OUTPUTS:
;
;	R1 IS INCREMENTED BY R2
;	R2 IS UNCHANGED
;
; CARRY MUST BE CLEAR UPON EXIT.
;

PUT:				;
	PUT$S	$STBPT,R1,R2	; OUTPUT THE RECORD
	BCC	10$		; IF C/C OK
	MOV	R$NAME(R0),R2	; POINT TO NAME BLOCK
	MOV	#<S$V2*400!E$R25>,R1 ; GET ERROR/SEVERITY
	CALL	$ERMSG		; FATAL, NO RETURN
10$:				;
	ADD	R2,R1		; UPDATE BUFFER POINTER
	RETURN			;

;+
; ROUTINES FOR ISD OUTPUT.
;
; P6RSC - RESET CURRENT BASE TO ABSOLUTE BASE FOR EVERY PSECT IN THIS
; SEGMENT. THIS ROUTINE IS CALLED ONCE PER SEGMENT.
;-
P6RSC:
	SAVRG			; SAVE NON-VOLATILE REGISTERS
	MOV	$CRSEG,R0	; GET ADDRESS OF SECTION
	ADD	#S$GCST,R0	; POINT TO SECTION TABLE
	MOV	#$ISED,-(SP)	; PUSH ADDRESS OF SYMBOL EDIT ROUTINE
10$:
	CALL	@(SP)+		; GET NEXT ENTRY
	BCS	20$		; IS CARRY SET NO MORE
	BITB	#CS$IND,C$SFLG(R0) ; INDIRECT ENTRY?
	BNE	10$		; IF YES, IGNORE
	BITB	#CS$REL,C$SFLG(R0) ; ABSOLUTE SECTION?
	BEQ	10$		; IF YES, IGNORE
	MOV	C$SBSE(R0),C$SCUR(R0) ; RESET CURRENT BASE
	BITB	#CS$VSC,C$SFLG+1(R0) ; VIRTUAL SECTION?
	BEQ	15$		; IF EQ NO
	CLR	C$SCUR(R0)	; CLEAR CURRENT BASE
15$:
	CALL	$WRMPG		; WRITE-MARK DESCRIPTOR
	BR	10$		; GO AGAIN
20$:
	RETURN			; ALL DONE
;+
; UPDPSC - UPDATE CURRENT PSECT ADDRESSES FOR THIS SEGMENT, USING
; THE CMT (CONTROL-SECTION MAPPING TABLE). THIS ROUTINE IS LIFTED
; FROM THE END-OF-MODULE CODE WHICH APPEARS IN SEVERAL PLACES IN PHASE 5.
;-
UPDPSC:
	MOV	$CRELM,R4	; GET CURRENT ELEMENT DESCRIPTOR ADDRESS
	MOV	E$LCMT(R4),R3	; GET CMT ADDRESS
	BEQ	30$		; IF EQ NONE
	MOV	E$LNUM(R4),-(SP) ; GET HIGHEST SECTION NUMBER
	INC	(SP)		; CONVERT TO LOOP COUNT
10$:	MOV	(R3)+,R1	; GET ADDRESS OF ENTRY
	CALL	$CVRL		; CONVERT TO REAL
	CALL	$WRMPG		; WRITE-MARK THE DESCRIPTOR
	MOV	(R3)+,R1	; GET LENGTH FOR THIS ELEMENT
	BITB	#<CS$LIB!CS$ALO>,C$SFLG(R0) ; LIB OR OVR SECTION?
	BNE	20$		; IF EQ YES, DON'T UPDATE
	BITB	#CS$REL,C$SFLG(R0) ; ABS SECTION?
	BEQ	20$		; IF EQ YES, DON'T UPDATE
	ADD	R1,C$SCUR(R0)	; ELSE UPDATE CURRENT BASE
20$:	DEC	(SP)		; DECREMENT LOOP COUNT
	BGT	10$		; LOOP IF GT
	TST	(SP)+		; ELSE CLEAN STACK
30$:
	RETURN			; GET OUT
;+
;
;
; PUTWRD - PUT WORD INTO ISD BUFFER
;
; INPUTS:
;
;	R0	WORD TO BE OUTPUT
;	R4	CURRENT BUFFER ADDRESS
;
; OUTPUTS:
;
;	R4	UPDATED BUFFER ADDRESS
;-
PUTWRD:
	MOVB	R0,(R4)+	; PUT FIRST BYTE
	SWAB	R0		; GET HI BYTE TO LOW END
	MOVB	R0,(R4)+	; PUT HI BYTE
	SWAB	R0		; RESTORE R0
	RETURN			; AND GET OUT
;+
; CPYWRD - COPY WORD FROM INPUT TO OUTPUT
; CPYBYT - COPY BYTE FROM INPUT TO OUTPUT
;-
CPYWRD:	CALL	(PC)		; JUST TREAT A WORD AS TWO BYTES
CPYBYT:	CALL	$GTBYT		; GET A BYTE
	DEC	ITMLEN		; DECREMENT LENGTH OF ITEM
	MOVB	R0,(R4)+	; PUT THE BYTE TO OUTPUT
	RETURN			; AND GO AWAY
;+
; SKPBYT - SKIP BYTES OF INPUT
;
; INPUTS:
;
;	R0	NUMBER OF BYTES TO SKIP
;-
SKPBYT:
	MOV	R0,-(SP)	; SAVE COUNT
10$:	CALL	$GTBYT		; GET A BYTE
	DEC	ITMLEN		; ACCOUNT FOR IT
	DEC	(SP)		; DECREMENT COUNT
	BNE	10$		; LOOP IF STILL SOME TO GO
	TST	(SP)+		; CLEAN STACK
20$:	RETURN			; AND GO AWAY
;+
; CPYITM - COPY REMAINDER OF CURRENT ITEM
;
; INPUTS:
;
;	ITMLEN	REMAINING NUMBER OF BYTES IN ITEM
;-
CPYITM:	MOV	ITMLEN,R1	; GET NO OF BYTES REMAINING
	BEQ	20$		; J IF NONE
10$:	CALL	CPYBYT		; COPY ONE BYTE
	SOB	R1,10$		; LOOP UNTIL DONE
20$:	RETURN			; AND GET OUT
;+
; GTSYM - GET TWO-WORD SYMBOL NAME FROM INPUT TO WORK AREA, AND COPY
; TO OUTPUT
;-
GTSYM:
	CALL	$GTWRD		; GET A WORD
	CALL	PUTWRD		; OUTPUT IT
	MOV	R0,LCLSYM+2	; AND SAVE IT
	CALL	$GTWRD		; SAME AGAIN...
	CALL	PUTWRD		;
	MOV	R0,LCLSYM+4	;
	SUB	#4,ITMLEN	; ACCOUNT FOR FOUR BYTES
	MOV	#LCLSYM,R1	; SET SYMBOL WORK AREA ADDRESS
	RETURN
;+
; GTCVL - GET PSECT INFORMATION FROM INPUT FILE
;
; INPUTS:
;
;	READS PSECT NAME FROM CURRENT ITEM, USING GTSYM
;
; OUTPUTS:
;
;	COPIES PSECT NAME TO OUTPUT
;	R1	REAL ADDRESS OF DESCRIPTOR FOR PSECT
;	R2	ADDRESS OF SEGMENT CONTAINING PSECT, OR 0 IF CURRENT SEG
;	R3	ADDRESS OF SEGMENT CONTAINING PSECT
;	CRPSVA	VA OF DESCRIPTOR FOR PSECT
;-
GTCVL:
	MOV	R0,-(SP)	; SAVE R0
	CALL	GTSYM		; GET THE SYMBOL
	MOV	$CRSEG,R0	; GET VA OF SEGMENT DESCRIPTOR
	ADD	#S$GCST,R0	; GET PSECT NAME HEADER
	CALL	$SRCH		; SEARCH FOR NAME
	BCS	ILFMT1		; ILLEGAL IF NOT ALREADY THERE
	MOV	R1,CRPSVA	; SAVE VA OF SECTION DESCRIPTOR
	CLR	R2		; ASSUME WILL BE IN CURRENT SEGMENT
	MOV	$CRVSG,R3	; AND SET THIS RETURN ACCORDINGLY TOO
	BITB	#CS$IND,C$SFLG(R0) ; INDIRECT DEFINITION?
	BEQ	10$		; J IF NOT, HAVE REAL THING
	MOV	C$SLTH(R0),R2	; ELSE GET CONTAINING SEGMENT
	MOV	R2,R3		; AND COPY FOR RESULT
	MOV	C$SBSE(R0),R1	; GET REAL DESCRIPTOR
	MOV	R1,CRPSVA	; SAVE VA OF REAL DESCRIPTOR
	MOV	R2,-(SP)	; SAVE R2
	CALL	$CVRL		; GET REAL ADDRESS
	MOV	(SP)+,R2	; RESTORE R2
10$:
	MOV	R0,R1		; COPY DESCRIPTOR ADDRESS
	MOV	(SP)+,R0	; RESTORE R0
	RETURN			; AND GET OUT
;+
; GTSVL - GET SYMBOL VALUE
;
; INPUTS:
;
;	READS SYMBOL NAME FROM INPUT STREAM
;
; OUTPUTS:
;
;	COPIES SYMBOL NAME TO OUTPUT STREAM
;	R1	VALUE OF SYMBOL
;	R2	VA OF DESCRIPTOR FOR CONTAINING SEGMENT
;-
GTSVL:
	MOV	R0,-(SP)	; SAVE R0
	CALL	GTSYM		; GET AND COPY SYMBOL NAME
	CALL	$WSRCS		; SEARCH ENTIRE SYMBOL TABLE
	BCS	ILFMT1		; ILLEGAL FORMAT IF NOT FOUND
	TST	(SP)+		; CLEAN COROUTINE FROM STACK
	CLR	R1		; ASSUME VALUE WILL BE ZERO
	CLR	R2		; AND CONTAINING SEGMENT
	BITB	#SY$DEF,S$YFLG(R0) ; SYMBOL DEFINED?
	BEQ	30$		; STRAIGHT OUT IF NOT DEFINED
	BITB	#SY$IND,S$YFLG(R0) ; INDIRECT DEFINITION?
	BEQ	10$		; J IF NOT
	MOV	S$YVAL(R0),R1	; ELSE GET VA OF ACTUAL DESCRIPTOR
	CALL	$CVRL		; CONVERT TO REAL
10$:	MOV	S$YVAL(R0),R1	; GET SYMBOL VALUE
	BITB	#SY$REL,S$YFLG(R0) ; SYMBOL RELOCATABLE?
	BEQ	20$		; J IF NOT
	ADD	$OFFST,R1	; ELSE RELOCATE
20$:
	MOV	S$YSEG(R0),R0	; GET DESCRIPTOR VA FOR CONTAINING SEGMENT
	MOV	R1,-(SP)	; SAVE SYMBOL VALUE
	CALL	SEGADR		; GET TASK ADDRESS OF RESIDENT DESCRIPTOR
	MOV	R1,R2		; COPY TO RIGHT REGISTER
	MOV	(SP)+,R1	; RESTORE SYMBOL VALUE
30$:	MOV	(SP)+,R0	; ...
	RETURN			; AND GET OUT
ILFMT1:	JMP	ILFMT		; BRANCH AID
;+
; SEGADR - EVALUATE TASK IMAGE ADDRESS OF RESIDENT SEGMENT
; DESCRIPTOR, GIVEN VA OF TKB'S SEGMENT DESCRIPTOR
;
; INPUTS:
;
;	R0	TKB VA OF SEGMENT DESCRIPTOR
;
; OUTPUTS:
;
;	R1	TASK ADDRESS OF SEGMENT DESCRIPTOR
;-
SEGADR:
	CLR	R1		; ASSUME TASK IS NON-OVERLAID
	CMP	$NUMSG,#1	; IS THE TASK OVERLAID?
	BEQ	20$		; IF EQ NO
	MOV	R0,R1		; COPY TKB ADDRESS
	MOV	R0,-(SP)	; SAVE R0
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	MOV	S$GSEG+2(R0),R1	; GET DESCRIPTOR ADR OF PSECT
	MOV	S$GSEG(R0),-(SP) ; GET OFFSET INTO PSECT
	CALL	$CVRL		; GET REAL ADR OF PSECT DESCRIPTOR
	MOV	C$SBSE(R0),R1	; COPY PSECT BASE
	ADD	$OFFST,R1		; RELOCATE
	ADD	(SP)+,R1	; ADD OFFSET
	MOV	(SP)+,R0	; RESTORE R0
20$:
	RETURN			; AND GET OUT
;+
; RELADR - RELOCATE FOUR WORD PSECT NAME/OFFSET/DESCRIPTOR BLOCK
;
; INPUTS:
;
;	READS FOUR WORD BLOCK FROM INPUT
;
; OUTPUTS:
;
;	COPIES RELOCATED BLOCK TO OUTPUT
;-
RELADR:
	CALL	GTCVL		; GET PSECT NAME
	CALL	$GTWRD		; GET OFFSET INTO PSECT
	SUB	#2,ITMLEN	; AND ACCOUNT FOR WORD IN ITEM SIZE
	ADD	C$SCUR(R1),R0	; ADD CURRENT BASE OF PSECT
	BIT	#<CS$VAS!CS$VSC*400!CS$LIB>,C$SFLG(R1) ; NEED RELOCATION?
	BNE	10$		; J IF NOT
	BIT	#CS$REL,C$SFLG(R1) ; RELOCATABLE SECTION?
	BEQ	10$		; J IF NOT
	ADD	$OFFST,R0	; ELSE ADD RELOCATION BIAS
10$:	CALL	PUTWRD		; OUTPUT THE ABSOLUTE BASE ADDRESS
	MOV	R3,R0		; GET SEGMENT DESCRIPTOR VA
	CALL	SEGADR		; AND MAKE TASK ADDRESS
	MOV	R1,R0		; COPY TO RIGHT REGISTER
	CALL	PUTWRD		; OUTPUT THAT WORD
	MOV	#2,R0		; SET BYTES TO SKIP
	CALL	SKPBYT		; AND SKIP THEM
	RETURN			; NOW GET OUT
	.END

	.END
