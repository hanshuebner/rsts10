	.TITLE	P5ELM
	.IDENT	/15.10/
;
; COPYRIGHT (c)	1991 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE IS FURNISHED  UNDER A LICENSE AND MAY BE USED OR
; COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;
; D. N. CUTLER/C. MONIA 27-JAN-74
;
;
;
; MODIFIED FOR RSX-11M/M-PLUS V4.0/V2.0 BY:
;
;	J. A. KASSON
;	C. B. PETROVIC
;
; MODIFIED BY:
;
;	C. B. PETROVIC	26-FEB-82	15.01
; 		CBP039		ADD CORRECT .PSECT DEFINITIONS TO
;				ALLOW TKB TO BE LINKED AS AN I/D TASK.
;
;	C. B. PETROVIC	26-MAR-82	15.02
;		CBP045		CHANGE AUTOLOAD VECTOR FORMAT TO USE
;				THE IMPURE AREA POINTER .NAUTO TO
;				ACCESS THE ROUTINE $AUTO IN PREPARATION
;				FOR I/D AUTOLOAD SUPPORT.
;
;	C. B. PETROVIC	4-MAY-82	15.03
;		CBP050		CONVERT TO MODIFIED FORMAT AUTOLOAD VECTOR
;				GENERATION TO FACILITATE I/D AUTOLOAD
;				SUPPORT AS WELL AS SELECTIVE INCLUSION OF
;				ONLY THOSE AUTOLOADABLE SYMBOLS ACTUALLY
;				REFERENCED BY THE USER TASK.
;
;	J. M. SALMAN	25-JUN-82	15.04
;		JMS050		SUPPORT SELECTIVE INCLUSION OF AUTOLOAD
;				VECTORS USING NEW TKB-GENERATED ISD RECORD.
;
;	J. M. SALMAN	06-OCT-82	15.05
;		JMS077		COMPLETE CBP039.
;
;	J. M. SALMAN	07-DEC-82	15.06
;		JMS051		FIX .LIMIT DIRECTIVE FOR I/D TASKS SO THAT
;				D-SPACE ADDRESS LIMITS ARE FILLED IN WHEN
;				THE DIRECTIVE APPEARS IN A D PSECT.  THIS
;				CORRECTION SOMEHOW GOT LOST EARLIER.
;
; MODIFIED FOR RSX-11M-PLUS AND MICRO/RSX V4.0 BY:
;
;	L. M. PETERSON	9-SEP-86	15.07
;		LMP045		ADD SUPPORT FOR OTS OPTIMIZATION (MODIFY 
;				RESIDENT LIBRARY SEGMENT DESCRIPTORS AS THEY
;				ARE READ IN AND WRITTEN OUT)
;
;	L. M. PETERSON	4-DEC-86	15.08		SPR# 0233P
;		LMP073		SET R.GSTS IN CLUSTER LIBRARIES' REGION 
;				DESCRIPTORS PER CLSTR ACCESS CODE (IN 
;				CONJUNCTION WITH CHANGE TO OTS TO MAKE OTS 
;				ATTACH REGION PER CLSTR OPTION ACCESS CODE)
;
; MODIFIED FOR RSX-11M-PLUS AND MICRO/RSX V4.1 BY:
;
;	L. M. PETERSON	20-OCT-87	15.09
;		LMP099		MODIFY OTS OPTIMIZATION SUPPORT TO ALLOW
;				BACKWARD COMPATIBILITY WITH RESIDENT
;				LIBRARIES BUILT BEFORE V2.1 (OLD STYLE
;				OBJECT MODULE RECORDS)
;
; MODIFIED FOR RSX-11M-PLUS AND MICRO/RSX V4.1 BY:
;
;	L. M. PETERSON	8-JAN-91	15.10
;		LMP156		FIX .LIMIT SO IT WORKS CORRECTLY WITH LMP131
;				CHANGES (EXTEND TASKS WITH MR OVERLAYS)
;
; PHASE 5 ELEMENT PROCESSING
;
; LOCAL DATA
;
	IMPURE			; READ/WRITE D-SPACE

BEGST:	.BLKW	1		;++004 BEGINING OF COMPLEX RELOCATION STACK
CMDBT:	.BLKW	1		;RLD COMMAND BYTE
CRADR:	.BLKW	1		;CURRENT VIRTUAL ADDRESS (MINUS 4)
CRSCT:	.BLKW	10.		; CURRENT CONTROL SECTION DATA
ENDST:	.BLKW	1		;++004 END OF COMPLEX RELOCATION STACK
LCLSYM:	.BLKW	6		;LOCAL SYMBOL DESCRIPTOR
SUPLIB:	.BLKW	1		; ELEMENT FROM SUPERVISOR MODE LIBRARY
SKPALV:	.BLKW	1		; FLAG - SKIP OVER AUTOLOAD VECTORS IF SET

LIBBLK=.			; START OF LOCAL LIBRARY DATA BLOCK
RESLIB:	.BLKW	1		; FLAG - CURERNT ELEMENT FROM RESIDENT LIBRARY
CLSLIB:	.BLKW	1		; FLAG - CURRENT ELEMENT FROM CLUSTER LIBRARY
FIRST:	.BLKW	1		; FLAG 1ST ELEMENT FROM RESIDENT LIBRARY (ROOT)
SGDBYT:	.BLKW	1		; SEGMENT DESCRIPTOR BYTE COUNT
RGDBYT:	.BLKW	1		; REGION DESCRIPTOR BYTE COUNT
ROOTVL: .BLKW	1		; VIRTUAL ADDRESS OF ROOT SEGMENT
SEGLTH:	.BLKW	1		; SEGMENT LENGTH
SEGNME:	.BLKW	1		; VIRTUAL ADDRESS OF SEGMENT NAME FIELD
SEGFLG:	.BLKW	1		; FLAG RLD TYPE 20 FOLLOWING TXT RECORD
LIBSIZ=.-LIBBLK/2		; SIZE OF LOCAL LIBRARY DATA BLOCK

;
; DEFINE OBJECT FILE RECORD TYPES WHICH ARE IGNORED BY TKB
;
; NOTE THAT IN THE CURRENT IMPLEMENTATION, RECORD TYPES IN THE RANGE
; OBRDEC-OBRMAX ARE IGNORED. ANY TYPE UNIMPLEMENTED BY DIGITAL OR
; GREATER THAN OBRMAX IS CONSIDERED A FILE FORMAT ERROR.
;
	OBRDEC = 100.		; RESERVED TO DIGITAL (0.-100.)
	OBRCUS = 201.		; RESERVED TO CUSTOMER (201.-255.)
	OBRMAX = 255.		; MAXIMUM TYPE CONSIDERED LEGAL
;+
; **-$P5ELM-PHASE 5 ELEMENT PROCESSING
;
; THIS ROUTINE IS CALLED TO PROCESS EACH ELEMENT IN PHASE 5. THE
; ELEMENT IS RELOCATED AND THE TASK IMAGE IS WRITTEN.
;
; INPUTS:
;
;	$CRELM=ADDRESS OF CURRENT ELEMENT DESCRIPTOR.
;	$CRSEG=ADDRESS OF CURRENT SEGMENT DESCRIPTOR.
;
; OUTPUTS:
;
;	NONE.
;-
	PURE.I			; READ-ONLY I-SPACE

$P5ELM::SAVRG			;SAVE NONVOLITILE REGISTERS
	CLR	SUPLIB		; ASSUME NOT SUPERVISOR MODE LIBRARY
	CLR	SKPALV		; CLEAR SKIP-AUTOLOAD-VECTORS FLAG
	MOV	#LIBBLK,R0	; GET START OF LOCAL LIBRARY DATA BLOCK
	MOV	#LIBSIZ,R1	; GET SIZE OF LOCAL LIBRARY DATA BLOCK
2$:	CLR	(R0)+		; CLEAR LOCAL LIBRARY DATA BLOCK
	SOB	R1,2$		;
	MOV	$CRELM,R0	; GET ADDRESS OF ELEMENT DESCRIPTOR
	BIT	#SW$CLS,E$LSWT(R0) ; ELEMENT A CLUSTER LIBRARY?
	BEQ	3$		; IF EQ NO
	INC	CLSLIB		; SET CLUSTER FLAG
3$:
	BIT	#SW$RL,E$LSWT(R0) ; ELEMENT A RESIDENT LIBRARY?
	BEQ	4$		; IF EQ NO
	INC	RESLIB		; SET RESIDENT FLAG
	BR	5$
4$:
	BIT	#SW$SUP,E$LSWT(R0) ; ELEMENT A SUPERVISOR MODE LIBRARY?
	BEQ	5$		; IF EQ NO
	INC	$SUPOF		; INCREMENT OFFSET
	INC	SUPLIB		; FLAG ELEMENT FROM SUP LIB
5$:
	BIT	#SW$ALE,E$LSWT(R0) ; LIBRARY ELEMENT CONTAINING AUTOLOADABLE
				   ;  ENTRY POINT ISD RECORDS?
	BEQ	7$		; IF EQ NO
	INC	SKPALV		; SET FLAG TO SKIP OVER AUTOLOAD VECTORS
7$:
	CALL	$WSINI		; INITIALIZE WHOLE-SEARCH ALGORITHM
	MOV	$ASCT,R1	; GET VIRTUAL ADDRESS OF CURRENT SECTION
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	MOV	R0,R1		; COPY REAL ADDRESS
	CALL	CPYSCT		; COPY SECTION DATA
	MOV	$CRVSG,R0	; GET VIRTUAL ADDRESS OF CURRENT SEGMENT
	CALL	$ADRST		;SET ADDRESS LIMITS
10$:	CALL	$GTBYT		;GET RECORD LENGTH
	BCS	20$		;IF CS EOF (ILL FORMAT)
	MOV	R0,R3		;SAVE RECORD LENGTH
	CALL	$GTWRD		;GET BLOCK TYPE
	SUB	#2,R3		;ADJUST BYTE COUNT
	CMP	R0,#LGBLK	;LEGAL BLOCK TYPE?
	BLOS	30$		;IF LOS YES
	CLR	$NBYTE		; ANYTHING ELSE IS ILLEGAL OR IGNORED
	CMP	#OBRMAX,R0	; GREATER THAN LEGAL TYPE?
	BLO	20$		; YES, FILE FORMAT ERROR
	CMP	#OBRCUS,R0	; WITHIN CUSTOMER RESERVED RANGE?
	BLOS	10$		; IF YES, JUST GO FOR NEXT RECORD
20$:	CLR	R0		;SET ZERO BLOCK TYPE
30$:	ASL	R0		;MAKE WORD INDEX
	CALL	@DSPVCT(R0)	;CALL BLOCK DEPENDENT ROUTINE
	BR	10$		;GO AGAIN

;
; DISPATCH VECTOR
;

	PURE.D			; READ-ONLY D-SPACE

DSPVCT:	.WORD	ILFMT		;BLK 0-ILLEGAL BLOCK TYPE
	.WORD	RPEAT		; BLK 1-START GSD
	.WORD	ENGSD		;BLK 2-END GSD
	.WORD	TXT		;BLK 3-TXT
	.WORD	RLD		;BLK 4-RLD
	.WORD	RPEAT		;BLK 5-ISD
	.WORD	MODND		;BLK 6-MODULE END
LGBLK=<.-DSPVCT-2>/2		;HIGHEST LEGAL BLOCK TYPE

	PURE.I			; READ-ONLY I-SPACE

;
; TXT-BLOCK TYPE 3
;

TXT:	BIT	#TS$KF,$SWTCH	;TASK IMAGE FILE SPECIFIED?
	BEQ	RPEATX		; IF EQ NO - BRANCH TO XFER TO RPEAT
	CALL	$GTWRD		;GET LOAD ADDRESS
	SUB	#2,R3		;ADJUST BYTE COUNT
	MOV	#CRSCT,R2	; GET ADDRESS OF CURRENT SECTION
	BITB	#<CS$VSC!CS$VAS>,C$SFLG+1(R2) ; VIRTUAL SECTION?
	BNE	100$		; IF NE YES, ILLEGAL
	BITB	#CS$REL,C$SFLG(R2)  ;ABS SECTION?
	BEQ	10$		;IF EQ YES
	ADD	C$SCUR(R2),R0	;ADD CURRENT SECTOR BASE
	ADD	$OFFST,R0	;ADD OFFSET BIAS
10$:	MOV	R0,R4		;SAVE LOAD ADDRESS
	SUB	#4,R0		;BIAS FOR DISPLACEMENT BYTES
	MOV	R0,CRADR	;STORE AS CURRENT VIRTUAL ADDRESS
	MOV	#CRSCT,R1	; GET CURRENT SECTION
	TST	CLSLIB		; CURRENT ELEMENT CLUSTER LIBRARY?
	BEQ	30$		; IF EQ, NO (MIGHT BE RESLIB)
	CMP	C$SNME(R1),#^R$$R   ; CURRENT SECTION $$RGDS?
	BNE	30$		; IF NE, NO (MIGHT BE $$SGD1)
	CMP	C$SNME+2(R1),#^RGDS ; SECOND HALF MATCH?
	BNE	50$		; IF NE, NO (WON'T BE RESLIB $$SGD1 EITHER)
15$:	CALL	$GTBYT		;GET NEXT BYTE
	INC	RGDBYT		; UPDATE BYTE COUNT OF REGION DESCRIPTOR
	CMP	#R$GLGH+3,RGDBYT  ; REACHED END OF REGION DESCRIPTOR?
	BNE	20$		; IF NE, NO - CHECK FOR ACCESS BYTE
	MOV	#1,RGDBYT	; RESET FOR NEW REGION DESCRIPTOR
	BR	25$		; WRITE OUT AND GET NEXT BYTE
20$:	CMP	#13.,RGDBYT	; REACHED ACCESS BYTE?
	BNE	25$		; IF NE, NO - WRITE OUT AND GET NEXT BYTE
	CALL	RGDCHK		; CHECK ACCESS FOR CLUSTER LIBRARY
25$:	MOV	R0,R1		;TEXT BYTE TO R1
	MOV	R4,R0		;VIRTUAL ADDRESS TO R0
	CALL	$WRBYT		;WRITE BYTE INTO IMAGE FILE
	INC	R4		;INCREMENT VIRTUAL ADDRESS
	SOB	R3,15$		;REPEAT
	BR	90$		;DONE

30$:	TST	$AFLG		; USING AUTOLOAD?
	BEQ	50$		; IF EQ, NO
	TST	RESLIB		; CURRENT ELEMENT RESIDENT LIBRARY?
	BEQ	50$		; IF EQ, NO
35$:	CMP	C$SNME(R1),#^R$$S   ; CURRENT SECTION $$SGD1?
	BNE	50$		; IF NE, NO
	CMP	C$SNME+2(R1),#^RGD1 ; SECOND HALF MATCH?
	BNE	50$		; IF NE, NO
40$:	CALL	$GTBYT		;GET NEXT BYTE
	CALL	SGDCHK		; MODIFY $$SGD1 CONTRIBUTIONS FROM RES LIB
SGDRET=.
	MOV	R0,R1		;TEXT BYTE TO R1
	MOV	R4,R0		;VIRTUAL ADDRESS TO R0
	CALL	$WRBYT		;WRITE BYTE INTO IMAGE FILE
SGDSKP=.-SGDRET
	INC	R4		;INCREMENT VIRTUAL ADDRESS
	SOB	R3,40$		;REPEAT
	BR	90$		; DONE

50$:	CALL	$GTBYT		;GET NEXT BYTE (REGULAR RECORD)
	MOV	R0,R1		;TEXT BYTE TO R1
	MOV	R4,R0		;VIRTUAL ADDRESS TO R0
	CALL	$WRBYT		;WRITE BYTE INTO IMAGE FILE
	INC	R4		;INCREMENT VIRTUAL ADDRESS
	SOB	R3,50$		;REPEAT
90$:	RETURN			;
100$:				;
	MOV	#<S$V2*400!E$R91>,R1 ; GET ERROR/SEVERITY
	MOV	$INPPT,R2	; GET INPUT FILE RECORD BLOCK
	MOV	R$NAME(R2),R2	; POINT TO NAME BLOCK
	CALL	$ERMSG		; FATAL, NO RETURN

RPEATX:	JMP	RPEAT		; TRANSFER TO RPEAT

;
; RLD-BLOCK TYPE 4
;

RLD:	BIT	#TS$KF,$SWTCH	;TASK IMAGE FILE SPECIFIED?
	BEQ	RPEAT		;IF EQ NO
10$:	CALL	$GTBYT		;GET COMMAND BYTE
	MOV	R0,CMDBT	;SAVE COMMAND BYTE
	CALL	$GTBYT		;GET DISPLACEMENT BYTE
	SUB	#2,R3		;ADJUST BYTE COUNT
	MOV	R0,R4		;SAVE DISPLACEMENT BYTE
	ADD	CRADR,R4	;CALCULATE VIRTUAL ADDRESS
	MOV	CMDBT,R0	;RETRIEVE COMMAND BYTE
	BIC	#177600,R0	;CLEAR GARBAGE BITS
	CMP	R0,#LGCMD	;LEGAL COMMAND?
	BHI	20$		;IF HI NO
	ASL	R0		;MAKE WORD INDEX
	MOV	#CRSCT,R5	; GET ADDRESS OF CURRENT SECTION DATA
	CALL	@RLDVCT(R0)	;DISPATCH TO RELOCATION ROUTINE
	TST	R3		;ANY MORE TO PROCESS?
	BGT	10$		;IF GT YES
	RETURN			;
20$:	JMP	ILFMT		;

;
; RPEAT-BLOCK TYPE 5
;

RPEAT:	CLR	$NBYTE		;CLEAR BYTE COUNT
	RETURN			;

;
; RLD DISPATCH VECTOR
;

	PURE.D			; READ-ONLY D-SPACE

RLDVCT:	.WORD	ILFMT		;ILLEGAL FORMAT
	.WORD	INTREL		;INTERNAL RELOCATION
	.WORD	GBLREL		;GLOBAL RELOCATION
	.WORD	INTDIS		;INTERNAL DISPLACED RELOCATION
	.WORD	GBLDIS		;GLOBAL DISPLACED RELOCATION
	.WORD	GBLADD		;GLOBAL ADDITIVE RELOCATION
	.WORD	GADDIS		;GLOBAL ADDITIVE DISPLACED RELOCATION
	.WORD	LOCDEF		;LOCATION COUNTER DEFINITION
	.WORD	LOCMOD		;LOCATION COUNTER MODIFICATION
	.WORD	LIMIT		;LIMIT DIRECTIVE
	.WORD	SECREL		;SECTOR RELOCATION
	.WORD	ILFMT		;ILLEGAL FORMAT
	.WORD	SCRDIS		;SECTOR DISPLACED RELOCATION
	.WORD	SECADD		;SECTOR ADDITIVE RELOCATION
	.WORD	SECDIS		;SECTOR ADDITIVE DISPLACED RELOCATION
	.WORD	CPLREL		;++004 COMPLEX RELOCATION
	.WORD	LIBADD		; RESIDENT LIBRARY ADDITIVE RELOCATION
LGCMD=<.-RLDVCT-2>/2		;HIGHEST LEGAL RLD TYPE

	PURE.I			; READ-ONLY I-SPACE

;
; INTERNAL RELOCATION
;

INTREL:				;
	CALL	$GTWRD		; GET CONSTANT
	MOV	R0,-(SP)	; SAVE CONSTANT
	MOV	C$SCUR(R5),R0	; GET CURRENT SECTION BASE
	MOV	R5,R1		; COPY SECTION ADDRESS
	CALL	GTMOD		; REDUCE TO MODULUS OF WINDOW
	BCS	10$		; IF C/S VIRTUAL SECTION
	ADD	$OFFST,R0	;ADD OFFSET BIAS
10$:				;
	ADD	(SP)+,R0	; INCLUDE CONSTANT
	BR	ADJCNT		;

;
; GLOBAL RELOCATION
;

GBLREL:	CALL	GTSVL		;GET SYMBOL VALUE
	BR	IMGOUT		;

;
; INTERNAL DISPLACED RELOCATION
;

INTDIS:	CALL	$GTWRD		;GET CONSTANT
	SUB	R4,R0		;CALCULATE DISPLACEMENT
	SUB	#2,R0		;
	BR	ADJCNT		;

;
; GLOBAL DISPLACED RELOCATION
;

GBLDIS:	CALL	GTSVL		;GET SYMBOL VALUE
	SUB	R4,R0		;CALCULATE DISPLACEMENT
	SUB	#2,R0		;
	BR	IMGOUT		;

;
; GLOBAL ADDITIVE RELOCATION
;

GBLADD:	CALL	GTSVL		;GET SYMBOL VALUE
	MOV	R0,-(SP)	;SAVE VALUE
	CALL	$GTWRD		;GET ADDITIVE CONSTANT
	ADD	(SP)+,R0	;ADD CONSTANT
	BR	ADJCNT		;

;
; GLOBAL ADDITIVE DISPLACED RELOCATION
;

GADDIS:	CALL	GTSVL		;GET SYMBOL VALUE
	MOV	R0,-(SP)	;SAVE VALUE
	CALL	$GTWRD		;GET CONSTANT
	ADD	(SP)+,R0	;ADD CONSTANT
	SUB	R4,R0		;CALCULATE DISPLACEMENT
	SUB	#2,R0		;
	BR	ADJCNT		;

;
; SECTOR RELOCATION
;

SECREL:	CALL	GTCVL		;GET CURRENT SECTOR BASE
	CALL	GTMOD		; REDUCE R0 TO MODULUS OF WINDOW SIZE
	BR	IMGOUT		;

;
; SECTOR DISPLACED RELOCATION
;

SCRDIS:	CALL	GTCVL		;GET CURRENT SECTOR BASE
	CALL	GTMOD		; REDUCE R0 TO MODULUS OF WINDOW SIZE
	SUB	R4,R0		;CALCULATE DISPLACEMENT
	SUB	#2,R0		;
	BR	IMGOUT		;

;
; RESIDENT LIBRARY ADDITIVE RELOCATION
;

LIBADD:				;
	CALL	GTLIB		; GET LIBRARY OFFSET BIAS
	MOV	R0,-(SP)	; SAVE OFFSET BIAS
	CALL	$GTWRD		; GET ADDITIVE CONSTANT
	ADD	(SP)+,R0	; ADD LIBRARY BIAS
	TST	$AFLG		; USING AUTOLOAD?
	BEQ	10$		; IF EQ, NO
	TST	SEGFLG		; THIS RELOCATION FOLLOWS SGD1 TXT REC?
	BEQ	10$		; IF EQ, NO
	MOV	R0,-(SP)	; SAVE VIRTUAL LOAD ADDRESS
	MOV	SEGNME,R0	; POINT TO 2ND HALF OF SEGMENT NAME FIELD
	ADD	#2,R0		; (TO STORE I-WINDOW SIZE, APR)
	MOV	SEGLTH,R1	; CONVERT SEGMENT LENGTH TO ROUNDED UP WINDOW SZ
	ADD	#77,R1		; (IN 64B BLOCKS)
	ROR	R1		;
	CLC			;
	ROR	R1		;
	ASR	R1		;
	ASR	R1		;
	ASR	R1		;
	ASR	R1		;
	ADD	#177,R1		; GOT 64B BLKS, NOW ROUND UP TO NEXT 4K BOUNDARY
	BIC	#177,R1		;
	ASR	R1		;
	ASR	R1		;
	ASR	R1		; LEAVE IN BITS 3-5
	MOV	(SP),R2		; NEXT  CONVERT VIRTUAL LOAD ADDRESS TO APR
	ASL	R2		;
	ROL	R2		;
	ROL	R2		;
	ROL	R2		;
	BIS	R2,R1		; AND PUT IN BITS 0-2
	CALL	$WRWRD		;
	MOV	(SP)+,R0	; RESTORE VIRTUAL LOAD ADDRESS AND GO
	CLR	SEGFLG		; RESET FOR NEXT SGD1 TXT RECORD
10$:	BR	ADJCNT		; ADJUST COUNT


;
; SECTOR ADDITIVE RELOCATION
;

SECADD:	CALL	GTCVL		;GET CURRENT SECTOR BASE VALUE
	CALL	GTMOD		; REDUCE RESULT TO MODULUS OF WINDOW
	MOV	R0,-(SP)	;SAVE VALUE
	CALL	$GTWRD		;GET ADDITIVE CONSTANT
	ADD	(SP)+,R0	;ADD CONSTANT
	BR	ADJCNT		;

;
; SECTOR ADDITIVE DISPLACED RELOCATION
;

SECDIS:	CALL	GTCVL		;GET CURRENT SECTOR BASE VALUE
	CALL	GTMOD		; REDUCE RESULT TO MODULUS OF WINDOW
	MOV	R0,-(SP)	;SAVE VALUE
	CALL	$GTWRD		;GET ADDITIVE CONSTANT
	ADD	(SP)+,R0	;ADD CONSTANT
	SUB	R4,R0		;CALCULATE DISPLACEMENT
	SUB	#2,R0		;


;
; ADJUST BYTE COUNT
;

ADJCNT:	SUB	#2,R3		;ADJUST BY ONE WORD

;
; IMAGE OUTPUT
;

IMGOUT:	MOV	#$WRWRD,-(SP)	;ASSUME WORD WRITE
	BIT	#200,CMDBT	;BYTE COMMAND?
	BEQ	10$		;IF EQ NO
	MOV	#$WRBYT,(SP)	;SET FOR BYTE WRITE
	BIT	#177400,R0	;TOP BYTE ZERO?
	BEQ	10$		;IF EQ YES BYPASS TEST
	MOVB	R0,R2		;COPY BYTE
	CMP	R0,R2		;IDENTICAL RESULT?
	BEQ	10$		;IF EQ YES
	MOV	R0,-(SP)	;SAVE OUTPUT VALUE
	MOV	$CRELM,R2	;GET ADDRESS OF ELEMENT DESCRIPTOR
	ADD	#E$LMOD,R2	;POINT TO MODULE NAME
	MOV	(PC)+,R1	;GET ERROR/SEVERITY
	.BYTE	E$R27,S$V0	;DIAGNOSTIC
	CALL	$ERMSG		;OUTPUT ERROR MESSAGE
	MOV	(SP)+,R0	;RESTORE R0
10$:	MOV	R0,R1		;OUTPUT VALUE TO R1
	MOV	R4,R0		;VIRTUAL ADDRESS TO R0
	CALLR	@(SP)+		;++004 OUTPUT TEXT - EXIT

;
; LOCATION COUNTER DEFINITION
;

LOCDEF:	CALL	GTCVL		;GET CURRENT SECTOR BASE AND ADDR
	CALL	CPYSCT		; COPY SECTION DATA
	MOV	R0,-(SP)	;SAVE CURRENT BASE ADDRESS
	MOV	R2,R0		;SET SEGMENT ADDRESS
	CALL	$ADRST		;SET ADDRESS LIMITS
	CALL	$GTWRD		;GET OFFSET VALUE
	SUB	#2,R3		;ADJUST BYTE COUNT
	ADD	(SP)+,R0	;ADD IN CURRENT BASE ADDRESS
	SUB	#4,R0		;BACK UP FOR DISPLACEMENT BYTE
	MOV	R0,CRADR	;SET CURRENT VIRTUAL ADDRESS
	RETURN			;

;
; LOCATION COUNTER MODIFICATION
;

LOCMOD:				;
	CALL	$GTWRD		; GET OFFSET CONSTANT
	MOV	R0,-(SP)	; SAVE CONSTANT
	CLR	R0		; CLEAR SECTION BASE
	SUB	#2,R3		;ADJUST BYTE COUNT
	BITB	#CS$REL,C$SFLG(R5);ABS SECTION?
	BEQ	10$		;IF EQ YES
	MOV	C$SCUR(R5),R0	; GET CURRENT SECTION BASE
	MOV	R5,R1		; COPY ADDRESS OF CURRENT SECTION
	CALL	GTMOD		; REDUCE TO MODULUS OF WINDOW
	BCS	10$		; IF C/S SECTION IS VIRTUAL
	ADD	$OFFST,R0	;ADD OFFSET BIAS
10$:				;
	ADD	(SP)+,R0	; ADD IN CONSTANT
	SUB	#4,R0		; BACK UP FOR DISPLACEMENT BYTE
	MOV	R0,CRADR	;SET CURRENT VIRTUAL ADDRESS
	RETURN			;

;
; LIMIT
;

LIMIT:	MOV	$OFFST,R1	;GET LOWEST VIRTUAL ADDRESS

	.IF	DF	R$$11M

	ADD	$HDSIZ,R1	; OFSET PAST HEADER

	.ENDC

	MOV	R4,R0		;SET VIRTUAL ADDRESS
	CALL	$WRWRD		;WRITE FIRST WORD
	MOV	$HVRTL,R1	;GET HIGHEST VIRTUAL ADDRESS
	BIT	#EX$MRT,$SWOV2	; SHIFT MR OVERLAYS UP SO TASK CAN EXTEND?	;LMP156
	BEQ	9$		; IF EQ, NO 					;LMP156
	MOV	$HVRT0,R1	; GET HIGHEST VIRTUAL ADDRESS WINDOW 0		;LMP156
9$:	TSTB	$STYP		; IS .LIMIT IN A DATA PSECT IN AN I/D TASK?	;LMP156
	BEQ	10$		; IF EQ NO					;LMP156
	MOV	$HDVRT,R1	; USE HIGHEST D-SPACE VIRTUAL ADDRESS INSTEAD	;LMP156
	BIT	#EX$MRT,$SWOV2	; SHIFT MR OVERLAYS UP SO TASK CAN EXTEND?	;LMP156
	BEQ	10$		; IF EQ, NO 					;LMP156
	MOV	$HDVR1,R1	; GET HIGHEST D-SPACE VIRTUAL ADDRESS WINDOW 1	;LMP156
10$:										;**-3
	INC	R1		; INCREMENT VIRTUAL ADDRESS
	ADD	$OFFST,R1	;ADD IN OFFSET BIAS
	MOV	R4,R0		;SET VIRTUAL ADDRESS
	ADD	#2,R0		;ADJUST TO NEXT WORD
	CALLR	$WRWRD		;++004 WRITE SECOND WORD


;
;++004 COMPLEX RELOCATION STRING PROCESSING
;

CPLREL:
	CMP	-(SP),-(SP)	;++004 ALLOCATE GUARD WORDS FROM STACK
	MOV	SP,R2		;++004 MARK BOTTOM OF STACK
	MOV	R2,BEGST	;++004 SAVE BOTTOM
	SUB	#48.,SP		;++004 ALLOCATE STACK SPACE
	MOV	SP,ENDST	;++004 MARK TOP OF STACK
10$:
	CALL	$GTBYT		;++004 COMAND BYTE => R0
	DEC	R3		;++004 DECREMENT BYTE COUNT
	CMP	R0,#LGCPL	;++004 LEGAL COMMAND TYPE?
	BHI	30$		;++004 NO -- BAD FORMAT
	ASL	R0		;++004 CONVERT TO WORD OFFSET
	CALL	@CPLVCT(R0)	;++004 CALL PROCESSING ROUTINE
	TST	R3		;++004 CHECK BYTE COUNT
	BGT	10$		;++004 OK -- GO AGAIN
30$:
	JMP	ILFMT		;++004 BAD COUNT

	PURE.D			; READ-ONLY D-SPACE

CPLVCT:				;++004 COMPLEX RELOCATION PROCESSING VECTOR
	.WORD	CPLNOP		;++004 NOP
	.WORD	CPLADD		;++004 ADD
	.WORD	CPLSUB		;++004 SUBTRACT
	.WORD	CPLMUL		;++004 MULTIPLY
	.WORD	CPLDIV		;++004 DIVIDE
	.WORD	CPLAND		;++004 'AND'
	.WORD	CPLOR		;++004 'OR'
	.WORD	CPLXOR		;++004 'XOR'
	.WORD	CPLNEG		;++004 NEGATE
	.WORD	CPLCOM		;++004 COMPLEMENT
	.WORD	CPLSTO		;++004 STORE
	.WORD	CPLSTD		;++004 STORE DISPLACED
	.WORD	ILFMT		;++004 ILLEGAL FORMAT
	.WORD	ILFMT		;++004 ILLEGAL FORMAT
	.WORD	CPLPGB		;++004 PUSH GLOBAL
	.WORD	CPLPRL		;++004 PUSH RELOCATABLE VALUE
	.WORD	CPLGTV		; PUSH CONSTANT
	.WORD	CPLPL		; PUSH LIBRARY CONSTANT
LGCPL=<.-CPLVCT>/2-1

	PURE.I			; READ-ONLY I-SPACE


;
;++004  COMPLEX RELOCATION -- 'NOP'
;

CPLNOP:	RETURN

;
;++004  SUBTRACT (SP)+,(SP)
;

CPLSUB:	NEG	@R2		;++004 NEGATE TOP ITEM ON STACK

;
;++004  ADD (SP)+,(SP)
;

CPLADD:	ADD	(R2)+,(R2)	;++004 ADD TOP TWO ITEMS
	BR	CPLRTN		;++004 CHECK STACK, EXIT

;
;++004  COMPLEX NEGATE -'(SP)'
;

CPLNEG:				;++004 DECREMENT TOP ITEM
	DEC	@R2

;
;++004  COMPLEX COMPLEMENT :(SP)
;

CPLCOM:
	COM	@R2		;++004 COMPLEMENT TOP ITEM
	RETURN			;++004 EXIT

;
;++004  COMPLEX 'AND' (SP)+,(SP)
;

CPLAND:
	COM	(R2)		;++004 COMPLEMENT TOP ITEM
	BIC	(R2)+,(R2)	;++004 'AND' BOTH ITEMS
	BR	CPLRTN		;++004 EXIT

;
;++004 EXCLUSIVE OR (SP)+,(SP)
;

CPLXOR:
	MOV	2(R2),R1	;++004 FETCH SECOND ITEM
	BIC	(R2)+,(R2)	;++004 CLEAR BITS SET IN BOTH -- SECOND ITEM
	BIC	R1,-(R2)	;++004 DITTO FIRST ITEM

;
;++004  COMPLEX 'OR' (SP)+,(SP)
;

CPLOR:
	BIS	(R2)+,(R2)	;++004 'OR' BOTH ITEMS.
	BR	CPLRTN		;++004 EXIT

;
;++004 COMPLEX MULTIPLY (SP)+,(SP)
;

CPLMUL:
	.IF	NDF	V1145
	MOV	#MUL1,-(SP)	;++004 SET ADDRESS OF COMP. ROUTINE
	BR	SGNOP		;++004 EXECUTE SIGNED ARITHMETIC
	.IFF
	MOV	(R2)+,R1	;++004 GET TOP ITEM - REGISTER MUST BE ODD
	MUL	(R2)+,R1	;++004 MULTIPLY TOP TWO ITEMS
	MOV	R1,-(R2)	;++004 STORE RESULT
	BR	CPLRTN		;++004 EXIT
	.ENDC

;
;++004  COMPLEX DIVIDE (SP)+,(SP)
;

CPLDIV:
	.IF	DF	V1145
	MOV	2(R2),R1	;++004 FETCH LOW PART
	SXT	R0		;++004 EXTEND SIGN
	DIV	(R2)+,R0	;++004 DIVIDE EM UP
	BVC	SGNEX		;++004 OK - DIVISOR NOT ZERO
	.IFF
	TST	(R2)+		;++004 VERIFY DIVISOR .NE. 0
	BNE	10$		;++004 OK -- PROCEED
;
	.IFTF
	MOV	R2,-(SP)	;++004 SAVE 'STACK POINTER'
	MOV	$CRELM,R2	;++004 FETCH ADDRESS OF CURRENT ELEMENT
	ADD	#E$LMOD,R2	;++004 POINT TO MODULE NAME
	MOV	(PC)+,R1	;++004 ERROR/SEVERITY
	.BYTE	E$R72,S$V0	;++004 DIAGNOSTIC
	CALL	$ERMSG		;++004 REPORT ERROR
	MOV	(SP)+,R2	;++004 RESTORE 'STACK POINTER'
	CLR	(R2)		;++004 FORCE RESULT OF 0
	BR	CPLRTN		;++004 EXIT
	.IFF
10$:
	TST	-(R2)		;++004 POINT TO FIRST ITEM
	MOV	#$DIV,-(SP)	;++004 SET ADDRESS OF ARITH. ROUTINE
SGNOP:
	MOV	(R2),R1		;++004 FETCH TOP ITEM
	BPL	10$		;++004 SEE IF POSITIVE
	NEG	R1		;++004 GET ABS. VALUE
10$:
	MOV	2(R2),R0	;++004 FETCH SECOND ITEM
	BPL	20$		;++004 GET ABS VALUE
	NEG	R0		;++004
	COM	(R2)		;++004 SIGN .NE. 0 -- SO EFFECTIVE 'XOR'
20$:
	CALL	@(SP)+		;++004 CALL ARITHMETIC ROUTINE
	TST	(R2)+		;++004 CHECK SIGN OF RESULT
	BPL	SGNEX		;++004 OK AS IS -- EXIT
	NEG	R0		;++004 SIGNS WERE DIFFERENT - NEGATE
	.ENDC
SGNEX:
	MOV	R0,(R2)		;++004 REPLACE TOP ITEM WITH RESULT
	BR	CPLRTN		;++004 CHECK STACK, EXIT

;
;++004  CHECK FOR STACK OVERFLOW/UNDERFLOW
;

CPLRT1:
	CMP	R2,ENDST	;++004 SEE IF 'PUSH' CAUSED OVERFLOW
	BLOS	CPLERX		;++004 YES - ERROR
	RETURN			;++004 NO, EXIT
CPLRTN:
	CMP	R2,BEGST	;++004 CHECK STACK POINTER VS. START
	BLO	CPLEXT		;++004 IF .LO. -OK
CPLERX:	JMP	ILFMT		;++004 ELSE ERROR
CPLEXT:	RETURN			;++004 EXIT

;
;++004  PUSH GLOBAL SYMBOL
;

CPLPGB:
	CALL	GTSVL		;++004 GET SYMBOL VALUE IN R0
	BR	CPLPSH		;++004 PUSH SYMBOL VALUE

;
; PUSH LIBRARY CONSTANT
;

CPLPL:				;
	CALL	GTLIB		; GET LIBRARY RELOCATION BIAS
	BR	CPLPSH		; PUSH RELOCATION BIAS

;
;++004  PUSH RELOCATABLE VALUE
;

	.ENABL	LSB

CPLPRL:
	CALL	$GTBYT		;++004 GET SECTION NUMBER
	DEC	R3		;++004 DECREMENT BYTE COUNT
	MOV	$CRELM,R1	;++004 GRAB ADDRESS OF CURRENT ELEMENT
	CMP	R0,E$LNUM(R1)	;++004 SEE IF SECTOR NO. OK
	BHI	CPLERX		;++004 NO - ERROR
	MOV	E$LCMT(R1),R1	;++004 GET MAPPING TABLE ADDRESS
	ASL	R0		;++004 CONVERT SECTION NO. TO TWO-WORD INDEX
	ASL	R0		;++004
	ADD	R0,R1		;++004 GET ENTRY IN TABLE
	MOV	(R1),R1		; GET VIRTUAL ADDRESS OF SECTION
	CALL	GTCVL2		;++004 GET RELOCATION BASE IN R0
	CALL	GTMOD		; REDUCE TO MODULO OF WINDOW SIZE
	MOV	R0,-(SP)	; SAVE VALUE
	CALL	$GTWRD		; GET OFFSET
	ADD	(SP)+,R0	; ADD RELOCATION BASE
	BR	10$		;
CPLGTV:				;
	CALL	$GTWRD		; GET CONSTANT
10$:				;
	SUB	#2,R3		;++004 BOOKEEP THE BYTE COUNT
CPLPSH:
	MOV	R0,-(R2)	;++004 PUSH RESULT
	BR	CPLRT1		;++004 EXIT

	.DSABL	LSB

;
;++004  COMPLEX STORE - DISPLACED
;
;++004  THIS OPERATION TERMINATES A COMPLEX RELOCATION STRING
;

CPLSTD:
	SUB	R4,@R2		;++004 SUBTRACT VIRTUAL ADDRESS
	SUB	#2,@R2		;++004 OFFSET FOR PC
;
;++004  COMPLEX STORE- NOT DISPLACED
;
;++004  THIS OPERATION TERMINATES A COMPLEX RELOCATION STRING
;
CPLSTO:	MOV	(R2)+,R0	;++004 FETCH DATA TO BE STORED
	CMP	R2,BEGST	;++004 CHECK STACK
	BNE	CPLERX		;++004 ERROR IF NOT AT BEGINNING
10$:
	MOV	R2,SP		;++004 RESTORE STACK
	CMP	(SP)+,(SP)+ 	;+004 FIX STACK
	CALLR	IMGOUT		;++004 OUTPUT TASK IMAGE DATA

;
; COPY SECTION DATA TO LOCAL STORAGE
;

CPYSCT:				;
	SAVVR			; SAVE VOLATILE REGISTERS
	CLRB	$STYP		; CLEAR SECTION TYPE FLAG
	BIT	#ID$ATA,$SWTCH	; /ID TASK?
	BEQ	5$		; IF EQ NO
	BITB	#CS$TYP,C$SFLG(R1) ; DATA PROGRAM SECTION?
	BEQ	5$		; IF EQ NO
	INCB	$STYP		; FLAG SECTION TYPE AS DATA
5$:
	MOV	#CRSCT,R0	; GET BLOCK TO STORE SECTION DATA
	MOV	#C$SLGH/2,R2	; GET WORD COUNT FOR ENTRY
10$:				;
	MOV	(R1)+,(R0)+	; COPY ENTRY
	SOB	R2,10$		;
	RETURN			;

;
; GET SECTION ENTRY ADDRESS AND CURRENT BASE
;

GTCVL:	CALL	GTSYM		;GET SECTION NAME
	ADD	#S$GCST,R0	;POINT TO SECTION TABLE HEADER
	CALL	$SRCH		;SEARCH FOR SECTION
	BCS	ILFMT		;IF CS ILLEGAL FORMAT
	MOV	$CRVSG,R2	; ASSUME CURRENT SEGMENT
	BITB	#CS$IND,C$SFLG(R0);INDIRECT REFERENCE?
	BEQ	GTCVL3		; IF EQ NO
	MOV	C$SLTH(R0),R2	;GET ADDRESS OF REAL SEGMENT
	MOV	C$SBSE(R0),R1	; GET VA OF REAL ENTRY
GTCVL2:				;
	MOV	R2,-(SP)	; SAVE R2
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	MOV	(SP)+,R2	; RESTORE R2
GTCVL3:				;
	MOV	R0,R1		; SAVE REAL ADDRESS
	MOV	C$SCUR(R1),R0	; GET CURRENT BASE
	BIT	#<CS$VSC!CS$VAS*400!CS$LIB>,C$SFLG(R1) ; LIBRARY SECTION?
	BNE	20$		;IF NE YES
	ADD	$OFFST,R0	;ASSUME RELATIVE SECTION
	BITB	#CS$REL,C$SFLG(R1);REL SECTION?
	BNE	20$		;IF NE YES
	CLR	R0		;BASE OF ALL ABS SECTIONS IS ZERO
20$:	RETURN			;

;
; GET RESIDENT LIBRARY RELOCATION BIAS
;

GTLIB:				;
	MOV	$OFFST,R0	; GET OFFSET BIAS
	MOV	$CRELM,R1	; GET ADDRESS OF CURRENT ELEMENT
	BIT	#SW$RL,E$LSWT(R1) ; RESIDENT LIBRARY ELEMENT?
	BEQ	10$		; IF EQ NO
	MOV	E$LLGH(R1),R0	; GET LIBRARY LIST ENTRY
	MOV	L$DSA(R0),R0	; GET BASE ADDRESS OF LIBRARY
10$:				;
	RETURN			;

;
; REDUCE SECTION OFFSET TO MODULUS OF WINDOW SIZE IF SECTION
; IS VIRTUAL
;

GTMOD:				;
	CLC			; ASSUME NOT VIRTUAL SECTION
	BITB	#CS$VSC,C$SFLG+1(R1) ; VIRTUAL SECTION?
	BEQ	10$		; IF EQ NO
	BITB	#CS$VAS,C$SFLG+1(R1) ; VIRTUAL ARRAY?
	BNE	5$		; IF NE YES
	MOV	C$SBSE(R1),-(SP) ; COPY BASE ADDRESS

	.IF DF	V1145

	MOV	C$SLTH(R1),-(SP) ; SET DIVISOR
	MOV	R0,R1		; COPY SECTION OFFSET
	CLR	R0		; CLEAR HIGH PART
	DIV	(SP)+,R0	; DIVIDE

	.IFF

	MOV	C$SLTH(R1),R1	; GET DIVISOR
	CALL	$DIV		; DIVIDE

	.ENDC

	MOV	R1,R0		; COPY REMAINDER
	ADD	(SP)+,R0	; ADD BASE ADDRESS
5$:				;
	SEC			; SET CARRY
10$:				;
	RETURN			;

;
; END GSD BLOCK TYPE 2
;
; NOTE: IF SKPALV IS SET, AUTOLOAD VECTOR TXT AND RLD RECORDS
;       FOLLOWING THE END GSD RECORD ARE SKIPPED OVER.
;

ENGSD:
	TST	SKPALV		; SKIP OVER AUTOLOAD VECTORS?
	BEQ	40$		; IF EQ NO
10$:
	CLR	$NBYTE		; LOOK AT NEXT RECORD
	CALL	$GTBYT		; GET RECORD LENGTH
	BCS	20$		; IF CS EOF (ILL FORMAT)
	CALL	$GTWRD		; GET BLOCK TYPE
	CMP	R0,#4		; RLD?
	BNE	20$		; IF NE NO - ILLEGAL FORMAT
	MOV	$NBYTE,-(SP)	; SAVE NUMBER OF BYTES LEFT
	CALL	$GTWRD		; GET COMMAND
	BIC	#177600,R0	; CLEAR UNWANTED BITS
	CMP	R0,#7		; LOCATION COUNTER DEFINITION?
	BNE	30$		; IF NE NO
	CALL	$GTWRD		; GET 1ST HALF OF PSECT NAME
	CMP	R0,#^R$$A	; IS IT $$ALVC?
	BNE	30$		; IF NE NO
	CALL	$GTWRD		; GET 2ND HALF
	CMP	R0,#^RLVC	; MAYBE
	BNE	30$		; IF NE NO
	TST	(SP)+		; CLEAN STACK
	CLR	$NBYTE		; SKIP AUTOLOAD VECTOR TXT RECORD
	CALL	$GTBYT		;
	BCS	20$		; IF CS ILLEGAL FORMAT
	CLR	$NBYTE		; SKIP RLD FOR PRECEDING TXT RECORD
	CALL	$GTBYT		;
	BCC	10$		; GO AGAIN
20$:
	JMP	ILFMT		; ILLEGAL FORMAT
30$:
	ADD	$NBYTE,$BYTEA	; COMPUTE INITIAL POINTER TO RLD
	SUB	(SP),$BYTEA	;  FOLLOWING BLOCK TYPE
	MOV	(SP),$NBYTE	; ...AND INITIAL BYTE COUNT
	MOV	(SP)+,R3	;
	JMP	RLD		; DO NORMAL RLD PROCESSING
40$:
	JMP	RPEAT		; GET RECORD FOLLOWING END GSD


;
; ILLEGAL FORMAT-BLOCK TYPES 0 AND 6
;

ILFMT:				;
	MOV	$INPPT,R2	; GET INPUT FILE RECORD BLOCK
	MOV	R$NAME(R2),R2	;GET ADDRESS OF NAME STRING
	MOV	(PC)+,R1	;GET ERROR/SEVERITY
	.BYTE	E$R14,S$V2	;FATAL-NO RETURN
	CALL	$ERMSG		;OUTPUT ERROR MESSAGE

;
; GET SYMBOL VALUE
;

GTSVL:				;
	MOV	R2,-(SP)	; SAVE R2
	CALL	GTSYM		; GET SYMBOL NAME
	CALL	$WSRCS		;SEARCH FOR SYMBOL
	BCS	20$		;IF CS NO FIND EM
	TST	(SP)+		;CLEAN STACK
	MOV	R0,R1		;SAVE SYMBOL ENTRY ADDRESS
	CLR	R0		;ASSUME UNDEFINED SYMBOL
	BITB	#SY$DEF,S$YFLG(R1);SYMBOL DEFINITION?
	BEQ	20$		;IF EQ NO
	BITB	#SY$IND,S$YFLG(R1);INDIRECT REFERENCE?
	BEQ	10$		;IF EQ NO
	MOV	S$YVAL(R1),R1	;GET ADDRESS OF REAL ENTRY
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	MOV	R0,R1		; COPY REAL ADDRESS
10$:
	BIT	#SY$ATL,S$YFLG(R1) ; AUTOLOADABLE SYMBOL??
	BEQ	12$		   ; IF EQ, NO...
	BIT	#SY$LIB,S$YFLG(R1) ; IF NE, YES...BUT IS IT FROM A LIBRARY?
	BEQ	12$		   ; IF EQ, NO...IGNORE THE EXTRA STUFF...
	BIT	#SY$SUP,S$YFLG(R1) ; FROM A SUPER-MODE LIBRARY??
	BNE	11$		   ; IF NE, YES...
	MOV	S$YVOF(R1),R0	   ; IF EQ, NO..GET THE 'INDIRECT' SYMBOL VALUE
	BR	14$
11$:
	MOV	S$YVOX(R1),R0	   ; GET THE 'INDIRECT' VALUE, BUT FROM THE
				   ; ENTENDED AREA FOR A SUPER-MODE SYMBOL
	BR	14$
12$:
	MOV	S$YVAL(R1),R0	   ; GET THE SYMBOL VALUE
13$:
	BITB	#SY$REL,S$YFLG(R1);ABS SYMBOL?
	BEQ	20$		;IF EQ YES
14$:
	ADD	$OFFST,R0	;ADD OFFSET BIAS
20$:				;
	MOV	(SP)+,R2	; RESTORE R2
	RETURN			;

;
; GET SYMBOL
;

GTSYM:	CALL	$GTWRD		;GET FIRST HALF OF SYMBOL
	MOV	R0,LCLSYM+2	;
	CALL	$GTWRD		;GET SECOND HALF OF SYMBOL
	MOV	R0,LCLSYM+4	;
	SUB	#4,R3		;ADJUST BYTE COUNT
	TST	SUPLIB		; ELEMENT SUPERVISOR MODE LIBRARY
	BEQ	10$		; IF EQ NO
	CMP	#^R.NA,LCLSYM+2 ; SYMBOL '.NAUTO'??
	BNE	10$		; IF NE NO
	CMP	#^RUTO,LCLSYM+4 ; MAYBE...
	BNE	10$		; IF NE NO
	ADD	$SUPOF,LCLSYM+4 ; YES...CHANGE TO .NAUTP - .NAUTW
10$:
	MOV	$CRSEG,R0	;GET ADDRESS OF CURRENT SEGMENT
	MOV	#LCLSYM,R1	;GET ADDRESS OF LOCAL SYM DESCRIPTOR
	RETURN			;


;
; END OF MODULE-BLOCK TYPE 6
;

MODND:	TST	(SP)+		;REMOVE RETURN FROM STACK
	MOV	$CRELM,R4	;GET ADDRESS OF ELEMENT DESCRIPTOR
	MOV	E$LCMT(R4),R3	;GET ADDRESS OF CMT TABLE
	BEQ	40$		;IF EQ NONE IN TABLE
	MOV	E$LNUM(R4),R5	; GET HIGHEST SECTION NUMBER
	INC	R5		; INCREMENT FOR LOOP COUNT
10$:				;
	MOV	(R3)+,R1	; GET VIRTUAL ADDRESS OF ENTRY
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	CALL	$WRMPG		; WRITE-MARK PAGE
	MOV	(R3)+,R1	; GET MAX SIZE
	BITB	#CS$LIB,C$SFLG(R0);LIB SECTION?
	BNE	30$		;IF NE YES - DON'T UPDATE
	BITB	#CS$REL,C$SFLG(R0);ABS SECTION?
	BEQ	30$		;IF EQ YES
	BITB	#CS$ALO,C$SFLG(R0);WHAT TYPE?
	BNE	30$		;IF NE OVERLAID
	ADD	R1,C$SCUR(R0)	;UPDATE CURRENT OFFSET ADDRESS
30$:				;
	SOB	R5,10$		; REPEAT
40$:	RETURN			;

;
; RGDCHK - CHECK CLUSTER LIBRARIES RGDS PSECTS AND SET R.GSTS IN REGION
; DESCRIPTOR ACCORDING TO CLUSTER OPTION ACCESS
;

RGDCHK:
	MOV	$CRELM,R5	; GET CURRENT ELEMENT
	MOV	#$LBRHD-L$DNXT,R2   ;  GET LIBRARY LIST HEAD
20$:
	MOV	L$DNXT(R2),R2	; NEXT LIBRARY
	BEQ	100$		; IF EQ, NO MORE
	CMP	L$DNME(R2),E$LMND+4(R5)	; THIS LIBRARY?
	BNE	20$			; IF NE, NO
	CMP	L$DNME+2(R2),E$LMND+6(R5)
	BNE	20$			; TRY NEXT LIBRARY
	TST	L$DFLG(R2)	; CHECK LIBRARY ACCESS SPECIFIED
	BPL	30$		; READ ONLY
	BISB	#RS.WRT,R0	; SET R.GSTS TO READ WRITE
	BR	100$
30$:	BISB	#RS.RED,R0	; SET R.GSTS TO READ ONLY
100$:	RETURN


;
; SGDCHK-CHECK FOR $$SGD1 CONTRIBUTIONS FROM RESIDENT LIBRARY; IF FOUND CHANGE
; CONTENTS OF SEGMENT FIELDS FOR OTS OPTIMIZATION
;

SGDCHK:
	INC	SGDBYT		; UPDATE SEGMENT DESCRIPTOR BYTE COUNT
	CMP	#S$ZSEG+3,SGDBYT    ; REACHED END OF SEGMENT DESCRIPTOR?
	BNE	10$		; IF NE, NO
	MOV	#1,SGDBYT	; RESET FOR NEXT SEGMENT DESCRIPTOR
10$:
	CMP	#1,SGDBYT	; FIRST BYTE OF SEGMENT DESCRIPTOR?
	BNE	20$		; IF NE, NO
	TST	FIRST		; FIRST SEGMENT DESCRIPTOR FOR THIS RES LIB?
	BNE	100$		; IF NE, NO
	MOV	$RLCNT,R1	; GET NEXT LOCATION IN $RLTBL
	MOV	R4,$RLTBL(R1)	; SAVE START OF THIS RESIDENT LIBRARY IN $$SGD1
	ADD	#2,$RLCNT	; INCREMENT COUNT OF RESIDENT LIBRARIES
	CMP	$RLCNT,#34	; OVER MAXIMUM ALLOWED?
	BLE	15$		; IF LE, NO
	BPT			; TOO MANY LIBRARIES _ WE'RE IN BIG TROUBLE
15$:
	TST	CLSLIB		; CLUSTER LIBRARY?
	BNE	100$		; IF NE, YES - THIS WON'T BE THE ROOT
	MOV	R4,ROOTVL	; SAVE VIRTUAL ADDRESS OF ROOT SEG DESCRIPTOR
	BR	100$
20$:
	CMP	#2,SGDBYT	; FLAGS BYTE?
	BNE	30$		; IF NE, NO
	TST	FIRST		; ROOT SEGMENT?
	BNE	100$		; IF NE, NO
	INC	FIRST		; LIB'S 1ST SEG DESC PROCESSED (FIRST=1)
	TST	CLSLIB		; CLUSTER LIBRARY?
	BNE	100$		; IF NE, YES - THIS WON'T BE THE ROOT
	BICB	#200,R0		; CLEAR HIGH BYTE TO INDICATE ROOT OF RESLIB
	BR	100$
30$:
	CMP	#5,SGDBYT	; LOW HALF OF SEGMENT LENGTH?
	BNE	40$		; IF NE, NO
	MOV	R0,SEGLTH	; SAVE
	BR	100$
40$:
	CMP	#6,SGDBYT	; HIGH HALF OF SEGMENT LENGTH?
	BNE	50$		; IF NE, NO
	MOV	R0,R1		; SAVE
	SWAB	R1		; AND COMBINE WITH
	ADD	R1,SEGLTH	; LOW HALF OF SEGMENT LENGTH
	BR	100$
50$:
	CMP	#13.,SGDBYT	; BEGINNING OF SEGMENT NAME FIELD?
	BNE	60$		; IF NE, NO
	MOV	R4,SEGNME	; SAVE VIRTUAL ADDRESS OF SEGMENT NAME FIELD
	BR	99$
60$:
	CMP	#14.,SGDBYT	; 2ND HALF OF SEGMENT NAME FIELD?
	BNE	100$		; IF NE, NO
	MOV	#1,SEGFLG	; SET TO CATCH RESIDENT LIBRARY RELOCATION REC
	TST	CLSLIB		; CLUSTER LIBRARY?
	BNE	100$		; IF NE, YES
	MOV	R0,-(SP)	; SAVE R0
	MOV	SEGNME,R0	; STORE VIRTUAL ADDRESS OF ROOT IN 1ST HALF
	MOV	ROOTVL,R1	; OF SEGMENT NAME FIELD
	CALL	$WRWRD		;
	MOV	(SP)+,R0	; RESTORE R0
99$:	ADD	#SGDSKP,(SP)	; SKIP CALL TO $WRBYT
100$:	RETURN

	.IF	NDF	V1145
;
;++004 SUBROUTINE TO PERFORM SOFTWARE MULTIPLY AND LEAVE
;++004 LOW 16 BITS IN R0
;
;++004 INPUTS:
;
;++004	R0 -- MULTIPLICAND
;++004  R1 -- MULTIPLIER
;
;++004	OUTPUTS:
;
;++004	R0 -- 16 LSB OF RESULT
;
;

MUL1:				;++004
	CALL	$MUL		;++004 CALL MULTIPLY ROUTINE
	MOV	R1,R0		;++004 PUT LOW HALF OF RESULT IN R0
	RETURN			;++004 EXIT
	.ENDC


	.END
