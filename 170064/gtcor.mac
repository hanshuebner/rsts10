	.IF NDF	W$$KST

	.TITLE	GTCOR

	.IFF

	.TITLE	GTCOS

	.ENDC

	.IDENT	/02.01/
;
;		COPYRIGHT (c) 1983 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD
;	 MASSACHUSETTS.  ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE  IS  FURNISHED  UNDER  A LICENSE AND MAY BE USED
; AND  COPIED  ONLY IN  ACCORDANCE WITH THE TERMS OF SUCH LICENSE
; AND WITH  THE INCLUSION  OF THE ABOVE  COPYRIGHT  NOTICE.  THIS
; SOFTWARE  OR ANY OTHER  COPIES  THEREOF, MAY NOT BE PROVIDED OR
; OTHERWISE MADE  AVAILABLE TO ANY OTHER PERSON.  NO TITLE TO AND
; OWNERSHIP OF THE SOFTWARE IS HEREBY TRANSFERRED.
;
; THE INFORMATION  IN THIS DOCUMENT IS SUBJECT  TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT  BY  DIGITAL
; EQUIPMENT CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF
; ITS SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.
;
;
;
; C. MONIA 22-FEB-74
;
; MODIFIED FOR RSX-11M/M-PLUS V4.0/V2.0 BY:
;
;	J. A. KASSON
;
; MODIFIED BY:
;
;	C. B. PETROVIC	26-FEB-82	02.01
;		CBP039		ADD CORRECT .PSECT DEFINITIONS TO
;				ALLOW TKB TO BE LINKED AS AN I/D TASK.
;
;
; ALLOCATE DYNAMIC STORAGE
;
;+
; **-GTCOR-ALLOCATE DYNAMIC STORAGE, DISPLACE VIRTUAL PAGE BUFFERS
;
; INPUTS:
;
;	R1=ALLOCATION REQUESTED(BYTES)
;	$TPADR=NEXT VIRTUAL ADDRESS ABOVE TASK IMAGE
;
; OUTPUTS:
;
;	C-CLEAR: ALLOCATION REQUEST SUCCEEDED
;
;	R0=ADDRESS OF STORAGE ALLOCATED
;
;	C-SET: ALLOCATION FAILED
;
; THIS ROUTINE IS CALLED TO OBTAIN DYNAMIC STORAGE. AN ATTEMPT IS MADE
; TO ALLOCATE THIS MEMORY FROM THE EXISTING POOL. IF THIS FAILS, A REQ-
; UEST TO EXTEND THE TASK IS ISSUED. IF THE REQUIRED MEMORY CANNOT BE OB-
; TAINED THEN UNLOCKED PAGE BUFFERS ARE DISPLACED UNTIL THE REQUESTED SPACE
; IS AVAILABLE. PAGE DISPLACEMENT IS ON THE BASIS OF 'LEAST RECENTLY USED'.
;-
	PURE.I			; READ-ONLY I-SPACE

$GTCOR::			;
	SAVRG			; SAVE NON-VOLATILE REGISTERS
10$:				;
	MOV	R1,-(SP)	; SAVE BYTE COUNT
	MOV	#$FRHD,R0	; GET ADDRESS OF FREE CORE POOL
	NEG	R1		; NEGATE SO $RQCB FROM SYSLIB CAN
				; BE USED WHEN LINKING TO FCSRES OR FCSFSL
	CALL	$RQCB		; REQUEST CORE BLOCK
	BCC	60$		; IF C/C HAVE REQUESTED SPACE

	.IF DF	W$$KST

	MOV	#$TPADR,R3	; GET POINTER TO NEXT FREE ADDRESS
	MOV	(R3),R2		; GET NEXT FREE ADDRESS
	CMP	R2,#T$KMAX	; TASK AT MAX. ALLOWABLE SIZE?
	BHIS	17$		; IF HIS YES
	MOV	#T$KINC,R1	; GET TASK INCREMENT (IN BYTES)
	CALL	$EXTSK		; EXTEND THE TASK
	BCS	17$		; IF C/S EXTEND FAILED
	ADD	R1,$FRSIZ	; ADD INCREMENT TO POOL
	ADD	R1,(R3)		; UPDATE TOP OF MEMORY
	BR	47$		; RELEASE BLOCK TO POOL
17$:				;
	MOV	#-1,(R3)	; BLOCK FURTHER ATTEMPTS TO EXTEND TASK

	.ENDC

;
; INSUFFICIENT STORAGE IS AVAILABLE. FREE UP MEMORY
; BY DISPLACING PAGE BUFFERS
;

	MOV	#<$PAGHD-P$GNXT>,R4 ; GET LISTHEAD ADDRESS MINUS OFFSET
	CLR	R2		; CLEAR ADDRESS OF LRU PAGE
	MOV	#-1,R3		; SET MAXIMUM TIME
	CLR	-(SP)		; CLEAR LRU PREDECESSOR
20$:				;
	MOV	R4,R5		; SAVE PREDECESSOR
	MOV	P$GNXT(R5),R4	; GET NEXT PAGE
	BEQ	30$		; IF EQ DONE
	CMP	P$GTIM(R4),R3	; TEST TIME OF LAST USE VS. LEAST
	BHI	20$		; IF HI, THIS BUFFER NOT LEAST
	TSTB	P$GLOK(R4)	; THIS PAGE LOCKED IN MEMORY?
	BNE	20$		; IF NE YES
	MOV	R4,R2		; MARK BUFFER AS LRU
	MOV	P$GTIM(R4),R3	; SAVE TIME
	MOV	R5,(SP)		; SAVE PREDECESSOR FOR RELINK
	BR	20$		; GO AGAIN
30$:				;
	TST	R2		; FIND LRU?
	SEC			; ASSUME NO
	BEQ	50$		; IF EQ NO
	BITB	#PG$WRT,P$GSTS(R2) ; PAGE WRITTEN INTO ?
	BEQ	40$		; IF EQ NO
	CALL	$WRPAG		; WRITE OUT PAGE INTO VM
40$:				;
	MOV	$PAGLS,R3	; GET ADDRESS OF PAGE LIST
	BEQ	45$		; IF EQ NONE
	CLR	R0		; SET FOR MOVB WITH NO SIGN EXTEND
	BISB	P$GBLK(R2),R0	; GET BLOCK NUMBER
	ASL	R0		; CONVERT TO WORD OFFSET
	ADD	R0,R3		; COMPUTE LOCATION IN LIST
	CLR	(R3)		; CLEAR ENTRY
45$:				;
	MOV	(SP)+,R3	; RETRIEVE LRU PREDECESSOR
	MOV	P$GNXT(R2),P$GNXT(R3) ; RELINK REMAINING PAGES
	MOV	#P$GSIZ,R1	; SET SIZE TO RELEASE
47$:				;
	MOV	#$FRHD,R0	; GET ADDRESS OF FREE POOL LISTHEAD
	CALL	$RLCB		; RELEASE MEMORY
	MOV	(SP)+,R1	; RESTORE COUNT
	BR	10$		; GO AGAIN
50$:				;
	INC	(SP)+		; CLEAN STACK, LEAVE C INTACT
60$:				;
	INC	(SP)+		; CLEAN STACK
	RETURN			;

	.END
