	.TITLE	P5CLS
	.IDENT	/03.06/
;
; COPYRIGHT (c)	1987 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE IS FURNISHED  UNDER A LICENSE AND MAY BE USED OR
; COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;	J.A. KASSON	20-AUG-80
;
; MODIFIED FOR RSX-11M/M-PLUS V4.0/V2.0 BY:
;
;	C. B. PETROVIC
;
; MODIFIED FOR RSX-11M-PLUS V3.0 BY:
;
;	C. B. PETROVIC	23-FEB-82	03.01	CBP033
;	C. B. PETROVIC	26-FEB-82	03.02	CBP039
;	J. M. SALMAN	07-MAY-82	03.03	JMS047
;	J. M. SALMAN	14-OCT-82	03.04	JMS078
;
; MODIFIED FOR RSX-11M-PLUS V4.0 BY:
;
;	L. M. PETERSON	12-SEP-86	03.05	LMP045
;		ADD SUPPORT FOR OTS OPTIMIZATION (MODIFY
;		CLUSTER SEGMENT DESCRIPTORS)
;
;	D. P. RABAHY	19-MAY-87	03.06	DPR041
;		DUMMY ROOT LINK DOWN POINT TO ROOT OF 1ST LIBRARY
;
;+
;**-$P5CLS-THIS MODULE IS CALLED FROM P5MDS TO CLEAN UP THE OVERLAY
;	   LINKAGE FOR CLUSTER LIBRARIES. IT CREATES ONE TREE STRUCTURE
;	   FOR EACH CLUSTER. THIS IS DONE BY CREATING A DUMMY ROOT FOR
;	   EACH CLUSTER AND LINKING EACH LIBRARY IN THE CLUSTER TO IT.
;	   ALL BUT THE FIRST LIBRARY IN THE CLUSTER MUST BE OVERLAID
;	   WITH A ZERO LENGTH ROOT.  THE FIRST LIBRARY MAY EITHER BE
;	   NON-OVERLAID, OVERLAID WITH A NULL ROOT, OR OVERLAID WITH
;	   A NON-NULL ROOT.  FOR THE LATTER TWO CASES, ADDITIONAL
;	   DESCRIPTORS NEED TO BE INSERTED INTO THE TASK IMAGE SINCE
;	   THEY ARE NOT AVAILABLE FROM THE .STB FILE FOR THE LIBRARY.
;
;-

	.PSECT	$DATA,LCL,D

	PURE.D			; READ-ONLY D-SPACE

SEG1NM:	.RAD50	/$$SGD1/
WNDNM:	.RAD50	/$$WNDS/
REGNM:	.RAD50	/$$RGDS/

	IMPURE			; READ/WRITE D-SPACE

CLLCT:	.BLKW	1
SEGVA:	.BLKW	1		; VIRTUAL ADDRESS OF DUMMY ROOT SEG DESCRIPTOR
SGDTMP:	.BLKW	1		; VIRTUAL ADDRESS OF BEGINNING OF $$SGD1
WNDVA:	.BLKW	1		; VIRTUAL ADDRESS OF 1ST LIB WINDOW DESCRIPTOR
WNDTMP:	.BLKW	1		; I-WINDOW SIZE,APR INFO FOR OPTIMIZED OTS
REGVA:	.BLKW	1		; VIRTUAL ADDRESS OF 1ST LIB REGION DESCRIPTOR
BUFFR:	.BLKW	10.


	PURE.I			; READ-ONLY I-SPACE


$P5CLS::
	SAVRG			; SAVE NON-VOLOTILE REGISTERS
	BIT	#ID$ATA,$SWTCH	; BUILDING AN I/D TASK?
	BEQ	10$		; IF EQ NO
	MOVB	#1,$STYP	; SET TYPE TO 'DATA' FOR $WRWRD
10$:
	SUB	#2,$RLCNT	; CORRECT COUNT OF RESIDENT LIBRARIES
	CLR	CLLCT		;
	CLR	WNDVA		;
	CLR	WNDTMP		;
	CLR	REGVA		;
	MOV	#SEG1NM,R4	; GET ADDRESS OF SECTION NAME
	CALL	FNDSEC		; SEARCH FOR SECTION
	MOV	C$SBSE(R0),R4	; VA OF SEGMENT DESCRIPTOR SECTION
	MOV	R4,SGDTMP	; SAVE THIS FOR PATNME
	ADD	C$SLTH(R0),R4	; ADD LENGTH OF SECTION
	MOV	R4,SEGVA	; SAVE VA OF DUMMY ROOT SEGMENT DESC.
	MOV	R0,-(SP)	; SAVE REAL ADDRESS OF $$SGD1 SECTION TABLE
	MOV	R1,-(SP)	; SAVE VA OF SECTION TABLE
	MOV	S$GELT(R5),R5	; GET ADDRESS OF ELEMEMT DESCRIPTOR
	BR	200$		;
100$:
	MOV	(R5),R5		; GET ADDRESS OF NEXT ELEMENT DESCRIPTOR
	BEQ	500$		; IF EQ END OF LIST
200$:
	MOV	R5,R1		; SETUP FOR CONVERT
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	MOV	R0,R5		; SAVE NEXT ADDRESS
	MOV	E$LVMT(R0),R1	; GET VIRTUAL ADDR. OF MAPPING TABLE
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	MOV	E$LNUM(R5),R1	; GET NUMBER OF SECTION IN MAPPING TABLE
	BMI	100$		; IF MI NO ENTRIES
	INC	R1		; GET REAL NUMBER OF ENTRIES
300$:				; SEARCH MAPPING TABLE FOR CONTRIBUTIONS
	CMP	(R0),(SP)	; TO $$SGD1.
	BEQ	400$		; IF EQ FOUND A CONTRIBUTOR
	CMP	(R0)+,(R0)+	; NOT A CONTRIBUTOR LOOK ON
	DEC	R1		; MORE SECTIONS IN TABLE?
	BNE	300$		; IF NE YES
	BR	100$		; END OF SEARCH FOR THIS ELEMENT
400$:
	MOV	2(R0),-(SP)	; SAVE CONTRIBUTION
	BIT	#SW$CLS,E$LSWT(R5) ; PART OF A CLUSTER?
	BEQ	450$		; IF EQ NO
	CALL	SAVOF		; SAVE OFFSET INTO $$SGD1
450$:
	ADD	(SP)+,CLLCT	; ADD IN CONTRIBUTION
	BR	100$		; NEXT

;
; SET UP SEGMENT DESCRIPTOR FOR DUMMY ROOT OF CLUSTER
;

500$:
	TST	(SP)+		; CLEAN VA OF SECTION OFF STACK
	MOV	#$CLSHD,R0	; GET ADDRESS OF CLUSTER LISTHEAD
525$:
	MOV	(R0),R1		; GET ADDRESS OF NEXT CLUSTER TABLE
	BEQ	750$		; IF EQ END OF LIST
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	MOV	R0,-(SP)	; SAVE ADDRESS OF CLUSTER
	SUB	$SZSEG,SEGVA	; CALC. ADDRESS OF NEXT DUMMY SEG DESCR.
	MOV	#BUFFR,R2	; GET ADDRESS OF PROTOTYPE SEGMENT DESCRPT.
	MOV	#<TR$DES!TR$DSK!TR$LOD>,(R2)+ ; SET SEGMENT STATUS
	TST	$AFLG		; USING AUTOLOAD?
	BEQ	530$		; IF EQ, NO
	BIC	#TR$DES,-2(R2)	; CLEAR HIGH BIT TO INDICATE THIS IS THE ROOT
530$:
	MOVB	C$LAPR(R0),R1	; SET FIRST APR USED BY CLUSTER
	CALL	CVADD		; CONVERT APR TO ADDRESS
	MOV	R1,(R2)+	; SET SEGMENT BASE ADDRESS
	TST	(R2)+		; SEMENT LENGTH FOR DUMMY ROOT IS ZERO
	ADD	#C$LNME,R0	; POINT TO FIRST LIBRARY NAME
	TST	(R0)+		; DOES THIS LIB HAVE A DESCRIPTOR?
	BNE	800$		; IF NE NO - IT NEEDS EXTRA DATA STRUCTURES
	MOV	(R0)+,R4	; GET SEGMENT DESCR. OFFSET
	MOV	2(SP),R5	; GET REAL ADDRESS OF $$SGD1 SECTION TABLE
	ADD	C$SBSE(R5),R4 	; CONVERT TO VIRTUAL ADDRESS BY
				; ADDING THE V.A. OF THE SEGMENT DESCRPT.
				; SECTION TO THE OFFSET
	MOV	R4,-(SP)	; SAVE ADDRESS
	CALL	DUMROT		; FILL IN REST OF DUMMY ROOT SEG. DESCR.
				; FOR DUMMY ROOT

;
; PATCH LINK DOWN AND LINK NEXT FOR ALL LIBRARIES IN CLUSTER
;
550$:
	MOV	2(SP),R0	; GET ADDRESS OF CLUSTER
	MOVB	C$LCNT(R0),R3	; GET NUMBER OF LIBRARIES IN CLUSTER
	ADD	#C$LNME+4,R0	; POINT TO SECOND LIBRARY IN CLUSTER
	MOV	4(SP),R5	; GET ADDRESS OF $$SGD1 SECTION TABLE
	MOV	(SP),-(SP)	; SAVE SEG. DESC. ADDR. OF FIRST LIBRARY
600$:
	TST	$AFLG		; USING AUTOLOAD?
	BEQ	650$		; IF EQ, NO
	CALL	PATNME		; MODIFY LIBRARY'S SEG. DESC. NAME FIELD
650$:
	DEC 	R3		; MORE IN CLUSTER?
	BEQ	700$		; IN EQ NO
	TST	(R0)+		; IS MORE THAN THE FIRST LIBRARY NOT OVERLAID?
	BNE	1000$		; IF NE YES - CAN'T BE - ERROR
	MOV	(R0)+,R4	; GET DECRIPTOR OFFSET
	ADD	C$SBSE(R5),R4 	; GET VIRTUAL ADDRESS FOR DESCRIPTOR
	MOV	R0,-(SP)	; SAVE CURRENT CLUSTER ADDRESS
	MOV	2(SP),R0	; GET VA OF DESCRIPTOR TO PATCH
	CALL	PATSEG		; FILL IN AND WRITE DESCRIPTOR
	MOV	(SP)+,R0	; RESTORE CLUSTER ADDRESS
	MOV	R4,(SP)		; SAVE CURRENT DESCRIPTOR VA
	BR	600$		; GET NEXT LIBRARY
700$:
	MOV	(SP)+,R0	; SEGMENT DESCRIPTOR OF LAST LIBRARY
	MOV	(SP),R4		; GET VA OF 1ST LIB FOR LAST LIB'S LINK NEXT
	CALL	PATROT		; PATCH LAST SEGMENT DESCRIPTOR
	TST	(SP)+		; CLEAN STACK
	MOV	(SP)+,R0	; RESTORE CLUSTER ADDRESS
	BR	525$		; LOOK FOR AND PROCESS NEXT CLUSTER
750$:
	TST	(SP)+		; CLEAN STACK WE DONE
	RETURN			;

1000$:
	MOV	#<S$V2*400!E$R104>,R1 ; ILLEGAL CLUSTER CONFIGURATION
	CALLR	$ERMSG


;
; WRITE SEGMENT DESCRIPTOR, WINDOW DESCRIPTOR AND REGION DESCRIPTOR
; FOR A LIBRARY WITHOUT OVERLAYS.  WRITE A WINDOW DESCRIPTOR FOR
; A LIBRARY THAT IS OVERLAID WITH A NON-NULL ROOT.  ONLY THE FIRST
; LIBRARY IN A CLUSTER CAN HAVE NO OVERLAYS OR BE OVERLAID WITH A NON-
; NULL ROOT.
;

800$:
	TST	WNDVA		; HAVE WE BEEN HERE BEFORE?
	BNE	850$		; IF NE YES
	MOV	R2,-(SP)	; SAVE BUFFER ADDRESS FOR SEG DESCR.
	MOV	#WNDNM,R4	; GET NAME OF SEGMENT NAME TO FIND
	MOV	#W$NLGH,R0	; GET LENGTH OF A WINDOW DESCRIPTOR
	CALL	DSCVA		; GET VA FOR SEGMENT $$WNDS
	MOV	R1,WNDVA	; SAVE VIRTUAL ADDRESS OF SEGMENT
	MOV	#REGNM,R4	; GET NAME OF SEGMENT TO FIND
	MOV	#R$GLGH,R0	; GET LENGTH OF REGION DESCRIPTOR
	CALL	DSCVA		; GET VA FOR SEGMENT $$RGDS
	MOV	R1,REGVA	; SAVE VIRTUAL ADDRESS OF SEGEMNT
	MOV	(SP)+,R2	; RESTORE BUFFER ADDRESS
	BR	875$		;
850$:
	SUB	#W$NLGH,WNDVA	; CALC. TASK VA OF WINDOW DESCRIPTOR
				; FOR NEXT CLUSTER
	SUB 	#R$GLGH,REGVA	; DO SAME FOR REGION DESCRIPTOR
;
; FINISH THE SEGMENT DESCRIPTOR FOR THE DUMMY ROOT
;

875$:
	MOV	(SP),R0		; GET ADDRESS OF CLUSTER TABLE
	BIT	#1,C$LOFF(R0)	; IS 1ST LIBRARY OFFSET IN $$SGD1 ODD?
	BEQ	1500$		; IF EQ NO - LIBRARY IS OVERLAID WITH A
				;  NON-NULL ROOT
	MOV	SEGVA,R4	; GET TASK'S VA FOR ROOT'S SEG. DESCRPT
	SUB	$SZSEG,R4	; BACK UP TO BEGINNING OF DESCRIPTOR ALLOCATED
				; FOR NON-OVERLAID FIRST LIBRARY
	MOV	R4,-(SP)	; SAVE ADDRESS
	CALL	DUMROT		; FILL IN REST OF DUMMY ROOT SEG. DESCR.

;
; WRITE WINDOW DESCRIPTOR OF 1ST LIBRARY
;

	MOV	#BUFFR,R5	; GET ADDRESS OF WINDOW BLOCK PROTOTYPE
	MOV	2(SP),R0	; GET REAL ADDR OF CLUSTER TABLE
	CALL	BRKWND		; WRITE WINDOW DESCRIPTOR INTO TASK IMAGE

;
; WRITE REGION DESCRIPTOR OF 1ST LIBRARY
;

	MOV	2(SP),R0	; GET REAL ADDR OF CLUSTER TABLE
	MOV	#BUFFR,R2	; GET ADDRESS OF REGION DESCRIPTOR PROTOTYPE
	CLR	(R2)+		;
	CLR	(R2)+		;
	MOV	C$LNME(R0),(R2)+   ; SET NAME
	MOV	C$LNME+2(R0),(R2)+ ;
	MOV	C$LNME(R0),(R2)+   ; SET PARTITION NAME
	MOV	C$LNME+2(R0),(R2)+ ;
	CLR	(R2)+		; ZERO REGION STATUS WORD
	CLR	(R2)+		; ZERO REGION PROTECTION CODES WORD
	CLR	(R2)+		; ZERO REGION FLAGS WORD
	MOV	REGVA,R4	; GET VA OF REGION DESCRIPTOR
	MOV	#R$GLGH,R3	; GET LENGTH
	MOV	#BUFFR,R5	; GET ADDRESS OF BUFFER TO WRITE
	CALL	WRTBLK		; WRITE REGION DESCRIPTOR INTO TASK IMAGE

;
; WRITE SEGMENT DESCRIPTOR FOR 1ST LIBRARY
;

	MOV	#BUFFR,R0	; GET ADDRESS OF SEGMENT DESCRIPTOR PROTOTYPE
	MOV	#<TR$DES!TR$DSK!TR$LOD>,(R0)+ ; SET SEGMENT STATUS
	MOV	L$DSA(R1),(R0)+	; SET VIRTUAL LOAD ADDRESS
	MOV	L$DHGV(R1),(R0) ; GET HIGH WINDOW 1 VIRTUAL ADDRESS
	SUB	-2(R0),(R0)	; AND TURN INTO SIZE IN BYTES
	INC	(R0)+		;
	CLR	(R0)+		; CLEAR LINK UP
	MOV	SEGVA,(R0)+	; SET LINK TO POINT TO DUMMY ROOT
	CLR	(R0)+		; CLEAR LINK NEXT
	TST	$AFLG		; USING AUTOLOAD?
	BEQ	1100$		; IF EQ, NO
	MOV	SEGVA,(R0)+	; STORE ADDRESS OF DUMMY ROOT FOR OTS TO USE
	MOV	WNDTMP,(R0)+	; STORE I-WINDOW SIZE AND APR FOR OTS TO USE	
	BR	1200$		;
1100$:
	MOV	L$DNME(R1),(R0)+ ; SET THE LIBRARY SEGMENT NAME
	MOV	L$DNME+2(R1),(R0)+
1200$:
	MOV	WNDVA,(R0)+	; SET WINDOW DESCRIPTOR VIRTUAL ADDRESS
	MOV	(SP),R4		; GET VA OF SEGMENT DESCRIPTOR
	MOV	$SZSEG,R3	; GET DECRIPTOR LENGTH
	MOV	#BUFFR,R5	; GET ADDRESS OF BUFFER TO WRITE
	CALL	WRTBLK		; WRITE SEGMENT DESCRIPTOR INTO TASK
				; IMAGE FOR NON-OVERLAID LIBRARY
	JMP	550$		; CONTINUE WITH REST OF CLUSTER

;
; FIRST LIBRARY IN CLUSTER IS OVERLAYED WITH A NON-NULL ROOT
;

1500$:
	MOV	C$LOFF(R0),R4	; GET SEGMENT DESCRIPTOR OFFSET
	MOV	2(SP),R5	; GET REAL ADDRESS OF $$SGD1 SECTION TABLE
	ADD	C$SBSE(R5),R4	; CONVERT TO V.A. OF SEGMENT DESCRIPTOR
	MOV	R4,-(SP)	; SAVE ADDRESS
	CALL	DUMROT		; FILL IN REST OF DUMMY ROOT SEG. DESCR.

;
; SEARCH FOR REGION DESCRIPTOR OF FIRST LIBRARY IN SECTION $$RGDS.  ITS
; TASK ADDRESS WILL BE INSERTED IN THE WINDOW DESCRIPTOR TO BE CREATED
; FOR THE NON-NULL ROOT OF THAT LIBRARY.
;

	MOV	#REGNM,R4	; GET ADDRESS OF $$RGDS SECTION NAME
	CALL	FNDSEC		; SEARCH FOR SECTION
	MOV	C$SBSE(R0),CLLCT ; VA OF REGION DESCRIPTOR SECTION
	MOV	R1,-(SP)	; SAVE VA OF SECTION TABLE
	MOV	S$GELT(R5),R5	; GET ADDRESS OF ELEMENT DESCRIPTOR
	BR	2000$		;
1800$:
	MOV	(R5),R5		; GET ADDRESS OF NEXT ELEMENT DESCRIPTOR
	BNE	2000$		; IF NE, OKAY OTHERWISE - END OF LIST - ERROR
	MOV	#<S$V2*400!E$R104>,R1 ; ILLEGAL CLUSTER CONFIGURATION
	CALLR	$ERMSG
2000$:
	MOV	R5,R1		; SETUP FOR CONVERT
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	MOV	R0,R5		; SAVE NEXT ADDRESS
	MOV	E$LVMT(R0),R1	; GET VIRT. ADDRESS OF MAPPING TABLE
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	MOV	E$LNUM(R5),R1	; GET NUMBER OF SECIONS IN MAPPING TABLE
	BMI	1800$		; IF MI NO ENTRIES
	INC	R1		; GET REAL NUMBER OF ENTRIES
2100$:				; SEARCH MAPPING TABLE FOR CONTRIBUTIONS
	CMP	(R0),(SP)	; TO $$RGDS
	BEQ	2200$		; IF EQ FOUND A CONTRIBUTOR
	CMP	(R0)+,(R0)+	; NOT A CONTRIBUTOR - LOOK ON
	DEC	R1		; MORE SECTIONS IN TABLE?
	BNE	2100$		; IF NE YES
	BR	1800$		; END OF SEARCH FOR THIS ELEMENT
2200$:
	BIT	#SW$CLS,E$LSWT(R5) ; PART OF A CLUSTER?
	BEQ	2300$		; IF EQ NO
	MOV	4(SP),R2	; GET ADDRESS OF CLUSTER TABLE
	CMP	C$LNME(R2),E$LMND+4(R5) ; MATCH OF LIB NAME AND ELEMENT?
	BNE	2300$		; IF NE NO
	CMP	C$LNME+2(R2),E$LMND+6(R5) ; MAYBE
	BEQ	2400$		; IF EQ YES - LOOK NO FURTHER
2300$:
	ADD	2(R0),CLLCT	; ADD IN CONTRIBUTION
	BR	1800$		; NEXT
2400$:
	TST	(SP)+		; CLEAN STACK

;
; WRITE A WINDOW DESCRIPTOR FOR THE NON-NULL ROOT
;

	MOV	R2,R0		; GET ADDRESS OF CLUSTER TABLE
	MOV	REGVA,-(SP)	; SAVE VA OF ALLOCATED REGION DESCRIPTOR
	MOV	CLLCT,REGVA	; AND REPLACE IT WITH VA OF ONE JUST FOUND
	CALL	BRKWND		; CREATE AND WRITE WINDOW DESCRIPTOR INTO
				; TASK IMAGE
	MOV	(SP)+,REGVA	; RESTORE VA OF ALLOCATED RDB

;
; PATCH THE SEGMENT DESCRIPTOR OF THE NON-NULL ROOT WITH THE
; ADDRESS OF THE WINDOW DESCRIPTOR WE JUST WROTE.
;

	MOV	4(SP),R5	; GET ADDRESS OF $$SGD1 SECTION TABLE
	MOV	2(SP),R0	; GET ADDRESS OF CLUSTER TABLE
	MOV	C$LOFF(R0),R0	; GET SEGMENT DESCRIPTOR OFFSET
	ADD	C$SBSE(R5),R0	; GET VIRTUAL ADDRESS FOR DESCRIPTOR
	ADD	#T$RWDP,R0	; POINT TO WINDOW DESCRIPTOR POINTER
	MOV	WNDVA,R1	; SET WORD TO BE WRITTEN
	CALL	$WRWRD		; WRITE IT
	JMP 	550$		; PATCH REST OF LIBRARIES IN CLUSTER

;+
; DUMROT - FILL IN THE REST OF THE SEGMENT DESCRIPTOR FOR THE DUMMY
;	   ROOT, STARTING AT "LINK UP".
;-

DUMROT:
	MOV	R4,(R2)+	; SET LINK UP
	CLR	(R2)+		; SET LINK DOWN
	MOV	SEGVA,R4	; GET V.A. OF ROOT SEGMENT DESCRIPTOR
	MOV	R4,(R2)+	; SET SELF AS LINK NEXT
	TST	$AFLG		; USING AUTOLOAD?
	BEQ	10$		; IF EQ, NO
	MOV	2(SP),-4(R2)	; POINT LINK DOWN TO ROOT OF 1ST MEMBER
	MOV	R4,(R2)+	; STORE ADDRESS OF CLUSTER ROOT 
	CLR	(R2)+
	BR	15$		;	
10$:
	MOV	#^RMTR,(R2)+	; SET DUMMY SEGMENT NAME "MTROOT"
	MOV	#^ROOT,(R2)+	;
15$:
	CLR	(R2)		; NO WINDOW DESCRIPTOR
	MOV	$SZSEG,R3	; SET SEGMENT DESCRIPTOR LENGTH
	MOV	#BUFFR,R5	; GET BUFFER ADDRESS
	CALLR	WRTBLK		; WRITE SEGMENT DESCRIPTOR IN TASK IMAGE
				; FOR DUMMY ROOT AND RETURN

;+
; BRKWND - WRITE A WINDOW DESCRIPTOR INTO THE TASK IMAGE
;-

BRKWND:
	MOV	#BUFFR,R5	; GET ADDRESS OF WINDOW DESCR. PROTOTYPE
	MOVB	C$LAPR(R0),R1	; GET CLUSTER STARTING APR
	MOVB	C$LAPR(R0),R4	; SAVE CLUSTER STARTING APR
	MOVB	R1,W.NAPR(R5)	; SET BASE APR IN WINDOW DESCRIPTOR
	CALL	CVADD		; CONVERT APR TO ADDRESS
	MOV	R1,W.NBAS(R5)	; SET BASE ADDRESS IN WINDOW DESCRIPTOR
	MOV	#<WS.64B!WS.MAP!WS.WRT>,W.NSTS(R5) ; SET STATUS
	MOV	C$LDSC(R0),R1	; GET LIBRARY DESCRIPTOR FOR 1ST LIBRARY
	MOV	L$DLDZ(R1),W.NSIZ(R5) ; SET WINDOW SIZE
	MOV	L$DLDZ(R1),W.NLEN(R5) ; SET LENGTH TO MAP
	TST	$AFLG		; USING AUTOLOAD?
	BEQ	5$		; IF EQ, NO
	MOV	L$DLDZ(R1),R3	; ROUND WINDOW SIZE UP TO NEXT 4K BOUNDARY
	ADD	#177,R3		; AND ROUND UP TO NEXT 4K BOUNDARY
	BIC	#177,R3
	MOV	R3,W.NSIZ(R5)
	ASR	R3
	ASR	R3
	ASR	R3
	BIS	R3,R4		; COMBINE I-WINDOW SIZE AND APR
	MOV	R4,WNDTMP	; AND SAVE TO PLUG INTO SEGMENT DESCRIPTOR
5$:	
	MOV	#WF$MAP,W$NFLG(R5) ; SET "MAPPED" BIT
	CLR	W.NRID(R5)	; CLEAR REGION I.D.
	CLR	W.NOFF(R5)	; CLEAR OFFSET INTO PARTITION
	CLR	W.NSRB(R5)	; CLEAR SEND/RECEIVE BUFFER ADDRESS
	MOV	REGVA,W$NREG(R5) ; SET VA OF REGION DESCRIPTOR
	MOV	WNDVA,R4	; GET VA OF WINDOW DESCRIPTOR
	MOV	#W$NLGH,R3	; GET LENGTH OF DESCRIPTOR
	CALLR	WRTBLK		; WRITE WINDOW DESCRIPTOR INTO TASK IMAGE
				; AND RETURN


;+
;
; PATROT - PATCHES LINK UP AND LINK DOWN IN SEGMENT DESCRIPTORS IN THE
;	   DUMMY ROOT SEGMENT ONLY
;
; PATSEG - PROVIDES IDENTICAL FUNCTIONALITY IN ADDITION TO SETTING THE
;	   'OUT OF MEMORY' BIT IN THE SEGMENT STATUS WORD OF EACH OF THE
;	   ROOT SEGMENT DESCRIPTORS IN THE ALLOCATION. THIS ASSUMES THAT
;	   THERE IS A NULL ROOT SEGMENT FOR EACH OVERLAID LIBRARY IN THE
;	   CURRENT CLUSTER.
;-

PATSEG:
	MOV	R0,-(SP)	; SAVE SEGMENT DESCRIPTOR ADDRESS
	MOV	R4,R0		; COPY VIRT ADDR OF CURRENT SEGMENT
	MOV	#<TR$DES!TR$DSK!TR$LOD!TR$MEM>,R1 ; SET SEGMENT STATUS
	CALL	$WRWRD		; AND CORRECT THE TASK IMAGE
	MOV	(SP)+,R0	; AND RESTORE IT.
PATROT:
	ADD	#T$RDWN,R0	; POINT TO LINK DOWN
	MOV	R0,-(SP)	; SAVE DESTINATION ADDRESS
	MOV	SEGVA,R1	; GET VA OF DUMMY ROOT FOR DOWN
	CALL	$WRWRD		; WRITE WORD INTO TASK IMAGE
	MOV	(SP)+,R0	; GET DESTINATION ADDRESS
	ADD	#2,R0		; POINT TO 'T$RNXT' WORD TO PATCH IN
				; THE TASK-RESIDENT SEGMENT DESCRIPTOR.
	MOV	R4,R1		; GET VA OF CURRENT LIB DESCRPTOR
	CALL	$WRWRD		; AND WRITE NEW NEXT LINK
	RETURN

;
; DSCVA - FIND THE VIRTUAL ADDRESS OF THE LAST DESCRIPTOR IN A
;         GIVEN SECTION
;

DSCVA:
	MOV	R0,-(SP)	; SAVE LENGTH OF DESCRIPTOR
	CALL	FNDSEC		; FIND SEGMENT IN SEGMENT TABLE
	MOV	C$SBSE(R0),R1	; GET SEGMENT'S BASE ADDRESS
	ADD	C$SLTH(R0),R1	; GET LAST ADDRESS IN SEGMENT
	SUB	(SP)+,R1	; SUBTRACT SIZE OF DESCRIPTOR TO
				; GET ADDRESS OF TOP OF LAST
				; DESCRIPTOR
	RETURN

;
; SEGADD - FIND SECTION IN THE ROOT
;

FNDSEC:
	MOV	$RTSEG,R1	; GET VIRTUAL ADDRESS OF ROOT
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	MOV	R0,R5		; SAVE REAL ADDRESS
	ADD	#S$GCST,R0	; POINT TO SECTION LISTHEAD
	MOV	R4,R1		; GET ADDRESS OF SEGMENT NAME
	SUB	#S$YM,R1	; CALC. PROPER OFFSET
	CALL	$SRCH		; FIND SEGMENT
	BCS	1000$		; IF CS	NOT FOUND
	RETURN
1000$:
	MOV	#<S$V2*400!E$R104>,R1 ; ILLEGAL CLUSTER CONFIGURATION
	CALLR	$ERMSG



;
; CVADD - CONVERT APR IN R1 TO A VIRTUAL ADDRESS IN R1
;

CVADD:
	BIC	#177400,R1	; CLEAR UPPER BYTE
	ASR	R1		; ROTATE IN TO C BIT
	ROR	R1		;
	ROR	R1		;
	ROR	R1		;
	RETURN			;

;+
;
; WRTBLK - WRITE BLOCK INTO TASK IMAGE
;
; INPUTS:
;	R3 - NUMBER OF BYTES TO WRITE
;	R4 - TASK IMAGE ADDRESS
;	R5 - ADDRESS OF BLOCK TO BE WRITTEN
;
;	R1 IS PRESERVED ACROSS CALL
;-

WRTBLK:
	MOV	R1,-(SP)	; SAVE R1
	ROR	R3		; CONVERT TO WORDS
10$:
	MOV	R4,R0		; COPY BLOCK ADDRESS
	ADD	#2,R4		; UPDATE BLOCK ADDRESS
	MOV	(R5)+,R1	; GET DATA TO BE WRITTEN
	CALL	$WRWRD		; WRITE WORD
	DEC 	R3		; DECREMENT COUNT
	BGT	10$		; IF GT GO AGAIN
	MOV	(SP)+,R1	; RESTORE R1
	RETURN

;
; SAVOF - SAVE OFFSET INTO $$SGD1 OF LIBRARY IN CLUSTER
;
; INPUTS:
;	R5 - ADDRESS OF ELEMENT DESCRIPTOR
;	CLLCT - SEGMENT OFFSET
;
; OUTPUT:
;	THE LIBRARY'S OFFSET INTO $$SGD1 IS STORED IN CLUSTER TABLE
;

SAVOF:
	MOV	E$LLGH+2(R5),R1	; GET VA OF CLUSTER
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	MOVB	C$LCNT(R0),R1	; GET NUMBER OF LIBRARIES IN CLUSTER
	ADD	#C$LNME,R0	; POINT TO FIRST LIBRARY NAME
	MOV	R0,R2		; SAVE POINTER
10$:
	CMP	(R0),E$LMND+4(R5)	; MATCH OF LIB NAME AND ELEMENT?
	BNE	20$		; IF NE NO
	CMP	2(R0),E$LMND+6(R5) ; MAYBE
	BEQ	30$		; IF EQ MATCH FOUND
20$:
	CMP	(R0)+,(R0)+	; POINT TO NEXT LIBRARY IN CLUSTER
	DEC	R1		; MORE LIBRARIES IN CLUSTER?
	BNE	10$		; IF NE YES
	RETURN
30$:
	CMP	R0,R2		; FIRST LIBRARY IN CLUSTER?
	BNE	40$		; IF NE NO
	MOV	C$LDSC-C$LNME(R0),R2 ; GET LIBRARY DESCRIPTOR FOR IT
	TST	L$DLDZ(R2)	; IS LOAD SIZE OF FIRST LIBRARY ZERO?
	BNE	50$		; IF NE NO - ITS ROOT IS NON-NULL
40$:
	CLR	(R0)		; ZERO FIRST HALF OF NAME
	MOV	CLLCT,2(R0)	; STORE SECTION OFFSET INTO SECOND HALF
	RETURN
50$:
	MOV	CLLCT,C$LOFF-C$LNME(R0) ; STORE SECTION OFFSET IN TABLE
	RETURN

;
; PATNME - PATCHES LIBRARY'S SEGMENT DESCRIPTOR NAME FIELDS (1ST HALF)
; 	   TO CONTAIN POINTER TO ROOT (SEGVA) FOR USE WITH OPTIMIZED OTS
;
; INPUTS:
;	   (SP) - VIRTUAL ADDRESS OF LIBRARY'S FIRST SEGMENT DESCRIPTOR
;	   $RLTBL - LIST OF ALL RESIDENT LIBRARIES' FIRST SEGMENT DESCRIPTORS
;	   $RLCNT - NUMBER OR RESIDENT LIBRARIES IN $RLTBL (X 2)
;

PATNME:	MOV	R0,-(SP)	; SAVE R0
	MOV	$RLCNT,R0	; GET COUNT OF RESIDENT LIBRARIES IN $RLTBL

10$:
	CMP	4(SP),$RLTBL(R0) ; CLUSTER LIB CONTRIBUTED IN P5ELM?
	BEQ	20$		; IF EQ, YES
	SUB	#2,R0		; TRY NEXT ONE (GOING BACKWARDS)
	TST	R0		;
	BGE	10$		;
	BR	60$		; CLUSTER LIB MUST BE NONOVERLAID, GO HOME
20$:
	CMP	R0,$RLCNT	; LAST ENTRY IN TABLE?
	BNE	30$		; IN NE, NO
	MOV	$RLTBL(R0),R4		;
	ADD	SGOFF,R4	; CALCULATE START OF TASK CONTRIBUTION
	BR	40$		;
30$:
	MOV	$RLTBL+2(R0),R4	; GET START OF NEXT RESIDENT LIBRARY IN $$SGD1
40$:
	MOV	$RLTBL(R0),R0	; GET START OF CLUSTER LIB IN $$SGD1
	ADD	#14,R0		; BUMP TO 1ST HALF OF SEGMENT NAME FIELD
50$:
	MOV	R0,-(SP)	; SAVE THIS AROUND WRITE
	MOV	SEGVA,R1	; GET ROOT OF THIS CLUSTER
	CALL	$WRWRD		; PUT ROOT IN 1ST HALF OF SEGMENT NAME FIELD
	MOV	(SP)+,R0	; RESTORE R0 FROM BEFORE WRITE
	ADD	$SZSEG,R0	; BUMP TO NEXT SEGMENT NAME FIELD
	CMP	R0,R4		; STILL IN THIS CLUSTER LIBRARY'S CONTRIBUTION?
	BLT	50$		; IF LT, YES
60$:
	MOV	(SP)+,R0	; RESTORE R0
	RETURN

	.END
