	.TITLE	INITL
	.IDENT	/27.07/
;
; COPYRIGHT (c)	1988 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE IS FURNISHED  UNDER A LICENSE AND MAY BE USED OR
; COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;
; D. N. CUTLER/C. MONIA	21-JAN-74
;
; MODIFIED FOR RSX-11M/M-PLUS V4.0/V2.0 BY:
;
;	C. B. PETROVIC
;
; MODIFIED BY:
;
;	C. B. PETROVIC	26-FEB-82	27.01
;		CBP039		ADD CORRECT .PSECT DEFINITIONS TO
;				ALLOW TKB TO BE LINKED AS AN I/D TASK.
;
;	C. B. PETROVIC		7-JUN-82	27.02
;		CBP051		ADD AUTOLOAD SUPPORT FOR USER-MODE
;				I/D TASKS.
;
;	J. M. LAWLER		29-JUN-82	27.03
;		JML112		ELIMINATE CALL TO FINIT FOR P/OS
;				SINCE FINIT IS DONE IN THE ROOT
;
;	L. M. PETERSON		7-SEP-86	27.04
;		LMP045		ADD SUPPORT FOR OTS OPTIMIZATION (CLEAR
;				$AFLG)
;
;	L. M. PETERSON		1-DEC-87	27.05
;		LMP098		ADD SUPPORT FOR LIBRARY D-SPACE RESERVATION
;
;	L. M. PETERSON		28-NOV-88	27.06
;		LMP124		DON'T AUTOMATICALLY SET TKB TO BUILD NON-ID
;				($DFSWT MAY HAVE BEEN PATCHED SO ID IS DEFAULT)
;
;	L. M. PETERSON		19-JAN-89	27.07
;		LMP115		EXPAND INITIALIZATION OF $LDAPR
;
; GENERAL INITIALIZATION ROUTINE
;
; MACRO LIBRARY CALLS
;

	.MCALL	DIR$,GPRT$
	.MCALL	GTSK$S

;
; LOCAL MACROS
;
; MACRO TO ISSUE RSX-11D 'READ EVENT FLAG' DIRECTIVE
;
; RDEF$S	FLAG
;
; WHERE:
;
;	FLAG=EVENT FLAG NUMBER (1 TO 64.)
;

	.MACRO	RDEF$S	FLAG
	MOV	FLAG,-(SP)
	MOV	#<2*400!37.>,-(SP)
	DIR$
	.ENDM

;+
; **-$INITL-GENERAL INITIALIZATION ROUTINE
;
; THIS ROUTINE IS CALLED AT THE START OF EACH TASK BUILD TO
; INITIALIZE STORAGE.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	INITIAL STATE OF STORAGE IS SET UP.
;-

	IMPURE			; READ/WRITE D-SPACE
$GTPRM: .BLKW	20.		; PARAMETER BUFFER FOR GTSK$
;
	PURE.I			; READ-ONLY I-SPACE

$INITL::			;

	.IF NDF	R$$PRO		; NOT P/OS
	CALL	$FINIT		; INITIALIZE FCS STORAGE

	.ENDC	; NDF R$$PRO

	MOV	#$CLRBG,R0	; GET START OF AREA TO CLEAR
	MOV	#C$LRSZ,R1	; GET NUMBER OF WORDS TO CLEAR
2$:				;
	CLR	(R0)+		; INITIALIZE MEMORY
	SOB	R1,2$		; ...
	INC	$SYSTM		; SET SYSTEM IDENTIFCATION TO 11M
	MOV	$DFSWT,$SWTCH	; SET DEFAULT SWITCH WORD
	MOV	#-1,$LDAPR	; INIT LIBRARY D-SPACE RESERVATIONS TO NONE
	CLR	$LIBNM		; CLEAR SYSTEM LIBRARY NAMEBLOCK ADDRESS
	CLR	$AFLG		; CLEAR AUTOLOAD FLAG
	MOV	$INIPT,R0	; GET INPUT REDORD BLOCK POINTER
	CLR	@R$NMBK(R0)	; NO NAME BLOCK TO SETUP
	CALL	$STRCB		; SETUP FCS STORAGE
	CLR	$ERRCT		; CLEAR ERROR COUNT
	MOV	#$FRHD,R0	; GET ADDRESS OF FREE POOL LISTHEAD
	MOV	#$FRSZ1,R1	; GET CORE POOL ADDRESS
	MOV	R1,(R0)		; SET LINK TO CORE POOL
	MOV	#<<$FRSZ2-$FRSZ1>&^C3>,R2 ; GET SIZE OF CORE POOL
	BEQ	3$		; IF EQ NONE
	CLR	(R1)+		; CLEAR LINK TO NEXT
	MOV	R2,(R1)		; SET POOL SIZE
	MOV	R2,$FRSIZ	; RECORD INITIAL SIZE OF POOL
3$:				;
	MOV	#177776,R1	; SET TOP ADDRESS TO MAX
	GTSK$S	#$GTPRM		; GET TASK PARAMETERS
	MOV	$GTPRM+G.TSSY,$RSXSY ; GET THE SYSTEM I.D.
	BEQ	4$		; IF EQ, THEN IS 11D
	CMP	#3,$RSXSY
	BEQ	4$		; IF EQ, THEN IS IAS.
	NEG	$RSXSY		; NEITHER, THEN IS OK TO CONTINUE...
	CALL	$INIDM		; INITIALIZE DYNAMIC MEMORY
	MOV	R2,$FRSIZ	; RECORD INITIAL POOL SIZE

	.IF DF	R$$11M

	TST	R0		; SYSTEM MAPPED?
	BNE	4$		; IF NE NO
	BIS	#MP$SY,$SWTCH	; SET DEFAULT TO MAPPED SYSTEM

	.ENDC

4$:				;
	BIS	#AB$RT,$SWTCH	; FORCE ABORT ON ANY ERROR
	CALL	$INIVM		; INITIALIZE WORKFILE SYSTEM
	BCS	10$		; IF C/S WORKFILE OPEN FAILURE
	MOV	#64.,$PHYBD	; SET PHYSICAL ADDRESS BOUND
	CLR	$SYMHD		; CLEAR SYMBOL TABLE LISTHEAD
	MOV	#S$ZSEG-4,$SZSEG ; SET SIZE OF RESIDENT SEGMENT DESCRIPTOR
	MOV	#20000,$VRTBD	; SET VIRTUAL ADDRESS BOUND
	MOV	#D$FAPR,$PRVAP	; SET DEFAULT PRIVILEGED APR
	MOV	#C$SLGH,R1	; GET LENGTH OF SECTION ENTRY
	MOV	R1,-(SP)	; SAVE LENGTH
	CALL	$ALVRT		; ALLOCATE VIRTUAL MEMORY
	MOV	R1,$ASCT	; SAVE VIRTUAL ADDRESS OF ABS
	MOV	#$ABSCT,R1	; GET ADDRESS OF PROTOTYPE ABS SECTION
	MOV	(SP)+,R2	; RETRIEVE LENGTH
5$:				;
	MOVB	(R1)+,(R0)+	; COPY ENTRY
	SOB	R2,5$		;
	MOV	#W$NLGH,R1	; GET SIZE OF WINDOW BLOCK
	CALL	$ALVRT		; ALLOCATE WINDOW BLOCK
	MOV	R1,$RTWDP	; MARK ADDRESS OF ROOT WINDOW DESCR.
	MOV	#W$NLGH,R1	; WE ARE GOING TO ALLOCATE ANOTHER WINDOW
				; BLOCK JUST IN CASE WE'RE BUILDING AN I/D
				; TASK. IT MAY NOT BE USED, BUT IT'S A SMALL
				; PRICE TO PAY FOR PERFORMANCE SINCE THE
				; SEGMENT DESCRIPTOR IS EXTRA LENGTH ANYWAY.
	CALL	$ALVRT		; ALLOCATE A VIRTUAL BLOCK
	MOV	R1,$RTWDP+2	; AND SAVE IT FOR LATER...
	BIS	#ID$ATA,$SWTCH	; SINCE THIS IS DONE FOR THE ROOT SEGMENT
				; ONLY ONCE AND BEFORE THE CONTENTS OF
				; $SWTCH IS SET UP BY $PARSE, WE WILL FAKE
				; AN I/D TASKBUILD PRIOR TO CALLING $ALSGD.
	CALL	$ALSGD		;ALLOCATE ROOT SEGMENT DESCRIPTOR
	MOVB	#<SG$DES!SG$LOD>,S$GSTS(R0) ; SET STATUS TO IN-CORE, LOADED
	MOV	$RTWDP,S$GWDP(R0) ; SET WINDOW BLOCK ADDRESS
	MOV	$RTWDP+2,S$GDWP(R0) ; SET D-SPACE WINDOW BLOCK ADDRESS
	MOV	R1,$RTSEG	; SET VIRTUAL ADDRESS OF DESCRIPTOR
	MOV	R1,$CRVSG	; SET VIRTUAL ADDRESS OF CURRENT SEGMENT
	MOV	R0,$CRSEG	;SET CURRENT SEG POINTER
	ADD	#S$GCST/2,R1	; POINT TO SECTION TABLE
	MOV	R1,R0		; COPY LISTHEAD ADDRESS
	MOV	$ASCT,R1	; GET ADDRESS OF ABS SECTION
	CALL	$SRCHI		;SEARCH FOR INSERT
	CALL	$ISYM		;INSERT SECTION ENTRY IN TABLE
	CLR	$SCTHD		; CLEAR SECTION EXTENSION LISTHEAD
	BIT	#ID$ATA,$DFSWT	; WAS DEFAULT SET TO ID (BY PATCHING BUILD)?
	BNE	8$		; IF NE, YES
	BIC	#ID$ATA,$SWTCH	; CLEAR THE FAKE /ID FLAG SET EARLIER 
8$:	BIC	#AB$RT,$SWTCH	; CLEAR THE ABORT FLAG SET EARLIER 
				; NOTE $SWTCH WILL BE SET UP LATER IN $BLDSG.
	MOV	#1,$XFRAD	;SET DEFAULT TRANSFER ADDRESSES
	MOV	#1,$ODTAD	;FOR TASK AND ODT
	CLR	$IDENT		;CLEAR PROGRAM IDENTIFICATION
	CLR	$IDENT+2	;
	MOV	#$RTSEG,$PATH	; INITIALIZE PATH LIST
	RETURN			;
10$:				;
	MOV	#<S$V2*400!E$R75>,R1 ; UNABLE TO OPEN WORK FILE
	CLR	R2		; SET DUMMY PARAMETER BLOCK ADDRESS
	CALL	$ERMSG		; FATAL-NO RETURN

	.END
