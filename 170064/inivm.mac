	.IF NDF	W$$KST & W$$OPT

	.TITLE	INIVM

	.ENDC

	.IF DF	W$$KST

	.IF NDF W$$OPT

	.TITLE	INIVS

	.ENDC

	.IF DF	W$$OPT

	.TITLE	INIVSX

	.ENDC

	.ENDC

	.IDENT	/06.01r/
;
;		COPYRIGHT (c) 1990,1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD
;	 MASSACHUSETTS.  ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE  IS  FURNISHED  UNDER  A LICENSE AND MAY BE USED
; AND  COPIED  ONLY IN  ACCORDANCE WITH THE TERMS OF SUCH LICENSE
; AND WITH  THE INCLUSION  OF THE ABOVE  COPYRIGHT  NOTICE.  THIS
; SOFTWARE  OR ANY OTHER  COPIES  THEREOF, MAY NOT BE PROVIDED OR
; OTHERWISE MADE  AVAILABLE TO ANY OTHER PERSON.  NO TITLE TO AND
; OWNERSHIP OF THE SOFTWARE IS HEREBY TRANSFERRED.
;
; THE INFORMATION  IN THIS DOCUMENT IS SUBJECT  TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT  BY  DIGITAL
; EQUIPMENT CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF
; ITS SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.
;
;
; Written by:
;
;	C. A. D'Elia	 1-Jun-74
;
; Previously modified by:
;
;	C. B. Petrovic
;	P. K. M. Weiss
;
; Modified for RSX-11M-PLUS V4.0 by:
;
;	J. C. Franzini	 2-Jun-86	06.00
;		JCF292 -- Improve error handling of work file open failures
;
; Modified for RSX-11M-PLUS and Micro/RSX V4.4 by:
;
;	L. M. Peterson	12-Mar-90	06.01
;		LMP148 -- Add alternate version of initialization routine for
;			  exclusive use with optimized version of TKB (HFT)
;
;	C. M. Katz	19-Jun-91	06.01r
;		Add RSTS conditionals


	.IF NDF	W$$OPT								;LMP148

;+
; **-$INIVM-*-INITIALIZE VIRTUAL MEMORY WORK FILE SYSTEM
;
; THIS ROUTINE INITIALIZES THE VIRTUAL MEMORY WORK FILE SUB-
; SYSTEM.  TO DO THIS IT FORCES ALL PAGES TO BE NON-RESIDENT,
; ALLOCATES THE FIRST PAGE, OPENS THE WORK FILE, AND MARKS
; IT FOR DELETION WHEN CLOSED.
;
; INPUTS:
;	R1=TOP TASK VIRTUAL ADDRESS
;	$WRKPT CONTAINS ADDRESS OF WORK FILE FDB
;	$FRHD  CONTAINS ADDRESS OF DYNAMIC MEMORY POOL
;
; OUTPUTS:
;	C-BIT CLEAR  AND/OR  R0=0 INDICATES SUCCESS
;
;	-OR-
;
;	C-BIT SET INDICATES FAILURE  AND/OR
;	      R0=-2 INDICATES WORK FILE OPEN FAILURE
;	      R0=-1 INDICATES WORK FILE MARK FOR DELETE FAILURE
;
;-

;
; MACRO LIBRARY CALLS
;

	.MCALL	FCSBT$
	FCSBT$	DEF$L
	.MCALL	FDOFF$
	FDOFF$	DEF$L
	.MCALL	OFNB$

	.IF	DF	T$$MP

	.MCALL	NMBLK$

	.ENDC

	IMPURE			; READ/WRITE D-SPACE

WKALOC:	.WORD	2*W$KEXT	; Work file initial allocation of 2 * W$KEXT

	.IF	DF	T$$MP

WRKNM:	NMBLK$	WRKFIL,TMP

	.ENDC


	PURE.I			; READ-ONLY I-SPACE

$INIVM::			;
	SAVRG			;++035 SAVE THE NON-VOLATILE REGISTERS

	.IF DF	W$$KST

	MOV	R1,$TPADR	; SET TOP ADDRESS IN TASK
	MOV	#$WRKAC,R0	; GET ADDRESS OF WORK FILE ACCESS COUNTS

	.REPT	6
	CLR	(R0)+		; CLEAR ACCESS COUNTS
	.ENDR

	.ENDC

	MOV	#1,$HGVAD	;++035 SET NEXT VIRTUAL ADDRESS TO 1
	CLR	$PAGHD		;SET NO RESIDENT PAGES
	CLR	$PAGLS		;++035 CLEAR POINTER TO RESIDENT PAGE LIST
	CLR	$TIME		; RESET PAGE TIME
	MOV	#$FRHD,R0	; GET ADDRESS OF FREE POOL LISTHEAD
	MOV	(R0)+,R1	; GET ADDRESS OF CORE POOL
	CLR	(R0)		; SECOND WORD OF LIST MUST BE ZERO
	CMP	2(R1),#<N$MPAG*P$GSIZ> ; ENOUGH ROOM FOR FAST PAGE SEARCH
	BLO	5$		; IF LO NO
	MOV	#512.,R1	; SET SIZE OF RESIDENT PAGE LIST
	CALL	$ALBLK		; ALLOCATE RESIDENT PAGE LIST
	MOV	R0,$PAGLS	;++035 SAVE ADDRESS OF LIST
5$:				;
	MOV	#P$GSIZ,R1	;PUT PAGE SIZE IN R1
	CALL	$ALBLK		;ALLOCATE FIRST PAGE
	MOV	R0,$PAGHD	;LINK IT TO RESIDENT PAGE LIST HEAD
	MOV	$PAGLS,R1	;++035 GET ADDRESS OF RESIDENT PAGE LIST
	BEQ	7$		;++035 IF EQ NONE
	MOV	R0,(R1)		;++035 SET THIS PAGE RESIDENT
7$:				;
	MOV	$WRKPT,R0	;POINT R0 TO WORK FILE FDB
	MOV	#-2,-(SP)	;ASSUME FILE OPEN FAILURE (STS=-2)

	.IF	DF	T$$MP

	MOV	#-W$KEXT,F.CNTG(R0) ; LEAVE THE FILE FULL WHEN CLOSED
				; BUT NON-CONTIGUOUS.
	MOV	R0,R1		;++035 COPY FDB ADDRESS
	ADD	#F.FNB,R1	;++035 POINT TO FILENAME BLOCK
	CLR	R2		;++035 NO DATASET DESCRIPTOR
	MOV	#WRKNM,R3	;++035 SET ADDRESS OF DEFAULT FILENAME BLOCK
	BISB	#FL.AEX,F.FLG(R0) ; TELL .PARSE NOT TO TRY TO EXPAND IT
	CALL	.PARSE		;++035 ENTER TEMP. FILE NAME IN DIRECTORY
	BCS	60$		; If CS, parse failed
	INC	(SP)		;++035 SPECIFY SUCCESFUL PARSE
	OFNB$	R0,#<FO.WRT>	;++035 OPEN FILE FOR WRITE
	BCS	60$		; If CS, open failure

	.IFF
20$:
	.IF	DF,R$RSTS	;++RSTS IF IT'S RSTS, THEN	;CMK001
	NEG	WKALOC		;++RSTS OPEN NON-CONTIGUOUS	;CMK001
	.ENDC			;++RSTS OR GET PROT VIOL LATER	;CMK001
	MOV	WKALOC,F.CNTG(R0)	; Set initial allocation

	OFNB$	R0,#<FA.TMP!FO.WRT>	; Create temporary work file
	BCC	40$		; If CC, OK

	CMP	#<IE.DFU&377>,F.ERR(R0)	; Is the error "device full?"
	BNE	60$		; If NE, no, some other error

;						     initial negated   new
;						      alloc   value   value
;
; If a contiguous allocation failed,			+n	-n	-n
;	try again with a noncontiguous allocation
; If a noncontiguous allocation failed,			-n	+n	 0
;	try again with an allocation of 0 blocks
; If an allocation of 0 blocks failed,			 0	 0	error
;	give an error

	NEG	WKALOC		; Negate the initial allocation that just failed
	BEQ	60$		; If EQ, allocation of 0 blocks failed (Can this
				; ...ever happen?  Return an error if it does.)
	BMI	20$		; If MI, contig allocation failed, try noncontig
	CLR	WKALOC		; Else PL, noncontiguous allocation failed.
				; ...Try initial allocation of 0.
	BR	20$		; Go back and try open again
40$:
	INC	(SP)		;ASSUME MARK FOR DELETE FAILURE (STS=-1)
	.IF	DF,R$RSTS	;++RSTS V8.0	;CMK001
	BICB	#FA.TMP,F.FACC(R0)	;++RSTS V8.0	;CMK001
	.ENDC			;++RSTS V8.0	;CMK001
	CALL	.MRKDL		;MARK FILE FOR DELETE AFTER CLOSE
	BCS	60$		; If CS, error

	.ENDC

	INC	(SP)		;SPECIFY SUCCESSFUL INIT (STS=0)
	BR	80$		;
60$:
	SEC			; Set error flag
80$:
	MOV	(SP)+,R0	; Pick up completion status
	RETURN			;RETURN WITH C-BIT SET IF ERROR

	.IFF	;DF	W$$OPT							;LMP148
										;LMP148
										;LMP148
;+										;LMP148
; **-$INIVM-*-INITIALIZE VIRTUAL MEMORY FAST MAPPED VSECT REGION		;LMP148
;										;LMP148
; THIS ROUTINE INITIALIZES THE VIRTUAL MEMORY SUBSYSTEM.			;LMP148
; TO DO THIS IT FORCES ALL PAGES TO BE NON-RESIDENT,				;LMP148
; AND ALLOCATES THE FIRST PAGE. A FAST MAPPED VSECT REGION 			;LMP148
; IS USED TO STORE OVERFLOW FROM DYNAMIC MEMORY.				;LMP148
;										;LMP148
; INPUTS:									;LMP148
;	R1=TOP TASK VIRTUAL ADDRESS (AFTER D-SPACE EXTENSION)			;LMP148
;	$FRHD  CONTAINS ADDRESS OF DYNAMIC MEMORY POOL				;LMP148
;										;LMP148
; OUTPUTS:									;LMP148
;	C-BIT CLEAR  AND/OR  R0=0 INDICATES SUCCESS				;LMP148
;										;LMP148
;	-OR-									;LMP148
;										;LMP148
;	C-BIT SET INDICATES FAILURE						;LMP148
;										;LMP148
;-										;LMP148
										;LMP148
										;LMP148
;										;LMP148
; MACRO LIBRARY CALLS								;LMP148
;										;LMP148
										;LMP148
	.MCALL	TFEA$,WDBBK$,DIR$,CRAW$,MAP$					;LMP148
										;LMP148
	PURE.D									;LMP148
										;LMP148
;										;LMP148
; D-APR 7 WILL BE USED FOR FAST MAPPING						;LMP148
;										;LMP148
										;LMP148
FMPAPR==7									;LMP148
										;LMP148
;										;LMP148
; FAST MAP APR VALUE FOR IOT							;LMP148
;										;LMP148
										;LMP148
IOTAPR==000170									;LMP148
										;LMP148
;										;LMP148
; VSECT REGION ID								;LMP148
;										;LMP148
										;LMP148
VREG==0										;LMP148
										;LMP148
	IMPURE									;LMP148
										;LMP148
;										;LMP148
; WINDOW BLOCK FOR VSECT							;LMP148
;										;LMP148
										;LMP148
FMWNDW:	WDBBK$	FMPAPR,200,VREG,0,,WS.MAP!WS.WRT!WS.64B!WS.UDS			;LMP148
										;LMP148
;										;LMP148
; TEST FEATURE MASK DPB								;LMP148
;										;LMP148
										;LMP148
TFEAT:	TFEA$	T4$FMP								;LMP148
										;LMP148
;										;LMP148
; CREATE ADDRESS WINDOW DPB							;LMP148
;										;LMP148
										;LMP148
CREWDW:	CRAW$	FMWNDW								;LMP148
										;LMP148
	PURE.I			; READ-ONLY I-SPACE				;LMP148
										;LMP148
$INIVM::			;						;LMP148
	SAVRG			;++035 SAVE THE NON-VOLATILE REGISTERS		;LMP148
										;LMP148
	.IF DF	W$$KST								;LMP148
										;LMP148
	MOV	R1,$TPADR	; SET TOP ADDRESS IN TASK			;LMP148
	MOV	#$WRKAC,R0	; GET ADDRESS OF WORK FILE ACCESS COUNTS	;LMP148
										;LMP148
	.REPT	6								;LMP148
	CLR	(R0)+		; CLEAR ACCESS COUNTS				;LMP148
	.ENDR									;LMP148
										;LMP148
	.ENDC									;LMP148
										;LMP148
	MOV	#1,$HGVAD	;++035 SET NEXT VIRTUAL ADDRESS TO 1		;LMP148
	CLR	$PAGHD		;SET NO RESIDENT PAGES				;LMP148
	CLR	$PAGLS		;++035 CLEAR POINTER TO RESIDENT PAGE LIST	;LMP148
	CLR	$TIME		; RESET PAGE TIME				;LMP148
	MOV	#$FRHD,R0	; GET ADDRESS OF FREE POOL LISTHEAD		;LMP148
	MOV	(R0)+,R1	; GET ADDRESS OF CORE POOL			;LMP148
	CLR	(R0)		; SECOND WORD OF LIST MUST BE ZERO		;LMP148
	CMP	2(R1),#<N$MPAG*P$GSIZ> ; ENOUGH ROOM FOR FAST PAGE SEARCH	;LMP148
	BLO	5$		; IF LO NO					;LMP148
	MOV	#512.,R1	; SET SIZE OF RESIDENT PAGE LIST		;LMP148
	CALL	$ALBLK		; ALLOCATE RESIDENT PAGE LIST			;LMP148
	MOV	R0,$PAGLS	;++035 SAVE ADDRESS OF LIST			;LMP148
5$:				;						;LMP148
	MOV	#P$GSIZ,R1	;PUT PAGE SIZE IN R1				;LMP148
	CALL	$ALBLK		;ALLOCATE FIRST PAGE				;LMP148
	MOV	R0,$PAGHD	;LINK IT TO RESIDENT PAGE LIST HEAD		;LMP148
	MOV	$PAGLS,R1	;++035 GET ADDRESS OF RESIDENT PAGE LIST	;LMP148
	BEQ	10$		;++035 IF EQ NONE				;LMP148
	MOV	R0,(R1)		;++035 SET THIS PAGE RESIDENT			;LMP148
10$:										;LMP148
										;LMP148
; SET UP FOR FASTMAPPING							;LMP148
										;LMP148
	DIR$	#TFEAT		; IS FAST MAPPING AVAILABLE?			;LMP148
	CMP	@#$DSW,#IS.SET	; CHECK DIRECTIVE STATUS			;LMP148
	BNE	20$		; IF NE, NO					;LMP148
										;LMP148
	DIR$	#CREWDW		; CREATE AND MAP ADDRESS WINDOW			;LMP148
	CMP	@#$DSW,#IS.SUC	; OKAY?						;LMP148
	BEQ	30$		; IF EQ, YES					;LMP148
20$:										;LMP148
	MOV	(PC)+,R1	; GET ERROR/SEVERITY				;LMP148
	.BYTE	E$R112,S$V2	; VSECT FAST MAPPING UNAVAILABLE		;LMP148
	CALL	$ERMSG		; ISSUE FATAL ERROR (NO RETURN)			;LMP148
30$:										;LMP148
	RETURN			;RETURN						;LMP148
										;LMP148
	.ENDC									;LMP148

	.END
