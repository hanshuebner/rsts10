	.TITLE	SRCINS
	.IDENT	/08.01/
;
; COPYRIGHT (c)	1983 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE IS FURNISHED  UNDER A LICENSE AND MAY BE USED OR
; COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;
; C. MONIA 13-MAR-74
;
; MODIFIED BY:
;
;	C. B. PETROVIC	26-FEB-82	08.01
;		CBP039		ADD CORRECT .PSECT DEFINITIONS TO
;				ALLOW TKB TO BE LINKED AS AN I/D TASK.
;
;
;
; VIRTUAL MEMORY SYMBOL TABLE SEARCH AND INSERT SUBROUTINES
;
; EQUATED SYMBOLS
;

S$CNT==7			; OFFSET TO HIGH BYTE OF SYMBOL FLAG WORD
S$YM==2				; OFFSET TO SYMBOL DESCRIPTOR

;
; LOCAL DATA
;
;
; ADJACENCY IS REQUIRED
;

	IMPURE			; READ/WRITE D-SPACE

LCOUNT:	.BLKW	1		; LISTHEAD COUNT
LHEAD:	.BLKW	1		; CURRENT LISTHEAD
PVSRC:	.BLKW	1		; VIRTUAL ADDRESS OF NEXT IN LIST
LIMIT:	.RAD50	/B/		;++038 SUB-LIST LIMITS
	.RAD50	/D/
	.RAD50	/F/
	.RAD50	/H/
	.RAD50	/J/
	.RAD50	/L/
	.RAD50	/N/
	.RAD50	/P/
	.RAD50	/R/
	.RAD50	/T/
	.RAD50	/V/
	.RAD50	/X/
	.RAD50	/Z/
	.RAD50	/$C/
	.RAD50	/$F/
	.RAD50	/$I/
	.RAD50	/$L/
	.RAD50	/$O/
	.RAD50	/$R/
	.RAD50	/$U/
	.RAD50	/$X/
	.RAD50	/$Z/
	.RAD50	/.C/
	.RAD50	/.F/
	.RAD50	/.I/
	.RAD50	/.L/
	.RAD50	/.O/
	.RAD50	/.R/
	.RAD50	/.U/
	.RAD50	/..G/
	.RAD50	/..P/
	.RAD50	/..Z/
L$HCNT==.-LIMIT/2		;++038 LISTHEAD COUNT
LKNXT:	.BLKW	1		; LINK TO NEXT ENTRY
LKPRV:	.BLKW	1		; LINK TO PREVIOUS ENTRY
SYMLOC:	.BLKW	1		; VIRTUAL ADDRESS OF SYMBOL TO INSERT
SYM:	.BLKW	2		; SYMBOL NAME

;
; DATA STRUCTURES
;
; GENERAL SYMBOL TABLE FORMATS
;
;	LISTHEAD: FIRST WORD CONTAINS A COUNT OF THE NUMBER OF
;	          SUBLISTS-1 IN USE. EACH CELL IN THE TABLE REPRESENTS
;		  THE START OF A SUBLIST CONTAINING ALL SYMBOLS WITHIN
;		  THE LEXICAL LIMITS ESTABLISHED BY THE LIMIT TABLE.
;
;	SYMBOL TABLE ENTRIES:
;
;	SENTRY:	.WORD	LINK	; POINTER TO NEXT ENTRY
;		.WORD	S$YM	; FIRST HALF OF SYMBOL
;		.WORD	S$YM+2	; SECOND HALF OF SYMBOL
;		.WORD	DATA	; ANY DATA
;			.
;			.
;			.
;		.WORD	DATA	; END OF ENTRY
;
; ENTRIES ARE LINKED IN LEXICAL ORDER. A ZERO IN THE LINK
; WORD INDICATES NO FURTHER ENTRIES IN THE LIST.
;
;+
; **-$ISYM-INSERT SYMBOL IN LEXICALLY ORDERED LIST
;
; THIS SUBROUTINE IS CALLED TO INSERT A SYMBOL IN
; A LIST STORED IN VIRTUAL MEMORY. A PREVIOUS CALL
; TO $SRCHI IS REQUIRED TO SCAN THE LIST AND SETUP
; LKPRV AND LKNXT WITH THE VIRTUAL ADDRESSES OF THE
; PREDECESSOR AND SUCCESSOR ENTRIES RESPECTIVELY. THE
; ENTRY IS INSERTED AND THE PAGE BUFFERS CONTAINING
; THE PRECEDING AND NEW ENTRIES ARE WRITE MARKED.
;
; INPUTS:
;
;	LKPRV=VIRTUAL ADDRESS OF PRECEDING ENTRY
;	LKNXT=VIRTUAL ADDRESS OF SUCCESSOR TO 'LKPRV'.
;	SYMLOC=VIRTUAL ADDRESS OF SYMBOL TO BE INSERTED
;
; OUTPUTS:
;
;	THE NEW ENTRY IS LINKED TO THE LIST.
;	THE APPROPRIATE PAGE BUFFERS ARE WRITE MARKED
;-
	PURE.I			; READ-ONLY I-SPACE

$ISYM::				;
	MOV	SYMLOC,R1	; GET VIRTUAL ADDRESS OF NEW SYMBOL
	CALL	$CVRL		; CONVERT NEW TO REAL ADDRESS
	CALL	$WRMPG		; WRITE-MARK PAGE BUFFER
	MOV	LKNXT,(R0)	; SET LINK TO NEXT
	MOV	LKPRV,R1	; GET VIRTUAL ADDRESS OF PREVIOUS
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	CALL	$WRMPG		; WRITE-MARK PAGE BUFFER
	MOV	SYMLOC,(R0)	; SET NEW LINK-NEXT
	RETURN			;

;+
; **-$SRCHI-SEARCH SYMBOL TABLE FOR INSERT
;
; THIS SUBROUTINE IS CALLED TO SEARCH A SYMBOL TABLE
; IN VIRTUAL MEMORY PRIOR TO PERFORMING AN INSERT.
;
; INPUTS:
;
;	R0=VIRTUAL ADDRESS OF LISTHEAD
;	R1=VIRTUAL ADDRESS OF SYMBOL TO BE INSERTED
;
; OUTPUTS:
;
;	C-SET: SYMBOL NOT IN TABLE
;	       R0 IS CLEARED
;	       R1 IS CLEARED
;
;	C-CLEAR: SYMBOL IS IN TABLE
;	         R0=REAL ADDRESS OF SYMBOL
;		 R1=VIRTUAL ADDRESS OF SYMBOL
;
; IN EITHER CASE 'LKPRV' AND 'LKNXT' CONTAIN
; THE ADDRESS OF THE PRECESSOR AND SUCCESOR EN-
; TRIES AT THE POINT FOR INSERTION.
;-

$SRCHI::			;
	MOV	R5,-(SP)	; SAVE R5
	MOV	R0,-(SP)	;++038 SAVE VIRTUAL ADDRESS OF LISTHEAD
	MOV	R1,-(SP)	;++038 SAVE VIRTUAL ADDRESS OF NEW ENTRY
	MOV	R0,R1		;++038 GET VIRTUAL ADDRESS OF LISTHEAD
	CALL	$CVRL		;++038 CONVERT TO REAL
	MOV	(R0),LCOUNT	; SAVE LIST COUNT
	MOV	(SP)+,R1	; GET ADDRESS OF NEW SYMBOL
	CALL	$CVRL		; CONVERT NEW ENTRY TO REAL ADDRESS
	MOV	R1,SYMLOC	; SAVE VIRTUAL ADDRESS OF NEW
	MOV	S$YM(R0),SYM	; SAVE SYMBOL NAME
	MOV	S$YM+2(R0),SYM+2 ;
	MOV	R0,R5		; COPY REAL ADDRESS
	CALL	FNDSLT		; LOCATE APPROPRIATE SUBLIST
	ASR	R2		; CONVERT TO VIRTUAL OFFSET
	MOV	(SP)+,R1	; RESTORE LISTHEAD ADDRESS
	INC	R1		;++038 POINT TO FIRST SUBLIST
	ADD	R2,R1		; COMPUTE VIRTUAL ADDRESS OF SUBLIST
10$:				;
	MOV	R1,LKPRV	; SAVE PREDECESSOR ADDRESS
	CLR	R2		; CLEAR OFFSET TO NEXT
	CALL	$GNVI		; GET NEXT ITEM ON LIST
	MOV	R1,LKNXT	; SAVE LINK TO NEXT
	BCS	30$		; IF C/S END OF LIST
	CMP	S$YM(R0),SYM	; COMPARE SYMBOL VALUES
	BHI	20$		; IF HI FOUND PLACE TO INSERT
	BLO	10$		; IF LO CONTINUE SEARCH
	CMP	S$YM+2(R0),SYM+2 ; COMPARE SECOND HALF
	BLO	10$		; IF LO CONTINUE SEARCH
	BEQ	30$		; IF EQ HAVE SYMBOL
20$:				;
	CLR	R0		; SET NOT FOUND INDICATORS
	CLR	R1		;
	SEC			;
30$:				;
	MOV	(SP)+,R5	; RESTORE R5
	RETURN			;

;+
; **-$ISED-INITIALIZE SYMBOL TABLE EDIT
;
; THIS CO-ROUTINE IS CALLED TO TO RETRIEVE ENTRIES IN AN
; ORDERED, LINKED LIST STORED IN VIRTUAL MEMORY
;
; INPUTS:
;
;	R0=REAL ADDRESS OF LISTHEAD(ONLY ON FIRST CALL)
;
; OUTPUTS:
;
;	C-SET: NO MORE ENTRIES IN LIST
;
;	C-CLEAR: FOUND NEXT ENTRY
;		 R0=REAL ADDRESS OF ENTRY
;		 R1=VIRTUAL ADDRESS OF ENTRY
;		 R2=ADDRESS OF BLOCK CONTAINING THE FOLLOWING DATA
;
;		.WORD	LCOUNT	; CURRENT SUBLIST COUNT
;		.WORD	LHEAD	; ADDRESS OF CURRENT SUBLIST
;		.WORD	NEXT	; VIRTUAL ADDRESS OF NEXT ENTRY
;
;
; ON A SUCCESFUL RETURN A CO-ROUTINE CALL IS MADE
; TO THE CALLER. THE SPECIFIED PAGE IS NOT LOCKED
; IN MEMORY. IF THE SEARCH IS TO BE TERMINATED, THE
; CALLER MUST REMOVE THE RETURN ADDRESS FROM THE
; STACK. WHEN NO MORE SYMBOLS REMAIN '$ISED' PER-
; FORMS AN 'RTS PC' TO THE CALLING ROUTINE.
;-

$ISED::				;
	MOV	#$ISD,-(SP)	; PUSH ADDRESS OF SCANNING ROUTINE
10$:				;
	MOV	#LCOUNT,R2	; POINT TO STORAGE BLOCK
	CALL	@(SP)+		; CALL SCANNING ROUTINE
	MOV	#LCOUNT,R2	; RESTORE ADDRESS OF BLOCK
	INC	(SP)+		; CLEAN STACK
	BCS	20$		; IF C/S SCANNED ALL ENTRIES
	CALL	@(SP)+		; CALL THE CALLER
	MOV	#$ISD1,-(SP)	; PUSH CONTINUATION POINT
	BR	10$		; GO AGAIN
20$:				;
	MOV	R1,R0		; PROPAGATE ZERO WORD
	RETURN			;

;+
; **-$ISD-RE-ENTRANT ROUTINE TO PERFORM SYMBOL TABLE EDIT
; **-$ISD1-BYPASS SETUP AND PERFORM EDIT
;
; THESE CO-ROUTINES ARE CALLED TO RETRIEVE ENTRIES IN AN ORDERED, LINKED
; LIST USING AN IMPURE STORAGE BLOCK SUPPLIED BY THE CALLER. THE LIST
; IS STORED IN VIRTUAL MEMORY.
;
; INPUTS:
;
; 	ENTRY POINT $ISD:
;
;	R0=REAL ADDRESS OF LISTHEAD ( ON FIRST CALL ONLY ).
;
;	ENTRY POINT $ISD AND $ISD1
;
;	R2=ADDRESS OF THREE-WORD STORAGE BLOCK TO RECEIVE DATA IN
;	   THE FOLLOWING FORMAT:
;
;		.WORD	LCOUNT	; CURRENT LISTHEAD COUNT
;		.WORD	LHEAD	; CURRENT LISTHEAD ADDRESS
;		.WORD	NEXT	; VIRTUAL ADDRESS OF NEXT IN LIST
;
; OUTPUTS:
;
;	C/CLEAR: HAVE NEXT SYMBOL
;
;		R0=REAL ADDRESS OF SYMBOL
;		R1=VIRTUAL ADDRESS OF SYMBOL
;
;	C/SET: NO MORE ENTRIES TO BE SCANNED
;
;		R1 = 0
;
; IN EITHER CASE, THIS ROUTINE EXITS VIA A CO-ROUTINE CALL
; TO THE CALLER WITH R2 POINTING TO THE NEXT LOCATION AFTER
; THE STORAGE BLOCK. THE BLOCK IS UPDATED WITH THE CURRENT
; COUNT, LISTHEAD ADDRESS AND VIRTUAL ADDRESS OF NEXT ENTRY.
;
;-

	.ENABL	LSB

$ISD::				;
	MOV	(R0),(R2)+	; SET THE INITIAL COUNT
10$:				;
	TST	(R0)+		; POINT TO NEXT LISTHEAD
ISD:				;
	MOV	R0,(R2)+	; SAVE LISTHEAD ADDRESS
	MOV	(R0),(R2)	; SET VIRTUAL ADDRESS OF NEXT
20$:				;
	MOV	(R2),R1		; GET VIRTUAL ADDRESS OF NEXT
	BEQ	40$		; IF EQ LIST EMPTY
	MOV	R2,-(SP)	; SAVE STORAGE POINTER
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	MOV	(SP)+,R2	; RETRIEVE POINTER
	MOV	(R0),(R2)+	; SET ADDRESS OF NEXT
	CLC			; CLEAR CARRY
30$:				;
	CALL	@(SP)+		; CALL THE CALLER
$ISD1::				;
	CMP	(R2)+,(R2)+	; POINT TO ADDRESS OF NEXT
	BR	20$		; PROCESS NEXT
40$:				;
	MOV	-(R2),R0	; GET LISTHEAD ADDRESS
	DEC	-2(R2)		; DECREMENT LISTHEAD COUNT
	BGE	10$		; IF GE MORE TO GO
	CMP	(R2)+,(R2)+	; POINT PAST END OF BLOCK
	SEC			; SET CARRY
	BR	30$		; CALL THE CALLER

	.DSABL	LSB


;+
; **-$SRCH-SEARCH A LEXICALLY ORDERED LIST FOR SYMBOL
;
; THIS ROUTINE IS CALLED TO SEARCH A LIST IN VIRTUAL
; MEMORY FOR A SYMBOL. THE LIST MUST BE IN LEXICAL OR-
; DER.
;
; INPUTS:
;
;	R0=REAL ADDRESS OF LISTHEAD
;	R1=REAL ADDRESS OF SYMBOL
;
; IT IS ASSUMED THAT THE SYMBOL IS PERMANENTLY RESIDENT
; IN REAL MEMORY.
;
;
; OUTPUTS:
;
;	C-SET:	SYMBOL NOT FOUND
;		R0, R1 CLEARED
;
;	C-CLEAR: SYMBOL FOUND
;		R0=REAL ADDRESS OF SYMBOL
;		R1=VIRTUAL ADDRESS OF SYMBOL
;
;-

$SRCH::				;
	MOV	R5,-(SP)	; SAVE R5
	MOV	R1,R5		; SAVE REAL ADDRESS OF SYMBOL
	MOV	(R0)+,LCOUNT	;++038 SET LISTHEAD COUNT
	CALL	FNDSLT		; LOCATE SUBLIST
	ADD	R2,R0		; COMPUTE SUBLIST ADDRESS
	MOV	#LCOUNT,R2	; GET ADDRESS OF LOCAL STORE
	CLR	(R2)+		; CLEAR LISTHEAD COUNT
	MOV	#ISD,-(SP)	; PUSH ADDRESS OF SCANNING ROUTINE
10$:				;
	CALL	@(SP)+		; GET NEXT SYMBOL
	MOV	#LCOUNT,R2	; GET ADDRESS OF LOCAL STORAGE
	BCS	20$		; IF C/S END OF LIST
	CMP	S$YM(R0),S$YM(R5) ; CHECK FIRST HALF OF SYMBOL
	BHI	20$		; IF HI NOT IN LIST
	BLO	10$		; IF LO CHECK NEXT ITEM
	CMP	S$YM+2(R0),S$YM+2(R5) ; CHECK SECOND HALF OF SYMBOL
	BLO	10$		; IF LO CHECK NEXT ITEM
	BEQ	25$		; IF EQ HAVE MATCH
20$:				;
	CLR	R0		; SET NOT-FOUND INDICATORS
	CLR	R1		;
	SEC			;
25$:				;
	INC	(SP)+		; CLEAN STACK
30$:				;
	MOV	(SP)+,R5	; RESTORE R5
	RETURN			;

;
; FIND SYMBOL POSITION WITHIN SUBLISTS
;

FNDSLT:				;
	MOV	#LIMIT,R1	; GET LIMIT TABLE ADDRESS
	CLR	R2		; CLEAR INDEX
10$:				;
	CMP	(R1)+,S$YM(R5)	; CHECK FIRST HALF OF SYMBOL
	BHIS	30$		;++038 IF HIS FOUND SLOT
	CMP	R2,LCOUNT	;++038 AT LAST SLOT?
	BHIS	30$		;++038 IF HIS YES
	INC	R2		;++038 INCREMENT COUNT
	BR	10$		;++038 GO AGAIN
30$:				;
	ASL	R2		; CONVERT TO WORD INDEX
	RETURN			;

	.END
