	.TITLE	P4MAL
	.IDENT	/24.18/
;
; COPYRIGHT (c)	1989,1991 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE IS FURNISHED  UNDER A LICENSE AND MAY BE USED OR
; COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; D.N. CUTLER 26-OCT-72
;
; MODIFIED FOR RSX-11M/M-PLUS V4.0/V2.0 BY:
;
;	J. A. KASSON
;
; MODIFIED FOR RSX-11M-PLUS V3.0 BY:
;
;	C. B. PETROVIC	26-FEB-82	24.01
;	C. B. PETROVIC	29-JUL-82	24.02
;	J. M. SALMAN	14-OCT-82	24.03
;	J. M. SALMAN	09-DEC-82	24.04
;	C. B. PETROVIC	27-MAY-83	24.05
;	C. B. PETROVIC	7-NOV-83	24.06
;
; MODIFIED FOR RSX-11M-PLUS V4.0 BY:
;
;	L. M. PETERSON	4-FEB-87	24.07	LMP078
;		ADD CHECK FOR INCOMPATIBLE SYSLIB SINCE V4.0 TKB REQUIRES
;		V4.0 SYSLIB
;
;	D. P. RABAHY	12-MAY-87	24.08	DPR040
;		CHANGE $$TSKP, ONLY OUTPUT SECOND WORD IF VARRAY SPECIFIED
;		SPR #264P
;
;	D. P. RABAHY	26-JUN-87	24.09	DPR044
;		SOME SMALL ENHANCEMENTS (NOTHING FUNCTIONAL)
;
;
; MODIFIED FOR RSX-11M-PLUS AND MICRO/RSX V4.1 BY:
;
;	L. M. PETERSON	1-DEC-87	24.10	LMP098
;		ADD LIBRARY D-SPACE RESERVATION SUPPORT
;
; MODIFIED FOR RSX-11M-PLUS AND MICRO/RSX V4.2 BY:
;
;	L. M. PETERSON	28-MAR-88	24.11	LMP110
;		CORRECT ERROR WITH PAR,/MU COMBINATION
;
;	L. M. PETERSON	6-DEC-88	24.12	LMP113
;		FIX ERROR MESSAGE SET UP
;
;	L. M. PETERSON	27-JUN-88	24.13	LMP115
;		CORRECT COMPARISON OF $APRDM VS $LDAPR
;		(APRS ALREADY RESERVED VS APRS REQUESTED WITH /LI:)
;
;	L. M. PETERSON	27-JUL-88	24.14	LMP118
;		MAKE ID TASKS W/O PAR CHECKPOINTABLE (SPR 16784)
;
;	LBM - propogate one-line correction to LMP115 made after CPR v1 SBD
;		across zero of master pack for CPR v1 before M-PLUS v4.2 ship
;
; MODIFIED FOR RSX-11M-PLUS AND MICRO/RSX V4.3 BY:
;
;	L. M. PETERSON	30-JAN-89	24.15	LMP130
;		LOCK ROOT SEGMENT DESCRIPTOR IN MEMORY TO PREVENT
;		PAGING PROBLEM WHEN LARGE NUMBER OF SYMBOLS IN ROOT
;
;	L. M. PETERSON	28-FEB-89	24.16	LMP131
;		Allow tasks with (task)memory resident overlays to be 
;		extended (with the $EXTM directive)
;
;	L. M. PETERSON	12-JUN-89	24.17	LMP133
;		FIX PROBLEMS WITH ID PIC LIBRARIES
;
;	C. M. KATZ	22-APR-91	24.18	CMK001
;		ADD RSTS CONDITIONAL CODE
;
; MACRO LIBRARY CALLS
;
	.MCALL	CLOSE$,GTIM$S
;
; LOCAL MACROS
;
	.MACRO	GENLST	ADR,N
	.IF	NB,N
	$$A=N
	.IFF
	$$A=1
	.ENDC
	$$B=0
	.REPT	$$A
	.WORD	ADR+$$B
	$$B=$$B+2
	.ENDR
	NN=NN+$$A
	.ENDM
;
; GENERATE PATCH LIST
;
; GPLST	SYMBOL,LIST,SCTNAM
;
; WHERE:
;
;	SYMBOL=SYMBOL NAME. IF DEFINED THEN SECTION IS EXTENDED BY
;	       ONE WORD FOR EACH ENTRY IN THE PATCH LIST.
;
;	LIST=LIST OF ADDRESSES CONTAINING VALUES THAT ARE TO BE
;	     INSERTED INTO THE PATCH LIST.
;		AN ADDRESS MAY ALSO TAKE THE FORM <ADR,N>, INDICATING
;		THAT 'N' WORDS ARE TO BE INSERTED, STARTING AT 'ADR'
;
;	SCTNAM=NAME OF SECTION TO CONTAIN SPECIFIED VALUES.
;

	.MACRO	GPLST	SYMBOL,LIST,SCTNAM

	.PSECT	PLST,RW,D
$$=.
	.BLKW	1
	.RAD50	/SYMBOL/
.=$$+6
NN=0
	.IRP	X,<LIST>
	GENLST	X
	.ENDR
$$$=.
.=$$
	.WORD	NN
.=$$$
	.WORD	0
.=.-2
	GSCTM	SYMBOL,0,$$,SCTNAM
	.ENDM

;
; GENERATE SECTION MODIFICATION TABLE ENTRY
;
; GSCTM SYMBOL,ADDCON,MULTIP,SCTNAM
;
; WHERE:
;
;	SYMBOL=SYMBOL NAME THAT IF DEFINED THEN SECTION IS TO BE EX-
;		TENDED BY AN AMOUNT EQUAL TO THE VALUE OF THE SYMBOL
;		PLUS THE ADDITIVE CONSTANT MULTIPLIED BY THE MULTIPLI-
;		CATIVE CONSTANT.
;	ADDCON=ADDITIVE CONSTANT.
;	MULTIP=ADDRESS OF MULTIPLICATIVE CONSTANT.
;	SCTNAM=CONTROL SECTION NAME.
;

	.MACRO	GSCTM SYMBOL,ADDCON,MULTIP,SCTNAM
	.PSECT	SCTTBL,RW,D,GBL
	.IF NB	<SYMBOL>

	.RAD50	/SYMBOL/

	.IFF

	.WORD	-1
	.WORD	2

	.ENDC
	.WORD	ADDCON
	.WORD	MULTIP
	.RAD50	/SCTNAM/
	.WORD	0
.=.-2
	IMPURE
	.ENDM

;
; GENERATE UNIT MODIFICATION TABLE ENTRY
;
; GUNTM SYMBOL,DEVNAM
;
; WHERE:
;
;	SYMBOL=SYMBOL NAME THAT IF DEFINED THEN THE LOCATION POINTED
;		TO BY THE SYMBOL VALUE IS TO BE MODIFIED WITH THE
;		NUMBER OF LOGICAL UNITS.
;	DEVNAM=A TWO CHARACTER DEVICE NAME. IF THE DEVICE NAME IS
;		BLANK, THEN THE NUMBER OF UNITS IS THE PATCH VALUE
;		AND NO LUN ASSIGNMENT IS GENERATED. ELSE THE NUMBER
;		OF LUNS IS INCREMENTED AND THE UPDATED VALUE IS THE
;		PATCH VALUE. AN ENTRY IS PLACED IN THE ASSIGNMENT LIST
;		FOR THE DEVICE TO THE LUN SPECIFIED BY THE UPDATED
;		NUMBER OF LOGICAL UNITS.
;

	.MACRO	GUNTM SYMBOL,DEVNAM
	.PSECT	LUNTBL,RW,D,GBL
.=.-2
	.RAD50	/SYMBOL/
	.WORD	0
	.IF NB	DEVNAM
.=.-2
	.ASCII	/DEVNAM/
	.ENDC
	.WORD	0
	IMPURE
	.ENDM


	.IF	DF	R$$11M

;
; ESTABLISH LOW CORE RESERVED SYMBOLS
;
; LOSAV	VECTOR,LOCOR
;
; WHERE:
;
;	VECTOR=	SYMBOL WHOSE VALUE, IF DEFINED IN THE ROOT SEGMENT
;		IS PLACED IN A SPECIFIED LOW-CORE SAVE LOCATION
;		WITHIN THE TASK HEADER
;
;	LOCOR= TKB STORAGE LOCATION TO RECEIVE THE ABOVE VALUE
;
	.MACRO	LOSAV,VECTOR,LOCOR
	.PSECT	SVTBL,RW,D,LCL
.=.-2
	.WORD	0
	.WORD	0
NN=.
.=.-4
	.RAD50	/VECTOR/
.=NN
	.WORD	LOCOR
	.WORD	0
	.PSECT
	.ENDM

	.ENDC

;
; LOCAL DATA
;

	.IF	DF	R$$11M

;
; LOW CORE VECTOR TABLE
;

	.PSECT	SVTBL,RW,D,LCL
LOBAS:	.WORD	0		; DUMMY ZERO WORD AT START OF TABLE
	IMPURE
	LOSAV	.FSRCB,$HFSR
	LOSAV	$OTSVA,$HOTV
	LOSAV	.NOVLY,$HOVLY
	LOSAV	$VEXTA,$HEXT

	.ENDC

;
; UNIT MODIFICATION TABLE
;
;		*** NOTE ***
;
; ANY 'AUTOMATIC' LUN/UNIT ASSIGNMENTS MUST BE INSERTED AFTER
; THE ENTRY FOR '.NLUNS'.
;

	.PSECT	LUNTBL,RW,D,GBL
LUNBAS:	.WORD	0		;DUMMY ZERO WORD AT START OF TBL
	GUNTM	.NLUNS

	.IF	NDF	R$$11M

	GUNTM	.MOLUN,MO

	.IFF

	GUNTM	.MOLUN,TI

	.ENDC

	GUNTM	.MBLUN,SY	; MAILBOX LUN USED BY RMS
	GUNTM	.PTLUN,SY	; PLOTTER LUN
	GUNTM	.USLU1,SY	; USER LUN
	GUNTM	.USLU2,SY	; USER LUN
	GUNTM	.NOVLY,OV

	.IF	NDF	R$$11M

	GUNTM	.ODTL1,CI	;++014

	.IFF

	GUNTM	.ODTL1,TI

	.ENDC

	GUNTM	.ODTL2,CL	;++014
	GUNTM	.TRLUN,CL

	.IF DF R$$PRO

	GUNTM	.SUML1,SY		; P/OS STANDARD UTILITY MODULE LUN

	.ENDC


;
; SECTION MODIFICATION TABLE
;

	.PSECT	SCTTBL,RW,D,GBL
SCTBAS:				; REF LABEL
	GSCTM	F.FDB,0,$NUNIT,$$DEVT
	GSCTM	F.BFHD,512.,$ACTFL,$$FSR1

;
; SECTIONS TO MODIFY IF CLUSTER LIBRARIES EXIST
;
	PURE.D			; READ-ONLY D-SPACE

CLSBAS:
	.RAD50	/$$SGD1/	; SECTION CONTAINING SEGMENT DESCRIPTORS
	.RAD50	/$$WNDS/	; SECTION CONTAINING WINDOW DESCRIPTORS
	.RAD50	/$$RGDS/	; SECTION CONTAINING REGION DESCRIPTORS
;
; PATCH LIST
;
;		*** NOTE ***
;
; PATCH LIST ENTRIES MUST BE DEFINED AFTER THE SECTION
; MODIFICATION TABLE.
;

	.PSECT	PLST

;
;		** NOTE **
; When building a Fortran-77 task to be built as an I/D  task, The OTS
; must know what APRS are in use by the task if Virtual arrays are also
; used. The first value in the p-section $$TSKP is the internal task APR
; bitmap, it should reflect the D-space APRs, not the I-space
;  APRs. When building a conventional (non-I/D) task, the D-space and I-space
; APRs are overmapped. This is guaranteed by the Executive and TKB will
; conform.
;
PLBAS:
	GPLST	$TSKP,<$APRDM,$VARSZ,$MXLGH,$MXLGH+2,$LBEXT,$LBOFF>,$$TSKP
	GPLST	.NSZSG,<$SZSEG>,$$OVRS


	GPLST	$DBTS,<<$DBTS,8.>,ZERO,ZERO,<STBNMB,10.>>,$$DBTS

	IMPURE			; READ/WRITE D-SPACE
;
; RELATIVE DISK BLOCK ADDRESS OF OVERLAY SEGMENT LOAD LIST
;

$LBSGL::.BLKW	1		;


STBNMB:	.BLKW	10.		; BUFFER TO HOLD NAMEBLOCK INFO FOR STB FILE
ZERO:	.WORD	0		; ZERO WORD FOR USE BY PATCHES
LCLSYM:	.BLKW	2		; SYSCHK TEMP BUFFER TO HOLD UNDEFINED SYMBOL
IAPUSE::.BLKW	1		; I-APR USAGE
DAPUSE::.BLKW	1		; D-APR USAGE
ADBIAS::.BLKW	1		; ADDRESS BIAS FOR SHIFTED MR OVERLAYS
APBIAS::.BLKW	1		; APR BIAS FOR SHIFTED MR OVERLAYS
RTOFF::	.BLKW	1		; ROOT W.NOFF FOR USE IN CALCULATING SHOFF
SHOFF::	.BLKW	1		; 1ST WNDW'S W.NOFF (USED AS BASE FOR SHIFTING)
LBOFF::	.BLKW	1		; SHIFTED VERSION OF $LBOFF


;+
; **-$P4MAL-PHASE 4 MEMORY ALLOCATION
;
; THIS ROUTINE IS CALLED AT THE END OF PHASE 3 TO ALLOCATE BOTH PHY-
; SICAL AND VIRTUAL MEMORY FOR THE TASK. RESIDENT COMMON AND LIBRARY
; ROUTINES ARE PROCESSED FIRST FOLLOWED BY EACH SEGMENT IN THE ALLOC-
; ATION. AS EACH SEGMENT IS CONSIDERED, EACH CONTROL SECTION FOR THAT
; SEGMENT IS ALLOCATED AN ABSOLUTE ADDRESS RELATIVE TO ZERO. AT THE
; END OF MEMORY ALLOCATION, ABSOLUTE ADDRESSES (RELATIVE TO ZERO) ARE
; ASSIGNED TO ALL RELOCATABLE SYMBOLS. THE AUTOLOAD LIST FOR EACH SEG-
; MENT IS THEN PROCESSED AND ABSOLUTE ADDRESSES ARE ASSIGNED TO AUTO-
; LOAD VECTORS. THE FINAL STEP IS THE ALLOCATION AND ZEROING OF THE
; DISK SPACE FOR THE TASK IMAGE.
;
; INPUTS:
;
;	TABLES CONTRUCTED BY PHASE 3.
;
; OUTPUTS:
;
;	PHYSICAL AND VIRTUAL MEMORY IS ALLOCATED, ABSOLUTE ADDRESSES
;	ARE ASSIGNED TO RELOCATABLE SYMBOLS, ABSOLUTE ADDRESSES ARE AS-
;	SIGNED TO AUTOLOAD VECTORS, AND THE TASK IMAGE DISK SPACE IS
;	ALLOCATED AND ZEROED.
;-
	PURE.I			; READ-ONLY I-SPACE

$P4MAL::SAVRG			;SAVE NONVOLITILE REGISTERS
	CALL	SYSCHK		; CHECK FOR INCOMPATIBLE SYSLIB
	MOVB	$APRMP,IAPUSE	; SAVE CURRENT LIBRARY APR USAGE (I-SPACE)
	MOV	$APRDM,DAPUSE	; SAVE CURRENT SHARED REGION D-SPACE RESERVATION
	
	.IF DF D$CVRL & D$P4MA

	MOV	$PHASE,$VMPHZ	; SET TRACE FOR VIRTUAL MEMORY PAGE
	MOV	$RTSEG,$CRVSG	; INSURE THAT WE POINT TO THE ROOT SEGMENT

	.ENDC	; D$CVRL & D$P4MA

	MOV	$TSKPT,R0	; GET TASK RECORD BLOCK
	CALL	$STRCB		; SETUP FILE-NAME BLOCK

;
; PROCESS SECTION MODIFICATION TABLE
;
;
; FIRST EXTEND SECTIONS FOR CLUSTER LIBRARIES IF THEY EXIST
;

	TST	$CLSHD		; CLUSTER LIBRARIES?
	BEQ	10$		; IF EQ NO
	MOV	#CLSBAS,R5	; GET ADDRESS OF SECTION NAMES
	MOV	$SZSEG,R0	; GET SIZE OF SEGMENT DESCRIPTORS
	ASL	R0		; NEED TWO SEGMENT DESCRIPTORS PER CLUSTER
	MOV	$CLSHD+2,R1	; GET NUMBER OF CLUSTERS
	CALL	$MUL		; MULTIPLY
	MOV	R1,R4		; SET EXTENSION AMOUNT
	CALL	EXTSEC		; EXTEND SECTION $$SEG1
	MOV	#W$NLGH,R0	; GET LENGTH OF WINDOW DESCRIPTOR
	MOV	$CLSHD+2,R1	; GET NUMBER OF CLUSTERS
	CALL	$MUL		; MULTIPLY
	MOV	R1,R4		; SET EXTENSION AMOUNT
	CALL	EXTSEC		; EXTEND SECTION $$WNDS
	MOV	#R$GLGH,R0	; GET LENGTH OF REGION DESCRIPTOR
	MOV	$CLSHD+2,R1	; GET NUMBER OF CLUSTERS
	CALL	$MUL		; MULTIPLY
	MOV	R1,R4		; SET EXTENSION AMOUNT
	CALL	EXTSEC		; EXTEND SECTION $$REG1
10$:

	MOV	#SCTBAS,R5	;GET ADDRESS OF MODIFICATION TABLE
P4MAL1:	TST	(R5)		;ANY MORE ENTRIES?
	BEQ	P4MAL2		;IF EQ NO
	CALL	SYMSR		;SEARCH FOR SYMBOL
	BCS	10$		;IF CS NOT FOUND
	BITB	#SY$REL,S$YFLG(R0);ABS SYMBOL?
	BEQ	4$		; IF NE NO
	MOV	#2,R0		; GET DUMMY VALUE
	BR	5$		;
4$:
	MOV	S$YVAL(R0),R0	;GET SYMBOL VALUE
5$:				;
	CMP	(R5)+,(R5)+	;POINT TO ADDITIVE CONSTANT
	ADD	(R5)+,R0	;ADD IN ADDITIVE CONSTANT
	MOV	@(R5)+,R1	;GET MULTIPLICATIVE CONSTANT

	CALL	$MUL		;

	MOV	R1,R4		;SAVE RESULT
	CALL	EXTSEC		; EXTEND SECTION
	BCC	20$		; IF CC ALREADY THERE
	BR	P4MAL1		;GO AGAIN
10$:	ADD	#14,R5		;ADVANCE TO NEXT ENTRY
	BR	P4MAL1		;GO AGAIN
20$:	CMP	(R5)+,(R5)+	;POINT TO NEXT ENTRY
	BR	P4MAL1		;GO AGAIN

;
; PROCESS UNIT MODIFICATION TABLE
;

P4MAL2:	MOV	#LUNBAS,R5	;GET ADDRESS OF UNIT MODIFICIATION TBL
10$:	TST	(R5)		;ANY MORE TO PROCESS?
	BEQ	P4MAL3		;IF EQ NO
	CMP	(PC)+,(R5)	;OVERLAY PATCH?
	.RAD50	/.NO/		;
	BNE	15$		;IF NE NO
	CMP	#1,$NUMSG	;MORE THAN ONE SEGMENT?
	BEQ	30$		;IF EQ NO
15$:	CALL	SYMSR		;SEARCH FOR SYMBOL
	BCS	30$		;IF CS NOT FOUND
	MOV	#1,R4		; GET PATCH COUNT
	CALL	IPATCH		;INITIALIZE PATCH
	MOV	(R5)+,R4	;GET DEVICE NAME
	BEQ	20$		;IF EQ NO UPDATE OF UNITS
	INC	$NUNIT		;INCREMENT NUMBER OF UNITS
20$:	MOV	$NUNIT,(R0)	;SET PATCH VALUE
	TST	R4		;ANY DEVICE?
	BEQ	10$		;IF EQ NO
	MOV	#10,R1		;GET SIZE OF BLOCK NEEDED
	CALL	$ALBLK		;ALLOCATE STORAGE
	MOV	R0,@$LUNHD+2	;LINK TO OLD LAST
	MOV	R0,$LUNHD+2	;SET NEW LAST
	TST	(R0)+		;POINT TO DEVICE NAME
	MOV	R4,(R0)+	;SET DEVICE NAME
	MOV	(PC)+,(R0)+	;SET UNIT 0 AND ONE ASSIGNMENT
	.BYTE	0,1		;
	MOV	$NUNIT,(R0)	;SET LUN NUMBER
	BR	10$		;
30$:	ADD	#6,R5		;ADVANCE TO NEXT ENTRY
	BR	10$		;

;
; CALCULATE HEADER SIZE
;

P4MAL3:				;
	MOV	$NUNIT,R0	; GET NUMBER OF UNITS
	MOV	#$LBSGL,R3	; GET ADDRESS OF LOAD LIST DISK BLOCK
	CLR	(R3)		; ASSUME NO DISK ALLOCATION MADE
	MOV	#$LBLSZ,R1	; POINT TO SIZE OF LABEL
	MOV	#512.*2,(R1)	; SET LABEL SIZE
	MOV	#2,R2		; SET NUMBER OF BLOCKS IN LABEL
	CMP	R0,#128.	; CHECK NUMBER OF LUNS
	BLE	5$		; IF LE ALL SET
	INC	R2		; ELSE INCREMENT NUMBER OF LABEL BLOCKS
	ADD	#512.,(R1)	; ADD ANOTHER BLOCK TO SIZE
5$:
	MOV	R2,$LBBLK	; SET NUMBER OF LABEL BLOCKS
	MOV	R2,$HDRBN	; RELATIVE BLOCK NUMBER OF HEADER

	ASL	R0		;MULTIPLY BY 4
	ASL	R0		;

	MOV	$TSKPT,R2
	MOV	R$SWTH(R2),R2	; FETCH TASK IMAGE FLAGS
	CLR	$HDSIZ		; ASSUME TASK IMAGE HAS NO HEADER
	BIT	#SW$NH,R2	 ; TEST FOR HEADER
	BNE	P4MAL4		; BUILD WITHOUT HEADER IF NE
	ADD	#<H$LUN-H$CSP>+2,R0 ; ADD LENGTH OF FIXED PART OF HEADER
	BIT	#<SW$FP!SW$EA>,R2  ; FLOATING POINT OR EAE SPECIFIED?
	BEQ	10$		; IF EQ NO
	BIT	#XH$DR,$SWTCH	; EXTERNAL HEADER TASK?
	BNE	10$		; YES - DON'T ALLOCATE SPACE FOR FP
	ADD	#6,R0		; ASSUME EAE
	BIT	#SW$FP,R2	; SEE IF F/P
	BEQ	10$		; IF EQ NO
	ADD	#<25.*2-6>,R0	; YES ALLOCATE MORE SPACE
10$:
	.IF	NDF,R$RSTS	
	ADD	#22,R0		; ALLOCATE REGISTER SAVE AREA,PS AND GUARD
	.IFF
	MOV	#1000,R0	; HEADER SIZE FOR RSTS
	.ENDC

	MOV	R0,$HDSIZ	;SET HEADER SIZE

;
; ALLOCATE CHECKPOINT AREA ON DISK
;

P4MAL4:				;

	.IF DF D$CVRL & D$P4MA

	MOV	#-1,$VMPHZ	; SET NO TRACE FOR VIRTUAL MEMORY PAGE

	.ENDC	; D$CVRL & D$P4MA

	.IF DF D$PCTR & D$P4MA

	.IF DF D$DSLO

		.IF DF D$PC0!D$PC1

	MOV	$PHASE,$TRSPH	; SET TRACE FLAG FOR SEGMENT DESCRIPTOR

		.ENDC	; D$PC0!D$PC1

		.IF DF D$PC2!D$PC3

	MOV	$PHASE,$TRWPH	; SET TRACE FLAG FOR WINDOW DESCRIPTOR

		.ENDC	; D$PC2!D$PC3

	.ENDC	; D$DSLO

	.IFTF

	CALL	$DSALO		; ALLOCATE TASK-RESIDENT DESCRIPTORS

	.IFT

	.IF DF D$ALLO

		.IF DF D$PC0!D$PC1

	MOV	$PHASE,$TRSPH	; SET TRACE FLAG FOR SEGMENT DESCRIPTOR

		.ENDC	; D$PC0!D$PC1

		.IF DF D$PC2!D$PC3

	MOV	$PHASE,$TRWPH	; SET TRACE FLAG FOR WINDOW DESCRIPTOR

		.ENDC	; D$PC2!D$PC3

	.ENDC	; D$ALLO

	.IFTF

	CALL	$ALALO		; ASSIGN ADDRESSES TO SET TRACE FLAG FOR GENERAT
				; AUTOLOAD VECTORS

	.IFT

	.IF DF D$SGLO

		.IF DF D$PC0!D$PC1

	MOV	$PHASE,$TRSPH	; SET TRACE FLAG FOR SEGMENT DESCRIPTOR

		.ENDC	; D$PC0!D$PC1

		.IF DF D$PC2!D$PC3

	MOV	$PHASE,$TRWPH	; SET TRACE FLAG FOR WINDOW DESCRIPTOR

		.ENDC	; D$PC2!D$PC3

	.ENDC	; D$SGLO

	.IFTF

	CALL	$SGALO		; ALLOCATE PHYSICAL SET TRACE FLAG FOR TASK-VIRT

	.IFT

	.IF DF D$DSLO!D$ALLO!D$SGLO

		.IF DF D$PC0!D$PC1

	MOV	#-1,$TRSPH	; SET NO TRACE FLAG FOR SEGMENT DESCRIPTOR

		.ENDC	; D$PC0!D$PC1

		.IF DF D$PC2!D$PC3

	MOV	#-1,$TRWPH	; SET NO TRACE FLAG FOR WINDOW DESCRIPTOR

		.ENDC	; D$PC2!D$PC3

	.ENDC	; D$DSLO!D$ALLO!D$SGLO

	.ENDC	; D$PCTR & D$P4MA
;
; ADD BLOCK TO SIZE OF LABEL IF TASK HAS RESIDENT OVERLAYS AND
; ONLY RESIDENT OVERLAYS. 11S SUPPORT
;
	CMP	$NUMSG,#1	; TASK OVERLAID?
	BEQ	110$		; IF EQ NO
	TST	$TSKWD		; TASK HAVE RESIDENT OVERLAYS?
	BEQ	110$		; IF EQ NO
	BIT	#DS$KOV,$SWOVR	; TASK HAVE DISK OVERLAYS?
	BNE	10$		; IF NE YES
	INC	$LBBLK		; ADD BLOCK TO NUMBER OF LABEL BLOCKS
	MOV	$HDRBN,$LBSGL	; SET BLOCK NUMBER OF SEGMENT TABLE
	INC	$HDRBN		; RESET RELATIVE BLOCK NUMBER OF HEADER
	ADD	#512.,$LBLSZ	; ADD ONE BLOCK TO LABEL SIZE IN BYTES
110$:
	MOV	$PARSZ,R0	;++041 GET PARTITION SIZE
	MOV	$TSKPT,R2	;++041 GET TASK FILE FLAGS
	MOV	R$SWTH(R2),R2	;++041 ...
	BIT	#MP$SY,$SWTCH	;++041 MAPPED SYSTEM?
	BEQ	5$		;++041 IF EQ NO
	BIT	#SW$NH,R2	; SHARED REGION?
	BNE	5$		; IF NE NO
100$:
	MOV	#$MXLGH,R1	; POINT TO MAX LENGTH
	TST	R0		;++041 SYSTEM CONTROLLED PARTITION?
	BEQ	1$		; IF EQ YES
	MOV	R2,R3		; SAVE SWITCHES
	MOV	(R1)+,R2	; GET MAX LENGTH
	BIT	#SW$MU,R3	; BUILDING MULTIUSER TASK?
	BEQ	101$		; IF EQ, NO - CHECK ALL SECTIONS
	CMP	(R1)+,(R1)+	; JUST CHECK RW SECTIONS
	BR	102$
101$:	ADD	(R1)+,R2	; ADD R/O ALLOCATION
	ADD	(R1)+,R2	; ADD R/O DATA
102$:	ADD	(R1)+,R2	; ADD R/W DATA
	MOV	R0,R1		; COPY PARTITION SIZE
	SUB	R2,R1		; SUBTRACT TASK SIZE FROM PARTITION SIZE
	BLO	2$		; IF LO ERROR
	MOV	R1,$LBEXT	; SET EXTEND SIZE
	MOV	R3,R2		; RESTORE SWITCHES
	BR	5$		; ALLOCATE CHECKPOINT SPACE
1$:				;
	MOV	(R1)+,R0	; GET LENGTH OF TASK IMAGE (I-SPACE)
	ADD	$LBEXT,R0	; INCLUDE TASK EXTENSION
	BCS	2$		; IF C/S PHYSICAL ADDRESS OVERFLOW
	ADD	(R1)+,R0	; INCLUDE R/O I ALLOCATION
	BCS	2$		; IF C/S PHYSICAL ADDRESS OVERFLOW
	ADD	$LBOFF,R0	; ADD TASK OFFSET INTO PARTITION
	BCS	2$		; IF C/S PHYSICAL ADDRESS OVERFLOW	
	MOV	R0,$PARSZ	;++041 SAVE TOTAL TASK SIZE
	BIT	#ID$ATA,$SWTCH	; DOING AN I/D TASKBUILD?
	BEQ	15$		; IF EQ, NO..CONVENTIONAL
	ADD	(R1)+,R0	; INCLUDE R/O D FOR POSSIBLE CHECKPOINTING
	ADD	(R1)+,R0	; INCLUDE R/W D FOR POSSIBLE CHECKPOINTING
15$:	BR	5$
2$:				;
	BIC	#TS$KF,$SWTCH	; CANCEL TASK IMAGE OUTPUT
	MOV	$LBEXT,-(SP)	; PUSH TASK EXTEND SIZE
	MOV	$MXLGH,-(SP)	; PUSH TASK IMAGE LENGTH
	MOV	$LBOFF,-(SP)	; PUSH TASK OFFSET
	MOV	SP,R2		; SET ADDRESS OF PARAMETER LIST
	MOV	#<S$V0*400!E$R87>,R1 ; GET ERROR/SEVERITY
	CALL	$ERMSG		; REPORT DIAGNOSTIC
	ADD	#6,SP		; CLEAN STACK
	MOV	#177777,R0	; SET PARTITION SIZE TO MAX
4$:				;
	MOV	R0,$PARSZ	;++041 SAVE TOTAL TASK SIZE
5$:				;++041
	BIT	#<SW$ALO!SW$CP>,R2 ; ALLOCATE CHECKPOINT SPACE ON DISK?
	BNE	10$		; IF NE NO
	BIT	#XH$DR,$SWTCH	; EXTERNAL HEADER TASK?
	BEQ	7$		; IF EQ NO
	MOV	$HDSIZ,R1	; INCLUDE EXTRA HEADER IN CHECKPOINT SPACE
	BIT	#SW$FP,R2	; TASK HAVE FLOATING POINT?
	BEQ	6$		; IF EQ NO
	ADD	#<25.*2>,R1	; ALSO INCLUDE SPACE FOR FLOATING POINT
				; SAVE AREA
6$:
	ADD	#77,R1		; ROUND TO 32W BOUND
	BIC	#77,R1		;
	ASR	R1		; CONVERT TO 32W BLOCKS
	BIC	#100000,R1	; CLEAR SIGN BIT, REALLY CARRY BIT
	ASR	R1		;
	ASR	R1		;
	ASR	R1		;
	ASR	R1		;
	ASR	R1		;
	ADD	R1,R0		; INCLUDE HEADER IN CHECKPOINT SPACE
7$:
	ADD	#7,R0		; ROUND TO MULTIPLE OF 256W
	BIC	#7,R0		; CLEAR EXTRANEOUS BITS
	ROR	R0		; CONVERT TO BLOCKS
	ROR	R0		; ...
	ROR	R0		; ...
	ADD	R0,$HDRBN	; SET RELATIVE BLOCK NUMBER OF HEADER
10$:				; REF LABEL
;
; NOW FINISH ALLOCATION (SHIFT ALLOCATION IN SYALO IF /EX SET)
;

P4MAL6:				;
	CALL	$SYALO		;ASSIGN ABSOLUTE ADDRESSES TO SYMS
	CALL	$DKALO		;ALLOCATE TASK IMAGE DISK SPACE

;
; PROCESS PATCH LIST TABLE
;

P4MAL7:				;
	GTIM$S	#$DBTS		; SET UP TIME STAMP FOR DEBUGGER SECTION
	MOV	$STBNM,R1	; GET STB NAMEBLOCK
	BEQ	6$		; J IF NONE
	CALL	$CVRL		; CONVERT TO REAL
	ADD	#E$LMND,R0	; OFFSET TO FILENAME INFO
	MOV	#STBNMB,R1	; GET ADDRESS OF BUFFER
	MOV	#10.,R2		; SET LOOP COUNT
5$:	MOV	(R0)+,(R1)+	; COPY A WORD
	SOB	R2,5$		; LOOP
	BR	8$		;
6$:	MOV	#STBNMB,R1	; GET BUFFER ADDRESS
	MOV	#10.,R2		; AND LOOP COUNT
7$:	CLR	(R1)+		; CLEAR THE BUFFER
	SOB	R2,7$		;
8$:
	MOV	#PLBAS,R5	; GET ADDRESS OF PATCH LIST TABLE
10$:				;
	MOV	(R5)+,R4	; GET NUMBER OF PATCHES
	BEQ	P4MAL8		; IF EQ AT END OF LIST
	CALL	SYMSR		; SEARCH FOR SYMBOL
	BCS	30$		; IF C/S NOT FOUND
	CALL	IPATCH		; INITIALIZE PATCH LIST
20$:				;
	MOV	@(R5)+,(R0)+	; INSERT ENTRIES IN LIST
	SOB	R4,20$		; ...
	BR	10$		; PROCESS NEXT ENTRY
30$:				;
	ASL	R4		; CONVERT COUNT TO BYTES
	ADD	R4,R5		; ADD TO TABLE POINTER
	CMP	(R5)+,(R5)+	; POINT TO NEXT ENTRY
	BR	10$		; GO AGAIN
;
; CHECK FOR LIBRARY D-SPACE RESERVATION AND SETUP LOW CORE POINTERS
;


P4MAL8:				;
	BIT	#LI$BRY,$SWOVR	; BUILDING LIBRARY?
	BEQ	10$		; IF EQ, NO
	TST	$LDAPR		; RESERVE SPECIFIC LIBRARY D-SPACE APRS?
	BMI	5$		; IF MI, NO
	CMP	#377,$LDAPR	; LEGAL VALUE?
	BGE	3$		; IF GE, YES
2$:	MOV	#LCLSYM,R0	; SET UP FOR ERROR MESSAGE
	MOV	$LDAPR,R1
	MOV	#14010,R2	
	CALL	$CBTA
	MOV	#LCLSYM,-(SP)
	MOV	#3,-(SP)
	MOV	SP,R2
	MOV	(PC)+,R1	; ILLEGAL APR RESERVATION
	.BYTE	E$R67,S$V2	; FATAL-NO RETURN
	CALL	$ERMSG		; OUTPUT ERROR MESSAGE	
3$:	MOV	$LDAPR,$APRDM	; RESET LIBRARY D-SPACE RESERVATION
	BR	10$		; CONTINUE
5$:	MOV	$TSKPT,R5	;
	BIT	#SW$PI,R$SWTH(R5) ; BUILDING PIC LIBRARY?
	BNE	10$		; IF NE, YES
	MOV	DAPUSE,$APRDM	; USE ORIGINAL (ABS) LIB D-SPACE RESERVATION
10$:
	MOV	#LOBAS-6,R5	; FETCH TABLE POINTER LESS OFFSET
20$:
	ADD	#6,R5		; OFFSET TO NEXT ENTRY
	TST	(R5)		; ANY MORE TO PROCESS
	BEQ	40$		; IF EQ NO
	CLR	@4(R5)		; ASSUME VECTOR NOT DEFINED IN ROOT
	CALL	SYMSR		; SEARCH ROOT FOR DEFINITION
	BCS	20$		; IF C/S NOT DEFINED
	BITB	#SY$REL,S$YFLG(R0) ; TEST IF RELOCATABLE
	BEQ	30$		; IF EQ NO
	MOV	$OFFST,@4(R5)	; SETUP RELOCATION BIAS
30$:
	ADD	S$YVAL(R0),@4(R5) ; RELOCATE DEFINITION
	BR	20$		; GO AGAIN
40$:				; REF. LABEL
	MOV	$RLBLK,$ROBLK	; GET RELATIVE BLK NUMBER OF R-O
	INC	$ROBLK		;
	CALL	$HEADR		;OUTPUT TASK HEADER
	BIT	#TS$KF,$SWTCH	; TASK FILE SPECIFIED ?
	BEQ	50$		; IF EQ NO
	MOV	$TSKNM,R1	; GET TASK NAME BLOCK
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	CALL	$WRMPG		; WRITE MARK THE PAGE
	MOV	R0,R1		; COPY REAL ADDRESS
	CLR	E$LNUM(R1)	; CLEAR HIGHEST SECTION NUMBER
50$:				;
	RETURN			;

;
; SUBROUTINE TO ALLOCATE AND INITIALIZE PATCH LIST ENTRY
;

IPATCH:				;
	MOV	#2+2+4+2+4+2,R1	; GET SIZE OF PATCH LIST HEADER
	ADD	R4,R1		; ADD IN NUMBER OF PATCHES
	ADD	R4,R1		; CONVERT NUMBER TO BYTES
	CALL	$ALBLK		;ALLOCATE STORAGE
	MOV	#$PATHD,R1	;GET ADDRESS OF PATCH LISTHEAD
	TST	(R1)+		;ANYTHING IN LIST?
	BEQ	10$		;IF EQ NO
	MOV	-(R1),(R0)	;LINK OLD FIRST TO NEW FIRST
	MOV	R0,(R1)		;SET NEW FIRST
	BR	20$		;
10$:	MOV	R0,@(R1)+	;SET ADDRESS OF FIRST
	MOV	R0,-(R1)	;SET ADDRESS OF LAST
20$:	TST	(R0)+		;POINT TO NUMBER OF PATCHES
	MOV	R4,(R0)+	; SET PATCH COUNT
	CALL	CVROOT		; GET REAL ADDRESS OF ROOT IN R1
	MOV	S$GNME(R1),(R0)+;SET SEGMENT NAME OF PATCH
	MOV	S$GNME+2(R1),(R0)+;
	MOV	#2,(R0)+	;TYPE EQUAL GLOBAL PATCH
	MOV	(R5)+,(R0)+	;INSERT SYMBOL NAME
	MOV	(R5)+,(R0)+	;
	CLR	(R0)+		;CLEAR OFFSET VALUE
	RETURN			;

;
; SUBROUTINE TO SEARCH ROOT SEGMENT FOR SYMBOL DEFINITION
;

SYMSR:				;
	CALL	CVROOT		; GET REAL ADDRESS OF ROOT IN R1
	MOV	R1,R0		; COPY REAL ADDRESS
	ADD	#S$GSTB,R0	;POINT TO SYMBOL TABLE
	MOV	R5,R1		;COPY TABLE ENTRY ADDRESS
	SUB	#S$YM,R1	;CALCULATE PROPER OFFSET
	CALL	$SRCH		;SEARCH SYMBOL TABLE
	BCS	20$		;IF CS NO FIND EM
	BITB	#SY$DEF,S$YFLG(R0);SYMBOL DEFINITION?
	BEQ	10$		;IF EQ NO
	BITB	#SY$IND,S$YFLG(R0);INDIRECT REFERENCE?
	BNE	10$		;IF NE YES
	CLC			;CLEAR CARRY
	BR	20$		;
10$:	SEC			;SET CARRY
20$:	RETURN			;

;
; CONVERT VIRTUAL ADDRESS OF ROOT TO REAL ADDRESS IN R1
;

CVROOT:				;
	MOV	R0,-(SP)	; SAVE R0
	MOV	$RTSEG,R1	; GET VIRTUAL ADDRESS OF ROOT SEGMENT
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	CALL	$WRMPG		; WRITE-MARK PAGE
	MOV	R0,R1		; COPY REAL ADDRESS
	MOV	(SP)+,R0	; RESTORE R0
	RETURN			;


;
; EXTSEC - INSERTS SECTIONS INTO THE EXTENSION LIST
;
; INPUTS:
;	R4 - LENGTH OF EXTENSION
;	R5 - ADDRESS OF SECTION NAME
;
; OUTPUTS:
;	R5 - ADDRESS FOLLOWING SECTION NAME
;	C BIT = 0 IF SECTION ALREADY IN EXTENSION LIST
;

EXTSEC:
	MOV	#$SCTHD,R0	; GET ADDR OF SECTION EXTENSION LISTHEAD
	MOV	R5,R1		; POINT TO SECTION NAME
	SUB	#S$YM,R1	; CALCULATE PROPER OFFSET
	CALL	$SRCHR		; SEARCH FOR SECTION
	BCC	10$		; IF CC	ALREADY THERE
	MOV	#C$SBSE+2,R1	; GET SIZE OF BLOCK NEEDED
	CALL	$ALBLK		; ALLOCATE STORAGE
	MOV	(R5)+,S$YM(R0)	; INSERT SECTION NAME
	MOV	(R5)+,S$YM+2(R0);
	MOV	R4,C$SBSE(R0)	; INSERT EXTENSION LENGTH
	MOV	R0,R1		; COPY ENTRY ADDRESS
	MOV	#$SCTHD,R0	; GET ADDR OF SECTION EXTENSION HEADER
	CALL	$ISYMR		; INSERT SECTION INTO EXTENSION LIST
	SEC			; SET BECAUSE SECTION DIDN'T EXIST
10$:
	RETURN

SYSCHK:
	CALL	CVROOT		;GET ROOT SEGMENT
	MOV	R1,R0
	TST	S$GUND(R0)	;ANY UNDEFINED SYMBOLS?
	BEQ	105$		;IF EQ, NO
	MOV	$RTSEG,R1	;GET VIRTUAL ADDRESS OF ROOT SEGMENT
	CALL	$LCKPG		;LOCK ROOT SEGMENT DESCRIPTOR IN MEMORY
	ADD	#S$GSTB,R0	;POINT TO SYMBOL TABLE
	MOV	#$ISED,-(SP)	;SET ADDRESS OF SYMBOL EDIT ROUTINE
10$:	CALL	@(SP)+		;GET NEXT SYMBOL
	BCS	100$		;IF CS DONE
	BITB	#SY$DEF,S$YFLG(R0);SYMBOL DEFINED?
	BNE	10$		;IF NE YES-BYPASS
	BITB	#SY$WK,S$YFLG(R0)	;WEAK DEFINITION?
	BNE	10$		;IF NE YES -BYPASS
	MOV	S$YM(R0),LCLSYM	;GET SYMBOL NAME
	MOV	S$YM+2(R0),LCLSYM+2;
	CMP	#^R$MA,LCLSYM	; MAYBE INCOMPATIBLE SYSLIB?
	BNE	10$		; IF NE, NO WAY
	CMP	LCLSYM+2,#^RFKS	; $MAFKS?
	BNE	410$		; NO
	JMP	416$		; ERROR
410$:	CMP	LCLSYM+2,#^RFKR	; $MAFKR?
	BNE	411$		; NO
	JMP	416$		; ERROR
411$:	CMP	LCLSYM+2,#^RFKC	; $MAFKC?
	BNE	412$		; NO
	JMP	416$		; ERROR
412$:	CMP	LCLSYM+2,#^RFDS	; $MAFDS?
	BNE	413$		; NO
	JMP	416$		; ERROR
413$:	CMP	LCLSYM+2,#^RFDS	; $MAFDS?
	BNE	414$		; NO
	JMP	416$		; ERROR
414$:	CMP	LCLSYM+2,#^RFDR	; $MAFDR?
	BNE	415$		; NO
	JMP	416$		; ERROR
415$:	CMP	LCLSYM+2,#^RFDC	; $MAFDC?
	BNE	10$		; NO
416$:
	MOV	(PC)+,R1	;
	.BYTE	E$R110,S$V2	;FATAL-NO RETURN
	CALL	$ERMSG		;OUTPUT ERROR MESSAGE

100$:	MOV	$RTSEG,R1	;GET VIRTUAL ADDRESS OF ROOT SEGMENT
	CALL	$UNLPG		;UNLOCK VIRT MEM PAGE FOR ROOT SEG DESCRIPTOR

105$:	RETURN

	.END
