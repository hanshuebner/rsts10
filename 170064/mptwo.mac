	.TITLE	MPTWO
	.IDENT	/06.04/
;
; COPYRIGHT (c)	1983 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE IS FURNISHED  UNDER A LICENSE AND MAY BE USED OR
; COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;
; D. N. CUTLER/C. MONIA 25-JAN-74/ J.A. KASSON 20-APR-76
;
; Previously Modified By:
;
;	J. A. Kasson
;	C. B. Petrovic
;	E. Pollack
;	J. M. Salman
;
; Modified By:
;
;	T. Lekas	 6-May-83	06.04
;		TL292		Use the system default page length
;				if there is one.
;
;


;
; LOCAL DATA
;

	IMPURE			; READ/WRITE D-SPACE

LEFT:	.BLKW	1	;NUMBER OF SYMBOLS LEFT TO BE OUTPUT
NSPC:			;NUMBER OF SYMBOLS PER COLUNM
STRTE:	.BLKW	1	;START OF SECTION CONTRIBUTOR
CRSEC:	.BLKW	1	;CURRENT SECTION
CSLTH:	.BLKW	1	;LENGTH OF CURRENT SECTION
CSBSE:	.BLKW	1	;BASE ADDRESS OF CURRENT SECTION
NSPP:	.BLKW	1	;NUMBER OF SYMBOLS PER PAGE
T1:	.BLKW	1
T2:	.BLKW	1
T3:	.BLKW	1
CCNTBL:	.BLKW	7.	;COLUNM COUNT TABLE
CPTR:	.BLKW	21.	;TOP OF COLUNM SYMBOL POINTER


; LOCAL MACRO
;
;+


	.PSECT	STB1$D,RO,D,GBL
;+
; GNATR- CREATES TABLE CONTAINING LENGTH OF ATTRIBUTE
;	 TEXT, ATTRIBUTE SWITCH, AND TEXT FOR ATTRIBTES.
;
;	A=ATTRIBUTE SWITCH
;	B=ATTRIBUTE'S TEXT FOR FLAG =1
;	C=ATTRIBUTE'S TEXT FOR FLAG =0
;
;

	.MACRO	GNATR	$A,$B,$C
	.NCHR	$B'$C,<$B>
	.WORD	$B'$C
	.WORD	$A
$'$B:	.ASCII	/$B,/
.=$'$B+4
$'$C:	.ASCII	/$C,/
.=$'$C+4
	.ENDM

PSARG:		;ATTRIBUTE SWITCH VECTOR
	GNATR	CS$ACC,RO,RW
	GNATR	CS$TYP,D,I
	GNATR	CS$GBL,GBL,LCL
	GNATR	CS$REL,REL,ABS
	GNATR	CS$ALO,OVR,CON
	GNATR	CS$ROT*400,SAV,$$$
PSARGN=<.-PSARG>/12.	;NUMBER OF ATTRIBUTES
	.NLIST	BEX		;TO SAVE SOME TREE SOMEWHERE
	.PSECT	MTX2$D,RO,D,GBL

	.ENABLE LC
FMT1:	.ASCIZ	/%N*** Root segment: %2R%3N/;
FMT2:	.ASCIZ	/*** Segment: %2R%3N/;
FMT3:	.ASCIZ	/R-O mem  limits: %P %P %P %U.%N/
FMT3A:	.ASCII	/R-O mem  limits: %P %P %P %U. I-Space%N/
	.ASCIZ	/%17S%P %P %P %U. D-Space%2N/
FMT4:	.ASCIZ	*R/W mem  limits: %P %P %P %U.%N*;
FMT4A:	.ASCII	*R/W mem  limits: %P %P %P %U. I-Space%N*
	.ASCIZ	/%17S%P %P %P %U. D-Space%2N/
FMT5:	.ASCIZ	/Disk blk limits: %P %P %P %U.%N/;
FMT5A:	.ASCII	/Disk blk limits: %P %P %P %U. I-Space%N/
	.ASCIZ	/%17S%P %P %P %U. D-Space%N/
FMT32:	.ASCIZ	/%2NMemory allocation synopsis:%2N/;
FMT52:	.ASCIZ	/Section%44STitle  Ident  File%N/
FMT53:	.ASCIZ	/-------%44S-----  -----  ----%N/
FMT54:	.ASCII	/%2R:(/
	.REPT	PSARGN
	.ASCII	/%VA/
	.ENDR
	.ASCIZ	/ %P %P %U.%N/
FMT55:	.ASCIZ	/%30S%P %P %U. %2R %2R %X%N/
FMT56:	.ASCIZ	/%3NGlobal symbols:%2N/
FMT57:	.ASCIZ	/%F/
FMT100:	.ASCII	/)     /
	.DSABLE LC
	.EVEN
	.LIST	BEX

;+
; **-$MPSEG-MAP SEGMENT
;
; THIS ROUTINE IS CALLED TO WRITE A SEGMENT NAME INTO THE LOAD
; MAP FILE.
;
; INPUTS:
;
;	$CRSEG=ADDRESS OF CURRENT SEGMENT DESCRIPTOR.
;
; OUTPUTS:
;
;	SEGMENT NAME IS WRITTEN INTO THE LOAD MAP FILE.
;-
	PURE.I			; READ-ONLY I-SPACE

$MPSEG::SAVRG			;SAVE NONVOLITILE REGISTERS
	CALL	$MPFSH		;FLUSH SYMBOL BUFFER
	CMP	$NUMSG,#1	;MORE THEN ONE SEGMENT?
	BEQ	5$		;IF EQ YES - DON'T FORCE NEW PAGE
	MOV	$MXLIN,$LNCNT	;Force full page
5$:
	MOV	$CRSEG,R0	;GET ADDRESS OF CURRENT SEGMENT
	MOV	S$GNME(R0),(R2)+;INSERT SEGMENT NAME
	MOV	S$GNME+2(R0),(R2);
	MOV	#FMT2,R1	; GET ADDRESS OF FORMAT
	CMP	$CRVSG,$RTSEG	; CURRENT ROOT?
	BNE	10$		; IF NE NO
	MOV	#FMT1,R1	; GET ALTERNATE FORMAT ADDRESS
	MOV	$OFFST,$BEGRW	; SET BEGINNING OF RW MEMORY
10$:	CALL	$MPOUT		;OUTPUT SEGMENT NAME
	MOV	$CRSEG,R1	; GET ADDRESS OF CURRENT SEGMENT
	BIT	#SG$RO,S$GSTS(R1) ; R-O SEGMENT?
	BNE	20$		; IF NE YES
	MOV	#FMT4,R1	; GET ADDRESS OF FORMAT
	MOV	$BEGRW,(R2)+	;INSERT BEGINNING OF RW AREA
	MOV	$ENDRW,(R2)	;INSERT END OF RW AREA
	CMP	(R2),-2(R2)	;++021 ANY LENGTH ?
	BNE	15$		;++021 IF NE YES
	TST	(R2)+		;++021 POINT TO LENGTH
	CLR	(R2)+		; CLEAR LENGTH
	CLR	(R2)		; ...
	BR	17$		;++021
15$:				;++021
	CALL	$MPEDT		;++021 OUTPUT CORE LIMITS
17$:				;
	BIT	#ID$ATA,$SWTCH	;I/D TASK?
	BEQ	172$		;IF EQ NO
	MOV	#FMT4A,R1	;USE DIFFERENT FORMAT STRING
	TST	(R2)+		;POINT TO NEXT ARGUMENT
	MOV	$BGRWD,(R2)+	;INSERT BEGINNING OF RW D-SPACE
	MOV	$EDRWD,(R2)	;INSERT END OF RW D-SPACE
	CMP	(R2),-2(R2)	;ANY LENGTH?
	BNE	171$		;IF NE YES
	TST	(R2)+		;POINT TO LENGTH
	CLR	(R2)+		;CLEAR LENGTH
	CLR	(R2)		;
	BR	172$		;
171$:
	CALL	$MPEDT		;EDIT SIZE OF RW D-SPACE
172$:
	CALL	$MPOUT		;++021 OUTPUT CORE LIMITS
	CMP	$CRVSG,$RTSEG	; CURRENT ROOT?
	BNE	25$		;IF NE NO
	CMP	$ENDRO,$ENDRW	; ANY RO AREA
	BEQ	25$		;IF EQ NO
20$:
	MOV	$BEGRO,(R2)+	;INSERT BEGINNING OF RO AREA
	MOV	$ENDRO,(R2)	;
	MOV	#FMT3,R1	;GET ADDRESS OF FORMAT
	CALL	$MPEDT		;OUTPUT RO CORE LIMITS
	BIT	#ID$ATA,$SWTCH	;I/D TASK?
	BEQ	22$		;IF EQ NO
	MOV	#FMT3A,R1	;USE DIFFERENT FORMAT STRING
	TST	(R2)+		;POINT TO NEXT ARGUMENT
	MOV	$BGROD,(R2)+	;INSERT BEGINNING OF D-SPACE RO AREA
	MOV	$EDROD,(R2)	;INSERT END OF D-SPACE RO AREA
	CALL	$MPEDT		;EDIT SIZE OF RO D-SPACE
22$:
	CALL	$MPOUT		; OUTPUT LINE
25$:	BIT	#TS$KF,$SWTCH	;TASK IMAGE FILE SPECIFIED?
	BEQ	100$		;IF EQ NO
	MOV	$CRSEG,R1	; GET REAL ADDRESS OF CURRENT SEGMENT
	BITB	#SG$DSK,S$GSTS(R1) ; SEGMENT HAVE DISK ALLOCATION?
	BNE	100$		; IF NE NO
	BIT	#SG$RO,S$GSTS(R1) ; IS THE SEGMENT R/O?
	BEQ	251$		; IF EQ, NO...
	MOV	S$GBRO(R1),(R2) ; INSERT STARTING R/O BLOCK NUMBER
	MOV	(R2)+,(R2)	; COPY STARTING BLOCK
	MOV	S$GRO(R1),R0	; GET LENGTH
	BR	252$
251$:
	MOV	S$GBLK(R1),(R2)	;INSERT STARTING DISK BLOCK NUMBER
	MOV	(R2)+,(R2)	;COPY BLOCK NUMBER
	MOV	S$GLNG(R1),R0	;GET LENGTH
252$:
	CLC			;CLEAR CARRY FOR DIVIDE BY 2
	BNE	27$		;++021 IF NE SEGMENT HAS LENGTH
	TST	(R2)+		;++021 POINT TO LENGTH
	CLR	(R2)+		; CLEAR LENGTH
	CLR	(R2)		;
	BR	28$		;++021 OUTPUT DISK BLOCK LIMITS
27$:				;++021
	ROR	R0		;CONVERT LENGTH TO WORDS
	ADD	#377,R0		;ROUND TO NEXT BLOCK
	CLRB	R0		;CLEAR LOW BYTE
	SWAB	R0		;DIVIDE BY 256. WORDS
	DEC	R0		;BACK OFF BY ONE
	ADD	R0,(R2)		;CALCULATE ENDING BLOCK NUMBER
	CALL	$MPEDT		;CALC LENGTH
28$:				;
	MOV	#FMT5,R1	;GET ADDRESS OF FORAMT
	BIT	#ID$ATA,$SWTCH	;I/D TASK?
	BEQ	283$		;IF EQ NO
	MOV	$CRSEG,R1	;GET REAL ADDRESS OF CURRENT SEGMENT
	TST	(R2)+		;POINT TO NEXT ARGUMENT
	BIT	#SG$RO,S$GSTS(R1) ; IS THE SEGMENT R/O?
	BEQ	2811$		; IF EQ, NO...
	MOV	S$GBOD(R1),(R2) ; INSERT STARTING R/O BLOCK NUMBER
	MOV	(R2)+,(R2)	; COPY STARTING BLOCK
	MOV	S$GROD(R1),R0	; GET LENGTH
	BR	2812$
2811$:
	MOV	S$GDBK(R1),(R2)	;INSERT STARTING DISK BLK # FOR D-SPACE
	MOV	(R2)+,(R2)	;COPY BLOCK NUMBER
	MOV	S$GDLN(R1),R0	;GET LENGTH OF D-SPACE
2812$:
	CLC			;CLEAR CARRY FOR DIVIDE BY 2
	BNE	281$		;IF NE D-SPACE HAS LENGTH
	TST	(R2)+		;POINT TO LENGTH
	CLR	(R2)+		;CLEAR LENGTH
	CLR	(R2)		;
	BR	282$		;OUTPUT DISK BLOCK LIMITS
281$:
	ROR	R0		;CONVERT LENGTH TO WORDS
	ADD	#377,R0		;ROUND TO NEXT BLOCK
	CLRB	R0		;CLEAR LOW BYTE
	SWAB	R0		;DIVIDE BY 256. WORDS
	DEC	R0		;BACK OFF BY ONE
	ADD	R0,(R2)		;CALCULATE ENDING BLOCK NUMBER
	CALL	$MPEDT		;CALCULATE LENGTH
282$:
	MOV	#FMT5A,R1	;GET FORMAT STRING
283$:
	CALL	$MPOUT		;OUTPUT
100$:	MOV	#FMT32,R1	;GET ADDRESS OF FORMAT
	CALL	$MPOUT		;OUTPUT SYNOPSIS HEADING
	MOV	#FMT52,R1
	CALL	$MPOUT		;OUTPUT HEADING
	MOV	#FMT53,R1
	CALL	$MPOUT		;UNDERSCORING
	MOV	$CRSEG,R0	;GET ADDRESS OF CURRENT SEGMENT
	BIT	#SE$QA,$SWTCH	;SEQUENCE ALLOCATION?
	BEQ	105$		;IF EQ NO
	ADD	#S$GSEQ,R0	;POINT TO SEQUENCE LISTHEAD
	MOV	R0,-(SP)	;SET ADDRESS OF FIRST LINK WORD
	BR	110$		;
105$:	ADD	#S$GCST,R0	;POINT TO SECTION TABLE
	MOV	#$ISED,-(SP)	;SET ADDRESS OF SYMBOL EDIT ROUTINE
110$:	BIT	#SE$QA,$SWTCH	;SEQUENCE ALLOCATION?
	BEQ	120$		;IF EQ NO
	MOV	@(SP)+,R0	;GET ADDRESS OF NEXT ENTRY
	BEQ	165$		;IF EQ DONE
	MOV	R0,-(SP)	;SET ADDRESS OF NEXT LINK WORD
	MOV	2(R0),R1	; GET VA OF SECTION TABLE ENTRY
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	BR	125$	;
120$:	CALL	@(SP)+		;GET NEXT SYMBOL
	BCS	165$		;IF CS DONE
125$:
	BITB	#CS$IND,C$SFLG(R0)	;INDIRECT REFERECE?
	BEQ	130$		;IF EQ NO
	MOV	C$SBSE(R0),R1	;POINTER TO DEFINITION
	CALL	$CVRL		;CONVERT TO REAL
130$:	MOV	#$SYMBF,R2	;GET ADDRESS OF SYMBOL BUFFER
	CALL	$MPCHK		;CHECK SECTION NAME
	CMP	-4(R2),$ABSNM	;ABS SECTION?
	BEQ	110$		;IN EQ YES - IGNORE
	CALL	MPCSA		;INSERT PSECT'S ATTRIBUTES
	MOV	R1,CRSEC	;SAVE VIRT ADDRESS OF CURRENT SECTION
	MOV	C$SBSE(R0),(R2) ;SET BASE ADDRESS OF SECTION
	MOV	(R2)+,CSBSE	;SAVE BASE ADDRESS OF SECTION
	MOV	C$SFLG(R0),R1	;GET FLAGS
	MOV	R1,T2		;SAVE FLAGS
	BITB	#CS$REL,R1	;ABS SECTION?
	BEQ	135$		; IF EQ YES
	BIT	#<CS$VSC!CS$VAS*400!CS$LIB>,R1 ; LIBRARY OR VIRTUAL SECTION?
	BNE	135$		;IF NE YES
	ADD	$OFFST,-2(R2)	;ADD IN OFFSET
135$:
	MOV	C$SCUR(R0),STRTE ;SAVE BASE ADDRESS
	MOV	C$SLTH(R0),(R2)	;SET LENGTH OF SECTION
	MOV	(R2),CSLTH	;SAVE LENGTH OF SECTION
	MOV	(R2)+,(R2)+	;COPY LENGTH
	MOV	#FMT54,R1	;GET ADDRESS OF FORMAT
	CLR	T1		;T1 IS USE TO FLAG BLANK SECTION
	TST	S$YM(R0)	; BLANK SECTION?
	BNE	140$		; IF NE NO
	INCB	T1		; SET - INDICATING BLANK SECTION
140$:
	BITB	#<CS$LIB!CS$ALO>,C$SFLG(R0) ; LIBRARY OR OVR?
	BNE	144$		;IF EQ NO
	BITB	#CS$REL,C$SFLG(R0);ABS SECTION?
	BNE	145$		;IF NE NO
144$:
	INCB	T1+1		; SET -FLAG OVR OR LIB
145$:
	CALL	$MPOUT		;OUTPUT SECTION INFO
	MOV	#$STELM,-(SP)	;STEP THRU ELEMENTS
150$:	CALL	@(SP)+
	BCS	160$		;IS C SET NO MORE ELEMENTS
	MOV	$CRELM,R0	;ADDRESS OF ELEMENT TABLE
	CALL	MPCTB		;FIND & PRINT CONTRIBUTION
	BR	150$		;GET NEXT ELEMENT
160$:
	MOV	CRSEC,R1	;GET VIRTUAL ADDRESS OF SECTION
	CALL	$CVRL		;CONVERT TO REAL
	CALL	$WRMPG		; WRITE MARK PAGE
	MOV	STRTE,C$SLGS(R0)	;CALCULATE LENGTH
	SUB	C$SCUR(R0),C$SLGS(R0)	; OF SECTION CONTRIBUTIONS
	MOV	STRTE,C$SCUR(R0)	; NEW CURRENT BASE
	BR	110$
165$:
	CALL	MPGBL
	RETURN


;+
;
; MPCSA -INSERT CONTROL SECTION ATTRIBUTES
;
;-
MPCSA:	SAVRG
	MOV	#PSARG,R5	;ATTRIBUTE VECTOR
	MOV	#PSARGN,R4	;NUMBER OF ATTRIBUTES
10$:
	MOV	(R5)+,(R2)	;LENGTH OF TEXT
	INC	(R2)+		;INCREMENT LENGTH
	CLR	(R2)
	BIT	(R5)+,C$SFLG(R0);ATTRIBUTE FLAG SET?
	BNE	15$
	MOV	#4,(R2)		;GET ADDRESS OF TEXT FOR FLAG =0
15$:	ADD	R5,(R2)+	;GET ADDRESS OF TEXT FOR FLAG =1
	CMP	(R5)+,(R5)+	;MOVE TO NEXT ENTRY
	CMP	(R5)+,(R5)+
	SOB	R4,10$		;MORE?
	CMP	#"$$,@-2(R2)	; WAS LAST ATTRIBUTE THE 'NO-SAVE' BIT?
	BNE	20$		; IF NE, NO
	DEC	-10(R2)		; DO AWAY WITH LAST COMMA
	MOV	#FMT100,-2(R2)	; REPLACE THE ADDRESS OF THE 'NO-SAVE' ARGUMENT
	INC	-4(R2)		; UPDATE THE CHARACTER COUNT
	RETURN			; AND LEAVE HERE...
20$:
	MOV	-2(R2),R4	; COPY THE OUTPUT BUFFER POINTER
	MOVB	#'),3(R4)	; AND REPLACE THE COMMA WITH THE ')' CHARACTER
	RETURN

;
; MPCTB-FIND CONTRIBUTORS TO SECTION
;

MPCTB:
	SAVRG
	MOV	E$LNUM(R0),R5	;SAVE NUM OF SECTS IN MAPPING TABLE
	BMI	25$		;IF MI	MAPPINF TABLE HAS NO ENRIES
	INC	R5		;INCR. NUMBER OF ENTRIES
	MOV	E$LCMT(R0),R3	;REAL ADDRESS OF MAPPING TABLE
10$:
	MOV	#$SYMBF,R2	;ADDRESS OF ARGUMENT POINTER
	CMP	(R3)+,CRSEC	;MAP ENTRY FOR CURRENT SECTION
	BNE	20$		;IF NE NO
	MOV	STRTE,(R2)+	;INSERT START OF CONTRIBUTION
	MOV	T2,R1		;GET SECTION FLAGS
	BITB	#CS$REL,R1	;ABS. SECTION?
	BEQ	12$		;IF EQ YES
	BIT	#<CS$VAS*400!CS$LIB>,R1  ; LIBRARY OR VIRTUAL ARRAY?
	BNE	12$		;IF NE YES
	BIT	#CS$VSC*400,R1	; VIRTUAL SECTION?
	BEQ	11$		; IF EQ NO

	.IF DF	V1145

	CLR	R0		; CLEAR HIGH PART OF LENGTH
	MOV	-(R2),R1	; GET STARTING ADDRESS
	DIV	CSLTH,R0	; REDUCE STARTING ADDRESS TO MODULUS OF LENGTH

	.IFF

	MOV	-(R2),R0	; GET STARTING ADDRESS
	MOV	CSLTH,R1	; GET LENGTH
	CALL	$DIV		; REDUCE STARTING ADDRESS TO MODULUS OF LENGTH

	.ENDC

	ADD	CSBSE,R1	; BIAS BY BASE ADDRESS
	MOV	R1,(R2)+	; SET BASE OF CONTRIBUTION
	BR	12$		;
11$:				;
	ADD	$OFFST,-2(R2)	; INCLUDE OFFSET
12$:
	MOV	(R3),(R2)	;INSERT LENGTH
	TSTB	T1		;BLANK SECTION?
	BEQ	15$		;IF EQ	NO
	TST	(R3)		;BLANK SECTION -LENGTH ZERO?
	BEQ	20$		;IF EQ YES S- SKIP
15$:
	MOV	(R2)+,(R2)+	;COPY LENGTH
	TSTB	T1+1		; CONCATINATED SECTION?
	BNE	150$		; IF NE NO
	ADD	(R3),STRTE	;START OF NEXT CONTRBUTION
150$:
	MOV	$CRELM,R0	; GET ADDRESS OF CURRENT ELEMENT
	BIT	#SW$MA,E$LSWT(R0)	; EXCLUDE MODULE?
	BNE	20$			;IF NE YES
	MOV	E$LMOD(R0),(R2)+	;INSERT TITLE
	MOV	E$LMOD+2(R0),(R2)+
	MOV	E$LIDT(R0),(R2)+;INSERT IDENT
	MOV	E$LIDT+2(R0),(R2)+
	MOV	$INPPT,R1	;GET INPUT FILE RECORD BLK
	CALL	$MPFLE		;SET UP FILENAME
	MOV	#FMT55,R1	; GET ADDRESS OF FORMAT
	CALL	$MPOUT		; OUTPUT CONTRIBUTOR
20$:
	TST	(R3)+		;MOVE TO NEXT MAPPING ENTRY
	DEC	R5		;MORE MAPPING ENTRIES?
	BNE	10$		;IF NE YES
25$:
	RETURN

;+
; MPGBL- OUTPUTS GOBAL SYMBOLS FOR A SEGMENT
;
;-

MPGBL:
	SAVRG			;SAVE NON-VOLITILE REGISTERS
	MOV	$CRSEG,R0	;REAL ADDRESS OFCURRENT SEGMENT
	MOV	S$GNTB(R0),LEFT	;NO. OF SYMBOLS
	BEQ	100$		;IF EQ	NONE
	MOV	R0,-(SP)	;SAVE R0
	MOV	$MXLIN,-(SP)	;Compute the page size
	SUB	#5,(SP)		;Less 5 lines
	CMP	$LNCNT,(SP)+	;Five lines left on the page?
	BMI	10$		;IF MI NO
	MOV	$MXLIN,$LNCNT	;Force form feed
10$:
	MOV 	#FMT56,R1	;OUTPUT SYMBOL TABLE HEADER
	CALL 	$MPOUT
	MOV	(SP)+,R0	;RESTORE R0
	ADD	#S$GSTB,R0	;SYMBOL LISTHEAD ADDRESS
	MOV	#$ISED,-(SP)	;SET ADDRESS OF SYMBOL EDIT ROUTINE
30$:
	CALL	CSOP		;CALC. # OF SYMBOLS ON THIS PAGE
	MOV	NSPP,T1		;NUMBER OF SYMBOLS PER PAGE
	MOV	NSPC,T2		;NUM. OF SYMBOLS PER COLUNM
	MOV	$NCLNM,T3	;NUM. OF COLUNMS
	MOV	#CPTR,R5	;COLUNM POINTER TABLE
	MOV	#CCNTBL,R4		;COLUNM COUNTER TABLE
40$:
	CALL	@(SP)+		;GET SYMBOL
	MOV	(R2),(R5)+	;INSERT LCOUNT
	MOV	2(R2),(R5)+	;NSERT LHEAD
	MOV	R1,(R5)+	;INSERT POINTER TO TOP OF COLUNM
	MOV	T2,(R4)+		;INSERT COLUNM COUNT
	SUB	T2,T1		;PAGE FULL?
	BMI	50$		;IF MI YES
	BR	450$

45$:
	CALL	@(SP)+		;THREAD DOWN SYMBOL TABLE
450$:	CALL	TSTSYM		;TEST SYMBOL FLAGS

	BCS	45$		;IF SET NOT WANTED
	DEC	T2		;END OF LINE?
	BNE	45$		;IF NE NO
	TST	T1		;END OF PAGE?
	BEQ	60$		;IF EQ YES
	MOV	NSPC,T2		;RESTORE COLUNM LENGTH
	BR	40$		;DO NEXT COLUNM
50$:
	ADD	T2,T1		;RESTORE COLUNM LENGTH
	MOV	T1,-2(R4)	;CHANGE LENGTH
60$:
	MOV	#$ISD1,-(SP)	;ADDRESS OF SYMBOL TABLE EDIT
	MOV	NSPP,R4		;NUMBER OF SYMBOLS PER PAGE
65$:

	MOV 	#CPTR,R2
	MOV	#CCNTBL,R5	;ADDRESS OF COLUNM COUNTER TABLE
	MOV	$NCLNM,T1	;NUMBER OF COLUNMS
	MOV	#$SYMBF,R3	;ADDRESS OF PARAMETER STORAGE
70$:
	TST	(R5)		;IS THERE A NEXT SYMBOL?
	BEQ	85$		;IF EQ NO MORE FOR COLUNM
	CALL	@(SP)+		;GET SYMBOL
	BCS	90$		;IF C SET NO MORE
	CALL	TSTSYM		;TEST SYMBOL FLAGS
	BCS	75$		;IF SET DON'T WANT

	MOV	R2,-(SP)	;SAVE CPTR POINTER
	MOV 	R3,R2		;GET SYMBF POINTER ONTO R2
	CALL	$MPSYM		;GET SYMBOL AND INSERT
	MOV	R2,R3		;PUT SYMBF PTR BACK
	MOV	(SP)+,R2	;PUT CPTR BACK
	DEC	(R5)+		;DEC. COUNT OF SYMBOLS IN COLUNM
	BR	80$		;IF NE MORE SYMBOLS IN COLUNM
75$:
	CMP	-(R2),-(R2)
	TST 	-(R2)
	BR	70$
80$:	INC	$MPFLG		;UPDATE MAP BUFFER FLAG
	DEC	R4		;MORE SYMBOLS ON PAGE?
	BEQ	90$		;IF EQ NO
	DEC	T1		;END OF LINE?

	BNE	70$		;IF NE NO
85$:
	CALL	$MPFSH		;END OF LINE
	BR	65$		;DO NEXT LINE
90$:
	CALL	$MPFSH		;END OF PAGE
	INC	(SP)+		;CLEAR STACK
	TST	LEFT		;ANY SYMBOLS LEFT
	BNE	30$		;IF NE YES
	INC	(SP)+
100$:

	RETURN


;
; TSTSYM - TEST SYMBOL FLAG FOR DEFINITION, INDIRECTNESS,AND
;	   EXCLUSION.
;

TSTSYM:
	CLC			;CLEAR CARRY BIT
	BITB	#SY$DEF,S$YFLG(R0)	;DEFINITION?
	BEQ	10$		;IF EQ NO
	BITB	#SY$IND,S$YFLG(R0)	;INDIRECT?
	BNE	10$		;IF NE YES
	BITB	#SY$EXC,S$YFLG+1(R0)	;EXCLUDE FLAG SET
	BEQ	20$		;IF NE YES
10$:	SEC			;SET C - SYMBOL NOT WANTED
20$:	RETURN
;
;
;
; CSOP- CALCULATE NUMBER OF SYMBOLS ON CURRENT PAGE
;

CSOP:
	SAVRG			;SAVE NON0VOLATILE REGISTERS
	MOV	$MXLIN,R4	;Lines on a page
	SUB	$LNCNT,R4	;LINES REMAINING ON PAGE
	BNE	5$		;IF EQ PREVIOUS PAGE NOT FULL
	MOV	$MXLIN,R4	;New page
	SUB	#5,R4		;...
5$:
	CLR	R2
	MOV	$NCLNM,R1
10$:	ADD	R4,R2
	SOB	R1,10$
	MOV	R2,NSPP		;NUMBER OF SYMBOLS ON THIS PGE
15$:
	MOV	LEFT,R3		;GET NUMBER OF SYMBOLS LEFT
	SUB	R2,R3		; # LEFT - #PER PAGE
	BMI	20$		; IF MI LESS THEN A PAGE LEFT
	MOV	R4,NSPC		;NO. OF SYMBOLS PER COLUNM
	BR	45$
20$:
	MOV	LEFT,NSPP	;NO. ON THIS PAGE IS ONLY WHATS LEFT
	CLR	R3		;ZERO WHAT'S LEFT
25$:
	CLR	R2
	MOV	NSPP,R1		;NUMBER OF SYMBOLS PER COLUNM =

30$:	SUB	$NCLNM,R1	;# SYMBOLS / # COLUNMS
	BEQ	35$		;IF EQ	DIVIDE IS OVER
	BMI	35$		;IF MI	REMAINDER
	INC	R2		;
	BR	30$		;CONTINUE DIVIDE
35$:
	INC	R2		;ROUND UP IF REMAIDER
40$:
	MOV	R2,NSPC	;SAVE NO. OF SYMBOLS PER COLUNM
45$:	MOV	R3,LEFT		;SAVE LEFTOVER
	RETURN

	.END
