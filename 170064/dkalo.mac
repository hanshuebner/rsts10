	.TITLE	DKALO
	.IDENT	/17.04/
;
; COPYRIGHT (c)	1991 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE IS FURNISHED  UNDER A LICENSE AND MAY BE USED OR
; COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;
; D. N. CUTLER/C. MONIA	21-JAN-74
;
; MODIFIED FOR RSX-11M/M-PLUS V4.0/V2.0 BY:
;
;	J. A. KASSON
;	C. B. PETROVIC
;
; MODIFIED BY:
;
;	C. B. PETROVIC	26-FEB-82	17.01
;		CBP039		ADD CORRECT .PSECT DEFINITIONS TO
;				ALLOW TKB TO BE LINKED AS AN I/D TASK.
;
;
;	C. B. PETROVIC	7-JUN-82	17.02
;		CBP051		ADD AUTOLOAD SUPPORT FOR USER-MODE
;				I/D TASKS.
;
;	L. M. PETERSON	30-MAY-89	17.03
;		LMP131		ALLOW TASKS WITH (IN-TASK) MEMORY RESIDENT 
;				OVERLAYS TO BE EXTENDED (WITH $EXTM)
;
;	C. M. KATZ	19-APR-91	17.04
;		CMK001		ADD RSTS CONDITIONAL CODE
;
; MONITOR DEPENDENT ROUTINE TO ALLOCATE DISK SPACE FOR TASK IMAGE
;
; MACRO LIBRARY CALLS
;

	.IF	NDF,R$RSTS
	.MCALL	OFNB$W
	.IFF
	.MCALL	OFNB$T
	.ENDC

;
; LOCAL DATA
;

	IMPURE			; READ/WRITE D-SPACE



	.IF	DF	T$$MP

;
; OUTPUT LOGICAL DISK BLOCK ADDRESS OF TASK IMAGE
;

TSKLM:	.ASCII	/TASK DISK ADDRESS: /
TSKDB:	.ASCII	/000000:000000/
TSKME:
	.EVEN
TSKST:	.BLKW	6		; TASK IMAGE FILE STATISTICS BLOCK

	.ENDC


	PURE.D			; PURE DATA AREA

	.IF DF D$DKAL

;
;
	.PSECT	TRPT$D,RO,D

$TRPH:	.WORD	-1			; phase on which to dump the seg desc.
$TRCSP:	.WORD	0			; Current structure real memory address
$TRLST:					; reference label

	TRC	S$GBLK,^/%NS$GBLK - %P%N/
	TRC	S$GBRO,^/S$GBRO - %P%N/
	TRC	S$GBWD,^/S$GBWD - %P%N/
	TRC	S$GBOD,^/S$GBOD - %P%N/
	TRC	S$GLDA,^/S$GLDA - %P%N/
	TRC	S$GLNG,^/S$GLNG - %P%N/
	TRC	S$GDLD,^/S$GDLD - %P%N/
	TRC	S$GDLN,^/S$GDLN - %P%N/
	TRC	S$GNME,^/S$GNME - %2R%N/
	TRC	S$GWDP,^/S$GWDP - %P%N/
	TRC	S$GDWP,^/S$GDWP - %P%N/
	TRC	S$GRW,^/S$GRWI - %P%N/
	TRC	S$GRO,^/S$GROI - %P%N/
	TRC	S$GRWD,^/S$GRWD - %P%N/
	TRC	S$GROD,^/S$GROD - %P%N/
	TRC	S$GVAD,^/S$GVAD - %P%N/
	TRC	S$GDVA,^/S$GDVA - %P%N/
	TRC	S$GROB,^/S$GROB - %P%N/
	TRC	S$GODB,^/S$GODB - %P%N/
;
	.PSECT	TRPT$D,RO,D
	.WORD	-1			; flag the end of the list

	.ENDC

;+
; **-$DKALO-DISK ALLOCATION
;
; THIS ROUTINE IS CALLED IN PHASE 4 TO ALLOCATE THE DISK SPACE
; FOR THE TASK IMAGE FILE. THE FILE IS ALLOCATED AND A BITMAP
; IS CONSTRUCTED THAT CONTAINS A ONE BIT FOR EACH BLOCK IN THE
; FILE.
;
; INPUTS:
;
;	$RLBLK=HIGHEST RELATIVE BLOCK NUMBER.
;
; OUTPUTS:
;
;	TASK IMAGE FILE IS ALLOCATED AND BITMAP IS CONSTRUCTED.
;-

	PURE.I			; READ-ONLY I-SPACE


$DKALO::BIT	#TS$KF,$SWTCH	;TASK IMAGE FILE SPECIFIED?
	BEQ	50$		;IF EQ NO
	SAVRG			;SAVE NONVOLITILE REGISTERS
	MOV	#$RLBLK,R5	; POINT TO RELATIVE BLOCK
	ADD	$HDRBN,(R5)	; INCLUDE HEADER IN DISK ALLOCATION
	ADD	(R5)+,(R5)	; BIAS R/O DISK ALLOCATION
	MOV	$TSKPT,R0	;GET TASK IMAGE FILE RECORD BLOCK
	MOV	$FSIZI,R4	; GET REQUESTED ALLOCATION
	ADD	$HDRBN,R4	; INCLUDE CHECKPOINT AREA
	CMP	R4,(R5)		; COMPARE AGAINST TRUE DISK ALLOCATION
	BHI	5$		; IF HI ALLOCATE MORE DISK AREA
	MOV	(R5),R4		; ELSE ALLOCATE JUST ENOUGH FOR TASK IMAGE
5$:				;
	MOV	R4,R3		; COPY SIZE OF FILE
	MOV	R4,$FSIZI	;SET FILE SIZE INDICATOR
	SUB	$LBBLK,$FSIZI	; SUBTRACT OUT LABEL BLOCKS

	.IF	DF	T$$MP

	MOV	#TSKST,F.STBK(R0) ; READ STATISTICS ON ACCESS

	.ENDC

6$:				;
	MOV	R$NAME(R0),R2	; POINT TO NAME BLOCK
	MOV	R3,F.CNTG(R0)	; SET SIZE OF FILE TO ALLOCATE
	.IF NDF,R$RSTS
	OFNB$W	R0		; OPEN TASK IMAGE FILE
	.IFF
	OFNB$T	R0
	.ENDC
	BCC	10$		;IF CC OKAY
	NEG	R3		; ALLOCATE NON-CONTIGUOUS FILE
	BMI	6$		; IF MI, RE-TRY OPEN
	MOV	(PC)+,R1	;ALLOCATION FAILURE
	.BYTE	E$R24,S$V0	;DIAGNOSTIC
	CALL	$ERMSG		;OUTPUT ERROR MESSAGE
	BIC	#TS$KF,$SWTCH	;CLEAR TASK IMAGE OPTION BIT
	BR	50$		;VAMOOSA!

10$:	
	.IF	NDF,R$RSTS
	TST	R3		; CONTIGUOUS FILE OPENED?
	.IFF
	BPL	15$		; IF PL YES
	MOV	R2,-(SP)	; SAVE FILENAME POINTER BEFORE CALLING $ERMSG
	MOV	#<S$V0*400!E$R89>,R1 ; REPORT NON-CONTIGUOUS TASK FILE
	CALL	$ERMSG		; ISSUE DIAGNOSTIC
	MOV	(SP)+,R2	; RESTORE FILENAME POINTER
	.ENDC
15$:				; REFERENCE LABEL
	MOV	$TSKNM,R1	; GET TASKIMAGE NAME BLOCK
	BEQ	16$		; IF EQ, THERE'S NONE...
	MOV	R2,-(SP)	; SAVE FILE NAME POINTER
	CALL	$CVRL		; FETCH FROM DYNAMIC MEMORY
	CALL	$WRMPG		; MAKE SURE WE SAVE THIS INFORMATION
	MOV	(SP)+,R2	; RESTORE FILE NAME POINTER...
	ADD	#E$LMND+4,R0	; STEP PAST DEVICE AND UNIT NUMBER..
	MOV	(R2)+,(R0)+	; SAVE FILE NAME
	MOV	(R2)+,(R0)+	; 
	MOV	(R2)+,(R0)+	; 
	MOV	(R2)+,(R0)+	; SAVE FILE TYPE
	MOV	(R2)+,(R0)+	; AND VERSION
16$:

	.IF	DF	V1145

	MOV	R4,R1		; SET LOW PART OF DIVIDEND
	CLR	R0		;CLEAR HIGH PART OF DIVIDEND
	DIV	#8.,R0		;CALCULATE SIZE OF BITMAP

	.IFF

	MOV	R4,R0		; SET DIVIDEND
	MOV	#8.,R1		;SET DIVISOR
	CALL	$DIV		;CALCULATE SIZE OF BITMAP

	.ENDC


	MOV	R1,R5		;SAVE REMAINDER
	BEQ	20$		;IF EQ SIZE IS RIGHT
	INC	R0		;INCREMENT LENGTH OF BITMAP
20$:	MOV	R0,R4		;SAVE SIZE OF BITMAP
	MOV	R0,R1		;SET SIZE OF BLOCK TO ALLOCATE
	CALL	$ALBLK		;ALLOCATE STORAGE
	MOV	R0,$BITMP+2	;SET ADDRESS OF BITMAP
	MOV	R4,$BITMP	;SET SIZE OF BITMAP
30$:	MOVB	#377,(R0)+	;FILL BITMAP WITH ONE BITS
	SOB	R4,30$		;REPEAT
	TST	R5		;ANY REMAINDER?
	BEQ	47$		;IF EQ NO
	MOV	#1,R1		;GET ONE BIT FOR MASK FORMATION


	.IF	DF	V1145

	ASH	R5,R1		;SHIFT INTO PLACE

	.IFF

43$:	DEC	R5		;DECREMENT SHIFT COUNT
	BLT	45$		;IF LT DONE
	ASL	R1		;SHIFT MASK INTO PLACE
	BR	43$		;

	.ENDC


45$:	DEC	R1		;FORM PARTIAL MAP FOR FINAL BYTE
	MOVB	R1,-(R0)	;INSERT FINAL BYTE
47$:				;
	MOV	#DKALO,R0	;GET PHASE CONTROL ROUTINE ADDRESS
	CALL	$PCTRL		;CALL PHASE CONTROL ROUTINE

	.IF	DF	T$$MP

	MOV	#TSKDB,R0	; GET ADDRESS OF OUTPUT TEMPLATE
	MOV	TSKST,R1	; FIRST HALF OF LBN
	MOV	PC,R2		; NO ZERO SURPRESS
	CALL	$CBOMG		; CONVERT
	TSTB	(R0)+		; STEP PAST DELIMITER
	MOV	TSKST+2,R1	; GET SECOND HALF OF DISK ADDRESS
	MOV	PC,R2		; AGAIN, NO ZERO SURPRESS
	CALL	$CBOMG		; CONVERT TO ASCII
	MOV	#TSKLM,R1	; GET BUFFER ADDRESS
	MOV	#<TSKME-TSKLM>,R2 ; BUFFER LENGTH
	CALL	$PUTCO		; OUTPUT TO 'CO'

	.ENDC

	BIT	#ID$ATA,$SWTCH	; IS THIS AN I/D TASKBUILD??
	BEQ	50$		; IF EQ, NO
	ADD	$HDRBN,$DHDRB	; INCLUDE RELATIVE BLK NUMBER OF I HEADER
50$:	RETURN			;

;
; VIRTUAL SEGMENT DESCRIPTOR ADDRESS ASSIGNMENT
;
; THIS ROUTINE IS CALLED FOR EACH SEGMENT IN THE ALLOCATION.
;
; THIS ROUTINE ALSO DOES THE OVERLAY SHIFTS IF /EX WAS SET

DKALO:	
	BIT	#EX$MRT,$SWOV2	; EXTENDING TASK WITH MR OVERLAYS?
	BEQ	9$		; IF EQ, NO 
	CMP	$CRVSG,$RTSEG	; AT ROOT?
	BEQ	9$		; IF EQ, YES - NO CHANGE
	MOV	$CRSEG,R1	; GET REAL ADDRESS OF CURRENT SEGMENT	
	BIT	#SG$RES,S$GSTS(R1) ; MEMORY RESIDENT OVERLAY?
	BEQ	3$		; IF EQ, NO USE VALUES FROM LAST MR SEGMENT
	BIT	#ID$ATA,$SWTCH	; ID TASK?
	BEQ	1$		; IF EQ, NO
	MOV	S$GDWP(R1),R1	; GET ADDRESS OF D-SPACE WINDOW BLOCK
	BR	2$		; CONTINUE
1$:
	MOV	S$GWDP(R1),R1	; GET ADDRESS OF I-SPACE WINDOW BLOCK
2$:
	CALL	$CVRL		; CONVERT TO REAL
	ADD	ADBIAS,W.NBAS(R0) ; SHIFT UP WINDOW BASE ADDRESS
	MOVB	W.NAPR(R0),R2	; GET WINDOW SIZE (64 BYTE BLOCKS)
	ADD	APBIAS,R2	; SHIFT UP WINDOW BASE APR
	MOVB	R2,W.NAPR(R0) ; AND SAVE
	MOV	$CRSEG,R1	;
3$:
	BIT	#ID$ATA,$SWTCH	; ID TASK?
	BEQ	4$		; IF EQ, NO
	ADD	ADBIAS,S$GDLD(R1) ; SHIFT UP ROOT D-SPACE LOAD ADDRESS
	ADD	ADBIAS,S$GODB(R1) ; SHIFT UP ROOT D-SPACE BASE VIRTUAL ADDRESS
	BR	9$		  ; CONTINUE
4$:
	ADD	ADBIAS,S$GLDA(R1) ; SHIFT UP ROOT I-SPACE LOAD ADDRESS
	ADD	ADBIAS,S$GROB(R1) ; SHIFT UP ROOT I-SPACE BASE VIRTUAL ADDRESS
9$:
	MOV	$CRSEG,R0	;GET ADDRESS OF CURRENT SEGMENT
	ADD	$HDRBN,S$GBLK(R0) ; ADD IN RELATIVE BLK. NUMBER OF HEADER
	ADD	$RLBLK,S$GBLK+2(R0) ; ADD IN MAX R-W DISK BLOCK
	BIT	#ID$ATA,$SWTCH	; WE BUILDING AN I/D TASK??
	BEQ	10$		; IF EQ, NO...CONVENTIONAL
	ADD	$HDRBN,S$GBWD(R0) ; ADD IN RELATIVE BLK NUMBER OF HEADER
	ADD	$RLBLK,S$GBWD+2(R0) ; ADD IN MAX R/W DISK BLOCKS
10$:

	.IF DF D$DKAL

	MOV	R0,-(SP)	; SAVE R0
	MOV	$PHASE,$TRPH	; COPY THE PHASE NUMBER
	MOV	$CRSEG,$TRCSP	; COPY THE CURRENT SEGMENT REAL MEMORY ADDRESS
	MOV	#$TRLST,R0	; POINT TO THE LIST
	CALL	$TRACE		; AND DUMP IT TO TI:
	MOV	(SP)+,R0	; RESTORE R0 BEFORE EXITING...

	.ENDC

	MOV	$CRVSG,R1	; GET VIRTUAL ADDRESS OF CURRENT SEGMENT
	CALLR	$WRMPG		; WRITE-MARK PAGE

	.END
