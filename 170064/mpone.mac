	.TITLE	MPONE
	.IDENT	/07.05/
;
; COPYRIGHT (c)	1983,1991 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE IS FURNISHED  UNDER A LICENSE AND MAY BE USED OR
; COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;
; D. N. CUTLER/C. MONIA 25-JAN-74/ J.A. KASSON 20-APR-76
;
; MODIFIED FOR RSX-11M/M-PLUS V4.0/V2.0 BY:
;
;	J. A. KASSON
;	E. POLLACK
;	C. B. PETROVIC
;	J. M. LAWLER
;
; MODIFIED BY:
;
;	C. B. PETROVIC	26-FEB-82	07.01
;		CBP039		ADD CORRECT .PSECT DEFINITIONS TO
;				ALLOW TKB TO BE LINKED AS AN I/D TASK.
;
;	C. B. PETROVIC	12-APR-82	07.02
;		CBP047		ADD CHECK IN OVERLAY DESCRIPTOR OUTPUT
;				TO PREVENT LEVEL FROM RUNNING OFF 132.
;				COLUMN PRINTER AND CAUSING OUTPUT DATA
;				TO OVERWRITE CRITICAL STORAGE REGIONS IN
;				THE TKB'S IMPURE AREA IN THE ROOT. THIS IS
;				DONE IN RESPONSE TO VMS FIELD TEST 2 Q266.
;
;	C. B. PETROVIC	04-OCT-82	07.03
;		CBP059		MODIFY MAP PROCESSOR TO REFLECT AN I/D
;				TASK MEMORY MAP.
;
;	C. B. PETROVIC	08-MAR-83	07.04
;		CBP079		CORRECT OVERLAY DESCRIPTOR PROCESSOR TO
;				PRESENT CORRECT SEGMENT LENGTHS IF A SEGMENT
;				CONTAINS ONLY R/O CODE OR DATA.
;
;	C. M. KATZ	19-APR-91	07.05
;		CMK001		ADD RSTS CONDITIONAL CODE
;

	.MCALL	GTIM$S

;
; LOCAL MACROS
;
;+
; GNSWT - CREATES TABLE OF TASK SWITCH OPTIONS AND
;	  CORRESPONDING TEXT
;
;	A= OPTION SWITCH
;	B=SWITCH NUEMONIC
;	C=SWITCH FLAG VALUE WHEN TRUE
;
;

	.MACRO GNSWT	A,B,C
	.WORD	A
	.ASCII	/-B,/
	.WORD	C
	.ENDM



	.PSECT	STBL$D,RO,D,GBL
OPSW:			;SWITCH OPTION VECTOR

	.IF	NDF	R$$11M

	GNSWT	SW$FP,FP,1
	GNSWT	SW$AB,AB,0
	GNSWT	SW$CP,CP,0
	GNSWT	SW$DS,DS,0
	GNSWT	SW$FX,FX,0
	GNSWT	SW$DA,DA,1
	GNSWT	SW$PI,PI,1
	GNSWT	SW$PR,PR,1
	GNSWT	SW$TR,TR,1

	.IFF

	GNSWT	SW$AC,AC,1
	GNSWT	SW$ALO,AL,0
	GNSWT	SW$CM,CM,1
	GNSWT	SW$CP,CP,0
	GNSWT	SW$DA,DA,1
	GNSWT	SW$EA,EA,1
	GNSWT	SW$FP,FP,1
	GNSWT	SW$NH,HD,0
	GNSWT	SW$PI,PI,1
	GNSWT	SW$PM,PM,1
	GNSWT	SW$PR,PR,1
	GNSWT	SW$NS,SE,0
	GNSWT	SW$SL,SL,1
	GNSWT	SW$TR,TR,1
	GNSWT	SW$MU,MU,1
;
; *NOTE WELL* THIS TABLE REPRESENTS AN INTERSECTION OF 3 WORDS OF
; OF SWITCH VALUES : $SWOVR,$SWTCH, $INIPT+R$SWTH.  UNFORTUNATELY,
; THE INTERSECTION MUST PRODUCE 16 UNIQUE BIT VALUE POSITIONS.
; STILL FURTHER, THIS TABLE IS ORDERED BY THESE BIT POSITIONS.
; THE ID$ATA BIT VALUE WAS A '1', BUT HAD TO BE CHANGED TO IMPLEMENT
; /-XH.  SINCE WE CAN'T BACK THIS CHANGE OUT, WE WILL KLUDGE HERE.
;

	GNSWT	1,ID,1

	.ENDC

OPSWN=<.-OPSW>/8.		;NUMBER OF OPTIONS


	.PSECT	MTX1$D,RO,D,GBL

	.NLIST BEX
	.ENABLE LC
FMT6:	.ASCIZ	/ODT xfr address: %P%N/;
FMT7:	.ASCIZ	/PRG xfr address: %P%N/;
FMT20:	.ASCIZ	/Stack    limits: %P %P %P %U.%N/;
FMT23:	.ASCIZ	/Identification : %2R%N/;
FMT24:	.ASCII	/Task attributes: /
	.REPT	OPSWN
	.ASCII	/%VA/
	.ENDR
	.ASCIZ	/%N/
FMT42:	.ASCIZ	/Task address limits: %P %P%N/
FMT42A:
	.ASCII	/Task Address limits: %P %P I-Space%N/ 
	.ASCIZ	/                     %P %P D-Space%N/
FMT43:	.ASCIZ	/Total  task  size  : %T. Words%N/
FMT43A:
	.ASCII	/Total  task  size  : %T. words, I-Space%N/
	.ASCIZ	/                     %T. words, D-Space%N/
FMT51:	.ASCIZ	/Partition name : %2R%N/
FMT47:	.ASCIZ	/%P  %P  %P  %U.  %VS%2R%N/
FMT47A:
	.ASCII	/%P  %P  %P  %U. I  %VS%2R%N/
	.ASCIZ	/%P  %P  %P  %U. D%2N/
FMT48:	.ASCIZ	/%4N%X Overlay description:%2N/
FMT49:	.ASCIZ	/----    ---        ------%N/
FMT50:	.ASCIZ	/Base    Top        Length%N/
	.IF	DF,R$RSTS
FMT53:	.ASCIZ	/Task  PPN      : [%D,%D]%N/
	.IFF
FMT53:	.ASCIZ	/Task  UIC      : [%O,%O]%N/
	.ENDC
FMT54:	.ASCIZ	/Task    name   : %2R%N/
FMT55:	.ASCIZ	/Task  priority : %M.%N/
FMT56:	.ASCIZ	/Mapped  array  area: %T. words%N/
FMT57:	.ASCIZ	/Task   extension   : %T. words%N/
FMT60:	.ASCIZ	/Total address windows: %M.%N/
FMT61:	.ASCIZ	/Task  image  size  : %T. words%N/
FMT61A:
	.ASCII	/Task  image  size  : %T. words, I-Space%N/
	.ASCIZ	/                     %T. words, D-Space%N/
FMT62:	.ASCIZ	/R-W disk blk limits: %P %P %P %U.%N/;
FMT63:	.ASCIZ	/R-O disk blk limits: %P %P %P %U.%N/;
BLANK:	.ASCIZ	/ /
	.DSABLE LC


	.EVEN


	IMPURE			; READ/WRITE D-SPACE

;	LOCAL DATA
;
TEMP:	.BLKW	2	;TEMPORARY USED TO CALC LENGTHS
TEMP0:	.BLKW	2		; TEMPORARY D-SPACE CALCULATION AREA
TOTAL:	.BLKW	2	;TOTAL STORAGE
TOTAL0:	.BLKW	2		; TOTAL D-SPACE STORAGE
TAB:	.BLKW	1		;INDENT SPACES PER LEVEL
IDENT:	.BLKW	1		;TOTAL INDENT FOR A LEVEL
ELSWT:	.BLKW	1	; TEMPORARY ELEMENT SWITCH WORD

;;+
; **-$MPHDG-MAP HEADING
;
; THIS ROUTINE IS CALLED TO WRITE A HEADING INTO THE LOAD MAP FILE
;
; INPUTS:
;
;	$TSKPT=ADDRESS OF TASK IMAGE FILE RECORD BLOCK.
;
; OUTPUTS:

;	MAP HEADING IS WRITTEN INTO THE LOAD MAP FILE.
	PURE.I			; READ-ONLY I-SPACE

$MPHDG::
	SAVRG			;SAVE NON-VOLATILE REGISTERS
	MOV	#$TITLE,R2	;GET ADDRESS OF TITLE BUFFER
	CALL	MPTSK		;SETUP TASK NAME
	MOV	$VERSN,(R2)+	;INSERT VERSION OF TKB
	MOV	$VERSN+2,(R2)+	;
	MOV	#1,(R2)+	;START PAGE COUNT
	CLR	(R2)+		;INSERT BLANKS FOR SEGMENT NAME
	CLR	(R2)+		;
	MOV	R2,R3
	GTIM$S	R3		;GET TIME PARAMETERS
	MOV	#$FMT16,R1	;GET ADDRESS OF TITLE FORMAT
	MOV	#$TITLE,R2	;GET ADDRESS OF TITLE BUFFER
	CALL	$MPOT1		;PRINT TITLE
	MOV	#$TNAME,R2	;ADDRESS OF TASK NAME
	TST	(R2)		;TASK NAME SPECIFIED?
	BEQ	10$		;IF EQ NO - DO PAR NAME
	MOV	#FMT54,R1	;ADDRESS OF FORMAT
	CALL	$MPOT1		;PRINT
10$:
	MOV	#$PNAME,R2	;GET ADDRESS OF PARITION NAME
	MOV	#FMT51,R1	;GET ADDRESS OF FORMAT
	CALL	$MPOT1		;OUTPUT PARTITION NAME
	MOV	#$IDENT,R2	;GET ADDR OF PROGRAM IDENTIFICATION
	MOV	#FMT23,R1	;GET ADDRESS OF FORMAT
	CALL	$MPOT1		;OUTPUT PRG IDENTIFICATION
	MOVB	$TKUIC+1,(R2)+	;GET GROUP CODE
	CLRB	(R2)+		;CLEAR HIGH BYTE OF CODE
	MOVB	$TKUIC,(R2)+	;GET PROGRAMMER CODE
	CLRB	(R2)+		;CLEAR HIGH BYTE OF PROGRAMMER CODE
	MOV	#FMT53,R1	;GET ADDRESS OF FORMAT
	CALL	$MPOUT		;OUTPUT UIC
	MOV	#$SYMBF,R2
	MOV	$PRIOR,(R2)	;ADDRESS OF TASK'S PRIORITY
	BEQ	20$		;IF EQ SKIP
	MOV	#FMT55,R1	;ADDRESS OF FORMAT
	CALL 	$MPOUT		;PRINT
20$:
	MOV	$RTSEG,R0	;VIRTUAL ADDRESS OF ROOT
	CALL	$ADRSM		; SET ADDRESS LIMITS
	MOV	#$SYMBF,R2	;BUFFER ADDRESS
	TST	$STACK		;ANY STACK SPECIFIED?
	BEQ	30$		;IF EQ NO
	MOV	$BEGRW,(R2)	;SET BASE ADDRESS OF STACK
	.IIF   DF  R$$11M, ADD	$HDSIZ,(R2)	; INCLUDE HEADER
	MOV	(R2)+,(R2)	;COPY BASE ADDRESS
	DEC	(R2)+		;BACK OFF BY ONE
	MOV	$STACK,(R2)	;SET LENGTH OF STACK
	MOV	(R2)+,(R2)	; COPY STACK LENGTH
	ADD	-(R2),-(R2)	; ADD BASE TO LENGTH
	MOV	#FMT20,R1	;GET ADDRESS OF FORMAT
	CALL	$MPOUT		;OUTPUT STACK LIMITS
30$:
	MOV	#$ODTAD,R2	;GET ODT VECTOR ADDRESS
	CMP	#1,(R2)		;ODT SPECIFIED?
	BEQ	40$		;IF EQ NO
	MOV	#FMT6,R1	;GET ADDRESS OF FORMAT
	CALL	$MPOT1		;OUTPUT ODT TRANSFER ADDRESS
40$:	MOV	#$XFRAD,R2	;GET PRG VECTOR ADDRESS
	CMP	#1,(R2)		;PRG SPECIFIED?
	BEQ	50$		;IF EQ NO
	MOV	#FMT7,R1	;GET ADDRESS OF FORMAT
	CALL	$MPOT1		;OUTPUT PRG XFR ADDRESS
50$:				;
	MOV	$TSKNM,R1	; GET ADDRESS OF TASK NAME BLOCK
	BEQ	51$		; IF EQ NO TASK FILE
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	MOV	E$LSWT(R0),R1	; GET TASK FILE SWITCH WORD
	BIT	#ID$ATA,$SWTCH	; IS THIS AN I & D SPACE TASK
	BEQ	505$		; IF EQ, NO, JUST A PLAIN ORDINARY TASK
	BIS	#1,R1		; YES, SET THAT ATTRIBUTE BIT
505$:

	MOV	R1,ELSWT ; SAVE SWITCH WORD FOR LATER
	BR	52$		;
51$:				;
	MOV	$STBNM,R1	; GET ADDRESS OF STB FILE NAME BLOCK
	BEQ	95$		; IF EQ NO STB FILE
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	MOV	E$LSWT(R0),R1	; GET STB FILE SWITCH WORD
	BIC	#^C<SW$PI!SW$NH>,R1 ; ISOLATE /PI, /NH SWITCHES
52$:				;
	.IF	DF	R$$11M

	BIT	#SW$AC,R1	;++021 'ACP' TASK
	BEQ	60$		;++021 IF EQ NO
	BIS	#SW$PR,R1	;++021 SET '/PR' SWITCH

	.ENDC

60$:
	MOV	$DFTSK,R3	;EXCLUSIVE OR
	MOV	R1,R2		;DEFAULT SWITCH WORD
	BIC	R3,R1		;SWITCH WORD
	BIC	R2,R3		;
	BIS	R3,R1		;
	BEQ	95$		; IF EQ NO OPTIONS SELECTED
	MOV	#OPSW,R5	;GET ADDRESS OF SWITCH VECTOR
	MOV	#OPSWN,R4	;GET REPEAT COUNT
	MOV	#$SYMBF,R2	;GET ADDRESS OF SYMBOL BUFFER


62$:
	BIT	(R5)+,R1	;OPTION SELECTED?
	BEQ	70$		;IF EQ NO
	MOV	#4,(R2)+	;
	MOV	R5,(R2)+	;INSERT OPTION TEXT ADDRESS
	CLR	R3		;
	BIT	-2(R5),$DFTSK	;GET SWITCH DEFAULT VALUE
	BEQ	65$		; IF EQ NOT SET
	INC	R3		;SET SWITCH BIT
65$:	CMP	(R5)+,(R5)+	;MOVE OVER CODE
	CMP	R3,(R5)+	;DEFAULT=YES?
	BEQ	75$		;IF EQ YES
	ADD	#1,-2(R2)		;OMIT "-" FROM TEXT
	DEC	-4(R2)		;DECREMENT COUNT
	BR	75$
70$:
	CMP	(R5)+,(R5)+	;ADVANCE TO NEXT OPTION
	TST	(R5)+
75$:
	SOB	R4,62$		;REPEAT
	DEC	-4(R2)		;DECREMENT COUNT OF LAST
	MOV	#FMT24,R1	;GET ADDRESS OF FORMAT
80$:	CMP	R2,#$SYMBF+<2*3*OPSWN>;FILL BUFFER YET?
	BHIS	90$		;IF HIS YES
	CLR	(R2)+		;CLEAR COUNT
	MOV	#BLANK,(R2)+	;INSERT ADDRESS OF BLANK FILLER
	BR	80$		;GO AGAIN
90$:	CALL	$MPOUT		;OUTPUT OPTIONS
95$:				;
	MOV	#$SYMBF,R2
	MOV	$MXWND,(R2)	;MAX NUM. OF WINDOWS ALLOCATED
	MOV	#FMT60,R1	;FORMAT ADDRESS
	CALL	$MPOUT		;PRINT
	MOV	#$SYMBF,R2	;ADDRESS OF PARAMETER STORAGE
	MOV	$LBOFF,R0	;LENGTH OF VSECT AREA IN 32 WORD BLKS
	BEQ	100$		;IF EQ DON'T PRINT
	CALL	MUL32		;CALL NUMBER OF WORDS
	MOV	#FMT56,R1	;ADDRESS OF FORMAT
	CALL	$MPOUT	;PRINT
100$:
	MOV	#$SYMBF,R2	;ADDRESS OF PARAMETER STORAGE
	MOV	$LBEXT,R0	;LENGTH OF EXTEND
	BEQ	110$		;IF EQ NONE -DON'T PRINT
	CALL	MUL32		;GET NUM OF WORDS PER BLK
	MOV	#FMT57,R1	;FOMAT ADDRESS
	CALL	$MPOUT		;PRINT
110$:
	MOV	#$SYMBF,R2	; GET ADDRESS OF PARAMETER STORAGE
	BIT	#ID$ATA,$SWTCH	; DOING AN I/D MAP?
	BEQ	111$		; IF EQ, NO...CONVENTIONAL FORMAT
	MOV	$MXLGH+6,R0	; GET THE D-SPACE MAX SIZE
	CALL	MUL32		; CONVERT TO WORDS. * 32.
	MOV	TEMP,TEMP0	; SAVE TEMPORARY LENGTHS TOO...
	MOV	TEMP+2,TEMP0+2
	MOV	TOTAL,TOTAL0	; COPY THE TOTALS FOR LATER PROCESSING
	MOV	TOTAL+2,TOTAL0+2 ; IF WE'RE DOING AN I/D MAP
	CLR	TOTAL		; ZERO THE TOTALS
	CLR	TOTAL+2
	CLR	TEMP		; ZERO THE TEMPORARY STORAGE
	CLR	TEMP+2
	MOV	$MXLGH,R0	; SET I-SPACE LENGTH REQUIREMENT
	CALL	MUL32
	MOV	#$SYMBF,R2	; POINT TO THE OUTPUT BUFFER AREA
	MOV	#TOTAL,(R2)+	; SET THE ADDRESS OF THE I-SPACE LENGTH
	MOV	#TEMP0,(R2)	; SET THE ADDRESS OF THE D-SPACE LENGTH
	MOV	#FMT61A,R1	; SET ADDRESS OF THE FORMAT STRING
	CALL	$MPOUT		; OUTPUT THE STATISTICS TO THE MAP FILE
	BR	112$
111$:
	MOV	$MXLGH,R0	;GET MAX TASK SIZE
	CALL	MUL32		;GET NUM OF WORDS PER BLK
	MOV	#FMT61,R1	;ADDRESS OF FORMAT
	CALL	$MPOUT
112$:
	BIT	#ID$ATA,$SWTCH	; WE PROCESSING AN I/D MAP??
	BEQ	113$		; IF EQ, NO...CHECK CONVENTIONAL LENGTHS...
	CMP	TEMP0,TOTAL0	; DID WE ADD IN $LBOFF OR $LBEXT??
	BNE	115$		; IF NE, YES...PRINT TOTALS
	CMP	TEMP0+2,TOTAL0+2 ; WAS EITHER ADDED IN??
	BEQ	120$		; IF EQ, NO...
	BR	115$		; IF NE, YES...PRINT TOTALS
113$:
	CMP	TEMP,TOTAL	;WAS LBEXT OR LBOFF ADD IN?
	BNE	115$		;IF NE YES - PRINT TOTAL
	CMP	TEMP+2,TOTAL+2	; WAS EITHER ADDED IN?
	BEQ	120$		;IF EQ NO
115$:
	MOV	#$SYMBF,R2	;ADDRESS OF PARAMETER BUFFER
	BIT	#ID$ATA,$SWTCH	; DOING AN I/D MAP??
	BEQ	116$		; IF EQ, NO...CONVENTIONAL
	MOV	#TOTAL,(R2)+	; SET I-SPACE TOTAL TASK SIZE...
	MOV	#TOTAL0,(R2)	; SET D-SPACE TOTAL TASK SIZE...
	MOV	#FMT43A,R1	; SET THE I/D FORMAT STRING
	CALL	$MPOUT		; SENT IT TO THE MAP FILE...
	BR	120$
116$:
	MOV	#TOTAL,(R2)	;ADDRESS OF TOTAL STORAGE
	MOV	#FMT43,R1	;FORMAT ADDRESS
	CALL	$MPOUT		;PRINT TOTAL STORAGE
120$:				;
	MOV	$OFFST,(R2)	; SET TASK OFFSET
	MOV	(R2)+,(R2)	; COPY OFFSET
	ADD	$HVRTL,(R2)	; CONPUTE TOP VIRTUAL ADDRESS
	BIT	#ID$ATA,$SWTCH	; DOING THE MAP FOR AN I/D TASK?
	BEQ	125$		; IF EQ, NO...CONVENTIONAL MAP FORMAT
	TST	(R2)+		; BUMP BUFFER POINTER
	MOV	$OFFST,(R2)	; SET TASK OFFSET
	MOV	(R2)+,(R2)	; COPY IT
	ADD	$HDVRT,(R2)	; COMPUTE TOP VIRTUAL ADDRESS FOR D-SPACE
	MOV	#FMT42A,R1	; SET FORMAT STRING ADDRESS
	CALL	$MPOUT		; OUTPUT THE STRING
	BR	126$
125$:
	MOV	#FMT42,R1	; GET ADDRESS OF FORMAT
	CALL	$MPOUT		; OUTPUT MAP FILE
126$:
	BIT	#TS$KF,$SWTCH	; TASK IMAGE FILE SPECIFIED?
	BEQ	140$		; IF EQ NO
	MOV	$HDRBN,(R2)+	; START BLK OF TASK IMAGE
	MOV	$ROBLK,(R2)	; LAST BLK IN R-W IMAGE
	DEC	(R2)		; BACK OFF BY ONE
	BIT	#SW$NH,ELSWT	; BUILDING LIBRARY?
	BEQ	130$		; IF EQ NO
	MOV	$REBLK,(R2)	; LAST BLK IN LIBRARY
130$:
	CALL	$MPEDT		; CALCULATE SIZE
	MOV	#FMT62,R1	; GET ADDRESS OF FORMAT
	CALL	$MPOUT		; OUT LINE
	BIT	#SW$MU,ELSWT	; MULTIUSER TASK?
	BEQ	140$		; IF EQ NO
	MOV	$ROBLK,(R2)+	; START BLK OF R-O
	MOV	$REBLK,(R2)	; END BLK OF R-O
	CALL	$MPEDT		; CALCULATE LENGTH
	MOV	#FMT63,R1	; ADDRESS OF FORMAT
	CALL	$MPOUT		; OUTPUT LINE
140$:
	RETURN

;
; MUL32-MULTIPLIES NUMBER IN R0 BY 32 THEN
;	ADDS RESULT TO TOTAL
;
MUL32:
	MOV	#TEMP,(R2)	;ADDRESS OF DOUBLE-PRECISION PARAMETER
	.IF DF	V1145							; 043

	MUL 	#32.,R0		;

	.IFF

	MOV	#32.,R1		;GET NUMBER OF WORDS PER BLOCK
	CALL	$MUL		;MULTIPLY

	.ENDC

	MOV	R0,@(R2)+	;SET HIGH PART OF LENGTH
	MOV	R1,TEMP+2	;SET LOW PART OF LENGTH
	ADD	TEMP+2,TOTAL+2	;ADD LOW PART TO TOTAL
	ADC	TOTAL		;ADD CARRY
	ADD	TEMP,TOTAL	;INCLUDE HIGH PART OF RESULT
	RETURN


;;+
; MPTSK-SETUP TASK NAME IN BUFFER
;
MPTSK:
	MOV	R2,-(SP)	;SAVE PARAMETER BLOCK ADDRESS
	MOV	$TSKNM,R1	; GET ADDRESS OF TASK NAME BLOCK
	BEQ	10$		;IF EQ NO TASK FILE
	CALL	$CVRL		;CONVERT TO REAL ADDRESS
	ADD	#E$LMND+4,R0	;STEP PAST DEVICE AND UNIT
	MOV	(SP),R2		;RESTORE PARAMETER BLOCK ADDRESS
	MOV	(R0)+,(R2)+	;SETUP FILE NAME
	MOV	(R0)+,(R2)+	;
	MOV	(R0)+,(R2)+	;
	MOV	(R0)+,(R2)+	;SETUP FILE TYPE
	MOV	(R0)+,(R2)+	;SETUP FILE VERSION NUMBER
	BR	30$
10$:
	MOV	#5,R1		;SET LOOP COUNT
20$:
	CLR	(R2)+		;CLEAR TASK FILE NAME
	SOB	R1,20$		;
30$:
	TST	(SP)+		;CLEAN STACK
	RETURN
;+
; $MPOLD-CREATE AND OUTPUT OVERLAY DESCRIPTION IN LOAD MAP
;
;INPUTS:
;	$NUMSG-NUMBER OF SEGMENTS
;
;OUTPUTS:
;	OVERLAY DESCRIPTOR
;
;-
$MPOLD::
	CMP	$NUMSG,#1	;MORE THEN ONE SEGMENT?
	BEQ	20$		;IF EQ NO
	CALL	MPTSK		; GET TASK NAME
	MOV	#FMT48,R1	;ADDRESSS OF HEADING
	CALL 	$MPOUT
	MOV	#FMT50,R1	;ADDRESS OF COLUNM HEADINGS
	CALL	$MPOUT
	MOV	#FMT49,R1	;UNDER SCORE
	CALL	$MPOUT
	MOV	#5,TAB		; INITIAL FOR WIDE LISTING
	BIT	#WI$DE,$SWTCH	;NARROW LISTING?
	BNE	10$		;IF NE	NO
	MOV	#2,TAB	;SET FOR NARROW LISTING
10$:
	MOV	#MPOLD,R0
	CALL	$PCTRL
20$:
	RETURN

;+
; MPOLD- GENERATE OVERLAY DESCRIPTOR
;
;

MPOLD:
	SAVRG			;SAVE NON-VOLATILE REGISTERS
	MOV	$CRVSG,R0	;GET VIRTUAL ADDRESS OF CURRENT SEGMENT
	CALL	$ADRSM		;SET ADDRESS LIMITS
	MOV	#$SYMBF,R2	;ARGUMENT BUFFER ADDRESS
	CMP	$CRVSG,$RTSEG	;CURRENT ROOT?
	BNE	10$		;IF NE NO
	MOV	$OFFST,$BEGRW
10$:
	MOV	$BEGRW,(R2)+	;INSERT STAT ADDRESS
	MOV	$ENDRW,(R2)
	CMP	(R2),-2(R2)	;LENGTH ZERO?
	BHIS	15$		; IF $ENDRW >= $BEGRW, CONTINUE...
	MOV	$BEGRO,-2(R2)	; R-O SEGMENT BASE
	MOV	$ENDRO,(R2)	; R-O SEGMENT END
	CMP	(R2),-2(R2)	; ZERO LENGTH?
	BHIS	15$		; IF $ENDRO >= $BEGRO, CONTINUE...
	TST	(R2)+
	CLR	(R2)+
	CLR	(R2)+
	BR	20$
15$:
	CALL	$MPEDT		;CALCULATE LENGTH
	TST	(R2)+		;
20$:
	MOV	TAB,(R2)
	MOV	$LVL,R3		;START CALCULATION FOR TAB

	BEQ	30$		;IF EQ LEVEL = 0
25$:
	ADD	TAB,(R2)	;ADD INDENT VALUUE
	SOB	R3,25$		;DEC LEVEL COUNT AND CONTINUE TILL ZERO
30$:
	CMP	#<130.-32.-6.>,(R2) ; HAVE WE REACHED THE PAGE WIDTH LIMIT?
	BGE	35$		    ; IF GE, NO...CAN STILL FIT IT ALL
	MOV	#<130.-32.-6.>,(R2) ; YES...RESET AND LEAVE ROOM FOR THE SEGMENT
				    ; NAME AND THE <CR><LF>
35$:
	TST	(R2)+
	MOV	$CRSEG,R0	;GET ADDRESS OF CURRENT SEGMENT
	MOV	S$GNME(R0),(R2)+	;INSERT SEGMENT NAME
	MOV	S$GNME+2(R0),(R2)

	BIT	#ID$ATA,$SWTCH	; ARE WE PROCESSING AN I/D TASK MAP?
	BNE	50$		; IF NE, YES...THERE'S EXTRA STUFF TO OUTPUT.
	MOV	#FMT47,R1	;ADDRESS OF FORMAT
	CALL	$MPOUT

40$:
	RETURN

50$:
	TST	(R2)+		; POINT PAST THE LAST THING IN THE BUFFER.
	CMP	$CRVSG,$RTSEG	; CURRENT = ROOT?
	BNE	60$		; IF NE, NO...
	MOV	$OFFST,$BGRWD	; RESET STARTING ADDRESS
60$:
	MOV	$BGRWD,(R2)+	; SET THE STARTING ADDRESS
	MOV	$EDRWD,(R2)	; SET THE ENDING ADDRESS
	CMP	(R2),-2(R2)	; ANY LENGTH HERE??
	BNE	70$		; IF NE, YES...
	TST	(R2)+
	CLR	(R2)+
	CLR	(R2)+
	BR	80$
70$:
	CALL	$MPEDT		; CALCULATE LENGTH OF SEGMENT
	TST	(R2)+
80$:
	MOV	#FMT47A,R1	; SET FORMAT STRING ADDRESS
	CALL	$MPOUT		; OUTPUT THE STRING
	RETURN
	.END
