	.IF	DF	A$$DRM

	.TITLE	ADRSM


	.IFF

	.TITLE	ADRST

	.ENDC


	.IDENT	/15.05/
;
; COPYRIGHT (c)	1986 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE IS FURNISHED  UNDER A LICENSE AND MAY BE USED OR
; COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;
; D. N. CUTLER/C. MONIA 27-JAN-74
;
; MODIFIED FOR RSX-11M/M-PLUS V4.0/V2.0 BY:
;
;	J. A. KASSON
;
; MODIFIED BY:
;
;	C. B. PETROVIC	26-FEB-82	15.01
;		CBP039		ADD CORRECT .PSECT DEFINITIONS TO
;				ALLOW TKB TO BE LINKED AS AN I/D TASK.
;
;	C. B. PETROVIC	7-JUN-82	15.02
;		CBP051		ADD AUTOLOAD SUPPORT FOR USER-MODE
;				I/D TASKS.
;
;	C. B. PETROVIC	14-DEC-82	15.03
;		CBP067		CORRECT SETTING ADDRESS LIMITS FOR
;				MEMORY-RESIDENT OVERLAID MULTI-USER TASKS.
;				THE $ENDRW LOCATION WAS BEING SET WITH THE
;				SEGMENT LENGTH RATHER THAN THE LENGTH OF THE
;				R/W ALLOCATION.
;
;	C. B. PETROVIC	20-APR-83	15.04
;		CBP084		CORRECT SETTING OF $ENDRW IF THE TASK
;				BEING BUILT IS I/D.
;
;	L. M. PETERSON	11-MAR-86  15.05  SPR# 82026A
;		LMP040		CORRECT ADDRESS LIMIT SETUP FOR /PR/ID TASK
;				SO THAT LWRWD INCLUDES OFFSET
;
;+
; **-$ADRSM-ADDRESS LIMITS SETUP
; **-$ADRST-ADDRESS LIMITS SETUP AND TASK IMAGE BUFFER FLUSHED
;
; THIS ROUTINE IS CALLED TO SET UP THE ADDRESS LIMITS FOR A SEGMENT.
; IF THE SPECIFIED SEGMENT IS THE SAME AS THE CURRENT SEGMENT THAT IS
; IS BEING WRITTEN, THEN AN IMMEDIATE RETURN IS EXECUTED. ELSE THE
; CURRENT OUTPUT BUFFER IS FLUSHED AND THE NEW ADDRESS LIMITS ARE ES-
; TABLISHED.
;
; INPUTS:
;
;	R0=VIRTUAL ADDRESS OF SEGMENT DESCRIPTOR
;
; OUTPUTS:
;
;	THE ADDRESS LIMITS FOR THE SPECIFIED SEGMENT ARE ESTABLISHED.
;-
	.NLIST	CND

	.IF DF D$ADRS

	PURE.D

	.NLIST	BEX
FMT:	.ASCII	/$ADRST:	$EDRWD=%P $ENDRW=%P $EDROD=%P $ENDRO=%P%N/
	.ASCIZ	/	$BGRWD=%P $BEGRW=%P $BGROD=%P $BEGRO=%P%N/
	.LIST BEX

	.ENDC


	PURE.I			; READ-ONLY I-SPACE


	.IF	NDF	A$$DRM

$ADRST::			;
	CMP	R0,$WRSEG	; IS SPECIFIED SEGMENT SAME AS CURRENT?
	BNE	10$		; IF NE, NO...ADDRESS LIMITS MUST BE
				; SET UP...
	RETURN			; IF EQ, YES...RETURN IMMEDIATELY
10$:
	MOV	R0,-(SP)	;SAVE SEGMENT ADDRESS
	CALL	$FLUSH		;FLUSH CURRENT OUTPUT BUFFER
	MOV	(SP)+,R1	; RETRIEVE VIRTUAL SEGMENT ADDRESS

 	.IFF

$ADRSM::			;
	MOV	R0,R1		; COPY VIRTUAL SEGMENT DESCRIPTOR

	.ENDC

	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	MOVB	S$GSTS(R0),$WRFLG ; SAVE SEGMENT FLAGS
	MOV	R0,R2		; SAVE REAL ADDRESS
	MOV	S$GLDA(R2),R0	; GET VIRTUAL STARTING ADDRESS

	.IF	DF	R$$11M

	CLR	$LOWRW		; SET LOW R/W MEMORY LIMIT
	CLR	$LWRWD		; SET LOW R/W DATA LIMIT

	.ENDC

	CMP	R1,$RTSEG	; RESIDENT ROOT?
	BNE	15$		; IF NE NO
	CLR	R0		;++021 CLEAR RELOCATION BIAS

	.IF	DF	R$$11M

	MOV	$HDSIZ,$LOWRW	; SET LOW R/W LIMIT TO EXCLUDE HEADER
	MOV	$HDSIZ,$LWRWD	; SET LOW R/W DATA LIMIT TO EXCLUDE HEADER

	.ENDC

15$:
	ADD	$OFFST,R0	; GET OFFSET BIAS
	MOV	R0,$BEGRW	; SET BEGINNING OF RW AREA
	MOV	R0,$BEGRO	; SET BEGINNING OF R-O
	MOV	R0,$ENDRW	 ; COPY BASE ADDRESS OF R/W
	CMP	R1,$RTSEG	 ; WE PROCESSING THE ROOT SEGMENT?
	BNE	16$		 ; IF NE, NO...DON'T ADD HEADER AND STACK
	ADD	$HDSIZ,$ENDRW	 ; IF EQ, YES...INCLUDE THE HEADER AND
	BIT	#ID$ATA,$SWTCH	 ; ARE WE BUILDING AN I/D TASK?
	BNE	16$		 ; IF NE, YES...DON'T INCLUDE THE STACK
	ADD	$STACK,$ENDRW	 ; IF EQ, NO...ADD IN THE STACK SIZE...
16$:
	ADD	S$GRW(R2),$ENDRW ; ADD IN SEGMENT R/W LENGTH
	DEC	$ENDRW		 ; AND BACK OFF BY ONE...
	MOV	$ENDRW,$ENDRO	 ; COPY TO THE R/O LIMIT IN CASE WE DON'T
				 ; HAVE ANY R/O TO PROCESS OR ARE NOT
				 ; DOING A MULTI-USER TASK.
	TST	S$GRO(R2)	; ANY READ ONLY LENGTH
	BEQ	17$		; IF EQ NO
	MOV	S$GROB(R2),R0	; GET R-O BASE ADDRESS
	ADD	$OFFST,R0	; INCLUDE OFFSET BIAS
	MOV	R0,$BEGRO	; CALC. END OF R-O
	ADD	S$GRO(R2),R0 ; ADD IN R-O LENGTH
	DEC	R0		; BACK OFF ONE
	MOV	R0,$ENDRO	; SAVE END OF R-O
17$:
	BIT	#ID$ATA,$SWTCH	; WE BUILDING AN I/D TASK??
	BEQ	40$		; IF EQ, NO...CONVENTIONAL
	MOV	S$GDLD(R2),R0	; GET STARTING VIRT. ADDR OF DATA SECTION
	ADD	$OFFST,R0	; GET OFFSET BIAS
	MOV	R0,$BGRWD	; SET BEGINING OF R/W DATA AREA
	ADD	S$GRWD(R2),R0	; ADD IN SEGMENT DATA LENGTH
	CMP	R1,$RTSEG	; IS THIS THE ROOT SEGMENT?
	BNE	18$		; IF NE, NO...DON'T ADD IN HEADER AND STACK
	ADD	$HDSIZ,R0	; IF EQ, YES...ADD IN THE HEADER SIZE
	ADD	$STACK,R0	; AS WELL AS THE STACK SIZE
18$:
	DEC	R0		; BACK OFF ONE
	MOV	R0,$EDRWD	; SET END OF R/W DATA AREA
	MOV	S$GODB(R2),R0	; GET R/O DATA BASE ADDRESS
	ADD	$OFFST,R0	; INCLUDE OFFSET BIAS
	MOV	R0,$BGROD	; SET START OF THE R/O DATA AREA
	ADD	S$GROD(R2),R0	; ADD IN R/O DATA LENGTH
	DEC	R0		; BACK OFF BY ONE
	MOV	R0,$EDROD	; SAVE END BOUNDRY
;
; Now we have to check back to see if there is any R/W I-space.
; We must do this because in order that the task image be built
; correctly for multi-user memory-resident tasks, the entire
; up-tree segment must be R/O. If there is only R/O I-space but R/W D-space,
; then we must reset the $ENDRW address limit to that of the $ENDRO limit.
; Note that we only do this for an up-tree segment.
;
	CMP	R1,$RTSEG	; IS THIS THE ROOT SEGMENT?
	BEQ	40$		; IF EQ, YES...DON'T CHECK FOR R/W D-SPACE. WE
				; GENERALLY ALWAYS HAVE R/W SPACE IN THE ROOT.
	TST	S$GRWD(R2)	; WELL, IS THERE R/W D-SPACE IN THIS SEGMENT
	BEQ	40$		; IF EQ, NO...STILL A R/O SEGMENT
	TST	S$GRW(R2)	; THEN IS THERE R/W I-SPACE??
	BNE	40$		; IF NE, NO...THE SEGMENT IS R/W ALREADY
	MOV	$ENDRO,$ENDRW	; IF EQ, WE'VE GOT TO RESET THE R/W ADDRESSES
40$:

	.IF NDF	A$$DRM

	MOV	S$GBLK(R2),$RLBLK ; SET STARTING BLK NUM OF R-W
	MOV	S$GBLK+2(R2),$RLBLK+2 ; SET START BLK NUM OF R-O
	BIT	#ID$ATA,$SWTCH	; WE BUILDING AN I/D TASK??
	BEQ	45$		; IF EQ, NO...CONVENTIONAL
	MOV	S$GBWD(R2),$RLDBK ; SET START BLK NUM FOR R/W DATA
	MOV	S$GBWD+2(R2),$RLDBK+2 ; SET START BLK NUM FOR R/O DATA
45$:

	.ENDC


	.IF	DF	R$$11M

	ADD	$BEGRW,$LOWRW	; OFFSET LOW R/W LIMIT
	ADD	$BGRWD,$LWRWD	; OFFSET LOW R/W DATA LIMIT

	.IF DF D$ADRS

	CALL	TRACE

	.ENDC
	.ENDC

50$:
	RETURN
	.IF DF D$ADRS

TRACE:
	MOV	$BEGRO,-(SP)	; SAVE THE ADDRESS RANGES
	MOV	$BGROD,-(SP)
	MOV	$BEGRW,-(SP)
	MOV	$BGRWD,-(SP)
	MOV	$ENDRO,-(SP)
	MOV	$EDROD,-(SP)
	MOV	$ENDRW,-(SP)
	MOV	$EDRWD,-(SP)
	MOV	#FMT,-(SP)	; OF COURSE, THE FORMAT STRING
	MOV	$PHASE,$DVDEB	; MARK THIS CURRENT PHASE AS THE ONE TO TRACE
	CALL	$DVDBP		; WRITE IT TO TI:
	ADD	#2*9.,SP	; CLEAN UP THE STACK BEFORE PROCEEDING
	CLR	$DVDEB		; ZERO OUT THE PHASE-TO-TRACE-ON LOCATION
	RETURN

	.ENDC


	.END
