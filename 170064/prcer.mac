	.TITLE	PRCER
	.IDENT	/01.03/
;
; COPYRIGHT (c)	1983,1991 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE IS FURNISHED  UNDER A LICENSE AND MAY BE USED OR
; COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;
; C. MONIA 18-APR-74
;
;
; MODIFIED BY:
;
;	C. B. PETROVIC	26-FEB-82	01.01
;		CBP039		ADD CORRECT .PSECT DEFINITIONS TO
;				ALLOW TKB TO BE LINKED AS AN I/D TASK.
;
;	J. M. Lawler	27-JUN-82	01.02
;		JML112		USE CALCULATED TASK NAME IN MESSAGE
;
;	C. M. Katz	23-APR-91	01.03
;		CMK001		ADD RSTS CONDITIONAL CODE
;


; ERROR MESSAGE PROCESSING
;
; LOCAL DATA
;

	.PSECT	ETXT$D,RO,D,GBL
        .IF	NDF,R$RSTS
DIAG:	.ASCIZ	/ -- *DIAG*-/	; DIAGNOSTIC PREFIX
FATAL:	.ASCIZ	/ -- *FATAL*-/	; FATAL PREFIX
	.IFF
DIAG:	.ASCIZ	/TKB -- *DIAG*-/ 
FATAL:	.ASCIZ	/TKB -- *FATAL*-/
	.ENDC			






	.IF	DF	S$$MSG

SUFF:	.ASCIZ	/%2N/		; STANDARD SUFFIX

	.ENDC


	.PSECT

;+
; **-$PRCER-PROCESS ERROR MESSAGE
;
; INPUTS:
;
;	R1=ERROR/SEVERITY
;	R2=PARAMETER BLOCK ADDRESS
;
; OUTPUTS:
;
;	R0=ADDRESS OF OUTPUT BUFFER ($OUTBF)
;	R1=ADDRESS OF BUFFER CONTAINING UNFORMATTED MESSAGE($TBUF)
;	R2=PARAMETER BLOCK ADDRESS
;	R3=SEVERITY CODE
;
;	THIS ROUTINE IS CALLED BY THE ERROR MESSAGE HANDLER ($ERMSG)
; TO MOVE UNFORMATTED ERROR TEXT FROM THE CO-TREE TO THE ROOT FOR
; SUBSEQUENT OUTPUT VIA LUN 2. THE MESSAGE TO BE FORMATTED CON-
; TAINS AN APPROPRIATE PREFIX DEPENDANT ON THE SEVERITY CODE.
;-
	PURE.I			; READ-ONLY I-SPACE

$PRCER::			;
	CLR	R3		; CLEAR SEVERITY
	CLR	R4		; CLEAR ERROR NUMBER
	BISB	R1,R4		; ISOLATE ERROR NUMBER
	SWAB	R1		; POSITION SEVERITY TO LOW BYTE
	BISB	R1,R3		; COPY SEVERITY CODE
	CMP	R4,#E$RMAX	; LEGAL ERROR CODE
	BHI	10$		; IF HI NO
	CMP	R3,#S$V2	; LEGAL SEVERITY?
	BLOS	20$		; IF LOS YES
10$:				;
	MOV	#$ARGBK+4,R0	; GET ADDRESS IN ARGUMENT BLOCK
	MOV	12(SP),(R0)	; SAVE ADDRESS OF CALLER
	MOV	R2,-(R0)	; STORE ARGUMENT BLOCK ADDRESS
	SWAB	R1		; REPOSITION ERROR/SEVERITY CODE
	MOV	R1,-(R0)	; STORE SEVERITY CODE
	MOV	R0,R2		; SET NEW PARAMETER BLOCK ADDRESS
	MOV	#<S$V2*400!E$R5>,R1 ; GET NEW ERROR/SEVERITY
	BR	$PRCER		; GO AGAIN
20$:				;
	MOV	$CMIPT,R5	; GET COMMAND INPUT RECORD BLOCK
	BITB	#FD.TTY,F.RCTL(R5) ; TTY DEVICE?
	BNE	30$		; IF NE YES
	INC	R3		; INCREMENT SEVERITY
30$:				;

	.IF DF	R$$PRO

	MOV	#$TBUF,R1	; MESSAGE BUFFER
	MOV	#$TSK,R0	; TASK NAME
	MOVB	(R0)+,(R1)+	; LOAD CALCULATED TASK NAME
	MOVB	(R0)+,(R1)+	; INTO ERROR MESSAGE BUFFER
	MOVB	(R0)+,(R1)+
	MOV	#DIAG,R0	; ASSUME DIAGNOSTIC MESSAGE
	CMP	R3,#S$V2	; DIAGNOSTIC?
	BLO	50$		; IF LO, YES
	MOV	#FATAL,R0	; GET FATAL PREFIX

	.IFF
	.IF	NDF,R$RSTS
	MOV	R2,-(SP)	; SAVE REGISTER
	MOV	#^RTKB,R1	; DEFAULT TASK NAME
	CALL	$GTKNM		; GET CORRECT TASK NAME
	MOV	#$TBUF,R0	; CONVERT TASK NAME TO ASCII
	CALL	$C5TA		; CONVERT TO ASCII
	MOV	(SP)+,R2	; RESTORE R2
	.ENDC
	MOV	#DIAG,R0	; ASSUME DIAGNOSTIC MESSAGE
	CMP	R3,#S$V2	; DIAGNOSTIC?
	BLO	40$		; IF LO YES
	MOV	#FATAL,R0	; GET FATAL PREFIX
40$:		
	.IF	DF,R$RSTS	
	MOV	#$TBUF,R1	; SET INPUT BUFFER ADDRESS
	.IFF
	MOV	#$TBUF+3,R1	; SET INPUT BUFFER ADDRESS
	.ENDC
	.ENDC	; DF R$$PRO

50$:				;
	MOVB	(R0)+,(R1)+	; MOVE PREFIX
	BNE	50$		;
	TSTB	-(R1)		; BACKUP TO LAST BYTE

	.IF	DF	S$$MSG

	CALL	CVDG		; CONVERT ERROR NUMBER TO ASCII
	MOVB	R5,(R1)+	; MOVE TO TEXT BUFFER
	SWAB	R5		; GET HIGH BYTE
	MOVB	R5,(R1)+	; MOVE TO TEXT BUFFER
	MOVB	#' ,(R1)+	; FORMAT WITH SPACES
	MOVB	#' ,(R1)+	;

	.IFF

	MOV	#$LM1,-(SP)	; SET TO LOAD TEXT SET 1
	CMP	R4,#M$SG1	; MESSAGE IN GROUP 1?
	BLOS	55$		; IF LOS YES
	MOV	#$LM2,(SP)	; REPLACE SUBROUTINE ADDRESS
55$:				;
	CALL	@(SP)+		; LOAD TEXT

	.ENDC

	ASL	R4		; CONVERT MESSAGE NUMBER TO WORD INDEX
	MOV	$MSG(R4),R0	; GET POINTER TO UNFORMATTED STRING
60$:				;
	MOVB	(R0)+,(R1)+	; MOVE MESSAGE PROPER
	BNE	60$		;

	.IF	DF	S$$MSG

	TSTB	-(R1)		; BACKUP TEXT POINTER
	MOV	#SUFF,R0	; POINT TO SUFFIX STRING
70$:				;
	MOVB	(R0)+,(R1)+	; INSERT SUFFIX
	BNE	70$		;

	.ENDC

	MOV	#$OUTBF,R0	; SET ADDRESS OF OUTPUT BUFFER
	MOV	#$TBUF,R1	; SET ADDRESS OF INPUT
	RETURN			;


	.IF	DF	S$$MSG


;
; SUBROUTINE TO CONVERT ERROR NUMBER TO TWO-DIGIT ASCII
;

CVDG:				;
	SAVVR			; SAVE VOLATILE REGISTERS

	.IF	DF	V1145

	MOV	R4,R1		; GET ERROR NUMBER
	CLR	R0		; CLEAR HIGH PART OF DIVIDEND
	DIV	#10.,R0		; DIVIDE BY TEN

	.IFF

	MOV	R4,R0		; GET ERROR NUMBER
	MOV	#10.,R1		; SET DIVISOR
	CALL	$DIV		; DIVIDE BY TEN

	.ENDC

	SWAB	R1		; POSITION REMAINDER
	BIS	R1,R0		; COMBINE WITH DIVIDEND
	BIS	#"00,R0		; INSERT ASCII OFFSET
	MOV	R0,R5		; SAVE RESULT
	RETURN

	.ENDC

	.END
