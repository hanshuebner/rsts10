	.TITLE	P2POP
	.IDENT	/18.21/
;
; COPYRIGHT (c) 1991 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED
; OR COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;
; C. MONIA 26-MAR-74
;
; MODIFIED FOR RSX-11M/M-PLUS V4.0/V2.0 BY:
;
;	J. A. KASSON
;	C. B. PETROVIC
;	J. M. LAWLER
;
; MODIFIED FOR RSX-11M/M-PLUS V4.1/V2.1 BY:
;
;	C. B. PETROVIC
;	J. M. SALMAN
;
; MODIFIED BY:
;
;	D. P. Rabahy	08-NOV-85
;		DPR026	CORRECTLY ALLOCATE IMPLIED APRS FOR VSECTS	V18.15
;			RESPONSE TO SPR #75535
;
;	D. P. Rabahy	12-JAN-87
;		DPR036	ENHANCE ASG OPTION, SPR #175P			V18.16
;
; MODIFIED FOR RSX-11M-PLUS V4.1 BY:
;
;	L. M. Peterson	2-NOV-87					V18.17
;		LMP098	ADD SUPPORT TO RESERVE LIBRARY D-SPACE
;
;	L. M. Peterson	29-MAR-88					V18.18
;		LMP110	CORRECT ERROR WITH /MU/ID & PAR COMBINATION
;
;
; MODIFIED FOR RSX-11M-PLUS V4.2 BY:
;
;	L. M. Peterson	19-Jan-89					V18.19
;		LMP128	SHIFT UP PIC LIB APRS IF NECESSARY
;			(reconstructed by LBM to propogate .COR after zero
;
; MODIFIED FOR RSX-11M-PLUS AND MICRO/RSX V4.3 BY:
;
;	L. M. PETERSON	12-JUN-89					V18.20
;		LMP133	CORRECT PROBLEMS WITH ID PIC LIBRARIES
;
; MODIFIED FOR RSX-11M-PLUS AND MICRO/RSX V4.3 BY:
;
;	L. M. PETERSON	24-JAN-91					V18.21
;		LMP157 CORRECT MORE PROBLEMS WITH ID PIC LIBRARIES 
;
; POST-OPTION PROCESSING
;
; MACRO LIBRARY CALLS
;

	.MCALL	GTIM$S

;
; LOCAL DATA
;

	.IF	DF	R$$11M


;
; TEMPORARY STORAGE FOR APR BITMAPS
;
	IMPURE			; READ/WRITE D-SPACE

APRD:	.BLKB	1
SMDAPR:	.BLKB	1
APR:	.BLKB	1		;
SUPAPR:	.BLKB	1		;
;
; APR ALLOCATION BITMAP TABLE
;
	PURE.D			; READ-ONLY D-SPACE

	.RADIX	2

APRMP:	.BYTE	00000001	;
	.BYTE	00000011	;
	.BYTE	00000111	;
APRMK:	.BYTE	00001111	; APR MASK FOR PRIVELEGED TASKS
	.BYTE	00011111	;
	.BYTE	00111111	;
	.BYTE	01111111	;
	.BYTE	11111111	;

	.RADIX	8.

	.ENDC

	IMPURE			; READ/WRITE D-SPACE

;
; HIGH ADDRESS LIMIT
;

;
; HGHAD   ::= MAX ADDRESS FOR I-SPACE
; HGHAD+2 ::= MAX ADDRESS FOR D-SPACE
;

HGHAD:	.BLKW	2

TEMP:	.BLKW	1		; TEMPORARY STORAGE

	.IF	DF	R$$11M

;
; TABLE OF ADDRESS OFFSETS FOR PRIVILEGED TASKS
;

T$APR:	.WORD	0		; TEMPORARY APR STORAGE

	PURE.D			; READ-ONLY D-SPACE

CL$SIZ:	.WORD	20000		; SIZE OF APR
	.WORD	40000
	.WORD	60000
OFFST:	.WORD	100000		; APR 4 OFFSET
	.WORD	120000		; APR 5 OFFSET
	.WORD	140000		; APR 6 OFFSET
	.WORD	160000

;
; TABLE OF PARTITION LIMITS FOR PRIVILEGED TASKS
;

PLIMIT:
	.WORD	100000-1	; APR 4 LIMIT
	.WORD	60000-1		; APR 5 LIMIT
	.WORD	40000-1		; APR 6 LIMIT

	.ENDC

STR:	.WORD	LEN
	.WORD	TEXT

TEXT:	.ASCII	/Units set to maximum assigned/
LEN=	.- TEXT
	.EVEN


;+
; **-$P2POP-PERFORM POST-OPTION PROCESSING
;
; THIS ROUTINE IS CALLED AFTER ALL OPTIONS HAVE BEEN ENTERED TO
; MAP LIBRARIES IN THE TASKS ADDRESSING SPACE
;
; INPUTS:
;	NONE
;
; OUTPUTS:
;	NONE
;
;-
	PURE.I			; READ-ONLY I-SPACE

$P2POP::			;
	GTIM$S	#$BGTIM		; RECORD START OF PROCESSING
	BIT	#ID$ATA,$SWTCH	; BUILDING AN I/D TASK
	BEQ	5$		; IF EQ, NO...
	MOV	#4,$SYSTM	; IF NE, YES...SET M+ BUILD
5$:
	MOV	$NUMWN,R0	; GET NUMBER OF TASK ADDRESS WINDOWS
	ADD	$MXWND,R0	; COMPUTE WINDOW ALLOCATION
	CMP	R0,#8.		; TOO MANY WINDOWS REQUIRED?
	BLOS	21$		; IF LOS NO
	CMP	#4,$SYSTM	; M+ TASK BUILD?
	BNE	10$		; IF NE NO
	CMP	R0,#W$NDWS	; STILL TOO MANY WINDOWS?
	BLOS	21$		; IF LOS NO
10$:
	MOV	#<S$V2*400!E$R86>,R1 ; GET ERROR/SEVERITY
	CLR	R2		; CLEAR PARAMETER BLOCK ADDRESS
	BR	50$		; REPORT FATAL ERROR
21$:				;
	CMP	$NUNIT, $MXASG	; WERE ENOUGH UNITS SPECIFIED?
	BHIS	215$		; IF HIS, YES
	MOV	$MXASG, $NUNIT
	MOV	(PC)+, R1	; ILLEGAL NUMBER OF UNITS
	.BYTE	E$R49, S$V0	; DIAGNOSTIC
	MOV	#STR, R2
	CALL	$ERMSG		; OUTPUT DIAGNOSTIC
215$:
	MOV	#$LUNHD,R0	; GET ADDRESS OF ASSIGNMENT LISTHEAD
	MOV	#$DFASG,R1	; GET DEFAULT ASSIGNMENT LIST
	MOV	(R1)+,R2	; GET NUMBER OF ASSIGNMENTS
22$:				;
	DEC	R2		; DECREMENT ASSIGNMENT COUNT
	BLT	26$		; IF LT DONE
	CMP	6(R1),$NUNIT	; LUN WITHIN RANGE?
	BHI	24$		; IF HI NO
	MOV	(R0)+,(R1)	; DISPLACE OLD FIRST IN LIST
	BNE	23$		; IF NE LIST NOT EMPTY
	MOV	R1,(R0)		; SET THIS AS ENTRY AS LAST IN LIST
23$:				;
	MOV	R1,-(R0)	; SET NEW FIRST
24$:				;
	ADD	#10,R1		; ADVANCE TO NEXT ASSIGNMENT
	BR	22$		;
26$:				;

	.IF	NDF	R$$11M

	RETURN			;

	.IFF

;
; ASSIGN THE DEFAULT PARTITION IF NECESSARY AND
; ALLOCATE APRS IF THE TARGET SYSTEM IS MAPPED.
;

	MOV	#177777,HGHAD	; SET HIGH ADDRESS BOUND TO MAX
	MOV	#177777,HGHAD+2	; SET HIGH D-SPACE ADDRESS BOUND TO MAXIMUM
	MOV	$OFFST,R1	; GET BASE ADDRESS
	MOV	$HGHAD,R2	; GET HIGH ADDRESS LIMIT
	BIT	#PA$RT,$MEMFL	;++041 EXPLICIT PARTITION SPECIFIED?
	BNE	60$		;++041 IF NE YES
	BIT	#EX$TSK,$MEMFL	;++041 TASK EXTENSION SPECIFIED?
	BNE	60$		;++041 IF NE YES
	CLR	R0		; ELSE REQUEST DEFAULT
	CALL	$GTPPR		; GET BASE ADDRESS, LENGTH
	BCC	30$		; IF C/C OK
	MOV	#<S$V2*400!E$R70>,R1 ; ERROR, RUNNING ON 'FOREIGN' SYSTEM
	MOV	SP,R2		; SET DUMMY PARAMETER BLOCK ADDRESS
	BR	50$		;
30$:				;
	BIT	#MP$SY,$SWTCH	;++041 MAPPED SYSTEM?
	BNE	35$		;++041 IF NE YES
	TST	R2		;++041 SYSTEM CONTROLLED PARTITION?
	BEQ	40$		;++041 IF EQ YES ERROR
35$:				;++041
	MOV	R2,$PARSZ	;++041 SET PARTITION SIZE
	CALL	$VTKMP		;++041 VERIFY NO DUPLICATE NAME
	BCS	40$		;++041 IF C/S DUPLICATE NAME
	BIT	$ADBND,R1	; TEST ADDRESS ALIGNMENT
	BNE	40$		; IF NE INCORRECT BOUND
	CMP	R2,$ADLIM	; CHECK ADDRESS LIMITS
	BHI	40$		; IF HI ERROR
	MOV	R1,$OFFST	; SET BASE ADDDRESS
	MOV	R2,$HGHAD	; SET HIGH ADDRESS BOUND
	MOV	R2,$HGHAD+2	; SET HIGH D-SPACE ADDRESS BOUND
	BR	60$		;
40$:				;
	MOV	#<S$V2*400!E$R81>,R1 ; GET ERROR/SEVERITY
	MOV	#$PNAME,R2	; POINT TO PARTITION NAME
50$:				;
	CALL	$ERMSG		; OUTPUT ERROR, NO RETURN
60$:				;
	CLR	R5		; CLEAR APR MAP
	BIT	#MP$SY,$SWTCH	; MAPPED SYSTEM ?
	BEQ	100$		; IF EQ NO, SET RELOCATION BIAS FOR LIBS
	BIT	#SW$NH,$TKSW	; BUILDING LIBRARY?
	BNE	80$		; IF NE YES
	TST	R1		; TASK START AT ZERO?
	BNE	40$		; IF NE NO, ERROR
	BIT	#<SW$PR!SW$AC>,$TKSW ; TASK PRIVELEGED?
	BEQ	80$		; IF EQ NO
	MOV	$PRVAP,R4	; GET FIRST APR TO MAP TASK
	BEQ	80$		; IF EQ USE NON-PRIVELGED MAPPING
	SUB	#4,R4		; SUBTRACT LOW LIMIT
	BISB	APRMK(R4),APR(R5) ; RESERVE EXEC. APR SET
	BISB	APRMK(R4),APRD(R5) ; RESERVE EXECUTIVE D-SPACE APR SET
	BIT	#IO$PAG,$SWOVR	; NEED I/O PAGE MAPPING?
	BNE	70$		; IF EQ NO
	BISB	#200,APR(R5)	; EXCLUDE I/O PAGE
	BISB	#200,APRD(R5)	; EXCLUDE D-SPACE I/O PAGE APR
70$:
	ASL	R4		; CONVERT NUMBER TO WORD BIAS
	MOV	OFFST(R4),$OFFST ; SET TASK ADDRESS BIAS
	MOV	OFFST(R4),$OFFSD ; COPY FOR D-SPACE TASK OFFSET BIAS
	CMP	R2,PLIMIT(R4)	; PARTITION BOUNDARY LEGAL?
	BHI	40$		; IF HI NO
	ADD	OFFST(R4),R2	; BIAS UPPER TASK LIMIT
	MOV	R2,$HGHAD	; RESET HIGH ADDRESS BOUND
	MOV	R2,$HGHAD+2	; RESET D-SPACE HIGH ADDRESS BOUND
80$:				;
	BISB	$APRMP,APR(R5)	; SAVE THE PREVIOUSLY RESERVED I-SPACE APRS
	BISB	$APRDM,APRD(R5)	; SAVE THE PREVIOUSLY RESERVED D-SPACE APRS

	.IF DF	R$$APR

	MOVB	$RIAPR,R4	; GET I-SPACE HIGHEST APR RESERVATION
	BEQ	85$		; IF EQ, NONE...
	SUB	#4,R4		; ADJUST TABLE LIMIT
	ASL	R4		; CONVERT TO WORD ADDRESS
	MOV	OFFST(R4),$OFFST ; SET TASK ADDRESS BIAS
85$:
	MOVB	$RDAPR,R4	; GET D-SPACE HIGHEST APR RESERVATION
	BEQ	90$		; IF EQ, THERE'S NONE TO RESERVE.
	SUB	#4,R4		; ADJUST THE TABLE LIMIT
	ASL	R4		; CONVERT TO WORD ADDRESS
	MOV	OFFST(R4),$OFFSD ; SET D-SPACE ADDRESS BIAS...
90$:

	.ENDC

	CALL	APRSPN		; CALCULATE STARTING APR AND SPAN
	BIT	#ID$ATA,$SWTCH	; BUILDING I/D TASK?
	BEQ	95$		; IF EQ, NO...CONTINUE AS NORMAL
	BIT	#PA$RT,$MEMFL	; EXPLICIT PARTITION SPECIFIED?
	BEQ	95$		; IF EQ NO...CONTINUE AS NORMAL
	BIT	#MU$LTI,$SWOVR	; BUILDING MULTITUSER TASK?
	BNE	96$		; IF NE, YES - FOR /ID/MU TSK W/PAR SKIP I-APRS
95$:	BISB	R2,APR(R5)	; RESERVE ALL TASK I-SPACE APR REQUIREMENTS
96$:	BISB	R2,APRD(R5)	; RESERVE ALL TASK D-SPACE APR REQUIREMENTS
;
; NOW ALLOCATE APRS TO ALL REFERENCED LIBRARIES
;

100$:				;
	MOV	#-2,R4		; SET FLAG FOR RESERVED/ABS ALLOCATION
	CALL	APRAL		; ALLOCATE APRS
	NEG	R4		; SET FLAG FOR PIC ALLOCATION
APRAL:				;

	.ENABL	LSB

	CLR	-(SP)		; ALLOCATE STACK FOR LIBRARY ENTRY ADDRESS
	CLR	-(SP)		; ALLOCATE SPACE FOR LIBRARY SIZE
	MOV	#<$LBRHD-L$DNXT>,R0 ; GET LISTHEAD ADDRESS MINUS OFFSET
APRAL2:				;
10$:				;
	MOV	L$DNXT(R0),R0	; GET NEXT ENTRY
	BEQ	80$		; IF EQ DONE WITH ALLOCATION
	BIT	#LD$RSV,L$DFLG(R0) ; APR RESERVED ?
	JMP	20$(R4)		; BRANCH ON CONDITION CODES
	BNE	50$		; IF NE CHECK APRS
20$:	BR	30$		; CHECK IF LIBRARY ABSOLUTE
	BNE	10$		; BYPASS, ALREADY RESERVED
30$:				;
	BIT	#LD$REL,L$DFLG(R0) ; RELOCATABLE LIBRARY ?
	JMP	40$(R4)		; DISPATCH ON CONDITION CODES
	BEQ	50$		; CHECK APRS FOR ABS LIBRARY
40$:	BR	10$		; DEFER PIC ALLOCATION
	BEQ	10$		; IF EQ BYPASS ABS LIBRARY
	MOV	L$DMXV(R0),R1	; GET TOP ADDRESS
	BIT	#<LD$CLS!LD$SCL>,L$DFLG(R0) ; PART OF CLUSTER?
	BEQ	45$		; IF EQ NO
	CALL	FNDCLS		; FIND CLUSTER GROUP
	TST	R2		; APR SPECIFIED?
	BPL	900$		; IF PL	YES
	MOV	$CURCL,R1	; GET ADDR OF CLUSTER
	MOVB	C$LMSK(R1),R1	; GET APR INDEX
	ASL	R1		; SHIFT TO WORD INDEX
	MOV	CL$SIZ(R1),R1	; GET 4KW SIZE
	BR	46$
45$:
	SUB	L$DSA(R0),R1	; COMPUTE LENGTH-1
46$:
	CMP	R1,(SP)		; THIS LIBRARY MAX?
	BLO	10$		; IF LO NO
	MOV	R1,(SP)		; SET NEW MAX
	MOV	R0,2(SP)	; SAVE ENTRY ADDRESS
	BR	10$		; GET NEXT ENTRY
50$:				;
	MOV	L$DSA(R0),R1	; GET STARTING ADDRESS
	BIT	#MP$SY,$SWTCH	; TARGET SYSTEM MAPPED?
	BEQ	560$		; IF EQ, NO...
	CLR	R5		;
	BIT	#LD$SUP,L$DFLG(R0) ; SUPERVISOR LIBRARY?
	BEQ	55$		; IF EQ NO
	INC	R5		; SET AS SUPERVISOR LIBRARY
55$:
	BIT	#<LD$CLS!LD$SCL>,L$DFLG(R0) ; PART OF CLUSTER LIBRARY
	BEQ	580$		; IF EQ NO
	CALL	FNDCLS		; FIND CLUSTER GROUP
	TST	R2		; APR SPECIFIED?
	BMI	570$		; IF MI, NO...DEFAULT TAKEN
	BIT	#LD$RSV,L$DFLG(R0) ; APR RESERVED?
	BNE	540$		; IF NE YES
	BIT	#LD$REL,L$DFLG(R0) ; RELOCATABLE LIBRARY?
	BNE	560$		; IF NE NO
540$:
	MOV	R2,-(SP)	; SAVE APR
	MOV	R1,R2		; COPY BASE ADRRESS
	CALL	CVAPR		; CONVERT TO APR
	CMP	R2,(SP)+	; APRS THE SAME?
	BEQ	560$		; IF EQ YES
	MOV	#<S$V2*400!E$R102>,R1 ; CONFLICTING BASE ADDRESSES
	CALL	$ERMSG		; OUTPUT DIAGNOSTIC
560$:
	JMP	115$		;
570$:
	MOV	$CURCL,R3	; GET ADDRESS OF CURRENT CLUSTER
	MOV	R1,R2		; GET BASE ADDRESS
	CALL	CVAPR		; CONVERT TO APR
	MOV	R2,R1		; SAVE APR
	MOVB	R1,C$LAPR(R3)	; SAVE BASE APR
	MOVB	C$LMSK(R3),R2	; GET LENGTH MASK
	CALL	CVLAP2		; FIND SPACE
	BR	590$		;
580$:
	CALL	CVLAPR		; CONVERT TO APR SPAN
590$:
	BEQ	110$		; IF EQ, RESERVE APRS
	JMP	ERXT		; IF NE, NO...
80$:				;
	MOV	(SP)+,R2	; RETRIEVE LENGTH OF MAX PIC
	MOV	(SP)+,R0	; RETRIEVE ADDRESS OF MAX.
	JMP	90$(R4)		; DISPATCH ON COND. CODES
	BR	901$
90$:	NOP			;
	BNE	91$
901$:
	JMP	POPEX		; ALLOCATED ALL LIBRARIES...EXIT
;+
; NOTE:
;
; What is done here is properly allocate all APRS necessary for PIC
; libraries which have not had the APR allocated via the option during
; Phase 2 processing. For instance, if a PIC Super-mode library is
; specified with an APR, the 'LD$RSV' bit is set and further, if a
; User-mode library is specified with no APR specified, the 'LD$RSV'
; bit is not set. When processing occurs, R5 which is used as the
; offset for Super-mode/User-mode APR allocation, is left in its
; previous state regardless of the type of library currently being
; processed. The following code will check the library type and
; make the required adjustment to R5 regardless of the order of
; library specification or whether an APR had been reserved.
;-
91$:
	CLR	R5		; ASSUME A USER-MODE LIBRARY
	BIT	#LD$SUP,L$DFLG(R0) ; IS THIS A SUPER-MODE LIBRARY?
	BEQ	92$		; IF EQ, NO...USER-MODE LIBRARY
	INC	R5		; FLAG AS A SUPER-MODE LIBRARY REQUEST
92$:
	CALL	CVAPR		; CONVERT TO APR INDEX
	BIT	#<LD$CLS!LD$SCL>,L$DFLG(R0) ; PART OF CLUSTER?
	BEQ	910$		; IF EQ NO
	CALL	FNDCLS		; FIND CLUSTER GROUP
	TST	R2		; APR SPECIFIED?
	BMI	904$		; IF MI, NO...DEFAULT REQUESTED
900$:
	ASR	R2		; CONVERT TO ADDRESS
	ROR	R2		;
	ROR	R2		;
	ROR	R2		;
	ADD	R2,L$DMXV(R0)	; RELOCATE MAX ADDRESS
	MOV	R2,L$DCUR(R0)	; SET NEW CURRENT BASE
	MOV	R2,L$DSA(R0)	; SET NEW BASE
	ADD	R2,L$DHGV(R0)	; RELOCATE WINDOW 0 TOP ADDRESS
	BIS	#LD$RSV,L$DFLG(R0) ; WE'VE ALREADY RESERVED APR FOR 1ST ENTRY
				; IN CLUSTER GROUP - SO SET FOR EACH MEMBER
	JMP	10$		;
904$:
	MOV	$CURCL,R2	; GET ADDRESS OF CURRENT CLUSTER GROUP
	MOVB	C$LMSK(R2),R2	; GET APR MASK INDEX
910$:
	CLR	R1		; SET INITIAL APR
	MOVB	APRMP(R2),R2	; GET APR MAPPING
	BMI	100$		; IF MI AT TOP OF MEMORY
95$:				;
	INC	R1		; INCREMENT APR NUMBER
	ROLB	R2		; ROTATE MAP
	BPL	95$		; IF PL GO AGAIN
100$:				;
	MOV	R1,TEMP		; SAVE APR NUMBER
	BIT	#ID$ATA,$SWTCH	; BUILDING AN I/D TASK?
	BEQ	101$		; IF EQ, NO...
	BIT	#LD$TYP,L$DFLG(R0) ; IS THIS A DATA COMMON?
	BEQ	101$		; IF EQ, NO...LIBRARY
	BITB	R2,APRD(R5)	; IF NE, YES...CHECK AGAINST THE D-SPACE APRS
	BR	102$
101$:
	BITB	R2,APR(R5)	; IS THIS I-SPACE APR SET AVALIABLE?
102$:
	BEQ	105$		; IF EQ, YES
	RORB	R2		; SHIFT MAP
	BCC	103$
	JMP	ERXT		; IF C/S NO ROOM
103$:
	DEC	R1		; DECREMENT APR
	BR	100$		; GO AGAIN
105$:	BIT	#ID$ATA,$SWTCH	; BUILDING AN I/D TASK?
	BEQ	109$		; IF EQ, NO
	BIT	#LD$TYP,L$DFLG(R0) ; IS THIS A DATA COMMON?
	BNE	109$		; IF NE, YES
	TST	L$DAPR(R0)	; LIBRARY D-SPACE RESERVED?
	BMI	109$		; IF MI, NO (OLD LIBRARY)
	BEQ	109$		; IF EQ, NO D-SPACE RESERVED FOR LIBRARY
	MOV	R1,-(SP)	; SAVE R1
	MOV	R2,-(SP)	; SAVE R2
	MOV	L$DAPR(R0),R2	; SET UP TO CHECK DAPR MASK
	BIT	#1,R2		; ORIGINAL PIC APRS THAT HAVE TO BE SHIFTED UP?
	BEQ	1055$		; IF EQ, NO - BITMASK SETTING, SO LEAVE ALONE
1050$:	ROLB	R2		; SHIFT
	BPL	1050$		; KEEP SHIFTING TILL UP THERE
1055$:
	SUB	R1,TEMP		; ANY APR SHIFT?
	BEQ	107$		; IF EQ NO, JUST CHECK DAPR MASK
	MOV	TEMP,R1		; SET UP SHIFT COUNTER
106$:	RORB	R2		; SHIFT MASK
	DEC	R1		; UPDATE COUNTER
	BNE	106$		; IF NE, CONTINUE SHIFTING
107$:	MOV	R2,L$DAPR(R0)	; RESET DAPR MASK
	BITB	R2,APRD(R5)	; IS THIS D-SPACE APR SET AVAILABLE?
	BNE	11102$		; JMP TO ERXT (11102$ IS JUST A BRIDGE)		;LMP157
108$:	MOV	(SP)+,R2	; RESTORE R2					;**-1
	MOV	(SP)+,R1	; RESTORE R1
109$:	MOV	R1,T$APR	; SAVE APR NUMBER
	ASR	R1		; CONVERT APR TO 4K ADDRESS
	ROR	R1		;
	ROR	R1		;
	ROR	R1		;
110$:				;
	BIT	#ID$ATA,$SWTCH	; BUILDING AN I/D TASK?
	BEQ	111$		; IF EQ, NO...
	BIT	#LD$TYP,L$DFLG(R0) ; IS THIS A DATA COMMON?
	BEQ	1110$		; IF EQ, NO - LIBRARY
	BISB	R2,APRD(R5)	; RESERVE THE D-SPACE APRS
	BR	115$
1110$:	TST	L$DAPR(R0)	; LIBRARY D-SPACE RESERVED?
	BMI	111$		; IF MI, NO (OLD LIBRARY)
	MOV	L$DAPR(R0),R3	; CHK IN CASE ENTRY VIA 110$-PIC LIB W/BASE APR	;LMP157
	BIT	#1,R3		; ORIGINAL PIC APRS THAT HAVE TO BE SHIFTED UP?	;LMP157
	BEQ	11103$		; IF EQ, NO - BITMASK SETTING, SO LEAVE ALONE	;LMP157
11101$:	ROLB	R3		; SHIFT						;LMP157
	BPL	11101$		; KEEP SHIFTING TILL UP THERE			;LMP157
	BITB	R3,APRD(R5)	; MAKE SURE WE CAN REALLY USE THESE		;LMP157
11102$:	BNE	ERXT		; IF NE, NO					;LMP157
	MOV	R3,L$DAPR(R0)	; UPDATE LIBRARY D-SPACE RESERVATION		;LMP157
11103$:										;LMP157
	BISB	L$DAPR(R0),APRD(R5) ; RESERVE THE REQUESTED D-SPACE APRS
111$:
	BISB	R2,APR(R5)	; RESERVE THE I-SPACE APRS
115$:				;
	BIT	#<LD$CLS!LD$SCL>,L$DFLG(R0) ; BUT IS THIS  PART OF A CLUSTERED L
	BEQ	116$		; IF EQ, NO...FORGET THE REST...
	MOV	$CURCL,R3	; GET CURRENT CLUSTER ADDRESS
	TSTB	C$LAPR(R3)	; APR ALREADY ESTABLISHED?
	BPL	116$		; IF PL, YES DON'T OVERRIDE
	MOVB	T$APR,C$LAPR(R3) ; NO, RECORD THE LOWEST APR
116$:
	TST	R5		; SUPERVISOR MODE LIBRARY?
	BNE	117$		; IF NE YES
	BIT	#ID$ATA,$SWTCH	; WE DOING AN I/D BUILD?
	BEQ	1165$		; IF EQ, NO...SET I-SPACE LIMITS ONLY
	BIT	#LD$TYP,L$DFLG(R0) ; IF NE, YES, BUT IS THIS A DATA COMMON?
	BEQ	1160$		; IF EQ, NO...IT'S A LIBRARY
	CMP	R1,HGHAD+2	; THIS ADDRESS LOWEST ??
	BHIS	117$		; IF HIGHER OR SAME, NO
	MOV	R1,HGHAD+2	; SET NEW UPPER LIMIT
	BEQ	117$		; BUT IF EQ, DON'T BACK IT OFF...
	DEC	HGHAD+2		; BACK OFF UPPER LIMIT
	BR	117$
1160$:	TST	L$DAPR(R0)	; LIBRARY D-SPACE RESERVED?
	BMI	1165$		; IF MI, NO (OLD LIBRARY)
	BEQ	1165$		; IF EQ, NO D-SPACE RESERVED FOR LIBRARY
	MOV	R1,-(SP)	; SAVE R1
	MOV	R2,-(SP)	; SAVE R2
	MOV	L$DAPR(R0),R2	; GET DAPR BIT MASK TO CALC LOWEST APR USED
	CLR	R1		; INITIALIZE DAPR (AVAILABLE) APR COUNT
1161$:	BIT	#1,R2		; SHIFTED ALL THE WAY DOWN YET?
	BNE	1162$		; IF NE, YES
	RORB	R2		; SHIFT DOWN ANOTHER APR IN BIT MASK
	INC	R1		; UP THE (AVAILABLE) APR COUNT
	BR	1161$		; GO AGAIN
1162$:	ASR	R1		; CONVERT APR TO 4K ADDRESS
	ROR	R1		;
	ROR	R1		;
	ROR	R1		;
	CMP	R1,HGHAD+2	; THIS D-SPACE ADDRESS LOWEST ??
	BHIS	1164$		; IF HIGHER OR SAME, NO
	MOV	R1,HGHAD+2	; SET NEW UPPER LIMIT
	BEQ	1164$
	DEC	HGHAD+2		; BACK OFF UPPER LIMIT
1164$:	MOV	(SP)+,R2	; RESTORE R2
	MOV	(SP)+,R1	; RESTORE R1
1165$:
	CMP	R1,HGHAD	;++041 THIS ADDRESS LOWEST?
	BHIS	117$		;++041 IF HIS NO
	MOV	R1,HGHAD	;++041 SET NEW UPPER LIMIT
	BEQ	117$		; IF EQ AT LOW LIMIT
	DEC	HGHAD		; DECREMENT HIGH ADDRESS BOUND
117$:				;++041
	MOV	R1,L$DCUR(R0)	; SET CURRENT BASE
	MOV	R1,L$DSA(R0)	; SET STARTING ADDRESS
	BIT	#MP$SY,$SWTCH	; MAPPED SYSTEM?
	BEQ	118$		; IF EQ NO
	BIT	#LD$REL,L$DFLG(R0) ; LIBRARY RELOCATABLE?
	BEQ	118$		; IF EQ NO
	BIT	#LD$RSV,L$DFLG(R0) ; APR RESERVED?
	BNE	118$		; IF NE YES
	BIS	#LD$RSV,L$DFLG(R0) ; RESERVE APRS NOW
	ADD	R1,L$DMXV(R0)	; RELOCATE TOP ADDRESS
	ADD	R1,L$DHGV(R0)	; RELOCATE WINDOW 0 TOP ADDRESS
118$:				;
	JMP	@DSPVCT(R4)	; DISPATCH OFF FLAG

	PURE.D			; READ-ONLY D-SPACE

	.WORD	APRAL2		; GET NEXT ENTRY
DSPVCT:	.WORD	APRAL		; GET NEXT PIC ALLOCATION
	.WORD	APRAL		; ...

	PURE.I			; READ-ONLY I-SPACE

ERXT:
	MOV	R0,R2		; COPY ENTRY ADDRESS
	TST	(R2)+		; POINT TO LIBRARY NAME
	MOV	#<S$V2*400!E$R65>,R1 ; GET ERROR/SEVERITY
	CALL	$ERMSG		; FATAL-NO RETURN

	.DSABL	LSB
POPEX:				;
	BISB	APR,$APRMP	; RECORD THE I-SPACE APR REQUIREMENTS
	MOVB	SUPAPR,$APRSP	;
	BISB	APRD,$APRDM	; RECORD THE D-SPACE APR REQUIREMENTS
	CALL	VSALO		; RECORD THE VSECT APR REQUIREMENTS
	BIT	#EX$TSK,$MEMFL	;++041 EXTEND TASK IMAGE?
	BNE	10$		;++041 IF NE YES
	TST	$PARSZ		;++041 SYSTEM CONTROLLED PARTITION?
	BNE	20$		;++041 IF NE NO
10$:				;++041
	MOV	HGHAD,$HGHAD	;++041 RESET HIGH ADDRESS LIMIT
	MOV	HGHAD+2,$HGHAD+2 ; RESET HIGH D-SPACE ADDRESS LIMIT
20$:				;++041
	RETURN			;

;
; CONVERT ADDRESS IN R2 TO APR NUMBER
;

CVAPR:				;
	BIC	#17777,R2	; TRUNCATE TO 4K
	ASL	R2		; BIT 15 TO C
	ROL	R2		; BITS 15 - 13 TO 2 - 0
	ROL	R2		;
	ROL	R2		;
	RETURN			;

;
; CONVERT STARTING ADDRESS IN R1 AND MAX. LENGTH TO APR SPAN
;
; INPUT:
;	R1 - STARTING ADDRESS
;	R0 - ADDRESS LABEL BLOCK
;
; OUTPUT:
;	R2 - APRS NEEDED

; 	C=1 - APRS NOT AVAILABLE
; 	C=0 - APRS AVAILABLE
;

CVLAPR:
	MOV	R1,R2		; SET STARTING ADDRESS
	CALL	CVAPR		; CONVERT  TO APR NUMBER
	MOV	R2,R1		; SAVE APR
	MOV	L$DMXV(R0),R2	; GET MAX VIRTUAL TASK ADDRESS
	SUB	L$DSA(R0),R2	; GET LENGTH
	CALL	CVAPR		; CONVERT TO APR INDEX
CVLAP2:
	MOVB	APRMP(R2),R2	; GET APR MAPPING
10$:
	DEC	R1		; DECREMENT APR NUMBER
	BLT	20$		; IF LT MAP POSITIONED FOR TEST
	ASLB	R2		; SHIFT MAP
	BCS	30$		; IF C/S NO ROOM FOR LIBRARY
	BR	10$		; GO AGAIN
20$:
	MOV	L$DSA(R0),R1	; GET STARTING ADDRESS
	BIT	#ID$ATA,$SWTCH	; BUILDING AN I/D TASK?
	BEQ	25$		; IF EQ, NO...
	BIT	#LD$TYP,L$DFLG(R0) ; IS THIS A DATA COMMON?
	BEQ	24$		; IF EQ, NO...I/D LIBRARY
	BITB	R2,APRD(R5)	; IF NE, YES...CHECK AGAINST THE D-SPACE APRS
	BR	30$
24$:
	TST	L$DAPR(R0)	; LIBRARY D-SPACE RESERVED?
	BMI	25$		; IF MI, NO (OLD LIBRARY)
	MOV	L$DAPR(R0),TEMP	; GET READY FOR CHECK
	BIC	#1,TEMP		; IGNORE APR 0 RESERVATION
	BITB	TEMP,APRD(R5)	; CHECK REQUESTED APRS AGAINST D-SPACE APRS
	BNE	30$		; IF NE, CAN'T RESERVE D-APRS SO QUIT NOW
25$:
	BITB	R2,APR(R5)	; IS THIS I-SPACE APR SET AVALIABLE?
30$:
	RETURN			;


;
; FNDCLS - FIND THE CLUSTER GROUP LIBRARY IS IN.
;
; INPUT:
;	R0 - ADDRESS OF LIBRARY DISCRIPTOR
; OUTPUT:
;	R2 - APR USED
;	$CURCL - ADDRESS OF CLUSTER
;	CLEAR LD$CLS IF PROCESSING FIRST LIBRARY IN CLUSTER
;	REASON = THE INSTALL TASK DOES NOT SET UP WINDOWS
;		 FOR LIBRARIES THAT ARE PART OF A "CLUSTER"
;		 BY CLEARING LD$CLS, WE ARE FORCING INSTALL
;		 TO ESTABLISH THE WINDOW (MAPPING) FOR THE
;		 DEFAULT LIBRARY.
;
FNDCLS:
	SAVRG			; SAVE NON-VOLITILE REGISTERS
	MOV	R0,-(SP)	; SAVE R0
	MOV	R1,-(SP)	; SAVE R1
	MOV	#$CLSHD,R1	; GET CLUSTER LISTHEAD ADDRESS
10$:
	MOV	(R1),R1		; GET ADDRESS OF NEXT CLUSTER
	BEQ	40$		; IF EQ END OF CLUSTER
	CALL	$CVRL		; CONVERT TO REAL
	MOV	R0,R4		; SAVE ADDRESS
	MOV	R0,$CURCL	; SET CLUSTER ADDRESS
	MOV	(SP)+,R1	; RESTORE R1
	MOV	(SP)+,R0	; RESTORE R0
	MOVB	C$LAPR(R4),-(SP) ; GET APR
	MOVB	C$LCNT(R4),R3	; GET LIBRARY COUNT FROM CLUSTER
	MOV	R3,-(SP)	; SAVE LIBRARY COUNT
	TST	(R4)+		; MOVE POINTER
20$:
	CMP	(R4)+,(R4)+	; MOVE TO NEXT LIBRARY IN CLUSTER
	CMP	L$DNME(R0),(R4)	; MATCH?
	BNE	25$		; IF NE NO
	CMP	L$DNME+2(R0),2(R4) ; MAYBE
	BEQ	30$		; IF EQ YES
25$:
	DEC 	R3		; END OF CLUSTER?
	BGT	20$		; IF GT NO - CHECK NEXT LIBRARY
	CMP	(SP)+,(SP)+	; REMOVE LIBRARY COUNT AND APR FROM STACK
	MOV	R0,-(SP)	; SAVE R0
	MOV	R1,-(SP)	; SAVE R1
	MOV	$CURCL,R1	; GET CURRENT CLUSTER ADDRESS
	BR	10$		; CHECK NEXT CLUSTER
30$:
	CMP	R3,(SP)+	; MATCH ON FIRST LIBRARY IN CLUSTER?
	BNE	35$		; IF NE NO
	BIC	#LD$CLS,L$DFLG(R0) ; FOR INSTALL FORGET THAT ITS CLUSTER
	BIS	#LD$SCL,L$DFLG(R0) ; BUT WE HAVE TO REMEMBER ITS A CLUSTER
	MOV	R0,C$LDSC-C$LNME(R4)  ; SAVE LIBRARY DESCRIPTOR ADDRESS
	CMP	L$DLDZ(R0),L$DMXZ(R0) ; IS THE FIRST LIBRARY OVERLAID?
	BNE	37$		; IF NE YES
	BIS	#1,C$LOFF-C$LNME(R4) ; INDICATE NON-OVERLAID FIRST LIBRARY
	BR	37$		;
35$:
	CMP	L$DLDZ(R0),L$DMXZ(R0) ; IS THIS AN OVERLAID LIBRARY?
	BEQ	60$		; IF EQ NO - ERROR
	TST	L$DLDZ(R0)	; IF SO, IS THE ROOT NULL
	BNE	50$		; IF NE, NO...ROOT MUST BE NULL!
	BIT	#LD$RES,L$DFLG(R0) ; IS LIBRARY MEMORY-RESIDENT OVERLAID?
	BEQ	70$		   ; IF EQ, NO...ELEMENT IS NOT BUILT
				   ; MEMORY-RESIDENT OVERLAID
37$:
	MOVB	(SP)+,R2	; PUT APR INTO R2
	RETURN			;
40$:
	MOV	#<S$V2*400!E$R103>,R1 ; LIBRARY NOT IN CLUSTER
45$:
	MOV	R0,R2		; GET ADDRESS OF LIBRARY
	TST	(R2)+		; ADJUST POINTER TO NAME FIELD
47$:
	CALLR	$ERMSG		; FATAL ERROR
50$:
	MOV	#<S$V2*400!E$R105>,R1 ; OVERLAID LIB. MUST HAVE NULL ROOT
	BR	45$		; FATAL ERROR EXIT...
60$:
	MOV	#<S$V2*400!E$R104>,R1 ; ILLEGAL CLUSTER CONFIGURATION
	BR	47$
70$:
	MOV	#<S$V2*400!E$R107>,R1 ; CLUSTER LIBRARY ELEMENT IS NOT
	BR	45$		; MEMORY-RESIDENT OVERLAID.


	.ENDC

;+
; Subroutine VSALO
;
; This routine scans the VSECT listhead and allocates the APRs
; necessary for the requested virtual sections.
;
; This routine is called after the task's library requests have been
; processed so that there will not be an APR allocation conflict while
; assigning/reserving the library request APR requirements.
;
; This allows for the flexibility of overlapping virtual sections
; and libraries, but prevents the Fortran Virtual array from attempting
; to overmap the task's address space.
;
; Inputs:
;	$VSCHD	::= Virtual Section listhead
;
; Outputs:
;	The VSECT APR requirements are recorded in the task APR bitmap
;
;-
;
	V$LNK=0				; LINK TO NEXT VSECT ENTRY
	V$NAM=2				; RAD50 VSECT NAME, FIRST HALF
	V$BAS=6				;   "     "     "   SECOND HALF
	V$LEN=10			; LENGTH OF VSECT
	V$PHY=12			; PHYSICAL MEMORY REQUIREMENT
;
	PURE.I
;
VSALO:
	MOV	#$VSCHD,R0		; GET VSECT LISTHEAD ADDRESS
	CLR	R3			; ASSUME CONVENTIONAL TASKBUILD
	BIT	#ID$ATA,$SWTCH		; BUILDING AN I/D TASK ??
	BEQ	10$			; IF EQ, NO....CONVENTIONAL BUILD
	MOV	#2,R3			; IF NE, YES...BIAS FOR I/D TASK
10$:
	MOV	(R0),R0			; GET FIRST ENTRY
	BEQ	50$			; IF EQ, DONE...
	MOV	V$BAS(R0),R2		; GET BASE ADDRESS
	ADD	V$LEN(R0),R2		; CALCULATE THE HIGH VIRTUAL ADDRESS
	CMP	R2,HGHAD(R3)		; IS THIS THE NEW I- OR D-SPACE
					; UPPER ADDRESS LIMIT?
	BLOS	20$			; IF LOWER OR SAME, NO...
	MOV	R2,HGHAD(R3)		; IF HIGHER, YES...SAVE IT
	BEQ	20$			; IF EQ, ALREADY AT LOWER LIMIT
	DEC	HGHAD(R3)		; BACK OFF HIGH BOUNDARY
20$:
	MOV	V$BAS(R0),R2		; GET BASE ADDRESS
	CALL	CVAPR			; CONVERT TO APR NUMBER
	MOV	R2,R1			; AND SAVE IT FOR LATER
	MOV	V$LEN(R0),R2		; GET LENGTH OF THIS SECTION
	DEC	R2			; BACK OFF BY ONE BYTE
	CALL	CVAPR			; CONVERT TO APR NUMBER
	MOVB	APRMP(R2),R2		; GET APR BITMAP VALUE
30$:
	DEC	R1			; DECREMENT APR NUMBER
	BLT	40$			; IF LT, BITMAP IS POSITIONED
	ASLB	R2			; SHIFT BITMAP
	BR	30$			; CONTINUE...
40$:
	BISB	R2,$APRMP(R3)		; ALLOCATE I- OR D-SPACE VSECT APRS
	BR	10$			; GET NEXT VSECT ENTRY...
50$:
	RETURN


;+
; Convert starting address in R1 and maximum length to APR span
;
; This routine is called when building a library and the starting APR
; and the length, in APRs must be known if the library being built is
; linked against another library or common. If the task being built
; is not a library, then the APR requirements are deferred until the
; actual task image physical and virtual memory limits have been calculated
; by SGALO during Phase 4.
;
; Inputs:
;	R1 - Starting address
;	R2 - Ending address
;
; Output:
;	R1 - Starting address
;	R2 - APRS needed
;
; 	C=1 - APRS not available
; 	C=0 - APRS available
;-

APRSPN:
	MOV	R1,-(SP)	; SAVE STARTING ADDRESS
	MOV	R2,-(SP)	; SAVE ENDING ADDRESS
	BNE	5$			; IF NE, USER-CONTROLLED PART.
	MOV	2(SP),(SP)		; IF EQ, WE HAVE A SYSTEM-CONTROLLED
					; PARTITION. WE HAVE TO ONLY RESERVE
					; 1 APR FOR NOW, SO WE WILL COPY THE
					; STARTING ADDRESS, BUMP IT TO THE NEXT
					; APR ADDRESS-1, THEN CONTINUE...
	ADD	#<20000-1>,(SP)
5$:

	MOV	2(SP),R2	; GET STARTING ADDRESS
	CALL	CVAPR		; CONVERT  TO APR NUMBER
	MOV	R2,R1		; SAVE APR
	MOV	(SP),R2		; GET MAX VIRTUAL TASK ADDRESS
	SUB	2(SP),R2	; CALCULATE LENGTH OF TASK
	CALL	CVAPR		; CONVERT TO APR INDEX
	MOVB	APRMP(R2),R2	; GET APR MAPPING
10$:
	DEC	R1		; DECREMENT APR NUMBER
	BLT	20$		; IF LT MAP POSITIONED FOR TEST
	ASLB	R2		; SHIFT MAP
	BCS	30$		; IF C/S NO ROOM FOR LIBRARY
	BR	10$		; GO AGAIN
20$:
	TST	(SP)+		; DUMP THE ENDING ADDRESS
	MOV	(SP)+,R1	; AND RESTORE THE STARTING ADDRESS
	BITB	R2,APR(R5)	; IS THIS I-SPACE APR SET AVALIABLE?
	RETURN
30$:
	TST	(SP)+		; DUMP THE ENDING ADDRESS
	MOV	(SP)+,R1	; AND RESTORE THE STARTING ADDRESS
	RETURN			;



	.END
