	.TITLE	BLDSG
	.IDENT	/18.07/
;
; COPYRIGHT (c) 1991 BY DIGITAL EQUIPMENT CORPORATION
; ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE IS FURNISHED  UNDER A LICENSE AND MAY BE USED OR
; COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;
; D. N. CUTLER/C. MONIA	16-JAN-74
;
; MODIFIED FOR RSX-11M/M-PLUS V4.0/V2.0 BY:
;
;	J. M. LAWLER
;	C. B. PETROVIC
;
; MODIFIED BY:
;
;	C. B. PETROVIC	26-FEB-82	18.01
;		CBP039		ADD CORRECT .PSECT DEFINITIONS TO
;				ALLOW TKB TO BE LINKED AS AN I/D TASK.
;
;	C. B. PETROVIC	20-MAR-85	18.02
;		CBP163		ADD SECOND DEFAULT TASK SWITCH WORD
;				IN PREPARATION FOR THE ELIMINATION
;				OF THE SLOW TASK BUILDER (STK) AND
;				ADD THE /SL SWITCH.
;
;	L. M. PETERSON	13-APR-88	18.03	SPR13603
;		LMP110		CORRECT ERROR WITH PAR, /MU COMBINATION
;
; MODIFIED FOR RSX-11M-PLUS AND MICRO/RSX V4.3 BY:
;
;	L. M. PETERSON	28-FEB-89	18.05	LMP131
;		ALLOW TASKS WITH (TASK) MEMORY RESIDENT OVERLAYS TO BE 
;		EXTENDED (WITH THE $EXTM DIRECTIVE)
;
;	L. M. PETERSON	1-OCT-89	18.06	LMP140A
;		CHANGE FILE TYP .TSK TO .EXE IF RUNNING ON VAX-11
;
; MODIFIED FOR RSTS/E V10.1  BY:
;	C. M. KATZ	19-APR-91	18.07
;		ADD RSTS CONDITIONAL CODE
;
;
; MONITOR DEPENDENT ROUTINE TO BUILD SEGMENT DESCRIPTION
;
; MACRO LIBRARY CALLS
;

	.MCALL	GLUN$S,FEAT$S,FEADF$
	FEADF$
	.MCALL	CSI$
	CSI$

;
; LOCAL DATA
;
	IMPURE			; READ/WRITE D-SPACE

$MRFLG::.BLKW	1		;MORE INPUT FILES FLAG
$SCANR::.BLKW	1		;ADDRESS OF SCANNING ROUTINE
	PURE.D			; READ-ONLY D-SPACE
CRFEX:	.RAD50	/CRF/		;++036 CREF FILE EXTENSION
ODTDS:	.WORD	ODTDR-ODTDV	;DEVICE DESCRIPTOR
	.WORD	ODTDV		;
	.WORD	ODTFN-ODTDR	;DIRECTORY DESCRIPTOR
	.WORD	ODTDR		;
	.WORD	ODTFE-ODTFN	;FILENAME DESCRIPTOR
	.WORD	ODTFN		;
ODTDV:	.ASCII	/LB/		;DEVICE
	.IF	NDF,R$RSTS
ODTDR:	.ASCII	/[1,1]/		;DIRECTORY
	.IFF
ODTDR:	.ASCII	//		;RSTS DIRECTORY
	.ENDC
ODTFN:	.ASCII	/ODT.OBJ/	;FILENAME
ODTFE:				;REF LABEL

ODIDFN:	.ASCII	/ODTID.OBJ/	; 'ODT' FOR I & D TASKS
ODIDFE:				; REFERENCE LABEL FOR FILENAME LENGTH
	.EVEN

;
; CSI SWITCH BLOCK POINTERS
;

SWPT:	.WORD	$TSKSW		; TASK FILE
	.WORD	$MAPSW		; MAP FILE
	.WORD	$STBSW		; STB FILE

;
; FILE SWITCH VALUE POINTERS
;

SWTB:	.WORD	TS$KF		; TASK FILE SPECIFIED
	.WORD	MA$PF		; MAP FILE SPECIFIED
	.WORD	ST$BF		; SYMBOL TABLE FILE SPECIFIED

;
; OUTPUT FILE NAMEBLOCK VECTORS (REAL) - ADJACENCY ASSUMED
;
	IMPURE			; READ/WRITE D-SPACE

TSKNM:	.BLKW	1		; TASK FILE
MAPNM:	.BLKW	1		; MAP FILE
STBNM:	.BLKW	1		; STB FILE


;+
; **-$BLDSG-BUILD SEGMENT DESCRIPTION
;
; THIS ROUTINE IS CALLED TO CREATE THE SEGMENT DESCRIPTION FOR THE
; TASK THAT IS CURRENTLY BEING BUILT. A COMMAND INPUT LINE IS READ
; AND THE OUTPUT FILE SPECIFICATIONS ARE INITIALIZED. THE FIRST INPUT
; FILE SPECIFICATION IS OBTAINED AND PLACED IN THE OBJECT FILE RECORD
; BLOCK. IF THE "MP" SWITCH IS SPECIFIED, THEN $MULSG IS CALLED TO
; CREATE A MULTI-SEGMENT TASK DESCRIPTION. ELSE $SNGSG IS CALLED TO
; CREATE A SINGLE SEGMENT TASK DESCRIPTION.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	NONE.
;-
	PURE.I			; READ-ONLY I-SPACE

$BLDSG::SAVRG			;SAVE NONVOLITILE REGISTERS
	CALL	$INITL		;INITIALIZE
	MOV	$DFLBS,$LBSWT	; SET DEFAULT SYSTEM LIBRARY SWITCH WORD
	BIS	$DFMAP,$SWTCH	; SET DEFAULT MAP FILE FORMAT SWITCHES
	MOV	$INIPT,R4	; GET FDB ADDRESS
	MOV	#T$MSIZ,R1	;GET SIZE OF TEMP BUFFER NEEDED
	CALL	$ALBLK		;ALLOCATE TEMP BUFFER
	MOV	R0,R5		;SAVE BUFFER ADDRESS
10$:	CALL	$GTCML		;GET NEXT COMMAND INPUT LINE
	BCC	15$		;IF CC CONTINUE
	JMP	$QUIT		;LOGICAL EOF-QUIT NOW
15$:	MOV	R5,R1		;GET ADDRESS OF TEMP BUFFER
	CALL	$SYNTX		;ANALYZE SYNTAX OF LINE
	BCS	10$		;IF CS SYNTAX ERROR
	MOV	$DFTSK,R$SWTH(R4) ; SET DEFAULT TASK SWITCHES
	MOV	$DFTSO,$SWOVR	; SET DEFAULT TSK OVERFLOW SWITCHES
	MOV	$DFTSO+2,$SWOV2	; SET DEFAULT TSK OVERFLOW SWITCHES
	MOV	$DFTSO+2,$SWTCH+2 ; SET 2ND DEFAULT TASK SWITCH WORD
	.IF 	NDF,R$RSTS	;RSTS V10.1
	FEAT$S	#FE$EXE		; RUNNING ON VAX-11?
	BCS	16$		; IF CS, ASSUME NO
	CMP	#IS.SET,$DSW	; VAX-11?
	BNE	16$		; IF NE, NO
	MOV	#$DFNB,R3	; GET DEFAULT NAME BLOCK
	MOV	#^REXE,N.FTYP(R3) ; CHANGE DEFAULT FILE TYPE TO EXE
	.ENDC			;RSTS V10.1
16$:
	MOV	#$DFNB,F.DFNB(R4) ; SET DEFAULT NAME BLOCK POINTER
	MOV	#-6,R3		; SET LOOP COUNT *2
20$:
	MOV	SWPT+6(R3),R$SWBK(R4) ; POINT TO CSI SWITCH BLOCK
	CLR	$TSKNM+6(R3)	; CLEAR NAME BLOCK POINTER
	CLR	TSKNM+6(R3)	; CLEAR REAL ADDRESS
	MOV	R4,R0		; GET FDB ADDRESS
	ADD	#F.FNB,R0	; POINT TO FILE NAME BLOCK
	MOV	#S.FNB/2,R1	; SET SIZE OF BLOCK
25$:				;
	CLR	(R0)+		; CLEAR NAMEBLOCK
	SOB	R1,25$		;
	MOV	R5,R1		; SET TEMP BUFFER ADDRESS
	MOV	R4,R0		; SET FDB ADDRESS
	CALL	$SCANO		; SCAN FOR OUTPUT FILE
	BCS	35$		; IF C/S NO FILE
	CALL	PARSE		;++036 PARSE FILE NAME
	BCS	35$		;++036 IF C/S ERROR
30$:				;
	BIS	SWTB+6(R3),$SWTCH ; SET FILE-PRESENT SWITCH
35$:				;
	CMP	#-6,R3		; PROCESSING THE TASK IMAGE FILE
	BNE	351$		; IF NE, NO SOME OTHER FILE
	BIT	#SW$CM,C.MKW1(R5) ; DID WE SEE A /CM OR /-CM
	BNE	353$		; IF NE, YES - USER'S CMD LINE OVERRIDES REST
	BIT	#SW$CM,$DFTSK	; TKB BUILT WITH CM AS DEFAULT?
	BNE	353$		; IF NE, YES - TKB BUILD DEFAULT OVERRIDES FEAT$
	.IF 	NDF,R$RSTS	;RSTS V10.1
	FEAT$S	#FE$CMO		; COMPAT. MODE ALIGNMENT FOR RESIDENT OVERLAYS?
	BCS	353$		; IF CS, ASSUME NO
	CMP	#IS.SET,$DSW	; COMPAT. MODE?
	BNE	353$		; IF NE, NO
	BIS	#SW$CM,R$SWTH(R4) ; SET FOR COMPATIBILITY MODE
	.ENDC			;RSTS V10.1
353$:	BIT	#SW$MU,R$SWTH(R4) ; /MU SPECIFIED ?
	BEQ	352$		; IF EQ, NO
	BIC	#SE$GA,$SWOVR	; YES, THEN ALWAYS FORCE /SG
	BIS	#MU$LTI,$SWOVR	; AND RECORD FOR POSTERITY (P2POP)
352$:	BIT	#XH$DR,C.MKW1(R5) ; DID WE SEE A /XH OR /-XH
	BEQ	351$		; IF EQ, NO
	BIC	#NO$XH,$SWOVR	; CLR OUT ANY DEFAULTS
	BIT	#XH$DR,C.MKW2(R5) ; DID WE SEE A /-XH
	BNE	351$		; IF NE, NO
	BIS	#NO$XH,$SWOVR	; REMEMBER THAT WE SAW /-XH
351$:	MOV	$PRVAP,R0	; GET FIRST APR FOR PRIVILEGED TASK
	BEQ	360$		; IF EQ OK
	SUB	#4,R0		; SUBTRACT LOWER LIMIT
	BMI	350$		; IF MI ERROR
	CMP	R0,#M$XAPR	; APR TOO BIG?
	BLOS	360$		; IF LOS NO
350$:				;
	MOV	#<S$V2*400!E$R3>,R1 ; GET ERROR/SEVERITY CODE
	MOV	R5,R2		; COPY ADDRESS OF CSI BLOCK
	ADD	#C.FILD,R2	; OFFSET TO FILENAME DESCRIPTOR
	CALL	$ERMSG		; REPORT FATAL ERROR
360$:				;
	CALL	$ALELO		; ALLOCATE ELEMENT DESCRIPTOR FOR OUTPUT
	CALL	$LCKPG		; LOCK PAGE IN MEMORY
	MOV	R0,TSKNM+6(R3)	; SAVE REAL ADDRESS OF NAMEBLOCK
	MOV	R1,$TSKNM+6(R3)	; SAVE VIRTUAL ADDRESS OF NAMEBLOCK
	CMP	R3,#-4		;++036 PROCESSING MAP FILE?
	BNE	43$		;++036 IF NE NO
	MOV	#<MA$PF!CR$EF>,R0 ;++036 GET MAP, CREF FILE FLAGS
	BIC	$SWTCH,R0	;++036 TEST FLAGS
	BNE	43$		;++036 IF NE NO CREF PRODUCED
	CLR	$CRODV		;++036 CLEAR CREF OUTPUT DEVICE
	CLR	$CROUN		;++036 CLEAR CREF OUTPUT UNIT
	MOV	F.DFNB(R4),-(SP) ;++036 SAVE ADDRESS OF DEFAULT NAMEBLOCK
	MOV	F.DSPT(R4),R0	;++036 GET ADDRESS OF DATASET POINTER
	MOV	2(R0),-(SP)	;++036 SAVE ADDRESS OF STRING
	BITB	#<FD.SQD!FD.REC>,F.RCTL(R4) ;++036 SEQUENTIAL OR RECORD DEVICE
	BNE	361$		; IF NE YES
	BITB	#FD.DIR,F.RCTL(R4) ; OR, IS IT NON-DIRECTORY:
	BEQ	361$		; IF EQ YES
	SUB	#6*2,SP		; ALLOCATE GLUN BUFFER ON STACK
	MOV	SP,R0		; STORE ADDRESS IN R3
	GLUN$S	F.LUN(R4),R0	; GET LUN INFORMATION
	MOV	G.LUCW(R0),R0	; GET LUN CHARACTERISTICS WORD
	ADD	#6*2,SP		; RESTORE STACK
	BIT	#FD.OSP,R0	; IS OUTPUT DEVICE SPOOLED?
	BEQ	40$		; IF EQ NO
361$:
	BIS	#SP$OL,$SWTCH	;++036 CANCEL REQUEST FOR SPOOLING
	MOV	F.FNB+N.DVNM(R4),$CRODV ;++036 SAVE OUTPUT DEVICE
	MOV	F.FNB+N.UNIT(R4),$CROUN ;++036 SAVE OUTPUT UNIT
	MOV	#$MAPTM,F.DFNB(R4) ;++036 SET ADDRESS OF TEMP MAP FILE NAMEBLOCK
	MOV	F.DSPT(R4),R0	;++036 GET ADDRESS OF DATASET
	MOV	#$MAPTD,R1	;++036 GET ADDRESS OF TEMP DSPT
	MOV	(R1)+,(R0)+	;++036 SET DEVICE STRING LENGTH
	MOV	(R1)+,(R0)+	;++036 SET ADDRESS OF STRING
	CALL	PARSE		;++036 PARSE CREF TEMP FILE
	BCC	37$		;++036 IF C/C PARSE SUCCEEDED
	BIC	#CR$EF,$SWTCH	;++036 RESET CREF SWITCH
	BR	42$		;++036
37$:				;++036
	MOV	$MAPNM,R1	;++036 GET VIRTUAL ADDRESS OF MAP FILE
	CALL	$UNLPG		;++036 UNLOCK PAGE
	MOV	R1,$MPFIL	;++036 SAVE VIRTUAL ADDRESS OF REAL DESCRIPTOR
	CALL	$ALELO		;++036 ALLOCATE AN ELEMENT DESCRIPTOR FOR OUTPUT
	CALL	$LCKPG		;++036 LOCK DESCRIPTOR IN MEMORY
	MOV	R0,MAPNM	;++036 SAVE REAL ADDRESS OF NEW DESCRIPTOR
	MOV	R1,$MAPNM	;++036 SAVE VIRTUAL ADDRESS
40$:				;++036
	CLR	F.FNB+N.FVER(R4) ;++036 FORCE NEW VERSION
	MOV	CRFEX,F.FNB+N.FTYP(R4) ;++036 REPLACE WITH CREF EXTENSION
	CALL	$ALELO		;++036 ALLOCATE DESCRIPTOR FOR CREF FILE
	MOV	R1,$CRFNM	;++036 SAVE VIRTUAL ADDRESS OF DESCRIPTOR
42$:				;++036
	MOV	F.DSPT(R4),R0	;++036 GET DATASET POINTER
	MOV	(SP)+,2(R0)	;++036 RESTORE ADDRESS OF STRING
	MOV	(SP)+,F.DFNB(R4) ;++036 RESTORE ADDRESS OF DFNB
43$:				;++036
	CLR	R$SWTH(R4)	; INITIALIZE SWITCH WORD
	ADD	#S.FNB,F.DFNB(R4) ; POINT TO NEXT DEFAULT NAME BLOCK
	ADD	#2,R3		; INCREMENT COUNT
	BGE	44$		; IF GE DONE
	JMP	20$		; GO AGAIN
44$:				;
	MOV	TSKNM,R0	; GET REAL ADDRESS OF TASK NAMEBLOCK
	BEQ	45$		; IF EQ NONE
	MOV	STBNM,R1	; GET REAL ADDRESS OF STB NAMEBLOCK
	BEQ	45$		; IF EQ NONE
	MOV	#^C<SW$PI!SW$NH>,R3 ; GET COMPLEMENT OF /PI, /NH FLAGS
	MOV	E$LSWT(R1),R2	; GET STB FILE SWITCH WORD
	BIC	R3,R2		; ISOLATE SWITCHES
	BIS	R2,E$LSWT(R0)	; TRANSFER SWITCHES TO TASK FILE
	MOV	E$LSWT(R0),R2	; GET TASK FILE SWITCH WORD
	BIC	R3,R2		; ISOLATE "/PI" SWITCH
	BIS	R2,E$LSWT(R1)	; TRANSFER TO STB FILE
45$:				;
	MOV	#$TSKNM,R0	; GET POINTER TO V/A OF TASK NAMEBLOCK
	MOV	#3,R2		; SET LOOP COUNT
46$:				;
	MOV	(R0)+,R1	; GET NAMEBLOCK VIRTUAL ADDRESS
	BEQ	47$		; IF EQ NONE SPECIFIED
	CALL	$UNLPG		; UNLOCK PAGE
47$:				;
	SOB	R2,46$		; REPEAT
	MOV	#$INPSW,R$SWBK(R4) ; SET ADDRESS OF INPUT SWITCH BLOCK
	MOV	$DFINP,R$SWTH(R4) ; SET DEFAULT INPUT FILE SWITCHES
	MOV	#$SCANI,$SCANR ; SET ADDRESS OF SCANNING ROUTINE
	CLR	$MRFLG		; CLEAR MORE FILES FLAG

;
; AT THIS POINT F.DFNB(R4) POINTS TO INPUT FILE
; DEFAULT NAME BLOCK
;
	CALL	$NXTFL		; GET FIRST INPUT FILE
	BCC	50$		;
	MOV	#<S$V2*400!E$R2>,R1 ; ASSUME NO INPUT FILES
	CLR	R2		; SET DUMMY PARAMETER BLOCK ADDRESS
	CALL	$ERMSG		; FATAL-NO RETURN
50$:				;
	JMP	$BCNTL		; BUILD SEGMENT DESCRIPTORS

;
; BUILD FILE NAME BLOCK FOR DEBUGGING AID AND SYSTEM LIBRARY FILES
;
;	THIS ROUTINE IS ENTERED VIA A JUMP FROM '$BCNTL' AFTER
;	ALL SEGMENT DESCRIPTORS HAVE BEEN BUILT. R3-R5 ARE INTACT.
;

$BLDSF::			;
	MOV	#$FRHD,R0	; GET ADDRESS OF FREE POOL HEADER
	MOV	#T$MSIZ,R1	; GET SIZE OF BLOCK TO RELEASE
	MOV	R5,R2		; GET ADDRESS OF BLOCK
	CALL	$RLCB		; RELEASE CORE BLOCK
	MOV	F.DFNB(R4),-(SP) ; SAVE DEFAULT NAMEBLOCK POINTER
	MOV	F.DSPT(R4),-(SP) ; SAVE DATASET POINTER
	MOV	$TSKNM,R1	; GET VIRTUAL ADDRESS OF TASK NAMEBLOCK
	BEQ	10$		; IF EQ-NO TASK FILE
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	BIT	#SW$DA,E$LSWT(R0) ; DEBUGGING AID REQUESTED?
	BEQ	10$		; IF EQ NO
	BIT	#ID$ATA,$SWTCH	; IS THIS AN I $ D TASKBUILD??
	BEQ	5$		; IF EQ, NO...JUST USE THE OLD 'ODT'
	MOV	#ODIDFE-ODIDFN,ODTDS+10 ; SET IN THE FILENAME LENGTH
	MOV	#ODIDFN,ODTDS+12 ; AS WELL AS THE FILENAME 'ODTID.OBJ' ADDRESS
5$:
	MOV	#ODTDS,F.DSPT(R4) ; SET ODT DATA DESCRIPTOR
	MOV	R4,R0		; FETCH FDB POINTER
	CALL	$PRFND		; PARSE/FIND FILE
	BCS	20$		; IF C/S PARSE/FIND FAILURE
	MOV	#SW$DA,R$SWTH(R0) ; SPECIFY DEBUGGING AID
	CALL	$ALELD		; ALLOCATE AN ELEMENT DESCRIPTOR
	MOV	$RTSEG,R0	; GET ADDRESS OF ROOT SEGMENT
	ADD	#<S$GELT/2>,R0	; POINT TO ELEMENT DESCRIPTOR LISTHEAD
	MOV	#E$LNXT,R2	; GET LINK-NEXT OFFSET
	CALL	$LNKVM		; LINK ELEMENT AS LAST ON LIST
10$:
	TST	$LIBNM		; DEFAULT LIBRARY SPECIFIED?
	BNE	15$		; IF NE, YES
	MOV	#$DFLIB,F.DFNB(R4) ; SET SYSTEM LIBRARY DFNB
	MOV	#$DSPLB,F.DSPT(R4) ; SET DATA STRING POINTER
	MOV	R4,R0		; GET FDB ADDRESS
	CLR	$LIBNM		; ASSUME PARSE/FIND FAILURE
	CALL	$PRFND		; PARSE/FIND THE FILE
	BCS	15$		; IF C/S PARSE/FIND FAILED
	CALL	$ALELD		; ALLOCATE ELEMENT DESCRIPTOR
	MOV	R1,$LIBNM	; SAVE VIRTUAL ADDRESS OF LIBRARY DESCRIPTOR
	MOV	$LBSWT,E$LSWT(R0) ; SET LIBRARY FILE SWITCH WORD
15$:				;
	MOV	(SP)+,F.DSPT(R4) ; RESTORE DATASET POINTER
	MOV	(SP)+,F.DFNB(R4) ; RESTORE DEFAULT NAMEBLOCK POINTER
	RETURN			;
20$:				;
	MOV	R$NAME(R4),R2	; GET NAME STRING ADDRESS
	MOV	#<S$V2*400!E$R57>,R1 ; PARSE/FIND FAILURE
	CALL	$ERMSG		; FATAL-NO RETURN

;++036
;++036 PARSE OUTPUT FILE SPECIFICATION
;++036

PARSE:				;++036
	MOV	R4,R0		;++036 GET ADDRESS OF FDB
	CALL	$PARSE		;++036 PARSE FILE
	BCC	10$		;++036 IF C/C OK
	MOV	#<S$V0*400!E$R11>,R1 ;++036 GET ERROR/SEVERITY
	MOV	R$NAME(R4),R2	;++036 FILE NAME
	CALL	$ERMSG		;++036 OUTPUT ERROR MESSAGE
	BR	20$		;
10$:				;++036
	CMP	F.FNB+N.DVNM(R0),#"NL ; NULL DEVICE?
	CLC			; ASSUME NO
	BNE	30$		; IF NE NO
20$:				;
	SEC			; SET CARRY
30$:				;
	RETURN			;++036


	.END
