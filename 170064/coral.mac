	.TITLE	CORAL
	.IDENT	/00.01/
;
;		COPYRIGHT (c) 1983 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD
;	 MASSACHUSETTS.  ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE  IS  FURNISHED  UNDER  A LICENSE AND MAY BE USED
; AND  COPIED  ONLY IN  ACCORDANCE WITH THE TERMS OF SUCH LICENSE
; AND WITH  THE INCLUSION  OF THE ABOVE  COPYRIGHT  NOTICE.  THIS
; SOFTWARE  OR ANY OTHER  COPIES  THEREOF, MAY NOT BE PROVIDED OR
; OTHERWISE MADE  AVAILABLE TO ANY OTHER PERSON.  NO TITLE TO AND
; OWNERSHIP OF THE SOFTWARE IS HEREBY TRANSFERRED.
;
; THE INFORMATION  IN THIS DOCUMENT IS SUBJECT  TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT  BY  DIGITAL
; EQUIPMENT CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF
; ITS SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.
;
;
;
; D. N. CUTLER/C. MONIA 23-SEP-76
;
; MODIFIED BY:
;
;	C. B. PETROVIC	26-FEB-82	00.01
;		CBP039		ADD CORRECT .PSECT DEFINITIONS TO
;				ALLOW TKB TO BE LINKED AS AN I/D TASK.
;
;
; FIRST FIT DYNAMIC CORE ALLOCATION ROUTINES
;
; DATA STRUCTURES
;
; FREE BLOCK LIST HEADER:
;
;	FREEHD:	.WORD	NEXT	;POINTER TO NEXT FREE BLOCK OR 0
;		.WORD	0	;ALWAYS ZERO
;
; FREE BLOCK:
;
;	FREEBK:	.WORD	NEXT	;POINTER TO NEXT OR 0
;		.WORD	SIZE	;SIZE OF BLOCK IN BYTES
;
; NOTE: THE FREE BLOCK LIST IS ORDERED BY THE CORE ADDRESS OF THE BLOCKS
;	THEMSELVES. THIS IS SO GARBAGE COLLECTION AND BLOCK AGGLOMERATIO
;	CAN BE PERFORMED WITH LITTLE OVERHEAD.
;+
; **-$RLCB-RELEASE CORE BLOCK
;
; THIS SUBROUTINE IS CALLED TO RELEASE A CORE BLOCK TO THE FREE LIST.
; THE FREE LIST IS SEARCHED UNTIL THE PROPER SLOT IS FOUND AND THE
; BLOCK IS MERGED INTO THE FREE LIST. IF THE BLOCK BEING RELEASED
; CAN BE AGGLOMERATED WITH A BLOCK ALREADY IN THE FREE LIST, THEN THE
; BLOCKS ARE AGGLOMERATED AND THE NEW BLOCK IS MERGED INTO THE FREE
; LIST.
;
; INPUTS:
;
;	R0=ADDRESS OF FREE BLOCK LIST HEAD.
;	R1=SIZE OF BLOCK TO RELEASE IN BYTES.
;	R2=ADDRESS OF BLOCK TO RELEASE.
;
; OUTPUTS:
;
;	NONE.
;-

	PURE.I			; READ-ONLY I-SPACE

$RLCB::	SAVRG			;SAVE NONVOLITILE REGISTERS
	ADD	#3,R1		;ROUND UP TO NEXT 2 WORD BOUNDRY
	BIC	#3,R1		;CLEAR EXCESS BITS
	BEQ	5$		;IF EQ VERGESSEN!!!
1$:	MOV	(R0),R3		;GET ADDRESS OF NEXT IN LIST
	BEQ	2$		;IF EQ END OF CHAIN
	CMP	R2,R3		;COMPARE ADDRESSES
	BLO	2$		;IF LO FOUND SLOT
	MOV	R3,R0		;SET NEW PREVIOUS ADDRESS
	BR	1$		;GO AGAIN
2$:	MOV	R3,(R2)		;ASSUME NO AGGLOMERATION
	MOV	R2,R4		;CALCULATE ADDRESS OF NEXT BLOCK
	ADD	R1,R4		;ADD IN BLOCK SIZE
	CMP	R3,R4		;COMPARE ADDRESSES
	BNE	3$		;IF NE DO NOT MERGE BLOCKS
	MOV	(R3)+,(R2)	;SET NEW FORWARD LINK
	ADD	(R3),R1		;ADJUST SIZE
3$:	MOV	R2,(R0)		;ASSUME NO AGGLOMERATION
	MOV	R0,R4		;CALCULATE ADDRESS OF NEXT BLOCK
	ADD	2(R0),R4	;ADD IN BLOCK SIZE
	CMP	R2,R4		;COMPARE ADDRESSES
	BNE	4$		;IF NE DO NOT MERGE
	MOV	(R2),(R0)	;SET NEW FORWARD LINK
	ADD	2(R0),R1	;ADJUST SIZE
	MOV	R0,R2		;SET NEW BASE ADDRESS OF BLOCK
4$:	MOV	R1,2(R2)	;SET SIZE OF BLOCK
5$:	RETURN			;

;+
; **-$RQCB-REQUEST CORE BLOCK
;
; THIS ROUTINE IS CALLED TO REQUEST A CORE BLOCK FROM THE FREE LIST.
; THE SELECTION IS ALWAYS FIRST FIT.
;
; INPUTS:
;
;	R0=ADDRESS OF FREE BLOCK LIST HEAD.
;	R1=SIZE OF BLOCK REQUESTED IN BYTES.
;		FOR COMPATIBILITY, R1 MAY BE EITHER POSITIVE OR NEGATIVE.
;		IN EITHER CASE THE MAGNITUDE OF R1 IS THE SIZE OF THE BLOCK.
;
; OUTPUTS:
;
;	C=1 IF REQUEST CANNOT BE FULFILLED.
;	C=0 IF REQUEST IS SATISFIED.
;		R0=ADDRESS OF REQUESTED CORE BLOCK.
;-

$RQCB::				;
	TST	R1		; SIZE NEGATIVE?
	BPL	10$		; IF PL NO
	NEG	R1		; GET ABSOLUTE VALUE OF ALLOCATION SIZE
10$:				;
	ADD	#3,R1		; ROUND UP TO 4-BYTE BOUNDARY
	BIC	#3,R1		; DISGARD EXCESS BITS
	BEQ	30$		; IF EQ EXIT NOW
20$:				;
	MOV	R0,R2		; COPY ADDRESS OF PREVIOUS
	MOV	(R2),R0		; GET ADDRESS OF NEXT
30$:				;
	SEC			; ASSUME AT END OF LIST
	BEQ	50$		; IF EQ AT END
	CMP	2(R0),R1	; THIS HOLE BIG ENOUGH?
	BLO	20$		; IF LO NO
	BEQ	40$		; IF EQ HOLE JUST FITS
	SUB	R1,2(R0)	; DECREASE HOLE SIZE
	ADD	R1,(R2)		; POINT TO NEXT HOLE
	MOV	(R2),R2		; GET ADDRESS OF NEXT HOLE
	MOV	2(R0),2(R2)	; SET LENGTH OF HOLE
40$:				;
	MOV	(R0),(R2)	; RELINK HOLES
50$:				;
	RETURN			;

	.END
