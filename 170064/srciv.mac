	.TITLE	SRCIV
	.IDENT	/02.02/
;
; COPYRIGHT (c) 1985 BY DIGITAL EQUIPMENT CORPORATION
; ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE IS FURNISHED  UNDER A LICENSE AND MAY BE USED OR
; COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;
; C. MONIA 27-NOV-74
;
; MODIFIED BY:
;
;	C. B. PETROVIC	26-FEB-82	02.01
;		CBP039		ADD CORRECT .PSECT DEFINITIONS TO
;				ALLOW TKB TO BE LINKED AS AN I/D TASK.
;
;
;	C. B. PETROVIC	20-MAR-85	02.02
;		CBP163		ADD SECOND DEFAULT TASK SWITCH WORD
;				IN PREPARATION FOR THE ELIMINATION
;				OF THE SLOW TASK BUILDER (STK) AND
;				ADD THE /SL SWITCH.
;
;
; VIRTUAL MEMORY SEARCH AND INSERT SUBROUTINES
;
; EQUATED SYMBOLS
;
; SYMBOL ENTRY OFFSETS
;

	.ASECT

.=0

S$YNXT:	.BLKW	1		; OFFSET TO NEXT (0=NONE)
S$YPRV:	.BLKW	1		; OFFSET TO PREVIOUS (0=NONE)
S$YUP:	.BLKW	1		; LINK UP (0=NONE)
S$YM:	.BLKW	1		; SYMBOL NAME (WORD 1)
	.BLKW	1		; SYMBOL NAME (WORD 2)
	.BLKW	1		; SYMBOL EXTENSION

;
; B-TREE NODE OFFSETS
;

	.ASECT

B$HOL::	.BLKW	1		; OFFSET TO FIRST HOLE (0=NONE)
B$HCT::	.BLKW	1		; COUNT OF HOLES (0=NONE)
B$DAT::	.BLKW	1		; OFFSET TO NODE DATA AREA

;
; HISTORY LIST ENTRY OFFSETS
;

	.ASECT

.=0

H$ISYM::.BLKW	1		; OFFSET TO INSERTION POINT
H$NODE::.BLKW	1		; VIRTUAL ADDRESS OF NODE ON PATH
H$LBR::	.BLKW	1		; VIRTUAL ADDRESS OF LEFT BROTHER
H$RBR::	.BLKW	1		; VIRTUAL ADDRESS OF RIGHT BROTHER
H$FINS::.BLKW	1		; INSERTION POINT OFFSET OF FATHER NODE
H$FNOD::.BLKW	1		; VIRTUAL ADDRESS OF FATHER NODE

;
; LISTHEAD OFFSETS
;

	.ASECT

.=0

L$RNOD::.BLKW	1		; POINTER TO ROOT NODE (0=NONE)
L$ESIZ::.BLKW	1		; ENTRY SIZE (BYTES)
L$NSIZ::.BLKW	1		; NODE SIZE (BYTES)

;
; LOCAL DATA (ADJACENCY ASSUMED).
;
	IMPURE			; READ/WRITE D-SPACE

LHEAD:	.BLKW	1		; POINTER TO B-TREE LISTHEAD
HPTR:	.BLKW	1		; HISTORY LIST POINTER
SYM:	.BLKW	1		; POINTER TO SYMBOL TO BE INSERTED
TSYM:	.BLKW	1		; POINTER TO SYMBOL FOR DOWN-TREE INSERTION
IFLG:	.BLKB	1		; INSERTION CONTROL FLAG
	.BLKB	1		; RESERVED BYTE
RNEW:	.BLKW	1		; REAL ADDRESS OF NEW NODE
VNEW:	.BLKW	1		; VIRTUAL ADDRESS OF NEW NODE
VUP:	.BLKW	1		; VIRTUAL ADDRESS OF LINK-UP
EHIST:				; END OF HISTORY LIST
	.BLKW	6.*4		; SEARCH HISTORY LIST
	.WORD	0		; START OF HISTORY LIST
	.WORD	0		; ...
	.WORD	0		; ...
HIST:	.WORD	0		; ...

;+
; VIRTUAL MEMORY SEARCH AND INSERT SUBROUTINES
;
; THESE SUBROUTINES ARE CALLED TO PERFORM THE FOLLOWING
; FUNCTIONS:
;
;	'$SRCIV' - SEARCH A SYMBOL TABLE FOR EDIT OR INSERTION
;	'$ISYMV' - INSERT A SYMBOL IN THE TABLE
;	'$SRCHV' - SEARCH FOR A SPECIFIED ENTRY
;	'$ISEDV' - PERFORM AN ORDERLY EDIT OF THE TABLE
;	'$ISEDP' - PERFORM EDIT FROM SPECIFIED ENTRY IN TABLE
;
; THESE ROUTINES CONSTRUCT AND OPERATE ON A TABLE RESIDING IN
; VIRTUAL MEMORY. THE TABLE IS STRUCTURD AS AN 'M-WAY'
; TREE AS DESCRIBED IN KNUTH VOL. 3, SECTION 6.2.4. SPECIFICALLY
; THE B-TREE STRUCTURE IS IMPLEMENTED WITH TWO-WAY SPLITTING
; AND ROTATION TO EITHER THE LEFT OR RIGHT BROTHER
;
; DATA STRUCTURES:
;
;	TABLE LISTHEAD
;
; LHEAD:	.WORD	ROOT	; VIRTUAL ADDRESS OF ROOT NODE (0=NONE)
;		.WORD	ESIZE	; SIZE OF EACH ENTRY (BYTES)
;		.WORD	NSIZE	; SIZE OF EACH B-TREE NODE (BYTES)
;
;	B-TREE NODE FORMAT
;
;	NODE HEADER
;
; NODE:		.WORD	FIRST	; OFFSET TO FIRST ENTRY (0=NONE)
;		.WORD	LAST	; OFFSET TO LAST ENTRY (0=NONE)
;		.WORD	LNKUP	; VIRTUAL ADDRESS OF LINK UP (0=NONE)
;		.WORD	-1	; DUMMY KEY
;		.WORD	-1	; ...
;		.WORD	-1	; KEY EXTENSION
; B$HOL:	.WORD	HOLE	; OFFSET TO FIRST FREE HOLE (0=NONE)
; B$HCT:	.WORD	COUNT	; NUMBER OF FREE HOLES
; B$DAT:	.BLKW	NSIZ-20	; DATA AREA (INCLUDING EXTENSION)
;
; THE DATA AREA WITHIN EACH NODE IS SUBDIVIDED INTO FIXED
; LENGTH BLOCKS EQUAL IN SIZE TO THE LENGTH OF AN ENTRY.
; UNOCCUPIED BLOCKS (HOLES) ARE FORWARD LINKED VIA THE
; FIRST WORD. ENTRIES ARE LINKED LINEARLY IN LEXICAL ASCENDING
; ORDER AND HAVE THE FORMAT DESCRIBED BELOW. OBSERVE THAT
; THE ENTRY LISTHEAD HAS THE SAME STRUCTURE AS THE ENTRY
; ITSELF TO FACILITATE THE DETECTION OF ENDPOINTS.
;
; LINKAGES ARE VIA OFFSETS RELATIVE TO THE START OF
; THE NODE.
;
;	SYMBOL TABLE ENTRY FORMAT
;
; S$YNXT:	.WORD	NEXT	; OFFSET TO NEXT (0=NONE)
; S$YPRV:	.WORD	PREV	; OFFSET TO PREVIOUS (0=NONE)
; S$YUP:	.WORD	LNKUP	; VIRTUAL ADDRESS OF LINK UP (0=NONE)
; S$YM:		.WORD	SYMHI	; RADIX-50 SYMBOL NAME (WORD 1)
;		.WORD	SYMLO	; RADIX-50 SYMBOL NAME (WORD 2)
;		.WORD	SYMEXT	; OPTIONAL KEY EXTENSION
; 		.BLKW	ESIZE-14 ; ENTRY DATA (WITH EXTENSION)
;
; OFFSETS ARE RELATIVE TO THE START OF THE NODE
;
;-
;+
; **-$ISEDV-PERFORM ORDERLY EDIT OF B-TREE
; **-$ISEDP-PERFORM EDIT OF B-TREE FROM SPECIFIED ENTRY
;
; INPUTS:
;
;	R0=REAL ADDRESS OF B-TREE LISTHEAD
; IF ENTRY IS AT $ISEDP:
;
;	R1=ADDRESS OF STARTING SYMBOL (SEE 'DATA STRUCTURES')
;
;
; OUTPUTS:
;
;	C/CLEAR:
;
;	R0=REAL ADDRESS OF NEXT SYMBOL IN LEXICAL SEQUENCE
;	R1=VIRTUAL ADDRESS OF NEXT SYMBOL IN LEXICAL SEQUENCE
;
;	CO-ROUTINE CALL IS MADE TO THE CALLER. TO TERMINATE
;	THE EDIT, THE CALLER SHOULD REMOVE THE RETURN
;	ADDRESS FROM THE STACK.
;
;	C/SET: NO FURTHER ENTRIES IN TREE
;
;	R1 IS CLEARED
;
;	EXIT IS VIA 'RETURN'
;
;
; R3 - R5 ARE PRESERVED
;
; SUBROUTINE $ISEDV IS CALLED TO INITIALIZE A SCAN OF
; ALL ENTRIES IN A B-TREE IN LEXICAL SEQUENCE. IF A VALID
; ENTRY IS FOUND, THE ROUTINE EXECUTES A CO-ROUTINE CALL TO THE
; CALLER WITH THE C-BIT CLEAR. SUBSEQUENT CO-ROUTINE CALLS
; WILL RETURN THE REMAINDER OF THE ENTRIES IN SEQUENCE. THE
; CALLER MAY TERMINATE THE SCAN BY REMOVING THE RETURN
; ADDRESS FROM THE STACK. IF NO FURTHER ENTRIES REMAIN, THE
; ROUTINE EXITS WITH C-SET VIA A 'RETURN'.
;
; SUBROUTINE $ISEDP IS CALLED TO INITIALIZE A SCAN OF
; ALL ENTRIES FROM THE SPECIFIED KEY TO THE END
; OF THE TABLES. IN ALL OTHER RESPECTS, IT IS IDENTICAL TO
; $ISEDV.
;
;-
	PURE.I			; READ-ONLY I-SPACE

$ISEDV::			;
	MOV	#HIST-6-6,R1	; GET ADDRESS OF NULL SYMBOL ENTRY
$ISEDP::			;
	CALL	$SRCIV		; BUILD HISTORY LIST
	MOV	R4,-(SP)	; SAVE R4
	MOV	HPTR,R4		; GET HISTORY LIST POINTER
10$:				;
	MOV	(R4),R1		; GET OFFSET TO SYMBOL
	BNE	20$		; IF NE NOT AT END OF NODE
	TST	H$NODE(R4)	; AT END OF HISTORY LIST?
	BEQ	60$		; IF EQ YES
	ADD	#H$FINS,R4	; POP HISTORY LIST ENTRY
	BR	10$		; GO AGAIN
20$:				;
	ASR	R1		; CONVERT TO VIRTUAL OFFSET
	ADD	H$NODE(R4),R1	; CONVERT TO VIRTUAL ENTRY ADDRESS
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
30$:				;
	MOV	R4,HPTR		; SAVE HISTORY LIST POINTER
	MOV	(SP)+,R4	; RESTORE R4
	CLC			; SET SUCCESS
	CALL	@(SP)+		; CALL THE CALLER
	MOV	R4,-(SP)	; SAVE R4
	MOV	HPTR,R4		; GET HISTORY LIST POINTER
	MOV	H$NODE(R4),R1	; GET VIRTUAL ADDRESS OF NODE
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	ADD	(R4)+,R0	; OFFSET TO ADDRESS OF CURRENT ENTRY
40$:				;
	MOV	(R0),-(R4)	; PUSH OFFSET TO NEXT
	MOV	S$YUP(R0),R1	; GET VIRTUAL ADDRESS OF LINK UP
	BEQ	10$		; IF EQ NO LINK UP
	CMP	-(R4),-(R4)	; PUSH DUMMY ENTRIES
	MOV	R1,-(R4)	; PUSH ADDRESS OF LINK UP
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	BR	40$		; GO AGAIN
60$:				;
	MOV	(SP)+,R4	; RESTORE R4
	SEC			; FLAG END OF TABLE REACHED
	RETURN			;

;+
; **-$ISYMV-INSERT SYMBOL IN B-TREE
;
; INPUTS:
;
;	HISTORY LIST BUILT BY $SRCIV
;
; OUTPUTS:
;
;	C/SET: NEW ROOT NODE CREATED
;
;	C/CLEAR: NEW ROOT NOT CREATED
;
; R3 - R5 PRESERVED
;
; SPECIFIED KEY IS INSERTED IN THE TREE. C-SET INDICATES
; THAT THE LISTHEAD WAS ALTERED. HENCE, THE CALLER SHOULD
; WRITE-MARK THE APPROPRIATE PAGE IF THIS DATA IS KEPT
; IN VIRTUAL MEMORY.
;
; THE INSERTION ROUTINE WILL UTILIZE ALL AVAILABLE SPACE
; IN THE LEFT OR RIGHT BROTHERS BEFORE SPAWNING A NEW
; NODE AT ANY LEVEL.
;
; PRIOR TO CALLING THIS ROUTINE $SRCIV MUST BE INVOKED TO
; BUILD THE HISTORY LIST.
;
;-
	PURE.I			; READ-ONLY I-SPACE

$ISYMV::			;
	BIT	#SL$OW,$SWTCH+2	; WE DOING A 'SLOW' BUILD?
	BEQ	5$		; IF EQ, NO...
	RETURN			; IF NE, YES...USE THE SLOW SYMBOL TABLE
				; MANAGEMENT ROUTINES...
5$:
	SAVRG			; SAVE NON-VOLATILE REGISTERS
	CLR	-(SP)		; ASSUME ROOT NOT SPLIT
	MOV	#LHEAD,R3	; POINT TO LISTHEAD STORAGE
	MOV	(R3)+,R5	; GET ADDRESS OF LISTHEAD
	MOV	(R3)+,R4	; GET HISTORY LIST POINTER
	MOV	(R3)+,R3	; GET ADDRESS OF SYMBOL TO INSERT
	MOV	L$ESIZ(R5),R1	; GET SIZE OF ENTRY
	ASL	R1		; DOUBLE ENTRY SIZE
	CALL	$ALBLK		; ALLOCATE HOLDING AREAS
	MOV	R0,TSYM		; SET ADDRESS OF TEMP. SYMBOL STORAGE
	ADD	L$ESIZ(R5),R0	; COMPUTE ADDRESS OF SYMBOL STORAGE
	MOV	R0,SYM		; SAVE ADDRESS OF SYMBOL STORAGE
	MOV	R0,R1		; COPY ADDRESS OF SYMBOL STORE
	CALL	XFREN		; COPY SYMBOL DATA
	CLR	S$YUP(R1)	; CLEAR LINK-UP
	MOV	R1,R3		; SET SYMBOL ADDRESS
10$:				;
	CLRB	IFLG		; ASSUME ROTATE/INSERT TO THE RIGHT
	MOV	H$NODE(R4),R1	; GET ADDRESS OF INSERTION NODE
	BNE	20$		; IF NE HAVE NODE
	CALL	BLDND		; BUILD NEW ROOT NODE
	MOV	(R5),S$YUP(R0)	; SET LINK-UP TO OLD ROOT
	MOV	R1,(R5)		; SET ADDRESS OF NEW ROOT
	INC	(SP)		; FLAG ROOT-SPLIT
20$:				;
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	TST	B$HOL(R0)	; ROOM TO INSERT NEW ENTRY?
	BEQ	25$		; IF EQ NO
	JMP	110$		; INSERT ENTRY, EXIT
25$:				;
	MOV	H$LBR(R4),R1	; GET ADDRESS OF LEFT BROTHER
	BEQ	30$		; IF EQ NO LEFT BROTHER
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	TST	B$HOL(R0)	; ROOM FOR AN ENTRY?
	BEQ	30$		; IF EQ NO
	INCB	IFLG		; SET ROTATION-LEFT FLAG
	MOV	H$NODE(R4),VUP	; SET VIRTUAL ADDRESS OF NEW LINK-UP
	BR	40$		; TO COMMON ROTATION CODE
30$:				;
	MOV	H$RBR(R4),R1	; GET ADDRESS OF RIGHT BROTHER
	BEQ	60$		; IF EQ NO RIGHT BROTHER
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	TST	B$HOL(R0)	; ROOM FOR ENTRY IN RIGHT BROTHER?
	BEQ	60$		; IF EQ NO, SPAWN NEW NODE
	MOV	R1,VUP		; SET VIRTUAL ADDRESS OF NEW LINK-UP

;
; COMMON ROTATION CODE
;
; THIS CODE IS ENTERED WHENEVER THERE IS SPACE FOR AN ENTRY
; WITHIN AN EXISTING BROTHER NODE. THIS SECTION OF CODE
; WILL TRANSFER THE FATHER ENTRY TO THE BROTHER NODE
; SET THE LINK-UP OF THE INSERTED ENTRY AND RELEASE
; THE SPACE WITHIN THE FATHER NODE. UPON COMPLE-
; TION, COMMON CODE FOR DISTRIBUTING SPACE WITHIN
; THE BROTHER NODES IS ENTERED. THE INSERTION PROCESS
; AUTOMATICALLY TERMINATES ON SUCCESFUL INSERTION AT THE
; LEVEL OF THE FATHER NODE
;
; OBSERVE THAT THE ROTATION PROCESS MAY ALTER THE INSERTION
; POINT OF THE FATHER (IE FOR ROTATION TO THE RIGHT).
;

40$:				;
	CALL	$WRMPG		; WRITE-MARK PAGE
	CALL	$LCKPG		; LOCK PAGE IN MEMORY
	MOV	R0,RNEW		; SAVE REAL ADDRESS OF NEW NODE
	MOV	R1,VNEW		; SAVE VIRTUAL ADDRESS OF NEW NODE
	MOV	H$FNOD(R4),R1	; GET VIRTUAL ADDRESS OF FATHER NODE
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	CALL	$WRMPG		; WRITE-MARK PAGE
	MOV	R0,R2		; COPY REAL ADDRESS
	MOV	H$FINS(R4),R3	; GET OFFSET TO INSERTION POINT
	ADD	R2,R3		; CONVERT TO ADDRESS
	DECB	IFLG		; DECREMENT ROTATION FLAG
	BNE	50$		; IF NE, ROTATION RIGHT
	CALL	GTNXT		; GET PREVIOUS ENTRY
50$:				;
	MOV	(R3),H$FINS(R4)	; SET NEW INSERTION POINT
	INCB	IFLG		; RESET INSERTION FLAG
	MOV	RNEW,R0		; GET REAL ADDRESS OF NEW
	CALL	MOVEN		; ROTATE FATHER ENTRY AND DELETE IT
	ADD	#S$YUP,R1	; POINT TO LINK-UP
	MOV	R1,-(SP)	; SAVE ADDRESS OF ENTRY+OFFSET
	MOV	(R1),R1		; GET VIRTUAL ADDRESS OF LINK-UP
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	MOV	S$YUP(R0),@(SP)+ ; SET LINK-UP OF ROTATED ENTRY
	BR	70$		; BALANCE SPACE IN BROTHERS

;
; THIS SECTION OF CODE IS ENTERED TO CREATE A NEW BROTHER
; NODE TO THE RIGHT OF THE INSERTION NODE. UPON COMPLETION
; COMMON CODE TO BALANCE SPACE BETWEEN BROTHERS IS EXECUTED
;

60$:				;
	CALL	BLDND		; CREATE A NEW NODE
	MOV	R1,VUP		; SET VIRTUAL ADDRESS OF NEW LINK-UP
	CALL	$LCKPG		; LOCK NEW PAGE IN MEMORY
	MOV	R0,RNEW		; SAVE REAL ADDRESS OF NEW BROTHER
	MOV	R1,VNEW		; SAVE VIRTUAL ADDRESS OF BROTHER

;
; COMMON CODE TO BALANCE SPACE IN BROTHER NODES:
;
; THIS SECTION OF CODE TRANSFERS ENTRIES BETWEEN THE INSER-
; TION NODE AND THE APPROPRIATE BROTHER UNTIL THE AMOUNT OF SPACE
; IN BOTH NODES IS BALANCED. BALANCE IS ACHIEVED WHEN THE NUM-
; BER OF HOLES IN THE BROTHER IS EQUAL TO OR ONE GREATER THAN
; THE NUMBER OF HOLES IN THE INSERTION NODE.
;
;

70$:				;
	MOV	H$NODE(R4),R1	; GET VIRTUAL ADDRESS OF INSERTION NODE
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	CALL	$WRMPG		; WRITE-MARK PAGE
	MOV	SYM,R1		; GET ADDRESS OF SYMBOL TO INSERT
	MOV	(R4),R2		; GET OFFSET TO INSERTION POINT
	CALL	INSKY		; LOGICALLY INSERT KEY
	MOV	R0,R2		; COPY ADDRESS OF INSERTION NODE
	MOV	R0,R3		; SET LISTHEAD ADDRESS
	MOV	RNEW,R0		; GET ADDRESS OF NEW NODE
	CALL	GTNXT		; GET NEXT ENTRY IN SEQUENCE
	CLR	-(SP)		; CLEAR PHYSICAL INSERT FLAG
80$:				;
	MOV	B$HCT(R0),-(SP)	; PUSH ENTRY COUNT OF BROTHER
	SUB	B$HCT(R2),(SP)	; SUBTRACT ENTRY COUNT OF INSERT NODE
	CMP	(SP)+,#1	; NODES BALANCED?
	BLOS	90$		; IF LOS YES
	CALL	MOVEN		; TRANSFER NEXT ENTRY IN SEQUENCE
	ADC	(SP)		; SAVE PHYSICAL INSERT FLAG
	BR	80$		; GO AGAIN

;
; THE NODES ARE NOW BALANCED. SETUP THE ENTRY TO BE
; MOVED DOWN-TREE AND INSURE THAT THE ENTRY TO BE IN-
; SERTED IS PHYSICALLY RESIDENT IN A NODE.
;

90$:				;
	MOV	TSYM,R1		; GET TEMP SYMBOL STORAGE
	CALL	MOVEN1		; MOVE THE LAST ENTRY FROM INSERT NODE
	ADC	(SP)+		; SAVE PHYSICAL INSERT FLAG, TEST FLAG
	BNE	100$		; IF NE ENTRY PHYSICALLY IN A NODE
	MOV	R2,R0		; COPY INSERT NODE ADDRESS
	CALL	RQNB		; REQUEST SPACE IN NODE
	MOV	SYM,R3		; GET ADDRESS OF SYMBOL TO INSERT
	CALL	XFREN		; TRANSFER ENTRY
	CALL	DLTKY		; LOGICALLY DELETE THIS KEY
	MOV	(R3),R2		; GET LINK NEXT
	CALL	INSKY		; LOGICALLY INSERT NEW ENTRY
100$:				;
	MOV	TSYM,R3		; GET ADDRESS OF TEMP SYMBOL STORE
	MOV	VUP,R1		; GET VIRTUAL ADDRESS OF UP
	CALL	$CVRL		; CONVERT TO REAL
	MOV	S$YUP(R3),S$YUP(R0) ; SET NEW LINK-UP
	MOV	R1,S$YUP(R3)	; SET LINK-UP OF SYMBOL
	MOV	SYM,TSYM	; SWAP STORAGE POINTERS
	MOV	R3,SYM		; ...
	MOV	VNEW,R1		; GET VIRTUAL ADDRESS OF NEW
	CALL	$UNLPG		; UNLOCK NEW
	ADD	#H$FINS,R4	; POP LIST POINTER
	JMP	10$		; GO AGAIN

;
; TERMINATE INSERTION PROCESS
;

110$:				;
	CALL	$WRMPG		; WRITE-MARK INSERTION NODE
	MOV	(R4),R2		; GET OFFSET TO INSERTION POINT
	CALL	RQNB		; REQUEST NODE ENTRY SPACE
	CALL	XFREN		; MOVE ENTRY
	CALL	INSKY		; LOGICALLY INSERT NEW KEY
	MOV	L$ESIZ(R5),R1	; GET SIZE OF ENTRY
	CMP	R3,TSYM		; AT START OF ALLOCATION
	BLO	120$		; IF LO YES
	SUB	R1,R3		; SET ADDRESS OF START
120$:				;
	MOV	#$FRHD,R0	; GET ADDRESS OF FREE POOL LISTHEAD
	MOV	R3,R2		; SET ADDRESS OF BLOCK TO RELEASE
	ASL	R1		; SET SIZE OF BLOCK
	CALL	$RLCB		; RELEASE TEMP STORAGE BLOCKS
	ROR	(SP)+		; GET ROOT-SPLIT INDICATOR
	RETURN			;

;+
; **-$SRCHV-SEARCH B-TREE FOR ENTRY
;
; INPUTS:
;
;	R0=ADDRESS OF LISTHEAD
;	R1=ADDRESS OF SYMBOL (SEE 'DATA STRUCTURES')
;
; OUTPUTS:
;
;	C/CLEAR: FOUND REQUESTED ENTRY
;
;	R0=REAL ADDRESS OF ENTRY
;	R1=VIRTUAL ADDRESS OF ENTRY
;
;	C/SET: ENTRY NOT IN TREE
;
;	R1=0
;
; R3 - R5 ARE PRESERVED
;-
	PURE.I			; READ-ONLY I-SPACE

$SRCHV::			;
	SAVRG			; SAVE NON-VOLATILE REGISTERS
	MOV	R0,R5		; COPY LISTHEAD ADDRESS
	MOV	R1,R3		; COPY ADDRESS OF SYMBOL
	MOV	(R5),R2		; GET ROOT NODE VIRTUAL ADDRESS
10$:				;
	MOV	R2,R1		; GET ADDRESS OF LINK-UP
	SEC			; ASSUME NO LINK-UP
	BEQ	20$		; IF EQ SYMBOL NOT IN LIST
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	CALL	SRCKY		; SEARCH FOR SYMBOL
	BCS	10$		; IF C/S NOT IN NODE
20$:				;
	RETURN			;

;+
; **-$SRCIV-SEARCH FOR INSERTION
;
; INPUTS:
;
;	R0=ADDRESS OF LISTHEAD (SEE 'DATA STRUCTURES')
;	R1=ADDRESS OF SYMBOL TO BE INSERTED (SEE 'DATA STRUCTURES')
;
; OUTPUTS:
;
;	SEARCH HISTORY LIST IS BUILT CONTAINING THE NODES AND
; INSERTION POINT OFFSETS FROM THE ROOT NODE TO THE
; NODE TO RECEIVE THE SYMBOL ALONG WITH THE FOLLOWING:
;
;	C-SET: SYMBOL NOT IN TABLE
;
;	C-CLEAR: SYMBOL IN TABLE
;
;	R1=VIRTUAL ADDRESS OF SYMBOL
;
; R3-R5 PRESERVED
;
; SEARCH HISTORY LIST FORMAT:
;
; THE LIST RECORDS THE VIRTUAL ADDRESS OF EACH NODE ON THE
; PATH FROM THE ROOT NODE TO THE NODE TO RECEIVE THE NEW ENTRY
; ALONG WITH THE CORRESPONDING OFFSET TO THE ENTRY AFTER THE INSERTION
; POINT.
;
; EACH ENTRY IN THE LIST HAS THE FOLLOWING FORMAT:
;
;		.
;		.
;		.
;		.WORD	INSP	; OFFSET TO INSERTION POINT
;		.WORD	NADDR	; VIRTUAL ADDRESS OF NODE CONTAINING POINT
;		.WORD	LBRO	; LEFT BROTHER
;		.WORD	RBRO	; RIGHT BROTHER
;
;-
	PURE.I			; READ-ONLY I-SPACE

$SRCIV::			;
	BIT	#SL$OW,$SWTCH+2	; WE DOING A 'SLOW' BUILD?
	BEQ	5$		; IF EQ, NO...
	RETURN			; IF NE, YES...USE THE SLOW SYMBOL TABLE
				; MANAGEMENT ROUTINES...
5$:
	SAVRG			; SAVE NON-VOLATILE REGISTERS
	MOV	#SYM+2,R5	; POINT TO LOCATION OF SYMBOL ADDRESS
	MOV	R1,-(R5)	; SAVE ADDRESS OF NEW ENTRY
	MOV	R1,R3		; COPY ADDRESS OF NEW SYMBOL
	TST	-(R5)		; POINT TO LISTHEAD STORAGE
	MOV	R0,-(R5)	; SAVE LISTHEAD ADDRESS
	MOV	(R5),R5		; GET LISTHEAD ADDRESS
	MOV	#HIST-6,R4	; SETUP POINTER TO HISTORY TABLE
	CLR	-(SP)		; CLEAR REAL ADDRESS OF CURRENT NODE
	CLR	VNEW		; CLEAR VIRTUAL ADDRESS OF FOUND SYMBOL
	MOV	(R5),R2		; GET ADDRESS OF ROOT NODE
10$:				;
	MOV	R2,R1		; GET ADDRESS OF LINK UP
	BEQ	50$		; IF EQ NO LINK UP
	MOV	R1,-(R4)	; PUSH LINK UP
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	MOV	R0,(SP)		; SAVE REAL ADDRESS
	CALL	SRCKY		; SEARCH FOR KEY
	BCS	20$		; IF C/S KEY NOT FOUND
	MOV	R1,VNEW		; SAVE VIRTUAL ADDRESS OF KEY
20$:				;
	MOV	R0,R1		; COPY REAL ADDRESS
	SUB	(SP),R1		; CONVERT TO OFFSET
	MOV	R1,-(R4)	; PUSH INSERTION POINT OFFSET
	BEQ	25$		; IF EQ AT END OF NODE
	MOV	S$YUP(R0),R1	; GET LINK-UP RIGHT
25$:				;
	MOV	R1,-(R4)	; PUSH ON LIST
	MOV	S$YPRV(R0),R1	; GET LINK-PREVIOUS OFFSET
	BEQ	30$		; IF EQ NO LINK-PREVIOUS
	ADD	(SP),R1		; CONVERT TO ADDRESS
	MOV	S$YPRV(R1),R1	; GET LINK PREVIOUS AGAIN
	ADD	(SP),R1		; CONVERT TO ADDRESS
	MOV	S$YUP(R1),R1	; GET LINK-UP LEFT
30$:				;
	MOV	R1,-(R4)	; PUSH LINK-UP LEFT
	BR	10$		; GO AGAIN
50$:				;
	SEC			; ASSUME SYMBOL NOT FOUND
	MOV	VNEW,R1		; GET VIRTUAL ADDRESS OF SYMBOL
	BEQ	60$		; IF EQ NOT FOUND
	CLC			; SET FOUND INDICATOR
60$:				;
	MOV	(R4)+,(R4)+	; ADJUST HISTORY LIST (LEAVE C BIT INTACT)
	INC	(SP)+		; CLEAN STACK
	MOV	R4,HPTR		; SAVE LIST POINTER
	RETURN			;

;
; BUILD NEW NODE
;
; THIS ROUTINE ALLOCATES A NEW B-TREE NODE AND CREATES THE
; LIST OF FREE SPACE(HOLES)
;
; INPUTS:
;
;	R5=LISTHEAD ADDRESS
;
; OUTPUTS:
;
;	R0=REAL ADDRESS OF NODE
;	R1=VIRTUAL ADDRESS OF NODE
;
;	THE FREE LIST WITHIN THE NODE IS BUILT
;
; R2 IS DESTROYED.
;

BLDND:				;
	MOV	R3,-(SP)	; SAVE R3
	MOV	L$NSIZ(R5),R1	; GET NODE SIZE (BYTES)
	CALL	$ALVRT		; ALLOCATE VIRTUAL MEMORY
	MOV	R0,-(SP)	; SAVE REAL ADDRESS
	ADD	#S$YM,R0	; OFFSET TO DUMMY NAME
	DEC	(R0)+		; SET DUMMY NAME (-1)
	DEC	(R0)+		; ...
	DEC	(R0)+		; ...
	TST	(R0)+		; POINT TO HOLE COUNT
	MOV	#B$DAT,R3	; SET OFFSET TO DATA AREA
10$:				;
	MOV	R3,R2		; SET OFFSET TO NEXT HOLE
	ADD	L$ESIZ(R5),R3	; ADD ENTRY SIZE TO OFFSET
	CMP	R3,L$NSIZ(R5)	; HOLE ENTIRELY WITHIN NODE?
	BHIS	20$		; IF HIS NO
	INC	(R0)		; INCREMENT FREE COUNT
	MOV	-(R0),-(SP)	; SAVE OFFSET TO FIRST HOLE
	MOV	R2,(R0)+	; SET NEW FIRST
	ADD	2(SP),R2	; CONVERT NEW FIRST TO ADDRESS
	MOV	(SP)+,(R2)	; LINK OLD FIRST TO NEW
	BR	10$		; GO AGAIN
20$:				;
	MOV	(SP)+,R0	; GET REAL ADDRESS OF NODE
	MOV	(SP)+,R3	; RESTORE R3
	RETURN			;

;
; LOGICALLY DELETE KEY FROM NODE
;
; INPUTS:
;
;	R2=NODE ADDRESS
;	R3=ADDRESS OF ENTRY TO BE DELETED
;
; OUTPUTS:
;
;	ENTRY IS LOGICALLY DELETED, SPACE IS NOT RELEASED
;
; ALL REGISTER CONTENTS ARE PRESERVED.
;

DLTKY:				;
	MOV	(R3)+,-(SP)	; PUSH LINK-NEXT OFFSET
	ADD	R2,(SP)		; CONVERT LINK-NEXT TO ADDRESS
	ADD	#S$YPRV,(SP)	; POINT TO LINK-PREVIOUS
	MOV	(R3),@(SP)+	; SET NEW LINK-PREVIOUS
	MOV	(R3),-(SP)	; PUSH LINK-PREVIOUS OFFSET
	ADD	R2,(SP)		; CONVERT TO ADDRESS
	MOV	-(R3),@(SP)+	; SET NEW LINK-NEXT
	RETURN			;

;
; GET NEXT/PREVIOUS ENTRY FROM NODE
;
; INPUTS:
;
;	R2=NODE ADDRESS
;	R3=ADDRESS OF CURRENT ENTRY
;	IFLG=1, GET NEXT ENTRY IN SEQUENCE
;	IFLG=0, GET PREVIOUS ENTRY IN SEQUENCE
;
; OUTPUTS:
;
;	C/CLEAR:
;
;	R3=ADDRESS OF APPROPRIATE ENTRY
;
;	C/SET: NO MORE ENTRIES IN NODE
;
;	R3=NODE ADDRESS
;
; ALL OTHER REGISTER CONTENTS ARE PRESERVED
;

GTNXT:				;
	TSTB	IFLG		; PREVIOUS WANTED?
	BNE	10$		; IF NE NO, GET NEXT
	TST	(R3)+		; STEP TO LINK-PREVIOUS
10$:				;
	MOV	(R3),R3		; GET OFFSET TO REQUESTED ENTRY
	ADD	R2,R3		; CONVERT TO ADDRESS
	CMP	R2,R3		; AT LISTHEAD?
	CLC			; ASSUME NO
	BNE	20$		; IF NE NO
	SEC			; SET C-BIT
20$:				;
	RETURN			;

;
; LOGICALLY INSERT ENTRY IN NODE
;
; INPUTS:
;
;	R0=ADDRESS OF NODE TO RECEIVE INSERT
;	R1=ADDRESS OF ENTRY TO BE INSERTED
;	R2=OFFSET TO INSERTION POINT
;
; OUTPUTS:
;
;	ENTRY IS LOGICALLY INSERTED IN NODE
;
; R2 IS DESTROYED
;

INSKY:				;
	MOV	R1,-(SP)	; COPY ADDRESS OF NEW
	SUB	R0,(SP)		; CONVERT TO OFFSET
	MOV	R2,(R1)+	; SET LINK NEXT
	ADD	R0,R2		; CONVERT LINK-NEXT TO ADDRESS
	MOV	S$YPRV(R2),(R1)	; SET LINK-PREVIOUS
	MOV	(SP),S$YPRV(R2)	; SET NEW LINK-PREVIOUS
	MOV	(R1),R2		; GET LINK-PREVIOUS
	ADD	R0,R2		; CONVERT TO ADDRESS
	MOV	(SP)+,(R2)	; SET NEW LINK NEXT
	TST	-(R1)		; POINT TO ADDRESS OF NEW
	RETURN			;

;
; MOVE ENTRY BETWEEN NODES
;
; THIS SUBROUTINE PHYSICALLY REMOVES AN ENTRY FROM A NODE
; AND ADDS IT TO A NEW NODE. THE SPACE PREVIOUSLY OCCUPIED
; IS RELEASED UNLESS THE ENTRY WAS LOGICALLY INSERTED ONLY.
;
; IF THE ENTRY WAS LOGICALLY INSERTED BUT DID NOT EXIST
; AS A PHYSICAL ENTRY (IE A NEW INSERTION IN THE TABLE) THE C-BIT
; IS SET ON EXIT. OTHERWISE, THE C-BIT IS CLEAR.
;
;
; INPUTS:
;
;	R0=ADDRESS OF NODE TO RECEIVE ENTRY
;	R2=ADDRESS OF NODE CONTAINING ENTRY
;	R3=ADDRESS OF ENTRY TO BE MOVED
;	SYM=ADDRESS OF NEW INSERT
;
; OUTPUTS:
;
; 	C/CLEAR: LOGICAL ENTRY NOT MOVED
;
;	R1=ADDRESS OF NEW ENTRY
;	R3=ADDRESS OF NEXT ENTRY(0=END OF LIST)
;
;	C/SET: LOGICAL ENTRY MOVED
;
;	R1,R3 SETUP AS ABOVE
;
; ALL OTHER REGISTERS ARE UNMODIFIED
;

	.ENABL	LSB

MOVEN:				;
	CALL	RQNB		; REQUEST SPACE FOR NEW ENTRY
	MOV	R2,-(SP)	; SAVE R2
	MOV	(R0),R2		; ASSUME ROTATION RIGHT
	TSTB	IFLG		; TEST ROTATION FLAG
	BEQ	10$		; IF EQ ROTATION RIGHT
	CLR	R2		; SET TO INSERT AT END
10$:				;
	CALL	INSKY		; INSERT NEW KEY
	MOV	(SP)+,R2	; RESTORE R2
MOVEN1:				;
	CALL	XFREN		; MOVE ENTRY DATA
	MOV	R3,-(SP)	; SAVE ADDRESS OF CURRENT
	CALL	GTNXT		; GET ADDRESS OF NEXT ENTRY
	MOV	R3,-(SP)	; SAVE ADDRESS OF NEXT
	MOV	2(SP),R3	; GET CURRENT
	CALL	DLTKY		; LOGICALLY DELETE THIS KEY
	CMP	R3,SYM		; ENTRY PHYSICALLY IN NODE?
	SEC			; ASSUME NO
	BEQ	20$		; IF EQ NO
	CALL	RLNB		; RELEASE ENTRY
	CLC			; CLEAR C-BIT
20$:				;
	MOV	(SP)+,R3	; GET ADDRESS OF NEXT
	INC	(SP)+		; CLEAN STACK
	RETURN			;

	.DSABL	LSB


;
; RELEASE SPACE FOR AN ENTRY WITHIN A NODE
;
; INPUTS:
;
;	R2=NODE ADDRESS
;	R3=ADDRESS OF ENTRY TO RELEASE
;
; OUTPUTS:
;
;	ENTRY IS RELEASED AND ADDED TO FREE LIST
;
; R3 IS DESTROYED
;

RLNB:				;
	MOV	B$HOL(R2),(R3)	; SET POINTER TO NEXT HOLE
	SUB	R2,R3		; CONVERT HOLE TO OFFSET
	MOV	R3,B$HOL(R2)	; SET THIS ENTRY AS FIRST HOLE
	INC	B$HCT(R2)	; INCREMENT HOLE COUNT
	RETURN			;

;
; REQUEST SPACE FOR ENTRY IN NODE
;
; INPUTS:
;
;	R0=NODE ADDRESS
;
; OUTPUTS:
;
;	C/CLEAR: REQUESTED SPACE AVAILABLE
;	R1=ADDRESS OF BLOCK REQUESTED
;
;	C/SET: NO SPACE IN NODE
;	R1=0
;

RQNB:				;
	MOV	B$HOL(R0),R1	; GET OFFSET OF FIRST FREE HOLE
	SEC			; ASSUME NO SPACE AVAILABLE
	BEQ	10$		; IF EQ NO SPACE
	ADD	R0,R1		; CONVERT TO ADDRESS
	MOV	(R1),B$HOL(R0)	; SET NEW FIRST HOLE
	DEC	B$HCT(R0)	; DECREMENT HOLE COUNT
10$:				;
	RETURN			;

;
; SEARCH NODE FOR KEY
;
; INPUTS:
;
;	R0=REAL ADDRESS OF NODE
;	R1=VIRTUAL ADDRESS OF NODE
;	R3=ADDRESS OF KEY
;
; OUTPUTS:
;
;	C/CLEAR: KEY FOUND
;
;	R0=REAL ADDRESS OF KEY
;	R1=VIRTUAL ADDRESS OF KEY
;	R2=VIRTUAL ADDRESS OF LINK UP FROM PRECEDING KEY
;
;	C/SET: KEY NOT IN NODE
;
;	R0=REAL ADDRESS OF KEY AT POINT FOR INSERTION
;	R1=VIRTUAL ADDRESS OF KEY AT INSERTION POINT
;	R2=VIRTUAL ADDRESS OF LINK UP FROM PREVIOUS KEY
;
; R3 - R5 UNMODIFIED
;

SRCKY:				;
	MOV	R0,R2		; COPY REAL ADDRESS OF NODE
	MOV	R1,-(SP)	; SAVE VIRTUAL ADDRESS
	CLR	-(SP)		; SAVE SPACE FOR LINK-UP ON STACK
10$:				;
	MOV	S$YUP(R0),(SP)	; SAVE LINK-UP OF PREVIOUS
	MOV	(R0),R0		; GET LINK-NEXT OFFSET
	ADD	R2,R0		; CONVERT TO ADDRESS
	CMP	S$YM(R3),S$YM(R0) ; TEST FIRST HALF OF SYMBOL
	BHI	10$		; IF HI GET NEXT ENTRY
	BLO	20$		; IF LO SYMBOL NOT IN NODE (C-SET)
	CMP	S$YM+2(R3),S$YM+2(R0) ; CHECK SECOND HALF OF SYMBOL
	BHI	10$		; IF HI GET NEXT ENTRY
	BLO	20$		; IF LO NOT IN NODE
	CMP	S$YM+4(R3),S$YM+4(R0) ; CHECK EXTENSION
	BHI	10$		; IF HI GET NEXT ENTRY
20$:				;
	ROR	-(SP)		; SAVE FOUND FLAG
	MOV	R0,R1		; COPY REAL ADDRESS
	SUB	R2,R1		; COMPUTE OFFSET
	ASR	R1		; CONVERT TO VIRTUAL OFFSET
	ADD	4(SP),R1	; CONVERT TO VIRTUAL ADDRESS
	ROL	(SP)+		; RESTORE C BIT
	MOV	(SP)+,R2	; SET VIRTUAL ADDRESS OF LINK UP
	INC	(SP)+		; CLEAN STACK
	RETURN			;

;
; TRANSFER AN ENTRY
;
; INPUTS:
;
;	R1=REAL ADDESS TO RECEIVE ENTRY
;	R3=REAL ADDRESS OF ENTRY
;	R5=ADDRESS OF LISTHEAD
;
; OUTPUTS:
;
;	ENTRY IS MOVED TO NEW LOCATION
;
; ALL REGISTERS ARE PRESERVED
;

XFREN:				;
	SAVVR			; SAVE VOLATILE REGISTERS
	MOV	R3,R0		; COPY ADDRESS OF ENTRY
	MOV	L$ESIZ(R5),R2	; GET SIZE OF ENTRY
	MOV	#S$YUP,-(SP)	; GET OFFSET TO LINK UP
	SUB	(SP),R2		; SET TO MOVE ONLY LINK-UP PLUS DATA
	ASR	R2		; CONVERT TO WORD COUNT
	ADD	(SP),R1		; STEP TO LINK-UP OF NEW
	ADD	(SP)+,R0	; STEP TO LINK-UP OF ENTRY
10$:				;
	MOV	(R0)+,(R1)+	; TRANSFER ENTRY
	SOB	R2,10$		; LOOP UNTIL COMPLETE
	RETURN			;

	.END
