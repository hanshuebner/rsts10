
	.TITLE	MLSG0
	.IDENT	/07.03/
;
; COPYRIGHT (c)	1983 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE IS FURNISHED  UNDER A LICENSE AND MAY BE USED OR
; COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;
; D. N. CUTLER/C. MONIA 10-DEC-73
;
;
; MODIFIED BY:
;
;	C. B. PETROVIC	26-FEB-82	07.01
;		CBP039		ADD CORRECT .PSECT DEFINITIONS TO
;				ALLOW TKB TO BE LINKED AS AN I/D TASK.
;
;	J. M. Lawler	03-JUL-82	07.02
;		JML112		PROMPT WITH CALCULATED TASK NAME
;
;	C. B. PETROVIC	07-APR-83	07.03
;		CBP082		ADD TRACE OF INTERNAL DATA STRUCTURES
;				OF THE OVERLAY DESCRIPTOR LANGUAGE.
;				(NECESSARY FOR ANSWER OF IPR #78.)
;
; READ OVERLAY DESCRIPTION FILE AND VERIFY LINE FORMAT
;
; MACRO LIBRARY CALLS
;

	.MCALL	CLOSE$,GCML$,GCMLD$,RCML$
	GCMLD$
	.IF DF D$MLS0

	.MCALL	ALUN$S, QIOW$S

	.ENABL	LC

	.ENDC

;
; LOCAL MACROS
;
; GENERATE DIRECTIVE NAME LIST
;
; GDIR	NAME,FLAG
;
; WHERE:
;
;	NAME=1 TO 5 CHARACTER DIRECTIVE NAME AND ADDRESS OF PROCESSING
;		SUBROUTINE
;
;	FLAG=OPERAND FLAG, IF FLAG IS NB, THEN OPERANDS ARE REQUIRED
;

	.MACRO	GDIR	NAME,FLAG
	.PSECT	DIRL0,RO,D
$$=.
	.WORD	0
	.WORD	0
.=$$
	.RAD50	/.'NAME/
.=$$+4
N=0
	.IIF	NB	FLAG, N=1
	.WORD	NAME+N
LNG=.-$$
	PURE.I			; READ-ONLY I-SPACE
	.ENDM

;
; GENERATE CONTROL SECTION ATTRIBUTE LIST
;
; GSAT	SAT,FBIT,DIS
;
; WHERE:
;
;	SAT=1 TO 6 CHARACTER ATTRIBUTE NAME
;	FBIT=FLAG BYTE BIT
;	DIS= FLAG BIT DISPOSITION. IF DIS NB, THEN SET BIT. ELSE
;		CLEAR BIT.
;

	.MACRO	GSAT	SAT,FBIT,DIS
	.PSECT	SATL0,RO,D
.=.-2
	.WORD	0
	.WORD	0
$$=.
.=.-4
	.RAD50	/SAT/
.=$$
N=1
	.IIF	NB	DIS, N=-1
	.BYTE	FBIT,N
	.WORD	0
	.PSECT
	.ENDM

;
; LOCAL DATA
;
; GCML BLOCK SAVE AREA
	IMPURE			; READ/WRITE D-SPACE

GCMSA:	.BLKB	G.ISIZ		;

	.EVEN

;
; DIRECTIVE LIST
;

	.PSECT	DIRL0,RO,D
DBAS:				; REF LABEL
	.PSECT	DIRL1,RO,D
DBASE:				; REF LABEL

;
; SECTION ATTRIBUTE LIST
;

	.PSECT	SATL0,RO,D
SBAS:				; REF LABEL
	.WORD	0		; DUMMY ZERO AT START OF LIST

	GSAT	ABS,CS$REL
	GSAT	CON,CS$ALO
	GSAT	D,CS$TYP,1
	GSAT	GBL,CS$GBL,1
	GSAT	HGH,CS$MEM,1
	GSAT	I,CS$TYP
	GSAT	LCL,CS$GBL
	GSAT	LOW,CS$MEM
	GSAT	OVR,CS$ALO,1
	GSAT	REL,CS$REL,1
	GSAT	RO,CS$ACC,1
	GSAT	RW,CS$ACC

	IMPURE			; READ/WRITE D-SPACE

;
; SEGMENT ATTRIBUTE LIST
;

	.PSECT	SATL0,RO,D

SGBAS:				; REF LABEL
	.WORD	0		; DUMMY ZERO AT START OF LIST

	GSAT	DSK,SG$DSK
	GSAT	GBL,SG$GBL,1
	GSAT	PHY,SG$PHY,1
	GSAT	NODSK,SG$DSK,1
	GSAT	NOGBL,SG$GBL
	GSAT	NOPHY,SG$PHY



;
; TEMP STORAGE
;
	IMPURE			; READ/WRITE D-SPACE

TMP:	.BLKW	5		; TEMP STORAGE

	.IF DF	D$MLS0

;
; Data structures and local storage for the overlay descriptor dump routines.
;

	.PSECT	$$FMTS,RO,D,LCL		; The $EDMSG format control string.

	.NLIST	BEX

FMT1:	.ASCII	"%NLink word = %P, Type/Size = %2B%N"
	.ASCII	"Segment name = %2R, Next byte address = %P%N"
	.ASCIZ	"Input line:%N%VA%N"
	.EVEN

FMT2:	.ASCII	"%NLink word = %P, Type/Size = %2B%N"
	.ASCIZ	"Segment name = %2R, Flags = %P%N"
	.EVEN

	.LIST	BEX

	.PSECT	$$MMGT,RW,D		; Dynamic memory management local store

					; For the intermediate buffer
INBLK:	.WORD	0			; Dynamic memory block address
	.WORD	32.			;    "      "      "    length
;					
					; For the output buffer
OUBLK:	.WORD	0			; Dynamic memory block address
	.WORD	256.			;    "      "      "    length
;					
	.ENDC

;
;+
; **-$MLSG0-READ ODL AND VERIFY LINE FORMAT
;
; INPUTS:
;
;	ODL FILE
;
; OUTPUTS:
;
;	EACH LINE IN THE OVERLAY DESCRIPTION IS READ, IDENTIFIED BY
; DIRECTIVE TYPE AND RETAINED IN DYNAMIC STORAGE FOR LATER PROCESSING.
;
;	THIS ROUTINE IS CALLED BY $MULSG TO PERFORM THE ABOVE
; PROCESSING AND VERIFY CORRECT LINE SYNTAX. NOTE THAT ALL I/O
; SPECIFIC TO ODL PROCESSING IS DONE HERE.
;
;-
	PURE.I			; READ-ONLY I-SPACE

$MLSG0::			;
	CLR	$DIRHD		; CLEAR DIRECTIVE LISTHEAD
	MOV	#$DIRHD,$DIRHD+2 ; LAST POINTS TO FIRST INITIALLY
	CLR	$RTDIR		; CLEAR ROOT DIRECTIVE POINTER
	MOV	$ODLPT,R0	;GET OVERLAY DESCRIPTION RECORD BLOCK
	MOV	R0,R4		; SAVE POINTER
	ADD	#S.FDB,R0	; POINT TO GCML IMPURE AREA
	MOV	#GCMSA,R1	; POINT TO GCML SAVE AREA
	MOV	#G.ISIZ/2,R2	; SET SIZE OF IMPURE AREA
5$:				;
	MOV	(R0)+,(R1)+	; SAVE IMPURE DATA AREA
	SOB	R2,5$		;
	MOV	R4,R0		; RESTORE GCML BLOCK ADDRESS
	CALL	$STFDB		; RECORD FDB ADDRESS OF OPEN FILE
	MOV	R4,R0		; RETRIEVE RECORD BLOCK POINTER
	MOV	$INIPT,R1	; GET RECORD BLOCK POINTER
	MOV	#SW$CC,R$SWTH(R1) ; ASSUME CONCATENATED OBJECT FILE
	MOV	F.DSPT(R1),F.DSPT(R0);SET ADDRESS OF DATA SET DESCRIPTOR
10$:				;

	.IF DF	R$$PRO

	GCML$	$ODLPT,#$PRMPT,#$PSIZ	 ; READ A LINE OF ODL TEXT

	.IFF

	GCML$	$ODLPT

	.ENDC


	BCS	50$		;IF CS I/O ERROR
	ADD	#G.CMLD,R0	; POINT TO LENGTH OF LINE
	MOV	R0,$LNDES	; SAVE DESCRIPTOR ADDRESS
	MOV	(R0)+,R1	; GET LENGTH OF LINE
	MOV	(R0),R0		; GET ADDRESS OF LINE
	ADD	R0,R1		; COMPUTE ADDRESS OF LAST BYTE+1
	CLRB	(R1)		; MARK END OF LINE
	CALL	$SETNB		;BYPASS LEADING BLANKS AND HT'S
	CMPB	#';,(R0)	;COMMENT LINE?
	BEQ	10$		;IF EQ YES
	TSTB	(R0)		;BLANK LINE?
	BEQ	10$		;IF EQ YES
	MOV	#TMP+8.,R5	;GET ADDRESS OF TEMP AREA
	.REPT	4
	CLR	-(R5)		;CLEAR TEMP STORAGE
	.ENDR
	CALL	$RR		;CONVERT LABEL OR DIRECTIVE NAME
	CMPB	#':,R2		;LABEL SPECIFIED?
	BNE	20$		;IF NE NO
	MOV	-(R5),4(R5)	;MOVE LABEL
	MOV	-(R5),4(R5)	;
	CALL	$SETNB		;BYPASS LEADING BLANKS AND HT'S
	CALL	$RR		;CONVERT DIRECTIVE NAME
20$:	DEC	R0		;BACK UP TO TERMINAL BYTE
	MOV	R0,-(SP)	;++033 SAVE ADDRESS OF TERMINAL BYTE
	MOV	R0,R1		;++033 COPY ADDRESS OF BYTE
22$:				;++033
	MOVB	(R0)+,(R1)	;++033 COPY BYTE
	BEQ	25$		;++033 IF EQ FINISHED WITH LINE
	CMPB	(R1)+,#SPA	;++033 PRINTING CHARACTER?
	BHI	22$		;++033 IF HI YES
	DEC	@$LNDES		; DECREMENT BYTE COUNT
	DEC	R1		;++033 BACKUP BYTE POINTER
	BR	22$		;++033 GO AGAIN
25$:				;++033
	MOV	(SP)+,R0	;++033 RETRIEVE TERMINAL BYTE ADDRESS
	CMP	-(R5),-(R5)	;POINT TO DIRECTIVE NAME
	MOV	#DBAS,R1	;GET ADDRESS OF DIRECTIVE LIST
30$:	CMP	(R5),(R1)	;FIRST HALF MATCH?
	BNE	40$		;IF NE NO
	CMP	2(R5),2(R1)	;SECOND HALF MATCH?
	BEQ	60$		;IF EQ YES
40$:	ADD	#LNG,R1		;ADVANCE TO NEXT NAME
	CMP	R1,#DBASE	; END OF LIST?
	BLO	30$		;IF LO NO
	MOV	(PC)+,R1	;ILLEGAL DIRECTIVE
	.BYTE	E$R36,S$V2	;FATAL-NO RETURN
	BR	90$		;
50$:				;
	MOV	R0,R2		; COPY ADDRESS OF GCML BLOCK
	ADD	#G.CMLD,R2	; POINT TO ADDRESS OF LINE DESCRIPTOR
	MOVB	G.ERR(R0),R3	; GET ERROR CODE
	MOV	#<S$V2*400!E$R9>,R1 ; ASSUME TOO MANY INDIRECT FILES
	CMPB	R3,#GE.MDE	; TOO MANY INDIRECT FILES?
	BEQ	55$		; IF EQ YES
	MOV	#<S$V2*400!E$R8>,R1 ; ASSUME INDIRECT FILE SYNTAX ERROR
	CMPB	R3,#GE.IND	; ERROR IN INDIRECT FILE SPECIFICATION?
	BEQ	55$		; IF EQ YES
	ADD	#<F.FNB+N.FNAM>-G.CMLD,R2 ; POINT TO FNB
	MOV	#<S$V2*400!E$R11>,R1 ; ASSUME OPEN FAILURE
	CMPB	R3,#GE.OPR	; OPEN FAILURE?
	BEQ	55$		; IF EQ YES
	MOV	#<S$V2*400!E$R94>,R1 ; ASSUME PREMATURE EOF
	CMPB	R3,#GE.EOF	; PREMATURE EOF
	BEQ	55$		; IF EQ YES
	MOV	#<S$V2*400!E$R10>,R1 ; MUST BE ODL FILE I/O ERROR
55$:				;
	CALL	$ERMSG		;OUTPUT ERROR MESSAGE

;
; DIRECTIVE FOUND-DISPATCH TO DIRECTIVE PROCESSING ROUTINE
;

60$:	MOV	LNG-2(R1),R1	;GET ADDRESS OF ROUTINE AND OPERAND FLG
	BIT	#1,R1		;OPERANDS REQUIRED?
	BEQ	70$		;IF EQ NO
	TST	R2		;TERMINAL ZERO?
	BEQ	80$		;IF EQ YES-ERROR
	CMPB	#';,R2		;COMMENT TERMINATOR?
	BEQ	80$		;IF EQ YES-ERROR
70$:	CMP	(R5)+,(R5)+	;POINT TO LABEL
	BIC	#1,R1		;CLEAR OPERAND FLAG
	CALL	(R1)		;CALL DIRECTIVE PROCESSING ROUTINE
	BR	10$		;GO AGAIN
80$:	MOV	(PC)+,R1	;DIRECTIVE HAS NO OPERANDS
	.BYTE	E$R35,S$V2	;FATAL-NO RETURN
90$:	JMP	SDIRL1		;

;
; END DIRECTIVE
;

	GDIR	END

END:	TST	(SP)+		;REMOVE RETURN FROM STACK
	TST	$RTDIR		; ROOT SEGMENT SPECIFIED?
	BNE	20$		; IF NE YES
10$:	MOV	(PC)+,R1	;ROOT SEG NOT DEFFINED
	.BYTE	E$R40,S$V2	;FATAL-NO RETURN
	JMP	SDIRL1		;
20$:				;
	CALLR	$CLSOD		; CLOSE ODL FILE

;
; NAME DIRECTIVE
;

	GDIR	NAME,1


	.ENABL	LSB


NAME:				;
	CMP	-(R5),-(R5)	; POINT TO START OF PARAMETER BLOCK
	CALL	$RR		; CONVERT NAME
	CMP	-(R5),-(R5)	; BACK UP TO START OF NAME
	MOV	#<S$V2*400!E$R40>,R1 ; ASSUME NULL NAME SPECIFIED
	TST	(R5)		; NULL NAME SPECIFIED?
	BEQ	SEG3		; IF EQ YES
	MOV	#<<F$LG+2>*400!S$EGN>,-(SP) ; SET ITEM TYPE, SIZE
	MOV	#SGBAS,-(SP)	; SET BASE ADDRESS OF ATTRIBUTE LIST
	MOV	#<SG$DES!SG$MEM>,R4 ; SET INITIAL FLAGS WORD
	BR	5$		;

;
; PROGRAM SECTION DIRECTIVE
;

	GDIR	PSECT,1

PSECT:	CMP	-(R5),-(R5)	;POINT TO BEGINNING OF TEMP STORAGE
	CALL	$RP		;GET CONTROL SECTION NAME
	CMP	-(R5),-(R5)	;POINT TO CONTROL SECTION NAME
	MOV	(PC)+,R1	;ASSUME BLANK NAME
	.BYTE	E$R41,S$V2	;FATAL-NO RETURN
	TST	(R5)		;ANY NAME SPECIFIED?
	BEQ	SDIRL1		;IF EQ NO
	MOV	#CS$REL,R4	; SET INITIAL FLAGS WORD
	MOV	#<<F$LG+2>*400!S$CTN>,-(SP) ; SET ITEM TYPE, SIZE
	MOV	#SBAS,-(SP)	; GET BASE ADDRESS OF ATTRIBUTE LIST
5$:				;
	CALL	SDIRL		;SCAN DIRECTIVE LIST FOR DUP NAME
	CMP	(R5)+,(R5)+	;ADJUST R5
10$:				;
	MOV	(SP),R3		; GET BASE ADDRESS OF DESCRIPTOR
	TST	R2		; AT END OF LINE?
	BEQ	40$		;IF EQ YES-DONE
	CMPB	#';,R2		;COMMENT TERMINATOR?
	BEQ	40$		;IF EQ YES-DONE
	CMPB	#',,R2		;COMMA TERMINATOR?
	BNE	SEG3		;IF NE NO-SYNTAX ERROR
	CALL	$SETNB		;BYPASS LEADING BLANKS AND HT'S
	CALL	$RP		;GET SECTION ATTRIBUTE NAME
	CMP	-(R5),-(R5)	;BACK UP TO NAME
20$:				;
	CMP	(R5),(R3)+	; CHECK FIRST HALF OF NAME
	BNE	25$		; IF NE NO MATCH
	CMP	2(R5),(R3)+	; CHECK SECOND HALF OF NAME
	BEQ	30$		; IF EQ HAVE ATTRIBUTE
	TST	-(R3)		; ADJUST R3
25$:				;
	CMP	(R3)+,(R3)+	; STEP OVER NAME AND DATA
	TST	(R3)		; AT END OF LIST
	BNE	20$		; IF LO NO
	MOV	(PC)+,R1	;ILLEGAL SECTION ATTRIBUTE NAME
	.BYTE	E$R42,S$V2	;FATAL-NO RETURN
	BR	SDIRL1		;
30$:	BICB	(R3),R4		;ASSUME BIT IS TO BE CLEARED
	TST	(R3)		;CLEAR BIT?
	BPL	10$		;IF PL YES
	BISB	(R3),R4		;SET BIT
	BR	10$		;GO AGAIN
40$:	MOV	#F$LG+2,R1	; GET SIZE OF BLOCK NEEDED
	CALL	$ALBLK		;ALLOCATE STORAGE
	MOV	R0,R1		;COPY ADDRESS OF BLOCK
	CMP	(SP)+,(R1)+	; CLEAN STACK, ADJUST BLOCK ADDRESS
	MOV	(SP)+,(R1)+	; SET TYPE, SIZE
	MOV	-4(R5),(R1)+	; SET FIRST HALF OF NAME
	MOV	-(R5),(R1)+	; SET SECOND HALF OF NAME
	MOV	R4,(R1)		;SET FLAG BYTE

	.IF DF D$MLS0

	CALL	$PSNM		; Dump the internal .ODL form...

	.ENDC

	BR	SEG2		;

	.DSABL	LSB

;
; ROOT DIRECTIVE
;

	GDIR	ROOT,1

ROOT:	CLR	-(SP)		;SET ROOT SEGMENT FLAG
	TST	$RTDIR		; MULTIPLE ROOT DIRECTIVES
	BEQ	SEG1		;IF EQ NO
	MOV	(PC)+,R1	;MULTIPLY DEFINED ROOT SEGMENT
	.BYTE	E$R38,S$V2	;FATAL-NO RETURN
	BR	SDIRL1		;
;
; FACTOR DIRECTIVE
;

	GDIR	FCTR,1

FCTR:	TST	(R5)		;ANY LABEL SPECIFIED?
	BEQ	SEG3		;IF EQ NO-SYNTAX ERROR
	MOV	R5,-(SP)	;SET SEG SEGMENT FLAG
SEG1:	MOV	R0,R3		;SAVE ADDRESS OF NEXT BYTE
	CALL	SDIRL		;SCAN DIRECTIVE LIST FOR DUP NAME
	MOV	@$LNDES,R1	; GET LENGTH OF LINE
	ADD	#11.,R1		;ALLOW FOR TERMINAL BYTE AND ENTRY
	MOV	R1,-(SP)	;SAVE LENGTH FOR LATER
	CALL	$ALBLK		;ALLOCATE STORAGE
	MOV	(SP)+,R1	;RETRIEVE SIZE OF BLOCK
	TST	(SP)+		;ROOT SEG?
	BNE	10$		;IF NE NO
	MOV	R0,$RTDIR	; SET POINT TO ROOT SEGMENT
10$:	MOV	R0,R2		;COPY ADDRESS OF BLOCK
	TST	(R2)+		;POINT TO SECOND WORD
	SWAB	R1		;SIZE TO LEFT BYTE
	MOV	R1,(R2)+	;SET TYPE/SIZE
	MOV	(R5)+,(R2)+	;INSERT SEGMENT NAME
	MOV	(R5)+,(R2)+	;
	MOV	$LNDES,R1	; GET DESCRIPTOR ADDRESS
	MOV	2(R1),R1	; GET ADDRESS OF LINE BUFFER
	SUB	R1,R3		;CALCULATE RELATIVE ADDR OF NEXT BYTE
	ADD	R0,R3		;ADD BASE ADDRESS OF BLOCK
	ADD	#10.,R3		;DISPLACE BY ENTRY SIZE
	MOV	R3,(R2)+	;SET ADDRESS OF NEXT BYTE
20$:	MOVB	(R1)+,(R2)+	;MOVE LINE
	BNE	20$		;IF NE GO AGAIN

	.IF DF D$MLS0

	CALL	$RTFC		; Dump the internal .ODL form...

	.ENDC

SEG2:	MOV	R0,@$DIRHD+2	; LINK NEW LAST TO OLD LAST
	MOV	R0,$DIRHD+2	; SET NEW LAST
	RETURN			;
SEG3:	MOV	(PC)+,R1	;SYNTAX ERROR
	.BYTE	E$R37,S$V2	;FATAL-NO RETURN
	BR	SDIRL1		;

;
; SCAN PARSED DIRECTIVE LIST FOR DUPLICATE NAME
;

SDIRL:	CALL	$SCNL		; SCAN DIRECTIVE LIST FOR A MATCH
	BCC	10$		;IF CC FOUND ONE-ERROR
	RETURN			;
10$:	MOV	(PC)+,R1	;DUPLICATE NAME DEFINITION
	.BYTE	E$R39,S$V2	;FATAL-NO RETURN
SDIRL1:	MOV	$LNDES,R2	; GET ADDRESS OF LINE DESCRIPTOR
SDIRL2:	CALL	$ERMSG		;OUTPUT ERROR MESSAGE

;+
; **-$CLSOD-CLOSE ODL FILE AND RESET GCML BLOCK
;
; INPUTS:
;
;	GCMSA=INITIAL CONTENTS OF GCML IMPURE AREA
;
; OUTPUTS:
;
;	ODL FILE GCML BLOCK IS RESTORED TO  ITS INITIAL STATE.
;	THE ODL FILE IS CLOSED.
;
; ALL REGISTER CONTENTS ARE PRESERVED.
;
;-
	PURE.I			; READ-ONLY I-SPACE

$CLSOD::			;
	SAVVR			; SAVE THE VOLATILE REGISTERS
	RCML$	$ODLPT		; RESET GCML BLOCK
	CLOSE$	R0		; CLOSE TOP LEVEL FILE
	MOV	#GCMSA,R1	; GET ADDRESS OF SAVE AREA
	MOV	#G.ISIZ/2,R2	; GET SIZE OF AREA IN WORDS
	ADD	#S.FDB,R0	; POINT TO IMPURE AREA
10$:				;
	MOV	(R1)+,(R0)+	; RESTORE IMPURE AREA
	SOB	R2,10$		;
	RETURN			;


	.IF DF	D$MLS0

;
; This routine prints on the terminal the overlay descriptor file as it
; is read and processed by TKB. It will allocate a core block for the
; intermediate input to $EDMSG and release that block when finished. The
; output buffer is also allocated out of dynamic memory and deleted as well.
;
;
	PURE.I
;
$RTFC:
	CALL	$SAVAL			; Save all the registers
	ALUN$S	.TRLUN,#"TI,#0		; Assign 'TI:' as the output device
	MOV	R0,-(SP)		; Save the address of the real buffer
	MOV	INBLK+2,R1		; Set argument block length for $EDMSG
	CALL	$ALBLK			; Allocate memory
	MOV	R0,INBLK		; save its address
	MOV	OUBLK+2,R1		; Set length of output block...
	CALL	$ALBLK			; and allocate it as well
	MOV	R0,OUBLK		; Save the output block address
	MOV	(SP)+,R2		; Restore the original block address
	MOV	INBLK,R0		; Set up to copy the first 5 items
					; from the real block to the intermediate
					; At this point we should have copied
					; the following 5 data items:
	MOV	(R2)+,(R0)+		; Link word
	MOV	R2,(R0)+		; Address of Size/Type bytes
	TST	(R2)+			; Bump pointer
	MOV	(R2)+,(R0)+		; RAD50 Segment name (2 words)
	MOV	(R2)+,(R0)+
	MOV	(R2)+,(R0)+		; and the address of the next byte...
	MOV	@$LNDES,(R0)+		; Set length of ascii string...
	MOV	$LNDES,R1		; Get address of descriptor
	MOV	2(R1),(R0)+		; Set address of line buffer.
	MOV	OUBLK,R0		; Set address of output block
	MOV	#FMT1,R1		; Set address of format string
	MOV	INBLK,R2		; Set address of argument block
	CALL	$EDMSG			; Format the string
	QIOW$S	#IO.WVB,.TRLUN,#31.,,,,<OUBLK,R1,#40>
	MOV	#$FRHD,R0		; Set free list pointer address
	MOV	INBLK+2,R1		; Set size of block to release
	MOV	INBLK,R2		; Set address of block to release...
	CALL	$RLCB			; and restore it to free pool
					; Now do the temporary buffer
	MOV	#$FRHD,R0		; Set free list pointer address
	MOV	OUBLK+2,R1		; Set size of block to release
	MOV	OUBLK,R2		; Set address of block to release...
	CALL	$RLCB			; and restore it to free pool
	RETURN	
;
; This routine dumps the .NAME and .PSECT information as it reads the input.
;
$PSNM::
	CALL	$SAVAL			; Save all the registers
	ALUN$S	.TRLUN,#"TI,#0		; Assign 'TI:' as the output device
	MOV	R0,-(SP)		; Save the address of the real buffer
	MOV	INBLK+2,R1		; Set argument block length for $EDMSG
	CALL	$ALBLK			; Allocate memory
	MOV	R0,INBLK		; save its address
	MOV	OUBLK+2,R1		; Set length of output block...
	CALL	$ALBLK			; and allocate it as well
	MOV	R0,OUBLK		; Save the output block address
	MOV	(SP)+,R2		; Restore the original block address
	MOV	INBLK,R0		; Set up to copy the first 5 items
					; from the real block to the intermediate
					; At this point we should have copied
					; the following 5 data items:
	MOV	(R2)+,(R0)+		; Link word
	MOV	R2,(R0)+		; Address of Size/Type bytes
	TST	(R2)+			; Bump pointer
	MOV	(R2)+,(R0)+		; RAD50 Segment name (2 words)
	MOV	(R2)+,(R0)+
	MOV	(R2)+,(R0)+		; and the flags byte...
	MOV	OUBLK,R0		; Set address of output block
	MOV	#FMT2,R1		; Point to the format string
	MOV	INBLK,R2		; Set address of argument block
	CALL	$EDMSG			; Format the string
	QIOW$S	#IO.WVB,.TRLUN,#31.,,,,<OUBLK,R1,#40>
	MOV	#$FRHD,R0		; Set free list pointer address
	MOV	INBLK+2,R1		; Set size of block to release
	MOV	INBLK,R2		; Set address of block to release...
	CALL	$RLCB			; and restore it to free pool
					; Now do the temporary buffer
	MOV	#$FRHD,R0		; Set free list pointer address
	MOV	OUBLK+2,R1		; Set size of block to release
	MOV	OUBLK,R2		; Set address of block to release...
	CALL	$RLCB			; and restore it to free pool
	RETURN

	.ENDC
	.END
