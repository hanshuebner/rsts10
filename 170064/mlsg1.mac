	.TITLE	MLSG1
	.IDENT	/13.04/
;
; COPYRIGHT (c)	1990 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE IS FURNISHED  UNDER A LICENSE AND MAY BE USED OR
; COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;
; MODIFIED BY:
;
;	C. B. PETROVIC	26-FEB-82	13.01
;		CBP039		ADD CORRECT .PSECT DEFINITIONS TO
;				ALLOW TKB TO BE LINKED AS AN I/D TASK.
;
;	J. M. SALMAN	06-OCT-82	13.02
;		JMS077		COMPLETE CBP039.
;
;	C. B. PETROVIC	20-OCT-82	13.03
;		CBP062		FIX TESTING OF MEMORY RESIDENCY OPERATOR
;				SUCH THAT AN OVERLAY DESCRIPTOR WITH
;				SEGMENTS ON THE NEXT HIGHER LEVEL WILL NOT
;				BE FLAGGED AS A SYNTAX ERROR IF THE '!'
;				'!' OPERATOR IS SEEN.
;
;	L. M. PETERSON	13-DEC-90	13.04
;		LMP155		FIX PARSING SO THAT OPERAND PROCESSING HANDLES
;				LOGICAL NAMES CORRECTLY
;
;
; PARSE THE OVERLAY DESCRIPTION
;
; MACRO LIBRARY CALLS
;

	.MCALL	CSI$1


;
; LOCAL MACROS
;
;
; GENERATE OPERATOR TABLES
;
; GOPR OPR,VAL
;
; WHERE:
;
;	OPR=OPERATOR CHARACTER.
;	VAL=OPERATOR VALUE.
;

	.MACRO	GOPR OPR,VAL
	.PSECT	OPRL,RO,D
	.ASCII	/OPR/
	.PSECT	OVAL,RO,D
	.BYTE	VAL
	.PSECT
	.ENDM

;
; LOCAL DATA
;
;
; AUTOLOAD INDICATOR SEEN
;
	IMPURE			; READ/WRITE D-SPACE

AFLG:	.BLKW	1		;
;
; AUTOLOAD ENTRY POINT NAME
;

AUTO:	.RAD50	/$AUTO/		;


;
; CONTROL BYTE STRING
;

CNTRL:	.ASCII	/[<$09AZ /	;


;
; LAST ITEM TYPE
;

LITEM:	.BLKW	1		;

;
; RESIDENCY OPERATOR SEEN
;

RFLG:	.BLKW	1		;

;
; RESIDENCY OPERATOR SEEN IN STRUCTURE
;

RFLG0:	.BLKW	1		;

;
;
; OPERATOR TABLES
;
	.PSECT	OPRL,RO,D
OBAS:				; REF LABEL
	.PSECT	OVAL,RO,D
OPRV:				; REF LABEL
	GOPR	^/(/,L$PAR
	GOPR	^/)/,R$PAR
	GOPR	^/,/,C$OMA
	GOPR	^/-/,D$ASH
	GOPR	^/*/,S$TAR
	GOPR	^/!/,E$XCL

	.PSECT	OPRL,RO,D
OBASE:				; REF LABEL

;
; TEMPORARY STORAGE
;
	IMPURE			; READ/WRITE D-SPACE

TMP:	.BLKW	5		;


;
;+
; **-$MLSG1-PARSE THE SEGMENT DESCRIPTION
;
; INPUTS:
;
;	OVERLAY DESCRIPTION READ BY $MLSG0
;
; OUTPUTS:
;
;	LINKED LIST OF ODL ITEM TYPES
;
;	THIS ROUTINE IS CALLED BY $MULSG TO PARSE THE
; ODL. THE INPUT, TAKEN FROM DYNAMIC STORAGE, CONSISTS OF
; EACH LINE IN THE DESCRIPTION WITH AN APPROPRIATE CODE
; IDENTIFYING THE ASSOCIATED ODL DIRECTIVE. THE PARSING PHASE
; RESULTS IN A LINKED LIST OF ITEMS LATER USED (BY $MULSG2)
; TO GENERATE THE SEGMENT DESCRIPTORS.
;
;-
	PURE.I			; READ-ONLY I-SPACE

$MLSG1::			;
	CLR	AFLG		; CLEAR AUTOLOAD FLAG
	CLR	RFLG		; RESET RESIDENCY FLAG
	CLR	RFLG0		; CLEAR STRUCTURE RESIDENCY FLAG
	CLR	$ALVL		; CLEAR AUTOLOAD LEVEL COUNT
	CLR	$AFLG		; CLEAR AUTOLOAD REQUIRED FLAG
	MOV	#S$OS,LITEM	; SET LAST ITEM TO SOS
	MOV	#$DSTK,R0	; GET ADDRESS OF DESCRIPTION STACK
10$:	MOV	R0,R1		;COPY HEADER ADDRESS
	CLR	(R0)+		;CLEAR LINK TO FIRST
	MOV	R1,(R0)+	;LAST POINTS TO FIRST INITIALLY
	CMP	R0,#$DSTK+<N$PLVL*4> ; END OF LIST?
	BLO	10$		;IF LO NO
	MOV	#$DSTK+2,R3	; SET INITIAL DESCRIPTION STACK POINTER
	MOV	#$SOSOP,R0	; GET ADDRESS OF SOS ENTRY
	CLR	(R0)		;CLEAR LINK TO NEXT
	MOV	R0,@(R3)+	;LINK NEW LAST TO OLD LAST
	MOV	R0,-(R3)	;SET NEW LAST
	MOV	#$TSTK,R4	; GET ADDRESS OF TEXT STACK
	MOV	$RTDIR,R0	; GET POINTER TO ROOT SEGMENT DIRECTIVE
	MOV	R0,-(R4)	;SET ADDRESS OF ROOT DIRECTIVE ENTRY
	MOV	N$XT(R0),-(R4)	; SET ADDRESS OF ROOT DIRECTIVE ENTRY
ITMBEG:	CALL	ITEM		;GET NEXT ITEM
	MOV	#LITEM,R5	;GET ADDRESS OF LAST ITEM
	MOVB	(R5),R2		;GET LAST ITEM TYPE
	ASR	R2		;CONVERT TO SHIFT COUNT
	MOV	#1,R1		;SET INITIAL MASK WORD


	.IF	NDF	V1145

10$:	DEC	R2		;DECREMENT SHIFT COUNT
	BLT	20$		;IF LT DONE
	ASL	R1		;SHIFT MASK
	BR	10$		;
20$:				;REF LABEL

	.ENDC


	.IF	DF	V1145

	ASH	R2,R1		;SHIFT MASK

	.ENDC


	MOVB	T$YP(R0),R2	; GET CURRENT ITEM TYPE
	BIT	R1,$CBAS(R2)	; LEGAL CONSTRUCTION?
	BEQ	ITMCM1		;IF EQ NO
	JMP	@DSPVCT-2(R2)	; DISPATCH ON CURRENT ITEM

;
; CURRENT ITEM DISPATCH VECTOR
;

	PURE.D			; READ-ONLY D-SPACE

DSPVCT:	.WORD	ITMEOS		;EOS
	.WORD	ITMLPR		;LPAR
	.WORD	ITMRPR		;RPAR
	.WORD	ITMCM		; COMMA
	.WORD	ITMOP1		;DASH
	.WORD	ITMSTR		; STAR
	.WORD	ITMEXC		; EXCLAMATION POINT
	.WORD	ITMOPA		;SCTN
	.WORD	ITMOPA		;SEGN
	.WORD	ITMOPA		;FILE

	PURE.I			; READ-ONLY I-SPACE

;
; COMMA
;

ITMCM:				;
	CMP	#$DSTK+2,R3	; AT ZERO PARENTHESES LEVEL
	BNE	ITMOP1		; IF NE NO
	MOV	RFLG0,RFLG	; COPY RESIDENCY FLAG
	CLR	RFLG0		; RESET RESIDENCY FLAG FOR STRUCTURE
	BR	ITMOP1		;

;
; EXCL-EXCLAMATION POINT
;

ITMEXC:				;
	CMP	R3,#$DSTK+2	; AT ZERO PARENTHESES LEVEL
	BEQ	10$		; IF EQ YES
	TSTB	RFLG		; LEGAL SYNTAX?
;
; THE PROBLEM WHICH IS CORRECTED BY THIS AUDIT-TRAIL IS EXTREMLY SUBTLE.
;
; THE FOLLOWING .ODL, ACCORDING TO THE MANUAL, IS SYNTACICLY CORRECT. HOWEVER,
; TKB ISSUES A FATAL SYNTAX ERROR MESSAGE. THE STRUCTURE IS:
;
;	.ROOT	A-*!(B-*(C,D),E-*!(F,G))
;
; BY CHANGING THE 'BGE' TO A 'BGT' THIS PROBLEM IS CORRECTED. PREVIOUSLY,
; IN ORDER THAT THE SAME STRUCTURE BE BUILT, THE ORDER OF SPECIFYING THE
; DISK-RESIDENT AND MEMORY-RESIDENT ELEMENTS HAD TO CHANGE. FOR THE ABOVE
; EXAMPLE, THE CHANGE IS SIMPLY:
;
;	.ROOT	A-*!(E-*!(F,G),B-*(C,D))
;
; ALTHOUGH THERE IS A SIMPLE WORKAROUND FOR THIS EXAMPLE, MORE COMPLEX
; STRUCTURES CANNOT BE MODIFIED AS EASILY.
;
	BGT	ITMCM1		; IF NE, NO...ILLEGAL
10$:				;
	MOV	#RS$FLG,RFLG0	; SET RESIDENCY FLAG FOR THIS STRUCTURE
	BIT	#MP$SY,$SWTCH	; TARGET SYSTEM MAPPED?
	BEQ	ITMOP2		; IF EQ NO
	BIT	#RS$OV,$SWTCH	; RECOGNIZING RESIDENT OVERLAYS?
	BNE	ITMOP2		; IF NE NO
	MOV	#S$ZSEG+2,$SZSEG ; SET SIZE OF SEGMENT DESCRIPTORS
	BR	ITMOP2		; SET LAST ITEM TYPE

;
; LPAR-LEFT PARENTHESIS
;

ITMLPR:	TST	$ALVL		; AUTOLOAD ENTRY NONZERO
	BNE	10$		;IF NE YES
	TST	AFLG		; PREVIOUS OPERATOR STAR?
	BEQ	20$		; IF EQ NO
10$:	INC	$ALVL		; INCEMENT AUTOLOAD LEVEL
20$:	CMP	(R3)+,(R3)+	;ADVANCE STACK LEVEL
	CMP	R3,#$DSTK+<N$PLVL*4> ; STACK OVERFLOW?
	BHIS	40$		; IF HIS YES
	CMPB	#L$PAR,(R5)	; PREVIOUS ITEM LEFT PAREN.?
	BNE	30$		; IF NE NO
	MOV	(R5),T$YP(R0)	; COPY ITEM TYPE
30$:				;
	CMPB	#E$XCL,(R5)	; PREVIOUS ITEM EXCLAMATION POINT?
	BNE	ITMOP1		; IF NE NO
	BISB	#RS$FLG,T$YP+1(R0) ; SET RESIDENCY FLAG IN ITEM
	CLR	RFLG		; CLEAR RESIDENCY FLAG
	BR	ITMOP1		;
40$:				;
	MOV	(PC)+,R1	;TOO MANY PARENTHESIS LEVELS
	.BYTE	E$R45,S$V2	;FATAL-NO RETURN
	BR	ITMES2		;

;
; RPAR-RIGHT PARENTHESIS
;

ITMRPR:	MOV	R0,@(R3)+	;LINK ITEM TO CURRENT LIST
	MOV	R0,-(R3)	;
	TST	$ALVL		; AUTOLOAD LEVEL NON-ZERO?
	BEQ	10$		;IF EQ NO
	DEC	$ALVL		; DECREMENT AUTOLOAD LEVEL
10$:	CMP	-(R3),-(R3)	;REDUCE STACK LEVEL
	CMP	R3,#$DSTK+2	; LEVEL OK?
	BHIS	ITMOP2		;IF HIS YES
	BR	ITMES1		;

;
; SYNTAX ERROR EXIT
;

ITMCM1:	MOV	(PC)+,R1	;SYNTAX ERROR
	.BYTE	E$R37,S$V2	;FATAL-NO RETURN
	BR	ITMES2		;

;
; SCTN/SEGN/FILE-OPERAND
;

ITMOPA:				;++021
	MOV	#RFLG,R2	; GET ADDRESS OF RESIDENCY FLAG
	CMPB	#L$PAR,(R5)+	; PREVIOUS ITEM LEFT PAREN.?
	BNE	10$		; IF NE NO
	MOVB	(R5),(R2)	; COPY RESIDENCY FLAG
	BICB	#177,(R2)	; CLEAR ALL BUT FLAG
10$:				;
	DEC	R5		; RESET TYPE POINTER
	BISB	(R2),T$YP+1(R0)	; SET RESIDENCY INDICATOR
	TST	AFLG		; TEST AUTOLOAD FLAG
	BNE	ITMOP0		; IF EQ ITEM AUTOLOADABLE
ITMOP1:	TST	$ALVL		; AUTOLOAD LEVEL NON-ZERO?
	BEQ	ITMOP3		;IF EQ NO
ITMOP0:	INC	T$YP(R0)	; SET AUTOLOAD BIT IN ITEM
	MOV	SP,$AFLG	; SET AUTOLOAD FLAG
ITMOP3:	MOV	R0,@(R3)+	;LINK ITEM TO CURRENT LIST
	MOV	R0,-(R3)	;
	CLR	AFLG		; CLEAR THE AUTOLOAD FLAG
ITMOP2:				;
	MOV	T$YP(R0),(R5)	; SET LAST ITEM TYPE
	BIC	#1,(R5)		; CLEAR POSSIBLE AUTOLOAD FLAG
	JMP	ITMBEG		;

;
; STAR-ASTERISK
;

ITMSTR:				;
	CMPB	#L$PAR,(R5)	; PREVIOUS ITEM LEFT PAREN?
	BNE	10$		; IF NE NO
	MOV	#RFLG,R2	; POINT TO RESIDENCY FLAG
	MOVB	1(R5),(R2)	; COPY FLAGS
	BICB	#177,(R2)	; CLEAR ALL BUT RESIDENCY FLAG
10$:				;
	MOV	SP,AFLG		; SET AUTOLOAD FLAG
	BR	ITMOP2		;


;
; EOS-END OF STATEMENT
;

ITMEOS:	MOV	R0,@(R3)+	;LINK ITEM TO CURRENT LIST
	MOV	R0,-(R3)	;
	CMP	R3,#$DSTK+2	; ZERO PARENTHESIS LEVEL
	BEQ	ITMES3		; IF EQ YES
ITMES1:	MOV	(PC)+,R1	;UNBALANCED PARENTHESIS
	.BYTE	E$R46,S$V2	;FATAL-NO RETURN
ITMES2:	JMP	FILNM2		;
ITMES3:				;
	RETURN			;




;
; SUBROUTINE TO BYPASS LEADING OR TRAILING BLANKS AND HT'S
;

BYPASS:				;++033
	TSTB	(R0)		;TERMINAL ZERO?
	BEQ	5$		;IF EQ YES
	CMPB	#';,(R0)	;COMMENT TERMINATOR?
	BNE	10$		;IF NE NO
5$:	CMP	R4,#$TSTK-4	; ANY TO UNSTACK?
	BHIS	10$		;IF HIS NO
	CMP	(R4)+,(R4)+	;REMOVE ENTRY FROM TEXT STACK
	MOV	(R4),R0		;GET ADDRESS OF NEXT BYTE
	BR	BYPASS		;GO AGAIN
10$:	MOV	R0,(R4)		;SAVE ADDRESS OF NEXT BYTE
	RETURN			;

;
; SUBROUTINE TO GET NEXT ITEM FROM SEGMENT DESCRIPTION
;
; INPUTS:
;
;	R4=ADDRESS OF TOP OF TEXT POINTER STACK.
;
; OUTPUTS:
;
;	R0=ADDRESS OF NEXT ITEM.
;

ITEM:	MOV	#$EOSOP,R0	; ASSUME EOS
	TSTB	@(R4)		;END OF SEGMENT DESCRIPTION?
	BEQ	40$		;IF EQ YES
	CMPB	#';,@(R4)	;COMMENT ALSO ENDS DESCRIPTION
	BEQ	40$		;IF EQ COMMENT TERMINATION
	MOV	(R4),R0		;GET ADDRESS OF NEXT BYTE
	MOV	#CNTRL,R1	;GET ADDRESS OF CONTROL BYTE STRING
	CMPB	(R1)+,(R0)	;LEFT BRACKET?
	BEQ	50$		;IF EQ YES
	CMPB	(R1)+,(R0)	;LEFT ANGLE BRACKET?
	BEQ	50$		;IF EQ YES
	CMPB	(R1)+,(R0)	;"$"?
	BEQ	50$		;IF EQ YES
	CMPB	(R1)+,(R0)	;POSSIBLY NUMERIC?
	BHI	10$		;IF HI NO
	CMPB	(R1)+,(R0)	;NUMERIC?
	BHIS	50$		;IF HIS YES
	CMPB	(R1)+,(R0)	;POSSIBLY ALPHABETIC?
	BHI	10$		;IF HI NO
	CMPB	(R1),(R0)	;ALPHABETIC?
	BHIS	50$		;IF HIS YES

;
; OPERATOR PROCESSING
;

10$:	MOV	#OBASE-OBAS,R5	;GET NUMBER OF OPERATORS
	MOVB	(R0)+,R1	;GET NEXT BYTE
20$:	CMPB	R1,OBAS-1(R5)	;OPERATOR MATCH?
	BEQ	30$		;IF EQ YES
	SOB	R5,20$		;REPEAT
	MOV	(PC)+,R1	;ILLEGAL OPERATOR
	.BYTE	E$R43,S$V2	;FATAL-NO RETURN
	JMP	FILNM2		;
30$:	CALL	BYPASS		;BYPASS TRAILING BLANKS AND HT'S
	MOV	#$EXCL,R0	; GET EXCLAMATION POINT ENTRY
	CMPB	OPRV-1(R5),#E$XCL ; EXCLAMATION POINT?
	BEQ	40$		; IF EQ YES
	MOV	#$STAR,R0	; ASSUME ASTERISK OPERATOR
	CMPB	OPRV-1(R5),#S$TAR ; AUTOLOAD OPERATOR?
	BEQ	40$		; IF EQ YES
	MOV	#4,R1		;GET SIZE OF BLOCK NEEDED
	CALL	$ALBLK		;ALLOCATE STORAGE
	MOV	#4*400,T$YP(R0)	; SET SIZE OF ENTRY
	MOVB	OPRV-1(R5),T$YP(R0) ; SET TYPE OF ENTRY
40$:	RETURN			;

;
; OPERAND PROCESSING
;

50$:	MOV	#TMP,R5		;GET ADDRESS OF TEMP STORAGE
	MOV	R0,-(SP)	;SAVE ADDRESS FOR POSSIBLE RESCAN
	CALL	$RP		;CONVERT OPERAND NAME
	DEC	R0		;BACK UP TO TERMINATOR
	CMP	-(R5),-(R5)	;POINT TO NAME
	CMPB	#':,(R0)	;COLON TERMINATOR?
	BEQ	FILNM		;IF EQ YES-FILE
	CMPB	#'.,(R0)	;PERIOD TERMINATOR?
	BEQ	FILNM		;IF EQ YES-FILE
	CMPB	#'[,(R0)	;LEFT BRACKET TERMINATOR?
	BEQ	FILNM		;IF EQ YES-FILE
	CMPB	#'<,(R0)	;LEFT ANGLE BRACKET TERMINATOR?
	BEQ	FILNM		;IF EQ YES-FILE
	CMPB	#'/,(R0)	;SLASH?
	BEQ	FILNM		;IF EQ YES-FILE
	MOV	R0,R1		;COPY ADDRESS OF NEXT BYTE
	SUB	(SP),R1		;CALCULATE LENGTH OF NAME
	CMP	R1,#7		;POSSIBLE DIRECTIVE OR LABEL?
	BHIS	FILNM		;IF HIS NO
	CALL	$SCNL		;SCAN DIRECTIVE LIST FOR MATCH			;LMP155
	BCS	FILNM		;IF CS NO FIND EM-FILE				;LMP155
	CMP	R2,#'_		;IS THIS REALLY JUST PART OF A LOGICAL?		;LMP155
	BEQ	FILNM		;IF EQ YES JUST TREAT LIKE A FILE (THIS WORKS!)	;LMP155
	TST	(SP)+		;CLEAN STACK					;**-2
	CALL	BYPASS		;BYPASS TRAILING BLANKS AND HT'S
	TSTB	T$YP(R1)	; FACTOR DIRECTIVE
	BEQ	70$		;IF EQ YES
	MOV	R1,-(SP)	;SAVE ADDRESS OF ENTRY
	MOVB	T$YP+1(R1),R1	; GET SIZE OF ENTRY
	MOV	R1,-(SP)	;SAVE SIZE OF ENTRY
	CALL	$ALBLK		;ALLOCATE STORAGE
	MOV	R0,R1		;COPY ADDRESS OF BLOCK
	MOV	(SP)+,R5	;RETRIEVE SIZE OF ENTRY
	MOV	(SP)+,R2	;RETRIEVE ADDRESS OF ENTRY
60$:	MOVB	(R2)+,(R1)+	;COPY ENTRY
	SOB	R5,60$		;REPEAT
	RETURN			;
70$:	CMP	R4,#$TSTK-<N$SLVL*4>	; ANY MORE ROOM ON TEXT STACK ?
	BLOS	80$		;IF LOS NO
	MOV	R1,-(R4)	;STACK ENTRY ADDRESS
	MOV	N$XT(R1),-(R4)		; STACK ADDRESS OF NEXT BYTE
	BR	ITEM		;GO AGAIN
80$:	MOV	(PC)+,R1	;TOO MANY NESTED .SEG/.ROOT DIRECTIVES
	.BYTE	E$R44,S$V2	;FATAL-NO RETURN
	JMP	FILNM2		;

;
; FILE OPERAND PROCESSING
;

FILNM:	MOV	(SP)+,R0	;RETRIEVE ADDRESS OF NEXT BYTE FOR RESCAN
	MOV	#$LNBUF,R5	;GET ADDRESS OF LINE BUFFER
	CLR	-(SP)		;CLEAR BRACKET COUNT
10$:	TSTB	(R0)		;ZERO BYTE?
	BEQ	20$		;IF EQ YES
	CMPB	#'-,(R0)	;DASH?
	BEQ	20$		;IF EQ YES
	CMPB	#'),(R0)	;RIGHT PARENTHESIS?
	BEQ	20$		;IF EQ YES
	CMPB	#'(,(R0)	;++039 LEFT PARENTHESES
	BEQ	20$		;++039 IF EQ YES
	CMPB	#'*,(R0)	;++039 ASTERISK?
	BEQ	20$		;++039 IF EQ YES
	TST	(SP)		;IN BRACKETS?
	BNE	13$		;IF NE YES
	CMPB	#',,(R0)	;COMMA?
	BEQ	20$		;IF EQ YES
13$:	INC	(SP)		;ASSUME LEFT BRACKET
	CMPB	#'[,(R0)	;LEFT BRACKET?
	BEQ	17$		;IF EQ YES
	DEC	(SP)		;DECREMENT BRACKET COUNT
	CMPB	#'],(R0)	;RIGHT BRACKET?
	BNE	17$		;IF NE NO
	DEC	(SP)		;DECREMENT BRACKET COUNT
17$:	MOVB	(R0)+,(R5)+	;MOVE BYTE TO LINE BUFFER
	BR	10$		;CONTINUE SCAN
20$:	TST	(SP)+		;BALANCED BRACKETS?
	BNE	40$		;IF NE NO
	CALL	BYPASS		;BYPASS TRAILING BLANKS AND HT'S
	MOV	#T$MSIZ,R1	;GET SIZE OF CSI BLOCK
	CALL	$ALBLK		;ALLOCATE CSI BLOCK
	SUB	#$LNBUF,R5	;CALCULATE LENGTH OF LINE SEGMENT
	CSI$1	R0,#$LNBUF,R5	;ANALYZE SYNTAX
	BCS	40$		;IF CS SYNTAX ERROR
	MOV	R0,R5		;SAVE ADDRESS OF CSI BLOCK
	CALL	$CLRMN		; INITIALIZE SWITCH VALUE LIST
	MOV	$INIPT,R0	; GET INPUT FILE RECORD BLOCK
	MOV	R5,R1		;SET ADDRESS OF CSI BLOCK
	CALL	$SCANO		;SCAN FOR OUTPUT FILE
	BCS	40$		;IF CS SYNTAX ERROR
	CALL	$BLMNT		; BUILD MODULE NAME LIST IF LIBRARY FILE
	MOV	#<S$V2*400!E$R78>,R1 ; ASSUME ERROR
	BCS	FILNM2		; IF C/S INCORRECT MODULE SPECIFICATION
	MOV	#$FRHD,R0	;GET ADDRESS OF FREE SPACE POOL LISTHEAD
	MOV	#T$MSIZ,R1	;GET SIZE OF BLOCK  TO RELEASE
	MOV	R5,R2		;SET ADDRESS OF BLOCK TO RELEASE
	CALL	$RLCB		;RELEASE BLOCK
	MOV	$INIPT,R0	; GET INPUT FILE RECORD BLOCK POINTER
	MOV	F.DFNB(R0),-(SP) ; SAVE POINTER TO NAMEBLOCK
	BIT	#SW$LB,R$SWTH(R0) ; LIBRARY FILE?
	BEQ	30$		; IF EQ NO
	MOV	#$LIBNB,F.DFNB(R0) ; REPLACE DEFAULT NAME BLOCK
30$:				;
	CALL	$PRFND		;PARSE/FIND FILE
	MOV	(SP)+,F.DFNB(R0) ; RESTORE DEFAULT NAMEBLOCK POINTER
	MOV	R$NAME(R0),R2	;GET ADDRESS OF NAME STRING
	MOV	(PC)+,R1	;ASSUME PARSE/FIND FAILURE
	.BYTE	E$R57,S$V2	;FATAL-NO RETURN
	BCS	FILNM3		;IF CS PARSE/FIND FAILURE
	CALL	$ALELD		; ALLOCATE ELEMENT DESCRIPTOR
	BIT	#SW$DL,E$LSWT(R0) ; DEFAULT LIBRARY SPECIFIED?
	BEQ	35$		; IF EQ NO
	TST	$LIBNM		; PREVIOUS DEFAULT SPECIFIED?
	BNE	40$		; IF NE YES, SYNTAX ERROR
	MOV	R1,$LIBNM	; SET DEFAULT LIBRARY
	MOV	$LBSWT,E$LSWT(R0) ; SET LIBRARY FILE SWITCH WORD
35$:				;
	MOV	$LBMOD,E$LIDT+2(R0) ; SET IN ADDRESS OF MODULE NAME LIST
	MOV	$INIPT,R2	; GET ADDRESS OF RECORD BLOCK POINTER
	MOV	$DFINP,R$SWTH(R2) ; RESET SWITCH WORD
	MOV	R1,-(SP)	; SAVE VIRTUAL ADDRESS OF DESCRIPTOR
	MOV	#6,R1		; GET LENGTH OF BLOCK FOR ITEM
	CALL	$ALBLK		; ALLOCATE CORE BLOCK
	MOV	R0,R1		; COPY ADDRESS OF BLOCK
	TST	(R1)+		; POINT TO TYPE/SIZE
	MOV	#<6*400!F$ILE>,(R1)+ ; SET TYPE/SIZE
	MOV	(SP)+,(R1)+	; SET VIRTUAL ADDRESS OF ELEMENT DESCR.
	RETURN			;
40$:	MOV	(PC)+,R1	;SYNTAX ERROR
	.BYTE	E$R37,S$V2	;FATAL-NO RETURN
FILNM2:	MOV	#$LNDES,R2	;GET ADDRESS OF LINE DESCRIPTOR
	MOV	2(R4),R0	;GET ADDRESS OF PARSED DIRECTIVE
	MOVB	T$YP+1(R0),(R2)+ ; GET SIZE OF ENTRY+LINE
	CLRB	(R2)+		; CLEAR TOP BYTE OF COUNT WORD
	SUB	#11.,-(R2)	; SUBTRACT OUT SIZE OF ENTRY
	ADD	#N$XT+2,R0	; CALCULATE ADDRESS OF LINE
	MOV	R0,2(R2)	;SET ADDRESS OF LINE
FILNM3:	CALL	$ERMSG		;OUTPUT ERROR MESSAGE

	.END
