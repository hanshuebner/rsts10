	.TITLE	MLSG2
	.IDENT	/12.06/
;
; COPYRIGHT (c)	1985 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE IS FURNISHED  UNDER A LICENSE AND MAY BE USED OR
; COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;
; D. N. CUTLER/C. MONIA 10-DEC-73
;
; MODIFIED FOR RSX-11M/M-PLUS V4.0/V2.0 BY:
;
;	J. A. KASSON
;
; MODIFIED FOR RSX-11M/M-PLUS V4.1/V2.1 BY:
;
;	C. B. Petrovic
;	J. M. Salman
;
; MODIFIED BY:
;
;	D. P. Rabahy	08-NOV-85
;		DPR026	Correct stack abuse problem			V12.05
;			response to SPR #69483
;
;	C. B. Petrovic	14-NOV-86
;		CBP200	Add option 'RNDSEG'				V12.06
;
;
; BUILD THE SEGMENT DESCRIPTION FOR AN OVERLAYED TASK
;
; LOCAL DATA
;
; AUTOLOAD ENTRY POINT NAME
;
	IMPURE			; READ/WRITE D-SPACE

AUTO:	.RAD50	/.NAUTO/
	.BLKW	2		;


;
; NAME OF POINTER TO IMPURE AREA IN OVERLAY RUNTIME ROUTINES
;

NOVLY:	.RAD50	/.NOVLY/	;
	.BLKW	2		;


;
; TEMPORARY STORAGE
;

TMP:	.BLKW	5

;
; TASK IMAGE FILE SWITCHES
;

TSKSW:	.BLKW	1		;

;
; CURRENT WINDOW OFFSET INTO WINDOW DESCRIPTOR SECTION
;

WNOFF:	.BLKW	1		;

;
; WINDOW DESCRIPTOR FLAGS
;

WNFLG:	.BLKW	1		;


;
;+
; **-MLSG2-BUILD SEGMENT DESCRIPTORS
;
; INPUTS:
;
;	PARSED SEGMENT DESCRIPTION BUILT BY $MLSG1
;
; OUTPUTS:
;
;	$PATH=ADDRESS OF PATH LIST
;	$SGLST=ADDRESS OF SEGMENT LIST
;
;	SEGMENT TABLES AND ELEMENT LIST FOR EACH SEGMENT
;
;
;	THIS ROUTINE IS ENTERED FROM $MULSG TO CONSTRUCT THE
; ABOVE TABLES. THE SEGMENT DESCRIPTORS ARE LINKED AND ELEMENT
; DESCRIPTORS STRUNG OFF EACH BRANCH. ANY .PSECTS SPECIFIED IN
; THE ODL ARE ENTERED IN THE SECTION TABLE OF THE APPROPRIATE
; SEGMENT.
;
; IF THE NUMBER OF SEGMENTS EXCEEDS ONE, BUFFERS FOR THE
; SEGMENT AND PATH LISTS ARE ALLOCATED.
;
;-
	PURE.I			; READ-ONLY I-SPACE

$MLSG2::			;
	MOV	#$DIRHD,R5	; GET ADDRESS OF PARSED DIRECTIVE HEADER
	CALL	RELEAS		; RELEASE MEMORY
	MOV	$TSKNM,R1	; GET ADDRESS OF TASK FILE NAMEBLOCK
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	MOV	E$LSWT(R0),TSKSW ; COPY TASK SWITCHES
	CLR	WNOFF		; CLEAR WINDOW OFFSET INTO SECTION
	MOV	#<WS.MAP!WS.64B>,WNFLG ; SET TO MAP ON CREATE, AND ALIGN
	BIT	#SW$CM,TSKSW	; TASK IN COMPATIBILITY MODE?
	BEQ	5$		; IF EQ NO
	BIC	#WS.64B,WNFLG	; CLEAR 64-BYTE ALIGNMENT
5$:				;
	MOV	#$DSTK,R0	; GET ADDRESS OF DESCRIPTION STACK
10$:	MOV	R0,R1		;COPY HEADER ADDRESS
	TST	(R0)+		;POINT TO LAST
	MOV	R1,(R0)+	;LAST POINTS TO FIRST INITIALLY
	CMP	R0,#$DSTK+<N$PLVL*4> ; END OF LIST?
	BLO	10$		;IF LO NO
	MOV	#$DSTK+2,R4	; GET ADDRESS OF FIRST HEADER
	MOV	(R4),R3		;GET ADDRESS OF NEXT ITEM
	MOV	$RTSEG,R1	; GET VITUAL ADDRESS OF ROOT SEGMENT
	CALL	$CVLOK		; CONVERT TO REAL, LOCK IN MEMORY
	CALL	$WRMPG		; WRITE MARK PAGE
	CALL	GNSEG		;GENERATE SEGMENT DESCRIPTORS
	MOV	$CRVSG,R1	; GET VIRTUAL ADDRESS OF LAST SEGMENT
	CALL	$WRMPG		; WRITE-MARK PAGE
	CALL	$UNLPG		; UNLOCK PAGE
	MOV	#$DSTK,R4	; GET ADDRESS OF DESCRIPTION STACK
20$:	MOV	R4,R5		;SET HEADER ADDRESS
	CALL	RELEAS		;RELEASE MEMORY
	CMP	(R4)+,(R4)+	;ADJUST TO NEXT HEADER
	CMP	R4,#$DSTK+<N$PLVL*4> ; END OF LIST?
	BLO	20$		;IF LO NO
	MOV	#SY$GBL,R0	; SET GLOBAL FLAG
	BIT	#SW$NH,TSKSW	; TASK IMAGE HAVE HEADER?
	BEQ	21$		; IF EQ NO
	BISB	#SY$WK,R0	; FLAG WEAK REFERENCE
21$:				;
	MOV	R0,AUTO+S$YFLG-S$YM ; SET SYMBOL TABLE FLAGS
	MOV	R0,NOVLY+S$YFLG-S$YM ; ...
	TST	$TSKWD		; TASK HAVE RESIDENT OVERLAYS?
	BEQ	210$		; IF EQ NO
	BIT	#SW$NH,TSKSW	; BUILDING RESIDENT LIBRARY?
	BEQ	210$		; IF EQ NO
	MOV	#1,$NUMRG	; SET NUMBER OF REGION DESCRIPTORS
210$:				;
	MOV	$NUMSG,R1	; GET NUMBER OF SEGMENTS
	CMP	R1,#1		; MORE THAN ONE SEGMENT?
	BEQ	22$		; IF EQ NO
	ASL	R1		; MULTIPLY BY 2
	INC	R1		; ACCOUNT FOR TERMINAL ZERO IN LISTS
	ASL	R1		; MULTIPLY BY 2
	MOV	R1,R3		; HAVE LENGTH OF ONE LIST
	ASL	R1		; CONVERT TO LENGTH IN BYTES
	CALL	$ALBLK		; ALLOCATE BLOCK
	MOV	R0,$PATH	; SAVE ADDRESS OF PATH LIST BUFFER
	ADD	R3,R0		; COMPUTE ADDRESS OF SEGMENT LIST BUFFER
	MOV	R0,$SGLST	; SAVE ADDRESS OF SEGMENT LIST
22$:				;
	MOV	#NOVLY,R5	; POINT TO IMPURE AREA NAME
	CALL	25$		;INSERT IN SYMBOL TABLE
	TST	$AFLG		; AUTOLOAD SPECIFIED?
	BEQ	30$		;IF EQ NO
	MOV	#AUTO,R5	;POINT TO NAME OF AUTOLOAD ROUTINE
25$:				;
	MOV	$RTSEG,R1	; GET ADDRESS OF ROOT SEGMENT
	CALL	$CVLOK		; CONVERT TO REAL, LOCK IN MEMORY
	CALL	$WRMPG		; WRITE-MARK PAGE
	MOV	R0,R4		; SAVE REAL ADDRESS OF SEGMENT
	BITB	#SY$WK,S$YFLG-S$YM(R5) ; WEAK REFERENCE?
	BNE	27$		; IF NE YES
	INC	$MSYMC		; INCREMENT MASTER UNDEFINED COUNT
	INC	S$GUND(R4)	; INCREMENT COUNT OF UDEFINED SYMBOLS
27$:				;
	MOV	#S$YLGH,R1	; GET LENGTH OF SYMBOL TABLE ENTRY
	CALL	$ALVRT		; ALLOCATE VIRTUAL MEMORY
	MOV	(R5)+,S$YM(R0)	; SET NAME OF SYMBOL
	MOV	(R5)+,S$YM+2(R0) ; SET SECOND HALF OF NAME
	MOV	(R5),S$YFLG(R0)	; SET FLAGS
	MOV	$ASCT,S$YCMT(R0) ; SET ADDRESS OF DEFINING SECTION
	MOV	$RTSEG,R0	; GET ADDRESS OF SEGMENT
	MOV	R0,(R5)+	; SET SEGMENT ADDRESS
	MOV	R1,(R5)+	; SET ADDRESS OF SYMBOL
	ADD	#S$GSTB/2,R0	; GET VIRTUAL DESCRIPTOR ADDRESS
	CALL	$SRCHI		;SEARCH FOR INSERT
	CALL	$ISYM		;INSERT SYMBOL
	MOV	R5,R1		; COPY DESCRIPTOR ADDRESS
	SUB	#<4+3>*2,R1	; COMPUTE DESCRIPTOR ADDRESS MINUS OFFSET
	MOV	#$SYMHD,R0	; GET ADDRESS OF MASTER TABLE LISTHEAD
	CALL	$SRCIV		; SEARCH FOR INSERTION
	CALL	$ISYMV		; INSERT SYMBOL
29$:				;
	MOV	$RTSEG,R1	; GET ADDRESS OF ROOT SEGMENT
	CALL	$UNLPG		; UNLOCK PAGE
30$:	RETURN			;

;
; SUBROUTINE TO GENERATE SEGMENT DESCRIPTORS
;

GNSEG:				;
	MOV	$CRVSG,R1	; GET VIRTUAL ADDRESS OF CURRENT SEGMENT
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	MOV	R0,R5		; SET REAL ADDRESS OF CURRENT
	MOV	R0,$CRSEG	; SET REAL ADDRESS OF CURRENT
	MOV	(R3),R3		; GET ADDRESS OF NEXT ITEM TYPE
	MOVB	T$YP(R3),R2	; GET ITEM TYPE
	BIC	#1,R2		;CLEAR POSSIBLE AUTOLOAD BIT
	JMP	@DSPVCT(R2)	; DISPATCH ON ITEM TYPE

;
; ITEM TYPE DISPATCH VECTOR
;

	PURE.D			; READ-ONLY D-SPACE

DSPVCT:	.WORD	GNSEG		;SOS
	.WORD	GNRPAR		;EOS
	.WORD	GNLPAR		;LPAR
	.WORD	GNRPAR		;RPAR
	.WORD	GNCOMA		;COMA
	.WORD	GNDASH		;DASH
	.WORD	GNSEG		;STAR
	.WORD	GNSEG		; EXCLAMATION POINT
	.WORD	GNSCTN		;SCTN
	.WORD	GNSEGN		;SEGN
	.WORD	GNFILE		;FILE

	PURE.I			; READ-ONLY I-SPACE

;
; LPAR-LEFT PARENTHESIS
;

GNLPAR:	BIT	#1,T$YP(R3)	; AUTOLOAD SPECIFIED?
	BEQ	10$		;IF EQ NO
	BIS	#SG$ATL,S$GSTS(R5)	; SET AUTOLOAD FLAG
10$:				;
	MOV	(R3),R0		; GET ADDRESS OF NEXT ITEM
	CMPB	#S$CTN,T$YP(R0)	; OPERAND?
	BLOS	GNSEG		;IF LOS YES
	CALL	GNLVL		;CHANGE LEVEL
	BR	GNSEG		;

;
; RPAR-RIGHT PARENTHESIS
;

GNRPAR:	RETURN			;

;
; COMA-COMMA
;

GNCOMA:	CALL	$ALSGD		;ALLOCATE SEGMENT DESCRIPTOR
	CALL	$LCKPG		; LOCK NEW SEGMENT IN MEMORY
	BIT	#ID$ATA,$SWTCH	; WE BUILDING AN I/D TASK?
	BEQ	1$		; IF EQ, NO...COPY WDB DATA FOR I-SPACE TASK
	MOV	S$GDWP(R5),S$GDWP(R0) ; COPY D-SPACE WDB ADDRESS
	MOV	S$GDWD(R5),S$GDWD(R0) ; COPY D-SPACE WINDOW DESC. OFFSET
1$:
	MOV	S$GWDP(R5),S$GWDP(R0) ; COPY ADDRESS OF WINDOW BLOCK
	MOV	S$GWND(R5),S$GWND(R0) ; COPY WINDOW DESCRIPTOR OFFSET
	BITB	#SG$RES,S$GSTS(R5) ; CURRENT SEGMENT RESIDENT?
	BEQ	5$		; IF EQ NO
	TST	S$GDWN(R5)	; CURRENT=ROOT?
	BEQ	5$		; IF EQ YES
	MOV	R1,-(SP)	; SAVE ADDRESSES
	MOV	R0,-(SP)	; ...
	CALL	ALCWD		; ALLOCATE WINDOW DESCRIPTOR
	MOV	(SP)+,R0	; GET REAL ADDRESS OF DESCRIPTOR
	MOV	R2,S$GWND(R0)	; SAVE OFFSET INTO WINDOW
	MOV	R1,S$GWDP(R0)	; SET ADDRESS OF WINDOW DESCRIPTOR
	BIT	#ID$ATA,$SWTCH	; WE BUILDING AN I/D TASK?
	BEQ	2$		; IF EQ, NO...SAVE WDB DATA FOR I-SPACE
	MOV	R0,-(SP)	; SAVE DESCRIPTOR ADDRESS
	CALL	ALCWD		; ALLOCATE A WINDOW DESCRIPTOR
	MOV	(SP)+,R0	; RESTORE DESCRIPTOR ADDRESS
	MOV	R2,S$GDWD(R0)	; SAVE OFFSET INTO D-SPACE WINDOW
	MOV	R1,S$GDWP(R0)	; SET ADDRESS OF D-SPACE WINDOW DESCRIPTOR
2$:
	MOV	(SP)+,R1	; RESTORE VIRTUAL ADDRESS OF SEGMENT
	BISB	#SG$RES,S$GSTS(R0) ; MARK SEGMENT RESIDENT
5$:				;
	BIT	#1,T$YP(R3)	; AUTOLOAD BIT SET?
	BEQ	10$		;IF EQ NO
	BIS	#SG$ATL,S$GSTS(R5)	; SET AUTOLOAD FLAG
10$:				;
	MOV	S$GNXT(R5),-(SP) ; GET LINK NEXT OF CURRENT
	MOV	R1,S$GNXT(R5)	; SET NEW LINK NEXT
	MOV	(SP),S$GNXT(R0)	; SET LINK NEXT OF NEW
	MOV	S$GDWN(R5),S$GDWN(R0) ;SET LINK DOWN OF NEW
	MOV	$CRVSG,S$GPRV(R0) ; SET LINK TO PREVIOUS
	MOV	R0,$CRSEG	; SAVE REAL ADDRESS OF SEGMENT
	MOV	R1,$CRVSG	; SAVE VIRTUAL ADDRESS OF SEGMENT
	MOV	S$GPRV(R0),R1	; GET VIRTUAL ADDRESS OF PREVIOUS
	CALL	$UNLPG		; UNLOCK PAGE
	MOV	(SP)+,R1	; GET VIRTUAL ADDRESS OF LINK NEXT
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	CALL	$WRMPG		; WRITE-MARK PAGE
	MOV	$CRVSG,S$GPRV(R0) ; SET NEW LINK TO PREVIOUS
	MOV	(R3),R1		;GET ADDRESS OF NEXT ITEM
	CMPB	#S$CTN,T$YP(R1)	; OPERAND?
	BLOS	GNSGIN		; IF LOWER OR SAME, YES (CORRECTS FOR AN
				; OUT-OF-RANGE BRANCH).
	CALL	GNLVL		;CHANGE LEVEL
	MOV	R1,-(SP)	; SAVE VIRTUAL ADDRESS OF CURRENT SEGMENT
	JMP	GND1

;
; DASH-MINUS
;

GNDASH:	MOV	(R3),R0		;GET ADDRESS OF NEXT ITEM
	CMPB	#S$CTN,T$YP(R0)	; OPERAND?
	BLOS	GNSGIN		; IF LOS YES (CORRECTS OUT-OF-RANGE BRANCH)
	CALL	$ALSGD		;ALLOCATE SEGMENT DESCRIPTOR
	BIT	#ID$ATA,$SWTCH	; IS THIS TASK USER I/D??
	BEQ	10$		; IF EQ, NO..CONVENTIONAL
	MOV	S$GDWP(R5),S$GDWP(R0) ; COPY D-SPACE WDB ADDRESS
	MOV	S$GDWD(R5),S$GDWD(R0) ; COPY D-SPACE WINDOW DESC. OFFSET TOO
10$:
	MOV	S$GWDP(R5),S$GWDP(R0) ; SET ADDRESS OF WINDOW BLOCK
	MOV	S$GWND(R5),S$GWND(R0) ; COPY DESCRIPTOR OFFSET
	CALL	$LCKPG		; LOCK NEW IN CORE
	MOV	R1,S$GUP(R5)	; SET LINK UP OF CURRENT
	MOV	$CRVSG,S$GDWN(R0) ; SET LINK DOWN OF NEW
	MOV	R1,$CRVSG	; SET NEW CURRENT SEGMENT
	MOV	S$GDWN(R0),R1	; GET VIRTUAL ADDRESS OF OLD
	CALL	$WRMPG		; WRITE-MARK PAGE
	CALL	$UNLPG		; UNLOCK PAGE BUFFER
	CALL	GNLVL		;CHANGE LEVEL
	CALL	$CVRL		; GET REAL ADDRESS OF CURRENT SEGMENT
	MOV	S$GDWN(R0),-(SP) ; RESTORE CURRENT SEGMENT
GND1:				;
	MOV	$CRVSG,R1	; GET VIRTUAL ADDRESS OF CURRENT SEG.
	CALL	$UNLPG		; UNLOCK CURRENT
	MOV	(SP)+,R1	; GET NEW CURRENT
	CALL	$CVLOK		; CONVERT TO REAL, LOCK IN MEMORY
	CALL	$WRMPG		; WRITE-MARK PAGE
	MOV	R1,$CRVSG	; SET NEW CURRENT
GNSGIN:
	JMP	GNSEG		;

;
; SCTN-SECTION NAME
;

GNSCTN:	MOV	R3,R1		;COPY ADDRESS OF ITEM
	ADD	#L$AB,R1	; CALCULATE PROPER OFFSET
	SUB	#S$YM,R1	;
	MOV	R5,R0		;COPY ADDRESS OF CURRENT SEGMENT
	ADD	#S$GCST,R0	;POINT TO SECTION TABLE
	CALL	$SRCH		;SEARCH FOR SECTION NAME
	BCC	21$		;IF CC ALREADY THERE

	MOV	#C$SLGH,R1	;GET SIZE OF BLOCK NEEDED
	CALL	$ALVRT		; ALLOCATE VIRTUAL MEMORY
	MOV	R1,-(SP)	; SAVE VIRTUAL ADDRESS OF SECTION TABLE
	MOV	L$AB(R3),S$YM(R0) ; INSERT SECTION NAME
	MOV	L$AB+2(R3),S$YM+2(R0) ;
	MOVB	F$LG(R3),C$SFLG(R0) ; SET FLAG BYTE
	BICB	#CS$MEM,C$SFLG(R0) ; CLEAR MEMORY FLAG(USED FOR AUTOLOAD)
	BIT	#1,T$YP(R3)	; AUTOLOAD SPECIFIED?
	BEQ	10$		;IF EQ NO
	BISB	#CS$ATL,C$SFLG(R0) ; SET AUTOLOAD BIT
10$:				;
	MOV	$CRVSG,R0	; GET VIRTUAL ADDRESS OF CURRENT SEGMENT
	ADD	#S$GCST/2,R0	; POINT TO SECTION TABLE
	CALL	$SRCHI		;SEARCH FOR INSERT
	BCC	20$		;IF CC ALREADY DEFINED FOR SEGMENT
	CALL	$ISYM		;INSERT SECTION
	BIT	#SE$QA,$SWTCH	; SEQUENTIAL ALLOCATION?
	BEQ	20$		; IF EQ NO
	MOV	#S$ZSEQ,R1	; GET SIZE OF SEQUENTIAL LIST ENTRY
	CALL	$ALBLK		; ALLOCATE BLOCK
	MOV	(SP),2(R0)	; SET ADDRESS OF SECTION TABLE ENTRY
	MOV	$CRSEG,R1	; GET ADDRESS OF CURRENT SEGMENT
	MOV	R0,@S$GSEQ+2(R1) ; LINK NEW ENTRY TO OLD LIST
	MOV	R0,S$GSEQ+2(R1)	; SET NEW LAST ENTRY
20$:
	TST	(SP)+		; CLEAR STACK
21$:
	TST	S$GNME(R5)	; SEGMENT HAVE NAME YET?
	BNE	GNSEG2		;IF NE YES
	BR	GNSEG1		;GIVE IT NAME NOW

;
; FILE-FILE NAME
;

GNFILE:	MOV	4(R3),R1	; GET VIRTUAL ADDRESS OF ELEMENT DESCR.
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	CALL	$WRMPG		; WRITE-MARK PAGE
	CMP	R1,$LIBNM	; DEFAULT LIBRARY
	BNE	2$		; IF NE NO
	ADD	#<E$LMND+4>/2,R1 ; OFFSET TO FILE NAME
	BR	15$		; SET NAME OF SEGMENT
2$:				;
	MOV	E$LIDT+2(R0),-(SP) ; RECORD ADDRESS OF MNT TABLE (IF ANY)
	BNE	5$		; IF NE MODULE NAME-LIST ALLOCATED
	MOV	R1,(SP)		; COPY ADDRESS OF ELEMENT DESCRIPTOR
	ADD	#<E$LMND+4>/2,(SP) ; OFFSET TO FILE NAME
5$:				;
	BIT	#1,T$YP(R3)	; AUTOLOAD SPECIFIED?
	BEQ	10$		; IF EQ NO
	BIS	#SW$AL,E$LSWT(R0) ; SET AUTOLOAD FLAG
10$:				;
	MOV	$CRVSG,R0	; GET VIRTUAL ADDRESS OF CURRENT SEGMENT
	ADD	#<S$GELT/2>,R0	; OFFSET TO ELEMENT LISTHEAD
	MOV	#E$LNXT,R2	; GET OFFSET TO NEXT
	CALL	$LNKVM		; LINK VIRTUAL LIST
	MOV	(SP)+,R1	; GET VIRTUAL ADDRESS OF NAME
15$:				;
	TST	S$GNME(R5)	; SEGMENT HAVE NAME?
	BNE	GNSEG2		; IF NE YES
	CALL	$CVRL		; CONVERT NAME ADDRESS TO REAL
	MOV	(R0)+,S$GNME(R5) ; SET SEGMENT NAME
	MOV	(R0),S$GNME+2(R5) ; ...
	BR	GNSEG2		;

;
; SEGN-SEGMENT NAME
;

GNSEGN:	BIT	#1,T$YP(R3)	; AUTOLOAD SPECIFIED?
	BEQ	10$		; IF EQ NO
	BIS	#SG$ATL,S$GSTS(R5)	; SET AUTOLOAD FLAG
10$:				;
	BICB	#^C<SG$RES!SG$LOD>,S$GSTS(R5) ; CLEAR ALL BUT RESIDENCY, LOAD FL
	BISB	F$LG(R3),S$GSTS(R5) ; SET SEGMENT FLAGS
	CMP	$CRVSG,$RTSEG	; CURRENT = ROOT?
	BNE	GNSEG1		; IF NE NO
	BICB	#SG$MEM,S$GSTS(R5) ; MARK SEGMENT IN MEMORY
GNSEG1:	MOV	L$AB(R3),S$GNME(R5) ; SET SEGMENT NAME
	MOV	L$AB+2(R3),S$GNME+2(R5) ;
GNSEG2:				;
	BITB	#SG$RES,S$GSTS(R5) ; SEGMENT RESIDENT?
	BNE	10$		; IF NE YES
	BITB	#RS$FLG,T$YP+1(R3) ; RESIDENCY FLAG SET IN ITEM?
	BEQ	10$		; IF EQ NO
	BIT	#MP$SY,$SWTCH	; SYSTEM MAPPED?
	BEQ	10$		; IF EQ NO
	BIT	#RS$OV,$SWTCH	; RESIDENT OVERLAYS RECOGNIZED?
	BNE	10$		; IF NE NO
	BISB	#SG$RES,S$GSTS(R5) ; SET RESIDENCY FLAG
	CALL	ALCWD		; ALLOCATE WINDOW BLOCK
	MOV	R1,S$GWDP(R5)	; SET ADDRESS OF WINDOW BLOCK
	MOV	R2,S$GWND(R5)	; SET OFFSET INTO DESCRIPTOR SECTION
	BIT	#ID$ATA,$SWTCH	; WE BUILDING AN I/D TASK?
	BEQ	5$		; IF EQ, NO...SAVE WINDOW ADDRESSES FOR I-SPACE
	CALL	ALCWD		; ALLOCATE A WINDOW DESCRIPTOR
	MOV	R1,S$GDWP(R5)	; SET ADDRESS OF D-SPACE WINDOW DESCRIPTOR
	MOV	R2,S$GDWD(R5)	; SAVE OFFSET INTO D-SPACE WINDOW
5$:
10$:				;
	JMP	GNSEG		;

;
; SUBROUTINE TO CHANGE LEVLES
;

GNLVL:	MOV	R3,(R4)		;SAVE ADDRESS OF CURRENT ITEM
	CMP	(R4)+,(R4)+	;ADVANCE LEVEL
	MOV	(R4),R3		;GET ADDRESS OF CURRENT ITEM
	MOV	$CRVSG,-(SP)	; SAVE CURRENT VIRTUAL SEGMENT ADDRESS
	CALL	GNSEG		;RECURSE
	MOV	(SP)+,R1	; RESTORE VIRTUAL ADDRESS OF SEGMENT
	MOV	R3,(R4)		;SAVE ADDRESS OF CURRENT ITEM
	CMP	-(R4),-(R4)	;REDUCE LEVEL
	MOV	(R4),R3		;RETRIEVE ADDRESS OF CURRENT ITEM
	RETURN			;

;
; ALLOCATE WINDOW DESCRIPTOR
;

ALCWD:				;
	MOV	#W$NLGH,R1	; GET SIZE OF DESCRIPTOR
	CALL	$ALVRT		; ALLOCATE VIRTUAL MEMORY
	BIS	WNFLG,W.NSTS(R0) ; SET DESCRIPTOR FLAGS
	INC	$TSKWD		; INCREMENT TOTAL DESCRIPTOR COUNT
	MOV	WNOFF,R2	; GET OFFSET
	ADD	#W$NLGH,WNOFF	; SET OFFSET TO NEXT DESCRIPTOR
	RETURN			;

;
; SUBROUTINE TO RELEASE MEMORY
;

RELEAS:	MOV	(R5),R5		;GET ADDRESS OF FIRST ENTRY
	BEQ	20$		;IF EQ NONE TO RELEASE
10$:	MOV	R5,R2		;SET ADDRESS OF BLOCK TO RELEASE
	MOVB	T$YP+1(R2),R1	; SET SIZE OF BLOCK
	BIC	#177400!RS$FLG,R1 ; CLEAR EXTRANEOUS BITS
	MOV	#$FRHD,R0	;GET ADDRESS OF FREE SPACE HEADER
	MOV	(R5),R5		;GET ADDRESS OF NEXT ENTRY
	CALL	$RLCB		;RELEASE BLOCK
	TST	R5		;ANY MORE?
	BNE	10$		;IF NE YES
20$:	RETURN			;

	.END
