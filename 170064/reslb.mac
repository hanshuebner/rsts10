	.TITLE	RESLB
	.IDENT	/04.06/
;
; COPYRIGHT (c)	1988,1991 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE IS FURNISHED  UNDER A LICENSE AND MAY BE USED OR
; COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;
; C. MONIA 10-MAY-76
;
; MODIFIED FOR RSX-11M/M-PLUS V4.0/V2.0 BY:
;
;	C. B. PETROVIC
;	J. M. LAWLER
;
; MODIFIED BY:
;
;	C. B. PETROVIC	26-FEB-82	04.01
;		CBP039		ADD CORRECT .PSECT DEFINITIONS TO
;				ALLOW TKB TO BE LINKED AS AN I/D TASK.
;
;	P. K. M. WEISS	23-OCT-84	04.02
;		PKW072		ADD LOGICAL NAME SUPPORT
;
; MODIFIED FOR RSX-11M-PLUS AND MICRO/RSX V4.1 BY:
;
;	L. M. PETERSON	22-DEC-87	04.03
;		LMP098		ADD SUPPORT FOR LIBRARY D-SPACE RESERVATION
;				(NEW RESLIB PARAMETER)
;
; MODIFIED FOR RSX-11M-PLUS AND MICRO/RSX V4.2 BY:
;
;	L. M. PETERSON	8-JUN-88	04.04
;		LMP114		FIX ERROR HANDLING I SCREWED UP FOR 4.03
;
;	L. M. PETERSON	9-JAN-89	4.05
;		LMP126		ALLOW RW ACCESS TO SUPERVISOR MODE LIBRARIES
;			(reconstructed by LBM to propogate .COR across zero
;			of master pack for CPR v1 before M-PLUS v4.2 ship)
;
;	C. M. KATZ	23-APR-91	4.06
;		CMK001		ADD RSTS CONDITIONAL CODE and Goodwin correction
;
; PARSE RESIDENT LIBRARY OPTION INPUTS
;
; MACRO LIBRARY CALLS
;

	.IF	NDF,R$RSTS
	.MCALL	CSI$,CSI$SW,CSI$SV,CSI$ND,CSI$1,CSI$4
	CSI$
	.IFF
	.MCALL	CSI$,CSI$SW,CSI$SV,CSI$ND,CSI$1,CSI$2
	CSI$
	.ENDC
;
; LOCAL DATA
;
; DEFAULT LIBRARY STRING
;

	.PSECT	LBR$D,RO,D,GBL

LBDEV:	.ASCII	/LB/		;DEVICE
LBDVE:				; REF LABEL
	.IF	NDF,R$RSTS
LBDIR:	.ASCII	/[1,1]/		; DIRECTORY
	.IFF
LBDIR:	.ASCII	//		; DIRECTORY
	.ENDC
LBDRE:				; REF. LABEL

	IMPURE			; READ/WRITE D-SPACE

;
; CSI SWITCH BLOCK
;

SWTAB:	CSI$SW	RO,LD$ACC,$PARM+C.SIZE,CLEAR,,SVTAB
	CSI$SW	RW,LD$ACC,$PARM+C.SIZE,SET,,SVTAB
	CSI$ND


SWTAB2:
	CSI$SW	SV,LD$SMV,$PARM+C.SIZE,CLEAR,NEG,SVTAB
	CSI$SW	SW,LD$ACC,$PARM+C.SIZE,SET,NEG,SVTAB
	CSI$ND

;
; SWITCH VALUE DESCRIPTOR TABLE
;

SVTAB:	CSI$SV	OCTAL,$PARM+C.SIZE+2,2
	CSI$ND

;+
; **-$LBR-PARSE LIBRARY OR COMMON KEYWORD INPUT
;
; THIS ROUTINE IS CALLED BY THE PHASE 2 OPTION PROCESSOR
; TO PARSE THE RESIDENT LIBRARY KEYWORD OPTIONS 'LIBR' OR
; 'COMMON'. THE PARSED STRING DESCRIPTORS ARE PASSED AS
; INPUT TO THE LIBRARY KEYWORD PROCESSOR
;
; INPUTS:
;
;	R0=ADDRESS OF CURRENT COMMAND BYTE
;	R5=ADDRESS OF PARAMETER LIST
;
; OUTPUTS:
;
;	R0=ADDRESS OF NEXT BYTE IN COMMAND LINE
;	R2=TERMINAL CHARACTER
;	R5=ADDRESS FOLLOWING CSI BLOCK IN $PARM
;	$PARM CONTAINS CSI BLOCK WITH PARSED STRING DESCR-
;	IPTORS SETUP
;
;-
	PURE.I			; READ-ONLY I-SPACE

$LBR::				;
	MOV	R5,R2		; COPY ADDRESS OF PARAMETER LIST
	MOV	#C.SIZE/2+2,R1	; SET SIZE OF DESCRIPTOR PLUS SWITCH WORDS
10$:				;
	CLR	(R2)+		; CLEAR DESCRIPTOR
	SOB	R1,10$		; LOOP
	MOV	#-1,C.SIZE+2(R5) ; INITIALIZE APR NUMBER TO DEFAULT
	MOV	#LBDEV,C.DEVD+2(R5)	; SET DEFAULT DEVICE STRING DESCRIPTOR
	MOV	#<LBDVE-LBDEV>,C.DEVD(R5) ;
	MOV	#LBDIR,C.DIRD+2(R5) ; SET DEFAULT DIRECTORY STRING DESCR.
	MOV	#<LBDRE-LBDIR>,C.DIRD(R5) ; ...
	MOV	R0,R1		; COPY STRING POINTER
	MOV	R0,-(SP)	; SAVE STRING POINTER
	MOVB	#' ,R2		; SET CHARACTER FOR COMPARISON
20$:				;
	MOVB	(R1),(R0)	; COMPRESS ALL NON-PRINTING CHARACTERS
	BEQ	30$		; IF EQ, END OF LINE
	INC	R1		; INCREMENT POINTER
	CMPB	(R0),R2		; PASS CHARACTER?
	BLOS	20$		; IF LOS NO
	INC	R0		; INCREMENT BYTE POINTER
	CMPB	-1(R0),#';	; COMMENT TERMINATOR?
	BNE	20$		; IF NE NO
	CLR	R2		; PASS REMAINING CHARACTERS
	BR	20$		;
30$:				;
	SUB	R0,R1		; COMPUTE NUMBER OF BYTES DISCARDED
	SUB	R1,$LNDES	; ADJUST BYTE COUNT
	MOV	(SP)+,R0	; RESET BYTE POINTER
	MOV	R0,R1		; COPY POINTER
40$:				;
	MOVB	(R0)+,R2	; GET A BYTE
	BEQ	50$		; IF EQ END-OF-STRING
	CMPB	R2,#';		; COMMENT TERMINATOR?
	BEQ	50$		; IF EQ YES
	CMPB	R2,#'!		; EXCLAMATION POINT TERMINATOR?
	BEQ	50$		; IF EQ YES
	CMPB	R2,#',		; COMMA TERMINATOR?
	BEQ	50$		; IF EQ YES
	CMPB	R2,#':		; COLON TERMINATOR?
	BEQ	50$		; IF EQ YES
	CMPB	R2,#'/		; COLON EQUIVALENT?
	BNE	40$		; IF NE NO
	MOV	#':,R2		; CHANGE TO COLON
50$:				;
	MOV	R0,-(SP)	; SAVE STRING POINTER
	DEC	R0		; DECREMENT POINTER
	MOV	R1,C.FILD+2(R5) ; SET FILENAME DESCRIPTOR
	SUB	R1,R0		; COMPUTE LENGTH OF STRING
	MOV	R0,C.FILD(R5)	; SET LENGTH OF STRING
	MOV	(SP)+,R0	; RESTORE POINTER
	ADD	#C.SIZE,R5	; ADJUST LIST POINTER
	RETURN			; EXIT

;+
; **-$ACC-CHECK RESIDENT LIBRARY ACCESS CODE
;
; THIS ROUTINE IS CALLED BY THE PHASE 2 PARSER TO VERIFY THAT
; THE SPECIFIED RESIDENT LIBRARY ACCESS IS EITHER R/W OR R/O.
;
; INPUTS:
;
;	R0=ADDRESS OF CURRENT COMMAND BYTE
;	R5=ADDRESS OF PARAMETER LIST
;
; OUTPUTS:
;
;	R0=ADDRESS OF NEXT BYTE IN COMMAND STRING
;	R2=TERMINAL BYTE
;	R5=ADDRESS OF NEXT AVAILABLE WORD IN PARAMETER LIST
;	ADDRESS POINTED TO BY R5 ON INPUT RECEIVES  SETTING
;	OF SWITCH LD$ACC. WHERE:
;
;	LD$ACC=1, INDICATES R/W ACCESS REQUESTED
;	LD$ACC=0, INDICATES R/O ACCESS REQUESTED
;
;-

$ACC::				;
	CLR	(R5)+		; ASSUME NO ACCESS SPECIFIED
	CMPB	(R0)+,#'R	;
	BNE	30$		; IF NE ERROR
	CMPB	(R0),#'O	; R/O ACCESS?
	BEQ	10$		; IF EQ YES, EXIT
	MOV	#LD$ACC,-2(R5)	; ASSUME R/W ACCESS
	CMPB	(R0),#'W	; READ/WRITE ACCESS?
	BNE	30$		; IF NE NO
10$:				;
	INC	R0		; ADJUST BYTE POINTER
	MOVB	(R0)+,R2	; GET TERMINAL BYTE
	RETURN			;

30$:	JMP	ERXT
;+
; **-$RESLB-PARSE RESIDENT LIBRARY KEYWORD INPUT
;
; THIS SUBROUTINE IS CALLED BY THE PHASE 2 OPTION PARSER TO
; PARSE THE RESIDENT LIBRARY KEYWORD OPTIONS 'RESLIB' AND
; 'RESCOM'. THE PARSED STRING DESCRIPTOR IS FURNISHED AS INPUT
; TO THE LIBRARY KEYWORD PROCESSOR.
;
; INPUTS:
;
;	R0=ADDRESS OF CURRENT COMMAND BYTE
;	R5=ADDRESS OF PARAMETER LIST
;
; OUTPUTS:
;
;	R0=ADDRESS OF NEXT BYTE IN COMMAND LINE
;	R2=TERMINAL CHARACTER
;	$PARM CONTAINS PARSED STRING DESCRIPTORS FOR FILE
;
;-

$RESLB::			;
	MOV	R0,C.CMLD+2(R5)	; SET ADDRESS OF STRING
	CLR	-(SP)		; CLEAR SLASH/COLON COUNT
	CLR	-(SP)		; CLEAR BRACKET COUNT
10$:				;
	MOVB	(R0)+,R2	; GET A CHARACTER
	BEQ	40$		; IF EQ, END-OF-STRING
	CMPB	R2,#',		; COMMA TERMINATOR?
	BEQ	30$		; IF EQ YES
	CMPB	R2,#'!		; EXCLAMATION POINT TERMINATOR?
	BEQ	40$		; IF EQ YES
	CMPB	R2,#'[		; OPEN BRACKET?
	.IF	DF,R$RSTS
	BEQ	15$		; START OF [P,PN]
	CMPB	R2,#'(		; OPEN PAREN ?
	.IFTF
	BNE	20$		; IF NE NO
	.IFT
15$:
	.ENDC
	INC	2(SP)		; INCREMENT BRACKET COUNT
	BR	10$		; GET NEXT CHARACTER
20$:				;
	CMPB	R2,#']		; CLOSE BRACKET?
	.IF	DF,R$RSTS
	BEQ	22$             ; YES, END OF [P,PN]
	CMPB	R2,#')		; CLOSE PAREN ?
	.IFTF
	BNE	25$		; IF NE NO
	.IFT
22$:
	.ENDC
	DEC	2(SP)		; DECREMENT BRACKET COUNT
	BR	10$		; GET NEXT CHARACTER
25$:
	CMPB	R2,#'/		; ACCESS SWITCH?
	BNE	28$		; IF NE NO
	INC	(SP)		; INDICATE '/' FOUND
	BR	10$		; GET NEXT CHARACTER
28$:
	CMPB	R2,#':		; COLON?
	BNE	10$		; IF NE NO
	TST	(SP)		; PART OF FILE SPEC?
	BEQ	10$		; IF EQ YES
	CMP	(SP),#1		; BASE APR COLON?
	BNE	29$		; IF NE NO
	INC	(SP)		; INDICATE BASE APR COLON FOUND
	BR	10$		; GET NEXT CHARACTER
29$:
	CMP	(SP),#2		; APR MASK COLON?
	BNE	10$		; IF NE NO - GET NEXT CHARACTER
	MOV	R0,(SP)		; SAVE LOCATION FOR LATER
	BR	10$		; GET NEXT CHARACTER
30$:				;
	TST	2(SP)		; IN BRACKETS?
	BNE	10$		; IF NE YES CONTINUE
40$:				;
	TST	2(SP)		; OUTSIDE OF BRACKETS?
	BNE	ERXT1		; IF NE NO, ERROR
	MOV	R0,R1		; SAVE STRING POINTER
	CMP	(SP),#2		; APR MASK?
	BLE	45$		; IF LE NO
	MOV	(SP),R0		; SET UP FOR CONVERSION
	MOV	R1,-(SP)	; STORE STRING POINTER WHILE CONVERTING
	MOV	R2,-(SP)	; STORE TERMINAL CHARACTER WHILE CONVERTING
	CALL	$COTB		; CONVERT
43$:
	MOV	#$PARM+C.SIZE+4,R0 ; STORE APR MASK
	MOV	R1,(R0)
	MOV	(SP)+,R2	; RESTORE TERMINAL CHARACTER
	MOV	(SP)+,R1	; RESTORE STRING POINTER
	MOV	(SP),R0		; OMIT APR MASK FROM CSI PARSING
	CMPB	-2(R0),#':	; BASE APR SPECIFIED?
	BNE	45$		; IF NE YES
	DEC	R0		; ALSO OMIT BASE APR COLON
45$:
	SUB	C.CMLD+2(R5),R0	; COMPUTE SIZE OF STRING
	DEC	R0		; ...
	MOV	R0,C.CMLD(R5)	; SAVE SIZE OF STRING
	CLR	C.SIZE(R5)	; CLEAR SWITCH WORD
	MOV	#-1,C.SIZE+2(R5) ; ASSUME A DEFAULT APR SPECIFICATION
	CSI$1	R5		; SCAN COMMAND STRING
	BCS	ERXT1		; IF C/S ERROR (RSTS BUG FIX CMK001)
	TST	$SUPLF		; SUPERVISOR-MODE LIBRARY?
	BEQ	50$		; IF EQ NO
	MOV	#SWTAB2,C.SWAD(R5) ;CHECK FOR SUPERVISOR MODE SWITCHES
	.IF	NDF,R$RSTS
	CSI$4	,OUTPUT		; PARSE COMMAND STRING
	.IFF
	CSI$2	,OUTPUT
	.ENDC
	BIT	#LD$SMV,C.MKW1(R0) ; VECTOR TREATMENT SPECIFIED?
	BNE	55$		; IF NE, YES WITH RO ACCESS
	BIT	#LD$ACC,C.MKW1(R0) ; RW VECTOR TREATMENT SPECIFIED?
	BEQ	ERXT1		; IF EQ, NO VECTOR TREATMENT AT ALL
	BIS	#LD$ACC,C.SIZE(R5) ; SET FOR RW ACCESS	
	BIT	#LD$ACC,C.MKW2(R0) ; SUPER MODE VECTORS WANTED?
	BNE	55$		; IF NE, YES
	BIS	#LD$SMV,C.SIZE(R5) ; SET FOR NO SUPER MODE VECTORS
	BR	55$
50$:
	MOV	#SWTAB,C.SWAD(R5) ; NORMAL LIBRARY
	.IF	NDF,R$RSTS
	CSI$4	,OUTPUT		; PARSE COMMAND STRING
	.IFF
	CSI$2	,OUTPUT
	.ENDC
	BIT	#LD$ACC,C.MKW1(R0) ; ACCESS SPECIFIED?
	BLOS	ERXT1		; IF CS OR EQ ERROR
55$:	MOV	R1,R0		; RESTORE STRING POINTER
	TST	(SP)+		; CLEAN STACK
	TST	(SP)+		; CLEAN STACK
	RETURN			;

ERXT1:	TST	(SP)+		; CLEAN STACK
ERXT:	TST	(SP)+		; CLEAN STACK
	MOV	#<S$V1*400!E$R30>,R1 ; GET ERROR/SEVERITY
	MOV	#$LNDES,R2	; POINT TO LINE DESCRIPTOR
	CALLR	$ERMSG		; REPORT ERROR

$SUPLB::
	INC	$SUPLF		; FLAG AS LINKING TO SUPERVISOR LIBRARY
	JMP	$LBR

$RESUP::
	INC	$SUPLF		; FLAG LINKING TO SUPERVISOR LIBRARY
	JMP	$RESLB


;+
;
; **-$SPV- CHECK SUPERVISOR-MODE LIBRARY VECTOR SWITCH
;
; THIS ROUTINE IS CALLED BY THE PHASE 2 PARSER TO VERIFY THAT
; THE SPEDIFIED SUPERVISOR-MODE LIRRARY SWITCH IS EITHER /SV OR /-SV
;
; INPUTS:

;
;	R0= ADDRESS OF CURRENT COMMAND BYTE
;	R5= ADDRESS OF PARAMETER LIST
;
; OUTPUTS:
;
;	R0= ADDRESS OF NEXT BYTE IN COMMAND STRING
;	R2= TERMINAL BYTE
;	R5= ADDRESS OF NEXT AVAILABLE WORD IN PARAMETER LIST
;	ADDRESS POINTED TO BY R5 ON INPUT RECIEVES SETTING
;	OF SWITCH LD$SMV. WHERE:
;
;	LD$SMV=1, INDICATES /-SV
;	LD$SMV=0, INDICATES /SV	
;
;-

$SPV::
	CLR	(R5)+		; ASSUME VECTORS SPECIFIED
	CMPB	(R0),#'-	; NO VECTORS?
	BNE	10$		; IF NE	NO
	MOV	#LD$SMV,-2(R5)	; SET FOR NO VECTORS
	TSTB	(R0)+		; ADJUST POINTER
10$:
	CMPB	(R0)+,#'S	; CORRECT SWITCH?
	BNE	ERXT		; IF NE NO
	CMPB	(R0)+,#'V	; READ ONLY ACCESS?
	BEQ	15$		; IF EQ, YES
	CMPB	-1(R0),#'W	; WRITE ACCESS?
	BNE	ERXT		; IF NE ERROR
	BIS	#LD$ACC,-2(R5)	; SET FOR WRITE ACCESS
15$:	MOVB	(R0)+,R2	; GET TERMINAL BYTE
	BNE	20$		; IF NE, THEN WE HAVE AN A.P.R REQUEST
	MOV	#-1,(R5)	; OTHERWISE MARK A DEFAULT REQUEST...
20$:
	RETURN


	.END
