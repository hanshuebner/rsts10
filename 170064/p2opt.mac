	.TITLE	P2OPT
	.IDENT	/29.15/
;
; COPYRIGHT (c)	1987,1991 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE IS FURNISHED  UNDER A LICENSE AND MAY BE USED OR
; COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;
; D.N. CUTLER 6-NOV-72
;
; PHASE 2 OPTION PROCESSING
;
; MODIFIED FOR RSX-11M/M-PLUS V4.0/V2.0 BY:
;
;	J. A. KASSON
;	E. POLLACK
;	C. B. PETROVIC
;	J. M. LAWLER
;
; MODIFIED FOR RSX-11M/M-PLUS V4.1/V2.1 BY:
;
;	C. B. PETROVIC
;	J. M. SALMAN
;
; MODIFIED BY:
;
;	D. P. Rabahy	08-NOV-85
;		DPR028	DON'T COMPARE COMMONS AND LIBRARIES		V29.08
;			RESPONSE TO SPR #77430
;
;	D. P. Rabahy	09-DEC-85
;		DPR029	KEEP THE COMMAND FILE OPEN, SPR #110X		V29.09
;
;	C. B. Petrovic	14-NOV-86
;		CBP200	ADD 'RNDSEG' OPTION				V29.10
;
;	D. P. Rabahy	12-JAN-87
;		DPR036	ENHANCE ASG OPTION, SPR #175P			V29.11
;
;	L. M. Peterson	14-JAN-87					V29.12
;		LMP076	IF TOTAL WINDOWS > 8 MAKE THIS M+ TASKBUILD (SPR#93140)
;
;	L. M. Peterson	4-AUG-87					V29.13
;		LMP094	FIX DPR029 FOR LIBRARY/COMMON OPTIONS (WHEN ! IS USED)
;			
; MODIFIED FOR RSX-11M-PLUS V4.1 BY:
;
;	L. M. Peterson	4-Nov-87					V29.14
;		LMP098	ADD NEW LIBR PARAMETER FOR LIBRARY D-SPACE SUPPORT
;
;	C. M. Katz	23-Apr-91					V29.15
;		CMK001	ADD RSTS CONDITIONAL CODE and GOODWIN CORRECTION
;
; MACRO LIBRARY CALLS
;

	.MCALL	CSI$, GCMLD$, CCML$
	GCMLD$
	CSI$

;
; EQUATED SYMBOLS
;
; MULTI-PARAMETER TRUE/FALSE DEFINITIONS
;

F=0				;NO MULTI PARAMETER CONSTRUCTION ALLOWED
T=1				;MULTI PARAMETER CONSTRUCTION IS ALLOWED

;
; MEMORY ALLOCATION FLAGS
;

EX$TSK==000001			;++041 EXTEND TASK KEYWORD LAST INVOKED
PA$RT==000002			;++041 PARTITION KEYWORD LAST INVOKED

;
; LOCAL MACROS
;
; DEFINE OPTION
;
; DFO	KW,MA,MS,A
;
; WHERE:
;
;	KW=A 1 TO 6 CHARACTER OPTION IDENTIFIER KEYWORD AND SUBROUTINE
;		ADDRESS. THE SUBROUTINE IS CALLED AFTER THE PARAMETERS
;		HAVE BEEN PARSED.
;	MA=MINIMUM NUMBER OF PARAMETERS REQUIRED.
;	MS=MULTI-PARAMETER T/F SWITCH.
;	A=ADDRESS OF THE CONVERSION ROUTINES FOR THE ARGUMENTS. THIS
;		ARGUMENT IS ASSUMED TO HAVE THE CONSTRUCTION <A,...,Z>.
;

	.MACRO	DFO KW,MA,MS,A
	.PSECT	ARGBLK, D,GBL
$$=.
NN=0
	.IRP	X,<A>
NN=NN+1
	.WORD	X
	.ENDM
	.PSECT	OPTBLK,D,GBL
MM=.
K$EY==.-MM
	.WORD	0
	.WORD	0
.=MM
	.RAD50	/KW/
.=MM+4
M$IN==.-MM
M$AX==.-MM+1
	.BYTE	MA,NN
A$RG==.-MM
	.WORD	$$+MS
S$UB==.-MM
	.WORD	KW
L$NG==.-MM
	.PSECT	OPCD$I,RO,I,GBL
	.ENDM

;
; LOCAL DATA
;
;
; ADDRESS BOUND
;
	IMPURE			; READ/WRITE D-SPACE

$ADBND::.BLKW	1		;

; MEMORY ALLOCATION FLAGS WORD
;

$MEMFL::.BLKW	1		;


;
; MAXIMUM LUN ASSIGNMENT
;

$MXASG::.BLKW	1		;


;
; TASK FILE SWITCHES
;

$TKSW::	.BLKW	1		;

	.PSECT	OPTBLK ,D,GBL

$KWRD::				; REF LABEL

;
; PARAMETER DATA
;

	.PSECT	PARM,D

$NUMP::	.BLKW	1		; NUMBER OF PARAMETERS
IOBSCT:	.RAD50	/$$IOB1/	;MAX LENGTH SECTION NAME
OBFSCT:	.RAD50	/$$OBF1/	; FORTRAN OTS FORMATTING BUFFER SECTION

;
; PARAMETER STORAGE
;

$CURCL::.BLKW	1		; REAL ADDRESS OF CURRENT CLUSTER
$CURCV::.BLKW	1		; VIRTUAL ADDRESS OF CURRENT CLUSTER
$CLNME::.BLKW	1		; TEMP STORAGE FOR A CLUSTER LIBRARY NAME
SCTNAM:	.BLKW	2		; RADIX 50 SECTION NAME
SEGFND:	.BLKW	0		; SEGMENT FOUND FLAG
$PARM::				;

	.IF	NDF	R$$11M

	.BLKW	65.

	.IFF

	.BLKW	C.SIZE+6/2

	.ENDC

OPMDS:	.WORD	OPMSE-OPMSG	;OPTION SOLICITATION MESSAGE DESCRIPTOR
	.WORD	OPMSG		;
	.ENABLE LC
	.NLIST BEX
OPMSG:	.ASCII	<15><12>/Enter Options:/
	.DSABLE LC
	.ASCII	<15><12>/TKB>/	;
OPMSE:				; REF LABEL
	.EVEN

;
; APR bitmap for the 'RESAPR' and 'RSDAPR' options
;
	PURE.D

APR:
	.BYTE	001
	.BYTE	002
	.BYTE	004
	.BYTE	010
	.BYTE	020
	.BYTE	040
	.BYTE	100
	.BYTE	200

;

;+
; **-$P2OPT-PHASE 2 OPTION PROCESSING
;
; THIS ROUTINE IS CALLED AT THE END OF PHASE 1 TO READ AND PROCESS
; OPTION INPUT. DEFAULTS ARE ESTABLISHED AND THEN OPTIONS ARE
; PROCESSED.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	DEFAULTS ARE ESTABLISHED AND OPTIONS ARE PROCESSED.
;-
	PURE.I			; READ-ONLY I-SPACE

$P2OPT::SAVRG			;SAVE NONVOLITILE REGISTERS
	CALL	$STOPT		; INITIALIZE OPTIONS
	MOV	#CS$VAS*400!CS$TYP!CS$GBL!CS$REL,$VAROC ; DEFAULT ATTRIBUTES
				; FOR A VIRTUAL ARRAY ARE 'RW,D,GBL,REL,CON'
	BIT	#EN$DR,$SWTCH	; ACCEPT OPTIONS?
	BNE	80$		; IF NE, NO
;
; NOTE:
;	THE COMMAND INPUT FILE MAY BE KEPT OPEN WHILE READING OPTIONS BECAUSE
;	THE ONLY OTHER FILES THAT WILL BE ACCESSED USING THE GCML$ ROUTINES ARE
;	SIMPLY "DOWN" MORE LEVELS (WHICH IS HANDLED BY THE GCML$ ROUTINES).
;
	MOV	$CMIPT, R0		; POINTER TO FDB OF COMMAND INPUT FILE
	BICB	#GE.CLO, G.MODE(R0)	; CAUSES THE FILE TO BE KEPT OPEN

	MOV	#OPMDS,$CMFLG	; SET ADDRESS OF PROMPT DESCRIPTOR
50$:				;
	CALL	$GTCML		; READ A COMMAND LINE
	BCS	70$		; IF C/S LOGICAL EOF
	CLR	$CMFLG		; REVERT TO DEFAULT PROMPT
	MOVB	#'!,R2		; SET KEYWORD STATUS
	MOV	#$LNBUF,R0	; SET BUFFER ADDRESS
60$:				;
	CALL	$P2PRS		; PARSE KEYWORD INPUT
	BCS	50$		; IF C/S SYNTAX ERROR OR END OF LINE
	MOV	R4,-(SP)	; SAVE OPTION BLOCK ADDRESS
	CALL	@S$UB(R4)	; CALL OPTION PROCESSOR
	MOV	(SP)+,R4	; RESTORE OPTION BLOCK ADDRESS
	BR	60$		; GO AGAIN
;
; NOTE:
;	SINCE ANOTHER BUILD MAY FOLLOW, THE INDICATOR MUST BE SET AND THE FILE
;	CLOSED EXPLICITLY.  THE FILE CANNOT BE KEPT OPEN WHILE READING THE
;	COMMAND LINE(S) SINCE AN ODL MIGHT BE SPECIFIED AND THEY ARE ALSO
;	ACCESSED USING THE GCML$ ROUTINES.
;
70$:	MOV	$CMIPT, R0		; POINTER TO FDB OF COMMAND INPUT FILE
	BISB	#GE.CLO, G.MODE(R0)	; SET TO ORIGINAL STATE
	CCML$				; CLOSE THE FILE
80$:
	MOV	$NUMWN,R0	; GET NUMBER OF TASK ADDRESS WINDOWS
	ADD	$MXWND,R0	; ADD WINDOWS FOR RESIDENT LIBRARIES
	INC	R0		; DON'T FORGET WINDOW FOR ROOT
	CMP	R0,#8.		; TOO MANY FOR M?
	BLOS	85$		; IF LOS, NO
	MOV	#4,$SYSTM	; MAKE THIS AN M+ TASK BUILD
85$:	CALLR	$P2POP		; PERFORM POST-OPTION PROCESSING



;
; CONVERT SYMBOL WITH OFFSET VALUE
;

SYM:	CALL	$RR		;GET SYMBOL
	DEC	R0		;BACK UP TO TERMINATOR
	CALL	$OT		;GET OFFSET
	RETURN			;

;
; ABORT TASK BUILD
;

	DFO	ABORT,1,T,$DC

ABORT:				;
	MOV	#<S$V2*400!E$R83>,R3 ; GET USER ABORT MESSAGE
	JMP	$P2OPE		; RESTART TKB

;
; ABSOLUTE PATCH
;

	DFO	ABSPAT,3,T,^/$RR,$OT,$OT,$OT,$OT,$OT,$OT,$OT,$OT,$OT/
	DFO	DSPPAT,3,T,^/$RR,$OT,$OT,$OT,$OT,$OT,$OT,$OT,$OT,$OT/

ABSPAT:
	CLR	R4		; SET TYPE TO I-SPACE ABS PATCH
	BR	ABSPT1		;
DSPPAT:
	MOV	#1,R4		; SET TYPE TO D-SPACE ABS PATCH
ABSPT1:	SAVVR			; SAVE VOLATILE REGISTERS
	MOV	R3,R1		;CALCULATE SIZE OF BLOCK NEEDED
	ASL	R1		;CONVERT TO BYTES
	ADD	#6+4,R1		;ALLOW FOR EXTRA STORAGE
	CALL	$ALBLK		;ALLOCATE STORAGE
	DEC	R3		;DECREMENT WORD COUNT
	JMP	GBLPT1		;

;
; ACTIVE FILES
;

	DFO	ACTFIL,1,F,$DC

ACTFIL:				;
	MOV	(R5),$ACTFL	;SET NUMBER OF ACTIVE FILES
	RETURN			;


;
; DEVICE ASSIGNMENT
;

	DFO	ASG,2,T,^/$DV,$DC,$DC,$DC,$DC,$DC,$DC,$DC,$DC/

ASG:	SAVVR			;SAVE VOLITILE REGISTERS
	MOV	R5,R0		;COPY PARAMETER LIST ADDRESS
	CMP	(R0)+,(R0)+	;POINT TO FIRST LUN NUMBER
	DEC	R3		;CALCULATE NUMBER OF LUNS
	MOV	R3,R1		;SET LOOP COUNT
10$:	TST	(R0)		;ZERO LUN NUMBER?
	BEQ	30$		;IF EQ YES
	CMP	(R0), #250.	; LEGAL UNIT?
	BHI	30$		;IF HI NO
	CMP	(R0)+,$MXASG	; NEW MAX LUN?
	BLOS	15$		; IF LOS NO
	MOV	-2(R0),$MXASG	; SET NEW MAX
15$:				;
	SOB	R1,10$		;REPEAT
	MOV	R3,R1		;COPY NUMBER OF LUNS
	ASL	R1		;CONVERT TO BYTES
	ADD	#6,R1		;ALLOW FOR LINK AND DEVICE INFO
	CALL	$ALBLK		;ALLOCATE STORAGE
	MOV	R0,@$LUNHD+2	;LINK NEW TO OLD LAST
	MOV	R0,$LUNHD+2	;SET NEW LAST
	TST	(R0)+		;POINT TO DEVICE NAME
	MOV	(R5)+,(R0)+	;INSERT DEVICE NAME
	MOV	(R5)+,R1	;GET PHYSICAL UNIT
	BISB	R1,(R0)+	; INSERT PHYSICAL UNIT NUMBER
	MOVB	R3,(R0)+	;INSERT NUMBER OF LUN ASSIGNMENTS
20$:	MOV	(R5)+,(R0)+	;INSERT LUN NUMBERS
	SOB	R3,20$		;REPEAT
	RETURN			;
30$:	MOV	(PC)+,R3	;ILLEGAL LUN NUMBER
	.BYTE	E$R48,S$V1	;DIAGNOSTIC
	JMP	$P2OPE

	.IF	NDF	R$$11M

;
; BASE/TOP ADDRESS
;

	DFO	BASE,1,F,$DC
	DFO	TOP,1,F,$DC

TOP:	NEG	R3		;SET TOP FLAG
BASE:	BIT	#3,(R5)		;4K BOUNDRY?
	BNE	20$		;IF NE NO
	CMP	(R5),#28.	;LEGAL 4K BOUNDRY?
	BHI	20$		;IF HI NO
	TST	R3		;TOP OR BASE?
	BPL	10$		;IF PL BASE
	NEG	(R5)		;MAKE NEGATIVE FOR TOP
10$:	MOV	(R5),$OFFST	;SET OFFSET BIAS
	RETURN			;
20$:	MOV	(PC)+,R3	;ILLEGAL BASE/TOP VALUE
	.BYTE	E$R51,S$V1	;DIAGNOSTIC
	JMP	$P2OPE

	.ENDC


;
; NAME OF COMPLETION ROUTINE
;

	DFO	CMPRT,1,F,$RR

	.DSABL	LSB


CMPRT:
	SAVVR			; SAVE VOLITILE REGISTERS
	MOV	#4,$SYSTM	; CHANGE SYSTEM ID TO M+
	MOV	(R5)+,$CMPRT	; GET NAME OF COMPLETION ROUTINE
	MOV	(R5)+,$CMPRT+2	;
	MOV	#SY$GBL,$CMPRT+S$YFLG-S$YM ; SET AS GLOBAL
	MOV	#$CMPRT,R5	; POINT TO SYMBOL
	CALL	INSRT		; INSERT SYMBOL INTO SYMBOL TABLE
	MOV	$RTSEG,R1	; GET ADDRESS OF ROOT SEGMENT
	CALLR	$UNLPG		; UNLOCK PAGE

	.DSABLE	LSB

;
; SET MINIMUM DISK ALLOCATION FOR TASK FILE
;

	DFO	CORSIZ	1,F,$DC

CORSIZ:				;
	CMP	(R5),#128.	; REASONABLE ALLOCATION
	BHI	10$		; IF HI NO
	ASL	(R5)		; CONVERT K TO DISK BLOCKS
	ASL	(R5)		;
	MOV	(R5),$FSIZI	; SET MINIMUM DISK ALLOCATION
	RETURN			;
10$:				;
	MOV	#<S$V1*400!E$R84>,R3 ; DISK IMAGE ALLOCATION TOO LARGE
	JMP	$P2OPE		;

;
; ESTABLISH TASK EXTEND SIZE
;

	DFO	EXTTSK	1,F,$DC

EXTTSK:				;++041
	BIT	#MP$SY,$SWTCH	;++041 TASK MAPPED?
	BEQ	10$		;++041 IF EQ NO IGNORE KEYWORD
	MOV	#EX$TSK,$MEMFL	;++041 SET EXTEND FLAG
	CLR	$PARSZ		;++041 SET PARTITION SIZE TO ZERO
	CLR	$HGHAD		;++041 SET HIGH ADDRESS BOUND TO ZERO
	CLR	$HGHAD+2	; SET D-SPACE HIGH ADDRESS BOUND TO ZERO
	MOV	#1777,$LBEXT	;++041 FORCE EXTEND ERROR IF INVALID SIZE
	ADD	#37,(R5)	;++041 ROUND INCREMENT TO 32 W BOUNDRY
	BCS	10$		;++041 IF C/S ERROR
	BIC	#37,(R5)	;++041 ...
	ROL	(R5)		;++041 CONVERT TO NUMBER OF 32W BLOCKS
	ROL	(R5)		;++041 ...
	ROL	(R5)		;++041 ...
	ROLB	(R5)		;++041 ...
	SWAB	(R5)		;++041 ...
	MOV	(R5),$LBEXT	;++041 SAVE EXTEND SIZE
10$:				;++041
	RETURN			;++041



;
; GLOBAL SYMBOL PATCH
;

	DFO	GBLPAT,3,T,^/$RR,SYM,$OT,$OT,$OT,$OT,$OT,$OT,$OT,$OT/

GBLPAT:	SAVVR			;SAVE VOLITILE REGISTERS
	MOV	R3,R1		;CALCULATE SIZE OF BLOCK NEEDED
	ASL	R1		;CONVERT TO BYTES
	ADD	#6+4+4,R1	;ALLOW FOR EXTRA STORAGE
	CALL	$ALBLK		;ALLOCATE STORAGE
	MOV	#2,R4		;SET TYPE TO GLOBAL
	INC	R3		;INCREMENT WORD COUNT
GBLPT1:	MOV	R0,@$PATHD+2	;LINK NEW LAST TO OLD LAST
	MOV	R0,$PATHD+2	;SET NEW LAST
	TST	(R0)+		;POINT TO NUMBER OF PARAMETERS
	MOV	$NUMP,(R0)	; INSERT NUMBER OF PARAMETERS
	SUB	#2,(R0)+	;ADJUST TO NUM PATCH VALUES
	MOV	(R5)+,(R0)+	;INSERT SEGMENT NAME
	MOV	(R5)+,(R0)+	;
	MOV	R4,(R0)+	;INSERT TYPE OF ENTRY
10$:	MOV	(R5)+,(R0)+	;MOVE PARAMETERS
	SOB	R3,10$		;REPEAT
	RETURN			;

;
; EXTEND CONTROL SECTION LENGTH
;

	DFO	EXTSCT,2,T,^/$RR,$OT/
	DFO	FMTBUF,1,F,$DC
	DFO	MAXBUF,1,F,$DC


FMTBUF:				;
	SAVVR			; SAVE THE VOLATILE REGISTERS
	MOV	#OBFSCT+4,R1	; POINT TO SECTION NAME PLUS OFFSET
	BR	MXBUF1		;

MAXBUF:				;
	SAVVR			; SAVE THE VOLATILE REGISTERS
	MOV	#IOBSCT+4,R1	; POINT TO NAME OF SECTION PLUS OFFSET
MXBUF1:				;
	MOV	-(R1),-(R5)	; MOVE NAME TO SECTION STORAGE
	MOV	-(R1),-(R5)	;
	BR	EXTSC1		; EXTEND SECTION LENGTH
EXTSCT:	SAVVR			;SAVE VOLITILE REGISTERS
EXTSC1:				;
	MOV	R5,R1		;GET ADDRESS OF SECTION NAME
	SUB	#S$YM,R1	;CALCULATE PROPER OFFSET
	MOV	#$SCTHD,R0	;GET ADDRESS OF EXTEND LISTHEAD
	CALL	$SRCHR		; SEARCH FOR SECTION NAME
	BCC	10$		;IF CC ALREADY THERE-CHANGE DEFINITION
	MOV	#C$SBSE+2,R1	;GET SIZE OF BLOCK NEEDED
	CALL	$ALBLK		;ALLOCATE STORAGE
	MOV	(R5)+,S$YM(R0)	;INSERT SECTION NAME
	MOV	(R5)+,S$YM+2(R0);
	MOV	(R5),C$SBSE(R0)	;SET SECTION EXTENSION LENGTH
	MOV	R0,R1		;COPY ADDRESS OF SECTION ENTRY
	MOV	#$SCTHD,R0	;GET ADDRESS OF EXTEND LISTHEAD
	CALL	$ISYMR		; INSERT EXTENSION
	BR	20$		;
10$:	MOV	4(R5),C$SBSE(R0);REDEFINE EXTENSION LENGTH
20$:	RETURN			;

;
; GLOBAL SYMBOL DEFINITION
;

	DFO	GBLDEF,2,T,^/$RR,$OT/

GBLDEF:	SAVVR			;SAVE VOLITILE REGISTERS
	MOV	#SY$DEF,-(SP)	; SET SYMBOL FLAGS
GBLDF1:				;
	MOVB	(SP),R2		; GET FLAGS
	CALL	INSRT		; INSERT SYMBOL IN SYMBOL TABLES
	BCS	20$		; IF C/S NOT PREVIOUSLY DEFINED
				; AND ADD TO SYMBOL TABLE
10$:				;
	TST	(SP)		; PROCESSING REFERENCE?
	BNE	12$		; IF NE YES
	BITB	#SY$WK,S$YFLG(R0)  ; WEAK QUALIFIER SET?
	BEQ	20$		; IF EQ NO
	INC	$MSYMC		; INCREMENT MASTER UNDEFINED COUNT
	INC	@SCTNAM		; INCREMENT SEGMENT UNDEFINED COUNT
	BICB	#SY$WK,S$YFLG(R0) ; CLEAR WEAK QUALIFIER
	BR	17$		;
12$:				;
	BITB	#SY$DEF,S$YFLG(R0) ; FIND DEFINITION?
	BNE	15$		; IF NE YES, CHANGE DEFINITION
	DEC	$MSYMC		; DECREMENT MASTER UNDEFINED COUNT
	DEC	@SCTNAM		; DECREMENT SEGMENT UNDEFINED COUNT
	BISB	(SP),S$YFLG(R0)	; SET DEFINITION FLAG
15$:				;
	MOV	4(R5),S$YVAL(R0) ; REDEFINE SYMBOL
17$:				;
	CALL	$WRMPG		; WRITE-MARK PAGE
20$:				;
	TST	(SP)+		; CLEAN THE STACK
	MOV	$RTSEG,R1	; GET VIRTUAL ADDRESS OF ROOT
	CALLR	$UNLPG		; UNLOCK ROOT SEGMENT

;
; GLOBAL SYMBOL REFERENCE
;

	DFO	GBLREF,1,T,^/$RR/

GBLREF:				;
	SAVVR			; SAVE THE VOLATILE REGISTERS
	CLR	-(SP)		; CLEAR FLAGS WORD ON STACK
	BR	GBLDF1		;


;
; SPECIFY TASK IDENTIFICATION
;

	DFO	IDENT,1,F,$RR

IDENT:
	MOV	(R5)+,$IDENT	; SET TASK IDENTIFICATION
	MOV	(R5),$IDENT+2
	RETURN


;
; ROUND SPECIFIED SEGMENT UP TO NEXT APR BOUNDARY
;

	DFO	RNDSEG,1,F,$RR

RNDSEG:
	BIT	#LI$BRY,$SWOVR		; WE BUILDING A LIBRARY?
	BNE	10$			; IF NE, YES...PROCESS THE OPTION
	MOV	(PC)+,R3		; SET THE DIAGNOSTIC ERROR MESSAGE
	.BYTE	E$R109,S$V0		; 'IGNORING OPTION', DIAGNOSTIC
	JMP	$P2OPE			; PRINT THE ERROR
10$:
	MOV	SCTNAM,-(SP)		; SAVE ORIGINAL SECTION NAME CONTENTS
	MOV	SCTNAM+2,-(SP)
	MOV	(R5)+,SCTNAM		; SAVE SPECIFIED SECTION NAME
	MOV	(R5),SCTNAM+2
	CLR	SEGFND			; ASSUME WE CAN'T FIND THE SEGMENT
	MOV	#SRCSEG,R0		; SET UP PHASE CONTROL ROUTINE CALL
	CALL	$PCTRL			; CALL ROUTINE TO PROCESS SEGMENTS
	MOV	(SP)+,SCTNAM+2		; RESTORE ORIGINAL SECTION NAME CONTENTS
	MOV	(SP)+,SCTNAM
	TST	SEGFND			; DID WE FIND A SEGMENT TO ROUND?
	BNE	20$			; IF NE, YES...
	MOV	(PC)+,R3
	.BYTE	E$R108,S$V0		; 'SEGMENT NOT FOUND', DIAGNOSTIC
	JMP	$P2OPE
20$:
	RETURN
;
SRCSEG:
	MOV	R0,-(SP)		; SAVE ADDRESS OF BUFFER
	MOV	$CRSEG,R0		; GET REAL ADDRESS OF CURRENT SEGMENT
	CMP	S$GNME(R0),SCTNAM	; COMPARE 1ST HALF OF SEGMENT NAME
	BNE	10$			; IF NE, NO MATCH...QUIT NOW
	CMP	S$GNME+2(R0),SCTNAM+2	; COMPARE 2ND HALF OF SEGMENT NAME
	BNE	10$			; NO MATCH EITHER...
	MOV	$CRVSG,R1		; GET SEGMENT'S VIRTUAL ADDRESS
	CALL	$WRMPG			; AND WRITE-MARK ITS PAGE...
	BIS	#SG$RND,S$GSTS(R0)	; SET THE 'ROUND-UP' BIT
	INC	SEGFND			; SET SEGMENT FOUND FLAG...

10$:
	MOV	(SP)+,R0		; RESTORE R0...
	RETURN				; AND BACK FOR ANOTHER SEGMENT



;
; RESIDENT LIBRARY AND COMMON BLOCKS
;

	DFO	COMMON,2,T,^/$LBR,$ACC,$DC/
	DFO	LIBR,2,T,^/$LBR,$ACC,$DCC,$OT/
	DFO	RESCOM,1,T,^/$RESLB/
	DFO	RESLIB,1,T,^/$RESLB/
	DFO	SUPLIB,2,T,^/$SUPLB,$SPV,$DC/
	DFO	RESSUP,1,T,^/$RESUP/
	DFO	CLSTR,1,T,^/$CLS/


	.IF	DF,R$RSTS	;++RSTS V8.0					   
	DFO	HISEG,1,F,^/$LBR/	;++RSTS V8.0				   
	PURE.I			;++RSTS V8.0	PUT RSTS CODE IN A 'LCL' PSECT	   
HISEG:				;++RSTS V8.0					   
	TST	$TKRTS		;++RSTS V8.0	HISEG ALREADY THERE?		   
	BNE	30$		;++RSTS V8.0	YES SO ERROR			   
	TST	$TKRTS+2	;++RSTS V8.0	REALLY ON THERE?		   
	BNE	30$		;++RSTS V8.0					   
	MOV	#-1,$TKRTS+4	;++RSTS V9.7	PRESET HISEG ERROR INDICATOR	   
	JMP	LIBR		;++RSTS V9.7	GO PROCESS IT			   
30$:	MOV	#<S$V1*400!E$R111>,R3	;++RSTS V8.0	SET ERROR CODE AND SEVERITY
	CALLR	$P2OPE		;++RSTS V8.0	AND REPORT IT			   
	.PSECT	OPCD$I,RO,I,GBL	;++RSTS V8.0	PUT THE RSX CODE WHERE IT BELONGS  
	.ENDC			;++RSTS V8.0					   
SUPLIB:
RESSUP:
	MOV	#4,$SYSTM	; CHANGE SYSTEM ID TO M+
LIBR:				;
RESLIB:				;
	MOV	R0,-(SP)		; SAVE R0
	MOV	$CMIPT, R0		; POINTER TO FDB OF COMMAND INPUT FILE
	BISB	#GE.CLO, G.MODE(R0)	; SET TO ORIGINAL STATE
	CCML$				; CLOSE THE FILE
	MOV	(SP)+,R0		; RESTORE R0 
	CALLR	$LIBR		; PROCESS RESIDENT LIBRARY REQUEST
COMMON:				;
RESCOM:				;
	MOV	R0,-(SP)		; SAVE R0
	MOV	$CMIPT, R0		; POINTER TO FDB OF COMMAND INPUT FILE
	BISB	#GE.CLO, G.MODE(R0)	; SET TO ORIGINAL STATE
	CCML$				; CLOSE THE FILE
	MOV	(SP)+,R0		; RESTORE R0 
	CALLR	$COMMN		; PROCESS RESIDENT COMMON REQUEST
CLSTR:
	MOV	R0,-(SP)		; SAVE R0
	MOV	$CMIPT, R0		; POINTER TO FDB OF COMMAND INPUT FILE
	BISB	#GE.CLO, G.MODE(R0)	; SET TO ORIGINAL STATE
	CCML$				; CLOSE THE FILE
	MOV	(SP)+,R0		; RESTORE R0 
	BIS	#CL$STR,$SWOVR	; SET LINKING TO CLUSTER LIBRARY FLAG
	CALLR	$CLSLB		; PROCESS CLUSTER LIBRARY REQUEST

;
; ODT SST VECTOR
;

	DFO	ODTV,2,F,^/$RR,$DC/

ODTV:	CMP	(R5)+,(R5)+	;POINT TO VECTOR SIZE
	TST	(R5)		;ANY SIZE SPECIFIED?
	BEQ	10$		;IF EQ NO
	CMP	(R5),#32.	;LEGAL SIZE?
	BHIS	10$		;IF HIS NO
	.IIF NDF R$$11M, MOVB	(R5),$ODTSZ ; SET VECTOR SIZE
	.IIF DF	R$$11M,	MOV	(R5),$ODTSZ ; SET VECTOR SIZE
	MOV	-(R5),$ODTV+2	;SET GLOBAL SYMBOL
	MOV	-(R5),$ODTV	;
	RETURN			;
10$:	JMP	TSKV1		;ILLEGAL VECTOR SIZE

;
; PARTITION NAME
;

	.IIF NDF R$$11M,	DFO	PAR,1,F,$RR
	.IIF DF R$$11M		DFO	PAR,1,F,^/$RR,$OT,$OT/

PAR:				;

	.IF	NDF	R$$11M

	MOV	(R5)+,$PNAME	; INSERT PARTITION NAME
	MOV	(R5)+,$PNAME+2 	;
	RETURN			;

	.IFF

	SAVVR			; SAVE VOLATILE REGISTERS
	MOV	R5,R0		; COPY OPTION BLOCK POINTER
	CMP	R3,#2		; CHECK NO. OF ARGUMENTS
	BEQ	30$		; ERROR, SIZE NOT SPECIFIED
	BGT	10$		; HAVE BOTH SIZE AND LENGTH
	CALL	$GTPPR		; GET PARTITION PARAMETERS
	BCS	40$		; IF C/S PARTITION NON-EXISTENT
	BR	20$		; CHECK MAPPING
10$:				;
	CMP	(R0)+,(R0)+	; POINT TO BASE ADDRESS
	MOV	(R0)+,R1	; GET BASE ADDRESS
	BIT	#77,R1		; ON 32W BOUND?
	BNE	30$		; IF NE NO
	MOV	(R0),R2		; GET LENGTH
	BIT	#77,R2		; SIZE MUST BE MULTIPLE OF 32 W
	BNE	30$		; ELSE ERROR
	SWAB	R2		; CONVERT LENGTH TO 32W BLOCKS
	RORB	R2		;
	ROL	R2		;
	ROL	R2		;
	ROL	R2		;
	MOV	R5,R0		; POINT TO PARTITION NAME
20$:				;
	BIT	#MP$SY,$SWTCH	;++041 MAPPED SYSTEM?
	BNE	21$		;++041 IF NE YES
	TST	R2		;++041 PARTITION HAVE LENGTH?
	BEQ	40$		;++041 IF EQ NO ERROR
21$:				;++041
	MOV	R2,$PARSZ	; SET PARTITION SIZE
	BIT	$ADBND,R1	; ADDRESS BOUND OK?
	BNE	40$		; IF NE NO
	TST	R1		; CHECK LOW ADDRESS BOUND
	BEQ	22$		; IF EQ OK
	BIT	#MP$SY,$SWTCH	; TARGET SYSTEM MAPPED?
	BEQ	22$		; IF EQ NO OK
	BIT	#SW$NH,$TKSW	; TASK HAVE HEADER?
	BEQ	40$		; IF EQ YES ERROR
22$:				;
	CALL	$VTKMP		; VERIFY MAPPING
	BCS	40$		; IF C/S ERROR
	CMP	R2,$ADLIM	; HIGH ADDRESS LIMIT OK?
	BLOS	25$		; IF LOS YES
	BIT	#SW$NH,$TKSW	; BUILDING LIBRARY ?
	BEQ	40$		; IF EQ NO
25$:				;
	MOV	(R0)+,$PNAME	; SET PARTITION NAME
	MOV	(R0)+,$PNAME+2	;
	MOV	R1,$OFFST	; SET OFFSET
	MOV	R2,$HGHAD	; HIGH ADDRESS BOUND
	MOV	R2,$HGHAD+2	; SET D-SPACE HIGH ADDRESS BOUND
	MOV	#PA$RT,$MEMFL	;++041 SET EXPLICIT PARTITION  FLAG
	RETURN			;
30$:				;
	MOV	#<S$V1*400!E$R64>,R3 ; FETCH ERROR/SEVERITY
	BR	50$		;
40$:				;
	MOV	#<S$V1*400!E$R82>,R3 ; INVALID PARTITION SPECIFIED
50$:				;
	JMP	$P2OPE		;

	.ENDC

	.IF	NDF	R$$11M

;
; POOL USAGE
;

	DFO	POOL,1,F,$DC

POOL:	CMP	(R5),#512.	;REASONABLE NUMBER?
	BHI	10$		;IF HI NO
	TST	(R5)		;ZERO IS BAD ALSO
	BEQ	10$		;IF EQ NO NO
	MOV	(R5),$POOL	;SET POOL USAGE
	RETURN			;
10$:	MOV	(PC)+,R3	;ILLEGAL POOL USAGE NUMBER
	.BYTE	E$R52,S$V1	;DIAGNOSTIC
	JMP	$P2OPE		;

	.ENDC

;
; DEFAULT PRIORITY
;

	DFO	PRI,1,F,$DC

PRI:	CMP	(R5),#250.	;LEGAL PRIORITY?
	BHI	10$		;IF HI NO
	MOV	(R5),$PRIOR	;SET DEFAULT PRIORITY
	RETURN			;
10$:	MOV	(PC)+,R3	;ILLEGAL PRIORITY
	.BYTE	E$R53,S$V1	;DIAGNOSTIC
	JMP	$P2OPE		;

;
; STACK SIZE ALLOCATION
;

	DFO	STACK,1,F,$DC

STACK:	ASL	(R5)		;CONVERT SIZE TO BYTES
	MOV	(R5),$STACK	;SET STACK SIZE
	RETURN			;


;

;
; RESERVE APRS FOR CONVENTIONAL AND USER I/D TASKS
;

	DFO	RESAPR,1,T,^/$OT,$OT,$OT,$OT,$OT,$OT,$OT,$OT/
	DFO	RSDAPR,1,T,^/$OT,$OT,$OT,$OT,$OT,$OT,$OT,$OT/

RESAPR:				; RESERVE CONVENTIONAL TASK APRS AND
				; USER I-SPACE APRS.
	SAVVR			; SAVE ALL THE REGISTERS
	MOV	$NUMP,R0	; GET THE NUMBER OF PARAMETERS
	CLR	R2		; CLEAR A TEMPORARY REGISTER
	CLR	R3		; ZERO ANOTHER ONE
10$:
	MOV	(R5)+,R1	; GET THE APR NUMBER TO RESERVE
	BIC	#<^C7>,R1	; FORCE THE VALUE RANGE 0-7
	BISB	APR(R1),R2	; AND RECORD THE REQUEST
	CMP	R1,R3		; DID WE FIND A HIGHER APR RESERVATION
	BLOS	20$		; IF LOWER OR SAME, NO...
	MOV	R1,R3		; IF HIGHER, YES...SAVE IT FOR LATER
20$:
	SOB	R0,10$		; AND PROCESS 'TILL DONE...
	MOVB	R2,$APRMP	; SET THE I-SPACE RESERVATION REQUEST
	MOVB	R3,$RIAPR	; SAVE THIS HIGHEST APR REQUEST
	RETURN			; AND RETURN
;
;
RSDAPR:				; RESERVE USER D-SPACE APRS ONLY.
	SAVVR			; SAVE ALL THE REGISTERS
	MOV	$NUMP,R0	; GET THE NUMBER OF PARAMETERS
	CLR	R2		; CLEAR A TEMPORARY REGISTER
	CLR	R3		; ZERO ANOTHER ONE
10$:
	MOV	(R5)+,R1	; GET THE APR NUMBER TO RESERVE
	BIC	#<^C7>,R1	; FORCE THE VALUE RANGE 0-7
	BISB	APR(R1),R2	; AND RECORD THE REQUEST
	CMP	R1,R3		; DID WE FIND A HIGHER APR RESERVATION
	BLOS	20$		; IF LOWER OR SAME, NO...
	MOV	R1,R3		; IF HIGHER, YES...SAVE IT FOR LATER
20$:
	SOB	R0,10$		; AND PROCESS 'TILL DONE...
	MOVB	R2,$APRDM	; SET THE D-SPACE RESERVATION REQUEST
	MOVB	R3,$RDAPR	; SAVE THE HIGHEST D-SPACE APR RESERVATION
	RETURN			; AND RETURN
;
;
; R-O PARTITION NAME
;

	.IF DF	R$$11M

	DFO	ROPAR,1,F,$RR

ROPAR:
	MOV	(R5)+,$ROPAR		; INSERT R-O PARTITION NAME
	MOV	(R5)+,$ROPAR+2		;
	RETURN

	.ENDC

;
; TASK NAME
;

	DFO	TASK,1,F,$RR

TASK:	MOV	(R5)+,$TNAME	;SET TASK NAME
	MOV	(R5),$TNAME+2	;
	RETURN			;

;
; TASK SST VECTOR
;

	DFO	TSKV,2,F,^/$RR,$DC/

TSKV:	CMP	(R5)+,(R5)+	;POINT TO VECTOR SIZE
	TST	(R5)		;ANY SIZE SPECIFIED?
	BEQ	TSKV1		;IF EQ NO
	CMP	(R5),#32.	;LEGAL SIZE?
	BHIS	TSKV1		;IF HIS NO
	.IIF  NDF  R$$11M, MOVB	(R5),$TSKSZ ; SET VECTOR SIZE
	.IIF   DF R$$11M, MOV	(R5),$TSKSZ ; SET VECTOR SIZE
	MOV	-(R5),$TSKV+2	;SET GLOBAL SYMBOL
	MOV	-(R5),$TSKV	;
	RETURN			;
TSKV1:	MOV	(PC)+,R3	;ILLEGAL SST VECTOR SIZE
	.BYTE	E$R54,S$V1	;DIAGNOSTIC
	JMP	$P2OPE		;

;
; TASK UIC
;

	DFO	UIC,1,F,UCVT

UIC:	MOV	(R5),$TKUIC	;SET TASK UIC
	RETURN			;

;
; UIC CONVERSION ROUTINE
;

UCVT:	CMPB	#'[,(R0)+	;LEFT BRACKET?
	BNE	10$		;IF NE NO-SYNTAX ERROR
	CALL	20$		;CONVERT PROJECT NUMBER
	CMPB	#',,R2		;TERMINAL COMMA?
	BNE	10$		;IF NE NO-SYNTAX ERROR
	TSTB	-(R5)		;PROJECT TOO BIG?
	BNE	10$		;IF NE YES-SYNTAX ERROR
	MOVB	-(R5),-(SP)	;SAVE PROJECT NUMBER
	CALL	20$		;CONVERT PROGRAMMER NUMBER
	MOV	(SP)+,R1	;RETRIEVE PROJECT NUMBER
	CMPB	#'],R2		;RIGHT BRACKET?
	BNE	10$		;IF NE NO-SYNTAX ERROR
	TSTB	-(R5)		;PROGRAMMER TOO BIG?
	BNE	10$		;IF NE YES-SYNTAX ERROR
	MOVB	R1,(R5)+	;INSERT PROJECT NUMBER
	CALL	$SETNB		;BYPASS LEADING BLANKS AND HT'S
	MOVB	(R0)+,R2	;GET TERMINAL BYTE
	RETURN			;
10$:	TST	(SP)+		;REMOVE RETURN FROM STACK
	MOV	#$LNDES,R2	;GET ADDRESS OF LINE DESCRIPTOR
	MOV	(PC)+,R1	;SYNTAX ERROR
	.BYTE	E$R30,S$V1	;DIAGNOSTIC
	CALL	$ERMSG		;OUTPUT ERROR MESSAGE
	SEC			;
	RETURN			; GO AGAIN
20$:	MOV	R0,-(SP)	;SAVE NEXT BYTE ADDRESS FOR POSSIBLE RESCAN
	CALL	$OT		;CONVERT OCTAL
	CMPB	#'.,R2		;TERMINAL PERIOD?
	BNE	30$		;IF NE NO
	MOV	(SP),R0		;RETRIEVE NEXT BYTE ADDRESS
	TST	-(R5)		;BACK UP PARAMETER POINTER
	CALL	$DC		;CONVERT DECIMAL
	CALL	$SETNB		;SET NONBLANK
	MOVB	(R0)+,R2	;GET TERMINAL BYTE
30$:	TST	(SP)+		;CLEAN STACK
	RETURN			;

;
; LOGICAL UNIT USAGE
;

	DFO	UNITS,1,F,$DC

	.ENABL	LSB

UNITS:				;
	CMP	(R5),$MXASG	; LESS THAN MAX LUN ASSIGNMENT?
	BLO	10$		;IF LO YES
	CMP	(R5),#250.	;REASONABLE NUMBER OF UNITS?
	BHI	10$		;IF HI NO
	MOV	(R5),$NUNIT	;SET NEW NUMBER OF UNITS
	RETURN			;
10$:	MOV	(PC)+,R3	;ILLEGAL NUMBER OF UNITS
	.BYTE	E$R49,S$V1	;DIAGNOSTIC
20$:				;
	JMP	$P2OPE		;


;
; VIRTUAL ARRAY ATTRIBUTE PROCESSOR
;

	DFO	VARRAY,1,T,^/$RR/

;
; PROCESS OPTION VARRAY - ARGUMENTS CAN ONLY BE 'CON' OR 'OVR'
;

VARRAY:
	CMP	(R5),#^RCON	; IS THE ARGUMENT 'CON'?
	BEQ	SETCON		; IF EQ, YES...SET FLAGS
	CMP	(R5),#^ROVR	; IF NE, IS IT 'OVR'??
	BEQ	SETOVR		; IF EQ, YES...SET FLAGS
	MOV	(PC)+,R3	; IF NE, IT'S AN INVALID KEYWORD...
	.BYTE	E$R29,S$V1	; 'INVALID KEYWORD' - DIAGNOSTIC
	JMP	$P2OPE		; PRINT ERROR AND TRY AGAIN
;
SETOVR:
	MOV	#CS$VAS*400!CS$TYP!CS$GBL!CS$REL!CS$ALO,$VAROC	; SET 'OVR' BIT
	RETURN
;
SETCON:
	MOV	#CS$VAS*400!CS$TYP!CS$GBL!CS$REL,$VAROC		; SET 'CON' BIT
	RETURN

;
; SPECIFY VIRTUAL PROGRAM SECTION
;

	DFO	VSECT,2,T,^\$RR,$OT,$OT,$OT\

VSECT:				;
	CALLR	$VSECT		; PROCESS VIRTUAL SECTION KEYWORD

;
; NUMBER OF TASK WINDOWS
;

	DFO	WNDWS,1,F,$DC

WNDWS:				;
	CMP	(R5),#7.	; > 8. WINDOWS DECLARED?
	BLOS	25$		; IF LOS YES
	CMP	(R5),#W$NDWS-1	; TOO MANY WINDOWS REQUESTED?

	BHI	30$		; IF HI YES
	MOV	#4,$SYSTM	; SET SYSTEM ID TO M+
25$:
	MOV	(R5),$NUMWN	; SET WINDOW COUNT FOR TASK
	RETURN			;
30$:				;
	MOV	#<S$V1*400!E$R85>,R3 ; SET ERROR/SEVERITY
	BR	20$		; REPORT ILLEGAL WINDOW SPECIFICATION

	.DSABL	LSB


;
; GLOBAL SYMBOL EXCLUDE AND INCLUDE/REFERENCE
;

	DFO	GBLXCL,1,T,^/$RR/
	DFO	GBLINC,1,T,^/$RR/

	.ENABL LSB
GBLINC:
	SAVVR			; SAVE THE VOLATILE REGISTERS
	MOV	PC,-(SP)	; SET "INCLUDE" SWITCH
	BR	10$		; AND FALL INTO COMMON CODE

GBLXCL:
	SAVVR			; SAVE THE VOLATILE REGISTERS
	CLR	-(SP)		; SET "EXCLUDE" SWITCH
10$:
	MOV	#10,R1		; SET SIZE OF BLOCK TO ALLOCATE
	CALL	$ALBLK		; ALLOCATE STORAGE
	MOV	(SP)+,6(R0)	; AND INSERT TYPE SWITCH
	MOV	R0,@$XCLHD+2	; LINK NEW LAST TO OLD LAST
	MOV	R0,$XCLHD+2	; SET NEW LAST
	CLR	(R0)+		; CLEAR LINK
	MOV	(R5)+,(R0)+	; SET NAME
	MOV	(R5)+,(R0)	; SET SECOND HALF OF NAME
	RETURN

	.DSABL LSB

;
; COMMON SUBROUTINES
;
;+
; **-$GTRT-CONVERT VIRTUAL ADDRESS OF ROOT SEGMENT TO REAL ADDRESS
;
;	THIS ROUTINE IS CALLED TO CONVERT THE ROOT SEGMENT VIRTUAL ADDRESS
;	TO AN ADDRESS IN REAL MEMORY. THE PAGE BUFFER CONTAINING THE
;	SEGMENT DESCRIPTOR IS WRITE-MARKED.
;
;
; INPUTS:
;
;	$RTSEG = VIRTUAL ADDRESS OF ROOT SEGMENT DESCRIPTOR
;
; OUTPUTS:
;
;	R0 = REAL ADDRESS OF DESCRIPTOR
;	PAGE BUFFER IS WRITE-MARKED
;
; THE CONTENTS OF R1 ARE PRESERVED
;-
	PURE.I			; READ-ONLY I-SPACE

$GTRT::				;
	MOV	R1,-(SP)	; SAVE R1
	MOV	$RTSEG,R1	; GET VIRTUAL ADDRESS OF DESCRIPTOR
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	CALL	$WRMPG		; WRITE MARK PAGE
	MOV	(SP)+,R1	; RESTORE R1
	RETURN			;

;
;
;
;+
; **-INSRT-INSERT SYMBOL INTO SEGMENT SYMBOL TABLE AND MASTER SYMBOL TABLE
;-
;
; INPUTS:
;	R2 - SYMBOL'S FLAG WORD
;	R5 - POINTS TO SYMBOL
;
; OUTPUTS:
;	C=1	NOT PREVIOUSLY DEFINED
;		SYMBOL ENTERED INTO SEGMENT SYMBOL TABLE
;		AND MASTER SYMBOL TABLE
;	C=0	SYMBOL PREVIOUSLY DEFINED
;

INSRT:
	MOV	R2,-(SP)	; SAVE FLAGS
	CALL	$GTRT		; GET REAL ADDRESS OF ROOT SEGMENT IN R0
	MOV	$RTSEG,R1	; GET VIRTUAL ADDRESS OF ROOT
	CALL	$LCKPG		; LOOK ROOT IN MEMORY
	ADD	#S$GUND,R0	; OFFSET TO UNDEFINED COUNT
	MOV	R0,SCTNAM	; SAVE REAL ADDRESS OF COUNT
	MOV	R5,R1		; GET ADDRESS OF SYMBOL
	SUB	#S$YM,R1	; CALCULATE PROPER OFFSET
	ADD	#S$GSTB-S$GUND,R0 ; POINT TO SYMBOL TABLE
	CALL	$SRCH		; SEARCH FOR SYMBOL
	BCC	20$		; IF C/C SYMBOL PREVIOUSLY DEFINED
	TSTB	(SP)		; TEST FALGS
	BNE	5$		; IF NE SYMBOL IS DEFINED
	INC	$MSYMC		; INCREMENT MASTER UNDEFINED COUNT
	INC	@SCTNAM		; INCREMENT SEGMENT UNDEFINED COUNT
5$:
	MOV	#S$YLGH,R1	; GET SIZE OF BLOCK NEEDED
	CALL	$ALVRT		; ALLOCATE VIRTUAL STORAGE
	MOV	(R5)+,S$YM(R0)	; INSERT SYMBOL
	MOV	(R5)+,S$YM+2(R0) ;
	BIS	(SP)+,S$YFLG(R0) ; SET FLAGS
	BISB	#SY$GBL,S$YFLG(R0) ; SET GLOBAL SYMBOL
	MOV	(R5)+,S$YVAL(R0) ; SET VALUE
	MOV	R1,(R5)		; SET VIRTUAL ADDRESS OF SYMBOL
	MOV	$ASCT,S$YCMT(R0) ; SET SECTION ENTRY ADDRESS
	MOV	$RTSEG,R0	; GET VIRTUAL ADDRESS OF ROOT
	MOV	R0,-(R5)	; SAVE VIRTUAL ADDRESS OF ROOT
	ADD	#S$GSTB/2,R0	; POINT TO SYMBOL TABLE LISTHEAD
	CALL	$SRCHI		; SEARCH FOR SYMBOL INSERTION
	CALL	$ISYM		; INSERT SYMBOL IN TABLE
	CMP	$NUMSG,#1	; TASK OVERLAYED?
	BEQ	10$		; IF EQ NO
	SUB	#<2+3>*2,R5	; CONVERT DEFINITION TO DESCRIPTOR FORM
	MOV	R5,R1		; COPY DESCRIPTOR ADDRESS
	MOV	#$SYMHD,R0	; GET ADDRESS OF MASTER TABLE LIST
	CALL	$SRCIV		; SEARCH FOR INSERTION
	CALL	$ISYMV		; INSERT SYMBOL
10$:
	SEC			; SET SYMBOL NOT PREVIOUSLY DEFINED
RETURN
20$:
	TST	(SP)+		; CLEAN STACK
	RETURN
;
;
;
;+
; **-$P2OPE - PARAMETER ROUTINE ERROR EXIT
;
; INPUTS:
;
;	R3:	ERROR/SEVERITY CODE
;
; OUTPUTS:
;
; 	NONE
;
;-
;

$P2OPE::			;
	SAVVR			; SAVE VOLATILE REGISTERS
	MOV	$CMIPT, R0		; POINTER TO FDB OF COMMAND INPUT FILE
	BISB	#GE.CLO, G.MODE(R0)	; SET TO ORIGINAL STATE
	CCML$				; CLOSE THE FILE
	MOV	R3,R1		;SET ERROR/SEVERITY
	MOV	#$LNDES,R2	;GET ADDRESS OF LINE DESCRIPTOR
	CALL	$ERMSG		;OUTPUT ERROR MESSAGE
	RETURN			;


	.IF	DF	R$$11M

;
; SUBROUTINES TO CHECK FOR INTERSECTING PARTITIONS
;
;+
; **-$VTKMP - VERITY TASK AREA DOES NOT INTERSECT LIBRARIES
;
; **-$VLBMP - VERIFY LIBRARY DOES NOT INTERSECT OTHER LIBRARIES
;		OR TASK PARTITION
;
; INPUTS:
;
;	R0:	ADDRESS OF 2-WORD, RADIX 50 PARTITION NAME
;		OR RESIDENT LIBRARY NAME
;	R1:	LOW MEMORY LIMIT
;	R2:	LENGTH IN 32W BLOCKS OR 0
;		IF R2=0 CHECKS ARE RESTRICTED TO SEARCH
;		FOR PARTITION OR LIBRARY HAVING DUPLICATE
;		NAME.
;
; OUTPUTS:
;
;	C-CLEAR: NO MEMORY CONFLICT
;	C-SET:	BOUNDARIES OVERLAP, NAME CONFLICT, HIGH ADDRESS
;		BOUND EXCEEDS 32K-1
;
;	R2:	HIGH ADDRESS BOUND OR 0 FOR NAME CHECK ONLY
;
; R0,R1 ARE UNCHANGED
;
;-
;
;

	.ENABL	LSB

	IMPURE			; READ-WRITE D-SPACE

LCLFLG:	.BLKW	1		; FOR LOCAL FLAGS WORD


	PURE.I			; READ-ONLY I-SPACE

$VTKMP::			;
	SAVRG			; SAVE NON-VOLATILE REGISTERS
	CALL	40$		; COMPUTE HIGH ADDRESS BOUND
	BR	10$		;
$VLBMP::			;
	SAVRG			; SAVE NON-VOLATILE REGISTERS
	CALL	40$		; COMPUTE HIGH ADDRESS BOUND
	MOV	$HGHAD,R5	; GET HIGH ADDRESS BOUND
	BEQ	10$		; IF EQ PARTITION NOT SPECIFIED
	MOV	$OFFST,R4	; GET RELOCATION BASE
	CALL	50$		; CHECK ADDRESS LIMITS
	CMP	(R0),$PNAME	; CHECK FOR NAME MATCH
	BNE	10$		; IF NE NO MATCH
	CMP	2(R0),$PNAME+2	; CHECK SECOND HALF OF NAME
	BEQ	70$		; IF EQ ERROR
10$:				;
	MOV	#<$LBRHD-L$DNXT>,R3 ; GET LISTHEAD ADDRESS MINUS OFFSET
	MOV	<L$DFLG-L$DNME>(R0),LCLFLG ; SAVE THE FLAGS OF THE SYMBOL
	BIC	#^C<LD$SUP!LD$TYP>,LCLFLG ; ONLY THE SUPER-MODE AND TYPE BITS
20$:				;
	MOV	L$DNXT(R3),R3	; GET ADDRESS OF NEXT ENTRY
	BEQ	80$		; IF EQ CHECKED AGAINST ALL ENTRIES
	CMP	(R0),L$DNME(R3)	; CHECK FIRST HALF OF NAME
	BNE	30$		; IF NE NO MATCH
	CMP	2(R0),L$DNME+2(R3) ; CHECK SECOND HALF OF NAME
	BEQ	70$		; IF EQ -ERROR
30$:				;
	BIT	#LD$RSV,L$DFLG(R3) ; APR RESERVED?
	BNE	35$		; IF NE YES
	BIT	#LD$REL,L$DFLG(R3) ; ABS LIBRARY?
	BNE	20$		; IF NE NO
35$:				;
	MOV	L$DFLG(R3),R4	; GET THE LIBRARY LIST FLAG WORD
	BIC	#^C<LD$SUP!LD$TYP>,R4	; ONLY THE SUPER-MODE AND TYPE BITS
	CMP	LCLFLG,R4	; ARE THE TWO SIMILAR LIBRARIES?
	BNE	20$		; IF NE YES - SKIP CHECK
	MOV	L$DSA(R3),R4	; GET STARTING ADDRESS
	MOV	L$DMXV(R3),R5	; GET TOP ADDRESS
	CALL	50$		; ADDRESS CHECK
	BR	20$		; GO AGAIN
40$:				;
	TST	R2		; NAME-CHECK ONLY
	BEQ	90$		; IF EQ YES
	SWAB	R2		; COMPUTE TASK UPPER BOUND
	RORB	R2		;
	ROR	R2		;
	ROR	R2		;
	DEC	R2		; BACK OFF BY ONE
	ADD	R1,R2		; COMPUTE HIGH ADDRESS LIMIT
	BCS	60$		; IF C/S ERROR
	BR	90$		;
50$:				;
	TST	R2		; NAME-CHECK ONLY?
	BEQ	90$		; IF EQ YES
	CMP	R2,R4		; CHECK END VS LOW
	BLO	90$		; IF LO OK
	CMP	R1,R5		; CHECK START VS. HIGH
	BHI	90$		; IF HI, ENTIRELY ABOVE - OK.
60$:				;
	TST	(SP)+		; REMOVE RETURN
70$:				;
	MOV	$CURCLS,R4	; GET ADDRESS OF CURRENT CLUSTER
	BEQ	730$		; CURRENT LIBRARY NOT IN CLUSTER
	MOV	2(R4),R5	; GET NUMBER OF LIBRARIES IN CLUSTER
	TST	(R4)+		; ADJUST POINTER
710$:
	ADD	#4,R4		; POINT TO LIBRARY NAME
	CMP	(R4),L$DNME(R3) ; INTERSECTING LIBRARY IN CLUSTER?
	BNE	720$		; IF NE NO
	CMP	2(R4),L$DNME+2(R3) ; MAYBE
	BEQ	80$		; IF EQ YES
720$:
	DEC	R5		; NO LIBRARIES IN CLUSTER?
	BNE	710$		; IF NE YES
730$:
	SEC			; ERROR
	BR	90$		;
80$:				;
	CLC			; SUCCESS
90$:				;
	RETURN			;

	.DSABL	LSB

	.ENDC

	.PSECT	OPTBLK,D,GBL
$KWRDE::			; REF LABEL

	PURE.I			; READ-ONLY I-SPACE

	.END
