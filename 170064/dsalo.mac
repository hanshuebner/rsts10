	.TITLE	DSALO
	.IDENT	/03.05/
;
; COPYRIGHT (c)	1983 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE IS FURNISHED  UNDER A LICENSE AND MAY BE USED OR
; COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
	.IDENT	/03.05/
; C. MONIA 09-FEB-76
;
; MODIFIED BY:
;
;	C. B. PETROVIC	26-FEB-82	03.01
;		CBP039		ADD CORRECT .PSECT DEFINITIONS TO
;				ALLOW TKB TO BE LINKED AS AN I/D TASK.
;
;	J. M. SALMAN	2-JUL-82	03.02
;		JMS050		SUPPORT SELECTIVE INCLUSION OF AUTOLOAD
;				VECTORS USING NEW TKB-GENERATED ISD RECORD.
;
;	C. B. PETROVIC	7-JUN-82	03.03
;		CBP051		ADD AUTOLOAD SUPPORT FOR USER-MODE
;				I/D TASKS.
;
;	C. B. PETROVIC	03-SEP-82	03.04
;		CBP056		ADD AUTOLOAD SUPPORT FOR USER-MODE
;				I/D TASKS, PHASE 2. CREATION AND
;				OUTPUT OF TASK-RESIDENT SEGMENT
;				DESCRIPTORS.
;
;	J. M. SALMAN	01-OCT-82	03.05
;		JMS074		COMPUTE SIZE OF $$ALVD AS WELL AS $$ALVI
;				FOR SINGLE SEGMENT I/D TASKS.
;
;
;	C. B. PETROVIC	7-NOV-83	03.05
;		CBP114		ADD TRACE OF SELECTED VIRTUAL MEMORY PAGE
;
;
; ALLOCATE TASK-RESIDENT DESCRIPTORS
;
; LOCAL MACROS
;
; DEFINE SECTION EXTENSION TABLE ENTRY
;
; EXTSC	MUL1,MUL2,ADDCON
;
; WHERE:
;
;	MUL1 = ADDRESS OF MULTIPLICATION CONSTANT #1
;	MUL2 = ADDRESS OF MULTIPLICATION CONSTANT #2
;	ADDCON = ADDITIVE CONSTANT
;

	.MACRO	EXTSC	MUL1,MUL2,ADDCON

$$$=.
	.WORD	MUL1
	.WORD	MUL2
	.WORD	ADDCON
EXSIZ=.-$$$
	.ENDM

;
; LOCAL DATA
;
; SECTION EXTENSION TABLE
;
	PURE.D			; READ-ONLY D-SPACE

EXTBL0:
	EXTSC	SZATD,NMATL,0
EXTBL:	EXTSC	SZATL,NMATL,0
	EXTSC	SZREG,$NUMRG,0
	EXTSC	$SZSEG,$NUMSG,0
	EXTSC	SZWND,$TSKWD,0
TBSIZ=.-EXTBL/EXSIZ


	IMPURE			; READ/WRITE D-SPACE

NMATL:	.BLKW	1		; NUMBER OF AUTOLOAD VECTORS
SGSEG:	.BLKW	1		; CURRENT SEGMENT DESCRIPTOR TASK ADDRESS
	.BLKW	1		; ADDRESS OF SEGMENT DESCRIPTOR SECTION
	.BLKW	1		; CURRENT WINDOW DESCRIPTOR TASK ADDRESS
	.BLKW	1		; ADDRESS OF WINDOW DESCRIPTOR SECTION

;
; DESCRIPTOR SIZES
;
	PURE.D			; READ-ONLY D-SPACE

SZATL:	.WORD	S$ZATL		; AUTLOLOAD VECTOR
SZATD:	.WORD	S$ZATD		; AUTOLOAD VECTOR D-SPACE SIZE
SZREG:	.WORD	R$GLGH		; SIZE OF REGION DESCRIPTOR
SZWND:	.WORD	W$NLGH		; SIZE OF WINDOW DESCRIPTOR

;+
;
; **-$DSALO-ALLOCATE SPACE FOR TASK-RESIDENT DESCRIPTORS
;
; THIS SUBROUTINE IS CALLED TO SET THE LENGTH OF PROGRAM SECTIONS
; THAT WILL CONTAINS THE FOLLOWING TASK-RESIDENT DESCRIPTORS:
;
;	. SEGMENT TABLES
;	. AUTOLOAD VECTORS
;	. WINDOW DESCRIPTORS
;	. REGION DESCRIPTORS
;
; INPUTS:
;
;	SEGMENT TABLES
;
; OUTPUTS:
;
;	THE LENGTH OF THE FOLLOWING PROGRAM SECTIONS IS ESTABLISHED
;
;	$$ALVC - AUTOLOAD VECTORS
;	$$RGDS - REGION DESCRIPTORS
;	$$SGD1 - SEGMENT DESCRIPTORS
;	$$WNDS - WINDOW DESCRIPTORS
;
;-
	PURE.I			; READ-ONLY I-SPACE

$DSALO::			;
	CMP	$NUMSG,#1	; TASK OVERLAID?
	BLE	10$		; IF LE NO
	BIT	#ID$ATA,$SWTCH	; DOING AN I/D TASKBUILD
	BEQ	5$		; IF EQ, NO...CONVENTIONAL
	ADD	#S$ZIDX,$SZSEG	; IF NE, YES..INCREASE SIZE OF SEG. DESC.
5$:

	.IF DF D$DSAL & D$CVRL

	MOV	$PHASE,$VMPHZ	; SET VIRTUAL MEMORY TRACE ON...
	MOV	#-1,$VMSEG	; ...FOR ALL SEGMENTS...
	MOV	#$DSALO,$VMIDN	; ...SET SNAP IDENTIFIER

	.ENDC	; D$DSAL & D$CVRL

	MOV	#DSALO,R0	; GET ADDRESS OF PHASE DEPENDANT ROUTINE
	CALL	$PCTRL		; CALL PHASE CONTROL ROUTINE

	.IF DF D$DSAL & D$CVRL

	MOV	#-1,$VMPHZ	; SET VIRTUAL MEMORY TRACE OFF
	MOV	#1,$VMIDN	; RESET SNAP IDENTIFIER
	
	.ENDC	; D$DSAL & D$CVRL

	BIT	#ID$ATA,$SWTCH	; DOING AN I/D TASKBUILD
	BEQ	7$		; IF EQ, NO...CONVENTIONAL
	SUB	#S$ZIDX,$SZSEG	; IF NE, YES..DECREASE SIZE OF SEG. DESC.
7$:
	RETURN
10$:				;
	BIT	#SU$PLB,$SWOVR	; LINKING TO SUPERVISOR MODE LIBRARY?
	BEQ	20$		; IF EQ NO
	MOV	$RTSEG,R1	; GET ROOT VIRTUAL ADDRESS
	CALL	$CVRL		; CONVERT TO REAL
	CALL	$WRMPG		; WRITE MARK PAGE
	MOV	S$GSPL+4(R0),NMATL ; SET NUMBER OF SUPERVISOR VECTORS
	MOV	R0,R4		; COPY SEGMENT DESCRIPTOR ADDRESS
	MOV	R4,-(SP)	; SAVE R4
	MOV	R3,-(SP)	; SAVE
	ADD	#S$GSUP,R4	; POINT TO FIRST DESCRIPTOR
	MOV	#EXTBL,R3	; POINT TO EXTENSION LIST
	CALL	CMPSZ		; COMPUTE SIZE
	MOV	(SP)+,R3	; RESTORE
	MOV	(SP)+,R4	;
20$:
	MOV	$RTSEG,R1	; GET ROOT VIRTUAL ADDRESS
	CALL	$CVRL		; CONVERT TO REAL
	MOV	S$GATL+4(R0),NMATL ; SET NUMBER OF AUTOLOAD VECTORS
	BEQ	30$		; IF EQ NONE
	CALL	$WRMPG		; WRITE-MARK PAGE
	MOV	R0,R4		; COPY SEGMENT DESCRIPTOR ADDRESS
	MOV	R3,-(SP)	; SAVE R3
	MOV	R4,-(SP)	; SAVE R4
	ADD	#S$GAUT,R4	; POINT TO FIRST DESCRIPTOR
	MOV	#EXTBL,R3	; POINT TO EXTENSION LIST
	CALL	CMPSZ		; COMPUTE AUTOLOAD SECTION SIZE
	BIT	#ID$ATA,$SWTCH	; BUILDING AN I/D TASK?
	BEQ	25$		; IF EQ NO
	MOV	(SP),R4		; GET SEGMENT DESCRIPTOR ADDRESS
	ADD	#S$GDAL,R4	; POINT TO THE D-SPACE AUTOLOAD VECTOR
	MOV	#EXTBL0,R3	; POINT TO EXTENSION LIST
	CALL	CMPSZ		; COMPUTE SECTION SIZE
25$:
	MOV	(SP)+,R4	; RESTORE R4
	MOV	(SP)+,R3	; RESTORE R3
30$:
	RETURN			;

;
; ALLOCATE DESCRIPTOR STORAGE
;

DSALO:				;
	SAVRG			; SAVE THE NONVOLATILE REGISTERS
	MOV	$CRVSG,R1	; GET VIRTUAL ADDRESS OF CURRENT SEGMENT
	CALL	$WRMPG		; WRITE-MARK PAGE
	MOV	$CRSEG,R5	; GET THE REAL ADDRESS OF CURRENT SEGMENT
	BIT	#SU$PLB,$SWOVR	; LINKING TO SUPERVISOR MODE LIBRARY?
	BEQ	5$		; IF EQ NO
	MOV	S$GSPL+4(R5),NMATL ; GET NUMBER OF VECTORS
	MOV	R5,R4		; COPY SEGMENT DESCRIPTOR ADDRESS
	ADD	#S$GSUP,R4	; POINT TO FIRST DESCRIPTOR
	MOV	#EXTBL,R3	; POINT TO EXTENSION LIST
	CALL	CMPSZ		; COMPUTE SUPERVISOR VECTOR SECTION SIZE
5$:
	MOV	S$GATL+4(R5),NMATL ; SET NUMBER OF AUTOLOAD VECTORS
	BIT	#ID$ATA,$SWTCH	; IS THIS AN I/D TASKBUILD?
	BEQ	8$		; IF EQ, NO...CONVENTIONAL
	MOV	R5,R4		; IF NE, YES...COPY THE SEG. DESC. ADDRESS
	ADD	#S$GDAL,R4	; POINT TO THE D-SPACE AUTOLOAD VECTOR
	MOV	#EXTBL0,R3	; POINT TO THE EXTENSION TABLE
	CALL	CMPSZ		; AND CALCULATE THE EXTENSION SIZE.
8$:				; IF WE JUMP HERE, THEN CONVENTIONAL TASK.
	MOV	R5,R4		; COPY SEGMENT DESCRIPTOR ADDRESS
	ADD	#S$GAUT,R4	; POINT TO FIRST DESCRIPTOR
	MOV	#EXTBL,R3	; POINT TO EXTENSION LIST
	CALL	CMPSZ		; COMPUTE AUTOLOAD SECTION SIZE
	MOV	#SGSEG,-(SP)	; PUSH ADDRESS OF LOCAL STORE
	CMP	$CRVSG,$RTSEG	; CURRENT = ROOT?
	BNE	20$		; IF NE NO
	MOV	#TBSIZ-1,-(SP)	; PUSH NUMBER OF ENTRIES TO CONSIDER
10$:				;
	CALL	CMPSZ		; COMPUTE SIZE INCREMENT
	DEC	(SP)		; MORE TO PROCESS?
	BNE	10$		; IF NE NO
	INC	(SP)+		; CLEAN STACK
	MOV	(SP),R4		; GET ADDRESS OF LOCAL STORE
	MOV	S$GSEG(R5),(R4)+ ; SET BASE OF SEGMENT DESCRIPTORS
	MOV	S$GSEG+2(R5),(R4)+ ; SET VIRTUAL ADDRESS OF SECTION
	MOV	S$GWND(R5),(R4)+ ; SET BASE OF WINDOW DESCRIPTORS
	CLR	S$GWND(R5)	; RESET BASE ADDRESS
	MOV	S$GWND+2(R5),(R4) ; SET VIRTUAL ADDRESS OF WINDOW SECTIPN
20$:				;
	MOV	(SP)+,R4	; GET ADDRESS OF LOCAL STORE
	MOV	(R4),S$GSEG(R5) ; SET BASE OF SEGMENT TABLES
	ADD	$SZSEG,(R4)+	; UPDATE ADDRESS
	MOV	(R4)+,S$GSEG+2(R5) ; SET VIRTUAL ADDRESS OF SEGMENT TABLE SECTIP
	ADD	(R4)+,S$GWND(R5) ; OFFSET WINDOW DESCRIPTOR ADDRESS
	MOV	(R4),S$GWND+2(R5) ; SET ADDRESS OF WINDOW SECTION
	RETURN			;

;
; COMPUTE SIZE OF PROGRAM SECTION TO CONTAIN DESCRIPTOR
;

CMPSZ:				;
	MOV	@(R3)+,R1	; GET MULTIPLIER
	MOV	@(R3)+,R0	; GET MULTIPLICAND

	.IF NDF	V1145

	CALL	$MUL		; MULTIPLY

	.IFF

	MUL	R0,R1		; MULTIPLY

	.ENDC

	ADD	(R3)+,R1	; ADD ADDITIVE CONSTANT
	MOV	R1,-(SP)	; SAVE RESULT
	MOV	2(R4),R1	; GET VIRTUAL ADDRESS OF SECTION
	BEQ	10$		; IF EQ NONE
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	CALL	$WRMPG		; WRITE-MARK PAGE
	MOV	C$SCUR(R0),(R4)	; SET BASE OF DESCRIPTOR
	ADD	(SP),C$SCUR(R0)	; UPDATE CURRENT BASE
	BCC	10$		; IF C/C OK
	MOV	(R4),C$SCUR(R0)	; RESET CURRENT BASE
	MOV	R0,R2		; COPY ADDRESS OF SECTION
	ADD	#S$YM,R2	; POINT TO SECTION NAME
	MOV	#<S$V0*400!E$R19>,R1 ; GET ERROR/SEVERITY
	CALL	$ERMSG		; REPORT SECTION OVERFLOW
10$:				;
	INC	(SP)+		; CLEAN STACK
	CMP	(R4)+,(R4)+	; POINT TO NEXT SECTION
	RETURN			;

	.END
