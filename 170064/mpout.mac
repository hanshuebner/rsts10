	.TITLE	MPOUT
	.IDENT	/03.03/
;
; COPYRIGHT (c)	1983 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE IS FURNISHED  UNDER A LICENSE AND MAY BE USED OR
; COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;
;
; D. N. CUTLER/C. MONIA 25-JAN-74/ J.A.KASSON 20-APR-76
;
; Previously Modified By:
;
;	J. A. Kasson
;	E. Pollack
;	C. B. Petrovic
;
; Modified By:
;
;	T. Lekas	 6-May-83	03.03
;		TL292		Use the system default page length
;				if there is one.
;
; MONITOR DEPENDENT LOAD MAP OUTPUT ROUTINES
;
; MACRO LIBRARY CALLS
;

	.MCALL	GTIM$S,PUT$S

;
; LOCAL DATA
;
	PURE.D			; READ-ONLY D-SPACE

BLKNM:	.RAD50	/. BLK./	;NAME OF BLANK CONTROL SECTION

	IMPURE			; READ/WRITE D-SPACE

$MPFLG::.BLKW	1		;MAP BUFFER TRUE/FALSE FLAG
$LNCNT::.BLKW	1		; LINE COUNT
$SYMBF::.BLKW	60.		;++034 SYMBOL OUTPUT BUFFER

	.PSECT	MTXT$D,RO,D,GBL


	.NLIST BEX
	.ENABLE LC
FMT10:	.ASCIZ	/%2R %P%2A  /	;
FMT14:	.ASCII	/  /
FMT15:	.ASCII	/-R/
$FMT16::.ASCII	/%F%X   Memory allocation map  TKB %2R      Page %M%N/
	.ASCIZ	/%2R%15S%Y   %2Z%4N/
FMT21:	.ASCII	/%4N************%2N/	;
	.ASCIZ	/Undefined references: %2N/	;
FMT22:	.ASCIZ	/    %2R%N/
FMT23:	.ASCIZ	/    %2R/
FMT42:	.ASCIZ	/Total task size: %M. words%N/
FMT43:	.ASCII	/%4N*** Task builder statistics:%2N/
	.ASCIZ	/%4STotal work file references: %T.%N/
FMT44:	.ASCII	/%4SWork  file  reads: %T.%N/
	.ASCIZ	/%4SWork  file writes: %T.%N/
FMT45:	.ASCII	/%4SSize of core pool: %M. words (%M. pages)%N/
	.ASCIZ	/%4SSize of work file: %M. words (%M. pages)%2N/
FMT46:	.ASCIZ	/%4SElapsed time:%3Z%N/
FMT57:	.ASCIZ	/%N/
	.DSABLE LC

	.EVEN

;+
; **-$MPCAL-CALCULATE ADDRESS LIMITS OF SECTION AND RELOCATE
;
; INPUTS:
;
;	R0=ADDRESS OF SECTION TABLE ENTRY
;	R2=PARAMETER BUFFER ADDRESS. BUFFER IS SETUP AS FOLLOWS
;
;		.WORD	C$SCUR		; CURRENT BASE
;		.WORD	C$SCUR		; CURRENT BASE
;	R2=>	.WORD	LENGTH		; LENGTH CONTRIBUTED BY MODULE
;
; OUTPUTS:
;
;	PARAMETER BUFFER SETUP AS FOLLOWS:
;
;		.WORD	C$SCUR		; CURRENT BASE (RELOCATED)
;		.WORD	TOP		; TOP ADDRESS CONTRIBUTED BY MODULE
;		.WORD	LENGTH		; LENGTH CONTRIBUTED BY MODULE
;		.WORD	LENGTH		; LENGTH CONTRIBUTED BY MODULE
;
;-
	PURE.I			; READ-ONLY I-SPACE

$MPCAL::			;
	MOV	(R2)+,(R2)	; COPY LENGTH
	TST	-(R2)		; TEST LENGTH, ADJUST POINTER
	BEQ	10$		; IF EQ ZERO LENGTH
	ADD	(R2),-(R2)	;ADD LENGTH TO BASE ADDRESS
	DEC	(R2)+		;BACK OFF TO REAL ENDING ADDRESS
10$:	BITB	#CS$REL,C$SFLG(R0);ABS SECTION?
	BEQ	20$		;IF EQ YES
	BIT	#<CS$VAS*400!CS$LIB>,C$SFLG(R0);LIB SECTION?
	BNE	20$		;IF NE YES
	BITB	#CS$VSC,C$SFLG+1(R0) ; VIRTUAL SECTION?
	BNE	15$		; IF NE YES
	ADD	$OFFST,-(R2)	; RELOCATE ENDING ADDRESS
	ADD	$OFFST,-(R2)	; RELOCATE STARTING ADDRESS
	BR	20$		; EXIT
15$:				;
	CALL	(PC)		; COMPUTE BASE ADDRESS
	MOV	R0,-(SP)	; SAVE ADDRESS OF SECTION
	MOV	C$SBSE(R0),-(SP) ; SAVE BASE ADDRESS
	MOV	C$SLTH(R0),-(SP) ; SAVE LENGTH

	.IF DF	V1145

	CLR	R0		; CLEAR HIGH PART OF LENGTH
	MOV	-(R2),R1	; GET TOP ADDRESS
	DIV	(SP)+,R0	; DIVIDE

	.IFF

	MOV	-(R2),R0	; GET TOP ADDRESS
	MOV	(SP)+,R1	; GET LENGTH
	CALL	$DIV		; DIVIDE

	.ENDC

	ADD	(SP)+,R1	; RELOCATE ADDRESS
	MOV	R1,(R2)		; SET ADDRESS
	MOV	(SP)+,R0	; RESTORE R0
20$:	RETURN			;

;
; CHECK FOR BLANK SECTION NAME
;

$MPCHK::	MOV	S$YM(R0),(R2)+	;INSERT FIRST HALF OF SYMBOL
	MOV	S$YM+2(R0),(R2)+;INSERT SECOND HALF OF SYMBOL
	BNE	10$		;IF NE SECOND HALF NONZERO
	TST	-4(R2)		;TEST FIRST HALF
	BNE	10$		;IF NE LEAVE AS IS
	MOV	BLKNM,-4(R2)	;SET DEFAULT BLANK SECTION NAME
	MOV	BLKNM+2,-2(R2)	;
10$:	RETURN			;

;
; EDIT SIZE
;

$MPEDT::	MOV	(R2)+,(R2)	;COPY ENDING ADDRESS
	SUB	-4(R2),(R2)	;SUBTRACT STARTING ADDRESS
	INC	(R2)		;INCREMENT TO MAKE LENGTH
	MOV	(R2)+,(R2)	; COPY LENGTH
	RETURN

;
; SET UP FILE NAME IN BUFFER
;

$MPFLE::	ADD	#F.FNB,R1	;POINT TO FILE NAME BLOCK
	MOV	N.FNAM(R1),(R2)+;SET FILENAME
	MOV	N.FNAM+2(R1),(R2)+;
	MOV	N.FNAM+4(R1),(R2)+;
	MOV	N.FTYP(R1),(R2)+;SET FILE TYPE
	MOV	N.FVER(R1),(R2)+;SET FILE VERSION
	RETURN			;

;
; FLUSH SYMBOL BUFFER
;

$MPFSH::
	SAVRG
	TSTB	$MPFLG		;IS BUFFER EMPTY?
	BNE	10$		;IF NE BUFFER FULL
	MOV	#$SYMBF,R2	;ASSUME BUFFER EMPTY
	CLR	$MPFLG		;MAKE SURE FLAG IS CLEAR
	RETURN			;
10$:	CALL	$MPTLE		;PAGE FULL?
	CLR	R5
	MOV	#$SYMBF,R2	;ASSUME BUFFER EMPTY
	MOVB	$MPFLG,R3	;GET BUFFER FLAG VALUE
	MOV	#$OUTBF,R0		;ADDRESS OF OUTPUT BUFFER
20$:	MOV	#FMT10,R1
	CALL	EDMSG		; EDIT ONE COLUMN AT A TIME.
	ADD	R1,R5		;RUNNING TOTAL OF LINE LENGTH
	SOB	R3,20$
	MOV	R5,R1		;LENGTH IS EXPECTED IN R1
	CALL	MPOUT2		;OUTPUT WHOLE LINE
	MOV	#FMT57,R1		;END OF LINE INSERT CR-LF
	CALL	$MPOUT
	RETURN

;
; MAP OUTPUT ROUTINE
;

$MPOUT::MOV	#$SYMBF,R2	;GET ADDRESS OF ARGUMENT BLOCK
$MPOT1::MOV	R2,-(SP)	;SAVE BUFFER ADDRESS
	MOV	R1,-(SP)	;SAVE FORMT ADDRESS
	CALL	$MPTLE		;TEST FOR FULL PAGE
	MOV	(SP)+,R1	;RESTORE FORMAT ADDRESS
	MOV	(SP)+,R2	;RESTORE BUFFER ADDRESS
MPOT2:	MOV	#$OUTBF,R0	;GET ADDRESS OF OUTPUT BUFFER
	CALL	EDMSG		; EDIT OUTPUT
MPOUT2:	MOV	$MAPPT,R0	;GET MAP FILE RECORD BLOCK
	PUT$S	R0,#$OUTBF,R1	; OUTPUT RECORD
	BCC	30$		;IF CC OKAY
	MOV	R$NAME(R0),R2	;GET ADDRESS OF NAME STRING
	MOV	(PC)+,R1	;GET ERROR/SEVERITY
	.BYTE	E$R25,S$V2	;FATAL-NO RETURN
	CALL	$ERMSG		;OUTPUT ERROR MESSAGE
30$:	CLR	$MPFLG		;SET MAP FLAG TO "FALSE"
	MOV	#$SYMBF,R2	;RETURN ADDRESS OF SYMBOL BUFFER
	RETURN			;


;
; EDMSG - EDIT OUTPUT LINE WITH $EDMSG AND THEN COUNT LINE FEEDS
;
; INPUT:
;	R0 - ADDRESS OF OUTPUT BUFFER
;	R1 - ADDRESS OF MESSAGE
;
; OUTPUT:
;	$LNCNT - NUMBER OF LINE COUNTS
;	R0     - NEXT CHARACTER IN OUTPUT BUFFER
;


EDMSG:
	MOV	R5,-(SP)	; SAVE R5
	MOV	R0,R5		; SAVE ADDRES OF OUTPUT BUFFER
	CALL	$EDMSG		; EDIT OUTPUT
	MOV	R0,-(SP)	; SAVE PTR TO NEXT IN BUFFER
	SUB	R5,R0		; GET NUMBER OF CHARACTERS
10$:				; SCAN OUTPUT FOR LINE FEEDS
	CMPB	#FF,(R5)	; FORM FEED?
	BNE	20$		; IF NE	NO
	CLR	$LNCNT		; YES - START OF NEW PAGE
	BR	30$		;
20$:
	CMPB	#LF,(R5)	; LINE FEED?
	BNE	30$		; IF NE NO
	INC	$LNCNT		; COUNT LINE FEEDS
30$:
	TSTB	(R5)+		; POINT TO NEXT CHARACTER
	SOB	R0,10$		; END OF LINE?
	MOV	(SP)+,R0	; RESTORE PTR TO NEXT IN OUT BUF
	MOV	(SP)+,R5	; RESTORE R5
	RETURN
;
; TITLE - SKIPS TO NEXT PAGE AND OUTPUTS TITLE
;

$MPTLE::
	CMP	$LNCNT,$MXLIN	;Page full?
	BMI	40$		;IF LT NO
	MOV	$CRSEG,R0	;GET ADDRESS OF CURRENT SEGMENT
	MOV	S$GNME(R0),$STTLE	;INSERT SEGMENT NAME
	MOV	S$GNME+2(R0),$STTLE+2	;INTO SUBTITLE
	INC	$TITLE+14.		; INCREMENT PAGE COUNT
	MOV	$MPFLG,-(SP)		;SAVE BUFFER FLAG
	MOV	#$TITLE,R2	;GET ADDRESS OF TITLE BUFFER
	MOV	#$FMT16,R1	;GET ADDRESS OF TITLE FORMAT
	CALL	MPOT2		;OUTPUT TITLE
	MOV	(SP)+,$MPFLG	;RESTORE BUFFER FLAG
40$:
	RETURN


;+
; **-$MPSTS-OUTPUT TASK BUILDER STATISTICS
;
; THIS SUBROUTINE IS CALLED TO WRITE THE WORKFILE
; USEAGE STATISTICS INTO THE MAP FILE
;
; INPUTS:
;
;	$BGTIM=STARTING TASK BUILD TIME
;	$FRSIZ=SIZE OF CORE POOL
;	$HGVAD=SIZE OF WORKFILE (IN WORDS)
;	$WRKAC=NUMBER OF WORKFILE ACCESSES (DOUBLE PRECISION)
;	$WRKRD=NUMBER OF WORKFILE READS (DOUBLE PRECISION)
;	$WRKWR=NUMBER OF WORKFILE WRITES (DOUBLE PRECISION)
;
; OUTPUTS:
;
;	WORKFILE STATISTICS ARE APPENDED TO THE MAP FILE
;
;-

$MPSTS::			;
	MOV	#$SYMBF,R2	; GET ADDRESS OF PARAMETER STORAGE
	MOV	#$WRKAC,(R2)+	; GET POINTER TO WORK FILE ACCESS COUNT
	MOV	$MXLIN,-(SP)	;Compute the page size
	SUB	#7,(SP)		;Less 7 to check for title room
	CMP	$LNCNT,(SP)+	;Room for title on this page?
	BLE	5$		;IF LE YES
	MOV	$MXLIN,$LNCNT	;Force to new page
5$:
	MOV	#FMT43,R1	; GET FORMAT STRING ADDRESS
	CALL	$MPOUT		; OUTPUT TOTAL ACCESSES
	MOV	#$WRKRD,(R2)+	; SET POINTER TO READ ACCESSES
	MOV	#$WRKWR,(R2)+	; SET POINTER TO WRITE ACCESSES
	MOV	#FMT44,R1	; GET ADDRESS OF FORMAT STRING
	CALL	$MPOUT		; OUTPUT DISK ACCESS DATA
	MOV	$FRSIZ,(R2)	; SET SIZE OF CORE POOL IN BYTES
	CLC			; CLEAR CARRY
	ROR	(R2)		; CONVERT TO WORDS
	MOV	(R2)+,(R2)	; COPY SIZE
	CLRB	(R2)		; TRUNCATE TO NUMBER OF BLOCKS
	SWAB	(R2)+		; CONVERT TO NUMBER OF BLOCKS
	MOV	$HGVAD,(R2)	; COPY HIGH VIRTUAL ADDRESS
	MOV	(R2)+,(R2)	; COPY ADDRESS
	ADD	#377,(R2)	; ROUND TO NEXT BLOCK
	CLRB	(R2)		; TRUNCATE
	SWAB	(R2)		; CONVERT TO NUMBER OF BLOCKS
	MOV	#FMT45,R1	; GET ADDRESS OF FORMAT
	CALL	$MPOUT		; OUTPUT TO MAP FILE
	GTIM$S	#$SYMBF		; GET CURRENT TIME
	MOV	#3,R1		; SET LOOP COUNT
	MOV	#$BGTIM+G.TICT,R0 ; POINT TO BEGINNING TIME
	MOV	#$SYMBF+G.TICT,R2 ; POINT TO CURRENT TIME
10$:				;
	SUB	-(R0),-(R2)	; SUBTRACT TIME UNITS
	BPL	20$		; IF PL NO UNDERFLOW
	ADD	#60.,(R2)	; ADD IN BORROW
	DEC	-2(R2)		; DECREMENT NEXT HIGHER UNIT
20$:				;
	SOB	R1,10$		; LOOP
	MOV	#FMT46,R1	; GET FORMAT NUMBER
	CALLR	$MPOT1		; OUTPUT TO MAP FILE


;+
; **-$MPUND-MAP UNDEFINED SYMBOLS
;
; THIS ROUTINE IS CALLED AT THE END OF THE PHASE 5 PROCESSING OF A SEG-
; MENT TO OUTPUT A LIST OF UNDEFINED SYMBOLS IF ANY EXIST.
;
; INPUTS:
;
;	$CRSEG=ADDRESS OF CURRENT SEGMENT DESCRIPTOR.
;
; OUTPUTS:
;
;	LIST OF UNDEFINED SYMBOLS IS WRITTEN INTO THE LOAD MAP FILE.
;-

$MPUND::CALL	$MPFSH		;FLUSH SYMBOL BUFFER
	MOV	$CRSEG,R0	;GET ADDRESS OF CURRENT SEGMENT
	TST	S$GUND(R0)	;ANY UNDEFINED SYMBOLS?
	BEQ	20$		;IF EQ NONE
	MOV	$MXLIN,-(SP)	;Compute the page size
	SUB	#10.,(SP)	;Less 10 to check for undefined's room
	CMP	$LNCNT,(SP)+	;Room for undefined symbol on this page?
	BLE	5$		;IF LE YES
	MOV	$MXLIN,$LNCNT	;Force to new page
5$:	MOV	#FMT21,R1	;GET ADDRESS OF FORMAT
	CALL	$MPOUT		;OUTPUT HEADING
10$:
	MOV	#$MPOUT,R1	;ADDRESS OF OUTPUT ROUTINE
	CALL	$MPGUN		;GET UNDEFINED SYMBOL
20$:	RETURN			;

;+
;
; **-$MPGUN -GET UNDEFINED SYMBOL
;
; THIS ROUTINE IS CALLED TO FIND ANY UNDEFINED
; SYMBOLS IN A SEGMENT
;
;-
$MPGUN::
	SAVRG			;SAVE NON-VOLITITLE REGISTERS
	MOV	$CRSEG,R0	;GET ADDRESS OF CURRENT SEGMENT
	MOV	R1,R5
	ADD	#S$GSTB,R0	;POINT TO SYMBOL TABLE
	MOV	#$ISED,-(SP)	;SET ADDRESS OF SYMBOL EDIT ROUTINE
10$:	CALL	@(SP)+		;GET NEXT SYMBOL
	BCS	30$		;IF CS DONE
	BITB	#SY$DEF,S$YFLG(R0);SYMBOL DEFINED?
	BNE	10$		;IF NE YES-BYPASS
	BITB	#SY$WK,S$YFLG(R0)	;WEAK DEFINITION?
	BNE	10$		;IF NE YES -BYPASS
	MOV	S$YM(R0),$SYMBF	;SET SYMBOL NAME
	MOV	S$YM+2(R0),$SYMBF+2;
	MOV	#FMT22,R1	;GET ADDRESS OF FORMAT
	CALL	(R5)		;OUTPUT SYMBOL
	BR	10$	;GET NEXT UNDEFINED SYMBOL
30$:
	RETURN


;+
;
; MPPUT- OUTPUT UNDEFINED SYMBOLS TO TERMINAL
;
; INPUTS:
;	$SYMBF CONTAINS SYMBOL
;	R1 = ADDRESS OF FORMAT
;
; OUTPUTS:
;	SYMBOL PRINTED ON TERMINAL
;
;-
$MPPUT::
	MOV	#FMT23,R1	;ADDRESS OF FORMAT
	MOV	#$SYMBF,R2	;ADDRESS OF PARAMETER BUFFER
	MOV	#$OUTBF,R0	;ADDRESS OF OUTPUT BUFFER
	CALL	$EDMSG
	MOV	R1,R2		;LENGTH OF OUTPUT BUFFER IN BYTES
	MOV	#$OUTBF,R1	;ADDRESS OF PUTPUT BUFFER
	CALL	$PUTCO		;OUTPUT SYMBOL
	RETURN

;+
; $MPSYM- INSERTS SYMBOL NAME AND VALUE INTO SYMBOL
;	 BUFFER
;
;	INPUTS:
;	   R2=SYMBOL BUFFER ADDRESS
;	   R0=ADDRESS OF SYMBOL DESCRIPTOR
;
;	OUTPUT:
;	   SYMBOL AND VALUE INSERTED INTO SYMBOL BUFFER
;
;-
$MPSYM::
10$:	MOV	S$YM(R0),(R2)+	;INSERT SYMBOL NAME
	MOV	S$YM+2(R0),(R2)+;
	CMP	$RTSEG,$CRVSG	; ARE WE PROCESSING SYMBOLS FROM THE ROOT?
	BNE	14$		; IF NE, NO...IGNORE THE 'AUTOLOAD' CHECKS...
	BIT	#SY$ATL,S$YFLG(R0) ; IS THIS SYMBOL AUTOLOADABLE
	BEQ	14$		; IF EQ, NO...NORMAL SYMBOL
	BIT	#SY$SUP,S$YFLG(R0) ; IF NE, YES, BUT IS IT SUPER-MODE?
	BNE	12$		; IF NE, YES...
	MOV	S$YVOF(R0),(R2) ; IF EQ, NO...GET THE 'INDIRECT' ENTRY VALUE
	BR	13$		;
12$:
	MOV	S$YVOX(R0),(R2) ; GET THE SUPER-MODE 'INDIRECT ENTRY VALUE
13$:
	ADD	$OFFST,(R2)+	; ADD IN THE TASK PRIVILEGE BIAS
	MOV	#FMT15,(R2)+	; SET REL SUFFIX POINTER
	BR	20$		; RETURN
14$:
	MOV	S$YVAL(R0),(R2)+;INSERT SYMBOL VALUE
	MOV	#FMT14,(R2)+	;ASSUME ABS SYMBOL
	MOV	S$YCMT(R0),R1	;GET SECTION ENTRY ADDRESS
	MOV	R2,-(SP)	; SAVE BUFFER POINTER
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	MOV	(SP)+,R2	; RESTORE POINTER
	BITB	#CS$REL,C$SFLG(R0) ; ABS SECTION?
	BEQ	20$		;IF EQ YES
	MOV	#FMT15,-(R2)	;SET REL SUFFIX POINTER
	BIT	#<CS$VSC!CS$VAS*400!CS$LIB>,C$SFLG(R0) ; LIB OR VIRTUAL SECTION?
	BNE	15$		;IF NE YES
	ADD	$OFFST,-(R2)	;ADD OFFSET BIAS
	TST	(R2)+		;ADJUST R2
15$:	TST	(R2)+		;ADJUST R2
20$:
	RETURN

	.END
