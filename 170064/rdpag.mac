
	.IF NDF	W$$KST & W$$OPT

	.TITLE	RDPAG

	.ENDC

	.IF DF	W$$KST

	.IF NDF W$$OPT

	.TITLE	RDPAS

	.ENDC

	.IF DF	W$$OPT

	.TITLE	RDPASX

	.ENDC

	.ENDC

	.IDENT	/04.01/
;
;		COPYRIGHT (c) 1990 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD
;	 MASSACHUSETTS.  ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE  IS  FURNISHED  UNDER  A LICENSE AND MAY BE USED
; AND  COPIED  ONLY IN  ACCORDANCE WITH THE TERMS OF SUCH LICENSE
; AND WITH  THE INCLUSION  OF THE ABOVE  COPYRIGHT  NOTICE.  THIS
; SOFTWARE  OR ANY OTHER  COPIES  THEREOF, MAY NOT BE PROVIDED OR
; OTHERWISE MADE  AVAILABLE TO ANY OTHER PERSON.  NO TITLE TO AND
; OWNERSHIP OF THE SOFTWARE IS HEREBY TRANSFERRED.
;
; THE INFORMATION  IN THIS DOCUMENT IS SUBJECT  TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT  BY  DIGITAL
; EQUIPMENT CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF
; ITS SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.
;
;
; Written by:
;
;	C. Monia	22-Feb-74
;
; Previously modified by:
;
;	C. B. Petrovic
;
; Modified for RSX-11M-PLUS V4.0 by:
;
;	J. C. Franzini	 2-Jun-86	04.00
;		JCF292 -- Improve error handling of work file open failures
;
; Modified for RSX-11M-PLUS and Micro/RSX V4.4 by:
;
;	L. M. Peterson	13-Mar-90	04.01
;		LMP148 -- Improve performance by replacing workfile on disk
;			  with fast mapped VSECT region in optimized HFT version

;
; SUBROUTINES TO READ/WRITE PAGE BUFFERS TO VIRTUAL STORE
;
										;LMP148
	.IF NDF	W$$OPT								;LMP148
										;LMP148
; MACRO LIBRARY CALLS
;

	.MCALL	READ$,WRITE$,WTSE$S

;
; LOCAL DATA
;
	IMPURE			; READ/WRITE D-SPACE

BLK:	.WORD	0		; HIGH ORDER PART OF VIRTUAL BLOCK NUMBER
BLKL:	.BLKW	1		; LOW ORDER PART OF VIRTUAL BLOCK NUMBER
IOSTS:	.BLKW	2		; I/O DONE STATUS BLOCK
WKEXT:	.WORD	W$KEXT		; WORK FILE EXTEND SIZE

;+
; **-RDPAG-READ A PAGE INTO MEMORY
;
; INPUTS:
;
;	R0=PAGE ADDRESS
;	PAGE HEADER (P$GBLK) MUST CONTAIN RELATIVE BLOCK
;	NUMBER OF PAGE.
;
; OUTPUTS:
;
;	REQUESTED PAGE IS TRANSFERRED INTO MEMORY
;-
	PURE.I			; READ-ONLY I-SPACE

$RDPAG::			;
	SAVVR			; SAVE VOLATILE REGISTERS
	CALL	STIOR		; SETUP FOR READ
	READ$	R0,R1,#512.,#BLK,#2,#IOSTS ; EXECUTE READ
	CALL	CHKST		; CHECK STATUS
	BCS	CHKST1		; IF C/S FATAL ERROR

	.IF DF	W$$KST

	INC	$WRKRD+2	; INCREMENT LOW PART OF READ COUNT
	BNE	10$		; IF NE HAVE CURRENT COUNT
	INC	$WRKRD		; INCREMENT HIGH PART OF COUNT
10$:				;

	.ENDC

	RETURN			; EXIT

;+
; **-$WRPAG-WRITE A PAGE INTO VIRTUAL STORE
;
; INPUTS:
;
;	R2=ADDDRESS OF PAGE TO BE SWAPPED OUT
;	PAGE HEADER (P$GBLK) MUST CONTAIN RELATIVE BLOCK NUMBER
;	OF PAGE
;
; OUTPUTS:
;
;	REQUESTED PAGE IS TRANSFERRED TO VIRTUAL STORE
;
;-

$WRPAG::			;
	SAVVR			; SAVE VOLATILE REGISTERS
	CALL	STIOW		; SET REGISTERS FOR WRITE
10$:				;
	MOV	WKEXT,F.ALOC(R0) ; Set work file extension size

	WRITE$	R0,R1,#512.,#BLK,#2,#IOSTS ; EXECUTE SWAP
	CALL	CHKST		; WAIT FOR COMPLETION
	BCS	10$		; If CS, repeat operation

	.IF DF	W$$KST

	INC	$WRKWR+2	; INCREMENT LOW PART OF WRITE COUNT
	BNE	20$		; IF NE HAVE COUNT
	INC	$WRKWR		; INCREMENT HIGH PART OF COUNT
20$:				;

	.ENDC

	RETURN			;

;
; SETUP REGISTERS FOR A PAGE I/O REQUEST
;

STIOR:				;
	MOV	R0,R1		; COPY PAGE ADDRESS

	.IF DF D$RDPG & D$VMDP

	MOV	#100000,$VMPAG	; SET VIRTUAL PAGE TO DUMP...
	MOV	#-1,$VMSEG	; SET TO DUMP ALL REFERENCES
	MOV	R1,$VMPAD	; SET REAL MEMORY ADDRESS
	MOV	#$RDPAG,$VMIDN	; SET DUMP IDENTIFIER

	.ENDC	; D$RDPG & D$VMDP

	BR	STIO		;
STIOW:				;
	MOV	R2,R1		; COPY PAGE ADDRESS

	.IF DF D$RDPG & D$VMDP

	MOV	#100000,$VMPAG	; SET VIRTUAL PAGE TO DUMP...
	MOV	#-1,$VMSEG	; SET TO DUMP ALL REFERENCES
	MOV	R1,$VMPAD	; SET REAL MEMORY ADDRESS
	MOV	#$WRPAG,$VMIDN	; SET DUMP IDENTIFIER

	.ENDC	; D$RDPG & D$VMDP

STIO:				;
	CLR	BLKL		; CLEAR LOW PART OF VBN
	MOVB	P$GBLK(R1),BLKL ; SET LOW PART OF VBN
	INC	BLKL		; CONVERT RELATIVE BLOCK TO VBN
	ADD	#P$GHD,R1	; STEP PAST HEADER
	MOV	$WRKPT,R0	; GET RECORD BLOCK
	RETURN			;

;
; CHECK STATUS OF I/O REQUEST
;

	.ENABL	LSB

CHKST:				;
	BCS	5$		; IF C/S NEGATE EXTEND SIZE
	WTSE$S	#2		; WAIT FOR I/O COMPLETION
	ROLB	IOSTS		; GET SIGN OF STATUS BYTE
	BCC	10$		; IF C/C OK
5$:				;
	NEG	WKEXT		; NEGATE WORK FILE EXTEND SIZE
	SEC			; SET FAILURE
	BMI	10$		; IF MI REPEAT OPERATION
CHKST1:				;

	.IF DF D$RDPG & D$VMDP

	MOV	$PHASE,$VMPHZ	; SET PHASE NUMBER TO DUMP ON
	CALL	$VMDMP		; SNAPSHOT THE VIRTUAL MEMORY PAGE
	MOV	#-1,$VMPHZ	; RESET PHASE NUMBER
	MOV	#0,$VMPAG	; RESET VIRTUAL PAGE TO DUMP...
	MOV	#-1,$VMSEG	; RESET DUMP REFERENCES
	MOV	#0,$VMPAD	; RESET REAL MEMORY ADDRESS
	MOV	#1,$VMIDN	; RESET DUMP IDENTIFIER

	.ENDC	; D$RDPG & D$VMDP

	CLR	R2		; SET DUMMY PARAMETER BLOCK ADDRESS
	MOV	#<S$V2*400!E$R73>,R1 ; GET ERROR/SEVERITY
	CALL	$ERMSG		; FATAL-NO RETURN
10$:				;
	RETURN			;

	.DSABL	LSB

										;LMP148
	.ENDC									;LMP148
										;LMP148
	.IF DF	W$$OPT								;LMP148
										;LMP148
;										;LMP148
; LOCAL DATA									;LMP148
;										;LMP148
	PURE.D			; READ-ONLY D-SPACE				;LMP148
										;LMP148
TABLE:	.WORD	   0		; TABLE OF W.NOFF'S (32 WD BLKS)		;LMP148
	.WORD	 200								;LMP148
	.WORD	 400								;LMP148
	.WORD	 600								;LMP148
	.WORD	1000								;LMP148
	.WORD	1200								;LMP148
	.WORD	1400								;LMP148
	.WORD	1600								;LMP148
	.WORD	2000								;LMP148
	.WORD	2200								;LMP148
	.WORD	2400								;LMP148
	.WORD	2600								;LMP148
	.WORD	3000								;LMP148
	.WORD	3200								;LMP148
	.WORD	3400								;LMP148
	.WORD	3600								;LMP148
										;LMP148
;+										;LMP148
; **-RDPAG-READ A PAGE INTO MEMORY						;LMP148
;										;LMP148
; INPUTS:									;LMP148
;										;LMP148
;	R0=PAGE ADDRESS								;LMP148
;										;LMP148
; OUTPUTS:									;LMP148
;										;LMP148
;	REQUESTED PAGE IS TRANSFERRED INTO MEMORY				;LMP148
;-										;LMP148
	PURE.I			; READ-ONLY I-SPACE				;LMP148
										;LMP148
$RDPAG::			;						;LMP148
	SAVVR			; SAVE VOLATILE REGISTERS			;LMP148
	CALL	STIOR		; FAST MAP TO VSECT				;LMP148
	MOV	2(SP),-(SP)	; DESTINATION ADDRESS FOR COPY (R0)		;LMP148
	ADD	#P$GHD,(SP)	; OFFSET PAST HEADER				;LMP148
	MOV	$VOFF,-(SP)	; SOURCE ADDRESS FOR COPY			;LMP148
	CALL	COPY		; COPY PAGE FROM VSECT REGION			;LMP148
	TST	(SP)+		; CLEAN STACK					;LMP148
	TST	(SP)+		; CLEAN STACK					;LMP148
										;LMP148
	.IF DF	W$$KST								;LMP148
										;LMP148
	INC	$WRKRD+2	; INCREMENT LOW PART OF READ COUNT		;LMP148
	BNE	20$		; IF NE HAVE CURRENT COUNT			;LMP148
	INC	$WRKRD		; INCREMENT HIGH PART OF COUNT			;LMP148
20$:				;						;LMP148
										;LMP148
	.ENDC									;LMP148
										;LMP148
	RETURN			; EXIT						;LMP148
										;LMP148
;+										;LMP148
; **-$WRPAG-WRITE A PAGE INTO VIRTUAL STORE					;LMP148
;										;LMP148
; INPUTS:									;LMP148
;										;LMP148
;	R2=ADDDRESS OF PAGE TO BE SWAPPED OUT					;LMP148
;	PAGE HEADER (P$GBLK) MUST CONTAIN RELATIVE BLOCK NUMBER			;LMP148
;	OF PAGE									;LMP148
;										;LMP148
; OUTPUTS:									;LMP148
;										;LMP148
;	REQUESTED PAGE IS TRANSFERRED TO VIRTUAL STORE				;LMP148
;										;LMP148
;-										;LMP148
										;LMP148
$WRPAG::			;						;LMP148
	SAVVR			; SAVE VOLATILE REGISTERS			;LMP148
	CALL	STIOW		; FAST MAP TO VSECT				;LMP148
	MOV	$VOFF,-(SP)	; DESTINATION ADDRESS FOR COPY			;LMP148
	MOV	10(SP),-(SP)	; SOURCE ADDRESS FOR COPY (R2 FROM SAVVR)	;LMP148
	ADD	#P$GHD,(SP)	; OFFSET PAST HEADER				;LMP148
	CALL	COPY		; COPY PAGE TO VSECT REGION			;LMP148
	TST	(SP)+		; CLEAN STACK					;LMP148
	TST	(SP)+		; CLEAN STACK					;LMP148
										;LMP148
	.IF DF	W$$KST								;LMP148
										;LMP148
	INC	$WRKWR+2	; INCREMENT LOW PART OF WRITE COUNT		;LMP148
	BNE	20$		; IF NE HAVE COUNT				;LMP148
	INC	$WRKWR		; INCREMENT HIGH PART OF COUNT			;LMP148
20$:				;						;LMP148
										;LMP148
	.ENDC									;LMP148
										;LMP148
	RETURN			;						;LMP148
										;LMP148
;										;LMP148
; SET UP REGISTERS FOR FAST MAPPING						;LMP148
;										;LMP148
										;LMP148
STIOR:				;						;LMP148
	MOV	R0,R1		; COPY PAGE ADDRESS				;LMP148
										;LMP148
										;LMP148
	BR	STIO		;						;LMP148
STIOW:				;						;LMP148
	MOV	R2,R1		; COPY PAGE ADDRESS				;LMP148
										;LMP148
										;LMP148
STIO:				;						;LMP148
										;LMP148
; DO CONVERSION TO FIND (512. BYTE BLOCK) OFFSET WITHIN APR			;LMP148
										;LMP148
	CLR	R0		; SET FOR MOVB WITHOUT EXTEND			;LMP148
	BISB	P$GBLK(R1),R0	; GET RELATIVE BLOCK NUMBER			;LMP148
	BIC	#360,R0		; CONVERT INTO VIRTUAL ADDRESS OFFSET		;LMP148
	.REPT	9.		; WITHIN APR					;LMP148
	ASL	R0		;						;LMP148
	.ENDR			;						;LMP148
	ADD	#160000,R0	; WHICH WILL BE MAPPED THRU DAPR 7		;LMP148
	MOV	R0,$VOFF	; AND SAVE FOR LATER				;LMP148
										;LMP148
; DO CONVERSION TO FIND WHICH APR IN VSECT REGION WE WANT			;LMP148
										;LMP148
	CLR	R0		; SET FOR MOVB WITHOUT EXTEND			;LMP148
	BISB	P$GBLK(R1),R0	; GET RELATIVE BLOCK NUMBER			;LMP148
	BIC	#17,R0		; CALCULATE APR WE WANT				;LMP148
	.REPT	3								;LMP148
	ASR	R0		;						;LMP148
	.ENDR									;LMP148
	MOV	TABLE(R0),R1	; GET OFFSET INTO VSECT REGION			;LMP148
	MOV	#IOTAPR,R0	; WINDOW STARTS IN USER D-APR 7			;LMP148
	IOT			; DO FAST MAP					;LMP148
	TST	R0		; SUCCESSFUL?					;LMP148
	BPL	10$		; IF PL, YES					;LMP148
	MOV	(PC)+,R1	; GET ERROR/SEVERITY				;LMP148
	.BYTE	E$R112,S$V2	; VSECT FAST MAPPING UNAVAILABLE		;LMP148
	CALL	$ERMSG		; ISSUE FATAL ERROR (NO RETURN)			;LMP148
10$:										;LMP148
	RETURN			;						;LMP148
										;LMP148
										;LMP148
;+										;LMP148
; COPY PAGE 									;LMP148
;										;LMP148
;   THIS ROUTINE IS CALLED TO MOVE A BLOCK OF DATA. THE CODE HERE		;LMP148
;   IS MUCH MORE EFFICIENT THAN A NORMAL BLOCK MOVE (USING SOB OR WHATEVER),	;LMP148
;   AND WAS OBTAINED FROM PDP LANGUAGES (WHO GOT IT FROM US). BOTH SOURCE	;LMP148
;   AND DESTINATION ADDRESSES MUST BEGIN ON A WORD BOUNDARY, AND THE BLOCK	;LMP148
;   SIZE IS 512. BYTES.								;LMP148
;										;LMP148
;   INPUTS:									;LMP148
;   	(SP)  - RETURN ADDRESS							;LMP148
;  	2(SP) - SOURCE ADDRESS							;LMP148
;  	4(SP) - DESTINATION ADDRESS						;LMP148
;										;LMP148
;   OUTPUTS:									;LMP148
;   	NONE									;LMP148
;										;LMP148
;+										;LMP148
										;LMP148
;										;LMP148
;   We'll need two registers to move the data. We can always take R1,		;LMP148
;   so push R0 to use as the other. Then load source pointer to R1,		;LMP148
;   and destination pointer to R0						;LMP148
;										;LMP148
COPY:										;LMP148
	MOV	R0,-(SP)							;LMP148
	MOV	4(SP),R1							;LMP148
	MOV	6(SP),R0							;LMP148
;										;LMP148
;   As the block move is done as a series of calls, we need to			;LMP148
;   fake a return address on the stack						;LMP148
;										;LMP148
	MOV	#1$,-(SP)			; No need for PIC		;LMP148
										;LMP148
;   Now move the data								;LMP148
										;LMP148
	CALL	(PC)								;LMP148
	CALL	(PC)								;LMP148
	CALL	(PC)								;LMP148
										;LMP148
	.REPT	32.								;LMP148
										;LMP148
	MOV	(R1)+,(R0)+							;LMP148
										;LMP148
	.ENDR									;LMP148
										;LMP148
	RETURN									;LMP148
;										;LMP148
;   Get here once block has been moved, restore R0 and leave			;LMP148
;										;LMP148
1$:	MOV	(SP)+,R0							;LMP148
	RETURN									;LMP148
										;LMP148
	.ENDC									;LMP148

	.END
