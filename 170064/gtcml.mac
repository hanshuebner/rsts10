	.TITLE	GTCML
	.IDENT	/06.02/
;
; COPYRIGHT (c)	1983 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE IS FURNISHED  UNDER A LICENSE AND MAY BE USED OR
; COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; VERSION 06.02
;
; D. N. CUTLER/C. MONIA 07-FEB-74
;
; MODIFIED BY:
;
;	C. B. PETROVIC	26-FEB-82	06.01
;		CBP039		ADD CORRECT .PSECT DEFINITIONS TO
;				ALLOW TKB TO BE LINKED AS AN I/D TASK.
;
;	J. M. Lawler	03-JUL-82	06.02
;		JML112		PROMPT WITH CALCULATED TASK NAME
;
;
;
; MACRO LIBRARY CALLS
;

	.MCALL	GCML$

;+
; **-$GTCML-GET LINE FROM COMMAND INPUT FILE
;
; THIS ROUTINE CALLS THE SYSTEM LIBRARY ROUTINE .GCML TO READ THE NEXT
; RECORD FROM THE COMMAND INPUT FILE. IF THE LINE CONTAINS A LEADING ";",
; THEN IT IS TREATED AS A COMMENT LINE AND ANOTHER LINE IS READ. IF THE
; FIRST TWO CHARACTERS OF THE LINE ARE "/BLANK", "/0", OR "//", THEN A
; LOGICAL EOF IS RETURNED TO THE CALLER. FOR "//" AND A REAL EOF, EN$DR
; IS SET IN $SWTCH THUS CAUSING AN EXIT AT THE END OF THE CURRENT BUILD.
; IF NONE OF THESE CONDITIONS ARE MET, THEN THE LINE IS TRANSFERED TO
; $LNBUF, $LNDES IS SET UP AS THE LINE DESCRIPTOR, AND A RETURN TO THE
; CALLER IS EXECUTED.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	C=1 IF LOGICAL EOF.
;	C=0 IF REQUEST SUCESSFUL WITH LINE IN $LNBUF AND $LNDES SET UP AS
;		THE LINE DESCRIPTOR.
;		R0=ADDRESS OF LINE DESCRIPTOR.
;-
	PURE.I			; READ-ONLY I-SPACE

$GTCML::MOV	$CMIPT,R0	;GET COMMAND BLOCK ADDRESS
	CLR	R2		;ASSUME STANDARD PROMPTING
	MOV	$CMFLG,R1	;GET ADDRESS OF PROMPT DESCRIPTOR
	.IF	DF R$$PRO

	BNE	10$		;IF NE, ALTERNATE BUFFER SPECIFIED
	MOV	#$PRMPT,R1	;ADDRESS OF TASK NAME PROMPT
	MOV	#$PSIZ,R2	;LENGTH OF PROMPT
	BR	20$		;GET NEXT COMMAND LINE
10$:	
	.ENDC	;DF R$$PRO
	
	BEQ	20$		;IF EQ, NO ALTERNATE BUFFER
	MOV	(R1)+,R2	;GET LENGTH OF PROMPT STRING
	MOV	(R1),R1		;GET ADDRESS OF PROMPT STRING
20$:	GCML$	R0,R1,R2	;GET COMMAND LINE


	BCS	GTCML1		;IF CS EOF OR ERROR
	MOV	G.CMLD(R0),R1	;GET LENGTH OF LINE
	BEQ	$GTCML		;IF NULL TRY AGAIN
	MOV	R1,$LNDES	;SET LENGTH OF LINE
	MOV	G.CMLD+2(R0),R2	; GET LINE BUFFER ADDRESS
	MOV	R2,$LNDES+2	;SET ADDRESS OF BUFFER
	ADD	R2,R1		; COMPUTE ADDRESS OF LAST BYTE PLUS 1
	CLRB	(R1)		; SET ZERO SENTINEL BYTE
	CLR	R1		;++039 SET FOR MOVB WITH NO SIGN EXTEND
	BISB	1(R2),R1	;++039 GET SECOND BYTE IN STRING
	SWAB	R1		;++039 POSITION TO HIGH BYTE
	BISB	(R2),R1		;++039 GET FIRST BYTE IN STRING
	CMP	(PC)+,R1	;++039 "/BLANK"?
	.BYTE	'/,' 		;
	BEQ	GTCML3		;IF EQ YES
	CMP	(PC)+,R1	;++039 "/0"?
	.BYTE	'/,0		;
	BEQ	GTCML3		;IF EQ YES
	CMP	(PC)+,R1	;++039 "//"?
	.BYTE	'/,'/		;
	BEQ	GTCML2		;IF EQ YES
	MOV	#$LNDES,R0	;GET ADDRESS OF LINE DESCRIPTOR
	CLC			;CLEAR CARRY
	RETURN			;

;
; EOF OR ERROR
;

GTCML1:	MOVB	G.ERR(R0),R2	;PICK UP ERROR CODE
	CMPB	#GE.EOF,R2	;EOF?
	BEQ	GTCML2		;IF EQ YES
	MOV	(PC)+,R1	;ASSUME I/O ERROR
	.BYTE	E$R6,S$V0	;DIAGNOSTIC
	CMPB	#GE.IOR,R2	;I/O ERROR
	BEQ	10$		;IF EQ YES
	MOV	(PC)+,R1	;ASSUME OPEN FAILURE
	.BYTE	E$R7,S$V2	;FATAL-NO RETURN
	CMPB	#GE.OPR,R2	;OPEN FAILURE?
	BEQ	10$		;IF EQ YES
	MOV	(PC)+,R1	;ASSUME BAD FILENAME
	.BYTE	E$R8,S$V2	;FATAL-NO RETURN
	CMPB	#GE.BIF,R2	;BAD FILENAME?
	BEQ	10$		;IF EQ YES
	MOV	(PC)+,R1	;ASSUME MAX DEPTH EXCEEDED
	.BYTE	E$R9,S$V2	;FATAL-NO RETURN
	CMPB	#GE.MDE,R2	;MAX DEPTH EXCEEDED?
	BEQ	10$		;IF EQ YES
	MOV	(PC)+,R1	;ILLEGAL ERROR CODE
	.BYTE	E$R0,S$V2	;FATAL-NO RETURN
10$:	MOV	R0,R2		;COPY ADDRESS OF CONTROL BLOCK
	ADD	#G.CMLD,R2	;POINT TO LINE DESCRIPTOR
	CALL	$ERMSG		;OUTPUT ERROR MESSAGE
GTCML2:	BIS	#EN$DR,$SWTCH	;SET END OF RUN
GTCML3:	SEC			;SET CARRY
	RETURN			;

	.END
