	.TITLE	HEADR
	.IDENT	/31.12/
;
; COPYRIGHT (c) 1991 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE IS FURNISHED  UNDER A LICENSE AND MAY BE USED OR
; COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;
; D.N. CUTLER/C. MONIA 26-DEC-73
;
;
;
; MODIFIED FOR RSX-11M/M-PLUS V4.0/V2.0 BY:
;
;	J. A. KASSON
;	C. B. PETROVIC
;	J. M. LAWLER
;
; MODIFIED FOR RSX-11M/M-PLUS V4.1/V2.1 BY:
;
;	C. B. PETROVIC
;	B. S. MCCARTHY
;	L. B. MCCULLEY
;	L. M. PETERSON
;
; MODIFIED FOR RSX-11M-PLUS V4.0 BY:
;
;	D. P. RABAHY
;
; MODIFIED FOR RSX-11M-PLUS V4.1 BY:
;
;	L. M. PETERSON		31.09	LMP098
;		ADD SUPPORT TO RESERVE LIBRARY D-SPACE
;
; MODIFIED FOR RSX-11M-PLUS AND MICRO/RSX V4.3 BY:
;
;	L. M. PETERSON		31.10	LMP131
;		ALLOW TASKS WITH (TASK)MEMORY RESIDENT OVERLAYS TO BE 
;		EXTENDED (WITH THE $EXTM DIRECTIVE)
;
;	L. M. PETERSON		31.11	LMP135
;		SET LABEL BLOCK DEFINITIONS WITH LBLDF$ MACRO INSTEAD 
;		OF DECLARING THEM
;
;	C. M. KATZ		31.12	CMK001
;		ADD RSTS CONDITIONALS
;
; LAST MODIFICATION DATE: 12-JUL-89
;
; WRITE TASK IMAGE FILE HEADER
;
; MACRO LIBRARY CALLS
;

	.MCALL	CLOSE$

;
; EQUATED SYMBOLS
;


	.IF	NDF	R$$11M

SF.XA=004000			;NOT ABORTABLE
SF.XC=040000			;NOT CHECKPOINTABLE
SF.XD=010000			;NOT DISABLABLE
SF.XF=020000			;NOT FIXABLE
SF.PT=000200			;PRIVILEGED


	.ENDC

;
; MACRO LIBRARY CALLS
;

	.MCALL	GTIM$S

;
; LOCAL MACROS
;
; GENERATE DATA BLOCK
;
; GBLK	ADRS,TXT,COUNT
;
; WHERE:
;
;	ADRS=STARTING ADDRESS IN TASK IMAGE WHERE TEXT IS TO BE WRITTEN.
;	     IF ODD, THIS VALUE POINTS TO THE REAL ADDRESS.
;
;	TXT=STARTING MEMORY ADDRESS OF TEXT TO BE WRITTEN
;
;	COUNT=NUMBER OF WORDS TO BE WRITTEN
;

	.MACRO	GBLK	ADRS,TXT,COUNT
.=.-2
	.WORD	TXT
	.WORD	ADRS
	.WORD	COUNT
	.WORD	0
	.ENDM

;
; GENERATE BIT TRANSFORMATION TABLE ENTRY
;
; GBTBL MSK1,MSK2
;
; WHERE:
;
;	MSK1=MASK WORD THAT SPECIFIES BIT TO BE TESTED.
;	MSK2=MASK WORD THAT SPECIFIES BIT TO BE SET IF MSK1 BIT IS
;		SET IN FILE SWITCH OPTION WORD.
;

	.MACRO	GBTBL MSK1,MSK2
	.PSECT	BITBL,RO,D
.=.-2
	.WORD	MSK1
	.WORD	MSK2
	.WORD	0
	IMPURE			; READ/WRITE D-SPACE
	.ENDM

;
; GENERATE HEADER BLOCK
;
; GHDRB HDADR,TXADR,COUNT
;
; WHERE:
;
;	HDADR=STARTING ADDRESS IN HEADER OF WHERE TEXT IS TO BE
;		WRITTEN.
;	TXADR=STARTING MEMORY ADDRESS OF TEXT TO BE WRITTEN.
;	COUNT=NUMBER OF WORDS TO BE WRITTEN.
;

	.MACRO	GHDRB HDADR,TXADR,COUNT
	.PSECT	HDRTBL,RO,D
	GBLK	HDADR,TXADR,COUNT
	IMPURE			; READ/WRITE D-SPACE
	.ENDM

;
; GENERATE LABEL BLOCK
;
; GLBLB	LBADR,TXADR,COUNT
;
; WHERE:
;
;	LBADR=STARTING ADDRESS IN LABEL WHERE TEXT IS TO BE WRITTEN
;
;	TXADR=STARTING MEMORY ADDRESS OF TEXT TO BE WRITTEN
;
;	COUNT=NUMBER OF WORDS TO BE WRITTEN
;

	.MACRO	GLBLB	LBADR,TXADR,COUNT
	.PSECT	LBLTBL,RO,D
	GBLK	LBADR,TXADR,COUNT
	IMPURE			; READ/WRITE D-SPACE
	.ENDM

;
; GENERATE VARIABLE PART OF LABEL BLOCK
;
; GLBLV	LBADR,TXADR,COUNT
;
; WHERE:
;
;	LBADR=STARTING ADDRESS IN LABEL WHERE TEXT IS TO BE WRITTEN
;
;	TXADR=STARTING MEMORY ADDRESS OF TEXT TO BE WRITTEN
;
;	COUNT=NUMBER OF WORDS TO BE WRITTEN
;
;
	.MACRO	GLBLV LBADR,TXADR,COUNT
	.PSECT	LBVTBL,RO,D
	GBLK	LBADR,TXADR,COUNT
	IMPURE			; READ/WRITE D-SPACE
	.ENDM

;
; LOCAL DATA
;
; BIT TRANSFORMATION TABLE
;
; THIS TABLE IS USED TO TRANSFORM TASK BUILDER BIT DEFINITIONS INTO
; RSX11D TASK STATUS BIT DEFINITIONS.
;

	.PSECT	BITBL,RO,D
BITBAS:	.WORD	0		;DUMMY ZERO WORD AT START OF TBL
	IMPURE			; READ/WRITE D-SPACE

	.IF	NDF	R$$11M

	GBTBL	SW$CP,SF.XC
	GBTBL	SW$AB,SF.XA
	GBTBL	SW$DS,SF.XD
	GBTBL	SW$FX,SF.XF
	GBTBL	SW$PR,SF.PT

	.IFF

	GBTBL	SW$AC,TS$ACP!TS$PRV
	GBTBL	SW$CP,TS$CHK
	GBTBL	SW$PR,TS$PRV
	GBTBL	SW$NH,TS$NHD
	GBTBL	SW$PI,TS$PIC
	GBTBL	SW$PM,TS$PMD
	GBTBL	SW$SL,TS$SLV
	GBTBL	SW$CM,TS$CMP
	GBTBL	SW$NS,TS$NSD

;
;	SECOND HEADER FLAGS TRANSOFORMATION TABLE
;
	.PSECT	BITBL
BT2BAS:	.WORD	0		; DUMMY ZERO WORD AT START OF TABLE
	IMPURE			; READ WRITE D-SPACE

	GBTBL	FS$MAP,T2$FMP
	GBTBL	IM$CLI,T2$CLI
	.ENDC

;
; HEADER BLOCK TABLE
;

	.PSECT	HDRTBL,RO,D
HDRBAS:	.WORD	0		;DUMMY ZERO WORD AT START OF TBL
	IMPURE			; READ/WRITE D-SPACE

	.IF	NDF	R$$11M

	GHDRB	H$DFLP,HDFLP,1
	GHDRB	H$DPDR,$HDPDR,8.
	GHDRB	H$DPAR,$HDPAR,8.
	GHDRB	H$DPS,HDPS,1
	GHDRB	H$DPC,HDPC,1
	GHDRB	H$DR0,HDR0,3
	GHDRB	H$DR0,HDR0,6
	GHDRB	H$DSP,HDSP,1
	GHDRB	H$DIPS,HDPS,1
	GHDRB	H$DIPC,HDPC,1
	GHDRB	H$DISP,HDSP,1
	GHDRB	H$DDSV,$ODTV,3
	GHDRB	H$DDUC,$TKUIC,1
	GHDRB	H$DUIC,$TKUIC,1
	GHDRB	H$DSIZ,HDSIZ,1
	GHDRB	H$DFZI,$FSIZI,1
	GHDRB	H$DLUT,$NUNIT,1

	.IFF

	GHDRB	H$EFLM,$IDENT,2
	GHDRB	H$FSR,$HFSR,1
	GHDRB	H$FOT,$HOTV,1
	GHDRB	H$OVLY,$HOVLY,1
	GHDRB	H$VEXT,$HEXT,1
	GHDRB	H$WND,WNADR,1
	GHDRB	H$DSIZ,HDSIZ,1
	GHDRB	H$IPS,HDPS,1
	GHDRB	H$IPC,HDPC,1
	GHDRB	H$ISP,HDSP,1
	GHDRB	H$ODVA,$ODTV,2
	GHDRB	H$TKVA,$TSKV,2
	GHDRB	H$FPSA,HDFLP,1
	GHDRB	H$DUIC,$TKUIC,1
	GHDRB	H$CUIC,$TKUIC,1
	GHDRB	H$NLUN,$NUNIT,1
	GHDRB	H$GARD,HGARD,1
	GHDRB	RGSAV+1,HDR0,6
	GHDRB	WNDPT+1,$MXWND,1
;
; STACK BLOCK TABLE
;

	.PSECT	HDRTBL,RO,D
HDRSP4:	.WORD	0		; DUMMY ZERO WORD AT START OF TABLE
	IMPURE			; READ/WRITE D-SPACE

	GHDRB	SPSAV+1,SPR4,2

	.ENDC


;
; LABEL BLOCK TABLE
;

	.PSECT	LBLTBL,RO,D
LBLBAS:	.WORD	0		; DUMMY ZERO WORD AT START OF TABLE
	IMPURE			; READ/WRITE D-SPACE

	.IF	NDF	R$$11M

	GLBLB	L$BTSK,$TNAME,2
	GLBLB	L$BPAR,$PNAME,2
	GLBLB	L$BFLG,HDSWT,1
	GLBLB	L$BPRI,$PRIOR,1
	GLBLB	L$BLDZ,HDLDZ,1
	GLBLB	L$BMXZ,HDMXZ,1
	GLBLB	L$BPOL,$POOL,1
	GLBLB	L$BPIC,HDPIC,1
	GLBLB	L$BDAT,HDDAT,3

	.IFF

	GLBLB	L$BTSK,$TNAME,2
	GLBLB	L$BPAR,$PNAME,2
	GLBLB	L$BFLG,HDSWT,1
	GLBLB	L$BLDZ,HDLDZ,1
	GLBLB	L$BMXZ,HDMXZ,1
	GLBLB	L$BSA,$OFFST,1
	GLBLB	L$BDAT,HDDAT,3
	GLBLB	L$BHGV,HVRT0,1
	GLBLB	L$BMXV,HVRTL,1
	GLBLB	L$BWND,NUMWN,1
	GLBLB	L$BSEG,$SZSEG,1
	GLBLB	L$BOFF,$LBOFF,1
	GLBLB	L$BFL2,HDSW2,1
	GLBLB	L$BLRL,LBREV,1

	.PSECT	LBVTBL,RO,D
LBVBAS:	.WORD	0		; DUMMY ZERO WORD AT START OF TABLE
	IMPURE			; READ/WRITE D-SPACE

	GLBLV	L$BPRI,$PRIOR,1
	GLBLV	L$BHRB,$HDRBN,1
	GLBLV	L$BBLK,$LBBLK,1
	GLBLV	L$BXFR,HDPC,1
	GLBLV	L$BEXT,$LBEXT,1
	GLBLV	L$BLUN,$NUNIT,1
	GLBLV	L$BSGL,$LBSGL,1
	GLBLV	L$BROB,$ROBLK,1
	GLBLV	L$BROL,ROLDZ,1
	GLBLV	L$BRDL,RODLZ,1
	GLBLV	L$BHDB,$DHDRB,1
	GLBLV	L$BDHV,HDVRT1,1
	GLBLV	L$BDMV,HDVRTL,1
	GLBLV	L$BDLZ,HDDLDZ,1
	GLBLV	L$BDMZ,HDDMXZ,1
	GLBLV	L$BAPR,$APRDM,1

	.ENDC

;
; MISC HEADER VALUES-AJACENCY ASSUMED
;
	IMPURE			; READ/WRITE D-SPACE

HDDAT:	.BLKW	3		;CREATION DATE
	.IIF NDF R$$11M, HDPIC:	.BLKW	1	; POSITION INDEPENDANT FLAG
HDFLP:	.BLKW	1		;FLOATING POINT SAVE AREA POINTER

	.IF	DF	R$$11M

HDSIZ:	.BLKW	1		; HEADER SIZE IN BYTES

	.ENDC

SPR4:	.BLKW	1		; INITIAL R4 FOR STACK INITIALIZATION
HDR0:	.BLKW	6		; INITIAL R0 - R5
HDPC:	.BLKW	1		;PC WORD
HDPS:	.BLKW	1		;PS WORD
HDSP:	.BLKW	1		;INITIAL SP CONTENTS
HDLDZ:	.BLKW	1		;LOAD SIZE IN 32W BLOCKS
HDMXZ:	.BLKW	1		;MAX SIZE IN 32W BLOCKS
ROLDZ:	.BLKW	1		; LOAD SIZE OF READ ONLY SEGMENTS
RODLZ:	.BLKW	1		; LOAD SIZE OF R/O DATA SEGMENT
HDSWT:	.BLKW	1		;TASK FLAG WORD

	.IF	NDF	R$$11M

HDSIZ:	.BLKW	1		;HEADER SIZE IN 32W BLOCKS

	.IFF

HGARD:	.BLKW	1		; ADDRESS OF STACK GUARD WORD
RGSAV:	.BLKW	1		; ADDRESS OF REGISTER SAVE AREA
HVRTL:	.BLKW	1		; HIGH VIRTUAL ADDRESS OF TASK
HVRT0:	.BLKW	1		; HIGH VIRTUAL ADDRESS OF WINDOW 0
WNADR:	.BLKW	1		; ADDRESS OF WINDOW BLOCKS
WNDPT:	.BLKW	1		; OFFSET TO WINDOW BLOCKS
SPSAV:	.BLKW	1		; ADDRESS OF R4 IN TASK'S STACK
NUMWN:	.BLKW	1		; NUMBER OF WINDOWS AND SYSTEM IDENTIFICATION

ADDIN:	.BLKW	1		; VALUE TO BE ADDED TO LABEL BLK ADDRESS
HDDLDZ:	.BLKW	1		; DATA LOAD SIZE IN 32W BLOCKS
HDDMXZ:	.BLKW	1		; DATA MAX SIZE IN 32W BLOCKS
HDVRTL:	.BLKW	1		; HIGH VIRTUAL ADDRESS OF DATA
HDVRT1:	.BLKW	1		; HIGH VIRTUAL ADDRESS OF WINDOW 1 (DATA)

HDSW2:	.BLKW	1		; SECOND HEADER FLAGS WORD
LBREV:	.WORD	LB$REV		; HEADER REVISION LEVEL

	.ENDC

;
; **-$HEADR-WRITE TASK IMAGE FILE HEADER
;
; THIS ROUTINE IS CALLED TO WRITE THE TASK HEADER INTO THE TASK IMAGE.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	TASK HEADER IS WRITTEN INTO THE TASK IMAGE FILE.
;-
	PURE.I			; READ-ONLY I-SPACE

$HEADR::			;
	SAVRG			; SAVE THE NON-VOLATILE REGISTERS
	CLR	$WRFLG		; SET UP DESCRIPTOR FLAGS
	CLR	R0		; CLEAR ADDRESS BIAS
	BIT	#MP$SY,$SWTCH	; MAPPED SYSTEM?
	BNE	20$		; IF NE YES
	MOV	$OFFST,R0	; SET ADDRESS BIAS
20$:				;
	MOV	R0,HGARD	; SET ADDRESS BIAS OF GUARD WORD
	MOV	R0,WNADR	; SET WINDOW BLOCK ADDRESS BIAS
	MOV	$TSKPT,R5	;GET TASK IMAGE FILE RECORD BLOCK
	MOV	R$SWTH(R5),R5	;GET FILE SWITCH WORD

;
; PROCESS BIT TRANSFORMATION TABLE
;

HEADR0:	MOV	#HDSWT,R4	;GET ADDRESS OF HEADER SWITCH WORD
	MOV	#TS$NEW,(R4)	;SET INITIAL FLAG WORD
	MOV	#BITBAS,R3	;GET ADDRESS OF BIT TABLE
10$:	MOV	(R3)+,R2	;GET MSK1
	BEQ	HEADR1		;IF EQ DONE
	MOV	(R3)+,R1	;GET MSK2
	BIT	R2,R5		;BIT SET?
	BEQ	10$		;IF EQ NO
	BIS	R1,(R4)		;SET BIT IN FLAG WORD
	BR	10$		;

;
; ALLOCATE PAR/PDR REGISTERS
;

HEADR1:				;++013
	TST	$TSKWD		; TASK HAVE RESIDENT OVERLAYS?
	BEQ	5$		; IF EQ, NO
	BIT	#EX$MRT,$SWOV2	; ALLOW TASK W/MR OVERLAYS TO EXTEND?
	BNE	5$		; IF NE, YES, SO NO TS$RES SO EXEC'LL ALLOW THIS
	BIS	#TS$RES,(R4)	; SET TASK ATTRIBUTE
5$:				;
	TST	$CMPRT		; BUILDING SUPERVISOR MODE LIBRARY?
	BEQ	7$		; IF EQ NO
	BIS	#TS$SUP,(R4)	; SET TASK ATTRIBUTE
7$:
	BIT	#IO$PAG,$SWOVR	; OVERMAPPING THE IO PAGE?
	BEQ	8$		; IF EQ NO
	BIS	#TS$IOP,(R4)	; SET TASK ATTRIBUTE
8$:
	BIT	#XH$DR,$SWTCH	; EXTERNAL HEADER REQUESTED?
	BEQ	11$
	BIS	#TS$XHR,(R4)	; SET TASK ATTRIBUTE
11$:	BIT	#NO$XH,$SWOVR	; NO EXTERNAL HEADER EXPLICITLY REQUESTED ?
	BEQ	12$		; IF EQ, NO
	BIS	#TS$NXH,(R4)	; SET TASK ATTRIBUTE
12$:
	BIT	#ID$ATA,$SWTCH	; WE DOING AN I/D TASKBUILD?
	BEQ	120$		; IF EQ, NO...
	MOV	$HDVRT,R0	; GET D-SPACE HIGH VIRTUAL ADDRESS
	ADD	$OFFST,R0	; ADD IN BASE ADDRESS OFFSET
	BCS	10$		; IF CARRY SET, OVERFLOW....ERROR
	CMP	R0,$HGHAD+2	; TASK D-SPACE ADDRESS WITHIN LIMITS?
	BLOS	120$		; IF LOWER OR SAME, IT'S WITHIN D-SPACE LIMITS
	BR	10$		; IF HIGHER, FLAG THE ERROR CONDITION
120$:				; D-SPACE IS WITHIN LIMITS, CHECK I-SPACE
	MOV	$HVRTL,R0	; GET HIGH VIRTUAL ADDRESS
	ADD	$OFFST,R0	;++041 ADD BASE ADDRESS OFFSET
	.IIF   DF  R$$11M, BCS	10$		; OVERFLOW IF CS
	CMP	R0,$HGHAD	;TASK WITHIN LIMITS?
	.IIF NDF  R$$11M, BLOS	35$		; IF LOS - YES
	.IIF  DF  R$$11M,	BLOS	15$		; IF LOS - YES
10$:				;
	MOV	#$OUTBF,R2	;POINT TO DUMMY BUFFER AREA
	MOV	#<S$V0*400!E$R34>,R1 ; GET ERROR/SEVERITY
	CALL	CANTSK		; ISSUE ERROR MESSAGE, CANCEL TASK FILE


15$:	MOV	R5,-(SP)	;SAVE OLD VALUE OF SWITCH WORD
	MOV	#HDSW2,R4	;GET ADDRESS OF HEADER SWITCH WORD
	CLR	(R4)		;SET INITIAL FLAG WORD
	MOV	#BT2BAS,R3	;GET ADDRESS OF BIT TABLE
	MOV	$SWOVR,R5	;GET SWITCH WORD
16$:	MOV	(R3)+,R2	;GET MSK1
	BEQ	17$		;IF EQ DONE
	MOV	(R3)+,R1	;GET MSK2
	BIT	R2,R5		;BIT SET?
	BEQ	16$		;IF EQ NO
	BIS	R1,(R4)		;SET BIT IN FLAG WORD
	BR	16$		;
17$:	TST	$TSKWD		;TASK HAVE MEMORY RESIDENT OVERLAYS?
	BEQ	18$		; IF EQ, NO
	BIS	#T2$MRO,(R4)	; SET BIT FOR VAX-11 RSX TO TEST
18$:	MOV	(SP)+,R5	;RESTORE OLD SWITCH VALUE (USED LATER)

	.IF	NDF	R$$11M

35$:	CALL	GTRT		; GET REAL ADDRESS OF ROOT
	MOV	R0,R3		; COPY REAL ADDRESS
	MOV	$HDSIZ,(R4)	;SET HEADER SIZE IN BYTES
	CALL	BLOCKS		;CALCULATE NUMBER OF 32W BLOCKS
	MOV	-(R4),R4	;SET INITIAL BLOCK OFFSET VALUE
	MOV	$OFFST,R0	;GET OFFSET BIAS
	MOV	#206,R1		;SET ACCESS CODE
	TST	S$GRO(R3)	;ANY RO AREA?
	BEQ	50$		;IF EQ NO
	MOV	S$GRW(R3),R2	;GET LENGTH OF RW AREA
	SUB	$HDSIZ,R2	;SUBTRACT OUT SIZE OF HEADER
	BEQ	40$		;IF EQ NO RW AREA
	ADD	R0,R2		;CALCULATE ENDING ADDRESS
	MOV	R2,-(SP)	;SAVE ENDING ADDRESS
	CALL	FLAPR		;FILL APR REGISTERS
	MOV	(SP)+,R0	;RETRIEVE ENDING ADDRESS
	ADD	#17777,R0	;ROUND TO NEXT 4K BOUNDRY
	BIC	#17777,R0	;CLEAR EXCESS BITS
40$:				;
	MOV	R0,-(SP)	; SAVE R0
	CALL	GTRT		; GET ADDRESS OF ROOT IN R0
	MOV	R0,R3		; COPY ADDRESS
	MOV	(SP)+,R0	; RESTORE R0
	MOV	#202,R1		; SET ACCESS CODE
	MOV	S$GRO(R3),R2	;GET LENGTH OF RO AREA
	ADD	R0,R2		;CALCULATE ENDING ADDRESS
	MOV	R2,-(SP)	;SAVE ENDING ADDRESS
	CALL	FLAPR		;FILL APR REGISTERS
	MOV	(SP)+,R0	;RETRIEVE ENDING ADDRESS
	CMP	#1,$NUMSG	;MORE THAN ONE SEGMENT?
	BEQ	HEADR2		;IF EQ NO
	ADD	#17777,R0	;ROUND TO NEXT 4K BOUNDRY
	BIC	#17777,R0	;CLEAR EXCESS BITS
50$:	MOV	$HVRTL,R2	;GET HIGHEST VIRTUAL ADDRESS
	ADD	$OFFST,R2	;ADD IN OFFSET BIAS
	CMP	R0,R2		;ANYTHING IN SEGMENT?
	BEQ	HEADR2		;IF EQ NO
	MOV	#206,R1		;SET ACCESS CODE
	CALL	FLAPR		;FILL APR REGISTERS


	.ENDC

;
; SET UP REMAINING HEADER WORDS
;

HEADR2:				; REF LABEL

	.IF	DF	R$$11M

	MOV	R0,HVRTL	; SAVE HIGH VIRTUAL ADDRESS BOUND
	MOV	$HVRT0,R0	; GET ADDRESS 0 LIMIT
	ADD	$OFFST,R0	; ADD TASK OFFSET
	MOV	R0,HVRT0	; SAVE LIMIT
	CMP	R0,HVRTL	; LESS THAN WINDOW 0 LIMIT?
	BLOS	3$		; IF LOS NO
	MOV	R0,HVRTL	; RESET LIMIT
3$:				;
	BIT	#LI$BRY,$SWOVR	; ARE WE BUILDING A LIBRARY?
	BEQ	300$		; IF EQ, NO...
	BIT	#EX$LIB,$SWOVR	; IF NE, YES...DO WE WANT TO 'EXTEND' IT?
	BEQ	300$		; IF EQ, NO...
	MOV	$HGHAD,HVRTL	; IF NE, YES...SET HIGH ADDRESS BOUND
300$:
	BIT	#ID$ATA,$SWTCH	; IS THIS AN I & D TASK?
	BEQ	4$		; IF EQ, NO
	MOV	$HDVRT,R0	; GET DATA HIGH VIRTUAL ADDRESS
	ADD	$OFFST,R0	; INCLUDE TASK OFFSET
	MOV	R0,HDVRTL	; SET DATA HIGH VIRTUAL ADDRESS
	MOV	$HDVR1,HDVRT1	; GET DATA HIGH VIRTUAL ADDRESS, WINDOW 1
	ADD	$OFFST,HDVRT1	; ADD IN THE TASK OFFSET BIAS
4$:

	.ENDC

	GTIM$S	#HDDAT		; GET TIME PARAMETERS

	.IF	NDF	R$$11M

	MOV	#HDPIC,R4	;GET ADDRESS OF MISC DATA AREA
	CLR	(R4)+		;ASSUME NOT POSITION INDEPENDENT
	BIT	#SW$PI,R5	;POSITION INDEPENDENT?
	BEQ	5$		;IF EQ NO
	INC	-2(R4)		;SET PIC FLAG

	.IFF

	MOV	#HDFLP,R4	;  GET ADDRESS OF MISC DATA AREA

	.IFTF

5$:	CLR	(R4)+		;ASSUME NO FLOATING POINT

	.IFT

	BIT	#SW$FP,R5	;FLOATING POINT SPECIFIED?
	BEQ	10$		;IF EQ NO
	MOV	$NUNIT,R0	;GET NUMBER OF LOGICAL UNITS
	ASL	R0		;MULTIPLY BY 4
	ASL	R0		;
	ADD	#<H$DLUT-H$DFLP+2>,R0 ; COMPUTE POINTER TO FLOATING POINT SAVE
	MOV	R0,-2(R4)	;SET POINTER TO FLOATING POINT SAVE AREA

	.IFF

	MOV	$NUNIT,R0	; FETCH NO. OF UNITS
	ASL	R0		; COMPUTE SIZE OF LUN TABLE
	ASL	R0		;
	ADD	#<H$LUN-H$CSP>,R0 ; COMPUTE OFFSET TO WINDOW BLOCKS
	MOV	R0,WNDPT	; SAVE OFFSET TO WINDOW BLOCKS
	ADD	R0,WNADR	; COMPUTE ADDRESS OF WINDOW BLOCKS
	MOV	$NUMWN,R0	; GET NUMBER OF TASK WINDOWS
	MOV	#$MXWND,R1	; POINT TO MAX WINDOWS
	ADD	R0,(R1)		; COMPUTE MAX WINDOWS
	MOV	(R1),R1		; GET RESULT
	CMP	R1,#8.		; HAVE LEGAL VALUE?
	BLOS	6$		; IF LOS YES
	CMP	#4,$SYSTM	; M+ TASK BUILD?
	BNE	500$		; IF NE NO
	CMP	R1,#W$NDWS	; HAVE ILLEGAL VALUE?
	BLOS	6$		; IF LOS YES
500$:
	MOV	#<S$V0*400!E$R86>,R1 ; GET ERROR/SEVERITY
	CALL	CANTSK		; ISSUE ERROR MESSAGE, CANCEL TASK FILE
	MOV	$MXWND,R1	; RESTORE MAX. WINDOWS
6$:				;
	MOV	#S$ZWND,R0	; GET SIZE OF EACH WINDOW BLOCK

	.IF	DF	V1145

	MUL	R0,R1		; COMPUTE WINDOW BLOCK ALLOCATION

	.IFF

	CALL	$MUL		; COMPUTE WINDOW BLOCK ALLOCATION

	.ENDC

	ADD	#2+4,R1		; INCLUDE SPACE FOR WINDOW COUNT PLUS PS,PC
	ADD	WNDPT,R1	; COMPUTE OFFSET TO REGISTER SAVE AREA
	MOV	R1,RGSAV	; SAVE OFFSET
	ADD	#14,R1		; COMPUTE GUARD WORD OFFSET
	ADD	R1,HGARD	; SAVE OFFSET
	ADD	#2,R1		; STEP PAST GUARD
	BIT	#<SW$FP!SW$EA>,R5 ; EAE OR FLOATING POINT SPECIFIED?
	BEQ	10$		; IF EQ NO
	MOV	R1,-(R4)	; SET OFFSET TO FLOATING PT., EAE
	BIT	#MP$SY,$SWTCH	; SYSTEM MAPPED?
	BEQ	7$		; IF EQ NO
	ADD	#140000,(R4)+	; BIAS ADDRESS RELATIVE TO APR 6
	BR	10$		;
7$:				;
	ADD	$OFFST,(R4)+	; CONVERT TO ADDRESS

	.IFT

10$:	CLR	(R4)+		;ASSUME ODT NOT SPECIFIED
	CLR	(R4)+		;
	CLR	(R4)+		;
	MOV	$IDENT,(R4)+	; SETUP IDENT
	MOV	$IDENT+2,(R4)+	;
	CLR	(R4)+		; CLEAR INITIAL R5

	.IFF

10$:				;
	MOV	R1,(R4)+	; SET SIZE OF HEADER
	MOV	$IDENT+2,(R4)+	; SET UP R4 FOR STACK INITIALIZATION
	MOV	$HDRBN,(R4)+
	MOV	$IDENT+2,(R4)+	; SETUP IDENT IN INITIAL R3 - R4
	MOV	$IDENT,(R4)+	;
	CLR	(R4)+		; ASSUME ODT NOT SPECIFIED, CLEAR R2 - R0
	CLR	(R4)+		;
	CLR	(R4)+		;

	.ENDC

	MOV	$XFRAD,(R4)+	;SET TASK TRANSFER ADDRESS
	CMP	#1,$ODTAD	;ODT SPECIFIED?
	BEQ	20$		;IF EQ NO

	.IF	NDF	R$$11M

	MOV	#HDR0,R4	; BACKUP TO INITIAL R0
	MOV	$XFRAD,(R4)+	;PROGRAM XFR ADDRESS GOES IN R0
	MOV	$TNAME,(R4)+	;TASK NAME IN R1 AND R2
	MOV	$TNAME+2,(R4)+	;

	.IFF

	MOV	#HDR0+6,R4	; POINT TO INITIAL R2
	MOV	$TNAME+2,(R4)+	; TASK NAME TO INITIAL R2 - R1
	MOV	$TNAME,(R4)+	;
	MOV	$XFRAD,(R4)+	; TRANSFER ADDRESS GOES IN R0

	.ENDC

	MOV	#HDPC,R4	; POINT TO INITIAL PC
	MOV	$ODTAD,(R4)+	;SET TRANSFER ADDRESS TO DEBUGGING AID
20$:	MOV	#174017,(R4)+	;SET INITIAL PS WORD
	BIT	#SW$TR,R5	;T BIT REQUESTED?
	BEQ	30$		;IF EQ NO
	BIS	#20,-2(R4)	;SET T BIT IN PS WORD
30$:				; REF. LABEL

	.IF	DF	R$$11M

	MOV	$STACK,(R4)	; SET INITIAL SP CONTENTS
	ADD	$HDSIZ,(R4)	; ADD HEADER BIAS
	MOV	(R4),SPSAV	; GET STACK POINTER
	SUB	#10,SPSAV	; POINT TO TENTH WORD IN STACK
	ADD	$OFFST,(R4)+	; ADD IN OFFSET BIAS
35$:
	CALL	GTRT		; GET REAL ADDRESS OF ROOT
	MOV	S$GLNG(R0),(R4)	; SET LOAD SIZE IN BYTES
	CALL	BLOCKS		; ROUND TO 32 W BOUNDRY

	.IFF

	MOV	$STACK,(R4)	; SET INITIAL STACK POINTER CONTENTS
	ADD	$OFFST,(R4)+	; ADD IN OFFSET BIAS
	CALL	GTRT		; GET REAL ADDRESS OF ROOT
	MOV	S$GMEM(R0),(R4)	;SET SIZE OF ROOT IN BYTES
	CALL	BLOCKS		;CALCULATE NUMBER OF 32W BLOCKS

	.IFTF

 	MOV	$MXLGH,(R4)+	; SET MAX. PHYSICAL MEMORY

	.IFT

	MOV	$MXLGH+2,(R4)	; SET MAX. R-O PHYSICAL MEMORY
	BIT #SW$MU,R5		; MULTIUSER?
	BEQ	355$		; IF EQ NO
	MOV	#4,$SYSTM	; MARK AS M-PLUS TASK
	MOV	$MXLGH+4,2(R4)	; SET R/O DATA LOAD SIZE
	BR	36$		;
355$:

	.IFTF

	ADD	$MXLGH+2,-2(R4) ; INCLUDE R-O ALLOCATION
	CLR	(R4)		; ZERO R-O PHYSICAL MEMORY
36$:
	MOV	#HDDLDZ,R4	; GET ADDRESS OF HIGH DATA VIRTUAL ADDR
	BIT	#ID$ATA,$SWTCH	; BUILDING AN I/D TASK
	BEQ	37$		; IF EQ, NO...CONVENTIONAL
	MOV	S$GDLN(R0),(R4)	; GET D-SPACE LOAD LENGTH
	CALL	BLOCKS		; CONVERT TO 64-BYTE BLOCKS
	MOV	$MXLGH+6,(R4)+	; SET THE MAX D-SPACE BLOCK REQUIREMENT
37$:
	MOVB	$NUMWN,NUMWN	; SET NUMBER OF WINDOWS
	MOVB	$SYSTM,NUMWN+1	; SET SYSTEM ID

	.IFF

	MOV	#$ODTV,R4	;GET ADDRESS OF ODT SST VECTOR
	MOV	R4,R1		;SET SYMBOL ADDRESS FOR SEARCH
	CALL	GTSYM		;GET SYMBOL VALUE
	MOV	R0,(R4)+	;SET ODT VECTOR ADDRESS
	BCC	40$		;IF CC DEFINITION FOUND
	CLRB	$ODTSZ		;CLEAR SIZE OF ODT VECTOR
40$:	MOV	#$TSKV,R1	;GET ADDRESS OF TSK VECTOR
	CALL	GTSYM		;GET SYMBOL VALUE
	MOV	R0,(R4)		;SET TSK VECTOR ADDRESS
	BCC	HEADR3		;IF CC DEFINITION FOUND
	CLRB	$TSKSZ		;CLEAR SIZE OF TSK VECTOR


	.IFT

	MOV	#HEADR3,-(SP)	; PUSH ADDRESS OF NEXT ROUTINE
	MOV	#$ODTV,R4	; GET ADDRESS OF ODT SST VECTOR
	CALL	40$		; SETUP ODT VECTOR
	MOV	#$TSKV,R4	; GET ADDRESS OF TASK SST VECTOR
40$:
	MOV	R4,R1	;	; COPY ADDRESS OF SYMBOL FOR SEARCH
	CALL	GTSYM		; SEARCH FOR SYMBOL VALUE
	MOV	R0,(R4)+	; SET VALUE
	MOV	R0,(R4)+	; CLEARS VECTOR SIZE IF NOT FOUND
	BCS	50$		; EXIT IF NOT FOUND
	MOV	(R4),-(R4)	; ELSE SET VECTOR  SIZE
	ASL	(R4)		; CONVERT TO BYTES
50$:
	RETURN			; EXIT TO CALLER OR NEXT ROUTINE

	.ENDC

;
; WRITE FIXED PART OF HEADER
;

HEADR3:				; REF LABEL
	BIT	#TS$KF,$SWTCH	; TASK IMAGE FILE REQUESTED?
	BEQ	60$		; IF EQ NO
	MOV	#HEADR4,-(SP)	; PUSH ADDRESS OF NEXT ROUTINE
	CLR	$BEGRW		; SET LOW MEMORY LIMIT

	.IF	DF	R$$11M

	CLR	$LOWRW		; CLEAR LOW R/W ADDRESS LIMIT

	.ENDC

	MOV	$HDSIZ,R0	; GET SIZE OF HEADER

	.IF	NDF	R$$11M

	SUB	$LBLSZ,R0	; OFFSET TO START OF HEADER
	CLR	$HDOFF		; CLEAR HEADER OFFSET

	.IFF

	BEQ	20$		; SKIP HEADER WRITE IF ZERO

	.ENDC

	MOV	#HDRBAS,R5	; GET BASE ADDRESS OF HEADER BLOCK TABLE
	DEC	R0		; BACK OFF TO REAL END  OF HEADER
	MOV	R0,$ENDRW	; SET MEMORY LIMITS
	MOV	$HDRBN,$RLBLK	; SET RELATIVE BLOCK NUMBER
	CLR 	ADDIN
	CALL	30$		; WRITE TASK HEADER
	CALL	$FLUSH		; OUTPUT BUFFER CONTENTS.
;
;
; WRITE A SECOND COPY OF THE HEADER INTO THE DATA PORTION OF THE TASK
; IMAGE IF THIS IS AN /ID TASK. THE STACK ALSO GOES INTO DATA SPACE IN
; /ID TASKS.
;
;
	BIT	#ID$ATA,$SWTCH	; /ID TASK?
	BEQ	10$		; IF EQ NO
	MOV	#4,$SYSTM	; MARK AS M-PLUS TASK
	MOVB	#4,NUMWN+1	; SET THE M-PLUS MARKER HERE TOO.
	MOV	#HDRBAS,R5	; GET BASE ADDR OF HEADER BLOCK TABLE
	MOV	$DHDRB,$RLBLK	; SET RELATIVE BLOCK NUMBER OF DATA HEADER
	CLR	ADDIN		;
	CALL	30$		; WRITE DATA'S COPY OF THE TASK'S HEADER
	CALL	$FLUSH		; OUTPUT BUFFER CONTENTS

10$:

	.IF DF	R$$11M

	TST	$STACK		; TASK HAVE STACK?
	BEQ	20$		; IF EQ NO
	MOV	#HDRSP4,R5	; GET ADDRESS OF REGISTER TABLE
	MOV	SPSAV,$ENDRW	; GET STACK ADDRESS
	ADD	#10,$ENDRW	; SET MEMORY LIMITS
	CLR	ADDIN		; ZERO VALUE TO BE ADDED IN
	CALL	30$		; WRITE R4 AND R5 INTO TASK'S STACK
	CALL	$FLUSH		; OUTPUT BUFFER CONTENTS

	.ENDC
20$:
	MOV	$LBOFF,-(SP)	; SAVE REAL TASK OFFSET (IN CASE EX$MRT SET)
	BIT	#EX$MRT,$SWOV2	; MR OVERLAYS SHIFTED UP SO TASK CAN EXTEND?
	BEQ	25$		; IF EQ, NO 
	MOV	LBOFF,$LBOFF	; WRITE OUT SHIFTED TASK OFFSET
25$:
	MOV	#LBLBAS,R5	; GET BASE ADDRESS OF LABEL BLOCK TABLE
	MOV	$LBLSZ,$ENDRW	; SET ADDRESS LIMIT
	DEC	$ENDRW		; BACK OFF TO REAL END
	CLR	$RLBLK		; CLEAR RELATIVE BLOCK NUMBER
	CLR	ADDIN		; ZERO VALUE TO BE ADDED TO LABEL BLOCK
	CALL	30$
	MOV	(SP)+,$LBOFF	; RESTORE $LBOFF	

	MOV	#LBVBAS,R5	; GET BASE ADRRESS OF FLOATING PART OF LABEL BLK
	CLR	ADDIN		; ASSUME NOT M+ TASK BUILD
	CMP	#4,$SYSTM	; M+ TASK BUILD
	BNE	40$		; IF NE	NO
	MOV	#$LBXL,ADDIN	; SET EXTRA LENGTH IN LABEL BLK
	BR	40$		;
30$:				; REF LABEL
	CLR	$BFFLG		; SET BUFFER FLAG TO FALSE
40$:				; REF LABEL
	MOV	(R5)+,R3	; GET ADDRESS OF TEXT INFORMATION
	BEQ	60$		; IF EQ DONE
	MOV	(R5)+,R4	; GET ADDRESS IN HEADER
	BIT	#1,R4		; SEE IF INDIRECT ADDRESS SPECIFIED
	BEQ	45$		; IF EQ NO
	BIC	#1,R4		; YES, CLEAR INDIRECT BIT
	MOV	(R4),R4		; GET REAL ADDRESS
45$:
	MOV	(R5)+,-(SP)	;SET LOOP COUNT
50$:
	ADD	ADDIN,R4
	MOV	(R3)+,R1	; SET WORD TO BE WRITTEN
	MOV	R4,R0		;SET VIRTUAL ADDRESS OF WORD
	CALL	$WRWRD		;WRITE WORD INTO HEADER
	ADD	#2,R4		;UPDATE VIRTUAL ADDRESS
	DEC	(SP)		;DECREMENT LOOP COUNT
	BGT	50$		; IF GT GO AGAIN
	TST	(SP)+		;CLEAN STACK
	BR	40$		; GO AGAIN
60$:
	RETURN

;
; WRITE LUN ASSIGNMENTS
;

HEADR4:	MOV	#$LUNHD,R5	;GET ADDRESS OF ASSIGNMENT LISTHEAD
10$:	MOV	(R5),R5		;GET ADDRESS OF NEXT ASSIGNMENT
	BEQ	HEADR5		;IF EQ DONE
	MOV	R5,R3		;COPY ENTRY ADDRESS
	MOV	R5,-(SP)	;SAVE ENTRY ADDRESS
	TST	(R3)+		;POINT TO DEVICE NAME
	MOV	(R3)+,R5	;GET DEVICE NAME
	CLR	R4		; TO PREVENT 'OR-ING' OF THE UNIT NUMBERS
	BISB	(R3)+,R4	; GET PHYSICAL UNIT NUMBER
	CLR	-(SP)		;CLEAR WORD ON STACK
	BISB	(R3)+,(SP)	;SET LOOP COUNT
20$:	MOV	(R3)+,R0	;GET LUN NUMBER
	ASL	R0		;MULTIPLY BY 4
	ASL	R0		;
	ADD	#L$BASG-4,R0	;CALCULATE ADDRESS IN LABEL BLOCK
	MOV	R0,-(SP)	;SAVE ADDRESS IN LABEL BLOCK
	MOV	R5,R1		;SET WORD TO BE WRITTEN
	CALL	$WRWRD		;WRITE DEVICE NAME INTO LABEL BLOCK
	MOV	(SP)+,R0	;RETRIEVE ADDRESS IN LABEL BLOCK
	ADD	#2,R0		;POINT TO SECOND ASSIGNMENT WORD
	MOV	R4,R1		;SET WORD TO BE WRITTEN
	CALL	$WRWRD		;WRITE PHYSICAL UNIT INTO LABEL BLOCK
	DEC	(SP)		;DECREMENT LOOP COUNT
	BGT	20$		;IF GT GO AGAIN
	TST	(SP)+		;CLEAN STACK
	MOV	(SP)+,R5	;RETRIEVE ADDRESS OF NEXT ENTRY
	BR	10$		;

;
; WRITE LIBRARY LIST INTO LABEL BLOCK
;

HEADR5:				;
	MOV	#$LBRHD-L$DNXT,R5 ; GET LISTHEAD ADDRESS MINUS OFFSET
	MOV	#L$BLIB,R4	; SET OFFSET TO LIBRARY LIST
	.IF	DF,R$RSTS	;++RSTS V8.0					;TWH001
	MOV	#$TKRTS,R3	;++RSTS V8.0 	GET POINTER TO HISEG NAME	;TWH001
	TST	(R3)		;++RSTS V8.0	ANTHING THERE?			;TWH001
	BNE	5$		;++RSTS V8.0	YES, USE IT			;TWH001
	MOV	#XRB+12,R3	;++RSTS V8.0	NO, POINT TTO RTS NAME IN XRB	;TWH001
	.DATE			;++RSTS V8.0	AND GET CURRENT RTS NAME	;TWH001
	CMP	(R3),#^R...	;++RSTS V8.0	NAME START WITH DOTS?		;TWH001
	BNE	5$		;++RSTS V8.0	NOPE USE IT			;TWH001
	MOV	2(R3),(R3)	;++RSTS V8.0	YEP, MOVE UP THE REAL NAME	;TWH001
	CLR	2(R3)		;++RSTS V8.0	AND MAKE 3 CHARS		;TWH001
5$:	MOV	#FIRQB+FQFUN,R0	;++RSTS V8.0	POINT TO FIRQB			;TWH001
	MOVB	#UU.NAM,(R0)+	;++RSTS V8.0	FUNC CODE=NAME RTS		;TWH001
	MOVB	#7,(R0)+	;++RSTS V8.0	CHANNEL FOR TSK FILE		;TWH001
	.REPT	4		;++RSTS V8.0					;TWH001
	MOVB	(R3)+,(R0)+	;++RSTS V8.0	COPY THE HISEG NAME		;TWH001
	.ENDM			;++RSTS V8.0					;TWH001
	.UUO			;++RSTS V8.0	NAME THE RTS			;TWH001
	.ENDC			;++RSTS V8.0					;TWH001
10$:				;
	MOV	L$DNXT(R5),R5	; GET NEXT ENTRY
	BEQ	HEADR6		; IF EQ DONE
	.IF	DF,R$RSTS	;++RSTS V8.0					;REG001
	BIT	#LD$MRTS,L$DFLG(R5) ;++RSTS V8.0 MAKE INTO AN RTS?		;REG001
	BEQ	11$		;++RSTS V8.0     NO, SO CONTINUE		;REG001
	BIC	#LD$MRTS,L$DFLG(R5) ;++RSTS V8.0 YES SO FORGET THIS		;REG001
	BIS	#LD$RTS,L$DFLG(R5) ;++RSTS V8.0	 MAKE IT ONE			;REG001
11$:				;++RSTS V8.0					;REG001
	.ENDC			;++RSTS V8.0					;REG001

	BIC	#LD$RSV,L$DFLG(R5) ; CLEAR APR RESERVATION FLAG
	MOV	R5,R3		; COPY ADDRESS OF ENTRY
	ADD	#L$DNME,R3	; POINT TO NAME
	MOV	2(R3), -(SP)	; SAVE SECOND PART OF LIBRARY NAME REQUESTED
	BIT	#TS$NHD, HDSWT	; BUILDING TASK OR LIBRARY IMAGE?
	BNE	12$		; NE IS LIBRARY, DON'T FORCE FCSFSL TO FCSRES
	CMP	#^RFCS, (R3)	; IS REQUEST FOR FCS LIBRARY 
	BNE	12$		; NO, NO FORCE
	CMP	#^RFSL, 2(R3)	; IS FCS LIBRARY REQUESTED THE FSL VERSION?
	BNE	12$		; NO, LEAVE IT ALONE
	MOV	#^RRES, 2(R3)	; YES, FORCE IT TO MEAN "FCSRES"
12$:	MOV	#L$BLIB-L$BPAR/2,-(SP) ; SET SIZE OF ENTRY IN WORDS
20$:				;
	MOV	(R3)+,R1	; GET WORD TO BE WRITTEN
	MOV	R4,R0		; SET VIRTUAL ADDRESS TO WRITE DATA
	ADD	#2,R4		; UPDATE ADDRESS
	CALL	$WRWRD		; WRITE WORD INTO TASK IMAGE
	DEC	(SP)		; DECREMENT COUNT
	BNE	20$		; IF NE GO AGAIN
	INC	(SP)+		; CLEAN STACK
	MOV	R5,R3		; RESTORE ADDRESS OF..
	ADD	#L$DNME,R3	; ..LIBRARY NAME
	MOV	(SP)+, 2(R3)	; RESTORE SECOND HALF OF LIBRARY NAME
	BR	10$		; GET NEXT ENTRY

;
; WRITE SEGMENT LOAD LIST INTO LABEL BLOCK IF TASK IS
;
; HAS ONLY RESIDENT OVERLAYS. THE SEGMENT LOAD LIST IS USED
; BY 11S TO LOAD IN TASKS WITH RESIDENT OVERLAYS
;
;

HEADR6:				;
	CMP	$NUMSG,#1	; TASK HAVE OVERLAYS?
	BEQ	10$		; IF EQ NO
	TST	$TSKWD		; TASK HAVE RESIDENT OVERLAYS?
	BEQ	10$		; IF EQ NO
	BIT	#DS$KOV,$SWOVR 	; TASK HAVE DISK OVERLAYS?
	BNE	10$		; IF NE YES
	MOV	$LBLSZ,R0	; GET SIZE OF LABEL BLOCK GROUP
	SUB	#512.,R0	; BACK OFF TO START OF SEGMENT LIST
	MOV	R0,HDDAT	; SAVE SEGMENT LIST ADDRESS
	MOV	#HEADR7,R0	; SET ADDRESS OF PHASE DEPENDANT ROUTINE
	CALL	$PCTRL		; CALL PHASE DEPENDANT ROUTINE
10$:				;
	CALL	$FLUSH		; FLUSH CURRENT BUFFER
	RETURN			;

;
; PHASE DEPENDANT ROUTINE TO WRITE SEGMENT LENGTH LIST INTO TASK IMAGE
;

HEADR7:				;
	MOV	HDDAT,R0	; SET TASK ADDRESS
	MOV	$CRSEG,R2	; GET REAL ADDRESS OF SEGMENT
	MOV	S$GLNG(R2),R1	; GET LENGTH OF SEGMENT
	BEQ	10$		; IF EQ, ZERO LENGTH SEGMENT
	BITB	#SG$DSK,S$GSTS(R2) ; SEGMENT HAVE DISK ALLOCATION?
	BNE	10$		; IF NE NO
	ADD	#2,HDDAT	; UPDATE TASK ADDRESS
	CALL	$WRWRD		; WRITE LENGTH OF DISK READ INTO LABEL BLOCK
10$:				;
	RETURN			;

;
; SUBROUTINE TO SUBTRACT OUT SIZE OF LABEL BLOCK, ROUND TO NEXT
; 32W BOUNDRY, AND CALCULATE NUMBER OF RESULTANT 32W BLOCKS.
;

BLOCKS:

	.IF	NDF	R$$11M

	SUB	$LBLSZ,(R4)	; SUBTRACT OUT SIZE OF LABEL BLOCK

	.IFTF

	ADD	#77,(R4)	;ROUND UP TO NEXT 32W BOUNDRY
	BIC	#77,(R4)	;CLEAR EXCESS BITS
	ROR	(R4)		;PRESERVE POSSIBLE CARRY
	ROR	(R4)		;CONVERT TO 32W BLOCKS
	ROR	(R4)		;
	ROR	(R4)		;
	ROR	(R4)		;
	ROR	(R4)+		;
	RETURN			;

;
; ISSUE ERROR MESSAGE, CANCEL TASK IMAGE OUTPUT AND CLOSE TASK FILE
;

CANTSK:				;
	CALL	$ERMSG		; ISSUE NON-FATAL ERROR MESSAGE
	BIC	#TS$KF,$SWTCH	; CANCEL TASK IMAGE OUTPUT
	MOV	$TSKPT,R0	; GET ADDRESS OF FDB FOR TASK IMAGE FILE
	CALL	.TRNCL		; TRUNCATE AND CLOSE TASK IMAGE FILE
	RETURN			;



	.IFT


;
; SUBROUTINE TO FILL APR REGISTERS
;

FLAPR:	MOV	R1,-(SP)	;SAVE ACCESS CODE
	MOV	R0,R3		;COPY STARTING ADDRESS
	ASL	R3		;ISOLATE APR NUMBER
	ROL	R3		;
	ROL	R3		;
	ROL	R3		;
	ASL	R3		;CONVERT TO TABLE INDEX
10$:	MOV	(SP),$HDPDR(R3)	;SET PDR CONTENTS
	MOV	R4,$HDPAR(R3)	;SET ADDITIVE BLOCK NUMBER
	CLR	R1		;CLEAR 4K ADDRESS ACCUMULATOR
	CLR	R4		;CLEAR ADDITIVE BLOCK NUMBER
20$:				;++011
	INC	R1		;
	INC	R4		;INCREMENT ADDITIVE BLOCK COUNT
	ADD	#100,R0		;++011 INCREMENT TO NEXT 32 W BOUNDARY
	BCS	40$		;++011 EXIT IF CROSS 32 K WORD LIMIT.
	CMP	R0,R2		;DONE?
	BHIS	40$		;IF HIS YES
	CMP	R1,#200		;CROSS 4K BOUNDRY?
	BHIS	30$		;IF HIS YES
	ADD	#400,$HDPDR(R3)	;INCREMENT BLOCK LENGTH FIELD
	BR	20$		;
30$:	ADD	#2,R3		;ADVANCE TO NEXT APR
	BR	10$		;
40$:	TST	(SP)+		;CLEAN STACK
	RETURN			;

	.ENDC


;
; SUBROUTINE TO GET SYMBOL VALUE
;

GTSYM:	SUB	#S$YM,R1	;CALCULATE PROPER OFFSET
	CALL	GTRT		; GET REAL ADDRESS OF ROOT
	ADD	#S$GSTB,R0	;POINT TO SYMBOL TABLE
	CALL	$SRCH		;SEARCH FOR SYMBOL
	BCS	30$		;IF CS NO FIND EM
	MOV	R0,R1		;COPY ENTRY ADDRESS
	CLR	R0		;ASSUME DEFINITION NOT FOUND
	BITB	#SY$DEF,S$YFLG(R1);DEFINITION?
	SEC			;ASSUME NOT DEFINITION
	BEQ	30$		;IF EQ NOT A DEFINITION
	BITB	#SY$IND,S$YFLG(R1);INDIRECT ENTRY?
	BEQ	10$		;IF EQ NO
	MOV	S$YVAL(R1),R1	;GET ADDRESS OF REAL ENTRY
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	MOV	R0,R1		; COPY REAL ADDRESS
10$:	MOV	S$YVAL(R1),R0	;GET SYMBOL VALUE
	BITB	#SY$REL,S$YFLG(R1);RELOCATABLE SYMBOL?
	BEQ	20$		;IF EQ NO
	ADD	$OFFST,R0	;ADD OFFSET BIAS
20$:	CLC			;CLEAR CARRY
30$:	RETURN			;

;
; CONVERT VIRTUAL ADDRESS OF ROOT SEGMENT TO REAL ADDRESS IN R0.
;

GTRT:				;
	MOV	R1,-(SP)	; SAVE R1
	MOV	$RTSEG,R1	; GET VITUAL ADDRESS OF ROOT
	CALL	$CVRL		; CONVERT TO REAL ADDRESS IN R0
	MOV	(SP)+,R1	; RESTORE R1
	RETURN
	.END
