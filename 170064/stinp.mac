	.TITLE	STINP
	.IDENT	/14.02/
;
; COPYRIGHT (c) 1983 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE IS FURNISHED  UNDER A LICENSE AND MAY BE USED OR
; COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;
; D.N. CUTLER/C. MONIA	21-JAN-74
;
; MODIFIED FOR RSX-11M/M-PLUS V4.0/V2.0 BY:
;
;	J. A. KASSON
;	C. B. PETROVIC
;
; MODIFIED BY:
;
;	C. B. PETROVIC	10-FEB-82	14.01
;		CBP034		FIX GEARLOOSE CBP004, CHANGE THE
;				ADD TO A SUB AND POINT TO THE DATA
;				THAT IS MORE OR LESS GUARANTEED TO BE
;				IN THE TASKS ADDRESSING SPACE.
;
;	C.B. PETROVIC	26-FEB-82	14.02
; 		CBP039		ADD CORRECT .PSECT DEFINITIONS TO
;				ALLOW TKB TO BE LINKED AS AN I/D TASK.
;
;
; MACRO LIBRARY CALLS
;

	.MCALL	CLOSE$,GET$S,OFNB$R

;
; LOCAL DATA
;
	IMPURE			; READ/WRITE D-SPACE

BYPSW:	.BLKW	1		; BYPASS SELECTED FILES
OPSW:	.BLKW	1		; DO NOT OPEN FILES
OPEN:	.BLKB	1		; A FILE IS OPEN
REWND:	.BLKB	1		; DO NOT REWIND

;+
; **-$STELM-SETUP SEGMENT ELEMENT DESCRIPTORS
; **-$STIMP-SETUP INPUT FILE FOR MAP
; **-$STINP-SET UP INPUT FILE
;
; THESE ROUTINES ARE CALLED TO SET UP THE NEXT INPUT FILE FROM THE CUR-
; RENT ELEMENT LIST. THE FILE IS SET UP IN THE $INPPT RECORD BLOCK.
; THE ROUTINE IS A MONITOR DEPENDENT ROUTINE SINCE IT MUST KNOW THE
; FORMAT OF THE MONITOR DEPENDENT DATA IN THE ELEMENT DESCRIPTOR. THE
; CURRENT FILE IS CLOSED, THE NEXT FILE IN THE ELEMENT LIST IS OPEN-
; ED AND $NBYTE IS CLEARED. A COROUTINE CALL IS THEN MADE TO THE CALLER.
;
; $STIMP IS INVOKED TO OPEN ONLY THOSE FILES TO BE INCLUDED IN THE MAP
; WHEN SW$MA IS CLEAR IN THE ELEMENT SWITCH WORD.
;
; $STELM IS INVOKED TO SETUP THE NEXT ELEMENT DESCRIPTOR WITHOUT OPENING
; THE ASSOCIATED FILE
;
;
;
; INPUTS:
;
;	$INPPT RECORD BLOCK.
;
; OUTPUTS:
;
;	C=1 IF NO MORE FILES ARE IN THE ELEMENT LIST.
;		RETURN IS VIA RETURN.
;	C=0 IF NEXT FILE IS OPENED SUCESSFULLY.
;		RETURN IS VIA CALL @(SP)+.
;-

	PURE.I			; READ-ONLY I-SPACE

	.ENABL	LSB

$STELM::			;
	MOV	SP,OPSW		; SET TO BYPASS FILE OPEN
	BR	2$		;

$STIMP::			;
	CLR	OPSW		; SET TO OPEN APPROPRIATE FILES
2$:				;
	MOV	#SW$MA,BYPSW	; SET TO EXCLUDE SELECTED FILES
	BR	5$		;


$STINP::			;
	CLR	BYPSW		; PROCESS ALL FILES
	CLR	OPSW		; OPEN ALL FILES
5$:				;
	CLR	OPEN		; SET NOTHING OPEN AND REWIND
	MOV	(SP)+,R0	; GET RETURN ADDRESS
	MOV	$CRSEG,R1	;GET ADDRESS OF CURRENT SEGMENT
	MOV	S$GELT(R1),-(SP);SET ADDRESS OF NEXT ELEMENT
	MOV	R0,-(SP)	;RESTORE RETURN ADDRESS
10$:				;
	MOV	2(SP),R1	; GET VIRTUAL ADDRESS OF NEXT ELEMENT
	BNE	20$		;IF NE GOT ONE
	MOV	(SP)+,(SP)	;REMOVE ZERO WORD
	CALL	CLOSE		; CLOSE FILE
	SEC			;SET CARRY
	RETURN			;
20$:				;
	CALL	$CVRL		; CONVERT VIRTUAL TO REAL ADDRESS
	MOV	E$LNXT(R0),2(SP) ; SET VIRTUAL ADDRESS OF NEXT
	MOV	(SP),-(SP)	; COPY RETURN ADDRESS
	MOV	R1,2(SP)	; SAVE VIRTUAL ADDRESS OF CURRENT ELEMENT
	MOV	R1,$CRVEL	; SET VIRTUAL ADDRESS OF CURRENT ELEMENT
	MOV	$CRELM,R2	; SAVE ADDRESS OF PREVIOUS ELEMENT DESCRIPTOR
	MOV	R0,$CRELM	;SET ADDR OF CURRENT ELEMENT DESCRIPTOR
	TSTB	OPEN		; FILE OPEN?
	BEQ	25$		; IF EQ NO
	ADD	#E$LMND+16,R0	; GET FILE ID OF CURRENT FILE
	MOV	$INPPT,R1	; GET INPUT FILE RECORD BLK POINTER
				; FOR PRIVIOUS FILE
	ADD	#F.FNB+N.FID,R1	; POINT TO FILE ID
	CMP	(R0)+,(R1)+	; FILE ID OF LAST AND CURRENT THE SAME
	BNE	24$		; IF NE NO
	CMP	(R0)+,(R1)+	;
	BNE	24$		;
	CMP	(R0)+,(R1)+	;
	BNE	24$		; FILE ID'S DIFFER
	SUB	#20,R0 		; POINT TO THE DEVICE UNIT NUMBERS
				; IN THE ELEMENT DESCRIPTOR.
	ADD	#<N.DVNM-N.FNAM>,R1 ; IN BOTH DATA STRUCTURES
	CMP	-(R0),(R1)+	; ARE THE DEVICE NAMES THE SAME?
	BNE	24$		; IF NE, NO...MUST BE A DIFFERENT FILE
	CMP	-(R0),(R1)+	; ARE UNIT NUMBERS THE SAME?
	BNE	24$		; IF NE, NO...STILL A DIFFERENT FILE
	MOV	$CRELM,R1	; GET ADDRESS OF CURRENT ELEMENT DESCRIPTOR
	BIT	E$LSWT(R2),BYPSW ; BY PASS OPEN?
	BEQ	23$		; IF EQ NO
	BIT	E$LSWT(R1),BYPSW ; BY PASS OPEN ON CURRENT?
	BEQ	25$		; IF EQ NO - OPEN
	BR	30$		; BOTH BY PASS
23$:
	BIT	E$LSWT(R1),BYPSW ;
	BEQ	30$		;BOTH NOT BY PASSED
	CALL	CLOSE		; CLOSE PREVIOUS
	BR	30$		;
24$:
	CALL	CLOSE		; FILES DIFFER - CLOSE LAST
25$:
	CALL	SETUP		; SETUP FILE NAME BLOCK
	TST	OPSW		; OPEN ANY FILE?
	BNE	35$		; IF NE NO
	BIT	E$LSWT(R1),BYPSW ; BYPASS OPEN ON SELECTED FILE?
	BNE	35$		; IF NE YES
	MOVB	SP,OPEN		; SET TO FILE IS OPEN
	OFNB$R	R0		; OPEN INPUT FILE
	BCC	35$		; IF CC OKAY
	MOV	R$NAME(R0),R2	;GET ADDRESS OF NAME STRING
	MOV	(PC)+,R1	;OPEN FAILURE
	.BYTE	E$R11,S$V2	;FATAL-NO RETURN
	CALL	$ERMSG		;OUTPUT ERROR MESSAGE
30$:
	CALL	SETUP		; SETUP FILE NAME BLOCK
35$:
	CMP	#3,$PHASE	; PHASE 3?
	BEQ	80$		;IF EQ YES
	BIT	#SW$CC,E$LSWT(R1);CONCATENATED FILE?
	BNE	40$		;IF NE YES
	BIT	#SW$LB,E$LSWT(R1);LIBRARY FILE?
	BEQ	80$		;IF EQ NO
40$:	MOV	(SP)+,R0	;GET RETURN ADDRESS
	MOV	E$LMOD(R1),-(SP);SET ADDRESS OF NEXT ENTRY
	MOV	R0,-(SP)	;RESTORE RETURN ADDRESS
50$:				;
	MOV	2(SP),R1	; GET VIRTUAL ADDRESS OF NEXT ENTRY
	BEQ	70$		;IF EQ NO MORE
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	MOV	E$LNXT(R0),2(SP);SET ADDRESS OF NEXT ENTRY
	MOV	(SP),-(SP)	; COPY RETURN ADDRESS
	MOV	R1,2(SP)	; SAVE VIRTUAL ADDRESS OF CURRENT
	MOV	R1,$CRVEL	; SET VIRTUAL ADDRESS OF CURRENT ELEMENT
	MOV	R0,$CRELM	;SET ADDR OF CURRENT ELEMENT DESCRIPTOR
	CLR	$NBYTE		;CLEAR BYTE COUNT
	TST	OPSW		; FILE OPEN?
	BNE	60$		; IF NE NO
	BIT	E$LSWT(R0),BYPSW ; OPEN BYPASSED FOR FILE?
	BNE	60$		; IF NE YES
	BIT	#SW$CC,E$LSWT(R0);CONCATENATED FILE?
	BEQ	53$		; IF EQ NO
	TSTB	REWND		; REWIND FILE?
	BNE	60$		; IF NE NO
	CALL	PTBGN		; ENSURE POINTING BEGINNING OF FILE
	MOVB	#1,REWND	; MARK NO REWIND
	BR	60$		;
53$:
	CLR	R1		;CLEAR HIGH PART OF VIRTUAL BLOCK NUMBER
	MOV	E$LMND(R0),R2	;SET LOW PART OF VIRTUAL BLOCK NUMBER
	MOV	E$LMND+2(R0),R3	;GET BYTE WITHIN BLOCK
	MOV	$INPPT,R0	;GET INPUT FILE RECORD BLOCK
	MOVB	#2,F.RTYP(R0)	;SET VARIABLE LENGTH RECORD TYPE
	MOVB	#4,F.RATT(R0)	;SET RECORD ATTRIBUTES
	CALL	.POINT		;POINT TO PROPER RECORD
	BCS	55$		;IF CS I/O ERROR
	GET$S	R0		; GET MODULE HEADER RECORD
	BCC	60$		;IF CC OKAY
55$:	MOV	R$NAME(R0),R2	;GET ADDRESS OF NAME STRING
	MOV	(PC)+,R1	;I/O ERROR
	.BYTE	E$R10,S$V2	;FATAL-NO RETURN
	CALL	$ERMSG		;OUTPUT ERROR MESSAGE
60$:				;
	CALL	ALCMT		; ALLOCATE CMT TABLE
	CALL	@(SP)+		;CALL THE CALLER
	CALL	$DLCMT		; DEALLOCATE CMT TABLE
	MOV	2(SP),R1	; RESTORE VIRTUAL ADDRESS OF CURRENT
	MOV	(SP)+,(SP)	; ADJUST STACK
	CALL	$UNLPG		; UNLOCK PAGE FROM CORE
	BR	50$		;GO AGAIN
70$:	MOV	(SP)+,(SP)	;REMOVE ZERO WORD
	BR	100$		;
80$:				;
	CALL	PTBGN		; POINT TO BEGINNING OF FILE
	CALL	ALCMT		; ALLOCATE CMT TABLE
	CALL	@(SP)+		;CALL THE CALLER
	CALL	$DLCMT		; DEALLOCATE CMT TABLE
	MOV	2(SP),R1	; GET DESCRIPTOR VIRTUAL ADDRESS
	CALL	$UNLPG		; UNLOCK DESCRIPTOR FROM MEMORY

100$:				;
	MOV	(SP)+,(SP)	; REMOVE VIRTUAL ADDRESS FROM STACK
	CLRB	REWND		; MARK REWIND
	JMP	10$		;

CLOSE:
	TST	OPSW		; FILE OPEN?
	BNE	110$		; IF NE NO
	MOV	$INPPT,R0	; GET POINTER TO INPUT FILE RECORD BLOCK
	BIT	R$SWTH(R0),BYPSW ; OPEN BYPASSED?
	BNE	110$		; IF NE YES
	CLOSE$	R0		; CLOSE FILE
	CLRB	OPEN		; SET TO NO FILE OPEN
110$:
	RETURN

;
; SETUP - SETUP FILE NAME BLOCK
;


SETUP:
	CLR	$NBYTE		; CLEAR BYTE COUNT
	MOV	$CRELM,R0	; GET ADDRESS OF CURRENT ELEMENT DESCRIPTOR
	MOV	$INPPT,R1	; GET INPUT FILE RECORD BLOCK POINTER
	CALL	$STFNB		; SETUP FILE NAME BLOCK
	MOV	$CRELM,R1	; GET ELEMENT DESCRIPTOR ADDRESS
	MOV	$INPPT,R0	; GET INPUT FILE RECORD BLOCK
	RETURN			;



	.DSABL	LSB

;
; ENSURE POINTING TO BEGINNING OF FILE
;

PTBGN:
	TSTB	OPEN		; IS THE FILE OPEN?
	BEQ	10$		; IF EQ, NO...DON'T BOTHER WITH THE REST
	MOV	$INPPT,R0	; GET ADDRESS OF FDB
	CLR	R1		; GET VBN
	MOV	#1,R2		;
	CLR	R3		; SET BYTE IN VBN
	CALL	.POINT		; POINT TO BEGINNING OF FILE.
10$:
	RETURN			;
;
; ALLOCATE CMT TABLE ENTRY IN DYNAMIC STORAGE
;

ALCMT:				;
	MOV	4(SP),R1	; GET VIRTUAL DESCRIPTOR ADDRESS
	CALL	$CVLOK		; CONVERT TO REAL, LOCK IN MEMORY
	SAVRG			; SAVE NON-VOLATILE REGISTERS
	MOV	R0,R3		; COPY REAL ADDRESS
	MOV	E$LNUM(R3),R1	; GET HIGHEST SECTION NUMBER
	BMI	20$		; IF MI NONE
	INC	R1		; CONVERT TO NUMBER OF SECTIONS
	ASL	R1		; CONVERT TO WORD COUNT
	MOV	R1,R5		; SAVE WORD COUNT
	SUB	#<P$GSIZ-P$GHD>/2,R5 ; ASSUME CMT EXCEEDS A PAGE
	BHI	5$		; IF HI CMT EXCEEDS A PAGE
	MOV	R1,R5		; RESET SIZE OF CMT
5$:				;
	ASL	R1		; CONVERT TO CMT SIZE
	CALL	$ALBLK		; ALLOCATE CORE BLOCK
	MOV	R0,E$LCMT(R3)	; SAVE CURRENT CMT ADDRESS
	MOV	R0,R4		; SAVE ADDRESS OF BLOCK
	MOV	E$LVMT(R3),R1	; GET ADDRESS OF VIRTUAL CMT
	CALL	7$		; SETUP FIRST PART OF CMT
	MOV	E$LVMT+2(R3),R1	; GET ADDRESS OF SECOND PART OF TABLE
	BEQ	20$		; IF EQ NONE
	MOV	#<P$GSIZ-P$GHD>/2,R5 ; GET PAGE SIZE
7$:				;
	CALL	$CVRL		; CONVERT TO REAL
10$:				;
	MOV	(R0)+,(R4)+	; COPY CMT ENTRY
	SOB	R5,10$		; LOOP FOR ALL ENTRIES
20$:				;
	RETURN			;


;+
; **-$DLCMT-DEALLOCATE CONTROL SECTION MAPPING TABLE
;
; THIS SUBROUTINE IS CALLED TO DEALLOCATE THE COPY OF THE
; CONTROL SECTION MAPPING TABLE THAT IS STORED IN REAL
; MEMORY. THE DEALLOCATION IS PERFORMED AFTER THE ELEMENT
; HAS BEEN PROCESSED.
;
; INPUTS:
;
;	$CRELM=REAL ADDRESS OF CURRENT ELEMENT
;
; OUTPUTS:
;
;	THE CONTROL SECTION MAPPING TABLE (IF ANY) IS RETURNED TO THE
;	CORE POOL. THE ELEMENT DESCRIPTOR CMT ADDRESS IS CLEARED
;
;	THE CALLING ROUTINE IS RESPONSIBLE FOR INSURING THAT THE
;	ADDRESS IN $CRELM IS VALID AND THE PAGE CONTAING THE DES-
;	CRIPTOR IS WRITE-MARKED.
;
;-
	PURE.I			; READ-ONLY I-SPACE

$DLCMT::			;
	MOV	$CRELM,R0	; GET REAL ADDRESS OF CURRENT ELEMTN
	MOV	E$LCMT(R0),R2	; GET ADDRESS OF CMT
	BEQ	10$		; IF EQ NONE
	CLR	E$LCMT(R0)	; CLEAR CMT ADDRESS
	MOV	E$LNUM(R0),R1	; GET HIGHEST SECTION NUMBER
	INC	R1		; CONVERT TO NUMBER OF SECTIONS
	ASL	R1		; CONVERT TO BYTE COUNT
	ASL	R1		; ...
	MOV	#$FRHD,R0	; GET ADDRESS OF FREE CORE POOL LISTHEAD
	CALL	$RLCB		; RELEASE CORE BLOCK
10$:				;
	RETURN			;


	.END
