	.TITLE	PRCLM
	.IDENT	/16.22/
;
; COPYRIGHT (c)	1989 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE IS FURNISHED  UNDER A LICENSE AND MAY BE USED OR
; COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;
; C. MONIA/D. CUTLER  23-OCT-75
;
; PREVIOUSLY MODIFIED BY:
;
;	J. A. KASSON
;	C. B. PETROVIC
;	E. POLLACK
;	J. M. SALMAN
;	D. P. RABAHY
;	L. M. PETERSON
;
; MODIFIED FOR RSX-11M-PLUS AND MICRO/RSX V4.3 BY:
;
;	L. M. PETERSON	23-JAN-89	16.22
;
;		LMP129	LET ID TASKS LINK TO MANUAL LOAD OVERLAID LIBRARIES
;
; PROCESS RELOCATABLE OBJECT MODULE
;
; LOCAL DATA
;
;	*** NOTE ***
;
; MODULE 'P3PRE' MUST BE MODIFIED WHENEVER THE CONTENTS OF THIS
; SECTION ARE CHANGED.
;

	.IF DF D$PRCL & D$TRAC

	S$YLNK	=	0	; Local definition
D$SYM::
	.RAD50	/.DATA./	; To hold a symbol to stumble over...

	.ENABL	LC
;
	.PSECT	TRPT$D,RO,D

$TRPS0:	.WORD	-1		; Phase on which to dump symbol data
$TRSY0:	.WORD	0		; Real memory address of symbol
$TRSM0:				; Reference label...
;
; The following offsets define the basic symbol table entry.
;
	TRC S$YLNK,^/%NS$YLNK - link to next symbol................%P%N/
	TRC S$YM,^/S$YM   - symbol name........................%2R%N/
	TRC S$YFLG,^/S$YFLG - symbol flags byte..................%P%N/
	TRC S$YVAL,^/S$YVAL - symbol value.......................%P%N/
	TRC S$YCMT,^/S$YCMT - control section entry address......%P%N/
	TRC S$YSEG,^/S$YSEG - address of defining segment........%P%N/

	.PSECT	TRPT$D,RO,D
	.WORD	-1		; Flag the end of the list

	.PSECT	TRPT$D,RO,D

$TRPS1:	.WORD	-1		; Phase on which to dump symbol data
$TRSY1:	.WORD	0		; Real memory address of symbol
$TRSM1:				; Reference label...
;
; The following offsets define the symbol table entry extension for
; autoloadable symbols originating from an overlaid super-mode library.
;
	TRC S$YCMP,^/S$YCMP - virtual address of $CMPAL..........%P%N/
	TRC S$YCMP+2,^/S$YCMP+2 - definition value of $CMPAL.......%P%N/
	TRC S$YCMP+4,^/S$YCMP+4 - offset value in $$ALVC...........%P%N/
	TRC S$YSDX,^/S$YSDX - 'group' offset value into $$ALVC...%P%N/
	TRC S$YVOX,^/S$YVOX - same as S$YVOF,but for super-mode..%P%N/
	TRC S$YCVX,^/S$YCVX - pseudo-indirect symbol table entry.%P%N/

	.PSECT	TRPT$D,RO,D
	.WORD	-1		; Flag the end of the list

	.PSECT	TRPT$D,RO,D

$TRPS2:	.WORD	-1		; Phase on which to dump symbol data
$TRSY2:	.WORD	0		; Real memory address of symbol
$TRSM2:				; Reference label...
;
; The following offsets define the symbol table entry extension for
; autoloadable symbols originating from an overlaid library.
;
	TRC S$YSDO,^/S$YSDO - 'group' offset value into $$ALVC...%P%N/
	TRC S$YVOF,^/S$YVOF - offset value into $$ALVC...........%P%N/
	TRC S$YCVT,^/S$YCVT - pseudo-indirect symbol table entry.%P%N/

	.PSECT	TRPT$D,RO,D
	.WORD	-1		; Flag the end of the list

;
	.ENDC	; D$PRCL & D$TRAC


	.PSECT	PRCL$D,RW,D,GBL,REL,OVR

CRSCT:	.BLKW	10.		; CURRENT SECTION DATA
CRVSC:	.BLKW	1		; VIRTUAL ADDRESS OF CURRENT SECTION
LOADNM:	.RAD50	/$LOAD/		; MANUAL LOAD SUBROUTINE NAME
MODN:	.BLKW	1		; FIRST HALF OF MODULE NAME (ADJ. TO LCLSYM)
LCLSYM:	.BLKW	12.		; LOCAL SYMBOL STORAGE
SRCPF:	.BLKW	1		;SEARCH PATH FLAG
SRVSG:	.BLKW	1		; VIRTUAL ADDRESS OF SEARCH SEGMENT
SYDEF:	.BLKW	1		;SYMBOL DEFINITION FLAG
SYENT:	.BLKW	2		; SYMBOL ENTRY ADDRESS (VA IN WORD 1,
				; RA IN WORD 2).
SYFLG:	.BLKW	1		; CURRENT SYMBOL FLAGS
CMPVA:	.BLKW	1		; VIRTUAL ADDRESS OF COMPLETION ROUTINE

	IMPURE			; READ/WRITE DATA

SKPALV:	.BLKW	1		; SKIP $$ALVC FLAG
SYMFLG:	.BLKW	1		; GLOBAL SYMBOL DEFINITION FLAG


	.PSECT	SUP$D,D

AUTONM:				; INDIRECT AUTOLOAD SUBROUTINE CALL
	.RAD50	/.NAUTO/

;
; DEFINE OBJECT FILE RECORD TYPES WHICH ARE IGNORED BY TKB
;
; NOTE THAT IN THE CURRENT IMPLEMENTATION, RECORD TYPES IN THE RANGE
; OBRDEC-OBRMAX ARE IGNORED. ANY TYPE UNIMPLEMENTED BY DIGITAL OR
; GREATER THAN OBRMAX IS CONSIDERED A FILE FORMAT ERROR.
;
	OBRDEC = 100.		; RESERVED TO DIGITAL (0.-100.)
	OBRCUS = 201.		; RESERVED TO CUSTOMER (201.-255.)
	OBRMAX = 255.		; MAXIMUM TYPE CONSIDERED LEGAL




;+
; **-$PRCLM-PROCESS RELOCATABLE OBJECT MODULE
;
; THIS SUBROUTINE IS CALLED TO PROCESS A RELOCATABLE OBJECT MODULE.
; ALL GLOBAL SYMBOL DIRECTORY RECORDS ARE READ AND ENTERED IN THE
; SECTION AND SYMBOL TABLES FOR THE CURRENT SEGMENT.
;
; INPUTS:
;
;	R4=REAL ADDRESS OF ELEMENT DESCRIPTOR
;	R5=REAL ADDRESS OF CURRENT SEGMENT
;	$CRELM=REAL ADDRESS OF ELEMENT DESCRIPTOR
;	$CRSEG=REAL ADDRESS OF SEGMENT DESCRIPTOT
;	$CRVEL=VIRTUAL ADDRESS OF ELEMENT DESCRIPTOR
;	$CRVSG=VIRTUAL ADDRESS OF SEGMENT DESCRIPTOR
;
; OUTPUTS:
;
;	ALL GLOBAL SYMBOL DIRECTORY RECORDS ARE PROCESSED
;
;-
	PURE.I			; READ-ONLY I-SPACE


$PRCLM::			;
	CLR	CMPVA		; ZERO COMPLETION ROUTINE ADDRESS
	MOV	R3,-(SP)	; SAVE R3
PRCEL1:	CALL	$GTBYT		;GET RECORD LENGTH
	BCS	PRCEL3		;IF CS EOF (ILL FORMAT)
	MOV	R0,R3		;SAVE RECORD LENGTH
PRCEL2:	CALL	$GTWRD		;GET BLOCK TYPE
	SUB	#2,R3		;ADJUST BYTE COUNT
	CMP	R0,#LGBLK	;LEGAL BLOCK TYPE?
	BLOS	PRCEL4		;IF LOS YES
	CLR	$NBYTE		; ANYTHING ELSE IS ILLEGAL OR IGNORED
	CMP	#OBRMAX,R0	; GREATER THAN LEGAL TYPE?
	BLO	PRCEL3		; YES, FILE FORMAT ERROR
	CMP	#OBRCUS,R0	; WITHIN CUSTOMER RESERVED RANGE?
	BLOS	PRCEL1		; IF YES, JUST GO FOR NEXT RECORD
PRCEL3:	CLR	R0		;SET ILLEGAL BLOCK TYPE
PRCEL4:	ASL	R0		;MAKE WORD INDEX
	CALL	@DSPVCT(R0)	;CALL BLOCK DEPENDENT ROUTINE
	BR	PRCEL1		;GO AGAIN

;
; DISPATCH VECTOR
;

	PURE.D			; READ-ONLY D-SPACE

DSPVCT:	.WORD	ILFMT		;BLK 0-ILLEGAL BLOCK TYPE
	.WORD	STGSD		;BLK 1-START GSD
	.WORD	ENGSD		;BLK 2-END GSD
	.WORD	RPEAT		;BLK 3-TXT
	.WORD	RPEAT		;BLK 4-RLD
	.WORD	STISD		; BLK 5-ISD
	.WORD	ILFMT		;BLK 6-MODULE END
LGBLK=<.-DSPVCT-2>/2		;HIGHEST LEGAL BLOCK TYPE

	PURE.I			; READ-ONLY I-SPACE

;
; START GSD-BLOCK TYPE 1
;

STGSD:	MOV	R3,-(SP)	;SAVE BYTE COUNT
	MOV	#LCLSYM+2,R3	; GET ADDRESS TO STORE SYMBOL
	MOV	#4,-(SP)	;SET LOOP COUNT
10$:	CALL	$GTWRD		;GET A WORD
	MOV	R0,(R3)+	;SAVE IN TEMP BUFFER
	DEC	(SP)		;DECREMENT LOOP COUNT
	BGT	10$		;IF GT GO AGAIN
	TST	(SP)+		;REMOVE COUNT WORD FROM STACK
	MOV	(SP)+,R3	;RETRIEVE BYTE COUNT
	SUB	#8.,R3		;ADJUST FOR SYMBOL ENTRY
	MOV	#LCLSYM,R1	;GET ADDR OF SYMBOL DESCRIPTOR
	MOVB	S$YFLG+1(R1),R2	; GET TYPE OF GSD ENTRY
	CLRB	S$YFLG+1(R1)	; CLEAR HIGH FLAGS WORD BYTE
	CMP	R2,#LGTYP	;LEGAL TYPE?
	BHI	ILFMT		;IF HI ILLEGAL FORMAT
	ASL	R2		;MAKE WORD INDEX
	MOV	R5,R0		;ADDRESS OF CURRENT SEGMENT TO R0
	CALL	@GSDVCT(R2)	;DISPATCH TO ROUTINE
	TST	R3		;ANY MORE TO PROCESS?
	BGT	STGSD		;IF GT YES
	RETURN			;

;
; GSD ENTRY TYPE DISPATCH TABLE
;
;	*** NOTE ***
;
; MODULE 'P3PRE' MUST BE MODIFIED WHENEVER THE CONTENTS OF THIS
; SECTION CHANGE.
;

	.PSECT	GSDV$D,RW,D,GBL,REL,OVR


GSDVCT:	.WORD	MODNME		;MODULE NAME
	.WORD	SCTNME		;SECTION NAME
	.WORD	INTSYM		;INTERNAL SYMBOL
	.WORD	XFRADR		;TRANSFER ADDRESS
	.WORD	SYMDCL		;SYMBOL DECLARATION
	.WORD	PSTNME		;PROGRAM SECTION NAME
	.WORD	VIDENT		;VERSION IDENTIFICATION
	.WORD	VSTNME		;VIRTUAL ARRAY STORAGE SECTION NAME
	.WORD	CMPRT		; COMPLETION ROUTINE NAME
LGTYP=<.-GSDVCT-2>/2		;HIGHEST LEGAL GSD TYPE

	PURE.I			; READ-ONLY I-SPACE


;
; MODULE NAME
;

MODNME:	CLR	SYMFLG		; INITIALIZE GLOBAL SYMBOL DEFINITION FLAG
	TST	E$LMOD(R4)	;MODULE NAME ALREADY DEFINED?
	BNE	ILFMT		;IF NE YES
	MOV	#LCLSYM+4,R0	; GET ADDRESS OF SECOND HALF OF SYMBOL
	MOV	#MODN,R1	; GET ADDRESS TO STORE MODULE NAME
	MOV	(R0),E$LMOD+2(R4);SET SECOND HALF OF MODULE NAME
	MOV	-(R0),E$LMOD(R4);SET FIRST HALF OF MODULE NAME
	MOV	(R0)+,(R1)+	;SET MODULE NAME IN LOCAL SYM DESCRIPTOR
	MOV	(R0),(R1)	;
	MOV	$CRVEL,R1	; GET VIRTUAL ADDRESS OF CURRENT ELEMENT
	CALLR	$WRMPG		; WRITE-MARK PAGE

;
; ILLEGAL FORMAT-BLOCK TYPES 0 AND 6
;

ILFMT:	MOV	$INPPT,R2	;GET INPUT FILE RECORD BLOCK
	MOV	R$NAME(R2),R2	;GET ADDRESS OF NAME STRING
	MOV	(PC)+,R1	;GET ERROR/SEVERITY
	.BYTE	E$R14,S$V2	;FATAL-NO RETURN
	CALL	$ERMSG		;OUTPUT ERROR MESSAGE

;
; SECTION AND PROGRAM SECTION NAME
;

SCTNME:	MOV	#$ABSCT,R2	;GET ADDRESS OF ABS SECTION ENTRY
	MOVB	C$SFLG(R2),C$SFLG(R1);ASSUME ABS SECTION
	CMP	S$YM(R2),S$YM(R1);ABS SECTION?
	BEQ	PSTNME		;IF EQ YES
	BISB	#CS$REL,C$SFLG(R1);ASSUME NAMED REL SECTION
	TST	S$YM(R1)	;NAMED SECTION?
	BNE	PSTNME		;IF NE YES
	BICB	#<CS$GBL!CS$ALO>,C$SFLG(R1) ; CLEAR GLOBAL, OVERLAYED FLAGS
PSTNME:				;
	CLR	SKPALV		; CLEAR SKIP-AUTOLOAD-VECTOR FLAG
	BIT	#SW$RL,E$LSWT(R4) ; LIBRARY ELEMENT?
	BEQ	90$		; IF EQ NO
	CMP	C$SNME(R1),#^R$$A ; IS SECTION $$ALVC?
	BNE	90$		; IF NE NO
	CMP	C$SNME+2(R1),#^RLVC ; MAYBE
	BNE	90$		; IF NE NO
	BIT	#SW$ALE,E$LSWT(R4) ; ENCOUNTERED ANY AUTOLOADABLE ENTRY
				   ; POINT ISD ITEMS?
	BNE	85$		; IF NE YES
	BIT	#ID$ATA,$SWTCH	; BUILDING I/D TASK?
	BEQ	90$		; IF EQ NO
	TST	SYMFLG		; USING MANUAL LOAD (ALREADY HIT GBL SYM DEF)?
	BNE	90$		; IF NE, YES
	MOV	#<S$V2*400!E$R106>,R1 ; INCOMPATIBLE AUTOLOAD VECTORS
	MOV	#MODN,R2	; GET ADDRESS OF MODULE NAME
	CALLR	$ERMSG		; FATAL ERROR
85$:
	INC	SKPALV		; SKIP $$ALVC AND SYMBOLS DEFINED IN IT
	RETURN			; GET OUT
90$:
	MOV	R3,-(SP)	; SAVE R3
	CLR	R3		; ZERO R3 - R3 IS USED TO TELL IF A DUMMY
				; P-SECTION ENTRY IS BEING MADE IN THE
				; ROOT - FOR USER D-SPACE
	MOV	R1,R2		; COPY DESCRIPTOR ADDRESS
	ADD	#C$SFLG,R2	; POINT TO FLAGS
	BICB	#<CS$IND>,(R2)	; CLEAR UNWANTED BIT.
	BITB	#CS$REL,(R2)	; SECTION RELOCATABLE
	BEQ	1$		; IF EQ NO
	BITB	#CS$TYP,(R2)	; DATA SECTION?
	BNE	100$		; IF NE YES
	MOV	#LCLSYM+10,R2	; POINT TO SECTION LENGTH
	BIT	#1,(R2)		; LENGTH ON BYTE BOUNDARY?
	BEQ	1$		; IF EQ NO
	INC	(R2)		; INCREMENT LENGTH
	BNE	1$		; IF NE OK
	MOV	#<S$V0*400!E$R19>,R1 ; P-SECTION OVERFLOW
	BR	2$		;
100$:
	BIT	#ID$ATA,$SWTCH	; TASK SUPPORT FOR D-SPACE?
	BEQ	1$		; IF EQ NO
	TST	$DPSIZ		; WAS /ID:N SPECIFIED WITH N > 0 ?
	BEQ	1$		; IF EQ NO
	TST	LCLSYM+10	; IS DATA SECTION ZERO LENGTH?
	BEQ	1$		; IF EQ YES
	CMP	LCLSYM+10,$DPSIZ ; IS SECTION LENGTH LARGER THAN N ?
	BHI	1$		; IF EQ YES - KEEP IT IN DEFINING SEGMENT
	MOV	R1,-(SP)	; SAVE THIS FOR A WHILE
	MOV	R0,-(SP)	; THIS ONE TOO...
	MOV	$RTSEG,R1	; GET ROOT SEGMENT VIRTUAL ADDRESS
	CALL	$CVRL		; CONVERT TO A REAL ADDRESS
	MOV	R0,R2		; COPY THE ADDRESS
	MOV	(SP)+,R0	; RESTORE THESE AGAIN
	MOV	(SP)+,R1	; SINCE WE DON'T NEED 'EM ANYMORE
	CMP	R5,R2		; AND CHECK IF CURRENT = ROOT.
	BEQ	4$		; IF EQ YES
	BIS	#CS$GBL,LCLSYM+6 ; FORCE SECTION TO BE GLOBAL IF WE'RE
				 ; RELOCATING IT BECAUSE IT'S LESS THAN
				 ; THE THRESHOLD VALUE IN $DPSIZ
	BR	310$		; NO - FIRST MAKE ENTRY IN ROOT
1$:				;
	BITB	#CS$LIB,C$SFLG(R1) ; LIBRARY SECTION?
	BEQ	3$		;IF EQ NO
	BITB	#SW$RL,E$LSWT(R4);LIB SECTION LEGAL?
	BEQ	105$		; IF .EQ. 0, THEN NOT LEGAL LIB. SECTION
	BITB	#SW$SUP,E$LSWT(R4) ; IS THE LIBRARY SUPER-MODE??
	BEQ	3$		; IF .EQ. 0, NO
	BISB	#CS$SUP,C$SFLG+1(R1) ; YES, FLAG THIS SECTION
	BR	3$		; AND CONTINUE
105$:
	BICB	#CS$LIB,C$SFLG(R1) ; CLEAR LIBRARY FLAG
	MOV	(PC)+,R1	;ILLEGAL REFERENCE TO LIBRARY SECTION
	.BYTE	E$R60,S$V0	;DIAGNOSTIC
2$:				;
	MOV	#LCLSYM+2,R2	; POINT TO SYMBOL NAME
	CALL	$ERMSG		;OUTPUT ERROR MESSAGE
	MOV	#LCLSYM,R1	;RETRIEVE ADDRESS OF LOCAL STORAGE
	MOV	R5,R0		;RESET SEGMENT DESCRIPTOR ADDRESS
3$:				; IF PSECT HAS SAVE ATTRIBUTE CREATE
				; ENTRY IN ROOT TO FORCE ALLOCATION THERE
	BITB	#CS$SAV,C$SFLG(R1) ; FORCE PSECT INTO ROOT?
	BEQ	4$		; EQ IF NO
	BISB	#CS$ROT,C$SFLG+1(R1) ; REMEMBER SAVE ATTRIBUTE IN HIGH BYTE
	CMP	$RTSEG,R0	; CURRENT=ROOT?
	BEQ	4$		; EQ IF YES
310$:
	MOV	#C$SLGH,R1	; SIZE OF BLOCK TO ALLOCATE
	CALL	$ALSVB		; ALLOCATE IT
	MOV	LCLSYM+2,S$YM(R0) ; SET UP PSECT NAME
	MOV	LCLSYM+4,S$YM+2(R0) ;
	MOV	LCLSYM+6,C$SFLG(R0) ; COPY FLAGS BYTE
	BICB	#<CS$ATL!CS$IND>,C$SFLG(R0) ; CLEAR AUTOLOAD AND IND BITS
	MOV	$RTSEG,R0	; GET VIRTUAL ADDRESS OF ROOT SEGMENT
	ADD	#S$GCST/2,R0	; POINT TO SECTION TABLE
	CALL	$SRCHI		; SEARCH FOR INSERT
	BCC	320$		; CC IF SECTION ALREADY DEFINED IN ROOT
	CALL	$ISYM		; INSERT SECTION
320$:
	MOV	R5,R0		; RESTORE CURRENT SEGMENT
	MOV	#LCLSYM,R1	; AND LOCAL STORAGE
4$:				;
	BICB	#CS$SAV,C$SFLG(R1) ; CLEAR SAV BIT
	BITB	#CS$GBL,C$SFLG(R1) ; LOCAL SECTION?
	BEQ	50$		;IF EQ YES
	MOV	#$WSRCC,-(SP)	;SET ADDRESS OF SEARCH ROUTINE
5$:	CALL	@(SP)+		;SEARCH FOR SECTION
	BCS	60$		;IF CS NO FIND EM
6$:
	BNE	7$		;IF NE FOUND ON PATH UP OR DOWN
	MOV	$CRVSM,R1	; GET VIRTUAL ADDRESS OF SECTION
	JMP	SCTCHK		;FOUND IN CURRENT SEGMENT
7$:	BITB	#CS$GBL,C$SFLG(R0);GLOBAL SECTION?
	BEQ	5$		;IF EQ NO

;
; FOUND ON PATH UP OR DOWN
;

	CLR	SYDEF		;CLEAR DEFINITION FOUND FLAG
	CALL	30$		;SET UP SEARCH PARAMETERS
10$:	CALL	@(SP)+		;CONTINUE SEARCH
	BCS	20$		;IF CS DONE
	BITB	#CS$GBL,C$SFLG(R0);GLOBAL SECTION?
	BEQ	10$		;IF EQ NO
	CALL	30$		;COMPARE PARAMETERS
	BCC	10$		;IF CC CONTINUE SEARCH
	TST	(SP)+		;CLEAN STACK
	BR	40$		;AMBIGUOUS DEFINITION

;
; ALL PATHS SEARCHED-ALLOCATE INDIRECT CONTROL SECTION ENTRY
;

20$:	TST	SYDEF		;DEFINITION FOUND?
	BEQ	40$		;IF EQ NO
	MOV	#C$SELM+2,R1	; GET SIZE OF INDIRECT ENTRY
	CALL	$ALSVB		; ALLOCATE SMALL VIRTUAL CORE BLOCK
	MOV	SYDEF,C$SBSE(R0);SET INDIRECT ENTRY ADDRESS
	MOV	SRVSG,C$SLTH(R0) ; SET VIRTUAL ADDRESS OF SEGMENT DECRIPTOR
	BISB	#<CS$IND!CS$GBL>,C$SFLG(R0) ; SET INDIRECT GLOBAL FLAGS
	MOV	#LCLSYM,R2	; GET LOCAL DESCRIPTOR ADDRESS
	BR	70$		;
;
; COMPARE PARAMETERS
;

30$:				;
	MOV	$CRVSM,R1	; GET VIRTUAL ADDRESS OF SYMBOL
	BITB	#CS$IND,C$SFLG(R0) ; INDIRECT REFERENCE?
	BEQ	32$		; IF EQ NO
	MOV	C$SBSE(R0),R1	; GET VA OF REAL ENTRY
	BR	34$		;
32$:				;
	MOV	R1,SYDEF	; SET DEFINITION FOUND FLAG
	MOV	$CRVSR,SRVSG	; SAVE VIRTUAL ADDRESS OF SEARCH SEGMENT
34$:				;
	CMP	R1,SYENT	; SAME AS LAST REFERENCE?
	BEQ	36$		; IF EQ YES
	SEC			; SET CARRY
36$:				;
	MOV	R1,SYENT	; SET ADDRESS OF LAST ENTRY
	RETURN			;

;
; AMBIGUOUS CONTROL SECTION DEFINITION
;

40$:				;
	MOV	#MODN,R2	; GET ADDRESS OF MODULE NAME
	MOV	(PC)+,R1	;GET ERROR/SEVERITY
	.BYTE	E$R15,S$V0	;DIAGNOSTIC
	CALL	$ERMSG		;OUTPUT ERROR MESSAGE
	BR	60$		;

;
; LOCAL CONTROL SECTION
;

50$:	ADD	#S$GCST,R0	;POINT TO CONTROL SECTION TABLE HEADER
	CALL	$SRCH		;SEARCH FOR SECTION ENTRY
	MOV	R1,-(SP)	; ASSUME FOUND
	BCC	SCTCHK		;IF CC YES
	TST	(SP)+		;CLEAN STACK
60$:	MOV	#C$SLGH,R1	;GET LENGTH OF SECTION TABLE ENTRY
	CALL	$ALSVB		; ALLOCATE SMALL VIRTUAL CORE BLOCK
	MOV	#LCLSYM,R2	; GET ADDRESS OF LOCAL DESCRIPTOR
	MOV	C$SFLG(R2),C$SFLG(R0)	; COPY FLAGS WORD
	BITB	#CS$LIB,C$SFLG(R0);LIB SECTION?
	BEQ	70$		;IF EQ NO
	MOV	LCLSYM+10,C$SLTH(R0) ; ESTABLISH LENGTH OF SECTION
70$:				;
	MOV	$CRVEL,C$SELM(R0) ; SET ELEMENT DESCRIPTOR BACKPOINTER
	MOV	S$YM(R2),S$YM(R0) ; INSERT SYMBOL IN ENTRY
	MOV	S$YM+2(R2),S$YM+2(R0) ;
	MOV	R1,-(SP)	; SAVE ENTRY ADDRESS
	MOV	$CRVSG,R0	; GET VIRTUAL ADDRESS OF CURRENT
	ADD	#S$GCST/2,R0	; POINT TO SECTION TABLE HEADER
	CALL	$SRCHI		;SEARCH FOR INSERT
	CALL	$ISYM		;INSERT SYMBOL
	BIT	#SE$QA,$SWTCH	;SEQUENCE ALLOCATION?
	BEQ	80$		;IF EQ NO
	MOV	#S$ZSEQ,R1	;GET SIZE OF SEQUENCE LIST ENTRY
	CALL	$ALBLK		;ALLOCATE STORAGE
	MOV	(SP),2(R0)	;SET ADDRESS OF SECTION TABLE ENTRY
	MOV	$CRSEG,R1	;GET ADDRESS OF CURRENT SEGMENT
	MOV	R0,@S$GSEQ+2(R1);LINK NEW ENTRY TO OLD LAST
	MOV	R0,S$GSEQ+2(R1)	;SET NEW LAST ENTRY
80$:				;
	MOV	(SP),R1		; RETRIEVE ENTRY ADDRESS
	CALL	$CVRL		; CONVERT TO REAL ADDRESS

;
; CHECK FOR EQUIVALENT CONTROL SECTION DEFINITIONS
;

SCTCHK:	BITB	#CS$IND,C$SFLG(R0);INDIRECT REFERENCE?
	BEQ	10$		;IF EQ NO
	MOV	C$SBSE(R0),R1	; GET ADDRESS OF REAL ENTRY
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
10$:				;
	MOV	R1,(SP)		; SAVE VIRTUAL ADDRESS OF ENTRY
	MOV	R0,-(SP)	; SAVE REAL ADDRESS OF ENTRY
	MOV	#CRSCT,R1	; POINT TO LOCAL STORAGE
	MOV	#C$SLGH/2,R2	; GET LENGTH OF SECTION ENTRY
15$:				;
	MOV	(R0)+,(R1)+	; COPY SECTION ENTRY
	SOB	R2,15$		; REPEAT
	MOV	(SP)+,R0	; RESTORE R0
	MOV	#LCLSYM,R2	;GET ADDR OF LOCAL DESCRIPTOR
	MOV	C$SFLG(R0),R1	;GET TABLE ENTRY FLAGS
	MOV	R0,-(SP)	; SAVE R0 FOR A LITTLE WHILE
	MOV	C$SFLG(R2),R0	;GET LOCAL ENTRY FLAGS
	BIT	#CS$LIB,R1	;TABLE ENTRY LIB SECTION?
	BEQ	20$		;IF EQ NO
	BIC	#CS$LIB,R1	;CLEAR LIBRARY FLAG
	BIC	#CS$LIB,R0	;CLEAR LIBRARY FLAG
	BIC	#<CS$SUP*400>,R1 ; CLEAR SUPER-MODE FLAG
	BIC	#<CS$SUP*400>,R0 ; DITTO...
20$:				;
	BIC	#<CS$RES*400>,R1 ; CLEAR TASK-RESIDENT FLAG, TABLE ENTRY
	BIC	#<CS$RES*400>,R0 ; CLEAR TASK-RESIDENT FLAG, LOCAL ENTRY
	BIC	#CS$ATL,R0	; CLEAR POSSIBLE AUTOLOAD FLAG
	BIC	#CS$ATL,R1	; CLEAR POSSIBLE AUTOLOAD FLAG
	CMP	R0,R1		;EQUIVALENT?
	BNE	30$		; IF NE, NO, SOMETHING'S DIFFERENT
	MOV	(SP)+,R0	; YES, EQUIVALENT, BUT RESTORE R0 FIRST
	BR	SCTCMT		; NOW BUILD THE CONTROL SECTION MAPPING TABLE
30$:
	MOV	R0,-(SP)	; SAVE THE IMPORTANT STUFF FIRST
	MOV	R1,-(SP)
	BIC	#^C<CS$ROT*400>,(SP) ; CLEAR OUT ALL EXTRA STUFF
	BIC	#^C<CS$ROT*400>,2(SP) ; SAME HERE TOO...
	CMP	(SP),2(SP)	; WHAT'S THE STORY
	BLO	40$		; IF LOW, THEN TABLE ENTRY IS CLEAR
	BHI	50$		; IF HIGH, THEN TABLE ENTRY IS SET
	CMP	(SP)+,(SP)+	; DUMP THE OLD FLAG WORDS
	MOV	(SP)+,R0	; RESTORE R0
	BR	60$		; STILL DIFFERENT...IF WE'RE HERE...
40$:
	CMP	(SP)+,(SP)+	; DUMP THE OLD FLAG WORDS
	MOV	(SP)+,R0	; RESTORE R0
	BISB	#CS$ROT,C$SFLG+1(R0) ; SET THE TABLE ENTRY FLAGS WORD
	CMP	C$SFLG(R0),C$SFLG(R2) ; ARE THEY EQUAL NOW??
	BEQ	SCTCMT		; IF EQ, YES, CONTINUE
	BR	60$		; NO, STILL DIFFERENT
50$:
	CMP	(SP)+,(SP)+	; AGAIN, DUMP THE OLD FLAG WORDS
	MOV	(SP)+,R0	; RESTORE R0
	BIS	#<CS$ROT*400>,C$SFLG(R2) ; SET THE LOCAL ENTRY 'SAV' FLAG BIT
	CMP	C$SFLG(R0),C$SFLG(R2) ; ARE THEY EQUIVALENT NOW??
	BEQ	SCTCMT		; IF EQ, YES...
60$:				; NO, TELL THE USER AND CONTINUE
	MOV	(PC)+,R1	;GET ERROR/SEVERITY
	.BYTE	E$R16,S$V0	;DIAGNOSTIC
	TST	-(R2)		; POINT TO FIRST HALF OF MODULE NAME
	CALL	$ERMSG		;OUTPUT ERROR MESSAGE

;
; BUILD CONTROL SECTION MAPPING TABLE ENTRY
;

SCTCMT:
	TST	R3		; IS THIS A DUMMY PSECT ENTRY?
	BNE	30$		; IF YES - DON'T BUILD MAPPING TABLE
	MOV	$CRVEL,R1	; GET VIRTUAL ADDRESS OF CURRENT
	BEQ	5$		; IF EQ DUMMY ELEMENT
	CALL	$WRMPG		; WRITE MARK ELEMENT DESCRIPTOR
5$:				;
	INC	E$LNUM(R4)	;INCREMENT SECTION NUMBER
	MOV	E$LNUM(R4),R1	;GET HIGHEST SECTION NUMBER
	MOV	R1,R3		;SAVE FOR LATER
	INC	R1		;INCREMENT TO NEXT SECTION NUMBER
	ASL	R1		;CONVERT TO BYTES
	ASL	R1		;
	CALL	$ALBLK		;ALLOCATE STORAGE
	MOV	R0,-(SP)	;SAVE NEW TABLE ADDRESS
	MOV	E$LCMT(R4),R1	;GET ADDRESS OF CURRENT TABLE
	BEQ	20$		;IF EQ NONE
	ASL	R3		;CONVERT SECTION NUMBER TO WORD COUNT
	MOV	R3,R2		;SET LOOP COUNT
10$:	MOV	(R1)+,(R0)+	;MOVE CMT TO NEW LOCATION
	SOB	R2,10$		;REPEAT
	MOV	R0,-(SP)	;SAVE ADDR OF NEXT IN TABLE
	MOV	#$FRHD,R0	;GET ADDRESS OF FRRE SPACE HEADER
	MOV	R3,R1		;SET SIZE OF BLOCK TO RELEASE
	ASL	R1		;CONVERT WORD COUNT TO BYTE COUNT
	MOV	E$LCMT(R4),R2	;GET ADDRESS OF BLOCK TO RELEASE
	CALL	$RLCB		;RELEASE OLD TABLE
	MOV	(SP)+,R0	;RETRIEVE NEXT IN TABLE
20$:	MOV	(SP)+,E$LCMT(R4);SET ADDRESS OF NEW CMT TABLE
	MOV	(SP)+,(R0)	;SET LINK TO TABLE ENTRY
	MOV	(R0)+,CRVSC	; SET VIRTUAL ADDRESS OF CURRENT SEGMENT
	MOV	LCLSYM+10,(R0)	; SET MAX LENGTH OF SECTION
	CMP	#^R$$S,LCLSYM+2 ; WE'RE LOOKING FOR $$SGD1, IS IT HERE?
	BNE	25$		; IF NE, NO...
	CMP	#^RGD1,LCLSYM+4	; MAYBE, DOES SECOND HALF MATCH?
	BNE	25$		; IF NE, NO...
	MOV	(R0),SGOFF	; YES, COPY SECTION LENGTH TO 'GROUP'
				; OFFSET STORAGE
25$:
	MOV	(SP)+,R3	; RESTORE R3
	RETURN			;
30$:
	MOV	(SP)+,CRVSC	; SET VIRTUAL ADDR. OF CURRENT SECTION
	MOV	(SP)+,R3	; RESTORE R3 BEFORE RETURNING
	RETURN

;
; INTERNAL SYMBOL
;

INTSYM:	RETURN			;IGNOR-UNSUPPORTED FEATURE

;
; TRANSFER ADDRESS
;

XFRADR:				;
	CMP	#1,LCLSYM+10	; DUMMY TRANSFER ADDRESS
	BEQ	60$		;IF EQ YES
	CMP	$CRVSG,$RTSEG	; CURRENT=ROOT?
	BNE	40$		;IF NE NO
	MOV	#$XFRAD,R2	;ASSUME TASK XFR ADDRESS
	BIT	#SW$DA,E$LSWT(R4);DEBUGGING AID?
	BEQ	10$		;IF EQ NO
	MOV	#$ODTAD,R2	;SET ODT XFR ADDRESS
10$:	CMP	#1,(R2)		;XFR ADDRESS ALREADY DEFINED?
	BNE	30$		;IF NE YES
	MOV	R2,-(SP)	;SAVE VECTOR ADDRESS
	ADD	#S$GCST,R0	;POINT TO SECTION TABLE HEADER
	CALL	$SRCH		;SEARCH SECTION TABLE
	MOV	(SP),R2		; RETRIEVE VECTOR ADDRESS
	MOV	R1,(SP)		; SAVE VIRTUAL ADDRESS OF ENTRY
	BCS	40$		;IF CS NO FIND EM
	BITB	#CS$IND,C$SFLG(R0);INDIRECT REFERENCE?
	BNE	40$		;IF NE YES
	MOV	LCLSYM+10,R1	; GET OFFSET ADDRESS
	BITB	#CS$REL,C$SFLG(R0);ABS SECTION?
	BEQ	20$		;IF EQ YES
	ADD	C$SCUR(R0),R1	;ADD IN CURRENT BASE
	BCS	40$		;IF CS ADDRESS OVERFLOW
20$:	BIT	#1,R1		;ODD ADDRESS?
	BNE	40$		;IF NE YES
	MOV	R1,(R2)+	;SET TRANSFER ADDRESS
	MOV	(SP)+,(R2)	; SET SECTION TABLE ENTRY ADDRESS
	BR	60$		;

;
; MULTIPLE DEFINITION OF TRANSFER ADDRESS
;

30$:				;
	MOV	#MODN,R2	; POINT TO MODULE NAME
	MOV	S$GNME(R5),4(R2);INSERT SEGMENT NAME
	MOV	S$GNME+2(R5),6(R2);
	MOV	(PC)+,R1	;GET ERROR/SEVERITY
	.BYTE	E$R17,S$V0	;DIAGNOSTIC
	BR	50$		;

;
; ILLEGAL TRANSFER ADDRESS
;

40$:				;
	TST	(SP)+		; CLEAN STACK
	MOV	#MODN,R2	; POINT TO MODULE NAME
	MOV	10.(R2),8.(R2)	;MOVE OFFSET ADDRESS
	MOV	(PC)+,R1	;GET ERROR/SEVERITY
	.BYTE	E$R18,S$V0	;DIAGNOSTIC
50$:	CALL	$ERMSG		;OUTPUT ERROR MESSAGE
60$:	RETURN			;

;
; SYMBOL DECLARATION
;

ALDSYM:				; AUTOLOADABLE GSD PROCESSOR ENTRYPOINT
	CLR	SKPALV		; DON'T SKIP OVER THIS SYMBOL
SYMDCL:
	MOV	#1,SYMFLG	; FOUND GLOBAL SYMBOL DEFINITION
	TST	SKPALV		; SKIP SYMBOLS DEFINED IN $$ALVC?
	BEQ	2$		; IF EQ NO
	RETURN			; DON'T PROCESS THIS SYMBOL
2$:
	MOV	R3,-(SP)	; SAVE R3
	MOV	R1,R3		;COPY LOCAL DESCRIPTOR ADDRESS
	MOVB	S$YFLG(R3),R2	; COPY FLAGS
	BICB	#SY$LIB,S$YFLG(R3);CLEAR LIBRARY DEFINITION FLAG
	BIT	#SW$RL,E$LSWT(R4);RESIDENT LIBRARY ELEMENT?
	BEQ	5$		; IF EQ NO

	BIT	#SW$SUP,E$LSWT(R4)	; IS THIS FROM A SUPER-MODE LIBRARY
	BNE	200$			; IF NE YES

	BITB	#SY$LIB,R2	; LIBRARY RELOCATION PERFORMED?
	BEQ	3$		; IF EQ NO
	BR	201$		; DO RELOCATION

200$:	BITB	#SY$DEF,S$YFLG(R3)	; IS THIS A REFERENCE?
	BEQ	305$			; IF EQ NO - DON'T ASSUME SUPERMODE

	BITB	#SY$REL,S$YFLG(R3)	; IS THIS A RELATIVE SYMBOL?
	BEQ	3$			; IF EQ NO - DON'T RELOCATE
201$:
	MOV	E$LLGH(R4),R2	; GET LIBRARY LIST ADDRESS
	ADD	L$DSA(R2),S$YVAL(R3) ; RELOCATE SYMBOL
	BICB	#SY$REL,S$YFLG(R3) ; MAKE SYMBOL ABSOLUTE
3$:				;
	BISB	#SY$LIB,S$YFLG(R3);SET LIBRARY DEFINITION FLAG
	BIT	#SW$SUP,E$LSWT(R4) ; SUPERVISER MODE LIBRARY?
	BEQ	5$		; IF EQ NO
	TST	$CMPRT		; BUILDING SUPERVISOR-MODE LIBRARY?
	BNE	5$		; IF NE YES
	MOVB	S$YFLG(R3),S$YFLG+1(R3) ; COPY FLAG BYTE
	BIT	#SW$SV,E$LSWT(R4)  ; WE NEED SUPER-MODE VECTORS?
	BNE	305$		   ; IF NE, NO...FAKE A NORMAL SYMBOL
	BIS	#SY$SUP,S$YFLG(R3) ; SET SUPER-MODE FLAG...
305$:
	BIT	#SY$WK,S$YFLG(R3) ; WEAK DEFINITION/REFERENCE
	BEQ	306$		; IF EQ, NO...STRONG LIKE BULL!
	BIS	#SY$RS0,S$YFLG(R3) ; YES, BUT REMEMBER IT FOR LATER.
306$:
	BIT	#SY$REL,S$YFLG(R3) ; IS THIS A PIC SUPER-MODE LIBRARY?
	BEQ	4$		   ; IF EQ, NO
	BIC	#<SY$SAB!SY$WK>,S$YFLG(R3) ; CLEAR BOTH BITS 'CAUSE IT'S PIC
4$:
	BIC	#SY$WK,S$YFLG(R3)  ; CLEAR WEAK QUALIFIER IF IT'S A .ABS. LIBRAR
	CMP	S$YM(R1),AUTONM	; SYMBOL FOR AUTOLOAD VECTOR?
	BNE	5$		; IF NE NO
	CMP	S$YM+2(R1),AUTONM+2 ; MAYBE
	BNE	5$		; IF NE NO
	ADD	$SUPOFF,S$YM+2(R1) ; CHANGE SYMBOL $AUTO'N'  WHERE N =1 TO 8

5$:	BITB	#SY$DEF,S$YFLG(R3);SYMBOL DEFINITION?
	BEQ	30$		;IF EQ NO
	BIT	#SW$MA,E$LSWT(R4) ; ELEMENT INCLUDED IN MAP?
	BEQ	6$		; IF EQ YES
	BISB	#SY$EXC,S$YFLG+1(R3) ; SET EXCLUSION FLAG
6$:				;

	BITB	#SY$DEF,S$YFLG(R3)	; IS THIS A REFERENCE?
	BEQ	30$			; IF EQ NO - DON'T ASSUME SUPERMODE

	MOV	#CRSCT,R0	; GET POINTER TO CURRENT SECTION DATA
	BITB	#CS$REL,C$SFLG(R0) ; ABS SECTION?
	BEQ	30$		; IF EQ YES
	BITB	#CS$ALO,C$SFLG(R0) ; OVERLAID?
	BNE	10$		; IF NE YES
	BIT	#SY$ATL,S$YFLG(R3) ; IS THE INPUT SYMBOL AUTOLOADABLE?
	BNE	10$		; IF NE YES...DON'T UPDATE ENTRYPOINT ADDRESS
	BIT	#SY$REL,S$YFLG(R3) ; IS THE SYMBOL ABSOLUTE?
	BEQ	10$		; IF EQ, YES...DON'T RELOCATE TO CURRENT
				; SECTION BASE.
	ADD	C$SCUR(R0),S$YVAL(R3) ; ADD RELOCATION BIAS
10$:				;
	BITB	#CS$TYP,C$SFLG(R0) ; "I" SECTION?
	BNE	30$		; IF NE NO
	BITB	#CS$ATL,C$SFLG(R0) ; SECTION AUTOLOAD?
	BNE	20$		;IF NE YES
	BIT	#SW$AL,E$LSWT(R4);ELEMENT AUTOLOAD?
	BNE	20$		;IF NE YES
	BIT	#SG$ATL,S$GSTS(R5) ; SEGMENT AUTOLOAD?
	BEQ	30$		;IF EQ NO
20$:	BISB	#SY$ATL,S$YFLG(R3);SET AUTOLOAD FLAG
30$:				;
	CMP	$SZSEG,#S$ZSEG	; RESIDENT SEGMENT DESCRIPTOR MAX LENGTH?
	BHIS	40$		; IF HIS YES, NO FURTHER TESTS NEEDED
	BITB	#SY$DEF,S$YFLG(R3) ; SYMBOL REFERENCE?
	BNE	40$		; IF NE NO
	CMP	S$YM(R3),LOADNM	; MANUAL LOAD CALL
	BNE	40$		; IF NE NO
	CMP	S$YM+2(R3),LOADNM+2 ; CHECK SECOND HALF OF NAME
	BNE	40$		; NOT MANUAL LOAD REFERENCE
	ADD	#4,$SZSEG	; INCREASE RESIDENT SEGMENT DESCRIPTOR SIZE
40$:				;
	BIT	#SW$CLS,E$LSWT(R4) ; THIS ELEMENT FROM A CLUSTER LIBRARY?
	BEQ	50$		; IF EQ, NO
	CMP	#^R$MA,S$YM(R3)	; IS FIRST HALF A '$MA'?
	BNE	50$		; IF NE, NO...
	CMP	#^RFKR,S$YM+2(R3) ; IS SECOND HALF A 'FKR'?
	BNE	45$		; IF NE, NO
	MOV	#^RFKC,S$YM+2(R3) ; SET SECOND HALF TO 'FKC' TO CREATE A
				; REFERENCE TO '$MAFKC' INSTEAD OF '$MAFKR'
	BR	50$
45$:
	CMP	#^RRKR,S$YM+2(R3) ; IS SECOND HALF A 'RKR'?
	BNE	50$		; IF NE, NO
	MOV	#^RRKC,S$YM+2(R3) ; SET SECOND HALF TO 'RKC' TO CREATE A
				; REFERENCE TO '$MARKC' INSTEAD OF '$MARKR'
;
; THIS NEXT SECTION IS AN ELEGANT HACK TO FORCE THE LARGEST VERSION OF
; FSR5 IF THE USER IS LINKING AGAINST FCSRES.  THE SYSLIB MODULE FSR5R 
; IS EXPANDED TO THE MAXIMUM SIZE, AND THE REFERENCE TO .FSR5 IS CHANGED 
; TO .FSR5R IF LINKING TO FCSRES
;
50$:
	CMP	#^R.FS,S$YM(R3) ; IS THIS ".FS"
	BNE	60$		; NOPE..FORGET THE WHOLE THING
	CMP	#^RR5,S$YM+2(R3); OK...IS SECOND HALF RIGHT?
	BNE	60$		; NO AGAIN...
	BITB	#SY$DEF,S$YFLG(R3) ; IS THIS A SYMBOL DEFINITION?
	BNE	60$		; IF NE, YES...LEAVE IT ALONE.
	MOV	R5,-(SP)	; SAVE OUR SANITY
	MOV	#$LBRHD-L$DNXT,R5 ; GET LISTHEAD ADDRESS MINUS OFFSET
55$:				;
	MOV	L$DNXT(R5),R5	; GET NEXT ENTRY
	BEQ	57$		; IF EQ DONE
	CMP	#^RFCS, L$DNME(R5) ; IS REQUEST FOR FCSRES LIBRARY?
	BNE	55$		; NO, LOOK AGAIN
	CMP	#^RRES, L$DNME+2(R5) ; IS REQUEST FOR FCSRES LIBRARY?
	BEQ	56$		; NO, LEAVE IT ALONE AND LOOK AGAIN
	CMP	#^RFSL, L$DNME+2(R5) ; IS REQUEST FOR FCSFSL LIBRARY?
	BNE	55$		; NO, LEAVE IT ALONE AND LOOK AGAIN
56$:	MOV	#^RR5R,S$YM+2(R3) ;CHANGE REFERENCE TO FSR5R
57$:
	MOV	(SP)+,R5	; RESTORE R5
60$:
	MOV	#-1,SYDEF	; SET PASS COUNT FLAG
	MOV	#$WSRCS,-(SP)	;SET ADDRESS OF SEARCH ROUTINE
SYMSRC:	CALL	@(SP)+		;SEARCH FOR SYMBOL
	BCC	1$		;IF CC FOUND ENTRY
	JMP	SYMINS		;
1$:	BITB	#SY$DEF,S$YFLG(R3);CURRENT SYMBOL DEFINITION?
	BEQ	2$		; IF EQ NO
	JMP	SYMDEF		; YES
2$:

;
; CURRENT IS SYMBOL REFERENCE
;
; REGISTER CONTENTS AT THIS POINT:
;	R0 = ADDRESS OF FOUND SYMBOL IN INTERNAL TABLE (DEFINITION)
;	R3 = ADDRESS OF LOCAL SYMBOL PROTOTYPE IN INPUT STREAM (REFERENCE)
;


	.IF DF D$PRCL & D$TRAC

		.IF DF D$PRC1

	CALL	SYMDP0		; DISPLAY THE SYMBOL REFERENCE
	CALL	SYMTRP		; AND TRAP

		.ENDC	; D$PRC1

	.ENDC	; D$PRCL & D$TRAC

	MOV	$CRVSM,SYENT+2	; SAVE THE FOUND SYMBOL'S VIRTUAL ADDRESS
	MOV	(SP)+,R2	;CLEAN STACK BUT SAVE ADDRESS
	TST	R1		; FIND IN CURRENT SEGMENT?
	BNE	5$		; IF NE NO
	MOV	#SY$WK,R2	; COPY FLAG
	ADD	#S$YFLG,R0	; POINT TO FLAGS BYTE
	ADD	#S$YFLG,R3	; ...
	BITB	R2,(R3)		; HAVE WEAK REFERENCE?
	BNE	33$		; IF NE YES, IGNORE
	BITB	R2,(R0)		; FIND WEAK REFERENCE?
	BNE	3$		; IF NE YES
	BIT	#SU$PLB,$SWOVR	; LINKING TO SUPERVISOR MODE LIBRARY
	BEQ	33$		; IF EQ NO
	TST	$CMPRT		; BUILDING SUPERVISOR-MODE LIBRARY?
	BNE	33$		; IF NE YES
	CMP	$CRVSG,$RTSEG	; CURRENT ROOT?
	BNE	33$		; IF NE NO
	BIT	#SY$SUP,(R0)	; SUPERVISOR MODE LIBRARY
	BEQ	33$		; IF EQ NO
	BIT	#SY$SAB,(R0)	; RESOLVE AS IS? (SYMBOL FROM ASECT OR
				; HAS BEEN SEEN BEFORE)
	BNE	33$		; IF NE YES
	BIT	#SY$RS0,(R0)	; IS THIS A WEAKLY DEFINED SYMBOL??
	BNE	33$		; IF NE, YES...WILL BECOME AUTO'N'
				; REFERENCE TO BE LATER PATCHED UP.
	BIT	#SW$SV,E$LSWT(R4) ; VECTORS WANTED?
	BNE	33$		; IF NE NO
	MOV	$CRVSM,R1	; GET VIRTUAL ADDRESS OF FOUND SYMBOL
	BIS	#SY$SAB,(R0)	; FLAG AS HAVING VECTOR
	MOV	R5,R2		; GET ADDRESS OF CURRENT SEGMENT
	CALL	LNKSUP		; LINK INTO LIST
	BR	33$		;
3$:
	BICB	R2,(R0)		; CLEAR FLAG
	MOV	CRVSC,S$YCMT-S$YFLG(R0) ; SET ADDRESS OF CURRENT SECTION
	MOV	$CRVSM,R1	; GET VIRTUAL ADDRESS OF REFERENCE
	CALL	$WRMPG		; WRITE-MARK PAGE
	INC	$MSYMC		; INCREMENT MASTER UNDEFINED COUNT
	INC	S$GUND(R5)	; INCREMENT SEGMENT UNDEFINED COUNT
	CALL	$BLDRF		; BUILD REFERENCE LIST ENTRY
	BR	33$		;
5$:				;
	MOV	R2,-(SP)	;RESTORE RETURN ADDRESS
	MOV	#SYDEF,R2	;GET ADDRESS OF FOUND SYMBOL FLAG
	BITB	#SY$DEF,S$YFLG(R0);SYMBOL DEFINITION?
	BEQ	SYMSRC		;IF EQ NO-CONTINUE SEARCH
	BITB	#SY$IND,S$YFLG(R0) ; INDIRECT REFERENCE?
	BNE	SYMSRC		; IF NE YES - CONTINUE SEARCH
	INC	(R2)		; FLAG WE'VE BEEN THIS WAY
	TST	(R2)		;TEST FOUND FLAG
	BNE	20$		;IF NE BEEN HERE MORE THAN ONCE
	CALL	40$		;SET UP INITIAL PARAMETERS
10$:	CALL	@(SP)+		;CONTINUE SEARCH
	BCS	30$		;IF CS DONE
	BITB	#SY$DEF,S$YFLG(R0);SYMBOL DEFINED?
	BEQ	20$		;IF EQ NO
	CALL	40$		;COMPARE PARAMETERS
	BCC	10$		;IF CC OKAY
20$:	TST	(SP)+		;CLEAN STACK
25$:
	JMP	80$		; AMBIGUOUS SYMBOL DEFINITION

;
; ALL PATHS SEARCHED-ALLOCATE INDIRECT SYMBOL TABLE ENTRY
;

30$:	TST	SYDEF		;DEFINITION FOUND?
	BEQ	25$		; AMBIGUOUS SYMBOL DEFINITION
	CMP	SRVSG,$RTSEG	; FOUND IN MAIN ROOT?
	BNE	32$		; IF NE NO
	BIT	#SU$PLB,$SWOVR	; LINKING TO SUPERVISOR MODE LIBRARY?
	BEQ	33$		; IF EQ NO
	TST	$CMPRT		; BUILDING A SUPERVISOR-MODE LIBRARY?
	BNE	33$		; IF NE YES
	CALL	SUPTST		; SYMBOL FROM SUPERVISOR MODE LIBRARY?
	BCS	33$		; IF CS NO
	BR	35$		; YES - INSERT
32$:
	TST	SRCPF		;FOUND ON PATH UP?
	BPL	34$		;IF PL YES
33$:				;
	MOV	SYENT+2,R1	; RESTORE THE FOUND SYMBOL'S VIRTUAL ADDRESS
	CALL	$CVRL		; RETURNS R0 -> LOCATION IN DYNAMIC MEMORY
	BIT	#SY$ATL,S$YFLG(R0) ; IS THE SYMBOL AUTOLOADABLE
	BNE	330$		; IF NE, YES...LINK INTO AUTOLOAD LISTHEAD
	JMP	SYMRET		; IF EQ, NO...
330$:
;
;+
; WHAT WE ARE TRYING TO ACCOMPLISH IS TO INSERT ANY SYMBOL WHICH HAS BEEN
; DETERMINED TO BE DEFINED IN A SYMBOL TABLE FILE OF A RESIDENT OVERLAID
; LIBRARY INTO THE AUTOLOAD LISTHEAD ONLY IF IT HAS BEEN REFERENCED. THE ONLY
; SPECIAL CASING OF THE SYMBOL MUST BE DONE FOR THE ROOT OF THE USER TASK,
; SINCE ANY OTHER REFERENCE UP-TREE WLL CREATE AN INDIRECT ENTRY IN THAT
; SEGMENT'S SYMBOL TABLE.
;-
;
	BIT	#SY$LIB,S$YFLG(R0) ; IS THE SYMBOL FROM A LIBRARY?
	BNE	331$		; IF NE, YES...NEED TO AUTOLOADED
	JMP	SYMRET		; IF EQ, NO...DIRECT REFERENCE DOWNTREE
331$:
;
; WHAT WE MUST DO NOW IS ASSURE THE USER THAT THERE WILL BE ONLY ONE AUTOLOAD
; VECTOR FOR EACH REFERENCED SYMBOL. SINCE THE 'EXCLUDE-FROM-MAP-' BIT IS SET
; WHEN WE FIND A DEFINITION AND CLEARED WHEN WE REFERENCE IT THE FIRSST TIME,
; THEN THAT BIT, IN CONJUNCTION WITH THE SY$ATL AND SY$LIB BITS DETERMINE IF
; THE SYMBOL HAS BEEN REFERENCED BEFORE AND HAS BEEN ENTERED INTO THE ROOT
; SEGMENT'S AUTOLOAD LISTHEAD.
;
	BITB	#SY$EXC,S$YFLG+1(R0) ; HAVE WE PROCESSED AN AUTOLOAD REQUEST
				     ; FOR THIS SYMBOL YET??
	BNE	332$		     ; IF NE, NO...
	JMP	SYMRET		     ; IF EQ, YES...WE ONLY NEED ONE, SO EXIT
332$:
	BICB	#SY$EXC,S$YFLG+1(R0) ; CLEAR THE 'EXCLUDE' BIT 'CAUSE
				; WE WANT TO SHOW THIS SYMBOL IN THE MAP AND
				; FLAG THE FACT THAT WE'VE ALREADY GENERATED AN
				; AUTOLOAD REQUEST FOR THE SYMBOL.
	MOVB	S$YFLG(R0),SYFLG ; SAVE THE SYMBOL'S FLAG BYTE
	MOV	$CRVSM,SYDEF	; SET THE FOUND SYMBOL'S VIRTUAL ADDRESS
	MOV	$CRVSM,R1	; SET VIRTUAL ADDRESS OF FOUND SYMBOL....
	CALL	$WRMPG		; WRITE MARK THE PAGE OF THE FOUND SYMBOL
	MOV	R5,R2		; COPY THE REAL ADDRESS OF THE SEGMENT...
	CMP	$RTSEG,$CRVSG	; IS THE CURRECT SEG ALSO THE ROOT SEGMENT?
	BEQ	336$		; IF EQ, YES...BYPASS FETCHING ROOT FROM VIRT
	MOV	R0,-(SP)	; SAVE THE SYMBOL'S REAL ADDRESS
	MOV	R1,-(SP)	; SAVE THE SYMBOL'S VIRTUAL ADDRESS
	MOV	$RTSEG,R1	; GET ROOT'S VIRTUAL MEMORY ADDRESS
	CALL	$CVRL		; FETCH IT AND...
	CALL	$WRMPG		; WRITE-MARK THE PAGE
	MOV	R0,R2		; COPY THE ROOT'S REAL ADDRESS
	MOV	(SP)+,R1	; RESTORE THE SYMBOL'S VIRTUAL ADDRESS
	MOV	(SP)+,R0	; RESTORE THE SYMBOL'S REAL ADDRESS
336$:
	CALL	LNKATL		; AND LINK IT INTO THE AUTOLOAD LISTHEAD
	JMP	SYMRET		; BUT DO NOT MAKE AN INDIRECT ENTRY...
34$:	MOV	#S$YLGH,R1	;GET SIZE OF SYMBOL ENTRY
	CALL	$ALSVB		; ALLOCATE SMALL VIRTUAL CORE BLOCK
	CALL	$LCKPG		; LOCK DESCRIPTOR IN MEMORY
	MOV	SYDEF,R2	; GET VIRTUAL ADDRESS OF REAL SYMBOL

	.IF DF D$PRCL & D$TRAC

	MOV	R2,-(SP)	; SAVE VALUE OF SYENT IN R2
	MOV	$CRVSM,R2	; SET VIRTUAL ADDRESS OF REAL SYMBOL
	BEQ	340$		; IF EQ, TRAP HERE...
	CMP	#-1,R2		; IS THE V.A. A -1?
	BEQ	340$		; IF EQ TO -1, TRAP ALSO
	BR	341$		; IF NEITHER, FORGET THE WHOLE THING
340$:
	BPT
	MOV	(SP)+,R2	; RESTORE VALUE OF SYENT IN R2
341$:

	.ENDC	; D$PRCL & D$TRAC

	MOV	R2,S$YVAL(R0)	; SET INDIRECT ENTRY ADDRESS
	BISB	#SY$IND,S$YFLG(R0);SET INDIRECT FLAG
	BISB	#SY$DEF,S$YFLG(R0);SET DEFINITION FLAG
	BITB	#SY$ATL,SYFLG	; AUTOLOAD SYMBOL
	BEQ	35$		;IF EQ NO
	MOV	R5,R2		; COPY REAL ADDRESS OF SEGMENT
	CALL	LNKATL		; LINK ITEM TO AUTOLOAD LIST
	CALL	$CVRL		; CONVERT ENTRY TO REAL ADDRESS
35$:				;
	CALL	$UNLPG		; UNLOCK NEW ENTRY
	JMP	SYMIN1		; INSERT ENTRY IN CURRENT SEGMENT

;
; COMPARE PARAMETERS
;

40$:	BITB	#SY$IND,S$YFLG(R0);INDIRECT REFERENCE?
	BEQ	50$		;IF EQ NO
	MOV	S$YVAL(R0),R0	;GET ADDRESS OF REAL ENTRY
	BR	60$		;
50$:				;
	MOV	S$YFLG(R0),SYFLG ; SAVE ENTRY FLAGS
	MOV	$CRVSM,R0	; GET VIRTUAL ADDRESS OF DEFINITION
	MOV	R0,SYDEF	; SET DEFINITION FLAG
	MOV	R1,SRCPF	;SET PATH FLAG
	MOV	$CRVSR,SRVSG	; SET VIRTUAL ADDRESS OF SEGMENT
60$:	CMP	R0,SYENT	;SAME AS LAST?
	SEC			;ASSUME ANSWER IS NO
	BNE	70$		;IF NE NO
	CLC			;CLEAR CARRY
70$:	MOV	R0,SYENT	;SET ADDRESS OF LAST
	RETURN			;

;
; AMBIGUOUS SYMBOL DEFINITION
;

80$:				;
	MOV	#MODN,R2	; GET ADDRESS OF MODULE NAME
	MOV	(PC)+,R1	;GET ERROR/SEVERITY
	.BYTE	E$R20,S$V0	;DIAGNOSTIC
	CALL	$ERMSG		;OUTPUT ERROR MESSAGE
	JMP	SYMINS		;
;
; CURRENT IS SYMBOL DEFINITION
;

SYMDEF:	TST	R1		;FIND IN CURRENT SEGMENT?
	BNE	10$		;IF NE NO
	MOV	$CRVSM,R1	; GET VIRTUAL ADDRESS OF SYMBOL
	CALL	$DELRF		; REMOVE REFERENCE LIST ENTRY
	CALL	$LCKPG		; LOCK PAGE IN MEMORY
	CALL	SYMCHK		; CHECK FOR MULTIPLE DEFINITION
	BCS	5$		; IF C/S SYMBOL MULTIPLE DEFINITION
	BNE	6$		; IF NE IGNORE DUPLICATE ABS SYMBOL
	MOV	$CRVSM,R1	; GET VIRTUAL ADDRESS OF ENTRY
	CALL	$CVRL		; CONVERT TO REAL
	CALL	$WRMPG		; WRITE-MARK PAGE
	CALL	$UNLPG		; UNLOCK PAGE
	MOV	R1,SYENT	; SAVE VIRTUAL ADDRESS OF ENTRY
	MOV	S$YFLG(R0),R2	; COPY PREVIOUS FLAGS
	MOV	S$YFLG(R3),S$YFLG(R0) ; SET SYMBOL FLAGS
	BIC	#SY$WK,S$YFLG(R0) ; CLEAR WEAK QUALIFIER
	MOV	S$YFLG(R3),SYFLG ; SAVE SYMBOL FLAGS
	MOV	S$YVAL(R3),S$YVAL(R0);SET SYMBOL VALUE
	MOV	CRVSC,S$YCMT(R0) ; SET SECTION ENTRY ADDRESS
	BITB	#SY$WK,R2	; SYMBOL WEAK REFERENCE?
	BNE	45$		; IF NE YES, DON'T DECREMENT COUNTS
	DEC	S$GUND(R5)	;DECREMENT UNDEFINED SYMBOL COUNT
	DEC	$MSYMC		;DECREMENT MASTER UNDEFINED SYMBOL COUNT
	BR	45$		;

;
; MULTIPLE SYMBOL DEFINITION
;

5$:
	CALL	60$		; OUTPUT MESSAGE
6$:
	TST	(SP)+		; CLEAN STACK
	MOV	$CRVSM,R1	; GET VIRTUAL ADDRESS OF FOUND ENTRY
	CALL	$UNLPG		; UNLOCK PAGE BUFFER
	JMP	SYMRET		;
10$:				;
	MOV	R1,-(SP)	;SAVE PATH FLAG
	MOV	$CRVSM,R1	; GET VIRTUAL ADDRESS OF FOUND REFERENCE
	CALL	$CVLOK		; CONVERT TO REAL AND LOCK IN MEMORY
	CALL	$WRMPG		; WRITE MARK PAGE
	BIT	#SY$DEF,S$YFLG(R0) ; DEFINITION?
	BEQ	15$		; IF EQ NO - INSERT SYMBOL
	BIT	#SY$IND,S$YFLG(R0) ; INDIRECT REFERENCE?
	BNE	15$		; IF NE YES - INSERT SYMBOL
	BIT	#SW$SS,E$LSWT(R4) ; SELECTIVE SEARCH MODULE?
	BEQ	15$		; IF EQ NO
	TST	(SP)+		; CLEAN STACK
	MOV	$CRVSR,R1	; GET VIRTUAL ADDRESS OF SEARCH SEGMENT
	CALL	$CVLOK		; CONVERT TO REAL AND LOCK IN MEMORY
	BR	40$		; CONTINUE SEARCH
15$:
	CALL	$UNLPG		; UNLOCK PAGE WITH THE FOUND REFERENCE IN IT.
	MOV	#20$,-(SP)	; SET RETURN ADDRESS
	MOV	R3,-(SP)	;PLACE R3 ON STACK
	MOV	$CRVSR,R1	; GET VIRTUAL ADDRESS OF SEARCH SEGMENT
	CALL	$CVLOK		; CONVERT TO REAL, LOCK IN CORE
	MOV	R0,$CRSRC	; SET REAL ADDRESS OF SEARCH SEGMENT
	JMP	SYMIN0		; INSERT SYMBOL IN CURRENT SEGMENT
20$:				;
	MOV	$CRVSM,R1	; GET VIRTUAL ADDRESS OF FOUND REFERENCE
	CALL	$CVLOK		; CONVERT TO REAL, LOCK IN MEMORY
	CALL	$WRMPG		; WRITE MARK PAGE
	MOV	R0,-(SP)	; SAVE REAL ADDRESS
	CALL	SYMCHK		; CHECK FOR MULTIPLE DEFINITION
	BCS	30$		; IF C/S SYMBOL MULTIPLY DEFINED
	BNE	35$		; IF NE IGNORE DUPLICATE ABS SYMBOL
	MOV	(SP)+,R0	; RETRIEVE REAL ADDRESS OF SYMBOL
	MOV	$CRVSM,R1	; GET VIRTUAL ADDRESS OF ENTRY
	BITB	#SY$WK,S$YFLG(R0) ; FOUND WEAK REFERENCE?
	BNE	25$		; IF NE YES, DON'T DECREMENT COUNTS
	MOV	$CRSRC,R2	;GET ADDRESS OF SEARCH SEGMENT
	DEC	S$GUND(R2)	;DECREMENT UNDEFINED SYMBOL COUNT
	DEC	$MSYMC		;DECREMENT MASTER UNDEFINED SYMBOL COUNT
25$:				;
	MOV	SYENT,R2	;GET ADDRESS OF CURRENT ENTRY
	MOV	R2,S$YVAL(R0)	;SET INDIRECT ENTRY ADDRESS
	CLR	S$YSEG(R0)	;CLEAR SEGMENT ADDRESS
	BISB	#SY$IND,S$YFLG(R0);SET INDIRECT FLAG
	BISB	#SY$DEF,S$YFLG(R0);SET DEFINITION FLAG
	CMP	(SP)+,#1	; FOUND ON PATH DOWN ?
	BEQ	40$		;++021 IF EQ NO
	BITB	#SY$ATL,SYFLG	; DEFINITION AUTOLOAD SYMBOL?
	BEQ	40$		;IF EQ NO
	MOV	$CRSRC,R2	; GET REAL ADDRESS OF SEARCH SEGMENT
	MOV	$CRVSM,R1	; GET VIRTUAL ADDRESS OF REFERENCE
	CALL	LNKATL		; LINK ITEM TO AUTOLOAD LIST
	BR	40$		;
30$:				;
	CALL	60$		; MULTIPLE GLOBAL SYMBOL DEFINITION
35$:				;
	CMP	(SP)+,(SP)+	; CLEAN STACK
40$:				;
	MOV	$CRVSM,R1	; GET VIRTUAL ADDRESS OF CURRENT SYMBOL
	CALL	$UNLPG		; UNLOCK PAGE
	MOV	$CRVSR,R1	; GET VIRTUAL ADDRESS OF SEARCH SEGMENT
	CALL	$WRMPG		; WRITE-MARK PAGE
	CALL	$UNLPG		; UNLOCK PAGE
45$:				;
	CALL	@(SP)+		; CONTINUE SEARCH
	BCC	47$		; IF C/C HAVE SYMBOL
	JMP	SYMRET		; ELSE NO MORE TO PROCESS
47$:				;
	MOV	R1,-(SP)	; SAVE PATH FLAG
	MOV	$CRVSR,R1	; GET VIRTUAL ADDRESS OF SEARCH SEGMENT
	CALL	$CVLOK		; CONVER TO REAL, LOCK IN MEMORY
	MOV	R0,$CRSRC	; SAVE REAL ADDRESS
	BR	20$		; PROCESS THIS SEGMENT


;
; MULTIPLY DEFINED SYMBOL
;

60$:				;
	MOV	#MODN,R2	; GET ADDRESS OF MODULE NAME
	MOV	(PC)+,R1	;GET ERROR/SEVERITY
	.BYTE	E$R21,S$V0	;DIAGNOSTIC
	CALL	$ERMSG		;OUTPUT ERROR MESSAGE
	RETURN			;



;
; COMPLETION ROUTINE NAME
;

CMPRT:
	SAVRG			; SAVE REGISTERS 3-5
	MOV	R1,R3		; SAVE SYMBOL DESCRIPTION ADDRESS
	BIT	#SW$SUP,E$LSWT(R4) ; SUPERVISOR MODE LIBRARY?
	BEQ	20$		; IF EQ NO
	MOV	E$LLGH(R4),R2		; GET LIBRARY LIST ADDRESS
	BIT	#LD$REL,L$DFLG(R2)	; RELOCATABLE LIBRARY ?
	BEQ	1$			; IF EQ, NO...ABSOLUTE
	ADD	L$DSA(R2),S$YVAL(R3)	; RELOCATE SYMBOL
1$:
	MOV	S$YVAL(R3),CMPVA ; SAVE VALUE OF COMPLETION ROUTINE
	MOV	#22,R1		; LENGTH OF A DESCRIPTOR
	CALL	$ALBLK		; ALLOCATE A BLOCK FOR DESCRIPTOR
	MOV	#$PATHD,R1	; GET ADDRESS OF PATCH LISTHEAD
	TST	(R1)+		; EMPTY?
	BEQ	5$		; IF EQ YES
	MOV	-(R1),(R0)	; LINK INTO LIST
	MOV	R0,(R1)		;
	BR	7$		;
5$:
	MOV	R0,@(R1)+	; LINK COMPLETION ROUTINE INTO PATCH LIST
	MOV	R0,-(R1)	;
7$:
	TST	(R0)+		; SKIP OVER LINK WORD
	MOV	#1,(R0)+	; SET PATCH COUNT
	MOV	R0,-(SP)	; SAVE PATCH ADDRESS
	MOV	$RTSEG,R1	; GET V/A OF ROOT SEGMENT
	CALL	$CVRL		; CONVERT TO REAL
	CALL	$WRMPG		; WRITE MARK PAGE
	MOV	R0,R1		; GET ADDRESS
	MOV	(SP)+,R0	; RESTORE PATCH ADDRESS
	MOV	S$GNME(R1),(R0)+ ; GET SEGMENT NAME
	MOV	S$GNME+2(R1),(R0)+ ;
	MOV	#2,(R0)+	; SET PATCH TYPE - GLOBAL
	MOV	#^R$CR,(R0)+	; SET SYMBOL NAME
	MOV	#^RVC,(R0)+	;
	MOV	$SUPOF,R4	; INCLUDE OFFSET
	ASL	R4		;
	MOV	R4,(R0)+	;
	MOV	S$YVAL(R3),(R0)+ ; VALUE OF ROUTINE
	INC	$SUPOF		; UPDATE OFFSET
20$:
	RETURN
;
; LINK AN ITEM TO SEGMENT AUTOLOAD LIST
;

	.ENABL	LSB

LNKATL:				;
	INC	S$GATL+4(R2)	; INCREMENT NUMBER OF AUTOLOAD ENTRIES
	MOV	R3,-(SP)	; SAVE REGISTER
	MOV	#S$GATL,R3	; GET OFFSET TO AUTOLOAD LISTHEAD
	BR	5$		;
LNKSUP:
	INC	S$GSPL+4(R2)	; INCREMENT NUMBER OF SUPERVISOR LOAD ENTRIES
	MOV	R3,-(SP)	; SAVE
	MOV	#S$GSPL,R3	; GET OFFSET TO SUPERVISOR LOAD LISTHEAD
5$:

	.IF DF D$PRCL & D$TRAC

		.IF DF D$PRC2

	CALL	SYMDP0		; DISPLAY THE SYMBOL TO AUTOLOAD

		.ENDC	; D$PRC2

	.ENDC	; D$PRCL & D$TRAC

	MOV	R1,-(SP)	; SAVE VIRTUAL ADDRESS OF REFERENCE
	MOV	R2,-(SP)	; SAVE REAL SEGMENT DESCRIPTOR ADDRESS
	MOV	#A$LLST,R1	; GET LENGTH OF AUTOLOAD ENTRY
	CALL	$ALBLK		; ALLOCATE STORAGE
	MOV	(SP)+,R2	; RESTORE SEGMENT DESCRIPTOR ADDRESS
	ADD	R3,R2		; POINT TO LISTHEAD
	TST	(R2)+		; LIST EMPTY?
	BNE	10$		; IF NE NO
	MOV	R0,(R2)		; MAKE THIS ENTRY LAST
	BR	20$		;
10$:				;
	MOV	R0,@(R2)+	; LINK TO LAST ITEM IN LIST
20$:				;
	MOV	R0,-(R2)	; MAKE THIS ITEM LAST
	MOV	(SP),2(R0)	; SET ADDRESS OF INDIRECT ENTRY

	.IF DF D$PRCL & D$TRAC

	BEQ	40$		; IF EQ, TRAP HERE...
	CMP	#-1,2(R0)	; IS THE V.A. A -1?
	BEQ	40$		; IF EQ TO -1, TRAP ALSO
	BR	50$		; IF NEITHER, FORGET THE WHOLE THING
40$:
	BPT
50$:

	.ENDC	; D$PRCL & D$TRAC

	MOV	(SP)+,R1	; RESTORE ENTRY ADDRESS
SYMRT1:				; CORRECTS AN OUT-OF-RANGE BRANCH...
	MOV	(SP)+,R3	; RESTORE
	RETURN			;

	.DSABL	LSB


;
; CHECK FOR MULTIPLY DEFINED SYMBOLS
;

SYMCHK:				;
	CLC			; ASSUME NO MULTIPLE DEFINITION
	BITB	#SY$DEF,S$YFLG(R0) ; FIND DEFINITION?
	BEQ	30$		; IF EQ NO, EXIT
	BITB	#SY$REL,S$YFLG(R3) ; CURRENT ABSOLUTE?
	BNE	10$		; IF NE NO
	BITB	#SY$IND,S$YFLG(R0) ; INDIRECT ENTRY?
	BEQ	5$		; IF EQ NO
	MOV	S$YVAL(R0),R1	; GET VIRTUAL ADDRESS OF REAL ENTRY
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
5$:				;
	BITB	#SY$REL,S$YFLG(R0) ; ENTRY ABSOLUTE?
	BNE	10$		; IF NE NO
	CMP	S$YVAL(R0),S$YVAL(R3) ; SYMBOLS EQUIVALENT?
	BEQ	20$		; IF EQ YES
10$:				;
	BIT	#SW$SS,E$LSWT(R4) ; SELECTIVE DEFINITON MODULE
	CLC			; SET NOT MULTIPLY DEFINED
	BNE	20$		; IF NE YES - IGNORE SYMBOL
	SEC			; SET MULTIPLE DEFINITION FLAG
20$:				;
	CLZ			; SET EQUIVALENCE FLAG
30$:				;
	RETURN			;

;
; INSERT SYMBOL IN CURRENT SEGMENT
;
SYMINS:				;++008
	BITB	#SY$WK,S$YFLG(R3) ; WEAK DEFINITION OR REFERENCE
	BEQ	10$		; IF EQ, NO...CONTINUE
	JMP	SYMRET		; IF NE, YES...IGNORE
10$:
	BITB	#SY$DEF,S$YFLG(R3) ;++008 SYMBOL DEFINITION?
	BEQ	SYMIN0		;++008 NO -- CONTINUE INSERT
	BIT	#SW$SS,E$LSWT(R4) ;++008 SELECTIVE DEFINITION MODULE ?
	BEQ	SYMIN0		; IF EQ, YES...INSERT
	JMP	SYMRET		; IF NE, NO...IGNORE IT...
SYMIN0:				;++008
	MOV	#S$YLGH,R1	;++008 GET SIZE OF SYMBOL TABLE ENTRY
	BIT 	#SY$DEF,S$YFLG(R3) ; SYMBOL DEFINITION?
	BEQ	10$		; IF EQ NO
	BIT	#SY$ATL,S$YFLG(R3) ; IS THE SYMBOL AUTOLOADABLE?
	BEQ	5$		; IF EQ, NO...ORDINARY SO FAR
	ADD	#S$YLEX,R1	; IF NE, YES..MAKE ENTRY THREE WORDS LONGER FOR
				; THE SEGMENT DESCRIPTOR OFFSET VALUE, THE
				; OFFSET WHICH WILL CONTAIN THE SYMBOL'S
				; 'INDIRECT' VALUE WHICH IS ITS OFFSET INTO
				; THE AUTOLOAD VECTOR PSECT, $$ALVC, AND THE
				; VIRTUAL ADDRESS OF THE DEFINING ELEMENT. THERE
				; IS ALSO THE NEED FOR A SECONDARY CONTROL
				; SECTION TABLE ENTRY WHICH WILL CONTAIN THE
				; VIRTUAL ADDRESS OF THE PSECT $$ALVC.
5$:
	BIT	#SU$PLB,$SWOVR	; LINKING TO A SUPERVISOR LIBRARY?
	BEQ	10$		; IF EQ NO
	BIT	#SW$SUP,E$LSWT(R4) ; SUPERVISOR MODE LIBRARY?
	BEQ	10$		; IF EQ NO
	TST	$CMPRT		; BUILDING A SUPERVISOR-MODE LIBRARY?
	BNE	10$		; IF NE YES
	BIT	#SW$SV,E$LSWT(R4) ; SUPERVISOR VECTORS WANTED?
	BNE	10$		; IF NE NO
	ADD	#S$YSEX,R1	; ALLOCATE A LARGER SYMBOL BLOCK
10$:
	CALL	$ALSVB		; ALLOCATE SMALL VIRTUAL CORE BLOCK
	MOV	R1,SYENT	; SAVE ADDRESS OF SYMBOL ENTRY
	BIT	#SW$RL,E$LSWT(R4) ; IS THIS A RESIDENT LIBRARY ELEMENT?
	BEQ	15$		; IF EQ, NO...DON'T CHECK THE SY$ATL BIT
	BIT	#SY$ATL,S$YFLG(R3) ; IS THE AUTOLOAD BIT SET??
	BEQ	15$		; IF EQ, NO...JUST A REG'LAR SYMBOL...
	BISB	#SY$EXC,S$YFLG+1(R3) ; SET THE 'EXCLUDE' BIT 'CAUSE THIS SYMBOL
				; MAY NOT BE REFERENCED BY THE USER TASK (NO
				; SENSE SHOWING IT IN THE MAP IF HE DOSEN'T
				; USE IT).
	MOV	S$YVAL+2(R3),S$YSDO(R0) ; IF NE, YES...COPY THE SEG. DESC.
				        ; OFFSET...
	ADD	$SGOFF,S$YSDO(R0) ; APPLY THE 'GROUP OFFSET VALUE
	CLR	S$YVOF(R0)	; CLEAR THE OFFSET VALUE INTO $$ALVC
	CLR	S$YCVT(R0)	; CLEAR THE 'INDIRECT' SYMBOL CMT ENTRY.
;
;+
; NOTE THAT WHAT WE HAVE HERE IS A MULTIPLEXING OF THE OFFSET 'S$YCMP'.
; THE FOLLOWING DESCRIBES EXACTLY WHERE THAT OFFSET VALUE WILL BE FOR
; THE VARIOUS TYPES OF SYMBOLS...
;
; REGULAR SYMBOL	-	THERE IS NO SEGMENT DESCRIPTOR OFFSET VALUE
;
; AUTOLOADABLE SYMBOL,	-	THE SEGMENT DESCRIPTOR OFFSET VALUE IS AT
; USER-MODE LIBRARY		OFFSET 'S$YSDO' WHICH HAS THE SAME VALUE
;				AS 'S$YCMP'.
;
; AUTOLOADABLE SYMBOL,	-	THE SEGMENT DESCRIPTOR OFFSET VALUE IS AT
; SUPER-MODE LIBRARY		OFFSET 'S$YSDX' WHICH IS AT THE END OF
;				THE EXTENDED SYMBOL TABLE ENTRY FOR A
;				SUPER-MODE LIBRARY ENTRY WITH SUPER-MODE
;				VECTORS SPECIFIED.
;
;
; NOW THAT WE'VE DETECTED A SYMBOL ENTRY FROM A SYMBOL TABLE FILE THAT'S GOT
; TO BE RESOLVED THROUGH AN AUTOLOAD VECTOR, WE NEED TO RESET 'CRVSC' TO
; CONTAIN THE VIRTUAL ADDRESS OF THE LIBRARY'S ROOT SEGMENT PSECT. FOR
; THIS RELEASE, WE'VE GOT THE ROOT SEGMENT PSECT NAME DERIVED FROM THE
; MODULE NAME WHICH IS DEFINED BY THE .NAME DIRECTIVE IN THE OVERLAY DESCRIPTOR
; LANGUAGE. THIS IS A DIRECT OUTCOME OF THE /LI SWITCH WHEN USED IN CONJUNCTION
; WITH THE /PI SWITCH. IF THE LIBRARY HAS BEEN BUILT /-PI, THEN THE PSECT WE
; HAVE TO LOOK FOR IS '. ABS.'
;
;-
	CALL	FNDSEC		; LOOK FOR THE PROGRAM SECTION NAME
				; THAT'S BEEN STORED IN THE ELEMENT DESCRIPTOR
				; AT OFFSET 'E$LMOD'.
	BCC	15$		; IF C-CLR, GOT A SECTION ENTRY
	BPT			; IF C-SET, DON'T HAVE A SECTION ENTRY...
				; SO CRAP OUT NOW...
15$:
	MOV	S$YFLG(R3),SYFLG ; SAVE SYMBOL FLAGS
	MOV	S$YFLG(R3),S$YFLG(R0);SET SYMBOL FLAGS
	BIC	#SY$WK,S$YFLG(R0) ; CLEAR WEAK QUALIFIER
	MOV	S$YVAL(R3),S$YVAL(R0);SET SYMBOL VALUE
	MOV	CRVSC,S$YCMT(R0) ; SET SECTION ENTRY ADDRESS
	MOV	$CRVSG,S$YSEG(R0) ; SET VIRTUAL ADDRESS OF CURRENT SEGMENT
	BIT	#SY$SUP,S$YFLG(R3) ; FROM SUPERVISOR MODE LIBRARY?
	BEQ	20$		; IF EQ NO
	MOV	CMPVA,S$YCMP(R0) ; SET VIRTUAL ADDRESS OF COMPLETION ROUTINE
	MOV	S$YVAL(R3),S$YCMP+2(R0) ; SET DEFINITION VALUE
	MOV	$SUPOF,S$YCMP+4(R0)  ; SET THE SUPER-MODE AUTOLOAD OFFSET VALUE
	BITB	#SY$ATL,S$YFLG(R3) ; IS THIS SYMBOL AUTOLOADABLE?
	BEQ	20$		; IF EQ, NO...JUST A SUPER-MODE DEFINITION
	BISB	#SY$EXC,S$YFLG+1(R3) ; SET THE 'EXCLUDE' BIT 'CAUSE THIS SYMBOL
				; MAY NOT BE REFERENCED BY THE USER TASK (NO
				; SENSE SHOWING IT IN THE MAP IF HE DOSEN'T
				; USE IT).
	MOV	S$YVAL+2(R3),S$YSDX(R0) ; IF NE, YES...STORE THE OFFSET VALUE
				; INTO THE SYMBOL TABLE IN THE EXTENDED AREA.
	ADD	$SGOFF,S$YSDX(R0) ; APPLY THE 'GROUP' OFFSET VALUE TO THE
				; EXTENDED AREA FOR SUPER-MODE LIBRARY SYMBOL.
	CLR	S$YVOX(R0)	; CLEAR THE OFFSET VALUE INTO $$ALVC, BUT IN
				; THE EXTENDED AREA IF THE SYMBOL WAS DEFINED
				; IN A SUPER-MODE LIBRARY.
	CLR	S$YCVX(R0)	; CLEAR THE 'INDIRECT' SYMBOL CMT ENTRY, BUT IN
				; THE EXTENDED AREA IF THE SYMBOL WAS DEFINED
				; IN A SUPER-MODE LIBRARY.
20$:
	BITB	#SY$DEF,S$YFLG(R3);SYMBOL DEFINITION?
	BNE	SYMIN1		;IF NE YES
	CLR	S$YCMT(R0)	;CLEAR SECTION ENTRY ADDRESS
	INC	S$GUND(R5)	;INCREMENT UNDEFINED SYMBOL COUNT
	INC	$MSYMC		;INCREMENT MASTER UNDEFINED SYMBOL COUNT
	CALL	$LCKPG		; LOCK PAGE IN MEMORY
	CALL	$BLDRF		; BUILD REFERENCE LIST ENTRY
	CALL	$UNLPG		; UNLOCK PAGE
SYMIN1:	MOV	S$YM(R3),S$YM(R0);SET FIRST HALF OF SYMBOL
	MOV	S$YM+2(R3),S$YM+2(R0);SET SECOND HALF OF SYMBOL

	.IF DF D$PRCL & D$TRAC

		.IF DF D$PRC0

	CALL	SYMDP0		; DISPLAY THE SYMBOL TO INSERT

		.ENDC	; D$PRC0

	.ENDC	; D$PRCL & D$TRAC

	MOV	$CRVSG,R0	; GET VIRTUAL ADDRESS OF CURRENT SEGMENT
	ADD	#S$GSTB/2,R0	; POINT TO SYMBOL TABLE LISTHEAD
	MOV	R1,-(SP)	; SAVE VIRTUAL ADDRESS OF SYMBOL
	CALL	$SRCHI		;SEARCH FOR INSERT
	CALL	$ISYM		;INSERT SYMBOL
	CMP	#1,$NUMSG	; SINGLE SEGMENT TASK?
	BEQ	10$		; IF EQ YES
	MOV	$CRVSG,-(SP)	; PUSH VIRTUAL ADDRESS OF CURRENT SEGMENT
	MOV	S$YM+2(R3),-(SP) ; PUSH SYMBOL NAME
	MOV	S$YM(R3),-(SP)	; ...
	SUB	#6,SP		; CONVERT TO PROPER FORMAT
	MOV	SP,R1		; COPY DESCRIPTOR ADDRESS
	MOV	#$SYMHD,R0	; GET LISTHEAD ADDRESS
	CALL	$SRCIV		; SEARCH FOR INSERTION
	CALL	$ISYMV		; INSERT SYMBOL
	ADD	#<3*2>+<3*2>,SP	; REMOVE ALL BUT SYMBOL ADDRESS
10$:				;
	INC	(SP)+		; CLEAN STACK
SYMRET:	MOV	(SP)+,R3	;RESTORE R3
	RETURN			;

;
; VERSION IDENTIFICATION
;

VIDENT:	MOV	#$IDENT,R0	;GET ADDRESS OF PRG IDENTIFICATION
	TST	(R0)		;ANY PREVIOUS DEFINITION?
	BNE	10$		;IF NE YES
	BIT	#SW$RL,E$LSWT(R4) ;++016 RESIDENT LIBRARY ?
	BNE	10$		;++016 IF NE YES
	MOV	S$YM(R1),(R0)+	;INSERT PROGRAM IDENTIFICATION
	MOV	S$YM+2(R1),(R0)	;
10$:	MOV	S$YM(R1),E$LIDT(R4);INSERT VERSION IDENTIFICATION
	MOV	S$YM+2(R1),E$LIDT+2(R4);
	MOV	$CRVEL,R1	; GET VIRTUAL ADDRESS OF CURRENT ELEMENT
	CALLR	$WRMPG		; WRITE-MARK PAGE, EXIT

;
; VIRTUAL ARRAY STORAGE
;
VSTNME:
	TST	$VSWND		;ALREADY ALLOCATED AN EXTRA WINDOW?
	BEQ	7$		;IF EQ YES
	MOV	$NUMWN,-(SP)	;PUSH NUMBER OF TASK WINDOWS
	ADD	$MXWND,(SP)	;ADD IN RESIDENT LIBRARY WINDOWS
	INC	(SP)		;ADD WINDOW FOR VIRTUAL ARRAY
	MOV	(SP)+,R2	; GET NUMBER OF WINDOWS
	CMP	R2,#8.		; TOO MANY WINDOWS REQUIRED?
	BLOS	5$		;IF LOS NO
	CMP	#4,$SYSTM	; BUILDING A M+ TASK
	BNE	3$		; IF NE NO
	CMP	R2,#W$NDWS	; STILL TOO MANY WINDOWS?
	BLOS	5$		; IF LOS NO
3$:
	MOV	R1,-(SP)	; SAVE R1
	MOV	(PC)+,R1	;GET ERROR/SEVERITY
	.BYTE	E$R86,S$V0	;
	CLR	R2		;NO PARAMETERS
	CALL	$ERMSG		;PRINT ERROR MESSAGE
	MOV	(SP)+,R1	; RESTORE
	BR	7$		;
5$:				;
	INC	$NUMWN		;ADD ONE WINDOW TO TASK ALLOCATION
7$:				;
	CLR	$VSWND		;CLEAR SO ONLY ONE WINDOW IS ADDED
	CLR	C$SFLG(R1)	;CLEAR FLAGS
	MOV	$VAROC,C$SFLG(R1) ; SET VIRTUAL ARRAY FLAGS...
				;SET FLAGS
	BIT	#MP$SY,$SWTCH	;MAPPED SYSTEM?
	BNE	10$		;IF NE YES
	MOV	R1,-(SP)	; SAVE
	MOV	#MODN,R2	;MODULE NAME
	MOV	(PC)+,R1	;PRINT WARNING
	.BYTE	E$R93,S$V0	;AND KEEP GOING
	CALL	$ERMSG
	MOV	(SP)+,R1	; RESTORE
10$:
	JMP	PSTNME		;NOW GO PROCESS LIKE A PSECT
;
; END GSD-BLOCK TYPE 2
;

ENGSD:	TST	(SP)+		;CLEAN STACK
	MOV	E$LCMT(R4),R3	;GET ADDRESS OF CMT TABLE
	BEQ	40$		;IF EQ NONE IN TABLE
	MOV	R5,-(SP)	;SAVE CURRENT SEGMENT DESCRIPTOR ADDRESS
	MOV	E$LNUM(R4),R5	;GET HIGHEST SECTION NUMBER
	INC	R5		;CONVERT TO REPEAT COUNT
	CALL	BLVMT		; BUILD VIRTUAL MAPPING TABLE
10$:				;
	MOV	(R3)+,R1	; GET ENTRY ADDRESS
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	CALL	$WRMPG		; WRITE-MARK PAGE
	MOV	(R3)+,R1	;GET MAX SIZE
	BITB	#CS$REL,C$SFLG(R0);ABS SECTION?
	BEQ	30$		;IF EQ YES
	BITB	#CS$LIB,C$SFLG(R0);LIB SECTION?
	BNE	13$		;IF NE YES
	BITB	#CS$ALO,C$SFLG(R0);WHAT TYPE?
	BNE	20$		;IF NE OVERLAID
	ADD	R1,C$SCUR(R0)	;UPDATE CURRENT OFFSET ADDRESS
	BCC	30$		;IF CC OKAY
	MOV	(PC)+,R1	;P-SECTION OVERFLOW
	.BYTE	E$R19,S$V0	;DIAGNOSTIC
	BR	17$		;
13$:
	BITB	#CS$SUP,C$SFLG+1(R0) ; IS THIS A SUPER-MODE LIB. SECTION ?
	BNE	30$		; IF .NE. THEN YES, IGNORE CHECKS
	CMP	R1,C$SLTH(R0)	; COMPATIBLE LENGTHS?
	BLOS	30$		;IF LOS YES
	MOV	(PC)+,R1	;INCOMPATABLE ALLOCATION REFERENCE
	.BYTE	E$R59,S$V0	;DIAGNOSTIC
17$:	MOV	R0,R2		;COPY ADDRESS OF P-SETION ENTRY
	TST	(R2)+		; POINT TO SECTION NAME
	CALL	$ERMSG		;OUTPUT ERROR MESSAGE
	BR	30$		;
20$:	CMP	R1,C$SCUR(R0)	;COMPARE SIZES
	BLOS	30$		;IF LOS NO CHANGE
	MOV	R1,C$SCUR(R0)	;SET NEW HIGH
30$:	SOB	R5,10$		;REPEAT
	MOV	(SP)+,R5	;RESTORE SEGMENT DESCRIPTOR ADDRESS
	CALL	$DLCMT		; DEALLOCATE RESIDENT CMT
40$:				;
	BIT	#SW$LB,E$LSWT(R4) ; LIBRARY FILE?
	BNE	70$		; IF NE YES
	BIT	#SW$CC,E$LSWT(R4) ; CONCATENATED FILE?
	BEQ	70$		; IF EQ NO
50$:				;
	MOV	$CRVEL,R1	; GET CURRENT VIRTUAL ADDRESS
	CALL	$UNLPG		; UNLOCK PAGE
55$:				;
	CLR	$NBYTE		; CLEAR BYTE COUNT
	CALL	$GTBYT		;GET RECORD LENGTH
	BCS	60$		;IF CS ILL FORMAT
	CALL	$GTWRD		;GET BLOCK TYPE
	CMP	R0,#6		;END OF MODULE?
	BNE	55$		; IF NE NO
	CLR	$NBYTE		;CLEAR BYTE COUNT
	CALL	$GTBYT		;GET RECORD LENGTH
	BCS	70$		;IF CS NO MORE MODULES
	MOV	R0,R3		;SAVE RECORD LENGTH
	CALL	$ACMOD		; ALLOCATE CONCATENATED MODULE DESCRIPTOR
	CALL	$LCKPG		; LOCK NEXT DESCRIPTOR IN MEMORY
	MOV	R0,-(SP)	; SAVE REAL ADDRESS OF NEXT
	MOV	R1,-(SP)	; SAVE VIRTUAL ADDRESS OF NEXT
	MOV	$CRVEL,R1	; GET VIRTUAL ADDRESS OF CURRENT
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	CALL	$WRMPG		; WRITE MARK PAGE
	MOV	(SP),E$LNXT(R0) ; SET LINK TO NEXT
	MOV	(SP)+,$CRVEL	; SET VIRTUAL ADDRESS OF NEXT DESCRIPTOR
	MOV	(SP)+,R4	; SET REAL ADDRESS OF NEXT DESCRIPTOR
	JMP	PRCEL2		;GO AGAIN
60$:	JMP	ILFMT		;ILLEGAL FORMAT
70$:	MOV	(SP)+,R3	;RESTORE R3
	RETURN			;

;
; ISD-BLOCK TYPE 5
;

STISD:
	BIT	#SW$RL,E$LSWT(R4) ; RESIDENT LIBRARY ELEMENT?
	BEQ	RPEAT		; IF EQ NO - IGNORE ISD
	CALL	$GTWRD		; GET ISD RECORD TYPE
	SUB	#2,R3		; ADJUST BYTE COUNT
	CMP	#1,R0		; TKB GENERATED ISD?
	BNE	RPEAT		; IF NE NO - IGNORE ISD
5$:
	CALL	$GTWRD		; GET ITEM TYPE AND LENGTH
	CMPB	#3,R0		; ITEM TYPE 3?
	BNE	RPEAT		; IF NE NO - IGNORE REST OF ISD
	BIT	#SW$ALE,E$LSWT(R4) ; HAVE WE PROCESSED ANY ITEMS BEFORE?
	BNE	7$		; IF NE YES
	BIS	#SW$ALE,E$LSWT(R4) ; SET AUTOLOADABLE ENTRY POINT FLAG
	MOV	$CRVEL,R1	; GET VIRTUAL ADDRESS OF CURRENT ELEMENT
	CALL	$WRMPG		; WRITE-MARK PAGE
7$:
	MOV	R3,-(SP)	; SAVE BYTE COUNT
	MOV	#LCLSYM+2,R3	; GET ADDRESS TO STORE SYMBOL
	MOV	#5,-(SP)	; SET LOOP COUNT
10$:
	CALL	$GTWRD		; GET A WORD
	MOV	R0,(R3)+	; SAVE IN TEMP BUFFER
	DEC	(SP)		; DECREMENT LOOP COUNT
	BGT	10$		; IF GT GO AGAIN
	TST	(SP)+		; REMOVE COUNT WORD FROM STACK
	MOV	(SP)+,R3	; RETRIEVE BYTE COUNT
	SUB	#12.,R3		; ADJUST FOR ISD ITEM
	MOV	#LCLSYM,R1	; GET ADDRESS OF LOCAL SYMBOL DESCRIPTOR
	MOV	R5,R0		; GET ADDRESS OF CURRENT SEGMENT
	CALL	ALDSYM		; PROCESS AUTOLOADABLE SYMBOL
	TST	R3		; ANY MORE ITEMS TO PROCESS?
	BGT	5$		; IF GT YES
	RETURN			;

;
; REPEAT-BLOCK TYPES 3,4, AND 5
;

RPEAT:	CLR	$NBYTE		;CLEAR BYTE COUNT
	RETURN			;

;
; SUBROUTINE TO BUILD THE VIRTUAL MAPPING TABLE
;

BLVMT:				;
	SAVRG			; SAVE THE NON-VOLATILE REGISTERS
	ADD	#E$LVMT,R4	; POINT TO VMT ADDRESS
	CMP	R5,#<P$GSIZ-P$GHD>/4 ; VMT EXCEED A PAGE?
	BLOS	10$		; IF LOS NO
	SUB	#<P$GSIZ-P$GHD>/4,R5 ; SPLIT VMT INTO TWO PARTS
	CALL	10$		; ALLOCATE FIRST PART OF TABLE
	MOV	#<P$GSIZ-P$GHD>/4,R5 ; GET NEXT INCREMENT
10$:				;
	MOV	R5,R1		; COPY SIZE OF TABLE
	ASL	R1		; CONVERT TO BYTES
	ASL	R1		; ...
	CALL	$ALSVB		; ALLOCATE VIRTUAL MEMORY
	MOV	R1,(R4)+	; SAVE VIRTUAL ADDRESS
20$:				;
	MOV	(R3)+,(R0)+	; COPY FIRST WORD OF ENTRY
	MOV	(R3)+,(R0)+	; COPY SECOND WORD OF ENTRY
	SOB	R5,20$		;
	RETURN			;


;
; SUPTST - DETERMINE IF SYMBOL IS AN ENTRY INTO A SUPERVISOR MODE LIBRARY
;		IF SO, LINK INTO LOAD LIST
;
;	INPUTS:
;		RO - SYMBOL TABLE FLAGS WORD
;	OUTPUTS:
;		C-BIT = 0 SYMBOL FROM SUPERVISOR MODE LIBRARY
;		C-BIT = 1 NOT
;

SUPTST:
	BIT	#SY$SUP,SYFLG	; FROM ROOT OF SUPERVISOR MODE LIBRARY?
	BEQ	10$		; IF EQ NO
	BIT	#SY$SAB,SYFLG	; ABSOLUTE DEFINITION?
	BNE	10$		; IF NE YES - RESLOVE AS IS
	BIT	#SY$RS0,SYFLG	; WEAK DEFINITION? (DEFINED PREVIOUSLY
				; THRU AUTOLOAD VECTORS)...
	BNE	10$		; YES...RESOLVE THRU THE VECTORS AT
				; P-SECTION $$AUTB IN THE ROOT.
	BIT	#SW$SV,E$LSWT(R4) ; SUPERVISOR VECTORS WANTED?
	BNE	10$		; IF NE NO
	MOV	#S$YLGH,R1	; GET SIZE OF SYMBOL ENTRY
	CALL	$ALSVB		; ALLOCATE SMALL VIRTUAL CORE BLOCK
	CALL	$LCKPG		; LOCK DESCRIPTOR IN MEMORY
	MOV	SYDEF,S$YVAL(R0) ; SET INDIRECT ENTRY ADDRESS
	BISB	#<SY$DEF!SY$IND>,S$YFLG(R0) ; SET INDIRECT FLAG
	MOV	R5,R2		; GET ADDRESS OF CURRENT SEGMENT
	CALL	LNKSUP		; LINK INTO LIST
	CALL	$CVRL		; COVERT TO REAL
	CLC			; SET C-BIT FOR FROM SUPER LIBRARY
	RETURN
10$:
	SEC			; SET C-BIT FOR NOT FROM SUPER LIB
	RETURN
;
;+
; FNDSEC - FIND THE VIRTUAL ADDRESS OF THE SYMBOL WHOSE NAME IS STORED
;          IN TWO-WORD RAD50 FORMAT IN THE CURRENT ELEMENT DESCRIPTOR
;          AT OFFSET 'E$LMOD'. IF THE SEARCH FAILS, ANOTHER SEARCH WILL
;	   BE INITIATED FOR THE '. ABS.' PSECT.
;
;	INPUTS:
;		$RTSEG - VIRTUAL ADDRESS OF ROOT SEGMENT DESCRIPTOR
;		$CRELM - REAL ADDRESS OF CURRENT ELEMENT DESCRIPTOR
;
;	OUTPUTS:
;		C-BIT = 1  IF PROGRAM SECTION NOT PRESENT IN THE SYMBOL TABLES
;			   CRVSC REMAINS AT CURRENT VALUE
;		C-BIT = 0  IF PROGRAM SECTION FOUND
;			   CRVSC CONTAINS VIRTUAL ADDRESS OF FOUND SECTION
;
; ALL REGISTERS ARE PRESERVED ACROSS THE CALL
;-
;
FNDSEC:
	CALL	$SAVAL		; SAVE THE VOLATILE REGISTERS
	MOV	$RTSEG,R1	; GET THE ROOT SEGMENT DESCRIPTOR VIRT. ADDRESS
	CALL	$CVRL		; CONVERT TO DYNAMIC MEMORY ADDRESS
	ADD	#S$GCST,R0	; POINT TO THE .PSECT TABLE ENTRES
	MOV	R0,-(SP)	; SAVE THIS AWHILE...
	MOV	$CRELM,R1	; GET THE CURRENT ELEMENT DESCRIPTOR ADDRESS
	ADD	#<E$LMOD-S$YM>,R1 ; ADJUST POINTER TO SYMBOL ENTRY
	CALL	$SRCH		; AND LOOK FOR THE SYMBOL...
	BCS	10$		; IF C-SET, NO SECTION ENTRY
	MOV	R1,CRVSC	; IF C-CLR, YES..RESET CURRENT VIRTUAL SECTION
				; ADDRESS.
	TST	(SP)+		; CLEAN OFF STACK
	RETURN			; AND RETURN SUCCESSFULLY
10$:
	MOV	(SP)+,R0	; GET THE ROOT REAL ADDRESS BACK
	MOV	#<$ABSNM-S$YM>,R1 ; LOOK FOR THE . ABS. SECTION
	CALL	$SRCH
	BCS	20$		; IF C-SET, NONE ENTERED...
	MOV	R1,CRVSC	; IF C-CLR, YES...RESET CORRECT VIRTUAL SECTION
				; ADDRESS.
20$:				; IF C-SET...UNSUCCESSFUL SEARCH...
	RETURN

	.IF DF D$PRCL & D$TRAC

SYMDP0:
	CALL	$SAVAL		; Save all registers
;	CMP	D$SYM,S$YM(R0)	; Does first half match?
;	BNE	20$		; If NE, no...bypass the rest
;	CMP	D$SYM+2,S$YM+2(R0); Does second Half match?
;	BNE	20$		; If NE, ignore all this
	MOV	R0,-(SP)	; Save R0's original value
	MOV	$PHASE,$TRPS0	; Set phase to dump
	MOV	(SP),$TRSY0	; Set the current symbol address
	MOV	#$TRSM0,R0	; Point to the list
	CALL	$TRACE		; Display the common symbol data
	MOV	(SP)+,R0	; Restore R0
;
	BIT	#SY$SUP,S$YFLG(R0) ; is the symbol from a super-mode lib?
	BEQ	10$		; If EQ, no
	MOV	R0,-(SP)	; Save R0's original value
	MOV	$PHASE,$TRPS1	; Set phase to dump
	MOV	(SP),$TRSY1	; Set the current symbol address
	MOV	#$TRSM1,R0	; Point to the list
	CALL	$TRACE		; Display the common symbol data
	MOV	(SP)+,R0	; Restore R0
;
10$:
	BIT	#SY$ATL,S$YFLG(R0) ; is the symbol autoloadable?
	BEQ	20$		; If EQ, no
	MOV	R0,-(SP)	; Save R0's original value
	MOV	$PHASE,$TRPS2	; Set phase to dump
	MOV	(SP),$TRSY2	; Set the current symbol address
	MOV	#$TRSM2,R0	; Point to the list
	CALL	$TRACE		; display the symbol data
	MOV	(SP)+,R0	; Restore R0
20$:
	RETURN

SYMTRP:
	CMP	D$SYM,S$YM(R0)	; Does first half match?
	BNE	10$		; If NE, no...bypass the rest
	CMP	D$SYM+2,S$YM+2(R0); Does second Half match?
	BNE	10$		; If NE, ignore all this
	BPT			; If EQ, trap
10$:
	RETURN

	.ENDC	; D$PRCL & D$TRAC

	.END
