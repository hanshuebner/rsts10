	.TITLE	SYALO
	.IDENT	/07.04/
;
; COPYRIGHT (c)	1989 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE IS FURNISHED  UNDER A LICENSE AND MAY BE USED OR
; COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;
; D. N. CUTLER/C. MONIA  19-APR-74
;
; MODIFIED BY:
;
;	C. B. PETROVIC	26-FEB-82	07.01
;		CBP039		ADD CORRECT .PSECT DEFINITIONS TO
;				ALLOW TKB TO BE LINKED AS AN I/D TASK.
;
;	C. B. PETROVIC	4-MAY-82	07.02
;		CBP050		CONVERT TO MODIFIED FORMAT AUTOLOAD VECTOR
;				GENERATION TO FACILITATE I/D AUTOLOAD
;				SUPPORT AS WELL AS SELECTIVE INCLUSION OF
;				ONLY THOSE AUTOLOADABLE SYMBOLS ACTUALLY
;				REFERENCED BY THE USER TASK.
;
; MODIFIED FOR RSX-11M-PLUS AND MICRO/RSX V4.2 BY:
;
;	L. M. PETERSON	7-JUN-88	07.03
;		LMP112		POSTPONE ASSIGNMENT OF ABSOLUTE ADDRESSES TO
;				AUTOLOAD ENTRY POINTS FOR OVERLAID COMMONS
;
; MODIFIED FOR RSX-11M-PLUS AND MICRO/RSX V4.3 BY:
;
;	L. M. PETERSON	28-FEB-89	46.05	LMP131
;		ALLOW TASKS WITH (TASK)MEMORY RESIDENT OVERLAYS TO BE 
;		EXTENDED (WITH THE $EXTM DIRECTIVE)
;
;+
; **-$SYALO-SYMBOL ABSOLUTE ADDRESS ALLOCATION
;
; THIS ROUTINE IS CALLED IN PHASE 4 TO ASSIGN ABSOLUTE ADDRESSES TO
; ALL RELOCATABLE SYMBOLS.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	ABSOLUTE ADDRESSES ARE ASSIGNED TO ALL RELOCATABLE SYMBOLS.
;	A COUNT OF ALL SYMBOLS DEFINED IS PLACED IN S$GNTB OF EACH
;	SEGMENT DESCRIPTOR
;-
	PURE.I			; READ-ONLY I-SPACE

$SYALO::
	BIT	#EX$MRT,$SWOV2	; SHIFT MR OVERLAYS UP SO TASK CAN EXTEND?
	BEQ	90$		; IF EQ, NO 
;
; Shift memory resident segment allocations
; Go thru segments and change S$GLDA, windows, and csects

	CMP	$SZSEG,#S$ZSEG+2 ; TASK HAVE RESIDENT OVERLAYS
	BLO	90$		; IF LO NO
	CLR	ADBIAS		; INITIALIZE
	CLR	APBIAS		; INITIALIZE
	MOV	$TSKNM,R1	; GET ADDRESS OF TASK FILE NAMEBLOCK
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	BIT	#SW$MU,E$LSWT(R0) ; MULTI-USER TASK?
	BEQ	4$		; IF EQ, NO
	MOV	#0,-(SP)	; SET FOR TEST OF HOW HIGH TO SHIFT
	BR	5$		;
4$:	MOV	#200,-(SP)	; ALLOW SHIFT TO THE VERY TOP OF MEMORY

	; CALCULATE TASK OVERLAY I OR D APR USAGE IN R2

5$:	BIT	#ID$ATA,$SWTCH	; ID TASK?
	BNE	30$		; IF NE, YES
	MOVB	$APRMP,R0	; GET TOTAL TASK APR USAGE
	BIC	#177400,R0	; GET RID OF (POSSIBLE) SIGN EXTENSION
	SUB	IAPUSE,R0	; FIND TASK OVERLAY USAGE
	MOVB	IAPUSE,$APRMP	; RESET TO JUST REFLECT SHARED REGION USAGE
	TST	(SP)		; NEED TO TEST HOW HIGH TO SHIFT?
	BNE	9$		; IF NE, NO
	MOV	#200,R1		; INITIALIZE TO TOP OF MEMORY
	CLR	R2		; INIT SHIFT FLG(IN CASE RO REG NOT AT VERY TOP)
6$:	BITB	R1,R0		; FOUND RO REGION?
	BEQ	8$		; IF EQ, NO
	MOV	#1,R2		; FLAG THAT WE REALLY FOUND RO REGION
	BISB	R1,$APRMP	; SET RO ALLOCATION
	BICB	R1,R0		; TAKE OUT OF TASK OVERLAY USAGE
7$:	RORB	R1		; CHECK OUT NEXT LOWEST APR
	BITB	#1,R1		; GONE TOO FAR?
	BNE	EXERR		; FATAL ERROR
	BR	6$		; GO AGAIN
8$:	TST	R2		; FIND (SHR REG) HOLE AT TOP OR END OF RO REG?
	BEQ	7$		; IF EQ, HOLE AT TOP, TRY AGAIN
	ROLB	R1		; SET LIMIT ON HIGH TO SHIFT
	MOV	R1,(SP)		; SET UP LIMIT TEST
9$:	CLR	R1		; INITIALIZE TEMP STORAGE
	CLR	R2		; INITIALIZE TEMP STORAGE
10$:	BITB	(SP),R0		; AT TOP OF MEMORY?
	BNE	20$		; IF NE, YES
	ROLB	R0		; SHIFT TASK OVERLAYS UP AN APR
	ADD	#20000,R1	; ADBIAS TEMP
	INC	R2		; APBIAS TEMP
	BITB	R0,$APRMP	; ANY OVERLAP?
	BNE	10$		; IF NE, YES
	MOV	R1,ADBIAS	; SAVE
	MOV	R2,APBIAS	; LIKEWISE
	BR	10$		; TRY AGAIN
20$:	BISB	R0,$APRMP	; MARK SHIFT
	BR	85$		; CONTINUE
30$:
	MOVB	$APRDM,R0	; GET TOTAL TASK APR USAGE
	BIC	#177400,R0	; GET RID OF (POSSIBLE) SIGN EXTENSION
	SUB	DAPUSE,R0	; FIND TASK OVERLAY USAGE
	MOVB	DAPUSE,$APRDM	; RESET TO JUST REFLECT SHARED REGION USAGE
	TST	(SP)		; NEED TO TEST HOW HIGH TO SHIFT?
	BNE	39$		; IF NE, NO
	MOV	#200,R1		; INITIALIZE TO TOP OF MEMORY
	CLR	R2		; INIT SHIFT FLG(IN CASE RO REG NOT AT VERY TOP)
36$:	BITB	R1,R0		; FOUND RO REGION?
	BEQ	38$		; IF EQ, NO
	MOV	#1,R2		; FLAG THAT WE REALLY FOUND RO REGION
	BISB	R1,$APRDM	; SET MU ALLOCATION
	BICB	R1,R0		; TAKE OUT OF TASK OVERLAY USAGE
37$:	RORB	R1		; CHECK OUT NEXT LOWEST APR
	BITB	#1,R1		; GONE TOO FAR?
	BNE	EXERR		; FATAL ERROR
	BR	36$		; GO AGAIN
38$:	TST	R2		; FIND (SHR REG) HOLE AT TOP OR END OF RO REG?
	BEQ	37$		; IF EQ, HOLE AT TOP, TRY AGAIN
	ROLB	R1		; SET LIMIT ON HIGH TO SHIFT
	MOV	R1,(SP)		; SET UP LIMIT TEST
39$:	CLR	R1		; INITIALIZE TEMP STORAGE
	CLR	R1		; INITIALIZE TEMP STORAGE
	CLR	R2		; INITIALIZE TEMP STORAGE
40$:	BITB	(SP),R0		; AT TOP OF MEMORY?
	BNE	50$		; IF NE, YES
	ROLB	R0		; SHIFT TASK OVERLAYS UP AN APR
	ADD	#20000,R1	; ADBIAS TEMP
	INC	R2		; APBIAS TEMP
	BITB	R0,$APRDM	; ANY OVERLAP?
	BNE	40$		; IF NE, YES
	MOV	R1,ADBIAS	; SAVE
	MOV	R2,APBIAS	; LIKEWISE
	BR	40$		; TRY AGAIN
50$:	BISB	R0,$APRDM	; MARK SHIFT

85$:	TST	(SP)+		; CLEAN STACK

90$:	MOV	#SYALO,R0	;GET PHASE CONTROL ROUTINE ADDRESS
	CALL	$PCTRL		;CALL PHASE CONTROL ROUTINE
	MOV	#$XFRAD,R0	;GET PRG VECTOR ADDRESS
	CMP	#1,(R0)+	;PRG SPECIFIED?
	BEQ	100$		;IF EQ NO
	CALL	200$		;RELOCATE PRG XFR ADDRESS
100$:	MOV	#$ODTAD,R0	;GET ODT VECTOR ADDRESS
	CMP	#1,(R0)+	;ODT SPECIFIED?
	BEQ	300$		;IF EQ NO
200$:	MOV	(R0),R1		;GET ADDRESS OF SECTION ENTRY
	MOV	R0,-(SP)	; SAVE VECTOR ADDRESS
	CALL	$CVRL		; CONVERT SECTION TO REAL ADDRESS
	MOV	(SP)+,R2	; RETRIEVE VECTOR ADDRESS
	BITB	#CS$REL,C$SFLG(R0) ; ABS SECTION?
	BEQ	300$		; IF EQ YES
	ADD	C$SBSE(R0),-(R2) ; ADD IN SECTION BASE ADDRESS
	ADD	$OFFST,(R2)	;
300$:	RETURN			;

EXERR:	MOV	#<S$V2*400!E$R111>,R1 ; FATAL ERROR
	CALL	$ERMSG		; NO RETURN


;
; SYMBOL ADDRESS ALLOCATION
;
; THIS ROUTINE IS CALLED FOR EACH SEGMENT IN THE ALLOCATION.
;


SYALO:				;
	BIT	#EX$MRT,$SWOV2	; SHIFT MR OVERLAYS UP SO TASK CAN EXTEND?
	BEQ	9$		; IF EQ, NO 
	TST	ADBIAS		; ANY SHIFT?
	BEQ	EXERR		; IF EQ, NO - FATAL ERROR
5$:	CMP	$CRVSG,$RTSEG	; AT ROOT?
	BEQ	9$		; IF EQ, YES - NO CHANGE
	MOV	$CRSEG,R0	; GET ADDRESS OF SECTION
	ADD	#S$GCST,R0	; POINT TO SECTION TABLE
	MOV	#$ISED,-(SP)	; PUSH ADDRESS OF SYMBOL EDIT ROUTINE
6$:
	CALL	@(SP)+		; GET NEXT ENTRY
	BCS	9$		; IS CARRY SET NO MORE
	BITB	#CS$IND,C$SFLG(R0) ; INDIRECT ENTRY?
	BNE	6$		; IF YES, IGNORE
	BIT	#ID$ATA,$SWTCH	; ID TASK?
	BEQ	7$		; IF EQ, NO
	BIT	#CS$TYP,C$SFLG(R0) ; I OR D PSECT?
	BEQ	6$		; IF EQ, I PSECT - DON'T TOUCH
7$:
	ADD	ADBIAS,C$SBSE(R0) ; SHIFT UP PSECT BASE ADDRESS
	ADD	ADBIAS,C$SCUR(R0) ; MAKE CURRENT BASE REFLECT THIS TOO
	CALL	$WRMPG		; WRITE-MARK DESCRIPTOR
	BR	6$		; GO AGAIN
9$:
	MOV	R5,-(SP)	; SAVE R5
	MOV	$CRVSG,R1	; GET VIRTUAL ADDRESS OF SEGMENT
	CALL	$WRMPG		; WRITE-MARK PAGE
	MOV	$CRSEG,R0	; GET REAL ADDRESS OF CURRENT SEGMENT
	MOV	R0,R5		; COPY ADDRESS
	ADD	#S$GSTB,R0	;POINT TO GLOBAL SYM TABLE HEADER
	ADD	#S$GNTB,R5	; POINT TO COUNT OF DEFINITIONS
	MOV	#$ISED,-(SP)	;SET EDIT ROUTINE ADDRESS
10$:	CALL	@(SP)+		;GET NEXT SYMBOL
	BCC	20$		;IF CC GOT ONE
	MOV	(SP)+,R5	; RESTORE R5
	RETURN			;
20$:	BITB	#SY$DEF,S$YFLG(R0);SYMBOL DEFINITION?
	BEQ	10$		;IF EQ NO
	BITB	#SY$IND,S$YFLG(R0);INDIRECT SYMBOL?
	BNE	10$		;IF NE YES
	BITB	#SY$EXC,S$YFLG+1(R0) ; SYMBOL EXCLUDED FROM MAP?
	BNE	30$		; IF NE YES
	INC	(R5)		; INCREMENT COUNT OF DEFINITIONS
30$:				;
	BITB	#SY$REL,S$YFLG(R0);RELOCATABLE SYMBOL?
	BEQ	10$		;IF EQ NO
	CALL	$WRMPG		; WRITE MARK PAGE
	CALL	$LCKPG		; LOCK PAGE IN CORE
	MOV	R0,-(SP)	; SAVE REAL ADDRESS
	MOV	R1,-(SP)	; SAVE VIRTUAL ADDRESS
	MOV	S$YCMT(R0),R1	; GET VIRTUAL ADDRESS OF SEGMENT
	CALL	$CVRL		; CONVERT TO REAL
	MOV	R0,R2		; COPY REAL ADDRESS
	MOV	(SP)+,R1	; RESTORE R1
	MOV	(SP)+,R0	; RESTORE R0
	CALL	$UNLPG		; UNLOCK PAGE
	BITB	#CS$VSC,C$SFLG+1(R2) ; VIRTUAL SECTION?
	BEQ	40$		; IF EQ NO
	MOV	R0,-(SP)	; SAVE ADDRESS OF SYMBOL

	.IF DF	V1145

	MOV	S$YVAL(R0),R1	; GET VALUE
	CLR	R0		; CLEAR TOP PART OF VALUE
	DIV	C$SLTH(R2),R0	; COMPUTE MODULUS OF SYMBOL

	.IFF

	MOV	S$YVAL(R0),R0	; GET VALUE
	MOV	C$SLTH(R2),R1	; GET DIVISOR
	CALL	$DIV		; COMPUTE MODULUS OF SYMBOL

	.ENDC

	MOV	(SP)+,R0	; RESTORE ADDRESS OF SYMBOL
	MOV	R1,S$YVAL(R0)	; RESET SYMBOL VALUE
40$:				;
	ADD	C$SBSE(R2),S$YVAL(R0) ; RELOCATE SYMBOL
	BIT	#<CS$VAS!CS$VSC*400!CS$LIB>,C$SFLG(R2) ; VIRTUAL OR LIBRARY SECT
	BEQ	10$		; IF EQ NO
	BICB	#SY$REL,S$YFLG(R0) ; CONVERT SYMBOL TO ABSOLUTE
;
;+
; WHAT WE HAVE TO DO HERE IS PROPERLY ASSIGN ABSOLUTE ADDRESSES TO THE
; 'INDIRECT' ENTRY HANGING OFF THE AUTOLOADABLE SYMBOL ENTRY. SINCE WE'VE
; PROCESSED THE REAL ENTRY, WE MUST CHECK TO SEE IF THERE'S AN EXTRA THREE
; WORDS WHICH DESCRIBE THE PSEUDO-INDIRECT ENTRY AND ASSIGN ABSOLUTE ADDRESSES
; TO THEM AS WELL.
;-
;
	BIT	#SY$ATL,S$YFLG(R0) ; AUTOLOADABLE SYMBOL?
	BEQ	10$		; IF EQ, NO
	MOV	S$YVAL(R0),-(SP)   ; IS THIS ONE FOR AN
	SUB	C$SBSE(R2),(SP)  ; OVERLAID COMMON?
	CMP	#-1,(SP)	   ; IF ORIGINAL ENTRY POINT VALUE WAS -1,
	BNE	45$		; YES
	MOV	#-1,S$YVAL(R0)	; SO LEAVE AS WAS FOR P5EOS TO TAKE CARE OF
45$:	TST	(SP)+		; CLEAN STACK
	CALL	$WRMPG		; WRITE-MARK THE PAGE...
	CALL	$LCKPG		; AND LOCK IT IN MEMORY
	MOV	R0,-(SP)	; SAVE REAL ADDRESS
	MOV	R1,-(SP)	; SAVE VIRTUAL ADDRESS
	BIT	#SY$SUP,S$YFLG(R0); IS IT A SUPER-MODE AUTOLOADABLE SYMBOL?
	BNE	50$		; IF NE, YES...
	MOV	S$YCVT(R0),R1	; NO...BUT IT IS AUTOLOADABLE
	BR	60$		; CONTINUE WITH THE REST OF THE PROCESSING
50$:
	MOV	S$YCVX(R0),R1	; SUPER-MODE AUTOLODABLE SYMBOL...
				; GET THE CONTROL SECTION ADDRESS OF THE
				; 'INDIRECT' ENTRY...
60$:
	CALL	$CVRL		; CONVERT TO REAL
	MOV	R0,R2		; COPY THE REAL ADDRESS
	MOV	(SP)+,R1	; RESTORE R1 WITH THE VIRTUAL ADDRESS
	MOV	(SP)+,R0	; AND SAME WITH THE REAL ADDRESS IN R0
	CALL	$UNLPG		; UNLOCK THE PAGE
	MOV	R0,-(SP)	; AND SAVE THE REAL ADDRESS AGAIN...
	BIT	#SY$SUP,S$YFLG(R0); IS IT A SUPER-MODE AUTOLOADABLE SYMBOL?
	BNE	70$		; IF NE, YES...
	MOV	S$YVOF(R0),R0	; NO...BUT IT IS AUTOLOADABLE
				; GET THE VALUE OF THE 'INDIRECT' ENTRY...
	BR	80$		; CONTINUE WITH THE REST OF THE PROCESSING
70$:
	MOV	S$YVOX(R0),R0	; SUPER-MODE AUTOLODABLE SYMBOL...
80$:				; GET THE VALUE OF THE 'INDIRECT' ENTRY...
	MOV	C$SLTH(R2),R1	; GET DIVISOR
	CALL	$DIV
	MOV	(SP)+,R0	; RESTORE R0
	BIT	#SY$SUP,S$YFLG(R0); IS IT A SUPER-MODE AUTOLOADABLE SYMBOL?
	BNE	90$		; IF NE, YES...
	MOV	R1,S$YVOF(R0)	; RESET SYMBOL VALUE
	ADD	C$SBSE(R2),S$YVOF(R0) ; NO...BUT IT IS AUTOLOADABLE
				; RELOCATE THE 'INDIRECT' SYMBOL
	JMP	10$		; CONTINUE WITH THE REST OF THE PROCESSING
90$:
	MOV	R1,S$YVOX(R0)	; RESET SYMBOL VALUE
	ADD	C$SBSE(R2),S$YVOX(R0) ; SUPER-MODE AUTOLODABLE SYMBOL...
				; RELOCATE THE 'INDIRECT' ENTRY...
	JMP	10$		; GO AGAIN...

	.END
