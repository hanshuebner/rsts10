	.TITLE	P3LBS
	.IDENT	/07.03/
;
; COPYRIGHT (c)	1986 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE IS FURNISHED  UNDER A LICENSE AND MAY BE USED OR
; COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.OP
;
;
; C. MONIA 24-OCT-75
;
; MODIFIED BY:
;
;	C. B. PETROVIC	26-FEB-82	07.01
;		CBP039		ADD CORRECT .PSECT DEFINITIONS TO
;				ALLOW TKB TO BE LINKED AS AN I/D TASK.
;
;	C. B. PETROVIC	4-MAY-82	07.02
;		CBP050		CONVERT TO MODIFIED FORMAT AUTOLOAD VECTOR
;				GENERATION TO FACILITATE I/D AUTOLOAD
;				SUPPORT AS WELL AS SELECTIVE INCLUSION OF
;				ONLY THOSE AUTOLOADABLE SYMBOLS ACTUALLY
;				REFERENCED BY THE USER TASK.
;
; MODIFIED FOR RSX-11M-PLUS V4.0 BY:
;
;	L. PETERSON	18-FEB-86	07.03
;		LMP033		OPEN AND CLOSE DEFAULT LIBRARY AT START AND
;				END OF UNDEFINED SYMBOL SEARCH INSTEAD OF
;				BEFORE AND AFTER EVERY SEGMENT
;
;
; PHASE 3 MODULE SCAN AND LIBRARY SEARCH
;
; EQUATED SYMBOLS
;

EPALO=26			;NUMBER EPT ENTRIES ALLOCATED
EPAVL=30			;NUMBER EPT ENTRIES AVAILABLE
EPSTR=24			;STARTING BLOCK NUMBER OF EPT
MNALO=36			; NUMBER OF MNT ENTRIES ALLOCATED
MNAVL=40			; NUMBER OF MNT ENTRIES AVAILABLE
MNSTR=34			; STARTING BLOCK NUMBER OF MNT

;
; MACRO LIBRARY CALLS
;

	.MCALL	DIR$,GET$S,OFNB$R,QIOW$
;
; LOCAL DATA
;

	.PSECT	$$P3DT,D,GBL

ALSW:	.BLKW	1		; LIBRARY ELEMENT AUTOLOAD SWITCH
BFBAS:	.BLKW	1		; BASE ADDRESS OF EPT TABLE
BFEND:	.BLKW	1		; LAST EPT ENTRY
BFSIZ:	.BLKW	1		; SIZE OF LIBRARY BUFFER
BFTOP:	.BLKW	1		;ADDRESS OF ACTUAL LAST ENTRY IN SEARCH BUFFER
BKPBF:	.BLKW	1		; BLOCKS PER BUFFER
CRVEL:	.BLKW	1		; VIRTUAL ADDRESS OF PARENT MODULE
EPBLK:	.BLKW	1		;STARTING VIRTUAL BLOCK OF EPT
EPHBK:	.BLKW	1		;HIGHEST BLOCK IN EPT PLUS 1
EPNUM:	.BLKW	1		;NUMBER OF EPT ENTRIES
LBRBF:	.BLKW	1		;CURRENT SEARCH BUFFER NUMBER
LBMOD:	.BLKW	17.		; LIBRARY MODULE LIST
LCLSYM:	.BLKW	2		; SYMBOL NAME
SRCDR:	.BLKW	1		;++015 LIBRARY SEARCH DIRECTION FLAG
SLSW:	.BLKW	1		;++008 SELECTIVE SYMBOL EXTRACTION FLAG

	IMPURE			; READ/WRITE D-SPACE

LBQIO:	QIOW$	IO.RVB,1,1,,LBSTS,,<0,0,0,0,0,0> ; QIO DPB FOR SEARCH READ
LBSTS:	.BLKW	2		; I/O STATUS BLOCK FOR SEARCH READ
$MXLBF::.WORD	512.		; MAXIMUM SIZE OF LIBRARY SEARCH BUFFER

;+
; **-$P3LBS-SEARCH SYSTEM LIBRARY
;
; THIS SUBROUTINE IS CALLED FOR EACH SEGMENT IN THE TASK TO PERFORM
; A SEARCH OF THE SYSTEM OBJECT MODULE LIBRARY.
;
; INPUTS:
;
;	NONE
;
; OUTPUTS:
;
;	NONE
;
;-
	PURE.I			; READ-ONLY I-SPACE

$P3LBS::			;
	SAVRG			; SAVE THE NON-VOLATILE REGISTERS
	CALL	$WSINI		; INITIALIZE THE PATH LIST
	MOV	$CRVSG,R1	; GET VIRTUAL ADDRESS OF SEGMENT
	CALL	$WRMPG		; WRITE-MARK PAGE
	MOV	$CRSEG,R5	;GET ADDRESS OF CURRENT SEGMENT
	TST	S$GUND(R5)	;ANY UNDEFINED SYMBOLS?
	BEQ	10$		;IF EQ NO
	MOV	$LIBNM,R1	; GET VIRTUAL ADDRESS OF LIBRARY DESCRIPTOR
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	CALL	$LCKPG		; LOCK PAGE IN MEMORY
	MOV	R0,-(SP)	; SAVE REAL ADDRESS OF DESCRIPTOR
	TST	$LBOPE		; DEFAULT LIBRARY ALREADY OPENED?
	BEQ	1$		; IF EQ, NO
	MOV	$INPPT,R0	; GET RECORD BLOCK POINTER
	CLR	R1		; GET VBN
	MOV	#1,R2
	CLR	R3		; SET BYTE IN VBN
	CALL	.POINT		; POINT TO BEGINNING OF FILE
	BR	2$
1$:
	MOV	$INPPT,R1	; GET RECORD BLOCK POINTER
	MOV	R1,R4		; SAVE NAMEBLOCK POINTER
	CALL	$STFNB		; SETUP FILE NAMEBLOCK
	OFNB$R	R4		; OPEN LIBRARY FILE
	BCS	20$		;IF CS OPEN FAILURE
	INC	$LBOPE
2$:
	MOV	#E$LLGH,R1	; SET DESCRIPTOR LENGTH
	MOV	R1,R3		; SAVE LENGTH
	CALL	$ALSVB		; ALLOCATE SMALL VIRTUAL BLOCK
	CALL	$LCKPG		; LOCK PAGE IN CORE
	MOV	R0,R4		; SAVE REAL ADDRESS OF CURRENT ELEMENT
	MOV	R4,$CRELM	; SET ADDRESS OF CURRENT ELEMENT
	MOV	R1,$CRVEL	; SET VIRTUAL ADDRESS OF CURRENT ELEMENT
	MOV	$CRVSG,R0	; GET VIRTUAL ADDRESS OF SEGMENT
	ADD	#<S$GELT/2>,R0	; POINT TO ELEMENT LISTHEAD
	MOV	#E$LNXT,R2	; GET OFFSET TO NEXT
	CALL	$LNKVM		; LINK ITEM TO ELEMENT LIST
	MOV	R4,R0		; GET REAL ADDRESS OF DESCRIPTOR
	MOV	(SP)+,R1	; GET REAL ADDRESS OF LIBRARY NAMEBLOCK
5$:				;
	MOVB	(R1)+,(R0)+	; COPY BLOCK
	SOB	R3,5$		;
	MOV	$LIBNM,R1	; GET VIRTUAL ADDRESS OF DESCRIPTOR
	CALL	$UNLPG		; UNLOCK PAGE
	CLR	SLSW		;++008 CLEAR SELECTIVE SEARCH FLAG
	CALL	LBSRC		; SEARCH LIBRARY
	MOV	S$GELT+2(R5),R1	; GET VIRTUAL ADDRESS OF LIBRARY ELEMENT
	CALL	$UNLPG		; UNLOCK PAGE FROM MEMORY
10$:	RETURN			;
20$:	MOV	R$NAME(R0),R2	;GET ADDRESS OF NAME STRING
	MOV	(PC)+,R1	;OPEN FAILURE
	.BYTE	E$R11,S$V2	;FATAL-NO RETURN
	CALL	$ERMSG		;OUTPUT ERROR MESSAGE

;+
; **-P3SCN-SCAN AN OBJECT MODULE
;
; THIS ROUTINE IS CALLED FOR EACH SEGMENT IN THE ALLOCATION TO INITI-
; ATE THE SCAN OF A RELOCATABLE OBJECT FILE.
;
; INPUTS:
;
;	NONE
;
; OUTPUTS:
;
;	NONE
;
;-

$P3SCN::			;
	SAVRG			; SAVE THE NONVOLATILE REGISTERS
	CALL	$WSINI		; INITIALIZE PATH LIST
	MOV	SP,$WSEXT	; SET TO SEARCH THE ENTIRE STRUCTURE
	MOV	$CRVSG,R1	; GET VIRTUAL ADDRESS OF SEGMENT
	CALL	$WRMPG		; WRITE MARK PAGE
	CLR	$SGOFF		; RESET THE 'GROUP' SEGMENT DESCRIPTOR OFFSET
	MOV	$CRSEG,R5	;GET ADDR OF CURRENT SEGMENT
	MOV	#$STINP,-(SP)	;SET ADDRESS OF INPUT SET UP ROUTINE
10$:	CALL	@(SP)+		;SET UP NEXT INPUT FILE
	BCC	20$		;IF CC GOT ONE
	CLR	$WSEXT		; SET TO RESTRICT TREE SEARCH ON FUTURE PASSES
	RETURN			;
20$:	MOV	$CRELM,R4	;GET ADDRESS OF ELEMENT DESCRIPTOR
	BIT	#SW$LB,E$LSWT(R4);LIBRARY FILE?
	BNE	40$		;IF NE YES
	BIT	#SW$CC,E$LSWT(R4);CONCATENATED FILE?
	BEQ	30$		;IF EQ NO
	MOV	$CRVEL,R1	; GET VIRTUAL ADDRESS OF DESCRIPTOR
	MOV	R1,-(SP)	; SAVE THE VIRTUAL ADDRESS
	CALL	$WRMPG		; WRITE-MARK THIS PAGE
	CALL	$ACMOD		; ALLOCATE CONCATENATED MODULE DESCRIPTOR
	CALL	$LCKPG		; LOCK PAGE IN MEMORY
	MOV	R1,E$LMOD(R4)	; SET LINK TO FIRST MODULE
	MOV	R1,$CRVEL	; SET VIRTUAL ADDRESS OF CURRENT ELEMENT
	MOV	R0,R4		;SET ADDRESS OF CURRENT DESCRIPTOR
	MOV	(SP),R1		; GET VIRTUAL ADDRESS OF PARENT ELEMENT
	CALL	$UNLPG		; FREE UP THE PAGE BUFFER
	CALL	PRCELM		; PROCESS THE ELEMENT
	MOV	(SP)+,R1	; RETRIEVE VIRTUAL ADDRESS OF PARENT ELEMENT
	CALL	$CVLOK		; RESTORE PAGE STATE
	MOV	R0,$CRELM	; RESTORE CURRENT ELEMENT
	BR	35$		;
30$:	CALL	PRCELM		;PROCESS ELEMENT
35$:				;
	ADD	SGOFF,$SGOFF	; UPDATE THE 'GROUP' SEGMENT DESCRIPTOR OFFSET
	CALL	$RLREF		; FLUSH THE REFERENCE LIST
	BR	10$		;

;
; LIBRARY FILE
;

40$:				;++008
	CLR	SLSW		;++008 ASSUME ALL SYMBOLS WANTED
	BIT	#SW$SS,E$LSWT(R4) ;++008 NOW TEST FOR SURE
	BEQ	50$		;++008 YES -- ALL SET
	MOV	#SW$SS,SLSW	;++008 NO -- SET SELECTIVE EXTRACTION SWITCH
50$:
	CALL	LBSRC		;++008 SEARCH LIBRARY
	BR	10$		;

;
; LIBRARY FILE SEARCH ROUTINE
;

LBSRC:				;
	MOV	E$LIDT+2(R4),R4	; GET ADDRESS OF MODULE NAME LIST
	MOV	$CRVEL,R1	; GET VIRTUAL ADDRESS OF LIBRARY ELEMENT
	MOV	R1,-(SP)	; SAVE ADDRESS OF PARENT ELEMENT
	ADD	#<E$LMOD-E$LNXT>/2,R1 ; CALCULATE VIRTUAL ADDRESS OF FIRST LINK
	MOV	R1,$CRVEL	; RESET VIRTUAL ELEMENT ADDRESS
	CALL	$UNLPG		; FREE UP THE PAGE BUFFER
	CALL	LBSR		; SEARCH LIBRARY
	MOV	(SP)+,R1	; GET ADDRESS OF PARENT ELEMENT
	CALL	$CVLOK		; RESTORE PAGE STATE
	MOV	R0,$CRELM	; RESET ADDRESS OF DESCRIPTOR
	CALLR	$RLREF		; FLUSH REFERENCE LIST

;
; SEARCH LIBRARY
;

LBSR:				;
	MOV	#$P3BF+S.BFHD+2,R0 ; GET ADDRESS OF TEMP BUFFER
	MOV	#1,R1		; GET VBN
	MOV	#512.,R2	; GET BYTE COUNT
	CALL	LBSRD		; READ FILE HEADER
	BCS	20$		; IF C/S I/O ERROR
	MOV	R0,R1		; POINT TO START OF BUFFER
	TST	R4		; SEARCHING ON MODULE NAMES?
	BEQ	5$		; IF EQ NO
	ADD	#<MNSTR-EPSTR>,R1 ; OFFSET TO MNT PARAMETERS
5$:				;
	MOV	EPSTR(R1),EPBLK	;SET STARTING BLOCK OF EPT
	MOV	EPALO(R1),R2	;GET NUMBER OF EPT ENTRIES ALLOCATED
	SUB	EPAVL(R1),R2	;SUBTRACT OUT NUMBER AVAILABLE
	BEQ	10$		;IF EQ NO ENTRIES IN LIBRARY
	MOV	R2,EPNUM	;SET NUMBER OF EPT ENTRIES IN LIBRARY
	ADD	#63.,R2		; ROUND UP TO NEXT EPT BLOCK

	.REPT	6
	ASR	R2		; CALCULATE NUMBER OF EPT BLOCKS
	.ENDR

	ADD	EPBLK,R2	;CALCULATE HIGHEST BLOCK IN EPT PLUS 1
	MOV	R2,EPHBK	;SET HIGHEST BLOCK IN EPT
	MOV	EPNUM,R1	; GET NUMBER OF ENTRY POINTS
	ASL	R1		; CONVERT TO EPT SIZE IN WORDS
	ASL	R1		; ...
	ADD	#377,R1		; ROUND TO NEXT BLOCK
	CLRB	R1		; CLEAR EXCESS BITS
	ASL	R1		; CONVERT TO BYTES
	CMP	R1,$MXLBF	; EXCEED MAX LIBRARY BUFFER SIZE?
	BLOS	7$		; IF LOS YES
	MOV	$MXLBF,R1	; GET MAX SIZE
7$:				;
	MOV	R1,BFSIZ	; SAVE SIZE OF BUFFER
	MOV	R1,R3		; ...
	CALL	$ALBLK		; ALLOCATE LIBRARY EPT BUFFER
	MOV	R0,BFBAS	; SAVE BASE ADDRESS
	MOV	R3,R1		; COPY SIZE OF BUFFER
	SUB	#10,R3		; BACK OFF LENGTH OF BUFFER
	ADD	R0,R3		; POINT TO LAST EPT ENTRY
	MOV	R3,BFEND	; SAVE ENDING ADDRESS
	SWAB	R1		; DIVIDE BUFFER SIZE BY 256
	ASR	R1		; CONVERT TO DISK BLOCKS
	MOV	R1,BKPBF	; SAVE BLOCKS PER BUFFER
	MOV	#1,R2		;SET TO READ FIRST BUFFER FROM EPT
	CALL	LBRD		;READ FIRST BUFFER
	BCC	LBSRC1		;IF CC OKAY
10$:				;
	MOV	#<S$V2*400!E$R79>,R1 ; ASSUME LIBRARY MODULE REQUEST
	TST	R4		; SEARCHING ON MODULE NAMES
	BNE	30$		; IF NE YES
	RETURN			;
20$:				;
	MOV	#<S$V2*400!E$R10>,R1 ; I/O ERROR
30$:				;
	MOV	$INPPT,R0	; GET ADDRESS OF RECORD BLOCK
	MOV	R$NAME(R0),R2	; GET ADDRESS OF NAME STRING
	CALL	$ERMSG		; OUTPUT ERROR MESSAGE, NO RETURN

;
; SEARCH FOR UNDEFINED SYMBOLS IN EPT OR REQUESTED MODULES
; IN MNT
;

LBSRC1:				;
	MOV	$INPPT,R0	; POINT TO INPUT FILE SWITCH WORD
	MOV	R$SWTH(R0),R2	; GET FILE SWITCH WORD
	BIC	#^C<SW$AL!SW$DA!SW$MA>,R2 ; SAVE SWITCHES TO PROPAGATE
	MOV	R2,ALSW		; SAVE SWITCHES
	MOV	R4,R1		; GET ADDRESS OF MODULE NAME LIST
	BEQ	30$		; IF EQ SEARCH FOR UNDEFINED SYMBOLS
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	MOV	#LBMOD,R1	; GET ADDRESS OF LOCAL STORE
	MOV	R1,-(SP)	; SAVE ADDRESS
10$:				;
	MOV	(R0)+,(R1)+	; TRANSFER LIST TO LOCAL STORE
	BEQ	20$		; IF EQ HAVE ALL OF LIST
	MOV	(R0)+,(R1)+	; MOVE SECOND HALF OF NAME
	BR	10$		;
20$:				;
	MOV	(SP)+,R0	; GET MODULE NAME LIST POINTER
	MOV	(R0)+,LCLSYM	; SETUP LOCAL SYMBOL DESCRIPTOR
	BEQ	50$		; IF EQ DONE WITH LIST
	MOV	(R0)+,LCLSYM+2	; SET SECOND HALF OF MODULE NAME
	MOV	R0,-(SP)	; SAVE LIST POINTER
	CALL	LBSRC2		; SEARCH LIBRARY
	BCC	25$		; IF C/C FOUND MODULE
	MOV	#<S$V2*400!E$R77>,R1 ; GET ERROR/SEVERITY
	MOV	#LCLSYM,R2	; POINT TO MODULE NAME
	CALL	$ERMSG		; FATAL, NO RETURN
25$:				;
	CALL	LBSRC3		; PROCESS MODULE
	BR	20$		; GO AGAIN
30$:				;
	TST	S$GUND(R5)	; ANY UNDEFINED SYMBOLS
	BEQ	50$		; IF EQ NO
	MOV	R5,R0		;++042 GET ADDRESS OF SEGMENT DESCRIPTOR
	ADD	#S$GSTB,R0	;++042 POINT TO SYMBOL TABLE
	MOV	#$ISED,-(SP)	;++042 PUSH ADDRESS OF SYMBOL EDIT ROUTINE
32$:				;++042
	CALL	@(SP)+		;++042 GET NEXT SYMBOL
	BCS	35$		;++042 IF C/S  DONE
	BITB	#<SY$DEF!SY$WK>,S$YFLG(R0) ; DEFINITION OR WEAK REFERENCE?
	BNE	32$		;++042 IF NE YES
	CALL	$BLDRF		; BUILD REFERENCE LIST ENTRY
	BR	32$		;++042 GO AGAIN
35$:				;++042
	MOV	#$EDRF,-(SP)	; PUSH ADDRESS OF SYMBOL EDIT ROUTINE
40$:				;
	CALL	@(SP)+		; GET NEXT SYMBOL
	BCS	50$		; IF C/S DONE
	MOV	S$YM(R0),LCLSYM	; SETUP LOCAL DESCRIPTOR WITH SYMBOL
	MOV	S$YM+2(R0),LCLSYM+2 ;
	MOV	R1,-(SP)	;++042 SAVE VIRTUAL ADDRESS OF SYMBOL
	CALL	LBSRC2		; SEARCH LIBRARY
	MOV	(SP)+,R1	;++042 RESTORE VIRTUAL ADDRESS OF SYMBOL
	INC	(SP)+		; CLEAN STACK
	BCC	43$		; IF C/CLEAR FOUND EPT
	CALL	$DELRF		; REMOVE ENTRY FROM REFERENCE LIST
	BR	35$		; GO AGAIN
43$:				;++042
	CALL	LBSRC3		; PROCESS ELEMENT
	BR	35$		; GO AGAIN
50$:				;
	MOV	#$FRHD,R0	; GET LISTHEAD ADDRESS
	MOV	BFSIZ,R1	; GET SIZE OF BUFFER
	MOV	BFBAS,R2	; GET BUFFER ADDRESS
	CALLR	$RLCB		; RELEASE CORE BLOCK

;
; SEARCH LIBRARY FILE FOR MODULE NAME OR SYMBOL
;
; INPUTS:
;
;	LCLSYM,LCLSYM+2 CONTAIN REQUESTED NAME
;
;
; OUTPUTS:
;
;	C-BIT SET=NAME NOT IN LIBRARY
;	R0=0 MORE MATCHES POSSIBLE
;	R0=-1 NO MORE MATCHES ARE POSSIBLE
;
;	C-BIT CLEAR=FOUND MATCH IN EPT OR MNT
;	R0=0
;	R3=POINTER TO EPT OR MNT ENTRY
;

LBSRC2:				;
	MOV	R4,-(SP)	; SAVE R4 AND R5
	MOV	R5,-(SP)	; ...
	CLR	-(SP)		; SET MORE-SYMBOLS INDICATOR
	CLR	SRCDR		;++015 CLEAR SEARCH DIRECTION FLAG
40$:				;
	MOV	BFBAS,R0	; GET BASE ADDRESS OF SEARCH BUFFER
	MOV	R0,R1		;COPY BASE ADDRESS
	BIC	#177770,R0	;CLEAR EXCESS BITS
	CMP	LCLSYM,(R1)	;SYMBOL LOWER THAN BUFFER?
	BHI	50$		;IF HI NO
	BLO	45$		;IF LO READ BUFFER BACKWARD
	CMP	LCLSYM+2,2(R1)	;SYMBOL LOWER THAN BUFFER?
	BHIS	50$		;IF HIS NO
45$:
	DEC	SRCDR		;++015 DECREMENT FLAG FOR BACKWARD SEARCH
	BGE	110$		;++015 LAST SEARCHED FORWARD, NOT IN LIBRARY.
	CALL	LBRDB		; READ BUFFER BACKWARD IN FILE
	BCS	110$		;IF CS NO BACKWARD BUFFER
	BR	40$		;TRY AGAIN
50$:	MOV	BFTOP,R2	;GET ADDRESS OF TOP ENTRY IN BUFFER
	CMP	LCLSYM,(R2)	;LOWER THAN TOP OF BUFFER?
	BLO	60$		;IF LO YES
	BHI	55$		;IF HI NO
	CMP	LCLSYM+2,2(R2)	;LOWER THAN TOP OF BUFFER?
	BLOS	60$		;IF LOS YES
55$:
	INC	SRCDR		;++015 INCREMENT FLAG FOR FORWARD SEARCH
	BLE	110$		;++015 LAST SEARCHED BACKWARD, NOT THERE
	CALL	LBRDF		; READ BUFFER FORWARD IN FILE
	BCS	100$		;IF CS NO MORE MATCHES ARE POSSIBLE
	BR	40$		;TRY AGAIN
60$:	MOV	R1,R3		;CALCULATE TRAIL INDEX HALFWAY IN BUFFER
	ADD	R2,R3		;
	ROR	R3		;HALVE RESULT
	BIC	#7,R3		;CLEAR LOW BITS
	BIS	R0,R3		;SET PROPER OFFSET BITS
	CMP	(R3),LCLSYM	;FIRST HALF MATCH?
	BHI	80$		;IF HI LOWER UPPER LIMIT
	BLO	70$		;IF LO RAISE LOWER LIMIT
	CMP	2(R3),LCLSYM+2	;SECOND HALF MATCH?
	BEQ	120$		;IF EQ YES
	BHI	80$		;IF HI LOWER UPPER LIMIT
70$:	MOV	R3,R1		;RAISE LOWER LIMIT
	ADD	#10,R1		;REDUCE BY ONE MORE ENTRY
	BR	90$		;
80$:	MOV	R3,R2		;LOWER UPPER LIMIT
	SUB	#10,R2		;REDUCE BY ONE MORE ENTRY
90$:	CMP	R1,R2		;ANY MORE TO SEARCH?
	BLOS	60$		;IF LOS YES
	BR	110$		;SYMBOL NOT IN LIBRARY
100$:				;
	COM	(SP)		; SET NOT-IN-LIBRARY FLAG
110$:				;
	SEC			; SET NOT-FOUND FLAG
120$:				;
	MOV	(SP)+,R0	; GET FLAG
	MOV	(SP)+,R5	; RESTORE R5 AND R4
	MOV	(SP)+,R4	;
	RETURN			;

;
; PROCESS LIBRARY ELEMENT
;
; INPUTS:
;
;	R3=POINTER TO ENTRY IN MNT OR EPT
;
; OUTPUTS:
;
;	THE SPECIFIED LIBRARY MODULE IS PROCESSED
;
;

LBSRC3:				;
	MOV	#E$LMND+4,R1	;GET SIZE OF LIBRARY ELEMENT DESCRIPTOR
	CALL	$ALSVB		; ALLOCATE VIRTUAL BLOCK
	CALL	$LCKPG		; LOCK PAGE IN MEMORY
	MOV	R0,-(SP)	; SAVE REAL ADDRESS
	MOV	R1,-(SP)	; SAVE VIRTUAL ADDRESS
	MOV	$CRVEL,R1	; GET VIRTUAL ADDRESS OF CURRENT
	ADD	#<E$LNXT>/2,R1	; POINT TO LINK NEXT
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	CALL	$WRMPG		; WRITE-MARK PAGE
	MOV	(SP),(R0) 	; SET LINK TO NEXT
	MOV	(SP)+,$CRVEL	; SET VIRTUAL ADDRESS OF DESCRIPTOR
	MOV	(SP)+,R4	; SET REAL ADDRESS OF DESCRIPTOR
	MOV	R4,$CRELM	; SAVE ADDRESS OF CURRENT ELEMENT
	DEC	E$LNUM(R4)	;SET HIGHEST SECTION NUMBER TO -1
	MOV	#SW$LB,E$LSWT(R4);SET SWITCH OPTION WORD
	BIS	ALSW,E$LSWT(R4)	; MERGE AUTOLOAD SWITCH
	CLR	R1		;CLEAR HIGH PART OF VIRTUAL BLOCK NUMBER
	MOV	4(R3),R2	;SET LOW PART OF VIRTUAL BLOCK NUMBER
	MOV	6(R3),R3	;SET RELATIVE BYTE WITHIN BLOCK
	MOV	R2,E$LMND(R4)	;SAVE VIRTUAL BLOCK IN ELEMENT DESCRIPTOR
	MOV	R3,E$LMND+2(R4)	;SAVE BYTE WITHIN BLOCK IN ELEMENT DESCRIPTOR
	MOV	$INPPT,R0	; GET FDB ADDRESS
	MOVB	#R.VAR,F.RTYP(R0) ; SET VARIABLE LENGTH RECORD TYPE
	MOVB	#FD.PLC,F.RACC(R0) ; SET TO PARTIAL LOCATE MODE
	CLR	F.VBN(R0)	; ZERO BLOCK NUMBER
	CLR	F.VBN+2(R0)	;
	CLRB	F.RATT(R0)	; RESET RECORD ATTRIBUTES
	CALL	.POINT		;POINT TO DESIRED RECORD
	BCS	110$		;IF CS I/O ERROR
	GET$S	R0		; GET MODULE HEADER RECORD
	BCS	110$		;IF CS I/O ERROR
	MOV	F.NRBD+2(R0),R1 ;++008 GET ADDRESS OF BUFFER
	BITB	#MH$SS,M$HFL(R1) ;++008 SELECTIVE SEARCH MODULE ?
	BEQ	105$		;++008 NO -- CONTINUE
	BIS	#SW$SS,E$LSWT(R4) ;++008 YES -- TURN ON SELECTIVE SEARCH
105$:				;++008
	BIS	SLSW,E$LSWT(R4) ;++008 SELECTIVE SEARCH FLAG MAY OVERRIDE
	CLR	$NBYTE		;CLEAR CURRENT BYTE COUNT
	CALL	PRCELM		;PROCESS ELEMENT
	MOV	$CRVEL,R1	; GET VIRTUAL ADDRESS OF ELEMENT
	CALL	$UNLPG		; UNLOCK PAGE
	RETURN			;
110$:				;
	MOV	$INPPT,R0	; GET ADDRESS OF INPUT FILE RECORD BLOCK
	MOV	R$NAME(R0),R2	; GET ADDRESS OF NAME BLOCK
	MOV	(PC)+,R1	;I/O ERROR
	.BYTE	E$R10,S$V2	;FATAL-NO RETURN
	CALL	$ERMSG		;OUTPUT ERROR MESSAGE

;
; SUBROUTINE TO READ LIBRARY SEARCH BUFFER
;

LBRDB:	MOV	LBRBF,R2	;READ BUFFER BACKWARDS
	DEC	R2		;BACK OFF ONE BUFFER
	BR	LBRD		;
LBRDF:	MOV	LBRBF,R2	;READ BUFFER FORWARDS
	INC	R2		;INCREMENT BY ONE BUFFER
LBRD:	MOV	R2,R1		;COPY BUFFER NUMBER
	DEC	R1		;BACK OFF BY ONE BUFFER
	SEC			;ASSUME NOT WITHIN RANGE
	BLT	40$		;IF LT NOT WITHIN RANGE
	MOV	BKPBF,R0	; GET NUMBER OF BLOCKS PER BUFFER

	.IF DF	V1145

	MUL	R0,R1		; CALCULATE RELATIVE BLOCK NUMBER

	.IFF

	CALL	$MUL		; CALCULATE RELATIVE BLOCK NUMBER

	.ENDC

	MOV	R1,R0		;COPY RELATIVE BLOCK NUMBER
	ADD	EPBLK,R1	;CALCULATE VIRTUAL BLOCK NUMBER IN EPT
	CMP	R1,EPHBK	;WITHIN RANGE?
	SEC			;ASSUME NOT WITHIN RANGE
	BGE	40$		;IF GE NOT WITHIN RANGE
	MOV	R2,LBRBF	;SET NEW SEARCH BUFFER NUMBER
	MOV	R1,R2		;COPY STARTING VIRTUAL BLOCK NUMBER
	ADD	BKPBF,R2	;CALCULATE ENDING VIRTUAL BLOCK NUMBER
	MOV	BFEND,-(SP)	;ASSUME FULL BUFFER TO READ
	CMP	R2,EPHBK	;WITHIN RANGE?
	BLE	10$		;IF LE YES

	.REPT	6
	ASL	R0		; CALCULATE NUMBER OF EPT ENTRIES
	.ENDR

	MOV	EPNUM,(SP)	;GET NUMBER OF EPT ENTRIES IN LIBRARY
	SUB	R0,(SP)		;SUBTRACT OUT NUMBER TO STARTING BLOCK
	DEC	(SP)		;BACK OFF BY FOR RELATIVE ADDRESS CALCULATION
	ASL	(SP)		;CALCULATE RELATIVE OFFSET WITHIN BUFFER
	ASL	(SP)		;
	ASL	(SP)		;
	ADD	BFBAS,(SP)	; ADD IN BASE ADDRESS OF SEARCH BUFFER
	MOV	EPHBK,R2	;SET HIGHEST BLOCK IN EPT
10$:				;
	SUB	R1,R2		; CALCULATE NUMBER OF BLOCKS
	SWAB	R2		; MULTIPLY BY 256
	ASL	R2		; CONVERT TO BYTE COUNT
	MOV	(SP)+,BFTOP	; SET ADDRESS OF LAST EPT ENTRY
	MOV	BFBAS,R0	; GET BUFFER ADDRESS
	CALL	LBSRD		; READ EPT BUFFER
	BCS	50$		; IF C/S I/O ERROR
40$:				;
	RETURN			;
50$:				;
	MOV	$INPPT,R0	; GET ADDRESS OF INPUT FILE RECORD BLOCK
	MOV	R$NAME(R0),R2	; GET ADDRESS OF NAME BLOCK
	MOV	(PC)+,R1	;I/O ERROR
	.BYTE	E$R10,S$V2	;FATAL-NO RETURN
	CALL	$ERMSG		;OUTPUT ERROR MESSAGE
;
; READ LIBRARY HEADER AND TABLES
;
; INPUTS:
;
;	R0=BUFFER ADDRESS
;	R1=VIRTUAL BLOCK NUMBER
;	R2=BYTE COUNT
;
; OUTPUTS:
;
;	C/CLEAR - DATA READ AS REQUESTED
;
;	C/SET - I/O ERROR
;
; R0 AND R2 ARE UNMODIFIED
;

LBSRD:				;
	MOV	R1,-(SP)	; SAVE VBN
	MOV	$INPPT,R1	; GET ADDRESS OF INPUT FDB
	MOVB	F.LUN(R1),LBQIO+Q.IOLU ; SET LOGICAL UNIT NUMBER
	MOV	#LBQIO+Q.IOPL,R1 ; POINT TO PARAMETER LIST
	MOV	R0,(R1)+	; SET BUFFER ADDRESS
	MOV	R2,(R1)+	; SET BYTE COUNT
	CMP	(R1)+,(R1)+	; POINT TO VBN
	MOV	(SP)+,(R1)	; SET VBN
	DIR$	#LBQIO		; EXECUTE QIO-AND-WAIT
	BCS	10$		; IF C/S EXIT NOW
	ROLB	LBSTS		; GET I/O STATUS
10$:				;
	RETURN			;


;
; CALL ELEMENT PROCESSING SUBROUTINE
;

PRCELM:				;
	MOV	$LBFN,-(SP)	; PUSH RETURN ADDRESS
	JMP	@$PRCL		; PROCESS THE ELEMENT
$LBFIN::			; REF. LABEL
	RETURN			;

	.END
