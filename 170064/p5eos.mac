	.TITLE	P5EOS
	.IDENT	/19.01/

;
;
; COPYRIGHT (c) 1988 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED
; OR COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;
; D. N. CUTLER/C. MONIA 27-JAN-74
;
; MODIFIED FOR RSX-11M/M-PLUS V4.0/V2.0 BY:
;
;	J. A. KASSON
;	C. B. PETROVIC
;	J. M. LAWLER
;
; MODIFIED BY:
;
;	C. B. PETROVIC	22-JAN-82	18.01
;		CBP032		FIX PLACEMENT OF SUPER-MODE VECTORS OF I&D
;				TASKS INTO I-SPACE IN ALL CASES.
;
;	C. B. PETROVIC	26-FEB-82	18.02
; 		CBP039		ADD CORRECT .PSECT DEFINITIONS TO
;				ALLOW TKB TO BE LINKED AS AN I/D TASK.
;
;	C. B. PETROVIC	03-MAR-82	18.03
;		CBP040		CORRECT METHOD OF DETERMINING THE DISK
;				AREA WHICH MUST BE PATCHED. SPECIFICALLY,
;				CHECK THE BIT CS$TYP IN THE CONTROL SECTION
;				ENTRY TO DETERMINE WHAT DISK BLOCK ADDRESS
;				MUST BE CHANGED.
;
;	C. B. PETROVIC	26-MAR-82	18.04
;		CBP045		CHANGE AUTOLOAD VECTOR FORMAT TO USE
;				THE IMPURE AREA POINTER .NAUTO TO
;				ACCESS THE ROUTINE $AUTO IN PREPARATION
;				FOR I/D AUTOLOAD SUPPORT.
;
;	C. B. PETROVIC	4-MAY-82	18.05
;		CBP050		CONVERT TO MODIFIED FORMAT AUTOLOAD VECTOR
;				GENERATION TO FACILITATE I/D AUTOLOAD
;				SUPPORT AS WELL AS SELECTIVE INCLUSION OF
;				ONLY THOSE AUTOLOADABLE SYMBOLS ACTUALLY
;				REFERENCED BY THE USER TASK.
;
;	C. B. PETROVIC	7-JUN-82	18.06
;		CBP051		ADD AUTOLOAD SUPPORT FOR USER-MODE
;				I/D TASKS.
;
;	C. B. PETROVIC	03-SEP-82	18.07
;		CBP056		ADD AUTOLOAD SUPPORT FOR USER-MODE
;				I/D TASKS, PHASE 2. CREATION AND
;				OUTPUT OF TASK-RESIDENT SEGMENT
;				DESCRIPTORS.
;
;	J. M. SALMAN	28-SEP-82	18.08
;		JMS071		ADD DSPPAT OPTION FOR PATCHING ABSOLUTE
;				D-SPACE ADDRESSES.
;
;	C. B. PETROVIC	15-OCT-82	18.09
;		CBP061		FIX THE IMPLEMENTATION OF OVERLAID SUPER-MODE
;				LIBRARIES. SPECIFICALLY, INSURE THAT WHEN
;				AUTOLOAD VECTORS ARE GENERATED FOR THE SUPER-
;				-MODE ENTRYPOINT, IT IS CORRECTLY RELOCATED
;				TO THE ALTERNATE AUTOLOAD POINT, .NAUTx, WHERE
;				'x' IS THE LETTER 'P' THRU 'W'.
;
;	C. B. PETROVIC	19-APR-83	18.10
;		CBP083		CORRECT SETTING OF THE D-SPACE DISK BLOCK
;				ADDRESS IF THE SEGMENT IS READ/ONLY.
;
;	C. B. PETROVIC	31-OCT-83	18.11
;		CBP113		ADD SOME EXTRA SPACE AT THE LOCAL WINDOW
;				WINDOW DESCRIPTOR (HOWIE B. COULDN'T
;				BUILD HIS TASK).
;
;	D. P. RABAHY	19-OCT-84	18.12
;		DPR005		ADD THE OFFSET BIAS TO THE VIRTUAL LOAD ADDRESS
;				IN THE D-SPACE PORTION OF A SEGMENT DESCRIPTOR.
;				THIS CORRECTS A PROBLEM REPORTED IN 21P.
;
; MODIFIED FOR RSX-11M-PLUS AND MICRO/RSX V4.0 BY:
;
;	L. M. PETERSON	16-APR-86	19.00
;		LMP045		ADD SUPPORT FOR OPTIMIZED OTS
;				(MODIFY TASK RESIDENT SEGMENT DESCRIPTORS)
;
; MODIFIED FOR RSX-11M-PLUS AND MICRO/RSX V4.2 BY:
;
;	L. M. PETERSON	31-MAY-88	19.01
;		LMP112		CHECK FOR AUTOLOAD VECTORS FROM OVERLAID
;				COMMONS AND REPLACE WITH $$RTS VALUE 
;
; LOCAL MACROS
;

	RGDF	,,S
	WDBDF	,,S

;
; LOCAL DATA
;
; SYMBOL DATA
;

	IMPURE			; READ/WRITE D-SPACE

RTSVAL:	.BLKW	1		; TEMPORARY STORAGE FOR $$RTS VALUE
SGDAL:	.BLKW	1		; RELOCATED TASK-VIRT. ADDR OF PSECT $$ALVD
CRFLG:	.BLKW	1		; SEGMENT FLAGS
CRSYM:	.BLKW	<<S$ZSEG + S$ZIDX>/2> + 1 ; ALLOCATE ROOM FOR THE POSSIBILITY
				; OF HAVING TO OUTPUT AN EXTENDED SEGMENT
				; DESCRIPTOR FOR AN I/D TASK...
CRWND:	.BLKW	<<W$NLGH/2> * 2> + 2 ; ALLOCATE ROOM FOR TWO WINDOW DESCRIPTORS


	PURE.D

RTSNM:	.RAD50	/$$RTS/		; ENTRY POINT FOR DUMMY RETURN IN OVDAT RTS
	.EVEN

	.IF DF D$P5EO

	PURE.D
;
;
	.PSECT	TRPT$D,RO,D

$TRSPH:	.WORD	-1		; Phase on which to dump the seg. desc.
$TRSCS:	.WORD	0		; Real memory address of current segment
$TRTSG:				; reference label

	TRC	T$RBLK,^/%NT$RBLK - %P%N/
	TRC	T$RLDA,^/T$RLDA - %P%N/
	TRC	T$RLNG,^/T$RLNG - %P%N/
	TRC	T$RUP,^/T$RUP  - %P%N/
	TRC	T$RDWN,^/T$RDWN - %P%N/
	TRC	T$RNXT,^/T$RNXT - %P%N/
	TRC	T$RNME,^/T$RNME - %2R%N/
	TRC	T$RWDP,^/T$RWDP - %P%N/
	TRC	T$DBLK,^/T$DBLK - %P%N/
	TRC	T$DLDA,^/T$DLDA - %P%N/
	TRC	T$DLNG,^/T$DLNG - %P%N/
	TRC	T$DWDP,^/T$DWDP - %P%N/
;
	.PSECT	TRPT$D,RO,D
	.WORD	-1		; flag the end of the list.
;
	.PSECT	TRPT$D,RO,D

$TRWPH:	.WORD	-1		; phase on which to dump the window blk
$TRWCS:	.WORD	0		; real memory address of current window
$TRWIN:				; reference label

	TRC	W.NID,^/%NWindow ID; Base APR  - %P%N/
	TRC	W.NBAS,^/Base virtual address - %P%N/
	TRC	W.NSIZ,^/Window size (64b blks)-%P%N/
	TRC	W.NRID,^/Region ID            - %P%N/
	TRC	W.NOFF,^/Offset in partition  - %P%N/
	TRC	W.NLEN,^/Length to map        - %P%N/
	TRC	W.NSTS,^/Window status word   - %P%N/
	TRC	W.NLGH,^/Window flags word    - %P%N/
	TRC	W$NREG,^/Address of reg. desc - %P%N/
;
	.PSECT	TRPT$D,RO,D
	.WORD	-1		; flag the end of the list
;
	.ENDC


;+
; **-$P5EOS-PHASE 5 OUTPUT AUTOLOAD VECTORS AND SEGMENT TABLES
;
; THIS ROUTINE IS CALLED AFTER THE PHASE 5 MODULE SCAN TO WRITE
; AUTOLOAD VECTORS AND SEGMENT TABLES INTO THE TASK IMAGE
; AND PROCESS THE PATCH LIST.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	NONE.
;-
	PURE.I			; READ-ONLY I-SPACE

$P5EOS::			;
	SAVRG			; SAVE NON-VOLATILE REGISTERS.
	MOV	$TSKPT,R0	; GET TASK FILE SWITCHES
	BIT	#SW$NH,R$SWTH(R0) ; ARE WE BUILDING A LIBRARY?
	BEQ	6$		; IF EQ, NO
	JMP	80$		; IF NE, YES...NO SEGMENT TABLES TO WRITE
				; OR AUTOLOAD VECTORS TO GENERATE EITHER...
6$:
	CMP	#1,$NUMSG	; IF NOT A LIBRARY, HOW 'BOUT AN OVERLAID TASK?
	BNE	7$		; IF NE, OVERLAYS HAVE BEEN DEFINED
				; WHAT WE HAVE NOW IS AN UN-OVERLAID TASK WITH
	JMP	449$		; NO SEGMENT TABLES TO WRITE, BUT THERE
				; MAY BE AUTOLOAD VECTORS TO WRITE.
7$:				;
	MOV	$RTSEG,R4	; GET ADDRESS OF ROOT SEGMENT
	MOV	R4,R0		; GET VIRTUAL ADDRESS OF ROOT
	CALL	$ADRST		;SET ADDRESS LIMITS
	CLRB	$STYP		; FLAG AS I-SPACE ONLY TASK FIRST, THEN CHECK...
	BIT	#ID$ATA,$SWTCH	; IS THIS AN I&D TASKBUILD?
	BEQ	8$		; IF EQ, NO...CONVENTIONAL TASK
	INCB	$STYP		; CLEAR SECTION TYPE - SEGMENT DESCRIPTORS
				; ARE IN D-SPACE
8$:
	MOV	$CRSEG,R3	; GET ADDRESS OF CURRENT SEGMENT
	MOV	#CRSYM,R5	; GET ADDRESS OF TEMP BUFFER
	MOV	S$GBLK(R3),(R5)	; SET BLOCK NUMBER (RELATIVE)
	MOV	S$GSTS(R3),R4	; GET SEGMENT FLAGS
	MOV	R4,CRFLG	; SAVE SEGMENT FLAGS
	BIT	#SG$RO,CRFLG	; R-O SEGMENT?
	BEQ	75$		; IF EQ NO
	MOV	S$GBLK+2(R3),(R5) ; SET R-O RELATIVE BLK NUMBER
	BIS	#<SG$LOD!SG$DSK>,R4	; SER NO DISK
75$:

	.IF	NDF	R$$11M

	SUB	$LBBLK,(R5)	; MAKE BLOCK RELATIVE TO HEADER

	.IFF

	SUB	$HDRBN,(R5)	; MAKE BLOCK RELATIVE TO HEADER

	.ENDC

	BIC	#^C<SG$DES!SG$DSK!SG$MEM!SG$LOD>,R4 ; CLEAR UNWANTED BITS
	SWAB	R4		; POSITION TO HIGH BYTE
	BIS	R4,(R5)+	; SET IN STATUS BITS
	MOV	#S$GSEG,R0	; GET OFFSET TO DESCRIPTOR
	CALL	RELOC		; COMPUTE TASK-VIRTUAL ADDRESS
	MOV	R0,R4		; SET ADDRESS
	MOV	S$GLDA(R3),(R5)	; SET LOAD ADDRESS
	BIT	#ID$ATA,$SWTCH	; ARE WE BUILDING AN I/D TASK??
	BEQ	750$		; IF EQ, NO...CONVENTIONAL
	BIS	#TR$DSP,(R5)	; FLAG THE SEGMENT AS HAVING D-SPACE
750$:
	ADD	$OFFST,(R5)+	; ADD OFFSET BIAS
	MOV	S$GLNG(R3),(R5)+ ; SET SEGMENT LENGTH
	MOV	S$GUP(R3),(R5)+  ; SET LINK UP
	MOV	S$GDWN(R3),(R5)+ ; SET LINK DOWN
	MOV	S$GNXT(R3),(R5)+ ; SET LINK NEXT (OR LINK RIGHT)
	TST	$AFLG		 ; USING AUTOLOAD?
	BEQ	752$		 ; IF EQ, NO
	TST	S$GDWN(R3)	 ; IS THIS A ROOT SEGMENT?
	BNE	751$		 ; IF NE, NO
	MOV	R4,$RTVAL	 ; UPDATE ROOT PTR
	BIC	#100000,-14(R5)	 ; RESET SG$DES TO INDICATE THIS IS A ROOT
751$:	MOV	$RTVAL,(R5)+	 ; SET PTR TO ROOT
	CLR	(R5)+		 ; ZERO OUT SPACE FOR MAPPING INFO
	BR	753$

752$:	MOV	S$GNME(R3),(R5)+ ; SET NAME, FIRST HALF
	MOV	S$GNME+2(R3),(R5)+ ; SET NAME, SECOND HALF
753$:	CLR	(R5)+		 ; ASSUME NO DESCRIPTOR TO BE WRITTEN
	CMP	S$GWDP(R3),$RTWDP; IS THIS THE ROOT WINDOW??
	BEQ	950$		; IF EQ YES
	MOV	#S$GWND,R0	; GET OFFSET TO WINDOW INFORMATION
	CALL	RELOC		; GET TASK IMAGE ADDRESS OF DESCRIPTOR
	MOV	R0,-2(R5)	; SET ADDRESS OF WINDOW DESCRIPTOR
	BIT	#ID$ATA,$SWTCH	; BUILDING AN I/D TASK
	BEQ	755$		; IF EQ, NO...
	CALL	DSEXT		; COPY EXTENDED DESCRIPTOR DATA
	MOV	#S$GWND,R0	; GET OFFSET TO WINDOW INFORMATION
	CALL	RELOC		; GET TASK-VIRTUAL ADDRESS INFORMATION
	ADD	#W$NLGH,R0	; ADJUST THE ADDRESS TO POINT TO THE D-WINDOW
	MOV	R0,-2(R5)	; SET THE D-SPACE WINDOW POINTER
755$:
	BIT	#SG$RES,CRFLG	; SEGMENT RESIDENT?
	BEQ	10$		; IF EQ, NO...
	MOV	S$GWDP(R3),R1	; GET I-SPACE WINDOW POINTER V.A.
	CALL	$CVRL		; CONVERT DESCRIPTOR ADDRESS TO REAL
	BIT	#FO$MAP,$SWOVR	; USE OTS FAST MAP ROUTINE?
	BEQ	85$		; IF EQ, NO
	TST	$AFLG		; USING AUTOLOAD?
	BEQ	85$		; IF EQ, NO - CAN'T USE OTS FAST MAP ROUTINE
	MOV	#CRSYM,R2
	MOV	W.NSIZ(R0),R1	
	MOV	R1,W.NLEN(R0)	; MAKE WINDOW SIZE LENGTH TO MAP
	ADD	#177,R1		; AND ROUND UP TO NEXT 4K BOUNDARY
	BIC	#177,R1
	MOV	R1,W.NSIZ(R0)
	ASR	R1
	ASR	R1
	ASR	R1
	MOV	R1,16(R2)	; IN LOW BYTE (I-SPACE SIDE) OF SEG NAME FIELD
	MOV	W.NBAS(R0),R1	; GET APR
	CALL	GETAPR
	BIS	R1,16(R2)	; AND STASH THIS TOO
85$:
	MOV	#W$NLGH/2,R1	; GET LENGTH OF WINDOW DESCRIPTOR IN WORDS

	.IF DF D$P5EO

	MOV	R5,$TRWCS	; SET THE CURRENT WINDOW BLOCK ADDRESS

	.ENDC

9$:				;
	MOV	(R0)+,(R5)+	; COPY WINDOW
	SOB	R1,9$		; ...
	CLR	(R5)		; RESET REGION BACKPOINTER
	ADD	$LBOFF,-<W$NREG-W.NOFF+2>(R5) ; INCLUDE WINDOW OFFSET INTO
				; REGION. NOTE THAT THIS IS AN OFFSET
				; RELATIVE TO R5. THIS IS SO BECAUSE WE MAY
				; HAVE A D-SPACE SEGMENT DESCRIPTOR EXTENSION
				; AND IF SO, THE W.NOFF OFFSET MUST NOT BE
				; REFERRED TO IN AN ABSOLUTE MANNER. SINCE WE
				; WILL ALWAYS HAVE R5 POINTING TO THE PLACE
				; THE REGION DESCRIPTOR POINTER IS, WE CAN USE
				; THE NEGATIVE DIFFERENCE OFFSET TO GET TO
				; W.NOFF...
	.IF DF D$P5EO

	MOV	R0,-(SP)	; SAVE R0
	MOV	$PHASE,$TRWPH	; COPY THE PHASE NUMBER
	MOV	#$TRWIN,R0	; POINT TO THE LIST
	CALL	$TRACE		; AND DUMP IT TO TI:
	MOV	(SP)+,R0	; RESTORE R0 BEFORE EXITING...

	.ENDC

	BIT	#ID$ATA,$SWTCH	; BUILDING AN I/D TASK
	BEQ	10$		; IF EQ, NO...BYPASS THE D-SPACE WINDOW STUFF
	MOV	S$GDWP(R3),R1	; GET THE D-SPACE WINDOW VIRTUAL ADDRESS
	BIT	#SG$RES,CRFLG	; SEGMENT RESIDENT??
	BEQ	950$		; IF EQ, NO...
	CALL	$CVRL		; CONVERT TO REAL
	BIT	#FO$MAP,$SWOVR	; USE OTS FAST MAP ROUTINE?
	BEQ	95$		; IF EQ, NO
	TST	$AFLG		; USING AUTOLOAD?
	BEQ	95$		; IF EQ, NO - CAN'T USE OTS FAST MAP ROUTINE
	MOV	#CRSYM,R2
	MOV	W.NSIZ(R0),R1	
	MOV	R1,W.NLEN(R0)	; MAKE WINDOW SIZE LENGTH TO MAP
	ADD	#177,R1		; AND ROUND UP TO NEXT 4K BOUNDARY
	BIC	#177,R1
	MOV	R1,W.NSIZ(R0)
	ASR	R1
	ASR	R1
	ASR	R1
	SWAB	R1		; STORE FOR OTS OPTIMIZATION
	BIS	R1,16(R2)	; IN HIGH BYTE (D-SPACE SIDE)
	MOV	W.NBAS(R0),R1	; CALCULATE APR
	CALL	GETAPR
	SWAB	R1
	BIS	R1,16(R2)	; AND SAVE ON D-SPACE SIDE
95$:
	MOV	#W$NLGH/2,R1	; SET LENGTH OF WINDOW IN WORDS

	.IF DF D$P5EO

	MOV	R5,$TRWCS	; SET THE CURRENT WINDOW BLOCK ADDRESS

	.ENDC

901$:
	MOV	(R0)+,(R5)+	; COPY THE WINDOW DATA
	SOB	R1,901$		; LOOP 'TILL DONE.
	CLR	(R5)		; RESET REGION BACKPOINTER
	ADD	$LBOFF,-<W$NREG-W.NOFF+2>(R5) ; SET WINDOW OFFSET INTO REGION

	.IF DF D$P5EO

	MOV	R0,-(SP)	; SAVE R0
	MOV	$PHASE,$TRWPH	; COPY THE PHASE NUMBER
	MOV	#$TRWIN,R0	; POINT TO THE LIST
	CALL	$TRACE		; AND DUMP IT TO TI:
	MOV	(SP)+,R0	; RESTORE R0 BEFORE EXITING...

	.ENDC

	BR	10$
950$:				;

	CALL	DSEXT		; COPY THE EXTENDED DESCRIPTOR DATA
;
; WRITE BLOCK, LOAD ADDRESS, AND LENGTH INTO TASK IMAGE
;

10$:
	.IF DF D$P5EO

	MOV	R0,-(SP)	; SAVE R0
	MOV	#CRSYM,$TRSCS	; POINT TO STRUCTURE TO DUMP...
	MOV	$PHASE,$TRSPH	; COPY THE PHASE NUMBER
	MOV	#$TRTSG,R0	; POINT TO THE LIST
	CALL	$TRACE		; AND DUMP IT TO TI:
	MOV	(SP)+,R0	; RESTORE R0 BEFORE EXITING...

	.ENDC

	MOV	#3,R3		;SET REPEAT COUNT
	MOV	#CRSYM,R5	; GET ADDRESS OF DESCRIPTOR IMAGE
	CALL	WRBLK		; WRITE BLOCK INTO TASK IMAGE

;
; WRITE ADDRESS OF UP, DOWN, AND NEXT INTO TASK IMAGE
;

	MOV	#3,R3		;SET REPEAT COUNT
20$:	MOV	(R5)+,R1	;GET ADDRESS OF SEGMENT DESCRIPTOR
	BEQ	30$		;IF EQ NONE
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	ADD	#S$GSEG,R0	; POINT TO DESCRIPTOR ADDRESS
	CALL	RELOC1		; RELOCATE
	MOV	R0,R1		; COPY ADDRESS
30$:	MOV	R4,R0		;SET VIRTUAL ADDRESS OF WORD
	CALL	$WRWRD		;WRITE WORD INTO IMAGE
	ADD	#2,R4		;ADVANCE VIRTUAL ADDRESS
	SOB	R3,20$		;REPEAT

;
; WRITE S$GNME (OR OPTIMIZING INFO) INTO TASK IMAGE
;

	CMP	$SZSEG,#S$ZSEG	; SEGMENT NAME TO BE WRITTEN?
	BLO	45$		; IF LO NO
	MOV	#2,R3		;SET REPEAT COUNT
	CALL	WRBLK		; WRITE BLOCK INTO TASK IMAGE
	TST	$TSKWD		; TASK HAVE RESIDENT OVERLAYS?
	BEQ	45$		; IF EQ NO
	CALL	WRBLK		; WRITE WINDOW ADDRESS INTO TASK IMAGE
	BIT	#SG$RES,CRFLG	; SEGMENT RESIDENT?
	BNE	42$		; IF NE, YES
	MOV	#1,R3		; IF EQ, NO...INCLUDE ZERO WORD FOR THE
				; WINDOW BACKPOINTER WHEN WE WRITE OUT
				; THE D-SPACE SEGMENT DESCRIPTOR EXTENSION
	BR	45$
42$:
	BIT	#ID$ATA,$SWTCH	; BUILDING AN I/D TASK?
	BNE	43$		; IF NE, YES..WRITE THE EXTENDED SEGMENT
				; SEGMENT DESCRIPTOR FOR D-SPACE, THEN THE
				; D-SPACE WINDOW DESCRIPTOR
	MOV	-2(R5),R4	; IF EQ, NO...CONVENTIONAL TASK, HOWEVER,
				; WE NEED TO WRITE OUT THE I-SPACE WINDOW
				; DESCRIPTOR 'CAUSE IT'S A MEMORY RESIDENT
				; OVERLAID TASK
	BR	44$		; NOW JOIN THE COMMON CODE
43$:
	MOV	#<S$ZIDX/2>,R3	; SET SIZE OF EXTENSION
	CALL	WRBLK		; WRITE OUT THE BLOCK
	MOV	-<S$ZIDX+2>(R5),R4 ; GET TASK-VIRTUAL ADDRESS OF WINDOW BLOCK
44$:
	CALL	ALWAPR		; SET WINDOW DESCRIPTOR BASE ADDRESS AND APR
				; REQUIREMENTS
	MOV	#W$NLGH/2,R3	; GET SIZE OF WINDOW DESCRIPTOR IN WORDS
	CALL	WRBLK		; WRITE BLOCK
	BIT	#ID$ATA,$SWTCH	; BUILDING AN I/D TASK??
	BEQ	449$		; IF EQ, NO...CONVENTIONAL
	CALL	ALWAPR		; SET WINDOW DESCRIPTOR BASE ADDRESS AND APR
				; REQUIREMENTS
	MOV	#<W$NLGH/2>,R3	; SET SIZE OF D-SPACE WINDOW BLOCK
	CALL	WRBLK		; WRITE IT TO THE DISK
	BR	449$
45$:
	BIT	#ID$ATA,$SWTCH	; BUILDING AN I/D TASK?
	BEQ	449$		; IF EQ, NO
	ADD	#<S$ZIDX>/2,R3	; SET SIZE OF D-SPACE EXTENSION IN WORDS.
				; NOTE THAT THIS IS AN 'ADD' AND NOT A 'MOV'
				; BECAUSE IF WE DON'T HAVE A WINDOW BACKPOINTER
				; TO WRITE WE STILL WANT TO WRITE OUT A ZERO
				; IN ITS PLACE. IF WE'VE WRITTEN THE WINDOW
				; POINTER, THEN R3 WILL BE ZERO ANYWAY, SO THE
				; ADD WILL REVERT TO MERLY AN INPLIED 'MOV.'
	CALL	WRBLK		; NOW WRITE IT OUT...


;
; WRITE AUTOLOAD VECTORS
;

;
;+
; NOTE THIS WELL, FUTURE MAINTAINERS...
;	WHAT IS DONE HERE IS TO PROPERLY PUT THE SUPERVISOR-MODE AND THE
;	AUTOLOAD VECTORS (AS WE NOW KNOW THEM...) INTO I-SPACE INSTEAD OF
;	D-SPACE. COMPLICATIONS AROSE WHEN MANUAL LOADING I-D SPACE OVERLAYS
;	WAS APPEMPTED. DURING 'PATCHING' OF THE SEGMENT DESCRIPTORS, THE
;	SIZE OF THE RESIDENT SEGMENT DESCRIPTORS WAS BEING PUT INTO I-SPACE
;	TASK REGION ON DISK THUS OVERLAYING SOME LEGITIMATE CODE WITH AN
;	ILLEGITIMATE VALUE.
;-
;
449$:
	MOV	$RTSEG,R1	; GET VIRTUAL ADDRESS OF ROOT SEGMENT
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	ADD	#S$GCST,R0	; POINT TO SECTION TABLE FOR ROOT
	MOV	#RTSNM-S$YM,R1	; POINT TO AUTOLOAD SEGMENT SECTION
	CALL	$SRCH		; SEARCH FOR SECTION
	BCS	4495$		; IF CS, FORGET THIS!
	MOV	C$SBSE(R0),RTSVAL ; SAVE $$RTS VALUE
4495$:	BIT	#ID$ATA,$SWTCH	; IS THE AN I&D TASKBUILD?
	BEQ	450$		; IF EQ, NO...CONVENTIONAL TASK
	CLRB	$STYP		; YES, FLAG AS I-SPACE FOR AUTOLOAD VECTORS
				; AND SUPER-MODE VECTORS
450$:
	MOV	$CRSEG,R0	;GET ADDRESS OF CURRENT SEGMENT
	MOV	S$GATL(R0),R5	;GET ADDRESS OF FIRST AUTOLOAD ENTRY
	BEQ	80$		;IF EQ NONE
	MOV	#S$GAUT,R0	; GET OFFSET INTO ENTRY
	CALL	RELOC		; RELOCATE AUTOLOAD ENTRIES
	MOV	R0,R4		; SET LOAD ADDRESS
	BIT	#ID$ATA,$SWTCH	; ARE WE BUILDING AN I/D TASK??
	BEQ	455$		; IF EQ, NO...CONVENTIONAL
	MOV	#S$GDAL,R0	; IF NE, YES...
	CALL	RELOC		; RELOCATE $$ALVD
	MOV	R0,SGDAL	; AND SAVE IT FOR LATER...WE WILL USE
				; THIS VALUE TO GENERATE THE ADDRESS OF
				; THE D-SPACE PART OF AN I/D TASK'S
				; AUTOLOAD VECTOR PAIR
455$:
	MOV	$CRVSG,R0	; GET VIRTUAL ADDRESS OF CURRENT SEGMENT
	CALL	$ADRST		;SET ADDRESS LIMITS
50$:
	CALL	GETVAL		; GET VALUE OF AUTOLOAD ENTRYPOINT
	CLR	R0		; SET UP INCASE IT'S NOT SUPER-MODE
	BIT	#SY$SUP,S$YFLG(R3) ; WELL, IS IT SUPER-MODE??
	BEQ	55$		; IF EQ, NO...
	MOV	S$YCMP+4(R3),R0	; GET THE SUPER-MODE OFFSET VALUE
	ASL	R0		; CONVERT TO WORD OFFSET
55$:
	MOV	$ALVAL(R0),R0	; GET TASK-VIRTUAL ADDRESS OF .NAUT'X'
	SUB	R4,R0		; ADJUST ADDRESS TO POINT TO .NAUTO
	SUB	#4,R0		; VIA ADDRESSING MODE PC(7)
	MOV	R0,$ALVCT+2	; AND PUT IT AWAY IN THE AUTOLOAD VECTOR
				; PROTOTYPE. THIS MUST BE DONE EACH TIME
				; A VECTOR IS GENERATED BECAUSE OF THE
				; CHANGE FROM MODE PC(3) TO PC(7).
	SUB	#<$ALVIA-$ALVI>,R0 ; WE MUST ADJUST THE ADDRESS OF THE
				; P-SECTION $$ALVI SO WE CAN PROPERLY
				; CALCULATE THE ADDRESS OF .NAUTO. THIS
				; IS SO BECAUSE THE JUMP INSTRUCTION IS
				; NO LONGER THE FIRST INSTRUCTION IN THE
				; P-SECTION. IT IS NOW 4 BYTES (HALFWAY)
				; INTO IT...
	MOV	R0,$ALVIA+2	; DO THE SAME HERE FOR THE I-SPACE PART
				; OF THE I/D TASK'S AUTOLOAD VECTOR PAIR.
				; WE DO THIS AS A MATTER OF CONVENIENCE AND
				; FOR EXECUTION SPEED. NO SENSE DOING A WHOLE
				; SLEW OF BIT TESTS TO SAVE A MOVE!!!
	ADD	S$YVAL(R3),R1	; ADD IN VALUE
	MOV	R1,$ALADR+2	; PUT VALUE IN AUTO LOAD VECTOR
	MOV	S$YSEG(R3),R1	; GET V/A OF CALLED SEGMENT DESCRIPTOR
	CALL	$CVRL		; CONVERT TO REAL
	ADD	#S$GSEG,R0	; OFFSET TO DESCRIPTOR ADDRESS
	CALL	RELOC1		; RELOCATE
	MOV	R0,$ALADR	; SET AUTOLOAD VECTOR ADDRESS
	BIT	#SY$ATL,S$YFLG(R3) ; IS THIS SYMBOL AUTOLOADABLE
	BEQ	70$		   ; IF EQ, NO
	BIT	#SY$LIB,S$YFLG(R3) ; IF NE, YES...BUT IS IT FROM A LIBRARY?
	BEQ	70$		   ; IF EQ, NO....JUST AN ORDINARY AUTOLOADABLE
	BIT	#SY$SUP,S$YFLG(R3) ; IF NE, YES, BUT IS IT A SUPER-MODE SYMBOL?
	BNE	60$		   ; IF NE, YES...LOOK AT THE EXTENDED OFFSET
	ADD	S$YSDO(R3),$ALADR  ; IF EQ, NO...UPDATE THE ADDRESS
	SUB	R2,$ALADR	   ; REMOVE TASK BIAS SINCE THIS IS AN
				   ; AUTOLOADABLE SYMBOL FROM A LIBRARY...
	BR	70$		   ; AND CONTINUE...
60$:
	ADD	S$YSDX(R3),$ALADR  ; GET THE UPDATE VALUE FROM THE EXTENDED
				   ; OFFSET VALUE
	SUB	R2,$ALADR	   ; REMOVE TASK BIAS SINCE THIS IS AN
				   ; AUTOLOADABLE SYMBOL FROM A LIBRARY...
70$:
	BIT	#ID$ATA,$SWTCH	; AGAIN, ARE WE BUILDING AN I/D TASK??
	BEQ	72$		; IF EQ, NO...CONVENTIONAL TASK
				; IF NE, WE WANT TO WRITE A PAIR OF
				; AUTOLOAD VECTORS, ONE INTO THE I-SPACE
				; DISK (MEMORY) OF THE TASKIMAGE (P-SECTION
				; $$ALVI) AND ANOTHER INTO THE D-SPACE
				; PART (P-SECTION $$ALVD).
	MOV	SGDAL,$ALVDP	; SET THE ADDRESS OF THE D-SPACE PACKET
				; WHICH CONTAINS THE SEGMENT DESCRIPTOR
				; ADDRESS AND THE TARGET ENTRY POINT ADDRESS
	MOV	#$ALVI,R1	; POINT TO THE I-SPACE PART VECTOR PROTOTYPE,
	CALL	WRVCT		; AND SCRIBBLE IT TO DISK...
	MOV	R4,-(SP)	; NOW SAVE THE TASK-VIRTUAL I-SPACE ADDRESS
	MOV	SGDAL,R4	; GET THE D-SPACE TASK-VIRTUAL ADDRESS
	INCB	$STYP		; NOW THIS HERE STUFF'S GOTTA GO INTO THE
				; D-SPACE SECTION OF THE TASKIMAGE
	MOV	#$ALVD,R1	; POINT TO THE D-SPACE VECTOR PROTOTYPE,
	CALL	WRVCTD		; AND WRITE IT TO DISK
	ADD	#S$ZATD,SGDAL	; UPDATE THE D-SPACE PACKET ADDRESS
	CLRB	$STYP		; RESET TO 'INSTRUCTION' MODE
	MOV	(SP)+,R4	; AND RESTORE THE I-SPACE TASK-VIRTUAL ADDRESS
	MOV	(R5),R5		; GET NEXT ENTRY'S ADDRESS
	BNE	50$		; IF NE, WE'VE GOT ANOTHER ONE TO PROCESS
	BR	80$		; IF EQ, WE'RE DONE WITH THIS SEGMENT
72$:
	MOV	#$ALVCT,R1	; SET ADDRESS OF PROTOTYPE VECTOR
	CALL	WRVCT		; WRITE VECTOR
	MOV	(R5),R5		; GET ADDRESS OF NEXT ENTRY
	BNE	50$		; IF NE GO AGAIN
80$:
	MOV	$CRSEG,R0	; GET ADDRESS OF CURRENT SEGMENT
	MOV	S$GSPL(R0),R5	; GET ADDRESS OF FIRST SUPERVISOR LOAD ENTRY
	BEQ	100$		; IF EQ NONE
	MOV	#S$GSUP,R0	;GET OFFSET INTO ENTRY
	CALL	RELOC		; RELOCATE
	MOV	R0,R4		; SET LOAD ADDRESS
	MOV	$CRVSG,R0	; GET VIRTUAL ADDRESS OF CURRENT SEGMENT
	CALL	$ADRST		; SET ADDRESS LIMITS
;+
; NOTE THIS!!!
;	This causes all Supervisor-mode Vectors to be put into I-space
;	regardless of whether or not an I/D task is being built.
;	This code path is taken when there are no overlays to process.
;-
	BIT	#ID$ATA,$SWTCH	; IS THE AN I&D TASKBUILD?
	BEQ	90$		; IF EQ, NO...CONVENTIONAL TASK
	CLRB	$STYP		; FORCE THE SUPER-MODE VECTORS INTO I-SPACE
90$:
	CALL	GETVAL		; GET VALUE OF SUPERVISOR MODE ENTRY POINT
	MOV	S$YCMP+2(R3),R1
	MOV	R1,$SLADR+2	; PUT VALUE INTO VECTOR
	MOV	S$YCMP(R3),$SLVCT+2 ; PUT ADDR OF COMPLETION ROUTINE IN VECTOR
	MOV	#$SLVCT,R1	; GET ADDRESS OF VECTOR PROTOTYPE
	CALL	WRVCT		; WRITE VECTOR INTO IMAGE
	MOV	(R5),R5		; GET ADDRESS OF NEXT ENTRY
	BNE	90$		; IF NE GO AGAIN
100$:
	MOV	$CRVSG,R0	; GET VIRTUAL ADDRESS OF CURRENT SEGMENT
	CALL	$ADRST		;SET ADDRESS LIMITS

;
; PROCESS PATCH LIST
;

P5EOS1:				;
	BIT	#TS$KF,$SWTCH	; TASK IMAGE FILE SPECIFIED
	BEQ	P5EOS2		; IF EQ NO
	MOV	#$PATHD,R5	;GET ADDRESS OF PATCH LISTHEAD
10$:	MOV	(R5),R5		;GET ADDRESS OF NEXT PATCH BLOCK
	BEQ	P5EOS2		; IF EQ DONE
	MOV	R5,R4		;COPY ADDRESS OF BLOCK
	TST	(R4)+		;POINT TO NUMBER OF PARAMETERS
	MOV	(R4)+,R3	;GET NUMBER OF PARAMETERS
	BMI	10$		; IF MI - PATCH HAS BEEN PREVIOUSLY APPLIED
	MOV	$CRSEG,R0	;GET ADDRESS OF CURRENT SEGMENT
	CMP	(R4)+,S$GNME(R0);SEGMENT NAME MATCH?
	BNE	10$		;IF NE NO
	CMP	(R4)+,S$GNME+2(R0);SEGMENT NAME MATCH?
	BNE	10$		;IF NE NO
	BIT	#2,(R4)+	; IS THIS A GBLPAT ENTRY?
	BEQ	25$		; IF EQ NO - IT'S EITHER ABSPAT OR DSPPAT
	MOV	R4,R1		;COPY ADDRESS OF SYMBOL
	SUB	#S$YM,R1	;CALCULATE PROPER OFFSET FROM SYMBOL
	ADD	#S$GSTB,R0	;POINT TO SYMBOL TABLE
	CALL	$SRCH		;SEARCH FOR SYMBOL
	BCS	50$		; IF CS SEARCH FAILED
	BITB	#SY$IND,S$YFLG(R0);INDIRECT REFERENCE?
	BNE	10$		;IF NE YES
	BITB	#SY$DEF,S$YFLG(R0);SYMBOL DEFINITION?
	BEQ	10$		;IF EQ NO
	CMP	(R4)+,(R4)+	;POINT TO OFFSET
	BITB	#SY$REL,S$YFLG(R0);ABS SYMBOL?
	BEQ	20$		;IF EQ YES
	ADD	$OFFST,(R4)	;ADD IN OFFSET BIAS
20$:	ADD	S$YVAL(R0),(R4)	;ADD IN SYMBOL VALUE
	CALL	SETTYP		; SET SWITCH TO I OR D DEPENDING ON CS$TYP
	BR	30$		;
25$:
	BIT	#ID$ATA,$SWTCH	; BUILDING I/D TASK?
	BEQ	30$		; IF EQ NO
	CLRB	$STYP		; ASSUME I-SPACE PATCH
	TST	-2(R4)		; IS THIS AN ABSPAT?
	BEQ	30$		; IF EQ YES
	INCB	$STYP		; SET FOR D-SPACE PATCH
30$:	MOV	R3,-(SP)	;SET LOOP COUNT
	MOV	(R4)+,R3	;GET PATCH ADDRESS
40$:	MOV	R3,R0		;SET ADDRESS TO WRITE PATCH
	MOV	(R4)+,R1	;GET WORD TO BE WRITTEN
	CALL	$WRWRD		;WRITE WORD INTO IMAGE FILE
	ADD	#2,R3		;ADVANCE TO NEXT PATCH ADDRESS
	DEC	(SP)		;DECREMENT LOOP COUNT
	BGT	40$		;IF GT GO AGAIN
	TST	(SP)+		;CLEAN STACK
45$:
	BIS	#100000,2(R5)	; FLAG APPLIED
	BR	10$		; PROCESS NEXT PATCH
50$:
	BIT	#SU$PLB,$SWOVR	; LINKING TO SUPERVISOR MODE LIBRARY?
	BEQ	55$		; IF EQ NO
	CMP	#^R$CR,(R4)	; SYMBOL $CRVC - COMPLETION ROUTINE VECTOR
	BNE	55$		; IF NE NO
	CMP	#^RVC,2(R4)	; MAYBE
	BEQ	45$
55$:
	MOV	#<S$V0*400!E$R96>,R1	;
	MOV	R4,R2		; GET ADDRESS OF SYMBOL NAME
	CALL	$ERMSG		; PRINT ERROR MESSAGE
	BR	45$		; GO MARK SEGMENT FOUND
P5EOS2:				;
	RETURN			;

;
; RELOCATE DESCRIPTOR ADDRESS
;
; INPUTS:
;
; ENTRY POINT 'RELOC'
;
;	R0=OFFSET INTO SEGMENT DESCRIPTOR CONTAINING DESCRIPTOR BIAS
;	$CRSEG=REAL ADDRESS OF CURRENT DESCRIPTOR
;
; ENTRY POINT 'RELOC1'
;
;	R0=REAL ADDRESS OF DESCRIPTOR BIAS
;
; OUTPUTS:
;
;	R0=TASK-VIRTUAL ADDRESS OF DESCRIPTOR
;

RELOC:				;
	ADD	$CRSEG,R0	; POINT TO DESCRIPTOR BIAS
RELOC1:				;
	MOV	(R0)+,-(SP)	; SAVE BIAS
	MOV	(R0),R1		; GET VIRTUAL ADDRESS OF DESCRIPTOR SECTION
	CALL	$CVRL		; CONVERT TO REAL
	MOV	C$SBSE(R0),R0	; GET BASE OF SECTION
	ADD	$OFFST,R0	; ADD OFFSET BIAS
	MOV	(SP),R2		; SAVE TASK BIAS FOR LATER
	ADD	(SP)+,R0	; ADD TASK BIAS
	RETURN			;

;
; WRITE BLOCK INTO TASK IMAGE
;
; INPUTS:
;
;	R3=NUMBER OF WORDS  TO WRITE. IF R3 IS LESS THAN OR EQUAL TO
;	   ZERO, A SINGLE WORD IS WRITTEN INTO THE TASK IMAGE.
;	R4=TASK IMAGE ADDRESS
;	R5=ADDRESS OF BLOCK TO BE WRITTEN
;
; OUTPUTS:
;
;	R4=NEXT TASK IMAGE ADDRESS IN SEQUENCE
;	R5=NEXT ADDRESS IN BLOCK
;
;	THE SPECIFIED BLOCK CONTENTS ARE WRITTEN INTO THE TASK IMAGE
;	AT THE ADDRESS CONTAINED IN R4.
;

WRBLK:				;
	MOV	R4,R0		; COPY BLOCK ADDRESS
	ADD	#2,R4		; UPDATE BLOCK ADDRESS
	MOV	(R5)+,R1	; GET DATA TO BE WRITTEN
	CALL	$WRWRD		; WRITE A WORD
	DEC	R3		; DECREMENT COUNT
	BGT	WRBLK		; IF GT GO AGAIN
	RETURN			;

;
;
; GETVAL - GET VALUE OF AUTOLOAD OR SUPERVISOR LOAD ENTRY POINT
;
; INPUTS:
;	R5 = ADDRESS OF VECTOR
;
; OUTPUTS:
;	R1 = ADDRESS OF ENTRY POINT
;

GETVAL:
	MOV	2(R5),R1	; GET V/A OF ENTRY SYMBOL
	CALL	$CVRL		; CONVERT TO REAL
	MOV	#CRSYM,R1	; GET ADDRESS OF LOCAL STORE
	MOV	R0,R3		; COPY ADDRESS
	MOV	#S$YLGH/2,R2	; GET LENGTH OF ENTRY IN WORDS
10$:
	MOV	(R0)+,(R1)+	; COPY ENTRY
	SOB	R2,10$		; REPEAT
	CLR	R1		; ZERO SYMBOL VALUE
	BITB	#SY$REL,S$YFLG(R3) ; ABS SYMBOL?
	BEQ	20$		; IF EQ NO
	 MOV	$OFFST,R1	; ADD OFFSET BIAS
20$:
	RETURN


;
; WRVCT - WRITE VECTOR INTO TASK IMAGE
;
; INPUTS:
;	R1 = ADDRESS OF VECTOR PROTOTYPE THAT IS TO BE WRITTEN
;

WRVCT:
	MOV	R5,-(SP)	; SAVE
	MOV	R1,R5		; GET ADDRESS OF BLOCK TO WRITE
	MOV	#<S$ZATL/2>,R3 	; SET REPEAT COUNT
	CALL	CHKVCT		; REPLACE S$YVAL IF VECTOR FOR OVERLAID COMMON
	CALL	WRBLK		; WRITE BLOCK INTO TASK IMAGE
	MOV	(SP)+,R5	; RESTORE
	RETURN

;+
; ALWAPR - allocate window descriptor block base APRs
;
;	This subroutine allocates the window descriptor block base APR
;	request for either an I-space window descriptor or a D-space
;	window descriptor. The descriptor this routine operates on is
;	that which has been copied into working storage prior to writing
;	it to the task image disk file.
;
; Inputs:
;	R5 -	points to the copied data structure in working storage
;
; Outputs:
;	The working storage window offsets W.NBAS and W.NAPR are set
;	to the required values.
;
; All resigsters are preserved across the call
;
;
ALWAPR:
	MOV	W.NBAS(R5),R0	; GET BASE VIRTUAL ADDRESS
	ADD	$OFFST,R0	; ADD OFFSET BIAS
	MOV	R0,W.NBAS(R5)	; RESET BASE ADDRESS
	ASL	R0		; CONVERT TO APR NUMBER
	ROL	R0		; ...
	ROL	R0		; ...
	ROL	R0		; ...
	MOVB	R0,W.NAPR(R5)	; SET APR NUMBER
	RETURN
;
;
;+
;
; DSEXT - Subroutine to copy the D-space specific data into the working
;	  storage prior to writing it to the disk image. It will only
;	  copy the D-space information if building an I/D task.
;
; Inputs:
;	R5	- Address of next available location in the local storage
;	$CRSEG	- Real address of current segment
;
; Outputs:
;	R5	- Address of next available location in the local storage
;
DSEXT:
	BIT	#ID$ATA,$SWTCH	; BUILDING AN I/D TASK?
	BEQ	10$		; IF EQ, NO..IGNORE THIS
	MOV	R3,-(SP)	; SAVE THE ORIGINAL SEGMENT DESCRIPTOR POINTER
	MOV	$CRSEG,R3	; GET CURRENT SEGMENT DESCRIPTOR ADDRESS
	BIT	#SG$RO,CRFLG	; IS THE SEGMENT READ-OMLY?
	BNE	1$		; IF NE, YES...IT'S A R/O SEGMENT...
	MOV	S$GDBK(R3),(R5)+; IF EQ, NO...IT'S A R/W SEGMENT...
	BR	2$
1$:
	MOV	S$GBOD(R3),(R5)+; SET R/O DISK BLOCK ADDRESS
2$:
	SUB	$HDRBN,-2(R5)	; MAKE DISK ADDRESS RELATIVE TO HEADER
	MOV	S$GDLD(R3),(R5)	; SET D-SPACE TASK-VIRTUAL LOAD ADDRESS
	ADD	$OFFST,(R5)+	; ADD OFFSET BIAS
	MOV	S$GDLN(R3),(R5)+; SET D-SPACE LOAD LENGTH
	MOV	S$GDWP(R3),(R5)+; SET D-SPACE WINDOW POINTER
	CMP	S$GDWP(R3),$RTWDP+2 ; ROOT SEGMENT DISCRIPTOR??
	BNE	5$		; IF NE, NO...WE NEED THE WINDOW POINTER
	CLR	-2(R5)		; IF EQ, YES...ROOTS DON'T HAVE WINDOWS
5$:
	MOV	(SP)+,R3	; RESTORE R3
10$:
	RETURN
;
;


;+
; WRVCTD - Write vector into task image, D-space
;
; This subroutine is a chinese copy of the existing WRVCT but only writes
; two words into the user task-image.
; Prior to calling this routine, one must have toggled $STYP to identify
; the data as real 'data' to be placed into the task image data space on disk
; and have R1 pointing to the data that is to be written into the address
; contained in R4, in this case, the task-virtual address of the two word
; D-space vector in P-section $$ALVD.
;-

WRVCTD:
	MOV	R5,-(SP)	; SAVE
	MOV	R1,R5		; COPY THE VECTOR PROTOTYPE ADDRESS
	MOV	#<S$ZATD/2>,R3	; SET THE LOOP COUNT FOR 2 WORDS
	CALL	CHKVCT		; REPLACE S$YVAL IF VECTOR FOR OVERLAID COMMON
	CALL	WRBLK		; WRITE THE BLOCK INTO THE TASK IMAGE
	MOV	(SP)+,R5	; RESTORE
	RETURN

;
; CHKVCT - CHECK FOR AUTOLOAD VECTOR FOR OVERLAID COMMON
;

CHKVCT:	CMP	#$ALVI,R5	; WRITING OUT I-SPACE PART OF VECTOR?
	BEQ	10$		; IF EQ, YES - NO NEED TO CHECK
	MOV	R3,R0		; GET SIZE OF VECTOR
	ASL	R0		; POINT TO LAST WORD OF VECTOR
	SUB	#2,R0		;
	ADD	R5,R0		; 
	CMP	#-1,(R0)	; ENTRY PT FOR OVERLAID COMMON?
	BNE	10$		; IF NE, NO
	MOV	RTSVAL,(R0)	; SET ENTRY POINT TO $$RTS (RETURN)
10$:	RETURN


;+
; SETTYP -	Set switch for I-space or D-space on disk depending on the
;		value of CS$TYP and whether or not an I/D taskbuild is in
;		progress.
;
;		If $STYP .NE. 0 then patch is to be applied to D-space
;		If $STYP .EQ. 0 then patch is to be applied to I-space
;
;		all registers are preserved across the call
;
; INPUTS:
;	R0 =	Real address of symbol table entry
;
; OUTPUTS:
;	R0 =	Real address of symbol table entry
;	$STYP = 0 if I-space patch
;	$STYP .NE. 0 if D-space patch
;
;-

SETTYP:
	BIT	#ID$ATA,$SWTCH	; I/D TASKBUILD?
	BEQ	30$		; IF EQ, NO...CONVENTIONAL TASK
	MOV	R0,-(SP)	; SAVE R0
	MOV	S$YCMT(R0),R1	; GET VIRTUAL ADDRESS OF CONTROL SECTION ENTRY
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	CLRB	$STYP		; ASSUME INSTRUCTION SECTION
	BIT	#CS$TYP,C$SFLG(R0) ; DATA OR INSTRUCTION?
	BEQ	10$		; IF EQ, I-SPACE REFERENCE
	INCB	$STYP		; IF NE, D-SPACE REFERENCE
10$:
	MOV	(SP)+,R0	; RESTORE R0
30$:
	RETURN

;+
; GETAPR - Get APR value corresponding to window. This routine is 
; only used when the optimized OTS fast map routine is used.
;
; INPUTS:
;	R1 - Virtual base address of window
;
; OUTPUTS:
;	R1 - APR for window (in bits 0-2)
;
;-

GETAPR:
	ADD	$OFFST,R1	
	ASL	R1
	ROL	R1
	ROL	R1
	ROL	R1
	RETURN

	.END
