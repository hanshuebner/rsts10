	.TITLE	SGALO
	.IDENT	/33.06/
;
; COPYRIGHT (c)	1987, 1990, 1991 BY DIGITAL EQUIPMENT CORPORATION.
; ALL RIGHTS RESERVED.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED
; OR COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
; D. N. CUTLER/C. MONIA 27-JAN-74
;
; MODIFIED FOR RSX-11M/M-PLUS V4.0/V2.0 BY:
;
;	J. A. KASSON
;	C. B. PETROVIC
;
; MODIFIED FOR RSX-11M-PLUS V3.0 BY:
;
;	C. B. PETROVIC	9-FEB-82	31.01	CBP038
;	C. B. PETROVIC	26-FEB-82	31.02	CBP039
;	C. B. PETROVIC	24-MAR-82	31.03	CBP043
;	C. B. PETROVIC	7-JUN-82	31.04	CBP951
;	C. B. PETROVIC	7-JUN-82	31.05	CBP051
;	C. B. PETROVIC	03-SEP-82	31.06	CBP056
;	C. B. PETROVIC	2-DEC-82	31.07	CBP066
;	C. B. PETROVIC	16-DEC-82	31.08	CBP069
;	C. B. PETROVIC	23-FEB-83	31.09	CBP076
;	C. B. PETROVIC	9-MAR-83	31.10	CBP078
;	C. B. PETROVIC	13-APR-83	31.11	CBP082
;	C. B. PETROVIC	27-MAY-83	31.12	CBP091
;	C. B. PETROVIC	31-AUG-83	31.13	CBP101
;	C. B. PETROVIC	20-OCT-83	31.14	CBP112
;
; MODIFIED FOR RSX-11M-PLUS V4.0 BY:
;
;	D. P. RABAHY			33.00	DPR038
;		SIGN-BIT ABUSE, RESPONSE TO SPR #203P
;
;	C. B. PETROVIC			33.01	CBP200
;		ADD 'RNDSEG' OPTION PROCESSING
;
;	L. M. PETERSON			33.02	LMP083
;		FIX CALCULATION OF W.NOFF WHEN BUILDING
;		IN COMPATIBILITY MODE
;
;	D. P. RABAHY	13-MAY-87	33.03	DPR040
;		VSECT vs. VARRAY -- SPR #264P
;
; MODIFIED FOR RSX-11M-PLUS AND MICRO/RSX V4.3 BY:
;
;	L. M. PETERSON	28-FEB-89	46.05	LMP131
;		Allow tasks with (task)memory resident overlays to be 
;		extended (with the $EXTM directive)
;
;	J. C. FRANZINI	28-SEP-89	33.05	JCF353
;		Retract LMP083 due to side effects
;
;	C. M. KATZ	8-AUG-91	33.06	CMK005
; SEGMENT PHYSICAL AND VIRTUAL MEMORY ALLOCATION
;
; LOCAL DATA
;
; APR ALLOCATION BITMASKS
;
; ASCENDING VIRTUAL ADDRESSES ARE RIGHTMOST
;

	.LIST	MEB

MSK=200				;
	PURE.D			; PURE DATA AREA



APRMK:				;

	.REPT	8.

	.BYTE	MSK		;
MSK=MSK!<MSK/2>			;

	.ENDR

	.NLIST	MEB

;
; APR ALLOCATION BITMAP TABLE
;
	.RADIX	2

APRMP:
	.BYTE	00000001
	.BYTE	00000011
	.BYTE	00000111
	.BYTE	00001111
	.BYTE	00011111
	.BYTE	00111111
	.BYTE	01111111
	.BYTE	11111111

	.RADIX	8.

	.EVEN

	.IF DF D$SGAL

;
;
	.PSECT	TRPT$D,RO,D
$TRSPH:	.WORD	-1		; Phase on which to dump the seg desc.
$TRSCS:	.WORD	0		; Real memory address of current segment
$TRSEG:				; Reference label...
;
TRC S$GSTS,^/%NSegment status in low byte........................S$GSTS - %P%N/
TRC S$GBLK,^/Disk block address of the I-space segment.........S$GBLK - %P%N/
TRC S$GBRO,^/R-O disk block address of I-space segment.........S$GBRO - %P%N/
TRC S$GBWD,^/Disk block address of the D-space segment.........S$GBWD - %P%N/
TRC S$GBOD,^/R-O disk block address of D-space segment.........S$GBOD - %P%N/
TRC S$GLDA,^/Task-virtual load address of I-space segment......S$GLDA - %P%N/
TRC S$GLNG,^/Length of I-space segment in bytes................S$GLNG - %P%N/
TRC S$GDLD,^/Task-virtual load address of D-space segment......S$GDLD - %P%N/
TRC S$GDLN,^/Length of D-space segment in bytes................S$GDLN - %P%N/
TRC S$GNME,^/RAD50 segment name................................S$GNME - %2R%N/
TRC S$GWDP,^/Virtual address of I-space WDB....................S$GWDP - %P%N/
TRC S$GDWP,^/Virtual address of D-space WDB....................S$GDWP - %P%N/
TRC S$GRW,^/Length of I-space R-W memory allocation in bytes..S$GRWI - %P%N/
TRC S$GRO,^/Length of I-space R-O memory allocation in bytes..S$GROI - %P%N/
TRC S$GRWD,^/Length of D-space R-W memory allocation in bytes..S$GRWD - %P%N/
TRC S$GROD,^/Length of D-space R-O memory allocation in bytes..S$GROD - %P%N/
TRC S$GVAD,^/Highest I-space virtual address in segment........S$GVAD - %P%N/
TRC S$GDVA,^/Highest D-space virtual address in segment........S$GDVA - %P%N/
TRC S$GROB,^/Base virtual address of I-space R-O root..........S$GROB - %P%N/
TRC S$GODB,^/Base virtual address of D-Space R-O root..........S$GODB - %P%N/
;
;
	.PSECT	TRPT$D,RO,D
	.WORD	-1		; Flag the end of the list

;
	.PSECT	TRPT$D,RO,D
$TRWPH:	.WORD	-1		; Phase on which to dump the window blk
$TRWCS:	.WORD	0		; Real memory address of current window
$TRWIN:				; Reference label...
;
	TRC	W.NID,^"%NWindow ID/Base APR   - %P - W.NID/W.NAPR%N"
	TRC	W.NBAS,^/Base virtual address - %P - W.NBAS%N/
	TRC	W.NSIZ,^/Window size (64b blks)-%P - W.NSIZ%N/
	TRC	W.NRID,^/Region ID            - %P - W.NRID%N/
	TRC	W.NOFF,^/Offset in partition  - %P - W.NOFF%N/
	TRC	W.NLEN,^/Length to map        - %P - W.NLEN%N/
	TRC	W.NSTS,^/Window status word   - %P - W.NSTS%N/
	TRC	W.NLGH,^/Window flags word    - %P - W.NLGH%N/
	TRC	W$NREG,^/Address of reg. desc - %P - W$NREG%N/
;
	.PSECT	TRPT$D,RO,D
	.WORD	-1		; Flag the end of the list
;
	.PSECT	TRPT$D,RO,D
$TRSPZ:	.WORD	-1		; Phase on which to dump working storage
$TRSME:	.WORD	0		; Base address of working storage
$TRSTO:				; Reference label
;
	TRC	PASS,^"%NFlag word for I/D processing pass.....PASS - %P%N"
	TRC	LCLGH,^"Local length of segment..............LCLGH - %P%N"
	TRC	LVADR,^"Local virtual address................LVADR - %P%N"
	TRC	LDLGH,^"Local length of data segment.........LDLGH - %P%N"
	TRC	LVDADR,^"Local virtual address of data.......LVDADR - %P%N"
	TRC	PHYBD,^"Physical address bound...............PHYBD - %P%N"
	TRC	VRTBD,^"Virtual address bound................VRTBD - %P%N"
	TRC	WNLEN,^"Window length word...................WNLEN - %P%N"
	TRC	WNSTS,^"Window status word...................WNSTS - %P%N"
	TRC	ROFLG,^"R/O allocation/res o'lay flag bytes..RS/RO - %P%N"
	TRC	RODFLG,^"Read-only data allocation flag......RODFLG - %P%N"
;	TRC	TSKSW,^"Task switch word.....................TSKSW - %P%N"
	TRC	CURWND,^"Current R/W and R/O windows.........CURWND - %2P%N"
	TRC	CURWDD,^"Current D-space R/W and R/O wndws...CURWDD - %2P%N"
	TRC	LVL,^"Level at which prev I-wndw was alloc...LVL - %P%N"
	TRC	LVLD,^"Level at which prev D-wndw was alloc..LVLD - %P%N"
	TRC	COTFLG,^"Co-tree flag........................COTFLG - %P%N"
	TRC	RWND,^"I-space co-tree root's WDB address....RWND - %2P%N"
	TRC	RWNDD,^"D-space co-tree root's WDB address...RWNDD - %2P%N"
;	TRC	TLEN,^"Length of longest segment in co-tree..TLEN - %P%N"
	TRC	$MXLGH,^"Max R/W I Phys mem (32w blks).......$MXLGH - %P%N"
	TRC	$MXLGH+2,^"Max R/O I Phys mem (32w blks).....$MXLGH+2 - %P%N"
	TRC	$MXLGH+4,^"Max R/O D Phys mem (32w blks).....$MXLGH+4 - %P%N"
	TRC	$MXLGH+6,^"Max R/W D Phys mem (32w blks).....$MXLGH+6 - %P%N"

	.PSECT	TRPT$D,RO,D
	.WORD	-1		; Flag the ned of the list...
;
;
	PURE.D

	.NLIST	BEX
$CSREL:
	.ASCII	/CSREL:	Bias  =%P C$SNME=%2R C$SFLG=%P C$SBSE=%P%N/
	.ASCIZ	/	C$SLTH=%P C$SCUR=%P C$SLGS=%P%N/
	.EVEN

$CSALO:
	.ASCII	/CSALO:	Bias  =%P C$SNME=%2R C$SFLG=%P C$SBSE=%P%N/
	.ASCIZ	/	C$SLTH=%P C$SCUR=%P C$SLGS=%P%N/
	.EVEN

$BLKAL:
	.ASCII	/BLKAL:	Bias  =%P BLOCKS=%P Reg. 5=%P Reg. 3=%P%N/
	.ASCIZ	/	$RLBLK=%P $ROBLK=%P $RLDBK=%P $RODBK=%P%N/
	.EVEN

$BLKA1:
	.ASCII	/BLKAL1:	Bias  =%P BLOCKS=%P Reg. 5=%P Reg. 3=%P%N/
	.ASCIZ	/	$RLBLK=%P $ROBLK=%P $RLDBK=%P $RODBK=%P%N/
	.EVEN
	.LIST	BEX

	.ENDC



	IMPURE			; READ/WRITE LOCAL STORAGE
;
; ADJACENCY IS ASSUMED
;

CLRBEG=.			; DEFINE START OF AREA TO CLEAR
PASS:	.BLKW	1		; FLAG WORD FOR PHALO TO DETERMINE
				; WHETHER I-SPACE OR D-SPACE IS BEING
				; PROCESSED.
LCLGH:	.BLKW	1		;LOCAL LENGTH OF SEGMENT
LVADR:	.BLKW	1		;LOCAL VIRTUAL ADDRESS
LDLGH:	.BLKW	1		; LOCAL LENGTH OF DATA SEGMENT
LVDADR:	.BLKW	1		; LOCAL VIRTUAL ADDRESS OF DATA
PHYBD:	.BLKW	1		; PHYSICAL ADDRESS BOUND
VRTBD:	.BLKW	1		; VIRTUAL ADDRESS BOUND
WNLEN:	.BLKW	1		; WINDOW LENGTH FLAG
WNSTS:	.BLKW	1		; WINDOW STATUS
CLRSZ=.-CLRBEG/2		; NUMBER OF WORDS TO CLEAR
ROFLG:	.BLKB	1		; READ-ONLY ALLOCATION FLAG
RSFLG:	.BLKB	1		; RESIDENT OVERLAY FLAG
RODFLG:	.BLKW	1		; READ-ONLY DATA ALLOCATION FLAG
TSKSW:	.BLKW	1		; TASK SWITCH WORD
CURWND:	.BLKW	2		; CURRENT R/W AND R/O WINDOWS
CURWDD:	.BLKW	2		; CURRENT D-SPACE R/W AND R/O WINDOWS
LVL:	.BLKW	1		; LEVEL AT WHICH PREVIOUS WINDOW WAS ALLOCATED
LVLD:	.BLKW	1		; LEVEL AT WHICH PREVIOUS D-SPACE WINDOW
				; WAS ALLOCATED.
COTFLG:	.BLKW	1		; CO-TREE FLAG
RWND:	.BLKW	2		; CO-TREE ROOT'S WINDOW BLOCK ADDRESS
RWNDD:	.BLKW	2		; D-SPACE CO-TREE'S ROOT WINDOW BLOCK ADDRESS
TLEN:	.BLKW	1		; LENGTH OF LONGEST SEGMENT IN CO-TREE
CLRSZ2=.-CLRBEG/2		; NUMBER OF WORDS TO CLEAR

;+
; **-$SGALO-SEGMENT MEMORY ALLOCATION
;
; THIS ROUTINE IS CALLED IN PHASE 4 TO ALLOCATE PHYSICAL AND VIRTUAL
; MEMORY FOR ALL SEGMENTS IN THE ALLOCATION.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	PHYSICAL AND VIRTUAL MEMORY IS ALLOCATED FOR ALL SEGMENTS.
;-
	PURE.I			; PURE CODE AREA

$SGALO::			;
	SAVRG			; SAVE THE NON-VOLATILE REGISTERS
	CLR	ROFLG		; CLEAR READ-ONLY FLAG
	CLR	SHOFF		; CLEAR SHIFT OFFSET
	CALL	CLRMEM		; CLEAR WORK AREA
	MOV	$TSKNM,R1	; GET ADDRESS OF TASK FILE NAMEBLOCK
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	MOV	E$LSWT(R0),TSKSW ; COPY TASK SWITCHES
	BIT	#SW$CM,TSKSW	; TASK BUILT IN COMPATIBILITY MODE?
	BEQ	5$		; IF EQ NO
	MOV	#512.,$PHYBD	; FORCE 256-WORD ALIGNMENT
5$:				;
	MOV	#SGALO,R0	; GET ADDRESS OF PHASE CONTROL ROUTINE
	CALL	$PCTRL		; CALL PHASE CONTROL
	TST	COTFLG		; ANY CO-TREES PROCESSED
	BEQ	7$		; IF EQ NO
	MOV	CURWND+2,R1	; GET ADDRESS OF WINDOW TO UNLOCK
	BEQ	6$		; IF EQ, THERE IS NO WINDOW
	CALL	$UNLPG		; IF NOT, UNLOCK IT
6$:
	BIT	#ID$ATA,$SWTCH	; DOING AN I/D TASKBUILD?
	BEQ	601$		; IF EQ, NO...CONVENTIONAL
	MOV	CURWDD+2,R1	; GET ADDRESS OF WINDOW TO UNLOCK
	BEQ	601$		; IF EQ, THERE IS NO WINDOW
	CALL	$UNLPG		; IF NOT, UNLOCK IT
601$:
	MOV	RWND,R1		; GET VIRTUAL ADDRESS OF WINDOW TO UNLOCK
	CALL	$UNLPG		; UNLOCK
	BIT	#ID$ATA,$SWTCH	; BUILDING AN I/D TASK?
	BEQ	602$		; IF EQ, NO...CONVENTIONAL
	MOV	RWNDD,R1	; GET VIRTUAL ADDRESS OF D-SPACE WDB TO UNLOCK
	CALL	$UNLPG		; AND FREE UP A PAGE
602$:
7$:
	CLR	LVL		; CLEAR LEVEL COUNT
	MOV	#WDALO,R0	; GET ADDRESS OF PHASE CONTROL ROUTINE
	CALL	$PCTRL		; COMPUTE WINDOW BLOCK REQUIREMENTS
	MOV	$NUMWN,R0	; GET NUMBER OF WINDOW BLOCKS
	ADD	$MXWND,R0	; ADD LIBRARY WINDOWS
	CMP	R0,#8.		; MORE THAT 8 WINDOWS REQUIRED?
	BLOS	10$		; IF LOS NO
	MOV	#<S$V2*400!E$R86>,R1 ; GET ERROR/SEVERITY
	CMP	#4,$SYSTM	; M+ TASK BUILD?
	BNE	9$		; IF NE NO
	CMP	R0,#W$NDWS	; MORE THEN THE MAX ALLOWABLE WINDOWS?
	BLOS	10$		; IF LOS NO
9$:
	CALL	$ERMSG		; FATAL, NO RETURN
10$:				;
	MOV	#$HDSIZ,R4	; POINT TO HEADER SIZE
	BIT	#SW$NH,TSKSW	; TASK IMAGE HAVE HEADER?
	BNE	20$		; IF NE NO
	MOV	#S$ZWND,R1	; GET LENGTH OF EACH WINDOW IN BYTES

	.IF DF	V1145

	MUL	R0,R1		; COMPUTE WINDOW ALLOCATION

	.IFF

	CALL	$MUL		; COMPUTE WINDOW ALLOCATION

	.ENDC

	.IF	NDF,R$RSTS	; CMK001 RSTS
	ADD	R1,(R4)		; INCLUDE WINDOW ALLOCATION IN HEADER
	.ENDC

	.IF NDF	R$$11M

	MOV	(R4),R0		; GET SIZE OF HEADER
	MOV	$PHYBD,R1	; GET PHYSICAL ADDRESS BOUND
	CALL	ADRUND		; ROUND TO PHYSICAL ADDRESS LIMIT
	MOV	R0,(R4)		; SET SIZE OF HEADER
20$:				;
	MOV	$STACK,R1	; GET STACK SIZE
	MOV	#LVADR,R2	; POINT TO LOCAL VIRTUAL ADDRESS
	MOV	R1,(R2)		; SET CURRENT VIRTUAL ADDRESS
	ADD	(R4),R1		; ADD HEADER TO STACK
	MOV	R1,-(R2)	; SET LOCAL LENGTH

	.IFF

20$:				;
	MOV	#LCLGH,R2	; GET LOCAL LENGTH
	MOV	(R4),(R2)	; SET LOCAL LENGTH
	BIT	#ID$ATA,$SWTCH	; USER D-SPACE TASK
	BEQ	30$		; IF EQ NO
	MOV	(R2)+,(R2)	; SET CURRENT VIRTUAL ADDRESS FOR I-SPACE
	MOV	(R2)+,(R2)	; SET CUREENT LENGTH FOR D-SPACE
30$:
	ADD	$STACK,(R2)	; INCLUDE SIZE OF STACK
	MOV	(R2)+,(R2)	; SET CURRENT VIRTUAL ADDRESS

	.ENDC

	MOV	$RTSEG,R1	; GET VIRTUAL ADDRESS OF ROOT SEGMENT
	CALL	$CVLOK		; CONVERT AND LOCK IN MEMORY
	MOV	R0,R5		; SAVE SEGMENT DESCRIPTOR ADDRESS
	TSTB	ROFLG		; ALLOCATING READ-ONLY MEMORY
	BNE	410$		; IF NE YES
	CALL	ALROD		; ALLOCATE VIRTUAL BASE FOR R/O DATA
	CALL	ALMEM		; ALLOCATE MEMORY
	TSTB	RODFLG		; NO - HOW ABOUT R/O DATA?
	BEQ	400$		; IF EQ, NO R/O DATA, JUST EXIT.
	JMP	425$		; YES, THERE'S R/O DATA SPACE TO ALLOCATE
400$:
	JMP	450$		; GO TO EXIT, BUT FIRST, SET THE TASK
				; APR REQUIREMENTS FOR NON-I/D FLAVORS
410$:
	MOV	S$GRO(R5),R0	; GET LENGTH OF R-O MEMORY
	BEQ	420$		; IF EQ NO R-O ROOT
	CLR	R4		; CLEAR BIAS FOR I/D
	MOV	#1000,R1	; SET 512. BYTE ADDRESS BOUND FOR R/O I ROOT
	CALL	GBAPR		; GET BASE APR FOR R/O
	MOV	R1,S$GROB(R5)	; RECORD BASE VIRTUAL ADDRESS
	SUB	$OFFST,S$GROB(R5) ; SUBRTACT OFFSET BIAS, IF ANY, FROM THE
				;   VIRTUAL I-SPACE R-O BASE ADDRESS.
	MOV	S$GRO(R5),R0	; GET LENGTH OF R/O MEMORY
	MOV	R5,$CRSEG	; SAVE THE CURRENT SEGMENT REAL ADDRESS
	MOV	$RTSEG,$CRVSG	; SAVE THE CURRENT SEGMENT VIRTUAL ADDRESS
	MOV	R5,R3		; COPY DESCRIPTOR ADDRESS
	MOV	#2,R4		; SET R/O BIAS
	ADD	R4,R3		; INCLUDE R/O BIAS
	CALL	BLKAL		; ALLOCATE DISK BLOCK

	.IF DF D$SG2

	MOV	R0,-(SP)	; SAVE R0
	MOV	$PHASE,$TRSPH	; COPY THE PHASE NUMBER
	MOV	$CRSEG,$TRSCS	; SET THE CURRENT SEGMENT ADDRESS
	MOV	#$TRSEG,R0	; POINT TO THE LIST
	CALL	$TRACE		; AND DUMP IT TO TI:
	MOV	(SP)+,R0	; RESTORE R0 BEFORE EXITING...

	.ENDC

	BIT	#ID$ATA,$SWTCH	; WE BUILDING AN I/D TASK???
	BEQ	415$		; IF EQ, NO...BYPASS THE CODE THAT FOLLOWS
	TSTB	RODFLG		; ANY R-O DATA?
	BEQ	450$		; IF EQ NO
	MOV	S$GROD(R5),R0	; GET R/O DATA LENGTH
	MOV	R5,R3		; GET SEGMENT DESCRIPTOR ADDRESS
	MOV	R5,$CRSEG	; SAVE THE CURRENT SEGMENT REAL ADDRESS
	MOV	$RTSEG,$CRVSG	; SAVE THE CURRENT SEGMENT VIRTUAL ADDRESS
	MOV	#2,R4		; SET R/O BIAS
	ADD	R4,R3		; ADD IN R/O BIAS
	CALL	BLKAL1		; ALLOCATE R/O DATA DISK BLOCKS

	.IF DF D$SG2

	MOV	R0,-(SP)	; SAVE R0
	MOV	$PHASE,$TRSPH	; COPY THE PHASE NUMBER
	MOV	$CRSEG,$TRSCS	; SET THE CURRENT SEGMENT ADDRESS
	MOV	#$TRSEG,R0	; POINT TO THE LIST
	CALL	$TRACE		; AND DUMP IT TO TI:
	MOV	(SP)+,R0	; RESTORE R0 BEFORE EXITING...

	.ENDC

415$:
	CALL	ALROD		; ALLOCATE VIRTUAL BASE FOR R/O DATA
	CALL	ALMEM		; ALLOCATE MEMORY
	MOV	R4,-(SP)	; SAVE R4 FOR LATER...
	CLR	R4		; RESET R/W -  R/O BIAS SINCE WE'RE
				; ALLOCATING AN I-SPACE DESCRIPTOR
	CALL	ALDSC		; ALLOCATE AN I-SPACE 'LIBRARY' DESCRIPTOR
	MOV	(SP)+,R4	; RESTORE R4...REMEMBER A REGISTER SAVED
				; IS A REGISTER EARNED...
	MOV	S$GROB(R5),R1	; GET R/O DATA BASE ADDRESS
	ADD	$OFFST,R1	; ADD IN THE OFFSET BIAS, IF ANY...
	DEC	R1		; DECREMENT BASE ADDRESS
	CMP	R1,$HGHAD	; TEST AGAINST CURRENT HIGH ADDRESS BOUND
	BHIS	430$		;IF HIS NO CHANGE
	MOV	R1,$HGHAD	; UPDATE HIGH ADDRESS BOUND
	BR	430$		;
420$:
	CALL	ALMEM		; ALLOCATE MEMORY
	CALL	ALDSC		; ALLOCATE LIBRARY DESCRIPTOR
425$:
	BIT	#ID$ATA,$SWTCH	; WE BUILDING AN I/D TASK???
	BEQ	450$		; IF EQ, NO...BYPASS THE CODE THAT FOLLOWS
	TSTB	RODFLG		; ANY R-O DATA?
	BEQ	450$		; IF EQ NO
	MOV	R5,R3		; GET SEGMENT DESCRIPTOR ADDRESS
	MOV	R5,$CRSEG	; SAVE THE CURRENT SEGMENT REAL ADDRESS
	MOV	$RTSEG,$CRVSG	; SAVE THE CURRENT SEGMENT VIRTUAL ADDRESS
	MOV	#2,R4		; SET R/O BIAS
	ADD	R4,R3		; ADD IN R/O BIAS
	CALL	BLKAL1		; ALLOCATE R/O DATA DISK BLOCKS

	.IF DF D$SG2

	MOV	R0,-(SP)	; SAVE R0
	MOV	$PHASE,$TRSPH	; COPY THE PHASE NUMBER
	MOV	$CRSEG,$TRSCS	; SET THE CURRENT SEGMENT ADDRESS
	MOV	#$TRSEG,R0	; POINT TO THE LIST
	CALL	$TRACE		; AND DUMP IT TO TI:
	MOV	(SP)+,R0	; RESTORE R0 BEFORE EXITING...

	.ENDC

430$:
	BIT	#ID$ATA,$SWTCH	; WE BUILDING AN I/D TASK??
	BEQ	450$		; IF EQ, NO...BYPASS ADDING AN EXTRA LIBRARY
				; DESCRIPTOR FOR NON-EXISTANT D-SPACE DATA...
	MOV	#L$DLGH,R1	; GET SIZE OF LIBRARY DESCRIPTOR
	CALL	$ALBLK		; ALLOCATE A DESCRIPTOR
	MOV	#$LBRHD,R1	; GET ADDRESS OF LIBRARY LIST HEAD
	TSTB	ROFLG		; ANY R/O?
	BEQ	440$		; IF EQ NO
	MOV	$LBRHD,R1	; THEN LINK R/O DATA FIRST
440$:				; OTHER WISE IT GETS LINKED SECOND
	MOV	(R1),(R0)	;
	MOV	R0,(R1)		;
	INC	$LBRHD+4	; BUMP COUNT OF ENTRIES
	MOV	S$GODB(R5),R1	; GET R/O DATA BASE ADDRESS
	MOV	S$GROD(R5),R2	; GET R/O DATA LENGTH
	CALL	LIBDSC		; FILE IN LIBRARY DESCRIPTOR
	MOV	$MXLGH+4,L$DMXZ(R4) ; SET PHYSICAL ADDR FOR DATA
450$:
;
; If we're building an I/D task then we want to keep the I- and D-space
; APR bitmaps separate. If we're building a conventional task, then both
; the I- and D-space APRS are identical. This code is necessary for the
; case of a Fortran-77 task using virtual arrays. We always set the APR
; requirement for D-space since it makes no sense to tell the OTS what
; APRS are in use by the I-space segment. In the case of a conventional
; task, the I- and D-space APRS are overmapped.
;
	BIT	#ID$ATA,$SWTCH	; BUILDING AN I/D TASK ??
	BNE	500$		; IF NE, YES...KEEP I- AND D-SPACE APRS APART
	MOV	$APRMP,$APRDM	; IF EQ, NO...COPY I-SPACE APRS TO D-SPACE
500$:
	MOV	$RTSEG,R1	; GET VIRTUAL ADDR. OF ROOT
	CALLR	$UNLPG		; UNLOCK PAGE

;
; ALROD - ALLOCATE VIRTUAL BASE FOR R/O DATA
;

ALROD:
	BIT	#ID$ATA,$SWTCH	; WE BUILDING AN I/D TASK???
	BEQ	10$		; IF EQ, NO...BYPASS THE CODE THAT FOLLOWS
	TSTB	RODFLG		; ANY R/O DATA?
	BEQ	10$		; IF EQ NO
	MOV	R5,-(SP)	; SAVE SEGMENT DESCRIPTOR ADDRESS
	ADD	#<S$GROD-S$GRO>,R5 ; ADD IN R/O BIAS FOR DATA SECTION
	MOV	S$GRO(R5),R0	; GET LENGTH OF READ-ONLY DATA
	MOV	#2,R4		; SET R/O BIAS
	MOV	#0,R1		; SET FOR 64. BYTE ADDRESS BOUND FOR R/O D ROOT
	CALL	GBAPR		; GET BASE APR FOR R/O DATA
	MOV	(SP)+,R5	; RESTORE SEGMENT DESCRIPTOR ADDRESS
	MOV	R1,S$GODB(R5)	; RECORD BASE VIRTUAL ADDRESS
	SUB	$OFFST,S$GODB(R5) ; SUBTRACT OFFSET BIAS, IF ANY...
10$:
	RETURN			;

;
; GBAPR - GET BASE APR FOR R/O AND SET MAX LENGTH
;
; INPUT::
;	R0 - R/O LENGTH
;	R1 - PHYSICAL ADDRESS BOUND
;		** NOTE **
;			IF A PHYSICAL ADDRESS BOUND OTHER THAN THE ONE
;			HELD IN $PHYBD IS DESIRED, SET THAT VALUE INTO
;			R1. IF THE DEFAULT IS DESIRED, ENSURE THAT R1
;			IS SET TO 0...
;	R4 - R/O BIAS
;	R5 - DATA BIAS

GBAPR:
	TST	R1		; HAVE WEE BEEN PASSED AN PHY. ADDR. BOUND?
	BNE	10$		; IF NE, YES...USE THAT ONE...
	MOV	$PHYBD,R1	; IF EQ, NO...USE THE SYSTEM'S
10$:
	CALL	ADRUND		; ROUND TO PHYSICAL ADDRESS LIMIT
	MOV	R0,S$GRO(R5)	; SAVE SIZE OF READ-ONLY ROOT
	MOV	R0,R1		; COPY SIZE
	CALL	BLOCKS		; CONVERT TO 32W BLOCKS
	MOV	R1,$MXLGH+2(R4) ; SET PHYSICAL ADDRESS
	CALL	ALOAPR		; ALLOCATE APR FOR R-O ROOT
	RETURN

;
; ALDSC - ALLOCATE A LIBRARY DESCRIPTOR FOR R/O
;

ALDSC:
	MOV	#L$DLGH,R1	; GET SIZE OF LIBRARY DESCRIPTOR
	CALL	$ALBLK		; ALLOCATE DESCRIPTOR
	MOV	$LBRHD,(R0)	; LINK AS FIRST IN LIST
	MOV	R0,$LBRHD	; ...
	INC	$LBRHD+4	; INCREMENT COUNT OF ENTRIES
	MOV	S$GROB(R5),R1	; GET R/O BASE ADDRESS
	MOV	S$GRO(R5),R2	; GET R/O LENGTH

;
; LIBDSC - FILLS IN THE LIBRARY DESCRIPTOR
;
; INPUT:
;	R0 - DESCRIPTOR ADDRESS
;	R1 - BASE ADDRESS
;	R2 - R/O LENGTH
;	R4 - R/O BIAS
;
; OUTPUT:
;	R4 - DESCRIPTOR ADDRESS
;	R3 - PRESERVED ACROSS CALL
;
;
LIBDSC:
	MOV	R3,-(SP)	; SAVE R3 FOR A WHILE...
	MOV	R4,-(SP)	; AND THIS ONE TOO...
	MOV	R0,R3		; COPY ADDRESS OF DESCRIPTOR
	MOV	R0,R4		; SAVE DESCRIPTOR ADDRESS
	TST	(R3)+		; POINT TO NAME
	MOV	$ROPAR,(R3)+	; GET NAME OF R-O PARTITION NAME (L$DNME)
	MOV	$ROPAR+2,(R3)+	;				(L$DNME+2)
	MOV	R1,(R3)		; SET BASE ADDRESS OF LIBRARY
	ADD	$OFFST,(R3)	; ADD IN THE OFFSET BIAS, IF ANY...
	MOV	R2,R0		; GET LENGTH TO R/O ALLOCATION
	MOV	R0,-(SP)	; SAVE LENGTH
	MOV	$PHYBD,R1	; GET PHYSICAL ADDRESS BOUND
	CALL	ADRUND		; ROUND TO ADDRESS LIMIT
	DEC	R0		; BACK OFF TO HIGH ADDRESS
	ADD	(R3)+,R0	; COMPUTE HIGH ADDRESS BOUND
	MOV	R0,(R3)+	; SET HIGH LIMIT (L$DHGV)
	TST	(R3)+		; BY-PASS HIGH VIRTUAL ADDRESS (L$DMXV)
	MOV	(SP)+,R1	; RETRIEVE LENGTH OF ROOT
	CALL	BLOCKS		; ROUND TO 32W BLOCKS
	MOV	R1,(R3)+	; SAVE LENGTH OF ROOT
	MOV	R4,-(SP)	; SAVE NEW R4
	MOV	2(SP),R4	; FETCH THE OLD VALUE
	MOV	(SP),2(SP)	; COPY THE TOP OF THE STACK (NEW R4)
	TST	(SP)+		; AND GET RID OF THE EXTRA COPY OF R4
	MOV	$MXLGH+2(R4),(R3)+ ; SET MAX LENGTH OF R-O AREA (I OR D)
	CLR	(R3)+		; ZERO OFFSET (L$DOFF)
	BIC	#LD$ACC,<L$DFLG-L$DWND>(R3) ; SET R-O ACCESS (L$DFLG)
	ADD	#<L$DDAT-L$DWND>,R3 ; POINT TO DATE (L$DDAT)
	MOV	#$BGTIM,R0	; GET TIME
	MOV	(R0)+,(R3)+	; SET YEAR
	MOV	(R0)+,(R3)+	; MONTH
	MOV	(R0),(R3)+	; DAY
	MOV	(SP)+,R4	; GET THE OLD R4 BACK (R/O BIAS VALUE)
	MOV	L$DSA(R4),(R3)	; SET CURRENT BASE
	MOV	(SP)+,R3	; RESTORE R3'S ORIGINAL VALUE AT ENTRY
	RETURN
ALMEM:
	CLR	COTFLG		; CLEAR CO-TREE FLAG AND APR MASK
	MOV	#PHALO,R0	; GET ADDRESS OF PHASE CONTROL ROUTINE
	CALL	$PCTRL		; CALL PHASE CONTROL ROUTINE
	CLR	R4		; CSET BIAS FOR R/W ALLOCATION
	CLR	PASS		; SET UP TO CLOSE THE LAST WINDOW...
	CALL	CLSWND		; CLOSE LAST R/W WINDOW
	MOV	#2,R4		; SET BIAS FOR R/O ALLOCATION
	CALL	CLSWND		; CLOSE LAST R/O WINDOW
	BIT	#ID$ATA,$SWTCH	; BUILDING AN I/D TASK??
	BEQ	5$		; IF EQ, NO...CONVENTIONAL
	CLR	R4		; SET BIAS FOR R/W ALLOCATION WINDOW
	MOV	#2,PASS		; SET FOR THE D-SPACE WINDOW...
	CALL	CLSWND		; CLOSE LAST D-SPACE R/W ALLOCATION WINDOW
	MOV	#2,R4		; SET BIAS FOR R/O ALLOCATION WINDOW
	CALL	CLSWND		; CLOSE LAST D-SPACE R/O ALLOCATION WINDOW
5$:
	MOV	$RTSEG,R1	; GET ADDRESS OF ROOT SEGMENT
	CALL	$CVRL		; CONVERT TO REAL
	BIT	#ID$ATA,$SWTCH	; DOING AN I/D BUILD??
	BEQ	10$		; IF EQ, NO...
	MOV	S$GDWP(R0),-(SP) ; IF NE, YES...SAVE D-SPACE WINDOW POINTER.
10$:
	MOV	S$GWDP(R0),R1	; GET ADDRESS OF WINDOW BLOCK
	CALL	$CVRL		; CONVERT TO REAL
	MOV	W.NSIZ(R0),R1	; GET WINDOW SIZE
	BEQ	60$		;IF EQ AT LOW LIMIT
	SWAB	R1		; MULTIPLY BY 64.
	RORB	R1		; ...
	ROR	R1		; ...
	ROR	R1		; ...
	DEC	R1		; BACK OFF TO ADDRESS LIMIT
60$:				;
	MOV	R1,$HVRT0	; SET HIGH ADDRESS BOUND FOR WINDOW 0
	CLR	R1		; ASSUME WE AREN'T BUILDING AN I/D TASK...
	BIT	#ID$ATA,$SWTCH	; AGAIN, WE BUILDING AN I/D TASK??
	BEQ	64$		; IF EQ, NO...CONVENTIONAL
	MOV	(SP)+,R1	; IF NE, YES...FETCH D-WINDOW POINTER
	BEQ	64$		; IF EQ, NONE THERE
	CALL	$CVRL		; CONVERT TO REAL
	MOV	W.NSIZ(R0),R1	; GET THE D-WINDOW SIZE
	BEQ	64$		; IF EQ, IGNORE THE REST OF THIS STUFF...
	SWAB	R1		; MULTIPLY BY 64.
	RORB	R1		; ...
	ROR	R1		; ...
	ROR	R1		; ...
	DEC	R1		; BACK OFF LIMIT BY ONE...
64$:
	MOV	R1,$HDVR1	; SET DATA HIGH ADDRESS FOR WINDOW 1
	MOV	$LBOFF,R0	; GET TASK OFFSET
	MOV	#512./64.,R1	; GET BOUNDARY VALUE
	CALL	ROUND		; ROUND TO 512 BYTE BOUNDARY
	BCC	70$		; IF C/C OK
	MOV	#-1,R0		; SET OFFSET TO MAX
70$:				;
	MOV	R0,$LBOFF	; SAVE TASK OFFSET
	MOV	$HVRTL,R0	; GET HIGH VIRTUAL ADDRESS
	CALL	CVAPR		; CONVERT TO APR INDEX
	BISB	APRMP(R0),$APRMP ; SET I-SPACE APR BITMAP
	BIT	#ID$ATA,$SWTCH	; BUILDING A USER I/D TASK??
	BEQ	80$		; IF EQ, NO..CONVENTIONAL
	MOV	$HDVRT,R0	; GET HIGH VIRTUAL D-SPACE ADDRESS
	CALL	CVAPR		; CONVERT TO APR INDEX
	BISB	APRMP(R0),$APRDM ; SET D-SPACE APR BITMAP
80$:
	RETURN			;

;
; ALLOCATE MEMORY AND DISK SPACE
;

PHALO:				;
	SAVRG			; SAVE THE NON-VOLATILE REGISTERS
	MOV	$CRVSG,R1	; GET VIRTUAL ADDRESS OF CURRENT SEGMENT
	CALL	$WRMPG		; WRITE-MARK PAGE
	CLR	PASS		; SET PASS FLAG FOR I-SPACE ALLOCATION
	CALL	PHALOI		; DO THE I-SPACE ALLOCATION FIRST. WE MAY
				; ONLY HAVE TO DO THIS ONCE IF WE'RE NOT
				; BUILDING AN I/D TASK...

	.IF DF D$SG0

	MOV	R0,-(SP)	; Save R0...
	MOV	$PHASE,$TRSPZ	; Phase on which to dump working storage
	CLR	$TRSME		; Base address of working storage
	MOV	#$TRSTO,R0	; Reference label for Working Storage Strings...
	CALL	$TRACE
	MOV	$PHASE,$TRSPH	; Copy the phase number
	MOV	$CRSEG,$TRSCS	; Set the current segment address
	MOV	#$TRSEG,R0	; Point to the list...
	CALL	$TRACE		; and dump it to TI:
	MOV	(SP)+,R0	; Restore R0 before exiting...

	.ENDC

	BIT	#ID$ATA,$SWTCH	; WELL, IS WE BUILDING AN I/D TASK??
	BEQ	10$		; IF EQ, NO...WE'RE DONE
	MOV	#2,PASS		; FLAG THIS PASS AS D-SPACE ALLOCATION
	MOV	$CRVSG,R1	; SET CURRENT SEGMENT VIRTUAL ADDRESS
	CALL	PHALOD		; NOW GO TO IT...

	.IF DF D$SG0

	MOV	R0,-(SP)	; Save R0...
	MOV	$PHASE,$TRSPZ	; Phase on which to dump working storage
	CLR	$TRSME		; Base address of working storage
	MOV	#$TRSTO,R0	; Reference label for Working Storage Strings...
	CALL	$TRACE
	MOV	$PHASE,$TRSPH	; Copy the phase number
	MOV	$CRSEG,$TRSCS	; Set the current segment address
	MOV	#$TRSEG,R0	; Point to the list...
	CALL	$TRACE		; and dump it to TI:
	MOV	(SP)+,R0	; Restore R0 before exiting...

	.ENDC

10$:
	RETURN			; BACK TO $PCTRL FOR ANOTHER SEGMENT...
;
; The following two labels, although they define the same entry point,
; are here because i want to preserve my sanity! The only way we can enter
; the code through the label 'PHALOD' is if we're building a user-mode
; I/D task. This also implies that the contents of the location 'PASS'
; are non-zero. In actuality, the contents are +2. This is not a value
; to be construed as an offset value, only something other than zero.
;
PHALOD:				; ENTRY POINT IF WE'RE PROCESSING A
				; SEGMENT'S DATA ALLOCATION
PHALOI:				; ENTRY POINT IF WE'RE PROCESSING EITHER
				; A NON-I/D TASK OR AN I/D TASK'S
				; I-SPACE ALLOCATION.
	MOV	$CRSEG,R5	; GET REAL ADDRESS OF CURRENT SEGMENT
	TST	PASS		; DOING D-SPACE OR I-SPACE??
	BEQ	1$		; IF EQ, WE'RE DOING I-SPACE
	MOV	S$GDWP(R5),R3	; IF NE, WE NEED D-SPACE WINDOW POINTER
	BR	2$
1$:
	MOV	S$GWDP(R5),R3	; GET I-SPACE WINDOW BLOCK ADDRESS
2$:
	TST	$LVL		; ROOT LEVEL?
	BNE	10$		; IF NE NO
	CMP	R1,$RTSEG	; AT MAIN ROOT?
	BNE	5$		; IF EQ NO
	TST	PASS		; DOING D-SPACE OR I-SPACE??
	BEQ	3$		; IF EQ, WE'RE DOING I-SPACE
	MOV	S$GDWP(R5),CURWDD ; SET UP CURRENT WINDOW, D-SPACE
	BR	10$
3$:
	MOV	S$GWDP(R5),CURWND ; SET UP CURRENT WINDOW, I-SPACE
	BR	10$		;
5$:
	TSTB	RSFLG		; RESIDENT OVERLAYS PRESENT?
	BEQ	6$		; IF EQ NO
	MOV	$VRTBD,R1	; YES - SET VIRTUAL ADDRESS BOUND
	MOV	$HVRTL,R0	; GET HIGH VIRTUAL ADDRESS
	CALL	ROUND		; ROUND TO NEXT 4K BOUNDARY
	DEC	R1		; BACK OFF ONE
	MOV	R1,$HVRTL	; SET NEW HIGH VIRTUAL ADDRESS
	BIT	#ID$ATA,$SWTCH	; BUILDING AN I/D TASK??
	BEQ	6$		; IF EQ, NO...IGNORE THE REST OF THIS
				; STUFF...
	MOV	$VRTBD,R1	; SET VIRTUAL ADDRESS BOUND
	MOV	$HDVRT,R0	; SET HIGH D-SPACE VIRTUAL ADDRESS
	CALL	ROUND		; ROUND UP TO NEXT 4K BOUNDARY
	DEC	R1		; BACK OFF ON BYTE
	MOV	R1,$HDVRT	; AND SAVE IT FOR LATER
6$:
	MOV	R3,R1		; GET WINDOW BLOCK ADDRESS
	CALL	$CVRL		; CONVERT TO REAL
	BIT	#WS.WRT,W.NSTS(R0) ; READ-ONLY SEGMENT?
	BNE	10$		; IF NE NO
	MOV	W.NBAS(R0),R0	; GET LENGTH OF CO-TREE OVERLAY STRUCTURE
	BEQ	7$		; IF EQ NO OVERLAYS
	INC	COTFLG		; FLAG AS CO-TREE
	CALL	ALOAPR		; ALLOCATE APRS FOR CO-TREE
	DEC	R1		; BACK OFF BASE ADDRESS
	TST	PASS		; DOING D-SPACE OR I-SPACE??
	BEQ	650$		; IF EQ, WE'RE DOING I-SPACE
	MOV	R1,S$GDVA(R5)	; SAVE BASE AS D-VIRTUAL UPPER BOUND
	BR	7$
650$:
	MOV	R1,S$GVAD(R5)	; SAVE BASE AS I-VIRTUAL UPPER BOUND
7$:
	CLR	LVL		; SET TO LEVEL ZERO (ROOT)
10$:				;
	MOV	#4,PHYBD	; SET PHYSICAL ADDRESS BOUND
	MOV	#4,VRTBD	; SET VIRTUAL ADDRESS BOUND
	MOV	R5,R0		; COPY ADDRESS OF SEGMENT
	MOV	S$GUP(R0),R1	; GET LINK-UP
	BEQ	20$		; IF EQ NO LINK UP
	CALL	$CVRL		; CONVERT LINK-UP TO REAL ADDRESS
20$:				;
	TST	S$GDWN(R0)	; ROOT SEGMENT?
	BEQ	30$		; IF EQ YES
	BITB	#SG$RES,S$GSTS(R0) ; SEGMENT RESIDENT?
	BEQ	30$		; IF EQ NO
;
;+
; At this point we must remember that we are processing a memory-resident
; overlay that has at least two null segments in order. the .ODL
; which caused the problem looked like this:
;
;	.ROOT	USER,LIB
;USER:	.FCTR	MAIN-*!(INPUT,CALC,OUTPUT)
;	.NAME	LIBROT
;LIB:	.FCTR	LIBROT-*!($ADD,$SUB,$MUL,$DIV)
;	.END
;
; The net result was that the structure was built as a disk-resident
; overlay structure.
;
	MOVB	SP,RSFLG	; SIGNAL THAT A RESIDENT OVERLAY IS PRESENT
	MOV	S$GDWN(R5),R1	; GET LINK-DOWN
	BEQ	25$		; IF EQ NONE
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
25$:
	MOV	$PHYBD,PHYBD	; SET PHYSICAL ADDRESS BOUND
	MOV	$VRTBD,VRTBD	; SET VIRTUAL ADDRESS BOUND
30$:				;
	MOV	#2,R4		; ASSUME R/O ALLOCATION
	MOV	R3,-(SP)	; SAVE VIRTUAL ADDRESS
	MOV	R3,R1		; COPY VIRTUAL ADDRESS
	CALL	$CVLOK		; CONVERT TO REAL, LOCK IN MEMORY
	CALL	$WRMPG		; WRITE-MARK PAGE
	MOV	R0,-(SP)	; SAVE REAL ADDRESS
	MOV	R0,R2		; COPY ADDRESS
	TST	PASS		; DOING D-SPACE OR I-SPACE??
	BEQ	35$		; IF EQ, WE'RE DOING I-SPACE
	MOV	S$GRWD(R5),R0	; GET R/W D-ALLOCATION IN BYTES
	BR	40$
35$:
	MOV	S$GRW(R5),R0	; GET R/W I-ALLOCATION IN BYTES
40$:
	TSTB	ROFLG		; READ-ONLY ALLLOCATION PERFORMED?
	BEQ	50$		; IF EQ NO
	CLR	R1		; ASSUME AT MAIN ROOT
	CMP	$CRVSG,$RTSEG	; SEGMENT=MAIN ROOT?
	BEQ	60$		; IF EQ YES, IGNORE R/O ALLOCATION
	BIT	#WS.WRT,W.NSTS(R2) ; WINDOW BLOCK IMPURE?
	BEQ	70$		; IF EQ NO
50$:				;
	TST	PASS		; DOING D-SPACE OR I-SPACE??
	BEQ	55$		; IF EQ, WE'RE DOING I-SPACE
	MOV	R0,S$GODB(R5)	; SET BASE OF R/O D-SECTION
	MOV	S$GROD(R5),R1	; GET R/O D-SPACE ALLOCATION
	CLR	S$GROD(R5)	; CLEAR R/O D-SPACE ALLOCATION
	BR	60$
55$:
	MOV	R0,S$GROB(R5)	; SET BASE OF READ-ONLY SECTIONS
	MOV	S$GRO(R5),R1	; GET READ-ONLY ALLOCATION
	CLR	S$GRO(R5)	; CLEAR READ-ONLY ALLOCATION
60$:				;
	CLR	R4		; SET R/W BIAS
	CALL	ADOFST		; COMPUTE R/W PLUS R/O
	TST	PASS		; DOING D-SPACE OR I-SPACE??
	BEQ	65$		; IF EQ, WE'RE DOING I-SPACE
	MOV	R0,S$GRWD(R5)	; SET R/W D-ALLOCATION SIZE IN BYTES
	BR	70$
65$:
	MOV	R0,S$GRW(R5)	; SET R/W I-ALLOCATION SIZE IN BYTES
70$:				;
	MOV	R5,R3		; COPY DESCRIPTOR ADDRESS
	ADD	R4,R3		; ADD R/W - R/O BIAS
	TST	PASS		; DOING D-SPACE OR I-SPACE??
	BEQ	71$		; IF EQ, WE'RE DOING I-SPACE
	MOV	LDLGH,R0	; GET LOCAL DATA LENGTH
	MOV	S$GRWD(R3),R1	; GET D-ALLOCATION COMPONENT
	BR	72$
71$:
	MOV	LCLGH,R0	; GET LOCAL I-SPACE LENGTH
	MOV	S$GRW(R3),R1	; GET I-ALLOCATION COMPONENT
72$:
	CALL	ADOFST		; ADD OFFSET
	BCC	720$		; IF C-CLEAR, SKIP THE REST
	BNE	720$		; IF RESULT IS NOT ZERO, SKIP IT
	DEC	R0		; IF C-SET AND Z-SET, DECREMENT LENGTH
720$:
	MOV	PHYBD,R1	; GET PHYSICAL ADDRESS LIMIT
	CALL	ADRUND		; ROUND TO PHYSICAL ADDRESS LIMIT
	TST	PASS		; DOING D-SPACE OR I-SPACE??
	BEQ	73$		; IF EQ, WE'RE DOING I-SPACE
	MOV	R0,S$GDLN(R5)	; SET LENGTH OF D-SPACE DISK READ
	BR	74$
73$:
	MOV	R0,S$GLNG(R5)	; SET LENGTH OF I-SPACE DISK READ
74$:
	TST	COTFLG		; CO-TREE?
	BEQ	77$		; IF EQ NO
	TST	$LVL		; ROOT OF CO-TREE?
	BNE	77$		; IF NE NO
	CALL	ALOAPR		; FIND FREE APR TO ALLOCATE
	TST	PASS		; DOING D-SPACE OR I-SPACE??
	BEQ	75$		; IF EQ, WE'RE DOING I-SPACE
	MOV	R1,S$GODB(R5)	; SAVE D-SPACE R/O BASE ADDRESS
	MOV	R1,S$GDLD(R5)	; STORE D-SPACE LOAD ADDRESS
	BR	90$
75$:
	MOV	R1,S$GROB(R5)	; SAVE R-O BASE ADDRESS
	MOV	R1,S$GLDA(R5)	; STORE LOAD ADDRESS
	BR	90$
77$:
	TST	PASS		; DOING D-SPACE OR I-SPACE
	BEQ	770$		; IF EQ, WE'RE UP TO I-SPACE
	MOV	$HDVRT,R2	; GET DATA HIGH VIRTUAL ADDRESS
	BR	780$
770$:
	MOV	$HVRTL,R2	; GET I-SPACE HIGH VIRTUAL ADDRESS
780$:
	MOV	S$GDWN(R5),R1	; GET LINK-DOWN
	BEQ	80$		; IF EQ AT ROOT
	CALL	$CVRL		; CONVERT TO REAL
	TST	PASS		; DOING D-SPACE OR I-SPACE??
	BEQ	79$		; IF EQ, WE'RE DOING I-SPACE
	MOV	S$GDVA(R0),R2	; GET LOCAL D-VIRTUAL ADDRESS
	BR	80$
79$:
	MOV	S$GVAD(R0),R2	; GET LOCAL I-VIRTUAL ADDRESS
80$:				;
	TST	R2		; AT VIRTUAL ZERO?
	BEQ	85$		; IF EQ YES
	INC	R2		; INCREMENT VIRTUAL ADDRESS
	BNE	85$		; IF NE OK
	CALL	OVRFLW		; REPORT ADDRESS OVERFLOW
	MOV	#-1,R2		; SET BASE ADDRESS TO MAX
85$:				;
	TST	PASS		; DOING D-SPACE OR I-SPACE??
	BEQ	850$		; IF EQ, WE'RE DOING I-SPACE
	MOV	R2,S$GDLD(R5)	; SET D-VIRTUAL SEGMENT LOAD ADDRESS
	BR	860$
850$:
	MOV	R2,S$GLDA(R5)	; SET I-VIRTUAL SEGMENT LOAD ADDRESS
860$:
	MOV	R2,R0		; COPY BASE ADDRESS
	TST	PASS		; DOING D-SPACE OR I-SPACE??
	BEQ	861$		; IF EQ, WE'RE DOING I-SPACE
	MOV	LVDADR,R1	; GET CURRENT D-SPACE VIRTUAL ADDRESS
	BR	862$
861$:
	MOV	LVADR,R1	; GET CURRENT I-SPACE VIRTUAL ADDRESS
862$:
	CALL	ADOFST		; ADD OFFSET
	TST	PASS		; DOING D-SPACE OR I-SPACE??
	BEQ	863$		; IF EQ, WE'RE DOING I-SPACE
	MOV	R0,LVDADR	; SAVE LOCAL D-SPACE VIRTUAL ADDRESS
	BR	864$
863$:
	MOV	R0,LVADR	; SAVE LOCAL I-SPACE VIRTUAL ADDRESS
864$:
	TSTB	ROFLG		; READ-ONLY ALLOCATION RECOGNIZED?
	BEQ	87$		; IF EQ NO
	CMP	$CRVSG,$RTSEG	; AT MAIN ROOT?
	BEQ	88$		; IF EQ YES
87$:				;
	TST	PASS		; DOING D-SPACE OR I-SPACE??
	BEQ	870$		; IF EQ, WE'RE DOING I-SPACE
	ADD	R0,S$GODB(R5)	; SET D-SPACE R/O BASE ADDRESS
	BR	88$
870$:
	ADD	R0,S$GROB(R5)	; SET I-SPACE R/O BASE ADDRESS
88$:				;
	TST	PASS		; DOING D-SPACE OR I-SPACE??
	BEQ	871$		; IF EQ, WE'RE DOING I-SPACE
	MOV	S$GRWD(R5),R1	; GET D-SPACE LENGTH ALLOCATION IN BYTES
	BNE	872$		; IF NE, WE HAVE R/W D-SPACE LENGTH
	MOV	S$GROD(R5),R1	; ELSE GET R/O D-SPACE ALLOCATION IN BYTES
	BR	872$
871$:
	MOV	S$GRW(R5),R1	; GET I-SPACE LENGTH ALLOCATION IN BYTES
	BNE	872$		; IF NE, WE HAVE R/W I-SPACE LENGTH
	MOV	S$GRO(R5),R1	; ELSE GET R/O I-SPACE ALLOCATION IN BYTES
872$:
	CALL	ADOFST		; COMPUTE TOP ADDRESS BOUND
	MOV	VRTBD,R1	; GET VIRTUAL ADDRESS BOUND
	CALL	ROUND		; ROUND TO ADDRESS LIMIT
	BCS	880$		; IF C/S OVER 32K LIMIT
	BEQ	89$		; IF EQ AT LOW LIMIT
880$:				;
	DEC	R1		; BACK OFF LIMIT
89$:				;
	TST	PASS		; DOING D-SPACE OR I-SPACE??
	BEQ	890$		; IF EQ, WE'RE DOING I-SPACE
	MOV	R1,S$GDVA(R5)	; SAVE D-VIRTUAL ADDRESS UPPER BOUND
	BR	900$
890$:
	MOV	R1,S$GVAD(R5)	; SAVE I-VIRTUAL ADDRESS UPPER BOUND
900$:
	TST	COTFLG		; CO-TREE?
	BNE	90$		; IF NE YES
	TST	PASS		; DOING D-SPACE OR I-SPACE??
	BEQ	901$		; IF EQ, WE'RE DOING I-SPACE
	CMP	R1,$HDVRT	; HAVE NEW HIGH D-SPACE LIMIT?
	BLOS	90$		; IF LOS, NO
	MOV	R1,$HDVRT	; YES, SAVE THE NEW D-SPACE LIMIT
	BR	90$
901$:
	CMP	R1,$HVRTL	; HAVE NEW HIGH LIMIT?
	BLOS	90$		; IF LOS NO
	MOV	R1,$HVRTL	; SET NEW HIGH LIMIT
90$:				;
	BITB	#SG$RES,S$GSTS(R5) ; SEGMENT RESIDENT?
	BEQ	100$		; IF EQ NO
	MOV	2(SP),R2	; GET VIRTUAL ADDRESS OF CURRENT WINDOW
	CALL	CLSWND		; CLOSEOUT PREVIOUS WINDOW ALLOCATION
	MOV	(SP),R2		; RETRIEVE REAL ADDRESS
	TST	PASS		; DOING D-SPACE OR I-SPACE??
	BEQ	95$		; IF EQ, WE'RE DOING I-SPACE
	MOV	S$GDLD(R5),W.NBAS(R2) ; SET BASE ADDRESS OF D-WINDOW
	BR	100$
95$:
	MOV	S$GLDA(R5),W.NBAS(R2) ; SET BASE ADDRESS OF I-WINDOW
100$:				;
	TST	PASS		; DOING D-SPACE OR I-SPACE??
	BEQ	101$		; IF EQ, WE'RE DOING I-SPACE
	MOV	S$GDLD(R5),R0	; GET D-SPACE LOAD ADDRESS
	MOV	S$GDLN(R5),R1	; GET D-SPACE LOAD LENGTH
	BR	102$
101$:
	MOV	S$GLDA(R5),R0	; GET I-SPACE LOAD ADDRESS
	MOV	S$GLNG(R5),R1	; GET I-SPACE LOAD LENGTH
102$:
	CALL	ADOFST		; COMPUTE TOP WINDOW ADDRESS
	MOV	(SP)+,R2	; GET REAL ADDRESS OF WINDOW BLOCK
	SUB	W.NBAS(R2),R0	; SUBTRACT BASE VIRTUAL ADDRESS
	CMP	R0,W.NSIZ(R2)	; NEW MAX LENGTH?
	BLO	110$		; IF LO NO
	MOV	R0,W.NSIZ(R2)	; SET NEW MAX LENGTH
110$:				;
	MOV	(SP)+,R1	; GET VIRTUAL ADDRESS OF WINDOW
	CALL	$UNLPG		; UNLOCK PAGE
	CALL	CSREL		; RELOCATE ALL SECTIONS
	MOV	#LCLGH,R0	; GET ADDRESS OF LOCAL LENGTH
	CLR	(R0)+		; CLEAR I-SPACE LOCAL TASK LENGTH
	CLR	(R0)+		; CLEAR I-SPACE LOCAL TASK-VIRTUAL ADDRESS
	TST	PASS		; WE DOING AN I- OR D-SPACE
	BEQ	115$		; IF EQ, I-SPACE, DON'T CLEAR THE D-SPACE DATA
	CLR	(R0)+		; CLEAR D-SPACE LOCAL TASK LENGTH
	CLR	(R0)		; CLEAR D-SPACE LOCAL TASK-VIRTUAL ADDRESS
115$:
	TST	PASS		; DOING D-SPACE OR I-SPACE??
	BEQ	120$		; IF EQ, WE'RE DOING I-SPACE
	MOV	S$GDLN(R5),R0	; GET D-SPACE DISK ALLOCATION
	BR	130$
120$:
	MOV	S$GLNG(R5),R0	; GET I-SPACE DISK ALLOCATION
130$:


	TST	PASS		; WE DOING I- OR D-SPACE?
	BEQ	BLKAL		; IF EQ, IT'S I-SPACE
	CALLR	BLKAL1		; IF NE, ALLOCATE D-SPACE  DISK BLOCKS
;+
;
; This section of code is entered by two directions. It is 'fallen' into
; when the physical memory is being allocated by 'PHALO' or it is called
; as a subroutine by the root of this module, namely, '$SGALO.' If called
; by $SGALO, it must pre-allocate the disk blocks for the read-only code
; of a multi-user task and, if the user is building an I/D task, it must
; do the same for the read-only data. The disk blocks are kept as an
; number in the 'TABLS' section of the Taskbuilder in the following locations:
;
;	$RLBLK - Highest relative block for R/W I-space
;	$ROBLK - Highest relative block for R/O I-space
;	$RLDBK - Highest relative block for R/W D-space
;	$RODBK - Highest relative block for R/O D-space
;
; These values are used to set the relative disk block addresses into the
; correct segment descriptor offsets. After completion of segment virtual
; and physical memory allocation, these values are modified to reflect
; the actual disk block address relative to label block 0.
;
;-
BLKAL:				;
	.IF DF D$SG5

	MOV	#$BLKAL,FMTADR	; SET FORMAT ADDRESS

	.ENDC
	MOV	$RLBLK(R4),S$GBLK(R3) ; SET DISK ADDRESS
	BITB	#SG$DSK,S$GSTS(R5) ; SEGMENT HAVE DISK ALLOCATION?
	BNE	10$		; IF NE NO
	CALL	CNVBLK		; CONVERT SIZE INTO NUMBER OF BLOCKS..
	ADD	R0,$RLBLK(R4)	; UPDAT HIGHEST BLOCK NUMBER NEEDED
10$:
	RETURN
BLKAL1:
	.IF DF D$SG5

	MOV	#$BLKA1,FMTADR	; SET FORMAT ADDRESS

	.ENDC
	MOV	$RLBLK(R4),S$GBWD(R3) ; SET DISK ADDRESS OF R/W OR R/O DATA
				; DEPENDING ON WHETHER WE ENTERED THIS
				; CORE FROM THE ROOT OF $SGALO OR THRU
				; THE NORMAL PROCESSING OF PHALO
	CMP	$RTSEG,$CRVSG	; CURRENT SEG = ROOT SEG??
	BNE	10$		; IF NE, NO...DON'T UPDATE D-SPACE HEADER BLK
	MOV	$RLBLK(R4),$DHDRB(R4) ; SET DISK BLOCK FOR DATA HEADER
10$:
	TST	R0		; ANY LENGTH TO THIS ??
	BEQ	20$		; IF EQ, NO...IGNORE THE REST.
	CALL	CNVBLK		; CONVERT TO NUMBER OF BLOCKS
	ADD	R0,$RLBLK(R4)	; UPDATE THE BLOCK COUNT
20$:
	RETURN

CNVBLK:
	CLC			; CLEAR CARRY
	ROR	R0		; CONVERT TO WORDS
	ADD	#377,R0		; ROUND TO NEAREST BLOCK
	CLRB	R0		; CLEAR LOW BYTE
	SWAB	R0		; POSITION TO LOW BYTE

	.IF DF D$SG5

	MOV	$RODBK,-(SP)	; PUSH DISK BLOCK CELLS.
	MOV	$RLDBK,-(SP)
	MOV	$ROBLK,-(SP)
	MOV	$RLBLK,-(SP)
	MOV	R3,-(SP)	; MODIFIED SEGMENT DESCRIPTOR ADDRESS
	MOV	R5,-(SP)	; CURRENT SEGMENT DESCRIPTOR ADDRESS
	MOV	R0,-(SP)	; BLOCK ALLOCATION
	MOV	R4,-(SP)	; INCLUDE THE RO/RW BIAS VALUE
	MOV	(PC)+,-(SP)	; INCLUDE THE FORMAT STRING
FMTADR:	.WORD	$BLKAL
	MOV	$PHASE,$DVDEB
	CALL	$DVDBP
	ADD	#2*9.,SP	; CLEAN UP THE STACK
	CLR	$DVDEB

	.ENDC

	RETURN			;


	.DSABL	LSB

;
; SEGMENT MEMORY ALLOCATION ROUTINE
;
; THIS ROUTINE IS CALLED FOR EACH SEGMENT IN THE ALLOCATION.
;

SGALO:				;
	SAVRG			; SAVE THE NON-VOLATILE REGISTERS
	CALL	CLRM2		; CLEAR WORKING STORAGE
	MOV	$CRVSG,R1	; GET VIRTUAL ADDRESS OF CURRENT SEGMENT
	CALL	$WRMPG		; WRITE-MARK PAGE
	MOV	$CRSEG,R5	; GET REAL ADDRESS OF SEGMENT
	TST	$LVL		; ROOT LEVEL?
	BNE	5$		; IF NE NO
	CMP	R1,$RTSEG	; AT ROOT?
	BNE	2$		; IF NE NO
;+
; The code which follows sets the length of the stack size plus the length
; of the header into WINDOW 0 for the main tree root only. If a co-tree
; root is detected, processing bypasses this ant proceeds directly to
; 2$ where we check to see if we are setting up a multi-user task as well.
;-
	BIS	$STACK,WNLEN	; SET STACK SIZE
	BIS	$HDSIZ,WNLEN	; SET HEADER SIZE
	BIS	#WS.WRT,WNSTS	; FORCE R/W FLAG ON
	BR	5$
2$:
;+
; If we get here, it means that we're at a co-tree root and need to check
; if we also need to flag multi-user protection as well. If we were processing
; co-trees and we are no longer at the first co-tree root, we must unlock
; the data structure for the previous co-tree root, fetch the next pointer
; and lock in in memory.
;-
	BIT	#MP$SY,$SWTCH	; MAPPED TARGET SYSTEM?
	BEQ	5$		; IF EQ NO
	BIT	#<SW$MU>,TSKSW	; RECOGNIZING R/O PROTECTION
	BEQ	5$		; IF EQ NO
	MOV	SP,COTFLG	; FLAG AT CO-TREE
	MOV	RWND,R1		; FIRST CO-TREE ?
	BEQ	4$		; IF EQ YES
	CALL	$UNLPG		; UNLOCK PRIVOUS WINDOW
4$:
	MOV	S$GWDP(R5),RWND ; SAVE VIRTUAL ADDRESS OF WINDOW BLOCK FOR
				; CO-TREE ROOT
	MOV	RWND,R1		; GET VIRTUAL ADDRESS
	CALL	$CVLOK		; CONVERT TO REAL AND LOCK IN MEMORY
	CALL	$WRMPG		; WRITE MARK PAGE
	MOV	R0,RWND+2	; SAVE REAL ADDRESS OF WINDOW
	BIT	#ID$ATA,$SWTCH	; BUILDING AN I/D TASK ?
	BEQ	5$		; IF EQ, NO...CONVENTIONAL
	MOV	RWNDD,R1	; FIRST CO-TREE ?
	BEQ	401$		; IF EQ YES
	CALL	$UNLPG		; UNLOCK PRIVOUS WINDOW
401$:
	MOV	S$GDWP(R5),RWNDD ; SAVE VIRTUAL ADDRESS OF WINDOW BLOCK FOR
				; CO-TREE ROOT
	MOV	RWNDD,R1	; GET VIRTUAL ADDRESS
	CALL	$CVLOK		; CONVERT TO REAL AND LOCK IN MEMORY
	CALL	$WRMPG		; WRITE MARK PAGE
	MOV	R0,RWNDD+2	; SAVE REAL ADDRESS OF WINDOW
5$:				;
;+
; At this point we process the segment thru common code, since all the
; specific things to be done for multi-user protection and co-trees
; has been done.
;-
	CLR	R3		; CLEAR R/O FLAG
	MOV	$CRSEG,R5	; GET REAL ADDRESS OF SEGMENT
	MOV	#2,R4		; SET FLAG FOR R/W ALLOCATION
	CALL	CSALO		; ALLOCATE R/W MEMORY
	MOV	R4,R1		; GET ADDRESS LIMIT
	MOV	R4,-(SP)	; SAVE ADDRESS LIMIT
	BIT	#ID$ATA,$SWTCH	; IS THIS AN I/D TASKBUILD?
	BEQ	6$		; IF EQ, NO...CONVENTIONAL
	MOV	#LDLGH,R4	; POINT TO LOCAL DATA LENGTH
	MOV	(R4),R0		; GET LOCAL LENGTH OF LOCAL DATA
	BIT	#SG$RND,S$GSTS(R5) ; ROUND THIS SEGMENT?
	BEQ	501$		; IF EQ, NO...
	MOV	#20000,R1	; SET APR LENGTH
501$:
	CALL	ADRUND		; ROUND TO LIMIT
	MOV	R0,S$GRWD(R5)	; SAVE LENGTH OF DATA
	MOV	R0,(R4)		; SET NEW LOCAL DATA LENGTH
6$:
	MOV	(SP)+,R1	; RESTORE ADDRESS LIMIT
	MOV	#LCLGH,R4	; POINT TO LOCAL LENGTH
	MOV	(R4),R0		; GET LOCAL LENGTH
	BIT	#SG$RND,S$GSTS(R5) ; ROUND THIS SEGMENT?
	BEQ	601$		; IF EQ, NO...
	MOV	#20000,R1	; SET APR LENGTH
601$:
	CALL	ADRUND		; ROUND TO SPECIFIED LIMIT
	MOV	R0,S$GRW(R5)	; SAVE LENGTH
	MOV	R0,(R4)		; SET NEW LOCAL LENGTH
	BIS	R0,WNLEN	; SET LENGTH FLAG
	BEQ	10$		; IF EQ SEGMENT HAS NO R/W ALLOCATION
	BIS	#WS.WRT,WNSTS	; SET R/W FLAG
10$:				;
	BIT	#ID$ATA,$SWTCH	; IS THIS AN I/D TASKBUILD?
	BEQ	12$		; IF EQ, NO...CONVENTIONAL
	TST	S$GRWD(R5)	; IF NE, YES...IS THE R/W DATA
	BEQ	12$		; IF EQ, NO...
	BIS	#WS.WRT,WNSTS	; IF NE, YES...FLAG THE WINDOW AS R/W
12$:
	TST	R3		; ANY R/O MEMORY
	BEQ	40$		; IF EQ NO
	CLR	(R4)+		; RESET LOCAL LENGTH
	CLR	(R4)+		; CLEAR LOCAL VIRTUAL ADDRESS
	CLR	(R4)+		; RESET LOCAL DATA LENGTH
	CLR	(R4)		; CLEAR LOCAL DATA VIRTUAL ADDRESS
	MOV	#-2,R4		; SET FOR R/O ALLOCATION
	CALL	CSALO		; ALLOCATE R/O MEMORY
	BIT	#ID$ATA,$SWTCH	; IS THIS AN I/D TASKBUILD?
	BEQ	15$		; IF EQ, NO...CONVENTIONAL
	MOV	#LDLGH,R4	; POINT TO LOCAL DATA LENGTH
	MOV	#2,R1		; GET BOUNDRY VALUE
	MOV	(R4),R0		; GET LOCAL DATA LENGTH
	BEQ	15$		; IF EQ NONE
	BIT	#SG$RND,S$GSTS(R5) ; ROUND THIS SEGMENT?
	BEQ	120$		; IF EQ, NO...
	MOV	#20000,R1	; SET APR LENGTH
120$:
	CALL	ADRUND		; ROUND TO LIMIT
	MOV	R0,S$GROD(R5)	; SAVE LIMIT
	MOV	R0,(R4)		; SET NEW LOCAL DATA LENGTH
15$:
	MOV	#LCLGH,R4	; POINT TO LOCAL LENGTH
	BIS	(R4),WNLEN	; SET LENGTH FLAG
	MOV	#2,R1		; GET BOUNDARY VALUE
	MOV	(R4),R0		; GET LOCAL LENGTH
	BIT	#SG$RND,S$GSTS(R5) ; ROUND THIS SEGMENT?
	BEQ	150$		; IF EQ, NO...
	MOV	#20000,R1	; SET APR LENGTH
150$:
	CALL	ADRUND		; ROUND TO LIMIT
	MOV	R0,S$GRO(R5)	; SAVE LIMIT
	CALL	RECOG		; RECOGNIZING MULTIUSER?
	BCS	30$		; IF CS NO
	MOVB	SP,ROFLG	; SET READ-ONLY RECOGNITION FLAG
	INC	$NUMWN		; ASSUME AT MAIN ROOT
	CMP	$CRVSG,$RTSEG	; CURRENT=MAIN ROOT?
	BEQ	40$		; IF EQ YES
	DEC	$NUMWN		; RESET WINDOW COUNT
	TST	$LVL		; CO-TREE ROOT
	BEQ	40$		; IF EQ YES
	BITB	#SG$RES,S$GSTS(R5) ; RESIDENT SEGMENT?
	BNE	40$		; IF NE YES
30$:				;
	BIS	#WS.WRT,WNSTS	; SET R/W FLAG
40$:				;
	MOV	S$GWDP(R5),R1	; GET ADDRESS OF WINDOW BLOCK
	BEQ	50$		; IF EQ NONE
	CALL	$CVRL		; CONVERT TO REAL
	CALL	$WRMPG		; WRITE-MARK PAGE
	BIS	WNSTS,W.NSTS(R0) ; SET FLAGS
	BIS	WNLEN,W.NLEN(R0) ; SET LENGTH FLAG
	TST	COTFLG		; CO-TREE?
	BEQ	50$		; IF EQ NO
;+
; From here on, we process a segment if it is a cotree root. What we need to do
; is adjust the base address of that root by looking at the down-link, getting
; the highest virtual address of that down-tree segment and adding to it the
; length of that segment. The resulting value is rounded up to the virtual
; address limit and saved in the current segment's highest virtual address cell.
;-
	CMP	S$GWDP(R5),RWND ; CURRENT WINDOW = CO-TREE WINDOW?
	BNE	50$		; IF NE, NO...DON'T ADULTERATE ROOT WINDOW...
	MOV	RWND+2,R4	; GET CO-TREE ROOT WINDOW BLOCK ADDRESS
	BIS	WNSTS,W.NSTS(R4); SET FLAGS
	TST	WNSTS		; SEGMENT R-W?
	BNE	50$		; IF NE R-W SEGMENT
	MOV	S$GDWN(R5),R1	; GET LINK DOWN
	BEQ	45$		; IF EQ ROOT
	CALL	$CVRL		; CONVERT TO REAL
	MOV	S$GVAD(R0),R1	; GET LOCAL LENGTH
	MOV	S$GRO(R5),R0	; GET LEMGTH OF SEGMENT
	CALL	ADOFST		; ADD OFFSET
	MOV	$VRTBD,R1	; GET VIRTUAL BOUND
	CALL	ROUND		; ROUND TO PHYSCIAL BOUND
	BCS	44$		; IF C/S OVER LIMIT
	BEQ	45$		; IF EQ AT LOW LIMIT
44$:
	DEC	R1		; BACK OFF LIMIT
45$:
	MOV	R1,S$GVAD(R5)	; SAVE LOCAL LENGTH
	CMP	R1,W.NBAS(R4)	; HAVE NEW HIGH LIMIT
	BLOS	50$		; IF LOS NO
	MOV	R1,W.NBAS(R4)	; SAVE HIGH LOCAL LENGTH IN CO-TREE ROOT
50$:				;
;
; At this point we must check if we're building an I/D task again. If we are,
; we have to set up the D-space window block so that later we don't
; inadvertently set the root segment as read-only and use the wrong disk block
; address in the segment descriptor during Phase 5 End-of-Segment processing.
;

	BIT	#ID$ATA,$SWTCH	; DOING AN I/D TASKBUILD??
	BEQ	80$		; IF EQ, NO...SKIP THE REST...
	MOV	#LDLGH,R4	; POINT TO LOCAL D-SPACE LENGTH
	BIS	(R4),WNLEN	; SET LENGTH FLAG (THIS HAS ALREADY BEEN
				; ROUNDED UP TO THE CORRECT ADDRESS LIMIT.
	CALL	RECOG		; RECOGNIZING MULTIUSER?
	BCS	60$		; IF CS NO
	MOVB	SP,RODFLG	; SET READ-ONLY DATA RECOGNITION FLAG
	INC	$NUMWN		; ASSUME AT MAIN ROOT
	CMP	$CRVSG,$RTSEG	; CURRENT=MAIN ROOT?
	BEQ	70$		; IF EQ YES
	DEC	$NUMWN		; RESET WINDOW COUNT
	TST	$LVL		; CO-TREE ROOT
	BEQ	70$		; IF EQ YES
	BITB	#SG$RES,S$GSTS(R5) ; RESIDENT SEGMENT?
	BNE	70$		; IF NE YES
60$:				;
	BIS	#WS.WRT,WNSTS	; SET R/W FLAG
70$:				;
	MOV	S$GDWP(R5),R1	; GET ADDRESS OF D-SPACE WINDOW BLOCK
	BEQ	80$		; IF EQ NONE
	CALL	$CVRL		; CONVERT TO REAL
	CALL	$WRMPG		; WRITE-MARK PAGE
	BIS	WNSTS,W.NSTS(R0) ; SET D-SPACE FLAGS
	BIS	WNLEN,W.NLEN(R0) ; SET D-SPACE LENGTH FLAG
	TST	COTFLG		; CO-TREE ??
	BEQ	80$		; IF EQ, NO...
	CMP	S$GDWP(R5),RWNDD ; CURRENT D-SPACE WINDOW = D-SPACE ROOT?
	BNE	80$		; IF NE, NO...DON'T ADULTERATE THE D-SPACE ROOT
	MOV	RWNDD+2,R4	; GET D-SPACE CO-TREE ROOT WINDOW BLOCK ADDRESS
	BIS	WNSTS,W.NSTS(R4); SET FLAGS
	TST	WNSTS		; SEGMENT R-W?
	BNE	80$		; IF NE R-W SEGMENT
	MOV	S$GDWN(R5),R1	; GET LINK DOWN
	BEQ	75$		; IF EQ ROOT
	CALL	$CVRL		; CONVERT TO REAL
	MOV	S$GDVA(R0),R1	; GET D-SPACE LOCAL LENGTH
	MOV	S$GROD(R5),R0	; GET D-SPACE LENGTH OF SEGMENT
	CALL	ADOFST		; ADD OFFSET
	MOV	$VRTBD,R1	; GET VIRTUAL BOUND
	CALL	ROUND		; ROUND TO PHYSCIAL BOUND
	BCS	74$		; IF C/S OVER LIMIT
	BEQ	75$		; IF EQ AT LOW LIMIT
74$:
	DEC	R1		; BACK OFF LIMIT
75$:
	MOV	R1,S$GDVA(R5)	; SAVE LOCAL LENGTH
	CMP	R1,W.NBAS(R4)	; HAVE NEW HIGH LIMIT
	BLOS	80$		; IF LOS NO
	MOV	R1,W.NBAS(R4)	; SAVE HIGH LOCAL LENGTH IN CO-TREE ROOT
80$:

	.IF DF D$SG1

	MOV	R0,-(SP)	; Save R0
	MOV	R1,-(SP)	; Save R1
	MOV	$PHASE,$TRSPZ	; Phase on which to dump working storage
	CLR	$TRSME		; Base address of working storage
	MOV	#$TRSTO,R0	; Reference label for Working Storage Strings...
	CALL	$TRACE
	MOV	$PHASE,$TRSPH	; Copy the phase number
	MOV	$CRSEG,$TRSCS	; Set the current segment address
	MOV	#$TRSEG,R0	; Point to the list
	CALL	$TRACE		; and dump it to ti:
	MOV	S$GWDP(R5),R1	; get window block pointer
	CALL	$CVRL		; convert to real
	MOV	$PHASE,$TRWPH	; Set Phase
	MOV	R0,$TRWCS	; set the current window block address
	MOV	#$TRWIN,R0	; point to the list
	CALL	$TRACE		; and dump it to ti:
	MOV	RWND+2,$TRWCS	; set the co-tree window block address
	BEQ	NOCOTI		; if eq, no cotree
	MOV	$PHASE,$TRWPH	; Set Phase
	MOV	#$TRWIN,R0	; point to the list
	CALL	$TRACE		; and dump it to ti:
NOCOTI:
	BIT	#ID$ATA,$SWTCH	; building an i/d task
	BEQ	NONID		; if eq, no
	MOV	S$GDWP(R5),R1	; get window block pointer
	CALL	$CVRL		; convert to real
	MOV	R0,$TRWCS	; set the current window block address
	MOV	#$TRWIN,R0	; point to the list
	MOV	$PHASE,$TRWPH	; Set Phase
	CALL	$TRACE		; and dump it to ti:
	MOV	RWNDD+2,$TRWCS	; set the co-tree window block address
	BEQ	NOCOTD		; if eq, no cotree
	MOV	#$TRWIN,R0	; point to the list
	MOV	$PHASE,$TRWPH	; Set Phase
	CALL	$TRACE		; and dump it to ti:
NOCOTD:
NONID:
	MOV	(SP)+,R1	; restore r1 before exiting...
	MOV	(SP)+,R0	; restore r0 before exiting...

	.ENDC

	RETURN			;

;
; CLEAR WORKING STORAGE
;

	.ENABL	LSB
CLRMEM:				;
	MOV	#CLRSZ2,R1	; GET NUMBER OF WORDS TO CLEAR
	BR	5$
CLRM2:
	MOV	#CLRSZ,R1	; GET NUMBER OF WORDS TO CLEAR
5$:
	MOV	#CLRBEG,R0	; GET START OF AREA TO CLEAR
10$:				;
	CLR	(R0)+		; CLEAR STORAGE
	SOB	R1,10$		; ...
	RETURN			;

	.DSABL	LSB

;
; ALLOCATE HEADER WINDOW BLOCKS
;

WDALO:				;
	SAVRG			; SAVE THE NON-VOLATILE REGISTERS
	MOV	$CRVSG,R1	; GET VIRTUAL ADDRESS OF CURRENT SEGMENT
	CALL	$WRMPG		; WRITE-MARK PAGE
	CLR	PASS		; SET PASS FLAG FOR I-SPACE ALLOCATION
	CALL	WDALOI		; DO THE I-SPACE ALLOCATION FIRST. WE MAY
				; ONLY HAVE TO DO THIS ONCE IF WE'RE NOT
				; BUILDING AN I/D TASK...
	BIT	#ID$ATA,$SWTCH	; WELL, IS WE BUILDING AN I/D TASK??
	BEQ	10$		; IF EQ, NO...WE'RE DONE
	MOV	#2,PASS		; FLAG THIS PASS AS D-SPACE ALLOCATION
	MOV	$CRVSG,R1	; SET CURRENT SEGMENT VIRTUAL ADDRESS
	CALL	WDALOD		; NOW GO TO IT...
10$:
	RETURN			; BACK TO $PCTRL FOR ANOTHER SEGMENT...
;
; The following two labels, although they define the same entry point,
; are here because I want to preserve my sanity! The only way we can enter
; the code through the label 'WDALOD' is if we're building a user-mode
; I/D task. This also implies that the contents of the location 'PASS'
; are non-zero. In actuality, the contents are +2. This is not a value
; to be construed as an offset value, only something other than zero.
;
WDALOD:				; ENTRY POINT IF WE'RE PROCESSING A
				; SEGMENT'S DATA ALLOCATION
WDALOI:				; ENTRY POINT IF WE'RE PROCESSING EITHER
				; A NON-I/D TASK OR AN I/D TASK'S
				; I-SPACE ALLOCATION.
	MOV	$CRSEG,R5	; GET REAL ADDRESS OF CURRENT SEGMENT
	CMP	R1,$RTSEG	; RESIDENT ROOT?
	BEQ	5$		; IF EQ YES
	BITB	#SG$RES,S$GSTS(R5) ; RESIDENT SEGMENT?
	BEQ	30$		; IF EQ NO
5$:				;
	TST	PASS		; DOING D-SPACE OR I-SPACE??
	BEQ	6$		; IF EQ, WE'RE DOING I-SPACE
	MOV	S$GDWP(R5),R1	; GET D-SPACE WINDOW DESCRIPTOR VIRTUAL ADDRESS
	BR	7$
6$:
	MOV	S$GWDP(R5),R1	; GET I-SPACE WINDOW DESCRIPTOR VIRTUAL ADDRESS
7$:
	CALL	$CVRL		; CONVERT TO REAL
	CALL	$WRMPG		; WRITE-MARK PAGE
	BIT	#WS.WRT,W.NSTS(R0) ; AREA READ-ONLY?
	BNE	10$		; IF NE NO
	BISB	#SG$RO,S$GSTS(R5) ; SET READ-ONLY FLAG
	MOV	#1,W.NRID(R0)	; SET REGION I/D TO R/W AREA
10$:				;
	TST	PASS		; DOING D-SPACE OR I-SPACE??
	BEQ	12$		; IF EQ, WE'RE DOING I-SPACE
	BIS	#WS.UDS,W.NSTS(R0) ; IF NE, D-SPACE, SO SET D-SPACE
				; MAPPING ONLY BIT...
12$:
	ADD	#W.NLEN,R0	; POINT TO MAPPING LENGTH
	TST	PASS		; WE DOING I- OR D-SPACE??
	BNE	40$		; IF NE, WE IS DOIN' D-SPACE!
	TST	$LVL		; AT ROOT LEVEL?
	BEQ	15$		; IF EQ YES
	TST	(R0)		; ANY LENGTH IN THIS SEGMENT?
	BEQ	20$		; IF EQ, NO..IGNORE IT
	CMP	$LVL,LVL	; AT HIGHER LEVEL THAN BEFORE?
	BLOS	20$		; IF LOS NO
15$:				;
	MOV	$LVL,LVL	; RESET LEVEL
	TST	(R0)		; ANY LENGTH?
	BEQ	20$		; IF EQ NO
	INC	$NUMWN		; INCREMENT COUNT OF TASK WINDOWS
20$:				;
	CLR	(R0)		; RESET LENGTH TO MAP

	.IF DF D$SG6

	MOV	R0,-(SP)	; SAVE R0
	MOV	$PHASE,$TRWPH	; COPY THE PHASE NUMBER
	MOV	R0,$TRWCS	; SET THE CURRENT WINDOW BLOCK ADDRESS
	SUB	#W.NLEN,$TRWCS	; POINT TO BEGINNING OF BLOCK
	MOV	#$TRWIN,R0	; POINT TO THE LIST
	CALL	$TRACE		; AND DUMP IT TO TI:
	MOV	(SP)+,R0	; RESTORE R0 BEFORE EXITING...

	.ENDC

25$:				;
	RETURN			;
30$:
	BIS	#DS$KOV,$SWOVR	; SET FLAG FOR DISK OVERLAY SEEN
	BR	25$		;
40$:
	TST	$LVL		; AT WHAT LEVEL ARE WE?
	BEQ	50$		; IF EQ, WE'RE AT THE MAIN ROOT
	TST	(R0)		; ANY LENGTH TO THIS D-SPACE SEGMENT?
	BEQ	20$		; IF EQ, NO...DON'T COUNT A WINDOW HERE...
	CMP	$LVL,LVLD	; WE AT A HIGHER D-SPACE LEVEL?
	BLOS	20$		; IF LOWER OR SAME, NO...BYPASS A WINDOW COUNT
50$:
	MOV	$LVL,LVLD	; WE'RE AT A HIGHER LEVEL THAN BEFORE...
				; RECORD THIS D-SPACE LEVEL
	TST	(R0)		; WE MAY BE AT A HIGHER LEVEL, BUT IS THERE ANY
				; DATA IN THIS HERE SEGMENT??
	BEQ	20$		; IF EQ, NO
	INC	$NUMWN		; YES, THERE IS, SO WE NEED A WINDOW
	BR	20$		; RESET THE LENGTH TO MAP

;
; CLOSEOUT CURRENT WINDOW
;
; THIS ROUTINE IS CALLED WHEN A NEW WINDOW IS ENTERED TO COMPLETE THE
; ALLOCATION OF MEMORY TO THE PREVIOUS WINDOW
;

CLSWND:				;
	TST	PASS		; DOING I-SPACE WINDOW??
	BNE	5$		; IF NE, NO...D-SPACE IF IT'S AN I/D BUILD
	CALL	CLSWDI		; CLOSE THE I-SPACE WINDOW FIRST. WE MAY
				; ONLY HAVE TO DO THIS ONCE IF WE'RE NOT
				; BUILDING AN I/D TASK...
5$:
	BIT	#ID$ATA,$SWTCH	; WELL, IS WE BUILDING AN I/D TASK??
	BEQ	10$		; IF EQ, NO...WE'RE DONE
	TST	PASS		; AGAIN, WE DOING I- OR D-SPACE
	BEQ	10$		; IF EQ, I-SPACE
	CALL	CLSWDD		; IF NE, CLOSE THE D-SPACE WINDOW
10$:
	RETURN
;
; The only way we can enter the code through the label 'CLSWDD' is if
; we're building a user-mode I/D task. This also implies that the contents
; of the location 'PASS' are non-zero. In actuality, the contents are +2.
; This is not a value to be construed as an offset value, only something other
; than zero.
;

	.ENABL	LSB

CLSWDD:				; ENTRY POINT IF WE'RE PROCESSING A
				; D-SPACE WINDOW
	MOV	CURWDD(R4),R1	; GET THE D-SPACE WINDOW VIRTUAL ADDRESS
	MOV	R2,CURWDD(R4)	; SET NEW CURRENT D-SPACE WINDOW
	TST	R1		; WE HAVE A WINDOW TO CLOSE OUT??
	BEQ	14$		; CONNECTOR TO 40$ (RETURN)
	BR	10$

CLSWDI:				; ENTRY POINT IF WE'RE PROCESSING EITHER
				; A NON-I/D TASK OR AN I/D TASK'S
				; I-SPACE WINDOW.
	MOV	CURWND(R4),R1	; GET VIRTUAL ADDRESS OF CURRENT WINDOW
	MOV	R2,CURWND(R4)	; SET NEW CURRENT WINDOW
	TST	R1		; HAVE WINDOW ADDRESS?
	BEQ	14$		; CONNECTOR TO 40$ (RETURN)
10$:
	CALL	$CVRL		; CONVERT TO REAL
;
; What we are doing here is correcting for a design deficiency which has
; been propagated since I/D space was conceived. Basically, the 4 consec-
; utive locations $MXLGH through $MXLGH+6 were to contain the following
; information:
;
;	$MXLGH	  -   Current length of R/W I-space
;	$MXLGH+2  -   Current length of R/O I-space
;	$MXLGH+4  -   Current length of R/O D-space
;	$MXLGH+6  -   Current length of R/W D-space
;
; Note that the D-space current length cells are opposite to the I-space
; current length cells. How nice! This clever design has caused several
; problems in the past. One of these problems deals with my sanity! The
; other problem concerns memory-resident overlaid multi-user I/D tasks.
; The difficulty arises when closing a window and saving the current
; length since we can close either R/W or R/O windows. The approach to
; the problem centers on using a negative offset based on the R/W or
; R/O offset value carried into CLSWND by R4. R3 will be saved on the
; stack, the contents of R4 copied into it and negated. Note that -0
; will still be zero. This negative offset value will be used to acc-
; sess the correct value held in either $MXLGH+6 if we're closing
; a R/W window or that value will come from $MXLGH+4 if the window is
; R/O...nothing like living with the stench of a chicken farm under
; your bedroom window...
;
	MOV	R3,-(SP)	; SAVE R3 WHILE WE PLAY GAMES...
	MOV	R4,R3		; COPY THE R/W-R/O OFFSET BIAS
	NEG	R3		; AND CONVERT ACCORDING TO THE ABOVE...
	CALL	$WRMPG		; WRITE-MARK PAGE

	.IF DF D$SG7

	MOV	R0,$TRWCS	; SET THE CURRENT WINDOW BLOCK ADDRESS
	MOV	2(SP),(R0)	; SET RETURN ADDRESS IN W.NAPR

	.ENDC

	MOV	R0,R2		; COPY REAL ADDRESS OF WINDOW
	MOV	W.NSIZ(R0),R1	; GET LENGTH
	CALL	BLOCKS		; CONVERT TO BLOCKS
	MOV	R1,W.NSIZ(R0)	; RESET SIZE
	TST	PASS		; DOING THE I- OR D-SPACE WINDOW??
	BEQ	20$		; IF EQ, I-SPACE
	MOV	$MXLGH+6(R3),R0	; GET CURRENT D-SPACE PHYSICAL LENGTH
	MOV	R0,W.NOFF(R2)	; SET WINDOW OFFSET INTO PARTITION
	ADD	$MXLGH(R4),W.NOFF(R2) ; ADD IN THE I-SPACE OFFSET
	CMP	$RTSEG,$CRVSG	; IF WE'RE NOT PROCESSING THE ROOT SEGMENT
	BNE	15$		; DON'T ADD IN THE HEDER AND STACK SIZE...
	MOV	R1,-(SP)	; SAVE W.NSIZ
	MOV	$STACK,R1	; SET STACK SIZE
	ADD	$HDSIZ,R1	; ADD IN SIZE OF HEADER
	CALL	BLOCKS		; CONVERT TO SIZE IN 32.W BLOCKS
	ADD	R1,W.NOFF(R2)	; AND ADD TO D-SPACE WINDOW OFFSET IN PARTITION
	MOV	(SP)+,R1	; RESTORE R1'S W.NSIZ VALUE
	MOV	W.NOFF(R2),RTOFF ; GET OFFSET FOR D ROOT (WINDOW 1)
	BR	17$		; CONTINUE
14$:	BR	40$		; CORRECTION FOR A BRIDGE TOO FAR...
15$:
	BIT	#EX$MRT,$SWOV2	; SHIFT MR OVERLAYS UP SO TASK CAN EXTEND?
	BEQ	17$		; IF EQ, NO 		
	TST	SHOFF		; GOT SHIFT OFFSET ALREADY?
	BNE	16$		; IF NE, YES
	MOV	W.NSIZ(R2),SHOFF ; CALCULATE SHIFT OFFSET
	ADD	RTOFF,SHOFF	;
16$:
	TST	W.NSIZ(R2)	 ; ZERO LENGTH WINDOW?
	BEQ	17$		 ; IF EQ, YES - DON'T DO ANYTHING
	SUB	SHOFF,W.NOFF(R2) ; SHIFT WINDOW DOWN
	MOV	W.NOFF(R2),LBOFF ; SAVE AS POSSIBLE LAST WINDOW
	ADD	W.NSIZ(R2),LBOFF ; CALCULATE POSSIBLE NEW WINDOW 1 OFFSET
17$:	
	CALL	ADOFST		; COMPUTE D-SPACE PHYSICAL LENGTH
	MOV	R0,$MXLGH+6(R3)	; SAVE NEW LENGTH
	BR	30$
20$:
	MOV	$MXLGH(R4),R0	; GET CURRENT PHYSICAL LENGTH
	MOV	R0,W.NOFF(R2)	; SET WINDOW OFFSET INTO PARTITION
	ADD	$MXLGH+6(R3),W.NOFF(R2) ; UPDATE THE I-SPACE OFFSET INTO THE
				; TASK PARTITION WITH THE PREVIOUS D-SPACE
				; OFFSET INTO THE PARTITION.
	BIT	#EX$MRT,$SWOV2	; SHIFT MR OVERLAYS UP SO TASK CAN EXTEND?
	BEQ	25$		; IF EQ, NO 
	BIT	#ID$ATA,$SWTCH	; BUILDING ID TASK?
	BNE	22$		; IF NE, YES - DO EX$MRT STUFF ONLY W/ D WINDOWS
	CMP	$CRVSG,$RTSEG	; DOING MAIN ROOT?
	BNE	21$		; IF EQ NO
	MOV	W.NOFF(R2),RTOFF ; SAVE ROOT OFFSET
	BR	25$		; CONTINUE
21$:	TST	SHOFF		; ALREADY HAVE SHIFT OFFSET?
	BNE	22$		; IF NE, YES
	MOV	W.NOFF(R2),SHOFF ; USE 1ST WINDOW'S OFFSET AS SHIFT OFFSET
	ADD	RTOFF,SHOFF	; INCLUDE ANY SHIFT UP FROM ROOT
22$:	
	TST	W.NSIZ(R2)	 ; ZERO LENGTH WINDOW?
	BEQ	25$		 ; IF EQ, YES - DON'T DO ANYTHING
	SUB	SHOFF,W.NOFF(R2) ; SHIFT WINDOW DOWN
	MOV	W.NOFF(R2),LBOFF ; SAVE AS POSSIBLE LAST WINDOW
	ADD	W.NSIZ(R2),LBOFF ; CALCULATE POSSIBLE NEW ROOT L$BOFF
	
25$:
	CALL	ADOFST		; COMPUTE PHYSICAL LENGTH
	MOV	R0,$MXLGH(R4)	; SAVE NEW LENGTH
30$:
	.IF DF D$SG7

	MOV	R0,-(SP)	; SAVE R0
	MOV	$PHASE,$TRWPH	; COPY THE PHASE NUMBER
	MOV	#$TRWIN,R0	; POINT TO THE LIST
	CALL	$TRACE		; AND DUMP IT TO TI:
	MOV	$TRWCS,R0	; GET POINTER TO CURRENT WINDOW BLOCK
	CLR	(R0)		; AND RESET W.NAPR
	MOV	(SP)+,R0	; RESTORE R0 BEFORE EXITING...

	.ENDC
	MOV	(SP)+,R3	; RESTORE R3 BEFORE CONTINUING...
40$:
	RETURN			;



	.DSABL	LSB

;
; CONTROL SECTION MEMORY ALLOCATION
;

CSALO:	MOV	R5,R0		;GET ADDRESS OF CURRENT CONTROL SECTION
	BIT	#SE$QA,$SWTCH	;SEQUENCE ALLOCATION?
	BEQ	5$		;IF EQ NO
	ADD	#S$GSEQ,R0	;POINT TO SEQUENCE ALLOCATION LISTHEAD
	MOV	R0,-(SP)	;SET ADDRESS OF FIRST LINK WORD
	BR	10$		;
5$:	ADD	#S$GCST,R0	;POINT TO SECTION TABLE
	MOV	#$ISED,-(SP)	;SET SYMBOL EDIT ROUTINE ADDRESS
10$:	BIT	#SE$QA,$SWTCH	;SEQUENCE ALLOCATION?
	BEQ	13$		;IF EQ NO
	MOV	@(SP)+,R0	;GET ADDRESS OF NEXT ENTRY
	BEQ	17$		;IF EQ DONE
	MOV	R0,-(SP)	;SET ADDRESS OF NEXT LINK WORD
	MOV	2(R0),R1	; GET VIRTUAL ADDRESS OF SECTION ENTRY
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	BR	20$		;
13$:	CALL	@(SP)+		;GET NEXT ENTRY
	BCC	20$		;IF CC GOT ONE
17$:	RETURN			;
20$:
	.IF DF D$SG9

	MOV	R3,-(SP)	; SAVE R3
	MOV	R0,R3		; COPY DESCRIPTOR ADDRESS
	CALL	TCSALO		; D$SG9==0
	MOV	(SP)+,R3	; RESTORE R3

	.ENDC

	BIT	#CS$IND,C$SFLG(R0) ; INDIRECT ENTRY?
	BNE	10$		;IF NE YES
	BITB	#CS$REL,C$SFLG(R0);ABS SECTION?
	BEQ	10$		;IF EQ YES
	BIT	#SE$QA,$SWTCH	; SEQUENCE ALLOCATION?
	BNE	50$		; IF NE YES - ALLOCATE RW & RO TOGETHER
	BIT	#SE$GA,$SWOVR	; SEGREGATE RO & RW PSECTS?
	BNE	50$		; IF NE NO - ALLOCATE TOGETHER
	BITB	#CS$ACC,C$SFLG(R0);WHAT TYPE OF ACCESS?
	JMP	30$(R4)		;DISPATCH
	BNE	50$		;IF NE RO
30$:	BR	40$		;
	BEQ	50$		;IF EQ RW
40$:	INC	R3		;INCREMENT FOUND ENTRY FLAG
	BR	10$		;
50$:				;
	CALL	$WRMPG		; WRITE-MARK PAGE
	BITB	#CS$RES,C$SFLG+1(R0) ; TASK-RESIDENT SECTION?
	BEQ	52$		; IF EQ NO, PROCESS SECTION
	MOV	C$SCUR(R0),C$SLTH(R0) ; SET LENGTH
	CLR	C$SCUR(R0)	; RESET CURRENT BASE ADDRESS
	CLR	C$SBSE(R0)	; RESET BASE ADDRESS
	BR	10$		;
52$:				;
	CALL	$LCKPG		; LOCK PAGE IN MEMORY
	MOV	R1,-(SP)	; SAVE VIRTUAL ADDRESS
	MOV	R4,-(SP)	; SAVE R4 AND R3
	MOV	R3,-(SP)	;
	MOV	R0,R3		;SAVE ADDRESS OF SECTION ENTRY
	BITB	#CS$VAS,C$SFLG+1(R3) ; VIRTUAL ARRAY STORAGE?
	BEQ	53$		; IF EQ NO
	MOV	$LBOFF,R0	; GET CURRENT TASK OFFSET
	MOV	#512./64.,R1	; GET BOUNDARY VALUE
	CALL	ADRUND		; ROUND TO 256 WORD BOUNDARY
	MOV	R0,$LBOFF	; SAVE CURRENT OFFSET
	MOV	R0,C$SBSE(R3)	; SET BASE OF SECTION
	MOV	C$SCUR(R3),R0	; GET LENGTH
	MOV	C$SBSE(R3),C$SCUR(R3) ; SET CURRENT=BASE
	MOV	#512./64.,R1	; GET BOUNDARY VALUE
	CALL	ADRUND		; ROUND LENGTH TO 256 WORD LIMIT
	MOV	R0,C$SLTH(R3)	; SET NEW LENGTH
	MOV	$LBOFF,R1	; GET PREVIOUS BASE
	CALL	ADOFST		; CALCULATE NEW STORAGE SIZE
	MOV	R0,$LBOFF	; STORE NEW ARRAY STORAGE LENGTH
	MOV	R0,$VARSZ	; COPY INDICATES SOURCE IS MAPPED ARRAY
				; DECLARATION, NOT VSECT OPTION
	JMP	90$
53$:
	BITB	#CS$LIB,C$SFLG(R3);LIB SECTION?
	BEQ	55$		;IF EQ NO
	MOV	C$SELM(R3),R1	; GET BACK POINTER TO ELEMENT DESCRIPTOR
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	MOV	R0,R4		; SAVE REAL ADDRESS
	MOV	E$LLGH(R4),R4	;GET BACK POINTER TO LIBRARY LIST ENTRY
	MOV	L$DCUR(R4),R0	;GET CURRENT BASE ADDRESS
	MOV	#2,R1		; GET BOUNDARY VALUE
	CALL	ADRUND		;ROUND VIRTUAL ADDRESS
	MOV	R0,C$SBSE(R3)	;SET BASE ADDRESS OF SECTION
	MOV	R0,C$SCUR(R3)	;SET CURRENT BASE OF SECTION
	MOV	C$SLTH(R3),R1	;GET LENGTH OF SECTION
	CALL	ADOFST		;ADD OFFSET VALUE
	MOV	R0,L$DCUR(R4)	;SET CURRENT BASE OF LIBRARY
	SUB	C$SBSE(R3),R0	;CALCULATE ACTUAL LENGTH
	MOV	R0,C$SLTH(R3)	;SET ACTUAL LENGTH
	BR	90$		;
55$:				;
	CMP	$CRVSG,$RTSEG	; AT ROOT?
	BNE	58$		; IF NE NO
	MOV	R3,R1		; GET ADDRESS OF SECTION
	MOV	#$VSCHD,R0	; GET ADDRESS OF LISTHEAD
	CALL	$SRCHR		; SEARCH FOR VIRTUAL SECTION ENTRY
	BCS	58$		; IF C/S NOT IN LIST
	MOV	12(R0),-(SP)	; SAVE PHYSICAL LENGTH
	TST	S$YM(R3)	; BLANK SECTION?
	BEQ	561$		;
	BEQ	57$		; IF EQ YES
	BISB	#CS$VSC,C$SFLG+1(R3) ; MARK SECTION AS VIRTUAL
	ADD	#6,R0		; POINT TO BASE ADDRESS
	MOV	(R0)+,C$SBSE(R3) ; SET BASE ADDRESS
	MOV	(R0),C$SLTH(R3)	; SET LENGTH
	BNE	56$		; IF NE HAVE LENGTH
	MOV	C$SCUR(R3),C$SLTH(R3) ; RESET LENGTH
56$:				;
	CLR	C$SCUR(R3)	; RESET CURRENT BASE
	MOV	C$SBSE(R3),R1	; GET BASE
	DEC	R1		; BACK OFF BASE
561$:
	MOV	C$SLTH(R3),R0	; GET LENGTH
	CALL	ADOFST		; ADD BASE TO LENGTH
57$:				;
	MOV	$LBOFF,R1	; GET CURRENT TASK OFFSET INTO PARTITION
	MOV	(SP)+,R0	; GET PHYSICAL SIZE OF SECTION
	CALL	ADOFST		; ADD SIZE
	MOV	R0,$LBOFF	; SAVE SIZE
	BR	90$		;
58$:				;
	CLR	R4
	BIT	#ID$ATA,$SWTCH	; USER D-SPACE TASK?
	BEQ	59$		; IF EQ NO
	BIT	#CS$TYP,C$SFLG(R3) ; DATA SECTION?
	BEQ	59$		; IF EQ NO
	MOV	#4,R4		; SET OFFSET FOR DATA
59$:
	ADD	#LVADR,R4	; POINT TO CURRENT VIRTUAL ADDRESS
	MOV	(R4),R0		;GET CURRENT VIRTUAL ADDRESS
	MOV	#2,R1		; GET BOUNDARY VALUE
	CALL	ADRUND		;ROUND VIRTUAL ADDRESS
	MOV	(R4),R1		;SAVE CURRENT VIRTUAL ADDRESS
	MOV	R0,(R4)		;SET NEW CURRENT VIRTUAL ADDRESS
	SUB	R1,R0		;CALCULATE NET INCREASE
	MOV	R0,R1		;SET OFFSET VALUE
	MOV	-(R4),R0	;GET CURRENT LENGTH
	CALL	ADOFST		;ADD OFFSET VALUE
	MOV	R0,-(SP)	;SAVE CURRENT LENGTH
	MOV	R3,R1		;SET ADDRESS OF SECTION ENTRY
	MOV	#$SCTHD,R0	;GET ADDRESS OF EXTEND LISTHEAD
	CALL	$SRCHR		; SEARCH EXTENSION LIST FOR SECTION
	BCS	80$		;IF CS NO FIND EM
	BITB	#CS$ALO,C$SFLG(R3);CONCATENATED SECTION?
	BNE	60$		;IF NE NO
	MOV	C$SBSE(R0),R1	;GET EXTENSION LENGTH
	MOV	C$SCUR(R3),R0	;GET CURRENT SECTION LENGTH
	CALL	ADOFST		;ADD OFFSET VALUE
	BR	70$		;
60$:	MOV	C$SBSE(R0),R0	;GET EXTENSION LENGTH
	CMP	R0,C$SCUR(R3)	;EXTENSION LENGTH LARGER?
	BLOS	80$		;IF LOS NO
70$:	MOV	R0,C$SCUR(R3)	;SET NEW CURRENT SECTION LENGTH
80$:	MOV	(SP)+,R0	;RETRIEVE CURRENT LENGTH
	MOV	C$SCUR(R3),R1	;GET LENGTH OF CONTROL SECTION
	CALL	ADOFST		;ADD OFFSET VALUE
	MOV	R0,(R4)+	;SET NEW CURRENT LENGTH
	MOV	(R4),R0		;GET CURRENT VIRTUAL ADDRESS
	MOV	R0,C$SBSE(R3)	;SET BASE ADDRESS OF SECTION
	MOV	C$SCUR(R3),R1	;GET LENGTH OF SECTION
	CALL	ADOFST		;ADD OFFSET VALUE
	MOV	(R4),C$SCUR(R3)	;SET CURRENT TO SECTION BASE ADDRESS
	MOV	R0,(R4)		;SET NEW CURRENT VIRTUAL ADDRESS
	SUB	C$SBSE(R3),R0	;CALCULATE ACTUAL LENGTH
	MOV	R0,C$SLTH(R3)	;SET SECTION LENGTH
90$:
	.IF DF D$SG4

	CALL	TCSALO		; D$SG4==0

	.ENDC
	MOV	(SP)+,R3	; RESTORE R3 AND R4
	MOV	(SP)+,R4	;
	MOV	(SP)+,R1	; RETRIEVE VIRTUAL ADDRESS OF SECTION
	CALL	$UNLPG		; UNLOCK PAGE
	JMP	10$		; GO AGAIN

;
; RELOCATE ALL CONTROL SECTIONS
;
; THIS ROUTINE IS CALLED AFTER THE ALLOCATION OF VIRTUAL AND PHYSICAL
; MEMORY TO RELOCATE ALL CONTROL SECTIONS WITHIN THE TASK IMAGE.
;

CSREL:				;
	MOV	R5,R0		; COPY ADDRESS OF SEGMENT DESCRIPTOR
	ADD	#S$GCST,R0	; POINT TO CONTROL SECTION TABLE
	MOV	#$ISED,-(SP)	; PUSH ADDRESS OF SYMBOL EDIT ROUTINE
10$:				;
	CALL	@(SP)+		; GET NEXT SYMBOL
	BCS	40$		; IF C/S NO MORE

	.IF DF D$SG8

	CALL	TCSREL		; D$SG8==0

	.ENDC

	MOV	LVADR,-(SP)	; PUSH LOCAL VIRTUAL ADDRESS
	MOV	C$SFLG(R0),R2	; COPY FLAG BYTE
	BIT	#<CS$VSC!CS$VAS*400!CS$IND!CS$LIB>,R2 ;
				; VIRTUAL, INDIRECT OR LIBRARY SECTION?
	BNE	30$		; IF NE YES
	BITB	#CS$REL,R2	; RELOCATABLE SECTION?
	BEQ	30$		; IF EQ NO
	BITB	#CS$RES,C$SFLG+1(R0) ; TASK-RESIDENT SECTION?
	BNE	30$		; IF NE YES
15$:				;
	BIT	#SE$QA,$SWTCH	; SEQUENCE ALLOCATION?
	BNE	20$		; IF NE YES
	BIT	#SE$GA,$SWOVR	; SEGREGATION RO AND RW PSECTS?
	BNE	20$		; IF NE NO
;+
; If we get here, then the user has overridden the /-SG switch with either
; /SG or /MU (if he's building a task for M+). We still don't know if the
; task is user I/D or conventional, so we will initially assume that it's
; going to be conventional.
;-
	BITB	#CS$ACC,R2	; READ-ONLY ACCESS?
	BEQ	20$		; IF EQ NO
	MOV	S$GROB(R5),(SP)	; GET READ-ONLY RELOCATION BIAS
	BIT	#ID$ATA,$SWTCH	; USER D-SPACE TASK?
	BEQ	25$		; IF EQ NO
	BIT	#CS$TYP,R2	; DATA SECTION?
	BEQ	25$		; IF EQ NO
;+
; We are processing an I/D task and need to relocate the data sections.
; If we previously detected an I-section, the section will be relocated
; by the code at 25$. We also must make note that if PASS is non-zero, we've
; already relocated the I-section since CSREL is called from PHALO twice
; if we're building an I/D task.
;-
	TST	PASS		; WE DOING I- OR D-SPACE
	BEQ	30$		; IF EQ, NO...I-SPACE. DEFER D-SPACE
				; PROCESSING 'TILL NEXT PASS.
	MOV	S$GODB(R5),(SP)	; GET R/O DATA BASE VIRTUAL ADDRESS
	ADD	(SP),C$SBSE(R0)	; SET BASE FOR D-SPACE
	ADD	(SP),C$SCUR(R0)	; AS WELL AS CURRENT BASE FOR D-SPACE
	CALL	$WRMPG		; WRITE-MARK THE PAGE

	.IF DF D$SG3

	CALL	TCSREL		; D$SG3==0

	.ENDC

	BR	30$
20$:
;+
; At this point, there can only be two possibilities: Either we are
; building a conventional task with /-SG in effect, or we could be building
; an I/D task with /-SG in effect. Basically, we don't care if the sections
; are Read/Write or Read-only since we're not going to segregate them.
;-
	BIT	#ID$ATA,$SWTCH	; USER D-SPACE TASK?
	BEQ	25$		; IF EQ NO
	BIT	#CS$TYP,R2	; DATA P-SECT?
	BEQ	25$		; IF EQ NO
	TST	PASS		; WE DOING I- OR D-SPACE
	BEQ	30$		; IF EQ, NO...I-SPACE.  DEFER D-SPACE
				; PROCESSING 'TILL NEXT PASS.
	MOV	LVDADR,(SP)	; IF NE, NO...USE R/W D-SPACE VIRTUAL ADDRESS
	ADD	(SP),C$SBSE(R0)	; SET BASE FOR D-SPACE
	ADD	(SP),C$SCUR(R0)	; AS WELL AS CURRENT BASE FOR D-SPACE
	CALL	$WRMPG		; WRITE-MARK THE PAGE

	.IF DF D$SG3

	CALL	TCSREL		; D$SG3==0

	.ENDC

	BR	30$
25$:
	TST	PASS		; DOING D-SPACE OR I-SPACE??
	BNE	30$		; IF NE, WE'VE ALREADY RELOCATED THE I-SECTIONS
	ADD	(SP),C$SBSE(R0)	; SET BASE
	ADD	(SP),C$SCUR(R0)	; SET CURRENT BASE
	CALL	$WRMPG		; WRITE-MARK PAGE

	.IF DF D$SG3

	CALL	TCSREL		; D$SG3==0

	.ENDC
30$:				;
	INC	(SP)+		; CLEAN STACK
	BR	10$		; GO AGAIN
40$:				;
	RETURN			;



	.IF DF D$SG3!D$SG8
;
; TRACE THE EXECUTION OF SUBROUTINE 'CSREL'
;
TCSREL:				; SHOW THE CONTROL SECTION DATA
	MOV	C$SLGS(R0),-(SP)
	MOV	C$SCUR(R0),-(SP)
	MOV	C$SLTH(R0),-(SP)
	MOV	C$SBSE(R0),-(SP)
	MOV	C$SFLG(R0),-(SP)
	MOV	C$SNME+2(R0),-(SP)
	MOV	C$SNME(R0),-(SP)
	MOV	R4,-(SP)	; INCLUDE THE RO/RW BIAS VALUE
	MOV	#$CSREL,-(SP)	; INCLUDE THE FORMAT STRING
	MOV	$PHASE,$DVDEB
	CALL	$DVDBP
	ADD	#2*9.,SP	; CLEAN UP THE STACK
	CLR	$DVDEB
	RETURN

	.ENDC

	.IF DF D$SG4!D$SG9

;
; TRACE THE EXECUTION OF SUBROUTINE 'CSALO'
;
TCSALO:				; SHOW THE CONTROL SECTION DATA
	MOV	C$SLGS(R3),-(SP)
	MOV	C$SCUR(R3),-(SP)
	MOV	C$SLTH(R3),-(SP)
	MOV	C$SBSE(R3),-(SP)
	MOV	C$SFLG(R3),-(SP)
	MOV	C$SNME+2(R3),-(SP)
	MOV	C$SNME(R3),-(SP)
	MOV	18.(SP),-(SP)	; INCLUDE THE RO/RW BIAS VALUE
	MOV	#$CSALO,-(SP)	; INCLUDE THE FORMAT STRING
	MOV	$PHASE,$DVDEB
	CALL	$DVDBP
	ADD	#2*9.,SP	; CLEAN UP THE STACK
	CLR	$DVDEB
	RETURN

	.ENDC

;
; SUBROUTINE TO ADD AN OFFSET VALUE TO A BASE ADDRESS AND CHECK FOR
; ADDRESS OVERFLOW. IF OVERFLOW IS DETECTED, THEN THE ORIGINAL BASE
; ADDRESS IS RETURNED TO THE CALLER. ELSE THE UPDATED ADDRESS IS RE-
; TURNED TO THE CALLER.
;

ADOFST:	MOV	R0,R2		;SAVE BASE ADDRESS
	ADD	R1,R0		;ADD IN OFFSET VALUE
	BEQ	10$		; IF EQ, THEN DON'T CHECK FOR OVERFLOW
	BCS	OVRFLW		;IF CS OVERFLOW
10$:
	RETURN			;

;
; SUBROUTINE TO ROUND UP AN ADDRESS TO AN ADDRESS BOUNDRY AND CHECK
; FOR ADDRESS OVERFLOW. IF OVERFLOW IS DETECTED, THEN THE ORIGINAL
; ADDRESS IS RETURNED TO THE CALLER. ELSE THE ROUNDED ADDRESS IS RE-
; TURNED TO THE CALLER.
;

ADRUND:				;
	CALL	ROUND		; ROUND TO SPECIFIED ADDRESS LIMIT
	BCS	OVRFLW		; IF C/S REPORT OVERFLOW
	RETURN			;

;
; ROUND TO SPECIFIED ADDRESS LIMIT, RETURN C/S ON OVERFLOW
;

ROUND:				;
	MOV	R0,R2		; SAVE BASE ADDRESS
	DEC	R1		;BACK OFF BOUNDRY VALUE BY ONE
	ADD	R1,R0		;ADD BOUNDRY VALUE
	BCC	10$		; IF C/C OK
	BIC	R1,R1		; CLEAR RESULT
	BR	20$		; EXIT
10$:				;
	INC	R1		;ADJUST BACK TO BOUNDRY VALUE
	MOV	R1,-(SP)	;SAVE BOUNDRY VALUE


	.IF	NDF	V1145

	CALL	$DIV		;

	.ENDC


	.IF	DF	V1145

	MOV	R0,R1		;SET LOW PART OF DIVIDEND
	CLR	R0		;CLEAR HIGH PART OF DIVIDEND
	DIV	(SP),R0		;DIVIDE EM UP

	.ENDC


	MOV	(SP)+,R1	;RETRIEVE BOUNDRY VALUE


	.IF	NDF	V1145

	CALL	$MUL		;

	.ENDC


	.IF	DF	V1145

	MUL	R1,R0		;

	.ENDC


	TST	R0		; OVERFLOW?
	BEQ	20$		; IF EQ NO
	SEC			; SET CARRY
20$:				;
	MOV	R1,R0		;SET ROUNDED ADDRESS
	RETURN			;

;
; CONVERT LENGTH IN R1 TO 32W BLOCKS
;

BLOCKS:				;
	ADD	#77,R1		; ROUND TO NEAREST 32W LIMIT
	ROR	R1		; SAVE CARRY, DIVIDE BY 64
	CLC			; ...
	ROR	R1		; ...
	ASR	R1		; ...
	ASR	R1		; ...
	ASR	R1		; ...
	ASR	R1		; ...
	RETURN			;

;
; ADDRESS OVERFLOW DETECTED
;

OVRFLW:	MOV	R2,-(SP)	;SAVE BASE ADDRESS
	MOV	R5,R2		;GET ADDRESS OF CURRENT SEGMENT
	ADD	#S$GNME,R2	;POINT TO SEGMENT NAME
	MOV	(PC)+,R1	;GET ERROR/SEVERITY
	.BYTE	E$R23,S$V0	;DIAGNOSTIC
	CALL	$ERMSG		;OUTPUT ERROR MESSAGE
	BIC	#<ST$BF!TS$KF>,$SWTCH ; NO SYMBOL TABLE OR TASK FILES
	MOV	(SP)+,R0	; GET BASE ADDRESS
	RETURN			;



;
;
; ALOAPR - SEARCHES APR'S FROM TOP DOWN TO FIND FREE SPACE
;	   FOR SEGMENT
;
; INPUTS:
;	  R0 - SIZE OF SEGMENT
;
; OUTPUTS:
;	  R0 - APR ALLOCATION
;	  R1 - BASE VIRTUAL ADDRESS
;
;
ALOAPR:
	TST	R0		; IS THIS A "NULL" SEGMENT?
	BEQ	1$		; IF EQ, YES - USE LENGTH AS IS
	DEC	R0		; DECREMENT LENGTH
1$:
	CALL	CVAPR		; CONVERT TO APR INDEX
	MOV	R0,R2		; SAVE INDEX
	MOVB	APRMK(R0),R0	; GET APR MASK
	CLR	R1
5$:
	DEC	R2
	BLT	10$
	SUB	#20000,R1	;
	BR	5$
10$:
	SUB	#20000,R1	; DECREMENT VIRTUAL ADDRESS
	BITB	R0,$APRMP(R4)	; ROOM AT THIS ADDRESS?
	BEQ	20$		; IF EQ YES
	CLC			; CLEAR CARRY
	RORB	R0		; ROTATE APR MASK
	BCC	10$		; IF C/C TEST AGAIN
	MOV	#<S$V2*400!E$R22>,R1 ; FATAL ERROR
	CALL	$ERMSG		; NO RETURN
20$:
	BISB	R0,$APRMP(R4)	; RECORD APR ALLOCATION
	RETURN


;
; CVAPR - CONVERT TO APR INDEX
;
; INPUT:
;	R0 - VIRTUAL ADDRESS
; OUTPUT:
;	R0 - APR INDEX
;
CVAPR:
	BIC	#17777,R0	; CLEAR ALL BUT DISPLACEMENT
	ASL	R0		; GET BIT 15 INTO CARRY
	ROL	R0		; CONVERT TO INDEX
	ROL	R0		;
	ROL	R0		;
	RETURN

;
; RECOG - TEST FOR MULTIUSER TASK
;

RECOG:
	SEC			; ASSUME FAILURE
	BIT	#MP$SY,$SWTCH	; MPPPED TARGET?
	BEQ	20$		; IF EQ NO
	BIT	#SW$MU,TSKSW	; RECOGNIZING R/O PROTECTION?
	BEQ	20$		; IF EQ NO
	BIT	#SW$NH,TSKSW	; TASK HAVE HEADER?
	BNE	20$		; IF NE NO
	CLC			; CLEAR THE CARRY FOR SUCCESS
20$:
	RETURN
	.END
