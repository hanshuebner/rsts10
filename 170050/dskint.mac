TITLE	ONLDSK,<RSTS/E ONLINE DSKINT>,0K,29-JUN-92,TWH/GPK/TWH/KFM/DBM/SHL/FRL/PJH

;
;		COPYRIGHT (c) 1974, 1992 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR ONLDSI

;+
;
;  000  DRP  31-AUG-82	CREATION - COPIED FROM V7.0-07
;  001	GPK  20-Oct-82	Updates for new file structure, bugfixes
;  002	TWH  01-NOV-82  ADD /DATE,/PUBLIC,/PRIVATE, AND /WRITE
;  003	TWH  25-FEB-83  FIX MSCP DRIVER BUG
;  004	TWH  24-OCT-83  ADD /ERASE SUPPORT
;  005	KFM  05-JAN-84	UPDATE FOR 8-BIT COMPATIBILITY
;  006	DBM  20-JAN-84	ADD VT200 SUPPORT (NO <LF> KEY)
;  007  SHL  19-JUL-84  CHANGE ERROR MESSAGE FOR MOUNTED DISKS
;  008  FRL  11-Oct-84  Allow ^ response to go back a question
;  009  FRL  06-Feb-85  Exit with status
;  010  FRL  17-Jul-86	Add /NEW_FILES
;	
;			[RSTS V9.4]
;  011	PJH  09-Feb-87	Add large disk support (No sign extends in calcs)
;  012  PJH  02-Mar-87  Fake GPK disks $MID, UNTS
;  013  BGN  12-Mar-87	DU unit numbers up to 15
;  014  JJT  13-Mar-87	Fix bug with GPK code
;  015	PJH  11-May-87	Do privilege checking for online version at BLDTBL
;
;			[RSTS V9.5]
;  016	PJH  09-Jul-87	Finish large disk support
;
;			[RSTS V9.6]
;  017	PJH  29-Dec-87	Remove BPT left in TYPER:
;  018	PJH  23-Feb-88	Change to only 1 open channel on disk at a time
;
;			[RSTS V10.0]
;  019	PJH  12-Jul-88	Fix DCS 64 disk problem for default PCS.
;
;			[RSTS V10.1]
;  020	DRP  26-Jun-92	Initialize PACKST with UC.NEW.
;-

.SBTTL	DEFINE PSECTS, CONSTANTS, AND MACROS
	DEFORG	ONLDSI
	DEFORG	ONLINE
	DEFORG	ONLTXT
	DEFORG	ONLCTL
	ORG	ONLDSI


;L$$IST	= 1		;LIST ALL PREFIX FILES

.DSABL	GBL

	EX$WAR == 0		;Warning status code			;009
	EX$SUC == 1		;Success status code			;009
	EX$ERR == 2		;Error status code			;009
	.MCALL	EXST$S		;Exit with status			;009
	.MCALL	SVTK$S		; RSX TRAP HANDLER
	.MCALL	CALBX		;INCLUDE THE CALL SUPPORT
	.MCALL	$CUI		;INCLUDE CUI
	$CUI			;
		
.MACRO	I.MESS
	TMPORG	ONLTXT
.NLIST	BEX
.ENDM

; COMMON ASCII DEFINITIONS

.EQUATE	BELL	, 7
.EQUATE	TAB	, 11
.EQUATE	LF	, 12
.EQUATE	VT	, 13
.EQUATE	FF	, 14
.EQUATE	CR	, 15
.EQUATE	ESCAPE	, 33
.EQUATE	SPACE	, 40

.SBTTL	ROOTBL:	DSKSZL, DSKSZM, DSKDCS: FIXED POINTERS
; POINTERS AND OTHER FIXED DATA FOR DISK CONTROL

	TMPORG	ONLCTL

DSKSZL::$DISKS			;DISK SIZE TABLE
	.WORD	DSKLSB		;POINTER TO LSB
.ENDM

DSKSZM::$DISKS			;DISK SIZE TABLE
	.WORD	DSKMSB		;POINTER TO MSB
.ENDM

DSKDCS::$DISKS			;DEVICE CLUSTER TABLE POINTERS [FIXED]
	.WORD	DISKDC		;NAME DISK DCS TABLE
.ENDM

DSKLSB::.BLKW0	16.,0		;LSB OF DISK
DSKMSB::.BLKW0	16.,0		;MSB OF DISK
DISKDC::.BLKW0	16.,0		;DCS TABLE
DCLQUE::.WORD	0
DCLENT::.WORD	0
DCLPCS::.BLKW	10.
DCLIND::.BLKW	34.
DCLPAT::.BLKW	4
DCLMFD::.BLKW	10.
EXFLAG:	.WORD	0
STATUS::.WORD	EX$ERR		;Assume error				;009

.SBTTL	DEFINING CSECT'S

BITBYT::.BYTE	1,2,4,10,20,40,100,200,0,0
	.WORD	0

;********* IMPORTANT!!!!!!! *************
;
; THE FOLLOWING IS THE FIBUF CSECT BUT IT 
; MUST RESIDE IN THE BLANK CSECT SO THAT
; IT LIES ON A 1000 BYTE BOUNDARY!!!
;
;****************************************

	.CSECT	;FIBUF

FIBUF::	.BLKB	760
FIBMAP::.BLKW
FIBENT::.BLKW	7
FIBEND::

	DEFORG	SATBUF

SATBUF::.BLKB	1000*16.

	DEFORG	S2TBUF

S2TBUF::.BLKB	1000*16.


	TMPORG	ONLCTL

ERFTBL::.WORD	0
	.WORD	0
	.WORD	0
	.WORD	0
	.WORD	0
	.WORD	0
	.WORD	ERFTRP
	.WORD	0

.SBTTL		FIP CONTROL DSQ, FILE I/O DSQ

I.DSQ::	.WORD	0	;LINK WORD & CSR CONTENTS FOR INIT ERROR CHECKS
	.BYTE	0	;+DSQJOB (IN INIT, DISK INDEX)
	.BYTE	0	;+DSQERR
	.WORD	0	;+DSQL3Q
	.BYTE	0	;+DSQUNT
	.BYTE	0	;+DSQFBM - EXTENDED DISK ADDRESS
	.WORD	0	;+DSQFBL - DISK ADDRESS
	.BYTE	0	;+DSQRFN - RH11 FUNCTION CODE
	.BYTE	0	;+DSQMAM - EXTENDED MEMEORY ADDR. R.H.JUSTIFIED
	.WORD	0	;+DSQMAL - CORE MEMORY ADDRESS
	.WORD	256.	;+DSQCNT - +WORD COUNT OF TRANSFER
	.BYTE	0	;+DSQFUN - FUNCTION
	.BYTE	0	;+DSQFAR - FAIRNESS COUNT
	.WORD	0	;+DSQMSC -
	.WORD	0	;+DSQTOT -
	.WORD	0	;+DSQPDA - PHYSICAL DISK ADDRESS
	.WORD	0	;+DSQOPT - OPTIMIZATION WORD
	.BYTE	0	;+DSQOUN - UNIT NUMBER * 2
	.BYTE	0	;+DSQSAV - FUNCTION SAVE
	.WORD	0	;+DSQPTO -
	.BYTE	0	;+DSQCTO -
	.BYTE	0	;+DSQPUN - PHYSICAL UNIT

IDENT:	.ASCII	<177><200>/DSKINT V/
	.WORD	SYSVEL
	.WORD	SYSVEE
	.BYTE	'-
BSLVL:	.BYTE	0
	.WORD	$$$VER
	.ASCIZ	/ /

	.EVEN
	UNORG




.SBTTL	MAIN DRIVER FOR DSKINT

	ORG	ONLDSI
.ENABL	LSB

ONLDSK::CLR	ENT.TY		;ASSUME NOT DCL
	MOVB	#-2,NRETRY	;FAKE NUMBER OF RETRYS
	SVTK$S	#ERFTBL,#8.	;SET UP TRAP HANDLER TABLE
	BIT	#16384.,@#30	;IS THIS A DCL ENTRY?
	BNE	20$		;YEP
	MOV	#BSLVL,R1	;POINT TO WHERE BASELEVEL # SHOULD GO
	MOV	#BSLVL+1,R2	;AND WHERE WE'RE MOVING FROM
	MOVB	(R2)+,(R1)+	;MOVE A BYTE
	MOVB	(R2)+,(R1)+	;MOVE A BYTE
	MOVB	(R2)+,(R1)+	;MOVE A BYTE
	CALLX	MESSAGE,R5,IDENT	;PRINT DSKINT VERSION NUMBER
	CLR	R0		;R0 = 0 ERROR MESSAGE NUMBER
	CALL	ERRPRT		;GO PRINT IT	
	MESSAGE	<<177><200>>	;PRINT A <CR><LF>
	JMP	BLDTBL		;JUMP AROUND DCL INITIALIZATION


.SBTTL	PARSE DEVICE AND UNIT

20$:	MOV	#16.,ENT.TY	;YEP-SET ENT.TY
	MOV	ENT.TY,DCLENT	;AND DCLENT
	CALBX	U.INI <#U.CMN,#ENT.TY>	;INITIALIZE CUI
	CALBX	U.DIA		;READ THE COMMAND LINE
	TST	U.CMN+U.STAT	;IS IT THERE?
	BEQ	30$		;YEP
	JMP	DSKABT		;ABORT.

30$:	CALBX	FET.P <#DEV.P>	;FETCH THE FIRST PARAMETER-DISK NAME      **DEVICE**
	SUB	#8.,SP		;ALLOCATE SPACE ON THE STACK
	MOV	SP,R1		;GET SP IN R1
	MOV	#U.CMN+U.STR,R2	;POINT TO DEVICE NAME
	MOV	U.CMN+U.LEN,R5	;GET LENGTH OF STRING
	CMPB	R5,#7.		;MORE THAN 7 CHARS?
	BLT	40$		;NO
	MOV	#7.,R5		;TRIM IT TO 7
40$:	MOV	R5,R4		;COPY LENGTH OF STRING
50$:	MOVB	(R2)+,(R1)+	;MOVE DEVICE NAME ONTO STACK
	SOB	R5,50$		;CHAR BY CHAR
	MOVB	#':,(R1)+	;ADD COLON TO END
	INC 	R4		;INCREMENT NUMBER OF CHARS FOR COLON
	MOV	SP,R1		;POINT TO THE BUFFER ON THE STACK
	CALBX	U$FSS <R4,R1>	;DO A FILE NAME STRING SCAN
	ADD	#8.,SP		;RESTORE THE STACK
	MOV	FIRQB+FQDEV,DNAME	;GET THE DEVICE NAME
	MOV	#FIRQB+FQDEVN,R1;GET THE UNIT NUMBER ADDRESS		**UNIT**
	MOVB	(R1)+,R0	;GET THE UNIT NUMBER
	TSTB	(R1)		;IS THE UNIT NUMBER FOR REAL?
	BNE	60$		;YEP
	MESSAGE	<"?Unit number must be specified"<200>>
	JMP	DSKABT		;DIE


	GLOBAL	<ENT.TY,U.CMN,U.PRES,U.STAT,U.NO,U.LEN,U.STR>
	GLOBAL	<DEV.P,DNAME,DUNT,JFPRIV,KEY>

.SBTTL	PARSE PACKID, PCS, AND INDEX

60$:	MOVB	R0,DUNT		;MOVE UNIT NUMBER INTO DUNT
	CALBX	FET.P <#LBL.P>	;GET THE PACKID				**PACKID**
	CALBX	U$FSS  <U.CMN+U.LEN,#U.CMN+U.STR>  ;DO THE FSS
	MOV	#FIRQB+FQNAM1,R0;GET THE STRING ADDRESS
	MOV	#PACKID,R1	;AND THE ADDRESS TO MOVE TO
	MOV	(R0)+,(R1)+	;MOVE THE FIRST WORD
	MOV	(R0)+,(R1)+	;AND THE SECOND WORD
	CLR	DCLPCS		;ASSUME NO /PCS
	CALBX	FET.CQ	<#CLS.Q>;SEARCH FOR THE CLUSTERSIZE		**PCS**
	TST	U.CMN+U.PRES	;IS THERE A CLUSTERSIZE?
	BEQ	80$		;NO-DEFAULT IS DCS
	CALBX	FET.A		;FETCH THE ARGUMENT
	MOV	#DCLPCS,R1	;BUFFER ADDRESS INTO R1
	MOV	#U.CMN+U.STR,R2	;GET STRING ADDRESS INTO R2
	MOV	U.CMN+U.LEN,R5	;LENGTH INTO R5
	CMP	#9.,R5		;ARE THERE MORE THAN 9 CHARS?
	BGE	70$		;NO
	MOV	#9.,R5		;YES-SO JUST TAKE 9
70$:	MOVB	(R2)+,(R1)+	;COPY ON TO STACK
	SOB	R5,70$		;ALL OF IT
	CLRB	(R1)+		;SET A FAKE END OF LINE
80$:	CLR	DCLIND		;ASSUME USING MIDDLE OF DISK		**INDEX**
	CALBX	FET.CQ <#IND.Q>	;IS /INDEX THERE?
	TST	U.CMN+U.PRES	;
	BEQ	100$		;NO-USE MIDDLE OF DISK
	CALBX	FET.KA <#MID.K> ;IS IT THE MIDDLE
	TST	U.CMN+U.PRES	;
	BNE	100$		;YEP
	MOV	#"10,DCLIND	;ASSUME BEGINNING
	CALBX	FET.KA <#BEG.K> ;IS IT THERE?
	TST	U.CMN+U.PRES	;
	BNE	100$		;YEP

	GLOBAL	<CLS.Q,LBL.P>

.SBTTL	PARSE MFD_CLUSTER_SIZE, PUB/PRI, DLW

	CALBX	FET.A		;GET THE ADDRESS OF ARGUMENT
	MOV	#U.CMN+U.STR,R1	;INTO R1
	MOV	U.CMN+U.LEN,R5	;GET STRING LENGTH
	MOV	#DCLIND,R2	;GET BUFFER ADDRESS
	CMP	#33.,R5		;ARE THERE MORE THAN 33 CHARS?
	BGE	90$		;NO
	MOV	#33.,R5		;JUST USE 33 CHARS
90$:	MOVB	(R1)+,(R2)+	;COPY IT
	SOB	R5,90$		;ALL OF IT
	CLRB	(R2)+		;SET FAKE END OF LINE
100$:	CLRB	P.EXT		;ASSUME NO EXTENDING			**MFDCLUSTERSIZE**
	CALBX	FET.CQ <#MFD.Q>	;IS /MFDCLUSTERSIZE THERE?
	TST	U.CMN+U.PRES	;
	BEQ	120$		;NO
	CALBX	FET.A		;FETCH THE ARGUMENT
	MOV	#DCLMFD,R1	;BUFFER ADDRESS INTO R1
	MOV	#U.CMN+U.STR,R2	;GET STRING ADDRESS INTO R2
	MOV	U.CMN+U.LEN,R5	;LENGTH INTO R5
	CMP	#9.,R5		;ARE THERE MORE THAN 9 CHARS?
	BGE	110$		;NO
	MOV	#9.,R5		;YES-SO JUST TAKE 9
110$:	MOVB	(R2)+,(R1)+	;COPY ON TO STACK
	SOB	R5,110$		;ALL OF IT
	CLRB	(R1)+		;SET A FAKE END OF LINE
120$:	MOV	#UC.PRI!UC.NEW,PACKST ;ASSUME PRIVATE			**PUB/PRI** ;020
	CALBX	FET.CQ <#PUB.Q>	;IS THERE A /PUBLIC?
	TST	U.CMN+U.PRES	;
	BEQ	130$		;NO
	MOV	#UC.NEW,PACKST	;PUBLIC STATUS ON DISK			;020
130$:	BIS	#UC.DLW,PACKST	;ASSUME DATE-LAST-WRITE			**DLW**
	CALBX	FET.CQ <#DAT.Q> ;IS THERE A /DATE?
	TST	U.CMN+U.PRES	;
	BEQ	140$		;NO

	GLOBAL	<MFD.Q,IND.Q,MID.K,BEG.K>
	GLOBAL	<CLRXRB,CLRFQB,PACKID,P.EXT>

.SBTTL	PARSE NFF, RETAIN, AND PATTERNS

	CALBX	FET.KA <#ACC.K> ;IS IT =ACCESS
	TST	U.CMN+U.PRES	;
	BEQ	140$		;NO
	BIC	#UC.DLW,PACKST	;YES-CLEAR BIT
140$:	BIC	#UC.TOP,PACKST	;ASSUME NOT NFF				**NFF**
	CALBX	FET.CQ <#NFF.Q>	;Fetch /NEW_FILES			;010
	TST	U.CMN+U.PRES	;Is it there?				;010
	BEQ	145$		;No, use default			;010
	CALBX	FET.KA <#FST.K> ;Fetch =FIRST				;010
	TST	U.CMN+U.PRES	;Is it there?				;010
	BEQ	145$		;No, must be =LAST			;010
	BIS	#UC.TOP,PACKST	;Yes, set NFF				;010
145$:	MOV	#-1,USEBB	;ASSUME /RETAIN				**RETAIN**
	CALBX	FET.CQ <#RET.Q>	;IS /RETAIN THERE?
	TST	U.CMN+U.PRES	;IS IT THERE?
	BEQ	150$		;NOPE
	TST	U.CMN+U.NO	; OR IS IT /NORETAIN?
	BEQ	150$		;  /RETAIN 
	CLR	USEBB		;/NORETAIN
150$:	MOVB	#3,DCLPAT	;DEFAULT IS 3				**PATTERNS**
	CALBX	FET.CQ <#EXE.Q>	;IS THERE A /EXERCISE?
	TST	U.CMN+U.PRES	;
	BEQ	180$		;NOPE
	MOV	#1,EXFLAG	;FLAG THAT HE SPECIFIED /EX		
	MOVB	#0,DCLPAT	;MAKE NOEX THE DEFAULT
	TST	U.CMN+U.NO	;IS IT /NOEX?
	BNE	180$		;YEP
	MOVB	#3,DCLPAT	;IF NO ARG, EX=3
	CALBX	FET.KA <#FUL.K> ;IS IT =FULL?
	TST	U.CMN+U.PRES	;
	BNE	180$		;YEP
	CALBX	FET.A		;GET THE ARGUMENT
	TST 	U.CMN+U.PRES	;IS IT THERE?
	BEQ	180$		;NOPE
	MOV	#DCLPAT,R1	;COPY BUFFER ADDRESS INTO R1
	MOV	#U.CMN+U.STR,R2	;GET STRING ADDRESS INTO R2
	MOV	U.CMN+U.LEN,R5	;LENGTH INTO R5
	CMP	#2,R5		;ARE  THERE MORE THAN 2 CHARS?
	BGE	160$		;NO
	MOV	#2,R5		;JUST USE 2
160$:	MOVB	(R2)+,(R1)+	;COPY TO BUFFER
	SOB	R5,160$		;ALL OF IT
	CLRB	(R1)+		;SET A FAKE END OF LINE
	MOV	#DCLPAT,R1	;R1 -> STRING TO TRANSLATE		;005

	GLOBAL	<EXE.Q,RET.Q,QUE.Q,FUL.K,ERA.Q,NFF.Q,FST.K>		;010
	GLOBAL	<PUB.Q,UC.DLW,UC.TOP,DAT.Q,ACC.K,WRI.Q>
	GLOBAL	<PACKST,UC.PRI,USEBB>

.SBTTL	PARSE QUOTA, QUERY, ERASE, WRITE

	CALL	DECINP		;TRANSLATE IT 				;005
	BEQ	190$		;PROPER DECIMAL NUMBER			;005
170$:	MESSAGE	<"?Invalid argument on /EXERCISE"<200>>			;005
	JMP	DSKABT		;DIE					;005

180$:	MOV	DCLPAT,R0	;GET THE NUMBER OF PATTERNS		;005
190$:	CMP	R0,#3		;IS IT GREATER THAN 3?			;005
	BHI	170$		;YEP					;005
	MOV	R0,WRONLY	;SET WRONLY=0 IF WRITE CHECK SUPPRESSED	;005
	BNE	200$		;DOING REAL PATTERN CHECKS		;005
	INC	R0		;FAKE A ONE PATTERN			;005
200$:	MOV	R0,NSPATS	;SET NUMBER OF SYSTEM DEFINED PATTERNS	;005
	CLR	NUPATS		;NO USER PATTERNS			;005
	CLR	SECRTY		;ASSUME WE ERASE THE DISK		;004
	CALBX	FET.CQ <#ERA.Q>	;IS /ERASE THERE?			;004
	TST	U.CMN+U.PRES	;
	BEQ	220$		;NOPE
	TST	U.CMN+U.NO	;OR IS IT /NOERASE			;004
	BEQ	220$		;/ERASE					;004
	TST	EXFLAG		;DID HE SPECIFY /EX			;005
	BEQ	210$		;NOPE					;005
	TST	WRONLY		;BUT DID HE SAY TO EXERCISE?		;005
	BEQ	210$		;NOPE					;005
	MESSAGE	<"?Cannot exercise disk with /NOERASE"<200>>		;005
	JMP	DSKABT		;DIE					;005

210$:	MOV	#-1,SECRTY	;/NOERASE - DON'T TOUCH THE DISK	;004
220$:	CALBX	FET.CQ <#WRI.Q> ;IS /WRITE THERE?		**WRITE**
	TST	U.CMN+U.PRES	;
	BEQ	230$		;NOPE
	TST	U.CMN+U.NO	; OR IS IT /NOWRITE?
	BEQ	230$		;/WRITE 
	BIS	#UC.RO,PACKST	;/NOWRITE
230$:	MOV	#1,DCLQUE	;ASSUME /QUERY			**QUERY**
	CALBX	FET.CQ <#QUE.Q> ;IS /QUERY THERE?
	TST	U.CMN+U.PRES	;
	BEQ	BLDTBL		;NOPE
	TST	U.CMN+U.NO	; OR IS IT /NOQUERY?
	BEQ	BLDTBL		; YEP
	CLR	DCLQUE		;/NOQUERY

	GLOBAL	<PACKST,UC.PRI,USEBB>
	GLOBAL	<UC.RO,SECRTY,WRONLY,NSPATS,NUPATS>

.DSABL	LSB

.ENABL	LSB
.SBTTL	FIND SYSTEM DISK AND FILL IN TABLES			

;015+
;	DSKINT.TSK is now stored in $ with a <232> protection code.
;	At the outset, we now check for WRTNFS and RDNFS privileges, else we 
;	abort.	We are checking here at BLDTBL so the identification line can
;	print if explicitly run.
;015-

BLDTBL:	CALLX	CLRFQB			;Clear Firqb			;015
	CALLX	CLRXRB			;.....	and XRB			;015
	MOV	#JFSYS,XRB+XRLEN	;drop temporary privs (temp)	;015
	.CLEAR				;...do it			;015
	MOVB	#UU.CHK,FIRQB+FQFUN 	;check for privs WRTNFS		;015
	MOVB	#1,FIRQB+FQFIL		;Subfunction = 1 (Check privs)	;015
	MOV	#FIRQB+FQNAM1,R0	;Setup address for priv write	;015
	MOV	#"WR,(R0)+		;set up for checking for WRTNFS	;015
	MOV	#"TN,(R0)+		;ditto				;015
	MOV	#"FS,(R0)		;ditto				;015
	.UUO				;see if they have it		;015
	TSTB	FIRQB+FQERNO		;lets check them out		;015
	BNE	3$			;no, so error out		;015
	MOVB	#UU.CHK,FIRQB+FQFUN 	;check for privs RDNFS		;015
	MOVB	#1,FIRQB+FQFIL		;Subfunction = 1 (Check privs)	;015
	MOV	#FIRQB+FQNAM1,R0	;Setup address for priv write	;015
	MOV	#"RD,(R0)+		;set up for checking for WRTNFS	;015
	MOV	#"NF,(R0)+		;ditto				;015
	CLR	(R0)			;set nulls here			;015
	MOVB	#'S,(R0)		;and place last character	;015
	.UUO				;see if they have it		;015
	TSTB	FIRQB+FQERNO		;lets check them out		;015
	BEQ	4$			;ok, so let them proceed	;015

3$:	MESSAGE	<"?WRTNFS and RDNFS privileges required"<200>>		;015
	JMP	DSKABT			;and go away			;015

4$:	MOV	#JFSYS,XRB+XRLEN	;regain privileges		;015
	.SET				;...do it			;015
	CALLX	CLRFQB			;clear FIRQB and XRB  again	;015
	CALLX	CLRXRB			;clear FIRQB and XRB  again	;015
	MOVB	#LOKFQ,FIRQB+FQFUN ;PREPARE FOR LOOKUP OF SATT.SYS
	MOV	#-1.,FIRQB+4	;NOT WILDCARD LOOKUP
	MOV	#0*256.+1,FIRQB+FQPPN ;[0,1]
	MOV	#^RSAT,FIRQB+FQNAM1 ;SATT.SYS
	MOV	#^RT  ,FIRQB+FQNAM1+2
	MOV	#^RSYS,FIRQB+FQEXT
	CALFIP			;DO THIS TO FIND SYSTEM DISK NAME. UGH.
	TSTB	FIRQB		;DID WE ERROR?
	BEQ	5$		;NOPE
	MOV	#PRVIOL,R0	;YEP - SAY PROTECTION VIOLATION 
	CALL	ERRPRT		;PRINT THE ERROR
	JMP	DSKABT		;DIE

5$:	MOV	FIRQB+FQDEV,SYSNAM ;SAVE PHYSICAL NAME OF SYSTEM DISK
	MOVB	FIRQB+FQDEVN,R2	;GET UNIT NUMBER OF SYSTEM DISK
	MOV	R2,SYSUNT	;SAVE IT
	MOV	R2,SYSUSV	;AND AGAIN
	MOVB	R2,SYSPHU+1	;AND AGAIN
	ASL	R2		;MAKE IT UNIT*2
	MOVB	R2,SYSPHU	;AND SAVE THAT, AS WELL
10$:	MOV	SYSNAM,R2	;CALCULATE SYSNDX
	MOV	#DSKNAM,R3	;GET DISK NAME TABLE
20$:	CMP	R2,(R3)+	;SAME NAME?
	BEQ	30$		;YUP
	TST	(R3)		;END OF LIST?
	BNE	20$		;NOPE
	MESSAG	<"?Unknown disk type ">					;009
	CALL	TYPE2		;PRINT DEVICE NAME
	JMP	DSKABT

30$:	SUB	#DSKNAM+2,R3	;SET R3 TO DISK INDEX
	MOV	R3,SYSNDX	;SAVE IT
	MOV	R3,SYNXSV	;AND AGAIN

GLOBAL	<PRVIOL>

.DSABL	LSB	

.ENABL	LSB
.SBTTL	BUILD MASSBUS ID TABLE FOR DB/DR

	CALLX	CLRFQB			;CLEAR THE FIRQB
	MOVB	#OPNFQ,FIRQB+FQFUN	;OPEN FUNCTION FOR CALFIP
	MOVB	#16*2,FIRQB+FQFIL	;ON CHANNEL 14
	MOV	#1,FIRQB+FQPPN		;[0,1]
	MOV	#^RINI,FIRQB+FQNAM1	;INIT.
	MOV	#^RT,FIRQB+FQNAM1+2	;SYS
	MOV	#^RSYS,FIRQB+FQEXT	;
	MOV	SYSNAM,FIRQB+FQDEV	;SY:
	MOVB	SYSUNT,FIRQB+FQDEVN	;UNIT NUMBER
	BISB	#256,FIRQB+FQDEVN+1	;FOR REAL
	CALFIP				;DO IT
	TSTB	FIRQB			;DID WE ERROR?
	BEQ	10$			;NO
	MESSAGE	<"?Can't open SY0:[0,1]INIT.SYS"<200>>			;001
	JMP	DSKABT			;DIE
	
10$:	CLR	R2			;MSB FOR LOOKING INTO INIT.SYS
	MOV	#102,R3			;102 -> DSKMID
	CALL	INIWRD			;GET THE WORD FROM INIT.SYS
	MOV	(SP)+,R3		;GET THE WORD INTO R3 (->DSKMID)
	MOV	R3,-(SP)		;COPY R3 ONTO STACK
	ADD	#IDX$DB,R3		;OFFSET INTO DSKMID FOR DB
	ADC	R2			;TWO WORD ARITHMETIC
	CALL	INIWRD			;GET THE MID TABLE FOR DB
	MOV	(SP)+,R3		;GET THE POINTER INTO R3
	MOV	#10,R5			;TABLE IS 8 WORDS
	MOV	#DB$MID,R4		;AREA TO COPY TO (OUR FAKER)
20$:	CALL	INIWRD			;FETCH A WORD
	MOV	(SP)+,(R4)+		;COPY AWAY
	ADD	#2,R3			;GET THE NEXT WORD
	ADC	R2			;ADD THE CARRY
	SOB	R5,20$			;ALL OF IT

	MOV	(SP)+,R3		;RESTORE R3 -> DSKMID
	ADD	#IDX$DR,R3		;OFFSET INTO DSKMID FOR DR
	ADC	R2			;TWO WORD ARITHMETIC
	CALL	INIWRD			;GET THE WORD
	MOV	(SP)+,R3		;INTO R3 ->MID TABLE FOR DR
	MOV	#DR$MID,R4		;R4 -> AREA TO COPY TO
	MOV	#10,R5			;8 WORDS TO COPY
30$:	CALL	INIWRD			;FETCH A WORD
	MOV	(SP)+,(R4)+		;COPY AWAY
	ADD	#2,R3			;GET THE NEXT WORD
	ADC	R2			;ADD THE CARRY
	SOB	R5,30$			;ALL OF IT

	CALLX	CLRFQB			;CLEAR THE FIRQB	
	MOVB	#2*16,FIRQB+FQFIL	;CHANNEL 14
	MOVB	#CLSFQ,FIRQB+FQFUN	;CLOSE FUNCTION
	CALFIP				;DO IT

.SBTTL	CALL MAINLINE DSKINT; DSKABT ROUTINE

11$:	BIS	#512.,OPNMOD		;SET SPECIAL MODE TO READ ERROR TRACK!;debug
	MOV 	#STRTUP,R1		;MAKE R1 POINT TO WORD CONTAINING 0
	CALLX	DSKINT			;Fly away, (does not return)	;009
DSKABT::EXST$S	STATUS			;Exit with status		;009

.DSABL	LSB

.SBTTL	TRAP HANDLER;	PARSEX
;
;	TRAP HANDLER
;

ERFTRP::TST	(SP)+		;SKIP A PARMATER
	MOV	@(SP),R0	;GET MESSAGE ADDRESS
	CALL	ASCIZ0		;PRINT THE MESSAGE
	JMP	DSKABT		;DIE


.ENABL	LSB
.SBTTL	FIP INTERNAL I/O ROUTINE
;+
; PARSEX - DO READ OR WRITE FOR FIP
;
; CALL:	R2/R3 = FIP BLOCK NUMBER OF BLOCK TO DO
;	I.DSQ+DSQCNT = NUMBER OF WORDS TO TRANSFER
;	CALL	PARSEX,R5
;	+	FUNCTION CODE (RFUN OR WFUN)
;	+	BUFFER ADDRESS
;
; NOTE: IF BACKUP IS SET THEN HIGHBF IS USED AS THE HIGH BYTE OF THE ADDRESS
;
; BACK:	'TIS DONE
;	I.DSQ+DSQCNT RESET TO 256.
;-
PARSEX::MOV	R4,-(SP)	;SAVE THE CALLER'S R4 FOR HIM
	MOV	#I.DSQ+DSQFUN,R4 ;SET POINTER TO DSQ @ DSQFUN
	MOV	(R5)+,(R4)	;SET THE SUPPLIED FUNCTION
	TST	-(R4)		;SKIP THE COUNT
	MOV	(R5)+,-(R4)	;SET THE SUPPLIED BUFFER ADDRESS
	CLR	-(R4)		;CLEAR EXTENDED ADDRESS AND RH FUNCTION
20$:	MOV	R2,-(R4)	;SET THE SUPPLIED BLOCK NUMBER (LSB)
	MOVB	R3,-(R4)	;AND SET EXTENDED DISK ADDRESS (MSB)
	CLRB	-(R4)		;SKIP UNIT
	TST	-(R4)		;SKIP ONE WORD
	MOVB	#-2,-(R4)	;SET DSQERR
	MOVB	SYSNDX,-(R4)	;SET UP SYSTEM DISK INDEX
	CLR	-(R4)		;AND CLEAR THE QUEUE LINK WORD
	MOVB	SYSUNT,DSQPUN(R4) ;SET UP SYSTEM DISK UNIT NUMBER
	CALL	DISK		;NOW START THE OPERATION
	BCC	30$		;NO ERRORS
	INC	ERRCTR		;SHOW WE HAD A ERROR
30$:	MOV	#256.,I.DSQ+DSQCNT ;NEXT TIME WE WILL DO 256. WORDS
	MOV	(SP)+,R4	;RESTORE R4
	RETURN	R5		;RETURN NORMALLY

	
	GLOBAL	<I.DSQ>

.DSABL	LSB

.SBTTL	DISK - DO ALL DISK I/O HERE (CALLED BY PARSEX)

;+
; DISK:	DO ALL DISK I/O FOR PARSEX
;
; CALL	DISK
;
;	DATA PASSED IN DSQ
;
; RETURN:
;	C=0 DONE
;	C=1 ERROR IN IOERR
;	N.B.  NOT ALL ERRORS PASS THROUGH
;
;-
.ENABL	LSB

DISK::	MOV	R0,-(SP)		;SAVE SOME REGISTERS
	MOV	R1,-(SP)
	MOV	R2,-(SP)
	MOV	DSQFBL(R4),R0		;GET LSB OF BLOCK TO TRANSFER
	MOVB	DSQFBM(R4),R1		;GET MSB OF BLOCK TO TRANSFER
	;TST	R1			;IS IT BLOCK ZERO?
	BNE	50$			;NOPE
	TST	R0			;MAYBE?
	BNE	50$			;NO
	NOP				;debugging			   ;016
	CALL	CLOSER			;Close block mode opened disk	   ;018
	CLR	OPNMOD			;Setup for CLUSTER Mode open	   ;018
	CALL 	OPENER			;OPEN IT BACK UP		   ;018
	BCS	125$			;ERROR, so die			   ;018
	CALLX	CLRXRB			; Clear the xrb			   ;016
	;MOV	R0,XRB+XRBLK		; R0=0, CLRXRB does it		   ;016
	MOV	DSQCNT(R4),R1		;GET BUFFERSIZE FROM WORD COUNT	   ;016
	ASL	R1			;MAKE IT BUFFERSIZE IN BYTES	   ;016
	MOV	R1,XRB+XRLEN		;SAVE IT			   ;016
	MOV	DSQMAL(R4),XRB+XRLOC 	;GET BUFFER ADDRESS		   ;016
	MOVB	CHANO,XRB+XRCI		;SET CHANNEL NUMBER		   ;018
	MOVB	DSQFUN(R4),R0		;Get function			   ;016
	CMP	R0,#WFUN		;IS IT WRITE?			   ;016
	BEQ	30$			;YES, do it			   ;016
	CMP	R0,#RFUN.C		;Heaven forbid, a read check?	   ;016
	BNE	22$			;No, so check for read		   ;016
	MOV	XRB+XRLEN,XRB+XRBC	;SET BUFFER SIZE for read check	   ;016
	MOV	#-1,XRB+XRLEN		;.SPEC FOR RFUN.C		   ;016
	.SPEC				;DO IT				   ;016
	BR	33$			;Then act like other cluster i/o   ;016

22$:	CMP	R0,#RFUN		;read?				   ;016
	BNE	90$			;No, so error			   ;016
	.READ				;Else, do the read		   ;016
	BR	33$			;And join common cluster i/o chks  ;016

30$:	MOV	XRB+XRLEN,XRB+XRBC 	;BUFFER LENGTH AND BYTE COUNT ARE  ;016
	.WRITE				; BOTH DEFINED AT I.DSQ+DSQCNT	   ;016
33$:	TSTB	FIRQB			; ERROR?			   ;016
	BNE	125$			; Yes, so abort			   ;016
	CALL	CLOSER			;Close the cluster mode I/O disk   ;018
	BCS	125$			; Error? Yes, so abort		   ;018
	MOV	#40000+1000+200,OPNMOD	;Set block mode i/o, err trk rd	   ;018
	CALL	OPENER			;Reopen in block mode		   ;018
	BCS	125$			;Die on error			   ;018
	BR	140$			;We are done			   ;018

50$:	CALLX	CLRXRB		;CLEAR THE XRB FOR I/O
	MOV	R0,XRB+XRBLK	;FBN-LSB gets loaded here		   ;016
	MOVB	R1,XRB+XRBLKM	;FBN-MSB gets loaded here		   ;016
	MOV	DSQCNT(R4),R1	;GET BUFFERSIZE FROM WORD COUNT
60$:	ASL	R1		;MAKE IT BUFFERSIZE IN BYTES
	MOV	R1,XRB+XRLEN	;SAVE IT
	MOV	DSQMAL(R4),XRB+XRLOC ;GET BUFFER ADDRESS
	MOVB	CHANO,XRB+XRCI	;GET CHANNEL NUMBER
	MOVB	DSQFUN(R4),R0	;WHAT SHOULD WE DO?
80$:	CMP	R0,#WFUN	;IS IT WRITE?
	BEQ	110$		;YES
	CMP	R0,#RFUN.C	;IS IT READ CHECK ONLY?
	BEQ	190$		; YES
	CMP	R0,#RFUN	;IS IT READ?
	BEQ	100$		;YES
90$:	MESSAG	<"?Bad DISK function #">
	CALL	OCTWRD		;TELL THEM WHAT WE WERE ASKED TO DO
	JMP	DSKABT		;DIE

100$:	.READ			;THIS SHOULD DO IT
	BR	120$

110$:	MOV	XRB+XRLEN,XRB+XRBC ;BUFFER LENGTH AND BYTE COUNT ARE
	.WRITE			; BOTH DEFINED AT I.DSQ+DSQCNT

120$:	CLC			;ASSUME NO ERROR
	MOVB	NRETRY,I.DSQ+DSQERR	;FAKE OK
125$:	MOVB	FIRQB,IOERR	;WELL?					;016
	BEQ	140$		;GOOD SHOW
	MOVB	IOERR,I.DSQ+DSQERR	;SET THE DSQERR
;	CMPB	IOERR,#HNGDEV	;IS DEVICE HANGED?
;	BEQ	130$		; YES; RECOVER
	CMPB	IOERR,#DATERR	;USER DATA ERROR?
	BEQ	130$		; YES, SO RECOVER
	CALL	TYPER		;NO, SO GIVE UP
	JMP	DSKABT		;DIE

130$:	SEC			;RETURN WITH ERROR FLAG SET
140$:	MOV	(SP)+,R2
	MOV	(SP)+,R1
	MOV	(SP)+,R0
	RETURN


.SBTTL	READ-CHECK (RFUN.C) ROUTINE

190$:	MOV	XRB+XRLEN,XRB+XRBC	;SET BUFFER SIZE
	MOV	#-1,XRB+XRLEN	;.SPEC FOR RFUN.C
	MOVB	XRB+XRBLKM,XRB+XRMOD	;.spec is different		;016
	CLRB	XRB+XRBLKM		;DSKHND=0			;016
	.SPEC			;DO IT
	BR	120$		;DO IT LIKE ANY OTHER I/O ERROR

	GLOBAL	<NOTAVL,DATERR,HNGDEV>
.DSABL	LSB

.ENABL	LSB
	.SBTTL	CHKMNT - CHECK TO SEE IF DISK IS MOUNTED
;
;	CHECKS TO SEE IF DISK IS MOUNTED AND FINDS DCS,MSB,LSB
;

CHKMNT::REGSAV			;SAVE THE REGS
	CALLX	CLRFQB		;CLEAR THE FIRQB
	MOVB	#CLSFQ,FIRQB+FQFUN;CALFIP FUNCTION CODE FOR CLSFQ
	MOVB	#1*2,FIRQB+FQFIL;CLOSE CHANNEL #1
	CALFIP			;IF IT'S OPEN
	CALLX	CLRXRB		;CLEAR THE XRB
	MOV	#LEN,XRB+XRLEN	;MOVE STRING LENGTH INTO XRB
	MOV	#LEN,XRB+XRBC	;MOVE BYTE TRANSFER COUNT INTO XRB
	MOVB	DUNT,(SP)+	;Save the unit number.			;013
	CMPB	DUNT,#9.	;Double digit unit number?		;013
	BLE	5$		;No, continue.				;013
.ASSUME	LEN2	EQ LEN+1
	INC	XRB+XRLEN	;Otherwise, the unit number "hole"	;013
	INC	XRB+XRBC	; is 1 character bigger, so fix it.	;013
	MOV	DNAME,DNAME2	;Make a copy of the disk name.		;013
	MOVB	#'1,DUNT2	;Put the first digit into string.	;013
	SUB	#10.,DUNT	;Isolate second digit...		;013
	BISB	#'0,DUNT	; ...and make it ASCII.			;013
	MOVB	DUNT,DUNT2+1	;Put the second digit into string, too.	;013
	MOV	#DNAME2,XRB+XRLOC;Move string address into XRB.		;013
	BR	7$		;Do the FSS.				;013

5$:	BISB	#'0,DUNT	;Convert unit to ASCII.			;013
	MOV	#DNAME,XRB+XRLOC;MOVE STRING ADDRESS INTO XRB
7$:	.FSS			;Do the File Name String Scan.		;013
	MOVB	-(SP),DUNT	;Restore DUNT to decimal.		;013
	CLR	FIRQB+FQJOB	;AND THEN...
	CLR	FIRQB+FQSIZ	;CLEAR OUT
	CLR	FIRQB+FQFIL	;     SOME OF
	CLR	FIRQB+FQPFLG	;     THESE UNUSED
	CLR	FIRQB+FQCLUS	;     BYTES IN
	CLR	FIRQB+FQNENT	;     THE FIRQB!
	CLR	FIRQB+FQFLAG	;	
	CLR	FIRQB+FQSWIT	;
	MOVB	#OPNFQ,FIRQB+FQFUN;SET CALFIP FUNCTION FOR OPNFQ
	MOVB	#2*2,FIRQB+FQFIL;OPEN ON CHANNEL #2
	CALFIP			;DO THE CALFIP
	TSTB	FIRQB		;DID WE ERR?
	BEQ	10$		;NO...WHICH MEANS THIS DISK IS MOUNTED!
	CMPB	#NOTMNT,FIRQB	;YES..IS THE ERROR NOTMNT?
	BEQ	20$		;YES..WHICH MEANS DISK IS NOT MOUNTED-SO CONTINUE
	MOVB	FIRQB,R0	;MOV THE ERROR CODE INTO IOERR TO PRINT
	CALL	ERRPRT		;PRINT THE ERROR WHATEVER IT IS
	BR	15$

10$:	MESSAG	<"?Disk must not be mounted"<200>>
15$:	CALLX	CLRFQB       	;CLEAR THE FIRQB
	MOVB	#CLSFQ,FIRQB+FQFUN	;CLOSE FUNCTION
	MOVB	#2*2,FIRQB+FQFIL	;CHANNEL 2
	CALFIP			;DO IT TO IT
	CALL	REGRES,R5	;RESTORE THE REGS
	SEC			;SET THE CARRY FOR ERROR
	RETURN

20$:	BIT	#DDWLO,FIRQB+FQFLAG	;WRITE-LOCK BIT  SET?
	BEQ	30$		;NO
	MESSAGE <"?Disk write-locked"<200>>	;tell the guy
	BR	15$		;DIE

30$:	CALL	OPENER		;OPEN IT UP ON CHANNEL 1
	BCS	35$		;OOPS-ERROR
	CALLX	CLRXRB		;CLEAR THE XRB
	MOV	#512.,XRB+XRLEN	;READ A BLOCK
	MOV	#SATBUF,XRB+XRLOC	;INTO SATBUF
	MOVB	CHANO,XRB+XRCI	;ON CHANNEL 1
	.READ			;READ IT
	CALL	CLOSER		;CLOSE IT  (these lines get around the MSCP problem)
	BCS	35$		;OOPS-ERROR
	CLR	OPNMOD		;Set std open for getting DCS, etc	;016
	CALL 	OPENER		;OPEN IT BACK UP
	BCS	35$		;ERROR
	MOV	FIRQB+FQBUFL,R2	;GET BUFFER SIZE (= DCS*1000)
	MOV	FIRQB+FQSIZ,R1	; SIZE OF DISK IN DEVICE CLUSTERS
	CALLX	CLRXRB		;CLEAR THE XRB
	MOV	#512.,XRB+XRLEN	;READ A BYTE
	MOV	#SATBUF,XRB+XRLOC	;INTO SATBUF
	MOVB	CHANO,XRB+XRCI	;ON CHANNEL 1
	.READ			;READ IT
	TSTB	FIRQB		;DID WE ERR?
	BEQ	40$		;NOPE
35$:	MOVB	FIRQB,R0	;PUT ERROR IN R0
	CALL	ERRPRT		;PRINT IT OUT
	BR	15$		;DIE
	
40$:	ASH	#-9.,R2		;COMPUTE DCS FOR THIS DISK
	BIC	#^C<177>,R2	;Clear bits 7:15 to kill Sign Extend	;019
	MOV	R2,DCS		;SAVE DCS
	CLR	R0		;CLEAR FOR SHIFT
45$:	ASR	R2		;SHIFT DCS
	BCS	50$		;DONE
	ASL	R1		;COMPUTE NUMBER OF BLOCKS ON DISK
	ROL	R0		; AS DCS*NUMBER OF CLUSTERS
	BR	45$

50$:	MOVB	DUNT,R3		;GET THE UNIT NUMBER
	ASL	R3		;TIMES 2
	MOV	DCS,DSKDCS(R3)	;COPY THE DCS
	MOV	R0,DSKMSB(R3)	;SAVE MAX FBN MSB
	MOV	R1,DSKLSB(R3)	;SAVE MAX FBN LSB
	CALLX	CLRFQB       	;CLEAR THE FIRQB
	MOVB	#CLSFQ,FIRQB+FQFUN	;CLOSE FUNCTION
	MOVB	#2*2,FIRQB+FQFIL	;CHANNEL 2
	CALFIP			;DO IT TO IT
	CALL	CLOSER		;close standard channel			;016
	MOV	#40000+1000+200,OPNMOD	;Set block mode i/o, err trk rd	;016
	CALL	OPENER		;do the open				;016
	BCS	35$		;error? Tell the user			;016
	CALL	REGRES,R5	;RESTORE THE REGS
	CLC			;RETURN WITHOUT ERROR
	RETURN


	GLOBAL	<NOTMNT,D.SIZM,D.SIZL>

	TMPORG	ONLCTL
	.EVEN
DNAME:	.WORD	0
DUNT:	.BYTE	0
	.ASCII	/:[0,1]SATT.SYS/
	LEN=.-DNAME
	.EVEN

DNAME2:	.WORD	0		; Used for .FSS with double-digit	;013
DUNT2:	.WORD	0		;  unit numbers.			;013
	.ASCII	/:[0,1]SATT.SYS/					;013
	LEN2=.-DNAME2							;013
	.EVEN								;013

	UNORG



.DSABL	LSB



.SBTTL	ROUTINES TO MANAGE SATBUF/S2TBUF

SAVSAT::REGSCR			;SAVE REGISTERS
	MOV	#SATBUF,R0	;POINT TO FIRST BUFFER
	MOV	#S2TBUF,R1	;POINT TO SECOND BUFFER
	MOV	#16.*256.,R2	;WORD COUNT
10$:	MOV	(R0)+,(R1)+	;COPY A WORD
	SOB	R2,10$		; WE GO
	RETURN

RESSAT::REGSCR			;SAVE REGISTERS
	MOV	#SATBUF,R0	;POINT TO FIRST BUFFER
	MOV	#S2TBUF,R1	;POINT TO SECOND BUFFER
	MOV	#16.*256.,R2	;WORD COUNT
10$:	MOV	(R1)+,(R0)+	;COPY A WORD
	SOB	R2,10$		; WE GO
	RETURN

GETSB2::ADD	#S2TBUF,2(SP)	;BIAS POINTER INTO S2TBUF
	MOV	2(SP),SB2ADR	;SAVE ADDRESS
	BIT	#1,2(SP)	;WORD?
	BNE	10$		;NO, BYTE
	MOV	@2(SP),2(SP)	;GET A WORD
	RETURN

10$:	MOVB	@2(SP),2(SP)	;REPLACE ADDRESS WITH DATA
	RETURN

PUTSB2::MOVB	2(SP),@SB2ADR	;REPLACE DATA
	MOV	(SP)+,(SP)	;DUMP DATA FROM STACK
	RETURN

PTRSB2::MOV	(SP),-(SP)	;MAKE ROOM FOR POINTER
	MOV	#S2TBUF,2(SP)	;SET POINTER ONTO STACK
RSTSB2::RETURN			;DONE. NOTHING TO RESET

SB2ADR:	.WORD	0		;SAVED ADDRESS FROM GETSB2

.SBTTL	READ FOR FIP (READ,READSV,READRF,READMF)

;+
; READ   - READ BLOCK INTO FIBUF GIVEN FBN (WRITE FIRST IF MARKED)
; READSV - READ BLOCK INTO FIBUF GIVEN FBN, ALWAYS WRITE CURRENT BUF
; READRF - READ BLOCK INTO FIBUF GIVEN DCN (RP)
; READMF - READ FIRST BLOCK OF MFD INTO FIBUF
;
; CALL:	FIPUNT = DISK UNIT NUMBER
;	FOR READ AND READSV -
;		R2 = LSB OF FBN OF BLOCK TO READ
;		R3 = MSB OF FBN OF BLOCK TO READ
;	FOR READRF -
;		R2 = DCN OF BLOCK TO READ
;	FOR READMF - NO SETUP
;	CALL	READ??
;
; BACK:	R2/R3 AND FIBPHS = FBN OF BLOCK READ
;	FIBUF CONTAINS THE BLOCK
;	FIBUNT = UNIT NUMBER
;	C=0
;-

.ENABL	LSB

READSV::BISB	(PC),@#FIBSTA	;FORCE A WRITE
READ::	CMP	R2,@#FIBPHS	;CHECK TO SEE IF SEGMENT ALREADY THERE
	BNE	10$		;IF NOT EQUAL, THEN DO THE I/O
	CMP	R3,@#FIBPHS+2	;CHECK MSB'S
	BEQ	20$		;IT'S ALREADY THERE, SO RETURN CARRY=0
10$:	CALL	WRITEC		;CHECK FOR WRITE BEFORE READ
	CALL	PARSEX,R5,<RFUN,FIBUF> ;DO A DISK OPERATION
	MOV	R2,@#FIBPHS	;SET LSB OF THE FIP BLOCK #
	MOV	R3,@#FIBPHS+2	; AND THE MSB'S
20$:	CLC			;MUST EXIT WITH C AT 0
	RETURN

; ENTRY TO READ THE FIRST BLOCK OF THE MFD

READMF::CALL	READPL		;Read the pack label first		;001
	BIT	#UC.NEW,FIBUF+PSTAT ;New or old pack?			;001
	BEQ	20$		;Old, done				;001
	MOV	FIBUF+MDCN,R2	;Get MFD starting DCN			;001
	.CALLR	READRF		;Go read that				;001

; ENTRY TO READ IF R2 CONTAINS A RETRIEVAL POINTER (DCN) RATHER THAN
; R2,R3 CONTAINING THE FIP BLOCK NUMBER TO BE READ

READRF::CALL	CNVRIB		;CONVERT RIB ENTRY TO FIP BLOCK #
	BR	READ		;AND DO A NORMAL READ

; Entry to read the pack label						;001

READPL::MOV	#1,R2		;Read the pack label			;001
	CLR	R3		;WHICH IS FIP BLOCK # 1
	BR	READ		;OTHERWISE NORMAL READ

.DSABL	LSB

.SBTTL	WRITE FOR FIP (WRITE,WRITEC)
;+
; WRITE  - WRITE OUT CONTENTS OF FIBUF
; WRITEC - WRITE OUT CONTENTS OF FIBUF ONLY IF FIBSTA IS NON-0
;
; CALL:	FIBPHS = FIB BLOCK NUMBER OF BLOCK IN BUFFER
;	FIBUNT = DISK UNIT NUMBER
;	CALL	WRITE?
;
; BACK:	BLOCK WRITTEN
;	FIBSTA = 0
;-
.ENABL	LSB

WRITEC::TSTB	@#FIBSTA	;CHECK STATUS OF BUFFER
	BEQ	30$		;IF 0, NOTHING THERE OR NO CHANGE
WRITE::CLRB	@#FIBSTA	;INDICATE BUFFER WRITTEN
	MOV	R2,-(SP)	;PUSH OLD R2
	MOV	R3,-(SP)	;AND  R3
	MOV	@#FIBPHS+2,R3	;GET MSB OF BLOCK # TO WRITE
	MOV	@#FIBPHS,R2	;GET THEM OTHER BITS TOO
	BNE	10$		;IF BLOCK # NOT ZERO,THEN DO THE I/O
	TST	R3		;ARE YOU SURE IT'S ZERO?
	BEQ	20$		;IF SO THEN SKIP THE WRITE
10$:	CALL	PARSEX,R5,<WFUN,FIBUF> ;FINISH PARAMS AND DO IT
20$:	MOV	(SP)+,R3	;POP OLD R3
	MOV	(SP)+,R2	;AND R2
30$:	RETURN

.DSABL	LSB

.ENABL	LSB
.SBTTL	GET A CLEAN SAT INTO CORE (CLNSAT)
;+
; CLNSAT - LOAD IN-CORE SAT BUFFER WITH CLEAN (NOTHING ALLOCATED) SAT
;
; CALL:	SETSAT MUST HAVE BEEN CALLED
;	CALL	CLNSAT
;
; BACK:	IN-CORE SATBUF LOADED WITH SAT BITS:
;	ALL SYSTEM DISK CLUSTERS ARE DEALLOCATED
;	ALL BITS CORRESPONDING TO NON-EXISTENT BLOCKS ARE ALLOCATED
;	through block 16						;016
;
; NOTE:	THE SAT IS KEPT IN CORE AS A MULTIPLE OF PCS BLOCKS,
;	EVEN THOUGH ITS FILE LENGTH REFLECTS ITS TRUE EXTENT
;-
CLNSAT::CLR	R4		;ZERO SAT BYTE POINTER
	MOV	R2,-(SP)	;get a register				;016
	MOV	#1,R5		;START AT BIT ZERO
	MOV	SATSYS+BITS,R0	;R0 = # CLUSTERS IN SYS DISK SAT

; THIS ROUTINE DEALLOCATES BITS IN THE SAT. NUMBER OF BITS IS IN R0

10$:	CMP	R4,SATSYS+BYTS	;ROOM IN SAT ?
	BHIS	35$		;NO, QUIT, restoring R2			;016
	BICB	R5,SATBUF(R4)	;YES, CLEAR A BIT
	CALL	30$		;ADVANCE TO NEXT BIT
	SOB	R0,10$		;CLEAR AS MANY AS NEEDED

; NOW TO FINISH UP BY ALLOCATING ALL BITS BEYOND PHYSICAL END OF DISK

20$:	MOV	SATSYS+BYTS,R2	;save the byts to be cleared		;016
	CMP	R2,#16.*1000	;At the limit?				;016
	BLOS	25$		;no, so ok				;016
	MOV	#16.*1000,R2	;yes, so set the valid limit		;016
25$:	CMP	R4,R2		;FINISHED YET ?				;016
	BHIS	35$		;YES, FINAL EXIT			;016
	BISB	R5,SATBUF(R4)	;SET A BIT
	CALL	30$		;ADVANCE TO NEXT BIT
	BR	20$		;LOOP MORE

; THIS ROUTINE ADVANCES TO THE NEXT BIT

30$:	ASLB	R5		;SHIFT BIT LEFT ONE
	BCC	40$		;STILL IN BYTE ?
	INC	R4		;NO, ON TO NEXT BYTE
	INC	R5		;AND SET MASK TO BIT 0 AGAIN
	BR	40$		;and return				;016

35$:	MOV	(SP)+,R2	;restore register			;016
40$:	RETURN
.DSABL	LSB

.ENABL	LSB
.SBTTL	SEARCH UFD FOR PPN + FILE.EXT  (SDU)
;+
; SDU - SEARCH UFD FOR [PPN]FILNAM.EXT
;
; CALL:	R0 -> PPN+FILNAM.EXT
;	CALL	SDU
;
; BACK:	C=0	FILE FOUND IN UFD
;		R2 = LINK IN UFD TO PREVIOUS NAME ENTRY
;		R3 = LINK IN UFD TO FOUND NAME ENTRY
;		R5 -> NAME ENTRY
;		FIPMUC = UFD CLUSTER SIZE
;	C=1	FILE NOT FOUND
;		R5=0	PPN NOT FOUND IN MFD
;			FIPCLU = LINK IN MFD TO LAST NAME ENTRY
;			FIBUF CONTAINS BLOCK WHICH FIPCLU POINTS TO
;		R5=2	PPN FOUND IN MFD, BUT UFD NOT ALLOCATED
;			FIBUF CONTAINS MFD BLOCK W/ ACCOUNT'S NAME ENTRY
;			FIPCLU = ABSOLUTE POINTER TO
;				ACCOUNT'S NAME ENTRY + UAR
;				(I.E. @FIPCLU IS DCN OF UFD = 0)
;			FIPMUC = UFD CLUSTER SIZE (FROM ACCOUNT'S AB)
;		R5=4	UFD EXISTS, BUT FILE NOT FOUND
;			R2 = LINK IN UFD TO LAST NAME ENTRY
;			R3 = 0
;			FIBUF CONTAINS UFD BLOCK WHICH R2 POINTS TO
;			FIPMUC = UFD CLUSTER SIZE
;-
SDU::	CALL	RUF		;RUF WILL GET THE UFD
	BCS	30$		;EXIT IF PPN NOT FOUND OR NO UFD
	CLR	R2		;INIT UFD SCAN
	CLR	R3		;ZERO LINK
10$:	CALLX	RDB		;GET A NAME BLOCK
	CMP	2(R0),UNAM(R5)	;MATCH ON NAME FIRST WORD ?
	BNE	20$		;NO,GET ANOTHER NAME BLOCK
	CMP	4(R0),UNAM+2(R5);GO FOR 2 ?
	BNE	20$		;NOPE
	CMP	6(R0),UNAM+4(R5);TRY THE EXTENSION
	BNE	20$		;SORRY CHARLIE
	BITB	#US.DEL!US.UFD,USTAT(R5) ;MARKED FOR DELETION OR UFD?
	BEQ	30$		;IF NOT, THEN WE FOUND IT
				;IF SO , IGNORE IT
20$:	MOV	R3,R2		;NEW LAST LINK
	MOV	(R5),R3		;NEW THIS LINK
	BIC	#17,R3		;WITHOUT FLAG BITS
	BNE	10$		;IF NOT END OF UFD, LOOP
	MOV	#4,R5		;IF END, SET R5=4 FOR EOF
	SEC			;INDICATE BADNESS
30$:	RETURN			;RETURN
.DSABL	LSB

.ENABL	LSB
.SBTTL	READ UFD GIVEN A PPN  (RUF)
;+
; RUF	- READ FIRST BLOCK OF UFD GIVEN PPN
;
; CALL:	R0 -> PPN
;	CALL	RUF
;
; BACK:	C=0	UFD WAS FOUND
;		FIBUF CONTAINS FIRST BLOCK OF UFD
;		FIPMUC = UFD CLUSTER SIZE
;		FIPCLU = LINK IN MFD POINTING TO NB ENTRY FOR PPN
;		R5 = 0
;	C=1	UFD COULD NOT BE READ
;		R5=0	PPN NOT FOUND IN MFD
;			FIPCLU = LINK IN MFD TO LAST NAME ENTRY
;			FIBUF CONTAINS BLOCK WHICH FIPCLU POINTS TO
;		R5=2	PPN FOUND IN MFD, BUT UFD NOT ALLOCATED
;			FIBUF CONTAINS MFD BLOCK W/ ACCOUNT'S NAME ENTRY
;			FIPCLU = ABSOLUTE POINTER TO
;				ACCOUNT'S NAME ENTRY + UAR
;				(I.E. @FIPCLU IS DCN OF UFD = 0)
;			FIPMUC = UFD CLUSTER SIZE (FROM ACCOUNT'S NB)
;-
RUF::	CLR	R5		;SET R5 TO ZERO INITIALLY
	REGSCR			;SAVE REGS
	MOV	(R0),-(SP)	;PUT SUPPLIED PPN ON STACK
	MOV	SP,R0		;R0 -> COPY OF PPN FOR SDM
	CALL	SDM		;SEARCH MFD FOR THIS PPN
	MOV	R2,FIPCLU	;STORE POSSIBLE LAST LINK IN TEMP
	BCS	30$		;NO PPN WAS FOUND, ACCOUNT DOESN'T EXIST
	ADD	#UAR,R5		;R5 -> RB LINK WORD
	MOV	(R5),R2		;GET THE UFD START DCN
	BNE	10$		;IF UFD EXISTS, BRANCH
	MOV	R5,FIPCLU	;STORE NB POINTER INTO A TEMP
	MOV	R3,-(SP)	;SAVE LINK TO ACCOUNT'S UFD NAME ENTRY
	MOV	-(R5),R3	;GET THE AB LINK
	CALLX	RDB		;NOW GET ACCOUNT'S MFD ACCOUNTING ENTRY
	MOV	UCLUS(R5),FIPMUC;SET THE UFD CLUSTER SIZE FROM THAT
	MOV	(SP)+,R3	;RESTORE NAME ENTRY LINK
	CALLX	RDB		;READ NAME ENTRY AGAIN
	COM	(SP)+		;SET THE CARRY, DUMP STACK
	MOV	#2,TOS.R5(SP)	;SET R5 TO 2 (ACCOUNT BUT NO UFD)
	RETURN			;RETURN WITH BADNESS NOTED

10$:	CALLX	CNVRIB		;CONVERT DCN TO FIP BLOCK #
20$:	CALL	READ		;READ IN FIRST BLOCK OF UFD
	CLR	FIPMUC		;set UFD cluster size from map		;011
	BISB	FIBMAP,FIPMUC	;''''					;011
;	MOVB	FIBMAP,FIPMUC	;SET UFD CLUSTER SIZE FROM MAP		;001
	;CLC			;INDICATE GOODNESS
30$:	INC	(SP)+		;DUMP STACK LEAVING CARRY ALONE
	RETURN
.DSABL	LSB

.SBTTL	READ NAME ENTRY FOR OPEN FILE (RNB)
;+
; RNB - READ NAME ENTRY OF OPEN FILE
;
; CALL:	R1 -> FCB
;	CALL	RNB
;
; BACK:	R5 -> NAME ENTRY OF FILE IN FIBUF
;-
RNB::	MOV	R2,-(SP)	;SAVE REGS
	MOV	R3,-(SP)
	MOV	FCUFND+F.FBNL(R1),R2 ;GET LSB OF FBN FOR NAME ENTRY
	MOVB	FCUFND+F.FBNM(R1),R3 ;GET MSB
	CALL	READ		;READ IN THE RIGHT BLOCK
	CLR	R5		;CLEAR R5 FOR BISB
	BISB	FCUFND+F.UNT(R1),R5 ;GET OFFSET/2 IN R5
	ASL	R5		;R5 = OFFSET OF N.E. IN FIBUF
	ADD	#FIBUF,R5	;R5 -> N.E.
	MOV	(SP)+,R3	;RESTORE REGS
	MOV	(SP)+,R2
	RETURN

.SBTTL	SEARCH UFD FOR PPN  (SDM)
;+
; SDM - SEARCH MFD FOR PPN
;
; CALL:	R0 -> PPN
;	CALL	SDM
;
; BACK:	C=0	PPN FOUND IN MFD
;		R2 = LINK IN MFD TO PREVIOUS NAME ENTRY (TO DELETE ACCT)
;		R3 = LINK IN MFD TO THIS NAME ENTRY
;		R5 -> NAME ENTRY
;		FIBUF CONTAINS MFD BLOCK W/ THIS ACCOUNT'S NAME ENTRY
;		FIPMUC = MFD CLUSTER SIZE
;	C=1	PPN NOT FOUND IN MFD
;		R2 = LINK IN MFD TO LAST NAME ENTRY
;		R3 = 0
;		R5 DESTROYED
;		FIBUF CONTAINS LAST BLOCK OF MFD
;		FIPMUC = MFD CLUSTER SIZE
;-
SDM::	CALL	READPL		;Read the pack label			;001
	BIT	#20000,FIBUF+PSTAT ;New pack?				;001
	BNE	SDMNEW		;Yes, do it that way			;001
	MOV	FIBMAP,FIPMUC	;SET MFD CLUSTER SIZE
	CLR	R2		;PREVIOUS LINK IS MFD'S DUMMY ENTRY
	MOV	FIBUF,R3	;R3 = LINK TO FIRST NAME ENTRY IN MFD
10$:	CALL	RDB		;READ A NAME ENTRY
	BCS	30$		;BAD NAME ENTRY
	CMP	(R0),UNAM(R5)	;TEST ARGS
	BNE	20$		;THIS IS NOT THE ACCOUNT NAME ENTRY
	BITB	#US.UFD,USTAT(R5) ;NAME MATCHES. MAYBE IT'S A FILE?
	BNE	30$		;NO, IT'S REALLY A UFD, SO EXIT WITH C=0
20$:	MOV	R3,R2		;SET NEW LAST LINK
	MOV	(R5),R3		;NEW CURRENT LINK
	BIC	#17,R3		; WITHOUT FLAG BITS
	BNE	10$		;CONTINUE IF NON ZERO
	SEC			;ELSE INDICATE BADNESS
30$:	RETURN

GLOBAL	<FIPMUC,FIBUF,FIBMAP>						;001

SDMNEW:	MOV	FIBUF+MDCN,R2	;Get MFD DCN				;001
	CALL	CNVRIB		;Convert to FBN				;001
	ADD	#1,R2		;Point to GFD DCN table			;001
	ADC	R3							;001
	CALL	READ		;Read that				;001
	CLR	R5		;Avoid sign extension			;001
	BISB	1(R0),R5	;Get group number			;001
	ASL	R5		; times 2 for word indexing		;001
	MOV	FIBUF(R5),R2	;Get GFD DCN				;001
	BEQ	10$		;Exit if no GFD				;001
	CALL	CNVRIB		;Convert DCN to FBN			;001
	ADD	#2,R2		;Point to UFD name entry link table	;001
	ADC	R3							;001
	CALL	READ		;Read it in				;001
	CLR	R5		;Avoid sign extension			;001
	BISB	(R0),R5		;Get user number			;001
	ASL	R5		;Word offset				;001
	MOV	FIBUF(R5),R5	;Get the link				;001
	BEQ	10$		;Error if no account there		;001
	SUB	#2,R2		;Point back to start of GFD		;001
	SBC	R3							;001
	CALL	READ		;Read it for the cluster map		;001
	MOV	R5,R3		;Copy saved link for RDB		;001
	CALLR	RDB		;Read the name entry and return		;001

10$:	CLR	R5		;Indicate PPN doesn't exist		;001
	SEC			;Error					;001
	RETURN								;001

.ENABL	LSB
.SBTTL	READ A DIRECTORY ENTRY (RDS AND RDB)
;+
; RDB - READ ENTRY FROM A DIRECTORY GIVEN LINK
; RDS - READ ENTRY FROM A DIRECTORY GIVEN LINK, MARK CURRENT BLOCK DIRTY
;
; CALL:	FIBUF MUST CONTAIN ANY BLOCK OF THIS DIR (SO FIBENT IS VALID)
;	FIBPHS CONTAINS CURRENT FIBUF FBN (AS USUAL)
;	R3 = LINK TO DESIRED ENTRY
;	CALL	RDB OR RDS
;
; BACK:	BLOCK WITH DESIRED ENTRY IS IN FIBUF
;	R5 -> DESIRED ENTRY
;	C=0
;
; ERRORS: IF A LINK IS DECODED AND SPECIFIES AN UNALLOCATED DIRECTORY
;	CLUSTER, OR SPECIFIES A BLOCK WITHIN CLUSTER WHICH IS
;	GREATER THAN THIS DIRECTORY CLUSTER SIZE:
;	"DIRECTORY ERROR DETECTED IN RDB"
;-

RDS::	BISB	(PC),@#FIBSTA	;MARK FIBUF FOR WRITE (MBFW)
RDB::	MOV	R2,-(SP)	;SAVE CALLING R2
	MOV	R3,-(SP)	;SAVE LINK FOR LATER RESTORING
	BIC	#17,R3		;CLEAR OFF FLAG BITS
	MOV	R3,R5		;COPY LINK INTO R5
	BIC	#^C<777>,R5	;LEAVE ONLY BUFFER OFFSET IN R5
	BIC	R5,R3		;AND REST ONLY IN R3
	ADD	#FIBUF,R5	;R5 IS NOW THE ABS POINTER FOR EXIT
	SWAB	R3		;GET REST OF LINK INTO LOW BITS
	MOV	R3,R2		;COPY WHAT IS LEFT OF LINK
	BIC	#-16-1,R2	;LEAVE ONLY CLUSTER NUMBER * 2 IN R2
	MOV	FIBENT(R2),R2	;NOW GET MAP ENTRY
	BNE	20$		;MUST BE NON-ZERO
10$:	MESSAGE	<<200>"?Directory error detected in RDB.">
	JMP	DSKABT

20$:	ASH	#-4,R3		;SHIFT TO GET BLOCK WITHIN CLUSTER
	CMPB	R3,FIBMAP	;IS IT VALID FOR THIS DIRECTORY?	;001
	BHIS	10$		;NO, DIRECTORY IS BAD
	MOV	R3,-(SP)	;SAVE THAT OFFSET
	CALL	CNVRIB		;CONVERT DEVICE CLUSTER # TO FIP BLOCK #
	ADD	(SP)+,R2	;ADD OFFSET INTO DIRECTORY CLUSTER
	ADC	R3		;(DOUBLE PRECISION)
	CALL	READ		;READ IN THE BLOCK OF THE DIRECTORY
	MOV	(SP)+,R3	;RESTORE ORIGINAL LINK WORD
	MOV	(SP)+,R2	;AND CALLING R2
	RETURN
.DSABL	LSB

.SBTTL	DATINI - GET THE DATE AND TIME

.ENABL	LSB

DATINI::.DATE
	MOV	XRB,I.DATE	;GET THE DATE
	MOV	XRB+2,I.TIME	; AND THE TIME
	RETURN

.DSABL	LSB

.SBTTL	LKBADB - LOOK UP BADB.SYS FILE

.ENABL	LSB

LKBADB::MOV	#FQBADB,R4	;POINT TO THE FIRQB
	CALL	LOKFIL		;LOOK UP THE FILE
	BCC	20$		;GOT IT
	SEC			;INDICATE FAILURE ON LOOK UP
20$:	RETURN

.DSABL	LSB

.ENABL	LSB
.SBTTL	LOKFIL - LOOKUP A FILE
;+
; LOKFIL - LOOKUP A FILE ON THE DISK
;
; CALL:	R4 -> FIRQB CONTAINING PPN+FILNAM.EXT
;	CALL	LOKFIL
;
; BACK:	C=0	FILE FOUND ON DISK
;		FCB ASSOCIATED WITH FIRQB SET UP FOR READING
;		FQSIZC SET UP WITH FILE'S SIZE
;	C=1	FILE NOT FOUND
;-
LOKFIL::REGSCR			;SAVE ALL REGISTERS
	BIC	#FS.OPN,FQSTAT(R4) ;MARK IT NOT OPEN FOR NOW
	MOV	R4,R0		;COPY FIRQB POINTER
	ADD	#FQPPN,R0	;R0 -> PPN+FILNAM.EXT
	CALL	SDU		;LOOK UP THE FILE BY NAME
	BCS	40$		;CAN'T FIND IT, RETURN C=1
	ADD	#FQFCB+FCBSIZ,R4 ;R4 -> END OF ASSOCIATED FCB
	MOV	#FCBSIZ/2,R3	;R3 = NUMBER OF WORDS TO CLEAR
10$:	CLR	-(R4)
	SOB	R3,10$
	MOVB	FIBIDX,(R4)+	;SAVE DISK TYPE INDEX
	MOVB	USTAT(R5),(R4)+	;FILE FLAGS (CONTIGUOUS)
	INC	R4		;SKIP PENDING XFER
	MOVB	FIBUNT,(R4)+	;SAVE FIP UNIT NUMBER
	MOV	R4,R0		;REMEMBER THIS POINTER
	ADD	#FCUFND-FCSIZ,R4 ;POINT TO UFD NAME ENTRY DESCRIPTOR
	MOV	R5,R2		;COPY NAME ENTRY POINTER
	SUB	#FIBUF,R2	;GET OFFSET TO N.E. WITHIN FIBUF
	ASR	R2		;MAKE IT A BYTE
	MOVB	R2,(R4)+	;SAVE IT IN FCB
	MOVB	FIBPHS+2,(R4)+	;SAVE CURRENT FIP BLOCK NUMBER
	MOV	FIBPHS,(R4)+	;(23 BITS)
	MOV	UAA(R5),R3	;R3 = LINK TO ACCOUNT ENTRY
	MOV	UAR(R5),R2	;R2 = LINK TO FIRST RETRIEVAL ENTRY
	CALL	RDB		;POINT TO ACCOUNT ENTRY
	MOV	USIZ(R5),(R0)	;SAVE FILE SIZE IN FCB
	MOV	(R0)+,FQSIZC-<FQFCB+FCWND>(R4) ; ALSO IN FQB EXTENSION
	CMP	(R0)+,(R0)+	;SKIP NEXT VIRTUAL BLOCK & FIRST V.B.(0)
	MOV	UCLUS(R5),(R0)	;GET FILE CLUSTER SIZE
	DEC	(R0)+		;MAKE IT A BYTE (AND FLAGS = 0)
	MOV	R2,R3		;R3 = LINK TO RETRIEVAL ENTRY
	BIC	#17,R3		; WITHOUT FLAG BITS
	BEQ	30$		;NONE (NULL FILE)
	CALL	RDB		;READ IT IN
20$:	MOV	(R5)+,(R4)+	;MOVE IN A WINDOW
	BIT	R5,#17		;DONE (ONLY FIBUF IS ALIGNED!)
	BNE	20$
30$:	CLC			;CLEAR CARRY FOR DONE
	BIS	#FS.OPN,FQSTAT-<FQFCB+FCUFND>(R0) ;MARK THE FILE OPEN
40$:	RETURN
.DSABL	LSB

.SBTTL	CNVRIB/CNVRB2 - CONVERT RETRIEVAL POINTER (DCN) TO FIP BLOCK #
;+
; CNVRIB - CONVERT RETRIEVAL POINTER (DEV CLU) TO FIP BLOCK #
; CNVRB2 - CONVERT RETRIEVAL POINTER TO FBN, PASSING DCS
;
; CALL:	R2 = RP TO CONVERT
;	DCS = DEVICE CLUSTER SIZE IF CNVRIB
;	R3  = DEVICE CLUSTER SIZE IF CNVRB2
;	CALL	CNVR??
;
; BACK:	R2/R3 = CORRESPONDING FBN
;-
CNVRIB::MOV	DCS,R3		;GET DEVICE CLUSTER SIZE
CNVRB2::MOV	R3,-(SP)	;SAVE DCS ON THE STACK
	CLR	R3		;CLEAR MSB OF FBN
	DEC	R2		;R2 = DCN - 1
10$:	ASR	(SP)		;MULTIPLY BY DEVICE CLUSTER SIZE (DCS)
	BCS	20$		; AND THEN ADD 1 TO GET
	ASL	R2		;  FIP BLK # = DCS*(DCN -1) + 1
	ROL	R3
	BR	10$

20$:	ADD	#1,R2		;R2 NOW HAS LSB OF BLOCK #
	ADC	R3		;R3 HAS MSB
	TST	(SP)+		;POP GARBAGE
	RETURN

.SBTTL	RIB2CN - CONVERT DEVICE CLUSTER NUMBER TO PACK CLUSTER NUMBER (RIB2CN)
;+
; RIB2CN - CONVERT DEVICE CLUSTER NUMBER (R.P.) TO PACK CLUSTER NUMBER
;
; CALL:	R2 = DCN TO CONVERT
;	CLURAT = CLUSTER RATIO (PCS/DCS)
;	CALL	RIB2CN
;
; BACK:	R3 = PACK CLUSTER NUMBER
;	NO ERROR IF DCN TO CONVERT IS NOT ON PACK CLUSTER BOUNDARY
;-
RIB2CN::MOV	R2,-(SP)	;SAVE R2 FOR RETURN
	MOV	R2,R3		;NEED IT IN R3 FOR DIVIDE
	DEC	R3		;RETRIEVAL POINTER - 1
	MOV	CLURAT,R2	;PCN = (R.P. - 1)/(PCS/DCS)
10$:	ASR	R2		;NOW DIVIDE
	BCS	20$		;ALL DONE
	;CLC			;AVIOD SIGN EXTENSION ON
	ROR	R3		;THIS SHIFT
	BR	10$

20$:	MOV	(SP)+,R2	;RESTORE RETRIEVAL POINTER TO R2
	RETURN

.SBTTL	CONVERT PACK CLUSTER NUMBER TO FIP BLOCK NUMBER (CN2SEG)
;+
; CN2SEG - CONVERT PACK CLUSTER NUMBER TO FIP BLOCK NUMBER
;
; CALL:	R2 = PACK CLUSTER NUMBER TO CONVERT
;	PCS = PACK CLUSTER SIZE
;	CALL	CN2SEG
;
; BACK:	R2/R3 = FIP BLOCK NUMBER
;-
CN2SEG::CLR	R3		;BLK # = CN * PCS + 1
	MOV	PCS,-(SP)	;CLEAR MSB (R3) AND STACK PCS
10$:	ASR	(SP)		;NOW MULTIPLY
	BCS	20$		;ALL DONE
	ASL	R2		;DOUBLE
	ROL	R3		; SHIFT
	BR	10$

20$:	TST	(SP)+		;DUMP STACK ITEM
	ADD	#1,R2		;ADD 1
	ADC	R3		; AND CARRY
	RETURN

.SBTTL	SEG2CN - CONVERT FIP BLOCK NUMBER TO PACK CLUSTER NUMBER
;+
; SEG2CN - CONVERT FIP BLOCK NUMBER TO PACK CLUSTER NUMBER
;
; CALL:	R2/R3 = FBN TO CONVERT
;	PCS = PACK CLUSTER SIZE
;	CALL	SEG2CN
;
; BACK:	R2 = PACK CLUSTER NUMBER
;	R3 <> 0 IF FBN WAS NOT ON A PACK CLUSTER BOUNDARY
;	CONDITION CODES SET ON R3 (Z=1 IF BOUNDARY OK)
;-
SEG2CN::SUB	#1,R2		;PCN = (BLK - 1)/PCS
	SBC	R3
	MOV	PCS,-(SP)	;GET PCS
10$:	ASRB	(SP)		;DIVIDE BY PCS
	BCS	20$
	ASR	R3		;SHIFT MSB
	ROR	R2		; BRING BITS INTO LSB
	ROLB	1(SP)		;SHIFTED OUT BITS TO STACK
	BR	10$

20$:	MOV	(SP)+,R3	;SET CC'S AND R3
	RETURN

.SBTTL	ROUND UP BLOCK COUNT TO CLUSTER MULTIPLE (FIXCLU)
;+
; FIXCLU - ROUND UP BLOCK COUNT TO AN EVEN NUMBER OF PACK CLUSTERS
;
; CALL:	R1 = NUMBER OF BLOCKS
;	CALL	FIXCLU
;
; BACK:	R0 = NUMBER OF PACK CLUSTERS AT CURRENT PCS (ROUNDED UP)
;	R1 = NUMBER OF BLOCKS = R0*PCS
;-
FIXCLU::MOV	PCS,R0		;GET PCS IN R0 FOR DIVIDE
10$:	ASR	R0		;SHIFT PCS
	BCS	20$		;DONE DIVIDE
	;CLC
	ROR	R1		;# OF BITS = (CLUSTER SIZE + PCS -1)/PCS
	ADC	R1		;AND ROUND UP IF ANY REMAINDER
	BR	10$

20$:	MOV	R1,R0		;NUMBER OF PACK CLUS TO R0
	MOV	PCS,-(SP)	;COMPUTE NUMBER OF BLOCKS AGAIN IN R1
30$:	ASR	(SP)		;MULTIPLY BY PCS
	BCS	40$
	ASL	R1
	BR	30$

40$:	TST	(SP)+		;POP THE 0 WORD
	RETURN

.SBTTL	COMPUTE SAT POINTERS GIVEN PACK CLUSTER NUMBER (FIXREG)
;+
; FIXREG - COMPUTE SAT BYTE OFFSET AND BIT NUMBER FROM PCN
;
; CALL:	R0 = PACK CLUSTER NUMBER
;	CALL	FIXREG
;
; BACK:	R2 = BIT NUMBER (USED FOR INDEXING INTO GETCLS)
;	R4 = OFFSET INTO SAT
;-
FIXREG::MOV	R0,R2		;CURRENT CN TO R2
	MOV	R0,R4		;AND R4
	BIC	#177770,R2	;ONLY BYTE REMAINDER IN R2
	CLC
	ROR	R4		;BYTE NUMBER = BIT NUMBER / 8.
	ASR	R4		;
	ASR	R4		;
	RETURN

.SBTTL	GETDIR - GET CLUSTER FOR DIRECTORY (ALIGNED ON CLUSTER BOUNDARY)
;+
; GETDIR - GET CLUSTER FOR DIRECTORY (ALIGNED ON CLUSTER BOUNDARY)
;
; CALL:	R1 = CLUSTER SIZE TO GET
;	CALL	GETDIR
;
; BACK:	C=1	CLUSTER HAS BEEN GOTTEN
;		R2 = DCN = R.P. TO START OF CLUSTER
;	C=0	NO CLUSTER AVAILABLE (R2 UNCHANGED)
;-
GETDIR::REGSCR			;SAVE ALL REGS
	MOV	R1,R5		;UFD CLUSTER SIZE TO R5
	CLR	R4		;SETUP DIVIDE
	DIV	PCS,R4		;(UFD CLU SIZE)/(PCS) = # OF PACKCLU'S TO GET
	BNE	5$		;not a large disk, continue		;016
	INC	R4		;large, so 16/32 = 1			;016
5$:	MOV	R4,R5		;ALLOCATION BOUNDARY MUST BE MULTIPLE OF SIZE
	DEC	R5		;MAKE MASK TO CHECK FOR MULTIPLE OF SIZE
	CLR	R0		;NO PREFERRED START CLUSTER
10$:	CALL	GETCLU		;GET A REAL CLUSTER
	BCC	30$		;IF NO MORE THEN DIE
	CALL	RIB2CN		;CONVERT DCN TO PACK CLUSTER #
	BIT	R5,R3		;CHECK FOR BOUNDARY
	BEQ	20$		;YUP, ON BOUNDARY
	CALL	RETCLU		;NOPE, RETURN THE CLUSTER
	MOV	R3,R0		;SET PREFERRED TO LAST FOUND
	INC	R0		;BUT DON'T GET IT AGAIN
	BR	10$		;NOW TRY AGAIN

20$:	SEC			;INDICATE POSITIVE HAPPINESS FACTOR
	MOV	R2,TOS.R2(SP)	;RETURN RETRIEVAL POINTER IN R2
30$:	RETURN

.SBTTL	GET A CLUSTER (GETCLU)
;+
; GETCLU - ALLOCATE CONTIGUOUS SPACE ON DISK (ALIGNED ONLY ON PACK CLU)
;
; CALL:	R0 = PREFERRED STARTING PACK CLUSTER NUMBER ON DISK
;	R1 = NUMBER OF BLOCKS TO ALLOCATE
;	CALL	GETCLU
;
; BACK:	C=1	SPACE HAS BEEN ALLOCATED
;		R2 = DCN OF START OF ALLOCATED SPACE (RP)
;		SATBUF UPDATED TO MARK CLUSTERS IN USE
;	C=0	NO SPACE AVAILABLE (R2 UNCHANGED)
;-
GETCLU::REGSAV			;SAVE EM ALL
	CALL	FIXCLU		;CALCULATE # OF BITS (PACK CLUS) TO GET
	MOV	R0,R1		;# OF PACK CLUSTERS TO R1
	MOV	SATSYS+BITS,R5	;SET UPPER CN LIMIT FOR SYSTEM DISK
	MOV	(SP),R0		;RESTORE PREFERREED START PCN

; R0 = START CLU #, R1 = NUMBER OF CLUSTERS, R5 = HIGH LIMIT

	CLR	-(SP)		;CLEAR ROOM FOR COUNTER ON STACK
10$:	MOV	R1,(SP)		;RESET COUNTER TO # OF BITS NEEDED
	MOV	R0,R3		;SAVE CURRENT PACK CLUSTER NUMBER
20$:	CMP	R0,R5		;HAVE WE REACHED LIMIT?
	BHIS	60$		;IF SO, ALLOCATION FAILS
	CALLX	FIXREG		;GET THE SAT POINTERS
	INC	R0		;BUMP TO NEXT CLUSTER IN SAT
	BITB	BITBYT(R2),SATBUF(R4) ;CLUSTER FREE?
	BNE	10$		;NO, START ALL OVER
	DEC	(SP)		;GOT EM ALL ?
	BNE	20$		;NOPE, CONTINUE

; CONTIGUOUS SPACE FOUND. DO THE ACTUAL ALLOCATION

	MOV	R3,R0		;START PCN OF STRING OF BITS FOUND
30$:	CALLX	FIXREG		;GET THE SAT POINTERS AGAIN
	BISB	BITBYT(R2),SATBUF(R4);ALLOCATE A CLUSTER
	INC	R0		;BUMP TO NEXT CLUSTER IN SAT
	DEC	R1		;HAVE WE SET EM ALL YET ?
	BNE	30$		;NO, HANG IN THERE A WHILE LONGER
	MOV	CLURAT,R2	;GET CLUSTER RATIO FOR DISK
40$:	ASR	R2		;RETRIEVAL POINTER =
	BCS	50$		; PCN * (DCS/PCS)
	ASL	R3
	BR	40$

50$:	INC	R3		;  + 1
	MOV	R3,TOS.R2+2(SP)	;STORE DCN IN R2 ON STACK
	SEC			;INDICATE GOODNESS
60$:	INC	(SP)+		;DUMP STACK LEAVING CARRY BIT ALONE
	CALLR	RESRPC		;RESTORE REGS & RETURN

.SBTTL	RETURN A CLUSTER (RETCLU)
;+
; RETCLU - RETURN CONTIGUOUS SPACE TO SAT AND DEALLOCATE
;
; CALL:	R1 = NUMBER OF BLOCKS BEING RETURNED
;	R2 = DCN (RP) OF START OF REGION
;
; BACK:	C=1	SUCCESSFUL DEALLOCATION
;	C=0	DIRECTORY ERROR: PART OF CLUSTER IS NOT IN THE SAT
;-
RETCLU::REGSCR			;SAVE REGS
	CALL	FIXCLU		;CALCULATE # OF BITS (PACK CLUS) TO RETURN
	MOV	R0,R1		;R1 = # OF PACK CLUSTERS
	CALL	RIB2CN		;CONVERT DCN TO PCN
	MOV	R3,R0		;R0 WILL STEP THROUGH THE CLUSTERS
	MOV	SATSYS+BITS,R5	;SET UPPER LIMIT ON CN'S
10$:	CMP	R0,R5		;REACHED LIMIT ?
	BHIS	20$		;YES, BAD DIRECTORY ERROR
	CALLX	FIXREG		;SET THE SAT POINTERS
	BICB	BITBYT(R2),SATBUF(R4) ;FREE A CLUSTER IN THE SAT
	INC	R0		;BUMP CURRENT CLUSTER NUMBER
	SOB	R1,10$		;AND GRIND
	SEC			;INDICATE GOODNESS
20$:	RETURN

;+
; REGSCR - SAVE ALL REGISTERS ON STACK AND SET UP CO-ROUTINE EXIT.
;
;	REGSCR
;
;	-OR-
;
;	CALL	REGSCR,R5
;
; NOTE: THE REGSCR MACRO DEFINES THE SYMBOLS:
;		TOS.R0,TOS.R1,...,TOS.R5,TOS.RA
;	TO BE TO SP STACK OFFSETS TO GET AT THOSE REGISTERS.
;-

SAVREG::			;HISTORICAL ENTRY POINT
REGSCR::MOV	R4,-(SP)	;SAVE R4,
	MOV	R3,-(SP)	; AND R3,
	MOV	R2,-(SP)	;  AND R2,
	MOV	R1,-(SP)	;   AND R1,
	MOV	R0,-(SP)	;    AND R0
	MOV	R5,-(SP)	;SAVE RETURN ADDRESS ON STACK
	MOV	6*2(SP),R5	;NOW RESTORE THE REAL R5 VALUE
	CALL	@(SP)+		;NOW CALL OUR CALLER
	MOV	(SP)+,R0	;RESTORE R0,
	MOV	(SP)+,R1	; AND R1,
	MOV	(SP)+,R2	;  AND R2,
	MOV	(SP)+,R3	;   AND R3,
	MOV	(SP)+,R4	;    AND R4,
	MOV	(SP)+,R5	;     AND R5
	RETURN			;NOW RETURN


REGSAV::MOV	R4,-(SP)
	MOV	R3,-(SP)
	MOV	R2,-(SP)
	MOV	R1,-(SP)
	MOV	R0,-(SP)
	MOV	5*2(SP),-(SP)
	RETURN	R5

RESRPC::CALL	REGRES,R5
	RETURN

REGRES::MOV	(SP)+,R0	;REMOVE CALLING R5
	MOV	(SP)+,R0
	MOV	(SP)+,R1
	MOV	(SP)+,R2
	MOV	(SP)+,R3
	MOV	(SP)+,R4
	RETURN	R5

;++
; OPENER, CLOSER
;
; FUNCTIONAL DESCRIPTION:
;
;	These routines open and close the subject disk we are working on.
;
;--
	.SBTTL	OPENER/CLOSER - OPEN/CLOSE DISK ROUTINES.

	.ENABL	LSB

OPENER::CALL	CLRFQB
	NOP								;016
	MOVB	#OPNFQ,FIRQB+FQFUN	; OPEN FUNCTION
	MOVB	CHANO,FIRQB+FQFIL	; ON CHANNEL #1
	MOV	DNAME,FIRQB+FQDEV	; THIS DEVICE
	MOVB	DUNT,FIRQB+FQDEVN	; AND THIS UNIT
	MOVB	#377,FIRQB+FQDEVN+1	; UNIT REAL FLAG
	MOV	OPNMOD,FIRQB+FQMODE	; ALLOW READING OF ERROR TRACK
	TST	OPNMOD			; WAS THERE SOME MODE SPEC'ED?
	BEQ	10$			; NO BRANCH.
	BIS	#100000,FIRQB+FQMODE	; SET MODE REAL FLAG.
	BR	10$			; JOIN COMMON CALFIP CODE

CLOSER::CALL	CLRFQB
	MOVB	#CLSFQ,FIRQB+FQFUN	; CLOSE FUNCTION
	MOVB	CHANO,FIRQB+FQFIL	; ON CHANNEL #1
10$:
	CALFIP				; BECOME A FIPPIE
	TSTB	FIRQB			; ERROR?
	BEQ	20$			; NOPE, RETURN C CLEAR
	SEC				; ERROR, C SET
20$:	RETURN

.DSABL LSB

;++
; ERRPRT
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine types the monitor error text, per the error code
;		given in R0 upon entry.
;
;--
	.SBTTL	ERRPRT - TYPE MONITOR ERROR TEXT
	.DSABL	LSB

ERRPRT::MOVB	R0,@#FIRQB+FQERNO	; R0=ERROR CODE
	MOVB	#ERRFQ,@#FIRQB+FQFUN	; FUNCTION
	CALFIP				; GET ERROR TEXT INTO FIRQB
	CALL	CLRXRB
	MOV	#28.,XRB+0		; WRITE FROM THE FIRQB
	MOV	#28.,XRB+2		; TO CHANNEL #0
	MOV	#FIRQB+4,XRB+4
	.WRITE				; TELL US WHAT UP
	RETURN				; AND GET LOST

.DSABL	LSB



.SBTTL	FAKE SETFIP

SETFIP::RETURN				;GO BACK WHERE YOU CAME FROM


.SBTTL	TYPER:	PRINT ERROR TEXT
;+
; TYPER: PRINT AN ERROR MESSAGE
;
; CALL:	IOERR=ERROR NUMBER
; NOTHING BACK.
;-
.ENABL	LSB

	TMPORG	ONLTXT
	.EVEN
10$:	.BYTE	177,200			;RESET CTRL/O, <CR><LF>
	.ASCII	"%%% "			;STANDARD MESSAGE PREFIX
20$:	.BLKB	28.			;27 CHARS TEXT, 1 CHAR NULL
	UNORG

TYPER::	NOP				;For debugging			;017
	MOV	R0,-(SP)		;SAVE R0.
	MOV	R1,-(SP)		;ALSO R1.
	MOV	R2,-(SP)		;ALSO R2.

	CALL	CLRFQB
	MOVB	#UU.ERR,FIRQB+FQFUN	;DETERMINE THE ERROR
	MOVB	IOERR,FIRQB+FQERNO	;WHAT ERROR?
	.UUO

	MOV	#FIRQB+5,R0		;START OF TEXT IN
	MOV	#20$,R1			;START OF TEXT OUT
	MOV	#28.,R2			;MAX NUMBER OF CHARS + 1

30$:	MOVB	(R0)+,(R1)+		;COPY IT
	BEQ	40$			;I'M DONE IF YOU ARE
	SOB	R2,30$			;DO IT AGAIN?

40$:	CLRB	-(R1)			;END WITH 0
	MOV	#10$,R0			;BUFFER ADDRESS TO R0
	CALL	ASCIZ0			;TYPE IT

	MESSAG	<" - called from ">	;INDICATE WHO CALLED US
	MOV	6(SP),R0		;GET THE RETURN ADDRESS
	CALL	OCTWRD			;PRINT IT IN OCTAL
	CALL	TYPECR			;END WITH <CR>

	MOV	(SP)+,R2		;RESTORE R2,
	MOV	(SP)+,R1		; R1, AND
	MOV	(SP)+,R0		; R0.

	RETURN

.DSABL	LSB

.SBTTL	BLKMOV:	MOVE LOTS OF STUFF FROM HERE TO THERE
;+
; BLKMOV -- MOVE DATA FROM HERE TO THERE
;  CALL	BLKMOV
;
;  PASSED:	R0 = SOURCE ADDRESS
;		R1 = DESTINATION ADDRESS
;		R2 = NUMBER OF WORDS TO TRANSFER
;
;	ALL REGISTERS PRESERVED
;	NOTHING RETURNED
;-
.ENABL	LSB

BLKMOV:	REGSCR			;SAVE SOME REGISTERS

10$:	MOV	(R0)+,(R1)+
	SOB	R2,10$
	RETURN

.DSABL	LSB

.SBTTL	DATCHK - COMPARE THE DATA IN TWO BUFFERS (FOR RFUN.C)

;+
; DATCHK: COMPARE THE DATA IN TWO BUFFERS
;
; CALL DATCHK
;
; DATA PASSED--
;	R0=ADDRESS OF FIRST BUFFER
;	R1=ADDRESS OF SECOND BUFFER
;	R2=NUMBER OF WORDS TO COMPARE
; BACK--
;	C=0 ALL IS EQUAL
;	C=1 NOT ALL IS EQUAL
;	R0, R1, AND R2 ARE DESTROYED!!!
;-
.ENABL	LSB

DATCHK:	CMP	(R0)+,(R1)+	;ARE THEY THE SAME?
	BNE	10$		; NO
	SOB	R2,DATCHK	;ELSE CONTINUE
;CLC				;RETURN WITH CARRY CLEAR (FROM 'SOB')
	TST	(PC)+		;ALL DONE AND GOOD
10$:	SEC			;RETURN WITH CARRY SET
	RETURN

.DSABL	LSB


.SBTTL	FIND DCS (GETDVC)
;+
; GETDVC - GET DEVICE CLUSTER SIZE FOR DISK AND UNIT
;
; CALL:	CALL	GETDVC,R5
;	
;	FAKED TO MAKE INIDSI HAPPY
;-
GETDVC::CMP	(R5)+,(R5)+	;SKIP OVER PARAMETERS
	TST	(R5)+		;
	RETURN	R5

GLOBAL	<DSKDCS>


.SBTTL	SET UP SAT PARAMETERS (SETSAT)
;+
; SETSAT - SET UP TABLE OF SAT PARAMETERS
;
; CALL:	CALL	SETSAT
;
; BACK:	SAT TABLES SET UP:
;	SATSYS CONTAINS INFO FOR SYSTEM DISK (NOT INCLUDING SWAP DISKS)
;		+ SEGS = NUMBER OF BLOCKS IN SAT (ROUNDED TO PACK CLUS)
;		+ BYTS = NUMBER OF BYTES IN SAT (512.*SEGS)
;		+ BITS = NUMBER OF BITS IN SAT = # OF PACK CLUS IN SAT
;			 = DISK SIZE-1/PCS
;-
SETSAT::REGSCR			;SAVE ALL REGS
SETST0:	MOV	SYSNDX,R3	;GET THE SYSTEM DISK INDEX
	MOV	SYSUNT,R5	;GET UNIT
	ASL	R5		;TIMES 2
	MOV	D.SIZL,R1	;GET DISK SIZE (LSB)
	MOV	D.SIZM,R0	;GET DISK SIZE (MSB)
	MOV	PCS,R5		;PACK CLUSTER SIZE
	SUB	R5,R1		;SUBTRACT PCS BLOCKS USED IN CLU 0
	SBC	R0
20$:	ASR	R5		;DIVIDE SIZE BY PCS
	BCS	30$		;TIL CARRY SETS
	;CLC
	ROR	R0		;SHIFT SIZE RIGHT
	ROR	R1
	BR	20$		;HANG IN THERE

30$:	MOV	R1,SATSYS+BITS	;SAVE NUMBER OF PACK CLUSTERS
	CLR	R0		;SET UP FOR DIVIDE
	ADD	#7777,R1	;ROUND UP BY 4095 AND
	ADC	R0
	ASHC	#-12.,R0	; DIVIDE BY 4096. BITS PER BLOCK
	MOV	R1,SATSYN	;SAVE NUMBER OF BLOCKS WITH FREE CLUS
	CALL	FIXCLU		;ROUND UP TO NEAREST CLUSTER @PCS
	CMP	R1,#16.		; LARGE disk with > 16 blocks?		;016
	BLOS	35$		; NO, so continue			;016
	MOV	#16.,R1		; yes, so set to 16			;016
35$:	MOV	R1,SATSYS+SEGS	;STORE  # BLOCKS IN SYS DISK SAT
	MUL	#512.,R1	;   at 512. bytes per block
	MOV	R1,SATSYS+BYTS	;   gives # bytes in sys disk SAT
	RETURN

GLOBAL	<SYSNDX,SYSUNT,PCS,SATSYN>

.SBTTL	XXRSET:	RESET AND OPEN A CHANNEL

;+
; MXRSET: TO MATCH INIT ROUTINE (SAME AS XXRSET ONLINE)
; XXRSET: RESET AND OPEN A CHANNEL
;
;  ** THIS ROUTINE IS TOTALLY UNLIKE THE INIT ROUTINE OF THE SAME NAME **
;
;CALL:	CALL XXRSET
;
;	NO DATA IS PASSED EXPLICITLY-- IT IS LYING AROUND IN VARIOUS TABLES.
;	NO PARTICULAR DATA IS RETURNED!!
;
;ERROR: C=1 IF CAN'T OPEN THE DEVICE.
;
;-
.ENABL	LSB

MXRSET::
XXRSET::REGSCR				;FREE UP SOME REGISTERS
	TSTB	OPNFLG			;IS THIS AN 'ERROR RESET' CALL
	BNE	50$			;YES
	CALL	RESET			;RESET THIS CHANNEL
	CALLX	CLRXRB			;RESET XRB
	MOVB	#OPNFQ,FIRQB+FQFUN	;SET OPEN FUNCTION CODE.
	MOVB	CHANO,FIRQB+FQFIL	;OPEN CURRENT CHANNEL.
	MOV	SYSNDX,R0		;GET DISK INDEX.
	MOV	DSKNAM(R0),FIRQB+FQDEV	;PLUG IN DISK NAME.
	MOVB	SYSUNT,FIRQB+FQDEVN	;ADD UNIT NUMBER.
	MOVB	#-1.,FIRQB+FQDEVN+1.	;FLAG IT REAL.
	MOV	OPNMOD,FIRQB+FQMODE	;SET THE MODE 
	BIS	#100000,FIRQB+FQMODE	;FOR REAL
	CALFIP				;DO IT.
	TSTB	FIRQB			;ANY ERRORS?
	BNE	20$			; OOPS
	BIT	#DDWLO,FIRQB+FQFLAG	;DO WE HAVE WRITE ACCESS?
	BEQ	20$			; YES, SO CONTINUE
	CALL	RESET			;ELSE CLOSE THE CHANNEL
	MOVB	#NOTAVL,FIRQB		; AND COMPLAIN LOUDLY
20$:	MOVB	FIRQB,IOERR	;ERROR?
	CLC			;ASSUME NO ERROR
	BEQ	50$		;OK
	CMPB	FIRQB,#NOTAVL	;DEVICE NOT AVAILABLE?
	BNE	30$		;NOPE
	MESSAG	<<177><200>"%%% ">
	MOV	SYSNDX,R0	;WHAT DEVICE?
	MOV	DSKNAM(R0),R2	;PUT THE NAME IN R2
	CALL	TYPE2		;TYPE IT OUT
	MOVB	SYSUNT,R2	;THEN GET UNIT NUMBER
	BIS	#60,R2		;MAKE IT ASCII
	CALL	TYPE		;TYPE IT OUT
	MESSAG	<": -- Device not available"<200>>
	BR	40$

30$:	;CALL TYPER		;PRINT THE MESSAGE (DEBUG)
40$:	SEC			;FLAG ERROR HAPPENED
50$:	RETURN

RESET:	CALLX	CLRXRB		   ;CLEAN THE FIRQB
	MOVB	#RSTFQ,FIRQB+FQFUN ;SET RESET FUNCTION CODE
	MOVB	CHANO,FIRQB+FQFIL  ;PURGE CURRENT CHANNEL
	CALFIP			   ;NO ERRORS POSSIBLE
	RETURN

GLOBAL	<CHANO>
.DSABL	LSB

.SBTTL	DATA AREA

DSKNAM::$DISKS
	 .WORD	"NAME
.ENDM
    	 .WORD	0

SATSYS::.WORD	0		;* + SEGS = # OF BLOCKS
	.WORD	0		;* + BYTS = # OF BYTES
	.WORD	0		;* + BITS = # OF BITS OR CLUSTER @PCS
SATSYN::.WORD	0		;# OF CLUSTERS OF SAT THAT ARE USEFUL

FIBIDX::			;FIBUF DISK INDEX SAME AS SYSTEM DISK INDEX
SYSNDX::.WORD	0		;SYSTEM DISK INDEX.
FIBUNT::			;FIBUF DISK UNIT NUMBER SAME AS SYS DISK
SYSUNT::.WORD	0		;SYSTEM DISK UNIT NUMBER
DCS::	.WORD	0		;SYSTEM DISK DEVICE CLUSTER SIZE
PCS::	.WORD	0		;SYSTEM DISK PACK CLUSTER SIZE
CLURAT::.WORD	0		;CLUSTER RATIO = PCS/DEVICE CLUSTER SIZE
I.DATE::.WORD	0		;HOLDER FOR DATE
I.TIME::.WORD	0		;HOLDER FOR TIME
CHANO:	.BYTE	1*2		;CHANNEL #1 FOR OPEN AND CLOSE
	.EVEN

FIBPHS::.WORD	0,0	;BLOCK NUMBER CURRENTLY IN 'FIBUF'

FIPCLU::.WORD	0	;CURRENT FILE CLUSTER SIZE
FIPMUC::.WORD	0	;CURRENT MFD/UFD CLUSTER SIZE

;****** FIBUNT,FIBSTA ARE GROUPED
	.EVEN
	.BYTE	0	;FIBUNT: UNIT # OF BLOCK CURRENTLY IN 'FIBUF'
FIBMOD::
FIBSTA::.BYTE	0	;MARKER FOR 'FIBUF' (MUST BE ODD ADDR!)

SYSPHU::.BYTE	0,0	;LOW BYTE=UNIT*2, HIGH BYTE = UNIT

.SBTTL		FIRQB'S

.MACRO	FQBGEN	TAG,NAMEXT,SIZ
.LIST
FQ'TAG::
.NLIST
	.WORD	0		;LINK (UNUSED)
	.BYTE	0,0		;FUNCTION, JOB
	.WORD	0		;CHANNEL
	.WORD	0*400+1		;PPN [0,1]
	.RAD50	"NAMEXT"	;FILE NAME & EXTENSION
	.WORD	SIZ+0		;REQUIRED SIZE (IF ANY)
	.WORD	0,0,0
	.BYTE	60,77		;STATUS, PROTECTION (?)
	.WORD	0,0,0,0		;REMAINDER OF STANDARD FIRQB

	.WORD	0		;REFRESH STATUS BITS
	.WORD	0		;CURRENT FILE SIZE
	.WORD	0		;CURRENT START CLUSTER
	.WORD	0		;PREFERRED START CLUSTER
	.WORD	0,0,0		;EXTRA WORDS FOR SCRATCH
	.WORD	0
.LIST
FC'TAG::
	.BLKW0	FCBSIZ/2	;FILE'S FCB

.NLIST
.ENDM	FQBGEN

	FQBGEN	BADB,<BADB  SYS>

	DEFORG	ONLINE

.ENABL	LSB

MESSAG::MOV	R0,-(SP)	;TYPE A MESSAGE
	MOV	(R5)+,R0	;R0 -> MESSAGE
	CALL	ASCIZ0		;PRINT IT
	MOV	(SP)+,R0	;RESTORE R0
	RETURN	R5

ASCIZ0::	MOV	R2,-(SP)
10$:	MOVB	(R0)+,R2	;NULL?
	BEQ	30$		;YES, END
	CALLX	TYPE		;TYPE IT
	BR	10$

20$:	MOV	(R2),R2		;FOR SPECIAL TYPING, GET THE BYTES
	CALL	TYPE2		;DO THE TYPING (CALL TO 20$ SAVES R2)
30$:	MOV	(SP)+,R2	;RESTORE R2
	RETURN

RCTRLO::CALL	CLRXRB
	MOVB	#2,XRB+7	; .SPEC CALL, 2=TTYHND
	.SPEC			; CANCEL CTRL-O
	RETURN			;DONE

TYPECR::CALL	20$,R2		;TYPE <CR><LF> STRING
	 .BYTE	CR,LF		;THIS IS IT

TYPE2::	CALL	TYPE		;TYPE ONE
	SWAB	R2		;GET THE OTHER
	BEQ	RTSPC		;NO SECOND CHARACTER!
TYPE::	CMPB	R2,#176		;Fill character?			;001
	BEQ	RTSPC		;Yes, so don't print it			;001
	CMPB	R2,#177		;RESET ^O HERE?
	BEQ	RCTRLO		;YUP, GO DO IT
	CMPB	R2,#200		;TYPE <CR><LF>?
	BEQ	TYPECR		;YES
	MOV	R2,TBUF		; CHAR TO WRITE
	CALL	CLRXRB
	MOV	#1,XRB+XRLEN
	MOV	#1,XRB+XRBC
	MOV	#TBUF,XRB+XRLOC	; WRITE FROM ONE WORD BUFFER
	.WRITE
RTSPC:	RETURN			;DONE

TYPTAB::CALL	20$,R2		;TYPE A TAB ONLY
	.BYTE	TAB,0
TBUF:	.WORD	0
.DSABL	LSB

.SBTTL	ASKER - QUESTION ASKER
;+
; ASKER - ASK A QUESTION AND GET AN ANSWER
;
;	CALL	ASKER,R5,<PTR TO SHORT TEXT, PTR TO LONG TEXT>
;
;	R1 -> ANSWER TEXT (ON WORD BOUNDARY)
;
;	Z=1, C=1 IFF ^Z TYPED
;	Z=1, C=0 IFF LINE FEED TYPED
;	N=1      IFF ^ TYPED						;008
;	Z=0, C=0 OTHERWISE
;
; NOTE:	TYPES SHORT TEXT, GETS ANSWER IN KBUFF.
;	IF ANSWER IS ?, TYPES LONG TEXT AND REPEATS
;-

ASKER::	MOV	(R5)+,20$	;GET SHORT QUESTION FORM
10$:	CALL	RCTRLO		;FORCE RESET OF ^O
	CALL	MESSAG,R5	;TYPE A MESSAGE
20$:	 .WORD	0		;MESSAGE TEXT POINTER
	MOV	(R5),20$	;PRESET LONG FORM IN CASE HELP NEEDED
	CALL	GETIN		;AND GET AN ANSWER
	BEQ	10$		;HE NEEDS HELP
	TST	(R5)+		;POP OVER LONG FORM
	CMPB	(R1),#12	;LINE FEED?
	BEQ	40$		;YES -- RETURN Z=1, C=0, N=0		;008
	CMPB	(R1),#'^	;BACKUP CHARACTER? (^)			;008
	BEQ	41$		;YES -- RETURN N=1			;008
	CMPB	(R1),#'Z-100	;^Z?
	BEQ	30$		;YES -- RETURN Z=1, C=1, N=0		;008
	TST	(PC)+		;NOTHING SPECIAL -- SET Z=0, C=0, N=0	;008
30$:	SEC			;SET CARRY FOR ^Z
40$:	RETURN	R5		;EXIT

41$:	SEN			;SET N-BIT FOR ^			;008
	RETURN R5		;EXIT					;008

GETUNQ::MOV	(R5)+,R0	;GET MATCH TEXT POINTER IN R0
	REGSAV			;SAVE REGISTERS
	MOV	R1,R4		;COPY POINTER TO PASSED TEXT
	CLR	(SP)		;CLEAR RETURNED R0
10$:	MOV	R4,R1		;RESTORE POINTER TO PASSED TEXT
20$:	MOVB	(R0)+,R3	;GET MATCH TEXT CHARACTER
	BIC	#^C<177>,R3	;ISOLATE IT
	CMPB	R3,(R1)+	;COMPARE AGAINST PASSED TEXT
	BEQ	20$		;GOT IT?
	TSTB	-(R0)		;NO MATCH. IS MATCH TEXT CHARACTER OPTIONAL?
	BMI	40$		;YES, WE PROBABLY FOUND IT
30$:	CMPB	(R0)+,#377	;NO, SKIP TO END OF THIS MATCH STRING
	BNE	30$
	ADD	#2,(SP)		;NEXT INDEX
	TSTB	(R0)		;ANY MORE MATCH TEXT?
	BNE	10$		;YES, TRY AGAIN
	SEC			;NO, INDICATE FAILURE IN CARRY
35$:	CALL	REGRES,R5	;RESTORE REGISTERS
	RETURN	R5		;BACK

40$:	TSTB	-(R1)		;FOUND DISCREPANCY AT OPTIONAL CHARACTER
	BEQ	60$		;THAT WAS THE END OF THE PASSED STRING
	CMPB	(R1),#40	;IT WASN'T THE END, SO GOTTA BE A BLANK
	BNE	30$		;NO LUCK, NOT THIS MATCH TEXT
50$:	CMPB	(R1)+,(R1)	;SCAN PAST N BLANKS
	BEQ	50$		;UNTIL R1 -> NOT A BLANK
60$:	MOVB	(R1)+,(R4)+	;MOVE THE REST OF THE STRING DOWN
	BNE	60$		;UNTIL END OF ASCIZ
	CLC			;C=0 FOR SUCCESS
	BR	35$		;GO BACK TO THE CALLER

.SBTTL	ANSWER CHECKER

;+
; ANSWER - CHECK AN ANSWER FOR Y, N, <LF>, O, OR OTHER
;
;	R1 -> ANSWER TO CHECK
;
;	CALL	ANSWER,R5
;
;	 RETURN+0 - 'Y' RETURN
;	 RETURN+2 - 'N' RETURN
;	 RETURN+4 - LF  RETURN
;	 RETURN+6 - 'O' RETURN
;	 RETURN+10- OTHER
;-

.MACRO	UNQTXT	TEXT
.NLIST
.DSABL	CRF
$$$$$$	= 0
.IRPC	X,<TEXT>
.IF EQ	''X-'\
$$$$$$	= 200
.IFF
	 .BYTE	''X+$$$$$$
.ENDC
.ENDM
	 .BYTE	377
.ENABL	CRF
.LIST
.ENDM	UNQTXT

ANSWER::MOV	R0,-(SP)	;SAVE R0
	CALLX	GETUNQ,R5	;PARSE THE ANSWER
	 GENTXT
	 UNQTXT	<Y\ES>		;0 YES
	 UNQTXT	<N\O>		;2 NO
	 .BYTE	12,377		;4 <LF>
	 UNQTXT	<O\LD>		;6 OLD
	 .BYTE	0		;10 OTHER
	 UNORG
	ADD	R0,R5		;BUMP RETURN ADDRESS PROPERLY
	MOV	(SP)+,R0	;RESTORE R0
	;CLC			;C=0 FROM 'ADD' ABOVE
	RETURN	R5

.SBTTL	INPUT A LINE

GETIN::	REGSAV
	CALL	INPLIN,R5,<KBUFF>
	BCC	5$		; NO ERROR, BRANCH.
	MOV	#"^Z,(R5)	; ASSUME CTRL-Z
5$:
	MOV	R5,TOS.R1(SP)	;RETURN TO CALLER IN R1
	CMPB	(R5),#CR	;PURE <CR>?
	BNE	10$		;NO
	MOV	(PC)+,(R5)	;YES, MAKE IT A PURE LF			;006
	.BYTE	LF,0							;006
10$:	CMP	(R5),#LF	;PURE LINE FEED?
	BEQ	20$		;YUP, RETURN LINE FEED
	MOV	#4+10+20+40+200+1000,R0					;005
	CALLX	CVT$$
20$:	CMP	(R5),#"^Z	;FAKE CTRL/Z?
	BNE	30$		;NO
	MOV	#'Z-100,(R5)
30$:	CALLX	EQU$$,R4,70$	;CHECK FOR <LF>
	BNE	40$		;NOPE
	MOV	#12,KBUFF	;YES, RESET TO TRUE LINE FEED
40$:	CALL	REGRES,R5	;RESTORE REGISTERS
	CMP	(R1),#"^C	;CONTROL C?
	BEQ	60$		;YES, TIME TO GO AWAY
	CMP	(R1),#'?	;QUESTION MARK? SET Z=1 IF TRUE)	;006
	CLC			;ALWAYS RETURN WITH C-BIT CLEAR		;006
50$:	RETURN

60$:
	JMP	DSKABT

70$:	.ASCIZ	"<LF>"
	.EVEN

KBUFF::	.BLKB	100.

.SBTTL	OCTAL PRINTERS

;+
; OCTWRD - PRINT AN OCTAL NUMBER (6 DIGITS)
; OCTBYT - PRINT AN OCTAL BYTE (3 DIGITS)
; OCT3DG - PRINT 3-DIGIT OCTAL NUMBER
; OCT4DG - PRINT 4-DIGIT OCTAL NUMBER
;
;	R0 =  NUMBER TO PRINT
;
;	CALL	OCT???
;-

.ENABL	LSB

OCTWRD::REGSCR			;SAVE REGS
	MOV	#6,R1		;COUNT IS 6
	BR	20$		;DO IT

OCT4DG::REGSCR			;SAVE REGISTERS
	MOV	#4,R1		;PRINT LOW 4 DIGITS
	BR	20$

OCT3DG::REGSCR			;SAVE REGS
	BR	10$		;AND DO 3 DIGITS

OCTBYT::REGSCR			;SAVE REGS
	BIC	#^C<377>,R0	;CLEAR OTHER BITS
10$:	MOV	#3,R1		;COUNT IS 3
20$:	MOV	#-1,-(SP)	;SET STOPPER FLAG
30$:	MOV	R0,-(SP)	;MOVE BITS TO STACK
	BIC	#^C<7>,(SP)	;ISOLATE BOTTOM OCTAL DIGIT
	ADD	#'0,(SP)	;MAKE IT ASCII
	;CLC			;ADD CLEARS THE CARRY
	ROR	R0		;SHIFT RIGHT 3 BITS
	ASR	R0
	ASR	R0
	SOB	R1,30$		;CONTINUE FOR ALL DIGITS
40$:	MOV	(SP)+,R2	;GET A DIGIT
	BMI	50$		;DONE
	CALL	TYPE		;TYPE IT
	BR	40$		;CONTINUE

50$:	RETURN

.DSABL	LSB

.SBTTL	DECIMAL PRINTERS

;+
; DBLPRT - PRINT DOUBLE-PREC NUMBER IN DECIMAL, BLANK FILL
; DBLZER - PRINT DOUBLE-PREC NUMBER IN DECIMAL, NO BLANKS
;
;	R2 = NUMBER TO PRINT (LSB)
;	R3 = NUMBER TO PRINT (MSB)
;
;	CALL	DBL???
;-

.ENABL	LSB

DBLPRT::REGSCR			;SAVE REGISTERS
	MOV	#6,R5		;PRINT INTO A COLUMN 6 SPACES WIDE
	BR	10$

DBLZER::REGSCR			;SAVE REGISTERS
	CLR	R5		;DON'T ADD ANY LEADING SPACES
10$:	MOV	R2,R1		;MOVE LSB TO WHERE WE CAN WORK ON IT
	BR	30$

;+
; DECPRT - PRINT NUMBER IN DECIMAL WITH LEADING BLANKS
; DECZER - PRINT NUMBER IN DECIMAL, BLANK SUPPRESSED
; P4DDIG - PRINT 4-DIGIT NUMBER IN DECIMAL, BLANK FILL
;
;	R0 = NUMBER TO PRINT
;
;	CALL	DEC???
;-

DECPRT::REGSCR			;SAVE REGISTERS
	MOV	#6,R5		;PRINT INTO A COLUMN 6 SPACES WIDE
	BR	20$

P4DDIG::REGSCR			;SAVE REGISTERS
	MOV	#4,R5		;PRINT INTO A COLUMN 4 SPACES WIDE
	BR	20$

DECZER::REGSCR			;SAVE REGISTERS
	CLR	R5		;DON'T ADD ANY LEADING SPACES
20$:	CLR	R3		;MSB ARGUMENT IS ZERO
	MOV	R0,R1		;MOVE LSB TO WHERE WE CAN WORK ON IT

; R1 = LSB OF NUMBER TO BE PRINTED
; R3 = MSB OF NUMBER TO BE PRINTED
; R5 = MINIMUM WIDTH OF COLUMN TO PRINT
;
; DIVIDE THE NUMBER BY 10 (AT LEAST ONCE) UNTIL THE QUOTIENT IS ZERO,
; AND PUSH THE REMAINDERS ON THE STACK.  THESE ARE THE DIGITS OF THE
; NUMBER'S DECIMAL REPRESENTATION, FROM RIGHT TO LEFT.
; R4 WILL COUNT THE DIGITS PUSHED.

30$:	MOV	#TYPE,80$	;OUTPUT BY TYPING
40$:	CLR	R4		;NO DIGITS PUSHED YET
	CLR	R2		;HIGH-HIGH ORDER = 0
	ASL	R1		;KEEP ONLY 15 BITS IN LOW WORD
	ROL	R3		;OVERFLOW INTO HIGH WORDS
	ROL	R2
	ROR	R1		;LOW WORD IS KEPT RIGHT-JUSTIFIED
50$:	DIV	#10.,R2		;DIVIDE MSB IN R3, BY 10.  Q -> R2, R -> R3
	MOV	R3,R0		;REMAINDER < 10 IS HIGH WORD FOR NEXT DIV
	MOV	R2,R3		;QUOTIENT IS USED NEXT TIME THRU LOOP
	CLR	R2		;HIGH-HIGH IS ZERO NEXT TIME
	ASL	R1		;LEFT-ADJUST 15-BIT LSB
	ASHC	#-1,R0		;TO PACK SO QUOTIENT FITS IN 15 BITS
	DIV	#10.,R0		;DIVIDE LSB BY 10. Q -> R0, R -> R1
	MOV	R1,-(SP)	;PUSH THE REMAINDER (IT'S A DIGIT)
	INC	R4		;COUNT DIGITS PUSHED
	MOV	R0,R1		;QUOTIENT IS USED NEXT TIME THRU LOOP
	BIS	R3,R0		;IS ENTIRE NUMBER NOW ZERO?
	BNE	50$		;REPEAT UNTIL IT IS ZERO
	SUB	R4,R5		;WIDTH - DIGITS => NUMBER OF LEADING BLANKS
	BLOS	70$		;NO SPACES IF DIGITS >= COLUMN SIZE
	MOV	#SPACE,R2
60$:	CALL	TYPE		;TYPE SPACES
	SOB	R5,60$		;REPEATEDLY

; UNSTACK AND PRINT THE DIGITS (WE KNOW THERE'S AT LEAST ONE)

70$:	MOV	(SP)+,R2	;UNSTACK A DIGIT
	ADD	#'0,R2		;MAKE ASCII
	CALL	@(PC)+		;EMIT IT
80$:	 .WORD	TYPE		;ROUTINE IS TYPE OR BYTE MOVER
	SOB	R4,70$		;REPEAT
	RETURN

;+
; DECSTR - CONVERT TO ASCII AND STORE STRING IN MESSAGE
;
;	R0 =  NUMBER TO PRINT
;	R1 -> 6-BYTE AREA TO STORE STRING, PADDED WITH 176'S
;
;	CALL	DECSTR
;-

DECSTR::REGSCR			;SAVE REGISTERS
	MOV	R1,110$		;SAVE STARTING ADDRESS FOR OUTPUT
	MOV	#6,R5		;COUNT SIX BYTES TO FILL
90$:	MOVB	#176,(R1)+	;PRE-FILL WITH IGNORE CHARACTERS
	SOB	R5,90$		; AND DON'T DO FILLS
	;CLR	R5		;NO LEFT-BLANKS
	CLR	R3		;MSB ARGUMENT IS ZERO
	MOV	R0,R1		;MOVE LSB TO WHERE WE CAN WORK ON IT
	MOV	#100$,80$	;CALL BYTE MOVER, NOT BYTE TYPER
	BR	40$		;ENTER MAIN LOOP

100$:	MOVB	R2,@(PC)+	;OUTPUT A BYTE
110$:	 .WORD	0		; TO THE CALLER'S STRING
	INC	110$		;NEXT BYTE
	RETURN

.DSABL	LSB

.SBTTL	RAD50 PRINTERS

;+
; RADPRT - PRINT RAD50 WORD
; RADZER - PRINT RAD50 WORD W/ BLANKS SUPPRESSED
;
;	R0 =  RAD50 WORD
;
;	CALL	RAD???
;-

.ENABL	LSB

RADPRT::REGSCR			;SAVE REGISTERS
	MOV	#SPACE,R5	;FILLER IS SPACE FOR 0
	BR	20$

RADZER::REGSCR			;SAVE REGISTERS
10$:	CLR	R5		;SUPPRESS SPACES
20$:	MOV	#90$,R1		;POINT TO TABLE OF DIVISORS
	MOV	R0,R3		;COPY THE WORD TO PRINT
30$:	CLR	R2		;CLEAR FOR DIVIDE
	DIV	(R1)+,R2	;DIVIDE
	;TST	R2		;IS THE RESULT A SPACE? (FROM DIVIDE)
	BNE	40$		;NO
	MOV	R5,R2		;YES, MAKE IT BLANK (MAYBE)
	BEQ	70$		;NO, IGNORE NULLS
	BR	60$		;YES, PRINT IT

40$:	CMP	R2,#26.		;ALPHABETIC?
	BHI	50$		;NO
	ADD	#'A-1,R2	;YES, MAKE IT ASCII
	BR	60$		;AND TYPE IT

50$:	MOVB	80$-27.(R2),R2	;GET SPECIAL CHARACTER OR DIGIT
60$:	CALL	TYPE		;TYPE IT AND RETURN
70$:	TST	(R1)		;ANY MORE TO DO?
	BNE	30$		;YES, LOOP ON IT
	RETURN

	I.MESS
80$:	.ASCII	"$.?0123456789"	;RAD50 TRANSLATION FOR 27.-39.
	UNORG

90$:	.WORD	50*50,50,1,0	;DIVISORS FOR RADIX 50 CONVERSION

.DSABL	LSB

.SBTTL	OCTAL & DECIMAL INPUTTERS

;+
; OCTINP - TRANSLATE AN OCTAL NUMBER
; DECINP - TRANSLATE A DECIMAL NUMBER
;
;	R1 -> STRING TO TRANSLATE
;
;	CALL ???INP
;
;	R0 = VALUE
;	R1 = UPDATED POINTER
;	CONDITION CODES SET FROM TSTB OF ENDING CHARACTER
;		(Z=1 MEANS NULL BYTE, USUALLY DESIRED)
;
;	SCAN STOPS ON CHARACTER ILLEGAL FOR SPECIFIED RADIX OR
;		IF OVERFLOW IS ENCOUNTERED
;-

OCTINP::TST	(PC)+		;CLEAR CARRY
DECINP::SEC			;SET CARRY
	REGSAV			;SAVE REGISTERS
	MOV	#4,R5		;R5 = RADIX/2
	ADC	R5		;10. IF ENTERED AT DECINP
	ASL	R5		;R5 = RADIX
	CLR	R3		;CLEAR THE ACCUMULATOR
10$:	MOVB	(R1)+,R0	;GET NEXT BYTE
	SUB	#'0,R0		;CONVERT FROM ASCII
	CMP	R0,R5		;CHECK AGAINST RADIX
	BHIS	20$		;TOO BIG TO BE A DIGIT
	MOV	R3,R2		;PUT OLD VALUE WHERE WE CAN MULTIPLY
	MUL	R5,R2		;PRODUCT MSB -> R2, LSB -> R3
	TST	R2		;DID ANY HIGH-ORDER BITS COME ON?
	BNE	20$		;YES -- UNSIGNED OVERFLOW
	ADD	R0,R3		;ADD IN NEW DIGIT
	BCC	10$		;GOOD, GO FOR ANOTHER BYTE
20$:	MOV	R3,TOS.R0(SP)	;RETURN VALUE IN R0
INPDNE:	MOV	R1,TOS.R1(SP)	;RETURN UPDATED POINTER IN R1
	CALL	REGRES,R5	;RESTORE REGISTERS
	TSTB	-(R1)		;POINT TO UNUSED CHAR, SET CONDITION CODES
	RETURN

.SBTTL	DOUBLE PRECISION DECIMAL INPUTTER

;+
; DBLINP - SCAN OFF A DOUBLE PRECISION DECIMAL NUMBER
;
;	R1 -> STRING TO SCAN
;
;	CALL DBLINP
;
;	R1 -> FIRST UNSCANNED BYTE
;	R2 =  VALUE (LSB)
;	R3 =  VALUE (MSB)
;	CONDITION CODES SET FROM TSTB OF ENDING CHARACTER
;		(Z=1 MEANS NULL BYTE, USUALLY DESIRED)
;
;	SCAN STOPS ON CHARACTER ILLEGAL FOR SPECIFIED RADIX OR
;		IF OVERFLOW IS ENCOUNTERED
;-

DBLINP::REGSAV			;SAVE REGISTERS
	CLR	R2		;CLEAR ACCUMULATOR
	CLR	R3
	CLR	-(SP)		;ALLOCATE SPACE FOR DIGIT
10$:	MOVB	(R1)+,(SP)	;GET A DIGIT
	SUB	#'0,(SP)	;REDUCE ASCII DIGITS TO RANGE 0-9
	MOV	#9.,R0		;SET COUNTER FOR ADD LOOP BELOW
	CMP	(SP),R0		;IS THE CHARACTER LEGAL?
	BHI	30$		;NO -- RETURN
	MOV	R3,R5		;COPY PARTIAL RESULT FOR ADDING
	MOV	R2,R4
20$:	ADD	R4,R2		;ADD LSB
	ADC	R3
	BCS	30$		;SKIP OUT ON UNSIGNED OVERFLOW
	ADD	R5,R3		;ADD MSB
	BCS	30$		;SKIP OUT ON UNSIGNED OVERFLOW
	SOB	R0,20$		;ADD 9 TIMES TO MAKE 10X TOTAL
	ADD	(SP),R2		;ADD THE DIGIT
	ADC	R3
	BCC	10$		;GET THE NEXT DIGIT
30$:	TST	(SP)+		;REMOVE TEMP SPACE FROM STACK
	MOV	R2,TOS.R2(SP)	;SAVE ON STACK TO RETURN IN REGISTERS
	MOV	R3,TOS.R3(SP)
	BR	INPDNE		;GO RETURN PROPERLY

.SBTTL	RAD50 INPUTTER

;+
; RADINP - SCAN AND CONVERT 2 WORDS OF RADIX 50
; RADWRD - SCAN AND CONVERT 1 WORD  OF RADIX 50
;
;	R1 -> STRING TO SCAN
;
;	CALL	RAD???
;
;	R0 =  FIRST 3 CHARACTERS
;	R1 -> FIRST UNSCANNED CHARACTER
;	R3 =  NEXT 3 CHARACTERS IFF RADINP
;
;	SCAN STOPS AT FIRST NON-RAD50 CHARACTER OR AFTER 3 (OR 6)
;		CHARACTERS HAVE BEEN SCANNED
;	ONLY LETTERS AND DIGITS ARE ALLOWED
;-

.ENABL	LSB

RADINP::REGSCR			;SAVE REGISTERS
	CALL	RADWRD		;GET A WORD
	MOV	R0,TOS.R0(SP)	;RETURN IT IN R0 ON EXIT
	CALL	RADWRD		;GET ANUDDER
	MOV	R0,TOS.R3(SP)	;RETURN IT IN R3 ON EXIT
	BR	10$		;AND EXIT

RADWRD::REGSCR			;SAVE REGISTERS
	CLR	R3		;CLEAR RETURN VALUE
	MOV	#20$,R5		;A HANDY POINTER
	CALL	(R5)		;GET 3 CHARACTERS
	CALL	(R5)
	CALL	(R5)
	MOV	R3,TOS.R0(SP)	;RETURN ANSWER IN R0 ON EXIT
10$:	MOV	R1,TOS.R1(SP)	;UPDATE R1
	RETURN

;+
; SUBROUTINE TO INPUT A SINGLE RAD50 CHARACTER, AND ADD IT TO
; THE WORD IN R3.  AFTER FINDING A NON-RAD50 CHARACTER, THE
; SUBROUTINE ADDS SPACES WHEN IT IS CALLED.
;-

20$:	MOVB	(R1)+,R0	;GET A CHARACTER
	SUB	#'0,R0		;REDUCE DIGITS TO RANGE 0-9
	CMP	R0,#9.		;IS THIS ONE?
	BHI	30$		;NO -- IT MUST BE A LETTER
	ADD	#30.,R0		;YES -- RAD50 DIGITS ARE 30.-39.
	BR	50$		;GO ACCUMULATE

30$:	ADD	#'0-'A+1,R0	;REDUCE LETTERS TO RANGE 1-26.
	BEQ	40$		;ZERO IS ILLEGAL
	CMP	R0,#26.		;IS THIS A LETTER?
	BLOS	50$		;YES -- GO ACCUMULATE

40$:	DEC	R1		;LEAVE R1 POINTING AT THE BAD CHARACTER
	CLR	R0		;AND USE A SPACE INSTEAD
50$:	MUL	#50,R3		;'SHIFT LEFT' THE OLD VALUE
	ADD	R0,R3		;AND ADD IN THE NEW CHARACTER
	RETURN			;EXIT

.DSABL	LSB

;+
; INPLIN - INPUT A LINE FROM THE TERMINAL
;
; CALL:	CALL	INPLIN,R5,<BUFFER>
;
; BACK:	R5 -> BUFFER
;	STRING READ FROM TELETYPE, TERMINATED WITH LF, ESC, OR FF
;	STRING MADE ASCIZ, BUT DELIMITER NOT STRIPPED
;
; NOTE:	NO SIZE CHECKING DONE
;-

INPLIN::MOV	R0,-(SP)	;SAVE R0
	MOV	R5,-(SP)	;SAVE R5
	MOV	(R5),R5		;R5 -> BUFFER
10$:	CALL	$TTYIN		; GET A CHAR
	BCS	30$		; CTRL-Z ??
	MOVB	R0,(R5)+	;SET IT
	CMPB	R0,#12		;LF?
	BEQ	20$
	CMPB	R0,#33		;ESC?
	BEQ	20$
	CMPB	R0,#14		;FF?
	BNE	10$
20$:	CLRB	(R5)		;SET TERMINATOR
	MOV	(SP)+,R5	;RESTORE R5
	MOV	(SP)+,R0	;RESTORE R0
	MOV	(R5)+,(SP)	;RETURN R5 -> BUFFER
	CLC
	RETURN	R5
30$:	MOV	(SP)+,R5	; ERROR RETURN
	MOV	(SP)+,R0
	MOV	(R5)+,(SP)	; RETURN BUFFER ADDR IN R5
	SEC
	RETURN	R5

;+
; $TTYIN - EMULATE THE RT11 .TTYIN CALL
;
;	CALLX	$TTYIN
;
;	R0 =  CHARACTER
;	XRB   IS DESTROYED
;
;	C=1 AND R0=0  IF ERROR ON READ (I.E. CONTROL Z)
;
;-

	.DSABL	LSB

$TTYIN::CLR	-(SP)		; MAKE ROOM FOR THE CHARACTER ON THE STACK
	CALL	CLRXRB		;
	MOV	#1,XRB+0	; SAY WE WANT  TO READ 1 CHARACTER
	MOV	SP,XRB+XRLOC	; SET THE ADDRESS OF THE BUFFER
	.READ			; READ FROM THE TERMINAL, 1 BYTE
	TSTB	FIRQB		; WAS THERE AN ERROR ON THE READ?
	BEQ	10$		; NO, CONTINUE WITH NORMAL PROCESSING
	CLR	(SP)		; CLEAR ANY GARBAGE THAT MAY HAVE COME IN
	SEC			; SET THE CARRY BIT TO FLAG THE ERROR
10$:	MOV	(SP)+,R0	; PLACE THE CHARACTER INTO R0
	RETURN			;  AND RETURN TO THE CALLER


;+
; INIWRD - FETCH A WORD FROM INIT.SYS
;
;	R2 =  MSB OF BYTE ADDRESS WITHIN INIT
;	R3 =  LSB OF BYTE ADDRESS WITHIN INIT
;
;	CALL	INIWRD
;
;	(SP) = THE WORD
;-

INIWRD::MOV	(SP),-(SP)	;MAKE ROOM FOR RETURNED VALUE
	MOV	R0,-(SP)	;GET A WORKING REGISTER
	MOV	R2,-(SP)	;DON'T LOSE R2
	MOV	R3,-(SP)	; OR R3, EITHER
	CALLX	CLRXRB		;CLEAR THE XRB
	DIV	#512.,R2	;DIVIDE BY 512 TO GET THE BLOCK NUMBER
	MOV	R2,R0		;R0=BLOCK TO GET
	INC	R0		;PHYSICAL BLOCK NUMBER
	MOV	(SP)+,R3	;RESTORE R3
	MOV	(SP)+,R2	;LIKEWISE R2
	CMP	R0,SATBLK	;DO WE ALREADY HAVE THIS BLOCK?
	BEQ	10$		;YEP
	MOV	R0,SATBLK	;MARK IT AS READ
	MOV	#512.,XRB+XRLEN	;FETCH ONE BLOCK
	MOV	#SATBUF,XRB+XRLOC	;BUFFER IS SATBUF
	MOV	#2*16,XRB+XRCI	;CHANNEL 14
	MOV	R0,XRB+XRBLK	;BLOCK TO GET
	.READ			;DO IT
	TST	FIRQB		;DID WE ERROR?
	BNE	20$		;YES

10$:	MOV	R3,R0		;COPY THE LSB OF THE ADDRESS
	BIC	#^C<777>,R0	;ISOLATE OFFSET IN BLOCK
	MOV	SATBUF(R0),4(SP) ;RETURN VALUE ON THE STACK
	MOV	(SP)+,R0	;RESTORE REGISTER

	RETURN

20$:	MESSAGE	<"?Error reading INIT.SYS"<200>>
	JMP	DSKABT		;die




.SBTTL	DCL TESTER

;
;	IF WE ARE RUN THRU DCL, ABORT
;

TSTABT::TST	DCLENT		;IS THIS DCL?
	BNE	10$		;YES
	RETURN			;NO

10$:	JMP	DSKABT		;DIE
.DSABL	LSB

.ENABL	LSB
.SBTTL	ROOT  FAKER
	TMPORG	ONLDSI

I.INI0::EXST$S	STATUS			;Exit with status		;009

	UNORG

.SBTTL	FAKE DATA

	; FAKE DATA TO MAKE INIDSI HAPPY

	TMPORG	ONLCTL
BACKUP::.BYTE	377
	.EVEN
STRTUP::.WORD 	0
DSIFLG::.WORD 	0
OPNFLG::.WORD	0
CC.DBL::.WORD	0
HDRIDX::.WORD	0
HDRUNT::.WORD	0
NRETRY::.WORD	0
SYSNAM::.WORD	0


DSKMID::$DISKS				;MASSBUS/UNIT ID TABLE POINTERS [FIXED]
	.WORD	NAME'$MID		;NAME DISK ID TABLE
.ENDM

DV$MID::.BLKW	1
DF$MID::.BLKW	10
DS$MID::.BLKW	10
DK$MID::.BLKW	10
DL$MID::.BLKW	4
DM$MID::.BLKW	10
DP$MID::.BLKW	10
DB$MID::.BLKW	10
DU$MID::.BLKW	20
DR$MID::.BLKW	10
DZ$MID::								;012
DW$MID::.BLKW	20							;012

SUBUNT::
	$DISKS								;001
	.WORD	NAME'UNTS						;001
.ENDR

DVUNTS::.BYTE	1.		;FAKE THE MAX UNIT TABLE		;001
DFUNTS::.BYTE	8.							;001
DSUNTS::.BYTE	8.							;001
DKUNTS::.BYTE	8.							;001
DLUNTS::.BYTE	4.							;001
DMUNTS::.BYTE	8.							;001
DPUNTS::.BYTE	8.							;001
DRUNTS::.BYTE	8.							;001
DBUNTS::.BYTE	8.							;001
DZUNTS::								;012
DWUNTS::.BYTE	16.							;012
DUUNTS::.BYTE	16.							;014
	.EVEN

DSKCSR::.BLKW0	12.,177777	;FAKE CSRTBL SET TO -1's		;014



SATBLK:	.WORD	0		;BLOCK NUMBER IN THE SAT (FOR INIWRD)
BUFCNT::.WORD	0		;# WORDS TO READ/WRITE
ERRCTR::.WORD	0		;USED TO SINGLE OUT BAD BLOCK
IOERR::	.WORD	0		;I/O ERROR CODE FOR LAST SEXPAR/PARSEX
NOERR::	.WORD	0		;NOERR <> 0 TELL'S PARSEX TO RETURN W/ERROR NOT ABT.
OPNMOD::.WORD	0		;Open mode storage cell			;016
SYSUSV::.WORD	177777
SYNXSV::.WORD	177777
	UNORG

	.END	ONLDSK
