	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
	.INCLUDE /CMN:FLDEF/
TITLE	ERLDSK,<COMMON DISK ERROR LOGGING>,0A,10-MAY-91,MHB/SRM/AJK/MND/GPK/MNB/FRL/KPH

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR ERLDSK

;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;  001	SRM  19-Sep-81	Make changes for FIP Pool.
;  002  AJK  18-JAN-82  Modified DISK error logger in 2 ways:
;			1. Registers are saved upon entry.
;			2. Added MSCP data for error logging.
;  003	MND  30-AUG-82	Source clear seq. 3.7.9 from V7.2
;
;				[RSTS V9.0]
;  004	GPK  07-Jun-83	Removed BSML call
;  005  MNB  06-Feb-84  Add new DSQ -> ASYWRK -> WCB link
;  006  FRL  01-Apr-84  V9.0 logicals
;  007	KPH  16-Oct-84	Changes for APR5 FIP pool
;
;-

	DEFORG	ERLDSK



.SBTTL	COMMON DISK ERROR LOGGING

;+
; ERLDSK - COMMON DISK ERROR LOGGING.
;
;	R0 -> QUEUE ROOT
;	R3 -> CSR
;	R4 -> DSQ
;
;	CALL	ERLDSK,R5
;	  .BYTE	<ERROR CODE>
;	  .BYTE	<OVERLAPPED SEEK INDICATION>
;	  .BYTE	<STARTING REG OFFSET>,<# REGS TO SAVE>	** OPTIONAL **
;	  .BYTE	<STARTING REG OFFSET>,<# REGS TO SAVE>	** OPTIONAL **
;	  .BYTE	0,0
;
;	R0 -> OFFSET LOCATION (BYTE)
;	R1 =  RANDOM
;	R2 -> TERMINATOR (-1) +2 IN CONTROL TABLE (WORD) (2 WORDS)
;	R5 -> CONTROL TABLE FOR ERROR LOGGER
;-
ERLDSK:	CALL	SVHWRG		;;;SAVE HARDWARE REGISTERS
	MOV	#ERLTBL,R2	;;;POINT TO THE CONTROL TABLE
	MOV	R2,(SP)		;;;PRESET FOR RETURNING POINTER
	MOVB	(R5)+,(R2)+	;;;SET THE ERROR CODE
	CLRB	(R2)+		;;;ASSUME NO DSQ, THEREFORE NO JOB NUMBER
	TST	R4		;;;DO WE HAVE A DSQ?
	BEQ	10$		;;;NO
	MOVB	DSQJOB(R4),-1(R2);;;SAVE JOB NUMBER TIMES 2
10$:
	MOV	#ERLAUX,R1	;;;ALSO POINT TO SUB-TABLE
	MOV	#2*400+4,(R2)+	;;;FIELD 2, 4 WORDS
	MOV	R1,(R2)+	;;; FROM THE SUB-TABLE
	MOV	DSO$XX(R0),(R1)+ ;;;SET THE UNIT'S STATUS/TIMEOUT
	MOV	R1,-(SP)	;;;SAVE POINTER TO OFFSET LOCATION
	CLRB	(R1)+		;;;SAY NO OFFSET FOR NOW
	MOVB	(R5)+,(R1)+	;;;SET OVERLAPPED SEEK INDICATION
	CLR	(R1)+		;;;CLEAR SIZE WORDS
	CLR	(R1)+		;;;
	TST	R4		;;;DO WE HAVE A DSQ?
	BEQ	30$		;;;NO
	CMP	-(R1),-(R1)	;;;RESET TO SIZE SAVE AREA
	MOVB	DSQUNT(R4),R0	;;;GET THE FIP UNIT NUMBER
	ASL	R0		;;; TIMES 2 FOR WORD ADDRESSING
	MOV	UNTSIZ(R0),(R1)+ ;;;SET UNIT SIZE IN DC'S
	MOVB	DEVCLU(R0),(R1)+ ;;;SET DEVICE CLUSTER SIZE
	MOVB	UNTCLU(R0),(R1)+ ;;;SET PACK CLUSTER SIZE
	MOV	#2*400+5,(R2)+	;;;FIELD 2, 5 WORDS			;006
.ASSUME	DL$SIZ	EQ	10.	;NEXT THREE LINES RELY ON THIS		;006
	MOV	R0,(R2)		;;;INDEX INTO DISK TABLE		;006
	ASL	R0		;;;					;006
	ASL	R0		;;;  FROM UNIT NUMBER * 2		;006
	ADD	R0,(R2)		;;;  					;006
	ADD	#DSKLOG,(R2)+	;;;					;006
	MOV	#2*400+16.,(R2)+ ;;;FIELD 2, 16. WORDS
	MOV	R4,(R2)+	;;; OF THE DSQ
	CMP	DSQL3Q(R4),#FLDNE ;;;FILE REQUEST?
	BNE	30$		;;;NOPE
	MOV	DSQMSC(R4),R0	;;;YEP, Get XRB POINTER			;005
	MOV	XRTIME(R0),R0	;;; and from that, get the SCB/WCB ->	;005
	MOV	#2*400+16.,(R2)+ ;;;FIELD 2, 16. WORDS
	MOV	R0,(R2)+	;;; OF SCB/WCB
	MAP	PUSH,APR=6,DATA	;;;SAVE APR 6 MAPPING SO WE CAN MAP FIP POOL
	MAP	FIPPOL		;;;MAP THE FIP POOL FOR WCB'S
	BIT	(R0),#DDNFS	;;;NON-FILE STRUCTURED?
	BNE	20$		;;;YEP, NO FCB EXISTS
	MOV	W$FCB(R0),R0	;;;GET FCB POINTER @ F$CLUS
	SUB	#F$CLUS,R0	;;; THEN GET UP TO THE TOP
	MOV	#2*400+16.,(R2)+ ;;;SET FIELD 2, 16. WORDS
	MOV	R0,(R2)+	;;; OF FCB
20$:	MAP	POP,APR=6,DATA	;;;RESTORE THE OLD APR 6 MAPPING
	MAP	@#KISAR5,APR=5,DATA ;;;And restore the APR5 mapping	;007
30$:	MOV	(SP),R0		;;;LEAVE POINTER TO OFFSET LOCATION
	;JMPX	ERLCMN		;;;FINISH UP IN THE COMMON CODE



.SBTTL	COMMON DISK/DEVICE ERROR LOGGING FINISH UP

;+
; ERLCMN - COMMON DISK/DEVICE ERROR LOGGING FINISH UP.
;
; *** NOTE ***
; THIS IS THE SAME "ERLCMN" AS THE ONE IN "CMNDVR" MODULE.  THE
; DIFFERENCE IS THAT THIS ROUTINE SETS UP POINTERS TO THE REGISTER
; SAVE AREA.  THE HARDWARE REGISTERS HAD TO BE SAVED TO BE MEANINGFUL
; AS THE LOGGER EXECUTES A LOT OF CODE BEFORE ACTUALLY SAVING THE
; REGISTER CONTENETS.  THIS CAUSES LOSS OF INFORMATION.
;
;	R2 -> CONTROL TABLE
;	R3 -> CSR
;	R5 -> .BYTE <STARTING REG OFFSET>,<# REGS>	** OPTIONAL **
;	      .BYTE <STARTING REG OFFSET>,<# REGS>	** OPTIONAL **
;	      .BYTE 0,0
;	      -- LOCATION RETURNED TO --
;	SP -> VALUE FOR R1, VALUE FOR R5, ...
;
;	...
;
;	R1 =  AS POP'D FROM STACK
;	R2 -> TERMINATOR (-1) +2 IN CONTROL TABLE (WORD) (2 WORDS)
;	R5 =  AS POP'D FROM STACK
;-

ERLCMN:	MOV	#3*400+1,(R2)+	;;;FIELD 3, 1 WORD
	MOV	#ERLCTB,(R2)	;;; FROM CSR LOCATION
	MOV	R3,@(R2)+	;;;  SO STORE THE CSR
	MOV	#REGSVA,R1	;;;R1=HARDWARE REGISTER SAVE AREA
10$:	TSTB	(R5)+		;;;SKIP OFFSET
	MOVB	(R5),(R2)+	;;;SET # WORDS TO SAVE
	MOVB	#4,(R2)+	;;; AND FIELD 4
	MOV	R1,(R2)+	;;;SET POINTER TO REGISTER SAVE AREA

	MOV	R1,-(SP)	;;;TEMP SAVE R1
	MOVB	(R5),R1		;;;R1=NUMBER OF WORDS TO MOVE
	ASL	R1		;;;MAKE IT A WORD OFFSET
	ADD	(SP)+,R1	;;;POINT TO NEXT SET OF DATA SAVED IN "REGSVA"

	TSTB	(R5)+		;;;REALLY END OF LIST?
	BNE	10$		;;;NOPE, LOOP
	CMP	-(R2),-(R2)	;;;YEP, BACK UP TO REAL END OF TABLE
	TST	(R1)		;;;BAE WORDS SAVED?
	BEQ	30$		;;;NO
	MOV	#4*400+2,(R2)+	;;;YES, SET FIELD 4, 2 WORDS
	MOV	R1,(R2)+	;;; SAVE POINTER TO SAVED BAE WORDS
30$:	MOV	#-1,(R2)+	;;;TERMINATE THE CONTROL TABLE
	MOV	#-1,2(R2)	;;; IN BOTH PLACES
	MOV	(SP)+,R1	;;;RESTORE R1 FROM THE STACK
	RETURN	R5		;;;NOW EXIT RESTORING R5


GLOBAL	<ERLTBL,ERLAUX,DSO$XX,UNTSIZ,DEVCLU,UNTCLU,DSKLOG,FLDNE,BAELST,REGSVA> ;006
GLOBAL	<ENDRSA,ERLCTB,MSCPWC,MSCPPK>



.SBTTL	SAVE MSCP PACKET
;+
; THIS ROUTINE SAVES THE MSCP PACKET
;
; R2 -> PAST SECOND -1 ERLTBL TERMINATOR
; "MSCPPK" CONTAINS PACKET TO BE SAVED
;
; ...
;
; R2 -> TERMINATOR (-1) +2 IN CONTROL TABLE (WORD) (2 WORDS)
;-
ERLPKT::MOV	#5*400+MSCPWC,-2(R2)	;;;FIELD 5, "MSCPWC" WORDS
	MOV	#MSCPPK,(R2)+		;;;  OF MSCP DATA
	MOV	#-1,(R2)+		;;;TERMINATE THE CONTROL TABLE
	MOV	#-1,2(R2)		;;;  IN BOTH PLACES
	RETURN				;;;RETURN TO DRIVER



.SBTTL	SAVE HARDWARE REGISTERS UPON ENTRY
;+
; THIS ROUTINE SAVES THE DISK HARDWARE REGISTERS IN "SAVREG"
; SAVE AREA.  THIS IS NECCESSARY TO PREVENT LOSS OF DATA.
;
;	R0 -> QUEUE ROOT
;	R3 -> CSR
;	R4 -> DSQ
;
;	CALL	SAVREG		; R5 POINTS TO CONTROL TABLE
;
;	  .BYTE	<ERROR CODE>
;	  .BYTE	<OVERLAPPED SEEK INDICATION>
;	  .BYTE	<STARTING REG OFFSET>,<# REGS TO SAVE>	** OPTIONAL **
;	  .BYTE	<STARTING REG OFFSET>,<# REGS TO SAVE>	** OPTIONAL **
;	  .BYTE	0,0
;
;	R5 -> CONTROL TABLE FOR ERROR LOGGER
;-
SVHWRG:	REGSCR			;;;SAVE REGISTERS
	TST	(R5)+		;;;POINT TO PAST ERROR CODE
	MOV	#REGSVA,R4	;;;R4 -> REGISTER SAVE AREA
10$:	TST	(R5)		;;;ANY REGISTERS TO SAVE?
	BEQ	40$		;;;NO
	MOVB	(R5)+,R1	;;;SIGN EXTEND REGISTER OFFSET
	ADD	R3,R1		;;;MAKE IT ABSOLUTE
	MOVB	(R5)+,R2	;;;R2=# OF WORDS TO SAVE
	BLE	10$		;;;SOMETHING IS WRONG, IGNORE IT
20$:	MOV	(R1)+,(R4)+	;;;SAVE THE REGISTER CONTENTS
	CMP	#ENDRSA,R4	;;;END OF SAVE AREA REACHED?
	BHI	30$		;;;NO
	CRASH			;;;YES, CRASH
30$:	SOB	R2,20$		;;;LOOP FOR NEXT REGISTER IN SET
	BR	10$		;;;GET NEXT SET OF REGISTERS

40$:	MOV	BAELST,R1	;;;GET RH70 BAE LIST
	BEQ	60$		;;;NO LIST EXISTS
50$:	MOV	(R1)+,R2	;;;SET R2 TO BAE
	BEQ	60$		;;;END OF LIST
	CMP	R3,(R1)+	;;;MATCH TABLE CSR
	BNE	50$		;;;NO, LOOP FOR MORE
	BIC	#1,R2		;;;MAKE SURE R2 IS EVEN
	MOV	(R2)+,(R4)+	;;;SAVE BAE REGISTERS
	MOV	(R2)+,(R4)+	;;;
60$:	CMP	R4,#ENDRSA	;;;END OF SAVE AREA REACHED?
	BHIS	70$		;;;YES
	CLR	(R4)+		;;;CLEAR REMAINDER OF SAVE AREA
	BR	60$		;;;LOOP TILL DONE
70$:	RETURN			;;;



.END

