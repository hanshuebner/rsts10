	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
	.INCLUDE /DSK:DPDEF/
TITLE	DPDSK,<RP11/RP02/RP03 DISK DRIVER>,0A,10-MAY-91,MHB/JDM/GW/WRM/TWH/VAM

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR DPDSK
;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;  001	RVR  30-Aug-80	Installed SRC for patch 3.7.7 M
;
;			[RSTS V9.0]
;  002	TWH  28-OCT-83	ADD SUPPORT FOR IFUN
;  003	FEK  15-May-84	Fix Sizes in IFUN support
;
;			[RSTS V9.1]
;  004  VAM  03-Jun-85	Add RELFUN.
;
;			[RSTS V9.2]
;  005	FEK  03-Feb-86	Fix IFUN for RP03's
;
;			[RSTS V9.6]
;  006	KCG  29-Feb-88	Add FMTFUN.
;-


	DEFORG	DPDSK

	INCLUDE	<CMNDSK,UNIDSK,OPTDSK,ERLDSK>

	DSKDEF	DP

.SBTTL	ERROR LOGGING

	ERRENT	LOG$DP

	CALLX	ERLDSK,R5	;;;USE COMMON ROUTINE
	  .BYTE	ERC$DP		;;;ERROR CODE
	  .BYTE	0		;;;NON-OVERLAPPED SEEK
	  .BYTE	RPDS,11.	;;;OFFSET, 11. REGISTERS
	  .BYTE	0,0		;;;THAT'S ALL
	RETURN			;;; AND BACK

.SBTTL	FORM THE PHYSICAL ADDRESS

QDS$DP::CMPB	DSQSAV(R4),#IFUN ;IS THIS A DRIVE INITIALIZE?		;002
	BEQ	30$		;YEP					;002
	CMPB	DSQSAV(R4),#RELFUN	;How about a Release?		;004
	BEQ	30$			;Yup.				;004
	CMPB	DSQSAV(R4),#FMTFUN	;Maybe a FORMAT?		;006
	BEQ	30$			;Yo				;006
	MOVB	#-21.,DSQERR(R4) ;RP'S GET 20. RETRIES
	DIV	#200.,R0	;DIVIDE BY 200.(SECTORS PER CYL)
	MOV	R0,DSQOPT(R4)	;ANSWER IS THE CYLINDER NUMBER
	CLR	R0		;SET FOR ANOTHER DIVIDE
	DIV	#10.,R0		;DIVIDE BY 10.(SECTORS PER TRACK)
	SWAB	R0		;PUT TRACK # IN HIGH BYTE (0-19.)
	ADD	R1,R0		; AND ADD IN SECTOR (0-9.)
	MOV	R0,DSQPDA(R4)	;NOW SAVE TRACK/SECTOR
	CLRB	DSQCTO(R4)	;ALLOW UNIT SELECTING AS A WORD
.ASSUME	DSQPUN	EQ DSQCTO!1	;UNIT MUST BE HIGH BYTE, WITH UNUSED LOW BYTE
30$:	CALL	@(SP)+		;RETURN WITH ADDRESS ALL SET UP		;002

.ENABL	LSB								;002
.SBTTL	COMES HERE IF REQUEST IS FIRST IN QUEUE

	BR	DSKGDP		;;FIRST IN QUEUE, SO DO IT

DSKGOP:	CALLX	OPTDSK,R5,OPT$DP ;;OPTIMIZE THE QUEUE
DSKGDP:	CMPB	DSQSAV(R4),#RELFUN	;;Is this a Release?		;004
	BEQ	150$			;;Yup, so just leave.		;004
	CMPB	DSQSAV(R4),#FMTFUN	;;FORMAT function?		;006
	BEQ	10$			;;Yes, set error code		;006
	MOV	DSQPUN-1(R4),(R3) ;;SELECT UNIT
	MOVB	DSQUNT(R4),R5	;;GET FIP UNIT NUMBER
	ASL	R5		;; TIMES 2
	MOV	RPDS(R3),R1	;;GET SELECTED DRIVE'S STATUS
	BIC	#^C<RPRP03>,R1	;; AND ISOLATE THE 'RP03' BIT
	CMPB	DSQSAV(R4),#IFUN ;;IS THIS A DRIVE INITIALIZE?		;002
	BEQ	30$		;;YEP					;002
	CMP	R1,MID$XX(R5)	;;REALLY CORRECT DRIVE TYPE??
	BNE	HARDER		;;NOPE, FATAL
	CALLX	DSKUMR		;;GET A WINDOW FOR THIS REQUEST
	MOV	DSQPDA(R4),RPDA(R3) ;;SET TRACK AND SECTOR
	MOV	DSQOPT(R4),RPCA(R3) ;;SET CYLINDER ADDRESS ALSO
	MOV	DSQPUN-1(R4),-(SP) ;;PUT THE UNIT INFORMATION ON STACK
	JMPX	DSKSRU		;; AND, NOW, START TRANSFER

10$:	SETERR	ERRERR,DSQERR(R4)	;;FORMAT DSQ currently unsupp	;006
	BR	150$			;;and join common		;006

DPDRVC:	MOV	#377,RPDS(R3)	;;CLEAR THE ATTN LINES
	CLR	RPDS(R3)	;; WITH OR WITHOUT THE ECO
	MOVB	#DRESET,DSQFUN(R4) ;; MARK FUNCTION AS "DRIVE RESET"
	MOV	#IE/100*RPAIE,R2 ;;SET ATTN INTERRUPT ENABLE IF IE<>0
	BIS	DSQPUN-1(R4),R2	;;.OR. UNIT SELECT BIT INTO HIGH BYTE
	MOV	R2,(R3)		;;SELECT UNIT
	BISB	#DRESET+IE+1,R2	;;SET DRIVE-RESET, INTERRUPT ENABLE, GO
	MOV	R2,(R3)		;;ISSUE COMMAND
20$:	RETURN

30$:	TST	(R3)		;;ANY ERRORS?				;002
	BMI	160$		;;YEP					;002
	BIT	#RPOL,RPDS(R3)	;;ARE WE DISABLED?			;002
	BEQ	160$		;;YEP					;002
	MOV	#20000.,UNTSIZ(R5) ;;SET UNTSIZ FOR RP02		;003
	MOVB	#2.,DEVCLU(R5)	;;AND DCS				;003
	MOV	R1,MID$XX(R5)	;;SAVE THE ID FOR THE CHECK LATER	;005
	BEQ	150$		;;WE'RE AN RP02				;002
	ASL	UNTSIZ(R5)	;;SET RP03 SIZE				;002
150$:	MOV	#DQS$DP,R0	;;GET THE QUEUE ROOT			;002
	BR	DPDONE		;;GO AWAY				;002

160$:	CLZ			;;SAY HARD ERROR			;002
	LOG$DP			;;LOG IT				;002
	CALLX	DFINT1		;;CHCK CC'S AND COUNT ERROR		;002
	BR	150$		;;FINISH UP				;002

GLOBAL	<OPT$DP,MID$XX,IE,UNTSIZ,DEVCLU,ERRERR>				;002
.DSABL	LSB								;002

.SBTTL	INTERRUPT SERVICE (PR5)

.ENABL	LSB

INT$DP::MOV	CSR.DP,R3	;;GET THE CSR ADDRESS
	MOV	#DQS$DP,R0	;;GET QUEUE ROOT POINTER
	MOV	RPER(R3),R2	;;GET ERROR REGISTER
	MOV	(R0),R4		;;GET TOP OF QUEUE REQUEST
	BEQ	60$		;;NONE, SO IGNORE INTERRUPT
	CALL	@RELUMR		;;RELEASE ANY WINDOWS FOR THIS REQUEST
	MOV	(R3),R1		;;GET CONTROL STATUS REGISTER
	BPL	20$		;;NO ERROR
TMO$DP::LOG$DP			;;ERROR (OR TIMEOUT), SO LOG THE ERROR
	CLR	(R3)		;;ERROR, SO CLEAR OUT
	INC	(R3)		;; CONTROL
.ASSUME	CRESET	EQ	0	;;THIS IS A RESET COMMAND
10$:	TSTB	(R3)		;;WAIT FOR READY
	BPL	10$		;;KEEP WAITING
20$:	CMPB	DSQFUN(R4),#DRESET ;;FROM A DRIVE RESET?
	BEQ	80$		;;YES, PROCESS END OF RESET
	TST	R1		;;NO, DID AN ERROR OCCUR?
	BPL	40$		;;NO ERROR
	BIT	R2,#RPDER	;;ERROR, WOULD A DRIVE RESET HELP?
	BNE	DPDRVC		;;IT WOULD HELP, SO DO ONE
	CMPB	DSQERR(R4),#-11. ;;TIME FOR A HOME SEEK ANYHOW?
	BEQ	DPDRVC		;;YES, SO DO ONE
30$:	BIT	R2,#RPSUWP!RPSUFU!RPNEC!RPNET!RPNES!RPNEM!RPEOP!RPDER
				;;CHECK FOR A HARD ERROR (SET CC'S)
HARDER:	CALLX	DFINT1		;;COUNT AND CHECK THE ERROR
	BMI	DSKGDP		;;MORE RETRIES LEFT, SO RETRY
DPDONE:									;002
40$:	CALLX	DFINT9		;;SAY IDLE, DE-QUEUE, AND HOUSEKEEP
50$:	TST	(R0)		;;MORE TO DO?
	BNE	DSKGOP		;;YES, SO DO IT ALREADY
60$:	MOV	(PC)+,(R3)	;;SELECT 7 AND CLEAR CONTROL BEFORE EXIT
	 .BYTE	0,7
70$:	RETURN			;;NOW EXIT

UMR$DP::TST	DSO$XX(R0)	;;ARE WE IDLE?
	BGE	50$		;;YES, CONTINUE OPERATIONS
	RETURN			;;NO, WE'RE NOT INTERESTED

80$:	TST	R1		;;ANY ERROR?
	BMI	90$		;;YES
	MOVB	DSQPUN(R4),R5	;;NO, GET THE UNIT NUMBER
	BITB	BITBYT(R5),RPDS(R3) ;;IS THE ATTN LINE ON YET?
	BEQ	70$		;;NO, WAIT FOR IT
90$:	CLR	(R3)		;;CLEAR CONTROL (NO ATTN IE)
	MOVB	DSQSAV(R4),DSQFUN(R4) ;;RESTORE FUNCTION TO THE REAL FUNCTION
	BR	30$		;;GO CHECK FOR ERROR(S)

.DSABL	LSB

GLOBAL	<CSR.DP,DQS$DP,BITBYT,RELUMR,DSO$XX>

.END

