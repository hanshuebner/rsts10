	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
TITLE	CMNDSK,<COMMON DISK DRIVER ROUTINES>,0A,10-MAY-91,MHB/GW/WBN/AJK/DRP/VAM

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR CMNDSK
;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;  001  AJK  13-JAN-82  ADDED CODE TO INTERFACE WITH MASCP HANDLER
;
;			[RSTS/E V9.0]
;  002	DRP  03-Oct-83	Table changes to UNTCNT, UNTOWN/UNTOPT and UNTCLU/UNTERR
;
;  003	DBM  21-May-85	DUDSK moved to BBR phase, change APR value
;
;			[RSTS/E V9.3]
;  004  VAM  02-Jun-86	Change INT$DU, TMO$DU and UMR$DU mapping back into
;			MCP phase.
;
;			[RSTS/E V9.5]
;  005	PJH  07-Jul-87	Add large disk support
;-

	DEFORG	CMNDSK

.SBTTL	COMMON DISK FRONT-END CONTINUED...

;+
; GODISK - CONTINUED START UP A DISK REQUEST...
;
;	R4 -> DSQ
;		DSQERR = -9.
;	R5 =  FIP UNIT NUMBER *2
;
;	...
;
;	RETURN
;-

	TMPORG	DSKDSP,0
	.WORD	GODISK
	UNORG

GODISK:	MOVB	DSQFBM(R4),R0	;GET THE FBN (MSB) AND
	MOV	DSQFBL(R4),R1	; (LSB)
	BNE	10$		;NON-ZERO, SO DO THE DCS-1 CORRECTION
	TST	R0		;REALLY A ZERO?
	BEQ	20$		;YES, LEAVE IT ALONE
10$:	CLR	R3		;avoid sign extends			;005
	BISB	DEVCLU(R5),R3	;NO, GET DCS FOR THIS UNIT AND		;005
	DEC	R3		; FIND (DCS-1)
	ADD	R3,R1		;NOW ADD IN (DCS-1) AND
	ADC	R0		; CARRY IF NEEDED
20$:	MOVB	DSQFUN(R4),R3	;GET THE (LOGICAL) FUNCTION CODE
	CMP	R3,#WFUN	;WRITING THE DISK?
	BHI	40$		;NO, READING (OR WRITE-CHECK)
.ASSUME	RFUN	GT	WFUN
.ASSUME	RFUN.C	GT	WFUN
	TSTB	UNTOPT(R5)	;YES, WRITING, WRITE CHECK UNIT?
	BPL	30$		;NOT WRITE CHECKING
.ASSUME	UO.WCU	EQ	200
	CLR	R3		;SET WRITE WITH WRITE CHECK FUNCTION
.ASSUME	WFUN.C	EQ	0
30$:	TST	R3		;IS IT WRITE THEN WRITE-CHECK?
	BNE	40$		;NO, JUST A NORMAL WRITE
.ASSUME	WFUN	NE	0
.IF	EQ	0	;*****MISSING*****
	MOV	#WFUN,R3	;ALWAYS JUST DO A NORMAL WRITE...
.ENDC			;*****MISSING*****
	MOVB	R3,DSQFUN(R4)	;SET CORRECT FUNCTION INTO DSQ
40$:	MOVB	R3,DSQSAV(R4)	;SAVE FUNCTION IN THE SAVE LOCATION
	MOVB	60$-WFUN.C(R3),DSQRFN(R4) ;SET THE RH11 TYPE FUNCTION

GLOBAL	<DEVCLU,UNTOPT>

	MOV	DSKMAP(R5),R2	;GET DISK DRIVER INDEX FROM UNIT *2
	MOV	DSKCSR(R2),-(SP) ;SAVE THE CSR ADDRESS
	MOV	DSKPTR(R2),R2	;GET POINTER TO 'D?DINT' @ DQS$OO
	MOV	(R2),-(SP)	;SAVE BASE QUEUE ROOT
	MOV	R5,R3		;COPY THE FUN *2 OF THIS REQUEST AND
	ADD	#DQS$XX,R3	; ADD IN START OF QUEUES, THEN FIND
	SUB	(SP),R3		;  THE PHYSICAL UNIT *2
	MOVB	R3,DSQOUN(R4)	;SET THE PHYSICAL UNIT *2
	ASR	R3		;FIND TIMES 1 ONLY AND
	MOVB	R3,DSQPUN(R4)	; SET THAT ALSO
	ASL	R3		;BACK TO PHYSICAL UNIT TIMES 2 NOW
	CLR	(R4)		;GUESS AT NO OFFSET INTO QUEUE ROOTS
	CMP	AP5$OO-DQS$OO(R2),#MCPAP5 ; Is this an MSCP disk?	;004
	BEQ	70$			  ; YES
	CALL	@-(R2)		;THEN ASK DRIVER TO CHECK IT OUT
.ASSUME	QDS$OO	EQ	DQS$OO-2

GLOBAL	<MCPAP5>							;004

;+
; WHEN THE DISK DRIVER IS CALLED:
;
;	R0 =  MSB OF THE STARTING LBN
;	R1 =  LSB OF THE STARTING LBN
;	R3 =  PHYSICAL UNIT NUMBER *2
;	R4 -> DSQ
;		DSQRFN =  RH11 FUNCTION
;		DSQSAV =  DSQFUN
;		DSQOUN =  PHYSICAL UNIT *2
;		DSQPUN =  PHYSICAL UNIT
;	R5 =  FIP UNIT NUMBER *2
;	(R4) = 0
;	PRIORITY LEVEL IS PR3
;
;	...
;
;	CALL	@(SP)+
;
;	R4 -> DSQ
;	(R4) = OFFSET TO QUEUE ROOT
;-

GLOBAL	<DSKMAP,DSKCSR,DSKPTR,DQS$XX,AP5$OO>				;004

	MOV	(SP)+,R1	;GET DRIVER'S RECALL ADDRESS
	NEG	DSQCNT(R4)	;MAKE THE WORD COUNT A -(WORD COUNT)
	MOV	(R4),R0		;GET OFFSET INTO QUEUE ROOTS
	ADD	(SP)+,R0	; AND ADD IN BASE OF THE ROOTS
	MOV	(SP)+,R3	;GET BACK THE CSR ADDRESS
	SPLC	5		;;LOCKOUT DISK INTERRUPTS
	CALLX	QUEUE0,R5	;;NOW QUEUE THIS REQUEST
	BCC	50$		;;NOT FIRST IN QUEUE
	CALL	(R1)		;;FIRST IN QUEUE, CALL DRIVER BACK AGAIN

;+
; CONTROL IS RETURNED TO DRIVER IF REQUEST IS FIRST IN QUEUE.
;
;	R0 -> QUEUE ROOT
;	R3 -> CSR
;	R4 -> DSQ
;		DSQCNT = -(WORD COUNT)
;	PRIORITY LEVEL IS PR5
;
;	...
;
;	RETURN
;-

50$:	SPLC	3		;;DROP TO LEVEL 3
	RETURN			; AND EXIT

60$:	.WORD	IE+RHWRIT	;RH11 WRITE
	.WORD	IE+RHWRIT	;RH11 WRITE
	.WORD	IE+RHREAD	;RH11 READ
	.WORD	IE+RHWCHK	;RH11 WRITE CHECK

70$:	CALL	MSCPGO		; GO TO MSCP DISK PHASE
	CMP	(SP)+,(SP)+	; REMOVE QUEUE ROOT AND CSR FROM STACK
	BR	50$		; RETURN

MSCPGO:	MAP	PUSH,APR=5,CODE,DATA ; SAVE CURRENT MAPPING
	MOV	-(R2),-(SP)	     ; (SP) -> DQS$XX
	MOV	@#MCPAP5,-(SP)	; (SP) -> APR5 value.			;004
	JMP	@#CALLMX	; CALL MSCP DISK DRIVER


GLOBAL	<IE,CALLMX>

.SBTTL	COMMON DISK END OF TRANSFER HOUSEKEEPING

;+
; DFINT9 - SAY IDLE, DE-QUEUE, AND HOUSEKEEP.
;
;	R0 -> QUEUE ROOT
;	R4 -> DSQ
;	PRIORITY LEVEL IS PR5
;
;	CALL	DFINT9
;-

DFINT9::CLR	DSO$XX(R0)	;;SAY DRIVE IS NOW IDLE
	MOV	(R4),(R0)	;;DE-QUEUE THIS REQUEST
	MOVB	DSQSAV(R4),DSQFUN(R4) ;;ENSURE CORRECT RETURNED FUNCTION
	CALLRX	QUEL3Q		;;NOW RE-QUEUE AND SIGNAL LEVEL 3

GLOBAL	<DSO$XX>

.SBTTL	COMMON DISK ERROR CHECKING

;+
; DFINT1 - CHECK FOR SOFT TYPE ERROR.
;
;	R4 -> DSQ
;	Z-BIT = 1 IF A SOFT ERROR
;	PRIORITY LEVEL IS PR5
;
;	CALL	DFINT1
;
;	R1 =  RANDOM
;
;	IF N=1 THEN A SOFT ERROR AND MORE RETRIES ALLOWED
;	IF N=0 THEN A HARD ERROR OR NO MORE RETRIES LEFT
;-

DFINT1::BEQ	DFINT3		;;Z=1 (NO MATCH) => SOFT ERROR (POSSIBLE RETRY)
	MOVB	#HNGDEV-1,DSQERR(R4) ;;SET THE HARD ERROR CODE (-1 FOR INC BELOW)

;+
; DFINT3 - CHECK FOR MORE RETRIES.
;
;	R4 -> DSQ
;	PRIORITY LEVEL IS PR5
;
;	CALL	DFINT3
;
;	R1 =  RANDOM
;
;	IF N=1 THEN A SOFT ERROR AND MORE RETRIES ALLOWED
;	IF N=0 THEN A HARD ERROR OR NO MORE RETRIES LEFT
;-

DFINT3::MOVB	DSQUNT(R4),R1	;;GET FIP UNIT NUMBER
	ASL	R1		;;TIMES 2 FOR WORD ADDRESSING
	INC	UNTERR(R1)	;; AND COUNT THE ERROR IN ERROR COUNTER	;002
	INCB	DSQERR(R4)	;;NOW CHECK FOR POSSIBLE RETRY
	RETURN			;;IF N=1 THEN RETRY POSSIBLE

GLOBAL	<HNGDEV,UNTERR>

.END

