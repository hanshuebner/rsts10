.INCLUDE /CMN:COMMON.MAC/						;012
.INCLUDE /CMN:KERNEL.MAC/						;012
.INCLUDE /DSK:MSCPDF.MAC/						;012
TITLE	DUDSK,<DISK CLASS MSCP DRIVER>,0K,04-JUN-92,MND/TPT/DBM/VAM/KCG/FEK

;
;		COPYRIGHT (c) 1974, 1992 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR DUDSK
;+
;
;  000	MND  14-SEP-84	Rewrite to seperate DISK class and common protocal
;			Original code extracted from MSCPPH by AJK/MND/JHC
;  001	MND  05-Mar-85	Various Bug fixes
;  002	MND  05-May-85	Add available command processor
;  003	TPT  08-May-85	Changes for placing DUDSK as a seperate phase
;  004	DBM  19-May-85	Put QUESYD in BBRDSP
;  005	DBM  27-May-85	Give NOTAVL error when no disk controllers present
;  006	DBM  30-May-85	Move disk error log stuff here from UQPORT
;  007	MND  15-Aug-85	Implement EXPRESS REQUEST, fix DCS calculation.
;  008	MND  21-Aug-85	Preserve critical U.STAT bits in R/W error handling
;
;			[RSTS/E V9.2]
;  009	TPT  13-Jan-86	Bug fix for system HOLD/RELEASE function
;  010  VAM  17-Mar-86	Make DUSERV bypass requests for units doing BBR.
;
;			[RSTS/E V9.3]
;  011  VAM  02-Jun-86	Move DU interrupt, timeout and UMR entry points into
;			MCP phase to avoid cross-phase call on every interrupt.
;  012  VAM  27-Jul-86	Re-merge CPH, UQPORT and DUDSK in MCP phase.
;			Move MUDVR into BBR phase.
;			Also, add .INCLUDES and INCLUDE to make sure needed
;			modules are included.
;  013  VAM  28-Oct-86	Fix handling of US.VI in DUSERV and ONL.DU.
;			Also, fix DEVCLU and UNTSIZ calculations.
;
;			[RSTS/E V9.4]
;  014  VAM  11-May-87	Move INCLUDE of ERLDSK into MCP phase header
;			so that TMSCP-only systems will work.
;
;			[RSTS/E V9.6]
;  015	KCG  17-Feb-88	Add code for FORMAT sequence (several changes).
;
;			[RSTS/E V9.7]
;  016	FEK  28-Oct-88	Add MID$XX setup code
;  017  VAM  23-Mar-89	Fix microcode revision check in FMT1.
;
;			[RSTS/E V10.1]
;  018	FEK  05-Mar-91	Add .ASSUMEs + controller ID setup
;  019  VAM  04-Jun-92	Fix FMTTBL for RQZX1/RX33
;-


	DEFORG	DUDSK


L$LIST	=  0	; 0 means list MSCP prefix file (CMT/UMT/CCB/UCB layouts)

RCF25	=: 3	; Controller model byte value for RC25 fixed platter.	;014

.SBTTL	********************************************
.SBTTL	*   DUDSK OVERVIEW/MONITOR ENTRY POINTS    *
.SBTTL	********************************************

;+
; Overview of the DU disk Class Driver operation.
;
;	[DUDSK]            [CPH]           [UQPORT]
;	QDS$DU ----->     CON$PH
;	SERVDU   <------  CON$PH
;
; 	DONEDU   <------  CON$PH   <------ INT$DU
;
; QDS$DU:
;	QDS$DU is the entry point for all disk I/O from the RSTS monitor.
;	The DSQ is queued into a linked list and processing for that request
;	is scheduled as a level 3 process. When the request is complete, the
;	port driver will schedule continuation processing at level 3 again.
;	CON$PH will dispatch to DUDSK to process the completed request.
;
; UMR$DU::
;	Entry point when the monitor needs to notify driver on the 
;	availability of UMRs.
;	All processing is done within the MSCP protocal handler (CPH).
;
; TMO$DU::	
;	Monitor entry point for Time-outs. Command execution time varies
;	on different controller so this entry point is set up to time-out
;	every second when a request is outstanding. The main MSCP driver 
;	(CPH) will update it's own clock to determine command timeouts.
;	All processing is done within the MSCP protocal handler (CPH).
;
; ERL$DU:
;	Monitor entry point for error logging.  Error log calls are
;	issued by UQPORT or CPH for the appropriate class driver.
;	The only LOG$?U call is made by UQPORT, but calls to that
;	routine are done by CPH.  For disks, the WCB, FCB, and DSQ
;	are logged (If present) along with [T]MSCP status and any
;	error log packet generated by the controller.
;-

.SBTTL	DUDSK REGISTER CONVENTIONS
;+
;
; The following register conventions are used by this driver.
;
;
; R0 -> UQPORT dispatch table, or queue root ppinter.
; R1 -> COMMAND/RESPONSE packet pointers
; R3 -  UCB Entry for unit requiring service
; R4 -> CMT Table entry for controller or DSQ request pointer
; R5 -> CCB Pointer for controller
;
;-
	

	TMPORG	DUDINT							;011

DUDINT:	JSR	R5,@#INTSVX		;;Set up interrupt save.	;011
	.WORD	MCPAP5			;;Here's the mapping to use...	;011
	.WORD	INT$PH			;;And here's where we go.	;011

	.WORD	QDS$DU			;Entry point to set up DSQ.	;011
	.WORD	DQS$DU			;Queue root base pointer.	;011
	.WORD	UMR$PH			;UMR service entry point.	;011
	.WORD	TMO$PH			;Timeout service entry point.	;011

.DSABL	CRF								;011
.GLOBL	INTSVX,DQS$DU							;011
.GLOBL	MCPAP5,INT$PH,UMR$PH,TMO$PH					;012
.ENABL	CRF								;011

	UNORG								;011


.SBTTL	********************************************
.SBTTL  *  QDS$DU queue structure (overview)       *
.SBTTL	********************************************
;+
; QDS$DU
;
; This code clears DSQSTS of the DSQ, queues the DSQ request to it's
; associated controller, queues that  CMT for service, and requests 
; level 3 service for CPH processing at CON$IP. The DSQ request 
; will be processed during level 3 priority by CON$IP in MSCPPH.
; DQS$DU is not used as the queue root as in non-MSCP disk drivers.
; Instead it is used as a count of queued request. DQS$DU is incremented
; every time a valid DSQ (non-zero) is recieved at this entry point, and 
; decremented when the request is queued to the system driver queue. This
; allows other modules that key off of DQS$DU to determine if there is any
; I/O outstanding for all controller serviced by this class drier.
;	
;	+-----------+
;	| CMT prefx |       +--------+
;	|           |------>| CMT #0 |----+
;	|           |       +----+---+ #1 |
;	|           |            +--------+
;	|           |
;	+-----------+    +------+
;	|  CMT  #0  |--->| DSQ1 |----+
;	+-         -+    +------+Q2  |---+
;	|  CMT  #1  |          +-----+Q3 |
;	+-         -+              +-----+
;	|  CMT  #n  |
;	+-----------+
;
; DSQ USAGE BY DRIVER
;
; Word DSQUMT -
;	UMT table pointer is saved here by QDS$?? routine of the port driver.
;
; Word DSQBWP -
;
; 	Used as a backward pointer in the MSCP request queue to
;	permit efficient dequeing of requests.
;
; Byte DSQSTS -
;	Byte DSQSTS will be used as a request status word.
;
;	R.SENT - request sent to the controller.
;	R.UMRW - request waiting for UMRs.
;	R.BBR  - request is being processed by BBR.
;	R.UNTS - unit search in progress
;	R.EXP  - Request should bypass optimization by controller (EXPRESS)
;
; Word DSQBBL -
;	Low order BAD block number used by BBR.
;
; Byte DSQBBH -
;	High order BAD block number used by bbr.
; 
;-

.SBTTL   QDS$DU entry point (set-up & queue DSQ entry)  

;+
;
; INPUTS:	R5=FIP UNIT NUMBER		R2 -> D?DINT @ QDS$PH
;		R4 -> DSQ			R1=LOW LBN
;		R3=PHYSICAL UNIT NUMBER * 2	R0=HIGH LBN
;
;	Note: At this entry point, the RSTS O/S has determined that this
;	DSQ is for a unit supported by the SIL, but not necessarly present
;	on the configuration. Valid units will have a CMT offset within the
;	UMT table (1 means unassigned). Also, requesting service at level 3
;	holds no guarantees regarding unit redirection. Thus, it is entirely
;	possible that the MSCP server may reject this request as an unknown
;	unit. The disk class driver will not recover from this situation 
;	and reject the request with "device hung or write-locked" (Ex: A
;	user could POP unit plugs after the request has reached the QDS$DU
;	entry point. Not likely, but still needs to be noted.)
;
;-

QDS$DU::NOP			;; Optionnaly patched to BPT for humor
	CALLX	ALOCCB		;; Chk data structures (or initialize)	;012
10$:	TST	R4		;; called via the RSTS start-up OVLY?
	BEQ	30$		;; Yes, we are done initializing.
	TSTB	CMT+CM.DCT	;; We're any controllers found by INIT?	;005
	BEQ	40$		;; Nope.  Give not available error	;005
	CMPB	DSQFUN(R4),#IFUN;; Is this a read or write?
	BHIS	20$		;; No, skip DCS compute and Express chk	;007
	MOVB	#-1,DSQERR(R4)	;; Pre-set DSQERR as sucessfull		;007
	TSTB	DSQFAR(R4)	;; Is the fairness count zero?		;007
	BPL	15$		;; No, allow controller optimization	;007
	DECB	DSQERR(R4)	;; Yes, signal Express request as #-2	;007
15$:	SUB	DSQFBL(R4),R1	;; COMPUTE DCS-1
	MOVB	R1,DSQCLU(R4)	;; SAVE DCS-1 IN DSQ
	.BR	20$

;COMMENT - Why do we need to save DCS-1 in the DSQ? Can't we use the	;MND
;	   monitors DEVCLU table now that we have IFUN? CPH currently	;MND
;          keys off of DSQCLU to distinquish DSQs from TSQs, so at the	;MND
;	   minimum it must contain a positive value.			;MND

;+
; 	Queue request (R3 still = Physical Unit *2)
;-
20$:	CLRB	DSQSTS(R4)	;; Set-up initial Status byte of zero	;007
	MUL	#<UMTSIZ/2>,R3	;; Get UMT offset ((PUN *2) * (UMTSIZ/2)).
	ADD	#UMT$DU,R3	;; Get absolute UMT table base address
	MOV	R3,DSQUMT(R4)	;; Save that for later processing
	CMP	(R3),#1		;; Is the physical unit present?
	BEQ	40$		;;-No! Give a device not available error
	MOV	(R3),R3		;; R3 -> offset into the CMT		;018
	.ASSUME	UM.CMT	EQ	0
	ADD	#CMT,R3		;; Get absolute address of CMT entry
	MOV	R3,R0		;; Save as the Queue ROOT
	ADD	#CM.QUE,R0	;; R0 -> CMT Queue Root pointer
	CALLX	QUEMCP		;;-Queue request in controller's queue	;012
	INC	DQS$DU		;; Count the number of queued requests
	MOV	R3,R4		;; Copy CMT address in R4
	CALLX	REQSER		;; and request service for this CMT	;012
	BINIT	50$		;;Set-up for INIT.SYS, if in INIT	;006
30$:	RETURN			;; Service request at level 3 (CON$IP)

;+
;	Unit not assigned.     Return  "?Device not Available" 
;	The controller will send an attention interrupt when the drive
;	is powered on. Which will cause the driver to assign the drive.
;-
40$:	SETERR	NOTAVL,DSQERR(R4)	;;?Device not available"	;001
	INC	DQS$DU		;;(FAKE) AS QUEUED REQUEST		;009
	CALLR	QUESYD		;;Queue to the SYSDRV queue and exit.
;+
;	INIT.SYS specific code
;-
50$:	MAP	PUSH,APR=6,DATA		;;;SAVE CURRENT APR6 MAPPING
	MAP	CM.AP6(R4),APR=6,DATA	;;;MAP TO CONTROLLER'S WORK AREA
	MOV	CM.COF(R4),R5		;;;R5 -> CCB
	CALLX	INTSIM			;;;YES, SETUP INTERRUPT SIMULATION;012
	MAP	POP,APR=6,DATA		;;;     FOR INIT.SYS.
	BR	30$			;;;Restore APR6 mapping & RETURN

.SBTTL	Error Logging

	ERRENT	LOG$DU		; DECLARE SERVICE ENTRY BY ERR.LOG INTO DRIVER

;+
; THE FOLLOWING CODE PERFOMS ERROR LOGGING FOR UDA CONTROLLERS
; AND ASSOCIATED DEVICES.  UDA ERROR LOGS COME IN 3 FLAVORS.
;
; 1. DSQ, END PACKET
; 2. RESPONSE PACKET ONLY
; 3. CONTROLLER FATAL, NO DSQ AND NO PACKET.
;
;
; THIS CODE IS ENTERED INTO VIA THE ERROR LOG EMT SERVICE CODE.
;
; INTPUT:	R0 -> QUEUE ROOT
;		R1 -> ERROR LOG PACKET (R1=0 IF NO ERROR LOG PACKET)
;		R2 -> AVAILABLE TABLE POINTER (PORT DRIVER DISPATCH TABLE PTR)
;		R3 -> CSR
;		R4 -> DSQ (IF DSQ EXISTS, OTHERWIESE R4 = 0)
;		R5 -> CCB
;
; This code was raped from UQPORT to be included here
;
;-
	CALL	CMNERL		;;;USE COMMON ROUTINE
	CALLX	ERLDSK,R5	;;;USE COMMON ROUTINE
	.BYTE	ERC$DU		;;;ERROR CODE
	.BYTE	0		;;;OVERLAPPED SEEK INDICATOR
	.BYTE	2,1		;;;SAVE IP AND SA REGISTERS
	.BYTE	0,0		;;;THAT'S IT
	MOV	R4,-(SP)	;;;TEMP SAVE DSQ
	BEQ	10$		;;;NO DSQ
	MOVB	DSQUNT(R4),R4	;;;R4 = FIP UNIT #
	ASL	R4		;;;R4 = FIP UNIT # * 2
	INC	UNTERR(R4)	;;;COUNT ERRORS FOR SYSTAT
	ASL	R4		;;;R4 = FIP UNIT # * 4
	MOV	UMT$XX+UM.UCB(R4),R4;;;R4 = UCB ADDRESS
	BEQ	20$		;;;UNIT NOT YET ASSIGNED
	MOV	U.STAT(R4),MSCPUS;;;SAVE SOFWARE UNIT STATUS
	BR	20$		;;;SKIP NEXT INSTRUCTION
10$:	MOV	#-1,(R0)	;;;OFFSET=-1 MEANS, NO DSQ!
20$:	MOV	(SP)+,R4	;;;RESTORE R4
	CALLX	ERLPKT		;;;NOW, LOG THE MSCP ERROR LOG AREA
	RETURN			;;;BACK TO ERROR LOGGER

GLOBAL	<UMT$DU,MSCPER,UNTERR>

.SBTTL	COMMON ERROR LOG CODE AMONG DRIVERS
;+
; COMMON ERROR LOG ROUTINE.  GETHERS ERROR LOG DATA.
;
; INPUTS/OUTPUTS SAME AS ABOVE.
;-
CMNERL:	MOV	R0,-(SP)	;;;SAVE R0 AND R1			;006
	MOV	R1,-(SP)	;;;IS THERE AN ERROR LOG PACKET?
	BEQ	20$		;;;NO, MUST BE A FATAL CONTROLLER ERROR

	MOV	R3,-(SP)	;;;TEMP SAVE R3
	MOV	E.LENG(R1),R0	;;;R0=LOG MESSAGE LENGTH
	ADD	#ENVLP,R0	;;;ADD EXTRA FOR THE ENVELOPE
	ADD	#E.LENG,R1	;;;R1 -> AT BEGINNING OF ENVELOPE
	MOV	#MSCPPK,R3	;;;R3 -> SAVE AREA FOR ERROR PACKET
10$:
	MOVB	(R1)+,(R3)+	;;;MOVE PACKET TO SAVE AREA
	SOB	R0,10$		;;;LOOP TIL DONE
	MOV	(SP)+,R3	;;;RESTORE R3
20$:
	MOV	(SP)+,R1	;;;RESTORE R1
	MOV	(SP)+,R0	;;;RESTORE R0
	MOV	(R5),MSCPCS	;;;SAVE CONTROLLER STATUS WORD		;018
	.ASSUME	C.STAT	EQ	0
	RETURN			;;;RETURN TO CALLER

GLOBAL	<MSCPPK,MSCPWC,MSCPCS,MSCPUS,DQS$XX,UMT$XX>

;006-

.SBTTL	DUSERV	-  MSCP DSQ SERVICE ROUTINE
;+
; DUSERV
;
; This routine performs disk related consistancy checks and
; issues the requested function to the controller.
;
; INPUT:    R3 -> UCB			OUTPUT:	R3,R4,R5 Preserved
; 	    R4 -> DSQ				R0,R2	 Destroyed
;	    R5 -> CCB			R.SENT or R.UMRW is marked in DSQ.
;
;-

DUSERV::BITB	#R.BBR,DSQSTS(R4)	; Is this entry waiting for BBR?;012
	BEQ	10$			; No.
	TSTB	CMT+CM.BRS		;-Yes? Then BBR should be active.
	BNE	90$			;-It is, BBR doing I/O on this request
					; No, then restart BBR.
					; (BBR can only service 1 DSQ at a
					;  time. So if BBR is not active then
					;  that means that BBR was busy at the
					;  time this DSQ's response was 
					;  recieved - or the driver determined
					;  that the unit was malfunctioning
					;  and took it offline. In both cases
					;  the DSQ is marked R.BBR and remains
					;  on the queue until SRVCDU restarts
					;  BBR processing for the request).
	CALLMI	$BBREP,BBRAP5		;-Restart BBR processing (like now);012
	BR	90$

10$:	BIT	#US.BBR,U.STAT(R3)	  ; Is unit doing BBR?		;010
	BNE	90$			  ; Yes, so just exit.		;010
	MOVB	DSQUNT(R4),R2	   	  ; Get Fip Unit Number		;013
	ASL	R2			  ;        *2			;013
	BIT	#UC.MNT!UC.NFS,UNTCNT(R2) ; Is unit mounted?		;013
	BNE	20$			  ; No, so clear US.VI and go	;013
					  ;  ahead with the I/O.	;013
	BIT	#US.VI,U.STAT(R3)	  ; Is volume really invalid?	;013
	BNE	60$			  ; Yes, go give DEVHNG error.	;013
20$:	BIC	#US.VI,U.STAT(R3)	  ; Say volume is not invalid.	;013
	BITB	#R.SENT!R.UMRW,DSQSTS(R4) ; Has DSQ been sent, or in UMR wait?
	BNE	90$			  ; Yes, exit.
	MOVB	DSQFUN(R4),R2		;-Get the FIP function code
	BMI	70$			;-Bogus function
	CMP	R2,#<FUNTBE-FUNDSP>	;-Do we know the function?
	BGT	70$			;-No.
	MOV	FUNDSP(R2),R2		;-Get routine address for function
	CALL	(R2)			;-Call the Function
	BR	90$			;-Exit


60$:	MOVB	#HNGDEV,DSQERR(R4)	;-Report "Device Hung or Write-Locked"
	MOV	#VOLINV,MSCPER		;-Driver detected Volume Invalid error
	BR	80$			;-  and log it

70$:	MOVB	#HNGDEV,DSQERR(R4)	;-Report "Device Hung or Write-Locked"
	MOV	#INVFUN,MSCPER		;-Driver detected Invalid Function
80$:	CLR	R1			;-No packet associated with error
	CALLX	LOG$PH			;-Log the error			;012
	MOV	C.CMT(R5),R0		;-R0 -> CMT for request
	ADD	#CMT+CM.QUE,R0		;-R0 -> DSQ Queue root for CMT
	CALLX	DEQUE			;;-Dequeue the request		;012
	CALL	QUESYD			;;-Queue it for done service
90$:	RETURN				;-Exit
	
;+
; FUNCTION PROCESSORS DISPATCH TABLE
;-
FUNDSP:	.WORD	WRIT.C			; WRITE WITH WRITE CHECK
	.WORD	WRITE			; WRITE FUNCTION PROCESSOR
	.WORD	READ			; READ FUNCTION PROCESSOR
	.WORD	READ.C			; WRITE CHECK(COMPARE HOST DATA CMD.)
	.WORD	INIT			; INITIALIZE (ONLINE)
	.WORD	CRASH			; Write Erase (should not be issued)
	.WORD	AVAIL			; RELEASE (AVAILABLE)
	.WORD	CRASH			; Unload (should not be issued)
	.WORD	FMT1			; FORMAT sequence (Part 1)	;015
FUNTBE:					; END OF FUNCTION TABLE

.ASSUME	WFUN EQ 2
.ASSUME	RFUN EQ 4
.ASSUME	RFUN.C EQ 6
.ASSUME IFUN EQ 10
.ASSUME RELFUN EQ 14

.SBTTL	READ/READ.C    - MSCP DISK READ AND READ-CHECK COMMAND PROCESSOR
.SBTTL	WRITE/WRITE-C  - MSCP DISK WRITE AND WRITE-CHECK COMMAND PROCESSOR
;+
; READ/WRITE
;
; SUBROUTINE TO INITIATE READ/WRITE TRANSFER
;
; INPUT:	R5 -> CCB
;		R4 -> DSQ
;		R3 -> UCB
;
; OUTPUT:	If UMR'S available, READ/WRITE command snet to processor.
;			DSQSTS is marked with R.SENT or R.UMRW.
;
; All registers preserved
;-

.ENABL	LSB
WRIT.C:
WRITE:	MOVB	#OP.WR,DSQSAV(R4)	; Save WRITE command
	BR	10$			; Join common code

READ:	MOVB	#OP.RD,DSQSAV(R4)	; Save READ command
	BR	10$			; Join common code

READ.C:	MOVB	#OP.CMP,DSQSAV(R4)	; Save COMPARE HOST DATA command
10$:	REGSCR				; SAVE REGISTERS
	CALLX	UMRGET			; GET UMRS			;012
	BCS	90$			; MUST WAIT FOR UMR'S
	MOV	R1,-(SP)		; SAVE HIGH UNIBUS ADDRESS ON STACK
	MOV	R2,-(SP)		; SAVE LOW UNIBUS ADDRESS ON STACK

20$:	CALLX	GETPAC			; GET A COMMAND PACKET		;012
	BCC	30$			; WE HAVE GOT A COMMAND PACKET
	CMP	(SP)+,(SP)+		; THROUGH AWAY UNIBUS ADDRESS
	BR	100$			; GO, RELEASE UMR'S

30$:	MOV	R4,(R1)			; SAVE DSQ AS LOW CMD.REF.NUMBER
	.ASSUME	P.CRF	EQ	0
	MOV	R3,P.CRF+2(R1)		; SAVE UCB AS HIGH CMD.REF.NUMBER
	MOVB	(R3),P.UNIT(R1)		; UNIT NUMBER TO COMMAND PACKET	;018
	.ASSUME	U.UNIT	EQ	0
	MOVB	DSQSAV(R4),P.OPCD(R1)	; Set-up the command
	CMPB	#-2,DSQERR(R4)		; Express request?		;007
	BNE	40$			; No.				;007
	BIS	#MD.EXP,P.MOD(R1)	; Yes, set EXPRESS modifier	;007
40$:	CMPB	DSQFUN(R4),#WFUN	; Is it some flavor of WRITE?
	BHI	50$			; No, then no WRITE CHECK required.
	BIT	#US.WCK,U.STAT(R3)	; WRITE CHECK REQUIRED?
	BEQ	50$			; NO
	BIS	#MD.CMP,P.MOD(R1)	; YES, SET COMPARE MODIFIER

;+
; Set-up Buffer address and bytes count
;-
50$:	MOV	(SP)+,P.BUFF(R1)	; PUT LOW AND HIGH UNIBUS ADDRESS
	MOV	(SP)+,P.BUFF+2(R1)	; .. IN COMMAND PACKET
	MOV	DSQCNT(R4),P.BCNT(R1)	; P.BCNT = WORD COUNT
	ASL	P.BCNT(R1)		; P.BCNT = WORD COUNT * 2
	ROL	P.BCNT+2(R1)		;
;+
; NOW, CONVERT FBN (FILE BLOCK NUMBER) TO LBN (LOGICAL BLOCK NUMBER)
;-
	MOV	DSQFBL(R4),P.LBN(R1)	; PUT FBN (LSB) TO COMMAND PACKET
	MOVB	DSQFBM(R4),P.LBN+2(R1)	; PUT FBN (MSB) TO COMMAND PACKET
	MOVB	DSQCLU(R4),R3		; R3=DCS-1
	ADD	R3,P.LBN(R1)		; ADD DCS-1 TO FBN
	ADC	P.LBN+2(R1)		; .. TO CONVERT IT TO LBN
	CALLX	SENCMD			; SEND COMMAND TO THE CONTROLLER;012
	BCS	100$			; SEND FAILED
	BISB	#R.SENT,DSQSTS(R4)	; INDICATE SENT STATUS IN DSQ
80$:	RETURN				; RETURN TO CALLER

90$:	BISB	#R.UMRW,DSQSTS(R4)	; SAY, ITEM WAITING FOR UMR'S
	MOV	C.CMT(R5),R0		;-Get the CMT offset in R0
	ADD	#CMT+CM.QUE,R0		;-  and get pointer to CMT request Que
	CALLX	DEQUE			;;-Now dequeue request from CMT queue;012
	MOV	#CMT+CM.QMR,R0		;-Get pointer to UMR stall queue root
	CALLX	JMPQUE			;;-Now queue DSQ to head of UMR queue;012
	BR	80$			; RETURN TO CALLER

100$:	CALL	@RELUMR			   ; RELEASE UMRS
	BICB	#R.UMRA!R.SENT,DSQSTS(R4)  ;-Clear UMRs assigned & sent flags
;					   ;-Should we REQSER for controller?
	BR	80$			   ; EXIT

.DSABL	LSB
GLOBAL	<GETUMR,UMT$XX,DEVCLU,CMT,REGSCR,RELUMR>

.SBTTL	AVAIL   - RELEASE FUNCTION (Take a unit OFFLINE)
;+									;002+
; AVAILABLE command processor
;	Input:	R5 -> CCB,  R4 -> DSQ,  R3 -> UCB
;
;	Output: C-bit clear if command sent, C-bit set if command not sent
;
;-									;002-

AVAIL:	CALLX	GETPAC			;-Get a command packet		;012
	BCS	10$			;-None available
	MOV	R4,(R1)			;-Save DSQ as low CRF
	.ASSUME	P.CRF	EQ	0
	MOV	R3,P.CRF+2(R1)		;-Save UCB as high CRF
	MOVB	(R3),P.UNIT(R1)		;-Move unit number into packet	;018
	.ASSUME	U.UNIT	EQ	0
	MOVB	#OP.AVL,P.OPCD(R1)	;-Set the AVAILABLE opcode
	CALLX	SENCMD			;-  and issue the command	;012
	;BCS	10$			;-Send failed
10$:	RETURN				;-Return


.SBTTL	INIT   - INITIALIZE/UNIT SELECT FUNCTION (IFUN)
;+
; INIT
;
; INITIALIZE FUNCTION
;	All DSQs queued for service require that the unit must be brought
;	online before the request is issued. The (unit) ONLINE processing 
;	does all the work required by this function. Thus, If we have reached
;	this function,then the unit has already been brought online at
;	least once. Here we just set the "Verify Unit Status" bit so the
;	next request will issue a GUS before attempting the I/O. This
;	is done in the event that attention messages are not enabled or
;	the attention message is delayed.
;
;		Note: Any change in the unit's state (such as switching
;		      unit plugs or power-on) will cause the unit to go
;		      offline only when attention messages are enabled.
;		      When the unit is brought offline, the next request
;		      will attempt to bring the drive back online or
;		      issue an error. If an attention message is recieved
;		      for a new unit, and all 4 UCBs have already been 
;		      allocated to the controller, then the driver will
;		      re-evaluate all units available to that controller 
;		      (and re-set the monitor's FUN tables). 
;		      This means that operator intervention can change 
;		      unit assignments at will.
;
; INPUT:	R5-> CCB
;		R4 -> DSQ
;		R3 -> UCB
;
; OUTPUT:	Item in R4 is dequeued from the driver queue and queued
;		for done service by the system driver.
;
;-

INIT:	BIS	#US.VUS,U.STAT(R3) ;Cause next I/O to do another GUS	;007
	CALL	IODONE		   ;Queue request to SYSDVR and housekeep.
	RETURN			   ;Return to PROREQ


.SBTTL	FORMAT	- Disk FORMAT function sequencer			;015
;+
; The format sequence is divided into three parts.  The first one is entered
; via the normal DUSERV DSQ entry, the second entry is entered by the
; AVAILABLE command response (see AVL.DU), and the third is entered by the
; ONLINE command response (see ONL.DU).  The following section descriptions 
; describe the format sequence.
;
; FMT1:
;	At entry, we are ensured of GUS information being correct (since
;	the DSQ entry forced a GUS or the unit was already online), and
;	a disk being in the unit (otherwise the GUS would have failed).
;	This routine ensures that the U2.FMT flag is set (it is normally
;	set in GUSEND, but GUS is skipped if unit is online), ensures
;	that we're working with a unit/controller pair that we support,
;	determines if subfunction (FORMAT Inquiry) is selected, and,
;	depending on subfunction, either exits via IODONE or through
;	calling AVAIL (the first command in the FORMAT sequence).
;
;   INPUT:	R5 -> CCB
;		R4 -> DSQ
;		R3 -> UCB
;   OUTPUT:	R2 destroyed
;
; FMT2:
;	Checks status of the AVAILABLE command (aborts sequence if 
;	it failed).  Saves regs, and calls ONLINE to perform the second
;	command in the sequence.
;
;   INPUT:	R5 -> CCB
;		R4 -> DSQ
;		R3 -> UCB
;		R1 -> AVAILABLE response packet.  (MUST BE PRESERVED)
;		R0 -> Port Driver Dispatch Table 
;   OUTPUT:	None
;
; FMT3:
;	We only get here if the ONLINE command (with Ignore Media Format
;	Errors modifier {MD.IMF}) has succeeded.  Gets the DSQ, gets a 
;	command packet, issues the FORMAT command to the controller.
;
;   INPUT:	R5 -> CCB
;		R3 -> UCB
;		R1 -> ONLINE response packet.  (MUST BE PRESERVED)
;		R0 -> Port Driver Dispatch Table 
;   OUTPUT:	None
;-

	.ENABL	LSB

FMT1:	BIS	#U2.FMT,U.ST2(R3)	;Set FORMAT in progress flag
	MOV	#FMTDVN,R0		;num supported fmtable unit/cntrlers
	MOV	#FMTTBL,R1		;set start address of table
10$:	MOV	(R1)+,R2		;Get first word of table
	CMPB	U.UNTI+6(R3),R2		;Does unit model number match?
	BNE	20$			;Nope, try next entry in table
	SWAB	R2			;Switch to get model number
	CMPB	C.CNTI+6(R5),R2		;Does controller model match?
	BNE	20$			;Nope, try next entry in table
	CMPB	C.VRSN+6(R5),(R1)	;Correct microcode?
	BHIS	30$			;Yes, it's a supported combo.	;017
20$:	TST	(R1)+			;set table pointer to next
	SOB	R0,10$			;try next table entry if any
	MOVB	#ERRERR,DSQERR(R4)	;No matches, not a good combination
	BR	40$			;join common exit.

30$:	TST	DSQFBL(R4)		;Is this a FORMAT Inquiry?
	BMI	50$			;no, it's a format command
	MOVB	#-1,DSQERR(R4)		;yes, signal success (set by default)
40$:	BIC	#U2.FMT,U.ST2(R3)	;show that FMT is done.
	JMP	IODONE			;send DSQ back to issuer

50$:	BR	AVAIL			;Make sure the unit is available.

GLOBAL	<ERRERR>
	.DSABL	LSB

;
; FMTTBL - The table of formattable device/controller combinations.
;
;	To add a new device/controller combination, insert new .BYTE
;	line before the FMTDVN computation.  There are three bytes used in
;	the .BYTE line; the first identifies the Unit model value, the
;	second identifies the Controller model value, and the third 
;	identifies the controller microcode version (see Appendix C
;	of the MSCP specification).  The .BYTE line must be followed by
;	a .EVEN
.EVEN
;		Unit		Controller	Version
;		----		----------	-------
FMTTBL:	.BYTE	10.	,	19.	,	3.	; RX33, RQDX3, V3
	.EVEN								;019
	.BYTE	10.	,	30.	,	0.	; RX33, RQZX1, V0
	.EVEN								;019
	.BYTE	-1.	,	-1.	,	-1.	; patch space
	.EVEN
FMTDVN = <<.-FMTTBL>/4>

	.ENABL	LSB

FMT2:	BIT	#ST.MSK,P.STS(R1)	;Did the command fail?
	BEQ	10$			;No, success
	JMPX	UNTOFL			;yes, send back error to user

10$:	PUSH	R1			;Save pointer to Response packet
	CALLX	ONLINE			;Send the online command
	POP	R1			;Restore Response packet pointer
	RETURN				;exit back to DONEDU (which goes
					;back to PRORSP)(which returns the
					;AVAILABLE response packet).
	.DSABL	LSB

	.ENABL	LSB

FMT3:	MOV	(R1),R4			;Get the DSQ address.
	.ASSUME	P.CRF	EQ	0
	PUSH	R1			;Save pointer to Response packet
	CALL	GETPAC			;Get a command packet.
	BCS	10$			;No packets?  (start FMT seqence again)
	MOV	R4,(R1)			;Set DSQ as low CRF
	.ASSUME	P.CRF	EQ	0
	MOV	R3,P.CRF+2(R1)		;Set UCB as high CRF
	MOVB	(R3),P.UNIT(R1)		;Set Unit number		;018
	.ASSUME	U.UNIT	EQ	0
	MOVB	#OP.FMT,P.OPCD(R1)	;Set FORMAT command
	CALLX	SENCMD			;issue the command
10$:	POP	R1			;Restore Response packet pointer
	RETURN				;exit back to DONEDU (which goes
					;back to PRORSP)(which returns the
					;ONLINE response packet).
	.DSABL	LSB


.SBTTL	DONEDU  - Disk Message END MESSAGE Response Processor 
;+
; DONEDU - (Process the completion of a disk request)
;   INPUT:	R5 -> CCB
;		R3 =  End message OPCODE * 2 (From bits 0:5 of P.OPCD)
;		R1 -> Response Packet
;-

DONEDU::CMP	#DUTBLE-DU.TBL,R3	;-Is the code valid?		;012
	BLOS	10$			;-No, ignore it
	MOV	C.PDVR(R5),R0		;-Get the PORT driver dispatch table
	CALL	@DU.TBL(R3)		;-  and go to it.
10$:	RETURN				;Back to PRORSP to release packet.

.SBTTL	DU.TBL  - Disk Response Processor dispatch table
;+
;	Disk class END MESSAGE dispatch table
;-
DU.TBL:	.WORD	CRASH	; Should never get here
	.WORD	CRASH	; ABORT (Not implemented)
	.WORD	CRASH	; GET COMMAND STATUS 		[CPH]
	.WORD	CRASH	; GET UNIT STATUS		[CPH]
	.WORD	CRASH	; SET CONTROLLER CHARACTERISTICS[CPH]
	.WORD	CRASH	; (not used)
	.WORD	CRASH	; (not used)
	.WORD	IGNORE	; SERIOUS EXCEPTION		[DU]
	.WORD	AVL.DU	; AVAILABLE COMMAND
	.WORD	ONL.DU	; ONLINE
	.WORD	CRASH	; SET UNIT CHARACTERISTICS (Not implemented)
	.WORD	CRASH	; DETERMINE ACCESS PATH (Not implemented)
	.WORD	CRASH	; (not used)
	.WORD	CRASH	; (not used)
	.WORD	CRASH	; (not used)
	.WORD	CRASH	; (not used)
	.WORD	CRASH	; ACCESS COMMAND (Not implemented)
	.WORD	CRASH	; COMPARE CONTROLLER DATA (Not implemented)
	.WORD	ERS.DU	; ERASE COMMAND
	.WORD	CRASH	; FLUSH COMMAND
	.WORD	RPL.DU	; REPLACE COMMAND (BBR)
	.WORD	CRASH	; (not used)
	.WORD	CRASH	; (not used)
	.WORD	CRASH	; (not used)
	.WORD	FMT.DU	; FORMAT COMMAND				;015
	.WORD	CRASH	; (not used)
	.WORD	CRASH	; (not used)
	.WORD	CRASH	; (not used)
	.WORD	CRASH	; (not used)
	.WORD	CRASH	; (not used)
	.WORD	CRASH	; (not used)
	.WORD	CRASH	; (not used)
	.WORD	CMP.DU	; COMPARE HOST DATA
	.WORD	RD.DU	; READ
	.WORD	WR.DU	; WRITE
DUTBLE:

CRASH:	CRASH
IGNORE:	RETURN


.SBTTL	AVL.DU - Disk AVAILABLE end message processor (Take a disk offline)

;+
;   AVL.DU	(Process Available response message, Take a disk offline)
;   INPUT:	R5 -> CCB
;		R1 -> Response Packet
;-
AVL.DU:	MOV	(R1),R4			;-R4 -> DSQ OF CURRENT REQUEST
	.ASSUME	P.CRF	EQ	0
	MOV	P.CRF+2(R1),R3		;-R3 -> UCB
	BIT	#U2.FMT,U.ST2(R3)	;FORMAT sequence in progress?	;015
	BEQ	10$			;no, continue normally		;015
	JMP	FMT2			;yes, goto 2nd FORMAT sequence	;015

10$:	CALLX	UNTOFL			;-Mark unit offline		;012
	INC	DQS$DU			;INCREMENT COMMAND COUNTER AGAIN  ;009
	JMP	IODONE			;-Queue request for SYSTEM driver


.SBTTL	ERS.DU              - Process ERASE response message
;+
;	ERS.DU  -  Process ERASE response message
;-
ERS.DU:	NOP			;ERASE command not implemented yet.
	JMP	IODONE		;Queue request for SYSTEM driver

.SBTTL	FMT.DU              - Process FORMAT response message		;015
;+
;	FMT.DU  -  Process FORMAT response message
;
;   INPUT:	R5 -> CCB
;		R1 -> FORMAT response packet.  (MUST BE PRESERVED)
;		R0 -> Port Driver Dispatch Table 
;   OUTPUT:	None
;-
	.ENABL	LSB
FMT.DU:	MOV	(R1),R4			;R4 -> DSQ
	.ASSUME	P.CRF	EQ	0
	MOV	P.CRF+2(R1),R3		;R3 -> UCB
	BIT	#ST.MSK,P.STS(R1)	;Did the command fail?
	BNE	10$			;Yes, return error
	MOVB	#-1,DSQERR(R4)		;Signal success (set by default)
	CALL	IODONE			;Send DSQ back to issuer
10$:	JMPX	UNTOFL			;yes, send back error to user
	.DSABL	LSB

.SBTTL	RPL.DU              - Process REPLACE response message
;+
;	RPL.DU  -  Process REPLACE response message
;-
RPL.DU:	.BR	WR.DU		;Handle REPLACE like normal I/O


.SBTTL	RD.DU,WR.DU,CMP.DU  - Process READ/WRITE/COMPARE response messages
;+
; RD.DU,WR.DU,CMP.DU
;
; This routine returns I/O done for the DISK request that just completed.
; If the request was initiated by the USER, I/O done is returned to the
; SYSTEM driver, unless the request is owned by BBR. If BBR is in progress
; on behalf of the request, BBR is resumed at it's I/O done entry point.
;
; INPUT:	R5=CCB, R4=CMT, R1 -> RESPONSE PACKET
;		R0 -> PORT DRIVER DISPATCH TABLE
;
; OUTPUT:	I/O DONE RETURNED TO THE USER
;			OR
;		BBR IS EXECUTED/RESUMED
;
; REGISTERS R0 THROUGH R4 CHANGED
;-
	.ENABL	LSB

CMP.DU:
WR.DU:
RD.DU:	MOV	(R1),R4			; R4 -> DSQ OF CURRENT REQUEST
	.ASSUME	P.CRF	EQ	0
	MOV	P.CRF+2(R1),R3		; R3 -> UCB

	BITB	#R.BBR,DSQSTS(R4)	; IS BBR IN PROGRESS ON BEHALF OF THIS
					; ..REQUEST?
	BEQ	20$			; NO, REGULAR I/O
	CALLMI	$RSMBR,BBRAP5		; Yes, resume BBR.		;012
	BR	90$			; BBR does it's own error checks.

20$:	BITB	#R.UMRA,DSQSTS(R4)	; NEED TO DEALLOCATE UMRS
	BEQ	30$			; NO
	CALL	@RELUMR			; RELEASE ANY UMR'S ASSOCIATED
					; ..WITH THIS DSQ
30$:	BIT	#UF.RPL,U.UNFL(R3)	; CONTROLLER INITIATED BBR?
	BNE	50$			; YES, SKIP BBR CHECKING
	BITB	#EF.BBR,P.FLGS(R1)	; BAD BLOCK REPORTED?
TESTP1::BNE	40$			; YES. -- <NOP these 2 branches>JHC007
	BEQ	50$			; NO.  -- <2 test host BBR code>JHC007
	BR	TSBBR0			; <Beware, stange things may be afoot>


;  Prepare for BBR

40$:	MOV	P.FBBK(R1),DSQBBL(R4)	; Save the potentially Bad LBN in
	MOVB	P.FBBK+2(R1),DSQBBH(R4)	;   the DSQ for BBR,
	JMP	DOBBR			;-  and activate BBR.
;
;	Check for other errors

50$:
	MOV	P.STS(R1),R2		; WAS REQUEST SUCCESSFUL?
	BNE	60$			; No. Log an Error.
	BITB	#EF.LOG,P.FLGS(R1)	; ERROR LOG GENERATED?
	BNE	70$			;   Yes. Request was sucessfull but
					;   we should Log this packet and DSQ.
	BR	80$			;   No errors.  Dequeue and Exit.

60$:	BIC	#^C<ST.MSK>,R2		; CLEAR SUB CODE
	CMPB	#13,R2			; Major code exceed our table?	;008
	BHI	65$			; No.				;008
	CLR	R2			; Yes, use default entry	;008
65$:	ASL	R2			; Get MSCP error code *2	;008
	ADD	#ECLASS,R2		; Index into error class table	;008
	MOVB	(R2)+,DSQERR(R4)	; Return the RSTS error code	;008
	TSTB	(R2)			; Should we make a state change?;008
	BPL	67$			; No, user or media error	;008
	BIS	#US.AVL!US.VI,U.STAT(R3); Mark unit's state as Offline	;013
	BIC	#US.ONL!US.OLP,U.STAT(R3);  (but preserve RCK,WCK &BBR)	;008
67$:	TSTB	(R2)			; Should we log it?		;008
	BEQ	80$			; No, must be a compare error.	;008
70$:					; R5 -> CCB	; R1 -> END PACKET
	CLR	MSCPER			; Indicate a Hardware detected error.
	CALLX	LOG$PH			;-Log the error			;012
	.BR	80$			; DO I/O DONE PROCESING

80$:	CALL	IODONE			; This request is finished.
90$:	RETURN				; RETURN TO CALLER

;+008
;	Error class Table
OFFLNE	=	200		;Change state so next request requires ONLINE
LOG	=	001		;Error must be logged to error logger

ECLASS:	.BYTE	HNGDEV,	OFFLNE!LOG	;Unknown or msg from intrnl diag;008
	.BYTE	EOF,	LOG		;Invalid command		;008
	.BYTE	HNGDEV,	OFFLNE!LOG	;Command aborted		;008
	.BYTE	HNGDEV,	OFFLNE!LOG	;Unit OFFLINE			;008
	.BYTE	HNGDEV,	OFFLNE!LOG	;Unit Available			;008
	.BYTE	FMTERR,	OFFLNE!LOG	;Media Format error		;008
	.BYTE	HNGDEV,	LOG		;Write protected		;008
	.BYTE	DATERR, 0		;Compare error			;008
	.BYTE	DATERR,	LOG		;Data error			;008
	.BYTE	B.PRTY,	LOG		;Host buffer access error	;008
	.BYTE	HNGDEV,	OFFLNE!LOG	;Controller error		;008
	.BYTE	HNGDEV,	OFFLNE!LOG	;Drive error			;008
	.EVEN

GLOBAL	<HNGDEV,DATERR,EOF,B.PRTY,FMTERR>
;-008

.SBTTL	***********************
.SBTTL	* <<<BBR TEST STUB>>> *
.SBTTL	***********************

;+
;	******** Care and use of this test stubb. ********
;
;	The two branches at TESTP1 should be patched to NOPs to start running
;	this test routine. The first word of PATCH space is used as an access
;	counter because it is in READ/WRITE memory. It should initially be 
;	patched to the frequency of the test.
;		TSBBR1 should be patched to the unit number under test.
;		TSBBR2 should be patched to the frequency of the test.
;
;	This stubb (when enabled) forces the block accessed on every Nth
;	(N=TSBBR2) access to the indicated unit (TSBBR1) to be marked bad and
;	replaced.  The LBN is calculated and placed in the response packet as
;	the controller would have for an actual replacement. (This stub
;	defaults to replace every 400(8) accesses on DU: unit 0).
;-

TSBBR0:	PUSH	R2			; save a work register.
	CMP	P.UNIT(R1),(PC)+	; is it the unit no. we're checking?
TSBBR1:	.WORD	0			; patched unit number (default=0)
	BNE	93$			; not the right unit, so continue.
	DEC	@#PATCH			; first word of patch space is counter
	BNE	93$			; counted down? BNE means no
	MOV	TSBBR2,@#PATCH		; Yes, reset the counter.
	MOV	DSQFBL(R4),P.FBBK(R1)	; set up the LBN of the 'bad block.'
	MOVB	DSQFBM(R4),P.FBBK+2(R1)	; from the FBN
	MOVB	DSQCLU(R4),R2
	ADD	R2,P.FBBK(R1)
	ADCB	P.FBBK+2(R1)
	POP	R2			; otherwise, restore R2
	BR	40$			; and call it a bad block.

TSBBR2:	.WORD	400			; Every Xth try, report error (X=400)
93$:	POP	R2			; Not one of our fake Bads,restore R2
	BITB	#EF.BBR,P.FLGS(R1)	; really a bad block report?
	BEQ	50$			; NO, so skip around it.
	BR	40$			; Now back into normal code....

	.DSABL	LSB

GLOBAL	<PATCH>								;012


.SBTTL	ONL.DU - Disk ONLINE end message response processor
;+
; ONL.DU
;
; THIS ROUTINE PROCESSES THE ONLINE END PACKET
;
; INPUT:	R5 -> CCB
;		R1 -> END PACKET
;
; OUTPUT:	IF STATUS CODE IS SUCCESSFUL, DRIVE IS
;		SET TO THE ONLINE STATE, UNIT SIZE
;		AND VOLUME SERIAL NUMBER SAVED IN UCB.
;		ALSO, THE DEVICE CLUSTER SIZE AND UNIT SIZE 
;		IN DC'S IS COMPUTED AND SAVED IN "DEVCLU"
;		"UNTSIZ" TABLE.
;		
;		IF STATUS CODE INDICATES FAILURE, THE UNIT
;		IS MARKED AS OFFLINE AND REQUEST TO IT
;		ARE RETURNED WITH DEVICE HUNG ERROR CODE.
;
; R0 THROUGH R4 CHANGED
;-
	.ENABL	LSB

ONL.DU:	MOV	P.CRF+2(R1),R3		; R3 -> UCB
	MOV	#OLFERR,MSCPER		; INVALID UNIT SIZE IN ONLINE END
	BIT	#ST.MSK,P.STS(R1)	; SUCCESSFUL?
	BNE	70$			; NO

	BIT	#U2.FMT,U.ST2(R3)	; FORMAT sequence in progress?	;015
	BEQ	10$			; No, Normal Online		;015
	JMP	FMT3			; Yes, Do third FORMAT seqence	;015

10$:	CLR	R4			; ASSUME INIT, FIP UNIT NUMBER = 0
	BINIT	30$			; Don't check Vol Vld in INIT	;006
	MOV	P.UNIT(R1),R4		; R4=UNIT #
	ASL	R4			;     *2
	ADD	#<DQS$DU-DQS$XX>,R4	; R4=FIP UNIT NUMBER * 2


;+
;
;	Check RC25 volume serial number and clear US.VI if it's the
;	same as the old one stored for that unit.
;
;	On RC25s, we need the capability of spinning down a mounted unit and
;	allowing it to come back online without generating an error.  This is
;	because the fixed and removable drives on the RC25 share the same
;	spindle, and in order to remove the removable pack you've got to
;	spin the fixed one down as well.
;
;	On drives other than an RC25 fixed unit, we skip around this section,
;	leaving US.VI (Volume Invalid) set; this will insure that DUSERV will
;	check to make sure the unit is not mounted before trying to do any
;	I/O (if US.VI is set on a logically mounted unit, DUSERV will return
;	DEVHNG on all requests for that unit until the unit is logically
;	dismounted).
;
;	If the drive that we just got the Online for was a fixed RC25 unit,
;	then we check it's serial number against our previously stored serial
;	number for that unit (if any).  Even though RC25 fixed units can't
;	be removed or ported to another system (and thus the file structure
;	can't be changed out from under us), checking the serial number
;	insures that no one has swapped unit number plugs on us while the
;	drives were spun down.  If they're the same, then we clear US.VI
;	here.
;-
	MOVB	P.UNTI+6(R1),MID$XX(R4)	;store the drive type away	;016
	MOVB	C.CNTI+6(R5),MID$XX+1(R4) ;Store controller type away	;018
	CMPB	P.UNTI+6(R1),#RCF25	; Is this an RC25 fixed drive?	;014
	BNE	30$			; No, so skip this check and	;014
					;  leave US.VI set.		;014
	CMP	P.VSER(R1),U.VSER(R3)	; Did the volume change?	;013
	BNE	30$			; Yes, leave volume invalid.	;013
	CMP	P.VSER+2(R1),U.VSER+2(R3) ; Check both words.		;013
	BNE	30$			; Different, so this isn't the	;013
					;  same volume.  Go store new	;013
					;  S/N without clearing US.VI.	;013
	BIC	#US.VI,U.STAT(R3)	; Say volume is OK.		;014

;+
;	Save volume serial number in UCB.
;-

30$:	MOV	P.VSER(R1),U.VSER(R3)	; Save volume serial number,	;014
	MOV	P.VSER+2(R1),U.VSER+2(R3) ; both words.			;014

;+
;	Save Unit size in LBN's.
;-

	MOV	P.UNSZ+2(R1),R0		; R0=HIGH WORD OF UNIT SIZE
	MOV	R0,U.UNSZ+2(R3)		; SAVE HIGH ORDER UNIT SIZE IN UCB
	MOV	P.UNSZ(R1),R1		; R1=LOW ORDER UNIT SIZE
	MOV	R1,U.UNSZ(R3)		; SAVE LOW ORDER UNIT SIZE

;+
; COMPUTE UNIT SIZE IN DC'S AND DEVICE CLUSTER SIZE
;-
	BINIT	60$			; Skip update of unit size if INIT ;006
	MOV	#1,R2			; ASSUME CLUSTER SIZE 1
40$:	TST	R0			; HIGH WORD ZERO
	BEQ	50$			; YES, DONE
	ASHC	#-1,R0			; DIVIDE UNIT SIZE BY 2 UNTIL UNIT
					; .. SIZE FITS IN ONE WORD.
	ASL	R2			; GENERATE DEVICE CLUSTER FACTOR
	CMP	#MAXCLU,R2		; MAX CLUSTER SIZE EXCEEDED?
	BHIS	40$			; NO
	MOV	#IUSERR,MSCPER		; INVALID UNIT SIZE IN ONLINE END
	BR	70$			; YES, ERROR - TAKE UNIT OFFLINE

50$:	MOVB	R2,DEVCLU(R4)		; SAVE DEVICE CLUSTER SIZE
	MOV	R1,UNTSIZ(R4) 		; Set Unit Size in DCNs		;007
60$:	MOV	C.VCRP(R5),R1		; RESTORE PACKET POINTER
	MOV	(R1),R4			; R4 -> DSQ
	.ASSUME	P.CRF	EQ	0
	BIT	#UF.RPL,P.UNFL(R1)	; CONTROLLER INITIATED BBR?
	BEQ	DOBBR			; No, check for incomplete replacement
	BIC	#US.BBR!US.OLP,U.STAT(R3) ; CLEAR BBR/ONLINE IN PROGRESS BITS
	BIS	#US.ONL,U.STAT(R3)	; INDICATE UNIT ONLINE.
	BR	80$			; RETURN TO CALLER

GLOBAL	<MID$XX>							;016

;+
;	Set required status bits and enter BBR
;
;	INPUT:	R4 -> DSQ, R3 -> UCB,  R5 -> CCB
;	OUTPUT:	R0,R1 Destroyed.
;-
DOBBR:	BISB	#R.BBR,DSQSTS(R4)	; DSQ is now the property of BBR
	BISB	#US.BBR,U.STAT(R3)	; Indicate UNIT requires BBR
	MOV	C.CMT(R5),R1		;-Get CMT offset		;001
	CLR	R0			;-Clear R0 for divide
	DIV	#CMTSIZ,R0		;-Get controller no. from CMT offset
	MOV	#1,R1			;-Start Bit map with ocntroller 1
	ASH	R0,R1			;-Shift to right controller
	BISB	R1,CMT+CM.BRM		;-Indicate this controller needs BBR
	BITB	#BBR.AC,CMT+CM.BRS	;-Is BBR already active?
	BNE	80$			;-Yes, BBR will find us eventually
	BISB	#BBR.AC,CMT+CM.BRS	;-No, then activate BBR
	CALLMI	$BBREP,BBRAP5		;-   and enter BBR		;012
	BR	80$			; EXIT VIA COMMON RETURN

70$:	CALLX	UNTOFL			;-Mark unit offline		;012
	MOV	C.VCRP(R5),R1		; R1 -> END PACKET
	CALLX	LOG$PH			;-Log the error			;012
80$:	RETURN

	.DSABL	LSB

GLOBAL	<DQS$XX,DQS$DU,UNTSIZ,UNTCNT>

.SBTTL	IODONE  -  Dequeue request and Queue it for SYSTEM driver
;+
;	IODONE 
;      		INPUT:	R5 -> CCB
;			R4 -> DSQ
;-
IODONE::MOV	C.CMT(R5),R0	;-R0 -> CMT for request
	ADD	#CMT+CM.QUE,R0	;-R0 -> DSQ Queue root for CMT
	CALLX	DEQUE		;; Dequeue this request			;012
	.BR	QUESYD		;; Queue it for done service

.SBTTL	QUESYD	- QUEUE THE DSQ (DISK) FOR DONE PROCESSING IN SYSDVR
;+
; QUESYD
;
; INPUT:	R4 -> DSQ
;		DSQ+DSQL3Q -> LEVEL 3 QUEUE ROOT AND BITS.
;		Priority may be PR5 or PR3 when called, SYSDVR
;		dequeueing must be done at PR5
;
; OUTPUT:	All registers preserved.
;-

QUESYD::PUSH	<@#PS>			;-Save the processor status.	;012
	SPLC	5			;;Disable disk interrupts.
	CALLX	QUEL3Q			;;Queue it for done service.
	DEC	DQS$DU			;;Decrement count of queued requests
	POP	<@#PS>			;-RESTORE THE PROCESSOR STATUS.
	RETURN				;


.SBTTL	BBRDSQ - GET BBR'S CURRENT DSQ SUBROUTINE
;+
; BBRDSQ - GET BBR'S CURRENT DSQ SUBROUTINE
;
; INPUT:	$DSQ IN BBR WORK ARE
;
; OUTPUT:	R2 -> BBR'S CURRRENT DSQ
;
; R2 CHANGED
;-

BBRDSQ::MAP	PUSH,APR=6,DATA		; Save current APR6 mapping.	;012
	MAP	CMT+CM.BA6,APR=6,DATA	; MAP TO BBR REGION
	MOV	$DSQ,R2			; R2 -> CMT ENTRY BEING USED BY BBR
	MAP	POP,APR=6,DATA		; RESTORE PREVIOUS MAPPING
	RETURN				;



	.END		; 'Push the button, pull the plug, say goodbye	;003
