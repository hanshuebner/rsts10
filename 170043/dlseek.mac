	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
	.INCLUDE /DSK:DLDEF/
TITLE	DLSEEK,<RL11/RL01/RL02 OVERLAPPED SEEK DISK DRIVER>,0A,10-MAY-91,LMK/WBN/ABC/AWL/TWH/VAM

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR DLSEEK
;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07

;  000  AWL  05-MAR-82  CREATION - COPIED FROM V7.1-11
;  001  AWL  05-MAR-82  Added support for RLV12 (5th register)
;  002  AWL  07-JAN-83  Changed comment on XC$22 for use with 248KB
;  003	TWH  28-OCT-83	ADD SUPPORT FOR IFUN
;  004	FEK  18-May-84	Fix IFUN support
;  005  MNB  30-Aug-84  Fix IFUN support again
;  006  MND  16-Oct-84  Fix soft errors (HNF,DLT,CRC) so they are retryable
;  007  VAM  13-Feb-85	Add non-existant device support to IFUN
;  008  VAM  04-Apr-85	Don't log Write Check miscompares as hard errors
;  009  VAM  30-May-85	Add RELFUN.
;
;			[RSTS/E V9.6]
;  010	KCG  29-Feb-88	Add FMTFUN.
;
;-

	DEFORG	DLSEEK

	DEFORG	DLDSK

	INCLUDE	<CMNDSK,OPTDSK,ERLDSK,UNIDSK>

	DSKDEF	DL

;   RL11 FUNCTION CODES

RLFUN:	.WORD	RLWRIT+IE	;WRITE WITH WRITE CHECK
	.WORD	RLWRIT+IE	;WRITE
	.WORD	RLREAD+IE	;READ
	.WORD	RLWCHK+IE	;WRITE CHECK
	.WORD	0		;INITIALIZE FUNCTION			;003
	.WORD	RLWRIT+IE	;Write Erase				;009
	.WORD	0		;RELFUN					;009
	.WORD	0		;Unload					;009
	.WORD	0		;Format					;010
GLOBAL	<IE>

.SBTTL	ERROR LOGGING

;+
; ERROR LOGGING.
;
;	R0-R5 =  VALUE AT TIME ERROR CALL WAS ISSUED
;
;	...
;
;	RETURN
;
;	R5 -> ERROR LOGGING CONTROL TABLE
;-

.ENABL	LSB

	ERRENT	LOG$DL
	
	CALLX	ERLDSK,R5	;;;CALL THE DISK ERROR LOGGING ROUTINE
	  .BYTE	ERC$DL,-1	;;;ERROR CODE, OVERLAPPED SEEK
	  .BYTE	RLCS,4		;;;OFFSET, 4 REGISTERS
	  .BYTE	0,0		;;;THAT'S ALL FOR THE ROUTINE

	BIT	#XC$QBU,@#X.CON	;;;IS SYSTEM USING A Q-BUS?
	BEQ	10$		;;;NO
	BIT	#XC$22,@#X.CON	;;;Is physical memory > 248KB?		;002
	BEQ	10$		;;;NO

	MOV	#30$,(R2)	;;;USE THIS ROUTINE
	MOV	#-4*400+3,-(R2)	;;; TO ADD THREE WORDS TO FIELD 4
	RETURN			;;;RETURN TO ERROR LOGGER

10$:	MOV	#20$,(R2)	;;;USE THIS ROUTINE
	MOV	#-4*400+2,-(R2)	;;; TO ADD TWO WORDS TO FIELD 4
	RETURN			;;;RETURN TO ERROR LOGGER

20$:	CALL	DRVGST,R5,RLGSTS ;;;GET DRIVE'S STATUS
	MOV	R2,(R5)+	;;;SAVE (R3) -- CSR FOR READ-STATUS
	MOV	R1,(R5)+	;;;SAVE RLMP(R3) -- DRIVE'S STATUS
	RETURN			;;;ALL DONE

30$:	MOV	RLBE(R3),-(SP)	;;;SAVE RLBE(R3) -- BUS ADDRESS EXTENSION
	CALL	DRVGST,R5,RLGSTS ;;;GET DRIVE'S STATUS
	MOV	R2,(R5)+	;;;SAVE (R3) -- CSR FOR READ-STATUS
	MOV	R1,(R5)+	;;;SAVE RLMP(R3) -- DRIVE'S STATUS
	MOV	(SP)+,(R5)+	;;;GET BAE FOR DISPLAY
	RETURN			;;;ALL DONE

.DSABL	LSB
GLOBAL	<X.CON>

.SBTTL	PUT ALL DEVICE-SPECIFIC DATA INTO REQUEST (DSQ)

;+
; QDS$DL - QUEUE DISK I/O REQUEST.
;
;	R0 =  STARTING LBN (MSB)
;	R1 =  STARTING LBN (LSB)
;	R2 =  DISK DRIVER INDEX
;	R3 =  PHYSICAL UNIT NUMBER * 2
;	R4 -> DSQ
;	R5 =  FIP UNIT NUMBER * 2
;-
QDS$DL::MOVB	DSQSAV(R4),R3	;GET FUNCTION CODE
	MOVB	RLFUN-WFUN.C(R3),DSQFUN(R4) ;SET UP RL11 FUNCTION CODE	
	CMPB	R3,#IFUN	;IS THIS A DRIVE INITIALIZE?		;003
	BEQ	30$		;YEP					;003
	CMPB	R3,#RELFUN	;How about a Release?			;009
	BEQ	30$		;Yup.					;009
	CMPB	R3,#FMTFUN	;Format?				;010
	BEQ	30$		;Yo					;010
	DIV	#20.,R0		;DIVIDE FOR THE TRACK NUMBER
	ASH	#6,R0		;MOVE TO CYLINDER/TRACK NUMBER POSITION
	MOV	R0,DSQOPT(R4)	;STORE THE ANSWER (TRK NUM IN POSITION)
	ASL	R1		;CONVERT BLOCK NUMBER TO SECTOR NUMBER
	BIS	R1,R0		; AND PUT SECTOR INTO POSITION
	MOV	R0,DSQPDA(R4)	;NOW STORE CYL/TRACK/SECTOR
	MOV	DSQCNT(R4),DSQPTO(R4) ;STASH AWAY THE ACTUAL WORD COUNT
	NEG	DSQPTO(R4)	;NEGATE IT
	CLRB	DSQCTO(R4)	;ALLOW UNIT SELECTING AS A WORD
.ASSUME	DSQPUN	EQ DSQCTO!1	;UNIT MUST BE HIGH BYTE, WITH UNUSED LOW BYTE
30$:	MOVB	DSQOUN(R4),(R4) ;SELECT PROPER QUEUE ROOT
	CALL	@(SP)+		;NOW CO-ROUTINE RETURN			;003

GLOBAL	<UNTSIZ,DEVCLU,MID$XX>

;	WE ARE CALLED BACK IF REQUEST IS FIRST IN QUEUE.
;
;	R0 -> QUEUE ROOT
;	R3 -> CSR
;	R4 -> DSQ
;	PRIORITY LEVEL IS PR5

.ENABL	LSB

UMR$DL::
CKSEEK:	TST	DLDCTL		;;CONTROLLER BUSY?
	BNE	CKEXIT		;;YES, JUST EXIT
	MOV	#DQE$DL,R0	;;START OVER AT THE END
10$:	MOV	-(R0),R4	;;PICK UP REQUEST FOR THIS DRIVE
	BEQ	20$		;;NONE, NO NEED TO SEEK
	TST	DSO$XX(R0)	;;IS THE DRIVE IDLE?
	BNE	20$		;;NO, WE SHOULDN'T TOUCH IT
	CMPB	DSQSAV(R4),#IFUN;;IS THIS A DRIVE INITIALIZE?		;003
	BEQ	70$		;;YEP					;003
	CMPB	DSQSAV(R4),#RELFUN	;;How 'bout a Release?		;009
	BEQ	110$			;;Yup.				;009
	CMPB	DSQSAV(R4),#FMTFUN	;;How 'bout a FMTFUN?		;010
	BEQ	65$			;;Yo				;010
	INC	DSO$XX(R0)	;;CHANGE STATE TO SEEKING
	CALLX	OPTDSK,R5,OPT$DL ;;OPTIMIZE ITS QUEUE
	CALL	STSEEK		;;AND START IT SEEKING
20$:	CMP	R0,#DQS$DL	;;HAVE WE DONE ALL THE DRIVES YET?
	BHI	10$		;;NO, REPEAT

; START I/O ON SOME DRIVE THAT'S ON-CYLINDER

	MOV	#CNT.DL,R5	;;LOOK AT THIS MANY DRIVES
	MOV	DLDPT1,R0	;;IN A ROUND-ROBIN MANNER
30$:	CMP	R0,#DQS$DL	;;WRAPPING FROM START BACK TO THE END
	BHI	40$
	MOV	#DQE$DL,R0
40$:	MOV	-(R0),R4	;;GET REQUEST IN THIS QUEUE
	BEQ	50$		;;NO REQUEST, SO NO I/O TO BE DONE
	CMPB	DSO$XX(R0),#1	;;IS IT (OR WAS IT) SEEKING?
	BNE	50$		;;NO, DON'T CONSIDER IT
	CMP	DSO$XX(R0),#1	;;IS IT DONE NOW?
	BEQ	STIO		;;YES, NO NEED TO CHECK DRIVE STATUS
	CALL	DRVGST,R5,RLGSTS ;;NO, GET DRIVE STATUS
	BMI	50$		;;TIMEOUT -- IGNORE DRIVE FOR NOW
	ASR	R2		;;CHECK IF DRIVE IS READY
.ASSUME	RLDRDY	EQ	1
	BCS	STIO		;;READY, START THE I/O
50$:	SOB	R5,30$		;;KEEP LOOKING FOR A READY ONE
	MOV	#DQE$DL,R0	;;NONE ARE READY. CHOOSE ONE ARBITRARILY.
60$:	MOV	-(R0),R4	;;GET THIS DRIVE'S REQUEST
	BNE	STIO		;;IF THERE IS ONE, GO DO IT
	CMP	R0,#DQS$DL	;;REPEAT FOR ALL DRIVES
	BHI	60$
CKEXIT:	RETURN			;;NOTHING TO BE DONE

65$:	SETERR	ERRERR,DSQERR(R4)	;;FORMAT not supp here		;010
	BR	110$			;;join common			;010

	.PAGE
	.SBTTL	IFUN Request Handler

GLOBAL	<NOTAVL,HNGDEV,ERRERR>
;+
;
;	I F U N   R E Q U E S T   H A N D L E R				;007
;
; The IFUN (Initialize FUNction) is used to check for the presence of a
; given RL01/RL02 drive, and to determine the drive type and fill in the
; UNTSIZ and DEVCLU table entries if it's there.
;
; Here are the steps taken for an IFUN request;
;
; 1)	Do a controller reset.
; 2)	Do a Get Status for the drive in question.
; 3)	Check the RLCS (Control and Status) register to see if the OPI
;	(Operation Incomplete) bit is set.  If so, the drive in question
;	is not present, so we return a '?Device not available' code in the
;	DSQ, but we do not log a hard error.
; 4)	If OPI is not set, we then check the Drive Ready bit in the RLCS.
;	If it's set, then the drive is online and ready.
;	If it's clear, then the drive is present, but is not ready, so we
;	return a '?Device hung or write locked' error in the DSQ, but again
;	we do not log a hard error.
;
; In any case, after we determine one of the above conditions to be true, the
; RLCS and RLMP (Multi Purpose) registers are checked for other hard errors.
; If any are found, the determination is ignored and a hard error is logged
; against the drive.
;
;-

70$:	MOVB	DSQUNT(R4),R5		;;GET FIP UNIT NUMBER		;003
	ASL	R5			;;TIMES TWO			;003
	CLR	MID$XX(R5)		;;SAY IT'S AN RL01		;005
	CLR	UNTSIZ(R5)		;;Say no unit size for now	;007
	CALL	DRVCLR,R5,RLGSTS	;;RESET DRIVE AND GET STATUS	;005
					;;On return from DRVCLR,	;007
					;;R1 = RLMP and R2 = RLCS	;007
	BIT	#RLOPI,R2		;;Is OPI set?			;007
	BEQ	80$			;;If not, the drive is there.	;007
	MOVB	#NOTAVL,DSQERR(R4)	;;Otherwise, it's not.		;007
	BR	90$			;;Tell 'em and check for errors	;007

80$:	BIT	#1,R2			;;Is the drive ready??		;007
	BNE	90$			;;Yup - go check for errors.	;007
	MOVB	#HNGDEV,DSQERR(R4)	;;If not, tell 'em about it.	;007
90$:	BIT	#074000,R2		;;Any errors set??		;007
	BNE	120$			;;Yup, hard error time!!	;007
	BIT	#156400,R1		;;How about here??		;007
	BNE	120$			;;Yup, same thing.		;007
	TSTB	DSQERR(R4)		;;Error code in DSQERR?		;007
	BPL	110$			;;If so, don't size drive	;007
	MOV	R1,MID$XX(R5)		;;Copy the Drive Status		;007
	MOVB	#1,DEVCLU(R5)		;;SET DCS=1			;004
	MOV	#10220.,UNTSIZ(R5)	;;Assume it's an RL01		;007
	BIC	#^C<RLDT>,MID$XX(R5)	;;GET DRIVE TYPE		;003
	BEQ	110$			;;If RL01, leave UNTSIZ alone	;003
	MOV	#20460.,UNTSIZ(R5)	;;Otherwise, put in RL02 size	;007
110$:	CALLX	DFINT9			;;DEQUEUE REQUEST, SET L3Q BITS	;003
	BR	20$			;;REQUEST IS DONE		;003

120$:	CLZ				;;SAY HARD ERROR		;003
	LOG$DL				;;LOG AN ERROR			;003
	CALLX	DFINT1			;;CHECK CC'S AND COUNT ERROR	;003
	BR	110$			;;EXIT				;003

.DSABL	LSB

GLOBAL	<DLDCTL,DLDPT1,DSO$XX,DQS$DL,DQE$DL,OPT$DL,CNT.DL>		;003

.SBTTL	INTERRUPTS (PR5)

INT$DL::MOV	CSR.DL,R3	;;GET THE CSR ADDRESS
	NOP			;;PATCH SPACE
	MOV	DLDCTL,R0	;;WHAT WAS HAPPENING?
	BEQ	GOCKSK		;;NOTHING, SEE WHAT THERE IS TO BE DONE	;010
	CLR	DLDCTL		;;NO LONGER HOLDING THE CONTROLLER
	MOV	(R0),R4		;;GET REQUEST FROM THE TOP OF QUEUE
	TSTB	DSO$XX(R0)	;;WAS THIS A 1-TRACK SEEK FOR RD-HEADER?
	BNE	GOCKSK		;;YES, SEE WHAT'S TO BE DONE
	CALL	@RELUMR		;;RELEASE ANY WINDOWS WE'RE HOLDING
	MOV	(R3),R2		;;SAVE CSR
	BMI	DLEROR		;;IF MI - ERROR
	MOV	DSQCNT(R4),R1	;;GET WORD COUNT OF LAST TRANSFER
	SUB	R1,DSQPTO(R4)	;;CALCULATE WORDS REMAINING TO TRANSFER
	BEQ	DLDONE		;;IF ZERO - REQUEST COMPLETE
	NEG	R1		;;MAKE WORD COUNT POSITIVE
	ASL	R1		;;MAKE WORD COUNT A BYTE COUNT
	ADD	R1,DSQMAL(R4)	;;UPDATE BUS ADDRESS
	ADCB	DSQMAM(R4)	;; AND BUS ADDRESS EXTENSION BITS
	BIS	#77,DSQPDA(R4)	;;INCREMENT SURFACE AND CYLINDER
	INC	DSQPDA(R4)	;;WHILE CLEARING SECTOR NUMBER
	MOV	RLDA(R3),R1	;;GET CURRENT DISK ADDRESS
	CALL	DOSEEK		;;START SEEK TO NEXT TRACK
STIO:	MOV	R0,DLDPT1	;;REMEMBER WHO GOT TO DO I/O
	MOV	DSQPDA(R4),R2	;;GET DESIRED DISK ADDRESS
	BIC	#^C<77>,R2	;;ISOLATE THE SECTOR
	SUB	#40.,R2		;;COMPUTE NEGATIVE SECTORS LEFT ON TRACK
	ASH	#7,R2		;;CONVERT TO NEGATIVE WORDS LEFT ON TRACK
	CMP	R2,DSQPTO(R4)	;;IS WORDS ON TRACK LESS THAN REQUESTED COUNT?
	BHIS	10$		;;YES, USE WORD COUNT IN R2
	MOV	DSQPTO(R4),R2	;;NO, GET DESIRED WORD COUNT IN R2
10$:	MOV	R2,DSQCNT(R4)	;;SET WORD COUNT FOR LATER REFERENCE
	MOV	R2,RLMP(R3)  	;;LOAD WORD COUNT REGISTER
	MOV	DSQPDA(R4),RLDA(R3) ;;LOAD DISK ADDRESS REGISTER
	CALLX	DSKUMR		;;TRY TO MAP THIS TRANSFER
	MOV	R2,RLBA(R3)	;;SET LOW ADDRESS
	BIT	#XC$QBU,@#X.CON	;;IS SYSTEM USING A Q-BUS?
	BEQ	20$		;;NO
	BIT	#XC$22,@#X.CON	;;Is physical memory > 248KB?
	BEQ	20$		;;NO
	MOVB	R1,RLBE(R3)	;;YES, SET HIGH ADDRESS
20$:	MOV	#-5*400,DSO$XX(R0) ;;SET TIME-OUT, & STATUS = DOING I/O
	MOV	R0,DLDCTL	;;WE ARE CURRENT USER OF CONTROLLER
	ASH	#4,R1		;;MOVE BUS EXTENSION BITS INTO POSITION
	BIC	#177717,R1	;;PREVENT HIGHER ADDRESS BITS FROM GOING IN RLCS
	BISB	DSQFUN(R4),R1	;;MERGE IN FUNCTION
RLSIO:	CLRB	DSQCTO(R4)	;;Don't assume the low byte is clear!	;005
	BIS	DSQPUN-1(R4),R1	;;MERGE UNIT NUMBER IN HIGH BYTE
.ASSUME	DSQPUN&1 EQ 1		;;UNIT NUMBER BYTE MUST BE ODD
	MOV	R1,(R3)		;;INITIATE THE FUNCTION
DLRET:	RETURN			;;AND EXIT

GOCKSK:	JMP	CKSEEK		;;This fixes an out-of-range branch.	;009

GLOBAL	<X.CON>
GLOBAL	<DLDCTL,DLDPT1,RELUMR>

;	TIMEOUTS AND ERRORS

DLEROR:	CLR	DSO$XX(R0)	;;The drive should be idle now		;006
	BIT	R2,#RLDRDY	;;Is the drive ready?			;008
	BEQ	HARDER		;;Nope, hard error.			;008
	BIT	R2,#RLNXM	;;NXM?					;008
	BNE	HARDER		;;Yup, that's one too.			;008
	BIT	R2,#4000	;;Write check error??			;008
	BEQ	30$		;;Nope, go find out more info.		;008
	BIT	R2,#RLOPI	;;If it's a WCHK, is OPI set?		;008
	BEQ	40$		;;Nope - it must be a real WCHK error.	;008
30$:	CALL	DRVGST,R5,RLGSTS ;;GET DRIVE STATUS
	BIT	R1,#177400-RLWGE-RLWLS ;;ANY ERROR SET BESIDES WRITE GATE?
	BNE	HARDER		;;YES, THOSE ARE HARD
	BIT	R1,#RLWGE	;;WRITE GATE ERROR?
	BEQ	RETRY		;;No, go try it again.			;008
	BIT	R1,#RLWLS	;;IS DRIVE WRITE LOCKED?
	BNE	HARDER		;;YES, HARD ERROR
	BR	RETRY		;;Otherwise, just try it again.		;008

40$:	MOVB	#DATERR,DSQERR(R4)	;;Stick the error away...	;008
	BR	DLDONE			;; ...and go back for more.	;008

.ENABL	LSB

TMO$DL::			;;TIMEOUT ENTRY POINT
RETRY:	CMP	(PC),(PC)+	;;SET Z FOR SOFT ERROR, SKIP NEXT INSTRUCTION
HARDER:	CLZ			;;INDICATE HARD ERROR
	LOG$DL			;;LOG AN ERROR HERE
	CALLX	DFINT1		;;CHECK CC'S AND COUNT ERROR
	BMI	10$		;;RETRIES LEFT, SO RETRY IT
	MOVB	DSQOUN(R4),R2	;;GET UNIT*2
	CLR	DLDPOS(R2)	;;INDICATE POSITION NO LONGER KNOWN
DLDONE:	CALLX	DFINT9		;;DEQUEUE THIS REQUEST
	BR	20$		;;AND START THE NEXT OPERATION

10$:	MOVB	DSQOUN(R4),R2	;;GET UNIT*2
	CLR	DLDPOS(R2)	;;INDICATE POSITION NO LONGER KNOWN
20$:	JMP	CKSEEK		;;AND START THE NEXT OPERATION

.DSABL	LSB

GLOBAL	<CSR.DL,DQS$DL,DSO$XX,OPT$DL,DATERR>				;008

STSEEK:	MOVB	DSQUNT(R4),R5	;;GET FIP UNIT NUMBER
	ASL	R5		;;WE'LL WANT 2* FIP UNIT NUMBER
	CALL	DRVGST,R5,RLGSTS ;;GET DRIVE'S STATUS
	BIT	R2,#RLOPI	;;OP INCOMPLETE?
	BNE	HARDER		;;YES, FAILURE -- NO DRIVE
	BIT	R1,#RLVC	;;VOLUME CHECK SET?
	BEQ	10$		;;NO, EVERYTHING'S FINE
	BIT	#UC.MNT!UC.NFS,UNTCNT(R5) ;;YES, IS DISK NOT MOUNTED, OR NFS?
	BEQ	HARDER		;;NO, SO IMITATE A VOLUME-NOT-VALID ERROR
10$:	BIC	#^C<RLDT>,R1	;;MASK TO DRIVE TYPE
	CMP	R1,MID$XX(R5)	;;IS IT WHAT WE EXPECTED?
	BNE	HARDER		;;DRIVE TYPE MISMATCH
	CALL	DRVCLR,R5,RLGSTS ;;RESET DRIVE AND GET ITS STATUS
	BIC	#RLWLS!RLHSS!RLDT,R1 ;;REMOVE IRRELEVANT BITS
	CMP	R1,#RLHH!RLBH!RLSLM ;;HEADS, BRUSHES, AND STATE OK?
	BEQ	20$		;;YES, CONTINUE WITH REQUEST
	CMP	R1,#RLHH!RLBH!RLTCM ;;IS IT OK, EXCEPT SEEKING?
	BNE	HARDER		;;NO -- REPORT A HARD ERROR
	MOV	#-1*400+377,DSO$XX(R0) ;;SET <= 1 SEC TIMEOUT -- JUST WAITING
	RETURN			;;WAIT FOR TIMEOUT

20$:	BIT	#RLDRDY,(R3)	;;DRIVE READY?
	BEQ	HARDER		;;NO -- WHY NOT??
	MOVB	DSQOUN(R4),R2	;;GET 2* DRIVE NUMBER
	MOV	DLDPOS(R2),R1	;;GET DRIVE'S CURRENT POSITION
	BIT	#1,R1		;;IS IT KNOWN?
	BNE	DOSEEK		;;YES, USE IT
	MOV	#16.,R5		;;SET READ HEADER RETRY COUNT
30$:	CALL	DRVCMD,R5,RLRDH	;;READ NEXT SECTOR HEADER
	BPL	DOSEEK		;;IF PL FUNCTION EXECUTED OK
	SOB	R5,30$		;;RETRY 15 TIMES
	LOG$DL			;;LOG AN ERROR
	CALLX	DFINT3		;;COUNT AGAINST USER RETRY COUNT
	BPL	DLDONE		;;GIVE UP IF NO MORE RETRIES
	TST	(SP)+		;;DUMP RETURN, 'CAUSE WE'RE DOING I/O
	MOV	#-5*400+1,DSO$XX(R0) ;;SET SEEK FLAG AND TIMEOUT COUNT
	CALL	DRVCLR,R5,RLGSTS ;;RESET DRIVE
	MOV	#RLREV,RLDA(R3)	;;LOAD REVERSE SEEK DIFFERENCE WORD
	CALL	DRVCMD,R5,RLSEEK ;;START A SEEK
	BMI	HARDER		;;QUIT ON ANY ERROR
	MOV	R0,DLDCTL	;;FLAG CONTROLLER IS IN USE
	MOV	#RLRDH+IE,R1	;;GET READ-HEADER FUNCTION TO CAUSE INTERRUPT
	JMP	RLSIO		;;GO START I/O

GLOBAL	<UNTCNT,DLDCTL,MID$XX,DSO$XX,IE>

DOSEEK:	MOV	#1,DSO$XX(R0)	;;MARK AS SEEKING OR WAITING FOR I/O
	MOV	DSQPDA(R4),R2	;;GET DESIRED DISK ADDRESS
	MOV	R2,R5		;;COPY TO A TEMPORARY
	XOR	R1,R5		;;FORM DIFFERENCE
	BIC	#77,R5		;;IGNORING SECTOR BITS
	BEQ	30$		;;NO DIFFERENCE, NO SEEK REQUIRED
	MOV	R2,R5		;;SAVE DESIRED TRACK
	BIC	#177,R1		;;KEEP ONLY CYLINDER NUMBERS
	BIC	#177,R2		;;...
	SUB	R2,R1		;;SUBTRACT DESIRED FROM ACTUAL
	BHIS	10$		;;SKIP IF ACTUAL >= DESIRED
	NEG	R1		;;ACTUAL < DESIRED, MAKE POSITIVE DIFFERENCE
	BIS	#RLSN,R1	;;SET PLUS SIGN FOR MOVE TO CENTER OF DISK
10$:	INC	R1		;;SET MARKER BIT
	ASLB	R5		;;WHICH TRACK DID WE WANT?
	BPL	20$		;;ZERO, NO ACTION NEEDED
	BIS	#RLHS,R1	;;SELECT HEAD 1
20$:	MOV	R1,RLDA(R3)	;;LOAD DIFFERENCE WORD
	MOVB	#-5.,DSO$XX+1(R0) ;;SET TIMEOUT FOR THE SEEK
	CALL	DRVCMD,R5,RLSEEK ;;START SEEK FUNCTION
	BPL	30$		;;SKIP IF SUCCESS
	JMP	HARDER		;;QUIT ON ANY ERROR

30$:	MOVB	DSQOUN(R4),R2	;;GET UNIT*2
	MOV	DSQPDA(R4),DLDPOS(R2) ;;UPDATE KNOWN POSITION FOR THE DRIVE
	BIS	#1,DLDPOS(R2)	;;MARK THAT IT IS KNOWN
	RETURN			;;SEEK HAS BEEN INITIATED IF NEEDED

GLOBAL	<DSO$XX,DLDPOS>

.SBTTL	ISSUE A COMMAND

;+
; DRVCLR - RESET THE DRIVE AND GET ITS STATUS.
; DRVGST - GET THE DRIVE'S STATUS
; DRVCMD - ISSUE A COMMAND.
;
;	R3 -> CSR
;	R4 -> DSQ
;
;	CALL	DRVCLR,R5,<FUNCTION>
;	CALL	DRVGTS,R5,<FUNCTION>
;	CALL	DRVCMD,R5,<FUNCTION>
;
;	R1 =  MULTI-PURPOSE [RLMP(R3)], OR -1 FOR TIMEOUT
;	R2 =  CSR CONTENTS [(R3)], OR -1 FOR TIMEOUT
;
;	IF N=1 THEN ERROR
;	IF N=0 THEN NO ERROR
;-

DRVCLR:	MOV	#RLRST!RLSTS!RLMRK,RLDA(R3) ;;SET MESSAGE CODES IN RLDA
	CALL	DRVCMD,R5,RLGSTS ;;DO THE DRIVE RESET FIRST
DRVGST:	MOV	#RLSTS!RLMRK,RLDA(R3) ;;SET MESSAGE CODES IN RLDA
DRVCMD:	MOV	(R5)+,R1	;;GET THE FUNCTION TO ISSUE
	MOVB	DSQUNT(R4),R2	;;GET THE FIP UNIT NUMBER
	ASL	R2		;; TIMES 2 FOR WORD ADDRESSING
	MOV	MID$XX(R2),R2	;;IS UNIT DISABLED?
	BMI	30$		;;YES, HARD ERROR
	CALL	RLSIO		;;NO, ISSUE FUNCTION R1 TO UNIT DSQPUN(R4)
	MOV	#100,R2		;;Wait for 600ms maximum.		;007
10$:	MOVB	TIMCLK,R1	;;GET CURRENT CLOCK TICK VALUE
20$:	TSTB	(R3)		;;CONTROL READY YET?
	BMI	30$		;;YES, READ CSR & MULTI-PURPOSE
	CMPB	R1,TIMCLK	;;HAS THE CLOCK TICKED?
	BEQ	20$		;;NO, KEEP WAITING
	DEC	R2		;;YES, IS TIME EXPIRED?
	BPL	10$		;;NO, WAIT FOR IT TO TICK AGAIN
30$:	MOV	R2,R1		;;COPY TIMEOUT INDICATOR TO R1
	BMI	40$		;;IT WAS SET -- RETURN IMMEDIATELY
	MOV	RLMP(R3),R1	;;GET MULTI-PURPOSE REGISTER
	MOV	(R3),R2		;;GET CSR CONTENTS
40$:	RETURN	R5		;;AND EXIT

GLOBAL	<MID$XX>

.END
