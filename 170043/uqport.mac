	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
	.INCLUDE /DSK:MSCPDF/
TITLE	UQPORT,<U/Q PORT DRIVER>,0I,31-JAN-92,TPT/MND/DBM/VAM/FEK

;
;		COPYRIGHT (c) 1974, 1992 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR UQPORT

;+
;			[RSTS/E V9.1]
;  000	TPT  29-Oct-84	Original code from DUDVR by AJK/JHC/DRP
;  001	MND  12-Dec-84	Globalized UMR$DU, TMO$DU, and QDS$DU (now in class)
;  002	MND  12-Dec-84	Remove PD.DQS from Port driver dispatch table
;  003	TPT  04-Feb-85	Only UMT$MU for now...
;  004	TPT  07-May-85	Merge MSCP disk/tape 
;  005	TPT  17-May-85	Modified cross overlay globals for INIT.SYS
;  006	DBM  30-May-85	Move disk error log code to DUDSK
;  007	TPT  12-Jun-85	Globalize INT.PH
;  008	TPT  18-Jun-85	Stuff UMT$MU entry for INIT, merge INICCB/INITAP
;  009	DBM  15-Jul-85	Fix LOGERR - log MU errors correctly
;  010	TPT  20-Aug-85	Get multi-controller support working correctly
;
;				[RSTS/E V9.2]
;  011	TPT  17-Dec-85	Fix TMSCP only problems, once and for all!
;
;				[RSTS/E V9.3]
;  012  VAM  27-Jul-86	Change call to DU$ERL in LOGERR to a LOG$DU.
;			Also fix autoload vector calls for INIT.
;
;				[RSTS/E V9.4]
;  013  VAM  15-Apr-87	Fix BEM in SETRNG.
;
;				[RSTS/E V10.1]
;  014	FEK  30-Aug-91	Mark unused UCBs for tape as unused.
;  015	FEK  30-Dec-91	Allow correct number of UCBs.
;-


.SBTTL	U/Q PORT DRIVER DESCRIPTION

;+
; THE U/Q PORT DRIVER IS VERY SIMILAR TO A NON-MSCP DISK DRIVER
; UNDER RSTS.  IT HAS ALL THE ENTRIES THAT A NON-MSCP DISK DRIVER HAS.
; BUT IN ADDITION, IT HAS SPECIAL PURPOSE ROUTINES THAT ARE CALLED BY
; THE LEVEL 3 MSCP PROCESSOR.  THESE ROUTINES PERMIT THE MSCP PROCESS
; TO PERFORM CONTROLLER DEPENDENT FUNCTIONS, SUCH AS INITIALIZING THE
; RINGS, SERVICING INTERRUPTS AND TRANSFERING INFORMATION VIA THE
; PHYSICAL PORT.
;
; THE PORT DRIVER PERFORMS PORT DEPENDENT/RELATED FUNCTIONS.  ALL MSCP
; PROTOCOL PROCESSING IS DONE BY THE LEVEL 3 PROTOCOL HANDLER (CALLED
; THE "CLASS DRIVER").
;
;
; THE FOLLOWING IS A LIST OF ENTRIES INTO THE PORT DRIVER AND THEIR
; EXPLANATION:
;			 *** NOTE ***
; *****************************************************************
; *ALL THESE ENTRIES MUST BE PRESENT IN ALL FUTURE PORT DRIVERS!!!*
; *****************************************************************
;
; THE FOLLOWING ARE STANDARD RSTS DISK DRIVER ENTRIES
; ---------------------------------------------------
;
;
; INT$PH:(INT$xx)
;   INTERRUPT SERVICE PROCESSOR.
;
; TMO$DU:
;   TIME OUT PROCESSOR.  THIS ENTRY JUMPS TO A COMMON TIME OUT PROCESSOR
;   IN THE LEVEL 3 MSCP PROCESS.
;
;
; SPECIAL PURPOSE ROUTINES TO BE CALLED BY THE MSCP PROCESS
; ---------------------------------------------------------
;
; INICCB:
;   THIS CODE IS RESPONSIBLE FOR INITIALIZING CCB DATA STRUCTURES IN
;   THE MSCP REGION WITH CONTROLLER DEPENDENT INFORMATION.
;
; INIUDA:
;   THIS ROUTINE INITIALIZES THE UDA CONTROLLER.
;
; GETCMP:
;   THIS ROUTINE IS USED TO OBTAIN A COMMAND PACKET FOR THE CLASS DRIVER.
;
; XFRCMD:
;   ROUTINE TO PASS A COMMAND PACKET TO THE CONTROLLER. (IN THE CASE OF
;   THE UDA, REQUEST THAT THE CONTROLLER POLL IT'S COMMAND RING)
; 
; GETRSP:
;   ROUTINE TO GET A RESPONSE MESSAGE FROM THE CONTROLLER RESPONSE RING.
;
; RELMPK:
;   MESSAGE IN PACKET HAS BEEN PROCESSED.  RETURN MESSAGE PACKET
;   OWNERSHIP TO CONTROLLER.
;
; LOGERR:
;   ROUTINE TO INTERFACE WITH RSTS ERROR LOG MECHANISM FOR LOGGING
;   [T]MSCP SPECIFIC INFORMATION.
;
;-

	DEFORG	UQPORT
	DEFORG	AVLTBL

	ORG	UQPORT


.SBTTL	UQPORT  AVAILABLE TABLE

	TMPORG	AVLTBL		; CREATE AVAILABLE TABLE ENTRY

;+
; NOTE:
; THE PORT DRIVER MUST HAVE AN ENTRY FOR EACH OF THE ENTRIES IN THIS
; TABLE.  FUNCTION WISE THE ORDER OF THE ENTRIES IN THIS TABLE MUST 
; BE THE SAME FOR ALL PORT DRIVERS.
;-

	.WORD	UDA50		  ; 1. MASS STORAGE CONTROL TYPE
	.WORD	INICCB		  ; 2. INITIALIZE CCB DATA STRUCTURES ENTRY
	.WORD	INIUDA		  ; 3. INITIALIZE UDA CONTROLLER PORT
	.WORD	GETCMP		  ; 4. GET COMMAND PACKET
	.WORD	XFRCMD		  ; 5. TRANSFER COMMAND PACKET TO CONTROLLER
	.WORD	GETRSP		  ; 6. GET A MESSAGE PACKET FROM CONTROLLER
	.WORD	RELMPK		  ; 7. RELEASE MESSAGE PACKET
	.WORD	LOGERR		  ; 8. ERROR LOG ENTRY
	.WORD	<DQE$DU-DQS$DU+1>/2 ;10. NUMBER OF MSCP UNITS

	UNORG

.SBTTL	LOGERR - SET UP FOR ERROR LOG ROUTINE

;+
; LOGERR
;
; THIS ROUTINE IS CALLED TO DO THE ERROR LOG CALL.  IT IS
; INCLUDED WITH THE PORT DRIVER TO MAKE THE CLASS DRIVER
; INDEPENDENT OF PORT SPECIFIC FUNCTIONS.
;
; INTPUT:	R0 -> QUEUE ROOT
;		R1 -> ERROR LOG PACKET (R1=0 IF NO ERROR LOG PACKET)
;		R2 -> PORT DRIVER AVAILABLE DISPATCH TABLE
;		R3 -> CSR
;		R4 -> DSQ (IF DSQ EXISTS, OTHERWIESE R4 = 0)
;		R5 -> CCB
;
; OUTPUT:	ERROR LOGGED
;
; R2 CHANGED
;-

LOGERR:	MOV	R2,-(SP)	;SAVE A REGISTER			;009
	MOV	C.CMT(R5),R2	;PICK UP CMT OFFSET			;009
	TSTB	CMT+CM.FLG(R2)	;DISK CLASS CONTROLLER?			;009
.ASSUME	CF.DSK	EQ	200
	BPL	4$		;NOPE, SO LOG TAPE ERROR		;009
	MOV	(SP)+,R2	;RESTORE REG				;009
	LOG$DU			;Log a disk error.			;012
	BR	8$		;Carry on				;006

4$:	MOV	(SP)+,R2	;RESTORE REG				;009
	CALLMI	$LOGMU,BBRAP5	;Log a tape error or crash		;012
8$:	MOV	R1,-(SP)	; SAVE R1 & R2				;006
	MOV	R2,-(SP)	;
	MOV	#MSCPPK,R1	; R1 -> SAVE AREA FOR ERROR PACKET
	MOV	#MSCPWC,R2	; R2 -> ERROR LOG SAVE AREA SIZE
10$:	CLR	(R1)+		; CLEAR AREA BEFORE SAVING CURRENT PACKET
	SOB	R2,10$		; LOOP
	MOV	(SP)+,R2	; RESTORE R1 & R2
	MOV	(SP)+,R1	; 
	RETURN			; RETURN TO CALLER

	GLOBAL	<MSCPPK,MSCPWC>

;+
;	ERRDSP -- 
;	
;	This is for handling mapped calls from the BBR phase.
;
;	CALLM	ERRDSP,MCPAP5
;
;	-- On entry, R2 -> Port Dispatch table
;
;	-- Exit is same as normal error logging.
;-

ERRDSP::NOP			;To simplify debugging			;002
	CALL	@PD.ERL(R2)	; now that we're mapped, just go for it,;002
	RETURN			; and dance back into BBR phase.	;002

.SBTTL	INT$PH - CONTROLLER INTERRUPT SERVICE ENTRY

;+
; INT$PH
;
; DUE TO OCCASIONAL HEAVY MSCP CPU ACTIVITY, THE INTERRUPT
; IS MERELY NOTED BY REQUESTING LEVEL 3 SERVICE.  THE LEVEL
; 3 PROCESS WILL THEN SCAN FOR AND SERVICE INTERRUPTING
; CONTROLLER.
;-

INT$PH::MAP	PUSH,APR=6,DATA	;; SAVE CURRENT APR6	;007
	MUL	#CMTSIZ/2,R0	;; MULTIPLY <CONTROLLER #>*2 BY CMT
				;; .. <ENTRY SIZE>/2 TO GET INDEX INTO CMT
				;; R1 NOW = INDEX TO CMT
	ADD	#CMT,R1		;; POINT TO CMT ENTRY FOR CONTROLLER
	MAP	CM.AP6(R1),APR=6,DATA ;; MAP TO CCB
	MOV	CM.COF(R1),R5	;; R5=OFFSET TO CCB BASE
	BIT	#CS.ONL,(R5)	;; CONTROLLER ONLINE?
	.ASSUME	C.STAT	EQ	0
	BEQ	10$		;; NO, SKIP CLEARING INTERRUPT INDICATORS
	MOV	C.FRSP(R5),R3	;; R3 -> 1ST RING ENTRY
	TST	-(R3)		;; POINT TO TOP OF RING HEADER
	CLR	-(R3)		;; CLEAR RESP INTERRUPT INDICATOR
	CLR	-(R3)		;; CLEAR COMMAND INTERRUPT INDICATOR
10$:	MOV	CM.CSR(R1),R3	;; R3=CONTROLLER IP REGISTER ADDR
	TST	UDASA(R3)	;; FATAL CONTROLLER ERROR?
	BGE	20$		;; NO
	CLR	(R5)		;; FORCE REINITIALIZATION
	.ASSUME	C.STAT	EQ	0
20$:	MOV	R1,R4		;; R4 -> CMT TABLE ENTRY FOR THIS CONTROLLER
	CALLX	REQSER		;; Request service for controller.	;012
	MAP	POP,APR=6,DATA	;; RESTORE APR 6 MAPPING
	RETURN			;; WILL PROCESS ON LEVEL 3

.SBTTL	INICCB - INITIALIZE CONTROLLER CONTROL BLOCK

;+
; INICCB
;
; THIS CODE IS RESPONSIBLE FOR INITIALIZING CCB DATA STRUCTURES
; WITH CONTROLLER DEPENDENT INFORMATION.
; 
;
; INPUT:	R5 -> CCB (APR6 IS MAPPED TO CCB)
;		R4 -> CMT ENTRY 
;
; OUTPUT:	UDA50 DEPENDENT STRUCTURES ARE INITIALIZED
;		C.TIMR=CONTROLLER WORK AREA SIZE
;
; REGISTERS PRESERVED
;-

INICCB:	REGSCR				; SAVE REGISTERS

;+
; THE PORT DRIVER WHOSE DQS$?? IS USED AS QUEUE ROOT IS CONSIDERED
; TO BE THE PRIMARY PORT DRIVER.  MEANING, IT'S QUEUE ROOT WILL  BE
; USED FOR QUEUEING AND ONLY IT WILL CALL THE MSCP PROTOCAL HANDLER
; TO REPORT UMR NOTIFICATION.  ALSO, IT'S DSS$?? WILL BE USED FOR
; TIMING PURPOSES.
;-
	CLR	CMT+CM.CRQ		;-Reset 1st time initialize flag
	CLR	(R5)			; SAY, CONTROLLER INITIALIZATION
	.ASSUME	C.STAT	EQ	0	; REQUIRED
	MOV	#UMT$DU,C.UMT(R5)	;ASSUME DISK CONTROLLER		;004
	MOV	R4,C.CMT(R5)		;SAVE CMT TABLE OFFSET	
	SUB	#CMT,C.CMT(R5)		;
	BICB	#^C7,CM.RSP(R4)		; CLEAR HIGH ORDER BITS OF RESPONSE
					; .. RING SIZE; EXP. IN POWERS OF 3
	BICB	#^C7,CM.CMD(R4)		; CLEAR HIGH ORDER BITS OF COMMAND
					; .. RING SIZE; EXP. IN POWERS OF 2
	MOVB	CM.RSP(R4),R1		; R1=RESP. RING SIZE IN POWERS OF 2
	CALL	CONVRT			; CONVERT IT TO AN INTEGER
	MOVB	R1,C.RSP(R5)		; SAVE RESP. RING SIZE IN CCB
	MOVB	CM.CMD(R4),R1		; R1=COMMAND RING SIZE IN POWERS OF 2
	CALL	CONVRT			; CONVERT IT TO AN INTEGER
	MOVB	R1,C.CMD(R5)		; SAVE COMMAND RING SIZE
	MOV	#RTRYCT,C.RTRY(R5)	; SET RETRY COUNTER

;+
; THIS CODE SETS UP THE "C.ITBL" OF THE CCB.  THE "C.ITBL" CONTAINS
; THE FOLLOWING:
;
; WORD 1 = BITS  0- 6 CONTAINS INTERRUPT VECTOR/4
;	   BIT      7 INTERRUPT ENABLE BIT
;	   BITS  8-10 RESPONSE RING SIZE, EXPRESSED IN POWERS OF 2
;	   BITS 11-13 COMMAND RING SIZE, EXPRESSED IN POWERS OF 2
;	   BIT     14 ZERO
;	   BIT     15 1 TO KEEP CONTROLLER FROM INTERPRETING IT AS AN
;		      ADAPTER PERGE REQUEST.
;
; WORD 2 = BIT      0 0 TO KEEP CONTROLLER FROM INTERPRETING IT AS AN
;		      ADAPTER PERGE REQUEST.
;	   BITS  1-14 RING BASE LOW ADDRESS
;
; WORD 3 = BIT   0-14 RING BASE HIGH ADDRESS
;	   BIT     15 0 TO KEEP CONTROLLER FROM INTERPRETING IT AS AN
;		      ADAPTER PERGE REQUEST.
;
; WORD 4 = BIT      0 GO BIT
;	   BIT	    1 1, MEANS HOST WANTS LAST FAIL RESPONSE PACKET
;	   BIT   2- 7 BURST RATE (ZERO MEANS DEFAULT)
;	   BIT   8-15 ZERO (RESERVED)
;-

	MOV	R5,R3			; R3=CCB OFFSET
	ADD	#C.ITBL,R3		; R3->C.ITBL WORD IN CCB
	BINIT	10$			; IS INTERRUPT TO BE ENABLED?	;011
					; NO, DON'T GIVE IT A VECTOR.  THE
					; .. CONTROLLER WILL NOT TALK TO YOU
					; .. IF YOU DO!!!!!!!!!!!!!!!!!!!!!!
	MOVB	CM.VTR(R4),(R3)		; SET VECTOR/4 IN INIT TABLE
10$:	BISB	#IE*2,(R3)+		; SET INTERRPUT ENABLE
	MOVB	CM.CMD(R4),R1		; R1=COMMAND RING SIZE
					; ..(IN POWERS OF 2)
	ASH	#3,R1			; SHIFT TO BITS 3 THROUGH 5
	BIC	#^C70,R1		; CLEAR UNWANTED BITS
	BISB	CM.RSP(R4),R1		; OR IN RESPONSE RING SIZE
	MOVB	R1,(R3)			; SET COMMAND RESPONSE RING LENTH IN
					; ..INIT TBL
	BISB	#200,(R3)+		; TELL CONTROLLER THIS IS NOT AN
					; ..ADAPTER PURGE
	MOVB	CM.FLG(R4),R1		; Get number of units
	BIC	#^C<CF.UNT>,R1		; and just the number of units
	MUL	#UCBSIZ,R1		; now, the size of their UCBs.
	ADD	R5,R1			; GENERATE BASE ADDR OF RINGS
	ADD	#CCBSIZ+RNGHED,R1	; R1=BASE ADDR OF RINGS
	CALL	MAPBUS			; CONVERT IT TO UNIBUS ADDRESS
	MOV	R1,(R3)+		; SAVE LOW ADDRESS OF RING BASE
					; .. IN C.ITBL
	MOV	R0,(R3)+		; SAVE HIGH ADDRESS OF RING BASE
					; .. IN C.ITBL
	MOV	#LFAIL!GO,(R3)		; SET LAST FAIL AND GO BITS IN C.ITBL

;+
; NOW COMPUTE CONTROLLERS WORK AREA SIZE AND COMPARE SIZE TO THAT IN "CM.WKA"
; OF THE CMT ENTRY FOR THIS CONTROLLER.  WE DO THIS TO HAVE SOME CONSISTANCY
; CHECKING BETWEEN INIT AND THE DRIVER BY CHECKING IF INIT HAS COMPUTED THE
; SAME WORK AREA SIZE FOR THIS CONTROLLER AS WE HAVE.
;-

	MOVB	C.CMD(R5),R1		; R1=COMMAND RING SIZE
	MUL	#CMDLNG+RNGSIZ+ENVLP,R1	; R1=ACCOUNT FOR COMMAND RING ENTRIES,
					; .. COMMAND PACKETS AND PACKET 
					; .. ENVELOPES.
	MOV	R1,-(SP)		; SAVE IT IN CMT ENTRY
	CLR	R1			; R1=0
	MOVB	C.RSP(R5),R1		; R1=RESPONSE RING SIZE
	MUL	#RSPLNG+RNGSIZ+ENVLP,R1	; R1=ACCOUNT FOR RESPONSE RING
					; .. ENTRIES, RESPONSE RING PACKETS
					; .. AND PACKET ENVELOPE.
	ADD	R1,(SP)			; ADD IN RESPONSE RING AREA REQUIRED
	MOV	R1,-(SP)
	MOVB	CM.FLG(R4),R1		; Get the number of units
	BIC	#^C<CF.UNT>,R1		; but just the units
	MUL	#UCBSIZ,R1		; and now the size of their UCBs.
	ADD	R1,2(SP)
	MOV	(SP)+,R1
	ADD	#CCBSIZ+RNGHED,(SP)	; ADD CCB SIZE + UCB'S + RING HEADR

	CMP	(SP)+,CM.WKA(R4)	; IS IT THE SAME AS THAT COMPUTED
					; .. BY INIT?
	BEQ	20$			; SAME OR LESS, ALL IS WELL.
	CRASH				; NO, SOMETHING IS VERY WRONG.  INIT
					; .. DID NOT ALLOCATE ENOUGH OF A WORK
					; .. AREA FOR THE DRIVER.  THIS COULD
					; .. PRODUCE SOME MISTERIOUS RESULTS
					; .. FOR AN ONLINE RSTS SYSTEM.

;+
; NOW, ASSIGN EACH UNIT A UCB WITHIN THE CONTROLLER WORK AREA
;-

20$:	MOVB	CM.FLG(R4),R0		; R0=NUMBER OF UNITS ON THIS CONTROLLER
	BIC	#^C<CF.UNT>,R0		; and no junk
	MOV	R0,C.NUNT(R5) 		; SAVE # OF UNITS IN CCB	;014
	MOV	R5,R1			; R1 -> CCB ADDR
	ADD	#CCBSIZ,R1		; POINT TO FIRST UCB FOR THIS
					; .. CONTROLLER
	MOV	#UMT$DU,R2		;ASSUME DISK CLASS		;008
	SUB	#CMT,R4			;GET CMT OFFSET			;011
	BITB	#CF.TAP,CMT+CM.FLG(R4)	;IS THIS A TAPE UNIT?		;004
	BEQ	50$			;NOPE, IT'S DISK		;008
	MOV	R3,-(SP)		;SAVE REGISTER			;011
	MOV	R4,-(SP)		;AND SAVE IT			;011
	MOVB	CMT+CM.DCT,R3		;GET # OF DISK CONTROLLERS	;011
	CLR	R2			;ASSUME CTLR ZERO		;011
	MUL	#CMTSIZ,R3		;GET 1ST TAPE OFFSET		;011
	SUB	R3,R4			;GET OFFSET FROM 1ST TAPE CMT	;011
	BEQ	30$			;UNIT ZERO			;011
	MOV	R4,R3			;COPY OFFSET			;011
	DIV	#CMTSIZ/2,R2		;GET CTLR # * 2			;011
30$:	MOV	(SP)+,R4		;RESTORE A REG			;011
	MOV	(SP)+,R3		;RESTORE A REG			;011
	MOV	R2,R0			;COPY UNIT NUMBER		;011
	MOV	DEV.MU(R2),R2		;PICK UP DDB POINTER		;011
	ADD	#<MUDDB+CMTMU>,R2	;AND GET UP TO DDB UMT ENTRIES	;011
	BMON	50$			;FOR INIT, COPY UMT ENTRY TO DDB;014
	MOV	R4,(R2)			;YES, SO COPY OUR CMT POINTER	;011	
	.ASSUME	UM.CMT	EQ	0
	MOV	#-1,UM.UCB(R2)		;FLAG AS ALIVE (in DDB)		;011
50$:	BIS	#1,(R2)			; ASSUME UNIT DOES NOT EXISTS
	.ASSUME	UM.CMT	EQ	0
	TST	UM.UCB(R2)		; UNIT EXISTS?
	BEQ	90$			; NO
	BIC	#1,(R2)			; CLEAR UNASSIGNED BIT
	.ASSUME	UM.CMT	EQ	0
	CMP	R4,(R2)			; IS THIS UNIT ON THIS CONTROLLER?
	.ASSUME	UM.CMT	EQ	0
	BNE	90$			; NO
	BITB	#CF.TAP,CMT+CM.FLG(R4)	;IS THIS A TAPE UNIT?		;011
	BNE	60$			;YES				;011
	TST	R0			; CAN WE HANDLE ANOTHER UNIT?
	BNE	70$			; YES				;011
	CRASH				; NO, CRASH!!!!!!!!!!!!!!

60$:	MOV	R2,C.UMT(R5)		;C.UMT-> UNIT'S UMT ENTRY	;011
	ASR	R0			;UNIT NUMBER TIMES 1		;011
	MOV	R0,U.UNIT(R1)		;SAVE UNIT # IN UCB		;011
	BMON	80$			;No UMT to do if Monitor	;014
	ASL	R0			;MAKE IT UNIT # * 2		;011
	ASL	R0			;MAKE IT UNIT # * 4		;011
	ADD	#UMT$MU+2,R0		;GET UP TO UMT UCB ENTRY	;011
	MOV	R1,(R0)			;SAVE UCB ADDRESS FOR INIT	;011
	BR	80$			;JOIN COMMON CODE		;008

70$:	MOV	R2,-(SP)		; COMPUTE UNIT # AT (SP)	;011
	SUB	#UMT$DU,(SP)		; (SP)=UNIT # TIMES 4
	ASR	(SP)			; (SP)=UNIT # TIMES 2
	ASR	(SP)			; (SP)=UNIT # TIMES 1
	MOV	(SP)+,U.UNIT(R1)	; SAVE UNIT NUMBER IN UCB	;010
80$:	MOV	R1,UM.UCB(R2)		; SAVE UCB POINTER IN UMT	;010
	BIS	#US.AVL,U.STAT(R1)	; MARK UNIT AS AVAILABLE
	DEC	R0			; COUNT # OF UNITS ASSIGNED TO
					; .. CONTROLLER
	ADD	#UCBSIZ,R1	   	; POINT TO NEXT UCB
90$:	BITB	#CF.TAP,CMT+CM.FLG(R4)	;IS THIS A TAPE UNIT?		;010
	BNE	110$			;YES, WELL, WE'RE DONE		;014
	ADD	#UMTSIZ,R2		; POINT TO NEXT UMT ENTRY	;010
	CMP	R2,#UME$DU		;-DISK,  END OF UMT TABLE?	;008
	BLO	50$			; NO, GO LOOK FOR NEXT UNIT
100$:	DEC	R0			; ALL UCB'S TAKEN
	BLT	120$			; YES, DONE
	MOV	#NOUNIT,U.UNIT(R1)	; WE DON'T HAVE A UNIT ASSIGNED TO
					; .. THIS UCB. SO, MARK IT AS HAVING
					; .. NO UNIT
	BIS	#US.AVL,U.STAT(R1)	; ALSO, MARK UNIT AS AVAILABLE
	ADD	#UCBSIZ,R1		; POINT TO NEXT UCB
	BR	100$			; CHECK NEXT UCB

110$:	MOVB	C.NUNT(R5),R0 		; Get # units from CCB		;014
	DEC	R0			; but we have 1 tape there	;014
	BGT	100$			; so clear out the rest		;014
120$:	RETURN				; RETURN TO CALLER

.WEAK	DEV.MU,UMT$MU			;Don't worry if no TMSCP monitor support ;008

.DSABL	LSB


;+
; THIS SUBROUTINE CONVERTS COMMAND/RESPONSE LENGTHS EXPRESSED
; AS POWERS OF 2 TO AN INTEGER VALUE.
;
; INPUT:	R1=NUMBER EXPRESSED IN POWERS OF 2
;
; OUTPUT:	R1=INTEGER
;-

CONVRT:	MOV	R1,-(SP)		; R1=0?
	BEQ	20$			; YES
	MOV	#2,R1			; START WITH 2 TO THE FIRST POWER
10$:	DEC	(SP)			; DEC POWER COUNT
	BEQ	30$			; DONE
	ASL	R1			; GENERATE NUMBER
	BR	10$			;
20$:	MOV	#1,R1			; 2 TO THE 0 = 1
30$:	TST	(SP)+			; CLEAN STACK
	RETURN				;

GLOBAL	<CMT,IE>

.WEAK	UME$DU,UMT$DU			; IF NO MSCP...			;011

.SBTTL	MAPBUS - CONVERT XBU ADDR TO 18 BIT UNIBUS ADDR

;+
; MAPBUS
;
; THIS ROUTINE CONVERTS A VIRTUAL ADDRESS TO AN 18 BIT UNIBUS ADDRESS.
;
; THE FORMULA IS:
;
; UNIBUS OFFSET	= VALUE AT "CMT+CM.UOF"
; PHYSICAL ADDR = <<APR6 VALUE>*100> + <VIRTUAL ADDR>&17700
; MMU OFFSET	= <VIRTUAL ADDR>&77
;
; UNIBUS ADDR	= <<<<PHYSICAL ADDR>/100> + <UNIBUS OFFSET>>*100>&<MMU OFFSET>
;
; *** NOTE ***
; THIS ROUTINE IS ONLY VALID FOR ADDRESSES WITHIN THE MSCP REGION.
; ALSO, THIS ROUTINE ASSUMES APR6 IS THE BASE REGISTER.
;
; INPUT:	R1=VIRTUAL ADDRESS
;		APR6 MAPPING IS ASSUMED
;
; OUTPUT:	R1=LOW WORD OF UNIBUS ADDRESS
;		R0=HIGH WORD OF UNIBUS ADDRESS
;
; R0, R1 CHANGED
;-

MAPBUS::MOV	R1,-(SP)		; (SP)=VIRTUAL ADDRESS
	BIC	#160000,(SP)		; (SP)=APR BITS CLEARED
	MOV	@DPAR6,R1		; R1=APR6
	CLR	R0			; CLEAR HIGH ORDER REGISTER
	ASHC	#6,R0			; GET MMU*100
	ADD	(SP),R1			; COMPUTE PHYSICAL ADDRESS
	ADC	R0			;
	ASHC	#-6,R0			; CONVERT MMU TO PHYSICAL ADDRESS
;+
; AT THIS POINT WE HAVE THE <IN R0, R1> MMU IN WHICH OUR BUFFER STARTS.
; NOW, WE MUST ADD THE MSCP REGION BIAS AND THE OFFSET WITHIN THE STARTING MMU.
; -
	ADD	CMT+CM.UOF,R1		; ADD IN MSCP REGION OFFSET
	CLR	R0			;

	ASHC	#6,R0			; CONVERT TO 18 BIT BUS ADDRESS
	BIC	#177700,(SP)		; (SP) MMU OFFSET
	BIS	(SP)+,R1		; OR IN OFFSET WITHIN STARTING MMU
	RETURN				; RETURN TO CALLER

GLOBAL	<DPAR6>

.SBTTL	INIUDA - INITIALIZE UDA VIRTUAL CIRCUIT

;+
;
; INIUDA
;
; THIS ROUTINE IS CALLED WHENEVER THE CLASS DRIVER DETERMINES THAT
; THE CONTROLLER REQUIRES SERVICE (CS.CRS)  AND  CONTROLLER INITIALIZATION
; REQUIRED  OR  CONTROLLER VIRTUAL CIRCUIT INITIALIZATION IS IN PROGRESS
; (CS.INV BIT OF C.STAT).
;
; INPUT:	R5 -> CCB
;
; OUTPUT:	CONTROLLER INITIALIZATION STARTED OR CONTINUED,
;		DEPENDING ON THE CONTROLLER STATUS BITS.
;
;		ON INIT INCOMPLETE, RETURN TO "RETURN"
;		ON INIT FAILS, RETURN TO "RETURN+2"
;		ON INIT SUCCESSFUL, RETURN TO "RETURN+4"
;
; ALL REGISTERS PRESERVED
;
;-

.ENABL	LSB

INIUDA:	REGSCR				; SAVE REGISTERS
	CLR	C.TIMR(R5)		; CLEAR TIMER
	BIT	#CS.TMO,(R5)		; LAST STEP TIMED OUT?
	.ASSUME	C.STAT	EQ	0
	BNE	RETRY1			; YES
	BIT	#CS.INV,(R5)		; VIRTUAL CIRCUIT INIT IN PROGRESS?
	.ASSUME	C.STAT	EQ	0
	BNE	10$		   	; YES

	MOV	C.CMT(R5),R2		; R2 = CMT OFFSET
	MOV	CMT+CM.CSR(R2),R2	; R2 -> CSR
	CLR	(R2)			; HARD INIT CONTROLLER
	.ASSUME	UDAIP	EQ	0
	MOV	#CS.INV,(R5)		; SAY, VIRTUAL CIRCUIT INIT IN PROG.
	.ASSUME	C.STAT	EQ	0
	MOV	#STEP1,C.INIT(R5)  	; START CONTROLLER AT STEP 1
	MOV	#C.ITBL,R1		; R1=INITIALIZE TABLE OFFSET
	ADD	R5,R1			; R1=POINTER TO C.ITBL
	MOV	R1,C.INIT+2(R5)		; SAVE POINTER TO INIT TABLE

	CALLX	INTSIM			; Save interrupt simulation info.  ;012
					; .. FOR INIT
	CALL	MAPFUN			; MAP TO FUNCTION IN INIT TABLE

	CALL	STEP			; STEP FUNTION SUCCESSFUL?
	BCS	RETRY			; NO, CHECK IF WE CAN RETRY
	BR	40$			; YES, WAIT FOR INTERRUPT

10$:	BIT	#STEP2,C.INIT(R5)	; STEP 2 NEXT?
	BEQ	20$			; NO
	CALL	MAPFUN			; MAP TO INITIALIZATION TABLE
	CMPB	-1(R1),UDASA(R2)	; RING LENGTH ECHOED SUCCESSFULLY?
	BNE	RETRY			; NO, TRY AGAIN
	CALL	STEP			; STEP FUNCTION SUCCESSFUL?
	BCS	RETRY			; NO, TRY AGAIN
	BR	40$			; YES, WAIT FOR INTERRUPT

20$:	BIT	#STEP3,C.INIT(R5)	; STEP 3 NEXT?
	BEQ	30$			; NO
	CALL	MAPFUN			; MAP TO INITIALIZATION TABLE
	CMPB	-4(R1),UDASA(R2)	; DID INTERRUPT VECTOR ECHO SUCCESS?
	BNE	RETRY			; NO, TRY AGAIN
	CALL	STEP			; STEP FUNCTION SUCCESSFUL?
	BCS	RETRY			; NO, TRY AGAIN
	BR	40$			; WAIT FOR INTERRUPT
;
; SET UP RING BUFFER POINTERS TO MSCP PACKETS.  THIS MUST BE DONE EACH TIME
; THE CONTROLLER IS INITIALIZED BECAUSE THE CONTROLLER ZEROS THIS AREA TO TEST
; THE ABILITY OF THE I/O BUS TO PERFORM NPR TRANSFERS.
;
30$:	CALL	SETRNG			; SET UP RING BUFFER POINTERS TO MSCP
					; PACKETS.
	CALL	MAPFUN			; MAP TO INITIALIZATION TABLE
	CALL	STEP			; STEP FUNTION SUCCESSFUL?
	BCS	RETRY			; NO, TRY AGAIN
	TST	(SP)+			; DO NOT RETURN TO "MAPFUN"
	ADD	#4,TOS.RA(SP)		; SUCCESSFUL, FORCE RETURN TO RETURN+4
	MOV	#CS.VCO,(R5)		; INDICATE VIRTUAL CIRCUIT OPEN
	.ASSUME	C.STAT	EQ	0
	BR	40$			; RETURN, VIRTUAL CIRCUIT IS OPEN

RETRY:	TST	(SP)+			; NOT RETURN TO "MAPFUN"
RETRY1:	ADD	#2,TOS.RA(SP)		; THAT'S IT. RETURN=RETURN+2
40$:	RETURN				; FAILED, RETURN TO RETURN+2

.DSABL	LSB

.SBTTL	MAPFUN - MAP TO NEXT STEP FUNCTION FOR UDA INIT

;+
; MAPFUN
; 
; THIS ROUTINE MAPS TO THE DRIVERS INITIALIZATION TABLE FOR
; THE NEXT STEP FUNTION.
;
; INPUTS:	R5 -> CCB
;
; OUTPUT:	R0=CURRENT STEP VALUE
;		R1=ADDR OF CURRENT STEP IN INITIALIZATION TABLE
;		R2=CSR ADDR
;
;-

MAPFUN:	MOV	C.INIT(R5),R0		; R0=CURRENT STEP VALUE
	MOV	C.INIT+2(R5),R1		; R1=CURRENT STEP WORD POINTER
	MOV	C.CMT(R5),R2		; R2=CMT ENTRY POINTER FOR CONTROLLER
	MOV	CMT+CM.CSR(R2),R2	; R2=CSR ADDRESS
	CALL	@(SP)+			; CALL CALLER BACK AS CO-ROUTINE
	MOV	R1,C.INIT+2(R5)		; SAVE NEXT STEP POINTER
	ASL	C.INIT(R5)		; MOVE TO NEXT STEP
	MOV	C.INIT(R5),CMT+CM.IMK	; SAVE NEXT STEP FOR INIT
	RETURN				; RETURN TO CALLER

.SBTTL	STEP   - DO NEXT STEP IN INITIALIZATION SEQUENCE

;+
; STEP
;
; THIS SUBROUTINE IS CALLED FROM THE INIUDA ROUTINE TO PERFORM THE
; NEXT STEP IN INITIALIZING OF THE UDA.
;
; INPUT:	R2=CSR
;		R1 -> NEXT STEP IN "C.ITBL"
;		R0=CURRENT STEP VALUE
;
; OUTPUT:	C BIT CLEAR IF UDA SA OK, NEXT INITIALIZATION WORD IS MOVED
;		  TO UDA SA REGISTER.
;		C BIT SET IF UDA SA ERROR BIT IS ON   OR  CORRECT STEP
;		  BIT IS NOT PRESENT IN SA REGISTER.
;
; R1 POINTING TO NEXT ENTRY IN "C.ITBL"
;-

STEP:	MOV	R3,-(SP)		; SAVE R3
	CLR	R3			; SET TIME OUT COUNT
10$:	TST	UDASA(R2)		; SA ERROR BIT ON?
	BMI	20$			; YES
	BIT	R0,UDASA(R2)		; CORRECT STEP BIT SET?
	BNE	40$			; YES
	SOB	R3,10$			; NO, LOOP
20$:	SEC				; WE FAILED
30$:	MOV	(SP)+,R3		; RESTORE R3
	RETURN				; RETURN TO CALLER

40$:	MOV	(R1)+,UDASA(R2)		; WRITE INITIALIZATION WORD TO UDA
	BIT	#STEP4,R0		; DID WE JUST DO STEP 4?
	BNE	50$			; YES
	MOV	#UDAITO,C.CTMO(R5)	; SET 10 SECOND TIMER
	CALLX	CLOCK			; SET TIMER
50$:	CLC				; SAY, GOOD RETURN
	BR	30$			; RETURN

.SBTTL	SETRNG - SET UP RING BUFFER POINTERS TO MSCP PACKETS

;+
; SETRNG
;
; THIS CODE SETS THE RING BUFFER POINTERS TO MSCP PAKCETS.  THE CONTROLLER
; ZEROES THE RINGS EACH TIME THE CONTROLLER IS INITIALIZED TO TEST THE
; ABILITY OF THE I/O BUS TO DO NPR TRANSFERS.  THEREFORE, THIS ROUTINE
; MUST BE EXECUTED AT STEP FOUR OF EACH INITIALIZE.
;
; INPUT:	R5 -> CCB
;
; OUTPUT:	RINGS BUFFER POINTERS ARE SET UP
;		CCB POINTERS ARE INITIALIZED
;
; ALL REGISTERS PRESERVED
;-

SETRNG:	REGSCR				; SAVE REGISTERS

;+
; INITIALIZE INTERNAL RING POINTERS IN CCB
;-

	MOVB	C.RSP(R5),R1		; R1=# OF ENTRIES IN RISPONSE RING
	MUL	#RNGSIZ,R1		; COMPUTE SIZE OF RESP.RING BUFFER
	MOV	R1,-(SP)		; SAVE SIZE OF RINGS
	SUB	#RNGSIZ,(SP)		; COMPUTE INDEX TO LAST ENTRY
	MOVB	C.NUNT(R5),R1		; Number of units on controller	;015
	MUL	#UCBSIZ,R1		;  and the size of their UCBs.
	ADD	R5,R1
	ADD	#CCBSIZ+RNGHED,R1	; R1=BASE ADDR OF RINGS
	TST	(R1)+			; POINT TO HIGH ORDER ENTRY OF RING
	MOV	R1,C.CRSP(R5)		; STORE IN CURRENT RESPONSE RING
					; BUFFER POINTER
	MOV	R1,C.FRSP(R5)		; AND IN FIRST RESPONSE RING BUFFER
					; POINTER
	ADD	(SP)+,R1		; LOCATE LAST MESSAGE RING BUFFER
	MOV	R1,C.LRSP(R5)		; AND STORE IN LAST RESPONSE RING
					; BUFFER POINTER
	ADD	#RNGSIZ,R1		; LOCATE COMMAND RING BUFFER
	MOV	R1,C.CCMD(R5)		; STORE IT IN CURRENT COMMAND RING
					; BUFFER POINTER
	MOV	R1,C.FCMD(R5)		; AND IN FIRST COMMAND RING BUFFER
					; POINTER
	MOVB	C.CMD(R5),R1		; GET NUMBER OF ENTRIES IN COMMAND
					; RING BUFFER
	MUL	#RNGSIZ,R1		; COMPUTE SIZE OF COMMAND RING BUFF
	SUB	#RNGSIZ,R1		; COMPENSATE FOR FIRST ENTRY
	ADD	C.FCMD(R5),R1		; LOCATE LAST COMMAND RING BUFFER
	MOV	R1,C.LCMD(R5)		; AND STORE IN LAST COMMAND RING
					; BUFFER POINTER

;+
; NOW, COMPUTE THE BASE ADDRESS OF THE PACKETS.  THE FORMULA IS:
;
; PAKETS BASE ADDR = CCBSIZ+<UCBSIZ*C.NUNT>+RNGHED+<RNGSIZ*RISP.RING.SIZE>+
;		     <RNGSIZ*CMD.RING.SIZE>
;				      :
; THE 4 IS FOR COMD/RESP INTERRUPT FLAG
;-

	MOVB	C.RSP(R5),R1		; R1=RESPONSE RING SIZE
	MOVB	C.CMD(R5),R0		; R0=COMMAND RING SIZE
	ADD	R0,R1			; R1=CMD + RESP RING SIZES
	MUL	#RNGSIZ,R1		; MULTIPLY BY "RNGSIZ"
	MOV	R1,-(SP)
	MOVB	C.NUNT(R5),R1		; number of units on controller	;015
	MUL	#UCBSIZ,R1		; size of UCBs for these units.
	ADD	(SP)+,R1
	ADD	#CCBSIZ+RNGHED,R1	; R1=OFFSET TO PACKETS BASE FROM CCB
	ADD	R5,R1			; R1=BASE ADDRESS OF PACKETS
	MOV	R1,C.CPKT(R5)		; SAVE BASE ADDR OF PACKETS IN CCB

;+
; NOW, SET UP RING POINTERS TO MSCP PACKETS
;-

	MOVB	C.RSP(R5),-(SP)		; GET # OF RESPONSE RINGS REQUIRED
	MOV	#RSPLNG-ENVLP,R4	; R4=LENGTH OF A RESPONSE PACKET
	MOV	C.CRSP(R5),R3		; R3 POINTS TO CURRENT RESP.RING BUFF
	CALL	ALOPKT			; ALLOCATE A PACKET
	MOV	R2,C.VCRP(R5)		; VIRTUAL ADDR OF CURRENT RISPONSE
					; .. RING ENTRY'S PACKET
	MOV	R2,C.VFRP(R5)		; VIRTUAL ADDR OF FIRST RESPONSE
					; .. RING ENTRY'S PACKET
	MOV	R2,C.VLRP(R5)		; PREPARE TO FIND LAST RESPONSE RING
					; .. ENTRY'S PACKET 
10$:	MOV	R2,R1			; R1=PACKET VIRTUAL ADDRESS
	CALL	MAPBUS			; CONVERT TO 18 BIT UNIBUS ADDRESS
	MOV	R0,(R3)			; SAVE HIGH ADDR IN RING ENTRY
	BIS	#OWN!FLAG,(R3)		; MARK UDA "OWN'ED" AND INTERRUPTABLE
	MOV	R1,-(R3)		; SAVE LOW ADDR IN RING ENTRY
	DECB	(SP)			; DECREMENT COUNT.  ARE WE DONE?
	BEQ	30$			; YES
	CALL	ALOPKT			; ALLOCATE ANOTHER PACKET
	BCC	20$			; IF CC, ALL'S WELL
	CRASH				; SOMETHING IS TERRIBLY WRONG
20$:	ADD	R4,C.VLRP(R5)		; LOCATE NEW LAST RESPONSE PACKET
	ADD	#ENVLP,C.VLRP(R5)	; ACCOUNT FOR ENVELOPE SIZE
	ADD	#RNGSIZ+2,R3		; POINT R3 TO 2ND WD OF NEXT RING ENTRY
	BR	10$			; DO THE NEXT PACKET

30$:	MOVB	C.CMD(R5),(SP)		; GET NUMBER OF COMMAND RINGS
	MOV	#CMDLNG-ENVLP,R4	; R4=LENGTH OF COMMAND PACKET
	MOV	C.CCMD(R5),R3		; GET CURRRENT COMMAND PACKET POINTER
	CALL	ALOPKT			; ALLOCATE A COMMAND PACKET
	MOV	R2,C.VCCP(R5)		; STORE PACKET POINTER IN CURRENT
					;   COMMAND RING BUFFER ENTRY
	MOV	R2,C.VFCP(R5)		; AND IN FIRST CMD RING BUFF POINTER
	MOV	R2,C.VLCP(R5)		; PREPARE TO FIND LAST COMMAND RING
					; BUFFER ENTRY'S PACKET
40$:	MOV	R2,R1			; R1=PACKET VIRTUAL ADDR
	CALL	MAPBUS			; CONVERT TO 18 BIT UNIBUS ADDR
	MOV	R0,(R3)			; INSERT HIGH ADDR
	MOV	R1,-(R3)		; INSERT LOW ADDR INTO RING ENTRY
	DECB	(SP)			; DECREMENT COUNT.  ARE WE DONE?
	BEQ	60$			; YES
	CALL	ALOPKT			; ALLOCATE ANOTHER PACKET
	BCC	50$			; IF CC, ALL'S WELL
	CRASH				; SOMETHING IS TERRIBLY WRONG
50$:	ADD	R4,C.VLCP(R5)		; LOCATE NEW LAST RESPONSE PACKET
	ADD	#ENVLP,C.VLCP(R5)	; ACCOUNT FOR ENVELOPE SIZE
	ADD	#RNGSIZ+2,R3		; POINT R3 TO 2ND WD OF NEXT RING ENTRY
	BR	40$			; DO THE NEXT PACKET

60$:	TST	(SP)+			; CLEAN UP THE STACK
	RETURN				; BACK TO CALLER


.SBTTL	ALOPKT - ALLOCATE AN MSCP PACKET

;+
; ALOPKT
;
; THIS ROUTINE IS CALLED TO ALLOCATE AN MSCP PACKET
;
; INPUT:	R5 -> CCB
;		R4=LENGTH OF PACKET TO BE ALLOCATED
;
; OUTPUT:	IF SUCCESS:
;		C  = 0
;		R2 = POINTER TO PACKET
;
;		IF FAILURE:
;		C  = 1  IF INSUFFICIENT CORE IS AVAILABLE
;			TO ALLOCATE THE PACKET.
;-

ALOPKT:	MOV	C.CPKT(R5),R2		; ALLOCATE THE PACKET
	ADD	R4,C.CPKT(R5)		; SET POINTER TO NEXT PACKET
	ADD	#ENVLP,C.CPKT(R5)	; ACCOUNT FOR ENVELOPE SIZE
	MOV	R4,(R2)+		; SET MSCP COMMAND/RESPONSE LENGTH
	CLR	(R2)+			; CLR VIRTUAL CIRCUIT IDENTIFIER
	RETURN				; RETUN TO CALLER

.SBTTL	GETCMP - GET COMMAND PACKET ROUTINE

;+
; GETCMP
;
; THIS ROUTINE CHECKS THE COMMAND RING BUFFER FOR THE FIRST
; AVAILABLE COMMAND PACKET.  IT WILL RETURN THE ADDRESS IF ONE
; IS FREE, OTHERWISE IT RETURNS CARRY SET IF NONE AVAILABLE.
;
; INPUTS:	R5 -> CCB
;		R1=VIRTUAL CIRCUIT AND CREDIT/DEBIT FIELD VALUE
;
; OUTPUTS:	IF SUCCESS:
;		C  = 0 IF COMMAND PACKET IS AVAILABLE
;		R1 = ADDRESS OF CURRENT COMMAND RING PACKET
;
;		IF FAILURE:
;		C  = 1 IF COMMAND PACKET IS NOT AVAILABLE
;
; R1 CHANGED
;-

GETCMP:	TST	@C.CCMD(R5)		; DOES UDA OWN THE CURRENT COMMAND RING
					; POINTER?
	SEC				; ASSUME FAILURE
	BMI	20$			; IF MI YES
	MOV	R0,-(SP)		; SAVE R0
	MOV	R1,-(SP)		; SAVE R1
	MOV	C.VCCP(R5),R1		; RETRIEVE CURRENT COMMAND PACKET PTR
	MOV	#P.LENG,E.LENG(R1)	; SET MESSAGE LENGTH IN ENVELOP
	MOV	(SP)+,E.CRDT(R1)	; SET VIRTUAL CIRCUIT AND CREDIT/DEBIT
	MOV	#P.LENG/2,R0		; R0=LENGTH OF AN MSCP COMMAND PACKET
10$:	CLR	(R1)+			; INITIALIZE MSCP PACKET
	SOB	R0,10$			; LOOP UNTIL DONE
	MOV	C.VCCP(R5),R1		; RESTORE PACKET POINTER
	MOV	(SP)+,R0		; RESTORE R0
	CLC				; SUCCESS RETURN
20$:	RETURN				; RETURN TO CALLER

.SBTTL	GETRSP - GET MESSAGE PACKET FROM CONTROLLER

;+
; GETRSP
;
; THIS ROUTINE WILL SCAN THE RESPONSE RING LOOKING FOR ANY
; RESPONSES RETURNED BY THE UDA50.
;
; INPUTS:	R5 -> CCB
;
; OUTPUTS:	IF SUCCESS:
;		C  = 0 IF RESPONSE PACKET AVAILABLE
;		R0 = MESSAGE TYPE FIELD
;		R1 = ADDRESS OF CURRENT RESPONSE RING PACKET
;		R2 = LOW WORD REF NUMBER FROM PACKET
;
;		IF FAILURE:
;		C  = 1 IF RESPONSE PACKET IS NOT AVAILABLE
;-

GETRSP:	BIT	#CS.VCO,(R5)		; VIRTUAL CIRCUIT OPEN?
	.ASSUME	C.STAT	EQ	0
	BEQ	60$			; NO
	TST	@C.CRSP(R5)		; DOES UDA OWN THIS ENTRY?
	BMI	60$			; IF MI YES
	MOV	C.VCRP(R5),R1		; GET CURRENT RESP.RING PACKET PTR
	MOV	P.CRF(R1),R2		; GET LOW WORD REF NUMBER FROM PACKET
	CLR	-(SP)			; GET A WORK REGISTER
	MOVB	E.CRDT(R1),(SP)		; OBTAIN MESSAGE CREDIT FIELDS
	BIC	#^C<CRDDBT>,(SP)	; CLR ALL BUT CREDIT/DEBIT FIELD
	ADD	(SP)+,C.CMDS(R5)	; INC CONTROLLER'S COMMAND LIMIT
	MOV	E.CRDT(R1),R0		; R0=MESSAGE CREDIT FIELD
	BIC	#^C<MSGTP>,R0		; CLR ALL BUT MESSAGE TYPE FIELD

;+
; R0 = CONTENTS OF MESSAGE TYPE FIELD
; R1 = ADDRESS OF CURRENT RISPONSE RING PACKET
; R2 = LOW ORDER REF NUMBER FROM THE RESPONSE PACKET
;-

	CMPB	#<MSGMNT*MSGMUL>,R0	; IS THIS RESPONSE FOR A MAINTENANCE
					; PACKET?
	BNE	20$			; NO
10$:	CALL	RELMPK			; IGNORE MAINTENANCE MESSAGES!
	BR	GETRSP			; TRY FOR ANOTHER

20$:	CMPB	#<MSGCRD*MSGMUL>,R0	; IS THIS RESP.A CREDIT NOTIF. PACKET?
	BEQ	10$			; YES (WAS PROCESSED ABOVE)
	CMPB	#<MSGDAT*MSGMUL>,R0	; IS THIS RESPONSE A DATAGRAM PACKET
	BNE	50$			; NO
	MOV	#DQS$DU,R0		; ASSUME DISK CLASS CONTROLLER	;011
	MOV	C.CMT(R5),R3		; R3 -> CMT TABLE ENTRY		;011
	TSTB	CMT+CM.FLG(R3)		; DISK CLASS CONTROLLER?	;011
.ASSUME	CF.DSK	EQ	200
	BMI	25$			; YES				;011
	MOV	R3,R0			; COPY CMT OFFSET		;011
	ADD	#CMT+CM.QUE,R0		; AND UP TO TAPE QUEUE ROOT	;011
25$:	MOV	CMT+CM.CSR(R3),R3	; GET CSR			;011
	MOV	R5,R4			; R4 -> CCB
	ADD	#C.OLDL,R4		; R4 -> OLD LIST QUEUE ROOT
30$:	MOV	(R4),R4			; GET NEXT ITEM IN QUEUE LIST
	BEQ	40$			; END OF LIST
	CMP	P.CRF(R1),R4		; IS PACKET FOR THIS DSQ?
	BNE	30$			; NO, KEEP LOOKING

40$:	CALL	LOGERR			; LOG THE ERROR
	BR	10$			; RELEASE PACKET AND LOOK FOR MORE

50$:	CMP	#<MSGSEQ*MSGMUL>,R0	; IS THIS RESP.A SEQUENTIAL PACKET?
	BNE	10$			; NO
	CLC				; YES, MESSAGE FOUND RETURN
	BR	70$			; GO VIA COMMON RETURN

60$:	SEC				; NO MESSAGES WERE FOUND
70$:	RETURN				; RETURN TO CALLER

.WEAK	DQE$DU,DQS$DU							;011

.SBTTL	RELMPK - RELEASE MESSAGE/RESPONSE PACKET

;+
; RELMPK
;
; THIS ROUTINE WILL CHECK THE RESPONSE RING FOR THE FIRST
; AVAILABLE RESPONSE PACKET.  IT WILL MARK IT "UDA OWN'ED".
;
; INPUTS:	R5 -> CCB
;
; OUTPUTS:	RESPONSE PACKET IS MARKED "UDA OWN'ED".
;
; R1 CHANGED
;-

RELMPK:	TST	@C.CRSP(R5)		; DOES UDA OWN THIS ENTRY?
	BPL	10$			; NO
	CRASH				; SOMETHING IS WRONG
10$:	MOV	C.VCRP(R5),R1		; R5=CURRENT RESPONSE PACKET POINTER
	MOV	#RSPLNG,E.LENG(R1)	; RESTORE RESPONSE PACKET LENGTH
	BIS	#OWN!FLAG,@C.CRSP(R5)	; MARK UDA "OWN" AND INTERRUPTABLE
	ADD	#RNGSIZ,C.CRSP(R5)	; POINT TO NEXT ENTRY IN RESPONSE RING
	ADD	#RSPLNG,C.VCRP(R5)	; POINT TO NEXT ENTRY'S PACKET
	CMP	C.LRSP(R5),C.CRSP(R5)	; RESET POINTER TO FIRST ONE
	BHIS	20$			; IF HIS NO
	MOV	C.FRSP(R5),C.CRSP(R5)	; RESET POINTER TO FIRST ONE
	MOV	C.VFRP(R5),C.VCRP(R5)	; AND IT'S PACKET

;+
; THE FOLLOWING LINE OF CODE IS ONLY MEANINGFUL WHEN IN INIT.  IT TELLS
; INIT WHERE THE CURRENT RESPONSE RING IS AT.  SO INIT CAN SIMULATE AN
; INTERRUPT.
;-

20$:	MOV	C.CRSP(R5),CMT+CM.IRG	; SAVE CURRENT RING POINTER
	RETURN				; RETURN TO CALLER

.SBTTL	XFRCMD - TRANSFER COMMAND TO CONTROLLER

;+
; XFRCMD
;
; THIS ROUTINE INITIATES THE I/O BY TRANSFERING THE COMMAND
; TO THE CONTROLLER.
;
; INPUTS:	R5 -> CCB
;
; OUTPUTS:	IF C = 0 THEN REQUESTED I/O IS INSERTED INTO COMMAND RING
;
;			 CURRENT COMMAND RING POINTER IS UPDATED TO
;			 POINT TO NEXT COMMAND RING ENTRY.
;
;		IF C = 1 THEN REQUESTED I/O IS NOT INSERTED INTO COMMAND RING
;-

XFRCMD:	MOV	R0,-(SP)		; SAVE R0
	MOV	@#PS,-(SP)		; SAVE CURRENT PRIORITY
	BIS	#1,(SP)			; ASSUME FAILURE
	SPLC	5			; DISABLE INTERRUPTS
	MOV	C.CMT(R5),R0		; R0 -> CMT OFFSET
	MOV	CMT+CM.CSR(R0),R0	; R0=CSR ADDR
	TST	UDASA(R0)		; IS UDA50 ONLINE?
	BMI	20$			;IF SIGN BIT SET - ERROR!	;008
	BIS	#OWN!FLAG,@C.CCMD(R5)	; SET RING TO UDA "OWN" AND
					; INTERRUPTABLE
	TST	(R0)			; FORCE A CONTROLLER POLL
	.ASSUME	UDAIP	EQ	0
	DEC	C.CMDS(R5)		; ACCOUNT FOR CURRENT PACKET
	ADD	#RNGSIZ,C.CCMD(R5)	; POINT TO NEXT ENTRY IN COMMAND RING
	ADD	#CMDLNG,C.VCCP(R5)	; POINT TO IT'S PACKET
	CMP	C.LCMD(R5),C.CCMD(R5)	; IS THIS THE LAST ONE
	BHIS	10$			; IF HIS, NO
	MOV	C.FCMD(R5),C.CCMD(R5)	; RESET POINTER TO FIRST ENTRY OF RING
	MOV	C.VFCP(R5),C.VCCP(R5)	; AND IT'S PACKET
10$:	BIC	#1,(SP)			; SHOW SUCCESS
20$:	MOV	(SP)+,@#PS		; RESTORE PRIORITY AT ENTRY
	MOV	(SP)+,R0		; RESTORE R0
	RETURN				; RETURN TO CALLER

.END
