        .INCLUDE /CMN:COMMON/
        .INCLUDE /CMN:KERNEL/
        .INCLUDE /DSK:MSCPDF/
TITLE	CPH,<COMMON PROTOCOL HANDLER MSCP/TMSCP>,0L,03-AUG-92,TPT/MND/DBM/VAM/KCG/FEK

;
;		COPYRIGHT (c) 1974, 1992 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR CPH
;+
;				[RSTS V9.1]
;  000	TPT  01-NOV-84	Creation of module CPH from MSCPPH, original code
;			by AJK/MND/JHC/FRL/DBM
;  001	TPT  29-Nov-84	Preliminary work for TMSCP
;  002	MND  27-Dec-84	Added code for the UMR wait queue, 
;			also modified for disk class split
;  003	MND  27-Jan-85	Removed PORT driver check
;  004	MND  08-Mar-85  Add dual-circuit changes to GTCPKT
;  005	MND  15-Apr-85  Fix GCS routine, initial credit count & others.
;  006	MND   8-May-85  More GCS/VALPKT fixes, Disk/Tape class split.
;  007	TPT   9-May-85  Merge TMSCP specific processing
;  008	DBM  05-Jun-85	Make UNTSOF know about TSQ's
;  009	TPT  08-Jun-85	Fix attention interrupt processing
;  010	TPT  15-Jun-85	Fix UNTSOF to return errors in TSQCEV for tape
;  011	TPT  25-Jun-85	Have ONLINE use tapes current density if applicable
;  012	TPT  13-Sep-85	Clear up MU multicontroller bugs
;  013	TPT  17-SEP-85	Fix GCS to only dec credit count once
;  014	TPT  22-Oct-85	Fix PROREQ UMR bug
;
;				[RSTS/E V9.2]
;  015	TPT  17-Dec-85	Fix TMSCP only problems, once and for all!
;			Code cleanup
;  016	TPT  20-Jan-86	Remove extra checks in timeout and clock routines
;  017  VAM  14-Mar-86	Add handling of US.OWL (Online Write Lock) in ONLINE.
;
;				[RSTS/E V9.3]
;  018  VAM  27-Jul-86	Move DUDSK into MCP phase, and MUDVR into BBR phase.
;			Fix autoload vector references for INIT.
;  019  VAM  12-Nov-86	Change US.VV references to US.VI instead.
;			Also, change reference to MUDEN (in DDB) to U.FORM
;			(in UCB) in ONLINE.
;
;				[RSTS/E V9.6]
;  020	KCG  17-Feb-88	Add FORMAT sequence support.
;
;				[RSTS/E V10.1]
;  021	FEK  10-Dec-90	Use L3QENT, optimizations, and unit redirection fix
;  022	FEK  17-Jun-91	Source clear V10.0 patch 1.1.1
;  023	FEK  16-Jul-91	Further redirect improvements
;  024	FEK  20-Aug-91	Prevent infinite retries
;  025	FEK  17-Oct-91	Allow Qbus with UMRs (non-DEC CPUs)
;  026	FEK  30-Dec-91	Don't setup for INIT in the monitor
;  027	FEK  24-Jul-92	Don't take units offline in INIT
;-


	DEFORG	CPH					;001


L$LIST=1	; LIST MSCP PREFIX FILE					

.SBTTL	********************************************
.SBTTL	*           DOCUMENTATION                  *
.SBTTL	********************************************
.SBTTL	CPH DESCRIPTION

;+
; Overview of Class Driver operation.
;
; NOTE - THE "PH" IN THE ???$PH LABELS STANDS FOR 
;	 PROTOCOL HANDLER.
;
; CON$IP:
;
; The driver continuation entry is a level 3 process.  Most of
; the MSCP protocol handling and port activity are being processed
; on level 3.
;
;	The continuation process scans the controller as follows:
;
;	1. If a controller is being initialized (virtual circuit), the
;	   port driver is called to continue the initialization process.
;
;	2. If oldest command sent to controller has timed out, sends
;	   command status to controller.  Controller is in verify command
;	   status state.
;
;	3. Otherwise, processes response ring entries -
;
;		      End messages processors
;	
;		      Attention messages processors
;
;
;	4. If a controller is marked for initialization -
;
;	   All units associated with the controller are marked as
;	   offline.  All state flags and pointers are re-initialized
;	   and controller initialization is initiated.
;
;	5. MSCP device request queue is scanned for outstanding requests to
;	   be initiated.
;
;	   If a unit is "Unit-Online", requests to it are initiated.
;	   If sent, the DSQ is marked as such to prevent sending it again.
;
;	   If unit NOT online, an attempt to bring the unit online is
;	   initiated.  The action started depends on the controller/unit
;	   state at the time.
;
;	   If a request cannot be started due to no available UMRs, the
;	   request is inserted into the UMR wait queue.
;
;
; UMR$PH
;
;	UMR freed up entry does the following:
;
;	1. The DSQ request queue is checked for items waiting
;	   for UMRs.  If none, no action is taken.
;
;	2. The DSQ is marked as nolonger waiting for UMRs
;
;	3. Request is queued into common MSCP driver queue for level
;	   3 processing and level 3 continuation is requested.
;
;	4. Return to UMR freed up notification.
;
; INT$??:
;
;	Interrupts are serviced by the port drivers as port
;	architecture may vary from port to port.
;
;	An interrupt from any controller does the following:
;
;	o  The controller is queued for service by the driver.
;
;	o  Requests level 3 continuation processing.
;
;	o  Exit from interrupt
;
;
; TMO$PH:
;
; The time out routine will monitor controller response integrity
; and command execution.  When requests are outstanding, a once a
; second time out decrements the controller timers.  If a controller
; timer goes to zero, level 3 processing is requested to investigate
; command status on the controller.
;
; The timer times out the oldest outstanding command sent to a
; given controller.  When the oldest outstanding command completes
; (i.e. - it's end packet is received) the timer is restarted for
; the next oldest outstanding command, if any.
;-



.SBTTL	REGISTER CONVENTIONS
;+
;
; THE FOLLOWING IS A SET OF REGISTER CONVENTIONS THIS CODE
; ATTEMPTS TO OBSERVE WHERE EVER IT IS POSSIBLE.
;
;
; R0 -> PORT DRIVER DISPATCH TABLE (PORT DRIVER AVAILABLE TABLE)
; R1 -> COMMAND/RESPONSE PACKET POINTER
; R2 -  AVAILABLE AS A WORK REGISTER
; R3 -  UCB ENTRY FOR UNIT
; R4 -> CMT TABLE ENTRY FOR CONTROLLER
; R5 -> CCB POINTER FOR CONTROLLER
;
;-


.SBTTL	********************************************
.SBTTL  *          MONITOR ENTRIES                 *
.SBTTL	********************************************
.SBTTL	CON$IP - MSCP/TMSCP LEVEL 3 CONTINUATION PROCESS
;+
; CON$IP
;
; THIS IS THE MAIN CLASS DRIVER CODE.  THIS CODE IS ENVOKED
; BY THE FOLLOWING EVENTS:
;
;	1. ARRIVAL OF A NEW REQUEST
;	2. INTERRUPT
;	3. CONTROLLER TIME OUT
;
; THE FUNCTIONS OF THIS CODE ARE DESCRIBED ABOVE UNDER SUB-TITLE
; "CPH DESCRIPTION".
;-

	.ENABL	LSB

	L3QENT	QPHCON,,MCPAP5						;021

CON$IP::				; Entry FOR L3Q 		;011
	MOV	#RTI3PH,-(SP)		; SET RETURN ADDRESS
10$:	MAP	PUSH,APR=6,DATA		; SAVE CURRENT APR MAPPING
	CALL	ALOCCB			; INIT DATA STRUCTURES (IF NEEDED);001
20$:	MOV	#CMT+CM.CRQ,R4		; R4 -> ROOT CONTROLLER SERVICE REQ-Q
	CALL	DEQALL			; DEQUE A REQUEST
	BNE	30$			; GOT ONE!
	MAP	POP,APR=6,DATA		; RESTORE MAPPING AT ENTRY
	RETURN				; NO MORE, THAT'S IT.

30$:	MAP	CM.AP6(R4),APR=6,DATA	; MAP TO CCB
	MOV	CM.COF(R4),R5		; R5 -> CCB
	MOV	C.PDVR(R5),R0		; R0 -> PORT DRIVER ENTRY DISPATCH TBL
	BIT	#CS.ONL!CS.SCC,(R5)	; CONTROLLER REQUIRES INITIALIZATION?
	.ASSUME	C.STAT	EQ	0
	BNE	60$			; NO, IT IS ONLINE
40$:	CALL	@PD.INI(R0)		; YES, INITIALIZE THE PORT
	BR	20$			; INIT STARTED RETURN
	BR	50$			; INIT FAILED, CONTROLLER IS DEAD
	CALL	SCC			; GO, SET CONTROLLER CHARACTERISTICS
	BCC	70$			; GO, CHECK IF SOMETHING IS IN THE
					; .. RESPONSE RING.
50$:	CLR	(R5)			; CONTROLLER MUST REINITIALIZE
	.ASSUME	C.STAT	EQ	0
	DEC	C.RTRY(R5)		; DEC RETRY COUNTER
	BGT	40$			; RETRY IF POSITIVE
	CALL	UNTSOF			; MARK CONTROLLER'S UNITS OFFLINE
	CLR	R1			; R1 =  NO END PACKET
	CLR	R4			; R4 -> NO DSQ
	MOV	#COFERR,MSCPER		; INDICATE UNABLE INITIALIZE CONTROLER
	CALL	LOG$PH			; Common MSCP/TMSCP ERROR LOGGING ;002
	BR	20$			; GO, SERVICE NEXT CONTROLLER

60$:	BIT	#CS.TMO,(R5)		; CONTROLLER TIMED OUT?
	.ASSUME	C.STAT	EQ	0
	BEQ	70$			; NO, CHECK RESPONSES
	CALL	GCS			; GO, GET COMMAND STATUS FOR THIS GUY
	BCS	50$			; REINIT CONTROLLER
70$:	CALL	PRORSP			; PROCESS ANY RESPONSES RECEIVED FOR
					; ..THIS CONTROLLER
	BIT	#CS.GCS!CS.SCC!CS.VFU,(R5)
	.ASSUME	C.STAT	EQ	0
					; IS "GET COMMAND STATUS"
					; .. OR "SET CONTROL. CHARACTERISTICS"
					; .. OR VERIFY CONTROLLER UNITS
					; .. IN PROGRESS?
	BNE	20$			; YES, WAIT FOR IT TO COMPLETE.
	TST	C.CMDS(R5)		; CONTROLLER COMMAND LIMIT EXHAUSTED?
	BLE	20$			; Yes, look at next controller.	;005
					; Note: If C.CMDS=0, then only	;005
					;	immediate commands are issued.
	BITB	#BBR.CP,CMT+CM.BRS	; IS BBR WAITING FOR COMMAND PACKETS?
	BEQ	80$			; NO
	CALLX	BBRDSQ			; Yes, get BBR's current DSQ.	;018
	MOV	DSQUMT(R2),R2		; R2 -> UMT
	MOV	(R2),-(SP)		; (SP) = CMT OFFSET
	.ASSUME	UM.CMT	EQ	0
	ADD	#CMT,(SP)		; (SP) -> CMT ENTRY FOR CONTROLLER
	CMP	(SP)+,R4		; BBR USING THIS CONTROLLER?
	BNE	80$			; NO	
	CALLMI	$RSMBR,BBRAP5		; Yes, so finish the replacement;018
					;   B4 using any more packets.	;006
80$:	CALL	PROREQ			; PROCESS ANY OUTSTANDING REQUESTS
					; ..FOR THIS CONTROLLER.
	BR	20$			; GO, CHECK NEXT CONTROLLER

.DSABL	LSB

GLOBAL	<IE,RTI3PH,CMT,MCPAP5>						;021

.WEAK	BBRDSQ				; Not in TMSCP-only systems.	;018


.SBTTL	UMR$PH - UMR FREED NOTIFICATION ENTRY
;+
; UMR$PH - THIS IS THE UMR FREED UP SERVICE ROUTINE.  
;
;	   This routine will dequeue each DSQ/TSQ queued to the 
;	   UMR stall queue (CM.QMR) and place the request back on
;	   the request queue for it's corresponding controller. The
;	   controller's CMT is then queued for service. The requests
;	   will be retried at level three by CON$IP.
;
; *** NOTE ***
;	CON$IP will give the oldest controller with an unissued I/O
;	request the first shot at obtaining any free UMR's for all of
;	it's requests.  This is because all I/O service is issued for
;	one controller at a time.
;
; REGISTERS PRESERVED
;-
UMR$PH::REGSCR				;; SAVE REGISTERS		;002
20$:	MOV	#CMT+CM.QMR,R4		;;-Get pointer to UMR wait Queue;002
	CALL	DEQALL			;;-Dequeue a UMR stalled request;002
	BEQ	40$			;;-No more, EXIT.		;002
	BICB	#R.UMRW,DSQSTS(R4)	;;-Remove DSQ from wait status	;002
	MOV	DSQUMT(R4),R3		;;-Get UMT pointer for request.	;002
	MOV	UM.UCB(R3),R1		;;-Now get the UCB pointer	;007
	MOV	(R3),R3			;;-Now get CMT offset for cntrlr;002
	.ASSUME	UM.CMT	EQ	0
	ADD	#CMT,R3			;;-R3 -> CMT of this request	;002
	MAP	PUSH,APR=6,DATA		;;-Save current APR6 mapping	;007
	MAP	CM.AP6(R3),APR=6,DATA	;;-Set map to the Unit's UCB	;007
	BIC	#US.UMR,U.STAT(R1)	;;-Clear UMR stalled state	;007
	MAP	POP,APR=6,DATA		;;-Restore previous mapping	;007
	MOV	R3,R0			;;-Get the CMT pointer in R0	;002
	ADD	#CM.QUE,R0		;;-Get the CMT's request Q root	;002
	CALL	JMPQUE			;;-Link to head of cntrlr's Que	;002
	MOV	R3,R4			;;-Get back CMT pointer		;002
	CALL	REQSER			;;Request service for controller;002
	BR	20$			;;-Get next stalled I/O request	;002

40$:	RETURN				;;RETURN TO UMR FREED NOTIFICATION

.SBTTL	TMO$PH - TIME OUT NOTIFICATION ENTRY
;+
; TMO$PH
;
; TIME OUT NOTIFICATION PROCESSING CODE
;	Each MSCP/TMSCP class controller has an individual time-out value 
;	retrieved from the SCC command and stored in the CCB. The common
;	timer, DSO$XX, is used to enter this routine once every second
;	and update the controller's timers.
;
; INPUT:	C.TIMR OF THE CCB
;
; OUTPUT:	C.TIMR OF EACH CCB IS DECREMENTED
;		IF GREATER THAN ZERO
;
; R1, R4, R5 CHANGED
;-
TMO$PH::REGSCR				; SAVE REGISTERS
	MAP	PUSH,APR=6,DATA		; SAVE CURRENT APR 6 MAPPING
	MOV	#CMT-CMTSIZ,R4		; R5 -> 1ST ENTRY -<CMT ENTRY SIZE>
	MOVB	CMT+CM.CCT,R1		; R1=NUMBER OF CONTROLLERS
	CLR	-(SP)			; CREATE WORK REGISTER
10$:	ADD	#CMTSIZ,R4		; POINT TO NEXT CMT
	MAP	CM.AP6(R4),APR=6,DATA	; MAP TO CCB
	MOV	CM.COF(R4),R5		; R5 -> CCB
	TST	C.TIMR(R5)		; IS TIMER SET?
	BEQ	20$			; NOT SET
	DEC	C.TIMR(R5)		; CONTROLLER TIMED OUT?
	BIS	C.TIMR(R5),(SP)		; SET FLAG FOR ACTIVE TIMERS
	TST	C.TIMR(R5)		; CURRENT CCB TIMED OUT?
	BGT	20$			; NOT YET
	BIS	#CS.TMO,(R5)		; INDICATE CONTROLLER HAS TIMED OUT
	.ASSUME	C.STAT	EQ	0
	CALL	REQSER			; YES, TIME UP!
20$:	SOB	R1,10$			; LOOK AT NEXT CONTROLLER
	TSTB	CMT+CM.DCT		; ANY MSCP CONTROLLERS PRESENT?	;015
	BNE	25$			; YES, SO JUST USE MSCP TIMER	;015
	MOV	#-1,TIM.MU		; ASSUME TIMER CONTINUATION	;021
	TST	(SP)+			; ANY TIMERS SET?		;015
	BNE	30$			; YES WE'RE ALL SET		;015
	CLR	TIM.MU			; NO, no ONCE A SECOND call	;021
	BR	30$			; AND LEAVE			;015

25$:	MOV	#-1*400,DSO$XX(R0)	; ASSUME TIMER CONTINUATION	;015
	TST	(SP)+			; ANY TIMERS SET?
	BNE	30$			; YES
	CLR	DSO$XX(R0)		; NO, DISABLE ONCE A SECOND TIME OUT
30$:	MAP	POP,APR=6,DATA		; RESTORE MAPPING AT ENTRY
	RETURN				; RETURN

GLOBAL	<CMT>

.WEAK	DSO$XX,TIM.MU							;015

.SBTTL	CLOCK  - ACTIVATE CLOCK ROUTINE
;+
; CLOCK
;
; This routine activates the class driver clock (DSS$DU) for MSCP or the
; tape class driver clock (TIM.MU) for TMSCP.   Once running, TMO$PH will 
; be entered once every second to decrement controller time-out values 
; (C.TIMR). C.CTMO is the time-out value for the controller's longest 
; command (usually ONLINE).
;
; INPUT:	R5 -> CCB	
;		C.TIMR
;
; OUTPUT:	ONCE A SECOND CLOCK STARTED IS "C.TIMR"
;		IS GREATER THAN ZERO.
;
; REGISTERS PRESERVED
;-
CLOCK::	TST	C.TIMR(R5)		; TIMER SET?
	BNE	10$			; YES, JUST RETURN
	MOV	C.CTMO(R5),C.TIMR(R5)	; SET CONTROLLER TIME OUT VALUE
	TSTB	CMT+CM.DCT		; ANY MSCP CONTROLLERS PRESENT?	;015
	BNE	5$			; YES, SO JUST USE MSCP TIMER	;015
	MOV	#-1,TIM.MU		; SET 1 SEC TMSCP TIMER		;021
	BR	10$			; AND LEAVE...			;015

5$:	MOV	#-1*400,DSS$DU		; SET 1 SEC MSCP TIMER		;021
10$:	RETURN				; RETURN TO CALLER	

GLOBAL	<CMT>

.WEAK	TIM.MU,DSS$DU			; IF NO MSCP DISKS		;015

.SBTTL	********************************************
.SBTTL	*       REQUEST PROCESSING ROUTINES        *
.SBTTL	********************************************

.SBTTL	PROREQ - PROCESS REQUESTS ROUTINE
;+
; PROREQ - THE FOLLOWING CODE DEQUEUES OUTSTANDING REQUESTS TO A
; 	   GIVEN CONTROLLER AND DISPATCHES THEM TO THEIR FUNCTION
; 	   PROCESSORS.
;
;	INPUT:	R0 -> DISPATCH TABLE
;		R5 -> CCB
;-
PROREQ:	MOV	C.CMT(R5),R4		; GET CMT OFFSET FROM CCB	;001
	ADD	#CMT+CM.QUE,R4		; R4 -> QUEUE ROOT		;001
10$:	TST	C.CMDS(R5)		; CONTROLLER COMMAND LIMIT EXHAUSTED?
	BLE	60$			; YES, WAIT FOR CONTROLLER.
	MOV	(R4),R4			; R4 -> DSQ OF NEXT REQUEST
	BEQ	60$			; THAT'S IT, NO MORE REQUESTS
	BITB	#R.UMRW,DSQSTS(R4)	; WAITING FOR UMRS?		;014
	BNE	10$			; YES, Check the others		;023
	MOV	DSQUMT(R4),R3		; R3 -> UMT ENTRY FOR UNIT
	CMP	(R3),C.CMT(R5)		; <<<IS THIS FOR CURRENT CONTROLLER?
	.ASSUME	UM.CMT	EQ	0
	BNE	35$			; NO, so do some retries	;023
	TST	UM.UCB(R3)		; HAS UNIT BEEN ASSIGNED?
	BNE	20$			; YES
	MOV	R3,R2			; R2 -> UMT ENTRY FOR DISK
	CALL	ASNUNT			; ASSIGN THE UNIT
	BCS	60$			; WAS NOT ASSIGNED, CONTROLLER UNITS
					; .. MUST BE VERIFIED BEFORE
					; .. ASSIGNMENT CAN BE COMPLETED.
					; .. SUSPEND ANY REQUEST PROCESSING 
					; .. FOR THIS CONTROLLER.
20$:	MOV	UM.UCB(R3),R3		; R3 -> UCB
	BIT	#U2.FMT,U.ST2(R3)	; FORMAT sequence in progress?	;020
	BNE	50$			; Yes, don't GUS or ONLINE unit	;020
	BIT	#US.VUS!US.AVL,U.STAT(R3) ; Need to do an online sequence?
	BEQ	30$			; Nope, so skip it.
	CALL	GUS			; TRY TO SEND "GET UNIT STATUS" CMD.
	BR	10$			; CHECK OUT NEXT REQUEST

30$:	BIT	#US.GUS!US.OLP,U.STAT(R3); GUS or ONLINE in progress for unit?
	BNE	10$			; YES
	BIT	#US.ONL,U.STAT(R3)	; IS UNIT ONLINE?
	BNE	40$			; YES
	BIT	#US.BOL,U.STAT(R3)	; NEED TO BRING UNIT ONLINE?
	BEQ	10$			; NO
	CALL	ONLINE			; YES, ISSUE ONLINE COMMAND
	BR	10$			; LOOK AT NEXT REQUEST

35$:	CRASH				; Someone has lost their mind


;+
;	DISPATCH TO THE CLASS DRIVER FOR DEVICE SPECIFIC PROCESSING
;
;	R3->UCB		R4->DSQ		R5->CCB
;-

40$:	TSTB	DSQCLU(R4)		;-IS THIS A TAPE REQUEST?	;001
	BPL	50$			;-NO, DISK...			;001
	CALLMI	$MUSRV,BBRAP5		;-Service the tape request	;018
	BR 	10$			;-AND LOOK AT NEXT		;001

50$:	CALLX	DUSERV			;-Service the disk request	;018
	BR 	10$			;-AND LOOK AT NEXT		;001

60$:	RETURN				; RETURN TO MAIN LOOP

.WEAK	DUSERV				; Not in TMSCP-only systems.	;018

.SBTTL	GUS    - GET UNIT STATUS SUBROUTINE
;+
; GUS
;
; SUBROUTINE TO REQUEST UNIT STATUS FROM THE CONTROLLER.
;
; INPUT:	R5 -> CCB
;		R4 -> DSQ or ZERO for disk unit verification
;		R3 -> UCB
;
; OUTPUT:	C - BIT CLEAR IS GUS WAS SENT TO CONTROLLER
;		C - BIT SET IF GUS COMMAND WAS NOT SENT TO THE
;		    CONTROLLER.
;
; R1 MODIFIED
;-
GUS::	TST	C.CMDS(R5)		; CAN WE SEND AN IMMEDIATE COMMAND?
	SEC				; Don't change 'N', but Set 'C'	;021
	BMI	10$			; NO
	MOV	#1,R1			; R1=Credit/Debit field		;006
	CALL	GTCPKT			; GET COMMAND PACKET FROM PORT DRIVER
	BCS	10$			; LOOP TILL WE GET A COMMAND PACKET
	MOV	R4,(R1)			; LOW ORDER CMD.REF.NUMBER = DSQ
	.ASSUME	P.CRF	EQ	0
	MOV	R3,P.CRF+2(R1)		; HIGH ORDER CMD.REF.NUMBER = UCB
	MOVB	(R3),P.UNIT(R1)		; SET UNIT NUMBER IN COMMAND PACKET
	.ASSUME	U.UNIT	EQ	0
	MOV	#0,P.MOD(R1)		; SET MODIFIERS
	MOVB	#OP.GUS,P.OPCD(R1)	; OP CODE = "GET UNIT STATUS"
	CALL	SENDCM			; TRANSFER COMMAND TO PORT
	BCS	10$			; TRANSFER FAILED, CONTROLLER MUST BE
					; .. OFFLINE!
	BIC	#US.VUS!US.AVL,U.STAT(R3); CLEAR VERIFY UNIT STATUS REQUIRED
					 ; .. AND AVAILABLE FLAG BITS
	BIS	#US.GUS,U.STAT(R3)	 ; INDICATE, GETTING UNIT STATUS.
10$:	RETURN				 ; RETURN TO CALLER

.SBTTL	ONLINE - BRING UNIT "ONLINE" ROUTINE
;+
; ONLINE
;
; SUBROUTINE TO BRING A GIVEN UNIT UNLINE TO THE CLASS DRIVER.
;
; INPUT:	R0 -> PORT DRIVER DISPATCH TABLE ADDRESS
;		R3 -> UCB
;		R4 -> DSQ
;		R5 -> CCB
;		
; OUTPUT:	"ONLINE" COMMAND IS SENT TO THE CONTROLLER
;		FOR UNIT.
;
; R1 CHANGED
;-
ONLINE::CALL	GTCPKT			; GET COMMAND PACKET <made glbl	;020
	BCC	10$			; WE HAVE GOT A COMMAN PACKET
	BIS	#US.BOL,U.STAT(R3)	; SET FLAG TO BRING UNIT ONLINE AT
					; .. SOME LATER TIME.
	BR	20$			; RETURN VIA COMMON RETURN

10$:	MOV	R4,(R1)			; P.CRF=DSQ
	.ASSUME	P.CRF	EQ	0
	MOV	R3,P.CRF+2(R1)		; P.CRF+2=UCB
	TSTB	DSQCLU(R4)		;IS THIS A TAPE ONLINE REQUEST?	;011
	BPL	15$			;NOPE, DISK			;011
	MOV	U.FORM(R3),P.FORM(R1)	;Bring online with current format;019
15$:	MOVB	(R3),P.UNIT(R1)		; SET UNIT NUMBER IN COMMAND PACKET ;011
	.ASSUME	U.UNIT	EQ	0
	MOV	#0,P.MOD(R1)		; Clear modifiers.		;017
	BIT	#US.OWL,U.STAT(R3)	; Bring it online Write Locked?	;017
	BEQ	17$			; Nope, leave it alone.		;017
	MOV	#MD.SWP,P.MOD(R1)	; Otherwise, set the modifier.	;017
17$:	BIT	#U2.FMT,U.ST2(R3)	; FORMAT sequence in progress?	;020
	BEQ	18$			; No, continue on		;020
	MOV	#MD.IMF,P.MOD(R1)	; Set Ignore Media Format Error	;020
18$:	MOVB	#OP.ONL,P.OPCD(R1)	; SET "ONLINE" OP CODE
	CALL	SENDCM			; SEND COMMAND TO CONTROLLER
	BCS	20$			; WAS NOT SENT
	BIS	#US.OLP,U.STAT(R3)	; SAY, ONLINE COMMAND IN PROGRESS
	BIC	#US.BOL!US.GUS,U.STAT(R3); CLEAR BRING UNIT ONLINE FLAG
20$:	RETURN				; RETURN TO CALLER

.SBTTL	SCC    - SET CONTROLLER CHARACTERISTICS
;+
; SCC
;
; THIS ROUTINE SETS CONTROLLER CHARACTERISTICS AFTER THE VIRTUAL
; CIRCUIT HAS BEEN ESABLISHED BETWEEN THE HOST AND THE CONTROLLER.
;
; INPUT:	R5 -> CCB
;		R0 -> PORT DRIVER DISPATCH TABLE
;
; OUTPUT:	CONTROLLER IS SET TO "CS.SCC" STATE
;		SCC COMMAND IS ASSEMBLED AND SENT TO THE CONTROLLER
;
; REGISTERS PRESERVED
;-
SCC:	REGSCR				; SAVE REGISTERS
	BIS	#CS.SCC,(R5)		; INDICATE SCC SUB-STATE
	.ASSUME	C.STAT	EQ	0
	MOV	#SCCTMO,C.TIMR(R5)	; SET TIMER
	MOV	#1,C.CMDS(R5)		; PRETEND WE HAVE ONE CREDIT SO WE
					; CAN GET A COMMAND PACKET
	CALL	GTCPKT			;-Get a command packet 		;004
	BCS	20$			; DON'T GIVE UP, TRY AGAIN
	CLR	C.CMDS(R5)		; Initialize credit count to zero ;005
					; Note: XFRCMD will make it a -1  ;005
					; -1 means port limit has elapsed ;005
					;  0 means immediate commands only;005
	MOV	R5,(R1)			; COMMAND REFERENCE NUMBER LOW = CCB
	.ASSUME	P.CRF	EQ	0
	MOV	R5,P.CRF+2(R1)		; COMMAND REFERENCE NUMBER HIGH = CCB
	MOVB	#OP.SCC,P.OPCD(R1)	; SET SCC OP CODE IN PACKET
	BINIT	10$			; IF INIT, SKIP OVER		;015
	MOV	#CF.ATN!CF.MSC!CF.THS,P.CNTF(R1) ; SET HOST FLAGS
					; ..ALLOW ATTENTION MESSAGES
					; ..MISCELLENEOUS ERROR LOGS
					; ..AND THIS HOSTS ERROR LOGS
10$:	MOV	#0,P.HTMO(R1)		; SET HOST TIMEOUT
					; ..ZERO KEEPS THE CONTROLLER FROM
					; ..TIMING THE HOST OUT
	CALL	SENDCM			; XFER REQUEST TO CONTROLLER
20$:	RETURN				; RETURN



.SBTTL	GCS    - GET COMMAND STATUS ROUTINE
;+
; GCS	-	SUBROUTINE TO SEND GET COMMAND STATUS FOR OLDEST
;  		OUTSTANDING REQUEST TO CONTROLLER.
;
; INPUT:	OLDEST OUTSTANDING COMMAND REFERENCE NUMBER (C.OTRF, C.OTRF+2)
;		R5 -> CCB	R0 -> PORT DRIVER DIPATCH TABLE
;
; OUTPUT:	"GET COMMAND STATUS" COMMAND IS SENT TO	CONTROLLER.
; 		R1, R2 MODIFIED
;-
GCS:	BIC	#CS.TMO,(R5)		; CLEAR TIME OUT INDICATOR
	.ASSUME	C.STAT	EQ	0
	BIT	#CS.ONL,(R5)		; IS CONTROLLER ONLINE?
	.ASSUME	C.STAT	EQ	0
	BEQ	10$			; No! SCC command timed out!	  ;005
					; Re-synchronize with controller. ;005
					; Note: Do not RESET controller   ;005
					; if virtual circuit is not open, ;005
					; (CS.VCO=0). RESET clears C.RTRY ;005
					; causing the driver to REINIT forever
	BIT	#CS.GCS!CS.VFU,(R5)	; Controller's online. Did a GCS
	.ASSUME	C.STAT	EQ	0
					; command time-out? Or did this
					; time-out occur during a controller
					; unit verification process?
	BEQ	20$			; NO
10$:	CALL	RESET			; RESET, CONTROLLER MUST BE RE-INITED
	SEC				; INDICATE GCS FAILED
	BR	30$			; RETURN

20$:	TST	C.OLDL(R5)		; Are there any outstanding commands?
	BNE	25$			; Yes, so send out a GCS command;006
	CLR	C.TIMR(R5)		; No, so stop this CCBs clock	;006
	;CLC				;-Clear C-bit			;006
	BR	30$			; RETURN			;006


;  Set up a GCS command for the oldest outstanding command		;006
;
; PRETEND WE HAVE ONE CREDIT.  WE HAVE TO DO THIS IN CASE THE CREDIT COUNT 
; IS DOWN TO 0; TO MAKE SURE WE WILL GET A COMMAND PACKET.  WHEN THE CREDIT
; COUNT IS 0, MEANS WE HAVE ONE COMMAND CREDIT LEFT.  THIS IS SO BECAUSE
; THE SCC ROUTINE INITIALIZES THE "C.CMDS" COUNT TO -1; THEREBY SUBTRACTING
; ONE FROM THE ACCUMULATED CREDITS.
					
25$:	MOV	C.CMDS(R5),-(SP)	; SAVE CURRENT CREDIT COUNT ON STACK
	MOV	#1,C.CMDS(R5)		; PRETEND CREDIT COUNT = 1.
	CALL	GTCPKT			; GET A COMMAND PACKET
	MOV	(SP)+,C.CMDS(R5)	; RESTORE 
	BCS	10$			; CONTROLLER MUST BE SICKO, JUST RESET
	MOV	R5,(R1)			; SET CMD REFERENCE NUMBER
	.ASSUME	P.CRF	EQ	0
	MOV	R5,P.CRF+2(R1)		; .. IN COMMAND PACKET
	MOV	#OP.GCS,P.OPCD(R1)	; STORE GCS OP-CODE IN COMMAND PACKET
	MOV	C.OLDL(R5),R2		;-R2 -> Oldest oustanding request;006
	MOV	R2,P.OTRF(R1)		;-DSQ/TSQ = the 1st word of the CRF
	MOV 	DSQUMT(R2),R2		;   we need to Get Status on	;006
	MOV	UM.UCB(R2),R2		;-UCB = the 2nd word of the CRF we
	MOV	R2,P.OTRF+2(R1)		;   need to Get the Status of. 	;006
	MOVB	(R2),P.UNIT(R1)		;-Set up the unit number also.	;006
	.ASSUME	U.UNIT	EQ	0
	CALL	SENDCM			; TRANSFER THE CMD TO THE CONTROLLER
	BCS	30$			; UNABLE TO SEND
	BIS	#CS.GCS,(R5)		; SAY, WE ARE GETTING COMMAND STATUS
	.ASSUME	C.STAT	EQ	0
30$:	RETURN				; RETURN TO CALLER


.SBTTL	********************************************
.SBTTL	*      RESPONSE PROCESSING ROUTINES        *
.SBTTL	********************************************
.SBTTL	PRORSP - PROCESS RESPONSES FROM CONTROLLER
;+
; PRORSP
;
; THIS ROUTINE CALLS THE PORT DRIVER TO RECEIVE RESPONSES FROM THE
; CONTROLLER.  RESPONSES RECEIVED ARE PROCESSED ACCORDING TO THEIR
; REQUIREMENTS.
;
; INPUT:	R5 -> CCB
;		R4 -> CMT
;
; OUTPUT:	RESPONSE IS PROCESSED
;
; ALL REGISTERS PRESERVED
;-
PRORSP:	REGSCR				; SAVE REGISTERS
10$:	MOV	C.PDVR(R5),R0		; R0 -> PORT DRIVER DISPATCH TABLE
	CALL	@PD.GRP(R0)		; GET A RESPONSE PACKET
	BCS	70$			; NO MORE RESPONSES
	CALL	VALPKT			; VALIDATE THE END PACKET
	BCS	60$			; NOT IN LIST, JUST IGNORE IT
	MOV	P.OPCD(R1),R3		; R3=OPCODE	
	BIC	#<177700>!OP.END!OP.AVA,R3 ; CLEAR TYPE FLAGS
	ASL	R3			; GENERATE COMMAND TABLE INDEX
.ASSUME OP.AVA EQ 100
	BIT	#OP.AVA,P.OPCD(R1)	; IS THIS AN ATTENTION MESSAGE?
	BEQ	50$			;-NO				;001
40$:	CMP	#TBLEND-CTLEND,R3	; VALID END PACKET?		;001
	BLOS	60$			; NO, IGNORE IT
	CALL	@CTLEND(R3)		;-PROCESS RESPONSE PACKET	;001
	BR	60$			;-AND CONTINUE...		;001

;+
; AT THIS POINT R0, R2 AND R3 ARE AVAILABLE AS WORK REGISTERS
;-
50$:	MOV	C.PDVR(R5),R0		; R0 -> PORT DRIVER DISPATCH TABLE
	TSTB	E.CRDT+1(R1)		;-Is this a TMSCP class packet?	;007
	BNE	55$			;-Yes, call Tape class driver	;007
	CMP	#PHTBLE-PH.TBL,R3	;-Is this a common response?	;008
	BLOS	56$			;-No, we must call class driver ;008
	CALL	@PH.TBL(R3)		;-Yes process it here		;008
	BR	60$			;				;008
	
56$:	CALLX	DONEDU			;-Process disk response packet.	;018
	BR	60$

55$:	CALLMI	$MURSP,BBRAP5		;-Process tape response packet	;018
60$:	MOV	C.PDVR(R5),R0		; R0 -> PORT DRIVER DISPATCH TABLE
	MOV	C.VCRP(R5),R1		; RESTORE RESPONSE PACKET POINTER
	CALL	@PD.RMP(R0)		; RELEASE RESPONSE PACKET
	BR	10$			; GET NEXT RESPONSE PACKET

70$:	RETURN				; RETURN TO MAIN LOOP

.WEAK	DONEDU				; Not in TMSCP-only systems.	;018


PH.TBL:	.WORD	CRASH			;-Should never get here		;008
	.WORD	CRASH			;-Abort (Not implemented)	;008
	.WORD	GCSEND			;-Get Command Status end packet	;008
	.WORD	GUSEND			;-Get Unit Status end packet	;008
	.WORD	SCCEND			;-Set Controller Char end packet;008
PHTBLE:

CTLEND:
	.WORD	AVLATN			; AVAILABLE ATTENTION MESSAGE
	.WORD	IGNORE			; DUPLICATE UNIT NUMBER ATTN.MESSAGE
	.WORD	IGNORE			; ACCESS PATH ATT. - IGNORE IT
TBLEND:					; END OF TABLE

;+
; CONTROLLER/DRIVER LOST IT'S MIND.  STOP THE SYSTEM BEFORE
; SOMETHING REALLY BAD HAPPENS!
;-
CRASH:	CRASH				; CRASH


;+
; END PACKETS IGNORED BY THIS DRIVER ARE PROCESSED HERE.
;-
IGNORE:	RETURN				; JUST CONTINUE


.SBTTL	GCSEND - GET COMMAND STATUS END PACKET PROCESSOR
;+
; GCSEND:	THIS SUBROUTINE PROCESSES "GET COMMAND STATUS END PACKETS"
;
; INPUT:	R5=CCB, R4=CMT, R1 -> RESPONSE PACKET
;
; OUTPUT:	R2 MODIFIED
; 		COMMAND STATUS IS VERIFIED.  IF COMMAND IS NOT MAKING ANY
;		PROGRESS, THE CONTROLLER IS MARKED FOR INITIALIZATION AND 
;		ALL REQUESTS FOR THIS CONTROLLER ARE RETURNED WITH DEVICE
;		HUNG ERROR CODE.
;-
GCSEND::MOV	P.CMST(R1),-(SP)	; If the command status is zero,
	BIS	P.CMST+2(R1),(SP)+	;   then the controller could not
	BEQ	40$			;     find the command.		;006
	TST	C.OLDL(R5)		; Anything outstanding?		;006
	BEQ	40$			; No. Command must have finished;006

; See if command reference field matches the oldest outstanding command

	CMP	P.OTRF(R1),C.OLDL(R5)	; Is THE DSQ in the end packet the
					;   same as the oldest DSQ issued?
	BNE	40$			; NOT SAME, IGNORE END PACKET.
					;   (THE COMMAND MUST HAVE COMPLETED).
	MOV	C.OLDL(R5),R0		; R0 -> DSQ ADDR
	MOV	DSQUMT(R0),R0		; R0 -> UMT
	CMP	P.OTRF+2(R1),UM.UCB(R0)	; Does the command reference match?
	BNE	40$			; NO, THE COMMAND MUST HAVE COMPLETED.

; Check command's progress

	CMP	C.CMST+2(R5),P.CMST+2(R1);CHECK IF COMMAND IS MAKING PROGRESS.
	BHI	10$			; YES, COMMAND STATUS IS DECREASING
	BLO	20$			; COMMAND STATUS INCREASED! REINIT!
	CMP	C.CMST(R5),P.CMST(R1)	; CHECK LOW ORDER WORD
	BLOS	20$			; NO PROGRESS, REINIT CONTROLLER
10$:	MOV	P.CMST(R1),C.CMST(R5)	; SAVE NEW COMMAND STATUS WORD
	MOV	P.CMST+2(R1),C.CMST+2(R5);.. IN CCB
	CALL	CLOCK			; START CLOCK IF NOT ALREADY RUNNING
	BR	40$			; EXIT VIA COMMON EXIT

20$:	CLR	R4			; R4 -> NO DSQ			;006
					; R1 -> END PACKET and R5 -> CCB;006
	MOV	#CTOERR,MSCPER		; INDICATE COMMAND TIME OUT ERROR
	MOV	C.PDVR(R5),R2		;ENSURE WE HAVE PORT DRIVER DISP. TABLE ;012
	CALL	LOG$PH			; USE Common MSCP/TMSCP ERROR LOGGING
	CALL	UNTSOF			; MARK CONTROLLER'S UNITS OFFLINE
	CALL	@PD.INI(R2)		; INITIALIZE THE PORT
	BR	40$			; INIT STARTED RETURN
	BR	40$			; INIT FAILED, CONTROLLER IS DEAD
40$:	BIC	#CS.GCS,(R5)		; CLEAR GCS IN PROGRESS FLAG
	.ASSUME	C.STAT	EQ	0
	RETURN				; RETURN TO CALLER

.SBTTL	GUSEND - GET UNIT STATUS END PACKET PROCESSOR
;+
; GUSEND
;
; THIS ROUTINE PROCESSES THE "GET UNIT STATUS" END PACKET.
;
; INPUT:	R5 -> CCB, R4 -> CMT, R1 -> END PACKET
;		R1 -> GUS END PACKET
;		R0 -> CONTROLLER DISPATCH TABLE
;
; OUTPUT:	IF END PACKET STATUS "NOT" SUCCESSFUL, UNIT
;		IS MARKED AS OFFLINE AND REQUESTS TO IT
;		ARE RETURNED WITH DEVICE HUNG ERROR CODE.
;
;		IF END PACKET STATUS "IS" SUCCESSFUL, UNIT
;		INFORMATION RECEIVED IS SAVED IN THE CCB.
;		THE UNIT IS MARKED AS ONLINE.
;
;		IF "P.CRF" IS ZERO, MEANS CONTROLLER IS CHECKING
;		TO SEE IF IT HAS THE UNITS ASSIGNED TO IT'S
;		UCB'S.  THIS SEQUENCE IS STARTED BY AN AVAILABLE
;		ATTENTION MESSAGE FOR A UNIT WHICH PRIVIOUSLY HAS
;		BEEN UNKNOWN TO THE CONTROLLER AND THE CONTROLLER
;		HAS NO FREE UCB FOR IT.  SO, IT IS ASSUMED THAT
;		ONE OF THE OTHER UNITS HAS GONE AWAY AND A NEW UNIT
;		APPEARED IN IT'S PLACE.  THUS A UNIT VERIFICATION
;		IS INITIATED TO FIND THE UNIT THAT HAS GONE AWAY
;		AND FREE UP THE UCB THAT WAS ALLOCATED TO IT.
;
; R0 THROUGH R4 DESTROYED
;-
GUSEND::MOV	P.CRF+2(R1),R3		; R3 -> UCB
	BIC	#US.GUS,U.STAT(R3)	; CLEAR GUS FLAG BIT
	BIS	#US.ONL,U.STAT(R3)	; ASSUME UNIT ALREADY ONLINE
	MOV	P.STS(R1),R2		; GET STATUS/EVENT CODE
	BIC	#^C<ST.MSK>,R2		; CLR ALL BUT STATUS/EVENT CODE
	BEQ	60$			; UNIT ALREADY ONLINE.  MUST BE	;021
					; .. COMPLETING A VERIFY UNIT STATUS
					; .. SUB-STATE.
	BIC	#US.ONL!US.BOL,U.STAT(R3); UNIT NOT ONLINE TO HOST
	CMP	#ST.AVL,R2		; UNIT AVAILABLE
	BEQ	40$			; SAVE UNIT STATUS INFO
10$:	TSTB	E.CRDT+1(R1)		;-Tape class response?		;007
	BNE	15$			;-Yes, they can't go away	;023
	BINIT	15$			;  nor can anything in INIT	;027
	MOV	P.UNIT(R1),R2		; R2=Disk unit number
	ASL	R2			;-Get unit number *2		;007
	ASL	R2			;-Now get Unit # * 4		;007
	ADD	C.UMT(R5),R2		;-  and point to the disk's UMT ;007
	CLR	UM.UCB(R2)		; SAY, DISK NOT ASSIGNED
	MOV	U.RDCT(R3),R4		; IS DISK BEING REDIRECTED?	;021
	BNE	20$			; YES      R1 -> END PACKET
	MOV	#1,(R2)			; Disk not there then		;021
	.ASSUME	UM.CMT	EQ	0
15$:	MOV	(R1),R4			; R4 -> DSQ (OR ZERO)
	.ASSUME	P.CRF	EQ	0
					; R5 -> CCB
	MOV	#USFERR,MSCPER		; INDICATE FATAL GUS
	CALL	LOG$PH			; Common MSCP/TMSCP ERROR LOGGING
	MOV	P.CRF+2(R1),R3		; RESTORE UCB POINTER
	BINIT	30$			; INIT can't go offline		;027
	TSTB	E.CRDT+1(R1)		;-Tape class response?		;023
	BEQ	25$			; No, Disks must go away	;023
	BR	30$			; Yes, they can't go away

	; R2 -> UMT of this unit
	; R3 -> UCB previously used by this unit
	; R4 -> CMT OF CONTROLLER CLAIMING THIS UNIT
20$:	MOV	R4,(R2)			; SAVE CMT OFFSET OF NEW CONTROLLER
	.ASSUME	UM.CMT	EQ	0
					; ..CLAIMING UNIT IN UMT ENTRY OF UNIT
	SUB	#CMT,(R2)		; Make it the real CMT OFFSET
	.ASSUME	UM.CMT	EQ	0
	CLR	U.RDCT(R3)		; CLEAR REDIRECT INDICATOR
	CALL	REQSER			; QUEUE CONTROLLER FOR SERVICE
	MOV	#US.AVL,U.STAT(R3)	; INITIALIZE STATUS WORD IN UCB
25$:	MOV	#NOUNIT,(R3)		; INDICATE UCB AVAILABLE
	.ASSUME	U.UNIT	EQ	0
30$:	CALL	UNTOFL			; Take unit offline
	MOV	(R1),R4			; R4 -> DSQ
	.ASSUME	P.CRF	EQ	0
	BEQ	60$			; NO DSQ, CONTROLLER MUST BE
					; .. VERIFYING IT'S UNITS
	BR	50$			; EXIT VIA COMMON RETURN


40$:	BIS	#US.BOL,U.STAT(R3)	; SAY, BRING UNIT ONLINE
					; WE SET BRING UNIT ONLINE AS WE MAY
					; .. NOT HAVE A DSQ TO ISSUE AN ONLINE
					; .. COMMAND.
	CLR	U.RDCT(R3)		; MAKE SURE REDIRECT POINTER IS OFF
	MOV	R3,R0			; R0 -> UCB
	ADD	#U.MLUN,R0		; POINT TO UNIT STATUS SAVE AREA
	ADD	#P.MLUN,R1		; POINT TO UNIT CHARACTERISTIC
	MOV	#<USTSIZ>/2,R2		; R2=NUMBER OF WORDS TO COPY
	CALL	COPY			; COPY UNIT STATUS TO UCB SAVE AREA
	MOV	C.PDVR(R5),R0		; RESTORE R0
	MOV	C.VCRP(R5),R1		; RESTORE GUS END PACKET ADDR
	MOV	(R1),R4			; R4 -> DSQ
	.ASSUME	P.CRF	EQ	0
	BEQ	60$			; NO, MUST HAVE BEEN A GUS GENERATED
42$:	CMPB	#FMTFUN,DSQFUN(R4)	; FORMAT command?		;020
	BNE	45$			; No, continue			;020
	BIS	#U2.FMT,U.ST2(R3)	; Yes, set FORMAT sequence flag	;020
	BR	50$			; and let PROREQ take DSQ	;020

45$:	BIT	#US.BOL,U.STAT(R3)	; BRING UNIT ONLINE
	BEQ	50$			; NO, IT IS ALREADY ONLINE
					; .. BY THE AVAILABLE ATTENTION MSG.
	CALL	ONLINE			; NO, BRING IT ONLINE
50$:	RETURN				; RETURN TO CALLER

;+
; THE END PACKET HAD NO DSQ.  THEREFORE, WE KNOW THAT THE CONTROLLER
; IS DOING UNIT VERIFICATION.  SO, WE FIND THE NEXT UNIT FOR THIS
; CONTROLLER AND REQUEST UNIT STATUS FOR IT.
;-

60$:	BIT	#CS.VFU,(R5)		; VERIFYING CONTRL.UNITS?	;021
	.ASSUME	C.STAT	EQ	0
	BEQ	50$			; No, so don't verify them then	;021
	MOV	#UCBSIZ,R1		; R1=UCB SIZE
	MOVB	C.NUNT(R5),R2		; R2=NUMBER OF UNITS ON THIS
					; .. CONTROLLER
	MUL	R2,R1			; R1=SIZE OF UCB AREA
	ADD	#CCBSIZ,R1		; R1=CCB SIZE + UCB AREA SIZE
	ADD	R5,R1			; R1 -> END OF UCB AREA

70$:	ADD	#UCBSIZ,R3		; POINT R3 TO NEXT UCB
	CMP	R3,R1			; HAVE WE VERIFIED ALL OF THEM?
	BHIS	80$			; YES
	TST	(R3)			; IS THERE A UNIT HERE?
	.ASSUME	U.UNIT	EQ	0
	BMI	70$			; NO, NONE ASSIGNED

	CLR	R4			; SHOW NO DSQ
	CALL	GUS			; GET UNIT STATUS FOR NEXT UNIT
	BR	50$			; RETURN


;+
; ALL OF THE CONTROLLERS UNITS HAVE BEEN VERIFIED.  NOW WE MUST SCAN
; THE UMT TO SEE IF ANY UNIT IS WAITING FOR A UCB TO BE ASSIGNED TO IT.
; IF ONE FOUND, ASSIGN UCB TO IT.
;-

80$:	MOV	C.PDVR(R5),R1		; R1 -> PORT DRIVER DISPATCH TABLE
	MOV	PD.NUN(R1),R0		; R0 = NUMBER OF UNITS OF THIS TYPE
	MOV	C.UMT(R5),R2		; R2 -> UMT TABLE FOR THIS DISK TYPE

90$:	CMP	C.CMT(R5),(R2)		; IS THIS UNIT BELONGS TO THIS CTRLR?
	.ASSUME	UM.CMT	EQ	0
	BEQ	100$			; YES
95$:	ADD	#UMTSIZ,R2		; POINT TO NEXT UMT ENTRY
	SOB	R0,90$			; CHECK EVERY UNIT
	BIC	#CS.VFU,(R5)		; CLEAR UNIT VERIFICATION FLAG
	.ASSUME	C.STAT	EQ	0
	BR	50$			; RETURN

100$:	TST	UM.UCB(R2)		; HAS UNIT BEEN ASSIGNED?
	BNE	95$			; YES, CONTINUE WITH NEXT UNIT
	CALL	ASNUNT			; ASSIGN UNIT TO THIS CONTROLLER
	BCC	95$			; UNIT HAS BEEN ASSIGNED
	MOV	R2,R1			; R1 -> UMT ENTRY
	MOV	#1,(R1)			; UNIT DOES NOT EXISTS
	.ASSUME	UM.CMT	EQ	0
	CLR	UM.UCB(R1)		;
	SUB	#UMT$XX,R1		; R1 = FUN * 4
	ASR	R1			; R1 = FUN * 2
	BMON	110$			; RSTS, SO USE FUN		;015
	CLR	R1			; FUN IN INIT = 0		;015
110$:	MOV	#UC.MNT,UNTCNT(R1)	; SAY, UNIT IS INOPERATIVE	;021
	CLR	MID$XX(R1)		; and we don't know what it is	;021
	BR	95$			; CHECK NEXT UMT ENTRY

GLOBAL	<UNTCNT,MID$XX>							;021

.WEAK	UMT$XX								;015

.SBTTL	SCCEND - SCC END PACKET PROCESSOR
;+
; SCCEND
;
; SUBROUTINE TO PROCESS "SET CONTROLLER CHARACTERISTICS" END
; PACKET.
;
; INPUT:	R5 -> CCB
;		R1 -> RESPONSE PACKET
;		R0 -> CONTROLLER DISPATCH TABLE
;
; OUTPUT:	IF END PACKET INDICATES SUCCESS, CONTROLLER
;		IS MARKED AS BEING ONLINE.
;
;		CONTROLLERR CHARACTERISTICS ARE SAVED IN THE CCB
;
; R0, R2 CHANGED
;-
SCCEND::BIT	#ST.MSK,P.STS(R1)	; WAS IT A SUCCESS?
	BNE	10$			; NO
	MOV	#CS.VCO!CS.ONL,(R5)	; SET CONTROLLER ONLINE/VIRTUAL
	.ASSUME	C.STAT	EQ	0
					  ; .. CIRCUIT OPEN BITS
	MOV	R5,R0			; R0 -> CCB
	ADD	#C.VRSN,R0		; R0 -> CONTROLLER CHARACTERISTICS
					;       SAVE AREA WITHIN CCB
	ADD	#P.VRSN,R1		; R1 -> CONTROLLER CHARACTERISTICS
					;       WITHIN RESPONSE PACKET
	MOV	#CCSIZE/2,R2		; R2 = LENGTH OF COPY IN WORDS
	CALL	COPY			; COPY CONTR.CHARACTERISTICS TO CCB
	SUB	#CCSIZE+P.VRSN,R1	; RESTORE R1
	BR	30$			; EXIT VIA COMMON RETURN

10$:	CLR	R4			;-No DSQ
	CALL	LOG$PH			; Log the MSCP/TMSCP error	;002
	DEC	C.RTRY(R5)		; DEC RETRY COUNTER
	BGT	20$			; RETRY IF POSITIVE
	CALL	UNTSOF			; MARK CONTROLLER'S UNITS OFFLINE
20$:	CLR	(R5)			; SAY, REINIT CONTROLLER
	.ASSUME	C.STAT	EQ	0
	CALL	@PD.INI(R0)		; INITIALIZE THE PORT
	NOP				; INIT STARTED RETURN
	NOP				; INIT FAILED, CONTROLLER IS DEAD
30$:	RETURN				; RETURN TO CALLER



.SBTTL	AVLATN - AVAILABLE ATTENTION MESSAGE PROCESSOR
;+
; AVLATN
;
; UNIT AVAILABLE ATTENTION MESSAGE PROCESSOR.  THE FOLLOWING THREE
; DRIVER STATES MAY EXIST WHEN RECEIVING THIS MESSAGE:
;
; 1. THE UNIT DID NOT EXIST UP TO THE TIME OF RECEIVING THE ATTENTION
;    MESSAGE.  THE UNIT IS SIMPLY ASSIGNED TO THE CURRENT CONTROLLER.
;
; 2. THE UNIT HAS BEEN KNOWN TO THE DRIVER AND IT IS ASSIGNED TO THE
;    CURRENT CONTROLLER.  AN AVAILABLE ATTENTION MESSAGE MAY BE
;    SENT BY THE CONTROLLER EVEN THOUGH THE UNIT IS ONLINE.  SO,
;    WE set volume invalid and request unit status.
;
; 3. THE UNIT HAS BEEN KNOWN TO THE DRIVER.  BUT THE UNIT IS THOUGHT
;    TO LIVE ON ANOTHER CONTROLLER.  IF RSTS THINKS THE UNIT
;    IS MOUNTED, THE ATTENTION MESSAGE IS IGNORED.
;
;    OTHERWISE, THE CMT OFFSET OF THE CONTROLLER REPORTING UNIT AVAILABLE
;    IS SAVED IN THE REDIRECT POINTER OF THE UNIT'S UCB AND UNIT STATUS
;    IS REQUESTED FROM THE OWNING CONTROLLER TO SEE IF IT STILL OWNS THE
;    UNIT.  IF THE END UNIT STATUS ROUTINE FINDS THE UNIT IS OFFLINE TO
;    THE CONTROLLER CURRENTLY OWNING THE UNIT, THEN  THE CONTROLLER
;    HAVING GENERATED THE UNIT VERIFICATION REQUEST WILL BE REQUESTED
;    TO VERIFY IT'S OWN UNITS.  THUS, THE CONTROLLER HAVING RECEIVED
;    THE AVAILABLE ATTENTION MESSAGE WILL EVENTUALLY ASSIGN THE UNIT
;    TO ITSELF.
;
; INPUT:	R5 -> CCB
;		R1 -> RESPONSE PACKET
;
; R0 THROUGH R4 MODIFIED
;-
AVLATN:	MOV	P.UNIT(R1),R2		; R2 = UNIT NUMBER

	TSTB	E.CRDT+1(R1)		;-Tape class attention message?	;007
	BEQ	5$			;-No, disk class		;007
	MOV	C.UMT(R5),R2		;-PICK UP UMT ENTRY		;012
	BR	7$			;-Now join the common code	;007
	
5$:	MOV	C.PDVR(R5),R4		; R4 -> PORT DRIVER DISPATCH TABLE
	CMP	PD.NUN(R4),R2		; UNIT NUMBER EXCEEDS MAX?
	BLOS	10$			; YES, JUST IGNORE IT

	ASL	R2			; MULTIPLY
	ASL	R2			; ..BY 4
	ADD	C.UMT(R5),R2		; R2 -> UMT ENTRY FOR UNIT

	MOV	R2,R4			; R4 -> UMT ENTRY FOR UNIT
	SUB	#UMT$XX,R4		; R4=FIP UNIT NUMBER * 4
	ASR	R4			; R4=FIP UNIT NUMBER * 2

7$:	BIT	#1,(R2)			; HAS UNIT BEEN ASSIGNED TO A CONTROL?
	.ASSUME	UM.CMT	EQ	0
	BNE	15$			; NO, ASSIGN TO CURRENT CONTROLLER ;021

	CMP	(R2),C.CMT(R5)		; IS IT ASSIGNED TO THIS CONTROLLER?
	.ASSUME	UM.CMT	EQ	0
	BNE	30$			; NO

	MOV	UM.UCB(R2),R3		; YES, DOES IT HAVE A UCB?
	BEQ	20$			; NO, ASSIGN IT A UCB

	BIT	#US.GUS!US.OLP,U.STAT(R3); GUS or ONLINE in progress?	;009
	BNE	10$			;  Yes. wait for the response.	;006
	BIS	#US.VUS!US.VI,U.STAT(R3); Set Verify Unit Status and	;019
					;  Volume Invalid.		;019
10$:	RETURN				; RETURN TO CALLER

15$:	MOV	C.CMT(R5),(R2)		; Set controller incase we need	;021
	.ASSUME	UM.CMT	EQ	0	;  to verify units		;021
20$:	CALL	ASNUNT			; ASSIGN THE UNIT TO THIS CONTROLLER
	BCC	10$			; when it works, its easy	;021
	NOP				;  if not, then catch it after	;021
	BR	10$			;  the verify, but EXIT now

30$:	TSTB	E.CRDT+1(R1)		;-Tape class attention message?	;007
	BNE	35$			;-Yes, skip over disk stuff	;007
	TST	UNTCNT(R4)		; IS UNIT MOUNTED?
	BGE	10$			; YES, DO NOTHING.  SOMEBODY IS
					; .. PLAYING WITH THE UNIT PLUGS.
35$:	MAP	PUSH,APR=6,DATA		; SAVE CURRENT MAPPING

	MOV	(R2),R4			; R4 -> CMT OF WHERE UNIT IS THOUGHT
	.ASSUME	UM.CMT	EQ	0
	ADD	#CMT,R4			; ..... TO LIVE
	MOV	C.CMT(R5),-(SP)		; SAVE CURRENT CMT ON STACK
	ADD	#CMT,(SP)		;

	MAP	CM.AP6(R4),APR=6,DATA	; MAP TO CCB OF THAT CONTROLLER

	MOV	UM.UCB(R2),R3		; R3 -> CURRENT UCB OF UNIT
	MOV	(SP)+,U.RDCT(R3)	; SAVE CMT OF CURRENT CONTROLLER IN
					; .. REDIRECT WORD OF UNIT'S CURRENT
					; .. UCB
	BIS	#US.VUS,U.STAT(R3)	; SAY, VERIFY UNIT STATUS

	MAP	POP,APR=6,DATA		; RESTORE MAPPING TO CURRENT CCB
	BR	10$			; THAT'S IT



.SBTTL	ASNUNT - SUBROUTINE TO ASSIGN A UNIT TO CURRENT CONTROLLER
;+
; ASNUNT - SUBROUTINE TO ASSIGN A UNIT TO CURRENT CONTROLLER
; 
; INPUT:	R5 -> CCB,  R2 -> UMT
;
; OUTPUT:	IF UCB AVAILABLE, UNIT IS ASSIGNED.  OTHERWISE UCB's
;		OF CURRENT CCB ARE SCANNED TO FIND AN EMPTY UCB.
;
; REGISTERS PRESERVED
;-
ASNUNT:	REGSCR				; SAVE REGISTERS
	MOV	R5,R3			; R3 -> CCB
	ADD	#CCBSIZ,R3		; R3 -> 1ST UCB OF CONTROLLER
	MOVB	C.NUNT(R5),R0		; R0=# OF UNITS ON CONTROLLER
10$:	TST	(R3)			; UCB AVAILABLE?
	.ASSUME	U.UNIT	EQ	0
	BMI	20$			; YES
	ADD	#UCBSIZ,R3		; POINT TO NEXT UCB
	SOB	R0,10$			; FIND AVAILABLE UCB
	MOV	R5,R3			; R3 -> CCB
	ADD	#CCBSIZ,R3		; R3 -> 1ST UCB OF THIS CONTROLLER
	CLR	R4			; NO DSQ
	CALL	GUS			; START VERIFYING CONTROLLER'S UNITS
	BIS	#CS.VFU,(R5)		; SAY, WE ARE VERIFYING CONTRL.UNITS
	.ASSUME	C.STAT	EQ	0
	SEC				; INDICATE, NOT ASSIGNED
	BR	50$			; RETURN

20$:	MOV	C.CMT(R5),(R2)		; SET CMT POINTER IN UMT ENTRY
	.ASSUME	UM.CMT	EQ	0
	MOV	R3,UM.UCB(R2)		; SET UCB ADDRESS IN UMT ENTRY
	MOV	#US.AVL,U.STAT(R3)	; MAKE UNIT AVAILABLE
	MOV	(R2),R1			;-Get CMT offset		;007
	.ASSUME	UM.CMT	EQ	0
	ADD	#CMT,R1			;-up to it's CMT proper		;007
	BITB	#CF.TAP,CM.FLG(R1)	;-Tape class controller?	;007
	BEQ	25$			;-No, assume disk (for now)	;007
	MOVB	MUDUNI-CMTMU(R2),(R3)	;-Save this unit number in UCB	;007
	.ASSUME	U.UNIT	EQ	0
	BR	45$			;-  and we're done		;021

25$:	MOV	R2,R1			; R1 -> UMT
	SUB	#UMT$XX,R1		; R1 = FUN * 4
	ASR	R1			; R1 = FUN * 2
	BMON	30$			; RSTS, USE FUN			;015
	CLR	R1			; YES, FUN IN INIT = 0		;015
30$:	CMP	#UC.MNT!UC.LCK,UNTCNT(R1); DOES RSTS THINK UNIT EXISTS?
	BNE	40$			 ; YES
	MOV	#UC.MNT,UNTCNT(R1)	; MAKE RSTS AWARE OF UNIT'S EXISTANCE
40$:	SUB	C.UMT(R5),R2		; R2 = UNIT NUMBER * 4
	ASR	R2			; R2 = UNIT NUMBER * 2
	ASR	R2			; R2 = UNIT NUMBER * 1
	MOV	R2,(R3)			; SAVE UNIT NUMBER IN UCB
	.ASSUME	U.UNIT	EQ	0
45$:	CLC				; INDICATE UNIT ASSIGNED
50$:	RETURN				; RETURN TO CALLER

.SBTTL	********************************************
.SBTTL	*          COMMON SUBROUTINES              *
.SBTTL	********************************************

.SBTTL	UNTOFL - MARK UNIT OFFLINE & PURGE I/O REQUESTS TO IT
;+
; UNTOFL
;
; THIS ROUTINE MARKS A UNIT OFFLINE AND RETURNS I/O REQUESTS
; OUTSTANDING TO IT WITH DEVICE HUNG ERROR CODE.
;
; INPUT:	R5=CCB, 	R3 -> UCB OF UNIT
;
; OUTPUT:	UNIT IS MARKED AS OFFLINE
;		I/O OUTSTANDING FOR UNIT IS RETURNED WITH
;		..DEVICE HUNG ERROR CODE
;
; REGISTERS PRESERVED
;-
UNTOFF::				; Cross overlay global for INIT	;005
UNTOFL::REGSCR				;  SAVE REGISTERS
	MOV	@#PS,-(SP)		;; SAVE CURRENT PRIORITY
	SPLC	5			;; MASK OUT DISKS
	BIC	#^C<US.VI>,U.STAT(R3)	;; Save Volume Invalid status.	;019
	CLR	U.ST2(R3)		;; Unconditionally clear U.ST2	;020
	BIS	#US.AVL,U.STAT(R3)	;; MARK UNIT AS IF IT HAD BEEN MADE
					;; .. AVAILABLE VIA AN AVAILABLE CMD.
10$:	CALL	FNDDSQ			;; FIND DSQ
	BCS	50$			;; NOT FOUND
	BITB	#R.UMRA,DSQSTS(R4)	;; UMR ASSIGNED TO DSQ?
	BEQ	20$			;; NO
	CALL	@RELUMR			;; RELEASE UMR'S IF ANY
20$:	CMP	R4,C.OLDL(R5)		;; IS THIS THE OLDEST ITEM OUTSTANDING
	BNE	30$			;; NO
	CLR	C.TIMR(R5)		;; STOP TIMER
	TST	(R4)			;; IS THERE ANOTHER ENTRY IN THE LIST?
	BEQ	30$			;; NO
	CALL	CLOCK			;; RESTART TIMER
30$:					;; R0=REQUEST or OLDEST QUEUE ROOT
					;;   returned by FNDDSQ		;006
	CALL	DEQUER			;; DEQUEUE THE REQUEST, IF THERE!
	TSTB	DSQCLU(R4)		;; TSQ or DSQ?			;008
	BPL	40$			;; DSQ.  Call disk class driver	;008
	BISB	#R.SENT,DSQSTS(R4)	;;SAY SENT			;010
	MOVB	#MAGSEL,DSQFBM(R4)	;;GIVE A MAGSEL ERROR		;010
.ASSUME	DSQFBM EQ 7
	CALLMI	$QUMTD,BBRAP5		;; TSQ.  Call tape class driver	;018
	BR	10$			;; Check for others		;008

40$:	MOVB	#HNGDEV,DSQERR(R4)	;; SET DEV HUNG ERROR CODE IN DSQ
	CALLX	QUESYD			;; Queue for completion.	;018
	TSTB	CMT+CM.BRS		;; IS BBR ACTIVE
	BEQ	10$			;; NO
	CALLX	BBRDSQ			;; Get BBR's current DSQ.	;018
	CMP	R2,R4			;; BBR WORKING ON THIS ITEM
	BNE	10$			;; NO
	CLRB	CMT+CM.BRS		;; YES, BBR IS NO LONGER ACTIVE
	BR	10$			;; CHECK THE OTHERS

50$:	MOV	(SP)+,@#PS		;; RESTORE PRIORITY
	RETURN				; RETURN TO CALLER	

GLOBAL	<RELUMR,MAGSEL,HNGDEV>						;010


.SBTTL	UNTSOF - MARK CONTROLLERS UNITS OFFLINE SUBROUTINE
;+
; UNTSOF
;
; THIS ROUTINE MARKS THE UNITS ASSOCIATED WITH THE CCB IN R5
; OFFLINE.  REQUESTS OUTSTANDING FOR UNITS ARE RETURNED WITH
; DEVICE HUNG ERROR CODE.
;
; INPUT:	R5 -> CCB
;
; OUTPUT:	UNITS ARE MARKED AS OFFLINE
;		OUTSTANDING REQUESTS ARE RETURNED WITH
;		..DEVICE HUNG ERROR CODE.
;
; REGISTERS PRESERVED
;+
UNTSOF:	REGSCR				; SAVE REGISTES
	MOVB	C.NUNT(R5),R1		; R1=# UNITS PER CONTROLLER
	MOV	R5,R3			; R3 -> CCB
	ADD	#CCBSIZ,R3		; R3 -> FIRST UCB
10$:
	TST	(R3)			; UNIT MAPPED TO THIS UCB?
	.ASSUME	U.UNIT	EQ	0
	BMI	20$			; NO
	CALL	UNTOFL			; YES, MARK UNIT AS OFFLINE AND RETURN
					; .. I/O REQUEST TO IT WITH DEVICE
					; .. HUNG ERROR CODE
20$:	ADD	#UCBSIZ,R3		; POINT TO NEXT UNIT
	SOB	R1,10$			; DO IT FOR ALL UNITS OF THIS CONTRL.
	.BR	CCBINT			; NOW, INITIALIZE CCB DATA


.SBTTL	CCBINT - INITIALIZE CCB FOR CONTROLLER RE-INIT
;+
; CCBINT - INITIALIZE CCB FOR CONTROLLER RE-INIT
; CCBIN1 - 	without resetting the retry counter
;
; INPUT:	R5 -> CCB
;
; OUTPUT:	CCB DATA IS PREPARED FOR CONTROLLER RE-INITIALIZATION
;
; REGISTERS NOT DISTURBED
;-
CCBINT:	MOV	#RTRYCT,C.RTRY(R5)	; RESTART RETRY COUNT		;024
CCBIN1:	CLR	(R5)			; FORCE REINITIALIZATION	;024
	.ASSUME	C.STAT	EQ	0
	CLR	C.TIMR(R5)		; CLEAR TIMER
	CLR	C.CMDS(R5)		; CLEAR CMD CREDIT AVAILABLE
	MOV	#-1,C.CMST(R5)		; RESET OLDEST OUTSTANDING
	MOV	#-1,C.CMST+2(R5)	; .. COMMAND STATUS
	RETURN				; RETURN TO CALLER

.SBTTL	COPY   - ROUTINE TO COPY FROM HERE TO THERE
;+
; COPY
;
; SUBROUTINE TO COPY A BLOCK OF MEMORY FROM ONE PLACE
; TO ANOTHER.
;
; INPUT:	R0 -> DESTINATION BUFFER
;		R1 -> SOURCE BUFFER
;		R2 -> LENGTH OF COPY IN WORDS
;
; R0, R1 AND R2 MODIFIED.
;-
COPY:	MOV	(R1)+,(R0)+		; COPY
	SOB	R2,COPY			; LOOP TILL DONE
	RETURN				; BACK TO CALLER

.WEAK	QUESYD				; Not in TMSCP-only systems.	;018

.SBTTL	RESET  - RESET CONTROLLER WORK AREA
;+
; RESET
;
; THIS SUBROUTINE INITIALIZES CONTROLLER WORK AREA
; AND MARKS DSQ'S AS NOT SENT.  THIS ROUTINE IS CALLED
; WHEN THE CONTROLLER NEEDS TO BE RE-INITIALIZED AND
; THE REQUESTS TO IT RE-DONE.  The retry counter is NOT
; reset, therefore, continual failures will NOT retry
; forever and ever.
;
; INPUT:	R5 -> CCB
;
; OUTPUT:	CCB/UCB'S INITIALIZED
;			(except for the CCB retry counter)
;		DSQ FOR CONTROLLER MARKED NOT SENT
;
; REGISTERS PRESERVED
;-
RESET:	REGSCR				; SAVE REGISTES
	MOVB	C.NUNT(R5),R1		; R1=# UNITS PER CONTROLLER
	MOV	R5,R2			; R2 -> CCB
	ADD	#CCBSIZ,R2		; R2 -> FIRST UCB
10$:
	MOV	#US.AVL,U.STAT(R2)	; MARK UNIT AS IF IT HAD BEEN MADE
					; .. AVAILABEL VIA AN AVAILABLE CMD.
	ADD	#UCBSIZ,R2		; POINT TO NEXT UNIT
	SOB	R1,10$			; DO FOR ALL UNITS OF THIS CONTROLLER

	CALL	CCBIN1			; NOW, INITIALIZE CCB DATA	;024

	MOV	@#PS,-(SP)		; SAVE CURRENT PRIORITY
	SPLC	5			;; MASK OUT DISK ACTIVITY

	MOV	R5,R4			;; R4 -> CCB
	ADD	#C.OLDL,R4		;; R4 -> OLD LIST ROOT WORD
	MOV	R4,R2			;; SAVE OLD LIST ROOT WORD IN R2
20$:	MOV	(R4),R4			;; GET 1ST ITEM
	BEQ	30$			;; NOTHING IN OLD LIST
	MOV	R2,R0			;; R0 -> OLD LIST ROOT WORD
	CALL	DEQUER			;; REMOVE T/DSQ FROM OLD LIST	;001
	MOV	C.CMT(R5),R0		;;-GET CMT OFFSET		;001
	ADD	#CMT+CM.QUE,R0		;;-R0 -> CMT queue root.	;002
	CALL	QUEMCP			;; PUT REQUEST INTO REQUEST LIST
	BR	20$			;; GO, REMOVE NEXT DSQ FROM OLD LIST
30$:
	MOV	C.CMT(R5),R4		;;-GET CMT OFFSET		;001
	ADD	#CMT+CM.QUE,R4		;;-R4 -> CMT queue root.	;002
40$:	MOV	(R4),R4			;; R4 -> NEXT DSQ IN CMT's QUEUE;002
	BEQ	60$			;; END OF QUEUE LIST
	BITB	#R.UMRA,DSQSTS(R4)	;; UMR ASSIGNED TO DSQ?
	BEQ	50$			;; NO
	CALL	@RELUMR			;; RELEASE ANY UMR'S FOR THIS DSQ
50$:	CLRB	DSQSTS(R4)		;; CLEAR DSQ STATUS BYTE
	BR	40$			;; LOOP THROUGH LIST

60$:	TSTB	CMT+CM.BRS		;; IS BBR ACTIVE
	BEQ	70$			;; NO
	CALLX	BBRDSQ			;; Get BBR's current DSQ.	;018
	MOV	DSQUMT(R2),R2		;; GET UMT POINTER
	CMP	(R2),C.CMT(R5)		;; BBR WORKING ON THIS CONTROLLER?
	.ASSUME	UM.CMT	EQ	0
	BNE	70$			;; NO
	CLRB	CMT+CM.BRS		;; BBR IS NO LONGER ACTIVE
70$:
	MOV	(SP)+,@#PS		;; RESTORE PS
	RETURN				; RETURN TO CALLER


.SBTTL	FNDDSQ - FIND a TSQ or DSQ for a specified unit
;+
; FNDDSQ - FIND a T/DSQ in the controller's request Queue or Oldest
;          outstanding command queue for a given unit.
;
; INPUT:	R5 -> CCB	
;		R3 -> UCB
;
; OUTPUT:	C-BIT CLEAR IF FOUND AND 
;		R0 -> QUEUE ROOT
;		R4 -> TSQ or DSQ
;
;		C-BIT set if no requests were found for the unit.
;
;-
FNDDSQ:	MOV	R2,-(SP)		;; SAVE R2
	MOV	C.CMT(R5),R4		;; Get CMT's Request queue root	;002
	ADD	#CMT+CM.QUE,R4		;; R4 -> QUEUE ROOT		;002
	MOV	R4,R0			;; Return QUEUE ROOT in R0	;006
	CALL	20$			;; Go look for one		;023
	BCC	10$			;; We got one!			;023
	MOV	R5,R4			;; R4 -> CCB
	ADD	#C.OLDL,R4		;; .. POINT TO OLD LIST Q ROOT
	MOV	R4,R0			;; Return QUEUE ROOT in R0	;006
	CALL	20$			;; Now, look here		;023
10$:	MOV	(SP)+,R2		;; RESTORE R2
	RETURN				;; RETURN TO CALLER

20$:	MOV	(R4),R4			;; GET NEXT ITEM IN LIST
	BEQ	40$			;; NOT FOUND
	MOV	DSQUMT(R4),R2		;; R2 -> UMT FOR THIS DSQ
	CMP	UM.UCB(R2),R3		;; IS DSQ FOR THIS UNIT?
	BEQ	30$			;; YES				;023
	CMP	(R2),#1			;; Or who knows where?		;023
	.ASSUME	UM.CMT	EQ	0
	BNE	20$			;; NO, we know where
30$:	TST	(PC)+			;; INDICATE DSQ FOUND (CLC)	;023
40$:	SEC				;; SAY, NOT FOUND
	RETURN				;; RETURN TO CALLER

.SBTTL	TWOSEC - ROUTINE TO TEST FOR 2 SEC ELAPSED TIME
;+
; TWOSEC
;
; THIS ROUTINE CHECKS TO SEE IF 2 SECONDS HAVE ELAPSED 
; USING THE TIME SAVED ON THE STACK AGAINST THE CURRENT
; TIME.
;
; INPUT:	(SP)  -> RETURN ADDRESS
;		2(SP) -> TIME TO TEST AGAINST
;
; OUTPUT:	C-BIT CLEAR IF 2 SECONDS HAVE NOT ELLAPSED.
;		C-BIT SET IF 2 SECONDS ELLAPSED.
;
; REGISTERS NOT CHANGED
;-
TWOSEC:	MOV	2(SP),-(SP)		; TEMP SAVE SECONDS TO TEST AGAINST
	CLR	-(SP)			; MAKE ROOM FOR CURRENT SECONDS
	MOVB	TIMSEC,(SP)		; PUT CURRENT SECONDS ON STACK
	SUB	(SP)+,(SP)		; COMPUTE # OF SECONDS ELLAPSED
	BGE	10$			; POS. IMPLIES WE ARE IN SAME MINUTE
					; .. WHEN TIME WAS SAVED.
	ADD	#60.,(SP)		; NEG. IMPLIES WE ARE IN MINUTE AFTER
					; .. TIME WAS SAVED.
10$:	CMP	(SP)+,#2		; 2 SECONDS ELLAPSED?
	BLOS	20$			; NOT YET
	SEC				; INDICATE 2 SECONDS ELLAPSED
	BR	30$			; TAKE COMMON EXIT
20$:	CLC				; 2 SECONDS NOT YET ELLAPSED
30$:	RETURN				; RETURN TO CALLER



.SBTTL	GTCPKT - GET COMMAND PACKET FROM PORT DRIVER
;+
; GTCPKT
;
; ROUTINE GETS COMMAND PACKET FROM PORT DRIVER
;
; INPUT:	R5 -> CCB
;
; OUTPUT:	C-BIT CLEAR IF COMMAND PACKET OBTAINED
;		R1 -> COMMAND PACKET
;
;		C-BIT SET IF FAILED TO GET COMMAND PACKET
;
; R0, R1 CHANGED
;-
	.ENABL	LSB
GETPAC::
GTCPKT::TST	C.CMDS(R5)		; ANY COMMAND PACKETS?
	BLE	15$			; NO
	CLR	-(SP)			; GET WORK REGISTER
	MOVB	TIMSEC,(SP)		; SAVE TIME AT ENTRY
	MOV	C.CMT(R5),R0		;-Get the CMT offset		;004	
	MOV	#<0*256.+1>,R1		;-Assume disk circuit 0, 1 debit;004
	BITB	#CF.TAP,CMT+CM.FLG(R0)	;-Is this a tape class circuit?	;005
	BEQ	10$			;-No, disk...			;004
	MOV	#<1*256.+1>,R1		; Circuit #1, + 1 packet debit	;005
10$:	MOV	C.PDVR(R5),R0		; R0 -> PORT DRIVER DISPATCH TABLE
	CALL	@PD.GCP(R0)		; GET COMMAND PACKET
	BCC	20$			; GOT IT
	BMON	12$			; easy if the monitor		;022
	MOV	R0,-(SP)		; Save R0 (GETCLK uses it)	;022
	CALLX	GETCLK			; but if INIT, update the clock	;022
	MOV	(SP)+,R0		; and get our R0 back again	;022
12$:	CALL	TWOSEC			; CHECK 2 SEC TIMER
	BCC	10$			; CHECK IT AGAIN
	REGSAV				; SAVE REGISTERS
	CLR	R1			; R1 =  NO PACKET
	CLR	R4			; R4 =  NO DSQ
					; R5 -> CCB
	MOV	#NOPERR,MSCPER		; INDICATE NO COMMAND PACKET ERROR
	CALL	LOG$PH			; Common MSCP/TMSCP ERROR LOGGING
	REGRES				; RESTORE THE REGISTERS
	TST	(SP)+			; CLEAN STACK
15$:	SEC				; INDICATE NO PACKETS AVAILABLE
	BR	30$			; RETURN
20$:	TST	(SP)+			; CLEAN STACK
	CLC				; GOOD RETURN
30$:	RETURN				; RETURN TO CALLER

.WEAK	GETCLK				; not in the monitor

.DSABL	LSB



.SBTTL	SENDCM - SEND COMMAND PACKET TO CONTROLLER
;+
; SENDCM
;
; SUBROUTINE TRANSFERS COMMAND PACKET TO CONTROLLER
;
; INPUT:	R5 -> CCB
;		R1 -> COMMAND PACKET
;
; OUTPUT:	C-BIT CLEAR IF COMMAND PACKET IS 
;		SUCCESFULLY TRANSFERED TO CONTROLLER
;
;		C-BIT SET IF TRANFER FAILED
;
; REGISTERS PRESERVED
;-
SENCMD::
SENDCM::BMON	5$			; No simulation in the monitor	;026
	CALL	INTSIM			; Save information for interrupt.  ;018
					; .. SIMULATION BY INIT
5$:	MOV	C.PDVR(R5),R0		; R0 -> PORT DRIVER DISPATCH TABLE
	CALL	@PD.XCM(R0)		; TRANSFER COMMAN TO CONTROLLER
	BCC	10$			; SUCCESS
	REGSAV				; SAVE THE REGISTERS
	CLR	R1			; R1 =  NO I/O PACKET
	MOV	C.PDVR(R5),R2		; R2 -> PORT DRIVER DISPATCH TABLE
	MOV	C.CMT(R5),R3		; R3 =  CMT OFFSET
	MOV	R3,R0			;	Copy CMT offset to R0
	ADD	#CMT+CM.QUE,R0		; R0 -> QUEUE ROOT
	MOV	CMT+CM.CSR(R3),R3	; R3 =  CSR
	CLR	R4			; R4 =  NO DSQ
	MOV	#SNDERR,MSCPER		; UNABLE TO SEND TO CONTROLLER
	CALL	@PD.ERL(R2)		; CALL LOGGER
	CALL	RESET			; RESET CONTROLLER STATUS
	MOV	C.CMT(R5),R4		; R4 -> CMT OFFSET
	ADD	#CMT,R4			; R4 -> CMT OF THIS CONTROLLER
	CALL	REQSER			; REQUEST SERVICE FOR CONTROLLER
	REGRES				; RESTORE REGISTERS
	SEC				; INDICATE FAILURE TO SEND COMMAND
	BR	40$			; RETURN TO CALLER
10$:
	TST	C.OLDL(R5)		; IS THIS THE 1ST ENTRY
	BNE	20$			; NO
	MOV	#-1,C.CMST(R5)		; YES. THIS WILL BE THE OLDEST COMMAND
	MOV	#-1,C.CMST+2(R5)	; .. OUTSTANDING.  SO, INIT IT'S
					; .. STATUS
20$:	
	TST	(R1)			; IS THIS A GUS VERIFY PROCESS?
	.ASSUME	P.CRF	EQ	0
	BEQ	30$			; YES
	
	CMP	(R1),R5			; IS THIS SCC -OR- GCS?
	.ASSUME	P.CRF	EQ	0
	BEQ	30$			; YES, NO DSQ ASSOCIATED WITH CMD!

	MOV	R4,-(SP)		; SAVE R4
	MOV	R0,-(SP)		; SAVE R0

	MOV	(R1),R4			; R4 -> DSQ
	.ASSUME	P.CRF	EQ	0
	MOV	C.CMT(R5),R0		;-GET CMT OFFSET		;001
	ADD	#CMT+CM.QUE,R0		;-Get the CMT'S  request Q-ROOT	;002
	CALL	DEQUER			; REMOVE ITEM FROM REQUEST LIST

	MOV	R5,R0			; R0 = QUEUE ROOT
	ADD	#C.OLDL,R0		; .. FOR OLD LIST
	CALL	QUEMCP			; QUEUE DSQ INTO OLD LIST

	MOV	(SP)+,R0		; RESTORE R0
	MOV	(SP)+,R4		; RESTORE R4
30$:					;	
	CALL	CLOCK			; START CLOCK IF NOT RUNNING
	CLC				; INDICATE GOOD RETURN
40$:	RETURN				; RETURN TO CALLER

GLOBAL	<MSCPER>



.SBTTL	LOG$PH - Common MSCP/TMSCP Error Logging
;+
;	LOG$PH	Log an MSCP/TMSCP type error
;
;	INPUT:	R1 -> Message Packet (or zero if driver determined the error)
;		R4 -> DSQ (or zero if error is a controller error)
;		R5 -> CCB of controller with error
;
;  ALL REGISTERS PRESERVED
;-

LOG.PH::				; Cross overlay global for INIT	;005
LOG$PH::REGSCR				; Save the world
	TST	R1			; Driver determined error?	;002
	BEQ	10$			; Yes, No packet. No DSQ.	;002
	TST	R4			; Driver initiated GUS or GCS?	;002
	BEQ	10$			; Yes, No DSQ.			;002
	MOV	(R1),R4			; R4 -> DSQ (or ZERO)		;002
	.ASSUME	P.CRF	EQ	0
10$:	MOV	C.PDVR(R5),R2		; R2 -> PORT DISPATCH TABLE	;002
	MOV	C.CMT(R5),R3		; R3 =  OFFSET INTO CMT		;002
	MOV	R3,R0			; 	Copy CMT offset in R0	;002
	ADD	#CMT+CM.QUE,R0		; R0 -> QUEUE ROOT		;002	
	MOV	CMT+CM.CSR(R3),R3	; R3 =  CSR			;002
	CALL	@PD.ERL(R2)		; LOG ERROR			;002
	RETURN				;				;002

.SBTTL	INTSIM - SAVE INFORMATION FOR INIT FOR INTERRUPT SIMULATION
;+
; THE FOLLOWING LINES OF CODE HAVE MEANING ONLY IN INIT.  THESE LINES
; OF CODE SAVE INIT THE NECCESSARY INFORMATION FOR INIT TO BE ABLE TO
; SIMULATE AN INTERRUPT.
;
; INPUT:	R5 -> CCB    (APR6 is assumed to be mapped to the CCB)
;
; OUTPUT:	CM.ICS - CONTROLLER CSR
;		CM.IMK - INITIALIZE MASK WORD
;		CM.IRG - IF CONTROLLER ONLINE, VIRTUAL ADDR OF RESPONSE
;			 RING ENTRY.  OTHERWISE, MEANINGLESS.
;		CM.IC6 - IF CONTROLLER ONLINE, APR6 MAPPING TO CCB.
;			 OTHERWISE, -1.
;
; REGISTERS PRESERVED
;-
INTSIM::								;018
;.IF	EQ	IE			; Assemble only in INIT.SYS	;005
	MOV	R0,-(SP)		; SAVE R0
	MOV	C.CMT(R5),R0		; R0 -> CMT
	MOV	CMT+CM.CSR(R0),CMT+CM.ICS; SAVE CSR OF CURRENTLY ACTIVE
					; .. CONTROLLER FOR INIT
	MOV	#-1,CMT+CM.IC6		; ASSUME CONTROLLER OFFLINE
	BIT	#CS.VCO,(R5)		; VIRTUAL CIRCUIT OPEN?
	.ASSUME	C.STAT	EQ	0
	BEQ	20$			; NO
	MOV	C.CRSP(R5),CMT+CM.IRG	; SAVE RESPONSE RING ENTRY VIRT. ADDR
	MOV	@DPAR6,CMT+CM.IC6	; SAVE CCB APR6 FOR INIT
20$:	MOV	(SP)+,R0		; RESTORE R0
;.ENDC					; Should never get called anyway;005
	RETURN				; RETURN
.SBTTL	********************************************
.SBTTL	*            QUEUE HANDLERS                *
.SBTTL	********************************************

.SBTTL	QUEMCP - MSCP REQUEST SERVICE QUEUER ROUTINE
;+
; QUEMCP - Queue an item into one of the MCSP controller Queues.
;	   Request is queued with forward and backward pointers.
;
; INPUT:	R4 -> DSQ/TSQ
;		R0 -> Q ROOT
;
; OUTPUT:	REQUEST IN R4 IS QUEUED INTO MSCP Q AT R0.
;		REQUEST IS QUEUED WITH BACKWARS/FORWARDS CHAIN
;		POINTERS.
;
; REGISTERS PRESERVED
;-
QUETSQ::				; Cross overlay global for INIT	;005
QUEMCP::MOV	R0,-(SP)		; GET A WORKING REGISTERS
	CLR	(R4)			; ENSURE FORWARD LINK IS ZERO IN
					; .. THIS ITEM
	CLR	DSQBWP(R4)		; ENSURE BACKWARDS CHAIN POINTER
					; .. IS ZERO
	MOV	@#PS,-(SP)		; SAVE CURRENT PRIORITY
	SPLC	5			;;DISABLE DISK INTERRPUTS
	TST	(R0)			;;SET Z-BIT=1 IF QUEUE IS EMPTY
	BEQ	20$			;;QUEUE EMPTY, JUST ENTER 1ST ITEM.
10$:	MOV	(R0),R0			;;GET NEXT ITEM IN LIST
	TST	(R0)			;;IS THIS LAST ITEM OF LIST?
	BNE	10$			;;NOT THE END, CONTINUE LOOKING
	MOV	R0,DSQBWP(R4)		;;SAVE BACKWARD POINTER
	ADD	#DSQBWP,DSQBWP(R4)	;;POINT TO BACKWARD THREAD WORD
20$:	MOV	R4,(R0)			;;QUEUE THIS ITEM
	MOV	(SP)+,@#PS		;;RESTORE PROCESSOR PRIORITY
	MOV	(SP)+,R0		; RESTORE R0
	RETURN				; RETURN TO CALLER



.SBTTL	DEQUER - DEQUE AN ITEM FROM MSCP I/O REQUEST QUEUE
;+
; DEQUER
;
; ROUTINE TO DEQUE A DSQ FROM ONE OF THE MSCP QUEUES.
;
; INPUT:	R4 -> DSQ TO BE DEQUED
;		R0 -> Q ROOT OF QUEUE
;
; OUTPUT:	ITEM IS DEQUED. BACKWARD/FORWARD POINTERS
;		IN QUEUE LIST ARE UPDATED.
;
; REGISTERS PRESERVED
;-
DEQUE::					; Cross overlay global for INIT	;005
DEQUER::PUSH	<R0>			; GET A WORK REGISTER
	PUSH	<@#PS>			; SAVE CURRENT PS
	SPLC	5			;;DISABLE DISK INTERRUPTS
	MOV	DSQBWP(R4),R0		;;R0 -> PREVIOUS ITEM IN LIST PTR
	BEQ	10$			;;IF ZERO, MUST BE 1ST ITEM OF LIST
	MOV	(R4),-DSQBWP(R0)	;;DEQUE ITEM FROM FORWARD LIST
	BEQ	20$			;;IF FORWARD PTR = 0, DSQ IS LAST ITEM
					;;.. OF LIST.
	MOV	(R4),R0			;;R0 -> DSQ OF NEXT ITEM IN LIST
	MOV	DSQBWP(R4),DSQBWP(R0)	;;SET BACKWARD POINTER IN NEXT DSQ
	BR	20$			;;THAT'S IT
10$:	MOV	(R4),@2(SP)		;;DEQUE FIRST ITEM OF LIST
	BEQ	20$			;;QUEUE EMPTY
	MOV	(R4),R0			;;R0 -> NEXT DSQ IN CHAIN
	CLR	DSQBWP(R0)		;;NEXT ITEM IS NEW 1ST ITEM. 
					;;.. THEREFORE, PRIVIOUS PTR = 0
20$:	POP	<@#PS>			;;RESTORE PS
	POP	<R0>			; RESTORE R0
	RETURN				; RETURN TO CALLER



.SBTTL	REQSER - REQUEST CONTROLLER SERVICE
;+
; REQSER - This routine queues the CMT into the service queue and
;	   requests level 3 service for the controller.
;
; INPUT:	R4 -> CMT ENTRY
;
; OUTPUT:	LEVEL 3 SERVICE REQUESTED
;		CONTROLLER IS QUEUED FOR SERVICE
;
; REGISTERS PRESERVED
;-

SERVIC::				; Cross overlay global for INIT	;005
REQSER::MOV	R0,-(SP)		; SAVE R0
	MOV	#CMT+CM.CRQ,R0		;R0 -> REQUEST QUEUE ROOT
	MOV	@#PS,-(SP)		; SAVE CURRENT PRIORITY
	SPLC	5			;;DISABLE DISK INTERRUPTS
10$:	TST	(R0)			;;END OF QUEUE?
	BEQ	20$			;;  Yes, queue CMT to end of list
	MOV	(R0),R0			;;GET NEXT ENTRY IN QUEUE
	CMP	R0,R4			;;IS THIS THE ITEM?
	BEQ	30$			;;  Yes, already queued for service
	BR	10$			;;  No, look at next CMT entry.

20$:	MOV	R4,(R0)			;;Add this CMT to the service queue
	CLR	(R4)			;;CLR CHAIN WORD IN CMT
	L3QSET	QPHCON			;;REQUEST LEVEL 3 SERVICE for driver
30$:	MOV	(SP)+,@#PS		;;RESTORE PROCESSOR STATUS
	MOV	(SP)+,R0		; RESTORE R0
	RETURN				; RETURN TO CALLER

.DSABL	LSB


.SBTTL	JMPQUE - QUEUE AN ENTRY AT THE HEAD OF THE QUEUE
;+
; JMPQUE - Routine will queue an item as the 1st entry on a queue
;	   jumping ahead of any other requests already queued.
;
; INPUT:	R4 -> DSQ TO BE 1ST IN QUEUE
;		R0 -> Q ROOT OF QUEUE
;
; OUTPUT:	Item is 1st on queue. Forward chain points to 2nd item
;		on queue (previously the 1st), backwards pointer = 0.
;
; REGISTERS PRESERVED
;-
JUMPQU::				; Cross overlay global for INIT	;005
JMPQUE::PUSH	<@#PS>			; -SAVE CURRENT PS
	PUSH	<R0>			; -Save the queue root
	SPLC	5			;;-DISABLE DISK INTERRUPTS
	CLR	(R4)			;;-No forward link in new item, yet.
	CLR	DSQBWP(R4)		;;-No backwards link for new item
	MOV	(R0),R0			;;-Get 1st entry in queue
	BEQ	10$			;;-Queue empty is easy
	MOV	R4,DSQBWP(R0)		;;-Set the backwards pointer of the
	ADD	#DSQBWP,DSQBWP(R0)	;;-  1st entry to point to new item.
	MOV	R0,(R4)			;;-Set up new item to point to 1st
10$:	POP	<R0>			;;-Restore original queue root
	MOV	R4,(R0)			;;-Now make new item 1st in queue
	POP	<@#PS>			; -Restore previous PS
	RETURN

.SBTTL	DEQALL - DEQUE ITEM FROM LIST
;+
; DEQALL
;
; ROUTINE TO DEQUEUE FROM A SINGLY LINKED (FIFO) LIST QUEUE.  THIS
; ROUTINE WILL MASK OUT DISK INTERRUPTS WHILE DEQUEING.
;
; INPUT:	R4 -> QUEUE ROOT
;
; OUTPUT:	R4 -> ITEM DEQUED
;
; R4 CHANGED
;-
DEQALL:	MOV	@#PS,-(SP)		; SAVE CURRENT PS
	SPLC	5			;;DISABLE DISK INTERRUPTS
	MOV	(R4),-(SP)		;;GET NEXT (SP)
	BEQ	10$			;;QUEUE EMPTY
	MOV	@(SP),(R4)		;;DEQUEUE ITEM
10$:	MOV	(SP)+,R4		;;R4 -> QUEUE ITEM
	MOV	(SP)+,@#PS		;;RESTORE PS AT ENTRY
	TST	R4			; SET CONDITION CODE
	RETURN				; RETURN TO CALLER


.SBTTL	VALPKT - VALIDATE END PACKET
;+
; VALPKT
; THIS ROUTINE VALIDATES AN END PACKET.  
;
;    Command Reference Field  [ DSQ/TSQ + UCB ] = Normal I/O request
; In order for the driver to time-out requests that are exceeding the
; time-out limit, a seperate queue is kept for commands sent to the
; controller (C.OLDL). It is the class driver's responsibility to make
; sure all requests are removed from the oldest oustanding command queue
; after it completes processing the request. Otherwize the driver will
; fail to time-out commands that are exceeding the time-out limit.
;
;    Command Reference Field  [ CCB + CCB ] = a SCC or GCS command.
; If the packet is a controller related request, then no action is taken.
; Controller requests have no DSQ/TSQ associated with them, so they are
; not kept on the oldest outstanding command queue. Certain driver states
; will cause a SCC or GCS to be issued to the controller. Once issued, the
; driver ceases to process any more requests for that controller until the
; command completes successfully.
; 
;   Command Reference Field [ Zero + UCB ] = Unit verification on controller
; If the GET UNIT STATUS command has a zero in place of the DSQ/TSQ pointer,
; then the controller is verifying it's units. This action is initiated when
; an AVAILABLE attention message is recieved for a unit and all four UCBs
; are already assigned to a device. (See AVLATN and GUSEND routines).
;
; INPUT:	R1 -> END PACKET
;		R5 -> CCB
;
; OUTPUT:	C-BIT CLEAR, PACKET OK
;		C-BIT SET, IGNORE PACKET
;
; REGISTERS 0, 3, 4 destroyed
;-
VALPKT:	BIT	#OP.AVA,P.OPCD(R1)	;-Is this an attention message?
	BNE	70$			;-Yes, have to assume it's O.K.	;009
	MOV	P.OPCD(R1),R3		; R3=OPCODE
	BIC	#<177400>!OP.END!OP.AVA,R3;CLEAR NON-OPCODE BITS

	TST	(R1)			; IS CONTROLLER VERIFYING ITS UNITS?
	.ASSUME	P.CRF	EQ	0
	BNE	10$			; NO
	BIT	#CS.VFU,(R5)		; ARE WE DOING UNIT VERIFICATION FOR
	.ASSUME	C.STAT	EQ	0
					; .. THIS CONTROLLER?
	BEQ	65$			; No, Ignore this packet!	;006
	CMP	#OP.GUS,R3		; IS THIS GUS END PACKET?
	BEQ	60$			; YES, GOOD RETURN
	BR	65$			; No, This is an unknown CRF	;006
10$:	CMP	(R1),R5			; IS THIS A SCC OR GCS?
	.ASSUME	P.CRF	EQ	0
	BNE	30$			; NO

	CMP	#OP.GCS,R3		; IS THIS GET COMMAND STATUS
	BNE	20$			; NO
	BIT	#CS.GCS,(R5)		; ARE WE WAITING FOR A GCS END?
	.ASSUME	C.STAT	EQ	0
	BEQ	65$			; NO, IGNORE PACKET
	BR	60$			; DO GOOD RETURN

20$:	CMP	#OP.SCC,R3		; IS THIS A SCC END PACKET
	BNE	65$			; NO, THIS SHOULD NOT HAPPEN!
	BIT	#CS.SCC,(R5)		; ARE WE WAITING FOR SCC END PACKET?
	.ASSUME	C.STAT	EQ	0
	BEQ	65$			; NO, THIS SHOULD NOT HAPPEN
	BR	60$			; DO GOOD RETURN

30$:	CMP	(R1),C.OLDL(R5)		; IS OLDEST JUST COMPLETING?
	.ASSUME	P.CRF	EQ	0
	BNE	40$			; NO
	MOV	#-1,C.CMST(R5)		; YES, RESTART OLDEST OUSTANDING
	MOV	#-1,C.CMST+2(R5)	; .. COMMAND STATUS WORDS
	CLR	C.TIMR(R5)		; CLEAR REMAINING TIME

; VERIFY THAT THE PACKET'S DSQ IS IN THE QUEUE

40$:	MOV	R5,R0			; R0 WILL POINT TO QUEUE ROOT
	ADD	#C.OLDL,R0		; .. OF OLDEST OUTSTANDING CMD LIST
50$:	MOV	(R0),R0			; GET NEXT ITEM IN QUEUE
	BEQ	65$			; QUEUE IS EMPTY? IGNORE THE PACKET
	CMP	R0,(R1)			; IS THIS THE ONE?
	.ASSUME	P.CRF	EQ	0
	BNE	50$			; NO

; REMOVE THE DSQ FROM THE OLD LIST AND PUT IT BACK ON TO THE REQUEST LIST

	MOV	R5,R0			; R0 WILL POINT TO QUEUE ROOT
	ADD	#C.OLDL,R0		; .. OF OLDEST OUTSTANDING CMD LIST
	MOV	(R1),R4			; R4 = DSQ
	.ASSUME	P.CRF	EQ	0
	CALL	DEQUER			;;DEQUE THE DSQ
	MOV	C.CMT(R5),R0		; -GET CMT OFFSET		;001
	ADD	#CMT+CM.QUE,R0		; -NOW R4->CMT			;002
	CALL	QUEMCP			;;RETURN DSQ TO THE REQUEST LIST

; START TIMER FOR CURRENT OLDEST OUT STANDING REQUEST, IF ANY.
60$:	CLR	C.TIMR(R5)		; Assume no more requests	;006
	TST	C.OLDL(R5)		; Are there any other requests?	;006
	BEQ	70$			; Yes, don't start timer (C-bit clear)
	CALL	CLOCK			; RESTART MSCP CLOCK
	TST	(PC)+			;-Clear C-bit, skip SEC		;006
65$:	SEC				;-Say BAD return		;006
70$:	RETURN				; RETURN TO CALLER





.SBTTL	********************************************
.SBTTL	*         UMR RELATED SUBROUTINES          *
.SBTTL	********************************************

.SBTTL	UMRGET - GET UNIBUS MAPPING REGISTERS SUBROUTINE
;+
; UMRGET
;
; SUBROUTINE GETS UMRS AND FLAGS DSQ AS HAVING UMRS
; ASSIGNED TO IT.
;
; INPUT:	R4 -> DSQ
;
; OUTPUT:	C-BIT CLEAR IF UMR WERE ASSIGNED
;		R.UMRA SET IN DSQSTS TO INDICATE
;		UMRS ASSIGNED TO DSQ.
;
; R0, R1, R2 CHANGED
;-
ACQUMR::				; Cross overlay global for INIT	;005
UMRGET::MOV	DSQCNT(R4),R0		; R0=WORD COUNT
	NEG	R0			; R0=-(WORD COUNT)
	MOVB	DSQMAM(R4),R1		; GET HIGH ADDRESS
	MOV	DSQMAL(R4),R2		; GET LOW ADDRESS
					; R4 -> DSQ
	CLC				; CLEAR CARRY
	MOV	@#PS,-(SP)		; SAVE CURRENT PS
	SPLC	5			;;DISABLE DISK INTERRUPTS
	CALL	@GETUMR			;;GET UMRS
	BCS	10$			;;NOT AVAILABLE
	BISB	#R.UMRA,DSQSTS(R4)	;;SET UMR ASSIGNED FLAG
10$:	ADC	(SP)			;;SET/CLEAR CARRY
	MOV	(SP)+,@#PS		;;RESTORE PS
	RETURN				; RETURN

GLOBAL	<GETUMR>							;001


.SBTTL	********************************************
.SBTTL	*      ONE SHOT INITIALIZATION CODE        *
.SBTTL	********************************************

.SBTTL	ALOCCB - ALLOCATE CCB'S IN the MSCP Region
;+
; ALOCCB
;
; This is MSCP one-shot code responsible for allocating CCB data
; structures in the MSCP region for MSCP and TMSCP class drivers.
; The starting MSCP region address, mapping value and region sizes
; are jammed into the CMT header by INIT.SYS.
;
; INPUT:	CMT+CM.BR6 = APR6 OF BBR AREA (1st section of region)
;		CMT+CM.CCT = NUMBER OF CONTROLLERS
;
; OUTPUT:	MSCP region for class drivers in initialized.
;
; All registers preserved
;-
INITPH::				; Cross overlay global for INIT	;005
ALOCCB::CMP	CMT+CM.CRQ,#-1		; DATA STRUCTURES INITIALIZED?	;001
	BNE	90$			; YES, SO DO NO MORE		;001
	REGSCR				; SAVE REGISTERS
;+
; Now, compute bus address offset into this region in terms of mmu's.
; We do this by taking the unibus address divided by 100 (given to us
; by INIT) and subtracting the base mmu of the MSCP region from it.
; Thus, to compute the unibus address from a physical address, the
; formula is:
;
; UNIBUS ADDRESS=<<<<PHYSICAL ADDRESS>/100> + <UNIBUS OFFSET>>*100>&
;		 ... &<LOW ORDER 6 BITS OF PHYSICAL ADDRESS>
;-
	BIT	#XC$UMR,X.CON		; Are we a UMR system?		;025
	BEQ	3$			;  No, so NO UMR offset		;025
	SUB	CMT+CM.BA6,CMT+CM.UOF	; Calculate the UNIBUS offset	;021
	BMON	5$			;  but only for monitor		;021

3$:	CLR	CMT+CM.UOF		;  INIT or NO UMRs (QBUS)	;021
;+
; NOW, MAP TO THE MSCP REGION AND ZERO IT.
;-
5$:	MAP	PUSH,APR=6,DATA		; SAVE CURRENT APR 6
	MAP	CMT+CM.BA6,APR=6,DATA 	; MAP TO BBR BUFFER FOR UDA
	MOV	#140000,R5		; R5=OFFSET TO START OF BUFFER
	TSTB	CMT+CM.DCT		; ANY MSCP DISKS AT ALL?	;015
	BEQ	15$			; NO, SO NO BBR INITIALIZATION	;015
	MOV	#BBRSIZ/2,R1		; R1=SIZE OF MSCP REGION IN WORDS
10$:
	CLR	(R5)+			; CLEAR BBR AREA
	SOB	R1,10$			; LOOP TILL ALL CLEARED
	SUB	#BBRSIZ,CMT+CM.AWS	; ACCOUNT FOR BBR REGION
;+
; NOW, ALLOCATE CONTROLLER WORK AREAS.
;-
15$:	MOVB	CMT+CM.CCT,R1		; R1=NUMBER OF CONTROLLERS	;015
	MOV	#CMT,R4			; R4 -> BASE OF CMT TABLE
20$:
	MOV	R5,CM.COF(R4)		; SET OFFSET TO NEXT CONTROLLER REGION
	BIC	#37701,CM.COF(R4)	; IT CANNOT HAVE BITS 37701 SET
					; NOW, GENERATE CCB PAR6 VALUE
	BIC	#140077,R5		; R5=OFFSET IN MMU*100 TO NEXT CCB
	ASH	#-6,R5			; R5=OFFSET IN MMU'S
	ADD	R5,@DPAR6		; GENERATE APR6 FOR THIS CONTROLLER
	MOV	@DPAR6,CM.AP6(R4) 	; SAVE CONTROLLER APR6 VALUE

	MOV	CM.COF(R4),R5		; R5 -> CCB
	MOV	CM.WKA(R4),R3		; R3=WORK AREA SIZE IN BYTES
	ASR	R3			; R3=WORK ARE SIZE IN WORDS
30$:	CLR	(R5)+			; CLEAR CONTROLLER'S WORK AREA
	SOB	R3,30$			; LOOP TILL DONE
					; NOW, FIND PORT DRIVER FOR CONTROLLER
	MOV	CM.COF(R4),R5		; R5 -> CCB
	MOV	#AVLTBL,R3		; R3 -> PORT DRIVERS AVAILABLE TABLE
40$:	TST	(R3)			; END OF TABLE?
	BNE	50$			; NO
	CRASH				; MUST HAVE PORT DRIVER, CRASH SYSTEM

50$:	MOV	R3,C.PDVR(R5)		; SAVE PORT DRIVER BRANCH TABLE IN CCB
	CALL	@PD.XBI(R3)		; CALL PORT DRIVER TO DO CONTROLLER
					; DEPENDENT INITIALIZATION.
	SUB	CM.WKA(R4),CMT+CM.AWS	; SUB FROM AVAILABLE WORK AREA SIZE
	BGE	70$			; ALL IS WELL
	CRASH				; CRASH, NOT ENOUGH WORK AREA
;+
; AT THIS POINT CCB IS INITIALIZED WITH PORT DRIVER DEPENDENT DATA
; R5=CCB, R4=CMT, R3=PORT DRIVER AVAIL.TABLE ENTRY
;-
70$:	BINIT	80$			; IF INIT, DON'T REQSER		;015

;+
; WE NEED TO QUEUE ALL CONTROLLERS FOR SERVICE SO THAT WE CAN BRING THEM
; ONLINE TO THE HOST AND BE ABLE TO SEE ATTENTION MESSAGES, SUCH AS
; UNIT AVALABLE.  WE CANNOT QUEUE ALL CONTROLLERS FOR INITIALIZATION WHEN
; IN INIT AS INIT IS ABLE TO SIMULATE INTERRUPTS FOR ONLY ONE CONTROLLER
; AT A TIME.  BUT THAT IS O.K. BECAUSE WE DONT'T RECEIVE ATTENTION MESSAGES
; WHILE IN INIT.
;- 
	CALL	REQSER			; QUEUE CONTROLLER FOR SERVICE TO
					; .. BRING IT ONLINE TO HOST.
80$:	ADD	CM.WKA(R4),R5		; POINT TO NEXT CCB
	ADD	#CMTSIZ,R4		; POINT TO NEXT CMT ENTRY
	SOB	R1,20$			; DO NEXT CCB
	MAP	POP,APR=6,DATA		; RESTORE MAPPING AT ENTRY
90$:	RETURN				; DONE, RETURN TO CALLER	;001

GLOBAL	<AVLTBL,X.CON>


.SBTTL	********************************************
.SBTTL	*              END CPH                     *
.SBTTL	********************************************

;
;
.END

