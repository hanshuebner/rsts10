	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
	.INCLUDE /DSK:DMDEF/
TITLE	DMSEEK,<OVERLAPPED SEEK RK611/RK06/RK07 DISK DRIVER>,0A,10-MAY-91,MHB/TWH/VAM/DBM

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR DMSEEK
;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;  001	TWH  28-OCT-83	ADD SUPPORT FOR IFUN
;  002	FEK  18-May-84	Fix IFUN support
;  003  VAM  24-Feb-85	Add non-existant device support to IFUN.
;  004  VAM  01-Apr-85	Don't log Write Check miscompares as hard errors
;  005  VAM  30-May-85	Add RELFUN.
;  006	DBM  02-Sep-85	Handle seek interrupts during I/O requests
;
;			[RSTS/E V9.6]
;  007	KCG  29-Feb-88	Add FMTFUN.
;
;-

	DEFORG	DMSEEK

	DEFORG	DMDSK

	INCLUDE	<CMNDSK,UNIDSK,OPTDSK,ECCDSK,ERLDSK>

	DSKDEF	DM

;   RK611 FUNCTION CODES

RKFUN:	.WORD	WRITE		;WRITE WITH WRITE CHECK
	.WORD	WRITE		;WRITE
	.WORD	READ		;READ
	.WORD	WRITEC		;WRITE CHECK
	.WORD	0		;INITIALIZE			;001
	.WORD	WRITE		;Write Erase			;005
	.WORD	0		;RELFUN				;005
	.WORD	0		;Unload				;005
	.WORD	0		;Format				;007

.SBTTL	ERROR LOGGING

;+
; ERROR LOGGING.
;
;	R0-R5 =  VALUE AT TIME ERROR CALL WAS ISSUED
;
;	...
;
;	RETURN
;
;	R5 -> ERROR LOGGING CONTROL TABLE
;-

.ENABL	LSB

	ERRENT	LOG$DM

	CALLX	ERLDSK,R5	;;;CALL THE DISK ERROR LOGGING ROUTINE
	  .BYTE	ERC$DM,-1	;;;ERROR CODE, OVERLAPPED SEEK
	  .BYTE	0,9.		;;;NO OFFSET, 9. REGISTERS
	  .BYTE	RMMR1,3		;;;OFFSET, 3 REGISTERS
	  .BYTE	0,0		;;;THAT'S ALL FOR THE ROUTINE
	MOVB	@DSQPTO(R4),(R0) ;;;SET THE CURRENT OFFSET VALUE
	MOV	#20$,(R2)	;;;USE THIS ROUTINE
	MOV	#-4*400+8.,-(R2) ;;; TO ADD 8. WORDS TO FIELD 4
10$:	RETURN			;;;RETURN TO THE ERROR LOGGER

20$:	CLR	R0		;;;START WITH MESSAGE #0
	CALL	DRVSEL,R5,SELECT+1 ;;;ENSURE THAT THE DRIVE IS SELECTED
30$:	;BNE	?		;;;WE MUST IGNORE ERROR(S)...
	MOV	RMMR2(R3),(R5)+	;;;STORE THE FIRST PART OF THE MESSAGE
	MOV	RMMR3(R3),(R5)+	;;; AND THE SECOND PART
	MOV	#RMCCLR,(R3)	;;;CLEAR ANY CONTROLLER ERROR(S)
	CLR	RMMR1(R3)	;;; AND BACK TO MESSAGE #0 AGAIN
	CMP	R0,#3		;;;ARE WE DONE?
	BHIS	10$		;;;YES
	INC	R0		;;;NO, INCREMENT TO THE NEXT MESSAGE
	MOV	R0,RMMR1(R3)	;;; AND SET THE MESSAGE NUMBER
	CALL	DRVTMS,R5,SELECT+1 ;;;GET THAT MESSAGE
	BR	30$		;;; AND LOOP

.DSABL	LSB

.ENABL	LSB
.SBTTL	PUT ALL DEVICE-SPECIFIC DATA INTO REQUEST (DSQ)

;+
; QDS$DM - QUEUE DISK I/O REQUEST.
;
;	R0 =  STARTING LBN (MSB)
;	R1 =  STARTING LBN (LSB)
;	R2 =  DISK DRIVER INDEX
;	R3 =  PHYSICAL UNIT NUMBER * 2
;	R4 -> DSQ
;	R5 =  FIP UNIT NUMBER * 2
;-

QDS$DM::MOV	R3,(R4)		;SET QUEUE ROOT OFFSET AS UNIT *2
	MOVB	DSQSAV(R4),R3	;GET FUNCTION CODE
	CMPB	R3,#IFUN	;IS THIS A DRIVE INITIALIZE?		;001
	BEQ	30$		;YEP					;001
	CMPB	R3,#RELFUN	;How about a Release?			;005
	BEQ	30$		;Yup.					;005
	CMPB	R3,#FMTFUN	;Maybe a FORMAT?			;007
	BEQ	30$		;Yo					;007
	MOVB	RKFUN-WFUN.C(R3),DSQFUN(R4) ;SET UP RK611 FUNCTION CODE
	DIV	#3.*22.,R0	;DIVIDE FOR THE CYLINDER NUMBER
	MOV	R0,DSQOPT(R4)	;STORE THE ANSWER (CYL NUM)
	CLR	R0		;CLEAR HIGH ORDER FOR TRACK DIVIDE
	DIV	#22.,R0		;GET ANSWER=TRACK, REMAINDER=SECTOR
	SWAB	R0		;PUT TRACK INTO HIGH BYTE
	BIS	R1,R0		; AND PUT SECTOR INTO LOW BYTE
	MOV	R0,DSQPDA(R4)	;NOW STORE TRACK/SECTOR
	MOV	#ECOFTB-1,DSQPTO(R4) ;INITIALIZE TO NO OFFSETS YET
30$:	CALL	@(SP)+		;NOW CO-ROUTINE RETURN			;001
	TST	DMDCTL		;;WAS 1ST IN QUEUE, CONTROL BUSY NOW??
	BNE	CKEXIT		;;YES, MUST EXIT FOR NOW
	.BR	DMATTN		;;NO, GO CHECK THE ATTN LINES

GLOBAL	<ECOFTB,DMDCTL>
.DSABL	LSB

.SBTTL	PROCESS ATTENTION LINES

DMATTN:	MOVB	RMASOF+1(R3),R4	;;GET ATTN LINE SUMMARY
	BEQ	CKSEEK		;;NO LINE(S) ON, CHECK FOR SEEKS AND/OR I/O
10$:	MOV	#BITBYT,R0	;;GET BIT-TO-BYTE TABLE POINTER
20$:	BITB	R4,(R0)+	;;DOES THE ATTN LINE MATCH THIS BIT?
	BEQ	20$		;;NO, LOOP UNTIL A MATCH
	MOVB	-(R0),R5	;;YES, GET SINGLE BIT OF ATTN LINE
	SUB	#BITBYT,R0	;; AND CALCULATE DRIVE'S UNIT NUMBER
	CMP	R0,#CNT.DM	;;LEGAL DRIVE?
	BHIS	40$		;;NOPE
	MOV	R0,R1		;;PUT UNIT NUMBER
	ASL	R1		;; TIMES 2 OVER HERE
	TSTB	DSS$DM(R1)	;;WAS THE DRIVE SEEKING, ETC.?
	BEQ	30$		;;NOPE, LEAVE IT ALONE
	CLRB	DSS$DM+1(R1)	;;YEP, SET STATUS TO WAITING FOR I/O
30$:	MOV	#RMCCLR,(R3)	;;CLEAR ANY CONTROLLER ERROR(S)
	MOV	R0,RMCS2(R3)	;; AND SET ATTN'ING DRIVE'S UNIT NUMBER
	CALL	DRVATS,R5,IE+DRESET+1 ;;SELECT & RESET THE ATTN'ING DRIVE
	BEQ	DMATTN		;;O.K., CHECK FOR MORE ATTN LINES BEING ON
40$:	BICB	R5,R4		;;FUNNY ERROR(S), REMOVE BAD DRIVE FROM BITS
	BNE	10$		;;OTHER BIT(S) ARE ON, PROCESS THEM FIRST
	MOV	#RMSCLR,RMCS2(R3) ;;ELSE MUST COMPLETELY CLEAR SUBSYSTEM!!!
	.BR	CKSEEK		;; THEN GO CHECK FOR SEEKS AND/OR I/O

GLOBAL	<BITBYT,CNT.DM,DSS$DM,IE>

.SBTTL	CHECK FOR SEEKS AND I/O TO START

.ENABL	LSB

;+
;	Note: All of the '003' edits in this section were needed to eliminate
;	out-of-range branch errors caused by the addition of the IFUN code.
;-

UMR$DM::
CKSEEK:	MOV	#DQE$DM,R0	;;GET END OF QUEUE ROOTS +2 POINTER
10$:	MOV	-(R0),R4	;;GET TOP-OF-QUEUE REQUEST
	BEQ	20$		;;NONE
	TST	DSO$XX(R0)	;;ONE, IS DRIVE IDLE NOW?
	BNE	20$		;;NOPE, BUSY OR WAITING FOR I/O
	CMPB	DSQSAV(R4),#IFUN;;IS THIS A DRIVE INITIALIZE?		;001
	BEQ	80$		;;YEP					;001
	CMPB	DSQSAV(R4),#RELFUN	;;How about a Release?		;005
	BEQ	79$			;;Yup.				;005
	CMPB	DSQSAV(R4),#FMTFUN	;;Maybe a FORMAT?		;007
	BEQ	78$			;;Yes, return error		;007
	CALLX	OPTDSK,R5,OPT$DM ;;IDLE, OPTIMIZE THIS DRIVE'S QUEUE
	MOV	#ECOFTB-1,DSQPTO(R4) ;;RESET ANY OFFSET SEQUENCE IF SEEKING
	CALL	SETUP		;;GO SELECT (AND ACK) THE DRIVE
	CALL	DRVCMD,R5,IE+SEEK+1 ;;START THE DRIVE SEEKING
	BNE	75$		;;WHOOPS! AN ERROR			;003
	MOV	#-5*400+1,DSO$XX(R0) ;;SET TIMEOUT AND SEEKING STATUS
20$:	CMP	R0,#DQS$DM	;;MORE QUEUES TO CHECK?
	BHI	10$		;;YES, SO CHECK THEM...
	MOV	#CNT.DM,R5	;;NOW CHECK FOR STARTING I/O
	MOV	DMDPT1,R0	;;GET ROUND-ROBIN QUEUE ROOT POINTER
30$:	CMP	R0,#DQS$DM	;;POINTER WITHIN RANGE?
	BHI	40$		;;YES
	MOV	#DQE$DM,R0	;;NO, ROUND-ROBIN IT
40$:	MOV	-(R0),R4	;;GET TOP-OF-QUEUE REQUEST
	BEQ	50$		;;NOTHING IN THE QUEUE
	TST	DSO$XX(R0)	;;SOMETHING, WHAT IS THE DRIVE'S STATUS?
	BGT	60$		;;WAITING FOR I/O
50$:	SOB	R5,30$		;;ELSE LOOP FOR ALL DRIVES
CKEXIT:	RETURN			;;NOTHING TO DO, EXIT

60$:	MOV	R0,DMDPT1	;;REMEMBER THE ROUND-ROBIN POSITION
	CALL	SETUP		;;SELECT (AND ACK) THE DRIVE
	TST	DSQCNT(R4)	;;REALLY MORE I/O TO DO?
	BPL	65$		;;Nope, really all done.		;003
	CMP	DSQPTO(R4),#ECOFTE ;;AT END OF OFFSETS?
	BLO	70$		;;NOPE
	CLRB	DSQERR(R4)	;;YEP, FAKE A DATA TYPE ERROR
65$:	JMP	DMDONE		;; and say all done.			;003

70$:	CALLX	DSKUMR		;;GET WINDOW FOR THE TRANSFER
	ASH	#8.-4,R1	;;WE WANT <17-16> IN <9-8> FINALLY
	MOV	R0,DMDCTL	;;SAY CONTROL BUSY WITH THIS REQUEST
	MOVB	DSQOUN(R4),R5	;;GET 2* PHYSICAL UNIT NUMBER
	MOV	MID$DM(R5),-(SP) ;;STACK THE RK06/7 DETERMINATION
	JMPX	DSKSRU		;; AND GO START THE I/O

75$:	BR	DMEROR		;;Fix out-of-range branch.		;003

78$:	SETERR	ERRERR,DSQERR(R4)	;;FMTFUN is unsupp here		;007
79$:	BR	120$			;;join common exit		;007

	.PAGE
	.SBTTL	IFUN Handler
;+
;
;	I F U N   R E Q U E S T   H A N D L E R				;003
;
; The IFUN (Initialize FUNction) is used to check for the presence of a
; given RK06/RK07 drive, and to determine the drive type and fill in the
; UNTSIZ and DEVCLU table entries if it's there.
;
; Here are the steps taken for an IFUN request;
;
; 1)	Clear out the UNTSIZ and MID$XX entries for the drive.
; 2)	Wait for the controller to become ready.
; 3)	Clear out any old error bits.
; 4)	Select and reset the drive, assuming that it's an RK06.
; 5)	Check the NED (Non-Existant Drive) bit to see if the drive in question
;	exists at all.  If not, return with '?Not a valid device' in the DSQ,
;	but do not log a hard error.
; 6)	If it does exist, check the RMDTY (Drive Type) bit to see if a mismatch
;	occurred.  If set, it means that the drive was really an RK07, so
;	set up for an RK07 and go back to Step 2.
; 7)	When we've finally got a match, check the RMDRA (Drive Available) bit
;	to see if the drive has been siezed by another system.  If so, we
;	return '?Device hung or write locked' in the DSQ, but do not log a
;	hard error.
; 8)	If the drive is available, test RMDRY (Drive Ready) to see if it's
;	spun up.  If not, once again we return '?Device hung or write locked'
;	in the DSQ without logging a hard error.
; 9)	We then check for any other errors.  If any occurred, we log a hard
;	error.
; 10)	Finally, we set the DEVCLU and UNTSIZ table entries for the drive,
;	based on the drive type we found.
;
;-

80$:	MOVB	DSQUNT(R4),R5		;;Get FUN			;003
	ASL	R5			;; TIMES TWO			;001
	CLR	UNTSIZ(R5)		;;Set UNTSIZ for unknown	;003
	CLR	MID$XX(R5)		;;SAY WE'RE LOOKING FOR A RK06	;001
85$:	TSTB	(R3)			;;Controller ready??		;003
	BPL	85$			;;No, wait for it.		;003
	MOV	#RMCCLR,(R3)		;;Get rid of leftover errors.	;003
	MOVB	DSQPUN(R4),R2		;;GET UNIT NUMBER		;001
	MOV	R2,RMCS2(R3)		;;DO A UNIT SELECT		;001
	MOVB	DSQOUN(R4),R1		;;GET UNIT NUMBER TIMES TWO.	;001
	CALL	DRVATS,R5,DRESET+1	;;SELECT AND RESET THE DRIVE	;001
	BIT	#RMNED,RMCS2(R3)	;;Does the drive exist??	;003
	BNE	150$			;;Nope, go tell 'em.		;003
	BIT	#RMDTY,RMER(R3)		;;Is it really what we said?	;003
	BEQ	90$			;;Yup, it appears to be.	;003
	TST	MID$XX(R5)		;;Have we tried both types??	;003
	BNE	100$			;;Yup, go log an error!		;003
	BIS	#RMCDT,MID$XX(R5)	;;Otherwise, call it an RK07...	;003
	BR	85$			;; ...and try again.		;003
90$:	BIT	#RMDRA,RMDS(R3)		;;Is it available??		;003
	BEQ	160$			;;No, tell 'em.			;003
	TSTB	RMDS(R3)		;;Is it spun up??		;003
	BPL	160$			;;No, tell 'em that too.	;003
	TST	(R3)			;;Any random errors??		;003
	BPL	110$			;;Nope.				;003
100$:	CLZ				;;SAY IT'S A HARD ERROR		;001
	LOG$DM				;;LOG AN ERROR HERE		;001
	CALLX	DFINT1			;;CHECK CC'S AND COUNT ERROR	;001
	BR	120$			;;LET'S GET OUT OF HERE		;001
	
110$:	MOVB	#1,DEVCLU(R5)	     ;;SET DCS=1			;002
	MOV	#27104.,UNTSIZ(R5)   ;;SET UNTSIZ	(ASSUME RK06)	;001
	BIC	#^C<002000>,MID$XX(R5)		;;GET DRIVE TYPE	;001
	BEQ	120$		     ;;IT'S AN RK06			;001
	MOV	#53768.,UNTSIZ(R5)   ;;CORRECT UNTSIZ FOR A RK07	;001
120$:	CALLX	DFINT9		     ;;DEQUEUE AND SET L3Q		;001
	BR	20$	             ;;REQUEST IS DONE			;001
	
150$:	MOVB	#NOTAVL,DSQERR(R4)	;;Stick the error away		;003
	BR	120$			;;Go back for more.		;003

160$:	MOVB	#HNGDEV,DSQERR(R4)	;;Tell 'em it's hung.		;003
	BR	120$			;;Go join the mainstream.	;003

GLOBAL	<UNTSIZ,DEVCLU,ECOFTB,OPT$DM,DSO$XX,UNTCNT,MID$XX>		;001
GLOBAL	<DQS$DM,DQE$DM,DMDPT1,DMDCTL,ECOFTE>
GLOBAL	<IE,CNT.DM,MID$DM>
GLOBAL	<NOTAVL,HNGDEV,ERRERR>						;003

.DSABL	LSB

.SBTTL	INTERRUPTS (PR5)

.ENABL	LSB

INT$DM::MOV	CSR.DM,R3	;;GET THE CSR ADDRESS
	TSTB	(R3)		;;IS CONTROLLER REALLY READY??
	BPL	CKEXIT		;;NOPE, JUST EXIT FROM THIS INTERRUPT
	MOV	DMDCTL,R0	;;GET THE CONTROLLER STATUS (POINTER)
	BEQ	DMATT0		;;NOT BUSY, GO CHECK ATTN LINES		;001
	MOV	(R0),R4		;;Get request from the top of queue	;006
	MOVB	DSQPUN(R4),RMCS2(R3) ;;Re-select that drive		;006
	BITB	#RMDRDY!RMDSC,RMDS(R3) ;;Drive ready or change status?	;006
	BEQ	DMATT0		;;No, so another drive must have ATTN	;006
	CLR	DMDCTL		;;Yes, clear in-progress indicator	;006

	CALL	@RELUMR		;;RELEASE WINDOWS FOR THIS REQUEST
	CLR	DSO$XX(R0)	;; AND SAY DRIVE IS IDLE NOW

	TST	(R3)		;;ANY ERRORS FOR NORMAL PROCESSING?
	BPL	DMDONE		;;NO - WE'RE ALL FINISHED WITH THIS REQUEST
	MOV	RMER(R3),R2	;;GET THE CONTENTS OF THE ERROR REGISTER
DMEROR:	BIT	R2,#RMUNS!RMWLE!RMIDAE!RMCOE!RMDTY!RMFMT!RMNXF!RMILF ;;HARD?
	BNE	HARDER		;;YES
	BIT	RMCS2(R3),#RMNED!RMNEM!RMMDS ;;CONTROLLER STATUS A HARD ERROR?
	BNE	HARDER		;;YES
	BIT	RMCS2(R3),#RMWCK	;;Write check error??		;004
	BEQ	5$			;;Nope, go check for others.	;004
	MOVB	#DATERR,DSQERR(R4)	;;Put the error code away...	;004
	BR	DMDONE			;; ...and go back.		;004

5$:	TSTB	R2		;;BAD SECTOR ERROR?
	BPL	10$		;;NO
.ASSUME	RMBSE	EQ	200	;;BE SURE WE'RE TESTING THE RIGHT BIT
	MOVB	#-1,DSQERR(R4)	;;YES, FORCE NO MORE RETRIES
10$:	BIT	(R3),#RMSPAR!RMCTO ;;MESSAGE PARITY OR CONTROLLER TIMEOUT?
	BNE	RETRY		;;YES, SO RETRY
	TSTB	RMCS2+1(R3)	;;CONTROLLER ERROR?
	BNE	RETRY		;;YES
	BIT	R2,#^C<RMDCK!RMDTE!RMHVRC!RMECH> ;;PARTIAL TRANSFER?
	BNE	RETRY		;;NO
	TST	R2		;;CORRECTABLE?
	BNE	DOECC		;;YES, GO DO CORRECTION
RETRY:	SEZ			;;INDICATE SOFT ERROR
HARDER:	LOG$DM			;;LOG AN ERROR HERE
	CALLX	DFINT1		;;CHECK CC'S AND COUNT ERROR
	BMI	20$		;;CONTINUE IF MORE RETRIES ARE LEFT
DMDONE:	CALL	DRVSEL,R5,IE+DRESET+1 ;;SELECT & RESET THE COMPLETING DRIVE
	;BNE			;; AND IGNORE ANY ERROR(S)
	MOV	#RMCCLR,(R3)	;;RESET ANY CONTROLLER ERROR(S)
	MOV	#IE,(R3)	;; BUT KEEP INTERRUPT ENABLE ON
	CALLX	DFINT9		;;SAY IDLE, DE-QUEUE, AND HOUSEKEEP REQUEST
DMATT0:	JMP	DMATTN		;;GO CHECK ATTN LINES

20$:	MOV	SP,R1		;;ENSURE R1<>0 FOR RESETTING OFFSETS
	TSTB	DSO$XX(R0)	;;ERROR FROM OFFSET OR RECAL?
	BNE	TRYOFF		;;YES, SO TRY, TRY AGAIN...
	BIT	R2,#RMOPI!RMSKI	;;SHOULD WE RECAL?
	BNE	TRYOFF		;;YES
	BR	DMATT0		;;NO, JUST PROCESS ATTN LINES

.DSABL	LSB

GLOBAL	<CSR.DM,DMDCTL,DSO$XX,IE,RELUMR,DATERR>				;004

.SBTTL	TIMEOUTS

.ENABL	LSB

10$:	MOV	#RMCCLR,(R3)	;;FORCE CONTROL TO BECOME IDLE!!!
	CLR	DMDCTL		;; AND SAY THAT WE DID IT
TMO$DM::CMP	R0,DMDCTL	;;THE REQUEST CONTROL IS BUSY WITH?
	BEQ	10$		;;YES, MUST ABORT CONTROL!
	TST	DMDCTL		;;NO, IS CONTROL BUSY AT ALL??
	BNE	20$		;;MUST JUST EXIT IF CONTROL BUSY
	CALL	DRVSEL,R5,SELECT+1 ;;RE-SELECT THE FAILING DRIVE
	BR	RETRY		;; AND CALL IT A RETRY

20$:	CLR	DSO$XX(R0)	;;ENSURE DRIVE IS MARKED AS IDLE
	;SEZ			;;INDICATE A SOFT ERROR WITH Z-BIT=1
	CALLX	DFINT1		;;COUNT ERROR
	BMI	30$		;;MORE RETRIES ARE LEFT
	CALLX	DFINT9		;;ELSE SAY IDLE, DE-QUEUE, AND HOUSEKEEP
30$:	RETURN			;;EXIT

.DSABL	LSB

GLOBAL	<DMDCTL,DSO$XX>

.SBTTL	SOFT ECC CORRECTION / HARD ECC DETECTION

DOECC:	MOV	RMECPS(R3),R1	;;GET ECC POSITION
	MOV	RMECPT(R3),R5	;;GET ECC PATTERN
	LOG$DM			;;LOG THIS TYPE OF ERROR
	CALLX	ECCDSK,R5	;;DO COMMON ECC HANDLING
	  .WORD	RMDTE!RMECH	; BACK UP 1 SECTOR ON THERE
	  .WORD	22.-400		; # SECTORS -400
	  .WORD	3.*400		; # TRACKS *400
	  .WORD	^C<RMDCK>	; NO ECC IF ANY BUT THIS
	  .WORD	DMATTN		; CHECK ATTN LINES IF ECC DONE
TRYOFF:	MOV	#1,DSO$XX(R0)	;;SET STATUS AS WAITING FOR I/O
	MOV	R4,R5		;;BUILD A POINTER TO
	ADD	#DSQPTO,R5	;; OFFSET INFORMATION
	TST	R1		;;IF R1 = 0 WE READ 0 GOOD SECTORS
	BEQ	10$		;;SO CONTINUE AT THE CURRENT OFFSET (IF ANY)
	MOV	#ECOFTB-1,(R5)	;;IF WE READ SOME GOOD DATA THEN THIS
				;; IS THE FIRST TIME, SO RESET OFFSETS
10$:	CMP	(R5)+,#ECOFTB	;;HAVE WE RETRIED THIS OP ALREADY?
	BLO	20$		;;NOPE - FIRST TIME, GO TO A NEW OFFSET (OF 0)
	DECB	(R5)		;;ANOTHER RETRY AT THIS OFFSET?
	BGT	DMATT0		;;NO - REDO THE READ OPERATION AT THIS OFFSET
20$:	MOVB	#16.,(R5)	;;ASSUME NEW OFFSET WILL BE 0 WITH 16 RETRIES
	INC	-(R5)		;;BUMP POINTER TO NEW OFFSET VALUE
	CALL	SETUPX		;;SELECT DRIVE, ETC.
	TSTB	@(R5)+		;;WHAT OFFSET VALUE ARE WE AT?
	BEQ	40$		;;IT IS OFFSET 0, DO A RECAL
	MOVB	#2.,(R5)	;;REAL OFFSET, RESET RETRIES TO 2
	CALL	DRVCMD,R5,IE+OFFSET+1 ;;START AN OFFSET FUNCTION
30$:	BNE	DMEROR		;;WHOOPS! AN ERROR
	MOV	#-5*400+1,DSO$XX(R0) ;;SET THE STATUS AND TIMEOUT
	RETURN			;;EXIT FROM INTERRUPT

40$:	CALL	DRVCMD,R5,IE+RECAL+1 ;;START A RECALIBRATE FUNCTION
	BR	30$		;; AND GO ERROR CHECK

.DSABL	LSB

GLOBAL	<DSO$XX,ECOFTB,IE>

.SBTTL	SELECT AND PACK ACKNOWLEDGE A DRIVE

;+
; SETUP - SAY IDLE, SELECT, RESET, AND PACK ACKNOWLEDGE A DRIVE.
; SETUPX - SELECT, RESET, AND PACK ACKNOWLEDGE A DRIVE.
;
;	R0 -> QUEUE ROOT
;	R3 -> CSR
;	R4 -> DSQ
;
;	CALL	SETUP
;	CALL	SETUPX
;
;	R1 =  UNIT NUMBER *2
;	R2 =  RANDOM
;
;	DOESN'T RETURN IF ANY ERROR CONDITION
;-

SETUP:	CLR	DSO$XX(R0)	;;SET DRIVE STATUS TO IDLE
SETUPX:	CALL	DRVSEL,R5,DRESET+1 ;;SELECT & RESET THE CORRECT DRIVE
	BNE	20$		;;WHOOPS! AN ERROR
	MOVB	DSQUNT(R4),R2	;;GET FIP UNIT NUMBER
	ASL	R2		;; TIMES 2 FOR WORD ADDRESSING
	BIT	#UC.MNT!UC.NFS,UNTCNT(R2) ;;NEED WE PACK ACKNOWLEDGE?
	BEQ	10$		;;NO
	CALL	DRVCMD,R5,PAKACK+1 ;;YES, PACK ACKNOWLEDGE DRIVE
	BNE	20$		;;ERROR, TAKE ERROR EXIT
10$:	MOV	RMDS(R3),R2	;;GET THE DRIVE STATUS
	COM	R2		;;COMPLEMENT THE BITS
	BIT	R2,#RMSVAL!RMDRDY!RMVV!RMDRA ;;IS THE DEVICE READY?
	BEQ	30$		;;ALL O.K., RETURN TO CALLER
	MOV	#RMUNS,R2	;;BAD, FORCE A HARD ERROR
20$:	MOV	#DMEROR,(SP)	;;CHANGE RETURN TO ERROR CHECKING
30$:	RETURN			;;NOW EXIT

GLOBAL	<UNTCNT>

.SBTTL	ISSUE A COMMAND

;+
; DRVSEL - CLEAR CONTROL, UNIT SELECT, AND ISSUE A COMMAND.
; DRVTMS - UNIT SELECT AND ISSUE A COMMAND.
; DRVCMD - ISSUE A COMMAND.
; DRVATS - ISSUE A COMMAND WITHOUT A DSQ.
;
;	R1 =  UNIT NUMBER *2 ("DRVATS" ONLY)
;	R3 -> CSR
;	R4 -> DSQ ("DRVSEL", "DRVTMS", AND "DRVCMD" ONLY)
;
;	CALL	DRVSEL,R5,<FUNCTION>
;	CALL	DRVTMS,R5,<FUNCTION>
;	CALL	DRVCMD,R5,<FUNCTION>
;	CALL	DRVATS,R5,<FUNCTION>
;
;	R1 =  UNIT NUMBER *2
;	R2 =  ERROR BITS
;
;	IF Z=1 THEN NO ERROR
;	IF Z=0 THEN ERROR
;-

DRVSEL:	MOV	#RMCCLR,(R3)	;;DO A CONTROLLER CLEAR
DRVTMS:	MOVB	DSQPUN(R4),R2	;;GET THE UNIT NUMBER
	MOV	R2,RMCS2(R3)	;; AND DO A UNIT SELECT
DRVCMD:	MOV	DSQOPT(R4),RMDCY(R3) ;;SET THE DESIRED CYLINDER
	MOVB	@DSQPTO(R4),R2	;;GET THE OFFSET VALUE
	BIC	#^C<260>,R2	;; TRIMMING IT TO LEGAL BITS
	MOV	R2,RMASOF(R3)	;;NOW SET THE OFFSET VALUE
	MOV	DSQPDA(R4),RMDA(R3) ;;SET DESIRED TRACK/SECTOR
	MOVB	DSQOUN(R4),R1	;;GET THE UNIT NUMBER *2
DRVATS:	MOV	(R5)+,R2	;;GET THE FUNCTION TO ISSUE
	BIS	MID$DM(R1),R2	;;.OR. RK06/7 DETERMINATION INTO FUNCTION
	BMI	40$		;;UNIT DISABLED??
	MOV	R2,(R3)		;;ISSUE THE FUNCTION
	MOVB	TIMCLK,R2	;;GET CURRENT CLOCK TICK VALUE
10$:	TSTB	(R3)		;;CONTROL READY YET?
	BPL	20$		;;NOPE
	MOV	RMER(R3),R2	;;YEP, GET ERROR BITS
	BIT	(R3),#RMCCLR!RMSPAR!RMCTO ;;SET Z-BIT=1 IF NO ERROR
	RETURN	R5		;; AND EXIT

GLOBAL	<MID$DM>

20$:	CLR	-(SP)		;;GET CURRENT CLOCK TICK
	MOVB	TIMCLK,(SP)	;; VALUE AS A WORD
	SUB	R2,(SP)		;;FIND THE CHANGE SO FAR
	BLE	30$		;;<=0 IS A VALID CHANGE
	SUB	#50.,(SP)	;;ELSE CORRECT FOR 50 HERTZ
	BLE	30$		;;ALL CORRECTED
	SUB	#60.-50.,(SP)	;;ELSE CORRECT FOR 60 HERTZ
30$:	INC	(SP)+		;;HAS IT BEEN 2 TICKS YET???
	BPL	10$		;;NO, CONTINUE TO WAIT
40$:	MOV	#RMUNS,R2	;;YES, SET FATAL TYPE ERROR BIT
	;CLZ			;;Z-BIT=0 FOR ERROR
	RETURN	R5		;; AND EXIT

.END

