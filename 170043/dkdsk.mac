	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
	.INCLUDE /DSK:DKDEF/
TITLE	DKDSK,<RK11/RK05/RK05F DISK DRIVER>,0A,10-MAY-91,MHB/JDM/GW/ABC/WRM/TWH/VAM

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR DKDSK
;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;
;			[RSTS V9.0]
;  001	TWH  28-OCT-83	ADD SUPPORT FOR IFUN
;  002  VAM  05-Apr-85	Don't log Write Check miscompares as hard errors
;
;			[RSTS V9.1]
;  003  VAM  30-May-85	Add RELFUN.
;
;			[RSTS V9.6]
;  004	KCG  29-Feb-88	Add FMTFUN.  (reject upon receiption)
;
;-

	DEFORG	DKDSK

	INCLUDE	<CMNDSK,UNIDSK,OPTDSK,ERLDSK>

	DSKDEF	DK

.SBTTL	ERROR LOGGING

	ERRENT	LOG$DK

	CALLX	ERLDSK,R5	;;;USE COMMON ROUTINE
	  .BYTE	ERC$DK		;;;ERROR CODE
	  .BYTE	0		;;;NON-OVERLAPPED SEEK
	  .BYTE	RKDS,6		;;;OFFSET, 6 REGISTERS
	  .BYTE	0,0		;;;THAT'S ALL
	RETURN			;;; AND BACK

.ENABL	LSB
.SBTTL	FORM THE PHYSICAL ADDRESS

QDS$DK::CMPB	DSQSAV(R4),#IFUN;IS THIS AN INITIALIZE?			;001
	BEQ	30$		;YEP					;001
	CMPB	DSQSAV(R4),#RELFUN	;How about a release?		;003
	BEQ	30$			;Yup.				;003
	CMPB	DSQSAV(R4),#FMTFUN	;Maybe a format?		;004
	BEQ	30$			;Yes 				;004
	DIV	#12.,R0		;DIV GIVES R0=TRACK(T), R1=SECTOR(S)
	SWAB	R0		;OLD SWITCHEROO TRICK. R0=TTTTTTTT0000000T
	BIS	R3,R0		;SO WE CAN .OR. IN UNIT NUMBER*2(U)
	ASH	#4,R1		;SHIFT SECTOR BITS INTO PLACE
	BIS	R0,R1		;NOW EVERYBODY IN R1=TTTTTTTTSSSSUUUT
	ASHC	#-4,R1		;FANCY ROTATE     R1=UUUTTTTTTTTTSSSS
	MOV	R1,DSQPDA(R4)	;STORE THE DISK ADDRESS
	BIC	#^C<37740>,R1	;GET OPTIMIZATION WORD (KEEPING LSB OF UNIT)
	MOV	R1,DSQOPT(R4)	;NOW STORE THE OPTIMIZATION WORD
	BICB	MID$XX(R5),DSQOUN(R4) ; OPTIMIZE BOTH RK05F UNITS TOGETHER
30$:	CALL	@(SP)+		;RETURN WITH ADDRESS ALL SET UP		;001

.SBTTL	COMES HERE IF REQUEST IS FIRST IN QUEUE

	BR	DSKGDK		;;FIRST IN QUEUE, SO DO IT


DSKGOP:	CALLX	OPTDSK,R5,OPT$DK ;;OPTIMIZE THE QUEUE
DSKGDK:	CMPB	DSQSAV(R4),#IFUN ;;IS THIS A DRIVE INITIALIZE?		;001
	BEQ	50$		;;YEP					;001
	CMPB	DSQSAV(R4),#RELFUN	;;How about a release?		;003
	BEQ	50$			;;Yup.				;003
	CMPB	DSQSAV(R4),#FMTFUN	;Maybe a format?		;004
	BEQ	40$			;Yes 				;004
	CALLX	DSKUMR		;;GET A WINDOW FOR THE TRANSFER
	MOV	DSQPDA(R4),RKDA(R3) ;;LOAD THE UNIT AND DISK ADDRESS
	CLR	-(SP)		;;INDICATE NO EXTRA PARAMETER(S)
	JMPX	DSKSRU		;; AND, NOW, START THE TRANSFER

UMR$DK::TST	DSO$XX(R0)	;;ARE WE IDLE?
	BGE	DKCKQU		;;YES, CONTINUE OPERATIONS
	RETURN			;;NO, WE'RE NOT INTERESTED		;003

40$:	SETERR	ERRERR,DSQERR(R4) ;formatting not supported		;004
50$:	CALLX	DFINT9		;;DEQUEUE THE REQUEST			;001
	MOV	#DQS$DK,R0	;;GET THE QUEUE ROOT			;001
	BR	DKCKQU		;;JOIN COMMON CODE			;001
	RETURN			;;GO AWAY				;001

.DSABL	LSB
GLOBAL	<MID$XX,OPT$DK,DSO$XX,ERRERR>

.SBTTL	INTERRUPT SERVICE (PR5)

.ENABL	LSB

INT$DK::MOV	CSR.DK,R3	;;GET A HARDWARE POINTER
	MOV	RKER(R3),R2	;;GET THE ERROR REGISTER
	MOV	#DQS$DK,R0	;;GET POINTER TO QUEUE ROOT
	MOV	(R0),R4		;;GET TOP OF QUEUE REQUEST
	BEQ	50$		;;NONE, SO IGNORE INTERRUPT
	CALL	@RELUMR		;;RELEASE WINDOWS FOR THIS REQUEST
	MOV	(R3),R1		;;GET CONTROL STATUS REGISTER
	BPL	20$		;;NO ERROR
	BIT	#RKWCK,R2		;;Write check error?		;002
	BEQ	TMO$DK			;;Nope, go log an error.	;002
	MOVB	#DATERR,DSQERR(R4)	;;Otherwise, put error away...	;002
	BR	40$			;; ...and go back.		;002

TMO$DK::LOG$DK			;;ERROR (OR TIMEOUT), SO LOG THE ERROR
	CLR	(R3)		;;ERROR, SO CLEAR OUT
	INC	(R3)		;; CONTROL
.ASSUME	CRESET	EQ	0	;;THIS IS A RESET COMMAND
10$:	TSTB	(R3)		;;WAIT FOR READY
	BPL	10$		;;KEEP WAITING
20$:	CMPB	DSQFUN(R4),#DRESET ;;FROM A DRIVE RESET?
	BEQ	80$		;;YES, PROCESS END OF RESET
	TST	R1		;;NO, DID AN ERROR OCCUR?
	BPL	40$		;;NO ERROR
	BIT	R2,#RKDRE!RKSKE	;;ERROR, WOULD A DRIVE RESET HELP?
	BNE	70$		;;IT WOULD HELP, SO DO ONE
30$:	CALLX	DFINT3		;;ALL ERRORS ARE CONSIDERED SOFT
	BMI	DSKGDK		;;MORE RETRIES LEFT, SO RETRY
	BIT	R2,#RKDRE!RKOVR!RKWLO!RKSKE!RKNXM!RKNXD!RKNXC!RKNXS
				;;NO MORE RETRIES, WAS IT A HARD ERROR?
	BEQ	40$		;;NO
	SETERR	HNGDEV,DSQERR(R4) ;;YES, SO SET THE CORRECT ERROR CODE
40$:	CALLX	DFINT9		;;SAY IDLE, DE-QUEUE, AND HOUSEKEEP
DKCKQU:	TST	(R0)		;;MORE TO DO?
	BNE	DSKGOP		;;YES, SO DO IT ALREADY
50$:	CLR	(R3)		;;CLEAR CONTROL JUST BEFORE
60$:	RETURN			;; THE EXIT

70$:	MOVB	#DRESET,DSQFUN(R4) ;;CHANGE FUNCTION TO DRIVE RESET
	BR	DSKGDK		;; AND DO ONE

80$:	BIT	R1,#RKERR!RKHE!RKSCP ;;DID ANYTHING REALLY HAPPEN?
	BNE	90$		;;YES, GO RESTORE THE FUNCTION & RETRY
	BIT	#RKARY,RKDS(R3)	;;NO, BUT IS THE DISK READY TO ACCESS?
	BEQ	60$		;;NO, WAIT
90$:	MOVB	DSQSAV(R4),DSQFUN(R4) ;;YES, RESTORE THE REAL FUNCTION
	BR	30$		;;GO CHECK FOR ERROR(S)

.DSABL	LSB

GLOBAL	<CSR.DK,DQS$DK,RELUMR,DATERR>					;002

.END

