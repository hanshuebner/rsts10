.INCLUDE /CMN:COMMON/							;006
.INCLUDE /CMN:KERNEL/							;006
.INCLUDE /CMN:KBDEF/							;008
TITLE	TIM,<ONCE-A-SECOND TIMER SERVICE>,0C,19-JUL-91,MHB/ABC/SJM/AJK/KPH/JFM

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR TIM
;+
;                                                                    
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;  001	SJM  08-JUL-81	ADD SUPPORT FOR I&D SPACE
;  002  AJK  13-JAN-82  CHANGED MAPPING LOGIC FOR DISKS
;
;			[RSTS V9.2]
;  003	KPH  09-Aug-85	Add job control region
;  004  KPH  24-Oct-85	Bugfix in terminal wait handling             
;
;			[RSTS V9.3]
;  005  KPH  01-Oct-85	Changes for DECnet/E V4.0
;
;			[RSTS V9.6]
;  006  KPH  13-Oct-87	Add .INCLUDEs
;			Skip disabled terminals without calling KBDVR
;  007  KPH  20-Oct-87	Add LAT support
;
;			[RSTS V10.0]
;  008	JFM  16-May-90	Set pending read and retype flags if KB wait exhausted
;			Include KBDEF
;
;			[RSTS V10.1]
;  009	JFM  12-Jul-91	Undo changes from 008. (Source clear Sep'91 Art 3.4.6M)
;-

	DEFORG	TIM

.SBTTL	ONCE-A-SECOND TIMER SERVICE

	L3QENT	QTIMER,,DSKAP5	;ONCE A SECOND SERVICE COMES HERE    

	INC	CHESEC		;COUNT APPROXIMATE SECONDS FOR CACHER
	MOV	#TIMEND,R5	;GET END+2 OF TIMEOUT TABLES
	.BR	TIMDVR		;DO GENERAL I/O TIMEOUTS FIRST

GLOBAL	<CHESEC>

; GENERAL I/O DEVICE TIMEOUTS

TIMDVR:	SPLC	5		;;LOCKOUT SOME INTERRUPTS
	TST	-(R5)		;;TIMING OUT?
	BEQ	20$		;;NOPE
	BMI	10$		;;YEP, AND ALWAYS CALL
	DEC	(R5)		;;YEP, EXPIRED?
	BNE	20$		;;NOT EXPIRED YET
10$:	MOV	R5,-(SP)	;;SAVE TABLE POINTER
	MOV	DDO.XX(R5),R1	;;GET DDB ADDRESS
	MOVB	DDUNT(R1),R0	;;GET UNIT NUMBER AND
	ASL	R0		;; NOW TIMES 2
	MOV	CSR.KB-TIM.KB(R5),R3 ;;GET THE CSR ADDRESS
	CALL	DOCALL		;;GO DO THE MAPPED CALLING

;+
; CONDITIONS ON CALL:
;
;	R0 =  UNIT NUMBER TIMES 2
;	R1 -> DDB
;	R3 -> CSR
;	PRIORITY IS PR5
;
;	...
;
;	RETURN
;-

	MOV	(SP)+,R5	;;RESTORE TABLE POINTER
20$:	SPLC	3		;;TO LEVEL 3 TO ALLOW INTERRUPTS
	CMP	R5,#TIM.NL	;DONE?
	BHI	TIMDVR		;NOT YET
	.BR	TIMKB		;DO TERMINAL TIMEOUTS NEXT

GLOBAL	<DSKAP5,TIMEND,DDO.XX,CSR.KB,TIM.KB,TIM.NL>

                                                                       
; TERMINAL TIMEOUTS

TIMKB:	TST	-(R5)		;BACK UP TO NEXT TERMINAL
	MOV	DDO.XX(R5),R1	;GET TERMINAL DDB ADDRESS		;006
	BITB	#1,DDJBNO(R1)	;Is this terminal disabled?		;006
	BNE	20$		;Yes, skip it				;006
	MOV	R5,-(SP)	;No, save timeout table pointer		;006
	MOVB	DDUNT(R1),R0	;GET KB NUMBER
	ASL	R0		; NOW TIMES 2
	TST	(R5)		;WAIT TIME ACTIVE?
	BEQ	10$		;NO
	CMP	DDBUFC+FP(R1),DDBUFC+EP(R1) ;OUTPUT STILL RUNNING?
	BNE	10$		;YES, DON'T TIMEOUT YET
	DEC	(R5)		;ELSE IS TIME EXPIRED?                  
	BNE	10$		;NOT YET
	MOVB	DDJBNO(R1),R4	;GET OWNING JOB NUMBER TIMES 2
	BIC	#^C<63.*2>,R4	;ENSURE NO DEATH IF DISABLED
	BIT	JBWAIT(R4),JBSTAT(R4) ;JOB RUNNABLE NOW?
	BNE	10$		;YES, SO FORGET THE TIMEOUT
	BIT	JBWAIT(R4),#JS.KB ;IS JOB WAITING FOR TERMINAL INPUT?
	BEQ	10$		;NO, SO FORGET THE TIMEOUT ALSO         
	MOV	JOBTBL(R4),R3	;ELSE GET THE JOB'S JOB DATA BLOCK
	BEQ	10$		;NOT A JOB, FORGET THE TIMEOUT
	MOV	JDWORK(R3),R4	;R4 -> XRB
	MOVB	XRCI(R4),R4	;R4 = CH # * 2
	BIC	#^C<36>,R4	;ENSURE LEGALITY
	MAP	FIPPOL		;Map FIP pool for the IOB		;004
	ADD	(R3),R4		;Point to DDB/WCB pointer for channel	;004
.ASSUME	JDIOB	EQ 0
	MOV	(R4),R4		;Now pick up DDB/WCB address		;004
	MAP	@#KISAR5,APR=5,DATA ;Restore our data mapping		;004
	CMP	R4,R1		;Waiting for this terminal?		;004
	BNE	10$		;NO; SO FORGET THE TIMEOUT
	BIS	#JFGO,JDFLG(R3)	;SAY WE ARE CANCELING THE I/O RE-DO,
	SETERR	HNGTTY,JDIOST(R3) ; AND SET THE WAIT TIMEOUT ERROR CODE 
	CALLX	IOFINI,R5,JS.KB	;AWAKEN THE JOB NOW
	TST	(PC)+		;C=0 => CLEAR FUNNY MODE(S) [SKIP THE 'SEC']
10$:	SEC			;C=1 => JUST CHECK FOR HUNG
	CALL	DOCALL		;GO DO THE MAPPED CALLING

;+
; CONDITIONS ON CALL:                                                   
;
;	R0 =  KB NUMBER TIMES 2
;	R1 -> DDB
;
;	IF C=0 THEN CLEAR FUNNY MODE(S)
;	IF C=1 THEN JUST CHECK FOR HUNG TERMINAL
;                                                                       
;	...
;
;	RETURN
;-

	MOV	(SP)+,R5	;RESTORE TABLE POINTER
20$:	CMP	R5,#TIM.KB	;MORE?					;006
	BHI	TIMKB		;YES, LOOP
	.BR	TIMDSK		;DO DISK TIMEOUTS NEXT

GLOBAL	<DDO.XX,JBWAIT,JBSTAT,JOBTBL,TIM.KB>

; DISK TIMEOUTS

TIMDSK:	SPLC	5		;;LOCKOUT DISK INTERRUPTS
	TST	-(R5)		;;TIMEOUT ACTIVE?
	BPL	10$		;;NO
	INCB	1(R5)		;;YES, EXPIRED NOW?
	BMI	10$		;;NOT YET
	INCB	1(R5)		;;JUST EXPIRED, SET A +1 FOR TIMEOUT
	MOV	R5,-(SP)	;;SAVE THE TABLE POINTER
	SUB	#DSS$XX,R5	;;NOW FIND THE FIP UNIT NUMBER
	MOV	R5,R0		;;COPY FIP UNIT NUMBER AND
	ADD	#DQS$XX,R0	;; RE-INDEX TO THE QUEUE ROOT
	MOV	DSKMAP(R5),R5	;;ALSO GET THE DISK INDEX
	MOV	DSKCSR(R5),R3	;;GET THE CORRECT CSR FOR DRIVER
	MOV	DSKPTR(R5),R5	;;GET POINTER TO D?DINT @ DQS$OO
	MOV	(R0),R4		;;FETCH TOP-OF-QUEUE DSQ
	MOV	#140000,R1	;;SET FAKE HARD ERROR STATUS
	CLR	R2		;; BUT NO OTHER ERROR(S)
	;CLC ! SEZ		;;ENSURE C=0 AND Z=1 (FROM 'CLR')
	CALL	CALDSK		;;NOW CALL THE DISK DRIVER

;+
; CONDITIONS ON CALL:
;
;	R0 -> QUEUE ROOT
;	R1 =  140000
;	R2 =  0
;	R3 -> CSR
;	R4 -> DSQ
;	TIMEOUT TIMER = +1
;	Z-BIT = 1, C-BIT = 0
;	PRIORITY IS PR5
;
;	...
;
;	RETURN
;-

	MOV	(SP)+,R5	;;RESTORE THE TABLE POINTER
10$:	SPLC	3		;;ALLOW INTERRUPTS NOW
	CMP	R5,#TIMTBL	;MORE?
	BHI	TIMDSK		;YES, LOOP
	.BR	TIMSLP		;DO JOB SLEEP TIME TIMEOUTS NEXT

GLOBAL	<DSS$XX,DQS$XX,DSKMAP,DSKCSR,DSKPTR,TIMTBL>

; JOB SLEEP TIME TIMEOUTS

TIMSLP:	MOV	#JOBTBL+2,R3	;Start off with job #1			;003
10$:	MOV	(R3)+,R5	;Is there a job here?			;003
	BEQ	10$		;No, not this time			;003
	CMP	R5,#-1		;Maybe, or are we done?			;003
	BEQ	20$		;We're done				;003
	MOV	R3,R0		;Copy JOBTBL offset			;003
	SUB	#JOBTBL+2,R0	;Now get job # * 2			;003
	CALLX	MAPJCR		;And map the JCR entry for the job	;003
	TST	JCCLOK(R1)	;Is this job ticking?			;003
	BEQ	10$		;No, not this time			;003
	DEC	JCCLOK(R1)	;Yes, ticking away, say one more second	;003
	BNE	10$		;More to do... try the next job		;003
	MOV	R0,R4		;Done, copy job # * 2			;003
	CALLX	IOFIN4,R5,JSTIM	;Wake this job up			;003
	BR	10$		;And loop				;003

; Call DECnet timer service

20$:	CALL	@NETTMO		;Tell DECnet a second went by		;005

; Call LAT timer service

	TST	LATAP5		;**temporary** Is LAT present?		;007
	BMI	30$		;No, not this time			;007
	CALLMI	LATTMO,LATAP5	;Yes, call LAT timer service		;007
30$:
; CHECK UNIBUS PARITY/ECC CSR'S ONCE A SECOND

	CALL	@PARSCN		;CHECK FOR PARITY/ECC ERROR(S)

; ALL DONE, WE CAN EXIT...

	JMPX	RTI3		;ALL DONE

; DOCALL - DO A NON-STANDARD MAPPED CALL.
;
;	R1 -> DDB
;
;	CALL	DOCALL

DOCALL:	MAP	PUSH,APR=5,CODE,DATA ;SAVE CURRENT PAR5 VALUE
	MOVB	(R1),R2		;GET DRIVER INDEX FROM DDB
	MOV	$TMOTBL(R2),-(SP) ;SET THE TIMEOUT SUBROUTINE ADDRESS
	MOV	@DVRAP5(R2),-(SP) ;SET PAR5 VALUE FOR THE DRIVER
	JMPX	CALLMX		;GO OFF AND REALLY DO THE MAPPED CALL

; CALDSK - MAP TO CORRECT DISK DRIVER AND GO TO IT
;
;	R5 -> D?DINT @ DQS$OO
;
;	CALL	CALDSK

CALDSK:	MAP	PUSH,APR=5,CODE,DATA	; SAVE CURRENT PAR5 VALUE
	MOV	TMO$OO-DQS$OO(R5),-(SP)	; TIME OUT ENTRY ADDR TO STACK
	MOV	@AP5$OO-DQS$OO(R5),-(SP); APR5 VALUE TO STACK
	JMP	@#CALLMX		; MAP AND GO TO ROUTINE

GLOBAL	<PARSCN,$TMOTBL,DVRAP5,NETTMO>					;005

.END

