	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
	.INCLUDE /DSK:DBDEF/
	.INCLUDE /DSK:MIDDEF/
TITLE	DBDSK,<RH11/RP04/05/06/07 DISK DRIVER>,0A,10-MAY-91,RH/MHB/RL/GW/WRM/CH/RVR/TWH/VAM

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR DBDSK
;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-08
;  001	TWH  28-OCT-83	ADD SUPPORT FOR IFUN
;  002	FEK  18-May-84	Fix IFUN support
;  003  VAM  23-Feb-85	Add non-existant device support to IFUN.  Also, fix
;			MCPE problem when selecting dual-ported drives.
;  004  VAM  02-Apr-85	Don't log Write Check miscompares as hard errors
;  005  VAM  30-May-85	Add RELFUN.
;
;			[RSTS V9.3]
;  006  VAM  19-Nov-86	Count uncorrectable ECC errors in UNTERR.
;
;			[RSTS V9.6]
;  007	KCG  29-Feb-88	Add FMTFUN.
;
;-

	DEFORG	DBDSK

	INCLUDE	<RHDDSK,OPTDSK,ECCDSK,ERLDSK>

	DSKDEF	DB

.SBTTL	ERROR LOGGING

	ERRENT	LOG$DB

	CALLX	ERLDSK,R5	;;;USE COMMON ROUTINE
	  .BYTE	ERC$DB		;;;ERROR CODE
	  .BYTE	0		;;;NON-OVERLAPPED SEEK
	  .BYTE	RHCS1,9.	;;;OFFSET, 9. REGISTERS
	  .BYTE	RHMR,10.	;;;OFFSET, 10. REGISTERS
	  .BYTE	0,0		;;;THAT'S ALL
	MOVB	@DSQPTO(R4),(R0) ;;;SET OFFSET INFORMATION
	TSTB	DSQFUN(R4)	;;;REALLY AN RP04/5/6?
	BPL	10$		;;;YES
	DECB	(R5)		;;;NO, REALLY AN RM02/3/05/80/RP07
.ASSUME	ERC$DR	EQ ERC$DB-1	;;;MAKE SURE THIS IS LEGAL
10$:	RETURN			;;;BACK TO ERROR LOGGER

;	ORDER FOR THE FOLLOWING IS IMPORTANT -- DO NOT CHANGE!

.SBTTL	CYLINDER & TRACK SIZES FOR DISKS HANDLED BY THIS DRIVER

MSZTBL:	MASSIZ	<RP04,RP05,RP06,RM02,RM03,RM80,RM05,RP07>

.SBTTL	MASSBUS ID TABLE FOR DISKS HANDLED BY THIS DRIVER

MIDTBL:	MASSID	<RP04,RP05,RP06,RM02,RM03,RM80,RM05,RP07>

.SBTTL	DISK SIZES IN DCN'S FOR DISKS HANDLED BY THIS DRIVER		;001

DBDCN:	.WORD	42949.,	42949.,	42583.,	0	;RP04,RP05,RP06,?	;001
	.WORD	32912.,	32912.,	60643.,	62544.	;RM02,RM03,RM80,RM05	;001

.SBTTL	DISK DCS'S FOR DISKS HANDLED BY THIS DRIVER			;001

DBDCS:	.WORD	4.,	4.,	8.,	0	;RP04,RP05,RP06,?	;001
	.WORD	4.,	4.,	4.,	8.	;RM02,RM03,RM80,RM05	;001

.SBTTL	FORM THE PHYSICAL ADDRESS AND SET UP DSQ

;+
; QDS$DB - CALCULATE DISK DEPENDENT PHYSICAL ADDRESS
;	   FROM LBN AND SET UP DSQ FOR TRANSFER.
;
;	CALL:	R0 =  LSB OF STARTING LBN OF TRANSFER
;		R1 =  MSB OF STARTING LBN OF TRANSFER
;		R2 =  DEVICE DRIVER INDEX
;		R3 =  PHYSICAL UNIT # * 2
;		R4 => DSQ TO SET UP
;		R5 =  FIP UNIT # * 2
;		CALL	QDS$DB
;		
;	RETURN:	R0,R1,R3 RANDOM
;		DSQ SET UP WITH CORRECT DISK ADDRESSES FOR TRANSFER.
;		OPTIMIZATION WORD (CYLINDER ADDRESS) WILL BE 177776
;		(-2) IF DISK TYPE WASN'T FOUND IN DISK SIZE TABLE.
;		THIS SHOULD CAUSE A FATAL ERROR WHEN THE TRANSFER IS
;		INITIATED.
;
;	DSQ @DSQFUN WILL CONTAIN A VALUE WHICH INDICATES THE DISK
;		TYPE, BASED ON THE ORDER OF THE MIDTBL ABOVE. THIS
;		VALUE IS USED TO DETERMINE DISK TYPE WITHOUT HAVING
;		TO SETUP THE DISK. CURRENTLY, ALL RP0?'S ARE POSITIVE,
;		ALL OTHERS ARE NEGATIVE (RP06 IS ALSO 0).
;
;		ORDER IS NORMALLY: RP04=2,  RP05=1,  RP06=0,  RM02=-1,
;				   RM03=-2, RM80=-3, RM05=-4, RP07=-5
;-
QDS$DB::NOP			;OPTIONALLY PATCHED TO BPT FOR DEBUGGING.
	CMPB	DSQSAV(R4),#IFUN;IS THIS A DRIVE INITIALIZE?		;001
	BEQ	30$		;YEP					;001
	CMPB	DSQSAV(R4),#RELFUN	;How about a Release?		;005
	BEQ	30$			;Yup.				;005
	CMPB	DSQSAV(R4),#FMTFUN	;Maybe a FORMAT?		;007
	BEQ	30$			;Yo				;007
	MOV	R1,-(SP)	;FREE UP R1
	MOV	R2,-(SP)	; AND R2
	MOVB	MID$XX(R5),R1	;GET A WORKING COPY OF THE DISK'S MASSBUS ID
	MOV	#MIDTBL,R2	;POINT TO THE TABLE OF MASSBUS ID'S
10$:	MOVB	(R2)+,R3	;GET ANOTHER MASSBUS ID FROM THE TABLE
	BEQ	20$		;END OF TABLE AND NO MATCH, SO EXIT
	CMPB	R3,R1		;DOES THE DISK MATCH THIS ENTRY?
	BNE	10$		;NOPE, SO TRY ANOTHER ID
	MOV	#MIDTBL+3,R3	;ID'S MATCHED, SO OFFSET TO FIRST NON-RP04 DSK
	SUB	R2,R3		;MAKE VALUE POSITIVE IF RP04 TYPE DSK (RP06=0)
	SUB	#MIDTBL+1,R2	;AND FIND OFFSET INTO TABLE FOR THIS DISK
	MOVB	R3,DSQFUN(R4)	;MAKE THE DISK CODE
	ASL	R2		;BUMP UP R2
	ASL	R2		; TO MAKE OFFSET INTO DISK SIZE TABLE
	MOV	#MSZTBL,R3	;POINT TO DISK SIZE TABLE
	ADD	R2,R3		;NOW INDEX INTO IT
	MOV	(SP)+,R2	;GET BACK GOOD 'OL R2
	MOV	(SP)+,R1	; 'N R1 AS WELL
	DIV	(R3)+,R0	;DIVIDE FOR THE CYLINDER NUMBER
	MOV	R0,DSQOPT(R4)	;STORE THE ANSWER (CYL NUM)
	CLR	R0		;CLEAR HIGH ORDER FOR TRACK DIVIDE
	DIV	(R3),R0		;GET ANSWER=TRACK, REMAINDER=SECTOR
	SWAB	R0		;PUT TRACK INTO HIGH BYTE
	BIS	R1,R0		; AND PUT SECTOR INTO LOW BYTE
	MOV	R0,DSQPDA(R4)	;NOW STORE TRACK/SECTOR
	MOV	#ECOFTB-1,DSQPTO(R4) ;RESET TO NO OFFSETS INITIALLY
	BR	30$		;JUMP AROUND UNKNOWN-DISK HANDLING CODE

20$:	CLRB	DSQERR(R4)	;CLEAR THE RETRY COUNT
	MOV	#-2,DSQOPT(R4)	;FORCE AN IMPOSSIBLE CYLINDER,
	MOV	(SP)+,R2	;RESTORE THE REGS WE
	MOV	(SP)+,R1	; SAVED EARLIER

30$:	CALL	@(SP)+		;NOW CO-ROUTINE RETURN

.ENABL	LSB
.SBTTL	COMES HERE IF FIRST IN DRIVER'S QUEUE

	BR	DSKGDB		;;FIRST IN QUEUE, START TRANSFER

DSKGOP:	CALLX	OPTDSK,R5,OPT$DB ;;OPTIMIZE THE DISK QUEUE
DSKGDB:	CMPB	DSQSAV(R4),#IFUN;;IS THIS A DRIVE INITIALIZE?		;001
	BEQ	60$		;;YEP					;001
	CMPB	DSQSAV(R4),#RELFUN	;;How about a Release?		;005
	BEQ	55$			;;Yup.				;005
	CMPB	DSQSAV(R4),#FMTFUN	;;FORMAT command?		;007
	BEQ	54$			;;Yes, send back an error	;007
	CLRB	DSQFAR(R4)	;;NOW USE FAIRNESS COUNT FOR SKP SEC ERR FLG

.SBTTL	COMES HERE FOR SSE RETRIES

SSEGDB:	CLR	DSO$XX(R0)	;;SAY NOT AN OFFSET OPERATION
	CALL	SETUP		;;SET UP DRIVE AND SET ADDRESSES
	BNE	HARDNE		;;MASSBUS ID MISMATCH, FATAL
	BIT	(R1)+,#RHNED	;;IS DRIVE THERE AT ALL?
	BNE	HARDNE		;;NO, HARD ERROR
	MOV	(R1),R2		;;GET DRIVE'S STATUS
	COM	R2		;; AND COMPLEMENT THE BIT VALUES
	BIT	R2,#RHMOL!RHDPR!RBVV ;;CHECK STATUS
HARDNE:	BEQ	10$		;;ERROR NOT HARD
	JMP	HARDER		;;ERROR IS HARD ERROR
10$:	BIT	(R1),#RHATA!RHERR!RHPIP!RBPGM ;;CHECK FOR FUNNY CONDITIONS
	BNE	50$		;;WHOOPS!
	BIT	#RHTRE!RHMCPE,(R3) ;;IS "TRANSFER ERROR" ALREADY SET?
	BNE	50$		;;YES!
	TSTB	(R1)		;;IS THE DRIVE READY?
	BPL	50$		;;NO!
.ASSUME	RHDRY	EQ	200	;;BE SURE WE'RE TESTING THE RIGHT BIT
	TSTB	DSQFUN(R4)	;;RP04/05/06?
	BPL	20$		;;YEP, SO NO RM TYPE OFFSETS
	CMP	DSQPTO(R4),#ECOFTB ;;NEED TO SET OFFSET FOR RM02/3?
	BLOS	20$		;;NO, NOT INTO OFFSETS
	MOVB	#OFFSET,(R3)	;;YES, (PRE-)SET OFFSET MODE
20$:	CLR	DSO$XX(R0)	;;ASSUME THE FOLLOWING WILL SUCCEED
	CALLX	RHDADR		;;SET UP MAPPING IF NECESSARY
	BCC	30$		;;SUCCEEDED, GO START THE OPERATION
	INC	DSO$XX(R0)	;;MARK AS WAITING FOR I/O
	RETURN			;;AND QUIT

30$:	TSTB	DSQFAR(R4)	;;ARE WE HANDLING A SKIP SECTOR ERROR?
	BEQ	40$		;;NOPE, SO JUST START THE OPERATION AS USUAL
	BIS	#RMSSEI,RBOF(R3) ;;SKP SEC ERR, SO SET SSE INHIBIT
40$:	JMPX	RHDSRT		;;NOW START AN RH11 DISK DEVICE

50$:	MOV	#-3*400+377,DSO$XX(R0) ;;SET JUST WAITING TIMEOUT
	JMP	RETRY		;; AND CALL IT A RETRYABLE ERROR

54$:	SETERR	ERRERR,DSQERR(R4) ;;FMTFUN not Supported here		;007
55$:	BR	150$		;;Fix out-of-range branch.		;005

	.PAGE
	.SBTTL	IFUN Handler
;+
;
;	I F U N   R E Q U E S T   H A N D L E R				;003
;
; The IFUN (Initialize FUNction) is used to check for the presence of a
; given RM/RP drive, and to determine the drive type and fill in the
; UNTSIZ and DEVCLU table entries if it's there.
;
; Here are the steps taken for an IFUN request;
;
; 1)	Clear out the UNTSIZ entry for that drive
; 2)	Wait for the controller to become ready, and then do a subsystem reset.
; 3)	Select the drive in question.
; 4)	Check to see if it's there.  If not, we return '?Device not available'
;	in the DSQ, but we don't log a hard error.
; 5)	If the drive is there, but the port select switch is set to A/B, or
;	it's ported away from us, or it's not spun up, we return with
;	'?Device hung or write locked' in the DSQ, but again it's not a
;	hard error.
; 6)	If all goes well, we check for other errors.  If any are found, we log
;	a hard error and return '?Device hung or write locked'.
; 7)	If no errors, we set the UNTSIZ and DEVCLU entries for the drive,
;	based on the Massbus ID.
;
;-

60$:	MOVB	DSQUNT(R4),R1		;;Get FIP unit number.		;003
	ASL	R1			;;Make it an index.		;003
	CLR	UNTSIZ(R1)		;;Flag the unit size as unknown	;003
	MOV	#10,R1			;;Now, R1 is MCPE retry flag.	;003
65$:	TSTB	(R3)			;;Controller ready yet??	;003
	BPL	65$			;;Nope, wait for it.		;003
	MOV	#RHCLR,RHCS2(R3)	;;Do a subsystem reset.		;003
	MOVB	DSQPUN(R4),R2		;;Get the physical unit number.	;003
	MOV	R2,RHCS2(R3)		;;Select a drive.		;003
	MOVB	#RHESET,(R3)		;;Reset and sieze the drive.	;003
	BIT	#RHNED,RHCS2(R3)	;;Is it there at all??		;003
	BNE	180$			;;Nope.				;003
	BIT	#RBPGM,RHDS(R3)		;;Is it programmable??		;003
	BNE	190$			;;Yup, so we can't have it.	;003
	BIT	#RHDPR,RHDS(R3)		;;Can we get to it??		;003
	BEQ	190$			;;Nope.				;003
	BIT	#RHDVA,(R3)		;;Really can we??		;003
	BEQ	190$			;;I guess not.			;003
	BIT	#RHMOL,RHDS(R3)		;;Medium online??		;003
	BEQ	190$			;;Nope, but not a hard error.	;003
	BIT	#RHMCPE,(R3)		;;Massbus parity error?		;003
	BEQ	70$			;;No, everything is cool.	;003
	SOB	R1,65$			;;Otherwise, try it again...	;003
	BR	160$			;;Sorry, hard error time!!	;003

70$:	BIT	#40000,RHDS(R3)		;;Any errors set??		;003
	BNE	160$			;;Yup, hard error time.		;003
	MOV	RHDT(R3),R2		;;Get massbus ID.		;003
	MOV	R2,R1			;;COPY MASSBUS ID		;001
	BIC	#004000,R2		;;IGNORE DUAL PORT BIT		;001
	CMP	R2,#RP07ID		;;IS IT A RP07?			;001
	BNE	115$			;;NOPE				;001
	MOVB	DSQUNT(R4),R2		;;GET FUN			;002
	ASL	R2			;; TIMES TWO			;001
	MOV	R1,MID$XX(R2)		;;SET MID			;001
	MOV	#62996.,UNTSIZ(R2)	;;SET SIZE			;001
	MOVB	#16.,DEVCLU(R2)		;;AND DCS			;002
	BR	150$			;;DONE				;001

115$:	CMP	R2,#RM05ID	;;IS THIS ONE WE KNOW ABOUT?		;001
	BHI	160$		;;NOPE					;001
	SUB	#RP04ID,R2	;;GET IN RANGE				;001
	ASL	R2		;;MAKE IT A WORD INDEX			;001
	MOVB	DSQUNT(R4),R0	;;GET FUN				;002
	ASL	R0		;;TIMES TWO				;001
	MOV	R1,MID$XX(R0)	;;SAVE THE MASSBUS ID			;001
	MOV	#DBDCN,R1	;;POINT TO TABLE OF DCN			;001
	ADD	R2,R1		;;INDEX INTO IT				;001
	MOV	(R1),UNTSIZ(R0)	;;SET THE SIZE IN DC'S			;001
	BEQ	160$		;;ILLEGAL IF 0				;001
	MOV	#DBDCS,R1	;;POINT TO TABLE OF DCS			;001
	ADD	R2,R1		;;INDEX INTO IT				;001
	MOVB	(R1),DEVCLU(R0)	;;SET THE DCS				;002
150$:	MOV	#DQS$DB,R0	;;GET QUEUE ROOT			;001
	JMP	DBDONE		;;JOIN COMMON CODE			;001

160$:	CLZ			;;SAY HARD ERROR			;001
	LOG$DB			;;LOG AN ERROR				;001
	CALLX	DFINT1		;;CHECK CC'S AND COUNT ERROR		;001
	BR	150$		;;DONE					;001

180$:	MOVB	#NOTAVL,DSQERR(R4)	;;Tell 'em it's not there.	;003
	BR	150$			;;And go back.			;003

190$:	MOVB	#HNGDEV,DSQERR(R4)	;;Tell 'em it's hung		;003
	BR	150$			;; and join the mainstream.	;003

GLOBAL	<MID$XX,ECOFTB,CSR.DB,DQS$DB,OPT$DB,DSO$XX,UNTSIZ,DEVCLU>	;001
GLOBAL	<NOTAVL,HNGDEV,ERRERR>						;003

.DSABL	LSB

.SBTTL	INTERRUPTS (PR5)

.ENABL	LSB

INT$DB::MOV	CSR.DB,R3	;;GET CSR ADDRESS
	MOV	#DQS$DB,R0	;;GET THE QUEUE ROOT POINTER
	MOV	(R0),R4		;;GET TOP OF QUEUE REQUEST
	BEQ	DBRET		;;NONE, SO EXIT
	MOV	R4,R5		;;COPY DSQ POINTER AND
	ADD	#DSQPTO,R5	;; INDEX TO OFFSET POINTER
	TSTB	DSO$XX(R0)	;;WAS THIS AN OFFSET OR "RTC"?
	BEQ	50$		;;NO - DO ORDINARY CHECKING
	MOV	RHDS(R3),R2	;;GET THE DRIVE'S STATUS
	ASL	R2		;;SHIFT IT SO THAT
	ASL	R2		;; CARRY=RHER, SIGN=RHPIP
	BCS	30$		;;ERROR, SO RETRY
	BMI	20$		;;STILL MOVING, SO EXIT UNTIL LATER
	CMP	(R5),#ECOFTE	;;ARE WE AT THE END OF THE TABLE?
	BLO	40$		;;NOT YET - WE'RE STILL IN AN OFFSET SEQUENCE
	CLRB	DSQERR(R4)	;;FAKE A DATA ERROR BY ZAPPING THE RETRY COUNT
DBDONE:	CALLX	DFINT9		;;SAY IDLE, DE-QUEUE, AND HOUSEKEEP REQUEST
10$:	TST	(R0)		;;MORE IN QUEUE?
	BEQ	DBRET		;;NOPE					;001
	JMP	DSKGOP		;;YES, SO CONTINUE			;001
DBRET:	RETURN			;;NO, SO EXIT FROM INTERRUPT

20$:	MOV	#IE,R1		;;GET INTERRUPT ENABLE BIT
	BEQ	DBRET		;;NONE, JUST EXIT
	MOVB	R1,(R3)		;;ONE, RE-INTERRUPT ENABLE CONTROL
	BR	DBRET		;; AND EXIT

UMR$DB::TST	DSO$XX(R0)	;;ARE WE IDLE?
	BGE	10$		;;YES, CONTINUE OPERATIONS
	RETURN			;;NO, NOT INTERESTED

30$:	JMP	RETRY		;;GO COUNT THE ERROR AND RETRY THE OPERATION
40$:	JMP	GOREDO		;;HANDLE AN OFFSET SEQUENCE

GLOBAL	<CSR.DB,DQS$DB,DSO$XX,ECOFTE,IE,DATERR>				;004

50$:	CALL	@RELUMR		;;RELEASE ANY WINDOWS WE'RE HOLDING
	BIT	#RBHCE!RBHCRC,RHER(R3) ;IS HEADER OK ENOUGH TO TELL US SSE?
	BNE	80$		;HARDLY...

; RM80 SPECIFIC CODE. FOR SKIP SECTORS, WE MODIFY THE DSQ TO RESUME TRANSFER
; FROM SECTOR THAT CAUSED ERROR. ALL PARAMETERS ARE CHANGED EXCEPT FOR THE
; STARTING FBN -- THIS IS KEPT INTACT FOR ERROR LOGGING REASONS...

	BIT	#RMSSE,RMER2(R3) ;DID WE GET A SKIP-SECTOR ERROR?
	BEQ	80$		;NO, SO CHECK EVERYTHING ELSE

.SBTTL	REDO TRANSFER IF SKIP SECTOR ERROR

	DECB	DSQFAR(R4)	;SSE FLAG -- HAVE WE HANDLED 64 SSE'S YET?
	BMI	55$		;NOPE, NO SWEAT.
	MOVB	#-1,DSQFAR(R4)	;YES, SO RESET SSE HANDLER COUNT (SORRY!)
55$:	MOV	R0,-(SP)	;WE'LL NEED R0 AND
	MOV	R1,-(SP)	; R1 FOR SCRATCH

; ONE COMPLETE CYL ON RM80 HOLDS MORE THAN 65535 WORDS, SO IF TRK-SEC VALUE
;  IS LESS THAN AT START OF XFER, WE HAVE CROSSED A CYLINDER BOUNDARY...

	MOV	RBDA(R3),R0	;GET WORKING COPY OF TRK-SEC VALUE, AND SET IT
	DEC	R0		; TO PRE-SSE VALUE (SECTR ALWAYS INC'D ON SSE)
	CMP	R0,DSQPDA(R4)	;DID CYL CHANGE SINCE THE XFER STARTED?
	BMI	60$		;YEP, RESET OFFSETS
	DEC	DSQOPT(R4)	;NO, BUT WE'LL INCR IT LATER, SO DECR IT NOW
	CMPB	RBDA+1(R3),DSQPDA+1(R4) ;SAME CYL, BUT DIFFERENT TRACK?
	BEQ	70$		;NOPE, OFFSET STILL OK
60$:	MOV	#ECOFTB-1,DSQPTO(R4)	;TRK OR CYL IS NEW, SO NO OFFSET YET
	CLRB	DSQCTO(R4)	;AND NO OFFSET RETRY COUNT, EITHER
70$:	MOV	R0,DSQPDA(R4)	;XFER RE-STARTS AT BAD TRACK AND SECTOR
				; (DSQ SHOWS LOGICAL, NOT PHYSICAL, SECTOR)
	INC	DSQOPT(R4)	;CORRECT FOR POSSIBLE CYLINDER CHANGE
	MOV	RHWC(R3),R1	;GET COPY OF (-)REMAINING WORDS TO XFER
	SUB	DSQCNT(R4),R1	;ESTIMATE (-)# WORDS XFER'D
	BIC	#377,R1		;ROUND DOWN TO LOWEST BLOCK MULTIPLE
	ADD	R1,DSQCNT(R4)	;AND MAKE THE NEW (-)WORD COUNT
	ASL	R1		;CHANGE WORD COUNT TO BYTE ADDRESSES, AND
	ADD	R1,DSQMAL(R4)	; UPDATE MEMORY ADDRESS FOR NEW XFER
	ADCB	DSQMAM(R4)	;  SO THAT XFER STARTS FROM RIGHT PLACE
	MOV	(SP)+,R1	;GET R1 BACK
	MOV	(SP)+,R0	;GET R0 BACK
	JMP	SSEGDB		;GO SET UP DISK DRIVE AND RESUME XFER
; ...TO HERE. 

80$:	BIT	RHDS(R3),#RHERR	;;ANY ERROR ?
	BNE	90$		;;FOR SURE
	BIT	(R3),#RHTRE!RHMCPE ;;XFER OR CONTROL PARITY ERROR?
	BEQ	DBDONE		;;ALL O.K., SO ALL DONE
90$:	BIT	RHCS2(R3),#RHNED!RHNEM ;;CONTROLLER HARD ERROR?
	BNE	HARDER		;;YES, SO CALL IT HARD
	MOV	RHER(R3),R2	;;GET ERROR REGISTER
	TSTB	DSQFUN(R4)	;;RM02/3/RP07?
	BPL	110$		;;NOPE, RP04/5/6
	TST	RMER2(R3)	;;YEP, BAD SECTOR ERROR?
	BPL	100$		;;NOT A BAD SECTOR
.ASSUME	RMBSE	EQ	100000	;;MAKE SURE WE'RE TESTING THE RIGHT BIT
	MOVB	#-1,DSQERR(R4)	;;A BAD SECTOR, FORCE NO MORE RETRIES
	BIS	#RHUNS,R2	;; AND FORCE A RETRY BELOW...
100$:	BIT	#RMIVC!RMLSC!RMLBC,RMER2(R3) ;;HARD ERROR?
	BNE	HARDER		;;YES, LOG IT AND QUIT
110$:	BIT	R2,#RBWLE!RBIAE!RBAO!RHRMR!RHILR!RHILF ;;HARD TYPE ERROR?
	BNE	HARDER		;;YES, SO CALL IT HARD
	BIT	#RHWCK,RHCS2(R3)	;;Write check error??		;004
	BEQ	115$			;;Nope, so go on.		;004
	MOVB	#DATERR,DSQERR(R4)	;;Otherwise, put the error away	;004
	BR	140$			;; and go back.			;004

115$:	TSTB	RHCS2+1(R3)	;;RECOVERY TYPE ERROR?
	BNE	RETRY		;;YES, SO JUST RETRY THE OPERATION
	TSTB	DSQFUN(R4)	;;RM02/3/5/80/RP07?
	BPL	120$		;;NOPE
	BIT	#RMSKI,RMER2(R3) ;;YEP, SEE IF SEEK INCOMPLETE ERROR
	BEQ	130$		;;CONTINUE IF NOT SEEK INCOMPLETE
	MOVB	#2,DSO$XX(R0)	;;A SEEK INCOMPLETE, INDICATE RECAL NEEDED
	BR	RETRY		;;COUNT THE ERROR AND GO RETRY

120$:	MOV	RBER2(R3),-(SP)	;;GET ERROR REGISTER #2 AND
	BIS	RBER3(R3),(SP)+	;; ERROR REGISTER #3 .OR.ED TOGETHER
	BNE	RETRY		;;JUST RETRY IF ANY BIT(S) ON
130$:	BIT	R2,#^C<RBDCK!RBDTE!RBHCRC!RBHCE!RBECH> ;;ANY OTHER ERROR BITS?
	BNE	RETRY		;;YES, RETRY
	TST	R2		;;FANCY TYPE RECOVERY POSSIBLE?
	BNE	DOECC		;;YES, SO DO IT
TMO$DB::TSTB	DSO$XX(R0)	;;TIMEOUT. IS IT SPECIAL "JUST WAITING"?
	BMI	CKREDO		;;YES, JUST CONTINUE
RETRY:	SEZ			;;INDICATE RETRY (NON-HARD) ERROR
HARDER:	LOG$DB			;;LOG AN ERROR HERE
	CALLX	DFINT4		;;CHECK CC'S AND COUNT ERROR
	BPL	140$		;;BRANCH IF NO RETRIES LEFT
	;CLRB	DSQFAR(R4)	;;SSE'S HAVE TO START ALL OVER AGAIN
	TSTB	DSO$XX(R0)	;;WHAT IS THE CURRENT DRIVE STATUS?
	BMI	150$		;;"JUST WAITING", SO JUST WAIT
	BNE	TRYOFF		;;RETRY THE OFFSET COMMAND
CKREDO:	MOV	#ECOFTB-1,DSQPTO(R4) ;;RESET TO NO OFFSETS HERE
GOREDO:	TST	DSQCNT(R4)	;;IS THERE A REMAINING WORD COUNT?
	BPL	140$		;;NO, SO ALL DONE
	JMP	DSKGDB		;;YES, SO TRY SOME MORE I/O

140$:	JMP	DBDONE		;;DO COMPLETION FOR THE REQUEST
150$:	JMP	DBRET		;;JUST EXIT FROM THE INTERRUPT

.DSABL	LSB

GLOBAL	<DSO$XX,ECOFTB,RELUMR>

.SBTTL	SOFT ECC CORRECTION / HARD ECC DETECTION

.ENABL	LSB

DOECC:	MOV	RBEC1(R3),R1	;;GET THE ECC CORRECTION POSITION
	MOV	RBEC2(R3),R5	;;GET THE ECC CORRECTION PATTERN
	LOG$DB			;;LOG THIS TYPE OF ERROR
	;CMPB	DSQFUN(R4),#-5	;;OUT OF RANGE?
	;BPL	30$		;;YES
	;CMPB	DSQFUN(R4),#2	;;OUT OF RANGE?
	;BMI	30$		;;YES
	MOV	R5,-(SP)	;;SAVE R5 (FROM OLD "CALLX ECCDSK,R5")
	MOVB	DSQFUN(R4),R5	;;GET DRIVE CODE BYTE IN R5 (RP06 SHOULD = 0)
	ASL	R5		;;TIMES TWO FOR WORD ADDRESSING
	MOV	ECCPRM(R5),R5	;;R5 POINTS TO ECC VALUES FOR SELECTED DRIVE
	JMPX	ECCDSK		;;DO ECC HANDLING

	;ECC PARAMETER BLOCK POINTERS -- ORDER EXACTLY OPPOSITE OF "MIDTBL"!

	.WORD	RP07ECC		;POINTER TO ECC PARAMETERS FOR RP07
	.WORD	RM05ECC		;POINTER TO ECC PARAMETERS FOR RM05
	.WORD	RM80ECC		;POINTER TO ECC PARAMETERS FOR RM80
	.WORD	RM03ECC		;POINTER TO ECC PARAMETERS FOR RM03
	.WORD	RM02ECC		;POINTER TO ECC PARAMETERS FOR RP02
ECCPRM:	.WORD	RP06ECC		;POINTER TO ECC PARAMETERS FOR RP06 (RP06=0)
	.WORD	RP05ECC		;POINTER TO ECC PARAMETERS FOR RP05
	.WORD	RP04ECC		;POINTER TO ECC PARAMETERS FOR RP04


RP04ECC:
RP05ECC:
RP06ECC:			; ERROR CORRECTION PARAMETERS FOR RP04/05/06
	  .WORD	RBDTE!RBECH	; BACK UP 1 SECTOR ON THESE
	  .WORD	22.-400		; # SECTORS -400
	  .WORD	19.*400		; # TRACKS *400
	  .WORD	^C<RBDCK>	; NO ECC IF ANY BUT THIS
	  .WORD	CKREDO		; CHECK FOR MORE I/O IF ECC DONE
	BR	ECCOFF		;;Decrement retry count and do		;006
				;; offsetting if ECC not done.		;006

RM02ECC:
RM03ECC:			; ERROR CORRECTION PARAMETERS FOR RM02/03
	  .WORD	RBDTE!RBECH	; BACK UP 1 SECTOR ON THESE
	  .WORD	32.-400		; # SECTORS -400
	  .WORD	5.*400		; # TRACKS *400
	  .WORD	^C<RBDCK>	; NO ECC IF ANY BUT THIS
	  .WORD	CKREDO		; CHECK FOR MORE I/O IF ECC DONE
	BR	ECCOFF		;;Decrement retry count and do		;006
				;; offsetting if ECC not done.		;006

RM80ECC:			; ERROR CORRECTION PARAMETERS FOR RM80
	  .WORD	RBDTE!RBECH	; BACK UP ONE SECTOR ON THESE
	  .WORD	31.-400		; # SECTORS -400
	  .WORD	14.*400		; #TRACKS *400
	  .WORD	^C<RBDCK>	; NO ECC IF ANY BUT THIS
	  .WORD	CKREDO		; CHECK FOR MORE I/O IF ECC DONE
	BR	ECCOFF		;;Decrement retry count and do		;006
				;; offsetting if ECC not done.		;006



RM05ECC:			; ERROR CORRECTION PARAMETERS FOR RM05
	  .WORD	RBDTE!RBECH	; BACK UP ONE SECTOR ON THESE
	  .WORD	32.-400		; # SECTORS -400
	  .WORD	19.*400		; #TRACKS *400
	  .WORD	^C<RBDCK>	; NO ECC IF ANY BUT THIS
	  .WORD	CKREDO		; CHECK FOR MORE I/O IF ECC DONE
	BR	ECCOFF		;;Decrement retry count and do		;006
				;; offsetting if ECC not done.		;006

RP07ECC:			; ERROR CORRECTION PARAMETERS FOR RP07
	  .WORD	RBDTE!RBECH	; BACK UP ONE SECTOR ON THESE
	  .WORD	50.-400		; # SECTORS -400
	  .WORD	32.*400		; #TRACKS *400
	  .WORD	^C<RBDCK>	; NO ECC IF ANY BUT THIS
	  .WORD	CKREDO		; CHECK FOR MORE I/O IF ECC DONE
	.BR	ECCOFF		;;Decrement retry count and do		;006
				;; offsetting if ECC not done.		;006


ECCOFF:	PUSH	<R1>		;;Save R1 'cause DFINT3 creams it.	;006
	CALLX	DFINT3		;;Update UNTERR and dec retry count.	;006
	POP	<R1>		;;Restore original R1.			;006
30$:	MOV	R4,R5		;;(RE-)BUILD POINTER
	ADD	#DSQPTO,R5	;; TO OFFSET INFORMATION
	TST	R1		;;IF R1 = 0 WE READ 0 GOOD SECTORS
	BEQ	40$		;;SO CONTINUE AT THE CURRENT OFFSET (IF ANY)
RSTOFF:	MOV	#ECOFTB-1,(R5)	;;IF WE READ SOME GOOD DATA THEN THIS
				;; IS THE FIRST TIME, SO RESET OFFSETS
40$:	CMP	(R5)+,#ECOFTB	;;HAVE WE RETRIED THIS OP ALREADY?
	BLO	50$		;;NOPE - FIRST TIME, GO TO A NEW OFFSET (OF 0)
	DECB	(R5)		;;ANOTHER RETRY AT THIS OFFSET?
	BGT	GOREDO		;;NO - REDO THE READ OPERATION AT THIS OFFSET
50$:	MOVB	#16.,(R5)	;;ASSUME NEW OFFSET WILL BE 0 WITH 16 RETRIES
	INC	-(R5)		;;BUMP DSQPTO TO NEW OFFSET BYTE
	.BR	TRYOFF		;;NOW GO DO THE OFFSETTING

.DSABL	LSB

GLOBAL	<ECOFTB>

.SBTTL	DO OFFSETTING

TRYOFF:	ASRB	DSO$XX(R0)	;;A FORCED RECALIBRATE? (CODE=2)
	BNE	RSTOFF		;;YES, INITIALIZE POINTER AND COUNT
	CLRB	DSQFAR(R4)	;;SKIP SECTOR ERRORS HAVE TO START OVER...
	CALL	SETUP		;;SET UP DRIVE AND ADDRESSES
	;BNE	?		;;MASSBUS ID MISMATCH
	MOV	(PC)+,R1	;;SET POSSIBLE FUNCTIONS (L=RECAL, H=OFFSET)
	 .BYTE	IE+RECAL,IE+OFFSET
	TSTB	@(R5)+		;;WHAT OFFSET VALUE DID WE JUST SET?
	BEQ	20$		;;0 IS ILLEGAL OFFSET - DO RECAL INSTEAD.
	MOVB	#2,(R5)		;;OFFSETS OTHER THAN 0 ARE LEGAL - CHANGE THE
	SWAB	R1		;; RETRY COUNT TO 2 AND FUNCTION TO OFFSET
	TSTB	DSQFUN(R4)	;;RM02/3/5/80/RP07?
	BPL	20$		;;NOPE, RP04/5/6
	CMP	-(R5),#ECOFTB+1	;;YEP, INTO REAL OFFSETTING NOW??
	BNE	10$		;;NOPE, NOT YET
	ADD	#4,(R5)		;;YES, ONLY + OR - ONCE FOR RM02/3
	CMPB	#-5,DSQFUN(R4)	;;RP07?
	BEQ	9$		;;YES INDEED
	CMPB	#-3,DSQFUN(R4)	;;RM80?
	BNE	10$		;;NOPE
9$:	MOV	#ECOFTE,(R5)	;;RP07 AND RM80 HAVE NO OFFSETS AT ALL
10$:	MOV	#INT$DB,-(SP)	;;RM02/3/5/80 BECOMES READY AGAIN IMMEDIATELY
20$:	MOV	#-5*400+1,DSO$XX(R0) ;;SET TIMEOUT AND DOING OFFSET
	MOVB	R1,(R3)		;;SET FUNCTION BYTE IN RHCS1
	RETURN			;;RETURN FROM INTERRUPT

GLOBAL	<DSO$XX,IE,ECOFTB,ECOFTE>

.SBTTL	SET UP DRIVE, ADDRESSES, AND OFFSET

;+
; SETUP - SET UP DRIVE, ADDRESSES, AND OFFSET.
;
;	R3 -> RHCS1 (CSR)
;	R4 -> DSQ
;
;	CALL	SETUP
;
;	R1 -> RHCS2
;	R2 =  FIP UNIT NUMBER TIMES 2
;
;	IF Z=1 THEN SET UP
;	IF Z=0 THEN MASSBUS ID MISMATCH
;-

SETUP:	CALLX	RHDSEL		;;SELECT AN RH11 DISK
	BNE	30$		;;MASSBUS ID MISMATCH, EXIT Z=0
	BIT	#UC.MNT!UC.NFS,UNTCNT(R2) ;;IS DISK NOT MOUNTED OR NFS?
	BEQ	10$		;;NO, NO NEED FOR PACK ACK THEN
	MOVB	#PAKACK,(R3)	;;"PACK ACKNOWLEGE" THE DRIVE
10$:	MOV	DSQOPT(R4),RBDC(R3) ;;SET THE DESIRED CYLINDER
	MOV	#FMT22,-(SP)	;;SET PDP-11 MODE, ECC ENABLE, SSE ENABLE
.ASSUME	FMT16	EQ	FMT22	;;PDP-11 MODE MUST BE SAME ON RM03/RP04
	BISB	@DSQPTO(R4),(SP) ;;.OR. IN THE CURRENT OFFSET VALUE
	BICB	#^C<260>,(SP)	;; TRIMMING IT TO ONLY LEGAL BITS
	CMPB	MID$XX(R2),#RP06ID ;;IS THIS AN RP06??
	BNE	20$		;;NOPE, ALL SET
	ASRB	(SP)		;;YEP, OFFSET=(OFFSET/2) FOR RP06'S
	BICB	#^C<230>,(SP)	;; AND RE-TRIM TO ONLY LEGAL BITS
20$:	MOV	(SP)+,RBOF(R3)	;;SET THE MODE AND OFFSET VALUE
	TSTB	DSQFAR(R4)	;;ARE WE IN A SSE RETRY SEQUENCE?
	BMI	25$		;;YEP, SO TRACK/SECTOR ARE ALREADY SET UP
	MOV	DSQPDA(R4),RBDA(R3) ;;SET DESIRED TRACK/SECTOR
25$:	SEZ			;;SET UP, EXIT Z=1
30$:	RETURN			;;NOW EXIT

GLOBAL	<UNTCNT,MID$XX>

.END
