	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
TITLE	ECCDSK,<COMMON DISK ECC SUBROUTINE>,0A,10-MAY-91,MHB/SJM/AWL/MND/DBM

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR ECCDSK
;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;  001	SJM  08-JUL-81	ADD SUPPORT FOR I&D SPACE
;
;				[RSTS V8.0]
;  002  AWL  31-Jan-83  Don't do ECC correction for multi-bit errrors
;  003  MND  24-Mar-83  Fix 002 to do check after DSQ update of good sectors
;  004	DBM  20-Nov-84	Multi-bit ECC errors need to back up one sector
;
;-

	DEFORG	ECCDSK

.SBTTL	COMMON DISK ECC SUBROUTINE

;+
; ECCDSK - COMMON DISK ECC SUBROUTINE.
;
;	R0 -> QUEUE ROOT
;	R1 =  ECC ERROR POSITION
;	R2 =  ERROR BITS
;	R3 -> CSR
;		RHWC(R3) = REMAINING -(WORD COUNT)
;	R4 -> DSQ
;		DSQMAM = INITIAL HIGH PHYSICAL ADDRESS
;		DSQMAL = INITIAL LOW PHYSICAL ADDRESS
;		DSQCNT = INITIAL -(WORD COUNT)
;		DSQPDA = INITIAL TRACK(HIGH BYTE)/SECTOR(LOW BYTE)
;		DSQOPT = INITIAL CYLINDER
;	R5 =  ECC ERROR CORRECTION PATTERN
;
;	CALL	ECCDSK,R5
;	 .WORD	ERROR BITS THAT IMPLY BACK UP ONE SECTOR
;	 .WORD	NUMBER OF SECTORS PER TRACK -400
;	 .WORD	NUMBER OF TRACKS PER CYLINDER *400
;	 .WORD	ERROR BITS THAT IMPLY ECC CORRECTION NOT ALLOWED
;	 .WORD	TRANSFER ADDRESS IF ECC WAS PERFORMED
;	...	;RETURN IF ECC NOT DONE
;
;	R1 =  NUMBER OF GOOD SECTORS TRANSFERRED
;-

.DSECT	DSQMAM		;VERIFY ORDERING IN DSQ

DSQMAM:	.BLKB		;BUS ADDRESS <21-16>
DSQMAL:	.BLKW		;BUS ADDRESS <15-0>
DSQCNT:	.BLKW		;-(WORD COUNT)

	UNORG

ECCDSK:	REGSCR			;;SAVE ALL REGISTERS
	MOV	TOS.RA(SP),TOS.R5(SP) ;;RE-SAVE THE ECC CORRECTION PATTERN
	MOV	R5,TOS.RA(SP)	;;SET THE RETURN ADDRESS
	ADD	#5*2,TOS.RA(SP)	;; FOR ECC NOT DONE (I.E., SKIP 5 ARGS)
	MOV	R1,-(SP)	;;SAVE THE ECC CORRECTION POSITION
	CLR	TOS.R1+2(SP)	;;GUESS AT NO GOOD SECTORS TRANSFERRED
	MOV	RHWC(R3),R1	;;GET REMAINING WORD COUNT OF TRANSFER
	BNE	10$		;;A REMAINING COUNT EXISTS
	COMB	R1		;;ELSE DUMMY UP FOR A FULL TRANSFER
10$:	ADD	#DSQCNT,R4	;;INDEX IN DSQ TO: MAM(B), MAL(W), CNT(W)
	SUB	(R4),R1		;;FIND # WORDS TRANSFERRED (INC. BAD SECTOR)
	CLRB	R1		;;CLEAR OUT ANY PARTIAL COUNT
	SWAB	R1		;; AND FIND # SECTORS TRANSFERRED
	BEQ	80$		;;NOTHING REALLY TRANSFERRED, EXIT NOT DONE
	BIT	R2,(R5)+	;;SHOULD WE BACK UP 1 SECTOR'S WORTH?
	BNE	730$		;;Yes					;004
	BIT	R2,4(R5)	;;No, should we perform ECC correction?	;004
	BNE	90$		;;No					;004

; Determine if error pattern is single-bit or multiple-bit.		;002
; Perform ECC correction only if pattern is single-bit.			;002
; Algorithm is:  if n = (n .and. -n) then n is power of 2, i.e. single bit;002
	MOV	TOS.R5+2(SP),R0	;;Get correction pattern		;002
	MOV	R0,-(SP)	;;Form negative of pattern (-n)		;002
	NEG	(SP)							;002
	MOV	R0,R3		;;Form value for .and.			;002
	COM	R3							;002
	BIC	R3,(SP)		;;Perform (n .and. -n)			;002
	CMP	(SP)+,R0	;;Is n = (n .and. -n)?			;002
	BNE	730$		;;No, n is a multibit error		;004
				;;At this point it's safe to do ECC, so do it.
	CALL	100$		;;Update bus address			;004
	MOV	6(R5),TOS.RA+2(SP) ;;Set ECC done return address	;004
	MOV	(SP),R1		;;GET BACK THE ECC CORRECTION POSITION
	DEC	R1		;; AND MAKE POSITION INTO 0-7777 RANGE
	CLR	R0		;;CLEAR A HIGH ORDER ERROR POSITION
	DIV	#20,R0		;;DIVIDE FOR:
				;; R0 = WORD POSITION (0-377)
				;; R1 = BIT POSITION (0-17)
	MOV	R5,-(SP)	;;Save R5				;004
	MOV	R0,R5		;;SAVE WORD POSITION
	MOV	TOS.R5+4(SP),R3	;;Get back the ecc correction pattern	;004
	CLR	R2		;;CLEAR A HIGH ORDER ERROR PATTERN
	ASHC	R1,R2		;;SHIFT PATTERN INTO CORRECT POSITION
	MOVB	(R4)+,R0	;;GET BUS ADDRESS AS DOUBLE-PRECISION NUMBER
	MOV	(R4)+,R1	;; INTO R0 AND R1
	SUB	#1000,R1	;;DECREMENT THIS ADDRESS BY ONE SECTOR'S WORTH
	SBC	R0		;; TO GET THE BASE OF THE BAD SECTOR IN MEMORY
	ASHC	#10.,R0		;;SHIFT FOR R0=MMU ADDRESS AND
	ASHC	#-10.,R1	;; R1=REMAINDER
	MAP	PUSH,APR=6,DATA ;;SAVE SCRATCH MAPPING REGISTER AND
	MAP	R0,APR=6,DATA	;; RE-LOAD IT FOR CORRECT ADDRESS
	ADD	#140000+2,R1	;;BIAS MMU REMAINDER FOR PAR6 ADDRESSING
	ADD	R5,R1		;;ADD IN ERROR WORD POSITION
	ADD	R5,R1		;; OFFSET (FOR BYTE ADDRESSING)
	MOV	(R4),R0		;;GET NEW -(WORD COUNT)
	BPL	50$		;;IF >=0 THEN CORRECTION LIMIT
	CLR	R0		;;IF <0 THEN CORRECT ANYTHING
50$:	ADD	R5,R0		;;ADD CORR OFFSET TO CORR LIMIT
	CMP	R0,#377		;;CHECK FOR CORRECTION LIMIT
	BHI	70$		;;IF >=400 THEN NO CORRECTION AT ALL
	BEQ	60$		;;IF =377 THEN CORRECT ONLY ONCE
	XOR	R2,(R1)		;;ELSE CORRECT HIGH ORDER WORD
60$:	XOR	R3,-(R1)	;;CORRECT LOW ORDER WORD
70$:	MAP	POP,APR=6,DATA	;;RESTORE SCR MAPPING REGISTER
	MOV	(SP)+,R5	;;Restore R5				;004
710$:	MOV	R4,R0		;;COPY DSQ POINTER @ DSQCNT		;004
	ADD	#DSQPDA-DSQCNT,R0 ;; AND INDEX TO TRACK/SECTOR LOCATION
	ADD	TOS.R1+2(SP),(R0) ;;Update trk/sec by # good sectors read ;004
720$:	CMPB	(R0),(R5)	;;SECTOR OVERFLOW?			;004
	BLO	80$		;;NOPE
	SUB	(R5),(R0)	;;YEP, DECREMENT SECTOR AND INCREMENT TRACK
	CMP	(R0),2(R5)	;;TRACK OVERFLOW?
	BLO	720$		;;NOPE, CHECK SECTOR AGAIN		;004
	SUB	2(R5),(R0)	;;YEP, DECREMENT TRACK
	INC	DSQOPT-DSQPDA(R0) ;; AND INCREMENT CYLINDER
	BR	720$		;;LOOP AROUND AGAIN			;004

730$:	DEC	R1		;;One less good sector was read in	;004
	BNE	90$		;;Partial transfer, update DSQ		;004
80$:	TST	(SP)+		;;POP THE SAVED ECC CORRECTION POSITION
	RETURN			;;NOW EXIT

90$:	CALL	100$		;;Update bus address			;004
	ADD	#DSQCNT-DSQMAM,R4 ;;Point R4 back to DSQCNT		;004
	BR	710$		;;Finish up				;004

100$:	MOV	R1,TOS.R1+4(SP)	;;Save sectors tranferred		;004
	SWAB	R1		;;CONVERT # SECTORS BACK TO # WORDS
	ADD	R1,(R4)		;;UPDATE THE REMAINING -(WORD COUNT)
	ASL	R1		;;CONVERT # WORDS TO # BYTES
	ADD	R1,-(R4)	;;UPDATE THE BUS ADDRESS LSB
	ADCB	-(R4)		;; AND MSB
	RETURN			;; Done					;004

.SBTTL	COMMON TRACK OFFSET POSITION VALUE TABLE

	.BYTE	100	;SPECIAL "READ WITHOUT OFFSETTING FIRST" CODE
;		0,+400,-400,+800,-800,+1200,-1200  ;MICROINCHES OF OFFSET
ECOFTB::.BYTE	0,  20, 220,  40, 240,   60,  260  ;TABLE OF VALUES FOR ABOVE
ECOFTE::.BYTE	0	;END OF TABLE - RETURN TO CENTER AND GIVE ERROR
	.EVEN

.END

