	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
	.INCLUDE /DSK:DKDEF/
TITLE	DKSEEK,<OVERLAPPED SEEK RK11/RK05/RK05F DISK DRIVER>,0A,10-MAY-91,MHB/GW/WRM/TWH/VAM

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR DKSEEK
;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;  001	TWH  28-OCT-83	ADD SUPPORT FOR IFUN
;  002  VAM  05-Apr-85	Don't log Write Check miscompares as hard errors
;  003  VAM  30-May-85	Add RELFUN.
;
;			[RSTS/E V9.6]
;  004	KCG  29-Feb-88	Add FMTFUN.
;
;-

	DEFORG	DKSEEK

	DEFORG	DKDSK

	INCLUDE	<CMNDSK,UNIDSK,OPTDSK,ERLDSK>

	DSKDEF	DK

.SBTTL	ERROR LOGGING

	ERRENT	LOG$DK

	CALLX	ERLDSK,R5	;;;USE COMMON ROUTINE
	  .BYTE	ERC$DK		;;;ERROR CODE
	  .BYTE	-1		;;;OVERLAPPED SEEK
	  .BYTE	RKDS,6		;;;OFFSET, 6 REGISTERS
	  .BYTE	0,0		;;;THAT'S ALL
	RETURN			;;; AND BACK

.SBTTL	FORM THE PHYSICAL ADDRESS

QDS$DK::CMPB	DSQSAV(R4),#IFUN;IS THIS AN INITIALIZE?			;001
	BEQ	30$		;YEP					;001
	CMPB	DSQSAV(R4),#RELFUN	;How about a release?		;003
	BEQ	30$			;Yup.				;003
	CMPB	DSQSAV(R4),#FMTFUN	;Maybe a format?		;004
	BEQ	30$			;Yes 				;004
	DIV	#12.,R0		;DIV GIVES R0=TRACK(T), R1=SECTOR(S)
	SWAB	R0		;OLD SWITCHEROO TRICK. R0=TTTTTTTT0000000T
	BIS	R3,R0		;SO WE CAN .OR. IN UNIT NUMBER*2(U)
	ASH	#4,R1		;SHIFT SECTOR BITS INTO PLACE
	BIS	R0,R1		;NOW EVERYBODY IN R1=TTTTTTTTSSSSUUUT
	ASHC	#-4,R1		;FANCY ROTATE     R1=UUUTTTTTTTTTSSSS
	MOV	R1,DSQPDA(R4)	;STORE THE DISK ADDRESS
	BIC	#^C<37740>,R1	;GET OPTIMIZATION WORD (KEEPING LSB OF UNIT)
	MOV	R1,DSQOPT(R4)	;SAVE THE OPTIMIZATION WORD NOW
	BICB	MID$DK(R3),DSQOUN(R4) ;OPTIMIZE BOTH RK05F UNITS TOGETHER
	MOVB	DSQOUN(R4),(R4)	; AND PUT ALL REQUESTS INTO THE EVEN QUEUE
	MOVB	#SEEK,DSQFUN(R4) ;INITIAL FUNCTION WILL BE SEEK
30$:	CALL	@(SP)+		;RETURN WITH ADDRESS ALL SET UP

.SBTTL	COMES HERE IF REQUEST IS FIRST IN DRIVE'S QUEUE

	.BR	CKSEEK		;;TRY TO START A SEEK

GLOBAL	<MID$DK>

.SBTTL	CHECK FOR STARTING SEEK(S) AND/OR AN I/O TRANSFER

.ENABL	LSB

UMR$DK::

; CHECK FOR REQUIRED CLEAR OF CONTROL

CKSEEK:	TST	DKDCTL		;;IS CONTROL BUSY NOW?
	BNE	CKEXIT		;;YES, SO WE MUST JUST EXIT
	BIT	(R3),#RKHE	;;IS CONTROL IN A HARD ERROR CONDITION?
	BEQ	100$		;;NO, SO CONTINUE
10$:	CLR	(R3)		;;YES, SO SET CONTROL CLEAR FUNCTION
	INC	(R3)		;; AND EXECUTE THAT FUNCTION
.ASSUME	CRESET	EQ	0	;;THIS IS A RESET COMMAND
20$:	BIT	(R3),#RKERR!RKRY ;;READY AND/OR ERROR?
	BEQ	20$		;;NEITHER, WAIT
	BMI	10$		;;ERROR, TRY IT AGAIN
	MOV	#DSS$DK,R0	;;O.K. NOW, GET STATUS LIST POINTER
30$:	TST	(R0)+		;;IS (WAS) THIS DRIVE TIMING OUT?
	BPL	40$		;;NO, LEAVE IT ALONE
	CLR	-(R0)		;;YES, MARK DRIVE AS IDLE NOW
40$:	CMP	R0,#DSE$DK	;;MORE DRIVES?
	BLO	30$		;;YES, CHECK THEM

GLOBAL	<DKDCTL,DSS$DK,DSE$DK>

; CHECK FOR SEEKS TO START

100$:	MOV	#CNT.DK,R2	;;GET THE NUMBER OF DRIVES TO SCAN
	MOV	DKDPT2,R0	;;GET THE ROUND-ROBIN SEEK STARTER PTR
110$:	CMP	R0,#DQS$DK	;;IS ROUND-ROBIN PTR ABOUT TO INVALIDATE ITSELF?
	BHI	120$		;;NOPE
	MOV	#DQE$DK,R0	;;YES, SO RESET IT
120$:	MOV	-(R0),R4	;;IS THERE ANYTHING IN THIS DRIVE'S QUEUE?
	BEQ	130$		;;NOTHING IN DRIVE'S QUEUE, SKIP THIS ONE
	TST	DSO$XX(R0)	;;SOMETHING, BUT IS THE DRIVE IDLE?
	BNE	130$		;;DRIVE NOT IDLE, SKIP THIS ONE ALSO
	CMPB	DSQSAV(R4),#IFUN;;IS THIS A DRIVE INITIALIZE?		;001
	BEQ	125$		;;YEP					;001
	CMPB	DSQSAV(R4),#RELFUN	;;How about a RELFUN?		;003
	BEQ	125$		;;Yup.					;003
	CMPB	DSQSAV(R4),#FMTFUN	;Maybe a format?		;004
	BEQ	124$			;Yes 				;004
	MOV	R0,DKDPT2	;;REMEMBER WE FOUND THIS DRIVE
	INC	DSO$XX(R0)	;;CHANGE STATUS TO WAITING FOR I/O
	CMPB	DSQFUN(R4),#DRESET ;;DESIRING A DRIVE RESET?
	BEQ	DKSTRT		;;YES, SO JUST DO IT
	CALLX	OPTDSK,R5,OPT$DK ;;NO, OPTIMIZE THE QUEUE
	BR	DKSTRT		;;NOW START THE SEEK GOING

124$:	SETERR	ERRERR,DSQERR(R4) ;;formatting not supported		;004
125$:	CALLX	DFINT9		;;DEQUEUE THE REQUEST (INIT SET THE TABLES);001
130$:	SOB	R2,110$		;;LOOP FOR ALL DRIVES

GLOBAL	<CNT.DK,DKDPT2,DQS$DK,DQE$DK,DSO$XX,OPT$DK>

; CHECK FOR AN I/O TRANSFER TO START

	MOV	#CNT.DK,R2	;;NO (MORE) SEEKS TO START, HOW ABOUT I/O?
	MOV	DKDPT1,R0	;;SO GET THE ROUND-ROBIN I/O PTR
200$:	CMP	R0,#DQS$DK	;;IS ROUND-ROBIN PTR ABOUT TO INVALIDATE ITSELF?
	BHI	210$		;;NOPE
	MOV	#DQE$DK,R0	;;YES, SO RESET IT
210$:	MOV	-(R0),R4	;;CHECK FOR SOMETHING IN THIS QUEUE
	BEQ	240$		;;NOTHING, SO SKIP THIS QUEUE
	CMP	DSO$XX(R0),#1	;;SOMETHING, BUT IS IT WAITING FOR I/O?
	BNE	240$		;;NOT IN I/O WAIT, SKIP IT
	MOV	R0,DKDPT1	;;WE FOUND ONE, SAVE ROUND-ROBIN PTR
	MOVB	DSQSAV(R4),DSQFUN(R4) ;;RESTORE THE I/O FUNCTION CODE
	CLR	DSO$XX(R0)	;;FLAG AS I/O TYPE FUNCTION
DKSTRT:	MOV	DSQPDA(R4),RKDA(R3) ;;LOAD UNIT AND DISK ADDRESS
	MOV	RKDS(R3),R5	;;GET SELECTED DISK'S STATUS
	COMB	R5		;;REVERSE SENSE OF LOW BYTE
	CMPB	DSQSAV(R4),#WFUN ;;IS A WRITE COMING UP?
	BHI	220$		;;NO, SO DISK CAN BE WRITE LOCKED
	BIT	R5,#RKWPS	;;YES, IS DISK WRITE LOCKED NOW?
	BEQ	DKDRVC		;;IF SO THAT IS A FATAL TYPE ERROR
220$:	BIT	R5,#RKDPL!RKDRU!RKDRY!RKARY ;;CHECK FOR ERROR
	BNE	300$		;;SOMETHING IS WRONG
	CLR	R1		;;KEEP CSR CLEAN FOR SEEKS
	TST	DSO$XX(R0)	;;IS THIS I/O OR SEEK?
	BNE	230$		;;SEEKS DON'T NEED WINDOWS
	CALLX	DSKUMR		;;GET A WINDOW
230$:	MOV	R0,DKDCTL	;;SET CONTROLER BUSY FLAG
	CLR	-(SP)		;;INDICATE NO EXTRA PARAMETER(S)
	JMPX	DSKSRU		;;WE CAN ASK COMMON CODE TO START THE ACTION

240$:	SOB	R2,200$		;;LOOP FOR ALL POSSIBLE DRIVES
CKEXIT:	RETURN			;;NOTHING TO DO, SO WHY NOT EXIT...

GLOBAL	<CNT.DK,DKDPT1,DKDCTL,DQS$DK,DQE$DK,DSO$XX,ERRERR>

; WE FOUND A DRIVE IN ERROR, SO WE WON'T ISSUE A COMMAND TO IT

300$:	BIT	R5,#RKDPL!RKDRU!RKDRY ;;CHECK AGAIN IGNORING ACCESS NOT READY
	BNE	DKDRVC		;;BAD, CHECK FOR NEEDING A DRIVE RESET
	COM	DSO$XX(R0)	;;ELSE SET A "JUST WAITING" TIMEOUT
	BR	CKEXIT		;; AND EXIT FOR NOW

DKDRVC:	MOVB	#DRESET,DSQFUN(R4) ;;SET DRIVE RESET REQUIRED
	CLR	-(SP)		;; AND DRIVE IDLE LATER
DKLOGR:	LOG$DK			;;NOW LOG THAT WE ARE FAILING
	MOV	(SP)+,DSO$XX(R0) ;;CORRECTLY SET NEW DRIVER STATUS
	BIT	R5,#RKDPL!RKDRU!RKDRY ;;CHECK HARD CONDITIONS
	CALLX	DFINT1		;;CHECK CC'S AND COUNT THE ERROR
	BMI	CKSEE1		;;MORE RETRIES, SO CONTINUE		;004
	CMPB	DSQSAV(R4),#WFUN ;;WAS THIS A WRITE?
	BHI	DKDONE		;;NO
	BIT	R5,#RKWPS	;;YES, IS DISK WRITE LOCKED?
	BNE	DKDONE		;;NOT WRITE LOCKED
	SETERR	HNGDEV,DSQERR(R4) ;;WRITE LOCKED, GIVE CORRECT ERROR
DKDONE:	CALLX	DFINT9		;;DONE, DE-QUEUE, AND HOUSEKEEP
CKSEE1:	JMP	CKSEEK		;;FROM THE TOP AGAIN...

.SBTTL	TIMEOUTS (PR5)

TMO$DK::CLR	R5		;;MAKE THIS A SOFT ERROR (FAKE "RKDS")
	CMP	R0,DKDCTL	;;WAS CONTROL BUSY WITH THIS REQUEST?
	BEQ	DKFINT		;;YES, FAKE AN INTERRUPT
	TSTB	DSO$XX(R0)	;;NO, "JUST WAITING" STATUS?
	BPL	DKDRVC		;;OTHER, LOG ERROR AND CONTINUE
	CLR	DSO$XX(R0)	;;"JUST WAITING", SET IDLE NOW
	BR	CKSEE1		;; AND CHECK FOR STARTING SEEKS, ETC.

.DSABL	LSB

GLOBAL	<DKDCTL,DSO$XX>

.SBTTL	INTERRUPT SERVICE (PR5)

INT$DK::MOV	CSR.DK,R3	;;GET CSR ADDRESS 
	MOV	RKDS(R3),R5	;;GET DRIVE UNIT THAT INTERRUPTED
	BIC	#^C<160000>,R5	;; AND ISOLATE IT
	MOV	R5,RKDA(R3)	;;SELECT THAT DRIVE
	MOV	RKDS(R3),R5	;;GET DRIVE STATUS AND
	COMB	R5		;; COMPLEMENT LOW BYTE OF IT
	MOV	RKER(R3),R2	;;GET ERROR REGISTER
	MOV	(R3),R1		;;GET CONTROL STATUS
DKFINT:	MOV	DKDCTL,R0	;;GET THE CONTROL BUSY INDICATOR
	BEQ	DKATTN		;;NOT BUSY, CHECK FOR ATTN INTERRUPT
	CLR	DKDCTL		;;BUSY, BUT NO LONGER
	MOV	(R0),R4		;;GET THE REQUEST AT TOP OF QUEUE
	TSTB	DSO$XX(R0)	;;I/O OR SEEK INITIATE COMPLETE?
	BNE	10$		;;IT WAS A COMPLETE SEEK INITIATE
	CALL	@RELUMR		;;RELEASE THE WINDOWS
	MOV	RKDA(R3),OPO$XX(R0) ;;IT WAS I/O COMPLETE, SAVE DISK ADDRESS
	BIC	#^C<37740>,OPO$XX(R0) ;;BUT TRIM FOR CYLINDER & UNIT LSB
	TST	R1		;;ANY ERROR?
	BPL	DKDONE		;;NO, SO ALL DONE
	BIT	R2,#RKDRE!RKSKE ;;YES, WOULD A DRIVE RESET HELP?
	BNE	DKDRVC		;;DO A DRIVE RESET FOR THIS DRIVE
	BIT	#RKWCK,R2		;;Write check error?		;002
	BEQ	5$			;;Nope, go log an error.	;002
	MOVB	#DATERR,DSQERR(R4)	;;Otherwise, put error away...	;002
	BR	DKDONE			;; ...and go back.		;002

5$:	MOV	#1,-(SP)	;; ELSE SET WAITING FOR I/O LATER
	BR	DKLOGR		;;  AND LOG AN ERROR

10$:	TST	R1		;;ANY ERROR?
	BPL	CKSEE1		;;NO, LET THE SEEK DO ITS THING
	BR	DKDRVC		;;YES, CHECK FOR DRIVE RESETING

GLOBAL	<CSR.DK,DKDCTL,DSO$XX,OPO$XX,RELUMR,DATERR>			;002

.SBTTL	UNIT ATTENTION LINE PROCESSING

DKATTN:	BIT	R1,#RKSCP	;;WHAT KIND OF INTERRUPT OCCURED?
	BEQ	CKSEE1		;;A NOTHING INTERRUPT
	MOV	R5,R0		;;A SEEK COMPLETED, COPY THE DISK STATUS
	ASH	#-13.+1,R0	;; AND SHIFT FOR UNIT NUMBER TIMES 2
	BIC	#^C<16>,R0	;;  BUT MASK ALL OTHER BITS OUT
	BICB	MID$DK(R0),R0	;;FORCE EVEN UNIT IF RK05F
	ADD	#DQS$DK,R0	;;NOW WE HAVE THE QUEUE ROOT ADDRESS
	CMP	R0,#DQE$DK	;;IS THIS DRIVE OUT OF OUR TABLE?
	BHIS	CKSEE1		;;YES, SO FORGET IT
	MOV	(R0),R4		;;NO, SO GET THE REQUEST IN THIS QUEUE
	BEQ	CKSEE1		;;NO REQUEST IN QUEUE, FORGET IT
	TSTB	DSO$XX(R0)	;;WHAT IS THE CURRENT STATUS?
	BEQ	CKSEE1		;;NOT DOING A SEEK, FORGET IT
	CLRB	DSO$XX+1(R0)	;;ELSE SET THE CORRECT NEW STATUS
	MOV	DSQPDA(R4),RKDA(R3) ;;RE-SELECT THAT DRIVE
	BIT	R5,#RKDPL!RKDRU!RKSIN ;;WAS THE COMPLETION O.K.??
	BEQ	CKSEE1		;;ALL O.K., SO PROCESSING ALL DONE
	BR	DKDRVC		;; AND CHECK ERROR CONDITIONS

GLOBAL	<MID$DK,DQS$DK,DQE$DK,DSO$XX>

.END

