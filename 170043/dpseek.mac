	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
	.INCLUDE /DSK:DPDEF/
TITLE	DPSEEK,<OVERLAPPED SEEK RP11/RP02/RP03 DISK DRIVER>,0A,10-MAY-91,MHB/GW/WRM/TWH/VAM

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR DPSEEK
;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;
;			[RSTS V9.0]
;  001	TWH  28-OCT-83	ADD SUPPORT FOR IFUN
;  002	FEK  15-MAY-84	CORRECT MOV INSTEAD OF MOVB IN 001
;			AND THE SIZES SET BY IFUN
;
;			[RSTS V9.1]
;  003  VAM  03-Jun-85	Add RELFUN.
;			(Note: RELFUN is a no-op in this driver).
;
;			[RSTS V9.6]
;  004	KCG  29-Feb-88	Add FMTFUN.
;
;-

	DEFORG	DPSEEK

	DEFORG	DPDSK

	INCLUDE	<CMNDSK,UNIDSK,OPTDSK,ERLDSK>

	DSKDEF	DP

.SBTTL	ERROR LOGGING

	ERRENT	LOG$DP

	CALLX	ERLDSK,R5	;;;USE COMMON ROUTINE
	  .BYTE	ERC$DP		;;;ERROR CODE
	  .BYTE	-1		;;;OVERLAPPED SEEK
	  .BYTE	RPDS,11.	;;;OFFSET, 11. REGISTERS
	  .BYTE	0,0		;;;THAT'S ALL
DPRET:	RETURN			;;; AND BACK

.SBTTL	FORM THE PHYSICAL ADDRESS

QDS$DP::CMPB	DSQSAV(R4),#IFUN ;IS THIS A DRIVE INITIALIZE?		;001
	BEQ	30$		;YEP					;001
	CMPB	DSQSAV(R4),#RELFUN	;How about a Release?		;003
	BEQ	30$			;Yup.				;003
	CMPB	DSQSAV(R4),#FMTFUN	;Maybe a FORMAT command?	;004
	BEQ	30$			;Yo				;004
	MOVB	#-21.,DSQERR(R4) ;RP'S GET 20. RETRIES
	DIV	#200.,R0	;NOW DIVIDE BY 200.(SECTORS PER CYLINDER)
	MOV	R0,DSQOPT(R4)	;ANSWER IS THE CYLINDER NUMBER
	CLR	R0		;SET FOR ANOTHER DIVIDE
	DIV	#10.,R0		;DIVIDE BY 10.(SECTORS PER TRACK)
	SWAB	R0		;PUT TRACK # IN HIGH BYTE (0-19.)
	ADD	R1,R0		; AND ADD IN SECTOR (0-9.)
	MOV	R0,DSQPDA(R4)	;NOW SAVE TRACK/SECTOR
	MOV	R3,(R4)		;SET QUEUE ROOT OFFSET AS PHY. UNIT*2
	CLRB	DSQCTO(R4)	;ENSURE LOW BYTE OF UNIT LOCATION IS ZERO
.ASSUME	DSQPUN	EQ DSQCTO!1	;UNIT MUST BE HIGH BYTE, WITH UNUSED LOW BYTE
	MOVB	#SEEK,DSQFUN(R4) ;FIRST FUNCTION WILL BE A SEEK
30$:	CALL	@(SP)+		;RETURN WITH ADDRESS ALL SET UP		;001

.SBTTL	COMES HERE IF REQUEST IS FIRST IN DRIVE'S QUEUE

UMR$DP::TST	DPDCTL		;;IS CONTROL BUSY NOW?
	BNE	DPRET		;;YES, WE WILL COME BACK LATER...
	.BR	DPATTN		;;CHECK THE ATTN LINES

GLOBAL	<DPDCTL>

.SBTTL	UNIT ATTENTION LINE PROCESSING

.ENABL	LSB

DPATTN:	MOVB	RPDS(R3),R4	;;GET THE ATTN LINE SUMMARY
	BEQ	CKSEEK		;;NO ATTN LINE(S) ON, CHECK SEEKS AND/OR I/O
	MOV	#BITWRD,R0	;;GET THE 'BIT-TO-WORD' TABLE POINTER
10$:	BIT	R4,(R0)+	;;ATTN LINE MATCH BIT IN TABLE?
	BEQ	10$		;;NO, LOOP UNTIL WE GET A MATCH...
	MOV	-(R0),RPDS(R3)	;;YES, SO TURN OFF THAT ATTN LINE
	SUB	#BITWRD,R0	;;-(TABLE BASE) FOR UNIT NUMBER TIMES 2
	ADD	#DQS$DP,R0	;;+(BASE OF QUEUE ROOT TABLE) FOR ROOT POINTER
	CMP	R0,#DQE$DP	;;IS THIS DRIVE OUT OF OUR TABLE?
	BHIS	DPATTN		;;YES, SO FORGET IT
	MOV	(R0),R4		;;NO, SO GET THE REQUEST IN THIS QUEUE
	BEQ	DPATTN		;;NO REQUEST IN QUEUE, FORGET IT
	TSTB	DSO$XX(R0)	;;CHECK DRIVE'S STATUS
	BEQ	DPATTN		;;NOT SEEKING, IGNORE IT
	BIC	(PC)+,(R3)	;;SELECT UNIT 0
	 .BYTE	0,7
	BIS	DSQPUN-1(R4),(R3) ;;NOW SELECT THE CORRECT UNIT
	CLRB	DSO$XX+1(R0)	;;SET STATUS TO I/O WAIT
	BIT	RPDS(R3),#RPSI!RPSU!RPFU ;;WAS THE COMPLETION O.K.??
	BEQ	DPATTN		;;ALL O.K., SO PROCESSING ALL DONE
DPDRVC:	MOV	RPDS(R3),R1	;;SOME ERROR OCCURED, GET STATUS BIT(S)
20$:	ADD	#RPOL,R1	;;NOW COMPLEMENT THE 'ON-LINE' STATUS BIT
	LOG$DP			;;LOG THE ERROR
	CLR	DSO$XX(R0)	;;SET DRIVE'S STATUS TO IDLE
	MOVB	#DRESET,DSQFUN(R4) ;; AND FUNCTION TO DRIVE RESET
	BIT	R1,#RPOL!RPFU	;;CHECK FOR FATAL TYPE ERROR
DPERRC:	CALLX	DFINT1		;;GO CHECK CC'S IN COMMON CODE AND COUNT ERROR(S)
	BMI	DPATTN		;;STILL CAN RETRY, SO PROCESSING DONE
DPDONE:	CALLX	DFINT9		;;DE-QUEUE, AND HOUSEKEEP THIS REQUEST
	BR	DPATTN		;;NOW GO PROCESS ATTENTION LINES

.SBTTL	TIMEOUTS (PR5)

TMO$DP::CMP	R0,DPDCTL	;;IS CONTROL BUSY WITH THIS REQUEST?
	BNE	20$		;;NO, SO RETRY THAT SEEK
	BR	DPCINT		;;YES, FAKE AN INTERRUPT

.DSABL	LSB

GLOBAL	<BITWRD,DQS$DP,DQE$DP,DSO$XX,DPDCTL>

.SBTTL	INTERRUPT SERVICE (PR5)

.ENABL	LSB

INT$DP::MOV	CSR.DP,R3	;;GET CSR ADDRESS 
	MOV	RPER(R3),R2	;;SAVE THE ERROR STATUS
	MOV	(R3),R1		;;SAVE CONTROL STATUS
DPCINT:	MOV	DPDCTL,R0	;;NOW GET THE BUSY FLAG
	BEQ	DPATTN		;;NOT BUSY, SO MUST BE ATTENTION LINE INTERRUPT
	CLR	DPDCTL		;;BUSY, BUT CLEAR THE BUSY FLAG NOW
	MOV	(R0),R4		;;NOW GET TOP-OF-QUEUE REQUEST
	TSTB	DSO$XX(R0)	;;WAS THIS I/O OR SEEK INITIATE?
	BNE	20$		;;IT WAS SEEK INITIATE
	CALL	@RELUMR		;;RELEASE THOSE WINDOWS
	MOV	RPSUCA(R3),OPO$XX(R0) ;; AND SAVE THE DRIVE'S CYLINDER ADDRESS
	ASL	R1		;;ANY ERROR?
	BCC	DPDONE		;;NO, SO ALL DONE
	BPL	10$		;;YES, IS IT A HARD ERROR?
	COM	DPDCTL		;;SET RESET CONTROL FLAG IF HARD ERROR
10$:	ASR	R2		;;CHECK FOR AN ERROR
	BCS	DPDRVC		;;ERROR, AND DRIVE NEEDS A DRIVE RESET
.ASSUME	RPDER	EQ	1	;;BE SURE WE'RE TESTING THE RIGHT BIT
	CMPB	DSQERR(R4),#-11. ;;TIME FOR A HOME SEEK ANYHOW?
	BEQ	DPDRVC		;;YES, SO DO ONE
	LOG$DP			;;ELSE LOG AN ERROR HERE
	MOV	#1,DSO$XX(R0)	;;SET STATUS TO WAITING FOR I/O AGAIN
	BIT	R2,#<RPSUWP!RPSUFU!RPNEC!RPNET!RPNES!RPNEM!RPEOP>/2 ;;CHECK FOR FATAL TYPE
DPERC1:	BR	DPERRC		;;CHECK CC'S AND CONTINUE

20$:	ASL	R1		;;DID AN ERROR OCCUR?
	BCC	DPATTN		;;NOPE, SO PROCESS ATTENTION LINES
	BPL	DPDRVC		;;YEP, BUT SOFT ERROR
	COM	DPDCTL		;;ELSE A HARD TYPE ERROR, SET RESET FLAG
	BR	DPDRVC		;; THEN GO CHECK THE ERROR

.DSABL	LSB

GLOBAL	<CSR.DP,DPDCTL,DSO$XX,OPO$XX,RELUMR>

.SBTTL	CHECK FOR STARTING SEEK(S) AND/OR AN I/O TRANSFER

.ENABL	LSB

; CHECK FOR A REQUIRED CONTROL CLEAR

10$:	CLR	(R3)		;;SET CONTROL CLEAR FUNCTION
	INC	(R3)		;; AND EXECUTE IT
.ASSUME	CRESET	EQ	0	;;BE SURE IT'S A RESET INSTRUCTION
20$:	TSTB	(R3)		;;READY?
	BPL	20$		;;NO, WAIT...
	CLR	DPDCTL		;;O.K., CLEAR THE FLAG
CKSEEK:	TST	DPDCTL		;;SHOULD WE RESET CONTROL?
	BNE	10$		;;YES, SO GO DO IT

; CHECK FOR SEEKS TO START

	MOV	#CNT.DP,R2	;;GET THE NUMBER OF DRIVES TO SCAN
	MOV	DPDPT2,R0	;;GET THE ROUND-ROBIN SEEK STARTER PTR
30$:	CMP	R0,#DQS$DP	;;IS ROUND-ROBIN PTR ABOUT TO INVALIDATE ITSELF?
	BHI	40$		;;NOPE
	MOV	#DQE$DP,R0	;;YES, SO RESET IT
40$:	MOV	-(R0),R4	;;IS THERE ANYTHING IN THIS DRIVE'S QUEUE?
	BEQ	70$		;;NOTHING IN DRIVE'S QUEUE, SKIP THIS ONE
	TST	DSO$XX(R0)	;;SOMETHING, BUT IS THE DRIVE IDLE?
	BNE	70$		;;DRIVE NOT IDLE, SKIP THIS ONE ALSO
	CMPB	DSQSAV(R4),#IFUN ;;IS THIS A DRIVE INITIALIZE?		;001
	BEQ	120$		;;YEP					;001
	CMPB	DSQSAV(R4),#RELFUN	;;Is this a release?		;003
	BEQ	150$			;;Yup, so just get out.		;003
	CMPB	DSQSAV(R4),#FMTFUN	;;Maybe a FORMAT?		;004
	BEQ	115$			;;Yes, return error		;004
	MOV	R0,DPDPT2	;;DRIVE IS IDLE, SAVE ROUND-ROBIN PTR
	INC	DSO$XX(R0)	;;SET STATUS TO WAITING FOR I/O
	CMPB	DSQFUN(R4),#DRESET ;;DO A DRIVE RESET NOW?
	BEQ	50$		;;YES
	CALLX	OPTDSK,R5,OPT$DP ;;ELSE GET THE BEST REQUEST IN THIS QUEUE
	MOV	DSQPUN-1(R4),(R3) ;;NOW SELECT THAT UNIT
	CMP	DSQOPT(R4),RPSUCA(R3) ;;IS DRIVE ON CORRECT CYLINDER ALREADY?
	BNE	50$		;;NOPE, SO DO A SEEK TO THE CYLINDER
	TST	RPDS(R3)	;;YEP, BUT DOES THE DRIVE LOOK O.K.?
	BMI	70$		;;ALL LOOKS O.K., SO NO SEEK THIS TIME
.ASSUME	RPDRDY	EQ	100000	;;BE SURE WE'RE TESTING THE RIGHT BIT
50$:	CALL	100$		;;NOW START THAT SEEK (OR DRIVE RESET)
60$:	BIT	(R3),#RPERR!RPRDY ;;IS CONTROL READY AND/OR IN ERROR?
	BEQ	60$		;;THIS SHOULD TAKE ONLY UP TO 16US
	BR	INT$DP		;;NOW FAKE AN INTERRUPT

70$:	SOB	R2,30$		;;LOOP FOR ALL POSSIBLE DRIVES

GLOBAL	<DPDCTL,DPDPT2,CNT.DP,DQS$DP,DQE$DP,DSO$XX,OPT$DP>

; CHECK FOR AN I/O TRANSFER TO START

	MOV	#CNT.DP,R2	;;NO (MORE) SEEKS TO START, HOW ABOUT I/O?
	MOV	DPDPT1,R0	;;SO GET THE ROUND-ROBIN I/O PTR
80$:	CMP	R0,#DQS$DP	;;IS ROUND-ROBIN PTR ABOUT TO INVALIDATE ITSELF?
	BHI	90$		;;NOPE
	MOV	#DQE$DP,R0	;;YES, SO RESET IT
90$:	MOV	-(R0),R4	;;CHECK FOR SOMETHING IN THIS QUEUE
	BEQ	110$		;;NOTHING, SO SKIP THIS QUEUE
	CMP	DSO$XX(R0),#1	;;SOMETHING, BUT IS IT WAITING FOR I/O?
	BNE	110$		;;NOT IN I/O WAIT, SKIP IT
	MOV	R0,DPDPT1	;;WE FOUND ONE, SAVE ROUND-ROBIN PTR
	MOVB	DSQSAV(R4),DSQFUN(R4) ;;RESTORE THE I/O FUNCTION CODE
	CLR	DSO$XX(R0)	;;FLAG AS EXECUTE TYPE FUNCTION
100$:	MOV	DSQPUN-1(R4),(R3) ;;SELECT UNIT
.ASSUME	DSQPUN&1 EQ 1		;;THIS MUST BE HIGH BYTE OF SOMETHING
	MOVB	DSQOUN(R4),R5	;;GET UNIT NUMBER TIMES 2
	MOV	RPDS(R3),R1	;;GET SELECTED DRIVE'S STATUS
	BIC	#^C<RPRP03>,R1	;; AND ISOLATE THE 'RP03' BIT
	CMP	R1,MID$DP(R5)	;;REALLY THE CORRECT DRIVE TYPE??
	BNE	DPERC1		;;NO, FATAL
	CLR	R1		;;PREVENT CONFUSION IN CASE OF SEEKS
	TST	DSO$XX(R0)	;;IS THIS A SEEK OR I/O TRANSFER?
	BNE	105$		;;A SEEK, DON'T MAP IT
	CALLX	DSKUMR		;;GET WINDOW FOR THE TRANSFER
105$:	MOV	R0,DPDCTL	;;SET CONTROLER BUSY FLAG
	MOV	DSQPDA(R4),RPDA(R3) ;;LOAD THE TRACK AND SECTOR DISK ADDRESSES
	MOV	DSQOPT(R4),RPCA(R3) ;;LOAD THE CYLINDER NUMBER TOO
	MOV	DSQPUN-1(R4),-(SP) ;;PUT UNIT NUMBER IN HIGH BYTE ON STACK
	;CLRB	(SP)		;; (LOW BYTE ENSURED TO BE ZERO)
	JMPX	DSKSRU		;;CALL COMMON CODE TO START THE ACTION

110$:	SOB	R2,80$		;;LOOP FOR ALL POSSIBLE DRIVES
	MOV	#7*400!RPAIE,(R3) ;;WAIT FOR ATTN INTERRUPTS WHEN CONTROL IDLE
CKEXIT:	RETURN			;;NOTHING TO DO, SO WHY NOT EXIT...

115$:	SETERR	ERRERR,DSQERR(R4)	;;FORMAT not supp for drive	;004
	BR	150$			;;join common			;004

120$:	MOV	DSQPUN-1(R4),(R3)	;;SELECT UNIT			;001
	TST	(R3)		;;IS THERE ANY ERRORS?			;001
	BMI	160$		;;YEP					;001
	BIT	#RPOL,RPDS(R3)	;;ARE WE DISABLED?			;001
	BEQ	160$		;;YEP					;001
	MOVB	DSQUNT(R4),R1	;;GET THE FUN				;002
	ASL	R1		;;TIMES 2				;001
	MOV	#20000.,UNTSIZ(R1)	;;SET UNTSIZ FOR RP02		;002
	MOVB	#2.,DEVCLU(R1)	;;AND DCS				;002
	MOV	RPDS(R3),R5	;;GET THE MID				;001
	MOV	R5,MID$XX(R1)	;;AND STORE IT				;001
	BIC	#^C<RPRP03>,MID$XX(R1)	;;IS IT A RP03?			;001
	BEQ	150$		;;NOPE					;001
	ASL	UNTSIZ(R1)	;;MAKE IT RP03 SIZE			;001
150$:	CALLX	DFINT9		;;DEQUEUE THE REQUEST			;001
	BR	70$		;;CONTINUE IN LINE			;001

160$:	CLZ			;;SAY HARD ERROR			;001
	LOG$DP			;;LOG THE ERROR				;001
	CALLX	DFINT1		;;CHECK CC'S AND COUNT ERROR		;001
	BR	150$		;;FINISH UP				;001

.DSABL	LSB

GLOBAL	<CNT.DP,DPDPT1,DPDCTL,DQS$DP,DQE$DP,DSO$XX,MID$DP>
GLOBAL	<MID$XX,UNTSIZ,DEVCLU,ERRERR>					;001
.END
