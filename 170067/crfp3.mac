	.TITLE	CRFP3
	.IDENT	/03/

;
; COPYRIGHT   1975, 1991 DIGITAL  EQUIPMENT  CORP.,  MAYNARD,   MASS.
;
; THIS SOFTWARE IS FURNISHED TO PURCHASER UNDER A LICENSE FOR USE
; ON A SINGLE COMPUTER SYSTEM  AND  CAN BE COPIED (WITH INCLUSION
; OF DEC'S COPYRIGHT NOTICE)  ONLY FOR USE IN SUCH SYSTEM, EXCEPT
; AS MAY OTHERWISE BE PROVIDED IN WRITING BY DEC.
;
; THE INFORMATION IN  THIS DOCUMENT IS  SUBJECT TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT  BE CONSTRUED AS  A COMMITMENT BY DIGITAL
; EQUIPMENT CORPORATION.
;
; DEC ASSUMES  NO  RESPONSIBILITY  FOR  THE  USE  OR  RELIABILITY
; OF ITS  SOFTWARE  ON  EQUIPMENT  WHICH IS NOT  SUPPLIED BY DEC.
;
;
; C. MONIA 31-DEC-74
;
; MODIFICATIONS:
;
;		TL290 -- 6-Apr-83
;
;			 Get the page length from the $PGLEN routine
;			 if it is supported on this system.  If it is
;			 not then use the task build default.  The lines
;			 per page used by CRF does not include the three
;			 lines for the page header or the eleven lines
;			 for the bottom margin so the number returned
;			 by $PGLEN is reduced by 14.
;
;					NOTE:
;
;			 In the past if a number of lines, say 63 (51.),
;			 was specified then CRF actually put out 64 (52.)
;			 lines plus the header and a formfeed.  This
;			 behaviour is being preserved for historical reasons.
;			 As a result the number returned by $PGLEN is
;			 reduced by 15. instead of 14.
;
;
;		S. LeVan
;			Merge RSTS-specific code in RSX V4.3 version of program
;
;
; CREF PHASE 3
;
; MACRO LIBRARY CALLS
;

	.MCALL	CLOSE$,OFNB$A
	.MCALL	OFNB$W		;++RSTS V7.1

;
; LOCAL DATA
;
; ADJACENCY REQUIRED
;

CLRBEG=.
CRFMT:	.BLKW	1		; CURRENT FORMAT NUMBER
LINNO:	.BLKW	1		; CURRENT LINE NUMBER
PAGELN:	.BLKW	1		; PAGE LENGTH (DOESN'T INCLUDE HEADER LENGTH)
MARGIN:	.BLKW	1		; NUMBER OF CONTINUATION LINE SPACES
REFHD:	.BLKW	1		; REFERENCE LISTHEAD
$BYTCT::.BLKW	1		; CURRENT BYTE COUNT
$NBYTE::.BLKW	1		; ADDRESS TO STORE NEXT BYTE
$PAGNO::.BLKW	1		; CURRENT PAGE
CLRSZ=.-CLRBEG/2

;
; FORMATTING STRING FOR NEW LINE
;

SPACES:	.ASCIZ	/%VS/

	.EVEN


;+
; **-$CRFP3-CREF PHASE THREE, OUTPUT CREF LISTING
;
; THIS ROUTINE APPENDS THE CREF LISTING TO THE APPRO-
; PRIATE OUTPUT FILE SUBMITTED FOR CREF PROCESSING.
;
; INPUTS:
;
;	TABLES BUILT BY CREF PHASES 1 AND 2.
;
; OUTPUTS:
;
;	THE CREF LISTING IS APPENDED TO THE OUTPUT FILE
;
;-

$CRFP3::			;
	SAVRG			; SAVE THE NON-VOLATILE REGISTERS
	MOV	#CLRBEG,R0	; GET BEGINNING ADDRESS TO CLEAR
	MOV	#CLRSZ,R1	; GET NUMBER OF WORDS TO CLEAR
10$:				;
	CLR	(R0)+		; CLEAR SPECIFIED MEMORY LOCATIONS
	SOB	R1,10$		; ...
	CALL	$PGLEN		; GET THE SYSTEM DEFAULT LINES PER PAGE
	TST	R0		; IS THERE ONE?
	BNE	5$		; IF NE YES - USE IT
	MOV	#L$NMAX+15.,R0	; IF NOT USE THE TASK BUILD DEFAULT
5$:	SUB	#15.,R0		; GET THE NUMBER OF LINES AFTER THE HEADER
	MOV	R0,PAGELN	; AND STORE IT FOR LATER USE
	MOV	$FMTPT,R5	; GET ADDRESS OF FORMAT CONTROL ENTRY
	MOV	F$MCTD(R5),R4	; POINT TO FIRST TABLE DESCRIPTOR
	OFNB$A	#$CRODB		; OPEN FILE FOR APPEND

	.IF	DF,RSTS		;++RSTS V7.1
	BCC	15$		;++RSTS V7.1 FILE EXISTS USE IT
	MOV	#$CRODB,R0	;++RSTS V7.1
	MOVB	#R.VAR,F.RTYP(R0)  ;++RSTS V7.1 MAKE SURE TYPE IS VARIABLE
	MOVB	#FD.PLC,F.RACC(R0) ;++RSTS V7.1 AND IN LOCATE MODE
	CLRB	F.RATT(R0)	;++RSTS V7.1 CLEAR RECORD ATTRIBUTE
	OFNB$W	#$CRODB		;++RSTS V7.1 TRY OPENING IT FOR OUTPUT
	.IFTF			;++RSTS V7.1
	BCS	OPERR		; IF C/S OPEN FAILURE
	.IFT			;++RSTS V7.1
15$:				;++RSTS V7.1
	.ENDC			;++RSTS V7.1

	MOV	F.NRBD+2(R0),$NBYTE ; SET ADDRESS OF NEXT BYTE
20$:				;
	TST	(R4)		; ANY ENTRIES IN TABLE?
	BEQ	100$		; IF EQ NO
	MOV	PAGELN,LINNO	; FORCE PAGE HEADER OUTPUT
	MOV	#$ISEDV,-(SP)	; PUSH ADDRESS OF SYMBOL EDIT ROUTINE
	MOV	R4,R0		; GET LISTHEAD ADDRESS
30$:				;
	CALL	@(SP)+		; GET NEXT SYMBOL
	BCS	100$		; IF C/S DONE
	MOV	R0,R3		; COPY REAL ADDRESS OF SYMBOL DESCRIPTOR.
	CALL	OUTPG		; OUTPUT A PAGE HEADER
	CALL	$CRFLB		; FORMAT CREF LABEL FIELD
	CALL	$CRFOT		; OUTPUT IF RECORD BUFFER FULL
	MOV	$BYTCT,MARGIN	; RECORD MARGIN POSITION
	ADD	#S$YREF,R3	; POINT TO REFERENCE LISTHEAD
40$:				;
	MOV	(R3),R3		; GET VIRTUAL ADDRESS OF NEXT REFERENCE
	BEQ	60$		; IF EQ DONE WITH REFERENCES
	MOV	#R$FLTH,R1	; GET LENGTH OF REFERENCE
	MOV	R1,-(SP)	; SAVE LENGTH
	CALL	$ALBLK		; ALLOCATE CORE BLOCK
	MOV	R0,-(SP)	; SAVE ADDRESS OF BLOCK
	MOV	R3,R1		; GET VIRTUAL ADDRESS OF REFERENCE
	CALL	$CVRL		; CONVERT TO REAL ADDRESS
	MOV	R0,R3		; SAVE REAL ADDRESS
	MOV	(SP)+,R1	; RESTORE ADDRESS OF CORE BLOCK
	MOV	(SP),R2		; GET LENGTH OF REFERENCE LIST ENTRY
50$:				;
	MOVB	(R0)+,(R1)+	; COPY ENTRY
	SOB	R2,50$		; ...
	SUB	(SP)+,R1	; RESET ENTRY POINTER
	MOV	#REFHD,R0	; GET LISTHEAD ADDRESS
	CALL	$ISYMR		; INSERT SYMBOL IN LEXICAL SEQUENCE
	BR	40$		; GO AGAIN
60$:				;
	MOV	#REFHD,R3	; POINT TO START OF REFERENCE LIST
	MOV	#$CRFRF,-(SP)	; PUSH ADDRESS OF REFERENCE FORMATTER
70$:				;
	MOV	(R3),R3		; GET ADDRESS OF NEXT REF. IN SEQUENCE
	BEQ	80$		; IF EQ DONE
75$:				;
	CALL	@(SP)+		; FORMAT THIS REFERENCE
	CALL	$CRFOT		; CONDITIONALLY OUTPUT A LINE
	BCS	70$		; IF C/S LINE NOT FINISHED
	MOV	(R3),R3		; GET ADDRESS OF NEXT REFERENCE
	BEQ	85$		; IF EQ NONE
	CALL	OUTPG		; CONDITIONALLY CREATE NEW PAGE
	MOV	$NBYTE,R0	; GET ADDRESS OF NEXT BYTE OUT
	MOV	#SPACES,R1	; POINT TO SPACING FORMAT
	MOV	#MARGIN,R2	; POINT TO MARGIN COUNT
	CALL	$EDMSG		; FORMAT STRING OF SPACES
	CALL	$CRFOT		; OUTPUT SPACES
	BR	75$		; OUTPUT NEXT REFERENCE
80$:				;
	CALL	$CRFSH		; FLUSH OUTPUT RECORD
85$:				;
	INC	(SP)+		; CLEAN STACK
	MOV	#REFHD,R3	; GET ADDRESS OF REFERENCE LIST
90$:				;
	MOV	(R3),R2		; GET ADDRESS OF BLOCK TO RELEASE
	BEQ	30$		; IF EQ DONE
	MOV	(R2),(R3)	; SET ADDRESS OF NEXT TO RELEASE
	MOV	#R$FLTH,R1	; SET LENGTH OF BLOCK
	MOV	#$FRHD,R0	; GET LISTHEAD ADDRESS
	CALL	$RLCB		; RELEASE BLOCK
	BR	90$		; GO AGAIN
100$:				;
	ADD	#T$DLTH,R4	; POINT TO NEXT TABLE DESCRIPTOR
	MOV	#CRFMT,R0	; POINT TO CURRENT FORMAT NUMBER
	INC	(R0)		; INCREMENT FORMAT
	CMP	(R0),F$MCMF(R5)	; DONE ALL LISTS?
	BLOS	20$		; IF LOS NO
	RETURN			;

;
; OPEN ERROR ON OUTPUT FILE
;

OPERR:				;
	ADD	#<F.FNB+N.FNAM>,R0 ; POINT TO FILENAME BLOCK
	MOV	R0,R2		; COPY ADDRESS OF FILENAME
	ERROR$	E$R2,S$V2	; FATAL ERROR, NO.RETURN

;
; CONDITIONALLY OUTPUT A PAGE HEADER
;

OUTPG:				;
	MOV	#LINNO,R0	; SET ADDRESS OF LINE NUMBER
	INC	(R0)		; INCREMENT LINE COUNT
	CMP	(R0),PAGELN	; TIME TO GENERATE NEW PAGE?
	BLOS	10$		; IF LOS NO
	CLR	(R0)		; RESET LINE NUMBER
	INC	$PAGNO		; INCREMENT PAGE NUMBER
	CALL	$CRFPG		; FORMAT PAGE HEADER
10$:				;
	RETURN			;

	.END
