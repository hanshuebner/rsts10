.TITLE	PAT.010	OBJECT MODULE PATCH
.IDENT	/V04.00/	;CHANGE "VERID" ALSO
.SBTTL	OBJECT MODULE PATCH

;                      COPYRIGHT (c) 1979, 1980 BY
;             DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.

; CER,MAS

.IIF NDF EIS$	EIS$=	0	;SAY EIS NOT AVAILABLE

; EDIT LOG
; LET CORRECTION REFERENCE GLOBAL DEFIINED IN MODULE			;MAS01
; FIX RLD BLOCK PROBLEM							;MAS02
; ADD FILE PROTECTION ERROR MESSAGES					;MAS03
; SET USER ERROR BYTE PROPERLY ON ERRORS				;MAS04

.SBTTL	*	MACRO DEFINITIONS

.MCALL	.PRINT,	.RCTRL,	.SRESE,	.CLOSE,	.SETTO,	.CSIGE,	.WAIT,	.EXIT
.READW=	EMT + 375
.WRITW= EMT + 375

.MACRO	ERROR$	ERNB,SEV,ETYP,REG
 .IF NB REG
  .IIF DIF <REG>,<R0>	MOV REG,R0
 .ENDC	;REG
	TRAP + <SEV*200>+<ERNB*4>+ETYP
.ENDM

; MACRO TO DEFINE ERROR NUMBERS (ERNB) FOR ERROR$ MACRO			;MAS02+

.MACRO	ERR 	SYM
 NUM=0
.DSABL CRF
 .REPT	SYM+1
  .IRP	FOO,<\NUM>
.ENABL CRF
   ERR'FOO=	NUM
  .ENDR
.DSABL CRF
  NUM=	NUM+1
.ENABL CRF
 .ENDR
.ENDM									;MAS02-

.IF Z EIS$
.MACRO	SOB	A,B
	DEC	A
	BNE	B
.ENDM
.ENDC	;EIS$

;+
; SUBROUTINE CALL AND RETURN TO MAIN PROGRAM, EQUIVILENT TO:
;	JSR	PC,A
;	RTS	PC
;-

.MACRO	CALLR	A
	JMP	A
.ENDM

.SBTTL	PAT 	DEFINITIONS	

.SBTTL	*	OFFSETS INTO JOB'S SYSTEM COMMUNICATION AREA

BEGIN=	40	;JOB STARTING ADDRESS
HIGH=	50	;PROGRAM'S HIGHEST AVAILABLE LOCATION
ERRBYT=	52	;MONITOR ERROR INDICATOR
USERRB=	53	;USER ERROR BYTE					;MAS04
RMON=	54	;CONTAINS THE START OF THE RESIDENT MONITOR
	U$RLD=	266	;OFFSET INTO RMON WHEN USR WILL LOAD
	CONFIG=	300	;CONFIG WORD RMON OFFSET
	KT.11=	10000	;BIT IN CONFIG SAYS IF RUNNING XM MONITOR

.SBTTL	*	CONSTANTS USED

SPACE=	40	;ASCII SPACE
IBFSIZ=	512.	;SIZE OF INPUT BUFR
OBFSIZ=	512.	;SIZE OF OUTPUT BUFR
INCHN=	3	;INPUT FILE CHANNEL
CORCHN=	4	;CORRECTION FILE CHANNEL
SMTSIZ=	256.	;SIZE OF SECTION MAPPING TABLE
RECSIZ=	128.	;SIZE OF FORMATTED BINARY RECORD(NOT COUNTING CHECKSUM)
GSDSZ=	8.	;SIZE OF GSD RECORD
F.BRHC=	1	;1ST WORD OF EACH FORMATTED BINARY RECORD
STGSD=	1	;START OF GSD
EOGSD=	2	;END OF GSD
EOMOD=	6	;END OF MODULE
TXTBLK=	3	;TEXT INFORMATION BLOCK	(TXT)
RLDTYP=	4	;RECORD TYPE 4 - (RLD)
	LCDEF=	7	;LOCATION COUNTER DEFINITION COMMAND NUMBER	;MAS02
	LCMOD=	10	;LOCATION COUNTER MODIFICATION COMMAND NUMBER	;MAS02
	RLDLIM=	11	;RLD PROGRAM LIMIT COMMAND NUMBER		;MAS02
	STO=	12	;COMPLEX TYPE 12 - STORE RESULT
	STOD=	13	;COMPLEX TYPE 13 - STORE DISPLACED

.SBTTL	*	ERROR MESSAGE TYPES

E$FIL=	0	;PRINT MSG & CURRENT INPUT FILENAME
E$PRT=	1	;JUST PRINT A MESSAGE
E$REG=	2	;PRINT MSG PLUS CONTENTS OF REG
E$SYM=	3	;PRINT MSG & REG -> 2 WD RAD50 SYMBOL TO PRINT
E$W=	0	;ERROR IS A WARNING MESSAGE
E$F=	1	;ERROR IS FATAL 
SE.VER= 10	;F ERROR SETTING IN USER ERROR BYTE			;MAS04
WA.RN=	2	;W ERROR SETTING IN USER ERROR BYTE			;MAS04

.SBTTL	*	CONTROL SECTION & GLOBAL SYMBOL FLAGS

CS$REL=	40		;RELOCATABILITY (1=REL, 0=ABS)
SY$GBL=	100		;GLOBAL (1=GLOBAL, 0=INTERNAL)
SY$REL=	40		;RELOCATABILITY (1=REL, 0=ABS)
SY$DEF=	10		;DEFINITION (1=DEF., 0=REF.)

.SBTTL	*	SYMBOL TABLE ENTRY OFFSETS

.ASECT
.=0

S.YNXT:	.BLKW	1	;LINK TO NEXT (0=NONE)
S.YM:	.BLKW	2	;SYMBOL NAME (2-WORD, RAD50)
S.YFLG:	.BLKB	1	;SYMBOL FLAGS
S.YCOD:	.BLKB	1	;GSD CODE BYTE
S.YVAL:	.BLKW	1	;SYMBOL VALUE
C.SLGH:	.BLKW	0	;LENGTH OF SECTION TABLE ENTRY
S.YSCT:	.BLKW	1	;ADDRESS OF SECTION TABLE ENTRY
S.YLGH:	.BLKW	0	;LENGTH OF GLOBAL SYMBOL ENTRY

.SBTTL	*	GSD ENTRY STRUCTURE

.=0
	.BLKW	2	;2 WORD RAD50 SYSBOL NAME
S$YFLG:	.BLKB	1	;SYMBOL FLAGS
S$YCOD:	.BLKB	1	;GSD CODE BYTE
S$YVAL:	.BLKW	1	;SYMBOL VALUE

.SBTTL	*	MEMORY LAYOUT

;+
;	.BLKB	OBFSIZ	;OUTPUT BUFFER IF AN OUTPUT FILE
;	.BLKB	IBFSIZ	;INPUT BUFFER (ALWAYS)
;	.BLKB	SMTSIZ	;SECTION MAPPING TABLE
;			;START OF SECTION & GLOBAL SYMBOL TABLE ENTRIES
;
;	HIGH LIMIT OF PROGRAM
;-

.SBTTL	*	END DEFINITIONS		*

  .IF	NDF	RST$		; The following suppressed for RSTS
.ASECT
.=34
	.WORD	ERROVR	;SETUP TRAP VECTOR FOR ERROR PROCESSING
	.WORD	0
  .ENDC

.SBTTL	IMPURE 	STORAGE AREAS AND VARIABLES

.PSECT	IMPURE,D,GBL

; NEXT 3 VALUES MUST BE ADJACENT

INSW::	.WORD	0	;INPUT FILE SWITCH WORD
INCS::	.WORD	0	;INPUT FILE CHECKSUM SPECIFIED BY USER
INCK::	.WORD	0	;INPUT FILE CHECKSUM COMPUTED BY PATCH

; NEXT 3 VALUES MUST BE ADJACENT

CRSW::	.WORD	0	;CORRECTION FILE SWITCH WORD
CRCS::	.WORD	0	;CORRECTION INPUT FILE CHECKSUM SPECIFIED BY USER
CRCK::	.WORD	0	;CORRECTION INPUT FILE CHECKSUM COMPUTED BY PATCH

; THE FOLLOWING TWO PARAMETERS MUST BE ADJACENT

MODNM::	.WORD	0,0,0,0		;MODULE NAME GSD RECORD
IDENT::	.WORD	0,0,6*400,0	;MODULE IDENTIFICATION
 
SCTHD::	.WORD	0,SCTHD		;SECTION TABLE LISTHEAD
SYMHD::	.WORD	0		;SYMBOL TABLE LISTHEAD
XFRAD::	.WORD	0,0,3*400,1	;MODULE TRANSFER ADDRESS

DEFEXT:	.RAD50	\OBJOBJOBJOBJ\	;DEFAULT EXTENSIONS
LIMIT::	.LIMIT			;USE 1ST WORD AS FREE SPACE PTR

RECBF::	.WORD	F.BRHC		;ALL FORMATTED BINARY RECORDS START WITH 1
	.BLKB	RECSIZ		;RECORD BUFFER(ALLOW FOR CHECKSUM)

.PSECT	BYTE,D

VERID::	.ASCIZ	\PAT V04.00 \	;CHANGE .IDENT ALSO

.SBTTL	START	COMMAND LINE DECODE & BUFFER INITILAZATION

;+
; PAT CAN NOT BE REENTERED OR RESTARTED, MUST RUN IT AGAIN.
; THE INITIAL STATE OF MANY VARIABLES IS CRITICAL TO PROPER FUNCTION
; OF THIS PROGRAM, THIS IS WHY IT IS NOT REENTERABLE OR RESTARTABLE.
; NO ATTEMPT WAS MADE TO CYCLE AGAIN THUS REQUIRING PROPER INITIALIZATION.
; .BLKW'S OR .BLKB'S DO NOT MATTER BUT .WORD'S OR .BYTE'S DO MATTER.
; PERFORM ALL STORAGE INITIALIZATION AND PARSE THE COMMAND LINE
;
; THE COMMAND LINE LOOKS LIKE:
;	*[OUTPUT-FILE]=INPUT-FILE[/C[:N]],CORRECTION-FILE[/C[:N]]
;-

.PSECT	MAIN

START::
  .IF	DF	RST$		; The following only for RSTS
	MOV	#ERROVR,@#34	; *MHB*, WJS Trap vector for error processing
	CLR	@#36		; *MHB*, WJS And guess at not XM monitor
  .ENDC
	CLR	@#BEGIN		;DISABLE USING "START"
	MOV	LIMIT+2,R3	;END OF PROGRAM ADR
	MOV	@#RMON,R0	;R0 -> START OF RESIDENT MON
	BIT	CONFIG(R0),#KT.11 ;IF RUNNING UNDER THE XM MONITOR
	BEQ	1$		;THEN SET USER MODE IN TRAP VECTOR PSW
	BIS	#140000,@#36	;TRAP VECTOR PSW
1$:	MOV	U$RLD(R0),R0	;ADR WHERE USR WILL LOAD
	TST	-(R0)		;JUST BELOW USR SO WILL NOT SWAP
	CMP	R0,R3		;IF USR LOAD ADR .LE. LIMIT THEN
	BHIS	2$		;GIVE ERROR
	ERROR$	ERR3,E$F,E$PRT	;INSUFFICIENT MEMORY

2$:	.SETTOP			;REQUEST SPACE UP TO USR
	.CSIGEN	R3,#DEFEXT	;REQUEST COMMAND LINE PARSING
	MOV	R0,R3		;UPDATE FREE CORE PTR
	MOV	R3,OBUF		;STARTING ADR OF OUTPUT BUFR
	BCS	8$
	CLR	R1		;START WITH CHANNEL 0 AN SEE IF
3$:	MOV	R1,R0		;ANYTHING GIVEN ON COMMAND LINE
	EMT	374		;.WAIT
	BCC	4$		;C=0 IF A FILE ON THIS CHANNEL
	INC	R1		;DO NEXT CHAN
	CMP	#10.,R1		;ONLY 3 OUTPUT & 6 INPUT FILES
	BNE	3$
	.PRINT	#VERID		;NOTHING ON CMD LINE SO PRINT VERSION ID
	BR	START		;GET ANOTHER LINE

4$:	.WAIT	#0		;WAS AN OUTPUT FILE GIVEN
	BCS	5$		;C=1 IF NO FILE
	MOV	R3,OBPTR	;INIT OUTPUT BUFR PTR;NON-ZERO WHEN FILE GIVEN
	ADD	#OBFSIZ,R3	;UPDATE FREE CORE PTR
5$:	.WAIT	#1		;MORE THAN 1 OUTPUT FILE ?
	BCC	6$		;C=0 IF A FILE
	.WAIT	#2
	BCS	7$
6$:	ERROR$	ERR2,E$W,E$PRT	;ADDITIONAL OUTPUT FILE IGNORED
7$:	.WAIT	#INCHN		;WAS INPUT FILE GIVEN ?
	BCC	9$		;YES IF C=0
	DECB	IRAREA		;GET PROPER MSG
	ERROR$	ERR1,E$F,E$FIL	;INPUT FILE MISSING

8$:	ERROR$	ERR21,E$F,E$PRT	;COMMAND LINE ERROR

9$:	MOV	R3,IBUF		;START OF INPUT BUFR(ALSO END OF OUTPUT BUFR)
	ADD	#IBFSIZ,R3	;SIZE OF INPUT BUFR
	.WAIT	#CORCHN		;CORRECTION FILE GIVEN ?
	BCC	10$		;YES IF C=0
	ERROR$	ERR1,E$F,E$FIL	;CORRECTION FILE MISSING

10$:	.WAIT	#5		;TOO MANY FILES SPECIFIED?
	BCS	11$		;NO IF C=1
	ERROR$	ERR4,E$W,E$PRT	;EXTRA INPUT FILE IGNORED

; BEGIN SWITCH PROCESSING

11$:	MOV	(SP)+,R2	;GET SWITCH COUNT
12$:	DEC	R2		;COUNT DOWN UNTIL ALL
	BMI	15$		;ALL DONE IF -
	CMPB	@SP,#'C		;ONLY /C IS LEGAL
	BNE	14$		;ERROR IF NE
	MOV	@SP,R0		;ISOLATE FILE POSITION
	BIC	#^C77400,R0	;FILE # BITS
	CMP	#3*400,R0	;SWITCH FOR INPUT FILE ?
	BEQ	13$		;YES IF EQ
	CMP	#4*400,R0	;CORRECTION FILE ?
	BNE	14$		;NO IF NE SO ERROR
	INC	CRSW		;SAY SWITCH GIVEN
	TST	(SP)+		;VALUE GIVEN ?
	BPL	12$		;NO IF +
	MOV	(SP)+,CRCS	;SAVE CORRECTION CHECKSUM VALUE
	BR	12$		;GET ALL SWITCHES

13$:	INC	INSW		;SAY SWITCH GIVEN
	TST	(SP)+		;VALUE GIVEN FOR INPUT FILE ?
	BPL	12$
	MOV	(SP)+,INCS	;INPUT FILE CHECKSUM
	BR	12$

14$:	ERROR$	ERR17,E$F,E$PRT	;ONLY /C ALLOWED

15$:	.SETTOP	#-2		;GET ALL FREE SPACE
	MOV	R3,LIMIT	;KEEP FREE SPACE PTR FOR BLOCK ALLOCATION
	MOV	#SMTSIZ,R0	;ALLOCATE SPACE FOR SECTION MAPPING TBL
	JSR	PC,ALBLK	;& CHECK IF ALL FITS TO NOW
	MOV	LIMIT,(PC)+	;SAVE CURRENT LIMIT WHICH = START GSD	;MAS02
STXT::	 .BLKW			;LIST, AND START OF TXT LOCATION LIST	;MAS02
	MOV	R0,(PC)+	;START ADR OF SECTION MAPPING TBL
CRCMT::  .BLKW			;ADR OF CORRECTION FILE SECTION MAPPING TBL
	MOV	R0,(PC)+	;INIT PTR
CSMTP::	 .BLKW			;CORRECTION SECTION MAPPING TABLE PTR

.SBTTL	SRCMN	SEARCH CONCATENATED OBJECT MODULES FOR SPECIFIED MODULE NAME

;+
; THIS SUBROUTINE IS CALLED TO SEARCH A FILE OF CONCATENATED
; OBJECT MODULES FOR A MODULE WHOSE NAME MATCHES THAT
; OF THE CORRECTION INPUT FILE. IF THE SEARCH IS SUCCESSFUL THE
; OBJECT FILE IS POSITIONED TO THE BEGINNING OF THE SPECIFIED MODULE.
;
; INPUT:
;	MODNM=0, IRAREA=CORCHN, CURBLK=-1, ENDBUF=0, EOF=ILFMT
;
; OUTPUT:
;	INPUT FILE IS POSITIONED TO THE BEGINNING OF THE SPECIFIED MODULE.
;-

.ENABL	LSB

SRCMN:	JSR	PC,OBSCN	;SCAN CORRECTION OBJ MODULE
	BCS	ER6		;C=1 IF MODULE NAME NOT FOUND 		;MAS02
	DECB	IRAREA		;INPUT FILE CHANNEL #
	MOV	#-1,CURBLK	;START AT BEGINNING(BUMPED BEFORE READ)
	CLR	ENDBUF		;FORCE 1ST BUFR READ
	MOV	#2$,EOF		;SET EOF JMP LOCATION
1$:	JSR	PC,OBSCN	;SCAN ALL OF INPUT FILE INTIL EOF
	BCS	1$		;C=1 IF END-OF-MODULE RECORD
	BR	BLGSD		;BUILD INPUT FILE GSD TBL

2$:	ERROR$	ERR11,E$F,E$SYM,#MODNM ;UNABLE TO LOCATE MODULE <SYMBOL>

.SBTTL	MODN	PROCESS MODULE NAME

;+
; POSITION THE INPUT FILE AT THE FOUND MODULE TO CORRECT.
; THE GSD TITLE ENTRY MUST BE IN THE 1ST FORMATTED BINARY RECORD
;-
 
MODN:	MOV	#MODNM,R0	;R0 -> MODULE NAME STORAGE
	TST	@R0		;SEARCHING FOR NAME?
	BNE	3$		;IF NE YES
	MOV	(R1)+,(R0)+	;SET NAME OF CORRECTION FILE
	MOV	@R1,@R0
	BR	4$		;C=0 FROM TST

3$:	CMP	(R1)+,(R0)+	;TEST FIRST PART OF NAME
	BNE	5$		;IF NE CONTINUE
	CMP	@R1,@R0		;TEST SECOND PART OF NAME
	BNE	5$
	MOV	RELBLK,FILBLK	;REMEMBER POSITION
	MOV	BYTOFF,FILBYT	;BEFORE CALLING POINT
	JSR	PC,POINT	;POSITION THE INPUT FILE
4$:	BIT	(SP)+,(SP)+	;FORCE RETURN FROM OBSCN & C=0
5$:	RTS	PC

.DSABL	LSB

.SBTTL	BLGSD	BUILD GSD SYMBOL TABLES

;+
; THIS ROUTINE IS CALLED TO CONSTRUCT THE GSD SYMBOL TABLES FROM THE
; MODULE TO BE PATCHED.
;
; INPUT:
;	INPUT FILE POSITIONED AT THE FIRST RECORD IN THE MODULE
; 	CSCNT=0, IRAREA=INCHN
;
; OUTPUT:
;	THE GSD TABLES (GLOBAL SYMBOLS, TRANSFER ADDRESS AND PROGRAM
;	SECTIONS) ARE CONSTRUCTED FROM THE GSD RECORDS IN THE MODULE
;	TO BE PATCHED.
;-

BLGSD:	MOV	#ILFMT,EOF	;ILLEGAL FMT IF REACH EOF BEFORE END-GSD
	MOV	#ENGSD,BLKVCT+4	;END-OF-GSD IN RECORD TABLE
	MOV	#GSDVCT,R1	;R1 -> GSD DISPATCH TBL FOR OBSCN
	MOV	#IGNORE,(R1)+	;MODULE NAME
	MOV	#BLSEC,(R1)+	;ETC.
	TST	(R1)+
	MOV	#BLXFR,(R1)+
	MOV	#ISYMR,(R1)+	;INSERT GLOBAL SYMBOL INTO TABLE
	MOV	#BLSEC,@R1
	JSR	PC,OBSCN	;INITIATE SCAN OF INPUT MODULE
	BCC	EDGSD		;C=0 IF REACHED END OF GSD
	BR	ER6		;C=1 IF END-GSD NOT REACHED BEFORE	;MAS02
				;REACHED END-OF-MOD OR EOF 
	
ENGSD:	TST	(SP)+		;C=0, END OF GSD REACHED
	RTS	PC		;FORCE RETURN FROM OBSCN WITH C=0
 
.SBTTL	-	PROGRAM SECTION

; INPUT:	R1 -> GSD RECORD
 
BLSEC:	INC	(PC)+		;INCREMENT SECTION COUNT
CSCNT::	 .WORD	0		;COUNT OF UNIQUE SECTIONS
	MOV	#C.SLGH,R0	;LENGTH OF DESCRIPTOR
	JSR	PC,ALBLK	;ALLOCATE MEMORY
	MOV	R0,(PC)+	;SAVE ADDRESS OF CURRENT SECTION
CRSCT::	 .BLKW
	MOV	#SCTHD+2,R2	;R2 -> SECTION TABLE LISTHEAD
	MOV	R0,@(R2)+	;LINK TO OLD LAST
	MOV	R0,-(R2)	;SET NEW LAST
	TST	(R0)+		;SKIP OVER LINK TO NEXT PTR
	BR	XFERS1		;COPY ENTRY, XFERS WILL RETURN		;MAS02

.SBTTL	-	TRANSFER ADDRESS
 
BLXFR:	MOV	#XFRAD,R0	;GET ADDRESS TO STORE TRANSFER ADDRESS
XFERS1:	CALLR	XFERS		;DO WORD TRANSFERS, XFERS WILL RETURN	;MAS02

.SBTTL	EDGSD	MERGE INPUT MODULE AND CORRECTION FILE GSD

;+
; THIS ROUTINE IS CALLED TO COMBINE THE GSD RECORDS FROM THE INPUT AND
; CORRECTION FILES. THE RULES FOR MERGING GSD RECORDS ARE AS FOLLOWS:
;   SECTIONS AND PROGRAM SECTIONS:
;	NEW PROGRAM SECTIONS AND SECTIONS ARE ADDED TO THE SECTION LIST.
;	IF DUPLICATE SECTIONS OR PROGRAM SECTIONS ARE ENCOUTERED, THE
;	LENGTH IS SET IN ACCORDANCE WITH THE LONGER OF THE TWO ENTRIES.
;	THE ATTRIBUTES OF THE NEW ENTRY SUPERCEDE THOSE OF THE PREVIOUS
;	ENTRY. THE RELOCATABILITY ATTRIBUTE MUST BE THE SAME FOR BOTH ENTRIES.
;
;   GLOBAL SYMBOLS:
;	NEW SYMBOLS ARE ENTERED IN THE SYMBOL TABLE.
;	DUPLICATE REFERENCES ARE IGNORED.
;	A DUPLICATE DEFINITION SUPERCEDES THE INITIAL DEFINITION.
;	A FATAL ERROR MESSAGE IS PRINTED IN ALL OTHER CASES.
;
;   TRANSFER ADDRESS:
;	UNLESS A DUMMY ADDRESS IS ENCOUNTERED, TRANSFER
;	ADDRESS SUPERCEDES THAT OF THE INPUT MODULE.
;
;   MODULE IDENT SUPERCEDES THAT OF THE INPUT MODULE.
;
; INPUT:
;	GSD TABLE BUILT BY BLGSD, CORRECTION FILE
;	CSNUM=0, EOF=ILFMT
;
; OUTPUT:
;	GSD TABLE CONTENTS ARE EDITED AS DESCRIBED ABOVE
;-

EDGSD:	INCB	IRAREA		;CORRECTION FILE CHANNEL #
	MOV	#-1,CURBLK	;INIT BLK #
	CLR	ENDBUF		;FORCE 1ST BUFR READ
	MOV	#GSDVCT+2,R1	;R1 -> GSD VECTOR TBL SECTION NAME ENTRY
	MOV	#EDSEC,(R1)+	;UPDATE DISPATCH TBL FOR THIS PHASE
	TST	(R1)+
	MOV	#EDXFR,(R1)+
	MOV	#EDSYM,(R1)+
	MOV	#EDSEC,(R1)+
	MOV	#EDIDNT,@R1
	JSR	PC,OBSCN	;SCAN CORRECTION FILE
	BCC	MRGFL		;C=0 IF FOUND END-GSD
ER6:	ERROR$	ERR6,E$F,E$FIL	;REACHED EOF OR END-OF-MOD BEFORE END-GSD

.SBTTL	-	SECTION AND PROGRAM SECTION NAME
 
.ENABL	LSB

EDSEC:	MOV	R1,R3		;SAVE DESCRIPTOR ADDRESS
	MOV	#SCTHD,R0 	;R0 -> SECTION LISTHEAD
	JSR	PC,SRCHR	;SEARCH FOR ENTRY
	BCS	2$		;IF C/S NOT FOUND
	MOVB	R1,@CSMTP	;SECTION # IN MAPPING TBL
	INC	CSMTP		;BUMP SECTION MAPPINT TBL PTR
	MOV	R0,CRSCT	;SET ADDRESS OF CURRENT SECTION
	CMPB	S.YCOD(R0),S$YCOD(R3) ;COMPARE TYPES
	BNE	3$		;IF NE INCONSISTENT FORMAT
	CMPB	S.YCOD(R0),#1	;SECTION NAME?
	BEQ	1$		;IF EQ YES, IGNORE FLAGS
	MOVB	#CS$REL,R1	;SET RELOCATABLE FLAG
	MOVB	R1,R2		;COPY FLAG
	BICB	S.YFLG(R0),R1	;CLEAR ALL SECTION FLAGS
	BICB	S$YFLG(R3),R2	;...
	CMPB	R1,R2		;COMPARE RELOCATABILITY
	BNE	3$		;IF NE INVALID FORMAT
	MOVB	S.YFLG(R0),S$YFLG(R3) ;TRANSFER ATTRIBUTES
1$:	CMP	S.YVAL(R0),S$YVAL(R3) ;CHECK LENGTHS
	BHIS	10$		;IF HIS NO CHANGE
	MOV	S$YVAL(R3),S.YVAL(R0) ;SET TO HIGHER LENGTH
	BR	10$

; SECTION NOT FOUND IN GSD TBL, ADD NEW ENTRY

2$:	MOVB	CSCNT,@CSMTP	;SECTION # IN MAPPING TABLE
	INC	CSMTP		;BUMP SECTION TBL PTR
	BR	BLSEC		;ENTER IT INTO TABLE JUST AS ABOVE
 
3$:	ERROR$	ERR13,E$F,E$SYM,R3	;SECTION HAS INCOMPATIBLE FORMAT

.SBTTL	EDSYM	GLOBAL SYMBOL
 
EDSYM:	MOV	R1,R2		;ADR OF DESCRIPTOR
	MOV	#SYMHD,R0	;R0 -> SYMBOL TABLE LISTHEAD
	JSR	PC,SRCHR	;SEARCH FOR SYMBOL
	BCS	7$		;IF C=1 NOT IN TABLE & R1 UNCHANGED
	MOVB	S.YFLG(R0),R1	;GET FOUND REFERENCE FLAGS
	MOVB	S$YFLG(R2),R3	;GET GSD FLAGS
	BICB	#^CSY$GBL,R1	;CLEAR EXTRANEOUS FLAGS			;MAS01+
	BICB	#^CSY$GBL,R3	;CLEAR EXTRANEOUS FLAGS			
	CMPB	R1,R3		;COMPARE FLAGS
	BNE	8$		;IF NE INCOMPATIBLE REFERENCES
	MOVB	S.YFLG(R0),R1	;GET FOUND REFERENCE FLAG		
	MOVB	S$YFLG(R2),R3	;GET GSD FLAGS				
	BICB	#^CSY$DEF,R1	;CLEAR EXTRANEOUS FLAGS			
	BICB	#^CSY$DEF,R3	;CLEAR EXTRANEOUS FLAGS			
	CMPB	R1,R3		;COMPARE FOR DEFINED			
	BNE	5$		;NOT EQUAL-> WHICH IS DEFINITION?		
	TSTB	R3		;EQUAL-> ARE THEY DEF'S OR REF'S	
	BNE	4$		;R3=0 -> THEN REFERENCE	
	JSR	PC,TSTREL	;TEST REL OR ABS RETURN IF EQUAL
	BR	6$		;YES- REDEFINE SYMBOL

4$:	JSR	PC,TSTREL	;REL OR ABS?->RETURN ONLY ON MATCH
	BR	10$		;YES- IGNORE DUP REFERENCE

5$:	TSTB	R3		;WHICH IS THE DEFINITION
	BEQ	10$		;OLD MODULE IS-> OK
	BR	8$		;NEW ONE-> ERROR

6$:	MOV	CRSCT,S.YSCT(R0) ;-> CURRENT SECTION			;MAS01-
	MOV	R2,R1		;R1 -> GSD ITEM AGAIN
	TST	(R0)+		;SKIP LINK TO NEXT PTR
	BR	XFERS		;ELSE SUPERSEDE EXISTING DEFINITION

; GLOBAL NOT FOUND IN GSD TBL, ADD IT

7$:	CALLR	ISYMR		;INSERT IN LIST

8$:	ERROR$	ERR12,E$F,E$SYM,R2 ;SYMBOL HAS INCOMPATIBLE DEFINITION	

; MODULE IDENTIFICATION
 
EDIDNT:	MOV	#IDENT,R0	;R0 -> IDENT. STORAGE
	BR	XFERS
 
; TRANSFER ADDRESS
 
EDXFR:	CMP	S$YVAL(R1),#1	;DUMMY TRANSFER ADDRESS?
	BEQ	10$		;IF EQ YES, IGNORE IT
	MOV	#XFRAD,R0	;R0 -> TRANSFER ADDRESSS STORAGE

.SBTTL	XFERS	ENTRY COPY AND RETURN

XFERS:	MOV	(R1)+,(R0)+	;COPY GSD ENTRY, AND RETURN
	MOV	(R1)+,(R0)+
	MOV	(R1)+,(R0)+
	MOV	(R1)+,(R0)+
10$:	RTS	PC

TSTREL:	MOVB	S.YFLG(R0),R1	;GET FOUND REFERNECE FLAGS		;MAS01+
	MOVB	S$YFLG(R2),R3	;GET GSD FLAGS
	BICB	#^CSY$REL,R1	;CLEAR EXTRA FLAGS
	BICB	#^CSY$REL,R3	;CLEAR EXTRA FLAGS
	CMPB	R1,R3		;COMPARE FLAGS
	BNE	8$		;NOT EQUAL->ERROR
	RTS	PC		;ONLY RETURN ON MATCH			;MAS01-

.DSABL	LSB

.SBTTL	MRGFL	MERGE INPUT AND CORRECTION FILES

;+
; THIS ROUTINE IS CALLED TO COMBINE THE CONCATENATED INPUT FILE
; AND CORRECTION FILES TO PRODUCE THE PATCHED OUTPUT. THE PROCEDURE
; FOR COMBINING FILES IS AS FOLLOWS:
;
; THE INPUT FILE IS COPIED TO THE OUTPUT FILE UNTIL IT
; IS POSITIONED AT THE MODULE TO BE PATCHED. AT THAT TIME THE
; PREVIOUSLY CONSTRUCTED GSD TABLES ARE REFERENCED TO GENERATE
; A NEW GLOBAL SYMBOL DIRECTORY CONTAINING MODULE NAME, TRANSFER
; ADDRESS (IF SPECIFIED) AND MODULE IDENTIFICATION EXTRACTED FROM THE
; PATCH FILE ALONG WITH SECTIONS AND GLOBAL SYMBOLS FROM THE TABLES 
; BUILT BY EDGSD. 
;
; ONCE RECONSTRUCTION OF THE GSD IS COMPLETE, AND THE GSD TABLES ARE	;MAS02+
; NO LONGER NEEDED, THE INPUT FILE POSITION IS MARKED, AND THE FILE IS CLOSED.
; THEN, THE CORRECTION FILE IS OPENED AGAIN. THE TXT BLOCKS OF
; THE CORRECTION FILE ARE SCANNED, AND A LIST IS MADE OF ALL TEXT LOCATIONS 
; USED, AND THE ASSOCIATED PSECTS. THE LIST IS STORED IN THE  SAME AREA THAT 
; THE GSD TABLES WERE CREATED IN. WHEN THE TABLE IS COMPLETE, THE CORRECTION
; FILE IS CLOSED, AND THE INPUT FILE IS OPENED AND REPOSITIONED.
; THE REMAINDER OF THE FILE IS COPIED (LESS ALL GSD RECORDS) UNTIL END OF 
; MODULE IS REACHED. AS THE INPUT FILE IS COPED TO THE OUTPUT FILE, ALL OF
; ITS RLD LOCATIONS ARE CHECKED AGAINST THE CORRECTION FILE LOCATION LIST. IF
; THE INPUT FILE HAS RLD BLOCK INFORMATION FOR ANY LOCATIONS MODIFIED BY THE
; CORRECTION FILE, THOSE RLD BLOCKS ARE DELETED FROM THE INPUT FILE.
;
; THE POSITION IN THE INPUT FILE IS MARKED AND THE FILE IS CLOSED. THE
; CORRECTION INPUT FILE IS OPENED AND COPIED, ITS TEXT AND RLD RECORDS 
; APPEARING AFTER ALL SUCH RECORDS IN THE INPUT FILE. ON COMPLETION, THE INPUT
; FILE IS RE-OPENED AND REPOSITIONED FOR THE COMPLETION OF FILE COPY. 	;MAS02-
;
; INPUT:
;	GSD TABLES BUILT BY EDGSD
;	EOF=ILFMT, CKSUM=INCK, INCK=0, CRCK=0
;
; OUTPUT:
;	INPUT AND CORRECTION FILES ARE MERGED AS DESCRIBED
; 	GSD AND END OF MODULE BLOCKS
;-

MRGFL:	DECB	IRAREA		;INIT FOR READING INPUT FILE
	MOV	#-1,CURBLK
	CLR	ENDBUF		;FORCE READ OF 1ST BUFR

; COPY INPUT FILE TO OUTPUT FILE UNTIL AT PROPER POSITION

1$:	JSR	PC,NEWBLK	;GET A INPUT RECORD
	CMP	RELBLK,FILBLK	;COMPARE FILE LOCATION
	BNE	2$		;IF NE NOT POSITIONED PROPERLY
	CMP	BYTOFF,FILBYT
	BEQ	3$		;IF EQ FOUND CORRECT POSITION IN FILE
2$:	JSR	PC,WRTBLK	;OUTPUT FORMATTED BINARY BLK
	BR	1$
 
; FOUND CORRECT POSITION OF INPUT FILE. REBUILD MODULE GSD
 
3$:	JSR	PC,SKPBLK	;SKIP INITIAL MODULE GSD F.B. RECORD
	JSR	PC,WRGSD4	;INSERT START OF GSD RECORD IN BUFFER
	MOV	#MODNM,R1	;R1 -> MODULE NAME & IDENT
	JSR	PC,WRGSD	;MOVE INITIAL GSD TO OUTPUT BUFFER
	MOV	#IDENT,R1	;R1 -> IDENTIFICATION
	TST	@R1		;WAS AN IDENT GIVEN ?
	BEQ	4$		;NO IF EQ
	JSR	PC,WRGSD	;THERE IS ONE, SO WRITE IT
4$:	MOV	R4,-(SP)	;SAVE CURRENT INPUT BUFR PTR
	MOV	#SCTHD,R4 	;R4 -> SECTION HEAD
5$:	MOV	@R4,R4		;R4 -> NEXT SECTION
	BEQ	9$		;END OF LIST IF EQ

; OUTPUT GLOBALS UNDER THIS CURRENT SECTION

6$:	MOV	#SYMHD,R5	;R5 -> SYMBOL TABLE LISTHEAD
	MOV	R4,R1		;COPY ADDRESS OF RECORD
7$:	TST	(R1)+		;SKIP LINK TO NEXT PTR
	JSR	PC,WRGSD	;WRITE GSD RECORD
8$:	MOV	@R5,R5		;R5 -> NEXT SYMBOL
	BEQ	5$		;IF EQ DONE
	CMP	S.YSCT(R5),R4	;CURRENT SYMBOL IN THIS SECTION?
	BNE	8$		;IF NE NO
	MOV	R5,R1		;COPY ADDRESS OF ENTRY
	BR	7$		;GO AGAIN

;+ 
; GSD CONSTRUCTION IS COMPLETE, COPY REMAINDER OF INPUT MODULE
; BUT STRIP OFF ALL GSD RECORDS AND FIX INPUT FILE RLD BLOCKS
;-
 
9$:	MOV	(SP)+,R4	;RESTORE INPUT BUFR PTR
	MOV	#XFRAD,R1	;R1 -> TRANSFER ADDRESS
	JSR	PC,WRGSD	;WRITE TRANSFER ADDRESS
	CMP	#6,R3		;IF 6 OR LESS BYTES IN RECORD THEN
	BHIS	10$		;NO NEED TO FLUSH IT
	JSR	PC,WRGSD2	;FLUSH RECORD BUFFER
10$:	MOV	#EOGSD,RECBF+4	;END GSD BLOCK
	MOV	#6,R2		;LENGTH OF RECORD
	JSR	PC,PUT		;WRITE END-OF-GSD

;+
; THE GSD RECORDS HAVE ALL BEEN COPIED TO THE OUTPUT FILE. NOW, 	;MAS02+
; RE-OPEN THE CORRECTION FILE AND CREATE THE TXT LOCATION LIST IN
; THE GSD RECORD BUFFER AREA.
;
; TXTSCN DOES NOT HAVE TO BE A SUBROUTINE, IT IS ONLY CALLED ONCE, BUT 
; FOR CLARITY IT IS DONE THAT WAY; IT IS A VERY LONG AND COMPLEX ADDITION
; OF CODE.
;
; RLDSCN:
; THE FLAG WORD RLDSCN IS USED TO DETERMINE WHAT TYPE OF SCAN TO
; DO TO THE FILE BEING PROCESSED.
;
; RDLSCN:	= 0  	-> 	CORRECTION FILE TXT LIST CREATION
;		= 1  	-> 	INPUT FILE RLD BLOCKS MODIFIED
;		= -1 	-> 	CORRECTION FILE RLD SECTION NUMBERS UPDATED
;-

	JSR	PC,TXTSCN	;CREATE TXT LOCATION LIST
	INC	(PC)+		;RLDSCN: = 1 -> INPUT FILE RLD SCAN
RLDSCN:: .WORD	0		;SCAN FLAG
	JSR	PC,CPYFL	;COPY REMAINDER OF THIS MODULE
				;STRIP GSD, FIX INPUT FILE RLD'S
	MOV	#CRCK,CKSUM	;SET ADDRESS TO RECEIVE CHECKSUM
	JSR	PC,SAVINP	;GO SAVE INPUT FILE POSITION	
	NEG	RLDSCN		;-1 -> CORRECTION FILE SECT. NO. FIX	;MAS02-
				;STRIP GSD, SCAN FOR COMPLEX RLD
	JSR	PC,CPYFL	;APPEND TEXT, RLD TO OUTPUT

; FINISHED COPYING CORRECTION FILE, OUTPUT REMAINDER OF INPUT FILE

	DECB	IRAREA		;INPUT FILE CHANNEL
	JSR	PC,POINT	;POSITION BACK TO THE INPUT FILE
	MOV	#12$,EOF	;GO HERE ON EOF OF INPUT FILE
11$:	JSR	PC,NEWBLK	;GET NEXT FB RECORD
	JSR	PC,WRTBLK	;& WRITE IT TO OUTPUT FILE
	BR	11$		;UNTIL ALL GONE

12$:	CMP	(SP)+,(SP)+	;GET RID OF NEWBLK CALL THAT DID NOT RETURN
	MOV	#511.,R1	;FORCE LAST BUFR OUT
	CLR	R0		;ZERO FILL
13$:	JSR	PC,PUTBYT
	SOB	R1,13$

.SBTTL	-	VALIDATE OR REPORT MODULE CHECKSUM * FINISH UP *

.ENABL	LSB

	MOV	#INSW,R1	;GET ADDRESS OF INPUT FILE SWITCHES
	TST	(R1)+		;CHECKSUM SWITCH SPECIFIED ?
	BEQ	1$		;NO IF EQ
	TST	(R1)+		;CHECKSUM TO BE VALIDATED ?
	BEQ	4$		;IF EQ NO, REPORT IT
	CMP	@R1,-(R1)	;CHECKSUM COMPARE OK ?
	BEQ	1$		;YES IF EQ
	ERROR$	ERR16,E$W,E$FIL	;INPUT FILE CHECKSUM ERROR
1$:	MOV	#CRSW,R1	;GET CORRECTION FILE SWITCH WORD
	TST	(R1)+		;CHECKSUM SWITCH SPECIFIED ?
	BEQ	2$		;NO IF EQ
	TST	(R1)+		;CHECKSUM TO BE VALIDATED ?
	BEQ	5$		;IF EQ NO, REPORT IT
	CMP	@R1,-(R1)	;CHECKSUM COMPARE OK ?
	BEQ	2$		;YES IF EQ
	INCB	IRAREA		;PROPER FILE #
	ERROR$	ERR16,E$W,E$FIL	;CORRECTION FILE CHECKSUM ERROR
2$:	.SETTOP	OBUF		;LESS SWAPPING WILL HAPPEN
	.CLOSE	#0		;CLOSE OUTPUT FILE
	BCC	3$		;C=0 -> NO ERROR ON CLOSE		;MAS03+
	CMPB 	#3,@#ERRBYT	;IS IT A PROCTECTION ERROR?
	BNE	3$		;NE -> NO
	ERROR$	ERR24,E$W,E$PRT	;FILE PROTECTION VIOLATION 		;MAS03-
3$:	.SRESET			;RESET SYSTEM AREAS
	MOV	SP,R0		;DO A SOFT EXIT
	.EXIT			;ALL DONE

4$:	ERROR$	ERR14,E$W,E$REG,@R1 ;INPUT FILE CHECKSUM IS <N>
	BR	1$

5$:	ERROR$	ERR15,E$W,E$REG,@R1 ;CORRECTION FILE CHECKSUM IS <N>
	BR	2$

.SBTTL	ERROR	PRINT ERROR MESSAGE & EXIT

ERROR:	.RCTRLO			;OVERRIDE CTRL O
	.PRINT			;PRINT MESSAGE & RESTART
	.SETTOP	LIMIT+2
	BR	3$		;GO EXIT

.DSABL	LSB

.SBTTL	SAVINP	SAV INPUT FILE POSITION

; TAKEN FROM MRGFL							;MAS02

SAVINP:	MOV	RELBLK,FILBLK	;REMEMBER POSITION OF INPUT FILE
	MOV	BYTOFF,FILBYT	;(WE ARE AT THE END-OF-MODULE RECORD)
	INCB	IRAREA		;CORRECTION FILE CHANNEL
	MOV	#-1,CURBLK	;INIT FOR READING CORRECTION FILE
	CLR	ENDBUF		;FORCE 1ST BUFR READ
	RTS	PC

.SBTTL	TXTSCN	CREATE TXT LOCATION LIST FROM CORRECTION FILE

;+
; THE INPUT FILE POSITION IS MARKED, AND THE FILE IS CLOSED. THE 	;MAS02+
; CORRECTION FILE IS OPENED, AND ALL TXT BLOCKS AND RLD LOCATION COUNTER 
; DEFINITIONS ARE SCANNED. A LIST OF ALL PSECTS, AND THEIR ASSOCIATED TXT 
; LOCATIONS (OFFSETS INTO THE PSECTS), IS MADE. THIS LIST IS CREATED IN THE
; SAME AREA THAT GSD INFORMATION WAS STORED. (THIS INFORMATION IS NO LONGER
; REQUIRED, SINCE THE NEW GSD'S HAVE BEEN WRITTEN TO THE OUTPUT FILE.)
;
; WHEN THE LIST IS COMPLETE, THE CORRECTION FILE IS CLOSED, AND THE INPUT
; FILE RE-OPENED, AND REPOSITIONED.
;
; CORRECTION FILE TXT LOCATION LIST:
;
;	!-----------------------!
;	! -1			!<------STXT: 	start of text 
;	!-----------------------!		information buffer
;	! PSECT name in		!
;	!-----------------------!
;	! 2 word RAD50		!
;	!-----------------------!
;	! TXT location		!<------minimum of 0 offset into PSECT
;	!-----------------------!
;	! length of TXT block	!<------minimum of 2 bytes (number contiguous
;	!-----------------------!	TXT locations in this TXT block)
;	! TXT location		!
;	!-----------------------!
;	! length of TXT block	!
;	!-----------------------!
;	!	:		!
;	!	:		!
;	!-----------------------!
;	! -1			!<------end of PSECT information marker
;	!-----------------------!
;	! PSECT name in		!
;	!-----------------------!
;	! 2 word RAD50		!
;	!-----------------------!
;	! TXT location		!
;	!-----------------------!
;	! length of TXT block	!
;	!-----------------------!
;	! -1   			!<------end of PSECT information marker
;	!-----------------------!
;	! -2			!<------end of list marker
;	!-----------------------!
;	!	  		!<------ENDTXT:: end of list pointer
;	!-----------------------!
;	!	  :		!
;	! 	  :		!
;	!-----------------------!<------@#HIGH 	(from SETTOP)		;MAS02-
;-

;+
; INPUT:								;MAS02+
;	STXT::  -> 	START OF TXT LOCATION LIST
;	ENDTXT	-> 	END TXT LIST POINTER  (WORD AFTER -2)
;
; REGISTER USAGE:
;	R0 	=	TYPE CODE OF BLOCK RETURNED HERE FROM NEWBLK:, 
;			ALSO TEMP
;	R2 	=	RECORD LENGTH IN BYTES FOR PUT:
;	R3 	->	CURRENT PSECT TXT LIST LOC POINTER (1ST WORD OF NAME)
;	R4 	->	1ST DATA WORD F.B. BLOCK/CURRENT BUF POSITION NEWBLK:
;	R5 	=	NUMBER OF DATA BYTES IN NEW F.B. BLOCK FROM NEWBLK:
;
; OUTPUT:
;	TXT LOCATION LIST
;	R0,R1,R2,R3,R5 CLOBBERED
;-

.ENABL LSB

TXTSCN:	JSR	PC,SAVINP	;SAVE INPUT FILE POSITION
	MOV	STXT,R3		;GET TXT LOCATION BUFFER POINTER
	ADD 	#4,R3		;ADD IN SPACE NEEDED TO INIT TXT LOC BUFFER
	CMP	R3,@#HIGH	;HAVE WE EXCEEDED ALLOWABLE SPACE?
	BLO	2$		;LO -> HAVE ROOM
1$:	JMP	MEMERR		;INSUFFICIENT MEMORY ERROR

2$:	MOV	R3,ENDTXT	;SET UP END OF LIST POINTER
	MOV	#-2,-(R3)	;SET UP LIST INFORMATION WITH AN
	MOV	#-1,-(R3)	;END PSECT (-1) AND A END LIST (-2) MARKER

.SBTTL	-	MAJOR LOOP TO PROCESS CORRECTION FILE

3$:	JSR	PC,NEWBLK	;GET NEXT FB BLOCK
	MOV	R5,-(SP)	;RECBFL NEEDS CONTENTS OF R5, SO SAVE IT
	SUB	#2,@SP		;CORRECT FOR TXT LENGTH WORD, SAVE FOR LATER
	JSR	PC,RECBFL	;FILL RECBF WITH FB RECORD TO PROCESS
	MOV	(SP)+,R5	;R5 = DATA BYTES IN TXT RECORD
	MOV	RECBF+4,R0	;R0 = RECORD TYPE
	CMPB	#EOMOD,R0	;END OF MODULE?
	BEQ	ENDMOD		;= -> YES, GO PROCESS INPUT FILE
	CMPB	#TXTBLK,R0	;TXT BLOCK?
	BEQ	TXT		;GO PROCESS TXT BLOCK
	CMPB	#RLDTYP,R0	;RLD BLOCK?
	BNE	3$		;NE -> NO, GET NEXT RECORD
	;BEQ	RLD		;= -> YES, PROCESS IT			;MAS02-

.SBTTL	-	RLD BLOCK PROCESSING

;+
; HAVE A CORRECTION FILE RLD BLOCK. LOOK FOR LC DEFINITION COMMANDS,	;MAS02+
; AND PROCESS THESE. EACH NEW LC DEF. PSECT IS ADDED TO THE END OF THE TXT 
; LIST IF THERE IS ROOM, AND THE CURRENT PSECT POINTER IS UPDATED (R3).
; A RE-OCCURANCE OF AN OLD PSECT ONLY UPDATES THE CURRENT PSECT
; POINTER (R3). ONLY LC DEF. COMMANDS ARE IMPORTANT IN CORRECTION FILE
; RLD BLOCKS; ALL OTHER RLD COMMANDS ARE IGNORED.
;-

RLD:	JSR	PC,SCRLD	;GO SCAN RLD, AND INSERT PSECTS IN LIST
	BR	3$		;GET NEXT FB BLOCK	

.SBTTL	-	RETURN TO INPUT FILE PROCESSING

ENDMOD:	DECB	IRAREA		;INPUT FILE CHANNEL, NOW REPOSITION 
	CALLR	POINT		;INPUT FILE (POINT WILL RETURN)		;MAS02-

.SBTTL	-	TXT BLOCK PROCESSING

;+
; WE HAVE A CORRECTION FILE TXT BLOCK.					;MAS02+
; THE FOLLOWING CONDITIONS ARE VALID DURING TXT BLOCK SCANING.
; (THERE MUST HAVE BEEN AT LEAST ONE RLD BLOCK BEFORE THE FIRST TXT BLOCK 
; TO DEFINE THE PSECT.)
; 
; INPUT:
; 	ENDTXT 	-> 	POINTER TO LOC AFTER END TXT LIST
;	PSECT  	-> 	POINTER TO START OF CURRENT PSECT
;	
; REGISTER USE:
;	R1 	-> 	POINTER TO LOC AFTER END OF TXT LIST
;	R3 	-> 	POINTER TO TXT LOCATION PROCESSING IN LIST
;	@R3 	-> 	OLD LOCATION
;	R0  	=	R3 +2	-> OLD LENGTH
;	@R0 	=	2(R3) 	=  OLD LENGTH
;	R2 	=	NEW TXT LOCATION 
;	R5 	=	NEW TXT LENGTH
;
; OUTPUT:
;	ENDTXT 	-> 	POINTER TO NEW END OF LIST (POSSIBLY UNCHANGED)
;	TXT LOCATION/LENGTH LIST AJDUSTED FOR NEW TXT INFORMATION
;	R4,R5  UNCHANGED
;-

4$:	ERROR$	ERR23,E$F,E$FIL	;CORRECTION FILE MISSING RLD RECORD

TXT:	MOV	R4,-(SP)	;SAVE REG
	MOV	PSECT,R3	;SET R3 TO START OF CURRENT PSECT
	BEQ	4$		;0 -> NO RLD LC DEF COMMAND IN CORRECTION OBJ
	MOV	ENDTXT,R1	;SET R1 -> POINTER TO LOC AFTER TXT LIST
	MOV	RECBF+6,R2	;GET LOAD ADDR FROM TXT BLOCK 

.SBTTL 	- 	MAJOR LOOP TO PROCESS TXT INFORMATION LIST FOR CURRENT PSECT

5$:	CMP	(R3)+,(R3)+	;SET R3 -> FIRST LOCATION AFTER PSECT NAME,
				;OR NEXT TXT BLOCK IN LIST
	CMP	#-1,@R3		;IS IT ALSO THE LAST LOCATION IN PSECT?
	BEQ	12$		;= -> AT END OF PSCET INFO, INSERT TXT HERE
	MOV	R3,R0		;SET UP R0 TO POINT TO 
	TST	(R0)+		;OLD LENGTH = R3+2
	CMP	@R3,R2		;DO TXT BLOCKS HAVE THE SAME START LOC?
	BHI	8$		;HI -> OLD START IS HIGHER THAN NEW START
	BLO	6$		;LO -> OLD START IS LOWER THAN NEW START
	;BEQ FALLS THRU		;EQ -> STARTING LOCATION ARE THE SAME	;MAS02-

.SBTTL	-	KEY FOR TXT COMPARES

;+
; DO COMPARES ALWAYS 			OLD,NEW				;MAS02+
; ALSO LOCATIONS TEST AS 		BHI AND BLO
;      LENGTHS TEST AS 			BGE AND BLE
;
; KEY:
;
; LO = OLD LOCATION IN LIST	 	@R3
; SO = OLD SIZE (LENGTH) IN LIST	2(R3) = @R0
; LN = NEW LOCATION 			R2
; SN = NEW SIZE (LENGTH) 		R5				;MAS02-
;-

.SBTTL	-	NEW AND OLD TXT BLOCKS HAVE SAME START LOCATION

;+
; HAVE TXT BLOCKS WITH IDENTICAL START LOCAIONS.	 LN = LO	;MAS02+
;
; POSSIBLE COMBINATIONS:
;
;		(1)			(2)			(3)		
; LN=LO->!---------------!LN=LO->!---------------!LN=LO->!---------------!
; 	 !		 !	 !		 !	 !		 !
; SN=SO->!---------------!   SN->!---------------!   SO->!---------------!
;		!		 !		 !	 !		 !
;		V	     SO->!---------------!   SN->!---------------!
;	IGNORE NEW			!			!
;					V			V
;				IGNORE NEW		REPLACE SO WITH SN
;-

	CMP	@R0,R5		;ARE THEY ALSO THE SAME LENGTH?
	BGE	15$		;GE -> NEW IS COVERED BY EXISTING ONE (1 OR 2)
	BR 	14$		;USE LENGTH OF NEW BLOCK		;MAS02-

.SBTTL	-	NEW TXT BLOCK START LOCATION HIGHER THAN OLD START LOCATION

;+
; HAVE TXT BLOCK WITH NEW START HIGHER THAN OLD START. 		LN > LO	;MAS02+
;
; POSSIBLE COMBINATIONS
;
;			(1)				(2)
;	    LO->!---------------!	    LO->!---------------!
;		!		!		!		!
;	    SO->!---------------!	    SO->!---------------!<- NO GAP 
;		:	GAP	:	    LN->!---------------!BETWEEN
;	    LN->!---------------!			!
;			!				!
;			V				V
;		TRY NEXT IN LIST,		CONTIGUIOUS, LO + SO = LN,
;		LO + SO < LN			UPDATED LENGTH = SN + SO 
;
;			(3)				(4)
;	    LO->!---------------!	    LO->!---------------!
;		!		!		!		!
;	    LN->!---------------!	    LN->!---------------!
;		!		!		!		!
;	    SN->!---------------!	    SO->!---------------!
;		!		!		!		!
;	    SO->!---------------!	    SN->!---------------!
;			!				!
;			V				V
;		IGNORE, NEW INSIDE OLD,		OLD OVERLAPS NEW,
;		LO + SO > LN + SN		LO + SO < OR = LN + SN,
;						UPDATED LEN = SN + (LN - LO)
;-

6$:	MOV	@R3,R4		;COPY R3 = OLD LOCATION
	ADD	@R0,R4		;ADD OLD LENGTH, R4 = LO + SO
	CMP	R4,R2		;COMPARE OLD LENGTH+2 AND OLD LOC TO NEW LOC
				;(CMP HIGHEST OLD LOC+2 TO LOWEST NEW LOC)
	BLO	5$		;LO -> NO OVERLAP, TRY NEXT IN LIST (1)
	BNE	7$		;NE -> TEST OVERLAP OR ONE INSIDE (3) OR (4)
	ADD	R5,@R0		;= -> CONGIGUIOUS BLOCKS, ADD LENGTHS (2)
	BR	15$		;AND GET ANOTHER FB BLOCK

7$:	MOV	R5,R0		;PUT LN + SN INTO
	ADD	R2,R0		;R0 FOR COMPARE
	CMP	R4,R0		;COMPARE HIGHEST OLD LOC TO HIGHEST NEW
	BHIS	15$		;OLD INCLUDES ALL OF NEW ONE, IGNORE NEW (3)
	SUB	@R3,R0		;OVERLAP (4),CALC NEW LENGTH = SN + (LN - LO) 
	BR	11$		;AND STORE IN TXT INFORMATION		;MAS02-

.SBTTL	-	NEW TXT BLOCK START LOCATION LOWER THAN OLD START LOCATION

;+
; HAVE TXT BLOCK WITH NEW START LOWER THAN OLD START. 		LN < LO	;MAS02+
;
; POSSIBLE COMBINATIONS
;
;			(1)				(2)
;	    LN->!---------------!	    LN->!---------------!
;		!		!		!		!
;	    SN->!---------------!	    SN->!---------------!<- NO GAP 
;		:	GAP	:	    LO->!---------------!BETWEEN
;	    LO->!---------------!			!
;			!				!
;			V				V
;		INSERT BEFORE THIS 		CONTIGUOUS, LN + SN = LO,
;		OLD TXT BLK,			UPDATED LOCATION = LN
;		LN + SN < LO			UPDATED LENGTH = SO + SN
;
;			(3)				(4)
;	    LN->!---------------!	    LN->!---------------!
;		!		!		!		!
;	    LO->!---------------!	    LO->!---------------!
;		!		!		!		!
;	    SO->!---------------!	    SN->!---------------!
;		!		!		!		!
;	    SN->!---------------!	    SO->!---------------!
;			!				!
;			V				V
;		OLD INSIDE NEW,			NEW OVERLAPS OLD, 
;		LO + SO < OR = LN + SN		LN + SN < LO + SO,
;		UPDATED LOCATION = LN		UPDATED LOCATION = LN
;		UPDATED LENGTH = SN		UPDATED LEN = SO + (LO - LN)
;-

8$:	MOV	R2,R4		;BUILD LN + SN IN R4
	ADD	R5,R4		;THIS = HIGHEST NEW LOCATION+2
	CMP	@R3,R4		;TEST FOR (1), IS LO > LN + SN ?
	BHI	12$		;HI -> YES, INSERT NEW TXT INFO HERE (1)
	BNE	9$		;NE -> NO, EITHER INSIDE, OR OVERLAP
	;BEQ FALLS THRU		;EQ -> CONTIGUOUS BLOCK

; EQUAL -> HAVE CONTIGUOUS TXT BLOCKS. (2)

	MOV	R2,@R3		;LOCATION = THAT FROM NEW TXT BLOCK,
	ADD	R5,@R0		;LENGTH = SUM OF BOTH BLOCKS LENGTHS
	BR	15$		;AND DO NEXT BLOCK

; HAVE EITHER ONE INSIDE (3), OR OVERLAP (4)

9$:	MOV	@R0,R0		;PUT LO + SO IN R0
	ADD 	@R3,R0		;FOR COMPARE
	MOV	R2,@R3		;RESET LOCATION TO NEW ONE. THEN
	CMP	R0,R4		;COMPARE HIGHEST OLD, AND HIGHEST NEW LOCS
	BHI	10$		;HI -> OVERLAP (4)
	MOV	R5,2(R3)	;HAVE OLD INSIDE NEW (3), REPLACE OLD LOC 
	BR	15$		;AND OLD LENGTH WITH NEW, AND DO NEXT

; KNOW WE HAVE OVERLAP (4)

10$:	SUB	R2,R0		;NEW LENGTH = SO + (LO - LN)
11$:	MOV	R0,2(R3)	;IN TXT INFORMATION
	BR 	15$		;AND DO NEXT

.SBTTL	-	INSERT NEW TXT INFORMATION IN LIST

;+
; INPUT:
;	R1 	-> 	TEMP POINTER TO LOC AFTER END TXT LIST
;	R2 	=  	NEW LOCATION TO BE INSERTED
;	R3 	-> 	POINTER TO LOCATION AT WHICH LIST WAS SPLIT
;	R5 	=  	NEW LENGTH TO BE INSERTED
;	
; REGISTER USAGE:
;	R0 	-> 	TEMP POINTER TO LOC TO SLIDE DOWN +2
;	R4 	-> 	TEMP POINTER TO LOC INWHICH TO SLIDE +2
;
; OUTPUT:
; 	ENDTXT 	-> 	UPDATED POINTER TO NEW END OF LIST
;-

12$:	MOV	R1,R0		;COPY R1 = NEXT FREE LOCATION IN LIST
	ADD	#4,R1		;NEED 4 MORE BYTES OF ROOM
	CMP	R1,@#HIGH	;ARE WE OUT OF SPACE?
	BHIS	1$		;HIS -> YES, NOT ENOUGH MEMORY
	MOV	R1,R4		;COPY NEW END OF LIST
13$:	MOV	-(R0),-(R4)	;NO, SHIFT INFORMATION DOWN BY 4 BYTES IN LIST
	CMP	R0,R3		;ARE WE AT THE PLACE TO INSERT TXT?
	BNE	13$		;NE ->NO, LOOP TILL ALL INFORMATION MOVED
	MOV	R2,(R0)+	;INSERT NEW LOCATION
14$:	MOV	R5,@R0		;INSERT NEW LENGTH

.SBTTL	-	GET NEXT FB BLOCK

15$:	MOV	R1,ENDTXT	;SAVE END OF TXT POINTER
	MOV	(SP)+,R4	;RESTORE REG
	BR	3$		;GET A NEW FB BLOCK

.DSABL LSB								;MAS02-

.SBTTL 	WRGSD	WRITE GSD RECORDS TO OUTPUT FILE

;+
; INPUT:
;	R1 	-> 	GSD ENTRIES TO OUTPUT
;
; USAGE:
;	R2 	=	# OF BYTES TO OUTPUT
;	R3	=	# OF BYTES IN FORMATTED BINARY RECORD
;
; CLOBBERS R0,R1,R2
;-

.ENABL	LSB 

WRGSD:	MOV	#GSDSZ,R2	;SET BYTE COUNT FOR 1 GSD ITEM
	ADD	R2,R3		;UPDATE BYTE COUNT
	MOV	(PC)+,R0	;GET ADDRESS OF BUFFER
CURBF::	 .BLKW			;CURRENT BUFFER ADDRESS
1$:	MOVB	(R1)+,(R0)+	;MOVE GSD RECORD TO BUFFER
	SOB	R2,1$
	MOV	R0,CURBF	;SAVE BUFFER POINTER
	CMP	#RECSIZ-GSDSZ,R3 ;ENOUGH ROOM FOR ANOTHER RECORD?
	BHI	2$		;YES IF HI
WRGSD2:	MOV	R3,R2		;SET BYTE COUNT
	JSR	PC,PUT		;WRITE THE RECORD
WRGSD4:	MOV	#RECBF+6,CURBF	;RESET CURRENT BUFFER POINTER
	MOV	#STGSD,RECBF+4	;INSERT START GSD RECORD IN BUFFER
	MOV	#6,R3		;SET BYTE COUNT
2$:	RTS	PC

.DSABL	LSB

.SBTTL	CPYFL	COPY INPUT MODULE TO OUTPUT, SKIP GSD RECORDS.

;+
; COPY INPUT AND CORRECTION MODULES TO THE OUTPUT FILE. CALCULATE
; CHECKSUMS FOR THE MODULES AT THE SAME TIME.  ALSO,
; SCAN INPUT FILE RLD AND TXT RECORDS, AND ELIMINATE RLDS AS
; REQUIRED (SCRLD: DOES THE WORK). SCAN CORRECTION FILE RLD RECORDS,
; AND UPDATE SECTION NUMBERS AS REQUIRED (SCRLD:).
;-

.ENABL	LSB

CPYFL:
1$:	JSR	PC,NEWBLK	;GET A INPUT RECORD
	JSR	PC,RECBFL	;FILL RECBF WITH FB RECORD
	MOV	#RECBF+2,R3	;SETUP R3 FOR CHECKSUM CALC

; CALCULATE PAT CHECKSUM, DON'T COUNT FB 1 OR ITS CHECKSUM

	MOV	@R3,R5		;GET BYTE COUNT
	CMPB	-(R5),-(R5)	;DON'T COUNT 1ST WORD
	TSTB	-(R1)		;BACKUP OVER CHECKSUM BYTE
2$:	DEC	R5		;DECREMENT BYTE COUNT
	BMI	3$		;IF MI DONE WITH CHECKSUM
	CLR	-(SP)		;CLEAR A WORD
	MOVB	-(R1),@SP	;GET A BYTE (WORKING BACK)
	ADD	(SP)+,@(PC)+	;UPDATE CHECKSUM
CKSUM::	 .WORD	INCK		;ADDRESS OF CURRENT CHECKSUM
 	BR	2$		;GO AGAIN

; CHECK RECORD TYPE CURRENTLY PROCESSING, AND GO TO CORRECT ROUTINE

3$:	MOV	RECBF+4,R0	;RECORD TYPE
	CMPB	#STGSD,R0	;GSD RECORD?
	BEQ	1$		;YES IF EQ SO IGNORE IT
	CMPB	#EOGSD,R0	;END GSD RECORD?
	BEQ	1$		;YES IF EQ SO IGNORE IT
	CMPB	#EOMOD,R0	;END OF MODULE?
	BEQ	6$		;IF EQ YES, EXIT
	CMPB	#TXTBLK,R0	;IS THIS A TXT BLOCK?			;MAS02+
	BNE	4$		;NE -> NOT TXT BLOCK
	MOV	RECBF+6,(PC)+	;SAVE LOCATION OF TXT BLOCK. ONLY 
TXTLOC:: .BLKW			;REQUIRED FOR INPUT FILE PROCESSING.

; SCRLD: JUST RETURNS IF THE RECORD IS NOT AN RLD RECORD (C=0)

4$:	JSR	PC,SCRLD	;SCAN RLD
	BCS	1$		;RLD BLOCK ELIMINATED, NO OUTPUT 	;MAS02-
5$:	MOV	@R3,R2		;RECORD LENGTH
	JSR	PC,PUT		;COPY RECORD TO OUTPUT
	BR	1$		;PROCESS NEXT RECORD

6$:	TST	@CKSUM		;TEST CHECKSUM RESULT
	BNE	7$		;IF NE OK
	INC	@CKSUM		;FORCE NON-ZERO RESULT
7$:	RTS	PC		;GET ADDRESS OF INPUT FILE FDB
.DSABL	LSB

.SBTTL	RECBFL	FILL RECBF WITH FB BLOCK

;+
; CODE REMOVED FROM CPYFL						;MAS02
;
; INPUT:
;	R5	=	LENGTH OF RECORD IN BYTES
;	R4	->	POINTER TO RECORD IN INPUT BUFFER
;
; OUTPUT:
;	R0,R5 CLOBBERED
;	NEW RECORD IN RECBF
;-

RECBFL:	MOV	#RECBF+2,R1	;R1 -> RECORD BUFR
	MOV	R5,@R1		;LENGTH OF RECORD
	ADD	#6,(R1)+	;WAS REDUCED BY 6 BYTES
	MOV	R0,(R1)+	;R0 ALLREADY HAS RECORD TYPE
1$:	JSR	PC,BYTE		;GET REMAINDER OF RECORD
	MOVB	R0,(R1)+
	DEC	R5		;LOOP FOR ENTIRE RECORD INCLUDING
	BPL	1$		;CHECKSUM BYTE
	RTS	PC

.SBTTL	PUT	WRITE A RECORD TO THE OUTPUT FILE

;+
; INPUT:
;	R2 	= 	RECORD LENGTH IN BYTES
;	RECBF 	= 	RECORD BUFFER
;
; CLOBBERS R0,R1,R2
;-

PUT:	MOV	#RECBF,R1	;ADR OF RECORD
	MOV	R2,2(R1)	;LENGTH OF RECORD IN BYTES
	CLR	-(SP)		;CLEAR A WORD FOR RECORD CHECKSUM(RT-11)
1$:	MOVB	(R1)+,R0	;R0 = BYTE TO OUTPUT
	ADD	R0,@SP		;ADD UP THE BYTES
	JSR	PC,PUTBYT	;TO THE OUTPUT FILE
	SOB	R2,1$		;LOOP FOR RECORD
	NEG	@SP		;CHECKSUM + ALL BEFORE = 0
	MOV	(SP)+,R0
	CALLR	PUTBYT		;OUTPUT CHECKSUM BYTE

.SBTTL	WRTBLK	FORMATTED BINARY BLOCK OUTPUT ROUTINE

;+
; INPUT:
;	R0 	= 	TYPE CODE
;	R5 	=  	NUMBER OF DATA BYTES IN THE BLOCK(LENGTH)
;	R4 	-> 	DATA TO BE WRITTEN(CURRENT INPUT BUFR POSITION)
;
; THIS REPRODUCES THE INITIAL 3 WORDS OF THE F.B. BLK SINCE THEY MAY NOT
; BE IN THE CURRENT INPUT BUFR.
;-

WRTBLK:	MOV	R0,-(SP)	;SAVE IT FOR LATER
	MOV	#F.BRHC,R0	;HEADER CODE
	JSR	PC,PUTWD
	MOV	R5,R0		;GET CURRENT LENGTH
	ADD	#6,R0		;ADD BACK 6 BYTES FOR F.B. HEADER
	JSR	PC,PUTWD
	MOV	(SP)+,R0	;TYPE OF BLOCK
	JSR	PC,PUTWD
1$:	JSR	PC,BYTE		;GET AN INPUT BYTE IN R0
	JSR	PC,PUTBYT	;WRITE A BYTE
	DEC	R5		;LOOP UNTIL END OF FB BLK
	BPL	1$		;INCLUDING CHECKSUM BYTE
	RTS	PC

.SBTTL	PUTWD	PUT A WORD INTO OUTPUT FILE (R0 = WORD)

; R0 IS BYTE SWAPPED

PUTWD:	JSR	PC,PUTBYT	;LOW ORDER BYTE IS OUTPUT
	SWAB	R0		;PREPARE FOR HIGH BYTE
;	BR	PUTBYT		;PUTBYT WILL RETURN

.SBTTL	PUTBYT	OUTPUT A BYTE TO THE OUTPUT FILE

;+
; INPUT:
;	R0 	=  	THE BYTE TO OUTPUT
;
; OUTPUT:
;	R0 	= 	SAME AS INPUT
;	A BUFFER IS WRITTEN AS REQUIRED
;-

.ENABL	LSB

PUTBYT:	MOV	R0,-(SP)	;SAVE BYTE TO OUTPUT
	MOV	#OBPTR,R0	;R0 -> OUTPUT BUFR PTR
	TST	@R0		;IF 0 THEN NO OUTPUT REQUESTED
	BEQ	2$
	MOVB	@SP,@(R0)+	;PUT CHAR INTO BUFR
	INC	-(R0)		;BUMP POINTER
	CMP	IBUF,@R0	;AT THE END OF BUFR?
	BHI	2$		;NO
	MOV	(PC)+,@R0	;YES, SET START OF BUFR
OBUF::	 .BLKW			;STARTING ADR OF OUTPUT BUFR
	INC	-(R0)		;BUMP REL BLOCK #
	TST	-(R0)		;R0 -> .WRITW AREA
	.WRITW
	BCC	2$		;NO ERRORS
	TSTB	@#ERRBYT	;WRITE BEYOND EOF ?
	BEQ	1$		;YES IF EQ
	ERROR$	ERR22,E$F,E$PRT	;OUTPUT WRITE ERROR

1$:	ERROR$	ERR20,E$F,E$PRT	;OUTPUT FILE FULL

2$:	MOV	(SP)+,R0	;RESTORE IT
	RTS	PC

.DSABL	LSB

.PSECT	IMPURE,D,GBL

.SBTTL	-	PUTBYT OUTPUT .WRITW REQUEST AREA

	.BYTE	0	;OUTPUT CHANNEL #
	.BYTE	11	;WRITE EMT CODE
	.WORD	-1	;OUTPUT BLK # (INIT TO -1 FOR BUMP BEFORE WRITE)
OBPTR::	.WORD	0	;OUTPUT BUFR POINTER (0 MEANS NO OUTPUT)
	.WORD	OBFSIZ/2 ;WORD COUNT
	.WORD	0	;INDICATE WAIT FOR COMPLETION

.SBTTL	OBSCN	DECODE STANDARD OBJECT MODULE FORMAT

;+
; THIS SUBROUTINE IS CALLED TO READ AN OBJECT MODULE AND DISPATCH
; TO PROCESSING ROUTINES FOR EACH RECORD AND BLOCK TYPE. THE DISPATCH
; TABLE FOR BLOCK TYPES AND RECORD TYPES WITHIN BLOCK IS SUPPLIED
; BY THE CALLER.
; 
; INPUT:
;	DISPATCH TABLE HAS THE FOLLOWING FORMAT:
;
;	BLKVCT:	.WORD	ILFMT		;DISPATCH VECTOR -BLOCK TYPE 0
;		.WORD	STGSD		;DISPATCH VECTOR-BLOCK TYPE 1
;			.
;		.WORD	MODND		;END OF BLOCK DISPATCHER
;	GSDVCT:	.WORD	MODNME		;GSD DISPATCH TABLE
;		.WORD	SCTNME		;...
;			.
;		.WORD	VIDENT		;END OF GSD DISPATCH TABLE
;
; OUTPUT:
;	THE APPROPRIATE ROUTINE IS CALLED WITH:
;
;	R5 = REMAINING BYTE COUNT IN BLOCK TO BE PROCESSED
;	CALLED ROUTINE MUST RETURN THE UPDATED BYTE COUNT IN R5
;
;	THE FOLLOWING BLOCK DEPENDANT PARAMETERS ARE ALSO SUPPLIED:
;
;	START OF GSD:
;		R1 = ADDRESS OF LOCAL DESCRIPTOR CONTAINING GSD RECORD
;
; EXCEPT FOR R4 & R5, ALL REGISTERS ARE AVAILABLE FOR USE BY THE CALLED
; ROUTINE.
;
; A RETURN TO THE INITIAL CALLER IS MADE UNDER THE FOLLOWING CONDITIONS:
;	C=1 	->	REACHED END-OF-MODULE RECORD
;	C=0 	->	MAY BE FORCED BY DISPATCHED ROUTINE
;-

.SBTTL	-	FORMATTED BINARY BLOCK DISPATCH TABLE

;+
; THIS IS THE INITIAL STATE AS REQUIRED BY "SRCMN"
; EACH SCAN MADE AFTER THAT MUST PLACE ADDRESSES IN THE TABLE
;-

.PSECT	IMPURE,D,GBL

BLKVCT:	.WORD	ILFMT		; 0 - ILLEGAL FORMAT
	.WORD	GSD		; 1 - START GSD
	.WORD	SKPBLK		; 2 - END GSD
	.WORD	SKPBLK		; 3 - TEXT
	.WORD	SKPBLK		; 4 - RLD
	.WORD	SKPBLK		; 5 - ISD
	.WORD	MODND		; 6 - MODULE END
LGBLK=.-BLKVCT/2-1		; MAXIMUM LEGAL BLOCK TYPE

.SBTTL	-	GSD DISPATCH VECTOR
 
GSDVCT:	.WORD	MODN		; 0 - MODULE NAME
	.WORD	IGNORE		; 1 - SECTION NAME
	.WORD	IGNORE		; 2 - INTERNAL SYMBOL
	.WORD	IGNORE		; 3 - TRANSFER ADDRESS
	.WORD	IGNORE		; 4 - SYMBOL DECLARATION
	.WORD	IGNORE		; 5 - PROGRAM SECTION NAME
	.WORD	IGNORE		; 6 - VERSION IDENTIFICATION
LGSD=.-GSDVCT/2-1		; LARGEST GSD RECORD TYPE
 
LCLSYM:	.BLKW	4		;GSD RECORD STORAGE
 
.PSECT	MAIN

OBSCN:
1$:	JSR	PC,NEWBLK	;GET FB BLK
	CMP	#LGBLK,R0	;LEGAL BLOCK TYPE?
	BLO	ILFMT		;IF LO NO
	ASL	R0		;CONVERT TO WORD OFFSET
	JSR	PC,@BLKVCT(R0)	;DISPATCH ON BLOCK TYPE
	BR	1$		;GO AGAIN
 
ILFMT:	ERROR$	ERR6,E$F,E$FIL	;HAS ILLEGAL RECORD

.SBTTL	-	DISPATCH ON GSD RECORD TYPE
 
.ENABL	LSB

1$:	MOV	#LCLSYM,R1	;GET ADDRESS TO STORE RECORD
	MOV	R1,R3		;SAVE SYMBOL ADR FOR LATER
	MOV	#4,R2		;4 WORDS IN EACH GSD ITEM
2$:	JSR	PC,GETWD	;GET NEXT INPUT WORD
	MOV	R0,(R3)+	;SAVE IN TEMP BUFFER
	SOB	R2,2$		;REPEAT
	MOVB	S$YCOD(R1),R0	;GET RECORD TYPE
	CMP	#LGSD,R0	;LEGAL RECORD TYPE?
	BLO	3$		;IF LO NO
	ASL	R0		;MAKE WORD FORMAT
	JSR	PC,@GSDVCT(R0)	;CALL RECORD DEPENDANT ROUTINE
GSD:	TST	R5		;ANY MORE TO PROCESS
	BGT	1$		;IF GT GO AGAIN
	CALLR	BYTE		;GET CHECKSUM BYTE

3$:	ERROR$	ERR10,E$F,E$FIL	;HAS BAD GSD

.DSABL	LSB

.SBTTL	MODND	END OF MODULE
 
MODND:	COM	(SP)+		;CLEAN STACK & C=1
IGNORE:	RTS	PC

.SBTTL	BYTE	GET NEXT INPUT BYTE INTO R0

;+
; THIS ROUTINE IS CALLED TO GET THE NEXT BYTE FROM THE CURRENT INPUT
; FILE. IF THERE ARE NO MORE BYTES IN THE CURRENT BUFFER,
; THEN THE NEXT BUFFER IS READ AND THE NEXT BYTE IS RETURNED TO THE CALLER.
; BEFORE THE FIRST CALL IS MADE FOR EACH FILE, ENDBUF MUST BE ZEROED
; IN ORDER TO FORCE A READ OF THE FIRST BUFFER.
;
; INPUT: 
;	R4 	-> 	CURRENT BUFFER POSITION
;       ENDBUF 	-> 	BYTE AFTER THE LAST BYTE OF THE CURRENT INPUT BUFFER
;-

.ENABL	LSB

1$:	JSR	PC,NEWBUF	;GET ANOTHER BUFFER
BYTE:	CMP	(PC)+,R4	;END OF INPUT BUFFER?
ENDBUF:: .BLKW
	BLOS	1$		;YES
	CLR	R0		;BECAUSE OF SIGN EXTEND
	BISB	(R4)+,R0	;GET BYTE IN R0
	RTS	PC

.DSABL	LSB

.SBTTL	NEWBLK	GET NEXT FORMATTED BINARY BLOCK FOR INPUT

;+
; INPUT: 
;	R4 	-> 	CURRENT BUFFER POSITION
;
; OUTPUT: 
;	R4 	-> 	1ST DATA WORD OF NEW BLOCK
;	R5 	= 	NUMBER OF DATA BYTES IN THE BLOCK.
;	R0 	= 	TYPE CODE OF THE BLOCK
;
; DATA STRUCTURE IS: .BYTE 1,0	.WORD	<LENGTH>	.BYTE	<TYPE>,0
;-

NEWBLK:
1$:	JSR	PC,BYTE		;GET NEXT INPUT BYTE
	TSTB	R0		;IS BYTE A 0 ?
	BEQ	1$		;YES, SKIP ALL NULL BYTES
	DECB	R0		;NEW BLK ST WITH A 1
	BNE	1$		;MODE ERROR, NOT FB BLOCK
	MOV	@(PC)+,(PC)+	;REMEMBER THE BEGINING OF EACH RECORD
	 .WORD	CURBLK
RELBLK:: .BLKW
	MOV	R4,(PC)+	;REL BLK # & BYTE OFFSET(+1)
BYTOFF:: .BLKW
	JSR	PC,BYTE		;SKIP HIGH BYTE OF F.B.
	JSR	PC,GETWD	;ASSEMBLE THE LENGTH WORD
	MOV	R0,R5		;COPY OF LENGTH
	SUB	#4,R5		;CALC CORRECTED LEN
;	BR	GETWD		;GET TYPE CODE & IGNORE HIGH BYTE
				;'GETWD' WILL RETURN

.SBTTL	GETWD	GET A WORD FROM OBJ FILE INTO R0

;+
; INPUT:
;	R4 	-> 	CURRENT BUFFER POSITION
;	R5 	= 	# OF DATA BYTES IN THE F.B. BLOCK
;
; OUTPUT:
;	R5 IS REDUCED BY 2
;-

GETWD:	JSR	PC,BYTE		;GET NEXT INPUT BYTE (LOW ORDER)
	MOV	R0,-(SP)	;SAVE IT
	JSR	PC,BYTE		;GET HIGH ORDER BYTE
	SWAB	R0		;PROPER PLACE
	BISB	(SP)+,R0	;SET IN LOW ORDER PART
	SUB	#2,R5		;BOOKKEEP THE BYTE COUNT
RTSPC:	RTS	PC

.SBTTL	SKPBLK	SKIP FB BLOCK ON INPUT

;+
; INPUT:
;	R4 	= 	CURRENT BUFR POSITION
;	ENDBUF 	= 	END OF CURRENT INPUT BUFFER
;	R5 	= 	LENGTH OF BLOCK
;
; OUTPUT:
;	R4 & ENDBUF UPDATED IF REQUIRED
;	CLOBBERS R0
;-

SKPBLK: INC	R5		;INCLUDE CHECKSUM BYTE
1$:	ADD	R5,R4		;LENGTH TO CURRENT POSITION
	CMP	ENDBUF,R4	;GONE PAST END OF BUFR?
	BHI	RTSPC		;NO, JUST RETURN
	MOV	R4,R5		;YES, HOW MUCH INTO NEXT BUFR
	SUB	ENDBUF,R5	;# TO PASS OVER IN NEXT BUFR
	JSR	PC,NEWBUF	;GET MORE
	BR	1$		;TRY AGAIN

.SBTTL	NEWBUF	READ NEXT INPUT BUFFER

;+
; INPUT:
;	CURBLK 	= 	RELATIVE INPUT BLK # -1 (BUMPED BEFORE READ)
;	ENDBUF 	= 	END OF CURRENT BUFR(IF R4.GE.ENDBUF, BUFR IS EXHAUSTED
;
; OUTPUT:
;	R4 	-> 	START OF INPUT BUFR
;	ENDBUF 	= 	END OF INPUT BUFR
;
; DESTROYS R0!!!
;-

NEWBUF:	MOV	#IBUF,R0	;R0 -> INPUT BUFR ADR
	MOV	@R0,R4		;RESET BUFR PTR
	INC	-(R0)		;BUMP THE BLK # BEFORE READ
	TST	-(R0)		;R0 -> EMT REQUEST AREA
	.READW
	BCC	1$		;NO ERROR
	TSTB	@#ERRBYT	;0=EOF, 1=HARDWARE, 2=CHAN NOT OPEN
	BNE	2$		;NOT EOF SO GIVE ERROR
1$:	ASL	R0		;WORDS READ TO BYTES READ
	BEQ	3$		;IF=0 THEN EOF
	ADD	R4,R0		;NOW THE END OF BUFR
	MOV	R0,ENDBUF	;UPDATE ENDBUF
	RTS	PC

2$:	ERROR$	ERR5,E$F,E$FIL	;READ ERROR

.SBTTL	-	END-OF-INPUT FILE PROCESSING

3$:	TST	(SP)+		;GET RID OF RETURN ADR
	JMP	@(PC)+		;GOTO PROPER EOF PROCESSING
EOF:	 .WORD	ILFMT		;ADR OF ROUTINE TO GOTO

.SBTTL	-	INPUT BUFFER INFORMATION

.PSECT	IMPURE,D,GBL

; NEXT 5 WORDS MUST BE IN THIS ORDER

IRAREA::.BYTE	CORCHN		;INPUT CHANNEL NUMBER
	.BYTE	10		;.READ EMT CODE
CURBLK::.WORD	-1		;BLOCK NUMBER(INIT TO -1 FOR BUMP BEFORE READ)
IBUF::	.BLKW			;INPUT BUFR ADR(ALSO END OF OUTPUT BUFR)
	.WORD	IBFSIZ/2	;INPUT BUFR SIZE WORD COUNT
	.WORD	0		;.READW INDICATOR MUST BE ZERO

.PSECT	MAIN

.SBTTL	POINT	POSITION THE INPUT FILE & READ IN BUFR

;+
; POSITION THE INPUT FILE AT THE BLOCK # & BYTE OFFSET AS DETERMINED
; BY "NEWBLK" ROUTINE.
;
; OUTPUT:
;	R4 	-> 	PROPER BYTE OF CURRENT INPUT FILE
;	CLOBBERS R0 & R1
;-

POINT:	MOV	(PC)+,R0	;REL BLK #
FILBLK:: .BLKW			;BLK # OF INPUT FILE FOR FOUND MODULE
	MOV	(PC)+,R1	;BUFR PTR AT TIME OF MARK
FILBYT:: .BLKW			;INPUT FILE BYTE OFFSET POSITION
	SUB	IBUF,R1		;LESS START OF BUFR
	DEC	R1		;WAS 1 BYTE BEYOND
	BPL	1$		;OK IF +
	DEC	R0		;LAST BYTE IN BLOCK, SO REDUCE REL BLK
	MOV	#777,R1		;SET LAST BYTE IN BLOCK
1$:	DEC	R0		;BUMPED BEFORE READ
	MOV	R0,CURBLK	;SET REL BLK # FOR READ
	JSR	PC,NEWBUF	;READ IT IN
	ADD	R1,R4		;SET BUFR PTR CORRECTLY
	RTS	PC

.SBTTL	ALBLK	ALLOCATE A BLOCK OF FREE MEMORY

;+
; THIS ROUTINE IS CALLED TO ALLOCATE A BLOCK OF STORAGE FROM THE FREE
; STORAGE POOL. IF THE BLOCK CANNOT BE ALLOCATED, THEN A FATAL ERROR
; MESSAGE IS ISSUED. ELSE THE BLOCK IS ALLOCATED AND ZEROED & THE
; ADDRESS IN RETURNED TO THE CALLER.
;
; INPUT: 
;	R0 	= 	SIZE OF BLOCK TO ALLOCATE IN BYTES(MUST BE EVEN)
;
; OUTPUT:
;	R0 	= 	ADDRESS OF ALLOCATED BLOCK
;-

ALBLK:	MOV	R1,-(SP)	;SAVE R1
	MOV	#LIMIT,R1	;R1 -> FREE SPACE PTR
	MOV	@R1,-(SP)	;SAVE START OF FREE SPACE
	ADD	R0,@R1		;UPDATE FREE SPACE PTR
	CMP	@R1,@#HIGH	;HAVE WE EXCEEDED SPACE ALLOWED ?
	BHIS	MEMERR		;YES IF .GE.
	MOV	@SP,R1		;R1 -> START OF AREA TO CLEAR
	ASR	R0		;CONVERT TO WORDS
1$:	CLR	(R1)+		;CLEAR BLOCK
	SOB	R0,1$
	MOV	(SP)+,R0	;ADR OF ALLOCATED BLK
	MOV	(SP)+,R1	;RESTORE R1
	RTS	PC

.SBTTL	PTSRC	REAL MEMORY SEARCH AND INSERT PACKAGE

;+
; EACH ITEM IN THE LIST IS ASSUMED TO HAVE THE FOLLOWING FORMAT:
;	ITEM:	.WORD	NEXT	;LINK TO NEXT (0=LAST)
;		.WORD	VAL	;FIRST HALF OF KEY VALUE
;		.WORD	VAL	;SECOND HALF OF KEY VALUE
;		.WORD	DATA	;ANY DATA
;		.WORD	DATA	;ANY DATA
;		  .
;		.WORD	DATA	;END OF ITEM
;-

.SBTTL	ISYMR	INSERT ITEM IN LEXICALLY ORDERED LIST

;+
; THIS ROUTINE IS CALLED TO INSERT AN ITEM IN A LIST WHOSE KEY VALUES ARE
; IN LEXICAL ORDER.
;
; INPUT:
;	SYMHD	=	LISTHEAD ADDRESS
;	R1	=	ADDRESS OF ITEM TO BE INSERTED
;
; OUTPUT:	NONE
;
; CLOBBERS R0 & R2
;-

ISYMR:	MOV	#S.YLGH,R0	;SET LENGTH OF ENTRY
	JSR	PC,ALBLK	;ALLOCATE CORE BLOCK
	TST	(R0)+		;SKIP LINK TO NEXT PTR
	MOV	R0,R2		;SAVE PTR TO SYMBOL NAME
	JSR	PC,XFERS	;CALL XFERS AS SUBROUTIN TO COPY ITEM 	;MAS02
	MOV	CRSCT,@R0	;SET ADDRESS OF CURRENT SECTION
	MOV	#SYMHD,R0 	;R0 -> SYMBOL LISTHEAD
1$:	MOV	R0,R1		;SAVE ADDRESS OF CURRENT
	MOV	@R0,R0		;R0 -> NEXT ITEM IN LIST
	BEQ	2$		;IF EQ DONE
	CMP	S.YM(R0),@R2	;CHECK FIRST HALF OF KEY
	BLO	1$		;IF LO, GO AGAIN
	BHI	2$		;IF HI, FOUND PLACE TO INSERT
	CMP	S.YM+2(R0),2(R2) ;CHECK SECOND HALF OF KEY
	BLO	1$		;IF LO GO AGAIN
2$:	TST	-(R2)		;BACKUP TO LINK TO NEXT PTR
	MOV	R2,@R1		;LINK NEW ITEM TO PREVIOUS
	MOV	R0,@R2		;LINK CURRENT TO NEW
	RTS	PC

MEMERR:	ERROR$	ERR3,E$F,E$PRT	;INSUFFICIENT MEMORY

.SBTTL	SRCHR	SEARCH LIST IN REAL MEMORY FOR KEY VALUE

;+
; THIS ROUTINE IS CALLED TO SEARCH A LIST (DESCRIBED ABOVE) FOR AN ITEM
; CONTAINING THE SPECIFIED KEY CONTAINED IN S.YM(R1), AND S.YM+2(R1)
;
; INPUT:
;	R0	=	LISTHEAD ADDRESS
;	R1	=	ADDRESS OF CONTAINING KEY VALUE
;
; OUTPUT:
;	C=0 	=> 	KEY VALUE IN LIST
;	R0	=	ADDRESS OF ITEM CONTAINING VALUE
;	R1	=	NUMERICAL POSITION OF ITEM IN LIST
;			(0=FIRST ITEM, 1=SECOND ITEM ETC.)
;
;	C=1 	=> 	KEY VALUE NOT IN LIST & R1 UNCHANGED
;
; CLOBBERS R0
;-

SRCHR:	MOV	#-1,-(SP)	;RESET POSITIONAL COUNT
1$:	INC	@SP		;INCREMENT COUNT
	SEC			;ASSUME KEY NOT IN LIST
	MOV	(R0),R0		;R0 -> NEXT ITEM IN LIST
	BEQ	2$		;IF EQ NOT IN LIST
	CMP	S.YM(R0),@R1	;CHECK FIRST HALF OF KEY
	BNE	1$		;IF NE GO AGAIN
	CMP	S.YM+2(R0),2(R1) ;CHECK SECOND HALF OF KEY
	BNE	1$		;IF NE GO AGAIN
	MOV	@SP,R1		;COPY POSITION IN LIST
2$:	INC	(SP)+		;POP CTR & DON'T CHANGE CARRY
	RTS	PC

.SBTTL	SCRLD	CORRECTION INPUT FILE RLD RECORD SCAN

;+
; SCRLD: IS USED FOR THREE SEPARATE SCANS OF RLD RECORDS.		;MAS02+
; THE FLAG WORD RLDSCN: INDICATES THE TYPE OF SCAN BEING DONE, AND THE 
; ACTION TO BE TAKEN.
;
; 1. RLD LOCATION COUNTER DEFINITION SCAN ON CORRECTION FILE: RLDSCN = 0
;
; THIS ROUTINE SCANS CORRECTION FILE RLD BLOCKS, AND SAVES LC
; DEFINITION INFORMATION IN THE TXT LOCATION LIST. 
;
; INPUT:
;	RECBF	= 	RECORD BUFFER ADDRESS
;	ENDTXT:	-> 	POINTER TO END OF TXT LIST
;	
; REGISTER USAGE:
;	R3 	-> 	POINTER TO NEW PSECT INSERT LOCATION
;	R1 	-> 	POINTER INTO RLD BLOCK
;	R0,R2 	= 	TEMP 
;	CLOBBERS	R0,R1,R2
;
; OUTPUT:
;	PSECT:  -> 	POINTER TO CURRENT PSECT IN TXT LIST
;	ENDTXT: -> 	POINTER TO NEW END OF TXT LIST
;
; 2. INPUT FILE RLD RECORD MODIFICATION: RLDSCN = 1
;
; THE INPUT FILE RLD RECORDS ARE SCANED. IF THEY MODIFIY A LOCATION THAT IS
; ALSO MODIFIED BY A CORRECTION FILE TXT BLOCK, THEN THE RLD INFORMATION
; IN THE INPUT FILE IS ELIMINATED. 
;
; INPUT:
;	TXTLOC: =  	LOCATION FROM THE PRECEEDING TXT BLOCK
;	SKPFLG:	=  	RLD ELIMINATION FLAG
;			0 -> NO RLD ELIMINATION REQUIRED
;		   	1 -> THIS RLD COMMAND IS REMOVED FROM THE RLD BLOCK
; 	PSECT:	-> 	CURRENT PSECT POINTER (FROM INPUT FILE LOC. CNT. DEF)
;		=  	0 IF INPUT FILE PSECT IS NOT IN THE CORRECTION LIST.
;		   	THIS MEANS NO RLD BLOCKS IN PSECT NEED TO BE ALTERED,
;		   	SCAN RLD FOR A LOCATION COUNTER DEFINITION COMMAND.
;			 NONE FOUND -> JUST RETURN C=0
;			 FOUND -> RESET PSECT INFO AND CHECK FOR MORE LC DEF'S
;			 (ONLY LC DEF'S IMPORTANT TILL NEXT TXT BLOCK) 	
; 
; OUTPUT:
;	PROPERLY UPDATED RLD RECORD IS CREATED
;	PSECT: UPDATED IF REQUIRED
;
;	C=0 	-> 	WRITE RLD BLOCK TO OUTPUT FILE
;	C=1 	-> 	ALL OF RLD BLOCK ELIMINATED, GET NEXT FB BLOCK,
;			DO NOT WRITE ANYTHING TO OUTPUT FILE		;MAS02-
;-

;+
; 3. RLD SECTION NUMBER ADJUSTMENT SCAN ON CORRECTION FILE: RLDSCN = -1
;
; THIS SUBROUTINE IS CALLED TO SCAN AN RLD RECORD IN THE CORRECTION
; INPUT FILE IN ORDER TO RE-MAP COMPLEX RELOCATION COMMANDS THAT
; REFERENCE THE SECTION NUMBER. THE CORRECTION FILE SECTION MAPPING TABLE
; IS REFERENCED TO CONVERT THIS VALUE TO THE EQUIVALENT NUMBER FOR THE 
; MODIFIED OUTPUT FILE.
;
; INPUT:
;	CRCMT	=	ADDRESS OF CORRECTION FILE SECTION MAPPING TABLE
;	RECBF 	= 	RECORD BUFR
;
; OUTPUT:
;	THE SECTION NUMBER IN ALL APPROPRIATE RLD RECORDS IS REMAPPED
;	CLOBBERS R0,R1,R2
;	CARRY DOES NOT MATTER
;-

.SBTTL -	COMPLEX RELOCATION RECORD BYTE COUNT TABLE

;+
; EACH BYTE REPRESENTS THE NUMBER OF BYTES IN EACH COMPLEX
; RELOCATION COMMAND. A VALUE OF -1 INDICATES AN ILLEGAL RECORD.
; THE HIGH ORDER BIT SET INDICATES THAT THE SECTION NUMBER ADJACENT
; TO THE COMMAND BYTE MUST BE REMAPPED.
;-
 
.PSECT	BYTE,D

CPCNT:	.BYTE	1		; 0 - NOP
	.BYTE	1		; 1 - ADD
	.BYTE	1		; 2 - SUBTRACT
	.BYTE	1		; 3 - MULTIPLY
	.BYTE	1		; 4 - DIVIDE
	.BYTE	1		; 5 - AND
	.BYTE	1		; 6 - INCLUSIVE OR
	.BYTE	1		; 7 - EXCLUSIVE OR
	.BYTE	1		; 10 - NEGATION
	.BYTE	1		; 11 - COMPLEMENT
	.BYTE	1		; 12 - STORE
	.BYTE	1		; 13 - STORE DISPLACED
	.BYTE	-1		; 14 - ILLEGAL
	.BYTE	-1		; 15 - ILLEGAL
	.BYTE	5		; 16 - FETCH GLOBAL
	.BYTE	204		; 17 - FETCH REL. VALUE
	.BYTE	3		; 20 - FETCH CONSTANT
	.BYTE	1		; 21 - FETCH LIBRARY OFFSET
LGCPL=	.-CPCNT-1		;LARGEST COMPLEX TYPE

.SBTTL	-	RLD BYTE COUNT TABLE

;+
; THIS BYTE TABLE CONTAINS THE NUMBER OF BYTES IN EACH RLD COMMAND TYPE.
; IT IS USED WHEN SCANNING AN RLD RECORD TO LOCATE ANY COMPLEX RLD STRINGS.
;-
 
RLCNT:	.BYTE	-1		; 0 - ILLEGAL FORMAT
	.BYTE	4		; 1 - INTERNAL RELOCATION
	.BYTE	6		; 2 - GLOBAL RELOCATION
	.BYTE	4		; 3 - INTERNAL DISPLACED REL.
	.BYTE	6		; 4 - GLOBAL DISPLACED
	.BYTE	10		; 5 - GLOBAL ADDITIVE
	.BYTE	10		; 6 - GLOBAL ADDITIVE DISPLACED
	.BYTE	10		; 7 - LOCATION COUNTER DEFINITION
	.BYTE	4		; 10 - LOCATION COUNTER MOD.
	.BYTE	2		; 11 - .LIMIT DIRECTIVE
	.BYTE	6		; 12 - SECTION RELOCATION
	.BYTE	-1		; 13 - ILLEGAL FORMAT
	.BYTE	6		; 14 - SECTION DISPLACED
	.BYTE	10		; 15 - SECTION ADDITIVE
	.BYTE	10		; 16 - SECTION ADDITIVE DISPL.
	.BYTE	200		; 17 - COMPLEX RELOCATION
LGRLD=	.-RLCNT-1		; LARGEST RLD RECORD TYPE

.PSECT	MAIN

.ENABL	LSB

SCRLD:	MOV	RECBF+2,R2	;GET BYTE COUNT
	MOV	#RECBF+4,R1	;GET BUFFER ADDRESS
	CMP	(R1)+,#RLDTYP	;RLD RECORD TYPE?
	BNE	1$		;IF NE NO, EXIT
	SUB	#6,R2		;ADJUST BYTE COUNT FOR F.B. HDR
	BNE	3$		;NE -> PROCESS THE BLOCK
1$:	JMP	RTN		;IF EQ DONE

2$:	ERROR$	ERR7,E$F,E$FIL	;HAS BAD RLD

.SBTTL 	-	MAJOR LOOP TO PROCESS RLD RECORDS

3$:	CLR	SKPFLG		;SET FLAG FOR NO RLD ELIMINATION
	MOVB	@R1,R0		;GET RLD TYPE
	BIC	#177600,R0	;CLEAR EXTRANEOUS BITS
	CMP	#LGRLD,R0	;LEGAL RLD TYPE?
	BLO	2$		;NO IF LO
	TST	RLDSCN		;CORRECTION FILE RLD SECTION NO. FIX?	;MAS02+
	BMI	11$		;MI -> CORECTION FILE RLD UPDATE
	BEQ	8$		;0  -> CORRECTION FILE LIST CREATION
	;BNE	FALLS THRU	;NE -> INPUT FILE RLD FIX		;MAS02-

.SBTTL	-	INPUT FILE RLD MODIFICATION	(RLDSCN = 1)

;+
; RLD COMMAND TYPES, AND MODIFICATIONS MADE				;MAS02+
;
; CMD #		DESCRIPTION	ACTION TAKEN
; ----------------------------------------------------------------------------
; 7		LC DEF 		UPDATE CURRENT PSECT DATA, NO RLD MODIFICATION
; 10		LC MOD		IGNORE DATA, NO RLD MODIFICATION 
; 11		LIMIT		IGNORE DATA, NO RLD MODIFICATION 
; ALL OTHERS			REMOVE IF LOCATION IS IN TXT LIST
;-

	CMP	#LCDEF,R0	;IS THIS AN LC DEFINITION COMMAND?
	BNE	4$		;NE -> NOT LC DEFINITION
	JSR	PC,GETPCT	;LOOK FOR PSECT NAME IN TXT LIST
	BR	11$		;LOOK FOR ANOTHER LC IN RLD BLOCK

4$:	CMP	#LCMOD,R0	;IS THIS LC MODIFICATION?
	BEQ	11$		;EQ -> DO NOT MODIFY IT
	CMP	#RLDLIM,R0	;IS THIS A LIMIT?
	BEQ	11$		;EQ -> NO MODIFICATION REQUIRED
	TST	PSECT		;IS THE CURRENT PSECT IN THE TXT LIST?
	BEQ	11$		;EQ -> NO, DO NOT MODIFY THIS RLD CMD

;+
; HAVE TO FIND THE LOCATION CORRESPONDING TO THIS RLD BLOCK, AND DETERMINE
; IF IT SHOULD BE REMOVED FROM THE PSECT LIST
;-
	MOV	R2,-(SP)	;SAVE R2
	MOV	R3,-(SP)	;R3,
	MOV	R4,-(SP)	;AND R4
	MOV	PSECT,R3	;SET UP R3 AS CURRENT PSECT POINTER
	MOVB	1(R1),R2	;GET RLD CMD DISPLACEMENT
	BIC	#177400,R2	;MAKE SURE HIGH BYTE IS CLEAR
	SUB	#4,R2		;ADJUST FOR EXTRA TXT BLOCK BYTES (LENGTH WD)
	ADD	TXTLOC,R2	;AND CURRENT TXT BLOCK LOCATION
5$:	CMP	(R3)+,(R3)+	;FIND FIRST TXT INFORMATION IN PSECT
	CMP	#-1,@R3		;IS THIS THE END OF THE PSECT?
	BEQ	7$		;EQ -> RLD LOC NOT IN LIST
	CMP	@R3,R2		;CMP START LOC OF TXT BLOCK TO RLD LOC
	BEQ	6$		;EQ -> RLD IS IN LIST, ELIMINATE IT
	BHI	7$		;HI -> RLD IS NOT IN LIST
	;BLO	FALLS THRU	;LO -> RLD MAY BE IN THIS TXT LOC.
	MOV	@R3,R4		;GET TXT LOCATION AND
	ADD	2(R3),R4	;ADD IN LENGTH
	CMP	R4,R2		;IS THE RLD LOC IN THIS BLOCK?
	BLOS	5$		;LOS -> NOT IN THIS TXT BLOCK, TRY NEXT
6$:	MOV	#1,SKPFLG	;THE RLD LOC IS IN THE LIST, SET FLAG ->
7$:	MOV	(SP)+,R4	;RESTORE REGS
	MOV	(SP)+,R3
	MOV	(SP)+,R2	;RESTORE BYTE COUNT
	BR	11$		;ELIMINATE RLD CMD ON RETURN		;MAS02-

.SBTTL	-	CORRECTION FILE LIST CREATION RLD SCAN 	(RLDSCN = 0)

;+
; ADD LC DEFINITION PSECT TO CORRECTION FILE TXT LIST IF THIS IS A NEW	;MAS02+
; PSECT NAME. ALSO RESET CURRENT PSECT POINTER.
;
; IF NAME IS ALREADY IN LIST, THEN JUST RESET R3 TO NEW CURRENT PSECT, 
; AND CONTINUE. 
;
; WHEN EITHER THE FIRST PSECT, OR A NEW PSECT NAME HAS BEEN FOUND. INSERT
; NAME AT END OF LIST, AND RESET R3 TO POINT TO THE NEW CURRENT PSECT.
;
; AFTER THE FIRST PSECT HAS BEEN FOUND, THE LIST WILL LOOK AS FOLLOWS:
;
;	!-----------------------!<------STXT:
;	! -1			!
;	!-----------------------!
;	! PSECT NAME IN		!<------R3
;	!-----------------------!
;	! (2 WORDS)		!
;	!-----------------------!<------ADDITIONAL PSECTS WILL BE ADDED HERE
;	! -1			!
;	!-----------------------!
;	! -2			!
;	!-----------------------!
;				 <------ENDTXT:
;-

8$:	CMP	#LCDEF,R0	;IS THIS LC DEFINITION?
	BNE	11$		;NE -> NO, IGNORE IT
	MOV	R1,-(SP)	;SAVE R1 = POINTER IN RLD BLOCK
	MOV	R3,-(SP)
	MOV	R4,-(SP)
	JSR 	PC,GETPCT	;POINT R3 TO PSECT NAME IF IT IS IN LIST
	BCC	10$		;C=0 -> PSECT NAME ALREADY IN LIST
	MOV	(PC)+,R3	;INIT R3
ENDTXT:: .BLKW			;END LIST POINTER
	MOV	R3,R4		;COPY POINTER
	ADD	#6,R4		;ADD PSECT NAME + END PSECT MARKER = 6 BYTES
	CMP	R4,@#HIGH	;DOES IT FIT IN ALLOWABLE SPACE?
	BHIS	MEMERR		;HIS -> NO, ERROR
	MOV	R4,ENDTXT	;RESET END LIST POINTER
	MOV	-(R3),-2(R4)	;MOVE END PSECT, END LIST INFORMATION DOWN
	MOV	-(R3),-4(R4)	;SO PSECT NAME CAN FIT IN
	MOV	#-1,(R3)+	;PUT IN END PSECT MARK FOR PRECEEDING PSECT
	MOV	R3,PSECT	;SET UP NEW CURRENT PSECT POINTER
	CMPB	(R1)+,(R1)+	;POINT R1 AT NAME
	MOVB	(R1)+,(R3)+	;NOW COPY PSECT NAME OVER
	MOVB	(R1)+,(R3)+	;TO THE TXT LIST
	MOVB	(R1)+,(R3)+	;= MOVE 4 BYTES
	MOVB	(R1)+,@R3
10$:	MOV	(SP)+,R4
	MOV	(SP)+,R3
	MOV	(SP)+,R1	;RESTORE R1				;MAS02-

.SBTTL 	-	CORRECTION FILE RLD SECTION NUMBER UPDATE  (RLDSCN = -1)

11$:	MOVB	RLCNT(R0),R0	;GET RLD BYTE COUNT
	MOVB	R0,BYTCNT	;NEED BYTE COUNT IF RLD IS COMPRESSED	;MAS02
	BPL	14$		;IF PL, NOT ERROR OR COMPLEX
	ASLB	R0		;ILLEGAL FORMAT?			;MAS02
	BNE	2$		;IF NE YES

; SCAN A COMPLEX STRING

	CMPB	(R1)+,(R1)+	;R1 -> FIRST COMPLEX COMMAND
	SUB	#2,R2		;ADJUST BYTE COUNT
	MOV	#2,BYTCNT	;ADJ. BYTE COUNT FOR 1ST WORD CMPLX RLD	;MAS02
12$:	MOVB	@R1,R0		;GET COMMAND TYPE
	CMPB	#LGCPL,R0	;LEGAL COMMAND TYPE?
	BLO	2$		;NO IF LO
	MOVB	CPCNT(R0),-(SP)	;GET COUNT
	BPL	13$		;IF PL UPDATE COUNT AND POINTERS
	CMPB	#-1,@SP		;ILLEGAL FORMAT
	BEQ	2$		;YES IF EQ

; IF CREATING TXT LIST, JUST SKIP OVER COMPLEX RELOCATION COMMANDS

	TST	RLDSCN		;WHAT PHASE OF RLD SCANING ARE WE DOING	;MAS02+
	BPL	13$		;0 -> CORRECTION FILE LIST CREATION
				;1 -> INPUT FILE RLD FIXING
	;BMI	FALLS THRU	;-1 -> CORRECTION FILE RLD SECT NO. FIX	;MAS02-
	CLR	R0		;CAREFULL OF SIGN EXTEND
	BISB	1(R1),R0	;GET SECTION NUMBER
	ADD	CRCMT,R0	;OFFSET TO MAPPING TABLE ENTRY
	MOVB	@R0,1(R1)	;RE-MAP SECTION NUMBER
13$:	BIC	#177600,@SP	;CLEAR EXTRANEOUS BITS
	ADD	@SP,BYTCNT	;NEED BYTE COUNT IF RLD COMPRESSED	;MAS02
	MOVB	@R1,R0		;GET COMMAND TYPE AGAIN
	ADD	@SP,R1		;POINT TO NEXT COMMAND
	SUB	(SP)+,R2	;ADJUST BYTE COUNT
	CMP	#STO,R0		;STORE COMMAND
	BEQ	15$		;IF EQ YES EXIT				;MAS02
	CMP	#STOD,R0	;STORE DISPLACED?
	BNE	12$		;IF NE YES, GO AGAIN
	BR	15$		;CONTINUE

14$:	ADD	R0,R1		;OFFSET TO NEXT COMMAND
	SUB	R0,R2		;ADJUST BYTE COUNT
15$:	TST	(PC)+		;DO WE ELIMINATE THIS RLD?
SKPFLG:: .BLKW			;1 -> REMOVE RLD, CAN ONLY BE 1 IF RLDSCN = 1
	BEQ	18$		;0 -> NO MODIFICATION
	MOV	(PC)+,R0	;GET BYTE COUNT FOR THIS RLD CMD
BYTCNT:: .BLKW			;BYTE COUNT FOR RLD CMD JUST PROCESSED
	MOV	R3,-(SP)	;NEED R3 LATER
	MOV	R1,R3		;POINT R3 AT REST OF RLD RECORD
	SUB	R0,R1		;SET BACK POINTER TO RLD RECORD JUST DONE
	MOV	R1,-(SP)	;SAVE POINTER, IT WILL BE CORRECT AFTER MOVE
	SUB	R0,RECBF+2	;RESET THE BYTE COUNT OF RLD BLOCK
	MOV	R2,R0		;R0 = COUNT OF BYTES IN RLD RECORD TO MOVE
	BEQ	17$		;EQ -> LAST IN RLD RECORD, -> DON'T MOVE ANY
16$:	MOVB	(R3)+,(R1)+	;MOVE 1 BYTE AT A TIME TO COMPRESS RECORD
	DEC	R0		;HAVE WE FINISHED?
	BNE	16$		;NE -> NO, KEEP MOVING	
17$:	MOV	(SP)+,R1	;RESET R1 TO NEW CURRENT RLD CMD
	MOV	(SP)+,R3	;RESTORE R3
18$:	TST	R2		;MORE RLD COMMANDS?
	BEQ	19$		;EQ -> MORE COMMANDS 
	JMP	3$		;IF NE GO AGAIN

19$:	CMP	#6,RECBF+2	;IF = 6 THEN WERE IN INPUT FILE MODE,
	BNE	RTN		;AND ALL OF RLD WAS ELIMINATED
	SEC			;RETURN WITH C=1
	BR 	20$

RTN:	CLC			;C=0 -> WRITE RECORD TO OUTPUT FILE	
20$:	RTS	PC							;MAS02-
 
.DSABL	LSB

.SBTTL	GETPCT	FIND PSECT NAME IN LIST, AND POINT R3 AT IT

;+
; SEARCH FOR THE DESIRED PSECT NAME IN THE TXT LIST. CHECK FOR END OF 	;MAS02+
; FIRST. THIS CODE REQUIRES A -1 TO ONLY BE POSSIBLE AS AN END OF PSECT
; MARKER. THE FIRST WORD OF A PSECT NAME CAN NOT BE -1 OR -2, AND TXT
; LOCATIONS AND LENGTHS CAN NOT BE -1. THIS SHOULD BE OK, SINCE
; RAD50 CAN NOT CREATE A -1 OR -2 WORD, AND TXT LOCAITONS/LENGTHS
; CAN NOT BE ODD -> -1 IS OK.
;
; INPUT:
; 	STXT: 	-> 	START OF LIST
;	R1    	-> 	PSECT NAME LOOKING FOR -2 BYTES
;
; STACK USAGE:
;	@SP   	= 	CURRENT PSECT POINTER
;	2(SP) 	=  	PSECT NAME IN RLD RECORD
;
; OUTPUT:
;	R1 UNCHANGED
;
;	NAME NOT FOUND: C=1, AND PSECT:: = 0
;
; 	NAME FOUND: C=0, AND PSECT:: POINTS AT PSECT NAME IN THE LIST.
;-

GETPCT:	MOV	R3,-(SP)	;SAVE R3
	MOV	R2,-(SP)	;SAVE R2
	MOV	R1,-(SP)	;SAVE R1
	MOV	STXT,-(SP)	;POINT @SP AT START OF TXT LIST
1$:	MOV	@SP,R3		;SET R3 TO START OF CURRENT PSECT IN LIST
	MOV	2(SP),R1	;SET R1 TO PSECT NAME IN RLD BLOCK
	CMPB	(R1)+,(R1)+	;ADD 2 TO R1 -> PSECT NAME IN RLD RECORD
2$:	CMP	#-1,(R3)+	;ARE WE AT THE END OF THE PSECT?
	BNE	2$		;NE -> NO, TRY NEXT LOCATION
	CMP	#-2,@R3		;ARE WE AT THE END OF THE LIST?
	BNE	3$		;NE -> NO, IS THIS A MATCH?
	CLR	@SP		;SET UP FOR R3 TO RETURN = 0
	SEC			;SET CARRY FOR RETURN ON NO MATCH
	BR	5$		;GO RESTORE REGISTERS, AND RETURN

3$:	MOV	R3,@SP		;R3 -> CURRENT PSECT, SAVE IT AGAIN
	MOV	#4,R2		;BYTE COUNT FOR PSECT NAME
4$:	CMPB	(R1)+,(R3)+	;NAME MATCH? (BYTES SINCE, R1 MAY BE ODD)
	BNE	1$		;NE -> NO MATCH, FIND NEXT PSECT OR END LIST
	DEC	R2		;REDUCE BYTE COUNT
	BNE	4$		;TRY NEXT BYTE OF NAME FOR MATCH
	CLC			;RETURN C=0 FOR PSECT FOUND
5$:	MOV	(SP)+,(PC)+	;RESET CURRENT PSECT POINTER
PSECT::	 .BLKW			;= 0 -> NO MODIFICATION (PSECT NOT IN LIST),
				;OTHERWISE, POINTER TO CURRENT PSECT.
	MOV	(SP)+,R1	;RESTORE R1
	MOV	(SP)+,R2	;AND R2
	MOV	(SP)+,R3	;AND R3
	RTS	PC							;MAS02-

.SBTTL	ERROVR	ENTRY WHEN ERROR IN ROOT

;+
; THIS SUPPORTS THE "ERROR$" MACRO. PRINT ERROR MESSAGES AND OPTIONAL
; REGISTER CONTENTS AND SYMBOLS.
; THE MESSAGE TYPES ARE:
;	0	MSG & DETERMINE WHICH INPUT FILE
;	1	PRINT A MESSAGE ON TERMINAL
;	2	PRINT MESSAGE PLUS THE CONTENTS OF R0
;	3	PRINT MESSAGE AND R0 -> 2 WORD RAD50 SYMBOL TO PRINT
;-

.ENABL	LSB

ERROVR:	MOV	R1,-(SP)	;SAVE R1 - R4
	MOV	R2,-(SP)
	MOV	R3,-(SP)
	MOV	R4,-(SP)
	MOV	2*4(SP),R4	;ADR + 2 WHERE TRAP INSTRUCTION
	MOV	-(R4),R4	;GET TRAP INSTR
	MOV	#LINBUF,R1	;R1 -> ERROR MESSAGE BUFR
	MOV	R4,R3		;MAKE COPY OF TRAP INST
	BIC	#^C174,R3	;ISOLATE MSG #
	BEQ	4$		;SHOULD NOT GET MSG 0
	ASR	R3		;SHIFT TWICE RIGHT
	ASR	R3
	CMP	#LGMSG,R3	;LEGAL MESSAGE # ?
	BLO	4$		;NO
	MOV	#MSG0,R2	;FIND PROPER MESSAGE TEXT
1$:	TSTB	(R2)+		;FIND EACH 0 OF ASCIZ
	BNE	1$
	SOB	R3,1$		;R3=0 WHEN AT RIGHT MESSAGE
				;R2 -> PROPER MESSAGE TEXT
	MOV	R4,R3		;MAKE COPY
	BIC	#^C3,R3		;ISOLATE MESSAGE TYPE
	BNE	3$		;FILE DETERMINATION IF 0
	MOV	#MSCFL,R0	;R0 -> CORRECTION FILE MSG
	CMPB	IRAREA,#INCHN	;INPUT FILE ?
	BNE	2$		;YES IF EQ
	MOV	#MSIFL,R0	;R0 -> INPUT FILE MSG
2$:	MOVB	(R0)+,(R1)+	;COPY FILENAME TO BUFR
	BNE	2$		;ENDS WITH 0
	DEC	R1		;BACKUP TO 0
3$:	MOVB	(R2)+,(R1)+	;COPY MSG TO LINE BUFR
	BNE	3$		;ENDS WITH 0
	DEC	R1		;BACKUP TO 0
	DEC	R3
	BLE	EPRT		;MSG TYPE = 0 OR 1
	MOVB	#SPACE,(R1)+	;TEXT TO FOLLOW MSG SO ADD BLANK
	DEC	R3		;MSG TYPE = 2 ?
	BEQ	EREG		;YES
	DEC	R3		;MSG TYPE = 3 ?
	BEQ	ESYM		;YES
				;IF WE GET HERE, NOT A LEGAL TYPE
4$:	MOV	#MSG0,R0	;WHILE TRYING TO RECOVER FROM ANOTHER
5$:	BISB	#SE.VER,@#USERRB ;SET SEVER ERROR IN USER ERROR BYTE 	;MAS04
	MOVB	#'F,FORW	;INSERT F FOR FATAL
	JMP	ERROR		;FATAL ERROR, PRINT IT

.SBTTL	EREG	PRINT MSG & CONTENTS OF R0

EREG:	JSR	PC,OCTOUT	;CONVERT VALUE IN R0 TO ASCII
	BR	6$

.SBTTL	ESYM	PRINT MSG & RAD50 SYMBOL

ESYM:	JSR	PC,R50ASC	;SYMBOL TO PRINT ALSO
6$:	CLRB	@R1		;TERMINATE

.SBTTL	EPRT	PRINT A MESSAGE

EPRT:	MOV	#LINE,R0	;R0 -> ERROR MESSAGE TO PRINT
	TSTB	R4		;FATAL ?
	BMI	5$		;YES
	BISB	#WA.RN,@#USERRB	;SET WARNING BIT IN USER ERROR BYTE	;MAS04
	MOVB	#'W,FORW	;INSERT W FOR WARNING
	.PRINT			;NO, PRINT IT AND RETURN TO CALLER
	MOV	(SP)+,R4	;RESTORE R4 - R1
	MOV	(SP)+,R3
	MOV	(SP)+,R2
	MOV	(SP)+,R1
	RTI			;RETURN FROM TRAP INST

.DSABL	LSB

.SBTTL	R50ASC	RAD50 TO ASCII CONVERSION

;+
; INPUT:
;	R1 	-> 	ASCII CHAR OUTPUT AREA
;	R0 	-> 	SYMBOL TO OUTPUT
;
; USAGE:
;	R2 & R3	=	TEMP
;	R4 	-> 	DIVISION TABLE
;	@SP 	= 	# OF CHARACTERS TO BE OUTPUT
;
; OUTPUT:
;	R0 	-> 	WORD AFTER 2 2D SYMBOL
;	R1 	-> 	NEXT FREE OUTPUT BYTE
;	CLOBBERS R2, R3
;-

.ENABL	LSB

R50ASC:	MOV	R4,-(SP)	;SAVE R4
	MOV	#6,-(SP)	;# OF CHARS TO OUTPUT
1$:	MOV	#DIVTAB,R4	;R4 -> DIVISION TABLE
	MOV	(R0)+,R2	;R2 = CURRENT INPUT WORD
2$:	TST	-(R4)		;NEW WORD REQUIRED YET?
	BEQ	1$		;YES
	CLR	R3		;INITIALIZE QUOTIENT REG
3$:	INC	R3		;DIVIDE BY APPROPRIATE POWER OF 50(8)
	SUB	@R4,R2
	BCC	3$
	DEC	R3
	ADD	@R4,R2		;RESTORE DIVIDEND
	TST	R3		;CHARACTER IS A BLANK?
	BEQ	4$		;YES
	CMP	#33,R3		;DOLLAR SIGN, PERIOD, OR DIGIT?
	BLO	5$		;PERIOD OR DIGIT
	BEQ	6$		;DOLLAR SIGN
	ADD	#40,R3		;ELSE ALPHA (A-Z) OR QUESTION MARK
4$:	ADD	#16,R3
5$:	ADD	#11,R3
6$:	ADD	#11,R3
7$:	MOVB	R3,(R1)+	;STORE CONVERTED CHARACTER IN OUTPUT
	DEC	@SP		;LOOP FOR MORE CHARS
	BNE	2$		;YES
	TST	(SP)+		;POP CTR
	MOV	(SP)+,R4
8$:	RTS	PC

	.WORD	0		;END-OF-TABLE FLAG
	.WORD	1
	.WORD	50
	.WORD	3100
DIVTAB=.

.SBTTL	OCTOUT	OCTAL TO ASCII OUTPUT

;+
;REGISTER USAGE:
;	R0 	= 	UNSIGNED # TO BE CONVERTED
; 	R1 	-> 	ADDR OF AREA TO PLACE THE 6 ASCII DIGITS
; THE BYTE AFTER THE # IS 206
;-

OCTOUT: MOVB	#30,@R1
	SEC			;NOT NEEDED IF C=1 ON ENTRY
9$:	ROL	R0
	ROLB	(R1)+
	MOVB	#206,@R1
10$:	ASL	R0
	BEQ	8$		;IF 0 THEN DONE
	ROLB	@R1
	BCS	10$
	BR	9$

.DSABL	LSB

.SBTTL	 PAT	ERROR MESSAGE TEXT

.NLIST	BEX
.PSECT	BYTE,D

; THE ASCII AREA & BUFFER MUST BE TOGETHER TO BE PRINTED AS ONE LINE.

LINE:	.ASCII	/?PAT-/
FORW:	.ASCII	/F-/
LINBUF:	.BLKB	50.		;ERROR MESSAGE BUFFER

.ENABL	LC

MSG0:	.ASCIZ	/?PAT-F-Illegal error/

.DSABL	CRF

MSG1:	.ASCIZ	/missing/				;FILE
MSG2:	.ASCIZ	/Additional output file ignored/
MSG3:	.ASCIZ	/Insufficient memory/
MSG4:	.ASCIZ	/Additional input file ignored/
MSG5:	.ASCIZ	/read error/				;FILE
MSG6:	.ASCIZ	/has illegal record/			;FILE
MSG7:	.ASCIZ	/has bad RLD/				;FILE
MSG10:	.ASCIZ	/has bad GSD/				;FILE
MSG11:	.ASCIZ	/Unable to locate module/		;SYMBOL
MSG12:	.ASCIZ	/Incompatible reference to global/	;SYMBOL
MSG13:	.ASCIZ	/Incompatible reference to section/	;SYMBOL
MSG14:	.ASCIZ	/Input module checksum is/		;#
MSG15:	.ASCIZ	/Correction file checksum is/		;#
MSG16:	.ASCIZ	/checksum error/			;FILE
MSG17:	.ASCIZ	\Only /C allowed\
MSG20:	.ASCIZ	/Output file full/
MSG21:	.ASCIZ	/Command line error/
MSG22:	.ASCIZ	/Output write error/
MSG23:	.ASCIZ	/missing RLD record/			;FILE		;MAS02
MSG24:	.ASCIZ	/Output file created - protected file already exists/	;MAS03
.ENABL	CRF

LGMSG=	24 		;HIGHEST LEGAL MESSAGE NUMBER

ERR	LGMSG		;DEFINE ERROR MESSAGE NUMBERS FOR ERROR$	;MAS02

MSCFL:	.ASCIZ	/Correction file /
MSIFL:	.ASCIZ	/Input file /

.PSECT	PATCH

	.BLKW	64.		;THIS PSECT IS FOR BUG FIXES		;MAS02

.END	START
