.MCALL	.MODULE
.MODULE	LIBR,VERSION=09,COMMENT=<CREATE EPT> IDENT=NO,MODNAME=LIBR2,GLOBAL=.LIBR2

;                       COPYRIGHT (c) 1989 BY
;           DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;                        ALL RIGHTS RESERVED
;
;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
;ONLY  IN  ACCORDANCE  WITH  THE TERMS  OF  SUCH  LICENSE AND WITH THE
;INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY OTHER
;COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS HEREBY
;TRANSFERRED.
;
;THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT NOTICE
;AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT
;CORPORATION.
;
;DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF ITS
;SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.

.SBTTL	OBJECT LIBRARY EPT CREATION
.ENABL	GBL

; CER,MAS,SMD

.IIF NDF EIS$	EIS$=0	;SAY EIS NOT AVAILABLE

; EDIT LOG
; PREVENT INSERTION OF ABSOLUTE GLOBAL SYMBOLS IN EPT			;MAS04
; FIX BOUNDARY CONDITION ON EPT=EVEN BLOCK				;MAS05
; ADD /X SWITCH (DUPLICATE GBLS IN EPT)					;MAS06
; ADD /A SWITCH TO PUT ABSLOUTE GLOBALS IN OBJ EPT			;MAS09
; FIX FILESPEC WITHIN MESSAGE FOR /UPDATE				;SMD01

.SBTTL	-	MACRO DEFINITIONS

MODEND=	6		;OBJ MODULE END CODE

.MCALL	.DATE,.GTIM

;+
; SUBROUTINE CALL AND RETURN TO MAIN PROGRAM, EQUIVILENT TO:
;	CALL	SUBR
;	RETURN
;-

.MACRO	CALLR	SUBR
	JMP	SUBR
.ENDM

.MACRO	ERROR$	ERNB,SEV,ETYP,REG
	.IF NB REG
	.IIF DIF <REG>,<R0>	MOV REG,R0
	.IFF
	.IIF IDN <ETYP>,<E$FIL>	CLR	R0
	.ENDC
	JSR	R5,ERROOT
	.BYTE	ERNB,	SEV*200!ETYP
.ENDM

.IF Z EIS$
.MACRO	SOB	A,B
	DEC	A
	BNE	B
.ENDM
.ENDC

.SBTTL	-	ENTRY POINT TABLE FORMAT

.ASECT
.=0
	.BLKW		;SYMBOL CHARS 1-3(RAD50)
	.BLKW		;SYMBOL CHARS 4-6(RAD50)
E$PBLK::.BLKW		;M!	RELATIVE BLOCK #
E$PBYT::.BLKW		;REL BYTE IN BLOCK	;REL BYTE MAX = 777

MD.NAM==100000		;'M' BIT 15 = 1 IF ENTRY IS MODULE NAME

.SBTTL	-	GSD ENTRY STRUCTURE

.=0
	.BLKW		;SYMBOL NAME IN RAD50 (CHARS 1-3)
	.BLKW		;SYMBOL NAME IN RAD50 (CHARS 4-6)
S$YFLG::.BLKB		;FLAGS BYTE
S$YCOD::.BLKB		;CODE BYTE
S$YVAL::.BLKW		;SIZE OF SECTION OR GLOBAL OFFSET

.SBTTL	-	GLOBAL SYMBOL INPUT FLAG BYTE BIT ASSIGNMENTS

SY$WK==1	;GLOBAL (1=WEAK, 0=STRONG)
SY$LBL==2	;LABEL (1=LABEL, 0=EQUATED)
SY$DEF==10	;DEFINITION (1=DEF, 0=REFERENCE)
SY$REL==40	;RELOCATABILITY (1=REL, 0=ABS)

.PSECT		;RESET TO BLANK SECTION

.SBTTL	-	LIBRARY HEADER FORMAT & OFFSETS

; MACRO TO DEFINE HEADER OFFSETS, VALUE SYMBOLS, & VALUES

.MACRO	LBRHDR	ONAME,ENAME,EVAL
.IIF NB <ONAME>	ONAME==	TMP		;DEFINES THE OFFSET
.IIF NB <ENAME>	ENAME==	EVAL		;SYMBOL FOR ENTRY VALUE
	.WORD	EVAL
TMP=	TMP+2
.ENDM	LBRHDR

TMP=	0	;OFFSETS START AT ZERO

	.WORD	2	;ERROR HANDLING INDEX WORD(IN A DATA SECTION)
			;MUST BE 1ST PHYSICAL LOCATION OF EACH OVERLAY

.PSECT	DPUR2,D

;	OFFSET	VAL SYM 	VALUE
;	------	-------		-----

HDRTBL:
LBRHDR	,	F.BRHC,		1	;FORMATTED BINARY BLK CODE
LBRHDR	,	L.HLEN,		42	;RECORD LENGTH
LBRHDR	L$HC,	L.BR,		7	;LIBRARIAN CODE
LBRHDR	L$HVER,	L.HVER,		500	;VERSION NUMBER (V05.00)
LBRHDR	L$HX,	,		0	;/X LIBRARY FLAG (1=/X;0=NOT /X);MAS06
LBRHDR	L$HDAT,	,		0	;DATE IN RT-11 DATE FORMAT
LBRHDR	L$HTIM,	,		0	;2 WD TIME
LBRHDR	,	,		0
LBRHDR	,	,		0	;NOT USED
LBRHDR	,	,		0	;NOT USED
LBRHDR	,	,		0	;NOT USED
LBRHDR	L$HRSA,	,		10	;EPT RELATIVE START ADR
LBRHDR	L$HEAB,	,		0	;EPT ENTRIES ALLOCATED IN BYTES
LBRHDR	L$HEEA,	,		0	;EPT ENTRIES AVAILABLE
LBRHDR	L$HNIB,	,		0	;NEXT INSERT RELATIVE BLOCK NUMBER
LBRHDR	L$HNBB,	,		0	;NEXT BYTE WITHIN BLOCK

L$HEPT==	TMP			;1ST ENTRY IN ENTRY POINT TABLE

.PSECT

.SBTTL	CREATE:: LIBRARY ROUTINE PASS 1 

CREATE::MOV	EPTST,EPTPTR	;INIT EPT PTR AT BEGINING

.SBTTL	-	CREATE THE LIBRARY HEADER BLOCK IN THE RESIDENT EPT

	.GTIM	#PRAREA,#<HDRTBL+L$HTIM> ;PUT CURRENT TIME IN HEADER
	.DATE			;GET TODAY'S DATE IF ANY
	MOV	#HDRTBL,R3	;R3 -> START OF LIBR HEADER TABLE
	MOV	R0,L$HDAT(R3)	;PUT DATE IN HEADER TABLE
	MOV	#L$HEPT/2,R2	;# OF WORDS IN HEADER
	CLR	L$HX(R3)	;SET FOR NORMAL LIBRARY			;MAS06+
	BIT	SWITCH,#SW.X	;IS /X LIBRARY BEING CREATED?
	BEQ	10$		;NO, KEEP 0
	INC	L$HX(R3)	;YES-> SET FLAG=1			;MAS06-
10$:	MOV	(R3)+,R0	;CURRENT HEADER WORD TO OUTPUT
	CALL	PUTEPT		;WORD TO OUTPUT BUFR
	SOB	R2,10$		;OUTPUT ENTIRE HEADER
	CALL	INIO		;INIT FOR INPUT FILE READING
	MOV	#1,MODCNT	;INIT OBJ MODULE COUNT

;+
; NORMAL REGISTER USAGE DURING THIS OVERLAY
;	R0, R1 & R2 USEABLE AS INDICATED ON A LOCAL BASES
;	R3 - DESTROYED (-> FOUND SYMBOL IN EPT AFTER A SEARCH)
;	R4 -> CURRENT INPUT FILE BUFFER POSITION
;	R5 = CURRENT FORMATTED BINARY RECORD LENGTH
;
; THE GSD (GLOBAL SYMBOL DIRECTORY) OF EACH INPUT MODULE IS
; SCANNED. THE MODULE NAME, THE SECTION NAMES, AND THE ENTRY
; POINTS ARE PLACED IN THE EPT ALONG WITH THEIR RELATIVE
; ADDRESSES. (RELATIVE BLK # AND RELATIVE BYTE WITHIN THE BLK)
; HOWEVER IF THE MODULE OR ENTRY POINT IS TO BE REPLACED
; OR DELETED, THE ASSOCIATED ACTION IS PERFORMED.
;-

.SBTTL	*	PROCESS FORMATTED BINARY RECORD TYPES

20$:	CALL	NEWBLK		;GET FB BLK
	ASL	R0		;MAKE WORD INDEX
	CMP	#DSPTBE-DSPTBL,R0 ;LEGAL BLOCK TYPE ?
	BLOS	ILFMT		;YES
	CALL	@DSPTBL(R0)	;CALL BLOCK DEPENDENT ROUTINE
	BR	20$		;GO AGAIN

.SBTTL	-	FORMATTED BINARY RECORD TYPE DISPATCH TABLE

.PSECT	DPUR2,D

DSPTBL:	.WORD	ILFMT		; 0 - ILLEGAL BLOCK TYPE
	.WORD	GSDREC		; 1 - START OF GSD RECORD
	.WORD	SKPBLK		; 2 - END OF GSD
	.WORD	SKPBLK		; 3 - TXT
	.WORD	SKPBLK		; 4 - RLD
	.WORD	SKPBLK		; 5 - ISD (INTERNAL SYMBOL DEF)
	.WORD	ENDMOD		; 6 - MODULE END
	.WORD	LMERGE		; 7 - LIBRARY HEADER RECORD
	.WORD	ENDLBR		;10 - END OF LIBRARY FILE
DSPTBE:				;END OF TABLE

.PSECT

ILFMT:	ERROR$	ERR6,E$F,E$FIL	;ILLEGAL RECORD TYPE IN <FILENAME>

.SBTTL	LMERGE	INPUT FILE IS A LIBRARY

;+
; THE INPUT FILE IS A LIBRARY SO WE ARE MERGING IT WITH THE OTHER INPUT
; FILES. THE EPT OF THIS INPUT FILE WILL BE SKIPPED OVER AND THE OBJ
; MODULES OF THE INPUT LIBR FILE PROCESSED JUST LIKE OTHER INPUT OBJ'S.
;-

LMERGE:	DECB	SWIT6		;IND PROCESSING LIBR FILE
	ADD	#L$HEAB-6,R4	;R4 -> SIZE OF EPT IN BYTES
	MOV	@R4,R0		;GET EPT ENTRIES ALLOC.
	DEC	R0		;FIX IF EPT EVEN BOUNDARY		;MAS05
	BIC	#777,R0		;DETERMINE STARTING BLK # OF OBJ'S
	SWAB	R0		; C =0
	ROR	R0
	INC	R0		;OBJ START ON BLK BOUNDARY
	MOV	R0,CURBLK	;UPDATE CURRENT INPUT REL BLK #
	CALLR	NEWBUF		;READ MODULES IN LIBR(NEWBUF WILL RETURN)
				;R4 & R5 ARE RESET BY NEWBUF

.SBTTL	ENDLBR	END OF INPUT LIBR FILE

; LIBRARY END RECORD IS IGNORED, SKIP IT.

ENDLBR:	CLRB	SWIT6		;RESET LIBR INDICATOR

.SBTTL	ENDMOD	END OF OBJ MODULE

ENDMOD:	TSTB	SWIT6		;PROCESSING A LIBRARY FILE?		???
	BMI	10$		;YES, DON'T INC FILE POSITION COUNT	???
	INC	MODCNT		;INC CNT OF OBJ MOD
10$:	CALLR	SKPBLK		;SKIP OVER END OBJ RECORD(SKPBLK WILL RETURN)

.SBTTL	GSDREC	PROCESS GSD RECORDS

GSDREC:	MOV	#8.,R0		;8 BYTES PER GSD RECORD
	SUB	R0,R5		;DECREMENT GSD SYMBOL LENGTH
	MOV	#TEMP+2,R1	;R1 -> STORAGE AREA FOR GSD BLK
	MOV	R1,R3		;SAVE SYMBOL ADR FOR LATER
10$:	CMP	ENDBUF,R4	;END OF INPUT BUFFER ?
	BHI	20$
	MOV	R0,-(SP)	;SAVE CTR
	CALL	NEWBUF		;READ ANOTHER BUFR
	MOV	(SP)+,R0
20$:	MOVB	(R4)+,(R3)+	;MOVE GSD TO TEMP AREA
	DEC	R0		;MORE GSD INFO ?
	BGT	10$		;YES
	MOVB	S$YCOD(R1),R0	;GET GSD INDICATOR FLAGS
	ASL	R0		;MAKE WORD INDEX
	CMP	#GSDTBE-GSDTBL,R0 ;LEGAL GSD CODE ?
	BLOS	30$		;ERROR, BAD GSD
	CALL	@GSDTBL(R0)	;CALL APPROPRIATE SUBROUTINE
	TST	R5		;ANY BYTES REMANING IN F.B. BLK ?
	BGT	GSDREC		;YES, PROCESS NEXT GSD ITEM
	CALLR	BYTE		;GET CHECKSUM BYTE
				;BYTE WILL RETURN TO GET NEW DATA BLK

30$:	ERROR$	ERR10,E$F,E$FIL	;BAD GSD IN <FILENAME>

.PSECT	DPUR2,D

GSDTBL:	.WORD	MODNAM		; 0 - MODULE NAME
	.WORD	SECNAM		; 1 - SECTION NAME
	.WORD	IGNORE		; 2 - INTERNAL SYMBOL DISCRIPTOR
	.WORD	IGNORE		; 3 - TRANSFER ADDRESS
	.WORD	GBLSYM		; 4 - GLOBAL SYMBOL
	.WORD	SECNAM		; 5 - PROGRAM SECTION
	.WORD	IGNORE		; 6 - PROGRAM IDENT
	.WORD	SECNAM		; 7 - VIRTUAL SECTION
GSDTBE:				;END OF TABLE

.PSECT

;+
; WHILE PROCESSING GSD ITEMS
;	R1 -> 1ST WORD OF 4 WORD GSD ENTRY
;	R3 -> EPT AFTER A SYMBOL FOUND
;-

.SBTTL	SECNAM	BUILD EPT FOR SECTION NAME

; BLANK, . ABS., & ZERO LENGTH SECTIONS ARE NOT INCLUED

.ENABL	LSB

SECNAM:	BIT	SWITCH,#SW.P	;SHOULD PROGRAM SECTIONS BE INCLUDED ?
	BEQ	20$		;YES IF SET
	TST	S$YVAL(R1)	;ZERO LENGTH SECTION ?
	BEQ	20$		;YES, IGNORE ENTRY
	CMP	(PC)+,(R1)+	;IS SYMBOL ASECT ?			
	 .RAD50	/. A/
	BNE	10$		;NO
	CMP	#^RBS.,@R1
	BEQ	20$		;YES, IGNORE IT
10$:	TST	-(R1)		;IS SECTION BLANK ?
	BNE	30$		;NO IF NE, CHECK FOR SECTION DELETE
20$:	RETURN			;DON'T PLACE IN EPT

.SBTTL	GBLSYM	BUILD EPT FOR GLOBAL SYMBOL

GBLSYM:	BICB	#^C<SY$DEF+SY$REL+SY$WK>,S$YFLG(R1) ;CLEAR UNUSED BITS	;MAS04
	CMPB	S$YFLG(R1),#<SY$DEF+SY$REL> ;IS IT STRONG REL DEF?	;MAS04
	BEQ	30$		;EQ -> NOT A STRONG ABS SYMBOL	;MAS04	;MAS09+
	TST	SWITCH		;TEST TO SEE IF ABSOLUTE SWITCH WAS USED
	BPL	IGNORE		;PL -> SWITCH NOT USED, SKIP ALL ABSOLUTES.
	CMPB	S$YFLG(R1),#SY$DEF ;IS IT STRONG DEFINED ABS?
	BNE	IGNORE		;NO, DON'T INCLUDE THIS IN EPT EITHER.	;MAS09-
30$:	MOV	DEPLA,R0	;R0 -> GLOBAL DELETE LIST
	BEQ	40$		;NOTHING TO DELETE
	CALL	DELENT		;CHECK DELETE FUNCTION
	BCS	IGNORE		;NO DELETE MADE
40$:	CALL	EPTSER		;IS SYMBOL ALREADY IN EPT ?
	BCS	MOVMOD		;NO, PLACE SYMBOL IN EPT
50$:	BIT	SWITCH,#SW.X	;KEEPING DUP. GBL SYMBOLS?		;MAS06
	BNE	60$		;YES-> OK				;MAS06
	TST	E$PBLK(R3)	;MODULE NAME ?
	BPL	90$		;NO, IND ILL INS
60$:	CALL	EPTSR1		;IS THERE A DUPLICATE SYMBOL ?		;MAS06
	BCC	50$		;YES, GO SEE IF DUP GLOBAL OR MOD NAME
;	BR	MOVMOD

.SBTTL	MOVMOD	PUT SYMBOL NAME IN LIBRARY EPT

MOVMOD:	MOV	(R1)+,R0
	CALL	PUTEPT		;PLACE 2WD SYMBOL NAME IN EPT
	MOV	(R1)+,R0	;THE LIBRARY EPT
	CALL	PUTEPT
	CLR	R0		;ASSUME NOT A MOD NAME
	TSTB	S$YCOD-4(R1)	;MODULE NAME ?
	BNE	70$		;YES IF 0
	BIS	#MD.NAM,R0	;IND MOD NAME IN EPT
70$:	CALL	PUTEPT		;BLK # OF MODULE (SET LATER)
	CLR	R0		;PREPARE BYTE OFFSET WD
	TSTB	SWIT7		;REPLACE MODULE ?
	BEQ	80$		;NO IF 0
	COM	R0		;IND MODULE REPLACE, NOW NON-ZERO
	CLRB	SWIT7		;TURN OFF REPLACE SWITCH
80$:	CALLR	PUTEPT		;LAST WD OF ENTRY IN EPT
				;PUTEPT WILL RETURN

90$:	ERROR$	ERR12,E$W,E$SYM,R1 ;ILLEGAL INSERT OF <SYMBOL>

IGNORE:	RETURN			;IGNORE BAD ENTRY & GET NEXT ONE

.DSABL	LSB

.SBTTL	MODNAM	BUILD EPT FOR MODULE NAME

;+
; CHECK DELETE LIST 1ST, THEN CHECK FOR /U, IF NO /U THEN CHECK /R
; OTHERWISE JUST INSERT MODULE NAME
;-

MODNAM:	MOV	DMNLA,R0	;R0 -> MODULE NAME DELETE LIST
	BEQ	10$		;NOTHING TO DELETE
	CALL	DELENT		;CALL DELETE FUNCTION
	BCS	SKPMOD		;C=1 IF DELETE THIS MODULE

; CHECK SWITCH OPTIONS

10$:	MOV	#SWITCH,R2	;R2 -> SWITCH WORD TO CHECK OPTIONS
	MOV	UPDPTR,R0	;R0 -> UPDATE LIST ADR
	BNE	20$		;NO /U IF 0
	MOV	REPLPT,R0	;R0 -> REPLACE LIST (R0 -> 0 IF NO /R)
20$:	TST	(R0)+		;END OF UPDATE/REPLACE LIST ?
	BEQ	70$		;END-OF-LIST IF 0
	CMPB	FILCNT,-1(R0)	;CORRECT FILE TO UPDATE OR REPLACE ?
	BNE	20$		;NO
	TSTB	SWIT6		;LIBRARY FILE?
	BPL	30$		;NO
	MOV	FILCNT,R0	;Get the input file number.		;SMD01
	SUB	#3.,R0		;Input files start at #3.		;SMD01
	ASL	R0		;Calculate offset into input file list	;SMD01
	ASL	R0							;SMD01
	ASL	R0							;SMD01
	ADD	#ODBLK+36,R0	; from start of list.			;SMD01
	ERROR$	ERR21,E$F,E$FIL,R0 ;/R OR /U GIVEN ON LIBRARY FILE <FILENAME>

30$:	CALL	EPTSER		;SEARCH EPT TABLE
	MOV	R3,R0		;SAVE FOUND MOD ENTRY ADR
	BCS	100$		;FOUND IF C=0, SO REPLACE IT

;+
; A MODULE NAME HAS BEEN FOUND TO REPLACE, REMOVE IT(& GLOBALS) FROM ITS CURRENT
; POSITION IN EPT(SHIFTING REMAINDER DOWN) THEN PUT IT AT THE END OF THE LIST
;-

40$:	ADD	#8.,R3		;INDEX TO NEXT ENTRY
	CMP	EPTPTR,R3	;END OF EPT ?
	BLOS	60$		;YES
	TST	E$PBLK(R3)	;MODULE NAME ?
	BPL	40$		;NO IF +, LOOP TO START OF NEXT MODULE
50$:	MOV	(R3)+,(R0)+	; THEN OVERLAY REPLACED ENTRY
	MOV	(R3)+,(R0)+
	MOV	(R3)+,(R0)+
	MOV	(R3)+,(R0)+
	CMP	EPTPTR,R3	;END OF EPT ?
	BHI	50$		;NO, LOOP UNTIL REACH END
60$:	CLR	@R0		;MARK END OF EPT
	MOV	R0,EPTPTR	;IND NEW END ADR
	DECB	SWIT7		;IND REPLACE
	BR	MOVMOD

; NEITHER /U NOR /R WAS GIVEN, OR NOT AT PROPER FILE

70$:	CALL	EPTSER		;DOES NAME ALREADY EXIST IN TABLE ?
	BCS	MOVMOD		;NO IF C=1
80$:	TST	E$PBLK(R3)	;IS THIS A MODULE NAME ENTRY ?
	BMI	90$		;YES IF -
	CALL	EPTSR1		;CONTINUE SEARCHING
	BCC	80$		;C=0 IF FOUND
	BR	MOVMOD		;NOT IN TABLE

90$:	ERROR$	ERR15,E$W,E$SYM,R3 ;DUPLICATE MODULE NAME OF <NAME>
	BR	MOVMOD		;WARNING(VERY MINOR) & ENTER IT ANYWAY

100$:	BIT	#SW.U,@R2	;DON'T GIVE ERROR WHEN NOT FOUND IF /U
	BNE	MOVMOD		;SET IF /U, JUST PUT NEW NAME IN TBL
	ERROR$	ERR13,E$W,E$SYM,R1 ;ILLEGAL REPLACEMENT OF <SYMBOL>
;	BR	SKPMOD		;SKIP MODULE CAUSING ILL REPL

.SBTTL	SKPMOD	SKIP OVER AN ENTIRE OBJ MODULE

SKPMOD:	CALL	SKPBLK		;SKIP OVER FB BLK
	CALL	NEWBLK		;GET NXT FB BLK
	CMP	#MODEND,R0	;END OF MODULE ?
	BNE	SKPMOD		;NO
	TST	(SP)+		;DO NOT RETURN TO GSD PROCESSING LOOP
				; BUT TO PROCESS NEW OBJ RECORD.
	CALLR	SKPBLK		;SKIP LAST FB (SKPBLK WILL RETURN)

.SBTTL	PUTEPT	PUT VALUE IN R0 INTO RESIDENT ENTRY POINT TABLE

PUTEPT:	MOV	R0,@EPTPTR	;INSERT VALUE AT CURRENT PTR
	ADD	#2,EPTPTR	;BUMP PTR TO NEXT WORD
	CMP	EPTPTR,@#HIGH	;REACH THE HIGH LIMIT OF AVAILABLE MEMORY?
	BLO	10$
	ERROR$	ERR3,E$F,E$PRT	;INSUFFICIENT MEMORY FOR EPT

10$:	CLR	@EPTPTR		;TERMINATE EPT WITH 0
	RETURN

.SBTTL	OV2DUM:: DUMMY ENTRY POINT TO MAKE IT RESIDENT

OV2DUM::RTS	R5

	.PSECT	PATCH		;THIS IS A PATCH PSECT TO BE 
			;USED FOR BUG FIXES
	.BLKW	64.

.END
