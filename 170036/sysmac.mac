.MCALL	.MODULE
.MODULE SYSMAC,RELEASE=V05,VERSION=01,COMMENT=<System macro library>,LIB=YES

;
;                      COPYRIGHT (c) 1983 BY
;             DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;			  ALL RIGHTS RESERVED
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
; SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.

;++
;	RESERVED SYMBOL NAMES
;	---------------------
;
;	...V1 and ...V5 are "global" values defined in macros
;
;	...V1	-- controls .MCALLing of ...CM* and support of V1, V2 and
;		   V3 versions of the expansions.
;	...V5	-- controls generation of .AUDIT information.
;
;	...V*	-- are reserved for more local and global values
;
;	...V2, ...V3, and ...V4 are currently in use as local symbols
;			(reusable in each macro definition).
;
;	RESERVED MACRO NAMES
;	--------------------
;
;	..V1..
;	..V2..
;	.MACS
;	...CM*
;--
;++
;	Error Messages
;
;?SYSMAC-W-Invalid argument, use #0, not 0
;
;	General message -- Macro arguments of "0" are almost always
;	errors, (Which specify an address of 0, not a value of 0.)
;
;?SYSMAC-E-Odd or invalid vector specified
;
;	.DRBEG & .DRVTB -- the 2 lower bits of the vector address must
;	be 0.
;
;?SYSMAC-E-Invalid c o n t r o l value - control
;
;	.DRBOT -- an invalid controller type was specified.  See definition
;	of .DRBOT for valid type codes.
;
;?SYSMAC-E-Invalid s i d e s value - sides
;
;	.DRBOT -- an invalid number of sides was specified, use 1 or 2.
;
;?SYSMAC-E-Primary boot too large
;
;	.DREND -- the primary boot code overflowed the area available to it.
;
;;?SYSMAC-E-V A L Must not be 0, VAL;
;;
;;	.DRSET -- the second argument to the macro must not be 0, if it
;;	is, the rest of the options in the table are ignored.
;;
;?SYSMAC-E-Invalid parameter x;
;
;	.DRSET -- the last argument must be blank or one (or more) of
;	the following: NO,NUM,OCT
;--
;++
;	..V1..
;
;	.MCALL the support routines and set the version to 1
;--

.MACRO ..V1..
.MCALL	...CM0,...CM1,...CM2,...CM3,...CM4,...CM5,...CM6,...CM7
...V1=1
.ENDM

;++
;	..V2..
;
;	.MCALL the support routines and set the version to 2
;--

.MACRO ..V2..
.MCALL	...CM0,...CM1,...CM2,...CM3,...CM4,...CM5,...CM6,...CM7
...V1=2.
.ENDM

;++
;	.MACS
;
;	.MCALL the support routines and set the version to [>=]3
;--

.MACRO .MACS
.MCALL	...CM0,...CM1,...CM2,...CM3,...CM4,...CM5,...CM6,...CM7
...V1=3.
.ENDM

;++
;	...CM0
;
;	Move a word to the stack. If argument blank or #0
;	Put a 0 on the stack.  If second argument present,
;	generate an EMT with that value
;--

.MACRO ...CM0 STARG,INS
.IF B <STARG>
	CLR	-(SP)
.IFF
.IF IDN <STARG>,#0
	CLR	-(SP)
.IFF
.IIF IDN <STARG> <0> .ERROR ;?SYSMAC-W-Invalid argument, use #0, not 0;
	MOV	STARG,-(SP)
.ENDC
.ENDC
.IIF NB <INS>	EMT	^O<INS>
.ENDM

;++
;	...CM1
;
;	Setup R0 to point to AREA, set the CHAN and IC (subcode)
;	value in first word.  This macro optimises number of
;	instructions to set up first word.
;	IC is forced to decimal.
;--

.MACRO ...CM1	AREA,IC,CHAN,FLAG,ARG,INS,CSET,BB
...CM5	<AREA>
...V2=0
.IF B <FLAG>
.IIF B <AREA>, ...V2=1
.IFF
.IIF DIF <FLAG>,SET, ...V2=1
.ENDC
.IF NE ...V2
.IF IDN <CHAN>,<#0>
	CLRB	@R0
.IFF
.IIF NB <CHAN>	MOVB	CHAN,@R0
.ENDC
.IFF
.IF B <CHAN>
	MOVB	#IC'.,1(R0)
.IFF
.NTYPE ...V2,CHAN
.IF EQ ...V2-^O27
	MOV	CHAN+<IC'.*^O400>,@R0
.IFF
	MOV	#IC'.*^O400,@R0
	MOVB	CHAN,@R0
.ENDC
.ENDC
.ENDC
.IIF IDN <CHAN> <0> .ERROR ;?SYSMAC-W-Invalid argument, use #0, not 0;
...CM2	<ARG>,2,INS,CSET,BB
.ENDM

;++
;	...CM2
;
;	Move an argument value to OFFSET(R0).
;	Use a CLR_ if the value is #0.
;	Offset is forced to decimal.
;	BB is blank or B for byte operations
;	If INS NB generate an EMT 375
;--

.MACRO ...CM2	ARG,OFFSE,INS,CSET,BB
.IF B <ARG>
.IF NB <CSET>
.IIF NE ...V1-3.	CLR'BB	OFFSE'.(R0)
.ENDC
.IFF
.IF IDN	<ARG>,#0
	CLR'BB	OFFSE'.(R0)
.IFF
.IIF IDN <ARG> <0> .ERROR ;?SYSMAC-W-Invalid argument, use #0, not 0;
	MOV'BB	ARG,OFFSE'.(R0)
.ENDC
.ENDC
.IIF NB <INS>	EMT	^O375
.ENDM

;++
;	...CM3
;
;	Move a channel and code to R0.
;	Follow this with an EMT 374.
;	This macro optimises the instructions used
;	to load R0.
;--

.MACRO ...CM3	CHAN,IC
.IF B <CHAN>
	MOV	#IC*^O400,R0
.IFF
.NTYPE ...V2,CHAN
.IF EQ ...V2-^O27
	MOV	CHAN+<IC*^O400>,R0
.IFF
	MOV	#IC*^O400,R0
	BISB	CHAN,R0
.ENDC
.ENDC
	EMT	^O374
.ENDM

;++
;	...CM4
;
;	Setup for a SDAT/RCVD EMT block
;--

.MACRO ...CM4	AREA,BUF,WCNT,CRTN,IC,CODE
.IIF IDN <CODE>,NOSET ...CM1 <AREA>,IC,,<CODE>
.IIF DIF <CODE>,NOSET ...CM1 <AREA>,IC,#0,<CODE>
...CM2 <BUF>,4
...CM2 <WCNT>,6
...CM2 <CRTN>,8,E
.ENDM

;++
;	...CM5
;
;	Move a (byte) value to R0 unless the src is
;	blank or R0.  If so, then generate nothing.
;	BB is blank for word operations or B for byte.
;	If second argument present, generate an EMT with 
;	that code value.
;--

.MACRO ...CM5	SRC,INS,BB
.IF NB <SRC>
.IIF DIF <SRC>,R0	MOV'BB	SRC,R0
.ENDC
.IIF NB <INS>	EMT	^O<INS>
.ENDM

;++
;	...CM6
;
;	Move a code and channel to R0.  This macro
;	optimises the instructions needed to load R0.
;	Do the first ...CM2 also.
;	IC and CHAN are forced to decimal.
;--

.MACRO ...CM6	AREA,IC,CHAN,FLAG,ARG,INS,CSET,BB
...CM5	<AREA>
.IF B <FLAG>
.IIF NB <AREA>	MOV	#IC'.*^O400+CHAN'.,@R0
.IFF
.IIF IDN <FLAG>,SET	MOV	#IC'.*^O400+CHAN'.,@R0
.ENDC
...CM2	<ARG>,2,INS,CSET,BB
.ENDM

;++
;	...CM7
;
;	Generate READ_/WRIT_ requests
;--

.MACRO	...CM7	AREA,CHAN,BUF,WCNT,BLK,CRTN,IC,CODE,V1
.IF EQ ...V1-1
...CM5	<WCNT>
...CM0	<CRTN>
...CM0	<BUF>
...CM0	<CHAN>,<V1+AREA>
.IFF
...CM1 <AREA>,IC,<CHAN>,<CODE>,<BLK>
...CM2 <BUF>,4
...CM2 <WCNT>,6
...CM2 <CRTN>,8,E
.ENDC
.ENDM


.MACRO .ABTIO	CHAN
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM3	<CHAN>,11.
.ENDM

;++
;	.AUDIT
;
;	macro to generate list of versions starting at abs 110
;
;	up to 26 names
;
;	First reference generates a RAD50 value for 110 of release
;--

.MACRO	.AUDIT	Q,W,E,R,T,Y,U,I,O,P,A,S,D,F,G,H,J,K,L,Z,X,C,V,B,N,M
.SAVE
.ASECT
.IIf	NDF	...V5	...V5=^O110
.=...V5
.IF	EQ	.-^O110
	.GLOBL	.AUDIT
	.WORD	.AUDIT
.ENDC
.IRP	...V2 <Q,W,E,R,T,Y,U,I,O,P,A,S,D,F,G,H,J,K,L,Z,X,C,V,B,N,M>
.IF	NB	<...V2>
	.GLOBL	'...V2'
	.WORD	'...V2'
.ENDC
.ENDR
...V5=.
	.WORD	-1
.RESTORE
.ENDM	.AUDIT

.MACRO .CDFN	AREA,ADDR,NUM,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM6	<AREA>,13,0,<CODE>,<ADDR>
...CM2	<NUM>,4,E
.ENDM

.MACRO .CHAIN
	MOV	#^O4000,R0
	EMT	^O374
.ENDM

.MACRO .CHCOP	AREA,CHAN,OCHAN,JOBBLK,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM1	<AREA>,11,<CHAN>,<CODE>,<OCHAN>
.IF NB  <JOBBLK>
...CM2	<JOBBLK>,4,E
.IFF
...CM2	#0,4,E
.ENDC
.ENDM

.MACRO .CLOSE	CHAN
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
.IF EQ ...V1-1
	EMT	^O<160+CHAN>
.IFF
...CM3 <CHAN>,6.
.ENDC
.ENDM

.MACRO .CMKT	AREA,ID,TIME=#0,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM6	<AREA>,19,0,<CODE>,<ID>
...CM2	<TIME>,4,E,C
.ENDM

.MACRO .CNTXS	AREA,ADDR,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM6	<AREA>,27,0,<CODE>,<ADDR>,E
.ENDM

.MACRO .CRAW	AREA,ADDR,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM6	<AREA>,30,2,<CODE>,<ADDR>,E
.ENDM

.MACRO .CRRG	AREA,ADDR,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM6	<AREA>,30,0,<CODE>,<ADDR>,E
.ENDM

.MACRO .CSIGE	DEVSPC,DEFEXT,CSTRNG,LINBUF,LINSIZ
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
.IF NB <LINBUF>
...CM0	<LINBUF>
.IF NB <LINSIZ>
...CM0	<LINSIZ>
...CM0	#0
.ENDC
.NTYPE	...V2,DEVSPC
.IF EQ ...V2-^O27
...CM0	<DEVSPC'+1>
.IFF
...CM0	<DEVSPC>
	INC	(SP)
.ENDC
.IFF
...CM0	<DEVSPC>
.ENDC
...CM0	<DEFEXT>
...CM0	<CSTRNG>,344
.ENDM

.MACRO .CSISP	OUTSPC,DEFEXT,CSTRNG,LINBUF,LINSIZ
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
.IF NB <LINBUF>
...CM0	<LINBUF>
.IF NB <LINSIZ>
...CM0	<LINSIZ>
...CM0	#0
.ENDC
.NTYPE	...V2,OUTSPC
.IF EQ ...V2-^O27
...CM0	<OUTSPC'+1>
.IFF
...CM0	<OUTSPC>
	INC	(SP)
.ENDC
.IFF
...CM0	<OUTSPC>
.ENDC
...CM0	<DEFEXT>
...CM0	<CSTRNG>,345
.ENDM

.MACRO .CSTAT	AREA,CHAN,ADDR,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM1	<AREA>,23,<CHAN>,<CODE>,<ADDR>,E
.ENDM

.MACRO .CTIMI	TBK
	JSR	R5,@$TIMIT
	.WORD	TBK-.
	.WORD	1
.ENDM

.MACRO .DATE
	MOV	#^O5000,R0
	EMT	^O374
.ENDM

.MACRO .DELET	AREA,CHAN,DBLK,SEQNUM,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
.IF EQ ...V1-1
...CM5	<CHAN>,<AREA>
.IFF
...CM5	<AREA>
.IF IDN <CHAN>,#0
	CLR	@R0
.IFF
.IIF IDN <CHAN> <0> .ERROR ;?SYSMAC-W-Invalid argument, use #0, not 0;
...V2=0
.IF B <CODE>
.IIF B <AREA>, ...V2=1
.IFF
.IIF DIF <CODE>,SET, ...V2=1
.ENDC
.IF NE ...V2
.IIF NB <CHAN>	MOVB	CHAN,@R0
.IFF
.IF B <CHAN>
	CLRB	1(R0)
.IFF
.NTYPE ...V2,CHAN
.IF EQ ...V2-^O27
	MOV	CHAN,@R0
.IFF
	CLR	@R0
	MOVB	CHAN,@R0
.ENDC
.ENDC
.ENDC
.ENDC
...CM2	<DBLK>,2
...CM2	<SEQNUM>,4,E,C
.ENDC
.ENDM

.MACRO .DEVIC	AREA,ADDR,LINK,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
.IF B LINK
...CM6	<AREA>,12,0,<CODE>,<ADDR>,E
.IFF
...CM6	<AREA>,12,1,<CODE>,<ADDR>,E
.ENDC
.ENDM

.MACRO .DRAST	NAME,PRI,ABT
.GLOBL	$INPTR
.IF B <ABT>
	RETURN
.IFF
	BR	ABT
.ENDC
NAME'INT:: JSR	R5,@$INPTR
	.WORD	^C<PRI*^O40>&^O340
.ENDM

.MACRO .DRBEG	NAME,VEC,DSIZ,DSTS,VTBL
.ASECT
.=^O52
.GLOBL	NAME'END,NAME'INT
	.WORD	<NAME'END-NAME'STRT>
.IF B	<DSIZ>
	.WORD	NAME'DSIZE
.IFF
	.WORD	DSIZ
.ENDC
.IF B	<DSTS>
	.WORD	NAME'STS
.IFF
	.WORD	DSTS
.ENDC
	.WORD	^O<ERL$G+<MMG$T*2>+<TIM$IT*4>+<RTE$M*10>>
.=^O176
.IIF DF NAME'$CSR, .WORD	NAME'$CSR
.PSECT	NAME'DVR
NAME'STRT::
.IF NB	VTBL
.GLOBL	VTBL
	.WORD	<VTBL-.>/2.-1+^O100000
.IFF
.IF NB	<VEC>
.IIF NE	VEC&3.	.ERROR	VEC ;?SYSMAC-E-Odd or invalid vector specified;
	.WORD	VEC&^C3.
.IFF
.IF DF	NAME'$VTB
.GLOBL	NAME'$VTB
	.WORD	<NAME'$VTB-.>/2.-1+^O100000
.IFF
.IIF NE	NAME'$VEC&3.	.ERROR	NAME'$VEC ;SYSMAC-E-Odd or invalid vector specified;
	.WORD	NAME'$VEC&^C3.
.ENDC
.ENDC
.ENDC
	.WORD	NAME'INT-.,^O340
NAME'SYS::
NAME'LQE::	.WORD	0
NAME'CQE::	.WORD	0
.ENDM

;++
;	.DRBOT
;
;	CONTROL= is used to generate the controller description bits
;	in the boot block.  The default value is correct for nearly
;	all RT supported devices. As many options may be specified as
;	are supported by the boot code:
;
;	<UBUS>	Unibus device
;	<QBUS>	Q-Bus device
;	<CBUS>	PC-Bus device
;	<UMSCP>	Unibus MSCP device
;	<QMSCP>	Q-Bus MSCP device
;	<CMSCP>	PC-Bus MSCP device
;
;	SIDES= is used to indicate the number of sides supported in
;	floppy disk drive.  Valid values are 1 and 2.  Hard media
;	sidedness is not coded.
;
;	NOTE: the definition of a code does NOT imply any present
;	or future product committment.
;--
.MACRO .DRBOT	NAME,ENTRY,READ,CONTROL=<UBUS,QBUS>,SIDES=1
	.DREND	NAME
.IIF NDF TPS, TPS=^O177564
.IIF NDF TPB, TPB=^O177566
LF=^O12
CR=^O15
B$BOOT=^O1000
B$DEVN=^O4716
B$DEVU=^O4722
B$READ=^O4730
.IF EQ	MMG$T
B$DNAM=^R'NAME
.IFF
B$DNAM=^R'NAME'X
.ENDC
.ASECT
.=^O62
	.WORD	NAME'BOOT,NAME'BEND-NAME'BOOT,READ-NAME'BOOT
.PSECT	NAME'BOOT
NAME'BOOT::NOP
	BR	ENTRY-2.
...V2=^O100
.IRP	X	<CONTROL>
...V3=0
.IIF	IDN	<X>	<UBUS>	...V3=1.
.IIF	IDN	<X>	<QBUS>	...V3=2.
.IIF	IDN	<X>	<CBUS>	...V3=4.
.IIF	IDN	<X>	<QMSCP>	...V3=^O10
.IIF	IDN	<X>	<UMSCP>	...V3=^O20
.IIF	IDN	<X>	<CMSCP>	...V3=^O40
.IIF	EQ	...V3	.ERROR	;?SYSMAC-E-Invalid c o n t r o l value - control;
...V2=...V2!...V3
.ENDR
.=ENTRY-6.
	.BYTE	^O20,...V2,^O20,^O^C<20+...V2+20>
.IF	EQ	<SIDES-1>
	BR	ENTRY
.IFF
.IF	EQ	<SIDES-2.>
	BMI	ENTRY
.IFF
	.ERROR ;?SYSMAC-E-Invalid s i d e s value - sides;
.ENDC
.ENDC
.ENDM

.MACRO .DRDEF	NAME,CODE,STAT,SIZE,CSR,VEC
.MCALL	.DRAST,.DRBEG,.DRBOT,.DREND,.DRFIN,.DRSET,.DRVTB,.FORK,.QELDF
.IIF NDF RTE$M RTE$M=0
.IIF NE RTE$M RTE$M=1
.IIF NDF TIM$IT TIM$IT=0
.IIF NE TIM$IT TIM$IT=1
.IIF NDF MMG$T MMG$T=0
.IIF NE MMG$T MMG$T=1
.IIF NDF ERL$G ERL$G=0
.IIF NE ERL$G ERL$G=1
.IIF NE TIM$IT .MCALL	.TIMIO,.CTIMI
.QELDF
HDERR$=1
EOF$=^O20000
VARSZ$=^O400
ABTIO$=^O1000
SPFUN$=^O2000
HNDLR$=^O4000
SPECL$=^O10000
WONLY$=^O20000
RONLY$=^O40000
FILST$=^O100000
NAME'DSIZ=SIZE
NAME'$COD=CODE
NAME'STS=<CODE>!<STAT>
.IIF NDF NAME'$CSR, NAME'$CSR=CSR
.IIF NDF NAME'$VEC, NAME'$VEC=VEC
.GLOBL	NAME'$CSR,NAME'$VEC
.ENDM

;++
;	.DREND
;
;	FORCE is used to force the generation of the vector table
;	assigning a value to FORCE causes the associated sysgen
;	bit value to "forced" on for purposes of generating the table.
;
;	FORCE=1 will force generation of the error logging vector
;	for instance.
;--
.MACRO .DREND	NAME,FORCE=0
.PSECT	NAME'DVR
.IIF NDF NAME'$END, NAME'$END:
.IF EQ	.-NAME'$END
NAME'$END::
.IF NE MMG$T!<FORCE&2.>
$RLPTR::.WORD	0
$MPPTR::.WORD	0
$GTBYT::.WORD	0
$PTBYT::.WORD	0
$PTWRD::.WORD	0
.ENDC
.IIF NE ERL$G!<FORCE&1> $ELPTR::.WORD	0
.IIF NE TIM$IT!<FORCE&4.> $TIMIT::.WORD	0
$INPTR::.WORD	0
$FKPTR::.WORD	0
.GLOBL	NAME'STRT
NAME'END==.
.IFF
.PSECT	NAME'BOOT

.IIF LT	<NAME'BOOT-.+^O664>, .ERROR ;?SYSMAC-E-Primary boot too large;

.=NAME'BOOT+^O664
BIOERR:	JSR	R1,REPORT
	 .WORD	IOERR-NAME'BOOT

REPORT:	MOV	#BOOTF-NAME'BOOT,R0
	JSR	R1,REP
	MOV	(R1)+,R0
	JSR	R1,REP
	MOV	#CRLFLF-NAME'BOOT,R0
	JSR	R1,REP
	RESET
	HALT
	BR	.-2.

REPOR:	MOVB	(R0)+,@#TPB
REP:	TSTB	@#TPS
	BPL	REP
	TSTB	@R0
	BNE	REPOR
	RTS	R1

BOOTF:	.ASCIZ	<CR><LF>"?BOOT-U-"<^O200>
CRLFLF:	.ASCIZ	<CR><LF><LF>
IOERR:	.ASCIZ	"I/O error"
	.EVEN
NAME'BEND::
.ENDC
.ENDM

.MACRO .DRFIN	NAME
.GLOBL	NAME'CQE
	MOV	PC,R4
	ADD	#NAME'CQE-.,R4
	MOV	@#^O54,R5
	JMP	@^O270(R5)
.ENDM

.MACRO .DRSET	OPTION,VAL,RTN,MODE
.ASECT
.IF LE	.-^O400
.=^O400
.IFF
.=.-2.
.ENDC
;...V2=0
;.IRP X,<VAL>
;.IIF EQ ...V2 .IIF EQ <X> .ERROR ;?SYSMAC-E-V A L Must not be 0, VAL;
;...V2=...V2+1
;.ENDR
	VAL
...V2=.
	.RAD50	\OPTION\
.=...V2+4.
	.BYTE	<RTN-^O400>/2.
...V2=0
.IRP X,<MODE>
.IF IDN <X>,<NUM>
...V2=...V2!^O100
.IFF
.IF IDN <X>,<NO>
...V2=...V2!^O200
.IFF
.IF IDN <X>,<OCT>
...V2=...V2!^O140
.IFF
.ERROR	;?SYSMAC-E-Invalid parameter x;
.ENDC
.ENDC
.ENDC
.ENDR
	.BYTE	...V2
	.WORD	0
.ENDM

.MACRO .DRVTB	NAME,VEC,INT,PS=0
.IF NB	NAME
NAME'$VTB::
.IFF
.=.-2.
.ENDC
.IIF NE	VEC&3.	.ERROR	VEC ;?SYSMAC-E-Odd or invalid vector specified;
	.WORD	VEC&^C3.,INT-.,^O340!PS,0
.ENDM

.MACRO .DSTAT	RETSPC,DNAM
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM5	<DNAM>
...CM0	<RETSPC>,342
.ENDM

.MACRO .ELAW	AREA,ADDR,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM6	<AREA>,30,3,<CODE>,<ADDR>,E
.ENDM

.MACRO .ELRG	AREA,ADDR,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM6	<AREA>,30,1,<CODE>,<ADDR>,E
.ENDM

.MACRO .ENTER	AREA,CHAN,DBLK,LEN,SEQNUM,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
.IF EQ ...V1-1
...CM5	<CHAN>
...CM0	<DBLK>,<40+AREA>
.IFF
...CM1	<AREA>,2,<CHAN>,<CODE>,<DBLK>
...CM2	<LEN>,4,,C
...CM2	<SEQNUM>,6,E,C
.ENDC
.ENDM

.MACRO .EXIT
	EMT	^O350
.ENDM

.MACRO .FETCH	ADDR,DNAM
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM5	<DNAM>
...CM0	<ADDR>,343
.ENDM

.MACRO .FORK	FKBLK
	JSR	R5,@$FKPTR
	.WORD	FKBLK - .
.ENDM

.MACRO .FPROT	AREA,CHAN,DBLK,PROT=#1,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM1	<AREA>,35,<CHAN>,<CODE>,<DBLK>
...CM2	<PROT>,4,E,,B
.ENDM

.MACRO .GMCX	AREA,ADDR,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM6	<AREA>,30,6,<CODE>,<ADDR>,E
.ENDM

.MACRO .GTIM	AREA,ADDR,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM6	<AREA>,17,0,<CODE>,<ADDR>,E
.ENDM

.MACRO .GTJB	AREA,ADDR,JOBBLK,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM6	<AREA>,16,1,<CODE>,<ADDR>
.IF NB  <JOBBLK>
.IF IDN <JOBBLK>,<ME>
...CM2	#-1,4,E
.IFF
...CM2	<JOBBLK>,4,E
.ENDC
.IFF
...CM2	#-3.,4,E
.ENDC
.ENDM

.MACRO .GTLIN	LINBUF,PROMPT,TYPE,LINSIZ
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM0	<LINBUF>
.IF NB <LINSIZ>
...CM0	<LINSIZ>
...CM0	#0
.ENDC
.IF	NB	<TYPE>
...CM0	#3.
.IFF
...CM0	#1
.ENDC
...CM0	<PROMPT>
...CM0	,345
.ENDM

.MACRO .GVAL	AREA,OFFSE,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM6	<AREA>,28,0,<CODE>,<OFFSE>,E
.ENDM

.MACRO .HERR
	MOV	#^O2400,R0
	EMT	^O374
.ENDM

.MACRO .HRESE
	EMT	^O357
.ENDM

.MACRO .INTEN	PRIO,PIC
.IF B PIC
	JSR	R5,@^O54
.IFF
	MOV	@#^O54,-(SP)
	JSR	R5,@(SP)+
.ENDC
	.WORD	^C<PRIO*32.>&224.
.ENDM

.MACRO .LOCK
	EMT	^O346
.ENDM

.MACRO .LOOKU	AREA,CHAN,DBLK,SEQNUM,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
.IF EQ ...V1-1
...CM5	<CHAN>,<20+AREA>
.IFF
...CM1	<AREA>,1,<CHAN>,<CODE>,<DBLK>
...CM2	<SEQNUM>,4,E,C
.ENDC
.ENDM

.MACRO .MAP	AREA,ADDR,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM6	<AREA>,30,4,<CODE>,<ADDR>,E
.ENDM

.MACRO .MFPS	ADDR
	MOV	@#^O54,-(SP)
	ADD	#^O362,(SP)
	CALL	@(SP)+
.IIF NB	<ADDR>	MOVB	(SP)+,ADDR
.ENDM

;++
;	.MODULE
;
;	Macro to define a standard identification for all
;	modules.
;
;	Inputs:
;
;	MODULE  1-5 character symbol name	(KEDIO)
;	RELEASE 3 char release identification	(X05)
;	VERSION 2 char version number		(09)
;	COMMENT n char title string		<I/O Module>
;
;	TITLE=YES generate .TITLE		(default)
;	TITLE=NO  do not generate .TITLE
;
;	IDENT=YES generate .IDENT		(default)
;	IDENT=NO  do not generate .IDENT
;
;	AUDIT=NO  generate .AUDIT call		(default)
;	AUDIT=YES generate .AUDIT call
;
;	LIB=NO	generate .AUDIT global value	(default)
;	LIB=YES	do not generate .AUDIT
;
;	GLOBAL	  not specified 		(default)
;	GLOBAL=gname substitutes gname for .'MODULE'
;
;	MODNAME   not specified uses MODULE	(default)
;	MODNAME=module name for .TITLE
;
;	Outputs:
;
;	.TITLE	'MODULE' - 'COMMENT'		title for module
;	.IDENT	"'RELEASE'.'VERSION'"		ident for module
;	.'MODULE' ==:	'VERSION'.		version value symbol Binary
;	.AUDIT	==:	^R'RELEASE'		release value symbol RAD50
;
;	.MCALL	.AUDIT				get .AUDIT definition
;	.AUDIT	.AUDIT	.'MODULE'		generate audit information
;
;
;	definition of .NLCSI macro		generate program ID string
;
;	.NLCSI	TYPE=,PART=
;	TYPE=Z	generate .ASCIZ	(default)	.ASCIZ "KEDIO X05.09 "
;	TYPE=I	generate .ASCII			.ASCII "KEDIO X05.09 "
;
;	PART=ALL    generate std ID (default)	.ASCIZ "KEDIO X05.09 "
;	PART=NAME   generate name		.ASCIZ "KEDIO"
;	PART=RLSVER generate release & version	.ASCIZ "X05.09"
;	PART=PREFIX generate message prefix	.ASCIZ "?KEDIO-"
;
;	definition of .RMODULE macro		generate RAD50 for 'MODULE'
;
;	.RMODULE
;--

.MACRO .MODULE	MODULE,RELEASE,VERSION,COMMENT,TITLE=YES,IDENT=YES,AUDIT=NO,GLOBAL,LIB=NO,MODNAME
.MCALL	.AUDIT
.IF	NB	<MODNAME>
 .IIF	IDN	<TITLE> <YES>	.TITLE	'MODNAME'	- 'COMMENT'
.IFF
 .IIF	IDN	<TITLE> <YES>	.TITLE	'MoDULE'	- 'COMMENT'
.ENDC
.IIF	IDN	<IDENT> <YES>	.IDENT	"'RELEASE'.'VERSION'"
.IIF	IDN	<LIB> <NO>	.AUDIT==:^R'RELEASE'
.IF	NB	<GLOBAL>
'GLOBAL'==:'VERSION'.
.IIF	IDN	<AUDIT> <YES>	.AUDIT	'GLOBAL'
.IFF
.'MODULE'==:'VERSION'.
.IIF	IDN	<AUDIT> <YES>	.AUDIT	.'MODULE'
.ENDC
.MACRO	.NLCSI	TYPE=Z,PART=ALL
.IIF	IDN	<PART> <ALL>	.ASCI'TYPE'	"'MODULE' 'RELEASE'.'VERSION' "
.IIF	IDN	<PART> <NAME>	.ASCI'TYPE'	"'MODULE'"
.IIF	IDN	<PART> <RLSVER> .ASCI'TYPE'	"'RELEASE'.'VERSION' "
.IIF	IDN	<PART> <PREFIX> .ASCI'TYPE'	"?'MODULE'-"
.ENDM
.MACRO	.RMODULE
	.RAD50	"'MODULE'"
.ENDM
...V5=^O110
.ENDM

.MACRO .MRKT	AREA,TIME,CRTN,ID,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM6	<AREA>,18,0,<CODE>,<TIME>
...CM2	<CRTN>,4
...CM2	<ID>,6,E
.ENDM

.MACRO .MTATC	AREA,ADDR,UNIT,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM6	<AREA>,31,5,<CODE>,<ADDR>
...CM2	<UNIT>,4,E,,B
.ENDM

.MACRO .MTDTC	AREA,UNIT,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM6	<AREA>,31,6,<CODE>
...CM2	<UNIT>,4,E,,B
.ENDM

.MACRO .MTGET	AREA,ADDR,UNIT,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM6	<AREA>,31,1,<CODE>,<ADDR>
...CM2	<UNIT>,4,E,,B
.ENDM

.MACRO .MTIN	AREA,ADDR,UNIT,CHRCNT,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM6	<AREA>,31,2,<CODE>,<ADDR>
...CM2	<UNIT>,4,,,B
...CM2	<CHRCNT>,5,E,,B
.ENDM

.MACRO .MTOUT	AREA,ADDR,UNIT,CHRCNT,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM6	<AREA>,31,3,<CODE>,<ADDR>
...CM2	<UNIT>,4,,,B
...CM2	<CHRCNT>,5,E,,B
.ENDM

.MACRO .MTPRN	AREA,ADDR,UNIT,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM6	<AREA>,31,7,<CODE>,<ADDR>
...CM2	<UNIT>,4,E,,B
.ENDM

.MACRO .MTPS	ADDR
.IIF NB	<ADDR>	CLR	-(SP)
.IIF NB	<ADDR>	MOVB	ADDR,(SP)
	MOV	@#^O54,-(SP)
	ADD	#^O360,(SP)
	CALL	@(SP)+
.ENDM

.MACRO .MTRCT	AREA,UNIT,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM6	<AREA>,31,4,<CODE>
...CM2	<UNIT>,4,E,,B
.ENDM

.MACRO .MTSET	AREA,ADDR,UNIT,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM6	<AREA>,31,0,<CODE>,<ADDR>
...CM2	<UNIT>,4,E,,B
.ENDM

.MACRO .MTSTA	AREA,ADDR,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM6	<AREA>,31,8,<CODE>,<ADDR>
...CM2	#0,4,E
.ENDM

.MACRO .MWAIT
	MOV	#^O4400,R0
	EMT	^O374
.ENDM

.MACRO	.PEEK	AREA,ADDR,CODE
.IF NDF	...V1
.MCALL	.MACS
.MACS
.ENDC
...CM6	<AREA>,28,1,<CODE>,<ADDR>,E
.ENDM

.MACRO	.POKE	AREA,ADDR,VALUE,CODE
.IF NDF	...V1
.MCALL	.MACS
.MACS
.ENDC
...CM6	<AREA>,28,3,<CODE>,<ADDR>
...CM2	<VALUE>,4,E
.ENDM

.MACRO .PRINT	ADDR
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM5	<ADDR>,351
.ENDM

.MACRO .PROTE	AREA,ADDR,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM6	<AREA>,25,0,<CODE>,<ADDR>,E
.ENDM

.MACRO .PURGE	CHAN
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM3	<CHAN>,3.
.ENDM

.MACRO	.PVAL	AREA,OFFSE,VALUE,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM6	<AREA>,28,2,<CODE>,<OFFSE>
...CM2	<VALUE>,4,E
.ENDM

.MACRO .QELDF
.IIF NDF MMG$T, MMG$T=1
.IIF NE MMG$T, MMG$T=1
Q.LINK=0
Q.CSW=2.
Q.BLKN=4.
Q.FUNC=6.
Q.JNUM=7.
Q.UNIT=7.
Q.BUFF=^O10
Q.WCNT=^O12
Q.COMP=^O14
.IRP	X,<LINK,CSW,BLKN,FUNC,JNUM,UNIT,BUFF,WCNT,COMP>
Q$'X=Q.'X-4
.ENDR
.IF EQ MMG$T
Q.ELGH=^O16
.IFF
Q.PAR=^O16
Q$PAR=^O12
Q.ELGH=^O24
.ENDC
.ENDM

.MACRO .QSET	ADDR,LEN
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM5	<LEN>
...CM0	<ADDR>,353
.ENDM

.MACRO .RCTRL
	EMT	^O355
.ENDM

.MACRO .RCVD	AREA,BUF,WCNT,CRTN=#1,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM4 <AREA>,<BUF>,<WCNT>,<CRTN>,22,<CODE>
.ENDM

.MACRO .RCVDC	AREA,BUF,WCNT,CRTN,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM4 <AREA>,<BUF>,<WCNT>,<CRTN>,22,<CODE>
.ENDM

.MACRO .RCVDW	AREA,BUF,WCNT,CRTN=#0,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM4 <AREA>,<BUF>,<WCNT>,<CRTN>,22,<CODE>
.ENDM

.MACRO .RDBBK	RGSIZ
.MCALL	.RDBDF
.RDBDF
	.WORD
	.WORD	RGSIZ
	.WORD
.ENDM

.MACRO .RDBDF
R.GID=0
R.GSIZ=2.
R.GSTS=4.
R.GLGH=6.
RS.CRR=^O100000
RS.UNM=^O40000
RS.NAL=^O20000
.ENDM

.MACRO .READ	AREA,CHAN,BUF,WCNT,BLK,CRTN=#1,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM7	<AREA>,<CHAN>,<BUF>,<WCNT>,<BLK>,<CRTN>,8,<CODE>,200
.ENDM

.MACRO .READC	AREA,CHAN,BUF,WCNT,CRTN,BLK,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM7	<AREA>,<CHAN>,<BUF>,<WCNT>,<BLK>,<CRTN>,8,<CODE>,200
.ENDM

.MACRO .READW	AREA,CHAN,BUF,WCNT,BLK,CRTN=#0,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM7	<AREA>,<CHAN>,<BUF>,<WCNT>,<BLK>,<CRTN>,8,<CODE>,200
.ENDM

.MACRO .REGDEF
.ENDM

.MACRO .RELEA	DNAM
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM5	<DNAM>
...CM0	,343
.ENDM

.MACRO .RENAM	AREA,CHAN,DBLK,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
.IF EQ ...V1-1
...CM5	<CHAN>,<100+AREA>
.IFF
...CM1	<AREA>,4,<CHAN>,<CODE>,<DBLK>,E
.ENDC
.ENDM

.MACRO .REOPE	AREA,CHAN,CBLK,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
.IF EQ ...V1-1
...CM5	<CHAN>,<140+AREA>
.IFF
...CM1	<AREA>,6,<CHAN>,<CODE>,<CBLK>,E
.ENDC
.ENDM

.MACRO .RSUM
	MOV	#^O1000,R0
	EMT	^O374
.ENDM

.MACRO .SAVES	AREA,CHAN,CBLK,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
.IF EQ ...V1-1
...CM5	<CHAN>,<120+AREA>
.IFF
...CM1	<AREA>,5,<CHAN>,<CODE>,<CBLK>,E
.ENDC
.ENDM

.MACRO .SCCA	AREA,ADDR,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM6	<AREA>,29,0,<CODE>,<ADDR>,E
.ENDM

.MACRO .SDAT	AREA,BUF,WCNT,CRTN=#1,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM4 <AREA>,<BUF>,<WCNT>,<CRTN>,21,<CODE>
.ENDM

.MACRO .SDATC	AREA,BUF,WCNT,CRTN,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM4 <AREA>,<BUF>,<WCNT>,<CRTN>,21,<CODE>
.ENDM

.MACRO .SDATW	AREA,BUF,WCNT,CRTN=#0,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM4 <AREA>,<BUF>,<WCNT>,<CRTN>,21,<CODE>
.ENDM

.MACRO .SDTTM	AREA,ADDR,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM6	<AREA>,32,0,<CODE>,<ADDR>,E
.ENDM

.MACRO .SERR
	MOV	#^O2000,R0
	EMT	^O374
.ENDM

.MACRO .SETTO	ADDR
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM5	<ADDR>,354
.ENDM

.MACRO .SFDAT	AREA,CHAN,DBLK,DATE=#0,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM1	<AREA>,34,<CHAN>,<CODE>,<DBLK>
...CM2	<DATE>,4,E
.ENDM

.MACRO .SFPA	AREA,ADDR,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM6	<AREA>,24,0,<CODE>,<ADDR>,E
.ENDM

.MACRO .SPCPS	AREA,ADDR,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM6	<AREA>,33,0,<CODE>,<ADDR>,E
.ENDM

.MACRO .SPFUN	AREA,CHAN,FUNC,BUF,WCNT,BLK,CRTN=#0,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM1	<AREA>,26,<CHAN>,<CODE>,<BLK>
...CM2	<BUF>,4
...CM2	<WCNT>,6
.IF NB FUNC
.NTYPE ...V2,FUNC
.IF NE ...V2-^O27
.IIF DIF <CODE>,NOSET,...CM2	#^O377,8,,,B
...CM2	<FUNC>,9,,,B
.IFF
...CM2	<FUNC'*^O400+^O377>,8
.ENDC
.ENDC
...CM2	<CRTN>,10,E,C
.ENDM

.MACRO .SPND
	MOV	#^O400,R0
	EMT	^O374
.ENDM

.MACRO .SRESE
	EMT	^O352
.ENDM

.MACRO .SYNCH	AREA,PIC
.IF B PIC
.IIF NB <AREA>	MOV	AREA,R4
.IFF
.IF NB AREA
	MOV	PC,R4
	ADD	#AREA-.,R4
.ENDC
.ENDC
	MOV	@#^O54,R5
	JSR	R5,@^O324(R5)
.ENDM

.MACRO .TIMIO	TBK,HI,LO
	JSR	R5,@$TIMIT
	.WORD	TBK-.
	.WORD	0
	.WORD	HI
	.WORD	LO
.ENDM

.MACRO .TLOCK
	MOV	#^O3400,R0
	EMT	^O374
.ENDM

.MACRO .TRPSE	AREA,ADDR,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM6	<AREA>,3,0,<CODE>,<ADDR>,E
.ENDM

.MACRO .TTINR
	EMT	^O340
.ENDM

.MACRO .TTOUT
	EMT	^O341
.ENDM

.MACRO .TTYIN	CHAR
	EMT	^O340
	BCS	.-2.
.IF NB <CHAR>
.IIF DIF <CHAR>,R0	MOVB	R0,CHAR
.ENDC
.ENDM

.MACRO .TTYOU	CHAR
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM5	<CHAR>,341,B
	BCS	.-2.
.ENDM

.MACRO .TWAIT	AREA,TIME,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM6	<AREA>,20,0,<CODE>,<TIME>,E
.ENDM

.MACRO .UNLOC
	EMT	^O347
.ENDM

.MACRO .UNMAP	AREA,ADDR,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM6	<AREA>,30,5,<CODE>,<ADDR>,E
.ENDM

.MACRO .UNPRO	AREA,ADDR,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM6	<AREA>,25,1,<CODE>,<ADDR>,E
.ENDM

.MACRO .WAIT	CHAN
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
.IF EQ ...V1-1
	EMT	^O<240+CHAN>
.IFF
.IF B <CHAN>
	CLR	R0
.IFF
.NTYPE ...V2,CHAN
.IF EQ ...V2-^O27
.IF IDN <CHAN>,#0
	CLR	R0
.IFF
.IIF IDN <CHAN> <0> .ERROR ;?SYSMAC-W-Invalid argument, use #0, not 0;
	MOV	CHAN,R0
.ENDC
.IFF
	CLR	R0
	BISB	CHAN,R0
.ENDC
.ENDC
	EMT	^O374
.ENDC
.ENDM

.MACRO .WDBBK	WNAPR,WNSIZ,WNRID,WNOFF,WNLEN,WNSTS
.MCALL	.WDBDF
.WDBDF
	.BYTE
	.BYTE	WNAPR
	.WORD
	.WORD	WNSIZ
	.WORD	WNRID
	.WORD	WNOFF
	.WORD	WNLEN
	.WORD	WNSTS
.ENDM

.MACRO .WDBDF
W.NID=0
W.NAPR=1
W.NBAS=2.
W.NSIZ=4.
W.NRID=6.
W.NOFF=^O10
W.NLEN=^O12
W.NSTS=^O14
W.NLGH=^O16
WS.CRW=^O100000
WS.UNM=^O40000
WS.ELW=^O20000
WS.MAP=^O400
.ENDM

.MACRO .WRITC	AREA,CHAN,BUF,WCNT,CRTN,BLK,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM7	<AREA>,<CHAN>,<BUF>,<WCNT>,<BLK>,<CRTN>,9,<CODE>,220
.ENDM

.MACRO .WRITE	AREA,CHAN,BUF,WCNT,BLK,CRTN=#1,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM7	<AREA>,<CHAN>,<BUF>,<WCNT>,<BLK>,<CRTN>,9,<CODE>,220
.ENDM

.MACRO .WRITW	AREA,CHAN,BUF,WCNT,BLK,CRTN=#0,CODE
.IF NDF ...V1
.MCALL .MACS
.MACS
.ENDC
...CM7	<AREA>,<CHAN>,<BUF>,<WCNT>,<BLK>,<CRTN>,9,<CODE>,220
.ENDM
