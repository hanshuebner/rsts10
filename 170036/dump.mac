.TITLE	DUMP FILE UTILITY
.IDENT	/V04.00/

;                      COPYRIGHT (c) 1979, 1984 BY
;             DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.

; Edit History:
;
; 001	07-Jan-80 14:37    Gumbel, Dick (75498) [240,189]
;	Add .QSET to allow true overlapped I/O
;	(001)
;									;001
; EDIT LOG BETWEEN V03.04 AND V04.00:					;001
; TURN OFF NON-FILE-STRUCTURED LOOKUP AFTER VERSION NUMBER OBTAINED	;**-2
; ADD .CLOSE ERROR MESSAGE FOR PROTECTION VIOLATION			;MAS02
; DO ERROR CHECKING ON CSIGEN, INPUT FROM MEMORY REQUIRES DUMP TO DO IT	;MAS03
; CHECK FOR SEQ. DEVICE ON CHANNEL 3 SPECIFICALLY, ADD MS DEVICE	;MAS04
;									;001
;
; 002	14-Dec-84 14:44	   Gillum, Kirt (secret) [1,235]
;	Allow Printable Eight bit characters to pass.
;

	.ENABL	LC							;001
									;001
.MCALL	.SRESE,	.CSIGE,	.READW,	.WRITE,	.FETCH,	.LOOKU,	.PRINT
.MCALL	.SETTO, .WAIT,	.CLOSE,	.RCTRL, ..V2..
.MCALL	.CSISPC, .DSTATU, .RELEAS, .QSET				;001
	..V2..		;USE V2 MACRO EXPANSIONS			;**-1

; MACRO TO OUTPUT THE ERROR MESSAGE TO THE USER CONSOLE AND THE
; CORRECT ERROR CODE IN BYTE 53.  THE ERROR MESSAGE AND ERROR
; CODE ARE PASSED AS ARGUMENTS TO THE MACRO.
; R5--> CONTAINS THE ARGUMENTS TO BE PASSED.

.MACRO	ERROR	MESS
	JSR	R5,PRINT
	.WORD	MESS		;ERROR MESSAGE
.ENDM

.MACRO	PUT	ARG
	JSR	R3,@R2
	.WORD	ARG
.ENDM

.MACRO	OCT	ARG
	JSR	R3,OCTOUT
	.WORD	ARG
.ENDM


;DEFINITIONS FOR THE CHANNELS AND ERROR CODES FOR BYTE 53.
	NULL	=	000		;DEFINE NULL
	CR	=	015		;DEFINE CARRIAGE RETURN
	LF	=	012		;DEFINE LINE FEED
	EQUAL	=	075		;DEFINE EQUAL SIGN
	WARN	=	2		;OPERATION CAUSED A WARNING	;MAS02
	FATAL	=	8.		;NO RESULTS WERE PRODUCED
	INPUT	=	3		;CHANNEL 3
	INPUT1	=	4		;CHANNEL 4
	OUTPUT	=	0		;OUTPUT CHANNEL
	OUT1	=	1		;OUTPUT CHANNEL 1
	OUT2	=	2		;OUTPUT CHANNEL 2
	NFS	=	001		;NON FILE STRUCTURE LOOKUP SET FLAG
	CHAN	=	0		;DEFINE OUTPUT CHANNEL
	TAPDEV	=	2		;TAPE DEVICE CODE
	SPINIT	=	42		;INITIAL TOP OF STACK
	ERRLOC	=	52		;ERROR BYTE LOCATION
	PROTCT	=	3		;PROTECTION ERROR BYTE CODE	;MAS02
	MONBYT	=	53		;MONITOR ERROR BYTE LOCATION
	RMON	=	54		;START OF RMON
	USRBUF	=	266		;OFFSET FOR USR
	CSWEOF	=	20000
	LEOT	=	2		;LEOT DEFINED AS TWO SUCCEDING TAPE MARKS
	MAGTAP	=	4		;DEFINE MAGTAP CODE		;MAS04

.PSECT	DATA	;ORDER DATA PSECT FIRST

.PSECT	CODE

.SBTTL	ROUTINE INITIALIZATION

	BR	DUMP		;REENTRY ADDRESS			;001
	.SBTTL	RESTART							;**-1

DUMP::	MOV	@#SPINIT,SP	;INIT STACK				;001
	CLR	ORGTOP		;INSERT INITAL NULL BYTE		;**-1
	.SRESET
	.QSET	#QELM,#1	;ALLOCATE AN EXTRA QUEUE ELEMENT	;001
	CLRB	LOKFLG		;CLEAR LOOKUP TYPE			;MAS01
	CLRB	NODEV		;CLEAR DEVICE PRESENT FLAG
	JSR	R3,FILTYP	;CHECK FOR LOOKUP TYPE
	JSR	PC,MOVNAM	;MOVE INPUT FILE TO HEADER
				;FOR MAGTAPE AND CASSETTE
	.RCTRLO			;SPEAK, OH MIGHTY TTY
	.CSIGEN	#ORGTOP,#DEFEXT,#ORGTOP	;GET INPUT FILE
	BCC	4$		;C=0 NO ERRORS				;MAS03+
	MOVB	@#ERRLOC,R0	;GET ERROR BYTE TO CHECK NUMBER
	BNE	1$		;0?
	ERROR	MSG5		;52 = 0 -> ILLEGAL COMMAND ERROR

1$:	CMPB	#2,R0		;2?
	BNE	2$		;NO
	ERROR	MSG11		;52 = 2 -> PROTECTION ERROR ON .ENTER

2$:	CMPB	#3,R0		;3?
	BNE	3$		;NO
	ERROR	MSG12		;52 = 3 -> DEVICE FULL

3$:	ERROR	MSG6		;52 = 1 OR 4 -> FILE OR DEVICE NOT FOUND

4$:	CLRB	DETEOF		;CLEAR THE EOF COUNT			;MAS03-
	MOV	R0,R2		;SAVE THE PROGRAM TOP
	MOV	@#RMON,R0	;GET THE START OF RMON
	MOV	USRBUF(R0),R0	;LEAVE USR RESIDENT
	TST	-(R0)		;FIX FOR SETTOP
	.SETTOP			;ASK FOR FREE CORE
	TST	(R0)+		;REFIX
	MOV	R0,TOP		;SAVE THE POINTER TO TOP
	.WAIT	#OUT1		;MORE THAN ONE OUTPUT CHAN ?.
	BCS	5$		;NO THERE WAS'NT
	ERROR	MSG5		;YES OUTPUT ERROR
									;001

5$:	.WAIT	#OUT2		;ANOTHER OUTPUT CHAN.			;**-1
	BCS	6$		;NO THERE WAS'NT
	ERROR	MSG5		;YES OUTPUT ERROR

6$:	.WAIT	#INPUT1		;MORE THAN ONE INPUT CHAN
	BCS	7$		;NO THERE WAS'NT
	ERROR	MSG5		;YES IT WAS,OUTPUT ERROR

7$:	.WAIT	#INPUT		;WAS THERE AND INPUT DEVICE
	BCC	9$		;YES THERE WAS
	TST	(SP)		;ANY SWITCHES ON STACK
	BEQ	8$		;NO THERE WERE'NT
	ERROR	MSG6		;OTHERWISE NO INPUT FILE OR DEVICE

8$:	.PRINT	#VNUM		;PRINT THE VERSION NUMBER
	BR	DUMP							;001
									;**-1
9$:	.WAIT	#OUTPUT		;WAS THERE AN OUTPUT FILE OR DEVICE
	BCC	11$		;YES THERE WAS
	.FETCH	R2,#LP		;NO DEFAULT TO LP
	BCC	10$		;NO PROBLEM ON FETCHING LP
	ERROR	MSG0		;ERROR NO LP HANDLER PRESENT

10$:	MOV	R0,R2		;SAVE CORE PTR
	.LOOKUP	#LAREA,#CHAN,#LP	;CONVERT TO ..V2.. MACRO
	BCC	11$		;NO ERROR
	ERROR	MSG0		;ERROR IN GETTING LP

11$:	MOV	#TOP,R3		;POINT TO DATA STUFF
	MOV	(R3)+,R1	;GET TOP OF CORE
	MOV	R2,(R3)+	;SAVE START OF FREE
	SUB	R2,R1		;COMPUTE SIZE OF BUFFER
	CMP	R1,#1000	;MAKE SURE WE HAVE AT LEAST 256. WORDS
	BHI	12$		;ENOUGH CORE
	ERROR	MSG4		;NOT ENOUGH CORE

12$:	MOV	#1,(R3)+	;SAVE BUFFER SIZE OF ONE BLOCK
	MOV	#<CLEARE-CLEARS>/2,R0	;COUNT TO CLEAR
13$:	CLR	(R3)+
	DEC	R0
	BNE	13$		;CLEAR IT
	MOV	#-2,EBLOCK	;VERY HIGH END BLOCK
	JSR	PC,DEVTYP	;WHICH MAGNETIC DEVICE IS IT

.SBTTL	SWITCH INTERPRETER

SWINT:	MOV	(SP)+,R5	;GET SWITCH COUNT
1$:	DEC	R5		;ANY MORE?
	BPL	2$		;NO, DO THE DUMP
	JMP	BEGIN		;GO GET DATA
2$:	MOV	#SBLOCK,R3	;POINT TO POINTERS
	MOV	#SWTBL,R2	;SWITCH TABLE
	CMPB	@SP,#'O		;'ONLY' IS SPECIAL CASE
	BNE	3$
	MOV	2(SP),@R3	;WHICH SETS BEGIN BLOCK
	MOVB	#'E,@SP		;AND END BLOCK
3$:	CMPB	-(R2),@SP	;IS THIS THE ONE ?
	BEQ	5$		;GOT IT
	TST	(R3)+		;BUMP DESTINATION
	TSTB	-(R2)		;END OF TABLE ?
	BNE	3$		;NO, GO ON
4$:	ERROR	MSG1		;SWITCH ERROR

5$:	TST	(SP)+		;VALUE GIVEN ?
	BMI	6$		;YES, HANDLE IT THERE
	MOVB	-(R2),R0	;GET FIXED VALUE
	BMI	4$		;HE SHOULD HAVE GIVEN ONE
	MOV	R0,@R3		;PUT IN VALUE
	BR	1$

6$:	TSTB	-(R2)		;WAS VALUE LEGAL ?
	BPL	4$		;NO
	MOV	(SP)+,@R3	;YES, PUT IT IN
	BR	1$

	.SBTTL	END PROCESSING, ERRORS

EOFCHK:	TSTB	@#ERRLOC	;WHAT KIND?
	BEQ	2$		;EOF DETECTED,NO HARDWARE ERROR
	TST	IGNORE		;DO WE IGNORE ERRORS
	BEQ	1$		;DON'T IGNORE ERROR
	JMP	READIG		;IGNORE THE ERROR

1$:	ERROR	MSG3		;HARDWARE ERROR

2$:	CMP	DEVFLG,#TAPDEV	;IS IT A TAPE DEVICE
	BLO	LEFTBU		;NO IT'S NOT
	INC	EBLOCK		;DON'T COUNT TAPE MARKS
	TSTB	CHKFLG		;SUPPRESS TAPE MARKER
	BMI	FILL		;YES SUPPRESS IT
	PUT	OUTTM		;TAPE DEVICE,OUTPUT TAPE MARK MESSAGE
	PUT	CRLF		;OUTPUT <CR> AND <LF>
FILL:	CLRB	CHKFLG		;CLEAR POSTION FLAG
	CMPB	DEVFLG,#MAGTAP	;IS IT A MAGTAP DEVICE
	BHI	LEFTBU		;NO IT'S NOT
	TSTB	LOKFLG		;FILE STRUCTURE REQUEST
	BEQ	LEFTBU		;YES IT IS
	TST	NORT11		;IS IT AN RT11 STRUCTURED TAPE
	BNE	1$		;NO IT'S NOT,STOP ON CONSECETIVE TM
	TSTB	HEDCHK		;HAS HEADER BEEN READ
	BMI	READ		;YES IT HAS
	TSTB	EOFLAB		;HAS EOF LABEL BEEN READ
	BMI	1$		;ADD TO EOF COUNT
	BR	READ		;NO GO READ SOME MORE
									;001

1$:	INCB	DETEOF		;ADD TO EOF COUNT			;**-1
				;STOP ON CONSECETIVE TAPE MARKS
	CMPB	DETEOF,#LEOT	;ARE WE FINISHED YET
	BNE	READ		;NO WE HAV'NT
LEFTBU:	MOV	BUFCTR,R3	;GET NUMBER OF CHARS LEFT
	CMP	R3,#-512.	;EMPTY?
	BEQ	2$		;YES, CLOSE OUTPUT FILE
1$:	CLRB	(R4)+
	INC	R3
	BNE	1$
	JSR	PC,EMIT1	;WRITE BUFFER LOAD
2$:	.WAIT	#OUTPUT
	.CLOSE	#OUTPUT		;CLOSE OUTPUT
	BCC	3$		;C=0 -> NO ERRORS			;001
	CMPB	#PROTCT,@#ERRLOC ;PROTECTION ERROR?			;**-1
	BNE	3$		;NE -> NO				;001
	ERROR	MSG10		;PROTECTION VIOLATION			;**-1
3$:	.CLOSE	#INPUT		;CLOSE INPUT FILE			;001
	BCC	4$		;C=0 -> NO ERROR			;001
	CMPB	#PROTCT,@#ERRLOC ;PROTECTION ERROR?			;**-2
	BNE	4$							;001
	ERROR	MSG10		;PROTECTION ERROR,UNLIKELY TO GET ONE ON;**-1
4$:	CMP	SBLOCK,TEMBLO	;IS IT AN ERROR				;001
	BNE	5$		;NO IT'S NOT				;001
	ERROR	MSG7		;EOF DETECTED ,START BLOCK LARGER THAN F;**-2

5$:	.RELEAS	#INDEV		;RELEASE THE INPUT HANDLER		;001
	.RELEAS	#OUTDEV		;RELEASE THE OUTPUT HANDLER		;**-1
	.SETTOP	#ORGTOP		;BRING USER TOP DOWN
	JMP	DUMP							;001
									;**-1

.SBTTL	FILE INITIALIZATION, READ
									;001
BEGIN:	JSR	PC,CHKPOS	;LOOK FOR TAPE POSITION
	MOV	#LBUFF1,R4	;START WITH BUFFER 1
	MOV	#-512.,BUFCTR	;COUNT OF SIZE
	MOV	EBLOCK,LIMIT	;SAVE UPPER LIMIT
	MOV	#SBLOCK,R3	;POINT TO POINTERS
	SUB	(R3)+,@R3	;COMPUTE # OF BLOCKS
	BHIS	1$		;SWITCHES ARE SAME OR DIFFERENT
	ERROR	MSG1		;SWITCH ERROR

1$:	MOV	SBLOCK,TEMBLO	;SAVE START BLOCK FOR DISC ERROR
	INC	@R3		;MAKE IT REAL COUNT
	MOV	#FORCE,R2	;WE CALL THIS A LOT
	MOV	#DEVNAM,HDRPTR	;DO NOT START W/ FORM FEED
READ:	MOV	#BUFFER,R3	;POINT TO DATA BUFFER PTR
	MOV	(R3)+,R5	;R5 -> DATA BUFFER
	MOV	(R3)+,R1	;R1 =  # BLOCKS IN BUFFER
	MOV	(R3)+,R0	;R0 =  BLOCK # TO START
	CMP	R1,@R3		;BUFSIZ <= XFER LEFT?
	BLOS	1$		;YES, READ ENTIRE BUFFER LOAD
	TSTB	CHKFLG		;READ SOME MORE
	BMI	2$		;YES READ ONE MORE
	MOV	@R3,R1		;NO, READ ONLY WHAT'S LEFT
	BEQ	LEFTBU		;DONE!
1$:	SUB	R1,@R3		;DECREMENT BLOCKS LEFT
	BR	3$		;BRANCH AROUND

2$:	MOV	#1,R1		;READ ONE MORE BLOCK
3$:	SWAB	R1		;MAKE READ A WORD COUNT
	.READW	#RAREA,#3,R5,R1,SBLOCK
	BCC	4$		;NO ERROR ON READ
	JMP	EOFCHK		;ERROR CHECK FOR EOF

4$:	JSR	PC,TAPCHK	;CHECK FOR LEOT
	CLRB	DETEOF		;CLEAR EOF COUNT ON SUCCESSFUL READS
	CLRB	CHKFLG		;CLEAR SUPPRESS TAPE MARK FLAG
	MOV	@#54,-(SP)	;ADDR OF SYSPTR ON STACK
	ADD	#42,(SP)	;ADDRESS OF CSW FOR CHANNEL 3 ON STACK
	MOV	@(SP),(SP)	;GET CSW FOR CHANNEL 3 ON STACK
	BIT	#CSWEOF,(SP)+	;EOF BIT ON?
	BEQ	READIG		;NO
	JMP	FILL		;YES-SIMULATE EOF (NEEDED FOR MT AND CT)

READIG:	MOV	R0,WDCTR	;PRESERVE WORDS ACTUALLY READ

.SBTTL	PROCESS 8 WORDS

LINE:	MOV	R5,R0		;PREPARE TO PRINT LINE ADDRESS
	SUB	BUFFER,R0	;COMPUTE OFFSET IN BUFFER
	BIC	#177000,R0	;MAKE IT OFFSET IN BLOCK
	BEQ	HEADER		;IF ZERO, PAGE EJECT AND TITLE
LINE0:	OCT	3		;3 DIGIT ADDRESS
	PUT	SLASH		;DELIMITER
	MOV	#16.,R3		;EIGHT WORDS / LINE
	TST	BYMODE		;BYTE OUTPUT MODE ?
	BEQ	1$		;NO, DO WORD PROCESSING
	TST	WMODE		;YES, HE MUST ASK FOR WORDS
	BEQ	6$		;HE DIDN'T. GO PUT BYTES		;001
									;**-1
; PRINT A LINE OF WORDS

1$:	ASR	R3		;EIGHT WORDS, NOT 16
2$:	PUT	BLANK		;SPACE THE WORD				;001
	MOV	(R5)+,R0	;GET WORD TO OUTPUT			;**-1
	OCT	6		;  AS 6 DIGITS
	TST	BYMODE		;EXTRA SPACING NEEDED ?
	BEQ	3$		;GO IF NO				;001
	PUT	BLANK		;YES					;**-1
3$:	DEC	R3		;ANY MORE HERE?				;001
	BNE	2$		;YES					;001
	MOV	#16.,R3		;COUNT OF 16 BYTES OR CHARS		;**-2
	SUB	R3,R5		;BACK UP FOR SOMETHING
	TST	BYMODE		;BYTES GOING OUT ?
	BNE	5$		;YES. PRINT BYTES
	TST	NMODE		;DOES HE WANT BYTES ?
	BNE	8$		;NO. END THE LINE			;001
	PUT	BLAST		;BLANK ASTERISK				;**-1
4$:	JSR	PC,PUTCH	;PUT A CHARACTER			;001
	BNE	4$		;LOOP UNTIL DONE			;001
	PUT	STARCL		;* CR LF				;**-2
	BR	9$		;NO BYTES. GO CHECK RAD 50		;001
									;001

5$:	PUT	CRLF		;END THE WORD LINE			;**-2
	PUT	BL4		;SPACE OUT THE BYTES
6$:	PUT	BLANK		;SEPARATION				;001
	MOVB	(R5)+,R0	;BYTE TO PRINT				;**-1
	BIC	#177400,R0	;PLEASE
	OCT	3		;ONLY A BYTE
	DEC	R3		;ANY MORE ?
	BNE	6$		;YES					;001
	PUT	CRLF		;NO, END OF LINE			;**-1
	TST	NMODE		;SUPPRESS ASCII ?
	BNE	9$		;YES					;001
	MOV	#16.,R3		;NO, 16 CHARS				;**-1
	SUB	R3,R5		;BACK UP
	PUT	BL2		;PRE SPACE
7$:	PUT	BL3		;SPACER					;001
	JSR	PC,PUTCH	;CHARACTER PUTTER			;**-1
	BNE	7$		;NOT DONE				;001
8$:	ADD	R3,R5		;ADVANCE OR NOT				;001
	PUT	CRLF		;DONE. END LINE				;**-2
9$:	TST	XMODE		;ANY RADIX 50?				;001
	BEQ	11$							;001
	MOV	#8.,R3		;WORD COUNT				;**-2
	SUB	#16.,R5		;DECREMENT BY 16
	TST	BYMODE
	BNE	10$							;001
	PUT	BLANK		;INITIAL SPACE				;**-1
10$:	MOV	#BL4,R1		;PRINT 4 BLANKS				;001
	SUB	BYMODE,R1	; (SOMETIMES 5)				;**-1
	JSR	R3,FORCE1	;  TO OUTPUT FILE
	MOV	(R5)+,R0	;GET A WORD
	JSR	PC,R50UNP
	DEC	R3
	BNE	10$							;001
	PUT	CRLF							;**-1
11$:	SUB	#8.,(PC)+	;DONE 8 WORDS. ANY MORE?		;001
WDCTR:	.WORD	0							;**-1
	BHI	LINE		;YES
	JMP	READ		;NO, READ SOME MORE

.SBTTL	PRINT HEADER

HEADER:	TST	BYMODE		;INSERT <CR><LF> FOR BYTE MODE
	BNE	1$		;DO IT FOR BYTE MODE
	TST	XMODE		;DO THE SAME FOR RAD50 STUFF
	BEQ	2$		;NOT RAD50
1$:	PUT	CRLF		;PUT IN <CR><LF> FOR
	PUT	CRLF		;FOR SPACING ON LISTING
2$:	JSR	R3,@R2		;OUTPUT HEADING
HDRPTR:	.WORD	0
	MOV	SBLOCK,R0	;PRINT BLOCK NUMBER
	INC	SBLOCK		;BUMP FOR LATER
	OCT	5		;PRINT 4 DIGIT FIELD
	PUT	CRLF		;EMIT CR LF
	TST	BYMODE		;IS IT BYTE MODE OUTPUT
	BNE	1$		;YES,DON'T FORM FEED
	TST	XMODE		;IS IT RAD50 OUTPUT MODE
	BNE	1$		;YES DON'T FORM FEED
	CLR	R0		;ZERO WORD NUMBER
	MOV	#HDRMSG,HDRPTR	;FORM FEEDS FROM NOW ON
	BR	2$

1$:	MOV	#BLKNO,HDRPTR	;DON'T DO FORM FEED
2$:	JMP	LINE0		;GET ANOTHER LINE

.SBTTL	OCTAL NUMBER OUTPUT

OCTOUT:	MOV	(R3)+,R1	;GET FIELD SIZE
	CLR	-(SP)		;SET MARKER
1$:	MOV	R0,-(SP)	;GET BYTE
	BIC	#177770,@SP
	BIS	#'0,@SP
	CLC
	ROR	R0
	ASR	R0
	ASR	R0
	DEC	R1
	BNE	1$
2$:	MOV	(SP)+,R0
	BEQ	RTS3
	JSR	PC,EMIT		;PUT DIGIT
	BR	2$

.SBTTL	RAD 50 UNPACK ROUTINE

R50UNP:	MOV	#COEFF,R1
	MOV	R0,-(SP)	;SAVE WORD TO UNPACK
1$:	CLR	R0		;MAKE A PLACE
2$:	CMP	@SP,@R1		;DONE YET?
	BLO	3$		;YES
	SUB	@R1,@SP
	INC	R0
	BR	2$

3$:	TSTB	R0		;FIND RAD50 RANGE
	BEQ	4$
	CMPB	R0,#33		;$ ?
	BEQ	6$
	BGT	5$		;DIGIT
	ADD	#40,R0		;ALPHA
4$:	ADD	#16,R0
5$:	ADD	#11,R0
6$:	ADD	#11,R0
	JSR	PC,EMIT		;PUT CHARACTER
	TST	-(R1)
	BNE	1$
	TST	(SP)+		;PRUNE
	RTS	PC

	.WORD	0,1,40.
COEFF:	.WORD	1600.

.SBTTL	OUTPUT ROUTINES

PUTCH:	MOVB	(R5)+,R0	;GET CHARACTER
	BIC	#177400,R0	;TRIM
	CMP	#177,R0		;DON'T PRINT RUBOUT			;002
	BEQ	2$
	BIT	#200,R0		;EIGHT BIT CHARACTER?			;002
	BEQ	1$		;NO, CONTINUE				;002
	CMP	#377,R0		;DON'T PRINT RUBOUT EQUIVALENT		;002
	BEQ	2$							;002
	CMP	R0,#240		;PRINTABLE EIGHT BIT CHARACTER?		;002
	BGE	3$		;YES, PRINT THE CHARACTER		;002
	BR	2$		;NO, PRINT A .				;002
1$:	CMP	R0,#40		;PRINTABLE SEVEN BIT CHARACTER?
	BGE	3$		;YES
2$:	MOV	#'.,R0		;NO, PUT A .
3$:	JSR	PC,EMIT		;OUTPUT A BYTE
	DEC	R3
	RTS	PC

EMIT:	MOVB	R0,(R4)+	;PUT CHAR IN BUFFER
	INC	(PC)+		;BUMP COUNTER
BUFCTR:	.WORD	0
	BNE	EMITR		;NOT FULL YET
EMIT1:	SUB	#512.,R4	;POINT TO BEGINNING
	.WAIT	#CHAN		;WAIT FOR FORMER TO END
	BCC	1$		;NO ERROR ON PREVIOUS WRITE
	ERROR	MSG2		;ERROR ON PREVIOUS WRITE

1$:	.WRITE	#WAREA,#CHAN,R4,#256.,LBLOCK
	BCC	2$		;NO ERROR ON WRITE
	ERROR	MSG2		;ERROR ON WRITE

2$:	INC	LBLOCK		;INCREMENT BLOCK COUNT
	MOV	#-512.,BUFCTR
	MOV	-(R4),R4	;POINT TO OTHER BUFFER
EMITR:	RTS	PC

FORCE:	MOV	(R3)+,R1	;POINT TO STRING
FORCE1:	MOVB	(R1)+,R0	;PUT CHAR
	BEQ	RTS3		;OUT ON 0
	JSR	PC,EMIT
	BR	FORCE1

RTS3:	RTS	R3

	.SBTTL	NON FILE TYPE LOOKUP REQUEST CHECK
; FILTYPE -- DETERMINES IF THE LOOKUP TO THE MAGTAPE DEVICE WAS A FILE
; OR NON FILE STRUCT REQUEST.IF THE REQUEST WAS FILE STRUCTURED
; THE LOKFLG BYTE IS CLEAR OTHERWISE IT IS SET
; R1--> ADDRESS TO THE FILE NAME RETURNED BY
; CSISPC.IF ZERO LOKFLG IS SET TO ONE.

FILTYP:	.RCTRL
	.CSISPC	#PGMTOP,#DEFEXT,#0,#ORGTOP ;GET THE COMMAND STRING
	BCC	1$			;NO ERRORS
	ERROR	MSG5			;ERROR IN CSI COMMAND

1$:	TST	PGMTOP			;IS THERE A DEVICE
	BNE	2$			;YES THERE WAS
	TST	PGMTOP+36		;IS THERE AN INPUT DEVICE
	BNE	2$			;YES THERE WAS
	MOVB	#-1,NODEV		;SET THE FLAG
2$:	MOV	#PGMTOP+40,R1		;GET FILE NAME
	.REPT	3			;CHECK FOR ZERO FILENAME
	TST	(R1)+			;IS IT ZEROS
	BNE	3$			;NO IT'S NOT,IT'S GOT A FILENAME
	.ENDR				;END FILENAME CHECK
	MOVB	#NFS,LOKFLG		;SET TYPE OF LOOKUP
3$:	MOV	PGMTOP,OUTDEV		;SAVE DEVICE TO BE RELEASED
	MOV	PGMTOP+36,INDEV		;SAVE INPUT DEVICE TO BE RELEASED
	RTS	R3

	.SBTTL	DEVICE TYPE ROUTINE
; DEVTYP -- DETERMINES IF THE INPUT DEVICE IS A SEQUENTIAL ACCESS DEVICE.
; IT CHECKS FOR THE FOLLOWING AND ASSIGN IT THE FOLLOWING CODE.
;	      DEVICE      CODE
;              MT         2
;              MM         3
;	       MS	  4
;              CT	  5
;    R1--> COUNTER FOR THE CONTROL LOOP.
;    R3--> ADDRESS OF DEVICE NUMBER
;    INDEV = INPUT FILE DEVICE NAME

DEVTYP:	MOV	#4,R1			;INDEX REGISTER			;MAS04+
	MOVB	#2,DEVFLG		;GIVE IT DEVICE CODE
	MOV	#MT,R3			;R3-> DEVICE INFORMATION
	.DSTAT	#DEVBLK,#INDEV		;GET INPUT DEVICE STATUS
1$:	CMPB	(R3)+,DEVBLK		;IS THIS IN THE LIST?
	BNE	2$			;NO, TRY NEXT DEVICE
	TST	DEVBLK+4		;IS THE DEVICE IN CORE,SHOULD BE
	BNE	3$			;IT'S IN CORE
2$:	INCB	DEVFLG			;ADD TO DEVICE CODE
	DEC	R1			;END OF DEVICE LIST?
	BNE	1$			;NO, TRY NEXT ONE
	CLRB	DEVFLG			;CLEAR DEVICE FLAG
3$:	RTS	PC							;MAS04-

	.SBTTL	TAPCHK,CHECKS FOR EOF AND HEADER LABELS
; TAPCHK -- SETS THE EOFLAB BYTE IF THE EOF
; LABEL HAS BEEN READ,OTHERWISE IT IS CLEAR
;    R5--> CONTAINS THE ADDRESS TO THE DATA.

TAPCHK:	CMP	#"HD,@R5		;DID WE READ HEADER LABEL
	BNE	1$			;NO WE DID'NT,CHECK FOR EOF
	CMPB	#'R,2(R5)		;IS THIS THE HEADER LABEL
	BEQ	3$			;YES IT IS
1$:	CMP	#"EO,@R5		;CHECK FOR EOF LABEL
	BNE	2$			;THIS IS'NT THE EOF LABEL
	CMPB	#'F,2(R5)		;CHECK FOR END OF LABEL
	BEQ	4$			;GO SET THE FLAG
2$:	CLRB	DETEOF
	RTS	PC

3$:	MOVB	#-1,HEDCHK		;SET HEADER FLAG
	CLRB	EOFLAB			;CLEAR EOF LABEL FLAG
	RTS	PC			;RETURN  TO DRIVER

4$:	MOVB	#-1,EOFLAB		;SET THE EOF FLAG
	CLRB	HEDCHK			;CLEAR LABEL FLAG
	RTS	PC			;RETURN TO DRIVER

	.SBTTL	CHKPOS,POSTIONS THE TAPE ACCORDING TO THE 'S' SWITCH
; CHKPOS SUBROUTINE -- POSITIONS THE TAPE ON A NON FILE STRUCTURE LOOKUP
; TO THE MAGTAPE DEV. THE ROUTINE CHECKS FOR LEOT ON FILE STRUCT.
; TAPES OR END OF FILE ON NON FILE STRUCTURED TAPES.

CHKPOS:	MOV	BUFFER,R5		;GET DATA BUFFER
	BITB	DEVFLG,#2		;IS IT A MAGTAPE DEVICE
	BEQ	7$			;NO IF EQ
	TSTB	LOKFLG			;IS IT A NON FILE STRUCTURE LOOKUP
	BEQ	7$			;NO IF EQ
	TST	SBLOCK			;DID HE SPECIFY STARTING BLOCK
	BEQ	7$			;NO IF EQ
	CLR	R2			;CLEAR COUNT REGISTER
4$:	.READW	#RAREA,#3,R5,#256.   	;ADVANCE TAPE TO DESIRED POSITION
	BCC	5$			;NO ERROR
	TSTB	@#ERRLOC		;IS IT EOF
	BEQ	4$			;IGNORE THE TAPE MARK
	TST	IGNORE			;IGNORE ERROR
	BNE	5$			;YES WE DO
	ERROR	MSG3			;ERROR IN READING

5$:	INC	R2			;ADD TO COUNT REGISTER
	CMP	R2,EBLOCK		;ARE WE AT UPPER LIMIT
	BEQ	6$			;YES WE ARE
	CMP	R2,SBLOCK		;ARE WE AT START
	BNE	4$			;NO,READ SOME MORE
6$:	MOVB	#-1,CHKFLG		;SUPRESS TAPE MARKER OUTPUT
7$:	RTS	PC

	.SBTTL	PRINT,EMITS ERROR AND CODE
; PRINT -- EMITS THE ERROR MESSAGE TO THE USER
; CONSOLE AND THE CORRESPONDING ERROR CODE FOR
; INDIRECT COMMAND FILES IN BYTE 53.
; R5-->ADDRESS OF ARGUMENTS.

PRINT:	.RCTRLO			;OUTPUT ERROR NO MATTER WHAT
	CMP	#MSG10,@R5	;PROTECTION MESSAGE?			;MAS02+
	BNE	44$		;NE -> NO
	MOV	(R5)+,R0
	.PRINT			;PRINT WARNING MESSAGE
	BISB	#WARN,@#MONBYT	;SET WARNING
	RTS	R5		;RETURN TO FINISH CLOSES

44$:	.PRINT	#DUMPF		;PRINT STANDARD 1ST PART		;001
	MOV	(R5)+,R0	;GET THE ERROR MESSAGE			;**-1
	.PRINT
	BISB	#FATAL,@#MONBYT
	.RELEAS	#INDEV		;RELEASE INPUT DEVICE
	.RELEAS	#OUTDEV		;RELEASE OUTPUT DEVICE
	.SETTOP	#ORGTOP
	JMP	DUMP		;GO GET ANOTHER COMMAND			;001
									;**-1
	.SBTTL	MOVNAM,MOVES INPUT STRING TO INITIAL HEADER
; MOVES THE INPUT FILE OR DEVICE TO THE INITIAL HEADER LABEL.
; R1-->INPUT STRING FROM CSISPC.
; R2-->OUTPUT AREA FOR HEADER.

MOVNAM:	MOV	#DEVNAM,R1
	MOV	#ORGTOP,R1	;GET THE INPUT STRING	;BC1
1$:	CMPB	(R1),#NULL	;SEARCH FOR NULL
	BEQ	2$		;JUST INPUT FILE WAS FOUND
	CMPB	(R1)+,#EQUAL	;FIND THE INPUT FILE
	BNE	1$		;GO SEARCH SOME MORE
	BR	3$		;OUTPUT FILE WAS GIVEN

2$:	MOV	#ORGTOP,R1	;GET THE INPUT FILE
3$:	MOV	#DEVNAM,R2	;GET OUTPUT SPACE
4$:	MOVB	(R1)+,(R2)+	;MOVE DATA FROM INPUT BUF TO OUTPUT
	TSTB	(R1)		;IS IT A ZERO BYTE
	BNE	4$		;NO ITS NOT
	MOVB	#CR,(R2)+	;INSERT <CR>
	MOVB	#LF,(R2)+	;INSERT <LF>
	MOV	#BLKNO,R1	;GET THE BLOCK NO.
5$:	MOVB	(R1)+,(R2)+	;INSERT THE STRING
	BNE	5$		;STOP ON NULL
	CLRB	(R2)
	RTS	PC

.PSECT	DATA

.SBTTL	DATA AREA

TOP:	.WORD	0
BUFFER:	.WORD	0
SIZE:	.WORD	0
CLEARS:					;START OF CLEAR AREA
SBLOCK:	.WORD	0
EBLOCK:	.WORD	0
BYMODE:	.WORD	0
XMODE:	.WORD	0
WMODE:	.WORD	0
NMODE:	.WORD	0
IGNORE:	.WORD	0
NORT11:	.WORD	0		;NON RT11 TAPE SWITCH
LBLOCK:	.WORD	0
CLEARE:					;END OF CLEAR AREA

	.NLIST	BEX							;001
									;001
	.WORD	0			;END OF LIST			;**-2
	.BYTE	1,'T			;NON RT11 TAPE SWITCH
	.BYTE	1,'G			;IGNORE INPUT ERRORS
	.BYTE	1,'N			;NO ASCII IF BYTES
	.BYTE	1,'W			;WORDS IF BYTES
	.BYTE	1,'X			;RAD 50
	.BYTE	1,'B			;BYTES
	.BYTE	-1,'E			;END BLOCK #
	.BYTE	-1,'S			;START BLOCK #
SWTBL:
MSG0:	.ASCIZ	/No LP/
MSG1:	.ASCIZ	/Illegal option/
MSG2:	.ASCIZ	/Write error/
MSG3:	.ASCIZ	/Read error/
MSG4:	.ASCIZ	/Insufficient memory/
MSG5:	.ASCIZ	/Illegal command/
MSG6:	.ASCIZ	/File or input device not found/
MSG7:	.ASCIZ	/End of file detected/
MSG10:	.ASCIZ	/?DUMP-W-File created : protected file already exists/	;MAS02
MSG11:	.ASCIZ	/Protected file already exists/				;MAS03
MSG12:	.ASCIZ	/Device full/						;MAS03
DUMPF:	.ASCII	/?DUMP-F-/<200>						;001
	.EVEN								;**-1
DEFEXT:	.WORD	0
	.RAD50	"DMP"
	.WORD	0,0

LP::	.RAD50	/LP /			;MAKE OUTPUT DEVICE GLOBAL FOR PATCHING

MT:	.BYTE	11			;TM11 DEVICE NUMBER		;MAS04+
MM:	.BYTE	20		   	;TJU16	DEVICE NUMBER
MS:	.BYTE	35			;TS10 TS04 DEVICE NUMBER
CT:	.BYTE	13			;CASSETTE DEVICE NUMBER
	.EVEN								;001
									;001

	.WORD	LBUFF2							;**-1
LBUFF1:	.BLKW	256.
	.WORD	LBUFF1
LBUFF2:	.BLKW	256.
LIMIT:	.BLKW	1			;UPPER LIMIT TO DUMP IF LEOT IS NOT WANTED

RAREA:	.BLKW	6
WAREA:	.BLKW	6
LAREA:	.BLKW	4			;EMT AREA FOR LOOKUP
QELM:	.BLKW	10.			;QUEUE ELEMENT			;001
TEMBLO:	.WORD	0			;TEM BLOCK FOR SBLOCK
DEVFLG:	.BYTE	0			;DEVICE TYPE CODE
NODEV:	.BYTE	0
HDRMSG:	.BYTE	14
BLKNO:	.ASCIZ	"BLOCK NUMBER  "
DEVNAM:	.BLKB	60.							;BC1
STARCL:	.BYTE	'*
CRLF:	.BYTE	015,012,0
SLASH:	.ASCIZ	"/"
BLAST:	.ASCIZ	" *"
BL5:	.ASCII	" "
BL4:	.ASCII	" "
BL3:	.ASCII	" "
BL2:	.ASCII	" "
BLANK:	.ASCIZ	" "
OUTTM:	.BYTE	012,015
	.ASCIZ	/**** TAPE MARK ****/
VNUM:	.ASCIZ	/DUMP V04.00A/						;001
HEDCHK:	.BYTE	0		;FLAG FOR DETECTING HEADER LABEL	;**-1
EOFLAB:	.BYTE	0		;FLAG FOR CHECKING EOF LABEL
DETEOF:	.BYTE	0		;NUMBER OF TAPE MARKS DETECTED IN SUCCESSION
CHKFLG:	.BYTE	1		;SUPPRESS TAPE MARK FLAG
LOKFLG:	.BYTE	0		;TYPE OF LOOKUP FLAG,0-FS,1-NFS
	.EVEN
INDEV:	.BLKW	1		;SAVE INPUT HANDLER
OUTDEV:	.BLKW	1		;SAVE OUTPUT HANDLER
DEVBLK:	.BLKW	4

.PSECT	FREE

; PATCHING INSTRUCTIONS FOR DUMP.
; TO PATCH DUMP INSERT THE NEW HIGH
; PROGRAM ADDRESS IN FREEM.THE AREA
; BETWEEN THE NEW HIGH PROGRAM ADDRESS
; AND 'FREE' IS THE PROGRAM PATCH SPACE

FREEM::FREE				;PATCH SPACE
FREE:					;PATCH SPACE IF THERE ARE SOME
ORGTOP	=	FREEM			;HEADER SPACE
PGMTOP	=	ORGTOP+70.		;HANDLER SPACE

	.END	DUMP							;001
