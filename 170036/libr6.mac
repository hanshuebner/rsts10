.MCALL	.MODULE
.MODULE	LIBR,VERSION=09,COMMENT=<CREATE FORM LIBRARY> IDENT=NO,MODNAME=LIBR6,GLOBAL=.LIBR6

;                       COPYRIGHT (c) 1989 BY
;           DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;                        ALL RIGHTS RESERVED
;
;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
;ONLY  IN  ACCORDANCE  WITH  THE TERMS  OF  SUCH  LICENSE AND WITH THE
;INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY OTHER
;COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS HEREBY
;TRANSFERRED.
;
;THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT NOTICE
;AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT
;CORPORATION.
;
;DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF ITS
;SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.

.SBTTL	FORM LIBRARY CREATION
.ENABL	GBL

; MAS,JVK

.IIF NDF EIS$	EIS$=0	;SAY EIS NOT AVAILABLE

; EDIT HISTORY:

; FIX INPUT BUFFER POINTER PROBLEM					;MAS01
; ADD .ENTER AND .CLOSE PROTECTION VIOLATION MESSAGES			;MAS07
; FIX BUG WITH FORM DIRECTORIES						;JVK01

; THIS OVERLAY WILL GO AWAY IF THE FORM LIBRARY
; FUNCTION IS REMOVED FROM THE RT-11 LIBRARIAN

.SBTTL	-	 MACRO DEFINITIONS

.MCALL	.DATE,.GTIM,.SETTOP,.CLOSE,.WRITW

;+
; SUBROUTINE CALL AND RETURN TO MAIN PROGRAM, EQUIVILENT TO:
;	CALL	SUBR
;	RETURN
;-

.MACRO	CALLR	SUBR
	JMP	SUBR
.ENDM

.MACRO	ERROR$	ERNB,SEV,ETYP,REG
	.IF NB REG
	.IIF DIF <REG>,<R0>	MOV REG,R0
	.IFF
	.IIF IDN <ETYP>,<E$FIL>	CLR	R0
	.ENDC
	JSR	R5,ERROOT
	.BYTE	ERNB,	SEV*200!ETYP
.ENDM

.IF Z EIS$
.MACRO	SOB	A,B
	DEC	A
	BNE	B
.ENDM
.ENDC

.PSECT		;RESET TO BLANK SECTION

.SBTTL	-	 LIBRARY HEADER FORMAT & OFFSETS

; MACRO TO DEFINE HEADER OFFSETS, VALUE SYMBOLS, & VALUES

.MACRO	LBRHDR	ONAME,ENAME,EVAL
.IIF	NB	<ONAME>	ONAME=TMP	;DEFINES THE OFFSET
.IIF	NB	<ENAME>	ENAME=EVAL	;SYMBOL FOR ENTRY VALUE
		.WORD	EVAL
TMP=	TMP+2
.ENDM	LBRHDR

TMP=	0		;OFFSETS START AT ZERO

LCODE=	^RFLB		;LIBRARY CODE

	.WORD	12	;ERROR HANDLING INDEX WORD(IN A DATA SECTION)
			;MUST BE 1ST PHYSICAL LOCATION OF EACH OVERLAY

.PSECT	DPUR6,D

;	OFFSET	VAL SYM		VALUE
;	------	-------		-----

HDRTBL:
LBRHDR	L$HC,	L.BR,		LCODE	;LIBRARIAN CODE
LBRHDR	L$HVER,	L.HVER,		500	;VERSION NUMBER (V05.00)
LBRHDR	L$HDAT,	,		0	;DATE IN RT-11 DATE FORMAT
LBRHDR	L$HTIM,	,		0	;2 WORD TIME
LBRHDR	,	,		0	;
LBRHDR	,	,		0	;NOT USED
LBRHDR	,	,		0	;NOT USED
LBRHDR	L$HRSA,	,		10	;EPT RELATIVE START ADR
LBRHDR	L$HEAB,	,		0	;EPT ENTRIES ALLOCATED IN BYTES
LBRHDR	,	,		0	;NOT USED
LBRHDR	L$HNIB,	,		0	;NEXT INSERT RELATIVE BLOCK NUMBER
LBRHDR	L$HNBB,	,		0	;NEXT BYTE WITHIN BLOCK

L$HEPT=	TMP				;1ST ENTRY IN ENTRY POINT TABLE

GTIM:	.WORD	21*400		;.GTIM CODE WORD
	.WORD	HDRTBL+L$HTIM	;ADR TO STORE 2 WD TIME VALUE

.PSECT

.SBTTL	FRMLBR:: CREATE A FORM LIBRARY

; CREATE THE LIBRARY HEADER FOR THE OUTPUT FILE

FRMLBR::CLRB	PASS		;ZERO PASS COUNTER
	MOV	EPTST,EPTPTR	;INIT EPT PTR AT BEGINING
	MOV	#GTIM,R0	;R0-> .GTIM REQUEST AREA
	.GTIM
	.DATE			;GET TODAY'S DATE
	MOV	#HDRTBL,R3	;R3-> START OF LIBR HEADER TABLE
	MOV	R0,L$HDAT(R3)	;PUT DATE IN HEADER TABLE
	MOV	#L$HEPT/2,R2	;# OF WORDS IN HEADER
10$:	MOV	(R3)+,R0	;CURRENT HEADER WORD TO OUTPUT
	CALL	PUTEPT		;MOVE WORD TO OUTPUT BUFFER
	SOB	R2,10$		;OUTPUT ENTIRE HEADER
	CLR	MODCNT		;CLEAR FILE COUNTER
	INCB	PASS		;INDICATE PASS1
	CALL	INIO		;PREPARE FOR INPUT

.SBTTL FPASS1   START OF PASS 1

FPASS1:	CALL	NEWFRM		;GET NEXT FORM FOR INPUT
	BCC	10$		;C=0 THIS IS NOT START OF A LIBRARY FILE
	CALL	LMERGE		;SKIP OVER EPT AND HEADER IN LIBRARY FILE
10$:	CALL	FRMNAM		;GO PROCESS A FORM
	BR	FPASS1		;GET NEXT FORM

;+
; NORMAL REGISTER USAGE DURING THIS OVERLAY
; R0,R1, AND R5 USEABLE AS INDICATED ON A LOCAL BASIS
; R3-DESTROYED (->FOUND SYMBOL IN EPT AFTER A SEARCH)
; R4 CURRENT INPUT FILE BUFFER POSITION
;
; MODCNT:: IS USED AS A CURRENT FILE COUNTER
;
; EACH INPUT FILE IS SCANNED. THE FORM NAMES ARE PLACED
; IN THE EPT, ALONG WITH THEIR REL. ADDRESS. (REL BLK #
; AND REL.BYTE WITH IN  THE BLK).
; HOWEVER, IF THE FORM IS TO BE UPDATED OR DELETED, THE
; ASSOCIATED ACTION IS PERFORMED
;-

.SBTTL	NEWFRM	 GET NEXT FORM FOR INPUT & CHECK FOR LIBR FILE

;+
; IF INPUT FILE IS A FORM LIBRARY ALREADY, THEN SKIP
; OVER THE HEADER AND EPTS.
; MODCNT:: USED AS CURRENT FILE COUNTER
;-

NEWFRM:	CALL	GETWD		;GET NEXT NON ZERO WORD
	CMP	FILCNT,MODCNT	;HAVE WE CHANGED FILES YET?
	BEQ	30$		;NO
	MOV	FILCNT,MODCNT	;UPDATE CURRENT FILE COUNT
	CLRB	SWIT6		;CLEAR LIBRARY SWITCH
	CMP	#^RFRM,@R4	;CHECK FIRST RAD 50 WORD
	BNE	10$		;NOT A FORM FILE
	CMP	#^RLBR,2(R4)	;CHECK 2ND WD FOR FORM FILE
	BEQ	20$		;IT IS A FORM FILE
10$:	CMP	#L.BR,@R4	;IS IT A FORM LIBRARY FILE?
	BNE	50$		;NO
	SEC			;C=1 IF IT IS A FORM LIBRARY FILE
	BR	40$		;RETURN TO SKIP HEADER AND EPT

20$:	ADD	#4,R4		;SKIP ID BEFORE PROCESSING FORM FILE
30$:	CLC			;C=0 IF INPUT  IS NOT START OF LIBRARY
40$:	RETURN			;CONTINUE PROCESSING

50$:	ERROR$	ERR30,E$F,E$FIL	;ILLEGAL INPUT FILE TYPE

.SBTTL	LMERGE   INPUT FILE IS A LIBRARY

;+
; THE INPUT FILE IS A LIBRARY SO WE ARE MERGING IT WITH THE OTHER INPUT
; FILES. THE EPT OF THIS INPUT FILE WILL BE SKIPPED OVER AND THE FORMS
; OF THE INPUT LIBR FILE PROCESSED JUST LIKE OTHER INPUT FORMS.
;-

LMERGE:	DECB	SWIT6		;IND PROCESSING LIBR FILE
	MOV	L$HEAB(R4),R0	;GET EPT ENTRIES ALLOC.
	BIC	#777,R0		;DETERMINE STARTING BLK # OF FORMS
	SWAB	R0		; C =0
	ROR	R0
; ??? DO WE NEED TO CHECK FOR EXACT EPT BLK FIT	???
	INC	R0		;FORM START ON BLK BOUNDARY
	MOV	R0,CURBLK	;UPDATE CURRENT INPUT REL BLK #
	CALLR	NEWBUF		;READ FORMS IN LIBR(NEWBUF WILL RETURN)
				;R4 & R5 ARE RESET BY NEWBUF

.SBTTL	FRMNAM   BUILD EPT FOR FORM NAME

;+
; CHECK DELETE LIST 1ST, THEN CHECK FOR /U
; OTHERWISE JUST INSERT FORM NAME
;-

FRMNAM:	CALL	GETNAM		;GET FORM NAME				;MAS01
	MOV	#NAME,R1	;R1->SYMBOL TO SEARCH FOR		;MAS01
	MOV	DMNLA,R0	;R0 -> FORM NAME DELETE LIST
	BEQ	10$		;NOTHING TO DELETE
	CALL	DELENT		;CALL DELETE FUNCTION
	BCC	10$		;C=0 IF FORM NOT ON DELETE LIST
	JMP	SKPMOD		;C=1 SKIP THIS FORM

; CHECK SWITCH OPTIONS

10$:	MOV	#SWITCH,R2	;R2 -> SWITCH WORD TO CHECK OPTIONS
	MOV	UPDPTR,R0	;R0 -> UPDATE LIST ADR
	BEQ	70$		;NO /U IF 0
20$:	TST	(R0)+		;END OF UPDATE LIST ?
	BEQ	70$		;END-OF-LIST IF 0
	CMPB	FILCNT,-1(R0)	;CORRECT FILE TO UPDATE  ?
	BNE	20$		;NO
	TSTB	SWIT6		;LIBRARY FILE?
	BPL	30$		;NO
	ERROR$	ERR32,E$F,E$FIL	; /U GIVEN ON LIBRARY FILE <FILENAME>

30$:	CALL	EPTSER		;SEARCH EPT TABLE
	MOV	R3,R0		;SAVE FOUND FORM ENTRY ADR
	BCC	40$		;FOUND IF C=0 SO REPLACE IT
	BR	MOVMOD		;INSERT IF NOT FOUND

;+
; A FORM NAME HAS BEEN FOUND TO REPLACE, REMOVE IT FROM ITS CURRENT
; POSITION IN EPT(SHIFTING REMAINDER DOWN) THEN PUT NEW ONE AT THE END OF THE LIST
;-

40$:	ADD	#8.,R3		;INDEX TO NEXT ENTRY
	CMP	EPTPTR,R3	;END OF EPT ?
	BLOS	60$		;YES
50$:	MOV	(R3)+,(R0)+	; THEN OVERLAY REPLACED ENTRY
	MOV	(R3)+,(R0)+
	MOV	(R3)+,(R0)+
	MOV	(R3)+,(R0)+
	CMP	EPTPTR,R3	;END OF EPT ?
	BHI	50$		;NO, LOOP UNTIL REACH END
60$:	CLR	@R0		;MARK END OF EPT
	MOV	R0,EPTPTR	;IND NEW END ADR
	DECB	SWIT7		;IND REPLACE
	BR	MOVMOD		;PUT FORM NAME IN EPT

; /U WAS NOT GIVEN, OR NOT AT PROPER TIME

70$:	CALL	EPTSER		;DOES NAME ALREADY EXIST IN TABLE ?
	BCS	MOVMOD		;NO IF C=1
	ERROR$	ERR31,E$W,E$SYM,R3 ;DUPLICATE FORM NAME OF <NAME>
	JMP	SKPMOD		;WARNING-SKIP OVER DUPLICATE FORM NAMES

.SBTTL	MOVMOD   PLACE FORM NAME IN EPT

MOVMOD:	MOV	(R1)+,R0
	CALL	PUTEPT		;PLACE 2WD SYMBOL NAME IN
	MOV	(R1)+,R0	;THE LIBRARY EPT
	CALL	PUTEPT
	CLR	R0		;R0->0 SINCE THE
	CALL	PUTEPT		;BLK # OF FORM IS SET LATER
	TSTB	SWIT7		;REPLACE FORM ?
	BEQ	10$		;NO IF 0
	COM	R0		;IND FORM REPLACE, NOW NON-ZERO
	CLRB	SWIT7		;TURN OFF REPLACE SWITCH
10$:	CALL	PUTEPT		;LAST WD OF ENTRY IN EPT
	JMP	SKPMOD		;SKIP OVER FORM DESCRIPTOR
				;SKPMOD WILL RETURN

.SBTTL	PUTEPT   PUT VALUE IN R0 INTO RESIDENT ENTRY POINT TABLE

PUTEPT:	MOV	R0,@EPTPTR	;INSERT VALUE AT CURRENT PTR
	ADD	#2,EPTPTR	;BUMP PTR TO NEXT WORD
	CMP	EPTPTR,@#HIGH	;REACH HIGH LIMIT OF AVAILABLE MEMORY?
	BLO	10$		;NO
	ERROR$	ERR3,E$F,E$PRT	;INSUFFICIENT MEMORY FOR EPT


10$:	CLR	@EPTPTR		;TERMINATE EPT WITH 0
	RETURN

.SBTTL	 EPTSER	 ENTRY POINT SEARCH TABLE

;+
; SEARCH THE ENTRY POINT TABLE FOR A MATCH OF THE INDICATED SYMBOL.
; INPUT:
;	R1-> SYMBOL TO BE SEARCHED FOR
;
; OUTPUT:
;	R3-> THE FOUND SYMBOL IN THE ENTRY POINT TABLE
;	C=0 SYMBOL FOUND
;	C=1 SYMBOL NOT FOUND
;-

EPTSER:	MOV	EPTST,R3	;R3->START OF LIBRARY HEADER
	ADD	#L$HEPT-8.,R3	;G0 BEYOND HEADER TO 1ST ENTRY
EPTSR1:	ADD	#8.,R3		;4 WORDS FOR EACH ENTRY POINT
	TST	@R3		;1ST WORD OF SYMBOL
	BEQ	10$		;IF 0 THEN AT END OF TABLE
	CMP	@R1,@R3		;1ST WD MATCH?
	BNE	EPTSR1		;NO, TRY NEXT ENTRY
	CMP	2(R1),2(R3)	;YES, 2ND WD MATCH?
	BNE	EPTSR1		;NO, TRY NEXT ENTRY
	BR	20$		;YES- C=0 FROM CMP,R3-> FOUND SYMBOL

10$:	SEC			;C=1 SYMBOL NOT FOUND
20$:	RETURN

.SBTTL	FPASS2:: END OF PASS1 (CLEANUP & START PASS 2)

FPASS2::CMPB 	#2,PASS		;START OR END OF PASS 2
	BNE	10$		;START
	JMP	FRMEXT		;END

10$:	CLR	MODCNT		;RESET FILE COUNT FOR 2ND PASS
	MOV	DMNLA,R1	;FORM NAMES TO DELETE ?
	BEQ	20$		;THERE WERE NONE
	JSR	R5,CHKDL1	;CHECK DELETE LIST
20$:	MOV	EPTST,R5	;R5-> START OF EPT
	MOV	EPTPTR,R0	;CHECK EPT SPACE
	ADD	#2,R0		;COUNT RIGHT MAS!			;JVK01
	SUB	R5,R0		;IF ALLOCATION IS ONLY THE HEADER, THEN
	CMP	#L$HEPT,R0
	BHIS	60$		;A NULL LIBRARY WAS MADE
	MOV	R0,L$HEAB(R5)	;AND IND IN EPT
	ADD	#511.,R0	;ROUND UP TO NEXT BLOCK BOUNDARY
	BIC	#777,R0
	ROR	R0		;KEEP CARRY IF ADD OVERFLOWED
	SWAB	R0		;BLK # IN RIGHT POSITION
	DEC	R0		;LESS 1 FOR BUMP BEFORE WRITE
	MOV	R0,OBLK		;OUTPUT (BLK # -1) OF FORM DESCRIPTORS
	INCB	PASS		;INDICATE PASS 2
	CALL	INIO		;INIT FOR READING INPUT FILES
30$:	CALL	NEWFRM		;GET NEXT INPUT FORM
	BCC	50$		;C=0 IF NOT START OF A LIBRARY FILE
40$:	CALL	LMERGE		;SKIP OVER HEADER AND EPT IN LIBRARY
50$:	CALL	FORM		;GO PROCESS FORM
	BR	30$		;GET NEXT FORM

60$:	ERROR$	ERR14,E$F,E$PRT	;NULL LIBRARY

.SBTTL	FORM	 INSERT FORM AND SET BLOCK AND BYTE OFFSETS IN EPT

FORM:	MOV	OBUF,-(SP)	;SAVE FILE POINTERS AS THEY ARE		;MAS01+
	MOV	OBPTR,-(SP)	;BEFORE GETTING THE FORM
	MOV	OBLK,-(SP)	;NAME, AS IT WILL CHANGE THEN
	CALL	GETNAM		;GET FORM NAME
	MOV	#NAME,R1	;R1-> SYMBOL TO SEARCH FOR		;MAS01-
	MOV	DMNLA,R0	;ANY FORMS TO DELETE ?
	BEQ	10$		;NO
	CALL	DELENT		;YES, CHECK FOR MATCH
	BCC	10$		;C=0 INSERT THIS FORM			;MAS01+
	ADD	#6,SP		;RESET SP FOR 3 WDS. PUSHED ON
	BR	SKPMOD		;AND SKIP THIS FORM

10$:	MOV	(SP)+,COBDEF	;CURRENT OUTPUT REL BLK #
	INC	COBDEF		;OBLK IS 1 LESS THAN BLK CURRENTLY FILLING
	MOV	(SP)+,R0	;CURRENT OUTPUT BUFR PTR
	SUB	(SP)+,R0		; & CALC BYTE DISPLACEMENT	;MAS01-
	MOV	R0,BYTDIS	;SAVE IT

; FORM NAMES MAY BE DUPLICATED IN EPT

	CALL	EPTSER		;FIND NAME IN EPT?
20$:	BCS	30$		;NOT FOUND SO DELETE IT
	TST	E$PBYT(R3)	;REPLACE THIS SYMBOL ?
	BPL	40$		;NO IF +
	CLR	E$PBYT(R3)	;TURN OFF REPLACE SWITCH
30$:	BR	SKPMOD		;SKIP IT

40$:	TST	E$PBLK(R3)	;HAS BLK ADR BEEN SET YET?
	BEQ	50$		;NO SET IT NOW
	CALL	EPTSR1		;YES-LOOK FOR NXT OCCURANCE
	BR	20$		;OF FORM NAME IN EPT

50$:	BIS	COBDEF,E$PBLK(R3) ;GET BLK DISP TO FORM
	MOV	BYTDIS,E$PBYT(R3) ;IND BYTE OFFSET
	MOV	#NAME,R2	;GET FORM NAME AND PUT IN OUTPUT	;MAS01+
	MOV	#4,R3		;SET COUNT FOR 4 BYTES
60$:	MOVB	(R2)+,R1	;FILE
	CALL	PUTBYT
	DEC	R3
	BNE	60$		;DO 4 BYTES OF FORM NAME
	MOV	#NAME,R3		;SET UP FOR BYTE COUNT
	CALL	BYTE		;GET BYTE COUNT
	MOVB	R0,(R3)+	;ASSEMBLE IN TEMP LOC
	MOV	R0,R1
	CALL	PUTBYT
	CALL	BYTE
	MOVB	R0,(R3)+
	MOV	R0,R1
	CALL	PUTBYT
	MOV	NAME,R3		;GET BYTES COUNT
	SUB	#6.,R3		;SUBT 3 WDS ALREADY GOT			;MAS01-
70$:	CALL	BYTE		;GET INPUT BYTE IN R0
	MOV	R0,R1
	CALL	PUTBYT		;GO TRANSFER BYTE TO OUTPUT FILE
	DEC	R3		;SUB FROM NUMBER OF BYTES TO MOVE
	BNE	70$		;CONTINUE TILL ALL BYTES ARE TRANSFERED
	RETURN

.SBTTL	GETNAM	GET FORM NAME IN TEMP LOC

GETNAM:	MOV	#NAME,R1	;SET UP TEMP LOC			;MAS01+
10$:	CALL	BYTE		;GET A BYTE
	MOVB	R0,(R1)+	;STORE IT
	CALL	BYTE		;REST OF WORD
	MOVB	R0,(R1)+
	CMP	#NAME+2,R1	;ON 1ST OR 2ND WORD?
	BEQ	10$		;=-> DONE 1ST
	RETURN			;NOT =-> DONE 2ND AND RETURN		;MAS01-

.SBTTL	SKPMOD   DELETE FORM FROM LIBRARY BUILD

SKPMOD:	CALL	GETNAM		;GET BYTE COUNT				;MAS01+
	MOV	NAME,R1		;SUBTRACT OUT 4 WORDS ALREADY GOT
	SUB	#8.,R1		;AND SKIP OVER THE REST OF THE		;MAS01-
10$:	CALL	BYTE		;GET NEXT FORM IN LIBRARY
	DEC	R1		;LOOP FOR NUMBER OF BYTES
	BNE	10$		;IN R1
	RETURN

.SBTTL	FRMEXT   END OF PASS 2 (EXIT)

;+
; SAVE CURRENT OUTPUT BLOCK NUMBER AND BUFFER POINTER
; WRITE HEADER TO OUTPUT FILE
;-

FRMEXT:	MOV	OBPTR,-(SP)	;SAVE CURRENT POINTER TO CALC NEXT INSERT BLK
	MOV	OBLK,-(SP)	;SAME FOR OUTPUT REL BLOCK NUMBER
	CLR	R1		;FILL THE REMAINDER OF BLOCK WITH 0
	MOV	#511.,R3	;TO FORCE OUT REST OF BUFFER
10$:	CALL	PUTBYT
	SOB	R3,10$
20$:	MOV	EPTST,R1	;R1->START OF RESIDENT EPT
	INC	@SP		;REL BLOCK # IS 1 LESS THAN CURENTLY FILLING
	MOV	(SP)+,L$HNIB(R1) ;NEXT INSERT REL BLOCK NUMBER IN HEADER
	SUB	OBUF,@SP	;START OF OUTPUT BUFR FROM POINTER TO
	MOV	(SP)+,L$HNBB(R1) ;GET NXT INSERT BYTE WITHIN BLOCK
	MOV	L$HEAB(R1),R2	 ;SIZE EPT IN BYTES
	ROR	R2		;C=0 FROM SUB, NOW WORD COUNT
	.WRITW	#TEMP,#0,R1,R2,#0 ;WRITE LIBR HEADER AND EPT TO OUTPUT FILE
	BCS	40$		;OUTPUT WRITE ERROR
	.SETTOP	FILPT1		;JUST ABOVE HANDLERS FOR LESS SWAPPING
	.CLOSE	#0		;CLOSE OUTPUT FILE
	BCC	30$		;C=0 -> NO ERROR ON CLOSE		;MAS07+
	CMPB	#PROTCT,@#ERRBYT ;PROTECTION ERROR?
	BNE	30$		;NE -> NO
	MOV	#ODBLK,R0	;POINT AT FILE NAME
	ERROR$	ERR33,E$W,E$FIL,R0 ;PROTECTION VIOLATION
30$:	JMP	REENTR							;MAS07-

40$:	ERROR$	ERR23,E$F,E$PRT	;OUTPUT WRITE ERROR

.SBTTL	 GETWD    GET NEXT WORD OF INPUT FILE (R1= WORD)

;+
; OUTPUT:
;	R1->NEXT NON ZERO WORD IN INPUT BUFFER (BYTE SWAPPED)
;	R4->POINTS TO NEXT NON ZERO WORD IN INPUT BUFFER
; CLOBBERS	R0 AND R1
;-

GETWD:	CLR	R0		;PREPARE TO GET BYTE IN R0
	CALL	BYTE		;GET NEXT INPUT BYTE FROM BUFFER
	MOVB	R0,R1		;R1->INPUT WORD ASSEMBLED HERE
	SWAB	R1		;MAKE IT HIGH BYTE
	CALL	BYTE		;GET NEXT BYTE FROM BUFFER
	MOVB	R0,R1		;PUT TOGETHER WORD
	BEQ	GETWD		;IF R1=0 THEN GET NEXT WORD OF BUFFER
	TST	-(R4)		;R4->POINTS TO NEXT NON ZERO WORD
	RETURN			;IN INPUT BUFFER

.SBTTL	CHKDL1   CHECK DELETE LIST FOR THINGS NOT DELETED

;+
; CHECK THE DELETE LIST AND INDICATE AN ILLEGAL DELETE
; IF AN ENTRY POINT NAME HAS NOT BEEN DELETED
;-

.ENABL	LSB

10$:	CLR	(R1)+		;ZERO FLAG FOR THIS PASS CHECKING
CHKDL1:	TST	(R1)+		;END OF LIST ?
	BEQ	20$		;YES
	TST	(R1)+		;R1 -> FLAG WORD
	TST	@R1		;SYMBOL DELETED ?
	BMI	10$		;YES, CHECK NEXT SYMBOL
	MOV	R1,R0		;NO, COPY PTR
	CMP	-(R0),-(R0)	;R0 -> SYMBOL TO PRINT
	ERROR$	ERR16,E$W,E$SYM	;ILLEGAL DELETE OF <SYMBOL>
	BR	10$		;DO ENTIRE LIST

.SBTTL	OV6DUM:: DUMMY ENTRY POINT TO MAKE IT RESIDENT

20$:
OV6DUM::RTS	R5

.DSABL	LSB

.PSECT	PATCH			;THIS IS A PATCH PSECT TO BE
				;USED FOR BUG FIXES
	.BLKW	64.

.END
