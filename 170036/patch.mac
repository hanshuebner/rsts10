	.TITLE PATCH V02.01 21-NOV-76
	.IDENT	/V02.01  /
	.SBTTL	PATCH.MAC - SAVE FILE PATCH UTILITY FOR RT-11 V03-01 AUGUST 1976.	
	.SBTTL	1.)	COPYRIGHT DISCLAIMER.
;
; RT-11 PATCH PROGRAM
;
; DEC-11-ORTSB-A
;
;
; COPYRIGHT (C) 1976
;
;
;
; DIGITAL EQUIPMENT CORPORATION
; MAYNARD, MASSACHUSETTS 01754
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ONLY
; ON A SINGLE COMPUTER SYSTEM AND MAY BE COPIED ONLY WITH
; THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE,
; OR ANY OTHER COPIES THEREOF, MAY NOT BE PROVIDED OR
; OTHERWISE MADE AVAILABLE TO ANY OTHER PERSON EXCEPT
; FOR USE ON SUCH SYSTEM AND TO ONE WHO AGREES TO THESE
; LICENSE TERMS. TITLE TO AND OWNERSHIP OF THE 
; SOFTWARE SHALL AT ALL TIMES REMAIN IN DIGITAL EQUIPMENT
; CORPORATION.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO
; CHANGE WITHOUT NOTICE AND SHOULD NOT BE CONSTRUED
; AS A COMMITMENT BY DIGITAL EQUIPMENT CORPORATION.
;
; DIGITAL EQUIPMENT CORPORATION ASSUMES NO RESPONSIBILITY
; FOR THE USE OR RELIABILITY OF ITS SOFTWARE ON EQUIPMENT
; WHICH IS NOT SUPPLIED BY DIGITAL EQUIPMENT CORPORATION.
;

			.SBTTL	EDIT LOG
;	1.)	ORIGINAL VERSION:	PATCH V01-01
;		A. S.
;		AUGUST 25, 1974
;
;
;
;	2.)	FIRST EDIT:	PATCH VO1-02
;		R. R. B.
;		AUGUST 15, 1975
;
;		CHANGES MARKED WITH
;		"[RRB 15-AUG-75]"
;		IN THE COMMENT FIELD.
;
;
;
;	3.)	SECOND EDIT:	PATCH V02-01
;		R. D. S.
;		NOVEMBER 30,	1976
;
;
;			ALL CODE CHANGES ARE MARKED WITH
;			" #RS# " IN THE COMMENT FIELD.
;
;			ALL NEW COMMENTS ARE MARKED WITH
;			" ### " IN THE COMMENT FIELD.

			.SBTTL	MACRO DEFINTIONS AND INVOCATIONS, ETC.
	.MCALL	..V2..
	.MCALL	.READW, .WRITW, .SRESET, .CSIGEN, .RCTRLO
	.MCALL	.TTYIN, .TTYOUT, .SETTOP, .EXIT, .CLOSE,.REGDEF
	.MCALL	.PRINT,.GVAL
..V2..
.REGDEF
			.NLIST
			.NLIST	COM
			.NLIST	MD

; THE FOLLOWING MACRO GENERATES SYMBOLIC BIT
; FLAGS FOR EACH SPECIFIED ARGUMENT.
;
;
;
.MACRO	GENFLG	A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13,A14,A15,A16
			.NLIST
			FLGCTR	=	1
	.IRP	XXX,<A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13,A14,A15,A16>
.IF	NB	XXX
		.IRP	QQQ,<\FLGCTR>
			.LIST
			.LIST
FLAG.'XXX	=	'QQQ		; #M# SYMBOLIC DEFINITION OF THE "'XXX" SWITCH OR FLAG.
			.NLIST
			.NLIST
		.ENDM
			FLGCTR	=	FLGCTR*2
.IFF
	.MEXIT
.ENDC

	.ENDM
			.LIST
.ENDM	GENFLG
;
;
;

; THE FOLLOWING MACRO GENERATES THE SWITCH PARSING
; CODE USED BY PATCH.
;	THE FIRST  ARGUMENT IS NUMERIC VALUE OF THE
;		LAST "IN-LINE" LOCAL LABEL.
;	THE SECOND ARGUMENT IS THE WORD USED TO CONTAIN
;		ALL THE FLAGS.
;	THE REMAINING ARGUMENTS ARE THE SWITCHES TO BE
;		CHECKED.
;
;
;
;
.MACRO	SWTTST	START,SWTWRD,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13,A14,A15,A16
			.NLIST
	.NARG	KKK
			.RADIX	10.
			.IRP	COMMON,<\<KKK+'START-1>>
			L	=	'START'+1
			LOOP	=	'START
	.IRP	SSS,<A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13,A14,A15,A16>
.IF	NB	SSS
		.IRP	LLL,<\L>
			.LIST
			.LIST
	CMPB	R0,	#''SSS	; #M# IS IT THE "'SSS" SWITCH?
	BNE	'LLL'$		; #M# NO - GO CHECK NEXT SWITCH.
	BIS	#FLAG.'SSS, 'SWTWRD	; #M# YES - SET THE PROPER FLAG BIT,...
	BR	'COMMON'$		; #M# ...THEN GO TO THE "VALUE CHECK" ROUTINE.
LLL'$:
			.NLIST
			.NLIST
		.ENDM
			L=L+1
.ENDC
	.ENDM
		.IRP	LLL,<\L+1>
		.IRP	MMM,<\LOOP>
			.LIST
			.LIST
OPTERR	=	.
	JSR	R1,	PRINT	; #M# PRINT THE...
	.WORD	SWTERR		; #M# ..."SWITCH ERROR" MESSAGE,...
	BR	ASKFIL		; #M# ...AND REQUEST A NEW FILE SPECIFICATION.
COMMON'$:	TST	R0		; #M# VALUE SPECIFIED ?
	BPL	'LLL'$		; #M# NO - UPDATE COUNT FOR NEXT SWITCH.
	TST	(SP)+		; #M# YES - THROW AWAY VALUES.
LLL'$:	DEC	R3		; #M# REDUCE THE COUNT BY ONE.
	BNE	'MMM'$		; #M# NO - GET NEXT SWITCH, AND REPEAT.
			.NLIST
			.NLIST
			.RADIX	8.
		.ENDM
		.ENDM
			.ENDM

			.LIST
.ENDM	SWTTST
;
;
;

;
;
; THE FOLLOWING MACRO IS A SIMPLIFIED VARIATION
; OF THE RT-11 ".WAIT" REQUEST.
;
;
;
.MACRO	$WAIT
	EMT	^O<374>		; #M# WAIT ON THE CHANNEL IN R0.
.ENDM
;
;
;
;
;
			.LIST	MD
			.LIST	COM
			.LIST

			.SBTTL	PROGRAM SYMBOLIC DEFINITIONS.
BIT0	=	1
BIT1	=	BIT0*2
BIT2	=	BIT1*2
BIT3	=	BIT2*2
BIT4	=	BIT3*2
BIT5	=	BIT4*2
BIT6	=	BIT5*2
BIT7	=	BIT6*2
BIT8	=	BIT7*2
BIT9	=	BIT8*2
BIT10	=	BIT9*2
BIT11	=	BIT10*2
BIT12	=	BIT11*2
BIT13	=	BIT12*2
BIT14	=	BIT13*2
BIT15	=	BIT14*2
HT	=	11		; ### SYMBOLIC FOR THE <HT> CHARACTER.
CR	=	15		; ### SYMBOLIC FOR THE <CR> CHARACTER.
LF	=	12		; ### SYMBOLIC FOR THE <LF> CHARACTER.
HLIMIT	=	50		; #RS# THE LOCATION OF THE PROGRAM HIGH LIMIT.
STKPTR	=	42		; ### THE LOCATION OF THE INITIAL STACK POINTER.
JSW	=	44		; ### THE LOCATION OF THE JOB STATUS WORD.
ESCAPE	=	33		; ### SYMBOLIC FOR THE "ESCAPE" CHARACTER.
RUBOUT	=	175		; ### SYMBOLIC FOR THE "RUBOUT" CHARACTER.
RMON	=	54		; ### THE LOCATION OF THE START OF THE RESIDENT MONITOR.
CTRL.U	=	<'U-'@>		; ### SYMBOLIC FOR THE "^U"CHARACTER.
BLKSIZ	=	256.		; ### SYMBOLIC FOR THE BLOCK SIZE IN WORDS.
COMMA	=	54		; ### SYMBOLIC FOR THE "," CHARACTER.
WORDS	=	2		; ### SYMBOLIC FOR WORD-TO-BYTE CONVERSIONS.
TTMODE	=	BIT12		; ### SYMBOLIC FOR TTY SPECIAL MODE BIT IN JSW.
OVLBIT	=	BIT9		; #RS# SYMBOLIC FOR OVERLAY FILE BIT IN JSW.
TAB	=	11		; #RS# SYMBOLIC FOR <TAB> CHARACTER.
SPACE	=	40		; #RS# SYMBOLIC FOR THE "SPACE" CHARACTER.
MAXCHN	=	8.		; #RS# SYMBOLIC FOR THE NUMBER OF CHANNELS CHECKED.
IOCHAN	=	3		; #RS# SYMBOLIC FOR THE LEGAL I/O CNANNEL.
USRLOC	=	266		; FIXED OFFSET INTO MONITOR DATA BASE FOR USR LOAD ADDRESS.
GENFLG	A C D I F M N O P R S T U W	; #RS# GENERATE BIT FLAGS.
BOOTSZ	=	0		; #RS# "VIRTUAL" SIZE OF RT-11 V03 BOOTSTRAP.
IDWORD	=	4742		; #RS# LOCATION OF THE RT-11 V03 IDENTIFIER IN THE MONITOR FILE.
SWAPSZ	=	4776		; #RS# LOCATION OF THE SWAP BLOCK SIZE IN THE MONITOR FILE.

			.SBTTL	GLOBAL DECLARATIONS.

;
;
;
; THE FOLLOWING ADDRESSES ENTRY POINTS, ETC. ARE GLOBALISED
; TO FORCE THEM TO APPEAR IN THE GENERATED LOAD MAP.
;
;
;
			.GLOBL	ASKFIL,START,PROMPT,NEWLIN,SLASH1,SLASH2
			.GLOBL	NEWCU,NEWCHA,NEWSTR,RSET,RELOC,BSET
			.GLOBL	BSLASH,SLASH,ATSIGN,UPARRO,LFEED,CARRET
			.GLOBL	SEMI,COLON,EXIT,ADRLOC,CLOSE,GETFIL
			.GLOBL	CONT,ERROR,INITOV,PRINT,SAVREG,RESREG
			.GLOBL	TYPDGT,$OVRH,RVAL,HIGH,SEGMNT
			.GLOBL	BOTTM,RCON,OPNLOC,SEG,BLKNO,NOSEG
			.GLOBL	OVTAB,OVTABE,OPNADR,RC,DEFEXT
			.GLOBL	BYTFLG,COMTAB,BRTAB,DEVTAB,CHKSUM,TMPSUM
			.GLOBL	BLOCK,MSGPTR,MSGTBL,EMTBLK,FLPFLP,SETOVL
			.GLOBL	FIXOVL,RTBOOT,FTLXIT,R50CVT,R50ASC,ASCOUT
			.GLOBL	ILLCHR,CHRSET,PATLVL,LVLEXT,PACK50,LOWLIM
			.GLOBL	HGHLIM,RETRY,IDADDR,IDWORD,SWPVAL,SWPBAS
			.GLOBL	SWAPSZ,PRTADR,SEARCH,ADDRSS

			.SBTTL	PROGRAM MAIN ROUTINES.
			.SBTTL	1.)	ROUTINE "START".
			.CSECT	HGHSEG
;----------------------------------------------------------------------
;
;
;
;			ROUTINE	"START"
;
;
;
;----------------------------------------------------------------------
START:	.GVAL	#EMTBLK,#USRLOC	; #RS# GET USR LOAD ADDRESS.
	CMP	R0,	HGHLIM	; #RS# ARE WE GOING TO BE SWAPPED OVER?
	BHI	1$		; #RS# NO - CONTINUE.
	JSR	R1,	PRINT	; #RS# YES - PRINT THE...
	.WORD	EXCORE		; #RS# ..."[+2K-CORE]" MESSAGE,...
	CLR	R0		; #RS# ......THEN REQUEST AS MUCH AS WE CAN GET!
1$:	TST	-(R0)		; #RS# POINT TO JUST BELOW REQUESTED AMOUNT.
	.SETTOP			; #RS# REQUEST IT.
	SUB	#8.,	R0	; #RS# ADJUST FOR THE END OF THE OVERLAY TABLES.
	MOV	R0,	OVTABE	; #RS# SAVE VALUE OF THE END OF THE OVERLAY TABLES.

			.SBTTL	2.)	ROUTINE "ASKFIL".
			.CSECT	HGHSEG
;----------------------------------------------------------------------
;
;			ROUTINE	"ASKFIL"
;
;
;		ACCEPT FILE NAME, AND OPEN FILE
;
;
;----------------------------------------------------------------------
ASKFIL:	MOV	@#STKPTR, SP	;INIT STACK - ### USE VALUE GIVEN BY "LINK".
	JSR	R1,	PRINTN	; ### PRINT THE MESSAGE...
	.WORD	FILNAM		; ### ..."FILE NAME - -".
	MOV	#-1,	BLKNO	; ###  SET INITIAL VALUE OF BLOCK NUMBER TO -1.
	MOV	#3,	RETRY	; ###  SET INITIAL VALUE FOR CHECKSUM RETRIES.
	CLR	SEGMNT		; ### INIT. SEGMENT NO. FOR OVERLAID FILES,... 
	CLR	SEG		; #RS# ENSURE "SEG" IS CLEAR.
	CLR	RCON		; ### ...RELOCATION CONSTANT,...
	CLR	BOTTM		; ### ... AND, BOTTOM ADDRESS WORD,
	CLR	CHKSUM		; #RS# ENSURE "CHKSUM" IS ZERO.
	CLRB	FLPFLP		; #RS# ENSURE THAT THE FLIP-FLOP IS ZERO.
	CLR	R1		;CLEAR OUT ALL RELOCATION BIASES,...
1$:	CLR	RC(R1)		; ### ...ALL 9. OF THEM....
	TST	(R1)+		; ### ...POINT TO NEXT RELOC. REG.,...
	CMP	R1,#9.*WORDS	; ### ...DONE?,...
	BNE	1$		; ### NO - DO NEXT ONE.
	BIC	#TTMODE, @#JSW	;TURN ON ECHO ### IN JOB STATUS WORD.
	.RCTRLO			;LET ECHO ON TAKE EFFECT [RRB 15-AUG-74]
	.SRESET			; CLOSE FILES, RELEASE HANDLERS,...
	.CSIGEN	#DEVTAB,#DEFEXT,#0 ;ACCEPT INPUT, LOAD HANDLERS.
	CMP	R0,	OVTABE	; #RS# ENOUGH ROOM FOR OVERLAY TABLES?
	BHIS	NOMEM		; #RS# NO - PRINT ERROR MESSAGE.
	MOV	R0,	OVTAB	; #RS# YES - SAVE OVERLAY TABLE ADDRESS
	BIS	#TTMODE, @#JSW	;TURN OFF ECHO.
	MOV	#MAXCHN, R0	; #RS# SET UP TO CHECK ALL CHANNELS,...
2$:	$WAIT			; #RS# CHECK ALL OF THEM,...
	BCC	6$		; #RS# ...OPEN => ERROR, REPORT IT!
3$:	DEC	R0		; #RS# MOVE DOWN TO NEXT CHANNEL.
	BLT	4$		; #RS# WHEN DONE CHECK INPUT CHANNEL- (I.E. 3).
	CMP	#IOCHAN, R0	; #RS# READY FOR INPUT CHANNEL YET?
	BNE	2$		; #RS# YES - SKIP PAST IT FOR NOW.
	BR	3$		; #RS# NO - GO DO NEXT.

4$:	MOV	#IOCHAN, R0	; #RS# NOW CHECK,...
	$WAIT			; #RS# ...LEGAL INPUT CHANNEL.
	BCC	7$		; #RS# OPEN => OK - GO TO IT.
5$:	JSR	R1,	PRINTN	; #RS# ON NULL COMMAND LINE,...
	.WORD	PATCHV		; #RS# ... PRINT THE VERSION NO.,...
	BR	ASKFIL		; #RS# ... AND GET A NEW COMMAND.
6$:	JSR	R1,	PRINT	; ### PRINT MESSAGE...
	.WORD	BADFIL		; ### ..."INCORRECT FILE SPECIFICATION"...
	BR	ASKFIL		; ### ... AND AWAIT NEW FILE SPECIFICATION.
NOMEM	=	.
	JSR	R1,	PRINT	; #RS# PRINT THE,...
	.WORD	NOCORE		; #RS# ..."INSUFFICIENT MEMORY" MESSAGE,...
	JMP	FTLXIT		; #RS# ......THEN RETURN TO THE RT-11 MONITOR.

7$:	CLR	R2		; #RS# INIT. R2 FOR SWITCH FLAGS, ETC..
	MOV	(SP)+,	R3	; ### GET # OF SWITCHES.
	BEQ	19$		;IF NONE BYPASS
8$:	MOV	(SP)+,	R0	; ### GET NEXT SWITCH
	SWTTST	8 R2 A M O C D	; #RS# SET TO TEST SWITCH OPTIONS.

16$:	BIT	#FLAG.M, R2	; #RS# "M" FLAG SET?
	BEQ	17$		; #RS# NO - EVERYTHING IS PROBABLY OK THEN.
	BIT	#FLAG.O, R2	; #RS# YES - IS THE "O" FLAG ALSO SET?
	BNE	OPTERR		; #RS# YES - THAT A NO-NO!!
17$:	BIT	#FLAG.D, R2	; #RS# NO - IS THE "D" FLAG SET?
	BEQ	18$		; #RS# NO - CHECK "C" FLAG.
	BIT	#FLAG.C, R2	; #RS# YES - "C" FLAG ALSO SET?
	BEQ	20$		; #RS# NO - NO FURTHER CHECKS ARE NECESSARY.
	BIC	#FLAG.D, R2	; #RS# YES - DEFAULT TO "C" FLAG SET,...
	BR	20$		; #RS# ...THEN BEGIN PROCESSING.
18$:	BIT	#FLAG.C, R2	; #RS# ARE "C" AND"D" FLAGS BOTH SET?
	BNE	20$		; #RS# NO - BEGIN PROCESSING.
19$:	BIS	#FLAG.N, R2	; #RS# YES - SET THE "NO CHECKSUM SWITCHES" FLAG...

20$:	BIT	#FLAG.M, R2	; #RS# IS THIS A MONITOR FILE?
	BEQ	22$		; #RS# NO - BYPASS.
	MOV	R2,	-(SP)	; #RS# YES - SAVE ALL LEGITIMATE FLAGS.
	MOV	#FLAG.A, FLGWRD	; #RS# SIMULATE NON-FILE-STRUCTURED MODE.
	MOV	#<BLKSIZ*WORDS>, R3 ; #RS# GET NUMBER OF BYTES IN A BLOCK.
	MOV	R3,	R4	; #RS# SAVE VALUE.
	ASL	R3		; #RS# MAKE IT 2000 IF IT'S VERSION V02C.
	MOV	(PC)+,	R1	; #RS# GET ADDRESS,..
IDADDR	=	.
	.WORD	IDWORD		; #RS# ...OF RT-11 V03 ID..
	JSR	PC,	ADRLOC	; #RS# READ BLOCK AND RELOCATE ADDRESS.
	CMP	(R2),	#"RT	; #RS# IS IT VERSION V03?

	BNE	21$		; #RS# NO - BYPASS.
	ASL	R3		; #RS# YES - R3 = 4000
	ADD	R4,	R3	; #RS# THEN MAKE R3 5000 FOR RT-11 V03 BOOT.
	MOV	(PC)+,	R1	; #RS# GET ADDRESS OF MONITOR,...
SWPVAL	=	.
	.WORD	SWAPSZ		; #RS# ...(SJ, FB, XM) SWAP BLOCK SIZE.
	JSR	PC,	ADRLOC	; #RS# READ BLOCK AND RELOCATE ADDRESS.
	MOV	(R2),	SWPBAS	; #RS# SAVE IT IN THE RIGHT PLACE.
21$:	MOV	R3,	RTBOOT	; #RS# THEN SAVE SIZE WHERE IT CAN BE FOUND.
	MOV	(SP)+,	R2	; #RS# RESTORE PROPER FLAGS.
22$:	MOV	R2,	FLGWRD	; #RS# SET UP FLAGS AND SWITCHES.
	JSR	PC,	INITOV	;INIT TABLES [RRB 15-AUG-74]

			.SBTTL	3.)	ROUTINES "PROMPT", "NEWLIN", "NEWCU", AND "NEWSTR".
			.CSECT	HGHSEG
;----------------------------------------------------------------------
;
;			ROUTINES "PROMPT" AND "NEWLIN".
;
;
;		START A NEW INPUT LINE
;
;
;----------------------------------------------------------------------
PROMPT:	MOVB	#'*,	R0		;PRINT PROMPT CHARACTER
	.TTYOUT
NEWLIN:	MOV	@#STKPTR,	SP	; ### INIT. STACK POINTER.
	CLR	OPNADR			; ### INDICATE "NO ADDRESS OPEN".
NEWCU:	CLR	TMPSUM			; #RS# RESET THE TEMPORARY CHECKSUM.
	CLR	RCON			; ### INIT. RELOCATION CONSTANTS.
	CLR	SEGMNT			; ### INIT. SEGMENT MARKER.
	CLR	SEG			; ### INIT. "SEG" MARKER.
	CLR	RVAL			; ### INIT. ARGUMENTS.
			.CSECT	HGHSEG
;----------------------------------------------------------------------
;
;			ROUTINE "NEWSTR".
;
;		START A NEW COMMAND STRING
;
;
;----------------------------------------------------------------------
NEWSTR:	CLR	R1			; ### INIT R1, FOR INPUT.
	BIC	#FLAG.T, FLGWRD		; #RS# INIT. "FLAG.T".

			.SBTTL	4.)	ROUTINE	"NEWCHA".
			.CSECT	HGHSEG
;----------------------------------------------------------------------
;
;			ROUTINE	"NEWCHA"
;
;
;		GET AN INPUT CHARACTER.
;
;
;----------------------------------------------------------------------
NEWCHA:	.TTYIN			; ### PICK UP A CHARACTER IN R0.
	CMPB	R0,	#CTRL.U	; ### CHECK FOR ^U
	BEQ	1$		; ### PROCESS ^U IF FOUND.
	CMPB	R0,	#RUBOUT	; ### TREAT AS ^U,...
	BHIS	1$		; ### ...AND PROCESS IN THE SAME MANNER.
	CMPB	R0,	#ESCAPE	; ### SIMILARLY FOR "ESCAPES",...
	BNE	2$		; ### ... ALSO AS ^U.
1$:	JSR	R1,	PRINTN	; ### PRINT THE "^U"...
	.WORD	UPARRU		; ### ... AND ...
	BR	NEWCU		; ### ...THEN GO BACK FOR A NEW COMMAND LINE.
2$:	MOV	R0,	-(SP)	; ### SAVE CHARACTER ON THE STACK.
	.TTYOUT			; ### PRINT IT.
	MOV	(SP)+,	R0	; ### RETRIEVE CHARACTER FROM STACK.
	ADD	R0,	TMPSUM	; #RS# ENSURE EACH CHARACTER IS ADDED TO "TMPSUM".
	ASL	TMPSUM		; #RS# DOUBLE IT FOR GREATER SAFETY.
	CMPB	R0,	#'0	; ### IS IT AN ASCII NUMBER?
	BLO	3$		; ### NO - TREAT IT SEPARATELY.
	CMPB	R0,	#'7	; ### MAYBE - CHECK UPPER LIMIT.
	BHI	3$		; ### NO - TREAT IT SEPARATELY.
	BIC	#-10, R0	; ### DEFINITELY A DIGIT MAKE IT OCTAL.
	ASL	R1		; ### BUILD OCTAL NUMBER,...
	ASL	R1		; ### ...BY MULTIPLYING BY 10(8),...
	ASL	R1		; ### ......THEN,...
	ADD	R0,	R1	; ### ... ADDING IN THE NEW DIGIT.
	BIS	#FLAG.T, FLGWRD	; ### SET THE TYPE-CHARACTER FLAG.
	BR	NEWCHA		; ### ANYTHING ELSE MUST BE NEW CHARACTER.
3$:	CLR	R4		; ### INIT. R4 AS AN INDEX.
4$:	CMPB	R0, COMTAB(R4)	; ### IS THE CHAR. A COMMAND CHAR.?
	BEQ	6$		; ### YES - GO DISPATCH TO ROUTINE.
	INC	R4		; ### MAYBE - CHECK NEXT ONE IN COMMAND TABLE.
	CMP	R4,	#NOCOM	; ### ALL COMMANDS CHECKED?
	BNE	4$		; ### NO - CHECK THE REST.
5$:	JSR	R1,	PRINTN	; ### YES - MUST BE AN ILLEGAL CHAR,...
	.WORD	QM..CR		; ### ...PRINT THE "?",...
	BR	PROMPT		; ### ...AND RETURN FOR A NEW LINE.
6$:	ASL	R4		; #RS# CONVERT TO A BYTE INDEX,...
	JMP	@BRTAB(R4)	; #RS# ...AND DISPATCH TO ROUTINE.

			.SBTTL	5.)	ROUTINES "RSET", "ADDOLD" AND "SETOVL".
			.CSECT	HGHSEG
;----------------------------------------------------------------------
;
;			ROUTINE	"RSET".
;
;		ROUTINE TO SET THE RELOCATION REGISTERS.
;
;
;----------------------------------------------------------------------
			.ENABL	LSB
RSET:	CMP	R1,	#7	;CHECK REG # ### <= 7?
	BLOS	1$		; ### YES - GO PROCESS IT.
	JSR	R1,	PRINT	; ### NO- PRINT THE ...
	.WORD	INVREL		; ### ..."INVALID RELOCATION REGISTER" MESSAGE.
	BR	PROMPT		; ### AND RETURN TO START A NEW LINE.
1$:	ASL	R1		; ### MAKE IT AN INDEX,...
	MOV	RVAL,	RC+2(R1); ### ...AND SAVE RELOC. CONSTANT.
2$:	JSR	R1,	PRINTN	; ### PRINT THE ...
	.WORD	CR..LF		; ### ...THE <CR><LF>,...
	BR	PROMPT		; ### ...AND RETURN TO START A NEW LINE.
;----------------------------------------------------------------------
;
;
;			ROUTINE "ADDOLD"
;
;		ROUTINE TO PROCESS THE "&" COMMAND.
;
;
;----------------------------------------------------------------------
ADDOLD:	JSR	PC,	CLOSE	; #RS# CLOSE ANY OPEN ADDRESSES,...
	COMB	FLPFLP		; #RS# COMPLEMENT THE 'ADD OLD CONTENTS' FLIP-FLOP.
	BR	2$		; #RS# ...THEN START A NEW LINE.
;----------------------------------------------------------------------
;
;
;			ROUTINE "SETOVL"
;
;		ROUTINE TO PROCESS THE "O" COMMAND.
;
;
;----------------------------------------------------------------------
SETOVL:	TST	OPNADR		; #RS# AN ADDRESS OPEN?
	BNE	3$		; #RS# YES -  GO DO IT. 
	JSR	R1,	PRINT	; #RS# NO - PRINT THE...
	.WORD	NOADDR		; #RS# ..."NO ADDRESS OPEN" MESSAGE.
	BR	2$		; #RS# THEN RETURN.
3$:	MOV	RVAL,	R1	; #RS# GET LAST ARGUMENT.
	BNE	4$		; #RS# ONLY NON-ZERO VALUES ALLOWED.
	JSR	R1,	PRINT	; #RS# NO - IT ISN'T, PRINT THE...
	.WORD	INVOVS		; #RS# ..."INVALID OVERLAY SIZE" MESSAGE,..
	BR	2$		; #RS# ...AND GET A NEW LINE.
4$:	BIS	#FLAG.T, FLGWRD	; #RS# INDICATE VALUE TO BE CHANGED.
	JSR	PC,	CLOSE	; #RS# SET THE CHANGE AND WRITE OUT THE BLOCK.
	BR	FIXOVL		; #RS# THEN RE - INIT. THE OVERLAYS.

			.SBTTL	6.)	ROUTINES "RELOC", "BSET", AND "BSLASH".
			.CSECT	HGHSEG
;----------------------------------------------------------------------
;
;			ROUTINE	"RELOC".
;
;		ROUTINE TO PROCESS THE "," COMMANDS
;		I. E. SET THE RELOCATION CONSTANTS.
;
;
;----------------------------------------------------------------------
RELOC:	INC	R1		; ### COMPUTE...
	ASL	R1		; ### ...THE RELOCATION CONSTANT,...
	MOV	R1,	RCON	; ### ...SAVE IT IN "RCON",...
	BR	NEWSTR		; ### ...AND RETURN TO GET A NEW LINE.
;----------------------------------------------------------------------
;
;			ROUTINE	"BSET".
;
;		ROUTINE TO PROCESS THE "B" COMMAND.
;		I. E. SET THE BOTTOM ADDRESS.
;
;
;----------------------------------------------------------------------
BSET:	MOV	RVAL,	BOTTM	; ### RVAL CONTAINS THE BOTTOM ADDRESS, SET "BOTTM".
FIXOVL:	BIC	#FLAG.I, FLGWRD	; ### INDICATE FILE NOT "INIT.'ED".
	JSR	PC,	INITOV	; ### INIT. THE OVERLAY FILES,...
	BR	2$		; ### ... AND GO BACK AND START A NEW LINE.
			.DSABL	LSB
;----------------------------------------------------------------------
;
;			ROUTINE	"BSLASH".
;
;		ROUTINE TO PROCESS THE "\" COMMAND.
;
;
;----------------------------------------------------------------------
			.ENABL	LSB
BSLASH:	MOVB	#1,	BYTFLG	; ### INDICATE THAT A BYTE HAS BEEN OPENED...
	BR	SLASH1		; ### ...AND GO DO THE COMMON STUFF.

			.SBTTL	7.)	ROUTINES "SLASH", AND "ATSIGN".
			.CSECT	HGHSEG
;----------------------------------------------------------------------
;
;			ROUTINE	"SLASH"
;
;		ROUTINE TO PROCESS THE "/" COMMAND.
;
;
;----------------------------------------------------------------------
SLASH:	CLRB	BYTFLG		; ### INDICATE THAT A WORD HAS BEEN OPENED...
	BIT	#1,	R1	; ### IS THE ADDRESS ODD?
	BEQ	SLASH1		; ### NO - GO DO IT.
1$:	JSR	R1,	PRINT	; ### YES - PRINT THE...
	.WORD	ODDADR		; ### ..."ODD ADDRESS" MESSAGE,...
	JMP	PROMPT		; ### ...AND START A NEW LINE.
SLASH1:	MOV	RCON,	R2	; ### PICK UP THE RELOCATION CONSTANT,...
	ADD	RC(R2),	R1	; ### ...CALCULATE THE ABSOLUTE ADDRESS,...
	MOV	R1,	OPNLOC	; ### ...AND SAVE THE VALUE OF THE CURRENTLY OPEN ADDRESS.
SLASH2:	MOV	SEGMNT,	SEG	; ### PICK UP THE SEGMENT NUMBER.
	MOV	OPNLOC,	R1	; ### PICK UP THE CURRENTLY OPEN ADDRESS.
	JSR	PC,	ADRLOC	; ### COMPUTE THE LOCATION OF THE ADDRESS WITHIN THE FILE.
	MOV	R2,	OPNADR	; ### R2 NOW CONTAINS THE ADDRESS OF THE LOCATION IN THE BUFFER.
	JSR	PC,	CONT	; ### PRINT OUT THE CONTENTS OF THE OPENED LOCATION.
	CLR	RCON		; ### RESET THE RELOCATION CONSTANT,...
	BIT	#FLAG.S, FLGWRD	; #RS# THIS IS A KLUDGE TO ALLOW SEARCH MODE.
	BNE	SERRTS		; #RS# BRANCH IF IN SEARCH MODE.
	JMP	NEWSTR		; ### AND RETURN FOR A NEW STRING.
SERRTS	=	.
	RTS	PC		; #RS# CONTINUE IN SEARCH MODE.
;----------------------------------------------------------------------
;
;			ROUTINE	"ATSIGN"
;
;		ROUTINE TO PROCESS THE "@" COMMAND.
;
;
;----------------------------------------------------------------------
ATSIGN:	TST	OPNADR		; ### ANY ADDRESS OPEN?
	BEQ	NAOERR		; ### NO - PRINT THE "NO ADDRESS OPEN" MESSAGE,...
	JSR	R1,	PRINTN	; ### YES - PRINT A...
	.WORD	CR..LF		; ### ...<CR><LF>.
	TSTB	BYTFLG		; ### IS A BYTE ADDRESS SPECIFIED?
	BNE	MOWERR		; ### YES - PRINT "MUST OPEN WORD" MESSAGE.
	MOV	@OPNADR, OPNLOC	; ### PICK UP THE CONTENTS OF THE OPENED LOCATION,...
	BIT	#1,	OPNLOC	; ### ...IS IT ODD?
	BNE	1$		; ### YES - PRINT THE "ODD ADDRESS" MESSAGE,...
	BR	3$		; ### NO - GO CHANGE IT AND WRITE OUT THAT BLOCK.

			.SBTTL	8.)	ROUTINES "UPARRO", AND "LFEED".
			.CSECT	HGHSEG
;----------------------------------------------------------------------
;
;			ROUTINE	"UPARROW".
;
;		ROUTINE TO PROCESS THE "^" COMMAND.
;
;
;----------------------------------------------------------------------
UPARRO:	JSR	R1,	PRINTN	; ### PRINT OUT...
	.WORD	CR..LF		; ### ...A <CR><LF> FIRST.
	DEC	OPNLOC		; ### POINT TO THE PREVIOUS BYTE.
	TSTB	BYTFLG		; ### IS A BYTE OPEN DESIRED?
	BNE	2$		; ### YES - GO DO IT.
	DEC	OPNLOC		; ### NO - MAKE IT A WORD THEN.
2$:	CMP	OPNLOC,	#-2	; ### ARE WE POINTING OUT OF THE BLOCK?
	BLO	3$		; ### NO - GO WRITE OUT THE BLOCK.
	CLR	OPNLOC		; ### YES - RESET THE CURRENTLY OPENED LOCATION,...
	BR	3$		; ### ... AND THE WRITE OUT THE BLOCK.
;----------------------------------------------------------------------
;
;			ROUTINE	"LFEED".
;
;		ROUTINE TO PROCESS THE "<LF>" COMMANDS.
;
;
;----------------------------------------------------------------------
LFEED:	.TTYOUT	#CR		; ### PRINT A "<CR>",...
	.TTYOUT	#CR		; ### ...TWICE!...
	INC	OPNLOC		; ### POINT TO THE NEXT BYTE.
	TSTB	BYTFLG		; ### WAS A BYTE OPEN DESIRED?
	BNE	3$		; ### YES - GO DO IT.
	INC	OPNLOC		; ### NO - MAKE IT A WORD THEN!
3$:	TST	OPNADR		; ### IS AN ADDRESS CURRENTLY OPEN?
	BEQ	NAOERR		; ### NO - PRINT THE "NO ADDRESS OPEN" MESSAGE.
	JSR	PC,	CLOSE	; ### YES - SET THE CHANGE AND WRITE OUT THE BLOCK.
			.DSABL	LSB

;----------------------------------------------------------------------
;
;		ROUTINE TO CALCULATE RELOCATION REGISTERS.
;
;
;		COMPUTE RELOCATION REGISTER
;
;
;----------------------------------------------------------------------
			.ENABL	LSB
PRTADR:	MOV	OPNLOC,	R2	;SMALLEST OFFSET SO FAR.
	CLR	RCON		; ### SET THE RELOCATION CONSTANT TO ZERO.
	CLR	R1		;COUNT
1$:	MOV	OPNLOC,	R3	; ### PUT THE OPENED ADDRESS INTO R3 ALSO.
	SUB	RC(R1),	R3	;COMPUTE NEW OFFSET.
	CMP	R2,	R3	;COMPARE WITH SMALLEST.
	BLOS	2$		;OLD ONE STILL SMALLEST.
	MOV	R1,	RCON	; ### NEW RELOCATION CONSTANT IS IN R1.
	MOV	R3,	R2	; ### SET NEW SMALLEST VALUE INTO R2.
2$:	TST	(R1)+		; ### POINT R1 TO NEXT VALUE.
	CMP	R1, #9.*WORDS	; ### IS IT AT THE END OF THE TABLE?
	BNE	1$		; ### NO - CHECK NEXT ENTRY.

;----------------------------------------------------------------------
;
;
;			PRINT OPEN ADDRESS
;
;
;----------------------------------------------------------------------
	BIT	#FLAG.O, FLGWRD	;OVERLAY FILE?
	BEQ	3$		;NO, BY PASS
	MOV	SEGMNT,	R1	;CHECK SEGMENT #
	BEQ	3$		; ### NO SEGMENT NUMBER => DON'T PRINT IT.
	MOV	R1,	R0	;PRINT SEGMENT #
	JSR	PC,	TYPDGT	; ### TYPE OUT THE SEGMENT NO.
	.TTYOUT	#':		;PRINT COLON
3$:	MOV	RCON,	R0	; ### INSERT RELOCATION CONSTANT INTO R0.
	BEQ	4$		; ### NO RELOC. CONST.=> PRINT ONLY THE ABLOLUTE ADDRESS.
	ASR	R0		; ### COMPUTE THE...
	DEC	R0		; ### ...RELOCATION CONSTANT.
	JSR	PC,	TYPDGT	;PRINT RELOC. IF ANY,
	.TTYOUT	#COMMA		; ### OUTPUT A COMMA.
4$:	MOV	R2,	R0	; ### GET THE OFFSET.
	JSR	PC,	TYPDGT	; ### PRINT IT.
	MOVB	BYTFLG,	R0	; ### SET UP OFFSET FOR BYTES OR WORDS.
	MOVB	FSLBSL(R0), R0	; ### PRINT EITHER THE "/" OR THE "\".
	.TTYOUT			; ### OUT IT GOES!
	BR	SLASH2		; ### TO THE COMMON CODE TO FINISH UP.
			.DSABL	LSB

			.SBTTL	9.)	ROUTINES "CARRET", "SEMI", AND "COLON".
			.CSECT	HGHSEG
;----------------------------------------------------------------------
;
;			ROUTINE	"CARRET".
;
;		ROUTINE TO PROCESS THE "<CR>" COMMANDS.
;
;
;----------------------------------------------------------------------
			.ENABL	LSB
CARRET:	.TTYIN			;ACCEPT AND ECHO,...
	.TTYOUT			;...LINE FEED CHAR.
	JSR	PC,	CLOSE	; ### FIX IT UP AND WRITE IT OUT.
1$:	JMP	PROMPT
;----------------------------------------------------------------------
;
;			ROUTINE "SEMI"
;
;		ROUTINE TO PROCESS THE ";" COMMANDS.
;
;
;----------------------------------------------------------------------
SEMI:	MOV	R1,	RVAL
2$:	JMP	NEWSTR
;----------------------------------------------------------------------
;
;			ROUTINE	"COLON".
;
;		ROUTINE TO PROCESSES THE ":" COMMANDS.
;
;
;----------------------------------------------------------------------
COLON:	MOV	R1,	SEGMNT	; ### SAVE THE VALUE OF THE SEGMENT NUMBER...
	BR	2$		; ### ...AND RETURN TO DO THE COMMON CODE.
NAOERR:	JSR	R1,	PRINT	; ### PRINT THE ...
	.WORD	NOADDR		; ### ..."NO ADDRESS OPEN" MESSAGE,...
	BR	1$		; ### ... AND GO GET A NEW LINE.
MOWERR:	JSR	R1,	PRINT	; ### PRINT THE ...
	.WORD	OPNWRD		; ### ..."MUST OPEN WORD" MESSAGE,...
	BR	1$		; ### ... THEN GO GET A NEW LINE.
			.DSABL	LSB

			.SBTTL	10.)	ROUTINES "GETFIL", AND "EXIT".
			.CSECT	HGHSEG
;----------------------------------------------------------------------
;
;			ROUTINES	"GETFIL" AND "EXIT".
;
;		ROUTINE TO CLOSE THE INPUT CHANNEL
;		AND RETURN TO THE RT-11 MONITOR.
;
;
;----------------------------------------------------------------------
			.ENABL	LSB
GETFIL:	BIS	#FLAG.F, FLGWRD	; #RS# INDICATE LAST COMMAND WAS AN "F" COMMAND.
EXIT:	JSR	R1,	PRINTN	; #RS# FIRST PRINT THE...
	.WORD	CR..LF		; #RS# ..."CR><LF>",...
	MOV	HGHLIM,	R0	; #RS# THEN LOWER THE AMOUNT OF CORE NEEDED,...
	.SETTOP			; #RS# ...SO THAT THE KMON CAN SWAP IN.
	ROR	CHKSUM		; #RS# ELIMINATE LAST DOUBLING.
	BIT	#FLAG.W, FLGWRD	; #RS# ANY PART OF THE FILE CHANGED?
	BEQ	8$		; #RS# IF NOT - BYPASS CHECKSUM LOGIC.
	BIT	#FLAG.N, FLGWRD	; #RS# ANY CHECKSUM SWITCHES?
	BNE	8$		; #RS# YES - JUST BLOW THIS GARAGE.
	BIT	#FLAG.D, FLGWRD	; #RS# INHIBIT CHECKSUM?
	BNE	7$		; #RS# NO - JUST PRINT OUT THE CHECK SUM.
1$:	CLR	R1		; #RS# INIT. R1 TO RECEIVE CHECKSUM.
	JSR	R1,	PRINTN	; #RS# PRINT THE ...
	.WORD	ECSMSG		; #RS# ..."ENTER CHECKSUM" MESSAGE.
2$:	.TTYIN			; #RS# RECEIVE A CHARACTER INTO R0.
	CMPB	R0,	#CR	; #RS# CHECK FOR "<CR>"
	BEQ	6$		; #RS# PROCESS "<CR>" IF FOUND.
	CMPB	R0,	#CTRL.U	; #RS# "^U" ?
	BNE	3$		; #RS# NO - BYPASS ERROR MESSAGE.
	JSR	R1,	PRINTN	; #RS# YES - PRINT THE "^U"...
	.WORD	UPARRU		; #RS# ... AND ...
	BR	1$		; #RS# GO BACK TO INIT. FOR ANOTHER TRY.
3$:	MOV	R0,	-(SP)	; #RS# SAVE CHARACTER ON THE STACK.
	.TTYOUT			; #RS# PRINT IT.
	MOV	(SP)+,	R0	; #RS# RETRIEVE CHARACTER FROM STACK.
	CMPB	R0,	#'0	; #RS# IS IT AN ASCII NUMBER?
	BLO	4$		; #RS# NO - TREAT IT SEPARATELY.
	CMPB	R0,	#'7	; #RS# MAYBE - CHECK UPPER LIMIT.
	BLOS	5$		; #RS# NO - TREAT IT SEPARATELY.
4$:	JSR	R1,	PRINTN	; #RS# PRINT THE...
	.WORD	QM..CR		; #RS# ..."?<CR><LF>",...
	BR	1$		; #RS# ...AND GO BACK FOR ANOTHER.
5$:	BIC	#-10,	R0	; #RS# DEFINITELY A DIGIT MAKE IT OCTAL.
	ASL	R1		; #RS# BUILD OCTAL NUMBER,...
	ASL	R1		; #RS# ...BY MULTIPLYING BY 10(8),...
	ASL	R1		; #RS# ......THEN,...
	ADD	R0,	R1	; #RS# ... ADDING IN THE NEW DIGIT.
	BR	2$		; #RS# ANYTHING ELSE MUST BE NEW CHARACTER.

6$:	.TTYOUT			; #RS# PRINT OUT THE "<CR>".
	.TTYIN			; #RS# ACCEPT,...
	.TTYOUT			; #RS# ...AND EHCO THE "<LF>"
	CMP	R1,	CHKSUM	; #RS# ARE THE TWO EQUAL?
	BEQ	8$		; #RS# YES - TELL HIM SO!
	JSR	R1,	PRINT	; #RS# NO - PRINT THE ...
	.WORD	CKSERR		; #RS# "CHECKSUM ERROR" MESSAGE,...
	DEC	(PC)+		; #RS# GIVE HIM...
RETRY:	.WORD	3		; #RS# ... THREE TRYS,...
	BEQ	8$		; #RS# ...THEN JUST EXIT IN DISGUST,...
	BR	1$		; #RS# ...OTHERWISE, MAKE HIM TRY UNTIL HE GETS IT RIGHT!
7$:	JSR	R1,	PRINT	; #RS# PRINT THE ...
	.WORD	CSEMSG		; #RS# ... "CHECKSUM EQUALS" MESSAGE.
	MOV	CHKSUM,	R0	; #RS# SET UP THE CHECKSUM.
	JSR	PC,	TYPDGT	; #RS# ...THEN,PRINT OUT THE CHECKSUM.
8$:	.CLOSE	#IOCHAN		; #RS# CLOSE THE INPUT CHANNEL FIRST.
	BIT	#FLAG.F, FLGWRD	; #RS# WAS THIS AN "F", OR "E" COMMAND?
	BEQ	10$		; #RS# AN "E" CMD. - GO EXIT TO MONITOR.
	JMP	ASKFIL		; #RS# ...THEN REQUEST NEW FILE SPEC.
				; #RS# NO - AN "E" CMD., ...
10$:
FTLXIT:	.EXIT			; ### ...THEN RETURN TO MONITOR
			.DSABL	LSB

			.SBTTL	11.)	ROUTINES "R50CVT" AND "ASCOUT".
			.CSECT	HGHSEG
;----------------------------------------------------------------------
;
;			ROUTINE	"R50CVT".
;
;		ROUTINE TO PROCESS THE "X" COMMAND.
;
;----------------------------------------------------------------------
			.ENABL	LSB
R50CVT:	TST	OPNADR		; #RS# IS AN ADDRESS OPEN?
1$:	BEQ	NAOERR		; #RS# NO - REPORT ERROR.
	TSTB	BYTFLG		; #RS# YES - IS THE OPEN ADDRESS A BYTE?
	BEQ	2$		; #RS# NO - BYPASS.
	BIT	#FLAG.S, FLGWRD	; #RS# YES - ARE WE IN SEARCH MODE?
	BNE	9$		; #RS# YES - JUST BYPASS EVERYTHING.
	BR	MOWERR		; #RS# NO - REPORT THE ERROR.
2$:	BIT	#FLAG.S, FLGWRD	; #RS# ARE WE IN SEARCH MODE?
	BEQ	3$		; #RS# NO - DON'T PRINT THE "A".
	MOV	#HT,	R0	; #RS# YES - SET UP A "TAB",...
	.TTYOUT			; #RS# ...THEN PRINT IT.
	MOV	#'X,	R0	; #RS#... AND SET UP THE "A",...
	.TTYOUT			; #RS# ...THEN PRINT IT TOO.
3$:	JSR	R1,	PRINTN	; #RS# PRINT THE,...
	.WORD	SPEQSP		; #RS# ..." = " SEPARATOR.
	JSR	PC,	R50ASC	; #RS# PRINT OUT THE RAD50 CONTENTS,...
4$:	.TTYOUT	#HT		; #RS# PRINT OUT THE <TAB>,...
	BIT	#FLAG.S, FLGWRD	; #RS# ARE WE IN SEARCH MODE?
	BNE	9$		; #RS# YES - RETURN TO CALLER.
	JMP	NEWCHA		; #RS# ... AND PREPARE TO ACCEPT A NEW CHARACTER.
;----------------------------------------------------------------------
;
;			ROUTINE	"ASCOUT"
;
;		ROUTINE TO PROCESS THE "A" COMMAND.
;
;----------------------------------------------------------------------
ASCOUT:	TST	OPNADR		; #RS# IS AN ADDRESS CURRENTLY OPEN?
	BEQ	1$		; #RS# NO - REPORT ERROR.
	JSR	R1,	PRINTN	; #RS# YES - PRINT THE,...
	.WORD	SPEQSP		; #RS# ..." = " SEPARATOR.
	TSTB	BYTFLG		; #RS# IS THE ADDRESS ON A BYTE BOUNDARY?
	BEQ	5$		; #RS# NO - DO WORDS.
	MOVB	@OPNADR, R5	; #RS# SET IN THE BYTE.
	BIC	#-400,	R5	; #RS# YES - ENSURE THAT CHAR. IS ASCII WORD,...
	BR	6$		; #RS# ...AND GO TO THE COMMON CODE.
5$:	MOV	@OPNADR, R5	; #RS# SET IN THE WORD.
6$:	MOVB	R5,	R0	; #RS# PUT IN THE FIRST BYTE,...
	BLE	7$		; #RS# NULL AND NEGATIVE ARE NOT ASCII.
	CMPB	R0,	#40	; #RS# IS IT A PRINTING CHARACTER?
	BGE	8$		; #RS# YES - GO PRINT IT.
7$:	MOVB	(PC)+,	R0	; #RS# NO - PRINT THE "?" INSTEAD.
ILLCHR:	.WORD	'?		; #RS# ***PATCHABLE.***
8$:	.TTYOUT			; #RS# ...PRINT IT,...
	CLRB	R5		; #RS# CLEAR OUT CHARACTER JUST PRINTED.
	SWAB	R5		; #RS# ...ALIGN THE NEXT BYTE, IF DOING WORDS,...
	TST	R5		; #RS# DONE?
	BNE	6$		; #RS# NO - DO NEXT BYTE.
	BIT	#FLAG.S, FLGWRD	; #RS# YES - ARE WE IN SEARCH MODE?
	BNE	R50CVT		; #RS# YES - DO RAD 50 CONVERSION TOO.
	BR	4$		; #RS# NO - LEAVE ROUTINE.
9$:	RTS	PC		; #RS# RETURN FOR SEARCH MODE.
			.DSABL	LSB

				.SBTTL	12.)	ROUTINE	"PACK50".
				.CSECT	HGHSEG
;----------------------------------------------------------------------
;
;
;			ROUTINE	"PACK50"
;
;		ROUTINE TO PROCESS THE "P" COMMAND.
;
;
;----------------------------------------------------------------------
PACK50:	MOV	OPNADR, -(SP)	; #RS# SAVE "OPNADR".
	BEQ	9$		; #RS# NULL? YES - REPORT ERROR.
	TSTB	BYTFLG		; #RS# IS THE OPEN ADDRESS A BYTE?
	BNE	8$		; #RS# YES - REPORT ERROR.
	.TTYOUT	#SPACE		; #RS# NO - PRINT...
	.TTYOUT	#'(		; #RS# ...SOME DELIMITERS.
	MOV	#3,	R3	; #RS# INITIALISE INPUT COUNT.
1$:	DEC	R3		; #RS# COUNT CHARACTERS.
	BMI	2$		; #RS# EXIT WHEN DONE.
	.TTYIN			; #RS# PICK UP A CHARACTER IN R0.
	BIC	#-200,	R0	; #RS# FORCE IT TO BE ASCII WORD.
	CMP	#CTRL.U, R0	; #RS# WAS IT A "<CTRL>U"?
	BEQ	10$		; #RS# YES - REPORT ERROR.
	CMP	#RUBOUT, R0	; #RS# NO - WAS IT A RUBOUT?
	BEQ	10$		; #RS# YES - REPORT ERROR.
	MOV	R0,	-(SP)	; #RS# NO - SAVE IT ON STACK,...
	ADD	R0,	TMPSUM	; #RS# ENSURE EACH CHARACTER IS ADDED TO "TMPSUM".
	ASL	TMPSUM		; #RS# DOUBLE IT FOR GREATER SAFETY.
	.TTYOUT			; #RS# ECHO THE CHARACTER,...
	BR	1$		; #RS# ...AND GO GET NEXT.
2$:	MOV	2*WORDS(SP),R0	; #RS# ALIGN...
	MOV	(SP), 2*WORDS(SP); #RS# ...CHARACTERS,...
	MOV	R0,	(SP)	; #RS# ......ON STACK.
	MOV	#BIT13,	R2	; #RS# MASK KEEPS TABS ON CONVERSION.
	CLR	R1		; #RS# INIT. REGISTER.
3$:	MOV	(SP)+,	R0	; #RS# GET A BYTE.
	SUB	#'9+1,	R0	; #RS# IN DIGIT...
	ADD	#'9+1-'0, R0	; #RS# ... RANGE?
	BCC	5$		; #RS# NO - TRY ALPLABETICS.
	ADD	#36,	R0	; #RS# YES - MAKE IT A RAD 50 DIGIT.
	BR	6$		; #RS# GO INSERT INTO RAD50 FORMAT.

4$:	SUB	#20,	R0	; #RS# TRY LOWER CASE.
5$:	SUB	#20,	R0	; #RS# CHECK FOR ALPHABETICS.
	BLE	7$		; #RS# NO - CHECK NEXT.
	CMP	R0,	#'Z-'@	; #RS# IS IT ALPHA?
	BHI	4$		; #RS# NO - TRY LOWER CASE.
6$:	TST	(PC)+		; #RS# YES - SKIP NEXT INSTRUCTION.
7$:	CLR	R0		; #RS# FILL WITH ZERO'S.
	ASL	R1		; #RS# BUILD RAD51 WORD.
	ASL	R1		; #RS# ...<DITTO>...
	ASL	R1		; #RS# ...<DITTO>...
	ADD	R1,	R0	; #RS# ...<DITTO>...
	ASL	R1		; #RS# ...<DITTO>...
	ASL	R1		; #RS# ...<DITTO>...
	ADD	R0,	R1	; #RS# ...<DITTO>...
	ASL	R2		; #RS# DONE?
	BCC	3$		; #RS# NOT YET!
	BIS	#FLAG.T, FLGWRD	; #RS# INDICATE THAT A CHANGE MUST BE MADE.
	.TTYOUT	#')		; #RS# OUTPUT,...
	.TTYOUT	#SPACE		; #RS# ...TERMINAL DELIMITERS.
	MOV	(SP)+,	OPNADR	; #RS# RESTORE THE "OPNADR",...
	JMP	NEWCHA		; #RS# AND RETURN FOR A NEW CHARACTER.
8$:	JMP	MOWERR		; #RS# PRINT THE "MUST OPEN WORD" MESSAGE.
9$:	JMP	NAOERR		; #RS# PRINT THE "NO ADDRESS OPEN" MESSAGE.
CULINK	=	.
10$:	JSR	R1,	PRINTN	; #RS# PRINT THE,...
	.WORD	UPARRU		; #RS# ..."^U<CR><LF>"...
	JMP	NEWCU		; #RS# ... AND RETURN FOR A NEW LINE.

			.SBTTL	13.)	ROUTINE	"CHRSET".
			.CSECT	HGHSEG
;----------------------------------------------------------------------
;
;			ROUTINE	"CHRSET"
;
;		ROUTINE TO PROCESS THE "C" COMMAND.
;
;----------------------------------------------------------------------
CHRSET:	MOV	OPNADR,	-(SP)	; #RS# SAVE OPEN ADDRESS.
	BEQ	6$		; #RS# NOT OPEN - REPORT ERROR.
1$:	MOV	#1,	R2	; #RS# YES OPEN - SET COUNT FOR BYTES.
	TSTB	BYTFLG		; #RS# IS THE OPEN ADDRESS A BYTE?
	BNE	2$		; #RS# YES - DO FOR BYTES.
	INC	R2		; #RS# NO - INCREMENT COUNT FOR WORDS.
2$:	.TTYOUT	#SPACE		; #RS# PRINT OUT A SPACE,...
	.TTYOUT	#'(		; #RS# ...AND A DELIMITER.
3$:	DEC	R2		; #RS# COUNT CHARACTERS,...
	BMI	4$		; #RS# ...AND EXIT WHEN DONE.
	.TTYIN			; #RS# PICK UP A CHARACTER INTO R0.
	BIC	#-200,	R0	; #RS# NO - FORCE CHARACTER TO BE ASCII
	CMP	#CTRL.U, R0	; #RS# IS THE CHAR. A "<CTRL>U"?
	BEQ	CULINK		; #RS# YES - REPORT ERROR.
	CMP	#RUBOUT, R0	; #RS# NO - IS THE CHAR. A "RUBOUT"?
	BEQ	CULINK		; #RS# YES - REPORT ERROR.
	CMP	#SPACE,	R0	; #RS# IS THE CHARACTER A CONTROL CHAR., ETC.?
	BHI	7$		; #RS# YES - INDICATE UNACCEPTABLE ARGUMENT.
	BISB	R0,	R1	; #RS# NO - BUILD CHARACTER IN R1.
	ADD	R0,	TMPSUM	; #RS# ENSURE EACH CHARACTER IS ADDED TO "TMPSUM".
	ASL	TMPSUM		; #RS# DOUBLE IT FOR GREATER SAFETY.
	.TTYOUT			; #RS# ECHO THE CHARACTER.
	SWAB	R1		; #RS# EXCHANGE THE BYTES,...
	BR	3$		; #RS# ...AND GO BACK FOR NEXT.
4$:	TSTB	BYTFLG		; #RS# IS THE OPEN ADDRESS A BYTE?
	BEQ	5$		; #RS# YES - DO FOR WORDS.
	SWAB	R1		; #RS# NO - RE-ALIGN FOR BYTE VALUES.

5$:	.TTYOUT	#')		; #RS# PRINT OUT ANOTHER DELIMITER,...
	.TTYOUT	#SPACE		; #RS# ...AND A SPACE.
	BIS	#FLAG.T, FLGWRD	; #RS# INDICATE THAT A CHANGE MUST BE MADE.
	BR	8$		; #RS# THEN GET A NEW LINE.
6$:	JMP	NAOERR		; #RS# NO - REPORT ERROR.
7$:	JSR	R1,	PRINTN	; #RS# PRINT OUT THE,...
	.WORD	QM..CR		; #RS# ... "?<CR><LF>",...
8$:	MOV	(SP)+,	OPNADR	; #RS# RESTORE OPEN ADDRESS.
	JMP	NEWCHA		; #RS# ...AND JUMP TO "NEWCHA".

			.SBTTL	14.)	ROUTINE "SEARCH".
			.CSECT	HGHSEG
;----------------------------------------------------------------------
;
;			ROUTINE "SEARCH"
;
;		ROUTINE TO PROCESS THE "S" COMMAND
;
;
;----------------------------------------------------------------------
SEARCH:	JSR	PC,	CLOSE	; #RS# ENSURE THAT ANY OPEN LOCATION IS CLOSED.
	JSR	PC,	EOLOUT	; #RS# PRINT A "<CR><LF>",...
	BIS	#FLAG.S, FLGWRD	; #RS# INDICATE A SEARCH IS IN PROGRESS.
	MOV	RVAL,	R3	; #RS# GET SEARCH OBJECT.
	MOVB	R1,	BYTFLG	; #RS# WERE WORDS SPECIFIED?
	BEQ	1$		; #RS# YES - BYPASS FOR WORDS.
	MOVB	#1,	BYTFLG	; #RS# NO - INDICATE BYTES SOUGHT.
1$:	MOV	BOTTM,	R4	; #RS# GET LOW LIMIT OF FILE.
	MOV	HIGH,	-(SP)	; #RS# ASSUME FILE IS NOT OVERLAID.
	BIT	#FLAG.O, FLGWRD	; #RS# IS IT OVERLAID?
	BEQ	2$		; #RS# NO - BYPASS.
	MOV	@OVTAB,	(SP)	; #RS# YES - INSERT HIGH LIMIT OF ROOT.
2$:	MOV	(SP)+,	R5	; #RS# INSTALL PROPER HIGH LIMIT.
	MOV	R4,	R1	; #RS# SET START ADDRESS OF SEARCH.

3$:	MOV	R1,	OPNLOC	; #RS# SAVE ABSOLUTE ADDRESS OPEN.
	JSR	PC,	ADRLOC	; #RS# READ APPROPRIATE BLOCK AND RELOCATE ADDRESS.
	MOV	R2,	OPNADR	; #RS# SAVE RELATIVE ADDRESS OPEN.
	BIT	#FLAG.R, FLGWRD	; #RS# ADDRESS SEARCH?
	BEQ	10$		; #RS# NO - BYPASS.
	CMP	R1,	R3	; #RS# YES - EQUAL?
	BEQ	5$		; #RS# YES - GO PROCESS IT.
	BR	6$		; #RS# NO - CALCULATE NEXT ADDRESS.
10$:	TSTB	BYTFLG		; #RS# BYTES?
	BEQ	4$		; #RS# NO - DO WORDS.
	CMPB	(R2),	R3	; #RS# YES - BYTES MATCH?
	BNE	6$		; #RS# NO - CHECK NEXT.
	BR	5$		; #RS# YES - INDICATE THE SUCCESS.
4$:	CMP	(R2),	R3	; #RS# MATCH FOUND?
	BNE	6$		; #RS# NO - BYPASS.
5$:	BIS	#FLAG.U, FLGWRD	; #RS# YES - INDICATE MATCH FOUND.
	MOV	R1,	-(SP)	; #RS# SAVE R1 ACROSS SUBROUTINE,...
	MOV	R2,	-(SP)	; #RS# ...R2,...
	MOV	R3,	-(SP)	; #RS# ...R3,...
	MOV	R4,	-(SP)	; #RS# ...R4,...
	MOV	R5,	-(SP)	; #RS# ...AND R5 ALSO.
	JSR	PC,	PRTADR	; #RS# PRINT THE ADDRESS,...
	MOV	#'A,	R0	; #RS# ......PREPARE TO PRINT AN "A".
	.TTYOUT			; #RS# ......THEN PRINT IT.

	JSR	PC,	ASCOUT	; #RS# ......THEN EMPTY OUT THE CONTENTS IN DIFFERENT FORMATS.
	JSR	PC,	EOLOUT	; #RS# ...CONTENTS, AND A "<CR><LF>".
	MOV	(SP)+,	R5	; #RS# RESTORE R5,...
	MOV	(SP)+,	R4	; #RS# ...R4,...
	MOV	(SP)+,	R3	; #RS# ...R3,...
	MOV	(SP)+,	R2	; #RS# ...R2,...
	MOV	(SP)+,	R1	; #RS# ...AND R1.
6$:	INC	R1		; #RS# POINT TO NEXT BYTE,...
	TSTB	BYTFLG		; #RS# ...BYTES?,...
	BNE	7$		; #RS# ......YES - BYPASS.
	INC	R1		; #RS# .........NO - BUMP FOR WORDS.
7$:	CMP	R1,	R5	; #RS# POINTING BEYOND END OF FILE?
	BLO	3$		; #RS# NO - CHECK NEXT BYTE/WORD.
	BIT	#FLAG.O, FLGWRD	; #RS# IS IT AN OVERLAID FILE?
	BEQ	8$		; #RS# NO - BYPASS.
	INC	SEGMNT		; #RS# YES - INDICATE NEXT SEGMENT.
	MOV	SEGMNT,	R5	; #RS# GET THE SEGMENT NUMBER.
	CMP	R5,	NOSEG	; #RS# IS IT A LEGAL SEGMENT NUMBER?
	BHI	8$		; #RS# NO - CHECK MATCH SUCCESS FLAG.
	MOV	R5,	SEG	; #RS# YES - SAVE SEGMENT NUMBER IN "SEG".
	DEC	R5		; #RS# ADJUST FOR INDEXING INTO TABLE.
	ASL	R5		; #RS# CALCULATE PROPER,...
	MOV	R5,	-(SP)	; #RS# ...INDEX INTO,...

	ASL	R5		; #RS# ......THE OVERLAY,...
	ADD	(SP)+,	R5	; #RS# .........TABLES.
	ADD	OVTAB,	R5	; #RS# ADDRESS OVERLAY TABLES.
	MOV	(R5),	R4	; #RS# GET START ADDRESS OF OVERLAY IN R4.
	MOV	4(R5),	-(SP)	; #RS# GET BYTE SIZE OF OVERLAY IN R5.
	ADD	R4,	(SP)	; #RS# CALCULATE HIGH ADDRESS OF OVERLAY.
	BR	2$		; #RS# REPEAT UNTIL ALL OVERLAYS PROCESSED.
8$:	BIT	#FLAG.U, FLGWRD	; #RS# WAS ANY MATCH FOUND?
	BNE	9$		; #RS# YES - SKIP ERROR DIAGNOSTIC.
	JSR	R1,	PRINT	; #RS# NO - PRINT THE ,...
	.WORD	SRCHFL		; #RS# ..."SEARCH FAILURE FOR " MESSAGE.
	MOV	R3,	R0	; #RS# THEN SET IN THE SEARCH OBJECT,...
	JSR	PC,	TYPDGT	; #RS# ...THEN TYPE IT,...
	JSR	PC,	EOLOUT	; #RS# ......WITH A "<CR><LF>".
9$:	BIC	#<FLAG.S+FLAG.U+FLAG.R>, FLGWRD	; #RS# CLEAR ALL SEARCH FLAGS.
	CLR	OPNLOC		; #RS# CLEAR OUT OPEN...
	CLR	OPNADR		; #RS# ...ADDRESSES BEFORE RETURNING,...
	CLR	SEGMNT		; #RS# ......AND THE...
	CLR	SEG		; #RS# .........SEGMENT MARKERS.
	JMP	PROMPT		; #RS# THEN RETURN TO "PROMPT".
EOLOUT:	JSR	R1,	PRINTN	; #RS# PRINT A,...
	.WORD	CR..LF		; #RS# ..."<CR><LF>".
	RTS	PC		; #RS# AND RETURN TO CALLER.

			.SBTTL	15.)	ROUTINE "ADDRSS".
			.CSECT	HGHSEG
;----------------------------------------------------------------------
;
;			ROUTINE "ADDRSS"
;
;		ROUTINE TO PROCESS THE "W" COMMAND
;
;
;----------------------------------------------------------------------
ADDRSS:	BIS	#FLAG.R, FLGWRD	; #RS# SET THE ADDRESS SEARCH FLAG.
	BIT	#1,	RVAL	; #RS# IS THE DESIRED ADDRESS ODD?
	BEQ	1$		; #RS# NO - DON'T ALTER R1.
	MOV	#1,	R1	; #RS# YES - INDICATE A BYTE ADDRESS.
1$:	JMP	SEARCH		; #RS# THEN GO TO "SEARCH".

			.SBTTL	PROGRAM SUBROUTINES.
			.SBTTL	1.)	SUBROUTINE "ADRLOC".
			.CSECT	SUBSEG
;----------------------------------------------------------------------
; SUBROUTINE 'ADRLOC'	CALLED BY
;
;			JSR PC,	ADRLOC
;
;			R1 IS ABSOLUTE LOCATION WITHIN FILE
;
;			SEG IS THE SEGMENT NO. IF NOT ROOT SECTION.
;				(IGNORED FOR NO-OVERLAY FILES)
;				ADDRESSES THE SPECIFIED WORD OR BYTE
;				WITHIN THE FILE.
;
;			R2 IS SET TO ADDRESS IN DATA BUFFER
;
;			BLKNO IS BLOCK OF FILE
;
;----------------------------------------------------------------------
			.ENABL	LSB
ADRLOC:	MOV	R3,-(SP)	;SAVE R3 ON STACK.
	MOV	R1,-(SP)	;AND R1 ON STACK.
	CLR	-(SP)		;INIT START BLOCK NO.
	BIT	#FLAG.A, FLGWRD	; #RS# IS NON-FILE STRUCTURED MODE DESIRED?
	BNE	1$		; #RS# YES - BYPASS CHECK.
	CMP	R1,	HIGH	; #RS# NO - MAKE SURE ADDR IS IN PROGR BOUNDS.
	BHI	6$		; ### OUT OF BOUNDS=> PRINT "NOT IN PROGRAM BOUNDS" MESSAGE.
1$:	BIT	#FLAG.M, FLGWRD	; #RS# CHECK SPECIAL 'MONITOR FILE' FLAG.
	BEQ	2$		; #RS# NO - BRANCH.
	CMP	R1,	(PC)+	; #RS# YES - CHECK ADDRESS LIMITS FOR A MONITOR FILE.
RTBOOT:	.WORD	BOOTSZ		; #RS# PATCHABLE FOR VARIABLE BOOT SIZES.
	BLO	2$		; ### SKIP THE ADD,...
	ADD	RTBOOT,	R1	; ### OTHERWISE SKIP OVER THE BOOT,...
	ADD	(PC)+,	R1	; ### ...AND SKIP OVER THE SWAP BLOCKS.
SWPBAS:	.WORD	0		; #RS# VARIABLE SWAPBLK SIZE FOR V03.
2$:	BIT	#FLAG.O, FLGWRD	; #RS# IS THIS AN OVERLAY FILE?
	BEQ	4$		; #RS# NO, BYPASS
	MOV	SEG,	R3	;YES, CHECK SEGMENT SPECIFIED
	BNE	3$		;YES, GO LOOK IT UP
	BIT	#FLAG.I, FLGWRD	; ### HAS THE "INIT" BEEN DONE?
	BEQ	4$		; ### NO - BYPASS CHECKS.
	TST	NOSEG		;MAKE SURE THERE ARE SEGMENTS
	BEQ	7$		; ### IF NO SEGMENTS, BRANCH.
	CMP	R1,	@OVTAB	;CHECK ADDRESS IN ROOT SEGMENT.
	BHIS	8$		; ### OUT OF BOUNDS, => PRINT "MUST SPECIFY SEGMENT NO." MESSAGE.
	BR	4$		; ### IN RANGE, => GO DO IT.
3$:	CMP	R3,	NOSEG	;CHECK VALID SEGMENT NO.
	BHI	9$		; ### MORE SEG.S THAN EXIST => PRINT...
				; ### ..."INVALID SEGMENT NO." MESSAGE.
	DEC	R3		; ### COMPUTE...
	ASL	R3		; ### ...INDEX TO...
	MOV	R3,	-(SP)	; ### ......TABLE...
	ASL	R3		; ### .........ENTRY...
	ADD	(SP)+,	R3	; ### ...<DITTO>...
	ADD	OVTAB,	R3	;ADDRESS TABLE ENTRY.
	SUB	(R3)+,	R1	;COMPUTE REL ADDRESS IN SEGMENT.
	MOV	(R3)+,	(SP)	;GET START BLOCK NO..

	CMP	R1,	(R3)	;CHECK ADDRESS WITHIN SEGMENT.
	BHI	10$		; ### OUT OF BOUNDS => PRINT...
				; ### ..."ADDR NOT IN SEG" MESSAGE.
4$:	MOV	R1,	R2	; ### COPY LEGAL ADDRESS INTO R2.
	BIC	#-1000,	R2	;R2 IS OFFSET WITHIN BLOCK.
	MOV	R1,	-(SP)	;DIVIDE FILE ADDRESS BY 1000.
	CLC			; ### CLEAR "C" BIT FOR CALCULATION.
	ROR	(SP)		; ### DIVIDE BY TWO(8)...
	CLRB	(SP)		; ### ...CLEAR LOW ORDER BYTE...
	SWAB	(SP)		; ### ...AND DIVIDE BY ANOTHER 400(8).
	ADD	(SP)+,	(SP)	;COMPUTE ACTUAL BLOCK NO.
	MOV	(SP)+,	R3	; ### PUT IT INTO R3.
	CMP	R3,	BLKNO	;IS IT THE SAME ALREADY READ IN.
	BEQ	5$		;YES, BYPASS READ.
	MOV	R3,	BLKNO	; ### SAVE THE ACTUAL BLOCK NUMBER FOR NEXT TIME.
	.READW	#EMTBLK,#3,#BLOCK,#256.,BLKNO	; ### READ THE BLOCK.
	BCS	12$		; ### ERROR => PRINT THE "READ ERROR" MESSAGE.
5$:	ADD	#BLOCK,	R2	;ADDRESS BUFFER LOC.
	MOV	(SP)+,	R1	;RESTORE R1.
	MOV	(SP)+,	R3	;AND R3.
	RTS	PC		; ### RETURN TO CALLER.
6$:	JSR	R1,	PRINT	; ### PRINT THE ...
	.WORD	BOUNDS		; ### ..."NOT IN PROGR BOUNDS" MESSAGE.
	BR	11$		; ### ... AND GO TO "PROMPT".
7$:	JSR	R1,	PRINT	; ### PRINT THE...
	.WORD	NOSEGS		; ### ..."PROGR HAS NO SEGS" MESSAGE,...
	BR	11$		; ### ... AND GO TO "PROMPT".
8$:	JSR	R1,	PRINT	; ### PRINT THE ...
	.WORD	GIVSEG		; ### ..."MUST SPECIFY SEG" MESSAGE,...
	BR	11$		; ### ...AND GO TO "PROMPT".
9$:	JSR	R1,	PRINT	; ### PRINT THE ...
	.WORD	INVSEG		; ### ..."INVALID SEG NO" MESSAGE,...
	BR	11$		; ### ...AN GO TO "PROMPT".
10$:	JSR	R1,	PRINT	; ### PRINT THE ...
	.WORD	SEGADR		; ### ..."ADDR NOT IN SEG" MESSAGE,...
11$:	JMP	PROMPT		; ### ...AND GO TO "PROMPT".
12$:	JSR	R1,	PRINT	; ### PRINT THE ...
	.WORD	READER		; ### ..."READ ERROR" MESSAGE,...
	JMP	FTLXIT		; ### ...AND JUMP BACK TO THE "CSI".
		.DSABL	LSB

			.SBTTL	2.)	SUBROUTINE "CLOSE"
			.CSECT	SUBSEG
;----------------------------------------------------------------------
; SUBROUTINE 'CLOSE'	CALLED BY
;
;			JSR PC,	CLOSE
;
;
;			CLOSES THE OPEN LOCATION OR BYTE,
;			WRITING OUT THE MODIFIED BLOCK
;			ON THE FILE.
;
;
;----------------------------------------------------------------------
CLOSE:	TST	OPNADR		; #RS# ANY ADDRESS OPEN?
	BEQ	2$		;NO, EXIT
	BIT	#FLAG.T, FLGWRD	;WAS ANYTHING TYPED?
	BEQ	2$		; #RS# NO - CLEAR OUT OPEN ADDRESS AND RETURN.
	MOV	RCON,	R2
	ADD	RC(R2),	R1	;RELOCATE VALUE STORED
	TSTB	BYTFLG		;IS THE OPEN LOCATION A BYTE
	BNE	3$
	MOV	R1,	@OPNADR	;STORE VALUE IN BUFFER
1$:	.WRITW	#EMTBLK,#3,#BLOCK,#256.,BLKNO
	BCS	4$		; ### ON WRITE ERROR,...
	BIS	#FLAG.W, FLGWRD	; #RS# SET THE "FILE MODIFIED" FLAG.
	ASL	CHKSUM		; #RS# SHIFT IT,...
	ADC	CHKSUM		; #RS# ADD IN CARRY TO PRESERVE UNIQUENESS.
	ADD	TMPSUM, CHKSUM	; #RS# ...ADD IN THE CHECKSUM AT THE END OF EACH LINE,...
2$:	CLR	OPNADR		; ### INDICATE NO ADDRESS OPEN,...
	RTS	PC		; ### ... AND RETURN TO CALLER.
3$:	MOVB	R1,	@OPNADR	;SET BYTE VALUE IN BUFFER.
	BR	1$		; ### I... AND GO WRITE OUT THE BUFFER.
4$:	JSR	R1,	PRINT	; #RS# NO - PRINT THE ...
	.WORD	WRTERR		; ### ..."WRITE ERROR" MESSAGE,...
	JMP	FTLXIT		; ### ...AND GO REQUEST ANOTHER FILE-SPECIFICATION.



			.SBTTL	3.)	SUBROUTINE "CONT".
			.CSECT	SUBSEG
;----------------------------------------------------------------------
; SUBROUTINE 'CONT'	CALLED BY
;
;			JSR PC,	CONT
;
;
;			TYPES THE CONTENTS OF THE OPEN LOCATION
;
;
;----------------------------------------------------------------------
CONT:	.TTYOUT	#HT		; ### PRINT THE ...
				; ### ..."<TAB>" CHARACTER.
	TSTB	BYTFLG		; ### IS IT A BYTE OPEN?
	BEQ	1$		; ### NO - GO DO WORDS.
	CLR	R0		; #RS# ENSURE THAT HIGH BYTE IS ZERO.
	BISB	@OPNADR, R0	; ### YES - SET UP BYTE...
	BR	2$		; #RS# ... THEN DO THE COMMON CODE.
1$:	MOV	@OPNADR, R0	; ### NO - SET UP WORD THEN.
2$:	TSTB	FLPFLP		; #RS# OLD CONTENTS REQUIRED?
	BEQ	3$		; #RS# NO - JUST CONTINE AS USUAL.
	ADD	R0, TMPSUM	; #RS# ADD IN THE VALUE TO "TMPSUM",...
	ASL	TMPSUM		; #RS# ...SHIFT IT TO ENHANCE SECURITY.
3$:	JSR	PC,	TYPDGT	; ### TYPE OUT THE CONTENTS OF A WORD.
4$:	.TTYOUT	#HT		; ### PRINT ANOTHER...
				; ### ..."<TAB>" CHARACTER,...
	RTS	PC		; ### ... AND RETURN TO CALLER.

			.SBTTL	4.)	SUBROUTINE "INITOV".
			.CSECT	SUBSEG
;----------------------------------------------------------------------
; SUBROUTINE 'INITOV'	CALLED BY
;
;			JSR PC,	INITOV
;
;
;			INITIALIZES THE OVERLAY TABLE
;			IF FLAG.I CLEAR, SETS FLAG.I
;			RESTORES ALL REGISTERS
;
;
;----------------------------------------------------------------------
INITOV:	BIT	#FLAG.I, FLGWRD	; ### HAS THE "INIT" BEEN DONE?
	BEQ	2$		; ### NO - GO DO IT.
1$:	RTS	PC		; ### YES - RETURN IMMEDIATELY.
2$:	JSR	R5,	SAVREG	; ### SAVE ALL REGISTERS.
	MOV	#-1,	HIGH	;(INIT HIGH LOCATION)
	BIT	#FLAG.M, FLGWRD	; ### MONITOR FILE?
	BNE	3$		; ### YES - BYPASS.
	BIT	#FLAG.A, FLGWRD	; #RS# IS ABSOLUTE MODE REQUIRED?
	BNE	3$		; #RS# YES - BYPASS.
	MOV	#HLIMIT, R1	; #RS# NO - READ HIGH LIMIT OF PROGRAM
	JSR	PC,	ADRLOC	; ### RELOCATE HIGH LIMIT,...
	MOV	(R2),	HIGH	; ### ... AND SAVE IT IN HIGH.
3$:	BIT	#FLAG.O, FLGWRD	; ### OVERLAY FILE?
	BEQ	1$		; ### NO - DONE.
	CLR	NOSEG		; ### YES - FORGET OVERLAYS
	TST	BOTTM		;CHECK BOTTOM ADDRESS SPECIFIED
	BNE	4$		;YES, USE IT
	MOV	#STKPTR, R1	; #RS# NO - READ INIT STACK POINTER
	JSR	PC,	ADRLOC
	MOV	(R2),	BOTTM	;SAVE BOTTOM ADDRESS
4$:	BIT	#1,	BOTTM	;CHECK BOTTOM ADDRESS IS EVEN
	BNE	9$
	MOV	#20.,	R4	;NUMBER OF WORDS CHECKED IN OVERLAY HANDLER
	MOV	#$OVRH,	R3	;ADDRESS MODEL
	MOV	BOTTM,	R1
	MOV	#$OVTAB, R0	;RELOCATE MODEL OVERLAY HANDLER
	SUB	R3,	R0
	ADD	R1,	R0
	SUB	#6,	R0
	MOV	R0,	$OVRHA+2
5$:	JSR	PC,	ADRLOC	; +++ MAKES SURE THE OVERLAY++++
	CMP	(R2),	(R3)+	; +++ HANDLER IS STORED AT THE++
	BNE	10$		; +++ BOTTOM ADDRESS.+++++++++++
	TST	(R1)+
	DEC	R4
	BNE	5$
6$:	MOV	OVTAB,	R3	;INIT TO SAVE OVERLAY TABLE
	MOV	BOTTM,	R1
	ADD	#OVHSIZ, R1	; ### POINT TO THE OVERLAY TABLES.

7$:	JSR	PC,	ADRLOC	;ADDRESS NEXT SEGMENT TABLE ENTRY
	BIT	#1,	(R2)	;IS IT ODD ?
	BNE	8$		;YES,	 DONE
	CMP	R3,	OVTABE	;ENOUGH ROOM TO STORE IT?
	BHIS	11$
	MOV	(R2),	(R3)+	;SAVE FIRST WORD
	TST	(R1)+		; #RS# POINT TO NEXT ENTRY.
	JSR	PC,	ADRLOC	;ADDRESS NEXT
	MOV	(R2),	(R3)+	;SAVE 2ND WORD
	ADD	#2,	R1
	JSR	PC,	ADRLOC	;ADDRESS NEXT
	MOV	(R2),	(R3)	;SAVE 3RD WORD
	CLC			;COMPUTE BYTES FROM WORDS
	ROL	(R3)
	DEC	(R3)+
	ADD	#2,	R1	;MOVE TO NEXT ENTRY
	INC	NOSEG		;COUNT SEGMENTS
	BR	7$		;LOOP FOR ALL SEGMENTS
8$:	BIS	#FLAG.I, FLGWRD	; ### INDICATE FILE NOT "INIT.'ED".
	RTS	PC		;RESTORE REGS AND RETURN
9$:	JSR	R1,	PRINT	; ### PRINT THE...
	.WORD	ODDBTM		; ### ..."ODD BOTTOM ADDRESS" MESSAGE,...
	BR	13$		; ### ...THEN START A NEW LINE.
10$:	JSR	R1,	PRINT	; ### PRINT THE...
	.WORD	BADBTM		; ### ..."BOTTOM ADDRESS WRONG" MESSAGE,...
	BR	13$		; ### ...THEN START A NEW LINE.
11$:	BIT	#FLAG.P, FLGWRD	; #RS# IS THIS A SECOND PASS?
	BNE	12$		; #RS# YES - NO MORE ROOM, REPORT ERROR.
	MOV	R0,	-(SP)	; #RS# NO - FIRST SAVE R0,...
	JSR	R1,	PRINT	; #RS# ...TELL HIM WE'RE GOING,...
	.WORD	EXCORE		; #RS# ......TO ASK FOR MORE CORE;...
	MOV	#-2,	R0	; #RS# .........THEN ASK FOR...
	.SETTOP			; #RS# ............ALL THAT WE CAN GET!

	MOV	R0,	OVTABE	; #RS# RESET THE END OF THE OVERLAY TABLES.
	MOV	(SP)+,	R0	; #RS# ...THEN RESTORE R0,...
	BIS	#FLAG.P, FLGWRD	; #RS# INDICATE WE HAVE ALL THE CORE WE CAN GET.
	BR	7$		; #RS# THEN RETRY THE LAST OPERATION.
12$:	JMP	NOMEM		; ### ...THEN EXIT TO RT-11 MONITOR.
13$:	JMP	PROMPT		; ### RETURN TO START A NEW LINE.

			.SBTTL	5.)	SUBROUTINES "ERROR", "PRINT" AND "PRINTN".
			.CSECT	SUBSEG
;----------------------------------------------------------------------
; SUBROUTINE "ERROR"	CALLED BY
;
;			JSR	R1,	ERROR
;			.WORD	MSGADR
;
;			PRINTS THE MESSAGE AT "MSGADR"
;			IN THE RT-11 V03 ERROR FORMAT, NO OTHER
;			ACTION IS TAKEN.
;
;----------------------------------------------------------------------
ERROR:				; #RS# "ERROR" IS A "NOP" FOR THIS VERSION.
;----------------------------------------------------------------------
; SUBROUTINES 'PRINT' AND 'PRINTN'
;
;			CALLED BY
;
;			JSR	R1,	PRINT(N)
;			.WORD	MSGADR
;
;			IF CALLED AT "PRINT"
;			PRINTS THE ASCII MESSAGE AT "MSGADR"
;
;			IF CALLED AT "PRINTN"
;			PRINTS THE ASCII MESSAGE AT "MSGADR",
;			PRECEEDED BY THE RT-11 V03 STANDARD
;			MESSAGE HEADER.
;----------------------------------------------------------------------
PRINT:	JSR	R1,	1$	; #RS# PRINT OUT THE RT-11,...
	.WORD	ERRFMT		; ...ERROR HEADER.
1$:
PRINTN:	MOV	(R1)+,	R0	; #RS# ADD IN THE INDEX TO THE MESSAGE,...
	.PRINT			; #RS# ...PRINT IT,...
	RTS	R1		; ### ... AND RETURN TO CALLER.



			.SBTTL	6.)	SUBROUTINES "SAVREG", AND "RESREG".
			.CSECT	SUBSEG
;----------------------------------------------------------------------
; SUBROUTINE 'SAVREG'	CALLED BY
;
;			JSR R5,	SAVREG
;
;
;			SAVES ALL REGISTERS ON THE STACK,
;			AND RESTORES THEM WHEN THE NEXT
;			'RTS PC' INSTRUCTION IS EXECUTED.
;
;
;----------------------------------------------------------------------
SAVREG:	MOV	R4,	-(SP)	; ### SAVE...
	MOV	R3,	-(SP)	; ### ...ALL...
	MOV	R2,	-(SP)	; ### ......THE...
	MOV	R1,	-(SP)	; ### .........GENERAL...
	MOV	R0,	-(SP)	; ### ............PURPOSE...
	MOV	R5,	-(SP)	; ### ...............REGISTERS...
	MOV	12.(SP), R5	; ### ...RESTORE R5...
	JSR	PC,	@(SP)+	; ### ...DISPATCH TO THE CO-ROUTINE...
RESREG:	MOV	(SP)+,	R0	; ### ................RESTORE...
	MOV	(SP)+,	R1	; ### ............ALL...
	MOV	(SP)+,	R2	; ### .........THE...
	MOV	(SP)+,	R3	; ### ......GENERAL...
	MOV	(SP)+,	R4	; ### ...PURPOSE...
	MOV	(SP)+,	R5	; ### REGISTERS...
	RTS	PC		; ### ...AND RETURN TO THE CALLER.

			.SBTTL	7.)	SUBROUTINE "TYPDGT".
			.CSECT	SUBSEG
;----------------------------------------------------------------------
; SUBROUTINE 'TYPDGT'.
;
;			CALLED BY
;
;			JSR PC,	TYPDGT
;
;
;			R0 CONTAINS VALUE TO BE TYPED.
;
;			TYPE OUT THE CONTENTS OF THE
;			BYTE, WORD, RESPECTIVELY, IN R0.
;			RESTORES ALL REGISTERS
;
;
;----------------------------------------------------------------------
			.ENABL	LSB
TYPDGT:	JSR	R5,	SAVREG	; ### SAVE ALL THE REGISTERS.
	CLR	-(SP)		; #RS# MARK END OF STRING.
1$:	MOV	R0,	-(SP)	; ### COPY WORD ONTO STACK.
	BIC	#-10,	(SP)	; #RS# ISOLATE NEXT DIGIT.
	ADD	#'0,	(SP)	; #RS# "'ASCII'IZE" THE DIGIT.
	ROR	R0		; ### EFFECTIVELY,...
	ASR	R0		; ### ...DIVIDE BY ...
	ASR	R0		; ### ...10(8)...
	BNE	1$		; #RS# REPEAT UNTIL DONE.
2$:	MOV	(SP)+,	R0	;GET NEXT DIGIT.
	BEQ	3$		; ### NOT DONE => RETURN FOR THE NEXT ONE.
	.TTYOUT			;TYPE IT.
	BR	2$		; #RS# GET ANOTHER DIGIT.
3$:	RTS	PC		; ### OTHERWISE, RETURN TO CALLER.

			.DSABL	LSB

			.SBTTL	8.)	SUBROUTINE "R50ASC".
			.CSECT	SUBSEG
;----------------------------------------------------------------------
;
;
;			ROUTINE	"R50ASC".
;
;	SUBROUTINE TO CONVERT THE THE CONTENTS OF THE OPEN WORD
;			FROM RAD50 TO ASCII.
;
;
;
;----------------------------------------------------------------------
R50ASC:	JSR	R5,	SAVREG	; #P00007# SAVE ALL THE REGISTERS.
	MOV	#3,	R1	; #P00007# SET UP TO CONVERT ONE WORD ONLY.
1$:	MOV	DIVTBL, R3	; #P00007# R3-> DIVISION TABLE.
	MOV	@OPNADR, R2	; #P00007# R2 = CURRENT INPUT WORD.
2$:	TST	-(R3)		; #P00007# NEW WORD REQUIRED YET?
	BEQ	1$		; #P00007# YES
	MOV	#-1,	R0	; #P00007# NO - INIT QUOTIENT REGISTER.
	CMP	#174777, R2	; #P00007# RAD50 VALUE TOO LARGE.
	BLO	4$		; #P00007# YES - OUTPUT "???".
3$:	INC	R0		; #P00007# NO - DIVIDE BY POWER OF 50(8)N
	SUB	(R3),	R2	; #P00007# ..."...
	BCC	3$		; #P00007# ..."...
	ADD	(R3),	R2	; #P00007# RESTORE DIVIDEND.
	TST	R0		; #P00007# IS THE CHARACTER A BLANK?
	BEQ	5$		; #P00007# YES - GO DO IT.
	CMP	#35,	R0	; #RS# NO - IS IT THE UNUSED CODE?
	BNE	9$		; #RS# NO - CHECK OTHERS.
	MOV	#-1,	R0	; #RS# YES - INITIALISE R0 FOR IT.
	BR	4$		; #RS# THEN GO FINISH IT.
9$:	CMP	#33,	R0	; #P00007# IS IT A "$", A ".", OR A DIGIT?
	BLO	6$		; #P00007# IT IS A ".", OR A DIGIT.
	BEQ	7$		; #P00007# IT IS A "$".
4$:	ADD	#40,	R0	; #P00007# OTHERWISE IT'S AN ALPHABETIC OR A "?".
5$:	ADD	#16,	R0	; #P00007# ..."...
6$:	ADD	#11,	R0	; #P00007# ..."...
7$:	ADD	#11,	R0	; #P00007# ..."...
8$:	.TTYOUT			; #P00007# PRINT THE CHARACTER.
	DEC	R1		; #P00007# ANY MORE TO DO?
	BNE	2$		; #P00007# YES - CONTINUE.
	RTS	PC		; #P00007# RETURN TO CALLER.

			.SBTTL	PROGRAM DATA AREAS.
			.SBTTL	1.)	OVERLAY HANDLER MODEL.
			.CSECT DATSEG
;----------------------------------------------------------------------
;
;
;		MODEL OVERLAY HANDLER
;
;
;----------------------------------------------------------------------
$OVRH:	MOV	R0,	-(SP)		; ### SAVE...
	MOV	R1,	-(SP)		; ### ...SOME...
	MOV	R2,	-(SP)		; ### ......REGISTERS.
$OVRHB:	BR	$FIRST			; *** #RS# NON-REENTRANT CODE.***
	MOV	R0,	R1		; ### SAVE OVERLAY NUMBER.
$OVRHA:	ADD	#$OVTAB-6, R1		; ### CALCULATE TABLE ADDRESS.
	MOV	(R1)+,	R2		; ### GET CORE ADDRESS OF OVERLAY REGION. 
	CMP	R0,	(R2)		; ### IS OVERLAY ALREADY RESIDENT?
	BEQ	$ENTER			; ### YES - BRANCH TO IT.
					; ### NO - READ IT IN FROM OVERLAY FILE.
	MOV	(R1)+,	R0		; #RS# EMULATE ..V1.. ".READW" EMT.
	CLR	-(SP)			; #RS# <DITTO>.
	MOV	(R1)+,	-(SP)		; #RS# <DITTO>
	MOV	R2,	-(SP)		; #RS# <DITTO>
	EMT	^O<200+17>		; #RS# END ..V1.. ".READW" EMULATION.
	BCS	$ERR			; ### ERROR? - REPORT IF SO.
$ENTER:	MOV	(SP)+,	R2		; ### .........RESTORE...
	MOV	(SP)+,	R1		; ### ......SAVED...
	MOV	(SP)+,	R0		; ### ...REGISTERS,...
	MOV	(R5),	R5		; ### ...AND...
	RTS	R5			; ### ...RETURN TO CALLER.
$FIRST:	MOV	#12500,	$OVRHB		; ### *** START NON-RENTRANT INSTRUCTION ***
;	MOV	(R5)+,	R0		; #RS# *** THIS IS INSTRUCTION THAT REPLACES THE "BR" ***.
	MOV	(PC)+,	R1		; ### LOAD START ADDRESS FOR CLEAR INSTRUCTION.
$HROOT:	.WORD	0			; ### ...I.E. HIGH ADDRESS OF ROOT SEGMENT.
	MOV	(PC)+,	R2		; ### LOAD COUNT FOR CLEAR OPERATION.
$HOVLY:	.WORD	0			; ### WORD COUNT SAVED HERE.
1$:	CLR	(R1)+			; ### START TO CLEAR,...
	CMP	R1,	R2		; ### ... AND CONTINUE,...
	BLO	1$			; ### ...... UNTIL DONE,...
	BR	$OVRHB			; ### ...THEN RETURN TO CALL IN PROGRESS.
$ERR:	EMT	376			; ### SYSTEM ERROR 10, "OVERLAY I/O ERROR EMT".
	.BYTE	0,	373		; ### EMT CODE.
$OVRHE:
$OVTAB:
	OVHSIZ	=	$OVRHE	-	$OVRH
;----------------------------------------------------------------------
;		OVERLAY SEGMENT TABLE STRUCTURE.
;	$OVTAB:	.WORD	<CORE ADDR.>
;		.WORD	<RELATIVE BLOCK NUMBER.>
;		.WORD	<WORD COUNT OF OVERLAY.>
;
;		THERE IS AN ADDITIONAL WORD PREFIXED TO EACH
;		OVERLAY REGION THAT IDENTIFYIES THE SEGMENT
;		CURRENTLY RESIDENT IN THAT REGION.
;		THIS WORD IS AN INDEX INTO THE "$OVTAB" TABLE.
;----------------------------------------------------------------------

			.SBTTL	2.)	PROGRAM VARIABLES AND FLAGS.
			.CSECT	DATSEG
;----------------------------------------------------------------------
;
;
;		VARIABLES AND FLAGS
;
;
;----------------------------------------------------------------------
RVAL:	.WORD	0	;VALUE OF 1ST ARG
HIGH:	.WORD	0	;HIGH LIMIT OF PROGRAM
SEGMNT:	.WORD	0	;SEGMENT NO. SPECIFIED
BOTTM:	.WORD	0	;BOTTOM ADDRESS
RCON:	.WORD	0	;RELOCATION CONSTANT
OPNLOC:	.WORD	0	;ADDRESS OF OPEN WORD OR BYTE
SEG:	.WORD	0	;SEGMENT FOR ADDRESSING FILE
BLKNO:	.WORD	0	;BLOCK NO. CURRENTLY IN CORE
NOSEG:	.WORD	0	;NO. OF SEGMENTS ON FILE
OVTAB:	.WORD	0	;START OF OVERLAY TABLE
OVTABE:	.WORD	0	;HIGHES WORD AVAILABLE FOR OVERLAY TABLE
OPNADR:	.WORD	0	;ADDRESS OF OPEN LOC IN BUFFER
FLGWRD:	.WORD	0	; #RS# THE FLAG WORD, FOR SWITCHES AND FLAGS.
TMPSUM:	.WORD	0	; #RS# TEMPORARY CHECKSUM GOES HERE.
CHKSUM:	.WORD	0	; #RS# CHECKSUM GOES HERE.
RC:	.WORD	0
	.WORD	0,0,0
	.WORD	0,0,0
	.WORD	0,0
	.WORD	0	; #P00007# END OF DIVISOR TABLE FLAG.
	.WORD	1	; #P00007# [40(10)]**0
	.WORD	50*1	; #P00007# [40(10)]**1
	.WORD	50*50	; #P00007# [40(10)]**2
DIVTBL:	.WORD	DIVTBL	; #P00007# RAD50 DIVISOR TABLE.
DEFEXT:	.RAD50	'SAV'	;DEFAULT FILE EXTENSION
MSGPTR:	.WORD	MSGTBL	; #RS# POINTER TO MESSAGE TABLES.
LOWLIM:	.LIMIT		; #RS# INSERT PROGRAM LIMITS HERE.
			.NLIST
	.=.-2
			.LIST
HGHLIM:
			.NLIST
	.=.+2
			.LIST
;----------------------------------------------------------------------
;
;
;			(BYTE VARIABLES)
;
;
;----------------------------------------------------------------------
BYTFLG:	.BYTE	0	;SET IF BYTE IS OPEN
FLPFLP:	.BYTE	0	; #RS# FLIP-FLOP FOR THE "&" COMMAND,
			.EVEN

			.SBTTL	PROGRAM MESSAGE TABLES.
			.CSECT	MSGSEG
;----------------------------------------------------------------------
;
;
;		PRINT MESSAGES
;
;
;----------------------------------------------------------------------
			.ENABL	LC
			.NLIST	BEX
MSGTBL:
PATCHV:	.ASCIZ	<15><12>/PATCH V02.01/<40><40><40><15><12>
			.EVEN
PATLVL	=	.-5
LVLEXT	=	.-4
FILNAM:	.ASCIZ	<15><12>/FILE NAME--/
			.EVEN
ERRFMT:	.ASCIZ	<15><15><12>/?PATCH-/<200>
			.EVEN
NOADDR:	.ASCIZ	/W-No address open/
			.EVEN
OPNWRD:	.ASCIZ	/W-Must open word/
			.EVEN
ODDADR:	.ASCIZ	/W-Odd address/
			.EVEN
INVREL:	.ASCIZ	/W-Invalid relocation register/
			.EVEN

BADFIL:	.ASCIZ	/W-Illegal command/
			.EVEN
SWTERR:	.ASCIZ	/W-Illegal option/
			.EVEN
BOUNDS:	.ASCIZ	/W-Not in program bounds/
			.EVEN
NOSEGS:	.ASCIZ	/W-Program has no segments/
			.EVEN
GIVSEG:	.ASCIZ	/W-Must specify segment number/
			.EVEN
INVSEG:	.ASCIZ	/W-Invalid segment number/
			.EVEN
SEGADR:	.ASCIZ	/W-Address not in segment/
			.EVEN
READER:	.ASCIZ	/F-Read error/
			.EVEN
WRTERR:	.ASCIZ	/F-Write error/
			.EVEN
ODDBTM:	.ASCIZ	/W-Odd bottom address/
			.EVEN

BADBTM:	.ASCIZ	/W-Bottom address wrong/
			.EVEN
NOCORE:	.ASCIZ	/F-Insufficient memory/
			.EVEN
ECSMSG:	.ASCIZ	<15><12>/Checksum?   /<200>
			.EVEN
CSEMSG:	.ASCIZ	/I-Checksum  =  /<200>
			.EVEN
CKSERR:	.ASCIZ	/I-Checksum error/
			.EVEN
INVOVS:	.ASCIZ	/W-Invalid overlay handler modification/
			.EVEN
CR..QM:	.ASCIZ	<15><12>/?/<200>
			.EVEN
QM..CR:	.ASCIZ	/?/
			.EVEN
CR..LF:	.ASCIZ	//

			.EVEN
UPARRU:	.ASCIZ	/^U/
			.EVEN
SPEQSP:	.ASCIZ	/ = /<200>
			.EVEN
FSLBSL:	.ASCIZ	'/\'
			.EVEN
EXCORE:	.ASCIZ	/I-[+2K Core]/
			.EVEN
SRCHFL:	.ASCII	/W-Search failure for /<200>
			.EVEN
NOTFND:	.ASCIZ	/W-Address not within program bounds/
			.LIST	BEX
			.DSABL	LC

			.SBTTL	PROGRAM COMMAND TABLE.
			.CSECT	TBLSEG
;----------------------------------------------------------------------
;
;
;			TABLE OF COMMANDS
;
;
;----------------------------------------------------------------------
COMTAB:	.ASCII	' ;/\@^BRFE,:&OAXCPSW'
	.BYTE	LF,CR
NOCOM	=.-COMTAB			;NO. OF COMMANDS IN TABLE
	.EVEN

			.SBTTL	PROGRAM DISPATCH TABLE.
			.CSECT	TBLSEG
;----------------------------------------------------------------------
;
;
;			DISPATCH TABLE
;
;
;----------------------------------------------------------------------
BRTAB:	.WORD	NEWCHA		; ### ADDRESS OF THE ROUTINE TO PROCESS INPUT CHARACTERS.
	.WORD	SEMI		; ### ADDRESS OF THE ROUTINE TO PROCESS THE ";" COMMAND.
	.WORD	SLASH		; ### ADDRESS OF THE ROUTINE TO PROCESS THE "/" COMMAND.
	.WORD	BSLASH		; ### ADDRESS OF THE ROUTINE TO PROCESS THE "\" COMMAND.
	.WORD	ATSIGN		; ### ADDRESS OF THE ROUTINE TO PROCESS THE "@" COMMAND.
	.WORD	UPARRO		; ### ADDRESS OF THE ROUTINE TO PROCESS THE "^" COMMAND.
	.WORD	BSET		; ### ADDRESS OF THE ROUTINE TO PROCESS THE "B" COMMAND.
	.WORD	RSET		; ### ADDRESS OF THE ROUTINE TO PROCESS THE "R" COMMAND.
	.WORD	GETFIL		; ### ADDRESS OF THE ROUTINE TO PROCESS THE "F" COMMAND.
	.WORD	EXIT		; ### ADDRESS OF THE ROUTINE TO PROCESS THE "E" COMMAND.
	.WORD	RELOC		; ### ADDRESS OF THE ROUTINE TO PROCESS THE "," COMMAND.
	.WORD	COLON		; ### ADDRESS OF THE ROUTINE TO PROCESS THE ":" COMMAND.
	.WORD	ADDOLD		; ### ADDRESS OF THE ROUTINE TO PROCESS THE "&" COMMAND.
	.WORD	SETOVL		; ### ADDRESS OF THE ROUTINE TO PROCESS THE "O" COMMAND.
	.WORD	ASCOUT		; ### ADDRESS OF THE ROUTINE TO PROCESS THE "A" COMMAND.
	.WORD	R50CVT		; ### ADDRESS OF THE ROUTINE TO PROCESS THE "X" COMMAND.
	.WORD	CHRSET		; ### ADDRESS OF THE ROUTINE TO PROCESS THE "C" COMMAND.
	.WORD	PACK50		; ### ADDRESS OF THE ROUTINE TO PROCESS THE "P" COMMAND.
	.WORD	SEARCH		; ### ADDRESS OF THE ROUTINE TO PROCESS THE "S" COMMAND.
	.WORD	ADDRSS		; ### ADDRESS OF THE ROUTINE TO PROCESS THE "W" COMMAND.
	.WORD	LFEED		; ### ADDRESS OF THE ROUTINE TO PROCESS THE "<LF>" COMMAND.
	.WORD	CARRET		; ### ADDRESS OF THE ROUTINE TO PROCESS THE "<CR>" COMMAND.

			.SBTTL	PROGRAM CORE UTILISATION.
			.CSECT	LOWSEG
;----------------------------------------------------------------------
;
;
;			FILE I/O BUFFER  (1 BLOCK)
;
;
;----------------------------------------------------------------------
BLOCK:
	.REPT	BLKSIZ		; #RS# 256(10) WORDS, 1000(8) BYTES.
		.NLIST
		.NLIST
	.WORD	0
		.LIST
		.LIST
	.ENDM
EMTBLK:	.REPT	9.		; #RS# BLOCK FOR ..V1.. TO ..V2.. EMT CONVERSIONS.
		.NLIST
		.NLIST
	.WORD	0
		.LIST
		.LIST
	.ENDM
DEVTAB:				;START OF DEVICE SPACE AND FREE CORE
	.END	START


