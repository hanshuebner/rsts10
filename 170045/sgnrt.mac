	.INCLUDE /CMN:COMMON/
	.INCLUDE /SGN:SGNCOM/
	.INCLUDE /CMN:SILFMT/
	.INCLUDE /SGN:SYSGEN/
TITLE	SGNRT,<RT11 SPECIFIC ROUTINES>,0A,10-MAY-91,JDM/ABC/PRL/KCG/JJT

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	SGNRT EDIT HISTORY
;+
; EDIT	BY	DATE		REASON
;   01  PRL	01-Feb-82	Add RA80 (DU) to disk table
;   02	PRL	30-Mar-82	Fix WRITE - no nulls output
;   03  KCG	27-Jul-82	RM80 comment edit
;   --	JJT	03-Apr-84	Creation of 9.0 from 8.0
;   04	JJT	25-Jul-85	Remove leading tabs from the answer
;   05	JJT	06-Feb-86	Increase filename length from 20 to 30 chars.
;   06	JJT	15-Jan-88	Fix template monitor feature for V9.6
;-



.SBTTL	RT11 SPECIFIC ROUTINES AND STRUCTURES

.ENABL	LC

; HOPEFULLY ALL OPERATING SYSTEM SPECIFIC CODE IS ISOLATED TO
; THIS SECTION. IF WE EVER CHANGE TO FILES-11/FCS/DMS BASED STRUCTURES
; ONLY THIS CODE AND PERHAPS THE MACROS IN SGNCOM.MAC NEED BE MODIFIED.
; Some macros are defined at the beginning of SYSGEN.MAC

	.MCALL	.EXIT,.DATE
	.MCALL	.ENTER,.RENAME,.CLOSE,.WRITEW
	.MCALL	.TTYIN,.PRINT
	.MCALL	.READW,.LOOKUP
	.MCALL	.SRESET,.RCTRLO


.SBTTL	GET COMMAND LINE FOR RSTS SYSGEN UNDER RT11 EMULATOR

; CALL 	JSR	PC,GETCML
;
; R0 POINTS TO BUFFER TEXT AREA ON RETURN
; ALL OTHER REGISTERS ARE PRESERVED

	ORG	Q0SUBR

GETCML:	CALL	REGSAV,R5	;SAVE EVERYBODY
	CALL	NOCTLO		;CANCEL ANY CONTROL/O
	MOV	#TTYBUF+2,R1	;GET POINTER TO BUFFER DATA
	CLR	R3		;NOTE WE ARE SUPPRESSING LEADING BLANKS
L10:	.TTYIN			;GET A CHARACTER
	BIC	#-177-1,R0	;CLEAR THE PARITY BIT
	BEQ	L10		;NULL, IGNORE IT
	CMP	R0,#3		;WAS CTRL/Z TYPED
	BNE	L15		;NOPE, GO CHECK IT OUT
	.CLOSE	#1		;CLOSE WHATEVER MAY BE OPEN ON CHANNEL 1
	MOV	#GBLNAM,LNKGBL+14 ;RESTORE THE POINTER TO THE FILENAME
	CALL	CREATE,R5,LNKGBL;OPEN GLOBAL FILE FOR OUTPUT
	JSR	R5,@#WRITE	;GO TO THE WRITE ROUTINE
	.WORD	LNKGBL		;WRITE TO THE GLOBAL.COM FILE
	.MESS			;BEGINNING OF TEXT TO WRITE
	.ASCII	%$ JOBMAX == 0%	;FLAG A CTRL/Z EXIT
	.ASCII	<CR><LF>
	MESS.
	CALL	CLOSE,R5,LNKGBL	;CLOSE GLOBAL FILE
	.EXIT			;THAT'S ALL FOLKS

L15:	CMP	R1,#TTYEND	;CAN WE STORE ?
	BEQ	40$		;NO, BUT GOBBLE UP REST OF LINE
	CMP	R0,#141		;CODE BELOW LOWER CASE SET ?
	BLT	20$		;YES. OKAY AS IS
	CMP	R0,#172		;NO - IS IT LOWER CASE ?
	BGT	20$		;NOT LOWER CASE - LEAVE AS IS
	BIC	#40,R0		;CONVERT LOWER CASE TO UPPER
20$:	CMP	R0,#40		;IS THIS CHARACTER A SPACE?		;004
	BEQ	L10		;YES, SO CHUCK IT			;004
	CMP	R0,#11		;IS THIS CHARACTER A TAB?		;004
	BEQ	L10		;YES, SO CHUCK IT			;004
	MOVB	R0,(R1)+	;STORE CHARACTER
40$:	CMP	R0,#LF		;IS THIS THE TERMINATING LINE FEED
	BEQ	50$		;YES. WE ARE DONE
	CMP	R0,#ESC		;IS THIS AN ESCAPE
	BNE	L10		;NO, GET ANOTHER
	MOV	#TTYBUF+2,R1	;RESET THE POINTER TO THE BEGINNING OF TEXT AREA
	MOVB	R0,(R1)+	;SET RESPONSE TO ESCAPE
	BR	60$		;GO FINISH UP

50$:	CMPB	-1(R1),#LF	;WAS LAST CHARACTER STORED A LINE FEED ?
	BEQ	60$		;YES, SO NO OVERFLOW
	MOV	#TTYBUF+2,R1	;RESET PTR TO BEGINNING OF TEXT AREA
	MOV	#CRLF,(R1)+	;OVERFLOW DEFAULTS TO JUST CR RESPONSE
60$:	MOV	#TTYBUF+2,(SP)	;SET BUFFER PTR FOR RETURN IN R0
	SUB	#TTYBUF+2,R1	;GET NUMBER OF CHARACTERS STORED
	MOV	R1,TTYBUF	;STORE IN HEADER
	CALL	REGRES,R5	;RESTORE EVERYBODY
	RETURN			;RETURN 


GETBUF:	MOV	#TTYBUF,R0	;SET A BUFFER POINTER TEXT OUTPUT
	RETURN	

	TMPORG	Q0DATA
TTYBUF:	.WORD	0		;COUNT OF CHARACTERS GOTTEN
	.BLKB	72
TTYEND:				;END OF BUFFER
	UNORG

.SBTTL	GET SYSTEM DISK TYPE/SIZE, ETC.

SETSYS:	MOV	#1,@#40		;ENSURE NO RE-STARTS!!
	MOV	FIRQB+FQDEV,R0	;GET THE DEVICE NAME WE "RAN" FROM
	MOV	#40$,R1		;ALSO GET A TABLE POINTER
10$:	MOV	(R1)+,SYSSIZ	;SET A TRIAL SYSTEM DISK SIZE FLAG
	CMP	R0,(R1)		;DO WE MATCH THE TABLE??
	BEQ	20$		;YES
	TST	(R1)+		;NO, END OF TABLE?
	BNE	10$		;NOT END YET, LOOP...
20$:	MOV	(R1),SYSDSK	;SET SYSTEM DISK TYPE
	CALL	NOCTLO		;CANCEL ANY CONTROL/O
	.SRESET			;RESET ALL CHANNELS
	BIT	#400,@#44	;WERE WE CHAINED TO?
	BEQ	30$		;NOPE
	MOV	@#510,ADSTMD	;YEP, SET DISTRO MEDIUM AUTO-ANSWER
30$:	RETURN			;EXIT

40$:	.WORD	-1,"DC		;RC'S ARE VERY SMALL
	.WORD	-1,"DF		;RF'S ARE VERY SMALL
	.WORD	-1,"DS		;RS'S ARE VERY SMALL
	.WORD	-1,"DK		;RK'S ARE VERY SMALL
	.WORD	+1,"DL		;RL'S ARE SORT OF SMALL
	.WORD	 0,"DM		;RK06'S ARE BIG
	.WORD	 0,"DP		;RP'S ARE BIG
	.WORD	 0,"DR		;RM02/03/05/80'S ARE BIG
	.WORD	 0,"DB		;RP04/05/06'S ARE BIG
	.WORD	 0,"DU		;RA80'S ARE BIG
	.WORD	-1,  0,"??	;WHOOPS!!

.SBTTL	DATA STRUCTURES FOR RT11 FILE I/O

; LINK BLOCK OFFSETS

L.FCBA	=	0		;FCB ADDRESS
L.BUFF	=	2		;BUFFER ADDRESS
L.BEND	=	4		;BUFFER END ADDRESS
L.FPTR	=	6		;FILL POINTER
L.XXXX	=	10		;NOT USED

; FCB OFFSETS

F.CHAN	=	0		;CHANNEL NUMBER (0-17)
F.CODE	=	1		;RT11 FUNCTION CODE
F.DBLK	=	2		;POINTER TO FILE DATA BLOCK
F.BLK	=	2		;BLOCK NUMBER FOR I/O
F.BUFF	=	4		;BUFFER ADDRESS
F.WCNT	=	6		;WORD COUNT
F.WFLG	=	10		;WAIT FLAG

	TMPORG	Q0DATA

; CONFIG FILE

LNKCFG::.WORD	CFGFCB		;FCB ADDRESS 	(L.FCBA)
	.WORD	BLKBUF		;BUFFER ADDRESS	(L.BUFA)
	.WORD	BLKEND		;BUFFER END	(L.BEND)
	.WORD	BLKBUF		;FILL POINTER	(L.FPTR)
	.WORD	0		;NOT USED

CFGFCB:	.BYTE	1,0		;LO=CHAN.,HI=CODE	(F.CHAN,F.CODE)
	.WORD	CFGNAM		;PTR TO NAME ! BLK #	(F.PTR ! F.BLK)
	.WORD	0		;BUFFER ADDRESS		(F.BUFF)
	.WORD	0		;WORD	COUNT		(F.WCNT)
	.WORD	0		;WAIT FLAG		(F.WFLG)

CFGNAM:	.RAD50	/DK/		;DK:CONFIG.MAC
	.RAD50	/CONFIG/	;
	.RAD50	/MAC/		;
	.RAD50	/DK/		;DK:CONFIG.BAK
	.RAD50	/CONFIG/	;
	.RAD50	/BAK/		;

	.WORD	-1		;BLOCK NUMBER OF BUFFER
BLKBUF::.BLKW	256.		;BUFFER FOR ALL BLOCK I/O
BLKEND::

	UNORG


; BATCH FILE

	TMPORG	Q0DATA

LNKBAT::.WORD	BATFCB		;FCB ADDRESS 	(L.FCBA)
	.WORD	BLKBUF		;BUFFER ADDRESS	(L.BUFA)
	.WORD	BLKEND		;BUFFER END	(L.BEND)
	.WORD	BLKBUF		;FILL POINTER	(L.FPTR)
	.WORD	0		;NOT USED

BATFCB:	.BYTE	1,0		;LO=CHAN.,HI=CODE	(F.CHAN,F.CODE)
	.WORD	BATNAM		;PTR TO NAME ! BLK #	(F.DBLK ! F.BLK)
	.WORD	0		;BUFFER ADDRESS		(F.BUFF)
	.WORD	0		;WORD	COUNT		(F.WCNT)
	.WORD	0		;WAIT FLAG		(F.WFLG)

BATNAM:	.RAD50	/DK/		;DK:SYSGEN.COM
	.RAD50	/SYSGEN/	;
	.RAD50	/COM/		;
	.RAD50	/DK/		;DK:SYSGEN.BAK
	.RAD50	/SYSGEN/	;
	.RAD50	/BAK/		;

	UNORG


;   INIT. SYS FILE

	TMPORG	Q0DATA

LNKINT::.WORD	INTFCB		;FCB ADDRESS	(L.FCBA)
	.WORD	BLKBUF		;BUFFER ADDRESS	(L.BUFA)
	.WORD	0		;NOT USED
	.WORD	BLKBUF		;FILL POINTER	(L.FPTR)
	.WORD	0		;NOT USED

INTFCB:	.BYTE	1,0		;LO=CHAN.,HI=CODE	(F.CHAN,F.CODE)
	.WORD	INTNAM		;PTR TO NAME ! BLK #	(F.DBLK ! F.BLK)
	.WORD	0		;BUFFER ADDRESS		(F.BUFF)
	.WORD	256.		;WORD COUNT		(F.WCNT)
	.WORD	0		;WAIT FLAG		(F.WFLG)

INTNAM:	.RAD50	/SY0/		;SY0:INIT.SYS
	.RAD50	/INIT/
	.RAD50	/SYS/
	.BLKW	3		;UNUSED

	UNORG


;	MONITOR FILE

	TMPORG	Q0DATA

LNKSIL::.WORD	SILFCB		;FCB ADDRESS	(L.FCBA)
	.WORD	SILBUF		;BUFFER ADDRESS	(L.BUFA)
	.WORD	0		;NOT USED
	.WORD	SILBUF		;FILL POINTER	(L.FPTR)
	.WORD	0		;NOT USED

SILFCB:	.BYTE	1,0		;LO=CHAN.,HI=CODE	(F.CHAN,F.CODE)
	.WORD	SILFNM		;PTR TO NAME ! BLK #	(F.DBLK ! F.BLK)
	.WORD	0		;BUFFER ADDRESS		(F.BUFF)
	.WORD	256.		;WORD COUNT		(F.WCNT)
	.WORD	0		;WAIT FLAG		(F.WFLG)

SILFNM::.RAD50	/SY0/		;SY0:      .SIL
	.RAD50	/      /
	.RAD50	/SIL/
	.BLKW	3		;UNUSED

SILBUF::.BLKB	SI.SIZ		;BUFFER FOR SIL INDEX			;006

	UNORG


; GLOBAL.COM FILE

	TMPORG	Q0DATA

LNKGBL::.WORD	GBLFCB		;FCB ADDRESS 	(L.FCBA)
	.WORD	BLKBUF		;BUFFER ADDRESS	(L.BUFA)
	.WORD	BLKEND		;BUFFER END	(L.BEND)
	.WORD	BLKBUF		;FILL POINTER	(L.FPTR)
	.WORD	0		;NOT USED

GBLFCB:	.BYTE	1,0		;LO=CHAN.,HI=CODE	(F.CHAN,F.CODE)
	.WORD	GBLNAM		;PTR TO NAME ! BLK #	(F.PTR ! F.BLK)
	.WORD	0		;BUFFER ADDRESS		(F.BUFF)
	.WORD	0		;WORD	COUNT		(F.WCNT)
	.WORD	0		;WAIT FLAG		(F.WFLG)

GBLNAM:	.RAD50	/DK/		;DK:GLOBAL.COM
	.RAD50	/GLOBAL/	;
	.RAD50	/COM/		;
	.RAD50	/DK/		;DK:GLOBAL.BAK
	.RAD50	/GLOBAL/	;
	.RAD50	/BAK/		;

	UNORG

.SBTTL	RT11 FILE CREATE

; CALL	JSR	R5,CREATE
;	+	LNKCFG		;LINK BLOCK ADDRESS
;
; ALL REGISTERS PRESERVED
; NO RETURN ON ERROR
;
	ORG	Q0SUBR

CREATE:	CALL	REGSAV,R5	;SAVE EVERYBODY
	MOV	(R5)+,R4	;GET LINK BLOCK ADDRESS
	MOV	R5,12(SP)	;UPDATE RETURN ON STACK
	MOV	L.FCBA(R4),R0	;GET FCB ADDRESS
	MOV	R0,-(SP)	;SAVE FCB ADDRESS
	.RENAME	R0,#1		;OLD CONFIG.MAC --> CONFIG.BAK
				;OLD SYSGEN.BAT --> SYSGEN.BAK
	MOV	(SP),R0		;RESTORE FCB ADDRESS
	.ENTER	R0,#1		;NOW OPEN FILE
	BCS	IOERR		;TERMINATE ON ANY ERROR
	MOV	(SP)+,R0	;RESTORE FCB ADDRESS
	CLR	F.BLK(R0)	;INITIALIZE BLOCK NUMBER IN FCB
	MOV	L.BUFF(R4),L.FPTR(R4) ;INITIALIZE FILL PTR IN LINK BLK
	CALL	REGRES,R5	;RESTORE EVERYBODY
	RETURN	R5		;AND QUIT

.SBTTL	RT11 TEXT FILE WRITER

; CALL	JSR	R5,WRITE
;	+	LNKBLK		;LINK BLOCK ADDRESS
;	+	MESS		;MESSAGE ADDRESS (ASCIZ)
;
; ALL REGISTERS PRESERVED
; ASCIZ TEXT IS BUFFERED AND BLOCKS WRITTEN AS REQUIRED
; CLOSE TAKES CARE OF WRITING LAST BLOCK

	ORG	Q0SUBR

WRITE:: CALL	REGSAV,R5	;SAVE ALL
	MOV	(R5)+,R4	;GET LINK BLOCK ADDRESS
	MOV	(R5)+,R1	;GET POINTER TO MESSAGE HEADER
	TST	(R1)+		;POINT TO ACTUAL MESSAGE TEXT
	MOV	R5,12(SP)	;UPDATE RETURN ADDRESS ON STACK
	MOV	L.FCBA(R4),R0	;GET FCB ADDRESS
	MOV	L.FPTR(R4),R2	;GET FILL POINTER
10$:	CMP	R2,L.BEND(R4)	;TIME TO WRITE BLOCK ?
	BNE	20$		;NOT YET
	MOV	R0,-(SP)	;SAVE FCB POINTER
	.WRITEW	R0,#1,#BLKBUF,#256. ;WRITE THE BLOCK
	BCS	IOERR		;TERMINATE ON ANY ERROR
	MOV	(SP)+,R0	;RESTORE FCB POINTER
	MOV	L.BUFF(R4),R2	;RESET FILL POINTER
	INC	F.BLK(R0)	;BUMP BLOCK NUMBER FOR NEXT WRITE
20$:	MOVB	(R1)+,R3	;GET THE CHARACTER
	BPL	30$		;NOT A SPECIAL CHARACTER
	BIC	#^C<177>,R3	;CLEAR UNWANTED BITS
	BEQ	40$		;TERMINATOR
	ADD	#SPLCHR-1,R3	;POINT TO THE CHARACTER LIST
	MOVB	(R3),R3		;GET THE SPECIAL CHARACTER
30$:	BEQ	10$		;NULL, SO IGNORE IT
	MOVB	R3,(R2)+	;MOVE CHARACTER TO BUFFER
	BR	10$		;THIS MAY NEVER END

40$:	MOV	R2,L.FPTR(R4)	;RESET FILL POINTER IN LINK BLOCK
	CALL	REGRES,R5	;RESTORE EVERYBODY
	RETURN	R5		;EXIT SMILING

IOERR:	MOV	IOSTS,R0	;GET THE ERROR NUMBER
	CALL	NOCTLO		;CANCEL ANY CONTROL/O
	EMT	364		;PRINT AN ERROR MESSAGE
	.EXIT			;JUST TERMINATE ON ERROR FOR NOW

.SBTTL	RT11 FILE CLOSE

; CALL	JSR	R5,CLOSE
;	+	LNKBLK		;LINK BLOCK ADDRESS
;
; ALL REGISTERS ARE PRESERVED
; LAST BUFFER IS NULL FILLED AND WRITTEN
; NO RETURN ON ERROR

	ORG	Q0SUBR

CLOSE::	CALL	REGSAV,R5	;SAVEM
	MOV	(R5)+,R4	;GET LINK BLOCK ADDRESS
	MOV	R5,12(SP)	;UPDATE RETURN ON STACK
	MOV	L.FCBA(R4),R0	;GET FCB ADDRESS
	MOV	L.FPTR(R4),R2	;GET FILL POINTER
	CMP	R2,L.BUFF(R4)	;ANY NEED TO WRITE LAST BLOCK ?
	BEQ	30$		;NO, JUST CLOSE
10$:	CMP	R2,L.BEND(R4)	;AT END OF BUFFER ?
	BEQ	20$		;YES, WRITE AND CLOSE
	CLRB	(R2)+		;ZERO FILL TO END
	BR	10$		;

20$:	MOV	R0,-(SP)	;SAVE FCB POINTER
	.WRITEW	R0,#1,#BLKBUF,#256. ;WRITE THE BLOCK
	BCS	IOERR		;TERMINATE ON ANY ERROR
	MOV	(SP)+,R0	;RESTORE FCB POINTER
30$:	.CLOSE	#1		;CLOSE SOMEBODY
	CALL	REGRES,R5	;RESTORE EVERYBODY
	RETURN	R5		;AND QUIT

.SBTTL	RT11 FILE OPEN

;  MOV		#ppn,@54 ;PPN OF FILE TO OPEN
;  CALL	JSR	R5,OPEN
;	+	LNKBLK	;LINK BLOCK ADDRESS

;  THE FILE IS OPENED ON CHANNEL 1 IN ACCOUNT SPECIFIED IN @54
;  C BIT IS SET ON ERROR

	ORG	Q0SUBR

OPEN::	MOV	R0,-(SP)	;SAVE A REGISTER
	MOV	(R5)+,R0	;GET LINK BLOCK ADDRES
	MOV	L.FCBA(R0),R0	;GET FCB ADDRESS
;	MOV	#1,@54		;PPN=0,1
	.LOOKUP	R0,#1		;OPEN IT
	MOV	(SP)+,R0	;RESTORE R0
	RETURN	R5		;BACK



.SBTTL	RT11 FILE READ

;  CALL	JSR	R5,READ
;	+	LNKBLK		;LINK BLOCK ADDRESS
;	R2 = BLOCK NUMBER
;	R4 = BUFFER ADDRESS

;  READ 1 BLOCK ON CHANNEL 1 INTO THE BUFFER
;  C BIT SET IF AN ERROR

READ::	MOV	R0,-(SP)	;SAVE R0
	MOV	(R5)+,R0	;GET LINK BLOCK ADDRESS
	MOV	L.FCBA(R0),R0	;GET FCB ADDRESS
	MOV	R2,F.BLK(R0)	;SET BLOCK NUMBER
	MOV	R4,F.BUFF(R0)	;SET BUFFER ADDRESS
	.READW	R0,#1		;READ A BLOCK
	MOV	(SP)+,R0	;RESTORE R0
	RETURN	R5		;RETURN

	UNORG

.SBTTL	CONVERT RT11 DATE TO DD-MMM-YY STRING

; CALL	JSR	PC,DATE
;
; ALL REGISTERS PRESERVED
; ASCIZ DATE RETURNED IN DATE$
	ORG	Q0SUBR

DATE::	CALL	REGSAV,R5	;SAVE ALL
	.DATE			;GET SYSTEM DATE
	MOV	R0,R1		;BITS 14-10 = MONTH (1-12)
	BIC	#176037,R1	;BITS  9-5  = DAY   (1-31)
	ASH	#-5,R1		;BITS  4-0  = YEAR  (YR-72.)
	BLE	30$		;IF DAY <= 0, RETURN DEFAULT DATE
	CMP	R1,#31.		;OR DAY > 31,
	BGT	30$		;RETURN DEFAULT DATE
	CALL	STRDEC,R5	;CONVERT DAY TO DECIMAL
	.WORD	DATE$$		;USING THIS SCRATCH AREA
	MOV	#DATE$$,R5	;GET POINTER TO DAY IN DECIMAL
	MOVB	#'0,R2		;ASSUME < 10TH OF MONTH
	CMP	R1,#10.		;GOOD ASSUMPTION ?
	BLT	10$		;YES
	MOVB	(R5)+,R2	;R2 = DAY (TENS  DIGIT)
10$:	MOVB	(R5)+,R3	;R3 = DAY (UNITS DIGIT)
	MOV	R0,R1		;RESTORE ORIGINAL BINARY DATE
	BIC	#177740,R1	;GET ONLY YEAR BITS
	ADD	#72.,R1		;BIASED BY 1972
	CALL	STRDEC,R5	;CONVERT YEAR TO DECIMAL
	.WORD	DATE$$		;USING SCRATCH AREA
	MOV	#DATE$$,R1	;GET POINTER TO YEAR IN DECIMAL
20$:	CMPB	(R1)+,#'.	;SCAN FOR DECIMAL POINT
	BNE	20$		;
	DEC	R1		;BACKUP POINTER TO DECIMAL POINT
	MOVB	-(R1),R5	;R5 = YEAR (UNITS DIGIT)
	MOVB	-(R1),R4	;R4 = YEAR (TENS  DIGIT)
	MOV	R0,R1		;RESTORE ORIGINAL BINARY DATE
	BIC	#101777,R1	;JUST MONTH BITS
	ASH	#-8.,R1		;GET MONTH * 4
	CMP	R1,#1.*4.	;MONTHS LESS THAN 1 ARE LOSERS
	BLT	30$		;SO RETURN DEFAULT DATE
	CMP	R1,#12.*4.	;NOTHING GREATER THAN DEC. PLEASE
	BGT	30$		;ELSE RETURN DEFAULT
	ADD	#MON$-4.,R1	;POINT TO TABLE OF MONTHS
	MOV	#DATE$+6,R0	;SET PTR TO RETURN STRING
	MOVB	R2,(R0)+	;MOVE DAY (TENS  DIGIT)
	MOVB	R3,(R0)+	;MOVE DAY (UNITS DIGIT)
	INC	R0		;SKIP DASH
	MOVB	(R1)+,(R0)+	;MOVE MONTH
	MOVB	(R1)+,(R0)+	;
	MOVB	(R1)+,(R0)+	;
	INC	R0		;SKIP DASH
	MOVB	R4,(R0)+	;MOVE YEAR (TENS  DIGIT)
	MOVB	R5,(R0)+	;MOVE YEAR (UNITS DIGIT)
30$:	CALL	REGRES,R5	;RESTORE EVERYBODY
	RETURN			;RETURN DATE IN DATE$


	TMPORG	Q0DATA
	.NLIST	BEX
DATE$::	.WORD	19.		;BYTE COUNT
	.ASCII	<CR><LF>
	.ASCII	%**%
TODAY::	.ASCII	%DD-MMM-YY**%<CR><LF><TERM>

DATE$$:	.BLKB	10.		;SCRATCH

MON$:	.ASCII	%Jan-Feb-Mar-Apr-May-Jun-Jul-Aug-Sep-Oct-Nov-Dec-%
	.LIST	BEX
	UNORG

.SBTTL	TEXT PRINTERS

;CALL	JSR	R5,PRINT
;	+	ADDR.		;ADDRESS OF BUFFER HEADER
;
;CALL	JSR	R5,PRINT0	
;	R0  =	ADDR.		;ADDRESS OF BUFFER HEADER IN R0
;

.ENABL	LSB

PRINT:: MOV	R0,-(SP)	;SAVE ONE
	MOV	(R5)+,R0	;GET BUFFER HEADER ADDRESS
	TST	QUERSW		;ABBREVIATED FORM REQUESTED ?
	BEQ	10$		;NOPE - PRINT WHOLE MESSAGE
	TST	-2(R0)		;IS THERE ANY ABBREVIATION ?
	BEQ	10$		;NO - PRINT LONG FORM
	MOV	-(R0),R0	;GET ADDR. OF ABBREVIATED MESSAGE
	BR	10$		;PRINT MESSAGE

PRINT0::MOV	R0,-(SP)	;SAVE ONE
10$:	TST	(R0)+		;SKIP OVER THE BYTE COUNT
	.PRINT
	MOV	(SP)+,R0	;RESTORE R0
	RETURN	R5		;RETURN

.DSABL	LSB

; CANCEL ANY CONTROL/O EFFECT

NOCTLO:	MOV	R0,-(SP)	;SAVE R0
	.RCTRLO			;CANCEL THE CONTROL/O
	MOV	(SP)+,R0	;RESTORE R0
	RETURN			;EXIT

.SBTTL	CHECK AND STORE FILE SPECIFICATION

;CALL	JSR	R5,FILNAM
;	+	STORAGE LOCATION (30. CHARACTERS)
;	+	RETURN FOR BAD INPUT
;	+	RETURN FOR GOOD INPUT
;
;	R0---> ASCII STRING WITH <CR> TERMINATOR
;
;RETURN:	R0,R1 AND R2 ARE UNDEFINED
;		TYPED STRING IS STORED IN STORAGE LOCATION WITH NULLS APPENDED

FILNAM::MOV	(R5),R1		;GET POINTER TO STORAGE
	MOV	#30.,R2		;SET COUNT				;05
10$:	CLRB	(R1)+		;CLEAR (NULL) STORAGE
	SOB	R2,10$
	MOV	(R5),R1		;GET POINTER AGAIN
	MOV	#29.,R2		;SET COUNT AGAIN			;05
20$:	CMPB	(R0),#CR	;TERMINATOR?
	BEQ	40$		;YES
	CMPB	(R0),#LF	;TERMINATOR?
	BEQ	40$		;YES
	CMPB	(R0)+,#40	;JUNK?
	BLOS	20$		;YES, IGNORE IT...
	CMPB	-(R0),#'$	;A DOLLAR SIGN?
	BEQ	30$		;YES, THA'S O.K.
	CMPB	(R0),#':	;A COLON?
	BEQ	30$		;O.K.
	CMPB	(R0),#'.	;DOT?
	BEQ	30$		;O.K.
	CMPB	(R0),#',	;COMMA
	BEQ	30$		;O.K.
	CMPB	(R0),#'[	;LEFT SQUARE?
	BEQ	30$		;O.K.
	CMPB	(R0),#']	;RIGHT SQUARE?
	BEQ	30$		;O.K.
	CMPB	(R0),#'(	;LEFT PAREN?
	BEQ	30$		;O.K.
	CMPB	(R0),#')	;RIGHT PAREN?
	BEQ	30$		;O.K.
	CMPB	(R0)+,#'0	;DIGIT?
	BLO	50$		;NO, ERROR
	CMPB	-(R0),#'9	;DIGIT?
	BLOS	30$		;O.K.
	BICB	#40,(R0)	;FORCE UPPER CASE
	CMPB	(R0)+,#'A	;ALPHA?
	BLO	50$		;NO, ERROR
	CMPB	-(R0),#'Z	;ALPHA?
	BHI	50$		;NO, ERROR
30$:	TST	R2		;ROOM LEFT??
	BEQ	50$		;NOPE, ERROR
	MOVB	(R0)+,(R1)+	;YEP, SO STORE A CHARACTER
	DEC	R2		; AND COUNT IT
	BR	20$		;  AND LOOP

40$:	CLRB	(R1)		;.ASCIZ TERMINATE THE STRING
	MOV	(R5),R0		;NOW POINT TO IT
	EMT	365		;DO THE .FSS
	BCS	50$		;ERROR
	TST	XRB+XRBC	;ANYTHING REMAINING?
	BNE	50$		;YES, ERROR
	MOV	XRB+10,R0	;GET FLAGS
	BIC	#^B0111110010011000,R0 ;REMOVE SOME
	CMP	#^B0000000000000001,R0 ;VALID?
	BNE	50$		;NO, ERROR
	MOV	XRB+12,R0	;GET FLAGS
	BIC	#^B0111011011111000,R0 ;REMOVE SOME
	CMP	#^B0000000100000000,R0 ;VALID?
	BNE	50$		;NO, ERROR
	TST	(R5)+		;SKIP THE ARGUMENT FOR GOOD EXIT
50$:	TST	(R5)+		;SKIP THE ARGUMENT (OR BAD EXIT)
	RETURN	R5		;EXIT

.SBTTL	EXIT TO SYSTEM

EXIT:	.EXIT

	.TITLE	SYSGEN		;FORCE THE TITLE
	.END	SYSGEN		;END OF ROOT SEGMENT

