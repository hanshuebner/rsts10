	.INCLUDE /CMN:COMMON/
	.INCLUDE /SGN:SGNCOM/
	.INCLUDE /CMN:SILFMT/
TITLE	SGNSRT,<SYSGEN START UP DIALOG>,0A,10-MAY-91,GW/ABC/MJG/PRL/KCG/FEK/JJT/KPH

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	SGNSRT EDIT HISTORY
;+
; EDIT	BY	  DATE			REASON
;
;  01 RVR/DRP	15-Dec-80	Added support for DMV11/DMP11.
;
;  02  PRL	26-Jan-82	Add /A (APT) hidden switch
;  03  PRL	28-Jan-82	Change AUTOAN flag to global
;  04  PRL	01-Feb-82	Add RA80/UDA50 support
;  05  PRL	23-Mar-82	Remove "small link" hidden switch
;  06  PRL	06-Apr-82	Change "LP for SYSGEN" default to no
;
;  --  KCG	08-Jul-82	Creation of 8.0 from 7.2 
;  07  KCG 	27-Jul-82	Comment changes for RM80 in RM fields.
;				Flagging of DC11 for deletion ( 9.0 ).
;				Deleting the KL11 comment.
;  08  KCG	11-Aug-82	Redefinition of device packet table as to
;				the definition for 8.0.
;  09  KCG	04-Oct-82	Change AUDA to AMSCP for more accuracey.
;  10  FEK	25-AUG-83	Add DHV/DHU remove 2741 change DZ and DMV/DMP
;  --  JJT	03-Apr-84	Creation of 9.0 from 8.0
; 011  KPH	26-Sep-84	Remove resident overlay stuff
;  --  JJT	22-May-85	Creation of 9.1
; 012  JJT	22-May-85	Add TMSCP
; 013  JJT	02-Jul-85	Implement new strategy for template monitors
; 014  JJT	04-Sep-85	Convert MSCP controllers to disks
; 015  JJT	18-Oct-85	Use new symbol for CTRL-T in V9.2
; 016  JJT	11-Nov-85	Allow Maps to be created
; 017  JJT	05-Dec-85	Add a /Baselevel switch
; 018  JJT	07-Jan-86	V9.3 changes
; 019  KPH/JJT  11-Mar-86	Disallow zero II units
; 020  JJT	12-Mar-86	Change MSCP question to a yes/no question
; 021  JJT	12-Mar-86	Accept INIT's value for RP02/03's as is
; 022  JJT	16-Feb-87	Accept INIT's value for TU16's as is
; 023  JJT	17-Feb-87	Account for disk unit numbers greater than 9
; 024  DRW	02-Oct-87	Fix corruption of Template Monitor default
;
;			[RSTS V9.6]
;  025  KPH	05-Nov-87	Remove terminal driver stuff
;  026	JJT	24-Dec-87	Add ability to print directory of .SILs
;  027	JJT	15-Jan-88	Fix template monitor feature
;  028	JJT	03-Mar-88	Remove Statistic support
;  029	JJT	03-Jun-88	Account for KBs in small buffer default
;
;			[RSTS V9.7]
;  030	JJT	05-Jan-89	Remove unsupp. hardware questions
;  031	JJT	21-Feb-90	Find the previously installed .SIL
;-

.SBTTL	DEFINE MACROS

	.MACRO	HARDEV	NAME,ROUTIN,ANS ;DEFINE TABLE ENTRY FOR HARDWARE
					;  AUTO ANSWERS
	 .WORD	NAME		;DEVICE NAME
	 .WORD	ANS		;AUTO ANSWER
	 .WORD	ROUTIN		;PROCESSING SUBROUTINE
GLOBAL	<ANS>
	.ENDM


	.MACRO	CPUDEV	OFF,ANS1,ANS2	;DEFINE TABLE ENTRY FOR CPU OPTION AUTO ANSWER
	 .WORD	OFF		;TABLE OFFSET
	 .WORD	ANS1		;AUTO ANSWER FOR WORD OR HIGH BYTE
	.IF	NB	<ANS2>
	 .WORD	ANS2		;AUTO ANSWER FOR LOW BYTE
GLOBAL	<ANS2>
	.IFF
	 .WORD	0		;ONLY ONE ANSWER
	.ENDC
GLOBAL	<ANS1>
	.ENDM

	.MACRO	SILMOD	MOD,ADD		;DEFINE TABLE ENTRY FOR SIL MODULES
	.NCHR	MODLEN,	MOD		;GET THE LENGTH OF THE MODULE NAME
	.RAD50	/MOD/			;GET THE RAD-50 OF THE MODULE MOD
	.IF	GT	4-MODLEN	;IF LENGTH IS LESS THAN 4 CHARACTERS
	.RAD50	/   /			; PAD WITH RAD-50 OF 3 SPACES
	.ENDC				;END OF IF STATEMENT
	.WORD	ADD			;PUT IN THE ADDRESS OF THE SYMBOLS
	.ENDM				;END OF MACRO

	.MACRO	SILSYM	NAME,LOC,ROUTNE	;DEFINE TABLE ENTRY FOR SIL SYMBOLS
	.NCHR	NAMLEN,	NAME		;GET THE LENGTH OF THE SYMBOL NAME
	.RAD50	/NAME/			;GET THE RAD-50 OF THE SYMBOL NAME
	.IF	GT	4-NAMLEN	;IF LENGTH IS LESS THAN 4 CHARACTERS
	.RAD50	/   /			; PAD WITH RAD-50 OF 3 SPACES
	.ENDC				;END OF IF STATEMENT
	.WORD	LOC			;PUT IN ADDRESS OF DEFAULT ANSWER
GLOBAL	<LOC>				;IT'S A GLOBAL SYMBOL
	.WORD	ROUTNE			;PUT IN ADDRESS OF ROUTINE
	.ENDM				;END OF MACRO

	.MACRO	INISYM	SYMNAM,INIVAL	;INITIALIZE SYMNAM TO THE VALUE INIVAL
	MOV	#SYMNAM,R1		;GET THE ADDRESS OF THE SYMBOL NAME
	.IF	B	INIVAL		;IF THE VALUE IS BLANK
	MOVB	#0,(R1)+		;PUT A ZERO IN THE LOWER BYTE
	MOVB	#0,(R1)			;PUT A ZERO IN THE UPPER BYTE
	.IFF				;IF THERE WAS A VALUE
	.IRPC	SYMCHR,<INIVAL>		;FOR EACH CHARACTER OF THE VALUE
	MOVB	#''SYMCHR,(R1)+		;MOVE THE CHARACTER INTO THE SYMBOL
	.ENDM				;END OF .IRPC
	.ENDC				;END OF THE CONDITIONAL
GLOBAL	<SYMNAM>			;IDENTIFY IT AS BEING A GLOBAL
	.ENDM				;END OF MACRO

.SBTTL	BEGINNING OF QUESTIONS

	DEFORG	Q1CODE

.ENABL	LC

MESNUM	=	0                                   
MSGSEG	=	1
TAGNUM	=	0

;   DEVICE TABLE DEFINITIONS

	.EQUATE	LOCDEV,60	;START OF DEVICE TABLE
	.EQUATE	LOCCSR,62	;START OF CSR TABLE
	.EQUATE	LOCTYP,66	;START OF TYPE TABLE
	.EQUATE	LOCHWR,70	;START OF HARDWARE TABLE
	.EQUATE LOCSIL,72	;START OF SIL NAME

	.DSECT			;DEFINE DEVICE PACKET
PK.MXU:	.BLKB			;MAX NUMBER OF DEVICES
PK.FLG:	.BLKB			;DEVICE FLAGS
PK.CSO:	.BLKW			;TABLE OFFSET
PK.SIZ:	.BLKB			;SIZE ON IO PAGE
PK.NUN:	.BLKB			;NUMBER OF SUBUNITS
PK.OFF:	.BLKB			;OFFSET OF MAJOR REGISTER
PK.PRI:	.BLKB			;PRIORITY
PK.NAM:	.BLKW			;DEVICE NAME
PK.LNG:	.BLKW			;LENGTH OF PACKET
	UNORG



SGNSRT::NOP
	CALLX	DATE		;GET THE DATE

GLOBAL	<DATE$>

FORM:
	CLR	QUERSW		;INIT FLAG
	INC	QUERSW		;SET IT TO SHORT FORM

SETDEF:	TST	AUTOAN		;WAS THERE A PREVIOUS BAD READ
	BMI	DSTRO		;YES
	TST	OPNINT		;DID WE READ THE INIT FILE
	BNE	2$		;YES
	INC	OPNINT		;NO. FLAG IT FOR THE NEXT TIME
	CALL	RDINIT		;READ THE FILE
	BR	SETDEF		;START THIS QUESTION OVER

2$:	CLR	AUTOAN		;ASSUME ANSWER WILL BE NO		;018
	INC	AUTOAN		;ANSWER WILL ALWAYS BE YES
GLOBAL	<QUERSW,AUTOAN>							;018

OUTMDM:
.TAG
DSTRO:	MOV	#"SY,ADSTMD	;SET UP "SY:" AS DEFAULT DISTRO DEVICE
	MOV	ADSTMD,DSTMED	;ACCEPT THE DEFAULT
	MOV	ADSTMD,GENSYS	;MAKE IT THE OUTPUT MEDIUM TOO
GLOBAL	<ADSTMD,DSTMED>

	TMPORG	Q1DATA
AGENSY:	.ASCII	%??%<CR>
	.EVEN
	UNORG

GLOBAL	<SYSSIZ,DSTMED,DEFLAG,OUTLST,GENSYS>

.TAG
	MOV	#"OU,PACKID	;INITIALIZE THE NAME
	MOV	#40*400+'T,PACKID+2 ; AS THREE WORDS
	MOV	#40*400+40,PACKID+4 ;  (= 6 CHARACTERS)
	CALLX	MEDIA,R5,GENSYS	;GET THE MEDIUM TYPE
	SKIP			;DECTAPE            
	SKIP			;MAGTAPE
	SKIP			;SYSTEM DISK
	;NOP			;OTHER DISK

	MOV	#ANSDEF,R1	;WE DON'T KNOW THE ANSWER

	ASK
	.MESS
	.ASCII	<CR><LF>
	.ASCII	%The disk  on which  you will  output the%<CR><LF>
	.ASCII	%generated  system  has  a  logical  name%<CR><LF>
	.ASCII	%called  the  pack  identification.  This%<CR><LF>
	.ASCII	%was  assigned  to the  disk  when it was%<CR><LF>
	.ASCII	%initialized. Please specify the pack ID.%<CR><LF>
	ME.SS
	.ASCII	<CR><LF>
	.ASCII	%Pack ID ?%
	MESS.

	BACK			;USER TYPED ESCAPE
	CALLX	NAME,R5,PACKID	;CHECK AND STORE THE RESPONSE
	LOOP			;BAD RESPONSE

GLOBAL	<ANSDEF,PACKID>


	CLR	DELFIL		;PRESET NO FILE DELETE(S)
	DEC	DELFIL		;FILES WILL ALWAYS BE DELETED

GLOBAL	<DELFIL>

	CLR	ANYLST		;ASSUME NO LISTINGS
	CLR	ASMLST		;THEREFORE NO ASSEMBLY LISTINGS
	NEG	DELFIL		;NO LP FOR SYSGEN

GLOBAL	<ANYLST,ASMLST,DELFIL>

GENMON:	CLR	MONFLG		;ASSUME ANSWER WILL BE NO
	CLR	DIAMON		;ASSUME NO DIAMOND STUFF
	CLR	PATMON		;SAY NO MONITOR PATCHING
	INC	MONFLG		;MONITOR WILL ALWAYS BE GENERATED

GLOBAL	<MONFLG,DIAMON,PATMON>						;025

.TAG
TMPMON:	CLR	ASKIT		;INIT UNCONDITIONAL PROMPTING FLAG	;013
	CLR	PRVMON		;INIT PREVIOUS MONITOR FLAG
	CLR	PRTDIR		;INIT THE PRINT-SIL-DIRECTORY FLAG	;026
	MOV	#ANSYES,R1	;DEFAULT TO YES
	CMP	#^RSYS,SILNM1	;IS THE INSTALLED SIL SYSGEN?
	BNE	10$		;NO, THE FIRST 3 CHARACTERS WEREN'T "SYS"
	CMP	#^RGEN,SILNM2	;CHECK LAST 3 CHARACTERS
	BNE	10$		;NO, IT ISN'T SYSGEN
	CALL	SGNDIR		;See if there is a previously installed .SIL;031
	CMP	#^RSYS,SILNM1	;IS THE INSTALLED SIL STILL SYSGEN?	;031
	BNE	10$		;NO, THE FIRST 3 CHARACTERS WEREN'T "SYS" ;031
	CMP	#^RGEN,SILNM2	;CHECK LAST 3 CHARACTERS		;031
	BNE	10$		;NO, IT ISN'T SYSGEN			;031
	MOV	#ANSNO,R1	;IT STILL IS SYSGEN; NO IS THE DEFAULT  ;031

10$:	ASK
	.MESS
	.ASCII	<CR><LF>
	.ASCII	%The SYSGEN process has the capability of%<CR><LF>
	.ASCII	%obtaining  the  necessary  configuration%<CR><LF>
	.ASCII	%information from a template monitor.  If%<CR><LF>
	.ASCII	%you wish to copy  the  configuration  of%<CR><LF>
	.ASCII	%that template  monitor,  answer  YES  to%<CR><LF>
	.ASCII	%this question, otherwise answer NO.%<CR><LF>
	ME.SS
	.ASCII	<CR><LF>
	.ASCII	%Use template monitor ?%
	MESS.

	BR	20$		;USER TYPED ESCAPE
	CALLX	TESTNY,R5	;CHECK THE ANSWER
	LOOP			;BAD
	TST	(PC)+		;NO (C=0)
	SEC			;YES (C=1)
	SBC	PRVMON		;NO=>0; YES=>-1
	SKIP			;CONTINUE

20$:	JMP	OUTMDM		;GO BACK TO THE OUTPUT MEDIUM QUESTION

GLOBAL	<PRVMON,DEFLAG,ANSYES,ANSNO,ASKIT,SILNM1,SILNM2,PRTDIR,SGNDIR>	;031
	


.TAG
	TST	PRVMON		;ARE WE USING A PREVIOUS MONITOR?
	BNE	1$		;YES, SO CONTINUE
	JMP	NEWMON		;NO, GO ON

1$:	INC	PRTDIR		;ENABLE THE PRINT-SIL-DIRECTORY FLAG	;026
	CMP	#^RSYS,SILNM1	;IS THE INSTALLED SIL SYSGEN?
	BNE	3$		;NO, THE FIRST 3 CHARACTERS WEREN'T "SYS"
	CMP	#^RGEN,SILNM2	;CHECK LAST 3 CHARACTERS
	BNE	3$		;NO, IT ISN'T SYSGEN
	MOV	#ANSDEF,R1	;IT IS SYSGEN; NO DEFAULT
	BR	4$		;GO ASK THE QUESTION

3$:	MOV	#ASILNM+9.,R4	;GET THE ADDRESS OF THE INSTALLED SIL NAME
	MOV	SILNM1,R0	;GET THE FIRST RAD50 WORD
	CALL	RADCNV		;CONVERT IT TO ASCII
	MOV	#ASILNM+12.,R4	;GET THE ADDRESS OF THE 2ND HALF OF SIL NAME
	MOV	SILNM2,R0	;GET THE SECOND RAD50 WORD
	CALL	RADCNV		;CONVERT THAT ONE
	MOV	#ASILNM,R1	;MAKE THIS THE DEFAULT ANSWER

4$:	ASK
	.MESS
	.ASCII	<CR><LF>
	.ASCII	%A  monitor  has  a  name  from  1  to  6%<CR><LF>
	.ASCII	%alphanumeric characters and  a  filetype%<CR><LF>
	.ASCII	%of  "SIL".   Enter  the  name   of   the%<CR><LF>
	.ASCII	%template monitor  whose  parameters  you%<CR><LF>
	.ASCII	%wish to use%<CR><LF>
	ME.SS
	.ASCII	<CR><LF>
	.ASCII	%Template monitor's name ?%
	MESS.

	BACK				;USER TYPED ESCAPE
	CMP	R0,#ANSDEF		;R0 SHOULD NOT BE THE DEFAULT ;024
	LOOP	EQ			;IT IS A BAD RESPONSE	      ;024
	CALLX	FILNAM,R5,SILNAM	;CHECK THE FILENAME
	LOOP				;BAD RESPONSE		      ;024

	CLR	PRTDIR			;CLEAR PRINT-SIL-DIRECTORY FLAG ;026
	MOV	#1,@54			;DEFAULT TO [0,1] FOR MONITOR FILE
	MOV	#^RSY0,SILFNM		;DEFAULT TO SY0:
	MOV	#^RSIL,SILFNM+6		;DEFAULT TO .SIL
	MOV	FIRQB+FQNAM1,SILFNM+2	;MOVE IN THE 1ST HALF OF THE FILENAME
	MOV	FIRQB+FQNAM1+2,SILFNM+4	;MOVE IN THE 2ND HALF OF THE NAME
	TST	FIRQB+FQEXT		;WAS A FILETYPE SPECIFIED?
	BEQ	5$			;NO, LEAVE THE DEFAULT OF .SIL ALONE
	MOV	FIRQB+FQEXT,SILFNM+6	;MOVE IN THE FILETYPE
5$:	TST	FIRQB+FQPPN		;WAS AN ACCOUNT SPECIFIED?
	BEQ	6$			;NO, LEAVE THE DEFAULT OF [0,1] ALONE
	MOV	FIRQB+FQPPN,@54		;MOVE IN THE ACCOUNT
6$:	MOV	XRB+10,R0		;GET FLAG WORD 2
	BIC	#^B1100111111111111,R0	;CLEAR OUT ALL BUT DEVICE
	CMP	#^B0011000000000000,R0	;WAS A DEVICE SPECIFIED?
	BNE	9$			;NO, LEAVE THE DEFAULT OF SY0: ALONE
	TST	XRB+10			;YES, WAS IT A VALID DEVICE?
	BPL	7$			;YES, CONTINUE
	JMP	SILERR			;NO, GO PRINT THE ERROR

7$:	MOV	FIRQB+FQDEV,SILDEV	;STORE THE DEVICE NAME
	MOV	#60,SILDEV+2		;DEFAULT TO UNIT NUMBER 0
	CLRB	SILDEV+3		;.ASCIZ TERMINATE THE STRING
	MOV	FIRQB+FQDEVN,TMPUNT	;STORE THE UNIT NUMBER AND FLAG	;023
	MOV	#SILDEV,R0		;POINT R0 TO THE DEVICE NAME	;023
	EMT	365			;.FSS THE DEVICE TO GET RAD-50	;023
	CMPB	#377,TMPUNT+1		;WAS A UNIT NUMBER SPECIFIED	;023
	BNE	8$			;NO, LEAVE THE DEFAULT OF 0 ALONE ;023
	CLR	R0			;CLEAR A HANDY REGISTER		;023
	MOVB	TMPUNT,R0		;MOVE IN THE UNIT NUMBER	;023
	ADD	R0,FIRQB+FQNAM1		;ADD IT TO THE DEVICE		;023
8$:	MOV	FIRQB+FQNAM1,SILFNM	;MOVE IN THE RAD-50 OF THE DEVICE ;023
9$:	MOV	#SILFNM,LNKSIL+14	;RESTORE THE MONITOR NAME POINTER
	CALLX	OPEN,R5,LNKSIL		;OPEN THE MONITOR
	BCC	.+6			;NO ERROR, CONTINUE
	JMP	SILERR			;GOTO THE ERROR ROUTINE
	CALL	SILNDX,R5		;GO READ THE SIL INDEX
	BEQ	.+6			;SIL OK, CONTINUE
	JMP	BADSIL			;SIL ALL MESSED UP, GO SAY SO

	CALL	INITSM			;GO INITIALIZE ALL THE DEFAULT SYMBOLS
	MOV	#MODTBL,R5		;GET THE ADDRESS OF THE SIL MODULES
10$:	TST	(R5)			;ANYTHING LEFT?
	BEQ	20$			;ALL DONE, SO MOVE ON
	CALL	SILSCN			;SCAN FOR THIS SIL MODULE
	BCC	.+6			;IT'S THERE, CONTINUE
	JMP	BADSIL			;NOT THERE, INVALID SIL
	CALL	SCANST			;GET THE SYMBOL VALUES FOR THIS MODULE
	TST	(R5)+			;GO ON TO THE NEXT SIL MODULE
	BR	10$			;DO THE NEXT SIL MODULE

20$:	CALLX	CLOSE,R5,LNKSIL		;CLOSE THIS MONITOR FILE
	CLR	R0			;CLEAR OFFSET TO DMP11 TRIB. ANSWERS
	CLR	R2			;CLEAR NUMBER OF DMP11 CONTROLLERS
DMPCNT:	CMP	#3.*15.,R0		;ARE WE PAST 3 BYTES BY 16 CONTROLLERS
	BLO	DMPOUT			;YES, GET OUT OF THE LOOP
	CMPB	#'9,XD0UN(R0)		;IS THERE A NUMBER FOR THIS CONTROLLER
	BLO	DMPOUT			;NO, ALL DONE, GET OUT OF THE LOOP
	CLR	R1			;CLEAR THE STORAGE REGISTER
	MOVB	XD0UN(R0),R1		;GET THE 10'S DIGIT
	SWAB	R1			;PUT IT IN THE HIGH BYTE
	BISB	XD0UN+1(R0),R1		;GET THE UNITS DIGIT
	CMP	#"00,R1			;IS THERE A VALUE
	BHIS	DMPOUT			;NO, GET OUT OF THE LOOP
	INC	R2			;INCREMENT THE NUMBER OF CONTROLLERS
	ADD	#3,R0			;MOVE TO THE NEXT CONTROLLER
	BR	DMPCNT			;CHECK THAT CONTROLLER

DMPOUT:	CALL	CHGDEC			;CONVERT NUMBER (IN R2) TO ASCII
	MOV	R2,ADMP11		;STORE THE NUMBER OF CONTROLLERS
	BR	22$			;CONTINUE TO THE PAPER-TAPES

22$:	MOVB	TMSCP,AMSCP		;MOVE IN THE MSCP SUPPORT	;030

	CLR	ASKTMS			;INIT ALWAYS-ASK-FOR-TMSCP FLAG	;013
	MOV	TTMSCP,R2		;GET THE NUMBER OF TMSCP TAPES	;013
	CMP	#99.,R2			;DID WE FIND ANY IN THE SIL	;013
	BNE	26$			;YES, GO MOVE IT IN		;013
	INC	ASKTMS			;ASK FOR TMSCP UNCONDITIONALLY	;013
	BR	30$			;CONTINUE			;013

26$:	MOV	#ATMSCP,R1		;GET THE ADDRESS OF THE ANSWER
	CALL	CSRXX			;PUT IN THE ASCII OF THE ANSWER

30$:	MOV	#ASILNK,R1		;ADDRESS OF SIMULTANEOUS IBM LINKS
	MOV	AIBMI,R2		;THE VALUE OF THE SIM. IBM LINKS
	BNE	301$			;We got something, good		;019
	MOVB	TKMC11,(R1)+		;Nothing, so use the KMC value	;019
	MOVB	TKMC11+1,(R1)		;In both places			;019
	BR	302$			;And join up			;019

301$:	CALL	CSRXX			;PUT IN THE ASCII OF THE ANSWER
302$:	MOV	CNT.KB,R1		;LET'S FIGURE THE SMALL BUFFER COUNT;029
	INC	R1			;GET THE ACTUAL # OF KBs	;029
	MUL	DDS.KB,R1		;CALC THE TOTAL SIZE OF THE DDBs;029
	ADD	BUF.E,R1		;ADD IN BEGINNING OF FIRST RANGE;029
	SUB	BUF.S,R1		;SUBTRACT THE END OF THE RANGE	;029
	ADD	MBF.E,R1		;BEGINNING OF SECOND RANGE	;029
	SUB	MBF.S,R1		;END OF SECOND RANGE		;029
	ADD	#31.,R1			;ADD A ROUNDING FACTOR		;029
	CLR	R0			;SET UP FOR THE DIVISION
	DIV	#32.,R0			;GET THE ACTUAL NUMBER OF SMALL BUFFS
	MOV	R0,R1			;SET UP FOR ANOTHER DIVIDE
	CLR	R0			;CLEAR THE HIGH WORD
	DIV	#100.,R0		;R0=100'S DIGIT;R1=10 + UNITS DIGITS
	MOV	R0,R2			;SET UP TO CONVERT
	CALL	CHGDEC			;CONVERT IT TO ASCII
	MOV	R2,ASBUF		;STORE THE 100'S DIGIT
	MOV	R1,R2			;SET UP TO CONVERT THE 10 + UNITS
	CALL	CHGDEC			;CONVERT THAT INTO ASCII
	MOV	R2,ASBUF+2		;PUT THAT INTO STORAGE

	CMPB	#'Y,C26			;WAS THE CARD DECODE TABLE CR26
	BNE	31$			;NO, CHECK FOR CR29
	MOV	#"02,ACDCOD		;YES, MOVE IN FIRST HALF OF "026"
	MOV	(PC)+,@(PC)+		;MOVE IN THE SECOND HALF + TERMINATOR
	.ASCII	%6%<CR>			;THE "6" + CARRIAGE RETURN
	.WORD	ACDCOD+2		;WHERE TO PUT IT
31$:	CMPB	#'Y,C29			;WAS THE CARD DECODE TABLE CR29
	BNE	32$			;NO, CHECK FOR CR1401
	MOV	#"02,ACDCOD		;YES, MOVE IN FIRST HALF OF "029"
	MOV	(PC)+,@(PC)+		;MOVE IN THE SECOND HALF + TERMINATOR
	.ASCII	%9%<CR>			;THE "9" + CARRIAGE RETURN
	.WORD	ACDCOD+2		;WHERE TO PUT IT
32$:	CMPB	#'Y,C1401		;WAS THE CARD DECODE TABLE CR1401
	BNE	35$			;NO, EITHER ANSI OR NO CARD READER;018
	MOV	#"14,ACDCOD		;YES, MOVE IN FIRST HALF OF "1401"
	MOV	#"01,ACDCOD+2		;MOVE IN THE SECOND HALF

35$:	TST	ARJDEV			;WAS THERE A RJ2780 DEVICE	;025
	BNE	45$			;YES, CONTINUE
	MOV	#"??,ARJDEV		;NO, SET IT TO UNKNOWN
45$:	MOV	#RJMOD,R5		;Point to 2780 phase name	;025
	MOV	#"N ,ARJ278		;DEFAULT TO NO RJ2780
	CALL	SILSCN			;CHECK FOR RJ2780
	BCS	50$			;NO RJ2780
	MOV	#"Y ,ARJ278		;YES RJ2780

50$:	MOVB	TRK11,ARK11		;MOVE IN THE FIRST DIGIT	;013
	MOVB	TRK11+1,ARK11+1		;MOVE IN THE SECOND DIGIT	;013

	MOVB	TRX01,ARX01		;MOVE IN THE FIRST DIGIT	;013
	MOVB	TRX01+1,ARX01+1		;MOVE IN THE SECOND DIGIT	;013

	MOVB	TTU16,ATU16		;MOVE IN THE FIRST DIGIT	;013
	MOVB	TTU16+1,ATU16+1		;MOVE IN THE SECOND DIGIT	;013

	MOVB	TTU10,ATU10		;MOVE IN THE FIRST DIGIT	;013
	MOVB	TTU10+1,ATU10+1		;MOVE IN THE SECOND DIGIT	;013

	MOVB	TRP04,ARP04		;MOVE IN THE FIRST DIGIT	;013
	MOVB	TRP04+1,ARP04+1		;MOVE IN THE SECOND DIGIT	;013

	MOVB	TRL11,ARL11		;MOVE IN THE FIRST DIGIT	;013
	MOVB	TRL11+1,ARL11+1		;MOVE IN THE SECOND DIGIT	;013

	MOVB	TRK06,ARK06		;MOVE IN THE FIRST DIGIT	;013
	MOVB	TRK06+1,ARK06+1		;MOVE IN THE SECOND DIGIT	;013

	MOVB	TRM03,ARM03		;MOVE IN THE FIRST DIGIT	;013
	MOVB	TRM03+1,ARM03+1		;MOVE IN THE SECOND DIGIT	;013

150$:	CMPB	#'X,ARBSEK		;OVERLAPPED SEEK FOR RP04/5/6?
	BNE	160$			;NO, CONTINUE
	CMP	#"00,TRP04		;ARE THERE ANY RP04/5/6?
	BEQ	155$			;NO, GO MOVE IN A "Y "
	MOVB	#'N,ARBSEK		;IT IS NO, SO PUT IT IN
	BR	160$			;CONTINUE

155$:	MOVB	#'Y,ARBSEK		;PUT IN A "Y " IN CASE THEY ADD IT

160$:	CMPB	#'X,ARKSEK		;OVERLAPPED SEEK FOR RK05?
	BNE	170$			;NO, CONTINUE
	CMP	#"00,TRK11		;ARE THERE ANY RK05'S IN THE MONITOR?
	BEQ	165$			;NO, GO MOVE IN A "Y "
	MOVB	#'N,ARKSEK		;IT IS NO, SO PUT IT IN
	BR	170$			;CONTINUE

165$:	MOVB	#'Y,ARKSEK		;PUT IN A "Y " IN CASE THEY ADD IT

170$:	CMPB	#'X,ARLSEK		;OVERLAPPED SEEK FOR RL01/2?
	BNE	180$			;NO, CONTINUE
	CMP	#"00,TRL11		;ARE THERE ANY RL01/2?
	BEQ	175$			;NO, GO MOVE IN A "Y "
	MOVB	#'N,ARLSEK		;IT IS NO, SO PUT IT IN
	BR	180$			;CONTINUE

175$:	MOVB	#'Y,ARLSEK		;PUT IN A "Y " IN CASE THEY ADD IT

180$:	CMPB	#'X,ARMSEK		;OVERLAPPED SEEK FOR RK06/7?
	BNE	200$			;NO, CONTINUE			;030
	CMP	#"00,TRK06		;ARE THERE ANY RK06/7?
	BEQ	185$			;NO, GO MOVE IN A "Y "
	MOVB	#'N,ARMSEK		;IT IS NO, SO PUT IT IN
	BR	200$			;CONTINUE			;030

185$:	MOVB	#'Y,ARMSEK		;PUT IN A "Y " IN CASE THEY ADD IT

200$:	CMPB	#'X,ARRSEK		;OVERLAPPED SEEK FOR RM03/5?
	BNE	210$			;NO, CONTINUE
	CMP	#"00,TRM03		;ARE THERE ANY RM03/5?
	BEQ	205$			;NO, GO MOVE IN A "Y "
	MOVB	#'N,ARRSEK		;IT IS NO, SO PUT IT IN
	BR	210$			;CONTINUE

205$:	MOVB	#'Y,ARRSEK		;PUT IN A "Y " IN CASE THEY ADD IT

210$:	MOVB	TTS11,ATS11		;MOVE IN THE FIRST DIGIT	;013
	MOVB	TTS11+1,ATS11+1		;MOVE IN THE SECOND DIGIT	;013

	MOVB	TLP,ALP			;MOVE IN THE FIRST DIGIT	;013
	MOVB	TLP+1,ALP+1		;MOVE IN THE SECOND DIGIT	;013

	MOVB	TDMC11,ADMC11		;MOVE IN THE FIRST DIGIT	;013
	MOVB	TDMC11+1,ADMC11+1	;MOVE IN THE SECOND DIGIT	;013

	MOVB	TKMC11,AKMC11		;MOVE IN THE FIRST DIGIT	;013
	MOVB	TKMC11+1,AKMC11+1	;MOVE IN THE SECOND DIGIT	;013

	MOVB	TCD,ACD			;MOVE IN THE CD11'S		;013

	MOVB	TCR,ACR			;MOVE IN THE CR11'S		;013

	SKIP				;MOVE ON FOR NOW

BADSIL:	MOV	IOSTS,R0		;GET THE ERROR NUMBER
	TST	R0			;IS THERE AN ACTUAL RSTS ERROR?
	BEQ	PRTERR			;NO, DON'T PRINT THE RSTS ERROR
	TELL				;PRINT A BLANK LINE
	.MESS
	.ASCII	<CR><LF>
	MESS.
	EMT	364			;PRINT THE ERROR MESSAGE
PRTERR:	TELL				;TELL THE USER ABOUT THE ERROR
	.MESS
	.ASCII	<CR><LF>
	.ASCII	%This file is not a valid RSTS/E monitor.%<CR><LF>
	MESS.
	CALLX	CLOSE,R5,LNKSIL		;CLOSE THIS MONITOR FILE
	CLR	OPNINT			;ALLOW US TO READ INIT AGAIN
	JMP	SETDEF			;START FROM THE BEGINNING

SILERR:	MOV	IOSTS,R0		;GET THE ERROR NUMBER
	TST	R0			;IS THERE AN ACTUAL RSTS ERROR?
	BEQ	PRTER2			;NO, DON'T PRINT THE RSTS ERROR
	TELL				;PRINT A BLANK LINE
	.MESS
	.ASCII	<CR><LF>
	MESS.
	EMT	364			;PRINT THE ERROR MESSAGE
PRTER2:	TELL				;TELL THE USER ABOUT THE ERROR
	.MESS
	.ASCII	<CR><LF>
	.ASCII	%Error opening template monitor.%<CR><LF>
	MESS.
	JMP	TMPMON			;GO BACK TO THE TEMPLATE MONITOR

	TMPORG	Q1DATA
SILDEV:	.BLKW	2			;TEMP AREA FOR XLATE DEVICE TO RAD-50
TMPUNT:	.WORD	0			;TEMP AREA FOR THE UNIT NUMBER	;023
OPNINT:	.WORD	0			;INIT FILE READ
C26:	.WORD	0			;TEMP AREA FOR CARD DECODE TBL CR26
C29:	.WORD	0			;TEMP AREA FOR CARD DECODE TBL CR29
C1401:	.WORD	0			;TEMP AREA FOR CARD DECODE TBL CR1401
TMSCP:	.ASCII	%N %			;TEMP AREA FOR MSCP DISKS	;020
TTMSCP:	.WORD	99.			;TEMP AREA FOR # OF TMSCP TAPES	;013
TRP04:	.ASCII	%00%			;TEMP AREA FOR NUMBER OF RP04/5/6'S
TRL11:	.ASCII	%00%			;TEMP AREA FOR NUMBER OF RL01/2'S
TRK06:	.ASCII	%00%			;TEMP AREA FOR NUMBER OF RK06/7'S
TRM03:	.ASCII	%00%			;TEMP AREA FOR NUMBER OF RM03/5'S
TRK11:	.ASCII	%00%			;TEMP AREA FOR NUMBER OF RK05'S
TRX01:	.ASCII	%00%			;TEMP AREA FOR NUMBER OF RX01/2'S
TTU16:	.ASCII	%00%			;TEMP AREA FOR NUMBER OF TU16'S
TTU10:	.ASCII	%00%			;TEMP AREA FOR NUMBER OF TU10'S
TTS11:	.ASCII	%00%			;TEMP AREA FOR NUMBER OF TS11'S
TLP:	.ASCII	%00%			;TEMP AREA FOR NUMBER OF LP'S
TDMC11:	.ASCII	%00%			;TEMP AREA FOR NUMBER OF DMC11'S
TKMC11:	.ASCII	%00%			;TEMP AREA FOR NUMBER OF KMC11'S
TCD:	.ASCII	%N %			;TEMP AREA FOR NUMBER OF CD11'S
TCR:	.ASCII	%N %			;TEMP AREA FOR NUMBER OF CR11'S
	.EVEN
	UNORG

GLOBAL	<SILNAM,SILFNM,ASILNM,SILNM1,SILNM2,DEFLAG,LNKSIL,ARJ278>	;025
GLOBAL	<CHGDEC,BUF.E,BUF.S,MBF.E,MBF.S,AMSCP,AIBMI,ASILNK,ASBUF,AUTOAN>
GLOBAL	<ADMP11,XD0UN,ACDCOD,ARBSEK,ARKSEK,ARLSEK,ARMSEK,ARRSEK>	;030
GLOBAL	<ARP04,ARK11,ARL11,ARK06,ARM03,ADMC11,AKMC11,ACD,ACR>		;030
GLOBAL	<ATS11,ALP,ATMSCP,ASKTMS,DDS.KB,CNT.KB>				;029

.TAG
NEWMON:	MOV	#ARSTS,R1		;SET THE AUTO ANSWER
	INC	DEFLAG			;A GUESS
	CLR	PRTDEF		;INSURE THE PRINT DEFAULTS FLAG IS CLEARED
	CLR	SUPSED		;CLEAR THE SUPERSEDE EXISTING MONITOR FLAG
	CLR	SYSDSK			; DEFAULT TO A NON-SYSTEM DISK
	CLR	LSTMAP			; DEFAULT TO NO MAPS CREATED	;016
	CLR	BASLVL			; DEFAULT TO NOT DOING A BASELEVEL;017

	ASK
	.MESS
	.ASCII	<CR><LF>
	.ASCII	%The new monitor will have a name of from%<CR><LF>
	.ASCII	%1 to 6  alphanumeric  characters  and  a%<CR><LF>
	.ASCII	%filetype of "SIL".  Please  specify  the%<CR><LF>
	.ASCII	%name you want.%<CR><LF>
	ME.SS
	.ASCII	<CR><LF>
	.ASCII	%New Monitor name ?%
	MESS.

	BR	BCKMON			;USER TYPED ESCAPE
	CLRB	10$			;SET UP FOR /M SWITCH TEST	;016+
	CALLX	SWSCAN,R5		;SCAN FOR HIDDEN SWITCHES
	.BYTE	'M			;/M
10$:	.BYTE	0			;WHERE TO STORE THE PRESENCE FLAG
	.BYTE	'B			;/B				;017
11$:	.BYTE	0			;WHERE TO STORE THE PRESENCE FLAG ;017
	.WORD	0			;END OF SWITCH TEST
	LOOP				;BAD SWITCH
	TSTB	10$			;/M?
	BEQ	20$			;NO
	INC	LSTMAP			;YES, SET THE INDICATOR
20$:	TSTB	11$			;/B?				;017+
	BEQ	30$			;NO
	INC	BASLVL			;YES, SET THE INDICATOR		;017-
30$:	CALLX	NAME,R5,MONNAM		;CHECK OUT AND STORE THE NAME	;016-
	LOOP				;BAD NAME
	BR	CHKNEW			;OKAY, CONTINUE

BCKMON:					; USER TYPED ESCAPE
	CLR	OPNINT			;ALLOW US TO READ INIT AGAIN
	JMP	SETDEF			;START FROM THE BEGINNING

CHKNEW:	MOV	#3,R0			;SET UP TO MOVE 6 CHARACTERS
	MOV	#MONNAM,R1		;FROM ADDRESS
	MOV	#TMPNAM,R2		;TO ADDRESS
100$:	MOV	(R1)+,(R2)+		;MOVE IN TWO CHARACTERS AT A TIME
	SOB	R0,100$			;NEXT TWO CHARACTERS
	MOV	#SYSLOG,R0		; GET THE ADDRESS OF THE LOGICAL
	EMT	365			; FSS IT TO GET THE DEVICE AND PPN
	TST	XRB+10			; WAS THE LOGICAL DEFINED?
	BPL	110$			; YES, GO EXTRACT IT
	MOV	#1,@54			; NO, GO LOOK FOR IT IN [0,1]
	MOV	#^RSY0,SILFNM		;  ON SY0:
	INC	SYSDSK			;FLAG THAT WE'RE USING THE SYSTEM DISK
	BR	130$			; GO TRY TO OPEN IT

110$:	MOV	FIRQB+FQPPN,TARPPN	; SAVE THE PPN
	MOV	FIRQB+FQDEV,TARDSK	; SAVE THE DEVICE NAME
	MOV	#60,TARDSK+2		; DEFAULT TO UNIT NUMBER 0
	CLRB	TARDSK+3		; .ASCIZ TERMINATE THE STRING
	MOV	FIRQB+FQDEVN,TMPUNT	;STORE THE UNIT NUMBER AND FLAG	;023
	MOV	#21.,R0			;SET UP TO CLEAR PART OF THE FIRQB;023
120$:	CLRB	FIRQB(R0)		; CLEAR THIS BYTE		;023
	SOB	R0,120$			; CONTINUE UNTIL ALL CLEARED	;023
	MOV	#FIRQB+FQFUN,R0		; SET UP TO STUFF THE FIRQB
	MOVB	#UU.ATR,(R0)+		; READ/WRITE ATTRIBUTE FUNCTION
	MOVB	#-4,(R0)		; READ DISK PACK ATTRIBUTE SUBFUNCTION
	EMT	377			; PREPARE TO DO A MONITOR DIRECTIVE
	.UUO				; DO IT
	TSTB	FIRQB+FQPROT		; IS IT THE SYSTEM DISK?
	BEQ	125$			; NO, CONTINUE
	INC	SYSDSK			; YES, FLAG IT AS SUCH
125$:	MOV	#TARDSK,R0		; POINT R0 TO THE DEVICE NAME
	EMT	365			; FSS IT TO GET THE RAD-50
	CMPB	#377,TMPUNT+1		;WAS A UNIT NUMBER SPECIFIED	;023
	BNE	127$			;NO, LEAVE THE DEFAULT OF 0 ALONE ;023
	CLR	R0			;CLEAR A HANDY REGISTER		;023
	MOVB	TMPUNT,R0		;MOVE IN THE UNIT NUMBER	;023
	ADD	R0,FIRQB+FQNAM1		;ADD IT TO THE DEVICE		;023
127$:	MOV	FIRQB+FQNAM1,SILFNM	; MOVE IN THE RAD-50 OF THE DEVICE
	MOV	TARPPN,@54		; MOVE IN THE PPN
130$:	MOV	#TMPNAM,R0		; POINT R0 TO THE MONITOR NAME
	EMT	365			; DO THE .FSS TO XLATE NAME TO RAD-50
	MOV	FIRQB+FQNAM1,SILFNM+2	; MOVE IN THE 1ST HALF OF THE FILENAME
	MOV	FIRQB+FQNAM1+2,SILFNM+4	; MOVE IN THE 2ND HALF
	MOV	#^RSIL,SILFNM+6		; A FILETYPE OF .SIL
	MOV	#SILFNM,LNKSIL+14	; RESTORE THE MONITOR NAME POINTER
	CALLX	OPEN,R5,LNKSIL		; OPEN THE MONITOR (HOPING TO FAIL)
	SKIP	CS			; IT'S NOT THERE, CONTINUE
	CALLX	CLOSE,R5,LNKSIL		; NOW CLOSE THE MONITOR FILE
	TST	SYSDSK			; IS THIS ON THE SYSTEM DISK?
	BEQ	SILSUP			; NO, GO PRINT WARNING
	CMP	SILFNM+2,INSIL1		; COMPARE THE 1ST HALF OF THE NAMES ;031
	BNE	SILSUP		; IT'S NOT THE INSTALLED SIL, GO PRINT WARNING
	CMP	SILFNM+4,INSIL2		; COMPARE THE 2ND HALF OF THE NAMES ;031
	BNE	SILSUP		; IT'S NOT THE INSTALLED SIL, GO PRINT WARNING
	TELL			; IT IS THE INSTALLED SIL, PRINT FATAL ERROR
	.MESS
	.ASCII	<CR><LF>
	.ASCII	%The installed monitor cannot be superseded.%<CR><LF>
	.ASCII	%Please specify a different monitor name.%<CR><LF>
	MESS.
	BR	BCKNEW			; ASK FOR IT AGAIN

SILSUP:	TELL				; PRINT A WARNING MESSAGE
	.MESS
	.ASCII	<CR><LF>
	.ASCII	%A  monitor by that  name already exists.%<CR><LF>
	.ASCII	%Do you wish to  supersede  this monitor?%<CR><LF>
	MESS.

	MOV	#ANSNO,R1		; DEFAULT IS NO
ASKSUP:	ASK
	.MESS
	ME.SS
	.ASCII	<CR><LF>
	.ASCII	%Supersede existing monitor ?%
	MESS.

	BR	BCKNEW			; USER TYPED ESCAPE
	CALLX	TESTNY,R5		; CHECK THE YES/NO RESPONSE
	BR	ASKSUP			; BAD RESPONSE
	BR	BCKNEW			; NO
	INC	SUPSED			; YES, FLAG THAT WE ARE SUPERSEDING
	SKIP				; CONTINUE

BCKNEW: JMP	NEWMON			; GO ASK FOR IT AGAIN

	TMPORG	Q1DATA
TMPNAM:	.ASCIZ	%RSTS  %
ARSTS:	.ASCII	%RSTS%<CR>
	.EVEN
SYSLOG:	.ASCIZ	/SYSTEM$$:/		; TARGET DISK [0,1] ACCOUNT
	.EVEN							
TARDSK:	.BLKW	2			; TEMP AREA FOR XLATE DEVICE TO RAD-50
TARPPN:	.BLKW	1			; TEMP AREA FOR PPN OF TARGET ACCOUNT
SYSDSK:	.WORD	0			; TARGET DISK IS SYSTEM DISK FLAG
	UNORG

GLOBAL	<DEFLAG,MONNAM,GENSYS,ANSNO,SILFNM,LNKSIL,INSIL1,INSIL2,SUPSED,LSTMAP>
GLOBAL	<BASLVL>

.TAG

	MOV	#ANSNO,R1		;ASSUME NO CONFIGURATION CHANGES
	TST	PRVMON			;ARE WE USING A PREVIOUS MONITOR?
	BEQ	5$			;NO, DON'T ALLOW THE DEFAULTS PRINTED
	INC	PRTDEF			;SET THE PRINT DEFAULTS FLAG

5$:	ASK
	.MESS
	.ASCII	<CR><LF>
	.ASCII	%The SYSGEN process has all  the  default%<CR><LF>
	.ASCII	%configuration  information.   If   these%<CR><LF>
	.ASCII	%defaults are valid, answer YES  to  this%<CR><LF>
	.ASCII	%question. If there will  be  changes  to%<CR><LF>
	.ASCII	%the information, type NO.%<CR><LF>
	.ASCII	<CR><LF>
	ME.SS
	.ASCII	<CR><LF>
	.ASCII	%Accept defaults ?%
	MESS.

	BR	BK2NEW		;USER TYPED ESCAPE
	CALLX	TESTNY,R5	;CHECK THE RESPONSE
	LOOP			;BAD
	BR	10$		;NO
	CLR	CHGCFG		;YES
10$:	CLR	PRTDEF		;CLEAR THE PRINT DEFAULTS FLAG
	SKIP
	
BK2NEW:	JMP	NEWMON		;USER TYPED UPARROW

GLOBAL	<CHGCFG,PRVMON,ANSNO,PRTDEF,DEFLAG>

;
;	NOTE - If CHGCFG is 0, then no further questions will
;	be able to be asked, unless the default for the question
;	is "?".  If a question is added after the Accept defaults
;	question, then the value of CHGCFG must be saved, a -1
;	moved into CHGCFG, ask the question, and then restore CHGCFG.
;
;	If CHGCFG is non-zero, then the ability of a question to
;	be asked depends on CHGSEC.  If CHGSEC is 0, then questions
;	cannot be asked, unless, as above, the default for the
;	question is "?".  If CHGSEC is non-zero, along with CHGCFG,
;	then questions will be able to be asked.  CHGSEC is set or
;	cleared at the beginning of SGNTTY, SGNDSK, SGNPRF, and
;	SGNOPT, depending on if the user wishes to accept the
;	defaults for the questions in that particular section.
;
;	This is the only prompt that uses PRTDEF.  When it is set
;	to a non-zero value, typing a question mark will print the
;	long form and will print the defaults.  In the future, the
;	value of PRTDEF could be used to select which set of defaults
;	to print.  For example, 1 to print all the defaults, 2 to print
;	the Terminal defaults, 3 for the Disk defaults, ...
;

.TAG
	CLR	PATMON		;ASSUME NO PATCHING
	DEC	PATMON		;ALWAYS PATCH

GLOBAL	<PATMON>

	MOV	#"SY,MPTDEV	;SYSTEM DISK IS PATCH FILE MEDIUM

GLOBAL	<MPTDEV>

	CLR	BPLFLG		;ASSUME ANSWER WILL BE NO
	CLR	DEBUGB		;ASSUME NO DEBUGGING WANTED

GLOBAL	<BPLFLG,DEBUGB>

	CLR	PATBAS		;ASSUME NO PATCHING

GLOBAL	<PATBAS>

	CLR	RSXFLG		;ASSUME NOT THE DEFAULT RTS
	INC	RSXFLG		;YES, IT IS THE DEFAULT

GLOBAL	<RSXFLG>

	CLR	PATRSX		;ASSUME NO PATCHING
	DEC	PATRSX		;WE WILL BE PATCHING ALWAYS

GLOBAL	<PATRSX,DEFLAG>

	MOV	#"SY,RSXDEV	;SYSTEM DISK IS THE DISTRO DEVICE

GLOBAL	<RSXDEV>

	RETURN			;ALL DONE, GO BACK TO THE ROOT SEGMENT

.SBTTL	READ THE INIT FILE

.ENABL	LSB

RDINIT:	MOV	#1,@54		;INIT.SYS IS IN [0,1]
	MOV	#LNKINT+24,LNKINT+14 ;RESTORE THE INIT NAME POINTER
	CALLX	OPEN,R5,LNKINT	;OPEN THE INIT.SYS FILE
	BCC	.+6		;NO ERROR, SO CONTINUE
	JMP	RDERR		;ERROR, GO GET OUT OF HERE
	MOV	#BLKBUF,R4	;GET BUFFER ADDRESS
	CLR	R2		;READING BLOCK 0
	CALLX	READ,R5,LNKINT	;GO READ IT
	BCC	.+6		;NO ERROR, SO CONTINUE
	JMP	RDERR		;ERROR, GO GET OUT OF HERE
	MOV	BLKBUF+LOCDEV,DSKDEV ;GET POINTER TO DEVICE TABLE
	MOV	BLKBUF+LOCCSR,DSKCSR ;AND CSR TABLE
	MOV	BLKBUF+LOCTYP,DSKTYP ;AND TYPE TABLE
	MOV	BLKBUF+LOCHWR,DSKHWR ;AND HARDWARE TABLE
	MOV	BLKBUF+LOCSIL,SILTBL ;AND SIL NAME TABLE

;   GET THE CPU OPTIONS

	MOV	#CPUB,R5	;POINT TO THE START OF OUR HARWARE TABLE
20$:	MOV	(R5)+,R2	;GET THE OFFSET
	MOV	(R5)+,R1	;AND POINTER TO AUTO ANSWER
	CALL	GETHWR		;NOW GET THE HARDWARE WORD FROM INIT
	CALL	HWRPRE		;AND GO PROCESS IT
	MOV	(R5)+,R1	;GET THE SECOND HALF
	BEQ	30$		;ZERO MEANS THERE WAS NONE
	SWAB	R4		;CHECK THE LOW BYTE
	CALL	HWRPRE		;AND GO PROCESS IT
30$:	CMP	R5,#CPUE	;ARE WE AT THE END OF THE TABLE
	BNE	20$		;NO. LOOP
	TST	MONFLG		;ARE WE GENING A MONITOR
	BEQ	110$		;NO. SO WE ARE DONE

GLOBAL	<BLKBUF,MONFLG,LNKINT>

	TMPORG	Q1DATA
SILTBL::	.WORD 0		;POINTER TO SIL NAME TABLE
	UNORG

;	GET THE INSTALLED SIL NAME

	MOV	SILTBL,R3	;GET POINTER TO SIL NAME TABLE
	CLR	R2		;SET UP FOR DIVIDE
	DIV	#512.,R2	;RESULT=BLOCK #; REMAINDER=OFFSET IN BLOCK
	MOV	R3,R5		;SAVE THE OFFSET
	ADD	#BUFDEV,R5	;MAKE IT A REAL LOCATION
	MOV	#BUFDEV,R4	;GET BUFFER LOCATION
	CALLX	READ,R5,LNKINT	;READ THE BLOCK
	BCC	.+6		;NO ERROR, SO CONTINUE
	JMP	RDERR		;ERROR, GO GET OUT OF HERE
	MOV	(R5)+,-(SP)	;SAVE THE FIRST WORD
	CMP	R5,#BUFDEV+510.	;ARE BOTH WORDS IN THIS BLOCK?
	BLO	35$		;YES, GO GET THEM
	INC	R2		;SET UP TO GET NEXT BLOCK
	CLR	R3		;OFFSET = ZERO
	CALLX	READ,R5,LNKINT	;READ THE BLOCK
	BCC	.+6		;NO ERROR, SO CONTINUE
	JMP	RDERR		;ERROR, GO GET OUT OF HERE
	MOV	#BUFDEV,R5	;GET ADDRESS TO SECOND WORD
35$:	MOV	(R5),SILNM2	;STORE THE SECOND WORD
	MOV	(SP)+,SILNM1	;STORE THE FIRST WORD
	MOV	SILNM1,INSIL1	;Store it again for comparing against	;031
	MOV	SILNM2,INSIL2	;  what they type for new monitor name	;031

;   PROCESS THE DEVICE TABLES

	MOV	DSKDEV,R3	;GET POINTER TO START OF INIT DEVICE TABLE
	CLR	R2		;SET UP FOR DIVIDE
	DIV	#512.,R2	;RESULT=BLOCK #; REMAINDER=OFFSET IN BLOCK
	MOV	R3,R5		;SAVE THE OFFSET
	ADD	#BUFDEV,R5	;MAKE IT A REAL LOCATION
40$:	MOV	#BUFDEV,R4	;GET BUFFER LOCATION
	CALLX	READ,R5,LNKINT	;READ THE BLOCK
	BCS	RDERR		;QUIT IF AN ERROR
	MOV	R2,BLKDEV	;SAVE THE BLOCK NUMBER
50$:	CMP	R5,#BUFEND-PK.LNG ;IS THE WHOLE PACKET IN THE BUFFER
	BLOS	70$		;YES
	MOV	R5,R0		;NO COPY POINTER TO START OF PACKET
	SUB	#BUFEND,R5	;HOW MANY ARE WE MISSING
	ADD	#BUFDEV,R5	;PLACE TO MOVE PARTIAL PACKET SO IT
				;   WILL MATCH UP WITH THE REST
	MOV	R5,R1		;COPY IT
60$:	MOV	(R0)+,(R1)+	;MOVE A WORD
	CMP	R1,#BUFDEV	;ARE WE DONE.
	BLO	60$		;NO. LOOP
	MOV	BLKDEV,R2	;GET OLD BLOCK NUMBER
	INC	R2		;BUMP IT
	BR	40$		;AND GO READ THE NEW BLOCK

70$:	TST	(R5)		;ARE WE DONE
	BEQ	110$		;YES
	MOV	#DEVICE,R0	;NO. GET START OF OUR HARWARE TABLE
80$:	CMP	PK.NAM(R5),(R0)+ ;ARE THEY POINTING TO THE SAME DEVICE
	BEQ	90$		;YES
	CMP	(R0)+,(R0)+	;NO. SKIP TWO WORDS FOR OUR NEXT DEVICE
	TST	(R0)		;IS THE LIST EXHAUSTED
	BNE	80$		;NO. LOOP
	BR	100$		;YES. GIVE UP ON THIS ONE

90$:	MOV	(R0)+,R1	;WE GOT A MATCH. GET THE AUTO ANSWER ADDRESS
	MOVB	#'0,(R1)	;INITIALIZE THE ANSWER TO 0
	MOVB	(R1),1(R1)	;THAT IS 00
	MOV	PK.CSO(R5),R2	;GET THE TABLE OFFSET
	CALL	GETCSR		;GET THE CSR
	CALL	@(R0)		;GO PROCESS THIS ENTRY
100$:	ADD	#PK.LNG,R5	;POINT TO THE NEXT PACKET
	BR	50$		;AND LOOP

GLOBAL	<LNKINT>

RDERR:	MOV	IOSTS,-(SP)	;SAVE THE ERROR NUMBER
	TELL			;PUT SOME SPACE IN THE PRINTOUT
	.MESS
	.ASCII	<CR><LF>
	MESS.
	MOV	(SP)+,R0	;GET THE SAVED ERROR
	EMT	364		;TELL THE USER
	TELL
	.MESS
	.ASCII	<CR><LF>
	.ASCII	%Error  reading file "SY0:[0,1]INIT.SYS".%<CR><LF>
	.ASCII	%Hardware auto answers will be disabled.%<CR><LF><LF>
	MESS.
	MOV	#-1,AUTOAN	;SET NO AUTO ANSWERS
110$:	CALLX	CLOSE,R5,LNKINT	;CLOSE INIT.SYS
120$:	RETURN			;RETURN

	GLOBAL	<AUTOAN>
.DSABL	LSB

.SBTTL	SUBROUTINES TO DETERMINE HARDWARE CONFIGURATION FROM INIT TABLES

;   ALL THESE ROUTINES ARE CALLED WITH:
;	R1--> AUTO ANSWER
;	R2= TABLE OFFSET (INIT)
;	R4= CONTENTS OF CSR TABLE
;	R5--> DEVTBL (INIT)
;	SYSGEN AUTOANSWER SET TO 00
;	Z BIT SET IF THERE IS NO CSR
;
;	ONLY R5 NEED BE PRESERVED

;   GET THE HIGHEST DISK UNIT NUMBER FOR A DISK

DISKNO:	BEQ	30$		;BRANCH IF NO CONTROLLER
	CALL	GETTYP		;GET THE DEVICE TYPE WORD
10$:	TST	R4		;ARE THERE ANY DRIVES THERE?
	BEQ	30$		;NO. THEN WE'RE DONE.
	INCB	1(R1)		;YES. ADD 1 TO COUNTER
	ASR	R4		;SHIFT OUT LOW ORDER BIT
	BR	10$		;LOOP BACK.
30$:	RETURN			;RETURN

;   ROUTINE TO CHECK FOR CONTROLLER OR HARDWARE PRESENT ONLY

.ENABL	LSB

HWRPRE:	TST	R4		;SEE IF THE HARDWARE IS THERE
	BMI	20$		;NEGATIVE MEANS ITS NOT THERE
	BR	10$		;OTHERWISE IT HAS TO BE THERE

PRESNT:	BEQ	20$		;ITS NOT THERE
10$:	MOVB	#'Y,(R1)+	;SET ANSWER TO "Y "
	MOVB	#' ,(R1)	;TWO BYTES
	BR	30$		;DONE

20$:	MOVB	#'N,(R1)+	;SET ANSWER TO "N "
	MOVB	#' ,(R1)	;TWO BYTES
30$:	RETURN			;RETURN

.DSABL	LSB

;   FIND THE NUMBER OF CSR'S

CSRNO:	MOVB	PK.MXU(R5),R0	;GET THE MAXIMUM NUMBER OF UNITS
10$:	CALL	GETCSR		;GET THE CSR
	BEQ	30$		;BRANCH IF THERE IS NO CSR ENTRY
	CMPB	1(R1),#'9	;IS THE LAST DIGIT A 9
	BNE	20$		;NO
	MOVB	#'0-1,1(R1)	;YES. RESET IT
	INCB	(R1)		;BUMP 10'S DIGIT
20$:	INCB	1(R1)		;BUMP THE DIGIT
	TST	(R2)+		;BUMP THE OFFSET
	SOB	R0,10$		;LOOP
30$:	RETURN			;RETURN

;   THESE ROUTINES GET AN ENTRY FROM ONE OF THE INIT TABLES
;
;	CALL	GET---	(TYP,HWR,CSR)
;	R2= OFFSET
;
;	RETURN	R4=TABLE CONTENTS
;		R3 IS UNDEFINED
;

GETTYP:	MOV	DSKTYP,R3	;GET THE TABLE POINTER
	MOV	#BUFTYP-2,R4	;AND THE BLOCK NUMBER POINTER
	BR	GET2		;GO DO IT

GETHWR:	MOV	DSKHWR,R3	;GET THE TABLE POINTER
	BR	GET1		;AND GO DO IT

GETCSR:	MOV	DSKCSR,R3	;GET THE TABLE POINTER
GET1:	MOV	#BLKBUF-2,R4	;AND THE BLOCK NUMBER POINTER
GET2:	MOV	R2,-(SP)	;SAVE A REGISTER
	ADD	R2,R3		;GET LOCATION OF ENTRY
	CLR	R2		;SET UP FOR DIVIDE
	DIV	#512.,R2	;RESULT=BLOCK #; REMAINDER =OFFSET IN BLOCK
	CMP	R2,(R4)+	;SAME BLOCK?
	BEQ	10$		;YES
	MOV	R2,-2(R4)	;NO. SAVE NEW BLOCK NUMBER
	CALLX	READ,R5,LNKINT	;READ THE NEW BLOCK
	BCS	20$		;CARRY IS ON IF AN ERROR
10$:	ADD	R4,R3		;GET LOCATION OF ENTRY
	MOV	(SP)+,R2	;RESTORE R2
	MOV	(R3),R4		;GET THE TABLE ENTRY IN R4
	RETURN			;AND GO PROCESS IT

20$:	CMP	(SP)+,(SP)+	;ERROR IN READ. QUITTING. CLEAN THE STACK
	JMP	RDERR		;GO TELL THEM

	TMPORG	Q1DATA
DSKDEV:	.WORD	0		;POINTER TO INIT DEVICE TABLE
DSKCSR:	.WORD	0		;POINTER TO INIT CSR TABLE
DSKTYP:	.WORD	0		;POINTER TO INIT CSR TABLE
DSKHWR:	.WORD	0		;POINTER TO INIT HARDWARE TABLE
	.WORD	-1		;BLOCK NUMBER FOR FOLLOWING BUFFER
BUFTYP:	.BLKW	256.		;BUFFER FOR TYPE TABLE
	.BLKW	PK.LNG		;SPARE BUFFER TO LINK PARTIAL PACKET
BUFDEV:	.BLKW	256.		;BUFFER FOR DEVICE TABLE
BUFEND:				;END OF BUFFER
BLKDEV:	.WORD	0		;SAVED BLOCK # FOR DEVICE TABLE
	UNORG

GLOBAL	<BLKBUF,LNKINT>

;   DEVICE TABLES FOR AUTO ANSWERS

	TMPORG	Q1DATA                  

DEVICE:				;START OF THE LIST OF DEVICE NAMES
	HARDEV	"RF,PRESNT,ARF		;RF11
	HARDEV	"RS,DISKNO,ARS03	;RS03/04
	HARDEV	"RK,DISKNO,ARK11	;RK11/RK05			;013
	HARDEV	"RL,DISKNO,ARL11	;RL11/RL01/02
	HARDEV	"RM,DISKNO,ARK06	;RK06/07
	HARDEV	"RR,DISKNO,ARM03	;RM02/03/05/80
	HARDEV	"RB,DISKNO,ARP04	;RP04/05/06
	HARDEV	"RU,PRESNT,AMSCP	;MSCP controller UDA50		;020
	HARDEV	"MU,CSRNO,ATMSCP	;TMSCP controller		;012
	HARDEV	"TM,CSRNO,ATU10		;TU10,TE10,TS03
	HARDEV	"TU,DISKNO,ATU16	;TU16,TE16,TU45,TU77		;022
	HARDEV	"TS,CSRNO,ATS11		;TS11
	HARDEV	"DD,CSRNO,ADTII		;TU58 DECTAPE II
	HARDEV	"LP,CSRNO,ALP		;PRINTER
	HARDEV	"RX,CSRNO,ARX01		;RX01/02 FLOPPY
	HARDEV	"CR,PRESNT,ACR		;CR11 CARD READER
	HARDEV	"CD,PRESNT,ACD		;CD11 CARD READER
	HARDEV	"D1,PRESNT,ADUP		;DUP11
	HARDEV	"DP,PRESNT,ADP		;DP11
	HARDEV	"DU,PRESNT,ADU		;DU11
	HARDEV	"XM,CSRNO,ADMC11	;DMC11/DMR11
	HARDEV	"XD,CSRNO,ADMP11	;DMP11/DMV11
	HARDEV	"XK,CSRNO,AKMC11	;KMC11
	.WORD	0		;END OF PERIPHERAL LIST

CPUB:				;START OF CPU OPTION LIST
	CPUDEV	10,AFPU		;FLOATING POINT PROCESSOR
	CPUDEV	12,AFIS		;FIS OPTION
	CPUDEV	30,AQBU,AQBU	;Q-BUS OR NOT
CPUE:				;END OF OPTION LIST



	.SBTTL	SIL SYMBOL TABLE


MODTBL:	SILMOD	RSTS,	RSTSYM
	SILMOD	DSK,	DSKSYM
	.WORD	0			;End of table			;025

RJMOD:	SILMOD	RJ2780,	0						;025

RSTSYM:	SILSYM	BUF,	ADIRCC,	PREYN
	SILSYM	BUFEXT,	ADATCC,	PREYN
	SILSYM	CNT.CD,	TCD,	PREYN
	SILSYM	CNT.CR,	TCR,	PREYN
	SILSYM	CNT.DB,	TRP04,	CSRXX
	SILSYM	CNT.DD,	ADTII,	CSRXX
	SILSYM	CNT.DF,	ARF,	CSRXX
	SILSYM	CNT.DK,	TRK11,	CSRXX
	SILSYM	CNT.DL,	TRL11,	CSRXX
	SILSYM	CNT.DM,	TRK06,	CSRXX
	SILSYM	CNT.DR,	TRM03,	CSRXX
	SILSYM	CNT.DS,	ARS03,	CSRXX
	SILSYM	CNT.DU,	TMSCP,	PREYN					;020
	SILSYM	CNT.MU,	TTMSCP,	PREVAL					;012
	SILSYM	CNT.DX,	TRX01,	CSRXX
	SILSYM	CNT.II,	AIBMI,	PREVAL
	SILSYM	CNT.LP,	TLP,	CSRXX
	SILSYM	CNT.MM,	TTU16,	CSRXX
	SILSYM	CNT.MS,	TTS11,	CSRXX
	SILSYM	CNT.MT,	TTU10,	CSRXX
;	SILSYM	CNT.RJ,	
	SILSYM	CNT.XK,	TKMC11,	CSRXX
	SILSYM	CNT.XM,	TDMC11,	CSRXX
;	SILSYM	DDCTBL,	
	SILSYM	DDS.KB,	DDS.KB, PREVAL					;029
	SILSYM	CNT.KB,	CNT.KB,	PREVAL					;029
	SILSYM	EMLFQ$,	AEMTLG,	PREYN
;	SILSYM	IDX.XD,	
	SILSYM	JOBMAX,	AJBMAX,	CSRXX
	SILSYM	KGEMU,	AQRJ27,	PREYN
	SILSYM	LPDVRX,	ALPBEX,	PREYN
;	SILSYM	UCT.XD,	
	SILSYM	$$BUFE,	BUF.E,	PREVAL
	SILSYM	$$BUFS,	BUF.S,	PREVAL
	SILSYM	$$MBFS,	MBF.S,	PREVAL
	SILSYM	$$USEM,	MBF.E,	PREVAL
	SILSYM	$$2780,	ARJDEV,	PREVAL
	SILSYM	CR026,	C26,	PREYN
	SILSYM	CR029,	C29,	PREYN
	SILSYM	CR1401,	C1401,	PREYN
	SILSYM	XD0UN,	XD0UN,	CSRXX
	SILSYM	XD1UN,	XD1UN,	CSRXX
	SILSYM	XD2UN,	XD2UN,	CSRXX
	SILSYM	XD3UN,	XD3UN,	CSRXX
	SILSYM	XD4UN,	XD4UN,	CSRXX
	SILSYM	XD5UN,	XD5UN,	CSRXX
	SILSYM	XD6UN,	XD6UN,	CSRXX
	SILSYM	XD7UN,	XD7UN,	CSRXX
	SILSYM	XD8UN,	XD8UN,	CSRXX
	SILSYM	XD9UN,	XD9UN,	CSRXX
	SILSYM	XD10UN,	XD10UN,	CSRXX
	SILSYM	XD11UN,	XD11UN,	CSRXX
	SILSYM	XD12UN,	XD12UN,	CSRXX
	SILSYM	XD13UN,	XD13UN,	CSRXX
	SILSYM	XD14UN,	XD14UN,	CSRXX
	SILSYM	XD15UN,	XD15UN,	CSRXX
		.WORD 0,0,0,0
		.WORD 0,0,0,0
		.WORD 0,0,0,0
DSKSYM:	SILSYM	DBSEEK,	ARBSEK,	PREYN
	SILSYM	DKSEEK,	ARKSEK,	PREYN
	SILSYM	DLSEEK,	ARLSEK,	PREYN
	SILSYM	DMSEEK,	ARMSEK,	PREYN
	SILSYM	DRSEEK,	ARRSEK,	PREYN
		.WORD 0,0,0,0
		.WORD 0,0,0,0
		.WORD 0,0,0,0
		.WORD 0,0,0,0

	UNORG


.SBTTL	RAD50 CONVERSION TO ASCII

;+
; RADCNV - CONVERT RAD50 WORD TO ASCII
;
;	R0 =  RAD50 WORD
;	R4 -> LOCATION TO STORE ASCII STRING
;
;	CALL	RADCNV
;-

RADCNV::CALL	REGSAV,R5	;SAVE REGISTERS
	MOV	#40,R5		;FILLER IS SPACE FOR 0
	MOV	#110$,R1	;POINT TO TABLE OF DIVISORS
	MOV	R0,R3		;COPY THE WORD TO PRINT
40$:	CLR	R2		;CLEAR FOR DIVIDE
	DIV	(R1)+,R2	;DIVIDE
	;TST	R2		;IS THE RESULT A SPACE? (FROM DIVIDE)
	BNE	50$		;NO
	MOV	R5,R2		;YES, MAKE IT BLANK (MAYBE)
	BEQ	90$		;NO, IGNORE NULLS
	BR	70$		;YES, PRINT IT

50$:	CMP	R2,#26.		;ALPHABETIC?
	BHI	60$		;NO
	ADD	#'A-1,R2	;YES, MAKE IT ASCII
	BR	70$		;AND TYPE IT

60$:	MOVB	100$-27.(R2),R2	;GET SPECIAL CHARACTER OR DIGIT
70$:	MOVB	R2,(R4)+	;CONVERTING, STORE THIS CHARACTER

90$:	TST	(R1)		;ANY MORE TO DO?
	BNE	40$		;YES, LOOP ON IT
	CALL	REGRES,R5	;RESTORE REGISTERS
	RETURN

100$:	.ASCII	"$.?0123456789"	;RAD50 TRANSLATION FOR 27.-39.
	.EVEN

110$:	.WORD	50*50,50,1,0	;DIVISORS FOR RADIX 50 CONVERSION

GLOBAL	<REGSAV,REGRES>

.DSABL	LSB


	ORG	SILNDX		; SIL Index read/verify routine

.SBTTL	SILNDX - read SIL index into SILBUF, check for validity

;+
; SILNDX - Read SIL index into memory from open file, check for validity
;
;	CALL	SILNDX,R5
;
;	SIL index has been read into SILBUF
;	Z=1 if file is a valid SIL (i.e. BEQ valid)
;	Z=0 if file is not a SIL (i.e. BNE invalid)
;	R0 = number of blocks in SIL index
;	R1 destroyed
;-

SILNDX:	CLR	R1		; Start with the first block minus one	;027+
5$:	INC	R1		; Move on to the next block
	MOV	R1, R3		; Set up R3 to do the calculation
	DEC	R3		; Make it zero-based
	MOV	R3, R2		; That's the block number we want
	MUL	#512.,R3	; Figure out the byte offset
	ADD	#SILBUF,R3	; Add in the Buffer address
	MOV	R3, R4		; Put it where we need it
	CALLX	READ,R5,LNKSIL	; Go read it
	BCS	50$		; Error, go to error routine
	CMP	R1, #SI.NBL	; Have we gotten SI.NBL blocks yet?
	BLO	5$		; No, not yet				;027-
	MOV	#SILBUF,R0	; Point to index buffer
	CMP	(R0),#7		; How many entries does the SIL have ?
							.ASSUME SI.NUM EQ 0
	BLO	50$		; Less than minimum ??
	BEQ	10$		; Minimum # of entries => go check checksum
	CMP	(R0),#SI.NMD	; Does it have too many entries ?
	BHI	50$		; Yes => return Not Equal (it's invalid)
10$:	CLR	-(SP)		; Clear a word on the stack
20$:	MOV	(R0)+,R1	; Get a word of the index
	XOR	R1,(SP)		; Make a checksum
	CMP	R0,#SILBUF+SI.CHK+2 ; Was that the checksum word we just did ?
	BLO	20$		; Not yet
	TST	(SP)+		; Yes, is the result 0?
	BNE	50$		; No, error
	CMP	(R0)+,#^RSIL	; Well, make final check on SIL index
						.ASSUME SI.SIL EQ SI.CHK+2
	BNE	50$		; Return Not Equal if invalid
	MOV	SILBUF+SI.NUM,R1  ; Get number of entries in SIL index
	CLR	R0		; Zero a counter for index blocks
	INC	R0		; Increment index block counter for 1st block
	SUB	#SI.1ST,R1	;   and count the entries it could contain
	BLOS	40$		; That's it, one block.  => all done
25$:	INC	R0		; Increment index block counter for another block
	SUB	#SI.OTH,R1	;   and count the entries it could contain
	BHI	25$		; More entries to account for => continue
	MOV	R2,-(SP)	; Save a register
	MOV	#SILBUF+SI.MOR,R1  ; R1 -> beginning of index's second block
	MOV	#SILBUF+SI.RST,R2  ; R2 -> where to move it down to
30$:	MOV	(R1)+,(R2)+	   ; Move down one word
	CMP	R1,#SILBUF+SI.SIZ  ; Have we moved all possible index blocks ?
	BLO	30$		   ; No => go move another word
	MOV	(SP)+,R2	; Restore R2
40$:	SEZ			; Indicate goodness (BEQ will now succeed)
50$:	RETURN	R5

	GLOBAL	<SILBUF>	; I/O buffer is defined in base modules

.SBTTL	SILSCN - Scan SIL for module name

;+
; SILSCN - scan a SIL index for a named module
;
;	SILBUF must contain the SIL index block
;	R5 - POINTS TO RAD50 OF MODULE NAME
;	CALL	SILSCN
;
;	C=0	Module found, R0 -> SIL index entry
;	C=1	Module not found, R0 random
;	R1 is destroyed
;	R5 is incremented by 4 to move over the module name
;-

SILSCN:	MOV	#SILBUF,R0	; R0 -> SIL index block
	MOV	(R0)+,R1	; R1 = # of entries in SIL
10$:	CMP	(R0),(R5)	; Name match?
	BNE	20$		; No
	CMP	2(R0),2(R5)	; Both halves?
	BEQ	30$		; Yup, we got it
20$:	ADD	#SE.LEN,R0	; Bump R0 by size of SIL entry
	SOB	R1,10$		;  and try again
	SEC			; Indicate not found
30$:	BIT	(R5)+,(R5)+	; Skip over the name
	RETURN			;  and return

.SBTTL	SET UP DEFAULT ANSWERS SUBROUTINES

;	ROUTINE TO PUT A Y OR N IN DEFAULT ANSWER
;	IF GIVEN THE DEVICE PRESENT FLAG IN R2
;	R1 - ADDRESS OF DEFAULT ANSWER
;	R2 - DEVICE PRESENT FLAG

PREYN:	TST	R2		;IS THE DEVICE PRESENT?
	CALL	PRESNT		;TO BE ANSWERED IN ROUTINE PRESNT
	RETURN			;ALL DONE

;	ROUTINE TO PUT THE NUMBER OF UNITS FOR A
;	DEVICE IN ASCII IN THE DEFAULT ANSWER
;	R1 - ADDRESS OF DEFAULT ANSWER
;	R2 - DEVICE PRESENT FLAG

CSRXX:	PUSH	R3		;SAVE R3
	CALL	CHGDEC		;CHANGE THE INTEGER IN R2 TO ASCII
	MOVB	R2,(R1)+	;PUT THE FIRST NUMBER IN THE DEFAULT ANSWER
	SWAB	R2		;GET ACCESS TO THE SECOND NUMBER
	MOVB	R2,(R1)		;MOVE IN THE SECOND NUMBER
	POP	R3		;RESTORE R3
	RETURN			;ALL DONE

PREVAL:	MOV	R2,(R1)		;MOVE THE VALUE IN R2 TO THE ADDRESS IN R1
	RETURN			;THAT'S ALL


.SBTTL	SCAN STB OF NEW FILE FOR ALL REQUIRED SYMBOLS

.ENABL	LSB

SCANST:	PUSH	R5		;SAVE R5
	MOV	SE.STN(R0),R5	;R5 = NUMBER OF SYMBOLS IN RSTS STB
	MOV	SE.STB(R0),R2	;NEXT READ IS RSTS STB
	MOV	#-1,R0		;ALL DONE; FORCE A READ TO START SCANNING STB
40$:	CMP	R0,#BLKEND	;NEED TO READ?
	BLO	50$		;NO
	MOV	#BLKBUF,R4	;YES, POINT TO BUFFER FOR READ
	CALLX	READ,R5,LNKSIL	;READ IN AN STB BLOCK
	INC	R2		;INC THE BLOCK COUNTER FOR NEXT READ
	MOV	#BLKBUF,R0	;POINT TO FIRST SYMBOL IN BLOCK
50$:	MOV	@(SP),R4	;GET THE ADDRESS OF OUR SYMBOL TABLE
60$:	CMP	(R0),(R4)+	;IS THIS SYMBOL ONE OF OURS?
	BNE	70$		;NO
	CMP	2(R0),(R4)	;MAYBE...
	BEQ	80$		;YES, INCLUDE IT IN OUR TABLE
70$:	CMP	(R4)+,(R4)+	;NO, GO TO NEXT SYMBOL IN OUR TABLE
	TST	(R4)+		;ONE MORE POP
	BNE	60$		;NOT DONE YET WITH THE TABLE
	BR	90$		;YES, TRY THE NEXT SYMBOL IN THE STB

80$:	PUSH	R2		;SAVE R2
	TST	(R4)+		;MOVE TO THE ADDRESS OF THE DEFAULT ANSWER
	MOV	(R4)+,R1	;GET THE ADDRESS OF THE DEFAULT ANSWER
	MOV	6(R0),R2	;GET THE VALUE
	CALL	@(R4)+		;GO EXECUTE THE ROUTINE TO STORE THE VALUE
	POP	R2		;RESTORE R2
90$:	ADD	#10,R0		;POINT TO NEXT SYMBOL IN STB
	SOB	R5,40$		;TRY FOR MORE
	POP	R5		;RESTORE R5
	RETURN

GLOBAL	<LNKSIL,BLKBUF,BLKEND,CHGDEC>


	.SBTTL	INITIALIZE THE DEFAULT ANSWERS

INITSM:	INISYM	ADIRCC,	<N >
	INISYM	ADATCC,	<N >
	INISYM	TCD,	<N >
	INISYM	TCR,	<N >
	INISYM	TRP04,	<00>
;	INISYM	ADTII,	<00>
;	INISYM	ARF,	<00>
	INISYM	TRK11,	<00>
	INISYM	TRL11,	<00>
	INISYM	TRK06,	<00>
	INISYM	TRM03,	<00>
;	INISYM	ARS03,	<00>
	INISYM	TMSCP,	<N >						;020
	MOV	#99.,TTMSCP		;INITIALIZE THE TTMSCP TO 99.	;013
	INISYM	TRX01,	<00>
	INISYM	AIBMI
	INISYM	TLP,	<00>
	INISYM	TTU16,	<00>
	INISYM	TTS11,	<00>
	INISYM	TTU10,	<00>
;	INISYM	ADMP11,	<00>
	INISYM	TKMC11,	<00>
	INISYM	TDMC11,	<00>
	INISYM	AJBMAX,	<00>
	INISYM	AQRJ27,	<N >
	INISYM	ALPBEX,	<N >
	INISYM	AEMTLG,	<N >
	INISYM	DDS.KB							;029
	INISYM	CNT.KB							;029
	INISYM	BUF.E
	INISYM	BUF.S
	INISYM	MBF.S
	INISYM	MBF.E
	INISYM	ARJDEV
	INISYM	ARBSEK,	<X >
	INISYM	ARKSEK,	<X >
	INISYM	ARLSEK,	<X >
	INISYM	ARMSEK,	<X >
	INISYM	ARRSEK,	<X >
	INISYM	C26,	<00>
	INISYM	C29,	<00>
	INISYM	C1401,	<00>
	INISYM	XD0UN,	<00>
	INISYM	XD1UN,	<00>
	INISYM	XD2UN,	<00>
	INISYM	XD3UN,	<00>
	INISYM	XD4UN,	<00>
	INISYM	XD5UN,	<00>
	INISYM	XD6UN,	<00>
	INISYM	XD7UN,	<00>
	INISYM	XD8UN,	<00>
	INISYM	XD9UN,	<00>
	INISYM	XD10UN,	<00>
	INISYM	XD11UN,	<00>
	INISYM	XD12UN,	<00>
	INISYM	XD13UN,	<00>
	INISYM	XD14UN,	<00>
	INISYM	XD15UN,	<00>
	INISYM	ACDCOD,	<AN>		;PUT IN THE 1ST 2 CHAR OF "ANSI"
	INISYM	ACDCD2,	<SI>		;PUT IN THE 2ND HALF OF "ANSI"
	RETURN

	.END
