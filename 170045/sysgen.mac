TITLE	SYSGEN,<SYSGEN ROOT SEGMENT>,0A,10-MAY-91,JDM/GW/ABC/MJG/AWL/PRL/KCG/FEK/JJT/KPH

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	SYSGEN EDIT HISTORY
;+
; EDIT	BY	  DATE			REASON
;
;  01  DRP	28-NOV-80	Added FMS flag for FMS support.
;  02 RVR/DRP	15-DEC-80	Added support for DMV11/DMP11.
;  03  DRP	04-FEB-81	Added DECnet/E V2.0 support.
;  04  AWL      03-AUG-81       Removed DPHASE
;               06-OCT-81       Change default from DMV to DMP
;                               Remove storage for SMLBUF
;               29-OCT-81       Remove R.xxx flags for resident overlays
;  05  AWL      06-NOV-81       Add <FF> after copyright
;  06  AWL      16-NOV-81       Add patch space 
;  07  PRL	26-JAN-82	Add /A (APT) hidden switch flag
;  08  PRL	28-JAN-82	Add AUTOAN (Auto-answer) as global flag
;  09  PRL	01-FEB-82	Add RA80/UDA50 globals
;  10  PRL	01-FEB-82	Fix media part nos. for DECNET V2.0
;  11  PRL	04-FEB-82	Add autoanswer for DZ type prompt
;  12  PRL	24-Feb-82	Add test for phase restriction
;  13  PRL	23-Mar-82	Remove "small link" global SMLLNK
;  14  PRL	07-May-82	Removed test for phase restriction
;
;  --  KCG	08-Jul-82	Creation of 8.0 from 7.2 
;  15  KCG	20-Jul-82	Fix comments on PP11 & PR11
;				( punch and reader are now same ).
;				Add comments for RM80 on RM comments.
;				Add flag for DC11 removal ( for 9.0 )
;  16  KCG	15-Aug-82	Insert EML global symbol for emt logging
;  17  KCG	04-Oct-82	Change AUDA to AMSCP 
;  18  FEK	25-Aug-83	Add DHV/DHU remove 2741, change DZ
;  --  JJT	03-Apr-84	Creation of 9.0 from 8.0
; 019  KPH	26-Sep-84	Add MVR phase stuff
;				Remove resident overlay stuff
; 020  JJT	22-May-85	Add TMSCP
; 021  JJT	02-Jul-85	Add unconditional prompt with default
; 022  JJT	25-Jul-85	Allow comments on the answers
; 023  JJT	11-Nov-85	Allow Maps to be created
; 024  JJT	11-Nov-85	Allow comments with switches
; 025  JJT	05-Dec-85	Add a /Baselevel switch
; 026  JJT	06-Jan-86	V9.3 changes
; 027  JJT	06-Feb-86	Increase filename length from 20 to 30 chars.
; 028  KPH	11-Mar-86	Add a global for KMC support
; 029  JJT	12-Mar-86	Change MSCP question to a yes/no question
;
;			[RSTS V9.6]
;  030  KPH	05-Nov-87	Remove terminal driver stuff
;  031	JJT	24-Dec-87	Add ability to print directory of .SILs
;  032	JJT	03-Jun-88	Account for KBs in small buffers default
;
;			[RSTS V9.7]
;  033	JJT	05-Jan-89	Add monitor name to GLOBAL.COM
;  034	JJT	08-Jan-89	Add a speedometer gauge
;  035	JJT	22-Feb-90	Move SILNM1 and SILNM2 from SGNSRT to here
;-
PFXLST	=	1		;LIST THE PREFIX FILE

.ENABL	LC


.SBTTL	BEGINNING OF SYSTEM GENERATION

	.MCALL	.DELETE		;DEFINE MACRO TO DELETE FILES
	.MCALL	.SCCA		;DEFINE MACRO FOR CTRL/Z TRAPPING
	.MCALL	..V2..		;MACRO 2 EXPANSION

	..V2..

	DEFORG	Q0CODE		;ROOT SEGMENT CODE CSECT

MESNUM	=	0
MSGSEG	=	0
TAGNUM	=	0



.SBTTL	ENTRY FOR SYSTEM GENERATION

SYSGEN::CALL	SETSYS		;SET UP SYSTEM DISK AND ITS SIZE
	.DELETE	#DELBLK,#1,#GBLNAM ;DELETE ANY PREVIOUS GLOBAL.COM
	.SCCA	#CTRLZ,#1	;TRAP CTRL/Z'S
	DEC	CHGCFG		;ALLOW QUESTIONS
	DEC	CHGSEC		; TO BE ASKED
	CALLX	SGNSRT		;START UP

	CALL	CREATE,R5,LNKCFG ;OPEN CONFIG FILE FOR OUTPUT
	CALLX	SGNTTY		;TERMINAL INTERFACES
	CALLX	SGNDSK		;DISKS
	CALLX	SGNPRF		;OTHER PERIPHERALS
	CALLX	SGNOPT		;SYSTEM OPTIONS
	CALL	CLOSE,R5,LNKCFG	;CLOSE CONFIG FILE

;	CALLX	SGNANS		;PRINT OUT THE CONFIGURATION
OPNBAT:	CALL	CREATE,R5,LNKBAT;OPEN BATCH FILE FOR OUTPUT
	MOV	#TODAY,R0	;GET TODAY'S DATE
	MOV	#BATDAT,R1	; AND ITS STORAGE LOCATION
	MOV	#9.,R2		;THERE ARE 9 CHARACTERS
50$:	MOVB	(R0)+,(R1)+	;MOVE A CHARACTER   
	SOB	R2,50$		;LOOP

	MOVB	TODAY+7,BATYR	;MOVE CURRENT YEAR TO COPYRIGHT
	MOVB	TODAY+10,BATYR+1;OFFSETS ARE OCTAL

	JSR	R5,@#WRITE	;GO TO THE WRITE ROUTINE
	.WORD	LNKBAT		;WRITE TO THE SYSGEN.COM FILE		;021


	.MESS
	.ASCII	%$!%<HT>
	.ASCII	%SYSGEN.COM - COMMAND PROCEDURE TO CREATE RSTS MONITOR %
BATDAT:	.ASCII	%---------%<CR><LF>
	.ASCII	%$! %<CR><LF>
	.ASCII	%$! %<CR><LF>
	.ASCII	%$! %<11><11>%COPYRIGHT (c) 1974, 19%
BATYR:	.ASCII	%??%
	.ASCII	% BY%<CR><LF>
.ASCII	%$!%<11>%DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.%<CR><LF>
.ASCII	%$!%<CR><LF>
	MESS.


GENBAT:	CALLX	SGNBAT		;BATCH FILE GENERATION
	CALL	CLOSE,R5,LNKBAT	;CLOSE BATCH FILE
	MOV	#GBLNAM,LNKGBL+14 ;RESTORE THE POINTER TO THE FILENAME
	CALL	CREATE,R5,LNKGBL;OPEN GLOBAL FILE FOR OUTPUT
	MOV	#TODAY,R0	;GET TODAY'S DATE
	MOV	#GBLDAT,R1	; AND ITS STORAGE LOCATION
	MOV	#9.,R2		;THERE ARE 9 CHARACTERS

10$:	MOVB	(R0)+,(R1)+	;MOVE A CHARACTER
	SOB	R2,10$		;LOOP

	MOVB	TODAY+7,GBLYR	;MOVE CURRENT YEAR TO COPYRIGHT
	MOVB	TODAY+10,GBLYR+1;OFFSETS ARE OCTAL

	JSR	R5,@#WRITE	;GO TO THE WRITE ROUTINE
	.WORD	LNKGBL		;WRITE TO THE GLOBAL.COM FILE


	.MESS
	.ASCII	%$!%<HT>
	.ASCII	%GLOBAL.COM - COMMAND PROCEDURE TO SET GLOBAL SYMBOLS %
GBLDAT:	.ASCII	%---------%<CR><LF>
	.ASCII	%$! %<CR><LF>
	.ASCII	%$! %<CR><LF>
	.ASCII	%$! %<11><11>%COPYRIGHT (c) 1974, 19%
GBLYR:	.ASCII	%??%
	.ASCII	% BY%<CR><LF>
.ASCII	%$!%<11>%DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.%<CR><LF>
.ASCII	%$!%<CR><LF>
	MESS.                                       

	MOVB	AJBMAX,STRJOB	;MOVE IN THE FIRST CHAR OF THE JOB MAX
	CMPB	AJBMAX+1,#'0	;IS THE CHARACTER LESS THAN A ZERO?
	BLO	15$		;YES, MOVE ON
	CMPB	AJBMAX+1,#'9	;IS THE CHARACTER GREATER THAN A NINE?
	BHI	15$		;YES, MOVE ON
	MOVB	AJBMAX+1,STRJOB+1;MOVE IN THE SECOND CHAR

15$:	MOV	#3,R0		;GET READY TO MOVE 3 WORDS (6 CHARACTERS);033
	MOV	#MONNAM,R1	;GET THE ADDRESS OF THE MONITOR NAME	;033
	MOV	#STRNAM,R2	;GET THE ADDRESS OF WHERE TO PUT IT	;033
17$:	MOV	(R1)+,(R2)+	;MOVE TWO CHARACTERS AT A TIME		;033
	SOB	R0,17$		;LOOP THROUGH ALL 3 WORDS		;033

	MOVB	#'0,STRRJ	;DEFAULT TO NO RJ2780
	TST	DS2780		;IS THERE RJ2780 SUPPORT
	BEQ	20$		;NO, CONTINUE
	MOVB	#'1,STRRJ	;YES, FLAG IT
20$:	MOV	TOTRUN,R2	;SET UP TO CONVERT TO DECIMAL ASCII	;034
	CALL	CHGDEC		;GO DO IT				;034
	MOVB	R2,STRRUN	;MOVE IN TENS NUMBER			;034
	SWAB	R2		;GET AT THE UNIT NUMBER			;034
	MOVB	R2,STRRUN+1	;MOVE IT IN				;034
	JSR	R5,@#WRITE	;GO TO THE WRITE ROUTINE		;026
	.WORD	LNKGBL		;WRITE TO THE GLOBAL.COM FILE
	.MESS			;BEGINNING OF TEXT TO WRITE
	.ASCII	%$ JOBMAX == %
STRJOB:	.BYTE	40,40
	.ASCII	<CR><LF>
	.ASCII	%$ MON_NAME ==  "%
STRNAM:	.ASCII	%------%
	.ASCII	%"%<CR><LF>
	.ASCII	%$ RJ2780 == %
STRRJ:	.BYTE	40
	.ASCII	<CR><LF>
	.ASCII	%$ TOTAL_RUNS == %
STRRUN:	.BYTE	40,40
	.ASCII	<CR><LF>
	MESS.
	CALL	CLOSE,R5,LNKGBL	;CLOSE GLOBAL FILE
	JMP	EXIT		;EXIT TO SOMEBODY'S MONITOR


	TMPORG	Q0DATA
	.NLIST	BEX

STATS::	.WORD	0		;<>0 IF STATISTICS CODE WANTED
EML::	.WORD	0		;1 IF EMT LOGGING WANTED

CTRLZ::	.BLKW	2		;AREA FOR CTRL/Z TRAPPING
DELBLK:	.BLKW	3		;AREA FOR DELETING GLOBAL.COM

TOTRUN::.WORD	0		;TOTAL NUMBER OF RUNS IN SYSGEN.COM	;034
SUPSED::.WORD	0		;SUPERSEDING MONITOR FLAG
SYSDSK::.WORD	0		;SYSTEM DISK TYPE
SYSSIZ::.WORD	0		;SYSTEM DISK SIZE FLAG
DELFIL::.WORD	0		;DELETE FILE(S) FLAG
PRTDEF::.WORD	0		;PRINT DEFAULTS FLAG
PRTDIR::.WORD	0		;PRINT DIRECTORY OF .SILs FLAG		;031
ASKIT::	.WORD	0		;<> 0 - ALWAYS PROMPT FLAG		;021
ASKTMS::.WORD	0		;<> 0 - ALWAYS PROMPT FOR TMSCP FLAG	;021
ADSTMD::.ASCII	%??%<CR>	;AUTO-ANSWER FOR DISTRO MEDIUM
	.EVEN
DSTMED::.ASCII	%??%<CR>	;DISTRIBUTION MEDIUM
	.EVEN
GENSYS::.WORD	0		;OUTPUT MEDIUM
DST278::.ASCII	%??%<CR>	;2780 DISTRIBUTION MEDIUM
	.EVEN
PACKID::.ASCII	%OUT   %	;PACK ID OF OUTPUT MEDIUM

AUTOAN::.WORD	0		;AUTO-ANSWER FLAG:
				;	-1 = DISABLED
				;	 0 = NOT WANTED
				;	+1 = WANTED

PATMON::.WORD	0		;<>0 FOR MONITOR PATCHING
PATBAS::.WORD	0		;<>0 FOR BASIC-PLUS PATCHING
PATRJE::.WORD	0		;<>0 FOR RJ2780 PATCHING
PATRSX::.WORD	0		;<>0 FOR RSX RTS PATCHING

MPTDEV::.WORD	0		;MONITOR PATCH FILE MEDIUM
BPTDEV::.WORD	0		;BASIC-PLUS PATCH FILE MEDIUM
RPTDEV::.WORD	0		;RJ2780 PATCH FILE MEDIUM
RSXDEV::.WORD	0		;RSX RTS PATCH FILE MEDIUM

MPTPID::.ASCII	%PATCH %	;MONITOR PATCH FILE PACK ID
BPTPID::.ASCII	%PATCH %	;BASIC-PLUS PATCH FILE PACK ID
RPTPID::.ASCII	%PATCH %	;RJ2780 PATCH FILE PACK ID
RSXPID::.ASCII	%PATCH %	;RSX RTS PATCH FILE PACK ID

MPTNAM::.ASCII	%$MONITOR.CMD        % ;MONITOR FILE NAME
BPTNAM::.ASCII	%$BASIC.CMD          % ;BASIC-PLUS FILE NAME
RPTNAM::.ASCII	%$RJ2780.CMD         % ;RJ2780 FILE NAME
RSXNAM::.ASCII	%$RSXRTS.CMD         % ;RSX RTS FILE NAME
SILNAM::.ASCII	%SY0:[0,1]      .SIL           % ;PREVIOUS SIL FILE NAME ;027

ASILNM::.ASCII	%SY0:[0,1]      .SIL%<CR> ;AUTO-ANS INSTALLED SIL FILENAME
AMPTNM::.ASCII	%$MONITR.CMD%<CR>	;AUTO-ANS MONITOR PATCH FILENAME
ABPTNM::.ASCII	%$BASIC.CMD%<CR>	;AUTO-ANS BASIC-PLUS PATCH FILENAME
ARSXNM::.ASCII	%$RSXRTS.CMD%<CR>	;AUTO-ANS RSX RTS PATCH FILENAME
ARPTNM::.ASCII	%$RJ2780.CMD%<CR>	;AUTO-ANS RJ2780 PATCH FILENAME

	.EVEN
SILNM1::.WORD	0		;FIRST RAD-50 WORD OF INSTALLED SIL NAME ;035
SILNM2::.WORD	0		;SECOND RAD-50 WORD OF INSTALLED SIL NAME ;035
INSIL1::.WORD	0		;First RAD-50 word of installed SIL name ;035
INSIL2::.WORD	0		;Second RAD-50 word of installed SIL name ;035

RKSEEK::.WORD	0		;-1 IF NON OVERLAPPED; 0 IF OVERLAPPED
RLSEEK::.WORD	0		;-1 IF NON OVERLAPPED; 0 IF OVERLAPPED
RMSEEK::.WORD	0		;-1 IF NON OVERLAPPED; 0 IF OVERLAPPED
RRSEEK::.WORD	0		;-1 IF NON OVERLAPPED; 0 IF OVERLAPPED
RBSEEK::.WORD	0		;-1 IF NON OVERLAPPED; 0 IF OVERLAPPED

ASMLST::.WORD	0		;<>0 IF ASSEMBLY LISTINGS WANTED
ANYLST::.WORD	0		;<>0 IF ANY LISTINGS WANTED
LSTMAP::.WORD	0		;<>0 IF MAPS WANTED			;023
BASLVL::.WORD	0		;<>0 IF WE ARE DOING A BASELEVEL	;025

DSDMC::	.WORD	0		;<>0 IF DMC11/DMR11 CONFIGURED
DSDMP::	.WORD	0		;<>0 IF DMV11/DMP11 CONFIGURED
DSKMC::	.WORD	0		;<>0 If KMC11 configured		;028
;DSDZ11::.WORD	0		;<>0 IF DZ11'S CONFIGURED
DS2780::.WORD	0		;0 IF NO 2780, 1 IF DP 2780, 2 IF DU 2780
KM2780::.WORD	0		;-1 IF KMC/2780 SUPPORT; 0 IF NONE
KMC.DZ::.WORD	0		;-1 IF KMC/DZ ASSIST; 0 IF NONE
KMC.LP::.WORD	0		;-1 IF KMC/LP ASSIST; 0 IF NONE

CR26::	.WORD	0		;<>0 IF 026 CODE DESIRED
CR29::	.WORD	0		;<>0 IF 029 CODE DESIRED
CR1401::.WORD	0		;<>0 ID 1401 CODE DESIRED

LRGFIL::.WORD	0		;LARGE FILE SUPPORT DESIRED IF <> 0
FIPBUF::.WORD	0		;FIP BUFFERING DESIRED IF <> 0
FIPBEX::.WORD	0		;EXTENDED DATA BUFFERING DESIRED IF <> 0
LPBEX::	.WORD	0		;EXTENDED LP BUFFERING DESIRED IF <> 0

E.MCP::	.WORD	0		;MCP PHASE RA80/UDA50/TMSCP REQUIRED IF <> 0
E.MSCP::.WORD	0		;MCP PHASE RA80/UDA50 REQUIRED IF <> 0

E.MVR::	.WORD	0		;MVR phase (magtapes) required if <> 0	;019
MTDVRM::.WORD	0		;Include MTDVRM in MVR if <> 0		;019
MMDVRM::.WORD	0		;Include MMDVRM in MVR if <> 0		;019
MSDVRM::.WORD	0		;Include MSDVRM in MVR if <> 0		;019
MUDVRM::.WORD	0		;Include MUDVRM in MVR if <> 0		;020

DIAMON::.WORD	0		;-1 => INCLUDE DIAMOND STUFF

RSXFLG::.WORD	0		;<>0 IF RSX SYSTEM DEFAULT RTS
MONFLG::.WORD	-1		;<>0 IF GENING MONITOR
BPLFLG::.WORD	0		;<>0 IF GENING BASIC-PLUS
DEBUGB::.WORD	0		;<>0 IF BASIC-PLUS DEBUGGING WANTED

PRVMON::.WORD	0		;<>0 IF USING A PREVIOUS MONITOR
CHGCFG::.WORD	0		;<>0 IF CHANGING THE CONFIGURATION
CHGSEC::.WORD	0		;<>0 IF CHANGING THE CONFIG. IN THE SECTION

MATH::	.ASCII	%  %		;MATH PACKAGE
FCTS.L::.WORD	0		;<>0 IF LOG FUNCTIONS DESIRED
FCTS.T::.WORD	0		;<>0 IF TRIG FUNCTIONS DESIRED
MAT::	.WORD	0		;<>0 FOR MATRICES
PRTUSE::.WORD	0		;<>0 IF PRINT USING WANTED
STRING::.WORD	0		;<>0 IF STRING MATH WANTED

MONNAM::.ASCII	%RSTS  %	;MONITOR SIL NAME
BASNAM::.ASCII	%BASIC %	;BASIC PLUS RUN TIME SYSTEM NAME

;  STANDARD AUTO ANSWERS

ANSYES::.ASCII	%Y %<CR>
ANSNO::	.ASCII	%N %<CR>
ANSDEF::.ASCII	%??%<CR>
ANS0::	.ASCII	%00%<CR>
ANS2::	.ASCII	%02%<CR>
ANS4::	.ASCII	%04%<CR>
ANS8::	.ASCII	%08%<CR>
ANS12::	.ASCII	%12%<CR>
ANS16::	.ASCII	%16%<CR>
ANS32::	.ASCII	%32%<CR>
	.EVEN
ANSWER::.ASCII	%--%<CR>	;ARBITRARY 2 CHARACTER ANSWER FOR GENERAL USE
	.EVEN

; TABLE OF SPECIAL CHARACTERS (USED BY WRITE SUBROUTINE)
; USED AS REPLACEMENT CHARS FOR OUTPUT ASCII CHARS > 200(8)

SPLCHR::.BYTE	0		;<PPN> ACCOUNT NAME

	.EVEN

;   HARDWARE AUTO ANSWERS

AUTOB::				;START OF LIST
AQBU::	.ASCII	%??%<CR>	;Q-BUS SYSTEM
AFPU::	.ASCII	%??%<CR>	;FLOATING POINT PROCESSOR
AFIS::	.ASCII	%??%<CR>	;FIS OPTION
ARS03::	.ASCII	%??%<CR>	;RS03/04
ARF::	.ASCII	%??%<CR>	;RF'S
ARP04::	.ASCII	%??%<CR>	;RP04/05/06
ARM03::	.ASCII	%??%<CR>	;RM02/03/05/80
ARK06::	.ASCII	%??%<CR>	;RK06
ARL11::	.ASCII	%??%<CR>	;RL01/02
ARK11::	.ASCII	%??%<CR>	;RK05
ARX01::	.ASCII	%??%<CR>	;FLOPPY
AMSCP::	.ASCII	%??%<CR>	;MSCP controllers UDA50
	.EVEN			;ATMSCP MUST BE ON AN EVEN BOUNDARY	;020
ATMSCP::.ASCII	%00%<CR>	;TMSCP controllers			;021
ATU16::	.ASCII	%??%<CR>	;TU16
ATU10::	.ASCII	%??%<CR>	;TU10
ATS11::	.ASCII	%??%<CR>	;TS11
ADTII::	.ASCII	%??%<CR>	;DECTAPE II
ALP::	.ASCII	%??%<CR>	;LINE PRINTERS
ACR::	.ASCII	%??%<CR>	;CR11 CARD READER
	.EVEN			;APTR MUST BE ON AN EVEN BOUNDARY
ACD::	.ASCII	%??%<CR>	;CD11 CARD READER
ADU::	.ASCII	%??%<CR>	;DU
ADP::	.ASCII	%??%<CR>	;DP
ADUP::	.ASCII	%??%<CR>	;DUP
	.EVEN
ADMP11::.ASCII	%??%<CR>	;DMP11/DMV11
ADMC11::.ASCII	%??%<CR>	;DMC11/DMR11
AKMC11::.ASCII	%??%<CR>	;KMC11
AUTOE::				;END OF LIST

	.EVEN



	;	MORE AUTO ANSWERS

ADIRCC::.ASCII	%??%<CR>
ADATCC::.ASCII	%??%<CR>
AIBMI::	.ASCII	%??%<CR>
APKB::	.ASCII	%04%<CR>
AJBMAX::.ASCII	%??%<CR>
ASTATS::.ASCII	%??%<CR>
AQRJ27::.ASCII	%??%<CR>
ALPBEX::.ASCII	%??%<CR>
	.EVEN
ARJ278::.ASCII	%??%<CR>
ARBSEK::.ASCII	%??%<CR>
ARKSEK::.ASCII	%??%<CR>
ARLSEK::.ASCII	%??%<CR>
ARMSEK::.ASCII	%??%<CR>
ARRSEK::.ASCII	%??%<CR>
ASILNK::.ASCII	%??%<CR>
	.EVEN
ASBUF::	.ASCII	% 200%<CR>
	.EVEN

DDS.KB::.WORD	0							;032
CNT.KB::.WORD	0							;032
BUF.E::	.WORD	0
BUF.S::	.WORD	0
MBF.S::	.WORD	0
MBF.E::	.WORD	0
	.EVEN
ARJDEV::.ASCII	%??%<CR>
	.EVEN

ACDCOD::.ASCII	%AN%			;FIRST HALF OF THE CARD DECODE TABLE
ACDCD2::.ASCII	%SI%<CR>		;SECOND HALF OF THE TABLE
AEMTLG::.ASCII	%??%<CR>

XD0UN::	.ASCII	%??%<CR>
XD1UN::	.ASCII	%??%<CR>
XD2UN::	.ASCII	%??%<CR>
XD3UN::	.ASCII	%??%<CR>
XD4UN::	.ASCII	%??%<CR>
XD5UN::	.ASCII	%??%<CR>
XD6UN::	.ASCII	%??%<CR>
XD7UN::	.ASCII	%??%<CR>
XD8UN::	.ASCII	%??%<CR>
XD9UN::	.ASCII	%??%<CR>
XD10UN::.ASCII	%??%<CR>
XD11UN::.ASCII	%??%<CR>
XD12UN::.ASCII	%??%<CR>
XD13UN::.ASCII	%??%<CR>
XD14UN::.ASCII	%??%<CR>
XD15UN::.ASCII	%??%<CR>

	.EVEN
	.LIST	BEX
	UNORG

.SBTTL	SUBROUTINE TO QUERY USER ABOUT CONFIGURATION

;CALL	JSR	R5,QUERY
;	+	MSG. ADDR.	;LONG FORM MESSAGE ADDR. FOLLOWS CALL
;	R1 = ADDRESS OF THE AUTO ANSWER (ENDS WITH CR)
;
;TWO RETURNS ARE POSSIBLE:
;	^ (UPARROW) TYPED	;INST FOLLOWING THE CALL
;	OTHER RESPONSE		;2ND INST FOLLOWING CALL
;				;R0 = ADDR. OF RESPONSE
;
;NORMAL CODE SEQUENCE IS AS FOLLOWS:
;	MOV	#AUTO ANSWER,R1
;	JSR	R5,QUERY
;	+	MSG. ADDR
;	BACK			;RETURN TO PREVIOUS QUESTION
;	----			;INTERPRET THE RESPONSE

	DEFORG	Q0SUBR
QUERY::	MOV	R2,-(SP)	;NEED ONE REGISTER
	MOV	(R5),R0		;GET THE MESSAGE LOCATION
	CMPB	(R1),#'?	;IS ANSWER AN AUTOMATIC DEFAULT
	BEQ	5$		;NO, GO ASK THE QUESTION
	TST	ASKIT		;DO WE WANT TO ASK UNCONDITIONALLY	;021
	BNE	5$		;YES, GO ASK				;021
	TST	CHGCFG		;DO WE WANT TO ASK ANY CONFIGURATION QUESTIONS
	BEQ	3$		;NO, GO ACCEPT THE DEFAULT
	TST	CHGSEC		; OR ANY QUESTIONS FROM THIS SECTION
	BNE	5$		;YES, GO ASK IT
3$:	TST	(R5)+		;SIMULATE USER ACCEPTING THE DEFAULT ANSWER
	MOV	R1,R0		;SET RESPONSE EQUAL TO THE DEFAULT ANSWER
	BR	100$		;GO RETURN

5$:	CLR	ASKIT		;RESET THE PROMPT-UNCONDITIONALLY FLAG	;021
	CMP	R0,QUERLC	;IS IT THE SAME AS LAST TIME
	BEQ	20$		;YES. DON'T PRINT THE LONG FORM AGAIN
	MOV	R0,QUERLC	;SAVE THE NEW MESSAGE LOCATION
	TST	QUERSW		;ABBREVIATED FORM REQUESTED
	BNE	20$		;YES. SKIP THE LONG FORM
10$:	TELLR0			;PRINT THE LONG MESSAGE
	TST	PRTDIR		;DO WE ALSO WANT TO PRINT .SIL DIRECTORY ;031
	BEQ	15$		;NO, JUST CONTINUE			 ;031
	CALLX	SGNDIR		;YES, PRINT IT OUT			 ;031
15$:	TST	PRTDEF		;DO WE ALSO WANT TO PRINT THE DEFAULTS?	 ;031
	BEQ	20$		;NO, JUST CONTINUE
	CALLX	SGNANS		;YES, PRINT THEM OUT
20$:	CALL	NOCTLO		;CANCEL ANY CONTROL/O EFFECT
	MOV	-(R0),R0	;CHANGE THE POINTER TO THE ABBREVIATED MESSAGE
	TELLR0			;PRINT THE SHORT MESSAGE
	MOV	(R0),R2		;GET THE BYTE COUNT
	SUB	#3,R2		;-3 FOR THE  CR,LF,AND TERMINATOR
	CALL	GETBUF		;GET POINTER TO THE OUTPUT BUFFER IN R0
	MOV	R0,-(SP)	;SAVE IT
	TST	(R0)+		;POINT TO START OF ASCII TEXT
	BIC	#7,R2		;GET # OF CHARACTERS TO LAST TAB
30$:	MOVB	#HT,(R0)+	;ADD A TAB TO THE OUTPUT
	ADD	#8.,R2		;CORRECT THE COLUMN COUNT
	CMP	R2,#32.		;ARE WE IN COLUMN 32
	BLT	30$		;NOT YET
50$:	MOVB	#'<,(R0)+	;MOVE THE HEADER CHARACTER INTO THE BUFFER
	MOV	R1,R2		;COPY THE AUTO ANSWER POINTER
60$:	CMPB	(R2),#CR	;CR IS A TERMINATOR
	BEQ	70$		;ITS A CR. WE ARE DONE
	MOVB	(R2)+,(R0)+	;COPY CHARACTER TO THE OUTPUT BUFFER
	BR	60$		;GO BACK FOR THE NEXT CHARACTER

70$:	MOVB	#'>,(R0)+	;APPEND TAIL (SAME AS HEADER)
	MOV	R0,R2		;SAVE END POINTER
	MOVB	#HT,(R0)+	;ADD A TAB TO THE OUTPUT
	MOVB	#TERM,(R0)+	;ADD THE TERMINATOR
	SUB	(SP),R2		;GET THE BYTE COUNT
	MOV	(SP)+,R0	;RESTORE THE BUFFER POINTER
	MOV	R2,(R0)		;STORE THE BYTE COUNT
	TELLR0			;PRINT THE AUTO ANSWER
	CALL	GETCML		;GET THE ANSWER
	CMPB	(R0),#'^	;DID USER TYPE UPARROW
	BNE	80$		;NO
	BR	100$		;AND TAKE THE FIRST RETURN

80$:	CMPB	(R0),#'?	;IS IT A QUESTION MARK
	BNE	90$		;NO
	MOV	(R5),R0		;RESTORE THE MESSAGE ADDRESS
	BR	10$		;AND GO PRINT THE LONG FORM

90$:	TST	(R5)+		;NORMAL RESPONSE. TAKE THE SECOND RETURN
	CMPB	(R0),#LF	;DID USER ACCEPT AUTO ANSWER
	BEQ	95$		;YES
	CMPB	(R0),#CR	;DID USER ACCEPT AUTO ANSWER
	BEQ	95$		;YES					;022
	CMPB	(R0),#'!	;IS THIS CHARACTER THE COMMENT CHARACTER? ;022
	BEQ	95$		;TREAT IT AS AN AUTO ANSWER		;022
	MOV	R0,-(SP)	;SAVE THE ADDRESS TO THE ANSWER		;022
91$:	CMPB	(R0),#CR	;ARE WE DONE YET?			;022
	BEQ	94$		;YES					;022
	CMPB	(R0),#LF	;ARE WE DONE NOW?			;022
	BEQ	94$		;YES					;022
	CMPB	(R0)+,#'!	;IS THIS CHARACTER THE COMMENT CHARACTER? ;022
	BNE	91$		;NO, GO LOOK AT THE NEXT ONE		;022
	MOVB	#CR,-1(R0)	;PUT A <CR> IN ITS PLACE		;022
94$:	MOV	(SP)+,R0	;PUT THE ADDRESS BACK			;022
	BR	100$		;GO FINISH UP				;022

95$:	MOV	R1,R0		;SET POINTER TO AUTO ANSWER
100$:	MOV	(SP)+,R2	;RESTORE R2
	TST	(R5)+		;SKIP OVER ONE DATA WORD
	CLR	DEFLAG		;CLEAR THE FLAG FOR NEXT TIME
	RETURN	R5		;RETURN

	TMPORG	Q0DATA
QUERSW::.WORD	0		;SHORT FORM QUESTION IF NOT 0
QUERLC:	.WORD	0		;SAVED LOCATION FOR TESTING REPROMPTS
HDR:	.ASCII	%*#%		;AUTO ANSWER HEADER
DEFLAG::.WORD	0		;<>0 IF AUTO ANSWER IS DEFAULT
ESCPRT:	.WORD	3		;BYTE COUNT
	.ASCII	<CR><LF><TERM>	;CR,LF AFTER AN ESCAPE
	.EVEN
	UNORG

.SBTTL	ROUTINE TO TEST YES/NO ANSWRERS

;CALL	JSR	R5,TESTNY
;	+	BAD ANSWER RETURN
;	+	RETURN FOR "NO
;	+	RETURN FOR "Y
;	R0 POINTS TO THE ANSWER
;

TESTNY::CMPB	(R0),#'Y	;IS ANSWER A YES
	BNE	10$		;NO IT ISN'T
	TST	(R5)+		;START FIXING UP FOR RETURN
	BR	20$		;CONTINUE

10$:	CMPB	(R0),#'N	;IS THE ANSWER A NO
	BNE	30$		;NO IT ISN'T SO ITS A BAD ANSWER
20$:	TST	(R5)+		;FIX UP THE RETURN ADDRESS
30$:	RETURN	R5		;RETURN TO WHEREVER


.SBTTL	SUBROUTINE SETS NONZERO ANSWERS TO EIGHT AND A DEFAULT

;CALL	CHKDEF
;	CALL	CHKDEF
;	R1--> AUTO ANSWER
;
CHKDEF::CMPB	(R1),#'?	;IS THERE AN ANSWER
	BEQ	10$		;NO
	MOVB	(R1),-(SP)	;GET THE FIRST CHARACTER
	SWAB	(SP)		;PUT IT IN THE HIGH BYTE
	MOVB	1(R1),(SP)	;INSERT THE SECOND BYTE
	CMP	(SP)+,#"00	;IS THE ANSWER 00
	BEQ	10$		;YES
	INC	DEFLAG		;NO. ANSWER IS UNCERTAIN
	MOV	#ANS8,R1	;ANSWER WILL BE 8
10$:	RETURN			;ALL DONE

.SBTTL	SUBROUTINE TO EVALUATE NUMERIC RESPONSE

	ORG	Q0SUBR

NUMBER::CALL	REGSAV,R5	;SAVE ALL
	MOV	(R5)+,R4	;GET LOC OF PARAMETER TO SET
	MOV	#7,R3		;SET NO MORE THAN 7 CHARACTERS
	CLR	R1		;VALUE STARTS OFF AS 0
	CALL	TESTNY,R5	;CHECK FOR 'Y' AND 'N' FIRST
	BR	10$		;NOT 'Y' OR 'N'
	BR	50$		;'N', SAY ANSWER IS '0'
	CMP	2(R5),#1	;'Y', IS THE HIGH LIMIT = 1 ??
	BNE	10$		;NOPE, DON'T DEFAULT 'Y' TO '1'
	MOVB	#'1,(R4)+	;YEP, STORE ANSWER OF '1'
	DEC	R3		; AND COUNT THAT STORE
	INC	R1		;  AND SET ANSWER TO 1
	BR	50$		;NOW CHECK IT

10$:	CMPB	(R0),#CR	;END OF RESPONSE?
	BEQ	50$		;YES - CHECK VALUE
	CMPB	(R0),#LF	;END CAN BE A <LF>
	BEQ	50$		;IT IS CHECK VALUE
	CMPB	(R0),#'/	;END IS EITHER <CR>,<LF> OR SWITCH "/"
	BEQ	50$		;WHICH THIS IS
	MOV	R1,R2		;NO - SAVE CURRENT VALUE
	BNE	20$		;SKIP IF THE RESULTS SO FAR ARE NONZERO
	CMPB	(R0),#'0	;IS THIS A ZERO
	BNE	20$		;NO. STORE IT
	TSTB	(R0)+		;YES. IGNORE IT
	BR	10$		;GO GET THE NEXT CHARACTER
20$:	MOVB	(R0),(R4)+	;STORE CHARACTER
	DEC	R3		;COUNT IT
	BEQ	80$		;TOO MANY DIGITS - ERROR
	MOVB	(R0)+,R1	;GET CHARACTER
	SUB	#'0,R1		;EXTRACT VALUE
	BMI	80$		;LESS THAN 0 - ERROR
	CMP	R1,NUMBAS	;CHECK FOR VALID DIGIT
	BGE	80$		;GREATER THAN NUMBER BASE - ERROR
	MOV	R2,-(SP)	;SAVE COPY OF VALUE SO FAR
	ASL	(SP)		;*2
	ASL	(SP)		;*2*2=*4
	CMP	NUMBAS,#8.	;OCTAL BASE?
	BEQ	30$		;YES - DON'T ADD
	ADD	(SP)+,R2	;4*VAL+VAL=5*VAL
	BR	40$
30$:	TST	(SP)+		;POP COPY INSTEAD OF ADDING
40$:	ASL	R2		;(5 OR 4)*2*VAL=(10 OR 8)*VAL
	ADD	R2,R1		;+ DIGIT = NEW VALUE
	BR	10$		;GET NEXT DIGIT, IF ANY
50$:	CMP	R1,(R5)+	;COMPARE VALUE TO MINIMUM
	BLT	90$		;LESS - ERROR
	CMP	R1,(R5)+	;COMPARE TO MAXIMUM
	BGT	100$		;GREATER - ERROR
	CMP	R3,#7		;ANY DIGITS BEEN STORED?
	BNE	60$		;YES - FINISH OFF AND GET OUT
	MOVB	#'0,(R4)+	;NO - PUT IN A 0
	DEC	R3		;ACCOUNT FOR IT
60$:	CMP	NUMBAS,#8.	;OCTAL NUMBER?
	BEQ	70$		;YES - SKIP THE DECIMAL POINT
	MOVB	#'.,(R4)+	;NO - DECIMAL REQUIRES '.'
	DEC	R3		;COUNT IT
70$:	MOVB	#40,(R4)+	;BLANK THE REST
	DEC	R3		;OF THE 7 CHARACTERS
	BNE	70$		;KEEP IT UP
	BR	90$		;SKIP ERROR RETURN AND RETURN
80$:	TST	(R5)+		;SKIP OVER THE ARGUMENTS
90$:	TST	(R5)+		;IN THE CALLING SEQUENCE
100$:	MOV	R5,12(SP)	;UPDATE RETURN ON STACK
	MOV	R1,2(SP)	;VALUE RETURNED IN R1
	CALL	REGRES,R5	;RESORE EM ALL
	RETURN	R5		;RETURN

	TMPORG	Q0DATA
NUMBAS:	.WORD	10.		;ASSUME DECIMAL NUMBER BASE
PARAM::	.BLKW	4		;GENERAL LOCATION FOR THE ASCII RESULTS
	UNORG


.SBTTL	CONVERT AND STORE DECIMAL

;CALL	JSR	R5,STRDEC
;	.WORD	ADDRESS OF CONFIG PARAMETER TO SET
;	R1	0.<= N <= 9999.

	ORG	Q0SUBR

STRDEC::CALL	REGSAV,R5	;SAVE EM ALL
	MOV	(R5),R2		;GET LOC OF PARAMETER TO SET
	MOV	#DECTBL,R3	;POINT TO DECIMAL TABLE
	MOV	#3,R4		;THREE DIGITS PLUS UNITS
10$:	MOVB	#'0,(R2)	;START AT ZERO FOR THIS DIGIT
20$:	SUB	(R3),R1		;CONVERT BY SUBTRACTIONS
	BMI	30$		;
	INCB	(R2)		;ONE MORE IN THIS PLACE
	BR	20$		;HANG IN THERE

30$:	ADD	(R3)+,R1	;CORRECT OVERFLOW
	CMPB	(R2),#'0	;IS THE DIGIT A ZERO?
	BNE	40$		;NO, KEEP IT
	CMP	R2,(R5)		;YES, A LEADING ZERO??
	BEQ	50$		;WE ARE IGNORING LEADING ZEROS
40$:	INC	R2		;NEXT DIGIT PLEASE
50$:	DEC	R4		;ENUF DIGITS STORED ?
	BNE	10$		;NOPE
	ADD	#'0,R1		;MAKE UNITS ASCII
	MOVB	R1,(R2)+	;ALWAYS STORE UNITS
	MOVB	#'.,(R2)+	;AND A DECIMAL POINT
	MOV	(R5)+,R3	;GET ORIGINAL START OF STRING
	MOV	R5,12(SP)	;UPDATE RETURN ON STACK
	ADD	#7,R3		;MAX LENGTH
60$:	CMP	R2,R3		;AT END OF STRING ?
	BEQ	70$		;YES
	MOVB	#40,(R2)+	;SPACE FILL TO END
	BR	60$		;
70$:	CALL	REGRES,R5	;RESTORE EVERYBODY
	RETURN	R5		;BYE

	TMPORG	Q0DATA
DECTBL:	.WORD	1000.
	.WORD	100.
	.WORD	10.
	UNORG



.SBTTL	CHANGE A DECIMAL INTEGER TO  2 CHARACTER ASCII

;	CALL	CHGDEC
;	R2=INTEGER	0<=N<=99

;	RETURN	R2=ASCII OF N; R3 ARBITRARY


CHGDEC::MOV	R2,R3		;SET UP FOR DIVISION
	CLR	R2		;16 BITS ONLY
	DIV	#10.,R2		;GET THE 10'S DIGIT
	SWAB	R3		;PUT UNIT IN THE HIGH BYTE
	BIS	R3,R2		;COMBINE THE TWO BYTES
	ADD	#"00,R2		;MAKE BOTH BYTES ASCII
	RETURN			;RETURN


.SBTTL	CONVERT AND STORE OCTAL

;CALL	R1	NUMBER TO CONVERT
;	JSR	R5,STROCT
;	.WORD	ADDRESS OF CONFIG PARAMETER TO SET

	ORG	Q0SUBR

STROCT::CALL	REGSAV,R5	;SAVE ALL
	MOV	(R5)+,R2	;GET ADDRESS OF CONFIG PARAMETER
	MOV	R5,12(SP)	;UPDATE RETURN ON STACK
	MOV	#6,R4		;6 OCTAL DIGITS TO SET
	CLR	R3		;CLEAR AN ACCUMULATOR
	BR	20$		;SKIP TWO SHIFTS
10$:	CLR	R3		;ZERO COUNT
	ASL	R1		;SHIFT LEFT 3 BITS OF R1 INTO R3
	ROL	R3		;
	ASL	R1		;
	ROL	R3		;
20$:	ASL	R1		;
	ROL	R3		;
	ADD	#60,R3		;MAKE IT ASCII
	MOVB	R3,(R2)+	;STORE
	DEC	R4		;LOOP FOR 6 DIGITS
	BNE	10$		;
	MOVB	#40,(R2)+	;STORE SPACE FOR CONSISTENCY
	CALL	REGRES,R5	;RESTORE EVERYBODY
	RETURN	R5		;DONE


.SBTTL	SUBROUTINE TO MOVE DATA

;CALL:	JSR	R5,MOVER
;	.WORD	'FROM' ADDRESS
;	.WORD	'TO' ADDRESS
;	.WORD	BYTE COUNT

	ORG	Q0SUBR

MOVER::	MOV	R0,-(SP)	;SAVE R0,R1,AND R2 ON THE STACK
	MOV	R1,-(SP)
	MOV	R2,-(SP)
	MOV	(R5)+,R0	;GET 'FROM' ADDRESS
	MOV	(R5)+,R1	;GET 'TO' ADDRESS
	MOV	(R5)+,R2	;GET BYTE COUNT
10$:	MOVB	(R0)+,(R1)+	;MOVE DATA
	DEC	R2
	BNE	10$
	MOV	(SP)+,R2	;RESTORE R0,R1 AND R2
	MOV	(SP)+,R1
	MOV	(SP)+,R0
	RETURN	R5		;RETURN






.SBTTL	SUBROUTINE TO SET PARAMETERS TO ZERO INITIALLY

	ORG	Q0SUBR

ZERO::	MOV	R0,-(SP)	;SAVE TWO
	MOV	R1,-(SP)	;
	MOV	(R5)+,R0	;GET PARAMETER LOC
	MOVB	#'0,(R0)+	;SET TO 0
	MOV	#6,R1		;THEN 6 BLANKS
10$:	MOVB	#40,(R0)+	;BLANK IT
	DEC	R1		;ANY MORE?
	BNE	10$		;NOT ENOUGH - CONTINUE
	MOV	(SP)+,R1	;RESTORE TWO
	MOV	(SP)+,R0	;
	RETURN	R5		;DONE - RETURN



.SBTTL	SCAN FOR SWITCHES

;CALL	R0		; PTR TO STRING (MUST HAVE <CR> OR <LF> TERMINATOR)
;	JSR	R5,SWSCAN
;	.BYTE	'X	; SCAN FOR SWITCH /X (ANY ORDER)
;TAG:	.BYTE	0	; -1 IF SWITCH FOUND; 0 IF NOT FOUND
;	.BYTE	'S,0	; ANY NUMBER OF SWITCHES TO FIND
;	----		;
;	----		;
;	.WORD	0	; SWITCH LIST TERMINATOR
;	LOOP		; BAD SWITCH RETURN ADDRESS
;	----		; NORMAL RETURN

SWSCAN::CALL	REGSAV,R5	;SAVE EVERYBODY
	MOV	R0,R2		;SCAN STRING WITH R2
	MOV	R5,R3		;SET PTR FOR INITIAL CLEAR OF SWITCHES
	MOV	R5,R4		;SAVE START ADDRESS OF SWITCH LIST
10$:	TSTB	(R3)+		;END OF SWITCH LIST ?
	BEQ	20$		;DONE
	CLRB	(R3)+		;ALL SWITCHES INITIALLY CLEARED
	BR	10$		;

20$:	INC	R3		;BUMP OVER SWITCH LIST TERMINATOR
	MOV	R3,R5		;SET ERROR RETURN ADDRESS
30$:	CMPB	(R2),#CR	;END OF STRING ?
	BEQ	60$		;DONE, TAKE NORMAL EXIT
	CMPB	(R2),#LF	;IS IT A LINE FEED
	BEQ	60$		;YES. TAKE NORMAL EXIT
	CMPB	(R2),#'!	;IS IT THE BEGINNING OF A COMMENT	;024
	BEQ	60$		;YES. TAKE NORMAL EXIT			;024
	CMPB	(R2)+,#'/	;ANY SWITCH HERE
	BNE	30$		;NOT YET
	MOV	R4,R3		;RESET POINTER TO TOP OF SWITCH LIST
40$:	TSTB	(R3)		;END OF SWITCH LIST ?
	BEQ	70$		;YES, HIS SWITCH NOT IN LIST - ERROR
	CMPB	(R2),(R3)+	;CHECK HIS SWITCH AGAINST OUR LIST
	BEQ	50$		;MATCH. FLAG SWITCH AS PRESENT
	INC	R3		;NO MATCH - BUMP TO NEXT SWITCH
	BR	40$		;CONTINUE SCAN

50$:	MOVB	#377,(R3)+	;NOTE SWITCH PRESENT
	MOVB	#CR,-1(R2)	;PUT A <CR> IN PLACE OF THE SWITCH	;023
	INC	R2		;BUMP TO NEXT INPUT CHARACTER
	BR	30$		;LOOK FOR MORE SWITCHES

60$:	TST	(R5)+		;NORMAL EXIT
70$:	MOV	R5,12(SP)	;UPDATE RETURN ON STACK
	CALL	REGRES,R5	;RESTORE EVERYBODY
	RETURN	R5		;ERROR  EXIT



.SBTTL	SUBROUTINES TO CLEAR PORTIONS OF BATCH CONTROL FILE

	ORG	Q0SUBR

CLEAR::	MOV	R0,-(SP)	;SAVE R0
	MOV	R1,-(SP)	;UND R1
	MOV	(R5)+,R0	;GET LOC TO CLEAR
	MOV	(R5)+,R1	;AND # BYTES TO CLEAR
CLEAR1::CLRB	(R0)+		;CLEAR A BYTE
	DEC	R1		;COUNT	- MORE?
	BNE	CLEAR1		;YES - KEEP CLEARING
	MOV	(SP)+,R1	;RESTORE
	MOV	(SP)+,R0	;
	RETURN	R5		;NO - RETURN



.SBTTL	SUBROUTINE TO DETERMINE DISTRIBUTION MEDIUM TYPE

	ORG	Q0SUBR

;CALL	JSR	R5,MEDIA
;	+	POINTER TO MEDIUM NAME
;	BR	--		;RETURN FOR DT   DISTRIBUTION
;	BR	--		;RETURN FOR MT   DISTRIBUTION
;	BR	--		;RETURN FOR SYS  DISTRIBUTION
;	BR	--		;RETURN FOR DISK DISTRIBUTION
;	R0---> MEDIUM NAME

MEDIA::	MOV	(R5)+,R0	;GET POINTER TO THE MEDIUM NAME
	CMP	(R0),#"DT	;DECTAPE ?
	BEQ	10$		;YES
	TST	(R5)+		;NEXT BEST QUESS IS MT
	CMP	(R0),#"MT	;TU10 MAGTAPE ?
	BEQ	10$		;TIS
	CMP	(R0),#"MM	;TU16 MAGTAPE ?
	BEQ	10$		;YES
	CMP	(R0),#"MS	;TS11 MAGTAPE ?
	BEQ	10$		;YES
	TST	(R5)+		;MUST BE DISK
	CMP	(R0),#"SY	;IS THE SYSTEM
	BEQ	10$		;YES
	TST	(R5)+		;NO. SOME OTHER DISK
10$:	RETURN	R5		;RETURN SOMEWHERE



.SBTTL	MEDIA CHECK SUBROUTINE

;   CALL	MEDCHK,R5
;   +		MEDIA LIST
;   +		ERROR RETURN
;   +		GOOD RETURN
;
;   CHECKS THAT R0 POINTS TO A LEGAL ANSWER TO THE MEDIA QUESTION. THE 
;   ALLOWED ANSWERS ARE GIVEN IN MEDIA LIST (TERMINATED WITH A ZERO)
;
;	R2 = SWITCH VALUE OR 0
;


MEDCHK::MOV	(R5)+,R1	;GET LIST POINTER
10$:	TST	(R1)		;LIST EXHAUSTED?
	BEQ	30$		;YES
	CMP	(R0),(R1)+	;DOES THE RESPONSE MATCH
	BNE	10$		;NO
	CLR	R2		;ASSUME NO SWITCH
	CMPB	2(R0),#CR	;TERMINATED?
	BEQ	20$		;YES
	CMPB	2(R0),#LF	;TERMINATED?
	BEQ	20$		;YES
	CMPB	2(R0),#'/	;IS THERE A SWITCH
	BNE	30$		;NO
	CMPB	3(R0),#'A	;IS IT A LETTER
	BLO	30$		;NO BAD ANSWER
	CMPB	3(R0),#'Z	;RANGE IS A TO Z
	BHI	30$		;NOT A LETTER
	MOVB	3(R0),R2	;SAVE THE REV LETTER
20$:	TST	(R5)+		;ALL IS OK. SET GOOD RETURN
30$:	RETURN	R5		;RETURN


;   SET UP MEDIA LISTS

	TMPORG	Q0DATA

OUTLST::.WORD	"DB		;RH11/RP04,RP05,RP06
	.WORD	"DR		;RH11/RM02,RM03,RM05,RM80
	.WORD	"DP		;RP11/RP02,RP03
	.WORD	"DU		;RA80
DSTLST::.WORD	"DK		;RK11/RK05,RK05F
	.WORD	"SY
	.WORD	"MT		;TM11,TMA11,TMB11/TU10,TE10,TS03
	.WORD	"MM		;RH11,TM02,TM03/TU16,TE16,TU45,TU77
	.WORD	"MS		;TS11
	.WORD	"DL		;RL11/RL01,RL02
	.WORD	"DM		;RK611/RK06,RK07
	.WORD	0

	UNORG


.SBTTL	CHECK AND STORE FILE NAME

;CALL	JSR	R5,NAME
;	+	STORAGE LOCATION (6 CHARACTERS)
;	+	RETURN FOR BAD INPUT
;	+	RETURN FOR GOOD INPUT
;
;	R0---> ASCII STRING WITH <CR> TERMINATOR
;
;RETURN:	R0,R1 AND R2 ARE UNDEFINED
;		TYPED STRING IS STORED IN STORAGE LOCATION WITH BLANKS APPENDED

NAME::	MOV	(R5)+,R1	;GET STORAGE LOCATION
	MOV	#6.,R2		;NUMBER OF CHARACTERS
10$:	CMPB	(R0),#CR	;IS IT A TERMINATOR
	BEQ	30$		;YES
	CMPB	(R0),#LF	;IS IT A TERMINATOR
	BEQ	30$		;YES
	TST	R2		;NO. IS THERE ROOM LEFT
	BEQ	50$		;NO. BAD INPUT
	CMPB	(R0),#'Z	;IS INPUT GREATER THAN Z
	BGT	50$		;YES. BAD INPUT
	CMPB	(R0),#'0	;IS IT LESS THAN 0
	BLT	50$		;YES. BAD INPUT
	CMPB	(R0),#'A	;IS IT A LETTER
	BGE	20$		;YES. GOOD INPUT
	CMPB	(R0),#'9	;IS IT A NUMBER
	BGT	50$		;NO. BAD INPUT
20$:	MOVB	(R0)+,(R1)+	;GOOD CHARACTER. STORE IT.
	DEC	R2		;COUNT IT
	BR	10$		;GO BACK FOR MORE

30$:	TST	(R5)+		;ALL INPUT WAS GOOD. SET THE RETURN
	TST	R2		;ALL SIX CHARACTERS FILLED IN
40$:	BEQ	50$		;YES
	MOVB	#40,(R1)+	;STORE A BLANK
	DEC	R2		;COUNT IT
	BR	40$		;AND GO BACK FOR MORE

50$:	RETURN	R5		;ALL DONE

.SBTTL	REGISTER SAVE AND RESTORE

;
;CALL	JSR	R5,REGSAV	
;
;EXITS WITH SP --> R0,R1,R2,R3,R4,R5 AND CARRY UNCHANGED
;

REGSAV::MOV	R4,-(SP)	;SAVE REGISTERS R4
	MOV	R3,-(SP)	; R3
	MOV	R2,-(SP)	;  R2
	MOV	R1,-(SP)	;   R1
	MOV	R0,-(SP)	;    R0
	MOV	5*2(SP),-(SP)	;NOW RESAVE R5 ON STACK TOP
	RETURN	R5		;SO WE CAN EXIT

;
;CALL	JSR	R5,REGRES
;
;POPS R0-R5 FROM STACK LEAVING CARRY UNCHANGED
;

REGRES::INC	(SP)+		;DUMP CALLING R5 LEAVING CARRY ALONE
	MOV	(SP)+,R0	;RESTORE REGISTERS R0
	MOV	(SP)+,R1	; R1
	MOV	(SP)+,R2	;  R2
	MOV	(SP)+,R3	;   R3
	MOV	(SP)+,R4	;    R4
	RETURN	R5		;NOW WE CAN EXIT

.SBTTL	PATCH SPACE
PATCH::	.BLKW0	128.
SGNPA1:
