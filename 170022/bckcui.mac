.INCLUDE /SYSTEM:BCKPFX/
TITLE	BCKCUI,<Backup Common User Interface>,0B,21-JUN-91,BSB/KPH/FRL/BGN

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	Edit history for BCKCUI

;+
;
;  000	BSB  04-Nov-83	Creation for Version 9.0
;  001	KPH  03-Oct-84	Bugfixes
;  002	KPH  29-Nov-84	Implement TELL qualifier; /BUF=MAX
;			Add privilege check
;  003	KPH  09-Jan-84	Add private pool routines
;  004	KPH  06-Mar-85	Add /PLACED_POSITION
;			Replace /OPTIMIZE=EXECUTABLE with /OPTIMIZE=DIRECTORY
;			Remove /ERROR
;			Remove /LOG
;			Add /REPLACE=QUERY
;			Remove /DOS
;			Add small buffer waits
;			Bugfixes in /END
;
;			[RSTS V9.1]
;  005  KPH  05-Jun-85	Add high density support
;			Change /ACCOUNT_DATA qualifier default
;  006  KPH  13-Jun-85	Add /DENSITY={MINIMUM,MAXIMUM}
;
;			[RSTS V9.2]
;  007  FRL  20-Jan-86	Set proper defaults for /END based on device type
;  008  FRL  27-Feb-86	Bug fix in /END handling
;
;			[RSTS V9.3]
;  009  KPH  20-Jan-86	Add /CRC switch
;  010  FRL  28-Apr-86	Add installation qualifiers and redefine /[NO]TELL
;  011  FRL  28-Jul-86	Add MAX and MIN keywords for /BLOCKSIZE
;  012  FRL  28-Jul-86	Up-case labels
;  013  FRL  28-Jul-86  Make filename in BACKUP in-spec optional
;  014  FRL  29-Jul-86	Allow multi-public disks
;  015  FRL  03-Sep-86	Fix save set name length
;
;			[RSTS V9.4/V9.5]
;  016  BGN  08-Jun-87  Change /GROUP_SIZE range to be 0 to 100.
;  017  BGN  29-Jun-87  Add /DIRECTORY support
;  018  BGN   2-Sep-87  Bug fixes to /DIRECTORY support
;  019  BGN   9-Oct-87  Add optimum buffer size for MS/MU
;
;			[RSTS V9.6]
;  020  BGN  24-May-88  Bug fix to 019; don't cancel user specified value
;
;			[RSTS V9.7]
;  021  BGN  14-Feb-89	/LIST should not conflict with /DIRECTORY
;  022  BGN   4-Apr-89	Addition to fix 020
;  023  BGN   3-May-89	Add /NOHEADER qualifier, allow users without install
;			priv to run BACKUP
;
;			[RSTS V10.0]
;  024	FEK  12-Oct-89	Allow Larger Magtape Recordsizes
;  025  BGN  26-Oct-89  Add hooks for Image mode development
;  026  BGN  10-Nov-89	Enable image mode
;  027	REG  30-Nov-89	Merge /INIT options from GPK
;  028	REG  06-Dec-89	Add exit with status
;  029	REG  07-Dec-89	Add /COPY option
;  030	REG  19-Dec-89	Add /VERIFY=ONLY option
;  031	REG  28-Dec-89	Add OMS interface, change DO.COP to IM$COP
;  032	REG  08-Jan-90	Add error for PPN/filespecs with /IMAGE
;  033	REG  09-Jan-90	Allow /OPTIMIZE and /PLACED on BACKUP/IMAGE
;  034	REG  14-Jan-90	Allow /REPLACE=QUERY on /COPY
;  035	REG  24-Jan-90	Trap conflicts: /COP,/IMA,/REP,/PLA,/OPT,/DIR
;  036	REG  29-Jan-90	Make sure /IMAGE and /COPY use disk-only devices
;  037	REG  07-Feb-90	Make /DIR work the same for restore as for backup
;  038	REG  18-Feb-90	/REPLACE=ASSIST
;  039	REG  18-Feb-90  Disallow /BUFF if no TUNE priv
;  040	REG  20-Feb-90	Add new /INIT stuff to Restore command
;  041  REG  03-Apr-90	Add big blocks
;  042  REG  03-Apr-90	Add DSKINT/[NO]QUERY
;  043  REG  03-Apr-90	Remove /LOG
;  044  REG  03-Apr-90	Add /QUERY=ASSIST
;  045  REG  03-APR-90	Fix /ASSIST code
;  046  REG  05-Apr-90	Restructure for BA/DI, RE/DI, BA/IM, BA/CO
;  047  REG  10-Apr-90	Disable /REPLACE=ASSIST and /QUERY=ASSIST for V10.0
;  048  REG  14-Apr-90	Establish 6 separate commands: BACKUP, RESTORE,
;			BACKUP/DIRECTORY, BACKUP/IMAGE, BACKUP/COPY
;  049  REG  14-APR-90	Add [NO] to /OUTPUT for compatibility with /LIST_FILE
;  050  REG  14-Apr-90	Check for RDNFS and SYSMOD for HOOK
;  051  REG  14-Apr-90  Add Y/ALL and N/ALL for /QUERY
;  052  REG  14-Apr-90	Add /SELECT to BACKUP/DIRECTORY
;  053  REG  20-Apr-90	Error if any /INIT args and output is tape
;  054  REG  29-Apr-90	"BEFORE=date_n" should not include "date_n"
;  055  REG  03-May-90	Allow EXERCISE=0 like DSKINT does
;  056  REG  03-May-90	Check for WRTNFS for HOOK
;  057  REG  15-May-90	Allow /REWIND for disk (NOP, no error)
;  058  REG  20-JUN-90	Add defaults /acc and /fil to /image
;  059  REG  21-JUN-90	Fix HOOK priv tests
;  060  REG  09-Aug-90	Make default PCS=0 for /INIT
;  061  REG  23-Aug-90	Clear the "priv" bit in the line number
;
;			[RSTS V10.1]
;  062  REG  26-Sep-90	Fix RESTORE/INIT=args TAPE: DISK: bug;
;			Fix BEFORE date/time defaults.
;  063  REG  25-Jan-91	Don't let /GROUPSIZE set group size to 0
;  064  REG  25-Jan-91	Don't allow QF.ALIS on /END; allow =REW on all commands
;  065  REG  03-Apr-91	Do not set buffer size to optimum if no TUNE priv
;  066  REG  08-Apr-91	Change OPTIMUM buffer size to 85
;  067  REG  21-May-91	Don't exit with status unless ours is more severe
;-

.SBTTL	BCKCUI	Macro definitions

;+
;	$QUALTBL	
;
;	This macro builds the dispatching table for qualifiers
;	to the commands. 'TAG' is the address of the qualifier
;	that CUI is to check for, 'BIT' is the bit in C$FLAG to 
;	set if that qualifier is found and is not preceeded by "NO",
;	and 'ADDR' is the address of the routine to go to if 
;	that qualifier is defined. If BIT=0 then there is no
;	bit to be set, if ADDR=0 then there is no rotuine to 
;	go to to process this qualifier.
;
;-

.MACRO	$QUALTBL TAG,BIT=0,ADDR=RTSPC
	.WORD	TAG,BIT,ADDR
.ENDM


.SBTTL	Call any needed MACROs

.MCALL	$CUI,EXIT$S,EXST$S,REPAINT,SUBR					;067

$CUI	TABLE
	.PSECT	CUICMN,RW,D,GBL,REL,CON,SAV
$CUI	ALLOC
$CUI	MSG
$CUI


.SBTTL	BACKUP qualifier definitions

	.PSECT	RODATA,RO,D,LCL,REL,CON

$BCK.Q:
	DEFQUAL	$ACC.Q, FLAGS=QF.NEG		;/[NO]ACCOUNT_DATA
	DEFQUAL	$AST.Q, FLAGS=QF.NEG		;/[NO]ASSIST		;031
	DEFQUAL	$BLK.Q, ARG=REQ			;/BLOCK_SIZE=
		DEFARG	$MIN.A			;Minimum		;011
		DEFARG	$MAX.A			;Maximum		;011
		DEFARG	TYPE=U$U16					;001
		ENDARG
	DEFQUAL	$BUF.Q,	ARG=REQ			;/BUFFER_SIZE=
		DEFARG	$MAX.A			;MAXIMUM		;002
		DEFARG	$OPT.A			;OPTIMUM		;019
		DEFARG	TYPE=U$U8, MINVAL=3, MAXVAL = 255
		ENDARG
	DEFQUAL	$CRC.Q, FLAGS=QF.NEG		;/[NO]CRC		;009
	DEFQUAL	$CRE.Q, FLAGS= QF.ALIS, ARG=REQ	;/CREATED=
		DEFARG	$AFT.A, ARG=REQ		;AFTER:
			DEFARG	TYPE=U$TIME
			ENDARG
		DEFARG	$BEF.A, ARG=REQ		;BEFORE:
			DEFARG	TYPE=U$TIME
			ENDARG
		DEFARG	 TYPE=U$TIME		;A specific time
		ENDARG
	DEFQUAL	$DEN.Q,ARG=REQ			;/DENSITY=
		DEFARG	$MIN.A			;Minimum		;006
		DEFARG	$MAX.A			;Maximum		;006
		DEFARG	TYPE=U$U16, MINVAL=1, MAXVAL=32767		;005
		ENDARG
	DEFQUAL	$END.Q,	ARG=REQ			;/END=			;064
		DEFARG	$RWD.A,FLAGS=AF.NEG	;[NO]REWIND
		DEFARG	$DIS.A,FLAGS=AF.NEG	;[NO]DISMOUNT
		ENDARG
	DEFQUAL	$EXC.Q, ARG=REQ, FLAGS=QF.ALIS	;/EXCLUDE=
		DEFARG	TYPE=LF.N.W
		ENDARG
	DEFQUAL	$FIL.Q, FLAGS=QF.NEG		;/[NO]FILE_DATA
	DEFQUAL	$GRP.Q, FLAGS=QF.NEG, ARG=OPT	;/[NO]GROUP_SIZE=
		DEFARG	TYPE=U$U16,MAXVAL=100	;016
		ENDARG
	DEFQUAL	$HEA.Q, FLAGS=QF.NEG		;/[NO]HEADER		;023
	DEFQUAL	$INC.Q, FLAGS=QF.ALIS, ARG=REQ	;/INCLUDE=
		DEFARG	TYPE=LF.N.W
		ENDARG
	DEFQUAL	$INI.Q,	FLAGS=QF.NEG!QF.ALIS, ARG=OPT ;[NO]INITIALIZE=	;027
		DEFARG	$CLU.A,	ARG=REQ		;CLUSTER_SIZE=n		;027
			DEFARG	TYPE=U$U8, MINVAL=1, MAXVAL=64		;027
			ENDARG						;027
		DEFARG	$ERA.A,	FLAGS=QF.NEG	;[NO]ERASE		;027
		DEFARG	$QUE.A, FLAGS=QF.NEG	;[NO]QUERY		;042
		DEFARG	$EXE.A, FLAGS=QF.NEG, ARG=OPT ;[NO]EXERCISE=n	;055
			DEFARG	TYPE=U$U8, MINVAL=0, MAXVAL=3		;027
			ENDARG						;027
		ENDARG							;027
	DEFQUAL	$ILB.Q, ARG=REQ			;/IN_LABEL=
		DEFARG	TYPE=U$LBL
		ENDARG
	DEFQUAL	$INS.Q				;/INSTALL		;010
	DEFQUAL	$LIS.Q,FLAGS=QF.NEG,ARG=OPT,CONF=$OUT.Q	;/[NO]LIST_FILE=;001
		DEFARG	TYPE=LF.N
		ENDARG
	DEFQUAL	$MOD.Q, FLAGS=QF.ALIS, ARG=REQ	;/MODIFIED=
		DEFARG	$AFT.A, ARG=REQ		;AFTER=
			DEFARG	TYPE=U$TIME
			ENDARG
		DEFARG	$BEF.A, ARG=REQ		;BEFORE=
			DEFARG	TYPE=U$TIME
			ENDARG
		DEFARG	 TYPE=U$TIME		;A specific time
		ENDARG
	DEFQUAL	$OUT.Q, ARG=OPT, CONF=$LIS.Q, FLAGS=QF.NEG ;/[NO]OUTPUT=;049
		DEFARG	TYPE=LF.N					;017
		ENDARG							;017
	DEFQUAL	$OLB.Q, ARG=REQ			;/OUT_LABEL=
		DEFARG	TYPE=U$LBL
		ENDARG
	DEFQUAL	$PRO.Q, FLAGS=QF.NEG		;/[NO]PROMPT
	DEFQUAL	$QRY.Q, FLAGS=QF.NEG		;/[NO]QUERY		;047
;	DEFQUAL	$QRY.Q, FLAGS=QF.NEG, ARG=OPT	;/[NO]QUERY
;		DEFARG	$ASS.A			;=ASSIST		;044
;		ENDARG							;004
	DEFQUAL	$REW.Q, FLAGS=QF.NEG		;/[NO]REWIND
	DEFQUAL	$VER.Q, FLAGS=QF.NEG, ARG=OPT	;/[NO]VERIFY=		;030
		DEFARG	$ONL.A			;ONLY			;030
		ENDARG							;030
	DEFQUAL	$VOL.Q, FLAGS=QF.NEG, ARG=REQ, REQUIRE=$INS.Q ;/[NO]VOLUME= ;010
		DEFARG	TYPE=U$U16, MINVAL=1, MAXVAL=32767		;010
		ENDARG							;010
	ENDQUAL

.SBTTL	BACKUP/DIRECTORY and RESTORE/DIRECTORY qualifier definitions	;046+

	.PSECT	RODATA,RO,D,LCL,REL,CON

$DIR.Q:
	DEFQUAL	$AST.Q, FLAGS=QF.NEG		;/[NO]ASSIST		;031
	DEFQUAL	$BRF.Q				;/BRIEF			;017
	DEFQUAL	$BUF.Q,	ARG=REQ			;/BUFFER_SIZE=
		DEFARG	$MAX.A			;MAXIMUM		;002
		DEFARG	$OPT.A			;OPTIMUM		;019
		DEFARG	TYPE=U$U8, MINVAL=3, MAXVAL = 255
		ENDARG
	DEFQUAL	$CRE.Q, FLAGS= QF.ALIS, ARG=REQ	;/CREATED=
		DEFARG	$AFT.A, ARG=REQ		;AFTER:
			DEFARG	TYPE=U$TIME
			ENDARG
		DEFARG	$BEF.A, ARG=REQ		;BEFORE:
			DEFARG	TYPE=U$TIME
			ENDARG
		DEFARG	 TYPE=U$TIME		;A specific time
		ENDARG
	DEFQUAL	$END.Q,	ARG=REQ			;/END=			;064
		DEFARG	$RWD.A,FLAGS=AF.NEG	;[NO]REWIND
		DEFARG	$DIS.A,FLAGS=AF.NEG	;[NO]DISMOUNT
		ENDARG
	DEFQUAL	$EXC.Q, ARG=REQ, FLAGS=QF.ALIS	;/EXCLUDE=
		DEFARG	TYPE=LF.N.W
		ENDARG
	DEFQUAL	$FUL.Q				;/FULL 			;017
	DEFQUAL	$ILB.Q, ARG=REQ			;/IN_LABEL=
		DEFARG	TYPE=U$LBL
		ENDARG
	DEFQUAL	$INC.Q, FLAGS=QF.ALIS, ARG=REQ	;/INCLUDE=
		DEFARG	TYPE=LF.N.W
		ENDARG
	DEFQUAL	$INS.Q				;/INSTALL		;010
	DEFQUAL	$LIS.Q,FLAGS=QF.NEG,ARG=OPT,CONF=$OUT.Q	;/[NO]LIST_FILE=;001
		DEFARG	TYPE=LF.N
		ENDARG
	DEFQUAL	$MOD.Q, FLAGS=QF.ALIS, ARG=REQ	;/MODIFIED=
		DEFARG	$AFT.A, ARG=REQ		;AFTER=
			DEFARG	TYPE=U$TIME
			ENDARG
		DEFARG	$BEF.A, ARG=REQ		;BEFORE=
			DEFARG	TYPE=U$TIME
			ENDARG
		DEFARG	 TYPE=U$TIME		;A specific time
		ENDARG
	DEFQUAL	$OCC.Q, ARG=REQ			;/OCCURANCE=
		DEFARG	TYPE=U$INT
		ENDARG                                                         
	DEFQUAL	$OUT.Q, ARG=OPT, CONF=$LIS.Q, FLAGS=QF.NEG ;/[NO]OUTPUT=;049
		DEFARG	TYPE=LF.N					;017
		ENDARG							;017
	DEFQUAL	$PRO.Q, FLAGS=QF.NEG		;/[NO]PROMPT
	DEFQUAL	$REW.Q, FLAGS=QF.NEG		;/[NO]REWIND
	DEFQUAL	$SEL.Q,ARG=REQ,FLAGS=QF.ALIS	;/SELECT=		;052
	 	DEFARG	TYPE=LF..W		;A list of local file names;052
		ENDARG							;052
	DEFQUAL	$VOL.Q, FLAGS=QF.NEG, ARG=REQ, REQUIRE=$INS.Q ;/[NO]VOLUME= ;010
		DEFARG	TYPE=U$U16, MINVAL=1, MAXVAL=32767		;010
		ENDARG							;010
	ENDQUAL								;046-

.SBTTL	BACKUP/IMAGE qualifier definitions				;046+

	.PSECT	RODATA,RO,D,LCL,REL,CON

$IMA.Q:
	DEFQUAL	$AST.Q, FLAGS=QF.NEG		;/[NO]ASSIST		;031
	DEFQUAL	$BLK.Q, ARG=REQ			;/BLOCK_SIZE=
		DEFARG	$MIN.A			;Minimum		;011
		DEFARG	$MAX.A			;Maximum		;011
		DEFARG	TYPE=U$U16					;001
		ENDARG
	DEFQUAL	$BUF.Q,	ARG=REQ			;/BUFFER_SIZE=
		DEFARG	$MAX.A			;MAXIMUM		;002
		DEFARG	$OPT.A			;OPTIMUM		;019
		DEFARG	TYPE=U$U8, MINVAL=3, MAXVAL = 255
		ENDARG
	DEFQUAL	$END.Q,	ARG=REQ			;/END=			;064
		DEFARG	$RWD.A,FLAGS=AF.NEG	;[NO]REWIND		;064
		DEFARG	$DIS.A,FLAGS=AF.NEG	;[NO]DISMOUNT
		ENDARG
	DEFQUAL	$ILB.Q, ARG=REQ			;/INLABEL=
		DEFARG	TYPE=U$LBL
		ENDARG
	DEFQUAL	$INI.Q,	FLAGS=QF.NEG!QF.ALIS, ARG=OPT ;[NO]INITIALIZE=	;027
		DEFARG	$CLU.A,	ARG=REQ		;CLUSTER_SIZE=n		;027
			DEFARG	TYPE=U$U8, MINVAL=1, MAXVAL=64		;027
			ENDARG						;027
		DEFARG	$ERA.A,	FLAGS=QF.NEG	;[NO]ERASE		;027
		DEFARG	$QUE.A, FLAGS=QF.NEG	;[NO]QUERY		;042
		DEFARG	$EXE.A, FLAGS=QF.NEG, ARG=OPT ;[NO]EXERCISE=n	;027
			DEFARG	TYPE=U$U8, MINVAL=0, MAXVAL=3		;055
			ENDARG						;027
		ENDARG							;027
	DEFQUAL	$LIS.Q,FLAGS=QF.NEG,ARG=OPT,CONF=$OUT.Q	;/[NO]LIST_FILE=;001
		DEFARG	TYPE=LF.N
		ENDARG
	DEFQUAL	$OPT.Q, ARG=OPT, FLAGS=QF.NEG!QF.ALIS ;/[NO]OPTIMIZE	;033
		DEFARG	$CLU.A			;=CLUSTER_SIZE		;033
		DEFARG	$DIR.A			;=DIRECTORY		;033
		ENDARG							;033
	DEFQUAL	$OUT.Q, ARG=OPT, CONF=$LIS.Q, FLAGS=QF.NEG ;/[NO]OUTPUT=;049
		DEFARG	TYPE=LF.N					;017
		ENDARG							;017
	DEFQUAL	$OLB.Q, ARG=REQ			;/OUT_LABEL=
		DEFARG	TYPE=U$LBL
		ENDARG
	DEFQUAL	$PLA.Q, ARG=REQ			;/PLACED_POSITION=	;033
		DEFARG	$MID.A			;MIDDLE			;033
		DEFARG	$ORI.A			;ORIGINAL		;033
		DEFARG	$IND.A			;INDEX			;033
		ENDARG							;033
	DEFQUAL	$PRO.Q, FLAGS=QF.NEG		;/[NO]PROMPT
	DEFQUAL	$REP.Q, ARG=OPT, FLAGS=QF.NEG	;/[NO]REPLACE=		;004
		DEFARG	$QUE.A			;=QUERY			;038
;		DEFARG	$ASS.A			;=ASSIST		;047
		ENDARG							;004
	DEFQUAL	$VER.Q, FLAGS=QF.NEG, ARG=OPT	;/[NO]VERIFY=		;030
		DEFARG	$ONL.A			;ONLY			;030
		ENDARG							;030
	ENDQUAL								;046-

.SBTTL	BACKUP/COPY qualifier definitions				;046+

	.PSECT	RODATA,RO,D,LCL,REL,CON

$COP.Q:
	DEFQUAL	$ACC.Q, FLAGS=QF.NEG		;/[NO]ACCOUNT_DATA
	DEFQUAL	$AST.Q, FLAGS=QF.NEG		;/[NO]ASSIST		;031
	DEFQUAL	$BLK.Q, ARG=REQ			;/BLOCK_SIZE=
		DEFARG	$MIN.A			;Minimum		;011
		DEFARG	$MAX.A			;Maximum		;011
		DEFARG	TYPE=U$U16					;001
		ENDARG
	DEFQUAL	$BUF.Q,	ARG=REQ			;/BUFFER_SIZE=
		DEFARG	$MAX.A			;MAXIMUM		;002
		DEFARG	$OPT.A			;OPTIMUM		;019
		DEFARG	TYPE=U$U8, MINVAL=3, MAXVAL = 255
		ENDARG
	DEFQUAL	$CRE.Q, FLAGS= QF.ALIS, ARG=REQ	;/CREATED=
		DEFARG	$AFT.A, ARG=REQ		;AFTER:
			DEFARG	TYPE=U$TIME
			ENDARG
		DEFARG	$BEF.A, ARG=REQ		;BEFORE:
			DEFARG	TYPE=U$TIME
			ENDARG
		DEFARG	 TYPE=U$TIME		;A specific time
		ENDARG
	DEFQUAL	$END.Q,	ARG=REQ			;/END=			;064
		DEFARG	$RWD.A,FLAGS=AF.NEG	;[NO]REWIND		;064
		DEFARG	$DIS.A,FLAGS=AF.NEG	;[NO]DISMOUNT
		ENDARG
	DEFQUAL	$EXC.Q, ARG=REQ, FLAGS=QF.ALIS	;/EXCLUDE=
		DEFARG	TYPE=LF.N.W
		ENDARG
	DEFQUAL	$FIL.Q, FLAGS=QF.NEG		;/[NO]FILE_DATA
	DEFQUAL	$ILB.Q, ARG=REQ			;/IN_LABEL=
		DEFARG	TYPE=U$LBL
		ENDARG
	DEFQUAL	$INC.Q, FLAGS=QF.ALIS, ARG=REQ	;/INCLUDE=
		DEFARG	TYPE=LF.N.W
		ENDARG
	DEFQUAL	$INI.Q,	FLAGS=QF.NEG!QF.ALIS, ARG=OPT ;[NO]INITIALIZE=	;027
		DEFARG	$CLU.A,	ARG=REQ		;CLUSTER_SIZE=n		;027
			DEFARG	TYPE=U$U8, MINVAL=1, MAXVAL=64		;027
			ENDARG						;027
		DEFARG	$ERA.A,	FLAGS=QF.NEG	;[NO]ERASE		;027
		DEFARG	$QUE.A, FLAGS=QF.NEG	;[NO]QUERY		;042
		DEFARG	$EXE.A, FLAGS=QF.NEG, ARG=OPT ;[NO]EXERCISE=n	;027
			DEFARG	TYPE=U$U8, MINVAL=0, MAXVAL=3		;055
			ENDARG						;027
		ENDARG							;027
	DEFQUAL	$LIS.Q,FLAGS=QF.NEG,ARG=OPT,CONF=$OUT.Q	;/[NO]LIST_FILE=;001
		DEFARG	TYPE=LF.N
		ENDARG
	DEFQUAL	$MOD.Q, FLAGS=QF.ALIS, ARG=REQ	;/MODIFIED=
		DEFARG	$AFT.A, ARG=REQ		;AFTER=
			DEFARG	TYPE=U$TIME
			ENDARG
		DEFARG	$BEF.A, ARG=REQ		;BEFORE=
			DEFARG	TYPE=U$TIME
			ENDARG
		DEFARG	 TYPE=U$TIME		;A specific time
		ENDARG
	DEFQUAL	$OPT.Q, ARG=OPT, FLAGS=QF.NEG!QF.ALIS ;/[NO]OPTIMIZE	;033
		DEFARG	$CLU.A			;=CLUSTER_SIZE		;033
		DEFARG	$DIR.A			;=DIRECTORY		;033
		ENDARG							;033
	DEFQUAL	$OUT.Q, ARG=OPT, CONF=$LIS.Q, FLAGS=QF.NEG ;/[NO]OUTPUT=;049
		DEFARG	TYPE=LF.N					;017
		ENDARG							;017
	DEFQUAL	$OLB.Q, ARG=REQ			;/OUT_LABEL=
		DEFARG	TYPE=U$LBL
		ENDARG
	DEFQUAL	$PLA.Q, ARG=REQ			;/PLACED_POSITION=	;033
		DEFARG	$MID.A			;MIDDLE			;033
		DEFARG	$ORI.A			;ORIGINAL		;033
		DEFARG	$IND.A			;INDEX			;033
		ENDARG							;033
	DEFQUAL	$PRO.Q, FLAGS=QF.NEG		;/[NO]PROMPT
	DEFQUAL	$QRY.Q, FLAGS=QF.NEG		;/[NO]QUERY		;047
;	DEFQUAL	$QRY.Q, FLAGS=QF.NEG, ARG=OPT	;/[NO]QUERY
;		DEFARG	$ASS.A			;=ASSIST		;044
;		ENDARG							;004
	DEFQUAL	$REP.Q, ARG=OPT, FLAGS=QF.NEG	;/[NO]REPLACE=		;004
		DEFARG	$QUE.A			;=QUERY			;038
;		DEFARG	$ASS.A			;=ASSIST		;047
		ENDARG							;004
	DEFQUAL	$VER.Q, FLAGS=QF.NEG, ARG=OPT	;/[NO]VERIFY=		;030
		DEFARG	$ONL.A			;ONLY			;030
		ENDARG							;030
	ENDQUAL								;046-

.SBTTL	RESTORE Qualifier definitions

	.PSECT	RODATA,RO,D,LCL,REL,CON

$RES.Q:
	DEFQUAL	$ACC.Q, FLAGS=QF.NEG		;/[NO]ACCOUNT_DATA
	DEFQUAL	$AST.Q, FLAGS=QF.NEG		;/[NO]ASSIST		;031
	DEFQUAL	$BUF.Q,	ARG=REQ			;/BUFFER_SIZE=
		DEFARG	$MAX.A			;MAXIMUM		;002
		DEFARG	$OPT.A			;OPTIMUM		;019
		DEFARG	TYPE=U$U8, MINVAL=3, MAXVAL = 255
		ENDARG
	DEFQUAL	$CRE.Q, FLAGS= QF.ALIS, ARG=REQ	;/CREATED=
		DEFARG	$AFT.A, ARG=REQ		;AFTER:
			DEFARG	TYPE=U$TIME
			ENDARG
		DEFARG	$BEF.A, ARG=REQ		;BEFORE:
			DEFARG	TYPE=U$TIME
			ENDARG
		DEFARG	 TYPE=U$TIME		;A specific time
		ENDARG
	DEFQUAL	$END.Q,	ARG=REQ			;/END=			;064
		DEFARG	$RWD.A,FLAGS=AF.NEG	;[NO]REWIND
		DEFARG	$DIS.A,FLAGS=AF.NEG	;[NO]DISMOUNT
		ENDARG
	DEFQUAL	$EXC.Q, ARG=REQ, FLAGS=QF.ALIS	;/EXCLUDE=
		DEFARG	TYPE=LF.N.W
		ENDARG
	DEFQUAL	$FIL.Q, FLAGS=QF.NEG		;/[NO]FILE_DATA
	DEFQUAL	$ILB.Q, ARG=REQ			;/IN_LABEL=
		DEFARG	TYPE=U$LBL
		ENDARG
	DEFQUAL	$INC.Q, FLAGS=QF.ALIS, ARG=REQ	;/INCLUDE=
		DEFARG	TYPE=LF.N.W
		ENDARG
	DEFQUAL	$INI.Q,	FLAGS=QF.NEG!QF.ALIS, ARG=OPT ;[NO]INITIALIZE=	;040
		DEFARG	$CLU.A,	ARG=REQ		;CLUSTER_SIZE=n		;040
			DEFARG	TYPE=U$U8, MINVAL=1, MAXVAL=64		;040
			ENDARG						;040
		DEFARG	$ERA.A,	FLAGS=QF.NEG	;[NO]ERASE		;040
		DEFARG	$QUE.A,	FLAGS=QF.NEG	;[NO]QUERY		;042
		DEFARG	$EXE.A, FLAGS=QF.NEG, ARG=OPT ;[NO]EXERCISE=n	;040
			DEFARG	TYPE=U$U8, MINVAL=0, MAXVAL=3		;055
			ENDARG						;040
		ENDARG							;040
	DEFQUAL	$INS.Q				;/INSTALL		;010
	DEFQUAL	$LIS.Q,FLAGS=QF.NEG,ARG=OPT,CONF=$OUT.Q ;/[NO]LIST_FILE=
		DEFARG	TYPE=LF.N
		ENDARG
	DEFQUAL	$MOD.Q, FLAGS=QF.ALIS, ARG=REQ	;/MODIFIED=
		DEFARG	$AFT.A, ARG=REQ		;AFTER=
			DEFARG	TYPE=U$TIME
			ENDARG
		DEFARG	$BEF.A, ARG=REQ		;BEFORE=
			DEFARG	TYPE=U$TIME
			ENDARG
		DEFARG	 TYPE=U$TIME		;A specific time
		ENDARG
	DEFQUAL	$OCC.Q, ARG=REQ			;/OCCURANCE=
		DEFARG	TYPE=U$INT
		ENDARG                                                         
	DEFQUAL	$OPT.Q, ARG=OPT, FLAGS=QF.NEG!QF.ALIS ;/[NO]OPTIMIZE
		DEFARG	$CLU.A			;=CLUSTER_SIZE		;004
		DEFARG	$DIR.A			;=DIRECTORY		;004
		ENDARG
	DEFQUAL	$OLB.Q, ARG=REQ			;/OUT_LABEL=
		DEFARG	TYPE=U$LBL
		ENDARG                                                         
	DEFQUAL	$OUT.Q, ARG=OPT, CONF=$LIS.Q, FLAGS=QF.NEG ;/[NO]OUTPUT=;049
		DEFARG	TYPE=LF.N
		ENDARG
	DEFQUAL	$PLA.Q, ARG=REQ			;/PLACED_POSITION=	;004
		DEFARG	$MID.A			;MIDDLE			;004
		DEFARG	$ORI.A			;ORIGINAL		;004
		DEFARG	$IND.A			;INDEX			;004
		ENDARG							;004
	DEFQUAL	$PRO.Q,	FLAGS=QF.NEG		;/[NO]PROMPT
	DEFQUAL	$QRY.Q, FLAGS=QF.NEG		;/[NO]QUERY		;047
;	DEFQUAL	$QRY.Q, FLAGS=QF.NEG, ARG=OPT	;/[NO]QUERY
;		DEFARG	$ASS.A			;=ASSIST		;044
;		ENDARG							;004
	DEFQUAL	$REP.Q, ARG=OPT, FLAGS=QF.NEG	;/[NO]REPLACE=		;004
		DEFARG	$QUE.A			;=QUERY			;004
;		DEFARG	$ASS.A			;=ASSIST		;047
		ENDARG							;004
	DEFQUAL	$REW.Q, FLAGS=QF.NEG		;/[NO]REWIND
	DEFQUAL	$SEL.Q,ARG=REQ,FLAGS=QF.ALIS	;/SELECT=
	 	DEFARG	TYPE=LF..W		;A list of local file names
		ENDARG                                                         
	DEFQUAL	$TEL.Q, FLAGS=QF.NEG		;/[NO]TELL		;010
	DEFQUAL	$VER.Q, FLAGS=QF.NEG, ARG=OPT	;/[NO]VERIFY=		;030
		DEFARG	$ONL.A			;ONLY			;030
		ENDARG							;030
	DEFQUAL	$VOL.Q, FLAGS=QF.NEG, ARG=REQ, REQUIRE=$INS.Q ;/[NO]VOLUME= ;010
		DEFARG	TYPE=U$U16, MINVAL=1, MAXVAL=32767		;010
		ENDARG							;010
	ENDQUAL                                                         

.SBTTL	Local Data section 

	.PSECT	RWDATA,RW,D,LCL,REL,CON

INITSP:	.BLKW			;Saved SP for error restarts
ENT.TY:	.BLKW			;Entry type filled in here
DEVPOS:	.BLKW			;Position of backup device filled in here
POOLST:	.BLKW			;Root of linked list of CUI pool blocks	;003

	.PSECT	RODATA,RO,D,LCL,REL,CON

$BCK.P:	.ASCIC	^"/Backup> /"	; BACKUP Prompt

$IN.P:	.ASCIC	<"From: ">	; Input spec prompt

$OUT.P:	.ASCIC	<"To: ">	; Output spec prompt

MODNAM:	.ASCIC	<"BCKCUI">	; Error message text

PRTUNE:	.ASCIC	<"TUNE">	; TUNE privilege name			;002

PRRDNF:	.ASCIC	<"RDNFS">	; RDNFS privilege name			;050

PRWRTN:	.ASCIC	<"WRTNFS">	; WRTNFS privilege name			;056

PRSYSM:	.ASCIC	<"SYSMOD">	; SYSMOD privilege name			;050

BLKLOW:	.ASCIC	<"2048">	; Lowest legal blocksize

; The next two items are grouped (see CK.BLK for use)			;024
	.EVEN			; Make sure we line up.			;024
	.WORD	28672.		; Highest disk blocksize, numeric	;041
BLKHGH:	.ASCIC	<"28672">	; Highest legal blocksize for disk	;041

; The next two items are grouped (see CK.BLK for use)			;024
	.EVEN			; Make sure we line up.			;024
	.WORD	28672.		; Highest tape blocksize, numeric	;041
BLKHTP:	.ASCIC	<"28672">	; Highest legal blocksize for tape	;041

	.EVEN			; Make sure we line up.			;026
	.WORD	28672.		; Highest image blocksize		;041
BLKIMA:	.ASCIC	<"28672">	; Highest legal blocksize for image mode;041

	.EVEN			; if we aren't make it

.SBTTL	Qualifier description and dispatching table

;+
;	SWTBL:
;
;	This is a table that drives the qualifier parsing
;	routine. This table contains three (3) words per
;	valid qualifier. The words are as follows:
;
;	Word #1 - Address of the  qualifier tag to use in "FET.CQ"
;
;	Word #2 - Bit to set in C$FLAG if "/<switch>" was present in
;		  the positive form.
;
;	Word #3 - The routine to goto to if the "/<switch>" or
;		  "/NO<switch>" is used. Note that the routine 
;		  will be called if either form of the switch is present.
;
;-

SWTBL:
	$QUALTBL $ACC.Q,DO.ACC			; "/[NO]ACCOUNT_DATA"
	$QUALTBL $AST.Q,,ST.AST			; "/[NO]ASSIST"		;031
	$QUALTBL $BLK.Q,,CK.BLK			; "/BLOCK_SIZE="
	$QUALTBL $BUF.Q,,CK.BUF			; "/BUFFER_SIZE="
	$QUALTBL $CRC.Q,,CK.CRC			; "/[NO]CRC"		;009
	$QUALTBL $CRE.Q,,CK.CRE			; "/CREATE=" 		
	$QUALTBL $DEN.Q,,CK.DEN			; "/DENSITY="		;005
	$QUALTBL $END.Q,,CK.END			; "/END="
	$QUALTBL $EXC.Q,,CK.EXC			; "/EXCLUDE="
	$QUALTBL $FIL.Q,DO.FIL			; "/[NO]FILE_DATA"
	$QUALTBL $FUL.Q,DIR.FU			; "/FULL"
	$QUALTBL $GRP.Q,,CK.GRP			; "/[NO]GROUP_SIZE="
	$QUALTBL $HEA.Q,,CK.HEA			; "/[NO]HEADER"		;023
	$QUALTBL $ILB.Q,,CK.ILB			; "/IN_LABEL="
	$QUALTBL $INC.Q,,CK.INC			; "/INCLUDE="
	$QUALTBL $INI.Q,DO.INI,CK.INI		; "/[NO]INITIALIZE="	;027
	$QUALTBL $INS.Q,DO.INS			; "/INSTALL"		;010
	$QUALTBL $MOD.Q,,CK.MOD			; "/MODIFIED="
	$QUALTBL $OCC.Q,,CK.OCC			; "/OCCURRENCE="
	$QUALTBL $OLB.Q,,CK.OLB			; "/OUT_LABEL="
	$QUALTBL $OPT.Q,,CK.OPT			; "/[NO]OPTIMIZE="
	$QUALTBL $PLA.Q,,CK.PLA			; "/PLACED_POSITION="  	;004
	$QUALTBL $PRO.Q,,CK.PRO			; "/[NO]PROMPT"
	$QUALTBL $QRY.Q,DO.QRY,CK.QRY		; "/[NO]QUERY"		;044
	$QUALTBL $REP.Q,DO.REP,CK.REP		; "/[NO]REPLACE"
	$QUALTBL $REW.Q,DO.REW,CK.REW		; "/[NO]REWIND		;046
	$QUALTBL $SEL.Q,,CK.SEL			; "/SELECT="
	$QUALTBL $TEL.Q,,ST.TEL			; "/[NO]TELL"		;010
	$QUALTBL $VER.Q,DO.VER,CK.VER		; "/[NO]VERIFY="	;030
	$QUALTBL $VOL.Q,,ST.VOL			; "/[NO]VOLUME"		;010

; Note: The list qualifier is checked last so that the list file
;       will be opened only if necessary.

	$QUALTBL $LIS.Q,DO.LIS,CK.LIS		; "/[NO]LIST_FILE="
	$QUALTBL $OUT.Q,DO.LIS,CK.LIS		; "/[NO]OUTPUT="	;049

	.WORD	0				; End of the table.

.SBTTL	Get a command line from the user

;+
; BCKCUI - Get a command line from the user, first time
; CUIAGI - Get a command line from the user, we've been here before
; ERRTRY - Get another command line - we had an error with the first one
; 
; Come here to get a command line from the user. We will perform all
; context initialization and return with the environment set up to
; perform the requested operation.
;
; If the user wants to exit, we will exit for him. No return will be made to
; the caller.
;
;
; Entry is:
;
;	CALLX	BCKCUI
;	CALLX	CUIAGI
;	JMP	ERRTRY
;
; All registers are preserved on exit.
;-

	.PSECT	ROCODE,RO,I,LCL,REL,CON
				
.ENABL	LSB

ERRTRY:	MOV	INITSP,SP	;Restore the initial SP -- we had an error
	BR	5$		;And start our initialization

CUIAGI::SAVREG			;Save all registers
	MOV	SP,INITSP	;Save the stack pointer for error restarts
	CALLX	DETRGN		;Dump our dynamic region
	BR	5$		;And start our initialization

BCKCUI::SAVREG			;Save all registers
	MOV	SP,INITSP	;Save the stack pointer for error restarts
	MOV	#1,R2		;Initially guess at CCL entry
	BIC	#100000,@#FIRQB+FQNENT ;Clear the "priv" bit		;061
	CMP	@#FIRQB+FQNENT,#30000. ;Is this a CCL?
	BEQ	3$		;Yes, it sure is
	INC	R2		;Guess at chain entry
	CMP	@#FIRQB+FQNENT,#31000. ;Is this a chain?
	BEQ	3$		;Yes, it sure is (whatever that means)
	CMP	@#FIRQB+FQNENT,#30500. ;Is this a DCL entry?
	BEQ	2$		;Yes, it sure is
	CLR	R2		;Not a DCL entry, must be run by now
	BR	3$		;So go set it up

2$:	MOV	#16.,R2		;And entry type is 16.

3$:	MOV	R2,ENT.TY	;And the entry type
	CALBX	U.INI <#U.CMN,#ENT.TY> ;Initialize CUI now

5$:	CLR	POOLST		;Clear out pool pointer for goodness	;003
	CALLX	BCKINI		;Initialize the BACKUP data areas	;003
10$:	CALBX	U.DIA		;Go perform the dialogue & parse tree
	BCC	PARSE		;It worked, now parse parameters 
	CMP	R0,#EOF		;Did we get an EOF error?
	BNE	10$		;No, something else, CUI has dealt with it
	CMP	STATS,#1	;Did we finish the operation?		;067
	BEQ	20$		;Yes, so exit without setting status	;067
	EXST$S	STATS		;Exit with status after Ctrl-Z		;028
20$:	EXIT$S			;Exit without setting status		;067

.DSABL	LSB

GLOBAL	<EOF,STATS>
GLOBAL	<HBKSIZ>							;041

;+
;	Now we have a valid CUI command, take  the
;	parsed command back from CUI, set the necessary
;	bits and store the file specs.
;
;-

PARSE:	MOV	#PRTUNE,R2	;R2 -> Tune privilege			;002
	CALB	CHKPRV,R2	;Do we have TUNE privilege?		;002
	BCC	10$		;Yes, don't check for /BUFF		;023
5$:	CALBX	FET.CQ,<#$BUF.Q>;See if they said /BUFF			;039
	TST	U.CMN+U.PRES	;Did they?				;039
	BEQ	10$		;No, proceed				;039
	REPAINT	U.CMN+U.POS	;Yes, tell 'em it's a no-no		;039
	CMESSAGE #NEDPRV,R2	;And report the privilege needed	;002
	BR	ERRTRY		;Now try again				;002

	; It takes RDNFS, WRTNFS, and SYSMOD to be allowed to hook the	;050
	; output disk (on a BACKUP/IMAGE).				;050
10$:	BIC	#GF.HAL,GENFLG	;Reset the HOOK allowed flag		;050
	MOV	#PRRDNF,R2	;R2 -> RDNFS privilege			;050
	CALB	CHKPRV,R2	;Do we have RDNFS privilege?		;050
	BCS	12$		;No					;059
	MOV	#PRWRTN,R2	;R2 -> RDNFS privilege			;056
	CALB	CHKPRV,R2	;Do we have RDNFS privilege?		;056
	BCS	12$		;No					;059
	MOV	#PRSYSM,R2	;R2 -> SYSMOD privilege			;050
	CALB	CHKPRV,R2	;Do we have SYSMOD privilege?		;050
	BCS	12$		;No					;059
	BIS	#GF.HAL,GENFLG	;Set the HOOK allowed flag		;050
12$:									;050
	MOV	CMDLEN,R1	;R1 = Length of command line		;003
	CALLX	GETMEM		;Now get memory to buffer it away
	MOV	R0,CMDSAV	;Save the address of the saved command line
	MOV	#CMDBUF,R1	;R1 -> Caller's command line		;003
	MOV	CMDLEN,R2	;R2 = Length of saved string		;003
	MOV	R2,CMDSLN	;Save the length of the command
15$:	MOVB	(R1)+,(R0)+	;Move a byte
	SOB	R2,15$		;And loop for the whole thing
	CMP	U.CMN+U.CMDC,#$IMA.K ;Is this a BACKUP/IMAGE command?	;046
	BNE	150$		;No, don't set the flag			;046
	BIS	#DO.IMA,C$FLAG	;Set /IMAGE flag			;032
	BR	20$		;Proceed				;046

150$:	CMP	U.CMN+U.CMDC,#$COP.K ;Is this a BACKUP/COPY command?	;046
	BNE	16$		;No, don't set the flag			;046
	BIS	#IM$COP,IMGSUB	;Set /COPY flag				;031
	BIS	#DO.IMA,C$FLAG	;Set /IMAGE flag			;036
	BR	20$		;Proceed				;046

16$:	CMP	U.CMN+U.CMDC,#$BAC.K; Are we doing a BACKUP?
	BEQ	20$		;  ..Yup, the bit is cleared, go get parameters

	;If it wasn't IMA.K, COP.K, or BAC.K, it must be RES.K or DIRR.K;046
17$:	BIS	#DO.RES,C$FLAG	;  ....set the RESTORE flag		;017
	CALL	RESPAR		;    ...go parse the Restore parameters
	BR	30$		;     ... and then get the qualifiers

20$:	CALL	BACPAR		; Take care of the BACKUP parameters
	BIT	#IM$COP,IMGSUB	;Is this a /COPY?			;031
	BEQ	30$		;No, don't set an output mask		;029
	CALL	COPPAR		;Yes, do the restore mask		;029
30$:	CALL	G.QUAL		;  and then all the qualifiers
	MOV	BLKSIZ,BBHDAT+BBH$BS ;Set up the block size
	CALB	U$IPOL		;Return CUI's pool			;003
	RETURN			;And now we're done

GLOBAL	<$BAC.K,C$FLAGS,CMDSAV,CMDSLN,BLKSIZ,BBHDAT,NEDPRV,CMDLEN,CMDBUF> ;003
GLOBAL	<IMGSUB>							;031
GLOBAL	<$DIRR.K,$IMA.K,$COP.K>						;046
GLOBAL	<GENFLG>							;050

.SBTTL	CUI Dialogue Threads - $RDCMD

.PSECT	ROCODE

CMDTBL::$THR			; Read User's Command thread

	$RDCMD	,PROMPT=$BCK.P	; Get the command line from the user

	$PARKEY			; Command Keyword section
	$ONKEY	$DIRB.K,$D.CMD	;   BACKUP/DIR				;046
	$ONKEY	$DIRR.K,$D.CMD	;   RESTORE/DIR				;046
	$ONKEY	$IMA.K,$I.CMD	;   BACKUP/IMAGE			;046
	$ONKEY	$COP.K,$C.CMD	;   BACKUP/COPY				;046
	$ONKEY	$BAC.K,$B.CMD	;   BACKUP .....
	$ONKEY	$RES.K,$R.CMD	;   RESTORE ....
	$ENDKEY			; End of command list

	$ENDTHR

GLOBAL	<$BAC.K,$RES.K>

.SBTTL	CUI dialogue threads - BACKUP command definitions

$B.CMD:	$THR		

	$DEFCMD	,QUAL=$BCK.Q, U.CMDC=$BAC.K ; BACKUP command definition

	    $PARM IN.T , TYPE=LF..W, OCCURS=200, PROMPT=$IN.P
						;Input Device 		;013
	    $PARM OUT.T, TYPE=LF.., PROMPT=$OUT.P
						;Output Dev 		;017
	$ENDCMD

	DFLTCQ	$CRC.Q,NO	;Default to /NOCRC			;009
	DFLTCQ	$END.Q		;Default to /END			;004
	DFLTCQ	$FIL.Q		;Default to /FILES
	DFLTCQ	$ACC.Q		;And /ACCOUNTING			;005
	DFLTCQ	$LIS.Q		;Default to /LIST
	DFLTCQ	$OPT.Q		;Default to /OPTIMIZE			;033
	DFLTCQ	$PLA.Q		;Default to /PLACED_POSITION		;033
	DFLTKA	$PLA.Q,$IND.A	;Default for /PLACED_POSITION is INDEX	;033
	$DO			;Do some code				;042
	BIS	#C2$QRY,C$FLG2	;Default for DSKINT/QUERY=ON		;042
	BIC	#C2$QER,C$FLG2	;Default off for "N/ALL" flag		;051
	$ENDDO			;Finished with code			;042

	$FETP	IN.T		;Get the input spec			;048
	$DO			;Some code				;048
	CALL	CHKDSK		;Be sure that it is disk		;048
	$ENDDO			;					;048

	$FETP 	OUT.T		;Get the output spec			;018
	$DO			;Some code				;048
	CALL	CKMTDK		;Check for magtape or disk		;048
	$ENDDO			;					;048
	$CALL	BR.CMD		;And off to some common code		;048

	$ENDTHR			;End threaded language

GLOBAL	<$BAC.K,CONFPOS,U.CNFE>
GLOBAL	<TBKSIZ>							;041

.SBTTL	CUI dialogue threads - /DIRECTORY command definitions		;046

$D.CMD:	$THR								;046

	$DEFCMD	,QUAL=$DIR.Q, U.CMDC=$DIRR.K ; /DIR Command definition	;046

	    $PARM IN.T , TYPE=LF.., PROMPT=$IN.P ;Input Device 		;046

	$ENDCMD								;046

	DFLTCQ	$END.Q		;Default to /END			;046
	DFLTCQ	$LIS.Q		;Default to /LIST

	$DO								;046
	BIS	#GF.DIR,GENFLG	; Indicate a directory pass of save set	;046
	$ENDDO								;046

	$FETP 	IN.T		;Get the output spec			;046
	$DO			;Some code				;048
	CALL	CKMTDK		;Check for magtape or disk		;048
	$ENDDO			;					;048

	$CALL	BR.CMD		;Off to common code			;046

	$ENDTHR			;Exit from threads			;048

GLOBAL	<$DIRR.K,GENFLG>						;046

.SBTTL	CUI dialogue threads - RESTORE command definitions

$R.CMD:	$THR

	$DEFCMD	,QUAL=$RES.Q, U.CMDC=$RES.K	; RESTORE Command definition

	    $PARM	IN.T, TYPE=LF.., PROMPT=$IN.P			;046
						; Input parameter
	    $PARM	OUT.T,TYPE=LF..W, PROMPT=$OUT.P			;046
						; Output parameter
	$ENDCMD

	DFLTCQ	$END.Q		;Default to /END			;004
	DFLTCQ	$FIL.Q		;Default to /FILES
	DFLTCQ	$ACC.Q		;And /ACCOUNTING
	DFLTCQ	$LIS.Q		;Default to /LIST
	DFLTCQ	$OPT.Q		;Default to /OPTIMIZE
	DFLTCQ	$PLA.Q		;Default to /PLACED_POSITION
	DFLTKA	$PLA.Q,$IND.A	;Default for /PLACED_POSITION is INDEX
	$DO			;Do some code				;042
	BIS	#C2$QRY,C$FLG2	;Default for DSKINT/QUERY=ON		;042
	BIC	#C2$QER,C$FLG2	;Default off for "N/ALL" flag		;051
	$ENDDO			;Finished with code			;042

	$FETP 	OUT.T		;Get the output spec			;018
	$DO			;Some code				;048
	CALL	CHKDSK		;Be sure that it is disk		;048
	$ENDDO			;					;048

	$FETP 	IN.T		;Get the input spec			;007
	$DO			;Some code				;048
	CALL	CKMTDK		;Check for magtape or disk		;048
	$ENDDO			;					;048

	$CALL	BR.CMD		;And off to common code			;048

	$ENDTHR			;Exit from threads			;048

GLOBAL	<$RES.K>

.SBTTL	CUI dialogue threads - /IMAGE command definitions		;046

$I.CMD:	$THR								;046

	$DEFCMD	,QUAL=$IMA.Q, U.CMDC=$IMA.K ; /IMAGE Command definition	;046

	    $PARM IN.T , TYPE=LF..W, OCCURS=200, PROMPT=$IN.P		;046
						;Input Device 		;046
	    $PARM	OUT.T,TYPE=LF..W, PROMPT=$OUT.P			;046
						; Output parameter	;046
	$ENDCMD								;046

	$DO								;046
	BIS	#DO.IMA,C$FLAG	; Indicate image mode			;046
	BIS	#DO.FIL,C$FLAG	; Indicate /FILE_DATA			;058
	BIS	#DO.ACC,C$FLAG	; Indicate /ACCOUNT_DATA		;058
	$ENDDO								;046

	DFLTCQ	$END.Q		;Default to /END			;004
	DFLTCQ	$LIS.Q		;Default to /LIST
	DFLTCQ	$OPT.Q		;Default to /OPTIMIZE
	DFLTCQ	$PLA.Q		;Default to /PLACED_POSITION
	DFLTKA	$PLA.Q,$IND.A	;Default for /PLACED_POSITION is INDEX
	$DO			;Do some code				;042
	BIS	#C2$QRY,C$FLG2	;Default for DSKINT/QUERY=ON		;042
	BIC	#C2$QER,C$FLG2	;Default off for "N/ALL" flag		;051
	$ENDDO			;Finished with code			;042
	DFLTKA	$END.Q,$DIS.A	;  DISMOUNT for disks			;007

	$FETP	IN.T		;Get the input spec			;048
	$DO			;Some code				;048
	CALL	CHKDSK		;Be sure that it is disk		;048
	CALL	CHKIMG		;/IMAGE can't have ppn/filespec parms	;032
	$ENDDO			;					;048

	$FETP 	OUT.T		;Get the output spec			;018
	$DO			;Some code				;048
	CALL	CHKDSK		;Be sure that it is disk		;048
	CALL	CHKIMG		;/IMAGE can't have ppn/filespec parms	;032
	$ENDDO			;					;048

	$ENDTHR			;Exit from threads			;048

GLOBAL	<$IMA.K>							;046

.SBTTL	CUI dialogue threads - /COPY command definitions		;046

$C.CMD:	$THR								;046

	$DEFCMD	,QUAL=$COP.Q, U.CMDC=$COP.K ; /COPY Command definition	;046

	    $PARM IN.T , TYPE=LF..W, OCCURS=200, PROMPT=$IN.P		;046
						;Input Device 		;046
	    $PARM OUT.T,TYPE=LF..W, PROMPT=$OUT.P			;046
						; Output parameter	;046
	$ENDCMD								;046

	$DO								;046
	BIS	#DO.IMA,C$FLAG	; Indicate /IMAGE mode			;046
	BIS	#IM$COP,IMGSUB	; Indicate /COPY submode		;046
	$ENDDO								;046

	DFLTCQ	$END.Q		;Default to /END			;004
	DFLTCQ	$FIL.Q		;Default to /FILES
	DFLTCQ	$ACC.Q		;And /ACCOUNTING
	DFLTCQ	$LIS.Q		;Default to /LIST
	DFLTCQ	$OPT.Q		;Default to /OPTIMIZE
	DFLTCQ	$PLA.Q		;Default to /PLACED_POSITION
	DFLTKA	$PLA.Q,$IND.A	;Default for /PLACED_POSITION is INDEX
	$DO			;Do some code				;042
	BIS	#C2$QRY,C$FLG2	;Default for DSKINT/QUERY=ON		;042
	BIC	#C2$QER,C$FLG2	;Default off for "N/ALL" flag		;051
	$ENDDO			;Finished with code			;042
	DFLTKA	$END.Q,$DIS.A	;  DISMOUNT for disks			;007

	$FETP	IN.T		;Get the input spec			;048
	$DO			;Some code				;048
	CALL	CHKDSK		;Be sure that it is disk		;048
	$ENDDO			;					;048

	$FETP 	OUT.T		;Get the output spec			;018
	$DO			;Some code				;048
	CALL	CHKDSK		;Be sure that it is disk		;048
	$ENDDO			;					;048

	$ENDTHR			;Exit from threads			;048

GLOBAL	<$COP.K>							;046


BR.CMD:	$DO			;Leave threaded code			;018
	CALBX	U$FSS <U.CMN+U.LEN,#U.CMN+U.STR> ;Extract device    	;018
	CLR	R0		;Presume it is a disk			;007
	TSTB	XRB+XRMOD	;See if it really is			;007
	BEQ	1$		;Yes it was, back to threaded code	;007
	DEC	R0		;No, so set to FAILURE			;007
1$:	$ENDDO			;Back to threaded code			;007
	$IF	SUCCESS		;Default for /END 			;007
	DFLTKA	$END.Q,$DIS.A	;  DISMOUNT for disks			;007
	$ELSE								;007
	DFLTKA	$END.Q,$RWD.A,NO ;  and NOREWIND for tapes		;007
	    $DO			;Check for streaming device		;019
	    MOV	TBKSIZ,BLKSIZ	;Default tape blocksize			;041
	    CLR	R0		;Assume streaming device		;019
	    CMP	FIRQB+FQDEV,#"MS;MS device?				;019
	    BEQ	10$		;Yes, R0 is still zero, exit	        ;019
	    CMP FIRQB+FQDEV,#"MU;MU device?				;019
	    BEQ	10$		;Yes, R0 is still zero, exit		;019
	    DEC	R0		;Indicate streaming device not found    ;019
10$:	    $ENDDO							;019
	    $IF	SUCCESS		; We found MU or MS			;019
	        $FETCQ	$BUF.Q	; Was /BUFF specified?			;020
	        $IF	ABSENT						;020
		   $DO							;065
		    MOV #PRTUNE,R2 ; R2 -> Tune privilege		;065
		    CALB CHKPRV,R2 ; Do we have TUNE privilege?		;065
		    NEG R0	; R0=0 for yes, -1 for no		;065
		   $ENDDO						;065
		   $IF SUCCESS	; If we have TUNE, 			;065
		    DFLTCQ $BUF.Q ; Default for these drives		;019
	            DFLTKA $BUF.Q,$OPT.A ; Optimize the buffersize	;019
		    $DO							;019
		     CALL CK.BUF ; Reset the buffersize if needed	;019
		    $ENDDO						;019
		   $ENDIF	;TUNE check				;065
		$ENDIF		;/BUFF check				;020
	    $ENDIF		;MU/MS check				;019
	$ENDIF			;Tape check				;007

	$RETURN								;048


.SBTTL	BACPAR - Parse the BACKUP command parameters
.DSABL	LSB								;046
;+
;
;	CALL	BACPAR
;
;-

BACPAR:
	CALBX	FET.P <#IN.T>	;Get the first Backup Filespec		;017
	MOV	U.CMN+U.POS,DEVPOS ;Save pointer to command line
	MOV	#$SELEC,R5	;R5 -> Select list
	CALLX	CLRFQB		;Clear out the FIRQB
	MOV	#FIRQB+FQPPN,R0	;R0 -> FIRQB @ FQPPN
	MOV	$MYPPN,(R0)+	;Default to current PPN
	MOV	#134745,(R0)	;Set up ???
	MOV	(R0)+,(R0)	;Now set up ??????
	MOV	(R0)+,(R0)	;Now finally ??????.???
	MOV	#"SY,@#FIRQB+FQDEV ;Set up device name as SY:
	CALL	SCANMF		;Scan the file name
	MOV	@#FIRQB+FQDEV,$DSKDEV ;Save the device name
	MOV	@#FIRQB+FQDEVN,$DSKUNT ;And unit number			;014
	CALL	STFQDM		;Store the name in dynamic memory

10$:	CALBX	FET.NP 		;Try to get another entry
	TST	U.CMN+U.PRES	;Was it there?
	BEQ	100$		;Nope, all done, we're done now
	CALL	CHKENT		;Now check out the entry
	BR	10$		;And try again

100$:	CALBX	FET.P <#OUT.T>	;Go get the output spec
	CALL	CLRFQB		;Clear out the FIRQB
	MOV	#FIRQB+FQPPN,R0	;R0 -> FIRQB @ FQPPN
	MOV	$MYPPN,(R0)+	;Default PPN is our own
	MOV	#^RBAC,(R0)+	;Set up BAC
	MOV	#^RKUP,(R0)+	;Now KUP
	MOV	#^RBCK,(R0)+	;.BCK
	MOV	#"SY,@#FIRQB+FQDEV ;Set up device name as SY:
	CALL	SCANMF		;Scan the file name
	MOV	#$SAVNAM,R0	;R0 -> Save set storage area
	CALL	STRFQB		;Now save this
	MOV	@#FIRQB+FQDEV,$SAVDEV ;Save the save set device
	MOV	@#FIRQB+FQDEVN,$SAVUNT ;And unit number/flags
	MOV	@#XRB+XRMOD,$SAVFLG ;And the device flags
	TST	(R0)+		;Advance to name of save set
	MOV	#BBHDAT+BBH$SN+1,R1 ;R1 -> Start of save set name
	MOVB	#10.,R2		;Number of bytes in a file name		;015
110$:	MOVB	(R0)+,R3	;Pick up a character
	CMPB	R3,#40		;Is it a space?
	BEQ	120$		;Yes, so nothing to do
	MOVB	R3,(R1)+	;Not a space, save it in the block header
120$:	SOB	R2,110$		;Now loop for the whole thing
	SUB	#BBHDAT+BBH$SN+1,R1 ;R1 = Length of save set name
	MOVB	R1,BBHDAT+BBH$SN ;Now save the name as a .ASCIC string
	RETURN			;Now we're done

GLOBAL	<$MYPPN,$DSKDEV,$DSKUNT,$SAVDEV,$SAVUNT,$SAVNAM,$SAVFLG,$SELEC,BBHDAT>

.SBTTL	COPPAR - Parse the /COPY output parameter			;029

;+									;029+
;
;	CALL	COPPAR
;
;-									;029-

COPPAR:	NOP			;Debug					;029
	CALBX	FET.P <#OUT.T>	;Pick up the output specification	;029
	CALL	CLRFQB		;Clear out the FIRQB			;029
	MOV	#FIRQB+FQPPN,R0	;R0 -> FIRQB @ FQPPN			;029
	MOV	#-1,(R0)+	;Default PPN is wild			;029
	MOV	#134745,(R0)	;Set up RAD-50 ???			;029
	MOV	(R0)+,(R0)	;In file name				;029
	MOV	(R0)+,(R0)	;And file type				;029
	CALL	SCANMF		;Now scan the specification		;029
	MOV	#$RESMSK,R0	;R0 -> Storage area			;029
	CALLR	STRFQB		;Now store this in the FIRQB		;029
	RETURN			;					;029

GLOBAL	<$RESMSK>							;029


.SBTTL	RESPAR - Parse the RESTOR command parameters

;+
;
;	CALL	RESPAR
;
;-

RESPAR:	NOP
	CALBX	FET.P <#IN.T>	;Set the input parameter
				;Skip the check, it is required
	CALL	CLRFQB		;Clear out the FIRQB
	MOV	#FIRQB+FQPPN,R0	;R0 -> FIRQB @ FQPPN
	MOV	$MYPPN,(R0)+	;Default PPN is our own
	MOV	#^RBAC,(R0)+	;Set up BAC
	MOV	#^RKUP,(R0)+	;Now KUP
	MOV	#^RBCK,(R0)+	;.BCK
	MOV	#"SY,@#FIRQB+FQDEV ;Set up device name as SY:
	CALL	SCANMF		;Scan the file name
	MOV	#$SAVNAM,R0	;R0 -> Save set storage area
	CALL	STRFQB		;Now save this
	MOV	@#FIRQB+FQDEV,$SAVDEV ;Save the save set device
	MOV	@#FIRQB+FQDEVN,$SAVUNT ;And unit number/flags
	MOV	@#XRB+XRMOD,$SAVFLG ;And the device specific flags
	CMP	U.CMN+U.CMDC,#$DIRR.K ;Is this a /DIR?			;046
	BEQ	130$		;Yes, don't get another parameter	;046
	CALBX	FET.P <#OUT.T>	;Pick up the output specification
				;Skip the check, it is required
	CALL	CLRFQB		;Clear out the FIRQB
	MOV	#FIRQB+FQPPN,R0	;R0 -> FIRQB @ FQPPN
	MOV	$MYPPN,(R0)+	;Default PPN is our own
	MOV	#134745,(R0)	;Set up RAD-50 ???
	MOV	(R0)+,(R0)	;In file name
	MOV	(R0)+,(R0)	;And file type
	CALL	SCANMF		;Now scan the specification
	MOV	@#FIRQB+FQDEV,$DSKDEV ;Yes, so save the device name
	MOV	@#FIRQB+FQDEVN,$DSKUNT ;And unit number
	MOV	#$RESMSK,R0	;R0 -> Storage area
	CALLR	STRFQB		;Now store this in the FIRQB
130$:	RETURN

GLOBAL	<$MYPPN,$DSKDEV,$DSKUNT,$RESMSK,$SAVNAM,$SAVDEV,$SAVUNT,$SAVFLG>

.SBTTL	G.QUAL - Parse all the qualifiers

;+
;	G.QUAL
;	Go check all possible qualifiers and
;	set/clear the needed flags and areas.
;
;-

G.QUAL:	PUSH	<R2>		; Get a work register			
	MOV	#SWTBL,R2	; Get the table's beginning address	
10$:	CALBX	FET.CQ <(R2)+>	; See if the qualifier is there
	TST	U.CMN+U.PRES	; Was it there??
	BEQ	50$		; No, so nothing to do

20$:	TST	U.CMN+U.NO	; Was it a "/NO..."?
	BNE	40$		; Yes, it was no, so don't set the bit
	BIS	(R2),C$FLAG	;  Nope, they want this one, set the bit

40$:	MOV	R2,-(SP)	; Save pointer into command table
	CALL	@2(R2)		; Now off to the service routine
	MOV	(SP)+,R2	; And get our pointer back

50$:	CMP	(R2)+,(R2)+	; Advance to next table entry
	TST	(R2)		; Anything to do?
	BNE	10$		; Yes, go for it

60$:	POP	<R2>		; Get the scratch reg back
RTSPC:	RETURN			; And we're done

.SBTTL	CK.BLK - "/BLOCK_SIZE=" parsing

;+
;
;	CALL	CK.BLK
;		(Check for /BLOCK_SIZE)
;
;-

CK.BLK:	MOV	#777,R2		;Guess that this is a disk backup
	MOV	#BLKIMA-2,R3	;Guess at image mode			;026
	BIT	#DO.IMA,C$FLAG	;/IMAGE or /COPY?			;046
	BNE	10$		;Yes, we guessed correctly		;046
	MOV	#BLKHGH-2,R3	;Get pointer to highest blocksize 	;024
	TSTB	$SAVFLG		;Is this a tape backup?
	.ASSUME	DSKHND	EQ	0
	BEQ	10$		;No, disk, we guessed correctly
	MOV	#17,R2		;Tape, set block size multiple - 1
	MOV	#BLKHTP-2,R3	;Get pointer to highest blocksize	;024
10$:	CALBX	FET.CQ <#$BLK.Q>;Get the /BLOCK information back	;026
	MOV	(R3)+,R4	;Get the number and fix the pointer	;024
	MOV	R4,BLKSIZ	;Assume /BLOCK=MAX			;011
	CALBX	FET.KA,#$MAX.A	;Good guess?				;011
	TST	U.CMN+U.PRES	;Well?					;011
	BNE	30$		;Yes, all set				;011
	CALBX	FET.KA,#$MIN.A	;No, is it /BLOCK=MIN ?			;011
	TST	U.CMN+U.PRES	;Well?					;011
	BEQ	13$		;No, check for number			;011
	MOV	#2048.,BLKSIZ	;Set minimum				;011
	BR	30$		;All done				;011

13$:	CALBX	FET.A		;Pick up the blocksize			;011
	MOV	U.CMN+U.LOW,BLKSIZ ;Stash the blocksize
	CMP	BLKSIZ,#2048.	;Is blocksize large enough?		;001
	BLO	15$		;No, forget it				;001
	CMP	BLKSIZ,R4	;Blocksize in range?			;001
	BLOS	17$		;Yes, that's fine
15$:	REPAINT	U.CMN+U.POS	;Go and draw an arrow
	CMESSAGE #U.OUTR,<#BLKLOW,R3> ;Report the out-of-range error	;001
	BR	20$		;And get out

17$:	BIT	R2,BLKSIZ	;Is this a valid blocksize?		;001
	BEQ	30$		;Yes, it sure is
	REPAINT U.CMN+U.POS	;No, so draw an arrow
	INC	R2		;Set up the blocksize multiplier
	CMESSAGE #BLKMUL,R2	;And report the error
20$:	JMP	ERRTRY		;And try again

30$:	RETURN			;And we're done

GLOBAL	<BLKSIZ,$SAVFLG,BLKMUL,U.OUTR>

.SBTTL	CK.BUF - "/BUFFER_SIZE=" parsing

;+
; CK.BUF - Check for /BUFFER_SIZE qualifier
;-

CK.BUF:	CALBX	FET.KA,<#$MAX.A> ;Check for /BUF=MAX?			;002
	TST	U.CMN+U.PRES	;Is it present?				;002
	BEQ	10$		;No, not this time			;002
	MOVB	#128.,RGNSIZ	;Yes, so set up a negative number	;002
	BR	20$		;And we're done				;002

10$:	CALBX	FET.KA,<#$OPT.A>;Check for /BUF=OPTIMUM			;019
	TST	U.CMN+U.PRES	;Is it present?				;019
	BEQ	15$		;No, not this time			;019
	MOVB	#85.,RGNSIZ	;Yes, so set the optimal size		;066
	BR	20$		;And we're done				;019

15$:	CALBX	FET.A		;Pick up the numeric argument		;002
	MOVB	U.CMN+U.LOW,RGNSIZ ;Stash the requested region size
20$:	RETURN			;And we're done				;002

GLOBAL	<RGNSIZ>

.SBTTL	CK.DEN - "/DENSITY=" Parsing

;+
;
;	CALL	CK.DEN:
;		Check for /DENSITY
;-

CK.DEN:	CALL	TAPQUL		;This is a tape-only qualifier
	MOV	#$DEN,R2	;Point to density cell			;006
	MOV	#100001,(R2)	;Guess at minimum density		;006
	CALBX	FET.KA,#$MIN.A	;Good guess?				;006
	TST	U.CMN+U.PRES	;Well?					;006
	BNE	10$		;Yes, all set				;006
	MOV	#-1,(R2)	;Try maximum this time			;006
	CALBX	FET.KA,#$MAX.A	;Ask CUI about it...			;006
	TST	U.CMN+U.PRES	;Is it present?				;006
	BNE	10$		;Yes, all set				;006
	CALBX	FET.A		;Must be a number by now, go get it	;006
	MOV	U.CMN+U.LOW,(R2) ;And stash it away			;006
10$:	RETURN			;And we're done				;006

GLOBAL	<$DEN>								;005

.SBTTL	CK.END - "/END=" Parsing

;+
;
;	CALL	CK.END
;		Check for /END=
;
;-

CK.END:	CALBX	FET.KA <#$RWD.A> ;Look for /END=REWIND
	TST	U.CMN+U.PRES	;Was it there?
	BEQ	10$		;No, not this time
	CALL	TAPQUL		;This is a tape-only qualifier
	TST	U.CMN+U.NO	;Was "/NO-" specified?
	BNE	10$		;Yes, check [NO]DISMOUNT		;008
	BIS	#C2$ERW,C$FLG2	;No, /END=REWIND, note that		;004
10$:	CALBX	FET.KA,#$DIS.A	;Look for /END=DISMOUNT
				;It must be here by now
	TST	U.CMN+U.NO	;Was it NODISMOUNT?
	BNE	20$		;Yes, nothing to do			;004
	BIS	#C2$EDM,C$FLG2	;No, dismount, set that bit		;004
20$:	RETURN			;And now we're done

GLOBAL	<C$FLG2>							;004

.SBTTL	CK.REW - "/REWIND" Parsing					;046+

;+
;
;	CALL	CK.REW
;		Check for /END=
;
;-

CK.REW:;CALL	TAPQUL		;This is a tape-only qualifier		;057
	RETURN			;And now we're done			;046-

.SBTTL	Parse the /EXCLUDE switch
.SBTTL	Parse the /INCLUDE switch
.SBTTL	Parse the /SELECT switch

;+
; CK.EXC - Parse the /EXCLUDE switch
; CK.INC - Parse the /INCLUDE switch
; CK.SEL - Parse the /SELECT switch
;-

.ENABL	LSB

CK.SEL:	MOV	#$SELEC,R5	;R5 -> Select list list header
	BR	10$		;Now join up

CK.INC:	MOV	#$INCLU,R5	;R5 -> Include list list header
	BR	10$		;Now join up

CK.EXC:	MOV	#$EXCLU,R5	;R5 -> Exclude list list header	
10$:	CALBX	FET.A		;Get an Argument from the list
	TST	U.CMN+U.PRES	;Did we get one???
	BEQ	100$		;No, we're done
	CALL	CHKENT		;Check out the entry	
	BR	10$		;Now loop

100$:	RETURN			;All done for now

.DSABL	LSB

GLOBAL	<$SELEC,$INCLU,$EXCLU>

.SBTTL	Make sure a /IMAGE entry has no ppn/filespec			;032+
;+
; CHKIMG - Make sure a /IMAGE entry has no ppn/filespec
;
; CUI common contains entry
;
;	CALL	CHKIMG
;
;	All registers are preserved
;
; This routine checks an entry (/IMAGE only) and gives an error if the
; user has included a PPN or filespec in the entry unless it is also a
; /COPY.
;-

CHKIMG:	BIT	#IM$COP,IMGSUB	;/COPY?
	BNE	20$		;Yes, PPN/filespec OK
	BIT	#DO.IMA,C$FLAG	;/IMAGE?
	BEQ	20$		;No, PPN/filespec OK
	CALL	SCANMF		;Scan the entry
	BIT	#F2NAM,@#XRB+XRBLK ;Is there a filename?
	BNE	10$		;Yes, thatsa nogood
	BIT	#F2PPN,@#XRB+XRBLK ;Is there a PPN?
	BEQ	20$		;No, thatsa good
10$:	REPAINT U.CMN+U.POS	; Show the bad parameter
	CMESSAGE #PFNALL	;Tell 'em where they went wrong
	JMP	ERRTRY		;And give 'em another chance

20$:	RETURN

GLOBAL	<IMGSUB,PFNALL>							;032-

.SBTTL	Check out an entry for a list

;+
; CHKENT - Check out an entry for a list
;
; CUI common contains entry
; Default for file specification is [Current PPN]*.*
;
;	R5 -> Previous entry in list
;
;	CALL	CHKENT
;
;	R0 = Undefined
;	R5 -> Next entry in list
;
; This subroutine checks out an entry to be sure that it is consistent
; with the operation being performed, and if it is, it stores the entry
; in dynamic memory.
;-

CHKENT:	CALL	CLRFQB		;Clear out the FIRQB
	MOV	#FIRQB+FQPPN,R0	;R0 -> FIRQB @ FQPPN
	MOV	$MYPPN,(R0)+	;Default to caller's PPN
	MOV	#134745,(R0)	;Set up RAD-50 ???
	MOV	(R0)+,(R0)	;In both parts of file name
	MOV	(R0)+,(R0)	;And now in file type
	CALL	SCANMF		;Scan the file name in CUI common
	BIT	#F2DEV1,@#XRB+XRBLK ;Did they specify a device name?
	BEQ	40$		;No, so no checking to do
	BIT	#DO.RES,C$FLAG	;Is this a restore?
	BEQ	20$		;No, BACKUP, check out device name
	REPAINT	U.CMN+U.POS	;Restore, repaint the command line
	CMESSAGE #DEVNOV	;And tell them the error message
	JMP	ERRTRY		;Now try again

20$:	CMP	$DSKDEV,@#FIRQB+FQDEV ;Does device name match?
	BNE	30$		;No, so this is an error
	CMPB	$DSKUNT,@#FIRQB+FQDEVN ;Do they really match?		;003
	BEQ	40$		;Yes, so this is OK
30$:	REPAINT	DEVPOS,U.CMN+U.POS ;Show the conflicting devices
	CMESSAGE #SAMSRC	;Tell them they have to be the same
	JMP	ERRTRY		;And we're done

40$:	CALLR	STFQDM		;Exit storing this entry in dynamic memory

GLOBAL	<$MYPPN,DEVNOV,$DSKDEV,$DSKUNT,SAMSRC>

.SBTTL	CK.GRP - "/[NO]GROUPSIZE=" Parsing

;+
;
;	CALL	CK.GRP
;		Check for /GROUPSIZE=
;
;-

CK.GRP:	TST	U.CMN+U.NO	; Did they specify "NO"GROUPSIZE
	BEQ	20$		; Nope, better set what they want...
	CLR	$GRPSZ		; ..they did, well that means size=0
	BR	30$		;    all done!

20$:	CALBX	FET.A		; Get the group size specified
	TST	U.CMN+U.PRES	; Did we get one?			;063
	BEQ	30$		; No, so don't change the size		;063
	MOV	U.CMN+U.LOW,$GRPSZ ; Now set the groupsize
30$:	RETURN			; And now we're done

GLOBAL	<$GRPSZ>

.SBTTL	CK.HEA - "/[NO]HEADER" Parsing

;+
;
;	CALL	CK.HEA
;		Check for /[NO]HEADER
;
;-

.ENABL	LSB

CK.HEA:	TST	U.CMN+U.NO	; Did they specify "NO" HEADER
	BEQ	10$		; No
	BIS	#C2$HEA,C$FLG2	; Yes, say not to record header info
10$:	RETURN			; And now we're done

.DSABL	LSB

.SBTTL	CK.INI - "/INITIALIZE" parsing					;027

;+									;027
; CK.INI - Check for /INITIALIZE qualifier				;027
;-									;027

CK.INI:	TST	U.CMN+U.NO	;Was it /NOINITIALIZE?			;027
	BNE	50$		;Yes, nothing to do			;027
	CLR	INICLU		;Use device clustersize as default	;060
	CALBX	FET.KA,<#$CLU.A> ;Check for /INIT=CLUSTER_SIZE=n	;027
	TST	U.CMN+U.PRES	;Is it present?				;027
	BEQ	20$		;No					;027
	CALL	DSKQUL		;Check for disk				;053
	CALBX	FET.A		;Yes, get the argument			;027
	MOV	U.CMN+U.LOW,R2	; and pick it up			;027
	MOV	R2,R0		;Copy it				;027
	MOV	R2,R1		; and again				;027
	DEC	R1		;Make a mask				;027
	BIC	R1,R0		;Compute n .AND (-n)			;027
	CMP	R0,R2		;Is that equal n?			;027
	BEQ	10$		;Yes, so it's a power of 2		;027
	REPAINT	U.CMN+U.POS	;Go and draw an arrow			;027
	CMESSAGE #ICLUER	;Report a bad clustersize		;027
	JMP	ERRTRY		; and go to error handler		;027

10$:	MOV	R2,INICLU	;Save clustersize			;027
20$:	CALBX	FET.KA,<#$ERA.A> ;Check for /INIT=[NO]ERASE		;027
	TST	U.CMN+U.PRES	;Is it present?				;027
	BEQ	30$		;No					;027
	CALL	DSKQUL		;Check for disk				;053
	BIC	#C2$NER,C$FLG2	;Clear explicit NOERASE			;027
	BIS	#C2$ERA,C$FLG2	; and set explicit ERASE		;027
	TST	U.CMN+U.NO	;Was it in fact NOERASE?		;027
	BEQ	30$		;No, ERASE, all set			;027
	ADD	#C2$NER-C2$ERA,C$FLG2 ;Yes, flag NOERASE		;027
30$:	CALBX	FET.KA,<#$EXE.A> ;Check for /INIT=[NO]EXERCISE=n	;027
	TST	U.CMN+U.PRES	;Is it present?				;027
	BEQ	40$		;No, all done				;027
	CALL	DSKQUL		;Check for disk				;053
	BIS	#C2$EXE,C$FLG2	;Yes, indicate [NO]EXERCISE present	;027
	CLRB	EXERCT		; and assume NOEXERCISE			;027
	TST	U.CMN+U.NO	;Correct?				;027
	BNE	40$		;Yes					;027
	MOVB	#3,EXERCT	;No, set default exercise count		;027
	CALBX	FET.A		;Get the argument			;027
	TST	U.CMN+U.PRES	;Is there one?				;027
	BEQ	40$		;No, use the default just set		;027
	MOVB	U.CMN+U.LOW,EXERCT ;Yes, save it			;027
40$:	BIS	#C2$QRY,C$FLG2	;Default to =QUERY			;042
	CALBX	FET.KA,<#$QUE.A> ; Check for /INIT=[NO]QUERY		;042
	TST	U.CMN+U.PRES	;Is it present?				;042
	BEQ	50$		;No, done				;042
	CALL	DSKQUL		;Check for disk				;053
	TST	U.CMN+U.NO	;Is it NOQUERY?				;042
	BEQ	50$		;No, leave				;042
	BIC	#C2$QRY,C$FLG2	;Assume =QUERY				;042
50$:	RETURN								;027

GLOBAL	<C$FLG2,EXERCT,INICLU,ICLUER>					;027

;+
; CK.ILB - Check for /INLABEL
; CK.OLB - Check for /OUTLABEL
;-

.ENABL	LSB

CK.OLB:	MOV	#$SAVLB,R3	;Set up storage area for BACKUP
	MOV	#$DSKLB,R5	;And storage area for RESTORE
	BR	10$		;Now join up

CK.ILB:	MOV	#$DSKLB,R3	;Set up storage area for BACKUP
	MOV	#$SAVLB,R5	;And stoage area for RESTORE
10$:	CALBX	FET.A		;Pick up the parameter
				;Skip test, the label must be there
	MOV	U.CMN+U.LEN,R2	;Get the length of the label
	MOV	#6,R4		;R4 = Maximum length of label
	CMP	R2,R4		;Is label too long?
	BLOS	15$		;It's short enough, that's OK
	MOV	R4,R2		;Label is too long, use only legal part
15$:	MOV	#U.CMN+U.STR,R0	;Get the -> user requested label
	BIT	#DO.RES,C$FLAG	;Are we doing a Restore?
	BEQ	20$		;Nope, all set up
	MOV	R5,R3		;Yes, so set up the proper storage area

20$:	MOVB	(R0)+,(R3)	;Move the requested label to storage area ;012
	CMPB	(R3),#'A+40	;Lower case alphabetic?			;012
	BLO	27$		;No					;012
	CMPB	(R3),#'Z+40	;Maybe...				;012
	BLOS	25$		;Yes					;012
	CMPB	(R3),#340	;No, lower case multi-national?		;012
	BLO	27$		;No					;012
	CMPB	(R3),#375	;Maybe...				;012
	BHI	27$		;No					;012
25$:	BICB	#40,(R3)	;Yes, store as upper case		;012
27$:	TSTB	(R3)+		;Increment				;012
	DEC	R4		;Indicate we have one less pad character to do
	SOB	R2,20$		;Now loop for their entire label name
30$:	TST	R4		;Do we need to do space-filling?
	BEQ	50$		;No, we're done now
40$:	MOVB	#40,(R3)+	;Yes, so fill in a space
	SOB	R4,40$		;And loop for the whole thing
50$:	RETURN			;All done for now

.DSABL	LSB

GLOBAL	<$DSKLB,$SAVLB>

.SBTTL	CK.OPT - "/[NO]OPTIMIZE"

;+
; CK.OPT - Check for /[NO]OPTIMIZE
;-

CK.OPT:	TST	U.CMN+U.NO	;Was it "/NOOPTIMIZE"?
	BNE	30$		;Yes, so nothing to do			;004
	CALBX	FET.KA,#$CLU.A	;Check for clustersize parameter
	TST	U.CMN+U.PRES	;Was "clustersize" present?		;004
	BEQ	10$		;No, nothing to do			;004
	BIS	#C2$CLU,C$FLG2	;Set up to do clustersize optimization
10$:	CALBX	FET.KA,#$DIR.A	;Check for "directory"			;004
	TST	U.CMN+U.PRES	;Was it there?				;004
	BEQ	20$		;No, nothing to do			;004
	BIS	#C2$DIR,C$FLG2	;Set up for directory optimization	;004
20$:	BIT	#C2$CLU!C2$DIR,C$FLG2 ;Was it just /OPTIMIZE?		;004
	BNE	30$		;No, all set				;004
	BIS	#C2$CLU!C2$DIR,C$FLG2 ;Yes, so set up the default	;004
30$:	RETURN			;All done now				;004

GLOBAL	<C$FLG2>

.SBTTL	CK.PLA - "/PLACED_POSITION=" parsing

;+
; CK.PLA - Check for /PLACED
;-

CK.PLA:	MOV	#PLADCN,R1	;Point to cell to store the DCN		;004
	CLR	(R1)		;Guess at ORIGINAL			;004
	CALBX	FET.KA,#$ORI.A	;Was it?				;004
	TST	U.CMN+U.PRES	;Well?					;004
	BNE	10$		;Yes, all done				;004
	DEC	(R1)		;Guess at middle			;004
	CALBX	FET.KA,#$MID.A	;Was it?				;004
	TST	U.CMN+U.PRES	;Well?					;004
	BNE	10$		;Yes, all done				;004
	DEC	(R1)		;No, must be INDEX by now		;004
10$:	RETURN			;All done now				;004

GLOBAL	<PLADCN>							;004

.SBTTL	CK.PRO - "/[NO]PROMPT" parsing

;+
; CK.PRO - Check for /[NO]PROMPT"
;-

CK.PRO:	TST	U.CMN+U.NO	;Was it [NO]prompt?
	BEQ	10$		;No, not this time, all set up
	BIS	#C2$PRO,C$FLG2	;Indicate that we don't want a proceed prompt
10$:	RETURN			;And we're done

GLOBAL	<C$FLG2>

.SBTTL	ST.AST - "/ASSIST" QUALIFIER					;031+

;+
;
;	CALL	ST.AST:
;		Check for /ASSIST
;
;-

ST.AST:	BIS	#C2$AST,C$FLG2	; Guess at /ASSIST mode			;045
	TST	U.CMN+U.NO	; /NOASSIST?				;045
	BEQ	10$		; No					;045
	BIC	#C2$AST,C$FLG2	; Yes, reset /ASSIST mode		;045
10$:	RETURN

GLOBAL	<C$FLG2>							;031-

.SBTTL	ST.TEL - "/[NO]TELL" qualifier					;010

;+
; ST.TEL - Set /INSTALL bit for /[NO]TELL qualifier			;010
;-

ST.TEL:	BIS	#DO.INS,C$FLAG	;Doing an installation 			;010
	RETURN			;Now we're done, [NO] just doesn't matter ;010

GLOBAL	<C$FLAG>							;010

.SBTTL	ST.VOL - "/VOLUME=" qualifier

.SBTTL	CK.VER - "/VERIFY=" Parsing					;030+

;+
;	CALL	CK.VER
;		Check for /VERIFY=ONLY
;-

CK.VER:	TST	U.CMN+U.NO	;NOVERIFY?
	BNE	10$		;Yes, get out
	CALBX	FET.KA <#$ONL.A> ;Look for /VERIFY=ONLY
	TST	U.CMN+U.PRES	;Was it there?
	BEQ	10$		;No, not this time

	BIS	#C2$ONL,C$FLG2	;Yes, set a flag
10$:	RETURN			;And now we're done

GLOBAL	<C$FLG2>							;030-

;+
; ST.VOL - Set volume bias supplied by /VOLUME qualifier
;-

ST.VOL:	TST	U.CMN+U.NO	;Did they specify "NO"VOLUME		;010
	BEQ	10$		;No, set bias				;010
	BIS	#NO.VOL,C$FLAG	;Set no volume flag			;010
	BR	20$		;Done					;010

10$:	CALBX	FET.A		;Go get the bias			;010
				;Skip check, argument is required	;010
	MOV	U.CMN+U.LOW,$BIAS ;Set it				;010
	DEC	$BIAS		;We start counting at 1 (not 0)		;010
20$:	RETURN			;Now we're done				;010

GLOBAL	<C$FLAG,$BIAS>							;010


.SBTTL	CK.LIS - "/[NO]LIST_FILE=" Parsing

;+
;
;	CALL	CK.LIS
;		Check for /LIST_FILE=
;
; Note: This routine should be executed after any qualifiers that
; might flag errors, to prevent the chance of opening a log file
; unnecessarily.
;-


CK.LIS:	NOP
	TST	U.CMN+U.NO	;Was it a "/NOLIST_FILE" ????
	BNE	30$		;It was "/NOLIST_FILE", nothing to do.
	CALBX	FET.A		;Go get the logfile specification
	CALLX	CLRFQB		;Clear out the FIRQB
5$:	TST	U.CMN+U.PRES	;Was an argument present?		;004
	BNE	10$		;Yes, sure was
	MOV	#"KB,@#FIRQB+FQDEV ;Set device name to KB:
	BR	20$		;And join up

10$:	MOV	#^RLST,@#FIRQB+FQEXT ;Default is .LST
	CALL	SCANMF		;Now scan the file name
20$:	MOVB	#CREFQ,@#FIRQB+FQFUN ;Set up to do the "OPEN FOR OUTPUT"
	MOVB	#LISFIL,@#FIRQB+FQFIL ;And set up the channel number
	CALFIP			;Now open the file
	CALLX	BUFWAT,R5	;Check for small buffers		;004
	 BR	5$		;None, try again			;004
	MOVB	@#FIRQB,R1	;Open go OK?
	BNE	110$		;Nope, go die...
	MOV	@#FIRQB+FQFLAG,$LISFL ;Save the flag word for later
	MOV	@#FIRQB+FQBUFL,R1 ;Pick up recommended buffer size
	MOV	R1,$LISSZ	;And stash it away
	CALLX	GETMEM		;Get memory for the log file buffer
	MOV	R0,$LISBF	;Save the buffer pointer
	MOV	R0,$LISPT	;And set the initial fill pointer

30$:	RETURN

110$:	REPAINT	U.CMN+U.POS	;Go and repaint the command line
	CMESSAGE R1		;Report the error code
	JMP	ERRTRY		;Now try again

GLOBAL	<$LISFL,$LISSZ,$LISBF,$LISPT>

.SBTTL	Parse the /[NO]CRC qualifier

;+
; CK.CRC - Check for /[NO]CRC
;-

CK.CRC:	TST	U.CMN+U.NO	;Was it /NOCRC?				;009
	BEQ	10$		;No, it was /CRC, nothing to do		;009
	BIS	#BH$NOC,BBHDAT+BBH$FL ;NOCRC, set the bit		;009
10$:	RETURN			;Now get out				;009

GLOBAL	<BBHDAT>

.SBTTL	Parse the /CREATED and /MODIFIED qualifiers

;+
; CK.CRE - Check for /CREATED
; CK.MOD - Check for /MODIFIED
;-

.ENABL	LSB

CK.CRE:	MOV	#D$ECDA-D$EMDA,R3 ;Get offset for creation cells
	BR	5$		;And join up

CK.MOD:	CLR	R3		; Indicate to use the "modified" cells
5$:	MOV	#-1,R2		; Initially we don't have an argument keyword
10$:	CALBX	FET.KA <#$AFT.A>; Ask CUI for a "/CREATE" ...
	TST	U.CMN+U.PRES	;...now was it there?
	BEQ	20$		; Nope....
	MOV	U.CMN+U.POS,R2	; Save the position of this argument
	CALBX	FET.A		;  Get the "/CREATE=AFTER=" date & time
	MOV	U.CMN+U.DATE,$DATTB+D$EMDA(R3) ;Save the date
	MOV	U.CMN+U.TIME,$DATTB+D$EMTI(R3) ;and the time
	BNE	20$		; They gave us one, good
	MOV	#-1,$DATTB+D$EMTI(R3) ;Set a very early default time

20$:	CALBX	FET.KA <#$BEF.A>; Hey CUI,....
	TST	U.CMN+U.PRES	;   ...was it "/CREATED=BEFORE" ??
	BEQ	40$		;  Nope...
	CMP	U.CMN+U.POS,R2	; Is this qualifier earlier on the line?
	BHI	30$		; No, so we have a good arrow pointer
	MOV	U.CMN+U.POS,R2	; Save the pointer to the error position
30$:	CALBX	FET.A		;  Get the "/CREATE=BEFORE=" date & time
	MOV	U.CMN+U.DATE,$DATTB+D$LMDA(R3) ; It was, so save the date and
	MOV	U.CMN+U.TIME,$DATTB+D$LMTI(R3) ; and time
	BNE	40$		; They specified a time, don't change it;062
	DEC	$DATTB+D$LMTI(R3) ; Change default to "earliest time"	;062

40$:	CALBX	FET.A		; Now check for an explict time
	TST	U.CMN+U.PRES	; Did he say "/CREATED=<date>"?
	BEQ	100$		; Nope...
	TST	R2		; Did we find a range specification?
	BMI	50$		; No, not this time
	REPAINT	R2,U.CMN+U.POS	; Yes, so repaint the line with arrows
	CMESSAGE #CONARG	; Tell them conflicting arguments
	JMP	ERRTRY		; And try again

50$:	MOV	U.CMN+U.DATE,$DATTB+D$EMDA(R3) ;  He is, so set the earliest
	MOV	U.CMN+U.DATE,$DATTB+D$LMDA(R3) ;  and latest dates
	MOV	U.CMN+U.TIME,$DATTB+D$EMTI(R3) ; Now set the time
	MOV	U.CMN+U.TIME,$DATTB+D$LMTI(R3) ; Store the latest time too
	BNE	60$		; One was specified
	MOV	#-1,$DATTB+D$EMTI(R3) ;  otherwise give them the earlist

60$:	MOV	U.CMN+U.POS,R2	;Save the position of this argument
	CALBX	FET.A		;See if there is another one
	TST	U.CMN+U.PRES	;Is there?
	BEQ	100$		;No, so this is OK
	REPAINT	R2,U.CMN+U.POS	;Too many arguments, repaint the line
	CMESSAGE #U.TOOA	;And report the error
	JMP	ERRTRY		;Now try again

100$:	RETURN

.DSABL	LSB

GLOBAL	<$DATTB,CONARG,U.TOOA>

.SBTTL	CK.OCC - "/OCCURRENCE" Parsing

.ENABL	LSB

;+
;
;	CALL	CK.OCC
;		Check for /OCCURRENCE=
;-

CK.OCC:	CALL	TAPQUL		; This is a tape-only qualifier
	CALBX	FET.A		; "/OCCURRENCE=..."What????
				; Skip the check, it is required..
	MOV	U.CMN+U.LOW,$OCCUR ;Save the occurance number
	RETURN

.DSABL	LSB

GLOBAL	<$OCCUR>


.SBTTL	CK.REP - "/[NO]REPLACE" Parsing

;+
;
;	CALL	CK.REP
;		Check for /REPLACE
;-

CK.REP:
; Remove the =ASSIST code for V10.0					;047
;	CALBX	FET.KA,#$ASS.A	;Check for /REPLACE=ASSIST		;038
;	TST	U.CMN+U.PRES	;Was it there?				;038
;	BEQ	5$		;No, check for /query			;038
;	BIS	#GF.QOP,GENFLG	;=ASSIST				;038
;	BR	10$		;And check no further			;038
;5$:
	CALBX	FET.KA,#$QUE.A	;Check for /REPLACE=QUERY		;004
	TST	U.CMN+U.PRES	;Was it there?				;004
	BNE	10$		;Yes, so nothing to do			;038
	BIS	#REP.S,C$FLAG	;No, indicate to look at DO.REP		;038
10$:	RETURN			;And we're done				;004

.SBTTL	CK.QRY - "/[NO]QUERY" Parsing					;044+

;+
;
;	CALL	CK.QRY
;		Check for /QUERY
;-

CK.QRY:
; Remove the =ASSIST code for V10.0					;047
;	CALBX	FET.KA,#$ASS.A	;Check for /REPLACE=ASSIST
;	TST	U.CMN+U.PRES	;Was it there?
;	BEQ	10$		;No, that's all folks
;	BIS	#GF.QOQ,GENFLG	;=ASSIST
;10$:
	BIC	#C2$QER,C$FLG2	;Default off for "N/ALL" flag		;051
	RETURN			;And we're done				;044-

.SBTTL	Scan CUI common for a file name

;+
; SCANMF - Scan CUI common for a file name, defaults in FIRQB
;
; CUI common contains a file name to scan
;
;	CALL	SCANMF
;
; FIRQB is set up with file name
;
; All registers are preserved
;
; If there is an error, it is reported to the caller, and the
; user is prompted for a new command line.
;-

SCANMF:	CALLX	CLRXRB		;Clear out the XRB
	MOV	R0,-(SP)	;Get a work register
	MOV	R1,-(SP)	;And another one
	MOV	#XRB,R0		;R0 -> XRB
	MOV	U.CMN+U.LEN,(R0) ;Set the length of the string to scan
	MOV	(R0)+,(R0)+	;In both places
	MOV	#U.CMN+U.STR,(R0) ;Now set the address of the string
	.FSS			;And go scan the device name
	MOVB	@#FIRQB,R1	;Did we get an error?
	BNE	10$		;Yes, so report it
	TST	-(R0)		;Did we scan the whole thing?
	BEQ	20$		;Yes, we sure did
	MOV	#BADNAM,R1	;Report bad file name
10$:	REPAINT	U.CMN+U.POS	;Set up an arrow
	CMESSAGE R1		;And report the RSTS error code
	JMP	ERRTRY		;Now try again

20$:	MOV	(SP)+,R1	;Restore a work register
	MOV	(SP)+,R0	;And another one
	RETURN			;All done for now

GLOBAL	<BADNAM>

;+
; STFQDM - Store the FIRQB into dynamic memory
;
;	R5 -> Previous entry in list, or list header
;
;	CALL	STFQDM
;
;	R5 -> New entry in list
;
; Note: Sooner or later, I will make this routine insert entries sorted
; by PPN. Keep this in mind when you use this!
;-

STFQDM:	MOV	R1,-(SP)	;Get a work register
	MOV	R0,-(SP)	;And another one
	MOV	#<S$SIZE+3>&^C<3>,R1 ;R1 = Desired size of entry
	CALLX	GETMEM		;Now get memory for the entry
	MOV	R0,(R5)		;And link this entry to the previous entry
	MOV	R0,R5		;Now set up pointer to new entry
	CLR	(R0)+		;And clear the link to next
.ASSUME	S$NEXT	EQ	0
.ASSUME	S$PPN	EQ	S$NEXT+2
.ASSUME	S$NAME	EQ	S$PPN+2
	CALL	STRFQB		;Now store the FIRQB contents
	MOV	(SP)+,R0	;Restore one work register
	MOV	(SP)+,R1	;And another one
	RETURN			;And now we're done

;+
; STRFQB - Store the FIRQB into a list entry
;
;	R0 -> Area to store list entry
;
;	CALL	STRFQB
;
; All registers are preserved
;-

STRFQB:	MOV	R0,-(SP)	;Get a work register
	MOV	R5,-(SP)	;And another one
	MOV	R0,R5		;Match conventions
	MOV	#FIRQB+FQPPN,R0	;And point R0 to FIRQB @ FQPPN
	MOV	(R0)+,(R5)+	;Save the specified PPN
	CALLX	RAD$FN		;Now do the conversion
	MOV	(SP)+,R5	;Restore a work register
	MOV	(SP)+,R0	;And another one
	RETURN			;And now we're done

.SBTTL	Check for valid devices

;+
; CHKDSK - Check XRB for disk
;
;	U.CMN + U.POS = Position of device name being checked
;-

CHKDSK:	CALL	SCANMF		;FSS it					;048
	TSTB	@#XRB+XRMOD	;Is device a disk?
	BEQ	10$		;Yes, that's good
	REPAINT	U.CMN+U.POS	;No, so repaint the command line
	CMESSAGE #DEVDSK		;Tell them device name must be disk
	JMP	ERRTRY		;And try again

10$:	RETURN			;All done for now

GLOBAL	<DEVDSK>

;+
; CKMTDK - Check for disk or tape
;
;	U.CMN + U.POS = Position of device being checked
;-

CKMTDK:	CALL	SCANMF		;FSS it					;048
	CMPB	@#XRB+XRMOD,#MTAHND ;Is device a magtape?
	BEQ	10$		;Yes, that's good
	TSTB	@#XRB+XRMOD	;Is device a disk?
	BEQ	10$		;Yes, that's good
	REPAINT	U.CMN+U.POS	;No, so repaint the command line
	CMESSAGE #DEVDMT		;Tell them device name must be disk or tape
	JMP	ERRTRY		;And try again

10$:	RETURN			;All done for now

GLOBAL	<DEVDMT>

;+
; TAPQUL - Disallow qualifier unless saveset is tape
;
;	U.CMN + U.POS = Position of qualifier to check
;
;	CALL	TAPQUL
;
; All registers are preserved.
;-

TAPQUL:	TSTB	$SAVFLG		;Is this a disk backup?
.ASSUME	DSKHND	EQ	0
	BNE	10$		;No, so let this qualifier go
	REPAINT	U.CMN+U.POS	;Repaint the command line
	CMESSAGE #INVDSK	;And tell them invalid for disk
	JMP	ERRTRY		;Now try again

10$:	RETURN			;All done for now...

GLOBAL	<$SAVFLG,INVDSK>

;+									;053+
; DSKQUL - Disallow qualifier unless saveset is disk
;
;	U.CMN + U.POS = Position of qualifier to check
;
;	CALL	DSKQUL
;
; All registers are preserved.
;-

DSKQUL:	BIT	#DO.RES,C$FLAG	;Is this a RESTORE?			;062
	BNE	10$		;Yes, no need to check			;062
	TSTB	$SAVFLG		;Is this a disk backup?
.ASSUME	DSKHND	EQ	0
	BEQ	10$		;Yes, so let this qualifier go
	REPAINT	U.CMN+U.POS	;Repaint the command line
	CMESSAGE #INVTAP	;And tell them invalid for tape
	JMP	ERRTRY		;Now try again

10$:	RETURN			;All done for now...

GLOBAL	<$SAVFLG,INVTAP>						;053-

.SBTTL	Check for a privilege

;+
; CHKPRV - Check for a privilege
;
;	CALB	CHKPRV,PRIVIELGE
;
;		PRIVILEGE = Privilege name to check, as a .ASCIC string
;
; Data returned:
;
;	R0 = 0 if caller has privilege, 1 if not
;
;-

CHKPRV:	SUBR	<PRIV>		;One argument please			;002
	CALLX	CLRFQB		;Clear out the FIRQB			;002
	MOV	#FIRQB+FQFUN,R1	;R1 -> FIRQB @ FQFUN			;002
	MOVB	#UU.CHK,(R1)+	;Function is check privileges		;002
	MOV	#1,(R1)+	;Subfunction is check for a privilege	;002
	CLR	(R1)+		;Skip past FQPPN			;002
	MOV	PRIV(R5),R4	;R4 -> Privilege name as .ASCIC string	;002
	MOVB	(R4)+,R3	;R3 = Length of privilege name		;002
10$:	MOVB	(R4)+,(R1)+	;Move a byte of the privilege name	;002
	SOB	R3,10$		;For the whole name			;002	
	.UUO			;Go look up the privilege		;002
	CRASH			;And die on errors			;002
	MOVB	@#FIRQB+FQERNO,R0 ;Get the returned value		;002
	RETURN			;And we're done				;002

.SBTTL	Private CUI pool allocation

;+
; U$ALLO - Allocate something from the pool
;
;	CALB	U$ALLO,SIZE
;		SIZE = Amount of memory required, in bytes
;
; Data returned:
;
;	R0 = 0
;	R1 -> Memory requested
;
;	C = 0 (always)
;-

U$ALLO::SUBR	<SIZE>		;Set up for our caller			;003
	MOV	SIZE(R5),R2	;Pick up size requested			;003
	MOV	R2,R1		;And copy it for GETMEM			;003
	ADD	#4,R1		;And add in our overhead		;003
	CALLX	GETMEM		;Allocate the memory			;003
	MOV	POOLST,(R0)	;Set up the link to next		;003
	MOV	R0,POOLST	;And make this the head of the list	;003
	TST	(R0)+		;Advance to size saving entry		;003
	MOV	R1,(R0)+	;Now save the size of this entry	;003
	MOV	R0,TOS.R1(SP)	;Set up the address for CUI conventions	;003
10$:	CLRB	(R0)+		;Clear a byte				;003
	SOB	R2,10$		;Now loop for the whole thing		;003
	CLR	R0		;Indicate goodness			;003
	RETURN			;And we're done				;003

.SBTTL	Private CUI pool initialization

;+
; U$IPOL - Initialize CUI's pool
;
;	CALB	U$IPOL
;
; This routine is used to initialize our pool. We go through the
; pool list, and return all memory to the global pool.
;-

U$IPOL::MOV	POOLST,R2	;Pick up entry to return		;003
	BEQ	10$		;All done				;003
	MOV	(R2),POOLST	;And unlink it				;003
	MOV	2(R2),R1	;Get size of entry			;003
	CALLX	RETMEM		;Now return it to the pool		;003
	BR	U$IPOL		;And try again				;003

10$:	RETURN			;All done, pool initialized		;003

.END
