.INCLUDE /SYSTEM:BCKPFX/
TITLE	BCKSUB,<Support Subroutines>,0K,02-JUN-92,BSB/KPH/FRL/BGN/DRP

;
;		COPYRIGHT (c) 1974, 1992 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	Edit history for BCKSUB

;+
;
;  000	KPH  16-Nov-83	Creation for Version 9.0
;  001	KPH  01-Nov-84	Exit on control/Z	
;			Bugfixes
;  002	KPH  29-Nov-84	Add [NO]TELL
;  003  KPH  06-Mar-85	Save set clustersize = free space / 100 rounded up
;			Remove /DOS; Have /REWIND replace it
;			Add option bit to place index at the beginning
;			Add BUFWAT routine
;			Add small buffer waits
;			Rewind tape when saying "No" to wrong volume...
;			Use a static buffer for DSKINT
;			Don't do three patterns on previous RSTS disks
;			Trap errors from NFS open in DSKINT
;  004  KPH  17-Apr-85	Don't error on .FSS when default prot. code is assigned
;			Do a rewind for verify processing
;			Bugfix in clustersize calculation
;
;			[RSTS V9.1]
;  005  KPH  05-Jun-85	Add high density support
;  006  KPH  13-Jun-85	Add minimum and maximum density support
;  007  KPH  19-Aug-85	Bugfix in writing save set size
;
;			[RSTS V9.2]
;  008  FRL  11-Feb-86	Ensure a rewind before the set density of an init
;
;			[RSTS V9.3]
;  009  KPH  20-Jan-86	Add CRC-32 calculator from GMB
;  010  FRL  28-Apr-86  Add installation qualifiers and redefine /[NO]TELL
;  011  FRL  12-Sep-86	Do not proceed on ^Z to "Press RETURN" prompt
;
;			[RSTS V9.5]
;  012  BGN   8-Oct-87	Modify cluster size constants
;
;			[RSTS V9.6]
;  013	BGN  14-Oct-87	Fix the way CRASH works
;  014  BGN  29-Feb-88	Use dynamic pseudo keyboards
;
;			[RSTS V9.7]
;  015	BGN  14-May-89	Don't init the dynamic region in this module
;  016  BGN  15-May-89  Make ;014 work
;  017  BGN  25-May-89  Allow the dynamic region init call to be made here
;			If we already have a region out there then nothing
;			is going to happen.
;
;			[RSTS V10.0]
;  018	FEK  12-Oct-89	Allow Larger Magtape recordsizes
;  019  BGN  26-Oct-89	Add support for image mode
;  020  BGN   2-Nov-89  Add code to hook disks
;  021	REG  30-Nov-89	Merge /INIT code from GPK
;  022	REG  07-Dec-89	Add exit with status
;  023	REG  12-Dec-89	Add image volume dismount message
;  024	REG  19-Dec-89	/IMAGE: out_label default to in_label
;  025	REG  19-Dec-89	Add /INIT=([NO]ERASE,[NO]EXERCISE=1,2,3)
;  026	REG  30-Dec-89	Improve parsing in ;025
;  027	REG  07-Jan-90	Fix test for init'ing tapes
;  028	REG  12-Jan-90	Move HOOK code to IMGRMS to make .TSK smaller
;  029	REG  13-Jan-90	Make user's CTRL-Z jump to restart
;  030	REG  13-Jan-90	Add OMS
;  031	REG  18-Jan-90	Fix /CLUS=nn bug
;  032	REG  18-Jan-90	Spawn PK even if nologins, raise temp privs
;  033	REG  20-Jan-90	Allow dskint PK code to be used by HOOK
;  034	REG  01-Feb-90	Move buffers to BCKDTA to make more room
;  035	REG  01-Feb-90	Move CRASH and BUFWAT to BACKUP for more room
;  036	REG  18-Feb-90	/REPLACE=ASSIST and /ALL
;  037	REG  18-Feb-90	Fix exit with status
;  038	REG  16-Mar-90	Remove /NOQUERY from DSKINT command line (grrr)
;  039  REG  03-Apr-90	Add big blocks
;  040  REG  03-Apr-90	Add DSKINT/QUERY
;  041  REG  03-APR-90	Add /QUERY=ASSIST
;  042  REG  03-Apr-90	Add big OMS messages
;  043  REG  10-Apr-90	Fix DSKINT .TMP file bug
;  044  REG  17-Apr-90	Add "_" to "CLUSTER_SIZE"
;  045  REG  20-APR-90	Add Y/ALL,N/ALL for /QUERY
;  046  REG  24-Apr-90	Check for /IN_LABEL for BCKRMS and IMGRMS
;  047  REG  24-Apr-90	Remove /QUERY=ASSIST and /REPLACE=ASSIST for V10.0
;  048  REG  23-May-90  Fix CRC32 bug
;  049  REG  27-May-90	Use DSKSTA for output disk init flags for /image
;  050	REG  29-May-90	Split up OMS text over 255 chars long
;  051  REG  21-Jun-90	Don't try to write null data to KB
;  052  REG  08-Aug-90	Write OMS input to log file; restart if OMS not up
;  053  REG  22-Aug-90	Clear /INIT if /NOINIT specified
;
;			[RSTS V10.1]
;  054  REG  07-Jan-91	Free up one APR
;  055  REG  07-Jan-91	Patch to disable tape dismounts
;  056  REG  25-Jan=91	EXERCT is a byte
;  057  REG  25-Jan-91	Fix error 31 problem with big BADB.SYS and /INIT;
;			Remove unnecessary UU.FCB call to get PK's KB#
;  058  REG  07-Feb-91	Fix dev name if null
;  059  REG  21-May-91	Print <SP><BS> before mount errors
;  060  REG  22-May-91	Reallocate disk before HOOK
;  061	DRP  09-Aug-91  Fix bug in MNTDSK where the Pack Status word of
;			the input disk is not used when doing an image
;			copy and /OUT_LABEL is specified.
;  062	DRP  01-Jun-92	Append !~I to the <SP><BS> that precedes the mount
;			errors messages so that they are displayed when
;			BACKUP is run from a com file.
;-

.SBTTL	Call any required MACROs

.MCALL	CALBX,.ASCIC,$FAO,$CUI,SUBR,WSIG$S,$FAP				;059
$CUI	MSG

.MACRO	CMESS	MSGSYM,PLUGINS,?A					;030+
	BIT	#GF.ASS,GENFLG						;060
	BNE	A							;060
	$FAP	<#SPBS>		;Prevent alteration of exit status	;059
A:									;060
	.IF	B	<PLUGINS>
	CMESSAGE	<MSGSYM>
	.IFF
	CMESSAGE	<MSGSYM,PLUGINS>
	.ENDC
	CALL	OMSCHK
	.ENDM	CMESS							;030-


.SBTTL	Define our local data

	.PSECT	RODATA,RO,D,LCL,REL,CON

	;+								;062
	; The ASCII values defined by SPBS are characters which precede
	; the mount messages. Some of these messages are actually errors
	; whose first character is a "?" or "%". Because these messages
	; begin with a "?" or "%" they affect the jobs completion status.
	; However, because the user takes measures to correct the problem,
	; the backup may complete successfully and therefore we don't want
	; them to affect the job status. To prevent this we precede the
	; message with these ASCII values. The first byte is a count field
	; defining the number of ASCII characters. The remaining values are
	; the characters themselves. The characters are:
	;			 <SP><BS>!~I
	; The space/backspace combination is what actually prevents the
	; completion status from being affected by the message. The !~I
	; combination is a CUI print modifier used to tell the monitor to
	; ignore noverify. This is needed to insure that the message will
	; be displayed if BACKUP is run from a com file with SET NOVERIFY
	; in effect.
	;-								;062

SPBS:	.BYTE	5,40,10,41,176,111					;062

YESCTL:	.ASCIC	<"!AC [!UW,!UW]!AD ? ">

CHKSTR:	UNQTXT	<Y-ES>		;Text for "YES"
	UNQTXT	<N-O>		;Text for "NO"
	.BYTE	0		;End of table
CHKSTQ:	UNQTXT	</ALL>		;Text for "/ALL"			;036
	.BYTE	0		;End of table				;036

MODNAM:	.ASCIC	<"BCKSUB">	;Module name
VOLASK:	.ASCIC	^/"Where can this volume be located? <!AD> "/
WRGVOL:	.ASCIC	^/"This is not the correct volume - proceed anyway? <No> "/
PRSRTN:	.ASCIC	^/"Press RETURN when ready:"/				;010

INITXT:	.ASCIC	<"INITIALIZE">	;The text INITIALIZE for default's sake

CHKINI:	UNQTXT	<IN-ITIALIZE>	;Text for "INITIALIZE"
	UNQTXT	<NOIN-ITIALIZE>	;Text for "NOINITIALIZE"
CHKARG:	UNQTXT	<ER-ASE>	;Text for "ERASE"			;025
	UNQTXT	<NOER-ASE>	;Text for "NOERASE"			;025
	UNQTXT	<EX-ERCISE>	;Text for "EXERCISE"			;025
	UNQTXT	<NOEX-ERCISE>	;Text for "NOEXERCISE"			;025
	UNQTXT	<QU-ERY>	;Text for "QUERY"			;040
	UNQTXT	<NOQU-ERY>	;Text for "NOQUERY"			;040
	UNQTXT	<CL-USTER_SIZE>	;Text for "CLUSTER_SIZE"		;044
NULASC:	.BYTE	0		;End of table (and a handy null to use)

IC:									;021
INICTL:	.BLKB			;Reserve a byte for our count
	.ASCII	"$SET NODATA"	;Make sure our PK gets prompts
	.BYTE	15,12		;And set up a CR/LF
	.ASCII	"$INIT/CLUS=!UB/DATE=!AC/!AC/!ACWRITE/INDEX=!AC/!AC!AC!AC" ;038;040
	.ASCII	" !AD!UB !AD"	;Source disk; Pack ID			;003
				;Set up our initialize command
	.BYTE	15,12		;Now a CR/LF
	.ASCII	+$INQUIRE/NOPUNCTUATION DUMMY ""+
				;And make the COM file wait for us
	.BYTE	15,12		;And end it with a CR/LF
$$$$$$	=	<.-INICTL>-1
.ASSUME	$$$$$$	LE	377	;COM file must fit as a .ASCIC string
.SAVE
.	=	INICTL
	.BYTE	$$$$$$
.RESTORE

PRVTXT:	.ASCIC	<"PRIVATE">	;Text for initializing private disks
PUBTXT:	.ASCIC	<"PUBLIC">	;Text for initializing public disks (yuch!)
ACCTXT:	.ASCIC	<"ACCESSED">	;Text for initializing disks DLA
MODTXT:	.ASCIC	<"MODIFIED">	;Text for initializing disks DLW
NOTXT:	.ASCIC	<"NO">		;Text to negate qualifiers
BEGTXT:	.ASCIC	<"BEGINNING">	;Place index at beginning		;003
MIDTXT:	.ASCIC	<"MIDDLE">	;Place index in middle			;003
DEFLBL:	.ASCII	/BACKUP/	;Default label for disk save sets
ERATXT:	.ASCIC	<"/ERASE">	;Text for /INIT=ERASE			;021
NERTXT:	.ASCIC	<"/NOERASE">	;Text for /INIT=NOERASE			;021
QERTXT:	.ASCIC	<"/QUERY">	;Text for /INIT=QUERY			;040
NQETXT:	.ASCIC	<"/NOQUERY">	;Text for /INIT=NOQUERY			;040

.EVEN	;Cowgirls get the blues
									;021
EXETBL:	.BLKW	4		;Strings for /INIT=EXERCISE=n		;021
.IRP	X,<0,1,2,3>							;021
...	=	.							;021
.SAVE									;021
.	=	EXETBL+<2*'X>						;021
	.WORD	...							;021
.RESTORE								;021
.IF	EQ	X							;021
	.ASCIC	<"NOEXERCISE">						;021
.IFF									;021
	.ASCIC	<"EXERCISE='X">						;021
.ENDC									;021
.ENDR									;021
.EVEN									;021

	.PSECT	RWDATA,RW,D,LCL,REL,CON

DSKSTA::.BLKW			;Status word of disk to initialize	;049
OL::									;060
OUTLEN::.BLKW	2		;Length of converted string goes here	;050
HLDOFF:	.BLKW			; Message hold offset			;042
HLDPTR:	.BLKW			; Message start pointer			;057
CTYBUF:	.BLKW			; TTYBUF + offset for $FAO		;042
CTYLEN:	.BLKW			; TTYLEN - offset for $FAO		;042
WORK:	.BLKB	20.		;Work area
PRXSIZ:	.BLKW			;Size to which backupset was pre-extended ;021
COUNT::	.BLKW			;Byte count for CRC32			;039
JUNK:	.BLKW			;A place for nothing			;054

.SBTTL	Parameter block offset definitions (PARBUF)			;030+
.DSECT

OMSCMD:	.BLKW				; Command to send to OMS
RCVRID:	.BLKB	6			; Receiver ID for confirmation message
RCVCTX:	.BLKW				; Context value to be returned
OMSCTX:	.BLKB				; Reserved for use by the subroutines
	.BLKB				; Reserved
RCVLEN:	.BLKW				; Length of message received
ERRSTS:	.BLKW				; Error status of request packet
ERRFLD:					; Field # of packet that caused error
SEQNUM:	.BLKW				; Sequence # assigned to REQUEST
REQSTS:	.BLKW				; Status of REQUEST/REPLY command
REPKBN:	.BLKB				; Operator KB # that made reply
REPJOB:	.BLKB				; Operator job # that made reply
REPPPN:	.BLKW				; Operator PPN that made reply	;030-

	.PSECT	ROCODE,RO,I,LCL,REL,CON

.SBTTL	Ask a yes/no question about a file

;+
; FILYNO - Ask a yes/no question about a file
;
;	R3 -> .ASCIC question to ask
;	$CURFI = File to ask about
;
;	CALL	FILYNO
;
;	All registers are preserved
;
;	C = 1 if answer is no
;	C = 0 if answer is yes
;-

FILYNO::SAVREG			;Save all registers
10$:	MOV	$CURFI+C$PPN,R4	;R4 = Current PPN
	CLR	R5		;R5 will hold the programmer number
	BISB	R4,R5		;Now R5 has programmer number
	CLRB	R4		;Get ready for project number
	SWAB	R4		;Now R4 has project number
	$FAO	#YESCTL,#OUTLEN,#TTYLEN,#TTYBUF,<R3,R4,R5,#10.,#$CURFI+C$NAME>
				;Format the output string
	BIS	#GF.YNF,GENFLG	;Tell 'em this is a query, not a mount	;036
	CALL	PRTINP		;Print the string and take input
	BCC	20$		;No error, that's good
	CMPB	R0,#EOF		;Did they hit ^Z	
	BEQ	70$		;Yes, so get out			;001
	BIS	#GF.HLD,GENFLG	;Hold this one				;042
	CMESS	R0		;No, so just say the error code
	BR	10$		;And try again

20$:	TSTB	(R5)		;Do we have anything at all?
	BEQ	50$		;No, so that means no
	CALLX	GETUNQ,R0,CHKSTR ;Scan for string
	BCC	30$		;Not found, tell them to say yes or no
	MOV	R1,-(SP)	;Save the result			;036
	TSTB	(R5)		;Found, but was there extra junk?
	BEQ	40$		;No, not this time
	CALLX	GETUNQ,R0,CHKSTQ ; Scan for a qualifier			;036
	BCC	35$		;Not found, tell 'em the choices	;036

	; Deal with /ALL for /QUERY and /REPLACE			;045
	CMP	R3,#ASKRPL	;Is this a /REPLACE?			;045
	BEQ	25$		;Yes, go handle that			;045
	BIC	#DO.QRY,C$FLAG	;Reset the query flag			;045
	TST	(SP)		;Did they say YES?			;045
	BEQ	40$		;Yes					;045
	BIS	#C2$QER,C$FLG2	;No, set the skip flag			;045
	BR	40$		;Done					;045

25$:	BIS	#REP.S,C$FLAG	;Don't allow any more /REPLACE queries	;036
	BIC	#DO.REP,C$FLAG	;Guess NO/ALL				;045
	TST	(SP)		;Did they say YES?			;036
	BNE	40$		;No					;036
	BIS	#DO.REP,C$FLAG	;Yes, replace 'em all			;045
	BR	40$		;And exit				;036

30$:	BIS	#GF.HLD,GENFLG	;Hold this one				;042
	CMESS	#YESNO		;Tell them to say yes or no
	BR	10$		;And try again

35$:	BIS	#GF.HLD,GENFLG	;Hold this one				;042
	CMESS	#ALLNON		;Tell them to say /ALL or /NONE		;036
	MOV	(SP)+,R1	;Fix the stack				;036
	JMP	10$							;060
	
40$:	MOV	(SP)+,R1	;Retrieve the result			;036
	TST	R1		;Is it "YES"?
	BEQ	60$		;Yes, that's good (C = 0 from TST)
50$:	SEC			;It is no, so set carry
60$:	BIC	#GF.YNF,GENFLG	;Clear the query flag			;036
	RETURN			;And we're done

70$:	BIC	#GF.YNF,GENFLG	;Clear the query flag			;036
	JMPX	RESTRT		;Go and get out quickly			;001

GLOBAL	<$CURFI,EOF,YESNO,TTYBUF>
GLOBAL	<ALLNON.GENFLG>							;036
GLOBAL	<QRYTXT,SELRES,ASKRPL>						;045

.SBTTL	Check for /IN_LABEL						;046+

;+
; INVCHK - Check for /IN_LABEL
;
;	CALL	INVCHK
;
; If /IN_LABEL was specified, this routine compares the label name
; with the input pack label and issues an error if they are different.
;-

INVCHK::TSTB	$DSKLB		;Do we need to verify input label?
	BEQ	40$		;No, not this time

	MOVB	#UU.ATR,@#FIRQB+FQFUN ;Function is read/write attributes
	MOVB	#-4,@#FIRQB+FQFIL ;Subfunction is get pack attributes
	MOV	$DSKDEV,@#FIRQB+FQDEV ;From the input device
	MOV	$DSKUNT,@#FIRQB+FQDEVN ;And unit number
	.UUO			;Now go for it
	MOVB	@#FIRQB,R2	;R2 = Returned error code
	BEQ	10$		;It worked, great
	CMESS	#ERRROL		;Tell them error reading input label	;052
	BR	50$		;And get out reporting RSTS error

10$:	MOV	#FIRQB+20,R0	;R0 -> Pack label in RAD-50
	SUB	#6,SP		;Get some work space
	MOV	SP,R5		;R5 -> work area
	CALLX	RAD$W2		;Convert this pack label to ascii
	MOV	#$DSKLBL+6,R1	;R1 -> Just past output label
	MOV	#3,R2		;R2 = Count of words to compare
20$:	CMP	-(R1),-(R5)	;Pack labels match?
	BNE	30$		;No, not this time
	SOB	R2,20$		;Yes, check more now
	ADD	#6,SP		;Release our stack space
	BR	40$		;Done, this is the correct volume...

30$:	MOV	#WRGIVL,R2	;Get ready to report incorrect volume
	BR	50$		;Now get out reporting it

40$:	RETURN			;And now we're done

50$:	CMESS	R2		;Report the error to our user		;052
	JMPX	RESTRT		;And try again

GLOBAL	<$DSKLB,WRGIVL,ERRROL,$DSKDE,$DSKUN>				;046-

.SBTTL	Mount the next volume of a save set

;+
; MOUNT - Mount the next volume of a save set
;
;	$SAVNAM = Save set name
;	$SAVDEV = Save set default device
;	$SAVUNT = Save set default unit
;	$SAVFLG = Save set device dependant flags
;
;	CALL	MOUNT
;
; New device is mounted. $SAVDEV and $SAVUNT are updated for the
; new device.
;-

MOUNT::	SAVREG			;Save all registers
	MOV	CURVOL,R1	;Pick up the current volume number
	BEQ	20$		;None, that's easy
	CMP	R1,BBHDAT+BBH$VL ;Do we have the correct volume mounted?
	BNE	10$		;No, so we've got to unload the current one
	JMP	OPNSET		;Yes, so mount is easy			;003

10$:	CALL	UNLOAD		;Go and unload this current volume

20$:	CMP	BBHDAT+BBH$VL,#1 ;Is this volume number one?
	BNE	30$		;No, so always ask for them to mount volume
	BIT	#C2$PRO,C$FLG2	;Do they want a prompt?
	BEQ	30$		;Yes, they sure do
	MOV	#TTYBUF,R5	;R5 -> Terminal I/O buffer
	CLRB	(R5)		;Pretend they entered the default
	JMP	PARSDV		;And skip asking anything		;010

30$:	BIT	#<DO.INS!DO.IMA>,C$FLAG	;Installation/Image mode?	;019
	BNE	GETDEV		;Yes					;010
	BIS	#GF.HLD,GENFLG	;Don't send this yet if OMS		;042
	CMESS	#PLSMNT,<BBHDAT+BBH$VL,#10.,#$SAVNAM+C$NAME>
				;Tell them to mount the volume
	.BR	GETDEV		;Join up				;010

GLOBAL	<BBHDAT,CURVOL,C$FLG2,TTYBUF,PLSMNT,C$FLAG,PLSMNI>		;019

; Now we get the device name and parse it

GETDEV:	MOV	#2,STATS	;Initialize exit status to error	;037
	CALL	DEASET		;Be sure we don't have anything assigned
	MOV	#WORK,R5	;R5 -> Work area
	MOV	$SAVDEV,(R5)+	;Copy name
	BNE	5$		;Is there one?				;058
	MOVB	#'S,-2(R5)	;No, make it look nice			;058
	MOVB	#'Y,-1(R5)	; with system disk name			;058
5$:	MOV	$SAVUNT,R0	;Pick up unit number
	BEQ	10$		;None, nothing to do
	BIC	#^C<377>,R0	;Isolate the unit number
	CALLX	NUM$		;Now convert it to ASCII
10$:	MOVB	#':,(R5)+	;Set up a colon for prettiness
	BIT	#<DO.INS!DO.IMA>,C$FLAG	;Installation/Image mode?	;019
	BNE	60$		;Yes					;010
	BIT	#DO.RES,C$FLAG	;Is this a restore?
	BNE	40$		;Yes, so don't show qualifier default
	MOVB	#'/,(R5)+	;Backup, show qualifier default
	BIT	#DO.INI,C$FLAG	;Should we default to /INITIALIZE
	BNE	20$		;Yes, so no special "NO"
	MOVB	#'N,(R5)+	;Noinit, so set up the N
	MOVB	#'O,(R5)+	;And the O
20$:	MOV	#INITXT,R2	;Point to the /INITIALIZE text
	MOVB	(R2)+,R3	;Pick up the length
30$:	MOVB	(R2)+,(R5)+	;Copy a byte
	SOB	R3,30$		;And loop for the whole thing
40$:	SUB	#WORK,R5	;Now R5 has the length of the output buffer
	MOV	#TTYBUF,CTYBUF	;Get the TTY buffer address		;042
	ADD	HLDOFF,CTYBUF	;Add in the offset			;042
	MOV	#TTYLEN,CTYLEN	;Get the TTY buffer length		;042
	SUB	HLDOFF,CTYLEN	;Subtract the offset			;042
	$FAO	#VOLASK,#OUTLEN,CTYLEN,CTYBUF,<R5,#WORK> ;042
				;Format the output string
	CALL	PRTINP		;Now ask the question
	BCS	42$		;Error					;060
	JMP	PARSDV		;No error, that's good			;060

42$:	CMPB	R0,#EOF		;Did they hit ^Z			;060
	BNE	50$		;No, not this time			;001
45$:	JMPX	RESTRT		;Yes, so get out			;001

50$:	BIS	#GF.HLD,GENFLG	;Hold this one				;042
	CMESS	R0		;Report the error			;001
	BR	GETDEV		;And ask again

60$:	MOV	BBHDAT+BBH$VL,R3 ;Get next volume			;010
	ADD	$BIAS,R3	;Add bias				;010
	SUB	#WORK,R5	;R5 = length of work buffer		;010
	BIS	#GF.HLD,GENFLG	;Don't send this yet if OMS		;042
	BIT	#DO.IMA,C$FLAG	;Image mode?				;019
	BEQ	65$		;No, continue				;019
	CMESS	#PLSMNI,<#$SAVDEV,#$SAVUNT> ;Image prompt		;019
	BR	66$		;And continue				;019
65$:	CMESS	#PLSMNX,<R3,R5,#WORK> ;Give installation message	;010
66$:	MOV	#TTYBUF,CTYBUF	;Get the TTY buffer address		;042
	ADD	HLDOFF,CTYBUF	;Add in the offset			;042
	MOV	#TTYLEN,CTYLEN	;Get the TTY buffer length		;042
	SUB	HLDOFF,CTYLEN	;Subtract the offset			;042
	$FAO	#PRSRTN,#OUTLEN,CTYLEN,CTYBUF		 		;042
				;Format output text	;030
	CALL	PRTINP		;Print and get input			;030
	BCC	70$		;No error, that's good			;010
	CMPB	R0,#EOF		;Did they hit ^Z			;010
	BEQ	45$		;Yes, get out				;029
	BIS	#GF.HLD,GENFLG	;Hold this one				;042
	CMESS	R0		;Report the error code			;010
67$:	JMP	GETDEV		;And try again				;019

70$:	CLRB	(R5)		;Pretend they just hit RETURN as they were ;010
	.BR	PARSDV		;  supposed to do, and join up		;010

GLOBAL	<STATS,$SAVDEV,$SAVUNT,C$FLAG,TTYBUF,EOF,PLSMNX,BBHDAT,$BIAS>	;022

; Now parse the entered device name
;
;	R5 -> Entered string as .ASCIZ

PARSDV:	MOV	R5,R4		;Copy pointer to string			;003
	CALLX	CVT$$A		;Eliminate non-essentials		;026
	CLR	R2		;R2 will hold length of string
	CLR	R3		;R3 is the "colon-found" flag
	BIS	#C2$INT,C$FLG2	;Guess at /INIT				;025
	BIT	#DO.RES,C$FLAG	;Is this a restore?
	BNE	10$		;Yes, so it must be /NOINITIALIZE
	BIT	#DO.INI,C$FLAG	;Well, is this /INITIALIZE by default?
	BNE	20$		;Yes, it sure is
10$:	BIC	#C2$INT,C$FLG2	;Default to /NOINIT			;025
20$:	TSTB	(R5)		;Are we at end of string yet?
	BNE	22$		;Yes, we sure are			;025
	JMP	70$		;					;025
22$:	CMPB	(R5),#'/	;Is this a qualifier?
	BEQ	40$		;Yes, go handle this
	CMPB	(R5)+,#':	;Is this a colon?
	BNE	30$		;No, not this time
	INC	R3		;Yes, so set the colon found flag
30$:	INC	R2		;Say one more character
	BR	20$		;And loop

40$:	BIT	#DO.RES,C$FLAG	;Is this a restore?
	BEQ	50$		;No, so switches are valid
	MOV	#NOSRES,R2	;Tell them no switches on restore
	JMP	ERROR2		;And we're done				;025

50$:	INC	R5		;Point past the slash
	CALLX	GETUNQ,R0,CHKINI ;Scan for initialize
	BCS	501$		;Found					;042
	JMP	60$		;Not found, tell them we don't understand
501$:									;042
	BIC	#C2$INT,C$FLG2	;Guess at /NOINIT			;053
	TST	R1		;/NOINIT specified?			;025
	BNE	502$		;Yes, don't set the flag		;025
	BIS	#C2$INT,C$FLG2	;Remember that we want to init the disk	;025
502$:	TSTB	(R5)		;Found, but was there junk at the end?	;025
	BNE	503$		;Yes					;042
	JMP	70$		;No, the string matched fine
503$:									;042
	CMPB	(R5)+,#'=	;Equal sign?				;025
	BEQ	504$		;Yes					;053
	JMP	62$		;No, set 'em straight			;053
504$:	CMPB	(R5),#'(	;Left paren?				;025
	BNE	508$		;No					;025
	INC	R5		;Yes, step past it			;025
508$:	CALLX	GETUNQ,R0,CHKARG ;Scan for a qualifier			;025
	BCC	62$		;Tell 'em what their choices are	;025

510$:	TST	R1		;=ERASE?				;025
	BNE	520$		;No, try another			;025
	BIS	#C2$ERA,C$FLG2	;Yes, set the =ERASE flag		;025
	BIC	#C2$NER,C$FLG2	;Yes, reset the =NOERASE flag		;053
	BR	550$		;And continue				;025

520$:	DEC	R1		;=NOERASE?				;025
	BNE	530$		;No, try another			;025
	BIC	#C2$ERA,C$FLG2	;Yes, reset the =ERASE flag		;053
	BIS	#C2$NER,C$FLG2	;Yes, set the =NOERASE flag		;025
	BR	550$		;And continue				;025

530$:	DEC	R1		;=EXERCISE?				;025
	BNE	540$		;No, try another			;025
	BIS	#C2$EXE,C$FLG2	;Set the =[NO]EXERCISE flag		;025
	CALL	560$		;And get the patterns			;025
	BCC	535$		;No carry means we have a value		;025
	BIC	#C2$EXE,C$FLG2	;Take the default for =EXER		;025
	BR	550$		;And continue				;025

535$:	TST	R0		;Inspect the pattern count carefully	;025
	BMI	62$		;Less than 0 is NFG			;025
	CMP	R0,#3		;Check the upper limit			;025
	BGT	62$		;Too big is NFG either			;025
	MOVB	R0,EXERCT	;Store it away				;056
	BR	550$		;And continue				;025

540$:	DEC	R1		;=NOEXERCISE?				;025
	BNE	543$		;No, try another			;025
	BIS	#C2$EXE,C$FLG2	;Set the =[NO]EXERCISE flag		;025
	CLRB	EXERCT		;Must be =NOEXERCISE then		;056
	BR	550$		;And continue				;025

543$:	DEC	R1		;=QUERY?				;040
	BNE	545$		;No, try another			;040
	BIS	#C2$QRY,C$FLG2	;Yes, set the =QUERY flag		;040
	BR	550$		;And continue				;040

545$:	DEC	R1		;=NOQUERY?				;025
	BNE	547$		;No, try another			;025
	BIC	#C2$QRY,C$FLG2	;Yes, reset the =QUERY flag		;025
	BR	550$		;And continue				;025

547$:	CALL	560$		;Must be =CLUSTER_SIZE then		;025
	BCS	62$		;No value is an error			;025
	TST	R0		;Check the lower limit			;026
	BLE	62$		;Too small is NFG			;026
	CMP	R0,#64.		;Check the upper limit			;025
	BGT	62$		;Too big is NFG either			;025
	MOV	R0,INICLU	;Store it away				;025

550$:	CLC			;Let's start off on the right foot	;025
	CALL	570$		;Step to the next string		;025
	BCS	60$		;Brook no nonsense			;025
	CALLX	GETUNQ,R0,CHKARG ;Scan for a qualifier			;025
	BCC	70$		;No more qualifiers			;025
	CLC			;It'll cause problems later if it's set	;025
	BR	510$		;Find out what it is			;025

560$:	CMPB	(R5),#'=	;Equal sign?				;025
	BNE	562$		;No					;025
	CLR	R0		;init it				;025
5602$:	INC	R5		;See what's there			;025
	MOVB	(R5),R1		;Get the number 			;025
	SUB	#48.,R1		;Make it binary				;025
	ADD	R1,R0		;Accumulate it				;025
	CMPB	1(R5),#48.	;See if the next char is a digit	;025
	BLT	5604$		;No, too low				;025
	CMPB	1(R5),#57.	;Check high limit			;025
	BGT	5604$		;No, too high				;025
	MUL	#10.,R0		;Shift by ten				;025
	MOV	R1,R0		;Put result in R0			;031
	BR	5602$		;And loop for the next digit		;025
5604$:	CLC			;Clear the error indicator		;031
	BR	572$		;Continue				;025

562$:	CALL	570$		;See what's next			;025
	BCS	62$		;Found a strange character		;025
	SEC			;Say we didn't find a value		;025
	RETURN			;And back to work			;025

570$:	CMPB	(R5),#',	;No value, but another arg?		;025
	BEQ	572$		;Yes					;025
	CMPB	(R5),#')	;No value, but end of list?		;025
	BEQ	572$		;Yes					;025
	TSTB	(R5)		;End of the line?			;025
	BEQ	574$		;Yup					;025
	SEC			;Strange character, set carry		;025
	BR	574$		;Get out				;025
572$:	INC	R5		;Point to next string			;025
574$:	RETURN			;Back to work				;025

60$:	MOV	#ININOI,R2	;Tell them to say /INIT or /NOINIT
	BR	ERROR2		;And we're done				;003
62$:	MOV	#ININO1,R2	;Tell them about valid arguments	;025
	BR	ERROR2		;And we're done				;025

; R2 = Count for device name field
; R3 <> 0 if colon found, 0 if need to add colon
; R4 -> Input buffer

70$:	TST	R2		;Did they say anything at all?
	BEQ	90$		;No, so we'll take the default
	TST	R3		;Do we need to add a colon?
	BNE	80$		;No, not this time
	MOV	R4,R5		;Copy pointer to input buffer
	ADD	R2,R5		;Now point past last character
	MOVB	#':,(R5)	;Insert a colon
	INC	R2		;And say we've got one more character

80$:	CALLX	CLRFQX		;Clear out the FIRQB and XRB
	MOV	#XRB,R5		;R5 -> XRB
	MOV	R2,(R5)+	;Set up length of string
	MOV	R2,(R5)+	;In both places
	MOV	R4,(R5)		;Now set up address of string
	.FSS			;And scan it
	MOVB	@#FIRQB,R2	;R2 = Returned error code
	BNE	ERROR2		;We got an error, so report that	;003
	MOV	#ONLDEV,R2	;Tell them they must specify a device name
	BIT	#^C<F2DEV!F2DEV1!F2DEVL!F2UPRT>,@#XRB+XRBLK ;Did they 	;004
				;specify anything other than a device name?
	BNE	ERROR2		;Yes, so tell them that its not OK	;003
	BIT	#F2DEV1,@#XRB+XRBLK ;Did they specify a device name at all?
	BEQ	ERROR2		;No, so give an error			;003
	MOV	#SAMDEV,R2	;Guess that it is a different type of device
	CMPB	@#XRB+XRMOD,$SAVFLG ;Is this the same type of device?
	BNE	ERROR2		;No, so error				;003
	MOV	#INVCHR,R2	;Guess at invalid characters
	TST	-(R5)		;Is there anything unscannable?
	BNE	ERROR2		;No, all set				;003
	MOV	@#FIRQB+FQDEV,$SAVDEV ;Set up the new save device name
	MOV	@#FIRQB+FQDEVN,$SAVUNT ;And the unit number

90$:	TSTB	$SAVFLG		;Are we doing magtape?
.ASSUME	DSKHND	EQ	0
	BEQ	MNTDSK		;No, disk, go do it			;003
	JMP	MNTTAP		;Yes, so go check it out		;003

; Report the error in R2 and try again

ERROR2:	BIS	#GF.HLD,GENFLG	;Hold this one				;042
	CMESS	R2		;Go and report the error		;003
	JMP	GETDEV		;And try again				;003

GLOBAL	<C$FLAG,NOSRES,ININOI,ONLDEV,SAMDEV,$SAVFLG,INVCHR,$SAVDEV,$SAVUNT> ;003
GLOBAL	<ININO1,INICLU>							;025

; We get here for disk verify save set/initialize

MNTDSK:	BIT	#C2$INT,C$FLG2	;Is this an initialize?
	BEQ	20$		;No, so off to mount the disk		;025

; Here's where we'll initialize disks

	MOV	R3,-(SP)	;Get a scratch reg			;049
	MOV	#BRF$PR!BRF$IB,R3 ;Set PSTAT defaults			;061
	MOV	#DEFLBL,R2	;   along with the default label	;061
	BIT	#DO.IMA,C$FLAG	;Is this an image copy?			;024
	BEQ	5$		;No					;061
	MOV	#$DEFLB,R2	;Yes, use the input disk pack label	;061
	MOV	DSKSTA,R3	; and pack status flags			;061
5$:	TSTB	$SAVLBL		;Did the user specify a label?		;061
	BEQ	10$		;No, use the defaults then		;061
	MOV	#$SAVLBL,R2	;Yes, use what the user specified	;061
10$:	CALB	DSKINT,<R3,#$SAVDEV,$SAVUNT,R2,INICLU>
				;Initialize the disk
	MOV	(SP)+,R3	;Restore scratch reg			;049
	CMPB	R0,#1		;Did the DSKINT succeed?
	BEQ	20$		;Yes, so go and mount the disk
	BIS	#GF.HLD,GENFLG	;Hold this one				;042
	CMESS	#NOTINI		;Tell them the disk isn't initialized
	JMP	GETDEV		;And try to get another one		;003

; Now we'll try to mount the disk

20$:	TST	$SAVUNT		;Is this a public structure request?
	BEQ	50$		;Yes, so don't try to mount it
	CALLX	CLRFQB		;Clear out the FIRQB
	MOVB	#UU.MNT,@#FIRQB+FQFUN ;Function is mount the disk
	MOV	#2000!4000!10000!100000,@#FIRQB+FQMODE
				;Mount - lookup pack ID, noshare, R/W
	BIT	#DO.RES,C$FLAG	;Is this a restore?
	BEQ	30$		;No, so we're set up correctly
	MOV	#2000!4000!20000!100000,@#FIRQB+FQMODE
				;Mount - lookup pack ID, noshare, R/O
30$:	MOV	$SAVDEV,@#FIRQB+FQDEV ;Set the device name
	MOV	$SAVUNT,@#FIRQB+FQDEVN ;And the unit number
	.UUO			;Now go do the mount
	MOVB	@#FIRQB,R2	;Pick up returned error code
	BEQ	40$		;None, so disk is mounted now
	CMPB	R2,#INUSE	;Was disk already mounted?
	BEQ	50$		;Yes, so that's OK, don't do dismount
	BIS	#GF.HLD,GENFLG	;Hold this one				;042
	CMESS	#ERRMNT		;Some other error, give our message
	JMP	ERROR2		;And get out, reporting the RSTS error	;060

40$:	BIS	#GF.OWN,GENFLG	;Indicate disk should be dismounted
50$:	TSTB	$SAVLBL		;Do we need to check save set label?
	BEQ	80$		;No, so nothing to do
	CALLX	CLRFQB		;Clear out the FIRQB
	MOVB	#UU.ATR,@#FIRQB+FQFUN ;Function is read/write attributes
	MOVB	#-4,@#FIRQB+FQFIL ;Subfunction is get pack attributes
	MOV	$SAVDEV,@#FIRQB+FQDEV ;From the save set device
	MOV	$SAVUNT,@#FIRQB+FQDEVN ;And unit number
	.UUO			;Now go for it
	MOVB	@#FIRQB,R2	;R2 = Returned error code
	BEQ	60$		;It worked, great
	BIS	#GF.HLD,GENFLG	;Hold this one				;042
	CMESS	#ERRRSL		;Tell them error reading save set label
	JMP	ERROR2		;Now try again reporting error code	;003

60$:	MOV	#FIRQB+20,R0	;R0 -> Pack label in RAD-50
	MOV	#WORK,R5	;R5 -> Output area
	CALLX	RAD$W2		;Convert this pack label to RAD-50
	MOV	#$SAVLBL+6,R4	;R4 -> Just past save set label
	MOV	#3,R2		;R2 = Count of words to compare
70$:	CMP	-(R4),-(R5)	;Pack labels match?
	BNE	MISSET		;No, not this time			;003
	SOB	R2,70$		;Yes, check more now
80$:	BIT	#C2$INT,C$FLG2	;Did we initialize this disk?		;025
	BEQ	90$		;No, not this time			;025
	CALLX	CLRFQB		;Yes, so clear out the FIRQB
.ASSUME	UU.PAS	EQ	0	;Function is create account
	MOV	$SAVNAM+C$PPN,@#FIRQB+FQNAM1 ;Set up the PPN for save set
	MOV	#FIRQB+FQDEV,R5	;R5 -> FIRQB @ FQDEV
	MOV	$SAVDEV,(R5)+	;Set up device name
	MOV	$SAVUNT,(R5)+	;And the unit number
	MOVB	#16.,(R5)	;Now the largest UFD clustersize we can
	.UUO			;Now create this directory
	MOVB	@#FIRQB,R2	;Pick up returned error code
	BEQ	90$		;None, that's good
	CMPB	R2,#FIEXST	;Already exist?
	BEQ	90$		;Yes, that's OK
	BIS	#GF.HLD,GENFLG	;Hold this one				;042
	CMESS	#ERRCOD		;Error creating output directory
	JMP	ERROR2		;Now report it				;003

90$:	JMP	OPNSET		;Off to the open			;003

; Report a saveset mismatch and try again

MISSET:	BIS	#GF.HLD,GENFLG	;Hold this one				;042
	CMESS	#WRGSET,<#6.,#$SAVLB> ;Indicate this is the wrong save set
	JMP	GETDEV		;And try to get another one		;003

GLOBAL	<$SAVLBL,$SAVDEV,$SAVUNT,NOTINI,C$FLAG,INUSE,ERRMNT,GENFLG>	;003
GLOBAL	<ERRRSL,$SAVNAM,FIEXST,ERRCOD,WRGSET>				;003
GLOBAL	<INICLU>							;021
GLOBAL	<$DEFLB>							;024
GLOBAL	<C$FLG2>							;025

; We get here for tape verify save set/density/initialize
;

MNTTAP:	CALLX	CLRFQB		;Clear out the FIRQB			;003
	MOVB	#UU.ASS,@#FIRQB+FQFUN ;Function code is assign
	MOV	#^RANS,@#FIRQB+FQEXT ;Using ANSI mode
	MOV	$SAVDEV,@#FIRQB+FQDEV ;Set up the device name
	MOV	$SAVUNT,@#FIRQB+FQDEVN ;And unit number
	.UUO			;Now assign the tape
	MOVB	@#FIRQB,R2	;Pick up error code
	BEQ	10$		;It worked, now we can do other stuff
	BIS	#GF.HLD,GENFLG	;Hold this one				;042
	CMESS	#ERRASS		;Tell them error assigning device
	JMP	ERROR2		;And exit reporting the error		;003

10$:	TSTB	@#FIRQB+FQFIL	;Did we own it already?
	BNE	20$		;Yes, so don't do a deassign
	BIS	#GF.OWN,GENFLG	;We didn't own it, deassign it when done

20$:	CALLX	CLRFQB		;Clear out the FIRQB
	MOVB	#OPNFQ,@#FIRQB+FQFUN ;Function is open
	MOVB	#SAVFIL,@#FIRQB+FQFIL ;On the save set channel
	MOV	$SAVDEV,@#FIRQB+FQDEV ;Set the device name
	MOV	$SAVUNT,@#FIRQB+FQDEVN ;And unit number
	CALFIP			;Now go for it
	MOVB	@#FIRQB,R2	;Pick up error code
	BEQ	30$		;It worked, that's good
	CALL	CLSDEA		;Go and close the save set
	BIS	#GF.HLD,GENFLG	;Hold this one				;042
	CMESS	#ERRNFS		;Tell them error opening NFS
	JMP	ERROR2		;And exit reporting the error		;003

; At this point, we are here to either set density, verify save
; set label, rewind the tape, or look for the ANSI portion of a DOS/ANSI tape.

30$:	CMP	BBHDAT+BBH$VL,#1 ;Is this volume one?			;004
	BNE	35$		;No, always rewind			;004
	BIT	#C2$INT,C$FLG2	;Are we here to do an initialize?	;027
	BNE	35$		;Yes, rewind the tape			;008
	BIT	#DO.REW,C$FLAG	;Need to rewind the tape?		;003
	BEQ	40$		;No, not this time			;003
35$:	BIC	#DO.REW,C$FLAG	;Clear rewind flag for goodness		;004
	CALLX	CLRXRB		;Clear out the XRB			;003
	MOV	#2,@#XRB	;Function is rewind			;003
	MOV	#SAVFIL+<400*MTAHND>,@#XRB+XRCI ;Set channel number/handler ;003
	.SPEC			;Now go for it				;003
	MOVB	@#FIRQB,R2	;Pick up error code			;003
	BEQ	40$		;It worked, that's good			;003
	BIS	#GF.HLD,GENFLG	;Hold this one				;042
	CMESS	<#ERRRWS>	;Tell them error rewinding save set	;003
	CMESS	R2		;Tell them why				;003
	CALL	CLSDEA		;Go and close the save set		;003
	JMP	GETDEV		;Now get out				;003

40$:	CALLX	CLRXRB		;Clear out the XRB			;003
	MOV	#XRB,R2		;R2 -> XRB				;006
	MOV	#13,(R2)+	;Function is extended set density	;006
	MOV	$DEN,(R2)	;Set the requested density		;006
	BIC	#100000,(R2)	;Indicate we shouldn't set it		;006
	MOV	#SAVFIL+<400*MTAHND>,@#XRB+XRCI ;Set channel number/handler ;006
	.SPEC			;Now get it...				;006
	CMPB	#HNGDEV,@#FIRQB	;Did we get an error from a rewind?	;006
	BEQ	30$		;Yes, so try it again			;006
	CRASH			;Die on other errors			;006
	MOV	#13,@#XRB	;Function is extended set density	;006
	BIS	#100000,(R2)	;And set the change requested flag	;005
	MOV	#SAVFIL+<400*MTAHND>,@#XRB+XRCI ;Set channel number/handler 
	.SPEC			;Now set it...
	CMPB	#NOTMTA,@#FIRQB	;Are we not at BOT?			;006
	BEQ	50$		;Yes, that's OK				;006
	CRASH			;Die on any other errors
50$:	CALLX	CLRXRB		;Clear out the XRB			;006
	MOV	#13,@#XRB	;Function is extended set density	;006
	MOV	#SAVFIL+<400*MTAHND>,@#XRB+XRCI ;Set channel number/handler ;006
	.SPEC			;Now get it...				;006
	CRASH			;This better work!			;006
	MOV	(R2),R3		;Pick up actual density			;005
	TST	$DEN		;Was it minimum or maximum?		;005
	BMI	70$		;Yes, so never a message		;005
	CMP	R3,$DEN		;Did we get the density they requested?
	BEQ	80$		;Yes, that's nice
	BIS	#GF.HLD,GENFLG	;Hold this one				;042
	CMESS	#DENNAV,<$DEN,R3> ;Report density not available
70$:	MOV	R3,$DEN		;Now set the density for the next save set

80$:	BIT	#C2$INT,C$FLG2	;Are we here to do an initialize?	;027
	BEQ	90$		;No, not this time
	JMP	190$		;Yes, so go for it

90$:	TSTB	$SAVLBL		;Are we here to check the save set label?
	BEQ	92$		;No					;060
	JMP	120$		;Yes, so go for it			;060

92$:	BIT	#DO.RES,C$FLAG	;Is this a restore?			;060
	BEQ	110$		;No, so no ANSI locating
	CALLX	CLRXRB		;Clear out the XRB
	MOV	#6,@#XRB	;Fuction is get tape status
	MOV	#SAVFIL+<400*MTAHND>,@#XRB+XRCI ;Set channel number/handler
	.SPEC			;Now pick up the tape status
	CRASH			;And die on errors
	MOV	#2400,R1	;We are checking for write locked @ BOT
	BIC	@#XRB+2,R1	;Is this write locked at BOT?
	BNE	110$		;No, don't go look for an ANSI label
	CALLX	CLRXRB		;Clear out the XRB
.ASSUME	TTYLEN	GE	14.
	MOV	#TTYBUF,R3	;R3 -> I/O buffer to use
	MOV	#XRB,R1		;R1 -> XRB
	MOV	#14.,(R1)+	;We want to read 14. bytes
	CLR	(R1)+		;Skip the returned count
	MOV	R3,(R1)+	;Use the terminal I/O buffer
	MOVB	#SAVFIL,(R1)	;Read from the save set channel
	.READ			;Now go for it
	MOVB	@#FIRQB,R2	;Pick up returned error code
	BEQ	95$		;None, good				;006
	CMPB	R2,#MAGRLE	;Is this an extended DOS tape?		;006
	BNE	110$		;No, so no DOS.EOT checking		;006
95$:	CMP	@#XRB+XRBC,#14.	;Did we read a DOS label?		;006
	BNE	110$		;Not if it isn't at least 14 bytes long
	CMP	TTYBUF+2,#^ROOT	;Is this a ???OOT file?
	BNE	110$		;No, so not bootable
	CMP	TTYBUF+4,#^RSYS	;Yes, but is it .SYS
	BNE	110$		;No, don't search for the ANSI part

; This is where we will search for the end of the DOS tape

100$:	CALL	CLSSET		;Close the save set
	CALLX	CLRFQB		;Clear out the FIRQB
	MOV	#FIRQB+FQFUN,R1	;R1 -> FIRQB @ FQFUN
	MOVB	#OPNFQ,(R1)+	;Function is open
	MOV	#SAVFIL,(R1)+	;On the save set channel
	MOV	(PC)+,(R1)+	;Set PPN to be
	 .BYTE	2,1		; [1,2]
	MOV	#^RDOS,(R1)+	;File name is DOS
	CLR	(R1)+		;
	MOV	#^REOT,(R1)+	; .EOT
	MOV	#40!40000!100000,@#FIRQB+FQMODE ;Mode is: rewind, find DOS
	MOV	$SAVDEV,@#FIRQB+FQDEV ;Set the device name
	MOV	$SAVUNT,@#FIRQB+FQDEVN ;And unit number
	CALFIP			;Now go for it
	MOVB	@#FIRQB,R1	;Pick up error code
	BEQ	110$		;It worked, great!
	BIS	#GF.HLD,GENFLG	;Hold this one				;042
	CMESS	#ERRSDS		;Tell them error searching for DOS portion
	CMESS	R1		;Be specific
	CALL	DEASET		;Deassign this device
	JMP	GETDEV		;And try again				;003

110$:	CALL	CLSSET		;Go and close the channel
	JMP	OPNSET		;And go off to open the ANSI file	;003

120$:	CALLX	CLRXRB		;Clear out the XRB
	MOV	#XRB,R1		;R1 -> XRB
	MOV	#2,(R1)+	;Function is rewind
	MOV	#SAVFIL+<400*MTAHND>,@#XRB+XRCI ;Set channel number/handler
	.SPEC			;Now go for it
	MOVB	@#FIRQB,R2	;Pick up error code
	BEQ	140$		;It worked, that's good
	BIS	#GF.HLD,GENFLG	;Hold this one				;042
	CMESS	<#ERRRWS>	;Tell them error rewinding save set
130$:	CMESS	R2		;Tell them why
	CALL	CLSDEA		;Go and close the save set
	JMP	GETDEV		;Now get out				;003

140$:	CALLX	CLRXRB		;Clear out the XRB
.ASSUME	TTYLEN	GE	80.
	MOV	#TTYBUF,R3	;R3 -> I/O buffer to use
	MOV	#XRB,R1		;R1 -> XRB
	MOV	#80.,(R1)+	;We want to read 80. bytes
	CLR	(R1)+		;Skip the returned count
	MOV	R3,(R1)+	;Use the terminal I/O buffer
	MOVB	#SAVFIL,(R1)	;Read from the save set channel
	.READ			;Now go for it
	MOVB	@#FIRQB,R2	;Pick up returned error code
	BEQ	150$		;It worked, that's good
	BIS	#GF.HLD,GENFLG	;Hold this one				;042
	CMESS	<#ERRRSL>	;Tell them error reading save set label
	BR	130$		;Now exit, closing set and reporting error

150$:	MOV	@#XRB+XRBC,R4	;Save the count returned
	CALL	CLSSET		;And close the save set
	CMP	R4,#80.		;Did we get something valid?
	BNE	180$		;No, not an ANSI label
	CMP	(R3)+,#"VO	;Does this begin with "VO"?
	BNE	180$		;No, not an ANSI label
	CMP	(R3)+,#"L1	;And have a "L1"?
	BNE	180$		;No, not an ANSI label
	MOV	#$SAVLB,R2	;R2 -> Saveset label
	MOV	#3,R4		;R4 = Count of words to check
160$:	CMP	(R2)+,(R3)+	;Do they match?
	BNE	170$		;No, so report the mismatch
	SOB	R4,160$		;Yes, loop for the whole label	
	JMP	OPNSET		;Save sets match, now join up

170$:	JMP	MISSET		;Off to report the mismatch		;003

180$:	MOV	#NOTANS,R2	;Indicate this isn't an ANSI label
	JMP	ERROR2		;And exit reporting the error		;003

190$:	CALL	CLSSET		;Close the save set
	CALLX	CLRFQX		;Clear out the FIRQB and XRB
	TSTB	$SAVLB		;Did they specify a saveset label
	BNE	200$		;Yes, so use it
	MOV	#^RBAC,@#FIRQB+FQNAM1 ;No, so set "BAC"
	MOV	#^RKUP,@#FIRQB+FQNAM1+2 ; "KUP"
	BR	210$		;And join up

200$:	MOV	#XRB,R1		;R1 -> XRB
	MOV	#6.,(R1)	;Set up byte count
	MOV	(R1)+,(R1)+	;In both places
	MOV	#$SAVLB,(R1)	;Now set up save set label name
	.FSS			;And convert it to RAD-50
	CRASH			;This .FSS can't fail

210$:	MOVB	#UU.ZER,@#FIRQB+FQFUN ;Function code is zero
	MOV	$SAVDEV,@#FIRQB+FQDEV ;Set up device name
	MOV	$SAVUNT,@#FIRQB+FQDEVN ;And unit number
	.UUO			;Now zero the tape in ANSI mode
	MOVB	@#FIRQB,R2	;Pick up any error code
	BEQ	OPNSET		;None, that's good			;003
	BIS	#GF.HLD,GENFLG	;Hold this one				;042
	CMESS	<#ERRINI>	;Tell them error doing the /INITIALIZE
	JMP	ERROR2		;Now report the RSTS code, and try again ;003

GLOBAL	<$DEN,MAGRLE,NOTMTA>						;005

; At this point, we will open the save set

OPNSET:	BIT	#DO.IMA,C$FLAG	;Image mode?				;019
	BEQ	5$		;No, continue				;019
	JMP	SETVOL		;Yes, no save set to open		;019
5$:	MOV	#1,R5		;Guess at wanting occurance number one?	;003
	BIT	#DO.RES,C$FLAG	;Is this a restore?
	BEQ	10$		;No, not this time, guess was correct
	CMP	BBHDAT+BBH$VL,#1 ;Is this the first volume?
	BNE	50$		;No, so we want occurance number one	;003
	MOV	$OCCUR,R5	;Now we have the occurance number
	BR	50$		;And join up				;003

; Calculate the clustersize for disk save sets

10$:	TSTB	$SAVFLG		;Is this a disk save set?		;003
.ASSUME	DSKHND	EQ	0
	BNE	50$		;No, not this time			;003
	CALLX	CLRFQB		;Yes, so clear out the FIRQB		;003
	MOVB	#UU.ATR,@#FIRQB+FQFUN ;Function is attribute read/write	;003
	MOVB	#-4,@#FIRQB+FQFIL ;Subfunction is read pack attributes	;003
	MOV	$SAVDEV,@#FIRQB+FQDEV ;Set up save set device		;003
	MOV	$SAVUNT,@#FIRQB+FQDEVN ;And unit number/real flag	;003
	.UUO			;Now read them				;003
	MOVB	@#FIRQB,R2	;Pick up any error code			;003
	BEQ	20$		;None, good				;003
	BIS	#GF.HLD,GENFLG	;Hold this one				;042
	CMESS	#ERRRSL		;Report error reading save set label	;003
	JMP	ERROR2		;And get out				;003

20$:	MOV	@#FIRQB+34,R3	;R3 = Free space on disk in DCNs	;004
	MOVB	@#FIRQB+26,R2	;R2 = Device cluster size of disk	;004
	CLR	R4		;R4 will hold the shift count		;004
25$:	ASR	R2		;Shift a bit of clustersize		;004
	BEQ	28$		;Done, we have the shift count now	;004
	INC	R4		;Say another left shift is needed	;004
	BR	25$		;And loop				;004

28$:	CLR	PRXSIZ		;Assume no pre-extending to be done	;021
	CMPB	@#FIRQB+26,#1	;DCN=1 on this disk?			;021
	BNE	29$		;No, big disk, no pre-extend		;021
	CMP	@#FIRQB+24,#3000. ;One of those small slow ones?	;021
	BHI	29$		;No, no point in pre-extending then	;021
	MOV	@#FIRQB+24,PRXSIZ ;Looks pretty small, pre-extend	;021
29$:	;CLR	R2		;Clear MSB for shift			;021
	ASHC	R4,R2		;Now get blocks in <R2,R3>		;004
	DIV	#1000.,R2	;Now get free space / 1000		;012
	BVS	40$		;Too big, use 256.			;003
	MOV	#1,R4		;Guess at clustersize = 1		;003
	TST	R3		;Is there a remainder?			;003
	BEQ	30$		;No, not this time			;003
	INC	R2		;Yes, so round up			;003
30$:	CMP	R4,R2		;Have we found the right clustersize?	;003
	BHIS	50$		;Yes, all set				;003
	ASLB	R4		;No, try the next higher clustersize	;003
	BCC	30$		;Not 256. yet, try again		;003
40$:	MOV	#256.,R4	;Set up clustersize of 256.		;003
50$:	NEG	R4		;Get the -(clustersize)			;003

; At this point, R4 = -(clustersize to use)

60$:	CALLX	CLRFQX		;Clear out the FIRQB and the XRB	;003
	MOV	#XRB,R1		;R1 -> XRB
	MOV	#10.,(R1)	;Set up byte count
	MOV	(R1)+,(R1)+	;In both places
	MOV	#$SAVNAM+C$NAME,(R1) ;Now set up pointer to file name
	.FSS			;Convert it to RAD-50
	CRASH			;This .FSS can't fail!
	MOV	#FIRQB+FQFUN,R1	;R1 -> FIRQB @ FQFUN
	MOVB	#CREFQ,(R1)	;Guess that we need to create this file
	BIT	#DO.RES,C$FLAG	;Is this a restore?
	BEQ	70$		;No, this is backup, we guessed correctly
	MOVB	#OPNFQ,(R1)	;Set up function code for a restore
70$:	INC	R1		;Advance to FQFIL
	MOV	#SAVFIL,(R1)+	;Set up channel number for save set
	MOV	$SAVNAM,(R1)+	;Set up PPN of save set
	MOV	#FIRQB+FQDEV,R1	;R1 -> FIRQB @ FQDEV
	MOV	$SAVDEV,(R1)+	;Set up device of save set
	MOV	$SAVUNT,(R1)+	;Now set up unit number
	MOV	#FIRQB+FQMODE,R2 ;R2 -> FIRQB @ FQMODE
	TSTB	$SAVFLG		;Is the save set on disk?
.ASSUME	DSKHND	EQ	0
	BNE	80$		;No, so set up the magtape open modes
	MOV	#120000,(R2)	;Restore, guess at a read-only open
	BIT	#DO.RES,C$FLAG	;Is this a restore?
	BNE	90$		;Yes, so our guess is correct
	MOV	#100040,(R2)	;Backup, make sure we open the file tentative
	MOV	R4,@#FIRQB+FQCLUS ;Set the -(calculated clustersize)	;003
	MOV	BLKSIZ,R3	;Pick up the blocksize
	ASH	#-9.,R3		;Now R3 has number of blocks per saveset block
	BIC	#177600,R3	;Clear out the sign extend		;039
	MOV	R3,@#FIRQB+FQSIZ ;Be sure the file is at least that large
	BR	90$		;Now join up

80$:	MOV	#162002,(R2)	;ANSI file, no rewind, large records	;018
	BIT	#DO.REW,C$FLAG	;Did our rewind ever get done?		;004
	BEQ	85$		;Yes, or they didn't ask for one	;004
	MOV	#162040,(R2)	;Yes, so set up for that rewind now	;018
	BIC	#DO.REW,C$FLAG	;And clear out the flag for goodness	;004
85$:	BIT	#DO.RES,C$FLAG	;Do we need to specify attributes?	;004
	BNE	90$		;No, this is a restore, we've got them
	MOV	#40000,(R1)	;Format of tape is "Fixed" and large recordsize
	MOV	BLKSIZ,@#FIRQB+FQSIZ ;And give the (large) blocksize value
	MOV	BBHDAT+BBH$VL,@#FIRQB+FQNENT ;Set the volume number to write
90$:	CALFIP			;Now create/open the save set	
	CALL	BUFWAT,R5	;Out of small buffers?			;003
	 BR	60$		;Yes, try again...			;003
	MOVB	@#FIRQB,R2	;Pick up returned error code
	BEQ	100$		;None, that's good
	BIS	#GF.HLD,GENFLG	;Hold this one				;042
	CMESS	#ERROPS		;Tell them about the error
	JMP	ERROR2		;And try again telling specific error code ;003

100$:	DEC	R5		;Say one more occurance went by
	BEQ	110$		;This is the last one
	CALL	CLSSET		;This isn't correct; go close this set
	JMP	10$		;And try again				;003

110$:	BIT	#DO.RES,C$FLAG	;Is this a restore?
	BNE	120$		;Yes, so off to more restore checking
	TSTB	$SAVFLG		;Disk?					;021
	BNE	117$		;No					;021
.ASSUME	DSKHND	EQ	0						;021
	CALLX	CLRXRB		;Clear out XRB for pre-extend		;021
	MOV	PRXSIZ,@#XRB+XRBLK ;Set size to extend to		;021
	BEQ	117$		;Oh, nothing to do, skip		;021
	MOVB	#SAVFIL,@#XRB+XRCI ;Set channel number * 2		;021
	MOV	#1000,@#XRB+XRLEN ;Set byte count			;021
	MOV	#1000,@#XRB+XRBC  ; in the usual places			;021
	.WRITE			;Do the write, it's bound to fail	;021
	CALLX	CLRFQB		;Clear out the FIRQB			;021
	MOV	#FIRQB+FQFUN,R1	;R1 -> FIRQB @ FQFUN			;021
	MOVB	#UU.FCB,(R1)+	;Function is get FCB information	;021
	MOV	(PC)+,(R1)+	;On the:				;021
	.BYTE	SAVFIL/2,1	; Save set channel, getting FCB information ;021
	.UUO			;Now go for it				;021
	CRASH			;And die on errors			;021
	MOV	2(R1),PRXSIZ	;Set the actual LSB size we obtained	;021
117$:	JMP	SETVOL		;No, not this time			;021

120$:	TSTB	$SAVFLG		;Is this from disk?
.ASSUME	DSKHND	EQ	0
	BEQ	130$		;Yes, so we'll need to read attributes
	MOV	@#FIRQB+FQBUFL,R2 ;Tape, get the block size
	MOV	@#FIRQB+FQSIZ,R4 ;Pick up volume number
	JMP	180$		;Now join up

130$:	CALLX	CLRFQB		;Clear out the FIRQB
	MOV	#FIRQB+FQFUN,R1	;R1 -> FIRQB @ FQFUN
	MOVB	#UU.ATR,(R1)+	;Function code is read attributes
	MOV	#SAVFIL/2,(R1)+	;On the save set channel
	.UUO			;Now read the attributes
	MOV	@#FIRQB,R2	;Pick up returned error code
	BEQ	150$		;None, that's good
	BIS	#GF.HLD,GENFLG	;Hold this one				;042
	CMESS	#ERRSAT		;Tell them error reading save set attributes
	CMESS	R2		;Tell them the error code
140$:	TSTB	$SAVFLG		;Is this a disk backup?			;003
.ASSUME	DSKHND	EQ	0
	BEQ	145$		;Yes, sure is				;003
	CALLX	CLRXRB		;No, clear out the XRB			;003
	MOV	#10,@#XRB	;Function is rewind on close		;003
	MOV	#SAVFIL+<400*MTAHND>,@#XRB+XRCI ;Set channel number/handler ;003
	.SPEC			;Now go for it				;003
	CRASH			;This better work!			;003
145$:	CALL	CLSDEA		;Close the save set			;003
	JMP	GETDEV		;Now try again				;003

150$:	CMPB	(R1)+,#1	;Is this a fixed length sequential file?
	BNE	169$		;No, so we can't use it			;010
	INC	R1		;Advance to record size
	MOV	(R1)+,R2	;Pick up the record size
	BIT	#777,R2		;Can we use it?
	BNE	169$		;No, this won't do			;010
	CMP	(R1)+,(R1)+	;Advance to used portion of attributes
	MOV	(R1)+,SAVSZM	;Save MSB of save set size
	MOV	(R1)+,SAVSZL	;And LSB of save set size
	TST	(R1)		;Did the whole last block get used?
	BEQ	160$		;Yes, this save set passes the tests
	CMP	(R1),#1000	;Maybe, did it get used?
	BNE	169$		;No, so we can't use this		;010
	ADD	#1,SAVSZL	;Yes, so update size LSB
	ADC	SAVSZM		;And size MSB	

; The code below picks up the volume number from the save set
;
; R2 = Block size of save set

160$:	CALLX	CLRXRB		;Clear out the XRB
	MOV	#XRB,R1		;R1 -> XRB
	MOV	#BBH$VL+2,(R1)+	;Set up to read up to the volume number
.ASSUME	BBH$VL	LE	TTYLEN
	CLR	(R1)+		;Clear the returned count
	MOV	#TTYBUF,(R1)+	;Use the terminal I/O buffer
	MOVB	#SAVFIL,(R1)	;Read from the save set channel
	.READ			;Now go for it
	MOVB	@#FIRQB,R1	;Pick up returned error code
	BEQ	170$		;None, that's good
	BIS	#GF.HLD,GENFLG	;Hold this one				;042
	CMESS	#ERRRSL		;Tell them error looking up volume number
	CMESS	R1		;Be specific
165$:	BR	140$		;And get out, closing this save set	;003

169$:	JMP	260$		;Cant' reach it from above		;010

170$:	MOV	TTYBUF+BBH$VL,R4 ;R4 = Volume number mounted

; At this point, we will check to see if this is the correct volume
; and if the block size is correct.
;
; R2 = Block size
; R4 = Volume number

180$:	CMP	R4,BBHDAT+BBH$VL ;Is this the correct volume?
	BEQ	240$		;Yes, it sure is
	BIT	#DO.INS,C$FLAG	;No, installation?			;010
	BEQ	190$		;No					;010
	BIS	#GF.HLD,GENFLG	;Hold this one				;042
	CMESS	#WRGVL2		;Yes, give message			;010
	BR	165$		;Re-prompt				;010

190$:	MOV	#TTYBUF,CTYBUF	;Get the TTY buffer address		;042
	ADD	HLDOFF,CTYBUF	;Add in the offset			;042
	MOV	#TTYLEN,CTYLEN	;Get the TTY buffer length		;042
	SUB	HLDOFF,CTYLEN	;Subtract the offset			;042
	$FAO	#WRGVOL,#OUTLEN,CTYLEN,CTYBUF ; Format text		;042
	CALL	PRTINP		;Print and get input			;030
	BCC	210$		;No error, that's good
	CMPB	R0,#EOF		;Did they hit ^Z	
	BNE	200$		;No, report the error
	JMPX	RESTRT		;Yes, get out
200$:	CMESS	R0		;Report the error code			;001
	BR	190$		;And try again

210$:	TSTB	(R5)		;Do we have anything at all?
	BEQ	165$		;No, so that means no			;010
	CALLX	GETUNQ,R0,CHKSTR ;Scan for string
	BCC	220$		;Not found, tell them to say yes or no
	TSTB	(R5)		;Found, but was there extra junk?
	BEQ	230$		;No, not this time
220$:	CMESS	#YESNO		;Tell them to say yes or no
	BR	190$		;And try again
	
230$:	TST	R1		;Is it "YES"?
	BNE	165$		;No, so forget this			;003
	MOV	R4,BBHDAT+BBH$VL ;Set the current volume to what they mounted

; Now we will verify that the block size is correct
;
; R2 = Block size

240$:	CMP	R2,#2048.	;Is the block size too small?
	BLO	260$		;Yes, so forget it
	CMP	R2,HBKSIZ	;Is the block size of this save set too large? ;039
	BHI	260$		;Yes, forget it
	BIT	#17,R2		;Is the blocksize a multiple of 16?
	BNE	260$		;No, forget it
	TST	BLKSIZ		;Is this the first volume?
	BNE	250$		;No, not this time
	MOV	R2,BLKSIZ	;Yes, so set up the blocksize
	CALLX	INIBUF		;Init the dynamic region if needed	;017
250$:	CMP	BLKSIZ,R2	;Is this the correct block size?
	BEQ	SETVOL		;Yes, this save set passes		;003

260$:	CMESS	#INVSAT		;Tell them invalid save set attributes
	JMP	140$		;And close the file and try again

; All done, set up the correct volume and exit

SETVOL:	MOV	BBHDAT+BBH$VL,CURVOL ;Set the current volume number	;003
	RETURN			;Now we're done with this mount		;003

GLOBAL	<BLKSIZ>
GLOBAL	<ONLDEV,SAMDEV,INVCHR,ININOI,C$FLAG,ERROPS,NOSRES,ERRASS,$SAVLB>
GLOBAL	<ERRINI,SAVSZM,SAVSZL,INVSAT,ERRSAT,CURVOL,DENNAV,ERRNFS>	;005
GLOBAL	<ERRRSL,WRGSET,ERRRWS,NOTANS,GENFLG,NOTINI,$OCCUR,INUSE,ERRMNT>
GLOBAL	<C$FLG2,ERRSDS,ERRCOD,FIEXST,HNGDEV,WRGVL2>			;010
GLOBAL	<HBKSIZ>							;039

.SBTTL	Close the current save set

;+
; CLSDEA - Close and deassign the save set
; CLSSET - Close the current save set
;
;	CALL	CLSSET
;
;	R1 = Returned error code
; 
; Note: If there is an error, we'll report it to the user, along with the
; RSTS error code.
;-

CLSDEA:	MOV	#DEASET,-(SP)	;Exit deassigning the save set
CLSSET:	CALLX	CLRFQB		;Clear out the FIRQB
.ASSUME	CLSFQ	EQ	0	;Function is close
	MOVB	#SAVFIL,@#FIRQB+FQFIL ;On the save set channel
	CALFIP			;Now close the file
	MOVB	@#FIRQB,R1	;Pick up error code
	BEQ	10$		;None, that's good
	CMESS	#ERRCSA		;Tell them error closing save set
	CMESS	R1		;Tell them the RSTS error code
10$:	RETURN			;Now we're done

GLOBAL	<ERRCSA>

.SBTTL	Dismount a save set

;+
; DISMNT - Dismount a save set
;
;	CALL	DISMNT
;
; And it happens.
;
;	All registers are preserved.
;-

DISMNT::SAVREG			;Save all registers
	TSTB	$SAVFLG		;Is this a tape backup?
.ASSUME	DSKHND	EQ	0
	BEQ	2$		;No					;060
	JMP	10$		;Yes, then we don't have to write attributes;060

2$:	BIT	#DO.RES,C$FLAG	;Is this a restore?			;060
	BNE	10$		;Yes, then we don't write attributes
	TST	PRXSIZ		;Pre-extended backupset?		;021
	BEQ	8$		;No					;021
	TSTB	SAVSZM		;Did we get way beyond that point?	;021
	BNE	8$		;Yes, no truncate needed		;021
	CMP	SAVSZL,PRXSIZ	;Did we write past extend point?	;021
	BHIS	8$		;Yes, skip truncate			;021
	CALLX	CLRXRB		;Clear out the XRB first		;021
	MOVB	#SAVFIL,@#XRB+XRCI ;Set channel number			;021
	MOV	SAVSZL,@#XRB+FQJOB ;Set LSB size (don't ask me, I didn't ;021
				; invent that absurd offset!)		;021
	DEC	@#XRB+FQJOB	;SAVSZL is actually size + 1, so fix it	;021
	MOV	#5,@#XRB	;Function = truncate			;021
	.SPEC			; and do it				;021
	CRASH			;It ought to work!			;021
8$:	CALLX	CLRFQB		;Clear out the FIRQB			;021
	MOV	#FIRQB+FQFUN,R1	;R1 -> FIRQB @ FQFUN
	MOVB	#UU.FCB,(R1)+	;Function is get FCB information
	MOV	(PC)+,(R1)+	;On the:
	.BYTE	SAVFIL/2,1	; Save set channel, getting FCB information
	.UUO			;Now go for it
	CRASH			;And die on errors
	INC	R1		;Advance to file size MSB
	CLR	R3		;Get ready for file size MSB
	BISB	(R1)+,R3	;Pick up file size MSB
	MOV	(R1)+,R4	;Now get file size LSB
	ADD	#1,R4		;Make it size + 1
	ADC	R3		;Double precision	
	CALLX	CLRFQB		;Clear out the FIRQB
	MOV	#FIRQB+FQFUN,R1	;R1 -> FIRQB @ FQFUN
	MOVB	#UU.ATR,(R1)+	;Function code is write attributes
	MOV	(PC)+,(R1)+	;We want to:
	.BYTE	SAVFIL/2,9.	; Write on the save set channel 9 words
	MOV	(PC)+,(R1)+	;Record format is:
	.BYTE	1,0		; Fixed
	MOV	BLKSIZ,(R1)+	;Set up the block size
	MOV	R3,(R1)+	;Set up MSB of file size
	MOV	R4,(R1)+	;And LSB of file size
	MOV	SAVSZM,(R1)+	;Set up MSB of file used		;007
	MOV	SAVSZL,(R1)+	;And LSB of file used			;007
	CMP	(R1)+,(R1)+	;Now offset to the maximum record size
	MOV	BLKSIZ,(R1)	;And save the maximum record size
	.UUO			;Now write the attributes
	MOVB	@#FIRQB,R1	;Pick up returned error code
	BEQ	10$		;No error, that's good
	CMESS	#ERRWSA		;Tell them error writing save set attributes
	CMESS	R1		;Now tell them what RSTS told us
10$:	CALL	CLSSET		;Go close the save set
	RETURN			;Now we're done

GLOBAL	<$SAVFLG,BLKSIZ,ERRWSA,SAVSZL,SAVSZM>				;007


.SBTTL	Unload a save set

;+
; UNLOAD - Unload a save set
; UNLODL - Unload the last volume in the BACKUP/RESTORE
;
;	CALL	UNLOAD
;	CALL	UNLODL
;
; And it happens.
;
; The unload subroutine is used to explicitly unload a volume (as opposed
; to DISMNT, which closes the save set, writing any attributes.)
;
; UNLOAD is used by the mount code before mounting a new volume.
; The reason that UNLOAD is seperate from DISMNT is so that a DISMNT
; followed by a MOUNT of the same volume won't cause the user to get
; a dismount message followed by a mount message. In addition, UNLOAD
; releases device ownership, and DISMNT doesn't.
;-

.ENABL	LSB

UNLODL::SAVREG			;Save all registers
	MOV	#2,R2		;Guess at rewind magtape		;003
	BIT	#C2$ERW!C2$EDM,C$FLG2 ;Do we have anything to do at the end? ;003
	BNE	4$		;Yes, so don't get out			;059
	JMP	40$		;No, so get out				;059

4$:	BMI	6$		;Yes, we have to do a rewind		;003
.ASSUME	C2$ERW	EQ	100000						;003
	MOV	#DEASET,-(SP)	;Dismount, so set up for deassign on exit ;003
	BR	5$		;And go check for rewinding the tape	;003

UNLOAD:	SAVREG			;Save all registers
	MOV	#DEAUNC,-(SP)	;Set up for an unconditional dismount
5$:	CLR	R2		;Set up function code for rewind/offline ;003
	TSTB	$SAVFLG		;Is this a tape backup?			;003
.ASSUME	DSKHND	EQ	0
	BEQ	30$		;No, disk, don't try to rewind it...
6$:	CALLX	CLRFQB		;Clear out the FIRQB			;003
	MOVB	#OPNFQ,@#FIRQB+FQFUN ;Function code is open
	MOVB	#SAVFIL,@#FIRQB+FQFIL ;On the save set channel
	MOV	$SAVDEV,@#FIRQB+FQDEV ;Set up save set name
	MOV	$SAVUNT,@#FIRQB+FQDEVN ;And unit number/real flag
	CALFIP			;Now go do the open
	MOVB	@#FIRQB,R1	;R1 = Returned error code
	BEQ	10$		;None, that's good
	CMESS	#ERRNFS		;Tell them error opening save set NFS
	CMESS	R1		;And be specific
	BR	30$		;Now join up

10$:	CALLX	CLRXRB		;Clear out the XRB
	MOV	R2,@#XRB	;Set function (rewind or rewind/offline) ;003
	BR	12$		;Branch around the test patch		;055

;**PATCH** Suppress tape dismounts for regression test 			;055
	..NDIS	==	.-2	;Set ..NDIS to NOP to activate patch	;055
	MOV	#2,@#XRB	;					;039

12$:	MOV	#SAVFIL+<400*MTAHND>,@#XRB+XRCI ;Set channel number/handler
	.SPEC			;Now do the rewind/offline
	MOVB	@#FIRQB,R1	;Pick up returned error code
	BEQ	20$		;None, that's good
	CMESS	#ERRRWS		;Tell them error rewinding save set	
	CMESS	R1		;Now be specific

20$:	CALL	CLSSET		;Go and close the save set

30$:	BIT	#DO.INS,C$FLAG	;Installation?				;010
	BNE	35$		;Yes					;010
	BIT	#DO.IMA,C$FLAG	;Image/Copy?				;023
	BNE	38$		;Yes					;023
	CMESS	#PLSDSM,<CURVOL,#10.,#$SAVNAM+C$NAME>
				;Tell them to dismount this save set
	BR	40$		;And join up				;002

35$:	CMESS	#CRLF		;Skip a line				;010
	CMESS	#PLSDSX		;Tell them the short message		;010
	BR	40$		;And join up				;023

38$:	CMESS	#PLSDSI		;Tell them to dismount image volume	;023

40$:	CLR	CURVOL		;Indicate we don't have a current volume
	MOV	#1,STATS	;Exit status = success			;037
	RETURN			;Now we're done

.DSABL	LSB

GLOBAL	<CURVOL,PLSDSM,ERRRWS,ERRNFS,$SAVFLG,$SAVDEV,$SAVUNT,C$FLAG,C$FLG2>
GLOBAL	<$SAVNAM,PLSDSX,PLSDSI,CRLF>					;023

.SBTTL	Deassign our save set

;+
; DEASET - Deassign/dismount our save set
; DEAUNC - Deassign/dismount our save set, even if we didn't assign it
;
;	$SAVDEV = Device name of save set
;	$SAVUNT = Unit number of save set
;	GENFLG = Save set ownership flags
;
;	CALL	DEASET
;
;	All registers are preserved.
;
; This routine is used to deassign/dismount a save set. We will deassign the
; save set only if we didn't own it to begin with.
;-

.ENABL	LSB

DEASET:	BIT	#GF.OWN,GENFLG	;Do we need to deassign this device?
	BEQ	10$		;No, not this time
DEAUNC:	MOV	R2,-(SP)	;Get a work register
	CALLX	CLRFQB		;Clear out the FIRQB
	MOVB	#UU.DEA,@#FIRQB+FQFUN ;Guess at doing a deassign
	MOV	$SAVDEV,@#FIRQB+FQDEV ;Set device name
	MOV	$SAVUNT,@#FIRQB+FQDEVN ;And unit number
	TSTB	$SAVFLG		;Is this a tape backup?
.ASSUME	DSKHND	EQ	0
	BNE	3$		;Yes, so we will deassign it
	MOVB	#UU.MNT,@#FIRQB+FQFUN ;Disk, so function is dismount
	MOVB	#2,@#FIRQB+FQFIL ;Set subfunction as dismount

3$:	.UUO			;Now go for it
	MOVB	@#FIRQB,R2	;Pick up error code
	BEQ	5$		;None, that's good
	CMESS	#ERRDSD		;Tell them error deassigning save set
	CMESS	R2		;Tell them what the error was
5$:	MOV	(SP)+,R2	;Restore our work register
	BIC	#GF.OWN,GENFLG	;Indicate we don't own device anymore
10$:	RETURN			;All done for now

.DSABL	LSB

GLOBAL	<$SAVDEV,$SAVUNT,ERRDSD,GENFLG>

.SBTTL	Input subroutine

;+
; PRTINP - Print a string and take input
;
;	TTYBUF = I/O buffer (contains string to print, used for input)
;	OUTLEN = Length of string to output
;
;	CALL	PRTINP
;
;	R0 = Returned error code
;	R5 -> Input string, as a .ASCIZ string
;	C = 1 to indicate error
;
;-

.ENABL	LSB

PRTINP:	BIC	#GF.HLD,GENFLG	;Clear the hold flag			;042
	MOV	R1,-(SP)	;Get a work register
	BIT	#GF.NHL,GENFLG	;Should we output to KB?		;057
	BNE	1$		;No (musta been called from DSKINT)	;057
	CALLX	CLRXRB		;Set up the XRB
	MOV	#XRB,R1		;R1 -> XRB
	MOV	OUTLEN,(R1)	;Set up output length
	MOV	(R1)+,(R1)+	;In both places
	MOV	#TTYBUF,(R1)	;Set up address of output buffer
	ADD	HLDOFF,(R1)	;Add in any offset			;042
	.WRITE			;Now output it
	CRASH			;And die on errors
	BIT	#GF.YNF,GENFLG	;Is this a query?			;041
	BNE	5$		;For V10.0, queries all go to KB:	;047
				; regardless of assist mode		;047
1$:	BIT	#C2$AST,C$FLG2	;Are we in /ASSIST mode?		;057
	BNE	OMS		;Yes, go do it with OMS			;041
	BR	5$		;No, go do it with KB:			;041


;+
; INPUT - Take input from the caller
;
;	CALL	INPUT
;
;	R0 = Returned error code
;	R5 -> Input string, as a .ASCIZ string
;	C = 1 to indicate error
;
;-

INPUT:	MOV	R1,-(SP)	;Get a work register
5$:	MOV	#TTYBUF,R5	;R5 -> I/O buffer
	CALLX	CLRXRB		;Clear out the XRB
	MOV	#XRB,R1		;R1 -> XRB
	MOV	#TTYLEN,(R1)+	;Set up the input length
	CLR	(R1)+		;And skip unused word
	MOV	R5,(R1)		;Point to TTY buffer
	MOV	#8192.,@#XRB+XRMOD ;Read with no stall
	.READ			;Now read the input
	MOVB	@#FIRQB,R0	;R0 = returned error code
	CMPB	R0,#DATERR	;Did we get anything?
	BNE	7$		;No, not this time
	CALLX	CLRXRB		;Clear out the XRB
	MOV	#-1,@#XRB	;Sleep for a long time, or until they type...
	.SLEEP			;Now wait...
	BR	5$		;No, so loop...

7$:	TSTB	R0		;Did we get some other error?
	BNE	10$		;Yes, so don't make string .ASCIZ
8$:	MOV	R4,-(SP)	;Get a work register			;052
	MOV	R5,R4		;R4 -> Input buffer
	ADD	-(R1),R4	;R4 -> End of input buffer
	CLRB	(R4)		;Mark the end of the buffer with a null
	MOV	#2!4!40,R0	;Convert LC to UC, junk spaces and delimiters
	CALLX	CVT$$		;Now convert the string
	CLR	R0		;Don't return an error
	MOV	(SP)+,R4	;Restore our work register
	TST	(PC)+		;Indicate success
10$:	SEC			;Set carry for error
20$:	MOV	(SP)+,R1	;Restore work register
30$:	RETURN			;And we're done


.SBTTL	OMS communications interface					;030+

;+
; OMS - communications interface
;-

OMSCHK:	BIT	#C2$AST,C$FLG2	;Are we in /ASSIST mode?
	BEQ	30$		;No, just return
	MOV	R0,-(SP)	;Save a register
	MOV	R1,-(SP)	;and another
	MOV	R2,-(SP)	;and another
	MOV	XRB+XRLOC,R0	;R0 -> CMESSAGE text
	MOV	#TTYBUF,R1	;R1 -> TTY buffer
	ADD	HLDOFF,R1	;Add in the hold offset			;042
	MOV	@#XRB,R2	;R2 = text byte count
	MOV	R2,OUTLEN	;Put it in output count word
35$:	MOVB	(R0)+,(R1)+	;move text to the tty buffer
	SOB	R2,35$		;until the count is exhausted
	MOV	(SP)+,R2	;Restore regs
	MOV	(SP)+,R1	;
	MOV	(SP)+,R0	;
	BIT	#GF.HLD,GENFLG	;Are we on hold?			;042
	BEQ	OMSSEN		;No, proceed				;042
	ADD	OUTLEN,HLDOFF	;Calculate our new offset		;042
	BR	30$		;And get out				;042
OMSSEN:	MOV	R1,-(SP)	;Save a register
	CLRB	OMSBUF+1	;Message only, no reply needed
	BR	40$		;And continue normally
OMS:	MOVB	#1,OMSBUF+1	;Tell OMS we want a reply
	ADD	HLDOFF,OUTLEN	;Get the total message length		;042
	CLR	HLDOFF 		;Reset the message hold offset		;042
40$:	MOV	OUTLEN,OUTLEN+2	;Make a copy of the text length		;050
	CMP	OUTLEN,#400	;Is text length > 255.?			;050
	BLO	50$		;Yes, proceed				;050

; OMS limits text records to 255 chars, and total text in one request	;050
; to 500 chars.  Our count (OUTLEN) should never exceed 500.		;050
; If we are here it's because our text is more than 255 chars long,	;050
; so we have to split the text into 2 parts, each with its own text 	;050
; record code and count.  We'll do that by shifting all text beyond	;050
; the first 254 characters out by one word so we can insert a byte	;050
; of record code "1" and a byte of the remaining count			;050

	MOV	R0,-(SP)	;Get a scratch reg			;050
	MOV	R1,-(SP)	;Get a scratch reg			;050
	MOV	R2,-(SP)	;Get a scratch reg			;050
	MOV	#TTYBUF+1000,R0	;R0 -> past next-to-last word in TTYBUF	;050
	MOV	#TTYBUF+1002,R1	;R1 -> past end of TTYBUF		;050
	MOV	#201,R2		;Number of words to shift		;050
45$:	MOV	-(R0),-(R1)	;Shift one				;050
	SOB	R2,45$		;Until done				;050
	MOV	OUTLEN,R1	;Get the original text length		;050
	MOV	#376,OUTLEN	;Cut 1st string length to 254.		;050
	SUB	#376,R1		;Calculate length of 2nd text string	;050
	MOVB	#1,(R0)		;Plug in the text code			;050
	MOVB	R1,1(R0)	;and the text length			;050
	ADD	#2,OUTLEN+2	;Add room for the extra word		;050
	MOV	(SP)+,R2	;Restore scratch reg			;050
	MOV	(SP)+,R1	;Restore scratch reg			;050
	MOV	(SP)+,R0	;Restore scratch reg			;050
50$:									;050
	MOVB	OUTLEN,TTYBUF-1 ;Set up text length in output buffer
	MOV	OUTLEN+2,CMDDSC+2 ;Set up length of send text		;050
	ADD	#12.,CMDDSC+2	;Offset for OMSBUF length
	CALBX	OMSSND,<#RSPDSC,#PARBUF,#-1,#CMDDSC,JOBNO>
				;Decare receiver, send, receive reply
	BCC	55$		;No error				;052

51$:	CMP	R0,#NOSUCH	;Is OMS alive?				;052
	BNE	52$		;Yes, don't tell 'em it's not		;052
	CMESSAGE #OMSNUP	;No, tell 'em				;052
	JMPX	RESTRT		;And get out				;052

52$:	MOV	R0,-(SP)	;Copy the error				;052
	CMESSAGE #OMSERR	;Tell 'em we got an error		;052
	MOV	(SP)+,R0	;Retrieve the error			;052
	CMESSAGE R0		;Tell 'em what went wrong		;052
	JMPX	RESTRT		;And get out				;052

55$:	TSTB	OMSBUF+1	;Did we ask for a reply?		;052
	BNE	OMSREC		;Yes					;052
	JMP	20$		;No, finished now			;052

OMSREC:	CALBX	OMSRCV,<#RSPDSC,#PARBUF,#-1> ;Issue a receive with wait
	BCS	51$		;Error					;052
58$:									;052
	CMP	#1,PARBUF+REQSTS ;Is status still pending?
	BEQ	OMSREC		;Fine, then go wait some more
	CMP	#2,PARBUF+REQSTS ; Request aborted - oh no!
	BNE	60$		;No					;050
	CMESSAGE #REQABO	;Report that operator aborted request	;052
	MOV	#EOF,R0		;Guess at user abort (like ctrl-z)
	JMP	10$		;Yes, take error exit			;050

60$:	MOV	#XRB,R1		;Point R1 at the byte count in XRB	;052
	MOV	#TTYLEN,(R1)+	;Plug in the buffer length		;052
	MOV	PARBUF+RCVLEN,(R1) ;Put received message length in XRBC	;052
	ADD	#2,(R1)+	;For a CRLF				;052
	MOV	#TTYBUF,R5	;Point R5 at the response
	MOV	R5,(R1)+	;Plug in the buffer address		;052
	CLR	(R1)+		;Plug in channel #			;052
	CLR	(R1)+		;Clear unused word			;052
	CLR	(R1)+		;Clear unused word			;052
	CLR	(R1)		;Clear unused word			;052
	MOV	R5,R0		;R0->TTYBUF				;052
	ADD	XRB+XRBC,R0	;R0->end of text + 2			;052
	MOVB	#12,-(R0)	;LF					;052
	MOVB	#15,-(R0)	;CR					;052
	CLR	R0		;Leave it as we found it (no error)	;052
	.WRITE			;Write it out for log file		;052
	CRASH			; Allow no errors			;052
	MOV	#XRB+XRBC,R1	;R1->message length			;052
	MOV	PARBUF+RCVLEN,(R1)+ ;Put received message length in XRBC ;052
				; and leave R1->XRLOC for 7$:		;052
	JMP	8$		;Take normal exit			;050

GLOBAL	<DATERR,TTYBUF>
GLOBAL	<C$FLG2,CMDDSC,RSPDSC,OMSBUF,PARBUF,JOBNO>			;030-
GLOBAL	<NOSUCH,OMSNUP,REQABO,OMSERR>					;052

.DSABL	LSB

.SBTTL	Save context for AST routines

;+
; ASYSAV - Save context for AST routines
;
;	CALL	ASYSAV,R5
;
;	All registers are saved on stack.
;	FIRQB & XRB are saved on the stack.
;
;	We will then call back our caller (JSR PC,(R5)).
;
;	When caller returns, we will restore context and exit from the AST.
;-

ASYSAV::MOV	R4,-(SP)	;;Save R4
	MOV	R3,-(SP)	;;Save R3
	MOV	R2,-(SP)	;;Save R2
	MOV	R1,-(SP)	;;Save R1
	MOV	R0,-(SP)	;;Now save R0
	MOV	#FIRQB,R0	;;R0 -> FIRQB
10$:	MOV	(R0)+,-(SP)	;;Save a word
	CMP	R0,#CORCMN	;;Are we done yet?
	BLO	10$		;;No, so loop...
	MOV	SAVXOR,-(SP)	;; Save the XOR ID			;054
	MOV	SAVDTA,-(SP)	;; Save the data ID			;054
	CALL	(R5)		;; Call our caller			;054

	CMP	(SP)+,SAVDTA	;; Did our data map change?		;054
	BEQ	12$		;; No, no need to remap it		;054
	MOV	-2(SP),SAVDTA	;; Restore the data ID			;054
	CALBX	MAPBUF,<#SAVDTA,#DTAAVL,#JUNK> ;; Remap data		;054
12$:	CMP	(SP)+,SAVXOR	;; Did our XOR map change?		;054
	BEQ	15$		;; No, no need to remap it		;054
	MOV	-2(SP),SAVXOR	;; Restore the XOR ID			;054
	CALBX	MAPBUF,<#SAVXOR,#XORAVL,#JUNK> ;; Remap XOR		;054
15$:	;CMESSAGE <#ASY,SAVDTA,SAVXOR>					;054
	MOV	#CORCMN,R0	;;R0 -> Just past XRB
20$:	MOV	(SP)+,-(R0)	;;Restore a word
	CMP	R0,#FIRQB	;;Are we done?
	BHI	20$		;;No, so loop...
	MOV	(SP)+,R0	;;Restore interrupted R0
	MOV	(SP)+,R1	;;And R1
	MOV	(SP)+,R2	;;And R2
	MOV	(SP)+,R3	;;And R3
	MOV	(SP)+,R4	;;And R4
	MOV	(SP)+,R5	;;And R5
	.ASTX			;;Now return to the interrupted process
	CRASH			;;We should never get here!

;GLOBAL	<ASY,CHK>							;054
GLOBAL	<SAVDTA,SAVXOR,DTAAVL,XORAVL,GENFLG>				;054

.SBTTL	Save context for Non-AST routines				;054+

;+
; NSYSAV - Save context for Non-AST routines
;
;	CALL	NSYSAV,R5
;
;	We will then call back our caller (JSR PC,(R5)).
;
;	When caller returns, we will restore context and exit from the routine.
;-

NSYSAV::MOV	R4,-(SP)	;
	MOV	R3,-(SP)	;
	MOV	R2,-(SP)	;
	MOV	R1,-(SP)	;
	MOV	R0,-(SP)	;
	MOV	SAVXOR,-(SP)	; Save the XOR ID
	MOV	SAVDTA,-(SP)	; Save the data ID
	CALL	(R5)		; Call caller back.
	CMP	(SP)+,SAVDTA	; Did our data map change?
	BEQ	10$		; No, no need to remap
	MOV	-2(SP),SAVDTA	; Restore data ID
	CALBX	MAPBUF,<#SAVDTA,#DTAAVL,#JUNK> ; Remap data	
10$:	CMP	(SP)+,SAVXOR	; Did our XOR map change?
	BEQ	20$		; No, no need to remap
	MOV	-2(SP),SAVXOR	; Restore XOR ID
	CALBX	MAPBUF,<#SAVXOR,#XORAVL,#JUNK> ; Remap XOR
20$:	;CMESSAGE <#CHK,SAVDTA,SAVXOR>
	MOV	(SP)+,R0	;
	MOV	(SP)+,R1	;
	MOV	(SP)+,R2	;
	MOV	(SP)+,R3	;
	MOV	(SP)+,R4	;
	MOV	(SP)+,R5	;
	RETURN

GLOBAL	<SAVDTA,SAVXOR,DTAAVL,XORAVL,GENFLG>				;054-

.SBTTL	Initialize a disk

;+
; DSKINT - Initialize a disk
;
;	R5 -> Argument list
;		.WORD	N	(Number of arguments)
;		.WORD	PCKSTA	(Pack status word)
;		.WORD	DN	(Address of device name)
;		.WORD	DU	(Device unit number/real flag)
;		.WORD	PD	(Address of Pack-ID in ascii, space filled)
;		.WORD	PCKCLU	(Requested pack clustersize)
;
;	CALL	DSKINT
;
; And the disk is initialized.
;
;	R0 = Exit status of DSKINT
;		0 = Warning occured while running DSKINT
;		1 = Disk successfully initialized
;		2 = Error occured while running DSKINT
;		4 = Severe error occured while running DSKINT or while
;		    executing this subroutine.
;-

.ENABL	LSB								;033

DSKINT::SUBR	<PCKSTA,DN,DU,PD,PCKCLU>

; Check to see if this is a RSTS disk

	CLR	R2		;Guess that the disk is a RSTS disk	;003
	CALLX	CLRFQB		;Clear out the FIRQB			;003
	MOVB	#UU.MNT,@#FIRQB+FQFUN ;Function is mount a disk pack	;003
	MOV	#2000!4000!100000,@#FIRQB+FQMODE ;Lookup pack ID for mount ;003
				;and mount /NOSHARE			;003
	MOV	@DN(R5),@#FIRQB+FQDEV ;Set up the device name	;003
	MOV	DU(R5),@#FIRQB+FQDEVN ;And the unit number		;003
	.UUO			;Now try to mount the disk		;003
	MOVB	@#FIRQB,R1	;R1 = Returned error code		;003
	BEQ	5$		;None, must be a RSTS disk		;003
	CMPB	R1,#INUSE	;Was the disk already mounted?		;003
	BEQ	5$		;Yes, so it was a RSTS disk		;003
	DEC	R2		;Some other error, must not be a good disk ;003
	BR	8$		;And skip the dismount			;003

; Dismount the disk since it is known to be mounted

5$:	CALLX	CLRFQB		;Clear out the FIRQB			;003
	MOVB	#UU.MNT,@#FIRQB+FQFUN ;Function is mount a disk pack
	MOVB	#2,@#FIRQB+FQFIL ;Subfunction is dismount
	MOV	@DN(R5),@#FIRQB+FQDEV ;Set up the device name
	MOV	DU(R5),@#FIRQB+FQDEVN ;And the unit number
	.UUO			;Now go for it
	MOVB	@#FIRQB,R1	;R1 = Returned error code
	BEQ	8$		;None, that's good
	CMESS	#ERRDSM		;Tell them error dismounting the disk
	CMESS	R1		;Now be specific
	JMP	220$		;Now get out in error

; Create the COM file
;
; R2 = 0 if previous RSTS disk, else -1
; R5 -> Argument list

8$:	MOV	PCKSTA(R5),R4	;Pick up pack status			;003
	MOV	SP,R3		;Save pointer to top of argument block	;003
	MOV	#ACCTXT,-(SP)	;Guess at disk being date of last access ;003
	BIT	#BRF$DW,R4	;Is this disk date of last write?
	BEQ	10$		;No, so our guess is fine
	MOV	#MODTXT,(SP)	;Yes, so set up correct text		;003

10$:	MOV	#PRVTXT,-(SP)	;Guess at disk being private		;003
	BIT	#BRF$PR,R4	;Is this a private disk?		;003
	BNE	20$		;Yes, that's good...
	MOV	#PUBTXT,(SP)	;No, this is public (too bad!)		;003

20$:	MOV	#NOTXT,-(SP)	;Guess at disk being NOWRITE		;003
	BIT	#BRF$RO,R4	;Is this a read-only disk?
	BNE	25$		;Yes, so all set up			;003
	MOV	#NULASC,(SP)	;No, so don't set the disk NOWRITE	;003

25$:	MOV	#BEGTXT,-(SP)	;Guess at placing index at beginning	;003
	BIT	#BRF$IB,R4	;Good guess?				;003
	BNE	27$		;Yes, all set				;003
	MOV	#MIDTXT,(SP)	;No, set up for the middle		;003

27$:	MOVB	EXERCT,R4	;Get exercise count, if specified	;056
	BIT	#C2$EXE,C$FLG2	;Explicit EXERCISE option?		;021
	BNE	28$		;Yes, use what was asked for		;021
	MOV	#3,R4		;Guess at doing 3 patterns		;021
	TST	R2		;Good guess?				;003
	BNE	28$		;Yes, this wasn't a RSTS disk before	;003
	CLR	R4		;Previous RSTS disk, do no patterns	;021
28$:	ASL	R4		;Make word offset			;021
	MOV	EXETBL(R4),-(SP) ;Push address of EXERCISE qualifier	;021

	MOV	#NULASC,-(SP)	;Assume [NO]ERASE is to be omitted	;021
	CMP	2(SP),EXETBL+0	;Was the previous choice /NOEXERCISE?	;021
	BNE	29$		;No, so don't say /[NO]ERASE		;043
	BIT	#C2$ERA!C2$NER,C$FLG2 ;Was it asked for explicitly?	;021
	BEQ	29$		;No					;043
	MOV	#ERATXT,(SP)	;Yes, assume /ERASE			;021
	BIT	#C2$ERA,C$FLG2	;Correct?				;021
	BNE	29$		;Yup					;043
	MOV	#NERTXT,(SP)	;No, change to /NOERASE			;021

29$:	MOV	#QERTXT,-(SP)	;Default to /QUERY			;040
	BIT	#C2$QRY,C$FLG2	;Did they specify /NOQUERY?		;040
	BNE	30$		;No, leave it				;040
	MOV	#NQETXT,(SP)	;Yes, set it to /NOQUERY		;040

30$:	MOV	PCKCLU(R5),R4	;R4 = Requested pack clustersize
35$:	CALLX	CLRFQB		;Clear out the FIRQB
	MOVB	#OPNFQ,@#FIRQB+FQFUN ;Function is open
	MOVB	#INIFIL,@#FIRQB+FQFIL ;On the initialization channel
	MOV	@DN(R5),@#FIRQB+FQDEV ;Set the device name
	MOV	DU(R5),@#FIRQB+FQDEVN ;Set the unit number
	CALFIP			;Now open the disk NFS
	CALLX	BUFWAT,R5	;Check for small buffers		;003
	 BR	35$		;None, try again			;003
	MOVB	@#FIRQB,R1	;Pick up any error code			;003
	BEQ	4000$		;None, that's good			;003
	CMESS	#OPNINI		;Tell them err opening dev for init	;003
	CMESS	R1		;Tell them what RSTS told us		;003
	MOV	R3,SP		;Fix up the stack			;003
	JMP	220$		;And get out				;003

4000$:	CMPB	R4,@#FIRQB+FQPFLG ;Is requested PCS >= DCS?		;003
	BHIS	36$		;Yes, so let it pass			;003
	MOVB	@#FIRQB+FQPFLG,R4 ;No, so use the DCS instead

36$:	CALLX	CLRFQB		;Clear out the FIRQB			;003
	MOVB	#RSTFQ,@#FIRQB+FQFUN ;Function is reset
	MOVB	#INIFIL,@#FIRQB+FQFIL ;On the initialization channel
	CALFIP			;Now reset the channel
	CRASH			;And die on errors

	$FAO	#IC,#OL,#512.,#DB,<R4,-2(R3),-4(R3),-6(R3),-10(R3),-12(R3),-14(R3),-16(R3),#2,DN(R5),<DU(R5),B>,#6,PD(R5)> ;040
				;Create the text for the COM file
	CRASH	R0		;And die on errors

	MOV	R3,SP		;Clean up the stack			;003

	; Note:  This subroutine is used by both DSKINT, above, and 	;033
	;	 HOOK, which is located in IMGRMS.			;033
COMPK::									;033
	MOV	#DSIBUF,R4	;R4 -> text area just created		;003
	ADD	OUTLEN,R4	;R4 -> Just after the last byte in COM file
40$:	CMP	OUTLEN,#512.	;Are we done yet?
	BEQ	50$		;Yes, so no more null filling to do
	CLRB	(R4)+		;Null fill				;033
	INC	OUTLEN		;Say we did one more byte
	BR	40$		;And loop

; Create the temporary file
;

50$:	CALLX	CLRFQB		;Clear out the FIRQB			;003
	MOVB	#CRTFQ,@#FIRQB+FQFUN ;Function is create a temporary file
	MOVB	#INIFIL,@#FIRQB+FQFIL ;On the DSKINT channel
	INC	@#FIRQB+FQSIZ	;File will be one block long
	CALFIP			;Now go create it
	CALL	BUFWAT,R5	;Check for small buffers		;003
	 BR	50$		;None, try again			;003
	MOVB	@#FIRQB,R3	;Pick up returned error code
	BEQ	60$		;None, that's good
	CMESS	#ERRCOM		;Tell them error creating COM file
	CMESS	R3		;Tell them what RSTS told us
	JMP	65$		;And get out, in error

60$:	MOV	@#FIRQB+FQNAM1+2,R5 ;Save the job number portion of name

; Set RTS name of COM file to DCL
;
; R5 = Second half of work file name in RAD-50

	CALLX	CLRFQB		;Clear out the FIRQB
	MOVB	#UU.FIL,@#FIRQB+FQFUN ;Function is file utilities
	MOV	#<INIFIL/2>+<10*400>,@#FIRQB+FQFIL ;Set channel number/function
	MOV	#^RDCL,@#FIRQB+FQSIZ ;RTS name will be DCL
	.UUO			;Now go for it
	CRASH			;And die on errors

; Give the COM file an executable protection code
;
; R5 = Second half of work file name in RAD-50

	CALLX	CLRFQB		;Clear out the FIRQB
	MOVB	#RENFQ,@#FIRQB+FQFUN ;Function is rename a file
	MOV	#FIRQB+FQNAM1,R3 ;R3 -> FIRQB @ FQNAM1
	MOV	#^RTEM,(R3)+	;Set first part of temporary file name
	MOV	R5,(R3)+	;Set second part of temporary file name
	MOV	#^RTMP,(R3)+	;Set file type of temporary file name
	CLR	(R3)+		;Skip the "delete file" flag
	MOV	#^RTEM,(R3)+	;Set the same name as the output name
	MOV	R5,(R3)+	; ...
	MOV	#^RTMP,(R3)+	; ...
	MOV	#<124.*400>+377,(R3) ;Now set the new protection code as <124>
	CALFIP			;And do the rename
	CRASH			;Die on errors...

; Write the COM file to disk
;
; R5 = Second half of work file name in RAD-50

	CALLX	CLRXRB		;Clear out the XRB
	MOV	#XRB,R3		;R3 -> XRB
	MOV	#512.,(R3)	;Set up to write one block		;003
	MOV	(R3)+,(R3)+	;In both places				;003
	MOV	#DSIBUF,(R3)+	;Set up the address of the buffer	;003
	MOVB	#INIFIL,(R3)	;Now set up the channel number
	.WRITE			;And go for it
	MOVB	@#FIRQB,R3	;Pick up error code
	BEQ	70$		;None, that's good
	CMESS	#ERRWCM		;Tell them error writing COM file
	CMESS	R3		;Tell them the specific error code
	CALLX	CLRFQB		;Clear out the FIRQB
	MOVB	#RSTFQ,@#FIRQB+FQFUN ;Function code is reset
	MOVB	#INIFIL,@#FIRQB+FQFIL ;Set up channel number to close
	CALFIP			;Now reset the channel
	CRASH			;And die on errors...
65$:	JMP	220$		;Get out, returning error to our caller ;003

70$:	CALLX	CLRFQB		;Clear out the FIRQB			;003
.ASSUME	CLSFQ	EQ	0	;Function is close
	MOVB	#INIFIL,@#FIRQB+FQFIL ;On the DSKINT channel
	CALFIP			;Now go for it
	CRASH			;And die on errors

; Now that we've written the work file, we'll get a PK to use
;
; R5 = Second half of work file name in RAD-50

110$:	CALLX	CLRFQB		;Clear out the FIRQB
	MOVB	#OPNFQ,@#FIRQB+FQFUN ;Function is open a file
	MOVB	#INIFIL,@#FIRQB+FQFIL ;On the "initialization" channel
	MOV	#"PK,@#FIRQB+FQDEV ;Set up the device name
	MOV	#400,@#FIRQB+FQDEVN ;And the unit number
	MOV	#100020,@#FIRQB+FQMODE ;Use dynamic PKs			;016
	CALFIP			;Now open a dynamic PK:			;014
	MOVB	@#FIRQB,R1	;Pick up the error code			;014
	BEQ	140$		;None, that's good			;014
	CMPB	R1,#NOROOM	;Resource problem?			;014	
	BEQ	120$		;Yes, wait for a free dynamic PK	;014
	JMP	220$		;No, so this in an unexpected error

120$:	WSIG$S			;Wait a little while
	BR	110$		;And try again

; Next thing to do is create a job running on our PK
;
; R2 = KB number of our PK (*1)
; R5 = Second half of work file name in RAD-50

140$:	MOVB	@#FIRQB+FQSIZM,R2 ; R2 = KB number of our PK		;057

145$:	CALLX	CLRFQB		;Clear out the FIRQB
	MOV	#FIRQB+FQFUN,R1	;R1 -> FIRQB @ FQFUN
	MOVB	#UU.JOB,(R1)+	;Function is create a job
	MOVB	#300,(R1)+	;Create job logged in			;032
	MOVB	R2,(R1)+	;Set the KB number of our PK
	CLR	(R1)+		;PPN will be our own
	MOV	#^RTEM,(R1)+	;Set first part of temporary file name
	MOV	R5,(R1)+	;Now set second part of temporary file name
	MOV	#^RTMP,(R1)+	;And set the file type of our temporary file
	MOV	#JFSYS,@#XRB	; Raise temp privs			;032
	.SET			; 					;032
	.UUO			;Now create the job
	MOV	#JFSYS,@#XRB	; We no longer need privs		;032
	.CLEAR			; So drop 'em				;032
	MOVB	@#FIRQB,R1	;Pick up returned error code
	BEQ	150$		;None, nothing to report
	CMPB	R1,#NOBUFS	;Are we low on XBUF?
	BNE	147$		;No, some unexpected error
	WSIG$S			;Wait a little bit
	BR	145$		;And try again

147$:	CMESS	#ERRCJI		;Tell them error creating job for initialize
	CMESS	R1		;Report the error
	JMP	220$		;And get out... with failure

150$:	MOVB	@#FIRQB+FQFIL,R5 ;R5 = Job number times two of job on PK
	ASR	R5		;Now R5 = job number of job on PK
	; We need to set nobroadcast on the PK so we don't get strange	;040
	; messages in our log file and through OMS			;040
	CALLX	CLRFQB		;Clear the firqb			;040
	MOVB	#UU.TRM,@#FIRQB+FQFUN ; Function is Set Term Char'stics ;040
	MOVB	R2,@#FIRQB+FQSIZM ; Target our PK terminal		;040
	MOVB	#377,@#FIRQB+FQCLUS+1 ; GAG that baby			;040
;	MOV	#JFSYS,@#XRB	; Raise temp privs			;032
;	.SET			; (otherwise we would need HWCFG)	;032
	.UUO			; Set nobroadcast on PK			;040
;	MOV	#JFSYS,@#XRB	; We no longer need privs		;032
;	.CLEAR			; So drop 'em				;032

; Now we'll turn off echo on the PK
;
; R5 = Controlled job job number

	CALLX	CLRXRB		;Clear out the XRB
	MOV	#-1,@#XRB+XRBC	;Function is disable echo
	MOV	#INIFIL+<PKBHND*400>,@#XRB+XRCI ;Set channel/handler index
	.SPEC			;Now go for it
	CRASH			;And die on errors	
	MOV	#TTYBUF,HLDPTR	;Init hold pointer			;057

; Now we'll reallocate the disk if this is a HOOK			;060
;									;060
; R5 = controlled job's job number					;060

	BIT	#GF.ASS,GENFLG	;Is this a HOOK?			;060
	BEQ	160$		;No, don't reallocate disk		;060
	BIT	#GF.OWN,GENFLG	;HOOK'ing a /noshareable disk?		;060
	BEQ	160$		;No, don't reallocate disk		;060
	CALLX	CLRFQB		;Clear the FIRQB			;060
	MOVB	#UU.ASS,@#FIRQB+FQFUN ; Function is reallocate		;060
	MOVB	R5,@#FIRQB+FQNAM1 ; Plug in the job number		;060
	MOV	$SAVDEV,@#FIRQB+FQDEV ; Plug in the device name		;060
	MOV	$SAVUNT,@#FIRQB+FQDEVN ; Plug in the device number	;060
	.UUO			; Execute the directive			;060
	CRASH			; And crash on other errors		;060

; Now we'll monitor the PK
;
; R5 = Controlled job job number
;
; Any output from the PK will be printed to our user. If the PK gets
; into KB state, we will see if the read comes from DCL. If it does,
; we know that DSKINT is done and we can pick up the exit status.

160$:	CALLX	CLRXRB		;Clear out the XRB
	MOV	#-1,@#XRB	;Conditionally sleep for a long time
	.SLEEP			;Now do it...

; We will first check for output from the PK

170$:	CALLX	CLRXRB		;Clear out the XRB again
	MOV	#XRB,R1		;R1 -> XRB
	MOV	#TTYLEN,(R1)	;Set up length of terminal I/O buffer
	SUB	HLDOFF,(R1)+	;Take off for previous input		;042
	CLR	(R1)+		;And clear returned count
	MOV	#TTYBUF,(R1)	;Set up the address of our buffer
	ADD	HLDOFF,(R1)+	;Add offset past previous input		;042
	MOVB	#INIFIL,(R1)	;And set the correct channel number
	.READ			;Now pick up the input from the PK
	CMPB	@#FIRQB,#EOF	;Are we out of data on the PK?
	BEQ	180$		;Yes, so check on needing input from user
	CRASH			;Die on any other errors
	MOV	#XRB,R1		;R1-> XRB 				;057
	MOV	#TTYLEN,(R1)+	;Set length of I/O buffer again
	TST	(R1)		;Is there a byte count?			;057
	BEQ	170$		;No, nothing to write out		;051
	ADD	(R1)+,HLDOFF	;Save the byte count			;042
	MOV	HLDPTR,(R1)+	;Point to start of new text		;057
	CLR	(R1)+		;Clear channel number/MSB of block number
	CLR	(R1)+		;Clear LSB of block number
	CLR	(R1)+		;Clear XRTIME
	CLR	(R1)		;And clear XRMOD
	.WRITE			;Now write this output out, please
	CRASH			;And die on errors
	MOV	#TTYBUF,R1	;Get start of buffer			;057
	ADD	HLDOFF,R1	;Offset to end of last text		;057
	MOV	R1,HLDPTR	;Update the hold pointer		;057
	CMP	R1,#TTYBUF+TTYLEN ;Are we past the end of the buffer?	;057
	BLT	170$		;No, proceed				;057
	CLR	HLDOFF		;Yes, clear the accumulator		;057
	MOV	#TTYBUF,HLDPTR	;Point to start of buffer		;057
	BR	170$		;Loop for all PK output

; Now we will check to see if the PK wants input
;
; R5 = PK job number

180$:	CALLX	CLRXRB		;Clear out the XRB
	MOV	#XRB,R1		;R1 -> XRB
	INC	(R1)+		;Set up to write one byte
	INC	(R1)+		;In both places
	MOV	#TTYBUF,(R1)+	;Set the address of our I/O buffer
	MOVB	#INIFIL,(R1)	;Set up our channel number
	MOV	#4,@#XRB+XRMOD	;Function is check PK status, don't send data
	.WRITE			;Now check out the status of the PK
	CMPB	@#FIRQB,#INUSE	;Are we waiting for input?
	BEQ	160$		;No, go back to sleep			;042

; PK wants input, if it is from DCL, we will get exit status and kill
; the job, if it is from another RTS, we will get it from our user.
;
; R5 = PK job number

	CALLX	CLRFQB		;Clear out the FIRQB
	MOVB	#UU.SYS,@#FIRQB+FQFUN ;Function is return job status
	MOVB	R5,@#FIRQB+FQFIL ;Set job number to get status from
	.UUO			;Now pick up the status of the job
	CRASH			;And die on errors
	CMP	@#FIRQB+34,#^RDCL ;Is DCL doing this read?
	BNE	190$		;No, not this time
	TST	@#FIRQB+36	;Is this really DCL?
	BNE	190$		;No, go do output and get input		;040
	JMP	210$		;We're almost done			;040

; We get here if someone other than DCL is doing the read. We will
; take input from the user and send it out to our PK.

190$:	MOV	HLDOFF,OUTLEN	;Get the accumulated byte count		;042
	CLR	HLDOFF		;Don't need an offset now		;042
	MOV	#TTYBUF,HLDPTR	;Reinitialize hold pointer		;057
	BIS	#GF.NHL,GENFLG	;Tell PRTINP we already output to KB	;057
	MOV	R5,-(SP)	;Save PK job #				;040
	CALL	PRTINP		;Yes, print last output and get input	;040
	MOV	(SP)+,R5	;And restore it				;040
	BIC	#GF.NHL,GENFLG	;Reset the no-print flag		;057
	CMP	R0,#EOF		;Did they hit a control/z?		;040
	BEQ	220$		;Yes, so handle that...
	CRASH			;And die on any other errors
	MOV	R0,-(SP)	;Save R0				;040
	MOV	R5,-(SP)	;Save PK job#				;040
	MOV	#TTYBUF,R5	;R5 -> Input string			;040
	ADD	@#XRB+XRBC,R5	;R5 -> End of string + 1		;040
	CLRB	(R5)		;Make sure there's a null at the end	;040
	MOV	#TTYBUF,R5	;R5 -> Start of string again		;040
	MOV	#2!4,R0		;Zap tabs, spaces, FF,LF,CR,DEL,ESC	;040
	CALLX	CVT$$		;String now = "Y", "N", or garbage	;040
	MOVB	#15,1(R5)	;Insert a CR as second character	;040
	MOV	(SP)+,R5	;Restore PK job#			;040
	MOV	(SP)+,R0	;and R0					;040

200$:	MOV	#XRB,R1		;R1 -> XRB
	MOV	#TTYLEN,(R1)+	;Set up length of I/O buffer
	MOV	#2,(R1)+	;Force byte count to 2			;040
	MOV	#TTYBUF,(R1)+	;Set up the address of buffer
	MOV	#INIFIL,(R1)+	;Set up the PK channel number
	CLR	(R1)+		;Skip one unused word
	CLR	(R1)+		;And another unused word
	MOV	#10,(R1)	;Set to wait until buffers are available
	.WRITE			;Now pass this data to the controlled job
	CRASH			;And die one errors
	JMP	160$		;Now wait for more to do from the PK

; We get here if the COM file is over... we'll pick up the exit status
; from the PK.

210$:	CALLX	CLRXRB		;Clear out the XRB
	INC	@#XRB		;Function is return PK exit status
	MOV	#INIFIL+<PKBHND*400>,@#XRB+XRCI ;Set channel number/handler
	.SPEC			;Now pick up the exit status
	CRASH			;And die on errors
	MOVB	@#XRB+XRBC,R0	;R0 = Exit status of DSKINT
	ASH	#-4,R0		;Get into low nybble			;001
	BIC	#^C<7>,R0	;Trim to returned status bits
	BR	230$		;And go close this PK

; We get here if an unexpected error occured. We will set the exit status
; to severe error and go close what's open on INIFIL.

220$:	MOV	#4,R0		;Set up the exit status

; We get here to close what's open on INIFIL. This may be either the PK
; or the work file.
;
; R0 = Exit status to return

230$:	CALLX	CLRFQB		;Clear out the FIRQB
	MOVB	#RSTFQ,@#FIRQB+FQFUN ;Function code is reset
	MOVB	#INIFIL,@#FIRQB+FQFIL ;On the initialization channel
	CALFIP			;Go for it
	CRASH			;And die on errors
	CLR	HLDOFF		;Text has printed, & OMS won't need it	;057
	RETURN			;And we're done

GLOBAL	<ERRCJI,TTYBUF,EOF,INUSE,CR,LF,NOBUFS>				;014
GLOBAL	<ERRCOM,ERRWCM,NOTMNT,ERRDSM,OPNINI,NOROOM>			;014
GLOBAL	<EXERCT>							;021
GLOBAL	<DSIBUF,DB>							;034
GLOBAL	<GENFLG>							;057
GLOBAL	<NOTAVL>							;060

.DSABL	LSB

.SBTTL	CRC-32 calculator

;+
; CRC32 - 32 bit CRC calculation routine
;
;	R4 -> Block to calculate CRC of
;
;		QD1BID	Data map ID of start of block
;		QD2BID	Data map ID of rest of block
;
;	CALL	CRC32
;
;	R0 = MSB of calculated CRC
;	R1 = LSB of calculated CRC
;	R4 -> Just past data
;-
 
CRC32::	MOV	#-1,R0		; Set up initial value MSB		;009
	MOV	R0,R1		; Set up initial value LSB		;009
	MOV	R2,-(SP)	; Get a work register			;009
	MOV	R3,-(SP)	; And another one			;009
	MOV	R5,-(SP)	; And another one			;009	
	MOV	BLKSIZ,R5	; Pick up blocksize			;009
	CMP	R5,#8192.-HBSIZE ; 1 APR - buffer header		;039
	BLOS	10$		; Proceed if less than that		;039
	MOV	R5,COUNT	; Copy the blocksize			;039
	MOV	#8192.-HBSIZE,R5 ; 1 APR's worth at a time		;039
	SUB	R5,COUNT	; Deduct it from the total		;039
	MOV	QD1BID,QD2BID	; Get the buffer ID			;054
10$:	MOVB	(R4)+,R2	; Get a byte of data			;009
	XOR 	R1,R2		; Xor in the CRC			;009
	BIC	#^C<377>,R2	; Clear the high byte			;009
	ASL	R2		; Compute longword index		;009
	ASL	R2		;  ...					;009
	ASHC	#-10,R0		; Shift R0,R1 right a byte		;009
	BIC	#^C<377>,R0	; Force leftmost byte of R0,R1 zero	;009
	MOV	CRC32T(R2),R3	; get low order polynomial value	;009
	XOR	R3,R1		; Xor it into the CRC			;009
	MOV	CRC32T+2(R2),R3 ; Get high order polynomial value	;009
	XOR	R3,R0		; Xor it into the CRC			;009
	SOB	R5,10$		; Go back and do next byte		;009
	TST	COUNT		; Any byte count remaining?		;039
	BEQ	20$		; No, done with block			;039
	CALL	50$		; Remap the buffers			;039
	BR	10$		; And transfer another load		;039

20$:	MOV	R0,-(SP)	; Save R0				;039
	CALBX	MAPBUF,<#QD1BID,#DTAAVL,#QDBVA> ; Restore data mapping	;054
	MOV	(SP)+,R0	; Restore R0				;039
	MOV	(SP)+,R5	; Restore one register			;009
	MOV	(SP)+,R3	; And another one			;009
	MOV	(SP)+,R2	; Restore other work register		;009
	COM	R0		; Complement CRC			;009
	COM	R1		; In both places			;009
	RETURN			; All done, return with CRC in R0,R1	;009
 
; Remap buffers								;039

50$:	CMP	COUNT,#8192.	; Is byte count >= 8192?		;039
	BLO	60$		; No					;039
	MOV	#8192.,R5	; Set up one APR's byte count		;039
	SUB	R5,COUNT	; Yes, subtract another APR's worth	;039
	BR	70$		; Go do the remapping			;039

60$:	MOV	COUNT,R5	; Use remaining byte count		;039
	CLR	COUNT		; Clear out the residual count		;039
70$:	ADD	#128.,QD2BID	; Increment data address by 128 slivers	;054
	MOV	R0,-(SP)	; Save a reg				;048
	CALBX	MAPBUF,<#QD2BID,#DTAAVL,#QDBVA> ; Remap dta buf up 8Kb	;054
	MOV	(SP)+,R0	; Rest a reg				;048
	MOV	QDBVA,R4	; R4 -> virtual addr in data block	;054
	RETURN			; Now go do some more transfers		;039

GLOBAL	<BLKSIZ,CRC32T>							;009
GLOBAL	<QD1BID,QD2BID,DTAAVL,QDBVA>					;054
.END
