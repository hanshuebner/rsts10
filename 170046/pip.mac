	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:RTCOM/
TITLE	PIP,<-RSTS/E PIP->,0F,24-AUG-91,GPK/ABC/SJK/WJS/AWR/PRL/SDL/KMF/JJT/GMB/BGN/REG/DWF

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY
.SBTTL	EDIT	DATE		REASON

.SBTTL	AWR001	26-JUL-81	ADD :Q OPTION TO /PROTECT FOR DCL (77)
.SBTTL	AWR002	28-JUL-81	CHECK /PROTECT AS PROTECTION CODE (78)
.SBTTL	PRL003	12-FEB-82	CHANGE ALL "EXTENSION'S" TO "TYPE'S"
.SBTTL	SDL004	01-FEB-83	FIX ANSI TAPE-TO-TAPE COPY I/O PROBLEM 
.SBTTL	SDL005	02-FEB-83	GENERATE CORRECT PPN IN DISK ERROR MESSAGE
.SBTTL	SDL006	22-FEB-83	PIP/SIZE:28 RUN LOOPS WHEN COPYING RMS FILES TO TAPE
.SBTTL  SDL007  15-MAR-83	DON'T FILL OUTPUT TAPE RECORD WITH NULLS ON /BSIZE:N
.SBTTL	SDL008	12-APR-83	DISALLOW /APPEND, /DELETE, /EXTEND OR /RENAME 
;                                 SWITCHES ON MAGTAPE FILE SPECS
.SBTTL	SDL009	03-JUN-83	FIX PROBLEM OF TRANSFERRING ANSI MAGTAPE FILES TO
;				  DISK (CAUSED BY A BAD SDL004 FIX; A NEW SDL004
;				  FIX WAS ADDED)
.SBTTL	WJS010  27-SEP-83	REMOVE INTERNAL RT11 (...CM5) MACRO RE-DEFINITION
.SBTTL  SDL011  13-DEC-83	FIX INFINITE LOOP PROBLEM WHEN COPYING A NON-SEQUENTIAL
;				  RMS FILE TO MAGTAPE BY TRAPPING THE ERROR
.SBTTL  KMF012	04-JAN-84	UPDATE FOR 8-BIT TERMINAL (UNSET PARITY BIT)
.SBTTL	JJT013	19-JAN-84	FIX DECDBL - DIVISION OF 32 BIT INTEGER BY 10.
.SBTTL	JJT014	19-JAN-84	STOP RETURNING THE TERMINAL CURSOR TO LEFT
;				  MARGIN WHEN OUTPUTTING DIRECTORY TO FILE
.SBTTL	JJT015	28-MAR-84	FIX PROBLEM OF TRANSFERRING RMS SEQUENTIAL
;				FILES TO DOS TAPES (MODIFIED THE SDL007 FIX)
.SBTTL	JJT016	23-AUG-84	CLEAR PREVIOUSLY UNUSED BITS IN THE FIRQB
;				BEFORE DOING A UU.FIL
.SBTTL	GMB017	06-Nov-84	Increased CCL com length to 511.
.SBTTL	GMB018	07-Nov-84	Made feature patch 22.13.6 the default
;				Mag tape max buffer size is now 8192.
.SBTTL	JJT019	07-Feb-85	Implemented feature patches 22.13.1 & 22.13.4
;				/NEWFILE and /LOG are now the default
.SBTTL	JJT020	25-Feb-85	Renamed PIPSAV.TXT to PIPSAV.HLP and
;				 look for it in HELP$:
.SBTTL	JJT021	15-Apr-85	Remove implementation of feature patch 22.13.4
;				 /NOLOG is back as the default
.SBTTL	JJT022	19-Apr-85	Ignore MSB of the size of Magtape files
.SBTTL	JJT023	24-Apr-85	Fix appending files larger than 28 blocks
;				to non-existent files
.SBTTL	JJT024	09-May-85	Add support for High-density magtapes
.SBTTL	JJT025	13-May-85	Fix problem of default protection code being
;				 set causes Multi-volume ANSI tapes to fail
;				 when mounting the second volume.
.SBTTL	JJT026	13-May-85	Clear and set input and output file open flags
;				 when using Multi-volume ANSI tapes.
.SBTTL	JJT027	11-Jul-85	Don't output trailing nulls to keyboard.
.SBTTL	JJT028	26-Jul-85	Kill the tentative file when ^C'ed.
.SBTTL	JJT029	09-Aug-85	Make /RE:NOWARN also apply to file not found.
.SBTTL	JJT030	20-Aug-85	Print prompt when creating file from KB input.
.SBTTL	JJT031	26-Aug-85	Always print CR/LF for Implied <cr> files.
.SBTTL	JJT032	05-May-86	Add switches to select files by filesize
.SBTTL	JJT033	06-Nov-86	Honor the EOF attr when going to non-attr devs
.SBTTL	JJT034	07-Nov-86	Have /RMS:FA for FTN files use the FTN routine
.SBTTL	JJT035	07-Nov-86	Fix handling of the Fortran character <SP>
.SBTTL	JJT036	24-Nov-86	Fix bug caused by JJT033
.SBTTL  BGN037  22-Jan-86       Correctly print out double digit unit numbers
.SBTTL  JJT038  18-Feb-87       Allow for HELP$: => double digit unit numbers
.SBTTL	REG039	24-Feb-87	Fix ANSI tape-to-disk with recsiz >4095
.SBTTL	DWF040	25-Feb-87	Use UU.ONX for disk directory lookup
.SBTTL	DWF041	26-Feb-87	Fix loop problem when copying files to the
;				same account
.SBTTL	REG042	12-Mar-87	ANSI tape-to-disk with implied carriage control
;				and recsiz not evenly divisible into 512
.SBTTL	REG043	12-Mar-87	ANSI tape non-DEC attribute in HDR2 byte 16
.SBTTL	REG044	30-Mar-87	Fix ANSI disk-to-tape with recsiz >4095
.SBTTL	REG045	30-Mar-87	ANSI disk-to-tape with implied carriage control
;				and recsiz not evenly divisible into 512
.SBTTL	REG046	30-Mar-87	ANSI tape-to-disk recsiz=0 hangs in RN state
.SBTTL	REG047	30-Mar-87	ANSI disk-to-tape recsiz=0 hangs in RN state
.SBTTL	REG048	30-Mar-87	ANSI disk-to-tape M/A/<sp> attr xferred wrong
.SBTTL	REG049	30-Mar-87	Fix delete/erase file with prot=<232> from 
;				account without TMPPRV privilege
.SBTTL	REG050	01-Apr-87	Issue warning when prot code rename doesn't
;				work because of insufficient privilege
.SBTTL	REG051	20-MAY-87	Check account after a /ZE and give message if
;				there are Protected files left over.
.SBTTL	JJT052	27-May-87	Fix bug with 050 above
.SBTTL	REG053	01-Jun-87	Add error msg output device on RENAME
.SBTTL	REG054	23-Jun-87	Stop printing Fixed Control Field from VFC
;				files during RMS->FA copy operation
.SBTTL	REG055	03-Jul-87	Add output device and PPN checks for RENAME
.SBTTL	REG056	06-Jul-87	Add filename to some warning messages
.SBTTL	REG057	24-Jul-87	Fix yet another rename bug *file<nn>/re error
.SBTTL	REG058	26-AUG-87	Remove restriction of edit 011, no longer needed
;				because of edit 044
.SBTTL	REG059	07-OCT-87	Output <CR><LF> to ttyhnd after ctrl-c.
.SBTTL	REG060	07-DEC-87	Use /BL on RMS -> ANSI tape when NOSPAN is set.
.SBTTL	REG061	14-MAR-88	Fix bug in VFCTST:: code that made RF:FIX files
;				print during copy to KB: with /RMS:FA set.
.SBTTL	REG062	14-MAR-88	Inhibit printing PPN in output ANSI tape file
;				spec when logging copy operations.
.SBTTL	REG063	24-MAR-88	Check real record length to determine attribute
;				validity.  F or D format must have reclen>0.
.SBTTL	REG064	18-APR-88	Fix ATRCHK to look at both reclen's.
;
.SBTTL	VAM065	02-Jun-88	Fix MAGTAPE SKIP calls to use -1 instead of 0
;				as argument, so that PIP won't try to use the
;				TMSCP "skip by tape marks" feature".
.SBTTL	REG066	17-Jun-88	Fix VFC RMS:FA boundary condition bug
.SBTTL	REG067	20-Jun-88	Use flag word 2 for /RE device check.
.SBTTL	REG068	24-Aug-88	On RMS-to-ANSI xfer, make block size = max 
;				recordsize for fixed and variable record types.
.SBTTL	REG069	06-Sep-88	Header size attribute erroneously being set.
.SBTTL	REG070	12-Jan-89	Give better error info for /ER without write 
;				access.
.SBTTL	REG071	23-Jul-89	Don't use file size to open non-disk files
.SBTTL	REG072	24-Aug-89	Fix SP after output ONX error
.SBTTL	FEK073	02-Nov-89	Propigate BACKUP/IGNORE bits and display them
;				on a /LI operation and /MD support.
.SBTTL	REG074	06-Feb-90	Fix error message on wild copy output error
.SBTTL	REG075	26-Mar-90	Fix /MD bug
.SBTTL	REG076	13-Feb-91	Fix error message on wild copy input error
.SBTTL	REG077	20-Mar-91	Allow dates over 1999
.SBTTL	JJT078	01-Jul-91	Fix problem typing Print format files to KB
;

.SBTTL	Warnings and gotchas

;+
; Warnings and gotchas in PIP
;
;    1.	Be SURE to DEFORG any new CSECTs so that they get linked before
;	INICOR.  If you don't, they'll get put at the end of the link, 
;	which INICOR will then use for buffer space!!!
;		- AWR
;-

.SBTTL	MACRO DEFINITIONS
.ENABL	LC

.MCALL	.CSISPC,.CLOSE,.EXIT,.ENTER,.LOOKUP,.SETTOP,.READW,.WRITW
.MCALL	.SRESET,..V1..,.RCTRLO,.PRINT,.DELETE,.TTYIN,.TTYOUT,.SPFUN

..V1..

;+. Macros for flagging of updates added for V7.1

.MACRO	PATCH	PATNO			; Open/close a patch segment
	.RADIX	10
	.NARG	P..NARG			; Get number of arguments
  .IF	NE 	P..NARG			; If an arg suppl, open a patch block
P..CUR	=	PATNO				; Save current article no.
  .IIF NDF P..'PATNO,  P..'PATNO = -1		; Initialize patch seg index
  .IIF DF P..PASS.2,   P..'PATNO = P..'PATNO+1	; Increment patch seg index
	PATCHO	PATNO,\P..'PATNO		; Define cross-reference entry
  .IFF					; If no arg supplied,
	PATCHI	\P..CUR				; close current patch block
  .IFTF
  .ENDC
	.RADIX
.ENDM	PATCH

.MACRO	PATCHI	PATNO
	PATCHC	PATNO,\P..'PATNO
.ENDM

.MACRO	PATCHO	PATNO,INDEX	; Create a cross-reference entry
P'PATNO'.'INDEX:			; Record current location counter
	.LIST
;+. 22.13.'PATNO     ( segment INDEX )
	.NLIST
.ENDM	PATCHO

.MACRO	PATCHC	PATNO,INDEX	; Close a patch block
	.LIST
;-. 22.13.'PATNO     ( segment INDEX )
	.NLIST
.ENDM	PATCHC

;-.



.MACRO	POINTX	TXT,NOCR,REG=R0
	TMPORG	TEXT
.NLIST	BEX
.DSABL	CRF
$$$$$$=.
.IF B <NOCR>
	 .ASCIZ	"TXT"
.IFF
	 .ASCII	"TXT"<200>
.ENDC
	UNORG
	 MOV	#$$$$$$,REG
.ENABL	CRF
.ENDM	POINTX

.MACRO	GENTXT	TXT,NOCR
	TMPORG	TEXT
.NLIST	BEX
.DSABL	CRF
$$$$$$=.
.IF B <NOCR>
	 .ASCIZ	"TXT"
.IFF
	 .ASCII	"TXT"<200>
.ENDC
	UNORG
	 .WORD	$$$$$$
.ENABL	CRF
.ENDM	GENTXT

.MACRO	MOVTXT	TXT,NOCR
.IF B	<TXT>
	CALL	MOVTX0,R4
.IFF
	CALL	MOVTXT,R4
	GENTXT	<TXT>,NOCR
.ENDC
.ENDM	MOVTXT

.MACRO	PRINT	TXT,NOCR
	POINTX	<TXT>,NOCR
.DSABL	CRF
	 .PRINT
.ENABL	CRF
.ENDM	PRINT

.MACRO	ERROR	TXT,DEST=ERROR,NOCR
	 CALL	DEST,R5
	 GENTXT	<TXT>,NOCR
.ENDM	ERROR

.MACRO	ERRORF	TXT,DEST=ERRORF,NOCR					;056
	 CALL	DEST,R5							;056
	 GENTXT	<TXT>,<200>						;056
.ENDM	ERRORF								;056

.MACRO	WARN	TXT,NOCR
	ERROR	<TXT>,WARN,NOCR
.ENDM	WARN

.MACRO	WARNF	TXT,NOCR						;056
	ERROR	<TXT>,WARNF,<200>					;056
.ENDM	WARNF								;056

.MACRO	PRNTXT	TXT,NOCR
	ERROR	<TXT>,PRNTXT,NOCR
.ENDM	PRNTXT

.MACRO	RSTSER	TAG,TXT,FILE
.IF	B	<FILE>
	CALL	RSTSER,R1,<TAG>
.IFF
	CALL	RSTSEF,R1,<PTR'FILE,TAG>
.ENDC
	TMPORG	TEXT
.IF NDF	TAG
TAG:
.ENDC
.NLIST	BEX
.IF EQ	.-TAG
TAG:	.ASCIZ	"?'TXT"
.ENDC
	UNORG
.ENDM	RSTSER

.MACRO	UNQTXT	TEXT
.NLIST
.NLIST
.DSABL	CRF
$$$$$$	= 0
.IRPC	X,<TEXT>
.IF EQ	''X-'\
$$$$$$	= 200
.IFF
	.BYTE	''X+$$$$$$
.ENDC
.ENDM
	.BYTE	377,0
.	= .-1
.ENABL	CRF
.LIST
.LIST
.ENDM	UNQTXT

.MACRO	SETERR	CODE,DEST=FIRQB,TYPE
.DSABL	CRF
.GLOBL	CODE
.ENABL	CRF
.IF  B	<TYPE>
	 MOVB	#CODE,DEST
.IFF
	 MOV	#CODE,DEST
.ENDC
.ENDM	SETERR

.MACRO	CHKERR	CODE,DEST=FIRQB
.DSABL	CRF
.GLOBL	CODE
.ENABL	CRF
	 CMPB	DEST,#CODE
.ENDM	CHKERR

.MACRO	.TTYIN	CHAR=R0
	 EMT	^O340
.IF DIF <CHAR>,R0
	 MOVB	%0,CHAR
.ENDC
.ENDM	.TTYIN

.MACRO	TAB	POS
.IF B 	<POS>
	 CALL	TABR0,R3
.IFF
	.NTYPE	$$$$$$,POS
	.IF EQ	$$$$$$
		 CALL	TABR0,R3
	.IFF
		.IF EQ	$$$$$$-67
			 CALL	TABBER,R3,POS
		.IFF
			 MOV	POS,R0
			 CALL	TABR0,R3
		.ENDC	;EQ $$$$$$-67
	.ENDC	;EQ $$$$$$
.ENDC	;B  POS
.ENDM	TAB

.MACRO	OUTSYM	TABLE
.IF B	<TABLE>
.ERROR	; OUTSYM MUST HAVE A TABLE
.IFF
	CALL	OUTSYM,R4,TABLE
.ENDC
.ENDM	OUTSYM

.MACRO	DECNUM	PAD=0
	CALL	DECNUM,R4,PAD
.ENDM	DECNUM

.MACRO	DECDBL	PAD=0
	CALL	DECDBL,R4,PAD
.ENDM	DECDBL

.MACRO	GETBUF	.SIZE
.IF B	<.SIZE>
	 CALL	GETBUF,R5
.IFF
	 CALL	GETBFX,R5,<.SIZE>
.ENDC
.ENDM	GETBUF

.MACRO	RETBUF	.SIZE
.IF B	<.SIZE>
	 CALL	RETBUF,R5
.IFF
	 CALL	RETBFX,R5,<.SIZE>
.ENDC
.ENDM	RETBUF

.MACRO	REGSAV	METHOD
.IF	IDN	<METHOD>,<INLINE>
	 MOV	R5,-(SP)
	 MOV	R4,-(SP)
	 MOV	R3,-(SP)
	 MOV	R2,-(SP)
	 MOV	R1,-(SP)
	 MOV	R0,-(SP)
.IFF
.IF	NB	<METHOD>
.ERROR	; ILLEGAL ARGUMENT "METHOD"
.ENDC
	CALLX	REGSAV,R5
.ENDC
.DSABL	CRF
TOS.R0	=	0*2
TOS.R1	=	1*2
TOS.R2	=	2*2
TOS.R3	=	3*2
TOS.R4	=	4*2
TOS.R5	=	5*2
TOS.PC	=	6*2
TOS.PS	=	7*2
.ENABL	CRF
.ENDM	REGSAV

.MACRO	REGSCR
	CALLX	REGSCR,R5
.DSABL	CRF
TOS.R0	=	0+1*2
TOS.R1	=	1+1*2
TOS.R2	=	2+1*2
TOS.R3	=	3+1*2
TOS.R4	=	4+1*2
TOS.R5	=	5+1*2
TOS.RA	=	6+1*2
.ENABL	CRF
.ENDM	REGSCR

.MACRO	REGRES
	CALLX	REGRES,R5
.ENDM	REGRES

.MACRO	MAGTAPE	CHAN,TYPE,ARG
.IF B	ARG
	CALL	MAGTXX,R5
	  .WORD	TYPE'.MT*400+377
	  .WORD CHAN+<26.*400>
.IFF
.IF IDN	<ARG>,<0>
	CALL	MAGTX0,R5
	  .WORD	TYPE'.MT*400+377
	  .WORD	CHAN+<26.*400>
.IFF
	CALL	MAGTAP,R5
	  .WORD	ARG
	  .WORD	TYPE'.MT*400+377
	  .WORD	CHAN+<26.*400>
.ENDC	;IDN <ARG>,<0>
.ENDC	;B   <ARG>
.ENDM	MAGTAPE

.MACRO	PEEK	LOC
.IF NB	LOC
	 MOV	LOC,XRB		; SET UP TO PEEK AT LOC
.ENDC
	 .PRIV,	.PEEK		; PEEK AT IT
.ENDM	PEEK

.MACRO	UNPNUM	PAD=0
	CALL	UNPNUM,R4,PAD
.ENDM	UNPNUM

.MACRO	UNPDBL	PAD=0
	CALL	UNPDBL,R4,PAD
.ENDM	UNPDBL

.MACRO	STATUS	CHAN
.IF B	CHAN
.ERROR	; CHANNEL ARGUMENT IS MISSING
.IFF
.IF IDN	<CHAN>,<OUT>
	CALL	MAGSTO
.IFF
.IF IDN	<CHAN>,<IN>
	CALL	MAGSTI
.IFF
.ERROR	; CHANNEL ARGUMENT IS FOOBAR
.ENDC	; IDN <CHAN>,<IN>
.ENDC	; IDN <CHAN>,<OUT>
.ENDC	; B   <CHAN>
.ENDM	STATUS

.MACRO	CMPLBL	TYP
	CALL	CMPLBL,R5
	 .RAD50	"TYP"
.ENDM	CMPLBL

.MACRO	OUTBYT	BITS,BYTES
	CALL	(R0),R2
	 .BYTE	BITS,''BYTES
.ENDM	OUTBYT

.MACRO	.TTYOUT	CHAR=R0
.IF DIF <CHAR>,R0
	 MOVB	CHAR,%0
.ENDC
	 EMT	^O341
.ENDM	.TTYOUT

.SBTTL	FLAG BIT DEFINITIONS FOR OPTION PROCESSING

; BITS IN SCNFLG (SWITCH OPTIONS)

.BSECT				; SCNFLG BITS

DELETE:	.BLKB	.		; DELETE SWITCH FLAG
RENAME:	.BLKB	.		; RENAME SWITCH FLAG
SOMOUT:	.BLKB	.		; THIS BIT ON IF OUTPUT SPEC PRESENT
RTS:	.BLKB	.		; /RTS FOUND
INSPCT:	.BLKB	.		; INSPECT FILES FROM WILD CARDS
NORWND:	.BLKB	.		; DO NOT REWIND MT BEFORE USING
STOPMS:	.BLKB	.		; STOP MT SCANNING AT A NON-MATCH
DIRECT:	.BLKB	.		; DIRECTORY FUNCTION
ZERO:	.BLKB	.		; ZERO SWITCH FLAG
UPDATE:	.BLKB	.		; UPDATE TYPE COPY
NOOVER:	.BLKB	.		; NO OVERRIDE OUTPUT
NEWFIL:	.BLKB	.		; DO NOT PRESERVE CREATION DATE/TIME
WIPEFL:	.BLKB	.		; ERASE FILE ON DELETE
APPEND:	.BLKB	.		; APPEND TO OUTPUT FILE
GOSWIT:	.BLKB	.		; IGNORE USER DATA ERRORS
LISTFN:	.BLKB	.		; LIST FILE NAMES WHEN COPIED

.BSECT				; DEFINE BITS IN SECOND SWITCH FLAG WORD
				;	(SC2FLG)

BSIZE:	.BLKB	.		; /BS SWITCH PARSED
DENSTY:	.BLKB	.		; /DENSITY:XXX FOUND
NOWARN:	.BLKB	.		; DON'T PRINT NOSUCH ON FAILING DELETE
ACCESS:	.BLKB	.		; /ACCESS FOUND - ACCESS ALL INPUT FILES
PARITY:	.BLKB	.		; /PARITY:FOOBAR WAS FOUND
PARODD:	.BLKB	.		; /PARITY: FOOBAR WAS ODD
NOATT:	.BLKB	.		; /NOATTRIBUTES WAS FOUND
INCOLS:	.BLKB	.		; :S FOUND ON /INSPECT OR /QUERY
RETAIN:	.BLKB	.		; RETAIN OLD CREATION DATE
DLA:	.BLKB	.		; USE DATE OF LAST ACCESS FOR LIMIT CHECKING
CREATE:	.BLKB	.		; USE CREATION DATA FOR LIMIT CHECKING
PRCOLQ:	.BLKB	.		; :Q FOUND ON /PROTECT			;001
MDFILS:	.BLKB	.		; Include Marked for Delete files	;073
	.BLKB	.		; RESERVED
	.BLKB	.		; RESERVED
	.BLKB	.		; RESERVED

.EQUATE	NOTCPY,	DELETE!RENAME!DIRECT!ZERO
.EQUATE	NOTZER,	DELETE!RENAME!DIRECT!INSPCT!NORWND
.EQUATE	NOTDIR,	DELETE!RENAME!INSPCT!UPDATE!ZERO
.EQUATE	NOTDEL,	RENAME!UPDATE!DIRECT!ZERO
.EQUATE	ZEROPT,	DENSTY!PARITY

.BSECT			;FLAGS FOR @ XRB+10

S$FIL:	.BLKB	.	;A FILE NAME EXISTS
S$FILS:	.BLKB	.	;  THE FILE NAME IS "*"
S$FILQ:	.BLKB	.	;  THE FILE NAME CONTAINS "?" (ONE OR MORE)
S$EXT:	.BLKB	.	;A . FOR THE TYPE EXISTS
S$EXTE:	.BLKB	.	;  THE TYPE ALSO EXISTS
S$EXTS:	.BLKB	.	;    THE TYPE IS "*"
S$EXTQ:	.BLKB	.	;    THE TYPE CONTAINS "?" (ONE OR MORE)
S$PPN:	.BLKB	.	;AN ACCOUNT NUMBER EXISTS
S$PPNJ:	.BLKB	.	;  THE PROJECT NUMBER IS "*"
S$PPNG:	.BLKB	.	;  THE PROGRAMMER NUMBER IS "*"
S$PROT:	.BLKB	.	;A PROTECTION CODE EXISTS
S$DPRO:	.BLKB	.	;(THE DEFAULT PROTECTION CODE WAS USED)
S$DEV:	.BLKB	.	;A : FOR THE DEVICE NAME EXISTS
S$DEVE:	.BLKB	.	;  THE DEVICE NAME ALSO EXISTS
S$DEVL:	.BLKB	.	;    THE DEVICE NAME WAS A LOGICAL NAME
S$DEVX:	.BLKB	.	;      THE LOGICAL DEVICE IS NOT NOW VALID

.BSECT			;FLAGS FOR @ XRB+12 [** MEANS INTERNAL]

SC$CLU:	.BLKB	.	;/CLUSTERSIZE:N SCANNED
SC$MOD:	.BLKB	.	;/MODE:N SCANNED
SC$SIZ:	.BLKB	.	;/FILESIZE:N SCANNED
SC$POS:	.BLKB	.	;/POSITION:N SCANNED
SCXEXT:	.BLKB	.	;**"FINISHED WITH" TYPE
SCIPR:	.BLKB	.	;**"INTO" PROTECTION SCANNING
SCIP1:	.BLKB	.	;**"INTO" PROJECT NUMBER OF ACCOUNT
SCIP2:	.BLKB	.	;**"INTO" PROGRAMMER NUMBER OF ACCOUNT
SCFIL:	.BLKB	.	;FILE NAME SEEN
SCEXT:	.BLKB	.	;. FOR TYPE SEEN
SCPPN:	.BLKB	.	;PPN SEEN
SCPROT:	.BLKB	.	;< FOR PROTECTION SEEN
SCDEV:	.BLKB	.	;: FOR DEVICE SEEN
SCLOG:	.BLKB	.	;A LOGICAL DEVICE WAS USED
SCQUES:	.BLKB	.	;**A "?" HAS OCCURRED IN THIS FIELD
SCWILD:	.BLKB	.	;SOMETHING WILD HAS BEEN ENCOUNTERED

; BIT COMBINATIONS OF .FSS FLAGS USED IN PIP

.EQUATE	S$WIFI	,	S$FILS!S$FILQ!S$EXTS!S$EXTQ ; WILD FILE NAME
.EQUATE	S$WILD	,	S$WIFI!S$PPNG!S$PPNJ	    ; SOMETHING IS WILD
.EQUATE	SC$SWT	,	SC$CLU!SC$MOD!SC$SIZ!SC$POS ; A SWITCH WAS FOUND

.BSECT			; BIT RETURNED FROM USTAT BY DIR LOOKUP

US.OUT:	.BLKB	.	; FILE IS PHYSICALLY ON ANOTHER DISK
US.PLC:	.BLKB	.	; FILE HAS BEEN PLACED
US.WRT:	.BLKB	.	; FILE IS OPEN FOR WRITE ACCESS
US.UPD:	.BLKB	.	; FILE IS OPEN FOR UPDATE
US.NOX:	.BLKB	.	; FILE IS CONTIGUOUS
US.NOK:	.BLKB	.	; FILE CANNOT BE KILLED DURING TIMESHARING
US.UFD:	.BLKB	.	; NAME ENTRY IS A UFD
US.DEL:	.BLKB	.	; FILE IS MARKED FOR DELETION

.DSECT			; DEFINE ATTRIBUTE OFFSETS

F.RTYP:	.BLKB		; TYPE OF RECORD
F.RATT:	.BLKB		; ATTRIBUTE (0=FB,2=FA)
F.RSIZ:	.BLKW		; RECORD SIZE
F.HIBK:	.BLKW	2	; HIGHEST VIRTUAL BLOCK
F.EFBK:	.BLKW	2	; EOF BLOCK
F.FFBY:	.BLKW		; FIRST FREE BYTE
S.FATT:			; NUMBER OF ATTRIBUTE BYTES PER FILE

; DEFINE VALUES IN F.RTYP

.DSECT			; VALUES FOR F.RTYP

R.UDF:	.BLKB		; UNDEFINED FORMAT
R.FIX:	.BLKB		; RECORDS ARE FIXED
R.VAR:	.BLKB		; RECORDS ARE VARIABLE
R.SEQ:	.BLKB		; RECORDS ARE SEQUENCED
R.ASC:	.BLKB		; FILE IS STREAM ASCII FORMAT

; DEFINE VALUES FOR RECORD ATTRIBUTES

.BSECT			; RECORD ATTRIBUTE VALUES

FD.FTN:	.BLKB	.	; RECORDS HAVE FORTRAN CARRIAGE CONTROL INFORMATION
FD.CR:	.BLKB	.	; RECORDS HAVE IMPLIED LF/CR
FD.PRN:	.BLKB	.	; RECORDS HAVE PRINT FILE PREFIX AND POSTFIX CONTROL
FD.BLK:	.BLKB	.	; RECORD CANNOT SPAN BLOCKS
FD.EMB:	.BLKB	.	; EMBEDDED

; MAGTAPE CHARACTERISTICS WORD DEFINITIONS

.EQUATE	MC.FMT	,140000	; MASK FOR FORMAT OF MAGTAPE

.DSECT	40000		; DEFINE VALUES FOR ABOVE MASK

MC$FIX:	.BLKB	.	; FIXED LENGTH RECORDS
MC$VAR:	.BLKB	40000	; VARIABLE LENGTH RECORDS
MC$SPN:	.BLKB	.	; SPANNED RECORDS (UGH)

.EQUATE	MC.CC	,30000	; MASK FOR CARRIAGE CONTROL CHARACTERISTICS

.DSECT	10000		; DEFINE VALUES FOR ABOVE MASK

MC$EMB:	.BLKB	.	; EMBEDDED CARRIAGE CONTROL
MC$FTN:	.BLKB	./2	; FORTRAN CARRIAGE CONTROL
MC$IMP:	.BLKB	.	; IMPLIED CARRIAGE CONTROL

.DSECT	FQBSIZ		; FIRQB EXTENSION

F$SFLG:	.BLKW		; SCAN FLAGS FROM .FSS @ XRB+10
F$FLAG:	.BLKW		; DEVICE FLAGS
F$HIDX:	.BLKB		; HANDLER INDEX
F$CHAN:	.BLKB		; RSTS CHANNEL NUMBER
F$DFLG:	.BLKW		; DEVICE FLAGS (LOW BYTE = F$HIDX)
F$FLG2:	.BLKW		; SCAN FLAGS FROM .FSS @ XRB+12
F$BSIZ:			; SIZE OF THE FIRQB EXTENSION BLOCK

; BITS IN FLAGS WORD EXTENSION OF FIRQB

.BSECT

DISKFL:	.BLKB	.	; DEVICE IS FILE STRUCTURED DISK
	.BLKB	.	; RESERVED
	.BLKB	.	; RESERVED
	.BLKB	.	; RESERVED
	.BLKB	.	; RESERVED
	.BLKB	.	; RESERVED
	.BLKB	.	; RESERVED
ANSIMT:	.BLKB	.	; MAGTAPE IS ANSI
ANSDEC:	.BLKB	.	; ANSI TAPE WAS WRITTEN ON A DEC SYSTEM		;043

.EQUATE	IN	,0	; INPUT CHANNEL
.EQUATE	OUT	,1	; OUTPUT CHANNEL
.EQUATE	ONX	,14	; Open Next channel				;040
.EQUATE	TMP	,15	; TEMPORARY CHANNEL
.EQUATE	IND	,16	; INDIRECT COMMAND FILE
.EQUATE	RADSTR	,134745	; RAD50 FOR "*"

.SBTTL	ANSI LABEL FORMAT DEFINITIONS

.DSECT			;VOL1 LABEL
V1.LID:	.BLKB	3	;"VOL"	LABEL IDENTIFIER
V1.LNU:	.BLKB	1	;"1"	LABEL NUMBER
V1.VID:	.BLKB	6	;AAAAAA	VOLUME IDENTIFIER
V1.ACC:	.BLKB	1	;" "	ACCESSIBILITY (SPACE => NO RESTRICTIONS)
	.BLKB	26.	;RESERVED
V1.OWN:	.BLKB	14.	;"D%B4431JJJGGG1" OWNER IDENTIFIER (& DEC PROTECTION)
	.BLKB	28.	;RESERVED
V1.LSV:	.BLKB	1	;"3"	LABEL-STANDARD VERSION
ANSLBL:			;CHECK LENGTH

.DSECT			;FILE LABEL 1 (HDR1 OR EOF1)
F1.LID:	.BLKB	3	;"HDR" OR "EOF" LABEL IDENTIFIER
F1.LNU:	.BLKB	1	;"1"	LABEL NUMBER
F1.FID:	.BLKB	17.	;FILNAM.EXT FILE IDENTIFIER
F1.FSI:	.BLKB	6	;AAAAAA	FILE-SET IDENTIFIER (VOLUME ID)
F1.SEC:	.BLKB	4	;0001	FILE SECTION NUMBER
F1.SEQ:	.BLKB	4	;NNNN	FILE SEQUENCE NUMBER
F1.GEN:	.BLKB	4	;0001	GENERATION NUMBER
F1.GVN:	.BLKB	2	;00	GENERATION VERSION NUMBER
F1.CRE:	.BLKB	6	; YYDDD CREATION DATE (LEADING SPACE!)
F1.EXP:	.BLKB	6	; YYDDD EXPIRATION DATE (SAME IN RSTS)
F1.ACC:	.BLKB	1	;" "	ACCESSIBILITY (SPACE => NO RESTRICTIONS)
F1.BLK:	.BLKB	6	;NNNNNN	BLOCK COUNT (000000 FOR HDR1 LABEL)
F1.SYS:	.BLKB	13.	;"DECRSTS/E" SYSTEM CODE
	.BLKB	7	;RESERVED
ANSLBL:			;CHECK LENGTH

.DSECT			;FILE LABEL 2 (HDR2 OR EOF2)
F2.LID:	.BLKB	3	;"HDR" OR "EOF" LABEL IDENTIFIER
F2.LNU:	.BLKB	1	;"2"	LABEL NUMBER
F2.FMT:	.BLKB	1	;"F" (FIXED), "D" (VARIABLE), OR "S" (SPANNED)
F2.BLK:	.BLKB	5	;NNNNN	BLOCK LENGTH
F2.REC:	.BLKB	5	;NNNNN	RECORD LENGTH
F2.ATT:	.BLKB	21.	;VAX COMPATIBLE ATTRIBUTE AREA
F2.CTL:	.BLKB	1	;DEC: CONTROL CHARACTERS ("A", " ", OR "M")
	.BLKB	13.	;RESERVED FOR SYSTEM USE
F2.BFO:	.BLKB	2	;"00"	BUFFER-OFFSET LENGTH
	.BLKB	28.	;RESERVED
ANSLBL:			;CHECK LENGTH

.SBTTL	CONSTANTS FOR PIPMT

.BSECT			; DEFINE BITS IN MAGTAPE STATUS WORD

M$LAST:	.BLKB	.	; LAST COMMAND ISSUED
	.BLKB	.
	.BLKB	.
M$1600:	.BLKB	.	; DRIVE IS A TU16 1600BPI PHASE ENCODED
M$TUMT:	.BLKB	.	; DRIVE IS A TU16, TE16, OR TU45
M$OFF:	.BLKB	.	; DRIVE IS OFFLINE
M$BUFF:	.BLKB	.	; LAST COMMAND WAS A READ THAT OVERFLOWED THE BUFFER
M$EOF:	.BLKB	.	; LAST COMMAND DETECTED AN EOF
M$BOT:	.BLKB	.	; WE ARE CURRENTLY AT BOT
M$EOT:	.BLKB	.	; WE ARE CURRENTLY BEYOND EOT
M$WLCK:	.BLKB	.	; DRIVE IS PHYSICALLY WRITE LOCKED
M$EVEN:	.BLKB	.	; DRIVE IS CURRENTLY SET FOR EVEN PARITY
M$7TRK:	.BLKB	.	; DRIVE IS 7 TRACK
M$DENS:	.BLKB	.	; DENSITY OF DRIVE 0=200,1=556,2=800,3=800DUMP
	.BLKB	.
M$ERR:	.BLKB	.	; LAST COMMAND CAUSED AN ERROR

.DSECT			; DEFINE FUNCTION CODES TO MAGTAPE DRIVER

RWO.MT:	.BLKB		; REWIND THEN OFFLINE
EOF.MT:	.BLKB		; WRITE EOF
REW.MT:	.BLKB		; REWIND THE MAGTAPE
SKP.MT:	.BLKB		; SKIP FORWARD
BSP.MT:	.BLKB		; SKIP BACKWARD
DEN.MT:	.BLKB		; SET THE DENSITY/PARITY
UNT.MT:	.BLKB		; GET MAGTAPE UNIT STATUS
FIL.MT:	.BLKB		; GET MAGTAPE FILE CHARACTERISTICS
RWC.MT:	.BLKB		; REWIND MAGTAPE ON CLOSE
	.BLKB								;024
	.BLKB								;024
XDN.MT:	.BLKB		; EXTENDED SET DENSITY FUNCTION			;024

.DSECT			; DEFINE THE ANSI FILE CONTROL BLOCK USED IN PIP

ACBLBL:	.BLKW		; TYPE OF LABEL TO WRITE
ACBNAM:	.BLKW	2	; FILE NAME		[ RAD50	]
ACBEXT:	.BLKW		; TYPE			[ RAD50 ]
ACBFSI:	.BLKB	6	; FILE SET IDENTIFIER	[ ASCII	]
ACBFSN:	.BLKW		; FILE SECTION NUMBER	[BINARY	]
ACBSQN:	.BLKW		; FILE SEQUENCE NUMBER	[BINARY	]
ACBCNT:	.BLKW	2	; FILE SIZE(BLOCK COUNT)[BINARY	]
ACBBSZ:	.BLKW		; BLOCK SIZE		[BINARY	]
ACBTYP:	.BLKW		; RECORD TYPE		[BINARY	]
ACBCHR:	.BLKW		; MODIFIER CHARACTER	[BINARY	]
ACBSIZ:			; SIZE OF AN ANSI FILE CONTROL BLOCK

; AN INDIRECT COMMAND FILE IS DESCRIBED BY AN 8-WORD CONTROL BLOCK
; ALL BLOCKS ARE ALLOCATED CONTIGUOUSLY, AND DYNAMICALLY FROM THE
; MAIN DATA BUFFER AS NEEDED

.DSECT			; DEFINE THE OFFSETS INTO THE ICFCB

IN$PPN:	.BLKW		; PPN OF THE ICF
IN$DEV:	.BLKW		; RAD50 DEVICE SPECIFICATION OF THE ICF
IN$NAM:	.BLKW	2	; RAD50 NAME OF THE ICF
IN$EXT:	.BLKW		; RAD50 TYPE OF THE ICF
IN$PTR:	.BLKW		; POINTER INTO BUFFER FOR NEXT BYTE
IN$CNT:	.BLKW		; COUNT OF BYTES LEFT IN CURRENT BLOCK
IN$MSB:	.BLKW		; MSB OF CURRENT BLOCK
IN$LSB:	.BLKW		; LSB OF CURRENT BLOCK
IN$SIZ:			; SIZE OF ICFCB IN BYTES

.SBTTL	ORDER THE CSECTS

DEFORG	PIP		; MAIN LINE PIP
DEFORG	PIPMT		; MAGTAPE FILE STRUCTURE CODE
DEFORG	TEXT		; TEXT
DEFORG	DATA		; DATA
DEFORG	LONGSW		; LONG SWITCHES
DEFORG	SHRTSW		; PER-FILE SWITCHES
DEFORG	DELOPT		; DELETE/PROTECT OPTION TEXT
DEFORG	PROOPT		; PROTECT/QUERY OPTION TEXT			;001
DEFORG	DENOPT		; DENSITY KEYWORDS MINUMUM/MAXIMUM		;024
DEFORG	PAROPT		; PARITY TYPE (EVEN/ODD)
DEFORG	SLWOPT		; INSPECT/QUERY OPTION TEXT
DEFORG	DENASC		; STORAGE AREA FOR DENSITY IN ASCII		;024
DEFORG	RFTBL		; RECORD FORMAT TABLE
DEFORG	FOTBL		; FILE ORGANIZATION TABLE
DEFORG	CCTBL		; CARRIAGE CONTROL TABLE
DEFORG	ONXFQB		; UU.ONX -> UU.LOK emulator storage area	;040
TMPORG	.99ODT		; MAINLINE RTSODT
TMPORG	.99999		; PSEUDO VECTORS FOR RTSODT
DEFORG	PATCH		; PATCH AREA FOR PIP
	.BLKW	64.	; 200 BYTES OF PATCH SPACE
DEFORG	INICOR		; ONE-SHOT INITIALIZATION CODE

.SBTTL	ONXFQB storage area

	ORG	ONXFQB							;040
									;040
	.BLKB	FQBSIZ		; Yes, it's a FIRQB			;040

BITBYT::.BYTE	001		; Define a table			;041
	.BYTE	002		;  that will				;041
	.BYTE	004		;   return a				;041
	.BYTE	010		;    bit value				;041
	.BYTE	020		;     given a				;041
	.BYTE	040		;      byte offset			;041
	.BYTE	100		;       (0-7)				;041
	.BYTE	200		;					;041

MSKSIZ	=:	256.		; Number of words in BITMSK table	;041

BITMSK::.BLKW	MSKSIZ		; Each bit in this table represents	;041
				; a possible File ID, as returned	;041
				; by UU.ONX, and is used to indicate	;041
				; that this file has been already	;041
				; accessed for the current operation	;041




.SBTTL	DATA AREA DEFINITIONS

	ORG	DATA

OUTSPC::.BLKW	<5*3>
INSPC::	.BLKW	<4*6>		; OUTPUT AND INPUT FILE SPEC BUFFERS
ENDSPC::
INDEX::	.BLKW			; DIRECTORY LOOKUP INDEX
BUFSIZ::.BLKW			; INPUT BUFFER SIZE
BUFSZ::	.BLKW			; RESET VALUE FOR BUFFER SIZE
GOTANY::.BLKW			; FLAG FOR ANY FILES MATCHED SO FAR
SCNFLG::.BLKW			; FLAGS FROM THE SCANNER
ZEROFL::.BLKW			; FLAG FOR LAST BLOCK OF 0
UPDENT::.BLKW			; NON-ZERO IF OUTPUT OPENED /U
ATRFLG::.BLKW			; 1 IF ATTRIBUTES/RTS NAME TO COPY
LPFLAG::.BLKW			; LINE PRINTER IN HUNG STATE
OURPPN::.BLKW			; OUR PPN, OF COURSE
OURKB::	.BLKW			; OUR KEYBOARD NUMBER			;030
PTRIN::	.BLKW			; POINTER TO CURRENT INPUT SPEC
PTROUT::.WORD	OUTSPC		; POINTER TO (ONLY) OUTPUT SPEC
INFQB::	.BLKB	F$BSIZ		; INPUT FIRQB COPY + FIRQB EXTENSION
OUTFQB::.BLKB	F$BSIZ		; OUTPUT FIRQB COPY + FIRQB EXTENSION
DDFALT::.BLKW			; DIRECTORY DEFAULT
UPDSIZ::.BLKW			; SIZE OF UPDATE OUTPUT FILE
UPDSZM::.BLKW			;  MSB OF SIZE FOR UPDSIZ
CP2SEF::.BLKW			; FLAG IF WE ARE COPYING TO SAME ACCOUNT ;041

RTSLST::.BLKW	6*3		; LIST OF RUNNABLE RTS TYPES & NAMES
RTSEND::.WORD	0		; END OF LIST
INFLG::	.BLKW			; <>0 IF INPUT FILE IS OPEN
OUTFLG::.BLKW			; <>0 IF OUTPUT FILE IS OPEN (HI BYTE=ATRFLG)
INFCTR::.BLKW			; NUMBER OF INPUT FILES OPENED SINCE ENTER

PRIVS::	.BLKW			; -1 if we have temp privs, 0 otherwise
SWTPTR::.BLKW			; ALLOWS US TO HANDLE /PR AS <PROT>	;002

; KEEP IN ORDER ...
SAVPPN::.BLKW			; STUFF REAL PPN FROM .ENTER HERE
PPNDEX::.BLKW			; PPN LOOKUP INDEX
WLDPPN::.BLKW			; WILD CARD PPN
WLDDEV::.BLKW			; DEVICE FOR WILD CARD PPN
WLDDVN::.BLKW			; DEVICE # FOR WILD CARD PPN
TDRNFL::.BLKW			; LSB OF TOTAL # FILES
TDRNFM::.BLKW			; MSB OF TOTAL # FILES
TDRNBL::.BLKW			; LSB OF TOTAL # BLOCKS
TDRNBM::.BLKW			; MSB OF TOTAL # BLOCKS

DIRPPN::.BLKW			; CURRENTLY LISTING ACCOUNT
DIRDEV::.BLKW			; CURRENTLY LISTING DEVICE
DIRDVN::.BLKW			; CURRENTLY LISTING UNIT
DIRNFI::.BLKW			; NUMBER OF FILES IN CURRENT SPEC
DIRNBL::.BLKW			; NUMBER OF BLOCKS (LSB)
DIRNBM::.BLKW			; NUMBER OF BLOCKS (MSB)
SWITCH::.BLKW			; CURRENT INPUT FILE SWITCH
KBSIZE::.BLKW			; TERMINAL WIDTH
LSTCTR::.BLKW			; COUNTER OF POSITION ON LINE FOR /L:W
LSTEPL::.BLKW			; RESET VALUE FOR LSTCTR
LSTSWT::.BLKW			; LISTING OPTIONS
; ... TO HERE

INOCNT:	.BLKW	0		;saved open counts for directories	;073
INFLAG:	.BLKW	0		;Copy of input file characteristics	;073

; KEEP IN ORDER ...
	.WORD	0		; trash area				;073
INAFQB	= .-FQFIL
	.BLKB	FQBSIZ-FQFIL	; FIRQB COPY
INRTS::	.BLKW	2		; RTS NAME OF INPUT FILE
INATRC::.BLKW			; NUMBER OF ATTRIBUTE WORDS
INATR::	.BLKW	13.		; ENOUGH ROOM
; ... TO HERE

OUTATC::.BLKW			; NUMBER OF ATTRIBUTE WORDS
OUTATR::.BLKW	13.		; OUTPUT FILE ATTRIBUTES
OUTRTS::.BLKW	2		; OUTPUT FILE RTS NAME
OUTPRO::.BLKW			; OUTPUT PROTECTION CODE SAVED HERE

; KEEP IN ORDER ...
IBLKL::	.BLKW			; INPUT BLOCK NUMBER LSB
IBLKM::	.BLKW			; INPUT BLOCK NUMBER MSB
OBLKL::	.BLKW			; OUTPUT BLOCK NUMBER LSB
OBLKM::	.BLKW			; OUTPUT BLOCK NUMBER MSB
IBFPTR::.BLKW			; ADDRESS OF START OF INPUT BUFFER
IBFSIZ::.BLKW			; LENGTH OF INPUT BUFFER IN BYTES
OBFPTR::.BLKW			; ADDRESS OF START OF OUTPUT BUFFER
OBFSIZ::.BLKW			; LENGTH OF OUTPUT BUFFER IN BYTES
EOFLAG::.BLKW			; <>0 IF EOF ON INPUT
; ... TO HERE

; KEEP IN ORDER ...
FBHDR::	.BYTE	1,0		; FORMATTED BINARY HEADER FOR OUTPUT
FBLEN::	.BLKW			; LENGTH OF FB RECORD (INCL HEADER)
CHKSUM::.BLKW			; FORMATTED BINARY CHECKSUM
; ... TO HERE

; KEEP IN ORDER ...
CURDAT::.BLKW			; CURRENT DATE
LODATE::.BLKW			; LOW DATE TO MATCH
HIDATE::.BLKW			; HIGH DATE TO MATCH
DATFLG::.BLKW			; FLAG OF DATES SCANNED
SWTTBL::.BLKW	9.		; SWITCH TABLE PER FILE
RMSFLG::.BLKW			; FLAG FOR /RMS IN, /RMS OUT, /BL
; ... TO HERE

; KEEP IN ORDER ...							;032
LOSIZL::.BLKW			; LOW FILESIZE TO MATCH - LSB		;032
LOSIZM::.BLKW			; LOW FILESIZE TO MATCH - MSB		;032
HISIZL::.BLKW			; HIGH FILESIZE TO MATCH - LSB		;032
HISIZM::.BLKW			; HIGH FILESIZE TO MATCH - MSB		;032
SIZFLG::.BLKW			; FLAG OF FILESIZE-SWITCHES SCANNED	;032
FILSIZ::.BLKW	2		; WHERE TO STORE THE FILESIZE		;032
; ... TO HERE								;032

;KEEP NEXT 3 ITEMS IN ORDER
DATELA::.BLKW			; DATE OF LAST ACCESS FROM DISK LOOKUP
DATECR::.BLKW			; DATE OF CREATION
TIMECR::.BLKW			; TIME OF CREATION

LIMITS::.LIMITS			; TO FIND WHERE THE BUFFER GOES
INIBUF	==	LIMITS+2	; INITIAL BUFFER POINTER

BUFFER::.BLKW			; CURRENT BUFFER POINTER

; KEEP THE NEXT 3 ITEMS IN ORDER
DIRPTR::.WORD	0		; POINTER INTO OUTPUT BUFFER
DIRCNT::.WORD	0		; COUNT OF BYTES IN OUTPUT BUFFER
LBLBUF::			; MAGTAPE LABEL BUFFER [SAME AS DIRBUF]
DIRBUF::.BLKB	540.		; DIRECTORY LISTING BUFFER

; KEEP THE NEXT ITEMS IN ORDER
INDINV::.BLKW			; FLAG FOR NESTING INDIRECT COMMAND FILES
INDEXT::.RAD50	"CMD         "
INDPTR::.WORD	0		; POINTER TO CFB
INDCMD::.WORD	0		; NUMBER OF INDIRECTORS OPEN
INDSPC::.BLKW0	5*3		; COMMAND SPEC
INDFIL::.BLKW0	4*6		; THE FILE SPEC ITSELF
INDBUF::.BLKW			; INDIRECT FILE INPUT BUFFER ADDRESS
INDOPN::.WORD	0		; INDIRECT COMMAND FILE IS OPEN FLAG
; TO HERE

; THE FOLLOWING VARIABLES ARE USED FOR HANDLING ANSI
; MAGTAPE FORMATS

IMCHRW::.BLKW			; SAVE MAGTAPE FILE CHARACTERISTICS WORD
IANSCV::.BLKW			; ANSI MT INPUT CONVERSION WORD
IMXREC::.BLKW			; MAXIMUM RECORD LENGTH (D FORMAT)
IBOFST::.BLKW			; BUFFER OFFSET

OMCHRW::.BLKW			; SAVE MAGTAPE FILE CHARACTERISTICS WORD
OANSCV::.BLKW			; ANSI MT OUTPUT CONVERSION WORD
OMXREC::.BLKW			; MAX REC LENGTH (SIZE OF ONE BUFFER)
OBOFST::.WORD	0		; MUST BE ZERO

INUST::	.BLKW			; SAVED INPUT FILE USTAT BYTE
MERGER::.BLKW			; MERGE OPERATION IF -1
TMPFQB::.BLKB	FQBSIZ		; TEMPORARY FIRQB
BLENG::	.BLKW			; BLOCKSIZE TO USE ON MAGTAPE OUTPUT
SC2FLG::.BLKW			; SECOND SWITCH FLAG WORD
DENVAL::.BLKW			; VALUE FOR DENSITY

ZERSPC::.BLKW0	4		; AREA FOR OPENING MAGTAPE DEVICES FOR UTILITY
CCFLAG::.BLKW	0		; FLAG USED IN CONTROL-C TRAPPING CLEAN UP
ERFLAG::.BLKW			; SCRATCH LOCATION USED AS A FLAG
SFUNBK::.BLKW	6		; AREA FOR BUILDING SPECIAL FUNCTION CALLS
MAGERR::.BLKW			; MAGTAPE IOSTAT CODE

RWSAVE::.BLKW	10.		; AREA TO SAVE THE RT11 R/W AREA
INACB::	.BLKB	ACBSIZ		; AN ANSI CONTROL BLOCK FOR INPUT FILE
OUTACB::.BLKB	ACBSIZ		; AN ANSI CONTROL BLOCK FOR OUTPUT FILE
ANINMD::.WORD	0		; INPUT MODE FOR ANSI MAGTAPE
ANOUMD::.WORD	0		; OUTPUT MODE FOR ANSI MAGTAPE
ANSFLG::.WORD	0		; ANSI INPUT TAPE MISCELLANEOUS FLAG WORD:;043
				;  BIT 0: MISC. STORAGE (LOCAL USE ONLY);043
				;  BIT 1-7: AVAILABLE FOR FUTURE USE	;043
				;  BIT 8: TAPE WAS WRITTEN ON A DEC SYSTEM;043
				;  BIT 9-15: AVAILABLE FOR FUTURE USE	;043
SAVWRD::.WORD	0		; MISCELLANEOUS STORAGE WORD		;050
SAVNAM::.BLKW	3		; 3 WORDS TO STORE FILENAME AND TYPE	;052
ODEVFL::.WORD	0		; OUTPUT DEVICE FLAG.			;067
				;	1 = DEVICE WAS SPECIFIED	;067
				;	0 = DEVICE WAS NOT SPECIFIED	;067

.SBTTL	THE MAGTAPE FUNCTION

	ORG	PIPMT

MAGTX0::CLR	R3		; CLEAR THE ARGUMENT
	BR	MAGTXX		;  AND DO THE PROPER THING

MAGTAP::MOV	(R5)+,R3	; GET THE ARG
MAGTXX::MOV	R0,-(SP)	; SAVE R0
	MOV	#SFUNBK+12.,R0	; GET THE POINTER TO A PARAMETER AREA
	CLR	-(R0)		; CLEAR A WORD
	MOV	(R5)+,-(R0)	; SET IN THE SPECIAL FUNCTION CODE
	MOV	R3,-(R0)	;  AND ITS ARGUMENT
	CLR	-(R0)		; CLEAR A WORD
	CLR	-(R0)		;   AND ANOTHER
	MOV	(R5)+,-(R0)	; SET THE CHANNEL/RTFUN SPECIFICATION
	EMT	375		; TRAP TO RT11
	MOV	(SP)+,R0	; RESTORE R0
	MOV	XRB+2,R3	;  AND RETURN PARAMETER
	RETURN	R5		;   AND RETURN EXECUTION

.SBTTL	DOS ZERO OUTPUT MAGTAPE

.ENABL	LSB

WRTZER::MOV	R2,-(SP)	; SAVE R2
	MOV	R3,-(SP)	;  AND R3
	MOV	#3,R2		; SET ITERATION COUNT
10$:	MAGTAPE	OUT,EOF,0	; WRITE AN EOF
	SOB	R2,10$		;  THREE TIMES
	MOV	(SP)+,R3	; RESTORE R3
	MOV	(SP)+,R2	; RESTORE R2
	RETURN			; RETURN TO CALLER

.DSABL	LSB

.SBTTL	ASK FOR NEXT OUTPUT MAGTAPE

.ENABL	LSB

10$:	CALL	BLANKL		;  ELSE, FLAG NO DEVICE GIVEN,1ST BLANK LINE
	SEC			;   FLAG THAT THERE IS NO NEXT VOLUME
	RETURN			;    RETURN TO THE CALLER

20$:	CALL	BLANKL		; PRINT A CARRIAGE RETURN
	.ERRPRT			; PRINT THE ERROR THAT OCCURRED
	BR	50$		; MERGE TO THE OUTPUT CLOSE ROUTINE
		
30$:	PRNTXT	<%Magtape already contains data>
	BR	50$		; REWIND AND OFFLINE THE CURRENT UNIT

40$:	CALL	PRNTXT,R5,NOTANS; SAY THE MAGTAPE IS NOT IN ANSI FORMAT
	.BR	50$		; REWIND AND OFFLINE THE CURRENT UNIT

50$:	MOV	#100$,-(SP)	; SET PHONEY RETURN ADDRESS TO GETMTA CALL
	.BR	MTOCLO		;  AND MERGE TO THE OFFLINE CODE

MTOCLO::MAGTAPE	OUT,RWO,0	; REWIND AND OFFLINE THE TAPE
..MTOC	==	.-4	;**PATCH** CHANGE TO 1377 TO CHANGE RWO TO REW
	.CLOSE	OUT		; CLOSE THE OUTPUT
	RETURN			; RETURN OTHERWISE

60$:	MOVB	MAGERR,FIRQB	; SET THE ERROR CODE IN THE FIRQB
70$:	RSTSER	WRFAIL,<Write failure>,OUT

NXTOUT::REGSCR			; SAVE THE REGISTERS
80$:	MOV	#OUTACB,R0	; GET A POINTER TO THE ACB
	MAGTAPE	OUT,EOF,0	; WRITE AN EOF TO SEPARATE DATA
	MOV	#^REOV,(R0)	; WE ARE WRITING EOV'S
	MOV	OBLKM,ACBCNT(R0); SET THE MSB OF THE FILESIZE SO FAR
	MOV	OBLKL,ACBCNT+2(R0); SET LSB OF THE FILESIZE
	CALL	LBLHD1		; WRITE OUT THE FILE TRAILER
	BCS	60$		; IF AN ERROR OCCURS IT IS FATAL
	CALL	WRTZER		; WRITE 3 EOFS - LOGICAL EOT
90$:	CALL	MTOCLO		; REWIND, OFFLINE, AND CLOSE
	CLR	OUTFLG		; FLAG OUTPUT FILE NO LONGER OPEN	;026
	CALL	PRNTXT,R5,NEWVOL; PRINT STARTING OF PROMPT
	.PRINT	#ANOUTT		; TELL THEM THIS IS THE OUTPUT
	.PRINT	#NEWVL2		; PRINT SECOND PART
100$:	CALL	GETMTA		;  AND GET THE NEW OUTPUT NAME
	BVS	10$		; AN ERROR OCCURRED,RETURN NO VOLUME TO CALLER
	MOV	R1,ZERSPC	; SET THE NEW MAGTAPE NAME
	MOV	R1,OUTSPC	; SET THE DEVICE NAME IN THE INPUT SPEC
	MOV	#FIRQB+FQDEV,R2	; GET A POINTER TO THE DEVICE NAME
	MOV	(R2)+,OUTFQB+FQDEV; SET IT IN THE ACTUAL FIRQB
	MOV	(R2),OUTFQB+FQDEVN; SET THE DEVICE NUMBER
	.LOOKUP	OUT,#ZERSPC	; LOOKUP THE NEW DEVICE NAME
	MOV	#377,OUTFLG	; FLAG OUTPUT FILE IS NOW OPEN		;026
	MOVB	FIRQB,R0	; GET THE ERROR, IF ANY
	BNE	20$		; AN ERROR OCCURRED, PRINT IT
	CALL	RLBLOU		; READ A LABEL FROM THE OUTPUT DEVICE
	BCS	40$		; AN ERROR OCCURRED, ASSUME TAPE NOT ANSI
	CMPLBL	VOL		; THIS MUST BE A VOL
	BNE	40$		; IT ISN'T - GIVE BAD DIRECTORY ERROR
	CMPB	(R0)+,#'1	; THIS MUST BE VOL1  [BUMP POINTER TO VID]
	BNE	40$		; IT ISN'T - GIVE BAD DIRECTORY ERROR
	CALL	CHKVID		; CHECK THE VOLUME ID
	BCS	50$		;  IF NO MATCH THEN CLOSE AND GET NEXT

110$:	CALL	RLBLOU		; READ IN ANTOHER LABEL
	BCS	40$		; AN ERROR OCCURRED, ASSUME TAPE NOT ANSI
	CMPLBL	VOL		; IS THIS A VOL?
	BEQ	110$		; YES, GET ANOTHER LABEL
	CMPLBL	UVL		; IS THIS A USER VOL?
	BEQ	110$		; YES, GET ANOTHER LABEL
	CMPLBL	HDR		; IS THIS A HEADER?
	BNE	40$		; NO, IT MUST BE AN ERROR
	CMPB	(R0)+,#'1	; IT MUST BE HEADER 1
	MOV	#LBLBUF+F1.SEQ,R0; POINT TO THE FILE SEQUENCE NUMBER
	CALL	PACK4D		; MAKE IT INTO BINARY
	TST	R3		; IS THIS A REAL SEQUENCE NUMBER?
	BNE	30$		; YES, THAT IS AN ERROR
	MAGTAPE	OUT,BSP,1	; BACKSPACE 1 (BACK OVER PHONY LABEL)
	INC	OUTACB+ACBFSN	; INCREMENT THE FILE SECTION NUMBER
	MOV	#OUTACB,R0	; GET A POINTER TO THE ACB
	MOV	#^RHDR,(R0)	; WE ARE WRITING HEADERS
	CLR	ACBCNT(R0)	; CLEAR THE BLOCK COUNT FOR HDR'S
	CLR	ACBCNT+2(R0)	; BOTH PARTS
	CALL	LBLHD1		; WRITE THE FILE HEADER
	BCS	60$		; IF AN ERROR OCCURS IT IS FATAL
	MAGTAPE	OUT,EOF,0	; WRITE 1 EOF
	STATUS	OUT		; GET THE MAGTAPE STATUS
	BIT	#M$EOT,R3	; ARE WE AT OR BEYOND EOT?
	BNE	80$		; YES, JUST A BIG WASTE OF TIME
	CALL	BLANKL		; PRINT OUT AN EXTRA LINE FEED FOR SPACING
	CLC			; CLEAR CARRY TO DENOTE THAT WE HAVE A TAPE
	RETURN			; NO, RETURN TO THE CALLER

.DSABL	LSB

.SBTTL	ASK FOR NEXT INPUT MAGTAPE

.ENABL	LSB

10$:	CALL	BLANKL		; PRINT BLANK LINE - SEPARATE PROMPT FROM DATA
	SEC			; SET THE CARRY TO DENOTE THAT WE HAVE NO VOL
	RETURN			;  AND LET READ HANDLE IT AS AN EOF

20$:	MOVB	MAGERR,R0	; GET THE ERROR THAT OCCURRED
	CHKERR	HNGDEV,R0	; IS THE DEVICE HUNG?
	BEQ	50$		; IF SO PRINT THAT ERROR
	CALL	PRNTXT,R5,NOTANS; OTHERWISE PRINT THE NOT ANSI FILE STRUC ERR
	BR	60$		;  AND THEN ASK FOR A DIFFERENT TAPE

30$:	PRNTXT	<%File set (>,NOCR
	MOV	#LBLBUF+F1.FSI,R1; GET A POINTER TO THE FILE SET IDENTIFIER
	MOVB	#200,6(R1)	; SET A STOPPER
	.PRINT	R1		; PRINT THE FSI
	PRINT	<) does not match current file set >,NOCR
	MOV	#INACB+ACBFSI,R0; POINT TO THE CURRENT FILE SET ID
	MOV	#6,R2		; GET SET TO MOVE THE NAME INTO A BUFFER
40$:	MOVB	(R0)+,(R1)+	; MOVE THE FILE SET ID ONE BYTE AT A TIME
	SOB	R2,40$		;   UNTIL DONE
	.PRINT	#LBLBUF+F1.FSI	;  AND PRINT THE CURRENT FILE SET ID
	BR	60$		;  AND GET NEXT TAPE

50$:	CALL	BLANKL		; OUTPUT AN EXTRA LINE FEED
	.ERRPRT			; PRINT THE ERROR TEXT
	BR	60$		; CONTINUE BY ASKING FOR NEXT INPUT DEVICE

NXTIN::	REGSCR			; SAVE ALL THE REGISTERS
	CALL	PRNTXT,R5,NEWVOL; PRINT OPENING
	.PRINT	#ANINPT		; SAY INPUT
	.PRINT	#NEWVL2		; PRINT NEW VL2.
60$:	MAGTAPE	IN,RWO,0	; REWIND AND OFFLINE
..MTIC	==	.-4	;**PATCH** CHANGE TO 1377 TO CHANGE RWO TO REW
	.CLOSE	IN		; CLOSE THE INPUT CHANNEL
	CLR	INFLG		; FLAG INPUT FILE NO LONGER OPEN	;026
	CALL	GETMTA		;  AND GET THE NEW DEVICE NAME
	BVS	10$		; A CONTROL-Z TYPED IMPLIES NO VOLUME
	MOV	R1,ZERSPC	; SET THE NEW MAGTAPE NAME
	MOV	R1,@PTRIN	; SET THE NEW MAGTAPE NAME IN THE INPUT SPEC
	MOV	#FIRQB+FQDEV,R2	; GET A POINTER TO THE DEVICE NAME
	MOV	(R2),INAFQB+FQDEV; SET UP THE ASCII DEVNAME
	MOV	(R2)+,INFQB+FQDEV;   IN BOTH COPIES OF THE FIRQB
	MOV	(R2),INAFQB+FQDEVN; SET THE DEVICE UNIT NUMBER
	MOV	(R2)+,INFQB+FQDEVN;   IN BOTH COPIES OF THE FIRQB
	.LOOKUP	IN,#ZERSPC	; OPEN THAT DEVICE
	MOV	#377,INFLG	; FLAG INPUT FILE IS NOW OPEN		;026
70$:	MOVB	FIRQB,R0	; IS THERE AN ERROR?
	BNE	50$		; YES, REPORT IT
	MAGTAPE	IN,REW,0	; REWIND THE MAGTAPE TO SEARCH FROM BEGINNING
	CALL	RLBLIN		; READ THE LABEL
	BCS	20$		; ANY ERROR IS ALMOST FATAL
	CMPLBL	VOL		; MUST BE VOL
	BNE	20$		; ERROR - ASSUME BAD DIRECTORY
	CMPB	(R0)+,#'1	; MUST BE VOL1  [BUMP POINTER TO VID]
	BNE	20$		; IT ISN'T - ASSUME BAD DIRECTORY ERROR
	CALL	CHKVID		; CHECK THE VOLUME ID
	BCS	60$		;  IF NO MATCH THEN CLOSE AND GET NEW VOLUME
80$:	CALL	RLBLIN		; READ THE NEXT LABEL
	BCS	20$		; REPORT ANY ERROR
	CMPLBL	VOL		; ANOTHER VOL?
	BEQ	80$		; YES, SKIP THIS LABEL

	CMPLBL	UVL		; A UVL?
	BEQ	80$		; YES, SKIP THIS LABEL
	CMPLBL	HDR		; AN HDR?
	BNE	20$		; NO, AND THIS CAN'T BE AN ANSI TAPE
	MOV	#LBLBUF+F1.FSI,R0; GET A POINTER TO THE FILE SET ID
	MOV	#INACB+ACBFSI,R1; GET A POINTER TO THE INPUT FILE SET ID
	MOV	#6,R2		; ALL SIX CHARACTERS MUST MATCH
90$:	CMPB	(R1)+,(R0)+	; DOES THIS ONE MATCH?
	BNE	30$		; NO, PRINT ERROR AND ASK FOR NEW INPUT
100$:	SOB	R2,90$		; LOOP
	MAGTAPE	IN,REW,0	; REWIND IT
	.CLOSE	IN		; CLOSE IT
	MOV	#INACB+ACBNAM,R0; POINT TO THE FILE NAME
	MOV	#WLDNAM,R5	;  AND THE OUTPUT AREA
	CALLX	RAD$FN		; DO THE RADIX FUNCTION FOR A FILE NAME
110$:	MOV	#FIRQB+FQFUN,R0	; POINT TO THE FUNCTION CODE LOCATION
	MOVB	#UU.DIR,(R0)+	; SET THE SPECIAL MAGTAPE DIRECTORY LOOKUP
	MOV	#1,(R0)+	; SET A NON-ZERO INDEX TO AVOID REWIND
	MOV	#-1,(R0)+	; SET SPECIAL MODIFIER TO AVOID TAPE MOTION
	.PRIV,	.UUO		; DO THE CALL
	MOVB	FIRQB,R0	; GET THE ERROR CODE
	BNE	50$		; IF AN ERROR REPORT IT, AND GET NEXT DEVICE
	MOV	#FIRQB+FQNAM1,R0; POINT TO THE FILE NAME TO TEST
	CALL	WLDTST		; CHECK OUT THE FILE NAME
	BEQ	120$		; IT CHECKS OUT, OPEN THE FILE
	MOV	#FIRQB+FQFUN,R0	; POINT TO THE FUNCTION CODE LOCATION AGAIN
	MOVB	#UU.DIR,(R0)+	; SET THE SPECIAL MAGTAPE DIRECTORY LOOKUP
	INC	(R0)+		; SET A NON-ZERO INDEX TO AVOID REWIND
	CLR	(R0)+		; SAY NO SPECIAL MODE, SKIP PAST FILE
	.PRIV,	.UUO		; DO THE FUNCTION
	MOVB	FIRQB,R0	; GET THE ERROR CODE
	BEQ	110$		; LOOP IF NO ERROR
	JMP	50$		; THERE WAS AN ERROR, REPORT AND GET NEXT DEV

120$:	.LOOKUP	IN,#ZERSPC	; OPEN THE DEVICE AGAIN
	MOV	#LBLBUF+F1.SEC,R0; POINT TO THE FILE SECTION NUMBER IN LABEL
	CALL	PACK4D		; PACK THE FILE SECTION NUMBER
	INC	(R1)		; INCREMENT THE FILE SECTION NUMBER IN ACB
	CMP	R3,(R1)		; ARE THEY THE SAME?
	BNE	140$		; NO, SO PRINT ERROR

130$:	MAGTAPE	IN,SKP,-1	; Skip forward until an EOF.		;065
	STATUS	IN		; GET THE STATUS
	BIT	#M$EOF,R3	; ARE WE AT AN EOF?
	BEQ	130$		;  IF WE AREN'T AT EOF SKIP MORE
	CALL	BLANKL		; BLANK A LINE FOR PRETTY PRINT OUT
	CLC			; SAY WE HAVE A VOLUME
	RETURN			; ELSE WISE, RETURN

140$:	MOV	(R1),-(SP)	; SAVE THE FILE SECTION NUMBER EXPECTED
	MOV	R3,-(SP)	; SAVE THE FILE SECTION NUMBER FOUND
	DEC	(R1)		; DECREMENT THE FSN BACK TO CURRENT
	PRNTXT	<%File section out of sequence (>,NOCR
	MOV	(SP)+,R0	; GET THE FSN FOUND
	MOV	#LBLBUF,R5	; GET A POINTER TO A BUFFER
	CALLX	NUM$		; CONVERT IT TO A NUMBER
	MOVB	#200,(R5)+	; SET A STOPPER FOR THE PRINT
	MOV	(SP)+,R0	; GET THE NUMBER WE EXPECTED
	MOV	R5,-(SP)	;  AND SAVE THE POINTER TO THE TEXT IN BUFFER
	CALLX	NUM$		; CONVERT IT TO A NUMBER
	CLRB	(R5)		; SET A STOPPER FOR THE PRINT ROUTINE
	.PRINT	#LBLBUF		; PRINT THE NUMBER
	.PRINT	#NXTSEC		; PRINT CLOSING PAREN,CARRET, AND MORE PROMPT
	.PRINT	(SP)+		; PRINT THE NUMBER EXPECTED
	JMP	60$		;  AND GET NEXT VOLUME

.DSABL	LSB

.SBTTL	GET NEXT ANSI MAGTAPE FROM USER

.ENABL	LSB


10$:	PRNTXT	<%Volume ID must be specified>
	BR	GETMTA

20$:	PRNTXT	<%Illegal device specification>
	.BR	GETMTA

GETMTA::CALL	PRNTXT,R5,NEWVL3; ASK FOR THE INPUT
	CALLX	INPUTX,R5,<83.,DIRBUF>
	BVS	50$		; IF V=1 THEN AN ERROR OCCURRED
	BCS	20$		; AN ERROR OCCURRED (LINE TOO LONG)
	CALL	LMARGN		; MAKE SURE THERE IS A LEFT MARGIN
	CALL	CVT$$B		; CONVERT THE INPUT			;012
	TSTB	(R5)		; IS THE INPUT THERE?
	BEQ	GETMTA		; NO, ASK FOR IT AGAIN
	MOV	R5,R0		; GET A POINTER TO THE ASCIZ STRING
	CLR	FIRQB+FQNAM1	; CLEAR THE VOLUME ID SPOT
	.DOFSS			; DO A FILE STRING SCAN THROUGH RT11
	BIC	#4000,XRB+10	; CLEAR ANY POSSIBLE DEFAULT PROT CODE	;025
	TSTB	FIRQB		; IS THERE AN ERROR?
	BNE	20$		; NO, CONTINUE ON
	TST	XRB+2		; ARE THERE ANY UNSCANNER CHARACTERS?
	BNE	20$		;  YES, THAT IS AN ERROR
	MOV	XRB+12,R4	; CHECK FOR SOMETHING BAD IN THE FILE NAME
.ASSUME	SCWILD	EQ	100000	;
	BMI	20$		; IT WAS BAD, GIVE HIM A DIAGNOSTIC
	BIT	#SC$SWT,R4	; WAS THERE A SWITCH?
	BNE	20$		; YES, THAT IS ALSO ILLEGAL
	MOV	XRB+10,R4	; GET THE FIRST FLAG
.ASSUME	S$DEVX	EQ	100000
	BMI	20$		; ANOTHER ERROR
	BIT	#^C<S$FIL!S$DEV!S$DEVE!S$DEVL>,R4; WAS SPEC LEGEL (DEV:VID)
	BNE	20$		; YES, THAT MEANS AN ERROR
	BR	30$		; SKIP THE OPTIONAL PATCH CODE
..VIDS	==	.-2	;**PATCH** CHANGE TO NOP TO REQUIRE VOLUME ID SPEC
	; **NOTE** that the contents of optional patches are referenced
	;	   at ONETIM: -- changes here mean changes there.
	BIT	#S$FIL,R4	; WAS THERE A VOLUME ID SPECIFIED
	BEQ	10$		; NO, PRINT AN ERROR, AND ASK AGAIN

30$:	MOV	FIRQB+FQNAM1,RWSAVE; SAVE THE VOLUME IF
	MOV	FIRQB+FQNAM1+2,RWSAVE+2;   BOTH WORDS
	CLR	XRB		; CLEAR FIRST WORD OF XRB FOR .LOGS
	.PRIV,	.LOGS		; GET THE INFORMATION ON THE DEVICE
	TSTB	FIRQB		; WAS THERE AN ERROR?
	BNE	20$		; IF SO, SAY IT WAS AN ILLEGAL DEVICE
	CMPB	#MTAHND,XRB+6	; MAKE SURE THIS IS A MAGTAPE
	BEQ	40$		; IT IS, SO FORM THE NAME AND RETURN
	PRNTXT	<%Device must be magtape>
	BR	GETMTA		; AND RESTART

40$:	MOV	#FIRQB+FQDEV,R0	; GET A POINTER TO THE DEVICE NAME
	MOVB	(R0)+,R1	; GET THE FIRST BYTE
	SUB	#'A-1,R1	; MAKE IT A LEGAL RAD 50
	MOVB	(R0)+,R2	; GET THE SECOND BYTE
	SUB	#'A-1,R2	; MAKE IT A LEGAL RAD 50
	MUL	#50,R1		; SHIFT THE CHARACTER UP A POSITION
	ADD	R2,R1		; ADD IN THE NEXT CHARACTER
	MUL	#50,R1		; SHIFT THESE CHARACTERS UP
	TSTB	1(R0)		; WAS THERE A UNIT NUMBER?
	BEQ	50$		; NO THE DEVICE NAME IS NOW SET
	MOVB	(R0),R2		; GET THE UNIT NUMBER
	ADD	#^R  0,R2	; MAKE IT A RAD 50 NUMBER
	ADD	R2,R1		; ADD IT IN
50$:	RETURN			; AND RETURN TO OUR CALLER R1 = DEV IN RAD50

.DSABL	LSB

.SBTTL	CHECK THE VOLUME ID SPECIFIED BY THE USER

;+
; CHKVID - CHECK THE VOLUME ID SPECIFIED BY USER AGAINST LBLBUF
;
;	LBLBUF CONTAINS A VOLUME HEADER LABEL
;	RWSAVE CONTAINS THE VOLUME ID SPECIFIED BY THE USER
;		OR THE FIRST WORD IS ZERO TO SPECIFY ANY VOLUME
;	R0 -> VOLUME ID IN LBLBUF
;
;	CALL	CHKVID
;
;	R0,R1,R5 DESTROYED
;
;	C =  0	IF VOLUME ID MATCHES OR NO VOLUME ID SPECIFIED
;-

.ENABL	LSB

CHKVID::MOV	R0,R1		; COPY THE POINTER TO THE VID
	MOV	#RWSAVE,R0	;  AND GET A POINTER TO THE RWSAVE AREA
	MOV	#RWSAVE+4,R5	;   AND A POINTER TO AN OUTPUT BUFFER
	TST	(R0)		; WAS THERE A VOLUME ID SPECIFIED BY USER?
	BEQ	20$		; NO, SO JUST RETURN, NO ERROR
	CALLX	RAD$W2		; CONVERT THE VID SPECIFIED TO ASCII
	SUB	#6,R5		; POINT BACK TO THE BEGINNING OF THE NAME
	MOV	#6,R0		; SET AN ITERATION COUNT
10$:	CMPB	(R1)+,(R5)+	; CHECK ALL BYTES
	BNE	30$		; ABORT IF AN ERROR, PRINT MESSAGE, AND RETURN
	SOB	R0,10$		;  LOOP UNTIL ALL HAVE BEEN CHECKED
20$:	;CLC			; CARRY SHOULD BE CLEAR FROM COMPARES OR TEST
	RETURN			; RETURN TO CALLER

30$:	PRNTXT	<%Volume ID (>,NOCR
	MOV	#LBLBUF+V1.VID,R0; POINT TO THE VID IN THE LABEL BUFFER
	MOVB	#200,6(R0)	; SET A STOPPER FOR THE PRINT
	.PRINT			; PRINT THE VOLUME ID
	PRINT	<) does not match>
	SEC			; SET THE CARRY BIT TO SAY AN ERROR OCCURRED
	RETURN			;  AND RETURN TO CALLER

.DSABL	LSB

.SBTTL	CLOSE OUTPUT ANSI FILE

;+
; MTCLOT - CLOSE AN OUTPUT ANSI MAGTAPE FILE
;
;	CALLED FROM CLOSEO IN PIP
;
;	CALL	MTCLOT
;
;	ALL REGS PRESERVED
;
;-

.ENABL	LSB

MTCLOT::REGSCR			; SAVE ALL OUR REGISTERS
	TSTB	OUTFQB+F$FLAG	; ARE WE AN ANSI TAPE?
.ASSUME	ANSIMT	EQ	200
	BPL	20$		; NO, LET THE MONITOR HANDLE IT
	MOV	#OUTACB,R0	; GET THE ADDRESS OF THE OUTPUT ACB
	MOV	OBLKL,ACBCNT+2(R0); SET THE LSB OF THE BLOCK COUNT
	MOVB	OBLKM,ACBCNT(R0); SET THE MSB OF THE BLOCK COUNT
	MOV	#^REOF,(R0)	; SAY WE WANT EOF RECORDS WRITTEN
.ASSUME	ACBLBL	EQ	0
	MAGTAPE	OUT,EOF,0	; WRITE TAPE MARK
	CALL	LBLHD1		; WRITE THE TRAILER
	BCS	30$		; AN ERROR OCCURRED
	CALL	WRTZER		; WRITE 3 EOFS
	MOV	#5,R3		; SET AN ITERATION COUNT
10$:	MAGTAPE	OUT,BSP		; BACKSPACE OVER LABELS
	BNE	10$		; IF THERE ARE UNSKIPPED RECORDS DO MORE
20$:	.CLOSE	OUT		; AND FINALLY CLOSE THE MAGTAPE
	BCS	40$		; IF AN ERROR OCCURRED
	RETURN			; RETURN TO OUR CALLER

30$:	MOVB	MAGERR,FIRQB	; POST THE ERROR STATUS
	RSTSER	WRFAIL,<Write failure>,OUT

40$:	RSTSER	CLFAIL,<Close failure>,OUT

.DSABL	LSB

.SBTTL	OPEN AN ANSI FILE FOR INPUT

;+
; MTOPIN - OPEN AN ANSI MAGTAPE FILE SPEC
;
;	CALLED FROM OPENIN IN PIP
;
;	R0 -> INPUT SPEC
;	R1 -> MODE IN R/W AREA
;	R2 =  SCNFLG
;	R4 -> INPUT SPEC
;
;	CALL	MTOPIN
;
;	REGS PRESERVED
;
;	C=1 IF ERROR
;	TAKE SECOND RETURN IF DOS FORMAT.
;-

.ENABL	LSB

10$:	RSTSER	RDFAIL,<Read failure>,IN

MTOPIN::REGSCR			; SAVE ALL THE REGISTERS
	MOV	PTRIN,R0	; GET A POINTER TO THE INPUT SPEC
	.SETFQB			; SET UP THE FIRQB AS IF WE WERE GOING TO OPEN
	MOV	#INAFQB+FQFIL,R1; POINT TO PLACE TO COPY ACTUAL FIRQB
	MOV	#FQBSIZ-FQFIL/2,R2; COUNT OF WORDS TO COPY
	MOV	#FIRQB+FQFIL,R3	;    AND WHERE TO COPY IT FROM (FIRQB)
20$:	MOV	(R3)+,(R1)+	; MOVE A WORD
	SOB	R2,20$		;  UNTIL THERE AIN'T NO MORE TO MOVE
	MOV	#INACB+ACBNAM,R4; POINT TO THE ACBNAME
	MOV	#FIRQB+FQNAM1,R3; POINT TO THE NAME IN THE FIRQB
	MOV	(R3)+,(R4)+	; MOVE IN NAME
	MOV	(R3)+,(R4)+	;   AND SECOND PART
	MOV	(R3)+,(R4)+	;     AND FINALLY THE TYPE
	MOV	FIRQB+FQMODE,ANINMD ; REMEMBER THE MODE VALUE
	MOV	(R0),ZERSPC	; GET THE DEVICE NAME WE ARE OPENING
	.LOOKUP	IN,#ZERSPC	; OPEN UP THE DEVICE
	BCS	80$		;  IN CASE OF AN ERROR, RETURN QUICKLY
	CALL	RLBLIN		; READ THE LABEL
	BCS	10$		; CONTINUE IF NO ERROR

	CMPLBL	HDR		; THIS MUST BE A HEADER, IS IT?
	BNE	70$		;  NO, IT DEFINITELY ISN'T
	MOV	#LBLBUF+F1.FSI,R0; GET A POINTER TO THE FILE SET ID
	MOV	#6,R1		;  AND A COUNT OF BYTES
30$:	MOVB	(R0)+,(R4)+	; SET IT INTO THE ACB
	SOB	R1,30$		;  UNTIL ALL BYTES ARE MOVED
	CALL	PACK4D		; PACK FOUR DECIMAL BYTES
	MOV	R3,(R4)+	; SAVE THE SECTION NUMBER
	CALL	PACK4D		; PACK FOUR DECIMAL BYTES
	MOV	R3,(R4)+	; SAVE THE SEQUENCE NUMBER
	CLR	(R4)+		; CLEAR MSB OF BLOCK COUNT
	CLR	(R4)+		;    AND LSB
	BIC	#ANSDEC,ANSFLG	; CLEAR DEC/ANSI FLAG			;043
	MOV	#LBLBUF+F1.SYS,R0; GET A POINTER TO THE SYSTEM CODE	;043
	CMPLBL	DEC		; LOOK FOR "DEC" IN HDR1		;043
	BNE	35$		; DON'T SET FLAG IF T'AIN'T THERE	;043
	BIS	#ANSDEC,ANSFLG	; DO SET FLAG IF 'TIS			;043
35$:	CALL	RLBLIN		; READ THE NEXT LABEL
	BCC	90$		; CONTINUE IF NO ERROR
	BIT	#M$EOF,R3	; IS THIS AN EOF?
	BEQ	10$		;  FINALLY GIVE AN ERROR (BADDIR)
40$:	MOV	#512.,(R4)	; SET A REASONABLE BLOCK SIZE
	CLR	(R4)+		; AND NO RECORDSIZE
	CLR	INATRC		; NO ATTRIBUTES FROM THIS TAPE
	CLR	IMCHRW		; CLEAR THE CHARACTERISTICS WORD
	CLR	IBOFST		; NO BLOCK OFFSET
	CLR	IMXREC		; NO MAX RECORD SIZE
50$:	MOV	INACB+ACBBSZ,INAFQB+FQBUFL; SET THE INPUT BLOCK SIZE
	MOVB	#MTAHND,INAFQB+FQFLAG; MAKE SURE WE HAVE THE RIGHT HIDX
	CLR	INAFQB+FQSIZ	; INDICATE NO SIZE
	CLRB	INAFQB+FQSIZM	;   IN THE HIGH BYTE ALSO
60$:	STATUS	IN		; GET THE INPUT CHANNEL STATUS
	BIT	#M$EOF,R3	;ARE WE PAST AN EOF?
	BNE	80$		; YES, SO WE ARE POSITIONED ON THE DATA
	MAGTAPE	IN,SKP,-1	; Skip until we hit an EOF.		;065
	BR	60$		; CHECK FOR AN EOF

70$:	SETERR	BADDIR		; INDICATE A BAD DIRECTORY
	SEC			; FLAG THE ERROR
80$:	RETURN			;  AND RETURN

90$:	CMPLBL	UHL		; IS THIS A UHL?
	BEQ	40$		; YES, PRETEND WE DON'T SEE A RECORD
	CMPLBL	HDR		; IS IT A HEADER LABEL?
	BNE	70$		;   NO, SO GIVE BADDIR
	CMPB	(R0)+,#'2	; IT MUST BE HDR2
	BNE	70$		;   IT ISN'T, SO BADDIR
	MOV	#LBLBUF+F2.BLK,R0; POINT TO  THE BLOCK LENGTH FIELD
	CALL	PACK5D		; PACK IT
	MOV	R3,(R4)+	;  AND SET IT INTO THE ACB
	CALL	PACK5D		; PACK THE RECORD LENGTH FIELD
	TST	R3		; Is record length field zero ?
	BEQ	110$		; Yes (record length OK as it stands)
	CMPB	F2.FMT-F2.ATT(R0),#'D ; Did header say "ANSI D" format ?
	BNE	110$		; No (record length OK as it stands)
	CMP	R3,-2(R4)	; Yes: Does record length match block length ?
	BNE	100$		; No (Use record length we have)
	CLR	R3		; Yes: set up length as zero
	BR	110$		;   and continue
100$:	SUB	#4,R3		; Reduce record length by count-field length

110$:				; Now that we have record length..

	MOV	R3,(R4)		;  AND SET IT INTO THE ACB		;046
	CLR	INATRC		; CLEAR THE INPUT ATTRIBUTE COUNT
	BIT	#ANSDEC,ANSFLG	; WAS THIS ANSI TAPE MADE ON DEC SYSTEM?;043
	BEQ	150$		;  NO, IGNORE ATTRIBUTES		;043
	CMPB	(R0),#SPACE	; IS THIS FIELD A SPACE?
	BEQ	150$		;  YES, THAT MEANS NO ATTRIBUTES
	MOV	#INATR,R1	;  AND POINT TO THE AREA WHERE TO PUT THEM
	CLR	R3		; CLEAR AN ACCUMULATOR
120$:	INC	R3		; INCREMENT THE ACCUMLATOR
	MOVB	(R0)+,(R1)	; SET FIRST BYTE
	MOVB	(R0)+,1(R1)	; SET SECOND BYTE
	TST	(R1)+		; IS THE ATTIBUTE NON-ZERO?
	BEQ	130$		;   NO, CONTINUE
	MOV	R3,INATRC	;   YES, SAY WE HAVE SO MANY ATTRIBUTES
130$:	CMP	R3,#6		; DO WE HAVE 7 OR MORE ATTRIBUTES?
	BHI	140$		; YES
	MOV	#7,INATRC	; NO, SAY WE HAVE SEVEN
140$:	CMP	R0,#LBLBUF+F2.CTL-1; ARE WE DONE YET?
	BNE	120$		;  NO, CONTINUE LOOPING
150$:	MOV	#LBLBUF+F2.BFO,R0; POINT TO THE BUFFER OFFSET FIELD
	CALL	PACK2D		; PACK IT
	MOV	R3,IBOFST	;  AND SAVE THE INPUT BUFFER OFFSET
	MOV	(R4)+,IMXREC	; SAVE THE RECORD SIZE			;039
	BNE	155$		; NON-ZERO RECLEN IS OK			;046
	BIS	#200,RMSFLG	; INVOKE /BL MODE IF NO RECLEN		;046
155$:	CLR	(R4)		; CLEAR THE CHARACTERISTICS WORD	;046
	CALL	UNSBYT,R5	; UNPACK THE FORMAT
	  .WORD	RECFMT		; FROM RECFMT CSECT
	  .WORD	LBLBUF+F2.FMT	;  AND WHERE TO GET THE BYTE
	  .WORD	FMTBIS		; BITS TO SET FROM FMTBIS
	CALL	UNSBYT,R5	; UNPACK THE CONTROL
	  .WORD	RECCTL		; FROM RECCTL CSECT
	  .WORD	LBLBUF+F2.CTL	;  AND WHERE TO GET THE BYTE
	  .WORD	CTLBIS		; BITS TO SET FROM CTLBIS
	MOV	(R4),IMCHRW	; SAVE THE MAGTAPE CHARACTERISTICS WORD

	MOV	#INATRC,R1	; GET A POINTER TO THE ATTRIBUTE AREA
	TST	(R1)+		; ARE THERE ANY ATTRIBUTES?
	BNE	50$		; YES, SO WE WILL BELIEVE THEM
	MOV	(R4),R0		; NO, SO LET'S MAKE SOME UP
	ASH	#-14.,R0	; GET THE MAGTAPE CHARACTERISTICS WORD.
	BIC	#^C<3.>,R0	; AND ISOLATE THE RECORD TYPE
	MOVB	MAPTYP(R0),(R1)+; SET THE RECORD TYPE FOR THIS TYPE
.ASSUME	F.RTYP	EQ	0
	BEQ	50$		; IF THE ATTRIBUTE IS ZERO ASSUME NONE
	MOV	(R4),R0		; GET THE CHARACTERISTICS WORD AGAIN.
	ASH	#-12.,R0	; SHIFT IT TO GET THE ATTRIBUTE
	BIC	#^C<3.>,R0	; ISOLATE ONLY THAT INFORMATION
	MOVB	MAPATT(R0),(R1)+; SET THE ATTRIBUTE BYTE
.ASSUME	F.RATT	EQ	1
	MOV	#6,R3		; Clear
160$:	CLR	(R1)+		; first six
	SOB	R3,160$		; attributes
	CLR	(R1)+		; Clear header and bucket size bytes	;069
	MOV	-2(R4),(R1)	; Set the record length			;039
.ASSUME	F.RSIZ	EQ	2
	CMPB	-20(R1),#R.FIX	; Is record format fixed ?
	BNE	170$		; No (skip)
	MOV	(R1)+,-20(R1)	; Yes: set larges-record size
170$:	MOV	#9.,INATRC	; Say we have 9 attributes
	JMP	50$		; Merge to common code

.DSABL	LSB

.SBTTL	TABLES FOR MAPPING ANSI CHARACTERISTICS TO ATTRIBUTES

	TMPORG	DATA

MAPTYP::
	.BYTE	0		; U FORMAT TRANSLATES TO NO RECORD TYPE
	.BYTE	R.FIX		; F FORMAT TRANSLATES TO F FORMAT
	.BYTE	R.VAR		; D FORMAT TRANSLATES TO V FORMAT
	.BYTE	0		; S FORMAT TRANSLATES TO NO RECORD TYPE

MAPATT::
	.BYTE	0		; NO CC TRANSLATES TO NO CC
	.BYTE	FD.EMB		; EMB CC TRANSLATES TO EMB CC
	.BYTE	FD.FTN		; FTN CC TRANSLATES TO FTN CC
	.BYTE	FD.CR		; IMP CC TRANSLATES TO IMP CC

	UNORG

.SBTTL	ANSI LABEL PACKING ROUTINES

.ENABL	LSB

UNSBYT::MOV	(R5)+,R3	; GET THE CSECT POINTER
	MOV	(R5)+,R2	;  AND THE POINTER TO THE BYTE
	MOVB	(R2),R2		; GET THE BYTE TO MATCH
	MOV	(R3)+,R1	;  AND THE NUMBER OF ENTRIES
10$:	CMPB	R2,(R3)+	; IS THIS IT?
	BEQ	20$		;  YES
	SOB	R1,10$		;  NO, RECURSE IF WE MUST
20$:	ASL	R1		; DOUBLE THE INDEX
	ADD	(R5)+,R1	; POINT TO THE PROPER BIT
	BIS	(R1),(R4)	; SET THE BIT
	RETURN	R5		;  AND RETURN

PACK5D::CALL	PACK0D		; TO DO 5, CLEAR AND DO 2
	CALL	PACK2D		; DO 2 MORE
	BR	PACK1D		; DO 1 MORE

PACK4D::MOV	#PACK2D,-(SP)	; RETURN TO PACK2D
PACK0D::CLR	R3		; CLEAR THE ACCUMULATOR
PACK2D::MOV	PC,-(SP)	; DO THE FOLLOWING TWICE
PACK1D::MOVB	(R0)+,R2	; GET A BYTE
	SUB	#'0,R2		; MAKE IT NUMERIC
	MUL	#10.,R3		; SHIFT DECIMAL
	BR	80$		;  AND ACCUMULATE

PACK1R::CLR	R3		; CLEAR THE RAD50 ACCUMULATOR
	CALL	30$		; SCAN 2 CHARACTERS
	CALL	40$		; SCAN 1 MORE
	RETURN			;  AND RETURN, RESULT IS IN R3

30$:	MOV	PC,-(SP)	; DO THE FOLLOWING TWICE
40$:	MOVB	(R0),R2		; GET THE BYTE
	SUB	#'A,R2		; MAKE A-Z INTO 0-31
	CMP	R2,#'Z-'A	; WITHIN RANGE?
	BLOS	60$		; YES
	SUB	#'0-'A,R2	; MAKE 0-9 INTO 0-9
	CMP	R2,#'9-'0	; WITHIN RANGE?
	BLOS	50$		; YES
	CLR	R2		; NO, SUBSTITUTE A SPACE FOR THE CHARACTER
	BR	70$		;  AND PACK A SPACE

50$:	ADD	#36-1,R2	; CORRECT THE NUMERICS
60$:	CMPB	(R2)+,(R0)+	; BUMP LETTER OR DIGIT, ADVANCE POINTER
70$:	MUL	#50,R3		; SHIFT RADIX 50
80$:	ADD	R2,R3		; ADD IN THE NEW LOW DIGIT
	RETURN			;  AND RETURN

	TMPORG	DATA
.NLIST	BEX
	.EVEN

RECFMT::
	.WORD	4		; FOUR TYPES
	.BYTE	'S,'D,'F,'U	; THE TYPES

FMTBIS::
	.WORD	0		; UNDEFINED IS U
	.WORD	0		; U
	.WORD	MC$FIX		; F
	.WORD	MC$VAR		; D
	.WORD	MC$SPN		; S

RECCTL::
	.WORD	3		; THREE TYPES
	.BYTE	SPACE,'A,'M	; THE TYPES
	.EVEN

CTLBIS::
	.WORD	0		; UNDEFINED IS M
	.WORD	0		; M
	.WORD	MC$FTN		; A
	.WORD	MC$IMP		; IMPLIED
	UNORG

.DSABL	LSB

.ENABL	LSB

SETCHW::CLR	R0		; CLEAR R0 (OMCHRW)
	TST	OUTATC		; ARE THERE ATTRIBUTES ON THE OUTPUT FILE
	BEQ	60$		; NO, 
	BIT	#4000,OUTATR	; Is the NOSPAN bit set?		;060
	BEQ	5$		; No, continue normally			;060
	MOV	#200,RMSFLG	; Yes, force block mode, and override	;060
				;  any other mode that was set		;060
5$:	TSTB	RMSFLG		; ARE WE FORCING A BLOCK MODE?		;060
.ASSUME	CV.BLK	EQ	200
	BMI	60$		; YES, SO DON'T DO THE FANCY RECORDS
	MOV	#OUTATR,R5	; GET A POINTER TO THE ATTRIBUTES
	CLR	R0		; CLEAR AN ACCUMULATOR FOR THE ATTRIBUTES
	MOV	#MAPTYP+3,R4	; GET A POINTER TO THE TYPES
10$:	BITB	(R5),-(R4)	; IS THIS IT?
	BNE	20$		; YES
	CMP	R4,#MAPTYP	; ARE WE DONE YET?
	BNE	10$		; NO
20$:	SUB	#MAPTYP,R4	; GET THE RECORD FORMAT
	MOV	R4,R0		; COPY IT
	ASL	R0		; ASL
	ASL	R0		;  TWICE
	MOV	#MAPATT+4,R4	; GET A POINTER TO THE CARRIAGE CONTROL
	TSTB	(R5)+		; BUMP POINTER TO NEXT ATTRIBUTE
30$:	BITB	(R5),-(R4)	; IS THIS BIT SET
	BNE	40$		; YES, THIS IS IT			;048
	CMP	R4,#MAPATT	; ARE WE DONE YET?
	BNE	30$		; LOOP UNTIL DONE
40$:	SUB	#MAPATT,R4	; GET THE TYPE
	ADD	R4,R0		; ADD IN THE CARRIAGE CONTROL
	ASH	#12.,R0		; SHIFT IT INTO POSITION
	TSTB	(R5)+		; POINT TO THE RECORD SIZE
	TST	16(R5)		; Are we pointing where we should ??
	BEQ	50$		; Yes (skip)
	ADD	#16,R5		; No: increment attribute pointer
50$:
	MOV	(R5),OMXREC	; SAVE RECORDSIZE IN A FULL WORD	;044
60$:	MOV	R0,FIRQB+FQCLUS	; NOW SET THE CHARACTERISTICS WORD IN FQCLUS
	MOV	R0,OMCHRW	; SET IT HERE ALSO
	RETURN

.SBTTL	OPEN AN ANSI FILE FOR OUTPUT

;+
; THE FOLLOWING CONDITIONS GOVERN THE ANSI MAGTAPE HANDLING
;
;	WHENEVER A FILE IS OPENED FOR OUTPUT THE TAPE MUST BE POSITIONED
;	ON A VALID VOL1, HDR1, OR EOF1 LABEL. THE FOLLOWING LABEL SEQUENCES
;	ARE PROCESSED BY THE MTENTR ROUTINE. A LABEL TYPE ENCLOSED IN BRACKETS
;	IS OPTIONAL (I.E. IT MAY APPEAR, BUT WILL BE IGNORED). *MARK* DENOTES
;	A TAPE MARK. AN ARROW MARKS LABELS WHERE THE TAPE MAY BE POSITIONED
;	BEFORE A FILE OPEN. A LABEL TYPE ENCLOSED IN SQUARE BRACKETS IS SIMI-
;	OPTIONAL, IF FOUND IT IS PROCESSED, IF NOT DEFAULT VALUES ARE ASSUMED.
;
;	RECORD ON TAPE		DESCRIPTION
;	---------------		-----------
;
; ->	  VOL1			VOLUME LABEL #1 - MUST BE PRESENT
;	(VOL2-9)		VOLUME LABELS 2-9, NOT NECESSARY
;	(UVL1-9)		USER VOLUME LABELS, NOT NECESSARY
; ->	  HDR1			HEADER FOR FIRST FILE - MUST BE PRESENT
;	 [HDR2]			HEADER #2 - MAY OR MAY NOT BE PRESENT
;	(HDR3-9)		HEADER LABELS 3-9, NOT NECESSARY
;	(UHL1-9)		USER HEADER LABELS
;	 *MARK*			TAPE MARK TO SEPARATE LABELS AND DATA
;	  DATA			MAY OR MAY NOT BE PRESENT, NOT NECESSARY
;	 *MARK*			TAPE MARK TO SEPARATE LABELS AND DATA
; ->	  EOF1			EOF FOR FIRST FILE - MUST BE PRESENT
;	(EOF2-9)		EOF LABELS 2-9, NOT NECESSARY
;	(UTL1-9)		USER TRAILER LABELS
;	 *MARK*			TAPE MARK TO SEPARATE LABEL GROUPS
;	--------		   MORE FILES
; ->	  HDR1			HEADER FOR NTH FILE - MUST BE PRESENT
;	 [HDR2]			HEADER #2 - MAY OR MAY NOT BE PRESENT
;	(HDR3-9)		HEADER LABELS 3-9, NOT NECESSARY
;	(UHL1-9)		USER HEADER LABELS
;	 *MARK*			TAPE MARK TO SEPARATE LABELS AND DATA
;	  DATA			MAY OR MAY NOT BE PRESENT, NOT NECESSARY
;	 *MARK*			TAPE MARK TO SEPARATE LABELS AND DATA
; ->	  EOV1			EOV FOR NTH FILE - MUST BE PRESENT
;	(EOV2-9)		EOV LABELS 2-9, NOT NECESSARY
;	(UTL1-9)		USER TRAILER LABELS
;	 *MARK*			TAPE MARK TO SEPARATE LABEL GROUPS
;	 *MARK*			TAPE MARK TO DENOTE END OF FILES
;-

;+
; MTENTR - OPEN AN ANSI MAGTAPE FILE SPEC
;
;	CALLED FROM ENTER IN PIP
;
;	CALL	MTENTR
;
;	REGS PRESERVED
;
;	C=1 IF ERROR
;	TAKE SECOND RETURN IF DOS FORMAT.
;-

70$:	ERROR	<Blocksize on ANSI output tape is too small>

80$:	SETERR	BADDIR
90$:	RSTSER	LKFAIL,<Lookup failure>,OUT

MTENTR::REGSCR			; SAVE ALL THE REGISTERS
	MOV	#OUTSPC,R0	; IF WE GET HERE WE HAVE AN ANSI TAPE
	.SETFQB			; SET UP THE FIRQB
	CALL	SETCHW		; SET THE CHARACTERISTICS WORD FROM ATTRIBUTES
	MOV	#OUTACB,R5	; POINT TO THE ACB
	MOV	#FIRQB+FQNAM1,R4; POINT TO THE NAME IN THE FIRQB
	MOV	#^RHDR,(R5)+	; SET THE TYPE OF LABEL WE WANT TO WRITE
	MOV	(R4)+,(R5)+	; SET THE
	MOV	(R4)+,(R5)+	;   NAME
	MOV	(R4)+,(R5)+	;     INTO THE ACB
	CMP	(R4)+,(R4)+	; BUMP TO THE FQMODE PARAMETER
.ASSUME	FQMODE	EQ	FQEXT+6
	MOV	(R4)+,ANOUMD	; SET THE OUTPUT MODE
	MOV	#OUTACB+ACBCNT,R5; POINT TO THE FILE SIZE
	CLR	(R5)+		; CLEAR THE MSW
	CLR	(R5)+		; CLEAR THE LSW
	MOV	BLENG,(R5)	; SET THE BUFFER SIZE
	BNE	100$		; IF THERE IS A BUFFER SIZE CONTINUE
	MOV	#512.,(R5)	; OTHERWISE, USE A REASONABLE SIZE
100$:	TST	(R5)+		; BUMP THE POINTER TO POINT TO THE RECORDSIZE
	MOV	OMXREC,(R5)+	; SET RECORD SIZE			;044
	MOV	FIRQB+FQCLUS,(R5); SET THE CHARACTERISTICS WORD		;044
	TST	-(R5)		; POINT R5 TO RECORD SIZE		;044
	MOV	OUTSPC,ZERSPC	; SET UP TO OPEN THE MAGTAPE

	.LOOKUP	OUT,#ZERSPC	; OPEN IT
	BCS	90$		; IF AN ERROR OCCURRED ABORT!
110$:	CALL	RLBLOU		; READ IN A LABEL
	BCS	80$		; IF AN ERROR OCCURRED, REPORT BADDIR
	CMPLBL	VOL		; IS THIS A VOL
	BEQ	120$		; YES, SKIP INTO VOLUME HEADER LOOP
	CMP	(R0),#"EO	; IS THIS AN EOF OR EOV?
	BEQ	160$		; YES, GO TO EOF/EOV LOOP
	BR	150$		; NEITHER, THIS IS A BADDIR ERROR

120$:	CALL	RLBLOU		; READ A LABEL
	BCS	80$		; BADDIR IF AN ERROR OCCURRED
	CMPLBL	VOL		; IS THIS ANOTHER VOL?
	BEQ	120$		; YES, SKIP IT AND READ ANOTHER
	CMPLBL	UVL		; IS THIS A USER VOLUME LABEL
	BNE	150$		; NO, IT MUST BE A HEADER, GO TO HEADER LOOP
	BR	120$		; YES, SKIP IT AND READ ANOTHER

130$:	CALL	RLBLOU		; READ IN A HDR LABEL
	BCC	150$		; IF NO ERROR, CHECK FOR PROPER LABEL
	BIT	#M$EOF,R3	; ARE WE AT  TAPE MARK?
	BNE	190$		; YES, CREATE THE FILE HERE
140$:	BR	80$		; OTHERWISE, A BADDIR ERROR

150$:	CMPLBL	HDR		; THIS MUST BE AN HDR LABEL
	BNE	80$		; IT ISN'T, GIVE BADDIR ERROR
	CMPB	(R0)+,#'1	; IT MUST BE HDR 1
	BNE	80$		; IT ISN'T
	CALL	FSISET		; SET THE FSI AND FILE SEQUENCE NUMBER
	BEQ	190$		; IF SEQUENCE NUMBER IS ZERO, CREATE HERE
	CALL	SKIP		; SKIP TO THE TAPE MARK AFTER HEADERS

	CALL	SKIP		; SKIP TO THE TAPE MARK AFTER DATA
	CALL	RLBLOU		; READ IN A LABEL, MUST BE EOF OR EOV
	BCS	80$		; ANY ERROR IS BADDIR
160$:	CMPLBL	EOF		; IS IT AN EOF?
	BNE	180$		; NO, IT MUST BE AN EOV
	CMPB	(R0)+,#'1	; YES, IT MUST BE EOF1
	BNE	80$		; OTHERWISE AN ERROR
	CALL	FSISET		; SET UP ALL NEEDED INFOORMATION
	BEQ	170$		; IF THIS IS SEQUENCE NUMBER 0 THEN REWIND
	CALL	SKIP		; SKIP TO THE TAPE MARK AFTER EOF LABELS
	BR	130$		;  AND CHECK FOR HDR OR SECOND TAPE MARK

170$:	MAGTAPE	OUT,REW,0	; FOUND EOF OF FILE SEQUENCE 0, REWIND
	BR	110$		;  AND GO TO VOLUME LOOP

180$:	CMPLBL	EOV		; IS THIS AN EOV LABEL?
	BNE	80$		; NO, BADDIR
	SETERR	NOROOM		; YES, NOROOM ERROR
	BR	90$		;

190$:	MAGTAPE	OUT,BSP,1	; BACKSPACE OVER TAPE MARK OR PHONEY HEADER
	MOV	#OUTACB,R0	; POINT TO THE ACB
	INC	ACBSQN(R0)	; INCREMENT THE FILE SEQUENCE NUMBER
	MOV	#1,ACBFSN(R0)	; SET THE FILE SECTION NUMBER TO 1
	CALL	LBLHD1		; WRITE THE FILE HEADER
	BCS	140$		; REPORT ANY ERROR
200$:	MAGTAPE	OUT,EOF,0	; WRITE AN EOF ON THE OUTPUT
	STATUS	OUT		; CHECK THE STATUS
	BIT	#M$EOT,R3	; ARE WE BEYOND EOT?
	BEQ	210$		; NO, RETURN ALL SET UP
	CALL	NXTOUT		; YES, GET NEXT OUTPUT VOLUME
210$:	RETURN			;  AND RETURN

.DSABL	LSB

.SBTTL	SET INFORMATION INTO ACB

;+
; FSISET - SET INFORMATION INTO THE OUTACB
;
;	LBLBUF CONTAINS A VALID HDR1, OR EOF1
;
;	CALL	FSISET
;
;	R0 = GARBAGE
;	R3 = FILE SEQUENCE NUMBER FOUND IN LABEL
;	R5 = GARBAGE
;
;	ACB UPDATED WITH FILE SEQUENCE NUMBER AND FILE SET ID
;	CONDITION CODES SET FROM MOV FILESEQNO,FOO
;-

FSISET::MOV	#OUTACB+ACBFSI,R5; GET A POINTER TO THE ACB FSI
	MOV	#LBLBUF+F1.FSI,R0; GET A POINTER TO THE FSI IN THE LABEL
	MOV	#6,R3		;   AND THE NUMBER OF BYTES TO COPY
10$:	MOVB	(R0)+,(R5)+	; SET THE BYTES
	SOB	R3,10$		;  UNTIL ALL ARE SET
	MOV	#LBLBUF+F1.SEQ,R0; POINT TO THE FILE SEQUENCE NUMBER
	CALL	PACK4D		; PACK THE FILE SEQUENCE NUMBER
	MOV	R3,OUTACB+ACBSQN; SET THE LAST SEQ NUMBER INTO THE ACB
	RETURN			;  AND RETURN

.SBTTL	SKIP TO NEXT TAPE MARK ON OUTPUT CHANNEL

;+
; SKIP - SKIPS RECORDS AND POSITIONS JUST AFTER NEXT TAPE MARK
;
;	CALL	SKIP
;
;	R3 = MAGTAPE STATUS
;-

SKIP::	MAGTAPE	OUT,SKP,-1	; Skip to an EOF.			;065
	STATUS	OUT		; GET THE STATUS
	BIT	#M$EOF,R3	; ARE WE AT AN EOF?
	BEQ	SKIP		; NO, GO THROUGH ROUTINE AGAIN
	RETURN			; RETURN

.SBTTL	CHECK ANSI LABEL TYPE

;+
; CMPLBL - COMPARE CURRENT LABEL IN BUFFER WITH SPECIFIC TYPE
;
;	R0 -> LBLBUF
;
;	CALL	CMPLBL,R5
;	.RAD50	"HDR"		(LABEL TYPE, HDR,UVL,VOL,EOV,EOF)
;
;	IF MATCH:
;	R0 -> LBLBUF+3
;	Z = 1	(BEQ)
;
;	IF NO MATCH:
;	R0 -> LBLBUF
;	Z = 0	(BNE)
;-

CMPLBL::CALL	PACK1R		; PACK THE HEADER LABEL TYPE
	CMP	(R5)+,R3	; DO WE HAVE A MATCH
	BEQ	10$		; IF SO, RETURN
	MOV	#LBLBUF,R0	; NO MATCH, RESET LABEL BUFFER POINTER
	;CLZ			; ACCOMPLISHED BY LBLBUF POINTER RESET
10$:	RETURN	R5		; RETURN WITH CONDITION SET

.SBTTL	FIND OUT WHAT LABEL TYPE IS DESIRED FOR OUTPUT MAGTAPE

;+
; LBLTYP - FIGURE OUT WHETHER OR NOT WE HANDLE THIS LABEL  TYPE
;
;	CALL	LBLTYP,R5,POINTER
;
;	C=1 IF AN ERROR OCCURRED
;	OUTFQB @ F$FLAG UPDATED WITH PROPER ANSI FLAG
;-

.ENABL	LSB

LBLTYP::REGSCR			; SAVE ALL REGISTER COROUTINELY
	MOV	OUTFQB+FQMODE,R1; GET THE OUTPUT FIRQB CLUSTERSIZE SPEC
	BIT	#16384.,R1	; DO WE HAVE AN OVER RIDE OF LABEL DEFAULT
	BEQ	30$		; NO, DO IT THE HARD ,SLOW, AND DIRTY WAY
	BIT	#8192.,R1	; IS IT AN ANSI LABEL?
	BNE	40$		; YES, SET THE ANSI BIT
10$:	BIC	#ANSIMT,OUTFQB+F$FLAG; CLEAR THE ANSI INDICATOR
20$:	RETURN			;  AND RETURN

30$:	MOV	OUTSPC,ZERSPC	; SET TO OPEN UP THE MAGTAPE NFS
	.LOOKUP	TMP,#ZERSPC	; LOOKUP THE MAGTAPE NFS
	BCS	20$		;  AN ERROR OCCURRED, RETURN IT TO THE CALLER
	MOV	#JFSYS,XRB	; SET TO REGAIN PRIVS
	.PRIV,	.SET		;  WE GOT 'EM IF WE HAD 'EM
	PEEK	#1010		; PEEK FOR OUR JDB
	PEEK			; PEEK FOR OUR IOB
	MOVB	FIRQB+FQFIL,R1	; GET THE CHANNEL NUMBER
	BIC	#^C<76>,R1	; CLEAR ANY HARMFUL BITS
	ADD	R1,XRB		; ADD IT TO THE XRB
	PEEK			; PEEK FOR OUR DDB
	ADD	#30,XRB		; ADD IN OFFSET TO THE LABEL DEFAULT
	PEEK			; PEEK FOR OUR LABEL DEFAULT
	MOVB	XRB+1,-(SP)	; SAVE THE LABEL DEFAULT FLAG
	MOV	#JFSYS,XRB	; NOW DROP PRIVS
	.PRIV,	.CLEAR		;  AND DROPPED!
	.CLOSE	TMP		; CLOSE THE MAGTAPE TO AVOID ANY OPEN FILES
	TSTB	(SP)+		; CHECK FOR LABEL DEFAULT
	BEQ	10$		; EQUAL MEANS DOS FORMAT
40$:	BIS	#ANSIMT,OUTFQB+F$FLAG; TAPE IS ANSI FORMAT
	RETURN			;  FLAG IT AND LEAVE

.DSABL	LSB

.SBTTL	MAKE ANSI HEADER LABEL HDR1, EOF1, OR EOV1

.ENABL	LSB

LBLHD1::REGSCR			; SAVE REGISTERS
	CALL	LBLCLR		; CLEAR OUT THE GARBAGE IN THE BUFFER
;	ADD	#ACBTYP,R0	; POINT TO THE LABEL TYPE
.ASSUME	ACBLBL	EQ	0
	CALL	UNPRD1		; SHOVE IN THE LABEL TYPE
	MOVB	#'1,(R5)+	; SAY THIS IS LABEL TYPE 1
	CALL	UNPRD2		; UNPACK FILE NAME
	MOVB	#'.,(R5)+	; SET TERMINATOR FOR FILE NAME
	CALL	UNPRD1		; UNPACK THE FILE TYPE
	MOV	#LBLBUF+F1.FSI,R5; POINT TO THE FILE SET IDENTIFIER
	MOV	#6,R1		; DO THE NEXT THING 6 TIMES
10$:	MOVB	(R0)+,(R5)+	; MOVE IN THE BYTES
	SOB	R1,10$		; UNTIL DONE
	UNPNUM	4		; UNPACK THE FILE SECTION NUMBER
	UNPNUM	4		; UNPACK THE FILE SEQUENCE NUMBER
	MOVTXT	<000100>,NOCR	; MOVE IN THE GENERATION NUMBER/VERSION NUMBER
	CALL	UNPDT2		; SET THE CREATION DATE & EXPIRATION DATE
	TSTB	(R5)+		; SKIP THE ACCESSIBILITY (ALREADY SPACE)
	UNPDBL	6		; UNPACK THE BLOCK COUNT
	MOVTXT	<DECRSTS/E>,NOCR; MOVE IN THE SYSTEM CODE
	MOVB	R4,(R5)+	; PUT IN ASPACE TO COMPENSATE FOR MOVTXT LOSS
	CALL	WLBLOU		; WRITE THE LABEL
	BCC	LBLHD2		; WRITE NEXT LABEL IF NO ERROR
	RETURN			;  ELSE RETURN

.SBTTL	MAKE ANSI HEADER LABEL HDR2, EOF2, OR EOV2

LBLHD2::MOV	TOS.R0(SP),R0	; RESTORE THE ACB POINTER
	CALL	LBLCLR		; CLEAR OUT THE LABEL BUFFER
;	ADD	#ACBLBL,R0	; GET THE TYPE OF LABEL
.ASSUME	ACBLBL	EQ	0
	CALL	UNPRD1		; CONVERT IT TO ASCII IN THE LABEL BUFFER
	MOVB	#'2,(R5)+	; SET IN LABEL Q2
	ADD	#ACBBSZ-ACBLBL-2,R0 ; POINT TO BLOCK LENGTH
	TSTB	(R5)+		; BUMP BY ONE BYTE TO POINT TO PROPER SPOT
	UNPNUM	5		; UNPACK THE BLOCK LENGTH
	MOV	(R0),R4		; Save the record length pointer
	MOV	2(R0),R2	; Get modifier character
	ASH	#-14.,R2	; Shift right - we're looking for MC$FIX, 40000
	CMP	R2,#-2		; Fixed-length records ?
	BNE	30$		; No (skip)
	TST	(R0)		; Yes: do we have a record length ?
	BNE	20$		; Yes (go add count length)
	MOV	-2(R0),(R0)	; No: use blocksize, then
	BR	30$		; (skip count-length add)
20$:	ADD	#4,(R0)		; Increment rec lnth to reflect count field
30$:	MOV	R0,R2		; Save pointer to record length
	UNPNUM	5		; UNPACK THE RECORD LENGTH
	MOV	R4,(R2)		; And save record length as we used it
	CALL	SETBYT,R1	; SET THE FORMAT CHARACTER
	  .WORD	-14.		; SHIFT FOR THESE BITS
	  .WORD	LBLBUF+F2.FMT	; WHERE TO STICK IT
	  .BYTE	'U,'F,'D,'S	; FORMATS 0,1,2,3
	CALL	SETBYT,R1	; SET THE MODIFIER CHARACTER
	  .WORD	-12.		; SHIFT FOR THESE BITS
	  .WORD	LBLBUF+F2.CTL	; WHERE TO STICK IT
	  .BYTE	'M,'A,SPACE,SPACE; MODIFIERS 0,1,2,3

	BIT	#140000,(R0)	; SET THIS F OR D FORMAT?
	BNE	60$		; IF SO, DON'T OUTPUT ATTRIBUTES TO HDR2
	BIT	#NOATT,SC2FLG	; DOES THE USER WANT ATTRIBUTES ON OUTPUT?
	BNE	60$		; NO, SO SKIP THE ATTRIBUTE COPY
	MOV	#OUTATC,R1	; POINT TO THE OUTPUT ATTRIBUTE COUNT
	MOV	(R1)+,R2	; GET THE COUNT, BUMP R1 POINTER TO ATTRIBUTES
	BEQ	60$		; IF NO ATTRIBUTES, LEAVE ALL SPACES
	ASL	R2		; DOUBLE COUNT FOR A BYTE COUNT
40$:	MOVB	(R1)+,(R5)+	; MOVE IN THEM ATTRIBUTES
	SOB	R2,40$		; UNTIL WE CAN'T MOVE 'EM NO MORE
50$:	CMP	R5,#LBLBUF+F2.CTL; ARE WE POINTING TO F2.CTL?
	BEQ	60$		; YES, SO WE ARE DONE
	CLRB	(R5)+		; NO, CLEAR A BYTE
	BR	50$		;  AND LOOP

60$:	MOV	#LBLBUF+F2.BFO,R5; POINT TO THE BUFFER OFFSET FIELD
	MOV	#"00,(R5)+	; MAKE SURE THAT BUFFER OFFSET IS ZERO
	.CALLR	WLBLOU		; AND RETURN (THROUGH WLBLOU)

.DSABL	LSB

.SBTTL	OUTPUT ANSI LABEL PROCESSING

.ENABL	LSB

WLBLOU::.WRITW	OUT,#LBLBUF,#40.,#0; WRITE OUT THE BUFFER
	MOVB	FIRQB,MAGERR	; SAVE THE IOSTS
	BEQ	MAGSTO		; IF THERE WASN'T RETURN THE STATUS
	CHKERR	NOROOM		; IS THIS A NOROOM?
	BNE	20$		; NO, SO THIS IS A REAL ERROR
MAGSTO::MAGTAPE	OUT,UNT,0	; GET MAGTAPE STATUS FOR OUTPUT
	CLRB	FIRQB		;  MAKE SURE THERE IS NO ERROR FLAG
	;CLC			; CLEARED BY ABOVE CLR
	RETURN

RLBLOU::.READW	OUT,#LBLBUF,#39.,#0; READ IN THE LABEL FROM CHANNEL OUT
	MOV	#LBLBUF,R0	; SET THE ADDRESS OF THE LABEL BUFFER
	TSTB	FIRQB		; TEST IOSTS
	BEQ	10$		; IF NO ERROR, THAT IS AN ERROR
	CHKERR	MAGRLE		; IS IT A MAGRLE?
	BEQ	MAGSTO		; YES, MAGRLE IS EXPECTED, RETURN NO ERROR
10$:	SETERR	BADDIR,MAGERR	; SET THE BADDIR ERROR INTO MAGERR
20$:	STATUS	OUT		; GET THE STATUS
	MOVB	MAGERR,FIRQB	; RESET THE ERROR CODE
	SEC			; SET THE CARRY TO FLAG AN ERROR
	RETURN			;  AND RETURN

.SBTTL	INPUT ANSI LABEL PROCESSING

RLBLIN::.READW	IN,#LBLBUF,#39.,#0; READ IN THE LABEL FROM CHANNEL IN
	MOV	#LBLBUF,R0	; SET THE ADDRESS OF THE LABEL BUFFER
	MOVB	FIRQB,MAGERR	; SAVE THE IOSTS
	BEQ	30$		; IF NO ERROR, THAT IS AN ERROR
	CHKERR	MAGRLE		; IS THERE A MAGRLW?
	BEQ	MAGSTI		; YES, THAT IS ALSO NO ERROR
30$:	SETERR	BADDIR,MAGERR	; SAY IT IS A BAD DIRECTORY
40$:	STATUS	IN		; GET THE STATUS
	MOVB	MAGERR,FIRQB	; SET THE ERROR CODE
	SEC			; SET THE ERROR FLAG
	RETURN			;   AND RETURN

MAGSTI::MAGTAPE	IN,UNT,0	; GET MAGTAPE STATUS FOR INPUT
	CLRB	FIRQB		; MAKE SURE THERE IS NO ERROR CODE
	;CLC			; CLEARED BY ABOVE CLEAR
	RETURN			; RETURN

.DSABL	LSB

.SBTTL	UTILITY UNPACKING ROUTINES FOR TAPE LABELS

UNPDT2::MOV	PC,-(SP)	;UNPACK THE DATE TWICE
	MOVB	#SPACE,(R5)+	;DATE STARTS WITH A BLANK
	.PRIV,	.DATE		;GET THE DATE FROM RSTS
	MOV	XRB,R3		; AND PUT IT IN R3
	MOV	R0,-(SP)	;SAVE R0
	MOV	#XRB,R0		;POINT AT THE NUMBER
	UNPNUM	5		;CONVERT IT
	MOV	(SP)+,R0	;RESTORE R0
	MOVB	-5(R5),R3	;GET TENS OF YEAR
	ADD	#7,R3		;CORRECT IT FOR 1970
	MOVB	R3,-5(R5)	;RESET IT
	RETURN

; RAD50 CONVERSIONS

UNPRD2::MOV	PC,-(SP)	; DO THE FOLLOWING TWICE
UNPRD1::MOV	(R0)+,R3	; GET THE WORD TO CONVERT
	CALL	10$,R0,<50*50,50,1> ; DO THE CONVERSION
.ASSUME	<<50*50!50!1>&200> EQ 0	; TERMINATES ON NEGATIVE BYTE VALUE (RETURN)
	RETURN

10$:	CLR	R2		; CLEAR THE HIGH ORDER
	DIV	(R0)+,R2	;  AND DIVIDE
	BEQ	30$		; 0 IS SPACE, IGNORE IT
	ADD	#100,R2		; GUESS AT ALPHA CORRECTION
	CMP	R2,#'Z		; REALLY ALPHA?
	BLOS	20$		; YES
	ADD	#'0-36-100,R2	; NO, CORRECT FOR DIGIT
20$:	MOVB	R2,(R5)+	; STORE THE CHARACTER
30$:	TSTB	(R0)		; MORE? (ANTON'S MAGIC, TERMINATES ON RETURN)
	BPL	10$		; YES
	RETURN	R0		; NO

LBLCLR::MOV	#LBLBUF+80.,R5	; GET A POINTER TO THE LABEL BUFFER (FROM TOP)
	MOV	#SPACE*400+SPACE,R4; GET A COUPLE OF SPACES IN R4
	MOV	#40.,R3		;   AND THE NUMBER OF SPACES TO CLEAR IN R3
10$:	MOV	R4,-(R5)	; SHOVE TWO SPACES INTO THE LABEL BUFFER
	SOB	R3,10$		; LOOP UNTIL ALL DONE
	RETURN			; R3 = 0, R4 = SPACE/SPACE, R5 -> LBLBUF

SETBYT::MOV	(R0),R2		; GET THE CHARACTERISTICS WORD
	ASH	(R1)+,R2	; SHIFT TO GET RELEVANT BITS
	BIC	#^C<3>,R2	; ISOLATE TWO BITS
	MOV	(R1)+,R4	; POINT TO THE PROPER BYTE IN THE BUFFER
	ADD	R1,R2		; POINT TO THE PROPER BYTE TO SET
	MOVB	(R2),(R4)	; SET THE BYTE, PROPERLY
	CMP	(R1)+,(R1)+	; BUMP THE RETURN ADDRESS
	RETURN	R1		;  AND RETURN PROPERLY

.SBTTL	Version-Message Setup (one-time routine)
.SBTTL	Core-Allocation Setup (one-time routine)
.SBTTL	One-time Setup Routines

; These one-time routines (beginning at INICOR) are overlaid
; at execution time by:
;
;	1) PIP's version message, and
;	2) the first part of PIP's buffer space
;
; The first section of these one-time routines composes PIP's
; version-message text string to reflect feature-patch status,
; and to flag the (sometimes-it-happens) condition of PIP not
; having temporary privileges.

	ORG	INICOR

; Define root part of PIP's version-and-patch-status message

STOPPER::.WORD	ENDID		; Pointer to end of /ID message text
VERMSG:: .PRGID	PIP		; Standard ID line
PCHLVL::.ASCII	" "		; Mandatory-patch edit level tag
	.NLIST	BEX
ENDID	==	.		; For linking/unlinking following text

; Next, the no-temp-privs error message (overlaid if not needed)
NOPRIV:	.BYTE	<CR>,<LF>,<7>	; A real warning:  ring a <BEL>
	.ASCII	"?PIP lacks normal temporary privileges"

QFIRST:: .BLKB	30		; Initial area for building add'l messages
				; (Each message grows by 1 as it is added
				; to composite area, since <CR><LF> 
				; replaces the <NUL> byte of prototype.)
QNEWF::	.ASCIZ	"/RETAIN is default"				;019
QDLA::	.ASCIZ	"Date switches use last-access date"
QVOLID:: .ASCIZ	"ANSI tapes require volume ID"
QLOG::	.ASCIZ	"/LOG by default"				;021
QERDE::	.ASCIZ	"/ERase implies /DElete"
QBSHI::	.ASCIZ	"MT /BSIZE max is "
QRES0::	.ASCIZ	"                                             "
QRES1::	.ASCIZ	"                                             "
QRES2::	.ASCIZ	"                                             "
QRES3::	.ASCIZ	"                                             "
QRES4::	.ASCIZ	"                                             "
QRES5::	.ASCIZ	"                                             "
QRES6::	.ASCIZ	"                                             "
QRES7::	.ASCIZ	"                                             "
QRES8::	.ASCIZ	"                                             "
QRES9::	.ASCIZ	"                                             "
	.EVEN
	.LIST	BEX

; Begin one-time routines.  PIP is entered here when initially fetched.

ONETIM::MOV	#-1,PRIVS	; Presume: we have privileges
	MOV	#XRBSIZ/2,R0	; Now, test them - set count,
	MOV	#XRB+XRBSIZ,R1	; 		 - clear
10$:	CLR	-(R1)		; 		 - the
	SOB	R0,10$		; 		 - XRB;
	.PRIV,	.PEEK		; 		 - try a PEEK
	TSTB	FIRQB		; Did PEEK succeed?
	BEQ	QBLD		; Yes: leave PRIVS set, and proceed
	CLR	PRIVS		; No: clear PRIVS, and proceed

QBLD:	MOV	#NOPRIV,R5	; Point to supplementary-message area
	TST	PRIVS		; Do we have privileges?
	BMI	10$		; Yes, don't use warning message
	MOV	#QFIRST,R5	; NO!  Allow warning message to stand;
	MOV	R5,STOPPER	;   and set up to keep it for /ID, too

10$:	CMPB	..NEWF+1,#1	; Has ..NEWF been patched?	;019
	BEQ	20$		; No				;019
	MOV	#QNEWF,R1	; Yes - point to supplementary message
	CALL	QMOVE		;     - and load it

20$:	CMPB	..DLAC+1,#2	; Has ..DLAC been patched?
	BEQ	30$		; No
	MOV	#QDLA,R1	; Yes - point to supplementary message
	CALL	QMOVE		;     - and load it

30$:	CMPB	..VIDS,#240	; Has ..VIDS been patched?
	BNE	40$		; No
	MOV	#QVOLID,R1	; Yes - point to supplementary message
	CALL	QMOVE		;     - and load it

40$:	TSTB	..SCNF+1	; Has /LOG been set?		;021
	BPL	50$		; No				;021
	MOV	#QLOG,R1	; Yes - point to supplementary message
	CALL	QMOVE		;     - and load it

50$:	BIT	#1,..ERDE	; Has /ER-implies-/DE been set?
	BEQ	60$		; No
	MOV	#QERDE,R1	; Yes - point to supplementary message
	CALL	QMOVE		;     - and load it

60$:	CMP	..BSHI,#8192.	; Has MT blocksize max been patched?	;018
	BEQ	70$		; No
	MOV	#QBSHI,R1	; Yes - point to supplementary message
	CALL	QMOVE		;     - load it
	MOV	..BSHI,R0	;     - now get current blocksize max
	CLR	R1		;     - and (indicating no MSB to DECNUM),
	CALL	DECNUM,R4,<0>	;     - load that

70$:

; Now, reserve code for possible inclusion of future messages

QQ0::	CMP	#0,#0		; Room for an arbitrary test
	BEQ	QQ1		; Arbitrary patch not applied - proceed
	MOV	#QRES0,R1	; Patch was applied: point to its message
	CALL	QMOVE		;   and load it

QQ1::	CMP	#0,#0		; Similarly, reserve code
	BEQ	QQ2		;   for additional cases
	MOV	#QRES1,R1
	CALL	QMOVE

QQ2::	CMP	#0,#0
	BEQ	QQ3
	MOV	#QRES2,R1
	CALL	QMOVE

QQ3::	CMP	#0,#0
	BEQ	QQ4
	MOV	#QRES3,R1
	CALL	QMOVE

QQ4::	CMP	#0,#0
	BEQ	QQ5
	MOV	#QRES4,R1
	CALL	QMOVE

QQ5::	CMP	#0,#0
	BEQ	QQ6
	MOV	#QRES5,R1
	CALL	QMOVE

QQ6::	CMP	#0,#0
	BEQ	QQ7
	MOV	#QRES6,R1
	CALL	QMOVE

QQ7::	CMP	#0,#0
	BEQ	QQ8
	MOV	#QRES7,R1
	CALL	QMOVE

QQ8::	CMP	#0,#0
	BEQ	QQ9
	MOV	#QRES8,R1
	CALL	QMOVE

QQ9::	CMP	#0,#0
	BEQ	QEND
	MOV	#QRES9,R1
	CALL	QMOVE

QEND:	CLRB	(R5)+		; Set final ASCIZ stopper in composite message
	CLRB	(R5)+		; Do again in case no feature patch messages
	INC	R5		; Make R5
	BIC	#1,R5		;  even
	MOV	R5,INIBUF	; Set the initial buffer just past the message
	BR	CORE		; Proceed to allocation of buffers


; QMOVE - load incremental message string into "/VE" message area

;	R5	--> area to receive message string
;	R1	--> ASCIZ string to move

;	CALL	QMOVE

;		<CR> <LF> and ASCIZ string added to R5 string
;		    (but 0 byte not transferred)
;
;	R5	--> next free byte in receiving area
;	R1	destroyed


QMOVE:	MOVB	#15,(R5)+	; Append a <CR> and
	MOVB	#12,(R5)+	;  <LF> to existing string

10$:	TSTB	(R1)		; Is there another byte to move?
	BEQ	20$		; No, go exit
	MOVB	(R1)+,(R5)+	; Yes -move it,
	BR	10$		;     -and go check next byte
20$:	RETURN

.ENABL	LSB

CORE::	CLR	INDINV		; CLEAR THE INDIRECTOR NESTING FLAG
;
; TO MAKE PIP RESTARTABLE COMMENT OUT THE NEXT STATEMENT AND
; CHANGE THE BIC #RSTRT$,JSW TO A BIS, AND REMOVE THE CLR USERPC
;
; Initial-buffer pointer set above to just past version-message string
;	MOV	#INICOR,INIBUF	; SET THE INITIAL BUFFER TO OVERWRITE US
	BIC	#RSTRT$,JSW	; SAY NOT RESTARTABLE
	CLR	USERPC		;  AND INSURE HE CAN'T START
	MOV	#RTSLST,R0	; NOW POINT TO OUR TABLE OF RTS NAMES
	MOV	#XRB,R1		; HANDY POINTER TO XRB
	MOVB	#UU.TB2,FIRQB+FQFUN ; GET MONITOR TABLES
	.PRIV,	.UUO		; GET THEM
	MOV	FIRQB+20,R2	; GET POINTER TO RTS LIST ROOT
10$:	CALL	60$,R5,0	; GET POINTER TO NEXT
	MOV	-(R0),R2	; BACK UP TABLE POINTER, GET NEXT RTS BLOCK
	BEQ	40$		; NO MORE, DONE
	CALL	60$,R5,6	; GET TYPE
	TST	-(R0)		; ANY?
	BEQ	10$		; NO, GO TO NEXT
	MOV	R0,R3		; COPY POINTER
20$:	SUB	#6,R3		; BACK IT UP
	CMP	R3,#RTSLST	; DONE WITH LIST?
	BLO	30$		; YES, NO DUPLICATION
	CMP	(R0),(R3)	; NO, IS THERE A DUPLICATION HERE?
	BEQ	10$		; YES, SKIP THIS ONE
	BR	20$		; TRY AGAIN

30$:	TST	(R0)+		; SKIP TYPE
	CALL	60$,R5,2	; GET RTS
	CALL	60$,R5,4	;  NAME
	CMP	R0,#RTSEND	; MORE ROOM IN TABLE?
	BLO	10$		; YES, TRY FOR MORE

40$:	MOV	#JFSYS!JFBIG!JFLOCK!JFSPRI,XRB ; MASK OF CAPABILITIES TO DROP
	.PRIV,	.CLEAR		; CLEAR EVERYTHING, TEMP DROP PRIV'S IF ANY
	.SETTOP	#-2		; ASK FOR ALL THE CORE THERE IS
	MOV	INIBUF,BUFFER	; SET THE BUFFER ADDRESS
	SUB	BUFFER,R0	; GET THE BUFFER LENGTH
	CMP	R0,#<512.*2>	; MUST BE AT LEAST 2 BLOCKS WORTH
	BLO	50$		; QUIT FAST IF NOT
	BIC	#1,R0		; MAKE IT A MULTIPLE OF WORDS
	MOV	R0,BUFSIZ	; SET INTO THE BUFFER SIZE
	MOV	R0,BUFSZ	; ALSO SAVE PERMANENT COPY
	CLRB	XRB+XRCI	; CLEAR THE CHANNEL NUMBER
	.PRIV,	.POSTN		; FIND OUT THE TERMINAL WIDTH
	MOV	XRB,KBSIZE	; SAVE IT
	DEC	KBSIZE		;  CORRECTED FROM MONITOR'S +1
	MOVB	#UU.SYS,FIRQB+FQFUN ;SET UP TO GET THE JOB STATUS	;030
	CLR	FIRQB+4		;  FOR OUR JOB				;030
	.PRIV,	.UUO		; GET OUR STATUS			;030
	MOVB	FIRQB+5,OURKB	; SAVE OUR KB				;030
	MOV	FIRQB+26,OURPPN	; SAVE OUR PPN				;030
	JMP	RESTRT		; START PIP

50$:	PRINT	<?Not enough memory>
	CLR	R0		; GO AWAY
	.EXIT			; COMPLETELY

60$:	MOV	(R5)+,(R1)	; SET RTS BLOCK OFFSET
	ADD	R2,(R1)		; COMPUTE ADDRESS
	.PRIV,	.PEEK		; LOOK FOR IT
	TSTB	FIRQB		; ERROR PEEKING?
	BEQ	70$		; NO
	CLR	(R1)		; YES, RESULT IS 0
70$:	MOV	(R1),(R0)+	; SAVE THE VALUE
	RETURN	R5		;

.DSABL	LSB

.SBTTL	CONTROL-C PROCESSING

.ENABL	LSB

	ORG	PIP

CNTRLC::CALL	LMARGN		; RESET ^O AND JUSTIFY CARRIAGE
	CALL	TTCRLF		; OUTPUT ANOTHER CR/LF COMBO
	TST	INDCMD		; WAS THERE AN INDIRECT COMMAND FILE OPEN?
	BEQ	CCSTRT		; NO, GO DO THE CONTROL-C RESTART	;028
	CALL	ZAPIND		; YES, SO ZAP ALL INDIRECTORS
	PRINT	<?Command file aborted>
	.BR	CCSTRT		; GO DO THE CONTROL-C RESTART		;028

CCSTRT:	TST	OUTFLG		; IS THERE ANY OUTPUT OPEN?		;028
	BEQ	RESTRT		; NO, GO RESTART THE PROGRAM		;028
	CMPB	OUTFQB+F$HIDX,#DSKHND ; IS THIS DISK OUTPUT?		;028
	BNE	TTYTST		; No, go check for TTY output		;059
	MOV	#3*400+OUT,R0	; SET UP TO KILL THE TENTATIVE FILE	;028
	EMT	374		; DO IT					;028
	BR	RESTRT		; GO DO THE RESTART			;028

TTYTST:	CMPB	OUTFQB+F$HIDX,#TTYHND ; Is output a TTY?		;059
	BNE	RESTRT		; No, go do the restart			;059
	.WRITW	OUT,#CRTERM,#1,#0 ; Write out a CR/LF to tty output dev	;059
	BR	RESTRT		; Go do the restart			;059

ERROR::	CALL	LMARGN		; ON ERROR, RESTORE CARRIAGE
	.TTYOUT	#'?		; PRINT THE ERROR PREFIX
	.PRINT	(R5)		; PRINT THE ERROR TEXT
	BR	RESTRT		; RESTART PIP

ERRORF::CALL	LMARGN		; ON ERROR, RESTORE CARRIAGE		;056
	.TTYOUT	#'?		; PRINT THE ERROR PREFIX		;056
	.PRINT	(R5)		; PRINT THE ERROR TEXT			;056
	PRINT	< - file >,NOCR	; Tell 'em where the error was:		;056
	MOV	INFQB+FQPPN,@SYSPTR; SET THE PROPER PPN			;056
.ASSUME	PPN	EQ	0	;					;056
	MOV	PTRIN,R0	; GET THE FILE SPEC POINTER		;056
	.SETFQB			; SETUP THE FIRQB			;056
	CALL	PRDVPP		; Print the file name			;056
	CALL	LMARGN		; Give us a new line			;056
	.BR	RESTRT		; RESTART PIP				;056

RESTRT::.CLRFQB			; RT11 is ignorant of this channel	;040
	MOVB	#CLSFQ,FIRQB+FQFUN ; Set CLOSE function			;040
	MOVB	#ONX*2,FIRQB+FQFIL ; for the Open Next channel		;040
	.PRIV,	CALFIP		; Do this, RSTS				;040
	TST	OUTFLG		; IS THERE ANY OUTPUT OPEN?
	BEQ	10$		; NO
	CALL	MTCLOT		; YES, SO WRITE EOF LABELS IF ANSI MT
10$:	TST	INFLG		; IS THERE AN INPUT OPEN?
	BEQ	20$		; NO
	CMPB	INFQB+F$HIDX,#MTAHND ; IS THIS MAGTAPE INPUT?
	BNE	20$		; NO, CONTINUE WITH NORMAL PROCESSING
	MAGTAPE	IN,REW,0	; YES, REWIND IT SINCE WE MIGHT BE ANYWHERE
20$:	CLR	R0		; CLEAR R0 TO DISABLE CTRL/C TRAPPING
	.SETCC			; SET NO CTRL/C TRAP ADDRESS
	MOV	USERSP,SP	; RESET STACK TO INITIAL VALUE
	CALL	LMARGN		; CANCEL ^O, RETURN THE CARRIAGE
	MOV	#3*400+17,R0	; PURGE CHANNEL 17
	EMT	374		; DO IT
	MOV	#3*400+15,R1	; RESET ALL BUT CHANNEL 16
30$:	MOV	R1,R0		; SET COMMAND TO PURGE CHANNEL
	EMT	374		; DO IT
	DECB	R1		; COUNT MORE
	BPL	30$		; DO MORE
	CALL	SCAN		; CALL COMMAND STRING SCANNER
	BIT	#WIPEFL,SCNFLG	; ARE WE REQUESTING AN ERASE?
	BEQ	40$		;  NO, SO CONTINUE ON, NO CHECKING NEEDED
	BIT	#DELETE,SCNFLG	;   YES, SO WE MUST HAVE A DELETE
	BNE	40$		;     AND WE DO HAVE ONE
	ERROR	<Use /DE with /ER>;	WE DON'T HAVE ONE, SO BOOT HIM OUT

40$:	MOV	#CNTRLC,R0	; GET RESTART ADDRESS IF CTRL/C
	.SETCC			;   SET CTRL/C TRAPPING
	CLR	DIRCNT		; IF /L, SET UP DIRECTORY OUTPUT
	MOV	#OBLKL,R0	; POINT TO OUTPUT PARAMETERS
	CLR	(R0)+		; CLEAR OUTPUT BLOCK # LSB
	CLR	(R0)+		;  AND MSB FOR DIRECTORY AND /WIPE
	CMP	(R0)+,(R0)+	; SKIP INPUT BUFFER POINTERS
	MOV	BUFFER,(R0)	; OUTPUT BUFFER POINTER = POINTER
	MOV	(R0)+,DIRPTR	; CURRENT POINTER IN DIRECTORY OUTPUT, TOO
	MOV	BUFSIZ,(R0)+	; OUTPUT BUFFER SIZE IS WHOLE THING
	CLR	INFLG		; INPUT  FILE NOT YET OPEN
	CLR	OUTFLG		; OUTPUT FILE NOT YET OPEN
	CLR	INAFQB+FQSIZ	; NO INPUT FILE SIZE
	CLRB	INAFQB+FQSIZM	;   IN HIGH BYTE EITHER
	MOV	#INSPC-<4*2>,PTRIN ; INITIALIZE INPUT FILE SPEC POINTER
	MOV	#OUTSPC,R0	; POINT TO OUTPUT SPEC
	CALL	SETFQB,R5,OUTFQB ; CONVERT THE FIRQB TO OUTFQB
	CMPB	R0,#MTAHND	; IS THE OUTPUT TO MAGTAPE?
	BNE	50$		; NO, CONTINUE WITH PROCESSING
	BIT	#APPEND!DELETE!RENAME,SCNFLG ; WAS /APPEND, /DELETE, 	;008+
				  ;  /EXTEND OR /RENAME SPECIFIED ?     
	BEQ	48$		; NO,48$ - SO CONTINUE ON               
	CALL	ERROR,R5,SWTER	; YES, ABORT WITH "?Switch error"	
48$:									;008-
	CALL	LBLTYP		; FIND OUT WHAT TYPE OF LABEL TO USE ON TAPE
50$:	TSTB	R2		; ARE WE DOING DIRECTORY LISTING?
.ASSUME	DIRECT	EQ	200
	BPL	PRLOOP		; NO, PROCESS NORMALLY
	BIT	R2,#SOMOUT	; IS THERE A REAL OUTPUT FILE?
	BEQ	PRLOOP		; NO, USE TERMINAL
	BIT	#S$EXT,(R1)	; WAS THERE A TYPE SPECIFIED?
	BNE	60$		; YES, SO HE MUST HAVE TYPED ANY WILD CARDS
	BIC	#S$EXTS,(R1)	; NO, SO CLEAR THE TYPE FLAG
	CLR	OUTSPC+6	;  AND CLEAR THE TYPE

60$:	CALL	ENTER		; DO THE ENTER FOR US
	BCC	70$		; Enter the main loop
	CALL	ERRFQB		; CANNOT OVERRIDE OUTPUT FILE
	BR	RESTRT		; ABORT THE WHOLE COMMAND
70$:	MOV	#1000,BLENG	; Set up magtape block length

.SBTTL	SET FILE MERGE FLAG

PRLOOP::BIT	#DELETE!RENAME!DIRECT,SCNFLG ; IF ANY OF THESE BITS SET
	BNE	LOOP		;  THERE IS NO NEED TO GO THROUGH FOLLOWING
	CLR	MERGER		; SET THE MERGER FLAG TO NO MERGER
	TST	OUTFQB+F$FLG2	; IS THIS WILD OUTPUT?
.ASSUME	SCWILD	EQ	100000	;
	BMI	LOOP		; YES, SO JUST GO TO THE LOOP
	MOV	R4,-(SP)	; SAVE R4
	MOV	PTRIN,R4	;  AND GET THE INPUT FILE POINTER
80$:	ADD	#4*2,R4		; INCREMENT POINTER TO THE NEXT FILE
	CMP	R4,#ENDSPC	; OFF THE FAR END YET?
	BHIS	90$		;  NO, KEEP COUNTING
	TST	(R4)		; IS THIS A FILE SPEC
	BEQ	80$		; NO, BLANK, DO MORE
	INC	MERGER		; YES, INCREMENT
	MOV	R4,INUST	; SAVE THE INPUT POINTER IN NON-USED LOC
	BR	80$		; BRANCH UNTIL WE ARE DONE

90$:	MOV	(SP)+,R4	; RESTORE R4
	DEC	MERGER		; IS THERE MORE THAN ONE INPUT?
	BNE	LOOP		;  YES, SO MERGER<>0 IS CORRECT
	REGSAV			; SAVE ALL REGISTERS
	MOV	INUST,R0	; GET POINTER TO ONLY INPUT SPEC
	CALL	SETFQB,R5,INFQB	; SET INTO THE INPUT SPEC BUFFER
	CMPB	INFQB+F$HIDX,#MTAHND ; IS IT MAGTAPE INPUT ?		   ;008+
	BNE	96$		; NO,96$ - SO CONTINUE ON		   
	BIT	#DELETE!RENAME,SCNFLG ; WAS /DELETE OR /RENAME SPECIFIED ? 
	BEQ	96$		; NO,96$ - SO CONTINUE ON		   
	CALL	ERROR,R5,SWTER	; YES, ABORT WITH "?Switch error"	   
96$:									   ;008-
	TST	INFQB+F$FLG2	; IS SOMETHING WILD?
.ASSUME	SCWILD	EQ	100000	;
	BPL	100$		; NO, RESTORE REGS AND GO
	COM	MERGER		; YES, SET MERGER FLAG
100$:	REGRES			; RESTORE REGISTER
	BR	LOOP		; AND JUMP INTO THE LOOP

.DSABL	LSB

.SBTTL	MAIN LOOP

.ENABL	LSB

10$:	TST	(R0)		; IS THERE A SPEC HERE AT ALL?
	BEQ	LOOP		; NO, SKIP IT
	CALL	DOSPEC		; PROCESS THE SPEC
LOOP::	ADD	#4*2,PTRIN	; ADVANCE THE INPUT SPEC POINTER
	MOV	PTRIN,R0	; POINT TO CURRENT INPUT SPEC
	CMP	R0,#ENDSPC	; OFF THE FAR END?
	BLO	10$		; NO, DO ANOTHER

; END OF ALL INPUT SPECS - FINISH UP

	TST	OUTFLG		; IS THERE AN OUTPUT FILE OPEN?
	BEQ	50$		; NOPE, NOTHING TO CLOSE
	TSTB	SCNFLG		; ARE WE DOING DIRECTORIES?
.ASSUME	DIRECT	EQ	200
	BPL	40$		; NO, JUST CLOSE NORMALLY
	MOV	DIRPTR,R4	; YES, GET OUTPUT POINTER
	MOV	DIRCNT,R1	;  AND COUNT OF BYTES IN BUFFER
	BEQ	50$		; IF NONE, THEN NEVER WRITTEN, NO CLOSE
	NEG	R1		; ELSE COMPUTE NUMBER TO FILL
	ADD	#1000,R1	;  AS 1000-(REMAINING)
	BEQ	30$		; NO FILLING NEEDED
20$:	CLRB	(R4)+		; CLEAR IT
	SOB	R1,20$
30$:	CALL	WRITE		; WRITE ONE BLOCK FROM THE BUFFER
40$:	CALL	CLOSEO		; FOR MERGE OR DIRECTORY, CLOSE OUTPUT FILE
50$:	JMP	RESTRT		; GO TO THE BEGINNING

.DSABL	LSB

;+
; DOSPEC - PROCESS A SINGLE INPUT SPECIFICATION
;
;	R0 -> INPUT SPEC (PTRIN = R0, TOO)
;
;	CALL	DOSPEC
;
;	ALL REGISTERS RANDOM
;-

.ENABL	LSB

DOSPEC::CLR	INDEX		; RESET THE DIRECTORY INDEX
	CLR	GOTANY		; NO FILES GOTTEN SO FAR
	MOV	R0,R1		; COPY POINTER TO SPEC
	SUB	#INSPC,R1	; COMPUTE INPUT FILE NUMBER (* 8 BYTES EACH)
	ASH	#-2,R1		; MAKE IT * 2
	MOV	SWTTBL+<3*2>(R1),SWITCH ; MOVE IN THE APPROPRIATE SWITCH
	CALL	SETFQB,R5,INFQB ; GO CONVERT INTO INFQB
	CMPB	INFQB+F$HIDX,#MTAHND ; IS IT MAGTAPE INPUT ?		   ;008+
	BNE	5$		; NO,5$ - SO CONTINUE ON		   
	BIT	#DELETE!RENAME,SCNFLG ; WAS /DELETE OR /RENAME SPECIFIED ? 
	BEQ	5$		; NO,5$ - SO CONTINUE ON		   
	CALL	ERROR,R5,SWTER	; YES, ABORT WITH "?Switch error"	   
5$:									   ;008-
	MOV	#PPNDEX,R3	; GET POINTER TO DIR GRAND TOTAL AREA
	CLR	(R3)+		; PPNDEX
	MOV	INFQB+FQPPN,(R3); SET THE WLDPPN WITH THE PPN SPECIFIED
	TSTB	R2		; ARE WE DOING DIRECTORY LISTING?
.ASSUME	DIRECT	EQ	200
	BPL	20$		; NO, PROCESS ONE OR MORE FILES
	BIT	R0,#DDNFS	; DIRECTORY, SO DEVICE MUST BE FILE STRUCTURED
	BEQ	10$		; IT IS, SET UP DIRECT INFORMATION AREAS
	SETERR	DEVNFS		; SET UP THE APPROPRIATE ERROR MESSAGE
	CALL	ERRFQB		; PRINT THE ERROR
	CALLR	TTCRLF		; NEW LINE

10$:	MOV	R4,-(SP)	; SAVE R4
	MOV	#DIRPPN,R4	; GET POINTER TO DIRPPN
	MOV	(R3)+,(R4)+	; SET DIRPPN TO WLDPPN
	MOV	INFQB+FQDEV,(R3); WLDDEV
	MOV	(R3)+,(R4)+	; DIRDEV
	MOV	INFQB+FQDEVN,(R3);WLDDVN
	MOV	(R3)+,(R4)	; DIRDVN
	CLR	(R3)+		; TDRNFL
	CLR	(R3)+		; TDRNFM
	CLR	(R3)+		; TDRNBL
	CLR	(R3)+		; TDRNBM
	CLR	(R4)+		; DIRNFI
	CLR	(R4)+		; DIRNBL
	CLR	(R4)+		; DIRNBM
	MOV	(SP)+,R4	; RESTORE R4
	TSTB	INFQB+F$HIDX	; IS THIS A DISK DEVICE?
.ASSUME	DSKHND	EQ	0
	BEQ	50$		;  YES, SO EVERYTHING IS ALRIGHT
	COM	PPNDEX		;  NO, PPNDEX<>0 => NO GRAND TOTALING YET
	BR	50$		;  AND CONTINUE ON WITH DIRECTORY PROCESSING

20$:	BIT	R0,#DDNFS	; FILE OPERATION. IS THE INPUT NFS?
	BEQ	23$		; No, continue				;041
	JMP	PROCES		; YES, NO WILD CARDING			;041

23$:	TST	INFQB+F$FLG2	; WILD CARDS ON F.S. INPUT?		;041
.ASSUME	SCWILD	EQ	100000	;
	BMI	30$		; YES, DO DIRECTORY LOOKUPS
	TSTB	R0		; NO WILDS, BUT IS THE INPUT FROM DISK?
.ASSUME	DSKHND	EQ	0
	BEQ	50$		; NO WILDS, BUT DISK SO DO LOOKUP
	CMPB	R0,#MTAHND	; IS THE INPUT FROM MAGTAPE?
	BEQ	50$		; NO WILDS, BUT INPUT IS MAGTAPE, SO DO LOOKUP
	JMP	PROCES		; NO, SO DO A SINGLE INPUT FILE		;041

30$:	BIT	#WIPEFL!DELETE,R2; IS THIS A DELETE COMMAND?
	BEQ	50$		; NO, CONTINUE WITH PROCESSING
	BIT	#INSPCT,R2	; IS THE /IN SWITCH SPECIFIED?
	BNE	50$		; YES, SO IMPLIED * IS OKAY
	BIT	#S$FIL,(R1)	; CHECK FOR FILE NAME SPECIFICATION
	BEQ	40$		; NOT EXPLICIT - ERROR
	BIT	#S$EXT,(R1)	; CHECK FOR EXPLICIT TYPE
	BNE	50$		;  IT IS THERE - GO DO DELETE
40$:	ERROR	<File name and type must be specified for /DE>

50$:	CLR	CP2SEF		; CLR Flag if copying to same account	;041
	MOV	SCNFLG,R2	; Get the flag bits			;041
	BIT	#DELETE!RENAME!DIRECT,R2 ; Are we doing a copy		;041
	BEQ	501$		; Maybe, go check some more		;041
	JMP	59$		; No, go lookup a file			;041

501$:	BIT	#RTS,R2		; Are we doing a rename			;041
	BEQ	51$		; No, it's a copy			;041
	BIT	#SOMOUT,R2	; Yes, is there any output		;041
	BNE	51$		; Yes, so it's really a copy		;041
	JMP	59$		; No, it's a plain old rename		;041

51$:	TSTB	INFQB+F$HIDX	; Is the input from a disk		;041
	BNE	59$		; No, go lookup a file			;041
	TSTB	OUTFQB+F$HIDX	; Is the output to a disk		;041
	BNE	59$		; No, go lookup a file			;041
	MOV	INFQB+FQPPN,R0	; Get the input PPN			;041
	BNE	52$		; Go around if there was one		;041
	MOV	OURPPN,R0	; Otherwise, use our own		;041
52$:	MOV	OUTFQB+FQPPN,R1	; Get the output PPN			;041
	BNE	53$		; Go around if there was one		;041
	MOV	OURPPN,R1	; Otherwise, use our own		;041
53$:	CMP	R0,R1		; Are the PPNs the same			;041
	BNE	59$		; No, go lookup a file			;041
	.CLRFQB			; RT11 is ignorant of this channel	;041
	MOVB	#CLSFQ,FIRQB+FQFUN ; Set CLOSE function			;041
	MOVB	#ONX*2,FIRQB+FQFIL ; for the Open Next channel		;041
	.PRIV,	CALFIP		; Do this, RSTS				;041
	MOV	#JFSYS,XRB	; Set to regain temp privs		;041
	.PRIV,	.SET		; Now get them				;041
	.CLRXRB			; Clear the XRB				;041
	.CLRFQB			; Clear the FIRQB			;041
	MOV	#FIRQB+FQFUN,R0	; Get a FIRQB pointer			;073
	MOVB	#UU.ONX,(R0)+	; Set Open Next function		;073
	MOV	#ONX*2,(R0)+	; Specify the channel number		;073
	MOV	#1,(R0)+	; Set account [0,1]			;073
	MOV	#^RSAT,(R0)+	; Set file SATT.SYS			;073
	MOV	#^RT  ,(R0)+	; for the Open Next lookup		;073
	MOV	#^RSYS,(R0)+	; (There HAS to be one on a disk)	;073
	CMP	(R0)+,(R0)+	; Skip two words			;073
	MOV	#100000!40,(R0)+ ; Allow no r/w access (lookup)		;073
	CMP	(R0)+,(R0)+	; Skip two words			;073
	MOV	INFQB+FQDEV,(R0)+ ; Move in the input device		;073
	MOV	INFQB+FQDEVN,(R0) ; Move in the unit number		;073
	.PRIV,	.UUO		; Get the physical device name		;041
	TSTB	FIRQB		; Any errors				;041
	BNE	60$		; Yes, go tell him off			;041
	MOV	(R0),-(SP)	; Save the unit number			;073
	MOV	-(R0),-(SP) 	; Save the device name			;073
	.CLRFQB			; RT11 is ignorant of this channel	;041
	MOV	#FIRQB+FQFUN,R0	; Get a FIRQB pointer			;073
	MOVB	#CLSFQ,(R0)+	; Set CLOSE function			;073
	MOV	#ONX*2,(R0)	; for the Open Next channel		;073
	.PRIV,	CALFIP		; Do this, RSTS				;041
	.CLRXRB			; Clear the XRB				;041
	.CLRFQB			; Clear the FIRQB			;041
	MOVB	#UU.ONX,-1(R0)	; Set Open Next function		;073
	MOV	#ONX*2,(R0)+	; Specify the channel number		;073
	MOV	#1,(R0)+	; Set account [0,1]			;073
	MOV	#^RSAT,(R0)+	; Set file SATT.SYS			;073
	MOV	#^RT  ,(R0)+	; for the Open Next lookup		;073
	MOV	#^RSYS,(R0)+	; (There HAS to be one on a disk)	;073
	CMP	(R0)+,(R0)+	; Skip two words			;073
	MOV	#100000!40,(R0)+ ; Allow no r/w access (lookup)		;073
	CMP	(R0)+,(R0)+	; Skip two words			;073
	MOV	OUTFQB+FQDEV,(R0) ; Move in the input device		;073
	MOV	OUTFQB+FQDEVN,2(R0) ; Move in the unit number		;073
	.PRIV,	.UUO		; Get the physical device name		;041
	TSTB	FIRQB		; Any errors				;041
	BNE	56$		; Yes, go tell him off			;072
	CMP	(R0)+,(SP)+	; Are the device names the same		;073
	BEQ	57$		; Yes, go check the unit numbers	;041
	TST	(SP)+		; No, restore the stack			;041
	BR	58$		; and go lookup a file			;041

56$:	CMP	(SP)+,(SP)+	; Restore the stack			;072
	CALLR	ERCONT		; Now go tell her off			;074

57$:	CMP	(R0),(SP)+	; Are the unit numbers the same		;073
	BNE	58$		; No, go lookup a file			;041
	INC	CP2SEF		; Yes, flag that copies to same acct	;041
58$:	MOV	#JFSYS,XRB	; Set to drop temp privs		;041
	.PRIV,	.CLEAR		; Now clear them			;041
59$:	CALL	LOOKUP		; LOOKUP A FILE FOR US			;041
	BCS	60$		; FAILURE - GO SEE IF WE GOT ANYTHING
	MOV	PTRIN,R1	; COPY INPUT SPEC POINTER
	MOV	#FIRQB+FQNAM1,R0 ; NAME COMES FROM HERE
	TST	(R1)+		; SKIP THE DEVICE
	MOV	(R0)+,(R1)+	; COPY NAME
	MOV	(R0)+,(R1)+
	MOV	(R0)+,(R1)+	; AND TYPE
	CALL	PROCES		; PROCESS THE FILE FOUND
	INC	INDEX		; NEXT FILE
	INC	GOTANY		; GOT ANOTHER FILE
	TST	INFQB+F$FLG2	; ARE THERE WILD CARDS ON THE INPUT SPEC?
.ASSUME	SCWILD	EQ	100000	;
	BMI	59$		; YES, GO FIND IT

; NO MORE MATCHES ON ONE INPUT FILE SPEC

60$:	MOVB	FIRQB,-(SP)	; Save the last error if any		;041
	MOV	#JFSYS,XRB	; Set to drop temp privs		;041
	.PRIV,	.CLEAR		; Now clear them			;041
	MOVB	(SP)+,FIRQB	; Restore the error if any		;041
	BEQ	65$		; No error, that's good			;076
	CMPB	FIRQB,#NOSUCH	; ?Can't find file or account error?	;076
	BEQ	65$		; Yes, handle that			;076
	CALLR	ERCONT		; No, so go tell 'em off		;076

65$:	TST	GOTANY		; DID WE GET ANY FILES AT ALL?
	BEQ	70$		; NO, GO PRINT AN ERROR
	TSTB	SCNFLG		; DOING DIRECTORIES?
.ASSUME	DIRECT	EQ	200
	BPL	120$		; NO, NOTHING SPECIAL
	CLR	PPNDEX		; CLEAR THE PPN INDEX TO FORCE GRAND TOTALS
	CALLR	DIREND		; PRINT SUMMARY LINE

; NO FILES ON THIS INPUT SPEC, PRINT AN ERROR OF SOME SORT

70$:	BIT	#DELETE!WIPEFL,SCNFLG; IS THIS A DELETE FUNCTION?
	BEQ	75$		; NO, CONTINUE				;029
	CALLR	DELERR		; YES, DO THE PROPER THING FOR DELETE ERRORS

75$:	BIT	R2,#RENAME	; WERE WE DOING RENAMES			;029
	BEQ	80$		; NO, PROCEED WITH NORMAL ERROR HANDLING;029
	CHKERR	NOSUCH		; WAS THE ERROR "FILE NOT FOUND"?	;029
	BNE	80$		; NO, CONTINUE				;029
	BIT	#NOWARN,SC2FLG	; WAS :NOWARN SPECIFIED?		;029
	BEQ	80$		; NO, PRINT ERROR			;029
	CLRB	FIRQB		; CLEAR ANY ERROR FLAGS			;029
	BR	120$		;  AND EXIT				;029

80$:	CMPB	INFQB+F$HIDX,#MTAHND ; IS THIS A MAGTAPE THAT FAILED?
	BNE	90$		; NOPE, DO NORMAL PROCESSING
	BIT	#STOPMS,SCNFLG	; ARE WE HALTING IF NO MATCH?
	BNE	120$		; Yes, return
90$:	TST	INFQB+F$FLG2	; DID UUO LOK FAIL?
.ASSUME	SCWILD	EQ	100000	;
	BMI	100$		; YES, IT IS A REAL UNMATCHING WILD CARD
	CALLR	ERCONT		; NO, ERROR IS NOSUCH

100$:	PRINT	<%No files matching >,NOCR
	MOV	PTRIN,R0	; GET POINTER TO WILD SPEC
	.SETFQB			; SET UP FIRQB FOR PRINTING
	CALL	PRDVPP		; PRINT THE MATCH TRY IN FULL
110$:	.PRINT	#CONTXT		; PRINT ' - CONTINUING'
120$:	RETURN

.DSABL	LSB

.SBTTL	PROCESS A FILE

.ENABL	LSB

PROCES::MOV	PTRIN,R4	; POINT TO INPUT SPEC FOR THE ROUTINES
	MOV	SCNFLG,R2	; GET THE FLAG BITS

.SBTTL	DELETE ROUTINE

	BIT	R2,#DELETE	; DELETE PERHAPS?
	BNE	10$		; YES, DO IT
	JMP	DORENM		; NO, GO CHECK FOR RENAME

10$:	CLR	ERFLAG		; CLEAR "ERASED AND" PRINT FLAG
	REGSAV			; Save all registers temporarily
	MOV	#8.,R0		; Prepare to move eight bytes
	MOV	PTRIN,R1	; Load input spec address
	MOV	#OUTSPC,R2	; Load output spec address
20$:	MOVB	(R1)+,(R2)+	; Copy inspc to outspc
	SOB	R0,20$		; Continue for eight bytes
	REGRES			; Restore all registers
	TSTB	INFQB+F$HIDX	; IS INPUT FROM DISK
.ASSUME	DSKHND	EQ	0
	BEQ	25$		; NO, CAN'T DO A WIPE			;049
	JMP	100$		;  SO GO DO SOMETHING ELSE		;049

25$:	BITB	#US.NOK,FIRQB+FQNENT+1 ; IS THE FILE PROTECTED FROM DELETE?
	BEQ	30$		; NO, CONTINUE THE CHECK
	SETERR	PRVIOL		; YES, PROTECTION VIOLATION!
	JMP	DELCLN		; TELL 'EM ABOUT THE ERROR		;070

30$:	MOVB	#UU.CHK,FIRQB+FQFUN; SET UP TO CHECK FILE ACCESS	;049
	CLRB	FIRQB+FQFIL	;  SET FILE ACCESS RIGHTS SUBFUNCTION	;049
	MOVB	FIRQB+20,FIRQB+FQPROT; SET FILE PROT CODE		;049
	BICB	#100,FIRQB+FQPROT; SEE IF WE HAVE WRITE ACCESS W/O EXE BIT;049
	.PRIV,	.UUO		; EXECUTE UU.CHK SYS CALL		;049
	TSTB	FIRQB+20	; CHECK THE PROTECTION CODE		;070
	BPL	40$		; IF PRIV BIT IS NOT SET, CHECK FOR FILE WIPE
	CALL	FQBSCR		; ELSE SAVE THE FIRQB WITH COROUTINE
	BIS	#100000,ERFLAG	;  FLAG A RENAME NEEDED
	BIT	#100,FIRQB+20	; IS EXECUTE BIT ON?			;049
	BEQ	50$		;  IF NOT GO RIGHT TO ERASE		;049
	BIT	#4,FIRQB+FQERNO	; BIT 2 ON MEANS WR ACCESS NOT ALLOWED	;049
	BNE	35$		;  BYPASS PROT CODE RENAME IF NO ACCESS	;049
	MOV	R0,-(SP)	; SAVE R0				;070
	MOV	R1,-(SP)	; SAVE R1				;070
	MOV	#FIRQB+FQPROT,R0; SET UP WHERE TO PUT PROT CODE		;049
	MOVB	FIRQB+20,(R0)	; MOVE IN PROT CODE			;049
	BICB	#100,(R0)	; RESET EXECUTE BIT IN PROT CODE	;049
	MOVB	#-1,-(R0)	; AND SAY IT IS REAL			;049
	MOV	#FIRQB+FQNAM1,R0; POINT TO NAME				;049
	MOV	#FIRQB+FQNAM2,R1;  AND WHERE TO PUT IT			;049
	MOV	(R0)+,(R1)+	; MOVE NAME				;049
	MOV	(R0)+,(R1)+	; MOVE NAME				;049
	MOV	(R0)+,(R1)+	; MOVE NAME				;049
	MOVB	#RENFQ,FIRQB+FQFUN; SET RENAME FUNCTION			;049
	MOV	#JFSYS,XRB	; SET UP TO RAISE PRIVS			;049
	.PRIV,	.SET		;  AND RAISE 'EM			;049
	.PRIV,	CALFIP		; DO IT					;049
	MOV	#JFSYS,XRB	; SET UP TO DROP PRIVS			;049
	.PRIV,	.CLEAR		;  AND DROP 'EM				;049
35$:	MOV	(SP)+,R1	; RESTORE R1				;049
	MOV	(SP)+,R0	;  AND R0				;049
	BR	50$		; AND WIPE THE FILE

40$:	BIT	R2,#WIPEFL	; DELETE REQUEST. WIPE OUT THE FILE?
	BEQ	100$		; NO
50$:	BIT	#4,FIRQB+FQERNO	; BIT 2 ON MEANS WR ACCESS NOT ALLOWED	;070
	BEQ	51$		; CONTINUE IF WE HAVE WRITE ACCESS	;070
	SETERR	PRVIOL		; PROTECTION VIOLATION!			;070
	BR	DELCLN		; TELL 'EM ABOUT THE ERROR		;070
51$:	INC	ERFLAG		; COMPLEMENT THE ERASE FLAG
	MOV	INFQB+FQPPN,@SYSPTR; SHOVE IN THE PROPER PPN
.ASSUME	PPN	EQ	0	;
	.LOOKUP	OUT,R4		; OPEN THE FILE FOR OVERWRITING
	BCS	DELCLN		; CAN'T DO THAT
	;CLC			; C=0 NOW
	MOV	R0,R3		; REMEMBER NUMBER OF BLOCKS IN FILE
	MOVB	FIRQB+FQSIZM,R1	; GET THE MSB OF THE FILE SIZE
	BIS	R1,R0		; BIT SET TO CHECK FOR A FILE SIZE
	BEQ	90$		; ZERO LENGTH FILES ARE E-Z
	MOVB	R1,IBLKM	; RECORD THE MSB
	CLRB	IBLKM+1		; MAKE SURE THERE IS NO GARBAGE IN HIGH BYTE
	CLR	OBLKL		; SAY NO BLOCKS WRITTEN YET
	CLR	OBLKM		;   CLEAR MSB SIZE ALSO
	MOV	OBFSIZ,R1	; GET BUFFER SIZE IN BYTES
	BIC	#777,R1		;   MASK OFF ANY PARTIAL BLOCKS
	ROR	R1		;     BUFFER SIZE IN WORDS
	MOV	R1,R5		; COPY SIZE IN WORDS
	SWAB	R1		; COMPUTE BUFFER SIZE IN BLOCKS
	ASR	R5		; COMPUTE BUFFER SIZE IN DOUBLEWORDS
	MOV	OBFPTR,R2	; POINT TO THE BUFFER

60$:	CLR	(R2)+		; CLEAR THE BUFFER
	CLR	(R2)+		; 2 WORDS AT A SHOT
	SOB	R5,60$		; UNTIL DONE
70$:	MOV	R1,R4		; BLOCK COUNT, ASSUMING WE WRITE A FULL BUFFER
	SUB	R1,R3		; COMPUTE NUMBER OF BLOCKS LEFT
	SBC	IBLKM		; SUBTRACT ANY CARRY FROM MSB
	BGE	80$		; A BUFFER LOAD OR MORE IS LEFT
	ADD	R3,R4		; END, SO SHORTEN THE WRITE
	CLR	R3		; FLAG END OF FILE
	CLR	IBLKM		; BOTH PLACES
80$:	SWAB	R4		; COMPUTE WORD COUNT TO WRITE
	ASL	R4		; MAKE IT A BYTE COUNT
	ADD	OBFPTR,R4	; POINT TO END OF AREA TO WRITE
	CALL	WRITE		; WRITE ZEROS
	MOV	IBLKM,R4	; GET MSB
	BIS	R3,R4		;  BIT SET IN LSB, ANY MORE?
	BNE	70$		; NO, MORE TO ERASE
90$:	.CLOSE	OUT		; CLOSE FILE
	TST	ERFLAG		; IS A RENAME NEEDED?
	BPL	100$		; NO, JUST DELETE THE FILE
	CALL	@(SP)+		; YES, SET UP THE FIRQB
	MOV	#FIRQB+FQPROT,R0; ADDRESS OF WHERE TO PUT PROTECTION CODE
	MOVB	FIRQB+20,(R0)	; SET THE NEW PROTECTION CODE
	BICB	#200,(R0)	;  Clear the PRIV bit
	MOVB	#-1,-(R0)	;    and say it is real
	MOV	#FIRQB+FQNAM1,R0; GET POINTER TO THE NAME
	MOV	#FIRQB+FQNAM2,R1; GET POINTER OF WHERE TO PUT IT AGAIN
	MOV	(R0)+,(R1)+	; SHOVE THE NAME UP
	MOV	(R0)+,(R1)+	;
	MOV	(R0)+,(R1)+	;
	MOVB	#RENFQ,FIRQB+FQFUN; FILE RENAME FUNCTION
	.PRIV,	CALFIP		; RENAME THE FILE TO PREVENT MONITOR WIPEOUT

100$:	MOV	INFQB+FQPPN,@SYSPTR; PUT THE PROPER PPN IN
.ASSUME	PPN	EQ	0	;
	.DELETE	IN,PTRIN	; DELETE THE FILE
	BCS	DELERR		; ERROR, GO REPORT IT (LEAVE INDEX BUMPED)
	MOV	#DECIDX,-(SP)	; DECREMENT THE INDEX WHEN DONE
	TST	SCNFLG		; SHOULD WE LIST THE NAME?
.ASSUME	LISTFN	EQ	100000
	BPL	120$		; NO, JUST GO FIX THE INDEX
	CALL	LMARGN		; YES, RESTORE THE CARRIAGE
	CALL	PRDVPP		;  AND PRINT THE FILE NAME IN THE FIRQB
	MOV	#140$,R0	; ASSUME IT WAS JUST DELETED
	TST	ERFLAG		; TEST THE ERASE FLAG
	BEQ	110$		; NO ERASED, SO JUST PRINT DELETED
	MOV	#130$,R0	; CHANGE TO ' ERASED AND DELETED'
110$:	.PRINT
120$:	RETURN

DELCLN::TST	ERFLAG		; DO WE NEED TO CLEAN THE FIRQB
	BPL	DELERR		; NO, GO TO THE ERROR ROUTINE
	CALL	@(SP)+		; CLEAN THE FIRQB
DELERR::BIT	#NOWARN,SC2FLG	; ARE WE AVOIDING ERRORS?
	BEQ	GOERC		; NO, PRINT IT OUT
	CHKERR	NOSUCH		; IS THE ERROR NOSUCH
	BEQ	120$		; YES, JUST QUIT
GOERC::	CALLR	ERCONT		; SAY ERROR AND CONTINUING

	TMPORG	TEXT
.NLIST	BEX
130$:	.ASCII	" erased and"
140$:	.ASCIZ	" deleted"
	UNORG

.DSABL	LSB

.SBTTL	RENAME ROUTINE

.ENABL	LSB

DORENM::BIT	R2,#RENAME	; ARE WE DOING RENAMES TODAY?
	BNE	10$		; YES, SO DO THEM
	JMP	DODIR		; NO, CHECK IF WE ARE DOING DIRECTORIES

10$:	CALL	MOVFQB		; COPY INPUT (!) FIRQB
	MOV	R4,R0		; COPY INPUT SPEC POINTER
	TST	(R0)+		; SKIP DEVICE NAME
	MOV	#FIRQB+FQNAM1,R1 ; PUT THE FILENAME IN THIS PLACE
	MOV	(R0)+,(R1)+
	MOV	(R0)+,(R1)+	; FILENAME
	MOV	(R0)+,(R1)+	; AND TYPE
	MOV	R4,R0		; GET POINTER AGAIN
	TST	(R0)+		; BUMP TO POINT TO FILE NAME

; ASSEMBLE NEW FILE NAME AND CHECK FOR ERRORS

	MOV	R5,-(SP)	; SAVE R5 SO WE CAN GET A SCRATCH REG
	MOV	#FNBUFF,R5	; GET A BUFFER AREA
	CALLX	RAD$FN		; CONVERT TO ASCII
	MOV	#OUTFQB+FQNAM1,R0 ; POINT TO NEW NAME
	CALLX	RAD$FN		; AND CONVERT IT TO ASCII
	MOV	#10.,R0		; SET LOOP CONTROL
20$:	CMPB	-(R5),#'?	; DOES NEW NAME HAVE A '?' HERE?
	BNE	30$		; NO, SO GO CHECK NEXT
	MOVB	-12(R5),(R5)	; YES, SO SET IN OLD NAME
30$:	SOB	R0,20$		; LOOP UNTIL DONW

; SET NEW FILE NAME INTO FIRQB

40$:	MOV	#FIRQB+FQNAM2,R3; GET POINTER TO NEW NAME LOCATION
	CALLX	ASCR50		; CONVERT NEW NAME TO RAD50
	MOV	R0,(R3)+	; AND SET IT FIRQB
	CALLX	ASCR50		; DO IT AGAIN
	MOV	R0,(R3)+	;  SET IT AGAIN
	INC	R5		; BUMP POINTER PAST '.'
	CALLX	ASCR50		; CONVERT TYPE
	MOV	R0,(R3)+	;  AND SET TYPE
	MOV	(SP)+,R5	;   AND FINALLY RESTORE R5
	BIT	#S$PROT,INFQB+F$SFLG ; PROTECTION CODE EXPLICIT ON INPUT?
	BNE	50$		; YES, USE IT IF NONE ON OUTPUT
	CLR	FIRQB+FQPROT-1	; NO, NO PROTECTION CODE FROM IN SPEC
50$:	BIT	#S$PROT,OUTFQB+F$SFLG ; DID HE ACTUALLY TYPE OUTPUT PROT?
	BEQ	55$		; NO, NO PROTECTION CHANGE		;053
	MOV	OUTFQB+FQPROT-1,FIRQB+FQPROT-1 ; GET THE OUTPUT PROTECTION
55$:	CMP	#134745,OUTFQB+FQNAM1	;   Is the output spec equal to	;057
	BNE	551$			;         "TT:??????.???"   ?	;057
	CMP	#134745,OUTFQB+FQNAM1+2	;   If so, it means that user	;057
	BNE	551$			;   supplied only one file spec	;057
	CMP	#134745,OUTFQB+FQEXT	;   as in *FILE.EXT<nn>/RE	;057
	BNE	551$			;   or DCL's			;057
	CMP	#"TT,OUTFQB+FQDEV	;       */PR:nn=:FILE.EXT/RE/LO	;057
	BNE	551$			;   and so we don't want to	;057
	TST	OUTFQB+FQDEVN		;   check the device and PPN	;057
	BEQ	60$			;   and generate a false error.	;057
551$:	TST	ODEVFL		; device specified on output?		;067
	BEQ	56$		; No, check PPN				;055
	TST	OUTFQB+FQDEVN	; Output device number specified?	;057
	BNE	552$		; Yes, continue checking		;057
	TST	INFQB+FQDEVN	; Input device number specified?	;057
	BEQ	56$		; No, then dev names don't matter	;057
552$:	CMP	OUTFQB+FQDEV,INFQB+FQDEV ; Out device same as in dev?	;055
	BNE	591$		; no, error				;055
	CMP	OUTFQB+FQDEVN,INFQB+FQDEVN ; Out unit same as in unit?	;057
	BNE	591$		; no, error				;055
56$:	TST	OUTFQB+FQPPN	; Output PPN not specified?		;055
	BEQ	60$		; Yes (not specified), OK		;055
	CMP	OUTFQB+FQPPN,INFQB+FQPPN ; out PPN = in PPN?		;055
	BEQ	60$		; yes, OK				;055
	CMP	OUTFQB+FQPPN,OURPPN ; out ppn=our ppn?			;055
	BNE	57$		; no, check proj			;055
	TST	INFQB+FQPPN	; in PPN=0?				;055
	BEQ	60$		; YES, OK				;055
57$:	CMPB	OUTFQB+FQPPN+1,INFQB+FQPPN+1 ; outproj=inproj?		;055
	BEQ	58$		; yes-OK, check prog			;055
	CMPB	OUTFQB+FQPPN+1,#377 ; outproj wild?			;055
	BEQ	58$		; yes-OK, check prog			;055
	CMPB	OUTFQB+FQPPN+1,OURPPN+1 ; outproj = ourppnproj?		;055
	BNE	592$		; no, error				;055
	TST	INFQB+FQPPN	; in PPN=0?				;055
	BEQ	58$		; YES, check prog			;055
	BR	592$		; NO, ERROR				;055
58$:	CMPB	OUTFQB+FQPPN,INFQB+FQPPN ; outprog=inprog?		;055
	BEQ	60$		; yes-OK				;055
	CMPB	OUTFQB+FQPPN,#377 ; outprog wild?			;055
	BEQ	60$		; yes-OK				;055
	CMPB	OUTFQB+FQPPN,OURPPN ; outprog = ourppnprog?		;055
	BNE	592$		; no, error				;055
	TST	INFQB+FQPPN	; in PPN=0?				;055
	BEQ	60$		; YES, OK				;055
	BR	592$		; NO, error				;055

591$:	CALL	LMARGN		; Get us a new line			;053
	PRINT 	<?Output/Input device mismatch on RENAME> ; Tell 'em	;055
	RETURN			; And go away				;053

592$:	CALL	LMARGN		; Get us a new line			;055
	PRINT 	<?Output/Input PPN mismatch on RENAME> ; Tell 'em	;055
	RETURN			; And go away				;055

; THE ACTUAL RENAME CALL TO FIP

60$:	MOVB	#RENFQ,FIRQB+FQFUN ; SET UP FOR A RENAME
	MOV	FIRQB+FQPFLG,SAVWRD; SAVE THE PROTECTION AND FLAG	;050
	.PRIV,	CALFIP		; CALL RSTS FOR THIS
	TSTB	FIRQB		; SHOULD NOT HAVE ANY ERRORS
	BEQ	90$		; THERE WERE NONE
	CHKERR	BADNAM		; IS THIS A BAD NAME?
	BEQ	70$		; YES, REPORT THAT ERROR, ONLY FOR NEW NAME
	CHKERR	FIEXST		; WAS THE ERROR FIEXST?
	BNE	80$		; NO, REPORT ERROR
	BIT	#NOWARN,SC2FLG	; WAS :NOWARN SPECIFIED?
	BEQ	70$		; NO, PRINT ERROR
	CLRB	FIRQB		; CLEAR ANY ERROR FLAGS
	RETURN			;  AND RETURN

70$:	MOV	PTRIN,R0	; YES, MOVE THE NEW NAME INTO POSITION
	TST	(R0)+		; BUMP R0 PAST THE DEVICE NAME
	MOV	#FIRQB+FQNAM2,R1;   MOVE NEW NAME TO PTRIN
	MOV	(R1)+,(R0)+	; MOVE THE NAME
	MOV	(R1)+,(R0)+	;   MOVE THE NAME
	MOV	(R1)+,(R0)+	;     MOVE THE NAME
80$:	CALLR	ERCONT		; AND SAY CONTINUING

90$:	TSTB	SAVWRD		; DID USER SPECIFY EXPLICIT PROTECTION?	;050
	BEQ	92$		;  NO, DON'T CHECK FOR PROT CHANGE	;050
	MOV	#FIRQB+FQNAM1,R1 ; Set up address of original file/type	;052
	MOV	#SAVNAM,R3	; Set up where to store it		;052
	MOV	(R1)+,(R3)+	; Load the file...			;052
	MOV	(R1)+,(R3)+	;          ...name			;052
	MOV	(R1),(R3)	;         and type			;052
	MOV	#FIRQB+FQEXT,R1	; Yes: look up the file as renamed	;050
	MOV	#FIRQB+FQNAM2+4,R3 ;    ..move name from FQNAM2 to FQNAM1;050
	MOV	(R3),(R1)	; Load the type				;050
	MOV	-(R3),-(R1)	; Load the file..			;050
	MOV	-(R3),-(R1)	;        ..name				;050
	TST	-(R1)		; Skip past FQPPN			;050
	MOV	#-1,-(R1)	; Indicate lookup-by-filename at FQFUN+1;050
	MOVB	#LOKFQ,-(R1)	; Set Lookup function			;050
	.PRIV,	CALFIP							;050
	CLR	R0		; Get the looked-up <prot>		;050
	BISB	(R3),R0		;   into R0 (one byte)			;050
	MOV	#FIRQB+FQNAM1,R1 ; Replace filename at FQNAM2, where	;050
	MOV	(R1)+,(R3)+	;   following code expects it		;050
	MOV	(R1)+,(R3)+	;					;050
	MOV	(R1)+,(R3)+	;					;050
	MOV	#SAVNAM,R1	; Set up where we stored original name	;052
	MOV	#FIRQB+FQNAM1,R3 ; Set up where we put it back		;052
	MOV	(R1)+,(R3)+	; Load the file...			;052
	MOV	(R1)+,(R3)+	;          ...name			;052
	MOV	(R1),(R3)	;         and type			;052
	CMPB	SAVWRD+1,R0	; DID PROT RENAME WORK?			;050
	BEQ	92$		; YES, CONTINUE NORMALLY		;050
	CALL	LMARGN		; RESTORE CARRIAGE			;050
	PRINT	<%>,NOCR	; OUTPUT WARNING SYMBOL			;050
	BR	96$		; AND REPORT THE CHANGE			;050

92$:	TST	R2		; SHOULD WE REPORT THE CHANGE?		;050
.ASSUME	LISTFN	EQ	100000
	BPL	110$		; NO

	CALL	LMARGN		; YES, RESTORE THE CARRIAGE		;050
96$:	CALL	PRDVPP		;  AND PRINT THE FIRST NAME		;050
	MOV	#FNBUFF,R5	; REUSE THE BUFFER
	PRINT	< renamed to >,NOCR
	MOV	#FIRQB+FQNAM2,R0 ; POINT TO THE NEW NAME
	CALLX	RAD$FN		; CONVERT AS A FILE NAME
	TSTB	FIRQB+FQPROT-1	; Did user specify explicit protection ?
	BEQ	100$		; No (don't log <prot>)
	MOV	#FIRQB+FQEXT,R1	; Yes: look up the file as renamed
	MOV	#FIRQB+FQNAM2+4,R3 ;    ..move name from FQNAM2 to FQNAM1
	MOV	(R3),(R1)	; Load the type
	MOV	-(R3),-(R1)	; Load the file..
	MOV	-(R3),-(R1)	;        ..name
	TST	-(R1)		; Skip past FQPPN
	MOV	#-1,-(R1)	; Indicate lookup-by-filename at FQFUN+1
	MOVB	#LOKFQ,-(R1)	; Set Lookup function
	.PRIV,CALFIP
	CLR	R0		; Get the looked-up <prot>
	BISB	(R3),R0		;   into R0 (one byte)
	MOV	#FIRQB+FQNAM1,R1 ; Replace filename at FQNAM2, where
	MOV	(R1)+,(R3)+	;   following code expects it
	MOV	(R1)+,(R3)+
	MOV	(R1)+,(R3)+
	MOVB	#'<,(R5)+	; INSERT IT
	CALLX	NUM$
	MOVB	#'>,(R5)+
100$:	CLRB	(R5)		; END STRING
	.PRINT	#FNBUFF		; TELL HIM THE NEW NAME
110$:	MOV	#FIRQB+FQNAM2,R0 ; THIS IS WHERE THE OUTPUT FILENAME IS
	CALL	WLDTST		; DOES IT MATCH THE INPUT SPEC?
	BEQ	120$		; YES, MAIN LOOP INC AVOIDS RERENAMING
DECIDX::DEC	INDEX		; TO CANCEL OUT THE SUBSEQUENT INC.
120$:	RETURN

.DSABL	LSB

.SBTTL	DIRECTORY ROUTINE

.ENABL	LSB

DODIR::	TSTB	R2		; DOING DIRECTORY?
.ASSUME	DIRECT	EQ	200
	BMI	10$		; YES
	JMP	RTSREN		; NO, WE MUST BE COPYING

10$:	CMPB	#MTAHND,INFQB+F$HIDX ; DIRECTORY OF MAGTAPE?
	BNE	20$		; NO, DIRECTORY INFO IS IN THE FIRQB
	MOV	#FIRQB+FQFUN,R0	; FOR TAPE, DO A LOOKUP TO GET LENGTH
	MOVB	#UU.DIR,(R0)+	; CODE IS DIRECTORY LOOKUP
	MOV	#1,(R0)+	; INDEX IS <> 0 TO AVOID TAPE MOTION
	MOV	INFQB+FQPPN,(R0)+; PPN IS SET
.ASSUME	PPN	EQ	0	; PPN MUST BE AT OFFSET ZERO IN R/W AREA
	.PRIV,	.UUO		; DO THE OPERATION
	CALL	ERRCHK		; DIE ON ERROR
	CLRB	FIRQB+21	; CLEAR THE MSB OF THE FILESIZE		;022
20$:	MOV	#DIRPPN,R4	; GET A HANDY POINTER
	MOV	#DIRBUF,R5	; POINT TO DIRECTORY LINE BUFFER
	TST	GOTANY		; ANY FILES THIS SPEC?
	BEQ	30$		; NO, PRINT THE HEADER LINES
	CMP	(R4),FIRQB+FQPPN ; ARE WE DOING THE SAME PPN AS BEFORE?
	BEQ	40$		; YES, NO NEW HEADER
	CALL	DIREND		; PRINT TRAILER ON CHANGE OF PPN
30$:	CALL	DIRHDR		; PRINT DIRECTORY HEADER
40$:	MOV	#DIRNFI,R4	; POINT TO SUMMARY DATA AREA
	INC	(R4)+		; ONE MORE FILE
	MOV	LSTSWT,R2	; GET THE LISTING SWITCH OPTIONS
	CMPB	#8.,FIRQB+FQNENT ; ARE WE DOING DISK?
	BEQ	50$		; DISK HAS EVERYTHING
	MOV	FIRQB+22,FIRQB+24 ; PUT CREATION DATE IN STANDARD PLACE
50$:	MOV	#FIRQB+FQNAM1,R0 ; POINT TO THE DATA
	ASR	R2		; IS THE NAME TO BE PRINTED?
	BCC	60$		; NO
	CALLX	RAD$W2		; CONVERT THE RAD50 FILE NAME 
60$:	MOV	#FIRQB+FQEXT,R0	; PRINT TYPE FROM HERE
	ASR	R2		; TYPE TO PRINT?
	BCC	70$		; NO
	MOVB	#'.,(R5)+	; YES, SEPARATE WITH A DOT
	CALLX	RAD$R0		;  AND PRINT IT
	MOVB	#' ,(R5)+	; Add a place holder for the deleted flag ;073
	TST	FIRQB+FQNENT	; See if this file is real?		;073
	.ASSUME	US.DEL	EQ	200					;073
	BPL	70$		;  Yes, its real, so continue		;073
	MOVB	#'*,-1(R5)	;  No, its deleted - so flag it 	;073

70$:	MOV	FIRQB+16,R0	; YES, GET THE LSB SIZE
	MOVB	FIRQB+21,R1	;  AND MSB SIZE
	MOV	R1,FISIZE	; FORM THE FLAG FOR POSITION PRINTING
	BIS	R0,FISIZE	;  FISIZE IS NON ZERO IF THERE IS A FILE SIZE
	ADD	R0,(R4)+	; BUMP NUMBER OF BLOCKS			;032
	ADC	(R4)		;  CARRYING
	ADD	R1,(R4)		; INCLUDING HIGH ORDER
	MOV	#SPACE,R4	; GET A HANDY CONSTANT
	ASR	R2		; PRINT FILE SIZE?
	BCC	90$		; NO
	DECDBL	7.		; CONVERT TO A 7-DIGIT FIELD		;073
	MOV	#OUTBYT,R0	; GET A HANDY ROUTINE ADDRESS
	MOVB	FIRQB+FQNENT+1,R1; GET THE USTAT BYTE
	OUTBYT	US.NOX,C	; OUTPUT C IF US.NOX
	OUTBYT	US.NOK,P	; OUTPUT P IF US.NOK
	OUTBYT	US.PLC,L	; OUTPUT L IF US.PLC
90$:	ASR	R2		; PRINT PROTECTION?
	BCC	100$		; NO
	MOVB	#'<,(R5)+	; OPEN PROTECTION CODE FIELD
	CLR	R0		; CLEAR FOR BISB
	BISB	FIRQB+20,R0	; GET THE PROTECTION CODE
	DECNUM	3		; CONVERT TO A 3 DIGIT NUMBER
	MOVB	#'>,(R5)+	; END THE FIELD
100$:	ASR	R2		; PRINT DATE OF LAST ACCESS?
	BCC	110$		; NO
	CALL	CVTDAT,R1,FIRQB+22 ; YES, CONVERT ACCESS DATE

110$:	ASR	R2		; PRINT CREATION DATE?
	BCC	120$		; NO
	CALL	CVTDAT,R1,FIRQB+24 ; YES, CONVERT THE CREATION DATE
120$:	ASR	R2		; PRINT CREATION TIME?
	BCC	130$		; NO
	CALL	CVTTIM,R1,FIRQB+26 ; YES, CONVERT THE TIME
130$:	ASR	R2		; PRINT CLUSTERSIZE?
	BCC	140$		; NO
	MOV	FIRQB+34,R0	; GET THE CLUSTERSIZE
	MOV	R1,-(SP)	;  Save the USTAT byte			;073
	DECNUM	4		; PRINT IN A 4-DIGIT FIELD
	MOV	(SP)+,R1	;  Get USTAT back again			;073
140$:	BIT	#DIR.PO!DIR.RT!DIR.OA!DIR.SA,LSTSWT ; DO WE REQUIRE UU.FIL?
	BEQ	165$		; NO, THIS IS EASY
	CALL	GETATR		; GET THE ATTRIBUTES
	MOVB	FIRQB,-(SP)	; DID AN ERROR OCCUR ON THE UU.FIL?
	BEQ	150$		; NO ERROR - CONTINUE PROCESSING
	CALL	DRCRLF		; FORCE OUT WHAT WE HAVE NOW
	MOVB	(SP)+,FIRQB	; RESET THE ERROR CODE
	CALLR	ERCONT		; TELL THE USER WHAT ERROR OCCURRED

150$:	TST	(SP)+		; POP THE SAVED ERROR CODE FROM THE UU.FIL UUO
	ASR	R2		; ARE WE DOING RTS?
	BCC	160$		; NO, THEN WE MUST BE DOING ATTRIBUTES
	MOVB	R4,(R5)+	; PAD WITH A SPACE
	MOV	#FIRQB+34,R0	; THIS IS WHERE THE RTS COMES FROM
	CALLX	RAD$W2		; CONVERT IT

160$:	ASR	R2		; ARE WE PRINTING THE FILES POSITION
	BCC	180$		;  NO, CHECK FOR ATTRIBUTES
	MOVB	R4,(R5)+	; PAD WITH A SPACE
	TST	FISIZE		; IS THERE A FILESIZE? (I.E. A FIRST BLOCK?)
	BNE	170$		; YES, SO GIVE THE DCN
	MOVTXT	<----->,NOCR	; NO, SO GIVE 5 DASHES TO INDICATE A NULL FILE
	BR	180$		;  AND CONTINUE AT ATTRIBUTE PRINTER

165$:	BR	270$		; Done with this one			;073

170$:	MOV	FIRQB+4,R0	; GET THE POSITION OF THE FIRST DCN
	MOV	R1,-(SP)	; Save USTAT again			;073
	DECNUM	5		; PRINT A DECIMAL NUMBER, FIELD OF 5
	MOV	(SP)+,R1	; and get USTAT back again		;073
180$:	BIT	#DIR.PO,LSTSWT	; do open counts? (kludge for now)	;073
	BEQ	185$		; NO					;073
	MOV	R1,-(SP)	; Save USTAT for later			;073
	CLR	R0		; Start with 0				;073
	BISB	INOCNT,R0	; Get the count				;073
	DECNUM	3		;  And print it out.			;073
	MOVTXT	</>,NOCR	; Put in the seperator			;073
	CLR	R0		; Start with 0 again			;073
	BISB	INOCNT+1,R0	; Now get the RR count			;073
	DEC	R0		; Don't count ourselves			;073
	DECNUM	1		;  and print it out.			;073
	MOV	#OUTBYT,R0	; GET A HANDY ROUTINE ADDRESS		;073
	MOV	(SP)+,R1	; GET THE USTAT BYTE			;073
	OUTBYT	US.WRT,W	; OUTPUT W IF US.WRT			;073
	OUTBYT	US.UPD,U	; OUTPUT U IF US.UPD			;073
185$:	BIT	#DIR.SA!DIR.OA,LSTSWT ; ARE WE DOING ATTRIBUTES AT ALL?
	BEQ	270$		; NO, SKIP THIS NEXT MESS
	MOV	#FIRQB+6,R1	; GET A POINTER TO THE START OF ATTRIBUTES
	MOV	R1,R0		; COPY THE POINTER
	MOV	R1,R3		;   TWO PLACES
200$:	TST	(R1)+		; IS THIS A NULL ATTRIBUTE?
	BEQ	210$		;  YES
	MOV	R1,R3		;   NO
210$:	CMP	#FIRQB+34,R1	; ARE WE DONE YET?
	BNE	200$		;  NO
	SUB	R0,R3		; SUBTRACT TO GET THE NUMBER OF ATTRIBUTES
	BLE	240$		;  IF # ATTRI <= 0 THEN PUNT
	ASR	R3		; ADJUST FOR PROPER NUMBER
	ASR	R2		; DO WE WANT OCTAL ATTRIBUTES?
	BCC	230$		; NO, WE MUST WANT SYMBOLIC
	MOV	R3,-(SP)	; SAVE R3
	CALL	DRCRLF		; FORCE OUT THE LINE
	MOV	#FIRQB+6,R0	; RESTORE R0 -> FIRQB+6
	MOV	(SP),R3		; RESTORE R3 FROM THE TOP OF THE STACK
220$:	MOVB	R4,(R5)+	; PAD A SPACE
	CALL	OCTATT		; OUTPUT THE OCTAL INTO THE BUFFER
	SOB	R3,220$		; DO IT UNTIL ALL ARE PRINTED
	MOV	(SP)+,R3	; POP R3 FROM THE STACK (# OF ATTRIBUTES
230$:	BIT	#DIR.SA,LSTSWT	; DO WE WANT SYMBOLIC ATTRIBUTES
	BEQ	270$		; NO
	MOV	#FIRQB+6,R0	; POINT TO THE ATTRIBUTES
	CALL	SYMATT		; PRINT OUT SYMBOLIC ATTRIBUTES
240$:	MOV	#SPACE,R4	; PUT THE SPACE BACK INTO R4
	MOVB	FIRQB+3,R1	; GET THE CACHING/flag BYTE
	BITB	#200!100!10!4,R1 ; CHECK FOR FILE CACHE or others	;073
	BEQ	270$		; NOT CACHED, or even anything		;073
	CALL	DRCRLF		; MUST OUTPUT A CR/LF
	BITB	#200!4,R1	; CHECK FOR FILE CACHE			;073
	BEQ	262$		; NOT CACHED, AND NOT RANDOMLY AT THAT	;073
	TAB	3.		; PAD THREE SPACES
	MOVTXT	<CACHE:>,NOCR	; SAY WE ARE CACHED
	POINTX	<ON:>,NOCR	; ASSUME THE CACHE BIT IS ON
	TSTB	R1		; Check and see if it is?		;073
	BMI	250$		; IT IS ON, MOVE IN THE TEXT
	POINTX	<OFF:>,NOCR	;  IT IS OFF, CHANGE TO OFF
250$:	MOVTXT			; AND MOVE THE TEXT
	POINTX	<RAN>,NOCR	; ASSUME RANDOM
	BITB	#4,R1		; IS THIS RANDOM OR SEQUENTIAL CACHE
	BEQ	260$		; RANDOM
	POINTX	<SEQ>,NOCR	; SEQUENTIAL
260$:	MOVTXT			; OUTPUT INTO BUFFER
262$:	BITB	#10,R1		; Are we NOBACKUP? 			;073
	BEQ	264$		;  No, so give up right here.		;073
	CALL	295$		; PAD with four SPACES			;073
	MOVTXT	<NOBACKUP>,NOCR	; SAY WE ARE NOBACKUP			;073
264$:	BITB	#100,R1		; Are we IGNORE?			;073
	BEQ	270$		;  NO, so go on				;073
	CALL	295$		; PAD with four SPACES			;073
	MOVTXT	<IGNORE>,NOCR	; SAY WE ARE IGNORE			;073
270$:	CMP	R5,#DIRBUF	; NULL LINE?
	BEQ	310$		; IF SO, EASY
	TST	LSTSWT		; ARE WE DOING A WIDE DIRECTORY?
.ASSUME	DIR.W	EQ	100000	;  THE ABOVE WON'T WORK WITHOUT IT!
	BPL	290$		;   NO, SO OUTPUT THE CR/LF
280$:	BIT	#DIR.OA!DIR.SA,LSTSWT; DOES THIS WIDE LIST HAVE ATTRIBUTES?
	BNE	290$		; YES, SO HE REALLY DOESN'T GET A WIDE LIST
	DEC	LSTCTR		; YES, IS THERE MORE ROOM HERE?
	BGT	300$		;   YES - CONTINUE ON
290$:	CALLR	DRCRLF		;   NOPE, DO END-OF-LINE WORK

295$:	MOVB	R4,(R5)+	; IF MORE,
	MOVB	R4,(R5)+	;  FOUR
	MOVB	R4,(R5)+	;   MORE
	MOVB	R4,(R5)+	;    SPACES
	RETURN

300$:	CALL	295$
310$:	CALLR	DIRPUT		;  AND EMIT THE LINE

	TMPORG	DATA
FISIZE:	.WORD	0		; AREA FOR THE FILESIZE
	UNORG

.DSABL	LSB

.SBTTL	PRINT AN OCTAL NUMBER FOR ATTRIBUTES

;+
; OCTATT - PRINT AN OCTAL NUMBER
;
;	R0 -> NUMBER
;	R5 -> BUFFER
;
;	CALL	OCTATT
;
;	R0 -> NEXT NUMBER
;	R5 -> JUST AFTER NUMBER
;-

.ENABL	LSB

OCTATT::REGSCR			; SAVE ALL THE REGISTERS
	MOV	#6,R1		; GET THE NUMBER OF CHARACTERS TO OUTPUT
	MOV	(R0)+,R2	; GET THE NUMBER TO OUTPUT
	MOV	R0,TOS.R0(SP)	; SAVE IT
	ADD	R1,R5		; DO THE NUMBER OUTPUT BACKWARDS
	MOV	R5,TOS.R5(SP)	;  AND SAVE R5
10$:	MOV	R2,R3		; COPY THE NUMBER
	BIC	#^C<7>,R3	; ISOLATE THE 7 BITS
	ADD	#'0,R3		; ADD AN ASCII ZERO
	;CLC			; CARRY IS CLEAR FROM ABOVE
	ROR	R2		; SHIFT RIGHT 1 BIT (ZERO INTO SIGN BIT)
	ASR	R2		; SHIFT RIGHT 1 BIT (SIGN EXTEND - ZERO)
	ASR	R2		; SHIFT RIGHT 1 BIT (SIGN EXTEND - ZERO)
	MOVB	R3,-(R5)	; SHOVE THE NUMBER INTO THE BUFFER
	SOB	R1,10$		; LOOP UNTIL DONE
	RETURN			; RETURN

.DSABL	LSB

.SBTTL	PAD A BUFFER WITH SPACES

;+
; TABBER - PUT A NUMBER OF SPACES INTO A BUFFER
; TABR0  - PUT A NUMBER OF SPACES INTO A BUFFER
;
;	R0 =  POSITION TO TAB TO
;	R5 -> CURRENT BUFFER POINTER
;
;	TAB	POSITION
;
;	R5 -> NEXT BYTE
;-

.ENABL	LSB

TABR0::	REGSAV			; SAVE ALL THE REGISTERS
	BR	10$		; GO TO THE ROUTINE

TABBER::REGSAV			; SAVE ALL THE REGISTERS
	MOV	(R3)+,R0	;  AND THE POSITION TO TAB TO
	MOV	R3,TOS.R3(SP)	; MAKE SURE WE RETURN TO THE PROPER LOCATION
10$:	MOV	R5,R2		; COPY THE BUFFER POINTER
	SUB	#DIRBUF,R2	; SUBTRACT THE PROPER THE POSITION DESIRED
	SUB	R2,R0		; SUBTRACT THE POSITION WHERE TO TAB TO
	BLE	30$		;  ALREADY THERE OR PAST THERE, RETURN
	MOV	#SPACE,R4	; GET A SPACE
20$:	MOVB	R4,(R5)+	; OUTPUT THE SPACE
	SOB	R0,20$		;  AND LOOP UNTIL DONE
	MOV	R5,TOS.R5(SP)	; RETURN THE UPDATED R5
30$:	REGRES			; RESET THE REGISTERS PROPERLY
	RETURN	R3		;  AND RETURN, ALL TABBED OUT

.DSABL	LSB

.SBTTL	OUTPUT A BYTE IF A BIT IS SET

;+
; OUTBYT - OUTPUT A BYTE IF A BIT IS SET
;
;	R0 -> OUTBYT
;	R1 =  WORD TO TEST FOR BIT
;	R4 =  ASCII CODE FOR SPACE
;	R5 -> OUTPUT BUFFER
;
;	OUTBYT	BIT,BYTE
;
;	R5 -> OUTPUT BUFFER POINTER UPDATED
;-

OUTBYT::MOVB	R4,(R5)+	; DEFAULT IS SPACE IF NOT SET
	BITB	(R2)+,R1	; IS THE BIT SET?
	BEQ	10$		; NO, THE SPACE IS RIGHT
	MOVB	(R2),-1(R5)	; CORRECT WITH PROPER BYTE
10$:	INC	R2		; BUMP POINTER FOR PROPER RETURN ADDRESS
	RETURN	R2		;  AND RETURN

.SBTTL	SYMBOLIC ATTRIBUTE PRINTER

;+
; SYMATT - PRINT OUT FILE ATTRIBUTES SYMBOLICALLY
;
;	R0 -> ATTRIBUTES
;	R3 =  COUNT OF ATTRIBUTES
;	R5 -> OUTPUT BUFFER
;
;	CALL	SYMATT
;
;	R0 =  GARBAGE
;	R1 =  GARBAGE
;	R2 =  GARBAGE
;	R3 =  GARBAGE
;	R4 =  GARBAGE
;	R5 -> NEXT BYTE IN BUFFER
;-

.ENABL	LSB

SYMATT::REGSAV			; SAVE THE REGISTERS
	CALL	DRCRLF		; OUTPUT WHAT WE HAVE ALREADY
	REGRES			; RESTORE THE REGISTERS
	MOV	#DIRBUF,R5	; MAKE SURE R5 POINTS TO DIRBUF
	MOV	R0,R4		; COPY THE ATTRIBUTE POINTER
	MOV	(R4),R1		; GET THE ATTRIBUTE
.ASSUME	F.RTYP	EQ	0	;
	BIC	#^C<17>,R1	; MASK OFF UNINTERESTING PARTS
	CMP	R1,#5		; IS IT OUT OF RANGE?
	BLE	10$		; NO, MOVE IN THE TEXT
	MOV	#5,R1		; YES, SET IT TO FIVE
10$:	MOVB	#SPACE,(R5)+	; PAD THE FIRST LINE WITH A SPACE
	OUTSYM	RFTBL		; OUTPUT THE RECORD FORMAT
	CMP	#9.,R3		; DO WE HAVE ENOUGH ATTS TO PRINT RECSIZ?
	BGT	20$		; NO, SKIP IT
	MOV	20(R4),R0	; GET THE RECORDSIZE
	BEQ	20$		; NOTHING HERE, SKIP PRINTING THE RECORD SIZE
	MOVB	#'=,(R5)+	; PUT IN AN EQUAL SIGN
	DECNUM			; PRINT	THE NUMBER
20$:	TAB	13.		; DO A TAB(13%)
	MOV	(R4),R1		; GET THE FIRST ATTRIBUTE AGAIN
.ASSUME	F.RTYP	EQ	0	;
	BIC	#^C<60>,R1	; CLEAR OFF UNDESIRABLE BITS
	ASH	#-4,R1		; DIVIDE BY 20

	OUTSYM	FOTBL		; MOVE OUT THE PROPER THREE BYTES
	CMP	#5.,R3		; DO WE HAVE ENOUGH TO PRINT BLOCKS USED?
	BGT	30$		; NO, SKIP IT
	TAB	22.		; DO A TAB(22%)
	MOVTXT	<USED:>,NOCR	; MOVE IN 'USED:'
	MOV	F.EFBK(R4),R1	; GET MSB
	MOV	F.EFBK+2(R4),R0	;  AND LSB
	DECDBL			; PRINT THE NUMBER
	MOVB	#':,(R5)+	; SEPARATE BYTE USED IN LAST BLOCK WITH COLON
	MOV	F.FFBY(R4),R0	; GET THE NUMBER OF BYTES
	DECNUM			; PRINT THE NUMBER, SINGLE PRECISION
30$:	CMP	#2,R3		; ARE THERE ENOUGH ATTRIBUTES TO PRINT RECSIZ?
	BGT	40$		; NO, SKIP IT
	TAB	40.		; DO A TAB(40%)
	MOVTXT	<RECSI:>,NOCR	; MOVE IN 'RECSI:'
	MOV	F.RSIZ(R4),R0	; GET THE RECORD SIZE
	DECNUM			;  AND PRINT THE NUMBER
40$:	MOVB	F.RATT(R4),R1	; GET THE FIRST ATTRIBUTE WORD AGAIN
	BIC	#^C<7>,R1	; CLEAR THE UNINTERESTING BITS
	DEC	R1		; DECREMENT IT FOR PROPER INDEXING
	BMI	60$		;  AND SKIP THE OUTSYM IF NONE ARE SET
	CMP	R1,#3		; CHECK FOR GREATER THAN THREE
	BLE	50$		; IF R1>=3 THEN PRINT THE SYMBOL
	MOV	#2,R1		;   ELSE FORCE THE ATTRIBUTE TO 2 (???)
50$:	TAB	52.		; DO A TAB(52%)
	OUTSYM	CCTBL		; OUTPUT THE PROPER SYMBOLIC THING
60$:	BITB	#FD.BLK,F.RATT(R4); IS THE NOSPAN BIT SET?
	BEQ	70$		; NO, GO CHECK FOR RMS BUCKETSIZE, ETC.
	TAB	62.		; DO A TAB(62%)

	MOVTXT	<NOSPAN>,NOCR	; FORCE OUT NOSPAN
70$:	CMP	#9.,R3		; DO WE HAVE ENOUGH ATTRIBUTES FOR RMS?
	BGT	100$		; NO, JUST SKIP THIS
	MOV	22(R4),R1	; CHECK TO SEE IF THE RMS STUFF REALLY EXISTS
	BIS	16(R4),R1	;  BIT SET THIS STUFF
	BEQ	100$		; NO INFORMATION HERE, SKIP IT
	REGSAV			; SAVE ALL THE REGISTERS
	CALL	DRCRLF		; DO A CARRET
	REGRES			; RESTORE THE REGISTERS
	MOV	#DIRBUF,R5	; INSURE THE BUFFER POINTER INITED PROPERLY
	MOV	16(R4),R0	; GET THE BUCKETSIZE
	BIC	#^C<377>,R0	; CLEAR IT
	BEQ	80$		; IF SOMETHING IS THERE, LEAVE IT
	TAB	2.		; DO A TAB(2%)
	MOVTXT	<BK:>,NOCR	; PRINT THE BUCKET SIZE
	DECNUM			; PRINT IT
80$:	MOV	16(R4),R0	; GET THE RECORDSIZE
	SWAB	R0		; SWAP THE BYTES TO GET RECSIZ IN LOWBYTE
	BIC	#^C<377>,R0	; MASK OFF THE HIGH BYTE
	BEQ	90$		; SKIP THIS ONE IF IT IS ZERO
	TAB	13.		; DO A TAB(13%)
	MOVTXT	<HS:>,NOCR	; SAY WHAT WE ARE PRINTING
	DECNUM			; PRINT IT
90$:	MOV	22(R4),R0	; GET THE DEFAULT TYPE
	BEQ	100$		; NONE - SO WE ARE FINISH!
	TAB	22.		; DO A TAB(22%)
	MOVTXT	<EX:>,NOCR	; SAY WHAT IT IS
	DECNUM			; PRINT IT
100$:	RETURN			;  AND RETURN

.SBTTL	OUTPUT A SYMBOLIC ATTRIBUTE

OUTSYM::MOV	(R4)+,R2	; GET THE TABLE ADDRESS
	MOVB	(R2)+,(R5)+	; MOVE IN THE PREFIX
	MOVB	(R2)+,(R5)+	;   AND THE SECOND
	MOVB	#':,(R5)+	;    AND THE COLON SEPARATOR
	MUL	#3,R1		; MULTIPLY BY THREE
	ADD	R2,R1		; ADD THE OFFSET
	MOVB	(R1)+,(R5)+	; MOVE IN THREE BYTES
	MOVB	(R1)+,(R5)+	;  ONE AT A
	MOVB	(R1)+,(R5)+	;   TIME
	RETURN	R4		; AND RETURN

.SBTTL	TABLES FOR PRINTING SYMBOLIC ATTRIBUTES

	TMPORG	RFTBL
	.NLIST	BEX

RFTBL::
	.ASCII	/RF/		; PREFIX FOR RECORD FORMAT ATTRIBUTE
	.ASCII	/UDF/		; = 0 -> UNDEFINED
	.ASCII	/FIX/		; = 1 -> FIXED
	.ASCII	/VAR/		; = 2 -> VARIABLE
	.ASCII	/VFC/		; = 3 -> VARIABLE WITH FIXED CONTROL
	.ASCII	/STM/		; = 4 -> STREAM (ASCII)
	.ASCII	/???/		; >=5 -> ILLEGAL(???)

	TMPORG	FOTBL
	.NLIST	BEX

FOTBL::
	.ASCII	/FO/		; PREFIX FOR FILE ORGANIZATION ATTRIBUTE
	.ASCII	/SEQ/		; = 0 -> SEQUENTIAL
	.ASCII	/REL/		; = 1 -> RELATIVE
	.ASCII	/IDX/		; = 2 -> INDEXED
	.ASCII	/???/		; = 3 -> ILLEGAL(???) (DIRECTORY???)

	TMPORG	CCTBL
	.NLIST	BEX

CCTBL::
	.ASCII	/CC/		; PREFIX FOR CARRIAGE CONTROL ATTRIBUTE
	.ASCII	/FOR/		; = 0 -> FORTRAN
	.ASCII	/IMP/		; = 1 -> IMPLIED
	.ASCII	/???/		; = 2 -> ILLEGAL(???)
	.ASCII	/PRN/		; = 3 -> PRINT FORMAT
	UNORG

.DSABL	LSB

.SBTTL	MOVE TEXT INTO THE DIRECTORY BUFFER

;+
; MOVTXT - MOVE TEXT TO OUTPUT BUFFER
;
;	R5 -> OUTPUT BUFFER
;
;	MOVTXT	<FOOBAR>,NOCR
;	 -or-
;	MOVTXT		(R0->TEXT)
;
;	R5 -> NEXT BYTE IN BUFFER
;-

.ENABL	LSB

MOVTX0::TST	(PC)+		; C = 0 IMPLIES R0 -> TEXT
MOVTXT::SEC			; C = 1 IMPLIES R4 -> TEXT POINTER
	REGSAV			; SAVE ALL THE REGISTERS
	BCC	10$		; IF ALL SET UP, GO TO LOOP
	MOV	(R4)+,R0	; GET THE POINTER TO THE TEXT
	MOV	R4,TOS.R4(SP)	; INSURE THE PROPER RETURN ADDRESS
10$:	CMPB	(R0),#200	; Is this end of string with no CR/LF?	;012+
	BEQ	30$		; Yes, so we're done			
	BEQ	30$		; Yes, so we're done			
	MOVB	(R0)+,(R5)+	; MOVE THE BYTES INTO THE BUFFER	
	BNE	10$		; Not a null, so more to do		;012-

	DEC	R5		; POINT BACK AT THE NULL
	MOVB	#CR,(R5)+	; PUT IN A CARRET
	MOVB	#LF,(R5)+	; PUT IN A LINEFD
30$:	MOV	R5,TOS.R5(SP)	; SAVE R5 PROPERLY
	REGRES			; RESTORE ALL THE REGISTERS
	RETURN	R4		; AND RETURN

.DSABL	LSB

.SBTTL	PRINT DIRECTORY SUMMARY LINES

.ENABL	LSB

DIREND::CMP	LSTEPL,LSTCTR	; IS /L:W IN THE MIDDLE OF A LINE?
	BEQ	10$		; NO
	CALL	DNCRLF		; YES, FORCE IT TO A NEW LINE
10$:	CALL	DNCRLF		; FORCE A BLANK LINE (AND SET BUFFER POINTER)
	BIT	#DIRLSU,LSTSWT	; LONG SUMMARY OR SHORT?
	BNE	30$		; LONG
	MOVB	#40,(R5)+	; LEADING BLANK FOR SHORT SUMMARY
	CALL	70$		; "N FILES"
	MOVB	#40,(R5)+	; SEPARATING BLANK
	CALL	20$		; "N BLOCKS"
	BR	50$		; DONE

20$:	MOV	DIRNBL,R0	; GET NUMBER OF BLOCKS LSB
	MOV	DIRNBM,R1	;  AND MSB
	MOV	#130$,R2	; POINT TO TEXT
	BR	80$		; OUTPUT NUMBER

30$:	MOV	#120$,R2	; POINT TO TRAILER TEXT
	CALL	110$		; "TOTAL OF "
	CALL	20$		; "N BLOCKS"
	BIT	LSTSWT,#DIR.AL	; ARE WE PRINT FILE SIZE OR ALLOCATION
	BEQ	40$		;   FILE SIZE
	MOV	#170$,R2	;   GET POINTER TO ' ALLOCATED'
	CALL	110$		;      PRINT ' ALLOCATED'
40$:	CALL	100$		; " IN "
	CALL	70$		; "N FILES"
	CALL	100$		; " IN "
	CALL	DPRINT		; PRINT DEVICE NAME
50$:	CALL	DRCRLF		; END THE SUMMARY LINE
	CALL	DNCRLF		; FINISH WITH A BLANK LINE

.SBTTL	DIRECTORY GRAND TOTALING

	BIT	#S$PPNJ!S$PPNG,INFQB+F$SFLG ; IS THIS A WILD PPN SPEC?
	BEQ	90$		; NO, JUST SKIP TOTALS
	BIT	#DIRLSU,LSTSWT	; LONG OR SHORT SUMMARY?
	BEQ	90$		; SHORT => NO GRAND TOTALING
	MOV	#DIRNFI,R0	; GET POINTER TO PPN TOTALS
	MOV	#TDRNFL,R1	; AND A POINTER TO GRAND TOTALS
	ADD	(R0)+,(R1)+	; ADD IN # FILES
	ADC	(R1)+		; AND ADJUST FOR ANY CARRY
	ADD	(R0)+,(R1)+	; ADD IN # BLOCKS
	ADC	(R1)		; ADD IN ANY CARRY
	ADD	(R0)+,(R1)+	; ADD IN MSB OF BLOCKS
	TST	PPNDEX		; IS THIS THE LAST SPEC?
	BNE	90$		; NO, JUST RETURN
	MOV	#160$,R2	; GET POINTER TO GRAND TOTAL
	CALL	110$		; OUTPUT IT
	MOV	#130$,R2	; NOW POINT TO OTHER THINGS
	MOV	TDRNBL,R0	; GET LSB OF # BLOCKS
	MOV	TDRNBM,R1	; SET MSB OF #   "
	CALL	80$		; EMIT THE # BLOCKS
	BIT	LSTSWT,#DIR.AL	; CHECK FOR FILE SIZE OR FILE ALLOCATION
	BEQ	60$		;   FILE SIZE - CONTINUE
	MOV	#170$,R2	;   POINTER TO ' ALLOCATED'
	CALL	110$		;      PRINT 'ALLOCATED'
60$:	CALL	100$		; EMIT " IN "
	MOV	TDRNFL,R0	; GET LSB OF FILES
	MOV	TDRNFM,R1	; GET MSB OF FILES
	CALL	80$		; AND OUTPUT IT
	CALL	100$		; EMIT " IN "
	MOV	WLDPPN,DIRPPN	; SET DIRPPN
	MOV	WLDDEV,DIRDEV	;     DIRDEV
	MOV	WLDDVN,DIRDVN	;     DIRDVN
	CALL	DPRINT		; PRINT THE DEVICE SPEC
	CALL	DRCRLF		; END THE GRAND TOTAL LINE
	BR	DNCRLF		; AND FINISH WITH A BLANK LINE

70$:	MOV	DIRNFI,R0	; GET NUMBER OF FILES
	CLR	R1		; MSB=0
	MOV	#150$,R2	; POINT TO TEXT
80$:	DECDBL			; PRINT THE NUMBER
	CALL	110$		; PRINT THE TEXT
	DEC	R0		; TAKE LSB-1
	BIS	R1,R0		; EXACTLY ONE?
	BEQ	90$		; YES
	MOVB	#'S+40,(R5)+	; NO, MAKE IT PLURAL
90$:	RETURN

100$:	MOV	#140$,R2	; EMIT " IN "
110$:	MOVB	(R2)+,(R5)+	; EMIT STRING
	BNE	110$		;  UNTIL NULL
	SOB	R5,90$		; BACK OVER THE NULL AND RETURN

	TMPORG	TEXT
	.NLIST	BEX
120$:	.ASCIZ	"Total of "
130$:	.ASCIZ	" block"
140$:	.ASCIZ	" in "
150$:	.ASCIZ	" file"
160$:	.ASCIZ	"Grand total of "
170$:	.ASCIZ	" allocated"
	UNORG

.DSABL	LSB

.SBTTL	DIRECTORY OUTPUT ROUTINE

.ENABL	LSB

DNCRLF::MOV	#DIRBUF,R5	; POINT TO THE BUFFER
DRCRLF::MOVB	#15,(R5)+	; END THE LINE
	MOVB	#12,(R5)+
	MOV	LSTEPL,LSTCTR	; RESET ITEMS PER LINE FOR /W
DIRPUT::CMP	R5,#DIRBUF	; NULLNESS
	BEQ	40$		; YES, EASY OUT
	MOVB	#200,(R5)	; SET STOPPER FOR .PRINT
	MOV	#DIRBUF,R0	; POINT TO THE BUFFER
	BIT	#SOMOUT,SCNFLG	; FILE FOR OUTPUT?
	BNE	10$		; YES, EMIT IT
	.PRINT			; PRINT IT
	BR	40$		; RESET POINTER AND RETURN

10$:	MOV	R0,R1		; COPY START OF TEXT
	MOV	R0,R2		; COPY BUFFER PARAMETER POINTER
	SUB	R0,R5		; COMPUTE NUMBER OF CHARACTERS TO EMIT
20$:	CMP	-(R2),#1000	; IS THE BUFFER NOW FULL?
	BLO	30$		; NOPE, JUST SHOVE IT IN
	MOV	R4,-(SP)	; SAVE FOR WRITE
	MOV	R5,-(SP)	;  INTERFACE
	MOV	-(R2),R4	; POINT TO END OF BUFFER
	CALL	WRITE		; WRITE ONE BLOCK FROM BUFFER
	MOV	R4,(R2)+	; RESET OUTPUT POINTER
	CLR	(R2)		; NOTHING IN BUFFER NOW
	MOV	(SP)+,R5	; RESTORE
	MOV	(SP)+,R4	;  REGISTERS
30$:	MOVB	(R1)+,@-(R2)	; PUT A BYTE IN THE BUFFER
	INC	(R2)+		; BUMP BUFFER POINTER
	INC	(R2)+		; BUMP COUNTER
	SOB	R5,20$		; DO MORE
40$:	MOV	#DIRBUF,R5	; RESTORE POINTER TO BUFFER
	RETURN

.DSABL	LSB

.SBTTL	INITIALIZE FOR DIRECTORY AND PRINT DIRECTORY HEADER LINE

.ENABL	LSB

DIRHDR::MOV	FIRQB+FQPPN,(R4)+ ; SAVE PPN OF DIRECTORY
	MOV	FIRQB+FQDEV,(R4)+ ; SAVE DEVICE OF DIRECTORY
	MOV	FIRQB+FQDEVN,(R4)+ ; SAVE UNIT NUMBER OF DIRECTORY
	CLR	(R4)+		; ZERO FILES SO FAR
	CLR	(R4)+		; ZERO BLOCKS SO FAR
	CLR	(R4)+		;  IN MSB, TOO
	MOV	(R4)+,R2	; GET THE DIRECTORY SWITCHES
	BIS	SWTTBL,R2	; 'OR' IN THE PERMANENT FLAGS FROM OUTPUT SPEC
	BNE	10$		; OK IF ANY SWITCHES HERE AT ALL
	MOV	DDFALT,R2	; ELSE USE THE LISTING DEFAULT

10$:	BIT	R2,#DIR.SU	; Was SUmmary requested?
	BEQ	20$		; [no - continue]
	BIC	#^C<DIR.SU!DIR.AL>,R2   ; Yes:  override any "detail" requests

20$:	TSTB	INFQB+F$HIDX	; DIRECTORY OF DISK?
.ASSUME	DSKHND	EQ	0
	BEQ	30$		; YES, ALL THINGS ARE LEGAL
	BIC	#DIR.ND,R2	; TURN OFF SOME "NOT DISK" BITS
30$:	TSTB	INFQB+F$FLAG	; IS THIS AN ANSI MAGTAPE?
.ASSUME	ANSIMT	EQ	200
	BPL	40$		; NO
	BIC	#DIR.PR,R2	; YES, NO PROTECTION CODES HERE
40$:	MOV	R2,LSTSWT	; SAVE THE TRUE LISTING SWITCHES
	MOV	#LWIDTH+<16.*2>,R1 ; POINT TO WIDTH OF FIELDS
	CLR	-(SP)		; START WITH NOTHING
50$:	MOV	-(R1),R0	; GET THE FIELD WIDTH FOR THIS BIT
	ASL	R2		; IS THIS LISTING BIT ON?
	BCC	60$		; NO, IT DOESN'T COUNT
	ADD	R0,(SP)		; YES, INCREASE WIDTH
60$:	TST	R2		; DONE?
	BNE	50$		; NO
	;CLR	R2		; CLEAR FOR DIVIDE
	MOV	(R4)+,R3	; GET TERMINAL WIDTH
	SUB	(SP),R3		; LAST FIELD ON LINE HAS NO TAB
	BGT	70$		; AT LEAST ONE FITS
	CLR	R3		; DON'T BLOW THE DIVIDE
70$:	ADD	#4,(SP)		; OTHERS END WITH SPACES
	DIV	(SP)+,R2	; COMPUTE NUMBER OF FILES PER LINE
	INC	R2		; COUNT THE LAST FILED
	MOV	R2,(R4)+	; SET RESET VALUE
	MOV	R2,(R4)+	; SET ENTRIES PER LINE
	BIT	#SOMOUT,SCNFLG	; FILE FOR OUTPUT?		  ;JJT014
	BNE	75$		; YES, DON'T RESTORE THE CARRIAGE ;JJT014
	CALL	LMARGN		; RESTORE THE CARRIAGE		  ;JJT014
75$:	MOV	R2,-(SP)	; Save R2			  ;JJT014
	CALL	DRCRLF		; AND LEAVE ONE LINE BLANK
	MOV	(SP)+,R2	; Restore R2
	MOV	(R4),R4		; GET THE LISTING SWITCHES
	BIT	R4,#DIR.HD	; DIRECTORY HEADER?
	BEQ	140$		; NO, JUST THE DEVICE NAME
	MOV	#HEADER,R0	; POINT TO THE HEADER PROTOTYPE
	MOV	#LWIDTH,R1	; POINT TO WIDTHS
	CLR	R3		; NOTHING YET
	BR	90$		; ENTER THE LOOP

80$:	MOVB	(R0)+,(R5)+	; PUT OUT A CHARACTER
	SOB	R3,80$
90$:	MOV	R5,R3		; COPY POINTER TO (CURRENT) END OF HEADER
	TST	R4		; ANY MORE BITS?
	BEQ	120$		; NO, DONE THE LINE
	ROR	R4		; IS THIS FIELD PRESENT?
	MOV	(R1)+,R3	; GET FIELD WIDTH
	BEQ	90$		; IF WIDTH IS 0, DON'T BOTHER
	BCS	80$		; IF PRESENT, ADD IT TO THE HEADER
	ADD	R3,R0		; NO, SKIP IT IN THE PROTOTYPE
	BR	90$		; TRY AGAIN

100$:	MOV	#DIRBUF,R1	; POINT TO START OF HEADER DATA
110$:	MOVB	(R1)+,(R5)+	; COPY A BYTE
	CMP	R1,R3		; UP TO SPACE TRAILER YET?
	BLO	110$		; NO
120$:	MOV	R5,R4		; COPY POINTER TO END OF HEADER
	MOVB	#40,(R5)	; EMIT
	MOVB	(R5)+,(R5)	;  FOUR
	MOVB	(R5)+,(R5)	;   SPACE
	MOVB	(R5)+,(R5)+	;    CHARACTERS
	TST	LSTSWT		; WIDE LISTING?
.ASSUME	DIR.W	EQ	100000
	BPL	130$		; IF NOT, ONLY ONE HEADER
	BIT	#DIR.OA!DIR.SA,LSTSWT ; ARE WE PRINTING ATTRIBUTES TOO?
	BNE	130$		;   YES, WIDE LISTING IS NOT POSSIBLE
	SOB	R2,100$		; EMIT ONE HEADER SET PER COLUMN
130$:	CALL	DPRINT		; EMIT THE DEVICE NAME
	MOV	R5,R0		; COPY THE POINTER NOW
	SUB	#DIRBUF,R0	; COMPUTE LENGTH
	CMP	R0,KBSIZE	; DOES THIS ALL FIT?
	BLOS	150$		; IF SO, EMIT HEADER-SPACES-DEVICE
	MOV	R4,R5		; IF NOT, BACK OVER TO THE END OF HEADER
	CALL	DRCRLF		; EMIT IT
140$:	CALL	DPRINT		; EMIT THE DEVICE AND ACCOUNT
150$:	CALLR	DRCRLF		;  ON A NEW LINE

.DSABL	LSB

.SBTTL	EMIT DIRECTORY DEVICE NAME AND PPN

.ENABL	LSB

DPRINT::TSTB	INFQB+F$HIDX	; DOING DISK?
.ASSUME	DSKHND	EQ	0
	BNE	10$		; NOPE
	TSTB	DIRDVN+1	; YES, IS UNIT NUMBER REAL?
	BEQ	20$		; IF NOT, USE 'SY:'
10$:	MOV	DIRDEV,R1	; GET THE DEVICE NAME
	BNE	30$		; IF ANY
20$:	MOV	#"SY,R1		; IF NONE, SAY SY:
30$:	MOVB	R1,(R5)+	; EMIT THE DEVICE
	SWAB	R1
	MOVB	R1,(R5)+
	MOV	DIRDVN,R0	; GET THE UNIT
	MOVB	R0,(R5)		; ASSUME IT IS REAL
	BISB	#'0,(R5)
	SWAB	R0		; IS IT REAL?
	BEQ	40$		; NO
	INC	R5		; YES, EMIT IT

	CLR	R0		; SETUP FOR UNIT#	;037
	MOVB	DIRDVN, R0	; GET THE UNIT#		;037
	CMP	R0, #9.		; SINGLE DIGIT?		;037
	BLE	40$		; NO, CONTINUE		;037
	MOVB	#'1, -1(R5)	; PUT IN THE "1"	;037
	SUB	#10., R0	; ISOLATE SECOND DIGIT	;037
	MOVB	R0,(R5)		; PUT IN SECOND DIGIT	;037
	BISB	#'0,(R5)+	; MAKE IT ASCII		;037
	
40$:	MOVB	#':,(R5)+	; END OF DEVICE
	CMPB	#DTAHND,INFQB+F$HIDX ; DOING DECTAPE?
	BEQ	50$		; YES, NO PPN
	TSTB	INFQB+F$FLAG	; DOING ANSI MAGTAPE?
.ASSUME	ANSIMT	EQ	200
	BMI	50$		; YES, ALSO NO PPN
	MOV	DIRPPN,R1	; GET THE PPN
	BNE	PRTPPN		; IF ANY, USE IT
	MOV	OURPPN,R1	;  ELSE USE OURS
PRTPPN::MOVB	#'[,(R5)+	; OPEN THE PPN
	CALL	60$		; PRINT HIGH BYTE
	MOVB	#',,(R5)+	; COMMA SEPARATES
	CALL	60$		; PRINT LOW BYTE
	MOVB	#'],(R5)+	; DONE
50$:	RETURN

60$:	SWAB	R1		; GET HIGH BYTE INTO LOW BYTE
	MOVB	#'*,(R5)+	; ASSUME IT'S WILD
	CLR	R0		; CLEAR FOR BISB
	BISB	R1,R0		; GET THE NUMBER
	INCB	R1		; WAS IT 255. ?
	BEQ	50$		; YUP, USE THE STAR
	DEC	R5		; BACK OVER THE STAR
	CALLRX	NUM$		; PRINT THE NUMBER

.DSABL	LSB

.SBTTL	FIXED FIELD DECIMAL NUMBER CONVERSION - ZERO PADDED

;+
; UNPNUM - EMIT SINGLE PRECISION FIXED FIELD DECIMAL NUMBER
; UNPDBL - EMIT DOUBLE PRECISION FIXED FIELD DECIMAL NUMBER
;
;	R0 -> NUMBER MSB/NUMBER LSB
;	R5 -> OUTPUT STRING
;
;	CALL	UNP???,R4,<FIELD WIDTH>
;
;	R0 -> NEXT WORD
;	R5 -> NEXT BYTE
;
; NOTE:	NUMBER WILL BE RIGHT JUSTIFIED IN FIELD. USE SIZE 0 FOR NO FILL
;-

.ENABL	LSB

UNPDBL::TST	(PC)+		; C=0 FOR DOUBLE PRECISION
UNPNUM::SEC			; C=1 FOR SINGLE PRECISION
	MOV	#"00,70$	; SET THE PAD CHARACTER
	MOV	(R4)+,50$	; SET THE FIELD WIDTH
	REGSAV			;  SAVE ALL THE REGISTERS
	BCS	10$		; IF UNPNUM DO ALTERNATE
	MOV	(R0)+,R1	; SET MSB
	MOV	(R0)+,R0	; SET LSB
	ADD	#4,(SP)		; UPDATE R0 ON THE STACK
.ASSUME	TOS.R0	EQ	0	; (ONLY WITH REGSAV, NOT WITH REGSCR)
	BR	30$		; MERGE TO WORKING ROUTINE

10$:	MOV	(R0)+,R0	; SET LSB
	ADD	#2,(SP)		; UPDATE R0 ON STACK
.ASSUME	TOS.R0	EQ	0	; (ONLY WITH REGSAV, NOT WITH REGSCR)
	BR	20$		;  AND MERGE TO WORKING ROUTINE

.SBTTL	FIXED FIELD DECIMAL NUMBER CONVERSION - SPACE PADDED

;+
; DECNUM - EMIT SINGLE PRECISION FIXED FIELD DECIMAL NUMBER
; DECDBL - EMIT DOUBLE PRECISION FIXED FIELD DECIMAL NUMBER
;
;	R0 =  NUMBER TO PRINT LSB
;	R1 =  NUMBER TO PRINT MSB (DECDBL ONLY)
;	R5 -> OUTPUT STRING
;
;	CALL	DEC???,R4,<FIELD WIDTH>
;		- OR -
;	DEC???	FIELD_WIDTH
;
;	R5 -> NEXT BYTE
;
; NOTE:	NUMBER WILL BE RIGHT JUSTIFIED IN FIELD. USE SIZE 0 FOR NO FILL
;-

DECDBL::TST	(PC)+		; C=0 FOR DOUBLE PRECISION
DECNUM::SEC			; C=1 FOR SINGLE PRECISION
	MOV	#SPACE*400+SPACE,70$; SET THE PADDING CHARACTER
	MOV	(R4)+,50$	; SAVE FIELD WIDTH
	REGSAV			; SAVE REGISTERS
	BCC	30$		; NUMBER MSB IS SET IF DOUBLE PRECISION
20$:	CLR	R1		; MSB IS 0 FOR SINGLE PRECISION
30$:	MOV	R0,R3		; COPY LSB TO AN ODD REGISTER
	CLR	R4		; NO DIGITS SAVED YET
40$:	CLR	R0		; CLEAR FOR DIVIDE
	DIV	#10.,R0		; DIVIDE MSB BY 10
	MOV	R1,R2		; PROPAGATE REMAINDER TO MSB OF LOW ORDER
	MOV	R0,R1		; COPY THE QUOTIENT AS NEW MSB
	DIV	#20.,R2		; DIVIDE LOW ORDER QUOTIENT BY 20.  ;JJT013
	ASL	R2		; TO OBTAIN 15 BIT RESULT	    ;JJT013
	CMP	#10.,R3		; AND THEN CORRECT		    ;JJT013
	BGT	45$		; TO OBTAIN DIVISION BY 10.	    ;JJT013
	SUB	#10.,R3		; GET REMAINDER LESS THAN 10.	    ;JJT013
	INC	R2		; ADD CARRY TO QUOTIENT		    ;JJT013
45$:	BIS	#'0,R3		; MAKE REMAINDER ASCII		    ;JJT013
	MOV	R3,-(SP)	; SAVE A BYTE
	INC	R4		; ONE MORE BYTE SAVED
	MOV	R2,R3		; COPY QUOTIENT AS NEW LSB
	BIS	R1,R2		; ENTIRE NUMBER NOW 0?
	BNE	40$		; NO, MORE TO DO
	MOV	(PC)+,R0	; GET FIELD WIDTH
50$:	 .WORD	0		; SAVE AREA
	SUB	R4,R0		; COMPUTE NUMBER OF BLANKS TO FILL
	BLE	80$		; IF NONE, DON'T FILL
60$:	MOVB	(PC)+,(R5)+	; PAD
70$:	.WORD	0		; WITH THIS CHARACTER
	SOB	R0,60$		; 
80$:	MOVB	(SP)+,(R5)+	; MOVE
	SOB	R4,80$		;  NUMBER
	MOV	R5,TOS.R5(SP)	; SAVE NEW TEXT POINTER
	REGRES			; RESTORE REGISTERS
	RETURN	R4

.DSABL	LSB

.SBTTL	CONVERT DATE TO STRING

.ENABL	LSB

CVTDAT::CLR	XRB+2		; Init the time word to 0		;077
	MOV	@(R1)+,XRB	; SET UP THE DATE IN THE XRB
	BNE	30$		; IF ANY, GO GET IT
	MOVB	R4,(R5)+	; FILL WITH 10. BLANKS. THIS IS NUMBER 1
10$:	MOV	#9.,R0		; IF NULL, BLANK FILL
20$:	MOVB	R4,(R5)+
	SOB	R0,20$
	RETURN	R1

.SBTTL	CONVERT TIME TO STRING

CVTTIM::MOV	@(R1)+,XRB+2	; SET UP THE TIME IN THE XRB
	BEQ	10$		; IF NULL, BLANK FILL
	CLR	XRB		; SET XRB+0 = 0 FOR TIME CONVERSION
30$:	MOVB	R4,(R5)+	; ALWAYS A LEADING BLANK
	MOV	R5,R0		; COPY THE TEXT POINTER
	.DATTIM			; CALL RT11 TO DO IT
	MOV	R0,R5		; COPY THE POINTER BACK
	RETURN	R1

.DSABL	LSB

.SBTTL	RENAME A FILE'S RTS

.ENABL	LSB

RTSREN::BIT	#RTS,R2		; IS THIS WHAT IS REQUESTED?
	BEQ	COPY		; NO, CONTINUE
	BIT	#SOMOUT,R2	; IS THERE ANY OUTPUT?
	BNE	COPY		; YES, SO RTS RENAME IS AFTER COPY
	POINTX	<%Can't set RTS on non-disk file - >,NOCR,R1
	TSTB	INFQB+F$HIDX	; IS INPUT FROM DISK?
.ASSUME	DSKHND	EQ	0
	BNE	50$		; NO, ERROR HIM
	POINTX	<%Can't set RTS on large file - >,NOCR,R1
	TSTB	FIRQB+21	; IS THIS A LARGE FILE?
	BNE	50$		; YES, ERROR!
	SETERR	PRVIOL		; PRESET THE ERROR CONDITION
	BITB	#US.NOK,FIRQB+FQNENT+1; IS THIS A PROTECTED FILE?
	BNE	20$		; YES, GIVE HIM THE ERROR
	CALL	OPENIN		; OPEN THE FILE FOR INPUT
	BCC	30$		; NO, ERRORS OCCURRED
10$:	MOVB	FIRQB,-(SP)	; SAVE THE ERROR CONDITION
	.CLOSE	IN		; CLOSE THE INPUT FILE, FOR SAFETY
	MOVB	(SP)+,FIRQB	; RESET THE ERROR CODE
20$:	CALLR	ERCONT		;  AND ERROR OUT

30$:	MOVB	INAFQB+FQFIL,R0	; SET THE CHANNEL NUMBER		;073
	CALL	RTSNAM		; do the RTS naming thing		;073
	TSTB	FIRQB		; WAS THERE AN ERROR
	BNE	10$		; YES - PRINT ERROR
	.CLOSE	IN		; CLOSE THE FILE
	TST	SCNFLG		; DOES THE USER WANT A LOG?
.ASSUME	LISTFN	EQ	100000
	BPL	40$		; NO, CONTINUE TO NEXT FILE SPEC
	MOV	INFQB+FQPPN,@SYSPTR; SET THE PROPER PPN
.ASSUME	PPN	EQ	0	;
	MOV	PTRIN,R0	; GET THE FILE SPEC POINTER
	.SETFQB			; SETUP THE FIRQB
	CALL	PRDVPP		; PRINT THE FILE NAME
	PRINT	< set to RTS >,NOCR ;  AND ANOTHER PART OF THE MESSAGE

	MOV	#FNBUFF,R5	; GET A TEMP BUFFER
	MOV	#OUTRTS,R0	; GET A POINTER TO THE RTS NAME
	CALLX	RAD$W2		; CONVERT IT
	CLRB	(R5)		; INSURE A CR/LF
	.PRINT	#FNBUFF		; PRINT THE RTS NAME
40$:	RETURN			; AND RETURN

50$:	CALL	CVDVPP		; GET THE FILE NAME
	.PRINT	R1		; PRINT THE ERROR MESSAGE
	.PRINT	#FNBUFF		;  AND PRINT THE FILE NAME
	.PRINT	#CONTXT		;   AND SAY CONTINUING
	RETURN			; FINALLY RETURN

.DSABL	LSB

.SBTTL	Run-Time-System Naming routine

;	Inputs
;		R0 has the channel #
;		OUTRTS and OUTRTS+2 contains new RTS name
;	Outputs
;		RTS name changed
;		and FIRQB tested for error

RTSNAM:	MOV	R0,-(SP)	; Save the channel #			;073
	MOV	#FIRQB+FQFUN,R0	; GET THE POINTER TO THE FIRQB		;073
	MOVB	#UU.FIL,(R0)+	; SET THE UU.FIL FUNCTION		;073
	MOVB	(SP)+,(R0)+	; SET THE CHANNEL NUMBER		;073
	MOVB	#10,(R0)+	; Set function to write RTS name	;073
	MOV	OUTRTS,FQSIZ-FQPPN(R0) ; SET THE RTS NAME		;073
	BEQ	10$		; But, don't make the file large	;073
	MOV	OUTRTS+2,FQNAM2-FQPPN(R0) ;   BOTH WORDS		;073
	CLR	FQCLUS-FQPPN(R0) ; Don't change anything else		;073
	CLR	36-FQPPN(R0)	; Clear this in case the future changes	;073
	.PRIV,	.UUO		; HAVE RSTS change it!			;073
10$:	RETURN			; and go back home			;073

.SBTTL	COPY A SINGLE FILE

.ENABL	LSB

COPY::	MOVB	FIRQB+FQNENT+1,INUST; SAVE INPUT FILE USTAT BYTE (IF DISK)
	CALL	OPENIN		; OPEN THE INPUT FILE
	BCC	10$		; IF NO ERROR, CONTINUE
	JMP	ERCONT		; REPORT ERROR AND SKIP FILE

10$:	CMPB	INAFQB+FQFLAG,#MTAHND; IS THE INPUT MAGTAPE?
	BNE	20$		; NO, CONTINUE WITH NORMAL PROCESSING
	TSTB	INFQB+F$FLAG	; IS THE INPUT ANSI TAPE?
.ASSUME	ANSIMT	EQ	200
	BMI	20$		; YES, THEN BUFFERSIZE SHOULD BE RIGHT
	CLR	INAFQB+FQBUFL	; NO, DOS FORMAT, NEVER BELIEVE BUFFERSIZE
20$:	MOV	#INATRC,R0	; POINT TO INPUT FILE ATTRIBUTES
	MOV	#OUTATC,R1	; POINT TO AREA TO COPY THEM TO
	MOV	(R0)+,R2	; GET NUMBER OF WORDS
	MOV	R2,(R1)+	; COPY THAT
	BEQ	40$		; IF NONE, EASY
30$:	MOV	(R0)+,(R1)+	; COPY A WORD
	SOB	R2,30$		;  AND REPEAT AS NECESSARY
40$:	MOV	#BL2BL,-(SP)	; ASSUME BLOCK MODE TRANSFER DISPATCH
	MOV	BUFFER,R2	; POINT TO BUFFER AREA
	ADD	DTBSIZ,R2	; TAKE AWAY FOR DECTAPE INPUT BUFFER MAGIC
	MOV	BUFSIZ,R3	; GET SIZE OF AREA IN BYTES
	BIC	#777,R3		; MAKE THE BUFFER A 512. BYTE BLOCK MULTIPLE
	SUB	DTBSIZ,R3	; REMOVE DECTAPE MAGIC
	MOV	R2,R4		; SET OUTPUT BUFFER
	MOV	R3,R5		;  SAME AS INPUT BUFFER
	TSTB	RMSFLG		; /BL SPECIFIED?
.ASSUME	CV.BLK	EQ	200
	BMI	60$		; YES, JUST DO IT
	TSTB	INFQB+F$FLAG	; IS THIS AN ANSI MAGTAPE ?
.ASSUME	ANSIMT	EQ	200
	BPL	50$		; NO, GO CHECK INPUT  ATTRIBUTES
	BIT	#MC$VAR!MC$FIX,IMCHRW ; IS THIS AN ANSI F OR D FORMAT ?
	BNE	50$		; YES,50$				;009
	BIT	#CV.ASC,RMSFLG	; NO, IT'S ANSI U, SO PROCESS AS /BL    ;009
				;   IS THIS A FORCED ASCII CONVERSION?  ;009
	BNE	110$		; YES, GO DO THE ASCII THING
				;   ELSE, TRANSFER IS BL, SO GO DO IT   ;004+
	CMPB	#MTAHND,OUTFQB+F$HIDX ; IS IT MAGTAPE OUTPUT ? 		
	BEQ	45$		; YES, GO JUMP TO 170$			;034
	JMP	190$		; NO, 190$ 				;004-

45$:	JMP	170$		; YES, 170$ 				;034

50$:	TST	INATRC		; NO, DOES INPUT HAVE ATTRIBUTES?
	BEQ	120$		; IF NOT, CHECK FOR /RMS OUTPUT
	TST	SWITCH		; /RMS ON INPUT FILE SPEC?
	BPL	70$		; IF NOT, MAY BE AUTOMATIC ON ATTR -> NONATTR
	CALL	ATRCHK		; DISK/RMS => * - REQUIRE GOOD ATTRIBUTES
	BCC	80$		; If we can use them, go init RMS input
60$:	BR	170$		; Else, go do /BL

70$:	TSTB	OUTFQB+F$FLAG	; INPUT IS ATTRIBUTED WITH NO /RMS. OUT=ATTR
	BNE	130$		; IF SO, NO RMS CONVERSION (COPY ATTRIBUTES)
	CALL	ATRCHK		; CAN WE USE THESE ATTRIBUTES?
	BCS	170$		; ERROR, CAN'T INTERPRET ATTRIBUTES, DO /BL
	CMPB	INATR+F.RTYP,#R.FIX ; INPUT IS FIXED LENGTH?
	BNE	80$		; NO, REALLY DO CONVERSION
	CMPB	#TTYHND,OUTFQB+F$HIDX ; Is output to a terminal?
	BEQ	80$		; Yes, attempt automatic conversion
	CMPB	#LPTHND,OUTFQB+F$HIDX ; Is output to a line printer?
	BEQ	80$		; Yes, attempt automatic conversion
	CMP	INATR+F.RSIZ,#1000 ; YES, FIXED LENGTH 512 BYTES?
	BEQ	170$		; NO AUTOMATIC CONVERSION IF TASK OR LIBRARY!
80$:	MOV	INATR+F.EFBK,R0	; GET EOF BLOCK MSB
	MOV	INATR+F.EFBK+2,R1;  AND LSB
	SUB	#1,R1		; MAKE IT RELATIVE TO 0
	SBC	R0		;  SINCE EOF BLOCK # IS ALWAYS >= 1
	ASHC	#9.,R0		; SHIFT TO BYTE NUMBER
	ADD	INATR+F.FFBY,R1	; ADD IN OFFSET WITHIN LAST BLOCK OF EOF BYTE
	MOV	R0,INATR+F.EFBK	; SAVE BYTE OFFSET IN FILE OF EOF BYTE
	MOV	R1,INATR+F.EFBK+2;  AS A DOUBLEWORD
	CLR	OUTATC		; NO OUTPUT ATTRIBUTES, SINCE WE'RE STRIPPING
	MOVB	SWITCH,R1	; GET THE /RMS:XX VALUE
	BEQ	90$		; NONE SPECIFIED
	TST	-(R1)		; DECREMENT OFFSET BY TWO
	CMP	#4,R1		; DID THE USER SPECIFY /RMS:FA?		;034
	BNE	100$		; NO, JUST CONTINUE			;034
	BITB	#1,INATR+F.RATT	; IS IT A FORTRAN FILE?			;034
	BNE	90$		; YES, GO USE THE FORTRAN COPIER INSTEAD ;034
	BR	100$		; NO, GO DISPATCH			;034

90$:	MOVB	INATR+F.RATT,R1	; IF NONE, GET THE RECORD ATTRIBUTES
	BIC	#^C<7>,R1	; USE 4=PRN, 2=FA, 1=FTN, 0=FB
	ASL	R1		; MULTIPLY BY TWO FOR OFFSET INTO JMP TABLE
	BIT	#FD.PRN*2,R1	; IS THE PRINT FORMAT BIT ON?
	BEQ	100$		; NO, LET IT BY
	BIC	#^C<FD.PRN*2>,R1; ELSE MAKE SURE LOW BITS ARE CLEAR
100$:	MOV	RMSDSP(R1),(SP)	; GET DISPATCH ADDRESS
	CMPB	INATR+F.RTYP,#R.ASC ; INPUT FILE IS STREAM ASCII?
	BNE	150$		; NO
110$:	MOV	#FA2FA,(SP)	; YES, REROUTE TO FA COPIER
	BR	150$		; GO DIVIDE BUFFER SPACE

120$:	TSTB	OUTFQB+F$FLAG	; INPUT IS NON-ATTR, IS OUTPUT ATTRIBUTABLE?
	BNE	130$		; YES, GO CHECK FOR /RMS SWITCHES	;027
	CMPB	#TTYHND,OUTFQB+F$HIDX ; Is output to a terminal?	;027
	BEQ	110$		; Yes, go use the Formatted ascii copier ;027
	BR	170$		; No, stay with the Block-to-block copier ;027

130$:	TST	SWTTBL		; NONDISK => DISK. IS /RMS ON OUTPUT FILE?
	BPL	170$		; NO, NO CONVERSION TO RMS FORMAT
	MOV	#FX2RMS,(SP)	; DISPATCH TO DECIDE FA VS. FB AND CONVERT
	MOV	#OUTATC,R0	; POINT TO OUTPUT ATTRIBUTES
	MOV	#7,(R0)+	; SEVEN WORDS
	MOV	#2*400+2,(R0)	; VARIABLE RECORDS, ASSUME ASCII
	CMPB	SWTTBL,#2	; IS THIS A FORMATTED BINARY REQUEST?
	BNE	140$		; NO, WE DON'T KNOW WHAT IT IS
	CLRB	1(R0)		; YES, SET THE FORMATTED BINARY ATTRIBUTE

140$:	TST	(R0)+		; BUMP THE POINTER TO THE OUTPUT ATTRIBUTES	
	CLR	(R0)+		; LONGEST RECORD IS 0 LENGTH
	CLR	(R0)+		; BLOCKS IN FILE
	CLR	(R0)+		;  ARE NONE
	CLR	(R0)+		; EOF BLOCK NUMBER
	MOV	#1,(R0)+	;  IS ONE
	CLR	(R0)+		; OFFSET IN EOF BLOCK IS 0
150$:	CLC			; PREPARE FOR ROR
	ROR	R3		; HALVE INPUT BYTE COUNT
	;CLC			; INPUT BYTE COUNT WAS N*1000, SO C=0
	ROR	R5		; HALVE OUTPUT BYTE COUNT
	BIT	R5,#400		; PARTIAL BLOCK?
	BEQ	160$		; IF NOT, NO PROBLEM
	SUB	#400,R5		; PUNISH THE OUTPUT BUFFER BY 1/2 BLOCK
	ADD	#400,R3		;  AND GIVE IT TO THE INPUT BUFFER
160$:	ADD	R3,R4		; START OF OUTPUT IS BEYOND END OF INPUT
	CLR	INAFQB+FQSIZ	; DON'T PRE-EXTEND OUTPUT IF CONVERTING
	CLRB	INAFQB+FQSIZM	;   CLEAR HIGH BYTE OF SIZE ALSO
170$:	CMP	R2,R4		; ARE WE DOING BLOCKED MODE TRANSFER
	BNE	190$		; NO, TRANSFER MODE IS ALREADY SET
	BIT	#CV.ASC,RMSFLG	; DO WE WANT ASCII CONVERSION?
	BNE	110$		; YES, GO SET IT
	CMPB	#MTAHND,INFQB+F$HIDX ; IS THIS MAGTAPE
	BEQ	180$		; DO IMAGE
	CMPB	#MTAHND,OUTFQB+F$HIDX; IS THIS MAGTAPE?
	BNE	220$		; NO, NEITHER ARE MAGTAPE
180$:	MOV	#IM2IM,(SP)	; REROUTE TO IMAGE COPY
	TSTB	RMSFLG		; IS THIS A FORCED BLOCK MODE
	BMI	150$		; YES, REROUTE IT
	TST	INATRC		; IS THE INPUT ATTRIBUTED
	BEQ	150$		; NO, DO THE IMAGE COPY
	CALL	ATRCHK		; ARE INPUT ATTRIBUTES ANY GOOD		;047
	BCC	185$		;  YES, THEN USE 'EM			;047
	BIS	#200,RMSFLG	; ELSE REVERT TO /BL MODE		;047
	BR	150$		;  AND GO DO IT				;047

185$:	TST	OUTATC		; IS THE OUTPUT ATTRIBUTED
	BEQ	150$		; NO, SO DON'T ATTRIBUTE IT
	CMPB	#R.ASC,INATR+F.RTYP ; IS THIS REALLY A STREAM ASCII FILE?
	BEQ	150$		; YES, DO THE STREAM ASCII THING
	MOV	#RC2RC,(SP)	; NO, SET THE RECORD COPY ROUTINE
	TSTB	INFQB+F$FLAG	; IS THE INPUT ANSI?
.ASSUME	ANSIMT	EQ	200
	BMI	150$		; YES, JUST SPLIT BUFFERS
	MOV	INATR+F.EFBK,R0	; YES, GET EOF BLOCK MSB
	MOV	INATR+F.EFBK+2,R1;  AND LSB
	SUB	#1,R1		; MAKE IT RELATIVE TO 0
	SBC	R0		;  SINCE EOF BLOCK # IS ALWAYS >= 1
	ASHC	#9.,R0		; SHIFT TO BYTE NUMBER
	ADD	INATR+F.FFBY,R1	; ADD IN OFFSET WITHIN LAST BLOCK OF EOF BYTE
	MOV	R0,INATR+F.EFBK	; SAVE BYTE OFFSET IN FILE OF EOF BYTE
	MOV	R1,INATR+F.EFBK+2;  AS A DOUBLEWORD
	BR	150$		;   AND SPLIT THE BUFFERS

190$:	CMPB	OUTFQB+F$HIDX,#MTAHND ; IS THE OUTPUT MAGTAPE?
	BNE	220$		; NO

	TST	BLENG		; IS THERE A BUFFER SIZE DESIRED?
	BNE	200$		; YES
	MOV	#1000,BLENG	; NO, USE STANDARD 512.
..BSDE	==	.-4	;**PATCH** TO CHANGE DEFAULT BLOCK LENGTH

1910$:
	MOV	R0,-(SP)	; SAVE R0				;068
	BIT	#ANSIMT,OUTFQB+F$FLAG ; IS THIS AN ANSI TAPE OUTPUT?	;068
	BEQ	1950$		; NO, DON'T CHANGE BUFFER/BLOCK SIZE	;068
	MOVB	OUTATR,R0	; GET THE FIRST ATTRIBUTE		;068
	BIC	#^C<17>,R0	; CLEAR ALL BUT RECORD FORMAT BITS 0-3	;068
	CMPB	R0,#R.FIX	; IS THIS FIXED FORMAT?			;068
	BEQ	1920$		; YES, SET THE BLOCKSIZE		;068
	CMPB	R0,#R.VAR	; IS THIS VARIABLE FORMAT?		;068
	BNE	1950$		; NO, DON'T ALTER THE BLOCKSIZE		;068
1920$:	MOV	OUTATR+2,R0	; GET RECORD SIZE			;068
	CMP	OUTATR+20,R0	; COMPARE WITH OTHER RECORD SIZE	;068
	BLE	1930$		; IF +20 IS NO BIGGER THEN USE +2	;068
	MOV	OUTATR+20,R0	; ELSE MOVE +20 TO R0			;068
1930$:	TST	R0		; DO WE HAVE A NON-ZERO RECORDSIZE?	;068
	BEQ	1950$		; IF BOTH = 0 THEN DON'T SET BLOCK SIZE	;068
	ADD	#1,R0		; MAKE 					;068
	BIC	#1,R0		;      RECORDSIZE EVEN			;068
	CMP	#18.,R0		; IS RECORDSIZE AT LEAST 18. FOR TAPE?	;068
	BLE	1940$		; YES, USE IT				;068
	MOV	#18.,R0		; NO, USE 18.				;068
1940$:	MOV	R0,BLENG	; SET NEW BUFFER LENGTH (BLOCK LENGTH)	;068
1950$:	MOV	(SP)+,R0	; RESTORE R0				;068

200$:	CMP	BLENG,R5	; IS THERE ENOUGH ROOM IN THE OUTPUT BUFFER
	BHI	280$		;  NO, DIE A HORRIBLE DEATH
210$:	MOV	R5,R1		; GET CURRENT SIZE OF BUFFER
	SUB	BLENG,R1	; SUBTRACT THE NEW LENGTH
	BIC	#777,R1		; MAKE IT A BLOCK MULTIPLE
	ADD	R1,R4		; ADD IN NEW OUTPUT BUFFER POINTER
	ADD	R1,R3		; INCREASE THE INPUT BUFFER LENGTH
	MOV	BLENG,R5	; SET NEW OUTPUT BUFFER SIZE
220$:	CMP	R3,INAFQB+FQBUFL ; CAN SOMETHING FIT FROM THE DEVICE?
	BLO	280$		; NO, UGH
	CMP	R3,#2000	; AT LEAST 2 BLOCKS OF INPUT BUFFER?
	BHIS	230$		; YES
	CMPB	INAFQB+FQFLAG,#DTAHND ; DECTAPE INPUT?
	BEQ	280$		; IF SO, NEED AT LEAST 2 BLOCKS
230$:	MOV	#IBFPTR,R0	; POINT TO BUFFER PARAMETERS
	MOV	R2,(R0)+	; SAVE INPUT BUFFER POINTER
	MOV	R3,(R0)+	;  AND LENGTH
	MOV	R4,(R0)+	; SAVE OUTPUT BUFFER POINTER
	MOV	R5,(R0)+	;  AND LENGTH
	BEQ	280$		; JUST IN CASE, LET'S QUIT IF BUFFER ISN'T
	CLR	(R0)+		; NO EOF FLAG ON YET
	MOV	OUTFLG,R0	; OUTPUT ALREADY OPEN? (MERGE)
	BNE	290$		; YES, GO CHECK FOR INVALID MERGE
	CALL	ENTER		; GO OPEN THE OUTPUT FILE
	BCC	310$		; NOT AN ILLEGAL OUTPUT OVERRIDE
	TST	(SP)+		; DUMP COPIER DISPATCH ADDRESS
	CHKERR	FIEXST		; IS THE ERROR FILE EXISTS?
	BNE	240$		;  NO, IT IS A REAL ERROR
	BIT	#NOWARN,SC2FLG	; DOES THE USER WANT THIS ERROR PRINTED?
	BNE	250$		; NO, SO SKIP THE ERRFQB
240$:	CALL	ERCNT1		; Log the error, "continuing"
	CALL	LMARGN		; <CR><LF>
250$:			; Close that input file and quit
	TSTB	INFQB+F$FLAG	; Is the input file magtape ?
.ASSUME	ANSIMT	EQ	200
	BPL	260$		; No (Continue at CLOSE)
	MAGTAP	IN,SKP,177777	; Yes: fake a "read" of file's data
	TSTB	FIRQB		; Error getting to tape mark ?
	BNE	270$		; Yes (Log CLOSE error)
260$:	.CLOSE	IN		; Close that input file and quit
	BCS	270$		; Error on CLOSE ?  Yes			;027
	JMP	390$		; No error, continue at RETURN		;027

270$:			; Error on CLOSE
	RSTSER	CLFAIL,<Close failure>,IN

280$:	ERROR	<Not enough buffer space for copy>

.SBTTL	START THE COPY

290$:	SWAB	R0		; ANY PREVIOUS FILE HAD ATTRIBUTES?
	BNE	300$		; YES, WARN HIM OF POSSIBLE YUCCH
	TSTB	INATRC		; CURRENT INPUT FILE HAS ATTRIBUTES?
	BEQ	310$		; NO, JUST A BLOCK MERGE
..MERG	==	.	;**PATCH** CHANGE TO 3 NOP'S TO GET RID OF MERGE MSG
300$:	WARNF	<Merge with attributes may yield invalid data>		;056
310$:	CMPB	INAFQB+FQFLAG,#TTYHND; IS THE INPUT TERMINAL?		;030
	BNE	315$		; NO, CONTINUE				;030
	TSTB	INFQB+FQDEVN+1	;WAS THERE A UNIT NUMBER SPECIFIED?	;030
	BEQ	313$		; NO, GO PRINT THE PROMPT		;030
	CMPB	INFQB+FQDEVN,OURKB ;IS IT OUR KB?			;030
	BNE	315$		; NO, DON'T PRINT THE PROMPT		;030
313$:	MOV	R0,-(SP)	; SAVE R0				;030
	CALL	LMARGN		; RESTORE THE MARGIN			;030
	POINTX	<Enter text below, type CTRL/Z to end:>			;030
	.PRINT			; PRINT THE PROMPT			;030
	MOV	(SP)+,R0	; RESTORE R0				;030
315$:	BISB	INATRC,OUTFLG+1	; SET FLAG				;030
	BISB	OUTATC,OUTFLG+1	;  SAYING WHETHER EITHER FILE HAS ATTRIBUTES
	CLR	R3		; INPUT BUFFER IS CURRENTLY EMPTY
	CALL	@(SP)+ 		; DISPATCH TO COPIER
	MOV	BLENG,-(SP)	; SAVE ORIGINAL BLOCK SIZE (RECORD LNG) ;007
	TSTB	OUTFQB+F$FLAG	; IS THIS AN ANSI MAGTAPE?
	BPL	320$		; NO, SKIP THE FOLLOWING
	BIT	#MC$FIX,OMCHRW	; IS THE OUTPUT FIXED LENGTH RECORDS?
	BNE	350$		; YES, SO JUST OUTPUT, BUFFER PADDED ALREADY
320$:	MOV	R4,-(SP)	; SAVE THE POINTER TO END OF OUTPUT BUFFER
	MOV	BLENG,R0	; GET THE RECORD LENGTH
	BNE	330$		;  IF THERE IS ONE, USE IT
	MOV	#1000,R0	;    ELSE USE THE 512 BYTE STANDARD BLOCK
330$:	MOV	R4,R5		; GET THE POINTER TO THE 1ST FREE BYTE IN BUFF
	SUB	OBFPTR,R5	; SUBTRACT OFF THE BASE OF THE BUFFER
	CLR	R4		; CLEAR R4 FOR A DIVIDE
	DIV	R0,R4		; DIVIDE BY THE RECORDSIZE
	MOV	(SP)+,R4	; RESTORE R4
	TST	R5		; IS THERE A REMAINDER?
	BEQ	350$		; NO, GO WRITE
	CMPB	OUTFQB+F$HIDX,#TTYHND ;IS THE OUTPUT FILESPEC TERMINAL?	;027
	BNE	335$		; NO, SO CONTINUE			;027
	BIT	#1,R5		; IS THERE AN ODD BYTE COUNT		;027
	BEQ	350$		; NO, GO WRITE OUT WHAT WE GOT		;027
	CLRB	(R4)+		; ADD A NULL BYTE TO MAKE IT EVEN	;027
	INC	R5		; INC THE BYTE COUNT			;027
	BR	350$		; GO WRITE IT OUT			;027

335$:	SUB	R5,R0		; SUBTRACT THE REMAINDER FROM RECSIZE
;+
; Note:  nulls are written to the output buffer to fill it up to the     ;007+
;	 value specified on /BSIZE:n.  When the output filespec is       
;	 magtape, then only the actual number of bytes of data are       
;	 written from the output buffer to the tape record (the nulls    
;	 are ignored).  An executable file transferred from disk to      
;	 tape and then back to disk will still be executable and not     
;	 contain nulls.  When concatenating ASCII files, an odd byte     
;	 count might occur so force it even.				 ;007-
;-
340$:	CLRB	(R4)+		;  AND CLEAR OUT PARTIAL BLOCK
	SOB	R0,340$		;   UP TO A BLOCK BOUNDARY
	CMPB	OUTFQB+F$HIDX,#MTAHND ; IS THE OUTPUT FILESPEC MAGTAPE ? ;007+
	BNE	350$		; NO,350$ - SO SKIP AROUND 		 
	BIT	#1,R5		; IS THERE AN ODD BYTE COUNT ?		 
	BEQ	343$		; NO,343$ - BYTE COUNT IS EVEN AND OKAY  
	INC	R5		; YES, MAKE IT AN EVEN BYTE COUNT	 
				;   (TO ENSURE A GOOD WORD COUNT	 
				;    AND A GOOD ENDING ADDRESS ALSO) 	 
343$:	CMP	R5,#14.		; IS BYTE COUNT LESS THAN 14 BYTES	 ;015
	BHIS	345$		; NO,345$ - BYTE COUNT IS 14 OR GREATER	 ;015
	MOV	#14.,R5		; MINIMUM BYTE COUNT TO TAPE IS 14 BYTES ;015
345$:	MOV	R5,BLENG	; ACTUAL # OF BYTES OF DATA		 
	ADD	OBFPTR,R5	; R5=START OF BUFFER + # BYTES OF DATA   
	MOV	R5,R4		; R4 = ADDRESS OF END OF DATA            ;007-
350$:	CALL	WRITE		; WRITE (POSSIBLY NOTHING)
	MOV	(SP)+,BLENG	; RESTORE BLOCKSIZE TO PROCESS NEXT FILE ;007
 	CALL	CLOSIO		; CLOSE INPUT, OUTPUT (IF NOT MERGE), FIX IT

.SBTTL	LOG THE FILE TRANSFER

	TST	SCNFLG		; DO WE WANT TO LIST THESE?
.ASSUME	LISTFN	EQ	100000
	BPL	390$		; NO, JUST LEAVE
	CALL	LMARGN		; NEW LINE IF NEEDED
	PRINT	<[File >,NOCR
	MOV	INFQB+FQPPN,@SYSPTR; SET THE PROPER PPN
.ASSUME	PPN	EQ	0	;
	MOV	PTRIN,R0	; R0 -> SPEC OF INPUT FILE
	.SETFQB			; GET STUFF
	CALL	PRDVPP		; PRINT IT
	POINTX	< copied to >,NOCR
	TST	UPDENT		; UPDATE TYPE COPY?
	BEQ	380$		; NO, MESSAGE IS RIGHT
	BMI	360$		; OVERRIDE TYPE
	POINTX	< appended to >,NOCR
	BR	380$		; MERGE

360$:	POINTX	< copied into >,NOCR
	CMP	OBLKM,UPDSZM	; DID WE OVERLAY THE WHOLE FILE
	BHI	380$		;  YES
	BLO	370$		;  NO
	CMP	OBLKL,UPDSIZ	; MAYBE?
	BHIS	380$		; YES
370$:	POINTX	< copied into prefix of >,NOCR
380$:	.PRINT			; PRINT IT
	MOV	#OUTSPC,R0	; R0 -> OUTPUT FILE SPEC
	.SETFQB
	MOV	SAVPPN,FIRQB+FQPPN ; SHOVE IN THE RIGHT PPN SPEC
	TSTB	OUTFQB+F$FLAG	; Is output tape ANSI?			;062
.ASSUME	ANSIMT	EQ	200	;					;062
	BPL	385$		; No, print the PPN			;062
	CLR	FIRQB+FQPPN	; Yes, zero the PPN so it won't print	;062
385$:	CALL	PRDVPP		; PRINT DESTINATION NAME		;062
	PRINT	<]>
390$:	RETURN

.DSABL	LSB

.SBTTL	CHECK INPUT FILE ATTRIBUTES FOR LEGALITY

;+
; ATRCHK - CHECK INPUT FILE ATTRIBUTES
;
;	CALL	ATRCHK
;
;	R0 =  RANDOM
;
;	C=1 IF ATTRIBUTES ARE NOT TO BE USED
;-

.ENABL	LSB

ATRCHK::MOV	#INATRC,R0	; POINT TO COUNT OF ATTRIBUTES
	CMP	(R0)+,#7-1	; WE NEED AT LEAST 7, BUT LAST MAY BE 0
	BLO	20$		; IF NOT, CANNOT USE
	CMPB	(R0),#R.ASC	; TYPE = 4 OR HIGHER?
	BHI	20$		; TYPE > 4 IS INVALID
	CMPB	(R0)+,#R.FIX	; FIXED LENGTH RECORDS?
	BLO	20$		; TYPE 0 IS ILLEGAL
	BHI	10$		; SKIP TEST IF TYPE 2 OR 3
	BITB	#FD.BLK,(R0)	; DO RECORDS NOT SPAN BLOCKS?
	BEQ	10$		; SPANNING IS FINE
	CMP	1(R0),#512.	; IF NO SPAN, LENGTH MUST BE <= 1 BLOCK
	BHI	20$		; ERROR IF SPANNING NOSPAN RECORDS
10$:	INC	R0		; SKIP RECORD OPTIONS
	TST	(R0)+		; RECORD LENGTH = 0? (except RF:VAR)	;064
	BNE	30$		; NON-ZERO IS OK			;064
	TST	14(R0)		; RECORD LENGTH = 0? (for RF:VAR)	;063;064
	BNE	30$		; IF NOT, ATTRIBUTES ARE LEGAL, RETURN C=0
20$:	WARNF	<Invalid attributes - ignored>				;056
	BR	40$		; GO SET C=1 FOR ERROR

30$:	TST	(PC)+		; SET C=0 FOR NO ERROR
40$:	SEC			; INDICATE NOT TO USE ATTRIBUTES
50$:	RETURN

.DSABL	LSB

.SBTTL	BLOCK INPUT TO BLOCK OUTPUT

.ENABL	LSB

10$:	ADD	R3,R4		; POINT OUTPUT POINTER TO TOP OF DATA
	ADD	R3,R2		; SAME FOR INPUT
	CLR	R3		; EMPTY INPUT SIDE
	CALL	WRITE		; EMPTY THE OUTPUT BUFFER
BL2BL::	CALL	READ		; FILL INPUT BUFFER
	BCC	10$		; NOT EOF, SO DO A WRITE
	RETURN

.DSABL	LSB

.SBTTL	IMAGE INPUT TO IMAGE OUTPUT

.ENABL	LSB

10$:	MOV	R3,R1		; RECORD LENGTH IS ENTIRE BUFFER
	CALL	CPYIMR		; COPY THE RECORD
IM2IM::	CALL	READ		; GET MORE INPUT
	BCC	10$		; COPY IT IF ANY
	RETURN

.DSABL	LSB

.SBTTL	FORMATTED ASCII COPIER

.ENABL	LSB

10$:	MOV	R3,R1		; RECORD LENGTH IS ENTIRE BUFFER
	CALL	CPYASC		; COPY RECORD
FA2FA::	CALL	READ		; GET AN INPUT LOAD
	BCC	10$		; COPY IT
	RETURN

.DSABL	LSB

.SBTTL	RMS INPUT TO FORMATTED ASCII OUTPUT

.ENABL	LSB

10$:	CALL	VFCTST		; Check for/bypass VFC control field	;054
	CALL	CPYIMR		; COPY ASCII RECORD (SANS CR/LF)
	BITB	#FD.CR,INATR+F.RATT ; ADD ASCII CONTROL?
	BEQ	RMS2FA		; NO, DONE HERE
	CALL	PUTCON,R1,<CRTERM,2> ; EMIT 2 BYTES OF TERMINATOR	;031
RMS2FA::CALL	GETREC		; GET A RECORD
	BCC	10$		; LOOP IF NOT DONE
	RETURN

	TMPORG	DATA
CRTERM:	.BYTE	15,12		; LINE TERMINATOR
	UNORG

.DSABL	LSB

.ENABL	LSB

VFCTST::MOV	R0,-(SP)	; Save a scratch register		;054
	CMPB	#3,INATR+F.RTYP ; Is this a VFC file?			;061
	BNE	10$		; No, don't do anything			;061
	MOV	INATR+14.,R0	; Get 8th attribute			;054
	SWAB	R0		; Isolate Fixed Control Field length	;054
	BIC	^C<377>,R0	; Clear unwanted high byte		;054
	ADD	R0,R2		; Skip over FixContFld in buffer	;054
	SUB	R0,R3		; And reduce buffer count by same amount;054
	SUB	R0,R1		; And reduce record length by same	;054
10$:	MOV	(SP)+,R0	; POP!					;054
	RETURN			; And continue the copy operation	;054

.DSABL	LSB

.SBTTL	RMS FORTRAN INPUT TO FORMATTED ASCII OUTPUT

.ENABL	LSB

10$:	TST	R1		; IS THIS A NULL RECORD?
	BNE	20$		;   NO, PROCESS NORMALLY
	CALL	PUTCON,R1,<CRTERM,2> ;OUTPUT A CR/LF FOR NULL RECORD
	BR	FTN2FA		;       AND GO GET NEXT RECORD

20$:	CALL	GETBYT		; GET A BYTE FROM THE RECORD
	BCS	90$		; IF AN EOF OCCURS, PUNT
	MOV	R0,FAFRST	; SAVE THE FIRST BYTE			;035
	BEQ	60$		; IF IT IS NULL THEN NO CC FOR THIS RECORD
	CMPB	R0,#'1		; CHECK FOR FORM FEED
	BHI	50$		;  NO, BUT ALSO TO HIGH FOR FTN CC
	BEQ	30$		;  YES, SO OUTPUT IT
	CMPB	R0,#'$		; CHECK FOR SUPPRESS CR
	BLOS	50$		;  YES, OR LOWER (IF LOWER NORMAL FTN CC)
	CMPB	R0,#'+		; CHECK FOR NO LINE ADVANCE
	BLO	50$		;  NO, THIS IS NORMAL CC
	BEQ	60$		;  YES, SO JUST COPY RECORD
	CMPB	R0,#'0		; CHECK FOR 2 LINE FEEDS
	BNE	50$		;  NO, THIS IS NORMAL CC
	BR	40$		;  YES, DO 2 LINE FEEDS

30$:	CALL	PUTCON,R1,<FFTERM,2> ;OUTPUT AN LF/FF
	BR	60$		; AND THEN COPY THE RECORD

40$:	CALL	PUTCON,R1,<LFTERM,2> ;OUTPUT AN LF/CR

50$:	CALL	PUTCON,R1,<LFTERM,1> ;OUTPUT AN LF

60$:	DEC	R1		; COUNT ONE LESS BYTE FROM RECORD
	BEQ	70$		; IF NONE LEFT, SKIP THE COPY IMR
	CALL	CPYIMR		; AND COPY THE REST OF RECORD IN IMAGE FORMAT
70$:	MOVB	FAFRST,R0	; GET THE SAVED BYTE			;035
	BEQ	FTN2FA		; IF A NULL THEN WE DON'T DO ANYTHING
	CMPB	R0,#'$		; CHECK FOR '$' CC
	BEQ	FTN2FA		; IF A '$' THEN WE DON'T DO ANYTHING
	CALL	PUTCON,R1,<CRTERM,1>; ELSE OUTPUT A CR AT END OF RECORD

FTN2FA::CALL	GETREC		; GET AN RMS FORMAT RECORD
	BCC	10$		;  AND DO THE CONVERSION IF NOT EOF
	MOVB	FAFRST,R0	; GET THE CC BYTE FOR THE LAST RECORD	;035
	BEQ	80$		;  NO CR APPENDED SO SKIP LF APPEND
	CMPB	R0,#'$		; IS THIS A '$' CC CHARACTER
	BEQ	80$		;  YES, THIS DOESN'T REQUIRE THE LF APPENDED
	CALL	PUTCON,R1,<LFTERM,1>; NORMAL CC FOR LAST REC REQUIRES LF
80$:	RETURN

90$:	CALL	WARNF,R5,UNXEOF	; TELL OF AN UNEXPECTED EOF		;056
	RETURN			;  AND END THE TRANSLATION

	TMPORG	DATA
FFTERM:	.BYTE	12,14		; LF/FF
LFTERM:	.BYTE	12,15		; LF/CR
	UNORG

.DSABL	LSB

.SBTTL	PRN (PRINT FORMAT) FILE TO FORMATTED ASCII

.ENABL	LSB

10$:	CMP	R1,#2		; ARE THERE ENOUGH BYTES IN THE RECORD?
	BGE	20$		; YES, CONTINUE
	WARNF	<PRN control record under 2 bytes>			;056
	SUB	R1,R3		; ADJUST THE BUFFER SIZE
	ADD	R1,R2		;  AND THE BUFFER POINTER
	BR	PRN2FA		;   AND CONTINUE WITH THE SEARCH

20$:	CALL	GETBYT		; GET A BYTE FOR PREFIX
	BCS	50$		; PUNT IF AN ERROR
	CALL	PRNCTL		; CALL THE PRINT CONTROL ROUTINE
	CALL	GETBYT		; GET A BYTE FOR POST FIX
	BCS	50$		; PUNT IF AN ERROR
	MOVB	R0,F2LAST	; STORE IT AWAY				;078
	SUB	#2,R1		; SUBTRACT THE VFC RECORD
	BEQ	30$		; IF THERE IS NO MORE IN BUFFER, DO THE CC
	CALL	CPYIMR		; COPY THE REST OF THE RECORD OUT
30$:	MOVB	F2LAST,R0	; GET THE POSTFIX CONTROL		;078
	CALL	PRNCTL		;  AND OUTPUT THE PROPER CARRIAGE CONTROL
PRN2FA::CALL	GETREC		; GET AN RMS RECORD
	BCC	10$		; IF NO END OF FILE - CONTINUE
	CMPB	FALAST,#CR	; IS IT A CARRIAGE RETURN?
	BNE	40$		; NO, JUST RETURN
	CALL	PUTCON,R1,<LFTERM,1>; YES, SO MAKE SURE THERE IS A LINE FEED
40$:	RETURN			;  ELSE RETURN

50$:	CALL	WARNF,R5,UNXEOF	; TELL OF THE UNEXPECTED EOF		;056
	RETURN			;  AND RETURN

.DSABL	LSB

.SBTTL	OUTPUT THE PROPER PRN CARRIAGE CONTROL

.ENABL	LSB

PRNCTL::MOV	R1,-(SP)	; SAVE R1
	MOVB	R0,R1		; GET A COPY OF THE CONTROL BYTE	;078
	BEQ	20$		;  IF IT IS ZERO LEAVE
	BMI	40$		; SPECIAL CASE
10$:	CALL	PUTCON,R1,<LFTERM,1>; PUT AN LF OUT
	SOB	R1,10$		; LOOP FOR  THE PROPER NUMBER OF LF'S
	MOVB	LFTERM,FALAST	; REMEMBER THE LAST CHARACTER OUTPUT
20$:	MOV	(SP)+,R1	; RESTORE OLD R1
30$:	RETURN			; RETURN TO USER

40$:	BIT	R1,#40		; IS THIS ILLEGAL?
	BNE	20$		; YES, JUST IGNORE IT
	BIC	#^C<37>,R1	; ISOLATE THE LOWER FIVE BITS		;078
	BIT	R0,#100		; IS THIS A CONTROL CHAR WITH HIGH BIT?
	BEQ	50$		; NO
	BIS	#200,R1		; YES
50$:	MOVB	R1,FALAST	; STORE THE BYTE IN MEMORY
	CALL	PUTCON,R1,<FALAST,1> ; OUTPUT IT
	BR	20$		;  AND RETURN RESTORING R1

.DSABL	LSB

.SBTTL	RMS INPUT TO FORMATTED BINARY OUTPUT

.ENABL	LSB

10$:	MOV	#FBLEN,R0	; POINT TO CONSTANT AREA FOR PREFIX
	MOV	R1,(R0)		; SET RECORD LENGTH
	BEQ	RMS2FB		; COMPLETELY SKIP NULL RECORDS
	ADD	#4,(R0)		; PLUS FOUR FOR 1,0,LEN,LEN
	MOV	(R0)+,(R0)	; MOVE LENGTH TO CHECKSUM
	SWAB	(R0)		; HIGH BYTE OF LENGTH TO CHECKSUM
	ADD	-2(R0),(R0)	; PLUS LOW BYTE OF LENGTH
	INC	(R0)		; PLUS 1 PLUS 0
	CALL	PUTCON,R1,<FBHDR,4> ; PUT THE FOUR BYTE HEADER
	CALL	CPYFBR		; COPY THE RECORD'S DATA PART
	NEG	CHKSUM		; FIGURE OUT THE CHECKSUM BYTE
	CALL	PUTCON,R1,<CHKSUM,1> ; PUT 1 BYTE OF CHECKSUM
	BIT	R4,#1		; EVEN BOUNDARY NOW?
	BEQ	RMS2FB		; IF SO, NO NEED TO EVEN IT OUT
	CALL	PUTCON,R1,<CRLF,1> ; PUT A NULL TO EVEN IT OUT
RMS2FB::CALL	GETREC		; GET A RECORD
	BCC	10$		; COPY IT IF NOT EOF
	RETURN

.DSABL	LSB

.SBTTL	RMS INPUT TO IMAGE OUTPUT

.ENABL	LSB

10$:	TST	R1		; ZERO LENGTH RECORD?
	BEQ	RMS2IM		; YES, SKIP THIS
	CALL	CPYIMR		; COPY IMAGE FORMAT RECORD
RMS2IM::CALL	GETREC		; GET A RECORD
	BCC	10$		; IF ANY, COPY IT
	RETURN

.DSABL	LSB

.SBTTL	FORMATTED WHATEVER INPUT TO RMS OUTPUT

.ENABL	LSB

FX2RMS::CALL	GETBYT		; GET A BYTE IN AN ATTEMPT TO CLASSIFY
	BCS	20$		; EOF, A NULL FILE
	MOVB	SWTTBL,R1	; GET OUTPUT /RMS:XXX VALUE
	BEQ	30$		; IF NONE, TRY TO MAKE A CLASSIFICATION
	SUB	#2,R1		; DECREMENT BY TWO
	BEQ	10$		; GO AHEAD IF ALL SET
	TST	-(R1)		; DECREMENT BY TWO MORE
10$:	JMP	@RMSJMP(R1)	; DO A KNOWN TYPE OF CONVERSION

20$:	RETURN

30$:	CMPB	R0,#1		; 1 INDICATES FORMATTED BINARY
	BLO	FX2RMS		; 0 MEANS SKIP MORE
	BHI	FA2RMS		; > 1 MEANS ASCII (AS A GUESS)
	;BR	FB2RMS		; 1 MEANS FORMATTED BINARY
FB2RMS::

	TMPORG	DATA
RMSJMP:	.WORD	FB2RMS,FA2RMS	; JUMP TABLE FOR F?2RMS
	UNORG

.DSABL	LSB

.SBTTL	FORMATTED BINARY INPUT TO RMS OUTPUT

.ENABL	LSB

FB2RMS::CLRB	OUTATR+F.RATT	; FORMATTED BINARY, INDICATE SO IN ATTRIBUTES
10$:	DECB	R0		; ENSURE THAT THE BYTE IS 1
	BNE	50$		; NO, WARN HIM
20$:	CALL	GETBYT		; GET A BYTE WHICH OUGHT TO BE 0
	BCS	70$		; UNEXPECTED EOF
	TSTB	R0		; IS IT RIGHT?
	BNE	50$		; NO, WARN AND SKIP
	CALL	GETBYT		; GET RECORD LENGTH LSB
	BCS	70$		; UNEXPECTED EOF
	MOV	R0,-(SP)	; SAVE IT
	CALL	GETBYT		; GET LENGTH MSB
	MOVB	R0,1(SP)	; STORE IT AS MSB
	MOV	(SP)+,R1	; RECORD LENGTH
	BCS	70$		; UNEXPECTED EOF
	INCB	R0		; START CHECKSUM AS MSB+1
	ADD	R1,R0		;  +LSB
	MOV	R0,CHKSUM	; SAVE IT FOR COMPUTING
	SUB	#4,R1		; REDUCE COUNT BY CONTROL LENGTH
	BLOS	40$		; IF NO DATA, WARN HIM AND SKIP TO NEXT RECORD
	CALL	RMSBOR		; START AN RMS RECORD
	CALL	CPYFBR		; COPY FORMATTED BINARY DATA PART
	CALL	RMSEOR		; CLOSE OUT THE RMS RECORD
	CALL	GETBYT		; GET THE CHECKSUM BYTE
	BCS	70$		; UNEXPECTED EOF
	ADD	CHKSUM,R0	; COMPUTE FINAL CHECKING SUM
	TSTB	R0		; ZERO AS IT OUGHT TO BE?
	BEQ	30$		; YES
	WARNF	<Checksum error>					;056
30$:	CALL	GETBYT		; SKIP TO NEXT RECORD
	BCS	80$		; EOF, SO WE ARE DONE
	TSTB	R0		; ZERO BYTE?
	BEQ	30$		; YUP, SKIP THAT
	BR	10$		; START ANOTHER RECORD

40$:	WARNF	<Invalid FB record length>				;056
	BR	60$

50$:	WARNF	<Invalid start of FB record>				;056
60$:	CALL	GETBYT		; SKIP TO A REAL 1
	BCS	80$		; EOF INSTEAD
	SOB	R0,60$		; IF NOT A 1, LOOP FOR A 1
	BR	20$		; GOT A GOOD START NOW

70$:	CALL	WARNF,R5,UNXEOF	; TELL THE USER OF UNEXPECTED EOF	;056
80$:	TSTB	OUTFQB+F$FLAG	; IS THE OUTPUT ANSI?
.ASSUME	ANSIMT	EQ	200
	BPL	90$		; NO
	CMP	R5,BLENG	; IS OUTPUT BUFFER THE SIZE OF IT?
	BEQ	90$		; YES, NO PADDING
	CALL	ANSPAD		; PAD THE BUFFER
90$:	RETURN			; WHAT ELSE IS THERE TO DO?

.DSABL	LSB

.SBTTL	FORMATTED ASCII INPUT TO RMS OUTPUT

.ENABL	LSB

FA2RMS::CMPB	-(R2),(R3)+	; FIX COUNT & POINTER FROM PRESCAN
10$:	TST	R3		; ANY DATA HERE?
	BEQ	30$		; I SEE NO DATA HERE
	CMPB	(R2),#'Z-100	; DO WE HAVE A CONTROL-Z AT BEGINNING?
	BEQ	40$		; YES, THAT IS EOF
20$:	TSTB	(R2)+		; SCAN FOR A NON-NULL
	BNE	60$		; GOT ONE
	SOB	R3,20$		; SKIP
30$:	CALL	READ		; GET SOME BYTES TO SCAN
	BCC	20$		; IF ANY BYTES HERE, SCAN THEM
40$:	TSTB	OUTFQB+F$FLAG	; IS THE OUTPUT ANSI?
.ASSUME	ANSIMT	EQ	200
	BPL	50$		; NO
	CMP	R5,BLENG	; IS OUTPUT BUFFER THE SIZE OF IT?
	BEQ	50$		; YES, NO PADDING
	CALL	ANSPAD		; PAD THE BUFFER
50$:	RETURN			; DONE AT EOF

60$:	DEC	R2		; POINT TO START OF RECORD
	MOV	R4,-(SP)	; GET SOME WORKING ROOM
70$:	MOV	R2,R1		; COPY START
	MOV	R3,R0		; COPY COUNT
80$:	MOVB	(R1)+,R4	; GET NEXT BYTE
	CMPB	R4,#FF		; VERTICAL FORMS EFFECTOR?
	BHI	90$		; NO
	CMPB	#LF,R4		; REALLY?
	BLOS	120$		; YES, AND C=0 IFF LINE FEED
90$:	CMPB	R4,#ESCAPE	; IS IT AN ESCAPE?
	BEQ	140$		; YES, THAT IS A LEGAL TERMINATOR
	CMPB	R4,#'Z-100	; IS THIS A CONTROL-Z?
	BNE	100$		; NOPE, CONTINUE OUR SEARCH
	DEC	R1		; YES, BACKUP SO WE DON'T INCLUDE CONTROL-Z
	BNE	140$		;   AND OUTPUT THE RECORD
	TST	(SP)+		; POP GARBAGE OFF OF THE STACK
	BR	40$		;   AND GO RETURN EOF

100$:	SOB	R0,80$		; KEEP LOOKING FOR VFE
110$:	MOV	R3,-(SP)	; DISCARD NULL COUNT, SAVE DATA LENGTH
	CALL	READ		; TRY TO READ MORE
	CMP	R3,(SP)+	; GOT ANY MORE?
	BHI	70$		; YES, RETRY THE SCAN
	WARNF	<Formatted ASCII record too long>			;056
	SEC			; FUDGE FLAG TO SAY NO <LF>

120$:	BCS	150$		; IF NO LINE FEED, SAVE FLAG
	SUB	#2,R1		; BACK UP EOR POINTER OVER CR/LF (WE HOPE)
	CMP	R1,R2		; BACK TOO FAR?
	BLO	130$		; YES, COULDN'T HAVE BEEN CR/LF
	CMPB	(R1),#CR	; CR BEFORE LF?
	BEQ	150$		; YES, SKIP IT (AND C=0 FOR POST-SKIP)
130$:	ADD	#2,R1		; GO FORWARD TO INCLUDE THE LINE FEED
140$:	SEC			; INDICATE NO FINAL SKIP OF 2 BYTES
150$:	ROR	FALAST		; SET FLAG IF WE NEED TO SKIP CR/LF
	MOV	(SP)+,R4	; RESTORE REGISTER
	SUB	R2,R1		; COMPUTE RECORD LENGTH IN INPUT BUFFER
	MOV	R1,RECLEN	; STORE THE RECORD LENGTH
	CALL	RMSBOS		; START OUTPUT RECORD
	TST	R1		; ANYTHING IN OUTPUT RECORD?
	BEQ	160$		; NO, SKIP THE CPYIMR
	CALL	CPYIMR		; COPY THE RECORD
160$:	TST	FALAST		; UNCOPIED CR/LF?
	BMI	170$		; NO
	ADD	#2,R2		; YES, SKIP OVER THEM
	SUB	#2,R3		;  AND UNCOUNT THEM
170$:	CALL	RMSEOR		; DONE WITH THIS RECORD
	BR	10$		; DO MORE

.DSABL	LSB

.SBTTL	START RMS OUTPUT RECORD

.ENABL	LSB

RMSBOR::MOV	R1,RECLEN	; SET RECORD LENGTH
RMSBOS::TSTB	OUTFQB+F$FLAG	; IS THIS AN ANSI OUTPUT TAPE?
.ASSUME	ANSIMT	EQ	200
	BMI	20$		; IF SO DO THE ANSI THING
	CMPB	#R.FIX,OUTATR+F.RTYP; IS THE INPUT ATTRIBUTE FIXED?
	BEQ	60$		; YES, CHECK BUFFER LENGTH,ETC. FOR DISK F FMT
	CALL	PUTCON,R1,<RECLEN,2> ; EMIT THE LENGTH FOR VARIABLE RECORD
	CMP	RECLEN,OUTATR+2	; LONGEST RECORD SO FAR?
	BLOS	10$		; NO
	MOV	RECLEN,OUTATR+2	; YES, REMEMBER THAT
10$:	RETURN

20$:	MOV	RECLEN,R1	; GET THE RECORD LENGTH
	CMPB	#R.FIX,OUTATR+F.RTYP ; ARE WE DOING FIXED LENGTH RECS?
	BEQ	60$		; YES, DO THE FIXED LENGTH ANSI THING	;045
	ADD	#4,R1		; ADD FOUR TO IT TO INCLUDE THE HEADER
	CMP	R1,R5		; IS THERE ENOUGH ROOM IN THE OUTPUT BUFFER
	BLOS	30$		; YES, GO DO IT
	CALL	ANSPAD		; NO, PAD THE BUFFER AND OUTPUT
30$:	CALL	ANSPFX		; OUTPUT THE PREFIX
	SUB	#4,R1		; SUBTRACT THE RECORD SIZE
	RETURN			; RETURN TO CALLER

40$:	CMP	R1,R5		; ENOUGH ROOM?
	BLOS	50$		; YES
	CALL	ANSPAD		; NO
50$:	RETURN			; RETURN

60$:	BITB	#FD.BLK,OUTATR+F.RATT ; CAN RECORDS SPAN BLOCKS?
	BEQ	90$		; YES, SO THIS IS EASY
	MOV	R0,-(SP)	; SAVE R0
	MOV	R5,R0		; GET THE NUMBER OF BYTES LEFT
	BIC	#^C<777>,R0	; MAKE IT THE NUMBER OF BYTES LEFT IN BLOCK
	BEQ	80$		; If block is full, then don't pad it	;060
	CMP	RECLEN,R0	; IS THERE ENOUGH ROOM IN THE BLOCK
	BLOS	80$		; YES, PROCEED
	SUB	R0,R5		; DECREMENT AMOUNT LEFT IN BUFFER
70$:	CLRB	(R4)+		; CLEAR A BYTE OF THE BUFFER
	SOB	R0,70$		; LOOP FOR THE NUMBER OF BYTES
80$:	MOV	(SP)+,R0	; RESTORE R0
90$:	RETURN			;  AND RETURN

.DSABL	LSB

.SBTTL	FINISH RMS OUTPUT RECORD

.ENABL	LSB

RMSEOR::TSTB	OUTFQB+F$FLAG	; IS THE OUTPUT ANSI
.ASSUME	ANSIMT	EQ	200
	BMI	30$		; YES, GO RETURN
	BIT	R4,#1		; OUTPUT POINTER IS ODD?
	BEQ	10$		; NO, IT'S EVEN
	CLRB	(R4)+		; YES, EMIT A NULL
	DEC	R5		;  AND COUNT IT
10$:	MOV	#OUTATR+14,R0	; POINT TO ATTRIBUTES TO FIX THEM
	MOV	R4,R1		; GET OUTPUT BUFFER POINTER
	SUB	OBFPTR,R1	; COMPUTE BYTE WITHIN BUFFER
	MOV	R1,(R0)		; SAVE THAT AS EOF BYTE NUMER
	BIC	#777,R1		; ROUND OUTPUT POINTER DOWN TO A BLOCK
	BIC	R1,(R0)		; MAKE EOF BYTE NUMBER LESS THAN A BLOCK
	SWAB	R1		; COMPUTE BLOCK NUMBER
	ROR	R1		;  WITHIN BUFFER
	INC	R1		; PLUS 1, SINCE FIRST BLOCK IS 1
	ADD	OBLKL,R1	; MAKE THAT LSB BLOCK WITHIN FILE
	MOV	R1,-(R0)	; SAVE LAST BLOCK NUMBER
	MOV	OBLKM,-(R0)	;  INCLUDING MSB
	ADC	(R0)		; MAKE IT TRUE
	MOV	R1,-(R0)	; THAT BLOCK IS THE HIGHEST BLOCK ALLOCATED
	TST	OUTATR+F.FFBY	; IS THE EOF BYTE ZERO?
	BNE	20$		; NO
	SUB	#1,(R0)		; YES, ONE LESS BLOCK IS ALLOCATED
20$:	MOV	OUTATR+F.EFBK,-(R0) ; MSB ALLOCATED = MSB WRITTEN
	SBC	(R0)		;  WITH CORRECTION
30$:	RETURN

.DSABL	LSB

.SBTTL	COPY DATA PORTION OF FORMATTED BINARY RECORD

.ENABL	LSB

CPYFBR::CALL	COPYPR		; GET CHUNK SIZE TO COPY
	MOV	R5,-(SP)	; SAVE A REGISTER
	CLR	R5		; FOR WORK
10$:	MOVB	(R2)+,R1	; GET A BYTE FROM INPUT
	MOVB	R1,(R4)+	; EMIT IT
	ADD	R1,R5		; COMPUTE CHECKSUM
	SOB	R0,10$		; DO MORE
	ADD	R5,CHKSUM	; MAINTAIN CHECKSUM IN MEMORY
	MOV	(SP)+,R5	; RESTORE REGISTER
	CALL	@(SP)+		; GET MORE OF RECORD
	BCS	CPYFBR		; IF MORE, CONTINUE
	RETURN

.DSABL	LSB

.SBTTL	COPY FORMATTED ASCII FILE JUNKING NULLS AND RUBOUTS

.ENABL	LSB

CPYASC::CALL	COPYPR		; COPY A PARTIAL RECORD
10$:	MOVB	(R2)+,R1	; GET THE NEXT BYTE
	BIC	#^C<377>,R1	; CLEAR SIGN EXTEND			;012+
	BEQ	30$		; SKIP THIS CHARACTER IF IT IS NULL	
	CMPB	#177,R1		; IS THIS A RUBOUT?			
	BEQ	30$		;  YES, SKIP IT				
	CMPB	#377,R1		; IS THIS A RUBOUT W/ SIGN BIT ON?	
	BEQ	30$		;  YES, SKIP IT				;012-
	MOVB	R1,(R4)+	; SAVE THIS CHARACTER
20$:	SOB	R0,10$		; KEEP COPYING IF MORE IN BUFFER
	CALL	@(SP)+		; GET MORE OF THE RECORD
	BCS	CPYASC		; IF MORE, CONTINUE
	RETURN			;  RETURN

30$:	INC	R5		; SKIP THIS CHARACTER
	BR	20$		;  AND CONTINUE

.DSABL	LSB

.SBTTL	COPY DATA PORTION OF IMAGE RECORD

.ENABL	LSB

CPYIMR::TST	R1		; ANY MORE TO DO?
	BEQ	20$		; NOPE, QUIT
	CALL	COPYPR		; GET CHUNK TO COPY
10$:	MOVB	(R2)+,(R4)+	; COPY IT
	SOB	R0,10$		;  ALL
	MOVB	-1(R2),FALAST	; SAVE A COPY OF THE LAST BYTE XFERED
	CALL	@(SP)+		; GET MORE OF RECORD
	BCS	CPYIMR		; IF MORE, CONTINUE
20$:	RETURN

	TMPORG	DATA
FAFRST::.WORD	0							;035
FALAST::.WORD	0
F2LAST::.WORD	0							;078
	UNORG

.DSABL	LSB

.SBTTL	COPY PARTIAL RECORD COROUTINE

.ENABL	LSB

10$:	CALL	60$		; GET SOME DATA
COPYPR::TST	R5		; OUTPUT BUFFER HAS ROOM?
	BNE	20$		; YES
	CALL	WRITE		; NO, MAKE ROOM
20$:	MOV	R3,R0		; COPY NUMBER OF INPUT BYTES LEFT
	BEQ	10$		; IF NONE, GET SOME
	CMP	R0,R1		; FEWER BYTES IN INPUT THAN IN RECORD?
	BLO	30$		; YES
	MOV	R1,R0		; NO, SHORTEN COUNT TO RECORD LENGTH
30$:	CMP	R0,R5		; FEWER BYTES TO COPY THAN IN OUTPUT BUFFER?
	BLO	40$		; YES
	MOV	R5,R0		; NO, SHORTEN COUNT TO OUTPUT SIZE
40$:	MOV	R0,CPYAMT	; SAVE AMOUNT TO BE COPIED
	MOV	R1,RECLEN	; SAVE TOTAL RECORD LENGTH
	CALL	@(SP)+		; CALL CALLER TO DO THE MOVE
	MOV	RECLEN,R1	; RESTORE TOTAL RECORD ELNGTH
	MOV	CPYAMT,-(SP)	; GET THE AMOUNT JUST DONE
	SUB	(SP),R5		; SHORTEN THE OUTPUT BUFFER AMOUNT LEFT
	BNE	50$		; IF NON-EMPTY, FINE
	CALL	WRITE		; EMPTY THE BUFFER, RESET POINTERS
50$:	SUB	(SP),R3		; TAKE AWAY FROM THE INPUT BUFFER COUNT
	SUB	(SP)+,R1	; SHORTEN THE RECORD
	BEQ	90$		; IF DONE, RETURN C=0
	TST	R3		; MORE IN RECORD, IS THE INPUT EMPTY?
	BNE	80$		; MORE IN INPUT, TOO, SO RETURN C=1
60$:	CALL	READ		; GET MORE INPUT DATA
	BCC	80$		; EOF IS UNHEALTHY, SINCE RECORD IS COMING
70$:	CALL	ERRORF,R5,UNXEOF; TELL USER OF UNEXPECTED EOF		;056
80$:	SEC			; INDICATE MORE TO DO
90$:	RETURN

.DSABL	LSB

	TMPORG	DATA
CPYAMT::.WORD	0		; AMOUNT TO COPY IN CALLER
RECLEN::.WORD	0		; TOTAL RECORD SIZE
	UNORG

.SBTTL	GET A SINGLE BYTE FROM THE INPUT STREAM

.ENABL	LSB

10$:	CALL	READ		; GET A BUFFER LOAD		       ;006
	BCS	20$		; IF EOF, RETURN SUCH
GETBYT::TST	R3		; INPUT BYTE COUNT = 0 ?	       ;006
	BEQ	10$		; YES,10$			       ;006

	CMPB	#3,INATR+F.RTYP ; Is this a VFC file?			;066
	BNE	15$		; No, don't do next test		;066
	MOV	INATR+14.,R0	; Get 8th attribute			;066
	SWAB	R0		; Isolate Fixed Control Field length	;066
	BIC	^C<377>,R0	; Clear unwanted high byte		;066
	ADD	#2,R0		; Find count fld + VFC fld length	;066
	CMP	R3,R0		; Are they both in the input buffer?	;066
	BLT	10$		; No, go get some more input		;066

15$:	DEC	R3		; NO, COUNT ONE LESS INPUT BYTE        ;006
	CLR	R0		; CLEAR FOR BISB
	BISB	(R2)+,R0	; GET THE BYTE
	;CLC			; C=0 FROM 'CLR' ABOVE
20$:	RETURN

.DSABL	LSB

.SBTTL	EMIT A CONSTANT TO THE OUTPUT STREAM

;+
; PUTCON - EMIT CONSTANT STRING TO OUTPUT
;
;	R4/R5 = OUTPUT POINTERS
;
;	CALL	PUTCON,R1,<STRING ADDRESS, STRING LENGTH>
;
;	R0 =  RANDOM
;-

PUTCON::MOV	R2,-(SP)	; MAKE ROOM
	MOV	R3,-(SP)	;  TO WORK
	MOV	(R1)+,R2	; GET DATA POINTER
	MOV	(R1)+,R3	; GET COUNT
	BR	20$		; ENTER LOOP

10$:	CALL	WRITE		; EMPTY THE BUFFER, RESET POINTERS
20$:	DEC	R5		; COUNT ONE LESS EMPTY BYTE IN OUTPUT
	BMI	10$		; IF NONE, WRITE AND TRY AGAIN
	MOVB	(R2)+,(R4)+	; EMIT A BYTE
	SOB	R3,20$		; DO IT AGAIN IF NEEDED
	MOV	(SP)+,R3	; RESTORE
	MOV	(SP)+,R2	;  REGISTERS
	RETURN	R1

.SBTTL	GET A RECORD FROM AN RMS INPUT FILE

;+
; GETRMS - GET A RECORD FROM AN RMS FILE
;
;	R2 -> INPUT BUFFER
;	R3 =  INPUT COUNT LEFT
;
;	CALL	GETRMS
;
;	R0 =  RANDOM
;	R1 =  RECORD LENGTH
;	R2 -> INPUT BUFFER (EVEN NOW)
;	R3 =  INPUT COUNT (EVEN)
;
;	C=1 IF EOF
;-

.ENABL	LSB

10$:	MOV	R3,R0		; GET COUNT REMAINING
	BIC	#^C<777>,R0	; COMPUTE BYTES LEFT IN THIS BLOCK
20$:	SUB	R0,R3		; SKIP THE BYTES REMAINING
	ADD	R0,R2		; ADVANCE OVER THEM
GETRMS::ASR	R3		; IF COUNT IS ODD,
	ADC	R2		;  THEN BUMP THE INPUT POINTER
	ASL	R3		; EVEN OUT THE COUNT, ROUNDING DOWN
	MOV	IBLKM,R0	; GET INPUT BLOCK NUMBER
	MOV	IBLKL,R1	;  OF NEXT BLOCK (AT END OF INPUT DATA)
	ASHC	#9.,R0		; COMPUTE NEXT BYTE WITHIN FILE
	SUB	R3,R1		; BACK OFF BY AMOUNT NOT PROCESSED YET
	SBC	R0		;  TO GIVE CURRENT BYTE WITHIN FILE
	CMP	R0,INATR+F.EFBK	; ARE WE UP TO THE END OF FILE POINT?
	BNE	30$		; MSB IS DIFFERENT
	CMP	R1,INATR+F.EFBK+2 ; CHECK OUT LSB
30$:	BHIS	90$		; AT OR BEYOND EOF, GO RETURN C=1
	CMPB	INATR+F.RTYP,#R.FIX ; FIXED LENGTH RECORDS?
	BNE	50$		; NO
	;CLC			; C=0 FROM 'CMPB'
	MOV	INATR+F.RSIZ,R1	; YES, FINDING THE RECORD LENGTH IS EASY
	BITB	#FD.BLK,INATR+F.RATT ; UNLESS RECS DON'T SPAN BLOCK BOUNDARIES
	BEQ	40$		; THEY DON'T, SO THIS IS EASY
	MOV	R3,R0		; GET BYTES REMAINING IN BUFFER
	BIC	#^C<777>,R0	; FIGURE NUMBER OF BYTES LEFT IN THIS BLOCK
	BEQ	40$		; NONE FORCES READ, BUT IT'S VALID
	CMP	R0,R1		; WILL A RECORD FIT?
	BLO	20$		; NO, ADVANCE TO START OF NEXT BLOCK
	;CLC			; C=0 SINCE 'BLO'='BCS'
40$:	RETURN

50$:	CALL	GETBYT		; VARIABLE LENGTH RECORDS, GET LENGTH
	BCS	80$		; EOF? THE ATTRIBUTE EOF POSITION LIED!
	DEC	R3		; COUNT ANOTHER (ODD BYTE MUST BE THERE)
	DEC	R2		; BACK UP TO GET A WORD
	MOV	(R2)+,R1	; WE HAVE THE RECORD LENGTH
	CMP	R1,#-1		; SKIP THE REST OF THIS BLOCK?
	BEQ	10$		; YUP, GO DO IT
	CMPB	INATR+F.RTYP,#R.VAR ; SIMPLE VARIABLE LENGTH?
	BEQ	60$		; YES, RETURN C=0
	CMP	R1,#2		; VFC, RECORD BETTER BE GREATER THAN 2 BYTES
	BLO	70$		; RMS STRIKES OUT
	;CLC			; C=0 FOR A WIN
60$:	RETURN			; DONE

70$:	WARNF	<VFC record under 2 bytes>				;056
	BR	GETRMS		; TRY TO RECOVER

80$:	CALL	WARNF,R5,UNXEOF	; TELL OF THE UNEXPECTED EOF		;056
90$:	SEC			; INDICATE EOF
	RETURN

.DSABL	LSB

.SBTTL	GET A RECORD FROM INPUT STREAM

;+
; GETREC - GET A RECORD FROM AN ANSI INPUT TAPE, OR RMS INPUT DISK FILE
;
;	R2 -> INPUT BUFFER
;	R3 =  INPUT BUFFER COUNT LEFT
;
;	CALL	GETREC
;
;	R0 =  RANDOM
;	R1 =  RECORD LENGTH
;	R2 -> INPUT BUFFER
;	R3 =  INPUT BUFFER COUNT
;-

GETREC::CMPB	INFQB+F$HIDX,#MTAHND; INPUT FROM MAGTAPE?
	BNE	GETRMS		; NO, DO A GET RMS
	TSTB	INFQB+F$FLAG	; IS THIS AN ANSI INPUT TAPE?
.ASSUME	ANSIMT	EQ	200
	BPL	GETRMS		; NO, DO A GET RMS
	BIT	#140000,IMCHRW	; IS THIS A NON-U FORMAT TAPE?
	BEQ	GETRMS		; NO, DO A GET RMS
	BR	GTANSI		; ELSE, GET AN ANSI INPUT RECORD

.SBTTL	GET A RECORD FROM AN ANSI INPUT FILE

;+
; GTANSI - GET A RECORD FROM AN ANSI INPUT FILE
;
;	R2 -> INPUT BUFFER
;	R3 =  INPUT COUNT LEFT
;
;	CALL	GTANSI
;
;	R0 =  RANDOM
;	R1 =  LENGTH OF RECORD
;	R2 -> RECORD IN BUFFER
;	R3 =  TOTAL COUNT OF BYTES LEFT IN BUFFER
;-

.ENABL	LSB

10$:	MOV	(SP)+,R5	; POP R5 BEFORE GIVING ERROR TEXT

20$:	WARNF	<RCW format error> ; GIVE BADLY FORMATTED RCW MESSAGE	;056

30$:	CLR	R3		; CLEAR REMAINING INPUT
35$:	CALL	READ		; READ IN SOME MORE			;042
	BCS	40$		; RETURN CARRY SET IF EOF
GTANSI::TST	R3		; ANY INPUT LEFT?
	BEQ	30$		; NOPE, GET SOME MORE
	TST	IMCHRW		; IS THE INPUT FIXED LENGTH OF VARIABLE
.ASSUME	MC$VAR	EQ	100000
	BMI	50$		; IT IS VARIABLE, GO DO A VARIABLE THING
	MOV	IMXREC,R1	; GET THE RECORD SIZE OF FIXED LENGTH RECORDS
	CMP	R3,R1		; ENOUGH DATA IN RECORD?
	BLO	35$		; NO, GET THE NEXT RECORD		;042
	;CLC			; CARRY CLEAR FROM ABOVE (BLO = BCS)
40$:	RETURN			; RETURN ALL SET UP

50$:	CMPB	(R2),#'^	; IS THE FIRST CHARACTER A PAD CHARACTER?
	BEQ	30$		; YES, THAT MEANS GET THE NEXT BUFFER
	CMP	R3,#4		; IS THERE ENOUGH ROOM FOR THE RCW?
	BLO	20$		; NO, GIVE AN ERROR MESSAGE AND JUNK BUFFER
	MOV	R5,-(SP)	; SAVE R5
	MOV	#4,R5		; GET AN ITERATION COUNT
	CLR	R1		; AND CLEAR THE RECORD LENGTH ACCUMULATOR
60$:	MOVB	(R2)+,R0	; GET A BYTE
	DEC	R3		; DOWN COUNT AMOUNT LEFT IN BUFFER
	BIC	#^C<177>,R0	; CLEAR ANY PARITY (AND SIGN EXTENSION)
	SUB	#'0,R0		; SUBTRACT THE ASCII VALUE FOR ZERO
	BLT	10$		;  AN ILLEGAL CHARACTER OCCURRED
	CMP	R0,#9.		; CHECK FOR LEGAL TOP VALUE
	BGT	10$		;  AN ILLEGAL CHARACTER OCCURRED
	MUL	#10.,R1		; MULTIPLY ACCUMULATOR BY TEN
	ADD	R0,R1		;  AND ADD IN NEW VALUE
	SOB	R5,60$		; LOOP
	SUB	#4,R1		; SUBTRACT THE LENGTH OF THE RCW
	BLT	10$		; RETURN AN ERROR IF LENGTH IS INVALID
	MOV	(SP)+,R5	; RESTORE R5
	CMP	R3,R1		; IS THERE ENOUGH ROOM IN BUFFER FOR THIS REC?
	BLO	20$		; NOPE, GIVE RCW FORMAT ERROR
	;CLC			; RETURN NO ERROR (C=0 DUE TO ABOVE, BLO=BCS)
	RETURN			;  AND RETURN

.DSABL	LSB

.SBTTL	RECORD TO RECORD

.ENABL	LSB

10$:	CALL	RMSBOR		; BEGIN RECORD
	TST	R1		; IS THERE DATA?
	BEQ	20$		; NO
	CALL	CPYIMR		; COPY THE RECORD
20$:	CALL	RMSEOR		; END THE RECORD
RC2RC::	CALL	GETREC		; GET A RECORD
	BCC	10$		; IF NO EOF CONTINUE
	TSTB	OUTFQB+F$FLAG	; IS THIS AN ANSI TAPE?
.ASSUME	ANSIMT	EQ	200
	BPL	80$		; NO
	.CALLR	ANSPAD		; NO, PAD THE OUTPUT AND RETURN

.SBTTL	PAD AN ANSI OUTPUT BUFFER

;+
; ANSPAD - PAD AN ANSI OUTPUT BUFFER WITH CIRCUMFLEXES
;
;	R4 -> NEXT BYTE IN OUTPUT BUFFER
;	R5 =  COUNT OF BYTES LEFT IN OUTPUT BUFFER
;
;	CALL	ANSPAD
;
;	OUTPUT BUFFER HAS BEEN OUTPUT TO MAGTAPE
;	AND ALL OUTPUT POINTERS HAVE BEEN RESET
;
;	R4 -> OUTPUT BUFFER
;	R5 =  NUMBER OF BYTES LEFT IN BUFFER
;
;-

ANSPAD::MOV	BLENG,-(SP)	; SAVE THE CURRENT BUFFER LENGTH
	TST	R5		; IS THERE ANY ROOM LEFT IN THE OUTPUT BUFFER
	BEQ	50$		; NO, JUST OUTPUT THIS BUFFER
	CMP	R5,BLENG	; IS THERE ANYTHING IN THE BUFFER?
	BEQ	70$		; NO, SO NO NEED TO DO ANY OUTPUT
	BIT	#MC$FIX,OMCHRW	; IS THIS FIXED LENGTH RECORDS?
	BEQ	40$		; NO, SO PAD NORMALLY
	MOV	R0,-(SP)	; SAVE R0
	MOV	BLENG,R0	; GET THE BUFFER LENGTH
	SUB	R5,R0		; GET NUMBER OF BYTES ACTUALLY IN BUFFER
	MOV	R0,BLENG	; TRUNCATE THE BUFFER LENGTH
	CMP	R0,#18.		; IS IT 18 BYTES OR MORE?
	BHIS	60$		; YES, WRITE OUT THE BUFFER
30$:	SUB	#18.,R0		;  NO, GET - NUMBER OF BYTES NEEDED FOR BLOCK
	MOV	#18.,BLENG	; MAKE THE BUFFER 18. BYTES LONG
	MOV	R0,R5		; COPY NUMBER OF BYTES TO PAD WITH
	MOV	(SP)+,R0	; RESTORE R0
	NEG	R5		; MAKE COUNT OF BYTES NEEDED POSITIVE
40$:	MOVB	#'^,(R4)+	; PAD WITH A CIRCUMFLEX
	SOB	R5,40$		;  UNTIL NO MORE BYTES ARE LEFT IN BUFFER
50$:	MOV	R0,-(SP)	; SAVE R0
60$:	CALL	WRITE		; WRITE THE BUFFER TO THE OUTPUT DEVICE
	MOV	(SP)+,R0	; RESTORE R0
70$:	MOV	(SP)+,BLENG	; AND THE BUFFER LENGTH
80$:	RETURN			;  AND RETURN TO THE CALLER

.DSABL	LSB

.SBTTL	INSERT AN ANSI D FORMAT RECORD CONTROL WORD (RCW) INTO OUTPUT BUFFER

;+
; ANSPFX - SET THE PREFIX HEADER FOR AN ANSI D FORMAT RECORD
;
;	R1 =  DATA TO WRITE IN DECIMAL FORMAT
;	R4 -> OUTPUT BUFFER
;	R5 =  NUMBER OF BYTES REMAINING IN OUTPUT BUFFER
;
;	CALL	ANSPFX
;
;	R4 -> OUTPUT BUFFER (UPDATED)
;	R5 =  NUMBER OF BYTES REMAINING IN OUTPUT BUFFER (UPDATED)
;
;-

ANSPFX::MOV	R1,-(SP)	; SAVE R1
	MOV	R0,-(SP)	; SAVE R0
	CALL	10$,R3,1000.	; OUTPUT THE 1000'S PLACE
	CALL	10$,R3,100.	; OUTPUT THE 100'S PLACE
	CALL	10$,R3,10.	; OUTPUT THE 10'S PLACE
	BIS	#60,R1		; THE REMAINDER IS THE 1'S PLACE
	MOVB	R1,(R4)+	; OUTPUT IT
	MOV	(SP)+,R0	; RESTORE R0
	MOV	(SP)+,R1	; RESTORE R1
	SUB	#4,R5		; SUBTRACT THE NUMBER OF BYTES SET INTO BUFFER
	RETURN			;   AND RETURN

10$:	CLR	R0		; CLEAR R0 FOR THE DIVIDE
	DIV	(R3)+,R0	; DIVIDE
	BIS	#60,R0		; MAKE THE QUOTIENT INTO DECIMAL
	MOVB	R0,(R4)+	; MOVE IT TO THE OUTPUT BUFFER
	RETURN	R3		;  AND RETURN

.SBTTL	COMMON INPUT SERVICE

;+
; READ - GET MORE DATA FROM INPUT FILE
;
;	R2 -> UNPROCESSED DATA TO BE PRESERVED (IGNORED IF R3=0)
;	R3 =  COUNT OF UNPROCESSED DATA
;
;	CALL	READ
;
;	R0 =  RANDOM
;	R2 -> UNPROCESSED (MOVED) DATA, OR START OF NEW DATA
;	R3 =  BYTE COUNT OF DATA IN BUFFER
;
;	C=1 IFF R3=0
;-

.ENABL	LSB

READ::	MOV	R1,-(SP)	; SAVE REGISTER
	ASR	EOFLAG		; ALREADY AT EOF?
	BCC	5$		; NO, CONTINUE				;036

	MOV	IBFPTR,R1	;   POINT TO THE INPUT BUFFER		;042
	MOV	R3,-(SP)	;   SAVE COUNT OF BYTES LEFT IN BUFFER	;042
	BEQ	3$		;   NONE IS EASY			;042
	ADD	#777,(SP)	;   ROUND UP TO NUMBER OF BLOCKS NOT TO READ;042
	BIC	#777,(SP)	;   GIVING NUMBER OF BYTES TO SHORTEN READS BY;042
	SUB	R3,(SP)		;   DISTANCE TO START OF BLOCK WITH INPUT PTR;042
	ADD	(SP),R1		;   COPY ONLY THE DATA, PRESERVE BLOCK OFFSET;042
2$:	MOVB	(R2)+,(R1)+	;   COPY INPUT DATA DOWN		;042
	SOB	R3,2$		;   ONLY AS MUCH AS IS LEFT		;042
3$:	TST	(SP)+		;   PUT STACK PTR BACK WHERE WE FOUND IT;042

	JMP	130$		; YES, GO EXIT				;036

5$:	CMPB	INAFQB+FQFLAG,#DTAHND ; DECTAPE INPUT?
	BNE	10$		; NO
	MOV	IBLKL,R0	; ARE WE
	BIS	IBLKM,R0	;  JUST STARTING?
	BEQ	10$		; YES, NO RESIDUAL BLOCK WAITING
	ADD	#1000,R3	; WE KEEP A BLOCK IN RESERVE
10$:	MOV	IBFPTR,R1	; POINT TO THE INPUT BUFFER
	MOV	R3,-(SP)	; SAVE COUNT OF BYTES LEFT IN BUFFER
	BEQ	30$		; NONE IS EASY
	ADD	#777,(SP)	; ROUND UP TO NUMBER OF BLOCKS NOT TO BE READ
	BIC	#777,(SP)	; GIVING NUMBER OF BYTES TO SHORTEN READS BY
	SUB	R3,(SP)		; DISTANCE TO START OF BLOCK WITH INPUT PTR
	ADD	(SP),R1		; COPY ONLY THE DATA, PRESERVE BLOCK OFFSET
20$:	MOVB	(R2)+,(R1)+	; COPY INPUT DATA DOWN
	SOB	R3,20$		; ONLY AS MUCH AS IS LEFT
30$:	MOV	IBFPTR,R2	; POINT TO START OF INPUT AGAIN
	MOV	R2,R3		; COPY SOB PTR
	ADD	(SP)+,R2	; FIX INPUT SCAN POINTER TO COPIED DATA
	SUB	R1,R3		; - ( [PLACE TO READ] - [START OF BUFFER] )
	ADD	IBFSIZ,R3	; NUMBER OF BYTES ABOVE COPIED DATA (LENGTH)
	BEQ	60$		; OOPS, NO ROOM IN BUFFER TO READ!

	CMPB	INAFQB+FQFLAG,#MTAHND ; MAGTAPE INPUT?
	BEQ	150$		; YES, DO SPECIAL MAGTAPE PROCESSING
40$:	CLC			; C=0 FOR ROR
	ROR	R3		; COMPUTE WORD COUNT FOR READ
	MOV	SYSPTR,R0	; GET R/W AREA POINTER
	MOV	IBLKM,RWMSBS(R0); SHOVE IN THE MSB OF BLOCK NUMBER
	.READW	IN,R1,R3,IBLKL	; READ INTO RESIDUAL BUFFER
50$:	BCC	70$		; NO ERROR (EXCEPT MAYBE MAGRLE)
	TSTB	ERRBYT		; RT DETECTED EOF?
	BNE	80$		; NO, CHECK FOR IGNORABLE DATERR
60$:	CLR	R0		; YES, ZERO BYTES ACTUALLY READ
	BR	90$		; MERGE

70$:	CHKERR	MAGRLE		; READ WAS OK, RECORD LENGTH ERROR?
	BNE	90$		; NO, SO READ REALLY OK
80$:	CALL	GOCHK,R5	; CHECK FOR RECOVERABLE ERROR
	 BR	BADINP		; NOPE, DIE
90$:	SWAB	R0		; COMPUTE INPUT BLOCK COUNT
	ADD	R0,IBLKL	; UPDATE NEXT BLOCK TO READ
	ADC	IBLKM		;  CARRYING ON
	SWAB	R0		; RECOVER WORD COUNT
	CMP	R0,R3		; DID WE GET A SHORTENED READ?
	BEQ	100$		; IF NOT, PROBABLY NOT AT EOF
	MOV	R0,R3		; IF SO, USE ACTUAL AMOUNT
	COM	EOFLAG		;  AND SET FLAG FOR NEXT TIME

100$:	ASL	R3		; BYTE COUNT READ
	TST	OUTATC		; DOES THE OUTPUT HAVE ATTRIBUTES?	;033
	BNE	109$		; YES, JUST CONTINUE			;033
	TST	INATRC		; DOES THE INPUT HAVE ATTRIBUTES?	;036
	BEQ	109$		; NO, JUST CONTINUE			;036
	CMPB	INATR+F.RTYP,#R.ASC ;IS THE INPUT FILE STREAM ASCII?	;033
	BNE	109$		; NO, NEVERMIND				;033
	MOV	INATR+F.EFBK,R0	; DOES THE INPUT HAVE			;033
	BIS	INATR+F.EFBK+2,R0 ; AN EOF ATTRIBUTE?			;033
	BEQ	109$		; NO, JUST CONTINUE			;033
	PUSH	R1		; SAVE R1				;033
	MOV	IBLKM,R0	; GET THE MSB OF INPUT BLOCKS READ	;033
	MOV	IBLKL,R1	; GET THE LSB OF INPUT BLOCKS READ	;033
	ASHC	#9.,R0		; CALCULATE THE NUMBER OF BYTES		;033
	CMP	R0,INATR+F.EFBK	; HAVE WE GONE OVER THE MSB BLOCK NUM	;033
	BNE	102$		; MAYBE, GO CHECK FOR SURE		;033
	CMP	R1,INATR+F.EFBK+2 ; HAVE WE GONE OVER THE LSB BLOCK NUM	;033
102$:	BLO	104$		; WE HAVEN'T GONE OVER YET, CONTINUE	;033
	SUB	INATR+F.EFBK+2,R1 ; SUBTRACT THE LSBs			;033
	SUB	R1,R3		; SUB THE DIFF FROM THE NUM OF BYTES READ ;033
	TST	EOFLAG		; IS THE EOF FLAG ALREADY SET?		;033
	BNE	104$		; YES, CONTINUE				;033
	COM	EOFLAG		; SET THE EOF FLAG FOR NEXT TIME	;033
104$:	POP	R1		; PUT R1 BACK				;033
109$:	SUB	R2,R1		; COMPUTE NUMBER OF BYTES COPIED EARLIER ;033
	ADD	R1,R3		; ADD IT TO GIVE NUMBER OF GOOD BYTES IN BUFF
	CMPB	INAFQB+FQFLAG,#DTAHND ; DECTAPE INPUT?
	BNE	130$		; NOPE, NO FINAL MAGIC
	MOV	R3,R1		; YES, IS THERE ANYTHING IN THE BUFFER?
	BEQ	130$		; NOPE, CAN'T MUNG NOTHING
	TST	EOFLAG		; AT EOF ON DECTAPE?
	BEQ	120$		; NOT FOR CERTAIN, RESERVE A BLOCK
	ADD	R2,R1		; POINT TO END OF BUFFER (LAST BLOCK ON DT)
	MOV	#256.,R0	; CHECK OUT THE LAST BLOCK
110$:	TST	-(R1)		; IS ANYTHING IN THE LAST BLOCK NON-ZERO?
	BNE	130$		; IF SO, DON'T TRASH IT
	SOB	R0,110$		; LOOK CAREFULLY
120$:	SUB	#1000,R3	; RESERVE A BLOCK IF NOT EOF, TRASH ONE IF EOF
130$:	MOV	(SP)+,R1	; RESTORE REGISTER
	TST	R3		; ANY DATA TO SPEAK OF?
	BNE	140$		; YES, RETURN C=0
	SEC			; NO, RETURN C=1
140$:	RETURN

BADINP::RSTSER	RDFAIL,<Read failure>,IN

.SBTTL	MAGTAPE INPUT MAGIC

150$:	MOV	SYSPTR,R0	; POINT TO THE READ/WRITE AREA
	MOV	<CHNMAP+<IN*2>>(R0),R0 ; GET THE POINTER TO RT CHAN BLK
	CLR	CH$FN1(R0)	; CLEAR THE FILE NAME (RT11 THINKS NFS)
	MOV	R1,-(SP)	; SAVE THE POINTER TO THE FIRST FREE BYTE
	MOV	INAFQB+FQBUFL,-(SP) ; IS THERE A BUFFER SIZE
	BEQ	160$		; NO, FIRST READ WILL GET ONE
	TSTB	INFQB+F$FLAG	; IS THIS AN ANSI MAGTAPE?
	BPL	170$		; NO, SO DO NORMAL PROCESSING
	BIT	#140000,IMCHRW	; IS THIS ANSI MAGTAPE IN "U" FORMAT?
	BEQ	170$		; YES, SO DO NORMAL MAGTAPE PROCESSING
160$:	CALL	MTRDER,R5	; READ IN THE BLOCK FROM MAGTAPE, R3=WHOLE BUF
	 BR	230$		; EOF ON THIS READ, CHECK IT OUT
	TST	(SP)		; WAS THERE A BLOCK SIZE?
	BNE	200$		; YES, NO NEED FOR BLOCKSIZE SETTING, ONE READ
	MOV	R0,INAFQB+FQBUFL; NO, REPLACE WITH AMOUNT READ AS BLOCKSIZE
	MOV	R0,(SP)		; REPLACE BUFFERSIZE ON STACK
	TST	INFQB+F$FLAG	; IS THIS AN ANSI MAGTAPE?
	BPL	170$		; NO, DO MULTIPLE READS
	BIT	#140000,IMCHRW	; IS THIS ANSI MAGTAPE SPECIAL CASE?
	BNE	200$		; YES, ONE BUFFER READ ONLY
170$:	CMP	R3,(SP)		; IS THERE ROOM FOR MORE IN BUFFER?
	BLO	200$		; NO, TERMINATE READ
	CALL	MTRDER,R5	; YES, READ MORE
	 BR	230$		; EOF ON THIS READ, CHECK IT OUT
	BR	170$		; READ OK, GO GET MORE

180$:	REGRES			; RESTORE ALL REGISTERS
190$:	CMP	(SP)+,(SP)+	; EOF WAS SEEN, POP STACK ITEMS
	BR	210$		;  THEN SET EOFLAG AND RETURN

200$:	TST	(SP)+		; POP THE BUFFER LENGTH
	CMP	R1,(SP)+	; DID WE GET ANYTHING?
	BNE	220$		; YES, ASSUME WE ARE NOT AT EOF
210$:	COM	EOFLAG		; NO, ASSUME WE ARE INDEED AT EOF
220$:	MOV	R1,R3		; COPY POINTER TO THE END OF BUFFER
	SUB	R2,R3		; SUBTRACT TO GET THE NUMBER OF BYTES READ
	BR	130$		;  AND RETURN TO THE CALLER

230$:	TSTB	INFQB+F$FLAG	; IS THIS AN ANSI TAPE?
	BPL	190$		; NO, IT IS DOS, POP STACK, SET EOF AND RETURN
	REGSAV			; SAVE ALL THE REGISTERS
	CALL	RLBLIN		; READ IN A LABEL
	ROL	-(SP)		; STACK THE CARRY
	MOVB	FIRQB,-(SP)	; STACK ANY ERROR CODE
	MAGTAPE	IN,BSP,1	; BACKSPACE 1 RECORD TO REPOSITION TAPE
	MOVB	(SP)+,FIRQB	; RETURN THE ERROR CODE
	ROR	(SP)+		; RESTORE ANY ERROR CARRY FLAG
	BCS	BADINP		; IF BAD INPUT, SAY SO
	CMP	(R0)+,#"EO	; LABEL MUST BE EOV FOR MULTI-VOLUME
	BNE	180$		;  AND IT IS NOT, SO REAL EOF (PRETEND)
	CMP	(R0)+,#"V1	; IT MIGHT BE
	BNE	180$		; BUT AS USUAL IT ISN'T
	REGRES			; RESTORE ALL REGISTERS
	CALL	NXTIN		; GET THE NEXT INPUT TAPE
	BCS	190$		; TREAT ANY ERROR AS EOF
	CMP	(SP)+,(SP)+	; POP GARBAGE FROM STACK
	BR	150$		;  AND RESTART PROCESS

.DSABL	LSB

.SBTTL	READ IN A SINGLE BLOCK FROM MAGTAPE INPUT STREAM

;+
; MTRDER - READ A BLOCK OFF OF MAGTAPE
;
;	R1 -> STARTING ADDRESS OF BUFFER
;	R3 =  AMOUNT OF DATA LEFT IN BUFFER
;
;	CALL	MTRDER,R5
;
;	R0 =  AMOUNT OF DATA JUST READ (IN BYTES)
;	R1 -> ADDRESS ABOVE DATA JUST READ
;	R3 =  AMOUNT LEFT IN BUFFER AFTER READ
;
;	FIRST  RETURN IS END-OF-FILE RETURN
;	SECOND RETURN IS NO ERROR RETURN
;-

MTRDER::ASR	R3		; DOING NON-FILE STRUCTURED, USE WORD COUNT
	.READW	IN,R1,R3,#0	; READ IN A SINGLE BLOCK FROM MAGTAPE
	ASL	R0		; TURN THE AMOUNT READ INTO A BYTE COUNT
	ASL	R3		; MAKE R3 BACK INTO A BYTE COUNT
	ADD	R0,R1		; BUMP THE BUFFER POINTER
	SUB	R0,R3		; SUBTRACT AMOUNT READ FROM AMOUNT LEFT
	TSTB	FIRQB		; WAS THERE AN ERROR?
	BEQ	10$		;  NO, NONE WHATSOEVER, JUST RETURN
	CHKERR	EOF		;  YES, WAS IT AN EOF ERROR?
	BEQ	20$		;   YES, DO THE FIRST RETURN
	CALL	GOCHK,R5	; IS THIS ERROR INSIGNIFICANT?
	 BR	BADINP		;  NO, REALLY GIVE ERROR
10$:	TST	(R5)+		;  YES, TAKE SECOND RETURN, NO ERROR
20$:	RETURN	R5		;     AND RETURN

.SBTTL	COMMON OUTPUT SERVICE

;+
; WRITE - PUT DATA TO THE OUTPUT FILE
;
;	R4 -> END OF DATA (FIRST BYTE NOT TO WRITE), > OBFPTR
;
;	CALL	WRITE
;
;	R0 =  RANDOM
;	R4 -> OUTPUT BUFFER
;	R5 =  OUTPUT BUFFER SIZE (BYTES)
;-

.ENABL	LSB

WRITE::	MOV	R4,R5		; COPY POINTER TO END OF DATA
	MOV	OBFPTR,R4	; POINT TO START OF OUTPUT BUFFER
	SUB	R4,R5		; COMPUTE LENGTH TO WRITE 
	CLC			; PREPARE FOR THE ROR			;009
	ROR	R5		; PUT INTO WORDS
	BEQ	10$		; NO WORDS IS EASY
	CMPB	OUTFQB+F$HIDX,#LPTHND ; LINE PRINTER OUTPUT?
	BEQ	20$		; YES, DO IT BLOCK BY BLOCK
	CMPB	OUTFQB+F$HIDX,#MTAHND ; MAGTAPE OUTPUT?
	BEQ	100$		; YES, BUFFER IT OUT IN BLENG BLOCK SIZES
	MOV	SYSPTR,R0	; GET R/W AREA POINTER
	MOV	OBLKM,RWMSBS(R0); SET MSB OF BLOCK TO WRITE
	.WRITW	OUT,R4,R5,OBLKL	; WRITE THE DATA WE HAVE
	CALL	GOCHKC,R5	; CHECK FOR ERROR AND IGNORABLE
	 BR	90$		; CAN'T IGNORE THIS ONE
	SWAB	R5		; MAKE INTO # OF BLOCKS
	ADD	R5,OBLKL	; UPDATE THE OUTPUT BLOCK NUMBER
	ADC	OBLKM		;  AS A LARGE FILE
10$:	MOV	OBFSIZ,R5	; RETURN BUFFER SIZE IN BYTES
	RETURN

.SBTTL	LINE PRINTER OUTPUT MAGIC

20$:	SWAB	R5		; CONVERT WORD COUNT TO BLOCKS
30$:	CLR	LPFLAG		; TURN OFF LP ERROR STATE
	MOV	SYSPTR,R0	; GET R/W AREA POINTER
	MOV	OBLKM,RWMSBS(R0); AND SET BLOCK TO WRITE
	.WRITW	OUT,R4,#256.,OBLKL ; OUTPUT A BLOCK TO THE PRINTER
	BCS	70$		; GO DO MAGIC IF ERROR
40$:	ADD	#1,OBLKL	; BUMP THE OUTPUT BLOCK NUMBER FOR CLEANLINESS
	ADC	OBLKM		;  AS A LARGE NUMBER
	ADD	#1000,R4	; UPDATE BUFFER POINTER
	SOB	R5,30$		; LOOP FOR ALL BLOCKS
	MOV	OBFPTR,R4	; RESET OUTPUT POINTER
	BR	10$		; SET COUNT AND RETURN

50$:	CHKERR	HNGDEV		; HUNG DEVICE?
	BNE	90$		; NOPE, DIE
	TST	R0		; DID WE TELL HIM YET?
	BNE	60$		; YES, WE HAVE ALREADY PRINTED THE MESSAGE
	MOV	#80$,R0		; FIRST TIME ERROR, TAKE OVER
	.SETCC			;  CTRL/C TRAP
	CALL	LMARGN		; FORCE MESSAGE TO LEFT OF TERMINAL
	PRINT <Line printer hung - put online to continue or type CTRL/C>,NOCR
	COM	LPFLAG		; DON'T DO THIS AGAIN
60$:	.TTYOUT	#7		; DING
	MOV	#10.,XRB	; SET A SLEEP TIMER
	.PRIV,	.SLEEP		; ZZZZZ

70$:	MOV	#4,@SYSPTR	; LINE PRINTER MODIFIER 4 => EMPTY BUFFERS
.ASSUME	SPCBLK	EQ	0	; ASSUME SPCBLK IN 1ST WORD OF R/W AREA
	.WRITW	OUT,#CRLF,#1,#-1; WRITE ONE NULL BYTE (-1 FLAGS 1 AS BYTES)
	MOV	LPFLAG,R0	; GET FLAG OF WHETHER WE HAVE TOLD HIM
	BCS	50$		; IF ERROR WRITING NULL, TELL HIM
	BEQ	40$		; IF NEVER GAVE MESSAGE, KEEP SILENT
	MOV	#CNTRLC,R0	; RESET
	.SETCC			;  CTRL/C INTERCEPT
	CALL	LMARGN		; BACK TO THE LEFT
	BR	40$		; DONE, DO ANOTHER BLOCK

80$:	ERROR	<Line printer output aborted>

90$:	RSTSER	WRFAIL,<Write failure>,OUT

.SBTTL	MAGTAPE OUTPUT MAGIC

100$:	MOV	SYSPTR,R0	; GET A POINTER TO THE READ/WRITE AREA
	MOV	<CHNMAP+<OUT*2>>(R0),R0 ; GET RT11 CHANNEL BLOCK
	CLR	CH$FN1(R0)	; CLEAR FILENAME, RT11 THINKS IT'S NFS
	ASL	R5		; TURN R5 BACK INTO A BYTE COUNT
	MOV	R1,-(SP)	; SAVE THE CONTENTS OF R1
	MOV	BLENG,R1	; GET THE BUFFER LENGTH FOR MT INTO R1
	MOV	R2,-(SP)	; SAVE R2
	MOV	R3,-(SP)	; SAVE R3
110$:	CMP	R5,R1		; ARE THERE ENOUGH BYTES TO WRITE?
	BGE	140$		; YES, GO WRITE THEM
	MOV	OBFPTR,R2	; GET A POINTER TO THE BEGINNING OF BUFFER
	MOV	OBFSIZ,R3	; GET A LENGTH FOR THE OUTPUT BUFFER

; R5 =  NUMBER OF BYTES LEFT IN BUFFER
; R4 ->	BEGINNING OF DATA
; R3 =  SIZE OF BUFFER
; R2 -> BEGINNING OF BUFFER

	MOV	R5,R0		; COPY THE NUMBER OF BYTES TO SHIFT DOWN
120$:	MOVB	(R4)+,(R2)+	; MOVE A WORD AT A TIME
	SOB	R0,120$		; LOOP UNTIL ALL DATA IS SHIFTED

; R5 = NUMBER OF BYTES LEFT IN BUFFER
; R4 -> NEVER NEVER LAND
; R3 = SIZE OF TOTAL BUFFER
; R2 ->PAST NEW END OF DATA

130$:	MOV	R2,R4		; MAKE R4 POINT PAST THE DATA ALREADY BUFFERED
	SUB	R5,R3		; SUBTRACT THE AMOUNT OF DATA LEFT IN BUFFER
	MOV	R3,R5		;  FROM TOTAL SIZE, RESET FREE BYTE COUNT (R5)
	BR	180$		; THEN EXIT ROUTINE

140$:	ASR	R1		; DIVIDE BYTE COUNT BY TWO, FOR A WORD COUNT
	MOV	SYSPTR,R0	; MAKE SURE R0 POINTS TO READ/WRITE AREA
	MOV	OBLKM,RWMSBS(R0); SET THE MSB OF THE BLOCK NUMBER TO WRITE
	.WRITW	OUT,R4,R1,OBLKL	; WRITE SOME DATA OUT TO THE TAPE
	ROR	-(SP)		; STACK THE CARRY
	ADD	#1,OBLKL	; INCREMENT THE BLOCK COUNT
	ADC	OBLKM		;  AND INCREMENT THE MSB IF WE MUST
	CHKERR	NOROOM		; IS THERE A NOROOM ERROR?
	BNE	150$		; NO, CHECK FOR REAL ERRORS
	TSTB	OUTFQB+F$FLAG	; IS THIS AN ANSI MAGTAPE?
.ASSUME	ANSIMT	EQ	200
	BPL	150$		;  NO, GO REPORT THE ERROR

	TST	(SP)+		; DUMP THE CARRY LEFT ON STACK
	CALL	NXTOUT		; GO GET NEXT OUTPUT VOLUME
	BCC	160$		; EVERYTHING IS FINE, CONTINUE WITH OUTPUT
	SETERR	NOROOM		; OTHERWISE, RESET THE ERROR CONDITION
	BR	90$		;  AND REPORT THE ERROR

150$:	ROL	(SP)+		; RESET THE CARRY BIT (ERROR FLAG)
	CALL	GOCHKC,R5	; CHECK FOR IGNORABLE ERRORS
	 BR	90$		; WHERE TO GO FOR A NON-IGNORABLE
160$:	ASL	R1		; MAKE THE WORD COUNT INTO A BYTE COUNT
	ADD	R1,R4		; BUMP THE OUTPUT BUFFER POINTER
	SUB	R1,R5		; SUBTRACT THE AMOUNT WRITTEN
	BNE	110$		; IF THERE IS MORE LEFT, DO SOMETHING
170$:	MOV	OBFPTR,R4	; GET A POINTER TO THE OUTPUT BUFFER
	MOV	OBFSIZ,R5	;  AND THE LENGTH OF THE OUTPUT BUFFER
180$:	MOV	(SP)+,R3	; RESTORE R3 TO ITS ORIGINAL CONTENTS
	MOV	(SP)+,R2	; RESTORE R2
	MOV	(SP)+,R1	;  AND R1
	RETURN			; THEN RETURN TO OUR CALLER

.DSABL	LSB

.SBTTL	CHECK FOR I/O ERROR AND /GO SWITCH

;+
; GOCHKC - CHECK FOR ERROR AND /GO
;
;	C=0 IF NO ERROR (GOCHKC ONLY)
;	FIRQB = ERROR CODE
;
;	CALL	GOCHK[C],R5
;	 FIRST RETURN IF NOT 'DATERR' OR NO '/GO'
;	SECOND RETURN IF RECOVERABLE ERROR (OR C=0 ON GOCHKC)
;-

.ENABL	LSB

GOCHKC::BCC	10$		; OK IF CARRY NOT SET
GOCHK::	BIT	#GOSWIT,SCNFLG	; ALLOWED TO IGNORE USER DATA ERRORS?
	BEQ	20$		; NO, TAKE ERROR RETURN
	CHKERR	MAGRLE		; MAGTAPE RECORD LENGTH ERROR?
	BEQ	10$		; YES, IGNORE IT
	CHKERR	DATERR		; USER DATA ERROR?
	BNE	20$		; NOPE, CAN'T IGNORE IT
10$:	TST	(R5)+		; SKIP TO NON-ERROR RETURN
20$:	RETURN	R5

.DSABL	LSB

.SBTTL	OPEN INPUT FILE FOR COPY

;+
; OPENIN - OPEN INPUT FILE
;
;	R2 =  SCNFLG
;	R4 -> INPUT SPEC
;
;	CALL	OPENIN
;
;	ALL REGISTERS RANDOM
;
;	C=1 IF ERROR ON LOOKUP
;-

.ENABL	LSB

OPENIN::MOV	SYSPTR,R1	; YES, POINT TO R/W AREA
	MOV	INFQB+FQPPN,(R1); SET IN THE PROPER PPN
.ASSUME	PPN	EQ	0	; NECESSARY CONDITION FOR ABOVE
	CLR	DTBSIZ		; NO EXTRA SPACE EATEN
	CMPB	INFQB+F$HIDX,#DTAHND ; DECTAPE INPUT TO OPEN?
	BNE	10$		; NOPE
	MOV	BUFFER,R0	; POINT TO BUFFER AREA
	ADD	#510.,R0	; POINT TO LAST WORD IN FIRST BLOCK
	MOV	R0,6(R1)	; USE OUR BUFFER FOR DECTAPE MAGIC
	MOV	#512.,DTBSIZ	; TELL CALLER NOT TO USE THE TOP BLOCK
10$:	CMPB	INFQB+F$HIDX,#MTAHND ; MAGTAPE INPUT TO OPEN?
	BNE	30$		; NOPE
	BIT	R2,#NORWND	; YES, SUPPRESS REWINDING?
	BEQ	20$		; NO, REWIND IF NECESSARY
	CMP	(R1)+,(R1)+	;  AT THE OPEN MODE WORD
.ASSUME	MODE	EQ	4	; MODE MUST BE AT OFFSET FOUR IN R/W AREA
	MOV	INFQB+FQMODE,(R1) ; SET UP THE PASSED MODE VALUE
	BIS	#100002,(R1)	; AND FORCE THE NOREWIND BIT ON
20$:	MOV	R4,R0		; COPY POINTER TO OPEN BLOCK STUFF
	TSTB	INFQB+F$FLAG	; IS THIS AN ANSI TAPE?
.ASSUME	ANSIMT	EQ	200	;
	BPL	30$		; IF NOT, LET RSTS DO IT DOS
	CALL	MTOPIN		; DO ALL MAGTAPE STUFF NFS (FOOLS!)
	BR	40$		;  AND MERGE

30$:	.LOOKUP	IN,R4		; LOOK UP THIS FILE
40$:	BCS	130$		; ERROR, RETURN C=1 TO CALLER
	INC	INFCTR		; COUNT ONE MORE OPEN INPUT FILE
	MOV	SP,INFLG	; SET FLAG SAYING INPUT FILE IS OPEN
	CLR	IBLKL		; START READING
	CLR	IBLKM		;  AT BLOCK 0
	CLR	INFLAG		; Clear out any old file flags		;073
	MOV	#FIRQB+FQFIL,R0	; POINT TO FIRQB FROM ACTUAL OPEN
	ASRB	(R0)		; UNDOUBLE CHANNEL NUMBER
	TSTB	INFQB+F$FLAG	; IS THIS AN ANSI MAGTAPE?
.ASSUME ANSIMT	EQ	200
	BMI	120$		;  YES, EVERYTHING SHOULD BE SET ALREADY
	MOV	#INAFQB+FQFIL,R1 ; POINT TO PLACE TO COPY ACTUAL INPUT FIRQB
	MOV	#FQBSIZ-FQFIL/2,R2 ; COUNT OF WORDS TO COPY
50$:	MOV	(R0)+,(R1)+	; COPY ACTUAL INPUT FIRQB
	SOB	R2,50$
	CLR	(R1)+		; SET INPUT RTS NAME TO 0
	CLR	2(R1)		; SET ATTRIBUTE WORD COUNT TO 0
	MOVB	FIRQB+FQFLAG,R2	; GET INPUT FILE DEVICE TYPE
	BNE	110$		; IF NOT DISK, CHECK FOR DECTAPE
	MOVB	#UU.FIL,FIRQB+FQFUN ; SET FUNCTION TO READ ATTRIBUTES	;073
	CLRB	FIRQB+FQSIZM	; FUNCTION IS return data only		;073
	CLR	FIRQB+FQCLUS	; No subfunction			;073
	CLR	FIRQB+36	; and no future sub-functions		;073
	.PRIV,	.UUO		; DO IT
	TSTB	FIRQB		; ERROR READING THEM?
	BNE	80$		; YES, ASSUME THERE WERE NONE
	MOVB	FIRQB+FQFUN,INFLAG ; Store the file flags for later	;073
	MOV	-(R0),(R1)+	; SET SECOND WORD OF INPUT FILE RTS NAME
	MOV	-(R0),-4(R1)	; SET FIRST  WORD OF INPUT FILE RTS NAME
60$:	TST	-(R0)		; BACK SCAN FOR A NON-0 ATTRIBUTE WORD
	BEQ	60$		; (WE GOTTA STOP SOMEWHERE)
	TST	(R0)+		; POINT PAST LAST ATTRIBUTE WORD
	MOV	#FIRQB+6,R2	; POINT TO FIRST ATTRIBUTE WORD
	SUB	R2,R0		; COMPUTE NUMBER OF ATTRIBUTE BYTES
	BLOS	80$		; IF NONE, DON'T COPY THEM
	ASR	R0		; COMPUTE NUMBER OF WORDS
	MOV	R0,(R1)+	; SAVE WORD COUNT
70$:	MOV	(R2)+,(R1)+	; COPY THE
	SOB	R0,70$		;  ATTRIBUTES
	CLR	(R1)		; ENSURE A TRAILING 0
80$:	BIT	#ACCESS,SC2FLG	; ARE WE TO ACCESS THIS FILE?
	BEQ	90$		; NO, SKIP THE UPDATE OF DATE
	.PRIV,	.DATE		; GET TODAYS DATE
	MOV	XRB,DATELA	;   AND UPDATE ACCESS DATE

90$:	MOV	#JFSYS,XRB	; GET READY TO REGAIN PRIVS
	.PRIV,	.SET		; REGAIN THEM (IF WE HAD 'EM)
	MOV	#FIRQB+13,R0	; GET ADDRESS OF WHERE TO PUT ACCTNG STUFF
	MOV	#TIMECR+2,R1	;  AND WHERE TO GET IT FROM
	MOV	#6,R5		;    AND OF COURSE, HOW MANY TO GET
100$:	MOVB	-(R1),-(R0)	; MOVE THEM BYTES
	SOB	R5,100$		;   UNTIL COMPLETED
	MOVB	INAFQB+FQFIL,-(R0) ; SET INPUT FILE CHANNEL
	MOVB	#UU.BCK,-(R0)	;      AND FINALLY WHAT TO DO
	.PRIV,	.UUO		; AND DO IT
	MOV	#JFSYS,XRB	; GET SET TO RID OURSELVES OF PRIVS
	.PRIV,	.CLEAR		;   ASK RSTS TO CLEAR THE BITS
	BR	120$		; FINISH UP WITH C=0

110$:	CMPB	R2,#DTAHND	; DECTAPE INPUT?
	BNE	120$		; NO, LEAVE SIZE ALONE
	MOV	INAFQB+FQSIZ,R0	; GET SIZE IN 255-WORD BLOCKS
	MUL	#255.,R0	; COMPUTE NUMBER OF WORDS IN FILE
	ASHC	#8.,R0		; SHIFT SIZE TO GET NUMBER OF 256-WORD BLOCKS
	MOV	R0,INAFQB+FQSIZ	; SET SIZE (ASSUMING LAST PARTIAL BLOCK 0'S)
120$:	CLC			; RETURN SUCCESSFUL LOOKUP
130$:	RETURN

.DSABL	LSB

	TMPORG	DATA
DTBSIZ::.BLKW			; ONE WORD FOR AMOUNT EATEN
	UNORG

.SBTTL	ENTER OUTPUT FILE

;+
; ENTER - OPEN OUTPUT FILE
;
;	CALL	ENTER
;
;	R0,R1,R3 = RANDOM
;-

.ENABL	LSB

ENTER::	BIT	#DDNFS,OUTFQB+F$DFLG ; IS THE OUTPUT NFS?
	BNE	70$		; YES, DON'T CHECK ANYTHING
10$:	TST	INFLG		; IS THERE AN INPUT FILE OPEN?
	BNE	20$		; YES, GO CHECK DEFAULTS ETC.
	TST	OUTFQB+F$FLG2	; IS THERE SOMETHING WILD?
.ASSUME	SCWILD	EQ	100000	;
	BPL	70$		; NO, GO DO THE RIGHT THING
ILLOUT::ERROR	<Illegal output filename> ; ERROR OUT

; FILL IN WILD CARDS IN OUTPUT NAME FROM INPUT NAME

20$:	BIT	#DDNFS,INAFQB+FQFLAG; IS THE INPUT NFS?
	BEQ	30$		; NO, DO ALL DEFAULTS FROM THE CURRENT FQNAM1
	MOV	#INAFQB+FQNAM1,R0 ; POINT TO THE INAFQB NAME
	CLR	(R0)+		; CLEAR IT
	CLR	(R0)+		;   2ND PART
	CLR	(R0)+		;     AND TYPE
30$:	MOV	#INAFQB+FQNAM1,R0 ; POINT TO ACTUAL INPUT FILE NAME
	MOV	R5,-(SP)	; SAVE R5 FOR LATER
	MOV	#FNBUFF,R5	; POINT TO BUFFER AREA FOR WILD CARDING
	CALLX	RAD$FN		; CONVERT RAD50 TO ASCII FILE NAME.EXT
	MOV	#OUTFQB+FQNAM1,R0 ; GET POINTER TO OUTPUT SPEC FILE NAME
	CALLX	RAD$FN		; AND CONVERT IT
	MOV	#10.,R0		; GET LOOP CONTROL REGISTER
40$:	CMPB	-(R5),#'?	; IS THIS A '?' WILD CARD?
	BNE	50$		; NO, SKIP THE MOVE
	MOVB	-12(R5),(R5)	; SET IN NEW CHARACTER
50$:	SOB	R0,40$		; THIS IS THE LOOP CONTROL
	MOV	#OUTSPC+2,R3	; GET POINTER TO OUTPUT SPEC
	CALLX	ASCR50		; CONVERT FIRST 3 CHARACTERS
	MOV	R0,(R3)+	;  AND SET FINAL RAD50 SPEC
	CALLX	ASCR50		; DO IT FOR THE NEXT 3
	MOV	R0,(R3)+	;  AND SET THEM
	INC	R5		; BUMP PAST '.'
	CALLX	ASCR50		; AND THEN CONVERT TYPE
	MOV	R0,(R3)		; SET NEW TYPE
	MOV	(SP)+,R5	; RESTORE R5

; SEE IF THIS TYPE IS A RUNNABLE ONE

	MOV	#RTSLST,R1	; POINT TO LIST OF INSTALLED RTS'S
60$:	CMP	R0,(R1)+	; DOES THIS TYPE MATCH?
	BEQ	70$		; YES, WE FOUND IT
	CMP	(R1)+,(R1)+	; ADVANCE POINTER
	TST	(R1)		; ANY MORE?
	BNE	60$		; YES
	CLR	R1		; NO, FLAG NONE
70$:	CLR	OBLKL		; BEGIN THIS FILE AT THE BEGINNING
	CLR	OBLKM		;  OF ITS LONG LENGTH
	CLR	OUTPRO		; NO OUTPUT PROTECTION CODE
	BIT	#RTS,SCNFLG	; HAS THE USER SELECTED AN RTS?
	BNE	80$		; YES, DON'T CLEAR IT.
	CLR	OUTRTS		; ASSUME NO OUTPUT RTS NAME
80$:	CLR	LPFLAG		; NO LINE PRINTER HUNG STATE
	CLR	INFCTR		; RESET COUNT OF FILES OPENED SINCE ENTER
	MOV	SYSPTR,R3	; POINT TO THE R/W AREA
	MOV	OUTFQB+FQPPN,R0	; GET THE PPN FROM THE CSI
	TST	INFLG		; IS THERE AN INPUT FILE OPEN?
	BEQ	110$		; NO, NO WILD CARD PPN'ING
	CMPB	#255.,R0	; IS PROGRAMMER NUMBER WILD?
	BNE	90$		; NO, GO CHECK PROJECT NUMBER
	CLRB	R0		; GET SET FOR A BISB
	BISB	INAFQB+FQPPN,R0	; SET THE PROGRAMMER NUMBER SPEC
90$:	SWAB	R0		; GET PROJECT NUMBER INTO LOWER BYTE
	CMPB	#255.,R0	; DO THE SAME WILD TEST
	BNE	100$		; NOT WILD, CHECK FOR NOT THERE
	CLRB	R0		; GET SET FOR A BISB
	BISB	INAFQB+FQPPN+1,R0 ; SET THE PROJECT NUMBER SPEC
100$:	SWAB	R0		; ADJUST THE PPN SPEC BACK TO NORMAL
110$:	TST	R0		; CHECK PPN, IF ZERO => NO SPEC
	BNE	120$		; THERE IS A PPN, USE IT
	MOV	OURPPN,R0	; NO PPN, USE OUR OWN
120$:	MOV	R0,SAVPPN	; AND SAVE THE PPN FOR LATER PRINTING
	BIT	#UPDATE!NOOVER,SCNFLG ; UPDATE MODE COPY?
	BEQ	200$		; NO, DO A REGULAR DESTRUCTIVE ENTER
	TSTB	OUTFQB+F$HIDX	; IS THE OUTPUT A DISK?
.ASSUME	DSKHND	EQ	0
	BNE	200$		; NO, OPEN FOR INPUT IS NOT VALID

; /UPDATE OR /PROTECT OR /APPEND - LOOKUP FOR EXISTING OUTPUT FILE
;    (For /PR, Do lookup by LOKFQ, so access date is not changed)

130$:	MOV	R0,(R3)		; FORCE USE OF CREATION PPN
.ASSUME	PPN	EQ	0	; PPN MUST BE AT OFFSET ZERO OF R/W AREA

	BIT	#NOOVER,SCNFLG	; Was /PROTECT requested ?
	BEQ	160$		; No: rejoin at OPEN-for-input

	MOV	#OUTSPC,R0	; Point .SETFQB to output file spec
	MOV	R5,-(SP)	; Save R5
	MOV	R3,R5		; R5 <-- USRPTR
	.SETFQB			; Set up FIRQB from output file spec
	MOV	(SP)+,R5	; Restore R5
	MOVB	#LOKFQ,FIRQB+FQFUN ; Set LOOKUP function
	MOV	#-1,FIRQB+FQFIL	; Indicate wildcard lookup
	.PRIV, CALFIP		; See if requested O/P file already exists
	TSTB	FIRQB		; Error on lookup ?
	BNE	150$		; Yes: file does not already exist
	BIT	#PRCOLQ,SC2FLG	; Doing /PR:Q?				;001+
	BEQ	140$		; No, sorry				
	CALL	CHKPRQ		; Ask them to confirm it		
	BCC	150$		; OK to replace it (CHKPRQ faked NOSUCH)
140$:	JMP	320$		; No:  file exists, deliver error 	;001-
150$:	MOV	SAVPPN,R0	; Restore the saved PPN for printing	;005
	MOV	R0,(R3)		; Put file's PPN back in R/W area
.ASSUME	PPN	EQ	0
	BR	180$		; Rejoin at check-for-error

160$:	.LOOKUP	OUT,#OUTSPC	; ATTEMPT TO FIND THE OUTPUT AS INPUT
170$:	BCS	180$		; THERE WAS AN ERROR ON THE LOOKUP
	JMP	320$		; GOT IT, SO COPY INTO THE OLD ONE

180$:	CHKERR	NOSUCH		; ERROR, WAS IT CAN'T FIND FILE?
	BNE	190$		; NO, SOMETHING ELSE
	BIT	#APPEND,SCNFLG	; ARE WE TRYING TO APPEND?
	BEQ	200$		;  No, so error looking up
	JSR	PC,ERCNT1	;  Yes, log the fact, say continuing
	BR	200$		;  And continue
190$:	RSTSER	ENFAIL,<Enter failure>,OUT

; PREPARE FOR .ENTER

200$:	CLR	UPDENT		; WE DID NOT DO AN UPDATE MODE ENTER
	TST	INFLG		; INPUT FILE?
	BEQ	270$		; NO, NO CHARACTERISTICS TO COPY
	TSTB	OUTFQB+F$HIDX	; OUTPUT TO DISK?
.ASSUME	DSKHND	EQ	0
	BNE	270$		; NOPE, NO MAGIC

; DISK TO DISK - PRESERVE OR CHOOSE RTS NAME

	BIT	#RTS,SCNFLG	; HAS THE USER ALREADY SUPPLIED AN RTS NAME?
	BNE	220$		; YES, SKIP THE RTS NAME CHOOSE
	MOV	#INRTS,R0	; POINT TO INPUT RTS NAME
	TSTB	INAFQB+FQFLAG	; INPUT FROM DISK?
.ASSUME	DSKHND	EQ	0
	BEQ	210$		; YES, COPY RTS NAME
	MOV	R1,R0		; NO, POINT TO RTS NAME FROM TYPE
	BEQ	220$		; NONE, DON'T RENAME
210$:	MOV	(R0)+,OUTRTS	; SET UP RTS NAME
	MOV	(R0)+,OUTRTS+2	;  FOR LATER RENAME

; Set Up Output File Protection Code

;    If user typed an explicit code, we use it literally

220$:	MOV	OUTFQB+FQPROT-1,-(SP) ; Get the output <prot>
	BIT	#S$PROT,OUTFQB+F$SFLG ; Was it explicitly typed ?
	BNE	SETOPP		; Yes: that's it, then. (go set O/P <prot>)

;    For what follows, get into R0:
;		<prot> <377>	-if input file was on disk
;		  <0> <0>	-otherwise

	MOV	INAFQB+FQPROT-1,R0 ; Get input file's <prot>
	BISB	#377,R0		; [Set "code is real" flag]
.ASSUME	DSKHND	EQ	0
	TSTB	INAFQB+FQFLAG	; If input is from disk,
	BEQ	230$		;    "code is real" flag stays set
	CLR	R0		; else (non-disk): flag (and <prot>) = 0
230$:

;    Without an explicitly-typed output <prot>, the "user-assigned" <prot>
;    is next in priority

	MOV	DEFPRO(R3),(SP)	; Look at user-assigned <prot>
	BNE	STRNBL		; There was one (go check "runnable" bit)

;    Without either an explicitly-typed output <prot> or
;    a user-assigned <prot>, let's try for the <prot> of the input file
;    (if it was from disk)

	MOV	R0,(SP)		; [Get input's <prot>]

;    Assign "runnable" <prot> bit (<64.> bit) as appropriate
RUNABL	=	64.*400    ; (high byte is <prot>; low byte is the flag
;    Cases:
;	(SP) = a user-assigned <prot>
;		R0 <> 0  -input was from disk:  set <64.> bit from R0
;		R0 = 0   -input not from disk:  set <64.> bit from type
;	(SP) = input file's <prot>
;		R0 <> 0  -input was from disk:  set <64.> bit from R0
;		R0 = 0   -input not from disk:  set <64.> bit from type
;	(SP) = 0  (user-assigned <0>)
;		R0 <> 0  -input was from disk:  set <64.> bit from R0
;		R0 = 0   -input not from disk:  set <64.> bit from type
;	(SP) = 0  (no <prot> information available
;		R0 = 0   -input not from disk:  set <64.> bit from type
;			  (the rest of <prot> will be zero: system default
;			  <prot> code will be used)

STRNBL:	BIC	#RUNABL,(SP)	; [Clear <64.> bit]
	TSTB	R0		; Can we look at a <prot> from disk input?
	BNE	240$		; Yes (go check R0)
	TST	R1		; No: was type runnable, then ?
	BEQ	SETOPP		; Not runnable (use (SP) as it stands)
	BIS	#RUNABL,(SP)	; Runnable: set <64.> bit
	BR	SETOPP		; (Go set <prot>)

240$:	    ; Use <64.> bit from disk-input file's <prot>
	BIC	#^C<RUNABL>,R0	; Mask off all but input file's <64.> bit
	BIS	R0,(SP)		; Set that bit in <prot>

;    "Runnable" <prot> bit (<64.> bit) now set appropriately in (SP)
;    Other than the <64.> bit, we have cases:
;	(SP) <> 0  "Real" flag = 377	-using input file's <prot>;
;					<prot> in (SP) will be forced literally
;	(SP) <> 0  "Real" flag = 0	-there was a user default;
;					it is in (SP), but the flag is not
;					needed, as the system's default will
;					include it
;	(SP) = 0   "Real" flag = 377	-using input file's <prot> of <0>;
;					<prot> in (SP) will be forced literally
;	(SP) = 0   "Real" flag = 0	-no <prot> information available;
;					system's default will be used

;	    The <64.> bit controls whether the ENTER will do a CRBFQ or not.

SETOPP:	MOV	(SP),PROTEC(R3)	; Set output <prot> code
	MOV	(SP)+,OUTPRO	; Save indication of output <prot> code
; PRESERVE INPUT CLUSTERSIZE
 
250$:	BIT	#SC$CLU,OUTFQB+F$FLG2 ; EXPLICIT OUTPUT CLUSTERSIZE?
	BNE	260$		; YES, NO FUNNIES
	MOVB	INAFQB+FQFLAG,R0 ; INPUT FROM DISK?
	BNE	260$		; NO, NO CLUSTERSIZE TO PRESERVE
	;CLR	R0		; CLEAR FOR BISB
	BISB	INAFQB+FQPROT-1,R0 ; GET INPUT FILE CLUSTER SIZE
	DECB	R0		; CHANGE 0 TO 255 (0 MEANS 256)
	INC	R0		; CHANGE 0 TO 256, OTHERS UNCHANGED
	NEG	R0		; MAKE CLUSTERSIZE A LITTLE MORE FAILSAFE
	MOV	R0,CLUSTR(R3)	; SET CLUSTERSIZE FOR ENTER

; PRESERVE INPUT CONTIGUOUS BIT

260$:	TST	MERGER		; IS THIS A MERGE OPERATION
	BNE	270$		; YES, DON'T PRESERVE CONTIGUOUS BIT OR SIZE
	BIT	#SC$SIZ!SC$MOD,OUTFQB+F$FLG2 ; ANY SWITCHES?
	BNE	270$		; YES, DON'T PRESERVE CNTG BIT
	MOVB	INAFQB+FQSIZM,R0; GET A FILE SIZE (HIGH BYTE)
	BIS	INAFQB+FQSIZ,R0	;  AND BIT SET IN THE LOW WORD
	BEQ	270$		; DON'T GO FOR CONTIGUOUS IF NO SIZE
	BIT	#US.NOX,INUST	; IS THE INPUT CONTIGUOUS?
	BEQ	270$		; NO, DON'T SET CONTIGUOUS BIT
	MOV	#100100,MODE(R3); SET CONDITIONAL CONTIGUOUS BITS

; SET PROPER PPN FOR OUTPUT FILE AND ENTER IT

270$:	MOV	SAVPPN,(R3)	; AND FINALLY RESET PPN SPEC
.ASSUME	PPN	EQ	0	; PPN MUST BE AT OFFSET ZERO IN R/W AREA
	TSTB	OUTFQB+F$FLAG	; IS THE OUTPUT TAPE ANSI?
.ASSUME	ANSIMT	EQ	200	;
	BPL	280$		;  NO, LET RSTS DO IT DOS
	CALL	MTENTR		;  YES, DO IT NFS (FOOLS!)
	BR	300$		; MERGE TO COMMON CODE

280$:	MOVB	INAFQB+FQSIZM,CRMSBS(R3)
	BIT	#SC$SIZ,OUTFQB+F$FLG2 ; WAS THERE AN OUTPUT SIZE SPECIFIED?
	BEQ	290$		; NOPE, STAY WITH THIS ONE
	MOV	OUTFQB+FQSIZ,INAFQB+FQSIZ ; SET THE DESIRED OUTPUT SIZE
	MOVB	OUTFQB+FQSIZM,CRMSBS(R3) ;  AND THE MSB OF THE OUTPUT SIZE
	BR	295$		; IGNORE NEXT TEST			;071

290$:	TSTB	OUTFQB+F$HIDX	; IS THIS A DISK FILE?			;071
.ASSUME	DSKHND	EQ	0						;071
	BEQ	295$		; YES, USE FILE SIZE WE HAVE		;071
	CLR	INAFQB+FQSIZ	; NO, CLEAR OUT THE FILE SIZE		;071
295$:	BISB	#200,CRMSBS(R3)	; Set PIP's special "size is real" flag	;071
	.ENTER	OUT,#OUTSPC,INAFQB+FQSIZ
300$:	BCS	350$		; THERE WAS AN ERROR: EXIT WITH C=1
	TSTB	OUTFQB+F$HIDX	; IS THIS A DISK FILE?
.ASSUME	DSKHND	EQ	0
	BNE	330$		; NO, MERGE TO THE COMMON CODE
	TST	CP2SEF		; Are we copying to the same account	;041
	BEQ	305$		; No, skip this stuff			;041
	MOV	FIRQB+FQCLUS,R0	; Pick up the File ID			;041
	ASH	#-4,R0		; Shift out the flag bits		;041
	BIC	#^C<7777>,R0	; Isolate the 12 remaining bits		;041
	MOV	R0,R1		; Copy it				;041
	ASH	#-3,R0		; Compute the byte offset into table	;041
	BIC	#^C<7>,R1	; Get the bit within the byte desired	;041
	BISB	BITBYT(R1),BITMSK(R0) ;This File ID was just created	;041
305$:	BIT	#100,FIRQB+FQMODE; WAS IT A CONDITIONAL CONTG CREATE	;041
	BEQ	330$		;   NO, CONTINUE
	CALL	FQBSCR		; SAVE THE FIRQB
	MOV	#FIRQB+FQFUN,R0	; GET A POINTER TO THE FIRQB @ FQFUN
	MOVB	#UU.FIL,(R0)+	; SET THE FUNCTION
	ASRB	(R0)+		; UNDOUBLE THE CHANNEL NUMBER
	CLRB	(R0)		; CLEAR THE FUNCTION CODE, JUST WANT CTG BIT
	CLR	FIRQB+34	; CLEAR THE EXTENDED ALLOCATION FLAGS	;016
	CLR	FIRQB+36	; CLEAR THE EXTENDED ALLOCATION FLAGS	;016
	.PRIV,	.UUO		; DO THE UTILITY CALL
	TSTB	FIRQB		; WAS THERE AN ERROR?
	BEQ	310$		; NO, CONTINUE
	JMP	190$		;  YES, REPORT THE ERROR

310$:	CMPB	-(R0),-(R0)	; DECREMENT FIRQB POINTER BACK TO FIRQB+3
.ASSUME	FQFIL-1	EQ	3
	MOVB	(R0),R1		; SAVE THE CONTIGUOUS INDICATOR
	CALL	@(SP)+		; RESTORE THE FIRQB
	BITB	#US.NOX,R1	; TEST FOR THE CONTIGUOUS BIT
	BNE	330$		; FILE IS CONTIGUOUS, NO NEED TO WARN
	CALL	LMARGN		; MAKE SURE WE SPEAK OUT
	PRINT	<%File >,NOCR	; PRINT AN OPENER
	MOV	R5,R1		; SAVE R5
	CALL	PRDVPP		; PRINT THE FILE NAME
	MOV	R1,R5		; RESTORE R5
	PRINT	< created non-contiguous>
	BR	330$		; MERGE TO FINAL CODE

.SBTTL	CLEAN UP AFTER .ENTER

320$:	BIT	#NOOVER,SCNFLG	; FOUND THE FILE. SUPPRESS OVERRIDE?
	BNE	340$		; YES, GIVE ERROR TO CALLER
	MOV	#-1,UPDENT	; NO, ENTER WAS UPDATE MODE (NO RENAME)
	MOV	R0,UPDSIZ	; REMEMBER SIZE OF OUTPUT FILE
	MOVB	FIRQB+FQSIZM,UPDSZM ; SET MSB OF FILE SIZE
	BIT	#APPEND,SCNFLG	; ARE WE APPENDING?
	BEQ	330$		; NO
	MOV	R0,OBLKL	; YES, WRITE FROM THE END ON
	MOVB	UPDSZM,OBLKM	; SET MSB OF FILE SIZE TO APPEND TO
	NEG	UPDENT		; SET FLAG FOR APPEND TYPE
330$:	MOVB	FIRQB+FQFIL,R0	; GET THE RSTS CHANNEL NUMBER
	ASR	R0		; * 1 FOR CLEANLINESS
	MOVB	R0,OUTFQB+F$CHAN ; SAVE IT IN THE FIRQB
	MOV	#377,OUTFLG	; INDICATE OPEN OUTPUT FILE IN LOW BYTE
	;CLC			; C=0 FOR NO OVERRIDE ERROR
	RETURN

340$:	.CLOSE	OUT		; CLOSE THE FILE WE SHOULDN'T OVERRIDE
	SETERR	FIEXST		; SET THE 'FILE EXISTS' CODE
	SEC			; C=1 FOR OVERRIDE ERROR
350$:	RETURN

; ASK IF WE CAN REPLACE THE FILE					;001+

CHKPRQ:	MOV	R0,-(SP)	; PRESERVE R0				
	MOV	R5,-(SP)	; ALSO R5				
	CALL	LMARGN		; PRINT IF CCPOS(0)			
	.PRINT	#PQREAL		; "Really replace "			
	CALL	PRDVPP		; PRINT DEVICE, PPN, AND FILENAME	
	.PRINT	#QMARK		; " ? "					
	CALL	GETANS		; GET YES OR NO				
	BNE	360$		; Z=0 MEANS NOT OK, RETURN WITH C=1	
	SETERR	NOSUCH		; OK; PRETEND WE FOUND NO FILE		
	TST	(PC)+		; C=0 FOR REPLACE IT			
360$:	SEC			; C=1 FOR DON'T TOUCH IT		
	MOV	(SP)+,R5	; RESTORE R5				
	MOV	(SP)+,R0	;  ALSO R0 (CARRY PRESERVED)		
	RETURN			; C=0 FOR OK TO REPLACE			;001-

.DSABL	LSB

.SBTTL	ERROR PRINT SUBROUTINE - PRINT ERROR MESSAGE AND CONTINUE

.ENABL	LSB

ERCONT::MOV	PTRIN,R0	; GET POINTER TO INPUT SPEC
	MOV	INFQB+FQPPN,@SYSPTR; SET THE PROPER PPN
.ASSUME	PPN	EQ	0	;
	MOV	FIRQB,-(SP)	; SAVE ERROR CODE
	.SETFQB			; SET UP THE FIRQB ACCORDINGLY
	MOV	(SP)+,FIRQB	; RESTORE ERROR CODE
ERCNT1::MOV	#10$,-(SP)	; WHEN DONE, SAY WE ARE CONTINUING
ERRFQB::CALL	LMARGN		; NEW LINE IF NEEDED
	CALL	CVDVPP		; CONVERT THE DEV:[P,PN]FILNAM.EXT
	MOVB	FIRQB,R0	; GET THE ERROR CODE
	.ERRPRT			; PRINT THE ERROR
	PRINT	< - file >,NOCR
	.PRINT	#FNBUFF
	RETURN			; DONE

ERCNT2::	   ; Flag an error occurring during directory lookup

	CALL	ERRFQB		; Display the RSTS error message
	CALL	LMARGN		; Return the carriage
	PRINT	<    (Attempting to read directory)>,NOCR  ; Give add'l info

10$:	.PRINT	#CONTXT		; PRINT 'CONTINUING'
	RETURN

.DSABL	LSB

.SBTTL	FIRQB IMAGE SETUP ROUTINE

;+
; SETFQB - SET UP THE FIRQB
;
;	R0 -> SPECIFICATION (FROM CSI) TO SET UP
;
;	CALL	SETFQB,R5,<PLACE TO COPY FIRQB>
;
;	R0 =  FLAG WORD FOR DEVICE FROM XRB+6
;	R1 -> INTERNAL FIRQB @ F$SFLG
;	R2 =  SCNFLG
;-

.ENABL	LSB

SETFQB::MOV	(R5)+,R1	; GET INTERNAL POINTER
	.SETFQB			; LET RT11 DO THE WORK
	MOV	#FQBSIZ/2,R2	; SIZE OF AREA TO COPY
	MOV	#FIRQB,R0	; "FROM" LOCATION
10$:	MOV	(R0)+,(R1)+	; COPY A WORD
	SOB	R2,10$
	CLR	F$FLAG-F$SFLG(R1); CLEAR THE FLAGS WORD
	MOV	XRB+6,R0	; GET THE DEVICE TYPE CODE
	MOV	XRB+10,(R1)	; SAVE .FSS FLAGS @ XRB+10
	MOV	XRB+12,F$FLG2-F$SFLG(R1) ; SAVE .FSS FLAGS @ XRB+12
	MOV	R0,F$DFLG-F$SFLG(R1) ; SAVE THE WHOLE THING
	MOVB	R0,F$HIDX-F$SFLG(R1) ; SAVE IT IN THE FIRQB
	BNE	20$		; IF NOT DISK, PROCESS FILE NAME NOW
	INC	F$FLAG-F$SFLG(R1); SAY THIS IS A DISK DEVICE
.ASSUME	DISKFL	EQ	1
20$:	BIT	#S$FIL,(R1)	; WAS THERE A FILE NAME?
	BNE	30$		; YES, GO CHECK TYPE
	BIS	#S$FILS,(R1)	; NO, THEN FILE NAME IS A STAR
	BIS	#SCWILD,F$FLG2-F$SFLG(R1);   AND SOMETHING IS WILD
30$:	BIT	#S$EXT,(R1)	; WAS THERE A TYPE?
	BNE	40$		; YES, READJUST POINTER AND LEAVE
	BIS	#S$EXTS,(R1)	; SET THE '*' TYPE BIT
	BIS	#SCWILD,F$FLG2-F$SFLG(R1);   AND SOMETHING IS WILD
40$:	MOV	SCNFLG,R2	; GET SCAN FLAG
	RETURN	R5		; AND RETURN

.DSABL	LSB

.SBTTL	CLOSE INPUT & OUTPUT

.ENABL	LSB

CLOSIO::TSTB	OUTFQB+F$HIDX	; IS THE OUTPUT DISK?
.ASSUME	DSKHND	EQ	0
	BNE	60$		;   NO, SKIP ALL SPECIAL CODE
	TSTB	INFQB+F$HIDX	; IS THE INPUT DISK?
.ASSUME	DSKHND	EQ	0
	TST	INFCTR		; IS THIS ANOTHER IN A SERIES OF INPUT?
	BNE	30$		;   YES, SO DON'T RESET EXCEPT THE FIRST TIME
	MOV	#JFSYS,XRB	; WE NEED PRIVS FOR WHAT'S COMIN' UP
	.PRIV,	.SET		;   ASK RSTS FOR THEM
	MOVB	#100!200,FIRQB+FQSIZM	; Start with Cache changes	;073
	BIT	#NEWFIL!APPEND!UPDATE,SCNFLG
				; Should standard RSTS/E dating apply?
	BNE	22$		;   YES, SO SKIP TIME/DATE RESET	;073
	BIT	#RETAIN,SC2FLG	; DOES USER WANT TO RETAIN
	BNE	10$		;   YES, SO DO THE RETAIN
	BR	22$		;   NO, SKIP OVER THE RETAIN		;073
..NEWF	==	.-2	;**PATCH** CHANGE UPPER BYTE TO BR/400 TO DEFAULT /NE	
	; **NOTE** that the contents of optional patches are referenced
	;	   at ONETIM: -- changes here mean changes there.
10$:	MOV	#FIRQB+FQDEV,R0	; GET ADDRESS WHERE WE PUT TIME/DATE	;073
	BISB	#4,FQSIZM-FQDEV(R0) ; Add the Change of dates 		;073
	MOV	#TIMECR+2,R1	;   AND WHERE WE GET THEM FROM
	MOV	#6,R5		;     AND HOW MANY WE CAN TAKE
20$:	MOVB	-(R1),-(R0)	; MOVE THOSE BYTES
	SOB	R5,20$		;   UNTIL WE CAN'T MOVE NO MORE
22$:	MOVB	INFLAG,R1	; Get the old flags			;073
	BIC	#^C<4!10!40!100!200>,R1	; clear the bits we don't want	;073
	MOV	R1,FIRQB+FQNAM2	; where we put the bits to change	;073
	MOV	#1!2!4!10!20,FIRQB+FQCLUS ; Tell it to change these too	;073
	CLR	FIRQB+36	; but not any future ones		;073
	MOV	#FIRQB+FQFIL,R0	; Point to the channel #		;073
	MOVB	OUTFQB+F$CHAN,(R0) ; GET OUTPUT FILE CHANNEL		;073
	MOVB	#UU.FIL,-(R0)	;       AND THEN WHAT .UUO SUBFUNCTION WE WANT
	.PRIV,	.UUO		;         FINALLY TELL RSTS WE WANT IT, NOW!
	MOV	#JFSYS,XRB	; GET SET TO DROP PRIVIES
	.PRIV,	.CLEAR		;   DROPPED
30$:	BIT	#NOATT,SC2FLG	; DOES THE USER NOT WANT ATTRIBUTES?
	BNE	50$		;   NO, SO SKIP THIS UUO
	MOV	#OUTATC,R1	; GET OUTPUT ATTRIBUTE AREA POINTER
	MOV	(R1)+,R2	;   GET COUNT OF ATTRIBUTES
	BEQ	50$		;     IF NONE, SKIP THIS CODE
	MOV	#FIRQB+FQFUN,R0	; GET POINTER TO FIRQB FOR LOADING ATTRIBUTES
	MOVB	#UU.ATR,(R0)+	;   SET ATTRIBUTE .UUO
	MOVB	OUTFQB+F$CHAN,(R0)+ ; AND THE CHANNEL NUMBER
	MOVB	R2,(R0)+	;       THE NUMBER OF ATTRIBUTES TO WRITE
40$:	MOV	(R1)+,(R0)+	; MOVE ALL ATTRIBUTES FROM ATTR AREA
	SOB	R2,40$		;   UNTIL WE MOVE 'EM ALL
	.PRIV,	.UUO		; NOW WRITE THE ATTRIBUTES
50$:	TSTB	OBLKM		; WAS THERE AN MSB ON THE FILE SIZE?
	BNE	60$		;   YES, DON'T TRY FOR AN RTS ON A LARGE FILE
	MOVB	OUTFQB+F$CHAN,R0 ; Get the channel number		;073
	CALL	RTSNAM		; and go change the RTS name		;073

60$:	.CLOSE	IN		; CLOSE THE INPUT
	BCS	80$		;  AND REPORT ANY ERROR ENCOUNTERED
	CLR	INFLG		; FLAG THE INPUT FILE AS CLOSED
	TST	OUTFQB+F$FLG2	; IS THERE MORE THAN ONE OUTPUT FILE
.ASSUME	SCWILD	EQ	100000	;
	BPL	70$		; NO, SO DON'T CLOSE OUTPUT FILE
	.BR	CLOSEO		;   YES, CLOSE THIS ONE

.SBTTL	CLOSE OUTPUT FILE

CLOSEO::CALL	MTCLOT		; CLOSE THE OUTPUT FILE
	CLR	OUTFLG		; NO MORE OUTPUT FILE OPEN
70$:	RETURN

80$:	RSTSER	CLFAIL,<Close failure>,IN

.DSABL	LSB

.SBTTL	CSI SCANNER ROUTINE

.ENABL	LSB

SCAN::	REGSCR			; PRESERVE ALL REGISTERS
10$:	MOV	#JFLOCK!JFSPRI!JFSYS!JFBIG,XRB ; DROP ANY SPECIAL OR PRIV
	.PRIV,	.CLEAR		; IN CASE WE HAVE THEM
	CLR	BLENG		; CLEAR THE BUFFER SIZE
	CLR	OUTFLG		; Indicate output file not open
	CLR	INFLG		; Indicate input file not open
	CLR	DENVAL		; CLEAR THE DENSITY VALUE
	MOV	#0,SC2FLG	;  AND THE SECOND FLAG WORD
..SCF2	==	.-4	;**PATCH** PATCH TO SET DEFAULT OPTIONS
	; **NOTE** that the contents of optional patches are referenced
	;	   at ONETIM: -- changes here mean changes there.
	CALL	GCML		; GET A COMMAND LINE
	CALL	CVT$$B		; TRIM THE STRING			;012
	TSTB	(R5)		; Is trimmed string null?
	BNE	20$		; No-   leave it alone
	MOV	#"/V,(R5)	; Yes-  force a command
	MOV	#<"E?&177>,2(R5);  of ASCIZ "/VE"
20$:
	.PRIV,	.DATE		; GET THE CURRENT DATE
	MOV	#CURDAT,R0	; POINT TO DATE STUFF
	MOV	XRB,(R0)+	; SAVE DATE
	CLR	(R0)+		; LOW MATCH DATE IS BEGINNING OF TIME
	MOV	#-1,(R0)+	; HIGH MATCH DATE IS END OF THE UNIVERSE
	MOV	#1+9.+1,R1	; CLEAR DATE FLAG, SWITCH TABLE, MODE FLAGS
30$:	CLR	(R0)+
	SOB	R1,30$
	MOV	#LOSIZL,R0	; POINT TO SELECT-BY-FILESIZE STUFF	;032
	CLR	(R0)+		; LOW FILESIZE LSB IS ZERO		;032
	CLR	(R0)+		; LOW FILESIZE MSB IS ZERO		;032
	MOV	#-1,(R0)+	; HIGH FILESIZE LSB IS INFINITE		;032
	MOV	#-1,(R0)+	; HIGH FILESIZE MSB IS INFINITE		;032
	MOV	#3,R1		; CLEAR FILESIZE-SWITCH FLAG, STORAGE	;032
35$:	CLR	(R0)+		; CLEAR IT				;032
	SOB	R1,35$		; NEXT					;032
	MOV	#SOMOUT,R4	; START BY ASSUMING THERE'S OUTPUT SIDE
	BIS	#000000,R4	; DEFAULT OPTIONS IN SCNFLG		;021
..SCNF	==	.-2	;**PATCH** PATCH TO SET DEFAULT OPTIONS
	; **NOTE** that the contents of optional patches are referenced
	;	   at ONETIM: -- changes here mean changes there.
40$:	CALLX	INSTR$,R4,<'/>	; LOOK FOR A SWITCH STARTER
	BEQ	70$		; NONE, PROCESS THE COMMAND AS IS
	INC	R5		; SKIP THE SLASH
	CMPB	(R5),#'A	; SWITCHES MUST BE ALPHABETIC
	BLO	130$		; ERROR IF NOT (INTERNAL SWITCHES PASS!)
	MOV	R5,R0		; COPY START OF SWITCH
	CALLX	GETUNQ,R0,LONGSW ; TRY FOR A LONG SWITCH
	BCC	40$		; NOT HERE, LOOK FOR MORE
	CALL	ENDSWT		; IS THE SWITCH END CHARACTER VALID?
	BNE	40$		; NO, NOT A VALID LONG SWITCH
	ASL	R1		; MAKE INDEX INTO A WORD OFFSET
	MOV	SHRTSW(R1),R1	; GET INDEX (OR SHORT SWITCH VALUE) IN R1
	BMI	50$		;   IF IT IS MINUS IT IS INDEED AN INDEX
	MOVB	R1,(R0)+	; IT IS A BYTE SO REPLACE SWITCH 
	MOV	R0,SWTPTR	; SAVE R0				;002
	BR	60$		;   AND EAT THE REST

50$:	NEG	R1		; MAKE IT POSITIVE (2-N)
	ADD	#SHRTGO-2,R1	; POINT INTO TABLE FOR ADDRESS & ARGUMENTS
	DEC	R0		; DECREMENT R0 TO EAT THE WHOLE SWITCH
	CLR	R2		; ENTER SWITCH ROUTINE WITH A CLEAR REGISTER
	MOV	R0,SWTPTR	; SAVE R0				;002
	;CLC			;  AND A CLEAR CARRY (C=0 FROM 'CLR')
	CALL	@(R1)+		; CALL THE SWITCH MAGIC
	MOV	SWTPTR,R0	; RESTORE R0, BUT HOLD IT		;002
	BCS	80$		; ERROR DETECTED
	CALL	ENDSWV		; MUST BE AT DELIMITER NOW
	BNE	80$		; IF NOT, INVALID SWITCH
60$:	MOVB	(R5)+,(R0)+	; SHORTEN THE STRING
	BNE	60$		;  UNTIL IT IS ALL COPIED DOWN
	MOV	SWTPTR,R5	; POINT TO AFTER SWITCH JUST FOUND	;002
	BR	40$		; LOOK FOR MORE TO SHORTEN

70$:	.CSISPC	#OUTSPC,#EXT,#DIRBUF ; SCAN US A STRING
	BCC	100$		; NO ERROR
80$:	SETERR	SASYNE		; PRESET SYNTAX ERROR
	DECB	ERRBYT		; IS IT THE ILLEGAL DEVICE ERROR?
	BNE	90$		; NO, THE SASYNE IS RIGHT
	SETERR	NODEVC		; SAY IT IS NOT A VALID DEVICE
90$:	CALLR	ERRCHK		;  AND NOW REPORT THE ERROR

100$:	MOV	(SP)+,R0	; ARE THERE ANY SWITCHES?
	BEQ	160$		; NO, SO THE STACK IS NOW OK
110$:	MOV	(SP),R2		; GET THE LETTER
	BIC	#^C<377>,R2	; CLEAR SIGN EXTEND OF CHARACTER	;012
	MOV	#SWTCHS,R1	; POINT TO TABLE OF SWITCHES
120$:	CMP	R2,(R1)+	; IS THIS THE SWITCH?
	BEQ	140$		; YES
	ADD	#5*2,R1		; NO, SKIP BITS TO TEST, SET, CALL
	TST	(R1)		; ANY MORE?
	BNE	120$		; YES, TRY AGAIN
130$:	CALL	ERROR,R5,SWTER	; ABORT WITH "?Switch error"

140$:	CALL	BISBIT		; SET BITS AND TEST FOR CONFLICT
	SWAB	(SP)		; GET THE FILE NUMBER IN THE LOW BYTE
	MOVB	(SP)+,R5	; GET THE INDEX
	ASLB	R5		; DOUBLE IT, C=1 IF VALUE
	BIC	#^C<17*2>,R5	; ISOLATE THE FILE NUMBER
	BCC	150$		; NO VALUE
	MOV	(SP)+,R3	; GET VALUE IN R3
150$:	CALL	@(R1)+		; CALL SWITCH PROCESSOR
	BCS	130$		; ERROR!
	SOB	R0,110$		; AND DO THEM ALL

.SBTTL	CHECK OUTPUT SPECIFICATIONS

160$:	MOV	#^RDK ,R1	; DEFAULT DEVICE IS DK (SYSTEM DEVICE)
	MOV	#OUTSPC,R0	; POINT TO THE OUTPUT SPEC
	.SETFQB			; SET UP THE FIRQB
	MOV	#OUTSPC+<3*2>,R0 ; POINT TO OUTPUT TYPE WORD
	MOV	XRB+10,R2	; GET SCAN FLAGS
	BIT	R2,#S$DEV	; IS THERE A DEVICE NAME (a ":")?
	BEQ	170$		; NO, SEE IF THERE IS ANY SPEC
	CLR	ODEVFL		; Clear device-was-specified flag word	;067
	BIT	R2,#S$DEVE	; Was a device name specified?		;067
	BEQ	165$		; No, don't set the flag		;067
	BIS	#1,ODEVFL	; Yes, set the flag so /RE can check it	;067
165$:	BIT	#DDNFS,XRB+6	; Yes there's a ":", is the device NFS?	;067
	BEQ	180$		; FS OUTPUT, ADD STARS IF NEEDED
	INC	(R0)		; NFS OUTPUT. UNSPECIFIED TYPE?
	BEQ	220$		; YUP, RESET IT TO 0
	DEC	(R0)		; NO, FIX IT
	BR	220$		; DON'T MUCK THE NAME

170$:	BIT	R2,#S$FIL!S$EXT!S$PPN ; FILENAME, TYPE, OR PPN PARSED?
	BNE	180$		; YES, FILL IN A FULL SPEC
	MOV	#^RTT,R1	; NO OUTPUT HERE. DEFAULT OUTPUT IS TT:
	BIC	#SOMOUT,R4	;  AND FLAG THE LACK OF AN OUTPUT FILE
180$:	BIT	R2,#S$EXT	; DID HE TYPE A TYPE?
	BNE	190$		; HE TYPED ONE
	MOV	#RADSTR,(R0)	; NO, GIVE HIM AN ASTERISK
190$:	MOV	-(R0),-(SP)	; IS THERE A NON-NULL
	BIS	-(R0),(SP)+	;  FILE NAME?
	BNE	200$		; YUP, USE IT
	MOV	#RADSTR,(R0)	; NO, SUPPLY A STAR
	MOV	(R0),2(R0)	;  IN BOTH WORDS
200$:	TST	-(R0)		; IS THERE A DEVICE NAME?
	BNE	210$		; YES, DONE
	MOV	R1,(R0)		; NO, USE THE DEFAULT
210$:	BIT	R4,#SOMOUT	; IS THERE OUTPUT?
	BEQ	230$		; NOPE, DON'T DO ERRORING
220$:	BIT	R4,#DELETE!ZERO	; WERE WE DELETING OR ZEROING?
	BNE	340$		; YES, SO ANY OUTPUT IS EXCESSIVE
230$:	TST	OUTSPC+<5*2>	; CHECK SECOND OUTPUT SPEC
	BNE	240$		; SOMETHING THERE???
	TST	OUTSPC+<5*2*2>	; THE THIRD ONE PERHAPS
	BEQ	250$		; NO, OUTPUT SIDE IS FINE
240$:	WARN	<Extra output specs ignored> ; WARN THE USER ABOUT OUTPUT

.SBTTL	CHECK INPUT SPECIFICATIONS

250$:	MOV	#002001,R3	; SHIFT INTO C AFTER 6 TIMES, GET MASK=1
	MOV	#INSPC,R1	; BEGIN AT THE INPUT SIDE
	MOV	#SWTTBL+<3*2>,R5 ; POINT TO SWITCH FLAGS FOR INPUT
	CLR	R2		; CLEAR MASK OF INPUT FILES
	MOV	#^RDK ,-(SP)	; DEFAULT DEVICE IS SYSTEM STRUCTURE
260$:	MOV	R1,R0		; POINT TO THE SPEC
	.SETFQB			; GET ITS VALUES
	MOV	R1,R0		; COPY THE POINTER
	TST	(R0)+		; GOT A SPEC?
	BNE	270$		; YES
	MOV	XRB+10,-(SP)	; GET THE .FSS FLAGS
	BIC	#^C<S$PPN!S$EXT>,(SP) ; ISOLATE TYPE & PPN FLAGS
	BIS	(R5),(SP)+	; TYPE, PPN, OR SWITCHES HERE?
	BEQ	290$		; NO, THIS SPEC IS EMPTY
	MOV	(SP),(R1)	; YES, DEFAULT THE DEVICE IF PPN GIVEN
270$:	MOV	(R1),(SP)	; SET DEFAULT DEVICE FROM EXISTING SPEC
	BISB	R3,R2		; SET FLAG BIT FOR THIS SPEC
	BIT	R4,#ZERO	; ARE WE ZEROING?
	BNE	290$		; YES, DON'T TOUCH THE NAME
	TST	(R0)		; IS THERE A FILE NAME?
	BNE	280$		; YES, LEAVE IT
	MOV	#RADSTR,(R0)	; NO, SET IT TO WILD CARDS
	MOV	(R0),2(R0)	; (BOTH WORDS)
280$:	CMP	(R0)+,(R0)+	; BUMP TO TYPE
	BIT	#S$EXT,XRB+10	; IS THERE A TYPE?
	BNE	290$		; HE TYPED SOMETHING (MAYBE EXPLICIT NULL)
	MOV	#RADSTR,(R0)	; NO DOT FOUND, SET TYPE '*'
290$:	TST	(R5)+		; POINT TO NEXT SWITCH FLAG WORD
	ADD	#<4*2>,R1	; POINT TO NEXT INPUT SPEC
	ASL	R3		; SHIFT MASK BIT, CHECK FOR DONE
	BCC	260$		; NOT YET
	TST	(SP)+		; DUMP DEFAULT DEVICE
	BIT	R4,#ZERO	; ARE WE ZEROING?
	BEQ	300$		; NO
	CALLR	DOZERO		; YES, DO IT

300$:	TST	R2		; NO, ARE THERE ANY INPUT SPECS?
	BNE	330$		; YES, WE CAN ACTUALLY DO SOMETHING!
	TSTB	R4		; NO INPUT FILES. WANTS DIRECTORY?
.ASSUME	DIRECT	EQ	200
	BMI	320$		; YUP, CHANGE TO *.*
	BIT	#SOMOUT!DELETE!RENAME,R4 ; WAS THERE ANYTHING TO DO?
	BNE	310$		; YES, TELL HIM SO
	JMP	10$		; NO, JUST IGNORE THE LINE

310$:	ERROR	<No input file>

320$:	MOV	#INSPC,R0	; SET DIRECTORY OF *.*
	MOV	#^RDK ,(R0)+	; ON SY:
	MOV	#RADSTR,(R0)	; SET ALL STARS
	MOV	(R0)+,(R0)
	MOV	(R0)+,(R0)
330$:	MOV	R4,SCNFLG	; SAVE THE SCAN FLAG
	RETURN

	TMPORG	DATA
EXT:	.WORD	-1,-1		; FILE DEFAULT TYPES ARE -1
	.BLKW0	2		; NO OTHER DEFAULT OUTPUT TYPES
	UNORG

340$:	ERROR	<No output file with /Z or /DE>

.DSABL	LSB

.SBTTL	CHECK FOR VALID END-OF-SWITCH CHARACTER

.ENABL	LSB

;+
; ENDSWT, ENDSWV - CHECK FOR VALID CHARACTER AT END OF SWITCH
;
;	R5 -> CHARACTER
;
;	CALL	ENDSW?
;
;	Z=1 IF CHARACTER IS <,> </> <=> <NUL> [OR <:> IF ENDSWT]
;-

ENDSWT::CMPB	(R5),#':	; ENDS IN COLON (VALUE)?
	BEQ	10$		; YES
ENDSWV::CMPB	(R5),#',	; ENDS IN COMMA (NEXT FILE)?
	BEQ	10$		; YES
	CMPB	(R5),#'/	; ENDS IN SLASH (ANOTHER SWITCH)?
	BEQ	10$		; YES
	CMPB	(R5),#'=	; ENDS IN EQUALS (INPUT)?
	BEQ	10$		; YES, WE GOT ONE
	TSTB	(R5)		; SWITCH ENDS IN NULL?
10$:	RETURN			; RETURN CONDITION IN Z-BIT

.SBTTL	CHECK FOR SWITCH CONFLICT IN SWITCH OPTION WORDS

;+
; BICBIT - CLEAR AND TEST SWITCH FLAG BITS
;
;	R1 -> BITS TO CLEAR/BITS TO TEST
;	R4 =  FLAG WORD
;
;	CALL	BICBIT
;
;	R1 -> PAST BITS
;-

BICBIT::BIC	(R1)+,R4	; SET BIT TO GO ON
	BIC	(R1)+,SC2FLG	; SET BITS IN SECOND WORD ALSO
	BR	20$		; MERGE TO COMMON BIC(S)BIT CODE

;+
; BISBIT - SET AND TEST SWITCH FLAG BITS
;
;	R1 -> BITS TO SET/BITS TO TEST
;	R4 =  FLAG WORD
;
;	CALL	BISBIT
;
;	R1 -> PAST BITS
;-

BISBIT::BIS	(R1)+,R4	; SET BIT TO GO ON
	BIS	(R1)+,SC2FLG	; SET BITS IN SECOND WORD ALSO
20$:	BIT	R4,(R1)+	; ANY CONFLICTS?
	BNE	SWTCON		;  YES
	BIT	(R1)+,SC2FLG	; ANY CONFLICTS WITH SECOND WORD
	BEQ	10$		;  NO
SWTCON::ERROR	<Switch conflict>

.DSABL	LSB

.SBTTL	PARSE THE /BSIZE SWITCH

.ENABL	LSB

BSSWIT::CALL	GETNUM		; GET A NUMBER OFF OF THE SWITCH
	BIT	R1,#1		;  IS THE RECORDSIZE ODD?
	BNE	10$		;   YES, WHAT AN ODD THING TO DO
	CMP	R1,#18.		;  IS THE VALUE LESS THAN GOOD?
..BSLO	==	.-2	;**PATCH** TO CHANGE LOWEST ALLOWABLE BLOCKSIZE
	; **NOTE** that the contents of optional patches are referenced
	;	   at ONETIM: -- changes here mean changes there.
	BLT	10$		;   YES, REPORT THE ERROR
	CMP	R1,#8192.	;  IS THE VALUE MORE THAN GOOD?		;018
..BSHI	==	.-2	;**PATCH** TO CHANGE HIGHEST ALLOWABLE BLOCKSIZE
	; **NOTE** that the contents of optional patches are referenced
	;	   at ONETIM: -- changes here mean changes there.
	BGT	10$		;   YES, THIS IS AN ERROR TOO
	MOV	R1,BLENG	; RECORD THE BLOCK SIZE FOR POSTERITY
	CLC			; CLEAR ERROR CONDITION FLAG
	RETURN			;   AND EXIT THROUGH THE COROUTINE

10$:	ERROR	<Bad blocksize>

.DSABL	LSB

.SBTTL	PARSE THE /PARITY SWITCH

.ENABL	LSB

PARSWT::BIT	#PARITY,SC2FLG	; IS THERE ALREADY BEEN ONE?
	BNE	30$		; YES, ERROR AND DIE
	CALL	BISBIT		; SET BITS AND CHECK FOR CONFLICTS
	CMPB	(R5)+,#':	; DO WE HAVE AN ARGUMENT?
	BNE	20$		; NO, ERROR AND DIE
	CALLX	GETUNQ,R0,PAROPT; PARSE THE OPTION
	BCC	30$		; CAN'T IDENTIFY IT
	TST	R1		; IS THE INDEX 1?
	BEQ	10$		; NO, MUST BE ODD
	BIS	#PARODD,SC2FLG	; SET PARITY WAS ODD
10$:	CALL	ENDSWV		;  CHECK FOR END OF SWITCH
	BNE	30$		; WASN'T PROPER, ERROR!!!!
	;CLC			; INSURE NO ERROR RETURN
	RETURN			; ELSE RETURN TO THE CALLER

20$:	ERROR	<No parity spec>

30$:	ERROR	<Bad parity spec>

.DSABL	LSB

	TMPORG	PAROPT
	UNQTXT	<E\VEN>
	UNQTXT	<O\DD>
	.BYTE	0	; END OF TABLE
	UNORG

.SBTTL	PARSE THE /DENSITY SWITCH

.ENABL	LSB

DENSWT::CALL	BISBIT		; FIRST CHECK FOR CONFLICTS		;024
	CMPB	(R5)+,#':	; DOES THE SWITCH HAVE A PROPER TERMINATOR?024
	BNE	30$		;    NO, ERROR				;024
	TST	DENVAL		; IS THERE A DENSITY ALREADY?
	BNE	20$		;    YES, ERROR!
	MOV	R5,-(SP)	; SAVE THE PRESENT CHARACTER POSITION	;024
	CALLX	GETUNQ,R0,DENOPT ;PARSE THE OPTIONS, IF THERE		;024
	BCC	5$		; NOT MINIMUM OR MAXIMUM, TRY A NUMBER	;024
	INC	MINMAX		; FLAG THAT IT'S MINIMUM OR MAXIMUM	;024
	TST	(SP)+		; RESTORE THE STACK			;024
	TST	R1		; IS IT MAXIMUM?			;024
	BEQ	3$		;    NO, MUST BE MINIMUM		;024
	MOV	#32767.,R1	;    YES, MOVE IN THE VALUE FOR MAXIMUM	;024
	BR	10$		; GO STORE IT				;024

3$:	INC	R1		; SET THE VALUE FOR MINIMUM		;024
	BR	10$		; GO STORE IT				;024

5$:	MOV	(SP)+,R5	; RESTORE THE CHARACTER POSITION	;024
	CALLX	VAL		; PARSE THE NUMBER			;024
	BCS	20$		; ERROR IF BAD VALUE			;024
	MOV	(SP)+,R1	; GET THE VALUE				;024
	TST	R1		; DID THE USER SPECIFY ANYTHING?	;024
	BEQ	20$		;    NO, ERROR
10$:	BIT	#100000,R1	; IS DENSITY VALID?			;024
	BNE	20$		;    NO, ERROR				;024
	CALL	ENDSWV		; CHECK FOR END OF SWITCH		;024
	BNE	30$		; WASN'T PROPER, ERROR			;024
	MOV	R1,DENVAL	; RECORD THE DENSITY
	RETURN			;    AND RETURN

20$:	ERROR	<Bad density>

30$:	CALL	ERROR,R5,SWTER	; ABORT WITH "?Switch error"		;024

.DSABL	LSB

	TMPORG	DENOPT
	UNQTXT	<MI\NIMUM>
	UNQTXT	<MA\XIMUM>
	.BYTE	0		; END OF TABLE
	.EVEN
MINMAX::.WORD	0		; FLAG THAT MINIMUM OR MAXIMUM SPECIFIED
	UNORG

.SBTTL	PARSE THE :NOWARN, :Q, AND :INSPECT OPTIONS FROM /DELETE AND /PROTECT

.ENABL	LSB

PRSWIT::CMPB	(R5),#':	; IS THERE A COLON?			;002+
	BNE	NOWOPT		; NO, THIS MUST BE /NOSUPERSEDE		
	TSTB	(R5)+		; SKIP THE COLON			
	MOVB	(R5),-(SP)	; ISOLATE THE NEXT CHARACTER		
	TSTB	-(R5)		; POINT TO THE COLON AGAIN		
	CMPB	(SP)+,#'9	; IS IT NUMERIC?			
	BGT	NOWOPT		; CAN'T BE, SO PROCEED WITH /NOSUPERSEDE

;AT THIS POINT, THE ARGUMENT IS EITHER NUMERIC (A PROTECTION 		
;CODE) OR ILLEGAL, SO WE'LL LET FSS CATCH IT.				

10$:	TSTB	(R5)+		; SKIP THE COLON/NEXT CHARACTER		
	CALL	ENDSWV		; END OF THE ARGUMENT?			
	BNE	10$		; NO, EAT SOME MORE			
	MOV	R5,SWTPTR	; YES, FORGET WE SAW THE SWITCH		
	BR	30$		; RETURN				;002-

NOWOPT::CALL	BISBIT		; FIRST CHECK FOR CONFLICTS
	CMPB	(R5),#':	; IS THERE A COLON?
	BNE	30$		; NO, QUICK EXIT, NO MODIFIER		;001
	TSTB	(R5)+		; BUMP PAST THE COLON
	CALLX	GETUNQ,R0,DELOPT; CHECK FOR A DELETE OPTION MODIFIER
	BCS	20$		; FOUND :NOWARN, CAN'T BE NO MORE	;001+
	BIT	#NOOVER,R4	; ARE WE DOING /PROTECT?		
	BEQ	40$		; NO; THIS MUST BE ILLEGAL		
	CALLX	GETUNQ,R0,PROOPT; CHECK FOR /PR:Q[UERY] OR :IN[SPECT]	
	BCC	40$		; NOT THAT, MUST BE ILLEGAL		
	BIS	#PRCOLQ,SC2FLG	; SUCCESS, SET THE :Q MODIFIER		
20$:	BIS	#NOWARN,SC2FLG	; SET THE MODIFIER BIT			
30$:	CLC			; CLEAR CARRY BIT FOR NO ERROR		;001-
	RETURN			;   AND RETURN TO THE CALLER

40$:	ERROR	<Bad parameter to /DE or /PR>

.DSABL	LSB

	TMPORG	DELOPT
	UNQTXT	<NOE\RRORS>	; :NOERROR
	UNQTXT	<NOW\ARNINGS>	; :NOWARN
	UNQTXT	<N\O>		; :NO
	.BYTE	0
	UNORG

	TMPORG	PROOPT							;001+
	UNQTXT	<Q\UERY>	; :QUERY				
	UNQTXT	<IN\SPECT>	; :INSPECT				
	.BYTE	0							
	UNORG								;001-

.SBTTL	PARSE THE :SLOW OPTION FROM /INSPECT OR /QUERY

.ENABL	LSB

INSOPT::CALL	BISBIT		; SET INSPECT BIT AND CHECK FOR CONFLICTS
	CMPB	(R5),#':	; IS THERE A MODIFIER?
	BNE	10$		; NO, EXIT QUICKLY
	TSTB	(R5)+		; BUMP PAST THE COLON
	CALLX	GETUNQ,R0,SLWOPT; CHECK FOR :SLOW ON SWITCH
	BCC	20$		; NOT THERE, THAT IS AN ERROR
	BIS	#INCOLS,SC2FLG	; SET THE MODIFIER BIT
10$:	CLC			; CLEAR THE CARRY FOR NO ERROR CONDITION
	RETURN			;  AND RETURN

20$:	ERROR	<Bad parameter to /IN or /Q>

.DSABL	LSB

	TMPORG	SLWOPT
	UNQTXT	<S\LOW>		; :SLOW
	.BYTE	0
	UNORG

.SBTTL	PARSE THE /RTS SWITCH

.ENABL	LSB

RTSSWT::BIT	#RTS,R4		; WAS ONE ALREADY PARSED?
	BNE	10$		; YES, THAT IS AN ERROR
	CALL	BISBIT		; DO THE BISBIT
	CMPB	(R5)+,#':	; CHECK FOR THE MANDATORY COLON
	BNE	10$		; NOT, THERE - ERROR
	CALLX	ASCR50		; CONVERT THE RTS NAME
	MOV	R0,OUTRTS	;  AND RECORD THE FIRST PART
	BEQ	20$		; IF ZERO => ERROR
	CALLX	ASCR50		; CONVERT THE SECOND PART
	MOV	R0,OUTRTS+2	; RECORD IT
	CALL	ENDSWV		; MUST BE THE TOTAL END
	BNE	20$		; IT ISN'T - ILLEGAL RTS NAME
	;CLC			; SAY NO ERRORS
	RETURN			;  AND RETURN

10$:	ERROR	<No RTS spec>

20$:	ERROR	<Bad RTS spec>

.DSABL	LSB

.SBTTL	PARSE A NUMBER ARGUMENT FROM A SWITCH

.ENABL	LSB

GETNUM::CALL	BISBIT		; FIRST CHECK FOR CONFLICTS
GETNM1::CMPB	(R5)+,#':	; DOES THE SWITCH HAVE THE PROPER TERMINATOR?
	BNE	10$		;  NO, ERROR OUT
	CALLX	VAL		; PARSE THE VALUE
	BCS	20$		;  ERROR IF BAD VALUE
	CALL	ENDSWV		; MAKE SURE THIS IS THE END OF THE SWITCH
	BNE	20$		;  IF NOT REPORT BAD VALUE
	MOV	(SP)+,R1	; GET THE VALUE IN R1
	RETURN			;   AND RETURN

10$:	CALL	ERROR,R5,SWTER	; ABORT WITH "?Switch error"

20$:	CALL	ERROR,R5,BVALER	; ABORT WITH "?Bad switch value"

.DSABL	LSB

.SBTTL	ZERO DEVICE OR ACCOUNT

.ENABL	LSB

DOZERO::MOV	#CNTRLC,R0	; GET RESTART ADDRESS IF CTRL/C
	.SETCC			;   SET CTRL/C TRAPPING
	MOV	R4,SCNFLG	; UPDATE SCAN FLAG FOR PRDVPP
	MOV	#INSPC,R0	; POINT TO THE INPUT SPEC
	CMP	R2,#1		; WAS THERE EXACTLY INPUT FILE #1 ?
	BEQ	20$		; YES
	BLO	10$		; NO, THERE WAS NONE
	ERROR	<Too many input files>

10$:	MOV	#^RDK ,(R0)	; SET THE DEFAULT OF DK:
20$:	.SETFQB			; SET UP THE FIRQB FROM IT
	BCS	40$		; NOT A VALID DEVICE!
	BIT	#S$WILD,XRB+10	; IS THERE A WILD PPN
	BNE	50$		; YES, TELL HIM "NO GO"
	CLR	XRB		; CLEAR THE XRB TO GET DEVICE FLAGS
	.PRIV,	.LOGS
	TSTB	FIRQB		; ANY ERROR?
	BNE	40$		; YES, STOP IT HERE
	MOVB	XRB+6,R1	; R1 = DEVICE TYPE
	BEQ	60$		; DISK, CHECK OUT THE PPN SITUATION
	CLR	R0		; NON-DISK, USE PPN OF ZERO
	CMPB	R1,#MTAHND	; MAGTAPE?
	BNE	30$		;   NO, GO CHECK FOR DECTAPE
	JMP	MTZERO		;   YES, GO TO SPECIAL MAGTAPE ZERO PROCESSOR

30$:	CMPB	R1,#DTAHND	; DECTAPE?
	BEQ	80$		; YES, CHECK FOR FILE NAME
40$:	ERROR	<Can't zero device>

50$:	ERROR	<No wild cards with /Z>

60$:	MOV	FIRQB+FQPPN,R0	; DEVICE IS DISK, IS THERE A PPN?
	BEQ	70$		;   NO, SO USE OUR OWN
	BIT	#JFPRIV,KEY	; PPN SUPPLIED, IS THE USER PRIVILEGED?
	BNE	80$		;   YES, SO DON'T HASSLE HIM
	ERROR	<No PPN with /Z>;   NO, SO HASSLE HIM

70$:	MOV	OURPPN,R0	; GET OUR OWN PPN
	TSTB	FIRQB+FQDEVN+1	; IS THERE A UNIT SPECIFICATION
	BNE	80$		;   YES - SO DEVICE SPECIFICATION IS TRUE
	MOV	#"SY,FIRQB+FQDEV;   NO - SO USE THE SYSTEM STRUCTURE
80$:	TST	FIRQB+FQNAM1	; IS THERE A NAME TO ZERO?
	BEQ	100$		;   NO, GO CHECK FOR A TYPE
	ERROR	<File name illegal with /Z>

90$:	ERROR	<Illegal use of /PAR or /DEN>

100$:	BIT	#DENSTY!PARITY,SC2FLG; IS THERE A /DEN OR /PAR SWITCH HERE?
	BNE	90$		; YES, GIVE THE PERSON AN ERROR
	CLR	FIRQB+FQEXT	; CLEAR THE TYPE HERE
	CLR	INSPC+6		;   AND HERE
	MOV	R0,-(SP)	; SAVE PPN HERE
	MOV	R0,FIRQB+FQPPN	;   AND HERE
	CALL	LMARGN		; JUSTIFY OUR CARRIAGE (IT GETS GOOD MILEAGE)
	.PRINT	#ZEREAL		; "Really zero"
	CALL	PRDVPP		; PRINT THE DEVICE AND PPN (IF ANY)
	.PRINT	#QMARK		;   OUTPUT A "?" TO INDICATE A QUERY
	CALL	GETANS		; AND GET AN ANSWER
	BEQ	120$		;   HE APPROVED
	.PRINT	#ZERABT		;   NO APPROVAL, TELL HIM SO HE DOESN'T PANIC
110$:	JMP	RESTRT		; AND FINALLY GIVE UP THIS EFFORT

120$:	MOV	#INSPC,R0	; GET THE INPUT SPECIFICATION
	.SETFQB			; HAVE RT11 SET UP THE FIRQB AGAIN
	MOV	(SP)+,FIRQB+FQPPN ; RESET OUR PPN SPECIFICATION
	MOVB	#UU.ZER,FIRQB+FQFUN ; SET THE FUNCTION
	CLR	FIRQB+FQFIL	; CLEAR THE CHANNEL SPECIFICATION
	.PRIV,	.UUO		; HAVE RSTS DO THE FUNCTION
	TSTB	FIRQB		; WAS THERE AN ERROR?
	BNE	130$		; Yes, give error			;051
	MOV	#INSPC,R0	; Get the input specification		;051
	.SETFQB			; Have RT11 set up the firqb again	;051
	TST	FIRQB+FQPPN	; See if there is a PPN			;051
	BNE	125$		; If so use it				;051
	MOV	OURPPN,FIRQB+FQPPN ; Else use our own			;051
	CMPB	#377,FIRQB+FQDEVN+1 ; Is there a unit specification	;051
	BEQ	125$		;   Yes - unit # was specified		;051
	MOV	#"SY,FIRQB+FQDEV;   No - so use the system structure	;051
125$:	MOVB	#DIRFQ,FIRQB+FQFUN ; Set up for file lookup on index	;051
	CLR	FIRQB+FQFIL	; Set index # for first file in account	;051
	.PRIV,	CALFIP		; Do it					;051
	CMPB	#NOSUCH,FIRQB	; ?Can't find file or account error?	;051
	BEQ	110$		; Yes, zero was successful.  Go away	;051
	WARN	<Not all files were deleted> ; No, miserable failure	;051
	BR	110$		; Go find something to do		;051
130$:	RSTSER	ZEFAIL,<Zero failure>

.SBTTL	MAGTAPE ZERO ROUTINE

MTZERO::CLR	INSPC+6		; MAKE SURE THERE IS NO TYPE
	MOV	INSPC,ZERSPC	; GET THE DEVICE NAME INTO ZERSPC
	.LOOKUP	OUT,#ZERSPC	; TRY TO OPEN THE DEVICE
	BCS	130$		; THERE WAS AN ERROR, REPORT IT
	MOV	FIRQB+FQFIL,-(SP); SAVE THE RSTS CHANNEL NUMBER
140$:	.CLRFQB			; First, insure that drive is ASSIGN'ed
	MOV	#ZERSPC,R0	; Point to device to be zeroed
	.SETFQB			; Develop FIRQB for ZERO call to RSTS
	MOVB	#ASSFQ,FIRQB+FQFUN ; Set up UU.ASS function
	.PRIV,CALFIP
	TSTB	FIRQB		; Error on ASSIGN ?
	BEQ	150$		; No (continue to ZERO)
	RSTSER	ZEFAIL,<Zero failure> ; Yes: print message and abort
150$:	STATUS	OUT		; Get the status
	BIT	#M$WLCK,R3	; IS THE MAGTAPE WRITE LOCKED?
	BEQ	160$		;   NO, CONTINUE
	ERROR	<Magtape is write locked>

160$:	MOV	SC2FLG,R4	; GET ALL MAGTAPE ZERO PARAMETERS INTO R4
	MOV	R3,-(SP)	; SAVE THE STATUS WORD
	CLR	R3		; CLEAR R3 TO STORE PARITY		;024
	BIT	#M$EVEN,(SP)	; IS THE MAGTAPE ODD OR EVEN PARITY
	BEQ	170$		; ODD PARITY, NO ADJUST OF SET PARAM NEEDED
	INC	R3		; SAY EVEN PARITY IN PARAM WORD
170$:	BIT	#PARITY,R4	; WAS A PARITY SPECIFIED BY THE USER?	;024
	BEQ	190$		; NO, CURRENT PARITY IS RIGHT
	BIC	#1,R3		; ASSUME ODD PARITY WAS REQUESTED
	BIT	#PARODD,R4	; WAS THAT WHAT HE WANTED?
	BNE	190$		; YES, GO CHECK DENSITY
	INC	R3		;  NO, SET EVEN PARITY
190$:	MOV	DENVAL,R2	; GET DENSITY VALUE			;024
	TST	MINMAX		; DID USER SPECIFY MINIMUM OR MAXIMUM?	;024
	BEQ	195$		;  NO, CONTINUE				;024
	MOV	R3,-(SP)	; SAVE THE PARITY SETTING		;024
	MOV	R2,R3		; GET THE VALUE TO LOOKUP		;024
	MAGTAPE	OUT,XDN		; GET THE MIN OR MAX DENSITY		;024
	MOV	R3,R2		; STORE THE DENSITY			;024
	MOV	(SP)+,R3	; RESTORE THE PARITY SETTING		;024
195$:	BIT	#DENSTY,R4	; DID USER WANT TO CHANGE DENSITY?	;024
	BNE	200$		; YES, USE THE GIVEN VALUE		;024
	MOV	R3,-(SP)	; SAVE THE PARITY SETTING		;024
	CLR	R3		; PARAMETER WORD TO RETURN CURRENT DENS	;024
	MAGTAPE	OUT,XDN		; GET THE CURRENT DENSITY		;024
	MOV	R3,R2		; STORE THE DENSITY			;024
	MOV	(SP)+,R3	; RESTORE THE PARITY SETTING		;024
200$:	MOV	#DENASC,R5	; STORAGE AREA FOR THE DENSITY IN ASCII	;024
	MOV	R2,R0		; DENSITY TO CONVERT			;024
	DECNUM			; GO CONVERT IT				;024
	MOVB	#200,(R5)	; TERMINATE THE STRING			;024

	CMP	R2,#1600.	; IS THE DENSITY 1600 OR GREATER?	;024
	BLT	240$		; NO, SKIP THE FOLLOWING PARITY BIT CLEAR ;024
	BIC	#1,R3		; CLEAR THE PARITY SPECIFICATION
	BIT	#PARITY,R4	; DID THE USER ASK FOR SPECIFIC PARITY?
	BEQ	240$		; NO, CONTINUE THEN
	BIT	#PARODD,R4	; WAS THE DESIRED PARITY ODD?
	BNE	240$		; YES, EVERYTHING IS OKAY THEN
	WARN	<ODD parity set for this density>			;024
240$:	BIS	#8192.,R3	; MAKE SURE THE 'STAY AFTER CLOSE' BIT IS SET
	MOV	R3,(SP)		; SAVE THE FINAL RESULT
	MOV	#INSPC,R0	; GET THE INPUT SPEC POINTER
	.SETFQB			; SET UP THE FIRQB
	CALL	LMARGN		; MAKE SURE THE CARRIAGE IS JUSTIFIED
	.PRINT	#ZEREAL		; "Really zero"
	CALL	PRDVPP		; PRINT THE DEV SPEC
	PRINT	</PARITY:>,NOCR	; ALONG WITH THE PARITY SWITCH
	POINTX	<ODD>,NOCR	; ASSUME ODD PARITY
	BIT	#1,R3		; IS IT ODD?
	BEQ	250$		; YES, GO PRINT IT
	CMP	R2,#1600.	; IS THE DENSITY 1600 OR GREATER?	;024
	BGE	250$		; YES, SO PARITY MUST BE ODD		;024
	BIC	#1,R3		; CLEAR EVEN PARITY BIT
	POINTX	<EVEN>,NOCR	; SAY EVEN

250$:	.PRINT			;  AND PRINT WHAT EVER
	PRINT	</DENSITY:>,NOCR; PRINT DENSITY SWITCH			;024
	.PRINT	#DENASC		; PRINT THE DENSITY SPEC		;024
	.PRINT	#QMARK		; MAKE THIS A QUERY			;024
	CALL	GETANS		; GET THE USER'S RESPONSE
	BEQ	310$		; HE APPROVED
	.PRINT	#ZERABT		; "Zero aborted"
	.CLOSE	OUT		; CLOSE THE MAGTAPE
300$:	JMP	RESTRT		;  AND GIVE UP

310$:	MAGTAPE	OUT,REW,0	; REWIND THE MAGTAPE			;024
	MOV	(SP)+,R3	; SET UP PARAMETER TO MAGTAPE FUNCTION
	MAGTAPE	OUT,DEN		; THE FUNCTION IS CHANGE PARITY		;024
	MOV	R2,R3		; PUT THE DENSITY IN THE PARAMETER WORD	;024
	BIS	#100000,R3	; SAY THAT WE ARE SETTING THE DENSITY	;024
	MAGTAPE	OUT,XDN		; SET THE DENSITY			;024
	BCC	315$		; CONTINUE IF NO ERRORS			;024
	CMPB	#52.,FIRQB	; ERROR, WAS IT INVALID DENSITY?	;024
	BNE	320$		; NO, USE GENERAL ERROR HANDLER		;024
	PRINT	<?Invalid density - >,NOCR	; PRINT ERROR MESSAGE	;024
	.PRINT	#DENASC		; PRINT THE DENSITY			;024
	MOV	#CRLF,R0	; SET UP TO PRINT A BLANK LINE		;024
	.PRINT			; PRINT IT				;024
	BR	300$		; AND EXIT				;024

315$:	.CLOSE	OUT		; CLOSE THE OUTPUT FILE (MT:)
	MOV	#INSPC,R0	; GET THE INPUT SPEC POINTER AGAIN
	.SETFQB			; SET UP THE FIRQB
	MOVB	#UU.ZER,FIRQB+FQFUN ; SET THE FUNCTION CODE TO ZERO FUNCTION
	CLR	FIRQB+FQFIL	; CLEAR THE CHANNEL SPECIFICATION
	.PRIV,	.UUO		;     AND FINALLY ZERO THE FILE
	TSTB	FIRQB		; WAS THERE AN ERROR?
	BEQ	300$		; NO, RESTART THE SCANNER
320$:	RSTSER	ZEFAIL,<Zero failure>					;024

.DSABL	LSB

.SBTTL	DATA FOR ZERO COMMAND

	TMPORG	DENASC
	.NLIST	BEX
	.BLKB	5
	.BYTE	200

	UNORG

.SBTTL	SWITCH PROCESSORS FOR PER-FILE SWITCHES
.SBTTL	PROCESS DIRECTORY SWITCHES

;+
; ON ENTRY:
;
;	R3 =  VALUE (IF C=1)
;	R4 =  SCAN FLAGS
;	R5 =  FILE NUMBER * 2
;
; ROUTINES MAY CLOBBER R1, R2, R3, R5
;
; ON EXIT: C=1 IFF ERROR
;-

.ENABL	LSB

SLSWIT::MOV	#^C<DIR.OA!DIR.W!DIR.AL!DIR.SU>,R1
				; Set the value to a slow listing
	BCC	10$		; IF NO OPTION THEN CONTINUE
	ERROR	<No options allowed with /S>

LSWIT::	MOV	#DIR.NA!DIR.EX!DIR.SI!DIR.PR!DIR.DA!DIR.HD,R1
	BCS	20$		; IF VALUE, USE IT
10$:	BIS	R1,SWTTBL(R5)	; ELSE USE UNARGUMENTED VALUE
	MOV	R1,DDFALT	; AND SET NO-SWITCH DEFAULT
	BR	40$		; GO CHECK CONFLICT

FSWIT::	MOV	#DIR.NA!DIR.EX,R1 ; SET UNARGUMENTED VALUE
	BCC	10$		; IF NO ARGUMENT, USE IT
20$:	MOV	#DIRTBL,R1	; POINT TO TABLE OF SWITCHES
	CLR	R2		; USE ONLY 2 CHARACTERS
	DIV	#50,R2		; REDUCE IT
	MUL	#50,R2		; R3 HAS FIRST 2 CHARACTERS
30$:	MOV	(R1)+,R2	; GET BITS
	BEQ	50$		; NONE, ERROR
	CMP	R3,(R1)+	; IS THIS IT?
	BNE	30$		; NO, TRY MORE
	BIS	R2,SWTTBL(R5)	; YES, SET THE BITS
	MOV	R2,DDFALT	; Make present value the default, now
40$:	MOV	#CV.DIR,R1	; MASK FOR LISTING SWITCHES
	BR	80$		; CHECK FOR NO /RMS OR /BL

50$:	CALL	ERROR,R5,BVALER	; ABORT WITH "?Bad switch value"

.SBTTL	PROCESS THE RMS SWITCH

RMSSWT::MOV	#RMSDSK,R2	; SET DEFAULT BITS IF NO VALUE
	BCC	70$		; IF NO VALUE, USE THIS
	MOV	#RMSOPT,R1	; POINT TO RMS SWITCH VALUES
	CMP	R5,#3*2		; OUTPUT FILE?
	BHIS	60$		; NO, ALL VALUES ARE LEGAL
	ADD	#3*4,R1		; YES, :IM, :FTN, AND :PRN ARE ILLEGAL
60$:	MOV	(R1)+,R2	; GET A SWITCH VALUE
	BEQ	50$		; NO MORE, ERROR
	CMP	R3,(R1)+	; IS THIS IT?
	BNE	60$		; NO
70$:	MOV	R2,SWTTBL(R5)	; SAVE THE SWITCH VALUE
	MOV	#CV.RMI,R1	; SET VALUE OF 1 FOR RMS ON INPUT SIDE
	CMP	R5,#3*2		; OUTPUT FILE (C=1 IF SO) ?
	ADC	R1		; SET VALUE OF 2 FOR RMS ON OUTPUT SIDE
.ASSUME	CV.RMO	EQ	CV.RMI+1
80$:	BIS	R1,RMSFLG	; SET FLAG SAYING /RMS IN OR OUT, OR /BL
	CMP	R1,RMSFLG	; IF ANY OTHER FLAG BIT IS SET, C=1 AS ERROR
	RETURN

.SBTTL	SWITCH PROCESSORS FOR COMPLEX OPTION SWITCHES

;+
; ON ENTRY:
;
;	R1 -> ARGUMENTS
;	R2 =  0
;	R4 =  SCAN FLAGS
;	R5 -> REMAINDER OF SWITCH (INCLUDING ARGUMENT IF PRESENT)
;	C=0
;
; ROUTINE MAY CLOBBER R1,R2,R3
;
; ON EXIT:
;
;	R5 -> PAST SWITCH ARGUMENT (IF ANY)
;	C=1 IFF ERROR
;-

VSWIT::	CLRB	@STOPPER	; Stop the message after one line for /ID
IDSWIT::MOV	R0,-(SP)	; SAVE R0
	.PRINT	#VERMSG		; PRINT VERSION STUFF
	MOVB	#15,@STOPPER	; Restore full /VE message
90$:	MOV	(SP)+,R0	; RESTORE R0
NLSWIT::CLC			; ENSURE C=0 FOR RETURN
	RETURN			; DONE

SETLPR::MOV	(R1)+,XRB	; SET TO RUN WITH PRIORITY OR TO RUN LOCKED
	.PRIV,	.SET		; GET SPECIAL MODE IF POSSIBLE, IGNORE ERROR
	RETURN			; DONE

DERROR::ERROR	<Use /DE for delete> ; FOR HE WHO TYPES /D

CVTMOD::MOV	(R1),R1		; SET FLAG FOR CONVERSION
	BR	80$		; MERGE TO CHECK


.SBTTL	DATE RELATED SWITCH PROCESSING

; DATE-RELATED SWITCHES

TODAY::	CMPB	(R5),#':	; TODAY CANNOT HAVE A VALUE
	BEQ	120$		; DIE IF SO
DATESW::BITB	(R1),DATFLG	; CONFLICTING DATES?
	BNE	120$		; YES, DIE
	BISB	(R1),DATFLG	; SET DATES FOUND
	MOVB	(R1)+,-(SP)	; SAVE FLAG
	MOVB	(R1),R2		; GET MODIFICATION OF 0 OR +1 OR -1
	CALL	DATE		; PARSE A DATE
	ADD	R2,R1		; CORRECT THE DATE
	ASRB	(SP)		; SAVE LODATE?
	BCC	100$		; NO
	MOV	R1,LODATE	; YES, DO IT
100$:	TSTB	(SP)+		; SAVE HIDATE?
	BEQ	110$		; NO
	MOV	R1,HIDATE	; YES, DO IT
110$:	RETURN			; C=0

120$:	SEC			; RETURN C=1
	RETURN

;+
; DATE & FILESIZE RELATED SWITCHES HAVE A 2-BYTE ARGUMENT		;032
;
;	LOW BYTE = MASK OF WHICH END POINT (1=LOW, 2=HIGH, 3=BOTH)
;	HIGH BYTE = MODIFICATION (0, +1, OR -1)
;-

.EQUATE	MODP1,	+1*400		; MODIFY BY +1 (AFTER)
.EQUATE	MODM1,	-1*400		; MODIFY BY -1 (BEFORE)
.EQUATE	LOLIM,	1		; SET LOW LIMIT
.EQUATE	HILIM,	2		; SET HIGH LIMIT

.SBTTL	DO THE HELP OPTION

HELPME::MOV	R0,-(SP)	; SAVE REGISTER AROUND HELPER
	;CLR	R2		; INCOMING REGISTER IS CLEAR
	;CLC			;  AS IS CARRY
	MOV	BUFFER,R1	; POINT TO SOME ROOM
	MOV	BUFSIZ,R3	; GET SIZE IN BYTES
	BIC	#777,R3		; MAKE IT AN EVEN BLOCK BOUNDARY
	ROR	R3		;  AND MAKE IT WORDS
	MOV	#175$,R0	; GET THE ADDRESS OF THE HELP LOGICAL	;020
	EMT	365		; FSS IT TO GET THE DEVICE AND PPN	;020
	TST	XRB+10		; WAS THE LOGICAL DEFINED?		;020
	BMI	150$		; NO, GO PRINT WARNING			;020
	MOV	FIRQB+FQPPN,HELPPN; SAVE THE PPN			;020
	MOV	FIRQB+FQDEV,HELPDV; SAVE THE DEVICE NAME		;020
	MOV	#60,HELPDV+2	; DEFAULT TO UNIT NUMBER 0		;020
	CLRB	HELPDV+3	; .ASCIZ TERMINATE THE STRING		;020
	MOV	FIRQB+FQDEVN,HELPUN ; STORE THE UNIT NUMBER AND FLAG	;038
	MOV	#HELPDV,R0	; POINT R0 TO THE DEVICE NAME		;038
	EMT	365		; FSS IT TO GET THE RAD-50		;038
	CMPB	#377,HELPUN+1	; WAS A UNIT NUMBER SPECIFIED?		;038
	BNE	125$		; NO, LEAVE THE DEFAULT OF 0 ALONE	;038
	CLR	R0		; CLEAR A HANDY REGISTER		;038
	MOVB	HELPUN,R0	; GET THE UNIT NUMBER			;038
	ADD	R0,FIRQB+FQNAM1	; ADD IT TO THE RAD-50 OF THE DEVICE	;038
125$:	MOV	FIRQB+FQNAM1,170$ ; MOVE IN THE RAD-50 OF THE DEVICE	;038
	MOV	SYSPTR,R0	; GET THE R/W AREA POINTER		;020
	MOV	HELPPN,(R0)	; MOVE IN THE PPN			;020
.ASSUME	PPN	EQ	0	; PPN MUST BE AT OFFSET ZERO IN R/W AREA
	.LOOKUP	IN,#170$	; OPEN THE HELP FILE
	BCS	150$		; NO HELP FOR YOU
130$:	.READW	IN,R1,R3,R2	; GET SOME HELP
	BCS	160$		; EOF OR ERROR, JSUT QUIT
	MOV	R1,R0		; COPY BUFFER POINTER
	ADD	#1000,R0	; POINT TO END OF TEXT
140$:	TSTB	-(R0)		; BACKSCAN OFF NULLS
	BEQ	140$		; UNTIL NON-NULL
	MOVB	#200,1(R0)	; END THE .PRINT WITH NO CR/LF
	.PRINT	R1		; PRINT THE BLOCK
	INC	R2		; NEXT BLOCK NUMBER
	BR	130$		; DO MORE

150$:	WARN	<No help available>
160$:	.CLOSE	IN
	CALL	LMARGN		; ENSURE CARRIAGE IS RESTORED
	BR	90$		; RESTORE REGISTER AND RETURN

170$:	.RAD50	/ SYPIPSAVHLP/	; FILE WITH HELP			;020
	.EVEN								;020
175$:	.ASCIZ	/HELP$:/	; HELP ACCOUNT				;020
	.EVEN								;020
HELPDV:	.BLKW	2		; TEMP AREA FOR XLATE DEVICE TO RAD-50	;020
HELPUN:	.BLKW	1		; TEMP AREA FOR DEVICE UNIT # AND FLAG	;038
HELPPN:	.BLKW	1		; TEMP AREA FOR PPN OF HELP ACCOUNT	;020
.DSABL	LSB

.SBTTL	SELECT-BY-FILESIZE RELATED SWITCH PROCESSING

; SELECT-BY-FILESIZE SWITCHES						;032

	.ENABL	LSB							;032

SELFSZ::CMPB	(R5)+,#':	; CHECK FOR THE ARGUMENT SEPARATOR	;032
	BNE	40$		; NOT THERE, OH NOOOOOOO!!!		;032
	BITB	(R1),SIZFLG	; CONFLICTING FILESIZE SWITCHES?	;032
	BNE	40$		; YES, GO ERROR				;032
	BISB	(R1),SIZFLG	; SET SWITCH FOUND			;032
	MOV	R4,-(SP)	; SAVE R4				;032
	MOVB	(R1)+,-(SP)	; SAVE FLAG				;032
	MOVB	(R1),R2		; GET MODIFICATION OF 0 OR +1 OR -1	;032
	MOV	#FILSIZ,R4	; POINT TO THE STORAGE AREA		;032
	CALL	VALDBL		; PARSE THE USER-SPECIFIED FILESIZE	;032
	BCS	40$		; EXIT IF ERROR				;032
	TST	R2		; TEST THE MODIFIER			;032
	BEQ	10$		; IT'S ZERO, CONTINUE			;032
	BMI	5$		; IT'S NEGATIVE, GO DECREMENT		;032
	ADD	#1,2(R4)	; INCREMENT THE LSB			;032
	ADC	(R4)		; ADD THE CARRY (IF ANY) TO THE MSB	;032
	BR	10$		; CONTINUE				;032

5$:	SUB	#1,2(R4)	; DECREMENT THE LSB			;032
	SBC	(R4)		; SUBTRACT THE CARRY (IF ANY) FROM THE MSB;032
10$:	ASRB	(SP)		; SAVE LOW FILESIZE?			;032
	BCC	20$		; NO					;032
	MOV	2(R4),LOSIZL	; YES, SAVE THE LSB			;032
	MOV	(R4),LOSIZM	;  AND THE MSB				;032
20$:	TSTB	(SP)+		; SAVE HIGH FILESIZE?			;032
	BEQ	30$		; NO					;032
	MOV	2(R4),HISIZL	; YES, SAVE THE LSB			;032
	MOV	(R4),HISIZM	;  AND THE MSB				;032
30$:	MOV	(SP)+,R4	; RESTORE R4				;032
	RETURN			; ALL DONE				;032

40$:	SEC			; ERROR, RETURN C=1			;032
	RETURN			; GO BACK				;032

	.DSABL	LSB							;032

.SBTTL	Convert String to 32-bit Unsigned Integer

	;+								;032
	; VALDBL - Convert String to 32-bit Unsigned Integer		;032
	; CALL:	R4 -> 2 Word block to store results			;032
	;	R5 -> String to convert					;032
	;	CALL	VALDBL						;032
	;								;032
	; BACK: (R4) = High Word					;032
	;	2(R4)= Lower Word					;032
	;	R5 -> First Unconverted Character			;032
	;	Leading, embedded, and trailing blanks are ignored.	;032
	;-								;032

	.ENABL	LSB							;032

VALDBL::MOV	R1,-(SP)	; SAVE REGISTERS 1-3			;032
	MOV	R2,-(SP)	;					;032
	MOV	R3,-(SP)	;					;032
	CLR	R1		; CLR RESULT ACCUMULATORS		;032
	CLR	R2		;					;032
	CLR	R3		;					;032
10$:	MOVB	(R5)+,R1	; GET NEXT CHAR				;032
	CMPB	R1,#40		; LEADING SPACE?			;032
	BEQ	10$		; GET NEXT CHAR IF SO			;032
	CMPB	R1,#11		; LEADING TAB?				;032
	BEQ	10$		; GET NEXT CHAR IF SO			;032
	SUB	#'0,R1		; CONVERT DIGIT TO VALUE		;032
	BLO	XERR		; ERROR IF NOT A DIGIT			;032
	CMP	R1,#9.		; CHARACTER IN RANGE?			;032
	BHI	XERR		; ERROR IF NOT				;032
20$:	ASHC	#1,R2		; MULTIPLY BY TWO			;032
	BCS	XERR		; BRANCH IF NUMBER TOO LARGE		;032
	MOV	R2,-(SP)	; SAVE HIGH ORDER BITS			;032
	MOV	R3,-(SP)	; SAVE LOW ORDER BITS			;032
	ASHC	#1,R2		; MULTIPLY BY TWO AGAIN			;032
	BCS	XERR		; BRANCH IF NUMBER TOO LARGE		;032
	ASHC	#1,R2		; HAVE (NEW NUMBER) = 8.*(OLD NUMBER)	;032
	BCS	XERR		; BRANCH IF NUMBER TOO LARGE		;032
	ADD	(SP)+,R3	; ADD BACK 2*(OLD NUMBER)		;032
	ADC	R2		; ADD THE CARRY TO THE MSB		;032
	BVS	XERR		; BRANCH IF NUMBER TOO LARGE		;032
	ADD	(SP)+,R2	; HAVE (NEW NUMBER) = 10.*(OLD NUMBER)	;032
	BVS	XERR		; BRANCH IF NUMBER TOO LARGE		;032
	BCS	XERR		; DITTO					;032
50$:	ADD	R1,R3		; ADD NEW DIGIT				;032
	ADC	R2		; ADD THE CARRY TO THE MSB		;032
	BCS	XERR		; BRANCH IF NUMBER TOO LARGE		;032
60$:	MOVB	(R5)+,R1	; GET NEXT CHAR				;032
	CMPB	R1,#40		; LEADING SPACE?			;032
	BEQ	60$		; GET NEXT CHAR IF SO			;032
	CMPB	R1,#11		; LEADING TAB?				;032
	BEQ	60$		; GET NEXT CHAR IF SO			;032
	SUB	#'0,R1		; CONVERT DIGIT TO VALUE		;032
	BLO	70$		; EXIT IF NOT A DIGIT			;032
	CMP	R1,#9.		; CHARACTER IN RANGE?			;032
	BHI	70$		; EXIT IF NOT				;032
	BR	20$		; GO WORK ON NEXT CHARACTER		;032

70$:	TSTB	-(R5)		; RESTORE R5'S POSITION			;032
	CALL	ENDSWV		; CHECK FOR THE END OF THE SWITCH	;032
	BNE	XERR		; BAD ENDING				;032
	BIT	#177400,R2	; ANY BITS SET IN HIGH BYTE OF MSB?	;032
	BNE	XERR		; YES, IT'S TOO BIG, GO ERROR		;032
	MOV	R2,(R4)		; STORE HIGH BITS			;032
	MOV	R3,2(R4)	; STORE LOW BITS			;032
	CLC			; ENSURE THE CARRY BIT IS CLEAR		;032
	BR	XEXIT		; AND EXIT				;032

	; ERROR AND NORMAL EXITS					;032

XERR:	ERROR	<Bad filesize>	; PRINT THE ERROR MESSAGE		;032

XEXIT:	MOV	(SP)+,R3	; RESTORE REGISTER 3			;032
	MOV	(SP)+,R2	; RESTORE REGISTER 2			;032
	MOV	(SP)+,R1	; RESTORE REGISTER 1			;032
	RETURN								;032

	.DSABL	LSB							;032

 .SBTTL	PARSE A DATE

;+
; DATE - PARSE A DATE FROM THE COMMAND LINE
;
;	R5 -> COMMAND LINE
;
;	CALL	DATE
;
;	R1 =  DATE (YEAR*1000.+DAY)
;	R5 -> CHARACTER AFTER DATE (MUST BE NULL, ',', '=', OR '/')
;-

.ENABL	LSB

DATE::	MOV	CURDAT,R1	; ASSUME TODAY'S DATE
	CMPB	(R5),#':	; IS THERE A SWITCH VALUE?
	BNE	50$		; NO, RETURN TODAY'S DATE
	REGSCR			; SAVE REGISTERS
	INC	R5		; BUMP OVER THE COLON
	CALLX	VAL		; GET THE DAY VALUE
	BCS	60$		; ERROR
	MOV	(SP)+,R4	; GET THE DAY IN R4
	BEQ	60$		; DAY OF 0 IS AN ERROR
	CMP	R4,#31.		; QUICK CHECK OF LEGALITY
	BHI	60$		; CANNOT BE VALID
	CMPB	(R5),#'-	; HYPHEN MUST FOLLOW
	BNE	60$		; IF NOT, ILLEGAL
	MOV	R5,R3		; PRESERVE POINTER TO MMM
	ADD	#4,R5		; POINT PAST THE MONTH NAME
	CMPB	(R3)+,(R5)+	; SKIP THE HYPHEN AFTER THE MONTH NAME
	BEQ	10$		; IF PRESENT, GO PARSE THE YEAR VALUE
	MOV	CURDAT,R1	; IF NO YEAR, USE TODAY
	CLR	R0		; CLEAR FOR DIVIDE
	DIV	#1000.,R0	; COMPUTE YEAR NUMBER AS QUOTIENT IN R0
	ADD	#70.,R0		; BIAS FOR FEBRUARY TESTING
	DEC	R5		; BACK UP POINTER TO NON-HYPHEN AFTER DATE
	BR	20$		; GO USE THIS YEAR

10$:	CALLX	VAL		; GET A YEAR VALUE FROM THE COMMAND
	BCS	60$		; ERROR
	MOV	(SP)+,R0	; GET YEAR OFF OF THE STACK

20$:	MOVB	#29.,MONFEB	; ASSUME IT'S A LEAP YEAR
	BIT	R0,#3		; IS IT?
	BEQ	30$		; YUP
	DECB	MONFEB		; NO, A SHORT FEBRUARY
30$:	CMP	R0,#70.		; 70 <= year <= 99?			;077
	BHIS	35$		; Yes, leave it alone.			;077
	CMP	R0,#35.		; 36 < year < 69			;077
	BHI	60$		; Yes, error				;077
	ADD	#100.,R0	; No, 00 <= year <= 35, so add 100.	;077
35$:	SUB	#70.,R0		; NO, UNBIAS THE YEAR
	MUL	#1000.,R0	; COMPUTE YEAR*1000.
	;CLR	R0		; (HIGH ORDER IS CLEAR AS A SIDE EFFECT)
	MOV	#MONTHS-2,R2	; POINT TO TABLE OF MONTHS
40$:	ADD	R0,R1		; ADD LENGTH OF PREVIOUS MONTH INTO YEAR
	CMPB	(R2)+,(R2)+	; BUMP MONTH TABLE POINTER
	MOVB	(R2)+,R0	; GET LENGTH OF NEXT MONTH
	BEQ	60$		; UNKNOWN MONTH
	CMPB	(R3),(R2)+	; IS THIS A MATCH?
	BNE	40$		; NO, NEXT MONTH
	CMPB	1(R3),(R2)	; MAYBE?
	BNE	40$		; NO
	CMPB	2(R3),1(R2)	; MAYBE?
	BNE	40$		; NOPE, TRY AGAIN
	CMP	R4,R0		; COMPARE DAY VALUE AGAINST LENGTH OF MONTH
	BHI	60$		; DAY SPECIFIED IS NOT IN MONTH SPECIFIED
	ADD	R4,R1		; ACCUMULATE DATE TOTAL
	MOV	R1,1*2+2(SP)	; SAVE IT FOR POSTERITY
	MOV	R5,5*2+2(SP)	; SAVE UPDATED TEXT POINTER, TOO
	CALL	ENDSWV		; ENDS ON NULL, COMMA, EQUALS, OR SLASH?
	BNE	60$		; NO, EVIL ENDING
50$:	RETURN			; DONE

60$:	ERROR	<Bad date spec>

.DSABL	LSB

	TMPORG	TEXT
	.NLIST	BEX
MONTHS::.ASCII	<31.>"JAN"
MONFEB::.ASCII	<28.>"FEB"<31.>"MAR"<30.>"APR"<31.>"MAY"<30.>"JUN"<31.>"JUL"
	.ASCIZ	<31.>"AUG"<30.>"SEP"<31.>"OCT"<30.>"NOV"<31.>"DEC"
	UNORG

.SBTTL	GET COMMAND LINE

.ENABL	LSB

GCML::	TST	INDCMD		; IS INPUT CURRENTLY FROM INDIRECT FILE?
	BLE	10$		; NO, GET INPUT FROM KB:
	CALL	GCMIND		; GET INPUT FROM  INDIRECT
	BR	30$		;  AND MERGE TO COMMON COMMAND LINE PROCESSING

10$:	CALL	LMARGN		; NO, RESET TO THE LEFT MARGIN
	.TTYOUT	#'*		; PRINT A PROMPT
	CALLX	INPUTL,R5,<511.,DIRBUF> ; GET A COMMAND LINE FROM THE TERMINAL  ;017
	BCC	20$		; IF THERE WAS NO ERROR CONTINUE
	CALL	LMARGN		; DO A LEFT MARGIN
	.PRINT	#LNELNG		; TELL THE USER THE ERROR OF HIS WAYS
	BR	10$		;  AND GET A NEW LINE FROM THE CONSOLE

20$:	CALL	LMARGN		; RESET IF NOT AT LEFT MARGIN
30$:	MOV	#10,R0		; FIRST REMOVE LEADING BLANKS
	CALLX	CVT$$		;  FROM THE COMMAND STRING
	MOV	R5,R0		; COPY COMMAND STRING POINTER
	CMPB	(R0),#';	; IS THIS A COMMENT LINE?
	BEQ	GCML		; YES, RESTART GCML
	CMPB	(R0)+,#'@	; INDIRECT FILE MAYBE?
	BNE	40$		; NO WAY
	.DOFSS			; MAYBE. TRY A FILE STRING SCAN
	BCS	40$		; SCAN BLEW UP, SO NOT INDIRECTER
	TST	XRB+XRBC	; INDIRECT REQUIRES FULLY EATEN NAME
	BNE	40$		; DIDN'T SCAN EVERTHING, SO NOT INDIRECT
	BIT	#S$DEVX!S$WILD,XRB+10 ; IS THERE SOMETHING FISHY IN FILE NAME?
	BEQ	50$		;         NO, THIS IS A REAL INDIRECTION
40$:	RETURN			; GOT A LINE, NOT INDIRECT FILE

.SBTTL	SET UP NEW INDIRECT COMMAND FILE

50$:	INC	R5		; POINT  TO THE FILE SPECIFICATION
	TST	INDCMD		; ARE THERE ANY INDIRECTORS OPEN NOW?
	BNE	60$		; YES, GO DO THE NEXT
	GETBUF	512.		; NO, WE NEED A DISK BUFFER
	BCS	130$		; ERROR GETTING DISK BUFFER
	MOV	R1,INDBUF	; RECORD THE BUFFER ADDRESS
60$:	TST	INDINV		; IS THE CURRENT ICF NON-DISK?
	BNE	90$		; YES, BOOT HIM, CAN'T DO THIS INDIRECT
	GETBUF	IN$SIZ		; GET A BUFFER THE SIZE OF AN CFB
	BCS	130$		; ERROR GETTING THE FCB
	MOV	R1,INDPTR	; SAVE THE NEW INDIRECT COMMAND FILE POINTER
	.CLOSE	IND		; CLOSE ANY CURRENTLY OPEN INDIRECTORS
	CLR	INDOPN		; CLEAR THE INDIRECT COMMAND FILE OPEN FLAG
	.CSISPC	#INDSPC,#INDEXT,R5; TRANSLATE THE COMMAND
	BCS	100$		; ERROR IN TRANSLATION
	TST	(SP)+		; BETTER NOT BE SWITCHES
	BNE	100$		; OOPS
	INC	INDCMD		; SAY ONE MORE LEVEL OF INDIRECT
	MOV	#INDFIL,R0	; SET POINTER TO THE FILE SPECIFICATION
	.SETFQB			; SET UP THE FIRQB
	MOV	FIRQB+FQPPN,(R1); SET THE PPN
	BNE	70$		; A PPN WAS SPECIFIED, SO GO PROCESS
	MOV	OURPPN,(R1)	; SET OUR PPN TO AVOID [1,2] LOOKUP
70$:	TST	(R1)+		; BUMP TO NEXT PARAMETER
	MOV	(R0)+,(R1)+	; COPY THE DEVICE  SPEC
	MOV	(R0)+,(R1)+	; COPY THE FILE NAME
	MOV	(R0)+,(R1)+	;   AND THE SECOND PART
	MOV	(R0)+,(R1)+	; GET THE TYPE
	MOV	INDBUF,(R1)+	; SET THE BYTE POINTER
	MOV	#512.,(R1)+	; AND THE COUNT TO THE MAX
	CLR	(R1)+		; CLEAR THE BLOCK NUMBER
	CLR	(R1)+		;
80$:	BR	GCML		;     AND GET A NEW COMMAND LINE

90$:	ERROR	<Can't nest command file>

.SBTTL	ERROR PROCESSING FOR NEW INDIRECT COMMAND FILES

100$:	PRINT	<?Bad command file spec>
	MOV	#RESTRT,-(SP)	; SET UP A PHONEY RETURN ADDRESS
	TST	INDCMD		; DO WE HAVE AN INDIRECTOR CURRENTLY OPEN
	BNE	120$		; YES, RETURN ALLOCATED CFB POINTER
110$:	CALLR	ZAPIND		; NO, DO A FULL RETURN

120$:	RETBUF	IN$SIZ		; RETURN THE BUFFER
	SUB	R0,INDPTR	;  AND SUBTRACT THE POINTER
	RETURN			; RETURN

130$:	PRINT	<?No buffer space for command file>
	MOV	#RESTRT,-(SP)	; SET PHONEY RETURN ADDRESS
	TST	INDCMD		; WAS THERE A FILE OPEN
	BEQ	110$		; NO, RETURN ALL
	RETURN			; YES, SO JUST RETURN

.DSABL	LSB

.SBTTL	READ FROM INDIRECT COMMAND FILE

.ENABL	LSB

GCMIND::TST	INDOPN		; IS THE INDIRECTOR CURRENTLY OPEN
	BNE	10$		; YES, GO DO THE INPUT
	CALL	OPINDR		; NO, OPEN THE INDIRECT FILE
10$:	MOV	#DIRBUF,R5	; POINT TO BUFFER FOR COMMAND LINE
	MOV	INDPTR,R4	; POINT TO INDIRECT FILE PARAMETERS
	MOV	#83.,R1		; GET MAXIMUM LINE LENGTH
	MOV	IN$PTR(R4),R2	; GET BUFFER POINTER
	MOV	IN$CNT(R4),R3	; GET COUNT OF BYTES LEFT
20$:	DEC	R3		; COUNT DOWN BYTES
	BPL	30$		; GO IF ANY ARE LEFT
	MOV	INDBUF,R2	; RESET BUFFER POINTER
	MOV	SYSPTR,R0	; GET POINTER TO RW AREA
	ADD	#1,IN$LSB(R4)	; BUMP BLOCK NUMBER IN LO WORD
	ADC	IN$MSB(R4)	;  INCLUDE ANY CARRY IN THE HI WORD
	MOV	IN$MSB(R4),RWMSBS(R0); SET MSB OF BLOCK TO READ
	.READW	IND,R2,#256.,IN$LSB(R4) ; GET NEXT INDIRECT BLOCK
	BCS	50$		; ERROR ON READ, GO DECODE IT
	MOV	#511.,R3	; COUNT IS NOW 512.
30$:	MOVB	(R2)+,R0	; GET A BYTE
	BIC	#^C<377>,R0	; CLEAR SIGN EXTEND OF CHARACTER        ;012
	BEQ	20$		; SKIP NULL BYTES
	MOVB	R0,(R5)+	; SAVE IT
	CMPB	R0,#12		; LINE FEED?
	BEQ	40$		; YES, DONE
	CMPB	R0,#33		; ESCAPE?
	BEQ	40$		; YES, DONE
	CMPB	R0,#14		; FORM FEED?
	BEQ	40$		; YES, DONE
	SOB	R1,20$		; COUNT DOWN, GO FOR MORE IF ROOM
	CALL	CLSIND		; CLOSE THE INDIRECTOR
	MOV	#LNELNG,R0	; POINT AT TEXT TO PRINT
	BR	70$		;  AND PRINT THE ERROR

40$:	MOV	R3,IN$CNT(R4)	; SAVE INDIRECT BUFFER COUNT
	MOV	R2,IN$PTR(R4)	;  AND POINTER
	CLRB	(R5)		; MAKE THE COMMAND ASCIZ
	MOV	#DIRBUF,R5	; POINT TO IT AGAIN
	MOV	#4,R0		; MASK ALL JUNKY CHARACTERS
	CALLX	CVT$$		; DO IT
	TSTB	(R5)		; NULL STRING?
	BEQ	10$		; YES, GET ANOTHER
	MOV	R5,R0		; COPY STRING POINTER
	MOVB	#'*,-(R0)	; INSERT PROMPT
	.PRINT			; PRINT IT
	RETURN			; DONE

50$:	CALL	LMARGN		; INSURE A LEFT MARGIN
	CALL	CLSIND		; CLOSE OUT THE INDIRECT
	CHKERR	EOF		; WAS THE ERROR EOF?
	BNE	60$		; NO, SO THE ERROR IS REAL
	CMP	R5,#DIRBUF	; YES, WERE WE INSIDE A LINE?
	BEQ	90$		; NO, REVERT TO TERMINAL
	POINTX	<?EOF inside command file>,NOCR
	BR	70$		; GO REPORT THE ERROR

60$:	MOV	#CMRTXT,R0	; POINT TO "?READ ERROR" TEXT
	TSTB	FIRQB		; WAS THERE AN HONEST TO GOODNESS ERROR?
	BEQ	70$		; NO, PRINT TEXT POINTED TO BY R0
	MOVB	FIRQB,R0	; GET THE ERROR CODE
	.ERRPRT			; PRINT IT
	BR	80$		;   AND MERGE TO COMMON CODE

70$:	.PRINT			; PRINT THE STUFF -> R0
80$:	.PRINT	#CMFTXT		; PUT IN A SEPARATOR
	MOV	(R4)+,@SYSPTR	; R4 -> CFB, SET PPN
.ASSUME	PPN	EQ	0	;
	MOV	R4,R0		; SET THE ADDRESS OF THE PARAMETER BLOCK
	.SETFQB			; SET UP THE FIRQB
	CALL	PRDVPP		; PRINT THE FILE NAME
	CALL	TTCRLF		; JUSTIFY THE CARRIAGE AND EXIT
90$:	JMP	RESTRT		; RESTART

.DSABL	LSB

.SBTTL	CLOSE INDIRECT COMMAND FILE

.ENABL	LSB

CLSIND::DEC	INDCMD		; SAY ONE LESS INDIRECTOR
	BLE	ZAPIND		; NO MORE LEFT, ZAP INDIRECT BUFFERS
	MOV	INDPTR,R1	; GET THE ADDRESS OF THE CFB
	RETBUF	IN$SIZ		; AND RETURN IT
	SUB	R0,INDPTR	; POINT TO THE PREVIOUS INDIRECTOR
	CLR	INDOPN		; CLEAR THE OPEN FLAG
	BR	10$		; MERGE TO OPEN INDIRECTOR CLOSING CODE

.SBTTL	ZAP ALL INDIRECTORS

ZAPIND::CLR	INDCMD		; SAY NO INDIRECTORS
	MOV	BUFSZ,BUFSIZ	; RESET THE BUFFER SIZE
	MOV	INIBUF,BUFFER	; RESET THE BUFFER ADDRESS
10$:	CLR	INDINV		; CLEAR THE INDIRECT INVALID FLAG
	MOV	FIRQB,-(SP)	; SAVE ANY CURRENT ERROR CODE
	MOV	R0,-(SP)	; SAVE R0
	.CLOSE	IND		; CLOSE THE CURRENTLY OPEN INDIRECT FILE
	MOV	#3*400+IND,R0	; MAKE SURE
	EMT	374		;  IT IS CLOSED BY PURGING IT
	MOV	(SP)+,R0	; RESTORE R0
	MOV	(SP)+,FIRQB	; RESTORE THE ERROR CODE AT TIME OF CALL
	RETURN			; RETURN TO CALLER

.DSABL	LSB

.SBTTL	OPEN AN INDIRECT COMMAND FILE

.ENABL	LSB

OPINDR::MOV	INDPTR,R4	; GET THE POINTER TO THE CFB
	MOV	SYSPTR,R5	; GET THE POINTER TO R/W AREA
	MOV	(R4),(R5)	; STUFF THE PPN OF THE FILE
.ASSUME	PPN	EQ	0	;
	MOV	R4,R0		; COPY POINTER TO FILE SPEC
	TST	(R0)+		;  AND POINT TO A DEVICE
	.LOOKUP	IND		; OPEN IT
	BCS	20$		; ERROR OPENING.

10$:	MOVB	FIRQB+FQFLAG,INDINV ; PUT THE HIDX INTO THE FLAG
	MOV	IN$MSB(R4),RWMSBS(R5); SET THE MSB OF THE FILE SIZE
	.READW	IND,INDBUF,#256.,IN$LSB(R4); READ THE CURRENT BLOCK
	BCS	60$		; ERROR READING FILE, DO THE THING
	COM	INDOPN		; SAY THE FILE IS OPEN AND READY FOR READS
	RETURN			; RETURN TO THE CALLER ALL SET

20$:	MOVB	FIRQB,R0	; WAS THERE A REAL ERROR?
	BNE	30$		; YES, PRINT THE REAL ERROR
	.PRINT	#CMOTXT		; PRINT THE OPEN ERROR MESSAGE
	BR	40$		; PRINT THE FILE NAME

30$:	CALL	FQBSCR		; SAVE THE OFFENDING FIRQB
	.ERRPRT			; PRINT THE ERROR
	.PRINT	#CMFTXT		; PRINT A SEPARATOR
	CALL	@(SP)+		; RESTORE THE OFFENDING FIRQB
40$:	CALL	PRDVPP		; PRINT THE OFFENDING FILE
50$:	CALL	TTCRLF		; JUSTIFY THE CARRIAGE
	CALL	CLSIND		; CLOSE THE CURRENT INDIRECTOR
	BR	90$		;  AND GO TO RESTART

60$:	MOV	ERRBYT,R3	; GET THE RT11 ERROR BYTE
	CALL	CLSIND		; CLOSE THE INDIRECT FILE
	TST	R3		; IS IT AN EOF ERROR?
	BEQ	90$		; YES, RESTART
	MOVB	FIRQB,R0	; IS THIS A REAL ERROR?
	BEQ	70$		; NO
	.ERRPRT			; PRINT IT
	.PRINT	#CMFTXT		; PRINT FILE NAME SEPARATOR
	BR	80$		;  AND PRINT THE FILE NAME

70$:	.PRINT	#CMRTXT		; PRINT "?Read error"
80$:	MOV	(R4)+,@SYSPTR	; SET THE PPN
.ASSUME	PPN	EQ	0	;
	MOV	R4,R0		; SET THE POINTER
	.SETFQB			; SET UP THE FIRQB
	CALL	PRDVPP		; PRINT THE ERRING FILE
	CALL	TTCRLF		; PRINT A CARRET
90$:	JMP	RESTRT		; AND RESTART

.DSABL	LSB

.SBTTL	PRINT FULL DEVICE NAME (AND MAYBE PPN AND FILENAME)

.ENABL	LSB

PRDVPP::MOV	#70$,-(SP)	; WHEN DONE, PRINT IT
CVDVPP::MOV	R1,-(SP)	; PRESERVE R1
	MOV	R5,-(SP)	; PRESERVE R5				;023
	MOV	#FNBUFF,R5	; R5 -> BUFFER FOR CONVERTING
	MOV	#FIRQB+FQDEV,R1	; R1 -> DEVICE NAME
	TST	(R1)		; ANY THERE?
	BEQ	30$		; NO
	CMP	(R1),#"DK	; IS IT THE PUBLIC STRUCTURE?
	BNE	10$		; NO, PRINT THE NAME
	TST	2(R1)		; YES, BUT IS IT A SPECIFIC DK?
	BEQ	30$		; NO, OMIT NAME ON PUBLIC STRUCTURE
10$:	MOVB	(R1)+,(R5)+	; YES, EMIT DEVICE NAME
	MOVB	(R1)+,(R5)+
	CLR	R0		; R0 = 0 FOR BISB
	BISB	(R1)+,R0	; R0 = UNIT NUMBER
	TSTB	(R1)+		; IS IT REAL?
	BEQ	20$		; NO
	CALLX	NUM$		; YES, EMIT UNIT
20$:	MOVB	#':,(R5)+	; END OF DEVICE
30$:	MOV	FIRQB+FQPPN,R1	; GET THE PPN
	BEQ	50$		; NONE
40$:	CALL	PRTPPN		; GOT IT, SO EMIT IT
50$:	MOV	#FIRQB+FQNAM1,R0 ; POINT TO THE FILE NAME
	TST	(R0)		; ANY NAME?
	BEQ	60$		; NO
	CALLX	RAD$FN		; YES, EMIT THE FILE NAME
60$:	MOVB	#200,(R5)	; SET TERMINATOR
	MOV	#FNBUFF,R0	; R0 -> MESSAGE
	MOV	(SP)+,R5	; RESTORE R5				;023
	MOV	(SP)+,R1	; RESTORE R1
	RETURN

70$:	MOV	FIRQB,-(SP)	; SAVE ERROR CODE
	.PRINT			; PRINT THE FILENAME
	MOV	(SP)+,FIRQB	; RESTORE ERROR CODE
	RETURN

.DSABL	LSB

.SBTTL	DIRECTORY LOOKUP ROUTINES

LOOKUP::MOV	#INFQB+FQNAM1,R0 ; POINT TO INPUT FILE NAME
	MOV	#WLDNAM,R5	; CONVERT TO ASCII IN WILD BUFFER
	CALLX	RAD$FN		; MAKE IT XXXXXX.EEE
	MOVB	INFQB+F$HIDX,R0	; GET THE INPUT DEVICE TYPE
	BEQ	DSKLUP		; GO LOOKUP ON DISK
	CMPB	R0,#MTAHND	; MAGTAPE?
	BEQ	MTLUP		; YES, DO THE MT THING
	JMP	DTLUP		; NO, DO THE DT THING

.SBTTL	MAGTAPE DIRECTORY LOOKUP

.ENABL	LSB

MTLUP::	MOV	#-1,PPNDEX	; SET PPN INDEX TO NON-ZERO FOR /DI ROUTINES
	CALL	MOVFQB		; COPY THE SAVED FIRQB INTO THE REAL THING
	BIT	#NORWND,SCNFLG	; DO WE AVOID THE REWIND?
	BEQ	10$		; NO, REWIND IF FIRST
	TST	INDEX		; YES.  IS THIS THE FIRST?
	BEQ	100$		; YUP, MAKE IT THE SECOND
	BNE	20$		;  ELSE KEEP THE INDEX WHERE IT IS

10$:	TST	INDEX		; IS THIS THE FIRST?
	BNE	20$		;   NO, JUST DO THE SEARCH
	TST	INFQB+F$FLG2	; IS SOMETHING WILD IN THE SPECIFICATION
.ASSUME	SCWILD	EQ	100000
	BMI	20$		;   YES, SO JUST DO THE NORMAL THING
	MOV	#-1,INDEX	;   ELSE SET INDEX TO -1 FOR REWIND NEXT LOOK
20$:	MOV	#FIRQB+FQFUN,R0	; POINT AT THE FUNCTION BYTE
	MOVB	#UU.DIR,(R0)+	; FUNCTION IS DIRECTORY
	MOV	INDEX,(R0)+	; SET THE INDEX
	MOV	#-1,(R0)+	; SET FOR SPECIAL LOOKUP ON MAGTAPE
	.PRIV,	.UUO		; DO YOUR THING RSTS
	MOVB	FIRQB,R0	; ANY ERRORS?
	BNE	ERLUPM		; YES, REPORT THE ERROR IF WE SHOULD
	MOV	FIRQB+26,R3	; GET THE PPN FROM THE TAPE
	BNE	30$		; NON-ZERO IS NOT ANSI
	BIS	#ANSIMT,INFQB+F$FLAG ; FLAG AN ANSI TAPE
30$:	MOV	#FIRQB+FQNAM1,R0 ; POINT AT NAME
	MOV	R3,FIRQB+FQPPN	; FIX THE PPN IN THE FIRQB
	BEQ	60$		; NONE ALWAYS MATCHES
	MOV	WLDPPN,R5	; GET THE PPN HE NAMED
	BNE	40$		; IF HE NAMED ONE, USE IT
	MOV	OURPPN,R5	;  ELSE MATCH AGAINST OUR OWN PPN
40$:	CMPB	R5,R3		; PROGRAMMER MATCH?
	BEQ	50$		; YES
	INCB	R5		; NO, BUT WILD PROGRAMMER REQUESTED?
	BNE	70$		; NO WILD, NO MATCH, SKIP THIS FILE
50$:	SWAB	R5		; GET REQUESTED PROJECT
	SWAB	R3		;  AND ACTUAL PROJECT
	CMPB	R5,R3		; MATCH?
	BEQ	60$		; YES, WE MAY HAVE A WINNER
	INCB	R5		; NO, BUT IS THE REQUESTED PROJECT WILD?
	BNE	70$		; NOPE, SKIP THIS ONE
60$:	CALL	WLDTST		; CHECK FOR A WILDCARD MATCH
	BNE	70$		; IF NO MATCH, STOP IF /H OR CONTINUE
	CALL	INSPEC		; MATCH, TRY FOR /I VERIFICATION
	BNE	90$		; NO MATCH, SKIP IT
	;CLC			; C=0 FROM INSPEC CALL
	MOV	FIRQB+FQPPN,INFQB+FQPPN	; MATCH! FORCE USE OF THE REAL PPN
	JMP	LUPEND		; END THIS SEARCH			;073

70$:	TST	GOTANY		; DOES WE GOT ANY?
	BEQ	80$		; NOPE, WE HAVE TO KEEP SEARCHING THEN
	BIT	#STOPMS,SCNFLG	; STOP MT SCAN ON NOMATCH?
	BNE	LUPNON		; YES, GO AWAY
80$:	CMP	INDEX,#-1	; IS THE INDEX -1? (SINGLE FILE KLUDGE)
	BEQ	100$		; YES, INC INDEX TO ZERO (FORCE REWIND)
90$:	MOV	#FIRQB+FQFUN,R0	; POINT TO THE FUNCTION
	MOVB	#UU.DIR,(R0)+	; DO A REGULAR LOOKUP
	INC	(R0)+		; AVOID REDUNDANT REWIND
	CLR	(R0)+		; MATCH ANY PPN
	.PRIV,	.UUO		; THIS IS A KLUDGE TO SKIP THE FILE WITHOUT
	MOVB	FIRQB,R0	; ANY ERRORS?
	BNE	ERRLUP		; YES, REPORT THE ERROR
100$:	INC	INDEX		; ON TO THE NEXT FILE
	BR	20$		; HAVING TO  OPEN THE MT

ERLUPM::CMP	INDEX,#-1	; IS THIS -1 INDEX => SINGLE FILE LUP KLUDGE
	BNE	ERRLUP		; NO, REPORT THE ERROR
	CHKERR	NOSUCH		; IS THE ERROR NOSUCH?
	BEQ	100$		; YES, WE ARE AT EOT AND SHOULD REWIND
	BR	ERRLUP		; NO, A REAL ERROR

.DSABL	LSB

.SBTTL	DISK LOOKUP

.ENABL	LSB

10$:	CALL	ONXLOK		; Call the UU.LOK emulation routine	;040
	MOV	#FIRQB+22,R0	; POINT TO DATE/TIME INFO
	MOV	(R0)+,DATELA	; SAVE DATE OF LAST ACCESS
	MOV	(R0)+,DATECR	; SAVE DATE OF CREATION
	MOV	(R0)+,TIMECR	; SAVE TIME OF CREATION
	CALL	INSPEC		; INSPECT THE FILE NAME/DATE IF REQUIRED
	BEQ	LUPEND		; EVERYTHING MATCHES, GO RETURN C=0
	INC	INDEX		; ADVANCE TO NEXT FILE
DSKLUP::TST	INDEX		; Check out the index being passed	;040
	BNE	15$		; Non-zero means this is a "next"	;040
	TST	CP2SEF		; Are we doing a copy to same account	;041
	BEQ	14$		; No, skip the initialize		;041
	CALL	INIMSK		; Initialize the File ID bit mask	;041
14$:	.CLRFQB			; RT11 is ignorant of this channel	;040
	MOVB	#CLSFQ,FIRQB+FQFUN ; Set CLOSE function			;040
	MOVB	#ONX*2,FIRQB+FQFIL ; for the Open Next channel		;040
	.PRIV,	CALFIP		; Do this, RSTS				;040
15$:	CALL	MOVFQB		; SET UP THE REAL FIRQB			;040
	MOVB	#UU.ONX,FIRQB+FQFUN ; Set Open Next function		;040
	MOVB	#ONX*2,FIRQB+FQFIL ; Specify the channel number		;040
	MOV	#130020,FIRQB+FQMODE ; Allow no r/w access (lookup)	;073
	BIT	#MDFILS,SC2FLG	; Do they Marked for Delete files?	;073
	BEQ	17$		; NO, so just go do it			;073
	BIS	#40000,FIRQB+FQMODE ; Yes, so get MDL files also	;073
17$:	.PRIV,	.UUO		;  GO GET THE FILE RSTS!
	MOVB	FIRQB,R0	; CHECK FOR ERRORS
	BEQ	10$		; NO ERROR, SEE IF FILE MATCHES ALL RESPECTS

ERRLUP::CHKERR	NOSUCH		; WAS IT REALLY "CAN'T FIND FILE"
	BNE	20$		;  NOT NOSUCH, REPORT HARD ERROR
	TSTB	INFQB+F$HIDX	; IS THIS A DISK DEVICE?
.ASSUME	DSKHND	EQ	0
	BNE	LUPNON		; NO, SO CONTINUE
	BIT	#S$PPNG!S$PPNJ,INFQB+F$SFLG ; IS ANY PART OF PPN WILD?
	BEQ	LUPNON		; NO, SO NO SPECIAL PPN LOOK UP NEEDED
	CALL	MOVFQB		; SET UP THE FIRQB
	MOV	WLDPPN,FIRQB+FQPPN ; SET UP WILD CARD PPN SPEC
	MOVB	#UU.PPN,FIRQB+FQFUN ; SET THE UUO FUNCTION CODE
	MOV	PPNDEX,FIRQB+FQFIL ; SET THE PPN INDEX
	INC	PPNDEX		; INCREMENT THE PPN INDEX FOR NEXT TIME
	CLR	INDEX		; AND CLEAR THE FILE INDEX
	.PRIV,	.UUO		; ASK RSTS FOR A PPN
	MOV	FIRQB+FQPPN,INFQB+FQPPN ; SAVE THE PPN RETURNED
	MOV	FIRQB,R0	; GET THE ERROR CODE
	BEQ	DSKLUP		; DO THE DISK LOOKUP IF RSTS DIDN'T BURP
	CHKERR	NOSUCH		; WAS THIS THE END OFF PPN'S?
	BEQ	LUPNON		; YES
20$:	CALL	ERCNT2		; Print the error - file - continuing
	INC	GOTANY		; AND AVOID THE 'NO FILES MATCHING' ERR
LUPNON::SEC			; INDICATE FAILURE RETURN
LUPEND::RETURN			; AND GO BACK

.SBTTL	ONXLOK	- Emulate UU.LOK for directory lookups

;+
; Provide UU.LOK emulation by taking the returned data from UU.ONX,
; and moving it around to look like UU.LOK returned the data.
; Unfortunately, UU.ONX returns everything UU.LOK does EXCEPT the USTAT
; byte.  So, a UU.FCB directive will be issued to pick it up.
;
; Note that UU.FCB also returns the number of users with the file
; open read-regardless as well as the number with it open non-RR.  
; This is stored in INOCNT for later use by directory operations	;073
;-

ONXLOK::MOV	R1,-(SP)	; Scratch				;040
	MOV	R2,-(SP)	;    "					;040
	TST	CP2SEF		; Are we doing a copy to same account	;041
	BEQ	25$		; No, skip this stuff			;041
	MOV	FIRQB+FQCLUS,R0	; Pick up the File ID			;041
	ASH	#-4,R0		; Shift out the flag bits		;041
	BIC	#^C<7777>,R0	; Isolate the 12 remaining bits		;041
	MOV	R0,R1		; Copy it				;041
	ASH	#-3,R0		; Compute the byte offset into table	;041
	BIC	#^C<7>,R1	; Get the bit within the byte desired	;041
	BITB	BITBYT(R1),BITMSK(R0) ; Is the bit already set?		;041
	BEQ	25$		; Nope, continue			;041
	MOV	(SP)+,R2	; Hmmm.  Seems we've been here before..	;041
	MOV	(SP)+,R1	; Restore the scratch registers,	;041
	TST	(SP)+		;  toss the return PC,			;041
	BR	LUPNON		;   and say we're done!			;041

25$:	MOV	#FIRQB,R0	; Point to the FIRQB			;040
	MOV	#ONXFQB,R1	;  and the ONX save area		;040
	MOV	#FQBUFL/2,R2	; Move everything before offset FQBUFL	;040
30$:	MOV	(R0)+,(R1)+	; Move a word				;040
	SOB	R2,30$		;  until done				;040

	MOVB	FIRQB+FQPROT,(R1)+ ; Protection code goes here		;040
	MOVB	FIRQB+FQSIZM,(R1)+ ; Follow that with the size MSB	;040
	MOV	(R0)+,(R1)+	; Copy the last access date		;040
	MOV	(R0)+,(R1)+	; Copy the creation date		;040
	MOV	(R0)+,(R1)+	;  and the creation time		;040
	MOV	(R0)+,4(R1)	; Move the clustersize to FQCLUS offset	;040
	CLRB	5(R1)		; I really meant ONLY the clustersize	;040
	DECB	4(R1)		; make 0 into 255.			;073
	INC	4(R1)		; make 255. into 256.			;073
	.CLRFQB			; Clear the FIRQB			;040
	MOVB	#UU.FCB,FIRQB+FQFUN ; This time, get FCB info		;040
	MOV	#<1*400>+ONX,FIRQB+FQFIL ; Channel and function		;040
	.PRIV, .UUO		; Get me that FCB info!			;040
	TSTB	FIRQB		; Any errors???				;040
	BEQ	40$		;  Nope, that's good			;040
	MOV	(SP)+,R2	; What?!  An error?!  			;040
	MOV	(SP)+,R1	; Restore the scratch registers,	;040
	TST	(SP)+		;  toss the return PC,			;040
	BR	20$		;   and go report the error		;040

40$:	MOVB	#8.,ONXFQB+FQNENT ; Say that 8 entries were returned	;040
	MOV	FIRQB+FQFIL,INOCNT ; Save the open count just in case	;073
	MOVB	FIRQB+FQPPN,ONXFQB+FQNENT+1 ; Store the USTAT byte	;040
	MOV	INDEX,ONXFQB+FQFIL ; Pretend the index was passed	;040
	MOV	INFQB+FQDEV,ONXFQB+FQDEV ; Return the device info	;040
	MOV	INFQB+FQDEVN,ONXFQB+FQDEVN ; as it was passed		;040
	MOV	#ONXFQB,R0	; Point to the built FIRQB clone	;040
	MOV	#FIRQB,R1	;  and to the real thing		;040
	MOV	#FQBSIZ/2,R2	; Set the number of words to move	;040
50$:	MOV	(R0)+,(R1)+	; Copy a word				;040
	SOB	R2,50$		;  until the whole FIRQB is done	;040
	MOV	(SP)+,R2	; Restore				;040
	MOV	(SP)+,R1	;  the scratch registers		;040
	RETURN			; Now go back with a silly grin  ;^)	;040

.DSABL	LSB

.SBTTL	DECTAPE DIRECTORY LOOKUP

.ENABL	LSB

DTLUP::	CALL	MOVFQB		; MOVE THE FIRQB INTO PLACE
10$:	MOVB	#UU.DIR,FIRQB+FQFUN ; SET DIRECTORY LOOKUP FUNCTION
	MOV	INDEX,FIRQB+FQFIL ; AND THE INDEX VALUE
	.PRIV,	.UUO		; CALL RSTS FOR THIS
	MOVB	FIRQB,R0	; ARE THERE ANY ERRORS?
	BEQ	15$		; No, continue				;041
	JMP	ERRLUP		;  Yes, see what it was			;041
15$:	MOV	#FIRQB+FQNAM1,R0 ; Get filename from here		;041
	CALL	WLDTST		; CHECK FOR A MATCH
	BNE	20$		; NO MATCH THIS TIME
	CALL	INSPEC		; CHECK FOR /I
	BEQ	LUPEND		; AOK, USE THIS FILE
20$:	INC	INDEX		; FAILURE - GO GET NEXT FILE
	BR	10$

.DSABL	LSB

.SBTTL	Initialize the File ID bit mask

;+
;	CALL	INIMSK
;
;	R0 undefined
;-

.ENABL	LSB

INIMSK::MOV	R1,-(SP)	; Save a register			;041
	MOV	#BITMSK,R0	; Pick up the address of the File ID	;041
				;  bit mask				;041
	MOV	#MSKSIZ,R1	; Get its size (in words)		;041
10$:	CLR	(R0)+		; Zap a word				;041
	SOB	R1,10$		;  'till done				;041
	MOV	(SP)+,R1	; Restore				;041
	RETURN			; to sender...				;041

.DSABL	LSB

.SBTTL	FIRQB MOVER

;+
; MOVFQB - MOVE THE INPUT FIRQB TO THE FIRQB
;
;	CALL	MOVFQB
;
;	FIRQB <- INFQB
;-

.ENABL	LSB

MOVFQB::REGSCR			; SAVE ALL REGISTERS
	MOV	#INFQB,R0	; "FROM" LOCATION
	MOV	#FIRQB,R1	; "TO" LOCATION
	MOV	#FQBSIZ/2,R2	; THIS MANY WORDS TO MOVE
10$:	MOV	(R0)+,(R1)+	; MOVE A WORD
	SOB	R2,10$
	RETURN

.DSABL	LSB

.SBTTL	SAVE FIRQB COROUTINE

;+
; FQBSCR - COROUTINE TO SAVE AND RESTORE THE FIRQB
;
;	CALL	FQBSCR
;
;-

.ENABL	LSB

FQBSCR::MOV	R0,-(SP)	; SAVE R0
	MOV	R1,-(SP)	; SAVE R1
	MOV	R2,-(SP)	; SAVE R2
	MOV	#FIRQB,R0	; @ FIRQB
	MOV	#TMPFQB,R1	; @ TMPFQB
	MOV	#FQBSIZ/2,R2	; # WORDS TO SAVE
10$:	MOV	(R0)+,(R1)+	; SAVE THE FIRQB
	SOB	R2,10$		; UNTIL DONE
	MOV	(SP)+,R2	; RESTORE R2
	MOV	(SP)+,R1	; RESTORE R1
	MOV	(SP)+,R0	; RESTORE R0
	CALL	@(SP)+		; CALL CALLER AS COROUTINE

	MOV	R0,-(SP)	; SAVE R0
	MOV	R1,-(SP)	; SAVE R1
	MOV	R2,-(SP)	; SAVE R2
	MOV	#FIRQB,R0	; @FIRQB
	MOVB	(R0),-(SP)	; SAVE THE CURRENT ERROR CODE
	MOV	#TMPFQB,R1	; @TMPFQB
	MOV	#FQBSIZ/2,R2	; # WORDS TO RESTORE
20$:	MOV	(R1)+,(R0)+	; RESTORE THE FIRQB
	SOB	R2,20$		; UNTIL DONE
	MOVB	(SP)+,FIRQB	; RESTORE THE CURRENT ERROR CODE
	MOV	(SP)+,R2	; RESTORE R2
	MOV	(SP)+,R1	; RESTORE R1
	MOV	(SP)+,R0	; RESTORE R0
	RETURN			; FINALLY RETURN

.DSABL	LSB

.SBTTL	DO DATE AND USER INSPECTION FOR LOOKUP

.ENABL	LSB

INSPEC::MOV	FIRQB+22,R0	; GET FILE LAST ACCESS OR TAPE CREATION DATE
	CMPB	FIRQB+FQNENT,#8. ; IS IT A DISK?
	BEQ	10$		; YES, SKIP THE TAPE ADJUSTMENT
	MOV	R0,FIRQB+24	; NO, SET THE DATE IN PROPER PLACE FOR TAPES
10$:	BIT	#CREATE,SC2FLG	; IS THIS USE CREATION DATE?
	BNE	20$		; YES, USE THE CREATION DATE
	BIT	#DLA,SC2FLG	; ARE WE SUPPOSED TO USE DATE OF LAST ACCESS?
	BNE	30$		; YES, SO USE CURRENT R0
..DLAC	==	.-2	;**PATCH** CHANGE TO Q&377+BR TO CHANGE TO DLA DEFAULT
	; **NOTE** that the contents of optional patches are referenced
	;	   at ONETIM: -- changes here mean changes there.
20$:	MOV	FIRQB+24,R0	; NO, GET DISK CREATION DATE (TAPE CREATION)
30$:	CMP	R0,LODATE	; BELOW START DATE?
	BHIS	31$		; NO, CONTINUE				;032
	JMP	90$		; YES, RETURN NE			;032

31$:	CMP	HIDATE,R0	; ABOVE END DATE?			;032
	BHIS	32$		; NO, CONTINUE				;032
	JMP	90$		; YES, RETURN NE			;032

32$:	CMPB	FIRQB+FQNENT,#8. ; IS IT A DISK?			;032
	BNE	40$		; NO, SKIP THE SELECT-BY-FILESIZE	;032
	TSTB	SCNFLG		; ARE WE DOING DIRECTORIES		;032
.ASSUME	DIRECT	EQ	200	; ENSURE THE DIRECTORY BIT IS AS EXPECTED;032
	BPL	34$		; NO, SKIP ALLOCATION ADJUSTMENT	;032
	BIT	SWITCH,#DIR.AL	; ARE WE PRINTING ALLOCATIONS?		;032
	BNE	33$		; YES, GO FIGURE THE ALLOCATED SIZE	;032
	BIT	SWTTBL,#DIR.AL	; LOOK AT THE OUTPUT SIDE'S SWITCH TBL	;032
	BEQ	34$		; NOT THERE, NO READJUSTMENT NEEDED	;032
33$:	MOV	FIRQB+16,R0	; YES, GET THE LSB SIZE			;032
	MOVB	FIRQB+21,R1	;  AND MSB SIZE				;032
	MOV	FIRQB+34,R3	; GET CLUSTER SIZE			;032
	DEC	R3		; SUBTRACT ONE				;032
	ADD	R3,R0		; ADD INTO SIZE				;032
	ADC	R1		;   HIGH WORD ALSO			;032
	BIC	R3,R0		; NOW ADJUST FOR AN EVEN CLUSTER	;032
	MOV	R0,FIRQB+16	; PUT THE LSB BACK			;032
	MOVB	R1,FIRQB+21	; AND PUT THE MSB BACK			;032
34$:	CMPB	FIRQB+21,LOSIZM	; BELOW REQUESTED FILESIZE MSB?		;032
	BLO	90$		; YES, RETURN NE			;032
	BHI	35$		; IT'S HIGHER, GO CHECK THE HIGH LIMIT	;032
	CMP	FIRQB+16,LOSIZL	; BELOW REQUESTED FILESIZE LSB?		;032
	BLO	90$		; YES, RETURN NE			;032
35$:	CMPB	HISIZM,FIRQB+21	; ABOVE REQUESTED FILESIZE MSB?		;032
	BLO	90$		; YES, RETURN NE			;032
	BHI	40$		; IT'S HIGHER, CONTINUE			;032
	CMP	HISIZL,FIRQB+16	; ABOVE REQUESTED FILESIZE LSB?		;032
	BLO	90$		; YES, RETURN NE			;032
40$:	CLC			; ENSURE THE C BIT IS CLEAR		;032
	BIT	#INSPCT,SCNFLG	; DOES HE WANT TO INSPECT EXPANSION?
	BEQ	90$		; NO, RETURN EQ
	CALL	LMARGN		; GO TO LEFT MARGIN
	CALL	PRDVPP		; PRINT THE THING
	TSTB	SC2FLG		; WAS A LONG LISTING DESIRED?
.ASSUME	INCOLS	EQ	200
	BPL	80$		; NOPE
	REGSAV			; YES, SAVE THE REGS
	MOV	#DIRBUF,R5	; GET A POINTER TO A BUFFER
	MOV	#400*SPACE+SPACE,R4 ;A HANDY VALUE (TWO SPACES)
	CMPB	#MTAHND,INFQB+F$HIDX ; IS THE INPUT A MAGTAPE?
	BEQ	50$		; YES, SKIP FISIZE, PROT, AND ACCESS
	MOV	R4,(R5)+	; SEPARATE WITH SPACES
	MOV	FIRQB+16,R0	; GET THE FILE SIZE
	MOVB	FIRQB+21,R1	;  AND MSB OF FILESIZE
	DECDBL	8.		; OUTPUT A DECIMAL NUMBER
	MOVB	R4,(R5)+	; PAD WITH A SPACE
	MOVB	#'<,(R5)+	; OPEN ANGLE BRACKET FOR PROTECTION CODE
	CLR	R0		; CLEAR R0 FOR A BIS
	BISB	FIRQB+20,R0	; GET THE PROTECTION CODE
	DECNUM	3.		; OUTPUT A DECIMAL NUMBER
	MOVB	#'>,(R5)+	; OUTPUT THE CLOSING BRACKET
	CALL	CVTDAT,R1,FIRQB+22; OUTPUT THE ACCESS DATE

50$:	CALL	CVTDAT,R1,FIRQB+24; OUTPUT THE CREATION DATE
	TSTB	INFQB+F$HIDX	; IS THE INPUT FROM DISK?
	BNE	70$		; NO, SO DON'T PRINT THE RTS NAME
	TST	FIRQB+FQNENT	; Is this file real?			;073
	.ASSUME	US.DEL	EQ	200					;073
	BMI	70$		;  NO, it's deleted			;073
	CALL	FQBSCR		; SAVE OUR FIRQB
	CALL	GETATR		; GET THE ATTRIBUTES FOR THIS FILE
	TSTB	FIRQB		; WAS THERE AN ERROR?
	BEQ	60$		; NOPE, CONTINUE
	CALL	@(SP)+		; RESTORE THE FIRQB
	CALL	ERCNT1		; SAY WE HAVE AN ERROR
	REGRES			; RESTORE ALL THE REGISTERS
	CLZ			; CLEAR THE Z-BIT (NO APPROVAL).
	RETURN			;   AND RETURN TO OUR CALLER

60$:	MOV	#FIRQB+34,R0	; GET A POINTER TO THE RTS NAME
	MOVB	R4,(R5)+	; SET A SPACE IN THE BUFFER
	CALLX	RAD$W2		; MAKE IT ASCII
	CALL	@(SP)+		; RESTORE THE OLD FIRQB
70$:	MOVB	#200,(R5)	;  AND SET A STOPPER FOR THE PRINT
	REGRES			; RESTORE ALL THE REGISTERS
	.PRINT	#DIRBUF		; PRINT THE AUXILIARY INFORMATION
80$:	.PRINT	#QMARK		; PRINT A QUESTION MARK
	INC	GOTANY		; AVOID "?CAN'T FIND" ERROR WITH /INSPECT
GETANS::MOV	R5,-(SP)	; SAVE R5
	CALLX	INPUTX,R5,<83.,DIRBUF> ; GET THE INPUT
	BVS	100$		; IF AN ERROR OCCURRED ASSUME EOF
	MOV	(SP)+,R5	; RESTORE R5
	BICB	#40,DIRBUF	; MAKE THE FIRST CHARACTER UPPER CASE
	CMPB	DIRBUF,#'Y	; DID HE SAY YES?
90$:	RETURN			; RETURN WITH A Z=1 OR 0 FOR YES OR NO

100$:	JMP	RESTRT		; ^Z ANSWER, RESTART PIP

.DSABL	LSB

.SBTTL	GET ATTRIBUTES AND RTS NAME FOR FILE IN FIRQB

;+
; GETATR - USE UU.FIL TO OBTAIN ATTRIBUTE INFO FROM DIRECTORY
;
;	FIRQB loaded with file spec to get attributes for
;
;	CALL	GETATR
;
;	FIRQB CONTAINS INFO OR ERROR CODE
;
;-

GETATR::MOV	R0,-(SP)	; SAVE R0
	MOV	#FIRQB+FQFUN,R0	; GET A POINTER TO THE FIRQB
	MOVB	#UU.FIL,(R0)+	; SET THE FUNCTION CODE
	MOV	#<20*400>!ONX,(R0)+ ; RETURN ATTRIBUTES AND DCN INFORMATION ;073
	MOV	#1,FIRQB+16	; SET LSB OF DCN TO RETRIEVE
	CLR	FIRQB+20	; CLEAR MSB OF DCN and flags
	CLR	FIRQB+34	; CLEAR THE EXTENDED ALLOCATION FLAGS	;016
	CLR	FIRQB+36	; CLEAR THE EXTENDED ALLOCATION FLAGS	;016
	MOV	#JFSYS,XRB	; SET TO GAIN PRIVS
	.PRIV,	.SET		; SET  THE TEMP PRIVS (GAIN 'EM IF YA GOT 'EM)
	.PRIV,	.UUO		; GET THE ATTRIBUTES
	MOVB	FIRQB,-(SP)	; SAVE ANY ERROR CODE
	MOV	#JFSYS,XRB	; SET TO DROP PRIVS
	.PRIV,	.CLEAR		; DROP 'EM, BUSTER
	MOVB	(SP)+,FIRQB	; RESET ANY ERROR CODE
	MOV	(SP)+,R0	; RESTORE R0
	RETURN			;  AND RETURN TO OUR CALLER.

.SBTTL	BUFFER MANAGEMENT EXPLAINATION

;+
; WHEN PIP IS INITIATED IT HAS ONE LARGE BUFFER.   THE  BUFFER
; EXTENDS FROM THE CSECT INICOR, THE TOP OF THE PROGRAM,TO THE
; START OF THE RT11 R/W CONTEXT SAVE AREA.
; 
; FOR NORMAL XFERS BETWEEN DISKS AND/OR MAGTAPES THE  REQUIRED
; BUFFER SPACE IS ONLY 1 K BYTE.  FOR XFERS INVOLVING DECTAPES
; OR LARGE BLOCKSIZES ON MAGTAPES MORE SPACE IS REQUIRED.
; 
; IN ORDER TO PROCESS INDIRECT COMMAND FILES PIP NEEDS  BUFFER
; AND  CONTEXT SAVE SPACE, SINCE PIP WILL ALLOW ANY NUMBER (AS
; LONG AS BUFFER SPACE HOLDS  OUT  -  ABOUT  2340)  OF  NESTED
; INDIRECT  COMMAND  FILES THIS SPACE IS ALLOCATED DYNAMICALLY
; FROM THE MAIN BUFFER.
; 
; WHEN BUFFER SPACE IS REQUESTED PIP  MAKES  SURE  THAT  THERE
; WILL  BE  AT  LEAST 1K BYTE OF BUFFER SPACE LEFT IN THE MAIN
; BUFFER.  IF THERE IS SUFFICIENT BUFFER SPACE  AVAILABLE  PIP
; WILL ALLOCATE THE BUFFER FROM THE BOTTOM UP.
; 
; BUFFER SPACE MUST BE RETURNED IN EXACTLY THE SAME  ORDER  AS
; IT WAS TAKEN TO PREVENT A FRAGMENTED BUFFER.  IF A BUFFER IS
; RETURNED OUT  OF  SEQUENCE  A  NASTY  ERROR  OCCURS,  DURING
; ERROR-FREE EXECUTION OF PIP THIS IS ALWAYS THE CASE.  IF THE
; ERROR EVER OCCURS  SOMETHING  IS  MUCKED  UP,  PROBABLY  THE
; NESTED RETURN ADDRESSES ON THE STACK.
; 
; ANOTHER RESTRICTION IN THE  BUFFER  ALLOCATION  IS  THAT  NO
; REQUEST  FOR  BUFFER SPACE MAY BE MADE WHILE THE MAIN BUFFER
; IS IN USE.  THE REASON FOR THIS IS THAT IT IS NOT NEEDED AND
; THEREFORE  THE  EFFORT  WAS  NOT  MADE  TO  MAKE  THE BUFFER
; MANAGEMENT INTELLIGENT.
; 
; THE MAIN USE FOR THESE ROUTINES IS TO  DYNAMICALLY  ALLOCATE
; SPACE  FOR PROCESSING INDIRECT COMMAND FILES (WHICH IS NEVER
; DONE DURING A TRANSFER  OPERATION).   FOR  THIS  REASON  THE
; FOLLOWING WARNING APPEARS:
; 
; ************************* WARNING **************************
; 
; THE BUFFER ALLOCATOR IS EXTREMELY STUPID.  IF YOU USE IT FOR
; ANYTHING  OTHER  THAN INDIRECT FILE PROCESSING YOU SHOULD BE
; SURE YOU FULLY UNDERSTAND THE STATE OF THE  MAIN  BUFFER  AT
; THE TIME OF THE REQUEST!!!!!
; 
; ************************* WARNING **************************
;-

.SBTTL	BUFFER MANAGEMENT ROUTINES
.SBTTL	ALLOCATE BUFFER SPACE

;+
; GETBFX - ALLOCATE A BUFFER, THE LENGTH DESIRED IS POINTED TO BY R5
; GETBUF - ALLOCATE A BUFFER, THE LENGTH DESIRED IS IN R0
;
;	GETBUF	SIZE
;	GETBUF		(SIZE IN R0 AT TIME OF CALL)
;
;	R0 =  SIZE OF BUFFER RETURNED (SAME AS PASSED)
;	R1 -> BUFFER
;
;	C BIT IS SET IF NO BUFFER SPACE IS AVAILABLE
;-

.ENABL	LSB

GETBFX::MOV	(R5)+,R0	; GET DESIRED SIZE
GETBUF::MOV	BUFFER,R1	; GET POINTER TO MAIN BUFFER
	ADD	R0,BUFFER	; BUMP MAIN BUFFER POINTER
	SUB	R0,BUFSIZ	; TAKE AWAY THE APPROPRIATE AMOUNT
	BLO	10$		; NO BUFFER SPACE AVAILABLE
	CMP	BUFSIZ,#512.*2	; IS THERE AT LEAST 1K BYTES LEFT
	BLO	10$		; NO, CAN'T ALLOCATE BUFFER SPACE
	RETURN	R5		; HAVE THE BUFFER, C=0 FROM ABOVE

10$:	SUB	R0,BUFFER	; PUT THE MAIN BUFFER POINTER BACK
	ADD	R0,BUFSIZ	;   AND GIVE IT ALL ITS BYTES
	SEC			; SET CARRY FOR ERROR RETURN
	RETURN	R5		;  AND RETURN WITH ERROR

.DSABL	LSB

.SBTTL	DEALLOCATE BUFFER SPACE

;+
; RETBFX - DEALLOCATE A BUFFER, THE LENGTH IS POINTED TO BY R5
; RETBUF - DEALLOCATE A BUFFER, THE LENGTH IS IN R0
;
;	R1 = ADDRESS OF BUFFER SPACE TO RETURN
;
;	RETBUF	SIZE
;	RETBUF		(SIZE IS IN R0)
;
;	R0	DESTROYED
;	R1	DESTROYED
;
;	IF AN ERROR OCCURS EXECUTION DOES NOT RETURN TO CALLER.
;-

.ENABL	LSB

RETBFX::MOV	(R5)+,R0	; GET RETURN BUFFER SIZE
RETBUF::SUB	R0,BUFFER	; ADJUST THE MAIN BUFFER POINTER BACK
	CMP	BUFFER,INIBUF	; ARE WE RETURNING MORE THAN POSSIBLE
	BLO	10$		; YES, THAT IS AN ERROR
	CMP	R1,BUFFER	; IS THIS THE RIGHT BUFFER TO RETURN
	BNE	20$		; NO, PHASE ERROR
	ADD	R0,BUFSIZ	; RETURN ALL BYTES TO THE BUFFER
	RETURN	R5		; AND RETURN, THERE SHOULD BE NO CARRY

10$:	POINTX	<?Buffer underflow>
	BR	30$		; MERGE TO COMMON ERROR PLACE

20$:	POINTX	<?Buffer phase error>
30$:	.PRINT			; PRINT THE ERROR
	CALL	ZAPIND		; RESET THE WORLD
	JMP	RESTRT		;  AND RESTART THE WORLD

.DSABL	LSB

.SBTTL	WILD NAME MATCH CHECKER

;+
; WLDTST - CHECK REAL NAME AGAINST WILD CARD SPEC
;
;	R0 -> NAME.EXT IN RAD50
;	WLDNAM = WILD CARD NAME (NNNNNN.EEE) IN ASCII
;
;	CALL	WLDTST
;
;	R0,R3,R5 = RANDOM
;	Z=1 IF NAME MATCHES
;-

.ENABL	LSB

WLDTST::MOV	#NAME,R5	; POINT TO WHERE FILENAME GOES
	CALLX	RAD$FN		; CALL THE RAD50 FILENAME CONVERTER
	MOV	#WLDNAM+10.,R3	; THE END OF THE PROTOTYPE FILENAME
	MOV	#6+1+3,R0	; LENGTH OF THE FILENAME
10$:	CMPB	-(R3),-(R5)	; MATCH HERE?
	BEQ	20$		; YEP
	CMPB	(R3),#'?	; NO, BUT IS THERE A ? IN THE  PROTOTYPE?
	BNE	30$		; NO, SO FAIL
20$:	SOB	R0,10$		; CONTINUE TILL ALL CHECKED OUT
	;SEZ			; Z=1 FROM COMPARISONS
30$:	RETURN	

.SBTTL	RSTS ERROR MESSAGE PRINTER

RSTSEF::MOV	FIRQB,-(SP)	; GOTTA SET UP FOR FILE. SAVE ERROR
	MOV	@(R1)+,R0	; R0 -> SPEC FOR FAILING FILE
	.SETFQB			; SET UP FIRQB WITH FAILING NAME
	MOV	(SP)+,FIRQB	; RESTORE THE ERROR
RSTSER::CALL	LMARGN		; GO TO LEFT MARGIN
	MOV	(R1)+,R0	; GET DEFAULT TEXT POINTER
	TSTB	FIRQB		; CHECK THE ERROR CODE
	BEQ	40$		; NO CODE, USE DEFAULT TEXT
	CALL	ERRFQB		; SET THE FIRQB, PRINT THE ERROR
	MOV	#CRLF,R0	; AND A NEW LINE
40$:	.PRINT			; AND PRINT THE BAD FILENAME
	JMP	RESTRT		; RESTART FROM SCRATCH

.DSABL	LSB

.SBTTL	PRINT IF POS(0)

.ENABL	LSB

WARN::	MOV	R0,-(SP)	; SAVE R0
	MOVB	FIRQB,-(SP)	; SAVE THE FIRQB
	CALL	LMARGN		; FOR WARNINGS, RESTORE THE CARRIAGE
	.TTYOUT	#'%		; PRINT OUT THE WARNING INDICATOR
	.PRINT	(R5)+		; PRINT THE ERROR
	MOVB	(SP)+,FIRQB	; RESTORE THE FIRQB
	MOV	(SP)+,R0	; RESTORE R0
	RETURN	R5		; DONE

WARNF::	MOV	R0,-(SP)	; SAVE R0
	MOVB	FIRQB,-(SP)	; SAVE THE FIRQB
	CALL	LMARGN		; FOR WARNINGS, RESTORE THE CARRIAGE
	.TTYOUT	#'%		; PRINT OUT THE WARNING INDICATOR
	.PRINT	(R5)+		; PRINT THE ERROR
	PRINT	< - file >,NOCR	; Tell 'em where the error was:		;056
	MOV	INFQB+FQPPN,@SYSPTR; SET THE PROPER PPN			;056
.ASSUME	PPN	EQ	0	;					;056
	MOV	PTRIN,R0	; GET THE FILE SPEC POINTER		;056
	.SETFQB			; SETUP THE FIRQB			;056
	CALL	PRDVPP		; Print the file name			;056
	CALL	LMARGN		; Give us a new line			;056
	MOVB	(SP)+,FIRQB	; RESTORE THE FIRQB			;056
	MOV	(SP)+,R0	; RESTORE R0				;056
	RETURN	R5		; DONE

ERRCHK::TSTB	FIRQB		; GET THE ERROR CODE
	BEQ	20$		; NONE, RETURN
	MOV	#FIRQB,R5	; DO THE ERROR
ERRPRT::CALL	LMARGN		; FOR RSTS/E ERRORS, RESTORE THE CARRIAGE
	MOV	(R5),R0		; GET RSTS/E ERROR CODE
	.ERRPRT			; PRINT IT
	MOV	#RESTRT,(SP)	; RESTORE THE CARRIAGE AND QUIT THE OPERATION
LMARGN::MOV	FIRQB,-(SP)	; SAVE ANY ERROR CODE
	.RCTRLO			; SPEAK
	CLRB	XRB+XRCI	; CHANNEL 0 IS THE TERMINAL
	.PRIV,	.POSTN		; GET THE POSITION
	TST	XRB+2		; ALREADY THERE?
	BEQ	10$		; YES, GO AWAY
	CALL	TTCRLF		; NEW LINE
10$:	MOV	(SP)+,FIRQB	; RESTORE ANY ERROR CODE
20$:	RETURN

BLANKL::CALL	LMARGN		; MAKE SURE THE CARRIAGE IS LEFT JUSTIFIED
	.BR	TTCRLF		;  AND CONTINUE THROUGH THE TTCRLF ROUTINE

TTCRLF::MOV	R0,-(SP)	; SAVE R0
	MOVB	FIRQB,-(SP)	; SAVE THE FIRQB
	.PRINT	#CRLF		; PRINT NULLNESS
	MOVB	(SP)+,FIRQB	; RESTORE THE FIRBQ
	MOV	(SP)+,R0	; RESTORE R0
	RETURN

PRNTXT::CALL	BLANKL		; BLANK A LINE
	MOV	R0,-(SP)	; SAVE R0
	MOV	FIRQB,-(SP)	;  AND FIRQB
	.PRINT	(R5)+		; PRINT THE TEXT
	MOV	(SP)+,FIRQB	; RESTORE THE FIRQB
	MOV	(SP)+,R0	;  AND FIRQB
	RETURN	R5		;   FINALLY RETURN THROUGH R5

.DSABL	LSB

.SBTTL	TRIM ALL OF STRING EXCEPT PARITY BIT

;+
; CVT$$B - Trim all of a string except for the parity bit		;012+
;
;	R5 -> .ASCIZ String
;
;	CALL	CVT$$B
;
;	R5 -> .ASCIZ string (may be shorter) at same place
;-

CVT$$B:	MOV	R0,-(SP)	;Save R0 for caller
	MOV	#-2,R0		;Set up mask for CVT$$
	CALLX	CVT$$		;Convert the string
	MOV 	(SP)+,R0	;Restore R0
	RETURN			;And go back to caller			;012-

.SBTTL	SWITCH TABLE GENERATING MACROS

.MACRO	$	LONG,SH,BS1,BS2,BC1,BC2,GO,PATCH
	TMPORG	LONGSW
.NLIST
	UNQTXT	<LONG>
.LIST
.DSABL	CRF
.IF IDN	<SH>,<=>
	......	=	$'BS1
.IFF
	.IF IDN	<SH>,<*>
		.IIF GT	.....0-'9, .ERROR ;TOO MANY PER-FILE SWITCHES
		......	= .....0
		.....0	= .....0+1
			UNORG
			.WORD	......
		.ENABL	CRF
			.WORD	BS1,BS2,BC1,BC2,GO
		.DSABL	CRF
	.IIF B	<GO>, .ERROR	;PER-FILE SWITCHES REQUIRE PROCESS ROUTINE
	.IFF
		TMPORG	DATA
		......	= SHRTGO-<.+2>
		.ENABL	CRF
		.IF	IDN	<SH>,<...>
			 .WORD	BISBIT
			.IF	NB	PATCH
				.LIST	MEB
				PATCH	==	.
				.NLIST	MEB
				.ENDC	;NB	PATCH
			.IRP	$$$$$$,<BS1,BS2,BC1,BC2>
				.IF B	$$$$$$
				.ERROR	; MISSING BIT MASKS FOR OPTION SWITCH
				.ENDC	;B	$$$$$$
				 .WORD	$$$$$$
			.ENDM	;.IRP
		.IFF
			 .WORD	SH
			.IF	NB	PATCH
				.LIST	MEB
				PATCH	==	.
				.NLIST	MEB
				.ENDC	;NB	PATCH
			.IRP	$$$$$$,<BS1,BS2,BC1,BC2>
				.IF NB	$$$$$$
					 .WORD	$$$$$$
				.ENDC	;NB	$$$$$$
			.ENDM	;.IRP
		.ENDC	;IDN	<SH>,<...>
		.DSABL	CRF
	.ENDC	;IDN	<SH>,<*>
.ENDC	;IDN	<SH>,<=>
	TMPORG	SHRTSW
	 .WORD	......
.ENABL	CRF
	UNORG
.ENDM	$

.MACRO	.TAG	TAG
.NLIST
.EQUATE	$'TAG,	......
.LIST
.ENDM	.TAG

.SBTTL	SWITCH TABLE MACRO EXPLANATION

;+
;  HOW THE SWITCH TABLE WORKS:
; 
;  THERE ARE TWO CLASSES OF SWITCHES:
; 
;  1) OPTION SWITCHES, WHICH CAN GO ANYWHERE ON THE LINE
;  2) PER-FILE SWITCHES, WHICH APPLY TO THE FILE ON WHICH THEY APPEAR
; 
;  SWITCH SCANNING IS DONE TWICE.  ON THE FIRST PASS, BEFORE THE COMMAND
; 	LINE IS PARSED, THE LONG SWITCH NAMES ARE REMOVED.
; 	ALL OPTION SWITCHES ARE DECODED, ACTION IS TAKEN, AND THEY
; 	(AND THEIR ARGUMENTS) ARE REMOVED FROM THE COMMAND LINE
; 	ALL PER-FILE SWITCHES ARE REPLACED BY A ONE-CHARACTER INTERNAL NAME
; 	WHICH IS PASSED TO (AND RETURNED FROM) THE RT-11 CSI.
; 	THESE ARE THEN ACTED ON AFTER THE PARSE.
; 
;  ENTRIES IN THE SWITCH TABLE ARE AS FOLLOWS:
; 
;  OPTION SWITCH WHICH SIMPLY SET ONE OR MORE FLAG BITS & CHECK CONFLICT:
;   $ <NAME>	...	BITS-TO-SET	BITS-WHICH-CONFLICT
; 
;  OPTION SWITCH WHICH CALLS A ROUTINE (WITH ONE OR TWO ARGUMENTS)
;   $ <NAME>	ROUTINE	[ARG1		[ARG2]]
; 	ROUTINE IS CALLED BEFORE PARSE WITH:
; 		R1 -> ARG1,ARG2 (IF ANY)
; 		R2 =  0
; 		R5 -> SWITCH ARGUMENT (':XXXXX') (PRESENT IF (R5) IS ':')
; 	ROUTINE MUST RETURN C=1 IF ERROR, R5 -> END OF ARGUMENT
; 
;  PER-FILE SWITCH
;   $ <NAME>	*	BITS-TO-SET	BITS-WHICH-CONFLICT	ROUTINE
; 	ROUTINE IS CALLED AFTER PARSE WITH:
; 		R3 =  SWITCH VALUE IF PRESENT
; 		R4 =  PARSE FLAGS
; 		R5 =  FILE NUMBER (0 - 8.) * 2
; 		C=1 IFF SWITCH VALUE PRESENT
; 	ROUTINE RETURNS C=1 IF ERROR
; 
;  SYNONYM DEFINITION
;     .TAG	SYNONYM
; 	MUST IMMEDIATELY FOLLOW THE SWITCH TO BE TAGGED
; 
;  SYNONYM SWITCH
;   $ <NAME>	=	SYNONYM
; 
; 
;-

.SBTTL	EXPLANATION OF DATA STRUCTURE FOR SWITCH TABLE

;+
;  EXPLANATION OF DATA STRUCTURE FOR SWITCH TABLE
; 
; 	THERE ARE THREE AREAS WHICH ARE USED:
; 
; 	LONGSW - IS A TABLE OF TEXT WHICH IS GENERATED BY THE UNQTXT MACRO.
;		 THE GETUNQ SUBROUTINE IS USED FOR PARSING THE SWITCHES.
;		 GETUNQ RETURNS AN INDEX INTO THE TABLE SHRTSW.
; 
; 	SHRTSW - IS A TABLE OF WORD DATA WHICH IS USED TO DETERMINE THE TYPE
;		 OF SWITCH WHICH WAS JUST PARSED. THERE ARE TWO TYPES OF
;		 SWITCHES: PER-FILE SWITCHES AND OPTION SWITCHES.
;
;		 OPTION SWITCHES ARE PARSED ON THE FIRST SCAN OF THE COMMAND
;		 LINE. PER-FILE SWITCHES, ON THE OTHER HAND, ARE PARSED BY
;		 THE RT11 COMMAND STRING INTERPRETTER.
; 
;		 PER-FILE SWITCH PROCESSING IS A LITTLE BIZZARE. UPON ENCOUNT-
;		 ERING A PER-FILE SWITCH DURING THE FIRST SCAN, PIP REPLACES
;		 THE SWITCH WITH A SINGLE BYTE (0-9) AND THEN COMPRESSES THE
;		 COMMAND STRING. THE RT11 COMMAND STRING INTERPRETTER THEN
;		 PARSES THOSE SWITCHES (AND ANY VALUES) AS NORMAL. PIP THEN
;		 INTERPRETS THE PER-FILE SWITCHES FROM WHAT IS PASSED BACK
;		 FROM CSI. THE VALUES IN SHRTSW DENOTE WHETHER OR NOT THE
;		 SWITCH IS A PER-FILE SWITCH.
;
; 		 IF THE VALUE IN SHRTSW IS POSITIVE THEN THE SWITCH JUST
;		 PARSED IS A PER-FILE SWITCH. THE VALUE ITSELF IS THE SINGLE
;		 BYTE VALUE THAT REPLACES THE SWITCH.
; 
; 		 IF THE VALUE IN SHRTSW IS NEGATIVE THEN THE SWITCH JUST
;		 PARSED IS AN OPTION SWITCH. THE VALUE IS THE NEGATIVE OF AN
;		 OFFSET INTO THE TABLE SHRTGO.
; 
; 	SHRTGO - IS A TABLE OF DATA FOR THE SWITCHES DEFINED IN THE ABOVE
;		 TABLES. SHRTSW POINTS INTO THIS TABLE AT THE LOCATION
;		 WHERE THE DATA FOR THE CORRESPONDING TEXT FROM LONGSW CAN BE
;		 FOUND. THE AMOUNT OF DATA CONTAINED PER SWITCH IS VARIABLE,
;		 THE ROUTINE WHICH PARSES THE SWITCH MUST KNOW HOW MUCH DATA
;		 IS IN THIS TABLE.
;-

.SBTTL	SWITCH TABLE

	TMPORG	DATA
SHRTGO::			; START OF DISPATCH TABLE FOR OPTION SWITCHES
	UNORG
SWTCHS::			; START OF CONTROL TABLE FOR PER-FILE SWITCHES
.....0	= '0			; START INTERNAL SWITCH NUMBERING

.NLIST	MEB

; NAME		CALL	SET/ARG	CONFLICT			PER-FILE CALL
;			SCNFLG,SC2FLG

$ <AC\CESS>	...	0,ACCESS	NOTCPY,ZEROPT
$ <AF\TER>	DATESW	LOLIM!MODP1
$ <AP\PEND>	...	APPEND!UPDATE,0	NOTCPY!NOOVER,ZEROPT
  .TAG	APPEND
$ <AS\CII>	CVTMOD	CV.ASC
$ <BE\FORE>	DATESW	HILIM!MODM1
$ <BL\OCK>	CVTMOD	CV.BLK
$ <BR\IEF>	=	FAST
$ <BS\IZE>	BSSWIT	0,BSIZE		NOTCPY,ZEROPT
$ <CO:T\>	NLSWIT
  .TAG	IGNORE
$ <CO\>		=	IGNORE
$ <CRE\ATION>	...	0,CREATE	0,DLA
$ <DEN\SITY>	DENSWT	ZERO,DENSTY	NOTZER!UPDATE!STOPMS,BSIZE
$ <DE\LETE>	NOWOPT	DELETE,0	NOTDEL,ZEROPT!BSIZE
$ <DI\RECTORY>	*	DIRECT,0	NOTDIR,BSIZE!ZEROPT!NOWARN	LSWIT
  .TAG	DIRECTORY
$ <DLA\>	...	0,DLA		0,CREATE
$ <D\>		DERROR
$ <EQ\>		SELFSZ	LOLIM!HILIM
	;032
$ <ER\ASE>	NOWOPT	WIPEFL,0	NOTDEL,BSIZE!ZEROPT	,,..ERDE
  .TAG	ERASE
	; **NOTE** that the contents of optional patches are referenced
	;	   at ONETIM: -- changes here mean changes there.
$ <EX\TEND>	=	APPEND
$ <F\AST>	*	DIRECT,0	NOTDIR,BSIZE!ZEROPT!NOWARN	FSWIT
  .TAG	FAST
$ <GE\>		SELFSZ	LOLIM
	;032
;$ <GT\>		SELFSZ	LOLIM!MODP1
	;032
$ <G\O>		...	GOSWIT,0	NOTCPY,ZEROPT
  .TAG	GO
$ <HE\LP>	HELPME
$ <H\ALT>	...	STOPMS,0	DELETE!RENAME!ZERO,ZEROPT
$ <ID\ENTIFY>	IDSWIT
$ <IG\NORE>	=	GO
$ <I\NSPECT>	INSOPT	INSPCT,0	ZERO!DIRECT,ZEROPT
  .TAG	INSPECT
$ <LE\>		SELFSZ	HILIM
	;032
$ <LOCK\>	SETLPR	JFLOCK
$ <LO\G>	...	LISTFN,0	ZERO!DIRECT,ZEROPT
  .TAG	LOG
;$ <LT\>		SELFSZ	HILIM!MODM1
	;032
$ <L\IST>	=	DIRECTORY
$ <MD\ELETE>	*	DIRECT,MDFILS	NOTDIR,BSIZE!ZEROPT!NOWARN	LSWIT ;073;075
$ <NE\WFILE>	...	NEWFIL,0	NOTCPY,ZEROPT!RETAIN
$ <NOA\TTRIBUTES> ...	0,NOATT		NOTCPY,ZEROPT
$ <NOLO\G>	BICBIT	LISTFN,0	ZERO!DIRECT,ZEROPT
  .TAG	NOLOG
$ <NOS\UPERSEDE> NOWOPT	NOOVER,0	NOTCPY!UPDATE,ZEROPT
$ <NOWA\TCH>	=	NOLOG
$ <N\OREWIND>	...	NORWND,0	DELETE!RENAME!ZERO,ZEROPT
  .TAG	NOREWIND
$ <ON\>		DATESW	LOLIM!HILIM
$ <PAR\ITY>	PARSWT	ZERO,PARITY	NOTZER!UPDATE!STOPMS,BSIZE
$ <PRIO\RITY>	SETLPR	JFSPRI
$ <P\ROTECT>	PRSWIT	NOOVER,0	NOTCPY!UPDATE,ZEROPT
$ <Q\UERY>	=	INSPECT
$ <RW:NO\>	=	NOREWIND
$ <RM\S>	*	0,0		0,0				RMSSWT
  .TAG	RMS
$ <RT\S>	RTSSWT	RTS,0		NOTCPY,ZEROPT
$ <RET\AIN>	...	0,RETAIN	NOTCPY!NEWFIL,ZEROPT
$ <R\ENAME>	NOWOPT	RENAME,0	RTS!DELETE!ZERO!UPDATE!DIRECT,BSIZE!ZEROPT
$ <SIN\CE>	DATESW	LOLIM
$ <S\LOW>	*	DIRECT,0	NOTDIR,BSIZE!ZEROPT!NOWARN	SLSWIT
$ <TO\DAY>	TODAY	LOLIM!HILIM
$ <UN\TIL>	DATESW	HILIM
$ <U\PDATE>	...	UPDATE,0	NOTCPY!NOOVER,ZEROPT
$ <V\ERSION>	VSWIT
$ <WIPEO\UT>	=	ERASE
$ <WO\>		=	ERASE
$ <W\ATCH>	=	LOG
$ <Z\ERO>	...	ZERO,0		NOTZER!UPDATE!STOPMS,BSIZE

	.WORD	0	;END THE PER-FILE SWITCH TABLE

.LIST	MEB

.SBTTL	DIRECTORY LISTING SWITCH VALUES

.MACRO	LSWIT	NN,BITS
.DSABL	CRF
$$$$$$	=	0
.IRP	X,<BITS>
$$$$$$	=	$$$$$$ ! DIR.'X
.ENDM
.ENABL	CRF
	 .WORD	$$$$$$
	 .RAD50	/NN/
.ENDM	LSWIT

DIRTBL:

LSWIT	FU,<NA,EX,SI,PR,DA,TI,LA,CL,RT,HD,PO> ; /L:FU - almost the works
LSWIT	W,<NA,EX,W>		; /L:W  - WIDE LISTING
LSWIT	WI,<NA,W>		; /L:WI - WIDE LISTING WITHOUT EX
LSWIT	NA,<NA>			; /L:NA - FILENAME
LSWIT	EX,<NA,EX>		; /L:EX - FILENAME AND TYPE
LSWIT	TY,<NA,EX>		; /L:TY - FILENAME AND TYPE (SAME, OF COURSE)
LSWIT	SI,<NA,EX,SI>		; /L:SI - SIZE (& NAME)
LSWIT	SZ,<NA,EX,SI>		; /L:SI - SIZE (& NAME)
LSWIT	PR,<NA,EX,PR>		; /L:PR - PROTECTION CODE (& NAME)
LSWIT	LA,<NA,EX,LA>		; /L:LA - LAST ACCESS DATE (& NAME)
LSWIT	DA,<NA,EX,DA>		; /L:DA - DATE OF CREATION (& NAME)
LSWIT	TI,<NA,EX,DA,TI>	; /L:TI - DATE & TIME OF CREATION (& NAME)
LSWIT	CL,<NA,EX,CL>		; /L:CL - CLUSTERSIZE (& NAME)
LSWIT	HD,<HD>			; /L:HD - INCLUDE HEADERS
LSWIT	SU,<SU>			; /L:SU - SUMMARY LISTING
LSWIT	F,<NA,EX>		; /L:F  - FAST LISTING (NAME & TYPE)
LSWIT	BR,<NA,EX>		; /L:BR - FAST LISTING (NAME & TYPE)
LSWIT	DI,<NA,EX,SI,PR,DA,HD>	; /L:DI - NORMAL LISTING
LSWIT	AL,<NA,EX,AL,SI>	; /L:AL - ALLOCATION INSTEAD OF FILESIZE
LSWIT	RT,<NA,EX,RT>		; /L:RT - RUN-TIME SYSTEM
LSWIT	SA,<NA,EX,SA>		; /L:SA - SYMBOLIC ATTRIBUTES
LSWIT	AT,<NA,EX,SA>		; /L:AT - SYMBOLIC ATTRIBUTES
LSWIT	OA,<NA,EX,OA>		; /L:OA - OCTAL ATTRIBUTES
LSWIT	PO,<NA,EX,PO>		; /L:PO - LIST FILE POSITION
LSWIT	OP,<NA,EX,PO>		; /L:OP - kludge for now - ties it to :PO ;073
LSWIT	S,<NA,EX,SI,PR,DA,TI,LA,CL,RT,HD,SA,PO> ; /L:S - the works
	.WORD	0

; DIRECTORY LISTING OPTION BITS

.BSECT
DIR.NA:	.BLKB	.		; LIST NAME
DIR.EX:	.BLKB	.		; LIST TYPE
DIR.SI:	.BLKB	.		; LIST SIZE
DIR.PR:	.BLKB	.		; LIST PROTECTION CODE
DIR.LA:	.BLKB	.		; LIST ACCESS DATE
DIR.DA:	.BLKB	.		; LIST CREATION DATE
DIR.TI:	.BLKB	.		; LIST CREATION TIME
DIR.CL:	.BLKB	.		; LIST CLUSTER SIZE
DIR.RT:	.BLKB	.		; LIST RTS NAME
DIR.PO:	.BLKB	.		; LIST DCN OF FIRST BLOCK
;DIR.OP:.BLKB	.		; list the open counts			;073
; (this is where it would go if there were more bits for the others	;073
DIR.OA:	.BLKB	.		; LIST ATTRIBUTES IN OCTAL    FORMAT
DIR.SA:	.BLKB	.		; LIST ATTRIBUTES IN SYMBOLIC FORMAT
DIR.AL:	.BLKB	.		; LIST ALLOCATION INSTEAD OF SIZE
DIR.SU:	.BLKB	.		; LIST SUMMARY INFO
DIR.HD:	.BLKB	.		; LIST HEADER LINE
DIR.W:	.BLKB	.		; LIST WIDE LISTING

	UNORG

.EQUATE	DIR.ND,	DIR.TI!DIR.LA!DIR.CL!DIR.RT!DIR.OA!DIR.SA!DIR.PO
.EQUATE	DIRLSU,	DIR.SI!DIR.PR!DIR.DA!DIR.TI!DIR.LA!DIR.CL!DIR.RT!DIR.SU

LWIDTH::.WORD	6		; NAME
	.WORD	5		; TYPE (including the * for MDL files)	;073
	.WORD	10.		; SIZE					;073
	.WORD	5		; PROTECTION CODE
	.WORD	10.		; ACCESS DATE
	.WORD	10.		; CREATION DATE
	.WORD	9.		; CREATION TIME
	.WORD	4		; CLUSTERSIZE
	.WORD	7		; RTS NAME
	.WORD	12.		; DCN OF FILE POSITION
; this is a kludge for now - cause we're out of bits.			;073
; This ties it to the position until we get more bit for directory flags ;073
;	.WORD	6		; Open count field			;073
	.WORD	0		; OCTAL ATTRIBUTES
	.WORD	0		; SYMBOLIC ATTRIBUTES
	.WORD	0		; ALLOCATION INSTEAD OF FILE SIZE
	.WORD	0		; SUMMARY LINE
	.WORD	0		; HEADER LINE
	.WORD	0		; WIDE LISTING
	.WORD	0		; RESERVED

.NLIST	BEX

HEADER::.ASCII	" Name "
	.ASCII	".Typ "							;073
	.ASCII	"   Size   "						;073
	.ASCII	" Prot"
	.ASCII	"  Access  "
	.ASCII	"    Date  "
	.ASCII	"   Time  "
	.ASCII	" Clu"
	.ASCII	"  RTS  "
	.ASCII	"  Pos "
	.ASCII	" Op/rr"						;073

 	.EVEN			; ENSURE EVEN BOUNDARY

.EQUATE	RMSDSK,	100000

RMSOPT::.WORD	RMSDSK!10 + 2, ^RPRN
	.WORD	RMSDSK!6 +  2, ^RIM
	.WORD	RMSDSK!2 +  2, ^RFTN
	.WORD	RMSDSK!4 +  2, ^RFA
	.WORD	RMSDSK!4 +  2, ^RAS
	.WORD	RMSDSK!0 +  2, ^RFB
	.WORD	0

RMSDSP::.WORD	RMS2FB
	.WORD	FTN2FA
	.WORD	RMS2FA
	.WORD	RMS2IM
	.WORD	PRN2FA

.BSECT				; BITS IN RMSFLG

CV.RMI:	.BLKB	.		; RMS INPUT
CV.RMO:	.BLKB	.		; RMO OUTPUT
CV.ASC:	.BLKB	.		; ASCII CONVERSION
	.BLKB	.		; RESERVED
	.BLKB	.		; RESERVED
	.BLKB	.		; RESERVED
CV.DIR:	.BLKB	.		; DIRECTORY OUTPUT (CONVERSION IS ILLEGAL)
CV.BLK:	.BLKB	.		; BLOCK OUTPUT
	.BLKB	.		; RESERVED
	.BLKB	.		; RESERVED
	.BLKB	.		; RESERVED
	.BLKB	.		; RESERVED
	.BLKB	.		; RESERVED
	.BLKB	.		; RESERVED
	.BLKB	.		; RESERVED
	.BLKB	.		; RESERVED

	UNORG

.SBTTL	PROGRAM IDENTIFICATION AND TEXT

	ORG	TEXT

.NLIST	BEX

NAME:	.BLKB	10.		; A BUFFER
WLDNAM:	.ASCIZ	"FILNAM.EXT"	; WILD NAME GOES HERE
FNBUFF:	.BLKB	40.
CRLF:	.BYTE	0
;VERMSG:	.PRGID	PIP		;MESSAGE TO IDENTIFY PROGRAM
	.BYTE	0
NXTSEC:	.ASCII	")"<CR><LF>
	.ASCII	"%Please mount volume containing file section "<200>
UNXEOF:	.ASCII	"Unexpected EOF in input record"<200>
CMOTXT:	.ASCII	"?Open error"
CMFTXT:	.ASCII	" - command file "<200>
CMRTXT:	.ASCII	"?Read error"<200>
LNELNG:	.ASCII	"?Line too long"<200>
CONTXT:	.ASCIZ	" - continuing"
PQREAL:	.ASCII	"OK to replace existing file "<200>			;001
ZERABT:	.ASCIZ	"Zero aborted"
ZEREAL:	.ASCII	"Really zero "<200>
SWTER:	.ASCIZ	"Switch error"
BVALER:	.ASCIZ	"Bad switch value"
NEWVOL:	.BYTE	CR,LF
	.ASCII	"%End of ANSI magtape  "<200>
NEWVL2:	.ASCII	"  volume  has"<CR><LF>
	.ASCIZ	"%been reached."<CR><LF>
NEWVL3:	.ASCII	"%Please type the  device  name  and  unit"<CR><LF>
	.ASCII	"%number  of  the  drive  where  the  next"<CR><LF>
	.ASCII	"%volume may be found.                    "
QMARK:	.ASCII	" ? "<200>
ANOUTT:	.ASCII	"output"<200>
ANINPT:	.ASCII	" input"<200>
NOTANS:	.ASCIZ	"Magtape is not in ANSI format"

P..PASS.2  =	-1		; Indicate assembler now in pass 2

.END	ONETIM
