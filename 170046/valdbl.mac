.INCLUDE	/CMN:COMMON.MAC/
TITLE	VALDBL,<Convert String to 32-bit Integer>,0A,10-MAY-91,JJT

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR VALDBL
;+
;
;  001	JJT  02-May-86	Creation
;
;-

	;+
	; VALDBL - Convert String to 32-bit Integer
	; CALL:	R4 -> 2 Word block to store results
	;	R5 -> String to convert
	;	CALL	VALDBL
	;
	; BACK: (R4) = High Word
	;	2(R4)= Lower Word
	;	R5 -> First Unconverted Character
	;	Leading, embedded, and trailing blanks are ignored.
	;	C=1 means overflow detected or no number present.
	;-
	.CSECT

VALDBL::MOV	R1,-(SP)	; SAVE REGISTERS 1-3
	MOV	R2,-(SP)	;
	MOV	R3,-(SP)	;	
	CLR	R1		; RESULT ACCUMULATORS
	CLR	R2
	CLR	R3
10$:	MOVB	(R5)+,R1	; GET NEXT CHAR
	CMPB	R1,#40		; LEADING SPACE?
	BEQ	10$		; GET NEXT CHAR IF SO
	CMPB	R1,#11		; LEADING TAB?
	BEQ	10$		; GET NEXT CHAR IF SO
	SUB	#'0,R1		; CONVERT DIGIT TO VALUE
	BLO	XERR2		; ERROR IF NOT A DIGIT
	CMP	R1,#9.		; CHARACTER IN RANGE?
	BHI	XERR2		; ERROR IF NOT
20$:	ASHC	#1,R2		; MULTIPLY BY TWO
	BCS	XERR2		; BRANCH IF NUMBER TOO LARGE
	MOV	R2,-(SP)	; SAVE HIGH ORDER BITS
	MOV	R3,-(SP)	; SAVE LOW ORDER BITS
	ASHC	#1,R2		; MULTIPLY BY TWO AGAIN
	BCS	XERR		; BRANCH IF NUMBER TOO LARGE
	ASHC	#1,R2		; HAVE (NEW NUMBER) = 8.*(OLD NUMBER)
	BCS	XERR		; BRANCH IF NUMBER TOO LARGE
	ADD	(SP)+,R3	; ADD BACK 2*(OLD NUMBER)
	ADC	R2
	BVS	XERR1		; BRANCH IF NUMBER TOO LARGE
	ADD	(SP)+,R2	; HAVE (NEW NUMBER) = 10.*(OLD NUMBER)
	BVS	XERR2		; BRANCH IF NUMBER TOO LARGE
	BCS	XERR2
50$:	ADD	R1,R3		; ADD NEW DIGIT
	ADC	R2
	BCS	XERR2		; BRANCH IF NUMBER TOO LARGE
60$:	MOVB	(R5)+,R1	; GET NEXT CHAR
	CMPB	R1,#40		; LEADING SPACE?
	BEQ	60$		; GET NEXT CHAR IF SO
	CMPB	R1,#11		; LEADING TAB?
	BEQ	60$		; GET NEXT CHAR IF SO
	SUB	#'0,R1		; CONVERT DIGIT TO VALUE
	BLO	70$		; EXIT IF NOT A DIGIT
	CMP	R1,#9.		; CHARACTER IN RANGE?
	BHI	70$		; EXIT IF NOT
	BR	20$		; GO WORK ON NEXT CHARACTER

70$:	TSTB	-(R5)		; RESTORE R5'S POSITION
	MOV	R2,(R4)		; STORE HIGH BITS
	MOV	R3,2(R4)	; STORE LOW BITS
	CLC			; ENSURE THE CARRY BIT IS CLEAR
	BR	XEXIT		; AND EXIT

	.SBTTL		ERROR AND NORMAL EXITS

XERR:	TST	(SP)+		; ADJUST STACK (SAVED HIGH ORDER BITS)
XERR1:	TST	(SP)+		; ADJUST STACK (SAVED LOW ORDER BITS)
XERR2:	SEC			; SET CONVERSION ERROR
XEXIT:	MOV	(SP)+,R3	; RESTORE REGISTER 3
	MOV	(SP)+,R2	; RESTORE REGISTER 2
	MOV	(SP)+,R1	; RESTORE REGISTER 1
	RETURN

	.END
