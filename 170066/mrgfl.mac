	.TITLE	MRGFL
	.IDENT	/02/
 
;
; COPYRIGHT (C) 1975,1976,1977
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ONLY ON A
; SINGLE COMPUTER SYSTEM AND MAY  BE  COPIED   ONLY  WITH  THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE,  OR
; ANY OTHER COPIES THEREOF, MAY NOT BE PROVIDED  OR  OTHERWISE
; MADE AVAILABLE TO ANY OTHER PERSON   EXCEPT FOR  USE ON SUCH
; SYSTEM AND TO ONE WHO AGREES TO THESE LICENSE  TERMS.  TITLE
; TO AND OWNERSHIP OF THE SOFTWARE SHALL AT ALL  TIMES  REMAIN
; IN DEC.
;
; THE INFORMATION IN THIS DOCUMENT IS SUBJECT TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT BY DIGITAL
; EQUIPMENT CORPORATION.
;
; DEC ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF
; ITS SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DEC.
;
; VERSION 02
;
; C. MONIA 13-NOV-75
;
; MODIFICATIONS:
;
;	C. MONIA  05-FEB-77
;
;		CM001 -- CORRECT VERSION IDENTIFICATION PROCESSING
;
; MERGE INPUT MODULE AND CORRECTION FILE
;
; MACRO LIBRARY CALLS
;
 
	.MCALL	CLOSE$,GET$S,PUT$S
 
;
; EQUATED SYMBOLS
;
 
GSDSZ=8.			; SIZE OF GSD RECORD
 
;
; LOCAL DATA
;
; ADDRESS OF CURRENT CHECKSUM
;
 
CKSUM:	.BLKW	1		;
 
;
; CURRENT BUFFER ADDRESS
;
 
CURBF:	.BLKW	1		;
 
;
; GSD AND END OF MODULE BLOCKS
;
 
EOGSD:	.BYTE	2,0		; END OF GSD
EOMOD:	.BYTE	6,0		; END OF MODULE
STGSD:	.BYTE	1,0		; START OF GSD
 
;
; RECORD BUFFER FOR GSD OUTPUT
;
 
RECBF:	.BLKB	128.		;
 
;+
; **-$MRGFL-MERGE INPUT AND CORRECTION FILES
;
; THIS ROUTINE IS CALLED TO COMBINE THE CONCATENATED INPUT FILE
; AND CORRECTION FILES TO PRODUCE THE PATCHED OUTPUT. THE PROCEDURE
; FOR COMBINING FILES IS AS FOLLOWS:
;
;	THE INPUT FILE IS COPIED TO THE OUTPUT FILE UNTIL IT
; IS POSITIONED AT THE MODULE TO BE PATCHED. AT THAT TIME THE
; PREVIOUSLY CONSTRUCTED GSD TABLES ARE REFERENCED TO GENERATE
; A NEW GLOBAL SYMBOL DIRECTORY CONTAINING MODULE NAME, TRANSFER
; ADDRESS (IF SPECIFIED) AND MODULE IDENTIFICATION EXTRACTED FROM THE
; PATCH FILE ALONG WITH SECTIONS AND GLOBAL SYMBOLS FROM THE TABLES 
; BUILT BY $EDGSD. 
;
;	ONCE RECONSTRUCTION OF THE GSD IS COMPLETE, THE REMAINDER OF THE
; INPUT FILE IS COPIED (LESS ALL GSD RECORDS) UNTIL END OF MODULE IS
; REACHED. THE POSITION IN THIS FILE IS MARKED AND THE FILE IS CLOSED.
; THE CORRECTION INPUT FILE IS OPENED AND COPIED IN SIMILAR FASHION, 
; ITS TEXT AND RLD RECORDS APPEARING AFTER ALL SUCH RECORDS IN THE
; INPUT FILE. UPON COMPLETION, THE INPUT FILE IS RE-OPENED AND RE-
; POSITIONED FOR THE COMPLETION OF FILE COPY.
;
; INPUTS:
;
;	GSD TABLES BUILT BY $EDGSD
;
; OUTPUTS:
;
;	INPUT AND CORRECTION FILES ARE MERGED AS DESCRIBED
;
;-
 
$MRGFL::			;
	SAVRG			; SAVE THE NONVOLATILE REGISTERS
	MOV	#$INCK,CKSUM	; SET ADDRESS TO RECEIVE CHECKSUM
	BIT	#OU$FL,$SWTCH	; OUTPUT FILE SPECIFIED?
	BEQ	5$		; IF EQ NO
	CALL	$OPNOU		; OPEN OUTPUT FILE
5$:				;
	MOV	#$INFNB,R0	; GET ADDRESS OF INPUT FILE NAME BLOCK
	CALL	$OPNIN		; OPEN INPUT FILE
10$:				;
	MOV	#$INFDB,R0	; GET ADDRESS OF INPUT FILE FDB
	CALL	.MARK		; GET CURRENT POSITION IN FILE
	BCS	75$		; IF C/S ERROR POSITIONING FILE
	MOV	#$FILPT,R4	; GET ADDRESS OF FILE POSITION
	CMP	R1,(R4)+	; COMPARE FILE LOCATION
	BNE	20$		; IF NE NOT POSITIONED PROPERLY
	CMP	R2,(R4)+	; ...
	BNE	20$		; ...
	CMP	R3,(R4)		; ...
	BEQ	30$		; IF EQ FOUND CORRECT POSITION IN FILE
20$:				;
	CLR	R5		; SET FLAG TO PASS ALL GSD
	CALL	CPYFL		; COPY ENTIRE MODULE TO OUTPUT
	BCC	25$		; IF C/C OK
	JMP	ILFMT		; ELSE ILLEGAL FORMAT
25$:				;
	CALL	WREOM		; WRITE END-OF-MODULE RECORD
	BR	10$		; GO AGAIN
 
;
; FOUND CORRECT POSITION IN FILE. RE-BUILD MODULE GSD
;
 
30$:				;
	CALL	WRGSD4		; INSERT START OF GSD RECORD IN BUFFER
	MOV	#$MODNM,R1	; POINT TO MODULE NAME
	MOV	#GSDSZ,R2	; GET BYTE COUNT
	CALL	WRGSD		; MOVE INITIAL GSD TO OUTPUT BUFFER
	MOV	#$IDENT,R1	; GET VERSION IDENTIFICATION
	TSTB	S$CNT-S$YM(R1)	; IDENT. SPECIFIED?
	BEQ	35$		; IF EQ NO
	MOV	#GSDSZ,R2	; GET SIZE OF RECORD
	CALL	WRGSD		; WRITE RECORD
35$:				;
	MOV	#$SCTHD,R4	; GET ADDRESS OF SECTION HEAD
40$:				;
	MOV	(R4),R4		; GET ADDRESS OF NEXT SECTION
	BNE	50$		; IF NE HAVE NEXT RECORD
	MOV	#$XFRAD,R1	; POINT TO TRANSFER ADDRESS
	MOV	#GSDSZ,R2	; SET BYTE COUNT
	CALL	WRGSD		; WRITE TRANSFER ADDRESS
	CMP	R5,#2		; BUFFER NOW EMPTY
	BLOS	45$		; IF LOS YES
	CALL	WRGSD2		; FLUSH RECORD BUFFER
45$:				;
	MOV	#EOGSD,R1	; POINT TO END GSD BLOCK
	MOV	#2,R2		; GET BYTE COUNT
	CALL	PUT		; WRITE END OF GSD
	BR	70$		;
50$:				;
	MOV	#$SYMHD,R3	; GET ADDRESS OF SYMBOL TABLE LISTHEAD
	MOV	R4,R1		; COPY ADDRESS OF RECORD
60$:				;
	TST	(R1)+		; POINT TO FIRST BYTE
	MOV	#GSDSZ,R2	; SET RECORD LENGTH
	CALL	WRGSD		; WRITE GSD RECORD
65$:				;
	MOV	(R3),R3		; GET ADDRESS OF NEXT SYMBOL
	BEQ	40$		; IF EQ DONE
	CMP	S$YSCT(R3),R4	; CURRENT SYMBOL IN THIS SECTION?
	BNE	65$		; IF NE NO
	MOV	R3,R1		; COPY ADDRESS OF ENTRY
	BR	60$		; GO AGAIN
 
;
; GSD CONSTRUCTION IS COMPLETE, COPY REMAINDER OF INPUT MODULE
; BUT STRIP OFF ALL GSD RECORDS
;
 
70$:				;
	MOV	#200,R5		; STRIP GSD, PASS ALL RLD
	CLR	@CKSUM		; RESET CHECKSUM
	CALL	CPYFL		; COPY REMAINDER OF MODULE
	BCS	ILFMT		; IF C/S ERROR IN FILE FORMAT
	CALL	.MARK		; RECORD CURRENT POSITION IN FILE
75$:				;
	BCC	77$		; IF C/C OK
	JMP	MRKER		; REPORT ERROR IN FILE POSITION
77$:				;
	MOV	#$FILPT,R4	; GET ADDRESS TO STORE POSITION
	MOV	R1,(R4)+	; SAVE FILE POSITION
	MOV	R2,(R4)+	; ...
	MOV	R3,(R4)		; ...
	CLOSE$	R0		; CLOSE INPUT FILE
	BCC	78$		; IF C/C OK
	JMP	CLSER		; ELSE CLOSE ERROR
78$:				;
	MOV	#$CRFNB,R0	; GET ADDRESS OF CORRECTION FILE NAMEBLOCK
	CALL	$OPNIN		; OPEN INPUT FILE
	MOV	#$CRCK,CKSUM	; SET ADDRESS TO RECEIVE CHECKSUM
	CLR	@CKSUM		; CLEAR CHECKSUM
	SWAB	R5		; STRIP GSD, SCAN FOR COMPLEX RLD
	CALL	CPYFL		; APPEND TEXT, RLD TO OUTPUT
	CALL	WREOM		; WRITE END OF MODULE
	CLOSE$	#$INFDB		; CLOSE CORRECTION FILE INPUT
	MOV	#$INFNB,R0	; GET INPUT FILE NAME BLOCK AGAIN
	CALL	$OPNIN		; OPEN INPUT
	MOV	#$FILPT,R4	; GET ADDRESS OF FILE POSITION
	MOV	(R4)+,R1	; SET FILE POSITION
	MOV	(R4)+,R2	; ...
	MOV	(R4),R3		; ...
	CALL	.POINT		; POSITION INPUT FILE
	BCC	80$		; IF C/C FILE POSITIONED PROPERLY
	CMPB	#IE.EOF,F.ERR(R0) ; END OF FILE?
	BNE	MRKER		; IF NE NO, FILE POSITIONING ERROR
	CMPB	R1,F.EFBK(R0)	; AT PHYSICAL END OF FILE?
	BNE	MRKER		; IF NE NO
	CMP	R2,F.EFBK+2(R0)	; CONTINUE COMPARISON
	BNE	MRKER		; ...
	CMP	R3,F.FFBY(R0)	; ...
	BNE	MRKER		;
80$:				;
	CLR	R5		; ALLOW GSD TO PASS
	MOV	#CURBF,CKSUM	; SET ADDRESS TO RECEIVE DUMMY CHECKSUM
	CALL	CPYFL		; COPY REMAINDER OF INPUT
	BCS	90$		; IF C/S END-OF-FILE
	CALL	WREOM		; WRITE END OF MODULE
	BR	80$		; GO AGAIN
90$:				;
	CLOSE$	#$OUFDB		; CLOSE OUTPUT FILE
	BCS	CLSER		; IF C/S ERROR DURING CLOSE
	CLOSE$	#$INFDB		; CLOSE INPUT FILE
	RETURN			;
 
;
; INPUT FILE HAS ILLEGAL FORMAT
;
 
ILFMT:				;
	ADD	#F.FNB+N.FNAM,R0 ; POINT TO FILE NAME
	ERROR$	E$R1,S$V2,R0 ; FATAL, NO RETURN
 
;
; COPY INPUT MODULE TO OUTPUT, PASS GSD RECORDS IF
; R5 IS CLEAR.
;
 
CPYFL:				;
	GET$S	#$INFDB		; GET INPUT RECORD
	BCS	30$		; IF C/S END OF FILE OR ERROR
	MOV	F.NRBD(R0),R1	; GET BYTE COUNT
	MOV	F.NRBD+2(R0),R2	; GET BUFFER ADDRESS
5$:				;
	DEC	R1		; DECREMENT BYTE COUNT
	BMI	7$		; IF MI DONE WITH CHECKSUM
	CLR	-(SP)		; CLEAR A WORD
	MOVB	(R2)+,(SP)	; GET A BYTE
	ADD	(SP)+,@CKSUM	; UPDATE CHECKSUM
	BR	5$		; GO AGAIN
7$:				;
	CMPB	@F.NRBD+2(R0),STGSD ; GSD RECORD?
	BEQ	10$		; IF EQ YES
	CMPB	@F.NRBD+2(R0),EOGSD ; END GSD RECORD?
	BNE	20$		; IF NE NO, COPY RECORD
10$:				;
	TST	R5		; WANT TO COPY GSD?
	BNE	CPYFL		; IF NE NO, IGNORE RECORD
20$:				;
	TST	R5		; RLD SCAN REQUIRED?
	BGE	25$		; IF GE NO
	CALL	$SCRLD		; SCAN RLD
25$:				;
	CMPB	@F.NRBD+2(R0),EOMOD ; END OF MODULE?
	BEQ	40$		; IF EQ YES, EXIT
	MOV	F.NRBD(R0),R2	; SET BYTE COUNT
	MOV	F.NRBD+2(R0),R1	; SET BUFFER ADDRESS
	CALL	PUT		; COPY RECORD TO OUTPUT
	BR	CPYFL		; PROCESS NEXT RECORD
30$:				;
	TST	@CKSUM		; TEST CHECKSUM RESULT
	BNE	35$		; IF NE OK
	INC	@CKSUM		; FORCE NON-ZERO RESULT
35$:				;
	CMPB	#IE.EOF,F.ERR(R0) ; END OF FILE ON INPUT?
	SEC			; ASSUME YES
	BEQ	40$		; IF EQ YES
	ERROR$	E$R16,S$V2,#$INFDB+F.FNB+N.FNAM ; I/O ERROR ON INPUT FILE
40$:				;
	MOV	#$INFDB,R0	; GET ADDRESS OF INPUT FILE FDB
	RETURN			;
 
;
; ERROR DURING CLOSE
;
 
CLSER:				;
	ADD	#F.FNB+N.FNAM,R0 ; POINT TO FILE NAME BLOCK
	ERROR$	E$R2,S$V2,R0	; FATAL, NO RETURN
 
;
; ERROR POSITIONING FILE
;
 
MRKER:				;
	ADD	#F.FNB+N.FNAM,R0 ; POINT TO FILE NAME BLOCK
	ERROR$	E$R3,S$V2,R0	; FATAL, NO RETURN
 
;
; WRITE A RECORD TO THE OUTPUT FILE
;
 
PUT:				;
	BIT	#OU$FL,$SWTCH	; OUTPUT FILE SPECIFIED?
	BEQ	10$		; IF EQ NO
	PUT$S	#$OUFDB,R1,R2	; OUTPUT THE RECORD
	BCC	10$		; IF C/C OK
	ERROR$	E$R15,S$V2,#$OUFDB+F.FNB+N.FNAM ; FATAL, NO RETURN
10$:				;
	RETURN			;
 
;
; WRITE END OF MODULE RECORD
;
 
WREOM:				;
	MOV	#EOMOD,R1	; POINT TO END OF MODULE RECORD
	MOV	#2,R2		; GET BYTE COUNT
	BR	PUT		; OUTPUT THE RECORD
 
;
; WRITE GSD RECORDS TO OUTPUT FILE
;
 
WRGSD:				;
	ADD	R2,R5		; UPDATE BYTE COUNT
	MOV	CURBF,R0	; GET ADDRESS OF BUFFER
10$:				;
	MOVB	(R1)+,(R0)+	; MOVE GSD RECORD TO BUFFER
	SOB	R2,10$		; ...
	MOV	R0,CURBF	; SAVE BUFFER POINTER
	CMP	R5,#128.-GSDSZ	; ENOUGH ROOM FOR ANOTHER RECORD?
	BHI	WRGSD2		; IF HI NO
	RETURN			;
 
;
; WRITE A GSD RECORD
;
 
WRGSD2:				;
	MOV	#RECBF,R1	; SET BUFFER ADDRESS
	MOV	R5,R2		; SET BYTE COUNT
WRGSD3:				;
	CALL	PUT		; WRITE THE RECORD
WRGSD4:				;
	MOV	#RECBF,CURBF	; RESET CURRENT BUFFER POINTER
	MOV	#STGSD,R1	; INSERT START GSD RECORD IN BUFFER
	MOV	#2,R2		; SET BYTE COUNT
	CLR	R5		; RESET TOTAL BYTE COUNT
	BR	WRGSD		; INSERT RECORD IN BUFFER
 
	.END
