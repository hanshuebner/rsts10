.INCLUDE	%CMN:COMMON.MAC%					;015
.INCLUDE	%CMN:KERNEL.MAC%					;015
TITLE	ERL,<ERROR LOGGING>,0A,13-MAY-91,GW/MHB/ABC/SJM/JTC/DRP/GMB/FEK/GPK/KPH/WRM

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR ERL

;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;  001	SJM  08-JUL-81	ADD I&D SPACE SUPPORT
;  002	JTC  25-OCT-81	FIP POOL SUPPORT
;  003	DRP  09-JUL-82  SUPPRESS/REROUTE ERROR MESSAGES
;			IF INITIALIZING A DISK
;  004  GMB  30-Sep-82  Add subroutine ERLPC to be used by
;			CRAsh and ERL to log (PC) values
;  005  GMB  25-Jan-83  Prevent negative PC's from being created in ERLPC
;  006  DRP  17-Feb-83	Fix bug in field 2 processing
;  007	FEK  30-Jun-83	USER I/D SUPPORT
;
;			[RSTS/E V9.0]
;  008	DRP  03-Oct-83	Table changes to UNTCNT, UNTOWN/UNTOPT and 
;			UNTCLU/UNTERR
;  009	MND  09-Dec-83	Virtual disk
;  010	GPK  28-Feb-84	Change calling convention on ERLMSD
;  011	KPH  29-Aug-84	Changes for APR5 FIP pool
;
;			[RSTS/E V9.1]
;  012  KPH  10-Jul-85	Fix ERLPC and crashes in APR5
;
;			[RSTS/E V9.2]
;  013  KPH  25-Jul-85	Add job control region
;			Move IOB to FIP pool
;
;			[RSTS/E V9.7]
;  014  WRM  03-Jan-89	Add LOG$CP Cache problem on 11/70's
;
;			[RSTS/E V10.0]
;  015  WRM  29-Sep-89	Make ERL exit thru RTIMON
;
;			[RSTS/E V10.1]
;  016	FEK  10-Apr-91	Make ERLCNT global & fix supervisor mode MMU errors
;-

	DEFORG	ERL

	DEFORG	ERLCTL

	DEFORG	ERLCTB

	ORG	ERL

ERLSIZ	=	6+3*2		;NUMBER OF BYTES ADDED TO STACK BY ERROR LOGGER

	TMPORG	ERLCTL

ERLCNT::.WORD	-1		;NUMBER OF ERRORS DETECTED		;016

;**** THE NEXT TWO ITEMS ARE GROUPED ****
ERLMIS:	.WORD	0		;NUMBER OF MISSED ERRORS
ERLSEQ:	.WORD	1		;ERROR SEQUENCE NUMBER

ERLCHK:	.WORD	-1		;RE-ENTRY CHECKING CELL

CALADR:	.BLKW			;ADDRESS FOR INDIRECT CALLS

SAVKA6:	.BLKW			;SAVED KERNEL PAR6

BUFMMU:	.BLKW			;BUFFER MMU ADDRESS

RCVRIB:	.BLKW			;MESSAGE RECEIVER'S RIB POINTER		;003

	TMPORG	ERLCTB

; CONTROL TABLE SPACE FOR ERROR LOGGING

ERLCTB:	.BLKB			;ERROR CODE
	.BLKB			;JOB NUMBER TIMES 2 (& FLAGS)
	.BLKB			;16. WORDS
	.BLKB			; FIELD 2
	.BLKW			;  ROUTINE TO CALL
	.BLKB			;M WORDS
	.BLKB			; FIELD 2
	.BLKW			;  DATA POINTER
	.BLKB			;N WORDS		**
	.BLKB			; FIELD 4		 * OPTIONAL
ERLCF4:	.BLKW			;  DATA POINTER		**
	.BLKW			;TERMINATING -1
ERLCPU:	.BLKW	2		;CPU ID, CPU ERROR REGISTER
	.BLKW	10.		;UP TO 10. MORE INTERNAL CPU REGISTERS

	UNORG

.SBTTL	GENERAL ERROR LOGGING ROUTINE

;+
; ERL - ERROR LOGGER.
;
;	R0 =  ERROR LOG CODE (FROM THE ERROR LOG EMT)
;	R1-R5 = VALUE AT TIME OF ERROR LOG EMT
;	SP -> R0, R1, R2, R3, R4, R5, PC, PS, ...
;	PRIORITY IS PR7
;
;	...
;
;	RTI
;
;	R0-R5 = VALUE AT TIME OF ERROR LOG EMT
;	SP -> ...
;-

ERL:	MOV	#ERLRIB,RCVRIB	;;;GET THE ERROR LOGGING RIB		;003
	MOV	R0,-(SP)	;;;SAVE THE EMT CODE			;003
	CMPB	R0,#LGDSKS	;;;IS IT A DISK EMT?			;003
	BLO	10$		;;;NO, EMT VALUE IS TOO LOW		;003
	CMPB	R0,#LGDSKE	;;;BEYOND THE RANGE OF A DISK EMT?	;003
	BHIS	10$		;;;YES, DON'T BOTHER LOOKING FURTHER	;003
	TST	R4		;;;IS THERE A DSQ?			;003
	BEQ	10$		;;;NO, DO NORMAL ERROR LOGGING		;003
	MOVB	DSQUNT(R4),R0	;;;GET THE FIP UNIT NUMBER		;003
	ASL	R0		;;; MAKE IT TIMES 2			;003
	BIT	#UO.INI,UNTOPT(R0) ;;;INITIALIZE BIT ON FOR THIS UNIT?	;008
	BEQ	10$		;;;NO, DO NORMAL ERROR LOGGING		;003
	MOVB	DSQJOB(R4),R0	;;;YES, GET THE JOB NUMBER * 2		;003
	MAP	PUSH,APR=6,DATA	;;;Save APR6 mapping			;013
	MOV	R1,-(SP)	;;;Save R1				;013
	CALLX	MAPJCR		;;;Map JCR entry for job		;013
	MOV	JCMPTR(R1),R0	;;;Pick up pointer to first RIB		;013
	MOV	(SP)+,R1	;;;Restore R1				;013
	MAP	POP,APR=6,DATA	;;;Restore APR6 mapping			;013
	TST	R0		;;;Check to see if there is a RIB	;013
	BR	3$		;;;And join up				;013

2$:	MOV	(R0),R0		;;;GET THE RIB POINTER			;003
3$:	BEQ	4$		;;;NO MORE RIBS, SO DROP THE MESSAGE	;003
	CMPB	S.JBNO(R0),DSQJOB(R4) ;;;THIS RIB OWNED BY THIS JOB?	;003
	BNE	4$		;;;NO, AGAIN WE DROP THE MESSAGE	;003
	BITB	#SA.NLC,S.ACCS(R0) ;;;ANYTHING "NON-LOCAL"?		;003
	BNE	2$		;;;YES, CAN'T HAVE A LOCAL OBJECT TYPE	;003
	CMPB	#SO.INI,S.OBJT(R0) ;;;NO, DELARED AS DSKINT?		;003
	BNE	2$		;;;NO, LOOK AT THE NEXT RIB		;003
	MOV	R0,RCVRIB	;;;GOT IT, SAVE THE RIB POINTER		;003
	BR	20$		;;;ONWARD TO REROUTE THIS MESSAGE	;003

4$:	MOV	(SP)+,R0	;;;NO, CLEAN UP THE STACK		;003
	JMP	310$		;;; AND GO EXIT				;003

10$:	INC	ERLCNT		;;;COUNT AS A DETECTED ERROR
	MOV	ERLCNT,@DISPLY	;;;DISPLAY THE ERROR COUNT
20$:	MOV	(SP)+,R0	;;;RESTORE THE EMT CODE			;003
	INC	ERLCHK		;;;ARE WE BEING RE-ENTERED
	BNE	70$		;;;YES. COUNT AS A MISSED ERROR
	MOVB	R0,ERLCTB	;;;SAVE THE ERROR LOG EMT CODE
	MOV	$ERRTBL(R0),CALADR ;;;STORE TRANSFER ADDRESS
	MOV	RCVRIB,R0	;;;GET THE ERROR LOGGING RIB		;003
	CMPB	S.MCNT(R0),S.MMAX(R0) ;;;CAN WE QUEUE ANOTHER MESSAGE?
	BHIS	70$		;;;NO. COUNT IT AS A MISSED ERROR
	MOV	(SP),R0		;;;RESTORE THE ORIGINAL R0
	CALL	@CALADR		;;;CALL THE CALLER'S ERROR LOGGING ROUTINE

;+
; CONDITIONS WHEN CALLER'S ERROR LOG ROUTINE IS CALLED.
;
;	R0-R5 = VALUE AT TIME OF ERROR LOG EMT
;	PRIORITY IS PR7
;
;	...
;
;	RETURN
;
;	R0-R4 = UNDEFINED
;	R5 -> CONTROL TABLE
;-

	REGSAV			;;;SAVE ALL THE REGISTERS

GLOBAL	<DISPLY,$ERRTBL,ERLRIB,UNTOPT>					;003

; FIND THE NUMBER OF WORDS TO LOG

	MOV	#1,R3		;;;INITIALIZE THE FIELD NUMBER
	MOV	#9.+1,R1	;;;SET THE WORD COUNT FOR THE JOB FIELD
	BICB	#^C<63.*2>,1(R5) ;;;IS THERE A JOB NUMBER
	BNE	30$		;;;YES
	MOV	R3,R1		;;;SET WORD COUNT =1 FOR EMPTY JOB FIELD
30$:	TST	(R5)+		;;;SKIP A WORD
	MOVB	(R5)+,R4	;;;GET THE NUMBER OF WORDS FOR THIS ENTRY
	BMI	90$		;;;NEGATIVE MEANS ALL DONE
	ADD	R4,R1		;;;ADD NUMBER OF WORDS TO THE TOTAL
	MOVB	(R5)+,R4	;;;GET THE FIELD NUMBER
	BPL	40$		;;;SKIP IF POSITIVE
	NEG	R4		;;;MAKE IT POSITIVE
40$:	CMP	R3,R4		;;;IS THIS THE SAME AS THE CURRENT FIELD
	BHIS	30$		;;;YES
	CMPB	(R1)+,(R3)+	;;;BUMP THE FIELD NUMBER AND WORD COUNT
	BR	40$		;;;TEST THE NEXT FIELD

; ERROR CLEANUP

50$:	MOV	R5,R4		;;;RESTORE THE BUFFER ADDRESS
	BUFFER	RETURN		;;;RETURN THE LARGE BUFFER
60$:	ADD	#6*2,SP		;;;REMOVE SAVED REGISTERS FROM STACK
70$:	CMP	#ERLRIB,RCVRIB	;;;ERROR LOGGING RIB?			;003
	BNE	80$		;;;NO					;003
	INC	ERLMIS		;;;YES, COUNT AS ERROR MISSED
80$:	JMP	300$		;;; AND GO EXIT

; GET BUFFERS

90$:	ASL	R1		;;;CONVERT # WORDS TO # BYTES
	MOV	R1,R0		;;; AND SAVE IT
	ADD	#BUFHDR,R1	;;;ADD IN FOR THE POSTING HEADER
	MOV	#75.,R2		;;;LEAVE 75. BUFFERS IN THE MONITOR POOL
	CALLX	BUFFER,R5,MONPOL ;;;GET A LARGE BUFFER
	BCS	60$		;;;WE FAILED. CALL IT A MISSED ERROR
	MOV	R4,R5		;;;SAVE THE BUFFER POINTER
	BUFFER	GETSML,0,75.	;;;GET A PMB (NOT ZEROED). LEAVE AT LEAST 75.
	BVS	50$		;;;FAILED. COUNT AS A MISSED ERROR
	MOV	@DPAR6,SAVKA6	;;;SAVE PAR6
	MOV	SAVKA6,BUFMMU	;;;AND MAKE IT OUR DEFAULT MAPPING FOR NOW
	MOV	R5,-(SP)	;;;SAVE THE LARGE BUFFER ADDRESS
	BIT	R5,#37		;;;IN MONITOR BUFFER POOL?
	BEQ	100$		;;;YES
	ASHC	#-7,R5		;;;FORM MMU ADDRESS
	MAP	R5,APR=6,DATA	;;;SET THE MMU FOR PAR6
	MOV	R5,BUFMMU	;;;AND REMEMBER THE MMU ADDRESS FOR LATER
	MOV	#140000,R5	;;; AND GET A NEW POINTER
100$:	ADD	#BUFHDR,R5	;;;SKIP POSTING HEADER IN THE BUFFER
	MOV	R5,-(SP)	;;;SAVE THE MAPPED LARGE BUFFER ADDRESS
	MOV	R4,-(SP)	;;; AND THE PMB ADDRESS

; FILL IN THE PENDING MESSAGE BLOCK

	CLR	(R4)+		;;;NO FORWARD LINK
	MOV	4(SP),(R4)+	;;;SET LARGE BUFFER ADDRESS
	MOV	ERLSEQ,R2	;;;SET THE SEQUENCE NUMBER
	CALL	BLDPMB		;;; AND BUILD THE PMB
	MOV	R0,12-40(R4)	;;;SET NUMBER OF BYTES
	MOV	ERLSIZ-2(SP),R0	;;;GET POINTER TO CONTROL TABLE (OLD R5)
	MOV	(R0)+,14-40(R4)	;;;SET ERROR CODE AND JOB NUMBER

GLOBAL	<MONPOL,DPAR6>

; SET UP JOB FIELD

	MOV	#1*400+9.,(R5)+	;;;SET FIELD 1, 9. WORDS
	MOVB	-1(R0),R2	;;;GET THE JOB NUMBER
	BEQ	140$		;;;NO JOB NUMBER
	MOV	JOBTBL(R2),R1	;;;GET POINTER TO JOB DATA BLOCK
	BEQ	130$		;;;WHOOPS! JOB WENT AWAY!
	MAP	PUSH,APR=5,DATA	;;;Save APR5 data mapping		;013
	MAP	FIPPOL		;;;Map the FIP pool for IOB contents	;013
	MOV	@(R1)+,R4	;;;Get a pointer to job's console DDB	;013
.ASSUME	JDIOB	EQ	0
	MAP	POP,APR=5,DATA	;;;Restore DPAR5 mapping		;013
	MOVB	DDUNT(R4),R3	;;;GET THE UNIT NUMBER
	CMPB	R2,DDJBNO(R4)	;;;DOES JOB OWN THE DDB
	BNE	110$		;;;NO
	BIT	#DDCONS,DDCNT(R4) ;;;IS THIS THE CONSOLE KB
	BNE	120$		;;;YES
110$:	COM	R3		;;;JOB IS DETACHED. FLAG IT
120$:	MOV	R3,(R5)+	;;;STORE THE KB NUMBER IN THE MESSAGE
	MOV	JDJDB2-JDFLG(R1),R4 ;;;GET POINTER TO SECOND JOB DATA BLOCK
	MOV	J2PPN(R4),(R5)+ ;;;STORE THE PPN
	MOV	R0,-(SP)	;;;Save current field pointer		;013
	MOV	R1,-(SP)	;;;And save JDB @ JDFLG pointer		;013
	MOV	R2,R0		;;;Copy job # * 2			;013
	CALLX	MAPJCR		;;;Map this job's JCR entry		;013
	MOV	JCNAME(R1),(R5)+ ;;; Save first part of program name	;013
	MOV	JCNAME+2(R1),(R5)+ ;;;  Save second part of program name ;013
	MAP	BUFMMU,APR=6,DATA ;;;Restore APR6 mapping		;013
	MOV	(SP)+,R1	;;;Restore JDB @ JDFLG pointer		;013
	MOV	(SP)+,R0	;;;And restore field pointer		;013
	MOV	JDMCTL+M.PHYA-JDFLG(R1),(R5)+ ;;;STORE THE PHYSICAL ADDRESS
	MOV	JDSIZE-JDFLG(R1),(R5)+ ;;; AND THE SIZE AND CONTROL DATA
	MOV	JDRTS-JDFLG(R1),R4 ;;;POINT TO THE RTS BLOCK
	TST	(R4)+		;;;SKIP TO R.NAME
	MOV	(R4)+,(R5)+	;;;STORE THE RTS NAME
	MOV	(R4)+,(R5)+	;;; TWO WORDS
	MOV	R.MCTL+M.PHYA-R.DEXT(R4),(R5)+ ;;;  AND THE PHYSICAL ADDRESS
	BR	150$		;;;NOW CONTINUE

130$:	SUB	#9.*2,12-40(R4)	;;;CORRECT THE BYTE COUNT
140$:	CLRB	-2(R5)		;;;CORRECT FIELD COUNT

GLOBAL	<JOBTBL>

; FILL IN THE REMAINING FIELDS

150$:	MOV	#1,R3		;;;SET CURRENT FIELD TO 1
160$:	MOVB	(R0)+,R1	;;;GET THE NUMBER OF WORDS
	BMI	210$		;;;FINISHED IF NEGATIVE
	MOVB	(R0),R4		;;;GET THE FIELD NUMBER
	BPL	170$		;;;SKIP IF PLUS
	NEG	R4		;;;MAKE IT POSITIVE
170$:	CMP	R3,R4		;;;DID THE FIELD CHANGE?
	BHIS	180$		;;;NO
	INC	R3		;;;YES. BUMP FIELD COUNT
	MOV	R5,R2		;;;SAVE POINTER TO THE HEADER
	CLRB	(R5)+		;;;SET NUMBER OF WORDS TO ZERO INITIALLY
	MOVB	R3,(R5)+	;;;SET THE FIELD NUMBER
	BR	170$		;;;LOOP FOR NEXT FIELD NUMBER

180$:	ADD	R1,(R2)		;;;ADJUST THE WORD COUNT
	TSTB	(R0)+		;;;IS THIS A STORE REQUEST?
	BMI	200$		;;;NO
	MOV	(R0)+,R4	;;;GET THE ADDRESS
190$:	DEC	R1		;;;MORE TO STORE?
	BMI	160$		;;;NO, DONE, DO NEXT FIELD
	MAP	PUSH,APR=5,DATA	;;;Save the present APR5 mapping	;011
	MAP	FIPPOL		;;;MORE, MAP FIP POOL (FOR FCB'S + WCB'S)
	MOV	(R4)+,-(SP)	;;;GET A WORD
	MAP	BUFMMU,APR=6,DATA ;;;AND MAP OUR MESSAGE BUFFER AGAIN
	MOV	(SP)+,(R5)+	;;;PUT THE WORD IN THE BUFFER
	MAP	POP,APR=5,DATA	;;;Restore the present APR5 mapping	;011
	BR	190$		;;; AND LOOP FOR MORE

200$:	MOV	(R0)+,CALADR	;;;SET THE CALL ADDRESS
	CALL	FLPREG		;;;FLIP R0-R4 WITH THE STACK
	CALL	@CALADR		;;;CALL THE REQUESTED ROUTINE

;+
; CONDITIONS AT TIME OF RE-CALL TO CALLER'S FIELD ROUTINE.
;
;	R0-R4 = VALUE WHEN LAST IN CALLER'S ROUTINE(S)
;	R5 -> ERROR LOG LARGE DATA BUFFER
;	APR 6 (MIGHT) MAP THE LARGE DATA BUFFER
;	PRIORITY IS PR7
;
;	...
;
;	RETURN
;
;	R5 -> UPDATED ERROR LOG LARGE DATA BUFFER
;-

	CALL	FLPREG		;;;FLIP R0-R4 WITH THE STACK
	BR	160$		;;;GET NEXT ENTRY

; CHECK IF THIS IS A REPEAT

210$:	MOV	RCVRIB,R2	;;;GET THE RECEIVER'S RIB		;003
	ADD	#S.MLST,R2	;;;POINT TO THE MESSAGE ROOT
	MOV	(R2)+,R0	;;;GET FIRST ERROR MESSAGE ON THE STACK
	BEQ	270$		;;;NO ERROR MESSAGES
	CMPB	@ERLSIZ-2(SP),#ERC$KT ;;;PROCESSOR TYPE ERROR??
	BHI	270$		;;;NOPE, SO DON'T CHECK FOR REPEAT(S)
.ASSUME	ERC$DV	GT	ERC$KT						;009
220$:	MOV	R0,R3		;;;COPY PMB POINTER
	MOV	#16,R4		;;;SET OFFSET TO "LAST FIELD"
	ADD	R4,R3		;;;GO TO "LAST FIELD" IN THE PMB
	ADD	(SP),R4		;;;POINT TO "LAST FIELD" IN CURRENT PMB
	CMPB	(R3),(R4)	;;;SAME FIELD?
	BNE	260$		;;;NO
	CMP	-(R3),-(R4)	;;;SAME JOB AND ERROR?
	BNE	260$		;;;NO
	CMP	-(R3),-(R4)	;;;SAME COUNT
	BNE	260$		;;;NO
	MOV	P$BUFA(R0),R1	;;;GET POINTER TO LARGE BUFFER
	MAP	PUSH,APR=5,DATA	;;;SAVE PAR5
	BIT	R1,#37		;;;MONITOR IN POOL?
	BEQ	230$		;;;YES
	ASHC	#-7,R1		;;;FORM THE MMU ADDRESS
	MAP	R1,APR=5,DATA	;;;SET THE MMU FOR THE PAR5 WINDOW
	MOV	#120000,R1	;;; AND GET A NEW POINTER
230$:	MOV	(R4),R3		;;;GET THE BYTE COUNT
	ASR	R3		;;; AND MAKE IT A WORD COUNT
	ADD	#BUFHDR,R1	;;;SKIP THE POSTING HEADER
	MOV	4(SP),R5	;;;GET MAPPED POINTER TO LARGE BUFFER
240$:	CMP	(R5)+,(R1)+	;;;ARE THEY THE SAME
	BNE	250$		;;;NO
	SOB	R3,240$		;;;LOOP OVER ALL STORED WORDS
	INCB	17(R0)		;;;GOT A MATCH. BUMP THE REPEAT COUNT
	MAP	POP,APR=5,DATA	;;;RESTORE PAR5
	MOV	(SP)+,R4	;;;GET PMB ADDRESS
	BUFFER	RETSML		;;;RETURN THE PMB
	TST	(SP)+		;;;POP MAPPED BUFFER ADDRESS
	MOV	(SP)+,R4	;;;GET THE REAL LARGE BUFFER ADDRESS
	BUFFER	RETURN		;;;RETURN IT
	BR	290$		;;;CLEAN UP AND EXIT

250$:	MAP	POP,APR=5,DATA	;;;RESTORE PAR5
260$:	MOV	(R0),R0		;;;GET THE NEXT BUFFER
	BNE	220$		;;; AND LOOP IF MORE


; LINK THE NEW MESSAGE

270$:	MOV	(SP)+,R4	;;;RESTORE PMB POINTER
	MOV	R4,@(R2)+	;;;QUEUE PMB TO LAST IN LIST
	MOV	R4,-(R2)	;;; AND SET IT AS THE NEW TAIL
	INCB	S.MCNT-<S.MLST+2>(R2) ;;;COUNT AS ANOTHER QUEUED MESSAGE
	CMP	#ERLRIB,RCVRIB	;;;ERROR LOGGING RIB?			;003
	BNE	280$		;;;NO					;003
	INC	ERLSEQ		;;;YES, COUNT AS LOGGED
280$:	MOV	(SP)+,R5	;;;RESTORE MAPPED LARGE BUFFER ADDRESS
	MOV	P$BREM(R4),-(R5) ;;; AND SET THE 'DATA SIZE' IN HEADER
.ASSUME	BUFHDR	EQ	BF.CNT+2
	MOV	(SP)+,R5	;;;GET THE BUFFER'S 'ADDRESS'
	BIT	R5,#37		;;;IS BUFFER FROM THE MONITOR POOL?
	BNE	290$		;;;NO
	SUB	(R5),S.BMAX-<S.MLST+2>(R2) ;;;SAY MORE BYTES ARE BUFFERED
290$:	MAP	SAVKA6,APR=6,DATA ;;;RESTORE PAR6
	ADD	#6*2,SP		;;;REMOVE SAVED REGISTERS FROM STACK
300$:	MOV	RCVRIB,R4	;;;SAVE THE RECEIVER'S RIB		;003
	MOVB	S.JBNO(R4),R4	;;;GET THE RECEIVER'S JOB NUMBER *2
	CALLX	IOFIN4,R5,JSTIM	;;; AND AWAKEN THAT JOB
	DEC	ERLCHK		;;;CORRECT THE RE-ENTRY CHECKER
310$:	CALLX	REGRES,R5	;;;RESTORE ALL REGISTERS
	JMPX	RTIMON		;;;RETURN thru common time portal	;015

GLOBAL	<ERLRIB>

; INTERCHANGE THE CURRENT R0-R4 WITH THOSE WE SAVED ON THE STACK

FLPREG:	MOV	R5,-(SP)	;;;SAVE R5
	MOV	SP,R5		;;;GET THE CURRENT STACK POINTER
	ADD	#ERLSIZ+4-4,R5	;;;POINT TO R4 ON THE STACK
	MOV	(R5),-(SP)	;;;SAVE OLD R4
	MOV	R4,(R5)		;;;PUT NEW R4 ON THE STACK
	MOV	(SP),R4		;;; AND THE STACK'S OLD R4 -->R4
	MOV	-(R5),(SP)	;;;SAME
	MOV	R3,(R5)		;;; FOR
	MOV	(SP),R3		;;;  R3
	MOV	-(R5),(SP)	;;;SAME
	MOV	R2,(R5)		;;; FOR
	MOV	(SP),R2		;;;  R2
	MOV	-(R5),(SP)	;;;SAME
	MOV	R1,(R5)		;;; FOR
	MOV	(SP),R1		;;;  R1
	MOV	-(R5),(SP)	;;;SAME
	MOV	R0,(R5)		;;; FOR
	MOV	(SP)+,R0	;;;  R0
	MOV	(SP)+,R5	;;;RESTORE R5
	RETURN			;;;MISSION ACCOMPLISHED

.SBTTL	PROCESSOR ERROR LOGGING ROUTINES

.ENABL	LSB

.SBTTL	MEMORY PARITY/ECC ERROR

	ERRENT	LOG$PA

.ASSUME	ERC$PA	EQ	LOG$PA&377/2+1

	CALL	40$		;;;DO THE COMMON STUFF
	MOV	#CTRLEV,(R1)	;;;STARTING LOCATION OF DATA
	MOV	UPELSZ,-(R1)	;;;N WORDS, FIELD 4, LET LOGGED FILL IT IN
	RETURN			;;;NOW RETURN

GLOBAL	<CTRLEV,UPELSZ>

.SBTTL	MEMORY MANAGEMENT ERROR

	ERRENT	LOG$KT

.ASSUME	ERC$KT	EQ	LOG$KT&377/2+1

	CALL	40$		;;;DO THE COMMON STUFF
	MOV	#10$,(R1)	;;;ADDRESS OF SERVICE ROUTINE
	MOV	#-4*400+3,-(R1)	;;;3 WORDS, FIELD 4, CALL
	MOV	@#MMUSR0,R4	;;;SAVE MAIN MMU STATUS REGISTER
	RETURN			;;;ALL DONE FOR NOW

10$:	MOV	R4,(R5)+	;;;STORE MAIN MMU STATUS REG IN THE LOG
	MOV	R4,R3		;;;COPY IT
	BIC	#^C<36>,R3	;;;FIND THE FAILING APR REG # TIMES 2
	ASLB	R4		;;;WHICH MODE?
	BMI	15$		;;; User				;016
	ASLB	R4		;;; Check Kernel or Supervisor		;016
	BPL	20$		;;;  KERNEL
	ADD	#SISDR0-UISDR0,R3 ;;; SWITCH TO Supervisor REGISTERS	;016
15$:	ADD	#UISDR0-KISDR0,R3 ;;;USER, SWITCH TO USER MODE REGISTERS
20$:	MOV	KISDR0(R3),(R5)+ ;;;STORE FAILING DESCRIPTION REG
SAVARX:	ADD	#KISAR0,R3	;;;POINT TO FAILING ADDRESS REG
	MOV	(R3),(R5)+	;;;SAVE FAILING ADDRESS REG
	CMP	R3,DPAR6	;;;WAS IT "DPAR6" (OR STAND-IN KISAR6)?
	BNE	30$		;;;NO
	MOV	SAVKA6,-2(R5)	;;;YES, USED SAVED VERSION
30$:	RETURN			;;;NOW RETURN

GLOBAL	<DPAR6>

.SBTTL	UNEXPECTED INTERRUPT

	ERRENT	LOG$UI

.ASSUME	ERC$UI	EQ	LOG$UI&377/2+1

	CALL	40$		;;;DO THE COMMON STUFF
	MOV	#FTLVEC,(R1)	;;;POINTER TO ERRING VECTOR ADDRESS
	MOV	#4*400+1,-(R1)	;;;1 WORD, FIELD 4, LET LOGGER FILL IT IN
	RETURN			;;;NOW RETURN

GLOBAL	<FTLVEC>

.SBTTL	JUMP TO 0

	ERRENT	LOG$J0

.ASSUME	ERC$J0	EQ	LOG$J0&377/2+1

.SBTTL	TRAP THROUGH 4

	ERRENT	LOG$T4

.ASSUME	ERC$T4	EQ	LOG$T4&377/2+1

.SBTTL	RESERVED INSTRUCTION TRAP

	ERRENT	LOG$RI

.ASSUME	ERC$RI	EQ	LOG$RI&377/2+1

.SBTTL	POWER FAILURE

	ERRENT	LOG$PF

.ASSUME	ERC$PF	EQ	LOG$PF&377/2+1

.SBTTL	CACHE FAULT

	ERRENT	LOG$CP							;014

.ASSUME	ERC$CP	EQ	LOG$CP&377/2+1					;014

40$:	MOV	#ERLSIZ+2,R0	;;;SET THE OFFSET FOR SAVED DATA
	BR	50$		;;; AND GO SET UP

.SBTTL	CHECKSUM ERROR

	ERRENT	LOG$CK

.ASSUME	ERC$CK	EQ	LOG$CK&377/2+1

	MOV	#ERLSIZ+2+<8.*2>,R0 ;;;SET THE OFFSET FOR THE REGISTERS

.SBTTL	COMMON PROCESSOR ERROR HANDLING ROUTINE

50$:	MOV	R0,-(SP)	;;;SAVE R0
	MOV	#ERLCPU,R1	;;;POINT INTO CONTROL TABLE
	MOV	R1,R5		;;; AND COPY THAT POINTER
	MOV	#-1,-(R5)	;;;ENSURE A TERMINATING -1
	MOV	(R5),-(R5)	;;; HERE ALSO IF SHORT
	MOV	(R5),-(R5)	;;;  ENTRY
	MOV	R1,-(R5)	;;;SET POINTER TO CPU SPECIFIC DATA
	MOV	#2*400+2,-(R5)	;;;2 WORDS, FIELD 2
	MOV	#60$,R0		;;;NOW GET CPU SPECIFIC DATA TABLE POINTER
	MOV	@(R0)+,(R1)+	;;;SAVE THE SYSTEM (CPU) SERIAL NUMBER
	MOV	@(R0)+,(R1)+	;;;SAVE THE CPU ERROR REGISTER
	CLR	@(R0)+		;;; THEN CLEAR IT OUT...
	CALL	@(R0)+		;;;CALL FOR MORE IF NEEDED
	MOV	#ERLCF2,-(R5)	;;;SET COMMON FIELD 2 ROUTINE
	MOV	#-2*400+16.,-(R5) ;;;16. WORDS, FIELD 2, CALL
	MOVB	JOB,-(R5)	;;;FILL IN JOB NUMBER *2
	ASRB	-(R5)		;;;NOW FORM THE
	INCB	(R5)		;;; CORRECT ERROR CODE
	MOV	#ERLCF4,R1	;;;SET POINTER FOR FIELD 4 INFORMATION
	MOV	(SP)+,R0	;;;RESTORE R0
	RETURN			;;; THEN EXIT

$$ESID	==	.	;**INIT** CHANGED TO '177764' IF CPU ID
60$:	.WORD	ZERO		;POINTER TO CPU ID
$$ECPU	==	.	;**INIT** CHANGED TO '177766' & '177766' IF CPU ERROR
	.WORD	ZERO		;POINTER FOR READING CPU ERROR REGISTER
CLRCPE::.WORD	JUNK		;POINTER FOR CLEARING CPU ERROR REGISTER
$$EMED	==	.	;**INIT** CHANGED TO '$$RTSP' IF NO "MED" CODE
	.WORD	DOMED		;ROUTINE TO READ "MED" INFORMATION

.DSABL	LSB

GLOBAL	<ZERO,JUNK,DOMED>

.SBTTL	COMMON ROUTINE FOR PROCESSOR ERROR FIELD 2

;	R0 = STACK DEPTH TO ERROR LOGGING INFORMATION
;
;	R4 MUST BE PRESERVED

ERLCF2:	MOV	SP,R1		;;;GET THE CURRENT STACK LOCATION
	ADD	R0,R1		;;;POINT TO THE SAVED REGISTERS
	MOV	#6,R3		;;;6 REGISTERS TO SAVE
10$:	MOV	(R1)+,(R5)+	;;;STORE A REGISTER
	SOB	R3,10$		;;;LOOP TILL DONE
	CMP	R0,#ERLSIZ+2	;;;DOES THE PC/PS FOLLOW R0-R5 DATA?
	BNE	20$		;;;YEP
	CMP	(R1)+,(R1)+	;;;NOPE, MUST SKIP 2 MORE WORDS HERE
20$:	MOV	(R1)+,R3	;;;GET THE PC
	MOV	R3,(R5)+	;;;STORE IT
	ASH	#-13.+1,R3	;;;SHIFT IT DOWN
	BIC	#^C<16>,R3	;;;LEAVE APR BITS TIMES 2 ONLY
	SPLC	7		;;;ENSURE PREVIOUS MODE AS USER
	MOV	(R1)+,(R5)+	;;;STORE THE PS
	BMI	25$		;;;User mode				;016
	BIT	#40000,-2(R1)	;;;Kernel or Super?			;016
	BEQ	30$		;;;KERNEL MODE				;016
	BIC	#20000,@#PS	;;;Make previous mode Supervisor	;016
	ADD	#SISAR0-UISAR0,R3 ;;;Super mode. Switch registers	;016
25$:	ADD	#UISAR0-KISAR0,R3 ;;;USER MODE. SWITCH TO USER REGISTERS
	MFPD	SP		;;;GET USER MODE SP STACK POINTER	;007
	MOV	(SP)+,R1	;;; INTO HERE
	BR	40$		;;;SKIP KERNEL MODE STUFF

30$:	MOV	#PR7&4340,@#PS	;;;KERNEL. SET PREVIOUS=KERNEL
40$:	CALL	SAVARX		;;;STORE THE MMU ADDRESS REGISTER
	MOV	R1,(R5)+	;;;SAVE THE SP ADDRESS
	CALL	ERLSP		;;;Save (SP) and 2(SP)			;006
; Save -6(PC) thru (PC)							;004
	MOV	-14(R5),R1	;;; Get the old PC address		;004
	MOV	@#KISAR5,R0	;;; IPAR5 is unchanged. Get it		;004
	MOV	SAVKA6,R3	;;; Get saved D-space reg		;004
	CMP	DPAR6,#KISAR6	;;; Used for I also?			;004
	BEQ	ERLPC		;;; Yes, go save (PC), etc.		;004
	MOV	@#KISAR6,R3	;;; No, so get real I-space reg		;004
	.CALLR	ERLPC		;;; Go save -6(PC) thru (PC)		;004

.SBTTL	ERLPC - log data around (PC)

;+									;004
; ERLPC  - Save -6(PC) thru (PC)					;004
; ERLPC2 - Save (PC) thru 6(PC)						;004
;									;004
;	R1 = Old PC							;004
;	R0 = Old IPAR5 value						;004
;	R3 = Old IPAR6 value						;004
;	R5 -> Save area							;004
;	Previous mode is kernel						;004
;									;004
;	CALLX	ERLPC							;004
;									;004
;	R1	Old PC + 2						;004
;	R0, R3	Unchanged						;004
;	R2	Random							;004
;	R5	Updated save area pointer				;004
;									;004
; This routine is also called from CRA phase!				;004
;-									;004

ERLPC::	SUB	#6,R1		;;; Build PC - 6, is it negative?	;005
	BCC	ERLPC2		;;; No, proceed as usual		;005
	CLR	R1		;;; Yes, set it to zero			;005
ERLPC2::BIC	#1,R1		;;; Ensure an even peeking address	;004
	MAP	PUSH,APR=5,CODE	;;; Save current IPAR5			;004
	MAP	PUSH,APR=6,CODE	;;; Save current IPAR6			;004
	MAP	R0,APR=5,CODE	;;; Set IPAR5 to time of call		;004
	MAP	R3,APR=6,CODE	;;; Set IPAR6 to time of call		;004
	MOV	R4,-(SP)	;;; Get a scratch register		;012
	MOV	#4,R4		;;; Set up to get four words		;012
10$:	CALLX	PEEKER		;;; MOV (R1)+ in I-space into R2	;004
	MOV	R2,(R5)+	;;; Put the word into the save area	;012
	SOB	R4,10$		;;; Now loop for all four words		;012
	MOV	(SP)+,R4	;;; Restore caller's R4			;012
	MOV	@#KISAR5,R0	;;; Restore caller's R0			;012
	MAP	POP,APR=6,CODE	;;; Restore current IPAR6		;004
	MAP	POP,APR=5,CODE	;;; Restore current IPAR5		;004
	RETURN			;;; Return				;004

.SBTTL	ERLSP - Save (SP) thru 2(SP)

;+
; ERLSP - Save (SP) thru 2(SP)						;006
;									;006
;	R1 =  SP address						;006
;	R5 -> Save area pointer						;006
;									;006
;	CALL	ERLSP							;006
;									;006
;	R1 =  SP + 4							;006
;	R5 -> Updated save area pointer					;006
;-
ERLSP:	MOV	PC,-(SP)	;;;DO THE BELOW TWICE			;006
	MAP	PUSH,APR=6,DATA	;;;SAVE CURRENT PAR6 AND		;004
	MAP	SAVKA6,APR=6,DATA;;; SET PAR6 OF TIME OF CALL		;004
	BIC	#1,R1		;;;ENSURE AN EVEN PEEKING ADDRESS	;004
	CALLX	DPEEKR		;;;GET A DATA WORD			;004
	MAP	POP,APR=6,DATA	;;;NOW RESTORE CURRENT PAR6		;004
	MOV	R2,(R5)+	;;;FILL DATA INTO ERROR LOG		;004
	RETURN			;;;Now exit (eventually)		;006

.SBTTL	PASS MISSED ERRORS TO ERROR RECEIVER

;+
; ERLMSD - PASSED MISSED ERRORS TO ERROR RECEIVER.
;
;	R4 -> FIRQB
;	PRIORITY IS PR7
;
;	CALL	ERLMSD
;
;	R2,R3	Random							;010
;	C = 0	Missed errors, caller's FIRQB set up			;010
;	C = 1	No missed errors					;010
;-

.ENABL	LSB

ERLMSD::MOV	#ERLMIS,R2	;;;SET POINTER TO "ERLMIS" AND "ERLSEQ"
	MOV	(R2),R3		;;;GRAB THE MISSED ERROR COUNT
	SEC			;;;Assume no missed errors		;010
	BEQ	20$		;;;RETURN TO CALLER IF NO MISSED ERRORS
	SUB	#256.,(R2)	;;;REDUCE THE MISSED COUNT BY 256.
	BHI	10$		;;;MORE IN MISSED COUNT, PASS 256.
	CLR	(R2)		;;;ELSE CLEAR OUT THE MISSED COUNT
10$:	SUB	(R2)+,R3	;;;CORRECT THE REPEAT COUNT (# MISSED) +1
	INC	(R2)		;;;PRE-BUMP SEQ NUMBER FOR NEXT TIME
	MOV	(R2),R2		;;;GET PRE-BUMPED ERROR SEQUENCE NUMBER
	SPLC	3		;;;DROP TO PRIORITY 3
	DEC	R2		;CORRECT ERROR SEQUENCE NUMBER
	DEC	R3		;Form repeat count			;010
	SWAB	R3		;PUT REPEAT COUNT IN HIGH BYTE
	CMP	(R4)+,(R4)+	;INDEX TO DATA PORTION OF FIRQB
BLDPMB:	MOV	#-1&377,(R4)+	;DATA MESSAGE AND NO JOB
	CLR	(R4)+		;ZERO THE PPN
	CLR	(R4)+		;ZERO THE MESSAGE FLAGS WORD
	CLR	(R4)+		;NO BYTES REMAINING IN MESSAGE
	CLR	(R4)+		;SET CODE = MISSED, JOB = 0
.ASSUME	ERC$XX	EQ	0
	MOV	R3,(R4)+	;SET LAST FIELD AND REPEAT COUNT
	MOV	R2,(R4)+	;SET THE ERROR SEQUENCE NUMBER
	MOV	#DATE,R2	;SET POINTER TO DATE AND TIME PARAMETERS
	MOV	(R2)+,(R4)+	;SET DATE
	MOV	(R2)+,(R4)+	;SET TIME
	MOV	(R2)+,(R4)+	; AND SECONDS TO MIDNIGHT
	CLR	(R4)+		;ZERO THE 
	CLR	(R4)+		; SPARE WORDS
	CLR	(R4)+		;   FOR
	CLR	(R4)+		;    CLEANLINESS
	;CLC			;Indicate message built (C=0 from CLR)	;010
20$:	RETURN			;;;NOW EXIT

.DSABL	LSB

.END
