.INCLUDE	%CMN:COMMON.MAC%					;067
.INCLUDE	%CMN:KERNEL.MAC%					;067
.LIBRARY	%CMN:NETDEF.SML%
TITLE	RTI,<FLOW CONTROL, ETC.>,0B,21-JUN-91,MHB/ABC/SRM/SJM/JTC/GPK/FEK/DRP/AJK/WJS/GMB/FRL/KPH/MNB/SHL/PJH/JHC/WRM

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR RTI

;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;  001	TG   27-Jun-80	Added GEN phase stuff
;  002	RTW  09-Aug-80	Added Complex EMT stuff
;  003	RVR  27-Aug-80	SRCPAT for V7.0 patch 3.1.6 M
;  004	TG   10-Dec-80	Fixed source fix for 3.1.6 M
;  005	TG   15-Dec-80	Removed RSX phase
;  006	MDS  23-Mar-81	Changes to crash code to allow XBUF dumping
;  007  SRM  04-May-81	Finish development of crash/snap XBUF
;  008	SRM  26-Jun-81	Change the check for a crash while crashing
;  009  SJM  12-Jul-81	Added support for I&D space
;  010  SJM  29-Jul-81	Moved RELOAD: here from TBL
;  011	JTC  03-Aug-81	Improved comments on ODT linkage
;  012	GPK  10-Aug-81	Removed logging calls for errors that cause a crash
;  013	SJM  12-Aug-81	Fixed power fail recovery for I&D
;  014  SRM  24-Aug-81  Place branches after C.HLT1 and C.HLT2.
;  015	JTC  16-Sep-81	Put FIP in APR 6
;  016	SRM  13-Oct-81	Add FIP Pool managing code, change SETUP::
;  017	JTC  22-Oct-81	Allow FIPPOL option to "CALL BUFFER"
;  018  SRM  20-Nov-81	Put back error logging calls for errors that crash
;  019  JTC  20-Nov-81	Fix CHEEXT clobbering R4 bug.
;  020	FEK  08-Apr-82	Don't log errors from bad user peeks
;  021	DRP  13-Apr-82	Put patch article 3.1.5 into source.
;  022  AK   19-APR-82  Add RTI3PH label to RTI3 for MCP support
;  023  FEK  20-Aug-82	Source clear V7.2 patch 3.1.6 (parity error crash)
;  024  AJK  21-AUG-82  Added delay mechanism to 2nd level of L3Q
;  025  GMB  08-Dec-82  Remove error logging of crash errors
;  026	WJS  05-Nov-82	BUFFER documentation;  BUFFRZ, BUFFRL entries added
;  027  GMB  11-Jan-83	Small cleanup of crash macro handling code
;  028	WJS  19-Jan-83	Additional commenting for small buffer gets/returns
;  029  GMB  25-Jan-83  Don't reset MMU or clear CPU error reg if crashing
;			Don't error log power failures
;
;				[RSTS V9.0]
;  030	GPK  04-Mar-83	Job headers
;  031	GPK  17-May-83	Detect CRASH macro even on machines that trap to 4
;			rather than 10 for JMP PC; change J2HDRS to a byte
;  032	FEK  01-Jul-83	SUPPORT FOR USER I/D SPACE, AND MAKE SUPER=USER MODE
;			FOR TRAPPING RATHER THAN SUPER=KERNEL
;  033  FRL  25-Oct-83  Added extended level three queue (L3Q) capability
;  034	KPH  11-Jan-84	Support for EMTs in EM2 phase
;  035	KPH  19-Jan-84	Turn on MMU for user-initiated restarts
;  036  MNB  22-Jan-84  Asynch changes in M.CTRL byte
;  037  SHL  25-Jan-84	Add support for UU.CFG directive in $$PWRP
;  038	FEK  13-MAR-84	CHANGE PARITY TRAPPING FOR J11'S
;			AND Q-BUS RJ MMU TRAPPING SUPPORT
;  039  MNB  15-Mar-84  Add JFASTD bit check to RTI3 (Asynch AST delivery)
;  040	GPK  22-May-84	Count system ticks; don't double fault in trap 4 code
;  041	KPH  09-Jul-84	Move EMU to RSX phase
;  042	KPH  29-Aug-84	Add support for FIP pool in APR5
;
;			[RSTS V9.2]
;  043  KPH  25-Jul-85	Pass job number to BADRTS
;			Move GETFIP here from CTL
;			Add job control region
;
;			[RSTS V9.3]
;  044	JHC  25-Dec-85	Add COMBUF and COMRET for communications buffer
;			acquisitions.
;  045	JHC  30-Jan-86	Fix bug in COMBUF
;  046	KCG  17-Feb-86	Fix I-space bug in COMBUF
;  047  KPH  22-Feb-86	Change SYDAP5 to RSTAP5
;  048  KPH  25-Mar-86	Change COMBUF size
;  049  KPH  13-May-86	Remove references to DECnet globals
;  050  KPH  01-Jun-86	Change XBUF size return convention to slivers
;  051  KPH  04-Jun-86	Change BAKLRG convention to MMU address
;  052  KPH  17-Jun-86	Fix problem with traps from windows mapped into
;			physical memory
;  053  KPH  29-Jun-86	Generalize cache giveback mechanism
;			Move RETMON out of the root
;			Remove CHKMON/CHKEXT dummy P-sects
;			Fix problems with restarts
;			Add caching to comm buffers
;  054  KPH  12-Aug-86	Fix problems with ASKCHE on 18-bit systems
;			Add tracking of current L3Q process
;			Check zero for corruption
;			Add tracking of last interrupting routine
;			Fix corruption of zero in ALLOC
;  055  KPH  16-Oct-86	Fix crashes when small buffer pool is empty
;
;			[RSTS/E V9.4]
;  056	DWF  24-Feb-87	Don't change PSW on entry to CPLXMC
;  057	PJH  10-Feb-87	Merge GPK changes to source
;  058  WRM   2-Apr-87  Add FASTMAP call entry at IOT
;
;			[RSTS/E V9.5]
;  059  JHC  03-Jun-87	Fix COMBUF/COMRET to allow givebacks at any priority
;			(source clear 3.1.4 from V9.4)
;
;			[RSTS/E V9.6]
;  060  WRM  10-Dec-87	Add CSM instruction emulation for Supervisor mode
;  061  KPH  24-Feb-88	Changes for dynamic statistics
;  062	KCG  05-May-88	Move CRA52 to RTI .PSECT to allow MMU disabled 52G's
;			to work.
;  063	JFM  07-Jun-88	Keep count of idle communication buffers
;			Fix bug in buffer giveback routine, DPAR6 not saved
;
;			[RSTS/E V9.7]
;  064  WRM  28-DEC-88	Add Cache check/sweep at RTI3 & RTI47 when 0<>106
;			 (for ABEL DH11's on 11/70s)
;  065  WRM  28-Dec-88	Allow trap returns to supervisor mode
;  066  WRM  02-Feb-89	Fix IOT & ODT BPT from supervisor mode
;
;			[RSTS/E V10.0]
;  067  WRM  10-Jul-89	Fix trapping of MVTS$ to unmapped memory
;			Improve RTI3 crash intercept code
;-

.SBTTL	Define needed DECnet symbols

.MCALL	$CCB             

	$CCB		; Define CCB layout for buffer acquisition.



	DEFORG	RTIISP
	DEFORG	RTI
	DEFORG	RTICTL
	DEFORG	BUFCTL
	DEFORG	CHETBL							;053

	ORG	RTIISP

.SBTTL	CHECK FOR LOGGING AN ERROR

;+
; CHKERL - CHECK FOR ERROR LOGGING.
;
;	SP -> PC, PS, ...
;	CALLING JOB IS "JOB"
;
;	CALL	CHKERL,R5
;
;	FIRST EXIT MEANS ERROR LOG.
;	SECOND EXIT MEANS DON'T ERROR LOG.
;-

CHKERL:	MOV	R3,-(SP)	;;;GET A WORKING REGISTER TO
	MOV	2*2(SP),R3	;;; HOLD THE PC+2 OF THE TRAP
	CMP	3*2(SP),#37777	;;;FROM USER OR SUPER????		;032
	BLOS	10$		;;; NO, DON'T LOG IT			;032
	TST	3*2(SP)		;;;Yes, was it from user mode?		;043
	BPL	35$		;;;No, super, certainly not in RTS!	;043
30$:	CMP	R3,MAXHGH	;;;WAS TRAP FROM HIGH SEGMENT?
	BHI	40$		;;;YES, CHECK FOR NO ERROR LOGGING
35$:	CALLX	LIBADR		;;;CHECK FOR RESIDENT LIBRARY ADDRESS	;043
	BCC	10$		;;;NOPE, GO TAKE SECOND EXIT, NO ERROR LOG
	CMP	R3,#RIDMIN	;;;Is this a special region?		;052
	BHIS	10$		;;;Yes, no error logging		;052
	BR	50$		;;;No, check the LIB block		;052

40$:	MOV	JOBRTS,R3	;;;GET JOB'S RTS POINTER
50$:	BIT	#PF.NER,R.FLAG(R3) ;;;RTS/LIB WANT ERROR LOGGING?
	BEQ	20$		;;;YES, SO TAKE FIRST EXIT

10$:	TST	(R5)+		;;;DON'T ERROR LOG IT, TAKE SECOND EXIT
20$:	MOV	(SP)+,R3	;;;RESTORE WORKING REGISTER
	RETURN	R5		;;; AND EXIT

GLOBAL	<MAXHGH>

.SBTTL	BPT TRAP HANDLING

;+
; ALL BPT INSTRUCTIONS AND T-BIT TRAPS COME HERE.
;
; 1) BPT FROM USER MODE.
;
;	THE BPT IS RE-ROUTED TO THE USER THROUGH P.BPT.
;
; 2) BPT FROM KERNEL MODE.
;
;	UNLESS KERNEL MODE ODT IS INSTALLED THIS WILL
;	CAUSE THE SYSTEM TO CRASH JUST LIKE ANY RESERVED
;	INSTRUCTION.
;-

.ENABLE	LSB

	TMPORG	RTICTL

SVPAR6:	.BLKW	2		;SAVED KERNEL MODE PAR6 VALUE

	TMPORG	RTI		;SO IT'L ALWAYS BE AROUND

20$:	MOV	@#KISAR6,SVPAR6	;;;SAVE INTERRUPTED PAR6
	MOV	@DPAR6,SVPAR6+2	;;; AND TOTO TOO (D APR)
	MOV	#0,@#KISAR6	;;;SET ODT'S PAR6 VALUE
$$ODT6	==	.-4	;**INIT** ODT'S PAR6 IF KERNEL MODE ODT
	MOV	@#KISAR6,@DPAR6	;;; AND D-SPACE
	CALL	@#NOODT		;;;NOW ENTER ODT (OR 'NOODT' IF NO ODT)
$$ODTE	==	.-2	;**INIT** ODT'S ENTRY IF KERNEL MODE ODT
	MOV	@#SVPAR6,@#KISAR6 ;;;RESTORE INTERRUPTED PAR6
				;;;(ODT FETCHES ADDRESS OF SVPAR6 FROM
				;;; SOURCE OF THE MOV INSTRUCTION.)
	MOV	@#SVPAR6+2,@DPAR6 ;;;RESTORE INTERRUPTED PAR6 D-SPACE
	RTT			;;; AND EXIT FROM THE BREAKPOINT

	VECTOR	14,,PR7		;BPT COMES HERE

	TMPORG	RTI		;I LIKE THIS PSECT, LET'S STAY HERE
				; THE VECTOR MACRO TOOK US ELSE WHERE

	CMP	1*2(SP),#37777	;;;FROM SUPER OR USER MODE???		;032
	BLOS	20$		;;; NO					;032
	BIC	#200,@#PS	;;;YES, SPLC TO LEVEL 3, preserve modes	;066
	REGSAV			;SAVE ALL REGISTERS
	MOV	#P.BPT,R0	;RE-ROUTE THROUGH P.BPT
	JMP	RETUSR		;NOW GO DO THE RE-ROUTE

.DSABL	LSB

	UNORG

GLOBAL	<DPAR6>

.SBTTL	TRAP TO 0 TRAP HANDLING

;+
; FTL000 - A TRAP TO 0 COMES HERE WITH:
;
;	SP -> R3, PC, PS, ...
;
; ALL UNEXPECTED INTERRUPTS ARE ERROR LOGGED, BUT ELSEWISE IGNORED.
;-

.ENABL	LSB

FTL000::CLR	R3		;;;SAY VECTOR ADDRESS IS 0
	BR	10$		;;; AND GO ERROR LOG IT

.SBTTL	UNEXPECTED INTERRUPT HANDLING

;+
; ALL UNEXPECTED INTERRUPTS COME HERE.
;
; ALL UNEXPECTED INTERRUPTS ARE ERROR LOGGED, BUT ELSEWISE IGNORED.
;-

	TMPORG	RTICTL

FTLVEC::.BLKW			;SAVED VECTOR ADDRESS

	UNORG

FTLXX0::CALL	FTLXXX,R3	;;;CALL COMMON CODE
FTLXX1::CALL	FTLXXX,R3	;;;CALL COMMON CODE
FTLXX2::CALL	FTLXXX,R3	;;;CALL COMMON CODE
FTLXX3::CALL	FTLXXX,R3	;;;CALL COMMON CODE
FTLXX4::CALL	FTLXXX,R3	;;;CALL COMMON CODE
FTLXX5::CALL	FTLXXX,R3	;;;CALL COMMON CODE
FTLXX6::CALL	FTLXXX,R3	;;;CALL COMMON CODE
FTLXX7::CALL	FTLXXX,R3	;;;CALL COMMON CODE

FTLXXX:	MOV	@#PS,-(SP)	;;;THE PS CONTAINS THE LOW ORDER 4 BITS
	SUB	#FTLXX1,R3	;;;FIND HIGH ORDER 3 BITS *4	(000 0HH H00)
.ASSUME	FTLXX1	EQ	FTLXX0+4
	ASH	#2,R3		;;;SHIFT HIGH ORDER BITS	(00H HH0 000)
	BIC	#^C<17>,(SP)	;;;ISOLATE LOW ORDER 4 BITS	(000 00L LLL)
	BIS	(SP)+,R3	;;;MERGE LOW INTO HIGH		(00H HHL LLL)
	ASH	#2,R3		;;;FORM VECTOR ADDRESS		(HHH LLL L00)
10$:	MOV	R3,FTLVEC	;;; AND SAVE IT
	MOV	(SP)+,R3	;;;RESTORE THE SAVED R3 ('JSR R3,')
	LOG$UI			;;;LOG AN UNEXPECTED INTERRUPT
	JMP	110$		;;;BUT IGNORE IT ELSEWISE...		;060

.SBTTL	AT 10 TRAP HANDLING

;+
; ALL TRAPS THROUGH 10 COME HERE.
;
; 1) TRAP AT 10 FROM USER OR SUPERVISOR MODE.
;
;	If the trap came from either mode and was a CSM instruction	;060
;	and supervisor state is enabled and mapped then route via	;060
;	supervisor location 10 and emulate the CSM hardware.		;060
;		else:
;
; 2) TRAP AT 10 FROM USER MODE.
;
;	IF THE TRAP CAME FROM THE HIGH SEGMENT (RUN-TIME SYSTEM)
;	AND IF THAT RUN-TIME SYSTEM WANTS ERROR LOGGING THEN
;	THE TRAP IS LOGGED. IN ANY CASE, A RE-ROUTE TO THE USER
;	THROUGH P.BAD WITH A CODE OF B.10 IS TAKEN.
;
; 3) TRAP AT 10 FROM KERNEL MODE.
;
;	IF THE TRAP AT 10 OCCURED FROM LOCATIONS 0 OR 2 THEN THIS
;	TRAP IS REALLY A "JUMP TO 0". THAT CAUSES A SYSTEM CRASH
;	WITH A CODE OF -2.
;
;	If the instruction that caused the trap was the CRASH
;	instruction then cause a crash with a code of -4.
;
;	ELSE THE SYSTEM IS CRASHED WITH A CODE OF B.10.
;-

	VECTOR	10,,PR7		;TRAPS TO 10 COME HERE

	CALL	CSMEMU		;;; See if CSM instruction, if so do it	;060
	CALL	80$		;;; Check for jump to 0 or software crash ;031
	BR	90$		;;; Wasn't, so continue			;031

80$:	CMP	2+2(SP),#37777	;;; Trap from kernel mode?		;032
	BHI	82$		;;; No, user/supervisor, no process	;060
	CMP	2(SP),#2	;;; Jump to 0?				;031
	BLOS	70$		;;; Yes, go set error code
	MOV	R0,-(SP)	;;; Free up a register
	MOV	2+2(SP),R0	;;; Get the PC at the time of the trap	;031
	BIC	#1,R0		;;; Force it even			;040
	MFPI	-(R0)		;;; Get the inst. that caused the trap
	MOV	2(SP),R0	;;; Restore R0
	MOV	(SP)+,(SP)	;;; Move inst. down and pop stack
	CMP	(SP)+,(PC)+	;;; Is inst. CRASH macro?
	 CRASH
	BEQ	85$		;;; Yes, go set error code		;031
82$:	RETURN			;;; Nothing special, exit		;031

85$:	MOV	#-4,(SP)	;;; Set "SOFTWARE FORCED CRASH" err code ;031
	JMP	FTL2KM$		;;;  and crash

70$:	MOV	#-2,(SP)	;;; Set "JUMP TO 0" error code		;031
	JMP	FTL2KM$		;;;  and crash

NOODT:	TST	(SP)+		;;;POP RETURN ADDRESS FROM THE 'JSR'
90$:	CALL	CHKERL,R5	;;;ERROR LOG IT?
	LOG$RI			;;;YES, ERROR LOG TRAP TO 10
	SETERR	B.10,-(SP),WORD	;;;SET TRAP TO 10 ERROR CODE
	JMP	FTLTRP		;;; AND CHECK IT


.SBTTL	CSM instruction emulation


CSMEMU:	BIT	#XC$IDS,X.CON	;;;Filled in w/ RETURN by init if no I&D ;060
	BEQ	82$		;;;Illegal if no I&D hardware		;060
CSMLDS::			;;;return to buffer pool if no I&D	;060
	CMP	2*2(SP),#37777	;;;trap from Kernel mode?		;060
	BLO	98$		;;;yes, disallow			;060
	BIT	#2,@#MMUSR3 	;;;Super mode must be enabled		;060
		;note that #2 in MMUSR3=1 is an indicator that super	;060
		;mode is mapped because user-D is over mapped super-D	;060
		;therefore I/D in super must be on			;060
		;Restriction: seperate user-D/Super-D not supported	;060
	BEQ	98$		;;;No, no place to go			;060
	BIT	#7,@#SISDR0	;;;Is super-I PDR0 turned on (must be)	;060
	BEQ	98$		;;;No, (10) then not available		;060
	MOV	R0,-(SP)	;;;Make work space			;060
	MOV	R1,-(SP)	;;;Make work space			;060
	MOV	R2,-(SP)	;;;Make work space			;060
	MOV	<SYSTAK-4>,-(SP) ;;;Get addr +2 of trapped code		;060
	SUB	#2,(SP)		;;;Now addr of trapped instruction	;060
	MFPI	@(SP)+		;;;STK top now trapped instruction	;060
	CMP	#7027,(SP)	;;;Is it CSM #nnn (target follows)	;060
	BEQ	92$		;;; Yes					;060
	CMP	#7026,(SP)+	;;;Is it CSM (SP)+ (target on stack top	;060
	BNE	95$		;;;NO, therefore not a legal form CSM	;060
		;by decry these are the only two forms of CSM supported	;060
		;In CSM @(SP)+ the addr was put on user stk before CSM	;060
	MFPD	SP		;;;Get the inbound stk (user/super) ptr	;060
	MFPD	@(SP)+		;;;Replace it with top of that stk	;060
	BR	94$		;;;re-thread, with target on K.stk top	;060

92$:	TST	(SP)+		;;;Align stack				;060
	MOV	<SYSTAK-4>,R1	;;;Get addr of target in prev code	;060
	CALL	PEEKER		;;;Get daata word if possible		;060
	BNE	95$		;;;if non zero there was error		;060
	MOV	R2,-(SP)	;;;put value on stack			;060
	ADD	#2,<SYSTAK-4>	;;;Step trap addr over operand in line	;060
94$:				;;;K.STK top now target addr		;060
		;Believe it or K.stk is in balance via either path	;060
	; At the RTI exit from this code the stack will look like:	;060
	; Kernel SP->	contents of super location 10			;060
	;		PSW from user w/ Tbit=0, cc as is,cur mode=super;060
	; SYSTAK -->							;060
	;
	; Super SP->	Routine target address				;060
	;		PC past end of autovector (after CSM instr)	;060
	;		PSW w/condition codes clr (from CSM instr)	;060
	; User SP->	completion return address ($CMPAL or $CMPCS)	;060
	;		return address to in line code after CALL	;060
	;

	MOV	@#PS,R1		;;; Copy of current PSW			;060
	BIC	#7777,R1	;;;Clear out all but modes		;060
	MOV	<SYSTAK-2>,R2	;;;Copy of user mode PSW		;060
	MOV	R2,-(SP)	;;;Save a copy for super stack		;060
	BIC	#17,(SP)	;;;Clear the condition codes,T unchged	;060
		;(SP) now PSW to put on super stack (cur mode=caller)	;060
	BIC	#170020,R2	;;;Clear T-bit & modes			;060
	BIS	R1,R2		;;;R2 now psw for RTI (almost)		;060
	BIS	#40000,R2	;;;Now super will be cur mode after RTI	;060
	MOV	R2,<SYSTAK-2>	;;; Save it away for RTI		;060
		;active PSW is cur mode =k,prev mode U/S CSM from eithr	;060
	MFPD	SP		;;;Get the prev modes stack ptr to K.st	;060
	MOV	(SP)+,R0	;;;setup a pseudo super.stack ptr	;060
	MOV	@#PS,R1		;;;Copy of active psw			;060
	BIC	#20000,R1	;;;force copy prev mode=super		;060
	MOV	R1,@#PS		;;;active prev mode=super w/o PR0 probm	;060
	MTPD	-(R0)		;;;Put on super stack			;060
	MOV	<SYSTAK-4>,-(SP) ;;;Addr after CSM instruction (caller)	;060
	MTPD	-(R0)		;;;super stack it			;060
	MTPD	-(R0)		;;;addr of super routine was K.stk top	;060
	MOV	R0,-(SP)	;;;New S.stack ptr on K.stack top	;060
	MTPD	SP		;;;Set S.stack ptr in super space	;060
	MOV	(SP)+,R2	;;;Restore user's registers		;060
	MOV	(SP)+,R1	;;;Restore user's registers		;060
	MOV	(SP)+,R0	;;;Restore user's registers		;060
	MOV	#<SYSTAK-2>,SP	;;;Force K.stk to behave		;060
	MFPI	10		;;;contents of super loc 10 > K.stk top	;060
	RTI			;;;engauge warp drive, dest super mode	;060

95$:	MOV	(SP)+,R2	;;;Restore user's registers		;060
	MOV	(SP)+,R1	;;;Restore user's registers		;060
	MOV	(SP)+,R0	;;;Restore user's registers		;060
98$:				;;;Exit without register restore	;060
CSMLDE:: RETURN			;;;Its not a legal CSM, something else	;060


.SBTTL	AT 4 TRAP HANDLING

;+
; ALL TRAPS THROUGH 4 COME HERE.
;
; 1) TRAP AT 4 FROM USER MODE.
;
;	IF THE TRAP CAME FROM THE HIGH SEGMENT (RUN-TIME SYSTEM)
;	AND IF THAT RUN-TIME SYSTEM WANTS ERROR LOGGING THEN
;	THE TRAP IS LOGGED. IN ANY CASE, A RE-ROUTE TO THE USER
;	THROUGH P.BAD WITH A CODE OF B.4 IS TAKEN.
;
; 2) TRAP AT 4 FROM KERNEL MODE.
;
;	IF THE KERNEL MODE SP STACK VALUE IS BELOW THE STACK LIMIT
;	SETTING WHEN A TRAP AT 4 OCCURS THEN  THE SYSTEM IS CRASHED
;	WITH A CODE OF B.STAK.
;
;	IF THE TRAP AT 4 OCCURED FROM LOCATIONS 0 OR 2 THEN THIS
;	TRAP IS REALLY A "JUMP TO 0". THAT RESULTS IN A SYSTEM
;	CRASH WITH A CODE OF -2.
;
;	If the word preceding (PC) matches the CRASH macro, we assume	;031
;	this is a software forced crash and set a crash code of -4.	;031
;
;	IF THE TRAP AT 4 OCCURED BECAUSE OF THE .PEEK MONITOR CALL
;	OR FROM THE ERROR LOGGING "PEEK" ROUTINE THEN THE TRAP IS
;	IGNORED.
;
;	ELSE THE SYSTEM IS CRASHED WITH A CODE OF B.4.
;-

	VECTOR	4,,PR7		;TRAPS TO 4 COME HERE

	CMP	SP,#SL.VAL+400	;;;STACK LIMIT VIOLATION?
	BHIS	55$		;;;NOPE
	CLR	@STKLMT		;;;YEP, DISABLE STACK LIMIT CHECKING
	SETERR	B.STAK,CRASAV+776,WORD ;;;SET SP STACK OVERFLOW ERROR CODE
	JMP	FTLFSP		;;;GO CRASH DUMP

55$:	CALL	80$		;;; Check for jump 0 or CRASH macro case ;031
60$:	CALL	CHKERL,R5	;;;CHECK FOR ERROR LOGGING
	LOG$T4			;;;LOG A TRAP TO 4 ERROR
	BIT	#140000,1*2(SP)	;;;FROM USER MODE OR SUPER??		;038
	BNE	69$		;;;YES					;038
	CALLX	RJMAPD		;;;SEE IF RJ IS MAPPED			;038
	BNE	69$		;;; NO, SO SKIP THIS			;038
	MOV	R3,-(SP)	;;;GET A WORKING REGISTER		;038
	MOV	2(SP),R3	;;;GET THE FAILING PC			;038
	CMP	-(R3),#170700	;;; WAS IT A KG0: CSR ACCESS??		;038
	BLO	66$		;;;   NO!				;038
	CMP	(R3),#170704	;;; WELL, WAS IT??			;038
	BHI	66$		;;;   NO!, SO GO LOG IT			;038
	CALLX	DOKG11		;;; YES, SO GO DO THE EMULATION		;038
				;;;REALLY, STRANGE IF WE GET BACK HERE	;038
66$:	MOV	(SP)+,R3	;;;NOT THE KG, SO GET THE REAL REGS	;038
69$:	SETERR	B.4,-(SP),WORD	;;;INDICATE TRAP TO 4 ERROR
	BR	FTLTRP		;;; AND CHECK IT

GLOBAL	<SL.VAL,STKLMT,PWFSAV,CRASAV>


.SBTTL	FIS EXCEPTION TRAP HANDLING

;+
; THE FIS FLOATING POINT EXCEPTIONS COME HERE. ALL ARE
;	RE-ROUTED TO THE USER THROUGH P.FIS.
;-

	;VECTOR	244,,PR3	;FIS EXCEPTIONS COME HERE

$$FIS	==	.	;**INIT** @ 244 VECTOR PC IF NO ASYNC FPP
	REGSAV			;SAVE ALL REGISTERS
	MOV	#P.FIS,R0	;RE-ROUTE THROUGH P.FIS
30$:	JMP	RETUSR		;GO DO THE RE-ROUTE

.SBTTL	AT 250 TRAP HANDLING

;+
; ALL TRAPS THROUGH 250 COME HERE.
;
; 1) TRAP AT 250 FROM USER MODE.
;
;	IF THE TRAP CAME FROM THE HIGH SEGMENT (RUN-TIME SYSTEM)
;	AND IF THAT RUN-TIME SYSTEM WANTS ERROR LOGGING THEN
;	THE TRAP IS LOGGED. IN ANY CASE, A RE-ROUTE TO THE USER
;	THROUGH P.BAD WITH A CODE OF B.250 IS TAKEN.
;
; 2) TRAP AT 250 FROM KERNEL MODE.
;
;	IF THE TRAP AT 250 WAS A "SEGMENT LENGTH VIOLATION" ON
;	PAR6 AND THE FAILING INSTRUCTION WAS "MOVB R2,(R5)" OR
;	"MOVB (R5),R2" (THESE COME FROM THE 'PUTUSR' AND 'GETUSR'
;	MACROS) THEN PAR6 AND R5 ARE MODIFIED AND THE FAILING
;	INSTRUCTION IS RE-DONE.
;
;	IF THE TRAP AT 250 OCCURED BECAUSE OF THE .PEEK MONITOR CALL
;	OR FROM THE ERROR LOGGING "PEEK" ROUTINE THEN THE TRAP
;	IS IGNORED (done in FTLTRP).					;067
;	
;	If the trap came from RSX (MVTS$) then the interrupt address gets ;067
;	changed to point to the user unmapped memory error entry in RSX	;067
;	and the trap is ignored at this level.				;067
;
;	ELSE THE SYSTEM IS CRASHED WITH A CODE OF B.250.
;
; IN ALL CASES THE MEMORY MANAGEMENT UNIT IS RESET BY RELOADING
;	ITS ENABLE BIT.
;-

	VECTOR	250,,PR7	;TRAPS TO 250 COME HERE

	CMP	1*2(SP),#37777	;;;FROM USER MODE OR SUPER??		;032
	BHI	130$		;;;YES					;032
	MOV	R0,-(SP)	;;;NO, GET A WORKING REGISTER
	MOV	@#MMUSR0,R0	;;;GET MMU STATUS REGISTER #0
	BIC	#^C<160156>,R0	;;;LEAVE ONLY ERR, MODE, PAGE
	CMP	R0,#040014	;;;IS IT: LEN, KERNEL, PAR6?
	BNE	35$		;;;NO, see if from MVTS$ then		;067
	MOV	1*2(SP),R0	;;;GET THE PC+2 OF FAILING INSTRUCTION
	MFPI	(R0)		;;;GET THE NEXT INSTRUCTION
	CMP	(SP)+,(PC)+	;;;IS IT
		INC R5		;;; FROM 'PUTUSR' OR 'GETUSR'?
	BEQ	50$		;;;yes-					;067
35$:	CMP	@#KISAR5,@#RSXAP5 ;;;is it from MVTS$ ?			;067
	BNE	120$		;;;No some unrecoverable failure	;067
	MOV	1*2(SP),R0	;;;GET THE PC+2 OF FAILING INSTRUCTION	;067+
	MFPI	-(R0)		;;;get instruction that failed		;067
	MOV	(SP)+,R0	;;;  and put it in R0			;067
	BIC	#100000,R0	;;;don't care if data or instruction	;067
	CMP	R0,(PC)+	;;; is it the following instruction	;067
	   MFPI	(R4)		;;; or MFPD (R4)			;067
	BEQ	40$		;;;yes- from MVTS$, we can recover	;067
	CMP	R0,(PC)+	;;;no, but is it the following?		;067
	   MTPI (R4)		;;;  or MTPD (R4)			;067
	BNE	120$		;;;no- it's hopeless then		;067
40$:	MOV	(SP)+,R0	;;;recover R0				;067
	MOV	(SP),R1		;;;save the fault address for testing	;067+
	MOV	@#ODTADP,(SP)	;;;turn the interrupt address into the 	;067
				;;;  error recover address, mapping is 	;067
				;;;  because we just tested it above	;067
	JMP	RTIMON		;;;Always pass thru the same time portal ;067

				;;; meet you in another space (EMU.MAC)	;067
50$:	MFPI	-(R0)		;;;GET TRAPPING INSTRUCTION
	CMP	(SP),(PC)+	;;;IS IT
		MOVB R2,(R5)	;;; FROM 'PUTUSR'?
	BEQ	100$		;;;YES
	CMP	(SP),(PC)+	;;;IS IT
		MOVB (R5),R2	;;; FROM 'GETUSR'?
	BNE	115$		;;;NO
100$:	TST	(SP)+		;;;YES,DICARD INSTRUCTION
	MOV	R0,1*2(SP)	;;;BACK UP TO RE-DO THE INSTRUCTION
	SUB	#14000,R5	;;;NOW BACK UP VIRTUAL (R5) POINTER AND
	ADD	#14000/100,@DPAR6 ;;; INCREMENT THE PAR6 VALUE
	MOV	(SP)+,R0	;;;RESTORE WORKING REGISTER
	MOV	#1,@#MMUSR0	;;;RE-START THE MMU TRACKING
110$:	JMP	RTI47		;;;EXIT IGNORING THE TRAP

115$:	TST	(SP)+		;;;DISCARD INSTRUCTION
120$:	MOV	(SP)+,R0	;;;RESTORE WORKING REGISTER
130$:	CALL	CHKERL,R5	;;;ERROR LOG THIS TRAP?
	LOG$KT			;;;ERROR LOG TRAP TO 250
	SETERR	B.250,-(SP),WORD ;;;SET TRAP TO 250 ERROR CODE
	.BR	FTLTRP		;;; AND CHECK ERROR

GLOBAL	<DPAR6,ODTADP>							;067

;+
; FTLTRP - ALL (POTENTIALLY) FATAL TRAPS COME HERE.
;
;	SP -> CODE, PC, PS, ...
;
; 1) IF FROM USER MODE.
;
;	RE-ROUTE THE TRAP THROUGH P.BAD WITH THE SUPPLIED
;	ERROR CODE RETURNED.
;
; 2) IF FROM KERNEL MODE.
;
;	IF THE TRAP WAS FROM THE .PEEK MONITOR CALL THEN SET
;	THE ERROR CODE FOR RETURNING IT TO THE USER, AND
;	EXIT.
;
;	IF THE TRAP WAS FROM THE ERROR LOG PEEK THEN TOTALLY
;	IGNORE THE TRAP.
;
;	ELSE CRASH THE SYSTEM INDICATING THE SUPPLIED ERROR CODE.
;-

FTLTRP:	CMP	2*2(SP),#37777	;;;FROM USER OR SUPER MODE??		;032
	BHI	150$		;;;YES, SET ERROR AND RE-ROUTE		;032
	CMP	1*2(SP),#ERLPOK	;;;FROM SPECIAL POKER?
	BEQ	140$		;;;YES
	CMP	1*2(SP),#ERLPEK	;;;FROM ERROR LOG?
	BEQ	140$		;;;YES
	CMP	1*2(SP),#ERLDPK	;;;FROM .PEEK PEEK?
	BNE	FTLFKM		;;;NO, GO CRASH THE SYSTEM
140$:	MOVB	(SP),R0		;;;YES, GET ERROR CODE TO R0
	BMI	FTLFKM		;;;<0, MUST BE REALLY FATAL
	MOV	2*2(SP),@#PS	;;;SIMPLE ERROR, DROP TO PEEK/POKE PRIORITY
	MOV	R2,SP		;;;FLUSH THE SP STACK
	MOV	R0,R2		;;;PUT THE ERROR CODE HERE
145$:	CLR	@CLRCPE		;;;ENSURE CPU ERROR REGISTER IS CLEARED
	MOV	#1,@#MMUSR0	;;;NOW RESET THE MMU
	;CLZ			;;;Z=0 (ERROR)
	RETURN			;;; AND BACK TO PEEK'S CALLER

FTL2KM:	BR	FTLFKM		;;; Intermediate branch point (trap to 10)

GLOBAL	<CLRCPE>

150$:	TSTB	(SP)		;;;FATAL TYPE ERROR CODE?
	BMI	FTLFKM		;;;YES, SO DIE...
	CALL	145$		;;;Reset some things
	SPLC	3		;;;NOW DROP TO LEVEL 3
	MOVB	(SP)+,@IOSTS	;SET THE ERROR CODE
	REGSAV			;SAVE ALL REGISTERS
	MOV	JOBF,R1		;GET JOB DATA POINTER @ JDFLG
	BIS	#JFIOKY,(R1)+	;INDICATE ERROR CODE TO POST
	MOV	#P.BAD,R0	;SET THE RE-ROUTE VECTOR
	CHKERR	B.PRTY,(R1)	;IS IT A PARITY ERROR?
	BNE	30$		;NOPE, DO A SIMPLE RE-ROUTE
	BIS	#JFSPCL,-(R1)	;YES, SET A SPECIAL CONDITION OF    
	BISB	#JFPRTY,JDFLG2-JDFLG(R1) ;PARITY ERROR
	BR	DMPJOB		;GO DUMP JOB AND CONTINUE

.DSABL	LSB

.SBTTL	CRASH THE SYSTEM!

;+
; FTLFKM - DO ORDERLY SYSTEM CRASH.
;
;	SP -> CODE, ...
;-

	TMPORG	RTI							;062

C52	=	-3.

CRA52::	MOV	#C52,-(SP)	;Indicate a crash through 52
	MOV	#1,@#MMUSR0	;Be sure MMU is turned on		;035
	JMP	FTLFKM		;Make sure this code comes next.	;062

	UNORG								;062

FTLFKM:	SPLC	7		;;;WE WILL CRASH THE SYSTEM
$$ODTB	==	.	;**INIT** CHANGED TO 'BPT' IF KERNEL MODE ODT
	NOP			;;;CALL KERNEL MODE ODT IF IT IS THERE
	MOV	(SP)+,CRASAV+776 ;;;SAVE ERROR CODE
FTLFSP:	SPLC	7		;;;ENSURE NO INTERRUPTS (& PREV=USER)
	CMP	HLTCRS,#CRSVER	;;;ARE WE CRASHING WHILE CRASHING?
	BEQ	C.HLT2		;;;YES, SO JUST HALT.
	MOV	#CRSVER,HLTCRS	;;;INDICATE THAT WE ARE CRASHING.
	MOV	@#KISAR5,CRASAV	;;;NO, SAVE APR5 REGISTER VALUE FOR ANALYS
	MOV	@DPAR5,CRASAV+2	;;;SAVE DAPR5 REGISTER VALUE FOR ANALYS
	MAP	CRAAP5,APR=5,CODE,DATA ;;;MAP THE CRA'SH PHASE
	CMP	#MAPVER,@CRAVER	;;;MAKE SURE WE GOT IT
	BNE	C.HLT1		;;;CAN'T DO MUCH IF ITS NOT MAPABLE
	BIC	#100,@CLKCSR	;;;IF WE TRAP TO NEVER NEVER LAND AND LOWER ;055
				;;; OUR PRIORITY, WE DON'T WANT THE CLOCK TO
				;;; INTERRUPT AND FURTHER OBSCURE THINGS.
				;;; SO PUNCH IT OUT BEFORE IT GETS US.
	JMP	@GOCRSH		;;;GO DER <-- (Dutch)

C.HLT2::HALT			;;;A HALT HERE MEANS WE CRASHED TWICE FAST
	BR	C.HLT2		;;;DON'T ALLOW HIM TO CONTINUE.
C.HLT1::HALT			;;;A HALT HERE MEANS THE CRASH PHASE COULD
	BR	C.HLT1		;;; NOT BE MAPPED.

	GLOBAL	<CRASAV,CRAVER,CRAAP5,GOCRSH,HLTCRS>

.SBTTL	TRAP TRAP HANDLING

;+
; ALL TRAP INSTRUCTIONS COME HERE.
;
; 1) USER MODE TRAPS.
;
;	RE-ROUTED TO THE USER THROUGH P.TRAP.
;
; 2) KERNEL MODE TRAPS FROM MONITOR STACK.
;
;	AN I/O ERROR CODE FOR JDIOST IS IN THE TRAP INSTRUCTION.
;	CONTROL PASSES TO IOEXIT WITH THE CODE IN R0.
;
; 3) KERNEL MODE TRAPS FROM FIP'S STACK.
;
;	AN ERROR CODE IS IN THE TRAP INSTRUCTION.
;	CONTROL PASSES TO FIPERR WITH THE CODE IN R0.
;-

	VECTOR	34,,PR3		;TRAP COMES HERE

	REGSAV			;SAVE ALL REGISTERS
	MOV	#P.TRAP,R0	;GUESS AT USER RE-ROUTE
	CMP	TOS.PS(SP),#37777 ;FROM USER OR SUPER MODE??		;032
	BLOS	10$		;No, not this time			;034
	JMP	RETUSR		;YES, RE-ROUTE IT			;034
10$:	MOV	TOS.PC(SP),R0	;NO, GET TRAP PC+2
	MFPI	-(R0)		;GET TRAP INSTRUCTION
	MOVB	(SP)+,R0	;NOW HAVE CODE FROM THE TRAP
	.BR	ERROR		;GO PROCESS THE ERROR

.SBTTL	ERROR REPORTING

;+
; ERROR - SET ERROR CODE.
;
;	R0 =  ERROR CODE
;
;	JMP	ERROR
;-

ERROR::	SPLC	3		;ENSURE LEVEL 3 ON ERRORS
	CMP	SP,#SYSTAK	;WHICH STACK ARE WE ON?
	BLOS	10$		;MONITOR'S STACK, I/O ERROR
	MAP	FIP,CODE,DATA	;(RE)SET FIP'S MAPPING
	JMP	@FIPERR		;GO TO FIP'S ERROR ROUTINE

10$:	MOVB	R0,@IOSTS	;SET THE I/O ERROR CODE

.SBTTL	EXIT FROM I/O

;+
; IOEXIT - EXIT WITH I/O COMPLETE (POSSIBLY WITH ERROR).
;
;	JMP	IOEXIT
;-

.ENABL	LSB

IOEXIT::MOVB	JOB,R0		;GET JOB NUMBER TIMES 2
	MOV	JBWAIT(R0),JBSTAT(R0) ;MAKE JOB RUNNABLE
	BR	10$		;GO CONTINUE

GLOBAL	<SYSTAK,FIPERR,JBWAIT,JBSTAT>

.SBTTL	RE-DO THE I/O REQUEST

;+
; IOREDO - EXIT WITH I/O PENDING (NEEDS RE-DOING).
;
;	JMP	IOREDO
;-

IOREDO::BIS	#JFREDO,@JOBF	;INDICATE I/O NEEDS RE-DO
	MOVB	JOB,R0		;GET JOB NUMBER TIMES 2
10$:	MOV	#SYSTAK-<8.*2>,SP ;RESET THE MONITOR'S STACK
	BIT	JBWAIT(R0),JBSTAT(R0) ;IS JOB RUNNABLE NOW?
	BNE	GORTI3		;YES, JUST CONTINUE WITHIN MONITOR

.SBTTL	FORCE A JOB NOT TO BE "JOB"

	L3QENT	QDUMP,,GENAP5	;FORCE A JOB OUT BEFORE "QSCHED" COMES HERE

	L3QENT	QFORCE,,GENAP5	;FORCE A JOB OUT AFTER "QSCHED" COMES HERE

.SBTTL	DUMP THE CURRENT JOB AND CONTINUE

;+
; DMPJOB - DUMP THE CURRENT "JOB".
;
;	JMP	DMPJOB
;
;	SP STACK IS RESET.
;-

DMPJOB::CALLX	SAVJOB,R5	;DUMP THE CURRENT JOB
	BR	GORTI3		; AND CONTINUE

.DSABL	LSB

GLOBAL	<SYSTAK,JBWAIT,JBSTAT,GENAP5>

.SBTTL	EMT TRAP HANDLING

;+
; ALL EMT INSTRUCTIONS COME HERE.
;
; 1) USER MODE EMTS.
;
;	IF NOT A MONITOR CALL THEN RE-ROUTED THROUGH P.EMT.
;	ELSE A MONITOR CALL IS MADE.
;
; 2) KERNEL MODE EMTS.
;
;	ALL KERNEL MODE EMTS ARE ERROR LOGGING CALLS.
;-

.ENABL	LSB

	VECTOR	30,,PR7		;EMT'S COME HERE

	REGSAV	INLINE		;;;SAVE ALL REGISTERS
	MOV	TOS.PC(SP),R0	;;;GET PC+2 OF THE EMT
	MFPI	-(R0)		;;;NOW GET THE EMT INSTRUCTION ITSELF
	MOVB	(SP)+,R0	;;;THEN GET THE EMT CODE
	CMP	TOS.PS(SP),#37777 ;;;CALL FROM USER OR SUPER?		;032
	BLOS	30$		;;;NO, ERROR LOGGING CALL		;032
	BIC	#200,@#PS	;;;Yes, drop PR3 (preserve prev. mode)	;056
CPLXMC::MAP	@UDPAR0,APR=6,DATA ;MAP TO USER'S 1ST 4K		;056
	MOV	JOBF,R1		;GET JOB DATA POINTER @ JDFLG
	MOV	#FIRQB+FQJOB+140000,R4 ;GET USER FIRQB POINTER @ FQJOB
	MOVB	JOB,(R4)	;ENSURE GOOD JOB NUMBER FOR USER
	MOV	JDRTS-JDFLG(R1),R5 ;GET RTS POINTER ALSO
	MOV	TOS.PC(SP),R3	;GET PC+2 OF THE EMT CALL
	BIT	#JFCEMT,(R1)	;IS THIS A COMPLEX EMT
	BNE	20$		;YES SKIP RTS PREFIX CHECK
	MOV	R.FLAG(R5),R2	;GET RTS'S FLAGS
	BPL	20$		;NO SPECIAL EMT PREFIX DESIRED
.ASSUME	PF.EMT	EQ	100000
	CMPB	R0,R2		;IS THE PREFIX CODE CORRECT?
	BNE	40$		;NO, RE-ROUTE IT
	TST	SYSTAK-2	;Call from supervisor mode?		;043
	BPL	5$		;Yes, so it must be from a library	;043
	CMP	R3,MAXLOW	;YES, WITHIN JOB IMAGE?
	BLO	10$		;YES
	CMP	R3,MAXHGH	;NO, WITHIN RTS?
	BHI	10$		;YES
5$:	MOV	R3,-(SP)	;NO, SAVE ADDRESS +2
	CALLX	LIBADR		;CHECK FOR WITHIN ANY MAPPED LIBRARY
	MOV	(SP)+,R3	;RESTORE ADDRESS +2
	BCC	40$		;NOPE, RE-ROUTE IT

GLOBAL	<MAXLOW,MAXHGH,UDPAR0,SYSTAK>					;043

10$:	MFPI	(R3)+		;O.K., GET NEXT INSTRUCTION
	MOVB	(SP),R0		;SET NEW EMT CODE
	CLRB	(SP)		;NOW CLEAR OUT THE CODE AND
	CMP	(SP)+,(PC)+	; CHECK FOR AN EMT INSTRUCTION
	 .WORD	EMT
	BNE	40$		;NOT AN EMT, RE-ROUTE
20$:	BIT	R0,#1		;IS THE EMT CODE ODD?
	BNE	40$		;YES, NOT A CALL, RE-ROUTE
	CMP	R0,#EMTSIZ	;IS CODE WITHIN LEGAL RANGE?
	BHIS	40$		;NO, NOT A CALL, RE-ROUTE
	MOV	R3,TOS.PC(SP)	;ALL O.K., UPDATE CALLING PC IF NEEDED
	BIS	#JFIOKY,(R1)+	;REMEMBER TO POST ERROR CODE AND KEY
	MOV	#^B<11100101>*400+0,(R1) ;SET NO ERROR AND XRB POSTING
	CMP	-(R1),-(R4)	;BACK TO JDB @ JDFLG AND (MAPPED) FIRQB TOP
	MOV	JDJDB2-JDFLG(R1),R2 ;GET POINTER TO SECOND JOB DATA BLOCK
	MOV	#XRB+140000,R3	;GET (MAPPED) POINTER TO USER'S XRB
	MOV	R0,LSTL3Q	;Save the EMT code * 2 for crashes	;054
	MAP	EMTAP5,APR=5,CODE,DATA ;ENSURE CORRECT MAPPING
	MOV	$EMTTBL(R0),-(SP) ;Pick up dispatch address		;034
	ASL	(SP)		;Is this in the EMT phase?		;034
	BCC	25$		;Yes, go for it				;034
	MAP	EM2AP5,APR=5,CODE,DATA ;EMT in EM2 phase, map it	;034
25$:	CALL	@(SP)+		;And execute it				;034
GORTI3:	JMP	RTI3		;RETURN THROUGH RTI3

GLOBAL	<EMTAP5,EM2AP5>

;+
; IF THIS IS A VALID MONITOR CALL THEN THE FOLLOWING IS
;	PASSED TO THE EMT ROUTINE.
;
;	R0 =  THE EMT CODE
;	R1 -> JOB DATA BLOCK OF CALLER @ JDFLG
;	R2 -> SECOND JOB DATA BLOCK OF CALLER
;	R3 -> (MAPPED) XRB OF CALLER
;	R4 -> (MAPPED) FIRQB OF CALLER
;	R5 -> RTS BLOCK BEING USED BY CALLER
;	SP -> "RTI3", R0, R1, R2, R3, R4, R5, PC, PS, ...
;
; THE JOB'S 1ST 4K IS MAPPED THROUGH DPAR6.
;
; NO ERROR IS INDICATED (JDIOST = 0).
;
; THE POSTING PATTERN IS XRB POSTING (<0 IN JDPOST).
;
; I/O STATUS POST IS INDICATED (JFIOKY).
; KEYWORD POSTING IS INDICATED (JFIOKY).
;-

GLOBAL	<$EMTTBL>

30$:	JMPX	ERL		;;;OFF TO ERROR LOGGING...

;+
; CONDITIONS UPON ENTRY INTO THE ERROR LOGGER ARE:
;
;	R0 =  ERROR LOG CODE (FROM THE ERROR LOG EMT)
;	R1 =  R1 AT TIME OF ERROR LOG CALL
;	R2 =  R2 AT TIME OF ERROR LOG CALL
;	R3 =  R3 AT TIME OF ERROR LOG CALL
;	R4 =  R4 AT TIME OF ERROR LOG CALL
;	R5 =  R5 AT TIME OF ERROR LOG CALL
;	SP -> R0, R1, R2, R3, R4, R5, PC, PS, PC, PS, ...
;-

40$:	MOV	#P.EMT,R0	;RE-ROUTE AS FOR EMT'S
	.BR	RETUSR		; AND GO DO IT

.DSABL	LSB

.SBTTL	RE-ROUTE TRAP TO USER ROUTINES

;+
; RETUSR - RE-ROUTE A TRAP TO THE USER.
;
;	R0 =  THE P.??? ADDRESS FOR THE RE-ROUTE
;	SP -> USER'S R0, R1, R2, R3, R4, R5, PC, PS, ...
;
;	JMP	RETUSR	(RETURN IS TO "RTI3")
;-

RETUSR::MOV	#RTI3,-(SP)	;SET RETURN ADDRESS TO "RTI3"
	.BR	RETUSX		; AND DO THE RE-ROUTE

;+
; RETUSX - RE-ROUTE A TRAP TO THE USER.
;
;	R0 =  THE P.??? ADDRESS FOR THE RE-ROUTE
;	SP -> USER'S R0, R1, R2, R3, R4, R5, PC, PS, ...
;
;	CALL	RETUSX
;
;	R0 =  RANDOM
;	R1 -> USER'S OLD PC/PS +4 (ON USER'S SP STACK)
;	R2 =  RANDOM
;	R4 =  RANDOM
;
;	IF C=0 THEN RE-ROUTE IS O.K.
;	IF C=1 THEN RE-ROUTE FAILED.
;-

RETUSX::CMP	JOBRTS,#NULRTS	;MONITOR RSX EMULATION?
	BEQ	50$		;YES, DO SPECIAL
	MOV	SP,R2		;FIND THE ADDRESS OF
	ADD	#7*2,R2		; SAVED USER PC/PS
	BIS	#30000,@#PS	;PREV mode=user, where vector is SPLC	;065
	MFPI	(R0)		;GET THE PSEUDO-VECTOR ADDRESS
	BIT	(SP),#1		;ODD?
	BNE	10$		;YES, THAT IS AN ERROR!
	CMP	(SP),MAXHGH	;EVEN, BUT WITHIN THE RTS?
	BHIS	20$		;INSIDE OF RTS, ALL O.K.
10$:	MOV	#40$,2(SP)	;ERROR, CHANGE THE RETURN ADDRESS
20$:	CALLX	CHKSTK		;CHECK USER'S SP STACK
	BCC	30$		;ALL O.K.
	MOV	#USRSP-<2*2>,R1	;BAD USER SP STACK, RESET THE STACK
	MOV	R1,(SP)		;GIVE THE RESET SP STACK BACK
	MTPD	SP		; TO THE USER
	SETERR	B.STAK,-(SP),WORD ;STACK ERROR CODE AS A WORD
	MOVB	(SP),@IOSTS	;PLACE ERROR CODE IN USER'S JOB DATA
	MTPD	@#FIRQB		;PLACE ERROR CODE IN USER'S JOB IMAGE
	MFPI	@#P.BAD		;CHANGE RE-ROUTE TO THE BAD TYPE ERROR
30$:	MOV	(R2)+,-(SP)	;RE-STACK USER'S OLD PC VALUE
	MTPD	(R1)+		; AND PUT IT ON THE USER'S STACK
	MOV	(R2),-(SP)	;RE-STACK USER'S OLD PS VALUE
	MTPD	(R1)+		; AND PUT IT ON THE USER'S STACK
	MOV	#PR0!170000,(R2) ;DUMMY IN A NEW PS VALUE FOR USER
	MOV	(SP)+,-(R2)	;NOW SET THE RETURN PC
	RETURN			; AND EXIT
		;Note- always returns to USER mode because all P.???	;065
		;are required to be in RTS				;065

40$:	LOG$CK			;LOG THE RTS TYPE ERROR
	MOVB	JOB,R0		;Get the job # * 2			;043
	MOV	JOBF,R1		;GET JOB DATA POINTER @ JDFLG
	MOV	JDRTS-JDFLG(R1),R2 ;GET POINTER TO "BAD" RTS
	CALLX	BADRTS		;GET RID OF THE BAD RTS
	JMP	DMPJOB		; THEN DUMP THIS JOB

50$:	MAP	PUSH,APR=5,CODE,DATA ;SAVE CALLING PAR5 VALUE
	MOV	RSXTRP,-(SP)	;STACK THE RSX SST/AST DISPATCH ADDRESS
	MOV	@#RSXAP5,-(SP)	;STACK THE PAR5 VALUE FOR THE RSX PHASE ;041
	JMPX	CALLMX		;GO DO RSX STYLE SST/AST HANDLING

GLOBAL	<NULRTS,MAXHGH,RSXTRP,RSXAP5>

.SBTTL	HANDLE BIG BUFFER (I/O BUFFER) GET/RETURN

;+
; RETBIG - RETURN A BIG (I/O) BUFFER.
;
;	R4 -> BIG BUFFER SUB-BLOCK (4 WORDS)
;		BGBUFF(R4) = BUFFER ADDRESS
;
;	CALL	RETBIG,R5,<SIZE OF BUFFER IN BYTES>
;
;		BGBUFF(R4) = 0
;-

.ENABL	LSB

RETBIG::MOV	R4,-(SP)	;SAVE SUB-BLOCK POINTER
	MOV	BGBUFF(R4),R4	; TO GET THE BUFFER ADDRESS
	BEQ	20$		;NONE...
	CMP	R4,#BGBUFR	;ONE, IS IT THE RESERVED BIG BUFFER?
	BNE	10$		;NOPE, GENERAL BUFFER, RETURN IT
	INC	FREES+6		;YEP, INDICATE IT IS AVAILABLE AGAIN
	BR	20$		; THEN CONTINUE

10$:	MOV	(R5),(R4)	;PLANT BUFFER SIZE IN THE BUFFER
	BUFFER	RETURN		; AND RETURN THE MONITOR POOL BUFFER
20$:	MOV	(SP)+,R4	;RESTORE THE SUB-BLOCK POINTER
	CLR	BGBUFF(R4)	; AND INDCATE NO BUFFER ALLOCATED NOW
	TST	(R5)+		;SKIP THE SIZE ARGUMENT
30$:	TST	BGBUFQ		;ANYTHING IN THE STALL QUEUE?
	BEQ	40$		;NOPE
	L3QSET	QBGBUF		;YEP, RUN UNSTALL CODE SOON
40$:	RETURN	R5		;NOW EXIT

GLOBAL	<BGBUFR>

;+
; GETBIG - GET A BIG (I/O) BUFFER.
;
;	R4 -> BIG BUFFER SUB-BLOCK (4 WORDS)
;	SP STACK IS 'CLEAN' FOR A "RTI3" EXIT
;
;	CALL	GETBIG,R5,<SIZE OF BUFFER IN BYTES>
;
;	R0 =  RANDOM
;	R1 =  RANDOM
;	R2 =  RANDOM
;	R3 =  BUFFER ADDRESS
;	R5 =  RANDOM
;	BGBUFF(R4) = BUFFER ADDRESS
;-


	L3QENT	QBGBUF,45$,RSTAP5 ;UNSTALL REQUESTS COME HERE		;047

	TMPORG	RTI

GETBIG::MOV	(R5)+,BGBUFF(R4) ;SAVE REQUESTED BUFFER SIZE
	MOV	R5,BGQRET(R4)	; AND THE RETURN ADDRESS
	TST	(SP)+		;NOW POP THE SAVED R5 (FROM 'JSR R5,')
	CALLX	QUEUER,R5,BGBUFQ ;NOW QUEUE INTO THE BIG BUFFER QUEUE
	BCC	60$		;NOT FIRST IN QUEUE, EXIT
45$:	MOV	#BGBUFR,R3	;PRESET THE RESERVED BUFFER ADDRESS
	MOV	BGBUFQ,R5	;GET THE FIRST IN QUEUE
	BEQ	60$		;NO MORE, EXIT
	ASR	FREES+6		;RESERVED BUFFER AVAILABLE?
	BCS	50$		;YES, USE THE RESERVED BUFFER
	MOV	BGBUFF(R5),R1	;NO, GET REQUESTED BYTE SIZE
	BUFFER	GETLRG,,40.,MONPOL   ; Anything there ?
	BCS	60$		;NO, EXIT NOW
	MOV	R4,R3		;YES, MOVE ADDRESS TO HERE
50$:	MOV	R5,R4		;PUT POINTER IN CORRECT LOCATION
	MOV	R3,BGBUFF(R4)	;SAVE THE BUFFER'S ADDRESS
	MOV	(R4),BGBUFQ	;DEQUEUE TO NEXT ITEM
	CALL	30$,R5		;RERUN US IF MORE IN QUEUE
	JMP	@BGQRET(R4)	;BUT DISPATCH TO DRIVER RIGHT NOW

60$:	JMP	RTI3		;EXIT THROUGH RTI3

	UNORG

.DSABL	LSB

GLOBAL	<RSTAP5,BGBUFR>							;047

.SBTTL	RELOAD SYSTEM AND GOTO INIT (SHUTUP)

	TMPORG	RTI

.ENABL	LSB

RELOAD::SPL	7		;;; LOCK ET ALL OUT
	MOV	#1,@#MMUSR0	;;; Be sure that the MMU is on		;035
	MAP	CRAAP5,APR=5,CODE,DATA ;;; MAP THE GUY IN
	JMP	@GOINIT		;;; GO TO THE RELOAD ROUTINE IN HIGH MEMORY

	UNORG

.DSABL	LSB

GLOBAL	<GOINIT>

.SBTTL	Buffer Manager

;+
; The Buffer Manager.
;
; 1) Get a 16 word buffer from the Monitor or FIP pool.
;
;	BUFFER	GETSML,clrcnt,leave		; which generates an:
;
;	 IOT with	0 LLL LLL LCC CCC CCC
;
;	where: L ("leave") is the number of buffers to leave  (0 <= L <= 177)
;	       C ("clrcnt") is the "clear" count  ( 1 <= (-C) <= 20)
;
;	V=1 => failure
;	V=0 => buffer obtained
;
;		R4 -> Monitor small buffer
;			R4 .AND. 37 = 0
;			the first clrcnt words of the buffer are zeroed
;
;
;
; 2) Return a 16 word buffer (to the Monitor or FIP pool).
;
;	R4 -> Monitor or FIP buffer  (R4 .AND. 37 = 0)
;	      (FIP pool must be mappped to return a FIP pool buffer)
;
;	BUFFER	RETSML			; which generates an:
;
;	 IOT with	0 000 000 000 100 000
;
;-

;+
;
; 4) Return an N word buffer
;
;	R4 points to the N word buffer, as follows:
;
;		R4 -> Monitor or FIP buffer  (R4 .AND. 37 = 0)
;		FIP pool must be mappped to return a FIP pool buffer
;		(R4) = buffer size in bytes
;
;		-or-
;
;		R4 is contorted buffer address  (R4 .AND. 37 <> 0)
;		(buffer address) = buffer size in bytes
;
;	BUFFER	RETURN				; which generates an:
;
;	 IOT with	0 000 000 000 000 000
;
;
;
; 5) Return a linked chain of N word buffers
;
;	R4 points to the first N word buffer in the chain, as follows:
;
;		R4 -> Monitor or FIP buffer  (R4 .AND. 37 = 0)
;		FIP pool must be mappped to return a FIP pool buffer
;		(R4) = buffer size in bytes
;
;		-or-
;
;		R4 is contorted buffer address  (R4 .AND. 37 <> 0)
;		(buffer address) = buffer size in bytes
;
;	BUFFER	RETCHN				; which generates a:
;
;	 JSR	PC,@#RETCHN
;
;-

	TMPORG	BUFCTL

BUFCTL:
;***** THE NEXT 5 ITEMS ARE GROUPED *****
FIPFRE::.WORD	0		;COUNT OF FREE FIP POOL BUFFERS
FREES::	.WORD	0		;NON-ZERO IF SOMEONE SMALL BUFFER STALLED
$$FR00	==	.	;**INIT** SET TO NUMBER INITIALLY FREE
	.WORD	<$$BUFE-$$BUFS/40>+<$$MBFE-$$MBFS/40>
				;COUNT OF THE NUMBER OF FREE 16 WD BUFFERS
BGBUFQ:	.WORD	0		;BIG (I/O) BUFFER STALL QUEUE
	.WORD	0		;1 IF I/O BUFFER AVAILABLE; ELSE 0
				;NOTE: IF THE OFFSET OF BGBUFQ+2 WITHIN
				; BUFCTL CHANGES, YOU MUST CHANGE ALL OF
				; THE DRIVERS THAT TMPORG INTO BUFCTL
				; (NAMELY THE MAGTAPE AND DECTAPE DRIVERS).

;***** THE NEXT 2 ITEMS ARE GROUPED
$$BFRT	==	.	;**INIT** POINTS TO FIRST FREE BUFFER
ROOT::	.WORD	BUFPOL		;POINTER TO BUFFER POOL			;053
	.WORD	0		;FULL TIME ZERO WORD

;***** THE NEXT 2 ITEMS ARE GROUPED
FIPROO::.WORD	0		;FIP POOL FREE LIST ROOT (THROUGH APR 6)
	.WORD	0		;ANOTHER FULL TIME ZERO WORD

BAKSML::.WORD	0		;MONITOR POOL BUFFERS TO RETURN LIST ROOT

BAKLRG::.WORD	0		;NPR/NON-NPR POOL BUFFERS TO RETURN LIST ROOT

IDLCBF::.WORD	0		;List of idle communications buffers	;053
ICBFMN::.WORD	0		;Minimum idle comm buffs to keep around	;063
ICBFCT::.WORD	0		;Count of idle comm buffers		;063

TRYMRS::.WORD	JUNK		;TRYMON saved SP-4 for restarts		;053

RETMRS::.WORD	JUNK		;RETMON saved SP-4 for restarts		;053

TRYERS::.WORD	JUNK		;TRYEXT saved SP-4 for restarts		;053

RETERS::.WORD	JUNK		;RETEXT saved SP-4 for restarts		;053


	TMPORG	RTI

;***** THE NEXT 14 ITEMS ARE GROUPED *****
LRGPOL::.WORD	1		;NON-NPR POOL, MOD 100(8)		;053
$$LRGP	==	.	;**INIT** PAR VALUE FOR LRGPOL
	.WORD	0		;ADDRESS OF POOL'S ROOT

EXTPOL::.WORD	1		;NPR POOL, MOD 100(8)			;053
$$EXTP	==	.	;**INIT** PAR VALUE FOR EXTPOL
	.WORD	0		;ADDRESS OF POOL'S ROOT

MONPOL::.WORD	0		;MONITOR POOL, MOD 40(8)		;053
	.WORD	ROOT		;ADDRESS OF POOL'S ROOT
	.WORD	FREES+2		;ADDRESS FOR QUOTA CHECKING
	.WORD	FREES+2		;FREE BUFFER COUNT STORED HERE
	.WORD	0		;END OF LINKED LIST OF "SMALL POOLS"

FIPPOL::.WORD	0		;FIP POOL, MOD 40(8)			;053
	.WORD	FIPROO		;ADDRESS OF POOL'S ROOT
	.WORD	MINUS1		;"INFINITE QUOTA" FOR FIP POOL
	.WORD	FIPFRE		;FREE BUFFER COUNT STORED HERE
	.WORD	MONPOL		;LINK TO NEXT "SMALL POOL"

$$EXTO	==	.	;**INIT** SET AS <MMU-POL-UWIN>-<MMU-POL>
EXTPOF::.WORD	0		;MMU OFFSET FOR UNIBUS MAPPING THE NPR POOL

$$FR20	==	.	;**INIT** SET TO 20% OF INITIAL FREE
FREE20::.WORD	<<$$BUFE-$$BUFS/40>+<$$MBFE-$$MBFS/40>>/5
				;20% OF TOTAL INITIALLY FREE

$$FR25	==	.	;**INIT** SET TO 25% OF INITIAL FREE
FREE25::.WORD	<<$$BUFE-$$BUFS/40>+<$$MBFE-$$MBFS/40>>/4
				;25% OF TOTAL INITIALLY FREE

	UNORG

; THE ABOVE FOUR POOLS MUST BE ORDERED: NON-NPR POOL, NPR POOL,
;	MONITOR POOL, AND FIP POOL FOR THE CODE BELOW TO WORK!

GLOBAL	<MINUS1,$$BUFE,$$BUFS,$$MBFE,$$MBFS,BUFPOL>

.DSECT			;VERIFY BUFFER HEADER ORDERING

BF.SIZ:	.BLKW		;BUFFER SIZE IN BYTES
BF.OFF:	.BLKW		;BYTE OFFSET TO DATA IN BUFFER
BF.LNK:	.BLKW		;LINK "ADDRESS" TO NEXT BUFFER
BF.CNT:	.BLKW		;DATA SIZE IN BYTES
BUFHDR:			;BUFFER HEADER SIZE IN BYTES

	UNORG

.ENABL	LSB

10$:	BIC	#200,@#PS	;;;to Lev3, preserve modes		   ;066	
	;SPLC	3		;;;from above 				   ;066
        MOV     @#JOBDA,R3      ;point to fippol job blk                   ;058
        BIT     #JDFSTM,JDFLG4(R3)      ;is fastmap turned on?             ;058
        BEQ     11$             ;NO - It's up to the user to handle        ;058
        MAP     GRDAP5,APR=5,CODE       ;MAP rest of function code         ;058
        JMP     @FMAP$I         ;and do it via merge                       ;058


11$:    MOV     #P.IOT,R0       ;RE-ROUTE AS FOR IOT'S                     ;058
	JMP	RETUSR		;NOW GO DO THE RE-ROUTE

	VECTOR	20,,PR7		;VECTOR FOR IOT'S

	REGSAV			;;;SAVE ALL REGISTERS
	MOV	TOS.PS(SP),R3	;;;IS IT AN IOT FROM USER MODE?
        BIT     #40000,R3       ;;;Test prev mode for user/superv?         ;058
        BNE     10$             ;;;yes route toward user or fastmap        ;058
	MOVB	R3,@#PS		;;;NO, DROP TO CALLER'S PRIORITY
	MFPI	@TOS.PC(SP)	;FETCH THE ARGUMENT WORD
	MOV	(SP)+,R0	; TO R0
	ADD	#2,TOS.PC(SP)	; THEN BUMP PC OVER THE ARGUMENT
	MOV	#RESRT4,-(SP)	;SET AN EXIT RETURN ADDRESS
	TSTB	R0		;NOW CHECK FOR KIND OF CALL
	BPL	60$		;BIT 7 = 0 => RETURNING A BUFFER
	BIC	#V,TOS.PS+2(SP)	;BIT 7 = 1 => GETTING A BUFFER
	MOV	#FREES+2,R5	;GET POINTER TO THE BUFFER COUNT
	MOV	#ROOT,R2	;GET POINTER TO MONITOR POOL ROOT
	MOV	#40,R1		;ASSUME 16 WORD BUFFER
	MOV	R0,R4		;COPY THE PARAMETER WORD AND
	SWAB	R4		; ISOLATE THE NUMBER TO BE LEFT
	BIC	#^C<177>,R4	;  WHEN ALL FINISHED
12$:	SPLC	7		;;;LOCKOUT INTERRUPTS NOW
	CMP	R4,(R5)		;;;CAN WE OBTAIN A BUFFER?
	BHIS	15$		;;;No, set to try caches		;053
	TST	(R2)		;;;Yes, but is the pool empty?		;053
	BNE	20$		;;;No, pick the buffer up		;053
15$:	MOVB	R3,@#PS		;;;Drop to caller's priority		;053
	REGSAV			;Save all registers			;053
	CLR	R0		;Try every cache in town		;053
	MOV	DPAR6,R3	;Get a pointer to DPAR6			;053
	MOV	#MONPOL,R4	;Note that we want MONPOL buffers	;053
	MOV	#140000,R5	;Set up cacher register convention	;053
	MOV	(R3),-(SP)	;Save DPAR6 mapping			;053
	CALL	ASKCHE		;Ask the cacher for buffers		;053
	MOV	(SP)+,(R3)	;Restore DPAR6 mapping			;053
	REGRES			;Restore registers			;053
	BCC	50$		;Failed, exit with V = 1		;053
	BR	12$		;Success, try, try again		;053

        GLOBAL  <GRDAP5,FMAP$I>                                            ;058

20$:	MOV	#TRYMRP,@TRYMRS	;;;Restart TRYMON if necessary		;053
	MOV	(R2),R4		;;;GET TOP-OF-LIST BUFFER		;053
	DEC	(R5)		;;;ONE LESS BUFFER ON ACCOUNT NOW
	CALL	ALLOC		;;;GET BUFFER FOR REAL NOW
	MOVB	R3,@#PS		;;;DROP TO CALLER'S PRIORITY
	MOV	R4,TOS.R4+2(SP)	;GIVE CALLER BACK THE POINTER
	COMB	R0		;Should we clear the buffer?		;053
	BEQ	30$		;No, not this time			;053
.REPT	16.			;For the whole buffer			;053
	CLR	(R4)+		;Clear it out				;053
.ENDR									;053
30$:	RETURN			;THEN RETURN

; ALLOC - ALLOCATE SPACE FROM THE MONITOR'S POOL OR FIP'S POOL.
;
;	R1 =  SIZE TO BE ALLOCATED
;	R2 -> PREVIOUS ITEM
;	R4 -> THIS ITEM
;	(R4) -> NEXT ITEM
;	2(R4) = THIS ITEM'S SIZE IN BYTES (>=R1)
;	PRIORITY LEVEL IS PR7
;
;	CALL	ALLOC
;
;	R4 -> ALLOCATED ITEM
;	R5 =  RANDOM

ALLOC:	MOV	(R4)+,R5	;;;SAVE LINK TO NEXT IN A REGISTER
	SUB	R1,(R4)		;;;NOW DEDUCT WHAT WE ARE TAKING
	BEQ	40$		;;;TAKING WHOLE THING, UNLINK TO NEXT
	MOV	R4,R5		;;;TAKING ONLY PART, BUILD A POINTER
	ADD	R1,R5		;;; TO NEXT FREE SPACE
	MOV	(R4),(R5)	;;;COPY REMAINING SIZE TO NEW FREE SPACE
	MOV	-2(R4),-(R5)	;;;COPY LINK TO NEW FREE SPACE
40$:	MOV	R5,(R2)		;;;SET CORRECT LINK TO NEXT IN PREVIOUS
	MOV	RETMRP,@RETMRS	;;;Restart the buffer returner		;054
	TST	-(R4)		;;;Point to start of allocated item	;053
	RETURN			;;;NOW EXIT

50$:	BIS	#V,TOS.PS+2(SP)	;;;INDICATE FAILURE WITH V-BIT SET
	MOV	SP,-(R5)	;;; AND REMEMBER SOMEONE FAILED
	RETURN			;;;NOW EXIT WITH FAILURE

GLOBAL	<RETMRP>							;053

60$:	BEQ	90$		;SKIP IF SIZE ALREADY STORED IN BUFFER
	BIT	#37,R4		;IS IT ALLIGNED PROPERLY??
	BEQ	65$		;YES, SO CONTINUE
	CRASH			;NO, SO CRASH AND FIND OUT WHO

65$:	MOV	R0,(R4)		; ELSE STORE THE SIZE
70$:	SPLC	7		;;;LOCKOUT INTERRUPTS NOW
	MOV	BAKSML,2(R4)	;;;LINK REST OF LIST TO THIS BUFFER	;053
	MOV	R4,BAKSML	;;; AND MAKE THIS BUFFER THE START OF LIST
80$:	L3QSET	QBUFRT		;;;SIGNAL THAT THE RETURNER SHOULD RUN
	RETURN			;;; THEN EXIT

90$:	BIT	R4,#37		;SPECIAL CONTORTED ADDRESS?
	BEQ	70$		;NO, IT'S A MONITOR POOL BUFFER
	MOV	DPAR6,R3	;NPR/NON-NPR POOL BUFFER, GET PAR6 POINTER
	MOV	(R3),R0		;SAVE CALLING PAR6 VALUE
	MOV	R4,R5		;COPY THE CONTORTED ADDRESS TO ODD REGISTER
	ASHC	#-7,R5		; AND CONVERT IT TO A MMU ADDRESS
	MOV	R5,(R3)		;MAP THE BUFFER THROUGH PAR6
	MOV	@#140000+BF.SIZ,R1 ;Get size of buffer			;050
	ASH	#-6,R1		;Convert it to slivers			;050
	MOV	R1,@#140000+BF.SIZ ;Store the new buffer size		;050
	SPLC	7		;;;LOCKOUT INTERRUPTS NOW
	MOV	BAKLRG,BF.LNK+140000 ;;;LINK REST OF LIST TO THIS BUFFER
	MOV	R5,BAKLRG	;;; AND MAKE THIS BUFFER THE START OF LIST ;051
	MOV	R0,(R3)		;;;RESTORE CALLING PAR6 VALUE
	BR	80$		;;; AND GO EXIT SIGNALING BUFFER RETURNER

.DSABL	LSB
GLOBAL	<DPAR6>


.SBTTL	COMBUF	Get a communications buffer

;+
; COMBUF - Get a communications buffer
; COMBFI - Get a communications buffer passing cache inhibit mask
;
;	R0 =  Cache inhibit mask (COMBFI only)
;
;	CALL	COMBUF
;	CALL	COMBFI
;
;	C = 0 if buffer allocated:
;
;	R0 =  Undefined
;	R4 -> Data portion of buffer
;	R5 -> CCB describing the buffer allocated
;		CC.BUF	Buffer descriptor for buffer allocated
;
;	C = 1 if buffer not allocated:
;
;	R0 =	Error code
;	R4 =	random.
;	R5 =	0
;-

COMBUF::CLR	R0		;Initialize inhibit mask		;053
COMBFI::BIS	#CI$CBF,R0	;Inhibit givebacks from ourselves	;053
	MOV	R1,-(SP)	;Get some work registers		;053
	MOV	R2,-(SP)	; ...					;053
	MOV	R3,-(SP)	; ...					;053
	PUSH	@#PS		; Save current priority...		;059
	SPLC	7		;Stop interrupts			;053
	MOV	IDLCBF,R5	;;;Get an idle CCB			;053
	BEQ	10$		;;;None, try to allocate a new one	;053
	MOV	(R5),IDLCBF	;;;Allocate that idle CCB		;053
	POP	@#PS		;;; restore PR of entry.		;059
	DEC	ICBFCT		;Decrement count of idle comm buffers	;063
	ADD	#CC.BUF+10,R5	;Point to end of CCB			;053
.ASSUME	CC.BUF+10 	EQ	40
	CLR	-(R5)		;Clear out BF.END value			;053
.ASSUME	BF.END	EQ	10-2
	MAP	-(R5),APR=6,DATA ;Map the buffer			;053
.ASSUME	BF.MMU	EQ	BF.END-2
	MOV	#140000,R3	;Get the address the buffer is mapped at ;053
	MOV	R3,-(R5)	;Set the BF.VIR value			;053
.ASSUME	BF.VIR	EQ	BF.MMU-2
	TST	-(R5)		;Skip BF.ADR				;053
.ASSUME	BF.ADR	EQ	BF.VIR-2
	BR	20$		;And join up to clear the buffer	;053

10$:	POP	@#PS		;;; Restore Priority of entry		;059
	;CLR	R5		;Indicate we don't have a CCB yet	;053
	MOV	#1,R1		;Set to get one buffer			;053
	MOV	#40.,R2		;Leaving 40. in the pool		;053
	MOV	#MONPOL,R4	;Get it from MONPOL			;053
	CALL	GETBUF		;Try to allocate that space		;053
	BCS	30$		;Error, forget it			;053
	MOV	R4,R5		;Got it, save the address		;053
	MOV	#CBFSIZ/40,R1	;Get the size of a comm buffer		;053
	MOV	#-1,R2		;Don't ever use MONPOL			;053
	MOV	#EXTPOL,R4	;EXTPOL is what we want			;053
	CALL	GETBUF		;Now try to allocate it			;053
	BCS	30$		;Failure, go return small buffer and exit ;053
	CALLX	MAPBUF		;Success, map this new buffer
	ADD	#CC.BUF+10,R5	;Point to end of CCB			;053
.ASSUME	CC.BUF+10 	EQ	40
	CLR	-(R5)		;Clear out BF.END value			;053
.ASSUME	BF.END	EQ	10-2
	MOV	@DPAR6,-(R5)	;Set the BF.MMU value			;053
.ASSUME	BF.MMU	EQ	BF.END-2
	MOV	R3,-(R5)	;Set the BF.VIR value			;053
.ASSUME	BF.VIR	EQ	BF.MMU-2
	MOV	R4,-(R5)	;And the BF.ADR value			;053
.ASSUME	BF.ADR	EQ	BF.VIR-2
20$:	MOV	#CBFSIZ,(R3)+	;Set up the size of the buffer		;053
.ASSUME	BF.SIZ	EQ	0
	MOV	#BUFHDR,(R3)+	;Set the offset to the data		;053
.ASSUME	BF.OFF	EQ	BF.SIZ+2
	CLR	(R3)+		;No link to next			;053
.ASSUME	BF.LNK	EQ	BF.OFF+2
	CLR	(R3)+		;And no data size right now		;053
.ASSUME	BF.CNT	EQ	BF.LNK+2
	MOV	R3,R4		;Copy pointer to buffer after buffer header ;053
.ASSUME	BUFHDR	EQ	BF.CNT+2
.REPT	<40-10>/2
	CLR	-(R5)		;Clear out the CCB			;053
.ENDR
	;CLC			;Indicate goodness (from CLC above)	;053
30$:	MOV	(SP)+,R3	;Restore work registers
	MOV	(SP)+,R2	; ...
	MOV	(SP)+,R1	; ...
	BCC	50$		;Get out if we got a buffer
	MOV	R5,R4		;Copy CCB pointer to return it		;053
	BEQ	40$		;We didn't get it, don't return it	;053
	BUFFER	RETSML		;Got one, return it			;053
40$:	CLR	R5		;Indicate we don't have a CCB		;053
	SETERR	NOBUFS,R0	;Set up NOBUFS error
	SEC			;Indicate failure
50$:	RETURN			;And exit				;053

GLOBAL	<NOBUFS>							;049

.SBTTL	Return a communications buffer

;+
; COMRET - Return a communications buffer
;
;	R5 ->	Somewhere in CCB
;		CC.LNK (offset 0) is ignored, can be anything		;059
;		Returns occur at PR3 and PR5				;059
;
;	CALL	COMRET
;
;	R5 =	0
;
; The buffer is linked to the idle communications buffer list. It
; will be re-allocated to other callers of COMBUF, or returned to
; the system as a result of a cache giveback.
;-

COMRET::BIC	#37,R5		;Point to top of CCB
	PUSH	@#PS		; save the current priority		;059
	SPLC	7		;Stop interrupts please			;053
	MOV	IDLCBF,(R5)	;;;Link idle list to this CCB		;053
	MOV	R5,IDLCBF	;;;And put this on the idle list	;053
	POP	@#PS		;;; Restore priority of entrance	;059
	INC	ICBFCT		;Increment count of idle comm buffers	;063
	CLR	R5		;Zap buffer address
	RETURN			;And exit

.SBTTL	BUFFR1	Get a buffer, all parameters in-line
.SBTTL	BUFFR2	Get a buffer, size in register, "leave" and "pool" in-line
.SBTTL	BUFFER	Get a buffer, size and "leave" in registers, pool in-line
.SBTTL	BUFFR4	Get a buffer, all parameters in registers

;+
; BUFFR1 - Get a buffer, all parameters in-line
; BUFFR2 - Get a buffer, size in register, "leave" and "pool" in-line
; BUFFER - Get a buffer, size and "leave" in registers, pool in-line
; BUFFR4 - Get a buffer, all parameters in registers
;
;	R1 = Requested buffer size in bytes (BUFFR2, BUFFER, BUFFR4)
;	R2 = Amount of space to leave in small buffer pool (BUFFER, BUFFR4)
;	R4 = Pool to start searching at (BUFFR4)
;
;	CALL	{BUFFR1 | BUFFR2 | BUFFER | BUFFR4 },R5
;	 .WORD	[requested size] (BUFFR1 only)
;	 .WORD	[small buffer leave amount] (BUFFR1, BUFFR2)
;	 .WORD	[pool to start searching] (BUFFR1, BUFFR2, BUFFER)
;	
;	-or-
;
;	BUFFER	GETLRG, <requested size>, <"leave" count>, <whichpool>
;
;		The macro's default for whichpool is LRGPOL. This is the
;		same as a direct call to BUFFR1.
;
;	If C=1 then request failed
;	If C=0 then buffer obtained
;
;	R1 =  rounded up size of buffer obtained  (mod 40(8))
;	R4 -> buffer  (R4 .AND. 37 = 0)
;	A null buffer header is built in the buffer
;
;	-or-
;
;	R1 =  rounded up size of buffer obtained  (mod 100(8))
;	R4 =  contorted buffer address  (R4 .AND. 37 <> 0)
;	A null buffer header is built in the buffer
;
;-

BUFFR1::MOV	(R5)+,R1	; Get requested size
BUFFR2::MOV	(R5)+,R2	; Get Monitor "leave" count
BUFFER::MOV	(R5)+,R4	; Get starting address
BUFFR4::MAP	PUSH,APR=6,DATA	; Save DPAR6 mapping			;053
	MOV	R0,-(SP)	; Save caller's R0			;053
	MOV	R1,-(SP)	; Save caller's R1			;053
	CLR	R0		; Set to try all caches			;053
	ADD	#40-1,R1	; Round up to next multiple of 40(8)	;053
	ASH	#-5,R1		; Convert request size to size/40	;053
	CALL	GETBUF		; Go and get that space			;053
	BCS	10$		; Failed, oh well			;053
	MOV	R3,-(SP)	; And save R3 as well			;053
	CALLX	MAPBUF		; Map this newly obtained buffer	;053
	ASH	#5,R1		; Form real byte size from size/40	;053
	MOV	R1,(R3)+	;  and set size in BF.SIZ		;053
	MOV	#BUFHDR,(R3)+	;   and initial offset in BF.OFF	;053
	CLR	(R3)+		;    and no link in BF.LNK		;053
	CLR	(R3)+		;     and no data size in BF.CNT	;053
	MOV	(SP)+,R3	; Restore R3				;053
	MOV	R1,(SP)		; Set to return buffer size		;053
	;CLC			; Indicate success (from CLR above)	;053
10$:	MOV	(SP)+,R1	; Return buffer size or passed value	;053
	MOV	(SP)+,R0	; Restore caller's R0			;053
	MAP	POP,APR=6,DATA	; Restore DPAR6 mapping			;053
	RETURN	R5		; And exit				;053

.SBTTL	GETBUF	Allocate space from a buffer pool

;+
; GETBUF - Allocate space from a buffer pool
;
;	R0 = Cache inhibit mask
;	R1 = Requested buffer size in 16-word units (size / 40)
;	R2 = Amount of space to leave in small buffer pool
;	R4 = Pool to start searching at
;
;	CALL	GETBUF
;
;	C = 0 for success, 1 for failure
;
;	R1 = Actual buffer size allocated in 16-word units
;	R4 = "Address" of buffer
;
;	DPAR6 mapping is undefined if an attempt is made to allocate 	;063
;		out of XBUF.						;063
;	DPAR6 mapping is preserved if an attempt is made to allocate 	;063
;		out of MONPOL or FIPPOL.				;063
;
; This routine is used to allocate space from any buffer pool. The
; caller of this routine can also explicitly control the searching
; of caches when trying to recover from allocation failures. Additionally,
; since this routine takes the size in 16-word units, it can be used
; to allocate large (greater than 16KW) amounts of XBUF.
;
; This routine does not set up buffer headers. It is the responsibility
; of the caller to do that!
;-

GETBUF::REGSCR			; Save all registers			;053
	MOV	DPAR6,R3	; Get handy pointer to PAR6
	MOV	#140000,R5	; Get handy pointer through PAR6
	MOV	@#PS,-(SP)	; Save calling priority
20$:	MOV	TOS.R1+2(SP),R1	; (Re-)get the requested size		;053
	ADD	(R4),R1		; Round size up to the
	BIC	(R4)+,R1	;  multiple for this pool
	MOV	(R4)+,R0	; Get pool's root
	BEQ	20$		; None, loop for next pool
	CMP	R4,#MONPOL	; To the Monitor pool or FIP pool?
	BHI	60$		; Yes, use a different routine
	MOV	R4,-(SP)	; No, save the list pointer
	ASR	R1		; Form size/100 for search (was size/40) ;053
	CALL	TRYEXT		; Try for extended pool space
	BNE	25$		;;;Found some, great			;053
	MOV	(SP)+,R4	; Failed, get back list pointer		;053
	CMP	-(R4),-(R4)	; And point back to pool block start	;053
	MOV	TOS.R0+2(SP),R0	; Pick up cache inhibit mask		;053
	CALL	ASKCHE		; Ask caches for some space		;053
	BCS	20$		; Got some, try this pool again		;053
	CMP	(R4)+,(R4)+	; Failed, advance to next pool		;053
	BR	20$		; And loop				;053

25$:	TST	(SP)+		;;; Pop the saved list pointer
	MOVB	(SP)+,@#PS	;;; Drop to caller's priority now
	ASL	R1		; Get size in 16-word units		;053
	;CLC			; C=0 from 'ASL' above
	ROR	R4		; Shift the MMU address into
	BCC	30$		;  the special contorted
	BIS	#100000,R4	;   address that we will
30$:	SWAB	R4		;    really return
40$:	MOV	R4,TOS.R4(SP)	; Give caller the contorted address	;053
	MOV	R1,TOS.R1(SP)	; Give caller size for returning buffer	;053
	TST	(PC)+		; Set C=0 for goodness (skip the 'SEC')
50$:	SEC			; Set C=1 for badness
	RETURN			;  and exit				;053

GLOBAL	<DPAR6>

60$:	TST	TOS.R2+2(SP)	; Should we try the monitor's pool?	;053
	BMI	100$		; No, so we failed			;053
70$:	MOV	@(R4)+,R5	; Get free count to check against
	SUB	TOS.R2+2(SP),R5	; Correct quota for number to leave	;053
	BLO	95$		; Underflow on Monitor pool quota, try cache ;055
	CMP	R1,R5		; Is request too large?
	BHI	95$		; Yes, try the cacher			;055
75$:	MOV	R4,R5		; Save the list pointer
80$:	CALL	TRYMON		; Try for root or FIP pool space
	BEQ	90$		; Failed, try the cacher
	SUB	R1,@(R5)+	;;;  success, update the buffer count	;053
	MOVB	(SP)+,@#PS	;;; Drop to caller's priority
	BR	40$		;    Now exit all o.k.

90$:	MOV	R5,R4		; Get back pool pointer			;053
95$:	SUB	#6,R4		; Point to start of pool descriptor	;054
	MOV	TOS.R0+2(SP),R0 ; Get cache inhibit mask		;053
	MOV	#140000,R5	; And get a handy 140000		;053
	MOV	(R3),-(SP)	; Save DPAR6 mapping, in case we're 	;063
				;  trying to get a FIP buffer		;063
	CALL	ASKCHE		; Try to get space from the cache	;053
	MOV	(SP)+,(R3)	; Restore DPAR6 mapping			;063
	BCS	20$		; Success, try this pool again		;053
	MOV	10(R4),R4	; Failure, get the next pool to try	;053
	BNE	20$		; And try it if there is one		;053
100$:	TST	(SP)+		; Pop saved calling priority
	BR	50$		;  and exit saying failure

;+
; TRYMON - TRY TO ALLOCATE SPACE IN MONITOR OR FIP BUFFER POOL.
;
;	R0 -> MONITOR OR FIP POOL ROOT
;	R1 =  Number of contiguous buffers to allocate
;
;	CALL	TRYMON
;
;	R2 =  RANDOM
;	R4 -> BUFFER ALLOCATED +2
;
;	Priority can be anything from PR3 to PR7
;
;	IF Z=0 THEN SPACE WAS FOUND (AND PRIORITY LEVEL IS PR7)
;	IF Z=1 THEN NO SPACE AVAILABLE
;
; This routine is used to attempt to allocate a series of contiguous
; buffers from the monitor's general buffer pool or the FIP pool.
; This routine can be called at any priority.
;
; To protect from interrupts while in this routine, we use "restarts".
; To restart a routine, we save the address that the saved PC will
; end up getting stored at if an interrupt occurs (it will be saved
; at the current SP - 4). Since we save SP, it is not possible to
; change the SP value while in restartable code.
;
; When we are entered, we will save the restart address that was
; previously set up, and save our own restart address. Note that
; the restart pointer points to "JUNK" if the routine is not in use.
;
; If we successfully allocate a buffer, we will restart any other
; instance of this routine, as well as the buffer return process.
;
; If we fail to return a buffer, we will simply restore the restart
; address that was saved at the time of our interrupt.
;
; The buffer allocater used to allocate a single small buffer (which
; is much more efficient than the general buffer allocater) will also
; signal restarts for this routine, as will the buffer returner.
;-

TRYMON:	MOV	R5,-(SP)	;SAVE R5				;053
	ASH	#5,R1		;Convert buffer count to bytes		;053
	MOV	SP,R4		;Get current SP value			;053
	CMP	-(R4),-(R4)	;Now get where interrupted PC will be stored ;053
	MOV	TRYMRS,R5	;Save possible restart interrupt point	;053
	MOV	R4,TRYMRS	;And save this one			;053
TRYMRP::MOV	R0,R4		;RELOAD THE ROOT ADDRESS
10$:	MOV	R4,R2		;SAVE THE POINTER TO PREVIOUS
	MOV	(R2),R4		; THEN GET THE NEXT IN THE LIST
	BEQ	40$		;NO MORE, WE CAN'T FIND ANYTHING
	CMP	R1,2(R4)	;MORE, IS IT BIG ENOUGH?
	BHI	10$		;NOT BIG ENOUGH, CONTINUE SEARCHING
	SPLC	7		;;;BIG ENOUGH, LOCKOUT INTERRUPTS
	MOV	R5,TRYMRS	;;;And restore previous restart value	;053
	MOV	#TRYMRP,(R5)	;;;And do that restart now		;053
20$:	CALL	ALLOC		;;;NOW ACTUALLY ALLOCATE THE SPACE

; Restore registers and exit. This code isn't guaranteed to be at PR7
; (for the failure case).

30$:	ASH	#-5,R1		;Restore R1				;053
	MOV	(SP)+,R5	;Restore R5
	TST	R4		;Set Z based on available space
	RETURN			; AND EXIT

40$:	MOV	R5,TRYMRS	;Failure, disable our restart		;053
	BR	30$		;And exit				;053

;+
; TRYEXT - TRY TO ALLOCATE SPACE IN EXTENDED BUFFER POOL.
;
;	R0 =  EXTENDED POOL'S ROOT
;	R1 =  DESIRED BUFFER SIZE IN BYTES /100
;	R3 -> DPAR6 (OR KISAR6 IF NO D-SPACE)
;	R5 =  140000
;
;	CALL	TRYEXT
;
;	R0 =  RANDOM
;	R2 =  RANDOM
;	R4 =  MMU ADDRESS IF SPACE FOUND
;
;	IF Z=0 THEN SPACE WAS FOUND (AND PRIORITY LEVEL IS PR7)
;	IF Z=1 THEN NO SPACE AVAILABLE
;
; This routine is used to attempt to allocate space from an extended
; buffer pool (either EXTPOL or LRGPOL).
;
; To protect from interrupts while in this routine, we use "restarts".
; To restart a routine, we save the address that the saved PC will
; end up getting stored at if an interrupt occurs (it will be saved
; at the current SP - 4). Since we save SP, it is not possible to
; change the SP value while in restartable code.
;
; When we are entered, we will save the restart address that was
; previously set up, and save our own restart address. Note that
; the restart pointer points to "JUNK" if the routine is not in use.
;
; If we successfully allocate a buffer, we will restart any other
; instance of this routine, as well as the buffer return process.
;
; If we fail to return a buffer, we will simply restore the restart
; address that was saved at the time of our interrupt.
;-

TRYEXT:	MOV	TRYERS,-(SP)	;Save the previous restart value	;053
	MOV	SP,R4		;Get our SP value			;053
	CMP	-(R4),-(R4)	;Now get where PC would get saved	;053
	MOV	R4,TRYERS	;And set our restart value		;053
TRYERP::MOV	R0,R4		;Reload the root address		;053
	MOV	R4,(R3)		; and load into the MMU
10$:	MOV	R4,R2		;Save previous MMU address
	MOV	(R5),R4		;Now get the next in the list
	BEQ	40$		;No more, exit with failure		;053
	MOV	R4,(R3)		;More, load MMU for this one
	CMP	R1,2(R5)	;Is its size large enough?
	BHI	10$		;No, loop...
	SPLC	7		;;;Yes, lockout interrupts
	MOV	(SP)+,TRYERS	;;;Restore previous restart value	;053
	MOV	#TRYERP,@TRYERS	;;;And do that restart now		;053
	MOV	RETERP,@RETERS	;;;Restart the buffer returner		;053
	SUB	R1,2(R5)	;;;PUNISH SIZE BY REQUESTED AMOUNT
	BNE	20$		;;;STILL IS SOME SIZE LEFT
	MOV	(R5),R0		;;;ALL USED UP, GET LINK TO NEXT
	MOV	R2,(R3)		;;;LOAD MMU FOR PREVIOUS AND
	MOV	R0,(R5)		;;; SET PREVIOUS FOR NEXT LINK
	MOV	R4,(R3)		;;;RELOAD MMU BACK TO FOUND BUFFER
20$:	ADD	2(R5),R4	;;;INDEX TO ACTUAL SPACE OBTAINED

; At this point, we are all done allocating the buffer. Since the code
; below is used for success or failure, priority might not be PR7
; (for the failure case).

30$:	TST	R4		;SET Z-BIT=1 IF NO SPACE FOUND
	RETURN			; AND EXIT

; Note: The SP reference below can be accomplished safely, since PDP-11
; instructions can not be interrupted in the middle. 

40$:	MOV	(SP)+,TRYERS	;Restore previous restart value		;053
	BR	30$		;And exit				;053

GLOBAL	<RETERP>							;053

.SBTTL	ASKCHE	Ask caches for buffer space

;+
; ASKCHE - Ask caches for buffer space
;
;	R0 =  Cache inhibit mask (setting a bit inhibits trying a cache)
;	R3 -> DPAR6
;	R4 =  Descriptor of pool for which space is desired
;	R5 =  140000
;
;	CALL	ASKCHE
;
;	All registers are preserved
;
;	C = 0 if space wasn't returned; try another pool or fail
;	C = 1 if space was available; search pool again
;
; This routine will call each cache giveback processor to attempt to
; get buffer space. On entry to the cache giveback processor:
;
;	R3 -> DPAR6
;	R4 =  Descriptor of pool for which space is desired
;	R5 =  140000
;
; On exit, the giveback processor sets C = 1 if space available, C = 0
; otherwise.
;-

ASKCHE:	MOV	R1,-(SP)	;Save caller's R1			;053
	MAP	PUSH,APR=5,CODE,DATA ;And DPAR5 mapping			;053
	MOV	#CHETBL,R1	;Point to cache table			;053
10$:	ASR	R0		;Inhibit this cache?			;053
	BCS	20$		;Yes, skip it then			;053
	REGSAV			;No, save all registers			;053
	MOV	@(R1)+,R2	;Pick up MMU address of cacher		;054
	BMI	15$		;Cacher not loaded, skip it (C=0 from BCS) ;053
	MAP	R2,APR=5,CODE	;Cacher mapped, map it in I-space	;054
	MAP	R2,APR=5,DATA	;And in D-space (takes less code this way) ;054
	CALL	@(R1)+		;And ask the cacher for space		;053
15$:	REGRES			;Restore registers			;053
	BCS	30$		;Success, go exit smiling		;053
20$:	CMP	(R1)+,(R1)+	;Advance to next cacher entry		;053
	CMP	R1,#CHETBL+<4*CHECNT> ;More to do?			;053
	BLO	10$		;Yes, go for it				;053
	;CLC			;Indicate goodness (BLO = BCS)
30$:	MAP	POP,APR=5,CODE,DATA ;Restore APR5 mapping		;053
	MOV	(SP)+,R1	;Restore caller's R1			;053
	RETURN			;And we're done				;053

.SBTTL	GET A FIP POOL BUFFER

;+
; GETFIP - GET AND CLEAR A FIP POOL BUFFER
;
;	CALL	GETFIP
;
;	TRY TO ALLOCATE A FIP POOL BUFFER OR A MONITOR POOL BUFFER
;	FAIL IF FIP POOL IS EMPTY AND MON POOL HAS LESS THAN 20 BUFFERS
;
;	IF C=1 THEN REQUEST FAILED
;	IF C=0 THEN BUFFER OBTAINED
;
;	R4 -> BUFFER (ALL CLEARED)
;
;	FIP pool must be mapped by our caller
;-

GETFIP::MOV	R0,-(SP)	;Save R0				;053
	MOV	R1,-(SP)	;SAVE R1				;043
	MOV	R2,-(SP)	; AND R2				;043
	CLR	R0		;Try all caches				;053
	MOV	#1,R1		;Get one buffer				;053
	MOV	#FIPPOL,R4	; FROM THE FIP POOL OR MONITOR POOL	;043
	MOV	#20.,R2		;  LEAVING 20. FREE MONITOR BUFFERS	;043
	CALL	GETBUF		;Go get that space			;053
	BCS	20$		;REQUEST FAILED, EXIT WITH C=1		;043
	ADD	#40,R4		;Success, point to end of buffer	;053
10$:	CLR	-(R4)		;Clear out the buffer			;053
	CLR	-(R4)		; ...					;053
	CLR	-(R4)		; ...					;053
	CLR	-(R4)		; ...					;053
	BIT	#37,R4		;More to do?				;053
	BNE	10$		;Yes, loop for it			;053
20$:	MOV	(SP)+,R2	;NOW RESTORE R2				;043
	MOV	(SP)+,R1	; AND R1				;043
	MOV	(SP)+,R0	;  And R0				;053
	RETURN			;AND BACK WITH OR WITHOUT THE BUFFER	;043

.SBTTL	HANDLE POWER FAILURES

;+
; POWER FAILURES COME HERE.
;-

	TMPORG	RTICTL

SPSAVE:	.BLKW			;SAVE THE SP STACK VALUE HERE
PWRFAL::.WORD	0		;NON ZERO WHEN A POWER FAIL
$$PWRP::.WORD	300.		; Seconds to wait on powerfail recovery

.ENABL	LSB

	TMPORG	RTI		;ALLOW TO RUN UNMAPPED

	VECTOR	24,,PR7	;POWER FAILURES COME HERE

	TMPORG	RTI		;ALLOW TO RUN UNMAPPED (STILL)
				; THE VECTOR MACRO TOOK US ELSE WHERE

10$:	MOV	#HALT,@#24	;;;PERMANENT HALT IF DIE IN CODE BELOW
	REGSAV			;;;SAVE ALL REGISTERS
	MOV	#POPRT4,-(SP)	;;;SET RETURN AS A SIMPLE RESTART
	MOV	SP,SPSAVE	;;; AND SAVE THE SP STACK VALUE
	MOV	#PWFSAV,R0	;;;GET START OF POWER FAIL SAVE AREA
	MOV	#170$,R1	;;;GET LIST POINTER OF THINGS TO SAVE
	MOV	#<180$-170$>/4,R2 ;;;NUMBER OF PAIRS TO SAVE (JUST I APR'S)
	BIT	#XC$IDS,X.CON	;;;DO WE HAVE D-SPACE APR'S?
	BEQ	20$		;;;NOPE, SO GO ON
	ADD	#<190$-180$>/4,R2 ;;;YES NUMBER OF PAIRS (I AND D APR'S)
20$:	BIT	#40,MMU22W+2	;;;USING UNIBUS WINDOW?
	BEQ	30$		;;;NOPE
	ADD	#<170$-160$>/4,R2;;;YES PAIRS (I&D APR'S AND UMR'S)
	MOV	#160$,R1	;;;ALSO POINT TO NEW BEGINING
30$:	MOV	R1,(R0)+	;;;SAVE THE LIST POINTER USED
	MOV	R2,(R0)+	;;;AND THE NUMBERS OF PAIRS SAVED
40$:	MOV	(R1)+,R3	;;;GET ADDRESS OF NEXT IN LIST
	MOV	(R1)+,R4	;;;GET NUMBER OF ITEMS TO SAVE
50$:	MOV	(R3)+,(R0)+	;;;SAVE A WORD AND
	SOB	R4,50$		;;; LOOP FOR NEXT
	SOB	R2,40$		;;;LOOP FOR NEW SET OF PAIRS
	MOV	JOBF,R1		;;;GET CURRENT JOB FLAG POINTER
	MOV	R1,(R0)		;;;SET FAKE USER SP STACK VALUE
	CALL	@SAVFPP		;;;NOW SAVE ASYNC FLOATING POINT IF ANY
	ADD	#100000,R0	;;;FUDGE FOR A SAFETY FACTOR
..PWRF	==	.-2	;**PATCH** CHANGE TO ?????? TO ENABLE POWER FAIL RECOVERY
	MOV	FIPR6,R2	;;;A SAVED MONITOR STACK?
	BNE	60$		;;;YES, USE IT FOR THE CHECK
	MOV	SP,R2		;;;NO, USE CURRECT STACK FOR CHECK
60$:	CMP	R0,R2		;;;SAVED TOO MUCH?
	BLO	70$		;;;NOPE, KEEP THE SIMPLE RESTART
	MOV	#FTLFKM,(SP)	;;;NO GO, WE MUST RELOAD AND AUTO-RESTART
70$:	MOV	#80$,@#24	;;;COME HERE ON POWER UP
	JMPX	HALT		;;;BUT HALT FOR NOW...

GLOBAL	<HALT,PWFSAV,MMU22W,SAVFPP,FIPR6,X.CON>

80$:	MOV	#70$,@#24	;;;HALT IF WE FAIL AGAIN
	SPLC	7		;;;ENSURE LEVEL 7 (& REG SET 1!)
	MOV	SPSAVE,SP	;;;GET BACK THE SP STACK VALUE
$$VSWR	==	.	;**INIT** 'NOP' FOR VOLATILE SWITCH REGISTER
	BR	90$		;;;SKIP THE BELOW IF REAL SWITCH REGISTER
	MOV	(PC),X.SWRP	;;;TELL RESTART CODE THIS IS A POWER FAIL
90$:	MOV	#PWFSAV,R0	;;;GET SAVE AREA POINTER
	MOV	(R0)+,R1	;;;GET SAVED LIST POINTER
	MOV	(R0)+,R2	;;;AND COUNT OF SAVED PAIRS
100$:	MOV	(R1)+,R3	;;;ADDR TO RESTORE
	MOV	(R1)+,R4	;;;COUNT TO RESTORE
110$:	MOV	(R0)+,(R3)+	;;;AND RESTORE A WORD
	SOB	R4,110$		;;; AND LOOP FOR MORE
	SOB	R2,100$		;;;NOW GO FOR NEXT PAIR TILL DONE

120$:	CALL	150$		;;;GO TURN ON MEM MANAGMENT
	MOV	$$PWRP,R1	;;; Get number of seconds to wait
	MOV	#PR5,-(SP)	;;;DROP TO CPU PRIORITY 5 AFTER
	CALL	CLOKGO		;;; RE-STARTING THE SYSTEM CLOCK RUNNING
130$:	MOVB	TIMSEC,R0	;;GRAB CURRENT SECOND COUNTER VALUE
140$:	CMPB	R0,TIMSEC	;;SECOND UP YET?
	BEQ	140$		;;NO
	SOB	R1,130$		;;YES, LOOP IF MORE WAIT REQUIRED
	CALL	SETUP		;;AND THEN GO SET THINGS UP
	MOV	#10$,@#24	;;PRESET FOR ANOTHER FAILURE
	MOV	(SP)+,SPSAVE	;;SET THE DISPATCH ADDRESS
	CALLX	REGRES,R5	;;ALL DONE, RESTORE REGISTERS
	;LOG$PF			;;Don't LOG THAT POWER FAILURE
	MOV	#-1,-(SP)	;;SET THE 'POWER FAILURE' ERROR CODE
	JMP	@SPSAVE		;; AND EXIT

SETUP::	CALL	150$		;;GO TURN ON MEM MANAGMENT
	MOV	JOBF,R1		;;GET THE 'JOBF' POINTER
	CALL	@RESFPP		;;RESTORE ASYNC FPP UNIT IF ANY
	CALL	@PARSCN		;;RE-ENABLE UNIBUS PARITY CSR'S
	CALLR	ENBCHE		;; AND ANY CACHE PARITY
	;RETURN			;;ALL DONE SETTING UP

150$:	MOV	#SL.VAL,@STKLMT	;;RESTORE STACK LIMIT VALUE
	MOV	MMU22W+2,@MMU22W ;;ENABLE 22-BIT / UNIBUS WINDOW / D-SPACE
	MOV	#1,@#MMUSR0	;;TURN MEMORY MANAGEMENT ON
	RETURN			;;

160$:	.WORD	170200,62.		;UNIBUS WINDOW INFORMATION
170$:	.WORD	UISAR0, 8.,UISDR0, 8.	;USER MMU INFORMATION
	.WORD	KISAR0, 8.,KISDR0, 8.	;KERNEL I-SPACE MMU INFORMATION
180$:	.WORD	KDSAR0, 8.,KDSDR0, 8.	;KERNEL D-SPACE MMU INFORMATION
	.WORD	UDSAR0, 8.,UDSDR0, 8.	;USER D-SPACE MMU INFORMATION		;032
190$:					;END OF LISTS

.DSABL	LSB

	UNORG
 
GLOBAL	<PWFSAV,SL.VAL,STKLMT,MMU22W,RESFPP,X.SWRP>

.SBTTL	HANDLE PARITY/ECC ERRORS

	TMPORG	RTICTL

; THE ERROR LOG INFORMATION

;***** START OF GROUPING *****
$$CCTL	==	.	;**INIT** INITIAL CACHE ENABLE/DISABLE STATE
CTRLEV::.WORD	0	;DATA PATTERN TO RELOAD CONTROL WITH ON EXIT
LOWAD::	.BLKW		;LOW ORDER ADDRESS OF ERROR
HGHAD::	.BLKW		;HIGH ORDER ADDRESS OF ERROR (AND CYCLE TYPE)
MEMERR::.BLKW		;MEMORY ERROR STATUS REGISTER
UPELOG::.BLKW		;ADDRESS OF FAILING CSR
	.BLKW		;CONTENTS OF FAILING CSR WITH LOW ORDER ADDRESS
	.BLKW		;CONTENTS OF FAILING CSR WITH HIGH ORDER ADDRESS
	.BLKW		;K RANGE OF FAILING CSR
	.BLKW		;NUMBER OF FAILING ADDRESSES
	.BLKW		;BASE ADDRESS /100 OF FAILURE(S)
	.BLKW	5.	;FAILING OFFSET(S)
UPELGE::		;END OF FAILING OFFSET LIST
;***** END OF GROUPING *****

UPELSZ::.WORD	4*400+4	;PARITY/ECC ERROR LOG ENTRY SIZE

PARDSP:	.BLKW		;PARITY ERROR EXIT ADDRESS

$$PZER	==	.	;**INIT** FOR PARITY TABLE FILLING
PARZER::.WORD	1	;LOOKS LIKE NON-ERROR PARITY CSR

PARMIN:	.WORD	100000	;DUMMY FULL TIME ERROR WORD

; NON-ABORT CHECK LIST

;***** START OF GROUPING *****
CACHET:	.BYTE	44,120	;FORCE GROUP 1, MISS GROUP 0; DATA GROUP 0, ADDR GROUP 0
	 .WORD	0	; TIME THE ABOVE TYPE CACHE ERROR OCCURED
	.BYTE	30,240	;FORCE GROUP 0, MISS GROUP 1; DATA GROUP 1, ADDR GROUP 1
	 .WORD	0	; TIME THE ABOVE TYPE CACHE ERROR OCCURED
	.WORD	0	;LIST STOPPER
;***** END OF GROUPING *****

	TMPORG	RTI

$$PSCN	==	.	;**INIT** '$$RTSP' IF NO PARITY/ECC CSR'S
PARSCN::.WORD	UNISCN	;ONCE A SECOND PARITY/ECC SCANNING ROUTINE

GLOBAL	<UNISCN>

; VALUE/ADDRESS TABLE (SYSTEM DEPENDENT!)
;
;		DEFAULT		IF NO	 IF	  IF	  IF
;		TABLE		UNIBUS	CACHE	C+SWEEP	C+ADDRS

$$PTBL	==	.	;**INIT** TABLE TO BE CORRECTLY FILLED IN
PARTBL:	.WORD	0	;		17
			;		15 IF J11
CACHEC:	.WORD	JUNK	;		177746
	.WORD	ZERO	;				177740
	.WORD	ZERO	;				177742
	.WORD	UNISCN	;	$$RTSP			$$RTSP
	.WORD	PARMIN	;		177744
CACHES:	.WORD	0	;			2N BYTES

	UNORG

GLOBAL	<JUNK,ZERO,UNISCN>

.SBTTL	PARITY ERRORS (TRAPS TO 114) ENTER HERE

.ENABL	LSB

	VECTOR	114,,PR7	;PARITY ERRORS COME HERE

10$:	MOV	PARTBL,@CACHEC	;;;DISABLE CACHE WARNING TRAPS FIRST	;038
	MOV	#HALT,@#114	;;;FORCE ANOTHER TRAP TO HALT US
	MOV	#FTLFKM,PARDSP	;;;SET FATAL TYPE ERROR RETURN
	REGSAV			;;;SAVE ALL REGISTERS
	MOV	#4*400+4,UPELSZ	;;;INITIALIZE THE ERROR LOG FIELD 4
	MOV	#PARTBL+4,R5	;;;GET OUR TABLE POINTER		;038
	MOV	#LOWAD,R4	;;;PTR TO: LOW ADDR, HGH ADDR, MEM ERR
	MOV	@(R5)+,(R4)+	;;;SAVE LOW ORDER ADDRESS OF ERROR
	MOV	@(R5)+,(R4)+	;;;SAVE HIGH ORDER ADDRESS OF ERROR
	CALL	@(R5)+		;;;NOW SAVE MORE DATA IF NEEDED
FTLSCN::			;;;REFERENCE ONLY
	MOV	@(R5)+,(R4)	;;;SAVE MEMORY ERROR REGISTER
	MOV	(R4),@-(R5)	;;;NOW UNLOCK THE ERROR LOG/ADDRESS TRACKING
	;TST	(R4)		;;;CHECK FOR ABORT TYPE ERROR (BIT 15)
	BMI	40$		;;;IT IS AN ABORT
	MOV	#100$,PARDSP	;;;WARNING TRAP, JUST EXIT AFTER LOGGING
	MOV	#CACHET-2,R0	;;;GET (BIASED) WARNING TABLE POINTER
20$:	TST	(R0)+		;;;ADVANCE TO NEXT GROUP PATTERN
	MOVB	(R0)+,R1	;;;GET DISABLE GROUP BITS
	BEQ	80$		;;;END-OF-LIST, ALL DONE
	BITB	(R0)+,(R4)	;;;ERROR IN THIS GROUP?
	BEQ	20$		;;;NOPE, LOOP FOR NEXT GROUP
	CMP	(R0),TIME	;;;YEP, WITHIN THE SAME MINUTE?
	BNE	30$		;;;NOT SAME MINUTE, DON'T DISABLE GROUP
	BIS	R1,CTRLEV	;;;SAME MINUTE, DISABLE THIS GROUP
30$:	MOV	TIME,(R0)	;;;REMEMBER WHEN THE LAST ERROR OCCURED
	BR	20$		;;; AND LOOP FOR NEXT GROUP

GLOBAL	<HALT>

40$:	BIT	#050000,(R4)	;;;DOUBLE ERROR WITH LOCKED ADDRESSES?
	BNE	80$		;;;YES, THAT IS FATAL
	CMP	TOS.PS(SP),#37777 ;;;FROM USER MODE?				;032
	BLOS	80$		;;;NO, KERNEL MODE ERROR IS FATAL		;032
	MOV	-(R4),R0	;;;ELSE GET HIGH ORDER ADDRESS
	MOVB	R0,R0		;;; TRIMING OFF THE CYCLE TYPE
	MOV	-(R4),R1	;;;  AND GET THE LOW ORDER ADDRESS
	ASHC	#10.,R0		;;;SHIFT FOR MMU ADDRESS HERE AND
	ASHC	#-10.,R1	;;; THE MMU REMAINDER HERE
	MOV	JOBDA,R2	;;;GET JOB DATA POINTER AND
	ADD	#JDMCTL,R2	;;; INDEX TO MEMORY CONTROL SECTION
	MOVB	M.SIZE(R2),R4	;;;GET SIZE OF JOB IN K AND
	ASH	#11.-6.,R4	;;; FIND THAT SIZE AS 32W BLOCKS
	MOV	R0,R3		;;;SAVE THE MMU ADDRESS OF ERROR
	SUB	M.PHYA(R2),R0	;;;FIND DISTANCE FROM THIS JOB
	CMP	R0,R4		;;;IS ERROR TOTALLY WITHIN JOB?
	BHIS	80$		;;;NOPE, ABOVE OR BELOW, CALL IT FATAL
	CALLX	REMJOB		;;;YEP, REMOVE JOB FROM MEMORY LIST
	MOV	R5,-(SP)	;;;Get a scratch register		;043
	MAP	JOBJC6,APR=6,DATA ;;;Map caller's JCR entry		;043
	MOV	JOBJCR,R5	;;;And point to it			;043
	MOVB	JCHDRS(R5),R4	;;;Get job header size			;043
	ASH	#11.-6,R4	;;;Convert to slivers			;030
	CMP	R0,R4		;;;Is error in job header?		;030
	BHIS	45$		;;;No, so no big deal			;030
	MOVB	M.SIZE(R2),JCSIZN(R5) ;;;Yes, set current size as next 	;043
	CLRB	M.SIZE(R2)	;;; and no current size			;030
	BIS	#J2IHDR,JDFLG3-JDMCTL(R2) ;;;Flag that header needs initialize	;043
45$:	MOV	(SP)+,R5	;;;Restore work register		;043
	;MAP	PUSH,APR=6,DATA	;;;NO NEED TO SAVE THIS			;030
	MAP	R3,APR=6,DATA	;;;NOW MAP US TO THE ERROR LOCATION
	BIC	#1,R1		;;;MAKE THE REMAINDER ADDRESS EVEN AND
	ADD	#140000,R1	;;; ADD IN THE PAR6 BIAS
	MOV	#50$,@#114	;;;WE WILL TAKE ANOTHER TRAP NOW
	MOV	#0,(R1)		;;; 1) CLEAR LOCATION
	COM	(R1)		;;; 2) COMPLEMENT IT TO ALL 1'S
	DEC	(R1)		;;; 3) JIGGLE LOW BYTE PARITY
	SWAB	(R1)		;;; 4) SWITCH BYTES TO JIGGLE HIGH BYTE PARITY
	TST	(R1)		;;; 5) ENSURE FULLY READABLE
	MOV	#HALT,@#114	;;;NO TRAP, SO DISABLE FURTHER ONES
	BR	60$		;;;CALL IT USER FATAL AND SOFT

GLOBAL	<HALT>

50$:	MOV	#HALT,@#114	;;;TRAPPED AGAIN, DISABLE FURTHER TRAPS
	CMP	(SP)+,(SP)+	;;;POP THE PUSHED PC/PS
60$:	BIT	#050000,@(R5)+	;;;DOUBLE TRAP?
	BNE	80$		;;;YES, THAT IS ALWAYS FATAL
	MOV	@-(R5),@(R5)+	;;;NO, RE-ENABLE ERROR LOG/TRACKING
	BUFFER	GETSML		;;;GET A 16W BUFFER FOR THE DISABLED MEMORY
	BVS	80$		;;;FAILED TO GET ONE, DIE
	CMP	(R4)+,(R4)+	;;;OFFSET +4 IS FOR LOCKED MEMORY
	MOV	#<MC.LCK*400+1>,M.SIZE(R4) ;;;Locked W/1K dead memory	;036
	BIC	#37,R3		;;;ADD IT AT THE NEXT LOWER 1K BOUNDARY
	CALLX	ADDMEM		;;;NOW ADD NEW ITEM TO THE MEMORY LIST
70$:	MOV	#FTLTRP,PARDSP	;;;INDICATE ONLY FATAL TO THE USER JOB
80$:	CALLX	REGRES,R5	;;;RESTORE ALL REGISTERS
	CMP	PARDSP,#FTLFKM	;;; Fatal crash error?
	BEQ	85$		;;; Yes, don't log it
	LOG$PA			;;;LOG THE PARITY ERROR
85$:	SETERR	B.PRTY,-(SP),WORD ;;;SET PARITY ERROR CODE
	MOV	PARDSP,-(SP)	;;; AND SET THE RETURN ADDRESS
	MOV	#10$,@#114	;;;ALLOW MORE PARITY TRAPS NOW
ENBCHE:	MOV	R0,-(SP)	;;;GET WORKING REGISTER
	MOV	CACHES,R0	;;;NOW GET THE CACHE SWEEP AMOUNT
	CALL	CSWEEP		;;; and go sweep cache			;064
	MOV	(SP)+,R0	;;;DONE, RESTORE WORKING REGISTER
	RETURN			;;; AND EXIT

			;;;sweep done by force read of each cache cell	;064
CSWEEP:	MOV	CTRLEV,@CACHEC	;;;RE-ENABLE CACHE AS SPECIFIED		;064
90$:	TST	-(R0)		;;;"SWEEP" A CACHE ADDRESS		;064
	TST	R0		;;;MORE?				;064
	BGT	90$		;;;YES, CONTINUE SWEEPING...		;064
	RETURN			;;;Done return to caller		;064

POPRT4:	MOV	DATE,IDATE	;;;RESET STARTING DATE
	MOV	TIME,ITIME	;;; AND TIME
100$:	TST	(SP)+		;;;DUMP ERROR CODE ON WARNING TRAP
	JMP	RTI47		;;; AND JUST EXIT

.DSABL	LSB

GLOBAL	<HALT,IDATE,ITIME>

.SBTTL	INTERRUPT SAVE ROUTINE

;+
; INTSVX - ALTERNATE INTERRUPT SAVE ROUTINE.
;
;		VECTOR	XXX,??,PRX,UNIT
;
;	??:	CALL	INTSVX,R5
;		  .WORD	<POINTER TO KISAR5 VALUE>
;		  .WORD	INT$??
;
;	INT$??::...
;		RETURN
;
; R0 IS SET TO DOUBLE THE VALUE IN BITS <3-0> OF THE PS PART OF THE VECTOR.
;-

.ENABL	LSB

	TMPORG	RTICTL							;054

LSTINT::.WORD	0		;Last interrupt XXDINT area + 4		;054

	UNORG								;054

INTSVX::MOV	@#PS,-(SP)	;;IMMEDIATELY SAVE PS ON STACK
	MOV	R3,-(SP)	;;NOW SAVE R3
	MOV	@(R5)+,R3	;;PUT APR5 VALUE INTO HOLDING
	BR	10$		;;GO JOIN COMMON CODE

;+
; INTSAV - INTERRUPT SAVE ROUTINE.
;
;		VECTOR	XXX,??,PRX,UNIT
;
;	??:	CALL	INTSAV,R5
;		  .WORD	<KISAR5 VALUE>
;		  .WORD	INT$??
;
;	INT$??::...
;		RETURN
;
; R0 IS SET TO DOUBLE THE VALUE IN BITS <3-0> OF THE PS PART OF THE VECTOR.
;-

INTSAV::MOV	@#PS,-(SP)	;;IMMEDIATELY SAVE PS ON STACK
	MOV	R3,-(SP)	;;NOW SAVE R3
	MOV	(R5)+,R3	;;PUT APR5 VALUE INTO HOLDING
10$:	MOV	R2,-(SP)	;;NOW SAVE R2,
	MOV	R1,-(SP)	;; AND R1,
	MOV	R0,-(SP)	;;  AND R0
	MOV	4*2(SP),R0	;;GET SAVED PS BACK INTO R0
	MOV	R4,4*2(SP)	;;NOW REPLACE IT WITH INTERRUPTED R4
	BIC	#^C<17>,R0	;;ISOLATE BITS <3-0> FROM SAVED PS
	ASL	R0		;;NOW DOUBLE THAT VALUE
	MOV	R5,LSTINT	;;Save the XXDINT region pointer	;054
	MAP	PUSH,APR=5,CODE,DATA ;;SAVE INTERRUPTED CODE MAPPING REGISTER
	MAP	R3,APR=5,CODE,DATA ;;LOAD WHAT THIS INTERRUPT WANTS
	CALL	@(R5)+		;;NOW CALL THE INTERRUPT SERVICE
	MAP	POP,APR=5,CODE,DATA ;;RESTORE INTERRUPTED MAPPING
	.BR	RESRT4		;;GO EXIT FROM INTERRUPT

.DSABL	LSB


.SBTTL	INTERRUPT, MONITOR PROCESS EXITS

;+
; RESRT4 - RETURN FROM INTERRUPT WITH ALL REGISTERS SAVED.
;
;	JMP	RESRT4
;-

.ENABL	LSB

RESRT4::CMPB	#PR1!T!N!Z!V!C,7*2(SP) ;;IS INTERRUPTED PROCESS IN MONITOR?
	BLO	80$		;;YES, SIMPLY RETURN TO IT THEN (C=1)	;064
	.BR	RTI3		;;go exit				;067

;+
; RTI3 - EXIT FROM INTERRUPTABLE MONITOR PROCESS.
;
;	JMP	RTI3
;-

RTI3PH::			;;;used in MCP phase
RTI3::	SPLC	7		;;;ENSURE NO INTERRUPTS NOW
	CMP	#106,@#0	;;;Does '0' contain the right value?	;054
	BEQ	10$		;;;Yes, continue			;064
	NOP			;;;space for intercept patching		;067
	BEQ	10$		;;;space for intercept patching		;067
	MOV	#3,R0		;;;Set the RTI3 check flag		;064
	CALL	CHECK0		;;;check for cache aborations		;064
	BNE	40$		;;;No warp here, she really is broken!	;064
10$:	BIT	#JFASTD!377,@JOBF ;;;Job posting set?			;064
	BNE	30$		;;;yes, go do it			;064
	MOV	#L3QUE,R0	;;;get top of L3 que			;064
20$:	TST	(R0)+		;;;test for empty, & point at tail	;064
	BEQ	70$		;;;it is empty for sure			;064
30$:	JMP	@#DOL3Q		;;;process the contents of L3 Queue	;064

	NOP			;;;space for intercept patching		;067
	NOP			;;;space for intercept patching		;067

40$:	CRASH			;;;Zero has been corrupted		;064

70$:	CMP	R0,#L3QEND	;;;Next word in L3Q			;064
	BLO	20$		;;;keep checking			;064
	;CLC			;;;BLO=BCS				;067
80$:	MOV	(SP)+,R0	;;;RESTORE R0,				;064
	MOV	(SP)+,R1	;;; AND R1,
	MOV	(SP)+,R2	;;;  AND R2,
	MOV	(SP)+,R3	;;;   AND R3,
	MOV	(SP)+,R4	;;;    AND R4,
	MOV	(SP)+,R5	;;;     AND R5
	BCS	RTIMON		;;;BACK TO MONITOR PROCESS IF C=1
RTITIM:	BIT	#100100,@CLKCSR	;;;IS CLOCK IN BAD SHAPE?
$$CNOP	==	.	;**INIT** A 'NOP' TO DISABLE CLOCK CHECKING
	BLE	CLOKGO		;;;YES, FAKE CLOCK INTERRUPT
	CLR	CPUTIM		;;;Clear out pointer to CPU bucket	;043
	MOVB	JOB,CPUTIM	;;;Set job the job # * 2		;043
	ADD	#JBTICK,CPUTIM	;;;And point to our job's tick bucket	;043
RTIMON:: RTI			;;;EXIT FROM THIS INTERRUPT

	NOP			;;;space for intercept patching		;067
	NOP			;;;space for intercept patching		;067

CHECK0:	MOV	@#0,R1		;;;save what was found @0 for logging	;064
	MOV	PARTBL,@CACHEC	;;;Disable cache			;064
	CMP	#106,@#0	;;;cache now off, is crash now ok?	;064
	BNE	90$		;;;No, everyone agrees,end her misery	;064
	MOV	LSTINT,R2	;;;include last interrupting device	;064
	MOV	LSTL3Q,R3	;;;also log last L3 Que service		;064
	LOG$CP			;;;0 in cache<>0 in main memory		;064
	MOV	#1026.,R0	;;;CACHE sweep amount = 2Kb		;064
90$:	CALL	CSWEEP		;;;try again after sweeping cache	;064
	CMP	#106,@#0	;;;is loc 0 ok now cache on & clean	;064
	RETURN			;;;caller does test on return, if 0=ok	;064

.DSABL	LSB

GLOBAL	<JBTICK>							;043

.SBTTL	CLOCK INTERRUPTS

;+
; ALL CLOCK INTERRUPTS COME HERE.
;-

	TMPORG	RTICTL

SUBCNT:	.WORD	60./60.		;CLOCK SUB-COUNT
SYSTIC::.WORD	0		;System tick accumulator		;040
JSTATS::.WORD	RTSPC		;Pointer to statistics intercept	;061

	TMPORG	RTI
                                    
.ENABL	LSB

$$CCSR	==	.	;**INIT** CLOCK CSR GOES HERE
CLKCSR:	.WORD	JUNK		;CLOCK CSR (NON-EXISTENT)
$$CPRM	==  	.	;**INIT** CLOCK PARAMETER(S) GO HERE
10$:	.WORD	1		;HARDWARE SUBDIVISION COUNT
$$CLK2	==	.	;**INIT** Changed to GPK clock CSR2 if a GPK sys ;057
CLKCS2:	.WORD	ZERO		;GPK clock CSR 2 or read-only dummy	 ;057

	UNORG

; The GOSTAT routine is used to transfer control to the statistics code.
; Note that the stats code needs to be passed mapping and the saved PC/PS
; on the stack. Do not change the stack handling without modifying JQSTAT
; as well.

GOSTAT::MAP	PUSH,APR=5,CODE,DATA ;;Save mapping (stats code needs it!) ;061
	MAP	GRDAP5,APR=5,CODE,DATA ;;Map the stats code		;061
	CALL	@DOSTAT		;;Collect the statistics		;061
	MAP	POP,APR=5,CODE,DATA ;;Restore mapping			;061
	RETURN			;;And back to the clock service		;061

CLOK.P::TST  	@#PKS	  	;;KW11-P OVERRUN?
	BPL	CLOK.L		;;NO
	INC	JSTATO		;;YES, COUNT THE KW11-P OVERRUNS	;061
	MOV	@#DATE,JSTATD	;;SAVE DATE            			;061
	MOV	@#TIME,JSTATD+2	;;AND TIME                              ;061
	MOV	@#TIMSEC,JSTATD+4 ;;AND SECONDS OF LAST OVERRUN         ;061
CLOKGO::CLR	@CLKCSR		;;YES, STOP THE CLOCK
	CMP	CLKCSR,#PKS	;;KW11-P CLOCK?
	BNE	20$		;;NO, KW11-L CLOCK, SO NO PARAMETERS
	MOV	10$,@#PKS+2	;;RELOAD THE KW11-P
	MOV	10$,@#PKS+4	;; CLOCK PARAMETERS
20$:	MOV	#115,@CLKCSR	;;NOW RE-START THE CLOCK
$$CSRT	==	.-4	;**INIT** ALTERED FOR DIFFERENT SPEEDS
CLOK.L::CALL	@JSTATS		;;Run statistics if needed		;061
	INC	@CPUTIM		;;COUNT AGAINST RUN-TIME
	ADD	#<10000.+<60./2>>/60.,JOBQNT ;;COUNT AGAINST RESIDENCY QUANTUM
$$CQNT	==	.-4	;**INIT** SET AS <10000.+<FREQ/2>>/FREQ
	TST	@CLKCS2		;;Re-arm GPK clock if GPK system	;057
	DEC	SUBCNT		;;UP TO A SYSTEM TICK YET?
	BNE	RTI47		;;NO, JUST EXIT
	MOV	#60./60.,SUBCNT	;;YES, RESET THE SUB-COUNT
$$CCNT	==	.-4	;**INIT** SET AS FREQ/TICK
	INC	SYSTIC		;; and count another system tick	;040

GLOBAL	<JUNK,JOBQNT,RTSPC,GRDAP5,DOSTAT,JSTATO,JSTATD>			;061

	TMPORG	RTICTL
           
WAIT1T:	.BLKW0	L3QLEN		;L3Q bit(s) for 1 tick later		;033
WAIT2T::.BLKW0	L3QLEN		;L3Q bit(s) for 2 ticks later		;033
WAIT2E:									;033

	UNORG             

	JSR	PC,@(PC)+	;;TELL 2780 (RJE) ANOTHER TICK PASSED
SYTTMO:: .WORD	RJETMO		;; (THIS WORD MAY HOOK ELSEWHERE, E.G. NR:)
	MOV	R0,-(SP)	;;Save R0				;033
	MOV	#WAIT2T,R0	;; to use as an offset			;033
25$:	BIS	WAIT1T-WAIT2T(R0),L3QUE-WAIT2T(R0) ;; OR 1 tick later into L3Q	;033
	MOV	(R0),WAIT1T-WAIT2T(R0) ;; Move 2 ticks later into 1 tick ;033
	CLR	(R0)+		;;And no more 2 ticks			;033
	CMP	R0,#WAIT2E	;;Next word in L3Q			;033
	BLO	25$		;;					;033
				;;DONE WITH DELAYED L3Q			;033
	DECB	TIMCLK		;;Is a second up yet?			;033
	BNE	30$		;;No					;033
	MOV	#TIMCLK,R0	;;Use R0 as pointer			;033
	MOVB	#60.,(R0)	;;RESET "UNTIL NEXT SECOND" COUNTER
$$TICK	==	.-2	;**INIT** SET AS TICK
	L3QSET	QTIMER		;;SIGNAL ONCE A SECOND ROUTINE
	DECB	-(R0)		;;IS A MINUTE UP YET?
	BNE	30$		;;NOPE
	MOVB	#60.,(R0)	;;YEP, RESET "UNTIL NEXT MINUTE" COUNTER
	DEC	-(R0)		;;IS A DAY UP YET?
	BNE	30$		;;NOPE
	MOV	#1440.,(R0)	;;YEP, RESET "UNTIL NEXT DAY" COUNTER
	INC	-(R0)		;; AND CALL IT A DAY...
	CMP	(R0),#-1  	;;YEAR UP YET?
$$LDAY	==	.-2	;**INIT** SET AS FIRST INVALID DAY OF YEAR
	BNE	30$		;;NOPE
	MOV	#0,(R0)		;;YEP, GO TO THE NEXT YEAR
$$NDAY	==	.-2	;**INIT** SET AS FIRST DAY OF THE NEXT YEAR
30$:	MOV	(SP)+,R0	;;Restore R0				;033
	DEC	QUANT		;;Run burst expired?			;033
	BPL	RTI47		;;NOPE
	L3QSET	QSCHED		;;YEP, CALL SCHEDULER
	.BR	RTI47		;;NOW EXIT
         
.DSABL	LSB

GLOBAL	<RJETMO,QUANT>


;+
; RTI47 - RETURN FROM INTERRUPT WITH NO REGISTERS SAVED.
;
;	JMP	RTI47
;-

RTI47::	CMP	#106,@#0	;;Is the contents of zero correct?	;054
	BEQ	3$		;;Yes, continue				;054
	REGSAV			;;save for the error logging data	;064
	MOV	#47,R0		;;Set the RTI47 check flag		;064
	CALL	CHECK0		;;check for cach aboratioons		;064
	BNE	39$		;;she really broken			;064
	REGRES			;;caught it trying to fool us, it lives	;064
3$:	CMPB	#PR1!T!N!Z!V!C,1*2(SP) ;;IS INTERRUPTED PROCESS IN MONITOR?
	BLO	390$		;;YES, JUST RETURN TO IT THEN		;064
	SPLC	7		;;;ENSURE NO INTERRUPTS NOW
	MOV	R5,-(SP)	;;;Save R5				;033
	BIT	#JFASTD!377,@JOBF ;;;Job posting?			;043
	BNE	40$		;;;Yes, go for it			;043
	MOV	#L3QUE,R5	;;; to use as a pointer			;033
38$:	TST	(R5)+ 	  	;;;Anything pending in L3Q		;033
	BNE	40$		;;;Yes, do it				;033
	CMP	R5,#L3QEND	;;;Next word in L3Q			;033
	BLO	38$		;;;					;033
	MOV	(SP)+,R5	;;;No, restore R5			;033
	JMP	RTITIM		;;; and get out				;061

39$:	CRASH			;;No, crash the system			;064

390$:	JMP	RTIMON		;;travellers return through same portal	;064

40$:	MOV	R4,-(SP)	;;;Save other registers,		;033
	MOV	R3,-(SP)	;;; R5 is already saved			;033
	MOV	R2,-(SP)	;;; 					;033
	MOV	R1,-(SP)	;;; 					;033
	MOV	R0,-(SP)	;;; 					;033
	.BR	DOL3Q		;;; and do level 3 work			;033

.SBTTL	LEVEL 3 QUEUE DISPATCHING

	TMPORG	RTICTL

L3QUE::	.BLKW0	L3QLEN		;Level 3 queue control words		;033
L3QEND::								;033
LSTL3Q::.WORD	-3		;Last directive/L3Q process to run	;054
        
	UNORG	
		
;+		
; DOL3Q - PROCESS HIGHEST PRIORITY L3Q TASK.	
;-						
						
DOL3Q:	MOV	#L3QUE,R0	;;;L3Q control word pointer		;033
	CLR	R2		;;;No initial offset			;033
5$:	MOV	(R0)+,R1	;;;Anything on here?			;033
	BNE	10$		;;;Yes, go do it			;033
	ADD	#20,R2		;;;Initial offset for next word		;033
	CMP	R0,#L3QEND	;;;Any more words in L3Q		;033
	BLO	5$		;;;Yes, check next word			;033
	BR	30$		;;;No, check for job posting		;033

10$:	NEG	R1		;;;ALTER LOWEST 1 BIT
	BIC	R1,-(R0)	;;;CLEAR BIT IN THE CONTROL WORD
	SPLC	3		;;;DROP TO INTERRUPTABLE LEVEL NOW
	TSTB	R1		;ANY BIT ON IN THE LOW BYTE?
	BNE	20$		;YES
	SWAB	R1		;NO, SWITCH TO HIGH BYTE
	ADD	#10,R2		; AND BUMP INDEX TO 8 BITS WORTH
20$:	INC	R2		;INCREMENT THE OFFSET VALUE
	ROR	R1		; AND CHECK FOR A 1 BIT
	BCC	20$		;NOT HERE, LOOP
	ASL	R2		;NOW MAKE OFFSET INTO WORD VALUE
	DEC	R2		;Now get position into table + 1	;054
	MOV	R2,LSTL3Q	;And save it away			;054
	MAP	@L3QPAR-1(R2),APR=5,CODE,DATA ;SET UP THE MAPPING REGISTER ;054
	MOV	#JUNK,CPUTIM	;DON'T CHARGE CPU TIME FOR LEVEL 3 TASKS
	CCC			;ENSURE CC'S ALL 0 ON L3Q DISPATCH
	JMP	@L3QTBL-1(R2)	; AND GO OFF TO IT...			;054

;+
; CONDITIONS ON LEVEL 3 TASK ENTRY:
;
;	ALL REGISTERS SCRATCH
;	PROCESSOR PRIORITY 3 (INTERRUPTABLE)
;	C=0
;
; EXIT WITH:
;
;	JMP	RTI3
;-

30$:	SPLC	5		;;DROP TO ONLY NON-TERMINAL INTERRUPTABLE
	MOV	#-1,LSTL3Q	;;Mark that posting is running		;054
	MAP	EMTAP5,APR=5,CODE,DATA	;;GET THE POSTING CODE MAPPED
	JMP	@DOPOST		;; AND GO OFF TO IT

GLOBAL	<JUNK,DOPOST,EMTAP5>

.SBTTL	PEEK ROUTINE FOR ERROR LOGGING

;+
; PEEKER - ERROR LOGGING PEEK ROUTINE TO I-SPACE.
; DPEEKR - .PEEK PEEK ROUTINE TO D-SPACE.
;
;	R1 -> DATA TO OBTAIN
;	PREVIOUS MODE SET CORRECTLY
;
;	CALL	PEEKER		(I-SPACE)
;	CALL	DPEEKR		(D-SPACE)
;
;	R0 =  ERROR CODE (0 FOR NO ERROR)
;	R1 =  R1 +2 (I.E. R1 'POPPED')
;	R2 =  THE OBTAINED DATA (ERROR CODE IF ERROR)
;
;	IF Z=1 THEN NO ERROR (R0 = 0)
;	IF Z=0 THEN ERROR (R0 <> 0)
;-

.ENABLE	LSB

PEEKER::MOV	SP,R2		;;;SAVE THE CURRENT SP STACK VALUE
	MFPI	(R1)+		;;;GET THE DESIRED DATA WORD

ERLPEK:				;;;SPECIAL CASED ADDRESS FOR 4 & 250 TRAPS
	BR	10$		;;;JOIN UP
DPEEKR::MOV	SP,R2		;;;SAVE THE CURRENT SP STACK VALUE
	MFPD	(R1)+		;;;GET THE DESIRED DATA WORD
ERLDPK:				;;;SPECIAL CASED ADDRESS FOR 4 & 250 TRAPS
10$:	MOV	(SP)+,R2	;;;PUT OBTAINED DATA HERE
	CLR	R0		;;; AND SET NO ERROR
	;SEZ			;;;  AND Z=1 (FROM 'CLR')
	RETURN			;;;NOW EXIT

.DSABL	LSB

.SBTTL	POKE ROUTINE FOR RSX EMULATION

;+
; UPOKER - USER MODE POKER.
;
;	R0 =  DATA TO POKE
;	R1 -> LOCATION +2 TO POKE (I.E. 'PUSH DATA')
;
;	CALL	UPOKER
;
;	R0 =  ERROR CODE (0 FOR NO ERROR)
;	R1 =  R1 -2 (I.E. R1 'PUSHED')
;	R2 =  UNDEFINED
;
;	IF Z=1 THEN NO ERROR (R0 = 0)
;	IF Z=0 THEN ERROR (R0 <> 0)
;-

UPOKER::BIS	#034000,@#PS	;ENSURE PREVIOUS MODE = USER
	MOV	SP,R2		;SAVE THE CURRENT SP STACK VALUE
	MOV	R0,-(SP)	;PUT DATA TO POKE ON STACK
	MTPD	-(R1)		;SET THE DESIRED DATA WORD PUSHING
ERLPOK:				;SPECIAL CASED ADDRESS FOR 4 & 250 TRAPS
	CLR	R0		;SET NO ERROR
	;SEZ			; AND Z=1 (FROM 'CLR')
	RETURN			;NOW EXIT


	.END
