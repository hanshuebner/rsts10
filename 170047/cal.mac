.INCLUDE /CMN:COMMON.MAC/
.INCLUDE /CMN:KERNEL.MAC/
.INCLUDE /CMN:FLDEF.MAC/
.INCLUDE /CMN:KBDEF.MAC/
.INCLUDE /CMN:HDRDEF.MAC/
TITLE	CAL,<MONITOR CALL HANDLERS>,0K,04-JUN-92,MHB/ABC/MJG/RTW/SJM/GPK/RRF/PRL/WJS/FEK/MNB/KPH/FRL/WRM/JFM

;
;		COPYRIGHT (c) 1974, 1992 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR CAL

;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;  001  TG   27-Jun-80	Added GEN phase stuff
;  002	RTW  02-Jul-80	Change .SLEEP code for multiple ribs
;  003	RTW  02-Jul-80	Change posting code for multiple ribs
;  004	RTW  03-Jul-80	Fix big in multiple rib dopost code
;  005	RTW  09-Aug-80	Add complex emt code
;  006	SM   13-Feb-81	Source fix for patch 3.1.8
;  007	SJM  06-Apr-81	Add default KBM support
;  008	GPK  15-May-81	Change conditional sleep to test message count
;  009	RRF  07-Jul-81	Added IOREDO table and IOREDO for .SPEC
;  010	SJM  08-Jul-81	Add support for I&D space
;  011	SRM  22-Sep-81	Add changes for FIP Pool.
;  012	PRL  28-Jun-82	CREATION - COPIED FROM V7.2-04
;  013	PRL  28-Jun-82  remove .WRITE XRBC posting pattern
;  014  WJS  16-Oct-82  MOVFQB added;  some cleanups
;  015	GPK  11-Nov-82	32K jobs
;  016	WJS  25-Nov-82	BUFFER RETCHN substituted for CALLX RETCHN;
;			  hook for retrieval of EML logging packets
;  017	WJS  13-Dec-82	BL4+ changes for EMT Logger
;
;				[RSTS V9.0]
;  018	GPK  04-Mar-83	Job headers
;  019	GPK  12-Apr-83	Multiple privileges
;  020	GPK  17-May-83	Change J2HDRS to a byte
;  021	GPK  07-Jun-83	Change .PRIV to .BPRIV
;  022	FEK  13-Jun-83	Add user I/D support
;  023	FEK  14-Jul-83	Only add J2HDRS once if shrinking job size
;			AND make R0->JDB2 when needed
;  024	GPK  21-Sep-83	Remove job headers, privs into JDB2
;  025	GME  01-Aug-83	Asynchronous I/O changes
;  026	GPK  19-Nov-83	Make JFBIG read-only bit (.SET, .CLEAR)
;  027	FEK  02-Dec-83	Bug fixes in mapping I/D split tasks
;  028	KPH  11-Jan-84	Move some code to MCL module
;  029  GPK  23-Jan-84  Rename WWORLD to WWRITE
;  030  MNB  23-Jan-84  Asynch changes to M.CTRL byte
;  031  MNB  27-Jan-84  More asynch I/O changes
;  032  MNB  14-Feb-84  Add POSTAS routine (Asynch-specific posting)
;			Add MOVUSR routine (MOVASY's "brother")
;			Add .ASTX Monitor call handler
;  033  GPK  08-Mar-84  Changes for .RTS and .EXIT run-down
;  034  MNB  26-Mar-84  Add SWPASY, Delete MOVUSR
;			Add .AST Monitor call handler
;			Add Asynch I/O outstanding .CORE refusal
;  035	KPH  04-Apr-84	Clean up .CORE code
;  036  FRL  04-Apr-84  V9.0 logicals
;  037  MNB  02-May-84	Add RTS/EXIT stall if outstanding I/O
;			Disallow asynch posting before complex EMT finishes
;  038	GPK  20-Apr-84	Privilege name changes, remove large posting
;  039	KPH  25-Jun-84	Bugfixes
;			Change RTS/EXIT stall to allow entry from TTDVR
;			Ignore JFGO for PFB and EXIT redo
;  040  MNB  23-Jul-84	Add "TUNE" priv check for asynch I/O requests
;  041	KPH  02-Aug-84	Don't conditional sleep with pending asynch I/O
;			Don't dump the job on conditional sleeps
;  042	KPH  07-Sep-84	Bugfixes in asynchronous posting
;  043	KPH  29-Aug-84	Changes for APR5 FIP pool
;			Move USRSET to GEN phase
;  044	KPH  23-Oct-84	Changes for non-SLA libraries
;  045	KPH  03-Dec-84	Make J2ISIZ and J2DSIZ bytes
;			Changes for multiple-non-sla attaches
;			Pass .AST parameter in XRB
;  046  KPH  11-Mar-85	Bugfix in SLA libraries
;  047	KPH  25-Mar-85	Change asynch I/O small buffer leave amount to 60.
;
;			[RSTS V9.1]
;  048  KPH  31-May-85	Fix EMT logging error code return
;
;			[RSTS V9.2]
;  049  KPH  30-Jul-85	Add job control region
;			Move IOB to FIP pool
;
;			[RSTS V9.3]
;  050  KPH  01-Jun-86	Change XBUF return convention to slivers
;  051  KPH  04-Jun-86	Change BAKLRG address convention to slivers
;  052  KPH  08-Jul-86	Move buffer handling stuff to BUFSUB
;
;			[RSTS V9.4]
;  053  KPH  28-Jan-87	New job mapping structure
;
;			[RSTS V9.6]
;  054  WRM  11-Jan-88	Add EXTM$ call to .CORE
;  055  WRM  08-Jun-88	Fix spec description difference with RSX-11
;
;			[RSTS/E V9.7]
;  056  WRM  11-Oct-88	Disable .READA/.WRITA/.ASTX from supervisor mode
;
;			[RSTS/E V10.0]
;  057  WRM  30-OCT-89	Add extended Logical feature
;  058	JFM  21-Dec-89	Fix up recall pointers if user hits CTRL/C
;  059  WRM  13-Feb-90	add user logical translate to .LOGS as subfunction
;			adjust .CORE math for header size vs RTS limits
;  060	FEK  05-Oct-89	Allow non-TUNE users 1 .READA/.WRITA
;  061  WRM  22-Feb-90	Add RAD50 to ascii translation
;  062	JFM  13-Mar-90	Don't sleep if unconditional sleep 0 requested
;  063  WRM  25-Apr-90	Search logical Disk list after user logical list
;
;			[RSTS/E V10.1]
;  064  WRM  20-Nov-90	fix mapping error on logical found in user space
;  065	DRP  04-Jun-91	Fix bug in LOGLEN which incorrectly determines the
;			length of logicals that are 7, 8 or 9 characters
;			long.
;  066	JFM  19-Jun-91	RECCC routine renamed to RECSTR
;  067	DRP  30-Jul-91	Source clear patch 3.1.2.
;  068	FEK  16-Sep-91	Bug fixes in .CORE
;  069	FEK  21-May-92	Don't leave trash flags in APRMSK
;-



	DEFORG	CAL
	DEFORG	RDOTBL		; REDO table lives here
	ORG	CAL

.SBTTL	Handle .POSTN monitor call

	EMTENT	.POSTN		; .POSTN comes here

	CALL	CMNSIO		; Do the common i/o thing
	MOV	$SIZTBL(R4),(R3)+ ; Put width+1 in XRB @+0
	CLR	(R3)		;  and dummy in position=0 in XRB @+2
	TST	-(R3)		; Was there a width+1 in the table?
	BNE	20$		; Yes, so all done
				; (note that disks always have a "width+1")
	MOVB	DDHORC(R1),(R3)	; No, fill in width+1 from the DDB
	CMPB	R0,#IDX.KB	; Is this a terminal?
	BNE	10$		; No
	CMPB	DDJBNO(R1),JOB	; Yes, does the job own this terminal??
	BEQ	10$		; If owned then give the real information
	ERROR	DETKEY		;  else give the detached error

10$:	MOV	(R3)+,(R3)	; Copy the width+1 value and
	SUB	DDHORZ(R1),(R3)	;  calculate the position
.ASSUME	DDHORZ&1 EQ	0
	BIC	(PC)+,(R3)	; Trim position to only 8 bits
	 .BYTE	0,-1
20$:	RETURN			;  and exit

GLOBAL	<$SIZTBL,IDX.KB>

.SBTTL	Handle .RTS monitor call

.ENABL	LSB

	RDOENT	EXIRDO		; EXIT/RTS redo starts here		;037

	MOV	#RTI3,(SP)	; Be sure to exit to RTI3		;039
	MOV	JOBF,R1		; Load the JDB ->			;037
	MOV	JOBJD2,R2	; Load the JDB2 ->			;037
	MOV	#FIRQB+140000,R4 ; Load the User FIRQB ->		;037
	MOV	JOBRTS,R5	; Load the RTS block ->			;037
	TST	XRBUSE(R3)	; Is this a .RTS style call?		;039
	BEQ	35$		; No, .EXIT, go and do it		;039

;+
;	R0 =  EMT CODE
;	R1 -> JOBDA @JOBF
;	R2 -> JDB2
;	R3 -> [mapped] XRB
;	R4 -> [mapped] FIRQB
;	R5 -> RTS BLOCK being used by the caller
;	SP -> "RTI3", R0, R1, R2, R3, R4, R5, PC, PS, ...
;-
	EMTENT	.RTS		;.RTS comes here

	MOV	JOBWRK,R3	; R3 -> Job's work block		;039
	MOV	R3,XRBUSE(R3)	; Indicate .RTS style switch		;039
	CLR	-(SP)		; Indicate normal RTS switch (+0)
	MAP	JOBJC6,APR=6,DATA ; Map the job control region entry for job ;049
	MOV	JOBJCR,R0	; Pick up pointer to JCR entry		;049
	MOV	JCDRTS(R0),R3	; Preset pointer to private default RTS	;049
	MAP	@UDPAR0,APR=6,DATA ; Now re-map the user's first 4K	;049
	TST	FQNAM1(R4)	; Switch to private default (0 name)?
	BEQ	50$		; Yes, so do it
	CALLX	FNDRTS		; No, try to find RTS by name
	CMP	FQEXT(R4),#-1	; Found, establish as private default??
	BNE	20$		; No
	BIT	#PF.KBM,R.FLAG(R3) ; Yep, is it a keyboard monitor?
	BEQ	10$		; No, so forget it			;039
	MAP	JOBJC6,APR=6,DATA ; Map the JCR entry again		;049
	MOV	R3,JCDRTS(R0)	; Set the default			;049
	BR	50$		; And join the .EXIT code		;039

10$:	ERROR	PRVIOL		; Illegal RTS switch attempted

20$:	CMP	FQEXT(R4),#-2	; Switch keeping job context?
	BNE	50$		; No, just a simple switch
	MAP	JOBJC6,APR=6,DATA ;Re-map JCR entry			;049
	MOVB	JDSIZE-JDFLG(R1),R2 ;Get job size			;049
	CLR	-(SP)		;Get a stack cell			;020
	MOVB	JCHDRS(R0),(SP)	;Fetch the job header size		;049
	SUB	(SP)+,R2	;Subtract it out of the total size	;049
	CMPB	R2,R.MSIZ(R3)	; Image too small?			;049
	BLO	10$		; Error if so
	CMPB	R2,R.SIZE(R3) 	; Image too big?			;067
	BHI	10$		; Error if so
	BIT	#J2SLAP,JDFLG4-JDFLG(R1) ; Are we mapped to a SLA library? ;049
	BNE	10$		; Yes, so don't allow a .RTS		;045
	MOVB	JOB,R0		; Get job # * 2				;049
	CALLX	WINSUB,R5	; Call for all windows
	  BR	30$		; Check this window
25$:	INC	(SP)		; O.K., indicate context saved switch (+1)
	BR	50$		;  and go do it

30$:	BIT	#WS$UIS!WS$UDS,(R0) ;User mode window?			;049
	BEQ	32$		;No, so it's OK				;049
	MOV	W$NSIZ(R0),R4	;Yes, get window's length in 32-word blocks ;049
	ADD	#200-1,R4	; Round up by 4k (size of an APR)
	ASH	#-7,R4		;  and divide for 4k length
	ADD	(R0),R4		; Add in the base APR number (high byte junk!)
	ASLB	R4		; Make ending APR number
	ASLB	R4		;  into a K number (*4)
	CMPB	R4,R.SIZE(R3)	; Does window cross into run-time system?
	BHI	10$		; Error if so
32$:	RETURN			; Else back to co-routine		;049

GLOBAL	<UDPAR0>							;049

.SBTTL	Handle .EXIT monitor call

	EMTENT	.EXIT		; .EXIT comes here

	MOV	JOBWRK,R3	; R3 -> Work block for job		;039
	CLR	XRBUSE(R3)	; Indicate .EXIT type of switch		;039
	MAP	JOBJC6,APR=6,DATA ; Map job's JCR entry			;049
	MOV	JOBJCR,R0	; Pick up pointer to JCR entry		;049
	MOV	DEFKBM,JCDRTS(R0) ; And set the new default KBM		;049
35$:	CLR	-(SP)		;  and indicate a normal switch (+0)	;039
	MOV	DEFKBM,R3	; Get pointer to default KBM
50$:	MAP	@UDPAR0,APR=6,DATA ; Be sure user's first 4K is mapped	;049
	MOV	#XRB+4+140000,R4 ; Get pointer to user's XRB+4
	MOV	R.NAME+2(R5),(R4) ; Load name of previous RTS
	MOV	R.NAME(R5),-(R4) ;    into XRB @ +2/+4
	MOV	(SP)+,-(R4)	; Set normal switch (+0) or context saved (+1)
	BNE	70$		; It is context save, keep any libraries
	CMPB	#MC.LCK,JDMCTL+M.CTRL-JDFLG(R1) ; Any outstanding I/O?	;037
	BNE	110$		; Yes, stall until the I/O completes	;037
	MOV	JOBWDB,R0	; Set zero flag if no libraries to destroy
	BEQ	60$		; No libraries, don't bother to call
	CALLX	RETWDB		; Un-attach all libraries & return WDB buffers
	MOV	SP,R0		; Now (re-)set a non-zero flag
60$:	CMP	R3,R5		; Is a switch really occuring?
	BNE	70$		; Yes, do it				;033
	MOV	JOBWRK,R5	; Pick up pointer to work block		;039
	TST	XRBUSE(R5)	; Is this a .EXIT style switch?		;039
	BEQ	70$		; Yes, so do a real switch always	;039
	BIT	#J2PRVP,JDFLG3-JDFLG(R1) ; No, but running a priv'd program? ;049
	BEQ	90$		; Nope, check for needing a re-map
70$:	CALLX	SWRTSL		; Yep, switch to new RTS (keeping libraries)
	TST	(SP)+		;  and pop return address
80$:	BIS	#JFSPCL,(R1)	; Indicate special condition
	;BISB	#0,JDFLG2-JDFLG(R1) ;  as run-time system switch
	TST	@#140000+XRB	; Saved context RTS switch?		;039
	BNE	85$		; Yes, flag that			;033
	BR	DOMSIZ		;  and set up minimum size		;033

85$:	BISB	#JFCTXT,JDFLG2-JDFLG(R1) ; Say preserve the context
	JMPX	DMPJOB		;  and go dump the job

90$:	TST	R0		; Were any libraries destroyed?
	BNE	100$		; Yes, need a re-map, go do it and return
	RETURN			; No, just return

100$:	CALLMR	USRSET,GENAP5	; Libraries destroyed, go remap the job	;043

110$:	MOVB	JOB,R0		; Get caller's JOB number * 2		;037
	CLR	JBSTAT(R0)	; Outstanding I/O so stall EXIT/RTS	;037
	MOV	#JSTIM,JBWAIT(R0) ;  until the I/O completes (SLEEP)	;037
	MOV	JOBWRK,R0	; Now get JOB's WRK Block ->		;037
	MOV	#EXIRDO,XRBSAV(R0) ;  and set the redo index		;037
	JMPX	IOREDO		; Wait for I/O to complete		;037

GLOBAL	<DEFKBM,UDPAR0>							;049

.DSABL	LSB

.SBTTL	Handle .ASTX monitor call					;032

;+
;  .ASTX - Exit AST (Asynch I/O completion routine)			;032+
;
;	R1 -> JDB @ JDFLG
;	R2 -> JDB2
;	R3 -> User's [mapped] XRB
;	R4 -> User's [mapped] FIRQB
;	SP -> "RTI3", R0, R1, R2, R3, R4, R5, PC, PS, ...
;
;-

	EMTENT	.ASTX		;ASTX COMES HERE

	BIT	#100000,<SYSTAK-2> ;Did call come from Supervisor mode	;056
	BEQ	125$		;Yes- Async not yet allowed		;056
	BIT	#J2ASTA,JDFLG3-JDFLG(R1) ;AST routine active?		;049
	BEQ	120$		;No, error
	BIC	#J2ASTA,JDFLG3-JDFLG(R1) ;Yes, but not any more		;049
	MAP	JOBJC6,APR=6,DATA ;Map caller's JCR entry		;049
	MOV	JOBJCR,R5	;And point to it			;049
	ADD	#JCASTQ,R5	;Now point to queue location		;049
	MOV	(R5),R1		;Get pointer to current AST block	;049
	BEQ	130$		;None? Something is messed up!		;034
	CALL	SWPASY		;Restore user's saved XRB/FIRQB 	;034
	MAP	JOBJC6,APR=6,DATA ;Map JCR entry again			;049
	MOV	(R1),(R5)	;Dequeue this AST block			;049
	BNE	105$		;More to do, signal it to posting	;049
	MOV	R5,JCASTT-JCASTQ(R5) ;No more, fix tail pointer		;049
	BR	110$		;And return AST block			;049

105$:	BIS	#JFASTD,@JOBF	;ANOTHER AST IS READY FOR DELIVERY	;034
110$:	MOV	R1,R4		;PUT <ASYWRK/ASTBLK> -> HERE
	BUFFER	RETSML		;RETURN <ASYWRK/ASTBLK> TO SMALL BUFFER POOL

				;allow entry from either mode (future)	;056
	MFPD	SP		;GET USER'S CURRENT SP			;034
	MOV	(SP)+,R0	; AND PUT IT HERE			;034
	MFPD	(R0)+		;POP THE SAVED USER PS			;034
	BIC	#340,(SP)	;FORCE PR ZERO			SPLC	;056
	BIS	#4000,(SP) 	;FORCE G REG SET, leave modes	SPLC	;056
	BIT	#140000,(SP)	;make sure not going to Kernel mode	;056
	BEQ	127$		;trying to sneak in- blow him away	;056
	MOV	(SP)+,TOS.PS+2(SP) ;GIVE BACK THIS NEW STATUS		;034
	MFPD	(R0)+		;POP THE SAVED USER PC			;034
	MOV	(SP)+,TOS.PC+2(SP) ; AND WE WILL RETURN THERE		;034
	MOV	R0,-(SP)	;STACK NEW SP VALUE			;034
	MTPD	SP		; AND RETURN IT TO THE USER		;034
	BIC	#JFIOKY,@JOBF	;DON'T SIGNAL POSTING			;034
	RETURN			;HEAD FOR RTI3				;034

120$:	ERROR	NOSUCH		;NO .ASTX'S WITHOUT AN AST ACTIVE	;034

125$:	ERROR	PRVIOL		;No AST's from supervisor mode		;056

127$:	ERROR	BADFUO		;going to kernel mode disallowed	;056

130$:	CRASH			;NULL ASTBLK -> ... NOTHING IN QUEUE?	;034

.SBTTL	Handle .AST monitor call					;034

;+
;  .AST - Disable/Enable AST processing					;034+
;
;	R1 -> JDB @ JDFLG
;	R2 -> JDB2
;	R3 -> User's [mapped] XRB
;	SP -> "RTI3", R0, R1, R2, R3, R4, R5, PC, PS, ...
;
;	Parameter in XRB+0 (byte):	0  = Enable
;					-1 = Disable
;-

	EMTENT	.AST		;AST COMES HERE

	CMPB	#-1,(R3)	;DISABLE AST'S?				;045
	BNE	150$		;NO, MAYBE ENABLE THEM
	BIT	#J2ASTD,JDFLG3-JDFLG(R1) ;ARE AST'S ALREADY DISABLED?	;049
	BNE	170$		;YES, ERROR
	BIS	#J2ASTD,JDFLG3-JDFLG(R1) ;NO, SO DISABLE THEM		;049
	RETURN			;ALL DONE

150$:	TSTB	(R3)		;ENABLE AST'S?				;045
	BNE	170$		;NEITHER ENABLE OR DISABLE; PARAM ERROR!
	BIT	#J2ASTD,JDFLG3-JDFLG(R1) ;ARE AST'S ALREADY ENABLED?	;049
	BEQ	170$		;YES, DON'T RE-ENABLE!
	BIC	#J2ASTD,JDFLG3-JDFLG(R1) ;ENABLE AST'S			;049
	MAP	JOBJC6,APR=6,DATA ;Map caller's JCR entry		;049
	MOV	JOBJCR,R2	;And point to it			;049
	TST	JCASTQ(R2)	;ANY AST'S TO POST?			;049
	BEQ	160$		;NO, RELAX
	BIS	#JFASTD,(R1)	;YES, TAKE CARE OF THEM NOW		;049
160$:	RETURN			;ALL DONE

170$:	ERROR	BADFUO		;"ILLEGAL SYS() USAGE"

.SBTTL	Do Minimum job image sizing for a RTS

;+
; DOMSIZ - Do job image sizing.
;
;	R1 -> Job data block @ JDFLG
;	R3 -> RTS block
;
;	JMP	DOMSIZ
;
;	Return is to "RTI3"
;-

.ENABL	LSB								;018

	TMPORG	EMTDSP,6
	MAP	EMTAP5,APR=5,CODE,DATA,PIC ; Load APR
 	JMP	@#DOMSIZ	; Go to it
.ASSUME	.-EMTDSP EQ 30		; Check EMT merge area length...
	UNORG

DOMSIZ:	MOVB	R.MSIZ(R3),R3	;R3 = Minimum size of RTS		;035
	MAP	JOBJC6,APR=6,DATA ;Map caller's JCR entry		;049
	MOV	JOBJCR,R0	;R0 -> JCR entry for job		;049
	MOVB	JCISIZ(R0),R2	;Pick up size of I-space		;049
	SUB	R2,R3		;R3 = I-space change amount		;045
	MOV	#RTI3,-(SP)	; Exit will be to "RTI3"
	MOVB	JCDSIZ(R0),R2	;DOES THIS JOB HAVE ANY D SPACE??	;049
	BEQ	1$		; NO, SO LIFE IS EASY			;054
	CALL	DCOPY		; Yes, copy low core D-space to I-space	;049
	CLR	-(SP)		;GET A CELL FOR ...			;022
	MOVB	JDSIZE-JDFLG(R1),(SP) ; THE JOBS CURRENT SIZE		;022
	SUB	R2,(SP)		; AND SUBTRACT OUT THE OLD D AREA	;022
	MOVB	(SP)+,JDSIZE-JDFLG(R1) ; REPLACING THE JOBS SIZE	;022
	CLRB	JCDSIZ(R0)	;DON'T FORGET, IT'S GONE		;049
1$:	JMP	80$		;Now join the .CORE code		;055

GLOBAL	<EMTAP5>							;052

.SBTTL	Handle .CORE monitor call

	MWN.FP=40000	;local flag used in APRMSK			;054

	EMTENT	.CORE		; .CORE comes here

	CMPB	JDMCTL+M.CTRL-JDFLG(R1),#MC.LCK ;Any asynch locks?	;035
	BEQ	10$		;No, not this time			;035
	ERROR	INUSE		;Yes, so forget this request		;035

10$:	MOV	2(R3),R2	;Copy the APR mask into this space	;054
	TST	(R3)		;IS THE TURN ON D FLAG SET??		;022
	SXT	-(SP)		;SAVE WHAT EVER THE RESULT WAS		;022
	MOVB	(R3),R3		; Get the requested size
	MAP	JOBJC6,APR=6,DATA ;Map caller's JCR entry		;049
	MOV	JOBJCR,R0	;And point to it			;049
	TST	R3		;Might this be D-space turn off?	;049
	BNE	20$		;Non-zero, must not be D-space turn-off	;035
	TST	(SP)+		;Is this a D-space turn-off?		;035
	BEQ	15$		;No, so forget this			;053
	MOVB	JCDSIZ(R0),R3	;Pick up current d-space size		;049
	BEQ	15$		;None, so turn-off is an error		;053
	CALL	DCOPY		;Copy low-core D-space to I-space	;049
	NEG	R3		;Indicate getting smaller		;035
	CLRB	JCDSIZ(R0)	;And zero the cell			;049
	JMP	110$		;All done for now			;057

15$:	ERROR	BADFUO		;Illegal D-space turn-off attempt	;053

20$:	CMPB	R3,R.MSIZ(R5)	; Is size < RTS min?			;035
	BLO	140$		; Yes, so error				;035
	CMPB	R3,#32.		; Is size > 32K words			;035
	BHI	140$		; Yes, we can never do that		;035
	BIC	#MWN.FP,APRMSK	;set flag to EXTK$			;054
	MOV	#WS$UDS,R4	; Guess at user mode data space windows	;049
	TST	(SP)		; Turning on data space?		;049
	BNE	25$		; Yes, good guess			;049
	TSTB	JCDSIZ(R0)	; No, but is it on?			;049
	BNE	25$		; Yes, we've guessed correctly		;049
	ASR	R4		; Must be instruction space by now	;049
	.ASSUME	WS$UDS NE 100000 ; ASR would cause sign extend
	.ASSUME WS$UIS EQ <WS$UDS/2>
	BR	28$		; Skip flag test if I space		;054

25$:	TSTB	R2		;was this a EXTM$? (min APR0 on)	;055
	BEQ	28$		;no - old EXTK$ then			;055
	BIS	#MWN.FP,APRMSK	;yes, set flag as such			;054
	MOV	JOBJCR,R0	;Point to JCR region again		;055
	MOVB	JCDSIZ(R0),-(SP) ;get current D space size in KW	;068
	BNE	27$		;if it was zero get I size		;055
	MOVB	JCISIZ(R0),(SP)	;this feature not available in RSX-11	;068
27$:	MOVB	(SP)+,R0	;Get the size where we need it		;068
	DEC	R0		;address-1 compensation			;055
	ASH	#<-2>,R0	;R0 highest APR# used by task now	;055
	MOV	R2,-(SP)	;Save  apr mask value			;055
	MOV	#1,R2		;set bit to control clearing mask bits	;055
270$:	BIC	R2,(SP)		;clear bit (APR0 for sure)		;055
	ASL	R2		;represent next APR in bit pattern	;055
	DEC	R0		;count down # of APRs to clear		;055
	BGE	270$		;until all done(stop on -1)		;055
	MOV	(SP)+,R2	;reload LIB only mask			;055
	MOV	R3,R0		;get requested size to math scratch	;054
	DEC	R0		; Address-1 compensation		;054
	ASH	#<-2>,R0	; Shift so R0 is highest APR# used <0:7> ;054
	ADD	#-7,R0		; R0 now minus # of free APRs		;054
	NEG	R0		; R0 now plus # of free aprs		;054
	ASH	R0,R2		; Shift mask(R2) left #of free APRs	;054
	BIT	#377,R2		; If any remaining mask bits set,violate ;054
	BNE	140$		; Yes, APR in mask violates req size	;054
	;This algorythm presumes APRD0 can not be used by libraries	;054
	;  and therefore should not be protected by mask, if it is the	;054
	;  expand will fail.						;054
28$:	MOVB	JOB,R0		; Get job # * 2				;049
	CALLX	WINSUB,R5	; Returns with all created windows
	  BR	130$		; Check for any overlap

	CLRB	APRMSK+1	;don't leave our trash around		;069
	MOV	JOBJCR,R0	;Get JCR pointer			;049
	MOVB	JCISIZ(R0),R2	;Pick up I-space size			;049
	MOVB	JCDSIZ(R0),R4	;And pick up D-space size		;049
	TST	(SP)		;Is this a D-space turn-on?		;022
	BEQ	30$		; NO, THEY DON'T WANT I/D TURN ON	;022
	BIT	#XC$IDS,X.CON	;IS THERE I/D AVAILABLE??		;022
	BEQ	150$		; NO, BUT THEY WANT IT - SO ERROR	;022
	TSTB	R4		;D-space already on?			;045
	BEQ	60$		;No, not this time			;035
	CLR	(SP)		;Yes, so ignore d-space turn-on flag	;035

30$:	TSTB	R4		;Caller have D-space?			;045
	BEQ	40$		;No, not this time			;035
	SUB	R4,R3		;Yes, R3 has D-space change amount	;045
	BR	50$		;And join up				;035

40$:	SUB	R2,R3		;R3 has I-space change amount		;045

50$:	BLOS	70$		;Getting smaller or same, that's OK	;035

60$:	ADD	R2,R4		;R4 = Old I-space size + Old D-space size ;045
	ADD	R3,R4		;Add in change amount (now have new size) ;045
	CMPB	R4,R.SIZE(R5)	;Is size > RTS max?			;035
	BHI	140$		;Yes, so error				;035

	MOVB	JDSIZE-JDFLG(R1),R4 ;Pick up present size		;035
	ADD	R3,R4		;R4 = New size				;035
	CMPB	R4,SWPMAX	;Do we have enough memory?		;035
	BHI	140$		;No, so forget it			;035
	CMPB	R4,JCSIZM(R0)	;Within caller's quota?			;049
	BLOS	70$		;Yes, so that's OK			;035
	MOVB	JOB,R0		; Get caller's job number		;019
	CALLX	CHKPRV,R4	; Check privileges			;019
	 .BPRIV	EXQTA		; Allowed to exceed private memory max?	;021
	BCS	140$		; No, so forget it			;035
	MOV	JOBJCR,R0	;Get the JCR pointer again		;049

70$:	TST	(SP)+		; ARE WE TURNING I/D ON??		;035
	BNE	90$		;  YES, SO GO DO IT NOW			;022
	MOVB	JCDSIZ(R0),R2	;Do we have D-space?			;049
	BNE	100$		;Yes, so that's what we change		;035
80$:	MOVB	JCISIZ(R0),R2	;Pick up I-space size			;049
	ADD	R3,R2		;Adjust the I-space size		;045
	MOVB	R2,JCISIZ(R0)	;Store it back				;049
	BR	110$		;And join up				;035

; The following 2 error messages placed here so all can reach them	;054
140$:	CLRB	APRMSK+1	;don't leave our trash around		;069
	ERROR	EDBMCE		; Illegal size request

150$:	ERROR	ERRERR		; MISSING D SPACE HARDWARE		;022

90$:	BIS	#JFSPCL,(R1)	;Set special condition			;053
	BISB	#JFDINI,JDFLG2-JDFLG(R1) ;As D-space initialization	;053
	CLR	R2		;And set the initial size as 0K		;045
100$:	ADD	R3,R2		;Adjust our d-space size		;045
	MOVB	R2,JCDSIZ(R0)	;And store it back			;049
	; common I expand or D expand begins here
110$:	MOVB	JDSIZE-JDFLG(R1),R2 ;R2 = Current size			;035
	ADD	R3,R2		;Now adjust the size			;035
	MOVB	R2,JCSIZN(R0)	; Set the new/desired size		;049
	MOVB	JOB,R0		; Get caller's job # * 2		;053
	CALLMI	SETMDE,GENAP5	; And re-calculate MDEs for new size	;053
	TST	R3		;Are we getting larger?			;035
	BLE	120$		;Shrinking or same, just update size	;035
	CMP	R2,JDMCTL+M.TSIZ-JDFLG(R1) ;Is hole big enough?		;035
	BHI	OUTJOB		;No, so swap out this job		;035
	CALLMI	ZERMEM,GENAP5	;Yes, so zero the newly added memory
	MAP	JOBJC6,APR=6,DATA ;Restore JCR mapping			;049
120$:	MOV	JOBJCR,R0	; Get caller's JCR entry pointer	;053
	MOVB	JCSIZN(R0),JDSIZE-JDFLG(R1) ; Set current size as requested size ;049
	TST	(R1)		; Some special condition?
	BMI	125$		; Yes, let scheduler do it		;049
.ASSUME	JFSPCL	EQ	100000
	CALLMR	USRSET,GENAP5	; No, just re-map and exit		;043

125$:	JMPX	DMPJOB		; Done with this job, dump it		;049

130$:	BIT	R4,(R0)		; Are we worried about this kind of window? ;049
	BEQ	135$		; No, forget it				;049
	MOVB	(R0),R2		; Get APR number of created window
	ASL	R2		; Convert APR number
	ASL	R2		;  to K number (*4)
	CMP	R3,R2		; Is desired K size > window base K addr?
	BHI	160$		; Yes, error,maybe unless can override	;054
135$:	RETURN			; Back to co-routine			;049

160$:	BIT	#WS$UDS,R4	; Are we looking for D-space		;054
	BEQ	140$		;no, violation for all I space request	;054
	; it is now known that WS$UDS in (R0) WDB is set		;054
	BIT	#WS$UIS,(R0)	;Is it D only (dynamic region)		;054
	BEQ	140$		;yes, he blew it! send  him packing	;054
	BIT	#MWN.FP,APRMSK	;was this an EXTM$?			;054
	BEQ	140$		;no, treat EXTK$ as a .CORE		;054
				;yes, allow, we can take D-apr's here	;054
	; No check of EXTM$ mask required here because request size	;054
	;	tested against it at entry.				;054
	;
	; At this point the RSX programmer is telling us to disassociate ;054
	;   the D space from this particular mapped user library	;054
	;   It's his program, but he better know what's going on	;054
	RETURN			;back to WINSUB to look at next window	;054

	;Note:	On machines w/o I&D hardware job space can not expand	;054
	;	into library space (a RSTS rule, may vary on RSX).	;054



.DSABL	LSB								;035

GLOBAL	<X.CON,SWPMAX,APRMSK>						;054

;+									;018
; OUTJOB -- remove a job from memory and bring it back in		;018
;									;018
; Entry:								;018
;	Job to remove is "JOB"						;018
;	R1 ->	JDB @ JDFLG						;018
;	JCSIZN	Size for job when brought back in			;018
;									;018
; Exit:									;018
;	Does not return -- exits via DMPJOB				;018
;-									;018

OUTJOB::MOVB	#SWP!OUT!MC.LCK,JDMCTL+M.CTRL-JDFLG(R1) ; Set swap out	;030
				; No asynch I/O in progress here	;030
	INC	SWOCNT		; Indicate another swap out pending
	CALLX	SAVJOB,R5	; Dump this job and
	JMPX	CHKSWP		; Get that swap out going

GLOBAL	<RTI3,SWOCNT>							;019

	TMPORG	EMTDSP,40						;039
	 .WORD	DCOPY							;049
	UNORG								;039

;+
; DCOPY - Copy D-space lowcore to I-space
;
;	R1 -> JDB @ JDFLG
;
;	Calling job is "JOB"
;
;	CALL	DCOPY
;
;	All registers and mapping are preserved.
;
; The first 1000(8) bytes of lowcore are copied from D-space to I-space.
;-

DCOPY:	REGSCR			;Save the world				;039
	MAP	PUSH,APR=6,DATA	;And the way it is mapped		;049
	MAP	JOBJC6,APR=6,DATA ;Map caller's JCR entry		;049
	MOV	JOBJCR,R0	;And point to it			;049
	TSTB	JCDSIZ(R0)	;Using data space right now?		;049
	BEQ	40$		;No, get out the fast way		;049	
	MOVB	JCHDRS(R0),R4	;GET THE HEADER SIZE			;049
	MOV	R4,R3		;AND SAVE FOR A FEW LINES DOWN		;022
	MOVB	JCISIZ(R0),R5	;Pick up I-space size			;049
	ADD	R5,R4		; NOW, TOTAL OF EVERYTHING BELOW D AREA	;045
	ASH	#11.-6,R4	;AND CONVERT IT INTO MMU FORMAT		;022
	MOV	JDMCTL+M.PHYA-JDFLG(R1),R5 ;GET THE JOBS BASE MMU ADDR	;022
	ADD	R5,R4		;THEN THE BASE MMU OF THE D AREA	;022
	ASH	#11.-6,R3	; GET THE MMU OFFSET TO THE I AREA	;022
	ADD	R5,R3		;THEN THE BASE MMU OF THE I AREA	;022
	MAP	R3,APR=6,DATA	;AND MAP IT AS THE DESTINATION		;022
	MOV	#140000,R3	;APR6 SOURCE ADDRESS			;022
	MOV	#NSTORG,R2	;LENGTH OF DATA TO COPY FROM D TO I	;022
	MOV	#120000,R1	;APR5 DESTINATION ADDRESS		;022
	MOV	R4,R0		;MAPPING VALUE				;022
	CALLX	MOVMEM		;Move that data now			;049
40$:	MAP	POP,APR=6,DATA	;Restore mapping			;049
	RETURN			;And we're done				;049

.DSABL	LSB

.SBTTL	Handle .SLEEP monitor call

.ENABL	LSB

	EMTENT	.SLEEP		; .SLEEP comes here

	MOV	(R3),R3		; Pick up argument			;049
	BIT	#^C<100000>,R3	; Sleep time of zero seconds?		;062
	BEQ	DUMPIT		; Zero, go dump this job		;049
	MOVB	JOB,R4		; Get job number times 2
	CLR	JBSTAT(R4)	; Put the job into
	MOV	#JSTIM!JS.KB,JBWAIT(R4) ;  a SLEEP type wait
	MAP	JOBJC6,APR=6,DATA ;Map caller's JCR entry		;049
	MOV	JOBJCR,R4	; And point to it			;049	
	MOV	R3,JCCLOK(R4)	; Load timer from the calling argument	;049
	BGT	DUMPIT		; Time>0, do a real sleep
	BIC	#100000,JCCLOK(R4) ; Time<0, clear off the flag bit	;049
	TST	JCASTQ(R4)	; Any pending asynchronous I/O?		;049
	BNE	60$		; Yes, don't do the conditional sleep	;041
	MOV	R4,R5		; Copy JCR pointer
	ADD	#JCMPTR,R5	; Point to RIB pointer			;049
10$:	MOV	(R5),R5		; Get next RIB
	BEQ	20$		; No more RIBs so let user sleep
	CMPB	JOB,S.JBNO(R5)	; This RIB owned by this job?
	BNE	20$		; Nope done with  this job's RIBs
	BITB	#SA.NCS,S.ACCS(R5) ; Ignore this RIB?
	BNE	10$		; Yes see if more
	TSTB	S.MCNT(R5)	; Any messages for this job?
	BNE	60$		; Yes, go run job (don't sleep)
	BR	10$		; Go check next RIB

20$:	MOV	-(R1),R4	; Get job's I/O block pointer
.ASSUME	JDIOB	EQ	JDFLG-2
30$:	MAP	FIPPOL		; Map the FIP pool for IOBs and WCBs	;049
	MOV	(R4)+,R1	; Get (possible) WCB/DDB pointer
	BEQ	40$		; Channel is closed, skip it
	MOVB	(R1),R2		;  get the driver index,
	MAP	@UDPAR0,APR=6,DATA ;  and re-map the user			;022
	MAP	@#KISAR5,APR=5,DATA ; and our data			;043
	MOV	$SLPTBL(R2),R0	; Now get the sleep checking dispatch
	BNE	50$		; Dispatch exists, go check with driver
40$:	BIT	R4,#40-1	; More channels to do?
	BNE	30$		; Yes, loop...
DUMPIT:	JMPX	DMPJOB		; Else go dump the job

50$:	MOV	R4,-(SP)	; Save the I/O block pointer
	CALLX	OPNCLS		; Call driver for sleep checking
	MOV	(SP)+,R4	; Restore I/O block pointer
	BCC	40$		; Driver said sleep allowed, continue checking
60$:	MAP	JOBJC6,APR=6,DATA ; Re-map JCR entry for job		;049
	MOV	JOBJCR,R4	; And point to it			;049
	CLR	JCCLOK(R4)	; Clear out the clock now		;049
	MOVB	JOB,R4		; Get back job number times 2
	MOV	JBWAIT(R4),JBSTAT(R4) ; Make the job runnable
	RETURN			; And we're done			;041

.DSABL	LSB

GLOBAL	<JBSTAT,JBWAIT,$SLPTBL,UDPAR0,DMPJOB>				;049

.SBTTL	Subroutines for generic flags, logical names

;+
; GETFLG - Get generic flags.
;
;	R4 -> FIRQB @ FQDEV
;
;	CALL	GETFLG
;
;	R0 =  Device's generic flags
;	R1 =  Random
;	R2 =  Device's driver index
;	R4 -> FIRQB
;
;	If C=0 then valid device
;	If C=1 then invalid device
;-

GETFLG::SUB	#FQDEV,R4	; Point to top of FIRQB
	CALLX	GUNSUB,R5	; Now check out the name
	SEC			; Invalid, set C=1
	;CLC			; Valid, C=0 already
	BCS	20$		; Exit now if error
	MOV	@DEVPTR(R0),R1	; Get DDB pointer for unit 0
	CLR	R2		; Now guess at disks (index = 0)
	CMP	R0,#DEVOKB	; Really disk?
	BLT	10$		; Yes
	MOVB	(R1),R2		; No, get real driver index
10$:	MOV	$FLGTBL(R2),R0	; Now get the generic flags
	CLC			; Indicate all O.K.
20$:	RETURN			;  and exit

GLOBAL	<DEVPTR,DEVOKB,$FLGTBL>

;+
; GETLOG - Get system logical name.
;
;	R0 = Logical status
;	R4 -> FIRQB @ FQDEV
;	SP -> Logical-name-part-1, Logical-name-part-2,			 ;036
;		 Logical-name-part-3,..., Logical-name-part-7		;057
;
;	CALL	GETLOG,R5	or	CALL GETLGF,R5  (from FIP)	;057
;
;	All registers saved						;036
;
;	First return means no logical name found
;
;	Second return means logical name found
;
;		If C=0 then no PPN with logical name
;		If C=1 then there was a PPN
;-
.ENABL	LSB
GETLGF::MAP	PUSH,APR=6,DATA	;SAVE APR6 MAPPING			;057
	REGSAV			;SAVE REGISTERS				;057
	MOVB	FIJOB,R3	;get the FIP job number for header map	;057
	BR	5$		;re-join are regular schelude		;057

GETLOG::MAP	PUSH,APR=6,DATA	;SAVE APR6 MAPPING			;036
	REGSAV			;SAVE REGISTERS				;036
	MOVB	JOB,R3		;get our (running) job number		;057
5$:	MOV	SP,R5		;GET POINTER TO LOGICAL NAME		;036
	ADD	#TOS.PC+2+2,R5	;  PASSED (+2 BECAUSE OF MAP PUSH)	;036
	CALL	SEARCH		;LOOK FOR IT				;036
	BCS	20$		;NOT FOUND, 1st EXIT			;036
	ADD	#2,TOS.R5(SP)	;SET FOR 2nd EXIT			;036
	BIT	R0,#LG$DSK	;DISK?					;057
	BNE	10$		;YES (C=0 on exit then)			;057
	MOV	SL$PPN(R3),-(SP) ;PUSH PPN (IF ANY),			;036
	MOV	SL$NUM(R3),-(SP) ;  UNIT NUMBER AND FLAG,		;036
	MOV	SL$DEV(R3),-(SP) ;  AND PHYSICAL DEVICE NAME ONTO THE STACK ;036
	MAP	@UDPAR0,APR=6,DATA ;RE-MAP FIRQB			;036
	MOV	(SP)+,(R4)	;RETRIEVE PHYSICAL DEVICE NAME		;036
	MOV	(SP)+,FQDEVN-FQDEV(R4) ;RETRIEVE UNIT NUMBER AND FLAG	;036
	MOV	(SP)+,R0	;TRY TO RETRIEVE PPN			;036
	BEQ	15$		;NOT PRESENT EXIT (WITH CLC)		;057
	MOV	R0,FQPPN-FQDEV(R4) ;IS PRESENT, SET IT			;036
	SEC			;set the carry				;057
	BR	20$		;   AND EXIT (C=1)			;036

10$:	MOV	DL$DEV(R2),(R4)	;RETRIEVE PHYSICAL DEVICE NAME		;036
	MOV	DL$NUM(R2),FQDEVN-FQDEV(R4) ;RETRIEVE UNIT NUMBER AND FLAG ;036
15$:	CLC			;NO PPN (IN CASE NON-DISK WITH NO PPN)	;036
20$:	REGRES			;RESTORE REGISTERS			;036
	MAP	POP,APR=6,DATA	;RESTORE MAPPING			;036
	RETURN	R5		;SAY "GOOD NIGHT," GRACIE		;036

.DSABL	LSB

;+									;036
; SEARCH - Search for a given logical.	 				;036
;	If R0 & LG$DSK=1 then SKIP disk logical search
;									;036
;	R0 = Status of logical search					;057
;	R3 = job#*2 for header mapping (required only for user logical)	;057
;	R5 -> Logical to search for (in RAD50).				;036
;									;036
;	CALL SEARCH 							;036
;									;036
; If C=0 (clr) then logical was found:					;057
;									;036
;	If R0 & LG$DSK = 1 then it was a disk logical & R2->DSKLOG	;057
;	  else								;057
;	R0 = status word of logical					;057
;	R1 = Logical sub buffer size					;057
;	R2 = previous buffer address (contorted)			;057
;	R3 -> Logical sub buffer (mapped via APR 6)			;057
;		See FLDEF.MAC for buffer layout				;057
;	APR6 unchanged if R0&LG$DSK=1, else it maps logical buffer	;057
;		R4 & R5 as in input					;057
;									;036
;    If Z=1 then no PPN found						;057
;	Z=0 then  a PPN was found with logical				;057
;									;036
; If C=1 then logical was not found:					;036
;									;036
;	Z,R0-R3 random							;036
;	APR6 random							;036
;-									;036

	TMPORG	EMTDSP,34						;036
	.WORD	SEARCH							;036
	.WORD	SRCHLG							;036
	UNORG								;036

.ENABL	LSB								;036

SRCHLG:	BIS	#LG$DSK,R0	;set to skip disk name search		;057	
SEARCH:	CALL	LOGLEN		;size up the logical were searching for	;057
	MOV	R4,-(SP)	;SAVE FIRQB POINTER			;057
	MOV	R0,-(SP)	;save disk list search flag		;063
	MAP	PUSH,APR=6,DATA	;save the current mapping for disk list	;063
	BIC	#LG$DSK,R0	;presume not disk			;063
	BIT	#LG$USR,R0	;look over both lists?			;057
	BEQ	25$		;no do just sys				;057
	CALLX	MAPHDR		;set header mapping and tags for user	;057
	MOV	@#JHULOG,R3	;get pointer in header to first user log ;057
	BEQ	24$		;no list to search- skip		;057
	BIC	#LG$DOS,R0	;inform SRHLOG it is			;057
	CALL	SRHLOG		;do we find it locally?			;057
	BCC	27$		;yes - that's nice			;057
24$:	CALL	SRHTBL		;see if it is in user table (obsolete)	;057
	BCC	27$		;found in prog supplied logical table	;057
25$:	BIT	#LG$SYS,R0	;do we want sys list search		;057
	BEQ	28$		;no- exit indicating not found		;057
	MOV	@#SYSLOG,R3	;get pointer to first system buffer	;057
	BEQ	26$		;no list to search			;057
	BIS	#LG$DOS,R0	;inform SRHLOG that it is sys list	;057
	CALL	SRHLOG		;and is global?				;057
	BCC	27$		;yes					;057
26$:	BIT	#LG$DSK,2(SP)	;search disk logical list? flag on stack;063
	BNE	28$		;no- if set exit indicating not found	;063
	MAP	POP,APR=6,DATA	;get original mapping back		;063
	CLR	-(SP)		;  and re-balance stack			;063
	BIS	#LG$DSK,R0	;presume disk logical found		;063
	MOV	#DSKLOG,R2	;GET POINTER TO DISK LOGICAL TABLE	;063
.ASSUME	DL$NAM	EQ	0	;NEXT THREE CMP INSTRUCTIONS RELY ON THIS ;063+
10$:	CMP	(R2),(R5)	;NAME MATCH?				;036
	BNE	20$		;NO					;036
	CMP	2(R2),2(R5)	;REALLY MATCH?				;036
	BNE	20$		;NO					;036
	CMP	4(R2),4(R5)	;REALLY REALLY MATCH?			;036
	BNE	20$		;no					;057
	TST	6(R5)		;yes but is it but a subset?		;057
	BEQ	27$		;no, found GO EXIT C=0 (TST CLEARS C)	;057
20$:	ADD	#DL$SIZ,R2	;INDEX TO NEXT TABLE ENTRY		;036
	CMP	#SYSLOG-1,R2	;END OF DISK TABLE?			;036
	BHIS	10$		;NOT YET, LOOP...			;063
	BIC	#LG$DSK,R0	;not in disk list either		;063
28$:	SEC			;no find it -set carry to indicate	;057
27$:	MOV	(SP)+,R4	;dump original mapping (or 0 if disk)	;063
	MOV	(SP)+,R4	;dump disk search flag- preserve carry	;063
	MOV	(SP)+,R4	;regain ^FIRQB for those who had it	;057
35$:	RETURN			;leave carry set for not found		;057

		;at return:						;057
		;R0	=status
		;R1	= logical size (12. or 20. or 8.)		;057
		;R3	-> beginning of logical buffer			;057


	;SRHLOG	directly searches the logical chain given it		;057
	;	no intermingling sizes with a given buffer		;057
	;	R0 = status bits					;057
	;	R1 = logical size					;057
	;	R3 -> first buffer (maybe contorted)			;057
	;	R5 -> first rad50 word of logical name to search for	;057
	;	if doing user logical work header must be mapped	;057
	;
	; on output							;057
	;	R0,R1,R5 as at input					;057
	;	R3 -> logical sub block					;057
	;	R2 = contorted address of prev buffer			;057
	;

SRHLOG:	CLR	-(SP)		;make hole for prev buffer pointer	;057+
43$:	MOV	R3,R4		;copy the buffer address for MAPBUF
	BEQ	65$		;if nothing there we can't find then
	BIT	#LG$DOS,R0	;is it do.sys logical in status?
	BEQ	45$		;no - mapping is correct then
	CALLX	MAPBUF		;R3 was contorted, now correct & mapped
45$:	MOV	#SL$SZS,R1	;set size to old style logical
	BIC	#LG$NEW,R0	;set status to old style
	MOVB	2(R3),R2	;get the old style allocation byte
	BIC	#^C<37>,R2	;clear to assure stopping
	Beq	48$		;if non-zero its the right type(old)	;057x
	BIT	#LG$NLG,R0	;is the target an old style?		;057x
	BNE	50$		;if non-zero its the right type(old)
	br	nextbf		;else miss match skip buffer		;057x

48$:	BIT	#LG$NLG,R0	;is the target an old style?
	BNE	NEXTBF		;yes-then this buffers no good this time
	MOVB	3(R3),R2	;no- get new style allocation byte
	BEQ	NEXTBF		;that's strange -nothing there? oh well
	BIS	#LG$NEW,R0	;indicate buffer type
	MOV	#SL$SIZ,R1	;set size to new style
	BIC	#^C<3>,R2	;clear any noise to assure stopping
50$:		;out	MOV	R3,R4		;save top of buffer pointer
	ADD	#4,R3		;put R3 on first sub block (logical)
55$:	ROR	R2		;put sub block allocation tag in carry
	BCC	60$		;if clear then this slot empty
	CMP	SL$NAM(R3),(R5)	;1st word match?
	BNE	60$		;no - then not this one
	CMP	SL$NAM+2(R3),2(R5)	;2nd word match?
	BNE	60$		;no - then not this one
	CMP	SL$NAM+4(R3),4(R5)	;3rd word match?
	BNE	60$		;no - then not this one
	BIT	#LG$NEW,R0	;this the end of the test?
	BEQ	70$		;yes if not new style
	CMP	SL$NAM+6(R3),6(R5)	;4th word match?
	BNE	60$		;no - then not this one
	CMP	SL$NAM+10(R3),10(R5)	;5th word match?
	BNE	60$		;no - then not this one
	CMP	SL$NAM+12(R3),12(R5)	;6th word match?
	BNE	60$		;no - then not this one
	CMP	SL$NAM+14(R3),14(R5)	;7th word match?
	BEQ	70$		;yes  then its found
60$:	TST	R2		;any more in buffer to look at?
	BEQ	NEXTBF		;no- get next buffer
	ADD	R1,R3		;add buffer size to pointer to next sub blk
	BR	55$		;go check it out

NEXTBF:	MOV	R4,(SP)		;note the prev contorted address
	BIC	#77,R3		;get buffer top back
	MOV	(R3),R3		;get link
	BNE	43$		;cycle to look at next buffer
65$:	SEC			;go to not found (no PPN to check)
	MOV	(SP)+,R2	;return prev buffer pointer
	BR	75$		;go return now

70$:	MOV	(SP)+,R2	;return prev buffer pointer
	TST	SL$PPN(R3)	;is there PPN? if so set Z=0
	BEQ	75$		;if 0 no- leave carry clear from TST
	;CLC			;C=0 for found from TST above
75$:	RETURN			;carry set if PPN from above		;057-

	.ENABL	LSB

LOGLEN:	MOV	R0,-(SP)	;save existing status bits		;057
	BIC	#<LG$L6!LG$L9>,(SP) ;but without any length settings	;057

	MOV	R5,-(SP)	;save the name pointer			;057+
	MOV	#7,R0		;MXLGSZ (maximum logical length in words ;057+
10$:	TST	(R5)+		;is this the 1st zero (terminator)	;057+
	BEQ	20$		;yes - figure out where it is		;057+
	SOB	R0,10$		;no keep looking			;057+
	BR	50$		;no terminator -definitely long	(R0=0)	;057+

20$:	MOV	R0,-(SP)	;save the counter left range (7:1)	;057+
	DEC	R0		;but was it the last anyway?		;057+
	BEQ	35$		;yes also a long but clean stack first	;057+
30$:	CLR	(R5)+		;clear remaining words			;057+
	SOB	R0,30$		;in the work space			;057+
35$:	CMP	#4,(SP)+	;is it 7,8 or 9 chars? R0=0 here	;065
	BEQ	40$		;yes- set L9 flag			;057+
	BPL	50$		;no but greater than 9 (new style)	;057+
	MOV	#LG$L6,R0	;if minus than 6 or less long		;057+
	BR	50$		;pick up threead			;057+

40$:	MOV	#LG$L9,R0	;set for 9 char length			;057+
50$:	MOV	(SP)+,R5	;retrieve the name pointer at start	;057+
	BIS	(SP)+,R0	;include the other condition flags	;057+
	RETURN								;057


;This routine searches a program supplied logical table for logical	;057
; note the system no longer stores in these tables however it will	;057
; delete an entry if deassigned or replaced				;057

;	R0 = Logical status word					;057
;	R5 -> Logical name (RAD50) to match				;057

SRHTBL:	BIT	#LG$L6,R0	;is the length 6 or less?		;064
	BEQ	80$		;if not can't be in this table-return	;064
	MAP	PUSH,APR=6,DATA	;save the current setting		;064
	MAP	@UDPAR0,APR=6,DATA ; Map us into user's 1st 4K		;057
	MOV	#140000+USRLOG-10,R3 ;starting address of logicals-10	;057
	MOV	#140000+USRLOG+37,R2 ;ending address of table		;057
		.rem	%	;the folowing code to use tables anywhere
				;won't work because SETXRB may not have run
	MOV	#140000+XRB+10,R4  ;set pointer to pre-config mapping	;057
	MOV	(R4)+,R2	;get end address at xrb+10		;057
	MOV	(R4)+,R3	;get start addr of table from XRB+12	;057
	MOV	(R4),R4		;get the tables mapping value @140000	;057
	MAP	R4,APR=6,DATA	;map the user's table @140000		;057
	SUB	#4,R3		;step over PPN&PROT code (only 2 words)	;057
			%

60$:	ADD	#4*2,R3		;step to the next logical (4 words)	;057
	CMP	R3,R2		;has current pointer passed end point?	;057
	BHIS	70$		;yes-then its not here is it		;057
	CMP	(R5),(R3)	;first 3 char match?			;057
	BNE	60$		;no- then try the next one		;057
	CMP	2(R5),2(R3)	;ok-what about the second 3 chars?	;057
	BNE	60$		;nope- maybe next one then		;057
	BIS	#LG$LOW,R0	;found it! make a note of the fact	;057
	;note the layout is wrong for actual use but thats ok because	;057
	;  we will ONLY be deassigning what was just found here		;057
	MOV	#10,R1		;be sure the boss knows how big it is	;064
	TST	(SP)+		;drop saved mapping 			;064
	;CLC			;from TST above, indicate found it	;057
	BR	90$		;exit saving carry clear, mapping user	;064

70$:	MAP	POP,APR=6,DATA	;restore mapping at entry		;064
80$:	SEC			;mark failure to find			;064
90$:	RETURN			;report back to the boss		;064


.DSABL	LSB								;036
GLOBAL	<FIJOB,DSKLOG,SYSLOG>						;057

.SBTTL	Handle .LOGS monitor call

	EMTENT	.LOGS		; .LOGS comes here

	ADD	#FQDEV,R4	; Index to FQDEV in the FIRQB
	MOV	R3,R0		;copy XRB pointer			;057
	ADD	#7*2,R0		;maximum logical size			;057
	TST	(R3)+		; but not the first word		;0xx
5$:	MOV	-(R0),-(SP)	;copy the logicals to the stack		;057
	CMP	R0,R3		;did it reach the start yet?		;057
	BHI	5$		;no - then yet again			;057
	TST	(R3)+		; bump the pointer to XRLOC		;0xx
	CLR	(R3)+		; Say logical name not used (0 @ XRB+4)
	MOV	-(R0),-(SP)	;now get the first word	of logical	;0xx
	BEQ	10$		; None
	MOV	#LG$SYS,R0	;set to search JUST system logicals	;057
	CMP	#-2,(R4)	;is user translate flag set @FQDEV?	;057
	BNE 7$  ;BNE	8$	;no continue as system translate	;057
	MOV	#LG$USR,R0	;yes its a user translate then		;057

		;following code wil come out when rt-11 fixed
	BR	8$							;0x1
7$:	TST	2(SP)		; Is it two words or more?		;0x1
	BNE	8$		; Yes, go just use it			;0x1
	CMP	4(SP),#-604	;strange kludge for now!		;0x1
	BNE	8$		; no, so stay compatible		;0x1
	MOV	#LG$USR,R0	; Yes, so kuldge to get user logicals	;0x1
	CLR	4(SP)		; trash the kludge flag.		;0x1
	BR	9$		;can't possibly be others then		;0x1
		;end of removal area

8$:	CMP	#-3,(R4)	;is a RAD50 to ASCii (LOGICAL style)	;061
	BNE	81$		;no					;061
	MOV	#RADASP,R0	;then set to go there			;061
	BR	30$		;do the new processing			;061

81$:	CMP	#-4,(R4)	;is RAD50 to ascii (straight style)?	;061
	BNE	9$		;no- continue as in the old days	;061
	MOV	#RADASC,R0	;then set to go there			;061
	BR	30$		;do the new processing			;061

9$:	CALL	GETLOG,R5	; Yes, check the logical name
	 BR	10$		; Not a logical name
	ADC	-(R3)		; Logical, make @XRB+4 =1 if PPN
	COM	(R3)+		; Now it is -1 or -2
10$:	ADD	#7*2,SP		; Pop the logical name			;057
	CALL	GETFLG		; Now get the generic flags
	BCS	20$		; Invalid, so error
	MOV	R0,(R3)+	; Valid, set flags @ XRB+6
	MOV	$BUFTBL(R2),(R3)+ ;Set default buffer size @ XRB+10
	RETURN			; And exit

20$:	ERROR	NODEVC		; Error, invalid device

30$:	ADD	#<FQFIL-FQDEV>,R4 ;output data (ascii) goes here	;061
	MOV	SP,R5		;pointer to RAD50			;061
	CALL	(R0)		;call the routine indicated		;061
	ADD	#7*2,SP		;pop the RAD50 data			;061
	RETURN								;061

GLOBAL	<$BUFTBL>

.SBTTL	RAD50 to ASCII translation subfunction to .LOGS monitor call

	;R4 -> output address for translation (if R4=0, no output)	;061+
	;R5 -> RAD50 list up to 7 long to translate/test
	;  test wil be terminated by a zero word
	; on return:
	;    c set if rule is broken, carry clear if not broken
	;    output transfered if R4<>0, unused words are zeroed
	;    R2 random, R4& R5 as at input

	.ENABL LSB

RADASC:: CLR	R2		;set to full rule table
	BR	10$		;to main thread

RADASP:: MOV	#<'_-'.>,R2	;pick up table that allows periods
10$:	MOV	R5,-(SP)	;save for output
	MOV	R4,-(SP)	; ditto- to give back reasonable regs
	MOV	R3,-(SP)	;working register
	MOV	R1,-(SP)	;working register
	MOV	R0,-(SP)	;working register
	MOV	#11.,R0		;max output space = 22(decimal) bytes
20$:	CLR	-(SP)		;initial workspace
	SOB	R0,20$		;one 2 bytes per loop
	MOV	#7,R3		;input word counter
	MOV	R4,R0		;save for a moment
	MOV	SP,R4		;pointer to work space
	CLR	-(SP)		;space for intermieate result
	MOV	R0,-(SP)	;save the target in a reasonable placement
	CLR	-(SP)		;fault flag set to ok initiially
	CLR	R0		;required homework
30$:	MOV	(R5)+,R1	;get the next word
	BEQ	60$		;if zero that is the end of the input
	CMP	R1,#<50*50*50>	;is the entire word bogus?		;061+
	BLOS	35$		;no -that good so far...
	MOV	#134745,R1	;yes so give him 3 '?'s "???" instead
	ADD	#400,(SP)	;increment the high fault byte as illegal
35$:	DIV	#3100,R0	;r0=r0/(50*50)= 1st char
	MOV	R1,4(SP)	;save the intermidate result
40$:	CALL	RADTST		;test and store it away
	MOV	4(SP),R1	;get the rad50 of next 2 char together
	BNE	43$		;are both 2nd&3rd char =0
	CALL	100$		;test for last char
	  BR	60$		;zero - so its the end
43$:	DIV	#50,R0		;r0=2nd char & r1= 3rd char
	MOV	R1,4(SP)	;save 3rd char
	CALL	RADTST		;test it and store it away
	MOV	4(SP),R0	;regain the intermediate result,R0=char 3
	BNE	50$		;is it a zero
45$:	CALL	100$		;yes - look ahead to the next, is it zero?
	  BR	60$		;yes so that is the end then
50$:	CALL	RADTST		;test it and store it away
55$:	SOB	R3,30$		;keep track of how many done so far
60$:	MOV	(SP)+,R3	;;get the fault flag
	MOV	(SP)+,R5	;get the output pointer
	BEQ	80$		;if zero - no output (just testing)
	MOV	#11.,R0		;max workspace size in words
	MOV	SP,R1		;point to top of work space-2
	TST	(R1)+		; now at real top
70$:	MOV	(R1)+,(R5)+	;copy the workspace to target
	SOB	R0,70$		;until done
	MOV	R3,(R5)+	;give the fault flag next
80$:	ADD	#<11.*2+2>,SP	;clear stack of workspace & a word
	;CLC			;from above, set to no faults
	TST	R3		;are there any character faults
	BEQ	90$		;0 is none
	SEC			;set carry if any
90$:	MOV	(SP)+,R0	;restore registers
	MOV	(SP)+,R1	; ...
	MOV	(SP)+,R3	; ...
	MOV	(SP)+,R4	; ...
	MOV	(SP)+,R5	; ...
	RETURN			;exit with carry as flag

100$:	;test for last char in RAD50 set
	CMP	#1,R3		;last word by count?
	BEQ	110$		;yes -end -take first exit
	TST	(R5)		;no so look at next word for 0 terminator
	BEQ	110$		;yes so first exit also
	ADD	#2,(SP)		;not end so 2nd exit
110$:	RETURN


RADTST:	MOV	R0,R1		;copy the char
	BNE	130$		;if zero just pass thru,storing a space
	MOV	#40,R0		;map 0 tospace and
	BR	170$		;fault and store

130$:	CMP	R0,#33		;not a space but is alpha(between RAD(a&z)?
	BNE	140$		;was it a "$"?
	ADD	#<'$-33>,R0	;yes map it and
	BR	170$		;  fault it,store it and exit

140$:	BHI	150$		;no- keep testing, not alpha
	ADD	#100,R0		;yes- make it ascii
	BR	180$		;done testing, save char and exit

150$:	CMP	R0,#35		;is it numeric (<rad50(0))?
	BNE	155$		;was it a "?"?
	ADD	#<'?-35>,R0	;yes, map it 
	BR	170$		;  fault it,store it and exit

155$:	BLO	160$		;not number if less (must be =34 then)
	ADD	#22,R0		;yes -turn it to ascii
	BR	180$		;done testing, save char and exit

160$:	ADD	R2,R0		;alternate mapping added in
	ADD	#<'.-34>,R0	;standard mapping
	CMP	R0,#<'_>	;is allowed (ie an underline)?
	BEQ	180$		;yes save it
170$:	INC	2(SP)		;count the fault
180$:	MOVB	R0,(R4)+	; and put it in workspace
190$:	CLR	R0		;prep for next char
	RETURN			;to get the next char			;061-


.SBTTL	Move user's FIRQB or XRB into the Work Block				      ;014+

;+
; MOVFQB - Move 16. words into the job's Work Block
;
;	R4 -> Source field (user's [mapped] FIRQB)
;
;	CALL	MOVFQB
;
;	R3 -> Work Block, loaded
;-

	.ENABL	LSB

MOVFQB::MOV	#16.*2,R3	; R3 = byte count to move
	CALL	10$		; Move 8. words,
	BR	20$		;   go move remaining 8. words, and exit

;+
; MOVXRB - Move 8. words into the job's Work Block
;
;	R3 -> Source field (user's [mapped] XRB)
;
;	CALL	MOVXRB
;
;	R4 -> Source field (user's [mapped] XRB)
;	R3 -> Work Block, loaded
;-

MOVXRB::MOV	R3,R4		; R4 -> beginning of source field
	MOV	#8.*2,R3	; R3 = byte count to move

10$:	ADD	R3,R4		; Now, R4 -> end of source field
	ADD	JOBWRK,R3	;   and R3 -> end of destination (in job WRK)

20$:	CALL	(PC)		; Move 4. words
30$:	MOV	-(R4),-(R3)	;   move
	MOV	-(R4),-(R3)	;     4.
	MOV	-(R4),-(R3)	;       (more)
	MOV	-(R4),-(R3)	;         words
	RETURN			; Back to 30$ or exit


.SBTTL	Move user XRB/FIRQB to ASYWRK block				;034

;+									;025
; MOVASY - Copy XRB and necessary FIRQB contents into the WORK block	;025
;									;025
;	R3 -> Source field (user's [mapped] XRB)			;025
;	R4 -> Source field (user's [mapped] FIRQB)			;031
;									;025
;	CALL	MOVASY							;025
;									;025
;	R3 -> Work Block, loaded					;025
;	R4 -> Source field (user's [mapped] FIRQB)			;030
;	R5 = ??								;025
;-									;025
									;025
MOVASY:	PUSH	R4		; Save mapped FIRQB pointer		;025
	CALL	MOVXRB		; Copy the normal XRB stuff		;025
	POP	R4		; Restore FIRQB pointer			;025
	MOV	FQFIL(R4),XRBCRA(R3); Stuff AST address into work block	;025
	BIT	#1,XRBCRA(R3)	; Did user give us a Bozo address?	;034
	BNE	40$		; Yes, error!				;034
	BIS	#1,XRBCRA(R3)	; WE'LL use the bit to flag asynch req	;034
	MOV	FQPPN(R4),XRBAP(R3); Stuff user's parameter into WORK	;025
	MOVB	FQNAM1(R4),XRBEFN(R3); Stuff Event Flag number in WORK	;025
	RETURN								;025

40$:	ERROR	BADCNT		; Odd address for completion routine	;034

.SBTTL	Switch/save user's XRB/FIRQB with the ASYWRK information	;034

;+
; SWPASY - Swap ASYWRK information with current user's XRB/FIRQB	;034+
;
;       R1 -> ASYWRK block
;
;	Error code in ASYWRK @ XRBUSE
;	XRLEN is saved in ASYWRK @ XRBUSE+2
;	The rest of the XRB is saved in standard work block XRB offsets
;	All registers are preserved.
;
;	CALL	SWPASY
;
;	User's first 4K is mapped on exit
;-

SWPASY:	PUSH	<R0,R2>		;SAVE THESE REGISTERS			;042
	MAP	@UDPAR0,APR=6,DATA ;Map the user's first 4K		;049
	MOV	#XRB+140000,R0	;R0 -> Caller's mapped XRB
	MOV	(R0),R2		;Save XRB @ XRLEN			;042
	MOV	XRBUSE+2(R1),(R0)+ ;Now post XRLEN to user's XRB	;042
	MOV	R2,XRBUSE+2(R1) ;And save user's XRLEN in ASY block	;042
	MOV	#<XRBSIZ/2>-1,R2 ;Set up to copy rest of XRB		;042
	TST	(R1)+		;And advance to second word in ASY block ;042
60$:	MOV	(R0),-(SP)	;PUSH NEXT USER XRB WORD
	MOV	(R1),(R0)+	;Then move word from ASY block to XRB
	MOV	(SP)+,(R1)+	;And save word from XRB in ASY block	;042
	SOB	R2,60$		;Now loop for the whole XRB
	TST	(R1)+		;Advance to XRBUSE in ASY block		;042
	MOV	#FIRQB+140000,R0 ;GET USER FIRQB -> IN R0
	MOVB	(R0),R2		;Save the current error code		;042
	MOVB	(R1),(R0)	; MOVE ERROR CODE (XRBUSE) TO FIRQB+0
	MOVB	R2,(R1)		;  Now save current XRB code in ASY block ;042
	CMP	(R0)+,(R0)+	;ADVANCE TO FIRQB+FQFIL
	SUB	#XRBUSE,R1	;And get back to beginning of ASY block
	MOV	(R0),R2		;Save user's FQFIL			;042
	MOV	XRBCRA(R1),(R0)+ ;And write the completion address there ;042
	MOV	R2,XRBCRA(R1)	;Now save FQFIL in ASY block		;042
	MOV	(R0),R2		;Save FQPPN				;042
	MOV	XRBAP(R1),(R0)+ ; SO ASY/ASYNCH PARAMETER CAN GO THERE
	MOV	R2,XRBAP(R1)	;  Now save FQPPN in ASY block		;042
	MOVB	(R0),R2		;Save low byte of FQPPN			;042
	MOVB	XRBEFN(R1),(R0) ; SO ASY/EVENT FLAG NUMBER CAN GO THERE
	MOVB	R2,XRBEFN(R1)	;  And save FQNAM1 in ASY block	;042
	POP	<R2,R0>		;RESTORE WORKING REG'S			;042
	RETURN								;034-

.SBTTL	Common I/O front end for monitor calls

;+
; CMNSIO - Common I/O monitor call front end.
;
;	Calling job is "JOB"
;
;	R3 -> XRB (some copy: either mapped or work block)
;
;	CALL	CMNSIO
;
;	R0 =  Unit number times 2 (from DDUNT)
;	R1 -> DDB/WCB
;	R4 =  Driver index (from DDIDX)
;	R5 =  Status flags (from DDSTS)
;
;	First 4K of job is mapped through APR 6
;
;	-or-
;
;	The error "BSERR"
;	The error "NOTOPN"
;-

.ENABL	LSB

CMNSIO:	MOVB	XRCI(R3),R1	; Get channel number times 2
	BIT	R1,#^C<15.*2>	; Valid channel times 2?
	BNE	60$		; No
	MAP	FIPPOL		; Map the FIP pool for IOBs and WCBs	;049
	ADD	@JOBDA,R1	; Find the I/O Block pointer
	MOV	(R1),R1		; Now get the DDB/WCB pointer
	BEQ	70$		; None, error
	MOVB	DDUNT(R1),R0	; Get the unit number
	ASL	R0		;  times two,
	MOVB	DDSTS(R1),R5	; Get the status bits,
	MOVB	(R1),R4		; And the driver index
.ASSUME	DDIDX	EQ	0
	CMP	R4,#IDX$MX	; Did we have a sane driver index?
	BHIS	10$		; No, something got clobbered!
	MAP	@UDPAR0,APR=6,DATA ; All OK, so remap the user		;022
	MAP	@#KISAR5,APR=5,DATA ;And map us I&D overmapped		;043
	RETURN			; Done

10$:	CRASH			; Invalid driver index in DDB/WCB

GLOBAL	<IDX$MX,UDPAR0>

.SBTTL	User I/O interface

;+
;	R0 =  EMT CODE
;	R1 -> JOBDA @JOBF
;	R2 -> JDB2
;	R3 -> MAPPED XRB
;	R4 -> MAPPED FIRQB
;	R5 -> RTS BLOCK
;-

.SBTTL	Handle .READA monitor call					;025
									;025
	EMTENT	.READA							;025
									;025
				; Fall into .WRITA

.SBTTL	Handle .WRITA monitor call					;025
									;025
	EMTENT	.WRITA							;025

	BIT	#100000,<SYSTAK-2> ; Did it come from Supervisor mode?	;056
	BEQ	80$		; Yes- Async not yet allowed		;056
	CALL	MOVASY		; Copy XRB/FIRQB to WORK block		;025
	BR	20$		; Join common code.			;025

	



.SBTTL	Handle .WRITE monitor call

	EMTENT	.WRITE		; .WRITE comes here

;	MOV	#^B<11100101>*400+0,@IOSTS ; Post XRBC, XRBLK & XRBLKM values
;				; (commented out - use same pattern as .READ)

.SBTTL	Handle .READ monitor call

	EMTENT	.READ		; .READ comes here

	BIS	#JFPOST,(R1)	; Indicate posting needed (not Asynch)	;030
	CALL	MOVXRB		; Move XRB into the work block
	BIC	#1,XRBCRA(R3)	; Make sure we're a Synch request	;034



.SBTTL	Common READ/READA/WRITE/WRITA service
;+									;025
;	R0	R1	R2	R3	R4	R5			;025
;	EMT 	JOBDA	JDB2	WORK	???	???			;025
;	Code	@JOBF		block					;025
;									;025
;	Common work for both synchronous and asynchronous		;025
;	I/O requests.							;025
;-									;025

20$:	BIC	#100,R0		; Treat asynchronous I/O as synchronous	;025
	MOV	R0,XRBSAV(R3)	; Save read/write indication		;025
	MOV	R0,R2		; Get read/write indicator in register
	CMP	R0,#.WRITE&377	; Set C=1 for reads
.ASSUME	.READ	LT	.WRITE
	CALLX	CHKXRB		; Now check the XRB parameters
	CLR	(SP)		; Say first time (clobber the "RTI3")
	BIT	#1,XRBCRA(R3)	; Asynchronous I/O request?		;031
	BEQ	USERIC		; No, synchronous.  No more checks.	;031
	CALL	ASCHEK		; Request is asynch.  Check more stuff.	;025
	.BR	USERIC		; Continue with redo code		;025


.SBTTL	User I/O continue (re-do) entry point
;+
;	R0	R1	R2	R3	R4	R5
;	??? 	???	JDB2	WORK or	???	???			;030
;				ASYWRK
;				block	
;
;-

	RDOENT	REDRDO		; Read REDO comes here
	RDOENT	WRTRDO		; Write REDO comes here

USERIC:	MOV	XRBSAV(R3),R2	; Restore read/write indication
	CALL	CMNSIO		; Do the common I/O thing
	BITB	R2,R5		; Legal access?
	BNE	80$		; No, error
	CMP	R3,JOBWRK	; Asynchronous I/O for real?		;031
	BNE	40$		; Yes.  Don't stall the job.		;025
	MOVB	JOB,R5		; Get job number times 2
	CLR	JBSTAT(R5)	; Make job non-runnable on
	MOV	JSBTBL(R4),JBWAIT(R5) ;  the correct device
40$:	CALLX	SCRUMX		; Map the user's buffer (sets up R5)	;025
	MOV	(SP),-(SP)	; Set up word to set CC's from
	MOV	$SERTBL(R4),2(SP) ; Set up the dispatch address
50$:	JMPX	SERSPC		; And off to the service/SPEC entry dispatch

;+
; Dispatch to a device driver's service routine has:
;
;	R0 =  Unit number times 2
;	R1 -> DDB or WCB
;	R2 =  2 (for .READ) or 4 (for .WRITE)
;	R3 -> XRB  (copy in WORK or ASYWRK)
;	R4 =  Driver index here, but replaced by calling job number
;		times 2 set by SERSPC:
;	R5 -> User's buffer through APR 6
;
;	Z-bit = 1 for the first call (else Z-bit = 0).
;	C-bit = 0 for the first call (else C-bit = 1).
;
;	JFIOKY and JFPOST (XRB posting) are indicated.
;
;	Job is non-runnable on the selected device.
;-

GLOBAL	<JBSTAT,JSBTBL,JBWAIT,$SERTBL>

.SBTTL	Handle .SPEC monitor call

	EMTENT	.SPEC		; .SPEC comes here

	CLR	(SP)		; Clobber RTI3 and say this is the first time
	CALL	MOVXRB		; Get the XRB into the workblock
	BIC	#1,XRBCRA(R3)	; Make sure we're a Synch request	;034
	CLR	XRBSAV(R3)	; Set the redo index
.ASSUME	SPCRDO	EQ	0

	RDOENT	SPCRDO		; SPEC redo comes here

				; XRB is not reinited on redo
	CALL	CMNSIO		; Do the common I/O thing
	CMPB	$FLGTBL(R4),XRCI+1(R3) ; Using correct device type?
	BNE	80$		; No, error
	MOV	(R3),R2		; Yes, load the special function code
	MOV	#XRB+140000,R5	; Point R5 to mapped XRB of caller
	MOV	(SP),-(SP)	; Set up the word to set CC's from
	MOV	$SPCTBL(R4),2(SP) ; Set up the dispatch address
	BR	50$		; Go to the service dispatch

;+
; The dispatch for special functions has:
;
;	R0 =  Unit number times 2
;	R1 -> DDB/WCB
;	R2 =  Special function code
;	R3 -> XRB
;	R4 =  Job number times 2 of caller
;	R5 -> (Mapped) XRB of caller
;
;	JFIOKY is set for I/O error code posting.
;
;	The posting pattern is XRB, but JFPOST is not set.
;
;	The job is still runnable.
;-

60$:	ERROR	BSERR		; Illegal channel number

70$:	ERROR	NOTOPN		; Channel not open

80$:	ERROR	PRVIOL		; Access violation

90$:	ERROR	BADCNT		;.Illegal byte count for I/O		;025

100$:	ERROR	NOBUFS		;.No buffer space available		;025

102$:	ERROR	INUSE		; Account or device in use		;025

GLOBAL	<$FLGTBL,$SPCTBL>

.SBTTL	Handle .PEEK monitor call

	EMTENT	.PEEK		; .PEEK comes here

	MOV	@SWITCH,R2	; Get value of console switches
	CMP	(R3),#SWR	; Peeking at the switches??
	BEQ	110$		; Yep, so give their value
	MOVB	JOB,R0		; Get job number			;019
	CALLX	CHKPRV,R4	; Go check privileges			;019
	 .BPRIV	RDMEM		; Allowed to look at memory?		;021
	BCS	80$		; No, error				;019
	MOV	(R3),R1		; Yes, get address to "peek" at
	CMP	R1,#160000	; I/O page address?			;038
	BLO	105$		; No, skip				;038
	CALLX	CHKPRV,R4	; Yes, that requires more privs		;038
	 .BPRIV	SYSMOD							;038
	BCS	80$		; Error if he doesn't have it		;038
105$:	MOV	#PR3&4340,@#PS	; Ensure previous mode as kernel
	MAP	FIPPOL		;  and map FIP's pool
	CALLX	DPEEKR		; Now do the real peeking (to D-space)
	MAP	@UDPAR0,APR=6,DATA ; Restore the mapping to the user.	;022
	MOVB	R0,@IOSTS	; Set error code if any
110$:	MOV	R2,(R3)		; Return data @ XRB+0
	RETURN			; Exit all done

.DSABL	LSB

GLOBAL	<SWITCH,UDPAR0>

.SBTTL	Asynch-specific checking
;+									;025
;	R0	R1	R2	R3	R4	R5			;025
;	EMT 	JOBDA	???	WORK	???	???			;031
;	Code	@JOBF		block					;025
;									;025
;	CALL	ASCHEK							;031
;									;031
;	EXIT information						;031
;									;031
;	If asynch I/O was requested on a device that SUPPORTS it:	;031
;	(True Asynch)							;034
;									;031
;	    R3 -> ASYWRK						;031
;	JOBWRK -> Small Buffer						;031
;									;031
;	If asynch was requested on a device that does NOT support it:	;031
;	(Simulated Asynch)						;034
;									;031
;	    R3 -> JOBWRK						;031
;	JCASTS -> Small Buffer (held for final AST)			;031
;									;031
;	If user specified asynchronous I/O (.READA or .WRITA),		;031
;	three additional parameters are included in the WORK block,	;031
;	(whether the output device supports asynch or not.)		;031
;									;025
;	WORK+XRBEFN	Event Flag Number / Request type		;025
;	WORK+XRBCRA	Completion routine address			;025
;	WORK+XRBAP	AST parameter					;025
;									;031
;-									;031

.ENABL	LSB

ASCHEK:	MOVB	JOB,R0		;Get job number				;040
	CALLX	CHKPRV,R4	;Go check for privileges		;040
	 .BPRIV	TUNE		;Allowed to do asynch I/O?		;040
	BCC	10$		; Yes, so continue			;060
	BIT	#J41ASY,JDFLG4-JDFLG(R1) ;No, did they do any already	;060
	BNE	102$		; Yes, so don't allow another one	;060
	BIS	#J41ASY,JDFLG4-JDFLG(R1) ; Say they already did one	;060
10$:	CMPB	JDMCTL+M.CTRL-JDFLG(R1),#<LCK-MC.LCK> ;Outstanding I/O?	;031
	BHIS	102$		;*Too many for this.  Error "In use"	;031

;+									;031
;	We must allocate another small buffer, since this is an		;031
;	asynchronous request.  If the device supports asynch, we'll	;031
;	substitute the new buffer for the JOBWRK block.  If the device	;031
;	does not support asynch, we are simulating.  JOBWRK retains	;031
;	his/her identity and the new small buffer will be saved for	;031
;	the AST completion routine.					;031
;-									;031

	CALL	CMNSIO		; Get DDIDX in R4, DDSTS in R5		;039
	BITB	R2,R5		; Legal access?				;039
	BNE	80$		;+No, error "Protection Violation"	;039
	MOV	R4,R1		;Save driver index in a safe place	;039
	BUFFER	GETSML,0,60.	; Get buffer for new WRK block (Asynch)	;047
				;  or for AST queue block (Synch)	;031
	BVS	100$		;+Oops.  Error "No Buffers"		;031
	TSTB	R1		; Is device a disk?			;039
	BEQ	30$		;-Yes.  We know disks do asynch.	;025
	BITB	#DDASY/400,R5	; Request=asynch.  Does device support?	;025
	BEQ	40$		;+No.  Treat as synchronous request.	;025

;+									;025
;	We have a buffer for a new WORK block.  Rather than copy the	;025
;	the parameters in the WORK block to the new buffer, we're just	;025
;	substituting the newly-obtained buffer for the normal WORK	;025
;	block.  Sorry if it confuses you.				;025
;-

30$:	MOV	R4,JOBWRK	; Copy new WORK address to pointer.	;039
	MOV	JOBDA,R1	; Get address of JDB.			;031
	MOV	R4,JDWORK(R1)	; Copy new WORK address to JDB		;039
	RETURN								;031

40$:	BIS	#JFPOST,@JOBF	; Simulated, assure posting is set	;039
	MAP	JOBJC6,APR=6,DATA ; Map caller's JCR entry		;049
	MOV	JOBJCR,R2	; And point to it			;049
	MOV	R4,JCASTS(R2)	; Stash address of simulated AST block	;049
	ADD	#XRBEFN,R4	; R4 -> Simulated block @ XRBEFN	;039
	MOVB	XRBEFN(R3),(R4)+ ; Stash event flag number		;039
	MOV	XRBCRA(R3),(R4)+ ; And completion routine address	;039
.ASSUME	XRBCRA	EQ	XRBEFN+1					;039
	MOV	XRBAP(R3),(R4)	; And user's parameter			;039
.ASSUME	XRBAP	EQ	XRBCRA+2					;039
	RETURN			; Back to USERIC:			;031

80$:	ERROR	PRVIOL							;025

90$:	ERROR	BADCNT							;025

100$:	ERROR	NOBUFS							;025

102$:	ERROR	INUSE							;025

.DSABL	LSB

GLOBAL	<MINUS1,JOBJD2>							;039

.SBTTL	Just before return do the posting

;+
; Just before returning to the user we do posting, AST's, etc.
;
; This routine depends on correct ordering of the JDB words
;	and the JDFLG bits!
;-

.DSECT	JDFLG

JDFLG:	.BLKW			; Job flags
JDIOST:	.BLKB			; I/O error code
JDPOST:	.BLKB			; Posting pattern or index
JDWORK:	.BLKW			; Work block pointer
JDJDB2:	.BLKW			; Pointer to JDB2

.BSECT

JFPOST:	.BLKB	.		; Do XRB/FIRQB posting
JFIOKY:	.BLKB	.		; Set I/O status and update keyword
JFCEMT:	.BLKB	.		; Do RSX style posting
JFCC:	.BLKB	.		; Ctrl/C Trap				;031
JF2CC:	.BLKB	.		; 2 ctrl/C Trap				;031
JFPPT:	.BLKB	.		; FPP Trap				;031
JFGO:	.BLKB	.		; Cancel I/O re-do
JFREDO:	.BLKB	.		; Re-do I/O

	UNORG

	TMPORG	EMTDSP,0
	.WORD	DOPOST
	UNORG

DOPOST:	MAP	@UDPAR0,APR=6,DATA ;; Map us into user's 1st 4K		;022
	MOV	JOBF,R3		;; Get job flag pointer
	MOVB	(R3),R5		;; Now get the job flags
	ASLB	R5		;; Check JFREDO and JFGO bits
	BCC	10$		;; JFREDO off, so no re-do I/O
	BIC	#JFREDO!JFGO,(R3) ;; Say no more I/O re-do		;039
	MOV	R3,-(SP)	;; Save JOBF pointer & set redo flag	;039
	MOV	JOBWRK,R3	;; Get work block (an XRB)
	MOV	XRBSAV(R3),R2	;; Re-get the function to redo		;039
	TSTB	R5		;; Should we cancel this I/O redo?	;039
	BPL	5$		;; No, not this time			;039
	CMP	R2,#CCREDO	;; Is this redo interruptable?		;039
	BHIS	5$		;; No, not this time			;039
	MOVB	JOB,R0		;; Yes, so get job # * 2		;039
	BIT	#JSALL,JBWAIT(R0) ;; Redo was interruptable, was wait?	;039
	BEQ	5$		;; No, so we'll redo the request	;039
	MOV	(SP)+,R3	;; Yes, pick up the JOBF pointer again	;039
	BR	10$		;; And join up				;039

5$:	SPLC	3		;; Drop to level 3 for I/O re-do	;039
	JMP	@RDOTBL(R2)	; Dispatch to function for redo

10$:	BITB	R5,#JFCEMT*2	;; Is RSX style posting signaled?
	BEQ	20$		;; Nope
	BICB	#<JFPPT!JF2CC!JFCC>*2,R5 ;; Yep, don't do any Trap(s) this time
20$:	ASLB	R5		;; Check for FPP Trap (JFPPT)		;031
	BPL	30$		;; No Trap handler needed		;031
	MOV	#P.FPP,R0	;; Trap H. needed, get re-route vector	;031
	CALLX	RETUSX		;;  and do the re-route
	BIC	#JFPPT,(R3)	;;   then say we did it
	BCS	30$		;; Re-route failed, die
	CALLX	RETUSX		;; O.K., do again for 2 more words
	BCS	30$		;; Whoops! Failed this time
	MOV	FPPFEC+2,-(SP)	;; Stack the floating error address
	MTPD	-(R1)		;;  and give it to job
	MOV	FPPFEC,-(SP)	;; Stack the floating error code
	MTPD	-(R1)		;;  and give it to job also
30$:	ASLB	R5		;; Check JF2CC and
	ASLB	R5		;;  JFCC bits
	BPL	50$		;; JFCC is off, JF2CC must be off also
	MOV	#P.CC,R0	;; JFCC is on, get re-route vector
	BCC	40$		;; O.K. if JF2CC is off
	MOV	#P.2CC,R0	;;  else re-route for 2 ctrl/C's
40$:	CALLX	RETUSX		;; Do the ctrl/C re-route
	BIC	#JF2CC!JFCC,(R3) ;;  then say we did it
	CALLMI	RECSTR,KBDAP5	;;Ensure recall ptrs at start of cmd 	;066
50$:	MAP	JOBJC6,APR=6,DATA ;; Map caller's JCR entry		;049
	MOV	JOBJCR,R0	;; And point to it			;049
	BICB	#2,JCPRI(R0)	;; Drop special ctrl/C priority		;049
	MOVB	(R3),R5		;; Re-get the job flags
	BICB	#^C<JFPPT!JF2CC!JFCC>,(R3)+ ;; Clear all but Trap bits
	SPLC	3		;;  and to interruptable by all

GLOBAL	<FPPFEC,UDPAR0,JSALL>						;039

	MOV	JCASTS(R0),R4	; R4 -> Simulated AST block (if any)	;049
	CLR	JCASTS(R0)	; No simulated posting any more		;049
	MAP	@UDPAR0,APR=6,DATA ; Map the user's first 4K now	;049
	MOVB	(R3)+,R2	; Get high byte of our flags
	MOVB	(R3)+,R0	; Get the I/O status error code
	MOV	#RTI3,-(SP)	; Set return to "RTI3"
	BITB	R5,#JFCEMT	; Check for complex EMT posting
	BEQ	60$		; It's off
	MOV	#DOEAGN,-(SP)	; Yep, so go do RSX stuff when we're done
60$:	BITB	R5,#JFIOKY	; Set I/O status and/or update key?
	BEQ	120$		; No
	TST	R4		; Are we doing simulated posting?	;039
	BEQ	65$		; No, not this time			;039
	MOVB	R0,XRBUSE(R4)	; Yes, so place I/O status in AST block	;039
	BR	67$		; And skip posting it to FIRQB		;039

65$:	MOV	R0,@#FIRQB+140000 ; Give the I/O status to job		;039
67$:	BIC	#JFLOCK!JFBIG!JFNOPR!JFSYS!JFPRIV!JFFPP!JFSPRI,@#KEY+140000 ;039
				; Clear user's				;039
	BICB	#^C<JFLOCK!JFSYS!JFFPP/400>,R2 ; Trim ours		;019
	MOV	JOBJD2,R0	;Get JDB2 pointer			;019
	TST	J2PPN(R0)	;Logged out?				;019
	BNE	80$		;No					;019
	BIS	#JFNOPR/400,R2	;Yes, indicate that			;019
80$:	MAP	JOBJC6,APR=6,DATA ;Map user's JCR entry			;049
	MOV	JOBJCR,R0	;And point to it			;049
	BITB	#4,JCPRI(R3)	;Special run priority?			;049
	BEQ	82$		;No					;049
	INC	R2		;Yes, indicate it (JFSPRI)		;049
.ASSUME	JFSPRI/400 EQ	1
82$:	TSTPRV	EXQTA,JCPRIV(R0) ;Can exceed quotas?			;049
	BEQ	90$		;No					;019
	BIS	#JFBIG/400,R2	;Yes, indicate that			;019
90$:	ADD	#JCPRIV,R0	;Point to current privs			;049
	BIT	#JFSYS/400,R2	;Temporary privs in effect?		;024
	BEQ	100$		;No, so this is the right mask		;024
	ADD	#JCSPRV-JCPRIV,R0 ;Otherwise use what was saved		;049
100$:	TSTPRV	WACNT,(R0)	;Does he have word-accounting?		;028
	BEQ	110$		;No					;024
	TSTPRV	WWRITE,(R0)	;Yes, but can he write anything?	;029
	BEQ	110$		;No					;024
	TSTPRV	SYSIO,(R0)	; and do system-I/O also?		;028
	BEQ	110$		;No					;024
	BIS	#JFPRIV/400,R2	;Yes, so he must be "privileged"	;024
110$:	MAP	@UDPAR0,APR=6,DATA ;Re-map the user's first 4K now	;049
	BISB	R2,@#KEY+1+140000 ; Fully updated now			;019
120$:	MOV	JOBJD2,R0	;MAKE SURE R0-> THE JDB2		;023
	ASRB	R5		; Do posting (JFPOST)?
	BCC	200$		; Nope, check on AST posting		;039
	TST	R4		; Is this simulated asynch I/O?		;039
	BEQ	125$		; No, this is normal posting		;039
	MOV	JOBWRK,R2	; R2 -> JOBs work block			;039
	MOV	XRBC(R2),XRBC(R4) ; Set up XRBC in AST block		;039
	MOVB	XRBLKM(R2),XRBLKM(R4) ; Set up XRBLKM in AST block	;039
	MOV	XRBLK(R2),XRBLK(R4) ; And set up XRBLK in AST block	;039
	MOVB	JOB,R0		; R0 = Current job # * 2		;039
	CALLX	ASYDNE		; Post this simulated block now		;043
	BR	200$		; And check for AST posting		;039

125$:	MOV	#XRB+140000,R2	; Guess at a post to the XRB
	MOVB	(R3)+,R1	; Get posting pattern (or index)
	BMI	130$		; It is XRB posting
	MOV	$MSKTBL(R1),R1	; FIRQB posting, get pattern
	MOV	#FIRQB+140000,R2 ;  and a pointer to the FIRQB
130$:	MOV	(R3)+,R4	; Get job's work block
	SEC			; Set carry and
140$:	ROR	R1		;  check to post this location?
	BCS	150$		; Bit on, so no
	MOV	(R4),(R2)	; Bit off, so yes
150$:	CMP	(R4)+,(R2)+	; Advance the pointers
	CMP	R1,#-1		; Done?
	BLO	140$		; Not yet, loop...
	MOV	(R3),R2		; Get 2nd job data block pointer
	MOVB	JDIOST-JDJDB2(R3),R0 ; And get any pending error code	;048
	CALLX	EMLSND		; Pass any JCEMLP packet to the EMT logger
200$:	MOV	JOBF,R3		; R3 -> "JOB"s JDB @ JDFLG		;039
	BIT	#JFASTD,(R3)	; Do we need to post AST completions?	;039
	BEQ	210$		; No, not this time			;039
	CMP	(SP),#DOEAGN	; Are we doing a complex EMT?		;039
	BNE	POSTAS		; No, so off to AST posting		;039
210$:	RETURN			; All done...				;039

GLOBAL	<RTI3,NULRTS,DOEAGN,$MSKTBL,UDPAR0>

.SBTTL	Do posting for the Asynchronous Completion vectoring

;+
; POSTAS - Post asynch-specific information				;032+
;
;	Calling job is "JOB"
;	Error code in ASYWRK @ XRBUSE
;
;-

.ENABL	LSB

POSTAS:	BIC	#JFASTD,(R3)	;Inidicate posting is no longer needed	;049
	BIT	#J2ASTA!J2ASTD,JDFLG3-JDFLG(R3) ;Should we post now?	;049
	BNE	40$		;No, an AST is active or disabled	;049
	MAP	JOBJC6,APR=6,DATA ;Map caller's JCR entry		;049
	MOV	JOBJCR,R2	;And point to it			;049
	ADD	#JCASTQ,R2	;Point to queue link word		;049
10$:	MOV	(R2),R1		;GET NEXT <ASYWRK/ASTBLK> OFF THE QUEUE	;049
	BEQ	35$		;OH-OH!  NOTHING IN THE QUEUE!  OH-OH!
	BIC	#1,XRBCRA(R1)	;FIRST CLEAR THE ASYNCH REQUEST BIT
	BEQ	30$		;NO COMPLETION ROUTINE, CLEAN UP AND LEAVE
				;
				; DELIVER THE AST COMPLETION ROUTINE
				;
	MOV	(R1),-(SP)	;Save -> to next work block (if any)	;060
	CALL	SWPASY		;SWAP CURRENT USER XRB/FIRQB WITH ASYWRK ;034
	SPLC	3		;Ensure previous mode = user		;049
	CALLX	CHKSTK		;CHECK THE VALIDITY OF USER'S STACK
				;  Returns: R1 -> [(User Stack) - 4]
	MOV	SYSTAK-2,-(SP)	;STACK THE CURRENT USER PS
	MTPD	(R1)+		; AND GIVE IT TO THE USER STACK
	MOV	SYSTAK-4,-(SP)	;STACK THE CURRENT USER PC
	MTPD	(R1)		; AND GIVE IT TO THE USER STACK
	MOV	@#<FIRQB+140000+FQFIL>,SYSTAK-4				;034
				;USER'S AST ROUTINE WILL EXECUTE	;034
	BIS	#J2ASTA,JDFLG3-JDFLG(R3) ;Indicate AST routine active	;049
	TST	(SP)+		;Was there another work block?		;060
	BEQ	37$		; No, so now allow more.		;060
	BR	40$		;ASYWRK GETS DEQUEUED AT ASTX TIME

30$:	MOV	(R1),(R2)	;DEQUEUE THIS ASYWRK BLOCK, ANY MORE?
	MOV	R1,R4		;PUT <ASYWRK/ASTBLK> BLOCK -> HERE
	BUFFER	RETSML		; AND RETURN IT TO THE SMALL BUFFER POOL
	BR	10$		;And loop				;034

35$:	MOV	R2,JCASTT-JCASTQ(R2) ;Fix the tail pointer		;049
37$:	BIC	#J41ASY,JDFLG4-JDFLG(R3) ;Clear the non-prived one-shot	;060
40$:	RETURN			;All done...

.DSABL	LSB

GLOBAL	<JOBDA,JOBJD2,CHKSTK,SYSTAK>					;032-

.END


