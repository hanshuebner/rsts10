	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
	.INCLUDE /CMN:KBDEF/
	.INCLUDE /FCS:QIOMAC/
	.INCLUDE /CMN:RSXCOM/
	.INCLUDE /CMN:FLDEF/
TITLE	EMU,<RSX EMULATION>,0J,27-MAR-92,MHB/MJG/RTW/TG/SJM/FEK/DRP/KPH/FRL/DWF/WRM

;
;		COPYRIGHT (c) 1974, 1992 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR EMU

;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;  001	TG   27-Jun-80	Added GEN phase stuff
;  002	RTW  09-Aug-80	Change to complex emt code
;  003	TG   15-Dec-80	Removed RSX phase
;  004  SJM  16-MAR-81	Add $SPND directive emulation
;  005  SJM  13-JUL-81	Add I&D space support
;  009  FEK  19-MAR-82  Fix $TICK access for I&D
;  010	DRP  12-APR-82	Put patch article 3.1.6 into source
;
;				[RSTS V8.0]
;  011	GPK  30-Dec-82	32K job support
;
;				[RSTS V9.0]
;  012	DRP  12-May-83	Fix bug in EXTK$ error exit on initial directive
;  013	FEK  05-Jul-83	SUPPORT FOR USER I/D SPACE
;  014	FEK  12-Jul-83	Add GSSW$, and MVTS$
;  015	FEK  14-Jul-83	Allow directives above 127.
;  016	DRP  20-Sep-83	Source clear patch 3.1.8 M
;  017	GPK  29-Dec-83	Remove extraneous JFNOPR reference
;  018	KPH  09-Jan-84	Add CRRG$
;  019	KPH  11-Jan-84	Changes for EMTs in EM2 phase
;  020	GPK  22-Feb-84	Remove messages, set J2EXST in EXST$ directive
;			Skip PMD if J2PRVP set
;  021  KPH  04-Apr-84	Add task loader
;			Add ENAR$ and DSAR$
;			I&D space changes to .CORE and EXTK$
;			Remove .RSX directive
;			Improve logical name parsing
;			Remove restoration of R.MON1 in DOCALL
;  022  FRL  04-Apr-84  V9.0 logicals
;  023	KPH  26-Jun-84	Bugfixes
;			Move to RSX phase
;  024	KPH  19-Sep-84	Add support for overlaid I&D tasks
;  025	KPH  23-Oct-84	Fix mapping of library's root segment
;			Add support for job's worst exit status
;  026	KPH  19-Nov-84	Bugfix in PMD processing; bugfix in EXST$
;  027	KPH  08-Jan-85	Make default translation for CL: be TT:
;  028	KPH  07-Feb-85	Add keyboard monitor
;  029	KPH  12-Mar-85	Remove JFPRIV reference
;
;			[RSTS V9.2]
;  030  KPH  12-Jul-85	Add Job Control Region
;			Move IOB to FIP pool
;
;			[RSTS V9.3]
;  031  KPH  12-Sep-86	Bugfix in initial task size setup for I/D tasks
;
;			[RSTS V9.4]
;  032	DWF  19-Feb-87	Improve LD$SUP library handling
;			Add the PSW to the register dump
;  033  WRM  03-Apr-87  Add FASTMAP to RSXRUN function                     
;
;			[RSTS V9.6]
;  034  WRM  09-Jan-88	Add EXTM$ apr mask directive
;
;			[RSTS V9.7]
;  035  WRM  29-Sep-88	Add Dynamic region as RSX-11 task header region (F77)
;			Allow Dynamic regions size up to 255KW
;			Make RSX Task Loader handle concurrent D & I regions
;			Include supervisor mode in LIB searches
;  036  WRM  15-Dec-88	Fix overlay channel closed incorrectly in loader
;			Add multiple calls to GMCR$ function
;			Allow AST service routines to live in supervisor mode
;  037  WRM  20-Jan-89	Add FEAT$ and TFEA$ calls
;  038  WRM  01-Feb-89	Bring SST cross mode vectoring to RSX-11m+ standard
;			Add RSX-11/M+ D-space loader method
;			Store initial PC-PSW-SP for PMDUMP
;			Fix incorrect task size given in GTSK$ for /ID
;
;			[RSTS V10.0]
;  039  WRM  15-Sep-89	Fix ODT mapping failure on libraries
;			Add MSDS$ code
;			Source clear 3.1.10 by calling SET prev mode routine
;			changes for extended logicals
;  040	DRP  08-Jan-90	Fix bug in ALUN.
;  041	FEK  11-Jan-90	Fix another bug in ALUN.
;  042	WRM  31-Jan-90	Fix D-space load problem for I&D sil format
;  043  WRM  22-Feb-90	Fix mapping bug in in FEAT$
;  044  WRM  25-Apr-90	Fix /SI:n math error and
;			add automatic Dyn Region size to GTSK
;
;			[RSTS V10.1]
;  045	FEK  15-Feb-92	Fix /SI:n again (044 fixed just /SI:+n)
;-


	DEFORG	FEATAB							;037+
			;table of FEAT$ feature test codes

	DEFORG	TFETAB
			;table of TFEA$ feature test codes

	DEFORG	FEATAD
			;table of feature test routine addresses	;037-

	DEFORG	EMU

.SBTTL	GET THE RSX QIO DEFINITIONS

;	FIRST A MACRO TO DO THE DEFINING

.MACRO	DEFIN$	SYM,VAL
.EQUATE	SYM,<VAL>
.ENDM	DEFIN$

;	NOW INVOKE THE DEFINITIONS...

	QIOSY$

.SBTTL	DEFINE LOCAL MACROS

;	DO A MONITOR CALL WITH RETURN

.MACRO	DOCALL	CODE
	 CALLX	DOEMT,R5,<CODE>
.ENDM

;	DIRECTIVE ERROR EXIT; FIXED ERROR CODE

.MACRO	XITERR	CODE
	CALL	XITERR,R5,CODE
.ENDM	XITERR

;	DEFINE DIC DISPATCH ADDRESS

.MACRO	DICDEF	DICVAL,DICLEN
.DSABL	CRF
.IF	NDF	DICMAX
.IIF	NDF	DICMIN,		DICMIN=203.
.IIF	NDF	DICNUM,		DICNUM=0
.IIF	GT	DICMIN-DICVAL,	DICMIN=DICVAL
DICNUM	=	DICNUM+1
.ENABL	CRF
	TMPORG	RSXDIC
	.BLKW
	TMPORG	RSXTBL
	.BLKW
.IFF
$$$$$$	=	.
$$$$$0	=	DICNUM-1
$$$$$1	=	DICMIN
.REPT	<DICVAL-DICMIN>/2
.IRP	XXX,<\<$$$$$1&377>>
.IF	DF	DEF'XXX
.IF	LT	$$$$$1-DICVAL
$$$$$0	=	$$$$$0-1
.ENDC
.ENDC
.ENDM
$$$$$1	=	$$$$$1+2
.ENDR
.ENABL	CRF
	TMPORG	RSXDIC,$$$$$0*2
	 .BYTE	DICVAL,DICLEN
	TMPORG	RSXTBL,$$$$$0*2
	 .WORD	$$$$$$
.ENDC
	UNORG
.DSABL	CRF
$$$$$$	=	DICVAL&377
.IRP	NUM,<\$$$$$$>
.NCHR	$$$$$0,<NUM>
.IRP	TAG,<DIC,DIC0,DIC00>
.NCHR	$$$$$1,<TAG>
.IF	EQ	$$$$$0+$$$$$1-6
.ENABL	CRF
.LIST
TAG''NUM:
.NLIST
.DSABL	CRF
.ENDC
.ENDM
DEF'NUM:
.ENDM
.ENABL	CRF
.ENDM	DICDEF

; Data moving

.MACRO	MOVE	SRC,DEST,LEN
	CALL	MOVE,R5,<SRC,DEST,LEN>
.ENDM	MOVE

; Do a monitor directive with all registers saved

.MACRO	DOCALX	CODE
	CALL	DOCALX,R5,CODE
.ENDM	DOCALX

; Report an error

.MACRO	DOERR	CODE
	CALL	DOERR,R5,CODE
GLOBAL	<CODE>
.ENDM	DOERR

.SBTTL	Define our local data

	TMPORG	RSXDTA

RUNSTR:	.ASCIZ	/RUN /		;The RUN command from our KBM		;028
PROMCR:	.BYTE	15,12		;A <CR/LF> for the prompt		;028
PROMPT:	.ASCIZ	/RSTS> /	;The KBM prompt				;028

.EVEN	;In the quietest moments					;028

	UNORG								;028

.SBTTL	START LOCAL TABLES

	TMPORG	RSXDIC		;TABLE OF EMULATED DIC'S (AND DPB LENGTHS)
RSXDIC:

	UNORG

	TMPORG	RSXTBL		;DISPATCHES FOR EMULATED DIC'S
RSXTBL:

	UNORG

.SBTTL	THE JOB DIES...

;+
; RSXDIE - A FATAL ERROR ABORT.
;
;	R4 =  P.??? -OR- ERROR CODE
;	SP -> ...,R0,R1,R2,R3,R4,R5,PC,PS,...
;					  !- "SYSTAK"
;	JOB IS "JOB"
;	JOB'S 1ST 4K IS MAPPED THROUGH PAR6
;
;	JMP	RSXDIE
;-

.ENABL	LSB

RSXDIE:	MOV	#SYSTAK-<8.*2>,SP ;;RESET SP STACK TO FLUSH ANY JUNK WORDS
	MAP	JOBJC6,APR=6,DATA ;;Map caller's JCR entry		;030
	MOV	JOBJCR,R1	;;And point to it			;030
	BICB	#2,JCPRI(R1)	;;DROP SPECIAL CTRL/C PRIORITY		;030
	MOV	JOBF,R1		;GET POINTER TO JDB @ JDFLG
	BIC	#JFPPT!JF2CC!JFCC,(R1) ;;ENSURE FURTHER AST'S ARE OFF
	SPLC	3		;;NOW ENSURE LEVEL 3 AND PREVIOUS = USER
	MAP	@UDPAR0,APR=6,DATA ;Be sure user's first 4K is mapped	;030
	MOV	R4,@#R.MON1+140000 ;SAVE P.??? -OR- ERROR CODE HERE
	BIS	#JFGO,(R1)	; CANCEL ANY I/O REDO
	MFPD	SP		;GET USER'S SP STACK			;013
	MOV	(SP),R1		; INTO A REGISTER
	MOV	#SYSTAK,R5	;GET POINTER TO USER'S REGISTERS, ETC.
10$:	MOV	-(R5),R0	;GET A REGISTER
	CALLX	UPOKER		; AND POKE ONTO USER'S STACK
	BNE	30$		;AN ERROR, JUST QUIT
	CMP	R5,#SYSTAK-<2*2> ;DID WE JUST PUSH THE USER PC?
	BNE	20$		;NOPE
	MOV	(SP)+,R0	;YEP, GET USER'S SP STACK VALUE
	CALLX	UPOKER		; AND PUSH THAT HERE
	BNE	30$		;AN ERROR, QUIT
20$:	CMP	R5,SP		;HAVE WE PUSHED EVERYTHING?
	BHI	10$		;NOT YET, CONTINUE...
30$:	MOV	R1,@#PMDSP+140000 ;DONE, SAVE THE FINAL USER SP STACK VALUE

GLOBAL	<SYSTAK,UDPAR0>							;030

	BIT	#JFDUMP,@#KEY+140000 ;Do they want a dump?		;021
	BEQ	60$		;No, not this time			;021
	MOV	JOBDA,R0	;Get JDB pointer			;030
	BIT	#J2PRVP,JDFLG3(R0) ;Is this a privileged program?	;030
	BNE	60$		;YES, NO POST-MORTUM DUMPING
	BR	40$		;NO, DO POST-MORTUM DUMPING
..CCPM==.-2			;** PATCH ** NOP TO EXCLUDE CTRL/C DUMPS
	CHKERR	CTRLCE,R4	;CONTROL/C ABORT?
	BEQ	60$		;YES, DON'T DUMP
40$:	MOVE	FIRQB+140000,PMDXRB+140000,FQBSIZ/2 ;Save user's FIRQB	;021
	CALL	CLRFQB		;Clear out the FIRQB			;026
	;MOVB	#CLSFQ,@#140000+FIRQB+FQFUN ;Function is close		;026
.ASSUME	CLSFQ	EQ	0
	MOVB	#15.*2,@#140000+FIRQB+FQFIL ;And set to use channel 15	;026
	DOCALL	CALFIP		;ASK FIP TO CLOSE CH# 15.
	TST	(R0)+		;SKIP TO FQFUN/FQJOB
	MOVB	(R0)+,R3	;GET JOB # *2
	ASR	R3		; THEN *1
	CLR	R2		;CLEAR A HIGH ORDER
	DIV	#10.,R2		; AND FIND TENS/UNITS
	MOVB	#CREFQ,(R0)+	;SET FUNCTION TO CREATE
	CMP	(R0)+,(R0)+	;SKIP CH# AND PPN
	MOV	#^RPMD,(R0)+	;SET FIRST PART OF FILE NAME AS "PMD"
	MOV	#^R000,(R0)	;SET SECOND PART WITH BASE OF ALL ZEROES
	ADD	R3,(R0)		;CORRECT UNITS
	MUL	#50,R2		;MAKE TENS (IN R2) INTO RAD50 (IN R3)
	ADD	R3,(R0)+	;CORRECT TENS
	MOV	#^RPMD,(R0)	;SET EXTENSION AS ".PMD"
	MOV	#100000!32.,FQMODE-FQEXT(R0) ;SAY TENTATIVE
	DOCALL	CALFIP		;SO GO DO IT

	MOVE	PMDXRB+140000,FIRQB+140000,FQBSIZ/2 ;Restore FIRQB	;021
	MOVE	XRB+140000,PMDXRB+140000,XRBSIZ/2 ;Save XRB		;021
	MOV	MAXDLO,(R5)	;XRLEN = JOB'S BYTE SIZE -1		;013
	INC	(R5)		;Compute actual byte count		;011
	BNE	53$		;Not a 32K job				;011
	MOV	#31.*1024.*2,(R5) ;Otherwise transfer first 31K		;011
53$:	MOV	(R5)+,(R5)+	;XRBC = JOB'S BYTE SIZE
	CLR	(R5)+		;XRLOC = 0
	MOV	#15.*2,(R5)+	;XRCI = CH# 15., XRBLKM = 0
	CLR	(R5)+		;XRBLK = 0
	CLR	(R5)+		;XRTIME = 0
	CLR	(R5)+		;XRMOD = 0
	DOCALL	.WRITE		;WRITE IT
	CMP	MAXDLO,#-1	;Is this a 32K job?			;013
	BNE	56$		;No, so we're done			;011
	MOV	#XRB+140000,R5	;Yes, we'll have to write out last 1K	;011
	MOV	#1024.*2,(R5)	;Set byte count for 1K words		;011
	MOV	(R5)+,(R5)+	;XRBC = 1K words also			;011
	MOV	#31.*1024.*2,(R5)+ ;XRLOC = 31K				;011
	MOV	#15.*2,(R5)+	;XRCI = CH# 15., XRBLKM = 0		;011
	MOV	#31.*4+1,(R5)+	;XRBLK = 31*4 (4 words per block) +1	;011
	;CLR	(R5)+		;XRTIME = 0				;011
	;CLR	(R5)+		;XRMOD = 0				;011
	DOCALL	.WRITE		;WRITE IT				;011
56$:	TST	(R0)+		;SKIP TO FQFUN/FQJOB
.ASSUME	FQJOB	EQ	2
.ASSUME	FQFUN	EQ	FQJOB+1
	CLR	(R0)+		;CLOBBER JOB #, BUT SET FUNCTION TO CLOSE
.ASSUME	CLSFQ	EQ	0
	MOVB	#15.*2,(R0)	;SET CH# 15. AGAIN
.ASSUME	FQFIL	EQ	FQJOB+2
	DOCALL	CALFIP		;CLOSE THE FILE
	CLR	@#KEY+140000	;CLEAR ALL JOB FLAGS

GLOBAL	<MAXDLO>

60$:	MOV	#FIRQB+FQFUN+140000,R0 ;GET USER FIRQB POINTER @ FQFUN
	MOVB	#UU.ERR,(R0)+	;SET FUNCTION AS ERROR MESSAGE LOOKUP
	MOVB	@#R.MON1+140000,(R0) ;COPY CODE TO USER FIRQB
.ASSUME	FQERNO	EQ	FQFUN+1
	BGT	70$		;ERROR CODE IS REAL
	SETERR	B.10,(R0)	;ELSE USE THIS ERROR CODE
70$:	CHKERR	CTRLCE,(R0)	;CONTROL/C ABORT?
	BEQ	110$		;YES
	CLR	@#KEY+140000	;NO, CLEAR ALL JOB FLAGS
	DOCALL	.UUO		;GET THE ERROR MESSAGE
	CALL	SETXRB		;SET UP FOR AN ERROR MESSAGE
	CMP	(R0)+,(R0)+	;POINT TO THE MESSAGE TEXT @ FQERNO
	CLRB	28.(R0)		; AND INSURE TERMINATION
80$:	MOVB	(R0)+,(R1)+	;COPY REST OF MESSAGE
	BNE	80$		; UNTIL ITS END...
	DEC	R1		;CORRECT FOR THAT ENDING NULL BYTE
	MOVB	#015,(R1)+	;NOW SET UP THE REGISTER DUMP
	MOVB	#012,(R1)+	; ...
	MOV	#SYSTAK-<8.*2>,R3 ;POINT TO BEGINNING OF USER REGISTERS
90$:	MOV	(R3)+,R5	;GET A REGISTER
	CALL	150$		;...AND FORMAT 6 OCTAL DIGITS
	CMP	#SYSTAK-<2*2>,R3;JUST FINISHED WITH R0-R5?
	BNE	90$		;NOPE
	MFPD	SP		;YEP, GET USER'S SP STACK VALUE			;013
	MOV	(SP)+,R5	;GET USER'S SP (SAVED BY MFPD ABOVE)
	CALL	150$		;...AND FORMAT IT
	MOV	(R3)+,R5	;GET USER'S PC				;032
	CALL	150$		;...AND FORMAT IT
	MOV	(R3),R5		;Now, get the PSW			;032
	CALL	150$		;...and format it			;032
	CALL	UPDXRB		;UPDATE XRB FOR MESSAGE CONSTRUCTED
	DOCALL	.WRITE		; THEN WRITE THE MESSAGE
110$:	JMP	EXIT$		;NOW GO EXIT

150$:	CLR	R4		;R4-R5 USED IN COMBINATION FOR ASHC...
	MOV	#6.,R0		;SET UP TO PRINT 6 DIGITS
	ASHC	#1,R4		;GET 1ST DIGIT (BIT ACTUALLY)
160$:	BIC	#^C<7>,R4	;MASK OUT BITS TO FORM OCTAL DIGIT
	ADD	#60,R4		;FORM ASCII DIGIT CHARACTER
	MOVB	R4,(R1)+	;STORE THE DIGIT
	ASHC	#3,R4		;SHIFT THE NEXT DIGIT INTO R4
	SOB	R0,160$		;LOOP FOR 6 DIGITS
	MOVB	#040,(R1)+	;SEPARATE REGISTERS BY TWO BLANKS
	MOVB	#040,(R1)+	; ...
	RETURN			;ANOTHER REGISTER DONE

.DSABL	LSB

GLOBAL	<SYSTAK>

.SBTTL	AST PROCESSING

.ENABL	LSB

10$:	.BYTE	P.2CC		;-3 - 2 CTRL/C'S
	.BYTE	P.CC		;-2 - CTRL/C
	.BYTE	P.FPP		;-1 - FPP EXCEPTION
20$:	.BYTE	B.4		; 0 - ODD ADDRESS, ETC.
	.BYTE	B.250		; 1 - MEMORY PROTECT
	.BYTE	P.BPT		; 2 - BREAKPOINT
	.BYTE	P.IOT		; 3 - IOT
	.BYTE	B.10		; 4 - RESERVED INSTRUCTION
	.BYTE	P.EMT		; 5 - EMT
	.BYTE	P.TRAP		; 6 - TRAP
	.BYTE	P.FIS		; 7 - FIS EXCEPTION
	.BYTE	0		;END OF LIST
	.EVEN

;+
; AST PROCESSING.
;
;	WHAT		HOW		SP STACK USAGE
;
;	FPP EXCEPTION	P.FPP		SP -> FEA, FEC, $DSW, PC, PS, EFM
;	CTRL/C		P.CC		SP -> PC, PS
;
; FOR FPP EXCEPTION:
;
;	EFM (EVENT FLAG MASK) IS NOT IMPLEMENTED...
;-

30$:	CMP	R0,#-2		;;WHICH AST IS IT?
	BGT	60$		;;FPP AST (INDEX = -1)
	BLT	40$		;;2 CTRL/C AST (INDEX = -3), ABORT
	MOV	@#R.CAST+140000,R2 ;;CTRL/C (INDEX = -2), GET CTRL/C DISPATCH
	CLR	@#R.CAST+140000	;;AVOID LOOPS ON CONTROL/C AST'S
	CALL	CHKUPC,R5	;; AND GO CHECK IT OUT
40$:	SETERR	CTRLCE,R4,WORD	;;SET THE CTRL/C ERROR
	BIT	@#KEY+140000,#100377 ;;A FRESH ENTRY CTRL/C?
	BNE	50$		;;NO
	CLR	@#NSTORG+140000	;;YES, DON'T CALL IT A STACK ERROR
50$:	CALL	STKCHK		;;CHECK FOR SP STACK ERROR(S)
	BR	110$		;;ABORT IN ANY EVENT (R4 = "CTRLCE")

60$:	MOV	FPPFEC+2,(SP)	;;STACK FEA (OVER # EXTRA)
	MOV	FPPFEC,-(SP)	;;STACK FEC
	MOV	@#$DSW+140000,-(SP) ;;STACK THE DSW
	MOV	#3,-(SP)	;;SAY 3 EXTRA WORDS ON STACK
	MOV	@#R.FAST+140000,R2 ;;GET FPP AST DISPATCH ADDRESS
	CALL	CHKUPC,R5	;; AND GO CHECK IT
	BR	110$		;;NO GO, JUST DIE (R4 = P.FPP)

GLOBAL	<B.4,B.250,B.10,FPPFEC>

.SBTTL	TRAPPED SST/AST/ENTRY

;+
; TRAPPED SST'S (FROM "RETUSR").
; TRAPPED AST'S (FROM "RETUSX").
; TRAPPED ENTRIES (FROM "SCH" VIA "RETUSR").
;
;	R0 =  P.???
;	SP -> ...,R0,R1,R2,R3,R4,R5,PC,PS,...
;					  !- "SYSTAK"
;	JOB IS "JOB"
;
;	CALL	RSXTRP
;
;	R0 =  UNDEFINED
;	R1 =  UNDEFINED
;	R2 =  UNDEFINED
;	R4 =  UNDEFINED
;
;	C=1 ALWAYS
;
;	JOB'S 1ST 4K IS MAPPED THROUGH PAR6
;-

	TMPORG	RSXDSP,0					;023

	.WORD	RSXTRP

	UNORG

RSXTRP:	MAP	@UDPAR0,APR=6,DATA ;;ENSURE WE ARE MAPPED TO USER'S 1ST 4K	;013
	MOV	R0,R4		;;SAVE THE P.??? IN CASE WE WANT TO DIE
	CMP	R4,#P.BAD	;;IS IT THE "BAD" ENTRY POINT?
	BNE	70$		;;NO
	MOVB	@IOSTS,R4	;;YES, CHANGE TO THE ERROR CODE
70$:	CLR	-(SP)		;;SET # EXTRA TO ZERO INITIALLY
	MOV	#10$,R0		;;GET THE P.???/ERROR CODE LIST POINTER
80$:	TSTB	(R0)		;;END OF LIST?
	BEQ	110$		;;YES, DEATH FOR SURE (R4 = P.???/ERROR CODE)
	CMPB	R4,(R0)+	;;ELSE CHECK FOR A MATCH
	BNE	80$		;;NO MATCH, KEEP CHECKING...
	SUB	#20$+1,R0	;;A MATCH, FIND THE SST INDEX
	BMI	30$		;;<0 IS AN AST INDEX

GLOBAL	<UDPAR0>

.SBTTL	SST PROCESSING

;+
; SST PROCESSING.
;
;	WHAT		INDEX	HOW		SP STACK USAGE
;
;	ODD ADDRESS	  0	P.BAD W/ B.4	SP -> PC, PS
;	MEMORY PROTECT	  1	P.BAD W/ B.250	SP -> SR1, SR2, SR0, PC, PS
;	BREAKPOINT	  2	P.BPT		SP -> PC, PS
;	IOT		  3	P.IOT		SP -> PC, PS
;	RESERVED INST	  4	P.BAD W/ B.10	SP -> PC, PS
;	NON-MONITOR EMT	  5	P.EMT		SP -> CODE*2, PC, PS
;	TRAP		  6	P.TRAP		SP -> CODE*2, PC, PS
;	FIS EXCEPTION	  7	P.FIS		SP -> PC, PS
;
; FOR MEMORY PROTECT:
;
;	SR0 (MMU CONTROL)	IS FAKED AS 0
;	SR1 (AMT CHANGED)	IS FAKED AS 0
;	SR2 (VIRTUAL PC)	IS FAKED AS THE ERRING PC
;-


	CMP	R0,#1		;MEMORY PROTECT VIOLATION?
	BNE	90$		;NO
	;CLR	(SP)		;YES, FAKE SR1 AS 0 (OVER # EXTRA)
	MOV	SYSTAK-<2*2>,-(SP) ; AND FAKE SR2 AS ERRING PC
	CLR	-(SP)		;  AND FAKE SR0 AS 0
	MOV	#3,-(SP)	;SAY 3 EXTRA WORDS
90$:	MOV	R0,R1		;COPY THE SST INDEX
	SUB	#5,R1		;FIND IF NON-MONITOR EMT (INDEX = 5)
	ASR	R1		; OR TRAP (INDEX = 6)
	BNE	100$		;NEITHER
	MOV	SYSTAK-<2*2>,R1	;ONE OF THE TWO, GET PC+2 OF EMT/TRAP
	MFPI	-(R1)		;NOW GET THE INSTRUCTION ITSELF
	MOV	(SP)+,(SP)	; AND MOVE IT OVER # EXTRA
	CMP	(SP),(PC)+	;REALLY "EMT 377", THE RSX DIRECTIVE CALL?
		EMT 377
	BEQ	RSXDIR		;YES, WE MUST PROCESS IT...
	CLRB	1(SP)		;NO, TRIM OFF THE HIGH BYTE
	ASL	(SP)		; AND FORM CODE*2
	MOV	#1,-(SP)	;SAY 1 EXTRA WORD
100$:	CALL	120$,R5,R.ODTV+140000 ;CHECK FOR ODT SST
	CALL	120$,R5,R.SSTV+140000 ;CHECK FOR NORMAL SST
110$:	JMP	RSXDIE		;CAN'T TAKE IT, DIE (R4 = P.???/ERROR CODE)

GLOBAL	<SYSTAK>

120$:	MOV	(R5)+,R2	;GET (BIASED) POINTER TO R.???V, R.???L
	TST	(R2)+		;ANYTHING THERE?
	BEQ	130$		;NO, RETURN
	CMPB	R0,(R2)		;YES, ARE WE WITHIN RANGE?
	BHIS	130$		;NO AGAIN, SO RETURN
	MOV	-(R2),-(SP)	;save copy of vector + mode flag	;038
	MOV	R0,-(SP)	;save the SST index			;038
	MOV	(R2),-(SP)	;save another copy of vector+mode flag	;038
	BIC	#1,(SP)		;mode to user,vector lives there	;038
	MOV	R0,R1		;COPY THE SST INDEX AND			;038
	ASL	R1		;DOUBLE INDEX FOR WORD ADDRESSING
	ADD	(SP)+,R1	;FORM USER'S SST TABLE ADDRESS		;038
	CALLX	DPEEKR		;TRY TO GET USER'S DISPATCH ADDRESS
	BNE	110$		;WHOOPS, SOME ERROR (R4 = P.???/ERROR CODE)
	MOV	(SP)+,R0	;RESTORE THE SST INDEX
	BIT	#1,(SP)+	;was vector table defined in super mode? ;038
	BEQ	CHKUPC		;no, 0 is user mode define, ok as is	;038
				;yes- must compliment bit 0 in R2	;038
	MOV	R2,-(SP)	;copy address and mode flag		;038
	BIC	#1,(SP)		;remove mode flag			;038
	COM	R2		;compliment address and mode flag	;038
	BIC	#177776,R2	;remove address, leaving just mode flag	;038
	BIS	(SP)+,R2	;add back just address to new mode flag	;038
	.BR	CHKUPC		;now vector is as exected by CHKUPC	;038
;+
; CHKUPC - CHECK A NEW USER PC, RE-ROUTE IF O.K.
;
;	R2 =  NEW USER PC (even-->user mode/odd-->supervisor mode	;036
;	R4 =  P.??? -OR- ERROR CODE
;	SP -> #EXTRA,[EXTRA],RETURN,...,R0,R1,R2,R3,R4,R5,PC,PS,...
;								!- "SYSTAK"
;	JOB IS "JOB"
;	JOB'S 1ST 4K IS MAPPED THROUGH PAR6
;
;	CALL	CHKUPC,R5	(NO RETURN IF NEW USER PC IS O.K.)
;
;	R2 =  UNDEFINED
;-

CHKUPC:	TSTB	@#KEY+140000	;;ARE TRAP(S) ENABLED?			;036
	.ASSUME	JFTRAP	EQ	200					;036
	BPL	130$		;;No should not do re-route		;036
	ASR	R2		;;DO QUICK CHECK FOR 0 OR ODD
	BEQ	130$		;;IT'S 0 OR 1, FORGET IT
	CLR	R4		;;presume going to user mode		;036
	BCC	140$		;;It's even, user mode is correct	;036
	ROR	R4		;;odd, so mark for supervisor mode	;036
	;CLC			;;because R4 was clear			;036
	BR	140$		;;goto re-routing			;036
.ASSUME	JFTRAP	EQ	200
130$:	RETURN	R5		;;ELSE EXIT

140$:	ASL	R2		;;O.K., BACK TO AN ADDRESS AGAIN	;036
	CALL	SETPRE		;;set the prev mode in @#PS to systak-2	;039
	MOV	(SP)+,R5	;;POP SAVED R5 SINCE WE WON'T BE RETURNING
	MFPD	SP		;;GET THE USER'S SP STACK		;013
	MOV	(SP)+,R1	;; INTO A REGISTER
	CMP	R1,#NSTORG+<2*2> ;;IS IT REALLY MESSED UP?
	BHIS	150$		;;NO
	MOV	#-1,@#NSTORG+140000 ;;YES, FORCE AN ERROR EXIT
150$:	CALL	STKCHK		;;CHECK FOR SP STACK ERROR(S)
	MOV	R2,-(SP)	;;SAVE THE NEW USER PC
	MOV	SYSTAK-<1*2>,R0	;;GET OLD USER PS
		;;UPOKER forces PREV to user before and leaves it @#PS	;036
	CALLX	UPOKER		;; AND POKE ONTO USER'S SP STACK
	BNE	110$		;;WHOOPS, SOME ERROR, DIE (R4=CODE)
	MOV	SYSTAK-<2*2>,R0	;;GET OLD USER PC
	CALLX	UPOKER		;; AND POKE ONTO USER'S SP STACK
	BNE	110$		;;WHOOPS, AN ERROR, DIE (R4=CODE)
	MOV	(SP)+,SYSTAK-<2*2> ;;Set the new PC			;036
	BIC	#3777,SYSTAK-<1*2> ;;Set CC's & priority=0, save modes	;036
	BIS	#PR0!140000,SYSTAK-<1*2> ;;presume destination user mde	;036
160$:	DEC	(SP)		;;ANOTHER EXTRA WORD ON STACK?
	BMI	170$		;;NOPE, TIME TO RETURN
	MOV	2(SP),R0	;;YEP, GET THE DATA WORD
	MOV	(SP)+,(SP)	;; AND MOVE THE COUNT DOWN
	CALLX	UPOKER		;;POKE IT ONTO USER'S SP STACK
	BEQ	160$		;;O.K., LOOP...
	BR	110$		;;ERROR, DIE (R4=CODE)

170$:	MOV	R1,(SP)		;;SET FINAL USER SP STACK VALUE
	TST	R4		;;user=0 or super<>0 ?			;036
	BEQ	180$		;;user, everything is ready		;036
	BIC	#20000,@#PS	;; put SP to super mode	SPLC		;036
	BIC	#100000,SYSTAK-<1*2> ;;send to supervisor space		;036
180$:	MTPD	SP		;; AND SET IT				;013
	BR	STKCHK		;;DO A FINAL STACK CHECK AND EXIT

.DSABL	LSB

GLOBAL	<SYSTAK>

.SBTTL	RSX DIRECTIVE EMULATION

;+
; RSXDIR - RSX DIRECTIVE EMULATION.
;
;	SP -> ...,"RTI3",R0,R1,R2,R3,R4,R5,PC,PS,...
;						 !- "SYSTAK"
;	JOB IS "JOB"
;	JOB'S 1ST 4K IS MAPPED THROUGH PAR6
;
;	JMP	RSXDIR
;-

RSXDIR:	MOV	#SYSTAK-<9.*2>,SP ;RESET STACK TO JUST "RTI3",REGS,PC,PS
	MFPD	SP		;GET USER'S SP STACK			;013
	MOV	(SP),R1		; INTO A REGISTER

;	GET DIRECTIVE PARAMETER BLOCK

	MOV	#1,R3		;SET TENTATIVE DPB LENGTH
	BIC	R3,SYSTAK-<1*2>	;CLEAR CARRY IN USER'S PS
.ASSUME	C	EQ	1
	MOV	#IS.SUC,@#$DSW+140000 ; AND PRESET DSW TO SUCCESS
	CALL	PEKADP		;GET FIRST STACK WORD
	BIT	R2,R3		;DIRECT OR INDIRECT DPB?
	BNE	10$		;DIRECT
	MOV	R2,R1		;INDIRECT
	CALL	PEKADP		;GET FIRST WORD OF DPB
	BR	20$		; AND CONTINUE

;	SET FINAL STACK POSITION

10$:	MOV	R2,R3		;COPY DPB/DIC
	CLRB	R3		;NOW REMOVE THE DIC
	SWAB	R3		; AND PUT DPB LENGTH INTO LOW BYTE
20$:	ASL	R3		;CONVERT STACK CHANGE TO BYTES
	ADD	R3,(SP)		;CORRECT USER'S SP STACK
	MTPD	SP		; AND SET IT				;013
	MOV	R1,@#R.MON1+140000 ;SAVE ORIGINAL DPB +2 POINTER

;	CHECK FOR VALID DIRECTIVE CODE

	MOV	#RSXDIC+<DICNUM*2>,R5 ;POINT TO END OF DIC TABLE
30$:	CMP	R5,#RSXDIC	;ARE WE BACK AT THE START??		;015
	BLOS	40$		; IF WE ARE LOWER, THEN THERE IS NONE	;015
	DEC	R5		;BACK UP OVER THE DPB LENGTH
	CMPB	R2,-(R5)	;CHECK FOR A MATCH ON DIC
	BHI	30$		;LIST IS ORDERED BACKWARDS		;015
	BNE	40$		;ERROR IF NOT IN THE TABLE

GLOBAL	<SYSTAK>

;	CHECK FOR VALID DIRECTIVE PARAMETER BLOCK LENGTH

	CMP	R2,(R5)+	;TOTAL MATCH ON DPB/DIC?
	BNE	40$		;NOPE, AN ERROR
	MOV	JOBWRK,R3	;GET JOB'S WORK BLOCK POINTER
	MOVB	-(R5),R4	;GET THE DPB LENGTH
	BR	60$		; AND ENTER THE MOVE LOOP

40$:	XITERR	IE.SDP		;EXIT WITH ILLEGAL DPB/DIC

;	COPY DPB INTO WORK BLOCK

50$:	CALL	PEKADP		;GET NEXT DPB WORD
	MOV	R2,(R3)+	;FILL WORK BLOCK WITH IT
	BIT	R3,#40-1	;END OF WORK BLOCK?
	BEQ	70$		;YES, DON'T MOVE ANY MORE
60$:	SOB	R4,50$		;ELSE LOOP FOR WHOLE DPB...

;	DISPATCH BY DIRECTIVE CODE

70$:	MOV	JOBF,R1		;GET POINTER TO JOB DATA BLOCK @ JDFLG
	MOV	JOBWRK,R3	;GET JOB'S WORK BLOCK POINTER AGAIN
	MOV	RSXTBL-<RSXDIC+1>(R5),-(SP) ;SET DISPATCH FOR THE DIC
	.BR	STKCHK		;CHECK STACK, THEN DISPATCH, THEN EXIT TO "RTI3"

.DSABL	LSB

;+
; AT RSX DIRECTIVE DISPATCH TIME:
;
;	R.MON1 = ORIGINAL DPB +2 POINTER
;	R1 -> JDB @ JDFLG
;	R3 -> WRK FILLED WITH DPB STARTING AT DPB+2
;	SP -> "RTI3",R0,R1,R2,R3,R4,R5,PC,PS,...
;					     !- "SYSTAK"
;	JOB IS "JOB"
;	JOB'S 1ST 4K IS MAPPED THROUGH PAR6
;-

.SBTTL	GENERAL SUBROUTINES

;+
; STKCHK - CHECK FOR USER SP STACK ERROR(S).
;
;	CALL	STKCHK
;
;	C=1 ALWAYS
;-

.ENABL	LSB

STKCHK:	TST	@#NSTORG+140000	;IS THE GUARD WORD CLOBBERED?
	BEQ	20$		;NOPE, O.K., RETURN
	SETERR	B.STAK,R4,WORD	;YEP, SET THE SP STACK ERROR
	JMP	RSXDIE		; AND GO DIE (R4 = "B.STAK")

;+
; XITERR - EXIT DIRECTIVE WITH FIXED ERROR CODE.
;
;	XITERR	<CODE>
;-

XITERR:	MAP	@#KISAR5,APR=5,DATA ;Be sure our D-space is mapped	;030
	MAP	@UDPAR0,APR=6,DATA ;And be sure user's first 4K is mapped ;030
	MOV	(R5)+,R0	;GET THE ERROR CODE
10$:	MOV	R0,@#$DSW+140000 ;SET THE RETURN ERROR CODE IN DSW
	INC	SYSTAK-<1*2>	;SET C-BIT FOR RETURN
.ASSUME	C	EQ	1
	MOV	#SYSTAK-<9.*2>,SP ;ENSURE A CLEAN STACK
20$:	SEC			;SET C=1
	RETURN			; AND EXIT

GLOBAL	<SYSTAK,UDPAR0>							;030

;+
; CKPLAS - CHECK FOR ERROR, GET BACK POINTERS.
;
;	R0 -> USER'S FIRQB
;
;	CALL	CKPLAS,R5,<CODE TABLE>
;
;		CODE TABLE:	.BYTE	<RSX ERROR>,<RSTS/E ERROR>
;				 ...
;				.BYTE	<DEFAULT RSX ERROR>,0
;
;	R1 -> USER'S RDB/WDB
;	R4 -> USER'S FIRQB @ FQPPN
;-

CKPLAS:	MOV	(R5)+,R4	;GET ERROR CODE TABLE POINTER
	MOVB	(R0),R1		;GET THE ERROR CODE ITSELF
	BNE	30$		;THERE IS AN ERROR, DECODE IT
	MOV	@#R.MON1+140000,R1 ;ELSE GET BACK POINTER TO RDB/WDB
	MOV	#FIRQB+FQPPN+140000,R4 ;GET POINTER TO RETURNED RESULTS
	RETURN	R5		;EXIT

30$:	MOVB	(R4)+,R0	;GET THE RSX ERROR
	TSTB	(R4)		;END OF TABLE?
	BEQ	10$		;YES, CALL IT A MATCH
	CMPB	R1,(R4)+	;NO, REALLY A MATCH?
	BEQ	10$		;YES
	BR	30$		;NOT YET, KEEP CHECKING...

.DSABL	LSB

;+
; PLAS - SET UP FOR A .PLAS CALL.
; PLASX - SPECIAL SET UP FOR A .PLAS CALL.
;
;	R1 -> RDB/WDB		(FOR "PLASX" ONLY)
;	R3 -> ->RDB/WDB		(FOR "PLAS" ONLY)
;
;	CALL	PLAS,R5,<.PLAS FUNCTION>
;	CALL	PLASX,R5,<.PLAS FUNCTION>
;
;	R0 =  UNDEFINED
;	R1 =  UNDEFINED
;	R2 =  UNDEFINED
;	R3 =  UNDEFINED
;	R4 =  UNDEFINED
;
;	R.MON1 = ->RDB/WDB
;-

PLAS:	MOV	(R3),R1		;GET POINTER TO RDB/WDB
PLASX:	MOV	R1,@#R.MON1+140000 ; AND SAVE IT
	MOV	#FIRQB+FQERNO+140000,R3 ;GET USER FIRQB POINTER
	MOV	(R5)+,(R3)+	;SET THE .PLAS FUNCTION CODE
	MOV	#8.,R4		;WE'LL COPY 8. MORE WORDS
10$:	CALL	PEKADP		;GET A USER WORD
	MOV	R2,(R3)+	; AND SET IT
	SOB	R4,10$		;  THEN LOOP...
	RETURN	R5		;EXIT

;+
; MAPLUN - GET LUN TABLE POINTER.
;
;	R3 -> LUN
;
;	CALL	MAPLUN
;
;	R3 =  R3 +2 (I.E., R3 'POPPED')
;	R4 -> LUN TABLE ENTRY
;-

MAPLUN:	MOV	(R3)+,R4	;GET LUN NUMBER
	CMP	R4,#15.		;CHECK LUN VALUE
	BHI	10$		;TOO BIG, ERROR
	CMP	R4,@#R.NLUN+140000 ;DOES TASK HAVE THIS MANY LUNS?
	BHI	10$		;NO NO
	ASH	#3,R4		;MULTIPLY LUN BY 8.
	ADD	#R.LUNS+140000,R4 ;ADD TABLE BASE
	RETURN			;RETURN

10$:	XITERR	IE.ILU		;ILLEGAL LUN ERROR

;+
; SETXRB - SET UP USER'S XRB FOR A MESSAGE.
;
;	CALL	SETXRB
;
;	R1 -> MESSAGE BUFFER
;	R2 -> XRB (DON'T TOUCH!)
;-

SETXRB:	MOV	#XRB+XRBSIZ+140000,R2 ;SET UP THE XRB FOR A MESSAGE
	MOV	#7000,-(R2)	;XRMOD = FULL RSX MODE
	CLR	-(R2)		;XRTIME = 0
	CLR	-(R2)		;XRBLK = 0
	CLR	-(R2)		;XRCI, XRBLKM = 0
	MOV	#NSTORG+3+140000,-(R2) ;XRLOC -> MESSAGE BUFFER (@ ODD BYTE)
	MOV	(R2),R1		; AND GET IT IN A REGISTER ALSO
	MOVB	#012,(R1)+	;SET THAT LEADING <LF> FOR RSX STYLE I/O
	MOV	R0,-(SP)	;SAVE R0
	CALL	GETERM		;GET TERMINAL DDB, CANCEL ANY CTRL/O
	BNE	10$		;TERMINAL NOT OWNED??
	CMPB	DDHORZ(R0),DDHORC(R0) ;ELSE IS THE CARRIAGE RESTORED?
	BEQ	20$		;YEP, ALL SET
10$:	MOV	(PC)+,(R1)+	;DO EXTRA <CR><LF> TO RESTORE CARRIAGE
	 .BYTE	015,012
20$:	MOV	(SP)+,R0	;RESTORE R0
	RETURN			;NOW BACK

;+
; SETMSG - SET UP USER'S XRB FOR AN ERROR MESSAGE.
;
;	R0 -> USER'S FIRQB WITH MESSAGE @ FQERNO, .ASCIZ -OR- 28. BYTES
;
;	CALL	SETMSG
;
;	R0 =  UNDEFINED
;	R1 =  UNDEFINED
;	R2 -> XRB
;-

SETMSG:	CALL	SETXRB		;SET UP FOR A MESSAGE
	CMP	(R0)+,(R0)+	;POINT TO THE MESSAGE TEXT @ FQERNO
.ASSUME	FQERNO	EQ	4
	CLRB	28.(R0)		; AND ENSURE TERMINATION
	.BR	FINXRB		;FINISH UP THE XRB SET UP & RETURN

;+
; FINXRB - FINISH UP XRB SET UP FOR MESSAGE, CANCEL CTRL/O.
;
;	R0 -> MESSAGE TEXT (.ASCIZ)
;	R1 -> MESSAGE BUFFER
;	R2 -> XRB (FROM "SETXRB")
;
;	CALL	FINXRB
;
;	R0 =  UNDEFINED
;	R1 =  UNDEFINED
;	R2 -> XRB
;-

FINXRB:	MOVB	(R0)+,(R1)+	;COPY REST OF MESSAGE
	BNE	FINXRB		; UNTIL ITS END...
	DEC	R1		;CORRECT FOR THAT ENDING NULL BYTE
UPDXRB:	SUB	(R2),R1		;FIND TOTAL MESSAGE LENGTH
	SUB	#140000,(R2)	;XRLOC = REAL MESSAGE START
	MOV	R1,-(R2)	;XRBC = LENGTH
	MOV	R1,-(R2)	;XRLEN = LENGTH
	.BR	GETERM		;CANCEL ANY CTRL/O AND EXIT

;+
; GETERM - GET TERMINAL DDB POINTER, CANCEL CONTROL/O.
;
;	CALL	GETERM
;
;	R0 -> TERMINAL DDB
;
;	IF Z=1 THEN TERMINAL IS OWNED.
;	IF Z=0 THEN TERMINAL NOT OWNED.
;-

GETERM:	MAP	FIPPOL		;Set up FIP pool mapping		;030
	MOV	@JOBDA,R0	;GET JOB'S IOB POINTER
.ASSUME	JDIOB	EQ	0
	MOV	(R0),R0		;NOW GET CH #0 DDB POINTER
	MAP	@#KISAR5,APR=5,DATA ;Restore APR5 mapping		;030
	MAP	@UDPAR0,APR=6,DATA ;And APR6 mapping			;030
	CMPB	JOB,DDJBNO(R0)	;DOES JOB OWN TERMINAL?
	BNE	10$		;NO, EXIT Z=0
	BIC	#DDSTAT,(R0)	;YES
	SEZ			;ENSURE Z=1 ON EXIT
10$:	RETURN			;EXIT

GLOBAL	<UDPAR0>							;030

.SBTTL	QIO$	QUEUE I/O REQUEST

	DICDEF	1.,12.

;	R3 -> FUN,LUN,PRI/EFM,->ISB,->AST,->BUF,CNT,VFC,BLK(M),BLK(L),?
;		ISB: CODE,CNT

.SBTTL	QIOW$	QUEUE I/O REQUEST AND WAIT

	DICDEF	3.,12.

;	R3 -> FUN,LUN,PRI/EFM,->ISB,->AST,->BUF,CNT,VFC,BLK(M),BLK(L),?
;		ISB: CODE,CNT

	MOV	#XRB+XRBSIZ+140000,R5 ;FILL IN USER XRB BACKWARDS
	CLR	-(R5)		;CLEAR MODIFIER WORD
	CLR	-(R5)		; AND TERMINAL WAIT TIME
	CLR	-(R5)		;  AND BLOCK NUMBER LSB
	MOV	(R3)+,-(SP)	;SAVE FUNCTION CODE
	MOV	(R3),-(R5)	;SET CHANNEL = LUN
	ASL	(R5)		;CHANNEL TIMES 2
	CALL	MAPLUN		;GET LUN TABLE POINTER
	CMP	(R4),#"TI	;IS LUN ASSIGNED TO "TI:"?
	BNE	10$		;NOPE
	CLR	(R5)		;IF SO USE CHANNEL 0
	MOV	#R.LUNS+140000,R4 ;RESET POINTER TO LUN 0
10$:	CMP	(R4)+,(R4)+	;POINT TO DEVICE CHARACTERISTICS
	TST	(R3)+		;SKIP PRI/EFN
	MOV	(R3)+,R1	;GET ISB
	MOV	R1,@#R.MON1+140000 ;SET ISB (IF ANY) FOR LATER
	BEQ	20$		;NONE
	CLR	R0		;SET DATA TO ZERO
	CALL	POKADP		;POKE 1ST WORD TO ZERO
	;CLR	R0		;SET DATA TO ZERO
	CALL	POKADP		;POKE 2ND WORD TO ZERO

20$:	TST	(R3)+		;SKIP AST
	MOV	(R3)+,-(R5)	;BUFFER ADDRESS
	MOV	(R3),-(R5)	;BYTES TO TRANSFER
	MOV	(R3)+,-(R5)	;BUFFER SIZE
	MOV	4(R3),XRBLK(R5)	;VIRTUAL BLOCK NUMBER
	MOVB	2(R3),XRBLKM(R5) ;SET HI BYTE OF BLOCK NUMBER
	MOV	(SP)+,R2	;GET BACK THE FUNCTION CODE
	MOV	#50$,R1		;GET QIO FUNCTION TABLE POINTER
30$:	MOV	(R1)+,R0	;GET NEXT DISPATCH ADDRESS
	BEQ	40$		;NONE, NOT LEGAL, SO SAY SO
	CMP	R2,(R1)+	;A MATCH?
	BNE	30$		;NOPE, KEEP CHECKING...
	JMP	(R0)		;YEP, DISPATCH

40$:	XITERR	IE.IFC		;EXIT WITH ILLEGAL FUNCTION

50$:	.WORD	QIOLOV,IO.LOV	;LOAD I-space OVERLAY (=> io.ral too, egad!)
	.WORD	QIOWVB,IO.WVB	;WRITE VIRTUAL BLOCK
	.WORD	QIORVB,IO.RVB	;READ VIRTUAL BLOCK
	.WORD	QIOWLB,IO.WLB	;WRITE LOGICAL BLOCK
	.WORD	QIORLB,IO.RLB	;READ LOGICAL BLOCK
	.WORD	QIOATT,IO.ATT	;ATTACH
	.WORD	QIODET,IO.DET	;DETACH
	.WORD	QIOWAL,IO.WAL	;WRITE PASS ALL
	.WORD	QIOLDO,IO.LDO	;Load D-space overlay			;024
	.WORD	0		;END OF TABLE

.ENABL	LSB

;	ATTACH

QIOATT:	CALL	10$,R3,OPNFQ*400 ;DO AN OPEN

;	DETACH

QIODET:	CALL	10$,R3,CLSFQ*400 ;DO A CLOSE

10$:	MOV	R5,R1		;POINT TO END OF USER'S FIRQB
.ASSUME	FIRQB+FQBSIZ EQ XRB
	MOV	#FQBSIZ/2,R0	;SET THE FIRQB'S SIZE IN WORDS
20$:	CLR	-(R1)		;CLEAR
	SOB	R0,20$		; WHOLE THING
	CLR	(R1)+		;CLEAR ERROR CODE AND SKIP TO FQFUN/FQJOB
	MOV	(R3),(R1)+	;JUNK FQJOB, BUT SET FUNCTION @ FQFUN
.ASSUME	FQJOB	EQ	2
.ASSUME	FQFUN	EQ	FQJOB+1
	MOV	(SP)+,R3	;RESTORE R3
	MOVB	XRCI(R5),(R1)	;GET CHANNEL NUMBER*2 FROM XRB
.ASSUME	FQFIL	EQ	FQJOB+2
	BEQ	40$		;IT'S CH# 0, SAY DONE O.K. (ERROR CODE =0)
	ADD	#FQDEVN-FQFIL,R1 ;POINT TO DEVICE UNIT NUMBER
	MOV	-(R4),(R1)	;COPY UNIT NUMBER
	ADD	(PC)+,(R1)	;SET UNIT NUMBER FLAG
	 .BYTE	0,-1
	BCC	30$		;BRANCH IF UNIT NUMBER REAL
	CLR	(R1)		;CLEAR IF NO UNIT NUMBER
30$:	MOV	-(R4),-(R1)	;COPY DEVICE NAME
.ASSUME	FQDEV	EQ	FQDEVN-2
	DOCALL	CALFIP		;CALL FIP
40$:	CLR	XRBC(R5)	;NO BYTE COUNT FOR THIS OPERATION...
	.BR	QIOSTS		;GO SET I/O STATUS AND EXIT

.DSABL	LSB

;	SET I/O STATUS IN STATUS BLOCK

QIOSTS:	MOV	#IS.SUC,-(SP)	;ASSUME SUCCESS
	MOVB	@#FIRQB+140000,R2 ;GET I/O STATUS/ERROR CODE
	BEQ	20$		;NO ERROR, GO SAY OK
	MOV	#30$,R1		;POINT TO ERROR TABLE
10$:	MOVB	(R1)+,(SP)	;ASSUME THIS ERROR
	TSTB	(R1)		;END OF TABLE?
	BEQ	20$		;YES, USE LAST ERROR CODE IN TABLE
	CMPB	R2,(R1)+	;IS IT THIS ONE?
	BNE	10$		;NO, GO TRY NEXT ONE...
20$:	MOV	(SP)+,R0	;GET THE MAPPED ERROR CODE OR SUCCESS
	MOV	@#R.MON1+140000,R1 ;GET I/O STATUS BLOCK ADDRESS
	BEQ	QIORET		;NONE PROVIDED
	CALL	POKADP		;ONE, SET STATUS AT ISB+0
	MOV	XRBC(R5),R0	;GET # OF CHARACTERS TRANSFERED
	CALLR	POKADP		; AND SET IT AT ISB+2 AND EXIT

30$:	.BYTE	IE.EOF,EOF
	.BYTE	IE.DNR,HNGDEV
	.BYTE	IE.RSU,NOTAVL
	.BYTE	IE.VER,DATERR
	.BYTE	IE.EOT,NOROOM
	.BYTE	IE.NLN,NOTOPN
	.BYTE	IE.PRI,PRVIOL
	.BYTE	IE.DAA,NOTCLS
	.BYTE	IE.BAD,0	;END OF TABLE

GLOBAL	<EOF,HNGDEV,NOTAVL,DATERR,NOROOM,NOTOPN,PRVIOL,NOTCLS>

.ENABL	LSB

;	Load I-space overlay

QIOLOV:	BIT	#FD.TTY,(R4)	;IS IT TERMINAL? (MAYBE IO.RAL?)
	BNE	QIORAL		;YUP, GO DO IT!
	MOV	#15.*2+<DSKHND*400>,XRCI(R5) ;Set channel #/handler	;024
	MOV	#-2,(R5)	;And set the function as I-space read	;024
	ADD	@#R.HDRZ+140000,XRBLK(R5) ;Advance past header blocks	;024
	DOCALL	.SPEC		;Go and load that overlay		;024
	BR	QIOSTS		;And get out posting completion status	;024

; Load D-space overlay

QIOLDO:	MOVB	#15.*2,XRCI(R5)	;TASK FILE IS ON CHANNEL 15.		;024
	ADD	@#R.HDRZ+140000,XRBLK(R5) ;Advance past header blocks	;024
	BR	10$		;GO DO THAT READ			;024

;	READ

QIORAL:	CALL	GETERM		;GET TERMINAL DDB POINTER, CHECK FOR OWNED
	BNE	QIORVB		;NOT OWNED...
	BIS	#TTDDT,DDFLAG(R0) ;OWNED, SET THE DDT SUB-MODE BIT
QIORLB:
QIORVB:	BIT	#FD.TTY,(R4)	;A TERMINAL?
	BEQ	10$		;NO
	BIS	#3000,XRMOD(R5)	;YES, USE RSX MODE I/O
10$:	CLR	XRBC(R5)	;CLEAR BYTE COUNT
	DOCALL	.READ		;READ A BLOCK/LINE
15$:	CALL	QIOSTS		;PUT I/O STATUS IN STATUS BLOCK
	BIT	#3000,XRMOD(R5)	;INPUT FROM TERMINAL (RSX MODE)?
	BEQ	QIORET		;EXIT IF NOT
	MOV	@#R.MON1+140000,R1 ;STATUS BLOCK EXIST?
	BEQ	QIORET		;NO
	MOV	XRCI(R5),R0	;GET DELIMITER (IN HIGH BYTE)
.ASSUME	XRBLKM	EQ XRCI+1
	BIC	#377,R0		;MASK OFF CHANNEL #*2
	BEQ	QIORET		;MUST BE BUFFER FULL OR CTRL/Z
	INCB	R0		;INDICATE SUCCESS (IN LOW BYTE)
	CALL	POKADP		; AND SET AT ISB+0
QIORET:	RETURN			;EXIT FROM QIO

.DSABL	LSB

.ENABL	LSB

;	WRITE

QIOWAL:	BIS	#11000,XRMOD(R5) ;SET BINARY OUTPUT AND RSX MODES
QIOWLB:
QIOWVB:	MOV	(R4),R4		;GET THE DEVICE CHARACTERISTICS BITS
	SWAB	R4		;PUT BITS WE WANT IN THE HIGH BYTE
	CLRB	R4		;CLEAR THE LOW BYTE
	BISB	(R3),R4		; AND .OR. IN THE FORMS CONTROL CHARACTER
	MOV	R4,@#PMDSP+140000 ;NOW SAVE THAT COMBINED VALUE FOR LATER
	BIT	R4,#FD.CCL*400	;CARRIAGE CONTROL DEVICE?
	BEQ	40$		;NO, JUST PLAIN WRITE
	BIS	#1000,XRMOD(R5)	;SET RSX MODE TERMINAL OUTPUT
	TSTB	R4		;ANY FORMS CONTROL TO BE DONE?
	BEQ	40$		;NOPE
	CMPB	R4,#'+		;OVERPRINTING?
	BEQ	30$		;YES, WRITE THE RECORD OUT NOW
	BIS	#3000,XRMOD(R5)	;MARK AS CANCEL LEADING <LF> IF NEEDED
	MOV	#1,(R5)		;BUFFER LENGTH TO 1 BYTE
	MOV	#014,R2		;SET UP TO OUTPUT FORM FEED
	CMPB	R4,#'1		;IS CONTROL CHARACTER PAGE EJECT?
	BEQ	10$		;YES, DO IT
	MOV	(PC)+,R2	;NO, CHANGE TO LINE FEED (2 OF THEM)
	 .BYTE	012,012
	CMPB	R4,#'0		;IS CONTROL CHARACTER DOUBLE SPACE?
	BNE	10$		;NO, ASSUME SINGLE SPACE
	INC	(R5)		;TWO LINE FEEDS
10$:	BIT	R4,#FD.TTY*400	;OUTPUT TO TERMINAL?
	BNE	20$		;YES
	BIC	#17000,XRMOD(R5) ;NO, CLEAR MODIFIER(S)
20$:	MOV	#PMDXRB+140000,R1 ;GET POINTER TO OUR SAVE AREA
	MOV	-(R3),(R1)+	;SAVE ORIGINAL BYTE COUNT @ PMDXRB+0
	MOV	-(R3),(R1)+	; AND ORIGINAL BUFFER ADDRESS @ PMDXRB+2
	MOV	R2,(R1)		;SET THE OUTPUT CHARACTER(S) @ PMDXRB+4
	MOV	(R5)+,(R5)+	;FILL THE BUFFER COUNT
	MOV	#PMDXRB+4,(R5)	;SET USER BUFFER ADDRESS
	DOCALL	.WRITE		;OUTPUT CHARACTER(S) ON THE CHANNEL

	MOV	#PMDSP+140000,R1 ;GET POINTER TO OUR SAVE AREA
	MOV	(R1)+,R4	;RESTORE THE CHARACTERISTICS/FORM CONTROL
	MOV	(R1)+,(R5)	;RESTORE THE ORIGINAL BYTE COUNT
.ASSUME	PMDXRB	EQ	PMDSP+2
	MOV	(R5)+,(R5)+	;PUT ORIGINAL COUNT IN BOTH LENGTH & COUNT
	MOV	(R1)+,(R5)	;RESTORE ORIGINAL USER BUFFER ADDRESS
	CMP	-(R5),-(R5)	;NOW BACK TO TOP OF USER'S XRB
	BIC	#2000,XRMOD(R5)	;CLEAR RSX PREFIXING
	CMPB	R4,#'$		;PROMPT MODE?
	BEQ	40$		;YES, NO TRAILING <CR>
30$:	BIS	#5000,XRMOD(R5)	;INDICATE TRAILING <CR> NEEDED
40$:	BIT	R4,#FD.TTY*400	;TERMINAL?
	BNE	50$		;YES
	BIC	#17000,XRMOD(R5) ;NO, CLEAR MODIFIER(S)
50$:	DOCALL	.WRITE		;DO THE WRITE
	CALL	QIOSTS		;FILL IN THE STATUS BLOCK IF ANY
	MOV	@#PMDSP+140000,R4 ;RESTORE CHARACTERISTICS/FORM CONTROL
	BIT	R4,#FD.CCL*400	;CARRIAGE CONTROL?
	BEQ	60$		;NO, EXIT
	BIT	R4,#FD.TTY*400	;TERMINAL?
	BNE	60$		;YES, EXIT ALSO
	TSTB	R4		;ANY FORMS CONTROL?
	BEQ	60$		;NONE, EXIT
	CMPB	R4,#'$		;PROMPTING?
	BEQ	60$		;YES, NO TRAILING <CR>
	MOV	#1,(R5)		;SET BUFFER LENGTH TO ONE
	MOV	(R5)+,(R5)+	;SET OUTPUT COUNT
	MOV	#PMDSP,(R5)	;SET USER BUFFER ADDRESS
	MOV	#015,@#PMDSP+140000 ; AND SET USER DATA (A <CR>)
				;SAME CH#, BLK, TIME, MODIFIER...
	DOCALL	.WRITE		;OUTPUT <CR> ON THE CHANNEL
60$:	RETURN			;EXIT

.DSABL	LSB

.SBTTL	ALUN$	ASSIGN LUN

	DICDEF	7.,4.

;	R3 -> LUN,NAME,UNIT

	TST	(R3)		;GET LUN VALUE
	BEQ	10$		;CAN'T ASSIGN LUN 0, BUT SAY O.K.	;021
	CALL	MAPLUN		;POINT TO RIGHT LUN IN TABLE
	MOV	R4,R5		;MOVE LUN TABLE POINTER TO HERE
	CALL	ALUN		;Now assign the LUN			;021
	BCC	10$		;Ok, that's good			;021
	XITERR	IE.IDU		;Report invalid device/unit		;021
10$:	RETURN			;All done now				;021

;+
; ALUN - Assign a LUN
;
;	R3 -> Name, unit (mapped)
;	R5 -> Lun table slot (mapped)
;
;	CALL	ALUN
;
;	C = 0 if no error
;	C = 1 if error
;-

ALUN:	MOV	(R3)+,R2	;GET DEVICE NAME			;021
	MOV	(R3),R3		; AND UNIT NUMBER
	CALL	CVTLOG		;CHECK FOR LOGICALS
	MOV	#FIRQB+FQDEV+140000,R4 ;POINT TO DEVICE NAME SLOT IN FIRQB
	MOV	R2,(R4)+	;PUT DEVICE NAME INTO FIRQB @ FQDEV
	MOV	R3,(R4)		;PUT DEVICE UNIT INTO FIRQB @ FQDEVN
	ADD	(PC)+,(R4)	;SET UNIT NUMBER FLAG
	 .BYTE	0,-1
	BCC	30$		;WAS 0, NOW IS -1
	CLR	(R4)		;NOT 0, NOW WHOLE THING IS 0
30$:	SUB	#FQDEVN,R4	;BACK TO TOP OF FIRQB

	CALLX	GUNSUB,R5	;CHECK OUT THE DEVICE/UNIT
	  BR	130$		;INVALID, GIVE AN ERROR
	MOV	@DEVPTR(R0),R1	;GET DDB POINTER FOR UNIT 0
	CLR	R2		;NOW GUESS AT DISK (INDEX = 0)
	CMP	R0,#DEVOKB	;REALLY DISK?
	BLT	40$		;YES
	MOVB	(R1),R2		;NO, GET REAL DRIVER INDEX
40$:	MOV	FQDEV(R4),(R5)+	;PUT DEVICE NAME IN LUN TABLE
	MOV	FQDEVN(R4),(R5)+ ;PUT UNIT NUMBER/FLAG IN LUN TABLE
	INCB	-1(R5)		;CLEAR THE UNIT NUMBER FLAG
	BEQ	50$		;FLAG WAS -1; NOW IS 0
	MOV	#-1,-2(R5)	;FLAG NOT -1; WHOLE WORD NOW IS -1

;	TRANSLATE DEVICE CHARACTERISTICS

50$:	MOV	$FLGTBL(R2),R0	;GET THE GENERIC FLAGS
	CLR	R3		;INIT DEVICE CHARACTERISTICS
	BIT	#FLGFRC,R0	;BYTE ORIENTED?
	BEQ	60$		;NO
	INC	R3		;YES, DEFINE AS RECORD ORIENTED
.ASSUME	FD.REC	EQ	1
60$:	BIT	#FLGPOS,R0	;DEVICE KEEPS OWN HORIZONTAL POSITION?
	BEQ	70$		;NO
	BIS	#FD.CCL,R3	;YES, CALL THAT CARRIAGE CONTROL
70$:	BIT	#FLGKB,R0	;A TERMINAL DEVICE?
	BEQ	80$		;NO
	BIS	#FD.TTY!FD.CCL,R3 ;SO BE IT, ALSO SET CARRIAGE CONTROL BIT
80$:	BIT	#DDNFS,R0	;DEVICE FILE STRUCTURED?
	BNE	100$		;NO
	TST	R0		;YES, IS IT ALSO RANDOM ACCESS?
	BMI	90$		;F/S & RANDOM, SAY DIRECTORY DEVICE
.ASSUME	FLGRND	EQ	100000
	BIS	#FD.SDI,R3	;F/S, BUT NOT RANDOM, SINGLE DIRECTORY
	BR	100$		; AND CONTINUE

90$:	BIS	#FD.DIR,R3	;SAY DIRECTORY DEVICE
100$:	TST	R0		;A RANDOM DEVICE?
	BMI	110$		;YES
.ASSUME	FLGRND	EQ	100000
	BIT	#FD.REC,R3	;IF NOT RANDOM, IS IT RECORD ORIENTED?
	BNE	110$		;YES
	BIS	#FD.SQD,R3	;SEQUENTIAL IF NOT RANDOM & NOT RECORD
110$:	MOV	R3,(R5)+	;STORE CHARACTERISTICS IN THE LUN TABLE
	MOV	$BUFTBL(R2),(R5)+ ;STORE THE DEFAULT BUFFER LENGTH
	TST	(PC)+		;Clear carry for success		;021
130$:	SEC			;Set carry for failure			;021
	RETURN			;DONE					;021

GLOBAL	<DEVPTR,DEVOKB,$FLGTBL,$BUFTBL>

;+
; CVTLOG - TRANSLATE A LOGICAL NAME; APPLY ANY DEFAULT.
;
;	R2 =  DEVICE NAME
;	R3 =  DEVICE UNIT
;
;	CALL	CVTLOG
;
;	R2 =  DEVICE NAME
;	R3 =  DEVICE UNIT
;-

CVTLOG:	REGSCR			;Save all registers			;021
	MAP	PUSH,APR=6,DATA	;SAVE APR6 MAPPING			;022
	CMP	R2,#"OV		;Trying to translate OV?		;021
	BEQ	10$		;Yes, so fall back on SY:		;021
	CMP	R2,#"LB		;How about translating SY?		;021
	BEQ	10$		;Yes, that's SY: also			;021
	CMP	R2,#"CL		;How about CL?				;021
	BEQ	15$		;Yes, set up for TT: fallback		;027
	CMP	R2,#"TI		;Is it TI?				;021
	BEQ	20$		;Yes, that never has a unit number	;021
	CMP	R2,#"SY		;Is it SY?				;021
	BNE	30$		;No, so leave it as it is		;021
10$:	MOV	#"SY,TOS.R2+2(SP) ;Be sure to fall back to SY:		;021
	BR	20$		;And join up with unit number forgetting ;027

15$:	MOV	#"TT,TOS.R2+2(SP) ;Be sure to fall back to TT:		;027
20$:	MOV	#-1,R3		;Forget the unit number			;021
	MOV	R3,TOS.R3+2(SP)	;Be sure fall-back unit is correct	;021
30$:	SUB	#7*2,SP		;Make room for three rad-50 words	;039
	MOV	SP,R4		;R4 -> Target logical area		;021
	CLR	-(SP)		;Make room for 2 bytes for logical	;021
	CLR	-(SP)		;Now we have room for four bytes	;021
	CLR	-(SP)		;Now we have room for six bytes		;021
	CLR	-(SP)		;Now we have room for eight bytes	;021
	MOV	SP,R1		;Now R1 -> Logical name work area + 2	;021
	MOV	R2,-(SP)	;Set the device name			;021
	CMP	R3,#-1		;Is there a unit number?		;021
	BEQ	40$		;No, not this time			;021
	CALL	120$,R5,<10000.,1000.,100.,10.> ;Do the divides		;021
40$:	MOV	SP,R1		;R1 -> ASCII characters to pack		;021
50$:	CALLMI	LOGR50,EMTAP5	;Convert the logical to RAD-50		;021
	MOVB	1(SP),R3	;Pick up second character of logical	;021
	ROL	R2		;Save error indication			;021
	ADD	#10.,SP		;Dump the ASCII version on the stack	;021
	ROR	R2		;Restore error condition		;021
	BCS	110$		;Now exit if this isn't valid		;021
	TST	4(SP)		;Is this a nine-character logical?	;021
	BNE	80$		;Yes, so don't try user logicals	;021
	CMPB	R3,#'$		;Is the second character a '$'?		;021
	BEQ	80$		;Yes, so don't try user logicals	;021
	MOV	#USRLOG+140000,R2 ;FIRST START WITH USER LOGICALS	;021
60$:	CMP	(R2)+,(SP)	;First part match?			;021
	BNE	70$		;No, not this time			;021
	CMP	(R2),2(SP)	;How about second part?			;021
	BEQ	90$		;Yes, we found it			;021
70$:	ADD	#6,R2		;Advance to next logical		;021
	CMP	R2,#NSTORG+140000 ;End of table?			;021
	BLO	60$		;No, so loop for the whole thing	;021
80$:	MOV	SP,R5		;MATCH CONVENTIONS FOR SEARCH		;021
	MOV	#<LG$USR!LG$SYS>,R0	;set status			;039
	MOVB	JOB,R3		;job number for search ID		;040
	CALLMI	SEARCH,EMTAP5	;SEARCH LOGICALS			;022
	BCS	110$		;Not found, forget translation		;021
	MOV	R3,R2		;Point to the right place		;041
90$:	TST	(R2)+		;Now advance past third part of name	;021
;.ASSUME SL$DEV	EQ	6						;021
	MOV	(R2)+,TOS.R2+2+14.(SP) ;Save the device name		;039
	MOV	(R2),R3		;R3 = Unit number/flag			;021
	ADD	(PC)+,R3	;Check the unit number flag
	 .BYTE	0,1
	BCS	100$		;WAS -1, NOW 0, EXIT
	MOV	#-1,R3		;Unit number wasn't real, so say no unit ;021
100$:	MOV	R3,TOS.R3+2+14.(SP) ;Save the unit number		;039
110$:	ADD	#7*2,SP		;Dump the RAD50 work area		;039
	MAP	POP,APR=6,DATA	;Restore the APR6 mapping		;022
	RETURN			;And now we're done

120$:	CLR	R0		;Indicate zero suppression		;021
130$:	CLR	R2		;Clear MSB for divide			;021
	DIV	(R5),R2		;Do a divide				;021
	CMP	R0,R2		;Do we need to supress this?		;021
	BEQ	140$		;Yes, we sure do			;021
	DEC	R0		;No, be sure we don't supress anymore	;021
	ADD	#60,R2		;Convert to ASCII			;023
	MOVB	R2,(R1)+	;Store the digit			;021
140$:	CMP	(R5)+,#10.	;More to do?				;021
	BNE	130$		;Yes, so do it				;021
	ADD	#60,R3		;Convert remainder to ASCII		;023
	MOVB	R3,(R1)+	;Store the digit			;021
	RETURN	R5		;And now we're done			;021

.SBTTL	ABRT$	ABORT TASK

	DICDEF	83.,3.

;	R3 -> NAME-1,NAME-2

	MOV	#4,(R3)		;ABORT SAME AS EXIT WITH SEVERE ERROR

.SBTTL	EXST$	EXIT WITH STATUS

	DICDEF	29.,2.

;	R3 -> STATUS

	MOV	(R3),R3		;GET EXIT STATUS
	BIC	#^C<7>,R3	;MASK OUT USER BITS
	MAP	JOBJC6,APR=6,DATA ;Map caller's JCR entry		;030
	MOV	JOBJCR,R0	;Get JCR pointer			;030
	MOVB	R3,JCEXST(R0)	;Store current status for DCL		;040
	ASH	#4,R3		;Shift exit status to high nybble	;040
	BISB	R3,JCEXST(R0)	;Store current exit status for job	;040
	MAP	@UDPAR0,APR=6,DATA ;Re-map the first 4K			;030
	.BR	EXIT$		; THEN EXIT


GLOBAL	<UDPAR0>							;030

.SBTTL	EXIT$	TASK EXIT

.ENABL	LSB

	DICDEF	51.,1.

EXIT$:	MOV	#NSTORG+140000,R1 ;GET POINTER TO STACK GUARD WORD
	TST	(R1)+		;IS IT O.K.?
	BEQ	20$		;YES
	MOV	#<NSTORG+2-USRPPN>/2,R0 ;NO, SET TO CLEAR LOGICALS
10$:	CLR	-(R1)		;CLEAR ALL LOGICALS
	SOB	R0,10$		; IN A TIGHT LOOP...
	CLR	@#KEY+140000	;ALSO CLEAR ALL JOB FLAGS
	MOV	#FIRQB+FQFUN+140000,R0 ;POINT TO USER'S FIRQB
	MOVB	#UU.ERR,(R0)+	;SET FUNCTION AS ERROR MESSAGE LOOKUP
	SETERR	FUCORE,(R0)	;SET ERROR AS "LOST -- SORRY"
.ASSUME	FQERNO	EQ	FQFUN+1
	DOCALL	.UUO		;NOW LOOK IT UP
	CALL	SETMSG		;SET UP FOR AN ERROR MESSAGE
	DOCALL	.WRITE		; THEN WRITE THE MESSAGE
20$:	MOV	#-1,@#XRB+140000 ;SET TO CLEAR ALL MONITOR FLAGS
	DOCALL	.CLEAR		; AND GO DO IT
	JMP	EXIKBM		;Now exit to the default KBM		;028

.DSABL	LSB


.SBTTL	GLUN$	GET LUN INFORMATION

	DICDEF	5.,3.

;	R3 -> LUN,->BUF
;		BUF: NAME,?/UNIT,GEN CHAR,DEV CHAR,DEV CHAR,BUF LEN

	CALL	MAPLUN		;POINT TO LUN ENTRY
	TST	(R4)		;HAS LUN BEEN ASSIGNED?
	BEQ	30$		;NO, ERROR
	MOV	(R3),-2(R3)	;PUT USER'S BUFFER AT WRK +0
	MOV	(R4)+,(R3)+	;COPY THE DEVICE NAME
	MOV	(R4)+,R2	;GET THE UNIT NUMBER
	CMP	-4(R4),#"TI	;IS LUN "TI:"?
	BNE	10$		;NO
	MOV	#"TT,-2(R3)	;YES, CHANGE DEVICE NAME TO "TT:"
	MAP	FIPPOL		;Map FIP pool to get the IOB		;030
	MOV	@JDIOB-JDFLG(R1),R2 ;GET POINTER TO JOB'S CONSOLE DDB
	MAP	@#KISAR5,APR=5,DATA ;Restore APR5 mapping		;030
	MAP	@UDPAR0,APR=6,DATA ;And APR6 mapping			;030
	MOVB	DDUNT(R2),R2	;GET THE TERMINAL'S UNIT NUMBER
10$:	MOV	R2,(R3)+	;STORE DEVICE UNIT NUMBER
	MOV	(R4)+,(R3)+	;COPY THE DEVICE CHARACTERISTICS
	CLR	(R3)+		;NEXT WORD TO BE RETURNED WILL BE 0
	CLR	(R3)+		;NOTHING FOR THE 3RD WORD		;029
	MOV	(R4)+,(R3)+	;FINALLY, THE BUFFER SIZE
	BR	MOVUSR		;NOW MOVE DATA TO USER'S BUFFER AND EXIT

30$:	XITERR	IE.ULN		;UNASSIGNED LUN ERROR

GLOBAL	<UDPAR0>

.SBTTL	GTIM$	GET TIME PARAMETERS

	DICDEF	61.,2.

;	R3 -> ->BUF
;		BUF: YEAR-1900,MONTH(1),DAY(1),H(0),M(0),S(0),TICK,TICK.SEC

	TST	(R3)+		;SKIP ADDRESS OF WHERE RESULT IS STORED
	MOV	#DATE,R5	;POINT TO 3 WORDS OF DATE AND TIME
	MOV	(R5)+,R1	;GET YEAR AND JULIAN DATE
	CLR	R0		;CLEAR HIGH ORDER
	DIV	#1000.,R0	; AND DIVIDE FOR YEAR-1970
	MOV	R0,(R3)		;STORE YEAR-1970
	ADD	#70.,(R3)	; AND, THEN, ADD IN THE 1970 BASE
	CLR	R0		;INITIALIZE MONTH INDEX
10$:	INC	R0		;BUMP TO NEXT MONTH
	MOVB	30$-1(R0),R4	;GET NUMBER OF DAYS IN A MONTH
	BIT	#3,(R3)		;IS IT A LEAP YEAR?
	BNE	20$		;NO
	CMP	R4,#29.		;YES - IS THE MONTH FEBRUARY? (BLO=BCS)
	ADC	R4		;IF SO, BUMP LENGTH OF MONTH
20$:	SUB	R4,R1		;SBTRACT OFF MONTH LENGTH
	BHI	10$		;NOT DONE YET
	ADD	R4,R1		;THIS IS THE MONTH - ADD LENGTH BACK IN
	TST	(R3)+		;SKIP YEAR WORD
	MOV	R0,(R3)+	;STORE MONTH NUMBER
	MOV	R1,(R3)+	; AND DAY
	MOV	#60.*24.,R1	;NUMBER OF MINUTES IN A DAY
	SUB	(R5)+,R1	;MINUS REMAINING TIME = TIME OF DAY
	CLR	R0		;CLEAR HIGH ORDER
	DIV	#60.,R0		;DIVIDE TO GET HOUR, MINUTES
	MOV	R0,(R3)+	;STORE HOUR
	MOV	R1,(R3)+	; AND MINUTES
	BIC	#30000,@#PS	;CHANGE PREVIOUS MODE TO KERNEL	SPLC	
	MFPI	$$TICK		; SO WE CAN GET THE $$TICK WORD FROM I SPACE
	MOV	(SP),R0		;GET TICKS PER SECOND
	SWAB	R0		;PUT TICKS PER SECOND IN HIGH BYTE
	ADD	#60.,R0		; THEN PUT SECONDS PER MINUTE IN LOW
	SUB	(R5),R0		;FIND SECONDS(LOW) AND TICKS(HIGH)
	MOVB	R0,(R3)+	;STORE SECONDS
	CLRB	(R3)+		; CLEARING HIGH BYTE
	SWAB	R0		;SWITCH BYTES FOR TICKS
	MOVB	R0,(R3)+	;STORE TICKS
	CLRB	(R3)+		; CLEARING HIGH BYTE
	MOV	(SP)+,(R3)+	;STORE TICKS PER SECOND
	BR	MOVUSR		;NOW MOVE THIS DATA TO THE USER'S BUFFER

30$:	.BYTE	31.,28.,31.,30.,31.,30.,31.,31.,30.,31.,30.,31.

GLOBAL	<$$TICK>

.SBTTL	GPRT$	GET PARTITION PARAMETERS

	DICDEF	65.,4.

;	R3 -> NAME-1,NAME-2,->BUF
;		BUF: BASE/100,SIZE/100,0

	MOV	@#R.TKSZ+140000,R2 ;GET JOB SIZE IN 32-WORD BLOCKS
	TST	(R3)		;IS PARTITION NAME SPECIFIED?
	BEQ	10$		;NO
	MOV	SWPMAX,R2	;YES, GET THE SWAP MAXIMUM
	ASH	#11.-6,R2	; AND MAKE THAT INTO 32-WORD BLOCKS
	CMP	R2,#2000	;Is it 32K?				;011
	BNE	10$		;No					;011
	DEC	R2		;Yes, fake it to be one sliver less	;011
10$:	MOV	4(R3),(R3)+	;SET ADDRESS TO RETURN PARAMETERS
	CLR	(R3)+		;SET THE BASE OF THE PARTITION TO 0
	CLR	@#$DSW+140000	;RETURN PARTITION BASE ADDRESS IN DSW
	MOV	R2,(R3)+	;RETURN PARTITION SIZE
	CLR	(R3)+		;PARTITION FLAGS WORD
	.BR	MOVUSR		;POST DATA TO USER AND EXIT

.SBTTL	MOVE DATA TO USER'S BUFFER

;+
; MOVUSR - MOVE DATA TO USER'S BUFFER.
;
;	R3 -> JUST BEYOND DATA TO MOVE IN WRK
;	WRK +0 -> USER'S BUFFER
;
;	CALL	MOVUSR
;
;	R0 =  UNDEFINED
;	R1 -> JUST BEYOND DATA MOVED TO USER'S BUFFER
;	R2 =  UNDEFINED
;	R3 =  UNDEFINED
;	R4 =  UNDEFINED
;-

MOVUSR:	MOV	JOBWRK,R4	;GET WRK POINTER AGAIN
	MOV	(R4)+,R1	;GET POINTER TO USER'S BUFFER
	SUB	R4,R3		;FIND # BYTES TO MOVE TO USER
	ASR	R3		;NOW # WORDS TO MOVE
	BEQ	20$		;NONE
10$:	MOV	(R4)+,R0	;GET A DATA WORD
	CALL	POKADP		; AND POKE IT TO THE USER
	SOB	R3,10$		;  THEN LOOP...
20$:	RETURN			;DONE, EXIT

GLOBAL	<SWPMAX>

.SBTTL	GTSK$	GET TASK PARAMETERS

	DICDEF	63.,2.

;	R3 -> ->BUF
;		BUF: N-1,N-2,P-1,P-2,dynreg,?,PRI,UIC,#LUN,		;044
;			?,?,SST-A,SST-L,P-S,4,UIC			;044

	TST	(R3)+		;SKIP ADDRESS OF PARAMETER BLOCK
	MOV	#R.TSKN+140000,R2 ;POINT TO TASK & PARTITION NAMES
	MOV	(R2)+,(R3)+	;GET TASK NAME
	MOV	(R2)+,(R3)+
	MOV	(R2)+,(R3)+	;GET PARTITION NAME
.ASSUME	R.PRTN	EQ	R.TSKN+4
	MOV	(R2)+,(R3)+
	MAP	JOBJC6,APR=6,DATA ;Map caller's JCR entry		;030
	MOV	JOBJCR,R0	;And point to it			;030
	MOVB	JCPRI(R0),R5	;Get priority	byte extended		;044
	MOV	R5,-(SP)	;save it				;044
	MOV	JCWPTR(R0),R5	;get pointer to WDB, is it empty?	;044
	BEQ	10$		;yes -then the answer is correct	;044
	MAP	FIPPOL		;Set up FIP pool mapping		;044
	MOV	-2(R5),R5	;get the pointer to LIB block		;044
	BEQ	10$		;if zero then no Dynn Region		;044
	BIC	#37,R5		;clear flags out of address		;044
	MOV	R.KSIZ(R5),R5	;get region size and control		;044
	BIC	#^C<377>,R5	;leave just size			;044
	ASH	#11.-6,R5	;make KW into sliver count		;044
10$:	MOV	R5,(R3)+	;store in location used only by RSX-11D	;044
	TST	(R3)+		;bump to next- RSX-D not supported	;044
	MAP	@UDPAR0,APR=6,DATA ;And re-map user's first 4K		;030
	MOV	(SP)+,R0	;restore priority			;044
	ADD	#128.,R0	;PUT IT IN RANGE 0 TO 255.
	MOV	R0,(R3)+	; AND STORE IT
	MOV	JDJDB2-JDFLG(R1),R0 ;GET 2ND JOB DATA BLOCK POINTER
	MOV	J2PPN(R0),R5	;GET PPN
	MOV	R5,(R3)+	; AND SET IT
	MOV	@#R.NLUN+140000,(R3)+ ;GET NUMBER OF LUNS
	CMP	(R3)+,(R3)+	;SKIP ANOTHER 2 WORDS
	MOV	@#R.SSTV+140000,(R3)+ ;GET SST VECTOR TABLE ADDRESS
	MOV	@#R.SSTL+140000,(R3)+ ; AND THE TABLE LENGTH
	MOV	@#R.TKSZ+140000,R2 ;GET JOB SIZE IN 32-WORD BLOCKS
	ASH	#6,R2		;CONVERT TO BYTES
	MOV	R2,(R3)+	;PUT THAT IN PARAMETER BLOCK
	MOV	R2,@#$DSW+140000 ;ALSO IN THE DSW
	MOV	#4,(R3)+	;IDENTIFY THIS SYSTEM AS RSTS
	CALL	MOVUSR		;MOVE THAT DATA TO THE USER
	MOV	R5,R0		;GET BACK THE PPN
	.BR	POKADP		; AND DO THAT LAST USER BUFFER POKE

GLOBAL	<UDPAR0>							;030

.SBTTL	PEEK AND POKE USER'S IMAGE

;+
; POKADP - POKE DATA INTO USER'S MEMORY; EXIT WITH "IE.ADP" ON ERROR.
;
;	R0 =  DATA TO POKE
;	R1 -> USER ADDRESS
;
;	CALL	POKADP
;
;	R0 =  0
;	R1 =  R1 +2 (I.E., R1 'POPPED')
;	R2 =  UNDEFINED
;-

.ENABL	LSB

POKADP:	ADD	#2,R1		;CORRECT USER POINTER FOR THE 'PUSH'
	CALLX	UPOKER		;GO POKE THE DATA TO USER
	BNE	20$		;WHOOPS, AN ERROR, SO SAY SO
	ADD	#2,R1		;O.K., 'POP' THE POINTER
10$:	RETURN			;RETURN

;+
; PEKADP - PEEK INTO USER'S MEMORY; EXIT WITH "IE.ADP" ON ERROR.
;
;	R1 -> USER ADDRESS
;
;	CALL	PEKADP
;
;	R0 =  0
;	R1 =  R1 +2 (I.E., R1 'POPPED')
;	R2 =  DATA
;-

PEKADP:	CALLX	DPEEKR		;GO PEEK FOR THE DATA
	BEQ	10$		;O.K., RETURN
20$:	XITERR	IE.ADP		;ELSE DIE WITH AN ERROR

.DSABL	LSB

.SBTTL	GSSW$S	GET SENSE SWITCHES

	DICDEF	125.,1.

;	R3 -> nothing

	MOV	@SWITCH,@#$DSW+140000	;RETURN THE SWITCHES
	RETURN

GLOBAL	<SWITCH>

.SBTTL	MSDS$	MAP SUPERVISOR D-SPACE

	DICDEF	201.,2							;039+

;	R3 -> MASK
;
;	mask layout
;	bit 	<15>	action (0=set mask / 1=only report mask)
;		<14>	D-APR7 (0=user D / 1=set to SUPER-I)
;		<13>	D-APR6 (0=user D / 1=set to SUPER-I)
;	likewise <12,11,10,9>
;		<8>	D-APR1 (0=user D / 1=set to SUPER-I)
;	bits <0-7>	Blank on input, PSW modes on return
;
;	Note 	D-APR0 must remain in user D mode.
;		If super mode is unmapped completely all settings
;		  will revert to USER-D.
;		If a Super APR is re-mapped after being set the setting
;		  will follow to the window.
;-

	MAP	JOBJC6,APR=6,DATA ;Map caller's JCR entry		
	MOV	JOBJCR,R0	;Get JCR pointer			
	ADD	#JCMFLG,R0	;And point to mapping flags
	MOV	(R3)+,R1	;get mask value
	BMI	20$		;if bit 15 set it is report only
	BIT	#100000,SYSTAK-2 ;did we come from user mode?		;039+
	BNE	20$		;yes then only report			;039+
	BIC	#77400,(R0)	;clear old values
	BIC	#^C<77400>,R1	;clear any noise
	BIS	R1,(R0)		;load the new mask value
	CALLMI	USRSTM,GENAP5	;reset up the MMU now			;039+
20$:	MOV	@#<SYSTAK-2>,R1	;get users psw
	SWAB	R1		;put modes in low byte
	BIC	#177400,R1	;clear the top byte
	MOV	(R0),R0		;get current mapping flags
	BIC	#100377,R0	;delete non-reported values
	BIS	R0,R1		;combine the two		
	MAP	@UDPAR0,APR=6,DATA ;Re-map the first 4K			
	MOV	R1,@#140000+$DSW ;return the report value
	RETURN								;039-

	GLOBAL	<JCMFLG>

.SBTTL	MVTS$	MOVE TO/FROM USER/SUPERVISOR I/D-SPACE

	.Enabl	LSB

	DICDEF	203.,4.

;	R3 -> ACTION, ADDRESS, VALUE
;
;		ACTION - MV.TUI - MOVE TO USER I SPACE		(14)
;			 MV.TUD - MOVE TO USER D SPACE		(16)
;			 MV.TSI - MOVE TO SUPER I SPACE		(15)
;			 MV.TSD - MOVE TO SUPER D SPACE		(17)
;			 MV.FUI - MOVE FROM USER I SPACE	(10)
;			 MV.FUD - MOVE FROM USER D SPACE	(12)
;			 MV.FSI - MOVE FROM SUPER I SPACE	(11)
;			 MV.FSD - MOVE FROM SUPER D SPACE	(13)
;			BIT 0 - ON=SUPER, OFF=USER
;			BIT 1 - ON=D, OFF=I
;			BIT 2 - ON=TO, OFF=FROM
;		ADDRESS - ADDRESS TO MOVE FROM OR TO
;		VALUE - VALUE TO BE WRITTEN (MOVE TO) OR
;			ADDRESS TO RETURN DATA TO (MOVE FROM)
;-

	MOV	(R3)+,R1	;GET THE REQUESTED ACTION
	BIT	#177760,R1	;LEGAL REQUEST???			;030
	BNE	100$		;NO, ILLEGAL PARAMETERS
	MOV	(R3)+,R4	;GET THE ADDRESS
	BIC	#1,R4		;MAKE SURE, WERE LOOKING AT A WORD
	MOV	(R3),-(SP)	;MOVE THE VALUE ON THE STACK (IN CASE IT'S MOVE TO)
	BIS	#30000,@#PS	;presume user mode prev	SPLC		;039
	BIT	#1,R1		;Is this a supervisor mode request?	;030
	BEQ	2$		;Doesn't seem to be			;030
	BIT	#XC$IDS,X.CON	;Do we have supervisor mode?		;030
	BEQ	100$		;No, forget it				;030
	BIC	#20000,@#PS	;Supervisor mode,super mode->PREV  SPLC	;030
2$:	BIT	#2,R1		;what space is it?			;039
	BNE	30$		; D, SO GO DO IT
15$:	BIT	#4,R1		;IS THIS A FROM OR TO REQUEST?
	BNE	20$		; MOVE TO REQUEST
	MFPI	(R4)		;MOVE IT FROM THE USERS I SPACE
	BR	40$		;REJOIN THE COMMON FROM CODE

20$:	MTPI	(R4)		; AND STORE IT INTO THE USERS I AREA
	BR	70$

30$:				;D-space request			;039
35$:	BIT	#4,R1		;IS THIS A FROM OR TO REQUEST?
	BNE	60$		; MOVE TO REQUEST
	MFPD	(R4)		;MOVE IT FROM THE USERS D SPACE
40$:	MOV	2(SP),R4	;GET THE USERS BUFFER ADDRESS
	BIC	#1,R4		;MAKE SURE ITS A WORD ADDRESS!
	CALL	SETPRE		;set previous mode to callers mode	;039
50$:	MOV	(SP)+,(SP)	;MOVE THE VALUE DOWN (THROWING AWAY THE TO DATA)	
60$:	MTPD	(R4)		; AND STORE IT INTO THE USERS D SPACE
70$:	RETURN

100$:	XITERR	IE.IFC		;ILLEGAL FUNCTION REQUESTED

130$:	XITERR	IE.PRI		;MOVE TO A R/O AREA

	TMPORG	RSXDSP,2						;041
	.WORD	ODTADP							;041
	UNORG								;041

ODTADP:				;entry point from RTI trap re-vectoring	;041
				;on return R1= address of fault		;041
	CMP	R1,#15$		;if it happened before this, then 	;041
	BLO	140$		; its fatal and we must die.		;041
	CMP	R1,#70$		;if it happened above this, then	;041
	BHI	140$		; its fatal and we must die.		;041
	XITERR	IE.ADP		;ADDRESS NOT MAPPED			;039

140$:	CRASH			; we didn't die in a legal place	;041

.DSABL	LSB
GLOBAL	<MAXLOW,MAXDLO,X.CON>						;039

.SBTTL	WTSE$	WAIT FOR SINGLE EVENT FLAG

	DICDEF	41.,2.

;	R3 -> EFN

	RETURN			;A NOP

.SBTTL	WSIG$	WAIT FOR SIGNIFICANT EVENT

	DICDEF	49.,1.

;	R3 ->

	MOV	#1,@#XRB+140000 ;One second sleep
	DOCALL	.SLEEP		; AND TAKE A BREATHER
	RETURN			;RETURN TO USER


.SBTTL	SPND$	SUSPEND TASK EXECUTION
.ENABL LSB
	DICDEF	45.,1.

;	R3 ->


10$:	MOV	#XRB+140000,R5		;FILL IN XRB
	MOV	#FQBSIZ-4,(R5)+		; XRLEN
	CLR	(R5)+			; XRBC
	MOV	#FIRQB+4,(R5)+		; XRLOC
	CLR	(R5)+			; XRCI
	CLR	(R5)+			; XRBLK
	CLR	(R5)+			; XRTIME
	MOV	#3000,(R5)+		; XRMOD
	DOCALL	.READ			; DO THE READ
	TSTB	@#XRB+XRBLKM+140000	;DID WE FIND A DELIMITER?
	BNE	20$			;BR IF WE DID
	TSTB	@#FIRQB+140000		;ERROR ON READ?
	BEQ	10$			;BR IF NOT (BUFER OVERFLOW- RETRY)
20$:	RETURN

.SBTTL	SVDB$	SPECIFY SST VECTOR FOR DEBUGGING AID

	DICDEF	103.,3.

;	R3 -> ->VEC,LEN

	MOV	#R.ODTV+140000,R1 ;POINT TO WHERE VECTOR WILL BE STORED
	BR	30$		; AND GO DO IT				;038

.SBTTL	SVTK$	SPECIFY SST VECTOR FOR TASK

	DICDEF	105.,3.

;	R3 -> ->VEC,LEN

	MOV	#R.SSTV+140000,R1 ;POINT TO WHERE VECTOR WILL BE STORED
30$:	MOV	(R3)+,R0	;get the vector address given by user	;038
	BIC	#1,R0		;assume from user mode, set flg bit =0	;038
	TST	<SYSTAK-2>	;did we come from supervisor mode?	;038
	BMI	35$		;no- from user mode, cont as you were	;038
	BIS	#1,R0		;yes- note from super for future	;038
35$:	MOV	R0,(R1)+	;move vec.address & mode flag to R.SSTV ;038
	MOV	(R3)+,(R1)+	;MOVE SST VECTOR LENGTH TO R.SSTL
	RETURN			;RETURN TO USER

.DSABL	LSB

.SBTTL	SFPA$	SPECIFY FLOATING POINT EXCEPTION AST

	DICDEF	111.,2.

;	R3 -> ADDR

	MOV	(R3),@#R.FAST+140000 ;MOVE ADDRESS INTO LOW CORE
	RETURN			;THAT'S ALL!

.SBTTL	ASTX$	AST SERVICE EXIT

	DICDEF	115.,1.

;	R3 ->
;		SP -> $DSW, PC, PS, EFM, ...

	MFPD	SP		;GET USER'S STACK			;013
	MOV	(SP)+,R1	; INTO A REGISTER
	CALL	PEKADP		;GET DSW
	MOV	R2,@#$DSW+140000 ; AND SET IT
	CALL	PEKADP		;GET PC AT AST TIME
	MOV	R2,SYSTAK-<2*2>	; AND SET AS THE NEW PC
	CALL	PEKADP		;GET PS AT AST TIME
	BIC	#3740,R2	;Set new PS to PR0			;038
	BIS	#4000,R2	; and ensure reg set 1			;038
	BIT	#140000,R2	;make sure not going to kernel mode	;038
	BEQ	40$		;he was! that's a no-no			;038
	MOV	R2,SYSTAK-<1*2>	;  THEN SET AS THE NEW PS
	MOV	R1,-(SP)	;PUSH UPDATED USER SP STACK VALUE
	MTPD	SP		; AND SET A NEW STACK			;013
	RETURN			;RETURN FROM AST

40$:	XITERR	IE.ALG		;Tried to jump to kernel illegally	;038

GLOBAL	<SYSTAK>

.SBTTL	ATRG$	ATTACH REGION

	DICDEF	57.,2.

;	R3 -> ->RDB

	MOV	(R3),R1		;Pick up RDB pointer			;018
DOATRG:	CALL	PLASX,R5,ATRFQ	;INITIALIZE FOR ATTACH REGION		;018
	DOCALL	.PLAS		;DO IT
	CALL	CKPLAS,R5,10$	;CHECK FOR ERRORS, ETC.
	MOV	(R4)+,R0	;GET RETURNED REGION ID
	CALL	POKADP		; AND RETURN IT
	MOV	(R4)+,R0	;GET RETURNED REGION SIZE IN 32-WORD BLOCKS
	CALLR	POKADP		; AND RETURN IT ALSO

10$:	.BYTE	IE.UPN,NOBUFS
	.BYTE	IE.PNS,NOSUCH
	.BYTE	IE.PRI,0	;END OF TABLE

GLOBAL	<NOBUFS,NOSUCH>

.SBTTL	DTRG$	DETACH REGION

	DICDEF	59.,2.

;	R3 -> ->RDB

	CALL	PLAS,R5,DTRFQ	;INITIALIZE FOR DETACH REGION
	DOCALL	.PLAS		;DO IT
	CALL	CKPLAS,R5,10$	;CHECK FOR ERRORS, ETC.
	MOV	R.GSTS(R4),R0	;GET RETURNED REGION STATUS
	ADD	#R.GSTS,R1	;INDEX TO RETURN LOCATION
	CALLR	POKADP		; AND GO RETURN STATUS

10$:	.BYTE	IE.NVR,NOSUCH
	.BYTE	IE.PRI,0	;END OF TABLE

GLOBAL	<NOSUCH>

.SBTTL	EXTK$/EXTM$	EXTEND TASK

.ENABL	LSB

	DICDEF	89.,3.

;	R3 -> DELTA SIZE/100						;034
;	      APR MASK VALUE						;034
;									;034
;	APR mask is structured as:					;034
;		Bit 0 (LSB)	represents	D-APR 0			;034
;				etc.					;034
;		Bit 7		represents	D-APR 7			;034
;									;034
;		Bit 15		EXTM$ flag(if EXTM$=1/EXTK$=0)		;034


;	The lowest D-APR # w/ a bit value=1 is the first protected APR	;034
;	expansion of D-space can occur up to that value but NOT included ;034

EXTK$:
	MOV	(R3),R1		;GET EXTEND SIZE IN 32-WD BLOCKS
	MOV	R1,@#R.MON1+140000 ; AND SAVE IT
	BNE	10$		;NON-ZERO IS A REAL SIZE
	MOV	@#R.LDSZ+140000,@#R.TKSZ+140000 ;ELSE REVERT TO LOAD SIZE
10$:	ADD	@#R.TKSZ+140000,R1 ;GET NEW TASK SIZE (MAYBE)
	BLE	15$		;WRAPAROUND, SORRY			;012
	CMP	R1,#2000	;Asking for 32K exactly?		;011
	BEQ	15$		;Yes, don't do that (one sliver less OK) ;012
	ADD	#40-1,R1	;ROUND TO NEXT K
	ASH	#-5,R1		; AND DIVIDE FOR K
12$:	MOV	R1,@#XRB+140000	;STORE THE NEW K SIZE
	MOV	2(R3),@#XRB+2+140000 ;Store APR mask in XRB for .CORE	;034
	DOCALL	.CORE		;SET NEW JOB SIZE
	TSTB	(R0)		;CHECK ERROR RETURN CODE
	BNE	20$		;WHOOPS, AN ERROR
	ADD	@#R.MON1+140000,@#R.TKSZ+140000 ;UPDATE CURRENT TASK SIZE
	RETURN			; AND RETURN

15$:	MOV	#FIRQB+140000,R0 ;Point to user's FIRQB			;012
	SETERR	XCDCOR,(R0)	;  and set "?Maximum memory" error	;012

20$:	XITERR	IE.ALG		;ILLEGAL/IMPOSSIBLE SIZE REQUEST

.SBTTL	CRAW$	CREATE ADDRESS WINDOW

	DICDEF	117.,2.

;	R3 -> ->WDB

CRAW$:	MOV	(R3),R1		;GET POINTER TO USER'S WDB
	CALL	PLASX,R5,CRAFQ	;SPECIAL INITIALIZE FOR CREATE ADDRESS WINDOW
	DOCALL	.PLAS		;DO IT
	CALL	CKPLAS,R5,90$	;CHECK FOR ERRORS, ETC.
	CALL	PEKADP		;GET FIRST WORD OF WDB
	CLRB	R2		;CLEAR LOW BYTE
	BISB	(R4)+,R2	; AND RETURN WINDOW ID
	MOV	R2,R0		;MOVE DATA WORD OVER HERE
	SUB	#2,R1		; AND BACK TO TOP OF WDB
	CALL	POKADP		;RETURN THE WINDOW ID
	MOVB	(R4),R0		;GET BASE APR
	ASH	#13.,R0		;CONVERT TO WINDOW BASE ADDRESS
	CALL	POKADP		; AND RETURN WINDOW BASE ADDRESS
	ADD	#W.NLEN-W.NAPR,R4 ;SKIP TO WINDOW MAP LENGTH
	ADD	#W.NLEN-<W.NBAS+2>,R1 ;SKIP TO WINDOW MAP LENGTH
	MOV	(R4)+,R0	;GET RETURNED WINDOW LENGTH MAPPED
	CALL	POKADP		; AND RETURN IT
	MOV	(R4)+,R0	;GET RETURNED WINDOW STATUS
	BIS	#WS.CRW,R0	; ENSURE SUCCESS
	CALL	POKADP		;  AND RETURN IT
80$:	RETURN			;DONE

90$:	.BYTE	IE.WOV,NOROOM
	.BYTE	IE.NVR,NOSUCH
	.BYTE	IE.UPN,NOBUFS
	.BYTE	IE.ALG,BADFUO
	.BYTE	IE.PRI,0	;END OF TABLE

.DSABL	LSB

GLOBAL	<NOROOM,NOSUCH,NOBUFS,BADFUO>

.SBTTL	CRRG$	Create dynamic region

	DICDEF	55.,2

;	R3 -> -> RDB

	MOV	(R3),R1		;R1 -> Start of RDB
	MOV	R1,@#140000+R.MON1 ;Save RDB pointer
	MOV	#140000+FIRQB+FQFUN,R4 ;R4 -> FIRQB
	MOVB	#UU.RTS,(R4)+	;Set up .UUO subfunction code
	MOV	#30,(R4)+	;And function code for create region
	CLR	(R4)+		;Skip past unused word
	ADD	#R.GNAM,R1	;R1 -> Region name
	CALL	PEKADP		;Now pick up part one of name
	MOV	R2,(R4)+	;And save it
	CALL	PEKADP		;Now get part two of name
	MOV	R2,(R4)+	;And save it
	CLR	(R4)+		;Let the monitor pick the load address
	ADD	#R.GSIZ-R.GPAR,R1 ;R1 -> Region size in slivers
	CALL	PEKADP		;Now get it
	ADD	#40-1,R2	;Round up to next K
	ASH	#-5,R2		;Now convert to K
	CMP	R2,#255.	;Do they want > 255K?			;035
	BLOS	10$		;No, we can fit it
	XITERR	IE.UPN		;Tell them we're out of room

10$:	BIS	#100000,R2	;Set flag to use low byte as size	;035
	MOV	R2,(R4)+	;Set up the size of region
	CLR	(R4)+		;Clear unused word
	CLR	(R4)		;Now guess at no attachment/no stay
	ADD	#R.GSTS-R.GNAM,R1 ;R1 -> Region status word
	CALL	PEKADP		;Now get it
	BIT	#RS.EXT,R2	;Do they desire extend access?
	BEQ	20$		;No, good, since we can't do it
	XITERR	IE.PRI		;Tell them we can't do it

20$:	BIT	#RS.ATT,R2	;Do they desire attachment?
	BEQ	30$		;No, not this time
	BIS	#200,(R4)	;Yes, so set the "attach me" flag
	BR	40$		;And join up
30$:	TST	FQNAM1-FQMODE(R4) ;Is this a named region create?
	BNE	40$		;Yes, so "no attach" is OK
	XITERR	IE.PNS		;Must specify attach to unnamed region (ugly!)

40$:	BIT	#RS.NDL,R2	;Is this a no mark for deletion add?
	BEQ	50$		;No, mark for delete, we're set
	BIS	#100000,(R4)	;No delete, so set the stay flag
50$:	MOV	R2,R0		;Copy region status bits
	BIC	#RS.UNM!RS.CRR!20000,R0 ;Clear top three bits like RSX does
	SUB	#2,R1		;Point back to R.GSTS
	CALL	POKADP		;Now return modified region status to caller
	TST	(R4)+		;Now skip past mode words
	CLR	(R4)+		;Don't pass any flags
	CALL	PEKADP		;Now pick up the protection code
	;CLR	R0		;R0 will hold RSTS protection
	MOV	#3,R5		;R5 = Count of protection fields to convert
60$:	BIT	#^B<00010000>,R2 ;Read protect set in RSX field?
	BEQ	70$		;No, so don't set it for RSTS field
	BIS	#^B<01000000>,R0 ;Set read protect in RSTS field
70$:	BIT	#^B<00100000>,R2 ;Write protect set in RSX field?
	BEQ	80$		;No, so don't set it for RSTS field
	BIS	#^B<10000000>,R0 ;Set write protect in RSTS field
80$:	ASH	#-2,R0		;Advance to next RSTS field
	ASH	#-4,R2		;And advance to next RSX field
	SOB	R5,60$		;And loop for the whole protection code
	SWAB	R0		;Get RSTS protection in high byte
	INC	R0		;Get a non-zero value in low byte
	MOV	R0,(R4)+	;Now set the protection field
	CLR	(R4)+		;Now clear an unused word
	CLR	(R4)+		;Now clear an unused word
	CLR	(R4)+		;Now clear an unused word
	CLR	(R4)+		;Now clear an unused word
	DOCALL	.UUO		;And go create the region
	MOV	@#140000+R.MON1,R1 ;Restore pointer to RDB		;021
	CMPB	(R0),#FIEXST	;Does region already exist?
	BNE	90$		;No, not this time
	ADD	#R.GSTS,R1	;R1 -> Passed region status
	CALL	PEKADP		;Get the region status
	BIT	#RS.ATT,R2	;Do they want attachment?
	BEQ	100$		;No, so we're done
	SUB	#R.GPRO,R1	;Point back to start of RDB
	JMP	DOATRG		;And do the attach

90$:	CALL	CKPLAS,R5,110$	;Check for errors
	MOV	(R4),R0		;Pick up returned region ID
	CALL	POKADP		;Now return it to the user
	ADD	#R.GSTS-R.GSIZ,R1 ;R1 -> Returned region status
	CALL	PEKADP		;Pick it up
	MOV	R2,R0		;Get it into the correct register
	BIS	#RS.CRR,R0	;Get ready to return successful creation
	SUB	#2,R1		;Point back to region status
	CALLR	POKADP		;Now return it
100$:	RETURN			;And we're done

110$:	.BYTE	IE.UPN,NOBUFS
	.BYTE	IE.UPN,NOROOM
	.BYTE	IE.PRI,0	;End of table

GLOBAL	<FIEXST,NOBUFS,NOROOM>

.SBTTL	MAP$	MAP ADDRESS WINDOW

	DICDEF	121.,2.

;	R3 -> ->WDB

	CALL	PLAS,R5,MAPFQ	;INITIALIZE FOR MAP ADDRESS WINDOW
	DOCALL	.PLAS		;DO IT
	CALL	CKPLAS,R5,10$	;CHECK FOR ERRORS, ETC.
	ADD	#W.NLEN,R1	;SKIP TO WINDOW LENGTH
	ADD	#W.NLEN,R4	;POINT TO RETURNED WINDOW LENGTH
	MOV	(R4)+,R0	;GET RETURNED WINDOW LENGTH MAPPED
	CALL	POKADP		; AND RETURN IT
	MOV	(R4)+,R0	;GET RETURNED WINDOW STATUS
	CALLR	POKADP		; AND RETURN IT & EXIT

10$:	.BYTE	IE.NVW,NOSUCH
	.BYTE	IE.ALG,BADFUO
	.BYTE	IE.PRI,0	;END OF TABLE

GLOBAL	<NOSUCH,BADFUO>

.SBTTL	ELAW$	ELIMINATE ADDRESS WINDOW

.ENABL	LSB

	DICDEF	119.,2.

;	R3 -> ->WDB

	CALL	PLAS,R5,ELAFQ	;INITIALIZE FOR ELIMINATE ADDRESS WINDOW
	DOCALL	.PLAS		;DO IT
	CALL	CKPLAS,R5,10$	;CHECK FOR ERRORS, ETC.
	MOV	#WS.ELW,R0	;SET BIT TO ENSURE SUCCESS
	BR	20$		; AND GO POST RESULTS

10$:	.BYTE	IE.NVW,0	;ONLY ONE ERROR...

.SBTTL	UMAP$	UNMAP ADDRESS WINDOW

	DICDEF	123.,2.

;	R3 -> ->WDB

	CALL	PLAS,R5,UMPFQ	;INITIALIZE FOR UNMAP ADDRESS WINDOW
	DOCALL	.PLAS		;DO IT
	CALL	CKPLAS,R5,30$	;CHECK FOR ERRORS, ETC.
	MOV	#WS.UNM,R0	;SET BIT TO ENSURE SUCCESS
20$:	ADD	#W.NSTS,R1	;POINT TO WINDOW STATUS
	BIS	W.NSTS(R4),R0	;.OR. IN RETURNED WINDOW STATUS
	CALLR	POKADP		; THEN RETURN STATUS & EXIT

30$:	.BYTE	IE.ITS,NOSUCH
	.BYTE	IE.NVW,0	;END OF TABLE

.DSABL	LSB

GLOBAL	<NOSUCH>

.SBTTL	GMCR$	GET MCR COMMAND LINE

	DICDEF	127.,41.

	CLR	@#$DSW+140000	;PRESET DSW TO 0
	TST	@#R.CCLF+140000	;ENTERED VIA CCL COMMAND?
	BPL	30$		;NO, SO ERROR
	MOV	#CORCMN+140000,R5 ;point at CCL buffer			;036
	MOV	R5,R3		;save a copy				;036
	MOVB	(R5)+,R4	;get char count				;036
	BPL	5$		;is it the first pass? plus is yes	;036
	BIC	#^C<177>,R4	;no, clear flag				;036
	MOVB	R4,(R3)		;put char count back			;036
	SUB	#79.,R4		;couunt of char for second pass		;036
	ADD	#79.,R5		;advance pointer to 1st char to output	;036
	BR	10$		;join common code			;036
	
5$:	CMP	#80.,R4		;does line need 2 passes?		;036
	BPL	10$		;no, only 80 or less char		;036
	BIS	#200,(R3)	;yes, set second pass flag on BC	;036
	MOV	#80.,R4		;force 1st line count to 80.		;036
10$:	MOV	R4,@#$DSW+140000 ;set returning char count		;036
	BEQ	30$		;zero is not legal			;036
	MOV	@#R.MON1+140000,R1 ;get pointer to DPB (really, +2)	;036
	CLR	-(SP)		;make work space			;036
20$:	MOVB	(R5)+,(SP)	;get next char, even			;036
	MOVB	(R5)+,1(SP)	;get next char, odd			;036
	MOV	(SP),R0		;get char word				;036
	CALL	POKADP		;poke it to user DPB @R1)+		;036
	SUB	#2,R4		;count down the characters		;036
	BHI	20$		;loop till end of count			;036
	BITB	#200,(R3)	;are we expecting a second pass?	;036
	BEQ	27$		;no,turn the lights out when you leave	;036
	MOVB	#55,1(SP)	;put a hyphen in last character		;036
	SUB	#2,R1		;backup over last poke			;036
	MOV	(SP)+,R0	;set for poke & clean stack up		;036
	CALL	POKADP		;put hyphen in DPB			;036
	RETURN			;exit, leave lights on for next time	;036
	
27$:	TST	(SP)+		;clean up stack				;036
	CLR	@#R.CCLF+140000	;no more passes, lock the door		;036
	RETURN			;That's all folks!			;036
	
	;notes on differences with RSX, CCL here does not provide a 	;036
	;terminating character as RSX does				;036
	
30$:	XITERR	IE.AST		;NOT ENTERED VIA CCL

.SBTTL	DSAR$	Disable AST recognition

.ENABL	LSB

	DICDEF	99.,1

; R3 -> Nothing

	MOV	JOBDA,R2	;R2 -> "JOB"s job data block		;030
	BIT	#J2ASTD,JDFLG3(R2) ;Are ASTs already disabled?		;030
	BNE	10$		;Yes, so we can't do this		;021
	BIS	#J2ASTD,JDFLG3(R2) ;Disable ASTs			;030
	RETURN			;And we're done				;021

10$:	XITERR	IE.ITS		;ASTs already disabled			;021

.SBTTL	ENAR$	Enable AST recognition

	DICDEF	101.,1

; R3 -> Nothing

	MOV	JOBF,R1		;R1 -> Job's JDB @ JOBF			;030
	BIT	#J2ASTD,JDFLG3-JDFLG(R1) ;Are ASTs already enabled?	;030
	BEQ	10$		;Yes, so give an error			;021
	BIC	#J2ASTD,JDFLG3-JDFLG(R1) ;Enable AST recognition	;030
	MOV	JOBJCR,R2	;Pick up JCR pointer			;030
	MAP	JOBJC6,APR=6,DATA ;And map it				;030
	TST	JCASTQ(R2)	;Are there any ASTs to post?		;030
	BEQ	20$		;No, not this time			;021
	BIS	#JFASTD,(R1)	;Yes, so get that posting going...	;030
20$:	RETURN			;And now we're done			;021

.DSABL	LSB

.SBTTL	FEAT$ & TFEA$ - FEATURE PRESENCE REPORTING

	;Table fill in macros						;037+

	.macro TFETAB	code,bitval,addr
		$3=0
		$1=code&377
	.if	DIF	ADDR,X.CON
		$3=100000
		tmporg	featad
		$2=<.-featad>*256.
		.word	addr
		unorg
	.iff
		$2=bitval*256.
	.endc
		tmporg	TFETAB
		.word	$1!$2!$3
		UNORG
	.endm

	.macro FEATAB code,bitval,addr
		$3=0
		$1=code&377
	.if	DIF	ADDR,X.CON
		$3=100000
		tmporg	featad
		$2=<.-featad>*256.
		.word	addr
		unorg
	.iff
		$2=bitval*256.
	.endc
		tmporg	FEATAB
		.word	$1!$2!$3
		UNORG

	.endm


	DICDEF	209.,2

TFEA:	MOV	#TFETAB-1,R5	;get pointer to TFEA$ feature table
	BR	FEACOM		;step over other entry

	DICDEF	177.,2

FEAT:	MOV	#FEATAB-1,R5	;get pointer to FEAT$ feature list
	;R3 ->	feature code to test in the DPB
FEACOM:	MOV	JOBF3,R2	;R2 -> "job's" job data block @ JDFLG3
	MOV	(R3),R4		;get feature to test
20$:	INC	R5		;look to the next code in list
	MOVB	(R5)+,R0	;get next feature list entry
	BEQ	FEAMIS		;end of list - failed to find it
	CMP	R4,R0		;is this the one?
	BNE	20$		;no- continue the search for the desirable one
	MOVB	(R5),R0		;found her- copy high byte of entry
	BMI	FEATST		;if bit 15, its a special test routine
	BEQ	FEASET		;if 0 it is always true (no test)
	DEC	R0		;table is <1:16> but BITWRD is <0:15.>*2
	ASL	R0		;make bit number word index
	BIT	BITWRD(R0),@#X.CON ;else test bit# in R0 against sys config
	BNE	FEASET		;if set true
FEACLR:	MOV	#IS.CLR,R1	;tell him false,missing clear		;043
	BR	FEARET		;common exit				;043

FEASET:	MOV	#IS.SET,R1	;report true				;043
FEARET:	MAP	PUSH,APR=6,DATA	;save where we are for the moment	;043
	MAP	@UDPAR0,APR=6,DATA ;map the users low core		;043
	MOV	R1,@#140000+$DSW ;put return value for user reference	;043
	MAP	POP,APR=6,DATA	;restore what was current mapping	;043
	RETURN			;back to the user

FEATST:	BIC	#177600,R0	;special function routine dispatcher
	JMP	@FEATAD(R0)	;and vector to address thru table

FEAMIS:	XITERR	IE.SDP		;feature not on list

FEAFPP:	;required because the test is compliment of X.CON value
	BIT	#XC$FPP,@#X.CON	;is there an FPP unit?
	BEQ	FEASET		;no so report true (that's RSX for you)
	BR	FEACLR		;yes- so tell him false

TFEA15:	BIT	#J2ASTD,(R2) 	;(test JDFLG3) Are AST's disabled?
	BNE	FEASET		;yes so report true to user
	BR	FEACLR		;no- so report out clear

TFEA34:	CMP	@UDPAR0,@#UISAR0 ;see if our D is also our I space?
	BNE	FEASET		;no- D must be on, report true
	BR	FEACLR		;yes- report false

TFEA40:	BIT	#JDFSTM,JDFLG4-JDFLG3(R2) ;is fast mapping enabled?
	BNE	FEASET		;yes- report set
	BR	FEACLR		;no- report clear

	.list	meb

	; note bit numbers for X.con are numbered <1:16> here not <0:15>
	; a zero in the bit number field means always true
	; address can be either X.CON or a label of test routine
	; if address is not X.CON, bitnumber ignored, <test> is for readablity
	; Macro use: TABLENAME  featurecode,bitnumber,address

	FEATAB	59.,0,X.CON	;fast map support
	FEATAB	37.,14.,X.CON	;user data space support
	FEATAB	18.,14.,X.CON	;Supervisor mode support
	FEATAB	5.,0,X.CON	;PLAS support
	FEATAB	1,5.,X.CON	;22 bit addressing
	FEATAB	-1.,15.,X.CON	;unibus mapping registers
	FEATAB	-2,0,X.CON	;EIS support
	FEATAB	-3,6.,X.CON	;Qbus present
	FEATAB	-4.,14.,X.CON	;I&D space supported
	FEATAB	-8.,11.,X.CON	;CIS supported
	FEATAB	-16.,test,FEAFPP	;NO fpp unit present (true if missing)

	TFETAB	15.,test,TFEA15	;AST recognition disabled (true if off)
	TFETAB	34.,test,TFEA34	;task uses I&D space
	TFETAB	40.,test,TFEA40 ;Task has fast mapping enabled
	.nlist	meb

	TMPORG	FEATAB
	.WORD	0		;mark end of table
	TMPORG	TFETAB
	.WORD	0		;mark end of table
	UNORG

	GLOBAL	<X.CON,BITWRD>						;037-

.SBTTL	Task image loader

;+
; RSXRUN - Load and execute a .TSK file
;
; RSXRUN is used to load and execute a .TSK file. We are entered when
; SCH notices a P.RUN attempt is being made to NULRTS. SCH uses the
; complex EMT completion mechanism to cause transfer to come to us
; after posting completes.
;
; The task file is open on channel 15.
;
; The FIRQB is set up as for the .RUN
;
; As soon as the task is loaded, we will exit to RTI3, setting up
; the caller's registers as requested in the .TSK file. We are
; able to preserve registers across DOEMTs, since we use the
; user mode registers as our registers. We are not able to preserve
; stack contents.
;-

RSXRUN::MOVB	@#140000+FIRQB,R1 ;Pick up possible error code		;021
	BEQ	10$		;None, that's good			;021
	JMP	DOERR1		;Error, so report it and get out	;021
10$:	MOV	#SYSTAK-2,SP	;Reset the monitor's stack		;021

;	DEFINE DEFAULT TASK NAME

	MOV	@#140000+FIRQB+FQNAM1,@#140000+R.TSKN ;Set the file name ;021
	MOV	@#140000+FIRQB+FQNAM1+2,@#140000+R.TSKN+2 ;as the task name ;021

;	SAVE PARAMETERS PASSED BY MONITOR

	MOV	#140000+FIRQB+FQNENT,R1 ;POINT TO USER PARAMETER WORD	;021
	MOV	#140000+R.PARM,R2 ;POINT TO LOW CORE SAVE AREA		;021
	MOV	(R1)+,(R2)+	;SAVE IT, POINT TO XRB			;021
	MOV	(R1),(R2)	;SAVE FIRST WORD OF XRB			;021

;	Set CCL bit if we were entered at line 30000

	MOV	@#140000+R.PARM,R0 ;PICK UP PARAMATER WORD		;021
	ASL	R0		;CLEAR OFF HIGH BIT NOW TIMES 2		;021
	CMP	#30000.*2,R0	;Did they run the program at line 30000? ;021
	BNE	20$		;No, not this time			;021
	BIS	#100000,(R2)	;SO SET R.CCLF TO FAKE OUT GMCR		;021

;	SAVE FIRQB IN PMDXRB

20$:	MOVE	140000+FIRQB,140000+PMDXRB,FQBSIZ/2 ;SAVE FIRQB IN PMDXRB ;021
	MOV	#140000+XRB,R1	;R1 -> (MAPPED) XRB			;021

;	READ IN TASK LABEL AND HEADER

	MOV	#NSTORG,R0	;R0 POINTS TO 1ST WORD ABOVE RSTS AREA	;021
	MOV	#512.*3,R4	;SET UP COUNT FOR A 3 BLOCK READ	;021
	CALL	LODSET		;Set up for a load of header area	;021
				;THIS INCLUDES LABEL AND LUN BLOCKS	;021
	DOCALX	.READ		;Now read it in				;021
	MOV	#3.,@#140000+R.HDRZ ;PRESET THE LOAD OVERLAY HEADER OFFSET ;021
	ADD	#140000,R0	;R0 -> Load block through APR6		;021
	CMP	#^RSIL,776(R0)	;IS THIS REALLY A SIL IMAGE?		;021
	BNE	40$		;NO, THEN THIS MUST BE THE HEADER	;021
	MOV	#254.,R2	;GET A LOOP CONTROL VARIABLE		;021
	CLR	R5		;R5 will hold the XOR checksum		;021
30$:	MOV	(R0)+,R3	;COPY A WORD				;021
	XOR	R3,R5		;XOR IN A WORD				;021
	SOB	R2,30$		;LOOP UNTIL ALL WORDS ARE DONE		;021
	CMP	R5,(R0)		;IS THE CHECKSUM RIGHT?			;021
	BNE	40$		;NO, SO NO PROCESSING			;021
	INC	@#140000+R.HDRZ	;BUMP HEADER OFFSET ONCE FOR SIL INDEX	;021
	MOVE	140000+L$LUN1,140000+NSTORG,512. ;MOVE UP THE REAL LABEL AND LUN BLOCKS ;021
	MOV	#H.ORG,R0	;R0 POINTS TO 3RD BLOCK ABOVE RSTS AREA	;021
	MOV	#512.,R4	;SET UP COUNT FOR A 1 BLOCK READ	;021
	CALL	LODSET		;FROM TASK HEADER INTO ITS PROPER PLACE ;021
	DOCALX	.READ		;Now read it in				;021
	.BR	40$		;NOW GO SET UP LOW CORE			;021

GLOBAL	<SYSTAK>

.SBTTL	DEFINITIONS OF ENTRIES IN RSX-11M TASK LABEL AND HEADER

L$BTSK=	NSTORG			;TASK NAME (2 WORDS)
L$BPAR=	L$BTSK+4		;TASK PARTITION (2 WORDS)
L$BSA =	L$BTSK+10		;BASE ADDRESS OF TASK
L$BHGV=	L$BTSK+12		;HIGHEST WINDOW 0 VIRTUAL ADDRESS
L$BMXV=	L$BTSK+14		;HIGHEST VIRTUAL ADDRESS OF TASK
L$BLDZ=	L$BTSK+16		;LOAD SIZE OF TASK IN 32-WD HUNKS
L$BMXZ=	L$BTSK+20		;MAXIMUM SIZE OF TASK IN 32-WD HUNKS
L$BOFF=	L$BTSK+22		;TASK OFFSET INTO PARTITION,header size	;035
L$BWND=	L$BTSK+24		;NUMBER OF TASK WINDOWS (LESS LIBRARIES)
				;high byte is system type code (4=M+)	;038
L$BSEG=	L$BTSK+26		;SIZE OF OVERLAY SEGMENT DESCRIPTORS
L$BFLG=	L$BTSK+30		;TASK FLAGS WORD
L$BDAT=	L$BTSK+32		;TASK CREATION DATE (3 WORDS)
L$BLIB=	L$BTSK+40		;LIBRARY/COMMON 14-WORD BLOCK
R$LNAM=	0			;LIBRARY NAME (2 WORDS)
R$LSA =	4			;BASE ADDRESS OF LIBRARY
R$LHGV=	6			;HIGHEST WINDOW 0 VIRTUAL ADDRESS
R$LMXV=	10			;HIGHEST VIRTUAL ADDRESS OF LIBRARY
R$LLDZ=	12			;LOAD SIZE OF LIBRARY IN 32-WD HUNKS
R$LMXZ=	14			;MAXIMUM SIZE OF LIBRARY IN 32-WD HUNKS
R$LOFF=	16			;LIBRARY OFFSET INTO PARTITION
R$LWND=	20			;NUMBER OF LIBRARY WINDOWS
R$LSEG=	22			;SIZE OF OVERLAY SEGMENT DESCRIPTORS
R$LFLG=	24			;LIBRARY FLAGS WORD
R$LDAT=	26			;LIBRARY CREATION DATE (3 WORDS)
L$BPRI=	L$BTSK+346		;TASK PRIORITY
L$BXFR=	L$BTSK+350		;TASK TRANSFER ADDRESS
L$BEXT=	L$BTSK+352		;TASK EXTENSION IN 32-WD HUNKS
L$BSGL=	L$BTSK+354		;BLOCK NUMBER OF SEGMENT LOAD LIST
L$BHRB=	L$BTSK+356		;BLOCK NUMBER OF HEADER
L$BBLK=	L$BTSK+360		;NUMBER OF BLOCKS IN LABEL
L$BLUN=	L$BTSK+362		;NUMBER OF LOGICAL UNITS

L$BOID= 340			;Label block difference for /ID (M+) tasks ;042+
L$BROB= L$BTSK+364+L$BOID+0	;RELATIVE BLOCK OR R/O IMAGE
L$BROL= L$BTSK+364+L$BOID+2	;R/O LOAD SIZE
L$BRDL= L$BTSK+364+L$BOID+4	;R/O DATA LOAD SIZE
L$BHDB= L$BTSK+364+L$BOID+6	;RELATIVE BLOCK NUMBER OF DATA HEADER
L$BDHV= L$BTSK+364+L$BOID+10	;DATA WINDOW 1 HIGH VIRTUAL ADDRESS
L$BDMV= L$BTSK+364+L$BOID+12	;DATA HIGH VIRTUAL ADDRESS
L$BDLZ= L$BTSK+364+L$BOID+14	;DATA LOAD SIZE
L$BDMZ= L$BTSK+364+L$BOID+16	;DATA MAX SIZE				   ;042-
L$DAPR=	L$BTSK+364+L$BOID+20	;D apr usage mask			   ;038
                                                                           ;033
;                                                                          ;033
; OFFSETS AT END OF LABEL BLOCK                                            ;033
;                                                                          ;033
                                                                           ;033
L$BFL2= L$BTSK+772              ; SECOND TASK FLAG WORD (includes L$BOID ) ;033
L$BLRL= L$BTSK+774              ; LABEL BLOCK REV NUMBER(includes L$BOID ) ;033
L$AME= L$BTSK+776               ; MUST ALWAYS BE NULL   (includes L$BOID ) ;033
                                                                           ;033
L$LUN1=	NSTORG+1000		;LOGICAL UNIT ASSIGNMENT TABLE START
H.ORG =	NSTORG+2000		;BASE OFFSET FOR TASK HEADER
H.CSP =	H.ORG			;CURRENT STACK POINTER (R6)
H.HDLN=	H.ORG+2			;HEADER LENGTH
H.EFLM=	H.ORG+4			;EVENT FLAG MASK
H.CUIC=	H.ORG+10		;CURRENT UIC
H.DUIC=	H.ORG+12		;DEFAULT UIC
H.IPS =	H.ORG+14		;INITIAL TASK PS
H.IPC =	H.ORG+16		;INITIAL TASK PC
H.ISP =	H.ORG+20		;INITIAL TASK SP
H.ODVA=	H.ORG+22		;ODT SST VECTOR ADDRESS
H.ODVL=	H.ORG+24		;ODT SST VECTOR LENGTH
H.TKVA=	H.ORG+26		;TASK SST VECTOR ADDRESS
H.TKVL=	H.ORG+30		;TASK SST VECTOR LENGTH
H.PFVA=	H.ORG+32		;POWER FAIL AST CONTROL BLOCK
H.RCVA=	H.ORG+34		;FLOATING POINT AST CONTROL BLOCK
H.RCVA=	H.ORG+36		;RECEIVE AST CONTROL BLOCK
H.EFSV=	H.ORG+40		;ADDRESS OF EVENT FLAG CONTEXT
H.FPSA=	H.ORG+42		;FLOATING POINT SAVE AREA
H.WND =	H.ORG+44		;POINTER TO NUMBER OF WINDOW BLOCKS
H.DSW =	H.ORG+46		;DIRECTIVE STATUS WORD
H.FCS =	H.ORG+50		;.FSRPT IN TASK IMAGE
H.FORT=	H.ORG+52		;ADDRESS OF FORTRAN IMPURE STORAGE
H.OVLY=	H.ORG+54		;ADDRESS OF OVERLAY IMPURE STORAGE
H.VEXT=	H.ORG+56		;ADDRESS OF IMPURE VECTORS
H.GARD=	H.ORG+72		;HEADER GUARD WORD POINTER
H.NLUN=	H.ORG+74		;NO. OF LUNS


; DEFINITION OF FLAG BITS IN LIBRARY DEFINITION BLOCK OF HEADER

LD$TYP= 000002			;Lib type (1=COMMON, 0=LIBR)		;035
LD$REL=	000004			;PIC INDICATOR (1=YES)
LD$SUP=	000010			;SUPERVISOR LIBRARY (1=YES)
LD$AMK=	000060			;APR MASK BITS (Super=40 & user data=20)   ;035
LD$SCL=	000200			;DEFAULT MEMBER OF CLUSTER LIB
LD$RTS=	000200			; OR RUN TIME SYSTEM
LD$CLS=	020000			;NON-DEFAULT MEMBER OF CLUSTER LIB
LD$RSV=	040000			;RELOCATION BIAS SPECIFIED (1=YES)
LD$ACC=	100000			;ACCESS INTENT (1=RW, 0=RO)

; MODIFIED FOR RSX-11M-PLUS V2.1 BY:                                       ;033
;                                                                          ;033
; DEFINE LABEL BLOCK REVISION NUMBER. THIS SHOULD BE INCRMENTED            ;033
; WHENEVER A NEW FIELD IS ADDED TO THE LABEL BLOCK. IT IS                  ;033
; STRUCTURED WITH MAJOR/MINOR REVISION NUMBERS IN THE HIGH/LOW             ;033
; BYTES, RESPECTIVELY. L$BLRL IS VALID ONLY IF TS$NEW IS SET.              ;033
; LABEL BLOCKS WITHOUT TS$NEW SET ARE CONSIDERED REVISION 0. THIS          ;033
; TURNS OUT HANDY, SINCE WE BELIEVE THEY ALL HAVE ZEROS IN THE             ;033
; L$BLRL OFFSET, ANYWAY.                                                   ;033
;                                                                          ;033
                                                                           ;033
LB$REV= 000400          ; MAJOR REVISION LEVEL = 1                         ;033
                                ; MINOR REVISION LEVEL = 0                 ;033
                                                                           ;033
;                                                                          ;033
; LABEL BLOCK TASK FLAG WORD DEFINITIONS                                   ;033
;                                                                          ;033
                                                                           ;033
TS$PIC= 100000          ; TASK IS PIC (1=YES)                              ;033
TS$NHD= 040000          ; NO HEADER IN TASK IMAGE (1=YES)                  ;033
TS$ACP= 020000          ; TASK IS ANCILLARY CONTROL PROCESSOR (1=YES)      ;033
TS$PMD= 010000          ; GENERATE POST-MORTEM DUMP (1=YES)                ;033
TS$SLV= 004000          ; TASK IS SLAVEABLE (1=YES)                        ;033
TS$NSD= 002000          ; NO SEND TO TASK IS PERMITTED (1=YES)             ;033
TS$PRV= 000400          ; TASK IS PRIVELEGED (1=YES)                       ;033
TS$CMP= 000200          ; TASK BUILT IN COMPATIBILITY MODE (1=YES)         ;033
TS$CHK= 000100          ; TASK IS CHECKPOINTABLE (0=YES)                   ;033
TS$RES= 000040          ; TASK HAS RESIDENT OVERLAYS (1=YES)               ;033
TS$IOP= 000020          ; PRIVILEGED TASK NOT MAPPED TO I/O PAGE           ;033
TS$SUP= 000010          ; TASK LINKED TO A SUPER MODE LIBRARY (1=YES)      ;033
TS$XHR= 000004          ; TASK HAS AN EXTERNAL HEADER (1=YES)              ;033
TS$NXH= 000002          ; TASK CAN NOT HAVE AN XTRNL HEADER (1=YES)        ;033
TS$NEW= 000001          ; LABEL BLOCK USES NEW FORMAT                      ;033
                                ; (MEANS L$BLRL DESCRIBES FORMAT)          ;033
                                                                           ;033
;                                                                          ;033
; SECOND TASK FLAGS WORD                                                   ;033
;                                                                          ;033
                                                                           ;033
T2$FMP= 000002          ; TASK USES FAST MAP DIRECTIVE (1=YES)             ;033
T2$CLI= 000001          ; TASK IS A CLI (1=YES)                            ;033
                                                                           ;033

.SBTTL	SET UP LOW CORE AREA

40$:	MOV	#140000+NSTORG,R0 ;POINTS TO 1ST WORD ABOVE RSTS AREA	;021
	MOV	#140000,R2	;SET POINTER TO LOW CORE AREA		;021
	TST	(R0)		;IS TASK NAME BLANK?			;021
	BNE	50$		;NO, SO USE IT				;021
	MOV	R0,R2		;YES, USE DEFAULT TASK NAME (FILENAME)	;021
50$:	MOV	(R0)+,(R2)+	;COPY TASK NAME				;021
	MOV	(R0)+,(R2)+	;  ...					;021
	MOV	#140000+R.PRTN,R2 ;SET POINTER BACK TO LOW CORE AREA	;021
	MOV	(R0)+,(R2)+	;COPY PARTITION NAME			;021
	MOV	(R0)+,(R2)+	;  ...					;021
	MOV	@#140000+L$BMXZ,(R2)+ ;SAVE THE TASK MAX SIZE		;021
	MOV	#140000+H.ODVA,R0 ;SET POINTER TO VECTOR ADDRESSES	;021
	MOV	(R0)+,(R2)+	;COPY ODT SST VECTOR ADDRESS		;021
	MOV	(R0)+,(R2)+	; AND ITS LENGTH			;021
	MOV	(R0)+,(R2)+	;LIKEWISE TASK SST			;021
	MOV	(R0)+,(R2)+	; AND ITS LENGTH			;021
	TST	(R0)+		;SKIP OVER POWER FAIL AST CONTROL BLOCK	;021
	MOV	(R0)+,(R2)+	;COPY FPP AST CONTROL BLOCK		;021
	CLR	(R2)+		;CLEAR CTRL/C AST HANDLER ADDRESS	;021
	MOV	@#140000+L$BFLG,(R2)+ ;SAVE THE TASK FLAGS WORD		;021
	TST	(R2)+		;SKIP OVER USER PARAMETER WORD		;021

;	EXTEND JOB'S MAIN STORAGE ALLOCATION

	MOV	#140000+L$BEXT,R5 ;--> TO THE EXTEND SECTION WORD	;021
	CMPB	@#140000+L$BWND+1,#4 ;IS THIS AN M-PLUS TASK		;021
	BNE	60$		; NO					;021
	ADD	#L$BOID,R5	; YES, SO CORRECT THE POINTER		;042
	TST	@#140000+L$BHDB	;IS THERE A D SPACE HEADER??		;021
	BEQ	60$		;NO, SO NOTHING SPECIAL			;021
	MOV	(R5),R3		;Get the extend size			;045
	ADD	@#140000+L$BDMZ,R3 ;add the maximum D space to it	;045
	BIT	#20000,(R2)	;is there a CCL size request?		;042
	BEQ	57$		;no -that is easy			;045
	BIC	#20000,(R2)	;kill ithe flag so it won't be in I-sp	;042
	MOVB	(R2),R4		;do it here in D-space instead,get ext	;042
	ASH	#5,R4		;make it a sliver value (was KWs)	;042
	BPL	54$		;if plus use as final value, else	;042
	NEG	R4		; make it plus and extend the increment	;042
	ADD	R3,R4		; by adding to size in header		;045
54$:	CMP	R4,R3		; and pick the larger of the two.	;045
	BLOS	57$		;    (is request > than in header?)	;042
	MOV	R4,R3		; Yes, so use it			;045
57$:	CMP	R3,#2000	;DO THEY WANT LESS THAN 32K?		;045
	BLO	58$		;YES -THEN HONOR REQUEST, ELSE		;045
	MOV	#1777,R3	;NO- GIVE THEM OUR 32K MAX SIZE		;045
58$:	MOV	R3,@#140000+R.MON2  ;and save as our D space size	;045
	CLR	(R5)		;CLEAR IT FOR THE I EXTEND		;021
60$:	MOV	R5,@#140000+R.MON1 ;SAVE THIS POINTER FOR LATER		;021
	MOV	(R5),R5		;GET THE TASK EXTEND SIZE AND		;021
	ADD	@#140000+L$BMXZ,R5 ;ADD THE MAXIMUM SIZE OF THE TASK	;021
	ADD	#1024./32.-1,R5	;ROUND UP TO NEXT 1K BOUND		;021
	ASH	#-5,R5		;OBTAIN MULTIPLE OF 1K WORDS		;021
	BIT	#20000,(R2)+	;TEST FOR SIZING REQUEST FROM CCL	;021
	BEQ	80$		;NO SIZING REQUIRED			;021
	MOVB	-2(R2),R4	;GET THE SIZE REQUESTED			;021
	BPL	70$		;ABSOLUTE SIZE REQUESTED		;021
	NEG	R4		;GET ABSOLUTE VALUE OF INCREMENT	;021
	ADD	R5,R4		;INCREMENT THE SIZE REQUEST		;021
70$:	CMP	R5,R4		;GET THE BIGGER SIZE			;021
	BHIS	80$		;ALREADY HAVE IT			;021
	MOV	R4,R5		;NOW WE DO				;021
80$:	MOV	R5,(R1)		;PUT LOAD SIZE IN K IN XRB		;021
	CLR	2(R1)		;0 apr mask word so it's a EXTK$	;034
	ASH	#5,R5		;CONVERT TO 32-WORD BLOCKS		;021
	CMP	R5,#2000	;Asking for less than 32K?		;021
	BLO	90$		;yes - honor request			;042
	MOV	#1777,R5	;no- set request to our maximum		;042
90$:	MOV	R5,(R2)+	;SAVE INITIAL LOAD SIZE (R.LDSZ) 	;021
	MOV	R5,(R2)+	;AND ALSO CURRENT TASK SIZE (R.TKSZ)	;021
	DOCALX	.CORE		;REQUEST CORE FROM RSTS			;021
	MOV	@#140000+R.MON1,R5 ;GET THE M OR M+ POINTER BACK	;021

;	SET NUMBER OF LUNS

	MOV	L$BLUN-L$BEXT(R5),R3 ;GET NUMBER OF LUNS		;021
	CMP	R3,#15.		;CHECK FOR MORE THAN 15 LUNS		;021
	BLOS	100$		;NO, SO OK.				;021
	DOERR	BSERR		;Go and report illegal I/O channel	;021

100$:	MOV	R3,(R2)+	;SAVE NUMBER OF LUNS			;021

;	DETACH JOB IF REQUESTED

	BIT	#40000,@#140000+R.CCLF ;IS JOB TO BE DETACHED?		;021
	BEQ	110$		;NO					;021
	MOV	#JFSYS,(R1)	;Get ready to drop privileges		;021
	DOCALX	.CLEAR		;Go drop privileges			;021
	CALL	CLRFQB		;Clear out the FIRQB			;021
	MOVB	#UU.DET,@#140000+FIRQB+FQFUN ;Function code is detach	;021
	MOVB	#200,@#140000+FIRQB+FQERNO ;CLOSE CHANNELS ON DETACH	;021
	DOCALX	.UUO		;Now do the detach			;021
	MOV	#JFSYS,(R1)	;Get ready to regain privileges		;021
	DOCALX	.SET		;And go for it				;021

;	SET UP PROGRAM NAME

110$:	MOV	@#140000+R.TSKN,@#140000+FIRQB+FQNAM1 ;Set program name	;030
	MOV	@#140000+R.TSKN+2,@#140000+FIRQB+FQNAM1+2 ;Both parts	;030
	DOCALX	.NAME		;Now actually set it			;030

;	SET UP SPECIAL WORDS FOR RSX-11M COMPATIBILITY

	MOV	#140000+$DSW,R2	;POINT TO $DSW				;021
	CLR	(R2)+		;CLEAR THE DIRECTIVE STATUS WORD	;021
	MOV	#140000+H.FCS,R0 ;COPY IMPURE AREA POINTERS		;021
	.REPT	4
	MOV	(R0)+,(R2)+	;.FSRPT,$OTSV,N.OVPT,$VEXT		;021
	.ENDM

;	MOVE THE LUN TABLE TO LOW CORE

	MOV	#140000+L$LUN1,R3 ;LUN TABLE IN TASK LABEL		;021
	MOV	#140000+R.LUNS,R5 ;LUN TABLE IN LOW CORE		;021
	;the following two instructions stomp on the words 141774 & 6	;042
	;in the new task label block. currently these words are not	;042
	;used by RSTS- if they ever are this must be changed.		;042
	CLR	-(R3)		;LUN 0 UNIT NUMBER			;021
	MOV	#"TI,-(R3)	;LUN 0 DEVICE NAME IS "TI:"		;021
	MOV	#16.,R4		;NUMBER OF LUNS TO MOVE			;021
120$:	TST	(R3)		;ANY DEVICE FOR THIS LUN?		;021
	BNE	130$		;YES, GO ASSIGN IT			;021
.REPT	4
	CLR	(R5)+		;CLEAR THIS LUN TABLE ENTRY		;021
.ENDM
	BR	150$		;And join up				;021

130$:	MOV	R3,-(SP)	;Get one work register			;021
	MOV	R4,-(SP)	;And another				;021
	CALL	ALUN		;Go and assign that LUN			;021
	BCC	140$		;It worked, that's good			;021
	DOERR	NODEVC		;Invalid device, go report it		;021

140$:	MOV	(SP)+,R4	;Restore counter			;021
	MOV	(SP)+,R3	;And pointer into LUN table		;021

150$:	CMP	(R3)+,(R3)+	;Advance to the next LUN		;021
	SOB	R4,120$		;Loop for the entire LUN table		;021
	MOV	#140000+XRB,R1	;POINT R1 TO XRB AGAIN			;021

	;set overlay status in KEY					;036
	
;	TST	@#140000+H.OVLY	;Built with an ODL file?		;045
;	BNE	152$		; Yes, so might have overlays		;045
	; This would fix programs where the total overlay size is < 64b	;045
	; but at the expense of keeping open some tasks that have NO	;045
	; overlays at all.  H.OVLY is set whenever an ODL is used -	;045
	; even if there are no overlays in it.  It was decided that	;045
	; lifting this restriction wasn't worth the extra small buffer	;045
	; usage (to keep the .tsk files opened).			;045
	CMP	@#140000+L$BLDZ,@#140000+L$BMXZ ;is I-maxsiz=load size	;036
	BNE	152$				;No- I-space overlay	;036
	CMP	@#140000+L$BDLZ,@#140000+L$BDMZ ;is D-maxsiz=load size?	;036
	BEQ	154$				;Yes- Neither overlayed	;036
152$:	BIS	#JFOVLY,@#140000+KEY		;set status-overlayed	;036
154$:									;036

        ;Set FAST MAP enable                                           	;033

        BIT     #TS$NEW,@#L$BFLG+140000 ;is it new format header?      	;033
        BEQ     155$            ;no - then can't possibly have it      	;033
        BIT     #T2$FMP,@#L$BFL2+140000 ;HDR real, is FASTMAP there?   	;033
        BEQ     155$            ;no                                    	;033
        MOV     JOBDA,R2        ;pt to job buffer                      	;033
        BIS     #JDFSTM,JDFLG4(R2)      ;enable func for this job      	;033
155$:                                                                  	;033

	;Set up dynamic region as task header if needed			;035

	MOV	@#140000+L$BOFF,R0 ;get header size requested by TKB	;035
	BEQ	159$	   	   ;if 0 none requested,skip		;035
	ADD	#37,R0		;round request up to nearest 1K bound	;035
	ASH	#-5,R0		;was slivers, now KW			;035
	CMP	R0,#255.	;is it too large?			;035
	BLOS	156$		;no, we can handle it			;035
	DOERR	VCSERR		;report error to big			;035

156$:	CALL	CLRFQB		;clear FIRQB				;035
	MOV	#140000+FIRQB+FQFUN,R4 ;set R4->firqb			;035
	MOVB	#UU.RTS,(R4)+	;Set .UUO function code (-18.)		;035
	MOV	#30,(R4)	;set RTS subfunction code to create Reg	;035
	ADD	#FQSIZ-FQFIL,R4	;point to reg size in firqb		;035
	BIS	#100000,R0	;set flag to use all low 8 bits as size	;035
	MOV	R0,(R4)		;Store requested region/header size	;035
	DOCALX	.UUO		;Go create region			;035

159$:
        GLOBAL  <JOBJD2>                                               	;033

.SBTTL	CHECK FOR PRESENCE OF RESIDENT LIBRARIES

; NOTE THAT RUN TIME SYSTEMS AND CLUSTER LIBRARIES LOOK VERY MUCH ALIKE
; THE FLAG WORD FOR A RUN TIME SYSTEM AND A DEFAULT MEMBER OF A CLUSTER
; LIBRARY BOTH USE THE #200 BIT TO IDENTIFY THEM.
; WE DETERMINE THE DIFFERENCE BY LOOKING AHEAD AT THE NEXT LIBRARY, AS
; IF IT WAS THE DEFAULT MEMBER OF A CLUSTER THEN THE NEXT LIB MUST BE A
; NON-DEFAULT MEMBER OF A CLUSTER, AND WE CAN TELL THAT BY LD$CLS.

	MOV	#140000+L$BLIB,R0 ;BEGIN AT (POSSIBLY) THE FIRST LIBRARY ;021
160$:	TST	(R0)		;IS THERE A LIBRARY HERE?		;021
	BEQ	210$		;NO, ALL DONE!				;021
	TSTB	R$LFLG(R0)	;IS THIS A HISEG LIBRARY?		;021
	BPL	170$		;NO, MUST BE A CLUSTER 			;021
	.ASSUME	LD$RTS EQ LD$SCL ;RTS AND CLUSTER LIBS LOOK ALIKE	;021
	.ASSUME	LD$RTS EQ 200	;ENSURE BPL WILL WORK RIGHT		;021
	TST	14.*2(R0)	;DOES A SECOND LIBRARY EXIST?		;021
	BEQ	200$		;NO, THIS MUST BE AN RTS		;021
	BIT	#LD$CLS,R$LFLG+<14.*2>(R0) ; IS THE NEXT ONE A CLU MEMBER ;021
	BEQ	200$		;NO, MUST BE AN RTS			;021

;	NOW TRY TO ATTACH TO THE RESIDENT LIBRARY

170$:	CALL	OVRLAP		;Check for overlapping addresses	;045
	CALL	CLRFQB		;Clear out the FIRQB			;021
.ASSUME	ATRFQ	EQ	0	;Function is attach			;021
	MOV	#140000+FIRQB+FQNAM1+2,R4 ;POINT TO BEGINNING OF PARAMETERS ;021
	MOV	(R0),(R4)+	;SET UP LIBRARY NAME			;021
	MOV	2(R0),(R4)+	;Both parts				;021
	CMP	(R4)+,(R4)+	;SKIP TO FIRQB+FQMODE			;021
	MOV	#RS.RED,(R4)	;START WITH READ ONLY ACCESS		;021
	TST	R$LFLG(R0)	;R/W ACCESS?				;021
	BPL	180$		;NO, GOOD GUESS				;021
	.ASSUME	LD$ACC EQ 100000 ;IT BETTER FOR THE BPL TO WORK		;021
	MOV	#RS.WRT,(R4)	;UPDATE FOR R/W ACCESS			;021
180$:	DOCALX	.PLAS		;DO ATTACH REGION			;021
.NO$LIB=.			;Special error message for failure	;021

;	NOW TRY TO MAP TO A ROOT SEGMENT (IF ANY)

	MOV	@#140000+FIRQB+FQPPN,R$LWND(R0)	;SAVE RETURNED REGION ID ;025
	BIT	#LD$CLS,R$LFLG(R0) ;IS THIS A NON-DEFAULT CLUSTER MEMBER? ;021
	BNE	200$		;YES, SO DON'T MAP IT NOW		;021
	CALL	CLRFQB		;Clear out the FIRQB			;021
	MOV	#140000+FIRQB+FQFIL,R4 ;R4 -> FIRQB @ FQFIL		;021
	MOV	#CRAFQ,(R4)+	;Function is create address window	;021
	MOV	R$LSA(R0),R2	;R2 = Library base address		;021
	ASH	#-5,R2		;Convert to APR number in high byte	;021
	BIC	#^C<7*400>,R2	;And keep only APR number		;021
	MOV	R2,(R4)+	;STORE APR NUMBER AWAY			;021
	CLR	(R4)+		;Skip unused word			;021
	MOV	R$LLDZ(R0),(R4)+ ;STORE WINDOW SIZE IN 32-WORD BLOCKS	;021
	MOV	R$LWND(R0),(R4)+ ;NOW STORE THE (SAVED) REGION ID	;021
	MOV	R$LOFF(R0),(R4)+ ;STORE AWAY OFFSET INTO REGION		;021
	CLR	(R4)+		;MAP ALL (OR PART) OF WINDOW		;021
	MOV	#RS.RED,(R4)	;ASSUME THEY WANT READ-ONLY		;021
	TST	R$LFLG(R0)	;NOW FIND OUT WHAT THEY WANT		;021
	BPL	190$		;THEY DO WANT READ ONLY			;021
	.ASSUME	LD$ACC EQ 100000 ;BETTER FOR ABOVE BPL TO WORK		;021
	MOV	#RS.WRT,(R4)	; SET WRITE REQUESTED, SINCE THEY DID.	;021
190$:	BIT	#LD$SUP,R$LFLG(R0) ;Supervisor mode library?		;032
	BEQ	195$		;Nope.  Move on (sigh)			;032
	BIS	#WS.SIS,(R4)	;Yep, mark it as such			;032
	BR	197$		;If super mode can't have D mode also	;035

195$:	BIT	#LD$TYP,R$LFLG(R0) ;Is it COMMON or LIBR?		;035
	BEQ	197$		;0 is LIBR (code region) is default	;035
	BIS	#WS.UDS,(R4)	;1 is COMMON so mark for D space	;035
197$:	MOV	(R4),R$LFLG(R0)	;MAKE USER, WE STORE IT AWAY		;035
	BIS	#WS.MAP,(R4)	; AND MAP THE WINDOW			;021
	DOCALX	.PLAS		;DO CREATE ADDRESS WINDOW		;021

200$:	ADD	#14.*2,R0	;SKIP TO NEXT LIBRARY			;021
	CMP	R0,#140000+L$BPRI ;More libraries to do?		;021
	BLO	160$		;CHECK FOR MORE				;021
	CMPB	@#140000+L$BWND+1,#4 ;IS THIS AN M-PLUS TASK		;045
	BNE	210$		; NO					;045
	CMP	R0,#140000+L$BPRI+L$BOID ; M+ upper limit check		;045
	BLO	160$		;CHECK FOR MORE				;045

;	RESTORE FIRQB

210$:	MOVE	140000+PMDXRB,140000+FIRQB,FQBSIZ/2 ;MOVE FIRQB BACK FROM PMDXRB ;021

;	Copy initial register values to PMDXRB

220$:	MOV	#140000+H.IPS,R0 ;POINT TO INITIAL PS			;021
	MOV	#140000+PMDXRB,R4 ;R4 -> PMD XRB save area		;021
	MOV	(R0)+,R3	;Pick up initial PS			;021
	BIC	#^C<PR0!T!N!Z!V!C>,R3 ;Trim it to valid bits		;021
	BIS	#170000!4000,R3	;Set prev=current=user & reg set 1	;021
	MOV	R3,(R4)+	;And save it for the user		;021
	MOV	(R0)+,(R4)+	;Save initial PC			;021
	MOV	(R0)+,(R4)+	;Save initial SP			;021
	MOV	#140000+726,R0	;set pointer task save area		;038
	MOV	-(R4),(R0)+	;SP stored-->726			;038
	MOV	-(R4),(R0)+	;PC stored-->730			;038
	MOV	-(R4),(R0)+	;PSW stored-->732			;038
	ADD	#6,R4		;reset R4 to next free word		;038

230$:	MOV	@#140000+H.GARD,R0 ;Pick up header guard address	;021
	BIT	#1,R0		;Is it odd?				;021
	BNE	240$		;Yes, so we can't use this		;021
	CMP	R0,#512.	;Does it fit within the header?		;021
	BLO	250$		;Yes, so it is OK			;021
240$:	DOERR	FUCORE		;No, so report program lost-sorry	;021

250$:	ADD	#<H.ORG-12>+140000,R0 ;Now point to register save area	;021
	.REPT	5
	MOV	(R0)+,(R4)+	;SAVE INITIAL R4-R0			;021
	.ENDM

;	SET/CLEAR FPP CONTEXT SWITCHING

	TST	@#140000+H.FPSA	;FPP SPECIFIED FOR THIS TASK?		;021
	BEQ	260$		;No, so we're all set up		;021
	BIS	#JFFPP,@JOBF	;Enable FPP context saving		;021

GLOBAL	<JOBF>

.SBTTL	LOAD ROOT SEGMENT AND GO

260$:	CLR	@#140000+PMDXRB+24 ;PUT A 0 = NO D SPACE 		;021
	CMPB	@#140000+L$BWND+1,#4 ;ARE WE AN M+ TASK??		;021
	BNE	270$		;NO, SO CAN'T HAVE D SPACE		;021
	MOV	#140000+L$BHDB,R0 ;GET THE D SPACE HEADER BLOCK # ->	;021
	TST	(R0)		; IS THERE A D SPACE HEADER?		;021
	BEQ	270$		; NO, SO CONTINUE NORMAL		;021
	MOV	(R0)+,@#140000+PMDXRB+20 ;Set up the block number	;021
	CMP	(R0)+,(R0)+	;R0=R0+4				;021
	MOV	(R0)+,@#140000+PMDXRB+22 ;SAVE THE LOAD SIZE		;021
	MOV	(R0)+,@#140000+PMDXRB+24 ;SAVE THE MAX SIZE ALSO	;021
	MOV	(R0)+,@#140000+PMDXRB+26 ;save the L$DAPR mask value	;038
270$:	MOV	@#140000+L$BLDZ,R4 ;GET THE SIZE OF THE ROOT SEGMENT	;021
	MOV	R4,@#140000+R.MON1 ;SAVE SIZE OF ROOT IN 32-WD BLOCKS	;021
	ASH	#6,R4		;CONVERT TO A BYTE COUNT		;021
	MOV	#NSTORG,R0	;STARTING ADDRESS FOR LOAD		;021
	SUB	R0,R4		;SUBTRACT FROM ROOT LENGTH		;021
	CALL	LODSET		;READ THE TASK IMAGE INTO CORE		;021
	DOCALX	.READ		;STARTING AT NEXT BLOCK OF .TSK FILE	;021

;	Set user flag bits

280$:	MOV	#JFTRAP,(R1)	;CONTROL C TRAP ENABLE BIT		;021
	BIT	#10000,@#140000+R.TSKF ;POST-MORTEM DUMP REQUESTED?	;021
	BEQ	300$		;No, not this time			;021
	BIS	#JFDUMP,(R1)	;Yes, so turn the bit on now		;021
300$:	BIS	(R1),@#140000+KEY ;SET OUR USER FLAGS			;021

;	START UP THE TASK

310$:	MOV	@#140000+PMDXRB+24,R2 ;GET THE D SPACE MAX SIZE		;021
	BEQ	320$		;NONE, SO SKIP THIS FANCY STUFF		;038
	MOV	@#140000+R.MON2,R2 ;Get the D space size		;045
	ADD	#<1024./32.>-1,R2 ;ROUND IT UP TO 1K BOUNDARY		;038
	BIC	#<1024./32.>-1,R2 ;mask off so =KW in slivers		;038
	ASH	#-5,R2		;CONVERT FROM 32W TO K WORDS		;021
	MOVB	R2,(R1)+	;SET THE SIZE IN THE XRB		;021
	MOVB	#-1,(R1)+	;AND SET THE D TURN ON FLAG		;021
	ASH	#5,R2		;Convert back into slivers		;045
	CMP	R2,#2000	;DO THEY WANT LESS THAN 32K?		;042
	BLO	311$		;YES -THEN HONOR REQUEST, ELSE		;042
	MOV	#1777,R2	;NO- GIVE THEM OUR 32K MAX SIZE		;042
311$:	MOV	R2,@#140000+R.LDSZ ;Save this as the load size		;031
	MOV	R2,@#140000+R.TKSZ ;And as the task size		;031
	CLR	(R1)		;0 apr mask word so it's a EXTK$	;034
	TST	@#140000+PMDXRB+26 ;was L$DAPR a 0 (pre V9.6 TKB)	;038
	BEQ	315$		;yes - use the old load rules		;038
			;if it is needed to go back to the old standard	;038
..LDSW ==.		;of RSTS default inclusion of D apr's with LIB	;038
			;I apr's then replace the next word with a NOP	;038
	INC	(R1)		;set up as EXTM$ w/ no D-apr's protect	;038
315$:	DOCALX	.CORE		;NOW, TURN IT ON			;021
	MOV	@#140000+PMDXRB+22,R3 ;Get the root segment size	;021
	ASH	#6,R3		;CONVERT TO BYTES			;021
	MOV	#NSTORG,R0	;GET THE STARTING ADDRESS		;021
	SUB	R0,R3		;DON'T READ IN THE LOWCORE AREA		;021
	MOV	R3,-2(R1)	;SET THE BYTE COUNT			;021
	CLR	(R1)+		;Clear returned byte count		;021
	MOV	R0,(R1)+	;Set up the address			;021
	MOV	#15.*2,(R1)+	;And channel number			;021
	MOV	@#140000+PMDXRB+20,(R1) ;RSX offset to D space of image	;042
	ADD	@#140000+R.HDRZ,(R1)	;add 3/4 header size(tsk/sil)	;042
	DEC	(R1)+		; -1 magic constant -don't ask, it works ;042
	CLR	(R1)+		;Clear XRTIME				;021
	CLR	(R1)+		;And XRMOD				;021
	DOCALX	.READ		;NOW, LOAD THE DATA			;021

; Close the task file if it isn't overlaid

320$:	BIT	#JFOVLY,@#140000+KEY ;Does task have overlays? 		;038
	BNE	330$		;Yes, keep it open			;036
	CLRB	@#140000+FIRQB+FQFUN ;Function is close			;024
.ASSUME	CLSFQ	EQ	0
	DOCALX	CALFIP		;Close channel 15 now			;024

330$:	MOV	#140000+PMDXRB,R4 ;R4 -> Register save area		;024
	MOV	#SYSTAK,SP	;Reset the monitor's stack		;021
	MOV	(R4)+,-(SP)	;Set the initial PS for the caller	;021
	MOV	(R4)+,-(SP)	;And initial PC				;021
	SPLC	3		;Set previous mode = user		;021
	MOV	(R4)+,-(SP)	;Pick up user's SP			;021
	MTPD	SP		;And set it for them			;021
	CLR	-(SP)		;Clear R5				;021
	MOV	(R4)+,-(SP)	;Set up R4				;021
	MOV	(R4)+,-(SP)	;And R3					;021
	MOV	(R4)+,-(SP)	;And R2					;021
	MOV	(R4)+,-(SP)	;And R1					;021
	MOV	(R4)+,-(SP)	;And R0					;021
	JMPX	RTI3		;Off to start this job now		;021

GLOBAL	<SYSTAK>

.SBTTL	Check task/library for overlapping addresses

;+
; OVRLAP - Check task address space for overlap with library addresses
;
;	R0 -> the L$BLIB entry for the library to check
;
;	CALL	OVRLAP
;
;	R4 destroyed
;		all others preserved
;
;	If it returns, all is well.  If not, then the user has
;	been given a max memory exceeded error.
;-

OVRLAP:	BIT	#LD$SUP,R$LFLG(R0) ;Supervisor mode Library		;045
	BNE	20$		; Yes, so can't overlap			;045
	MOV	@#140000+R.TKSZ,R4 ;Get the I space max address		;045
	CMPB	@#140000+L$BWND+1,#4 ;Is this an M-PLUS task		;045
	BNE	10$		; No, so only check I space		;045
	TST	@#140000+L$BHDB	;Is there a D space header??		;045
	BEQ	10$		; No, so only check I space		;045
	BIT	#LD$TYP,R$LFLG(R0) ;Is it in I or D space?		;045
	BEQ	10$		; It is I space, so check that		;045
	MOV	@#140000+R.MON2,R4 ;Get the D space max address		;045
10$:	ASH	#6,R4		;Convert slivers to virtual		;045
	CMP	R4,R$LSA(R0)	;Task address space higher?		;045
	BHI	30$		; Yes, so give the error		;045
20$:	RETURN			;All is well with this task		;045

30$:	DOERR	EDBMCE		;report error to big			;045


.SBTTL	Clear the FIRQB

;+
; CLRFQB - Clear the FIRQB
; CLRFQX - Clear the FIRQB and XRB
;
;	CALL	CLRFQB
;	CALL	CLRFQX
;
; And it happens. All registers are preserved.
;-

CLRFQX:	MOV	#CLRXRB,-(SP)	;Clear the XRB when done		;028
CLRFQB:	MOV	R0,-(SP)	;Get a work register			;021
	MOV	#140000+FIRQB,R0 ;R0 -> FIRQB				;021
10$:	CLR	(R0)+		;Clear out a word			;021
	CMP	R0,#140000+XRB	;Are we done yet?			;021
	BNE	10$		;No, so loop for the whole thing	;021
	MOV	(SP)+,R0	;Restore our work register		;021
	RETURN			;And we're done				;021

.SBTTL	Clear the XRB

;+
; CLRXRB - Clear the XRB
;
;	CALL	CLRXRB
;
; And it happens. All registers are preserved.
;-

CLRXRB:	MOV	R0,-(SP)	;Get a work register			;028
	MOV	#140000+XRB,R0	;R0 -> XRB				;028
10$:	CLR	(R0)+		;Clear a word				;028
	CMP	R0,#140000+CORCMN ;Done yet?				;028
	BNE	10$		;No, so loop				;028
	MOV	(SP)+,R0	;Yes, restore work register		;028
	RETURN			;And we're done				;028

.SBTTL	Data moving

;+
; MOVE - Move a block of words
;
;	CALL	MOVE,R5,SOURCE,DEST,LEN
;
; All registers are preserved.
;-

MOVE:	MOV	R0,-(SP)	;Get one work register			;021
	MOV	R1,-(SP)	;And another one			;021
	MOV	R2,-(SP)	;And still another one			;021
	MOV	(R5)+,R0	;Pick up source address			;021
	MOV	(R5)+,R1	;And destination address		;021
	MOV	(R5)+,R2	;And length				;021
10$:	MOV	(R0)+,(R1)+	;Move a word				;021
	SOB	R2,10$		;For all the words			;021
	MOV	(SP)+,R2	;Restore R2				;021
	MOV	(SP)+,R1	;And R1					;021
	MOV	(SP)+,R0	;And R0					;021
	RETURN	R5		;All done for now			;021

.SBTTL	Set up for a .READ of the task file

;+
; LODSET - Set up for a .READ of the task file
;
;	R0 = Address
;	R4 = Byte count
;
;	CALL	LODSET
;
; XRB set up for .READ
; All registers are preserved.
;-

LODSET:	MOV	R1,-(SP)	;Get a work register			;021
	MOV	#140000+XRB,R1	;R1 -> (MAPPED) XRB			;021
	MOV	R4,(R1)+	;Set up byte count			;021
	CLR	(R1)+		;Clear XRBC for .READ			;021
	MOV	R0,(R1)+	;Set up the address			;021
	MOV	#15.*2,(R1)+	;Set up channel number			;021
	CLR	(R1)+		;Get the next block #			;021
	CLR	(R1)+		;Clear XRTIME				;021
	CLR	(R1)+		;And indicate no modifiers		;021
	MOV	(SP)+,R1	;Restore R1				;021
	RETURN			;And we're done				;021

.SBTTL	Execute a EMT directive

;+
; DOCALX - Execute a EMT directive
;
;	SP -> Saved R5, Unavailable word
;		TOS.PC		TOS.PS	!SYSTAK
;	Calling job is JOB
;
;	CALL	DOCALX,R5
;	 EMT	CODE
;
; This routine is used to execute a monitor directive from within the
; monitor. We will save all registers in the user-mode registers,
; and return to the caller on success. No information may be maintained
; on the stack.
;
; If there is an error, we will print out the error and exit to the
; job's default keyboard monitor.
;-

DOCALX:	CMP	SP,#SYSTAK-4	;Does the stack look correct?		;021
	BNE	ABCALX		;Nope, something is messed up		;021
	CLR	-(SP)		;Make a hole for PC to return to	;021
	MOV	R4,-(SP)	;Save R4				;021
	MOV	R3,-(SP)	;And R3					;021
	MOV	R2,-(SP)	;And R2					;021
	MOV	R1,-(SP)	;And R1					;021
	MOV	R0,-(SP)	;And finally R0				;021
	MOVB	(R5)+,R0	;Pick up EMT code desired		;021
	INC	R5		;And skip the high byte			;021
	MOV	R5,5*2(SP)	;Save the caller's return PC		;021
	MOV	JOBJCR,R2	;Point to JCR entry for job		;030
	MAP	JOBJC6,APR=6,DATA ;Map the JCR				;030
	MOV	#10$,JCCEPC(R2)	;Set up PC to return to			;030
	MOV	@#KISAR5,JCCEAP(R2) ;Save our mapping			;030
	BIS	#JFCEMT,@JOBF	;Indicate to do complex EMT posting	;021
	JMPX	CPLXMC		;And do the call now			;021

; We will be returned to after the EMT completes
;
;	R0 -> (MAPPED) FIRQB
;	R5 -> (MAPPED) XRB
;	SP -> "RTI3", R0, R1, R2, R3, R4, PC, R5, Unavailable Word
;								  !SYSTAK
;-

10$:	TST	(SP)+		;Dump the RTI3				;021
	MOVB	(R0),R1		;Did we get an error?			;021
	BNE	20$		;Yes, check on reporting it		;021
	MOV	(SP)+,R0	;Restore R0				;021
	MOV	(SP)+,R1	;And R1					;021
	MOV	(SP)+,R2	;And R2					;021
	MOV	(SP)+,R3	;And R3					;021
	MOV	(SP)+,R4	;And R4					;021
	MOV	(SP)+,R5	;And the saved PC (via a JSR R5,...)	;021
	RETURN	R5		;Now back to our caller			;021

20$:	CMP	5*2(SP),#.NO$LIB ;Were we unable to attach to our library? ;021
	BNE	DOERR1		;No, not this time, no special message	;021
	MOVB	R1,@#140000+R.MON1 ;Save the error code			;021
	CALL	SETXRB		;Set up for a message			;021
	MOV	#ERRALB,R0	;R0 -> Message text			;021
	CALL	FINXRB		;Finish up XRB setup			;021
	DOCALL	.WRITE		;Go and write this message out		;021
	MOVB	@#140000+R.MON1,R1 ;Restore the error code		;021
	BR	DOERR1		;And write out the error code		;021

ABCALX:	CRASH			;SP not correct for DOCALX		;021

.ENABL	LC								;021

ERRALB:	.ASCIZ	/?Unable to attach to resident library/			;021

.DSABL	LC								;021

.EVEN									;021

GLOBAL	<SYSTAK>							;030

;+
; DOERR - Report an error
; DOERR1 - Report an error in R1
;
; For DOERR:
;
;	R5 -> Error code
;
;	JMP	DOERR
;
;	    - or -
;
;	CALL	DOERR,R5,<error-code>
;
; For DOERR1:
;
;	R1 = Error code
;
; This routine is used to report errors which occur during task loading.
; We will report the error code and exit to the caller's default KBM.
;-

DOERR:	MOVB	(R5),R1		;Pick up error code			;021
DOERR1:	MOV	#140000+FIRQB+FQFUN,R0 ;R0 -> FIRQB @ FQFUN		;021
	MOVB	#UU.ERR,(R0)+	;Function code is error message lookup	;021
	MOVB	R1,(R0)		;Set the error code			;021
	DOCALL	.UUO		;Pick up the error code			;021
	CALL	SETMSG		;Set up for the message			;021
	CALLX	DOEMT,R5	;Get ready to print it			;021
	.WRITE			;Now print the error message		;021
	.BR	EXIKBM		;Now exit to the default KBM		;028

;+
; EXIKBM - Exit to the default KBM
;
; Come here to exit from emulation and go to the default KBM.
;
; We will issue a .RTS. After the .RTS, if the current KBM is NULRTS,
; we will enter our KBM. Otherwise, we will return to P.NEW in the
; default RTS for the job.
;-

EXIKBM:	CLR	@#140000+FIRQB+FQNAM1 ;Set to return to caller's RTS	;028
	DOCALL	.RTS		;Off to the caller's RTS		;028
	CMP	JOBRTS,#NULRTS	;Using our KBM?				;028
	BEQ	10$		;Yes, so go to it			;028
	RETURN			;No, exit (via RTI3)			;028

10$:	MOV	#377*400,@#140000+XRB ;Ask for D-space turn off		;028
	DOCALL	.CORE		;Now turn off D-space if it is on	;028
	MOV	#1,@#140000+XRB	;Now ask for a 1K program		;028
	DOCALL	.CORE		;And go for it				;028
	.BR	RSXKBM		;Now enter the KBM			;028

.SBTTL	The keyboard monitor

;+
; RSXKBM - The keyboard monitor
;
;	R0 -> FIRQB (Mapped)
;	R5 -> XRB (Mapped)
;	SP -> "RTI3",R0,R1,R2,R3,R4,R5,PC,PS,...
;					     !- "SYSTAK"
;	JOB IS "JOB"
;	JOB'S 1ST 4K IS MAPPED THROUGH DPAR6
;
; This is the handler for P.NEW into the NULRTS. This is only used when
; there has been a load error for the default KBM. We will prompt
; with "RSTS>" and accept any CCL command as well as the RUN command.
;-

RSXKBM::MOV	JOBJD2,R1	;Pick up JDB2 pointer			;028
	TST	J2PPN(R1)	;Is job logged in?			;028
	BNE	45$		;Yes, sure is				;030
	TST	2(R5)		;Is this a brand new job?		;028
	BEQ	10$		;Yes, go run LOGIN or something		;028
	MOV	JOBF,R1		;No, get JDB @JDFLG pointer		;028
	BIS	#JFSPCL,(R1)	;Set special condition			;028
	BISB	#JFKILL,JDFLG2-JDFLG(R1) ;As kill this job		;028
	MOV	JOBJCR,R1	;Point to JCR entry			;030
	MAP	JOBJC6,APR=6,DATA ;And map it				;030
	MOVB	#127.,JCPRI(R1) ;Kill this job fast!			;030
	JMPX	DMPJOB		;And dump this job			;028

10$:	MOV	#140000+FIRQB+FQPPN,R0 ;Point to FIRQB @ FQPPN		;028
	TST	(R0)		;Should I run LOGIN?			;028
	BNE	20$		;No, this is old-style spawn processing	;028
	MOV	(PC)+,(R0)+	;Yes, so set up for			;028
	 .BYTE	2,1		;[1,2]LOGIN.*				;028
	MOV	#^RLOG,(R0)+	; ...					;028
	MOV	#^RIN,(R0)+	; ...					;028
	MOV	#-1,(R0)+	;Any file type will do			;028
	MOV	#32000.,@#140000+FIRQB+FQNENT ;Go to line 32000.	;028
	BR	40$		;Now join up				;028

20$:	MOV	#140000+CORCMN,R0 ;Point to mapped core common		;028
	MOV	#11.,R2		;Move ten bytes plus creator's job #	;028
	MOVB	R2,(R0)+	;Set up length in CORCMN		;028
30$:	MOVB	FIRQB+16-<CORCMN+1>(R0),(R0)+ ;Copy a byte		;028
	SOB	R2,30$		;For the whole thing			;028
	MOVB	@#140000+FIRQB+FQFIL,-(R0) ;Set the creator's job number ;028
40$:	JMP	130$		;And go do the run			;028

; This is the logged-in keyboard monitor

45$:	MOV	#^R.RS,@#140000+FIRQB+FQNAM1 ;Set program name		;030
	MOV	#^RTS.,@#140000+FIRQB+FQNAM1+2 ;To be .RSTS.		;030
	DOCALL	.NAME		;Now set it				;030
50$:	DOCALL	.TTRST		;Cancel ^O effect			;028
	BIC	#JFGO!JFCC!JF2CC,@JOBF ;Forget any ^C ASTs		;028
	MOV	#PROMPT,R4	;Point to our prompt			;028
	MAP	FIPPOL		;Map FIP pool for the IOB		;030
	MOV	@JOBDA,R1	;Pick up IOB pointer			;028
.ASSUME	JDIOB	EQ	0
	MOV	(R1),R1		;Now get CH # 0 DDB pointer		;028
	MAP	@#KISAR5,APR=5,DATA ;Restore our code mapping		;030
	MAP	@UDPAR0,APR=6,DATA ;Restore user mapping		;030
	CMPB	DDHORZ(R1),DDHORC(R1) ;Need to do a CR/LF?		;028
	BEQ	51$		;No, so all set up			;028
	MOV	#PROMCR,R4	;Yes, so get the other prompt		;028
51$:	MOV	#140000+NSTORG,R3 ;And point to our buffer		;028
	MOV	#-1,R2		;R2 will have the length		;028
52$:	INC	R2		;Note another byte went by		;028
	MOVB	(R4)+,(R3)+	;Copy a byte				;028
	BNE	52$		;And loop for all the characters	;028
	CALLX	CLRXRB		;Clear out the XRB			;028
	MOV	R2,(R5)+	;Set up the prompt length		;028
	MOV	R2,(R5)+	;In both places				;028
	MOV	#NSTORG,(R5)	;Set up the prompt address		;028
	DOCALL	.WRITE		;And write it out			;028
	CALLX	CLRXRB		;Clear the XRB again			;028
	MOV	#200,(R5)	;Set up for a 128. byte read		;028
	MOV	#NSTORG,XRLOC(R5) ;Into some free memory		;028
	DEC	XRTIME(R5)	;Indicate that this is a KBM read	;028
	DOCALL	.READ		;Now go for it				;028
	BEQ	60$		;Worked, that's good			;028
	MOVB	(R0),R1		;Pick up error code			;028
	CMPB	R1,#EOF		;Did they hit ^Z?			;028
	BEQ	50$		;Yes, so ignore the line		;028
55$:	JMP	DOERR1		;No, so report the error		;028

60$:	BIT	#JFCC!JF2CC,@JOBF ;User hit ^C lately?			;028
	BNE	50$		;Yes, so forget their input		;028
	MOV	@#140000+XRB+XRBC,R1 ;Get the length of the string	;028
	ADD	#140000+NSTORG,R1 ;Point to end of string + 1		;028
70$:	CMP	R1,#140000+NSTORG ;Is there anything here at all?	;028
	BEQ	50$		;No, so ignore this			;028
	CMPB	-(R1),#40	;Is this a printable character?		;028
	BLOS	70$		;No, or a space, ignore it		;028
	SUB	#<140000+NSTORG>-1,R1 ;Get the byte count		;028
	CALLX	CLRXRB		;Clear out the XRB			;028
	MOV	R1,(R5)		;Set up the length			;028
	MOV	(R5)+,(R5)+	;In both places				;028
	MOV	#NSTORG,(R5)	;Set up the address			;028
	DOCALL	.CCL		;Now issue the .CCL			;028
	BEQ	80$		;No error, check for .RUN or exiting	;028
	MOVB	(R0),R1		;Pick up error code			;028
	BR	55$		;And report it				;028

80$:	CMP	JOBRTS,#NULRTS	;Did we find a program to run?		;028
	BNE	140$		;Yes, so go to it			;028
	MOV	#140000+NSTORG,R2 ;No, so point to input string		;028
	MOV	#RUNSTR,R3	;And point to the "RUN " text		;028

; Note: The match checking code below will only work for seven-bit
; data, and will never be able to match eight-bit data correctly.

90$:	MOVB	(R3)+,R5	;Get a character to check against	;028
	BEQ	120$		;Done, it matches			;028
	DEC	R1		;Say another character being checked	;028
	BEQ	110$		;No more, so no match			;028
	MOVB	(R2)+,R4	;Pick up a character			;028
	CMPB	R4,#140		;Is it lowercase?			;028	
	BLO	100$		;No, not this time			;028
	BICB	#40,R4		;Yes, so make uppercase			;028
100$:	CMPB	R4,R5		;Character match?			;028
	BEQ	90$		;Yes, try another one			;028
110$:	MOV	#TLCNTD,R1	;Mismatch, set up for ?What?		;028
	BR	55$		;And give it				;028

120$:	CALLX	CLRFQX		;Clear out the FIRQB and XRB		;028
	MOV	#140000+XRB,R5	;R5 -> (Mapped) XRB			;028
	MOV	R1,(R5)+	;Set up the length			;028
	BEQ	110$		;Nothing there, give an error		;028
	MOV	R1,(R5)+	;Set up the length in the second place	;028
	MOV	R2,(R5)		;Now set up the address			;028
	SUB	#140000,(R5)	;And correct for user mapping		;028
	MOV	#-1,@#140000+FIRQB+FQEXT ;Default to wild file type	;028
	DOCALL	.FSS		;And scan that string			;028
	MOVB	(R0),R1		;Pick up any error code			;028
	BNE	55$		;And report it if we have one		;028
	TST	XRBC(R5)	;Anything unscannable?			;028
	BNE	110$		;Yes, so report an error		;028
130$:	DOCALL	.RUN		;Go run some program			;028

; After issuing the .RUN, we can get back here for two reasons. One
; is an error code in the FIRQB, which we report. The other reason
; is because the program was found, but doesn't run under NULRTS.
; NULRTS runs use the complex EMT mechanism, and will cancel the
; return from our DOCALL. Other runs do not have that effect, so we
; must do a RETURN to get to the new RTS at P.RUN.

	MOVB	(R0),R1		;Pick up the error code			;028
	BNE	55$		;Report any possible error code		;028
140$:	RETURN			;All done now...			;028

GLOBAL	<NULRTS,TLCNTD,UDPAR0>						;030

.SBTTL	Set previous mode routine

;+									;039+
;	Set the Previous mode in the PSW to what was indicated in
;	the mode bits of the traped PSW at SYSTAK-2
;
;		CALL	SETPRE
;
; on return:
;	Previous mode in PSW set
;	R5 is random
;	carry value becomes random
;-

SETPRE::								;039
	BIC	#30000,@#PS	;preset to lowest value	SPLC
	MOV	@#<SYSTAK-2>,R5	;get the user's real PSW
	ROR	R5		;position current mode to prev spot
	ROR	R5
	BIC	#147777,R5	;remove all but prev mode bits
	BIS	R5,@#PS		;set in current PSW	SPLC
	RETURN
									;039-


.SBTTL	FINAL FIXUPS

.EQUATE	DICMAX,	209.		;DEFINE MAXIMUM DIC (FOR 2ND PASS)	;038

.END
