	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
TITLE	UPE,<UNIBUS PARITY/ECC CODE>,0A,10-MAY-91,MHB/ABC/SHG/SJM/FEK

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR UPE
;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;  001	RVR/TG 02-Sep-80	Fixed ECC memory check bug
;  002	SJM  08-Jul-81	Add I&D space support
;
;			[RSTS/E V10.0]
;  003	FEK  20-Mar-90	Add large no-address root CSR support (for KDJ11-E)
;-


	DEFORG	UPE

	DEFORG	UPEISP

	DEFORG	UPECTL

	ORG	UPEISP

	TMPORG	UPECTL



;+
; UNIBUS PARITY/ECC REGISTER TABLES.
;
;	THESE TWO TABLES ARE FILLED IN TO DESCRIBE THE UNIBUS PARITY
;	CSR CONFIGURATION ON THE SYSTEM.
;
;	A "PARCSR" ENTRY IS EITHER A POINTER TO 'PARZER' (WHICH LOOKS
;	LIKE A PARITY CSR WITH NO ERROR CONDITION) FOR A NON-EXISTENT
;	CSR OR A POINTER TO THE CSR ITSELF WHEN IT EXISTS.
;
;	FOR EXISTING CSR'S, THE CORRESPONDING ENTRY IN "RNGCSR" IS ALSO
;	FILLED IN AS FOLLOWS:
;
;		BITS   4-0	THE CSR'S RANGE IN K (1 TO 31.)
;		BITS  11-5	THE CSR'S BASE ADDRESS (IF BIT 15=1)
;				    If bits 14-13 <> 01 then base address
;				    If bits 14-13 = 01 then part of range
;		BIT     12	1 => ECC MEMORY
;		BITS 14-13	00 => NON-INTERLEAVED MEMORY
;				01 => BIG NOADDRESS CSR
;				    (Bits 11-0 are the range)
;				    (Base is always 0)
;				10 => INTERLEAVED, EVEN BANK, MEMORY
;				11 => INTERLEAVED, ODD BANK, MEMORY
;		BIT     15	0 => BASE ADDRESS IS IN THE CSR ITSELF
;				1 => BASE ADDRESS IS IN THE RANGE WORD
;-

$$PCSR	==	.	;**INIT** PARITY CSR ADDRESSES ARE FILLED IN
PARCSR:	.BLKW0	16.,PARZER	;THE 16. POSSIBLE UNIBUS PARITY CSR'S
	.WORD	0		;TERMINATING ZERO WORD

$$PRNG	==	.	;**INIT** PARITY CSR RANGES ARE FILLED IN
RNGCSR:	.BLKW0	16.		;THE 16. RANGES FOR THE ABOVE CSR'S

$$PMSK	==	.	;**INIT** PARITY SCANNING ERROR BIT MASK
PARMSK:	.WORD	000020		;ERROR BIT(S) TO DETECT ONCE A SECOND

ECCDNE:	.BLKW0	16.		;SO WE CAN LOG SINGLE BIT ERRORS ONLY ONCE...

	UNORG

GLOBAL	<PARZER>

;+
; UNISCN - SCAN FOR A UNIBUS PARITY/ECC ERROR.
;
;	CALL	UNISCN
;
;	R0 =  RANDOM
;	R1 =  RANDOM
;	R2 =  RANDOM
;	R3 =  RANDOM
;	UPELOG  +0 = ADDRESS OF CSR WITH ERROR
;	UPELOG  +2 = CONTENTS OF CSR WITH ERROR AND LOW ORDER ADDRESS
;	UPELOG	+4 = CONTENTS OF CSR WITH ERROR AND HIGH ORDER ADDRESS
;	UPELOG  +6 = RANGE OF ERROR IN K
;	UPELOG +10 = COUNT OF FAILING ADDRESSES
;	UPELOG +12 = BASE ADDRESS OF ERROR /100
;	UPELOG +14 = LIST OF FAILING ADDRESS OFFSETS
;	UPELSZ     = UPELSZ + 6 + # FAILING ADDRESS(ES)
;	HGHAD, LOWAD = ADDRESS OF ERROR
;-

UNISCN::MOV	@#PS,-(SP)	;;;SAVE CALLING PRIORITY
	SPLC	7		;;; THEN SET NO INTERRUPTS
	MOV	#100000,R3	;;;GUESS AT ONLY ERROR CHECKING
	CMP	2(SP),#FTLSCN	;;;GOOD GUESS?
	BEQ	10$		;;;YES
	MOV	PARMSK,R3	;;;NO, CHECK ACCORDING TO THE MASK
	MOV	#4*400+4,UPELSZ	;;;INITIALIZE SIZE (& FIELD 4)
10$:	MOV	#PARCSR,R0	;;;GET POINTER TO TABLE OF CSR'S
	MOV	#JUNK,R2	;;;SET FOR THE FIRST RE-ENABLE JAM
20$:	MOV	#1,(R2)		;;;NO ERROR, BUT RE-ENABLE THE CSR
	MOV	(R0)+,R2	;;;GET NEXT PARITY CSR IN TABLE
	BNE	25$		;;; Not at the end yet, so continue	;003
	JMP	120$		;;;END OF TABLE, JUST EXIT

25$:	MOV	(R2),R1		;;;ELSE GET CONTENTS OF CSR
	BIT	R1,R3		;;;FOUND SOMETHING?
	BEQ	20$		;;;NOT YET...
	BMI	30$		;;;FOUND, A REAL ERROR AT THAT
	TST	ECCDNE-PARCSR-2(R0) ;;;SINGLE BIT ERROR, ALREADY LOGGED?
	BNE	20$		;;;YES, SO SKIP IT NOW
	MOV	R1,ECCDNE-PARCSR-2(R0) ;;;NO, BUT INDICATE WE WILL LOG IT

GLOBAL	<FTLSCN,UPELSZ,JUNK>

30$:	MAP	PUSH,APR=6,DATA	;;;REAL ERROR, SAVE PAR6 VALUE
	MOV	R4,-(SP)	;;; AND R4
	MOV	R5,-(SP)	;;;  AND R5
	MOV	#UPELOG,R3	;;;GET LOG AREA POINTER
	ADD	#6,UPELSZ	;;; AND SAY SOMETHING IS IN IT
	MOV	R2,(R3)+	;;;SAVE ADDRESS OF CSR WITH ERROR
	MOV	R1,(R3)+	;;; AND SAVE CONTENTS OF THE CSR WITH LOW ADDR
	MOV	#40000,(R2)	;;;FETCH HIGH ORDER ADDRESS BITS INTO CSR
	MOV	(R2),(R3)+	;;; AND SAVE CONTENTS OF THE CSR
	MOV	RNGCSR-PARCSR-2(R0),R0 ;;;NOW GET RANGE OF THE ERROR
	MOV	R0,R5		;;; AND SAVE IT HERE
	BPL	40$		;;;BASE IS IN C(CSR)
	MOV	R0,R1		;;;BASE IS IN RANGE WORD
40$:	BIC	#^C<7740>,R1	;;;ISOLATE THE BASE ADDRESS (/100)
	BNE	46$		;;; Can't be a big CSR			;003
	BIC	#^C<7777>,R0	;;; and the BIG range (if a BIG CSR)	;003
	BIT	#40000,R5	;;;Interleaved?				;003
	BNE	46$		;;; Yes, so not a BIG CSR		;003
	BIT	#20000,R5	;;; BIG or small?			;003
	BEQ	46$		;;;  Its a small			;003
	CLR	R5		;;; Turn off all the flags		;003
	BR	48$		;;;BIG NOADDRESS CSR			;003

46$:	BIC	#^C<37>,R0	;;; AND ISOLATE THE RANGE
48$:	MOV	R0,(R3)+	;;;SAVE RANGE IN K IN LOG
	CLR	(R3)+		;;;START COUNT AT ZERO
	MOV	R1,(R3)+	;;;SAVE BASE IN LOG
	CLR	(R3)		;;;DUMMY IN INITIAL OFFSET OF 0
	ASL	R5		;;;CHECK FOR INTERLEAVED
	ASL	R5		;;; AND/OR ODD BANK
	BPL	50$		;;;BIT 13=0 => EVEN BANK
	MOV	#2,(R3)		;;;BIT 13=1 => ODD BANK
50$:	MOV	#2,R5		;;;GUESS AT NON-INTERLEAVED MEMORY
	BCC	60$		;;;BIT 14(CARRY NOW)=0 => NON-INTERLEAVED
	ASL	R5		;;;BIT 14(CARRY NOW)=1 => INTERLEAVED (R5=4)
60$:	TST	UPELOG+2	;;;ERROR OR CORRECTABLE?
	BPL	100$		;;;ONLY CORRECTABLE, NO RE-SCAN
	MAP	R1,APR=6,DATA	;;;NOW LOAD BASE OF ERROR INTO PAR6
	MOV	#140000,R4	;;;SET VIRTUAL STARTING BIAS
	MOV	R4,R1		;;;SET VIRTUAL BASE FOR SCAN
	ADD	(R3),R1		;;; WITH CORRECT STARTING POINT

GLOBAL	<UPELOG,UPELSZ>

70$:	CLR	(R2)		;;;DISABLE THIS PARITY CSR
	TST	(R1)		;;;CHECK DATA AT THAT LOCATION
	TST	(R2)		;;;DID READ CAUSE ERROR?
	BPL	90$		;;;NOPE
	INC	UPELOG+10	;;;YEP, COUNT AS A FOUND ERROR
	CMP	R3,#UPELGE	;;;ROOM LEFT TO STORE ANOTHER?
	BHIS	80$		;;;NO ROOM LEFT
	MOV	R1,(R3)		;;;ELSE SET THE VIRTUAL ADDRESS AND
	SUB	R4,(R3)+	;;; FIND THE FAILING OFFSET
	INC	UPELSZ		;;;  AND COUNT AS ANOTHER STORED

;NOTE: THE FOLLOWING CODE WAS REMOVED DUE TO ECC/PARITY ERROR CONTEXT LOSS

80$:	;MOV	#2,(R2)		;;;TURN OFF ECC CORRECTIONS
	;MOV	(R1),(R1)	;;;TRY TO CORRECT THE ERROR
	;CLR	(R2)		;;;TURN ECC CORRECTIONS BACK ON

90$:	ADD	R5,R1		;;;GO TO NEXT WORD IN VIRTUAL POINTER
	CMP	R1,#140000+4000	;;;OUTSIDE OF A 1K RANGE?
	BLO	70$		;;;NO, JUST LOOP
	ADD	#4000/100,@DPAR6 ;;;YES, ADVANCE MAPPING REGISTER
	SUB	#4000,R4	;;; AND CHANGE BIAS VALUE
	SUB	#4000,R1	;;;  AND THE VIRTUAL POINTER
	SOB	R0,70$		;;;LOOP FOR MORE
100$:	MOV	#UPELOG+12,R3	;;;GET LOG POINTER
	MOV	(R3)+,R1	;;;GET BASE OF ERROR(S)
	CLR	R0		;;;CLEAR A HIGH ORDER AND
	ASHC	#6,R0		;;; FIND BASE AS REAL ADDRESS
	ADD	(R3),R1		;;;NOW ADD IN THE OFFSET
	ADC	R0		;;; WITH CARRY IF NEEDED
	MOV	R1,LOWAD	;;;THIS IS THE LOW ORDER ADDRESS
	MOV	UPELOG+4,R5	;;;GET CONTENTS OF CSR WITH HIGH ORDER ADDRESS
	BIT	#40000,R5	;;;WERE WE ABLE TO GET HIGH ORDER ADDRESS?
	BEQ	110$		;;;NO, PRINT HIGH ORDER ADDRESS AS IS
	BIC	#^C<7740>,R5	;;;ISOLATE HIGH ORDER ERROR ADDRESS
	CLC			;;;MAKE SURE CARRY IS CLEAR FOR ROTATE
	ASHC	#-3,R5		;;;ROTATE BITS TO THE RIGHT POSITION
	ADD	R5,R0		;;;AND ADD IT INTO THE PRESENT HIGH ORDER ADDR
110$:	MOV	R0,HGHAD	;;; AND THIS IS THE HIGH ORDER
	MOV	#1,(R2)		;;;RE-ENABLE TRAPS FOR THIS CSR
	MOV	(SP)+,R5	;;;RESTORE R5
	MOV	(SP)+,R4	;;; AND R4
	MAP	POP,APR=6,DATA	;;;  AND THE PAR6 VALUE
	CMP	2(SP),#FTLSCN	;;;WAS THIS THE TRAP @ 114 CALL?
	BEQ	120$		;;;YES, EXIT, ERROR LOGGED LATER
	CLR	MEMERR		;;;NO, SAY NOT CPU ERROR
	CLR	-(SP)		;;; BY FAKING A PS
	CLR	-(SP)		;;;  AND PC
	LOG$PA			;;;SO LOG IT ALREADY
	CMP	(SP)+,(SP)+	;;;POP THAT FAKE PC/PS
120$:	MOV	(SP)+,@#PS	;;;RESTORE CALLING PRIORITY
	RETURN			;;;NOW EXIT

GLOBAL	<UPELOG,UPELGE,UPELSZ,LOWAD,HGHAD,FTLSCN,MEMERR,DPAR6>

.END

