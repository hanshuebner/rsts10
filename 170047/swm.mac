	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
TITLE	SWM,<SWAP MANAGER>,0A,10-MAY-91,MHB/ABC/MJG/GPK/MNB/KPH/FRL

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR SWM

;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;  001	TG   27-Jun-80	Added GEN phase stuff
;
;				[RSTS V8.0]
;  002	GPK  11-Nov-82	Eliminate potential deadlock when swapping images
;			> 31K in size
;
;				[RSTS V9.0]
;  003	GPK  04-Mar-83	Job headers
;  004	GPK  21-Sep-83	Bugfix in swap error handling
;  005  MNB  15-Dec-83  Asynch changes to M.CTRL byte
;
;				[RSTS V9.2]
;  006  KPH  25-Jul-85	Pass job # to BADRTS
;			Add job control region
;
;				[RSTS V9.3]
;  007  FRL  24-Mar-86	Large library support
;-


	DEFORG	SWM

.DSECT			;VERIFY ORDER WITHIN DSQ

	.BLKW		;QUEUE LINK WORD
DSQJOB:	.BLKB		;JOB # *2 OF REQUESTOR
DSQERR:	.BLKB		;RETRY COUNT AND ERROR FLAG
DSQL3Q:	.BLKW		;COMPLETION QUEUE AND L3Q BITS TO SET
DSQUNT:	.BLKB		;FIP UNIT NUMBER
DSQFBM:	.BLKB		;FIP BLOCK NUMBER (MSB)
DSQFBL:	.BLKW		;FIP BLOCK NUMBER (LSB)
DSQRFN:	.BLKB		;RH11 FUNCTION
DSQMAM:	.BLKB		;MEMORY ADDRESS OF THE TRANSFER (MSB)
DSQMAL:	.BLKW		;MEMORY ADDRESS OF THE TRANSFER (LSB)
DSQCNT:	.BLKW		;WORD COUNT OF THE TRANSFER
DSQFUN:	.BLKB		;OPERATION FUNCTION CODE
DSQFAR:	.BLKB		;QUEUE FAIRNESS OR PRIORITY
DSQMSC:	.BLKW		;MEMORY CONTROL BLOCK POINTER
DSQTOT:	.BLKW		;NUMBER OF PENDING SUB-TRANSFERS

	UNORG

SWDONE:	CALLX	SIGMEM		;SWAP COMPLETION(S) DONE, SIGNAL 'MEM'

.SBTTL	CHECK FOR SWAP INITIATIONS

;+
; CHKSWP - CHECK FOR SWAPS IN AND/OR OUT.
;
;	JMP	CHKSWP
;
;	RETURN IS TO "RTI3"
;-

	TMPORG	GENDSP,2
	.WORD	CKSWP
	UNORG

CKSWP:	MOV	#MEMLST,R1	;GET ROOT OF MEMORY CONTROL LIST
10$:	BITB	#SWP,M.CTRL(R1)	;SWAP REQUESTED?
	BEQ	20$		;NO
	CLR	R0		;Yes, get size of			;007
	BISB	M.SIZE(R1),R0	; the swap in K				;007
	CALL	DOSWAP		; AND START UP THAT SWAP
	BVS	30$		;NO BUFFER(S), EXIT NOW
20$:	MOV	M.PNXT(R1),R1	;GO TO THE NEXT IN THE LIST
	BNE	10$		;MORE
30$:	JMPX	RTI3		;END, SO ALL DONE

GLOBAL	<MEMLST>

.SBTTL	PROCESS SWAP COMPLETIONS

.ENABL	LSB

10$:	MOVB	#MC.LCK,M.CTRL(R2) ;RTS/LIB load complete, inc LCK	;005
	SUB	#R.MCTL,R2	;BACK UP TO TOP OF RTS/LIB BLOCK
	MOV	#JOBTBL,R5	;GET JOB TABLE FOR ALL THOSE...
20$:	MOV	(R5)+,R1	;ANYONE HERE?
	BEQ	20$		;NO, LOOP
	INC	R1		;YES, BUT IS IT THE END(-1)??
	BEQ	70$		;END, DONE
	INC	R1		;ADVANCE TO JDFLG IN THE JDB
.ASSUME	JDFLG	EQ	1+1
	MOV	R5,R0		;Copy JOBTBL pointer			;006
	SUB	#JOBTBL+2,R0	;And get job # * 2			;006
	TSTB	DSQERR(R4)	;WAS THE RTS/LIB LOAD IN ERROR?
	BMI	30$		;NOPE
	CALLX	BADRTS		;YEP, SWITCH RTS IF JOB USING THE BAD RTS/LIB
30$:	CMP	R2,JDRTS-JDFLG(R1) ;IS THIS JOB USING THIS RTS/LIB?
	BEQ	60$		;YES, SIGNAL RESIDENCY
	MOV	R2,R3		;SAVE POINTER TO RTS/LIB BLOCK
	CALLX	LIBSUB,R5	;RETURNS WITH ALL MAPPED LIBRARIES
	  BR	40$		;CHECK FOR MAPPED ATTACHES
	MOV	R3,R2		;RESTORE WORKING REGISTER
	BR	20$		;LOOP

40$:	CMP	R3,R2		;IS THE JOB ATTACHED TO THIS BLOCK?
	BEQ	50$		;YES, SIGNAL RESIDENCY
	RETURN			;BACK TO CO-ROUTINE

50$:	ADD	#2,(SP)		;Signal special co-routine exit		;006
	CALL	@(SP)+		;And do it				;006
	;MOV	R3,R2		;RESTORE WORKING REGISTER
60$:	MOV	JDRESB-JDFLG(R1),R0 ;YES, GET L3Q BIT(S) FOR RESIDENCY
	BEQ	20$		;NONE, LOOP
	CALLX	L3QSE0,R5	;SOME, SO SET THEM
	CLR	JDRESB-JDFLG(R1) ;BUT DON'T KEEP DOING IT...
	BR	20$		;NOW LOOP...

GLOBAL	<JOBTBL>

70$:	CALL	RETDSQ		;FREE UP THE DSQ

	L3QENT	QSWAPC,,GENAP5	;SWAP COMPLETIONS COME HERE

80$:	MOV	SWDONQ,R4	;GET TOP-OF-QUEUE ITEM
	BEQ	SWDONE		;NO MORE, CHECK FOR STARTING SWAPS
	MOV	@SWDONQ,SWDONQ	;DE-QUEUE THE TOP ITEM
	MOV	DSQMSC(R4),R2	;GET MEMORY CONTROL BLOCK POINTER (MAYBE)
	TST	DSQTOT(R4)	;IS THIS A PENDING SUB-TRANSFER?
	BEQ	110$		;NO
	MOVB	DSQERR(R4),R1	;ANY ERRORS ON THE SWAP?
	BMI	90$		;NO
	MOVB	R1,DSQERR(R2)	;ALWAYS SAVE THE LAST ERROR ENCOUNTERED
90$:	DEC	DSQTOT(R2)	;SIGNAL ONE LESS PENDING SUB-TRANSFER
	BNE	70$		;LOOP
	MOV	DSQCNT(R2),R3	;ANY UNFINISHED BUSINESS WITH THIS SWAP?
	BEQ	100$		;NO
	CALL	SWPSUB		;INITIATE REST OF SUB-TRANSFERS
	BR	80$		;LOOP AND WAIT FOR THEM TO COME IN

100$:	CALL	RETDSQ		;RETURN SUB-TRANSFER BUFFER
	MOV	R2,R4		;POINT TO MASTER COPY OF DSQ
	MOV	DSQMSC(R4),R2	;GET MEMORY CONTROL BLOCK POINTER
110$:	MOV	R2,R1		;BUILD A POINTER TO THE
	SUB	#JDMCTL,R1	; JDB (IF THIS IS A JOB!)
	BICB	#IN!LCK,M.CTRL(R2) ;CLEAR SOME STATUS BITS 		;005
				;(LCK count here is "1")		;005
	BNE	140$		;IT WAS A SWAP OUT...
	BIT	R2,#20		;IT WAS A SWAP IN, IS IT A JOB?
	BEQ	10$		;NO, A RTS/LIB LOAD
.ASSUME	JDMCTL	EQ	20
	MOV	JDRESB(R1),R0	;A JOB, GET L3Q BIT(S) TO SET ON RESIDENCY
	BNE	120$		;BIT(S) TO SET EXIST
	CALLX	CLRRSQ		;NO BITS, SO "FORCED", CLEAR RES QUANTUM
	BR	130$		; AND CONTINUE

GLOBAL	<GENAP5,SWDONQ>

120$:	CALLX	L3QSE0,R5	;NOW GO SET THOSE BIT(S)
	CLR	JDRESB(R1)	;NO MORE RESIDENCY L3Q BIT(S)
130$:	MOVB	JDJBNO(R1),R0	;Get job # * 2				;006
	MOV	R1,-(SP)	;Save JDB pointer			;006
	CALLX	MAPJCR		;Map JCR entry				;006
	MOV	R1,R5		;Copy JCR pointer			;006
	MOV	(SP)+,R1	;And restore JDB pointer		;006
	CLR	R3		;GET JOB'S SWAP SLOT
	BISB	JCSWAP(R5),R3	; WITHOUT SIGN EXTENSION		;006
	BEQ	160$		;NONE, JUST FINISH UP
	CLRB	JCSWAP(R5)	;ONE, CLEAR IT OUT			;006
	MOV	R3,R5		;COPY THE VALUE
	BIC	#^C<7>,R5	; AND LEAVE THE BIT OFFSET HERE
	ASH	#-3,R3		;FIND BYTE OFFSET HERE
	MOV	R3,R0		;COPY BYTE OFFSET TO
	ASH	#-3,R0		; FIND THE FILE # (0-3)
	DECB	SWPUSE(R0)	;ONE LESS SLOT IN USE NOW
	BMI	160$		;FILE DISABLED, JUST FINISH UP
	BISB	BITBYT(R5),SWPMAP(R3) ; ELSE FREE UP THIS SWAP SLOT
	BR	160$		;NOW WE CAN FINISH UP

140$:	MOVB	M.CTRL(R2),-(SP) ;SAVE THE MEMORY CONTROL BYTE
	CALLX	REMJOB		;REMOVE SWAPPED OUT JOB FROM MEMORY LIST
	ASRB	(SP)+		;WANT IMMEDIATE RE-RESIDENCY?
	BCC	150$		;NO
.ASSUME	REQ	EQ	1
	MOV	R4,-(SP)	;YES, SAVE THE DSQ POINTER
	CALLX	RESENT		; AND GO MAKE JOB IMAGE RESIDENT AGAIN
	MOV	(SP)+,R4	;RESTORE THE DSQ POINTER
150$:	DEC	SWOCNT		;ONE LESS SWAP OUT IN PROGRESS
160$:	TSTB	DSQERR(R4)	;ANY ERROR?
	BMI	70$		;NO
	BIS	#JFSPCL,JDFLG(R1) ;YES, A SPECIAL CONDITION
	BISB	#JFSWPE,JDFLG2(R1) ; AS A SWAP ERROR
	MOV	R4,-(SP)	;Save DSQ address			;003
	MOV	R1,R4		;Copy JDB pointer			;003
	ADD	#JDMCTL,R4	;Point to MCSB				;003
	BIS	#J2IHDR,JDFLG3(R1) ;Flag header initialization required	;006
	TSTB	M.CTRL(R4)	;Was this swap an in or an out?		;004
	BNE	170$		;It was a swap out			;004
	CALLX	INIHDR		;Go reinitialize the job header		;003
170$:	MOV	(SP)+,R4	;Restore the DSQ pointer		;003
	BR	70$		;THEN CONTINUE

.DSABL	LSB

GLOBAL	<SWPUSE,BITBYT,SWPMAP,SWOCNT>

.SBTTL	ALLOCATE A DSQ FOR SWAPPING

;+
; To guarantee that the swapper will get a DSQ sooner or later, we need to
; have two DSQs reserved to it.  The reason we need two rather than just one
; is that swaps of more than 31K (i.e. 32K jobs or large libraries) are done
; in pieces, and an additional DSQ is then used for context.
;
; GETDSQ allocates the swapper's private DSQs first, if available, otherwise
; it tries for the system's small buffer pool.  If that fails also, the swap
; will be retried later; eventually we will succeed because eventually the
; reserved DSQs will free up.
;
;	CALL	GETDSQ
;
;	V = 0	Success
;	R4 ->	DSQ
;
;	V = 1	Failure
;	R4	Random
;-

GETDSQ:	MOV	#SWPDSQ,R4	;Point to our private DSQ
	TST	DSQMSC(R4)	;In use?
	BEQ	10$		;No, so use it
	MOV	#SWPDS2,R4	;Otherwise try for the second private DSQ
	TST	DSQMSC(R4)	;How about this one?
	BEQ	10$		;Free, so done
	BUFFER	GETSML,0	;As last resort, get a small buffer
10$:	RETURN




.SBTTL	RELEASE A SWAP DSQ

;+
;	R4 ->	DSQ
;
;	CALL	RETDSQ
;
;-

RETDSQ:	CLR	DSQMSC(R4)	;Indicate this DSQ is free
	CMP	R4,#SWPDSQ	;Our private DSQ?
	BEQ	10$		;Yes, don't return it
	CMP	R4,#SWPDS2	;Second private DSQ?
	BEQ	10$		;Yes, don't return it
	BUFFER	RETSML		;No, return it to monitor's pool
10$:	RETURN			;Exit

GLOBAL	<SWPDSQ,SWPDS2>

.SBTTL	START UP A SWAP

;+
; DOSWAP - START UP A SWAP IN OR OUT.
;
;	R0 =  SIZE OF THE SWAP IN K
;	R1 -> MEMORY CONTROL BLOCK
;
;	CALL	DOSWAP
;
;	R0 =  RANDOM
;	R1 -> SAME MEMORY CONTROL BLOCK
;	R2 =  RANDOM
;	R3 =  RANDOM
;	R4 =  RANDOM
;	R5 =  RANDOM
;
;	IF V=1 THEN SWAP NOT STARTED DUE TO NO BUFFER(S)
;	IF V=0 THEN SWAP HAS BEEN STARTED
;-

	.ENABL	LSB

DOSWAP::CALL	GETDSQ		;Allocate a DSQ for the swap
	BVS	110$		;FAILURE, GO AWAY FOR A WHILE...
	ADD	#DSQTOT,R4	;INDEX INTO THE DSQ
	CLR	(R4)		;NO SUB-TRANSFERS YET
	MOV	R1,-(R4)	;STORE MEMORY CONTROL BLOCK POINTER @ DSQMSC
	MOVB	#-1,-(R4)	;SWAPS HAVE A HIGH PRIORITY (@ DSQFAR)
..SWHP	==	.-2	;**PATCH** 0 FOR NO HIGH PRIORITY SWAPS
	MOVB	M.CTRL(R1),-(R4) ;SET FUNCTION CODE @ DSQFUN
	BICB	#^C<6>,(R4)	;NOW A REAL FUNCTION CODE
.ASSUME	RFUN	EQ	SWP!IN&6					;005
.ASSUME	WFUN	EQ	SWP!OUT&6					;005
	MOV	R0,-(R4)	;SAVE K SIZE @ DSQCNT
	CLR	R2		;CLEAR HIGH ORDER AND
	MOV	M.PHYA(R1),R3	; SET LOW ORDER PHYSICAL ADDRESS /100
	ASHC	#6,R2		;NOW FIND REAL PHYSICAL ADDRESS
	MOV	R3,-(R4)	;SET <15-0> @ DSQMAL
	MOVB	R2,-(R4)	;SET <21-16> @ DSQMAM
	DEC	R4		;SKIP RH11 FUNCTION (DSQRFN)
	MOV	#DISK,R5	;SET ADDRESS OF COMMON DISK I/O STARTER

GLOBAL	<SWPDSQ,DISK>

	CLR	R0		;GUESS AT RTS LOAD (JOB = 0)
	MOV	R.DATA+F.FBNL-R.MCTL(R1),-(R4) ;SET LSB DISK ADDR @ DSQFBL
	MOV	R.DATA-R.MCTL(R1),-(R4) ;SET MSB/UNIT @ DSQFBM/DSQUNT
	BIT	R1,#20		;REALLY A JOB SWAP?
	BEQ	90$		;NO, A RTS LOAD, ALL SET UP
.ASSUME	JDMCTL	EQ	20
	MOV	R1,R2		;COPY JDB POINTER @ JDMCTL
	MOVB	JDJBNO-JDMCTL(R2),R0 ;Pick up job # * 2			;006
	BITB	#IN,M.CTRL(R1)	;SWAP IN OR OUT?
	BNE	70$		;IT IS A SWAP IN
	MOV	#SWPMPE,R2	;SWAP OUT, GET SWAP MAP END POINTER
	MOV	JBWAIT(R0),R3	;GET JOB'S WAIT STATE
	BEQ	50$		;HIBERNATING, SWAP SLOWLY...
	BIT	R3,JBSTAT(R0)	;RUNNABLE NOW?
	BNE	30$		;YES, USE FASTEST POSSIBLE
	BIT	R3,#JSTIM	;ELSE IS JOB TIMING OUT?
	BNE	50$		;GO SLOW IF TIMING
30$:	MOV	#SWPMAP,R2	;POINT TO START OF SWAP MAPS
40$:	TST	(R2)+		;FORWARD SCAN FOR A WORD WITH
	BEQ	40$		; SOME SLOT FREE (BIT=1)
50$:	MOVB	-(R2),R3	;GET A MAP BYTE
	BEQ	50$		;NOTHING FREE, LOOP
	MOV	R2,-(SP)	;A FREE SLOT HERE, SAVE POINTER
	SUB	#SWPMAP,R2	;NOW FIND MAP OFFSET (0-37)
	MOV	R2,-(SP)	;SAVE MAP OFFSET VALUE
	ASH	#3,R2		;MAKE OFFSET INTO 0-370 RANGE
	DEC	R2		;SLIGHT CORRECTION FOR LOOP BELOW
60$:	INC	R2		;ADVANCE TO NEXT SWAP SLOT
	ASR	R3		;IS IT THE FREE ONE?
	BCC	60$		;NO, LOOP
	MOV	R1,-(SP)	;Get a scratch register			;006
	CALLX	MAPJCR		;Map the JCR entry			;006
	MOVB	R2,JCSWAP(R1) 	;Set the swap slot			;006
	MOV	(SP)+,R1	;And restore the JDB @ JDMCTL pointer	;006
	MOV	(SP)+,R3	;GET BACK MAP OFFSET VALUE
	ASH	#-3,R3		;MAKE INTO SWAP FILE # (0-3)
	INCB	SWPUSE(R3)	; AND COUNT AS 1 MORE SLOT IN USE
	BIC	#^C<7>,R2	;TRIM FOR ONLY THE BIT OFFSET AND
	BICB	BITBYT(R2),@(SP)+ ; MARK THIS SWAP SLOT AS IN USE

GLOBAL	<JOBTBL,SWPMPE,JBWAIT,JBSTAT,SWPMAP,SWPUSE,BITBYT>

70$:	MOV	R1,-(SP)	;Save JDB @ JDMCTL pointer		;006
	CALLX	MAPJCR		;Map the JCR entry			;006
	CLR	R2		;GET THE SWAP SLOT WITHOUT
	BISB	JCSWAP(R1),R2	; SIGN EXTENSION			;006
	BNE	80$		;A REAL SLOT EXISTS
	MOV	#DISKNE,R5	;NO SLOT, DON'T DO ANYTHING!
80$:	MOV	(SP)+,R1	;Restore JDB @ JDMCTL pointer		;006
	MOV	R2,R3		;COPY THE SWAP SLOT
	BIC	#^C<77>,R3	;ISOLATE THE SLOT # HERE (0-77)
	BIC	R3,R2		;TRIM BITS TO AVOID ODD ADDRESSES
	ASH	#-6+3,R2	;ISOLATE THE FILE # *8. HERE (0-3)
	MOV	SWBASE(R2),(R4)+ ;SET HIGH ORDER AND UNIT @ DSQFBM/DSQUNT
	MOV	SWBASE+2(R2),(R4) ;SET LOW ORDER DISK ADDRESS @ DSQFBL
	DEC	R3		;MAKE SLOT # INTO 0-76 (-1 NEVER OCCURS!)
	ASL	R3		;NOW TIMES 4 FOR
	ASL	R3		; 4 BLOCKS PER K
	MUL	SWPMAX,R3	;FIND BLOCK OFFSET WITHIN FILE
	ADD	R3,(R4)		;ADD TO LOW ORDER AND
	ADCB	-(R4)		; CARRY TO HIGH ORDER IF NEEDED
	DEC	R4		;CORRECT THE DSQ POINTER
90$:	MOV	#SWDNE,-(R4)	;SET COMPLETION QUEUE/BITS @ DSQL3Q
	MOVB	#-1,-(R4)	;SET NO ERRORS @ DSQERR
	MOVB	R0,-(R4)	;SET JOBNO*2 @ DSQJOB
	CLR	-(R4)		;NOW, FINALLY, UP TOP
	BICB	#SWP,M.CTRL(R1)	;SAY SWAP IN PROGRESS NOW
	MOV	DSQCNT(R4),R0	;GET SAVED TRANSFER COUNT IN 1K-WORDS
	CMP	R0,#31.		;TRYING TO SWAP >31K?
	BHI	120$		;YES
100$:	ASH	#11.-1,R0	;MAKE K SIZE A WORD COUNT
	MOV	R0,DSQCNT(R4)	;SET WORD COUNT @ DSQCNT
	CALL	(R5)		;CALL FOR I/O INITIATION
	;CLV			;V=0 FROM "DISK" RETURN
110$:	RETURN			;NOW EXIT

120$:	MOV	R0,R3		;SAVE ORIGINAL TRANSFER SIZE IN 1K-WORDS
	MOV	R4,R2		;SAVE ORIGINAL DSQ POINTER
130$:	CALL	GETDSQ		;Get another DSQ
	BVC	SWPSUB		;SUCCESS, CONTINUE
	CMP	R3,DSQCNT(R2)	;HAVE ANY SUB-TRANSFERS GONE OUT?
	BEQ	140$		;NO, SO FLUSH MASTER DSQ
	MOV	R3,DSQCNT(R2)	;YES, SAVE WHATS LEFT TO DO
	RETURN			; SO SWAP COMPLETION CAN PICK UP THE REST

140$:	MOV	R2,R4		;RESTORE POINTER FOR BUFFER RETURN
	CALL	RETDSQ		;FREE UP THE DSQ
	BISB	#SWP,M.CTRL(R1)	;SAY SWAP NEEDED NOW
	SEV			;INDICATE NO BUFFERS AVAILABLE
	RETURN			;GO AWAY FOR AWHILE...

GLOBAL	<DISKNE,SWBASE,SWPMAX,SWDNE>

SWPSUB:	MOV	#DSQSIZ/2,R0	;Set up word count to move
145$:	MOV	(R2)+,(R4)+	;COPY MASTER DSQ INTO SUB-TRANSFER DSQ
	SOB	R0,145$		;Loop
	SUB	#40,R4		;BACK UP SUB-TRANSFER DSQ POINTER TO THE TOP
	SUB	#40,R2		;BACK UP MASTER DSQ POINTER ALSO
	MOV	R2,DSQMSC(R4)	;POINT SUB-TRANSFER BACK TO MASTER DSQ
	MOV	#-1,DSQTOT(R4)	;INDICATE THIS IS A SUB-TRANSFER
	MOV	#31.,R0		;SET MAXIMUM K-WORD COUNT FOR TRANSFER
	CMP	R0,R3		;IS REMAINING COUNT GREATER THAN MAX?
	BLOS	150$		;YES
	MOV	R3,R0		;NO, USE PARTIAL COUNT THEN
150$:	MOV	#DISK,R5	;SET ADDRESS OF COMMON DISK I/O STARTER
	CALL	100$		;CALL FOR I/O INITIATION
	INC	DSQTOT(R2)	;INDICATE ONE MORE SUB-TRANSFER INITIATED
	ASL	R0		;MAKE WORD COUNT INTO A BYTE COUNT
	ADD	R0,DSQMAL(R2)	;UPDATE MASTER MEMORY ADDRESS (LSB) 
	ADCB	DSQMAM(R2)	; AND (MSB) FOR NEXT SUB-TRANSFER
	SWAB	R0		;MAKE BYTE COUNT INTO A BLOCK COUNT
	ASR	R0		; (BYTE/256)/2
	ADD	R0,DSQFBL(R2)	;UPDATE MASTER FIP BLOCK NUMBER (LSB)
	ADCB	DSQFBM(R2)	; AND (MSB) FOR NEXT SUB-TRANSFER
	ASR	R0		;MAKE BLOCK COUNT INTO 1K-WORD SIZE
	ASR	R0		; (BLOCK/2)/2
	SUB	R0,R3		;UPDATE MASTER TRANSFER SIZE
	BHI	130$		;ANY LEFT MEANS MORE WORK TO DO
	MOV	R3,DSQCNT(R2)	;ZERO MASTER TRANSFER SIZE FOR SWAP COMPLETION
	BR	110$		;AT LAST (V=0) FROM MOV

.DSABL	LSB

GLOBAL	<DISK>

.END

