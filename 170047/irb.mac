	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
TITLE	IRB,<IRB/DATA BUFFER PAIR HANDLING>,0A,10-MAY-91,MHB/SJM/KPH

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR IRB
;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;  001	SJM  08-JUL-81	Added I&D space support
;
;			[RSTS/E V9.3]
;  002  KPH  22-Feb-86	Change SYDAP5 to RSTAP5
;
;-

	DEFORG	IRB

.SBTTL	RETURN IRB/DATA BUFFER PAIR

;+
; RETIRB - RETURN IRB/DATA BUFFER PAIR.
;
;	R4 -> IRB
;
;	CALL	RETIRB
;
;	R4 =  UNDEFINED
;-

RETIRB::MOV	IRBCON(R4),-(SP) ;SAVE CONTORTED ADDRESS OF DATA BUFFER
	BUFFER	RETSML		;RETURN THE IRB
	MOV	(SP)+,R4	;GET BACK THE DATA BUFFER'S CONTORTED ADDRESS
	BUFFER	RETURN		; AND REURN IT ALSO
	RETURN			;EXIT

.SBTTL	STORE A CHARACTER USING IRB

;+
; STOIRB - STORE 1 CHARACTER (BYTE) INTO THE BUFFER CHAIN USING IRB.
;
;	R1 -> DDB
;	R2 =  CHARACTER (BYTE) TO STORE
;	R3 =  ADDRESS OF UNLINKED IRB TO USE
;	   =  ADDRESS+37 OF LINKED IRB TO USE
;	   =  0 FOR NO AVAILABLE IRB
;
;	CALL	STOIRB,R5,<OFFSET+FP>
;
;	R3 =  ADDRESS OF SAME UNLINKED IRB TO USE IF IT WAS NOT USED
;	   =  ADDRESS+37 OF SAME IRB (NOW LINKED) IF IT WAS USED
;	   =  0 IF PASSED AS 0
;	R4 =  RANDOM
;
;	IF C=0 THEN THE STORE COMPLETED
;	IF C=1 THEN THE STORE FAILED
;-

.ENABL	LSB

10$:	MOV	R1,R4		;BUILD A POINTER TO THE EMPTY
	TST	-(R4)		; POINTER FOR INITIAL LINKING
	BR	20$		;  THEN GO TRY TO LINK IN THE IRB

STOIRB::ADD	(R5),R1		;INDEX TO FILL POINTER IN THE DDB
	MOV	(R1),R4		; AND GET THE FILL POINTER
	BEQ	10$		;NO FILL POINTER EXISTS
	BIT	R4,#40-2	;FILL POINTER USED UP OR IRB/DATA?
	BNE	40$		;NOPE, ROOM STILL IN SMALL BUFFER, USE IT
	DEC	R4		;ENSURE WE ARE POINTING INSIDE THE BUFFER
	BIS	#40-1,R4	; THEN GO TO OFFSET +37 WITHIN BUFFER
	CMP	R4,R3		;MATCH THE CURRENT DESIRED IRB IN USE?
	BEQ	30$		;YES, KEEP USING IT...
	BIC	#40-1,R4	;NO, GET TO THE TOP IF THE BUFFER
20$:	TST	R3		;IS THERE ANY IRB AT ALL?
	BEQ	40$		;NOPE, NEED TO USE A SMALL BUFFER
	BIT	R3,#40-1	;IS THERE AN AVAILABLE IRB TO LINK?
	BNE	40$		;NOPE, MUST USE A SMALL BUFFER
	CLR	(R3)		;CLEAR LINK TO NEXT IN IRB
	INC	R3		;INDEX TO OFFSET +1 IN IRB
	MOV	R3,(R4)		;NOW LINK THIS TO REST OF CHAIN
	ADD	#40-1,R3	;INDEX TO OFFSET +40 IN IRB
	MOV	R3,(R1)		;SET FILL POINTER TO JUST BEYOND IRB
	DEC	R3		;NOW BACK TO OFFSET +37 WITHIN IRB
	MOV	IRBSIZ-37(R3),R4 ;GET TOTAL SIZE OF THE DATA BUFFER
	ASH	#-9.,R4		;FIND THE CORRECTION AMOUNT
	INC	R4		;PLUS ONE FOR THE IRB'S SMALL BUFFER
	SUB	R4,BC-FP(R1)	;CORRECT THE USAGE QUOTA
30$:	CMP	IRBFPT-37(R3),IRBDPT-37(R3) ;ANY ROOM LEFT IN THE DATA BUFFER?
	BHIS	40$		;NOPE, WE HAVE TO USE A SMALL BUFFER
	MAP	PUSH,APR=6,DATA	;SAVE CALLING PAR6 VALUE
	MAP	IRBMMU-37(R3),APR=6,DATA ;MAP THE DATA BUFFER
	MOVB	R2,@IRBFPT-37(R3) ;STORE CHARACTER IN THE DATA BUFFER
	MAP	POP,APR=6,DATA	;RESTORE CALLING PAR6 VALUE
	INC	IRBFPT-37(R3)	;BUMP THE FILL POINTER
	SUB	(R5)+,R1	;RE-INDEX BACK TO DDB'S TOP
	;CLC			;THE 'SUB' ABOVE CLEARED THE CARRY
	RETURN	R5		;EXIT WITH C=0 FOR STORE COMPLETED

40$:	SUB	(R5),R1		;RE-INDEX BACK TO DDB'S TOP
	JMP	STORE		; AND GO STORE CHARACTER IN SMALL BUFFER

.DSABL	LSB

.SBTTL	STORE A CHARACTER

;+
; STORE - STORE 1 CHARACTER (BYTE) INTO THE BUFFER CHAIN.
;
;	R1 -> DDB
;	R2 =  CHARACTER (BYTE) TO STORE
;
;	CALL	STORE,R5,<OFFSET+FP>
;
;	R4 =  RANDOM
;
;	IF C=0 THEN THE STORE COMPLETED
;	IF C=1 THEN THE STORE FAILED
;-

.ENABL	LSB

	TMPORG	STORE

STORE:	ADD	(R5),R1		;INDEX TO FILL POINTER IN THE DDB
	MOV	(R1)+,R4	;NOW GET THE CURRENT FILL POINTER
	BIT	R4,#40-2	;IS FILL POINTER ALL USED UP (OR IRB/DATA)?
	BNE	20$		;NO, SO USE IT
	BIT	R4,#40-1	;YES, WHICH CASE IS IT??
	BNE	10$		;IRB/DATA CASE, POINTER IS REAL AND INSIDE IRB
	SUB	#40,R4		;SMALL BUFFER @ +40 OR 0, BACKUP TO TOP
	BHIS	10$		;NO UNDERFLOW, SO IT WAS NOT 0
	MOV	R1,R4		;ELSE BUILD A POINTER TO THE EMPTY
	CMP	-(R4),-(R4)	; POINTER FOR INITIAL LINKING
10$:	BIC	#1,R4		;HANDLE IRB/DATA CASE CORRECTLY (OFFSET +1)
	MOV	R4,-(SP)	;SAVE PREVIOUS ADDRESS FOR LINKING
	BUFFER	GETSML,0	;GET ANOTHER BUFFER (NOTHING CLEARED)
	BVS	30$		;FAILED TO GET A BUFFER, PUNT
	DEC	(R1)		;GOT ONE, DECREMENT THE BUFFER COUNT
	CLR	(R4)+		;CLEAR LINK TO NEXT IN NEW BUFFER
	MOV	R4,@(SP)+	;NOW LINK THIS TO REST OF THE CHAIN
20$:	MOVB	R2,(R4)+	;ALL O.K., STORE CHARACTER IN THE BUFFER
	MOV	R4,-(R1)	;NOW UPDATE THE FILL POINTER IN THE DDB
	SUB	(R5)+,R1	;RE-INDEX BACK TO DDB'S TOP
	;CLC			;THE 'SUB' ABOVE CLEARED THE CARRY
	RETURN	R5		;EXIT WITH C=0 FOR STORE COMPLETED

30$:	TST	(SP)+		;DUMP THE STACK ITEM
	JMP	120$		;GO EXIT C=1

	UNORG

.SBTTL	FETCH A CHARACTER

;+
; FETCH - FETCH 1 CHARACTER (BYTE) FROM THE BUFFER CHAIN.
;
;	R1 -> DDB
;
;	CALL	FETCH,R5,<OFFSET+EP>
;
;	R2 =  CHARACTER (BYTE) FETCHED
;	R4 =  RANDOM
;
;	IF C=0 THEN THE FETCH COMPLETED
;	IF C=1 THEN THE FETCH FAILED
;-

	TMPORG	FETCH

FETCH:	ADD	(R5),R1		;INDEX TO THE EMPTY POINTER IN DDB
40$:	MOV	(R1)+,R4	;NOW GET THE EMPTY POINTER
	BEQ	120$		;NO EMPTY POINTER, SO NO MORE CHARACTERS
	BIT	R4,#40-2	;NO MORE HERE OR THE IRB/DATA BUFFER CASE?
	BEQ	70$		;ONE OF THE ABOVE, GO CHECK IT OUT
	CMP	R4,(R1)		;ARE THE TWO POINTERS THE SAME?
	BEQ	120$		;YES, NO MORE CHARACTERS
	MOVB	(R4)+,R2	;ALL O.K., FETCH THE CHARACTER
	CMP	R4,(R1)		;WOULD NEXT FETCH FAIL?
	BNE	50$		;NO
	DEC	R4		;YES, SO FIND THE TOP OF THIS
	BIC	#40-1,R4	; BUFFER AND THEN INDEX TO THE
	TST	(R4)+		;  FIRST STORAGE LOCATION TO
	MOV	R4,(R1)		;   REUSE THE BUFFER AGAIN
50$:	MOV	R4,-(R1)	;NOW UPDATE THE EMPTY POINTER
60$:	SUB	(R5)+,R1	;RE-INDEX BACK TO DDB'S TOP
	;CLC			;THE 'SUB' ABOVE CLEARED THE CARRY
	RETURN	R5		; AND EXIT ALL O.K. (C=0)

70$:	MOV	#40$,-(SP)	;SET RETURN FOR LOOPING FOR ANOTHER TRY...
	BIT	R4,#40-1	;IS IT THE IRB/DATA BUFFER CASE?
	BEQ	90$		;NOPE
	CMP	IRBEPT-1(R4),IRBFPT-1(R4) ;YEP, IS DATA BUFFER ALREADY EMPTY?
	BHIS	80$		;ALREADY EMPTY, RETURN IT AND TRY AGAIN
	MAP	PUSH,APR=6,DATA	;SAVE CALLING PAR6 VALUE
	MAP	IRBMMU-1(R4),APR=6,DATA ;MAP THE DATA BUFFER
	MOVB	@IRBEPT-1(R4),R2 ;FETCH THE NEXT DATA BYTE
	MAP	POP,APR=6,DATA	;RESTORE CALLING PAR6 VALUE
	INC	IRBEPT-1(R4)	;BUMP THE IRB EMPTY POINTER
	TST	(SP)+		; AND DUMP THE STACKED RETURN ADDRESS
	CMP	IRBEPT-1(R4),IRBFPT-1(R4) ;IS THE DATA BUFFER NOW EMPTY?
	BLO	50$		;NOPE
	MOV	#60$,-(SP)	;YEP, SET RETURN FOR EXITING WITH C=0
80$:	CALL	170$		;GO RETURN THE DATA BUFFER
	BR	100$		; THEN RETURN THE IRB

90$:	SUB	#40,R4		;GET BACK TO THIS BUFFER'S TOP
100$:	MOV	(R4),-(R1)	;RESET EMPTY POINTER TO NEXT IN CHAIN
	BNE	110$		;THERE ARE STILL MORE IN THE CHAIN
	CLR	FP-EP(R1)	;NO MORE, SO CLEAR THE FILL POINTER
110$:	BUFFER	RETSML		;NOW RETURN THIS BUFFER
	INC	BC-EP(R1)	; AND COUNT IT AS RETURNED
	RETURN			;  THEN EXIT

120$:	TST	-(R1)		;CORRECT (INDEXED) DDB POINTER
	SUB	(R5)+,R1	;RE-INDEX BACK TO DDB'S TOP
	SEC			;INDICATE FAILURE (C=1)
	RETURN	R5		; AND EXIT WITH C=1

	UNORG

.SBTTL	CLEAR A BUFFER CHAIN

;+
; CLRBUF - CLEARS A WHOLE BUFFER CHAIN ALL AT ONCE.
;
;	R1 -> DDB
;
;	CALL	CLRBUF,R5,<OFFSET+EP>
;
;	R4 =  RANDOM
;
; NOTE: PRIORITY IS RAISED TO PR5 DURING THE CLEAR IF
;	THE CALLING PRIORITY WAS PR4 OR LESS.
;-

	TMPORG	CLRBUF

CLRBUF:	ADD	(R5),R1		;INDEX TO EMPTY POINTER IN THE DDB
	MOV	@#PS,-(SP)	;SAVE THE CALLING PRIORITY
	CMPB	(SP),#PR5	;IS CALLING PRIORITY PR5 OR GREATER?
	BHIS	130$		;YES, LEAVE PRIORITY THE SAME
	SPLC	5		;;NO, RAISE PRIORITY TO PR5 FOR DURATION
130$:	MOV	(R1)+,R4	;;NOW GET THE EMPTY POINTER
	BEQ	160$		;;NO EMPTY POINTER, SO DONE ALREADY
140$:	DEC	R4		;;ENSURE POINTER IS POINTING WITHIN BUFFER
	BIT	R4,#40-1	;;SPECIAL CASE OF IRB/DATA BUFFER?
	BNE	150$		;;NOPE
	CALL	170$		;;YEP, GO RETURN THE DATA BUFFER
150$:	BIC	#40-1,R4	;;POINT TO TOP OF THIS BUFFER
	MOV	(R4),-(SP)	;;SAVE LINK TO THE NEXT BUFFER
	BUFFER	RETSML		;;THEN RETURN THIS BUFFER AND
	INC	BC-FP(R1)	;; COUNT IT AS RETURNED
	MOV	(SP)+,R4	;;RESTORE THE NEXT BUFFER ADDRESS
	BNE	140$		;;LOOP UNTIL DONE...
160$:	CLR	(R1)		;;NOW SET BOTH POINTERS TO
	CLR	-(R1)		;; ZERO TO INDICATE NO CHAIN
	MOVB	(SP)+,@#PS	;;RESTORE CALLING PRIORITY
	SUB	(R5)+,R1	;RE-INDEX BACK TO DDB'S TOP
	RETURN	R5		; AND EXIT

170$:	BIC	#40-1,R4	;;ENSURE WE'RE POINTING AT IRB'S TOP
	MOV	R3,-(SP)	;;GET A WORKING REGISTER
	MOV	R4,-(SP)	;; AND SAVE THE IRB POINTER
	MOV	IRBSIZ(R4),R3	;;GET THE SIZE OF THE DATA BUFFER
	ASH	#-9.,R3		;;FIND THE CORRECTION AMOUNT
	ADD	R3,BC-FP(R1)	;; AND CORRECT THE USAGE QUOTA
	MOV	IRBCON(R4),R4	;;GET CONTORTED ADDRESS OF DATA BUFFER
	BUFFER	RETURN		;; AND RETURN THAT DATA BUFFER
	MOV	(SP)+,R4	;;RESTORE THE IRB POINTER
	MOV	(SP)+,R3	;; AND THE WORKING REGISTER
	RETURN			;;EXIT

	UNORG

.DSABL	LSB

.SBTTL	GET IRB/DATA BUFFER PAIR

;+
; GETIRB - GET IRB/DATA BUFFER PAIR FOR NPR DEVICE.
;
;	R2 =  DESIRED DATA BYTE SIZE
;	R3 -> XRB
;	R4 -> BB
;
;	CALLBB	BBGIRB
;
;	R2 -> IRB
;
;	IF C=0 THEN IRB/DATA BUFFER OBTAINED
;	IF C=1 THEN ALLOCATION FAILURE
;-

	TMPORG	FETCH

GETIRB::REGSCR			;SAVE ALL REGISTERS
	MAP	RSTAP5,APR=5,CODE,DATA ;ENSURE THAT REST OF THE CODE IS MAPPED ;002
	MOVB	BBDOFF(R4),R1	;GET DATA OFFSET FROM BB
	CALL	SETUP		;DO INITIAL SET UP
	MOV	#40.,R2		;LEAVE AT LEAST 40. MONITOR POOL BUFFERS
	CALLX	BUFFER,R5,EXTPOL ;ASK FOR THE DATA BUFFER SPACE (NPR POOL)
	RETURN			; AND BACK

	UNORG

GLOBAL	<RSTAP5,EXTPOL>							;002

;+
; GETIRX - GET IRB/DATA BUFFER PAIR FOR NON-NPR DEVICE.
;
;	R2 =  DESIRED DATA BYTE SIZE
;	R3 -> XRB
;
;	CALL	GETIRX
;
;	R2 -> IRB
;
;	IF C=0 THEN IRB/DATA BUFFER OBTAINED
;	IF C=1 THEN ALLOCATION FAILURE
;-

GETIRX::REGSCR			;SAVE ALL REGISTERS
	CLR	R1		;NO DATA OFFSETTING
	CALL	SETUP		;DO INITIAL SET UP
	MOV	#-1,R2		;DON'T EVEN TRY THE MONITOR'S POOL...
	CALLX	BUFFER,R5,LRGPOL ;ASK FOR THE DATA BUFFER SPACE (ANY POOL)
	RETURN			; AND BACK

GLOBAL	<LRGPOL>

SETUP:	MOV	(SP)+,R5	;PUT THE CO-ROUTINE ADDRESS IN A REGISTER
	ADD	#BUFHDR,R1	;ADD SIZE OF A BUFFER HEADER TO OFFSET
	BUFFER	GETSML,,20.	;GET A SMALL BUFFER FOR THE IRB
	BVS	10$		;FAILED, SO QUIT RIGHT NOW (EXIT C=1)
	MOV	R4,TOS.R2(SP)	;WE'LL RETURN THE IRB POINTER IN R2 UPON EXIT
	MOV	R1,IRB18L(R4)	;SAVE COMBINED BUFFER HEADER + DATA OFFSET
	MOV	R4,R0		;MOVE IRB POINTER TO HERE
	ADD	#IRBEPT,R0	; AND INDEX INTO IT
	MOV	R1,(R0)		;SAVE COMBINED OFFSET @ IRBEPT
	ADD	#140000,(R0)	; MAKING IT A VIRTUAL (THROUGH PAR6) POINTER
	MOV	(R0),-(R0)	;PUT THE POINTER @ IRBFPT ALSO
.ASSUME	IRBFPT	EQ	IRBEPT-2
	ADD	R2,R1		;NOW FORM THE TOTAL REQUEST SIZE
	CALL	(R5)		;CO-ROUTINE CALL BACK FOR BUFFER ALLOCATION
	BCS	20$		;FAILED, NEED TO RETURN THE OBTAINED IRB
	MOV	R1,-(R0)	;SAVE TOTAL BUFFER SIZE @ IRBDPT
.ASSUME	IRBDPT	EQ	IRBFPT-2
	ADD	#140000,(R0)	; MAKING IT A VIRTUAL (THROUGH PAR6) POINTER
	MOV	R1,-(R0)	;SAVE TOTAL BUFFER BYTE SIZE @ IRBSIZ
.ASSUME	IRBSIZ	EQ	IRBDPT-2
	MOV	R4,R5		;MOVE CONTORTED ADDRESS TO AN ODD REGISTER
	ASHC	#-7,R5		;MAKE CONTORTED ADDRESS INTO AN MMU ADDRESS
	MOV	R5,-(R0)	; AND SAVE THE MMU ADDRESS
.ASSUME	IRBMMU	EQ	IRBSIZ-2
	ADD	#IRBCON-IRBMMU,R0 ;RE-INDEX IN THE IRB TO CONTORTED ADDRESS
	MOV	R4,(R0)		;SAVE CONTORTED ADDRESS OF BUFFER @ IRBCON
	MOV	XRMOD(R3),-(R0)	;LOAD DATA MODIFIER @ IRBMOD FROM XRB
.ASSUME	IRBMOD	EQ	IRBCON-2

	ADD	EXTPOF,R5	;FIND THE 18-BIT UNIBUS ADDRESS /100
	CLR	R4		;CLEAR A HIGH ORDER
	ASHC	#6,R4		; AND FIND THE TRUE 18-BIT UNIBUS ADDRESS
	ADD	R5,-(R0)	;ADD UNIBUS ADDRESS BASE TO OFFSET @ IRB18L
.ASSUME	IRB18L	EQ	IRBMOD-2
	ADC	R4		; CARRYING ANY CARRY TO MSB
	MOVB	R4,-(R0)	;LOAD MSB OF UNIBUS ADDRESS @ IRB18M
.ASSUME	IRB18M	EQ	IRB18L-1
	MOVB	XRCI(R3),-(R0)	;LOAD CHANNEL NUMBER *2 @ IRBCHN FROM XRB
.ASSUME	IRBCHN	EQ	IRB18M-1
	ASRB	(R0)		; THEN MAKE IT THE PLAIN OLD CHANNEL NUMBER
	CLR	-(R0)		;CLEAR THE STATUS @ IRBSTA
.ASSUME	IRBSTA	EQ	IRBCHN-2
	MOV	(PC)+,-(R0)	;LOAD FUNCTION CODE @ IRBFUN
	 .BYTE	0,1
.ASSUME	IRBFUN	EQ	IRBSTA-2
.ASSUME	IRBFUN	EQ	0
	TST	(PC)+		;SET C=0 FOR ALL O.K. EXIT
10$:	SEC			;SET C=1 FOR FAILURE EXIT
	RETURN			;EXIT

20$:	MOV	TOS.R2(SP),R4	;GET BACK THE SAVED IRB POINTER
	BUFFER	RETSML		; AND RETURN THE IRB
	BR	10$		;GO TAKE THE FAILURE EXIT

GLOBAL	<EXTPOF>

.END

