	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
	.INCLUDE /CMN:FLDEF/
TITLE	BUFEXT,<EXTENDED CACHE BUFFER MANAGER>,0A,10-MAY-91,MHB/RL/PTT/JTC/SJM/MND/DRP/FRL/MNB/KPH

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR BUFEXT
;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;  001	TG   01-Jan-81	Changed ..CAGE to 60 sec
;  002	JC   10-Feb-81	Fixed Cache limits task complete
;  003	SJM  08-Jul-81	Add support for I&D space
;  004	MND  06-Aug-81	Add ".ASSUME" to produce error if CHRDL3 is moved
;  005	JTC  14-Sep-81	Map WCB's in the FIP Pool
;
;			[RSTS/E V9.0]
;  006	DRP  03-Oct-83	Table changes to UNTCNT, UNTOWN/UNTOPT and UNTCLU/UNTERR
;  007  FRL  23-Nov-83  Made compatible with extended L3Q
;  008  MNB  02-Feb-84  Install DSQ -> ASYWRK -> WCB links
;  009	FEK  04-Apr-84	Make ..CAGE a cell
;  010	KPH  29-Aug-84	Changes for APR5 FIP pool
;  011	FEK  29-Oct-84	Make CHENUE global so UU.CHE can return the counters
;  012	KPH  21-Feb-85	Cache PFB I/O
;
;			[RSTS/E V9.1]
;  013  KPH  21-Feb-85	Cache window turn I/O
;
;			[RSTS/E V9.3]
;  014  KPH  22-Feb-86	Change SYDAP5 to RSTAP5
;  015  KPH  01-Jun-86	Change conventions for returned XBUF from bytes
;			to slivers
;			Disable interrupts when returning buffers
;  016  KPH  30-Jun-86	Support new cache giveback interface
;  017  KPH  06-Aug-86	Fix problem setting cache clustersize
;
;			[RSTS/E V9.4]
;  018  KPH  15-May-87	Don't cache FBN 0 since the cacher doesn't realize
;			that FBN 0 and FBN 1 are a full device cluster apart
;
;			[RSTS/E V9.6]
;  019  KPH  24-Feb-88	Better integrate code with disk statistics
;-


.IIF	NDF	CSTATS,	CSTATS=1 ;ASSUME CACHE STATISTICS

	DEFORG	BUFEXT

	DEFORG	BUF

	DEFORG	CHEISP							;019
    
	DEFORG	CHECTL							;016

	ORG	BUF							;016

	TMPORG	CHECTL							;016

$$CHEN	==	.	;**INIT** TO DISABLE DISK CACHEING IF NEEDED	;016
.ASSUME	.-CHECTL EQ CH$CTL
CHECTL:	.WORD	400		;400=>CACHEING ENABLED; 0=>CACHEING DISABLED

.ASSUME	.-CHECTL EQ CH$TIC
CHETIC::.WORD	0		;1=>CHARGE CACHE TIME; 0=>NO CHARGE	;016

.ASSUME	.-CHECTL EQ CH$SEC
CHESEC::.WORD	0		;APPROX SECONDS SINCE BOOT (MOD 64K)

;*****THE NEXT 2 ITEMS ARE GROUPED*****
.ASSUME	.-CHECTL EQ CH$NXT
CHENXT:	.WORD	CHEPRV		;POINTER TO "FIRST" IN LIST @ +2
.ASSUME	.-CHECTL EQ CH$PRV
CHEPRV:	.WORD	CHENXT		;POINTER TO "LAST" IN LIST @ +0

;*****THE NEXT 4 ITEMS ARE GROUPED*****
$$CACH	==	.	;**INIT** PAR6, TAG LIST, "UNUSED", W-TAG LIST FILLED IN
.ASSUME	.-CHECTL EQ CH$PAR
CHEPAR:	.WORD	0		;PAR6 VALUE FOR EXTENDED CACHE TAGS
.ASSUME	.-CHECTL EQ CH$TAG
CHETAG:	.WORD	0		;LIST OF USABLE EXTENDED CACHE TAGS
.ASSUME	.-CHECTL EQ CH$USM
	.WORD	0		;0=>DON'T USE MONITOR BUFFER POOL
.ASSUME	.-CHECTL EQ CH$WTG
CHEWTG:	.WORD	0		;LIST OF USABLE EXTENDED CACHE WRITE-TAGS

.ASSUME	.-CHECTL EQ CH$LIM
CHELIM:	.WORD	-1		;LIMIT OF TOTAL NUMBER OF EXTENDED CACHE TAGS

.ASSUME	.-CHECTL EQ CH$FLM
CHEFLM:	.WORD	-1		;LIMIT OF NUMBER OF EXTENDED CACHE DIRECTORY TAGS

.ASSUME	.-CHECTL EQ CH$DLM
CHEDLM:	.WORD	-1		;LIMIT OF NUMBER OF EXTENDED CACHE DATA TAGS

.ASSUME	.-CHECTL EQ CH$MOD
CHEMOD:	.BYTE	1		;0=>NO DATA; 1=>OPEN MODE; -1=>ALL DATA

.ASSUME	.-CHECTL EQ CH$DAT
	.BYTE	200		;200=>DATA CACHEING

;*****THE NEXT 4 ITEMS ARE GROUPED*****
$$CBSZ	==	.	;**INIT** ALL FOUR BELOW FILLED IN FOR CLUSTER SIZE
.ASSUME	.-CHECTL EQ CH$BSZ
CHEBSZ:	.WORD	4		;SIZE OF A CACHE CLUSTER IN BLOCKS
CHESHF:	.WORD	-2		;AMOUNT FOR A SHIFT TO DIVIDE BY CLUSTER SIZE
	.WORD	4-1		;MASK TO ROUND FBN DOWN TO CACHE CLUSTER
CHEBIC:	.WORD	^C<4-1>		;COMPLEMENT OF ABOVE (HANDY MASK)

SAVKA6:	.WORD	0		;SAVED DPAR6

RSTRTN:	.WORD	0		;"RESTART" RETURN ADDRESS

REFLAG:	.WORD	0		;"RESTART" FLAG (SP STACK VALUE)

GIVRES:	.WORD	0		;"Restart" flag for giveback routine	;016

TMWQUE:	.WORD	0		;QUEUE FOR WRITES AWAITING FREE WRITE-TAG

CHLFXB:	.WORD	0		;TIME OF LAST FAILURE TO ALLOCATE BUFFER

;*****THE NEXT 2 ITEMS ARE GROUPED*****
CHWTL3:	.WORD	CHWRTQ		;POINTER TO CACHEING QUEUE ROOT FOR WRITES
	.L3Q	QCACHE		;LEVEL 3 QUEUE BIT FOR CACHE		;007

CHWRTQ:	.WORD	0		;CACHEING QUEUE ROOT FOR WRITES

;*****THE NEXT 2 ITEMS ARE GROUPED*****
CHRDL3::.WORD	CHREDQ		;POINTER TO CACHEING QUEUE ROOT FOR READS ;016
	.L3Q	QCACHE		;LEVEL 3 QUEUE BIT FOR CACHE		;007

CHREDQ:	.WORD	0		;CACHEING QUEUE ROOT FOR READS

FAKDSQ:	.BLKB	DSQSIZ		;FAKE DSQ FOR HANDLING CROSS CLUSTER TRANSFERS

..CAGE:	.WORD	60.		;DEFAULT CACHE REPLACEMENT TIMER	;010

.IF	NE	CSTATS

	TMPORG	STSTBL,6

	.WORD	RDS.XC		;POINTER TO CACHE STATISTICS

	TMPORG	CHECTL

;*****START OF COMPATIBLE CACHE STATISTICS GROUPING*****
RDS.XC:	.WORD	0,0		;NUMBER OF DISK TRANSFERS WHICH ARE CACHED

DIR.CN:	.WORD	0,0		;NUMBER OF ABOVE WHICH ARE DIRECTORY TRANSFERS

HRS.RH:	.WORD	0,0		;NUMBER OF CACHE HITS

DIR.RH:	.WORD	0,0		;NUMBER OF ABOVE WHICH ARE DIRECTORY HITS

CHERST:	.WORD	0		;NUMBER OF TIMES CACHER RESTARTED

;The next 5 counters are grouped for easy reference to be returned
;by the UU.CHE call.

	.WORD	0		;NO MONITOR BUFFER CACHE ELEMENTS

.IFTF

CHENUE::.WORD	0		;NUMBER OF EXTENDED POOL CACHE ELEMENTS
;*****END OF COMPATIBLE CACHE STATISTICS GROUPING*****

CHFCNT:	.WORD	0		;COUNT OF DIRECTORY CACHE TAGS

CHDCNT:	.WORD	0		;COUNT OF DATA CACHE TAGS

CHEINV:	.WORD	0		;COUNT OF INVALID TAGS

.IFT

;*****START OF EXTENDED CACHE STATISTICS GROUPING*****
DAT.CN:	.WORD	0,0		;DATA TRANSFERS WHICH WERE CACHED

DAT.RH:	.WORD	0,0		;CACHE HITS ON DATA TRANSFERS

RDS.NC:	.WORD	0,0		;TRANSFERS WHICH ARE NOT CACHED

RDS.CI:	.WORD	0,0		;FRACTION OF ABOVE DUE TO CACHE INSTALLS

RDS.LX:	.WORD	0,0		;LARGE TRANSFERS CUT UP INTO SEGMENTS

RDS.RX:	.WORD	0,0		;LARGE TRANSFERS NOT CACHED CAUSE NO TAGS

RDS.SR:	.WORD	0,0		;SEGMENT READS PRODUCED WHEN CUT UP

WTS.NX:	.WORD	0,0		;TOTAL WRITE TRANSFERS

WTS.CH:	.WORD	0,0		;TAGS HIT BY WRITES
;*****END OF EXTENDED CACHE STATISTICS GROUPING*****

CAN.CH	=	.-CHFCNT
	.WORD	DIR.CN		;POINTER TO STATS AREA FOR DIRECTORY READS

.ASSUME	.-CHDCNT EQ CAN.CH
	.WORD	DAT.CN		;POINTER TO STATS AREA FOR DATA READS

HIT.CH	=	.-CHFCNT
	.WORD	DIR.RH		;POINTER TO STATS AREA FOR DIRECTORY HITS

.ASSUME	.-CHDCNT EQ HIT.CH
	.WORD	DAT.RH		;POINTER TO STATS AREA FOR DATA HITS

.ENDC

	UNORG

.SBTTL	MACRO AND ELEMENT CONTROL BLOCK DEFINITIONS

.MACRO	UNLINK	FROM,RG=R0
.IF	IDN	<FROM>,<CH.NXT>
	 MOV	(RG)+,@(RG)+	;;;MOVE NEXT PTR TO PREV'S NEXT PTR
	 MOV	-(RG),@-(RG)	;;;MOVE PREV PTR TO NEXT'S PREV PTR
.MEXIT
.ENDC
.IF	IDN	<FROM>,<CH.PRV>
	 MOV	(RG),@-(RG)	;;;MOVE PREV PTR TO NEXT'S PREV PTR
	 MOV	(RG)+,@(RG)+	;;;MOVE NEXT PTR TO PREV'S NEXT PTR
.MEXIT
.ENDC
.ERROR	; "FROM" IS AN ILLEGAL TAG OFFSET
.ENDM	UNLINK

.MACRO	INCSTA	STATSC
.IF	NE	CSTATS
	 ADD	#1,STATSC	;INCREMENT IN STATSC
	 ADC	STATSC+2	; (DOUBLE)
.ENDC
.ENDM	INCSTA

.DSECT				;DEFINE THE CACHE TAG OFFSETS

CH.NXT:	.BLKW			;POINTER TO NEXT @ CH.PRV
CH.PRV:	.BLKW			;POINTER TO PREVIOUS @ CH.NXT
CH.UNT:	.BLKB			;UNIT NUMBER OF BLOCK
CH.MSB:	.BLKB			;BLOCK'S FBN MSB
CH.LSB:	.BLKW			;BLOCK'S FBN LSB
CH.DAT:	.BLKW			;POINTER TO THE CACHED DATA BLOCK
CH.BLS:	.BLKW			;POINTER TO DSQ'S WAITING ON TAG
CH.TYP:	.BLKW			;TYPE POINTER (DATA OR DIRECTORY)
CH.TIM:	.BLKW			;TIME OF LAST REFERENCE
CH$SIZ:				;SIZE OF A CACHE TAG IN BYTES
$$CHSZ	==	CH$SIZ	;**INIT** FOR BUILDING EXTENDED CACHE TAGS

.ASSUME	CH.NXT	EQ	0
.ASSUME	CH.PRV	EQ	CH.NXT+2
.ASSUME	CH.UNT	EQ	CH.NXT+4

.ASSUME	CH.MSB-DSQFBM EQ CH.UNT-DSQUNT
.ASSUME	CH.LSB-DSQFBL EQ CH.UNT-DSQUNT

.DSECT				;DEFINE THE CACHE WRITE-TAG OFFSETS

WT.TYP:	.BLKB			;WRITE-TAG TYPE (REAL OR FROM TAG LIST)
WT.MAM:	.BLKB			;SAVED "DSQMAM"
WT.MAL:	.BLKW			;SAVED "DSQMAL"
WT.CNT:	.BLKW			;SAVED "DSQCNT"
WT.L3Q:	.BLKW			;SAVED "DSQL3Q"
WT.COF:	.BLKB			;SAVED TRANSFER'S BLOCK OFFSET INTO CLUSTER
WT.CHM:	.BLKB			;SAVED CACHE MODE FOR TRANSFER
WT.CTP:	.BLKW			;SAVED POINTER TO CACHE TAG
WT.MSC:	.BLKW			;SAVED "DSQMSC"
WT$SIZ:				;SIZE OF A CACHE WRITE-TAG IN BYTES

.ASSUME	WT.CHM	 EQ	WT.COF+1
.ASSUME	WT.COF&1 EQ	0

.ASSUME	WT$SIZ	LE	CH$SIZ

; DEFINE SOME OFFSETS INTO THE DSQ WHICH ARE NOT IN USE AT TIME OF CALL
; TO CACHE CODE.  THESE OFFSETS ARE USED TO STORE CACHE TEMPORARY
; VARIABLES CONCERNING THE TRANSFER BEING OPERATED ON.

.EQUATE	DQ.WRT,	DSQL3Q		;SAVED WORD COUNT FOR TRANSFER [FAKE DSQ ONLY]

.EQUATE	DQ.COF,	DSQPDA		;TRANSFER'S OFFSET INTO STARTING CACHE CLUSTER

.EQUATE	DQ.CHM,	DSQPDA+1	;CACHE MODE FOR TRANSFER (RANDOM OR SEQUENTIAL)

.EQUATE	DQ.NCB,	DSQOPT		;NUMBER OF BLOCKS AFFECTED BY TRANSFER

.EQUATE	DQ.TYP,	DSQPTO		;TRANSFER TYPE POINTER (DIRECTORY OR DATA)

.EQUATE	DQ.NCL,	DSQCTO		;NUMBER OF CACHE CLUSTERS AFFECTED BY TRANSFER

.ASSUME	DQ.CHM	 EQ	DQ.COF+1
.ASSUME	DQ.COF&1 EQ	0

	UNORG

.SBTTL	Give backs to the buffer manager

;+
; GIVBAK - Get back a extended buffer from cache.
;
;	R3 -> DPAR6
;	R4 -> Requested pool
;	R5 =  140000
;
;	CALL	GIVBAK
;
;	All registers are undefined
;
;	C = 1 if buffer available, C = 0 otherwise
;
;	Priority could be anything from PR3 to PR7.
;
; It is possible that the request to give back a buffer could interrupt
; the search for a cache tag. Additionally, it is possible that this
; routine could be interrupted by a higher priority caller that is
; trying to allocate a buffer. To avoid running much of the cacher
; at a high priority, we use "restarts".
;
; The main-line cache searcher will save it's SP value before it
; starts searching the cache list in the cell REFLAG. If we decide
; to remove a buffer from the cache, we will check to see if REFLAG
; is non-zero. If it isn't, then we didn't interrupt a search of
; the cache. If it is non-zero, then we will alter the saved PC
; of the interrupted routine, which will be stored at the memory
; location pointed to by REFLAG minus 4 (since the interrupt pushed
; the PS, followed by the PC) to contain the value RSTCHE, which
; is the address of a routine to restore context and resume.
; It doesn't matter if REFLAG gets changed more than once (which
; can happen if this routine itself gets interrupted by a higher
; priority caller) since the effect is the same every time that
; it happens.
;
; To prevent against this routine getting interrupted by itself
; at a higher priority, a similar restart approach is used. The
; cell GIVRES is used to control restarts within this routine.
; Initially, we pick up the contents of GIVRES before entering
; our critical section of code. This will be either a zero,
; indicating that no lower priority routine was interrupted, or
; it will be the SP value of the interrupted routine. We will
; the save our SP value in GIVRES. If a cache tag is allocated,
; we will check to see if GIVRES previously contained a non-zero
; value. If it did, we will alter the saved PC of the interrupted
; routine to start searching at the beginning again. On exit,
; we restore GIVRES to the value that it had before we started.
; This will either restore the context of the lower priority
; routine, or place a zero back indicating that restarts are
; not needed. Note that there is a window of time during which
; we have picked up the old GIVRES value but not set a new one.
; This is OK, since it simply means that the higher priority
; caller signalled the restart for the thread that we also interrupted.
; 
; Since restarts work by saving the value of SP, it is very important
; that the value of SP does not change while interrupts are enabled
; (either by explicit references to SP or use of the JSR instruction).
; Otherwise, the value on the stack which is changed by the interrupting
; caller will not be the saved PC, but will instead be some random
; value.
;-

	TMPORG	CHETBL,CO$DSK
	 .WORD	RSTAP5
	 .WORD	GIVBAK
	UNORG

GIVBAK:	CMP	R4,#MONPOL	;Looking for an XBUF type buffer?	;016
	BHIS	60$		;No, small buffer, exit C = 0 (BHIS=BCC) ;016
3$:	MOV	CHEPAR,(R3)	;Map the cache tags			;016
	MOV	@#PS,-(SP)	;Save calling priority			;016
	MOV	GIVRES,R1	;Save possible interrupted restart point ;016
	MOV	SP,GIVRES	;Set up giveback restart point		;016
5$:	MOV	#CHENXT,R2	;Set up starting address of tags	;016
10$:	MOV	CH.PRV(R2),R2	;Go back one in the list		;016
	CMP	R2,#CHENXT	;All of the way around?			;016
	BEQ	50$		;Yes, failure, exit C=0 (BEQ=>BHIS=BCC)	;016
	TST	CH.BLS(R2)	;Tag busy?				;016
	BNE	10$		;Yes, so can't give it back
	CMP	CH.DAT(R2),2(R4) ;No, but is it from the right pool?	;016
	BLO	10$		;No, loop				;016
	CMP	R4,#EXTPOL	;Maybe, did they request EXTPOL?	;016
	BEQ	15$		;Yes, so we're all set			;016
	CMP	CH.DAT(R2),EXTPOL+2 ;No, LRGPOL, what pool is this from? ;016
	BHIS	10$		;EXTPOL, forget it			;016

; The above pool check works as follows. LRGPOL always occupies lower
; physical memory addresses than EXTPOL. Offset two in the pool
; descriptor is the address of the root of the pool. If the MMU
; address of the cache data is less than the MMU address of the
; pool root, then this definitly isn't from the pool requested.
; If it is greater than the pool root, then it might possibly be
; an EXTPOL buffer when looking for a LRGPOL buffer. If we were
; looking for an EXTPOL buffer, then we are set. If not, we will
; check to see if this buffer is from EXTPOL. If it is, then we
; will look for the next buffer. Otherwise, we are all set.

15$:	SPLC	7		;Lock out interrupts			;016
	MOV	R1,GIVRES	;;;Restore previous restart SP value	;016
	BEQ	20$		;;;None, so we don't have a PC to fix	;016
	MOV	#5$,-<2*2>(R1)	;;;We had one, do the restart now	;016
20$:	MOV	(SP)+,R1	;;;Get priority for RELTAG		;016
	CALL	RELTAG		;;;Release this tag to buffer pool	;015
30$:	MOV	REFLAG,R1	;Is restart enabled?			;016
	BEQ	40$		;No restart enabled

.IF	NE	CSTATS

	INC	CHERST		;Count number of restarts

.ENDC

	MOV	#RSTCHE,-<2*2>(R1) ; And update the saved PC 		;016
40$:	SEC			;Indicate we returned something		;016
	BR	60$		;And get out				;016

50$:	MOV	R1,GIVRES	;Failure, restore previous restart point ;016
	TST	(SP)+		;Indicate we didn't return anything	;016
60$:	RETURN			; and get out				;016

GLOBAL	<RSTAP5,MONPOL,EXTPOL>						;016

.SBTTL	RELTAG	Release a tag to the buffer pool

;+
; RELTAG - RELEASE A TAG TO THE BUFFER POOL.
;
;	R1 =  Priority to drop to after unlinking tag
;	R2 -> TAG (LINKED)
;	R3 -> KISAR6 OR KDSAR6
;	R5 =  140000
;	APR6 MAPS TAGS
;
;	CALL	RELTAG
;
;	R0 =  Undefined
;	R1 =  Undefined
;	R2 =  Undefined
;	R4 =  Undefined
;	R5 =  Undefined
;
;	DPAR6 mapping is undefined
;
;-

RELTAG:	UNLINK	CH.NXT,R2	;;;Unlink tag from active tag list	;016
	MOV	CHETAG,(R2)	;;;Now re-link this tag to		;016
	MOV	R2,CHETAG	;;; the free tag list			;016
	MOV	R1,@#PS		;;;Drop to caller's priority		;016
	DEC	CHENUE		;One less extended cache tag now
	DEC	@CH.TYP(R2)	;Decrement the correct limit counter	;016
	MOV	CH.DAT(R2),R2	;Now get mmu address of data buffer	;016
	MOV	R2,(R3)		;Load PAR6 for cache buffer		;016
	MOV	CHEBSZ,R2	;Get size of XBUF buffer in blocks	;016
	ASH	#11-6,R2	;Now get the size in slivers		;016
	MOV	R2,(R5)		;And save that in the XBUF buffer	;016
.ASSUME	BF.SIZ	EQ	0
	CALLMI	RETEXT,GENAP5	;Go and really return the buffer space	;016
	RETURN			; and exit

.SBTTL	SET RESTART ADDRESS SUBROUTINE

; RESTRT - SET RESTART ADDRESS, ETC. FOR FIRST RESTART ROUTINE.
; RSTRT2 - RESTART FOR ADDITIONAL ROUTINES.
;
;	CALL	RESTRT
;	(RESTART POINT)
;
;	R0 -> CHEPRV
;	R3 -> CHEPRV
;	RESTARTS ENABLED, APR6 MAPS TAGS

RESTRT:

.IF	NE	CSTATS

	INC	CHETIC		;CHARGE CACHER FOR TIME

.ENDC

RSTRT2:	MOV	(SP)+,RSTRTN	;SAVE RETURN ADDRESS

.SBTTL	COME HERE ON ALL RESTARTS

RSTCHE:	MOV	SP,REFLAG	;ENABLE RESTARTS IF ANY CACHE BUF GRABBED
	MAP	CHEPAR,APR=6,DATA ;SET PAR6 TO MAP EXTENDED CACHE TAGS
	MOV	#CHEPRV,R0	;SET R0 AND R3 TO POINT TO THE PREV-PTR
	MOV	R0,R3		; OF THE CACHE LIST ROOT ELEMENT
	JMP	@RSTRTN		;  AND GO TO THE RESTART ADDRESS
GLOBAL	<DPAR6>

.SBTTL	DISK CACHE 'ZAP' SUBROUTINE

;+
; CHEZAP - ZAP CACHE INFORMATION ABOUT ALL BLOCKS ON A UNIT.
;
;	R1 =  THE FUN OF THE UNIT TO BE ZAPPED
;
;	CALL	CHEZAP
;-

	TMPORG	CHEZAP

CHEZAP:	CALLMR	CHEZAX,RSTAP5	;GO TO THE MAPPED CODE...		;014

	UNORG

CHEZAX:	MOV	R0,-(SP)	;SAVE R0
	MOV	R3,-(SP)	; AND R3
	MOV	@DPAR6,SAVKA6	;SAVE DATA APR 6
	CALL	RESTRT		;SET RESTART ADDRESS
10$:	MOV	-(R0),R0	;POINT TO THE NEXT FORWARD IN LIST
	CMP	R0,R3		;SEE IF WE'VE COME FULL CIRCLE
	BEQ	20$		;NO MORE, SO DONE
	CMPB	R1,CH.UNT-CH.PRV(R0) ;MORE, DOES THE UNIT MATCH?
	BNE	10$		;NO UNIT MATCH, CONTINUE
	SPLC	7		;;;UNIT MATCH, LOCKOUT INTERRUPTS
	CALL	MOVEND		;;;MOVE TO END OF LIST MAKING IT INVALID
	BR	RSTCHE		;START ALL OVER AGAIN - SLOW BUT SURE

20$:	CLR	REFLAG		;DISABLE RESTARTING
	MOV	(SP)+,R3	;RESTORE R3
	MOV	(SP)+,R0	; AND R0
	JMP	KISRTS		;GO RESTORE PAR6 AND EXIT		;019

GLOBAL	<DPAR6>

.SBTTL	CHECK CACHE FOR THE REQUEST

;+
; CHECHK - CHECK FOR REQUEST BEING IN THE CACHE.
;
;	R4 -> DSQ
;	R5 =  FIP UNIT NUMBER *2
;
;	CALL	CHECHK
;
;	R3 =  RANDOM
;
;	C = 0 if physical I/O needed
;	C = 1 if no I/O needed
;-

CHECHK::TST	CHECTL		;IS CACHEING ENABLED?
	BEQ	10$		;NOPE, SO SIMPLY EXIT (C=0 from TST)
	CMP	DSQL3Q(R4),#SWDNE ;A SWAP AND/OR RTS LOAD REQUEST?
	BEQ	10$		;YES, WE NEVER LOOK AT THOSE... (C=0 from CMP)
	TSTB	DSQJOB(R4)	;SPECIAL "DON'T CACHE IT" REQUEST?
	BMI	10$		;YEP, SO DON'T! (C=0 from TSTB)
	BIT	#UC.MNT!UC.NFS,UNTCNT(R5) ;NOT MOUNTED AND/OR NFS?
	BNE	10$		;DON'T CACHE THOSE... (C=0 from TSTB)
	MOVB	DSQFBM(R4),R3	;Get MSB of FBN of I/O request		;018
	BIS	DSQFBL(R4),R3	;Are we doing I/O to block zero?	;018
	BEQ	10$		;Yes, don't ever cache that (C=0 from TSTB) ;018
	CALL	CHECKX		;Do further checking, result in C	;019
10$:	BICB	#200,DSQJOB(R4)	;ENSURE THE "DON'T CACHE" FLAG IS NOW OFF
	RETURN			; AND EXIT

GLOBAL	<SWDNE,UNTCNT>

.SBTTL	INITIATE WRITE REQUESTS

CHECKX:	MOV	@DPAR6,SAVKA6	;SAVE CALLER'S APR6
	CMPB	DSQFUN(R4),#RFUN ;IS THIS TRANSFER A READ?
	BHIS	CHECKR		;YES (OR WRITE-CHECK), GO CHECK REQUEST
.ASSUME	WFUN.C	LT	RFUN
.ASSUME	WFUN	LT	RFUN

.IF	NE	CSTATS

	INC	CHETIC		;CHARGE CACHER FOR TIME

.ENDC

	MAP	CHEPAR,APR=6,DATA ;NO, A WRITE, MAP TAG AREA IN XBUF
	CALL	GETWTG		;GET AND LOAD A WRITE-TAG
	BEQ	10$		;NO WRITE-TAG AVAILABLE...
	MOV	#CHWTL3,DSQL3Q(R4) ;ELSE CHANGE TO RE-QUEUE TO OUR WRITE QUEUE
	INCSTA	WTS.NX		;INCREMENT NUMBER OF WRITE TRANSFERS
	BR	KISRTS		;GO RETURN TO CALLER

10$:	CALLX	QUEUER,R5,TMWQUE ;PUT WRITE IN WAITING FOR TAG QUEUE
	BR	KISRTC		;GO EXIT TO CALLER'S CALLER
GLOBAL	<DPAR6>

.SBTTL	CHECK READ REQUESTS

CHECKR:	BHI	KISRTS		;A WRITE-CHECK, DON'T EVEN LOOK AT IT
.ASSUME	RFUN.C	GT	RFUN
	CLRB	DQ.CHM(R4)	;ASSUME RANDOM CACHE MODE FOR THIS TRANSFER
	CMP	DSQL3Q(R4),#CHRDL3 ;IS THIS OUR OWN MULTI-CLUSTER READ?
	BEQ	CACHIT		;YEP, ALWAYS (RE-)CACHE IT
	MOV	#CHFCNT,DQ.TYP(R4) ;NOPE, ASSUME A DIRECTORY TRANSFER
	CMP	R4,#FIPAR	;FIP READ?
	BEQ	30$		;YES, ALWAYS TRY TO CACHE IT
	CMP	DSQL3Q(R4),#FLDNE ;USER READ?
	BEQ	5$		;Yes, go check it out			;012
	CMP	DSQL3Q(R4),#WTDNE ;Window turn I/O?			;013
	BEQ	30$		;Yes, treat it like FIP I/O		;013
	CMP	DSQL3Q(R4),#PFDNE ;PFB I/O?				;012
	BEQ	5$		;YES, so cache it.			;0xx
	CMP	DSQL3Q(R4),#0	;Any other strange stuff		;0xx
	BR	50$		;NOPE, NEVER CACHE IT			;0xx
5$:	MOV	DSQMSC(R4),R3	;Get -> to the XRB, then		;012
	MOV	XRTIME(R3),R3	; GET POINTER TO WCB (OR SCB)		;008
	MAP	FIPPOL		;MAP THE WCB'S IN THE FIP POOL
	BIT	(R3),#DDNFS	;NFS READ?
	BNE	KISRTS		;YES, DON'T TRY TO CACHE IT
	BIT	(R3),#SC$UFD	;UFD READ?
	BNE	30$		;YES, ALWAYS TRY TO CACHE IT
.ASSUME	WC$UFD	EQ	SC$UFD
	MOV	#CHDCNT,DQ.TYP(R4) ;ASSUME A DATA TRANSFER NOW
	TSTB	CHEMOD		;CHECK THE CACHEING MODE
	BEQ	50$		;ZERO, NO DATA CACHEING AT ALL
	MOVB	<LRGFIL*W$WCB>+<<1-LRGFIL>*S$WND>(R3),R3
				;GET CACHE FLAGS IN OPEN FILE'S WCB (SCB)
	BIT	#<LRGFIL*WC$CHE>+<<1-LRGFIL>*SC$CHE>,R3
				;IS FILE OPEN FOR CACHEING?
	BEQ	10$		;NO
	BIC	#^C<<LRGFIL*WC$CSQ>+<<1-LRGFIL>*SC$CSQ>>,R3
				;YES, ISOLATE CACHE MODE BIT
	MOVB	R3,DQ.CHM(R4)	; AND SET MODE OF CACHED TRANSFER
	BR	20$		;GO TRY TO CACHE THIS TRANSFER
                
10$:	TSTB	CHEMOD		;CACHEING ALL DATA?
	BPL	50$		;NOPE
20$:	MOV	#UO.NCD,R3	;SET DATA CACHEING OPTION BIT
	BR	40$		; AND GO CHECK IT

30$:	MOV	#UO.NCF,R3	;SET DIRECTORY CACHEING OPTION BIT
40$:	MAP	@#KISAR5,APR=5,DATA ;Be sure we are mapped I&D		;010
	BIT	R3,UNTOPT(R5)	;ALLOWING THIS KIND OF CACHEING?	;006
	BEQ	CACHIT		;YEP, SO GO CACHE IT
50$:	INCSTA	RDS.NC		;COUNT TRANSFERS NOT CACHED
	BR	KISRTS		;RETURN TO CALLER WITH C=0

GLOBAL	<FIPAR,FLDNE,LRGFIL,UNTOPT,PFDNE,WTDNE>				;013

.SBTTL	READ SHOULD BE CACHED, SEE IF SINGLE CLUSTER OR MULTI-CLUSTER

.ENABL	LSB

10$:	CALL	LNKINV		;NO WRITE-TAG AVAILABLE, LINK AS INVALID
	BR	KISRTS		; AND GO DO REAL I/O

20$:	CLR	REFLAG		;NO MORE RESTARTS NOW PLEASE
	BR	KISRTS		; WE'RE GIVING UP AND DOING REAL I/O

30$:	INCSTA	HRS.RH		;INCREMENT TOTAL READ HITS

.IF	NE	CSTATS
	MOV	HIT.CH(R1),R3	;GET POINTER TO STATISTICS CELLS
	ADD	#1,(R3)+	;COUNT HITS
	ADC	(R3)+		; (DOUBLE)
.ENDC

	MOV	CH.BLS-CH.UNT(R0),R3 ;IS TAG BUSY?
	BNE	50$		;YES
	CALL	READNE		;NO, DO CACHE READ HIT HOUSEKEEPING
KISRTC:	MOV	#40$,-(SP)	;SET FOR RETURN TO CALLER'S CALLER
KISRTS:	MAP	SAVKA6,APR=6,DATA ;RESTORE PAR6
	MAP	@#KISAR5,APR=5,DATA ;And set up I&D overmapped		;010
.IF	NE	CSTATS
	CLR	CHETIC		;STOP CHARGING CACHE FOR TIME
.ENDC

	TST	(PC)+		;SET C=0 FOR EXIT (CALLER)
40$:	SEC			;SET C=1 FOR EXIT (CALLER'S CALLER)
	RETURN			;EXIT

50$:	MOV	R3,(R4)		;POINT DSQ AT REST OF BUSY LIST
	MOV	R4,CH.BLS-CH.UNT(R0) ; AND BUSY LIST POINTER AT DSQ
60$:	CALL	LINKIT		;NOW PUT BACK IN TAG LIST
	BR	KISRTC		;AND RETURN TO CALLER'S CALLER

CACHIT:	REGSCR			;SAVE ALL REGISTERS
	CALL	MASHER		;MASH DSQ INTO FORM CONVENIENT FOR TESTS
	DEC	R1		;IS THIS A SINGLE CLUSTER TRANSFER?
	BGT	CHEMUL		;NO, DO FANCY CHECKING
	INCSTA	RDS.XC		;YES, COUNT TOTAL SINGLE TRANSFERS CACHED
	MOV	DQ.TYP(R4),R1	;GET POINTER TO TRANSFER LIMIT COUNTER

.IF	NE	CSTATS
	MOV	CAN.CH(R1),R3	;GET POINTER TO STATISTICS CELLS
	ADD	#1,(R3)+	;COUNT POSSIBLES
	ADC	(R3)+		; (DOUBLE)
.ENDC

	CALL	SEARCH,R1	;IS BLOCK IN CACHE?
	  TST	(PC)+		;NO, TRY TO GET IT INSTALLED
	BR	30$		;YES, WE GOT A HIT
	CALL	UNMASH		;NO HIT, RESTORE THE ORIGINAL FBN IN DSQ
	TSTB	DQ.CHM(R4)	;IS INSTALL ON MISS INHIBITTED?
	BMI	KISRTS		;YEP, SO GET OUT AND DO I/O
	CMP	(R1),CHEFLM-CHFCNT(R1) ;ARE WE AT LIMIT FOR THIS TYPE?
.ASSUME	CHEFLM-CHFCNT EQ CHEDLM-CHDCNT
	BHIS	80$		;YES, MUST GET EXPIRED TAG OF SAME TYPE
	TST	CHEINV		;ANYTHING WILL DO, ANY INVALIDS LYING AROUND?
	BNE	70$		;YES, GO USE AN INVALID
	CALL	GETNTG		;NO INVALIDS, CAN WE GET A NEW TAG?
	BCC	120$		;YUP, USE THE NEW ONE
70$:	CLR	R1		;NOW LOOK FOR ANY INVALID OR EXPIRED TAG
80$:	CALL	RSTRT2		;ENABLE RESTARTING
	MOV	#CHENXT,R0	;GET POINTER FOR BACKWARDS SEARCH
90$:	MOV	CH.PRV(R0),R0	;GET NEXT GOING BACKWARDS IN LIST
	CMP	R0,#CHENXT	;HAVE WE CLOSED THE LOOP?
	BEQ	20$		;YEP, GIVE UP AND DO REAL I/O
	TST	CH.BLS(R0)	;TAG BUSY?
	BNE	90$		;IT IS BUSY, GO LOOK AT THE NEXT TAG
	TSTB	CH.UNT(R0)	;NOT BUSY, IS TAG INVALID?
	BMI	100$		;IT IS INVALID, SEE IF WE CAN USE IT
	MOV	CHESEC,R3	;ELSE GET AGE OF TAG IN
	SUB	CH.TIM(R0),R3	; SECONDS
	CMP	R3,..CAGE	;IS IT LESS THAN REPLACE VALUE?		;009
	BLO	20$		;TOO YOUNG, GIVE UP AND DO REAL I/O
100$:	TST	R1		;OLD ENOUGH (OR INVALID), WE CARE ABOUT TYPE?
	BEQ	110$		;WE DON'T CARE, WHATEVER IT IS, USE IT
	CMP	CH.TYP(R0),R1	;WE CARE, IS THIS OUR KIND OF TAG?
	BNE	90$		;NO, TRY TO FIND ONE LIKE US
110$:	SPLC	7		;;;DISABLE INTERRUPRS
	DEC	@CH.TYP(R0)	;;;DEC COUNT FOR TYPE OF TAG WE'RE USING
	UNLINK	CH.NXT		;;; AND UNLINK THE TAG
	CLR	REFLAG		;;;NO MORE RESTARTS PLEASE, WE'VE GOT IT NOW
	SPLC	3		;;;AND WE'RE SAFE AGAINST INTERRUPTS AGAIN
120$:	CALL	GETWTG		;GET AND LOAD A WRITE-TAG
	BEQ	10$		;COULDN'T GET ONE, GIVE UP

GLOBAL	<..CAGE>

.SBTTL	RE-BUILD DSQ TO READ IN A CACHE CLUSTER FOR INSTALLING

	INCSTA	RDS.CI		;COUNT CACHE CLUSTER INSTALLS
	MOV	R0,-(R3)	;SAVE CACHE TAG POINTER @ WT.CTP
.ASSUME	WT.CTP	EQ	WT.MSC-2                          
	ADD	#CH.TYP,R0	;INDEX INTO THE TAG TO WT.TYP
	MOV	DQ.TYP(R4),(R0)+ ;SET TYPE POINTER IN TAG (DATA, ETC.)
	INC	@-(R0)		; AND INC TAG COUNT FOR THAT TYPE
	MOV	R4,-(R0)	;SET BUSY LIST TO END WITH THIS DSQ
.ASSUME	CH.BLS	EQ	CH.TYP-2
	MOV	DQ.COF(R4),-(R3) ;SET WT.CHM AND WT.COF FROM DSQ
.ASSUME	WT.COF	EQ	WT.CTP-2
	MOVB	(R3),R1		;SAVE BLOCK OFFSET INTO CACHE CLUSTER
	ADD	#DSQCNT+1,R4	;INDEX INTO THE DSQ TO DSQCNT HIGH BYTE
	MOVB	CHEBSZ,(R4)	;SET WORD COUNT TO
	CLRB	-(R4)		; SIZE OF A CACHE CLUSTER @ DSQCNT
	MOV	-(R0),R3	;GET MMU ADDRESS OF DATA BUFFER
.ASSUME	CH.DAT	EQ	CH.BLS-2
	CLR	R2		;CLEAR THE HIGH ORDER
	ASHC	#6,R2		; AND SCALE UP MMU ADDRESS TO REAL ADDRESS
	MOV	R3,-(R4)	;SET MEMORY ADDRESS LSB @ DSQMAL
.ASSUME	DSQMAL	EQ	DSQCNT-2
	SWAB	R2		;MOVE MEMORY ADDRESS MSB TO HIGH BYTE
	MOV	R2,-(R4)	; AND IT @ DSQMAM (JUNK @ DSQRFN)
.ASSUME	DSQMAM	EQ	DSQMAL-1
.ASSUME	DSQRFN	EQ	DSQMAM-1
	SUB	R1,-(R4)	;FIX FBN LSB TO START AT A CACHE CLUSTER
.ASSUME	DSQFBL	EQ	DSQRFN-2
	MOV	(R4),-(R0)	;BUILD TAG'S FBN LSB FROM @ DSQFBL
.ASSUME	CH.LSB	EQ	CH.DAT-2
	SBCB	-(R4)		;CARRY ANY CARRY TO FBN MSB
.ASSUME	DSQFBM	EQ	DSQFBL-1
	SUB	#1,(R0)		;TAG'S FBN WANTS TO BE ZERO BASED
	MOVB	(R4),-(R0)	;BUILD TAG'S FBN MSB FROM @ DSQFBM
.ASSUME	CH.MSB	EQ	CH.LSB-1
	SBCB	(R0)		;CARRY ANY CARRY TO TAG'S FBN MSB
	MOVB	-(R4),-(R0)	;BUILD TAG'S UNIT FROM @ DSQUNT
.ASSUME	DSQUNT	EQ	DSQFBM-1
.ASSUME	CH.UNT	EQ	CH.MSB-1
	MOV	#CHRDL3,-(R4)	;CACHE IS READ COMPLETION HANDLER
.ASSUME	DSQL3Q	EQ	DSQUNT-2
	BIS	#200,-(R4)	;SAY "DON'T CACHE" THIS REQUEST @ DSQJOB
.ASSUME	DSQJOB	EQ	DSQL3Q-2
	CLR	-(R4)		;NOW, FINALLY, UP TO THE TOP OF THE NEW DSQ
.ASSUME	0	EQ	DSQJOB-2
	CALLX	DISK		;START THE CACHE READ INSTALL
	BR	60$		;NOW GO RE-LINK TAG AND EXIT CALLER'S CALLER

.DSABL	LSB

.SBTTL	CHECK MULTI-CLUSTER READS

.ENABL	LSB

CHEMUL:	TSTB	DQ.CHM(R4)	;IS THIS A SEQUENTIAL MODE TRANSFER?
	BNE	140$		;YES, SO DON'T BOTHER TO TRY TO INSTALL IT
	MOV	R4,-(SP)	;SAVE MASHED DSQ POINTER
	CMP	-(SP),-(SP)	;CREATE TWO SCRATCH STACK WORDS
	CALL	RESTRT		;ENABLE RESTARTING
	MOV	CHEINV,(SP)	;WE CAN ALWAYS REUSE INVALID TAGS
	MOVB	DQ.NCL(R4),2(SP) ;SET COUNT OF TOTAL NUMBER OF CLUSTERS
	MOV	DQ.NCB(R4),R1	;GET NUMBER OF BLOCKS AFFECTED BY TRANSFER
	MOV	DSQFBL(R4),R3	;NOW GET BOTH WORDS OF THE
	MOV	DSQUNT(R4),R2	; OF THE FIP BLOCK NUMBER
	SWAB	R2		;  WITH UNIT NUMBER IN HIGH BYTE
10$:	MOV	-(R0),R0	;GET NEXT TAG IN THE CACHE
	CMP	R0,#CHEPRV	;HAVE WE GONE ALL THE WAY AROUND?
	BEQ	70$		;YES, ALL DONE
	MOV	CH.UNT-CH.PRV(R0),R5 ;GET HIGH WORD OF TAG ID
	SWAB	R5		; AND PUT FIP UNIT NUMBER IN HIGH BYTE
	CMP	R2,R5		;DOES TRANSFER START ABOVE THIS TAG?
	BNE	20$		;MSB'S DIFFER, CHECK WHICH WAY
	CMP	R3,CH.LSB-CH.PRV(R0) ;DOES TRANSFER START ABOVE THIS TAG?
20$:	BHI	40$		;YEP, SKIP THIS TAG
	ADD	R1,R3		;FIND ENDING LSB FOR DSQ
	ADC	R2		; AND ENDING MSB
	CMP	R2,R5		;DOES TRANSFER END BELOW THIS TAG?
	BNE	30$		;MSB'S DIFFER, CHECK WHICH WAY
	CMP	R3,CH.LSB-CH.PRV(R0) ;DOES TRANSFER END BELOW THIS TAG?
30$:	BHI	60$		;YEP, SO COUNT A HIT!
	SUB	R1,R3		;RESTORE THE ORIGINAL DSQ LSB
	SBC	R2		; AND MSB
40$:	TST	CH.BLS-CH.PRV(R0) ;IS THIS TAG BUSY?
	BNE	10$		;YES, CAN'T BE A (RE-)USABLE TAG
	TST	R5		;AN INVALID TAG?
	BMI	70$		;YES, WE'VE LOOKED FAR ENOUGH
	MOV	CHESEC,R5	;ELSE GET AGE OF TAG
	SUB	CH.TIM-CH.PRV(R0),R5 ;IN SECONDS
	CMP	R5,..CAGE	;IS IT LESS THAN REPLACE VALUE?		;009
	BLO	10$		;NOPE, NOT RE-USABLE
	INC	(SP)		;COUNT (RE-)USABLE TAGS
	BR	10$		;NOW GET THE NEXT TAG

60$:	SUB	R1,R3		;RESTORE THE ORIGINAL DSQ LSB
	SBC	R2		; AND MSB
	DECB	2(SP)		;COUNT DOWN NUMBER OF CLUSTERS IN TRANSFER
	BNE	10$		;STILL SOME NOT HIT, KEEP GOING...
70$:	CLR	REFLAG		;NO MORE RESTARTS
	MOV	(SP)+,R1	;SET NUMBER OF (RE-)USABLE TAGS
	MOVB	(SP)+,R4	;GET NUMBER CLUSTERS MISSED
	BEQ	90$		;NONE MISSED
	CMP	R4,#2		;REQUIRE MORE THAN 2 PHYSICAL READS?
..CFAC	==	.-2	;**PATCH** CACHE I/O SPLITTING FACTOR
	BHI	130$		;TOO MUCH REAL I/O, DON'T CACHE IT
	SUB	R1,R4		;FIND NUMBER OF NEEDED NEW TAGS
	BLOS	90$		;NO MORE TAGS NEEDED

GLOBAL	<..CAGE>

80$:	CALL	GETNTG		;GET A NEW CACHE TAG FROM XBUF
	BCS	130$		;NONE TO BE FOUND
	CALL	LNKINV		;GOT ONE, LINK IT AS AN INVALID TAG
	SOB	R4,80$		;LOOP FOR ALL WE NEED...
90$:	MOV	(SP),R4		;RESTORE MASHED DSQ POINTER
	CLR	(R4)		;CLEAR LINK, WILL USE AS A READ COUNTER
	CALL	CPYDSQ		;COPY MASHED DSQ INTO FAKE DSQ
	CALL	CHMDSQ		;SET UP TO BREAK DOWN INTO CLUSTERS
100$:	MOV	R4,R5		;COPY FAKE DSQ POINTER TO HERE
	CALL	CRNDSQ		;GET NEXT CLUSTER AFFECTED
	BCC	160$		;NO MORE, SO FINISH UP
	BUFFER	GETSML,0	;TRY TO GET A (NON-CLEARED) SMALL BUFFER
	BVS	120$		;NONE AVAILABLE, SO GIVE UP EFFORTS
	MOV	R4,-(SP)	;GOT ONE, SAVE THE NEW DSQ'S ADDRESS
110$:	MOV	(R5)+,(R4)+	;COPY FAKE INTO FRESH SMALL BUFFER
	CMP	R5,#FAKDSQ+DSQSIZ ;ALL DONE WITH COPY?
	BLO	110$		;NOT YET...
	MOV	#CHRDL3,DSQL3Q-DSQSIZ(R4) ;CACHER IS READ COMPLETION HANDLER
	MOV	2(SP),DSQMSC-DSQSIZ(R4) ;PUT ORIGINAL DSQ POINTER INTO NEW DSQ
	INC	@DSQMSC-DSQSIZ(R4) ; AND COUNT NUMBER OF NEW DSQ'S
	INCSTA	RDS.SR		;COUNT SEGMENTED READS DONE
	MOV	#FAKDSQ,R4	;GET BACK A POINTER TO THE FAKE DSQ
	MOV	(SP)+,(R4)	; AND LINK NEW DSQ TO THE LIST
	BR	100$		;HERE WE GO AGAIN...

120$:	MOV	(R5),R4		;CLEANUP, GET LAST DSQ WE CREATED
	BNE	150$		;WE GOT AT LEAST ONE...
130$:	MOV	(SP)+,R4	;RESTORE ORIGINAL MASHED DSQ POINTER
	MOV	#KISRTS,-(SP)	;SET EXIT TO RETURN TO CALLER FOR REAL I/O
140$:	INCSTA	RDS.RX		;COUNT NUMBER OF LARGE READS NOT CACHED
	.BR	UNMASH		;FIX UP FBN IN DSQ AND EXIT C=0 FOR CALLER

; UNMASH - FIX UP THE "MASHED" FBN IN THE DSQ.
;
;	R4 -> MASHED DSQ
;
;	CALL	UNMASH
;
;	R3 =  UNDEFINED
;
;	C=0 ALWAYS!

UNMASH:	MOVB	DQ.COF(R4),R3	;GET OFFSET INTO CACHE CLUSTER
	INC	R3		;ADD CORRECTION FOR 1 BASED FBN
	ADD	R3,DSQFBL(R4)	;UPDATE THE
	ADCB	DSQFBM(R4)	; FBN IN DSQ
	;CLC			;C=0 (FROM 'ADCB') FOR RETURN TO CALLER
	RETURN			;EXIT WITH C=0

150$:	BISB	#200,DSQJOB(R4)	;SAY THIS REQUEST SHOULDN'T BE (RE-)CACHED
	ADD	DSQCNT(R5),DSQCNT(R4) ;ADD WORD COUNT OF PENDING TRANSFER
	MOV	DQ.WRT(R5),R3	;GET WORD COUNT REMAINING
	BLE	160$		;NONE REMAINING SO FINISH UP
	ADD	R3,DSQCNT(R4)	;ELSE ADD IT TO TRANSFER ALSO
160$:	MOV	(R5),(SP)	;MAKE TOP-OF-STACK THE ROOT OF THE DSQ LIST
	CALL	KISRTS		;GO RESTORE PAR6, ETC.
170$:	MOV	(SP),R4		;GET NEXT DSQ IN LIST
	BEQ	180$		;ALL DONE
	MOV	(R4),(SP)	;ELSE DE-QUEUE THIS DSQ FROM LIST
	CALL	UNMASH		;FIX UP THE FBN IN THE DSQ
	CALLX	DISK		; AND CALL FOR THAT (CACHED!) DISK TRANSFER
	BR	170$		;  AND LOOP...

180$:	INCSTA	RDS.LX		;COUNT LARGE READS CACHED
	COM	(SP)+		;POP STACK SETTING C=1 (FROM 'COM')
	RETURN			; AND EXIT C=1 TO RETURN TO CALLER'S CALLER

.DSABL	LSB     

               
.SBTTL	CACHE WRITE COMPLETIONS

.ENABL	LSB

10$:	MOV	(SP)+,R4	;RESTORE ORIGINAL DSQ POINTER
	CALLX	DISKER		; AND HOUSEKEEP UP THE REQUEST
	CALL	CHKTMW		;CHECK TEMPORARY WRITE QUEUE NOW

	L3QENT	QCACHE,,RSTAP5	;CACHE COMPLETIONS COME HERE		;014

	MOV	CHWRTQ,R4	;GET TOP OF THE WRITE QUEUE
	BEQ	CHCKRD		;NO MORE, GO CHECK READ COMPLETION QUEUE
	MOV	@CHWRTQ,CHWRTQ	;MORE, BUT DE-QUEUE THIS ONE
	MOV	R4,-(SP)	;SAVE THIS DSQ POINTER
	CALL	RETWTG		;RETURN THE WRITE-TAG AND FIX UP DSQ
	CALL	CPYDSQ		;COPY DSQ INTO THE FAKE DSQ
	CALL	MASHER		; AND MASH THE FAKE DSQ
	CALL	CHMDSQ		;INIT FAKE DSQ FOR CLUSTER AT A TIME CHECK
20$:

.IF	NE	CSTATS

	CLR	CHETIC		;STOP CHARGING CACHE TIME

.ENDC

	CALL	CRNDSQ		;SET UP FAKE DSQ FOR NEXT CLUSTER
	BCC	10$		;NONE LEFT, ALL DONE
	CALL	SEARCH,R1	;IS THIS TAG IN THE CACHE?
	  BR	20$		;NO (IF ERROR, SEARCH TOOK CARE OF IT)
	INCSTA	WTS.CH		;TOTAL WRITE TAG HITS
	CALL	MOVER		;GO DO THE MEMORY TO MEMORY MOVE
	BR	20$		; AND GET NEXT CLUSTER

.DSABL	LSB

GLOBAL	<RSTAP5>							;014

.SBTTL	CACHE READ COMPLETIONS

.ENABL	LSB

10$:	JMPX	RTI3		;FINAL EXIT

20$:	MOV	R1,(SP)		;SAVE REAL DSQ POINTER FOR HOUSEKEEPING
	TSTB	DSQERR(R4)	;WAS THERE AN ERROR ON THIS TRANSFER?
	BMI	30$		;NO, SO CONTINUE
	MOVB	DSQERR(R4),DSQERR(R1) ;TRANSFER ERROR INDICATOR TO REAL DSQ
30$:	BUFFER	RETSML		;RETURN DSQ FOR SEGMENT READ (DON'T NEED IT)
	MOV	(SP)+,R4	;GET POINTER TO ORIGINAL READ DSQ AGAIN
	DEC	(R4)		;WAS THIS THE LAST SEGMENT OF REAL DSQ?
	BNE	40$		;NO
	CALL	UNMASH		;YES, IT IS MASHED, SO FIX IT
	CALLX	DISKER		; THEN HOUSEKEEP UP THE REQUEST
40$:

.IF	NE	CSTATS

	CLR	CHETIC		;STOP CHARGING CACHE TIME

.ENDC

	MOV	#CHCKRD,-(SP)	;SET RETURN ADDRESS FOR CHECKING READS AGAIN
CHKTMW:	TST	CHEWTG		;ARE ANY WRITE-TAGS AVAILABLE?
	BEQ	60$		;NO, EXIT
	MOV	TMWQUE,R4	;ANY WRITES WAITING IN "REQUEUE QUEUE"?
	BEQ	60$		;NOPE, EXIT
	MOV	(R4),TMWQUE	;YEP, DE-QUEUE TOP ITEM
	CALLX	DISK		; AND GO TRY IT AGAIN
	BR	CHKTMW		;NOW GO CHECK AGAIN...

CHCKRD:	MOV	CHREDQ,R4	;GET TOP OF THE READ QUEUE
	BEQ	10$		;NO MORE READS, EXIT
	MOV	@CHREDQ,CHREDQ	;MORE, BUT DE-QUEUE THIS ONE

.IF	NE	CSTATS

	INC	CHETIC		;START CHARGING CACHE TIME

.ENDC

	MOV	R4,-(SP)	;SAVE THIS DSQ POINTER
	MOV	DSQMSC(R4),R1	;GET WRITE-TAG POINTER TO REAL DSQ POINTER
	CMP	R1,#140000	;IS IT A WRITE-TAG?
	BLO	20$		;NO, A SEGMENT OF A LARGER READ

.SBTTL	HANDLE A CACHE INSTALL READ
                
	CALL	RETWTG		;RETURN WRITE-TAG AND FIX UP DSQ
	ADD	R2,DSQFBL(R4)	;CORRECT FBN LSB FOR REAL DISK ADDRESS
	ADCB	DSQFBM(R4)	; AND CARRY ANY CARRY
	MOVB	R5,DQ.CHM(R4)	;(RE-)SET CORRECT CACHEING MODE
	MOV	CH.TYP(R0),DQ.TYP(R4) ; AND (RE-)SET TYPE POINTER
	CALL	MASHER		;(RE-)MASH THE INSTALLING DSQ
	TSTB	DSQERR(R4)	;WAS THERE AN ERROR?
	BMI	50$		;NO, SO PROCEED
	TST	(R0)+		;YES, INDEX TO CH.PRV IN TAG
	SPLC	7		;;;LOCKOUT INTERRUPTS
	CALL	MOVEND		;;;MOVE FAILING TAG TO END OF LIST AS INVALID
50$:	MOV	CH.BLS(R0),R4	;GET NEXT DSQ IN BUSY LIST FOR TAG
	CMP	R4,(SP)		;IS THIS THE ENDING INSTALLING DSQ?
	BNE	80$		;NOPE, GO PROCESS A PENDING MASHED DSQ
	CALL	90$		;YEP, PROCESS THE INSTALLING DSQ
	CLR	CH.BLS(R0)	;THE TAG'S BUSY LIST IS NOW EMPTY
	MOV	#40$,(SP)	;CLOBBER DSQ ADDRESS WITH A LOOPING RETURN
60$:	RETURN			;DO A RETURN...

70$:	CALL	UNMASH		;FIX UP THE MASHED DSQ
	BISB	#200,DSQJOB(R4)	;SET "NO CACHE" INDICATOR
	CALLRX	DISK		;GO REDO THIS TRANSFER & RETURN

80$:	MOV	(R4),CH.BLS(R0)	;DE-QUEUE THIS MASHED PENDING DSQ
	MOV	#50$,-(SP)	;BUT SET A RETURN ADDRESS TO LOOP...
90$:	TSTB	CH.UNT(R0)	;IS THIS A VALID TAG?
	BMI	70$		;NO
	TST	(R0)+		;YES, INDEX TO CH.PRV IN TAG
	SPLC	7		;;;NO INTERRUPTIONS PLEASE
	UNLINK	CH.PRV		;;;UNLINK TAG FROM THE ACTIVE LIST
	SPLC	3		;;;BACK TO LEVEL 3 AGAIN
	.BR	READNE		;PERFORM CACHE READ HIT HOUSEKEEPING & RETURN

.DSABL	LSB

.SBTTL	DO CACHE READ HIT HOUSEKEEPING

; READNE - DO CACHE READ HIT HOUSEKEEPING.
;
;	R0 -> TAG @ CH.UNT (UNLINKED)
;	R4 -> MASHED DSQ
;	APR6 MAPS TAGS
;
;	CALL	READNE
;
;	R0 -> TAG (LINKED)
;	R1 =  UNDEFINED
;	R2 =  UNDEFINED
;	R3 =  UNDEFINED
;	R4 =  UNDEFINED
;	RESTARTS DISABLED

READNE:	INC	CH.BLS-CH.UNT(R0) ;MARK AS BUSY TO AVOID A RELEASE
	CALL	MOVER		;DO THE NECESSARY MEMORY TO MEMORY MOVE
	TSTB	DQ.CHM(R4)	;IS THIS SEQUENTIAL MODE?
	BEQ	30$		;NOPE
	CMP	DQ.NCB(R4),CHEBSZ ;YEP, AFFECT LAST BLOCK OF FIRST CLUSTER?
	BLO	30$		;NOPE AGAIN
	CLR	CH.TIM(R0)	;YEP, SET TIME TO "INFINITE"
	TST	(R0)+		;POINT TO CH.PRV IN TAG
	MOV	#CHENXT,R3	;GET A POINTER FOR LIST SEARCHING
	SPLC	7		;;;LOCKOUT INTERRUPTS
	UNLINK	CH.PRV		;;;REMOVE TAG FROM ACTIVE LIST
10$:	MOV	CH.PRV(R3),R3	;;;GET NEXT PREVIOUS TAG
	CMP	R3,#CHENXT	;;;HAVE WE COME FULL CIRCLE?
	BEQ	20$		;;;YES, QUIT
	TSTB	CH.UNT(R3)	;;;NO, AN INVALID TAG?
	BMI	10$		;;;SKIP INVALIDS
	TST	CH.TIM(R3)	;;;AN "INFINITE" TAG?
	BEQ	10$		;;;SKIP "INFINITE"S
20$:	MOV	(R3),R3		;;;GET CORRECT PREVIOUS FOR LINKING
	CALL	LNKTAG		;;; AND GO LINK THE TAG BACK INTO LIST
30$:	DEC	CH.BLS(R0)	;SAY TAG NO LONGER ARTIFICALLY BUSY
	CALL	UNMASH		;FIX UP THE FBN IN THE DSQ
	CALLRX	DISKER		;HOUSEKEEP REQUEST & RETURN

.SBTTL	LINK TAGS TO LIST

; LINKIT - LINK A TAG TO HEAD OF LIST AND UPDATE REFERENCE TIME.
;
;	R0 -> TAG @ CH.UNT (UNLINKED)
;
;	CALL	LINKIT
;
;	R0 -> TAG (LINKED)
;	R3 =  UNDEFINED
;	RESTARTS DISABLED, APR6 MAPS TAGS

LINKIT:	MAP	CHEPAR,APR=6,DATA ;SET MAPPING TO TAGS
	MOV	CHESEC,CH.TIM-CH.UNT(R0) ;UPDATE TIME OF LAST REFERENCE
	SPLC	7		;;;LOCKOUT INTERRUPTS FOR LINK
	MOV	CHENXT,R3	;;;GET THE ROOT TO LINK TO HEAD OF LIST

; LNKTAG - LINK A TAG TO LIST
;
;	R0 -> TAG @ CH.UNT (UNLINKED)
;	R3 -> TO-BE-NEXT TAG @ CH.PRV
;	APR6 MAPS TAGS, PRIORITY IS PR7
;
;	CALL	LNKTAG
;
;	R0 -> TAG (LINKED)
;	R3 =  UNDEFINED
;	RESTARTS DISABLED, PRIORITY IS PR3

LNKTAG:	MOV	(R3)+,-(R0)	;;;SET NEW PREV PTR TO NEXT'S PREV PTR
	MOV	R0,@-(R3)	;;; AND CROSS-LINK
	MOV	R3,-(R0)	;;;SET NEW NEXT PTR TO R3'S NEXT PTR
	MOV	R0,(R3)		;;; AND CROSS-LINK
	CLR	REFLAG		;;;DISABLE RESTARTS
	SPLC	3		;;;BACK TO LEVEL 3 AGAIN
	RETURN			; AND EXIT

; LNKINV - LINK A TAG TO TAIL OF LIST MAKING IT AN INVALID, NON-BUSY TAG.
;
;	R0 -> TAG (UNLINKED)
;	APR6 MAPS TAG
;
;	CALL	LNKINV
;
;	R0 -> TAG (LINKED)
;	R3 =  UNDEFINED
;	RESTARTS DISABLED

.ENABL	LSB

LNKINV:	CLR	CH.BLS(R0)	;ZERO THE TAG'S BUSY LIST
	CMP	(R0)+,(R0)+	;POINT AT CH.UNT
	SPLC	7		;;;HAVE TO BE SAFE
	BR	10$		;;;GO MAKE INVALID AND LINK IT

; MOVEND - MOVE TAG TO END OF LIST MAKING IT AN INVALID TAG.
;
;	R0 -> TAG @ CH.PRV (LINKED)
;	APR6 MAPS TAG, PRIORITY IS PR7
;
;	CALL	MOVEND
;
;	R0 -> TAG (LINKED)
;	R3 =  UNDEFINED
;	RESTARTS DISABLED, PRIORITY IS PR3

MOVEND:	UNLINK	CH.PRV		;;;UNLINK TAG FROM ACTIVE LIST
	DEC	@CH.TYP-CH.UNT(R0) ;;; AND CORRECT THE USAGE COUNTER
10$:	MOV	#CHEINV,CH.TYP-CH.UNT(R0) ;;;POINT TO INVALID COUNTER
	INC	CHEINV		;;; AND COUNT THIS INVALID TAG
	MOVB	#-1,(R0)	;;;ENSURE TAG IS MARKED AS INVALID
	MOV	#CHEPRV,R3	;;;POINT AT END OF TAG LIST
	BR	LNKTAG		;;;GO LINK TAG AND EXIT

.DSABL	LSB

.SBTTL	TRANSFORM DSQ INTO A FORM WHICH IS EASIER FOR CACHE CODE

; MASHER - TRANSFORM DSQ INTO A FORM WHICH IS EASIER FOR CACHE CODE.
;
;	R4 -> DSQ
;
;	CALL	MASHER
;
;	R1 =  NUMBER OF CACHE CLUSTERS
;	R3 =  UNDEFINED
;	R4 -> MASHED DSQ
;		DSQFBM,DSQFBL = FBN ROUNDED DOWN TO START OF A CACHE CLUSTER
;		DQ.COF = BLOCK OFFSET FROM START OF CACHE CLUSTER
;		DQ.NCB = NUMBER OF BLOCKS AFFECTED BY TRANSFER
;		DQ.NCL = NUMBER OF CACHE CLUSTERS
;
;	INSTALL ON MISS IS INHIBITED IF TRANSFER CROSSES LAST BLOCK OF
;	FIRST CLUSTER AND MODE IS SEQUENTIAL.

MASHER:	MOV	DSQFBL(R4),R3	;GET LSB OF THE FBN
	SUB	#1,R3		;MAKE THE FBN
	SBCB	DSQFBM(R4)	; ZERO BASED
	MOV	R3,DSQFBL(R4)	;RE-STORE FBN LSB
	BIC	CHEBIC,R3	;FIND OFFSET INTO A CACHE CLUSTER
	MOVB	R3,DQ.COF(R4)	; AND SAVE IT
	BIC	R3,DSQFBL(R4)	;SET FBN LSB TO A CACHE CLUSTER START
	MOV	DSQCNT(R4),R1	;GET THE LENGTH OF THE TRANSFER IN WORDS
	ADD	#400-1,R1	;ROUND UP BLOCK COUNT
	ASH	#-8.,R1		; AND CONVERT TO BLOCKS
	ADD	R3,R1		;ROUND UP NUMBER OF BLOCKS FOR CLUSTER OFFSET
	MOV	R1,DQ.NCB(R4)	;SAVE NUMBER OF BLOCKS AFFECTED BY TRANSFER
	TSTB	DQ.CHM(R4)	;IS THIS SEQUENTIAL CACHEING?
	BEQ	10$		;NOPE, SO PROCEED
	CMP	R1,CHEBSZ	;TRANSFER AFFECT LAST BLOCK OF 1ST CLUSTER?
	BLO	10$		;NOPE, GO AHEAD AND DO IT
	BISB	#200,DQ.CHM(R4)	;INHIBIT INSTALL ON MISS!
10$:	ADD	CHEBSZ,R1	;ROUND UP
	DEC	R1		; NUMBER OF BLOCKS
	ASH	CHESHF,R1	;FIND NUMBER OF CLUSTERS
	MOVB	R1,DQ.NCL(R4)	; AND SAVE IT
	RETURN			; AND EXIT

.SBTTL	MULTI-CLUSTER SUBROUTINES

; CHMDSQ - SET UP MASHED FAKE DSQ TO EXAMINE CLUSTER AT A TIME.
;
;	R4 -> MASHED FAKE DSQ
;
;	CALL	CHMDSQ

CHMDSQ:	MOV	DSQCNT(R4),DQ.WRT(R4) ;SAVE WORD COUNT OF TRANSFER
	CLR	DSQCNT(R4)	; AND CLEAR COUNT DONE LAST TRY
	RETURN			;EXIT

; CRNDSQ - SET UP MASHED FAKE DSQ FOR NEXT CLUSTER OF TRANSFER.
;
;	R4 -> MASHED FAKE DSQ
;                  
;	CALL	CRNDSQ
;
;	R1 =  UNDEFINED
;	R2 =  UNDEFINED
;
;	IF C=0 THEN NO DATA LEFT TO TRANSFER
;	IF C=1 THEN DSQ SET UP TO TRANSFER NEXT CLUSTER

CRNDSQ:	TST	DQ.WRT(R4)	;ANY DATA LEFT TO TRANSFER?
	BLE	30$		;NO (AND CARRY ALREADY CLEAR FROM 'TST')
	MOV	CHEBSZ,R1	;YES, GET CACHE CLUSTER SIZE
	MOV	DSQCNT(R4),R2	;GET WORD COUNT OF LAST TRANSFER
	BEQ	10$		;THIS IS THE FIRST, SO SKIP NEXT PART
	CLRB	DQ.COF(R4)	;OFFSET IS ZERO FOR SUBSEQUENT TRANSFERS
	ASL	R2		;CONVERT WORD COUNT TO BYTES
	ADD	R2,DSQMAL(R4)	;UPDATE THE MEMORY ADDRESS
	ADCB	DSQMAM(R4)	; IN DOUBLE PRESCISION
	ADD	R1,DSQFBL(R4)	;UPDATE DISK ADDRESS
	ADCB	DSQFBM(R4)	; IN DOUBLE PRESCISION
10$:	MOVB	DQ.COF(R4),R2	;GET OFFSET INTO CACHE CLUSTER
	SUB	R2,R1		;SUB STARTING POINT TO GET BLOCKS TO END
	SWAB	R1		;CONVERT TO A WORD COUNT
	SUB	R1,DQ.WRT(R4)	; AND SUBTRACT THAT COUNT FROM WORDS REMAINING
	BPL	20$		;HAVEN'T EXCEEDED WORD COUNT YET
	ADD	DQ.WRT(R4),R1	;ELSE CORRECT FINAL WORD COUNT
20$:	MOV	R1,DSQCNT(R4)	;STORE WORD COUNT FOR THIS TRANSFER
	SEC			;SET CARRY TO INDICATE VALID TRANSFER
30$:	RETURN			;EXIT

.SBTTL	TRY TO GET A CACHE CLUSTER FROM THE XBUF POOL

; GETNTG - GET A NEW TAG AND BUFFER FOR THE CACHE.
;
;	CALL	GETNTG
;
;	R0 -> NEW CACHE TAG (UNLINKED)
;	R1 =  UNDEFINED
;	R2 =  UNDEFINED
;	R3 =  UNDEFINED
;	R5 =  UNDEFINED
;	APR6 MAPS TAGS
;
;	IF C=0 THEN NEW TAG OBTAINED
;	IF C=1 THEN NO NEW TAG AVAILABLE

GETNTG:	MOV	R4,-(SP)	;SAVE R4
	CMP	CHENUE,CHELIM	;IS NUMBER OF EXTENDED BUFFERS AT LIMIT?
	BHIS	40$		;YES, SO DON'T ATTEMPT TO ALLOCATE MORE
	MOV	CHLFXB,R1	;FIND TIME OF
	SUB	@#TIME,R1	; LAST ALLOCATE FAILURE
	CMP	R1,#2.		;HAS IT BEEN LONG ENOUGH?
	BLO	40$		;NO, FAILURE RIGHT OFF...
	TST	CHETAG		;ANY FREE EXTENDED TAGS?
	BEQ	20$		;NO
	MOV	#CI$DSK!CI$NSP,R0 ;Yes, inhibit calling ourselves and NSP ;016
	MOV	CHEBSZ,R1	;YES, GET CLUSTER SIZE IN BLOCKS
	ASH	#4,R1		;Now in 40(8) byte units (BLK*1000/40=BLK*20) ;016
	MOV	#-1,R2		;Don't even think about MONPOL		;016
	MOV	#LRGPOL,R4	;But LRGPOL or EXTPOL is fine		;016
	CALLX	GETBUF		;Now try to get that buffer space	;016
	BCC	30$		;Got a buffer, go use it		;016
20$:	MOV	@#TIME,CHLFXB	;THIS TIME WE TRIED AND FAILED
	BR	40$		; SO GIVE UP

30$:	MAP	CHEPAR,APR=6,DATA ;Map the cache tags again		;016
	SPLC	7		;Protect against cache givebacks	;016
	MOV	CHETAG,R0	;;;GET THE TAG TO USE
	MOV	(R0),CHETAG	;;; AND DE-LINK IT FROM FREE TAG LIST
	SPLC	3		;;;DROP BACK TO LEVEL 3 AGAIN
	INC	CHENUE		;ONE MORE EXTENDED CACHE TAG NOW
	MOV	R4,R3		;Copy contorted address of buffer	;016
	ASHC	#-7,R3		;Make it into a MMU address		;016
	MOV	R3,CH.DAT(R0)	;SET DATA POINTER IN THE TAG
	TST	(PC)+		;SET C=0 FOR O.K.
40$:	SEC			;SET C=1 FOR FAILURE
	MOV	(SP)+,R4	;RESTORE R4
	RETURN			; AND EXIT

GLOBAL	<LRGPOL,EXTPOL,DPAR6>

; CPYDSQ - COPY A DSQ INTO FAKE DSQ.
;
;	R4 -> DSQ
;
;	CALL	CPYDSQ
;
;	R3 =  UNDEFINED
;	R4 -> FAKE DSQ

CPYDSQ:	MOV	#FAKDSQ,R3	;POINT TO OUR FAKE DSQ
10$:	MOV	(R4)+,(R3)+	;COPY THE DSQ
	CMP	R3,#FAKDSQ+DSQSIZ ;DONE?
	BLO	10$		;NOT YET...
	MOV	#FAKDSQ,R4	;NOW POINT TO THE FAKE DSQ
	RETURN			;EXIT

.SBTTL	GET AND LOAD A WRITE-TAG

; GETWTG - GET AND LOAD A WRITE-TAG.
;
;	R4 -> DSQ
;
;	CALL	GETWTG
;
;	R3 -> LOADED WRITE-TAG @ WT.MSC
;
;	IF Z=0 THEN WRITE-TAG OBTAINED
;	IF Z=1 THEN NO WRITE-TAGS AVAILABLE

GETWTG:	MOV	CHEWTG,R3	;GET A WRITE-TAG
	BNE	10$		;ONE OBTAINED
	TST	CHETAG		;NONE, ANY CACHE TAGS AVAILABLE?
	BEQ	30$		;NO TAGS AT ALL, GO EXIT Z=1 (SINCE 'BEQ')
	SPLC	7		;;;NO INTERUPTIONS PLEASE
	MOV	CHETAG,R3	;;;GET A CACHE TAG FOR A WRITE-TAG
	MOV	(R3),CHETAG	;;; FROM THE CACHE TAG LIST
	SPLC	3		;;;NOW BACK TO LEVEL 3
	MOVB	(PC),(R3)+	;SAY REALLY A CACHE TAG @ WT.TYP (<>0)
	BR	20$		;GO USE AS A WRITE-TAG

10$:	MOV	(R3),CHEWTG	;DE-LINK WRITE-TAG FROM FREE LIST
	CLRB	(R3)+		;SAY REAL WRITE-TAG @ WT.TYP (=0)
20$:	MOVB	DSQMAM(R4),(R3)+ ;SAVE "DSQMAM" @ WT.MAM
	MOV	DSQMAL(R4),(R3)+ ;SAVE "DSQMAL" @ WT.MAL
	MOV	DSQCNT(R4),(R3)+ ;SAVE "DSQCNT" @ WT.CNT
	MOV	DSQL3Q(R4),(R3)+ ;SAVE "DSQL3Q" @ WT.L3Q
	CMP	(R3)+,(R3)+	;SKIP WT.COF, WT.CHM, WT.CTP
	MOV	DSQMSC(R4),(R3)	;SAVE "DSQMSC" @ WT.MSC
	MOV	R3,DSQMSC(R4)	; THEN POINT TO WRITE-TAG @ WT.MSC
	;CLZ			;Z=0 SINCE R3 <> 0
30$:	RETURN			;EXIT WITH Z-BIT INDICATION

.SBTTL	RELEASE A WRITE-TAG AND FIX UP THE DSQ

; RETWTG - RELEASE A WRITE-TAG AND FIX UP THE DSQ.
;
;	R4 -> DSQ
;
;	CALL	RETWTG
;
;	R0 -> CACHE TAG (FROM WT.CTP)
;	R1 =  UNDEFINED
;	R2 =  SAVED DQ.COF (FROM WT.COF)
;	R3 =  UNDEFINED
;	R5 =  SAVED DQ.CHM (FROM WT.CHM)
;	APR6 MAPS TAGS

RETWTG:	MAP	CHEPAR,APR=6,DATA ;MAP CACHE TAG AREA
	MOV	DSQMSC(R4),R1	;GET POINTER TO WRITE-TAG @ WT.MSC
	MOV	(R1),DSQMSC(R4)	; AND RESTORE "DSQMSC" FROM WT.MSC
	MOV	-(R1),R0	;GET CACHE TAG POINTER FROM WT.CTP
.ASSUME	WT.CTP	EQ	WT.MSC-2
	MOVB	-(R1),R5	;GET SAVED DQ.CHM FROM WT.CHM
.ASSUME	WT.CHM	EQ	WT.CTP-1
	MOVB	-(R1),R2	;GET SAVED DQ.COF FROM WT.COF
.ASSUME	WT.COF	EQ	WT.CHM-1
	MOV	-(R1),DSQL3Q(R4) ;RESTORE "DSQL3Q" FROM WT.L3Q
.ASSUME	WT.L3Q	EQ	WT.COF-2
	MOV	-(R1),DSQCNT(R4) ;SET "DSQCNT" FROM WT.CNT
.ASSUME	WT.CNT	EQ	WT.L3Q-2
	MOV	-(R1),DSQMAL(R4) ;SET "DSQMAL" FROM WT.MAL
.ASSUME	WT.MAL	EQ	WT.CNT-2
	MOVB	-(R1),DSQMAM(R4) ;SET "DSQMAM" FROM WT.MAM
.ASSUME	WT.MAM	EQ	WT.MAL-1
	MOV	#CHEWTG,R3	;GUESS AT A REAL WRITE-TAG
	TSTB	-(R1)		;A REAL OF CACHE TAG (WT.TYP)?
	BEQ	10$		;REAL WRITE-TAG
.ASSUME	0	EQ	WT.MAM-1
	MOV	#CHETAG,R3	;A CACHE TAG, CHANGE POINTER
	SPLC	7		;;;NO INTERRUPTIONS PLEASE
10$:	MOV	(R3),(R1)	;;;RE-LINK TAG
	MOV	R1,(R3)		;;; TO FREE LIST
	SPLC	3		;;;BACK TO LEVEL 3
	RETURN			; AND EXIT

.SBTTL	CACHE DATA MOVING SUBROUTINE
                                       
; MOVER - CACHE DATA MOVING SUBROUTINE.
;
;	R0 -> TAG @ CH.UNT (UNLINKED)
;	R4 -> MASHED DSQ
;	APR6 MAPS TAGS
;               
;	CALL	MOVER
;
;	R0 -> TAG (LINKED TO FRONT)
;	R1 =  UNDEFINED
;	R2 =  UNDEFINED
;	R3 =  UNDEFINED

	TMPORG	CHEISP							;019

MOVER:	MAP	PUSH,APR=5,DATA	;SAVE THE PAR5 VALUE
	MAP	CH.DAT-CH.UNT(R0),APR=5,DATA ;MAP THE CACHE DATA
	MOVB	DQ.COF(R4),R1	;GET BLOCK OFFSET INTO CACHE CLUSTER
	SWAB	R1		;CONVERT INTO WORDS
	ASL	R1		; THEN BYTES
	ADD	#120000,R1	;FORM POINTER (THROUGH PAR5) TO CACHE DATA
	MOV	DSQMAL(R4),R3	;GET THE LSB
	MOVB	DSQMAM(R4),R2	; AND MSB OF THE MEMORY BUFFER
	ASHC	#10.,R2		;FORM INTO MMU ADDRESS IN EVEN REGISTER
	ASHC	#-10.,R3	; AND REMAINDER IN ODD REGISTER
	MAP	R2,APR=6,DATA	;PUT MMU ADDR OF MEMORY BUFFER IN PAR6
	ADD	#140000,R3	; AND POINT (THROUGH PAR6) TO IT
	CMPB	DSQFUN(R4),#RFUN ;CHECK FOR READ OR WRITE
	BHIS	10$		;READ, FROM CACHE TO MEMORY BUFFER
.ASSUME	WFUN	LT    	RFUN
	MOV	@DPAR5,@DPAR6   ;MOVE PAR5 INTO PAR6
	ADD	#20000,R1	; AND POINT (THROUGH PAR6) TO CACHE DATA
	MAP	R2,APR=5,DATA	;MAP MEMORY BUFFER THROUGH PAR5
	SUB	#20000,R3	; AND CORRECT THE POINTER FOR PAR5
	MOV	R1,R2		;NOW INTERCHANGE THE
	MOV	R3,R1		; POINTERS FOR CORRECT
	MOV	R2,R3		;  MOVE DIRECTION
10$:	MOV	DSQCNT(R4),R2	;GET THE WORD COUNT FOR MOVE
	CALLX	MOVWRD		;GO DO THE DATA MOVE
	MAP	POP,APR=5,DATA	;RESTORE THE PAR5 VALUE
	CALLR	LINKIT		;NOW LINK TAG TO FRONT OF LIST & EXIT

	UNORG
GLOBAL	<DPAR5,DPAR6>

.SBTTL	CACHE LIST SEARCH SUBROUTINE
        
; SEARCH - SEARCH FOR A CACHE TAG HIT.
;
;	R4 -> MASHED DSQ
;
;	CALL	SEARCH,R1
;
;	FIRST EXIT MEANS NOT FOUND OR FOUND WITH ERROR
;
;		R0 =  UNDEFINED
;		R3 =  UNDEFINED
;
;	SECOND EXIT MEANS FOUND (NO ERROR)
;
;		R0 -> TAG @ CH.UNT (UNLINKED)
;		R3 =  UNDEFINED

SEARCH:	ADD	#DSQFBL,R4	;INDEX TO DISK ADDRESS IN DSQ
	CALL	RESTRT		;SET RESTART ADDRESS
10$:	MOV	-(R0),R0	;ADVANCE FORWARD TO THE NEXT ELEMENT
	CMP	R0,R3		;HAVE WE GONE ALL THE WAY AROUND?
	BEQ	30$		;YES, SO NOT FOUND, FIRST EXIT
	CMP	(R4),CH.LSB-CH.PRV(R0) ;LSB MATCH?
	BNE	10$		;NO
	CMP	DSQUNT-DSQFBL(R4),CH.UNT-CH.PRV(R0) ;UNIT AND MSB MATCH?
	BNE	10$		;NO
	SPLC	7		;;;YES, LOCKOUT INTERRUPTS
	TSTB	DSQERR-DSQFBL(R4) ;;;DID AN ERROR OCCUR?
	BMI	20$		;;;NOPE, UNLINK AND TAKE 2ND EXIT
	CALL	MOVEND		;;;YEP, MOVE TO END OF LIST AS INVALID
	BR	40$		;NOW TAKE THE FIRST EXIT

20$:	UNLINK	CH.PRV		;;;DETACH THE MATCHING ENTRY FROM THE LIST
	TST	(R1)+		;;;TAKE THE 2ND EXIT FOR FOUND O.K.
30$:	CLR	REFLAG		;;;DISABLE RESTARTING
	SPLC	3		;;;ALLOW INTERRUPTS AGAIN
40$:	SUB	#DSQFBL,R4	;BACK TO THE TOP OF THE DSQ
	RETURN	R1		; AND EXIT

.SBTTL	DISK CACHE CLUSTER SIZE CHANGE SUBROUTINE

;+
; CHEUUO - DISK CACHE FLUSH OR CLUSTER SIZE CHANGE SUBROUTINE.
;
;	R1 =  0  ->  FLUSH THE CACHE
;
;		OR
;
;	R1 =  NEW DISK CACHE CLUSTER SIZE (1, 2, 4, OR 8)
;	R2 =  NEW DISK CACHE CLUSTER SHIFT (0, -1, -2, OR -3)
;
;	CALL	CHEUUO
;-

	TMPORG	CHEUUO

CHEUUO:	CALLMR	CHEUUX,RSTAP5	;GO TO THE MAPPED CODE...		;014

	UNORG

CHEUUX:	REGSCR			;SAVE ALL REGISTERS
	MOV	DPAR6,R3	;SET R3 -> PAR6
	MOV	(R3),-(SP)	;SAVE THE PAR6 VALUE
10$:	MOV	#140000,R5	;SET R5 = 140000 FOR A MAPPED POINTER	;017
	MOV	#PR3,R1		;Set to drop to PR3 when returning tags	;016
	MOV	CHEPAR,(R3)	;MAP CACHE TAG AREA
	SPLC	7		;;;DISABLE INTERRUPTS
	MOV	CHEPRV,R2	;;;GET LAST TAG IN LIST			;016
	CMP	R2,#CHENXT	;;;ALL DONE?				;016
	BEQ	30$		;;;YES
	TST	CH.BLS(R2)	;;;IS THIS TAG BUSY?			;016
	BNE	20$		;;;YES, IT CAN'T BE RELEASED RIGHT NOW
	CALL	RELTAG		;;;ELSE RELEASE THIS TAG TO BUFFER POOL
	BR	10$		; AND LOOP...

20$:	ERROR	INUSE		;;;NO CHANGE POSSIBLE RIGHT NOW...

30$:	SPLC	3		;;;BACK DOWN TO LEVEL 3
	MOV	(SP)+,(R3)	;RESTORE PAR6 VALUE
	MOV	#CHEBSZ,R3	;GET POINTER TO CACHE CLUSTER SIZE PARAMETERS
	MOV	TOS.R1(SP),R1	;GET NEW CACHE CLUSTER SIZE
	BEQ	40$		;NO NEW CLUSTER SIZE, JUST FLUSHING ...
	MOV	R1,(R3)+	;SET CACHE CLUSTER SIZE @ CHEBSZ
	MOV	TOS.R2(SP),(R3)+ ; AND SHIFT VALUE FOR DIVIDE @ CHESHF
	DEC	R1		;NOW COMPUTE MASK VALUE (SIZE - 1)
	MOV	R1,(R3)+	; AND SET IT @ CHEMBM
	COM	R1		;NOW COMPLEMENT OF MASK
	MOV	R1,(R3)+	; AND SET IT @ CHEBIC
40$:	CLR	CHLFXB		;REALLY TRY FOR XBUF NEXT TIME
	RETURN			;EXIT

GLOBAL	<DPAR6>

.END

