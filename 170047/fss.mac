.INCLUDE /CMN:COMMON/
.INCLUDE /CMN:KERNEL/
.INCLUDE /CMN:FLDEF/
.INCLUDE /CMN:PFBDEF/
.INCLUDE /CMN:HDRDEF/
.LIBRARY /CMN:NETDEF.SML/
TITLE	FSS,<FIP RELATED MONITOR CALLS>,0B,21-JUN-91,MHB/ABC/GPK/SJM/WJS/JTC/FEK/KPH/FRL/MNB/PJH/DSD/WRM

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR FSS

;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;  001	TG   27-Jun-80	Added Namdir & GEN phase stuff
;  002	TG   25-Jul-80	Fixed Wild card bug in .FSS
;  003	MD   15-SEP-80	Allow entry to SCANPK from EMT dispatch
;  004	PK   16-Feb-81	Added XPEEK and DDCU
;  005	SRM  26-Jun-81	Allow zero length messages in .MESAG.
;  006	MDS  03-Jun-81	Added Bramhall fixes and the /PROTECT switch
;  007	WJS  09-Jul-81	Merged edit 005 into MDS' version 006;
;			  added JTC's APR6 changes and "$" processing
;  008  SJM  08-Jul-81	Added support for I&D space.
;  009	GPK  10-Aug-81	Added REDO entry for .MESAG
;  010	JTC  15-Sep-81	Changed /PROTECT to /PROTECTION
;  011	JTC  21-Sep-81	FIP in APR6, new resident overlay scheme
;  012	JTC  13-Oct-81	Map the FIP Pool for CCL's.
;  013	JTC  13-Nov-81	Fix CCL /SI:+n and /PROTECTION w/ default prot
;  014	GPK  11-Nov-81	Change .MESAG dispatching of overlay functions
;			to distinguish sync vs. non-sync, and to leave
;			job locked in memory if needed.
;  015	WJS  15-Sep-82	EMTLOG packet-build added
;  016  WJS  27-Oct-82	BL4 changes for EMT Logger
;  017	AWL  23-Nov-82	Allow UUO to be "locked"
;  018	WJS  17-Dec-82	BL4+ changes for EMT Logger
;  019	WJS  31-Jan-83	8-bit char mods;  "command" form of .RUN entry;
;				allow 32K max in CCL switch
;
;				[RSTS V9.0]
;  020	GPK  31-Mar-83	Multiple privileges
;  021	WJS  04-May-83	Repair broken /SIZE & co in CCL's
;  022	GPK  07-Jun-83	Change .PRIV to .BPRIV
;  023  BSB  29-Jun-83	Add .PFB support
;  024	FEK  05-Jul-83	Support for user I/D space
;  025	BSB  17-Aug-83	Moved .EQUATES for PFB function limits from KERNEL 
;			to here
;  026	GPK  21-Sep-83	FSS enhancements, more multipriv stuff
;  027	GPK  01-Nov-83	.PFB changes for ICFP and monitor record I/O
;  028	KPH  17-Jan-84	Add 8-bit support to .FSS
;  030	GPK  08-Mar-84	Added exit/run cleanup; exit status reset
;  031  FRL  01-Apr-84  Allow $ as non-first character in logical name
;  032  FRL  01-Apr-84  Add a new flag to indicate suppression of user 
;			logical translation
;  033	KPH  11-Apr-84	Add LOGR50 subroutine
;  034	GPK  20-Apr-84	Move PFBIO, .MESAG, .XPEEK to EM2 phase
;  035  MNB  26-Apr-84	Trash RUN/CHAIN/CCL if pending asynch I/O
;  036	KPH  02-Jul-84	Move UU.MNT -> UU.TRM to MNT overlay
;			Bugfixes
;			If "$" CCL not defined, go to DCL
;			Have .CCL directive set flags for .CMDLN
;  037	KPH  21-Sep-84	Change .CMDLN flag setting from .CCL
;			Changes for APR5 FIP pool
;  038	KPH  24-Oct-84	Change .UUO to set up data for control/t
;			Add 8-bit support to .CCL (sort-of)
;  039	KPH  28-Nov-84	Add 8-bit uppercasing to .CCL
;  040	KPH  10-Jan-85	Disallow invalid characters in .FSS
;
;			[RSTS V9.2]
;  041  KPH  08-Aug-85	Move IOB to FIP pool
;			Add job control region
;  042  KPH  03-Jan-86	Disallow missing unit number in DDCU names
;  043  KPH  14-Feb-86	Add privileges to fake CCL block
;
;                       [RSTS V9.4]
;  044  PJH  28-JAN-87  Fix protection code saved from prev .FSS call
;
;			[RSTS V9.6]
;  045	DSD  22-FEB-88	Add wildcard name* type strings in .FSS call
;
;			[RSTS V10.0]
;  046	DRP  25-Sep-89	Fix FSS to handle controller syntax of devices
;			correctly.
;  047  WRM  03-Nov-89	Add extended logical features.
;  048  WRM  25-Jan-90	Allow underline in logicals
;  049  WRM  24-Apr-90	Change error code on logical /noreplace
;
;			[RSTS V10.1]
;  050  WRM  20-Nov-90	fix UU.DEA default case action to clr all logicals
;  051	DRP  04-Jun_91	Fix allocation bug in LOGHOL which only places 2
;			long logicals per XBUFF buffer rather than 3.
;-


	DEFORG	FSS
	DEFORG	FSSTBL
	DEFORG	FSSDSP
	DEFORG	FSSNAM
	DEFORG	NAMGO

	ORG	FSS

.SBTTL	.FSS DEFINITIONS

.BSECT			;FLAGS FOR @ XRB+10

S$FIL:	.BLKB	.	;A FILE NAME EXISTS
S$FILS:	.BLKB	.	;  THE FILE NAME IS "*"
S$FILQ:	.BLKB	.	;  THE FILE NAME CONTAINS "?" (ONE OR MORE)
S$EXT:	.BLKB	.	;A . FOR THE EXTENSION EXISTS
S$EXTE:	.BLKB	.	;  THE EXTENSION ALSO EXISTS
S$EXTS:	.BLKB	.	;    THE EXTENSION IS "*"
S$EXTQ:	.BLKB	.	;    THE EXTENSION CONTAINS "?" (ONE OR MORE)
S$PPN:	.BLKB	.	;AN ACCOUNT NUMBER EXISTS
S$PPNJ:	.BLKB	.	;  THE PROJECT NUMBER IS "*"
S$PPNG:	.BLKB	.	;  THE PROGRAMMER NUMBER IS "*"
S$PROT:	.BLKB	.	;A PROTECTION CODE EXISTS
S$DPRO:	.BLKB	.	;(THE DEFAULT PROTECTION CODE WAS USED)
S$DEV:	.BLKB	.	;A : FOR THE DEVICE NAME EXISTS
S$DEVE:	.BLKB	.	;  THE DEVICE NAME ALSO EXISTS
S$DEVL:	.BLKB	.	;    THE DEVICE NAME WAS A LOGICAL NAME
S$DEVX:	.BLKB	.	;      THE LOGICAL DEVICE IS NOT NOW VALID

.BSECT			;FLAGS FOR @ XRB+12 [** MEANS INTERNAL]

SC$CLU:	.BLKB	.	;/CLUSTERSIZE:N SCANNED
SC$MOD:			;/MODE:N SCANNED
SCNULG:	.BLKB	.	;**NO USER LOGICAL NAME TRANSLATION		;032
SC$SIZ:			;/FILESIZE:N SCANNED
SCNLOG:	.BLKB	.	;**NO LOGICAL NAME TRANSLATION
SC$POS:			;/POSITION:N SCANNED
SCXFIL:	.BLKB	.	;**"FINISHED WITH" FILENAME
SCXEXT:	.BLKB	.	;**"FINISHED WITH" EXTENSION
SCIPR:	.BLKB	.	;**"INTO" PROTECTION SCANNING
SCIP1:	.BLKB	.	;**"INTO" PROJECT NUMBER OF ACCOUNT
SCNAM:			;ACCOUNT WAS 'NAMED'
SCIP2:	.BLKB	.	;**"INTO" PROGRAMMER NUMBER OF ACCOUNT
SCFIL:	.BLKB	.	;FILE NAME SEEN
SCEXT:	.BLKB	.	;. FOR EXTENSION SEEN
SCPPN:	.BLKB	.	;PPN SEEN
SCPROT:	.BLKB	.	;< FOR PROTECTION SEEN
SCDEV:	.BLKB	.	;: FOR DEVICE SEEN
SCLOG:	.BLKB	.	;A LOGICAL DEVICE WAS USED
SCQUES:	.BLKB	.	;**A "?" HAS OCCURED IN THIS FIELD
SCWILD:	.BLKB	.	;SOMETHING WILD HAS BEEN ENCOUNTERED

	UNORG

.SBTTL	SWITCH TABLE MACROS

.MACRO	SWTTBL
.DSABL	CRF
$$$$$$	=	1
.ENABL	CRF
.LIST

.ENABL	LSB

.NLIST
	 .WORD	10$		;POINTER TO FIRST SWITCH
.ENDM	SWTTBL

.MACRO	SWITCH	N0,N1,BITV,FLAG,LOAD,MAX,ALSB,AMSB,LABEL
.DSABL	CRF
.IRP	A1,<\$$$$$$>
.IRP	A2,<\$$$$$$+1>
$$$$$$	=	$$$$$$+1
.ENABL	CRF
.IF NB	<LOAD>
.IF NB	<AMSB>
	 .WORD	140000+AMSB ;ADDRESS FOR MSB OF VALUE
.IFF
	 .WORD	0		;NO MSB ALLOWED
.ENDC
	 .WORD	ALSB+140000,MAX ;ADDRESSES OF LSB, MAXIMUM VALUE
.IFF
.IIF NB	<MAX>,	.ERROR	;INVALID PARAMETER "MAX"
.IIF NB	<ALSB>,	.ERROR	;INVALID PARAMETER "ALSB"
.IIF NB	<AMSB>,	.ERROR	;INVALID PARAMETER "AMSB"
.ENDC
	 .WORD	FLAG+140000	;SET BIT(S) HERE
.IF	NB	<LABEL>
LABEL:	 .BYTE	BITV		;CHECK/SET THESE BITS
.IFF
	 .BYTE	BITV		;CHECK/SET THESE BITS
.ENDC
.IF IDN	<LOAD>,<BIS>
	 .BYTE	1		;SWITCH TAKES ARGUMENT WITH 'BIS'
.IFF
.IF IDN	<LOAD>,<MOV>
	 .BYTE	-1		;SWITCH TAKES ARGUMENT WITH 'MOV'
.IFF
	 .BYTE	0		;NO NUMERIC ARGUMENT
.IIF NB	<LOAD>,	.ERROR	;INVALID PARAMETER "LOAD"
.ENDC
.ENDC
.DSABL	CRF
A1'0$:	 .WORD	A2'0$,A1'1$,A1'2$	;POINTERS TO NEXT, STRING, NON-UNIQUE
.NLIST	BEX
A1'1$:	 .ASCII	"N0"		;NAME OF SWITCH
A1'2$:	 .ASCII	"N1"<377>
.LIST	BEX
	.EVEN
.ENDM
.ENDM
.LIST

.NLIST
.ENDM	SWITCH

.MACRO	SWTEND
.DSABL	CRF
.DSECT
.IRP	A1,<\$$$$$$>
A1'0$:
.ENDM
	UNORG
.LIST

.DSABL	LSB
.NLIST
.ENDM	SWTEND

	.DSECT			;FORMAT OF SWITCH BLOCKS

ST.MSB:	.BLKW			;ADDRESS OF MSB BYTE FOR PARAM VALUE OR ZERO
ST.LSB:	.BLKW			;ADDRESS OF LSB WORD FOR PARAM VALUE OR ZERO
ST.MAX:	.BLKW			;MAX VALUE FOR LSB WORD
ST.SET:	.BLKW			;ADDRESS OF A BYTE TO SET BITS IN IF SW FOUND
ST.BIT:	.BLKB			;BYTE SIZE BIT MASK OF BIT OR BITS TO SET
ST.TYP:	.BLKB			;0 IF NO PARAM, 1 IF SET PARAM WITH BIS INS
				;-1 TO USE MOV, -2 TO USE MOVB
ST.NST:	.BLKW			;POINTS TO NEXT STRING
ST.STR:	.BLKW			;POINTS TO THIS STRING
ST.UNQ:	.BLKW			;POINTS TO THE PLACE THE STRING GETS NON UNIQUE
	
	UNORG

	.DSECT			;FORMAT OF BLOCKS FOR UNQCHK SUBROUTINE

UQ.NST:	.BLKW			;POINTS TO NEXT STRING
UQ.STR:	.BLKW			;POINTS TO THIS STRING
UQ.UNQ:	.BLKW			;POINTS TO THE PLACE THE STRING GETS NON UNIQUE
UQSIZ:

	UNORG

.ASSUME	ST.NST-ST.NST	EQ	UQ.NST
.ASSUME	ST.STR-ST.NST	EQ	UQ.STR
.ASSUME	ST.UNQ-ST.NST	EQ	UQ.UNQ


.SBTTL	FSS File name switches

; SWITCH TABLE FOR:
;
;	/CL(USTERSIZE):N
;	/FI(LESIZE):N
;	/SI(ZE):N
;	/MO(DE):N
;	/RO(NLY)
;	/PO(SITION):N
;	/PR(OTECT):N

FSSSWT:				;START OF FSS'S SWITCHES

HI	=	FIRQB+FQSIZM	;PLACE TO PUT THE HIGH BYTE OF A FILE SIZE
PROTBB	=	S$PROT/400	;VALUE TO SET THE PROTECTION CODE FOUND BIT
	SWTTBL
;		 1     2        3       4     5    6         7        8      9

	SWITCH	/CL,USTERSIZE,SC$CLU ,XRB+12,MOV,177777,FIRQB+FQCLUS
	SWITCH	/FI,LESIZE   ,SC$SIZ ,XRB+12,MOV,177777,FIRQB+FQSIZ ,HI*LRGFIL
	SWITCH	/SI,ZE       ,SC$SIZ ,XRB+12,MOV,177777,FIRQB+FQSIZ ,HI*LRGFIL
	SWITCH	/MO,DE       ,SC$MOD ,XRB+12,MOV,077777,FIRQB+FQMODE,,MO.BIT
	SWITCH	/RO,NLY      ,SC$MOD ,XRB+12,,,,,RO.BIT
	SWITCH	/PO,SITION   ,SC$POS ,XRB+12,MOV,177777,FIRQB+FQNENT
	SWITCH	/PR,OTECTION ,PROTBB ,XRB+11,MOV,000377,FIRQB+FQPROT-1,,PR.BIT
	SWTEND

;1	Switch name up to abreviation point.
;2	The rest of the switch name.
;3	The bit to set when this switch is found.
;4	The place to set the bit.
;5	Either MOV, BIS, MOVB or no arg.  MOV, MOVB or BIS are instruction
;	  used to store the argument.  No arg is used if the switch has no
;	  value argument.
;6	Largest value the argument may take.
;7	Place to put the argument.
;8	If given and nonzero then says the argument may be 24 bits and tells 
;	  where the MSB byte goes.
;9	Label to attach to byte at ST.BIT (address of ST.BIT is returned
;	  in R0 by CHKSWT).

GLOBAL	<LRGFIL>

.SBTTL	FSS General macros

; MACROS USED BY THE .FSS

.MACRO	SCANSP	CHAR
.DSABL	CRF
$$$$$$	=	.
	TMPORG	FSSTBL
	 .BYTE	CHAR
	TMPORG	FSSDSP
	 .WORD	$$$$$$
	UNORG
.ENABL	CRF
.ENDM	SCANSP

.MACRO	BITBIS	BITS1,BITS2,BITS3
	CALL	BITBIS,R0	;CHECK FOR LEGALITY (BITS OFF)
	  .WORD	BITS1,BITS2
	  .WORD	BITS3		;POST THIS TO CALLER
.ENDM	BITBIS

.MACRO	BITBIC	BITS1,BITS2,BITS3
	CALL	BITBIC,R0	;CHECK FOR LEGALITY (BITS ON)
	  .WORD	BITS1,BITS2
	  .WORD	BITS3		;POST THIS TO CALLER
.ENDM	BITBIC

.SBTTL	HANDLE .FSS MONITOR CALL

;+
;	R0 =  EMT CODE
;	R1 -> JOBDA @JOBF
;	R2 -> JDB2
;	R3 -> MAPPED XRB
;	R4 -> MAPPED FIRQB
;	R5 -> RTS BLOCK
;-

	EMTENT	.FSS		;.FSS COMES HERE

;
; -	SET UP
;
	MOV	@#JOBWRK,R3 	; GET POINTER TO WORK BLOCK
	CLR	(R3)		;CLEAR FIRST WORD AS NO [NAME] INDICATOR
	CALL	SETXRB		;CHECK NON-STANDARD USER LOGICAL AREA
	CALL	STRCHK		;CHECK OUT THE STRING
;
; -	SCAN ALL THE STRING EXCEPT THE SWITCHES
;
	CALL	SCANGO		;NOW SCAN IT
;
; -	NOW LOOK FOR A SWITCH AND IF ONE IS FOUND MOVE IST BODY TO SWTBLK
;
10$:	MOV	#XRB+XRLOC+140000,R4 ;POINT TO VIRTUAL POINTER/COUNT
	MOV	(R4),-(SP)	;SET CURRENT VIRTUAL POINTER
	MOV	-(R4),-(SP)	; AND CURRENT COUNT
	CALL	MFPCHR		;GET A CHARACTER
	BEQ	80$		;NONE, ALL DONE
	CMP	R0,#'/		;ONE, A POSSIBLE SWITCH?
	BNE	80$		;NOPE
	MOV	#SWTBLK,R2	;MIGHT BE, GET BUFFERING BLOCK
	MOV	R2,R5		; AND SAVE THAT ADDRESS
20$:	MOVB	R0,(R2)+	;SAVE CHARACTER IN BLOCK
	CLRB	(R2)		; KEEPING NULL BYTE TERMINATOR
	CMP	R2,#SWTBKE-1	;OUT OF ROOM?
	BHIS	80$		;YES, EXIT
	CALL	MFPCHR		;NO, GET MORE
	BEQ	40$		;END, CHECK THE SWITCH
	MOV	#TRMLST,R1	;ANOTHER, GET TERMINATOR LIST
30$:	CMPB	R0,(R1)+	;A TERMINATOR?
	BLO	30$		;NO, KEEP CHECKING
	BHI	20$		;NO, STORE IT
	INC	(R4)		;YES, BACK UP FOR
	DEC	2(R4)		; RE-FETCHING TERMINATOR LATER

;
; -	NOW SEE IF ITS OURS AND HANDLE IT IF IT IS
;
40$:	CALL	CHKSWT,R4,FSSSWT ;CHECK FOR .FSS SWITCHES
	 BR	80$		;NO GO
;
; -	STANDARD HANDLING OF A FSS SWITCH IS DONE NOW TAKE CARE OF SPECIAL 
; -	CASES FOR:
; -	/PROTECTION, /RONLY OR /MODE
;
;	[R0 points to ST.BIT]

	CMP	R0,#PR.BIT	;/PROTECTION SWITCH ?
	BNE	50$		;NOPE
	BIS	#SCPROT,@#140000+XRB+12 ;SET THIS BIT SO IT LOOKS LIKE <n>
	BIC	#S$DPRO,@#140000+XRB+10 ;MAKE SURE DEFAULT PROT BIT IS OFF
	SWAB	@#140000+FIRQB+FQPROT-1 ;MOVE PROTECTION CODE TO ITS HOME
	MOVB	#-1,@#140000+FIRQB+FQPROT-1 ;SET EXPLICIT-PROTECTION-CODE FLAG
	BR	70$		;CONTINUE

50$:	CMP	R0,#RO.BIT	;/RONLY SWITCH ?
	BNE	60$		;NOPE
	TSTB	@#140000+XRB+14	;YES: IS IT ALSO A DISK ?
	BNE	90$		;NO - ERROR
	MOV	#120000,@#140000+FIRQB+FQMODE  ;SET READ-ONLY MODE
	BR	70$				;AS THE ONLY MODE BIT

60$:	CMP	R0,#MO.BIT	;/MODE SWITCH ?
	BNE	70$		;NOPE
	BIS	#100000,(R1)	;ALWAYS SET BIT 15=1 ON /MODE

70$:	CMP	(SP)+,(SP)+	;POP SAVE XRB PARAMETERS
	BR	10$		; AND LOOP FOR ANOTHER SWITCH

80$:	MOV	(SP)+,(R4)+	;RESTORE XRB
	MOV	(SP)+,(R4)	; PARAMETERS AS THEY SHOULD BE
	MOV	@#JOBWRK,R1	;GET WORK BLOCK POINTER
	TST	(R1)		;ANYTHING THERE (NAME) ?
	BNE	100$		;YEP
	RETURN			;NOPE, JUST EXIT

90$:	ERROR	BADSWT		;NO "/RO" IF NOT DISK

100$:	CALLRX	NAMGO		;GO FINISH UP IN OVERLAY

	TMPORG	NAMGO

NAMGO:	ERROR	BADNAM		;NO NAMED DIRECTORIES

	UNORG

GLOBAL	<SWTBLK,SWTBKE>

.SBTTL	DO SCANNING MINUS SWITCHES

WRKSPS	=	22.		;SIZE OF THE WORK SPACE			;047

.ENABL	LSB

10$:	MOV	#-1,R3		;Setup to set all to -1's		;045
	TST	(SP)		;Anything in work area?			;045
	BNE	12$		;Yes, go do name* processing		;045
	BITBIS	SCIPR,SCWILD,0	;* Found (wild field)			;045
	BR	30$		;Found * alone				;045

12$:	BIS	#SCQUES,R5 	;Set "?" found flag			;045
	MOV	R3,<WRKSPS-2>(SP) ;Set the end of the work buffer to *	;045
	CMP	R1,R2		;Is there room for more characters?	;045
	BHIS	50$		;No, go get next character		;045
15$:	MOVB	#'?,(R1)+	;Fill up rest of work buffer with "?"'s	;045
	CMP	R1,R2		;Done yet?				;045
  	BLO	15$		;No, go fill in with another "?"	;045
	MOV	R3,<WRKSPS-2>(SP) ;Reset the end of the string to *	;045
	BR	50$		;Go process next character		;045

SCANGO:	MOV	#FIRQB+FQDEV+140000,R4 ;GET (MAPPED) FIRQB POINTER
	CLR	R5		;CLEAR FLAGS WORD
	CLR	-(SP)		;CLEAR FOR GENERIC DEVICE FLAGS
	CLR	-(SP)		;CLEAR FOR MORE FLAGS
	MOV	SP,R2		;GET POINTER TO MORE FLAGS
	SUB	#WRKSPS,SP		;GET WORKING SPACE

20$:	CLR	R3		;SET UP TO CLEAR WORKING AREA
30$:	MOV	SP,R1		;GET TOP OF STORAGE
40$:	MOV	R3,(R1)+	;CLEAR OR SET TO -1 THE WORKING SPACE
	CMP	R1,R2		;DONE YET?
	BLO	40$		;NOPE, LOOP...
	MOV	SP,R1		;NOW BACKUP TO THE TOP

50$:	CALL	MFPCHR		;GET A CHARACTER
	BEQ	SCANEX		;END, DONE
	TSTB	R0		;Is this an eight-bit character?	;028
	BMI	SCANER		;Yes, so that is an error		;028
	MOV	#FSSTBL,R3	;ELSE GET TABLE POINTER
	CMPB	R0,(R3)+	;IS IT A * ??
	BEQ	10$		;YES
	CMPB	R0,(R3)+	;IS IT A ? ??
	BNE	60$		;NO
	BIS	#SCQUES,R5 	;YES, SET "?" FOUND FLAG
	BR	SCANST		;And store it				;040

60$:	CMPB	R0,(R3)		;COMPARE FOR SPECIALS
	BEQ	80$		;FOUND ONE
	TSTB	(R3)+		;END OF TABLE?
	BNE	60$		;IF NOT, THEN LOOP
	CMPB	R0,#'Z		;Not special, is it valid?		;040
	BHI	SCANER		;No, so error				;040
	CMPB	R0,#'A		;Maybe, is it alphabetic?		;040
	BHIS	SCANST		;Yes, that's good			;040
	CMPB	R0,#'9		;No, how about numeric?			;040
	BHI	SCANER		;No, not this time			;040
	CMPB	R0,#'0		;Maybe, is it numeric?			;040
	BLO	SCANER		;No, forget it				;040
SCANST:	TST	<WRKSPS-2>(SP)	;Is * active?				;045
	BPL	70$		;NO, ALL IS WELL
SCANER:	ERROR	BADNAM		;SAY ILLEGAL FILE NAME

70$:	CMP	R1,R2		;IS THERE ROOM TO STORE ANYTHING?
	BHIS	50$		;IF NOT THEN IGNORE CHARACTER
	MOVB	R0,(R1)+	;ELSE STASH IT AWAY
	BR	50$		; AND GET ANOTHER

80$:	CMP	#'_,R0		;is it underline?			;048
	BEQ	90$		;yes than continue scan after, R1 as is	;048
	MOV	SP,R1		;SET WORK AREA POINTER FOR OTHERS
90$:	SUB	#FSSTBL+2,R3	;GET THE CORRECT INDEX
	ASL	R3		;TIMES 2 FOR WORDS
	CALL	@FSSDSP(R3)	;AND GO TO IT
	 BR	20$		;THEN CLEAR THE AREA
	 BR	50$		;2nd return is to continue scanning	;048

.DSABL	LSB

	TMPORG	FSSTBL
FSSTBL:	.BYTE	'*		;SPECIAL COMPARE FOR *
	.BYTE	'?		;SPECIAL COMPARE FOR ?
	UNORG

; SCAN COMPLETED, DO FINAL FIXUPS

SCANSP	<'/>			;/ FOUND (END SCAN)
SCANSP	<';>			;; FOUND (END SCAN)
SCANSP	<'=>			;= FOUND (END SCAN)
SCANDN:	TST	(SP)+		;DUMP RETURN ADDRESS
	DEC	@#XRB+XRLOC+140000 ;BACK UP TO KEEP
	INC	@#XRB+XRBC+140000 ;  THIS CHARACTER
SCANEX:	BIT	R5,#SCIPR!SCIP1!SCIP2;INTO ANYTHING?
	BNE	SCANER		;YES IS ERROR
	CALL	SCANNB		;AND CHECK FOR A NAME
	BIT	R5,#SCPROT	;WAS THE PROTECTION CODE SUPPLIED?
	BNE	10$		;YES, SO LEAVE IT ALONE
	TST	FQPROT-1-FQDEV(R4) ;Protection already in FIRQB?	;044
	BNE	10$		;Yes, so leave it there			;044
	MOV	@#XRB+12+140000,R3 ;NO, GET LOGICAL POINTER
	MAP	XRB+14+140000,APR=6,DATA ;MAP FOR DEFAULT PROT CODE
	MOV	USRPRT-USRPPN(R3),R3 ;GET THAT PROT CODE
	MAP	@UDPAR0,APR=6,DATA ;RESTORE OUR MAPPING			;024
	MOV	R3,FQPROT-1-FQDEV(R4) ;SET DEFAULT PROT CODE
	BEQ	10$		;NONE TO SUPPLY
	BIS	#S$DPRO,(R2)	;AND INDICATE SUCH
10$:	ADD	#WRKSPS,SP		;POP THE SCRATCH AREA
	MOV	#XRB+140000+10,R3 ;GET XRB POINTER
	MOV	(SP)+,(R3)+	;SET FIRST SET OF FLAGS
	BIC	#SCNLOG!SCXFIL!SCXEXT!SCNULG,R5 ;CLEAR THESE BITS	;032
	MOV	R5,(R3)+	;SET SECOND SET OF FLAGS
	MOV	(SP)+,(R3)+	;AND SET THE GENERIC DEVICE FLAGS
	RETURN			;EXIT

GLOBAL	<UDPAR0>

.sbttl	Underline character processing
	.enabl	LSB

SCANSP	<'_>			;_ FOUND (SUPPRESS LOGICAL NAME TRANSLATION)
	BIS	(R2),2(SP)	;CHECK FOR FIRST OF ANY AT ALL		;048
	BNE	5$		;NOT FIRST IN STRING, 			;048
	BITBIS	-1,SCNLOG,0	;MUST BE FIRST IN STRING		;048
	BR	80$		;done then after flag set, 1st exit	;048
				;note on this return (R1)=2(SP) 	;048

5$:	CLR	-(SP)		;set flag for underline ok (in logical)	;048+
	MOV	R0,-(SP)	;make space to work
	MOV	R1,-(SP)	;  again
	MOV	R2,-(SP)	;   and again
	MOV	#XRB+XRBC,R1	;get users pointer to bytes remaining
		;note MFPD instructions protected by earlier call to CHKXRB
		;  where the values of XRBC & XRLOC are verified.
	MFPD	(R1)+		;get remaining bc from user space
	MOV	(SP)+,R0	;any left? (point to buffer of string)
	BEQ	40$		;no that's no good then
.ASSUME	XRBC+2	EQ	XRLOC
	MFPD	(R1)		;from user space then...
	MOV	(SP)+,R1	;get pointer to next char in user buffer
10$:	MOV	R1,R2		;copy pointer to next char
	BIC	#1,R2		;get a word at a time
	MFPD	(R2)		;retrieve from user space next chars (2)
	CMP	R2,R1		;want odd or even byte?
	BEQ	20$		;even byte if equal
	SWAB	(SP)		;else odd, swap char order retrived
20$:	BIC	#^C<177>,(SP)	;clear all but 7 bit char wanted
	MOV	(SP)+,R2	;gett the char off stack
	CMP	#':,R2		;is it a colon?
	BEQ	50$		;yes then in logical and ok
	CMP	#'_,R2		;is it another underline?
	BEQ	50$		;yes put off the problem till then
	CMP	#'$,R2		;accept dollar signs
	BEQ	30$		;if it is continue scan ahead
	CMP	R2,#'0		;otherwise if less than #0 error
	BLT	40$		;error exit 
	BIC	#40,R2		;make lower case upper
	CMP	R2,#'Z		;is above #Z?
	BGT	40$		;yes -no good then
	CMP	R2,#'A		;but is it a letter?
	BGE	30$		;yes that's ok, continue looking
	CMP	R2,#<'9-40>	;no, but is it a number (w/ 40 bit clr)
	BGT	40$		;no -no good
30$:	DEC	R0		;any more char in buffer?
	BEQ	40$		;no so underline is NG
	INC	R1		;yes so bump up pointer to next
	BR	10$		;continue scanning

40$:	COM	6(SP)		;mark as error exit
50$:	MOV	(SP)+,R2	; else good exit, reset space
	MOV	(SP)+,R1	; one register
	MOV	(SP)+,R0	; at a time
	TST	(SP)+		;test return type
60$:	BNE	SCANEJ		;error exit
	CMP	R1,R2		;is there room in workspace?
	BHIS	70$		;if not ignore it
	MOVB	#'.,(R1)+	;store "_" as a "." so can RAD50 it
70$:	ADD	#2,(SP)		;take 2nd return to continue scan
80$:	RETURN			;underline ok				;048-

SCANSP	<076>			;> FOUND (END OF PROTECTION CODE)
	BITBIC	SCIPR,SCPROT,S$PROT
	CALL	NUMCNV		;GET THE NUMBER
	MOVB	(R1),-(R4)	;SET PROTECTION CODE
	MOVB	#-1,-(R4)	; AND SAY IT IS REAL
	TST	(R4)+		;CORRECT FIRQB POINTER
	RETURN			; AND RETURN

.ENABL	LSB

SCANSP	<',>			;, FOUND (MIDDLE OF ACCOUNT NUMBER)
	BIT	R5,#SCIP1	;COLLECTING PROJ NUMBER?
	BEQ	SCANDN		;NO, SO CALL SCAN DONE
	ADD	#SCIP2-SCIP1,R5	;CHANGE TO COLLECTING PROG NUMBER
	TST	(R1)		;ANYTHING THERE?
	BNE	10$		;YES, SOMETHING				;026
	MOV	JOBJD2,R3	;NOTHING, GET 2ND JOB DATA BLOCK
	MOVB	J2PPN+1(R3),(R1) ;DEFAULT TO USER'S PROJECT NUMBER
	BR	20$		;DON'T TRY TO GET THE NUMBER

10$:	CALL	NUMCNV		;GET THE NUMBER
20$:	MOVB	(R1),FQPPN+1-FQDEV(R4) ;SET PROJECT NUMBER OF ACCOUNT
	MOV	#S$PPNJ,R3	;PROJECT NUMBER COULD BE WILD...
	BR	50$		;NOW CHECK FOR VALID ACCOUNT NUMBER

SCANSP	<')>			;) FOUND (END OF ACCOUNT NUMBER)
SCANSP	<']>			;] FOUND (END OF ACCOUNT NUMBER)
	TST	(R1)		;ANYTHING SINCE LAST DISPATCH CHARACTER?
	BNE	30$		;YES, SOMETHING				;026
	MOV	JOBJD2,R3	;NOTHING, GET 2ND JOB DATA BLOCK
	MOVB	J2PPN(R3),FQPPN-FQDEV(R4) ;Supply user's programmer #	;026
	BIT	#SCIP2,R5	;Did we find a comma?			;026
	BNE	40$		;Yes, so programmer number already set	;026
	MOV	J2PPN(R3),FQPPN-FQDEV(R4) ;DEFAULT TO USER'S PPN
	ADD	#SCIP2-SCIP1,R5	;TRY SAYING PROJECT NUMBER COLLECTED
	BR	40$		; AND DON'T TRY TO PARSE A PROGRAMMER NUMBER

30$:	BIT	#SCIP2,R5	;FOUND A COMMA ON THE WAY ??
	BEQ	80$		;NOPE, GO DO WHAT IS NEEDED
	CALL	NUMCNV		;YEP, GET THE NUMBER
	MOVB	(R1),FQPPN-FQDEV(R4) ;SET PROGRAMMER NUMBER OF ACCOUNT
40$:	BITBIC	SCIP2,SCPPN,S$PPN ;AND DO THE NORMAL CHECKING
	MOV	#S$PPNG,R3	;PROGRAMMER NUMBER COULD BE WILD
	TST	FQPPN-FQDEV(R4)	;WAS THE WHOLE ACCOUNT NUMBER [0,0]?
	BEQ	SCANEJ		;YES, THAT IS AN ERROR
50$:	TST	(R1)		;WAS THE NUMBER *?
	BPL	70$		;NOPE
	BIS	R3,(R2)		;YES, SO INDICATE THE FIELD NUMBER FOR CALLER
60$:	RETURN			;EXIT

70$:	INCB	(R1)+		;WAS THE NUMBER 255?
	BNE	60$		;NOPE, GO EXIT
SCANEJ:	ERROR	BADNAM		;ERROR

80$:	ERROR	BADNAM		;Missing comma in PPN			;026

.DSABL	LSB

.ENABL	LSB

SCANSP	<':>			;: FOUND (DEVICE NAME)
$$$$$$	=	SCQUES!SCDEV!SCXFIL!SCXEXT!SCIPR!SCIP1!SCIP2
	BITBIS	$$$$$$,SCDEV,S$DEV
	;	R1 -> 1st char in ascii work space on stack		;047
	;	R4 -> FIRQB@FQCLUS					;047
FSSCOL::
	TST	(R1)		;WAS THE DEVICE WILD?
	BMI	SCANEJ		;YES, SO ERROR
	MOV	R4,-(SP)	;free a register, ^FIRQB@FQDEV		;047
	MOV	#<SL$SIZ-SL$NAM>/2,R4 ;set to maximum rad50 words	;047
5$:	CLR	-(SP)		;make a work space on stack		;047
	SOB	R4,5$		;loop til SL$SIZ-SL$NAM done		;047
	MOV	SP,R4		;save pointer work space (^WORK)	;047
	MOV	R1,-(SP)	;save ^char 1 in ascii			;047
	MOV	R4,-(SP)	;save the ^work				;047
	MOV	#<SL$SIZ-SL$NAM>/2,R3	;set to maximum rad50 words	;047
7$:	CALL	SCANLG		;pack the next 3 char to rad50 @R4	;047
	BEQ	8$		;if no more char that's it		;047
	SOB	R3,7$		;else loop for the maximum possible	;047
8$:	MOV	(SP)+,R4	;get the ^work back			;047
	MOV	(SP)+,R1	;get pointer to ascii chars back	;047
	MOV	<SL$SIZ-SL$NAM>(SP),R4 ; get firqb back @FQDEV		;047
	MOV	2(SP),FQDEVN-FQDEV(R4); copy rad50 word 2 to FQDEV	;047
	MOV	(SP),(R4)	;copy rad50 word 1 to FQDEV		;047
	BEQ	55$		;if  it is no -that's all then		;047
	BIS	#S$DEVE,(R2)	;note a device name exists		;047
	BIT	#SCNLOG,R5	;suppress logical scan?			;047
	BNE	80$		;yes- so skip this stuff		;047
	MOV	SP,R4		;copy pointer to work space		;047
	MOV	#LG$SYS,R0	;set logical status to search sys only	;047
	BIT	R5,#SCNULG	;SUPPRESS USER LOGICAL NAME TRANSLATION?;032
	BNE	65$		;YES, SKIP IT				;032
	TST	4(R4)		;see if logical to long for low core?	;047
	BNE	63$		;yes look just at job header then	;047
	MOV	@#XRB+12+140000,R3 ;GET POINTER TO USER LOGICAL TABLE -4
	MOV	@#XRB+10+140000,R0 ;GET END OF THAT TABLE
	MOV	R3,-(SP)	;SAVE POINTER TO USER LOGICAL TABLE
	ADD	#4,(SP)		;AT THE BEGINNING OF USER LOGICALS
	MAP	XRB+14+140000,APR=6,DATA ;NOW RE-MAP TO THE TABLE
	BR	20$		;AND CHECK TABLE

10$:	TST	(R3)+		;SKIP UNCOMPARED RAD50 WORD
20$:	CMP	(R3)+,(R3)+	;SKIP PHYSICAL DEVICE NAME
30$:	CMP	R3,R0		;MORE IN TABLE?
	BHIS	60$		;NO, CANNOT BE A LOGICAL NAME THEN
	CMP	(R4),(R3)+	;YES, MATCH NAME PART 1?		;047
	BNE	10$		;NO MATCH, LOOP
	CMP	2(R4),(R3)+	;MATCH NAME PART 2?			;047
	BNE	20$		;NO MATCH, LOOP
	MOV	(R3)+,-(SP)	;MATCH, SAVE THE DEVICE
	MOV	(R3)+,-(SP)	; NAME AND UNIT/FLAG
	MOV	4(SP),-(SP)	;GET SAVED BEGINNING OF LOGICAL TABLE
	CLR	6(SP)		;SAVE A PLACE FOR A PPN (POSSIBLY)
	SUB	#10*4,R0	;FIND BEGINNING OF LOGICAL TABLE
	CMP	(SP)+,R0	;DOES TABLE HAVE A FULL FOUR ENTRIES?
	BNE	40$		;NOPE, TOO BAD
	CMP	#-1,30(R0)	;IS IT A PPN SLOT?
	BNE	40$		;NOPE
	SUB	R0,R3		;GET A RELATIVE SLOT INDEX
	ASH	#-2,R3		;DIVIDE BY 4 TO GET INDEX OF 2,4, OR 6
	ADD	R0,R3		;ADD BASE BACK IN TO GET ASSOCIATED PPN SLOT
	MOV	30(R3),4(SP)	; AND SAVE THE PPN
40$:	MAP	@UDPAR0,APR=6,DATA ;RESTORE THE MAPPING			;024
	MOV	<SL$SIZ-SL$NAM+6>(SP),R4 ; get firqb back @FQDEV	;047
	MOV	(SP)+,2(R4)	;SET UNIT/FLAG AND
	MOV	(SP)+,(R4)	; DEVICE NAME
	MOV	(SP)+,R0	;SAVE WHAT MAY BE A PPN
	BEQ	50$		;GUESS NONE WAS FOUND, CONTINUE
	MOV	R0,FQPPN-FQDEV(R4) ;ACTUALLY GOT A PPN
45$:	BIS	#S$PPN,(R2)	;INDICATE PPN FOUND			;041

GLOBAL	<UDPAR0>

50$:	BIS	#S$DEVL,(R2)	;SAY A LOGICAL DEVICE NAME
	BIS	#SCLOG,R5	; IN BOTH PLACES
55$:	CLR	6(SP)		;make device check out work		;047
	CLR	10(SP)		;by declaring no controller syntax	;047
	BR	120$		;NOW CHECK THAT PHYSICAL NAME		;046

60$:	TST	(SP)+		;POP OFF SAVED BASE OF LOGICAL AREA
63$:	MOV	#<LG$SYS!LG$USR>,R0 ; set to search everthing		;047
65$:	MAP	@UDPAR0,APR=6,DATA ;RESTORE THE MAPPING			;047
	MOV	<SL$SIZ-SL$NAM>(SP),R4 ; get firqb back @FQDEV		;047
	CALLX	GETLOG,R5	;NOW GET SYSTEM LOGICAL IF ANY
	BR	80$		;NOT A SYSTEM LOGICAL NAME
	BCC	50$		;SYSTEM LOGICAL, BUT NO PPN
	BR	45$		;Logical with PPN, set the flag		;041

80$:	CLR	R3		;CLEAR A UNIT NUMBER BUCKET
	MOV	(R1)+,(R4)	;SET THE DEVICE NAME
	MOVB	(R1)+,R0	;GET POSSIBLE CONTROLLER LETTER OR UNIT NUMBER
	BEQ	110$		;NONE
	CMP	R0,#'A		;ONE, A CONTROLLER (ALPHABETIC)?
	BLO	90$		;NO
	CMP	R0,#'Z		;MIGHT BE, REALLY ALPHABETIC?
	BHI	90$		;NOPE
	MOV	R0,6(SP)	;SAVE CONTROLLER NAME FOR LATER		;031
	MOVB	(R1)+,R0	;GET POSSIBLE UNIT NUMBER
	BEQ	110$		;NO UNIT NUMBER
90$:	SUB	#'0,R0		;CORRECT ASCII INTO BINARY
	CMP	R0,#9.		;VALID DIGIT?
	BHI	150$		;NOPE, GIVE AN ERROR			;046
	MUL	#10.,R3		;OLD TIMES 10
	ADD	R0,R3		;ADD IN NEW DIGIT
	MOVB	(R1)+,R0	;GET NEXT UNIT NUMBER DIGIT
	BNE	90$		;THERE IS ANOTHER, GO PROCESS IT
100$:	BIT	R3,#^C<177>	;IS UNIT NUMBER ILLEGAL?
	BNE	150$		;YES					;046
	BIS	(PC)+,R3	;NO, SET 'UNIT VALID' FLAG
	 .BYTE	0,-1
	REGSAV			;Save the world for now			;046
	CLR	FQDEVN-FQDEV(R4) ;Use unit zero of this device		;046
	CALLX	GETFLG		;Get the driver index and generic flags	;046
	MOV	R2,(SP)		;Save driver index in saved R0		;046
.ASSUME	TOS.R0 EQ 0							;046
	REGRES			;Put the world back			;046
	BCS	150$		;Invalid device				;046
	MOV	R0,10(SP)	;Save the driver index for later	;046
	MOV	6(SP),R1	;Controller syntax specified		;046
	BEQ	110$		;No, then we're done			;046
	MOVB	R3,FQDEVN-FQDEV(R4) ;Save the specified subline #	;046
	SUB	#'A,R1		;Convert controller letter to binary	;046
	MOV	DDCTBL(R0),R0	;Get controller count & unit info offset ;046
	CMPB	R1,R0		;Controller # >= controller count	;046
	BHIS	150$		;Too large or not allowed		;046
	CLRB	R0		;Leave only unit count offset		;046
	SWAB	R0		; in low byte				;046
	ADD	#UCTTBL,R0	;Point to units/controller table	;046
	TST	R1		;Which controller was it?		;046
	BEQ	108$		;Controller A, skip the loop		;046
104$:	ADD	(R0)+,R3	;Adjust the unit number			;046
	SOB	R1,104$		;Loop until we're at the right controller ;046
108$:	CMPB	FQDEVN-FQDEV(R4),(R0) ;subline # valid for this controller ;046
	BHIS	150$		;No, reset logical name and exit	;046
110$:	MOV	R3,FQDEVN-FQDEV(R4) ;Store the real unti number and flag ;046

GLOBAL	<UDPAR0,DDCTBL,UCTTBL>						;046

120$:	REGSAV			;SAVE ALL REGISTERS
	CALLX	GETFLG		;Get the driver index and generic flags	;046
	MOV	R2,(SP)		;Save driver index in saved R0		;046
.ASSUME	TOS.R0 EQ 0							;046
	REGRES			;Restore all registers			;046
	BCC	130$		;Device is valid			;046
	MOV	10(SP),R0	;Restore the driver index		;046
	CMP	R0,#IDX.KB	;Invalid device, is it a keyboard ?	;046
	BNE	150$		;No, then treat as a logical name	;046
	MOV	DYNKBN,R1	;Get the KB # * 2 of the 1st dynamic KB	;046
	ASR	R1		; and make it KB # * 1			;046
	CMPB	R3,R1		;Is it a dynamic one?			;046
	BLT	150$		;No, then treat it as a logical name	;046
130$:	MOV	$FLGTBL(R0),2(R2) ;Set the generic flags		;046
	TST	6(SP)		;Controller syntax specified?		;046
	BEQ	160$		;NONE, THAT'S EASY, JUST EXIT
	TSTB	FQDEVN+1-FQDEV(R4) ;Got one, was there a unit number?	;042
	BNE	160$		;Yes, then its not a logical name	;046
150$:	MOV	(SP),(R4)	;ERROR, RE-SET THE			;046
	MOV	2(SP),FQDEVN-FQDEV(R4)	; LOGICAL NAME			;047
	MOV	4(SP),FQFLAG-FQDEV(R4)	;ALL THREE WORDS		;047
	BIS	#S$DEVX!S$DEVL,(R2) ;SAY LOGICAL NOT NOW VALID
	BIS	#SCWILD,R5	;INDICATE SOMETHING IS WILD
160$:	ADD	#16.,SP		;NOW CLEAN THE STACK			;047
	RETURN			; AND EXIT

GLOBAL	<$FLGTBL,DYNKBN>						;046

SCANSP	<074>			;< FOUND (START OF PROTECTION CODE)
	BITBIS	SCPROT!SCIPR!SCIP1!SCIP2,SCIPR,0
	BR	SCANNB		;NOW SCAN FOR A FILE NAME

SCANSP	<'(>			;( FOUND (START OF ACCOUNT NUMBER)
SCANSP	<'[>			;[ FOUND (START OF ACCOUNT NUMBER)
	BITBIS	SCPPN!SCIPR!SCIP1!SCIP2,SCIP1,0
	BR	SCANNB		;NOW SCAN FOR A FILE NAME

.ENABL	LSB

SCANSP	<'@>			;@ FOUND (LOGICAL ACCOUNT NUMBER)
	MOV	@#XRB+12+140000,R1 ;GET LOGICAL PPN POINTER
	MAP	XRB+14+140000,APR=6,DATA ;MAP FOR THAT LOGICAL
	MOV	(R1),R1		;FETCH USER'S LOGICAL PPN
	MAP	@UDPAR0,APR=6,DATA ;RESTORE MAPPING			;024
	BR	10$		;AND CHECK IT OUT

	TMPORG	FSSDSP
FSSDSX:				;DISPATCH ADDRESS FOR SPECIAL ACCOUNTS
	UNORG
SCANSP	<'$>			;$ FOUND (1ST STANDARD ACCOUNT NUMBER)
	TST	(R1)		;AS FIRST CHARACTER?			;031
	BEQ	6$		;YES, SO IT'S [1,2]			;031
	MOV	R0,-(SP)	;SAVE FETCHED $				;031
	MOV	R3,-(SP)	;SAVE POINTER INTO FSSTBL		;031
	BITBIS	0,SCNULG,0	;SUPPRESS USER LOGICAL TRANSLATION	;032
	CALL	MFPCHR		;ANY MORE?				;031
	BEQ	5$		;NO					;031
	MOV	(SP)+,R3	;GET BACK FSSTBL POINTER		;031
	MOV	(SP)+,R0	;GET BACK FETCHED $			;031
	INC	@#XRB+XRBC+140000 ;INCREMENT COUNTER			;031
	DEC	@#XRB+XRLOC+140000 ;BACK UP POINTER			;031
	BR	STOCHR		;STORE IT				;031

5$:	MOV	(SP)+,R3	;GET BACK FSSTBL POINTER		;031
	MOV	(SP)+,R0	;GET BACK FETCHED $			;031
SCANSP	<'!>			;! FOUND (2ND STANDARD ACCOUNT NUMBER)
SCANSP	<'%>			;% FOUND (3RD STANDARD ACCOUNT NUMBER)
SCANSP	<'&>			;& FOUND (4TH STANDARD ACCOUNT NUMBER)
6$:	MOV	PPNTBL-<FSSDSX-FSSDSP>(R3),R1 ;PICK UP THE ACCOUNT NUMBER ;031
10$:	BITBIS	SCPPN!SCIPR!SCIP1!SCIP2,SCPPN,S$PPN
	MOV	R1,FQPPN-FQDEV(R4) ;NOW SET THE ACCOUNT NUMBER
	BNE	SCANNB		;NON-ZERO, SCAN FOR A FILENAME
SCANE0:	ERROR	BADNAM		;TOO BAD

SCANSP	<'#>			;# FOUND (GROUP ACCOUNT NUMBER)
	BIT	R5,#SCIPR!SCIP1!SCIP2 ;INTO A NUMBER?
	BNE	STOCHR		;YES, GO STORE THE # INSTEAD...
	MOV	JOBJD2,R1	;GET 2ND JOB DATA AND
	MOV	J2PPN(R1),R1	; THE JOB'S PPN
	CLRB	R1		;MAKE [X,Y] INTO [X,0]
	BR	10$		;GO CHECK IT

.DSABL	LSB

STOCHR:	TST	(SP)+		;DUMP RETURN ADDRESS & SP -> WORKING AREA START
	MOV	R2,R1		;COPY A POINTER TO WORKING AREA END +1
10$:	CMP	R1,SP		;UP TO TOP OF WORKING AREA?
	BLOS	20$		;YES, STOP THE BACK SCAN
	TSTB	-(R1)		;NO, HAVE WE STORED HERE YET?
	BEQ	10$		;STILL AN UNSTORED SPOT, KEEP LOOKING...
	INC	R1		;AN INUSE SPOT, CORRECT TO AN AVAILABLE SPOT
20$:	JMP	SCANST		;GO BACK AND STORE THIS SPECIAL CHARACTER

GLOBAL	<PPNTBL,UDPAR0>

.ENABL	LSB

SCANSP	<'.>			;. FOUND (END OF NAME, START OF EXTENSION)
	BIT	R5,#SCIPR!SCIP1!SCIP2 ;INTO A NUMBER?
	BNE	STOCHR		;YES, GO STORE THE . INSTEAD...
	BITBIS	SCXFIL!SCXEXT!SCIPR!SCIP1!SCIP2,SCXFIL!SCEXT,S$EXT
	CLR	FQEXT-FQDEV(R4)	;ENSURE AT LEAST A NULL EXTENSION
	TST	(R1)		;ANY NAME THERE?
	BNE	40$		;YES, SO PROCESS IT
	RETURN			;NO, SO JUST RETURN

SCANNB:	MOV	SP,R1		;GET OUR POINTER
	TST	(R1)+		;BUMP OVER RETURN ADDRESS
	TST	(R1)		;ANY CHARACTERS THERE?
	BEQ	10$		;IF NOT, THEN BRANCH
	BIT	R5,#SCXFIL	;GOT A NAME ALREADY
	BEQ	30$		;IF NOT, THEN BRANCH
	BIT	R5,#SCXEXT	;GOT AN EXTENSION ALREADY
	BNE	SCANE0		;IF SO, THEN AN ERROR
	MOV	#S$EXTE,R3	;SAY EXTENSION EXISTS
	BIS	#SCEXT!SCXEXT,R5 ; IN BOTH PLACES
	MOV	R4,-(SP)	;AND SAVE MAIN POINTER
	ADD	#FQEXT-FQDEV,R4	;NOW POINTS TO EXTENSION
	BR	50$		;GO AND SET EXTENSION

10$:	BIT	R5,#SCXFIL	;GOT A NAME ALREADY
	BEQ	20$		;IF NOT, THEN EXIT
	BIS	#SCXFIL!SCXEXT,R5 ;ELSE SET NAME/EXT GOTTEN
20$:	RETURN			; AND RETURN

30$:	BIS	#SCXFIL!SCXEXT,R5 ;SET GOTTEN NAME & EXT
40$:	BIS	#SCFIL,R5	;SAY FILE NAME EXISTS
	MOV	R4,-(SP)	;SAVE MAIN POINTER
	ADD	#FQNAM1-FQDEV,R4 ;R4 NOW -> THE NAME
	MOV	#S$FIL,R3	;SET BIT FOR FLAG-WORD "BIS"
	CALL	SCANPR		;PACK FIRST WORD
	MOV	#S$FIL,R3	;SET UP FLAG-WORD BIT AGAIN
50$:	CALL	SCANPR		;PACK (ANOTHER) WORD
	BIC	#SCQUES,R5	;INDICATE ? NO LONGER ACTIVE
	MOV	(SP)+,R4	;RESTORE MAIN POINTER
	RETURN			; AND RETURN

.DSABL	LSB

.SBTTL	SUBROUTINES FOR EMT'S

;+
; SCANPR - PACK RAD50 FOR A FILE NAME OR EXTENSION.
;
;	R1 -> CHARACTERS TO PACK
;	R2 -> USER POSTED FLAG WORD
;	R3 =  BIT FOR 1) EXISTS, 2) IS "*", 3) ONE OR MORE "?"'S
;	R4 -> PLACE TO STORE THE RAD50 WORD
;	R5 =  FLAG WORD
;
;	CALL	SCANPR
;
;	R0 =  NUMBER OF ?'S PACKED
;	R1 -> JUST BEYOND THE THREE (3) PACKED CHARACTERS
;	R3 =  DESTROYED
;	R4 -> PLACE RAD50 WORD STORED +2
;-

SCANPR:	CALL	SCANPK		;PACK THE RAD50
	BIS	R3,(R2)		;TELL USER THAT FIELD WAS FOUND
	ASL	R3		;NOW SET UP FOR THE "*" FLAG BIT
.ASSUME	S$FILS	EQ	S$FIL*2
.ASSUME	S$EXTS	EQ	S$EXTE*2
	TSTB	(R1)		;WAS FIELD "*"? (WHOLE WORKAREA -1 IF SO)
	BMI	10$		;YES, GO POST IT TO USER'S FLAGS
	TST	R0		;NO, WERE ANY ?'S FOUND, THEN ?
	BEQ	20$		; NO, NONE OF THEM EITHER:  JUST EXIT
	BIS	#SCWILD,R5	; YES, INSURE WE SAID "SOMETHING WAS WILD",
	ASL	R3		;  AND SET UP FOR THE "?" FLAG BIT
.ASSUME	S$FILQ	EQ	S$FILS*2
.ASSUME	S$EXTQ	EQ	S$EXTS*2
10$:	BIS	R3,(R2)		;POST FLAG BIT TO USER'S FLAGS WORD
20$:	RETURN

;+
; LOGR50 - Convert an ASCII logical name to RAD-50
;
;	R1 -> Nine-character logical to pack
;	R4 -> Place to store the 3 RAD-50 words
;
;	CALL	LOGR50
;
; If R1 -> valid RAD-50 characters:
;
;	R1 -> Past logical name in ASCII
;	R4 -> Past logical name in RAD-50
;	C = 0
;
; If R1 -> invalid characters:
;
;	R1 = Undefined
;	R4 = Undefined
;	C = 1
;-

	TMPORG	EMTDSP,32						;033
	.WORD	LOGR50							;033
	UNORG

.ENABL	LSB								;033

LOGR50:	MOV	R5,-(SP)	;Get a work register			;033
	MOV	R3,-(SP)	;And another one			;033
	MOV	#FSSCVL,R5	;Set up address of table		;033
	MOV	#3,R3		;Number of words to pack		;033
10$:	CALL	40$		;Pack the characters			;033
	BCS	20$		;Error, so stop now			;033
	SOB	R3,10$		;Loop for the whole thing		;033
20$:	MOV	(SP)+,R3	;Restore R3				;033
	MOV	(SP)+,R5	;Restore R5				;033
	RETURN			;And we're done				;033

;+
; SCANPK - PACK RAD50, return BADNAM on error
; SCANLG - PACK LOGICAL RAD50, return BADNAM on error			;031
;
;	R1 -> CHARACTERS TO PACK
;	R4 -> PLACE TO STORE THE RAD50 WORD
;
;	CALL	SCANPK							;031
;	    -OR-							;031
;	CALL	SCANLG							;031
;
;	R0 =  NUMBER OF ?'S PACKED
;	R1 -> JUST BEYOND THE THREE (3) PACKED CHARACTERS
;	R4 -> PLACE RAD50 WORD STORED +2
;-


SCANPK:	MOV	R5,-(SP)	;Release R5 for local use		;033
	MOV	#FSSCVR,R5	;Set up address of table		;033
	BR	30$		;Now join up				;033

SCANLG:	MOV	R5,-(SP)	;Release R5 for local use		;033
	MOV	#FSSCVL,R5	;Set up address of table		;033

30$:	CALL	40$		;Pack the characters			;033
	BCS	SCER		;Die on errors				;033
	MOV	(SP)+,R5	;Restore R5				;033
	RETURN			; AND EXIT				;031

40$:	CLR	R0		;CLEAR "?" COUNTER			;033
	CLR	(R4)		;CLEAR OUR RAD50 BUCKET			;033
	MOV	R2,-(SP)	;Get one work register			;033
	MOV	R3,-(SP)	;Get another work register		;033
	MOV	R5,-(SP)	;Save conversion table pointer		;033
	MOV	#3,R3		;Set up number of characters to pack	;033
50$:	MOVB	(R1)+,R2	;GET THE CHARACTER			;031
	BEQ	100$		;NONE, USE CODE 0
	BPL	60$		;ONE, A NORMAL CHARACTER TO CONVERT
	MOVB	(R5),R2		;IT'S "*", SUBSTITUTE A "?" FOR IT
60$:	CMPB	R2,(R5)+	;SPECIAL CODE CHARACTER MATCH?
	BEQ	80$		;YEP
	TSTB	(R5)+		;NOPE, REALLY END OF TABLE?
	BNE	60$		;THERE'S MORE TO GO, LOOP FOR IT...
70$:	INC	R5		;SKIP A CONVERSION BIAS
	CMPB	R2,(R5)+	;IS CHARACTER TOO LOW?
	BLO	110$		;Yes, exit with C set (BLO = BCS)	;033
	CMPB	R2,(R5)+	;IS CHARACTER TOO HIGH?
	BHI	70$		;YES, GO SKIP CONVERSION AND TRY NEXT RANGE
80$:	CMPB	R2,#'?		;IS THIS CHARACTER A "?" ?
	BNE	90$		;NOPE
	INC	R0		;YEP, COUNT IT
90$:	MOVB	(R5),R5		;GET THE CONVERSION BIAS
	ADD	R5,R2		; AND ADD IT IN
100$:	MOV	(R4),R5		;GET OLD VALUE
	MUL	#50,R5		;* 50 PLEASE
	ADD	R2,R5		;ADD IN NEW VALUE
	MOV	R5,(R4)		; THEN PUT IT BACK
	MOV	(SP),R5		;Restore the conversion table address
	SOB	R3,50$		;Loop for all three bytes		;033
	TST	(R4)+		;Advance to next return word		;033
110$:	MOV	(SP)+,R5	;Restore R5				;033
	MOV	(SP)+,R3	;Restore R3				;033
	MOV	(SP)+,R2	;Restore R2				;033
	RETURN			; AND EXIT				;033

	TMPORG	FSSTBL

	.BYTE	000		;END SPECIAL CHARACTER TABLE

;	HANDY TABLE FOR RAD50 CONVERSIONS

FSSCVL:	.BYTE	'$, 33-'$	;DOLLAR SIGN IS CODE 33			;031
	.BYTE	'., 34-'.	;period (really underline) code is 34	;048
FSSCVR:	.BYTE	'?, 35-'?	;WILD SINGLE CHARACTER IS CODE 35
	.BYTE	 0, 0, 0	;**END OF SPECIAL CODES**
	.ASCII	/09/<^R  0-'0>	;NUMERIC RANGE CHECK AND CONVERSION BIAS
	.ASCII	/AZ/<^R  A-'A>	;ALPHABETIC RANGE CHECK AND CONVERSION BIAS
	.BYTE	-1		;**END OF RANGE CHECK CODES**

;	VALID TERMINATOR LIST (REVERSE ORDERED!)

TRMLST:	.ASCII	"=;/,"<40><0>

	.EVEN

	UNORG

.DSABL	LSB								;031

; "BITBIS" SUBROUTINE
;
;	R5 =  FLAG WORD
;	R2 -> USER POST FLAG WORD
;
;	CALL	BITBIS,R0,MUST-BE-OFF-FLAG-BITS,TURN-ON-FLAG-BITS,POST-BITS

.ENABL	LSB

BITBIS::BIT	R5,(R0)+	;DO ANY BIT(S) MATCH?
	BEQ	10$		;NO, SO ALL IS O.K.
SCER:	ERROR	BADNAM		;TOO BAD

; "BITBIC" SUBROUTINE
;
;	R5 =  FLAG WORD
;	R2 -> USER POST FLAG WORD
;
;	CALL	BITBIC,R0,MUST-BE-ON-FLAG-BITS,TURN-ON-FLAG-BITS,POST-BITS

BITBIC::BIT	R5,(R0)		;DO ANY BIT(S) MATCH?
	BEQ	SCER		;NO, SO ERROR
	BIC	(R0)+,R5	;YES, SO TURN OFF THOSE BIT(S)
10$:	BIS	(R0)+,R5	;NOW TURN ON SPECIFIED BIT(S)
	BIS	(R0)+,(R2)	;TURN ON SPECIFIED BIT(S) FOR CALLER
	RETURN	R0		; AND EXIT

.DSABL	LSB

;+
; CHKSWT - CHECK FOR SWITCHES.
;
;	R5 -> STRING TO CHECK
;
;	CALL	CHKSWT,R4,<ROOT OF SWITCH LIST>
;
;	R0 -> SWITCH BLOCK AT ST.BIT
;	R1 -> LOCATION OF LSB VALUE (RANDOM IF NO VALUE)
;	R2 =  0 IF NO ARGUMENT
;		BIT 15 = 1 IF + OR - SIGN WITH ARGUMENT
;		BIT 14 = 1 IF ANY VALUE AT ALL
;		BITS 7-0 = MSB OF VALUE IF MSB IS LEGAL
;	R3 =  LSB OF VALUE IF ARGUMENT DESIRED (RANDOM IF R2=0)
;	R5 -> REST OF STRING
;
;	FIRST RETURN IF NOT A VALID SWITCH
;
;	SECOND RETURN IF A VALID SWITCH
;-

CHKSWT:	MOV	(R4)+,R0	;GET SWITCH LIST ROOT ADDRESS
	MOV	R5,-(SP)	;SAVE STRING POINTER
	CMPB	(R5),#40	;LEADING <SPACE>?
	BNE	10$		;NO
	INC	R5		;YES, SKIP IT
10$:	CALLX	UNQCHK		;CHECK FOR UNIQUE SWITCH
	BEQ	70$		;NOT FOUND, 1ST EXIT

;	[R0 points to ST.NST]

	CLR	R2		;FOUND, GUESS AT NO ARGUMENT
	TSTB	-(R0)		;NEED AN ARGUMENT?

;	[R0 points to ST.TYP]

.ASSUME	ST.TYP	EQ	ST.NST-1
	BEQ	20$		;NO ARGUMENT DESIRED...
	CMPB	(R5)+,#':	;WANTS ARGUMENT, IS THERE ONE?
	BNE	80$		;NOPE, ERROR
	CALL	GETNBR		;YES, GET THE NUMERIC ARGUMENT
	BCC	20$		;IT IS O.K.
	ERROR	BDNERR		;ELSE ERROR

20$:	MOV	#TRMLST,R1	;GET LIST OF VALID TERMINATORS
30$:	CMPB	(R5),(R1)+	;TERMINATED CORRECTLY?
	BLO	30$		;NO, BUT KEEP CHECKING
	BHI	80$		;NO, ERROR
	MOV	R5,(SP)		;YES, UPDATE THE SAVED STRING POINTER
	MOVB	-(R0),R1	;GET BIT TO SET (& CHECK)

;	[R0 points to ST.BIT]

.ASSUME	ST.BIT	EQ	ST.TYP-1
	BITB	R1,@-(R0)	;IS THE BIT ON ALREADY?

;	[R0 points to ST.SET]

.ASSUME	ST.SET	EQ	ST.BIT-2
	BNE	80$		;YES, ERROR
	MOV	R0,R5		;COPY POINTER TO SWITCH BLOCK HERE
	BISB	R1,@(R0)+	;TURN IT ON NOW...

;	[R0 points to ST.BIT]

	TST	R2		;IS THERE A VALUE TO CHECK/SET?
	BEQ	60$		;NO, ALL DONE
	CMP	R3,-(R5)	;IS THE VALUE LSB WITHIN RANGE?
	BHI	80$		;NO, ERROR
	MOV	-(R5),R1	;GET ADDRESS FOR LSB
	MOV	-(R5),R5	;GET ADDRESS FOR MSB
	BEQ	40$		;IF NONE, THERE BETTER NOT BE AN MSB
	MOVB	R2,(R5)		;IF PRESENT, LOAD IT
	BR	50$		; AND EXIT

40$:	TSTB	R2		;ANY MSB VALUE?
	BNE	80$		;IF SO, ERROR
50$:	BIS	R3,(R1)		;BIT SET THE LSB INTO THE VALUE


;	[R0 still points to ST.BIT but by using a word test below we test the
;	sign of ST.TYP since they are contiguous byte values]

.ASSUME	ST.TYP	EQ	ST.BIT+1
	TST	(R0)		;CHECK THE 'VALUE DESIRED' FLAG FOR BIS/MOV
	BPL	60$		;IF 'BIS' WANTED, AOK
	MOV	R3,(R1)		; ELSE LOAD THE LOCATION WITH A 'MOV'
60$:	TST	(R4)+		;TAKE 2ND EXIT FOR ALL FOUND
70$:	MOV	(SP)+,R5	;RESTORE THE TEXT POINTER
	RETURN	R4		;NOW EXIT

80$:	ERROR	BADSWT		;BAD SWITCH ERROR

;+
; NUMCNV - CONVERT A NUMBER FOR FSS.
;
;	R1 -> FSS WORKING STORAGE (CHARACTERS -OR- -1'S FOR *)
;	R2 -> END OF FSS WORKING STORAGE (START OF USER POST FLAG WORDS)
;
;	CALL	NUMCNV
;
;	(R1) AS A BYTE = CONVERTED NUMBER (255. IF *)
;	(R1) AS A WORD < 0 IF *
;	R3 =  RANDOM
;-

NUMCNV:	TST	(R1)			;IS IT *?
	BMI	10$			;YES, ALREADY ALL SET...
	BEQ	20$			;NO, IT'S NULL, THAT'S AN ERROR...
	TSTB	-1(R2)			;POSSIBLE DATA OVERFLOW?
	BNE	20$			;YES, CALL IT AN ERROR...
	MOV	R1,-(SP)		;SAVE REGISTERS USED
	MOV	R2,-(SP)		; BY THE NUMBER GETTER
	MOV	R5,-(SP)		;  ROUTINE
	MOV	R1,R5			;IT WANTS THE POINTER HERE
	CALL	GETNBR			;CONVERT NUMBER PLEASE
	BCS	20$			;ERROR...
	BIT	#100377,R2		;"+", "-", OR BIG ??
	BNE	20$			;TOO BAD
	CMP	R3,#255.		;STILL TO BIG ?
	BHI	20$			;AGAIN A BADDY
	TSTB	(R5)			;ANYTHING NOT CONVERTED?
	BNE	20$			;ERROR IF SO...
	MOV	(SP)+,R5		;RESTORE THE
	MOV	(SP)+,R2		; SAVED
	MOV	(SP)+,R1		;  REGISTERS
	MOVB	R3,(R1)			;RETURN ANSWER HERE
10$:	RETURN				;THAT'S IT

20$:	ERROR	BADNAM

;+
; GETNBR - GET A NUMERIC ARGUMENT.
;
;	R5 -> STRING
;
;	CALL	GETNBR
;
;	C=1 IF ERROR ELSE C=0
;	R1 =  RANDOM
;	R2 =  MSB AND FLAGS
;		BIT 15 = 1 IF + OR - SIGN WITH ARGUMENT
;		BIT 14 = 1
;		BITS 7-0 = NUMBER MSB
;	R3 =  NUMBER LSB
;	R5 -> JUST BEYOND THE NUMBER
;-

GETNBR:	MOV	R4,-(SP)	;SAVE R4
	CLR	R2		;START WITH NO NUMBER MSB
	CLR	R3		; OR LSB
	MOV	#034000,-(SP)	;SET FLAGS TO SHIFT IN, JUST BIT 13 ON NOW
	MOV	#10.,R4		;SET INITIAL RADIX OF DECIMAL
	CMPB	(R5)+,#'+	;LEADING + SIGN?
	BEQ	10$		;YES
	CMPB	-(R5),#'-	;LEADING - SIGN?
	BNE	20$		;NOPE, NO SIGN
	ASL	(SP)		;- SIGN, FORCE NEGATION LATER (BITS 15 AND 14)
	INC	R5		; AND SKIP THE - SIGN CHARACTER
10$:	ASL	(SP)		;INDICATE SOME SIGN FOUND (BIT 14)
20$:	CMPB	(R5),#'#	;REALLY WANT OCTAL RADIX?
	BNE	40$		;NO
	MOV	#100000!8.,R4	;YES, SET RADIX TO OCTAL
30$:	INC	R5		;SKIP TO NEXT CHARACTER
40$:	MOVB	(R5),R1		;GET NEXT CHARACTER
	SUB	#'0,R1		;CHANGE FROM ASCII INTO BINARY
	CMPB	R1,R4		;LEGAL FOR THIS RADIX?
	BHIS	60$		;NO, DONE WITH NUMBER THEN
	ASHC	#3,R2		;SHIFT THE NUMBER TO MULTIPLY BY 8
	TST	R4		;REALLY WANTED * 10.?
	BMI	50$		;NOPE, WE DID IT RIGHT
	MOV	R2,-(SP)	;YES, SAVE VALUE MSB
	MOV	R3,-(SP)	; AND LSB
	ASHC	#-2,R2		;SHIFT BACK FOR VALUE * 2
	ADD	(SP)+,R3	;ADD IN VALUE * 8
	ADC	R2		; WITH CARRY
	ADD	(SP)+,R2	;  AND PRECISION
50$:	ADD	R1,R3		;ADD THE NEW DIGIT IN
	ADC	R2		; WITH CARRY
	BIT	R2,#^C<177>	;TOO BIG NOW?
	BNE	90$		;SURE IS, ERROR HIM
	INCB	(SP)		;COUNT AS A DIGIT FOUND
	BNE	30$		; AND LOOP...
60$:	CMPB	(R5),#'.	;TRAILING DECIMAL POINT?
	BNE	70$		;NO
	TST	R4		;YES, DECIMAL RADIX??
	BMI	90$		;ERROR, OCTAL AND DECIMAL POINT
	INC	R5		;ELSE O.K., SKIP THE . CHARACTER
70$:	TSTB	(SP)		;ANY DIGITS AT ALL?
	BEQ	90$		;NO, ERROR
	ASL	(SP)		;GET NEGATION FLAG BIT INTO THE CARRY
	MOVB	R2,(SP)		;REPLACE DIGIT COUNT WITH MSB VALUE
	BCC	80$		;NO NEGATION, GO FINISH UP
	BNE	90$		;NEGATION IS ILLEGAL WITH BIG NUMBER
	NEG	R3		;NEGATE THE NUMBER
	BGE	90$		;IT SHOULD BE NEGATIVE NOW, ELSE ERROR
80$:	TST	(PC)+		;SAY ALL IS WELL
90$:	SEC			;INDICATE ERROR
	MOV	(SP)+,R2	;GET MSB AND FLAGS
	MOV	(SP)+,R4	;RESTORE R4
	RETURN			;AND EXIT

;+
; MFPBYT - Get next character from user's string.
;
;	Obtain the next byte from the user's image.
;	Do quote checking, space/tab sequence merging, etc.
;
; MFPCHR - same, except no spaces and/or quotes
;
;	User's XRB has string pointers, quote, char
;		XRBC   =  Remaining character count
;		XRLOC  -> User's string virtually
;		XRCI   =0  => Outside quotes
;		       =X  => Inside quote character 'X'
;		XRCI+1 =0  => Ignore spaces
;		       <>0 => Keep a space
;
;	CALL	MFPBYT
;	    or
;	CALL	MFPCHR
;
;	If Z=1 then no more
;		R0,R3 = 0
;	If Z=0 then got one..
;		R0,R3 = character (1 <= R0,R3 <= 176) or (201 <= R0,R3 <= 376)
;
;-


MFPCHR:	CLR	@#XRB+XRCI+140000 ; Set <sp> ignore and outside quotes


MFPBYT:	MOV	R1,-(SP)	; Obtain a work register
5$:	MOV	#XRB+XRBC+140000,R1 ; Get user XRB pointer @ XRBC
	MOV	(R1),R0		; Get remaining count of string
	BEQ	40$		; No more => exit with zero, and Z-bit set
	DEC	(R1)+		; More, but less 1 of those now
	MOV	(R1),R0		; Get (virtual) string pointer
	BIC	#1,R0		;  and ensure it is a word type pointer
	MFPD	(R0)		; Now get a word from user's image		;024
	CMP	R0,(R1)		; Do we want the low byte?
	BEQ	10$		; Yes, all set
	SWAB	(SP)		; No, switch bytes on the stack
10$:	CLR	R0		; Now fetch the byte that we want
	BISB	(SP)+,R0	;  (discarding the high byte)
	INC	(R1)+		; Bump our virtual pointer
	MOV	R0,R3		; Make a copy of the new byte
	BIC	#^C<177>,R3	;   ..without its eighth bit
	BEQ	5$		; Ignore nulls (C0 or C1)

;+
;	R0 = next character, all eight bits
;	R3 = next character, trimmed to seven bits
;-

	CMP	R3,#177		; Is byte a rubout (C0 or C1) ?
	BEQ	5$		; Yes => ignore it
	TSTB	(R1)+		; Inside of quotes??
	BNE	50$		; Yes, so process inside of quote character
	CMP	R0,#''		; No, about to enter quotes?
	BEQ	60$		; Yes, entering ' style quotes
	CMP	R0,#'"		; How about this kind of quote?
	BEQ	60$		; Yes, entering " style quotes
	CMP	R0,#11		; Outside of quotes, is it a <tab>?
	BNE	20$		; Not a <tab>
	MOV	#40,R0		; A <tab>, replace with a <space>
20$:	CMP	R0,#40		; Is this a <space>?
	BEQ	70$		; Yes, <space> => check it out
	CMP	R3,#40		; No:  is char a control (C0 or C1) ?
	BLO	5$		; Yes => ignore unquoted controls
	CMP	R0,#'A+40	; No, bigger, is it l.c. character?
	BLO	30$		; Not lower case, keep it
	CMP	R0,#'Z+40	; Might be lower case...
	BLOS	25$		; Sure is				;039
	CMP	R0,#340		; Is it a C1 lower case character?	;039
	BLO	30$		; No, not this time			;039
	CMP	R0,#375		; Is this really C1 lower case?		;039
	BHI	30$		; No, not this time			;039
25$:	BIC	#40,R0		; It is l.c., make it into U.C.		;039
30$:	MOVB	R0,(R1)		; Signal keep next space since non-space
40$:	MOV	(SP)+,R1	; Restore work register
	MOV	R0,R3		; Copy returned character, and set condition codes
	RETURN			; Now exit




50$:	CMPB	R0,-(R1)	; Is it the end of quotes?
	BNE	40$		; No, keep it
	CLRB	(R1)+		; Yes, clear quotes and
	BR	30$		;  keep char (also next space)

60$:	MOVB	R0,-(R1)	; Starting quotes, save quote character
	BR	40$		;  but keep the starting quote char

70$:	TSTB	(R1)		; Should we keep this <space>?
	BEQ	5$		; No, ignore it
	CLRB	(R1)		; Yes, but don't keep the next one
	BR	40$		;  and carry on...

;+
; STRCHK - CHECK FOR BEING PASSED A VALID PARAMETER STRING.
;
;	CALL	STRCHK
;
;	R3 -> USER'S XRB
;	<SP> IGNORE AND OUTSIDE QUOTES PRESET
;-

STRCHK:	MOV	#XRB+140000,R3	;GET USER XRB POINTER

;+
; XXXCHK - CHECK FOR BEING PASSED A VALID EXTRA PARAMETER STRING.
;
;	R3 -> PARAMETERS (JUST LIKE AN XRB)
;
;	CALL	XXXCHK
;
;	<SP> IGNORE AND OUTSIDE QUOTES PRESET
;-

XXXCHK:	CLR	XRCI(R3)	;SET <SP> IGNORE AND OUTSIDE QUOTES
	;CLC			;INDICATE A WRITE WITH C=0
	CALLRX	CHKXRB		;NOW CHECK THE XRB PARAMETERS

;
;+
; SETXRB - CHECK XRB FOR VALID PARAMETERS AND SETUP DEFAULT STRING
;
;	XRB+10 = LENGTH OF NON-STANDARD USER LOGICAL AREA
;	XRB+12 = ADDRESS OF NON-STANDARD AREA
;
;	CALL	SETXRB
;
;	R2 = MAPPING VALUE FOR USER LOGICAL AREA
;	R3 => XRB+10
;	R5 = MAPPED POINTER TO USER LOGICAL AREA
;-

SETXRB:	MOV	#XRB+10+140000,R3 ;GET (MAPPED) XRB POINTER
	MOV	@UDPAR0,R2	;PRESET DEFAULT LOGICAL MAPPING		;024
	MOV	(R3),R5		;SPECIAL LOGICALS?
	BEQ	30$		;NO
	BIC	#^C<170007>,R5	;YES, CHECK LENGTH FOR
	CMP	R5,#4		; CORRECTNESS
	BEQ	10$		;ALL O.K.
	CLR	(R3)		;BAD, FORCE AN ERROR
10$:	MOV	(R3),-(R3)	;REPLICATE THE LENGTH
	BIT	#1,XRTIME-XRCI(R3) ; AND CHECK FOR AN ODD ADDRESS.
	BEQ	20$		;THE ADDRESS WAS EVEN.
	ERROR	BADCNT		;OTHERWISE EXIT WITH AN ERROR.

20$:	CALL	XXXCHK		; AND CHECK PARAMETERS
	CALLX	SCRUMX		;GET POINTER MAPPED
.ASSUME	+12	EQ	<10-2+XRLOC>
	MOV	@DPAR6,R2	;SAVE MAPPING VALUE
	MAP	@UDPAR0,APR=6,DATA ;RESTORE OUR MAPPING			;024
	BR	40$		;AND CONTINUE

30$:	MOV	#NSTORG-USRPPN,(R3) ;DUMMY IN A LENGTH
	MOV	#USRPPN+140000,R5 ; AND A POINTER
40$:	MOV	#XRB+14+140000,R3 ;GET XRB POINTER
	MOV	R2,(R3)		;SAVE MAPPING VALUE
	MOV	R5,-(R3)	;SAVE MAPPED POINTER
	ADD	R5,-(R3)	;FIND END POINTER
	RETURN

GLOBAL	<UDPAR0>

.SBTTL	.CCL Switches

; SWITCH TABLE FOR:
;
;	/DET(ACH)
;	/SI(ZE):(+)N

CCLSWT:				;START OF THE CCL SWITCH LIST

	SWTTBL

;		 1    2           3       4     5  6     7     8     9

	SWITCH	/DET,ACH     ,040000/400,XRB+1
	SWITCH	/SI ,ZE      ,020000/400,XRB+1,BIS,32.,XRB+0
	SWTEND

; See FSSSWT: table for parameter definitions

.SBTTL	Fake CCL command block for "$" CCL

DCLCCL:	.WORD	0		;Start off with a pad word		;036
	.BYTE	1,0		;PPN for DCL is [0,1]			;036
	.RAD50	/DCL   /	;File name is DCL			;036
	.RAD50	/RTS/		; .RTS					;036
	.BYTE	'$		;Command is a $				;036
	.BYTE	377		;Set the stopper			;036
	.BLKB0	10		;Now pad the rest of the block with zeroes ;036
	.ASCII	/SY/		;Device name is SY:			;036
	.BYTE	0,377		;Unit is real (SY0:)			;036
	.WORD	0		;Unused word				;036
	.WORD	8192.!100000	;Line number is 8192., privileged	;043

.SBTTL	Handle .CCL Monitor Call

.ENABL	LSB

;+
;	R0 =  EMT code
;	R1 -> JOBDA @JOBF
;	R2 -> JDB2
;	R3 -> Mapped XRB
;	R4 -> Mapped FIRQB
;	R5 -> RTS block
;-
	EMTENT	.CCL		; .CCL comes here
;+
;	Register use on this page..
;
;	R2	-scratch
;	R3	-will return each byte from MFPBYT
;	R4	-extraction:  pointer to extraction workarea
;			(remains through this page, and next page as well)
;	R5	-extraction:  workarea loading cursor
;-

	CALL	STRCHK		; Check string and get its pointers
	MOV	@#JOBWRK,R4	; Create pointer to our extraction area
	ADD	#40-10.,R4	;  [ last byte's address ends in 37(8) ]
	MOV	R4,R5		; Initialize "loading cursor" from that

10$:	CALL	MFPBYT		; Get a byte from <-- by user's XRB	;038
	BEQ	40$		; No more:  done with extraction
12$:	CMP	R3,#40		; A terminator (a space) ?
	BEQ	40$		; Yes -> done with extraction
	CMP	R3,#'/		; A terminator (beginning of switch) ?
	BEQ	40$		; Yes -> done with extraction
	MOV	R4,R2		; Develop temporary pointer -> extraction area's
	INC	R2		;   second byte
	CMP	R5,R2		; Are we now getting second character ?
	BNE	18$		; No -> continue normally
	CMPB	(R4),#'A	; Yes: was first character a "special", then ?
	BLO	38$		; Yes -> done with extraction
18$:	MOVB	R3,(R5)+	; Extraction, continued: store this char
	BIT	#37,R5		; Would next char overflow extraction area ?
	BNE	10$		; Not yet, so go look at another character
30$:	RETURN			; Finally: not a CCL, exit w/o error

38$:	BIS	#100000,R3	; Indicate scan stopped by finding a "special"
	.BR	40$

;+
;	R3 =  Character which stopped extraction scan
;		(sign bit set if scan stopped by "special")
;	R4 -> Origin of our extraction workarea (in JOBWRK)
;	R5 -> Next byte in extraction area into which to store
;-

40$:	CLRB	(R5)		; Set stopper in extraction area for CCLCHK
	MOV	R4,R5		; Point CCLCHK to extracted string

	MAP	FIPPOL		; Map the FIP Pool
	CALLX	CCLCHK		; Does some CCL match extracted string ?
	BNE	50$		; Yes (at least, the first part of it did)	       ;016+
	CMPB	(R4),#'$	; No, is this a command for DCL?	;036
	BNE	30$		; No, not for DCL, forget this		;036
	MOV	#DCLCCL,R0	; Point to the fake CCL block		;036
	MAP	@#KISAR5,APR=5,DATA ;And remap overmapped I&D		;037
	BR	55$		; And join up				;036

50$:	TSTB	(R5)		; Did match eat the whole thing ?
	BNE	30$		; No, spelling error or missing delimiter

;			; Ahhh,..  we've matched against a valid CCL

	CMP	(R0)+,(R0)+	; Point past CCL buffer link, text pointers
55$:	MOV	#FQBSIZ/2-2,R1	; Set count of words to move
	MOV	R1,R5		;  (Save word count for second half of move)
60$:	MOV	(R0)+,-(SP)	; Move all but first two words of CCL
	SOB	R1,60$		;  buffer onto the stack

; Now, re-map to user space, and copy stacked CCL buffer to user's FIRQB

	MAP	@UDPAR0,APR=6,DATA ; Restore user-space mapping			;024
	MAP	@#KISAR5,APR=5,DATA ;And remap overmapped I&D		;037
	MOV	#XRB+140000,R1	; Point to user's XRB
	MOV	#100000,(R1)	; Indicate command-type entry to .RUN code ;021

; We'll now re-copy in reverse direction (down from the top)
								.ASSUME	XRB EQ FIRQB+FQBSIZ
70$:	MOV	(SP)+,-(R1)	; Copy from temporary area to final
	SOB	R5,70$		;  destination (user's FIRQB)

GLOBAL	<UDPAR0>

	MOV	#FIRQB+FQSIZ+140000,R0	; R0 -> full CCL keyword (in FIRQB)
	MOV	#CORCMN+1+140000,R5	; R5 -> Job's core common area
80$:	MOVB	(R0)+,(R5)+	; Copy the full CCL keyword
	BPL	80$		;  until we hit the 377 byte
	CLRB	-(R5)		; Replace the 377 with 0 for end
	MOV	R5,-(SP)	; Save start of CCL parameters
	TST	R3		; Anything more in user's command ?
	BEQ	140$		; No => total end, done
	BPL	90$		; Yes and normal case => continue
	MOVB	#40,(R5)+	; "Special" case:  fake a delimiting <space>
	CLRB	(R5)		;   and keep the trailing <NULL> byte
90$:	CMP	R5,#CORCMN+1+127.-1+140000 ; Too much ?
	BHIS	170$		; Yes, die
	MOVB	R3,(R5)+	; O.K., store in core common
	CLRB	(R5)		;  and keep trailing <NULL> byte
	CALL	MFPBYT		; Now get the next byte			;038
	BNE	90$		; Got one, loop...
	MOV	(SP),R5		; Retrieve pointer to parameter(s)
100$:	CALL	CHKSWT,R4,CCLSWT ; Check for CCL switches
	 BR	140$		; No more switches
	TSTB	(R5)		; Correctly terminated ?
	BEQ	110$		; Yes, EOL is correct
	CMPB	(R5),#40	; Is it space ?
	BEQ	110$		; Yes
	CMPB	(R5),#'/	; Is it / ?
	BNE	130$		; No, error
110$:	TST	R2		; Was it the "/SIZE:nn" switch ?
	BEQ	100$		; No, loop for another switch
	BPL	120$		; Yes, but no sign (incremental) specified
	NEGB	@#XRB+0+140000	; Yes, incremental:  negate the returned value
120$:	TSTB	R3		; Was the value zero ?
	BNE	100$		; Non-zero is O.K.
130$:	ERROR	BADSWT		; else switch error

140$:	MOV	(SP)+,R3	; Get original parameter start
150$:	MOVB	(R5)+,(R3)+	; Now move parameters up
	BNE	150$		;  until the <NULL> byte
	TSTB	@#XRB+XRCI+140000 ; Hanging quote ?
	BNE	160$		; Yes
	CMPB	-2(R3),#40	; No, trailing space ?
	BNE	160$		; Not a trailing space
	DEC	R3		; Trailing space, delete it
160$:	SUB	#CORCMN+1+1+140000,R3 ; Find CCL command length
	MOVB	R3,@#CORCMN+140000    ;  and set that length
	MAP	JOBJC6,APR=6,DATA ; Map job's JCR entry			;041
	MOV	JOBJCR,R2	; R2 -> JCR entry for this job		;041
	MOV	JCCMDL(R2),R4	; R4 has contorted address of .CMDLN buffer ;041
	BEQ	165$		; None, so nothing to return to the pool ;036
	BUFFER	RETURN		; Yes, so return it to the pool		;036
165$:	CLR	JCCMDL(R2)	; Indicate command line is in CORCMN	;041
	MAP	@UDPAR0,APR=6,DATA ; Restore APR6 mapping		;041
	MOV	#XRB+140000,R3	; Set (mapped) pointer to XRB+0
	MOV	#FIRQB+140000,R4 ; Set a (mapped) FIRQB pointer here
	MOV	JOBRTS,R5	; Set pointer to job's RTS block
	MOV	JOBF,R1		;  and, finally, set pointer to JDB @ JDFLG
	BR	190$		; Now go off and do it

170$:	ERROR	LINERR		; Error, CCL command too long

GLOBAL	<UDPAR0>							;041

.SBTTL	Handle .CHAIN and .RUN Monitor Calls

;+
;	R0  =	EMT code
;	R1  ->	JOBDA @JOBF
;	R2  ->	JDB2
;	R3  ->	Mapped XRB
;	R4  ->  Mapped FIRQB
;	R5  ->	RTS block
;-


	EMTENT	.CHAIN		; .CHAIN comes here				       ;019+

	MOV	#1,(R3)		; Indicate a .CHAIN type entry
	BR	180$		; Join common code




	EMTENT	.RUN		; .RUN comes here

	CLR	(R3)		; Indicate not a command-type .RUN entry
	CMP	FQCLUS(R4),#^RCMD	; Good guess ?
	BNE	180$			; Yes => go join common code
	MOV	#000000,(R3)		; Indicate command-type entry
..CRN.	  ==	.-2		; ** Patch **  #100000 to enable command-type .RUN entry
										       ;019-
180$:	BIT	#JFSYS,(R1)	;Allowed to pass privileges?		;036
	BNE	190$		;Yes, leave FQNENT alone		;036
	BIC	#100000,FQNENT(R4) ;Don't allow privileges to be passed	;036

190$:	MOV	JOBDA,R2	; Get JDB ->				;035
	BITB	#^C<MC.LCK!SWP!IN!OUT!REQ>,JDMCTL+M.CTRL(R2)		;035
				; Pending asynch I/O (LCK > 1?)		;035
	BNE	200$		; Yes, CCL/CHAIN/RUN not allowed	;035
	MOV	#15.*2,FQFIL(R4)    ; Channel number is 15.
	MOV	#130000,FQMODE(R4)  ; No write allowed if RUN
	MOV	(R3)+,FQSWIT(R4)    ; Save CCL/CHAIN indication
	MOV	R.NAME(R5),(R3)+    ; Set name (part 1) @ XRB+2
	MOV	R.NAME+2(R5),(R3)+  ; Set name (part 2) @ XRB+4
	MOV	#RUNFQ,R2	; Set the posting pattern
	MOVB	R2,FQFUN(R4)	;  which is also the function
	CALL	@DCOPY		;Copy lowcore from D-space to I-space	;041
	JMP	ASYNCP		; Do a FIP non-synchronous function

200$:	ERROR	INUSE		; Pending I/O, "Account/Device in use"	;035

.DSABL	LSB

GLOBAL	<UDPAR0,DCOPY>							;041

.SBTTL	.PFB redo entry

	RDOENT	PFBRDO							;027

	CALLMI	PFREDO,EM2AP5	; Go do the redo			;034
	RETURN			; Done					;027


.SBTTL	Handle CALFIP Monitor Call

.ENABL	LSB

10$:	ERROR	BADCNT		; Parameter error

20$:	ERROR	BSERR		; Illegal I/O channel

30$:	BIT	R3,#^C<15.*2>	; Legal channel # times 2 ?
	BNE	20$		; Nope -> error
	ADD	R3,R5		; Yep:  point into the I/O block
	TST	(R5)		; Is that channel closed now??
	BNE	55$		; No -> we must do the real call	;041
	RETURN			; Yep:  do a quick return

;+
;	R0 =  EMT code
;	R1 -> JOBDA @JOBF
;	R2 -> JDB2
;	R3 -> Mapped XRB
;	R4 -> Mapped FIRQB
;	R5 -> RTS block
;-


	EMTENT	CALFIP		; CALFIP Comes Here
								.ASSUME	CALFIP&377 EQ 0
	MOVB	FQFUN(R4),R2	; Get the function code/post pattern
	CMP	R2,#NONRTS	; Valid function code?
	BHIS	10$		; No -> error
	BIT	R2,#1		; Odd function code?
	BNE	10$		; Yes -> error
	CMP	R2,#RSTFQ	; Is this reset channel(s)?
	BNE	60$		; No -> go check for UUOFQ
	MOV	@JOBDA,R5	; Yes: get pointer to job's I/O block
.ASSUME	JDIOB	EQ	0
	MOVB	FQFIL(R4),R3	; Also get the RESET CHANNEL(s) parameter
	MAP	FIPPOL		; Map FIP pool for the IOB		;041
	TST	R3		; What kind of reset is this?		;041
	BGT	30$		; >0 means reset a single channel
	NEG	R3		; <=0 means reset all(=0) or all but one(<0)
	MOV	#15.*2,R0	; Start at channel #15.
	ADD	R0,R5		;  and at channel #15. in the IOB
40$:	CMP	R0,R3		; Should we skip this channel?
	BEQ	50$		; Yes -> do so
	TST	(R5)		; No: is the channel closed now??
	BNE	55$		; Not closed -> must do the real call	;041
50$:	CMP	-(R0),-(R5)	; Back up 1 channel in both places
	TST	R0		; To channel #0 by now?
	BNE	40$		; Not yet -> loop..
	RETURN			; Yes:  we can exit quickly

55$:	MAP	@#KISAR5,APR=5,DATA ; Restore our data mapping		;041
	MAP	@UDPAR0,APR=6,DATA ; And map the user's first 4K	;041
	BR	ASYNCP		; Now enter the function asynchronously	;041

GLOBAL	<UDPAR0>

.SBTTL	Handle .UUO Monitor Call

; CALFIP, continued -- accept UUOFQ by turning it into .UUO

60$:	CMP	R2,#UUOFQ	; Is this CALFIP for a UUO ?
	BNE	ASYNCP		; No -> go dispatch this CALFIP
	MOV	R4,R3		; Yes: copy FIRQB pointer and
	ADD	#FQFUN,R3	;  index to function code location
	MOV	#27.,R5		; Set count of parameters to move
70$:	MOVB	1(R3),(R3)+	; Move a parameter byte up 1
	SOB	R5,70$		;  for each of the user parameters

;+
;	R0 =  EMT code
;	R1 -> JOBDA @JOBF
;	R2 -> JDB2	    (If from .UUO, but not if fallthrough from CALFIP)
;	R3 -> Mapped XRB    (If from .UUO, but not if fallthrough from CALFIP)
;	R4 -> Mapped FIRQB
;	R5 -> RTS block     (If from .UUO, but not if fallthrough from CALFIP)
;-

	EMTENT	.UUO		;.UUO comes here

UUO:	MOV	#UUOFQ,R2	; Ensure posting pattern as "UUO"
	MOVB	FQFUN(R4),R3	; Get the UUO function code
	MOVB	R2,FQFUN(R4)	;  and replace it with UUOFQ		;038
	CMP	R3,#UU$MIN	; Is code too small (negative) ?	;036
	BLT	BADSYS		; Yes -> error
	CMP	R3,#UU$MAX	; Is code too big (positive) ?
	BGT	BADSYS		; Yes -> error
	ASL	R3		; No:  OK, code times 2 now
	MOV	$UUOPRV-<UU$MIN*2>(R3),R5 ; Get privilege indicator	;020
	BEQ	87$		; Not a privileged function		;020
	MOVB	JOB,R0		; Get caller's job number		;020
	CALLX	CHKPR5,R4	; Check privileges for this function	;020
	BCS	BADSYS		; Not good enough, quit			;020
87$:	MOV	$UUOTBL-<UU$MIN*2>(R3),R5 ; Get the "address"		;020
	BEQ	BADSYS		; Zero at this point is an error
	MOV	R3,FQADDR(R4)	; Set up the function * 2 to execute	;038
	ASR	R3		; Get the code again
	MOVB	$UUOSNC-UU$MIN(R3),R0   ; Get UUOSNC (flag byte) for this UUO
	BIT	#UUOSLK,R0	; Must this UUO be locked ?
	BNE	LOCKP		; Yes => go "lock" job before FIP entry
	TST	R0		; No:  is this UUO synchronous ?
	BPL	ASYNCP		; No -> go queue it to FIP
							.ASSUME UUOSSN EQ 200
	.BR	SYNCP		; Yes:  try executing it synchronously

.DSABL	LSB

GLOBAL	<$UUOTBL,$UUOPRV,$UUOSNC>					;020

.SBTTL	DISPATCH TO FIP

;+
; SYNCP  - Enter FIP synchronously, doing all the posting
; ASYNCP - Enter FIP asynchronously, doing all the posting
;
;	R1 ->	Job Data Block of caller (at JDFLG)
;	R2  =	Posting pattern index [equal to FQFUN]
;	R3  =	UUO code, if a .UUO (if R2 = UUOFQ)
;	R4 ->	(Mapped) FIRQB of caller
;	R5  =	Dispatch "address" of FIP function (SYNCP only;  not needed for ASYNCP)
;	SP ->	"RTI3",R0,R1,R2,R3,R4,R5,PC,PS,..
;	Calling job is "JOB"
;
;	JMP	SYNCP    or
;	JMP	ASYNCP
;
;
; SYNC   - Enter FIP synchronously, posting already done
; ASYNC  - Enter FIP asynchronously, posting already done
;
;	R4 ->	FIRQB image in work block
;	R5  =	Dispatch "address" of FIP function (SYNC only;  not needed for ASYNC)
;	SP ->	"RTI3",R0,R1,R2,R3,R4,R5,PC,PS,..
;	Calling job is "JOB"
;
;	JMP	SYNC     or
;	JMP	ASYNC
;-


SYNCP::	CALL	FIPPRE		; Do preparation for FIP entry		;034
SYNC:	MAP	FIP,CODE,DATA	; Map FIP,
	JMP	@FIPSNC		;   and go try a sync function
				;	R4 -> WRK block (FIRQB)
				;	R5 =  address of FIP function

ASYNCP::CALL	FIPPRE		; Do preparation for FIP entry		;034
ASYNC:	JMPX	FIPSTL		; Go stall the job + queue the request
				;	R4 -> WRK block (FIRQB)

BADSYS:	ERROR	BADFUO		; Illegal SYS() usage

GLOBAL	<FIPSNC,FIPSTL>

.SBTTL	Preparation for FIP entry, and EMT Logging hook

;+
;	R1 ->	Job Data Block of caller (at JDFLG)
;	R2  =	Posting pattern index [equal to FQFUN]
;	R3  =	UUO code, if a .UUO (if R2 = UUOFQ)
;	R4 ->	(Mapped) FIRQB of caller
;	R5  =	Dispatch "address" of FIP function (if called from SYNCP)
;
;	CALL	FIPPRE
;
;	R4 ->	Caller's FIRQB (in Work Block)
;	R5  =	Dispatch "address" of FIP function (if called from SYNCP)
;
;	R1,R3  ..munged
;-


FIPPRE:	BIS	#JFPOST,(R1)+	; Indicate the FIRQB will need posting
	CLRB	(R1)+		; Set error = 0 at JDIOST
								.ASSUME JDIOST EQ JDFLG+2
	MOVB	R2,(R1)+	; Set posting pattern index
								.ASSUME JDPOST EQ JDIOST+1
	MOV	R3,R0		; Save UUO code
	CALLX	MOVFQB		; Move FIRQB to work block
	MOV	R3,R4		; Point R4 -> work block (FIRQB)
	CALLRX	EMLBLD		; Off to EMT Logger (or RTS.PC, if EML not present)
							.ASSUME JDWORK EQ JDPOST+1

.SBTTL	Start up FIP for .MESAG processing

;+
;	R0 = Function code and flags
;		Low byte	= XXXFQ function code
;		100000 bit	= Job to be left locked (forces non-sync)
;		040000 bit	= Non-sync function
;-

.ENABL	LSB

FIPSND::MOVB	R0,FQFUN(R4)	; set the correct FIP function code
	MOV	R0,-(SP)	; Save R0 to preserve flags
	MOVB	R0,R0		; Get rid of flags
.ASSUME	FQFSIZ LT 200
	MOV	$FIPTBL(R0),R5	; Now get that function's "address"
	ASL	(SP)+		; Check the flags
	BCS	80$		; Leave job locked
	BMI	ASYNC		; Non-sync function
	BR	SYNC		; Sync function

GLOBAL	<$FIPTBL>							;034

.SBTTL	Start a FIP function, locking JOB in memory

;+
; Come here to start a FIP function that needs to have the job in memory.
; So we leave it locked by duplicating some code from "ASYNC" onwards,
; without doing the UNLOCK, then merging into common code.  If the way
; FIP dispatching works changes, this duplicated code might have to change
; to match.
; Currently the flow is as follows:
;	1. Put job in FIP wait state (FIPSTL, in RES)
;	2. Compute new residency quantum (FNDRSQ, in SUB)
;	3. Unlock the job (UNLOC0, in SUB)
;	4. Save the job and set up the null job (SAVJBL, in SUB)
; Step 3 is the one we want to skip, so we'll duplicate 1 and 2, then go to 4.
;-


LOCKP:	CALL	FIPPRE		; Do standard preparation for a FIP entry
80$:	MOVB	JOB,R0		; Get job number
	CLR	JBSTAT(R0)	; Make job not runnable
	MOV	#JSFIP,JBWAIT(R0) ; and waiting on FIP
	MOV	JOBDA,R1	; Get JDB pointer
	CALLX	FNDRSQ		; Recompute residency quantum
	TST	(R1)+		; Point to job flags
.ASSUME	JDFLG EQ 2
	CALLX	SAVJBL,R5	; Save job, set up null job
	JMPX	FIPSYS		; Now queue the FIRQB R4 points at

.DSABL	LSB

GLOBAL	<JBSTAT,JBWAIT>

.SBTTL	HANDLE .ULOG MONITOR CALL

;+
;	R0 =  EMT CODE
;	R1 -> JOBDA @JOBF
;	R2 -> JDB2
;	R3 -> MAPPED XRB
;	R4 -> MAPPED FIRQB
;	R5 -> RTS BLOCK
;-

	.ENABLE	LSB

	EMTENT	.ULOG		;.ULOG COMES HERE

ULOG:	MOV	(R3),10(R3)	;MOVE LENGTH OF NON-STANDARD LOGICALS
	MOV	4(R3),12(R3)	;MOVE ADDRESS OF NON-STANDARD LOGICALS
	CALL	SETXRB		;CHECK FOR NON-STANDARD LOGICALS
	MOV	R0,-(SP)	;save EMT code for reference in CALUUO	;047
	MOV	R4,-(SP)	;save firqb pointer for reference	;047
	MOVB	FQFUN(R4),R0	;GET THE FUNCTION
	SUB	#10.,R0		;FUNCTIONS START AT 10.
	BMI	10$		;ERROR IF FQFUN < 10.
	ASL	R0		;TIMES 2 FOR OFFSET
	BIC	#^C<6>,R0	; AND TRIM TO 0,2,4, OR 6
	ADD	R0,PC		;NOW DISPATCH ON FUNCTION
	 BR	20$		; 0=ASSIGN/REASSIGN/LIST
	 BR	15$		; 2=DEASSIGN				;047
	 BR	REMVAL		; 4=DEASSIGN ALL			;047
10$:	 JMP	BADSYS		; 6=NOT IMPLEMENTED

		;Deassign all logicals
REMVAL:	CALL	CLRLOG		;CLEAR ALL USER LOGICALS
	MOV	(SP),R4		;get ^FIRQB back (stack unchanged)	;047
	CMP	#1,FQFIL(R4)	;was this a logical deassign only?	;047
	BEQ	EXIT.1		;yes -split, else deassign devices also	;047
CALUUO:	MOV	(SP)+,R4	;^firqb retrieved			;047
	MOV	(SP)+,R0	;orginal EMT code retrieved		;047
	MOV	JOBF,R1		;RESTORE POINTER TO JOB DATA BLOCK @ JDFLG
	MAP	@UDPAR0,APR=6,DATA ;RESTORE OUR MAPPING			
	CALLR	UUO		;DISPATCH TO .UUO

GLOBAL	<JHFREE,JHULOG,UDPAR0>

		;Deassign or call UUO for de-allocate
15$:	MOV	#LG$USR+LG$DEA,R0 ;Guess at user logical only deasign	;050
	TST	FQNAM1(R4)	;DEASSIGN USER LOGICAL?
	BNE	25$		;YES, DEASSIGN (IF MATCH)		;050
	CLR	R0		;ASSUME SUCCESS
	TST	FQPPN(R4)	;DEASSIGN USER ASSIGNABLE PPN?
	BNE	120$		;YES, CLEAR ASSIGNABLE PPN
	TST	FQPROT-1(R4)	;DEASSIGN DEFAULT PROTECTION?
	BNE	19$		;YES, CLEAR DEFAULT PROTECTION
	TST	FQDEV(R4)	;DEASSIGN DEVICE?
	BNE	CALUUO		;YES, DISPATCH TO .UUO
	CALL	CLRLOG		;Delete all logicals			;050
	BR	EXIT.1		;Exit cleaning up stack			;050

19$:	MOV	R5,R3
	BR	110$

		;[RE]assign PPN, Device etc
		;  R3 ->XRB+10		/ending table address  (141000)
		;	  +12		/Starting address table(140734)
		;	  +14		/mapping value for above(M.PHY)

100$:	MOV	4(R3),R2	;get the mapping value of table		;047+
	MOV	2(R3),R3	; make R3 point at PPN default		;047+
	MOV	FQPPN(R4),R0	;FOUND A PPN?
	BNE	120$		;YES, FILL IN THE ASSIGNED PPN
	MOV	FQPROT-1(R4),R0	;FOUND A PROTECTION CODE?
	BEQ	CALUUO		;else, DISPATCH TO .UUO for device assign ;049
110$:	TST	(R3)+		;POINT TO DEFAULT PROTECTION		;047
120$:	MAP	R2,APR=6,DATA	;RE-MAP TO THE TABLE
	MOV	R0,(R3)		;FILL IN THE VALUE			;047
	BR	EXIT.1		;THAT'S ALL THERE IS


20$:	MOV	FQNAM1(R4),R0	;CHECK FOR ASSIGN/REASSIGN
	BEQ	100$		;GO ASSIGN PPN,PROT OR DEVICE
	CMP	#200,R0		;is it a list function			;049
	BEQ	LISTUL		;if flag =128% then yes			;049
	CMP	#63.,R0		;if <64. its JOB# so
	BHIS	CALUUO		;DISPATCH TO .UUO;  else
				;Do assign				;047+
	MOV	#LG$USR,R0	;set to do user logical only
	BITB	#LG$UNR,FQSIZM(R4) ;is the User No Replace requested?	;047+
	BNE	25$		;yes- don't set replace flag		;047+
	BIS	#LG$RPL,R0	;no- default is set (do) replace	;047+
25$:	ADD	#20*2,R4	;^FIRQB+workarea size
	MOV	#20,R1		;word count of work area
30$:	MOV	-(R4),-(SP)	;copy firqb to stack
	SOB	R1,30$		;all of it
	MOV	SP,R5		;copy pseudo-firqb top pointer
	ADD	#FQNAM1,R5	;pointer to RAD50 name
	MOVB	@#JOB,R3	;who are any way
	CALLMI	SEARCH,EMTAP5	;is it there now?
	BIT	#LG$DEA,R0	;is it a deassign function?
	BNE	DEASGN		;if set yes
	BCS	ADDUSR		;if c=set by SEARCH, it is new assignment
	BIT	#LG$RPL,R0	;is /REPLACE turned on?			;047+
	BEQ	220$		;no, skip out then doing nothing-FIEXST	;049
	MAP	PUSH,APR=6,DATA	;save the mapping of the logical sub blk;049+
	MAP	@UDPAR0,APR=6,DATA	;map the user low core again	;049+
	BISB	#LG$UNR,FQFUN(R4) ;set flag that it was replaced	;047+
	MAP	POP,APR=6,DATA	;restore mapping of logical to replace	;049+
	BIT	#LG$LOW,R0	;was it fouund in a user table?		;047+
	BEQ	35$		;no - then we can re-assign it		;047+
	CALL	ZAPALG		;yes- then remove from there before add	;047+
	BR	ADDUSR		;now add it in the new structure	;047+

		;ULOG does not deal with replacement bit, it is DEASGN tag
35$:	MOV	FQPPN-FQNAM1(R5),SL$PPN(R3)	;PPN replaced		;047+
	MOV	FQDEVN-FQNAM1(R5),SL$NUM(R3)	;unit # and flag	;047+
	MOV	FQDEV-FQNAM1(R5),SL$DEV(R3)	;device name		;047+
EXIT.0:	ADD	#20*2,SP	;drop work area from stack
EXIT.1:	CMP	(SP)+,(SP)+	;trash R0 & R4 that were not used
	RETURN			;  and we're out of here


LISTUL:	MOV	FQFIL(R4),R1	;get list index (see if present?)	;049
	BEQ	230$		;if none that's an error		;049
	CMP	#255.,R1	;artifical limit to prevent runaway
	BLO	230$		;if R1>255. then error NOTFND
	MOV	R1,-(SP)	;save the current
	MOV	R4,-(SP)	;save the ^FIRQB
	MOV	#LG$USR,R0	;set logical status as user only
	CALL	LISTLG		;go extract data for nth logical
	MAP	@UDPAR0,APR=6,DATA	;map the user low core again
	MOV	(SP)+,R4	;pop the ^FIRQB
	MOV	(SP)+,R1	;get the orignal index value back
	INC	R1		;goal is to make life easier for user
	MOV	R1,FQFIL(R4)	;replace with indexed bumped
	ADD	#<FQPPN-FQNAM1>,R5 ;make workblk pointer start at PNN
	ADD	#FQPPN,R4	;likewise with ^FIRQB
	MOV	#12.,R1		;set to copy thru FQCLUS
40$:	MOV	(R5)+,(R4)+	;copy wrkblk->firqb
	SOB	R1,40$		;till done
	BR	EXIT.1		;   and bag it...			;047

;	CLEAR LOGICAL DEVICE, ASSIGNED PPN, AND DEFAULT PROTECTION CODE

CLRLOG::MOV	@#XRB+10+140000,R0 ;GET END OF TABLE
	MOV	@#XRB+12+140000,R1 ;POINT TO USER LOGICAL AREA
	MAP	XRB+14+140000,APR=6,DATA ;NOW RE-MAP TO THE TABLE
150$:	CLR	(R1)+		;CLEAR ALL LOGICALS
	CMP	R1,R0		;AT END OF TABLE?
	BLO	150$		;LOOP
160$:	MOVB	@#JOB,R3	;who are we now?			
	CALLM	ZAPLOG,GENAP5	;clear the job header list		
	RETURN


	;from SEARCH
	;	R0 = status
	;	R1 = logical size (bytes)
	;	R2 = contorted previous ^buffer
	;	R3 -> current buffer top
	;	R4 ->firqb (not mapped)
	;	R5 ->logical name in work area

DEASGN:	BCS	230$		;error nosuch
	MOV	R2,R5		;save the prev buffer
	CALL	ZAPALG		;erase logical data found
	BNE	EXIT.0		;if >0 then not last in buffer
	TST	R5		;is this the head end
	BNE	130$		;no
	MOV	(R3),@#JHULOG	;make link the new head end
	BR	140$		;now got drop buffer

130$:	MOV	(R3),(R5)	;make current link the prev link
140$:	MOV	@#JHFREE,(R3)	;put last free top as current link and
	MOV	R3,@#JHFREE	;make this buffer new free top
	BR	exit.0		;homeward bound..

GLOBAL	<UDPAR0,ZAPLOG>

ADDUSR:	MOVB	@#JOB,R3	;who am I
	CALLX	MAPHDR		;map the user header area
	TST	(R5)		;is any name present (must be one)	
	BEQ	260$		;no - that's not good			
	CMP	(R5),#^R$	;ADD, LEGAL FIRST CHARACTER?		
	BLO	170$		;YES					
	CMP	(R5),#^R0	;MAYBE...				
	BLO	260$		;YES					

170$:	MOV	R4,-(SP)	;save the ^firqb
	CLR	R4		;signal RAD50 code /nooutput
	CALLX	RADASP		;translate accepting "."'s as "_"
	MOV	(SP)+,R4	;restore ^FIRQB
	BCS	260$		;bum input if carry set
	MOV	@#JHULOG,R3	;no then get user list top		
	CALL	LOGADD		;put in chain pointed by R3		
	BCS	250$		;if c=1 the no buffers- failed		
	BR	exit.0		;else we are done			

220$:	ERROR	FIEXST		;replace required but /noreplace bit set ;049

230$:	ERROR	NOSUCH		;CAN'T FIND THAT LOGICAL

240$:	ERROR	INUSE		;DOUBLE LOGICAL NAMES CAN'T HAPPEN

250$:	ERROR	NOBUFS		;NO MORE BUFFER SPACE LEFT		

260$:	ERROR	BADFUO		;illegal SYS() usage

	GLOBAL	<RADASP>

LOGADD::  
	;R3 -> first buffer in chain					
	;R0	is status
	;R5 ->	first rad50 word (length known in status
	;R2	fill in flag; If r2=-1 then R3->sub blk top
	TST	12(R5)		;absolute logical length limit
	BNE	240$		;BADNAM error if not empty
	INC	R2		;fill in flag set?
	BEQ	LOGFIL		;yes - just do that
	CALL	LOGHOL		;find a correct sized hole and fill in
	BCC	320$		;done ok? c=0 is yes
290$:	CALL	LOGROW		;no, must grow a buffer
	BCS	325$		;if c=1, sorry no buffers
LOGFIL:	MOV	R5,R2		;copy pointer to input logical
	BIT	#LG$NEW,R0	;is the current buffer 3per or 5 per type?
	BEQ	300$		;if 0=TYP then 5 per buffer (old style)
	MOV	#<SL$SIZ-SL$NAM>/2,R1	;it's new, set length to 7 words
	BR	310$		;go fill in

300$:	MOV	#<SL$SZS-SL$NAM>/2,R1	;old style set limit to 3 words
310$:	MOV	FQPPN-FQNAM1(R5),(R3)+	;copy PPN (or 0 if none)
	MOV	FQDEV-FQNAM1(R5),(R3)+	;copy device name to logical sub blk
	MOV	FQDEVN-FQNAM1(R5),(R3)+	;copy device unit # & flag
315$:	MOV	(R2)+,(R3)+	;copy rad50 logical to sub blk
	SOB	R1,315$		;until all done
320$:	CLC			;indicate success
325$:	RETURN								


LOGHOL:	;Find a proper size hole in the logical chain and fill it	
	;R3 ->	chain top
	;R0	status
	;R5 ->	"firqb" @FQNAM1
	; APR6 mapping left correct by caller
	CLR	-(SP)		;we will need a cell
	CLR	-(SP)		;pre-set previous buffer pointer
	TST	R3		;no more buffers to test?
	BEQ	395$		;nope- sorry chain is empty, must grow
	BR	335$		;skip over linkage get
330$:	MOV	(R3),R3		;get next link
	BEQ	395$		;if zero there no more
335$:	BIC	#LG$NEW,R0	;preset buffer style status
	MOV	R3,R4		;copy address for MAPBUF input
	CALLX	MAPBUF		;uncontort those that are in XBUF
	MOV	R3,2(SP)	;save current ^buffer as ^prev buffer(mapped)
340$:	MOV	#SL$SZS-SL$PPN,R4	;assume the size for old style
	BIT	#LG$NLG,R0	;is it a short style?
	BNE	370$		;yes
	MOVB	3(R3),R1	;get the new style allocation byte
	BEQ	330$		;if zero its not our style today
	BIS	#LG$NEW,R0	;note this buffer is the new type
	MOV	#SL$SIZ-SL$PPN,R4	;note the proper size
	BIS	#^C<7>,R1	;set all bits but the allocation ones	;051
350$:	COM	R1		;now the polarity of allocation is reversed
	MOV	#4,R2		;point to the first sub block
	MOV	#1,(SP)		;set up allocation tag
	CLC			;for sureness
360$:	BCS	380$		;is this allocated c=0 is used, c=1 is hole
	BEQ	330$		;yes- but are there any free left? z=1 is no
	ROL	(SP)		;rotate allocation bit
365$:	ADD	R4,R2		;offst to next sub blk
	ROR	R1		;rotate the allocation byte
	BR	360$		;loop till no more

370$:	MOVB	2(R3),R1	;get the old style allocation byte
	BEQ	330$		;if zero not our style this time
	BIS	#^C<37>,R1	;set all bits but the allocation ones
	BR	350$		;now do the common check

380$:	BIT	#LG$HLE,R0	;Hole found-should we just report it?
	BNE	390$		;yes then its been found
	SUB	R4,R2		;we added before we check 1st sub-blk	
	ADD	R3,R2		;add buffer top pointer to offset to sub blk
	ROR	(SP)		;compensate for 1st pass here also
	BIT	#LG$NEW,R0	;is this a new style buffer?
	BEQ	385$		;no (SP) set already
	SWAB	(SP)		;put the flag in high byte
385$:	BIS	(SP),2(R3)	;its not byte because (SP) set up
	MOV	R2,R3		;set targets for LOGFIL
	CALL	LOGFIL		;fill in the sub block w/ logical
390$:	CLC			;note our success
	TST	(PC)+		;step over fault set condition
395$:	SEC			;indicate no hole found (need to grow)
	INC	(SP)+		;clean up stack leaving carry be
	MOV	(SP)+,R1	;get the previous link for LOGROW
	RETURN

.ENABLE	LSB								
GLOBAL	<SYSLOG,BITBYT,USETBL,FIQUE,UNTCNT>				


LOGROW:	;make the current chain grow by one buffer and init it for size	
	;for usr logical a minimum header presumed available
	;R1 points to last block in chain(mapped) or 0 if no chain yet
	;R0	status including sizing

	BIT	#LG$SYS,R0	;is the system logical?
	BNE	440$		;yes
410$:	MOV	@#JHFREE,R2	;point to free list in job hdr
	BEQ	480$		;no more room to expand
420$:	MOV	(R2),@#JHFREE	;update free list pointer, taking 1
	CLR	(R2)		;0 link of the one we took off free list
	TST	R1		;is this the first use?
	BNE	430$		;no that's good
	MOV	R2,@#JHULOG	;set as list top
	BR	460$		;goto common thread

430$:	MOV	R2,(R1)		;else link it in
	BR	460$		;re-join also

440$:	MOV	R1,-(SP)	;save pointer to prev				
	BUFFER	GETLRG,100,-1,LRGPOL ;TRY TO GET AN XBUF CHUNK		
.ASSUME	100	GE	3*SL$SIZ+4					
	MOV	(SP)+,R1	;regain previous pointer		
	BNE	443$		;was there one there?			
	MOV	#SYSLOG,R1	;no- so this will be the first		
443$:	BCS	480$		;NONE TO BE HAD				
	INC	@#USETBL+UT.LOG	;GOT ONE, INCREMENT MONITOR'S COUNTER	
	MOV	R4,(R1)		;LINK IT INTO LIST AT THE TAIL		
		;presumption here that there is at least one buff on list
	CALLX	MAPBUF		;MAP IT					
	MOV	R3,R2		;GET POINTER TO 			
	MOV	#100/2,R4	;buffer size (see assume above)		
445$:	CLR	(R3)+		;  BLOCK IN CHUNK    (CLEAR ALLOC FLAGS)
	SOB	R4,445$		;zap the buffer				
460$:	BIC	#LG$NEW,R0	;assume old style			
	MOV	#1,R1		;allocate first sub block (old)		
	BIT	#LG$NLG,R0	;is the logical NOT long?		
	BNE	470$		;yes (short)				
	BIS	#LG$NEW,R0	;no (long), note it			
	SWAB	R1		;set allocation to new style byte	
470$:	MOV	R1,2(R2)	;put allocation byteS in place		
	MOV	R2,R3		;make up the sub block pointer		
	ADD	#4,R3		; and point at first one		
	;CLC			;from add above				
	TST	(PC)+		;step over error exit			
480$:	SEC			;error exit				;047-
	RETURN

.DSABL	LSB

.ENABL	LSB
LISTLG:: ;R1 = n	to list the nth logical in chain		;047+
	;R3 -> top of chain only required if system listing
	;	if user logical header must be mapped to APR6
	BIT	#LG$SYS,R0	;system call?
	BNE	55$		;yes - different mapping needed
	MOVB	@#JOB,R3	;who am I 
	MOV	JOBTBL(R3),R4	;get ^JDB
	MOV	JDWORK(R4),R5	;get ^workblk
	CALLX	MAPHDR		;map me please to my header
	MOV	@#JHULOG,R3	;get list top pointer
	BEQ	230$		;if not there - we're done
	MOV	#16.,R2		;set to zero work blk
53$:	CLR	(R5)+		;a word at a time
	SOB	R2,53$		;until done
	MOV	JDWORK(R4),R5	;re-get ^wrkblk top
	ADD	#FQNAM1,R5	;every body expects pointing here
55$:	MOV	R3,R4		;copy ^BUFFER for mapbuf use
	CALLX	MAPBUF		;maps the XBUF if contorted address
	MOV	R3,R0		;point to top of mapped buffer
	MOV	#SL$SIZ,R4	;maximum length of logical
	MOVB	3(R3),R2	;get long style allocation byte
	BNE	56$		;if non zero its new style
	MOV	#SL$SZS,R4	;reset length to old style
	MOVB	2(R3),R2	;so get the its allocation byte
	BEQ	NXTBUF		;if zero its empty -go to next
56$:	BIC	#^C<37>,R2	;clear any extranie
LISCYC:	CLC			;assurance
	ROR	R2		;see if next sub slot allocated
	BCS	LISCNT		;if set -its used & count it
	BEQ	NXTBUF		;if not used & not more used goto next 
	BR	LISADV		;  else go look for the next one

LISCNT:	DEC	R1		;count down from the requestedNth
	BEQ	LISTIT		;this is the one-
LISADV:	ADD	R4,R0		;add the logical size for this buffer type
	BR	LISCYC		;this was not it-so go for the next

LISTIT:	ADD	#4,R0		;add offset for link & allocation words
	MOV	R5,R1		;address of wrkblk FIRQB@FQNAM1
	ADD	#<FQPPN-FQNAM1>,R1	;point at first word we care about
	MOV	#12.,R2		;count space to clear for us
57$:	CLR	(R1)+		;clear it for us
	SOB	R2,57$		;till done
	MOV	R5,R1		;re-get wrk blk ^FIRQB@FQNAM1
	MOV	(R0)+,FQPPN-FQNAM1(R1)	;  and PPN where they belong
	MOV	(R0)+,FQDEV-FQNAM1(R1)	;put device name
	MOV	(R0)+,FQDEVN-FQNAM1(R1);  and unit # & flag
	MOV	R4,R2		;copy sub blk size
	SUB	#<SL$NAM-SL$PPN>,R2  ;make just size of logical in bytes
	ASR	R2		;from byte size to word count
58$:	MOV	(R0)+,(R1)+	;copy the i rad50 words 3 or 7
	SOB	R2,58$		;list buffer to wrkblk
	BIT	#LG$SYS,R0	;are we a system list call?
	BEQ	60$		;no so skip FIP stuff
	MAP	FIPPOL		;to make fip exit happy
60$:	RETURN								

NXTBUF:	MOV	(R3),R3		;get link, is there one?		
	BNE	55$		;yes go map it if needed and continue	
	.BR	230$		;no more so it not there		

230$:	ERROR	NOSUCH		;CAN'T FIND THAT LOGICAL

240$:	ERROR	BADNAM		;something wrong with input data

.DSABL	LSB
	GLOBAL	<JOBTBL,UDPAR0>						;047-

ZAPALG::  ;remove a pointed to logical 					;047+
	;at input registers are:
	; R0 = status
	; R1 = logical size
	; R3 = mapped pointer to sub buffer
	;at output
	;   if Z=1 this was the last allocated sub buffer and the
	;	entire buffer may be return to its free pool on exit
	;   if z=0 more data remains in the buffer
	;
	; R0 = status
	; R1 = size
	; R2 = bit mask of sub buffer cleared 	*
	; R3 = pointer to buffer top		*
	; R4 random
	; (*) if in user table value is random

	MOV	R3,R4		;copy sub buffer pointer
	MOV	R1,R2		;copy size
	ASR	R2		;make it words
10$:	CLR	(R3)+		;zero the logical data
	SOB	R2,10$		;until all words done
	MOV	R4,R3		;re-get sub buffer pointer
	BIT	#LG$LOW,R0	;was it in a user table?		;047+
	BEQ	15$		;no- continue the process		;047+
	BIC	#LG$LOW,R0	;yes- well it ain't there now!		;047+
	BR	60$		;and that leaves nothing left to do	;047+

15$:	BIC	#77,R3		;make it point to buffer top
	SUB	#4,R4		;correct for overhead words in buffer
	MOV	#1,R2		;set up rotation word
20$:	CMP	R4,R3		;have we reach the buffer top?
	BEQ	40$		;yes -
	BLO	30$		;something is very wrong here
	ASL	R2		;no - adjust bit mask and
	SUB	R1,R4		;see if next one is it
	BR	20$		;now test again

30$:	CRASH			;to prevent run aways

40$:	BIT	#LG$NEW,R0	;which type are we, new?
	BNE	50$		;yes, if set its new type
	BICB	R2,2(R3)	;no, clear the bit of the subbuffer found
	BR	60$		;start for home

50$:	BICB	R2,3(R3)	;new style use the other allocation byte
60$:	RETURN			;if Z=1 then it is an empty buffer	;047-


.END
