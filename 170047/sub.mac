	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
	.INCLUDE /CMN:FLDEF/
TITLE	SUB,<SYSTEM SUBROUTINES>,0C,19-JUL-91,MHB/ABC/SJK/MJG/GPK/SJM/JTC/DRP/FEK/FRL/KPH/PRL/MNB/WRM

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR SUB

;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;  001	PK   16-Feb-81	Added XPEEK and DDCU
;  002	SJM  06-Apr-81	Added support for default KBM
;  003  SJM  04-May-81	Fix BADRTS for use with DEFKBM and B+ as DEFRTS
;  004  SJM  12-Jul-81	Add support for I&D space
;  005	JTC  04-Aug-81	Fix SAVTIM to work with Data space
;  006	JTC  14-Sep-81	Modifications for FIP in I-space and APR 6
;  007	GPK  11-Nov-81	Added entry SAVJBL for .MESAG
;  008	DRP  26-Apr-82	Fix CHKXRB and LIBADX problem with I/O from resident
;			libraries mapped in APR 7
;
;				[RSTS V8.0]
;  009	GPK  11-Nov-82	32K jobs
;
;				[RSTS V9.0]
;  010	GPK  04-Mar-83	Job headers
;  011	GPK  04-Apr-83	Multiple privileges
;  012	GPK  17-May-83	Change J2HDRS to a byte
;  013	GPK  07-Jun-83	Change .PRIV to .BPRIV
;  014	FEK  15-Jun-83	Add user I/D support
;  015	GPK  21-Sep-83	Add SYSMGR, remove job headers, new permanent
;			file handling
;  016  FRL  25-Oct-83  Added extended level three queue (L3Q) capability
;  017	FEK  02-DEC-83	Allow I/O to non 0 offsets in libs
;  018  KPH  14-Dec-83	Add dynamic regions
;  019	PRL  21-Jan-84	Update TABSET to pass R3 unchanged to <subroutine>
;  020  MNB  22-Jan-84  Asynch changes in M.CTRL byte
;  021  MNB  14-Feb-84  Add ASIODN routine for Asynch I/O posting
;  022	KPH  05-Apr-84	Changes for task-loader
;  023	GPK  20-Apr-84	Privilege name changes; dummy out SCNPRM; add ONE
;  024	KPH  26-Jun-84	Change ASIODN to run at PR3
;  025	DRP  10-Jul-84	Source clear fix to ADDMEM bug
;  026	KPH  29-Aug-84	Changes for APR5 FIP pool
;  027	KPH  03-Dec-84	Make J2ISIZ and J2DSIZ bytes
;			Hooks for supervisor mode library support
;  028	KPH  08-Feb-85	Changes for the monitor RTS
;  029	KPH  11-Mar-85	Place floating libraries in RESLST first
;  030	GPK  05-Apr-85	Force previous mode = user in SAVJBL
;
;				[RSTS V9.1]
;  031	KPH  12-Mar-85	Make sure APR5 is always mapped R/W
;
;				[RSTS V9.2]
;  032  KPH  25-Jul-85	Job control region
;			Move IOB to FIP pool
;  033  KPH  24-Oct-85	Bugfix in FNDJOB
;			Remove pre-emptive scheduling
;  034  KPH  03-Dec-85	Bugfix in BADRTS
;
;				[RSTS V9.3]
;  035  KPH  01-May-86	Add support for dynamic DDBs
;  036  KPH  07-Jun-86	Fix library protection problems
;			Fix LIBADX handling of special regions
;
;				[RSTS V9.4]
;  037  KPH  30-Jan-87	Changes for new mapping structure
;  038	PJH  05-MAR-87	Change ASSUME to actual offset in LOOPCK
;
;  				[RSTS V9.5]
;  039	PJH  08-Jul-87	Add large disk support
;
;
;				[RSTS V9.6]
;  040  WRM  20-Jan-88	Re-write FNDJOB for performance & EXTM$ function
;  041  WRM  15-May-88	Add synch multi-user Supervisor mode to Context
;
;				[RSTS V9.7]
;  042	DRP  20-Oct-88	Modify FNDJOB to map the user's buffer if RESCHK
;			failed because the RTS or LIB was not resident
;			but the job was.
;  043  WRM  31-Mar-89	Force error from Get unit for DV: not created
;
;				[RSTS V10.0]
;  044  WRM  26-Oct-89	Add LIB I/O beyond mapped area
;  045	FEK  19-Feb-90	Handle Asynch I/O completions for non-TUNE users
;  046	FEK  10-May-90	Header dumping and preemptive scheduler option
;
;				[RSTS V10.1]
;  047	FEK  16-Apr-91	Allow DV:=SY:, optimize PREMPT
;  048	FEK  16-Jul-91	Fix condition if SLI swap out is done, but in isn't
;-


	DEFORG	SUBISP
	DEFORG	SUB

	DEFORG	LIBISP
	DEFORG	LIBCTL

	DEFORG	STORE
	DEFORG	FETCH
	DEFORG	CLRBUF

	ORG	SUBISP
	TMPORG	SUB

.SBTTL	PURE DATA FOR EVERYONE

; GIVEN WORD INDEX (0 TO 36 STEP 2) GET A BIT WITHIN A WORD

ONE::									;023
BITWRD::.WORD	000001
	.WORD	000002
	.WORD	000004
	.WORD	000010
	.WORD	000020
	.WORD	000040
	.WORD	000100
	.WORD	000200
	.WORD	000400
	.WORD	001000
	.WORD	002000
	.WORD	004000
	.WORD	010000
	.WORD	020000
	.WORD	040000
	.WORD	100000

; GIVEN BYTE INDEX (-6 TO 0) GET THE CLUSTER RATIO			;039

	.BYTE	64.							;039
	.BYTE	32.							;039
	.BYTE	16.
	.BYTE	8.
	.BYTE	4.
	.BYTE	2.
CLUCVT::;.BYTE	1.

; GIVEN BYTE INDEX (0 TO 7) GET A BIT WITHIN A BYTE

BITBYT::.BYTE	001
	.BYTE	002
	.BYTE	004
	.BYTE	010
	.BYTE	020
	.BYTE	040
	.BYTE	100
	.BYTE	200

; A FULL TIME (READ-ONLY) ZERO WORD

ZERO::	.WORD	0

; A FULL TIME (READ-ONLY) ALL ONE'S WORD

MINUS1::.WORD	-1

; L3Q BIT DEFINITION FOR 2780 CODE ONLY

QRJIDL ==: <OQRJIDL*400>+BQRJIDL 					;016

	UNORG

.SBTTL	CHARACTER HANDLING ROUTINES

;+
; THE CHARACTER ROUTINES (STORE, FETCH, CLRBUF) MANAGE THE CHARACTER
;	BUFFER CHAINS. THE DATA BASE FOR THESE ROUTINES IS KEPT IN THE
;	DEVICE'S DDB AND CONSISTS OF 3 WORDS: 1) THE EMPTY POINTER [EP],
;	2) THE FILL POINTER [FP], AND 3) THE BUFFER COUNT [BC].
;
; NOTES ON THE HANDLING OF THE "BC" (BUFFER COUNT) WORD:
;
;	1) BC STARTS OUT AT SOME POSITIVE VALUE WHICH IS THE
;		DEVICE'S "BUFFER QUOTA".
;
;	2) EVERY TIME A BUFFER IS ADDED TO THAT DEVICE'S BUFFER
;		CHAIN (A 'STORE'), BC IS DECREMENTED.
;
;	3) EVERY TIME A BUFFER IS REMOVED FROM THAT DEVICE'S BUFFER
;		CHAIN (A 'FETCH' OR 'CLRBUF'), BC IS INCREMENTED.
;
;	4) THE NUMBER OF BUFFERS THAT THE DEVICE IS USING CAN BE
;		FOUND BY SUBTRACTING THE CURRENT BC VALUE TO THAT
;		DEVICE'S INITIAL BC VALUE (THE DEVICE'S "BUFFER QUOTA").
;
;	5) IF THE VALUE AT BC IS 0 THEN THE DEVICE HAS USED ITS
;		QUOTA OF BUFFERS.
;
;	6) IF THE VALUE AT BC IS <0 THEN THE DEVICE IS OVER QUOTA.
;		(NOTE: THE 'FREBUF' ROUTINE WILL PERMIT THIS TO
;		OCCUR.)
;-

.DSECT			;VERIFY ORDER OF EP, FP, BC

EP:	.BLKW		;EMPTY POINTER
FP:	.BLKW		;FILL POINTER
BC:	.BLKW		;BUFFER COUNT

	UNORG

.SBTTL	STORE A CHARACTER

;+
; STORE - STORE 1 CHARACTER (BYTE) INTO THE BUFFER CHAIN.
;
;	R1 -> DDB
;	R2 =  CHARACTER (BYTE) TO STORE
;
;	CALL	STORE,R5,<OFFSET+FP>
;
;	R4 =  RANDOM
;
;	IF C=0 THEN THE STORE COMPLETED
;	IF C=1 THEN THE STORE FAILED
;-

.ENABL	LSB

	TMPORG	STORE

STORE:	ADD	(R5),R1		;INDEX TO FILL POINTER IN THE DDB
	MOV	(R1)+,R4	;NOW GET THE CURRENT FILL POINTER
	BIT	R4,#40-1	;IS FILL POINTER ALL USED UP?
	BNE	20$		;NO, SO USE IT
	SUB	#40,R4		;BACKUP TO THIS BUFFER'S TOP
	BHIS	10$		;NO UNDERFLOW, SO IT WAS NOT 0
	MOV	R1,R4		;ELSE BUILD A POINTER TO THE EMPTY
	CMP	-(R4),-(R4)	; POINTER FOR INITIAL LINKING
10$:	MOV	R4,-(SP)	;SAVE PREVIOUS ADDRESS FOR LINKING
	BUFFER	GETSML,0	;GET ANOTHER BUFFER (NOTHING CLEARED)
	BVS	30$		;FAILED TO GET A BUFFER, PUNT
	DEC	(R1)		;GOT ONE, DECREMENT THE BUFFER COUNT
	CLR	(R4)+		;CLEAR LINK TO NEXT IN NEW BUFFER
	MOV	R4,@(SP)+	;NOW LINK THIS TO REST OF THE CHAIN
20$:	MOVB	R2,(R4)+	;ALL O.K., STORE CHARACTER IN THE BUFFER
	MOV	R4,-(R1)	;NOW UPDATE THE FILL POINTER IN THE DDB
	SUB	(R5)+,R1	;RE-INDEX BACK TO DDB'S TOP
	;CLC			;THE 'SUB' ABOVE CLEARED THE CARRY
	RETURN	R5		;EXIT WITH C=0 FOR STORE COMPLETED

30$:	TST	(SP)+		;DUMP THE STACK ITEM
	JMP	70$		; AND GO EXIT WITH C=1

	UNORG

.SBTTL	FETCH A CHARACTER

;+
; FETCH - FETCH 1 CHARACTER (BYTE) FROM THE BUFFER CHAIN.
;
;	R1 -> DDB
;
;	CALL	FETCH,R5,<OFFSET+EP>
;
;	R2 =  CHARACTER (BYTE) FETCHED
;	R4 =  RANDOM
;
;	IF C=0 THEN THE FETCH COMPLETED
;	IF C=1 THEN THE FETCH FAILED
;-

	TMPORG	FETCH

FETCH:	ADD	(R5),R1		;INDEX TO THE EMPTY POINTER IN DDB
40$:	MOV	(R1)+,R4	;NOW GET THE EMPTY POINTER
	CMP	R4,(R1)		;ARE THE TWO POINTERS THE SAME?
	BEQ	70$		;YES, NO MORE CHARACTERS
	BIT	R4,#40-1	;NO, MORE IN THIS BUFFER THEN??
	BEQ	60$		;NO MORE HERE, GO TO THE NEXT BUFFER
	MOVB	(R4)+,R2	;ALL O.K., FETCH THE CHARACTER
	CMP	R4,(R1)		;WOULD NEXT FETCH FAIL?
	BNE	50$		;NO
	DEC	R4		;YES, SO FIND THE TOP OF THIS
	BIC	#40-1,R4	; BUFFER AND THEN INDEX TO THE
	TST	(R4)+		;  FIRST STORAGE LOCATION TO
	MOV	R4,(R1)		;   REUSE THE BUFFER AGAIN
50$:	MOV	R4,-(R1)	;NOW UPDATE THE EMPTY POINTER
	SUB	(R5)+,R1	;RE-INDEX BACK TO DDB'S TOP
	;CLC			;THE 'SUB' ABOVE CLEARED THE CARRY
	RETURN	R5		;AND EXIT ALL O.K. (C=0)

60$:	SUB	#40,R4		;GET BACK TO THIS BUFFER'S TOP
	MOV	(R4),-(R1)	;RESET EMPTY POINTER TO NEXT IN CHAIN
	BUFFER	RETSML		;NOW RETURN THIS BUFFER
	INC	BC-EP(R1)	;AND COUNT IT AS RETURNED
	BR	40$		;LOOP FOR ANOTHER TRY...

70$:	TST	-(R1)		;CORRECT (INDEXED) DDB POINTER
	SUB	(R5)+,R1	;RE-INDEX BACK TO DDB'S TOP
	SEC			;INDICATE FAILURE (C=1)
	RETURN	R5		; AND EXIT WITH C=1

	UNORG

.DSABL	LSB

.SBTTL	CLEAR A BUFFER CHAIN

;+
; CLRBUF - CLEARS A WHOLE BUFFER CHAIN ALL AT ONCE.
;
;	R1 -> DDB
;
;	CALL	CLRBUF,R5,<OFFSET+EP>
;
;	R4 =  RANDOM
;
; NOTE: PRIORITY IS RAISED TO PR5 DURING THE CLEAR IF
;	THE CALLING PRIORITY WAS PR4 OR LESS.
;-

	TMPORG	CLRBUF

CLRBUF:	ADD	(R5),R1		;INDEX TO EMPTY POINTER IN THE DDB
	MOV	@#PS,-(SP)	;SAVE THE CALLING PRIORITY
	CMPB	(SP),#PR5	;IS CALLING PRIORITY PR5 OR GREATER?
	BHIS	10$		;YES, LEAVE PRIORITY THE SAME
	SPLC	5		;;NO, RAISE PRIORITY TO PR5 FOR DURATION
10$:	MOV	(R1)+,R4	;;NOW GET THE EMPTY POINTER
	BEQ	30$		;;NO EMPTY POINTER, SO DONE ALREADY
20$:	DEC	R4		;;UNCONDITIONALLY GO TO THE
	BIC	#40-1,R4	;; TOP OF THIS BUFFER
	MOV	(R4),-(SP)	;;SAVE LINK TO THE NEXT BUFFER
	BUFFER	RETSML		;;THEN RETURN THIS BUFFER AND
	INC	BC-FP(R1)	;; COUNT IT AS RETURNED
	MOV	(SP)+,R4	;;RESTORE THE NEXT BUFFER ADDRESS
	BNE	20$		;;LOOP UNTIL DONE...
30$:	CLR	(R1)		;;NOW SET BOTH POINTERS TO
	CLR	-(R1)		;; ZERO TO INDICATE NO CHAIN
	MOVB	(SP)+,@#PS	;;RESTORE CALLING PRIORITY
	SUB	(R5)+,R1	;RE-INDEX BACK TO DDB'S TOP
	RETURN	R5		;AND EXIT

	UNORG

.SBTTL	DO TAB STOP CALCULATIONS

;+
; TABSET - DO TAB STOP CALCULATIONS.
;
;	R1 -> DDB
;
;	CALL	TABSET,R5,<SUBROUTINE>
;
;	R0 =  WHATEVER THE <SUBROUTINE> LEFT
;	R1 =  WHATEVER THE <SUBROUTINE> LEFT
;	R2 =  WHATEVER THE <SUBROUTINE> LEFT
;	R3 =  SAME AS PASSED
;	R4 =  RANDOM
;	R5 =  SAME AS PASSED
;
;	FIRST EXIT MEANS ALL COMPLETE (C-BIT AS PER LAST <SUBROUTINE> CALL)
;
;	SECOND EXIT MEANS AT END-OF-LINE (THE TAB OVERFLOWED LINE)
;
;	THE <SUBROUTINE> IS CALLED WITH 'JSR PC,' AND GETS:
;
;	R0 =  SAME AS PASSED TO "TABSET"
;	R1 -> DDB
;	R2 =  SAME AS PASSED TO "TABSET"
;	R3 =  SAME AS PASSED TO "TABSET"				;019
;	R4 =  RANDOM
;	R5 =  RANDOM
;
;	ONLY R5 MUST BE PRESERVED BY THE <SUBROUTINE>
;-

TABSET::MOV	R3,-(SP)	;SAVE R3
	MOVB	DDHORC(R1),R4	;NOW CALCULATE THE CURRENT		;019
	SUB	DDHORZ(R1),R4	; HORIZONTAL POSITION			;019
.ASSUME	DDHORZ&1 EQ	0
	COM	R4		;FORM THE TAB COUNT			;019
	BIC	#^C<7>,R4	; MOD (8) FROM				;019
	INC	R4		;  THAT POSITION			;019
	CMPB	R4,DDHORZ(R1)	;WILL WE OVERFLOW THE LINE?		;019
	BHIS	20$		;YES
	MOV	#30$,-(SP)	;NO, SET FINAL RETURN ADDRESS
10$:	MOV	(R5),-(SP)	;STACK 1 MORE <SUBROUTINE> CALL		;019
	SOB	R4,10$		;LOOP FOR ALL NEEDED STOPS...		;019
	TST	(R5)+		;SET RETURN ADDRESS			;019
	RETURN			;NOW OFF TO THE <SUBROUTINE>

20$:	MOVB	#1,DDHORZ(R1)	;SET POSITION AS END-OF-LINE
	TST	(R5)+		;TAKE THE
	TST	(R5)+		;  2ND EXIT				;019
30$:	MOV	(SP)+,R3	;RESTORE R3
	RETURN	R5		; AND EXIT

.SBTTL	CHECK FOR BUFFER AVAILABILITY

;+
; FREBUF - CHECK FOR BUFFER AVAILABILITY.
;
;	R1 -> DDB
;
;	CALL	FREBUF,R5,<INITIAL QUOTA>
;
;	IF C=0 THEN BUFFER(S) ARE AVAILABLE
;	IF C=1 THEN NO BUFFER IS AVAILABLE
;
; NOTE:	IF NO BUFFERS ARE AVAILABLE DUE TO A LACK OF BUFFERS
;	SYSTEM-WIDE (AS OPPOSED TO THIS DEVICE BEING AT ITS
;	BUFFER QUOTA ALREADY) THEN THE JOB IS RE-STALLED IN THE
;	BUFFER WAIT STATE (JSBUF) IF THE JOB IS "JOB".
;-

.ENABL	LSB

FREBUF::MOV	R0,-(SP)	;;GET A WORKING REGISTER
	TST	(R5)+		;;SKIP TO REAL RETURN ADDRESS
	MOV	FREES+2,R0	;;PICKUP CURRENT SMALL BUFFER COUNT
	CMP	R0,#10.		;;ARE LESS THAN 10. FREE SYSTEM-WIDE?
	BLO	30$		;;YES, SO EXIT C=1 AND RE-STALL [BLO=BCS]
	TST	DDBUFC+BC(R1)	;;IS DEVICE UP TO QUOTA NOW?
	BGT	10$		;;NOT YET, EXIT C=0 FROM 'TST' ABOVE
	CMP	R0,FREE20	;;IS (CURRENT FREE) < (20% TOTAL FREE) ?
	BLO	10$		;;EXIT C=1 IF SO [BLO=BCS]
	MOV	-2(R5),R0	;;ELSE GET INITIAL QUOTA AND FIND
	SUB	DDBUFC+BC(R1),R0 ;; (INUSE) = (INITIAL-CURRENT)
	CMP	FREE25,R0	;;IS (25% TOTAL FREE) < (INUSE) ?
	;BHIS	10$		;;NO, EXIT C=0 [BHIS=BCC]
	;BLO	10$		;;YES, EXIT C=1 [BLO=BCS]
10$:	MOV	(SP)+,R0	;;RESTORE WORKING REGISTER
20$:	RETURN	R5		;; AND EXIT

30$:	MOVB	DDJBNO(R1),R0	;;GET THE JOB NUMBER TIMES 2
	CMPB	R0,JOB		;;IS THIS JOB "JOB"?
	BNE	40$		;;NO
	MOV	SP,FREES	;;YES, INDICATE SOMEONE STALLED FOR BUFFERS
	MOV	#JSBUF,JBWAIT(R0) ;;RE-STALL THIS JOB ON A BUFFER WAIT
40$:	SEC			;;INDICATE FAILURE WITH C=1
	BR	10$		;; AND GO EXIT

GLOBAL	<FREES,FREE20,IDX.KB,FREE25,JBWAIT>

.SBTTL	CHECK BEFORE LOOPING

;+
; LOOPCK - CHECK FOR ANOTHER WANTING TO RUN BEFORE LOOPING.
;
;	CALLING JOB IS "JOB"
;
;	CALL	LOOPCK,R5
;
;	IF C=0 THEN NO ONE MORE IMPORTANT WANTS TO RUN
;	IF C=1 THEN YOU SHOULD QUIT SOON
;-

LOOPCK::CLC			;PRE-INDICATE O.K. TO LOOP		;016
	;Check for any L3Q bits of higher priority than QBUFRT.		;016
	TST	L3QUE		;Process pending in first word?		;016
	BNE	50$		;Yes, do it now				;016
	BITB	#BQBUFRT-1,@#L3QUE+OQBUFRT ;Higher priority process pending?  ;038
	BNE	50$		;Yes, do it now				;016
	BITB	#BQSCHED,@#L3QUE+OQSCHED ;Is scheduler trying to stop us? ;016
	BEQ	20$		;No, exit C=0				;016
50$:	MOV	R0,-(SP)	;GET A WORKING REGISTER
	MOVB	JOB,R0		;GET JOB NUMBER TIMES 2
	MOV	JBWAIT(R0),JBSTAT(R0) ;MAKE RUNNABLE SINCE FORCED STOP
	BR	40$		;GO EXIT INDICATING FAILURE (C=1)

.DSABL	LSB

GLOBAL	<L3QUE,JBWAIT,JBSTAT>

.SBTTL	REGISTER SAVE/RESTORE

;+
; REGSAV - SAVE ALL REGISTERS ON STACK.
;
;	REGSAV
;
;	-OR-
;
;	CALL	REGSAV,R5
;
; NOTE: THE REGSAV MACRO DEFINES THE SYMBOLS:
;		TOS.R0,TOS.R1,...,TOS.R5,TOS.PC,TOS.PS
;	TO BE TO SP STACK OFFSETS TO GET AT THOSE REGISTERS.
;-

REGSAV::MOV	R4,-(SP)	;SAVE R4,
	MOV	R3,-(SP)	; AND R3,
	MOV	R2,-(SP)	;  AND R2,
	MOV	R1,-(SP)	;   AND R1,
	MOV	R0,-(SP)	;    AND R0
	MOV	5*2(SP),-(SP)	;REPLICATE SAVED R5
	RETURN	R5		;AND EXIT

;+
; REGRES - RESTORE ALL REGISTERS FROM STACK.
;
;	CALL	REGRES,R5
;-

REGRES::MOV	(SP)+,R0	;DUMMY TO REMOVE SAVED R5
	MOV	(SP)+,R0	;RESTORE R0,
	MOV	(SP)+,R1	; AND R1,
	MOV	(SP)+,R2	;  AND R2,
	MOV	(SP)+,R3	;   AND R3,
	MOV	(SP)+,R4	;    AND R4
	RETURN	R5		;RESTORE R5 AND EXIT

;+
; REGSCR - SAVE ALL REGISTERS ON STACK AND SET UP CO-ROUTINE EXIT.
;
;	REGSCR
;
;	-OR-
;
;	CALL	REGSCR,R5
;
; NOTE: THE REGSCR MACRO DEFINES THE SYMBOLS:
;		TOS.R0,TOS.R1,...,TOS.R5,TOS.RA
;	TO BE TO SP STACK OFFSETS TO GET AT THOSE REGISTERS.
;-

REGSCR::MOV	R4,-(SP)	;SAVE R4,
	MOV	R3,-(SP)	; AND R3,
	MOV	R2,-(SP)	;  AND R2,
	MOV	R1,-(SP)	;   AND R1,
	MOV	R0,-(SP)	;    AND R0
	MOV	R5,-(SP)	;SAVE RETURN ADDRESS ON STACK
	MOV	6*2(SP),R5	;NOW RESTORE THE REAL R5 VALUE
	CALL	@(SP)+		;NOW CALL OUR CALLER
	MOV	(SP)+,R0	;RESTORE R0,
	MOV	(SP)+,R1	; AND R1,
	MOV	(SP)+,R2	;  AND R2,
	MOV	(SP)+,R3	;   AND R3,
	MOV	(SP)+,R4	;    AND R4,
	MOV	(SP)+,R5	;     AND R5
	RETURN			;NOW RETURN

.SBTTL	QUEUE MANAGEMENT

;+
; QUEUER - QUEUE AN ITEM INTO A QUEUE (FIFO).
;
;	R4 -> ITEM TO QUEUE
;
;	CALL	QUEUER,R5,<QUEUE ROOT>
;
;	IF C=0 THEN ITEM IS NOT FIRST IN QUEUE
;	IF C=1 THEN ITEM IS FIRST (AND ONLY) ITEM IN QUEUE
;-

.ENABL	LSB

QUEUER::MOV	R0,-(SP)	;GET A WORKING REGISTER
	MOV	(R5)+,R0	; TO GET A POINTER TO THE QUEUE ROOT
10$:	CLR	(R4)		;ENSURE A 0 LINK IN THIS ITEM
	TST	(R0)		;SET Z-BIT=1 IF QUEUE NOW EMPTY
	SEC			;PRE-INDICATE FIRST IN QUEUE (C=1)
	BEQ	30$		;QUEUE NOW EMPTY, ENTER IN QUEUE AND C=1
20$:	MOV	(R0),R0		;ELSE GET NEXT IN THE QUEUE LIST
	TST	(R0)		;THE END YET? (AND C=0)
	BNE	20$		;NOT THE END, CONTINUE LOOKING
30$:	MOV	R4,(R0)		;PUT NEW ITEM INTO THE QUEUE
	MOV	(SP)+,R0	;RESTORE WORKING REGISTER
	RETURN	R5		; AND EXIT (C=1 OR C=0)

;+
; QUEUE0 - QUEUE AN ITEM INTO A VARIABLE QUEUE (FIFO).
;
;	R0 -> QUEUE ROOT
;	R4 -> ITEM TO QUEUE
;
;	CALL	QUEUE0,R5
;
;	IF C=0 THEN ITEM IS NOT FIRST IN QUEUE
;	IF C=1 THEN ITEM IS FIRST (AND ONLY) ITEM IN QUEUE
;-

QUEUE0::MOV	R0,-(SP)	;SAVE THE QUEUE ROOT
	BR	10$		;NOW JOIN COMMON CODE

.DSABL	LSB

.SBTTL	NON-I/O DISK CALLS

;+
; DISKNE - NON-I/O, NON-ERROR DISK CALL.
;
;	R4 -> DSQ
;
;	CALL	DISKNE
;-

DISKNE::MOVB	#-1,DSQERR(R4)	;SAY NO ERROR OCCURED

;+
; DISKER - NON-I/O, POSSIBLE ERROR DISK CALL.
;
;	R4 -> DSQ (WITH DSQERR SET UP)
;
;	CALL	DISKER
;-

DISKER::SPLC	5		;;LOCKOUT DISK INTERRUPTS
	CALL	QUEL3Q		;;DO END OF TRANSFER HOUSEKEEPING
	SPLC	3		;;BACK TO LEVEL 3 AGAIN
	RETURN			; AND EXIT

.SBTTL	QUEUE AND SET LEVEL 3 QUEUE BIT(S)

;+
; QUEL3Q - QUEUE AND SET LEVEL 3 QUEUE BIT(S).
;
;	R4 -> LINK, XXX, ->ROOT/BITS
;
;	CALL	QUEL3Q
;-

QUEL3Q::MOV	R0,-(SP)	;GET TWO
	MOV	R1,-(SP)	; WORKING REGISTERS
	MOV	DSQL3Q(R4),R1	;GET POINTER TO ROOT/BITS
.ASSUME	DSQL3Q	EQ	4
	MOV	(R1)+,R0	;NOW GET THE QUEUE ROOT
	BEQ	10$		;NO ROOT, JUST GO SET THE BIT(S)
	CALL	QUEUE0,R5	;ROOT EXISTS, QUEUE INTO IT
	BCC	20$		;NOT FIRST IN QUEUE, SKIP L3Q BIT SET
10$:	MOV	(R1),R0		;GET THE L3Q BIT(S) TO SET
	CALL	L3QSE0,R5	; AND GO SET THEM
20$:	MOV	(SP)+,R1	;RESTORE THE
	MOV	(SP)+,R0	; WORKING REGISTERS
	RETURN			;NOW EXIT

.SBTTL	I/O PARAMETER CHECK

;+
; CHKXRB - CHECK XRB FOR VALID PARAMETERS.
;
;	R3 -> XRB
;	C=0 => CHECK WRITE ACCESS (USER --> MONITOR)
;	C=1 => CHECK READ ACCESS (MONITOR --> USER)
;	CALLING JOB IS "JOB"
;
;	CALL	CHKXRB
;
;	VALID PARAMETERS IF RETURN
;
;	"BADCNT" ERROR IF INVALID
;-

CHKXRB::MOV	R1,-(SP)	;GET A WORKING REGISTER
	ROR	R1		;MAKE R1<0 FOR READ ACCESS CHECKING
	MOV	(R3)+,-(SP)	;GET BUFFER LENGTH ("XRLEN")
	BEQ	40$		;NO LENGTH IS AN ERROR
	CMP	(SP),(R3)	;CHECK LENGTH VS. BYTE COUNT ("XRBC")
	BLO	40$		;ERROR IF LENGTH < BYTE COUNT
	CMP	(R3)+,#1	;SET C=1 ONLY IF BYTE COUNT =0
	BIT	R1,R1		;CHECK TYPE OF ACCESS
	BPL	30$		;R1>=0, WRITE, BYTE COUNT MUST BE <>0
	BCC	40$		;R1<0, READ, ERROR IF BYTE COUNT <>0
	CMP	(R3),#FPPTXT+<6*4*2> ;WOULD READ CLOBBER CONTEXT AREA?
	BLO	40$		;YES, SO AN ERROR
10$:	ADD	(R3),(SP)	;FIND ENDING ADDRESS +1
	BCC	15$		;OVERFLOW IS CERTAINLY TOO FAR
	BNE	79$		; but might be in a LIB or region	;044+
				; if it was =0 must check all types	;044+
15$:	CMP	(R3),MAXDLO	;DOES IT START IN JOB IMAGE?		;014
	BHI	50$		;NO, CHECK FOR WITHIN RTS OR LIB
	DEC	(SP)		;Compute end address + 0
	CMP	(SP)+,MAXDLO	;TOTALLY WITHIN THE JOB IMAGE??		;014
	BHI	40$		;NOPE, SPLITS IMAGE, ERROR
20$:	CMP	-(R3),-(R3)	;ALL O.K., BACK UP TO TOP OF XRB
	MOV	(SP)+,R1	;RESTORE WORKING REGISTER
	RETURN			; AND RETURN

30$:	BCC	10$		;WRITE IS O.K. IF BYTE COUNT <>0
40$:	ERROR	BADCNT		;ILLEGAL XRB PARAMETER(S)

50$:	MOV	R0,-(SP)	;SAVE A WORKING REGISTER
	CMP	(R3),MAXHGH	;IS START INSIDE THE RUN-TIME SYSTEM?
	BLO	80$		;NO, BUT MAY BE WITHIN A LIBRARY
	TST	2(SP)		;END+1 ADDRESS AT THE 32K BOUNDARY
	BEQ	40$		;YES, ILLEGAL ADDRESS, PSEUDO-VECTOR REGION
	CMP	2(SP),#P.OFF	;IS END+1 INTO PSEUDO-VECTOR REGION
	BHI	40$		;YES, ILLEGAL FOR RTS'S
	MOV	JOBRTS,R0	;GET POINTER TO JOB'S RTS BLOCK
60$:	TST	R1		;IS THIS A READ REQUEST?
	BPL	70$		;NO, WRITE, RTS OR LIB CAN BE R-O
	BIT	#PF.RW,R.FLAG(R0) ;A READ/WRITE RTS?
65$:	BEQ	40$		;NO, READ-ONLY, DON'T CLOBBER IT
70$:	MOV	(SP)+,R0	;RESTORE WORKING REGISTER
	TST	(SP)+		;  POP THE END+1 ADDRESS OFF OF THE STACK
	BR	20$		;    AND EXIT

79$:	CLR	(SP)		;address over flow mark as such		;044+
	MOV	R0,-(SP)	;SAVE A WORKING REGISTER,match 50$ path	;044+
80$:	MOVB	JOB,R0		;Get caller's job # * 2			;032
	MOV	R2,-(SP)	;SAVE WORKING REGISTERS
	MOV	R3,-(SP)	;  ...
	MOV	R4,-(SP)	;  ...					;032
	MOV	#WS$UDS,R4	;Set up to check data space windows	;032
	MOV	(R3),R3		;GET STARTING ADDRESS TO CHECK
	CALL	LIBADX		; AND CHECK ALL MAPPED WINDOWS
	BCC	40$		;ERROR, STARTING ADDRESS NOT MAPPED
	MAP	PUSH,APR=5,DATA ;Save DPAR5 mapping	
	MAP	PUSH,APR=6,DATA ;And save DPAR6 mapping	
	MAP	FIPPOL		;Map FIP pool for the WDB
	TST	R2		;DOES MAPPED WINDOW END AT THE 32K BOUNDARY?
	BNE	90$		;no- leave it unmodified for math	;044+
	DEC	R2		;yes-ending addr=32k=0 set to 32k-1	;044+
90$:	CMP	R2,14(SP)	;ENDING ADDRESS WITHIN MAPPED WINDOW?	;044+
	BLO	100$		;window top<buffer end addr chk region	;044+
			;at this point R0 ->address window sub-block	;044
			;		R2 = highest mapped address	;044
			;		R3 -> LIB block @R.link		;044
	TST	14(SP)		;was it an overflow address?		;044+
	BNE	110$		;no- re-join skipping needless math	;044+
100$:	CLR	R4		;get the region size			;044
	BISB	R.KSIZ(R3),R4	;  in KWs				;044
	ASH	#5,R4		;  and make it into slivers REG.MMU	;044
	MOV	<3*2>(SP),R3	;get ^XRB@VIR.ADDR (done w/ LIB block)	;044
	MOV	XRLEN-XRLOC(R3),R2 ;get BUFLEN (bytes)			;044
	BIC	#^C<64.-1>,R2	; get sub-sliver portion ssbuf.byte	;044
	MOV	R2,-(SP)	;   and save ssbuf.byte			;044
	MOVB	W$NAPR(R0),R2	;get base apr #				;044
	ASH	#13.,R2		;  and make it a virtual address(*8192.) ;044
	MOV	R2,-(SP)	;  and save it for a moment		;044
	MOV	(R3),R2		;get the virtual start address		;044
	SUB	(SP)+,R2	;calc dist from offset in bytes		;044
	ADD	(SP)+,R2	;  +ssbuf.byte				;044
	ADD	#63.,R2		;  +sliver size-1 to round up		;044
	ASH	#-6,R2		;   and make into sliver Y.MMU		;044
	BIC	#176000,R2	;  sign extend is a problem here	;044+
	MOV	R2,-(SP)	;    and save Y.MMU			;044
	MOV	XRLEN-XRLOC(R3),R2 ;get BUFLEN (bytes) again		;044
	ASH	#-6,R2		;  make it slivers BUF.MMU (round down)	;044
	BIC	#176000,R2	;  sign extend is a problem here	;044+
	ADD	(SP)+,R2	;  +Y.MMU				;044
	ADD	W$NOFF(R0),R2	;  +offset.MMU to base apr		;044
		;R2 is now # of slivers from LIB base to I/O buff top	;044
	CMP	R4,R2		;REG.MMU-BUFTOP.MMU			;044
	BLO	40$		;error if REGtop<BUFtop			;044
110$:	MOV	(R0),R0		;copy W$NSTS for later			;044
	MAP	POP,APR=6,DATA	;Yes, restore DPAR6 mapping	
	MAP	POP,APR=5,DATA	;And DPAR5 mapping		
	MOV	(SP)+,R4	;Restore working registers	
	MOV	(SP)+,R3	;  ...
	MOV	(SP)+,R2	;  ...
	TST	R1		;Is this a read request?	
	BPL	70$		;No, write, library can be read-only
	BIT	#WS$WRT,R0	;Library mapped read/write?		;044
	BR	65$		;go do the test there			;044

GLOBAL	<MAXDLO,MAXHGH>

.SBTTL	CHECK USER'S SP STACK FOR VALIDITY

;+
; CHKSTK - CHECK USER'S SP STACK FOR VALIDITY.
;
;	CALLING JOB IS "JOB"
;
;	CALL	CHKSTK
;
;	R1 -> OLD USER SP STACK VALUE -4
;
;	IF C=0 THEN GOOD USER SP STACK
;	IF C=1 THEN ILLEGAL USER SP STACK
;-

.ENABL	LSB

CHKSTK::MFPD	SP		;FETCH USER'S SP STACK VALUE		;014
	BIT	(SP),#1		;STACK ODD?
	BNE	30$		;YES, ERROR
	DEC	(SP)		;Account for MAXLOW being last valid address
	CMP	(SP),MAXDLO	;STACK IN USER'S JOB IMAGE?		;014
	BHI	20$		;NOT IN THE JOB IMAGE
	INC	(SP)		;Restore SP value back to real
	CMP	(SP),#FPPTXT+<6*4*2>+<2*2> ;WITHIN CONTEXT REGION?
	BLO	30$		;ERROR IF SO
	SUB	#2*2,(SP)	;O.K., BACK UP 2 WORDS
10$:	MOV	(SP),R1		;RETURN OLD STACK VALUE -4 HERE
	MTPD	SP		; AND GIVE A NEW STACK TO THE USER	;014

;+
; RTSPC - CLEARS THE CARRY AND RETURNS.
;-

$$RTSP	==	.	;**INIT** THE UNIVERSAL 'RTS PC'
RTSPC::	CLC			;INDICATE GOODNESS (C=0)
	RETURN			; AND EXIT

20$:	SUB	#2*2-1,(SP)	;BACK UP STACK BY 2 WORDS (remember DEC above)
	CMP	(SP),MAXHGH	;STILL WITHIN THE RUN-TIME SYSTEM?
	BLO	30$		;NO, ERROR
	CMP	(SP),#P.OFF-<2*2> ;IS IT WITHIN THE PSEUDO-VECTORS?
	BHI	30$		;ERROR IF SO
	MOV	JOBRTS,R1	;GET JOB'S RTS POINTER
	BIT	#PF.RW,R.FLAG(R1) ;RTS MUST BE R/W TO HAVE A SP STACK
	BNE	10$		; AND IT IS R/W, ALL O.K.
30$:	COM	(SP)+		;ERROR, POP USER SP VALUE
	;SEC			;C=1 FROM 'COM' ABOVE
	RETURN			;NOW EXIT WITH ERROR

.DSABL	LSB

GLOBAL	<MAXDLO,MAXHGH>

.SBTTL	SET SPECIFIED LEVEL 3 QUEUE BIT(S)

;+									;016
; L3QSET - SET L3Q BIT SPECIFIED					;016
;									;016
;	** ONLY CALLED FROM 2780 CODE **				;016
;									;016
;	CALL	L3QSET,R5						;016
;-									;016

L3QSET::MOV	R0,-(SP)	;Save R0				;016
	MOV	(R5)+,R0	;Match conventions			;016
	CALL	L3QSE0,R5	;Do it					;016
	MOV	(SP)+,R0	;Restore R0				;016
	RETURN	R5		; and exit				;016

;+									;016
; L3QSE0 - SET L3Q BIT SPECIFIED 					;016
;									;016
;	R0 = BYTE OFFSET IN HIGH BYTE					;016
;	     BIT IN LOW BYTE						;016
;									;016
;	CALL	L3QSE0,R5						;016
;-									;016

L3QSE0::MOV	R1,-(SP)	;Save R1				;016
	MOV	R0,R1		;Extract offset				;016
	CLRB	R1		;					;016
	SWAB	R1		;					;016
	BISB	R0,L3QUE(R1)	;Set the bits				;016
	MOV	(SP)+,R1	;Restore R1				;016
	RETURN	R5							;016

GLOBAL	<L3QUE>

.SBTTL	INDICATE A SP STACK OVERFLOW FOR USER

;+
; STKOVF - INDICATE USER SP STACK OVERFLOW.
;
;	R1 -> JOB DATA BLOCK @ JDFLG
;
;	CALL	STKOVF
;-

STKOVF::BIS	#JFSPCL,(R1)	;INDICATE SPECIAL CONDITION
	BISB	#JFSTAK,JDFLG2-JDFLG(R1) ; AS SP STACK OVERFLOW
	RETURN			;NOW EXIT

.SBTTL	MAP USER'S ADDRESS THROUGH DPAR6

;+
; SCRUMX - MAP USER'S "XRLOC" THROUGH DPAR6.
;
;	R3 -> XRB
;	CALLING JOB IS "JOB"
;
;	CALL	SCRUMX
;
;	R5 -> USER'S BUFFER THROUGH DPAR6
;-

SCRUMX::MOV	XRLOC(R3),R5	;GET USER'S VIRTUAL ADDRESS

;+
; SCRUMP - MAP USER'S VIRTUAL ADDRESS THROUGH DPAR6.
;
;	R5 -> USER'S BUFFER VIRTUALLY
;	CALLING JOB IS "JOB"
;
;	CALL	SCRUMP
;
;	R5 -> USER'S BUFFER THROUGH DPAR6
;		NOTE: THIS MAPS A USER D SPACE BUFFER IF I/D ARE
;			SEPERATED.  IT CAN NOT MAP AN I SPACE BUFFER
;			IF I/D ARE SEPERATED.
;-

SCRUMP::MOV	R4,-(SP)	;SAVE R4
	MOV	R5,-(SP)	; AND R5
	CLR	R4		;CLEAR A HIGH ORDER
	ASHC	#3,R4		; AND PUT APR NUMBER INTO IT
	ASL	R4		;NOW HAVE APR NUMBER TIMES 2
	ADD	UDPAR0,R4	;Now offset to the correct data APR	;032
	MAP	(R4),APR=6,DATA ;SET THE BASE MMU ADDRESS VALUE		;032
	CLR	R4		;CLEAR A HIGH ORDER AGAIN
	ASHC	#7,R4		; AND GET ADDITIVE DISPLACEMENT
	ADD	R4,@DPAR6	;  SO WE CAN ADD IT IN
	MOV	(SP)+,R5	;RESTORE VIRTUAL ADDRESS
	BIC	#^C<77>,R5	; AND ISOLATE THE LAST 6 BITS
	ADD	#140000,R5	;  THEN BIAS IT FOR APR6
	MOV	(SP)+,R4	;RESTORE R4
	RETURN			; AND EXIT

GLOBAL	<DPAR6,UDPAR0>							;032

.SBTTL	I/O COMPLETION POSTING

	TMPORG	SUB		;CLRBUF AND IOFIN4 CALLS REQUIRE D-SPACE
;+
; IOFINC - CHECK FOR POSTING I/O COMPLETION.
;
;	R1 -> DDB
;
;	CALL	IOFINC,R5,<BFQ.??-N.,JSBITS>
;
;	R4 =  RANDOM
;-


IOFINC::CMP	DDBUFC+BC(R1),(R5)+ ;SHOULD WE POST I/O COMPLETION?
	BLT	20$		;NOPE, EXIT SKIPPING THE 2ND ARGUMENT
	MOVB	DDJBNO(R1),R4	;YEP, GET THE OWNING JOB # *2
	BNE	10$		;JOB EXISTS, GO POST I/O COMPLETION
	CMP	DDBUFC+EP(R1),DDBUFC+FP(R1) ;NO JOB, IS THE CHAIN EMPTY??
	BNE	20$		;NOT EMPTY YET, JUST GO EXIT
	CALL	CLRBUF,R5,DDBUFC+EP ;EMPTY, RELEASE THE WHOLE CHAIN
10$:	JMP	IOFINI		;NOW GO EXIT (SLOWLY...)

20$:	TST	(R5)+		;DISCARD SECOND ARGUMENT
	RETURN	R5		; THEN EXIT

;+
; IOFIP4 - POST FIP COMPLETION.
;
;	R4 =  JOB# * 2
;
;	CALL	IOFIP4
;
; NOTE: R4 WILL BE RETURNED AS 0 IF THE JOB# * 2 WAS 1.
;-

IOFIP4::CALL	IOFIN4,R5,JSFIP	;AWAKEN A JOB FOR FIP
	RETURN			; AND RETURN
				;(THIS ROUTINE IS DOWN HERE SO THAT CTL
				; DOESN'T HAVE TO TRY AND DO A "CALL R5"
				; WITH AN IN-LINE ARGUMENT FROM I-SPACE.)
;+
; IOSYD4 - POST JS.SY COMPLETION.
;
;	R4 =  JOB# * 2
;
;	CALL	IOSYD4
;
; NOTE: R4 WILL BE RETURNED AS 0 IF THE JOB# * 2 WAS 1.
;-

IOSYD4::CALL	IOFIN4,R5,JS.SY	;AWAKEN A JOB FOR JS.SY			;026
	RETURN			; AND RETURN				;026
				;(THIS ROUTINE IS DOWN HERE SO THAT SYDLRG/PFBIO
				; DOESN'T HAVE TO TRY AND DO A "CALL R5"
				; WITH AN IN-LINE ARGUMENT FROM I-SPACE.)

	UNORG

;+
; IOFINI - POST I/O COMPLETION.
;
;	R1 -> DDB
;
;	CALL	IOFINI,R5,<JSBITS>
;
;	R4 =  JOB# * 2
;
; NOTE: R4 WILL BE RETURNED AS 0 IF THE JOB# * 2 WAS 1.
;-

IOFINI::MOVB	DDJBNO(R1),R4	;GET JOB# *2 FOR POSTING COMPLETION

;+
; IOFIN4 - POST I/O COMPLETION.
;
;	R4 =  JOB# * 2
;
;	CALL	IOFIN4,R5,<JSBITS>
;
; NOTE: R4 WILL BE RETURNED AS 0 IF THE JOB# * 2 WAS 1.
;-

IOFIN4::BIC	#^C<63.*2>,R4	;ENSURE VALID JOB# TIMES 2
	BEQ	30$		;NO JOB, JUST EXIT			;046
	MOV	R0,-(SP)	;Get one work register			;032
	MOV	R1,-(SP)	;And another one			;032
	MOV	R2,-(SP)	; Save a register			;046
	MOV	(R5),R2		;Get the bits to set.			;046
	MAP	PUSH,APR=6,DATA ;Save caller's APR6 mapping		;032
	MOV	R4,R0		;Copy job # * 2				;032
	CALLX	MAPJCR		;Map the JCR entry			;032	
	BIT	#JS.KB,R2	;WOULD THIS SET THE KEYBOARD BIT?	;046
	BEQ	10$		;NO, SO NO SPECIAL CASE CODE
	BIT	JBSTAT(R4),JBWAIT(R4) ;YES, JOB ALREADY RUNNABLE?
	BNE	10$		;NOTHING SPECIAL IF RUNNABLE
	BIT	R2,JBWAIT(R4)	;WOULD THIS MAKE THE JOB RUNNABLE?
	BEQ	10$		;WOULDN'T HELP, SO SKIP IT
	BISB	#1,JCPRI(R1)	;Boost the priority of the job		;032
10$:	BIS	R2,JBSTAT(R4)	;SET THE JSBIT(S) SUPPLIED TO US	;046
	CALL	PREMPT		; Decide if the scheduler needs to run	;047
20$:	MAP	POP,APR=6,DATA	;Restore mapping			;032
	MOV	(SP)+,R2	;Restore working registers		;046
	MOV	(SP)+,R1	;Restore one register			;032
	MOV	(SP)+,R0	;And another one			;032
30$:	TST	(R5)+		;SKIP THE ARGUMENT
	RETURN	R5		; THEN EXIT

GLOBAL	<JBSTAT,JBWAIT,JOBTBL>

.SBTTL	Asynchronous I/O Completion Posting

;+
; ASYDNE - Post asynchronous I/O completion				;021+
;
;	R0 =  Job number * 2
;	R4 -> ASYWRK block
;	
;	Error code in ASYWRK @ XRBUSE
;
;	CALL	ASYDNE
;
;-

.ENABL	LSB

ASYDNE::MOV	R1,-(SP)	;Get one work register			;032
	MOV	R2,-(SP)	; and another				;045
	MAP	PUSH,APR=6,DATA	;And save APR6 mapping			;032
	MOV	(R4),XRBUSE+2(R4) ;Save this word for queue link	;032
.ASSUME	XRLEN	EQ	0
	CALLX	MAPJCR		;Map the JCR entry for completing job	;032
	CLR	(R4)		;Clear the link to next			;032
	MOV	R4,@JCASTT(R1)	;Queue the block to the end of the list	;032
	MOV	R4,JCASTT(R1)	;And make it be the tail pointer	;032
	BISB	#1,JCPRI(R1)	;Give this job a priority boost		;032
	MOV	JOBTBL(R0),R2	;Pick up the pointer to the JDB
	BIS	#JFASTD,JDFLG(R2) ;I/O complete, ready for AST delivery
	BIS	#JSTIM,JBSTAT(R0) ;Awaken the job from sleep		;026
	BIT	#J41ASY,JDFLG4(R2) ;Is this a TUNE Asynch I/O?		;045
	BEQ	10$		; Yes, so leave well enough alone	;045
	BICB	#1,JCPRI(R1)	; No, so remove the boost		;045
	CMPB	R0,JOB		;  Are we the running job?		;045
	BNE	10$		;  No, so do normal checking		;046
	L3QSET	QSCHED		;  Since fake async, let others run	;046
	BR	20$		;  and don't bother checking		;046

10$:	CALL	PREMPT		;decide if the scheduler should run	;046
20$:	MAP	POP,APR=6,DATA	;Restore APR6 mapping			;032
	MOV	(SP)+,R2	;Restore this working register		;045
	MOV	(SP)+,R1	;Restore another work register		;032
	RETURN			; and return to a periwinkle sunset...	;026

.DSABL	LSB

GLOBAL	<JOBTBL,JBSTAT,JBWAIT>

.SBTTL	Decide if the scheduler should be run

PREMPT:	BIT	JBSTAT(R0),JBWAIT(R0) ;Are we runnable?
	BEQ	40$		;No, leave now
	TSTB	JOB		;Is someone running now?		;032
	BEQ	30$		;No, so get the scheduler going		;045
	BNE	40$		; Patch to NOP to enable preempt	;047
..PREM==.-2			;  patch point global			;047
	MOVB	JCPRI(R1),R2	; Yes, so save completing jobs priority	;046
	MAP	JOBJC6,APR=6,DATA ; and prepare to compare with JOBs	;046
	MOV	JOBJCR,R1	; Get the mapping pointer		;046
	MOVB	JCPRI(R1),R1	; and get the current JOBs priority	;046
	CMPB	R2,R1		; Is completing job higher?		;047
	BLE	40$		;  No, let current job complete		;047
	CMPB	R1,#-64.!7	;Is current JOB real LOW?		;046
	BLT	30$		;  Yes, dump it and schedule next job	;047
	CMPB	R2,#64.!7	;Is the completing job real high?	;047
	BLT	40$		;  No, so let current job complete	;046
30$:	L3QSET	QSCHED		;get the scheduler running		;046
40$:	RETURN			; and return to our caller		;046

.SBTTL	Check to see if a request is asynchronous

;+
; CHKASY - Check to see if a request is asynchronous
;
;	R0 = Job # * 2
;	R4 -> [A]synchronous work block
;
;	CALL	CHKASY
;
;	C = 0 If synchronous
;	C = 1 If asynchronous (simulated or real)
;
;	All registers are preserved.
;
; Note:	The code to check for real asynchronous I/O has been disabled.
;	At present this routine can only be used to check for simulated
;	asynchronous I/O. This is because MTDVR and MMDVR, which have
;	special handling for simulated asynchronous I/O, haven't been
;	checked to see if they preserve XRBCRA.
;-

CHKASY::MAP	PUSH,APR=6,DATA	;Save APR6 mapping			;032
	MOV	R1,-(SP)	;And save a register			;032

.REM	*
	BIT	#1,XRBCRA(R4)	;Is this an asynchronous request?	;032
	BNE	10$		;Yes, tell our caller			;032
*		
	CALLX	MAPJCR		;Map JCR entry for job			;032
	TST	JCASTS(R1)	;Simulated asynch I/O going on?		;032
	BEQ	20$		;No, C=0, all set			;032
10$:	SEC			;Tell our caller this is asynchronous	;032
20$:	MOV	(SP)+,R1	;Restore a register			;032
	MAP	POP,APR=6,DATA	;And caller's mapping			;032
	RETURN			;And we're done				;032

.SBTTL	SAVE THE CURRENT JOB

;+
; SAVJQX - SAVE CURRENT JOB WITHOUT CLEARING RESIDENCY QUANTUM.
;
;	CALLING JOB IS "JOB"
;
;	CALL	SAVJQX,R5
;
;	R0 =  RANDOM
;	R1 =  RANDOM
;	R2 =  RANDOM
;	R5 =  RANDOM
;
;	AR6 MAPPING DESTROYED.
;
;	THE SP STACK IS RESET.
;-

.ENABL	LSB

SAVJQX::MOV	JOBDA,R1	;GET JOB DATA POINTER
	BEQ	SAVJNL		;NULL JOB, PUNT
	CALL	FNDRSQ		;REAL JOB, FIND NEW RESIDENCY QUANTUM
	BR	10$		; THEN GO SAVE THE JOB


;+
; SAVJOB - SAVE CURRENT JOB AND CLEAR RESIDENCY QUANTUM.
;
;	CALLING JOB IS "JOB"
;
;	CALL	SAVJOB,R5
;
;	R0 =  RANDOM
;	R1 =  RANDOM
;	R2 =  RANDOM
;	R5 =  RANDOM
;
;	AR6 MAPPING DESTROYED.
;
;	THE SP STACK IS RESET.
;-

SAVJOB::MOV	JOBDA,R1	;GET JOB DATA POINTER
	BEQ	SAVJNL		;NULL JOB, PUNT
	CALL	CLRRSQ		;REAL JOB, CLEAR RESIDENCY QUANTUM
10$:	TST	(R1)+		;ADVANCE TO JOB FLAGS
	CALL	UNLOC0		;UNLOCK CURRENT JOB
	.BR	SAVJBL		;NOW SAVE THAT JOB

;+
; SAVJBL - SAVE CURRENT JOB WITHOUT UNLOCKING IT.
;
;	CALLING JOB IS "JOB" (MUST NOT BE NULL JOB)
;
;	R1 ->	JDB @ JDFLG
;
;	CALL	SAVJBL,R5
;
;	R0 =  RANDOM
;	R1 =  RANDOM
;	R2 =  RANDOM
;	R5 =  RANDOM
;
;	AR6 MAPPING DESTROYED.
;
;	THE SP STACK IS RESET.
;
;	NOTE THAT SAVJBL DOES NOT TOUCH THE JOB'S RESIDENCY QUANTUM; CALLER
;	SHOULD CALL FNDRSQ OR CLRRSQ OR THE EQUIVALENT BEFORE CALLING SAVJBL.
;-

SAVJBL::MOV	#SYSTAK-<8.*2>,SP ;RESET THE SP STACK
	MAP	@UDPAR0,APR=6,DATA ;MAP USER'S 1ST 4K THROUGH PAR6
	MOV	#CONTXT+140000,R0 ;GET CONTEXT AREA POINTER
	CLR	(R0)+		;START CHECKSUM AT ZERO
20$:	MOV	(SP)+,R2	;GET AN ITEM (R0-R5, PC, PS)
	MOV	R2,(R0)+	; AND SAVE IT AWAY
	ASL	R2		;SHIFT THE ITEM 1 PLACE LEFT
	ADC	R2		; AS A ROTATE LEFT
	XOR	R2,@#CONTXT+140000 ;  THEN .XOR. IT INTO THE CHECKSUM
	CMP	SP,#SYSTAK	;DOWN TO THE BASE SP STACK YET?
	BLO	20$		;NOPE, CONTINUE SAVING ITEMS
	COM	@#CONTXT+140000	;STORE THE CHECKSUM COMPLEMENTED
	SPLC	3		;Ensure previous mode = user		;030
	MOV	-2(R0),R2	;Is user's saved PSW, Super mode set?	;041
	BMI	25$		;No- leave as user mode in @#PS		;041
	BIC	#20000,@#PS	;yes, set PS prev mode to super mode	;041
25$:	MFPD	SP		;NOW STACK THE USER'S SP STACK VALUE	;014
	CMP	(SP),#FPPTXT	;WOULD WE CLOBBER USER'S STACK?
	BHIS	30$		;NO
	CALL	STKOVF		;YES, SIGNAL SP STACK OVERFLOW
30$:	MOV	(SP)+,(R0)	;NOW SAVE USER'S SP STACK VALUE
	CALL	@SAVFPP		;SAVE FPP CONTEXT IF ANY
	CALL	SAVTIM		;SAVE JOB TIMING INFORMATION
	.BR	SAVJNL		;NOW SET UP THE NULL JOB

.DSABL	LSB

GLOBAL	<SYSTAK,SAVFPP,UDPAR0>

;+
; SAVJNL - SET UP THE NULL JOB.
;
;	CALL	SAVJNL,R5
;
;	R2 =  RANDOM
;	R5 =  RANDOM
;
;	THE SP STACK IS RESET.
;-

.DSECT	JOBDA		;VERIFY ORDERING	[IF NULL JOB]

JOBDA:	.BLKW		;-> JDB			[0]
JOBF:	.BLKW		;-> JDB @ JDFLG		[->ZERO]
IOSTS:	.BLKW		;-> JDB @ JDIOST	[->JUNK]
JOBWRK:	.BLKW		;-> WRK			[0]
JOBJD2:	.BLKW		;-> JDB2		[->JUNK]
JOBRTS:	.BLKW		;-> RTS			[0]
CPUTIM:	.BLKW		;-> CPU TIME BUCKET	[->JUNK]
JOBWDB:	.BLKW		;-> WDB			[0]

	UNORG

SAVJNL::MOV	#SYSTAK,SP	;RESET STACK TO NULL JOB'S VALUE
	CLRB	JOB		;SET JOB TO 0 FOR NULL JOB
	CLR	@DIABOX		;CLEAR JOB NUMBER FOR DIAMOND
	MOV	#JOBDA,R2	;POINTER TO JOB PARAMETERS
	CLR	(R2)+		;SET JOBDA TO 0 FOR NULL JOB
	MOV	#ZERO,(R2)+	;SET JOBF TO ZERO VALUE FOR NULL JOB
	MOV	#JUNK,(R2)+	;SET IOSTS TO DUMMY LOCATION FOR NULL JOB
	CLR	(R2)+		;SET JOBWRK TO 0 FOR NULL JOB
	MOV	#JUNK,(R2)+	;SET JOBJD2 TO DUMMY LOCATION FOR NULL JOB
	CLR	(R2)+		;SET JOBRTS TO 0 FOR NULL JOB
	MOV	#JUNK,(R2)+	;SET CPUTIM TO DUMMY LOCATION FOR NULL JOB
	CLR	(R2)+		;SET JOBWDB TO 0 FOR NULL JOB
	MOV	#0,@#X.TAB+<<SEG.JH*XMTLEN>+XM.ADD> ; Reset JOBs	;046
				; header dumping APR pointer		;046
	L3QSET	QSCHED		;RUN THE SCHEDULER SOON
	JMP	(R5)		;NOW EXIT

GLOBAL	<SYSTAK,JUNK,DIABOX,X.TAB>					;046

.SBTTL	COLLECT JOB TIMING INFORMATION

;+
; SAVTIM - COLLECT JOB TIMING INFORMATION.
;
;	R1 -> JOB DATA BLOCK @ JDFLG
;	CALLING JOB IS "JOB"
;
;	CALL	SAVTIM
;-

SAVTIM::REGSCR			;SAVE ALL REGISTERS
	MOVB	JOB,R4		;GET JOB NUMBER TIMES 2
	TST	-(R1)		;BACK UP POINTER TO TOP OF JDB
.ASSUME	JDFLG	EQ	2
	CALL	CONNEC		;GO COMPUTE CONNECT TIME
	MOVB	JOB,R2		;Get job # times two again		;032
	MOV	JBTICK(R2),R5	;And get unconverted ticks		;032
	MOV	#60./10.,R0	;GET TICKS-TO-TENTHS DIVISOR
$$HZDV	==	.-2	;**INIT** SET TO FREQ/10.
	CLR	R4		;CLEAR A HIGH ORDER AND
	DIV	R0,R4		; FIND 1/10TH'S OF A SECOND
	MOV	R4,R3		;COPY THE ANSWER,
	MUL	R0,R3		; FIND THE UNDIVIDED TIME CHARGED,
	SUB	R3,JBTICK(R2)	;And update the uncharged time		;032
	MAP	PUSH,APR=6,DATA	;Save APR6 mapping			;032
	MAP	JOBJC6,APR=6,DATA ;And map caller's JCR entry		;032
	MOV	JOBJCR,R2	;Point to job's JCR entry		;032
	ADD	#JCCPU,R2	;And point to CPU time			;032
	ADD	R4,(R2)		;NOW ADD 10TH'S TO COLLECTED CPU TIME
	ADCB	JCCPUM-JCCPU(R2) ; WITH CARRY IF NEEDED			;032
	MOVB	JDSIZE-JDFLG(R1),R5 ;GET JOB'S CURRENT SIZE IN K
	MUL	R5,R4		;MULTIPLY FOR KCT'S
	ADD	R5,JCKCT-JCCPU(R2) ;ADD TO COLLECT KCT'S		;032
	ADC	R4		; AND CARRY IF NEEDED
	ADD	R4,JCKCTM-JCCPU(R2) ; NOW CARRY TO KCT MSB		;032
.ASSUME	JCKCTM&1	EQ	0
	MAP	POP,APR=6,DATA	;Restore APR6 mapping			;032
	RETURN			;NOW EXIT

GLOBAL	<JBTICK>							;032

.SBTTL	COLLECT CONNECT TIME

;+
; CONNEC - COMPUTE CONNECT TIME.
;
;	R1 -> JDB
;	R4 =  JOB NUMBER TIMES 2
;
;	CALL	CONNEC
;
;	R1 -> JDB+2
;	R2 -> JDB2
;	R3 -> CHANNEL #0 DDB
;	R4 =  RANDOM
;
;	C=1 IF JOB DETACHED
;-

CONNEC::MOV	JDJDB2(R1),R2	;GET JDB2 POINTER
	MAP	PUSH,APR=5,DATA	;Save APR5 mapping			;032
	MAP	PUSH,APR=6,DATA	;And APR6 mapping			;032
	MAP	FIPPOL		;Map FIP pool				;032
	MOV	@(R1)+,R3	;GET CHANNEL #0 DDB POINTER
.ASSUME	JDIOB	EQ	0
	MAP	POP,APR=6,DATA	;Restore APR6 mapping			;032
	MAP	POP,APR=5,DATA	;Restore APR5 mapping			;032
	.BR	CONNEX		;And calculate the connect time		;032

;+
; CONNEX - COMPUTE CONNECT TIME.
;
;	R3 -> DDB
;	R4 =  JOB NUMBER TIMES 2
;
;	CALL	CONNEX
;
;	R4 =  RANDOM
;
;	C=1 IF JOB DETACHED
;-

CONNEX::CMPB	R4,DDJBNO(R3)	;DOES JOB OWN THIS TERMINAL?
	BNE	20$		;NO, DETACHED, GO EXIT C=1
	BIT	#DDCONS,DDCNT(R3) ;IS IT REALLY THE CONSOLE TERMINAL??
	BEQ	20$		;NO, DETACHED, GO EXIT C=1
	MOV	R0,-(SP)	;Get one work register			;032
	MOV	R4,R0		;Copy job # * 2				;032
	MOV	DDTIME(R3),R4	;O.K., GET STARTING TIME
	MOV	TIME,DDTIME(R3)	; AND RESET THE STARTING TIME
	SUB	DDTIME(R3),R4	;NOW FIND THE ELAPSED TIME
	BPL	10$		;NO MIDNIGHT CORRECTION NEEDED
	ADD	#1440.,R4	; ELSE CORRECT FOR THROUGH MIDNIGHT
10$:	MOV	R1,-(SP)	;Get another work register		;032
	MAP	PUSH,APR=6,DATA	;Save caller's APR6 mapping		;032
	CALLX	MAPJCR		;Map this job's JCR entry		;032
	ADD	R4,JCCON(R1)	;Update the connect time		;032
	MAP	POP,APR=6,DATA	;Restore caller's mapping		;032
	MOV	(SP)+,R1	;Restore R1				;032
	MOV	(SP)+,R0	;Restore R0				;032
	TST	(PC)+		;SET C=0 AND SKIP THE 'SEC'
20$:	SEC			;SET C=1
	RETURN			;EXIT

.SBTTL	DEVICE NAME CHECKER

;+
; GUNSUB - CHECK PHYSICAL DEVICE NAME.
;
;	R4 -> FIRQB WITH NAME @ FQDEV/FQDEVN
;
;	CALL	GUNSUB,R5
;
;	R0 -> OFFSET TO "DEVNAM" TABLE ENTRY
;	R1 =  RANDOM
;	R2 =  UNIT NUMBER
;
;	FIRST EXIT MEANS THE DEVICE NAME IS INVALID
;
;	SECOND EXIT MEANS THE DEVICE NAME IS VALID
;		C=0 ALWAYS
;		IF Z=1 THEN NO EXPLICIT UNIT
;		IF Z=0 THEN EXPLICIT UNIT NUMBER
;-

GUNSUB::MOV	#DEVNAM-2,R0	;GET DEVICE NAME TABLE POINTER
	MOV	FQDEV(R4),R1	;GET THE SPECIFIED DEVICE NAME
	BEQ	10$		;=0 MIGHT MEAN "SY:"
	CMP	R1,#"TI		;IS IT "TI:"?
	BNE	20$		;NO					;047
	MOV	#DEVNKB,R0	;YES, FAKE POINTER TO FIND "KB:"
10$:	TST	FQDEVN(R4)	;UNIT EXPLICIT?
	BNE	50$		;YES, ERROR HERE
	MOV	(R0),R1		;GET THE FAKED DEVICE NAME
20$:	TST	(R0)		;END OF TABLE?
	BMI	50$		;YES, NOT FOUND, ERROR
	CMP	R1,(R0)+	;NO, DOES THIS MATCH?
	BNE	20$		;NO MATCH, CONTINUE...
	CMP	R0,#DEVSYN+2	;IS THIS AN ALTERNATE NAME?
	BLO	30$		;NO
	MOV	DEVOSN-2(R0),R0	;YES, GET THE REAL POINTER (+2)
30$:	MOV	FQDEVN(R4),R1	;GET UNIT NUMBER SPECIFICATION
	BNE	40$		;IT IS EXPLICIT
	CMP	R0,#DEVNKB+2	;NONE, WHAT KIND OF DEVICE?
	BHIS	40$		;NON-DISK, LEAVE AS UNIT 0
	MOV	#DEVNAM-2+2,R0	;DISK, FAKE "SY" NAME POINTER +2
40$:	MOVB	R1,R2		;ISOLATE THE UNIT NUMBER
	BMI	50$		;<0 IS AN ERROR
	SUB	#DEVNAM+2,R0	;MAKE POINTER RELATIVE
	CMP	R2,DEVCNT(R0)	;LEGAL UNIT NUMBER?
	BGT	50$		;NO, ERROR ALSO
	CMP	DEVNAM(R0),#"DV	;Is it Virtual Disk?			;047
	BNE	42$		;No- then nothing special		;047
	TST	@#CSR.DV	;yes- Is there one created?		;047
	BEQ	50$		;No-Not a valid device at this time	;047
42$:	CMP	R0,#DEVOKB	;Is unit a disk?			;035
	BLO	45$		;Yes, no special DDB check		;035
	MOV	DEVPTR(R0),-(SP) ;Non-disk, so get DDB pointer table	;035
	ADD	R2,(SP)		;Now point to unit DDB			;035
	ADD	R2,(SP)		; ...					;035
	CMP	#FAKDDB,@(SP)+	;Does unit point to the fake DDB?	;035
	BEQ	50$		;Yes, so pretend it isn't there		;035
45$:	TST	(R5)+		;YES, TAKE SECOND EXIT (VALID)
	TST	R1		;SET Z-BIT=1 IF NO EXPLICIT UNIT (& C=0)
50$:	RETURN	R5		; AND EXIT

GLOBAL	<DEVNAM,DEVNKB,DEVSYN,DEVOSN,DEVCNT,FAKDDB,DEVOKB,CSR.DV>	;043

.SBTTL	DEVICE GRABBERS/RELEASERS

;+
; GETDEV - TRY TO GRAB A DEVICE.
;
;	R1 -> DDB
;	CALLER IS IN FIP
;
;	CALL	GETDEV
;
;	IF Z=1 THEN DEVICE WAS ALREADY OWNED
;	IF Z=0 THEN DEVICE WAS JUST OBTAINED
;
;	-OR-
;
;	THE ERROR "NOTAVL"
;-

.ENABL	LSB

GETDEV::CMPB	DDJBNO(R1),FIJOB ;IS DEVICE ALREADY OWNED?
	BEQ	20$		;YES, JUST EXIT WITH Z=1
	TSTB	DDJBNO(R1)	;NO, IS DEVICE AVAILABLE?
	BNE	30$		;IN USE, SO ERROR
	BIT	#DDPRVO,(R1)	;OWNERSHIP REQUIRE PRIV'S?
	BEQ	10$		;NOPE, ANYONE CAN OWN IT
	TSTPRV	DEVICE,FIPRVM	;Privileged to grab device?		;023
	BEQ	30$		;No, so error				;011
10$:	MOV	#$ASNTBL,-(SP)	;SET UP FOR ASSIGNMENTS
	CALL	60$		;CALL DRIVER FOR ASSIGNMENTS
	TST	(SP)+		;DISCARD ARGUMENT
	;CLZ			;Z=0 FROM CALL ABOVE
20$:	RETURN			;NOW EXIT

30$:	ERROR	NOTAVL		;DEVICE NOT AVAILABLE

GLOBAL	<FIJOB,FIPRVM,$ASNTBL>

;+
; RETDEV - RETURN A DEVICE.
;
;	R1 -> DDB
;	CALLING JOB IS IN FIP
;
;	CALL	RETDEV
;
;	R2 =  RANDOM
;-

RETDEV::CMPB	DDJBNO(R1),FIJOB ;REALLY OWNED BY CALLER?
	BNE	50$		;NOPE
	BIC	#DDUTIL,DDCNT(R1) ;CLEAR THE UTILITY BIT
	BNE	50$		;STILL IS IN USE...
	MAP	PUSH,APR=6,DATA	;Save APR6 mapping			;032
	MAP	FIPJC6,APR=6,DATA ;Map job's JCR entry			;032
	MOV	FIPJCR,R2	;And point to it			;032
	MOV	DDTIME(R1),-(SP) ;GET TIME OWNERSHIP STARTED
	SUB	TIME,(SP)	;FIND ELAPSED TIME
	BPL	40$		;NO MIDNIGHT CORRECTION NEEDED
	ADD	#1440.,(SP)	; ELSE CORRECT FOR MIDNIGHT
40$:	ADD	(SP)+,JCDEV(R2)	;COLLECT DEVICE TIME			;032
	MAP	POP,APR=6,DATA	;Restore APR6 mapping			;032
	MOV	#$DEATBL,-(SP)	;SET UP FOR DEASSIGNMENT
	CALL	60$		;NOW CALL DRIVER FOR DEASSIGNMENT
	TST	(SP)+		;DISCARD ARGUMENT
	CLRB	DDJBNO(R1)	;FREE IT UP
50$:	RETURN			; AND EXIT

60$:	MOV	R0,-(SP)	;SAVE R0
	MOV	R2,-(SP)	; AND SAVE R2
	MAP	PUSH,APR=5,CODE,DATA ;AND SAVE PAR5
	MOVB	FIJOB,R0	;GET JOB NUMBER TIMES 2 OF ASSIGNER
	MOVB	(R1),R2		;GET DRIVER INDEX FROM DDB
	MAP	@DVRAP5(R2),APR=5,CODE,DATA ;SET DRIVER'S PAR5 VALUE
	ADD	12(SP),R2	;FIND TABLE ENTRY FOR THIS DRIVER
	CALL	@(R2)+		; AND CALL THE DRIVER
	MAP	POP,APR=5,CODE,DATA ;RESTORE PAR5
	MOV	(SP)+,R2	; AND RESTORE R2
	MOVB	R0,DDJBNO(R1)	;SET JOB NOW OWNING THE DEVICE
	MOV	(SP)+,R0	; THEN RESTORE R0
	CLR	DDCNT(R1)	;SET ACCESS CONTROL TO ZERO
	BIC	#DDSTAT,(R1)	;ALWAYS CLEAR THIS STATUS BIT
	MOV	TIME,DDTIME(R1)	;RESET TIME OWNED
	;CLZ			;EXIT Z=0 SINCE TIME IS NEVER ZERO
	RETURN			;NOW EXIT

.DSABL	LSB

GLOBAL	<FIJOB,FIJBDA,$DEATBL,DVRAP5,FIPJC6,FIPJCR>			;032

.SBTTL	CHECK FOR UNIQUENESS

;+
; CCLCHK - CHECKS CCL TABLE AGAINST THE PASSED STRING.
;
;	R5 -> STRING TO CHECK
;		NOTE: CALLER MUST ENSURE ASCIZ STRING WITH NO PARITY BITS
;		SINCE CCL COMMANDS IN BUFFERS END WITH 377, A MISMATCH
;		IS GUARANTEED.
;
;	CALL	CCLCHK
;
;	R0 -> BUFFER WITH CCL COMMAND AND FILE
;	R1 -> LINK WORD OF PREVIOUS COMMAND IN CHAIN
;	R2 -> CHARACTER IN BUFFER TERMINATING SCAN
;	R5 -> CHARACTER IN PASSED STRING TERMINATING SCAN
;
;	IF Z=0 THEN SUCCESSFUL
;	IF Z=1 THEN UNSUCCESSFUL
;-

CCLCHK::MOV	#CCLLST,R0	;POINT TO HEAD OF CHAIN
	.BR	UNQCHK		; AND CHECK IT

GLOBAL	<CCLLST>

;+
; UNQCHK - CHECK STRING AGAINST ANY TABLE.
;
;	R0 -> ROOT OT TABLE TO USE
;	R5 -> STRING TO CHECK
;
;	CALL	UNQCHK
;
;	R0 -> BUFFER WITH COMMAND
;	R1 -> LINK WORD OF PREVIOUS COMMAND IN CHAIN
;	R2 -> CHARACTER IN BUFFER TERMINATING SCAN
;	R5 -> CHARACTER IN PASSED STRING TERMINATING SCAN
;
;	IF Z=0 THEN SUCCESSFUL
;	IF Z=1 THEN UNSUCCESSFUL
;-

UNQCHK::MOV	R5,-(SP)	;SAVE RESTART POINT
10$:	MOV	(SP),R5		;REFRESH R5
	MOV	R0,R1		;SAVE POINTER TO PREVIOUS LINK WORD
	MOV	(R1),R0		;POINT TO NEXT COMMAND BLOCK
	BEQ	30$		;OOPS
	MOV	FQJOB(R0),R2	;POINT TO ACTUAL COMMAND STRING
20$:	CMPB	(R2)+,(R5)+	;MATCH?
	BEQ	20$		;YES, GO ON
	CMP	R2,FQFIL(R0)	;NO, ARE WE PAST POINT OF UNIQUENESS?
	BLOS	10$		;NO, TRY AGAIN
	CMPB	-(R2),-(R5)	;YES, BACK UP POINTERS
30$:	MOV	R0,(SP)+	;PURGE OLD R5, SET OR CLEAR Z-BIT
	RETURN			; NOW EXIT

.SBTTL	Check job's privileges

;+									;011
; CHKPRV - Check privileges for a given job				;011
;									;011
;	R0 =	Job number * 2						;011
;									;011
;	CALLX	CHKPRV,R4						;011
;	 .BPRIV	<priv to check>						;013
;									;011
;	C = 0	if job is privileged					;011
;	C = 1	if not							;011
;									;011
;	R5	Random							;011
;-									;011

CHKPRV::MOV	(R4)+,R5	;Get privilege word			;011
	.BR	CHKPR5		; and check it				;011

;+									;011
; CHKPR5 - Check privileges for a given job				;011
;									;011
;	R0 =	Job number * 2						;011
;	R5 =	Privilege code (low byte = offset, high byte = mask)	;011
;									;011
;	CALLX	CHKPR5,R4						;011
;									;011
;	C = 0	if job is privileged					;011
;	C = 1	if not							;011
;									;011
;	All registers preserved						;011
;-									;011

CHKPR5::REGSAV			;Save those registers			;011
	MAP	PUSH,APR=6,DATA	;And APR6 mapping			;032
	CALLX	MAPJCR		;Map this job's JCR entry		;032
	CLR	R2		;Avoid sign extension			;011
	BISB	R5,R2		; and get the byte offset value		;011
	SWAB	R5		;Bring mask into low byte		;011
	ADD	R1,R2		;Offset into beginning of JCR entry	;032
	ADD	#JCPRIV,R2	;Now point to the mask itself		;032
	BITB	R5,(R2)		;Have privilege?			;032
	BEQ	20$		;No, so stop right now			;011
	TST	JCALPP(R1)	;Have alternate privileges?		;032
	BEQ	10$		;None, so nothing left to check		;011
	ADD	#JCALPV-JCPRIV,R2 ;Point at mask portion		;032
	BITB	R5,(R2)		;Check 3rd party's privileges		;011
	BEQ	20$		;No privileges, indicate that		;011
10$:	TST	(PC)+		;Clear carry, skip next line		;011
20$:	SEC			;Indicate no privileges			;011
	MAP	POP,APR=6,DATA	;Restore mapping			;032
	REGRES			;Restore registers			;011
	RETURN	R4		;Done					;011

GLOBAL	<JOBTBL>							;011

.SBTTL	Look for a file in the permanent file list

SCNPRM::								;023
SCNPRU::SEC			;Dummy routine				;023
	RETURN			;Return saying "nothing installed"	;023

.REM	\								;023
;+									;015
; This routine looks for an entry in the permanent file list given	;015
; a FIRQB with a filespec in it.  SCNPRM uses the device name from	;015
; the FIRQB; SCNPRU uses a FIP unit number passed as an argument	;015
;									;015
; Entry:								;015
;	R0 =	FIP unit number to check for if SCNPRU			;015
;	R4 ->	FIRQB							;015
;			FQPPN, FQNAM1, FQEXT = name to find		;015
;			FQDEV, FQDEVN = device to find if SCNPRM	;015
;	FIUSER	PPN to look for if FQPPN= 0				;015
;									;015
; Exit:									;015
;	C = 0	Entry found						;015
;	R2 =	Contorted address of previous buffer, 0 if first	;015
;	R4 =	Contorted address of same				;015
;									;015
;	C = 1	Not found						;015
;	R2,4	Random							;015
;-									;015

.ENABL	LSB								;015

SCNPRM::MOV	R0,-(SP)	;Save a register			;015
	MOV	R1,-(SP)	;Save R1 for a moment			;015
	CALL	GUNSUB,R5	;Identify that device			;015
10$:	 CRASH			;That's not supposed to fail!		;015
	CMP	R0,#DEVOKB	;Disk?					;015
	BGE	10$		;No, that's not supposed to be either	;015
	ASL	R2		;Form unit * 2				;015
	ADD	DEVPTR(R0),R2	;Make it a UNTCNT table address		;015
	SUB	#UNTCNT,R2	;Now a FUN * 2				;015
	ASR	R2		; now * 1				;015
	MOV	R2,R0		;Move to the right place		;015
	MOV	(SP)+,R1	;Restore R1 again			;015
	BR	20$		;Merge with common code			;015

SCNPRU::MOV	R0,-(SP)	;Save R0				;015
20$:	MOV	R3,-(SP)	; and R3				;015
	MAP	PUSH,DATA,APR=6	;  and APR6 mapping			;015
	MOV	R0,-(SP)	;Save the FIP unit number desired	;015
	MOV	FQPPN(R4),-(SP)	;Get PPN to find			;015
	BNE	30$		;There was one				;015
	MOV	FIUSER,(SP)	;Otherwise use FIP's			;015
30$:	MOV	R4,R0		;Copy FIRQB pointer			;015
	CLR	R2		;Indicate no previous			;015
	MOV	PRMLST,R4	;Get first entry			;015
	BR	50$		;Enter the loop				;015

40$:	MOV	R4,R2		;Save address of this buffer		;015
	MOV	(R3),R4		;Get link to next block			;015
50$:	SEC			;Assume there isn't one			;015
	BEQ	60$		;That's right, exit failing		;015
	CALL	MAPBUF		;Map that buffer			;015
	CMPB	F$UNT(R3),2(SP)	;Same unit?				;015
	BNE	40$		;No					;015
	CMP	F$PPN(R3),(SP)	;Same PPN?				;015
	BNE	40$		;No					;015
	CMP	F$NAM(R3),FQNAM1(R0) ;Name match?			;015
	BNE	40$		;No					;015
	CMP	F$NAM+2(R3),FQNAM1+2(R0) ;Both halves?			;015
	BNE	40$		;No					;015
	CMP	F$NAM+4(R3),FQEXT(R0) ;Extension too?			;015
	BNE	40$		;No					;015
	;CLC			;Indicate success (C=0 from CMP)	;015
60$:	BIT	(SP)+,(SP)+	;Pop FIP unit number, don't touch C	;015
	MAP	POP,DATA,APR=6	;Restore APR6 mapping			;015
	MOV	(SP)+,R3	;Restore R3				;015
	MOV	(SP)+,R0	; and R0				;015
	RETURN			;Done					;015

.DSABL	LSB								;015
\									;023

GLOBAL	<DEVOKB,DEVPTR,UNTCNT,FIUSER,PRMLST>				;015

.SBTTL	CONVERT DCN'S TO FBN'S

;+
; CNVDCN - CONVERT DCN TO FBN USING FIPUNT.
;
;	R2 =  DCN
;	FIPUNT = FIP UNIT NUMBER
;
;	CALL	CNVDCN
;
;	R2 =  FIP BLOCK NUMBER (LSB)
;	R3 =  FIP BLOCK NUMBER (MSB)
;-

CNVDCN::MOVB	FIPUNT,R3	;GET UNIT NUMBER

;+
; CNVDC3 - CONVERT DCN TO FBN.
;
;	R2 =  DCN
;	R3 =  FIP UNIT NUMBER
;
;	CALL	CNVDC3
;
;	R2 =  FIP BLOCK NUMBER (LSB)
;	R3 =  FIP BLOCK NUMBER (MSB)
;-

CNVDC3::MOV	R0,-(SP)	;GET A WORKING REGISTER
	ASL	R3		;GET FIP UNIT NUMBER TIMES 2 TO
	CLR	R0		;avoid sign extension			;039
	BISB	DEVCLU(R3),R0	; GET THE DEVICE CLUSTER SIZE (DCS)	;039
	MOV	R2,R3		;CHECK DCN FOR TRUE ZERO
	BEQ	20$		;DCN = 0, SO EXIT FBN = 0
	DEC	R2		;DCN <> 0, SO FIND (DCN-1)
	MUL	R0,R2		;GET (FBN-1) = ( DCS * (DCN-1) )
	BPL	10$		;IF POSITIVE THEN RESULT O.K.
	ADD	R0,R2		; ELSE ADD MULTIPLIER TO HIGH ORDER
10$:	MOV	R2,R0		;EXCHANGE THE
	MOV	R3,R2		; LOW AND
	MOV	R0,R3		;  HIGH ORDERS
	ADD	#1,R2		;FBN =
	ADC	R3		; ( DCS * (DCN-1) ) +1
20$:	MOV	(SP)+,R0	;RESTORE WORKING REGISTER
	RETURN			; AND EXIT

GLOBAL	<FIPUNT,DEVCLU>

.SBTTL	ADD ENTRY TO MEMORY CONTROL LIST

;+
; ADDMEM - ADD ENTRY TO MEMORY CONTROL LIST.
;
;	R0 -> PREVIOUS ENTRY @ +M.PNXT
;	R3 =  NEW ENTRY'S LOAD ADDRESS (M.PHYA VALUE)
;	R4 -> NEW ENTRY
;
;	CALL	ADDMEM
;
;	R0 -> PREVIOUS ENTRY @ +M.TSIZ
;	R3 =  NEW ENTRY'S TOTAL SIZE IN K (M.TSIZ'S VALUE)
;-

.DSECT			;VERIFY ORDER OF MEMORY CONTROL AREA

M.PPRV:	.BLKW		;POINTER TO PREVIOUS @+2
M.PNXT:	.BLKW		;POINTER TO NEXT
M.TSIZ:	.BLKW		;TOTAL SIZE IN K
M.SIZE:	.BLKB		;IN USE SIZE IN K
M.CTRL:	.BLKB		;CONTROL BYTE
M.PHYA:	.BLKW		;PHYSICAL ADDRESS /100

	UNORG

ADDMEM::MOV	R3,M.PHYA(R4)	;SET ADDRESS AS SPECIFIED
	CMP	(R4)+,(R4)+	;NOW INDEX TO M.TSIZ IN ENTRY
.ASSUME	M.TSIZ	EQ	4
	SUB	M.PHYA-M.PNXT(R0),R3 ;SIZE OF NEW ENTRY IS
	ASH	#6.-11.,R3	; SIZE OF PREVIOUS AREA MINUS
	BIC	#174000,R3	;Account for the sign bit		;025
	NEG	R3		;  THE ADDRESS DIFFERENCE
	ADD	M.TSIZ-M.PNXT(R0),R3 ;   CONVERTED TO A K DIFFERENCE
	MOV	R3,(R4)		;TOTAL SIZE IS WHAT WE JUST CALCULATED
	MOV	(R0)+,-(R4)	;SET NEXT PTR @ M.PNXT
	MOV	R4,@-(R0)	;SET OUR +2 INTO THE NEXT
	MOV	R0,-(R4)	;SET PREV+2 @ M.PPRV
	MOV	R4,(R0)+	;SET OUR ADDR INTO PREV @ +2
	SUB	R3,(R0)		;NOW LOWER THE TOTAL SIZE OF PREVIOUS
	RETURN			;ALL DONE

.SBTTL	GET RID OF A BAD RTS/LIB IMAGE

;+
; BADRTS - RTS/LIB IMAGE IS BAD, SWITCH TO SYSTEM DEFAULT KBM.
;
;	R0 = Job # * 2
;	R1 -> JOB DATA BLOCK @ JDFLG
;	R2 -> BAD RTS/LIB BLOCK
;
;	CALL	BADRTS
;-

BADRTS::REGSCR			;SAVE ALL REGISTERS
	MAP	PUSH,APR=6,DATA	;Save APR6 mapping			;032
	BIC	#100000,R.CNT(R2) ;THE RTS/LIB ALWAYS GETS /STAY TAKEN AWAY
	CALLX	MAPJCR		;Map this job's JCR entry		;032
	CMP	R2,JCDRTS(R1)	;USING BAD RTS AS PRIVATE DEFAULT?	;032
	BNE	10$		;NO
	MOV	DEFKBM,JCDRTS(R1) ;YES, TRY SWITCH TO DEFAULT KBM	;032
	CMP	R2,DEFKBM	;WAS THE BAD RTS THE DEFAULT KBM?
	BNE	10$		;NO, SO DEFAULT KBM MAY BE OK
	MOV	RTSLST,JCDRTS(R1) ;YES, SO TRY SWITCH TO SYSTEM DEFAULT RTS ;032
	MOV	RTSLST,DEFKBM	;AND MAKE THE DEFKBM BE THE SYS DEF RTS
10$:	MOV	R1,-(SP)	;Save pointer to JCR entry		;032
	MOV	TOS.R1+4(SP),R1	;Restore JDB @ JDFLG pointer		;032
	CMP	R2,JDRTS-JDFLG(R1) ;USING THE BAD RTS/LIB NOW?
	BEQ	40$		;YES, INDICATE SPECIAL CONDITION
	MOV	R2,R3		;SAVE POINTER TO BAD RTS/LIB BLOCK
	CALL	LIBSUB,R5	;RETURNS WITH ALL MAPPED LIBRARIES
	  BR	20$		;CHECK FOR USING THIS LIB
	TST	(SP)+		;Not using library, dump JCR pointer	;034
	BR	50$		;And join up				;034	

20$:	CMP	R3,R2		;USING THE BAD LIB BLOCK NOW?
	BEQ	30$		;YES, INDICATE SPECIAL CONDITION
	RETURN			;NO, BACK TO CO-ROUTINE

30$:	ADD	#2,(SP)		;Set up for special co-routine exit	;032
	CALL	@(SP)+		;And request it				;032
	;MOV	R3,R2		;RESTORE POINTER TO BAD LIB
40$:	BIS	#JFSPCL,(R1)	;INDICATE SPECIAL CONDITION
	BISB	#JFSWPR,JDFLG2-JDFLG(R1) ; AS RUN-TIME SYSTEM/LIB LOAD FAILURE
	MOV	(SP)+,R0	;Get job's JCR pointer			;032
	MOV	JCDRTS(R0),R3	;GET JOB'S PRIVATE DEFAULT RTS
	CALL	SWRTS		; AND SWITCH JOB TO PRIVATE DEFAULT RTS
50$:	MAP	POP,APR=6,DATA	;Restore APR6 mapping			;032
	MOV	TOS.R2(SP),R2	;GET BAD RTS/LIB POINTER AGAIN
	BR	REMRTS		; AND REMOVE IT FROM MEMORY LIST

GLOBAL	<RTSLST,DEFKBM>

.SBTTL	SWITCH AND REMOVE RUN-TIME SYSTEMS

;+
; SWRTS - SWITCH RUN-TIME SYSTEMS REMOVING ANY LIBRARIES.
; SWRTSL - SWITCH RUN-TIME SYSTEMS KEEPING LIBRARIES.
;
;	R1 -> JOB DATA BLOCK @ JDFLG
;	R3 -> NEW RUN-TIME SYSTEM DESCRIPTION BLOCK
;
;	CALL	SWRTS
;	CALL	SWRTSL
;
;	R0 =  RANDOM
;	R2 =  RANDOM
;-

SWRTS::	CALL	RETWDB		;DETACH FROM LIBRARIES & RETURN WDB BLOCKS
SWRTSL::MOV	JDRTS-JDFLG(R1),R2 ;GET CURRENT (OLD) RTS POINTER
	MOV	R3,JDRTS-JDFLG(R1) ; THEN SWITCH TO NEW RTS
	MOVB	JDJBNO-JDFLG(R1),R0 ; Get job # * 2			;037
	CALLMI	SETMDE,GENAP5	;And re-calculate the job's MDEs	;037
	MOV	(PC)+,R0	;GUESS AT JOB IMAGE RESIDENT
	 .BYTE	1,1
	CMPB	#OUT,JDMCTL+M.CTRL-JDFLG(R1) ;GOOD GUESS?
	BEQ	5$		;No, its non-resident			;048
	CMPB	#SWP!IN!MC.LCK,JDMCTL+M.CTRL-JDFLG(R1) ;Starting in?	;048
	BNE	10$		; No, so already resident		;048
5$:	MOVB	R0,R0		;JOB IMAGE IS NON-RESIDENT
10$:	ADD	R0,R.CNT(R3)	;CORRECT COUNT(S) IN NEW RTS
	SUB	R0,R.CNT(R2)	;CORRECT COUNT(S) IN OLD RTS
	BNE	GSGMEM		;STILL ARE OTHER USER(S)
	BIT	#PF.REM,R.FLAG(R2) ;DESIRE A MEMORY REMOVE?
	BEQ	GSGMEM		;NO

;+
; REMRTS - REMOVE A RUN-TIME SYSTEM OR RESIDENT LIBRARY FROM MEMORY CONTROL LIST.
;
;	R2 -> RTS/LIB DESCRIPTION BLOCK
;
;	CALL	REMRTS
;
;	R0 =  RANDOM
;	R2 =  RANDOM
;
; Note: If this is a dynamic region, the dynaimic region will be removed  ;018
; from LIBLST and returned to the buffer pool.				  ;018
;-

REMRTS::CMPB	#MC.LCK,R.MCTL+M.CTRL(R2) ;Simply in memory?		;020
	BNE	GSGMEM		;It's not, forget it			;020
	MOVB	#LS.LIB!LS.DYN,R0 ;R0 = Flags set in dynamic region	;018
	BICB	L.STAT(R2),R0	;Is this a dynamic region?		;018
	BNE	20$		;No, not this time			;018
	MOV	R4,-(SP)	;Yes, get a work register		;018
	MOV	R2,-(SP)	;Save pointer to LIB block		;018
	CALL	20$		;And remove it from MEMLST		;018
	MOV	(SP)+,R4	;R4 -> LIB block to remove		;018
	MOV	#LIBLST,R0	;R0 -> Library list			;018
10$:	CMP	(R0),R4		;Are we at the library to remove?	;018
	BEQ	15$		;Yes, we sure are			;018
	MOV	(R0),R0		;Get the link to next			;018
	BR	10$		;And loop for the whole list		;018
15$:	MOV	(R4),(R0)	;Un-link this library from the list	;018
	BUFFER	RETSML		;Return the LIB block to the pool	;018
	MOV	(SP)+,R4	;Restore our work register		;018
	RETURN			;And we're done				;018

20$:	ADD	#R.MCTL,R2	;O.K., INDEX TO MEMORY CONTROL		;018
	.BR	BYERTS		; AND GET RTS/LIB OUT OF MEMORY LIST

GLOBAL	<LIBLST>

.SBTTL	REMOVE ENTRIES FROM MEMORY CONTROL LIST

;+
; BYERTS - REMOVE A RUN-TIME OR RESIDENT LIBRARY SYSTEM FROM MEMORY CONTROL LIST.
;
;	R2 -> MEMORY CONTROL AREA IN RTS/LIB (R.MCTL)
;
;	CALL	BYERTS
;
;	R0 -> PREVIOUS MEMORY LIST ENTRY @ +M.PNXT
;-

.ENABL	LSB

BYERTS::BIT	#PF.SLA,R.FLAG-R.MCTL(R2) ;SAVE THE LOAD ADDRESS?
	BNE	30$		;YES
	BR	20$		;NO

;+
; REMJOB - REMOVE A JOB FROM MEMORY CONTROL LIST.
;
;	R2 -> MEMORY CONTROL AREA IN JDB (JDMCTL)
;
;	CALL	REMJOB
;
;	R0 -> PREVIOUS MEMORY LIST ENTRY @ +M.PNXT
;-

10$:	DECB	R.CNT+1(R2)	;MARK AS HAVING ONE LESS RESIDENT
	RETURN			;BACK TO CO-ROUTINE

REMJOB::MOV	JDRTS-JDMCTL(R2),R0 ;GET POINTER TO JOB'S CURRENT RTS
	DECB	R.CNT+1(R0)	; AND SAY 1 LESS RESIDENT IMAGE NOW
	MOVB	JDJBNO-JDMCTL(R2),R0 ;Get jobs job # * 2		;032
	MOV	R2,-(SP)	;SAVE MEMORY CONTROL LIST POINTER
	CALL	LIBSUB,R5	;RETURNS WITH ALL MAPPED LIBRARIES
	  BR	10$		;GO DECREMENT MAPPED RESIDENT COUNT
	MOV	(SP)+,R2	;DONE, RESTORE POINTER TO MEMORY CONTROL AREA
20$:	CLR	M.PHYA(R2)	;SAY NEXT RESIDENCY CAN BE ANYWHERE
30$:	MOV	(R2)+,R0	;GET PREV POINTER @+2
	MOV	R0,@(R2)+	;LINK NEXT TO OUR PREV
	ADD	(R2),M.TSIZ-M.PNXT(R0) ;COLLECT TOTAL SIZE IN PREV
	MOV	-(R2),@-(R2)	;LINK PREV TO OUR NEXT
	MOVB	#OUT,M.CTRL(R2)	;THIS ENTRY IS NOW NON-RESIDENT		;020
GSGMEM:	JMP	SIGMEM		;NOW EXIT SIGNALING MEMORY MANAGER	;020

.DSABL	LSB

.SBTTL	TRY TO FIND A JOB

;+
; FNDJOB - TRY TO FIND A JOB FOR I/O OPERATIONS.
;
;	R0 =  JOB NUMBER TIMES 2 OF JOB TO FIND
;	R3 =  LEVEL 3 QUEUE BIT(S) TO SET ON RESIDENCY
;	R5 =  USER'S VIRTUAL BUFFER ADDRESS
;
;	CALL	FNDJOB
;
;	R2 =  PHYSICAL BUFFER ADDRESS BITS <21-16>
;	R3 =  PHYSICAL BUFFER ADDRESS BITS <15-0>
;	R5 -> USER'S BUFFER THROUGH "DPAR6"
;	DPAR6 MAPS THE USER'S BUFFER
;		IF SEPRATE I/D EXIST, THE BUFFER MUST BE IN THE USERS D SPACE
;		Looks for phys address in D space unless I&D off, then I space
;
;	FIRST EXIT MEANS JOB HAS JOB IMAGE/RTS SWAP/LOAD ERROR(S)
;
;	SECOND EXIT MEANS JOB IMAGE/RTS ALL O.K.
;
;	If C=0 then JOB/RTS and possible LIBs are resident and locked	;042
;	If C=1 then one of the above is not resident 			;042
;		If Z = 0 then JOB was resident (RTS or LIB were not)	;042
;		If Z = 1 then JOB was not resident			;042
;-

FNDJOB::MOV	JOBTBL(R0),R2	;GET JOB DATA POINTER
	BITB	#JFSWPR!JFSWPE,JDFLG2(R2) ;ANY SWAP/RTS ERRORS?
	BNE	60$		;YES, TAKE THE 1ST EXIT
	ADD	#2,(SP)		;NO, TAKE THE 2ND EXIT
	CALL	RESCHK		;CHECK FOR JOB RESIDENCY
	BCC	3$		;All pieces required are memory resident ;042
	BITB	#^C<LCK>,JDMCTL+M.CTRL(R2) ;Something is not resident,	;042
					   ;....was it the job itself?	;042
	BNE	2$		;Yes, request residency			;042
	CALL	RESJOB		;Request residency for RTS or LIB	;042
	;SEC			;  C = 1 on return from RESJOB		;042
	CALL	3$		;Map user's buffer			;042
	SEC			;Reset the residency failure flag	;042
	CLZ			;... but indicate the job was resident	;042
	BR	60$		;Return to the caller			;042

2$:	CALL	RESJOB		;Request residency for the job		;042
	;SEC			;  C = 1 on return from RESJOB		;042
	SEZ			;Indicate the job itself was not resident ;042
	BR	60$		;Return to the caller			;042

3$:	MOV	R0,-(SP)	;save job#*2				;040
	MOV	R4,-(SP)	;RESIDENT, SAVE R4			;020
	MOV	R1,-(SP)	;And R1					;032
	MOV	R2,R4		;COPY JOB DATA POINTER TO HERE
	ADD	#<MC.LCK*400>,JDMCTL+M.SIZE(R4) ;Lock the job in memory	;020
.ASSUME	M.CTRL	EQ M.SIZE+1						;020
	BCS	70$		;Overflowed the LCK field, crash!	;020
	CALLX	MAPJCR		;Map caller's JCR entry	<-R1		;032	
	MOV	R5,R3		;copy of virtual address		;040
	ASH	#-13.,R3	;shift APR # into bits <0:2>		;040+
	BIC	#^C<7>,R3	;mask to just APR bits
	MOV	R1,R4		;copy the JCR pointer
	ADD	#<JCMDE+MOUSRI>,R4 ; R4-> user I MDE's
	BIT	#JM.UDS,JCMFLG(R1) ; is I&D hardware on?
	BEQ	10$		;no, correct in using I MDE's
	ADD	#<8.*MDSIZE>,R4	;yes, so point to user D-space MDE's
.assume	MOUSRD	EQ	<MOUSRI+<8.*MDSIZE>>
10$:	MUL	#MDSIZE,R3	; R3=mdsize * APR#=offset into MDE
	ADD	R3,R4		;R4->proper MDE for virtual address
	BIT	#6,MDDESC(R4)	;is it mapped (access bits active)?
	BEQ	70$		;no, Crash, this never happens
.ASSUME	MDADDR	EQ	0	;Make sure MDE is as expected
.ASSUME	MDOFF	EQ	MDADDR+2
.ASSUME	MDDESC	EQ	MDOFF+2
.ASSUME MDSIZE	EQ	MDDESC+2
	MOV	R5,R0		;copy of virtual address again		;040-	
	BIC	#^C<77>,R0	; AND ISOLATE THE BYTE OFFSET		;040
	CLR	R2		;CLEAR MMU ADDRESS HIGH ORDER
	;CLC			;C=0 FROM 'CLR' ABOVE
	BIC	#160000,R5	;clear out the APR bits from virtual	;040
	ROR	R5		;NOW FIND VIRTUAL
	ASH	#-6+1,R5	; ADDR/100 (NO SIGN EXTEND...)
	MOV	@(R4)+,R3	;get phys base address for this APR	;040
	ADD	(R4),R3		;add in this APR's offset from base	;040
	ADD	R5,R3		;ADD block # TO MMU ADDRESS
	MAP	R3,APR=6,DATA	;SET THAT AS THE BUFFER WINDOW
	ASHC	#6,R2		;NOW FIND THE PHYSICAL ADDRESS
	MOV	R0,R5		;GET BACK THE BYTE OFFSET		;040
	ADD	R5,R3		;ADD IT TO THE PHYSICAL ADDRESS
	ADD	#140000,R5	;THEN MAKE IT A PAR6 WINDOW POINTER
50$:	MOV	(SP)+,R1	;Restore R1				;032
	MOV	(SP)+,R4	;RESTORE R4
	MOV	(SP)+,R0	;Restore R0				;040
	;CLC			;C=0 FROM THE 'ADD' ABOVE
60$:	RETURN			;NOW EXIT

70$:	CRASH			;Illegal M.CTRL byte count		;020

80$:	SUB	#2,6(SP)	;Set up for the first exit		;032
	BR	50$		;And go take it

GLOBAL	<JCMDE,JCMFLG>


.SBTTL	CHECK FOR JOB RESIDENCY

;+
; RESCHK - CHECK TO SEE IF A JOB IS NOW RESIDENT.
;
;	R2 -> JOB'S JOB DATA BLOCK
;
;	CALL	RESCHK
;
;	IF C=0 THEN JOB IS RESIDENT
;	IF C=1 THEN JOB IS NON-RESIDENT (OR ELSEWISE BUSY)
;-

.ENABL	LSB

RESCHK::BITB	#^C<LCK>,JDMCTL+M.CTRL(R2) ;IS JOB RESIDENT AND FREE?	;020
	BNE	30$		;NO, GO EXIT C=1
	REGSCR			;SAVE ALL REGISTERS
	CALL	RTSSUB,R5	;GET POINTER TO RTS OR A MAPPED LIBRARY
	  BR	10$		;CHECK RTS AND ANY MAPPED LIB FOR RESIDENCY
	;CLC			;FROM SECOND EXIT
	BR	40$		; NOW EXIT

10$:	BITB	#^C<LCK>,R.MCTL+M.CTRL(R2) ;Is RTS or LIB resident?	;020
	BNE	12$		;No, exit C=1				;020
	BITB	#LCK,R.MCTL+M.CTRL(R2) ;Is RTS or LIB ready?		;020
	BNE	40$		;Yes, back to co-routine		;020
12$:	ADD	#2,(SP)		;No, signal special co-routine exit	;032
	CALL	@(SP)+		;Signal special co-routine exit		;032
	RETURN			;And get out (C=1)			;032

.SBTTL	MAKE ENTRIES RESIDENT

;+
; RESENT - MAKE AN ENTRY RESIDENT.
;
;	R2 -> ENTRY TO BE MADE RESIDENT
;
;	CALL	RESENT
;
;	R4 -> ENTRY TO BE MADE RESIDENT
;
;	C=1 ALWAYS
;-

20$:	SUB	#M.CTRL,R2	;RE-INDEX BACK TO TOP OF MEMORY AREA
RESENT::MOV	R2,R4		;COPY THE MEMORY CONTROL AREA POINTER
	MOVB	#SWP!IN!MC.LCK,M.CTRL(R4) ;SET RESIDENCY REQUEST STATUS	;020
	MOV	R0,-(SP)	;SAVE R0 ...
	MOV	#RESLST,R0	;SELECT QUEUE ROOT ...
	CALL	QUEUE0,R5	;LEGAL CALL IN I-SPACE
	MOV	(SP)+,R0	;RESTORE R0
	BR	SIGMEM		; AND SIGNAL MEMORY MANAGER

GLOBAL	<RESLST>

.SBTTL	CALCULATE/CLEAR RESIDENCY QUANTUM

;+
; FNDRSQ - CALCULATE RESIDENCY QUANTUM.
;
;	R1 -> JOB DATA BLOCK
;	CALLING JOB IS "JOB"
;
;	CALL	FNDRSQ
;-

FNDRSQ::SUB	JOBQNT,JDRESQ(R1) ;CALCULATE NEW RESIDENCY QUANTUM
	BHI	40$		;NO UNDERFLOW YET

;+
; CLRRSQ - CLEAR RESIDENCY QUANTUM.
;
;	R1 -> JOB DATA BLOCK
;
;	CALL	CLRRSQ
;-

CLRRSQ::CLR	JDRESQ(R1)	;SET RESIDENCY QUANTUM TO ZERO

;+
; SIGMEM - SIGNAL MEMORY MANAGER IF NEEDED.
;
;	CALL	SIGMEM
;-

SIGMEM::TST	RESLST		;ANYTHING IN RESIDENCY LIST?
	BEQ	30$		;NOPE, JUST EXIT
	L3QSET	QBRING		; AND CALL RESIDENCY MANAGER
30$:	SEC			;INDICATE COMING IN (SEE 'FNDJOB')
40$:	RETURN			; AND EXIT

GLOBAL	<JOBQNT,RESLST>

;+
; RESJOB - MAKE A JOB IMAGE RESIDENT.
;
;	R2 -> JOB'S JOB DATA BLOCK
;	R3 =  LEVEL 3 QUEUE BIT(S) TO SET ON RESIDENCY
;
;	CALL	RESJOB
;
;	C=1 ALWAYS
;
; In order to make a job image resident, we must make the job and
; everything that it uses resident. Because of the way that the
; memory manager works, the first thing to be made resident must
; be a floating library or RTS, then fixed libraries follow, and
; then the job image follows.
;
; Since a job using a floating library must be running under NULRTS,
; we can load the floating library first instead of the RTS, and
; not need to bother with making a RTS resident. We also don't have
; to worry about placing the floating library in RESLST more than
; once, since once it is placed in RESLST it will no longer be marked
; as OUT.
;-

RESJOB::MOV	R3,JDRESB(R2)	;SET L3Q BITS FOR RESIDENCY
	REGSCR			;SAVE ALL REGISTERS
	MOV	R2,R0		;Copy JDB pointer			;032
	MOV	JDFLG4(R0),R2	;Get pointer to floating library & flags ;032
	BIC	#^C<J2SLAP>,R2	;Save only floating library pointer	;032
	BNE	45$		;Using one, make it resident		;032
	MOV	JDRTS(R0),R2	;Not using one, get RTS block pointer	;032
45$:	CALL	50$		;Make RTS or floating library resident	;029
	MOVB	JDJBNO(R0),R0	;Now get job # * 2			;032
	CALL	LIBSUB,R5	;Check each library for residency	;029
	  BR	50$		;CHECK ONCE FOR EACH
	MOV	TOS.R2(SP),R2	;NOW GET JDB POINTER AGAIN
	ADD	#JDMCTL+M.CTRL,R2 ; AND INDEX TO CONTROL BYTE IN JOB IMAGE
	BR	60$		;GO CHECK FOR RESIDENCY

50$:	ADD	#R.MCTL+M.CTRL,R2 ;INDEX TO CONTROL BYTE IN RTS/LIB BLOCK
60$:	CMPB	(R2),#OUT	;IS IMAGE COMPLETELY NON-RESIDENT?
	BEQ	20$		;YES, START RESIDENCY
	BITB	(R2),#IN	;IS IMAGE TRYING TO COME IN NOW?
	BNE	SIGMEM		;YES, SIGNAL RESIDENCY MANAGER
	BITB	(R2),#OUT	;IS THE IMAGE GOING OUT?
	BEQ	30$		;NO, JUST WAIT UNTIL LATER...
	BISB	#REQ,(R2)	;ELSE REQUEST RESIDENCY SOON
	BR	30$		; BUT EXIT NOW

.SBTTL	UNLOCK A JOB

;+
; UNLOC0 - UNLOCK THE CURRENT JOB.
;
;	CALLING JOB IS "JOB"
;
;	CALL	UNLOC0
;
;	R0 =  JOB NUMBER TIMES 2
;	R2 =  RANDOM
;-

UNLOC0::MOVB	JOB,R0		;GET CURRENT JOB NUMBER TIMES 2

;+
; UNLOCK - UNLOCK A JOB.
;
;	R0 =  JOB NUMBER TIMES 2
;
;	CALL	UNLOCK
;
;	R2 =  RANDOM
;-

UNLOCK::MOV	JOBTBL(R0),R2	;GET JOB DATA BLOCK POINTER
	BEQ	40$		;NO JOB, EXIT
	BITB	#^C<LCK>,JDMCTL+M.CTRL(R2) ;Is job simply locked?	;020
	BNE	40$		;NO, LEAVE IT ALONE...
	SUB	#<MC.LCK*400>,JDMCTL+M.SIZE(R2) ;Yes, free up one lock	;020
.ASSUME	M.CTRL	EQ M.SIZE+1						;020
	BCS	70$		;Error, too many unlocks!		;020
	BR	SIGMEM		;EXIT SIGNALING MEMORY MANAGER

70$:	CRASH			;Illegal LCK count			;020

.DSABL	LSB

GLOBAL	<JOBTBL>

.SBTTL	SCANNING SUBROUTINES

;+
; RTSSUB - RUN-TIME SYSTEM & RESIDENT LIBRARY CHECKER.
;
;	R2 -> JOB'S JOB DATA BLOCK
;
;	CALL	RTSSUB,R5
;
;	R0 = Job # * 2
;	R2 -> TOP OF RTS/LIB BLOCK TO CHECK
;
;	FIRST EXIT MEANS THERE IS A RTS/LIB BLOCK TO CHECK
;	SECOND EXIT MEANS THERE ARE NO MORE BLOCKS
;		C=0 ALWAYS
;-

	TMPORG	LIBISP

RTSSUB::MOVB	JDJBNO(R2),R0	;Get job # * 2				;032
	MOV	JDRTS(R2),R2	;GET POINTER TO RTS BLOCK
	CALL	(R5)		;CALL FOR RTS CHECK
	 BR	LIBSUB		;No special exit, good			;032
	MOV	(SP)+,R5	;Special exit, get return address	;032
	SEC			;Set carry for failure			;032
	RETURN	R5		;And we're done				;032

;+
; LIBSUB - RESIDENT LIBRARY CHECKER.
;
;	R0 = Job # * 2
;
;	CALL	LIBSUB,R5
;
;	R0 -> JOB'S WINDOW DESCRIPTOR BLOCK @ LIB POINTER
;	R2 -> TOP OF LIB BLOCK TO CHECK
;
;	FIRST EXIT MEANS THERE IS A LIB BLOCK TO CHECK
;		FIP pool will be mapped
;
;		If caller is through checking libraries, execute:
;			ADD #2,(SP)
;			CALL @(SP)+
;
;		If caller wants to check more libraries, execute:
;			RETURN
;
;	SECOND EXIT MEANS THERE ARE NO MORE BLOCKS TO CHECK
;		C=0 for regular exit
;		C=1 for forced exit
;		Mapping will be restored
;-

.ENABL	LSB

LIBSUB::MAP	PUSH,APR=5,DATA	;Caller's APR5 mapping			;032
	MAP	PUSH,APR=6,DATA	;And caller's APR6 mapping		;032
	MOV	R1,-(SP)	;Save a work register			;032
	CALLX	MAPJCR		;Map caller's JCR entry			;032
	MOV	R1,R0		;Copy pointer to JCR entry		;032
	MOV	(SP)+,R1	;Restore work register			;032
	MOV	JCWPTR(R0),R0	;Get pointer to caller's first WDB	;032
	BEQ	50$		;SIMPLE, NONE EXISTS
	MAP	FIPPOL		;Found one, map FIP pool		;032
10$:	MOV	-(R0),R2	;ANY LIBRARY POINTER HERE?
	BEQ	20$		;NO
	BIT	#WA$MAP,R2	;ANY MAPS FOR THIS LIBRARY?		;036
	BEQ	20$		;NO
	BIC	#^C<WA$LIB>,R2	;Yes, save only LIB block pointer	;036
	CALL	(R5)		;CALL OUR CALLER
	 BR	20$		;Not special exit, good			;032
	BR	35$		;Special exit, go do it			;032

20$:	BIT	R0,#40-3	;AT TOP OF ATTACHED LIB LIST
	BNE	10$		;NO, LOOP TILL DONE
	MOV	-(R0),R0	;Yes, get pointer to next WDB		;027
	BNE	10$		;We got one, loop for all attaches	;027
	BR	50$		;None, get out				;032

;+
; WINSUB - CREATED ADDRESS WINDOW CHECKER.
;
;	R0 -> Job # * 2
;
;	CALL	WINSUB,R5
;
;	R0 -> JOB'S WINDOW DESCRIPTOR BLOCK @ W$NAPR
;
;	FIRST EXIT MEANS THERE IS A WINDOW TO CHECK
;		FIP pool is mapped
;
;		If caller is through checking windows, execute:
;			ADD #2,(SP)
;			CALL @(SP)+
;
;		If caller wants to check more windows, execute:
;			RETURN
;
;	SECOND EXIT MEANS THERE ARE NO MORE WINDOWS TO CHECK
;		C=0 for regular exit
;		C=1 for forced exit
;		Mapping is restored
;-

WINSUB::MAP	PUSH,APR=5,DATA	;Caller's APR5 mapping			;032
	MAP	PUSH,APR=6,DATA	;And caller's APR6 mapping		;032
	MOV	R1,-(SP)	;Save a work register			;032
	CALLX	MAPJCR		;Map caller's JCR entry			;032
	MOV	R1,R0		;Copy pointer to JCR entry		;032
	MOV	(SP)+,R1	;Restore caller's R1			;032
	MOV	JCWPTR(R0),R0	;Get pointer to caller's first WDB	;032
	BEQ	50$		;SIMPLE, NONE EXISTS
	MAP	FIPPOL		;Map FIP pool for WDBs			;032
30$:	TST	(R0)		;ANY WINDOW HERE?
	BEQ	40$		;NO
	CALL	(R5)		;CALL OUR CALLER
	 BR	40$		;Not special exit, good			;032
35$:	MOV	(SP)+,R5	;Special exit, set the return PC	;032
	SEC			;Set carry to flag it			;032
	BR	60$		;And go do it				;032

40$:	ADD	#W.SIZE,R0	;SKIP TO NEXT WINDOW
	BIT	R0,#40-1	;END OF BLOCK?
	BNE	30$		;NO, LOOP TILL DONE
	MOV	-40(R0),R0	;GET LINK TO NEXT WDB
	BNE	30$		;LOOP TILL DONE
50$:	TST	(R5)+		;Set up for second exit			;032
	;CLC			;(C=0) FROM ABOVE
60$:	MAP	POP,APR=6,DATA	;Restore APR6 mapping			;032
	MAP	POP,APR=5,DATA	;Restore APR5 mapping			;032
	RETURN	R5		;EXIT WITH NO MORE CHECKS TO BE DONE

.DSABL	LSB

;+
; LIBADR - Check for instruction space address within libraries
;
;	R3 =  VIRTUAL ADDRESS+2 TO CHECK
;
;	JOB IS "JOB"
;	User's saved PS is at SYSTAK-2
;
;	CALL	LIBADR
;
;	R3 -> LIB block of mapped window, or a special RID if this is
;	      a special window
;
;	IF C=0 ADDRESS NOT WITHIN A MAPPED WINDOW
;	IF C=1 ADDRESS IS WITHIN A MAPPED WINDOW
;-

LIBADR::REGSCR			;SAVE ALL REGISTERS
	MOVB	JOB,R0		;Get job # * 2				;032
	SUB	#2,R3		;CORRECT THE VIRTUAL ADDRESS
	MOV	#WS$UIS,R4	;Guess that we're looking at user mode	;032
	TST	SYSTAK-2	;Good guess?				;032
	BMI	10$		;Yes, sure is				;032
	MOV	#WS$SIS,R4	;No, try supervisor mode		;032
10$:	CALL	LIBADX		;CHECK FOR MATCHING MAPPED WINDOW
	MOV	R3,TOS.R3(SP)	;RETURN R3 AS THE LIB POINTER (IF ANY)
	RETURN			;EXIT (KEEPING C-BIT)

GLOBAL	<SYSTAK>							;032

;+
; LIBADX - CHECK FOR ADDRESS WITHIN A MAPPED WINDOW.
;
;	R0 = Job # * 2
;	R3 = VIRTUAL ADDRESS TO CHECK
;	R4 = Mapping bits to check in W$NSTS
;		WS$UIS = Check user mode I-space
;		WS$UDS = Check user mode D-space
;		WS$SIS = Check supervisor mode I-space
;
;	CALL	LIBADX
;
;	R0 -> MAPPED WINDOW (but not mapped!)
;	R2 =  ENDING ADDRESS OF MAPPED WINDOW
;	R3 -> LIB block of mapped window, or a special RID if this is
;	      a special window
;	R4 =  Undefined
;
;	IF C=0 ADDRESS NOT WITHIN A MAPPED WINDOW
;	IF C=1 ADDRESS IS WITHIN A MAPPED WINDOW
;-

LIBADX::BIT	#XC$IDS,X.CON	;Does system have I&D space?		;032
	BNE	5$		;Yes, sure does				;032
	MOV	#WS$UIS,R4	;No, so always check user mode I-space	;032
5$:	CALL	WINSUB,R5	;RETURNS ALL CREATED WINDOWS
	  BR	10$		;CHECK AGAINST MAPPED ADDRESS IN WINDOW
	BR	20$		;(C=0) FROM SECOND EXIT

10$:	TST	(R0)		;IS WINDOW MAPPED?
	BPL	20$		;NOPE
.ASSUME	WS$MAP	EQ	100000
	BIT	R4,(R0)		;Yes, but is it mapped in the right space? ;032
	BEQ	20$		;No, forget it				;032
	MOVB	(R0),R2		;GET APR NUMBER OF MAPPED WINDOW
	ASH	#13.,R2		;CONVERT BASE TO VIRTUAL ADDRESS
	CMP	R3,R2		;IS ADDRESS >= BASE ADDRESS?
	BLO	20$		;NO
	ADD	W$NBYT(R0),R2	;CALCULATE ENDING MAPPED ADDRESS
	BEQ	15$		;ENDING MAPPED ADDRESS AT THE 32K BOUNDARY?
	CMP	R3,R2		;IS ADDRESS < ENDING MAPPED ADDRESS?
	BHIS	20$		;NO
15$:	MOV	W$NLIB(R0),R3	;Yes, get attachment pointer		;036
	CMP	R3,#RIDMIN	;Is this a special region?		;036
	BHIS	17$		;Yes, so return the special value	;036
	MOV	(R3),R3		;No, get the LIB pointer and flags	;036
	BIC	#^C<WA$LIB>,R3	;Save only the LIB pointer		;036
17$:	ADD	#2,(SP)		;Signal special co-routine exit		;032
	CALL	@(SP)+		;Invoke it				;032
	;SEC			;From special co-routine exit
20$:	RETURN			;EXIT

GLOBAL	<X.CON>								;032

;+
; RETWDB - DETACH ALL LIBRARIES AND RETURN WDB BLOCKS.
;
;	R1 -> JOB DATA BLOCK @ JDFLG
;
;	CALL	RETWDB
;
;	R0 =  RANDOM
;	R2 =  RANDOM
;-

RETWDB::MAP	PUSH,APR=5,DATA	;Save caller's APR5 mapping		;032
	MAP	PUSH,APR=6,DATA	;And caller's APR6 mapping		;032
	MOVB	JDJBNO-JDFLG(R1),R0 ;Get job # * 2			;032
	MOV	R1,-(SP)	;Save JDB @ JDFLG pointer		;032
	CALLX	MAPJCR		;Map caller's JCR entry			;032
	MOV	JCWPTR(R1),R0	;Get pointer to job's WDB		;032
	CLR	JCWPTR(R1)	;And forget about it			;032
	MOV	(SP)+,R1	;Restore JDB @ JDFLG pointer		;032
	TST	R0		;Is there really a WDB to get rid of?	;032
	BEQ	60$		;No, not this time
	BIC	#J2SLAP,JDFLG4-JDFLG(R1) ;Indicate no floating library	;032
	CMP	JOBWDB,R0	;IS THIS "JOB"'S WDB?
	BNE	10$		;NO
	CLR	JOBWDB		;"JOB"'S WDB IS GONE
10$:	MAP	FIPPOL		;Now map FIP pool for the WDBs		;032
20$:	MOV	-(R0),R2	;IS JOB ATTACHED TO A LIBRARY?
	BEQ	40$		;NO
	MOV	(PC)+,-(SP)	;GUESS AT JOB IMAGE NOT RESIDENT OR MAPPED
	 .BYTE	1,0
	CMPB	#OUT,JDMCTL+M.CTRL-JDFLG(R1) ;IS JOB IMAGE RESIDENT?
	BEQ	30$		;NO, MAP COUNT ALREADY DECREMENTED
	BIT	#WA$MAP,R2	;ANY MAPS OUTSTANDING?			;036
	BEQ	30$		;NOPE
	MOV	(PC)+,(SP)	;YEP, JOB IMAGE RESIDENT AND MAPPED
	 .BYTE	1,1
30$:	BIC	#^C<WA$LIB>,R2	;Save only LIB block pointer		;036
	SUB	(SP)+,R.CNT(R2)	;MARK 1 LESS USER FOR THIS LIBRARY
	BNE	40$		;WE STILL HAVE A FEW HANGERS ON
	BIT	#PF.REM,R.FLAG(R2) ;IS THE LIBRARY ADDED REMOVE?
	BEQ	40$		;NOPE
	MOV	R0,-(SP)	;SAVE WORKING REGISTER
	CALL	REMRTS		;REMOVE LIBRARY FROM MEMORY LIST
	MOV	(SP)+,R0	;RESTORE WORKING REGISTER
40$:	BIT	R0,#40-3	;AT TOP OF LIST?
	BNE	20$		;NO, LOOP
	TST	-(R0)		;Point to top of block			;027
	MOV	R4,-(SP)	;SAVE REGISTER
	MOV	R0,R4		;SET UP FOR BUFFER RETURN
	MOV	(R0),R0		;GET ADDRESS OF NEXT IN LIST
	BUFFER	RETSML		;RETURN CURRENT BLOCK
	MOV	(SP)+,R4	;RESTORE REGISTER
	TST	R0		;AT END OF LIST?
	BNE	20$		;NO, LOOP				;027
	MOVB	JDJBNO-JDFLG(R1),R0 ;Get caller's job # * 2		;037
	CALLMI	SETMDE,GENAP5	;And re-calculate job's mapping		;037
60$:	MAP	POP,APR=6,DATA	;Restore APR6 mapping			;032
	MAP	POP,APR=5,DATA	;Restore APR5 mapping			;032
	RETURN			;EXIT

	UNORG

.SBTTL	FIND A RUN-TIME SYSTEM BY NAME

;+
; FNDRTS - Find a RTS by name, skipping NULRTS
; FNDRTX - Find a RTS by name, passing starting RTS for match
;
;	R1 -> JOB DATA BLOCK @ JDFLG
;	R3 -> Starting RTS block (for FNDRTX only)
;	R4 -> FIRQB
;		FQNAM1 =  RTS NAME (2 WORDS)
;
;	CALL	FNDRTS
;	CALL	FNDRTX
;
;	R3 -> RTS BLOCK
;-

.ENABL	LSB

FNDRTS::MOV	#NULRTS,R3	;Get NULRTS pointer			;028
	BR	20$		;And join up				;028

FNDRTX::CMP	FQNAM1(R4),R.NAME(R3) ;NAME PART 1 MATCH?		;022
	BNE	20$		;NO
	CMP	FQNAM1+2(R4),R.NAME+2(R3) ;YES, PART 2 ALSO MATCH?
	BEQ	30$		;YES, WE FOUND THE RTD
20$:	MOV	(R3),R3		;GET NEXT RTS IN THE LIST
	BNE	FNDRTX		;MORE, LOOP				;022
	ERROR	NORTS		;NO MORE, ERROR

30$:	CMP	R3,JDRTS-JDFLG(R1) ;IS FOUND RTS THE CALLER'S CURRENT RTS?
	BEQ	40$		;YES, JUST EXIT ALL O.K.
	BIT	#PF.1US,R.FLAG(R3) ;NO, ONLY 1 USER FOR THIS RTS?
	BEQ	40$		;ANY NUMBER GOES, ALL O.K.
	TSTB	R.CNT(R3)	;ONLY 1, ARE THERE ANY NOW??
	BNE	50$		;SOME NOW, SO ERROR
40$:	RETURN			; ELSE EXIT ALL O.K.

50$:	ERROR	PRVIOL		;ONLY 1 USER ALLOWED AT A TIME...

GLOBAL	<NULRTS>							;028

.DSABL	LSB

.SBTTL	BLOCK DATA MOVING

;+
; BLKMOV - BLOCK DATA MOVING.
;
;	R0 =  MONITOR'S COUNT (USUALLY 'J2PCNT')
;	R1 =  USER'S BUFFER LENGTH (USUALLY 'XRLEN') [MONITOR --> USER ONLY]
;	R2 =  USER'S COUNT[USER --> MONITOR] OR 0[MONITOR --> USER] (USUALLY 'XRBC')
;	R4 =  MONITOR'S BUFFER "ADDRESS"
;	R5 -> USER'S BUFFER (OPTIONALLY THROUGH DPAR6, BUT NEVER DPAR5)
;
;	CALL	BLKMOV
;
;	R0 =  COUNT ACTUALLY MOVED
;
; NOTES:
;
;	THIS ROUTINE WILL MOVE FROM CHAINED MONITOR BUFFERS. IT ASSUMES
;	THAT THE MAXIMUM MOVE SIZE IS <=4K-32 WORDS AND THAT ALL BUFFERS
;	IN THE CHAIN HAVE THE SAME BUFFER HEADER AS SHOWN BELOW:
;-

.DSECT			;VERIFY THE BUFFER HEADER

BF.SIZ:	.BLKW		;BUFFER SIZE IN BYTES
BF.OFF:	.BLKW		;BYTE OFFSET TO DATA WITHIN BUFFER
BF.LNK:	.BLKW		;LINK "ADDRESS" TO NEXT BUFFER
BF.CNT:	.BLKW		;DATA SIZE IN BYTES

	UNORG

BLKMOV::REGSCR			;SAVE ALL REGISTERS
	MAP	PUSH,APR=5,DATA	; AND THE PAR5 VALUE
	TST	R2		;WHICH DIRECTION WILL THE MOVE BE
	BNE	10$		;USER --> MONITOR, CHECK USER'S COUNT
	MOV	R1,R2		;MONITOR --> USER, CHECK USER'S BUFFER LENGTH
10$:	CMP	R2,R0		;IS USER'S COUNT/BUFFER LENGTH < MONITOR'S COUNT?
	BLOS	20$		;YES, SO USE USER'S COUNT/BUFFER LENGTH
	MOV	R0,R2		;NO, SO USE THE MONITOR'S COUNT
20$:	MOV	R5,R3		;PUT USER BUFFER POINTER HERE
	CLR	TOS.R0+2(SP)	;CLEAR COUNT OF BYTES ACTUALLY MOVED

30$:	MOV	R4,R1		;COPY BUFFER ADDRESS TO HERE
	BEQ	90$		;NO MORE BUFFERS, SO NO MORE MOVING
	BIT	R4,#37		;IS IT A MONITOR MAPPED BUFFER?
	BEQ	40$		;NORMAL (MONITOR POOL) KIND
	ASHC	#-7,R1		;CONTORTED KIND, FIND MMU ADDRESS AND
	MAP	R1,APR=5,DATA	;LOAD PAR5 WITH IT
	MOV	#120000,R1	;  THEN POINT TO IT (MAPPED)
40$:	MOV	R2,-(SP)	;STACK TOTAL COUNT TO MOVE
	MOV	R1,R0		;COPY BUFFER VIRTUAL ADDRESS TO HERE
	MOV	(R0)+,R5	;SAVE SIZE OF BUFFER HERE
	SUB	(R0),R5		;FIND SIZE OF AVAILABLE DATA SPACE
	ADD	(R0)+,R1	;FORM POINTER TO DATA (OR FREE AREA)
	MOV	(R0)+,R4	;GET POINTER TO NEXT BUFFER IN CHAIN
	MOV	R0,-(SP)	;STACK POINTER TO DATA SIZE IN HEADER
	MOV	(R0),R0		;GET SIZE OF DATA IN THIS BUFFER
	MOV	R3,-(SP)	;SAVE ORIGINAL "USER" BUFFER POINTER
	TST	TOS.R2+10(SP)	;WHICH DIRECTION IS THE MOVE AGAIN?
	BEQ	50$		;MONITOR --> USER, WE ARE ALL SET UP
	SUB	R0,R5		;USER --> MONITOR, FIND SIZE OF FREE SPACE
	MOV	R1,R0		;EXCHANGE THE POINTERS
	MOV	R3,R1		; TO MOVE FROM USER TO
	MOV	R0,R3		;  MONITOR IN COMMON CODE
	MOV	R5,R0		;COPY COUNT OF FREE SPACE IN BUFFER
50$:	CMP	R0,R2		;MORE DATA (OR FREE SPACE) THAN NEEDED?
	BHIS	60$		;YES, SO KEEP CURRENT COUNT TO MOVE
	MOV	R0,R2		;NO, SET MAXIMUM FOR THIS BUFFER
60$:	MOV	R2,R0		;REMEMBER THE MOVE BYTE COUNT
	BEQ	70$		;NO MOVING IF NO COUNT...
	CALL	MOVBYT		;ELSE GO DO THAT DATA MOVING
70$:	MOV	(SP)+,R3	;RESTORE ORIGINAL "USER" POINTER
	ADD	R0,R3		; AND CORRECT IT FOR THE AMOUNT MOVED
	MOV	(SP)+,R1	;RESTORE POINTER TO HEADER @ DATA SIZE WORD
	MOV	(SP)+,R2	;THIS IS SIZE OF TOTAL MOVE REQUESTED
	TST	TOS.R2+2(SP)	;WHAT IS THAT MOVE DIRECTION??
	BNE	80$		;USER --> MONITOR, UPDATE DATA SIZE ONLY
	SUB	R0,(R1)		;MONITOR --> USER, MAKE DATA SIZE SMALLER
	CMP	-(R1),-(R1)	; AND POINT TO OFFSET WORD
80$:	ADD	R0,(R1)		;ADD COUNT MOVED TO DATA SIZE OR OFFSET
	ADD	R0,TOS.R0+2(SP)	;BUMP THE COUNT MOVED
	SUB	R0,R2		;WAS TOTAL REQUESTED ACTUALLY MOVED?
	BHI	30$		;NOT YET, CONTINUE WITH NEXT BUFFER
90$:	MAP	POP,APR=5,DATA	;DONE, RESTORE THE PAR5 VALUE
	RETURN			; AND REGISTERS AND EXIT (R0 = COUNT MOVED)

;+
; MOVMEM - MOVE DATA FROM ANY PHYSICAL ADDRESS.
;
;	R0 =	APR5 MMU VALUE TO MAP "FROM" DATA
;	R1 ->	"FROM" DATA (VIA APR5 IF NOT PERMANENTLY MAPPED)
;	R2 =	BYTE COUNT (0 < R2 <= 8K-64)
;	R3 ->	"TO" DATA
;
;	CALL	MOVMEM
;
;	R1 =  UNDEFINED
;	R2 =  UNDEFINED
;	R3 =  UNDEFINED
;-

MOVMEM::MAP	PUSH,APR=5,DATA	;SAVE PAR 5
	MAP	R0,APR=5,DATA	;MAP "FROM" DATA
	CALL	MOVBYT		;MOVE THE DATA
	MAP	POP,APR=5,DATA	; AND RESTORE PAR5
	RETURN			;ALL DONE

;+
; MOVBYT - MOVE DATA BYTES.
;
;	R1 -> "FROM" DATA
;	R2 =  BYTE COUNT (NOT ZERO!)
;	R3 -> "TO" DATA
;
;	CALL	MOVBYT
;
;	R1 =  UNDEFINED
;	R2 =  UNDEFINED
;	R3 =  UNDEFINED
;-

.ENABL	LSB

$$MOVB::			;&INIT -- REPLACE WITH CIS CODE
MOVBYT::MOV	R3,-(SP)	;SAVE R3
	XOR	R1,R3		;SET BIT <0> IF POINTERS DIFFER IN BYTES
	ROR	R3		;SET C=1 IF POINTERS DIFFER IN BYTES
	BCS	20$		;DO IT THE LONG WAY IF POINTERS DIFFER
	MOV	(SP)+,R3	;RESTORE R3 ("TO" POINTER)
	BIT	R1,#1		;INITIAL BYTE MOVE NEEDED?
	BEQ	10$		;NO
	MOVB	(R1)+,(R3)+	;YES, SO MOVE 1 BYTE
	DEC	R2		; AND CORRECT THE MOVE COUNT
10$:	;CLC			;C=0 FROM NO BRANCH OF 'BCS'
	ROR	R2		;FORM WORD MOVE COUNT AND SET C=1 IF FINAL
	BCC	MOVWRD		;NO FINAL BYTE MOVE NEEDED, DO AS WORDS
	CALL	MOVWRD		;FINAL MOVE NEEDED, DO WORD MOVE FIRST
	MOVB	(R1)+,(R3)+	;NOW DO THAT FINAL BYTE MOVE
	RETURN			; AND EXIT

20$:	MOV	#70$,-(SP)	;SET BYTE MOVE LOOP DISPATCH
	BR	30$		; AND GO DO IT

;+
; MOVWRD - MOVE DATA WORDS.
;
;	R1 -> "FROM" DATA
;	R2 =  WORD COUNT (CAN BE ZERO!)
;	R3 -> "TO" DATA
;
;	CALL	MOVWRD
;
;	R1 =  UNDEFINED
;	R2 =  UNDEFINED
;	R3 =  UNDEFINED
;-

$$MOVW::			;&INIT -- REPLACE WITH CIS CODE
MOVWRD::MOV	R3,-(SP)	;SAVE R3
	MOV	#50$,-(SP)	;SET WORD MOVE LOOP DISPATCH
30$:	CLR	R3		;CLEAR OUT THE REMAINDER
	ASHC	#-3,R2		;FORM: R2=LOOP COUNT, R3=REMAINDER
	ASHC	#-16.+1+3,R3	;NOW HAVE REMAINDER *2
	INC	R2		;GO THROUGH LOOP AT LEAST ONCE
	NEG	R3		;MAKE REMAINDER NEGATIVE
	ADD	(SP)+,R3	; TO FORM INITIAL LOOP ENTRY POINT
	RTS	R3		;NOW ENTER LOOP (AND RESTORE R3)

40$:				;MAIN WORD MOVING LOOP
.REPT	8.
	MOV	(R1)+,(R3)+	;MOVE A WORD
.ENDR
50$:	SOB	R2,40$		;LOOP FOR MOVING WORDS
	RETURN			; THEN EXIT

60$:				;MAIN BYTE MOVING LOOP
.REPT	8.
	MOVB	(R1)+,(R3)+	;MOVE A BYTE
.ENDR
70$:	SOB	R2,60$		;LOOP FOR MOVING BYTES
	RETURN			; THEN EXIT

.DSABL	LSB

.SBTTL	BUFFER MAPPING

;+
; MAPBUF - BUFFER MAPPING
;
;	R4 =  BUFFER "ADDRESS"
;
;	CALL	MAPBUF
;
;	R3 -> BUFFER (POSSIBLY THROUGH DPAR6)
;	DPAR6 ALTERED IF NON-MONITOR BUFFER
;-

MAPBUF::MOV	R4,R3		;COPY THE BUFFER "ADDRESS"
	BIT	R4,#37		;IS IT A MONITOR BUFFER?
	BEQ	10$		;YES, ALL SET UP ALREADY
	ASHC	#-7,R3		;NO, CONTORTED, MAKE INTO MMU ADDRESS
	MAP	R3,APR=6,DATA	; AND SET PAR6 FOR IT
	MOV	#140000,R3	;NOW MAKE THE VIRTUAL POINTER
10$:	RETURN			;ALL DONE

.END


