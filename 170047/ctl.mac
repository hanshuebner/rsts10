	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
	.INCLUDE /CMN:FLDEF/
TITLE	CTL,<FILE PROCESSOR CONTROL>,0H,20-DEC-91,JDM/MHB/ABC/RTW/SRM/SJM/JTC/GPK/FEK/BGN/DRP/FRL/TWH/MNB/KPH/WRM/JFM/VAM

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR CTL

;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;  001	RTW  02-Jul-80	Changed LODFIP to allow sync fcall/fjmp
;  002	TG   07-Aug-80	Fixed GETCLU loop problem
;  003	RTW  09-Aug-80	Added system job support
;  004	SRM  25-Mar-81	Add optional patch to disable zeroing of privileged
;			files on deletion.
;  005	SJM  08-Jul-81	Add support for I/D space
;  006	JTC  15-Oct-81	FIP Pool modifications
;  007	JTC  02-Nov-81	Fix FCALL return to res overlay problem
;  008	GPK  11-Nov-81	Change default error handling to unlock job if locked
;
;				[RSTS V8.0]
;  009  FEK  28-Jul-82	Add placed directory support
;  010	FEK  26-Aug-82	Add V1 structure support
;  011  FEK  22-SEP-82	create REDSAT routine.
;  012	GPK  20-Sep-82	Add attribute search code
;  013	GPK  20-Sep-82	Add one-user mounted disks
;  014	GPK  14-Oct-82	Add CALL WRITEC to NXTUNT
;  015	GPK  14-Oct-82	Add CHKPWD to verify RAD50 passwords
;  016	GPK  28-Oct-82	Add entry point GUNOWN
;  017	FEK  01-Nov-82	Fix R50ASC for I/D space
;  018	GPK  23-Nov-82	Bugfix in ZAPUNT, logged-in spawn support
;  019	GPK  08-Dec-82	Sourceclear fix to EXTDIR
;  020  BGN  26-Dec-82	Add code to RUF to try and find a UFD's DCN faster
;  021  FEK  26-Dec-82  Fix the fix to EXTDIR (019)
;
;				[RSTS V9.0]
;  022	GPK  28-Mar-83	Multiple privileges; merge in CTLLRG
;  023	GPK  21-Sep-83	Changes to multiple privileges
;  024	DRP  03-Oct-83	Table changes to UNTCNT, UNTOWN/UNTOPT and
;			UNTCLU/UNTERR
;  025	GPK  22-Nov-83	Change CHKACC to implement separate executable
;			file protection rules and executable access flag
;  026  FRL  25-Oct-83  Added extended level three queue (L3Q) capability
;  027  DRP  18-Nov-83	Made OPNLRG and EXTLRG into a phase. Modified FIPGO to
;			map it instead of calling LODFIP
;  028	TWH  12-Oct-83	Add AUTOSZ routine
;  029	GPK  29-Dec-83	Fix MARK for I-only code
;  030	GPK  18-Jan-84	Add Merge pointer to FIEXIX
;  031  MNB  15-Dec-83  Fix changes in M.CTRL byte (LCK bit LCK field)
;  032  MNB  02-Feb-84  Install DSQ->ASYWRK->WCB linkages
;  033	KPH  21-Mar-84	Add cell for current FIP overlay
;			Improve system startup error reporting
;  034  FRL  04-Apr-84  V9.0 logicals
;  035	DRP  06-Apr-84	Add logged-in quota support
;  036	MNB  @0-Apr-84	REQUE, WINDOW, and WINERR moved to EXTLRG
;			INI moved to OPNLRG
;  037	GPK  17-Apr-84	Centralize restricted device check in GUN,
;			Priv name changes
;  038	GPK  14-May-84	Correction because of added QKBTIC bit
;			Fix WRTBUF's handling of I/O errors
;  039	KPH  25-Jun-84	Bugfixes
;  040	DRP  06-Jul-84	Change MOVPIC to MOV in XDE
;  041	KPH  20-Jul-84	Lock disks on disk errors in WRTBUF
;  042	KPH  29-Aug-84	Changes for FIP pool in APR5
;  043	DRP  15-Oct-84	Fix problem with file lookup on multi-public
;			disk structured systems
;  044	GPK  30-Oct-84	Add accounting right check to CHKACC
;			Put FIPRIV back in for RJ2780
;  045	KPH  24-Oct-84	Add UUOFQ support
;  046  FRL  02-Nov-84  New special value for POSITION
;  047	DRP  17-Dec-84	Add I/O error handling to ZAPUNT
;			Make UNPLNK global
;  048	GPK  22-Jan-85	Check for RDS 0.0 in SAA, SAACR
;  049	GPK  11-Feb-85	Bugfix in CHKACC, new flag for accounting access
;  050	GPK  27-Feb-85	Add CHKACJ
;
;			[RSTS V9.1]
;  051	KPH  30-Mar-85	Resident SATT handling
;  052  KPH  03-Jun-85	Add RELFUN support to ZAPUNT
;  053  KPH  01-Jul-85	Clustersize optimization
;
;			[RSTS V9.2]
;  054  KPH  12-Jul-85	Add Job Control Region
;			Move GETFIP routine to root for others to use
;  055  KPH  24-Oct-85	Bugfix in RUF
;
;			[RSTS V9.3]
;  056  KPH  16-Jan-86	Change "higher priority L3Q checker" to not depend
;			on .ASSUMEs
;  057  KPH  23-Apr-86	Make GETCLU use less CPU time
;
;			[RSTS V9.5]
;  058	PJH  08-Jul-87	Add large disk support.
;  059  WRM  29-Jul-87	Add routines for partial deletes
;
;			[RSTS V9.6]
;  060	KCG  08-Dec-87	Correct stack reference in RUF.
;  061	WRM  08-Dec-87	Added global CNTENT to XDE (partial delete).
;
;			[RSTS V9.7]
;  062	KCG  15-Nov-88	Add F2CALL, F2CALX, F2JMP, and F2JMPX for the second
;			overlay phase.
;  063	KCG  15-Nov-88	Change F?CALL and FRET to have new parameter (pointing
;			to either OVBASE or O2BASE) on stack.
;  064	KCG  16-Nov-88	Change LODFIP to correctly offset into OVR.SYS for 
;			overlays in OV2.
;  065	JFM  21-Dec-88	Fix OV2 bug - Save current OVBTBL value before setting
;			current value.
;  066	JFM  16-Jan-88	Fix OV2 bug - Store OVBTBL value in case we go into 
;			FIP wait state.
;
;			[RSTS V10.0]
;  067	FEK  10-May-91	Add FIJOB header dumping
;  068  VAM  30-May-90	Correct calculation for free block count for large
;			clustersize disks.
;
;			[RSTS V10.1]
;  069	FEK  04-Dec-91	Eliminate 1 unnecessary I/O for open by FID
;-

	IONLY								;042

	DEFORG	CTL

	DEFORG	FIPEND

	ORG	CTL

.SBTTL	SYNCHRONOUS FUNCTION ENTRY POINT

;+
; FIPSNC - Synchronous Function Entry Point
;
; This is the entry point into FIP for synchronous functions.
;
;	R4 -> FIRQB (WORK BLOCK)
;	R5 =  DISPATCH "ADDRESS"
;	SP -> "RTI3", ... (SYSTEM STACK!)
;	CALLING JOB IS "JOB"
;
;	JMP	FIPSNC
;
; If the function dispatches to a resident module, we will execute the
; function synchronously.  That is, we do not go through the FIP queue
; but we execute it right now, using the system stack.  We then return
; to RTI3.  If we start the function this way but it then wants to
; FCALL or FJMP to a non-resident module, or tries to stall for any
; other reason, we will crash!  So come here only for synchronous
; functions.  Consider yourself warned.
;
; If the function dispatches to a non-resident module, we will queue
; the request on the FIP queue for later execution on the FIP stack.
; We then return to RTI3.
;
; Synchronous functions may not clobber any FIP variables because a
; stalled FIP function may be counting on them.  Synchronous functions
; may use FJMP and FCALL but FIPUNT and FIPGEN will not be changed
; in this case to preserve their values for possible FIP queued functions.
;-

	TMPORG	FIPDSP,0
	.WORD	FIPSNC
	UNORG

FIPSNC:	MOV	OVBASE,OVBTBL	;Select the correct overlay table	;063
	CALL	LODFIP		;TRY TO LOAD THE FUNCTION
	BCC	10$		;IT WAS RESIDENT
	JMPX	FIPSTL		;NON-RES, SO STALL USER AND QUEUE THE REQUEST

10$:	MOVB	JOB,R0		; SET R0 =  JOB NUMBER * 2
	MOV	JOBDA,R1	; SET R1 -> JOB DATA BLOCK
	MOV	JDJDB2(R1),R2	; SET R2 -> JOB DATA BLOCK #2
	MOV	J2PPN(R2),R3	; SET R3 =  PPN
	CALL	(R5)		;NOW CALL THE SYNCHRONOUS FUNCTION
	MOVB	JOB,R4		;GET BACK JOB NUMBER * 2
	ADD	#JBWAIT,R4	; AND POINT TO WAIT CODE
	BIS	(R4),JBSTAT-JBWAIT(R4) ;TRY TO MAKE THE JOB RUNNABLE
	TST	(R4)		;IS JOB NOW RUNNABLE?
	BNE	20$		;YES
	MOV	#JSTIM!JS.KB,(R4) ;NO, MAKE WAIT AS A SLEEP
	BIT	(R4),JBSTAT-JBWAIT(R4) ;DID THAT MAKE JOB RUNNABLE?
	BNE	20$		;YEP, LET IT RUN
	;TST	(SP)+		;(THE SP STACK WILL BE RESET)
	JMPX	DMPJOB		;NO, GO DUMP THIS SLEEPING JOB

20$:	RETURN			;RETURN TO RTI3

GLOBAL	<JBWAIT,JBSTAT>


.SBTTL	FIP START UPS

	TMPORG	FIPDSP,2
	.WORD	FIPGO
	UNORG

FIPGO:	MOV	SP,FIPR6	;SAVE THE MONITOR'S STACK POINTER
FIPNXT:	CLR	FIPOVR		;Indicate no current FIP overlay	;033
	MOV	#FISTAK,SP	;RESET FIP STACK (FLUSH GARBAGE)
	CLR	FIPERX		;ENSURE NO ALTERNATE ERROR EXIT
	MOV	FIQUE,R4	;GET POINTER TO REQUEST (FIRQB)
	MOVB	FQJOB(R4),R0	;GET JOB # REQUESTING SERVICE
	BIT	#1,R0		;IS THIS A SYSTEM JOB?
	BEQ	20$		;NO  GO ON AS NORMAL
	CMP	#<2*SYSJOB>,R0	;IS IT A VALID SYSJOB NUMBER
	BHI	10$		;OK GOOD JOB NUMBER
	CRASH			;BAD SYSTEM JOB NUMBER

10$:	MOV	SJBTBL+1(R0),JOBTBL ;GET ADDRESS OF THIS SYSTEM JOB'S JDB
	MOV	R0,FIPSJN	;SAVE SYSTEM JOB NUMBER IN FIP
	MOV	#JSFIP,JBWAIT	;FLAG THAT THIS JOB IS IN FIP
	CLR	R0		;MAKE FIJOB BE THE NULL JOB
20$:	MOV	R0,R5		;Copy job number times two		;067
	ADD	#JBTICK,R5	;Point to CPU time collection bucket	;067
	MOV	R5,CPUTIM	;And start charging this user		;067
	CALLX	GETJCR		;Pick up the JCR pointer for job	;054
	MOV	#FIPJC6,R5	;Point to address for JCR MMU address	;054
	MOV	R2,(R5)		;And save it for FIP functions		;054
	MOV	R1,-(R5)	;Save the virtual addres through APR6	;054
;ASSUME FIPJCR EQ FIPJC6-2
	MAP	R2,APR=5,DATA	;Map the JCR entry through APR5		;054
	MOV	#PRIVSZ/2,R3	;Count of priv words to move		;022
	ADD	#JCPRIV+PRIVSZ-20000,R1 ; Point to privileges in JCR	;054
				;Assume FIPJCR = FIPRVM+PRIVSZ		;054
	MOV	R1,R2		;Copy pointer to JCPRIV			;054
	TST	JCALPP-<JCPRIV+PRIVSZ>(R2) ;Do we have alternate privilege data?	;054
	BEQ	30$		;No, not this time			;054
	ADD	#JCALPV-JCPRIV,R2 ;Yes, so point to that mask also	;054
30$:	MOV	-(R1),-(R5)	;Set up a word in the mask		;054
	MOV	-(R2),-(SP)	;Pick up a word of alternate privileges	;054
	COM	(SP)		;Complement them			;054
	BIC	(SP)+,(R5)	;And clear any privileges not in mask	;054
	SOB	R3,30$		;Loop until done			;022
	MOV	JOBTBL(R0),R1	;GET ADDRESS OF JOB DATA BLOCK
	MOV	JDMCTL+M.PHYA(R1),@#X.TAB+<<SEG.FH*XMTLEN>+XM.ADD>	;067
				; Dump the FIJOB header if needed	;067
	MOV	JDJDB2(R1),R2	;GET JDB2 POINTER ALSO
	MOV	R2,-(R5)	;SET FIJBD2 AS -> JDB2			;022
				;Assume FIJBD2 = FIPRVM - 2		;022
	MOV	R1,-(R5)	;SET FIJBDA AS -> JDB
				;ASSUME FIJBDA = FIJDB2 - 2
	MOV	J2PPN(R2),R3	;GET CALLER'S PPN
	MOV	R3,-(R5)	;SET FIUSER = PPN
				;ASSUME FIUSER = FIJBDA - 2
	CLRB	-(R5)		;Assume privs for RJ2780		;044
				;ASSUME FIPRIV = FIUSER - 1		;044
	TSTPRV	HWCTL,FIPRVM	;Have HWCTL privs?			;044
	BNE	40$		;Yes, so RJ can think we're "priv'd"	;044
	COMB	(R5)		;No, indicate no privs to RJ		;044
40$:	MOVB	R0,-(R5)	;SET FIJOB AS JOB NUMBER TIMES 2	;044
				;ASSUME FIJOB = FIPRIV - 1		;044
	MAP	FIPPOL		;Restore FIP mapping			;054
	MOVB	FQFUN(R4),FIPFUN ;SAVE THE CURRENT FIP FUNCTION		;022
	MOV	FQADDR(R4),R5	;GUESS AT GENERAL DISPATCH FUNCTION
	CMPB	FQFUN(R4),#DSPFQ ;GOOD GUESS?
	BEQ	80$		;YES, DISPATCH TO GENERAL "ADDRESS"
	CMPB	FQFUN(R4),#UUOFQ ;Is this a .UUO or UUOFQ?		;045
	BNE	70$		;No, some other FIP function		;045
	MOV	$UUOTBL-<UU$MIN*2>(R5),R5 ;Get the .UUO address		;045
	BR	80$		;And join up				;045

70$:	MOVB	FQFUN(R4),R5	;General function, pick up the code	;045
	MOV	$FIPTBL(R5),R5	;GET FUNCTION'S TRANSFER "ADDRESS"
80$:	BIT	#1,R5		;Is the code in the OPN phase?		;027
	BEQ	90$		;No, it's an overlay, go load it	;027
	DEC	R5		;Fix the transfer address		;027
	MOV	#1*4,FIPOVR	;Set special overlay number for OPN phase ;033
	MAP	OPNAP5,APR=5,CODE ;Map the code in APR 5		;042
	BR	100$		;Now go do it				;027

90$:	MOV	OVBASE,OVBTBL	;Make OVBASE current table		
	CALL	LODFIP		;LOAD THAT FIP FUNCTION
100$:	CALL	(R5)		;NOW START IT

;+
; FIP FUNCTION ENTRY CONDITONS:
;
;	R0 =  JOB NUMBER TIMES 2
;	R1 -> JOB DATA BLOCK
;	R2 -> 2ND JOB DATA BLOCK
;	R3 =  PPN
;	R4 -> FIRQB
;-

	.BR	FIEXIT		;DROP THROUGH WHEN DONE

GLOBAL	<FIPR6,FISTAK,FIPERX,FIQUE,JOBTBL,FIJBD2,FIJBDA,FIUSER,FIPRVM>
GLOBAL	<FIJOB,FIPFUN,$FIPTBL,FIPSJN,SYSJOB,SJBTBL,OPNAP5,FIPOVR>	;067
GLOBAL	<$UUOTBL,FIPJC6,JBTICK,OVBASE,OVBTBL,X.TAB>			;067

.SBTTL	FIP EXITS

;+
; FIEXIT - EXIT FROM FIP SETTING "JSFIP".
;
;	JMP	FIEXIT
;
;-

FIEXIT::TST	(PC)+		;DON'T SKIP THE "JSFIP" SETTING

;+
; FIEXIX - EXIT FROM FIP NO "JSFIP" SETTING.
;
;	JMP	FIEXIX
;-

	TMPORG	FIPDSP,10						;030
	.WORD	FIEXIX							;030
	UNORG								;054

FIEXIX::SEC			;DO SKIP THE "JSFIP" SETTING
	MOV	FIQUE,R3	;Pick up work block FIP is working on	;039
	MOV	(R3),-(SP)	;Re-queue the FIP queue			;039
	MOV	SP,FIQUE	; through the FIP stack
	ROR	-(SP)		;Save the JSFIP setting indicator on stack
	SPLC	3		;Be sure that we are level three on exit
	CLR	FIPERX		;Guess at reporting errors to caller	;039
	MOV	FIJBDA,R4	;R4 -> JDB of job in FIP		;039
	CMP	JDWORK(R4),R3	;Does JDB match work block in FIP?	;039
	BEQ	10$		;Yes, so we can return errors in JDIOST	;039
	INC	FIPERX		;No, don't return errors in JDIOST	;039
10$:	MOV	SP,FIPESP	;Save the stack pointer in case of errors ;039
	BIS	#20$,FIPERX	;Set an error exit for writing FIBUF	;039
	CALL	WRITEC		;Check on writing out FIBUF
	BR	30$		;It worked, that's good			;041

20$:	CLRB	@#FIBMOD	;Error cleaning up FIBUF, stop trying	;041
	MOVB	@#FIBUNT,R4	;Pick up FIP unit number of FIBUF block	;041
	ASL	R4		;Make it a word index			;041
	BIS	#UO.CLN,UNTOPT(R4) ;And mark it as unclean		;041
30$:	ADD	#40$-20$,FIPERX ;Set error trap in case of SATBUF errors ;041
	CALL	WOMSAT		;WOMP SAT IF NECESSARY
	BR	50$		;It worked, that's good			;041

40$:	CLRB	@#SATMOD	;Error cleaning up SATBUF, stop trying	;041
	MOVB	@#SATUNT,R4	;Pick up unit number in SATBUF		;041
	ASL	R4		;Make it a word index			;041
	BIS	#UO.CLN,UNTOPT(R4) ;And mark it as unclean		;041

50$:	MOV	FIPESP,SP	;Restore SP in case we got errors	;041
	MOVB	FIJOB,R4	;GET CURRENT JOB #
	BNE	60$		;THIS IS A NORMAL JOB
	MOV	FIPSJN,R1	;GET THE SYSTEM JOB NUMBER
	MOV	SJBCQR+1(R1),R0	;GET POINTER TO QUE ROOT
	MOV	SJBTBL+1(R1),R4	;GET POINTER TO SYSTEM JOB DDB
	MOV	JDWORK(R4),R4	;GET POINTER TO SYSTEM JOB WORK BLOCK
	CALLX	QUEUE0,R5	;GET THE WORKBLOCK BACK TO THE SYSTEM JOB
	MOV	SJBL3Q+1(R1),R0	;GET L3QBIT TO SET
	CALLX	L3QSE0,R5	;SET THE L3QBIT SO SYSTEM JOB RUNS
	TST	(SP)+		;CLEAN THE STACK
	CLR	FIPSJN		;FLAG NO SYSJOB
	CLR	JOBTBL		;FREE UP THE NULL JOB
	CLR	JBWAIT		;FLAG WAITING FOR NOTHING
	BR	90$		;GO ON TO NEXT REQUEST			;033

60$:	MOV	#0,@#X.TAB+<<SEG.FH*XMTLEN>+XM.ADD> ;None to dump	;067
	TST	JBWAIT(R4)	;SPECIAL SLEEPING CONDITION?
	BNE	70$		;NOPE
	MOV	#JSTIM!JS.KB,JBWAIT(R4) ;YES, CHANGE WAIT CONDITION
70$:	TST	(SP)+		;SHOULD WE SET "JSFIP"?
	BMI	80$		;NOT THIS TIME...
	CALLX	IOFIP4		;YES, SO AWAKEN THE JOB
80$:	CMPB	#STAFQ,FIPFUN	;Is this system startup?		;033
	BNE	90$		;No, not this time			;033
	MOV	FIJBDA,R4	;R4 -> JDB for job in FIP		;033
	TSTB	JDIOST(R4)	;Error?					;033
	BEQ	90$		;No, so the system started up OK	;033
	BIS	#JFSPCL,JDFLG(R5) ;Yes, so set special condition	;033
	MOVB	#JFPRTY,JDFLG2(R4) ;as report IOSTS to P.BAD		;033

; Note: The setting of JFPRTY above will cause SCH to report the error 	;033
; in JDIOST to the primary RTS at its P.BAD entry point. As a result,	;033
; any errors which occur during system startup (mounting disks, running	;033
; START.COM, loading overlays, etc.) will be reported to the user	;033
; starting up the system.						;033

90$:	MOV	(SP)+,FIQUE	;POP NEXT REQUEST FROM QUEUE		;033
	BEQ	FIPMON		;Exit if there isn't one		;022
	MAP	FIPPOL		;Be sure FIP pool is mapped		;042
	JMP	FIPNXT		;And start next request			;022

FIPMON:	MOV	FIPR6,SP	;RESTORE SYSTEM STACK
	CLR	FIPR6		; AND INDICATE NO LONGER SAVED
	JMPX	RTI3		;NOW BACK TO THE MONITOR

GLOBAL	<FIQUE,FIPERX,FIJOB,JBWAIT,FIPR6,FIPSJN,SJBL3Q,SJBCQR,FIJBDA>	;033
GLOBAL	<FIPFUN,FISTAK,FIPESP,UNTOPT,FIBMOD,FIBUNT,SATMOD,SATUNT,X.TAB>	;067

.SBTTL	FIP ERROR EXITS

;+
; FIPDER - FIP DISK ERRORS.
;
;	JMP	FIPDER
;-

FIPDER:	MOVB	FIPAR+DSQERR,R0	;GET ERROR CODE

;+
; FIPERR - FIP ERRORS.
;
;	R0 =  ERROR CODE
;
;	JMP	FIPERR
;-

	TMPORG	FIPDSP,4
	.WORD	FIPERR
	UNORG

FIPERR:	MOV	FIJBDA,R1	;GET JOB'S DATA AREA POINTER
	TSTB	R0		;Did we get a specific error?		;039
	BNE	10$		;Yes, that's good			;039
	SETERR	ABORT,R0	;No, so set the generic error code	;039
10$:	MOV	FIPERX,-(SP)	;Get the error trap address and flag	;039
	BIT	#1,(SP)		;Should we report errors to JDIOST?	;039
	BNE	20$		;No, not this time			;039
	MOVB	R0,JDIOST(R1)	;SET IOSTS FOR NON-RUNNING JOB
20$:	BIC	#1,(SP)		;Correct error trap address		;039
	BNE	FIPRPC		;ONE EXISTS, USE IT
	MOV	#FIEXIT,(SP)	;NONE, USE THE STANDARD ERROR EXIT	;037
	BIT	#J2FSPW,JDFLG3(R1) ;Job being spawned?			;054
	BEQ	30$		;No, so no special handling
	BIS	#JFSPCL,JDFLG(R1) ;Yes, kill this job
	BISB	#JFKILL,JDFLG2(R1) ; by setting special condition and kill
30$:	MOVB	FIJOB,R0	;GET THE JOB NUMBER
	BIT	#JSFIP,JBWAIT(R0) ;WAITING FOR FIP ?
	BNE	FIPRPC		;YES, TAKE ERROR EXIT
	CRASH			;NOPE, GOOF!!!, CRASH THE SYSTEM

GLOBAL	<FIPAR,FIJBDA,FIPERX,FIJOB,JBWAIT,JOBTBL>

.SBTTL	FIP'S STALL AND COMPLETION CONTINUE

;+
; FIPWAT - STALL UNTIL COMPLETION L3Q BIT IS SET.
;
;	CALL	FIPWAT
;
;	C=0 ALWAYS
;-

FIPWAT::CLR	FIPLSB		;Unknown wait, zero address LSB		;039
	CLRB	FIPMSB		;And address MSB			;039
FIPWTX:	REGSCR			;SAVE ALL REGISTERS			;039
	CMP	SP,#SYSTAK	;ARE WE RUNNING ON THE SYSTEM STACK?
	BHI	10$		;NO, FIP STACK SO IT'S COOL
	CRASH			;CAN'T FIP STALL ON THE SYSTEM STACK!

10$:	MAP	PUSH,APR=5,CODE,DATA ;SAVE THE APR 5 MAPPING ALSO
	MOV	OVBTBL,-(SP)	;Save current overlay base table	;066
	MOV	CPUTIM,-(SP)	;Remember who we were charging		;054
	MOV	SP,FIPSP	; AND REMEMBER WHERE FIP'S STACK WAS
	BR	FIPMON		;RESTORE OLD STACK AND EXIT

.ENABL	LSB

	L3QENT	QFIP,10$-20000,FIPAP6 ;WE RESTART WAY DOWN HERE IN APR 5

10$:	MAP	FIP,CODE,DATA	;Go and map the file processor		;042

.DSABL	LSB

	ADD	#20000,PC	; AND COME BACK UP HERE TO APR 6
	MOV	SP,FIPR6	;SAVE THE SYSTEM STACK FOR LATER
	MOV	FIPSP,SP	; AND GET BACK FIP'S OLD STACK
	MOV	(SP)+,CPUTIM	;START CHARGING USER AGAIN		;054
	MOV	(SP)+,OVBTBL	;Restore current overlay base table	;066
	MAP	POP,APR=5,CODE,DATA ;RESTORE THE APR 5 MAPPING
	;CLC			;C=0 FROM "ADD" (L3Q LEAVES C=0 ALSO)
FIPRPC:	RETURN			;RESTORE REGISTERS AND EXIT

GLOBAL	<SYSTAK,FIPSP,FIPR6,FIJBD2,FIPLSB,FIPMSB,FIPAP6>		;042

.SBTTL	FIP AUTOMATIC PAGING CODE

;+
; FCALL - CALL ANOTHER FIP OVERLAY
;
;	FCALL	SUBR		EXPANDS TO:	JSR	PC,FCALL
;						.WORD	SUBR
;	-OR-
;
;	FCALLI	SUBR		EXPANDS TO:	JSR	PC,FCALL
;						.WORD	SUBR+1
;	-OR-
;
;	FCALL	(R5)		EXPANDS TO:	JSR	PC,FCALX
;
; ON THE CALL:	 R0-R5 = PRESERVED FROM CALLER TO SUBROUTINE
;	      ALL CC'S = UNDEFINED
;		FIPUNT = SYSTEM DISK UNIT  **UNLESS SYSTEM STACK**
;		FIPGEN = 0 (SPECIFIC)      **UNLESS SYSTEM STACK**
;		   SP -> SAVED CONTEXT ON TOP OF CALLER'S STACK
;			 DON'T COUNT ON THE NUMBER OF WORDS OF CONTEXT!!!
;
; ON RETURN:	 R0-R5 = PRESERVED FROM SUBROUTINE TO CALLER
;		 C-BIT = PRESERVED FROM SUBROUTINE TO CALLER
;	    N,Z,V-BITS = UNDEFINED
;		FIPUNT = SYSTEM DISK UNIT  **UNLESS SYSTEM STACK**
;		FIPGEN = 0 (SPECIFIC)      **UNLESS SYSTEM STACK**
;		    SP = RESTORED
;-

.ENABL	LSB

F2CALX::TST	(PC)+		;CLC and skip over SEC			;062
F2CALL::SEC			;Indicate FCALL instead of FCALLX	;062
	MOV	OVBTBL,-(SP)	;Save current overlay base table value	;065
	MOV	O2BASE,OVBTBL	;Select O2BASE for overlay base table	;062
	BR	5$		;Join common				;062

FCALX::	TST	(PC)+		;SET C=0 AND SKIP THE 'SEC'
FCALL::	SEC			;SET C=1
	MOV	OVBTBL,-(SP)	;Save current overlay base table value	;065
	MOV	OVBASE,OVBTBL	;Select OVBASE for overlay base table	;062
5$:	MOV	FIPOVR,-(SP)	;Save the current overlay value		;033
	MOV	KISAR5,-(SP)	;SAVE APR 5 MAPPING (IN CASE WE'RE RESIDENT)
	MOV	#FRET,-(SP)	;SET ADDRESS OF FCALL RETURN HANDLER
	INC	-(SP)		;MAKE ROOM FOR TARGET ADDRESS (PRESERVE C-BIT)
	MOV	R5,-(SP)	;SAVE R5
	BCC	10$		;R5 HAS TARGET "ADDRESS" IF C=0, FCALX ENTRY
	BIC	#30000,@#PS	;Be sure that previous mode = Kernel	;042
	MFPI	@14(SP)		;Get the address to transfer control to	;042
	MOV	(SP)+,R5	;Now get it the proper register		;042
	ADD	#2,14(SP)	; THEN BUMP PC OVER THE CALLING ADDRESS	;033
10$:	CMP	KISAR5,OVRBUF	;EXECUTING FROM OVRBUF?
	BNE	30$		;NO, SO THE RESIDENT RETURN IS ALL SET UP
	MOV	FIPVBN,-(SP)	;YES, GET VBN*4 OF OVERLAY IN OVRBUF
	BIC	#1000,(SP)	;clear out incase it's in OV2		;062
	ASR	(SP)		;CONVERT VBN*4 TO "ADDRESS" AT THE START
	SWAB	(SP)		; OF THE OVERLAY IN OVRBUF
	SUB	#120000,(SP)	;SUBTRACT THE VIRTUAL ADDRESS OF OVRBUF
	ADD	(SP)+,14(SP)	; AND COMPUTE OUR CALLER'S RETURN "ADDRESS" ;033
	CLR	6(SP)		;FLAG THAT WE'RE RETURNING TO AN "ADDRESS"
	BR	30$		;NOW THE NON-RESIDENT RETURN IS ALL SET UP,
				; SO GO JOIN THE COMMON CODE WITH FJMP

GLOBAL	<FIPVBN,FIPOVR>							;033
GLOBAL	<OVBASE,O2BASE,OVBTBL>						;062

;+
; FJMP - JUMP TO ANOTHER FIP OVERLAY
;
;	FJMP	TARGET		EXPANDS TO:	JSR	R5,FJMP
;						.WORD	TARGET
;	-OR-
;
;	FJMPI	TARGET		EXPANDS TO:	JSR	R5,FJMP
;						.WORD	TARGET+1
;	-OR-
;
;	FJMP	(R5)		EXPANDS TO:	JMP	FJMPX
;
;	R0-R5,SP = PRESERVED ACCROSS THE JUMP
;	ALL CC'S = UNDEFINED
;	  FIPUNT = SYSTEM DISK UNIT  **UNLESS SYSTEM STACK**
;	  FIPGEN = 0 (SPECIFIC)      **UNLESS SYSTEM STACK**
;-

F2JMPX::MOV	O2BASE,OVBTBL	;Select O2BASE as overlay base table	;062
	BR	17$		;Join common				;062

FJMPX::	MOV	OVBASE,OVBTBL	;Select OVBASE as overlay base table	;062
17$:	MOV	R5,-(SP)	;MATCH CONVENTIONS
	BR	20$		; AND JOIN UP

F2JMP::	MOV	O2BASE,OVBTBL	;Select O2BASE as overlay base table	;062
	BR	18$		;Join common				;062

FJMP::	MOV	OVBASE,OVBTBL	;Select OVBASE as overlay base table	;062
18$:	BIC	#30000,@#PS	;Be sure that previous mode = Kernel	;042
	MFPI	(R5)+		;Get the "address" to go to		;042
	MOV	(SP)+,R5	;Now get it in the proper place		;042
20$:	MOV	(SP),-(SP)	;MAKE HOLE FOR THE "ADDRESS"
30$:	BIT	R5,#1		;DO AND INDIRECT ON THE "ADDRESS"?
	BEQ	40$		;NOPE, ALREADY THE REAL "ADDRESS"
	MOV	-1(R5),R5	;YES, GET THE REAL "ADDRESS"
	BIC	#1,R5		; AND ENSURE NO ODD ADDRESS TRAPS FROM IT
40$:	CALL	LODFIP		;MAKE SURE THAT TARGET IS LOADED/MAPPED
	BCS	50$		;NON-RES OVERLAY AND SYSTEM STACK: COMPLAIN!
	MOV	R5,2(SP)	;PLUG TRANSFER INTO ITS SAVED LOCATION
	MOV	(SP)+,R5	;RESTORE R5
	RETURN			; AND OFF TO TARGET

50$:	CRASH			;FCALL OR FJMP TO A NON-RESIDENT OVERLAY
				; WHILE EXECUTING OFF THE SYSTEM STACK!

GLOBAL	<OVBASE,O2BASE,OVBTBL>						;062

.DSABL	LSB

;
; FRET - RETURN FROM FCALL COMES HERE
;
; IF FIRST WORD ON STACK IS NON-ZERO:
;
;	FCALL WAS FROM A RESIDENT OVERLAY.  FIRST WORD CONTAINS THE MMU
;	VALUE TO REMAP THE OVERLAY.  Second word contains the overlay ID
;	used by the statistics module. THIRD WORD CONTAINS THE VIRTUAL
;	ADDRESS IN THE OVERLAY AT WHICH TO RETURN.
;
; IF FIRST WORD ON STACK IS ZERO:
;
;	FCALL WAS FROM A NON-RESIDENT OVERLAY IN OVRBUF.  Second word
;	contains the overlay ID used by the statistics module. THIRD WORD
;	CONTAINS THE LODFIP "ADDRESS" TO RETURN TO.

.ENABL	LSB

FRET:	MOV	(SP),@#KISAR5	;GUESS AT RESIDENT OVERLAY, RESTORE I-MAPPING
	BEQ	10$		;BAD GUESS, GO LOAD NON-RESIDENT OVERLAY
	ROR	(SP)		;SAVE THE C-BIT HERE
	CALL	90$		;MUNG FIPUNT AND FIPGEN IF ON FIP STACK
	BR	20$		;RESTORE C-BIT AND RETURN TO RESIDENT CALLER

10$:	ROR	(SP)		;SAVE THE C-BIT HERE
	MOV	R5,-(SP)	;AND SAVE R5
	MOV	6(SP),OVBTBL	;Restore overlay base table reference	;065
	MOV	10(SP),R5	;GET SAVED OVERLAY "ADDRESS"		;033
	CALL	LODFIP		;RELOAD THE "FCALLING" OVERLAY IF NECESSARY
	MOV	R5,10(SP)	;SET UP OUR FINAL VIRTUAL RETURN ADDRESS ;033
	MOV	(SP)+,R5	;RESTORE R5
20$:	ROL	(SP)+		;RESTORE C-BIT VALUE
	MOV	(SP)+,FIPOVR	;Restore the FIP overlay value		;033
	INC	(SP)+		;Ignore OVBTBL entry, PRESERVING C-BIT	;065
	RETURN			; AND RETURN TO "FCALLING" OVERLAY

GLOBAL	<DPAR5,FIPOVR>							;033
GLOBAL	<OVBTBL>							;063

.SBTTL	LOAD A FIP FUNCTION

;+
; LODFIP - TRY TO LOAD A FIP FUNCTION.
;
;	R5 =  FUNCTION'S "ADDRESS"
;
;	CALL	LODFIP
;
;	C=1 -> NON-RESIDENT MODULE AND WE'RE USING THE SYSTEM STACK!
;	C=0 -> FUNCTION LOADED AND READY:
;
;		R5 =  TRANSFER ADDRESS TO USE
;		FIPUNT = SYSTEM DISK UNIT	**UNLESS SYSTEM STACK**
;		FIPGEN = 0 (SPECIFIC)		**UNLESS SYSTEM STACK**
;-

LODFIP:	REGSCR			;SAVE ALL REGISTERS
	MOV	R5,R1		;COPY FUNCTION'S "ADDRESS"
	BIC	#^C<777>,R5	; TO GET OFFSET WITHIN BLOCK,
	BIC	R5,R1		;  AND BLOCK NUMBER * 4 WITHIN
	ASHC	#-7,R1		;   THE OVERLAY VIRTUAL ADDRESS RANGE
	MOV	R1,R0		;COPY THE VIRTUAL BLOCK NUMBER * 4
	ADD	OVBTBL,R1	;POINT TO DESCRIPTOR FOR THIS BLOCK	;062
	MOV	(R1)+,R4	;IS THE OVERLAY RESIDENT OR NON-RESIDENT?
	BPL	30$		;NON-RESIDENT
	ADD	R4,R5		;RESIDENT, GET THE FINAL DISPATCH ADDRESS
	MAP	(R1),APR=5,CODE	;MAP THE OVERLAY
	BR	80$		;SET CALLER'S R5, CHECK STACK AND EXIT

GLOBAL	<OVBTBL>							;062

30$:	CMP	SP,#SYSTAK	;ARE WE RUNNING ON THE SYSTEM STACK?
	BLO	100$		;YES, EXIT WITH C=1 (SINCE BLO=BCS)
	CMP	O2BASE,OVBTBL	;OV2 overlay call?			;062
	BNE	32$		;no					;062
	BIS	#1000,R0	;Flag its VBN as being in OV2		;062
32$:	CMP	R0,FIPVBN	;FIP STACK, OVERLAY ALREADY IN FIBUF?
	BEQ	70$		;YES, NO I/O NEEDED
	MOV	OVBASU+F.FBNL,R2 ;GET USER'S OVERLAY FILE LSB
	MOV	OVBASU,R3	;GET MSB/UNIT OF USER'S FILE
	BNE	40$		;NON-ZERO, SO USER FILE DOES EXIST
	TST	R2		;REALLY THERE?
	BEQ	50$		;NO
40$:	MOV	#FIPAR+DSQMAM,R4 ;GET POINTER TO DSQ @MSB MEMORY
	CLRB	(R4)+		;CLEAR THE HIGH BYTE AND LOW WORD
.ASSUME	DSQMAL	EQ	DSQMAM+1
	CLR	(R4)+		; TO INDICATE I/O TO R4 ADDRESS (0 -> OVRBUF)
.ASSUME	DSQCNT	EQ	DSQMAL+2
	MOV	#400,(R4)	;  OF ONE BLOCK
	CALL	110$		;SET UP THE UNIT/ADDRESS
	MOV	R0,-(SP)	;COPY THE VIRTUAL BLOCK TIMES 4
	ASR	(SP)		; AND FIND VIRTUAL
	ASR	(SP)		;  BLOCK
	CMP	OVBTBL,O2BASE	;Are we trying an overlay in OV2?	;064
	BNE	45$		;No, it is in OVR			;064
	BIC	#<1000/4>,(SP)	;Clear out OV2 flag			;064
	MOV	O2BASE,-(SP)	;Get start of O2BASE on stack		;064
	SUB	OVBASE,(SP)	;-OVBASE to get blocks * 4 for OV2 offset;064
	ASR	(SP)		; Convert to				;064
	ASR	(SP)		;  Blocks * 1				;064
	ADD	(SP)+,(SP)	;Add result to virtual offset		;064
45$:	ADD	(SP)+,R2	;ADD TO LSB AND
	ADC	R3		; CARRY TO MSB
	CALL	FIPIOE,R5	;READ FROM USER'S FILE (WITH ERROR EXIT)
	BR	60$		;ALL OK
	.BR	50$		;ERROR, TRY FROM THE .SIL FILE
50$:	MOV	(R1),R2		;GET LSB OF .SIL FILE
	MOV	-(R1),R3	; AND .SIL MSB/UNIT
	CALL	110$		;SET UP THE UNIT/ADDRESS
	CALL	FIPIO4,R5	;READ IN FROM .SIL FILE
60$:	MOV	R0,FIPVBN	;REMEMBER WHAT'S NOW IN "OVRBUF"
70$:	ADD	#120000,R5	;GET THE DISPATCH ADDRESS IN APR 5
	MAP	OVRBUF,APR=5,CODE,DATA ;AND MAP OVRBUF
80$:	MOV	R5,TOS.R5(SP)	;RETURN THE VIRTUAL DISPATCH ADDRESS
	CMP	#SYSTAK,SP	;Are we running on system stack?	;033
	BHIS	100$		;Yes, resident overlay, exit C=0 (BHIS=BCC) ;033
	MOV	R0,FIPOVR	;Remember the FIP overlay		;033

90$:	CMP	#SYSTAK,SP	;RUNNING ON SYSTEM STACK?
	BHIS	100$		;YES, AND RES OVR, EXIT C=0 (BHIS=BCC)
	MOVB	SYSUNT,FIPUNT	;FIP STACK: SET FIP UNIT AS SYSTEM DISK
	CLRB	FIPGEN		; AND SET SPECIFIC SEARCHES
	;CLC			;(C=0 FROM THE CLRB)
100$:	RETURN			;NOW EXIT

110$:	MOVB	R3,FIPAR+DSQUNT	;LOAD THE CORRECT OVERLAY UNIT
	CLRB	R3		;NOW ISOLATE THE
	SWAB	R3		; MSB OF THE DISK ADDRESS
	CLR	R4		;INDICATE I/O TO OVRBUF
	MOV	#<-1*400+RFUN>,FIPAR+DSQFUN ; AS HIGH PRIORITY READ
	CLR	FIPVBN		;NOT THERE YET, BUT IT SHOULD BE SOON...
	RETURN			;EXIT

.DSABL	LSB

GLOBAL	<SYSTAK,FIPVBN,OVBASU,FIPAR,OVRBUF,SYSUNT,FIPUNT,FIPGEN,FIPOVR>	;033
GLOBAL	<O2BASE,OVBASE>							;064

.SBTTL	FIP'S I/O

;+
; FIPIO4 - DO FIP I/O TO R4 BUFFER ADDRESS
;
;	R2 =  LSB OF DESIRED FBN
;	R3 =  MSB OF DESIRED FBN
;	R4 =  BUFFER ADDRESS
;	   =  0  IF WE SHOULD DO I/O TO OVRBUF
;	FIPAR+DSQUNT = FIP UNIT NUMBER
;	FIPAR+DSQFUN = FUNCTION AND FAIRNESS COUNT
;
;	CALL	FIPIO4,R5
;
;	C=0 ALWAYS
;-

.ENABL	LSB

FIPIO4:	CLR	@#FIPAR+DSQMAL	;SAY I/O TO THE BUFFER SPECIFIED IN R4
	BR	10$		;NOW JOIN COMMON CODE

;+
; FIPIOS - DO I/O TO SATBUF
;
;	R2 =  LSB OF DESIRED FBN
;	R3 =  MSB OF DESIRED FBN
;	FIPUNT = FIP UNIT NUMBER
;	FIPAR+DSQFUN = FUNCTION AND FAIRNESS COUNT
;
;	CALL	FIPIOS,R5
;
;	C=0 ALWAYS
;-

FIPIOS:	MOV	#SATBUF,FIPAR+DSQMAL ;INDICATE I/O TO SATBUF
	.BR	FIPIO		;THE REST IS THE SAME AS FIPIO

;+
; FIPIO - DO FIP I/O.
;
;	R2 =  LSB OF DESIRED FBN
;	R3 =  MSB OF DESIRED FBN
;	R4 =  BUFFER ADDRESS IF FIPAR+DSQMAL = 0
;	   =  0  IF WE SHOULD DO I/O TO OVRBUF
;	FIPUNT = FIP UNIT NUMBER
;	FIPAR+DSQFUN = FUNCTION AND FAIRNESS COUNT
;	FIPAR+DSQMAL = BUFFER ADDRESS
;
;	CALL	FIPIO,R5
;
;	C=0 ALWAYS
;-

FIPIO:	MOVB	FIPUNT,@#FIPAR+DSQUNT ;SET FIPUNT AS THE UNIT
	BR	10$		;NOW JOIN COMMON CODE

;+
; FIPIOE - DO FIP I/O WITH ERROR RETURN
;
;	R2 =  LSB OF DESIRED FBN
;	R3 =  MSB OF DESIRED FBN
;	R4 =  BUFFER ADDRESS IF FIPAR+DSQMAL = 0
;	   =  0  IF WE SHOULD DO I/O TO OVRBUF
;	FIPAR+DSQCNT = NUMBER OF WORDS TO TRANSFER
;	FIPAR+DSQUNT = FIP UNIT NUMBER
;	FIPAR+DSQFUN = FUNCTION AND FAIRNESS COUNT
;	FIPAR+DSQMAM = MSB OF BUFFER ADDRESS
;	FIPAR+DSQMAL = LSB OF BUFFER ADDRESS
;
;	CALL	FIPIOE,R5
;
;	FIRST RETURN MEANS NO ERROR
;
;	SECOND RETURN MEANS DISK ERROR
;-

FIPIOE::MOV	R5,-(SP)	;CALCULATE THE
	ADD	#2,(SP)		; ERROR RETURN ADDRESS
	BR	20$		;NOW JOIN COMMON CODE

;+
; PARSEX - DO FIP I/O.
;
;	R2 =  LSB OF DESIRED FBN
;	R3 =  MSB OF DESIRED FBN
;	R4 =  BUFFER ADDRESS IF ARGUMENT BUFFER IS 0
;	   =  0  IF WE SHOULD DO I/O TO OVRBUF
;	FIPAR+DSQUNT = FIP UNIT NUMBER
;
;	CALL	PARSEX,R5,<FUNCTION,BUFFER>
;
;	C=0 ALWAYS
;-

PARSEX::MOV	(R5)+,FIPAR+DSQFUN ;SET THE SUPPLIED FUNCTION AND FAIRNESS
	MOV	(R5)+,FIPAR+DSQMAL ;SET THE SUPPLIED BUFFER ADDRESS
10$:	MOV	#FIPDER,-(SP)	;SET ERROR RETURN ADDRESS
	CLRB	FIPAR+DSQMAM	;CLEAR THE EXTENDED PART OF THE ADDRESS
	MOV	#400,FIPAR+DSQCNT ; AND SET UP FOR A ONE BLOCK READ
20$:	MOV	R0,-(SP)	;SAVE R0
	MOV	R4,-(SP)	; AND R4
	MAP	PUSH,APR=5,DATA	;Save APR5 data mapping			;054
	MAP	FIPJC6,APR=5,DATA ;And map the JCR entry		;054
	MOV	FIPJCR,R0	;Get pointer to JCR entry		;054
	MOV	#FIPAR+DSQFUN,R4 ;GET THE FIP PARAMETER BLOCK POINTER
	TSTB	JCPRI+<120000-140000>(R0) ;RUNNING WITH HIGH PRIORITY?	;054
	BLE	30$		;NO
	BIS	#-1*400,(R4)	;YES, SET EXPIRED FAIRNESS COUNT
.ASSUME	DSQFAR	EQ	DSQFUN+1

GLOBAL	<FIPAR,FIJBDA,FIPJC6,FIPJCR>					;054

30$:	MAP	POP,APR=5,DATA	;Restore mapping			;054
	CMPB	(R4),#WFUN	;IS THIS A WRITE?
	BHI	40$		;NO
	MOVB	FIPAR+DSQUNT,R0	;GET THE UNIT INVOLVED
	ASL	R0		; TIMES 2 FOR WORD ADDRESSING
	BIT	#UO.WCF,UNTOPT(R0) ;DO WRITE CHECKING?			;024
	BEQ	40$		;NOPE
	CLRB	(R4)		;DO A WRITE WITH WRITE CHECK
.ASSUME	WFUN.C	EQ	0
40$:	TST	-(R4)		;SKIP THE WORD COUNT (DSQCNT)
	TST	-(R4)		;WAS A BUFFER ADDRESS SUPPLIED (DSQMAL<>0)?
	BNE	50$		;YES, WE'RE ALL SET
	TSTB	-(R4)		;REALLY, WAS ONE THERE (DSQMAM<>0)?
	BNE	60$		;YES, HIGH ORDER WAS NON-ZERO
	MOV	(SP),DSQMAL-DSQMAM(R4) ; ELSE USE R4 FOR BUFFER ADDRESS
	BNE	60$		; IF ANY...
	MOV	R1,-(SP)	;  ELSE USE OVRBUF.  SAVE R1
	MOV	OVRBUF,R1	;MMU ADDRESS OF OVRBUF
	CLR	R0		;CLEAR OUT FOR THE SHIFT
	ASHC	#6,R0		;COMPUTE PHYSICAL ADDRESS OF OVRBUF
	MOVB	R0,(R4)+	;SET THE MSB ADDRESS OF OVRBUF
	MOV	R1,(R4)		;SET THE LSB ADDRESS OF OVRBUF
	MOV	(SP)+,R1	;RESTORE R1
50$:	DEC	R4		;POINT PAST THE EXTENDED ADDRESS
60$:	MOVB	(R4),FIPMSB	;Set MSB of FIP I/O address for stats	;039
	MOV	DSQMAL-DSQMAM(R4),FIPLSB ;And set LSB of I/O address	;039
	CLRB	-(R4)		;SET DSQRFN=0
	MOV	R2,-(R4)	;SET THE SUPPLIED FBN (LSB)
	MOVB	R3,-(R4)	; AND SET EXTENDED FBN (MSB)
	DEC	R4		;SKIP OVER THE UNIT @ DSQUNT
	MOV	#FPDNE,-(R4)	;SET COMPLETION QUEUE(NONE)/L3Q BIT @ DSQL3Q
	MOV	FIJOB,-(R4)	;SET JOB NUMBER *2 (& DSQERR = ??)
	CLR	-(R4)		;NOW UP TOP
	CALLX	DISK		; AND START THE OPERATION
	MOV	(SP)+,R4	;RESTORE R4
	MOV	(SP)+,R0	; AND R0
	CALL	FIPWTX		;NOW STALL UNTIL I/O COMPLETE		;039
	TSTB	FIPAR+DSQERR	;ERROR?
	BMI	70$		;NO
	MOV	(SP),R5		;YES, CHANGE RETURN ADDRESS
70$:	TST	(SP)+		;POP ERROR RETURN ADDRESS
	;CLC			;C=0 FROM 'TST' ABOVE
	RETURN	R5		;NOW EXIT

.DSABL	LSB

GLOBAL	<FIPAR,UNTOPT,OVRBUF,FPDNE,FIJOB,FIPLSB,FIPMSB>			;039

AUTOSZ::MOV	#IFUN,@#FIPAR+DSQFUN	;SET FUNCTION AS INITIALIZE	;028
	MOV	#FIPDER,-(SP)		;SET ERROR RETURN ADDRESS	;028
	MOV	R4,-(SP)		;SAVE R4			;028
	MOV	#FIPAR+DSQUNT,R4	;R4 -> FIP DSQ @ DSQUNT		;028
	MOVB	FIPUNT,(R4)		;SET FIPUNT AS THE UNIT		;028
	MOV	#FPDNE,-(R4)		;SET COMPLETION QUEUE(NONE)/L3Q BIT @ DSQL3Q  ;028
	MOV	FIJOB,-(R4)		;SET JOB NUMBER *2 (& DSQERR = ??) ;028
	CLR	-(R4)			;NOW UP TOP			;028
	CALLX	DISK			; AND START THE OPERATION	;028
	MOV	(SP)+,R4		;RESTORE R4			;028
	CALL	FIPWAT			;NOW STALL UNTIL I/O COMPLETE	;028
	TSTB	FIPAR+DSQERR		;ERROR?				;028
	BMI	10$			;NO				;028
	MOV	(SP),2(SP)		;YES, CHANGE RETURN ADDRESS	;028
10$:	TST	(SP)+			;POP ERROR RETURN ADDRESS	;028
	;CLC				;C=0 FROM 'TST' ABOVE		;028
	RETURN				;NOW EXIT			;028

GLOBAL	<FIPAR,FPDNE,FIJOB>						;028

.SBTTL	SET DATE OF LAST ACCESS/WRITE

;+
; DATEIT - SET DATE OF LAST ACCESS/WRITE.
;
;	R5 -> ACCOUNTING ENTRY
;
;	CALL	DATEIT
;-

DATEIT::CMP	DATE,UDLA(R5)	;NEED TO CHANGE THE DATE?
	BEQ	10$		;NOPE, SO DON'T
	MOV	DATE,UDLA(R5)	;YEP, SO DO
	MARK	FIBUF		; AND MARK BUFFER FOR WRITE
10$:	RETURN			;NOW EXIT



.SBTTL	Mark FIP buffer

MRKFBF::MOVB	#-1,@#FIBMOD	;Mark the buffer, I-only code		;042
	RETURN								;029

GLOBAL	<FIBMOD>							;029

.SBTTL	GET THE NEXT UNIT

;+
; NXTUNT - GET NEXT UNIT.
;
;	FIPUNT = CURRENT UNIT
;
;	CALL	NXTUNT,R1,<MASK>
;
;	R2 =  NEXT UNIT
;	FIPUNT = NEXT UNIT
;
;	FIRST RETURN MEANS NO MORE
;
;	SECOND RETURN MEANS NEXT UNIT FOUND
;-

NXTUNT::MOV	(R1)+,R2	;GET CALLER'S MASK
NXTUN2::MOV	R2,-(SP)	;PUT IT ON THE STACK FOR NOW
	CALL	WRITEC		;Write FIBUF before FIPUNT change	;042
	MOVB	FIPUNT,R2	;GET THE CURRENT UNIT NUMBER
	ASL	R2		;TIMES 2 FOR WORD ADDRESSING
10$:	TST	(R2)+		;ADVANCE TO THE NEXT UNIT
	CMP	R2,#MAXUN2	;TOO FAR?
	BLOS	20$		;NO
	CLR	R2		;YES, RESET TO 0
20$:	CMPB	R2,SYSUN2	;BACK TO SYSTEM UNIT?
	BEQ	40$		;NO MORE IF SO
	BIT	(SP),UNTCNT(R2) ; DOES THIS MATCH WHAT IS WANTED?
	BNE	10$		;NOPE, TRY FOR ANOTHER
	BIT	#UC.LCK,UNTCNT(R2) ;Yes, is unit locked?		;037
	BEQ	30$		;No, skip				;037
	TSTPRV	DEVICE,FIPRVM	;Is caller privileged?			;037
	BEQ	10$		;No, skip this unit			;037
30$:	ASR	R2		;YES, BACK TO NOT TIMES 2 NOW
	MOVB	R2,FIPUNT	; AND SET THAT UNIT
	ADD	#2,R1		;TAKE THE 2ND EXIT (OR SKIP ARG + TAKE FIRST)
40$:	TST	(SP)+		;WE'RE THROUGH WITH THE MASK
	RETURN	R1		;NOW EXIT

GLOBAL	<FIPUNT,MAXUN2,SYSUN2,UNTCNT,FIPRVM>				;037

.SBTTL	GET DIRECTORY ENTRY

;+
; GDECR - GET A FREE DIRECTORY ENTRY (CREATING DIRECTORY).
;
;	FIPMUC = DIRECTORY CLUSTER SIZE
;
;	CALL	GDECR
;
;	R3 =  LINK OF ENTRY
;	R5 -> ENTRY
;
;	NOTE: ENTRY IS ALL CLEARED AND BUFFER MARKED.
;
;	IF C=0 THEN ENTRY FOUND
;	IF C=1 THEN NO ENTRY AVAILABLE
;-

.ENABL	LSB

GDECR::	MOV	R2,-(SP)	;SAVE A REGISTER
	CLR	-(SP)		;PUT FLAG WORD ON STACK FOR NOT FIRST TIME
	MOVB	FIPUNT,R2	;GET THE FIP UNIT #			;046
	ASL	R2		;FUN * 2				;046
	CMP	DIRPOS,#-1	;Did he ask for the middle?		;046
	BEQ	10$		;Yes					;046
	CMP	DIRPOS,#-2	;No, did he ask for close to SATT?	;046
	BNE	20$		;No					;046
	MOV	MFDPTR(R2),DIRPOS ;Get SATT location (next to MFD)	;046
	BR	20$		;Continue				;046

10$:	MOV	UNTSIZ(R2),R2	;GET THE SIZE IN DCN'S			;046
	;CLC			; (carry clear from CMP)		;046
	ROR	R2		;AND THE SIZE/2 (MIDDLE)
	MOV	R2,DIRPOS	;WILL BE THE DEFAULT POSITION.
20$:	ASR	R0		;Make it FUN * 1			;046
	CALL	WRITEC		;CLEAR FIBUF
	MOV	#FIBMAP,R5	;POINT TO MAP AREA
	MOV	FIPMUC,(R5)+	;SET DIRECTORY CLUSTER SIZE
30$:	CLR	(R5)+		;SET ALL DCN'S TO ZERO
	BIT	R5,#1000-1	;MORE?
	BNE	30$		;YES, LOOP
	CLRB	K		;SET CLUSTER(K) = 0
	BR	70$		;GO EXTEND THE DIRECTORY

GLOBAL	<FIBMAP,FIPMUC,K,FIPUNT,UNTSIZ,DIRPOS,MFDPTR>			;046

;+
; GDESV - GET A FREE DIRECTORY ENTRY MARKING BUFFER (EXTEND DIRECTORY IF NEEDED).
;
;	FIBUF HAS ANY BLOCK OF THE DIRECTORY
;
;	CALL	GDESV
;
;	R3 =  LINK OF ENTRY
;	R5 -> ENTRY
;
;	NOTE: ENTRY IS ALL CLEARED AND BUFFER MARKED.
;
;	IF C=0 THEN ENTRY FOUND
;	IF C=1 THEN NO ENTRY AVAILABLE
;-

GDESV::	MARK	FIBUF		;MARK BUFFER FOR WRITE
	.BR	GDE		;NOW GET AN ENTRY

;+
; GDE - GET A FREE DIRECTORY ENTRY (EXTEND DIRECTORY IF NEEDED).
;
;	FIBUF HAS ANY BLOCK OF THE DIRECTORY
;		(EXCEPT BLOCK 1 OR 2 OF NEW MFD'S OR GFD'S)
;
;	CALL	GDE
;
;	R3 =  LINK OF ENTRY
;	R5 -> ENTRY
;
;	NOTE: ENTRY IS ALL CLEARED AND BUFFER MARKED.
;
;	IF C=0 THEN ENTRY FOUND
;	IF C=1 THEN NO ENTRY AVAILABLE
;-

GDE::	MOV	R2,-(SP)	;SAVE A REGISTER
	MOV	(PC)+,-(SP)	;FIRST TIME MASK SETS J-1=177 (MAX), K=-1
	 .BYTE	177,-1
	CALL	CJK		;COMPUTE J & K FROM FIBFBN
	;CLC			;CLEAR CARRY FROM CJK FOR A HACK
40$:	ADC	R2		;BUMP FBN TO NEXT BLOCK IN DIRECTORY CLUSTER
	ADC	R3		; IF NOT FIRST BLOCK IN CLUSTER
	TST	FIBMAP		;NEW STYLE MFD OR GFD???
	BPL	50$		;NO, SO JUST CONTINUE
	CMP	J,#0*400+1	;ARE WE TRYING TO GET AT BLOCK 1, CLUSTER 0?
	BNE	50$		;NO, SO JUST CONTINUE
	ADD	#2,J		;YES, SO SKIP TO BLOCK 3
	ADD	#2,R2		;AND IN THE FBN ALSO
	ADC	R3		;MAKE SURE WE ADD IT EVERYWHERE
50$:	CALL	READ		;GET BLOCK R2,R3 INTO FIBUF
	CLR	R5		;START AT BEGINNING OF BLOCK
60$:	MOV	FIBUF(R5),-(SP)	;CHECK THE FIRST TWO WORDS
	BIS	FIBUF+2(R5),(SP)+ ; IF BOTH ARE ZERO
	BEQ	90$		;  THEN THIS IS A HOLE
	ADD	#20,R5		;BUMP THE BUFFER OFFSET TO NEXT
	CMP	R5,#760		;ARE WE INTO THE DIRECTORY CLUSTER MAP?
	BLO	60$		;IF NOT, THEN CONTINUE LOOKING
	BIS	(SP),J		;FIBUF BLOCK FULL. SET J=177, K=-1 IF FIRST
	INCB	J		;ADVANCE TO NEXT BLOCK IN CLUSTER
	CMPB	J,FIBMAP	;DONE WITH THIS CLUSTER? (FAILS IF J=200!)
	BLO	40$		;IF NOT, BLO => C=1, GO BUMP BLOCK & TRY AGAIN
	INCB	K		;ADVANCE TO NEXT CLUSTER (0 FIRST TIME)
70$:	CLR	(SP)		;OFF WITH FIRST TIME SWITCH
	CLRB	J		;BLOCK 0 WITHIN CLUSTER
	MOVB	K,R3		;GET CLUSTER
	CMP	#6,R3		;ARE DIRECTORY CLUSTERS 0-6 FULL?
	BLO	120$		;SO SOLLY, DIRECTORY FULL [C=1 EXIT]
	ASL	R3		;GOODY, DOUBLE CLUSTER NUMBER
	MOV	FIBENT(R3),R2	;R2 = MAP ENTRY
	BNE	80$		;IF IT'S THERE, USE IT
	CALL	EXTDIR		;TRY TO EXTEND THE DIRECTORY
	BCS	120$		;FAILED, EXIT C=1
80$:	CALLX	CNVDCN		;CONVERT MAP DCN TO FIP BLOCK #
	BR	50$		;NOW GO READ THAT BLOCK

GLOBAL	<FIBUF,J,FIBMAP,K,FIBENT>

90$:	CALL	PLK		;GOT A HOLE, PACK INTO A LINK
	TST	R3		;IS THIS THE FIRST?
	BNE	100$		;IF LINK 0 THEN 1ST ENT,1ST BLK,1ST CLU
	MOV	#20,R3		;IF SO, FUDGE LINK TO 20
	ADD	R3,R5		; AND CORRECT POINTER
	COM	FIBUF+2		;SET UP FIRST ENTRY TO BE DUMMY ENTRY
100$:	MARK	FIBUF		;MARK BUFFER FOR WRITING
	ADD	#20,R5		;R5 -> END OF FOUND ENTRY
	MOV	#20/2,R2	;COUNT OF WORDS IN ENTRY
110$:	CLR	-(R5)		;NOW CLEAR OUT THE HOLE
	SOB	R2,110$		;CLEAR ALL 8. WORDS
	;CLC			;C=0 FROM 'CLR' ABOVE
120$:	MOV	(SP)+,R2	;DUMP THE FIRST TIME FLAG
	MOV	(SP)+,R2	;RESTORE R2
	RETURN			; AND EXIT

.DSABL	LSB

GLOBAL	<FIBUF>

.SBTTL	EXTEND A DIRECTORY

;+
; EXTDIR - EXTEND A DIRECTORY.
;
;	R3 = [CLUSTER NUMBER TO ADD (0 TO 6)] * 2
;	FIBUF HAS ANY BLOCK OF THE DIRECTORY
;
;	CALL	EXTDIR
;
;	R2 =  DCN OF CLUSTER ADDED
;	IF C=0 THEN DIRECTORY WAS EXTENDED
;	IF C=1 THEN NO EXTENSION POSSIBLE
;-

EXTDIR:	REGSCR			;PRESERVE EVERYTHING
	MOVB	R3,R0		;GET CLUSTER NUMBER TO ADD (0-6) * 2
	ADD	#FIBENT-2,R0	;POINT TO PREVIOUS CLUSTER IN MAP
	MOV	FIBMAP,R1	;GET DIRECTORY CLUSTER SIZE
	TST	R3		;IS THE CLUSTER 0 (CREATING NEW??)
	BNE	10$		;NO, SO JUST DO IT THE OLD WAY
	MOV	DIRPOS,(R0)	;TEMPORARLY CLOBER FIBMAP WITH THE POS
10$:	MOVB	FIPUNT,R2	;GET THE UNIT INVOLVED
	ASL	R2		; TIMES 2 FOR WORD ADDRESSING
	ADD	#SATPTR,R2	;POINT LOGICAL S.A.T. POINTER FOR UNIT
	MOV	R2,-(SP)	;SAVE THE LOGICAL S.A.T. POINTER
	MOV	(R2),-(SP)	; AND THE CONTENTS THEREIN
	MOV	(R0)+,(R2)	;TRY TO KEEP DIRECTORY CLUSTERS ADJACENT
	MOV	R1,FIBMAP	;RESTORE THE CLUSTER SIZE INCASE WE
				; STOMPED ON IT FOR POSITIONING.
	MOVB	FIPUNT,R2	;Get FUN.				;068
	ASL	R2		;Times two for word addressing.		;068
	MOVB	UNTCLU(R2),R2	;Get units PCS.				;068
	BIC	#<^C377>,R2	;Get rid of sign extend (if any).	;068
	CMP	R2,R1		;Is PCS <= directory clustersize?	;068
	BLOS	15$		;Yes, so use dir clustersize as-is	;068
	MOV	R2,R1		;Otherwise, use PCS instead.		;068
15$:	CALL	GETCLU		;Get a cluster on the disk.		;068
	BCS	80$		;DISK TOO FULL TO FIND ONE (EXIT C=1)
	MOV	R2,R4		;SAVE THE DCN OF THE NEW CLUSTER
	MOV	R2,TOS.R2+4(SP)	;RETURN THAT DCN, TOO
	CALL	WRITEC		;CLEAR FIBUF
	MOV	#FIBUF,R5	;POINT TO DIRECTORY BUFFER
20$:	CLR	(R5)+		;NOW CLEAR THE BUFFER
	CMP	R5,#FIBMAP	;UP TO MAP AREA?
	BLO	20$		;NOT YET...
	MOV	R0,R5		;COPY POINTER TO NEW CLUSTER
	MOV	R4,(R5)+	;ADD THAT NEW CLUSTER TO MAP

GLOBAL	<K,FIBENT,FIPUNT,SATPTR,FIBMAP,FIBUF,DIRPOS,UNTCLU>		;068

30$:	MOV	-(R5),R2	;GET STARTING DCN OF NEXT CLUSTER
	CALLX	CNVDCN		;CONVERT DCN TO FBN OF DIR CLUSTER
	MOVB	FIBMAP,R1	;SET NUMBER OF BLOCKS IN A CLUSTER
	ADD	R1,R2		;GO TO THE LAST BLOCK
	ADC	R3		; OF CLUSTER +1
40$:	SUB	#1,R2		;NOW BACK 1 BLOCK WITHIN
	SBC	R3		; THIS CLUSTER
	CMP	R5,R0		;THE NEW CLUSTER?
	BEQ	60$		;YES, SO NO READ
	TST	FIBMAP		;NEW STYLE GFD OR MFD??
	BPL	50$		;NO, SO CONTINUE
	CMP	R5,#FIBENT	;ARE WE AT CLUSTER 0??
	BNE	50$		;NO, SO CONTINUE AS NORMAL
	CMP	R1,#3		;Are we looking at block 1 or 2?
	BHI	50$		;No, too high (note numbering off by 1)
	CMP	R1,#1		;Maybe, but is this block 0?
	BHI	70$		;No -- 1 and 2 are not updated	;019 &
50$:	CALL	READ		; ELSE READ BLOCK OF DIRECTORY CLUSTER
60$:	MOV	R4,(R0)		;PLUG NEW CLUSTER INTO THE MAP
	MOV	R3,FIBFBN	;SET THE FBN THAT
	MOV	R2,FIBFBN+F.FBNL ; WE WANT TO WRITE AND
	CALL	WRITE		;  WRITE IT OUT
70$:	SOB	R1,40$		;LOOP FOR NEXT BLOCK WITHIN CLUSTER
	CMP	#FIBENT,R5	;MORE CLUSTERS TO DO?
	BLO	30$		;YES, DO THEM...
	;CLC			;INDICATE SUCCESS
80$:	MOV	(SP)+,@(SP)+	;RESTORE THE LOGICAL S.A.T. POINTER
	RETURN			;EXIT

GLOBAL	<FIBMAP,FIBFBN,FIBENT>

.SBTTL	READ ENTRIES

;+
; RDETB - READ ENTRY WITH TABLE BLOCK IN FIBUF
;
;	R2 = LOW FBN OF THE BLOCK IN FIBUF (THE NAME BLOCKETTE TABLE)
;	R3 = HIGH FBN OF BLOCK IN FIBUF
;	R5 = LINK
;	FIBUF HAS BLOCK 2 OF DIRECTORY
;
;	CALL	RDETB
;
;	C = 0	ALWAYS
;	Z = 0	IF LINK WAS THERE, AND READ
;	Z = 1	IF NO LINK PASSED (BUT FIBUF CHANGED TO LABEL BLOCK)
;-

RDETB::	MOV	R5,-(SP)	;SAVE THE LINK FOR LATER
	SUB	#2,R2		;POINT BACK AT THE DIR LABEL
	SBC	R3		; REALLY POINT THERE
	ASH	#-12.,R5	;MOVE THE BLOCK # TO THE LOW 4 BITS
	BIC	#^C<17>,R5	;CLEAR THE HIGH BITS
	BIT	#UL.CLO,(SP)	;IS IT A REQUEST FOR CLUSTER 0
	BEQ	10$		; YES, SO READ THE BLOCK REQUESTED
	MOV	#3,R5		;SET UP TO READ BLOCK 3
10$:	ADD	R5,R2		;ADD THE REQUESTED BLOCK INTO THE FBN
	ADC	R3		;  REALLY GET TO THE RIGHT ONE
	CALL	READ		;NOW READ IN THE REQUESTED BLOCK
	MOV	FIBMAP,FIPMUC	;SET MFD CLUSTER SIZE
	MOV	(SP)+,R3	;GET THE LINK WORD BACK
	BR	RDECHK		;GO READ THE LINK, CHECKING

;+
; RDEPRV - READ NEXT ENTRY KEEPING PREVIOUS LINK.
;
;	R3 =  LINK OF CURRENT ENTRY
;	R5 -> LINK OF NEXT ENTRY
;	FIBUF HAS ANY BLOCK OF THE DIRECTORY
;
;	CALL	RDEPRV
;
;	R2 =  LINK OF PREVIOUS ENTRY (FROM R3)
;	R3 =  LINK OF ENTRY
;	R5 -> ENTRY
;
;	IF Z=0 THEN NEXT ENTRY READ
;	IF Z=1 THEN NO MORE ENTRIES
;-

RDEPRV::MOV	R3,R2		;MAKE CURRENT LINK INTO PREVIOUS LINK

;+
; RDENXT - READ NEXT ENTRY.
;
;	R5 -> LINK OF NEXT ENTRY
;	FIBUF HAS ANY BLOCK OF THE DIRECTORY
;
;	CALL	RDENXT
;
;	R3 =  LINK OF ENTRY
;	R5 -> ENTRY
;
;	IF Z=0 THEN NEXT ENTRY READ
;	IF Z=1 THEN NO MORE ENTRIES
;-

RDENXT::MOV	(R5),R3		;GET LINK OF NEXT ENTRY

;+
; RDECHK - CONDITIONALLY READ ENTRY.
;
;	R3 =  LINK OF ENTRY
;	FIBUF HAS ANY BLOCK OF THE DIRECTORY
;
;	CALL	RDECHK
;
;	R5 -> ENTRY
;
;	IF Z=0 THEN ENTRY READ, C=0
;	IF Z=1 THEN LINK WAS NULL, C=UNCHANGED
;-

RDECHK::BIT	R3,#UL.BLO!UL.CLO!UL.ENO ;NULL LINK?
	BNE	RDE		;NO, DO A REAL READ (EXIT Z=0)
	RETURN			;YES, EXIT Z=1, C UNCHANGED

;+
; RAE - READ ACCOUNTING ENTRY.
;
;	R5 -> NAME ENTRY
;
;	CALL	RAE
;
;	R3 =  LINK OF ACCOUNTING ENTRY
;	R5 -> ACCOUNTING ENTRY
;
;	C=0 ALWAYS
;-

RAE::	TST	(PC)+		;CLEAR CARRY, SKIP NEXT INSTRUCTION

;+
; RAESV - READ ACCOUNTING ENTRY MARKING CURRENT FOR WRITE.
;
;	R5 -> NAME ENTRY
;
;	CALL	RAE
;
;	R3 =  LINK OF ACCOUNTING ENTRY
;	R5 -> ACCOUNTING ENTRY
;
;	C=0 ALWAYS
;-

RAESV::	SEC			;SET CARRY
	MOV	UAA(R5),R3	;GET LINK TO ACCOUNTING ENTRY
	BCC	RDE		;GO READ IF NOT MARKING, ELSE FALL INTO RDESV

;+
; RDESV - READ ENTRY MARKING CURRENT FOR WRITE.
;
;	R3 =  LINK OF ENTRY
;	FIBUF HAS ANY BLOCK OF THE DIRECTORY
;
;	CALL	RDESV
;
;	R5 -> ENTRY
;
;	C=0 ALWAYS
;-

RDESV::	MARK	FIBUF		;MARK BUFFER FOR WRITE
	BR	RDE		; AND DO A READ

;+
; RDE - READ ENTRY.
;
;	R3 =  LINK OF ENTRY
;	FIBUF HAS ANY BLOCK OF THE DIRECTORY
;
;	CALL	RDE
;
;	R5 -> ENTRY
;
;	C=0 ALWAYS
;-

RDE::	MOV	R3,-(SP)	;SAVE LINK FOR LATER RESTORING
	MOV	R2,-(SP)	;SAVE CALLING R2
	CALL	UNPLNK		;UNPACK THAT LINK
	CALL	READ		;NOW WE CAN READ THE BLOCK
	MOV	(SP)+,R2	;RESTORE CALLING R2
	MOV	(SP)+,R3	; AND ORIGINAL LINK WORD
	;CLZ			;Z=0 SINCE LINK IS NON-ZERO (SEE 'RDECHK')
	;CLC			;C=0 FROM THE 'CALL READ'
20$:	RETURN			;NOW EXIT

;+
; UNPLNK - UNPACK LINK WORD
;
;	R3 =  LINK OF ENTRY
;	FIBUF HAS ANY BLOCK OF THE DIRECTORY
;
;	CALL	UNPLNK
;
;	R2 =  LSB OF FBN CONTAINING ENTRY
;	R3 =  MSB OF FBN CONTAINING ENTRY
;	R5 -> ENTRY LOCATION IN FIBUF IF READ
;-

UNPLNK::MOV	R3,R5		;COPY LINK INTO R5			;047
	BIC	#^C<UL.ENO>,R5	;LEAVE ONLY ENTRY OFFSET IN R5
	ADD	#FIBUF,R5	;R5 IS NOW THE ABS POINTER FOR EXIT
	BIC	#^C<UL.BLO!UL.CLO>,R3 ;LEAVE ONLY BLOCK/CLUSTER IN R3
	SWAB	R3		;GET REST OF LINK INTO LOW BITS
	MOV	R3,R2		;COPY WHAT IS LEFT OF LINK
	BIC	#^C<UL.CLO/400>,R2 ;LEAVE ONLY CLUSTER NUMBER *2 IN R2
	CMP	R2,#UL.CLO/400	;IS CLU NUM *2 LEGAL?
	BHIS	10$		;NO, BAD DIRECTORY ERROR
	MOV	FIBENT(R2),R2	;NOW GET MAP ENTRY
	BEQ	10$		;MUST BE NON-ZERO
	ASH	#-4,R3		;GET RID OF EXTRA BITS
	CMPB	R3,FIBMAP	;LEGAL BLOCK OFFSET?
	BHIS	10$		;NO, BAD DIRECTORY ERROR
	MOV	R3,-(SP)	;SAVE THAT OFFSET
	CALLX	CNVDCN		;CONVERT MAP ENTRY TO FBN
	ADD	(SP)+,R2	;ADD OFFSET FROM ABOVE TO FBN
	ADC	R3		; CARRION
	RETURN			;DONE

10$:	ERROR	BADDIR		;BAD DIRECTORY

GLOBAL	<FIBUF,FIBENT,FIBMAP>

.SBTTL	PACK AN FBB

;+
; PAKFBB - PACK AN FBB
;
;	R0 -> FBB TO LOAD
;	R3 =  LINK OF ENTRY
;	FIBUF HAS ANY BLOCK OF THE DIRECTORY
;
;	CALL	PAKFBB
;
;	R0 -> BEYOND FBB (PASSED R0 + 4)
;	R2 =  RANDOM
;	R3 =  RANDOM
;-

PAKFBB::BIT	R3,#UL.BLO!UL.CLO!UL.ENO ;IS THE LINK NULL?
	BEQ	10$		;IF SO, LOAD A NULL FBB
	MOV	R5,-(SP)	;SAVE R5
	CALL	UNPLNK		;UNPACK THE LINK
	ASR	R5		;CONVERT FIBUF ADDRESS TO OFFSET/2 (BYTE)
	MOVB	R5,(R0)+	;LOAD OFFSET/2
	MOVB	R3,(R0)+	; AND FBN MSB
	MOV	R2,(R0)+	;  AND FBN LSB
	MOV	(SP)+,R5	;RESTORE R5
	RETURN			; AND EXIT

10$:	MOV	#-1,(R0)	;FOR NULL LINK, MAKE ALL BYTES < 0
	MOV	(R0)+,(R0)+	; BY PUTTING -1 IN BOTH WORDS
	RETURN			;DONE

.SBTTL	SEARCHES ON DISK

;+
; SDMDCN - SEARCH MFD FOR A UFD'S DCN
;
;	R0 -> PPN
;	FIPUNT = UNIT
;
;	CALL	SDMDCN
;
;	R2 =  DCN FOUND
;	R3 =  LINK OF ENTRY (IF OLD DISK)
;	FIPMUC = MFD CLUSTER SIZE (IF OLD DISK)
;
;	IF C=0 THEN UFD FOUND
;	IF C=1 THEN UFD NOT FOUND
;-

.ENABL	LSB

SDMDCN::MOVB	FIPUNT,R5	;GET THE FUN
	ASL	R5		;MAKE IT THE FUN * 2
	TST	UNTLVL(R5)	;OLD DISK????
	BNE	20$		;NO, SO DO IT THE EASY WAY
	CALL	SDM		;GO GET IT THE OLD WAY
	BCS	10$		;NONE, THEN ERROR
	MOV	UAR(R5),R2	;RETURN THE DCN IN R2
	;CLC			;CARRY CLEAR TO SAY WE FOUND IT
10$:	RETURN			;AND ALL DONE NOW

20$:	CALL	30$		;GET THE GFD MAPPED
	BCS	60$		;IF CARRY SET, THEN NONE
	ADD	#1,R2		;GET BLOCK 2 OF THE GFD
	ADC	R3		;REALLY GET BLOCK 2
	CALL	READ		;AND READ IT IN
	CLR	R5		;START WITH A CLEAN PROGRAMMER #
	BISB	(R0),R5		;NOW, GET THE PROGRAMMER NUMBER
	ASL	R5		;MAKE IT *2 (AN INDEX)
	MOV	FIBUF(R5),R2	;GET THE DCN POINTER FOR THE UFD
	BEQ	60$		;IF NO UFD, THEN SAY SO
	BR	50$		; YES, SO RETURN IT

30$:	MOV	MFDPTR(R5),R2	;GET THE MFD'S DCN
	CALL	CNVDCN		;AND MAKE IT INTO AN FBN
	ADD	#1,R2		;GO TO THE NEXT FBN
	ADC	R3		;REALLY GET THE NEXT FBN
	CALL	READ		;NOW, GO READ THE DCN MAP
	CLR	R5		;CLEAR THE PROJ NUMBER FIELD
	BISB	1(R0),R5	;GET THE PROJECT NUMBER
	ASL	R5		;MAKE IT *2 (AN INDEX)
	TST	FIBUF(R5)	;IS IT THERE (BEFORE WE USE IT??)
	BEQ	40$		;NO, SO GET A GOOD BLOCK OF THE DIR BACK
	MOV	FIBUF(R5),R2	;GET THE DCN POINTER FOR THE GFD
	CALL	CNVDCN		;CONVERT TO FBN
	BR	50$		;GET BACK TO OUR CALLER

40$:	SUB	#1,R2		;BACKUP 1 FBN TO THE LABEL BLOCK
	SBC	R3		;REALLY 1 FBN BACK
	CALL	READ		;AND READ THE DIRECTORY LABEL BACK
	MOV	FIBMAP,FIPMUC	;SET MFD CLUSTER SIZE
	BR	60$		;AND THEN CALL IT AN ERROR

GLOBAL	<FIPUNT,UNTLVL,MFDPTR,FIBUF,FIPMUC>

;+
; SDM0 - SEARCH MFD FOR A PPN (ONLY NEW DISKS)
;
;	R0 -> PPN
;	R5 = FUN * 2
;	FIPUNT = UNIT
;
;	CALL	SDM0
;
;	R3 =  LINK OF ENTRY
;	R5 -> ENTRY
;		ENTRY IN FIBUF
;	FIPMUC = MFD CLUSTER SIZE
;
;	IF C=0 THEN PPN FOUND
;	IF C=1 THEN PPN NOT FOUND
;-

SDM0:	CALL	30$		;GO GET THE GFD MAPPED
	BCS	60$		; BUT THERE IS NONE, SO ERROR
	ADD	#2,R2		;AND SET UP TO READ THE THIRD BLOCK
	ADC	R3		;GET THE REAL THIRD ONE
	CALL	READ		;AND REALLY READ IT IN.
	CLR	R5		;START WITH A CLEAN PROGRAMMER NUMBER
	BISB	(R0),R5		;GET JUST THE PROGRAMMER NUMBER
	ASL	R5		;MAKE IT *2 (AN INDEX)
	MOV	FIBUF(R5),R5	;GET THE POINTER
	CALL	RDETB		;READ THE ENTRY WITH THE TABLE BLOCK
	BEQ	60$		;NONE, THEN NO ACCOUNT
50$:	;CLC			;SAY WE FOUND THE ONE WE WANT
	TST	(PC)+		;EXIT SKIPPING THE SEC (TST CLEARS C)
60$:	SEC			;SAY CAN'T FIND ANY PPN
	RETURN			;AND GO BACK TO OUR CALLER

GLOBAL	<FIBUF>

.DSABL	LSB


;+
; SDM - SEARCH MFD FOR A PPN.
;
;	R0 -> PPN
;	FIPUNT = UNIT
;
;	CALL	SDM
;
;	R2 =  LINK OF PREVIOUS TO ENTRY
;	R3 =  LINK OF ENTRY
;	R5 -> ENTRY
;	FIPMUC = MFD CLUSTER SIZE
;
;	IF C=0 THEN PPN FOUND
;	IF C=1 THEN PPN NOT FOUND
;-

.ENABL	LSB

SDM::	MOVB	FIPUNT,R5	;FUN
	ASL	R5		; FUN *2
	TST	UNTLVL(R5)	;OLD OR NEW???
	BNE	SDM0		;MUST BE SOME NEW TYPE
	CALL	READMF		;READ THE MFD
	MOV	FIBMAP,FIPMUC	;SET MFD CLUSTER SIZE
	;CLR	R3		;SET CURRENT LINK TO ZERO (FROM READMF IF OLD)
	MOV	#FIBUF,R5	; AND GET AN INITIAL POINTER
10$:	CALL	RDEPRV		;NOW KEEP PREVIOUS AND READ NEXT
	BEQ	80$		;THE END, EXIT C=1
	CMP	(R0),UNAM(R5)	;DESIRED PPN?
	BNE	10$		;NO MATCH THIS TIME
	BITB	#US.DEL!US.UFD,USTAT(R5) ;IS IT A UFD?
	BLE	10$		;NO OR MARKED FOR DELETION
.ASSUME	US.DEL	EQ	200
	;CLC			;YES, MATCH, C=0 FROM 'CMP'
	BR	90$		; AND EXIT

GLOBAL	<FIBMAP,FIPMUC,FIBUF,FIPUNT,UNTLVL>

;+
; SDU - SEARCH FOR A FILE NAME.
;
;	R0 -> PPN, 2-WORD FILE NAME, EXTENSION
;	FIPUNT = UNIT
;	FIPGEN = GENERAL SEARCH(<>0) OR SPECIFIC(=0)
;
;	CALL	SDU
;
;	IF C=0 THEN FILE NAME FOUND
;
;	R2 =  LINK OF PREVIOUS TO ENTRY
;	R3 =  LINK OF ENTRY
;	R5 -> ENTRY
;	FIPUNT = UNIT OF ENTRY
;	FIPGEN = 0
;	FIPMUC = UFD CLUSTER SIZE
;	FIPU0C = SYSTEM DISK UFD CLUSTER SIZE IF SYSTEM DISK OR GENERAL
;
;	IF C=1 THEN FILE NAME NOT FOUND (GENERAL)
;
;	R2 =  0
;	R3 =  0
;	R5 =  RANDOM
;	FIPUNT = SYSTEM UNIT
;	FIPU0C = SYSTEM DISK UFD CLUSTER SIZE IF PPN EXISTS THERE
;
;	IF C=1 THEN FILE NAME NOT FOUND (SPECIFIC)
;
;	R5 =  0 => NO PPN
;
;		R2 =  0
;		R3 =  0
;		FIPMUC = MFD CLUSTER SIZE
;		FIPCLU = LAST LINK IN MFD
;
;	R5 =  2 => NO UFD
;
;		R2 =  0
;		R3 =  0
;		FIPMUC = UFD CLUSTER SIZE
;		FIPCLU -> UAR OF PPN IN MFD
;
;	R5 =  4 => NO FILE NAME
;
;		R2 =  LAST LINK IN UFD
;		R3 =  NULL LINK IN UFD
;		FIPMUC = UFD CLUSTER SIZE
;		FIPU0C = SYSTEM DISK UFD CLUSTER SIZE IF SYSTEM DISK
;-

20$:	TSTB	FIPGEN		;GENERAL OR SPECIFIC FAILURE?
	BEQ	70$		;IF SPECIFIC, THEN SET AND EXIT
30$:	MOV	#<UC.MNT!UC.PRI!UC.NFS>,R2 ;MASK FOR NEXT UNIT
	CALL	NXTUN2,R1	;GO TO THE NEXT UNIT
	BR	60$		;NO MORE UNITS
SDU::	CALL	RUF		;USE SOME TRUMP TO GET UFD
	BCS	20$		;FIPMUC ALWAYS SET RIGHT
	CLR	R3		;SAY CURRENT LINK=0
	MOV	#FIBUF,R5	; AND CURRENT POINTER TO UFD'S START
40$:	CALL	RDEPRV		;KEEP PREVIOUS AND READ NEXT
	BNE	50$		;REAL, SO CHECK IT
	TSTB	FIPGEN		;GENERAL?
	BNE	30$		;IF GENERAL HACK UP UNIT DEAL
	MOV	#4,R5		;SET R5 FOR EOF, C-BIT GETS IT LATER
	BR	80$		;COMMON EXIT

50$:	CMP	2(R0),UNAM(R5)	;FILE NAME, WORD 1
	BNE	40$		;NOT IT
	CMP	4(R0),UNAM+2(R5) ;FILE NAME, WORD 2
	BNE	40$		;NOT IT
	CMP	6(R0),UNAM+4(R5) ;EXTENSION
	BNE	40$		;NOT IT
	BITB	#US.DEL!US.UFD,USTAT(R5) ;FILE MARKED FOR DELETION OR IS UFD?
	BNE	40$		;IF SO, THEN IGNORE IT
	CLRB	FIPGEN		;SET REAL LIVE UNIT
	;CLC			;C=0 FROM THE 'CLRB'
	BR	90$		; AND EXIT

60$:	MOVB	SYSUNT,FIPUNT	;RESET BACK TO SYSTEM UNIT IF FAILED
70$:	CLR	R2		;R2=0, SET NO LAST LINK
	CLR	R3		;R3=0, SET NULL LINK
80$:	SEC			;C=1, NOT FOUND
90$:	RETURN			;NOW EXIT

.DSABL	LSB

GLOBAL	<FIPGEN,FIBUF,SYSUNT,FIPUNT>

.SBTTL	SEARCH MEMORY/UFD FOR A FILE NAME

;+
; SMU - SEARCH MEMORY/UFD FOR A FILE NAME
;
;	R0 -> PPN, 2-WORD FILE NAME, EXTENSION
;	FIPUNT = UNIT
;	FIPGEN = GENERAL SEARCH(<>0) OR SPECIFIC(=0)
;
;	CALL	SMU
;
;	IF C=0 THEN FILE NAME FOUND
;
;	R1 -> FCB IF FILE ALREADY OPEN
;	   =  1   if file not open but marked as permanent
;	   =  0   IF FILE NOT OPEN
;	R2 =  RANDOM
;	R3 =  LINK OF ENTRY, or permanent file block contorted address	;023
;		if R1 = 1						;023
;	R5 -> ENTRY
;	FIPUNT = UNIT OF ENTRY
;	FIPGEN = 0
;
;	IF C=1 THEN FILE NAME NOT FOUND
;
;	R1,R2,R3,R5 = RANDOM
;-

.ENABL	LSB

SMU::	MOV	#SDP,-(SP)	;Search permanent file list next	;023
	MOV	FIPUNT,R5	;GET STARTING UNIT AND FIPGEN FLAG
	MOV	(R0),R3		;GET PPN TO FIND
	BNE	10$		;IF PRESENT, USE IT
	MOV	@#FIUSER,R3	;IF NOT, GET CALLER'S PPN
	BEQ	70$		;LOGGED OUT IS ILLEGAL
10$:	CALL	100$		;COMPUTE START OF FCB LIST
20$:	MOV	(R1),R1		;POINT TO NEXT FCB IN LIST
	BNE	30$		;IF PRESENT, CHECK IT
	TSTB	FIPGEN		;GENERAL DISK?
	BEQ	50$		;YES, RESTORE FIPUNT/FIPGEN & TRY DISK
	MOV	#<UC.MNT!UC.PRI!UC.NFS>,R2 ;NO, SO SET UP MASK
	CALL	NXTUN2,R1	;AND LOOK FOR NEXT UNIT
	 BR	50$		;IF NO MORE, RESTORE FIPUNT/FIPGEN & TRY DISK
	BR	10$		;TRY NEXT UNIT

30$:	MOV	R1,R2		;COPY THE FCB POINTER
	CMP	(R2)+,(R2)+	; AND INDEX TO F$PPN
	CMP	R3,(R2)+	;IS THIS THE RIGHT PPN?
	BNE	20$		;NO
	CMP	2(R0),(R2)+	;RIGHT NAME?
	BNE	20$		;NO
	CMP	4(R0),(R2)+	;RIGHT NAME WORD 2?
	BNE	20$		;NO
	CMP	6(R0),(R2)+	;RIGHT EXTENSION?
	BNE	20$		;NO
	BITB	#US.DEL!US.UFD,(R2) ;FILE MARKED FOR DELETION OR IS UFD?
	BNE	20$		;IF SO, THEN IGNORE IT
40$:	MOV	R1,R2		;COPY THE FCB POINTER
	ADD	#F$UFND,R2	; AND POINT TO THE NAME ENTRY FBB
	MOV	#RFEFBB,(SP)	;ROUTE RETURN TO READ THE NAME ENTRY
	MOVB	@#FIPUNT,R5	;GET UNIT NUMBER FOR READER
50$:	MOV	R5,@#FIPUNT	;RESET FIP UNIT AND FIPGEN
60$:	RETURN			;READ N.E. OR CHECK DISK

70$:	ERROR	PRVIOL

GLOBAL	<FIPUNT,FIPGEN,FIUSER,RFEFBB>					;022

.SBTTL	SEARCH MEMORY/MFD FOR A FILE NAME

;+
; SMM - SEARCH MEMORY/MFD FOR A FILE NAME
;
;	R0 -> PPN
;	FIPUNT = UNIT
;
;	CALL	SMM
;
;	R1 -> FCB IF UFD OPEN AS FILE
;	   =  0   IF UFD NOT OPEN AS FILE
;	R2 =  RANDOM
;	R3 =  LINK OF ENTRY
;	R5 -> ENTRY
;
;	IF C=0 THEN PPN FOUND
;	IF C=1 THEN PPN NOT FOUND
;-

SMM::	MOV	#SDM,-(SP)	;DISK SEARCHER IF MEMORY SEARCH FAILS
	CALL	100$		;COMPUTE START OF FCB LIST
80$:	MOV	(R1),R1		;POINT TO NEXT FCB IN LIST
	BEQ	60$		;NO MORE, TRY DISK
	CMP	(R0),F$PPN(R1)	;RIGHT PPN?
	BNE	80$		;NO, TRY AGAIN
	BITB	#US.DEL!US.UFD,F$STAT(R1) ;IS IT A UFD?
	BLE	80$		;NO OR MARKED FOR DELETION
	BR	40$		;FOUND IT, GO READ IT

.SBTTL	SEARCH MEMORY/UFD FOR A FILE ID

;+
; SMFID - SEARCH MEMORY/UFD FOR A FILE ID
;
;	R0 -> PPN, 0, FID
;	FIPUNT = UNIT
;
;	CALL	SMFID
;
;	R1 -> FCB IF FILE ALREADY OPEN
;	   =  0   IF FILE NOT OPEN
;	R2 =  RANDOM
;	R3 =  LINK OF ENTRY
;	R5 -> ENTRY
;
;	IF C=0 THEN ENTRY FOUND
;	IF C=1 THEN ENTRY NOT FOUND
;-

SMFID::	MOV	#SDFID,-(SP)	;DISK SEARCHER IF MEMORY SEARCH FAILS
	MOV	4(R0),R3	;GET LINK TO FIND
	BIC	#^C<UL.BLO!UL.CLO!UL.ENO>,R3 ;TRIM TO ONLY ADDRESSING
	CALL	100$		;COMPUTE START OF FCB LIST
90$:	MOV	(R1),R1		;POINT TO NEXT FCB IN LIST
	BEQ	60$		;NO MORE, TRY DISK
	CMP	(R0),F$PPN(R1)	;RIGHT PPN?
	BNE	90$		;NO
	BITB	#US.UFD,F$STAT(R1) ;IS IT A MFD TYPE ENTRY?
	BNE	90$		;YES
	MOV	F$FID(R1),R2	;PICK UP LINK WORD
	BIC	#^C<UL.BLO!UL.CLO!UL.ENO>,R2 ;TRIM TO ONLY ADDRESSING
	CMP	R3,R2		;RIGHT LINK WORD?
	BNE	90$		;NO
	TSTB	F$STAT(R1)	;FOUND IT, BUT IS IT MARKED FOR DELETE?
	BPL	40$		;IF NOT, IT'S OK, SO GO READ IT
	COM	(SP)+		;IF DELETED, FAIL INSTANTLY (NO DISK)
	RETURN

100$:	MOVB	@#FIPUNT,R1	;GET FIP UNIT NUMBER
	ASL	R1		; TIMES 2
	ADD	#FCBLST,R1	;POINT TO FCB LIST FOR UNIT
	RETURN

.DSABL	LSB

GLOBAL	<FIPUNT,FCBLST>

.SBTTL	Search permanent file list

SDP::	MOV	#SDU,-(SP)	;Try disk next				;023
	MOV	R0,-(SP)	;Save R0				;023
	MOV	R4,-(SP)	; and R4				;023
	MOV	@#FIPUNT,-(SP)	;Save FIPUNT and FIPGEN			;043
	MOV	R0,R4		;Copy FIRQB pointer			;023
	SUB	#FQPPN,R4	; and unbias it				;023
10$:	MOVB	FIPUNT,R0	;Get FIP unit number			;023
	CALLX	SCNPRU		;Scan the permanent file list		;023
	BCC	20$		;Found something, pass the good word	;023
	TSTB	FIPGEN		;Specific unit?				;023
	BEQ	30$		;Yes, so no match			;023
	MOV	#<UC.MNT!UC.PRI!UC.NFS>,R2 ;Set up mask			;023
	CALL	NXTUN2,R1	;Look for next unit			;023
	 BR	30$		;None left				;023
	BR	10$		;Found one, look again			;023

20$:	TST	(SP)+		;Dump the saved FIPUNT and FIPGEN	;043
	MOV	#50$,4(SP)	;Don't do disk search			;023
	MOV	R4,R3		;Return buffer's contorted address	;023
	MOV	#1,R1		; and indicate found in PRMLST		;023
	BR	40$		;Continue in line			;043

30$:	MOV	(SP)+,@#FIPUNT	;Restore the original FIPUNT and FIPGEN ;043
40$:	MOV	(SP)+,R4	;Restore R4				;023
	MOV	(SP)+,R0	; and R0				;023
50$:	RETURN			;Exit or search disk			;023

GLOBAL	<FIPUNT,FIPGEN>							;023

;+
; SAA - Search GFD for account attributes
;
;	R0 = Type to get
;	R3 = Link to name entry for account
;
;	CALL	SAA
;
;	R2 =  Link previous to entry
;	R3 =  Link of entry
;	R5 -> Entry
;
;	C = 0	if entry found
;	C = 1	if entry not found (R3,R5 meaningless)
;-

SAA::	CALL	RDS0CK		;Check for RDS 0, exit C=1 if so	;048
	CALL	RDE		;Make sure we have the name block
10$:	MOV	R3,R2		;Save the previous link
	MOV	(R5),R3		;Pick up the link to next item
.ASSUME	ULNK EQ 0
	CALL	RDECHK		;Read it, checking
	BEQ	20$		;None left, exit in error
	CMPB	UATYP(R5),R0	;Does the type match?
	BNE	10$		;No, keep looking
	;CLC			;Indicate success (C=0 from CMPB)
	RETURN

20$:	SEC			;Indicate failure
	RETURN			;Done

;+
; SAACR - Search GFD for account attributes, create if not found
;
;	R0 = Type to get
;	R3 = Link to name entry for account
;
;	CALL	SAACR
;
;	R2 =  Link previous to entry
;	R3 =  Link of entry
;	R5 -> Entry
;
;	C = 0	Success, entry found or new one created
;	C = 1	Failure, directory is full
;-

SAACR::	CALL	RDS0CK		;Check for RDS 0.0, exit C=1 if so
	CALL	SAA		;Try to find it first
	BCC	10$		;Found it, that's simple
	CALL	GDE		;Allocate a new entry
	BCS	10$		;No room, exit failing
	MOV	R3,-(SP)	;Save this link
	MOV	R2,R3		;Get predecessor's link
	CALL	RDE		;Read that one
	MOV	(SP)+,R3	;Restore link to new entry
	MOV	R3,(R5)		;Link new entry to this one
.ASSUME	ULNK EQ 0
	CALL	RDESV		;Write this entry, re-read new one
	MOVB	R0,UATYP(R5)	;Set up the type field
	MARK	FIBUF		;Make sure entry will be written back
10$:	RETURN			;Done

RDS0CK:	MOVB	FIPUNT,R2	;Get FIP unit number			;048
	ASL	R2		; and make word offset			;048
	TST	UNTLVL(R2)	;RDS 0?					;048
	BNE	10$		;No, skip				;048
	COM	(SP)+		;Pop return address and set carry	;048
10$:	RETURN			;Return to caller or caller's caller	;048

GLOBAL	<UNTLVL>							;048

.SBTTL	READ UFD

;+
; RUF - READ IN A UFD.
;
;	R0 -> PPN
;	FIPUNT = UNIT
;
;	CALL	RUF
;
;	IF C=0 THEN UFD READ
;
;	R5 =  0
;	FIPMUC = UFD CLUSTER SIZE
;	FIPU0C = SYSTEM DISK UFD CLUSTER SIZE IF SYSTEM DISK
;
;	IF C=1 THEN UFD NOT READ
;
;	R5 =  0 => NO PPN
;
;		FIPMUC = MFD CLUSTER SIZE
;		FIPCLU = LAST LINK IN MFD
;
;	R5 =  2 => NO UFD
;
;		FIPMUC = UFD CLUSTER SIZE
;		FIPU0C = UFD CLUSTER SIZE IF SYSTEM DISK
;		FIPCLU -> UAR OF PPN IN MFD
;-

.ENABL	LSB

RUF::	CLR	R5		;SET R5 TO 0 INITIALLY
	REGSCR			;NOW SAVE ALL REGISTERS
	MOV	(R0),-(SP)	;STACK THE SUPPLIED PPN
	BNE	10$		;A PPN WAS SUPPLIED
	MOV	FIUSER,(SP)	;NONE SUPPLIED, SET USER'S OWN
	BEQ	130$		;NOT LOGGED IN!, GIVE ERROR

10$:	CLR	R2		;Guess that we won't find a match	;055
	CMPB	FIPUNT,SYSUNT	;Is UFD on the system disk?
	BNE	45$		;No, so don't search JCRs for DCN	;055
	MAP	PUSH,APR=5,DATA	;Save APR5 mapping			;054
	MOV	@#FIJBDA,R4	;Pick up pointer to current job JDB	;054
	MOV	#JOBTBL,R3	;Pick up pointer to JOBTBL		;054
	BR	30$		;JUMP INTO LOOP

20$:	MOV	(R3)+,R4	;GET JOB DATA POINTER
	BEQ	20$		;NONE?, LOOP
	CMP	R4,#-1		;END OF LIST?
	BEQ	40$		;YES, EXIT
30$:	MOVB	JDJBNO(R4),R0	;Pick up job # * 2			;054
	MOV	JDJDB2(R4),R4	;GET JOBS JDB2 POINTER
	CMP	2(SP),J2PPN(R4)	;SAME PPN?				;060
	BNE	20$		;NO, LOOP
	CALLX	GETJCR		;Calculate JCR mapping			;054
	MAP	R2,APR=5,DATA	;And map JCR entry for job		;054
	MOV	JCUFDR-20000(R1),R2 ;Pick up UFD pointer		;054
40$:	MAP	POP,APR=5,DATA	;Restore APR5 mapping			;054
	TST	R2		;Did we get a pointer?			;054
	BNE	70$		;Yes, go use it				;054
45$:	;CLR	R2							;055
	INC	R2		;PRESET FOR FINDING THE MFD		;054
	MOVB	FIPUNT,R0	;YES, GET THE CURRENT FIP UNIT
	ASL	R0		; TIMES 2 FOR WORD ADDRESSING
	TST	UNTLVL(R0)	;IS THIS A NEW OR OLD DISK??
	BNE	50$		;NEW, SO [1,1] ISN'T SPECIAL
	CMP	(SP),(PC)+	;IS PPN = [1,1] (THE MFD)?
	 .BYTE	1,1
	BEQ	70$		;YES, NO NEED TO SEARCH...
50$:	CMP	(SP),PPNTBL	;IS PPN THE LIBRARY?
	BNE	60$		;NO, MUST SEARCH MFD FOR THE PPN
	MOV	UNTLIB(R0),R2	;NOW GET DCN FOR LIBRARY ON UNIT
	BNE	70$		;IT EXISTS, SO JUST USE IT

GLOBAL	<FIUSER,PPNTBL,FIPUNT,UNTLIB>

60$:	MOV	SP,R0		;WE MUST SEARCH, SET ARG POINTER
	CALL	SDM		;NOW SEARCH MFD FOR THE PPN
	MOV	R2,FIPCLU	;STORE POSSIBLE MFD LAST LINK
	BCS	90$		;FAILED, EXIT WITH C=1 AND R5=0
	ADD	#UAR,R5		;FOUND, INDEX TO DCN FOR UFD
	MOV	(R5),R2		;NOW GET THAT DCN
	BNE	70$		;UFD EXISTS, SO READ IT
	MOV	R5,FIPCLU	;NO UFD, SAVE POINTER TO UAR IN N.E.
	MOV	R3,-(SP)	;SAVE N.E. LINK
	MOV	-(R5),R3	;SO WE CAN GET THE A.E. LINK
	CALL	RDE		;NOW READ THE A.E.
	MOV	UCLUS(R5),R1	;GET UFD CLUSTER SIZE
	CALL	110$		;GO SET THE CLUSTER SIZE
	MOV	(SP)+,R3	;RESTORE THE N.E. LINK AND
	CALL	RDE		; ENSURE WE RE-READ IT
	MOV	#2,TOS.R5+2(SP)	;NOW EXIT WITH R5=2 AND
	BR	90$		; C=1

70$:	CALL	READUF		;CONVERT DCN AND READ THE UFD
	MOV	FIBMAP,R1	;GET UFD'S CLUSTER SIZE
	CALL	110$		;GO SET THE CLUSTER SIZE
80$:	TST	(PC)+		;SET C=0 AND SKIP THE 'SEC'
90$:	SEC			;SET C=1
	INC	(SP)+		;DUMP SAVED PPN LEAVING C-BIT ALONE
100$:	RETURN			; AND EXIT

110$:	MOV	R1,FIPMUC	;ALWAYS SET UFD CLUSTER SIZE HERE
	CMPB	FIPUNT,SYSUNT	;IS THIS THE SYSTEM DISK?
	BNE	120$		;NO
	MOV	R1,FIPU0C	;YES, SO SAVE SYSTEM DISK'S UFD CLU
120$:	RETURN			;NOW EXIT

130$:	ERROR	PRVIOL		;NOT LOGGED IN AND TRYING TO DEFAULT PPN

GLOBAL	<FIPCLU,FIPUNT,SYSUNT,FIJBD2,FIBMAP,FIPMUC,FIPU0C>

.SBTTL	SEARCH FOR A LINK

;+
; SDL - SEARCH FOR A LINK.
;
;	R2 =  UFD'S STARTING DCN
;	R3 =  LINK TO FIND
;	FIPUNT = UNIT
;
;	CALL	SDL
;
;	R2 =  LINK OF PREVIOUS TO ENTRY
;	R3 =  LINK OF ENTRY
;	R5 -> ENTRY
;
;	IF C=0 THEN ENTRY FOUND
;	IF C=1 THEN ENTRY NOT FOUND
;-

SDL:	BIC	#^C<UL.BLO!UL.CLO!UL.ENO>,R3 ;TRIM LINK TO ONLY ADDRESSING
	MOV	R3,-(SP)	; PARTS AND SAVE IT
	CALL	READUF		;NOW READ IN THE UFD
	CLR	R3		;START AT LINK = 0
	MOV	#FIBUF,R5	; AND GET AN INITIAL POINTER
140$:	CALL	RDEPRV		;READ NEXT SAVING PREVIOUS
	BEQ	90$		;NO MORE, EXIT C=1
	MOV	R3,-(SP)	;REPLICATE THIS LINK AND
	BIC	#^C<UL.BLO!UL.CLO!UL.ENO>,(SP) ; TRIM ALL BUT ADDRESSING PARTS
	CMP	(SP)+,(SP)	;MATCH THE DESIRED LINK?
	BNE	140$		;NO, LOOP
	BR	80$		;NOW GO EXIT C=0

.DSABL	LSB

GLOBAL	<FIBUF>

.SBTTL	FILE ID SEARCH

;+
; SDFID - SEARCH BASED ON FILE ID.
;
;	R0 -> PPN, 0, FID
;	FIPUNT = UNIT
;
;	CALL	SDFID
;
;	R2 =  LINK OF PREVIOUS TO ENTRY
;	R3 =  LINK OF ENTRY
;	R5 -> ENTRY
;
;	IF C=0 THEN ENTRY FOUND
;	IF C=1 THEN ENTRY NOT FOUND
;-

SDFID::	CALL	SDMDCN		;FIND PPNs DCN IN MFD			;069
	BCS	20$		;NOT THERE, EXIT C=1
	MOV	4(R0),R3	;THERE, GET LINK TO FIND
	CALL	SDL		;ELSE TRY TO FIND IT
	BCS	20$		;NOT THERE, FAIL
	TSTB	USTAT(R5)	;IS FILE MARKED FOR DELETION?
	BPL	20$		;NO, O.K., EXIT C=0 [FROM 'TSTB']
.ASSUME	US.DEL	EQ	200
10$:	SEC			;ELSE ERROR, SET C=1
20$:	RETURN			; AND EXIT

.SBTTL	SEARCHES IN MEMORY

;+
; SNE - SEARCH FOR OPEN FILE NAME ENTRY
;
;	R5 -> NAME ENTRY IN FIBUF
;
;	CALL	SNE
;
;	R1 -> FCB OF FILE
;
;	C=0, Z=0 IF FCB FOUND
;	C=1, Z=1 IF FILE NOT OPEN, R1=0 (ALWAYS IF NOT LARGE FILE SYSTEM)
;-

SNE::	MOV	R5,-(SP)	;SAVE POINTER INTO FIBUF
	ASR	(SP)		; AND MAKE IT OFFSET/2 IN LOW BYTE
	MOVB	FIBFBN,1(SP)	;LOAD FIP BLOCK NUMBER MSB INTO HIGH BYTE
	MOVB	FIPUNT,R1	;GET FIP UNIT NUMBER OF DISK
	ASL	R1		; TIMES 2
	ADD	#FCBLST,R1	;POINT TO LIST OF FCB'S OPEN ON UNIT
10$:	MOV	(R1),R1		;GET NEXT FCB
	SEC			;SET CARRY IN CASE LAST
	BEQ	20$		;IT'S LAST, RETURN C=1, R1=0
	CMP	FIBFBN+F.FBNL,F$UFND+F.FBNL(R1) ;IS NAME ENTRY FBN LSB RIGHT?
	BNE	10$		;NO
	CMP	(SP),F$UFND(R1)	;YES, ARE THE MSB AND OFFSET RIGHT?
	BNE	10$		;NO, LOOK FOR MORE
	;CLC			;C=0 FROM EQUAL COMPARE
20$:	MOV	R1,(SP)+	;DUMP THE STACK, SET Z=1 IF NO FCB
	RETURN

GLOBAL	<FIBFBN,FIPUNT,FCBLST>

.SBTTL	GET UNIT DETERMINATION

;+
; GUNOWN - Get unit allowing any disk, even if owned
;
;	R4 -> FIRQB
;		FQDEV, FQDEVN = DEVICE NAME/UNIT
;
;	CALL	GUNOWN,R5
;
;	FIRST EXIT MEANS DISKS
;
;	R0 =  UNIT TIMES 2
;	R1 -> UNIT COUNT LIST ENTRY
;	R2 =  RANDOM
;	FIPUNT = UNIT
;	FIPGEN = -1 IF NO UNIT (GENERAL) ELSE 0 (SPECIFIC UNIT)
;
;	SECOND EXIT MEANS NON-DISK
;
;	R0 =  HANDLER INDEX
;	R1 -> DDB
;	R2 =  RANDOM
;	FIPUNT = UNIT
;	FIPGEN = -1 IF NO UNIT (GENERAL) ELSE 0 (SPECIFIC UNIT)
;
;	IF C=0 THEN DEVICE IS OWNED
;	IF C=1 THEN DEVICE IS NOT OWNED
;-

.ENABL	LSB

GUNOWN::CLR	-(SP)		;Allow owned disks
	BR	10$		; join common code

;+
; GUNMNT - GET UNIT ALLOWING ANY DISK.
;
;	R4 -> FIRQB
;		FQDEV, FQDEVN = DEVICE NAME/UNIT
;
;	CALL	GUNMNT,R5
;
;	FIRST EXIT MEANS DISKS
;
;	R0 =  UNIT TIMES 2
;	R1 -> UNIT COUNT LIST ENTRY
;	R2 =  RANDOM
;	FIPUNT = UNIT
;	FIPGEN = -1 IF NO UNIT (GENERAL) ELSE 0 (SPECIFIC UNIT)
;
;	SECOND EXIT MEANS NON-DISK
;
;	R0 =  HANDLER INDEX
;	R1 -> DDB
;	R2 =  RANDOM
;	FIPUNT = UNIT
;	FIPGEN = -1 IF NO UNIT (GENERAL) ELSE 0 (SPECIFIC UNIT)
;
;	IF C=0 THEN DEVICE IS OWNED
;	IF C=1 THEN DEVICE IS NOT OWNED
;-

GUNMNT::MOV	#377,-(SP)	;Check owner
10$:	CLR	-(SP)		;ALLOW NON-MOUNTED DISKS
	BR	20$		; NOW JOIN COMMON CODE

;+
; GUN - GET UNIT ALLOWING ONLY RSTS DISKS.
;
;	R4 -> FIRQB
;		FQDEV, FQDEVN = DEVICE NAME/UNIT
;
;	CALL	GUN,R5
;
;	FIRST EXIT MEANS DISKS
;
;	R0 =  UNIT TIMES 2
;	R1 -> UNIT COUNT LIST ENTRY
;	R2 =  RANDOM
;	FIPUNT = UNIT
;	FIPGEN = -1 IF NO UNIT (GENERAL) ELSE 0 (SPECIFIC UNIT)
;
;	SECOND EXIT MEANS NON-DISK
;
;	R0 =  HANDLER INDEX
;	R1 -> DDB
;	R2 =  RANDOM
;	FIPUNT = UNIT
;	FIPGEN = -1 IF NO UNIT (GENERAL) ELSE 0 (SPECIFIC UNIT)
;
;	IF C=0 THEN DEVICE IS OWNED
;	IF C=1 THEN DEVICE IS NOT OWNED
;-

GUN::	MOV	#377,-(SP)	;Check owner
	MOV	#UC.MNT!UC.NFS,-(SP) ;ERROR IF NON-MOUNTED DISKS
20$:	CLRB	FIPGEN		;CLEAR FIPGEN (SPECIFIC)
	CALLX	GUNSUB,R5	;SORT OUT NAME AND UNIT
	 ERROR	NODEVC		;NO SUCH DEVICE ERROR
	BEQ	100$		;NO UNIT NUMBER WAS SPECIFIED
30$:	ASL	R2		;GET UNIT TIMES 2
	ADD	DEVPTR(R0),R2	;FORM POINTER TO DDB TABLE
	CMP	R0,#DEVOKB	;DID WE FIND A DISK??
	BGE	110$		;NOPE
40$:	MOV	R2,R1		;YES, SO COPY ACCESS COUNTER POINTER
	SUB	#UNTCNT,R2	; AND FIND THE FIP UNIT NUMBER (TIMES 2)
	MOV	R2,R0		;SET TO RETURN UNIT TIMES 2
	ASR	R2		;NOW MAKE INTO FIP UNIT NUMBER
	MOVB	R2,FIPUNT	; AND SAVE THE FIP UNIT NUMBER
	BIT	#UC.MNT!UC.LCK,(R1) ;Is the unit mounted and locked?	;037
	BLE	50$		;No, skip privilege check		;037
	CMPB	UNTOWN(R0),FIJOB ;Yes, but do we own it?		;037
	BEQ	50$		;If so we can access it			;037
	TSTPRV	DEVICE,FIPRVM	;Not ours -- can we access locked units? ;037
	BEQ	80$		;No, so issue error			;037
50$:	BIT	(R1),(SP)+	;IS THE DISK UNIT MOUNTED??
	BNE	60$		;No, so figure out what error to return
	BITB	(SP)+,UNTOWN(R0) ;Is unit owned, or don't we care?	;024
	BEQ	140$		;No, so we're allowed to access it
	CMPB	UNTOWN(R0),FIJOB ;Owned by caller?
	BEQ	140$		;Yes, good
	ERROR	INUSE		;Don't let others get at this disk

60$:	BPL	70$		;YES, BUT IT IS NON-FILE STRUCTURED
	ERROR	NOTMNT		;NO, NOT MOUNTED

70$:	ERROR	DEVNFS		;NON-FILE STRUCTURED ERROR

80$:	ERROR	PAKLCK		;Pack is locked and no DEVICE privs	;037
90$:	ERROR	NOTAVL		;Device is restricted and no DEVICE privs ;037

100$:	COMB	FIPGEN		;INDICATE GENERAL DEVICE (NO UNIT)
	CMP	R0,#DEVOKB	;IS THE DEVICE KB:??
	BNE	30$		;NOPE
	MOV	@FIJBDA,R2	;YES, SO GET USER'S CH #0 IOB ADDRESS
110$:	CMP	(SP)+,(SP)+	;Pop two stack items			;042
	ADD	#2,R5		;And take second exit			;042
	MOV	(R2),R1		;GET THE REAL DDB ADDRESS
	MOVB	DDUNT(R1),FIPUNT ;SET THE UNIT NUMBER
	MOVB	(R1),R0		;GET THE DRIVER INDEX FROM DDB
	MOVB	$FLGTBL(R0),R0	;NOW RETURN THE HANDLER INDEX
	CMPB	DDJBNO(R1),FIJOB ;DOES THE USER OWN THIS DDB??
	BEQ	140$		;YES, SO EXIT (C=0)
	BIT	#DDPRVO,(R1)	;Need privilege to own the device?	;037
	BEQ	120$		;No, skip priv check			;037
	TSTPRV	DEVICE,FIPRVM	;Yes, do we have the privilege?		;037
	BEQ	90$		;Error if not				;037
120$:	CMP	R2,@FIJBDA	;NO, IS THIS THE CH #0 DDB?
	BNE	130$		;NOT CH #0, SO EXIT (C=1)
	ERROR	DETKEY		;CH #0, SO DETACHED ERROR

130$:	SEC			;INDICATE USER NOT OWNER
140$:	RETURN	R5		;NOW EXIT

.DSABL	LSB

GLOBAL	<FIPGEN,DEVPTR,DEVOKB,UNTCNT,FIPUNT,FIJBDA>			;037
GLOBAL	<FIPRVM,$FLGTBL,UNTOWN,FIJOB>					;037

.SBTTL	READS INTO FIBUF

;+
; READPL - READ FIRST BLOCK OF THE PACK LABEL.
;
;	FIPUNT = UNIT
;
;	CALL	READPL
;
;	R2 =  1
;	R3 =  0
;
;	C=0 ALWAYS
;-

READPL::MOV	#1,R2		;SET UP TO READ MFD (DCN=1)
	BR	READUF		;NOW CONTINUE			

;+
; READMF - READ FIRST BLOCK OF THE MFD.
;
;	FIPUNT = UNIT
;
;	CALL	READMF
;
;	R2 =  LSB OF MFD'S STARTING FBN
;	R3 =  MSB OF MFD'S STARTING FBN
;
;	C=0 ALWAYS
;-

READMF::MOVB	FIPUNT,R3		;GET THE FIP UNIT NUMBER
	ASL	R3			; FUN * 2
	MOV	MFDPTR(R3),R2		;NOW, GET THE MFD POINTER
	.BR	READUF			;AND READ IT IN.

GLOBAL	<FIPUNT,MFDPTR>

;+
; READUF - READ FIRST UFD BLOCK USING THE UFD'S STARTING DCN.
;
;	R2 =  DCN THAT STARTS THE UFD
;	FIPUNT = UNIT
;
;	CALL	READUF
;
;	R2 =  LSB OF UFD'S STARTING FBN
;	R3 =  MSB OF UFD'S STARTING FBN
;
;	C=0 ALWAYS
;-

READUF::CALLX	CNVDCN		;CONVERT DCN TO FIP BLOCK NUMBER
	BR	READ		;NORMAL READ

;+
; READSV - ALWAYS MARK BUFFER AS DIRTY, THEN READ.
;
;	R2 =  LSB OF FBN TO READ
;	R3 =  MSB OF FBN TO READ
;	FIPUNT = UNIT OF FBN TO READ
;
;	CALL	READSV
;
;	C=0 ALWAYS
;-

READSV::MARK	FIBUF		;MARK BUFFER AS MODIFIED
	.BR	READ		; AND THEN READ

;+
; READ - READ INTO FIBUF CHECKING FOR DIRTY BUFFERS.
;
;	R2 =  LSB OF FBN TO READ
;	R3 =  MSB OF FBN TO READ
;	FIPUNT = UNIT OF FBN TO READ
;	FIBMOD = DIRTY INDICATOR
;
;	CALL	READ
;
;	C=0 ALWAYS
;-

READ::	MOV	R5,-(SP)	;GET A SCRATCH REGISTER
	MOV	#FIBFBN+F.FBNL,R5 ;POINT TO FIBUF CONTROL AREA
	CMP	R2,(R5)+	;CHECK TO SEE IF LSB'S MATCH
	BNE	10$		;NO
	CMPB	FIPUNT,(R5)	;CHECK TO SEE IF BLOCK THERE
	BNE	10$		;NO
	CMP	R3,FIBFBN	;DO MSB'S MATCH?
	BNE	10$		;No, so we'll need to do the I/O	;056
	L3QSET	QFIP		;Block in FIBUF, set our L3Q bit 	;056
	CALLX	FIPWAT		;And let others run			;056
	BR	20$		;Now get out				;056

10$:	CALL	WRITEC		;CHECK FOR WRITE BEFORE READ
	MOVB	#-1,(R5)	;INVALIDATE JUST BEFORE READS
	MOV	#RFUN,@#FIPAR+DSQFUN ;SET FUNCTION AS READ
	MOV	#FIBUF,@#FIPAR+DSQMAL ; INTO FIBUF
	CALL	FIPIO,R5	;NO DO THE I/O
	MOVB	FIPUNT,(R5)	;SET THE BLOCK'S UNIT
	MOV	R2,-(R5)	;REMEMBER THE FBN THAT
	MOV	R3,-(R5)	; WE JUST READ
20$:	MOV	(SP)+,R5	;Restore R5				;024
	RETURN			;Exit					;024

GLOBAL	<FIPUNT,FIBUNT,FIBFBN,FIBUF,L3QUE>

.SBTTL	READ A NAME ENTRY

;+
; RNEFBB - READ NAME ENTRY FROM FBB.
;
;	R2 -> N.E. FBB OF A DATA FBB/N.E. FBB PAIR
;
;	CALL	RNEFBB
;
;	R3 =  LINK OF NAME ENTRY
;	R5 -> NAME ENTRY
;	FIPUNT = NAME ENTRY UNIT
;	FIPGEN = 0 (SPECIFIC)
;-

.ENABL	LSB

RNEFBB::MOVB	-FBBSIZ(R2),R5	;GET CORRECT UNIT FROM DATA FBB

;+
; RFEFBB - READ NAME ENTRY FROM FBB.
;
;	R2 -> FBB (OFFSET / FBN)
;	R5 =  FIP UNIT NUMBER
;
;	CALL	RFEFBB
;
;	R3 =  LINK OF NAME ENTRY
;	R5 -> NAME ENTRY
;	FIPUNT = NAME ENTRY UNIT
;	FIPGEN = 0 (SPECIFIC)
;-

RFEFBB::MOV	R2,-(SP)	;SAVE R2
	BR	10$		;NOW GO READ THE NAME ENTRY

;+
; RNE - READ A NAME ENTRY.
;
;	R1 -> WCB/SCB
;
;	CALL	RNE
;
;	R3 =  LINK OF NAME ENTRY
;	R5 -> NAME ENTRY
;	FIPUNT = NAME ENTRY UNIT
;	FIPGEN = 0 (SPECIFIC)
;	FIPCLU = FILE'S CLUSTER SIZE
;-

RNE::	MOV	W$FCB(R1),R5	;GET POINTER TO FCB @ F$CLUS
	ADD	#F$UFND-F$CLUS,R5 ; AND MAKE A POINTER TO THE NAME ENTRY FBB

;+
; RFE - READ FBB ENTRY
;
;	R1 -> WCB
;	R5 -> FBB TO READ
;
;	CALL	RFE
;
;	R3 =  LINK OF ENTRY
;	R5 -> ENTRY
;	FIPUNT = ENTRY UNIT
;	FIPGEN = 0 (SPECIFIC)
;	FIPCLU = FILE'S CLUSTER SIZE
;-

RFE::	MOV	R2,-(SP)	;SAVE R2
	MOV	R5,R2		;MOVE FBB POINTER TO A REASONABLE PLACE
	MOV	W$FCB(R1),R5	;GET FCB POINTER
	MOV	(R5),FIPCLU	;SET FILE'S FILE CLUSTER SIZE
	MOVB	F$UNT-F$CLUS(R5),R5 ;GET CORRECT FIP UNIT
10$:	MOV	R5,FIPUNT	;SET THE FIP UNIT NUMBER AND CLEAR FIPGEN
	;CLRB	FIPGEN		;SET SPECIFIC UNIT (0)
	CLR	R5		;CLEAR A REGISTER AND
	BISB	(R2)+,R5	;GET N.E. ENTRY OFFSET /2
	ASL	R5		;NOW HAVE THE REAL ENTRY OFFSET
	MOVB	(R2)+,R3	;GET MSB OF N.E. FBN AND
	BPL	20$		;IT MUST BE POSITIVE
	ERROR	BADDIR		;OR ELSE DIRECTORY IS BAD

20$:	MOV	(R2),R2		; ALSO LSB OF N.E. FBN
	CALL	READ		;NOW READ IT IN
	CALL	CJK		;COMPUTE J & K AND FIND
	MOV	(SP)+,R2	;RESTORE R2
	.BR	PLK		;PACK THE LINK AND EXIT

.DSABL	LSB

GLOBAL	<FIPCLU,FIPUNT>

.SBTTL	LINK HANDLERS

;+
; PLK - PACK A LINK WORD.
;
;	R5 =  ENTRY OFFSET
;	J  =  BLOCK OFFSET
;	K  =  CLUSTER OFFSET
;
;	CALL	PLK
;
;	R3 =  LINK
;	R5 -> ENTRY
;-

.ENABL	LSB

PLK:	MOVB	J,R3		;BLOCK OFFSET TO LO R3, CLEAR HI R3
	ASH	#3,R3		;MARK 3 BITS FOR CLUSTER
	BISB	K,R3		;CLUSTER TO R3
	ASL	R3		;BLOCK + CLUSTER IN LO BYTE
	SWAB	R3		;NOW HIGH
	BIS	R5,R3		;.OR. IN ENTRY OFFSET
	ADD	#FIBUF,R5	;MAKE ENTRY OFFSET INTO A POINTER
10$:	RETURN			; AND DONE

GLOBAL	<J,K,FIBUF>

;+
; CJK - COMPUTE UL.BLO (J) AND UL.CLO (K).
;
;	FIBUF HAS DIRECTORY BLOCK TO COMPUTE ON
;
;	CALL	CJK
;
;	R2 =  LSB OF FBN IN FIBUF
;	R3 =  MSB OF FBN IN FIBUF
;	J  =  BLOCK OFFSET
;	K  =  CLUSTER OFFSET
;
;	C=0 ALWAYS
;-

CJK:	MOV	FIBFBN+F.FBNL,R2 ;GET LSB OF THE FBN AND
	MOV	FIBFBN,R3	; MSB OF THE FBN
	REGSCR			;NOW SAVE ALL REGISTERS
	MOVB	FIBMAP,R0	;GET UFD CLUSTER SIZE
	NEG	R0		;MAKE IT A MASK
	;SEC			;C=1 SINCE CLUSTER SIZE <> 0
	SBC	R2		;FIND VALUE OF
	SBC	R3		; FBN -1
	MOV	R2,R1		;LSB OF FBN INTO R1
	BIC	R0,R1		;GET BLOCK OFFSET FROM START OF CLUSTER
	MOV	R1,J		; WHICH GETS STORED IN J
	;CLRB	K		;K=J+1, SO CLUSTER NUMBER IS CLEAR NOW
	BIC	R1,R2		;NOW CLEAR THOSE BITS IN FBN
	MOVB	FIBUNT,R0	;GET UNIT #
	ASL	R0		;UNIT # *2
	MOVB	DEVCLU(R0),R0	;Get Device cluster size (DCS)		;058
	BIC	#^C377,R0	;...without sign extend			;058
20$:	ASR	R0		;DIVIDE (FBN-1)
	BCS	30$		; BY (DCS)...
	ASR	R3		;  [WON'T TAKE LONG
	ROR	R2		;   SINCE DCS IS USUALLY
	BR	20$		;    LESS THAN OR EQUAL TO 4]

30$:	;SEC			;C=1 FROM 'BCS' ABOVE
	ADC	R2		;NOW WE HAVE DCN IN R2
	MOV	#FIBENT,R0	;NOW LOOK FOR THIS ENTRY IN MAP
	MOV	#7,R3		;COUNT SEVEN POSSIBLE CLUSTERS
40$:	CMP	R2,(R0)+	;GOT IT ?
	BEQ	10$		;YOU BETCHA, EXIT WITH C=0
	INCB	K		;NO, BUMP THE CLUSTER NUMBER
	SOB	R3,40$		;IT'S GOTTA BE HERE SOMEWHERE
	ERROR	BADDIR		; ELSE WE HAVE BAD DIRECTORY

.DSABL	LSB

GLOBAL	<FIBFBN,FIBMAP,J,FIBUNT,DEVCLU,FIBENT,K>

.SBTTL	RAD50 -> ASCII conversion

;+
; R50ASC - Convert RAD50 word to 3 characters ASCII
;
;	R0 = RAD50 value
;
;	CALL	R50ASC
;
;	R0 -> Buffer with ASCII string (3 bytes ASCIZ)
;-

R50ASC::MOV	R1,-(SP)	;Save a work register
	MOV	R2,-(SP)	; and another
	MOV	R0,R1		;Copy the data
	MOV	#R50WRK,R2	;Point to work buffer
	BIC	#30000,PS	;MAKE SURE 10$ & 20$ DO MFPI FROM KERNEL
	CALL	10$,R5,50*50	;Convert first char
	CALL	10$,R5,50	; and second
	MOV	R1,R0		;Copy remainder
	CALL	20$,R5		;Convert third
	CLRB	(R2)		;Store terminator null
	MOV	#R50WRK,R0	;Point to string
	MOV	(SP)+,R2	;Restore caller's R2
	MOV	(SP)+,R1	; and R1
	RETURN			;Done

10$:	MFPI	(R5)+		;GET THE DIVISOR FROM OUR I SPACE CALLER
	CLR	R0		;Set up for DIV
	DIV	(SP)+,R0	;Get a character and remainder
20$:	BEQ	50$		;Space, store as null
	CMP	R0,#<^R  Z>	;Letter?
	BLOS	40$		;Yes
	CMP	R0,#<^R  0>	;Digit?
	BHIS	30$		;Yes
	ASL	R0		;MAKE INTO A WORD INDEX
	MFPI	60$-<2*<^R  $>>(R0) ;NOW GET THE REAL VALUE
	MOVB	(SP)+,R0	 ;Deal with the specials
30$:	ADD	#<'0-<^R  0>>-<'A-<^R  A>>,R0 ;Bias to ASCII digit
40$:	ADD	#'A-<^R  A>,R0	;Bias to ASCII letter/digit/whatever
50$:	MOVB	R0,(R2)+	;Store it
	RETURN	R5		;Done

60$:	.WORD	'$-<'0-<^R  0>>	;REALLY A BYTE, BUT CAUSE OF MFPI
	.WORD	'.-<'0-<^R  0>>	; ABOVE, THEY ARE
	.WORD	'?-<'0-<^R  0>>	;  STORED AS WORDS

GLOBAL	<R50WRK>

.SBTTL	Check access rights to a file

;+									;022
; CHKACC - Check access rights to a file (from FIP context)		;050
; CHKACJ - Check access rights to a file (given job number)		;050
;									;022
;	R0 =	PPN of file, or 0 if same as caller's PPN		;022
;	R1 =	Protection code of file					;022
;	R2 =	Job number * 2 of job to check (CHKACJ only)		;050
;									;022
;	CALLX	CHKACC or CHKACJ					;050
;									;022
;	R0 =	Access flags:						;022
;		DDWLO	if no write access				;022
;		DDRLO	if no read access				;022
;		DDAUX	if no execute access				;025
;		DDPRVO	if create/rename access rights			;037
;		DDAUXA	if accounting read rights			;049
;		DDSTAT	if accounting change rights			;049
;									;044
;	Note that DDPRVO, DDAUXA and DDSTAT are independent of		;049
;	protection code; the only parameter affecting those two is	;049
;	the PPN								;049
;-									;022

	TMPORG	FIPDSP,6						;025
	.WORD	CHKACJ							;050
	UNORG								;025

.ENABL	LSB								;050

CHKACJ::REGSCR			;Save all registers			;050
	BR	10$		; and skip R2 setup			;050

CHKACC::REGSCR			;Save all registers			;022
	MOVB	FIJOB,R2	;Get job number in FIP			;050
10$:	MOV	JOBTBL(R2),R4	;Get JDB pointer for job		;054
	MOV	JDJDB2(R4),R4	;Get JDB2 pointer			;054
	MOV	J2PPN(R4),R3	;First check our own PPN		;054
	MAP	PUSH,APR=5,DATA	;Save APR5 mapping			;054
	MAP	PUSH,APR=6,DATA	;And APR6 mapping			;054
	MAP	FIPAP6,APR=6,DATA ;Map our data				;054
	MOV	R2,R0		;Copy job # * 2				;054
	CALLX	GETJCR		;Pick up JCR pointer			;054
	MAP	R2,APR=5,DATA	;And map it via APR5			;054
	MOV	R1,R5		;Copy JCR pointer			;054
	ADD	#JCPRIV-20000,R5 ;And point to privileges		;054
	MOV	TOS.R1+4(SP),R1	;Restore protection code to check	;054
	MOV	TOS.R0+4(SP),R0	;And restore PPN to check		;054
	BNE	20$		;We got one, good			;022
	MOV	R3,R0		;Otherwise use caller's PPN		;022
20$:	SWAB	R0		;Hack up PPN for easy checking		;022
	MOV	#DDPRVO!DDAUXA!DDSTAT,TOS.R0+4(SP) ;Assume all access ok ;054
	CALL	40$		;Check out access rights		;022
	MOV	JCALPP-JCPRIV(R5),R3 ;Pick up alternate PPN		;054
	BEQ	30$		;None, that's easy			;054
	ADD	#JCALPV-JCPRIV,R5 ;Got one, point to privs also		;054
	CALL	40$		;Check out alternate privileges		;022
30$:	MAP	POP,APR=6,DATA	;Restore APR6 mapping			;054
	MAP	POP,APR=5,DATA	;Restore APR5 mapping			;054
	RETURN			;And we're done				;054

GLOBAL	<FIJOB,JOBTBL>							;054

;+									;023
; Registers at this point:						;023
;									;023
;	R0 =	File's PPN, swapped					;023
;	R1 =	Protection code						;023
;	R3 =	PPN of user to check					;023
;	R5 ->	Mask to check with					;023
;	SP ->	Caller's PC, Saved DPAR6, Saved DPAR5, 			;054
;			cell to return data, ...			;054
;									;025
; Registers on return:							;025
;									;025
;	R0,1,4,5 Unchanged						;025
;	R2,3	 Random							;025
;-									;023

40$:	MOV	R4,-(SP)	;Get a scratch register			;054
	MOV	#EXETBL,R4	;Point to executable file check table	;025
	BIT	#UP.RUN,R1	;Is it executable?			;025
	BNE	50$		;Yes					;025
	MOV	#NXETBL,R4	;No, so use the other table		;025
50$:	SWAB	R3		;Hack up user PPN for easy checking	;025
	TSTB	R0		;File in [0,*]?				;022
	BNE	60$		;No					;022
	TSTPRV	SYSIO,(R5)	;Allowed to change those?		;037
	BNE	60$		;Yes, ok				;022
	BIC	#DDPRVO,TOS.R0+10(SP) ;No, so never create/rename rights ;054
	BIS	#DDWLO,TOS.R0+10(SP) ; and no write access		;054
60$:	CMP	R0,R3		;Are we the owner?			;022
	BEQ	70$		;Yes					;022
	ADD	#ACTBSZ,R4	;No, so advance table pointer		;025
	CMPB	R0,R3		;Same group?				;022
	BEQ	70$		;Yes, check now				;022
	ADD	#ACTBSZ,R4	;No, advance pointer			;025
70$:	MOV	#2,R3		;Two non-protection privs to check	;044
80$:	MOVB	(R4)+,R2	;Get a priv to check			;044
	BEQ	90$		;None needed, so go on			;025
	BITB	R2,(R5)		;Do we have those privs?		;025
	BNE	90$		;Yes					;025
	BICB	(R4),TOS.R0+1+10(SP) ;No, so cancel this flag		;054
90$:	INC	R4		;Skip flag byte				;044
	SOB	R3,80$		;Loop through the entries		;044
	MOV	#3,R3		;Three table entries to process		;025
100$:	MOVB	(R4)+,R2	;Get protection bits to check		;025
	BIC	R1,R2		;Leave 0 if all are set for file	;025
	BITB	(R4)+,(R5)	;Do we have the privilege?		;025
	BNE	110$		;Yes, don't set the flag		;025
	TST	R2		;No, but does protection deny access?	;025
	BNE	110$		;Not unless all bits set in protection	;025
	BISB	(R4),TOS.R0+1+10(SP) ;Access denied, set the flag	;054
110$:	INC	R4		;Skip flag byte				;025
	SOB	R3,100$		;Loop through the entries		;025
	MOV	(SP)+,R4	;Restore caller's R4			;054
	RETURN			;Done					;025

.DSABL	LSB

.SBTTL	Data for the check access routine

.MACRO	.MSK	PRIV							;054
$$$$$$	=	0							;054
.IRP	X,<PRIV>							;054
.ASSUME	O'X EQ 0							;054
.ASSUME	P'X&377 NE 0							;054
$$$$$$	=	$$$$$$ ! P'X						;054
.ENDR									;054
	 .BYTE	$$$$$$							;054
.ENDM	.MSK								;054

.MACRO	.CHK	PROT,PRIV,BITS						;054
.IF	NB	<PROT>							;054
	 .BYTE	PROT							;054
.ENDC									;054
	 .MSK	<PRIV>							;054
	 .BYTE	<BITS>/400						;054
.ENDM	.CHK								;054

; The following two tables define the privilege checks.  The first	;054
; table is for executable files, the second one for non-executable	;054
; files.  In each table, the first 5 entries are for owner, the		;054
; next 5 for group, and the last 5 for world.				;054
; The first line of each 5 lines specifies the privileges needed to	;054
; get create/rename rights.  The second line specifies the privileges	;054
; needed to get accounting rights.  These two checks are indepent of	;054
; protection code.  The remaining 3 lines specify protection		;054
; bits, a mask, and flags.  The flags will be set (thereby denying	;054
; the access) if all the specified protection bits are set, and the	;054
; caller doesn't have the indicated privilege.  If either some		;054
; protection bits are clear, or the indicated privilege is available,	;054
; then the flags are left alone.					;054
; The reason there are 3 lines for protection checks is that there	;054
; are 3 bits (read, write and execute) being returned.  For 		;054
; non-executable files, one of the lines is a dummy to always set	;054
; the DDAUX (execute lockout) bit.					;054

EXETBL:									;054

;	protection bits		priv mask	flags to change		;054
;	---------------		---------	------------		;054
.BYTE				0,		0			;054
.CHK	,			<GACNT,WACNT>	DDSTAT			;054
.CHK	UP.RPO+UP.RPG+UP.RPW	<GREAD,WREAD>	DDAUX			;054
.CHK	UP.WPO+UP.WPG+UP.WPW	<GREAD,WREAD>	DDRLO			;054
.CHK	UP.WPO+UP.WPG+UP.WPW	<GWRITE,WWRITE>	DDWLO			;054

ACTBSZ	=:	.-EXETBL						;054

.CHK	,			<GWRITE,WWRITE>	DDPRVO			;054
.CHK	,			<GACNT,WACNT>	DDSTAT!DDAUXA		;054
.CHK	UP.RPG+UP.RPW		<GREAD,WREAD>	DDAUX			;054
.CHK	UP.WPG+UP.WPW		<GREAD,WREAD>	DDRLO			;054
.CHK	UP.WPG+UP.WPW		<GWRITE,WWRITE>	DDWLO			;054

.CHK	,			WWRITE		DDPRVO			;054
.CHK	,			WACNT		DDSTAT!DDAUXA		;054
.CHK	UP.RPW			WREAD		DDAUX			;054
.CHK	UP.WPW			WREAD		DDRLO			;054
.CHK	UP.WPW			WWRITE		DDWLO			;054

NXETBL:									;054

;	protection bits		priv mask	flags to set		;054
;	---------------		---------	------------		;054
.BYTE				0,		0			;054
.CHK	,			<GACNT,WACNT>	DDSTAT			;054
.CHK	0			<>		DDAUX			;054
.CHK	UP.RPO+UP.RPG+UP.RPW	<GREAD,WREAD>	DDRLO			;054
.CHK	UP.WPO+UP.WPG+UP.WPW	<GWRITE,WWRITE>	DDWLO			;054

.CHK	,			<GWRITE,WWRITE>	DDPRVO			;054
.CHK	,			<GACNT,WACNT>	DDSTAT!DDAUXA		;054
.CHK	0			<>		DDAUX			;054
.CHK	UP.RPG+UP.RPW		<GREAD,WREAD>	DDRLO			;054
.CHK	UP.WPG+UP.WPW		<GWRITE,WWRITE>	DDWLO			;054

.CHK	,			WWRITE		DDPRVO			;054
.CHK	,			WACNT		DDSTAT!DDAUXA		;054
.CHK	0			<>		DDAUX			;054
.CHK	UP.RPW			WREAD		DDRLO			;054
.CHK	UP.WPW			WWRITE		DDWLO			;054

	.EVEN								;054

.SBTTL	CLUSTER RETURN AND GET

;+
; RETCLU - RETURN A CLUSTER TO THE SYSTEM.
;
;	R1 =  CLUSTER SIZE
;	R2 =  DCN
;	FIPUNT = UNIT
;
;	CALL	RETCLU
;-

RETCLU::BIC	#100000,R1	;CLEAR FUNNY FLAG FROM CLUSTER SIZE
	REGSCR			;SAVE ALL REGISTERS
	MAP	PUSH,APR=5,DATA	;And save DPAR5 mapping			;051
	CALL	SETSAT		;MAKE DCN INTO PCN, GET COUNT, ETC.
	CALL	FNDPCN		; AND FIND IT IN S.A.T.
	BCS	30$		;OUT OF S.A.T., FORGET IT
10$:	BICB	R3,(R4)+	;IN S.A.T., CLEAR BIT(S)
	SOB	R1,10$		; FOR THE WHOLE CLUSTER
	TST	SATMMU(R5)	;Resident SATT for ths unit?		;051
	BNE	20$		;Yes, so no I/O to do now		;051
	MARK	SATBUF		;MARK S.A.T. BUFFER FOR WRITE
20$:	ADD	TOS.R1+2(SP),SATCTL(R5) ;WE JUST RETURNED THIS		;051
	ADC	SATCTM(R5)	; MANY BLOCKS TO THE SYSTEM
30$:	MAP	POP,APR=5,DATA	;Restore DPAR5 mapping			;051
	RETURN			;And we're done				;051

GLOBAL	<SATCTL,SATCTM,SATMMU>						;051

;+
; GETCLU - GET A CLUSTER FROM THE SYSTEM.
;
;	R1 =  CLUSTER SIZE
;	FIPUNT = UNIT
;
;	CALL	GETCLU
;
;	R2 =  DCN
;
;	IF C=0 THEN CLUSTER OBTAINED
;	IF C=1 THEN NO CLUSTER AVAILABLE
;-

GETCLU::BIC	#100000,R1	;Clear funny flags from cluster size	;057
	REGSCR			;Save all registers			;057
	MAP	PUSH,APR=5,DATA	;Save APR5 mapping			;057
	CALL	SETSAT		;Get cluster bit count, unit *2		;057
	MOV	R0,-(SP)	;Save the cluster bit count		;057
	MOV	SATPTR(R5),R2	;Get (trial) starting DCN		;057
	CALL	DCNPCN		;Make that DCN into a PCN		;057
10$:	MOV	(SP),R0		;Restore the cluster bit count		;057
20$:	CALL	FNDPCN		;Find the PCN in the SATT		;057
	BCS	210$		;PCN too large, check for wrapping	;057
	CMP	R0,#10		;What kind of search should we do?	;057
	BHI	130$		;Word search, go do that		;057
	BEQ	100$		;Byte search, go for it			;057
	BIT	R3,#1		;Bit search, start of this byte?	;057
	BNE	70$		;Yep, then check for anything free first ;057

; This is the bit searcher

30$:	CMP	SATEND(R5),R2	;Is this PCN legal?			;057
	BLO	210$		;No, check for wrapping around		;057
	BITB	R3,(R4)		;All bit(s) free?			;057
	BEQ	80$		;Yes, cluster found			;057
	ADD	R0,R2		;No, advance to next PCN		;057
	ASH	R0,R3		; and advance the testing mask		;057
	TSTB	R3		;Have bits shifted out (i.e., next byte)? ;057
	BNE	30$		;Not yet, keep checking this byte	;057
	SWAB	R3		;Else get mask for starting next byte	;057
40$:	INC	R4		;Advance to next byte in SATT		;057
	TST	SATMMU(R5)	;Is SATT resident in memory?		;057
	BEQ	50$		;No, not this time			;057
	CMP	R2,SATEND(R5)	;Yes, so check if PCN is legal		;057
	BR	60$		;And join up				;057

50$:	CMP	R4,#SATBUF+777	;Do we have the next PCN in memory?	;057
60$:	BHI	20$		;No, call general routine for buffer shifts ;057
70$:	CMPB	(R4),#-1	;Is anything free in this byte?		;057
	BNE	30$		;Yes, so check it bitwise		;057
	ADD	#10,R2		;No, advance pcn for a whole byte's worth ;057
	BCC	40$		;And go advance to the next SATT byte	;057
	BR	210$		;Overflow, check for wrapping around	;057

80$:	BISB	R3,(R4)		;Mark bits as in use if found		;057
	BR	180$		; and go exit with found cluster	;057

; This is the byte searcher

90$:	ADD	R0,R4		;Advance SATT pointer to		;057
	DEC	R4		; the next byte to check		;057
	ADD	(SP),R2		;Advance to the next PCN		;057
	CMP	SATEND(R5),R2	;Is this PCN legal?			;057
	BLO	210$		;No, check for wrapping around		;057
	TST	SATMMU(R5)	;Resident SATT?				;057
	BNE	100$		;Yes, no end of buffer check		;057
	CMP	R4,#SATBUF+1000	;No, is this PCN in SATBUF?		;057
	BHIS	10$		;No, read it in				;057
100$:	MOV	R1,R0		;Save the byte count			;057
110$:	TSTB	(R4)+		;All bits free?				;057
	BNE	90$		;Nope					;057
	SOB	R0,110$		;Loop for whole cluster			;057
120$:	COMB	-(R4)		;Got it, mark all bit(s)		;057
	SOB	R1,120$		; in the cluster			;057
	BR	180$		;And go exit with the found cluster	;057

; This is the word searcher

130$:	ASR	R1		;Make byte count a word count		;057
	BR	150$		;And join up				;057

140$:	ADD	R0,R4		;Advance SATT pointer			;057
	ADD	R0,R4		; to the next word 			;057
	TST	-(R4)		; to check				;057
	ADD	(SP),R2		;Advance to the next PCN		;057
	CMP	SATEND(R5),R2	;Is this PCN legal?			;057
	BLO	210$		;No, check for wrapping around		;057
	TST	SATMMU(R5)	;Resident SATT?				;057
	BNE	150$		;Yes, no end of buffer check		;057
	CMP	R4,#SATBUF+1000	;No, is this PCN in SATBUF?		;057
	BHIS	10$		;No, read it in				;057
150$:	MOV	R1,R0		;Save the word count			;057
160$:	TST	(R4)+		;All bits free?				;057
	BNE	140$		;Nope					;057
	SOB	R0,160$		;Loop for whole cluster			;057
170$:	COM	-(R4)		;Got it, mark all bit(s)		;057
	SOB	R1,170$		; in the cluster			;057

180$:	TST	SATMMU(R5)	;Resident SATT?				;057
	BNE	190$		;Yes, no I/O do to			;057
	MARK	SATBUF		;No, so be sure that SATBUF gets updated ;057
190$:	MOVB	CLUFAC(R5),R0	;Get the cluster factor			;057
	MOVB	CLUCVT(R0),R0	; to get the cluster ratio (PCS/DCS)	;057
	MUL	R0,R2		;  and find the DCN-1			;057
	INC	R3		;Now we have the real DCN		;057
	MOV	R3,SATPTR(R5)	;Set the round robin search for next time ;057
	MOV	R3,TOS.R2+4(SP)	; And return the found DCN		;057
	SUB	TOS.R1+4(SP),SATCTL(R5) ;We just took this many		;057
	SBC	SATCTM(R5)	; blocks away from the system		;057
	;CLC			;C=0 FROM THE 'SBC' ABOVE		;057
200$:	MOV	(SP)+,R0	;Get back the cluster bit count		;057
	MAP	POP,APR=5,DATA	;Restore APR 5 mapping			;057
	RETURN			; and exit				;057

210$:	CMP	SATPTR(R5),#2	;Set C=1 if we've been all the way around ;057
	BCS	200$		;Failure, exit C=1			;057
	MOV	#1,SATPTR(R5)	;Still might go, but flag next time	;057
	CLR	R2		; and try starting from the beginning	;057
	BR	10$		;  this time				;057

GLOBAL	<SATEND,SATBUF,CLUFAC,CLUCVT,SATPTR,SATCTL,SATCTM,SATMMU>	;057

;+
; GETCL2 - Get N clusters from the system
;
;	R1 =  CLUSTER SIZE
;	R2 =  # of clusters to get
;	FIPUNT = UNIT
;
;	CALL	GETCL2
;
;	R2 =  DCN
;
;	If C=0 then requested clusters available
;	IF C=1 then requested clusters weren't available
;-

GETCL2::BIC	#100000,R1	;Clear the RDS1 flag from clustersize	;051
	REGSCR			;Save all registers
	MAP	PUSH,APR=5,DATA	;And save the APR5 mapping		;051
	CALL	SETSAT		;Get cluster bit count, unit # * 2
	MOV	SATPTR(R5),R2	;Get the trial starting DCN
	CALL	DCNPCN		;Convert that DCN to a PCN
	BR	40$		;And enter the lookup loop		;051

; We come here when we reach the end of the disk with a failure

10$:	CMP	SATPTR(R5),#1	;Have we been all the way around?	;051
	BNE	20$		;No, not this time			;051
	CMP	(SP)+,(SP)+	;Yes, so clean up the stack		;051
	BR	100$		;And get out				;051

; We come here when we reach the end of the disk to start from the
; beginning.

20$:	CLR	R2		;Set to start from the beginning	;051
	MOV	#1,SATPTR(R5)	;And set the flag for next time		;051

; We come here after any failure to clean up the stack and continue

30$:	CMP	(SP)+,(SP)+	;Clean up the stack			;051

; We come here when we are initially looking for a hole
;
; R0 = Cluster bit count
; R2 = Starting PCN to check out
; R5 = Unit # * 2

40$:	MOV	R2,-(SP)	;Save the starting PCN of the hole	;051
	CLR	-(SP)		;And indicate hole size is zero		;051

; We may come here in a loop for each DCN when doing multi-DCN allocation

50$:	CALL	FNDPCN		;Look for this PCN			;051
	BCS	10$		;Not found, check for wrapping around	;051
	ADD	R0,R2		;Preset to the next PCN to check	;051

; We come here for each PCN when doing multi-PCN allocation

60$:	BITB	R3,(R4)+	;Are all the required bits free?	;051
	BNE	30$		;No, try the next PCN			;051
	SOB	R1,60$		;Yes, in this byte, try the next one	;051
	INC	(SP)		;Indicate another cluster found		;051
	CMP	(SP),TOS.R2+4+2(SP) ;Found enough space yet?		;051
	BNE	50$		;No, loop until we do			;051
	MOV	(SP)+,R4	;Yes, so pop the cluster count		;051
	MOV	(SP),R2		;Get back the starting PCN		;051
70$:	MOV	R4,-(SP)	;Save the cluster count			;051
	CALL	FNDPCN		;Find the PCN again			;051
	;BCS			;This can not fail!			;051
80$:	BISB	R3,(R4)+	;Mark the bits in use			;051
	SOB	R1,80$		;For all the bits			;051
	TST	SATMMU(R5)	;Resident SATT for this unit?		;051
	BNE	90$		;Yes, so don't touch SATBUF		;051
	MARK	SATBUF		;SATT is on disk, update it there	;051
90$:	SUB	TOS.R1+6(SP),SATCTL(R5) ;Indicate another cluster	;051
	SBC	SATCTM(R5)	; has been taken from the system	;051
	ADD	R0,R2		;Point to the next cluster		;051
	MOV	(SP)+,R4	;Restore the cluster counter		;051
	SOB	R4,70$		;Loop for all the DCNs to return	;051
	MOV	(SP)+,R3	;Done, get the starting DCN again	;051
	MOVB	CLUFAC(R5),R4	;Get the unit's cluster factor		;051
	MOVB	CLUCVT(R4),R4	; to get the cluster factor (PCS/DCS)	;051
	MUL	R4,R3		;Now find the				;051
	INC	R3		; starting DCN				;051
	MOV	R3,SATPTR(R5)	;Set the trial SATT pointer for next time ;051
	MOV	R3,TOS.R2+2(SP)	;Save the starting DCN for our caller	;051
	TST	(PC)+		;Indicate cluster is found		;051
100$:	SEC			;Indicate cluster not found		;051
	MAP	POP,APR=5,DATA	;Restore APR5 mapping			;051
	RETURN			;And we're done				;051

GLOBAL	<SATCTL,SATCTM,CLUFAC,CLUCVT,SATPTR,SATMMU>			;051

.SBTTL	WRITES FROM FIBUF & SATBUF

;+
; WRITE - WRITE FIBUF.
;
;	CALL	WRITE
;-

WRITE::	MARK	FIBUF		;FORCE A WRITE
	.CALLR	WRITEC		;GO DO IT

;+
; WRITEC - WRITE FIBUF IF DIRTY.
;
;	CALL	WRITEC
;-

WRITEC::REGSCR			;SAVE ALL REGISTERS
	MOV	#FIBUF,R4	;INDICATE A POSSIBLE WRITE TO FIBUF
	MOV	#FIBMOD,R3	;TEST FIBMOD TO SEE IF FIBUF IS DIRTY
	BR	WRTBUF		;GO TO THE CONDITIONAL BUFFER WRITER

;+
; WOMSAT - WRITE SATBUF IF DIRTY.
;
;	CALL	WOMSAT
;-

WOMSAT::REGSCR			;SAVE ALL REGISTERS
	MOV	#SATBUF,R4	;INDICATE A POSSIBLE WRITE TO SATBUF
	MOV	#SATMOD,R3	;TEST SATMOD TO SEE IF SATBUF IS DIRTY
	.BR	WRTBUF		;GO TO THE CONDITIONAL BUFFER WRITER

GLOBAL	<FIBUF,FIBMOD,SATBUF,SATMOD>

;+
; WRTBUF - WRITE A BUFFER TO DISK IF DIRTY
;
;	R3 ->  BUFFER CONTROL AREA
;	R4 ->  BUFFER TO WRITE (R4 = 0 INDICATES FIBUF)
;
;	BR	WRTBUF
;
;	R2 =  RANDOM
;	R3 =  RANDOM
;
;	RETURN
;-

WRTBUF:	TSTB	(R3)		;IS THE BUFFER DIRTY?
	BEQ	20$		;IF NOT, WE'RE OUT EASY
	MOV	R3,-(SP)	;It is, push address of flag		;038
	MOVB	-(R3),FIPAR+DSQUNT ;SET UNIT IN FIP'S DSQ
	BMI	10$		;IF INVALIDATED, DON'T WRITE		;038
	MOV	-(R3),R2	;GET FBN OF BLOCK IN BUFFER LSB
	MOV	-(R3),R3	; AND MSB
	MOV	#WFUN,@#FIPAR+DSQFUN ;SET FUNCTION AS WRITE
	CALL	FIPIO4,R5	;AND WRITE TO BUFFER POINTED TO BY R4
10$:	CLRB	@(SP)+		;Clear dirty buffer flag byte		;038
20$:	RETURN			;AND RETURN

GLOBAL	<FIPAR>

.SBTTL	DELETE FILE/UFD ENTRIES

;+
; XDR - DELETE DIRECTORY ENTRY.
;
;	R2 =  LINK OF PREVIOUS TO ENTRY
;	R3 =  LINK OF ENTRY
;	FIPUNT = UNIT
;	FIBUF HAS ANY BLOCK OF THE MFD
;
;	CALL	XDR
;-

.ENABL	LSB

XDR::	REGSCR			;SAVE ALL REGISTERS
	CALL	XDE		;DO PARTIAL WIPE OF ACCOUNT
	BCS	20$		;BAD OR IN USE, JUST EXIT NOW		;035
	MOV	R0,R2		;UFD START R.E. ENTRY (LOOKS LIKE ONE) 
	BEQ	20$		;NO UFD SO NO DELETE IT			;035
	CALL	READUF		;GET UFD BLOCK INTO BUFFER
	MOV	#FIBENT,R5	;POINT TO UFD'S PSEUDO-R.E.
	CLR	R0		;SET FOR NO NEXT R.E.
	CLR	R4		; AND NO USTAT/UPROT
	BR	100$		;MARK FIBUF AND DELETE THE CLUSTERS

;+
; XFL3 - DELETE FILE ENTRY.
;
;	R3 =  LINK OF ENTRY
;	FIPUNT = UNIT
;	FIBUF HAS ANY BLOCK OF DIRECTORY
;
;	CALL	XFL3
;-

XFL3::	REGSCR			;SAVE ALL REGISTERS
	MOV	FIBENT,R2	;GET DCN OF UFD'S START
	CALL	SDL		; AND FIND THE LINK
	BCS	20$		;NOT FOUND, JUST PUNT			;035
	BR	10$		; ELSE DELETE IT

GLOBAL	<FIBENT>

;+
; XFL - DELETE FILE ENTRY.
;
;	R2 =  LINK OF PREVIOUS TO ENTRY
;	R3 =  LINK OF THIS ENTRY
;	FIPUNT = UNIT
;	FIBUF HAS ANY BLOCK OF DIRECTORY
;
;	CALL	XFL
;-

XFL::	REGSCR			;SAVE ALL REGISTERS
10$:	CALL	XDE		;DO PARTIAL WIPE OF ENTRY
	BCC	30$		;OK, do the rest of delete		;035
20$:	RETURN			;BAD OR IN USE, JUST EXIT NOW		;035

30$:	MOV	R2,R4		;PUT THE USTAT/UPROT VALUE IN A SAFE SPOT
	BPL	90$		;FILE NOT PRIVILEGED, SO NO ERASE ON DELETE
.ASSUME	UP.PRV	EQ	200	;SIGN BIT OF HIGH BYTE
	CALL	WOMSAT		;CLEAR OUT THE SAT BUFFER SO WE CAN USE IT
	MOVB	#-1,SATUNT	;INVALIDATE BUFFER CONTENTS
	MOV	#SATBUF,R3	;POINT TO THE BUFFER
	MOV	#1000/2,R2	;GET LENGTH IN WORDS
40$:	CLR	(R3)+		;MAKE IT A BLOCK
	SOB	R2,40$		; OF ZEROS
	MOV	R0,R3		;COPY THE LINK TO THE FIRST R.E.
50$:	CALL	RDECHK		;READ A R.E., CHECKING FOR ACTUAL
	BEQ	90$		;NO MORE, DONE CLEARING FILE
	MOV	(R5)+,-(SP)	;SAVE LINK TO NEXT R.E.
60$:	MOV	(R5)+,R2	;GET A RETRIEVAL POINTER
	BEQ	80$		;NO MORE, GO POP LINK AND EXIT LOOP
	CALLX	CNVDCN		;CONVERT TO FIP BLOCK NUMBER
	MOV	R1,-(SP)	;SAVE FILE CLUSTER SIZE
	MOV	#WFUN,@#FIPAR+DSQFUN ;SET FUNCTION AS WRITE
70$:	CALL	FIPIOS,R5	;AND WRITE OUT SATBUF
	ADD	#1,R2		;BUMP THE BLOCK TO NEXT
	ADC	R3		; IN CLUSTER
	SOB	R1,70$		;LOOP FOR THE WHOLE FILE CLUSTER
	MOV	(SP)+,R1	;RESTORE THE FILE CLUSTER SIZE
	BIT	R5,#20-1	;DONE THIS RETRIEVAL ENTRY?
	BNE	60$		;NO, DO MORE
80$:	MOV	(SP)+,R3	;GET LINK TO NEXT RETRIEVAL ENTRY
	BR	50$		;GO READ IT AND CONTINUE

GLOBAL	<SATUNT,SATBUF>

;+									;059
; XREP -	Beginning at the middle of a retrival entry, return
;	all clusters to the end of file.
;	
;	R1 = File cluster size
;	R3 = ->link word of retrival entry 
;	R5 = -> first cluster entry to return
;		or -1 to begin at blockette end boundary
;		(ie to keep all 7 clusters in this blockette but
;		 return the first cluster and subsequent in the
;		 next blockette).
;
;	FIPUNT = Unit
;	FIBUF contains retrival blockette to begin in
;
;	CALL	XREP
;-									;059

XREP::	REGSCR								;059
	CLR	R4			;Clear out of SAT flag		;059
	MOV	(R3),R0			;GET NEXT LINK			;059
	CLR	(R3)+			;0 MAKES IT THE LAST		;059
	MARK	FIBUF			;MARK FOR DISC UP DATE		;059
	CMP	#-1,R5			;A BOUNDARY CONDITION REQUEST?	;059
	BEQ	90$			;YES- SPECIAL HANDLING		;059
	CMP	R3,R5			;PROTECT FROM RETURNING ALL 7 	;059
	BNE	110$			;NO PROBLEM IF NOT EQUAL	;059
	CRASH				;illegal to return first cluster;059


;+
; XRE - Delete a file's retrieval entries and return the space
;
;	R0 = Link word to first retrieval entry to remove
;	R1 = File cluster size
;
;	FIBUNT = Unit
;	FIBUF has any block of directory
;
;	CALL	XRE
;
;	All registers are preserved.
;-

XRE::	REGSCR			;Save all registers			;053
	CLR	R4		;And indicate space should be returned	;053
90$:	MOV	R0,R3		;COPY THE LINK
	CALL	RDECHK		;CONDITIONALLY READ NEXT
	BEQ	WOMSAT		;DONE, EXIT
	MOV	(R5),R0		;GET NEXT LINK
	CLR	(R5)+		;WIPE OUT R.E. LINK
100$:	MARK	FIBUF		;MARK BUFFER TO WRITE
110$:	MOV	(R5),R2		;GET NEXT CLUSTER TO RETURN
	BEQ	WOMSAT		;NO MORE, LAST R.E. WAS PARTIALLY FULL
	BITB	R4,#US.OUT	;OUT-OF-SAT TYPE FILE?
	BNE	120$		;YES, DON'T RELEASE THE SPACE
	CALL	RETCLU		;RETURN FILE SPACE
120$:	CLR	(R5)+		;CLEAR THE CLUSTER ENTRY
	BIT	R5,#20-1	;MORE IN THIS R.E.?
	BNE	110$		;YES, FINISH IT OFF
	BR	90$		;NO, LOOP FOR MORE R.E.'S

;+
; XDE - DO PARTIAL WIPE OF ENTRY.
;
;	R2 =  LINK OF PREVIOUS TO ENTRY
;	R3 =  LINK OF ENTRY
;	FIPUNT = UNIT
;	FIBUF HAS ANY BLOCK OF DIRECTORY
;
;	CALL	XDE
;
;	R0 =  LINK TO RETRIEVAL OR UFD DCN
;	R1 =  CLUSTER SIZE
;	R2 =  USTAT/UPROT OF ENTRY
;	R3 =  RANDOM
;	R5 =  RANDOM
;
;	IF C=0 THEN O.K. TO DO REST OF DELETE
;	IF C=1 THEN BAD BLOCK AND/OR IN USE
;-

XDE:	CALL	RDE		;GET ABSOLUTE POINTER TO N.E.
	MOV	(R5),-(SP)	;SAVE LINK TO THE NEXT N.E.
	CALL	SNE		;SEARCH FOR FCB TO SEE IF FILE IS OPEN
	BNE	150$		;IF OPEN, SIMPLY MARK FOR DELETION IN FCB & NE
	TST	UACNT(R5)	;IN USE NOW (OPEN ON DISK OR SMALL FILES)?
	BNE	170$		;YES, SIMPLY MARK FOR DELETION
	MOV	R3,R0		;SAVE LINK TO THIS N.E.
	CALL	RAE		;READ THE ACCOUNTING ENTRY
	BIT	#UL.BAD,(R5)	;A BAD BLOCK IN THIS FILE/UFD?
	BNE	160$		;YES, DON'T DELETE IT NOW THEN
	MOV	R2,R3		;NO, GET LINK TO PREVIOUS N.E.
	CALL	RDE		; AND READ THE PREVIOUS N.E.
	BIC	#UL.BLO!UL.CLO!UL.ENO,(R5) ;REMOVE LINK INFO FROM PREV N.E.
	BIC	#^C<UL.BLO!UL.CLO!UL.ENO>,(SP) ;REMOVE ALL BUT LINK FROM NEXT
	BIS	(SP)+,(R5)	;NOW LINK PREVIOUS TO NEXT
	MOV	R0,R3		;GET BACK LINK TO THIS N.E.
	CALL	RDESV		; AND READ IT SAVING THAT PREVIOUS ALTERATION

	MOV	UAA(R5),R3	;GET LINK TO A.E.
	MOV	UAR(R5),R0	;PUT LINK TO R.E.'S HERE FOR EXIT
	MOV	USTAT(R5),R2	;PUT STATUS BYTE/PROTECTION CODE HERE FOR EXIT
.ASSUME	UPROT	EQ	USTAT+1
	CALL	ZDE		;ZERO OUT THE N.E.
	CALL	RDE		;NOW READ THE A.E.
	MOV	UCLUS(R5),R1	;PUT CLUSTER SIZE HERE FOR EXIT
	MOV	USIZ(R5),-(SP)	;Save the file size LSB			;035
	CLR	-(SP)		;Assume no file size MSB		;035
	TST	URTS(R5)	;Does RTS name exist?			;035
	BNE	130$		;Then assumption is correct		;035
	MOVB	URTS+2(R5),(SP)	;Otherwise save the file size MSB	;035
130$:	CALL	ZDENXT		;MAKE THIS ENTRY A HOLE, SAVING LINK TO NEXT
	;CLC			;C=0 FROM ZDECHK
	CALL	RDECHK		;MORE?
	BNE	130$		;YES, LOOP (NOTE C=0 HERE ALWAYS)
CNTENT::								;061
	MOV	(SP)+,R4	;Copy the file size MSB			;035
	MOV	(SP)+,R3	; and file size LSB			;035
	MOVB	@#FIPUNT,R5	;Get the Fip Unit Number		;035
	ASL	R5		; and make it FUN * 2			;035
	CMP	UNTLVL(R5),(PC)+ ;Support extended quota data?		;035
	 .BYTE	2,1							;035
	BLO	140$		;No, good less work to do		;035
	TST	FIBMAP		;Are we deleting a directory?		;035
	BMI	140$		;Yes					;035
	MOV	R3,-(SP)	;No a file, save the file size LSB	;035
	CLR	R3		;We want the UFD lable entry		;035
	CALL	RDE		;Now go read it				;035
	MOV	(SP)+,R3	;Restore the file size			;035
	CMP	LPPN(R5),(PC)+	;Account [0,1]?				;035
	 .BYTE	1,0							;035
	BEQ	140$		;Yes, no special quotas for these	;035
	MOV	R0,-(SP)	;Save the R.E. link			;035
	MOV	LPPN(R5),-(SP)	; and the PPN				;035
	MOV	SP,R0		;Point R0 at the saved PPN		;035
	MOV	#XDEFIN,-(SP)	;Save our return address		;040
	MAP	PUSH,APR=5,CODE,DATA ;Save the current APR5 values	;035
	MOV	SUBUSG,-(SP)	;Routine we want to dispatch to		;035
	MOV	OPNAP5,-(SP)	; along with the OPN phase APR5 value	;035
	JMPX	CALLMX		;Now go there				;035

XDEFIN:	TST	(SP)+		;Junk the saved PPN			;040
	MOV	(SP)+,R0	;Restore the saved R.E link		;035
140$:	CLC			;Set the C bit				;035
	RETURN			;EXIT WITH C=0				;035

150$:	BISB	#US.DEL,F$STAT(R1) ;FILE IS OPEN, MARK FCB FOR DELETE
	BR	170$		; AND GO MARK THE DIRECTORY, TOO

160$:	MOV	R0,R3		;FILE HAS BADS. GET BACK LINK TO THIS N.E.
	CALL	RDE		; AND READ IT
170$:	BISB	#US.DEL,USTAT(R5) ;INDICATE MARKED FOR DELETE
	COM	(SP)+		;POP SAVED LINK NEXT AND SET C=1
	BR	190$		;GO MARK BUFFER AND EXIT

GLOBAL	<SUBUSG,OPNAP5>							;035


;+
; ZDENXT - ZERO DIRECTORY ENTRY, SAVING LINK TO NEXT ENTRY
;
;	R5 -> LINK OF NEXT ENTRY
;
;	CALL	ZDENXT
;
;	R3 =  LINK OF NEXT ENTRY
;	R5 -> ENTRY
;
;	C=0 ALWAYS
;-

ZDENXT::MOV	(R5),R3		;GET LINK OF NEXT ENTRY
	.BR	ZDE		;ZERO THIS ONE

;+
; ZDE - ZERO DIRECTORY ENTRY.
;
;	R5 -> INSIDE DIRECTORY ENTRY TO ZERO
;
;	CALL	ZDE
;
;	R5 -> ENTRY
;
;	C=0 ALWAYS
;-

ZDE::	BIS	#20-1,R5	;POINT JUST BEYOND
	INC	R5		; THE ENTRY TO ZERO
180$:	CLR	-(R5)		;ZERO A WORD
	BIT	R5,#20-1	;MORE?
	BNE	180$		;YES, LOOP
190$:	MARK	FIBUF		;MARK BUFFER FOR WRITE
	RETURN			;EXIT

.DSABL	LSB

.SBTTL	S.A.T. HANDLING SUBROUTINES

;+
; SETSAT - SET UP S.A.T. PARAMETERS AND CONVERT DCN INTO ALIGNED PCN.
;
;	R1 =  CLUSTER SIZE
;	R2 =  DCN
;	FIPUNT = UNIT
;
;	CALL	SETSAT
;
;	R0 =  CLUSTER BIT COUNT
;	R2 =  (DCN-1)/(PCS/DCS) = PCN
;	R4 =  RANDOM
;	R5 =  UNIT *2
;-

SETSAT::MOVB	FIPUNT,R5	;GET THE UNIT NUMBER
	ASL	R5		; TIMES 2 FOR WORD ADDRESSING
	MOV	R1,-(SP)	;SAVE THE CLUSTER SIZE
	CLR	R4		;avoid sign extensions			;058
	BISB	UNTCLU(R5),R4	;GET THE UNIT'S PACK CLUSTER SIZE
	CLR	R0		;CLEAR A HIGH ORDER AND
	DIV	R4,R0		; FIND: BIT COUNT = (CLU)/(PCS)
	BNE	5$		;real cluster ratio, so ok		;058
	INC	R0		;CLU<PCS, large disk, ok...		;058
5$:	MOV	(SP)+,R1	;RESTORE THE CLUSTER SIZE
	.CALLR	DCNPCN		;CONVERT DCN TO PCN AND RETURN

;+
; DCNPCN - CONVERT DCN TO ALIGNED PCN.
;
;	R0 =  CLUSTER BIT COUNT (FOR ALIGNMENT)
;	R2 =  DCN
;	R5 =  UNIT *2
;
;	CALL	DCNPCN
;
;	R2 =  (DCN-1)/(PCS/DCS) = PCN
;	R4 =  RANDOM
;-

DCNPCN:	DEC	R2		;GET DCN-1
	MOVB	CLUFAC(R5),R4	;GET CLUSTER RATIO FACTOR
	BEQ	10$		;WE HAVE PCN ALREADY
	CLC			;NO SIGN BIT PLEASE
	ROR	R2		;GET (DCN-1)/2 UNSIGNED
	INC	R4		;NOW FINISH GETTING (DCN-1)/(PCS/DCS)
	ASH	R4,R2		; WITHOUT PROPIGATING THE SIGN BIT
10$:	DEC	R0		;MAKE BIT COUNT AN ALIGNMENT MASK
	BIC	R0,R2		;NOW THE PCN IS CORRECTLY ALIGNED
	INC	R0		;RESTORE CORRECT BIT COUNT
	RETURN			; THEN EXIT

GLOBAL	<FIPUNT,UNTCLU,CLUFAC>

;+
; REDSAT - READ SOMETHING INTO SATBUF.
;
;	R2 = FBN (LOW)
;	R3 = FBN (HIGH)
;	FIPUNT = UNIT
;
;-

REDSAT::MOV	R4,-(SP)	;SAVE R4 FOR THE CALLER
	MOV	#SATFBN+F.FBNL,R4 ;POINT TO: SATFBN(2W), SATUNT(1B)
	CMP	R2,(R4)+	;LSB MATCH BLOCK IN BUFFER?
	BNE	10$		;NO, DO I/O
	CMP	R3,SATFBN	;MSB MATCH?
	BNE	10$		;NO, DO I/O
	CMPB	FIPUNT,(R4)	;UNIT MATCH?
	BEQ	20$		;YES, NO I/O NEEDED
10$:	CALL	WOMSAT		;FORCE OUT DIRTY PAGE IF NEEDED
	MOVB	#-1,(R4)	;INVALIDATE BUFFER JUST BEFORE I/O
	MOV	#RFUN,@#FIPAR+DSQFUN ;SET FUNCTION AS READ
	CALL	FIPIOS,R5	;AND READ THE PAGE INTO SATBUF
	MOVB	FIPUNT,(R4)	;NOW SET UNIT
	MOV	R2,-(R4)	; AND LSB
	MOV	R3,-(R4)	;  AND MSB OF BLOCK JUST READ
20$:	MOV	(SP)+,R4	;RETURN THE CALLERS R4
	RETURN			;AND RETURN TO OUR CALLER

GLOBAL	<SATFBN,FIPUNT>

;+
; FNDPCN - FIND A PCN IN S.A.T.
;
;	R0 =  CLUSTER BIT COUNT
;	R2 =  (DCN-1)/(PCS/DCS) = PCN
;	R5 =  UNIT *2
;	FIPUNT = UNIT
;
;	CALL	FNDPCN
;
;	R1 =  BYTE COUNT WITHIN S.A.T.
;	R3 =  BIT MASK WITHIN BYTE
;	R4 -> Byte associated with PCN (within SATBUF if not loaded,
;	      otherwise mapped through DPAR5).
;
;	IF C=0 THEN WITHIN S.A.T.
;	IF C=1 THEN OUT OF S.A.T.
;-

FNDPCN:	MOV	R2,-(SP)	;SAVE THE PACK CLUSTER NUMBER		;051
	CMP	SATEND(R5),R2	;STILL WITHIN THE S.A.T. ?
	BLO	50$		;NO, EXIT C=1 ('BLO'='BCS')
	;CLC			;C=0 SINCE BLO FAILED
	ROR	R2		;SHIFT ONCE WITH NO SIGN EXTEND
	ASH	#-2,R2		;FIND LOGICAL BYTE POINTER WITHIN S.A.T.
	MOV	R2,-(SP)	;SAVE LOGICAL BYTE POINTER
	MOV	SATMMU(R5),R3	;Pick up MMU address of SATT		;051
	BEQ	10$		;None, SATT is out on disk		;051
	MAP	R3,APR=5,DATA	;Map the SATT through APR5		;051
	ADD	#120000,(SP)	;And point to it virtually		;051
	BR	20$		;Now join up				;051

10$:	BIC	#^C<777>,(SP)	;Trash all but byte offset into SATBUF	;051
	ADD	#SATBUF,(SP)	;Now calculate actual SATBUF address	;051
	CLRB	R2		;FIND THE S.A.T.			;051
	SWAB	R2		; FILE VIRTUAL
	ASR	R2		;  BLOCK NUMBER (/1000)
	MOV	SATSTM(R5),R3	;NOW ADD IN THE
	ADD	SATSTL(R5),R2	; S.A.T.'S FILE
	ADC	R3		;  BASE WITH CARRY IF NEEDED
	CALL	REDSAT		;AND NOW, READ IT INTO SATBUF.

GLOBAL	<SATEND,SATSTM,SATSTL,SATBUF,SATMMU>				;051

20$:	MOV	R0,R1		;COPY THE BIT COUNT AND
	MOV	#377,R3		; GUESS AT FULL BYTES
	CMP	R0,#4		;GOOD GUESS?
	BHI	40$		;YES
	MOV	2(SP),R4	;NO, GET THE PCN BACK AGAIN TO
	BIC	#^C<7>,R4	; ISOLATE THE BIT WITHIN BYTE
	ADD	#BITBYT,R4	;  AND FORM A BIT TABLE POINTER
	CLR	R3		;CLEAR THE BIT MASK
30$:	BISB	(R4)+,R3	;NOW COLLECT THE
	SOB	R1,30$		; CORRECT BIT MASK
	MOV	#10,R1		;SET FOR CONVERSION TO BYTE COUNT = 1
40$:	ASH	#-3,R1		;FORM THE BYTE COUNT FOR CLUSTER
	MOV	(SP)+,R4	;Get the pointer within SATBUF or DPAR5
	CLC			;Indicate that block is in SATT		;051
50$:	MOV	(SP)+,R2	;RESTORE THE ORIGINAL PCN
	RETURN			;NOW EXIT

GLOBAL	<BITBYT>							;051

.SBTTL	DISMOUNT A UNIT

;+
; ZAPUNT - DISMOUNT A UNIT.
;
;	R1 =  FIP UNIT NUMBER TIMES 2
;
;	CALL	ZAPUNT
;-

ZAPUNT::MOV	R1,-(SP)	;SAVE FIP UNIT NUMBER TIMES 2		;047
	MOV	SP,FIPESP	;Remember our current stack ->		;047
	MOV	#50$,FIPERX	;Set the address for I/O error handling	;047
	CALL	WRITEC		;CHECK/CLEAR FIBUF
10$:	MOV	#60$,FIPERX	;Set the address for I/O error handling	;047
	CALL	WOMSAT		;CHECK/CLEAR SATBUF
20$:	CLR	FIPERX		;Clear the error handler address	;047
	MOV	(SP),R1		; and make sure R1 = FUN * 2		;047
	ASR	R1		;MAKE PLAIN OLD UNIT NUMBER NOW
	CMPB	R1,FIBUNT	;UNIT IN FIBUF?
	BNE	30$		;NOPE
	COMB	FIBUNT		;YES, INVALIDATE BUFFER (UNIT)
	CLRB	@#FIBMOD	; and indicate no modifications		;047
30$:	CMPB	R1,SATUNT	;UNIT IN SATBUF?
	BNE	40$		;NOPE
	COMB	SATUNT		;YES, INVALIDATE BUFFER (UNIT)
	CLRB	@#SATMOD	; and indicate no modifications		;047
40$:	MOV	R4,-(SP)	;Get a scratch register			;052
	MOVB	#RELFUN,FIPAR+DSQFUN ;Function is release		;052
	MOV	#FIPAR+DSQUNT,R4 ;Point at DSQUNT in FIP's DSQ		;052
	MOVB	R1,(R4)		;Set up the FIP unit number to release	;052
	MOV	#FPDNE,-(R4)	;And L3Q root				;052
.ASSUME	DSQL3Q	EQ	<DSQUNT-2>
	MOV	FIJOB,-(R4)	;Set the job number (DSQERR = ???)	;052
.ASSUME	DSQJOB	EQ	<DSQL3Q-2>
	CLR	-(R4)		;Clear link to next and point to top	;052
.ASSUME	DSQJOB	EQ	2
	CALLX	DISK		;Go release that unit			;052
	CALL	FIPWAT		;And wait for it to complete		;052
	MOV	(SP)+,R4	;Restore our work register		;052
	CALLX	CHEZAP		;ZAP UNIT'S BUFFERS
	MUL	#DL$SIZ,R1	;INDEX INTO THE DISK TABLE		;034
	ADD	#DSKLOG,R1	;CLEAR THE LOGICAL NAME			;034
	CLR	(R1)+		; ALL					;034
	CLR	(R1)+		;  THREE				;034
	CLR	(R1)		;   WORDS				;034
	MOV	(SP)+,R1	;RESTORE UNIT TIMES 2
	MOV	#UC.MNT,UNTCNT(R1) ;DISMOUNT THE UNIT
	CLRB	UNTOWN(R1)	; and indicate no current owner
	RETURN			; AND EXIT

50$:	MOV	FIPESP,SP	;Restore the saved stack ->		;047
	BR	10$		;Return inline				;047

60$:	MOV	FIPESP,SP	;Restore the saved stack ->		;047
	BR	20$		;Return inline				;047

GLOBAL	<FIBUNT,SATUNT,DSKLOG,UNTCNT,FIPESP,FIPERX,FIBMOD,SATMOD>	;047

.SBTTL	CHECK FOR LEGAL FILE NAME SPECIFICATION

;+
; CHKNAM - CHECK FOR A LEGAL RSTS/E FILE NAME SPECIFICATION
;
;	R4 -> FILE NAME (AS THREE WORDS OF RAD50) MINUS FQNAM1
;		(I.E. TO CHECK FQNAM1 R4 -> FIRQB)
;		(     TO CHECK FQNAM2 R4 -> FIRQB+FQNAM2-FQNAM1)
;
;	CALLX	CHKNAM
;	CALLX	CHKWLD
;
;	ALL REGS PRESERVED, EXECUTION RETURNS IF NO ERROR
;	EXECUTION TERMINATES WITH BAD NAME ERROR IF BAD NAME DETECTED
;	CHKNAM DOES NOT PERMIT WILD CARD FIELDS, CHKWLD DOES.
;
;	C BIT SET IF WILD CARDS WERE FOUND  (CHKWLD ONLY)
;-

.ENABL	LSB

CHKNAM::TST	(PC)+		;CLEAR THE CARRY FOR NORMAL NAME CHECK
CHKWLD::SEC			;SET THE CARRY FOR SPECIAL WILD CHECK
	REGSCR			;SAVE ALL THE REGISTERS
	ROR	R5		;PUT THE WILD CARD INDICATOR IN R5
	BIC	#77777,R5	; CLEAR ALL BUT THE SIGN BIT IN WILD FLAG
10$:	ADD	#FQNAM1+2,R4	;POINT TO THE SECOND WORD OF NAME TO CHECK
	MOV	R4,-(SP)	; AND REMEMBER THIS SIGNIFICANT LOCATION
	CMP	(R4)+,(R4)+	;Point beyond name/extension
20$:	CLR	R2		;HAVEN'T SEEN ANY NON-SPACES YET
30$:	MOV	-(R4),R0	;GET THE NEXT RAD50 WORD
	MOV	#3,R3		;SET TO LOOP FOR EACH CHARACTER IN WORD
40$:	MOV	R0,R1		;GET QUOTIENT TO DIVIDE
	CLR	R0		; CLEAR OUT THE HIGH-ORDER REGISTER
	DIV	#50,R0		;  GET THE NEXT CHARACTER IN R1
	TST	R1		;WAS CHAR A SPACE?
	BNE	60$		; NO, CONTINUE WITH THE OTHER CHECKS
	TST	R2		; YES, HAVE WE SEEN A NON-SPACE YET?
	BEQ	80$		;  NOPE, SEEN NOTHIN' BUT SPACES SO FAR...
	.BR	50$		;  YUP, A SPACE BEFORE A NON-SPACE IS ILLEGAL

50$:	ERROR	BADNAM		;SOME ERROR OCCURRED IN FILE NAME, REPORT IT

60$:	SUB	#26.,R1		;SUBTRACT BASE OF ALPHA CHARACTERS
	BLE	70$		; IT WAS AN ALPHA, THAT'S LEGAL
	SUB	#3,R1		;CODE IN RANGE 1-13. ADJUST TO -2 TO 10.
	BMI	50$		; ILLEGAL CHARS ARE -1, -2 ($,.)
	BNE	70$		;IT WAS A NUMBER, THAT'S LEGAL
	TST	R5		;IT WAS A WILD CARD, ARE WE PERMITTING THEM?
	BPL	50$		; NO, REPORT THE USER AN ERROR
	BIS	#1,R5		; YES, SET THE "WILD CARD FOUND" FLAG
70$:	INC	R2		;FLAG THAT WE'VE SEEN A NON-SPACE
80$:	SOB	R3,40$		;LOOP FOR EACH CHARACTER IN THIS WORD
	TST	R0		; WAS THE ORIGINAL WORD ABOVE RAD50 "999"?
	BNE	50$		;  YES, RETURN AN ERROR
	CMP	R4,(SP)		;HOW FAR BACK THROUGH "NAME.EXT" ARE WE?
	BHI	20$		; JUST FINISHED "EXT", GO DO THE NAME
	BEQ	30$		; FINISHED SECOND WORD OF NAME, DO FIRST
	TST	R2		;FINISHED ALL OF NAME, WAS IT ALL SPACES?
	BEQ	50$		; YES, AN ALL-SPACE NAME IS AN ERROR
90$:	TST	(SP)+		;CLEAN UP THE STACK
	ROR	R5		;POP WILD FLAG, SETTING CARRY IF WILD FOUND
	RETURN			; AND RETURN

.DSABL	LSB

.END
