.INCLUDE	/CMN:COMMON.MAC/
.LIBRARY	/CUI:CUIMAC.MLB/
.INCLUDE	/CUI:CUIPFX.MAC/
TITLE	CUIA2B,<CUI Ascii to Binary Conversion>,0A,10-MAY-91,GPK/JFM

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR CUIA2B
;+
;
;  001	JFM  10-JAN-84	Created from ASCBIN.MAC and CDBL.MAC
;  002	JFM  08-MAR-84	Separated routines into two separate PSECTS
;  003	JFM  12-MAR-84	Separated CUIASC into CUIA2B and CUIB2A for overlay
;			purposes.  These routines are called from different
;			overlays.
;
;			[RSTS/E V9.7]
;  004	JFM  19-Sep-88	Removed references to the psect CUIA2B, since it's not
;			used.

;
;-

	.PSECT	CUILEX,RO,REL,LCL,CON

;+
; The ASCII to BINARY routines ($XDTB etc) are used by the parsing routines 
; like LX.INT, LX.TIME, etc to convert the user's ASCII characters into binary 
; to compute integers, dates, etc.  These I put into the CUILEX PSECT because 
; that is the CUI PSECT that references these routines.  
;-

.SBTTL	SUBROUTINE PURPOSES
;
;	GENERAL PURPOSE ASCII TO BINARY ROUTINES
;
;	ROUTINE		PURPOSE
;	-------		-------
;
;	$XDTB		CONVERT ASCII DECIMAL TO BINARY WORD
;	$XDTBB		CONVERT ASCII DECIMAL TO BINARY BYTE
;	$XDT2B		CONVERT ASCII DECIMAL TO TWO BINARY WORDS
;	$XOTB		CONVERT ASCII OCTAL TO BINARY WORD
;	$XOTBB		CONVERT ASCII OCTAL TO BINARY BYTE
;	$XOT2B		CONVERT ASCII OCTAL TO TWO BINARY WORDS
;
; INPUT:
;
;	R0 = INPUT BUFFER POINTER
;	R1 = RESULT POINTER
;	R2 ! 100000 IMPLIES SIGNED INTEGER ASSUMED
;	R2 = MAXIMUM FIELD WIDTH
;	   = 0 - NO FIELD WIDTH SPECIFIED
;
; OUTPUT:
;
;	RESULT STORED IN BYTE, WORD, OR DOUBLE WORD POINTER TO BY R1
;	R0 = UPDATED BUFFER POINTER
;	R1 = UNCHANGED
;	R2 = TERMINAL CHARACTER
;	   = 0 - END OF INPUT DETECTED
;	   < 0 - ENTIRE FIELD USED
;	R3 = UNCHANGED
;	R4 = UNCHANGED
;	R5 = UNCHANGED
;	C  = 0 - NO CONVERSION ERROR
;	   = 1 - CONVERSION ERROR
;
; METHOD:
;
;	THE INPUT BUFFER IS SCANNED AND LEADING SPACES OR HORIZONTAL TABS ARE
;	DISCARDED.  A PLUS SIGN (+), MINUS SIGN (-), OR DIGIT IS RECOGNIZED AS
;	START OF NUMBER.  THE NUMBER IS THEN SCANNED UNTIL A NON-NUMERIC
;	CHARACTER IS FOUND OR THE FIELD WIDTH RUNS OUT.  A CONVERSION ERROR IS
;	RETURNED IF THE RESULT WILL NOT FIT IN THE SPECIFIED OUTPUT SIZE.  THE
;	PRESENCE OF A LEADING PLUS OR MINUS SIGN WILL FORCE THIS ROUTINE TO
;	COMPARE THAT SIGN WITH THE SIGN OF THE RESULT AND RETURN A CONVERSION
;	ERROR IF THEY ARE DIFFERENT.  IF NO LEADING SIGN IS PRESENT A PLUS IS
;	ASSUMED AND A CONVERSION ERROR IS RETURNED IF THE RESULT WILL NOT FIT
;	INTO THE FULL NUMBER OF BITS SPECIFIED BY THE CONVERSION ROUTINE.
;
; EXAMPLE:
;
;	ON A CALL TO $XOTBB THE STRING "+377" WILL RETURN WITH THE CARRY BIT
;	SET, "377" WILL RETURN WITH THE CARRY BIT CLEAR.
;-

	.SBTTL	$XDTBB	- DECIMAL TO BYTE

$XDTBB::MOV	R3,-(SP)	; SAVE REGISTERS 3-5
	MOV	R4,-(SP)	;
	MOV	R5,-(SP)	;	
	MOV	#377,-(SP)	; SET BYTE CONVERSION FLAG
	BR	XDT

	.SBTTL	$XDTB	- DECIMAL TO WORD

$XDTB::	MOV	R3,-(SP)	; SAVE REGISTERS 3-5
	MOV	R4,-(SP)	;
	MOV	R5,-(SP)	;	
	CLR	-(SP)		; SET WORD CONVERSION FLAG
	BR	XDT

	.SBTTL	$XDT2B	- DECIMAL TO DOUBLE WORD

$XDT2B::MOV	R3,-(SP)	; SAVE REGISTERS 3-5
	MOV	R4,-(SP)	;
	MOV	R5,-(SP)	;	
	MOV	#1,-(SP)	; SET DOUBLE WORD CONVERSION FLAG

XDT:	MOV	#9.,R3		; UPPER NUMERIC BOUND
	BR	XCOM

	.SBTTL	$XOTBB	- OCTAL TO BYTE

$XOTBB::MOV	R3,-(SP)	; SAVE REGISTERS 3-5
	MOV	R4,-(SP)	;
	MOV	R5,-(SP)	;	
	MOV	#377,-(SP)	; SET BYTE CONVERSION FLAG
	BR	XOT

	.SBTTL	$XOTB	- OCTAL TO WORD

$XOTB::	MOV	R3,-(SP)	; SAVE REGISTERS 3-5
	MOV	R4,-(SP)	;
	MOV	R5,-(SP)	;	
	CLR	-(SP)		; SET WORD CONVERSION FLAG
	BR	XOT

	.SBTTL	$XOT2B	- OCTAL TO DOUBLE WORD

$XOT2B::MOV	R3,-(SP)	; SAVE REGISTERS 3-5
	MOV	R4,-(SP)	;
	MOV	R5,-(SP)	;	
	MOV	#1,-(SP)	; SET DOUBLE WORD CONVERSION FLAG

XOT:	MOV	#7.,R3		; UPPER NUMERIC BOUND

	.SBTTL		XCOM

XCOM:	MOV	R1,-(SP)	; RESULT POINTER
	CLR	-(SP)		; SIGN FLAG
	CLR	R4		; RESULT ACCUMULATORS
	CLR	R5
10$:	MOVB	(R0)+,R1	; INPUT CHARACTER
	BEQ	XCOM1		; BRANCH IF END OF INPUT STRING
	TST	(SP)		; NUMBER STARTED YET?
	BNE	30$		; BRANCH IF SO
	CMPB	#'-,R1		; MINUS SIGN?
	BNE	20$		; BRANCH IF NOT
	COM	(SP)		; SET MINUS FLAG
	BR	60$

20$:	CMPB	#' ,R1		; LEADING SPACE?
	BEQ	60$		; BRANCH IF SO
	CMPB	#TAB,R1		; LEADING TAB?
	BEQ	60$		; BRANCH IF SO
	INC	(SP)		; SET POSITIVE SIGN
	CMPB	#'+,R1		; PLUS SIGN?
	BEQ	60$		; BRANCH IF SO
	BIT	R2,#100000	; SIGNED INTEGER ASSUMED?
	BEQ	25$		; NO
	INC	(SP)		; SET POSITIVE SIGN
	BR	30$		; (SP) > 0  --> POSITIVE SIGN THERE OR ASSUMED
				; (SP) = -1 --> NEGATIVE SIGN WAS SPECIFIED
				; (SP) = 100000 NO LEADING SIGN
25$:	MOV	#100000,(SP)	; SET NO LEADING SIGN FLAG
30$:	BIC	#100000,R2	; STRIP FLAG BIT
	SUB	#'0,R1		; CONVERT DIGIT TO VALUE
	BLO	70$		; BRANCH IF NOT A DIGIT
	CMP	R1,R3		; CHARACTER IN RANGE?
	BHI	70$		; BRANCH IF NOT
	ASHC	#1,R4		; MULTIPLY BY TWO
	BCS	XERR2		; BRANCH IF NUMBER TOO LARGE
	MOV	R4,-(SP)	; SAVE HIGH ORDER BITS
	MOV	R5,-(SP)	; SAVE LOW ORDER BITS
	ASHC	#1,R4		; MULTIPLY BY TWO AGAIN
	BCS	XERR		; BRANCH IF NUMBER TOO LARGE
	ASHC	#1,R4		; HAVE (NEW NUMBER) = 8.*(OLD NUMBER)
	BCS	XERR		; BRANCH IF NUMBER TOO LARGE
	CMP	#9.,R3		; DECIMAL CONVERSION?
	BEQ	40$		; BRANCH IF SO
	CMP	(SP)+,(SP)+	; CLEANUP STACK
	BR	50$

40$:	ADD	(SP)+,R5	; ADD BACK 2*(OLD NUMBER)
	ADC	R4
	BVS	XERR1		; BRANCH IF NUMBER TOO LARGE
	ADD	(SP)+,R4	; HAVE (NEW NUMBER) = 10.*(OLD NUMBER)
	BVS	XERR2		; BRANCH IF NUMBER TOO LARGE
	BCS	XERR2
50$:	ADD	R1,R5		; ADD NEW DIGIT
	ADC	R4
	BCS	XERR2		; BRANCH IF NUMBER TOO LARGE
60$:	SOB	R2,10$		; LOOP IF MORE TO CONVERT
	COM	R1		; SET ENTIRE FIELD USED FLAG
	BR	XCOM1

70$:	ADD	#'0,R1		; RESTORE ORIGINAL CHARACTER

	.SBTTL		XCOM1

XCOM1:	MOV	R1,R2		; TERMINAL CHARACTER
	MOVB	(SP)+,R3	; SIGN FLAG
	BGT	20$		; BRANCH IF PLUS SIGN
	BEQ	30$		; BRANCH IF NO LEADING SIGN
	TST	R4		; IT'S NEGATIVE, IS IT -0?
	BNE	5$		; NO
	TST	R5		; MAYBE
	BEQ	30$		; YES.  TREAT IT AS UNSIGNED
5$:	NEG	R5		; MAKE LOW ORDER BITS NEGATIVE
	BCC	10$		; BRANCH IF ZERO LOW HALF
	INC	R4		; ADJUST HIGH ORDER BITS
	BEQ	XERR3		; BRANCH IF NUMBER TOO LARGE
10$:	NEG	R4		; MAKE HIGH ORDER BITS NEGATIVE
	BPL	XERR3		; BRANCH IF NUMBER TOO LARGE
	BR	30$

20$:	TST	R4		; CHECK IF NUMBER TOO LARGE
	BMI	XERR3		; BRANCH IF NUMBER TOO LARGE
30$:	MOV	(SP)+,R1	; RESULT POINTER
	TSTB	(SP)+		; CONVERION TYPE FLAG
	BLT	40$		; BRANCH IF BYTE
	BEQ	70$		; BRANCH IF WORD
	MOV	R4,@R1		; STORE HIGH BITS
	MOV	R5,2(R1)	; STORE LOW BITS
	BR	XEXIT		; (CARRY CLEAR FROM TST)

40$:	SWAB	R5		; SETUP FOR TESTS
	TSTB	R3		; LEADING SIGN?
	BEQ	60$		; BRANCH IF NOT
	BLT	50$		; BRANCH IF MINUS SIGN
	TST	R5		; POSITIVE RESULT?
	BLT	XERR4		; BRANCH IF NOT
	BR	60$

50$:	COM	R4		; SETUP FOR TESTS
	TST	R5		; WILL SIGNED RESULT FIT IN ONE BYTE?
	BGT	XERR4		; BRANCH IF NUMBER TOO LARGE
	COMB	R5		; ADJUST OLD HIGH BYTE OF LOW ORDER BITS
60$:	TSTB	R5		; CHECK IF RESULT FITS ONE BYTE
	BNE	XERR4		; BRANCH IF NUMBER TOO LARGE
	TST	R4		; CONTINUE CHECK
	BNE	XERR4		; BRANCH IF NUMBER TOO LARGE
	SWAB	R5		; SETUP FOR STORE
	MOVB	R5,@R1		; STORE BYTE
	BR	XEXIT		; (CARRY CLEAR FROM SWAB)

70$:	TSTB	R3		; LEADING SIGN?
	BEQ	90$		; BRANCH IF NOT
	BLT	80$		; BRANCH IF MINUS SIGN
	TST	R5		; POSITIVE RESULT?
	BLT	XERR4		; BRANCH IF NOT
	BR	90$

80$:	COM	R4		; SETUP FOR TESTS
	TST	R5		; NEGATIVE RESULT?
	BGT	XERR4		; BRANCH IF NOT
90$:	TST	R4		; CHECK IF RESULT FITS ONE WORD
	BNE	XERR4		; BRANCH IF NUMBER TOO LARGE
	MOV	R5,@R1		; STORE WORD
	BR	XEXIT		; (CARRY CLEAR FROM TST)

	.SBTTL		ERROR AND NORMAL EXITS

XERR:	TST	(SP)+		; ADJUST STACK (SAVED HIGH ORDER BITS)
XERR1:	TST	(SP)+		; ADJUST STACK (SAVED LOW ORDER BITS)
XERR2:	TST	(SP)+		; ADJUST STACK (SIGN FLAG)
XERR3:	MOV	(SP)+,R1	; RESULT POINTER
	TST	(SP)+		; ADJUST STACK (CONVERSION TYPE FLAG)
XERR4:	SEC			; SET CONVERSION ERROR
XEXIT:	MOV	(SP)+,R5	; RESTORE REGISTER 5
	MOV	(SP)+,R4	; RESTORE REGISTER 4
	MOV	(SP)+,R3	; RESTORE REGISTER 3
	RETURN

	.END
