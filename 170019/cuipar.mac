.INCLUDE	/CMN:COMMON.MAC/
.LIBRARY	/CUI:CUIMAC.MLB/
.INCLUDE	/CUI:CUIPFX.MAC/
TITLE	CUIPAR,<CUI Parser>,0A,10-MAY-91,CEK/JFM/KPH/SDL/GMB/BTK/BTB

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR CUIPAR
;+
;
;  001	CEK  16-APR-82	Added edit history.
;  002	CEK  16-APR-82	Removed @# notation.
;  003	CEK  16-APR-82	Fixed bug where $$$$$$$$$$$$ made DCL overflow stack. 
;  004	CEK  16-APR-82	Made DCLPAR a normal subr instead of PPARSE pattern.
;  005	CEK  16-APR-82	Improved messages about filespecs.
;  006	CEK  30-APR-82	Changed ORG statements
;  007	CEK  27-MAY-82	Prompt for continuation if line ends with comma or plus
;  008	CEK  27-MAY-82	Changed name from DCLPAR to CUIPAR
;  009	CEK  01-JUL-82	Eliminated flavors and colors.  Added CONF= construct.
;  010	CEK  01-JUL-82	Changed meaning of CLASS= construct.
;  011	CEK  01-JUL-82	Added REQUIRE= construct.
;  012	CEK  01-JUL-82	Added $PARKEY construct.  
;  013	CEK  01-JUL-82	Made main parse table (CMDTBL) threaded.
;  014	CEK  01-JUL-82	Moved handling of DCL/CCL/$ prefixes into DCLCMD.MAC.
;  015	CEK  02-JUL-82	Added DFLTKA construct.
;  016	CEK  11-AUG-82	Made CLASS= work with REQUIRE= on DEFQUAL.
;  017  JFM  09-SEP-82  Added $DISALLOW construct.
;  018	CEK  01-Oct-82  Use new NXT.NODE call to CUITRE.
;  019	CEK  01-Oct-82  Check for text strings longer than U.STR buffer.
;  020	CEK  01-Oct-82	Support fancy args, like /FOO=NOBAR.
;  021	CEK  01-Oct-82	Change global symbol names to begin with U$.
;  022	CEK  15-Oct-82	Added $PARKEY SLASH feature.
;  023	CEK  06-Dec-82	Changed symbol names and comments
;  024	JFM  28-Dec-82	Changed PARKEY SLASH error message.
;  025	JFM  07-Jan-83	Added BUMPDA construct.
;  026	JFM  27-Jan-83	Made NETPOS global.
;  027	JFM  01-Feb-83	Changed PARARG to make it a recursive routine.
;  028	JFM  09-Feb-83	Added $PARPFX routine to parse DCL prefixes
;  029	JFM  29-Apr-83	Changed all CRE.NODE LEVEL= syntax to #.
;  030	JFM  29-Apr-83	Added CALBX LX.BLA to U$ENDCMD to parse all spaces
;			before checking for unexpected characters and such.
;  031	JFM  29-Apr-83	Fixed up recursive PARARG routine.
;  032	JFM  10-May-83	Added GLOBAL TAG to ONKEY.
;  033	JFM  10-May-83	Added, changed comments.
;  034	JFM  22-Sep-83	?No qualifiers allowed, when no qualtable specified.
;  035  KPH  10-Nov-83	Added .SAVE and .RESTORE assembler directives to
;			MACROs that modify PSECT context.
;  036	JFM  23-Nov-83	Allowed qualifers like /NOTIFY (that begin with "NO") 
;  037	JFM  23-Nov-83	Negative quals accept arguments if QF.NARG specified
;  038	JFM  11-Dec-83	Removed $PARPFX hack
;  039	JFM  18-Jan-84	$PARM and DEFARG arguments MINVAL and MAXVAL
;  040	JFM  18-Jan-84	$PARMs now require a space unless PF.SEP
;  041	JFM  18-Jan-84	You will now get reprompted for a parameter
;  042	JFM  28-Feb-84	Fixed PARARG bug - LX.SUP destroys R4
;  043	JFM  08-Mar-84	32-bit integer bugs, MINVAL, MAXVAL bug fixes
;  044	JFM  08-May-84	?Conflicting qualifiers goes away
;  045	JFM  08-May-84	DIR/DATE/NODATE doesn't conflict
;  046	SDL  10-Sep-84	Changed message text of various messages
;  047	JFM  20-Dec-84	Fixed parameter prompting and bug if file parm is 
;			specified right away
;  048  GMB  17-Jun-85	Fixed delinking conflicting qualifiers
;  049  GMB  09-Nov-86  Fixed bug 3137: CUI stripped leading "+" from P1
;
;			[RSTS V9.5]
;  050	JFM  04-Jun-87	Added integer support for U$PO2 in U$PARM, DEFARG
;
;			[RSTS/E V9.7]
;  051	JFM  15-Sep-88	To speed things up, CALL, don't CALB LX.BLA and LX.EOS
;			Added a way to globalize labels on ONKEY statements
;			Unglobalized variables.  Made change so keywords 
;			beginning with "NO" (like NONE) are allowed.
;  052	BTK  16-Jan-89	Fixed ^ placement for Conflicting elements
;  053	BTB  24-Apr-89	Removed change 052 (caused worse placement problem)
;
;			[RSTS/E V10.0]
;  054	JFM  20-Jun-90	Check for no qualifier table in U$ENDCMD.
;			Use .ASSUMEs in place of Q.TAG since it's value is 0.
;-

  	.MCALL	SUBR,CALB,.ASSERT,CRE.NODE,FET.NODE,$CUI
	.PSECT	CUIPAR,RO,REL,LCL,CON
	DEFORG	CUIPAR


	$CUI	TABLE		;Include CUI table macros.

.SBTTL	Variables
	TMPORG	IMPURE
NET::	.BLKW			;Network command?  YES or NO. Default is NO.
U.NODE::.BLKW			;Pointer to node which was fetched and present
NETPOS::.BLKW			;Scan position at which network-ness was
				;first determined.  0 if network-ness
				;not determined yet.
CONFPOS::.BLKW			;Position of lefthand element of syntax
				;conflict.  (LX.ERP is the position of
				;the righthand element.)  0 if no error
				;or if the syntax error is not a conflict.
CMDQUAL:.BLKW			;Address of table of command qualifiers
				;(the one mentioned in the $DEFCMD statement).
				;Zero if no command qualifiers mentioned
				;in $DEFCMD statement.
TMP.LVL:.BLKW			;Temporary level count for creating and 
				;fetching nodes.
NXTKEY::.BLKW			;Next keyword.  As we are parsing along, a
				;keyword could have spaces in it.  This cell 
				;holds position of last keyword parsed
SLAPOS::.BLKW			;Slash position.  A keyword can have a slash
				;in it.  This cell holds position of where 
				;slash should have been if it were found. (It
				;wasn't)
	UNORG

.SBTTL	CUIPAR--Parse a command.
;+
; CUIPAR--Parse a command.
;
; INPUTS:
;	CMDTBL	=	threaded routine to process command
;	CMDBUF contains command string.
;	CMDLEN 	=	length of command string.
;
; CALB	CUIPAR
;
; OUTPUTS:
;	R0	=	status
;	U.CMN+U.KEY =	keyword code of primary keyword matched, or 0 if no 
;			match
;
; EFFECT:
;	The threaded routine is invoked to parse and process the command.
;-

.ENABL	LSB

CUIPAR::SUBR
	MOV	CMNADR,R4	;Point at CUI common.
	CLR	CMDLEN		;Nothing in CMDBUF yet.
	CALBX	LX.INI <#CMDBUF,#CMDLEN>
				;Initialize to parse command.
	CLR	CONFPOS		;No syntax conflict has been discovered yet.
	CALLX	U$ITRE		;Initialize parse tree.
	CLR	NETPOS
	CLR	NET		;Network-ness is NO by default.
	CALBX	CUITHR <#CMDTBL>;Invoke the threaded command table.
	RETURN

.DSABL	LSB
GLOBAL	<CMDTBL,CMDBUF,CMDLEN,CMNADR>

.SBTTL	$PARKEY--Parse a keyword
;+
; $PARKEY -- Parse a keyword
;
; Format:
;	$PARKEY	[PROMPT=prompt][,LABEL=GLOBAL]				;051
;	$ONKEY	tag,label[,LOCAL]					;051
;	$ONKEY	tag,label
;	...
;	$ENDKEY	[FAIL=label]
;
; Description:
;	$PARKEY is a threaded instruction for use within a $THR block.
;
;	PROMPT=prompt specifies an ASCIC prompt string to print if
;	the parser is at the end of the command line at the point
;	when $PARKEY is invoked.
;
;	LABEL=GLOBAL specifies that the ONKEY labels are local to the 	;051
;	module.  If anything besides GLOBAL is specified, or the 	;051
;	argument is omitted, it is assumed the label is LOCAL.  The 	;051
;	labels specified on the ONKEY lines are globalized intil the 	;051
;	next PARKEY macro is issued.					;051
;
;	The $ONKEY statement specifies a keyword code and the label
;	of a threaded instruction to which control passes if the keyword
;	matches.  If U.TGNO is ORed into the keyword tag, then the NO
;	prefix is legal with the keyword.
;
;	LOCAL may be specified as the third argument of the ONKEY 	;051
;	statement to override the LABEL=GLOBAL argument specified in 	;051
;	the PARKEY macro.						;051
;
;	The $ENDKEY statement terminates the list of $ONKEY statements.
;	The FAIL= construct is optional, and specifies the label
;	of a threaded instruction to which control passes if none
;	of the keywords match.  If you do not specify FAIL=, and none
;	of the keywords match what the user typed, CUI displays
;	the "?Invalid keyword" or "?Keyword needed"
;
;	The FAIL= construct does NOT trap ?Abbreviation too short.
;-

.MACRO	$PARKEY	PROMPT=0,LABEL=LOCAL					;051
	 .WORD	U$PARKEY,PROMPT
	.GLOBL	U$PARKEY
	$$$GBL	= 0							;051
	.IF 	IDN LABEL GLOBAL 					;051
	$$$GBL = 1							;051
	.ENDC								;051
	.ENDM	$PARKEY

.MACRO	$ONKEY	TAG,LABEL,LOCAL						;051
	 .WORD	TAG,LABEL
	.GLOBL	TAG
	.IF	B LOCAL							;051
	.IIF 	EQ $$$GBL-1 	.GLOBL LABEL				;051
	.ENDC								;051
	.ENDM	$ONKEY

.MACRO	$ENDKEY	FAIL=0
	 .WORD	0,FAIL
	.ENDM	$ENDKEY

.ENABL	LSB

U$PARKEY::CALLX	LX.BLA		;Parse optional gap before setting up	;051
	CALLX	LX.SUP		;Get set up.
	CLR	NXTKEY		;No next keyword yet
	CLR	SLAPOS		;No slash position yet
	MOV	(R3)+,R2	;Is there prompt text?
	IFNZ			;If so then
	CALL	EOS		;  Are we at end-of-string?
	IFCC			;  If so then
	CALBX	U$RDMOR <R2>	;    Prompt for and read keyword.
	BCS	20$		;    Error occurred. Quit.
	ENDIF			;  Endif
	ENDIF			;Endif
	CALLX	LX.BLA		;Skip optional gap.			;051
10$:	CALB	MATKEY <(R3)+>	;Try to match this keyword.
	IFCC			;If found match then
	MOV	(R3),R3		;  Transfer control to the label
	BR	20$		;  Go to the label
	ENDIF			;Endif

; Match was not found for this keyword

	CMP	R0,#U.SHOR	;Was error ?Ambiguous keyword ?
	IFEQ			;If so then
	MOV	NXTKEY,LX.ERP	;  It happened in last keyword found
	BR	20$		;  Quit
	ENDIF			;Endif

	TST	(R3)+		;This was not the keyword, bump past label
	CMP	R0,#U.KYND	;Was error ?Keyword required ?
	BEQ	12$		;Yes.  Quit
	TST	(R3)		;No.  Another keyword to try?
	BNZ	10$		;Yes. Go try it.

; No match was found in list of keywords

	CMP	R0,#U.IKEY	;Was final error ?Invalid keyword?
	IFEQ			;If so then
	MOV	SLAPOS,LX.ERP	;  Assume we didn't find a slash in user's 
				;  input even though we expected it
	BNE	15$		;  We were right; return ?Invalid Keyword
	MOV	NXTKEY,LX.ERP	;  Assume there were more than on keyword
				;  (i.e. "ON ERROR THEN").  And we made it 
				;  past the first keyword but got caught after
				;  that
	BNE	15$		;  We were right; return ?Invalid Keyword
	MOV	#U.ICMD,R0	;  Change error to ?Invalid command
	ENDIF			;Endif

12$:	TST	(R3)		;Are we at ENDKEY?
	BEQ	15$		;Yes.  Check for FAIL=
	CMP	(R3)+,(R3)+	;No.  Skip past this PARKEY
	BR	12$		; until we hit an ENDKEY

; We didn't match on any command, go to the FAIL= clause, if any.

15$:	MOV	R4,LX.POS	;Put scan position back (in case of LX.ERP 
				;not set up)
	MOV	2(R3),R2	;Do we have a FAIL=?
	IFNZ			;If so then
	MOV	R2,R3		;  Transfer control to label.
	CLR	R0		;  Flag no error.
	ENDIF			;Endif

20$:	CLR	NXTKEY		;Make sure this is clear for next MATKEY
	CLR	SLAPOS		; in CUILEX
	RETURN

.DSABL	LSB
GLOBAL	<U.SHOR,LX.POS,U.KYND,U.ICMD,U.IKEY>

.SBTTL	$DEFCMD--Define a command
;+
; $DEFCMD -- Define a command
;
; FORMAT:
;	$DEFCMD	[QUAL=qualtbl] 
;		[U.CMDC=cmdcod]
;
; ARGUMENTS:
;	qualtbl	=	address of qualifier table.  Omitted if the command
;			doesn't take any qualifiers.
;	cmdcod	=	numeric command code to be put into CUI common
;
; DESCRIPTION:
;	Invoke $DEFCMD after command name has been parsed,
;	but before qualifiers and parameters have been parsed.
;	$DEFCMD can establish the command code for this command,
;	by which the CUSP identifies the command.
;	$DEFCMD also parses the qualifiers that come right after
;	the command name.
;-

.SBTTL	U$DEFCMD threaded service routine
;+
; U$DEFCMD threaded service routine
;
; U$DEFCMD is called from within a $THR block.
;
; INPUTS:
;	CONFPOS	=	0
;	//Other things initialized too?//
;
; BINARY:
; 	.WORD	U$DEFCMD,qualtbl,commandcode
;
; OUTPUTS:
; R0 = 0 if success.
;	CMDQUAL ->	command qualifier table
; R0 = status if error.
;-

.MACRO	$DEFCMD	QUAL=0,U.CMDC=0
	 .WORD	U$DEFCMD,U.CMDC,QUAL
	.GLOBL	U$DEFCMD
$$$QUAL	=	QUAL
	.ENDM	$DEFCMD

.ENABL	LSB

U$DEFCMD::MOV	(R3)+,U.CMDC(R4);Set command code.
	MOV	(R3),CMDQUAL	;Save address of qualifier table.
	CALB	PARQUAL <(R3)+,#NO>;Parse qualifiers.
	RETURN

.DSABL	LSB

.SBTTL	$ENDCMD -- End a command parse
;+
; $ENDCMD -- End a command parse
;
; FORMAT:
;	$ENDCMD
;
; DESCRIPTION:
;	Invoke $ENDCMD after all command parameters and qualifiers
;	have been parsed, and after issuing DFLTCQ statements.
;
;	$ENDCMD verifies that there are no extraneous characters
;	beyond the end of the command.  If there are any, $ENDCMD
;	returns an error.
;
;	$ENDCMD also enforces the REQUIRE= argument of DEFQUAL.
;	$ENDCMD makes sure that any qualifiers required by a REQUIRE=
;	construct either (1) were present on the command line,
;	without /NO prefix, 
;	or (2) were made the default by a DFLTCQ statement.  Otherwise,
;	$ENDCMD prints an error message.
;
; SIDE EFFECTS:
;	CUI common random.
;-

.SBTTL	U$ENDCMD threaded service routine
;+
; U$ENDCMD threaded service routine
;
; INPUTS:
;	R4	->	CUI common
;	R0	=	0
;
; BINARY:
; 	.WORD	U$ENDCMD
;
; OUTPUTS:
;	//etc//
;-

.MACRO	$ENDCMD
	 .WORD	U$ENDCMD
	.GLOBL	U$ENDCMD
	.ENDM	$ENDCMD

.ENABL	LSB

U$ENDCMD::

; Make sure we're at end-of-string.

	CALLX	LX.BLA		;Parse all spaces and tabs.		;051
	CALLX	LX.EOS		;Are we at end-of-string?		;051
	IFCS			;If not then
	CALBX	LX.EXAC	<#5$>	;  Are we starting at a comment?
	 TMPORG U$TEXT
5$:	  .ASCIZ "!"
	 UNORG
	BCC	10$		;  Yes, that's okay
	DEC	LX.POS		;  Back up scan position.
	CALLX	LX.BLA		;  Was there a blank before this 	;051
				;   unexpected character?		;051
	MOV	#U.TOOP,R0	;  Guess that there was a blank, and say
				;  ?Too many parameters. (Carry unaffected.)
	IFCS			;  If there was no blank then
	MOV	#U.UCHR,R0	;    Say ?Unexpected character.
	INC	LX.POS		;    Put scan position back.
	ENDIF			;  Endif
	MOV	LX.POS,LX.ERP	;  Current position is position of error.
	BR	70$		;  Return.
	ENDIF			;Endif
	.BR	10$		;This program will continue after this page 
				;break from our sponsor ...
GLOBAL	<U.TOOP,U.UCHR>

; Make sure that all required qualifiers are present.

10$:	MOV	CMDQUAL,R2	;Point at table of command qualifiers.
	BEQ	60$		;No table, no problem			;054
20$:	TST	(R2)		;Have we reached ENDQUAL yet?
	IFNZ			;If not then
	CALBX	FET.CQ <(R2)>	;Try to fetch this qualifier.		;054
.ASSUME	Q.TAG	EQ 0							;054
	IFCC			;  If present in the tree then
	MOV	U.POS(R4),R1	;    Save position of qualifier.
	MOV	Q.REQ(R2),R5	;    Point at list of required tags to 
				;    check for.
	IFNZ			;    If this qualifier has a REQUIRE= then

; Now R5 -> list of required qualifiers.
; Make sure that at least ONE of them is present, without "NO" prefix.

50$:	CALBX	FET.CQ <(R5)+>	;      Is this qualifier present?
	BCS	55$		;      No. Go look at next candidate.
	TST	U.NO(R4)	;      Yes, but does it have "NO" prefix?
	BZE	57$		;      No.  We're happy.  Continue with
				;      next cmd qualifier on command line.
55$:	TST	(R5)		;      Qualifier is not there, or has
				;      "NO" prefix. Have we run out 
				;      of candidates?
	BNZ	50$		;      No. Go try next candidate.
				;      Yes. Deep sneakers.
	MOV	#U.ADDQ,R0	;      Say ?Additional qualifier required.
	MOV	R1,LX.ERP	;      Position of invalid qualifier is 
				;      position of error.
	BR	70$		;      Return.
	ENDIF			;    Else this qualifier has no REQUIRE=.
	ENDIF			;  Else this qualifier isn't present.
57$:	CALL	BUMPDQ		;  Bump R2 past DEFQUAL.
	BR	20$		;  Go check next DEFQUAL.
	ENDIF			;Else we've checked all DEFQUALs in qualifier
				;table.
60$:	CLR	R0		;Flag no error.
70$:	RETURN
			
.DSABL	LSB
GLOBAL	<U.ADDQ>

.SBTTL	$PARM -- Parse a parameter
;+
; $PARM -- Parse a parameter
;
; FORMAT:
;	$PARM parmname
;		[,TYPE=type]
;		[,FLAGS=flags]
;		[,QUAL=qual]
;		[,PROMPT=prompt]
;		[,OCCURS=n]	
;		[,MAXVAL=n]
;		[,MAXVAL=n]
;	type	name of syntax type. If none specified, 
;		then any string of the proper general format
;		is accepted.
;	flag	OR of any of the following: 
;		PF.OPT -- the parameter is optional 
;		PF.LIS -- a list of parameters separated by commas
;			or plus signs is accepted.
;		PF.COL -- the separator to the LEFT of this parameter
;			is a colon or equal sign, rather than the usual
;			space.  This is useful for things like
;			SET PROTECTION:40.
;	qual	label of qualifier table.  Omitted if the parameter
;		doesn't take any qualifiers.
;-

.MACRO	$PARM	PARMNAME,TYPE=U$ANY,FLAGS=0,QUAL,PROMPT=0,OCCURS=1,CONF,MINVAL,MAXVAL
	 .WORD	U$PARM,PARMNAME,TYPE
	.GLOBL	U$PARM,TYPE
$$$INT = 0
	.IIF	IDN <TYPE>,<U$INT> $$$INT = 1
	.IIF	IDN <TYPE>,<U$PO2> $$$INT = 1
	.IIF	IDN <TYPE>,<U$S8> $$$INT = 1
	.IIF	IDN <TYPE>,<U$S16> $$$INT = 1
	.IIF	IDN <TYPE>,<U$S32> $$$INT = 1
	.IIF	IDN <TYPE>,<U$U8> $$$INT = 1
	.IIF	IDN <TYPE>,<U$U16> $$$INT = 1
	.IIF	IDN <TYPE>,<U$U32> $$$INT = 1
	.IF	NE $$$INT
	 .WORD	FLAGS!PF.INT,OCCURS
	.IFF
	 .WORD	FLAGS,OCCURS
	.ENDC
	.IF	NB	QUAL
	 .WORD	QUAL,PROMPT
	.IFF
	 .WORD	$$$QUAL,PROMPT
	.ENDC
	.IIF	DIF <PROMPT>,<0>	.GLOBL	PROMPT
$$$CONF	=	0
	.IF	NB <CONF>
	.SAVE
	 .PSECT	U$TBL,RO,REL,LCL,CON
$$$CONF	=	.
	 .WORD	CONF,0
	.RESTORE
	.ENDC
	 .WORD	$$$CONF
	.IF	NE $$$INT
	.SAVE
	.PSECT	U$TEXT
$$$MIN	= .	
	 .ASCIC	"MINVAL"
$$$MAX	= .	
	 .ASCIC	"MAXVAL"
	.RESTORE
	 .WORD	$$$MIN,$$$MAX
	.ENDC
	.ENDM	$PARM

; The $PARM macro expands into a call to U$PARM with the following arguments:
; 	P.TAG	->	tag that identifies this parameter or parameter list
;	P.PAT	->	pattern for this parameter
;	P.FLG	=	flag word.  This consists of the following bits.
;		PF.OPT--the parameter is optional.  If it is omitted, 
;			there must not be any following parameters on the 
;			command line either.
;		PF.COL--the separator that goes between this parameter
;			and the stuff to the left of it can be a colon
;			or equal sign rather than a blank.
;	P.OCCURS =	number of occurrences of parameter that are allowed.
;	P.QUAL	->	table of qualifiers accepted with this parameter.
;	P.PROMPT ->	prompt string to use if end-of-string is found
;			when we look for this parameter.
;	P.CONF	->	Conflict table.  Table of qualifiers which conflict 
;			with this paramter
;	P.MIN	->	Optional ASCIC string (minimum value for this integer)
;	P.MAX	->	Optional ASCIC string (maximum value for this integer)
;

	.DSECT
P.TAG:	.BLKW
P.PAT:	.BLKW
P.FLG:	.BLKW
P.OCCURS:.BLKW
P.QUAL:	.BLKW
P.PROMPT:.BLKW
P.CONF:	.BLKW
P.MINV:	.BLKW								;051
P.MAXV:	.BLKW								;051
P.SIZ:
	UNORG

.SBTTL	U$PARM threaded service routine
;+
; U$PARM threaded service routine
;
; INPUTS:
;	R4	->	CUI common
; INTERNAL VARIABLES:
;	R2	=	parameter count
;	(SP)	=	Flag: 	 0 if a parameter qualifier is allowed here
;				-1 otherwise
;-

.ENABL	LSB

U$PARM::MOV	#-1,-(SP)	;Initialize a flag on top of stack
	CLR	R2		;Initialize parameter count
10$:	CALL	EOS		;Are we at end of string?
	IFCC			;If so then
	BIT	#PF.OPT,P.FLG(R3); Is parameter optional?
	BNZ	30$		;  Yes. Return without action.
	CALL	40$		;  Are there any conflicting qualifiers present?
	BCS	30$		;  Yes, Return without action
	TST	P.PROMPT(R3)	;  No.  Is a prompt string available?
	IFNZ			;  If so then
	CALBX	U$RDMOR <P.PROMPT(R3)>
				;    Prompt for and read parameter.
	BCS	30$		;    An error occurred. Quit.
	ENDIF			;  Endif
	ENDIF			;Endif

	TST	(SP)		;Did we just see a comma or plus sign?
	IFNE			;If so then
	CALB	PARQUAL <CMDQUAL,#NO>
				;  Allow command qualifiers here
	ELSE			;Else
	CALB	PARQUAL <P.QUAL(R3),#YES>
				;  Allow command or paramter qualifiers
	ENDIF			;Endif
	BCS	30$		;An error occurred, quit.
	CALL	EOS		;Are we still at end of string?
	BCC	10$		;Reprompt if we are at end of string

; We're not at end-of-string.

	TST	R2		;Have we seen a parameter yet?
	IFEQ			;If this is our first time through then
	CALB	SCANSEP		;  Look for separator.
	BCS	30$		;  Not there.  Quit.
	MOV	LX.POS,LX.ERP	;  Assume this will error, point to parameter
	CRE.NODE TREE=PARMTREE,TAG=P.TAG(R3),TXTPOS=LX.POS,LEVEL=#PL.LVL
				;  Add a branch for this parameter.
				;  Now R1 -> newly created node.
	BCS	30$		;  Error occurred.  Quit.
	ENDIF			;Endif

	INC	R2		;We are looking for a paramter now
	CALL	DOPARM		;Look for one occurrence of parameter.
	TST	R0		;Did we find it?
	BNZ	30$		;No. Quit.
	CALL	40$		;Any conflicts present on the command line now?
	IFCS			;If so then
	MOV	U.POS(R4),CONFPOS; Point to qualifier (LX.ERP points to parm)
	MOV	#U.CNFE,R0	;  ?Conflicting elements
	BR	30$		;  Quit
	ENDIF			;Endif

	CALLX	LX.BLA		;Look for an optional gap.		;051
	BIT	#PF.NLS,P.FLG(R3);Should we look for a parameter list separator?
	IFEQ			;If so then
	CLR	(SP)		;  Assume we will not find a comma or plus sign
	CALBX	LX.MEM <#20$>	;  Look for a comma or plus sign.
	 TMPORG	U$TEXT
20$:	  .ASCIZ "+,"
	 UNORG
	IFCC			;  If we found comma or plus sign then
	COM	(SP)		;    We found one	
	CMP	R2,P.OCCURS(R3)	;    Are more occurrences allowed?
	BLO	10$		;    Yes, go parse more
	MOV	#U.MANY,R0	;    No, say ?Too many items in list
	MOV	LX.POS,LX.ERP	;    Position of extra filespec is error pos
	BR	30$		;    Report the error
	ENDIF			;  Endif
	ENDIF			;Endif
	CLR	R0		;Flag no error

; Clean up stack and point R3 at next threaded statement

30$:	BIT	#PF.INT,P.FLG(R3);Is this one of those integer type parameters?
	IFEQ			;If not then
	SUB	#4,R3		;  Adjust for the MIN and MAX words
	ENDIF			;Endif
	ADD	#P.SIZ,R3	;Bump R3 past inline arguments.
	POP			;Give back stack space
	RETURN

;+
; Check for presence of conflicting qualifier.  
;
; R3 --> $PARM line
;
; OUTPUTS:
; 	C=0 if no conflict found
; 	C=1 if conflict found, and U.CMN+U.POS points to the qualifier
;-

40$:	PUSH	<R2>		;Save register
	MOV	P.CONF(R3),R2	;Check for conflicting qualifier
	IFNZ			;If there are conflicts then
45$:	TST	(R2)		;  Run off end of conflict list?
	BEQ	50$		;  Yes, return success - no conflict found
	CALBX	FET.CQ <(R2)+>	;  Is this conflicting qualifier present?
	BCS	45$		;  No. Check for others
	SEC			;  Yes, return failure - conflict found	
	ENDIF			;Endif
50$:	POP	<R2>		;Restore register (Don't effect C-bit)
	RETURN			;Return with C-bit indicating status

.DSABL	LSB
GLOBAL	<LX.POS,LX.ERP,PARMTREE,U.MANY,U.CNFE>

.SBTTL	DOPARM--Parse one occurrence of parameter
;+
; DOPARM--Parse one occurrence of parameter
;-

.ENABL	LSB

DOPARM:	CALLX	LX.BLA		;Look for optional gap.			;051
	CRE.NODE TREE=PARMTREE,TXTPOS=LX.POS,LEVEL=#P.LVL
				;Create a node to represent the parameter.
	BCS	10$		;Error occurred. Quit.
				;Now R1 -> newly created node.
	
	BIT	#PF.INT,P.FLG(R3);Is this one of those integer type parameters?
	IFNZ			;If so then
	MOV	P.MINV(R3),MINADR
	MOV	P.MAXV(R3),MAXADR
	ENDIF			;Store min and max before going off to pattern
	CALB	@P.PAT(R3)	;Parse the parameter.
	BCS	10$		;Error. Quit.
	TST	N.TXTLEN(R1)	;Has a text length been supplied?
	IFZE			;If not then
	MOV	LX.POS,N.TXTLEN(R1);Set length equal to amount of text matched.
	SUB	N.TXTPOS(R1),N.TXTLEN(R1)
	ENDIF
	CMP	N.TXTLEN(R1),#U.MAXL
				;Does string exceed length of CUI common 
				;buffer?
	IFGT			;If so then
	MOV	#U.PLNG,R0	;  Say it's too long.
	MOV	N.TXTPOS(R1),LX.ERP
				;  Flag position of error.
	RETURN
	ENDIF
	CALB	PARQUAL <P.QUAL(R3),#YES>
				;Parse qualifiers.
	;BCS	10$		;An error occurred. Quit.
10$:	RETURN

.DSABL	LSB
GLOBAL	<PARMTREE,U.PLNG,LX.ERP,MINADR,MAXADR>

.SBTTL	DEFQUAL--Define a qualifier in a table
;+
; DEFQUAL--Define a qualifier in a table
;
; USAGE:
;	DEFQUAL	tag
;		[,FLAGS=flags]
;		[,ARG=REQUIRED]
;		[,ARG=OPTIONAL]
;		[,CONF=<tag,...>]
;		[,REQUIRE=<tag,...>]
;		[,CLASS=<tag>]
;
; ARGUMENTS:
;	tag--Keyword tag.  By looking this code up in KEYTBL
;		one can find the target string.  For the format of 
;		the target string itself, refer to LX.KEY in CUILEX.MAC.
;	FLAGS=flags--flag word containing the following Boolean (bit) flags.
;		QF.NEG--the form /NOqual is accepted.
;		QF.PARM--this is a parameter qualifier rather than a command
;			qualifier.
;		QF.ALIS--this qualifier accepts a list of arguments, in 
;			addition to accepting a single argument.  
;			The arguments are separated by commas and 
;			the list is surrounded by parentheses: 
;			e.g. /qual=(arg,...).  An argument table must follow
;			the DEFQUAL statement, and ARG=REQUIRED or
;			ARG=OPTIONAL must also be specified.
;		QF.LOCL--this qualifier implies a local (non-network) 
;			operation.
;	ARG=REQ--indicates that the qualifier requires an argument
;		(/qual=arg).  An argument table must follow the 
;		DEFQUAL statement.
;	ARG=OPT--indicates that the qualifier accepts an optional
;		argument (/qual[=arg]).  Do not use ARG=OPTIONAL with
;		ARG=REQUIRED.  An argument table must follow the DEFQUAL
;		statement.
;	CLASS=class--tag of class to which this qualifier belongs.
;		This "class" tag may be referenced in a "conf=" list.
;	CONF=conf--Tags of one or more command qualifiers, command parameters,
;		or classes that conflict with this qualifier
;	REQUIRE=require--one or more command qualifier tags.  At least
;		one of the listed qualifiers has to be on the command
;		line, or to be present by default.  For example,
;		in the EDIT command the /VTEDIT qualifier requires /TECO;
;		in the DIRECTORY command the /CREATED qualifier
;		requires either /BEFORE or /SINCE or both.
;
; A qualifier table consists of one or more DEFQUAL statements, followed
; by an ENDQUAL statement.  Also, an argument table can appear after
; a DEFQUAL, before the next DEFQUAL or ENDQUAL.
;-

.MACRO	DEFQUAL	TAG,FLAGS=0,CLASS=0,CONF,REQUIRE,ARG
	.SAVE								;035
	.DSABL	CRF
	.GLOBL	TAG
$$$FLG	=	FLAGS
	.IIF	IDN <ARG>,<REQ>	$$$FLG = $$$FLG ! QF.AREQ
	.IIF	IDN <ARG>,<OPT>	$$$FLG = $$$FLG ! QF.AOPT
$$$CONF	=	0
	.IF	NB <CONF>
	 .PSECT	U$TBL,RO,REL,LCL,CON
$$$CONF	=	.
	 .WORD	CONF,0
	.ENDC
$$$REQ	=	0
	.IF	NB <REQUIRE>
	 .PSECT	U$TBL,RO,REL,LCL,CON
$$$REQ	=	.
	 .WORD	REQUIRE,0
	.ENDC
	.RESTORE							;035
	 .WORD	TAG,$$$FLG,CLASS,$$$CONF,$$$REQ
	.ENDM	DEFQUAL

.SBTTL	ENDQUAL--End a qualifier table
;+
; ENDQUAL--end a qualifier table
;-

.MACRO	ENDQUAL
	 .WORD	0
	.ENDM	ENDQUAL

.SBTTL	Binary of a Qualifier Table
;+
; Binary of a qualifier table
; DEFQUAL has the following expansion.
;	Q.TAG--Keyword tag.  A zero value here terminates the table.
;	Q.FLAGS--Flag byte containing the following Boolean (bit) flags.
;		QF.NEG--the form /NOqual is accepted.
;		QF.AOPT--this qualifier accepts an optional argument.
;		QF.AREQ--Qualifier requires an argument.
;		QF.ALIS--a list of arguments of the form (arg,...) 
;			is accepted. 
;		QF.PARM--this is a parameter qualifier rather than a command
;			qualifier.
;	Q.CLASS (optional)--code of class to which this qualifier belongs.
;	Q.CONF (optional)--address of a null-terminated word list of
;		command qualifiers, parameters, or classes that conflict
;		with this qualifier.
;	Q.REQ (optional)--address of a null-terminated word list of
;		command qualifier tags.
;		At least ONE of these qualifiers must be present.
; ENDQUAL expands to a 0 terminator.
;-


; ***********************************************************************
; *** Q.TAG and Q.FLAGS must match Q.KEY and Q.FLAGS due to recursion ***
; ***********************************************************************

	.DSECT
Q.TAG:	.BLKW
Q.FLAGS:.BLKW
Q.CLASS:.BLKW
Q.CONF:	.BLKW
Q.REQ:	.BLKW
Q.LEN:				;= length of a DEFQUAL
	UNORG

.SBTTL	PARQUAL--Parse list of qualifiers
;+
; PARQUAL -- Parse list of qualifiers
;
;	A qualifier has the following syntax.
;
;		/NOqual | /qual [=arg]
;
; INPUTS:
;	QUALTBL	-> 	a qualifier table.  See "Structure of a 
;		Qualifier Table".  =0 if no qualifier table.
;	.PARMQ	=	-1 if these qualifiers follow a parameter,
;			0 if these qualifiers follow command name.
;	NETPOS	=	
;	NET	=
;	R4	->	CUI common
;
; CALB	PARQUAL <QUALTBL,.PARMQ>
;
; OUTPUT:
;	R0	=	return status
;	C=1	iff	error
;
; EFFECT:
;	For each qualifier, a node representing it is added to one of the parse
;	trees.  A command qualifier is added to QUALTREE.  A parameter 
;	qualifier is added to PARMTREE if .PARMQ is YES, and to QUALTREE 
;	otherwise.  
;
;	Qualifier arguments are parsed according to the DEFQUAL statement.
;	If an argument type is specified, the syntax type routine
;	is called with R1 pointing at the node that will represent
;	the argument.  The syntax type routine can put a text position
;	and length into the node.  If it does not, then by default
;	the entire string matched by the syntax type routine is considered
;	to be the argument.
;-

; INTERNAL VARIABLES:
; R1	->	node representing qualifier
; R3	=	Q.FLAGS word
; (SP)	=	Did we find /NO prefix?  (-1 if so, 0 otherwise.)
; R2	->	entry that we're now processing

.ENABL	LSB

PARQUAL::SUBR	<QUALTBL,.PARMQ>
	TST	QUALTBL(R5)	;Is there a qualifier table?
	IFZE			;If not then
	CALLX	LX.BLA		;  Look for optional blank.		;051
	CALBX	LX.EXAC <#12$>	;  Look for a slash.
	IFCC			;  If we found one then
	MOV	#U.NOQL,R0	;    Say ?No qualfiers permitted
	MOV	LX.PMAT,LX.ERP	;    Position of slash is position of error.
	ELSE			;  Else
	CLR	R0		;    There was no error.
	ENDIF			;  Endif
	RETURN			;  Return without parsing qualifiers.
	ELSE			;Else
	TST	@QUALTBL(R5)	;  Is the qualifier table empty?
	IFZE			;  If so then
	RETURN			;    Return without parsing qualifiers.	
	ENDIF			;  Endif
	ENDIF			;Endif
	CLR	-(SP)		;Make a cell on top of the stack and clear it.
10$:	CLR	(SP)		;We are looking for the positive form first.
	CALLX	LX.BLA		;Look for optional blank.		;051
	CALBX	LX.EXAC <#12$>	;Look for a slash.
	 TMPORG	U$TEXT
12$:	  .ASCIZ "/"
	 UNORG
	IFCS			;If we didn't find it then
	CLR	R0		;  Flag no error.
	JMP	60$		;  Return.
	ENDIF			;Endif
	CALLX	LX.BLA		;Look for another optional blank.	;051
15$:	MOV	QUALTBL(R5),R2	;Point at first table entry.
20$:	CALB	MATKEY <(R2)>	;Look for qualifier keyword.		;054
.ASSUME	Q.TAG	EQ 0							;054
	BCC	35$		;We found it.  Continue.
	CMP	R0,#U.IKEY	;Was the error ?Invalid keyword?
	BNE	33$		;No, something else.  Quit.
	CALL	BUMPDQ		;Bump R2 past DEFQUAL.
	TST	(R2)		;Are there any more entries?
	BNE	20$		;Yes.  Keep testing.
	TST	(SP)		;Have we tried the /NO version yet?
	BNE	30$		;Yes.  Then we failed.
	CALB	LX.EXAC	<#NO.KEY>;Is it /NO?
	BCS	30$		;No.  Then we fail.
	COM	(SP)		;Indicate that we are now going to try /NO.
	BR	15$		;Try all entries with /NO.

30$:	TST	(SP)		;Was it /NO?
	IFNZ			;If so then
	SUB	#2.,LX.POS	;  Position of qualifier was the /NO.
	ENDIF			;Endif
	MOV	#U.IQ,R0	;We fell off end of table. ?Invalid qualifier
	MOV	LX.POS,LX.ERP	;Position of qualifier is position of error.
33$:	BR	60$		;Quit.

; We matched qualifier keyword against entry in qualifier table.

35$:	MOV	Q.FLAGS(R2),R3	;Get qualifier flags word.
	CALB	CHKCNF		;Check for conflicts.
	BCS	60$		;Error occurred. Quit.
	TST	Q.CLASS(R2)	;Is there a class tag for this qualifier?
	IFNZ			;If so then
	CALBX	FET.CQ	<Q.CLASS(R2)>
				;  Has a qualifier from that class already
				;  been encountered?
	IFCS			;  If not then
	CRE.NODE TREE=QUALTREE,TAG=Q.CLASS(R2),TXTPOS=LX.PMAT,LEVEL=#CQ.LVL
				;    Create a node for the class.
				;    Position of the node is position
				;    of qualifier we just matched.
	BCS	60$		;    Error occurred. Quit.
				;    Now R1 -> newly created node.
				;    
	BIS	#NF.AFFIRM,N.FLAG(R1);Set affirmative flag.
	ENDIF
	ENDIF

; Store the qualifier into CUITRE.

	TST	.PARMQ(R5)	;Does the qualifier follow a parameter?
	BZE	40$		;No.  Go store it into QUALTREE.
	BIT	#QF.PARM,R3	;Yes. Is it a parameter qualifier or
				;a command qualifier?
	BZE	40$		;Command qualifier. Go store it into 
				;QUALTREE.
	CRE.NODE TREE=PARMTREE,TAG=Q.TAG(R2),TXTPOS=LX.PMAT,LEVEL=#PQ.LVL
				;Parameter qualifier. Store it into PARMTREE.
	BR	50$

40$:	CRE.NODE TREE=QUALTREE,TAG=Q.TAG(R2),TXTPOS=LX.PMAT,LEVEL=#CQ.LVL
				;Create a node in QUALTREE for the qualifier.
50$:	BCS	60$		;Error occurred. Quit.
				;Now R1 -> newly created node
	TST	(SP)		;Is qualifer prefixed by /NO?
	IFNZ			;If so then
	SUB	#2.,LX.PMAT	;  Location of qualifier is the "N" in "NO"
	ENDIF			;Endif
	MOV	LX.PMAT,N.TXTPOS(R1)
				;Set position of qualifier into node.
	TST	(SP)		;Was qualifier prefixed with /NO?
	IFNZ			;If so then
	BIT	R3,#QF.NEG	;  Does qualifier take /NO prefix?
	IFZE			;  If not then
	MOV	#U.NPFX,R0	;    Say ?NO prefix not allowed.
	MOV	LX.PMAT,LX.ERP	;    Position of qualifier is position
				;    of error.
	BR	60$		;    Quit.
	ELSE			;  Else qualifer takes /NO prefix
	BIT	R3,#QF.NARG	;    Does the NO form accept arguments?
	BNE	52$		;    Yes.  Look for arguments.	
	ENDIF			;  Endif
	;BIC	#NF.AFFIRM,N.FLAG(R1);Clear affirmative flag.
	ELSE			;Else it wasn't prefixed with /NO.
	BIS	#NF.AFFIRM,N.FLAG(R1)
				;  Set affirmative flag.
52$:	MOV	#CQ.LVL,TMP.LVL	;  Guess that we have a command qualifier.
	TST	.PARMQ(R5)	;  Does the qualifier follow a parameter?
	BZE	55$		;  No.  Parse qualifiers under QUALTREE.
	BIT	#QF.PARM,R3	;  Yes.  Are they command qualifiers?
	BZE	55$		;    Yes.  Parse qualifiers under QUALTREE.
	MOV	#PQ.LVL,TMP.LVL	;    No. It was a parameter qualifier.	
55$:	CALB	PARARG <#Q.LEN,Q.FLAGS(R2),TMP.LVL>
				;  Parse the argument.
	BCS	60$		;  That failed. Quit.
	ENDIF
	JMP	10$		;Go look for more qualifiers.

60$:	POP			;Discard scratch location on stack.
	RETURN

.DSABL	LSB
GLOBAL	<KEYTBL,NO.KEY,U.NPFX,U.IQ,U.IKEY,PARMTREE,QUALTREE,U.NOQL>

.SBTTL	$DISALLOW -- Disallow command qualifiers.
;+
; $DISALLOW - Disallow command qualifiers.
;
; FORMAT:
;	$DISALLOW <tag,tag,...>,errmsg
;
; ARGUMENTS:
;	tag    -- The tag of the qualifier to be checked for existence 
;                 in the tree.
;	errmsg -- The error message to be printed in the event one of the
;                 qualifiers is present in the tree.
;
; DESCRIPTION:
;	$DISALLOW does fetches of qualifiers in the given list.  If one of 
;	the qualifiers is in the tree, then the offending qualifier is pointed
;	to and the error message is printed out.
;
; OUTPUT:
;	R0  =    0     if no qualifier from the list is found
;	R0  =  errmsg  if any of the qualifiers in the list is found.
;
; CAUTION:
;	INCLUDING A QUALIFIER IN THE LIST AFTER A DFLTCQ OF THAT QUALIFIER
;	CAUSES THE ERROR MESSAGE TO BE PRINTED REGARDLESS OF WHETHER OR NOT 
;	THE USER SPECIFIES IT.
;
; SIDE EFFECT:
;	CUI common is wiped out.
;
;-

.MACRO	$DISALLOW LIST,ERRMSG
	 .WORD	U$DISALLOW
	.GLOBL	U$DISALLOW
	.DSABL	CRF
	.IIF	B  <LIST>	.ERROR ;Argument required for $DISALLOW
	.IIF	B  <ERRMSG>	.ERROR ;Error message must be specified.
	.MCALL	.NELEM
	.NELEM	$$$NUM,<LIST>
	.ENABL	CRF
	 .WORD	$$$NUM,ERRMSG,LIST
	.ENDM	$DISALLOW

U$DISALLOW::MOV	(R3)+,R2	;R2 = Number of elements in list.
	MOV	(R3)+,R5	;R5 = Error message.
 10$:	CALBX	FET.CQ  <(R3)+> ;Fetch list items one at a time.
	BCC	30$		;If we find one then go report conflict.
	SOB	R2,10$		;Else check next item in list.
	CLR	R0		;Indicate success - no invalid qualifiers.
	RETURN			;No conflicts detected.

 20$:	TST	(R3)+		;Bump R3 past last item in list.
 30$:	SOB	R2,20$		;
	MOV	U.POS(R4),LX.ERP;Move current scan position into error position
	MOV	R5,R0		;Indicate failure.
	RETURN

GLOBAL	<LX.ERP>

.SBTTL	CHKCNF -- Check for conflicts.
;+
; CHKCNF -- Check for conflicts.
;
; CHKCNF checks for (a) network filespec present and this qualifier is for 
; local operations only, and (b) conflicting qualifier present.  
;
; If conflicting qualifier is present, then we make first element seen -1
; so that future fetches of it will fail.  
;
; INPUTS:
;	R2	->	DEFQUAL entry of qualifier table
;	LX.PMAT	=	position of qualifier
;	NETPOS	=	Position we first encountered network-ness. 
;			(If a qual had a QF.LOCL, NETPOS is the position of 
;			that qualifier, or if a NODE:: was found in a filespec,
;			NETPOS is the position of that filespec.)
;	NET	=	NO	if a LOCAL operation
;			YES	if a NETwork operation.
;	R4	->	CUI common
;
; CALB	CHKCNF
;
; OUTPUTS:
; C=0 if success.
;	R0	=	0
; C=1 if failure.
;	R0	=	status. (Only error is from network/local conflicts)
;	CONFPOS	=	position of lefthand element of conflict
;	LX.ERP	=	position of righthand element of conflict
;
; SIDE EFFECTS:
;	CUI common random.
;-

.ENABL	LSB

CHKCNF:	SUBR	,CHECK
					;Check for qualifier already specified
	BIT	Q.FLAGS(R2),#QF.MULT	;Can it be multiply specified?
	IFEQ				;If not then
	BIT	Q.FLAGS(R2),#QF.PARM	;  Is it a parameter qualifier?
	BEQ	20$			;  No
	CALBX	FET.PQ	<(R2)>		;  Already been specified?	;054
.ASSUME	Q.TAG	EQ 0							;054
	BCC	22$			;  Yes, wipe it out
20$:	CALB	FET.CQ	<(R2)>		;  Specified as a command qual?	;054
.ASSUME	Q.TAG	EQ 0							;054
	BCS	30$			;  No.  Check local/network
22$:	CALL	DELINK			;  Yes. Wipe out reference to it
	.BR	30$			;  Check local/network
	ENDIF				;Endif

					;Check for conflict between network 
30$:					;and local capabilities.
	BIT	Q.FLAGS(R2),#QF.LOCL	;Does qualifier imply local operation?
	IFNZ				;If so then
	CALL	SETNET,R5		;  Set NET=NO.
	 .WORD	NO			;  Return status is in R0.
	TST	R0			;  Error?
	BNZ	70$			;  Yes. Quit.
	ENDIF				;Endif

					;Check for conflicting qualifiers.
40$:	MOV	Q.CONF(R2),R1		;Get pointer to conflict list.	
	IFNZ				;If there are conflicts to check for 
50$:	TST	(R1)			;  Run off end of conflict list?
	IFNZ				;  If not then
	CALBX	FET.CQ <(R1)>		;    Is this conflicting qual present?
	BCS	60$			;    No.  Check for conflicting parm
	CALL	DELINK			;    Yes, Found it.  Wipe it out
	BR	40$			;    Keep checking (from beginning)

60$:	CALBX	FET.P <(R1)+>		;    Maybe it's a conflicting parm?
	BCS	50$			;    No. Go check next conflict in list
	MOV	U.POS(R4),CONFPOS	;    Point to parameter
	MOV	LX.PMAT,LX.ERP		;    Point to qualifier
	MOV	#U.CNFE,R0		;    ?Conflicting elements
	BR	70$			;    Quit with error
	ENDIF				;  Endif
	ENDIF				;Endif
	CLR	R0			;Set no error
70$:	RETURN				;Done
	
.DSABL	LSB
GLOBAL	<LX.PMAT,LX.ERP,CONFPOS,U.CNFE>

.SBTTL	DELINK - Delink the current node in the current tree

;+
; DELINK - Delink the current node in the current tree
;
; Input:
;	CRNTTREE -> points to the current tree
;	U.NODE   -> points to the current node
;
; Call:
;	CALL	DELINK
;
; Output:
;	R3, R4 are munged
;
; Side effects:
;	The node which U.NODE pointed to is no longer in the tree.
;
; // change U.NODE's name to something else. It looks like an error msg.
;-

.ENABL	LSB

DELINK:	MOV	CRNTTREE,R3		;Get current tree (pointer to qual list
					;... if QUALTREE, pointer to parm tag
					;... list if PARMTREE)
	MOV	U.NODE,R4		;Get pointer to qualfier node
					;... to be deleted
	CMP	R3,#PARMTREE		;Is this node in the parameter tree?
	IFEQ				;If so then find head of qual list for
					;... current parameter
	MOV	R4,R1			;  Copy pointer to qualifier node
	CALLX	U$PARENT		;  Get parent (ptr to parameter node)
					   .ASSUME N.LSON EQ 0
	MOV	R1,R3			;  Copy pointer to N.LSON (the ptr to
					;  ... the head of param qual list)
	ENDIF				;Endif
					;R3 points to pointer to first qual
	CMP	(R3),R4			;Is the first node in the list it?
	IFEQ				;If so then give it special treatment
	MOV	N.RBROTHER(R4),(R3)	;  Delink the first node.
	BIT	#1,(R3)			;  Was that the only node in the tree?
	BEQ	40$			;  No, return.
	CLR	(R3)			;  Yes.  Now there's no nodes in tree
	BR	40$			;  Return
	ENDIF				;Endif

10$:	MOV	(R3),R3			;Point to 1st node (not the only one)
	BR	30$			;Check this node

20$:	MOV	N.RBROTHER(R3),R3	;Point to next node
30$:	CMP	N.RBROTHER(R3),R4	;Is this node which points to us?

;% Note: If we don't find the node, we
;% will get an odd address trap here on
;% the last node in the list.

	BNE	20$			;No, try next
	MOV	N.RBROTHER(R4),N.RBROTHER(R3)
					;Yes! Delink our node.
40$:	RETURN

GLOBAL	<U$PARENT>

.DSABL	LSB

.SBTTL	DFLTCQ -- Establish a default for a command qualifier
;+
; DFLTCQ--Establish a default for a command qualifier.
;
; FORMAT:
;	DFLTCQ	tag [,NO]
;
; ARGUMENTS:
;	tag -- the tag of the qualifier to establish a default for
;	NO -- specifies that the qualifier is negated by default
;		(as if the user had typed the "NO" prefix).
;
; DESCRIPTION:
;	If the user did not specify any qualifiers that conflict
;	with this qualifier, then DFLTCQ creates a node in QUALTRE
;	to represent the qualifier.  
;
;	It is illegal (and hazardous)
;	to execute a $PARM statement after executing DFLTCQ statements.
;
; BINARY:
;	.WORD	DFLTCQ
;	.WORD	tag
;	.WORD	-1 | 0
;
; **********************************************************
; *			C A U T I O N:			   *
; *			-------------                      *
; *		    Feature patches to DCL 		   *
; *			  DEPEND ON			   *
; *		  DFLTCQ's binary expansion.		   *
; *		   If you change the format		   *
; *		   you must CHECK all of the		   *
; *		       feature patches.			   *
; *							   *
; **********************************************************
;
; OUTPUTS:
;	QUALTRE becomes the current tree.
;	R0	=	0
;	R3	->	next instruction
; 	Other registers random.
;-

.MACRO	DFLTCQ	TAG,AFFIRM=YES
	.IF	IDN <AFFIRM>,<YES>
	 .WORD	DFLTCQ,TAG,-1
	.IFF
	 .WORD	DFLTCQ,TAG,0
	.ENDC
	.GLOBL	DFLTCQ
	.ENDM	DFLTCQ

.ENABL	LSB

DFLTCQ::CALBX	FET.CQ <(R3)>	;Has this qualifier already been specified?
	BCC	60$		;Yes. Return without error.

; Find DEFQUAL that corresponds with this qualifier.

	MOV	CMDQUAL,R2	;Point at table of DEFQUALs.
10$:	.ASSERT	(R2) NE #0	;We can't fall off end of table.
	CMP	(R2),(R3)	;Is this the qualifier we're defaulting?;054
.ASSUME	Q.TAG	EQ 0							;054
	BEQ	20$		;Yes. Done searching.
	CALL	BUMPDQ		;No. Bump R2 past DEFQUAL.
	BR	10$		;Go try next DEFQUAL.

; We found the DEFQUAL. See if this qualifier conflicts
; with anything else that has been specified.

20$:	MOV	Q.CONF(R2),R1	;Point at list of conflicts to check for.
	IFNZ			;If there are any to check for then
30$:	TST	(R1)		;  Have we reached end of conflict list?
	BZE	40$		;  Yes, and no conflicts. Go check for
				;  required qualifiers.
				;  No, still checking conflicts.
	CALBX	FET.CQ <(R1)>	;  Is this conflicting qualifier present?
	BCC	60$		;  Yes. Return without action.
	CALBX	FET.P <(R1)+>	;  No. Maybe it's a conflicting parameter?
	BCC	60$		;  Yes. Return without action.
	BR	30$		;  No. Go check next conflict in list.
	ENDIF			;Else no conflict list.

; No conflicts. See if at least one of the "required" qualifiers is present.

40$:	MOV	Q.REQ(R2),R1	;Point at list of required qualifiers to check
				;for.
	IFNZ			;If there are any to check for then
45$:	TST	(R1)		;  Have we reached end of list?
	BZE	60$		;  Yes, and none of the "required" qualifiers
				;  is present.  Return without action.
	CALBX	FET.CQ	<(R1)+>	;  No. Is this one present?
	IFCC			;  If so then
	TST	U.NO(R4)	;    Does it have "NO" prefix?
	BZE	50$		;    No, so we're happy.  Go add it to tree.
	ENDIF			;    It has "NO" prefix, so pay no attention.
	CLR	R0		;  Set no error.
	BR	45$		;  Go check next candidate.
	ENDIF			;Else no required qualifiers to check for.

; Create node representing the qualifier.

50$:	CRE.NODE TREE=QUALTREE,TAG=(R3),LEVEL=#CQ.LVL,TXTPOS=#0
				;(Specify a dummy text position of 0.)
	BCS	60$		;That failed. Quit.
				;Now R1 -> newly created node.
	TST	2(R3)		;Is it an affirmative node?
	IFNZ			;If so then
	BIS	#NF.AFFIRM,N.FLAG(R1)
				;  Set affirmative flag.
	;ELSE			;Else
	;BIC	#NF.AFFIRM,N.FLAG(R1)
				;  Clear affirmative flag.
	ENDIF
	TST	Q.CLASS(R2)	;Is there a class tag for this qualifier?
	IFNZ			;If so then
	CALBX	FET.CQ	<Q.CLASS(R2)>
				;  Has a qualifier from that class already
				;  been encountered?
	IFCS			;  If not then
	CRE.NODE TREE=QUALTREE,TAG=Q.CLASS(R2),TXTPOS=#0,LEVEL=#CQ.LVL
				;    Create a node for the class.
	BCS	60$		;    Error occurred. Quit.
				;    Now R1 -> newly created node.
	BIS	#NF.AFFIRM,N.FLAG(R1);Set affirmative flag.
	ENDIF
	ENDIF
60$:	CMP	(R3)+,(R3)+	;Bump past the two inline arguments.
	RETURN

.DSABL	LSB
GLOBAL	<QUALTREE>

.SBTTL	DFLTKA -- Establish a default for a keyword argument
;+
; DFLTKA--Establish a default for a keyword argument
;
; FORMAT:
;	DFLTKA	qualtag, argtag [,NO]
;
; ARGUMENTS:
;	qualtag -- the tag of the qualifier to establish a default for
;	argtag -- the tag of the argument to establish as the default
;	NO -- specifies that the argument is negated by default
;		(as if the user had typed the "NO" prefix).
;
; DESCRIPTION:
;	DFLTKA has no effect unless the qualifier is present,
;	either explicitly or by default (via DFLTCQ).
;	DFLTKA also has no effect if the qualifier is prefixed with "NO",
;	or if the user specified the qualifier and specified a keyword
;	argument that conflicts with this one.
;
; BINARY:
;	.WORD	DFLTKA
;	.WORD	qualtag
;	.WORD	argtag
;	.WORD	-1 | 0
;
; OUTPUTS:
;	QUALTRE becomes the current tree.
;	R0	=	0
;	R3	->	next instruction
; 	Other registers random.
;-

.MACRO	DFLTKA	QUALTAG,ARGTAG,AFFIRM=YES
	.IF	IDN <AFFIRM>,<YES>
	 .WORD	DFLTKA,QUALTAG,ARGTAG,-1
	.IFF
	 .WORD	DFLTKA,QUALTAG,ARGTAG,0
	.ENDC
	.GLOBL	DFLTKA
	.ENDM	DFLTKA

.ENABL	LSB

DFLTKA::CALBX	FET.CQ 	<(R3)>	;Is the qualifier present?
	BCS	10$		;No. Return without error.
	CALBX	FET.KA	<2(R3)>	;Is the argument present, either with
				;or without 'NO' prefix?
	BCC	10$		;Yes. Return without error.

; Create node representing the argument.

	CRE.NODE TREE=QUALTREE,TAG=2(R3),LEVEL=#CQA.LVL,TXTPOS=#0
				;(Specify a dummy text position of 0.)
	BCS	20$		;That failed. Quit.
				;Now R1 -> newly created node.
	TST	4(R3)		;Is it an affirmative node?
	IFNZ			;If so then
	BIS	#NF.AFFIRM,N.FLAG(R1)
				;  Set affirmative flag.
	;ELSE			;Else
	;BIC	#NF.AFFIRM,N.FLAG(R1)
				;  Clear affirmative flag.
	ENDIF
10$:	CLR	R0		;Flag no error.
20$:	ADD	#6,R3		;Bump past the three inline arguments.
	RETURN

.DSABL	LSB
GLOBAL	<QUALTREE>

.SBTTL	PUTCQ -- Put out a command qualifier
;+
; PUTCQ--Put out a command qualifier.
;
; Inline arguments are 
;	The tag (keyword code) of the qualifier to 
;		establish a default for.
;	The "affirmativeness"--either YES or NO.
;
; USAGE:
;	PUTCQ	tag [,AFFIRM={YES | NO}]
;
; BINARY:
;	.WORD	PUTCQ
;	.WORD	tag
;	.WORD	YES | NO
;
; OUTPUTS:
;	PUTCQ creates a node in QUALTRE to represent the qualifier.
;	PUTCQ does NOT check for conflicting qualifiers.
;	QUALTRE becomes the current tree.
;	R0	=	0
;	R3	->	next instruction
; 	Other registers random.
;-

.MACRO	PUTCQ	TAG,AFFIRM=YES
	.IF	IDN <AFFIRM>,<YES>
	 .WORD	PUTCQ,TAG,-1
	.IFF
	 .WORD	PUTCQ,TAG,0
	.ENDC
	.GLOBL	PUTCQ
	.ENDM	PUTCQ

.ENABL	LSB

PUTCQ::	CRE.NODE TREE=QUALTREE,TAG=(R3)+,LEVEL=#CQ.LVL,TXTPOS=#0
				;(Specify a dummy text position of 0.)
	BCS	10$		;That failed. Quit.
				;Now R1 -> newly created node.
	TST	(R3)+		;Is it an affirmative node?
	IFNZ			;If so then
	BIS	#NF.AFFIRM,N.FLAG(R1)
				;  Set affirmative flag.
	;ELSE			;Else
	;BIC	#NF.AFFIRM,N.FLAG(R1)
				;  Clear affirmative flag.
	ENDIF
10$:	RETURN

.DSABL	LSB
GLOBAL	<QUALTREE>

.SBTTL	DEFARG -- Define a qualifier argument in a table
;
; DEFARG--Define a qualifier argument in a table
;
; USAGE:
;	DEFARG 	[tag]
;		[,FLAGS=flags]
;		[,TYPE=type]
;
;	tag--Keyword tag.  By looking this code up in KEYTBL
;		one can find the target string.  For the format of 
;		the target string itself, refer to LX.KEY in CUILEX.MAC.
;		Specify a tag if it's a keyword argument.  
;	FLAGS=flags--flag word containing the following Boolean (bit) flags.
;		QF.NEG--the form /qual=NOarg is accepted.
;			Use this flag only for a keyword argument.
;	TYPE=type--name of syntax type. If none specified, 
;		then any string of the proper general format
;		is accepted.
;
; An argument table goes after a DEFQUAL,
; and consists of one or more DEFARG statements, followed
; by an ENDARG statement.  If there is more than one DEFARG statment,
; the last DEFARG statement may use either TYPE=type or a tag,
; but the others must use tags and not TYPE=type.
;-

.MACRO	DEFARG	TAG,FLAGS=0,TYPE=U$ANY,ARG,MINVAL,MAXVAL
$$$FLG	=	FLAGS
	.IIF	IDN <ARG>,<REQ>	$$$FLG = $$$FLG ! AF.AREQ
	.IIF	IDN <ARG>,<OPT>	$$$FLG = $$$FLG ! AF.AOPT
	.IF	NB <TAG>
	  .WORD	TAG,$$$FLG!AF.KEY
	.GLOBL	TAG
	.IFF
	  .WORD	TYPE
	.GLOBL	TYPE
$$$INT = 0
	.IIF	IDN <TYPE>,<U$INT> $$$INT = 1
	.IIF	IDN <TYPE>,<U$PO2> $$$INT = 1
	.IIF	IDN <TYPE>,<U$S8> $$$INT = 1
	.IIF	IDN <TYPE>,<U$S16> $$$INT = 1
	.IIF	IDN <TYPE>,<U$S32> $$$INT = 1
	.IIF	IDN <TYPE>,<U$U8> $$$INT = 1
	.IIF	IDN <TYPE>,<U$U16> $$$INT = 1
	.IIF	IDN <TYPE>,<U$U32> $$$INT = 1
	.IF	EQ $$$INT
	.WORD	$$$FLG
	.IFF
	.SAVE
	.PSECT	U$TEXT
$$$MIN	= .	
	 .ASCIC	"MINVAL"
$$$MAX	= .	
	 .ASCIC	"MAXVAL"
	.RESTORE
	.WORD	$$$FLG!AF.INT,$$$MIN,$$$MAX
	.ENDC
	.ENDC
	.ENDM	DEFARG

.SBTTL	ENDARG -- End an argument table

.MACRO	ENDARG
	  .WORD	0
	.ENDM	ENDARG

.SBTTL	Binary of an argument table

; ***********************************************************************
; *** Q.TAG and Q.FLAGS must match A.KEY and A.FLAGS due to recursion ***
; ***********************************************************************

	.DSECT
A.KEY:				; 
A.TYPE:	.BLKW			;(Shared location.)
A.FLAGS:.BLKW			;
A.LEN:				;= length of a DEFARG.
	UNORG

.SBTTL	PARARG -- Parse a qualifier argument
;+
; PARARG -- Parse a qualifier argument
;
; INPUTS:
;	R2	->	DEFQUAL table entry
;
; CALB	PARARG <len,flags>
;
;	len	=	Q.LEN or A.LEN, length of DEFQUAL or DEFARG
;	flags	=	Q.FLAGS(R2) or A.FLAGS(R2), flags of DEFQUAL or DEFARG
;
; OUTPUTS:
; C=0 if success
;	R0	=	0
;	//etc//
; C=1 if error
;	R0	=	error code
;	LX.ERP	=	position of error
;-

.ENABL	LSB

	 TMPORG	U$TEXT
10$:	  .ASCIZ ":="
20$:	  .ASCIZ "("
40$:	  .ASCIZ ","
50$:	  .ASCIZ ")"
	 UNORG			

PARARG:	SUBR    <LENGTH,FLAGS,LEVEL>,CHECK
	MOV	FLAGS(R5),R3	;Get the flag word. 
	MOV	LEVEL(R5),TMP.LVL;Get node current level.
	INC	TMP.LVL 	;Node level to create is next address up.
	CALLX	LX.BLA		;Skip an optional blank.		;051
	CALBX	LX.MEM <#10$>	;Look for a colon or equal sign.
	IFCS			;If we didn't find one then
	CLR	R0		;  Preset no error.
	BIT	#QF.AREQ,R3	;  Does this qualifier require an argument?
	BZE	60$		;  No, so everything's legal. Return.
	MOV	#U.EQRQ,R0	;  Yes. Flag ?Equal sign required.
	BR	60$		;  Quit.
	ENDIF			;Else we found colon or equal sign.
	BIT	#QF.AOPT!QF.AREQ,R3
				;Does qualifier accept an argument?
	IFZE			;If not then
	MOV	#U.ARGA,R0	;  Say "?Argument not allowed"
	MOV	LX.PMAT,LX.ERP	;  Position of equal sign is position
				;  of error.
	BR	60$		;  Quit.
	ENDIF			;End if

	ADD	LENGTH(R5),R2	;Bump to first DEFARG statement.
	CALLX	LX.BLA		;Skip optional blank.			;051
	CALBX	LX.EXAC <#20$>	;Look for a left parenthesis.
	IFCC			;If we found one then
30$:	CALLX	LX.BLA		;  Skip optional blanks			;051
	CALB	70$		;  Look for the keyword or arg text.
	BCS	60$		;  Error. Quit.
	CALBX	LX.EXAC <#40$>	;  Look for a comma.
	IFCC			;  If we found one then
	BIT	#QF.ALIS,R3	;    Is a list of arguments accepted?
	BNZ	30$		;    Yes. Go look for next one.
	MOV	#U.TOOA,R0	;    No. Say ?Too many arguments.
	MOV	LX.POS,LX.ERP	;    Position of next arg is position
				;    of error.
	BR	60$		;    Quit.
	ENDIF			;  End if ... We didn't find a comma.
	CALB	LX.EXAC <#50$>	;  Look for a closing parenthesis.
	ELSE			;Else arg is not enclosed in parentheses.
	CALB	70$		;  Look for the keyword or arg text.
	ENDIF			;End if
60$:	RETURN

; Look for the keyword or arg text.
; INPUTS:
;	R2	->	DEFARG entry 
;
; CALB 70$
;

70$:	SUBR
	CALLX	LX.SUP		;Get set up.
	PUSH	R2		;Save pointer to first DEFARG for this qualifier
	CLR	R5		;Assume no NO keyword prefix.		;051
	MOV	LX.POS,R3	;Save scan position.			;051
	BIT	#AF.KEY,A.FLAGS(R2)					;051
				;Are there keywords in the list?	;051
	IFNZ			;If so then				;051
	.ASSUME	A.KEY EQ 0	;  A.KEY field is at offset 0 from R2.	;051
75$:	CALB	MATKEY <(R2)>	;  Try to match keyword.		;051
	BCC	77$		;  We matched the keyword.		;051
				;  Something bad happened.		;051
	CALL	BUMPDA		;  Bump to next DEFARG or ENDARG.	;051
	TST	(R2)		;  Is it an ENDARG?			;051
	BEQ	76$		;  Branch if it is			;051
	BIT	#AF.KEY,A.FLAGS(R2);Looked at all keyword arguments?	;051
	BNE	75$		;  No, keep checking			;051
76$:	TST	R5		;  Yes.  Have we tried "NO" prefix yet?	;051
	BNE	78$		;  Yes, then there's no matching keyword;051
	CALBX	LX.EXAC <#NO.KEY>; Look for NO prefix.			;051
	BCS	78$		;  Not found, try non-keyword		;051
	COM	R5		;  Remember that we found NO prefix.	;051
	MOV	(SP),R2		;  Set up pointer to first DEFARG 	;051
	BR	75$		;  Go try another DEFARG		;051

77$:	BIT	#AF.MULT,A.FLAGS(R2)					;051
				;  Are multiple keyword copies allowed?	;051
	IFEQ			;  If not then				;051
	CALBX	FET.KA <(R2)>	;    This keyword already specified?	;051
	IFCC			;    If so then				;051
	MOV	U.NODE,R4	;      Get pointer to node		;051
	MOV	#-1,N.TAG(R4)	;      Mark tag so future fetches fail	;051
	ENDIF			;    End if				;051
	ENDIF			;  End if				;051
	CRE.NODE TXTPOS=LX.POS,LEVEL=TMP.LVL,TAG=A.KEY(R2)
				;  Create a node at current qualifier level.
	BCS	80$		;  Error occurred. Quit.
				;  Now R1 -> newly created node.
	MOV	LX.PMAT,N.TXTPOS(R1)
				;  Set position of qualifier into node.
	MOV	(R2),N.TAG(R1)	;  Copy the keyword tag into the node.
	TST	R5		;  Was keyword prefixed with NO?
	IFNZ			;  If so then
	BIT	A.FLAGS(R2),#AF.NEG; Does keyword take NO prefix?
	IFZE			;    If not then
	MOV	#U.NPFX,R0	;      Say ?NO prefix not allowed.
	MOV	LX.PMAT,LX.ERP	;      Position of keyword is position
				;      of error.
	BR	80$		;      Quit.
	ENDIF			;    End if
	;BIC	#NF.AFFIRM,N.FLAG(R1)
				;    CRE.NODE clears the NO prefix bit 
				;    Flag NO prefix.
	ELSE			;  Else qualifier wasn't prefixed with NO.
	BIS	#NF.AFFIRM,N.FLAG(R1)
				;    Make it an affirmative keyword.
	ENDIF			;  End if
	ELSE			;Else we're looking for a type.
78$:	TST	(R2)		;  Did we reach the ENDARG statement?
	SEC			;  Assume we did
	BEQ	80$		;  Exit with an error if we did
	MOV	R3,LX.POS	;  Restore scan position (in case the "NO" 
				;  keyword matched above)
	CRE.NODE TXTPOS=LX.POS,LEVEL=TMP.LVL
				;  Create a node for this argument. 
	BCS	80$		;  Error.  Quit.
	.ASSUME	A.TYPE EQ 0	;  A.TYPE word is at offset 0 from R2.
	BIT	A.FLAGS(R2),#AF.INT;Is type an integer type?
	IFNZ			;  If so then
	MOV	4(R2),MINADR	;    Store min value
	MOV	6(R2),MAXADR	;    Store max value
	ENDIF			;  Endif
	CALB	@(R2)		;  Parse the argument.
	BCS	80$		;  Error. Quit.
	TST	N.TXTLEN(R1)	;  Did that syntax type routine insert a 
				;  text length?
	IFZE			;  If not then
	MOV	LX.POS,N.TXTLEN(R1); Set length equal to amount 
	SUB	N.TXTPOS(R1),N.TXTLEN(R1)
				;    of text matched.
	ENDIF			;  End if
	CMP	N.TXTLEN(R1),#U.MAXL
				;  Does string exceed length of CUI common 
				;  buffer?
	IFGT			;  If so then
	MOV	#U.PLNG,R0	;    Say it's too long.
	MOV	N.TXTPOS(R1),LX.ERP; Flag position of error.
	BR	80$		;    Quit
	ENDIF			;  End if
	ENDIF			;End if
	CALB	PARARG <#A.LEN,A.FLAGS(R2),TMP.LVL>
				;Parse any arguments to the arguments.
	DEC	TMP.LVL		;We've come out of this recursive call.  Set
				;level back to where we came into this routine.
	BCS	80$		;Error. Quit.
	CLR	R0		;Flag no error.
80$:	BIT	(SP),(SP)+	;Get rid of argument pointer w/o changing Carry
	RETURN

.DSABL	LSB
GLOBAL	<U.EQRQ,U.ARGA,U.TOOA,U.NPFX,U.PLNG>
GLOBAL	<PARMTRE,CRNTTRE,LX.POS,LX.ERP,MINADR,MAXADR>

.SBTTL	BUMPDQ -- Bump R2 past DEFQUAL
;+
; BUMPDQ -- Bump R2 past DEFQUAL
;
; INPUTS:
;	R2	->	DEFQUAL
;
; CALL	BUMPDQ
;
; OUTPUTS:
;	R2	->	next DEFQUAL or ENDQUAL
;-

.ENABL	LSB

BUMPDQ:	ADD	#Q.LEN,R2	;Bump past DEFQUAL.
	BIT	#QF.AOPT!QF.AREQ,-Q.LEN+Q.FLAGS(R2)
				;Look at flags word of DEFQUAL we just
				;bumped past.  Does it accept an argument?
	IFNZ			;If so then
10$:	CALL	BUMPDA		;  Bump past next DEFARG.  
				;  R2 -> Next DEFARG or ENDARG.
	TST	(R2)		;  Is it an ENDARG?
	BNZ	10$		;  No. Go process next DEFARG.
	TST	(R2)+		;  Yes.  We made it! Bump R2 past ENDARG.
	ENDIF			;
	RETURN

.DSABL	LSB

.SBTTL	BUMPDA -- Bump R2 past DEFARG
;+
; BUMPDA -- Bump R2 past DEFARG
;
; INPUTS:
;	R2	->	DEFARG
;
; CALL	BUMPDA
;
; OUTPUTS:
;	R2	->	next DEFARG or ENDARG
;-

.ENABL	LSB

BUMPDA:	MOV	R3,-(SP)	;Save R3
	MOV	A.FLAGS(R2),R3	;Save flag bits 
	ADD	#A.LEN,R2	;Bump past DEFARG.
	BIT	#AF.INT,-A.LEN+A.FLAGS(R2)
				;Is this one of those integer argument types?
	IFNZ			;If so then
	ADD	#4,R2		;  Make way for the 2 extra words (MAX,MIN)
	ENDIF			;Endif
	BIT	#AF.AOPT!AF.AREQ,R3
				;Look at flags word of DEFARG we just
				;bumped past.  Does it accept an argument?
	IFNZ			;If so then
10$:	CALL	BUMPDA		;  Bump past next DEFARG.  
				;  R2 -> Next DEFARG or ENDARG.
	TST	(R2)		;  Is it an ENDARG?
	BNZ	10$		;  No. Go process next DEFARG.
	TST	(R2)+		;  Yes.  We made it! Bump R2 past ENDARG.
	ENDIF			;Endif.  
	MOV	(SP)+,R3	;Restore R3
	RETURN

.DSABL	LSB

.SBTTL	SETNET--set command network-ness
;+
; SETNET--set command network-ness
;
; INPUTS:
;	NET	=	YES if this is a network command, NO if this
;			is either a local or undecided command
;	NETPOS	=	position at which network-ness was first decided.
;			0 if network-ness is undecided.
;
; CALL	 SETNET,R5
;  .WORD YES | NO
;
; OUTPUTS:
;	C=1	if	error
;	R0	=	return status:
;		U.INET if conflict detected
;		0 otherwise
;
;	C=0	if	no error
;	NET	=	YES if this is a network command, NO if this
;			is either a local or undecided command
;	NETPOS	=	Unchanged if NETPOS <> 0 on input and if NET is
;			not changed.
;			LX.PMAT, position of qualifier or parameter just
;			matched if NETPOS = 0 on input.
;-

SETNET::CLR	R0		;Preset no error.
	TST	NETPOS		;Has network-ness been decided?
	IFZE			;If not then
	MOV	(R5)+,NET	;  Establish it.
	MOV	LX.PMAT,NETPOS	;  Note scan position at which 
				;  network-ness was decided.
	ELSE			;Else
	CMP	NET,(R5)+	;  Are we trying to change the network-ness
				;  of this command?
	IFNE			;  If so then
	MOV	#U.INET,R0	;    Say ?Invalid with network filespec.
	MOV	NETPOS,CONFPOS	;    Note position of lefthand element of
				;    syntax conflict.
	MOV	LX.PMAT,LX.ERP	;    Note position of righthand element of
				;    syntax conflict.
	SEC			;    Flag error.
	ENDIF			;  Else C=0 from CMP.
	ENDIF			;Else C=0 from TST.
	RETURN	R5

GLOBAL	<LX.PMAT,U.INET>

.SBTTL	SCANSEP -- Look for separator that should preceed parameter
;+
; SCANSEP--Look for separator that should preceed parameter.
; 
; INPUTS:
;	R3	->	parameter description
;
; CALB	SCANSEP
;
; OUTPUTS:
;	R0	=	return status
;-

.ENABL	LSB

SCANSEP:SUBR
	CALLX	LX.SUP		;Get set up.
	CALLX	LX.BLA		;Look for gap.				;051
	BIT	#PF.COL,P.FLG(R3);Can colon be used as separator?
	BEQ	20$		;No.
	CALBX	LX.MEM <#10$>	;Look for optional colon or equal sign.
	 TMPORG	U$TEXT
10$:	  .ASCIZ ":="
	 UNORG
	BCC	30$		;Found one
20$:	BIT	#PF.SEP,P.FLG(R3);Is a space absolutely required?
	BNE	30$		;No.  (MOUNT DEV:LABEL)
	DEC	LX.POS		;Back scan position up a character
	CALLX	LX.BLA		;Look for mandatory blank		;051
	BCC	40$		;Didn't find one
	INC	LX.POS		;Restore scan position
	MOV	LX.POS,LX.ERP	;Position of this unknown character is error
	MOV	#U.UCHR,R0	;?Invalid character
	BR	40$		;Quit with error

30$:	CALLX	LX.BLA		;Look for optional blank		;051
	CLR	R0		;Flag no error.
40$:	RETURN			;Finished

GLOBAL	<U.UCHR>
.DSABL	LSB

.SBTTL	MATKEY -- Match a keyword
;+
; MATKEY -- Match a keyword
;
; INPUTS:
;	keyword	=	offset into KEYTBL for address of target ASCIZ string
;
; CALB	MATKEY <keyword>
;
; OUTPUTS:
;	R0	=	status
;	N.TXTLEN(node) =text length matched
;	C=1	if	error
;	C=0	if	no error
;-

.ENABL	LSB

MATKEY:	SUBR	<KEYWORD>
	MOV	KEYWORD(R5),R2	;Get the keyword code.
	CALBX	LX.KEY <KEYTBL(R2)>
				;Look up the target string in KEYTBL,
				;and try to match the target string.
10$:	RETURN

.DSABL	LSB
GLOBAL	<KEYTBL>

.SBTTL	EOS -- Match end-of-string.
;+
; EOS -- Match end-of-string.
;
; FORMAT:
;	CALL	EOS
;
; OUTPUTS:
;	C = 0	if at end of string
;	C = 1	if not at end of string
;-

EOS:	CALLX	LX.BLA		;Skip optional gap.			;051
	CALLX	LX.EOS		;Match end-of-string.			;051
	RETURN			;Return with status			;051

.END
