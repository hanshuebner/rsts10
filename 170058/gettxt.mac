.INCLUDE	%CMN:COMMON%
TITLE	GETTXT,<GET MESSAGE TEXT>,0A,10-MAY-91,SJM/DBM

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR GETTXT
;+
;
; Edit	By   Date	Reason
;  001  SJM  23-Sep-82	CREATION - And it was a good thing
;  002	PRL  26-May-84	Use .INCLUDEs and .LIBRARYs
;  003	DBM  17-Jul-89	Add entry status text
;-

.SBTTL	INCLUDE MACRO LIBRARIES

.LIBRARY	%SYSTEM:PBSMAC%

.SBTTL	MACROS	- SUCK IN NEEDED MACROS

	.MCALL	PSECTS,BITDEF,SAVREG
	.MCALL	FQBERR,CR$LF
	.MCALL	SUBRIB,GETLUN,RETLUN,GETBUF,RETBUF
	.MCALL	GETDEV,RETDEV
	.MCALL	SPLCMD,.ASCIC

	SPLCMD
	PSECTS
	BITDEF
	CR$LF



.SBTTL	GETTXT	- GET MESSAGE TEXT

;+
;
; GETTXT::
;
;
; INPUTS:
;		R0 =  MESSAGE TYPE
;			= 0 FOR RSTS/E ERROR MESSAGES
;			= 1 FOR RMS-11 ERROR MESSAGES
;			= 2 FOR PBS entry status text
;		       >= 3 FOR OTHER'S
;
;		R1 =  MESSAGE NUMBER (OR STS FIELD FOR RMS ERRORS)
;
;		R2 =  STV FIELD FOR RMS ERRORS
;
; CALL:
;	JSR	PC,GETTXT
;
;
; BACK:
;		R1 -> MESSGE TEXT RETURNED
;		R2 =  MESSAGE LENGTH
;
;		ALL OTHER REGISTERS PRESERVED
;
;	C=0 FOR SUCCESS, C=1 IF INTERNAL FAILURE OR ERROR
;
;-

	.PSECT	GETTXT,RO,CON

	.ENABL	LSB

GETTXT::NOP				;FOR DEBUGING
	SAVREG				;SAVE ALL REGISTERS
	MOV	#TXTFAIL,TOS.R1(SP)	;PRESUME A FAILURE (DUMMY TEXT)
	MOV	#FAILEN,TOS.R2(SP)	;PRESUME A FAILURE (DUMMY TEXT LEN)
	CMP	R0,#1			;WHAT KIND OF ERROR AM I?
	BLT	20$			;R0<1 (=0) RSTS/E ERROR TYPE
	BGT	70$			;R0>1 RANDOM OTHER ERROR TYPE
;
; RMS-11 ERROR HANDLER
;
	NEG	R1			;MAKE RMS ERROR NUMBER POSITIVE
	BIT	#BIT0!BIT1,R1		;ANY 'UNUSED' BITS USED?
	BNE	60$			;OHH NOT A PROPER ERROR #
	ASH	#-2,R1			;MAKE RMS ERROR NUMBER A TEXT INDEX
	DEC	R1			;AND MAKE IT ZERO BASED
;
; NON-RSTS/E ERROR HANDLER
;

10$:	CMP	#15.,R0			;CHECK FOR ERR TYP OUT OF RANGE
	BLT	60$			;MUST BE IN RANGE OR IS ERROR
	TST	R1			;ERROR NUMBERS MUST BE >=ZERO
	BLT	60$			;ILLEGAL ERROR NUMBER
	DEC	R0			;TO POINT US TO END OF PREVIOUS
	ASL	R0			;MAKE IT A WORD OFFSET BASE
	ADD	ERRTBL(R0),R1		;ADD OFFSET INTO TEXT FILE FOR START
	CALL	GETIT			;AND GO TO IT
	BCS	60$			;IF FAILURE GO EXIT
	BR	30$			;AND STUFF IT



;
; RSTS/E ERROR HANDLER
;
20$:	CALLX	CLRFQX			;CLEAR FIRQB/XRB
	MOVB	#ERRFQ,@#FIRQB+FQFUN	;ASK FOR A RSTS/E ERROR MESSAGE
	MOVB	R1,@#FIRQB+FQERNO	;PASS THE REQUESTED ERR NUMBER
	CALFIP				;PLEASE TO DO IT FOR ME MR. FIP
	FQBERR	60$			;GOTO ERROR EXIT IF ERROR
	MOV	#FIRQB+4+1,R2		;GET PTR TO ERROR MESSAGE
	MOV	#28.-1,R3		;AND LENGTH
	TST	R1			;CHECK FOR SPECIAL CASE ERR=0
	BNE	30$			;BR IF NOT SPECIAL CASE
	DEC	R2			;BACK UP TO INCLUDE FIRST CHAR
	INC	R3			;AND UP THE COUND

30$:	MOV	#TXTBUF,R4		;GET PTR TO DESTINATION BUFFER
	MOV	R4,TOS.R1(SP)		;PUT DATA PTR ON STACK
	MOV	R3,TOS.R2(SP)		;AND LEN OF DATA
40$:	MOVB	(R2)+,(R4)+		;MOVE DATA BYTE BY BYTE
	SOB	R3,40$			;COPY UNTIL DONE

50$:	TST	(PC)+			;CLEAR CARRY AND RETURN
60$:	SEC				;SET CARRY AND RETURN
	RETURN

70$:;	CMP	R0,#2			;Make sure we want PBS status text ;002
;	BNE	10$			;Nope, some other kind of text	;002
	CMP	R1,#JS$MAX		;Is the status value too high?	;002
	BHIS	60$			;Yep, return bogus error text	;002
	ASL	R1			;Double R1			;002
	MOV	STSTBL(R1),R2		;Get pointer to .ASCIC text	;002
	MOVB	(R2)+,R3		;Pick up length of the data	;002
	BR	30$			;Go return the data		;002

	.DSABL	LSB
	

.SBTTL	GETIT	- GET MESSAGE TEXT FROM DISK FILE

;
;
; GETIT:
;
;
; INPUTS:
;		R0 = MESSAGE TEXT NUMBER
;
; CALL:
;	JSR	PC,GETIT
;
;
; BACK:
;		R2 -> MESSGE TEXT RETURNED
;		R3 =  MESSAGE LENGTH
;
;		ALL OTHER REGISTERS PRESERVED
;
;	C=0 FOR SUCCESS, C=1 IF INTERNAL FAILURE OR ERROR
;
;


GETIT:	SAVREG
	GETLUN	R5			;GET A CHANNEL NUMBER TO USE
	BCS	20$			;EXIT IF NO LUNS LEFT
	MOV	R1,R3			;USE R3 FOR TEXT NUMBER
	MOV	#512.,R1		;NUMBER OF BYTES FOR BUFFER
	GETBUF	R0,R1
	MOV	R0,R4			;LOAD BUFFER PTR
	BCS	40$			;NO BUFFER SO GET OUT
	CALLX	CLRFQX			;CLEAR FIRQB/XRB
	MOV	#ERRLEN,@#XRB+XRLEN	;LEN OF FILESPEC
	MOV	#ERRLEN,@#XRB+XRBC	;LEN OF FILESPEC
	MOV	#ERRFIL,@#XRB+XRLOC	;ADDR OF FILESPEC
	.FSS				;CALL RSTS FILE NAME STRING SCAN
	MOVB	R5,@#FIRQB+FQFIL	;CHANNEL #
	MOVB	#OPNFQ,@#FIRQB+FQFUN	;SET UP FOR RSTS FILE OPEN
	CALFIP				;ASK FIP TO OPEN THE FILE	
	FQBERR	30$			;CHECK FOR ERROR
	CALLX	CLRFQX			;CLEAR FIRQB/XRB FOR READ
	MOV	#512.,@#XRB+XRLEN	;LENGTH OF BUFFER
	MOV	R4,@#XRB+XRLOC		;ADDR OF BUFFER
	MOVB	R5,@#XRB+XRCI		;CHANNEL
	MOV	R3,R2			;GET SECOND COPY OF MESSAGE TXT NUMBER
	ASH	#-3,R2			;BLK=(TXT/8)+1
	INC	R2			;START WITH BLOCK 1
	MOV	R2,@#XRB+XRBLK		;BLOCK OFFSET INTO FILE
	DEC	R2
	.READ				;AND READ THE BLOCK
	FQBERR	30$			;ERROR EXIT IF ERROR
10$:	ASH	#3,R2			;GET TXT NUMBER WITH OUT BYTE OFFSET
	SUB	R2,R3			;# OF RECORDS IN BUFFER BEFORE OURS
	ASH	#6,R3			;NOW HAVE BYTE OFFSET INTO BUFFER
	ADD	R4,R3			;MAKE AN ADDR OF BUFFER OFFSET
	MOV	R3,TOS.R2(SP)		;PUT R2 ON THE STACK
	MOV	#64.,TOS.R3(SP)		;SET LEN OF STRING FOUND
	CALL	30$			;GO RETURN BUFFER/LUN
	CLC
20$:	RETURN	


;
;
; LITTLE ROUTINE TO RETURN BUFFER SPACE AND CHANNEL TO THE
; APPROPRIATE RESOURCE POOL
;
; INPUTS:
;		R4 -> BUFFER
;		R1 = REAL BUFFER LEN
;		R5 = LUN *2
;
; CALL 
;
;
; BACK:
;
;		ALL REGISTERS PRESERVED
;
;	C=1 ALWAYS
;


30$:	RETBUF	R4,R1			;AND RETURN THE BUFFER
40$:	RETLUN	R5			;RETURN LUN
	SEC				;PRETEND WE FAILED
	RETURN				;AND RETURN



	.SAVE
	.PSECT	DATA

;ERRFIL::.ASCII	<LOGICL:[000,000]FILNAM.EXT/RO>
ERRFIL::.ASCII	'PBS$:PBSERR.ERR/RO           '
	.EVEN
	ERRLEN=.-ERRFIL

TXTFAIL:.ASCII	/Error Text File - PBS$:PBSERR.ERR Lookup Failure/
	.EVEN
	FAILEN=.-TXTFAIL

ERRTBL::.WORD	0			;RSTS ERROR MESSAGES (NOT IN TBL)
	.WORD	456.			;RMS-11 ERROR MESSAGE FIRST
	.WORD	0			;PBS entry status (Not in TBL)
	.WORD	0			;OTHERS?????
	.BLKW0	32.-<.-ERRTBL>		;PAD TABLE OUT TO 16. WORDS



	.PSECT	IMPURE
	.EVEN
TXTBUF:	.BLKB0	64.			;CREATE A BUFFER

	.EVEN
STSTBL:	.WORD	100$			;JS$FRM =  0 = Forms wait state
	.WORD	101$			;JS$NRD =  1 = Hold
	.WORD	102$			;JS$AFT =  2 = After
	.WORD	103$			;JS$RDY =  3 = Ready
	.WORD	104$			;JS$STR =  4 = Started
	.WORD	105$			;JS$ABT =  5 = Aborting
	.WORD	106$			;JS$SUC =  6 = Success
	.WORD	107$			;JS$FAI =  7 = Severe Error
	.WORD	110$			;JS$KIL = 10 = Aborted during execution
	.WORD	111$			;JS$ABO = 11 = Deleted before execution
	.WORD	112$			;JS$ERR = 12 = Error
	.WORD	113$			;JS$WAR = 13 = Warning
	.WORD	114$			;JS$UNX = 14 = Unknown
	.WORD	115$			;JS$TIM = 15 = Time limit exceeded
	.WORD	116$			;JS$CPU = 16 = CPU limit exceeded
	.WORD	117$			;JS$ILL = 17 = Entry could not execute

100$:	.ASCIC	<Forms_wait>
101$:	.ASCIC	<Hold>
102$:	.ASCIC	<After>
103$:	.ASCIC	<Ready>
104$:	.ASCIC	<Started>
105$:	.ASCIC	<Aborting>
106$:	.ASCIC	<Success>
107$:	.ASCIC	<Severe Error>
110$:	.ASCIC	<Entry aborted during execution>
111$:	.ASCIC	<Entry deleted before execution>
112$:	.ASCIC	<Error>
113$:	.ASCIC	<Warning>
114$:	.ASCIC	<Unknown>
115$:	.ASCIC	<Time limit exceeded>
116$:	.ASCIC	<CPU limit exceeded>
117$:	.ASCIC	<Entry could not execute>

	.EVEN

	.RESTOR
	.END
