.INCLUDE	%CMN:COMMON%
.INCLUDE	%CMN:KERNEL%
TITLE	PBSMAC,<DEFINE MACROS FOR PBS>,0D,02-AUG-91,SJM/PRL/KCG/TJK/DBM

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR PBSMAC
;+
;
;  001  SJM  23-Sep-82	CREATION - And it was a good thing
;  002	PRL  17-Nov-82  Add INITIALIZE DEVICE packet
;  			Add DELETE DEVICE packet
;  003	PRL  27-Nov-82	Fix File flag descriptions
;			Move PG0 & PG1 words in ALLCMD macro
;  004	PRL  22-Dec-82	Split PAUSE/CONTINUE flag bits
;			Add PAF$EJO (/END_JOB) & PAF$EFI (/END_FILE)
;  005	PRL  23-Dec-82	Add JBF$PRV (privileged job) flag
;  006  KCG  20-Jan-83	Add OF.SEQ as a legal value.
;  007	PRL  12-Feb-83	Add IDF$ASN (assign device) bit flag
;
;  008	PRL  27-Apr-83	Prep for version 9.0
;  009	KCG  30-Aug-83	Added FM$TOF for CHR words, JB$HLD, and JB$REL.
;  010	PRL  18-Sep-83	Added JB.MDA, JB.MTI (last modified date/time)
;  011	PRL  14-Nov-83	Added AK.NML and AK.NAM fields to ACK packet
;  012	KCG  21-Nov-83	Move Queue type info here from QMAN
;  013	KCG  06-Jan-84	Add DECnet Macros for our version of them
;  014	KCG  19-Jan-84	Change JB and MD packet to reflect priv and dev changes
;  015	KCG  02-Feb-84	Add JB.RPR, JB.PBR, JB.LOG, and MD equivs
;			Made PRVSIZ to reflect size ( in words ) of priv mask
;  016	KCG  26-Mar-84	Add SETPRV macro for setting 3PP
;  017	KCG  27-Mar-84	Add MS, MQ, DH, and DN commands
;  018  PRL  28-Mar-84  Add PD$EOP bit for /PAGE_END
;  019	KCG  29-Mar-84	Add MUTEXC macro for Mutually Exclusive testing
;  020	PRL  13-Apr-84	Add code word to XMITTG section
;  021	PRL  19-Apr-84	Change FB$xxx symbols to FF$xxx
;  022	PRL  02-May-84	Remove PB.NXT offset
;  023	PRL  07-May-84	Define FF$QLG (queue logfile) flag bit
;  024 	KCG  08-May-84	Define new JS$ flags for completion codes in BATSER
;  025	PRL  09-May-84	Add MOVBYT macro
;  026	PRL  12-May-84	Add RECV, REMV, DCLR macros
;			Add FIXSTG, .ASCIC, EVEN macros
;  027	PRL  13-May-84	Add LOT macro
;			Remove all MSR-related macros
;  028	KCG  14-May-84	Clear FQB and XRB on DCLR macro
;  029	PRL  14-May-84	Define CHKPRV macro
;			Define JB$EXQ flag bit
;  030	PRL  15-May-84	Define new XMITxx symbols
;  031	PRL  16-May-84	Change CHKPRV to take reg argument
;  032	PRL  22-May-84	Renamed SKDCON macro to PBSCON
;			Added P.VER, NAM.LEN, FIL.LEN to PBSCON macro
;			Move PRVSIZ from SPLCMD to PBSCON macro
;  033	PRL  26-May-84	Change CHKPRV macro to call CHKPRV routine
;  034	PRL  27-May-84	Rename ASCIC macro to .ASCIC
;			Add FILL macro
;  035	KCG  08-Jun-84	Fix FILL macro
;  036	KCG  14-Jun-84	Remove DH and DN command
;  037	PRL  27-Jul-84	Add PD$IMM bit to pause device flag
;  038	KCG  19-Sep-84	Add FM$CTL for allowing non printable characters
;  039	KCG  25-Sep-84	Add FM$CUP for printing up-arrow characters
;  040	PRL  26-Sep-84	Add MQ.FLG and MS.FLG flag bit definitions
;  041	PRL  16-Oct-84	Define ID$TEN (tentative) flag bit for INIDEV
;  042	PRL  22-Oct-84	Add MD.FLG flag bit definitions
;  043	KCG  28-Oct-84	Add RIBDEF macro for defining RIB data structure offsets
;  044	PRL  30-Oct-84	Change symbol names (QT$) in QUEDEF macro
;  045	PRL  04-Nov-84	Add CONTROLS flag bits to MS.FLG
;  046	KCG  10-Jan-85	Add /NOFEED flag bits to FM$ flag bits
;  047	KCG  10-Jan-85	Add /NOFEED and /FEED flag to MS.FLG
;  048	KCG  16-Jan-85	Remove /FEED and /NOFEED bits to FM$ and MS$
;  049	KCG  28-Jan-85	Inc P.VER to 7 for packet changes for BL11
;  050	KCG  29-Jan-85	Remove JB.USR and MD.USR
;  051	KCG  29-Jan-85	Add offsets for margins in ID., MD., MS., and JB.
;  052	PRL  29-Jan-85	Shorten CD.xxx packet to remove form fields
;  053  TJK  14-SEP-85  Add FM$FTP for file trailers
;  054	PRL  20-Jan-86	Add JB$TAP (reserved job flag for TAP group)
;
;			[RSTS/E V9.6]
;  055	DBM  18-Feb-88	Add FF$RAP for /[NO]WRAP support
;
;			[RSTS/E V10.0]
;  056	DBM  22-Jun-89	Add OMS, FORMS_WAIT and /NOTIFY support
;
;			[RSTS/E V10.1]
;  057	PRL  17-Mar-91	Add MD$NOT, MD$NNT flags (set/clear NOTIFY)
;-

.SBTTL	BITDEF	- SYMBOLIC BIT DEFINITIONS

;
; DEFINE BIT VALUES
;

	.MACRO	BITDEF
	.SAVE

	.BSECT	,CREF
BIT0:	.BLKB	.		;BIT 0	VALUE 1 (1.)
BIT1:	.BLKB	.		;BIT 1	VALUE 2 (2.)
BIT2:	.BLKB	.		;BIT 2	VALUE 4 (4.)
BIT3:	.BLKB	.		;BIT 3	VALUE 10 (8.)
BIT4:	.BLKB	.		;BIT 4	VALUE 20 (16.)
BIT5:	.BLKB	.		;BIT 5	VALUE 40 (32.)
BIT6:	.BLKB	.		;BIT 6  VALUE 100 (64.)
BIT7:	.BLKB	.		;BIT 7	VALUE 200 (128.)
BIT8:	.BLKB	.		;BIT 8	VALUE 400 (256.)
BIT9:	.BLKB	.		;BIT 9	VALUE 1000 (512.)
BIT10:	.BLKB	.		;BIT 10	VALUE 2000 (1024.)
BIT11:	.BLKB	.		;BIT 11	VALUE 4000 (2048.)
BIT12:	.BLKB	.		;BIT 12	VALUE 10000 (4096.)
BIT13:	.BLKB	.		;BIT 13	VALUE 20000 (8192.)
BIT14:	.BLKB	.		;BIT 14	VALUE 40000 (16384.)
BIT15:	.BLKB	.		;BIT 15	VALUE 100000 (32768.)
	
	.RESTORE
	.ENDM	BITDEF


.SBTTL	DSKMOD	- SYMBOLIC DISK MODE DEFINITIONS

;
; DEFINE RSTS/E DISK MODES
;

	.MACRO	DSKMOD
	.SAVE

	.BSECT	,CREF
UPDATE:	.BLKB	.		; UPDATE MODE
APPEND:	.BLKB	.		; APPEND MODE
GUARDE:	.BLKB	.		; GUARDED (UPDATE) MODE
EXTEND:	.BLKB	.		; EXTEND MODE
CONTIG:	.BLKB	.		; CONTIGUOUS MODE
TENTAT:	.BLKB	.		; TENTATIVE MODE
CODITG:	.BLKB	.		; CONDITIONALLY CONTIGUOUS MODE
NOSUPE:	.BLKB	.		; NO SUPERSEDE MODE
CACHE:	.BLKB	.		; CACHE MODE
BEGDIR:	.BLKB	.		; PLACE BEGINNING DIRECTORY MODE
ENDDIR:	.BLKB	.		; PLACE END DIRECTORY MODE
SCACHE:	.BLKB	.		; SEQUENTIAL CACHE MODE
READR:	.BLKB	.		; READ REGARDLESS MODE
RONLY:	.BLKB	.		; READ ONLY MODE
UFD:	.BLKB	.		; WRITE UFD MODE

	.RESTORE
	.ENDM	DSKMOD


.SBTTL	CR$LF	- COMMON SYMBOLIC CHARACTER DEFINITIONS

;
; DEFINE COMMONLY USED CHARACTERS
;

	.MACRO	CR$LF

	CR$NUL	=  0		; <NULL>
	CR$TAB	= 11		; <TAB>
	CR$LF	= 12		; <LF>
	CR$VTAB	= 13		; <VTAB>
	CR$FF	= 14		; <FF>
	CR$CR	= 15		; <CR>
	CR$SP	= 40		; <SPACE>
	SPACE	= 40		; <SPACE>
	BLANK	= 40		; <SPACE>
	CR$ESC	= 33		; <ESC>
	CR$0	= 60		; "0"
	CR$9	= 71		; "9"

	.ENDM	CR$LF


.SBTTL	PSECTS	- DEFINE/ORDER THE PSECTS

;
; DEFINE AND ORDER THE PSECTS
;
	.MACRO	PSECTS
	.SAVE

	.PSECT	SYSROO,RO,CON
	.PSECT	BUFFER,RW,CON
	.PSECT	PURE  ,RO,CON,D
	.PSECT	IMPURE,RW,CON
	.PSECT	GIMPUR,RW,CON,GBL
	.PSECT	INIT  ,RO,CON
	.PSECT	DISPAT,RO,CON,GBL	; WARNING THESE ARE ORDERED PSECTS
	.PSECT	DISPAU,RO,CON,GBL	; DO NOT CHANGE THE ORDER OF THESE TWO
	.PSECT	NAMES ,RO,CON,GBL
	.PSECT	JDB   ,RW,CON,GBL

	.RESTORE
	.ENDM	PSECTS


.SBTTL	PBSCON	- PBS PACKAGE CONSTANTS

;
; DEFINE THE CONSTANTS FOR PBS
;

	.MACRO	PBSCON

	 MAXJOB	= 10.		;MAXIMUM NUMBER OF SUBJOBS SUPPORTED
	 BLKS	= 8.		;NUMBER OF BLOCKS IN THE DYNAMIC BUFFER POOL
	 BUFSZ	= 512.*BLKS	;SIZE OF DYNAMIC BUFFER POOL IN BYTES
	 BUFCHN	= 14.		;DEFINE CHANNEL FOR DYNAMIC BUFFER POOL

	 PRVSIZ	= 4.		;Define length of priv mask, in words	;032
	 P.VER	= 7.		;Define PBS message packet version	;049
	 NAM.LEN= 9.		;Define length of packet string		;032
	 FIL.LEN= 28.		;Define max length of RSTS file-spec	;032

	.ENDM	PBSCON

.SBTTL	SKDSTA	- SKED STATUS BITS

;
; DEFINE SUBJOB STATUS BUTS
;

	.MACRO	SKDSTA
	.SAVE

	.BSECT	,CREF
MSGPND:	.BLKB	.		;MESSAGE PENDING FOR SUBJOB
RUNNOW:	.BLKB	.		;SUBJOB READY TO RUN (OR INIT)
RUNOK:	.BLKB	.		;RUN WHENEVER WE ARE WAKEN UP
	.BLKB	.
	.BLKB	.
	.BLKB	.
	.BLKB	.
	.BLKB	.
	.BLKB	.
	.BLKB	.
	.BLKB	.
	.BLKB	.
	.BLKB	.
	.BLKB	.
WTSUB:	.BLKB	.		;SUBJOB WAITING FOR SUB FUNCTION
NORUN:	.BLKB	.		;SUBJOB IS CRASHED, DON'T RUN IT

	.RESTORE
	.ENDM	SKDSTA


.SBTTL	SKDJDB	- DEFINE SKED JBD OFFSETS

;
; DEFINE SUBJOB JDB OFFSETS
;

	.MACRO	SKDJDB
	.SAVE

	.DSECT
JDBSTA:	.BLKW			;OFFSET FOR SUBJOB STATUS WORD
SLEP:	.BLKW			;OFFSET FOR SUBJOB SLEEP TIMER
JDBSIZ:				;SIZE OF JDB IN BYTE

	.RESTORE
	.ENDM	SKDJDB

.SBTTL	RIBDEF	- DEFINE RIB DATA STRUCTURE OFFSETS


;
;	Define the linked list data structure for storing the address to 
;	mess count portion of the sub-rib assign to a sub-job.  Each sub-job
;	can have at most 8 ribs ( which we don't enforce ).
;
;	The general format is:
;
;	              -----------------------------
;	              |                           |  +0 RIB.NX
;	              -----------------------------
;	              |                           |  +2 RIB.LN
;	              -----------------------------
;	   RIB.SJ +5  |             |             |  +4 RIB.SR
;	              -----------------------------
;	              |                           |  +6 RIB.MC
;	              -----------------------------
;

	.MACRO	RIBDEF

	.SAVE
	.DSECT	,CREF

RIB.NX:	.BLKW			;Pointer to next 
RIB.LN:	.BLKW			;Length of data structure (standard)
RIB.SR:	.BLKB			;Sub-rib number
RIB.SJ:	.BLKB			;Sub-job number
RIB.MC:	.BLKW			;Message count pointer

RIB.SI	= <.-RIB.NX>		;size of rib pointer data structure

	.RESTORE

	.ENDM	RIBDEF

.SBTTL	QUEDEF	- DEFINE RECORD/QUEUE TYPE BITS

;+
;	The xx.QUE field determines the record and queue type.
;	The following symbols define what values are assigned to
;	the fields in the diagram.
;
;	       7     6	   5	 4     3     2	   1	 0
;	    +-----+-----+-----+-----+-----+-----+-----+-----+
;	    |      Record type      |      Queue type       |
;	    +-----+-----+-----+-----+-----+-----+-----+-----+
;-

	.MACRO	QUEDEF

; Define record types (zero for entry records)

	.DSECT	,NOCREF
QR$ENT:	.BLKB	20		;000 = entry (job) record type		;044
QR$QDB:	.BLKB	20		;020 = QDB (queue) record type		;044
QR$SDB:	.BLKB	20		;040 = SDB (server) record type		;044
QR$FNT:	.BLKB	20		;060 = FDB (font) record type		;044
QR$ASB:	.BLKB	20		;100 = ASB (assign server) record type	;044
QR$BAD:	.BLKB	20		;120 = 1st invalid record type		;044
	.BLKB	20		;140 = undefined
	.BLKB	20		;160 = undefined
	.BLKB	20		;200 = undefined
	.BLKB	20		;220 = undefined
	.BLKB	20		;240 = undefined
	.BLKB	20		;260 = undefined
	.BLKB	20		;300 = undefined
	.BLKB	20		;320 = undefined
	.BLKB	20		;340 = undefined
	.BLKB	20		;360 = undefined (maximum)

; Define queue types (for all record types)

	.DSECT	,NOCREF
	.BLKB				;000 = reserved
QT$PRI:	.BLKB				;001 = print queue type
QT$BAT:	.BLKB				;002 = batch queue type
QT$BAD:					;003 = First invalid queue type	;056
QT$RJE:	.BLKB				;003 = RJ2780 queue type
QT$DJS:	.BLKB				;004 = DJS queue type
	.BLKB				;005 = undefined		;056
	.BLKB				;006 = undefined
	.BLKB				;007 = undefined
	.BLKB				;010 = undefined
	.BLKB				;011 = undefined
	.BLKB				;012 = undefined
	.BLKB				;013 = undefined
	.BLKB				;014 = undefined
	.BLKB				;015 = undefined
	.BLKB				;016 = undefined
	.BLKB				;017 = undefined (maximum)

; Ensure record types do not conflict with queue types

.ASSUME	<QR$ENT & 17> EQ 0
.ASSUME	<QR$QDB & 17> EQ 0
.ASSUME	<QR$SDB & 17> EQ 0
.ASSUME <QR$FNT & 17> EQ 0
.ASSUME <QR$ASB & 17> EQ 0

	.ENDM	QUEDEF

.SBTTL	RMSBLK	- DEFINE RMS I/O BLOCK OFFSETS

;
;	DEFINE OFFSETS FOR ARGUMENT PASSING TO RMS INTERFACE
;

	.MACRO	RMSBLK
	.SAVE

	.DSECT	,CREF
ARGCNT:	.BLKW
STS:	.BLKW
STV:	.BLKW
NAM:	.BLKW
NAML:	.BLKW
BUF:	.BLKW
BUFL:	.BLKW
REC:	.BLKW
RECL:	.BLKW
RECBL:	.BLKW
FAB:	.BLKW
RAB:	.BLKW
OPT:	.BLKW
INT1:	.BLKW
INT2:	.BLKW
ARGSIZ:

;
; DEFINE OPTION WORD BITS 
;

	.BSECT	,CREF
BLKIO:	.BLKB	.		;USE BLOCK I/O MODE
	.BLKB	.
	.BLKB	.
	.BLKB	.
	.BLKB	.
	.BLKB	.
	.BLKB	.
	.BLKB	.
	.BLKB	.
	.BLKB	.
	.BLKB	.
	.BLKB	.
	.BLKB	.
	.BLKB	.
	.BLKB	.
	.BLKB	.
	.BLKB	.


	.RESTORE
	.ENDM	RMSBLK


.SBTTL	XMTBLK	- DEFINE XMIT IO REQUEST BLOCK

;
; DEFINE THE OFFSETS IN THE XMIT IO BLOCK
;

	.MACRO	XMTBLK
	.SAVE

	.DSECT	,CREF
XMITBF:
XMITNX:	.BLKW				;LINK TO NEXT BLOCK OR ZERO
XMITLN:	.BLKW				;LENGTH OF TOTAL XMIT BUFFER
XMITCT:	.BLKB				;NUMBER OF RECIEVIERS
XMITRT:	.BLKB				;RE-TRY COUNTER
XMITAL:	.BLKW				;Actual length of message	;020
XMITFX:					;LENGTH OF FIXED PORTION

	.DSECT	,CREF

XMITTG:	.BLKB				;code for broadcast/send:	;020
					; 0 = broadcast			;020
					; 1 = send by job no/local obj	;020
					; 2 = send by rcvr ID		;020
					; 3 = return URP confirmation	;020
					; 4 = send URP			;030
XMITJB:	.BLKB				; KB, job*2, LOT, or req type	;030
XMITID:					; receiver ID			;056
XMITSO:	.BLKW				; Starting offset (Broadcast)	;056
XMITCO:	.BLKW				; Current offset (Broadcast)	;056
XMITPN:	.BLKW				; Owner's [p,pn] number		;056
XMITTL:					;LENGTH OF TARGET DISCRIPTER

	XM.LEN	= XMITFX+XMITTL		;LENGTH OF TOTAL XMIT HEADER

	.RESTORE
	.ENDM	XMTBLK


.SBTTL	FQBERR	- FIRQB ERROR CHECKER

;
; FIRQB ERROR CHECKER
;

	.MACRO	FQBERR	LABEL
	 TSTB	@#FIRQB			;any errors ?
	 BNE	LABEL			;yes, branch to LABEL
	.ENDM	FQBERR

.SBTTL	RMSERR	- RMS FAB/RAB ERROR CHECKER

;
; RMS ERROR CHECKER
;

	.MACRO	RMSERR	REG,LABEL
	 TST	O$STS(REG)	;ANY FATAL ERRORS ?
	 BMI	LABEL		;YES BRANCH TO TRAP
	.ENDM	RMSERR

.SBTTL	SYNERR	- DECLARE AND PROCESS SYNC ERROR

;+
; THIS MACRO IS USED TO REJECT A STATE TRANSITION IN THE
; MESSAGE STATE PROCESSOR.  IT TAKES ONE ARGUMENT, WHICH
; IS A REGISTER POINTING TO A SPOOLER DEFINITION BLOCK.
; IT THEN SETS THE CURRENT STATE TO SYNC AND CALLS THE
; SYNC ERROR HANDLER.
;-

	.MACRO	SYNERR	REG
	 MOV	#SPLSYN,SP.STA(REG)	; SET STATE TO SYNC ERROR
	 JMP	SPSYN			; AND GO HANDLE IT
	.ENDM	SYNERR

.SBTTL	JOBNUM	- RETURN SKED JOB NUMBER TIMES 2

	.MACRO	JOBNUM	LABEL
	 MOV	SJOB,LABEL	; SUBJOB NUMBER TIMES 2
	.GLOBL	SJOB
	.ENDM	JOBNUM


.SBTTL	NOTOFF	- VERIFY ARGUMENT 'ARG' IS NOT REGISTER 'REG' COMPLEX

	.MACRO	NOTOFF	REG,ARG
	 .NTYPE	$$MODE,ARG
	 .IIF	NE <$$MODE&7>-REG	.MEXIT
	 .IIF	NE <$$MODE&70>	.ERROR	CAN'T USE OFFSET FROM 'REG
	.ENDM	NOTOFF

.SBTTL	NOTREG	- VERIFY ARGUMENT 'ARG' DOES NOT INVOLVE REGISTER 'REG'

	.MACRO	NOTREG	REG,ARG
	 .NTYPE	$$MODE,ARG
	 .IIF	EQ <$$MODE&7>-REG	.ERROR	CAN'T INVOLVE 'REG
	.ENDM	NOTREG


.SBTTL	SUBRIB	- GET SUBJOB'S RIB NUMBER

	.MACRO	SUBRIB	ADDRES,UNIT
	 .MCALL	JOBNUM,NOTOFF
	 NOTOFF	5,ADDRES
	 .IF	NB <UNIT>
.ASSUME	UNIT GT 0
.ASSUME	UNIT LE 7.
	 .ENDC
	.IIF	DIF R5,ADDRES,	 PUSH R5
	 JOBNUM	R5	
	 ASH	#2.,R5
	 SUB	#7,R5
	 .IIF	NB <UNIT> ADD	#'UNIT,R5
	.IIF	DIF R5,ADDRES,	 MOV	R5,ADDRES
	.IIF	DIF R5,ADDRES,	 POP R5
	.ENDM	SUBRIB


.SBTTL	STALL	- STALL SUBJOB FOR LATER

	.MACRO	STALL	TIM
	 MOV	TIM,R5
	 JMPX	STALL
	.ENDM	STALL


.SBTTL	CRASH	- FATAL TERMINATION OF SUBJOB

; GENERATE AN INSTRUCTION GUARANTEED TO BE ILLEGAL (JMP PC)

	.MACRO	CRASH
	 .WORD	107	;?ILL INS TRAP
	.ENDM	CRASH


.SBTTL	SHUTUP	- TERMINATE WITHOUT ERROR (SHUTDOWN)

	.MACRO	SHUTUP
	 JMPX	SHUTUP
	.ENDM	SHUTUP


.SBTTL	CHKFRE	- CHECK FREE LIST FOR PROBLEMS/CRASH ON FAILURE

	.MACRO	CHKFRE	?A
	.IF	NE DEBUG$
	.MCALL	CRASH
	 CALLX	CHKFRE
	 BCC	A
	 CRASH
	 A:		;REF LABEL
	.ENDC
	.ENDM	CHKFRE


.SBTTL	DEBUG	- ENABLE/DISABLE DEBUGING


	.MACRO	DEBUG	ONOROFF
	.IF	IDN	ONOROFF,ON
	 DEBUG$=1
	.IFF
	 DEBUG$=0
	.ENDC
	.ENDM	DEBUG



.SBTTL	SAVREG	- REGISTER SAVER

	.MACRO	SAVREG
	CALLX	SAVREG,R5
	.DSABL	CRF
	TOS.R0	=	0+1*2
	TOS.R1	=	1+1*2
	TOS.R2	=	2+1*2
	TOS.R3	=	3+1*2
	TOS.R4	=	4+1*2
	TOS.R5	=	5+1*2
	TOS.RA	=	6+1*2
	.ENABL	CRF
	.ENDM	SAVREG


.SBTTL	GETLUN	- GET LUN TIMES 2 FOR SUBJOB

	.MACRO	GETLUN	ADDRES
	 .MCALL	NOTOFF
	 NOTOFF	5,ADDRES
	.IIF	DIF R5,ADDRES,	 PUSH R5
	 CALLX	GETLUN
	.IIF	DIF R5,ADDRES,	 MOV	R5,ADDRES
	.IIF	DIF R5,ADDRES,	 POP	R5
	.ENDM	GETLUN

.SBTTL	RETLUN	- RETURN LUN TIMES 2 FOR SUBJOB

	.MACRO	RETLUN	ADDRES
	.IIF	DIF R5,ADDRES,	 PUSH	R5
	.IIF	DIF R5,ADDRES,	 MOV	ADDRES,R5
	 CALLX	RETLUN
	.IIF	DIF R5,ADDRES,	 POP	R5
	.ENDM	RETLUN


.SBTTL	GETBUF	- ALLOCATE DYNAMIC BUFFER

;		TO ROUTINE	FROM ROUTINE
;	R0=	LIST HEAD	=ADDR
;	R1=	SIZE
;	R2=	0


	.MACRO	GETBUF	ADDRES,LENGTH,CLEAR
	.MCALL	NOTREG
	NOTREG	1,ADDRES
	NOTREG	0,LENGTH
	.IIF	DIF R0,ADDRES,	PUSH R0
	.IIF	DIF R1,LENGTH,	PUSH R1
	.IIF	DIF R1,LENGTH,	MOV	LENGTH,R1

	.IIF	NB	<CLEAR>,CALLX	GTCBUF
	.IIF	B	<CLEAR>,CALLX	GETBUF

	.IIF	DIF R0,ADDRES,	MOV	R0,ADDRES
	.IIF	DIF R1,LENGTH,	MOV	R1,LENGTH

	.IIF	DIF R1,LENGTH,	POP	R1
	.IIF	DIF R0,ADDRES,	POP	R0
	.ENDM	GETBUF




.SBTTL	RETBUF	- DE-ALLOCATE DYNAMIC BUFFER


;		TO ROUTINE	FROM ROUTINE
;	R0=	LIST HEAD	
;	R1=	SIZE
;	R2=	ADDR


	.MACRO	RETBUF	ADDRES,LENGTH
	.MCALL	NOTREG
	NOTREG	1,ADDRES
	NOTREG	2,LENGTH
	.IIF	DIF R1,LENGTH,	PUSH R1
	.IIF	DIF R2,ADDRES,	PUSH R2
	.IIF	DIF R1,LENGTH,	MOV	LENGTH,R1
	.IIF	DIF R2,ADDRES,	MOV	ADDRES,R2
	CALLX	RETBUF
	.IIF	DIF R2,ADDRES,	POP	R2
	.IIF	DIF R1,LENGTH,	POP	R1
	.ENDM	RETBUF



.SBTTL	CLRBUF	- CLEAR BUFFER

	.MACRO	CLRBUF	ADDRES,LENGTH
	.MCALL	NOTREG
	NOTREG	1,ADDRES
	NOTREG	0,LENGTH
	.IIF	DIF R0,ADDRES,	PUSH R0
	.IIF	DIF R1,LENGTH,	PUSH R1
	.IIF	DIF R0,ADDRES,	MOV	ADDRES,R0
	.IIF	DIF R1,LENGTH,	MOV	LENGTH,R1

	CALLX	CLRBUF

	.IIF	DIF R1,LENGTH,	POP	R1
	.IIF	DIF R0,ADDRES,	POP	R0
	.ENDM	CLRBUF



.SBTTL	GETDEV	- GET (ALLOCATE) DEVICE FOR SUBJOB

	.MACRO	GETDEV	ADDRES,LENGTH
	.MCALL	NOTREG
	NOTREG	1,ADDRES
	NOTREG	0,LENGTH
	.IIF	DIF R0,ADDRES,	PUSH R0
	.IIF	DIF R1,LENGTH,	PUSH R1
	.IIF	DIF R0,ADDRES,	MOV	ADDRES,R0
	.IIF	DIF R1,LENGTH,	MOV	LENGTH,R1

	CALLX	GETDEV

	.IIF	DIF R1,LENGTH,	POP	R1
	.IIF	DIF R0,ADDRES,	POP	R0
	.ENDM	GETDEV




.SBTTL	RETDEV	- RETURN (DEALLOCATE) DEVICE FOR SUBJOB

	.MACRO	RETDEV	ADDRES,LENGTH
	.MCALL	NOTREG
	NOTREG	1,ADDRES
	NOTREG	0,LENGTH
	.IIF	DIF R0,ADDRES,	PUSH R0
	.IIF	DIF R1,LENGTH,	PUSH R1
	.IIF	DIF R0,ADDRES,	MOV	ADDRES,R0
	.IIF	DIF R1,LENGTH,	MOV	LENGTH,R1

	CALLX	RETDEV

	.IIF	DIF R1,LENGTH,	POP	R1
	.IIF	DIF R0,ADDRES,	POP	R0
	.ENDM	RETDEV




.SBTTL	RETDAL	- RETURN (DEALLOCATE) ALL DEVICES FOR SUBJOB

	.MACRO	RETDAL
	CALLX	RETDAL
	.ENDM	RETDAL



.SBTTL	MOVSTR	- COPY A STRING

;
; ALL STRINGS ARE COUNTED ASCII (1ST BYTE = LENGTH)
;

	.MACRO	MOVSTR	SADR,DADR,LENGTH=<#10.>
	.MCALL	NOTREG

	NOTREG	1,SADR
	NOTREG	2,SADR
	NOTREG	0,DADR
	NOTREG	2,DADR
	NOTREG	0,LENGTH
	NOTREG	1,LENGTH

	.IF	DIF R0,SADR
	 PUSH  R0
	 MOV   SADR,R0
	.ENDC
	.IF	DIF R1,DADR
	 PUSH  R1
	 MOV   DADR,R1
	.ENDC
	.IF	DIF R2,LENGTH
	 PUSH  R2
	 MOV   LENGTH,R2
	.ENDC

	CALLX	MOVSTR

	.IIF	DIF R2,LENGTH	POP   R2
	.IIF	DIF R1,DADR	POP   R1
	.IIF	DIF R0,SADR	POP   R0

	.ENDM	MOVSTR

.SBTTL	CMPSTR	- COMPARE TWO STRINGS

;
; STRINGS ARE COUNTED ASCII (1ST BYTE = LENGTH)
;

	.MACRO	CMPSTR	SADR,DADR
	.MCALL	NOTREG
	NOTREG	0,DADR
	NOTREG	1,SADR
	.IIF	DIF R0,SADR,	PUSH R0
	.IIF	DIF R1,DADR,	PUSH R1
	.IIF	DIF R0,SADR,	MOV	SADR,R0
	.IIF	DIF R1,DADR,	MOV	DADR,R1
	CALLX	CMPSTR
	.IIF	DIF R1,DADR,	POP	R1
	.IIF	DIF R0,SADR	POP	R0
	.ENDM	CMPSTR

.SBTTL	SETPRV	- SET 3PP OF GIVEN PPN AND MASK

;
; R1=PPN AND R2->PRIV MASK FOR CALL TO SETPRV
;

	.MACRO	SETPRV,PPN=<#0>,PRIV=<R2>
	.MCALL	NOTREG
	 NOTREG	2,PPN
	 NOTREG	1,PRIV
	.IF	DIF R1,PPN
	 PUSH	R1
	.IF	DIF #0,PPN
	 MOV	PPN,R1
	.IFF
	 CLR	R1
	.ENDC
	.ENDC
	.IF	DIF R2,PRIV
	 PUSH	R2
	 MOV	PRIV,R2
	.ENDC
	 CALLX	SETPRV
	.IIF	DIF R2,PRIV	 POP	R2
	.IIF	DIF R1,PPN	 POP	R1
	.ENDM	SETPRV

.SBTTL	CHKPRV	- CHECK FOR PRIV ENABLED/DISABLED

;+
; The macro CHKPRV determines if the specified priv name
; is currently enabled or disabled.
;
; The format of the CHKPRV macro is
;
;	CHKPRV	PRVNAM[,PPN][,PRVMSK]
;
; where
;
;	PRVNAM	-> 6-char privilege name, starting on word
;		   boundary, padded with nulls.
;
;	PPN	=  PPN to be used for the privilege check.
;		   If this argument is not included or is 0,
;		   then no 3rd party privileges are used.
;
;	PRVMSK	-> 3rd party privilege mask to use.  If the
;		   PPN argument is not included or is 0, then
;		   this field is ignored.
;
; Returns:	C=0 if priv enabled.
;		C=1 if priv disabled or invalid priv name.
;
;-

	.MACRO	CHKPRV	PRVNAM,PPN=#0,PRVMSK=R2
	.MCALL	NOTREG
	NOTREG	1,PRVNAM
	NOTREG	2,PRVNAM
	NOTREG	0,PPN
	NOTREG	2,PPN
	NOTREG	0,PRVMSK
	NOTREG	1,PRVMSK
	.IF	DIF	PRVNAM,R0
	 PUSH	R0
	 MOV	PRVNAM,R0
	.ENDC
	.IF	DIF	PPN,R1
	 PUSH	R1
	 MOV	PPN,R1
	.ENDC
	.IF	DIF	PRVMSK,R2
	 PUSH	R2
	 MOV	PRVMSK,R2
	.ENDC
	 CALLX	CHKPRV
	.IF	DIF	PRVMSK,R2
	 POP	R2
	.ENDC
	.IF	DIF	PPN,R1
	 POP	R1
	.ENDC
	.IF	DIF	PRVNAM,R0
	 POP	R0
	.ENDC
	.ENDM	CHKPRV

.SBTTL	MUTEXC	- MUTUALLY EXCULSIVE MASK TESTING 

;
; IS THE MASK POINTED TO BY R1 A SUBSET OF THE MASK IN R2?
;

	.MACRO	MUTEXC,SET1,SET2,LENGTH
	.MCALL	NOTREG
	NOTREG	2,SET1
	NOTREG	3,SET1
	NOTREG	1,SET2
	NOTREG	3,SET2
	NOTREG	1,LENGTH
	NOTREG	2,LENGTH
	.IF	DIF R1,SET1
	 PUSH	R1
	 MOV	SET1,R1
	.ENDC
	.IF	DIF R2,SET2
	 PUSH	R2
	 MOV	SET2,R2
	.ENDC
	 PUSH	R3
	 MOV	LENGTH,R3
	 CALLX MUTEXC
	 POP	R3
	.IIF	DIF R2,SET2	 POP	R2
	.IIF	DIF R1,SET1	 POP	R1
	.ENDM	MUTEXC

.SBTTL	MOVBYT	- MOVE A BYTE INTO REGISTER

;+
; Define macro MOVBYT to move a byte from SRC to DST.
; If DST is a register, then a CLR DST followed by a
; BISB SRC,DST is performed to ensure that the high
; byte of the register is cleared.  Otherwise, the
; instruction MOVB SRC,DST is performed.
;-

	.MACRO	MOVBYT	SRC,DST
	.NTYPE	$$MODE,DST
	.IF EQ	$$MODE&70
	 CLR	DST
	 BISB	SRC,DST
	.IFF
	 MOVB	SRC,DST
	.ENDC
	.ENDM	MOVBYT

.SBTTL	EVEN	- MACRO TO ENSURE VALUE IS ON EVEN (WORD) BOUNDARY

	.MACRO	EVEN	ADDR
	 INC	ADDR			;ensure address starts
	 BIC	#1,ADDR			;on word boundary
	.ENDM	EVEN

.SBTTL	RECV	- MACRO TO RECEIVE LOCAL MESSAGE

;+
; The macro RECV is used to receive a local message.
; Note that the SNDR, QUAL and SLPTIM values are not
; used and are forced to zero.
;
; The format of the RECV macro is:
;
;		RECV	RIB[,BFR][,BLN][,MOD]
; where
;
;	RIB	is the receiver ID number.  This argument is
;		required.
;
;	BFR	is the address of the buffer to receive the message
;		If not present, then #0 is used.
;
;	BLN	is the length of the buffer to receive the message.
;		If not present, then #0 is used.
;
;	MOD	is the receiver modifier byte.  If not present, then
;		#0 is used.
;
;-

	.MACRO	RECV	RIB,BFR=#0,BLN=#0,MOD=#0
	 CALLX	CLRFQX			;clear FIRQB and XRB
	 MOVB	#2,@#FIRQB+FQFIL	;load receive subfun
	 MOVB	RIB,@#FIRQB+FQDEVN	;load rib_number
	.IF	DIF BFR,#0
	 MOV	BFR,XRB+XRLOC		;load buffer addr
	.ENDC
	.IF	DIF BLN,#0
	 MOV	BLN,XRB+XRLEN		;load buffer length
	.ENDC
	.IF	DIF MOD,#0
	 MOVB	MOD,@#FIRQB+FQSIZM	;load receive modifier
	.ENDC
	 .MESAG			;receive the message
	.ENDM	RECV

.SBTTL	REMV	- MACRO TO REMOVE RECEIVER

;+
; The macro REMV is used to remove a receiver.  Optionally, a
; RIB number and job number can be specified.
;
; The format of the REMV macro is:
;
;		REMV	[RIB][,JOB]
; where
;
;	RIB	is the RIB number of the receiver to remove.  If
;		not present, then all RIBs are removed.
;
;	JOB	is the job number times 2 of the job's RIB
;		to remove.  If not present, then only RIBs in
;		the caller's job are removed.
;
;-

	.MACRO	REMV	RIB=#0,JOB=#0
	 CALLX	CLRFQB			;clear FIRQB
;	 MOVB	#0,@#FIRQB+FQFIL	;load receive subfun
	.IF	DIF RIB,#0
	 MOVB	RIB,@#FIRQB+FQDEVN	;load rib_number
	.IFF
	 MOVB	#-1,@#FIRQB+FQDEVN+1	;load -1 to remove all ribs
	.ENDC
	.IF	DIF JOB,#0
	 MOVB	JOB,@#FIRQB+FQSIZM	;load job no. * 2
	.ENDC
	 .MESAG				;remove rib(s)
	.ENDM	REMV

.SBTTL	DCLR	- MACRO TO DECLARE RECEIVER

;+
; The macro DCLR is used to declare a receiver.  Note that the
; link maximum cannot be passed to this macro, and is always set
; to 0.
;
; The format of the DCLR macro is:
;
;		DCLR	NAM[,RIB][,LOT][,ACC][,MGX][,BFX]
; where
;
;	NAM	is a register containing the address of the
;		6-character receiver name.  An error is generated
;		if this argument is not a register.  This argument
;		is required.
;
;	RIB	is the RIB number of the receiver to declare.  If
;		not present, then the value #0 is used.
;
;	LOT	is the local object type.  If not present, then
;		the value #0 is used.
;
;	ACC	is the access control value.  If not present,
;		then the value #0 is used.
;
;	MGX	is the maximum number of messages to be queued.
;		If not present, then the value #20. is used.
;
;	BFX	is the maximum amount of XBUF to use.  If not
;		present, then the value #0. is used.
;
;-

	.MACRO	DCLR	NAM,RIB=#0,LOT=#0,ACC=#0,MGX=#20.,BFX=#0.
	.NTYPE $$MODE,NAM
	.IF	NE $$MODE&70
	.ERROR	NAM		;?Receiver name arg must be a register
	.MEXIT
	.ENDC
	 CALLX	CLRFQX			;clear FIRQB and XRB		;028
	 MOVB	#1,@#FIRQB+FQFIL	;load the declare subfun
	 MOV	(NAM),@#FIRQB+FQPPN+0	;load 1st 2 chars of name
	 MOV	2(NAM),@#FIRQB+FQPPN+2	;load next 2 chars of name
	 MOV	4(NAM),@#FIRQB+FQPPN+4	;load last 2 chars of name
	.IF	DIF RIB,#0
	 MOVB	RIB,@#FIRQB+FQDEVN	;load rib_number
	.ENDC
	.IF	DIF LOT,#0
	 MOVB	LOT,@#FIRQB+FQEXT	;load local object type
	.ENDC
	.IF	DIF ACC,#0
	 MOVB	ACC,@#FIRQB+FQEXT+1	;load access control byte
	.ENDC
	 MOVB	MGX,@#FIRQB+FQNAM2	;load message maximum
;	 MOVB	#0,@#FIRQB+FQNAM2+1	;load link maximum
	.IF	DIF BFX,#0
	 MOV	BFX,@#FIRQB+FQSIZ	;load buffer maximum
	.ENDC
	 .MESAG
	.ENDM	DCLR

.SBTTL	.ASCIC	- MACRO TO CREATE A COUNTED ASCII STRING

;+
; The .ASCIC macro creates a counted ASCII string.  A
; counted ASCII string consists of a one-byte character
; count, followed by the characters of the string.  The
; argument of .ASCIC must be in the format accepted by
; the .ASCII directive.
;-

	.MACRO	.ASCIC	STR
	.NCHR	$$LEN,<STR>
	 .BYTE	$$LEN
	 .ASCII	%STR%
	.ENDM	.ASCIC

.SBTTL	FIXSTG	- MACRO TO CREATE FIXED LENGTH TEXT STRING

;+
; The FIXSTG macro creates a fixed-length string, padded
; with nulls.  The length argument must be greater than or
; equal to the number of characters in the string.
;-

	.MACRO	FIXSTG	ARG,LEN
	.DSABL	CRF
$$$BEG	=	.
	 .BLKB0	LEN
$$$END	=	.
.	=	$$$BEG
	 .ASCII	ARG
.	=	$$$END
.ASSUME .-$$$BEG EQ LEN			;LENGTH MUST BE LEN CHRS
	.ENABL	CRF
	 .ENDM	FIXSTG

.SBTTL	LOT	- MACRO TO DEFINE LOCAL OBJECT TYPES FOR PBS RECEIVERS

;+
; The macro LOT is used to define the local object type
; for receivers declared in the BPS package.
;-

	.MACRO	LOT

; Define single-instance LOTs

LO.QMN	= 3.				;QMAN's PBSCMD receiver
LO.SRV	= 4.				;QMAN's server receiver
LO.URP	= 5.				;QMAN's URP receiver
LO.OMS	= 11.				;OMS's ORP receiver		;056

; Define multiple-instance LOTs

LO.PRT	= 101				;print servers' receiver
LO.BAT	= 102				;batch servers' receiver

	.ENDM	LOT

.SBTTL	FILL	- MACRO TO FILL BUFFER WITH CHAR ARG

;+
; The FILL macro is used to fill a specified buffer with a
; single character.
;-

	.MACRO	FILL	CHR,DST,LEN
	NOTREG	1,CHR
	NOTREG	2,CHR
	NOTREG	0,DST
	NOTREG	2,DST
	NOTREG	0,LEN
	NOTREG	1,LEN
	.IF	DIF	CHR,R0
	 PUSH	R0
	 MOVB	CHR,R0
	.ENDC
	.IF	DIF	DST,R1
	 PUSH	R1
	 MOV	DST,R1
	.ENDC
	.IF	DIF	LEN,R2
	 PUSH	R2
	 MOV	LEN,R2
	.ENDC
	 CALLX	FILL
	.IF	DIF	LEN,R2
	 POP	R2
	.ENDC
	.IF	DIF	DST,R1
	 POP	R1
	.ENDC
	.IF	DIF	CHR,R0
	 POP	R0
	.ENDC
	.ENDM	FILL

.SBTTL	SUBJOB	- MACRO TO DEFINE A SUBJOB

	.MACRO	SUBJOB	NME,ADDRES
	 .SAVE

	 .MCALL	SKDJDB,SKDSTA
	 SKDJDB
	 SKDSTA

	 .PSECT	NAMES

	$$$$$1	= .			;SAVE CURRENT POSITION
	 .NLIST	MEB
	 .BLKW0	2			;ALLOCATE ATLEASE 2 WORDS
	 .=$$$$$1			;BACK UP
	 .RAD50	/....../		;GIVE US A DEFAULT NAME
	 .LIST	MEB
	 .=$$$$$1			;BACK UP
	 .NCHR	$$$$$2,<NME>		;HOW LONG IS HIS NAME
	 .IF	GT $$$$$2-6. 		;IS IT MORE THAT 6. CHARS?
	 .ERROR	NAME -->NME<-- IS TOO LONG
	 .IFF
	 .RAD50	/NME/			;USE HIS NAME
	 .ENDC
	 . = $$$$$1+4			;NAME IS ONLY 2 WORD MAX

	 .PSECT	DISPAT
	 .WORD	ADDRES
	 .GLOBL	ADDRES

	 .PSECT	JDB
	 $$$$$1	= .
	 .WORD	RUNNOW!NORUN		;JOB STATUS WORD (INIT ME)
	 .WORD	0			;SLEEP TIMER WORD
	 JDBSZ	= . -$$$$$1

	 .RESTORE
	.ENDM	SUBJOB

.SBTTL	XMIT	- MACRO TO QUEUE A MAPPED ASYNC SEND/BROADCAST MESSAGE

	.MACRO	XMIT	XMT.BLK
	.IIF	DIF R0,XMT.BLK,	 PUSH R0
	.IIF	DIF R0,XMT.BLK,	 MOV	XMT.BLK,R0
	 CALLX	XMITQ
	.IIF	DIF R0,XMT.BLK,	 POP R0
	.ENDM	XMIT




.SBTTL	XMITM	- QUEUE UP AN UNMAPPED ASYNC SEND OR BROADCASE MESSAGE

	.MACRO	XMITM	XMT.BLK
	.IIF	DIF R0,XMT.BLK,	 PUSH R0
	.IIF	DIF R0,XMT.BLK,	 MOV	XMT.BLK,R0
	 CALLX	XMITQM
	.IIF	DIF R0,XMT.BLK,	 POP R0
	.ENDM	XMITM



.SBTTL	REJECT	- MACRO TO REJECT STATE TRANSITION

;+
; This macro is used to reject a state transition in the message
; state process.  register REG points to the affected spooler
; definition block.  this macro moves the old (previous) state
; back to the current state.
;-

	.MACRO	REJECT	REG
	 MOV	SP.OSTA(REG),SP.STA(REG) ;MAKE THE OLD STATE THE CURRENT STATE
	.ENDM	REJECT

.SBTTL	SPLMAC	- MACRO TO DEFINE FUNCTION DISPATCH-RELATED MACROS


;+
; Function dispatch-related macros:
;
;	SPLSTA
;		Used to initialize the begining of the
;		function list
;
;	SPLFUN	NAME,ADDR,SET
;		Used to declare a member of the activity list
;		NAME is the symbolic used later to turn on this
;		function. ADDR is the address of this function.
;		SET, if specified will cause this  routine to
;		be turned on initially at assembly time.
;
;	SPLEND
;		Terminates the activity list.
;
;	SETFUN	FUNC,REG
;		Used by any routine to turn on a function.
;		FUNC is the name of the function used in the
;		splfun macro. REG is a register pointing at
;		the begining of the dispatch bits list.
;
;	CLRFUN	FUNC,REG
;		Reverse of SETFUN, i.e. clears the specified
;		function.
;-

.SBTTL	SPLSTA	- MACRO TO DEFINE START OF FUNCTION DISPATCH TABLE


	.MACRO	SPLSTART
	 .SAVE
	 .PSECT	$DSPAT,RO,CON
	 $DSPAT:
	 .PSECT	$DSBIT,RO,CON
	 $DSBIT:
	 $$$VAL=0
	 $$$BIT=1
	 $DSMAX=0
	.ENDM	SPLSTA




.SBTTL	SPLEND	- DEFINE END OF SPOOLER DISPATCH TABLE

	.MACRO	SPLEND
	 .DSABL CRF
	 .PSECT	$DSBIT
	 .IIF	NE $$$BIT-1	.WORD $$$VAL
	 $DSBYT=.-$DSBIT
	 .RESTORE
	 .ENABL CRF
	.ENDM	SPLEND


.SBTTL	SPLFUN	- MACRO TO DEFINE ENTRY IN FUNCTION DISPATCH TABLE

	.MACRO	SPLFUN	NAME,ADDR,SET
	 .DSABL CRF
	 .IIF	NB <SET>  $$$VAL=$$$VAL!$$$BIT
	 $$$BIT=$$$BIT+$$$BIT
	 .PSECT	$DSPAT
	 .IIF	NDF	ADDR	GLOBAL	<ADDR>
	 .WORD	ADDR
	 NAME=:<<.-$DSPAT>/2>
	 $DSMAX=$DSMAX+1
	 .IF	EQ $$$BIT
	  .PSECT	$DSBIT
	  .WORD	$$$VAL
	  $$$BIT=1
	  $$$VAL=0
	 .ENDC
	 .ENABL CRF
	.ENDM	SPLFUN

.SBTTL	SETFUN	- MACRO TO SET A FUNCTION REQUEST IN DISPATCH TABLE


	.MACRO	SETFUN	FUNC,REG
	 $OFFST=<<FUNC-1>/16.>*2
	 $BIT=FUNC-<16.*$OFFST/2>-1
	 $$BIT=1
	 .REPT	$BIT
	 $$BIT=$$BIT+$$BIT
	 .ENDR
	 .IF	NB <REG>
	  .IF	EQ $OFFST
	    BIS	#$$BIT,(REG)
	  .IFF
	   BIS	#$$BIT,$OFFST(REG)
	  .ENDC
	 .IFF
	 BIS	#$$BIT,$OFFST+$DSBIT
	.ERROR ;THIS MAY NOT WORK
	.ENDC
	.ENDM	SETFUN

.SBTTL	CLRFUN	- MACRO TO CLEAR A FUNCTION REQUEST IN DISPATCH TABLE

	.MACRO	CLRFUN	FUNC,REG
	 $OFFST=<<FUNC-1>/16.>*2
	 $BIT=FUNC-<16.*$OFFST/2>-1
	 $$BIT=1
	 .REPT	$BIT
	 $$BIT=$$BIT+$$BIT
	 .ENDR
	 .IF	NB <REG>
	  .IF	EQ $OFFST
	    BIC	#$$BIT,(REG)
	  .IFF
	   BIC	#$$BIT,$OFFST(REG)
	  .ENDC
	 .IFF
	 BIS	#$$BIT,$OFFST+$DSBIT
	.ERROR ;THIS MAY NOT WORK
	.ENDC
	.ENDM	CLRFUN

.SBTTL	SPLCMD	- MACRO TO DEFINE THE USER/QMAN/SPLER COMMAND VALUES

	.MACRO	SPLCMD

	.SAVE
	.MCALL	ALLCMD

;
; DEFINE COMMAND VALUES FOR USER -> QMAN MESSAGE PROTOCAL
;

	.DSECT	,CREF
UQ.NOP:	.BLKB		;  0 = NO-OP command
UQ.BPT:	.BLKB		;  1 = BREAKPOINT TRAP command
UQ.STA:	.BLKB		;  2 = STATUS REQUEST command
	.BLKB		;  3 = STATUS RESPONSE command
	.BLKB		;  4 = STATUS UPDATE command
	.BLKB		;  5 = ACKNOWLEDGEMENT command
	.BLKB		;  6 = NEG-ACKNOWLEDGEMENT command
UQ.PDV:	.BLKB		;  7 = PAUSE SERVER command
UQ.CDV:	.BLKB		; 10 = CONTINUE SERVER command
UQ.JOB:	.BLKB		; 11 = DEFINE ENTRY command
UQ.MOD:	.BLKB		; 12 = MODIFY ENTRY command
UQ.KIL:	.BLKB		; 13 = KILL ENTRY command
	.BLKB		; 14 = END OF ENTRY command
UQ.FNT:	.BLKB		; 15 = DEFINE FONT command
	.BLKB		; 16 = ON-LINE command
	.BLKB		; 17 = ON-LINE CONFIRM command
UQ.OFL:	.BLKB		; 20 = OFF-LINE command
	.BLKB		; 21 = SYNCH ERROR command
UQ.IDV:	.BLKB		; 22 = INITIALIZE SERVER command
UQ.MSR:	.BLKB		; 23 = MODIFY SERVER command
UQ.DDV:	.BLKB		; 24 = DELETE SERVER command
UQ.IQU:	.BLKB		; 25 = INITIALIZE QUEUE command
UQ.MQU:	.BLKB		; 26 = MODIFY QUEUE command
UQ.DQU:	.BLKB		; 27 = DELETE QUEUE command
UQ.PQU:	.BLKB		; 30 = PAUSE QUEUE command
UQ.CQU:	.BLKB		; 31 = CONTINUE QUEUE command
UQ.AQU:	.BLKB		; 32 = ASSIGN QUEUE command
UQ.DSQ:	.BLKB		; 33 = DEASSIGN QUEUE command
UQ.MAX:			; FIRST ILLEGAL COMMAND

;
; DEFINE COMMAND VALUES FOR USER <- QMAN MESSAGE PROTOCAL
;

	.DSECT	,CREF
QU.NOP:	.BLKB		;  0 = NO-OP command
	.BLKB		;  1 = BREAKPOINT TRAP command
	.BLKB		;  2 = STATUS REQUEST command
QU.RSP:	.BLKB		;  3 = STATUS RESPONSE command
	.BLKB		;  4 = STATUS UPDATE command
QU.ACK:	.BLKB		;  5 = ACKNOWLEDGEMENT command
QU.NCK:	.BLKB		;  6 = NEG-ACKNOWLEDGEMENT command
	.BLKB		;  7 = PAUSE SERVER command
	.BLKB		; 10 = CONTINUE SERVER command
	.BLKB		; 11 = DEFINE ENTRY command
	.BLKB		; 12 = MODIFY ENTRY command
	.BLKB		; 13 = KILL ENTRY command
	.BLKB		; 14 = END OF ENTRY command
	.BLKB		; 15 = DEFINE FONT command
	.BLKB		; 16 = ON-LINE command
	.BLKB		; 17 = ON-LINE CONFIRM command
	.BLKB		; 20 = OFF-LINE command
	.BLKB		; 21 = SYNCH ERROR command
	.BLKB		; 22 = INITIALIZE SERVER command
	.BLKB		; 23 = MODIFY SERVER command
	.BLKB		; 24 = DELETE SERVER command
	.BLKB		; 25 = INITIALIZE QUEUE command
	.BLKB		; 26 = MODIFY QUEUE command
	.BLKB		; 27 = DELETE QUEUE command
	.BLKB		; 30 = PAUSE QUEUE command
	.BLKB		; 31 = CONTINUE QUEUE command
	.BLKB		; 32 = ASSIGN QUEUE command
	.BLKB		; 33 = DEASSIGN QUEUE command
QU.MAX:			; FIRST ILLEGAL COMMAND

;
; DEFINE COMMAND VALUES FOR QMAN -> SPLR MESSAGE PROTOCAL
;

	.DSECT	,CREF
QS.NOP:	.BLKB		;  0 = NO-OP command
QS.BPT:	.BLKB		;  1 = BREAKPOINT TRAP command
QS.STA:	.BLKB		;  2 = STATUS REQUEST command
	.BLKB		;  3 = STATUS RESPONSE command
	.BLKB		;  4 = STATUS UPDATE command
QS.ACK:	.BLKB		;  5 = ACKNOWLEDGEMENT command
QS.NCK:	.BLKB		;  6 = NEG-ACKNOWLEDGEMENT command
QS.PDV:	.BLKB		;  7 = PAUSE SERVER command
QS.CDV:	.BLKB		; 10 = CONTINUE SERVER command
QS.JOB:	.BLKB		; 11 = DEFINE ENTRY command
QS.MOD:	.BLKB		; 12 = MODIFY ENTRY command
QS.KIL:	.BLKB		; 13 = KILL ENTRY command
	.BLKB		; 14 = END OF ENTRY command
QS.FNT:	.BLKB		; 15 = DEFINE FONT command
	.BLKB		; 16 = ON-LINE command
QS.ONC:	.BLKB		; 17 = ON-LINE CONFIRM command
QS.OFL:	.BLKB		; 20 = OFF-LINE command
QS.SYN:	.BLKB		; 21 = SYNCH ERROR command
QS.IDV:	.BLKB		; 22 = INITIALIZE SERVER command
	.BLKB		; 23 = MODIFY SERVER command
	.BLKB		; 24 = DELETE SERVER command
	.BLKB		; 25 = INITIALIZE QUEUE command
	.BLKB		; 26 = MODIFY QUEUE command
	.BLKB		; 27 = DELETE QUEUE command
	.BLKB		; 30 = PAUSE QUEUE command
	.BLKB		; 31 = CONTINUE QUEUE command
	.BLKB		; 32 = ASSIGN QUEUE command
	.BLKB		; 33 = DEASSIGN QUEUE command
QS.MAX:			; FIRST ILLEGAL COMMAND

;
; DEFINE COMMAND VALUES FOR QMAN <- SPLR MESSAGE PROTOCAL
;

	.DSECT	,CREF
SQ.NOP:	.BLKB		;  0 = NO-OP command
	.BLKB		;  1 = BREAKPOINT TRAP command
	.BLKB		;  2 = STATUS REQUEST command
SQ.RSP:	.BLKB		;  3 = STATUS RESPONSE command
SQ.STU:	.BLKB		;  4 = STATUS UPDATE command
SQ.ACK:	.BLKB		;  5 = ACKNOWLEDGEMENT command
SQ.NCK:	.BLKB		;  6 = NEG-ACKNOWLEDGEMENT command
	.BLKB		;  7 = PAUSE SERVER command
	.BLKB		; 10 = CONTINUE SERVER command
	.BLKB		; 11 = DEFINE ENTRY command
	.BLKB		; 12 = MODIFY ENTRY command
	.BLKB		; 13 = KILL ENTRY command
SQ.EOJ:	.BLKB		; 14 = END OF ENTRY command
	.BLKB		; 15 = DEFINE FONT command
SQ.ONL:	.BLKB		; 16 = ON-LINE command
	.BLKB		; 17 = ON-LINE CONFIRM command
SQ.OFL:	.BLKB		; 20 = OFF-LINE command
SQ.SYN:	.BLKB		; 21 = SYNCH ERROR command
	.BLKB		; 22 = INITIALIZE SERVER command
	.BLKB		; 23 = MODIFY SERVER command
	.BLKB		; 24 = DELETE SERVER command
	.BLKB		; 25 = INITIALIZE QUEUE command
	.BLKB		; 26 = MODIFY QUEUE command
	.BLKB		; 27 = DELETE QUEUE command
	.BLKB		; 30 = PAUSE QUEUE command
	.BLKB		; 31 = CONTINUE QUEUE command
	.BLKB		; 32 = ASSIGN QUEUE command
	.BLKB		; 33 = DEASSIGN QUEUE command
SQ.MAX:			; FIRST ILLEGAL COMMAND

	ALLCMD

	.RESTORE

;
; RE-DEFINE SPLCMD MACRO AS NULL
;

	.MACRO	SPLCMD
	.ENDM

	.ENDM	SPLCMD

.SBTTL	ALLCMD	- DEFINE ALL THE PACKET OFFSETS

	.MACRO	ALLCMD

	.SAVE

;
; DEFINE PACKET OFFSETS FOR FIXED HEADER BLOCK
;

	.DSECT	,NOCREF
HD.FLG:	.BLKB			; RESERVED (FLAG)
HD.VER:	.BLKB			; PROTOCAL VERSION
HD.CID:	.BLKW			; CONNECT ID
HD.RTQ:	.BLKB			; RETURN ADDR FLAG
HD.CMD:	.BLKB			; COMMAND
HD.RTN:	.BLKW	3		; RETURN ADDR
HD.CTX:	.BLKW			; SENDER CONTEXT
HD.LEN:				; HEADER LENGTH

;
; DEFINE PACKET OFFSETS FOR NO-OP (NP) COMMAND (#0)
;

	.DSECT	,NOCREF
NP.LEN:				; PACKET LENGTH

;
; DEFINE PACKET OFFSETS FOR BREAKPOINT TRAP (BP) COMMAND (#1)
;

	.DSECT	,NOCREF
BP.LEN:				; PACKET LENGTH

;
; DEFINE PACKET OFFSETS FOR STATUS REQUEST (ST) COMMAND (#2)
;

	.DSECT	,NOCREF
ST.LEN:

;
; DEFINE PACKET OFFSETS FOR STATUS RESPONSE (SR) COMMAND (#3)
;

	.DSECT	,NOCREF
SR.LEN:				; PACKET LENGTH

;
; DEFINE PACKET OFFSETS FOR STATUS UPDATE (SU) COMMAND (#4)
;

	.DSECT	,NOCREF
SU.SEQ:	.BLKW			; RESERVED ( SEQUENCE NUMBER )		;056
SU.QUE:	.BLKB			; QUEUE TYPE
	.BLKB			; RESERVED ( IPR )
	.BLKW			; RESERVED ( EDA )
	.BLKW			; RESERVED ( ETI )
	.BLKW			; RESERVED ( AFD )
	.BLKW			; RESERVED ( AFT )
SU.STS:	.BLKW			; STATUS
SU.FLG:	.BLKW			; FLAGS
SU.QNL:	.BLKB			; Length of queue name			;056
SU.QNM:	.BLKB	NAM.LEN		; Name of queue for entry		;056
SU.NML:	.BLKB			; Length of entry name			;056
SU.NAM:	.BLKB	NAM.LEN		; Entry name				;056
SU.DVL:	.BLKB			; Length of server name			;056
SU.DEV:	.BLKB	NAM.LEN		; Name of server processing entry	;056
SU.PPN:	.WORD			; Project/Programmer number of owner	;056
SU.LEN:				; PACKET LENGTH

;
; DEFINE PACKET OFFSETS FOR ACKNOWLEDGEMENT (AK) COMMAND (#5)
;

	.DSECT	,NOCREF
AK.SEQ:	.BLKW			; SEQUENCE NUMBER
AK.QUE:	.BLKB			; QUEUE TYPE
	.BLKB			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
AK.STS:	.BLKW			; STATUS
AK.FLG:	.BLKW			; FLAGS
AK.QNL:	.BLKB			; Length of queue name			;056
AK.QNM:	.BLKB	NAM.LEN		; Name of queue for entry		;056
AK.LEN:				; PACKET LENGTH		* Historical *	;056
AK.NML:	.BLKB			; Length of entry name			;056
AK.NAM:	.BLKB	NAM.LEN		; Entry name				;056
AK.DVL:	.BLKB			; Length of server name			;056
AK.DEV:	.BLKB	NAM.LEN		; Name of server processing entry	;056
AK.PPN:	.WORD			; Project/Programmer number of owner	;056
AK.LN2:				; Packet length (For spooler acks)	;056

;
; DEFINE PACKET OFFSETS FOR NEG-ACKNOWLEDGEMENT (NK) COMMAND (#6)
;

	.DSECT	,NOCREF
NK.SEQ:	.BLKW			; SEQUENCE NUMBER
NK.QUE:	.BLKB			; QUEUE TYPE
	.BLKB			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
NK.STS:	.BLKW			; STATUS
NK.FLG:	.BLKW			; FLAGS
NK.LEN:				; PACKET LENGTH

;
; DEFINE PACKET OFFSETS FOR PAUSE SERVER (PD) COMMAND (#7)
;

	.DSECT	,NOCREF
PD.SEQ:	.BLKW			; SEQUENCE NUMBER
PD.QUE:	.BLKB			; QUEUE TYPE
	.BLKB			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
PD.STS:	.BLKW			; STATUS
PD.FLG:	.BLKW			; FLAGS
PD.DVL:	.BLKB			; SERVER NAME LENGTH
PD.DEV:	.BLKB	NAM.LEN		; SERVER NAME
PD.LEN:				; PACKET LENGTH

;
; DEFINE PACKET OFFSETS FOR CONTINUE SERVER (CD) COMMAND (#10)
;

	.DSECT	,NOCREF
CD.SEQ:	.BLKW			; SEQUENCE NUMBER
CD.QUE:	.BLKB			; QUEUE TYPE
	.BLKB			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
CD.STS:	.BLKW			; STATUS
CD.FLG:	.BLKW			; FLAGS
CD.DVL:	.BLKB			; SERVER NAME LENGTH
CD.DEV:	.BLKB	NAM.LEN		; SERVER NAME
CD.PG0:	.BLKW			; RESTART PAGE NUMBER (LSB)
CD.PG1:	.BLKW			; RESTART PAGE NUMBER (MSB)
CD.LEN:				; PACKET LENGTH

;
; DEFINE PACKET OFFSETS FOR DEFINE ENTRY (JB) COMMAND (#11)
;

	.DSECT	,NOCREF
JB.SEQ:	.BLKW			; SEQUENCE NUMBER
JB.QUE:	.BLKB			; QUEUE TYPE
JB.IPR:	.BLKB			; INTERNAL PRIORITY
JB.EDA:	.BLKW			; ENTRY DATE
JB.ETI:	.BLKW			; ENTRY TIME
JB.AFT:	.BLKW			; INTERNAL AFTER TIME
JB.AFD:	.BLKW			; INTERNAL AFTER DATE
JB.STS:	.BLKW			; STATUS
JB.FLG:	.BLKW			; FLAGS
JB.QNL:	.BLKB			; QUEUE NAME LENGTH
JB.QNM:	.BLKB	NAM.LEN		; QUEUE NAME
JB.NML:	.BLKB			; ENTRY NAME LENGTH
JB.NAM:	.BLKB	NAM.LEN		; ENTRY NAME
JB.PRI:	.BLKB			; PRIORITY
	.BLKB			; (RESERVED)
JB.PGL:				; PAGE LIMIT ( PRINT ENTRIES )
JB.CPU:	.BLKW			; CPU LIMIT  ( BATCH ENTRIES )
JB.PGM:				; PAGE (MSW) ( PRINT ENTRIES )
JB.TIM:	.BLKW			; TIME LIMIT ( BATCH ENTRIES )
JB.PPN:	.BLKW			; PPN
JB.PRV:	.BLKW	4.		; ENTRY PRIVILEGE MASK
JB.CHR:	.BLKW			; ENTRY CHARACTERISTICS
JB.LOG:				; OFFSET TO LOG FILESPEC ( BATCH ENTRIES )
JB.COP:	.BLKW			; JOB COPIES
JB.QSQ:	.BLKW			; QUEUE SEQ NO
JB.MDA:	.BLKW			; MODIFIED DATE
JB.MTI:	.BLKW			; MODIFIED TIME
JB.ADA:	.BLKW			; AFTER DATE
JB.ATI:	.BLKW			; AFTER TIME
JB.SDA:	.BLKW			; START DATE
JB.STI:	.BLKW			; START TIME
JB.FDA:	.BLKW			; FINISH DATE
JB.FTI:	.BLKW			; FINISH TIME
JB.DVL:	.BLKB			; SERVER NAME LENGTH
JB.DEV:	.BLKB	NAM.LEN		; SERVER NAME
JB.FML:	.BLKB			; FORM NAME LENGTH
JB.FRM:	.BLKB	NAM.LEN		; FORM NAME
JB.DCH:	.BLKW			; SERVER CHARACTERISTICS
JB.PKN:				; BATCH PK NUMBER
JB.JHD:	.BLKB			; NO. JOB HEADERS
JB.JTR:	.BLKB			; NO. JOB TRAILERS
JB.RPR:				; JOB RUN PRIORITY ( BATCH ENTRIES )
JB.FHD:	.BLKB			; NO. FILE HEADERS
JB.RBR:				; JOB RUN BURST ( BATCH ENTRIES )
JB.FTR:	.BLKB			; NO. FILE TRAILERS
JB.LNG:	.BLKB			; FORM LENGTH
JB.WID:	.BLKB			; FORM WIDTH
JB.BOM:	.BLKB			; Form bottom margin			;051
JB.TOM:	.BLKB			; Form top margin			;051
JB.LEM:	.BLKB			; Form left margin			;051
JB.RIM:	.BLKB			; Form right margin			;051
	.EVEN
JB.FIL:	.BLKW			; OFFSET TO 1ST FILESPEC BLOCK
JB.SET:
JB.PAR:	.BLKW			; OFFSET TO PARAMETER/SETUP BLOCK
JB.LEN:				; FIXED PACKET LENGTH

;
; DEFINE PACKET OFFSETS FOR MODIFY ENTRY (MD) COMMAND (#12)
;

	.DSECT	,NOCREF
MD.SEQ:	.BLKW			; SEQUENCE NUMBER
MD.QUE:	.BLKB			; QUEUE TYPE
MD.IPR:	.BLKB			; INTERNAL PRIORITY
MD.EDA:	.BLKW			; ENTRY DATE
MD.ETI:	.BLKW			; ENTRY TIME
MD.AFT:	.BLKW			; INTERNAL AFTER TIME
MD.AFD:	.BLKW			; INTERNAL AFTER DATE
MD.STS:	.BLKW			; STATUS
MD.FLG:	.BLKW			; FLAGS
MD.QNL:	.BLKB			; QUEUE NAME LENGTH
MD.QNM:	.BLKB	NAM.LEN		; QUEUE NAME
MD.NML:	.BLKB			; ENTRY NAME LENGTH
MD.NAM:	.BLKB	NAM.LEN		; ENTRY NAME
MD.PRI:	.BLKB			; PRIORITY
	.BLKB			; RESERVED
MD.PGL:				; PAGE LIMIT ( PRINT ENTRIES )
MD.CPU:	.BLKW			; CPU LIMIT  ( BATCH ENTRIES )
MD.PGM:				; PAGE (MSW) ( PRINT ENTRIES )
MD.TIM:	.BLKW			; TIME LIMIT ( BATCH ENTRIES )
MD.PPN:	.BLKW			; PPN
MD.PRV:	.BLKW	4.		; ENTRY PRIVILEGE MASK
MD.CHR:	.BLKW			; CHARACTERISTICS
MD.LOG:				; OFFSET TO LOG FILE SPEC ( BATCH ENTRIES )
MD.COP:	.BLKW			; JOB COPIES
MD.QSQ:	.BLKW			; QUEUE SEQ NO
MD.MDA:	.BLKW			; MODIFIED DATE
MD.MTI:	.BLKW			; MODIFIED TIME
MD.ADA:	.BLKW			; AFTER DATE
MD.ATI:	.BLKW			; AFTER TIME
MD.SDA:	.BLKW			; START DATE
MD.STI:	.BLKW			; START TIME
MD.FDA:	.BLKW			; FINISH DATE
MD.FTI:	.BLKW			; FINISH TIME
MD.DVL:	.BLKB			; SERVER NAME LENGTH
MD.DEV:	.BLKB	NAM.LEN		; SERVER NAME
MD.FML:	.BLKB			; FORM NAME LENGTH
MD.FRM:	.BLKB	NAM.LEN		; FORM NAME
MD.DCH:	.BLKW			; SERVER CHARACTERISTICS
MD.PKN:				; PSUEDO KEYBOARD NUM ( BATCH )
MD.JHD:	.BLKB			; NO. JOB HEADERS ( PRINT )
MD.JTR:	.BLKB			; NO. JOB TRAILERS ( PRINT )
MD.RPR:				; JOB RUN PRIORITY ( BATCH )
MD.FHD:	.BLKB			; NO. FILE HEADERS ( PRINT )
MD.FTR:	.BLKB			; NO. FILE TRAILERS ( PRINT )
MD.RBR:				; JOB RUN BURST  ( BATCH )
MD.LNG:	.BLKB			; FORM LENGTH ( PRINT )
MD.WID:	.BLKB			; FORM WIDTH ( PRINT )
MD.BOM:	.BLKB			; Form bottom margin 			;051
MD.TOM:	.BLKB			; Form top margin			;051
MD.LEM:	.BLKB			; Form left margin			;051
MD.RIM:	.BLKB			; Form right margin			;051
	.EVEN
MD.FIL:	.BLKW			; OFFSET TO 1ST FILESPEC BLOCK
MD.PAR:				; OFFSET TO PARAMETER BLOCK
MD.SET:	.BLKW			; OFFSET TO SETUP BLOCK
MD.LEN:				; FIXED PACKET LENGTH

;
; DEFINE PACKET OFFSETS FOR KILL ENTRY (KL) COMMAND (#13)
;

	.DSECT	,NOCREF
KL.SEQ:	.BLKW			; SEQUENCE NUMBER
KL.QUE:	.BLKB			; QUEUE TYPE
	.BLKB			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
KL.STS:	.BLKW			; STATUS
KL.FLG:	.BLKW			; FLAGS
KL.LEN:				; PACKET LENGTH

;
; DEFINE PACKET OFFSETS FOR END-OF-ENTRY (EJ) COMMAND (#14)
;

	.DSECT	,NOCREF
EJ.SEQ:	.BLKW			; SEQUENCE NUMBER
EJ.QUE:	.BLKB			; QUEUE TYPE
	.BLKB			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
EJ.STS:	.BLKW			; STATUS
EJ.FLG:	.BLKW			; FLAGS
EJ.QNL:	.BLKB			; Length of queue name			;056
EJ.QNM:	.BLKB	NAM.LEN		; Name of queue for entry		;056
EJ.NML:	.BLKB			; Length of entry name			;056
EJ.NAM:	.BLKB	NAM.LEN		; Entry name				;056
EJ.DVL:	.BLKB			; Length of server name			;056
EJ.DEV:	.BLKB	NAM.LEN		; Name of server processing entry	;056
EJ.PPN:	.WORD			; Project/Programmer number of owner	;056
EJ.AC0:	.BLKW			; ACCOUNTING (LSB) (* Currently unused *)
EJ.AC1:	.BLKW			; ACCOUNTING (MSB) (* Currently unused *)
EJ.LEN:				; PACKET LENGTH

;
; DEFINE PACKET OFFSETS FOR FONT DEFINITION (FT) COMMAND (#15)
;

	.DSECT	,NOCREF
FT.LEN:	.BLKW			; FIXED PACKET LENGTH

;
; DEFINE PACKET OFFSETS FOR ON-LINE (ON) COMMAND (#16)
;

	.DSECT	,NOCREF
ON.SEQ:	.BLKW			; RESERVED
ON.QUE:	.BLKB			; QUEUE TYPE
	.BLKB			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
ON.STS:	.BLKW			; STATUS
ON.FLG:	.BLKW			; FLAGS
ON.RCL:	.BLKB			; RCVR NAME LENGTH
ON.RCV:	.BLKB	NAM.LEN		; RCVR NAME
ON.LEN:				; PACKET LENGTH

;
; DEFINE PACKET OFFSETS FOR ON-LINE CONFIRM (OC) COMMAND (#17)
;

	.DSECT	,NOCREF
OC.SEQ:	.BLKW			; RESERVED
OC.QUE:	.BLKB			; QUEUE TYPE
	.BLKB			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
OC.STS:	.BLKW			; STATUS
OC.FLG:	.BLKW			; FLAGS
OC.LEN:				; PACKET LENGTH

;
; DEFINE PACKET OFFSETS FOR OFF-LINE (OF) COMMAND (#20)
;

	.DSECT	,NOCREF
OF.SEQ:	.BLKW			; RESERVED
OF.QUE:	.BLKB			; QUEUE TYPE
	.BLKB			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
OF.STS:	.BLKW			; STATUS
OF.FLG:	.BLKW			; FLAGS
OF.LEN:				; PACKET LENGTH

;
; DEFINE PACKET OFFSETS FOR SYNCH ERROR (SY) COMMAND (#21)
;

	.DSECT	,NOCREF
SY.LEN:				; PACKET LENGTH

;
; DEFINE PACKET OFFSETS FOR INITIALIZE SERVER (ID) COMMAND (#22)
;

	.DSECT	,NOCREF
ID.SEQ:	.BLKW			; SEQUENCE NUMBER
ID.QUE:	.BLKB			; QUEUE TYPE
	.BLKB			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
ID.STS:	.BLKW			; STATUS
ID.FLG:	.BLKW			; FLAGS
ID.DVL:	.BLKB			; SERVER NAME LENGTH
ID.DEV:	.BLKB	NAM.LEN		; SERVER NAME
ID.FML:	.BLKB			; FORM NAME LENGTH
ID.FRM:	.BLKB	NAM.LEN		; FORM NAME
ID.CHR:	.BLKW			; SERVER CHARACTERISTICS
ID.JHD:	.BLKB			; NO. JOB HEADERS
ID.JTR:	.BLKB			; NO. JOB TRAILERS
ID.RPR:				;    RUN PRIORITY
ID.FHD:	.BLKB			; NO. FILE HEADERS
ID.RBR:				;    RUN BURST
ID.FTR:	.BLKB			; NO. FILE TRAILERS
ID.LNG:	.BLKB			; FORM LENGTH
ID.WID:	.BLKB			; FORM WIDTH
ID.BOM:	.BLKB			; Form bottom margin			;051
ID.TOM:	.BLKB			; Form top margin			;051
ID.LEM:	.BLKB			; Form left margin			;051
ID.RIM:	.BLKB			; Form right margin			;051
	.EVEN
ID.LEN:				; PACKET LENGTH

;
; DEFINE PACKET OFFSETS FOR MODIFY SERVER (MS) COMMAND (#23)
;

	.DSECT	,NOCREF
MS.SEQ:	.BLKW			; SEQUENCE NUMBER
MS.QUE:	.BLKB			; QUEUE TYPE
	.BLKB			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
MS.STS:	.BLKW			; STATUS
MS.FLG:	.BLKW			; FLAGS
MS.DVL:	.BLKB			; SERVER NAME LENGTH
MS.DEV:	.BLKB	NAM.LEN		; SERVER NAME
MS.FML:	.BLKB			; FORM NAME LENGTH
MS.FRM:	.BLKB	NAM.LEN		; FORM NAME
MS.CHR:	.BLKW			; SERVER CHARACTERISTICS
MS.JHD:	.BLKB			; NO. JOB HEADERS
MS.JTR:	.BLKB			; NO. JOB TRAILERS
MS.FHD:	.BLKB			; NO. FILE HEADERS
MS.FTR:	.BLKB			; NO. FILE TRAILERS
MS.LNG:	.BLKB			; FORM LENGTH
MS.WID:	.BLKB			; FORM WIDTH
MS.BOM:	.BLKB			; Form bottom margin			;051
MS.TOM:	.BLKB			; Form top margin			;051
MS.LEM:	.BLKB			; Form left margin			;051
MS.RIM:	.BLKB			; Form right margin			;051
	.EVEN
MS.LEN:				; PACKET LENGTH

;
; DEFINE PACKET OFFSETS FOR DELETE SERVER (DD) COMMAND (#24)
;

	.DSECT	,NOCREF
DD.SEQ:	.BLKW			; SEQUENCE NUMBER
DD.QUE:	.BLKB			; QUEUE TYPE
	.BLKB			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
DD.STS:	.BLKW			; STATUS
DD.FLG:	.BLKW			; FLAGS
DD.DVL:	.BLKB			; SERVER NAME LENGTH
DD.DEV:	.BLKB	NAM.LEN		; SERVER NAME
DD.LEN:				; PACKET LENGTH

;
; DEFINE PACKET OFFSETS FOR INITIALIZE QUEUE (IQ) COMMAND (#25)
;

	.DSECT	,NOCREF
IQ.SEQ:	.BLKW			; SEQUENCE NUMBER
IQ.QUE:	.BLKB			; QUEUE TYPE
	.BLKB			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
IQ.STS:	.BLKW			; STATUS
IQ.FLG:	.BLKW			; FLAGS
IQ.QNL:	.BLKB			; QUEUE NAME LENGTH
IQ.QNM:	.BLKB	NAM.LEN		; QUEUE NAME
IQ.FML:	.BLKB			; FORM NAME LENGTH
IQ.FRM:	.BLKB	NAM.LEN		; FORM NAME
IQ.DPR:	.BLKB			; DEFAULT PRIORITY
	.BLKB			; RESERVED
IQ.DP0:				; DEFAULT PAGE LIMIT (PRINT)
IQ.DCP:	.BLKW			; DEFAULT CPU  LIMIT (BATCH)
IQ.DP1:				; DEFAULT PAGE LIMIT (PRINT)
IQ.DTI:	.BLKW			; DEFAULT TIME LIMIT (BATCH)
IQ.MPR:	.BLKB			; MAXIMUM PRIORITY
	.BLKB			; RESERVED
IQ.MP0:				; MAXIMUM PAGE VALUE (PRINT)
IQ.MCP:	.BLKW			; MAXIMUM CPU  VALUE (BATCH)
IQ.MP1:				; MAXIMUM PAGE VALUE (PRINT)
IQ.MTI:	.BLKW			; MAXIMUM TIME VALUE (BATCH)
IQ.PRV:	.BLKW	PRVSIZ		; REQUIRED PRIVILEGE MASK
IQ.LEN:				; PACKET LENGTH

;
; DEFINE PACKET OFFSETS FOR MODIFY QUEUE (MQ) COMMAND (#26)
;

	.DSECT	,NOCREF
MQ.SEQ:	.BLKW			; SEQUENCE NUMBER
MQ.QUE:	.BLKB			; QUEUE TYPE
	.BLKB			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
MQ.STS:	.BLKW			; STATUS
MQ.FLG:	.BLKW			; FLAGS
MQ.QNL:	.BLKB			; QUEUE NAME LENGTH
MQ.QNM:	.BLKB	NAM.LEN		; QUEUE NAME
MQ.FML:	.BLKB			; FORM NAME LENGTH
MQ.FRM:	.BLKB	NAM.LEN		; FORM NAME
MQ.DPR:	.BLKB			; DEFAULT PRIORITY
	.BLKB			; RESERVED
MQ.DP0:				; DEFAULT PAGE LIMIT (PRINT)
MQ.DCP:	.BLKW			; DEFAULT CPU  LIMIT (BATCH)
MQ.DP1:				; DEFAULT PAGE LIMIT (PRINT)
MQ.DTI:	.BLKW			; DEFAULT TIME LIMIT (BATCH)
MQ.MPR:	.BLKB			; MAXIMUM PRIORITY
	.BLKB			; RESERVED
MQ.MP0:				; MAXIMUM PAGE VALUE (PRINT)
MQ.MCP:	.BLKW			; MAXIMUM CPU  VALUE (BATCH)
MQ.MP1:				; MAXIMUM PAGE VALUE (PRINT)
MQ.MTI:	.BLKW			; MAXIMUM TIME VALUE (BATCH)
MQ.PRV:	.BLKW	PRVSIZ		; REQUIRED PRIVS FOR QUEUE ENTRY
MQ.LEN:				; PACKET LENGTH

;
; DEFINE PACKET OFFSETS FOR DELETE QUEUE (DQ) COMMAND (#27)
;

	.DSECT	,NOCREF
DQ.SEQ:	.BLKW			; SEQUENCE NUMBER
DQ.QUE:	.BLKB			; QUEUE TYPE
	.BLKB			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
DQ.STS:	.BLKW			; STATUS
DQ.FLG:	.BLKW			; FLAGS
DQ.QNL:	.BLKB			; QUEUE NAME LENGTH
DQ.QNM:	.BLKB	NAM.LEN		; QUEUE NAME
DQ.LEN:				; PACKET LENGTH

;
; DEFINE PACKET OFFSETS FOR PAUSE QUEUE (PQ) COMMAND (#30)
;

	.DSECT	,NOCREF
PQ.SEQ:	.BLKW			; SEQUENCE NUMBER
PQ.QUE:	.BLKB			; QUEUE TYPE
	.BLKB			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
PQ.STS:	.BLKW			; STATUS
PQ.FLG:	.BLKW			; FLAGS
PQ.QNL:	.BLKB			; QUEUE NAME LENGTH
PQ.QNM:	.BLKB	NAM.LEN		; QUEUE NAME
PQ.LEN:				; PACKET LENGTH

;
; DEFINE PACKET OFFSETS FOR CONTINUE QUEUE (CQ) COMMAND (#31)
;

	.DSECT	,NOCREF
CQ.SEQ:	.BLKW			; SEQUENCE NUMBER
CQ.QUE:	.BLKB			; QUEUE TYPE
	.BLKB			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
CQ.STS:	.BLKW			; STATUS
CQ.FLG:	.BLKW			; FLAGS
CQ.QNL:	.BLKB			; QUEUE NAME LENGTH
CQ.QNM:	.BLKB	NAM.LEN		; QUEUE NAME
CQ.LEN:				; PACKET LENGTH

;
; DEFINE PACKET OFFSETS FOR ASSIGN QUEUE (AS) COMMAND (#32)
;

	.DSECT	,NOCREF
AS.SEQ:	.BLKW			; SEQUENCE NUMBER
AS.QUE:	.BLKB			; QUEUE TYPE
	.BLKB			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
AS.STS:	.BLKW			; STATUS
AS.FLG:	.BLKW			; FLAGS
AS.DVL:	.BLKB			; SERVER NAME LENGTH
AS.DEV:	.BLKB	NAM.LEN		; SERVER NAME
AS.QNL:	.BLKB			; QUEUE NAME LENGTH
AS.QNM:	.BLKB	NAM.LEN		; QUEUE NAME
AS.LEN:				; PACKET LENGTH

;
; DEFINE PACKET OFFSETS FOR DEASSIGN QUEUE (DS) COMMAND (#33)
;

	.DSECT	,NOCREF
DS.SEQ:	.BLKW			; SEQUENCE NUMBER
DS.QUE:	.BLKB			; QUEUE TYPE
	.BLKB			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
	.BLKW			; RESERVED
DS.STS:	.BLKW			; STATUS
DS.FLG:	.BLKW			; FLAGS
DS.DVL:	.BLKB			; SERVER NAME LENGTH
DS.DEV:	.BLKB	NAM.LEN		; SERVER NAME
DS.QNL:	.BLKB			; QUEUE NAME LENGTH
DS.QNM:	.BLKB	NAM.LEN		; QUEUE NAME
DS.LEN:				; PACKET LENGTH

;
; DEFINE OFFSETS FOR FILESPEC BLOCK
;

	.DSECT	,NOCREF
FB.NXT:	.BLKW			; OFFSET TO NEXT FILESPEC BLOCK
FB.FLG:	.BLKW			; FLAGS
FB.COP:	.BLKW			; FILE COPIES
FB.SPL:	.BLKB			; FILESPEC LENGTH
FB.SPC:				; FILESPEC

;
; DEFINE OFFSETS FOR LOG FILE BLOCK
;

	.DSECT	,NOCREF
LG.FLG:	.BLKW			; LOG FILE FLAGS ( SAME AS FF$ FLAGS )	;021
LG.QNL:	.BLKB			; LOG FILE QUEUE NAME LENGTH
LG.QNM:	.BLKB	NAM.LEN		; LOG FILE QUEUE NAME
LG.SPL:	.BLKB			; LOG FILE NAME LENGTH
LG.SPC:				; LOG FILE NAME

;
; DEFINE OFFSETS FOR SET-UP BLOCK
;

	.DSECT	,NOCREF
SE.NXT:	.BLKW			; OFFSET TO NEXT SET-UP BLOCK
SE.SPL:	.BLKB			; FILESPEC LENGTH
SE.SPC:	.BLKB			; FILESPEC

;
; DEFINE OFFSETS FOR PARAMETER BLOCK
;

	.DSECT	,NOCREF
PB.PML:	.BLKB			; PARAMETER LENGTH
PB.PMS:	.BLKB			; PARAMETER STRING

;
; DEFINE ENTRY PACKET STATUS (JB.STS) VALUES
;

	.DSECT	,NOCREF
JS$FRM:	.BLKB			; Entry is READY, but needs form change	;056
JS$NRD:	.BLKB			; NOT READY
JS$AFT:	.BLKB			; AFTER
JS$RDY:	.BLKB			; READY
JS$STR:	.BLKB			; STARTED
JS$ABT:	.BLKB			; ABORTING
JS$SUC:	.BLKB			; SUCCEEDED
JS$FAI:	.BLKB			; FAILED ( severely )
JS$KIL:	.BLKB			; DELETED
JS$ABO:	.BLKB			; ABORTED
JS$ERR:	.BLKB			; Completed in error
JS$WAR:	.BLKB			; Completed in warning
JS$UNX:	.BLKB			; Completed with unknown status
JS$TIM:	.BLKB			; time limit exceeded
JS$CPU:	.BLKB			; cpu limit exceeded
JS$ILL:	.BLKB			; Entry has illegal task parameters (Batch) ;056
JS$MAX:				; FIRST ILLEGAL

	.ASSUME JS$FRM LT JS$STR
	.ASSUME JS$NRD LT JS$STR
	.ASSUME JS$AFT LT JS$STR
	.ASSUME JS$RDY LT JS$STR
	.ASSUME JS$ABT GT JS$STR
	.ASSUME JS$SUC GT JS$ABT
	.ASSUME JS$FAI GT JS$ABT
	.ASSUME JS$KIL GT JS$ABT
	.ASSUME JS$ABO GT JS$ABT

;
; DEFINE ENTRY PACKET FLAG (JB.FLG) BITS
;

	.BSECT	,NOCREF
JB$PRV:	.BLKB	.		; ENTRY IS PRIVILEGED ** OBSOLETE **	;029
JB$HLD:	.BLKB	.		; ENTRY SHOULD BE HELD
JB$REL:	.BLKB	.		; ENTRY SHOULD BE RELEASED
JB$EXQ:	.BLKB	.		; Entry has EXQTA privilege		;029
JB$NTF:	.BLKB	.		; User want to be NOTIFY'd of things	;056
JB$LTS:	.BLKB	.		; Log_file Time Stamp flag  ** BATCH **	;056
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
JB$TAP:	.BLKB	.		; Reserved for TAP group		;054
	.BLKB	.		; UNUSED

;
; DEFINE STATUS UPDATE COMMAND BITS
;

	.BSECT	,NOCREF
SU$OFL:	.BLKB	.		; SERVER IS OFFLINE
SU$ONL:	.BLKB	.		; SERVER IS ONLINE
SU$CAR:	.BLKB	.		; SERVER HAS EXPERIENCED CARRIER LOSS
	.BLKB	.
	.BLKB	.
	.BLKB	.
	.BLKB	.
	.BLKB	.
	.BLKB	.
	.BLKB	.
	.BLKB	.
	.BLKB	.
	.BLKB	.
	.BLKB	.
	.BLKB	.
	.BLKB	.

;
; DEFINE SERVER/FORM CHARACTERISTIC BITS
;

	.BSECT	,NOCREF
FM$TOF:	.BLKB	.		; HARDWARE TOP_OF_FORM
FM$CTL:	.BLKB	.		; ALLOW NON-PRINTING CONTROLS
FM$CUP:	.BLKB	.		; CONVERT CONTROLS TO UP-ARROW REPRESENTATION
FM$FTP:	.BLKB	.		; File trailer page ;053
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED

;
; DEFINE OFF-LINE PACKET FLAG (OF.FLG) BITS
;

	.BSECT	,NOCREF
OF$ABO:	.BLKB	.		; ABORT STARTED ENTRIES
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED

;
; DEFINE FILESPEC BLOCK FLAG (FB.FLG) BITS
;

	.BSECT	,NOCREF
	.BLKB	.		; 000001 = UNUSED
	.BLKB	.		; 000002 = UNUSED
FF$DEL:	.BLKB	.		; 000004 = DELETE FILE AFTER PRINTING	;021
FF$BIN:	.BLKB	.		; 000010 = BINARY (8-BIT) FILE		;021
	.BLKB	.		; 000020 = UNUSED
FF$FHD:	.BLKB	.		; 000040 = PRINT FILE HEADER PAGES	;021
FF$FTR:	.BLKB	.		; 000100 = PRINT FILE TRAILER PAGES	;021
FF$PHD:	.BLKB	.		; 000200 = PRINT PAGE HEADERS		;021
FF$PFT:	.BLKB	.		; 000400 = PRINT PAGE FOOTERS		;021
FF$ZER:	.BLKB	.		; 001000 = CONVERT (ZERO TO OH)		;021
FF$TRN:	.BLKB	.		; 002000 = TRUNCATE LONG LINES		;021
FF$UPR:	.BLKB	.		; 004000 = CONVERT LC TO UC		;021
FF$SKP:	.BLKB	.		; 010000 = SKIP OVER PERFS (FEED)	;021
FF$RAP:	.BLKB	.		; 020000 = WRAP LONG, UNTRUNCATED LINES	;055
	.BLKB	.		; 040000 = UNUSED
FF$QLG:	.BLKB	.		; 100000 = Queue logfile		;023

;
; DEFINE PAUSE SERVER PACKET FLAG (PD.FLG) BITS
;

	.BSECT	,NOCREF
PD$EOJ:	.BLKB	.		; PAUSE AT END OF JOB
PD$EOF:	.BLKB	.		; PAUSE AT END OF FILE
PD$EOP:	.BLKB	.		; PAUSE AT END OF PAGE			;018
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
PD$IMM:	.BLKB	.		; pause immediate (internal)		;037

;
; DEFINE CONTINUE SERVER PACKET FLAG (CD.FLG) BITS
;

	.BSECT	,NOCREF
CD$NXT:	.BLKB	.		; NEXT_JOB (ABORT)
CD$TOF:	.BLKB	.		; TOP_OF_FILE
CD$RES:	.BLKB	.		; RESTART
CD$PAG:	.BLKB	.		; PAGE
CD$FWD:	.BLKB	.		; FORWARDSPACE
CD$BWD:	.BLKB	.		; BACK_SPACE
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED

;
; DEFINE INITIALIZE SERVER PACKET FLAG (ID.FLG) BITS
;

	.BSECT	,NOCREF
ID$ASN:	.BLKB	.		; ASSIGN (NOSHAREABLE)
ID$TEN:	.BLKB	.		; mark server as "tentative"		;041
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED

;
; DEFINE DEASSIGN QUEUE PACKET FLAG (DS.FLG) BITS
;

	.BSECT	,NOCREF
DS$ALL:	.BLKB	.		; DEASSIGN/ALL
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED
	.BLKB	.		; UNUSED

;
; DEFINE MODIFY JOB PACKET FLAG (MD.FLG) BITS
;

	.BSECT	,NOCREF
MD$AFT:	.BLKB	.		;      1 = update after date/time fields
MD$CPU:	.BLKB	.		;      2 = update CPU limit field
MD$FRM:	.BLKB	.		;      4 = update forms name field
MD$HLD:	.BLKB	.		;     10 = hold entry
MD$COP:	.BLKB	.		;     20 = update job count field
MD$PAG:	.BLKB	.		;     40 = update page limit field
MD$PRI:	.BLKB	.		;    100 = update priority field
MD$RLS:	.BLKB	.		;    200 = release entry
MD$TIM:	.BLKB	.		;    400 = update time limit field
MD$NOT:	.BLKB	.		;   1000 = set notify flag		;057
MD$NNT:	.BLKB	.		;   2000 = clear notify flag		;057
	.BLKB	.		;   4000 = (reserved)
	.BLKB	.		;  10000 = (reserved)
	.BLKB	.		;  20000 = (reserved)
	.BLKB	.		;  40000 = (reserved)
	.BLKB	.		; 100000 = (reserved)

;
; DEFINE MODIFY QUEUE PACKET FLAG (MQ.FLG) BITS
;

	.BSECT	,NOCREF
MQ$MCP:	.BLKB	.		;      1 = update maximum CPU limit field
MQ$DCP:	.BLKB	.		;      2 = update default CPU limit field
MQ$DFL:	.BLKB	.		;      4 = mark queue as default
MQ$NDF:	.BLKB	.		;     10 = mark queue as nodefault
MQ$FRM:	.BLKB	.		;     20 = update default forms name field
MQ$MPG:	.BLKB	.		;     40 = update maximum page limit field
MQ$DPG:	.BLKB	.		;    100 = update default page limit field
MQ$MPR:	.BLKB	.		;    200 = update maximum priority field
MQ$DPR:	.BLKB	.		;    400 = update default priority field
MQ$PRV:	.BLKB	.		;   1000 = update privilege mask field
MQ$MTM:	.BLKB	.		;   2000 = update maximum time limit field
MQ$DTM:	.BLKB	.		;   4000 = update default time limit field
	.BLKB	.		;  10000 = (reserved)
	.BLKB	.		;  20000 = (reserved)
	.BLKB	.		;  40000 = (reserved)
	.BLKB	.		; 100000 = (reserved)

;
; DEFINE MODIFY SERVER PACKET FLAG (MS.FLG) BITS
;

	.BSECT	,NOCREF
MS$CTL:	.BLKB	.		;      1 = set CONTROLS flag bit	;045
MS$NCT:	.BLKB	.		;      2 = set NOCONTROLS flag bit	;045
MS$CUP:	.BLKB	.		;      4 = set CONTOLS=UPARROW flag bit	;045
MS$FRM:	.BLKB	.		;     10 = update forms field
MS$PRI:	.BLKB	.		;     20 = update priority field
MS$RUN:	.BLKB	.		;     40 = update runburst field
MS$SHR:	.BLKB	.		;    100 = mark server as shareable
MS$NSH:	.BLKB	.		;    200 = mark server as noshareable
	.BLKB	.		;    400 = (reserved)
	.BLKB	.		;   1000 = (reserved)
	.BLKB	.		;   2000 = (reserved)
	.BLKB	.		;   4000 = (reserved)
	.BLKB	.		;  10000 = (reserved)
	.BLKB	.		;  20000 = (reserved)
	.BLKB	.		;  40000 = (reserved)
	.BLKB	.		; 100000 = (reserved)

	.RESTORE

;
; RE-DEFINE ALLCMD MACRO AS NULL
;

	.MACRO	ALLCMD
	.ENDM

	.ENDM	ALLCMD

	.END
