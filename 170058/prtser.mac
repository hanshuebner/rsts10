.INCLUDE	%CMN:COMMON%
TITLE	PRTSER,<THE PRINT SERVER>,0A,10-MAY-91,SJM/PRL/KCG/ACT/TJK/DBM

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR PRTSER
;+
;
;  001  SJM  23-Sep-82	CREATION - And it was a good thing
;  002  KCG  29-Oct-82  Fix file header pages.
;  003  KCG  02-Dec-82	Fix simulated form feeds.
;  004  KCG  03-Dec-82 	Install Job Header Pages ( tentative ).
;  005	PRL  23-Dec-82	Add check of PRIV JOB flag
;  006	PRL  01-Jan-83	Fix bit tests for DEVFLG word
;			Change FLUSH's to EMPTY's
;  007	PRL  06-Jan-83	Update STRJOB routine
;			Define patch symbol for output buffer len
;			Rename .NOP routine to RETMSG
;  008	PRL  07-Jan-83	Added PAUSE at END-OF-FILE, END-OF-JOB
;			Added BLDPPN routine for default user name
;  009	PRL  11-Jan-83	Moved BLDPPN into PBSLIB library
;  010  KCG  17-Jan-83	Added Form Name to Splat
;  011  KCG  17-Jan-83	Add bit check for STOP/ABORT in SPOFL
;			Add CNF$REL to continue option table CONOPT
;  012	KCG  28-Jan-83	Add new state to send EOJ to QMAN after dev closing.
;  013	KCG  18-Feb-83	Ensure not TOF after EOF.
;  014	KCG  21-Feb-83	Move request for s.form and s.eojc down to opndev from
;			spjob.
;
;	KCG/ACT		Creation of 9.0 from 8.0
;  015	ACT  01-Jul-83	Convert package to accept new packet definition.
;  016	ACT  20-Jul-83	Add new form handling routine (since no more form cmd)
;  017	KCG  30-Aug-83	Changed hardware TOF to be set in ID.CHR word.
;  018	KCG  01-Sep-83	Adapted RESATN to handle new flag handling.
;  019	KCG  27-Feb-84	Fix hibernation upon;
;				1) simulated form feeds
;				2) skip over perfs
;				3) tab as first char of page
;				4) near end of output buffer
;  020	PRL  28-Mar-84	Implement pause at end of page (PD$EOP)
;  021	PRL  29-Mar-83	Implement page limit checks
;  022	KCG  13-Apr-84	Insert new field for new XMIT
;  023	PRL  19-Apr-84	Change FB$xxx symbols to FF$xxx
;  024	KCG  26-Apr-84	Put in .INCLUDEs
;  025	PRL  13-May-84	Use MOVBYT, RECV, REMV, DCLR macros
;			Use LOT macro to define local obj types
;  026	PRL  14-May-84	Use new PR$xnn receiver name
;  027	PRL  21-May-84	Remove CHKOPR routine
;  028	PRL  22-May-84	Invoke PBSCON macro to define constants
;  029	PRL  28-May-84	Update GETMSG to check for priv'd sender
;  030	PRL  29-May-84	Add new SPLAT line buffer and code
;  031	KCG  05-Jun-84	Invoke PBSCON before SPLCMD (PBSCON defines NAM.LEN)
;  032	KCG  20-Jun-84	Move SPLAT line buffer to dynamic area
;  033	KCG  29-Jun-84	Create new SECRTY routine using 3PP
;  034	PRL  28-Jul-84	Process pause at end of page properly
;  035	KCG  11-Sep-84	Added routines for DEVONL and DEVOFL
;  036	KCG  18-Sep-84	Added new routine for back space processing
;  037	KCG  19-Sep-84	Added new routine for reading device characteristics
;  038	KCG  21-Sep-84	Added routine to send real tab if selected
;  039	KCG  11-Oct-84	Added control sequence detection/support
;  040	KCG  22-Oct-84	Added forced <ST> if in control seq for abort, continue
;  041	KCG  26-Oct-84	Added call to entrcv for receiver declaration
;  042	KCG  04-Dec-84	Forced <ST> if in control string for EOF condition
;  043	KCG  07-Feb-85	Make corrections/additions to make modem spooling work
;  044	KCG  07-Feb-85	Put in support for margins (only bottom margin works)
;  045	KCG  12-Feb-85	Added DEVNAM routine for device/ppn on file headers
;  046	KCG  04-Mar-85	call devonl when carrier loss found on initial open
;  047	KCG  14-Mar-85	Implement new device assignment protocol from QMAN.
;  048	KCG  15-Apr-85	Set minimum write length to 12. in PUT routine
;  049	KCG  15-Apr-85	STOP/QUEUE/MANAGER/ABORT will stop if device goes OFL
;
;	KCG		Creation of 9.1 from 9.0
;  050	KCG  15-May-85	Fix bug with real tabs again
;  051	KCG  05-Jun-85	Use FSS and UNFSS for saving device name (SAVDEV)
;  052	KCG  19-Jun-85	Fix header page problems
;  053	KCG  21-Jun-85	Clear out saved file name on job initialization
;
;       KCG		Creation of 9.2 from 9.1
;  054	KCG  09-Sep-85	Fix restart functions.
;  055	KCG  10-Sep-85	Fix CC:IMP processing
;  056  TJK  10-Sep-85  Add [NO]TRAILER pages
;  057  TJK  26-Nov-85  Put FILE END on two lines
;  058  TJK  27-Nov-85  Simulate /CRFILL support for KB's
;  059  TJK  10-Jan-86  Fix bug in 058
;  060	PRL  20-Jan-86	Support (undocumented) TAP feature.  Suppress all
;				job/file header and trailer pages and <ff>'s
;				between job/file copies
;  061	PRL  09-Nov-86	Fix bug in 058 (no <sp><cr> after <ff> on KB printers)
;  062	DBM  02-Feb-87	Output LP fill chars instead of UNGETting them
;  063	DBM  19-Feb-87	Remove possibility of buffer corruptions via UNGETs
;			 or over-outputting.
;  064	DBM  11-Mar-87	Fix tab processing on width 255 servers
;			Remove some of 063 due to RMS files breaking
;
;			[RSTS/E V9.5]
;  065	DBM  18-Jun-87	Add keyboard support to EMPTY1
;			(Checks DDB to see when buffers are really empty)
;  066	DBM  24-Aug-87	Fix form-feed processing on simulated form servers
;  067	DBM  05-Oct-87	Fix sense of LPTRBS (Real BackSpace) bit.
;			Also make it work for width 255 forms.
;			[RSTS/E V9.6]
;  068	DBM  01-Feb-88	Move most of CC:IMP processing to RMSGET
;			(Some top-of-form stuff has to stay here)
;			Also allow C0 controls during ESCape sequences
;
;			[RSTS/E V9.6]
;  069	DBM  07-Feb-88	Add /[NO]WRAP support
;  070	DBM  18-Feb-88	Finish /[NO]WRAP support
;			Add Unconditional sleep bit on KB opens
;  071	DBM  21-Feb-88	Fix <BS> beyond right margin, Remove CLR of DDFLAG
;			in FORM (Dialup lines were resetting)
;			Fix aborting jobs on lost-carrier servers
;  072	DBM  23-Mar-88	Actually process C0 controls during ESCape sequences
;
;			[RSTS/E V9.7]
;  073	DBM  29-Sep-88	Add "dirty page" state flag
;
;			[RSTS/E V10.0]
;  074	DBM  29-Jun-89	Add OMS and /NOTIFY support
;  075	DBM  27-Jan-90	Outbound LAT support
;  076	DBM  06-Mar-90	Fix restart at page n problem
;  077	DBM  24-May-90	Output <CR> instead of <NUL> in OPNDEV
;-

.SBTTL	INCLUDE MACRO LIBRARIES

.LIBRARY	%SYSTEM:PBSMAC%
.LIBRARY	%LB:RMSMAC%

	.ENABL	LC

.SBTTL	MACROS	- CALL/INVOKE NEEDED COMMON MACROS

	.PSECT

	.MCALL	SPLCMD
	.MCALL	PSECTS,BITDEF,QUEDEF,SAVREG
	.MCALL	FQBERR
	.MCALL	RMSERR
	.MCALL	CR$LF
	.MCALL	SUBRIB,GETLUN,RETLUN,GETBUF,RETBUF
	.MCALL	GETDEV,RETDEV,MOVSTR
	.MCALL	STALL,CRASH,SHUTUP,XMIT,XMITM,XMTBLK
	.MCALL	SPLSTA,SPLFUN,SPLEND,SETFUN,CLRFUN
	.MCALL	RMSBLK,REJECT
	.MCALL	CHKFRE,DEBUG
	.MCALL	MOVBYT,RECV,REMV,DCLR					;025
	.MCALL	LOT							;025
	.MCALL	PBSCON							;028
	.MCALL	MUTEXC,SETPRV,CHKPRV					;029
	.MCALL	.ASCIC,FILL						;030

	PSECTS
	BITDEF
	PBSCON								;028
	SPLCMD
	QUEDEF
	CR$LF
	XMTBLK
	RMSBLK
	LOT

.SBTTL	DEFINE ASSEMBLY TYPE

	.IF	DF	$$TEST

		LO.QMN	=	LO.QMN+4 ; Set new lots for test version
		LO.SRV	=	LO.SRV+4
		LO.URP	=	LO.URP+4

	.ENDC

.SBTTL	RMSOFF	- DEFINE RMS OFFSETS
	.PSECT

	.MCALL	FABOF$,FAB$BT,RABOF$,RAB$BT,$RMSTAT,RMS$L,$STORE,$TESTBITS

	FABOF$	RMS$L
	RABOF$	RMS$L
	RAB$BT	DFIN$L
	FAB$BT	DFIN$L
	$RMSTAT	DFIN$L

.SBTTL	RSTTBL	- DEFINE OFFSETS IN RESTART TABLE

	.SAVE
	.DSECT	,CREF

RPAG0:	.BLKW			;  2 WORDS PAGE NUMBER
RPAG1:	.BLKW
RLIN:	.BLKW			;  1 Word line number			;069
RPOS:	.BLKW			;  1 Word CCPOS number			;069
RRFA:	.BLKW	3		;  3 WORDS RFA
RSIZ = .-RPAG0			;SIZE OF RESTART ENTRIES

	.RESTORE

.SBTTL	OFFSETS	- DEFINE OFFSETS FOR IMPURE AREA

;
; DEFINE OFFSETS FOR OUR IMPURE DATA BLOCK
;
	.DSECT	,CREF
	.BLKW	<ARGSIZ/2>
L3QJOB:	.BLKW			; SUBFUN NUMBER OF LAST FUN TO RUN
JOBSTA:	.BLKW			; SPOOLER/SPOOLED JOB STATUS
EOJSTS:	.BLKW			; END OF JOB STATUS
KILLGL:	.BLKW			; KILL'S ARE LEGAL FOR THIS FILE

RECVID:	.BLKW	3		; RECEIVER ID
QRIB:	.BLKW			; RIB NUMBER

MSGPTR:	.BLKW			; POINTER TO MESSAGE BLOCK
MSGLEN:	.BLKW			; LENGTH OF MESSAGE BLOCK
MSGEND:	.BLKW			; end addr of message			;029

PPN:	.BLKW			; sender's PPN		** keep     **	;029
JBNO:	.BLKB			; sender's job no.	** these    **	;029
KBNO:	.BLKB			; sender's KB no.	** fields   **	;029
PRIV:	.BLKW	PRVSIZ		; sender's priv mask	** in order **	;029

QMJBNO:	.BLKW			; QMAN's job number			;047
JOBPTR:	.BLKW			; POINTER TO JOB BLOCK
JOBLEN:	.BLKW			; LENGTH OF JOB BLOCK

RESPTR:	.BLKW			; POINTER TO RESTART BLOCK
RESLEN:	.BLKW			; LENGTH OF RESTART BLOCK

SP.SID:	.BLKW			; THEIR (SENDER'S) CID
SP.RID:	.BLKW			; OUR (RECIEVER'S) CID
SP.CTX:	.BLKW			; USER CONTXT FIELD TO BE RETURNED

RECPTR:	.BLKW			; POINTER TO TEMP VERSION OF INPUT DATA

OUTBUF:	.BLKW			; POINTER TO OUTPUT BUFFER
OUTBLN:	.BLKW			; FIXED LENGTH OF OUTPUT BUFFER
OUTPTR:	.BLKW			; POINTER TO NEXT FREE SPOT IN OUT BUFFER
OUTPOS:	.BLKW			; OUTPUT POSITION IN OUTPUT BUFFER
FREE:	.BLKW			; COUNT OF FREE SPACE IN OUTPUT BUFFER
OUTLUN:	.BLKW			; CHANNEL # *2 TO USE FOR OUTPUT
ORCMOD:	.BLKW			; MODE TO USE ON OUTPUT PUTS
SVDMOD:	.BLKW			; SAVED COPY OF ORCMOD
CTLSTA:	.BLKW			; CURRENT STATE OF CONTROL SEQUENCE

DSPBIT:	.BLKW	4		; PRTSER DISPATCH FUNCTION BITS
INITSP:	.BLKW			; INITIAL VALUE OF SP (USED TO ZONK STACK)

WILD:	.BLKW			; FLAG, SET IF LAST WILD LOOKUP SUCCEDED
WILD1:	.BLKW			; INTERNAL STORAGE FOR WILD LOOKUP
WILD2:	.BLKW			; INTERNAL STORAGE FOR WILD LOOKUP
WILD4:	.BLKW			; INTERNAL STORAGE FOR WILD LOOKUP
WILFQB:	.BLKB	FQBSIZ		; Internal firqb storage for wild lookup

HDRFLG:	.BLKW			; HEADER PAGE FLAGS
FILCOP:	.BLKW			; NUMBER OF FILE COPY CURRENTLY PRINTING
JOBCOP:	.BLKW			; NUMBER OF JOB COPY CURRENTLY PRINTING
FILSPC:	.BLKW			; POINTER TO CURRENT FILE SPEC IN FILE PACKET
SPLLIN:	.BLKW			; STORAGE FOR SPLAT GENERATOR
SPLCNT:	.BLKW			; STORAGE FOR SPLAT GENERATOR

PGJH:	.BLKB			; NUMBER OF JOB HEADER PAGES PRINTED
PGJT:	.BLKB			; NUMBER OF JOB TRAILER PAGES PRINTED
PGFH:	.BLKB			; NUMBER OF FILE HEADER PAGES PRINTED
PGFT:	.BLKB			; NUMBER OF FILE TRAILER PAGES PRINTED

CENCNT:	.BLKW			; center counter for job header pages
ENTSIZ:	.BLKW			; 1 or 2 for single or dbl height entry name

SP.STAT:.BLKW			; CURRENT STATE OF MESSAGE PROCESSOR
SP.OSTA:.BLKW			; OLD STATE OF MESSAGE PROCESSOR
SAVSTA:	.BLKW			; STATE OF LAST MESSAGE FOR REDO

SUCPUT:	.BLKW			; NUMBER OF SUCCESSFULL PUTS WO RECIEVE TRY
ZERPUT:	.BLKW			; NUMBER OF ZERO LENGTH PUTS IN A ROW
PUTSLP:	.BLKW			; SLEEP TIMER LAST USED ON OUT PUT
DDBUFC:	.BLKW			; Save area for KB DDB empty pointer	;065

DEVHNG:	.BLKW			; SET IF OUTPUT DEVICE HUNG BAD
DEVFLG:	.BLKW			; OUTPUT DEVICE CHARACTERISTICS
DDFLAG:	.BLKW			; OUTPUT DEVICE DEPENDENT FLAGS
DDCHAR:	.BLKW			; OUTPUT DEVICE CHARACTERISTIC FLAGS
DDFILL:	.BLKW			; CR Fill count				; 058
DDNULL:	.BLKW			; Number of fill nulls left to put	; 058
DDHORZ:	.BLKW			; Horizontal position			;069
DDHORC:	.BLKW			; Form width				;069
DDVERT:	.BLKW			; Vertical position			;069
DDVERC:	.BLKW			; Form length				;069
DDPAUS:	.BLKW			; output device pause options		;020
DDBSPO:	.BLKW			; Horizontal back space position
DDPAG0:	.BLKW			; CURRENT PAGE (FIRST WORD)
DDPAG1:	.BLKW			; CURRENT PAGE (SECOND WORD)
DDPGT0:	.BLKW			; CURRENT PAGE TOTAL (FIRST WORD)
DDPGT1:	.BLKW			; CURRENT PAGE TOTAL (SECOND WORD)
DDBOM:	.BLKW			; form's bottom margin			;069
DDTOM:	.BLKW			; form's top margin			;069
DDLEM:	.BLKW			; form's left margin			;069
DDRIM:	.BLKW			; form's right margin			;069

PGLIM0:	.BLKW			; current job's page limit (LSB)	;021
PGLIM1:	.BLKW			; current job's page limit (MSB)	;021

CHARX1:	.BLKW			; max single-block chars per line	;031
CHARX2:	.BLKW			; max double-block chars per line	;031

RESPG0:	.BLKW			; RESTART PAGE NUMBER
RESPG1:	.BLKW			; RESTART PAGE NUMBER (SECOND WORD)
RSTPTR:	.BLKW			; RESTART TABLE 1 POS POINTER
RSTINT:	.BLKW			; RESTART STORAGE INTERVAL
RSTENT=20.
RSTBEG:	.BLKW	<RSTENT*RSIZ>/2	;RSTENT ENTRIES IN FIRST RESTART TABLE
RSTEND:

SVDOPT:	.BLKW			; SAVED COPY OF FILE OPTIONS WORD
NAMBUF:	.BLKB	48.		; BUFFER FOR REBULT FILE NAME
	NAMBFS	= .-NAMBUF
	.EVEN
				;SPLAT TABLE DEFINITION
ENTBUF:	.BLKB			;length of entry-spec
	.BLKB	FIL.LEN		;entry-spec ("queue:[ppn]name")

FILBUF:	.BLKB			;length of file-spec
	.BLKB	FIL.LEN		;file-spec ("_dev:[ppn]filnam.typ")

JCPBUF:	.BLKB			;length of job copy nos.
	.BLKB	<3.+4.+3.>	;job copy nos.

FCPBUF:	.BLKB			;length of file copy nos.
	.BLKB	<3.+4.+3.>	;file copy nos.

DEVBUF:	.BLKB			;length of device name
	.BLKB	NAM.LEN		;device name ("_dev:")

FRMBUF:	.BLKB			;length of form name
	.BLKB	NAM.LEN		;form name ("form")

DATBUF:	.BLKB			;length of date/time
	.BLKB	<9.+1.+8.>	;date/time ("dd-mmm-yy hh:mm am")

SYSBUF:	.BLKB			;length of system name
	.BLKB	28.		;system name ("name")

ACTBUF:	.BLKB			;length of account name string
	.BLKB	13.		;account name string ("name")

PPNBUF:	.BLKB			;length of PPN string
	.BLKB	13.		;PPN string ("[xxx,yyy]")

	.EVEN

SARGSIZ:			; TOTAL SIZE OF DATA BLOCK

.ASSUME	4 GT $DSBYT/2 		;CHECK SIZE OF DSPBIT TABLE

;
; DEFINE BITS IN JOBSTA WORD (STATUS OF SPOOLED JOB)
;
	.BSECT	,CREF
J.ONL:	.BLKB	.		;JOB IS ONLINE TO QMAN
J.FRM:	.BLKB	.		;FORM HAS BEEN DEFINED
J.JOB:	.BLKB	.		;JOB IS IN PROGRESS
J.DEV:	.BLKB	.		;OUTPUT DEVICE IS OPEN
J.OPN:	.BLKB	.		;INPUT FILE IS OPEN
J.ABRT:	.BLKB	.		;ABORT REQUESTED BY USER OR SPOOLER
J.HNG:	.BLKB	.		;OUTPUT DEVICE IS HUNG
J.SBS:	.BLKB	.		;IN PROCESS OF SIMULATING BACKSPACE
J.PLE:	.BLKB	.		;JOB PAGE LIMIT EXCEEDED
J.ESC:	.BLKB	.		;CONTROL SEQUENCE IN PROGRESS
J.KBCL:	.BLKB	.		;Initial KB open encountered carrier loss
J.ABOF:	.BLKB	.		;OFL/ABORT command was recieved
J.SFF:	.BLKB	.		;In process of simulating form feed	;069
J.STAB:	.BLKB	.		;In process of simulating a tab		;069
J.DRTY:	.BLKB	.		;Page Dirty flag			;073
	.PSECT

.SBTTL	DEFINE BITS IN HDRFLG - HEADER PAGE FLAGS

	.BSECT	,CREF

H$JOBH:	.BLKB	.		;printing job header page		;030
H$JOBT:	.BLKB	.		;printing job trailer page		;030
H$FILH:	.BLKB	.		;printing file header page		;030
H$FILT:	.BLKB	.		;printing file trailer page		;030

.SBTTL	xxxKWD	- DEFINE SPLAT LINE ASCIC KEYWORD STRINGS

	.SAVE
	.PSECT	PURE

FILKWD:	.ASCIC	<  File >		;keyword FILE
ENTKWD:	.ASCIC	<  Entry >		;keyword ENTRY
COPKWD:	.ASCIC	< Copy >		;keyword COPY
DEVKWD:	.ASCIC	< Printer >		;keyword PRINTER
FRMKWD:	.ASCIC	< Form >		;keyword FORMS
EOJKWD:	.ASCIC	<END-OF-JOB >		;keyword END-OF-JOB
FILEND:	.ASCIC	<*** File End *** >	;keyword FILE END	;056
CFLKWD:	.ASCIC	<FILE>			;keyword FILE	 	;057
CEDKWD:	.ASCIC	<END>			;keyword END		;057
FILLER:	.ASCIC	< >			;filler (blank)
EOLKWD:	.BYTE	2,CR$CR,CR$LF		;keyword <cr><lf>

	.EVEN
	.RESTORE

.SBTTL	JHSPLT	- DEFINE JOB HEADER SPLAT FIELDS TABLE

	.SAVE
	.PSECT	PURE
	.EVEN
JHSPLT:					;start of job header splat table
	.WORD	DATBUF,1		;  date/time
	.WORD	ENTKWD,0		; keyword "Entry"
	.WORD	ENTBUF,1		;  entry-spec
	.WORD	COPKWD,0		; keyword "Copy"
	.WORD	JCPBUF,1		;  job copy nos.
	.WORD	DEVKWD,0		; keyword "Printer"
	.WORD	DEVBUF,1		;  device name
	.WORD	FRMKWD,0		; keyword "Forms"
	.WORD	FRMBUF,1		;  form-name
	.WORD	FILLER,0		; filler space
	.WORD	SYSBUF,1		;  system name
	.WORD	EOLKWD,0		; <cr><lf>
	.WORD	0     ,0		;end of table

	.RESTORE

.SBTTL	JTSPLT	- DEFINE JOB TRAILER SPLAT FIELDS TABLE

	.SAVE
	.PSECT	PURE

JTSPLT:					;start of job trailer splat table
	.WORD	EOJKWD,0		; keyword "End-Of-Job"
	.WORD	EOJKWD,0		; keyword "End-Of-Job"
	.WORD	EOJKWD,0		; keyword "End-Of-Job"
	.WORD	EOJKWD,0		; keyword "End-Of-Job"
	.WORD	EOJKWD,0		; keyword "End-Of-Job"
	.WORD	EOJKWD,0		; keyword "End-Of-Job"
	.WORD	EOJKWD,0		; keyword "End-Of-Job"
	.WORD	EOJKWD,0		; keyword "End-Of-Job"
	.WORD	EOJKWD,0		; keyword "End-Of-Job"
	.WORD	EOJKWD,0		; keyword "End-Of-Job"
	.WORD	EOJKWD,0		; keyword "End-Of-Job"
	.WORD	EOJKWD,0		; keyword "End-Of-Job"
	.WORD	EOLKWD,0		; <cr><lf>
	.WORD	0     ,0		;end of table

	.RESTORE

.SBTTL	FHSPLT	- DEFINE FILE HEADER SPLAT FIELDS TABLE

	.SAVE
	.PSECT	PURE

FHSPLT:					;start of file header splat table
	.WORD	DATBUF,1		;  date/time
	.WORD	FILKWD,0		; keyword "File"
	.WORD	FILBUF,1		;  file-spec
	.WORD	FILLER,0		; filler space
	.WORD	COPKWD,0		; keyword "Copy"
	.WORD	FCPBUF,1		;  copy nos.
	.WORD	DEVKWD,0		; keyword "Printer"
	.WORD	DEVBUF,1		;  device name
	.WORD	FRMKWD,0		; keyword "Forms"
	.WORD	FRMBUF,1		;  form-name
	.WORD	FILLER,0		; filler space
	.WORD	SYSBUF,1		;  system name
	.WORD	EOLKWD,0		; <cr><lf>
	.WORD	0     ,0		;end of table

	.RESTORE

.SBTTL	FTSPLT	- DEFINE FILE TRAILER SPLAT FIELDS TABLE

	.SAVE
	.PSECT	PURE

FTSPLT:					;start of file header splat table ;056
	.WORD	FILEND,0		; keyword "File End"		;056
	.WORD	FILLER,0		; filler space			;056
	.WORD	DATBUF,1		;  date/time			;056
	.WORD	FILKWD,0		; keyword "File"		;056
	.WORD	FILBUF,1		;  file-spec			;056
	.WORD	FILLER,0		; filler space			;056
	.WORD	COPKWD,0		; keyword "Copy"		;056
	.WORD	FILLER,0		; filler space			;056
	.WORD	FCPBUF,1		;  copy nos.			;056
	.WORD	FILLER,0		; filler space			;056
	.WORD	SYSBUF,1		;  system name			;056
	.WORD	FILLER,0		; filler space			;056
	.WORD	FILEND,0		; keyword "File End"		;056
	.WORD	EOLKWD,0		; <cr><lf>			;056
	.WORD	0     ,0		;end of table			;056

	.RESTORE

.SBTTL	RETRY	- MACRO TO RETRY FUNCTION AFTER N SECS

	.MACRO	RETRY	ARG
	 .IIF	DIF	<ARG>,<R1>	MOV	ARG,R1			;065
	 JMP	RETRY
	.ENDM	RETRY

.SBTTL	SUBFUN	- DECLARE SPOOLER FUNCTIONS

;+
; NOTE THAT FUNCTION BITS ARE GROUPED IN 8.'S
; AND ARE ACCESSED OPTIMALLY BY 8.'S
;-

	SPLSTART

	SPLFUN	S.MDCL,MDCL,SET		;DECLARE RECEIVER
	SPLFUN	S.ONL,SNDONL,SET	;SEND ON-LINE MSG
	SPLFUN	S.REDO,REDO		;REDO LAST FUNCTION
	SPLFUN	S.QMSG,QMMSG,SET	;GET MESSAGE FROM QMAN 
	SPLFUN	S.ODEV,OPNDEV		;OPEN OUTPUT DEVICE
	SPLFUN	S.PUT,PUT		;WRITE OUTPUT RECORD
	SPLFUN	S.RMOD,RSTMOD		;RESTORE OUTPUT REC MODE
	SPLFUN	S.EMTY,EMPTY		;EMPTY OUTPUT BUFFERS

	SPLFUN	S.PACN,PAUCON		;HANDLE PAUSE/CONTINUE REQ
	SPLFUN	S.PAU,PAUSE		;PAUSE SPOOLING
	SPLFUN	S.CVT,MOVCVT		;MOVE/CONVERT INPUT TEXT
	SPLFUN	S.ROPT,RSTOPT		;RESTORE OUTPUT FILE OPTIONS
	SPLFUN	S.ATN,RESATN		;RESTART AT PAGE N
	SPLFUN	S.FORM,FORM		;SET UP FORM ATTRIBUTES
	SPLFUN	S.P0CR,P0CRAM		;OUTPUT PRE-CRAM DATA
	SPLFUN	S.PGJH,PAGEJH		;OUTPUT JOB HEADER PAGES

	SPLFUN	S.PGFH,PAGEFH		;OUTPUT FILE HEADER PAGES
	SPLFUN	S.OPN,OPEN		;OPEN INPUT FILE
	SPLFUN	S.ERROR,ERROR		;OUTPUT ERROR MESSAGE
	SPLFUN	S.GET,GET		;GET INPUT RECORD
	SPLFUN	S.CLOSE,CLOSE		;CLOSE INPUT FILE
	SPLFUN	S.PGFT,PAGEFT		;OUTPUT FILE TRAILER PAGES
	SPLFUN	S.PEOF,PAUEOF		;PAUSE AT END-OF-FILE
	SPLFUN	S.EOF,EOFCHK		;END-OF-FILE CHECK

	SPLFUN	S.ERASE,ERASE		;ERASE INPUT FILE
	SPLFUN	S.WLD,WLDCHK		;WILDCARD CHECK
	SPLFUN	S.EOFS,EOFSCHK		;END-OF-FILESPEC CHECK
	SPLFUN	S.PGJT,PAGEJT		;OUTPUT JOB TRAILER PAGES
	SPLFUN	S.PEOJ,PAUEOJ		;PAUSE AT END-OF-JOB
	SPLFUN	S.EOJC,EOJCHK		;END-OF-JOB CHECK
	SPLFUN	S.P1CR,P1CRAM		;OUTPUT POST-CRAM DATA
	SPLFUN	S.EMT1,EMPTY1		;EMPTY LP BUFFERS

	SPLFUN	S.CDEV,CLSDEV		;CLOSE OUTPUT DEVICE
	SPLFUN	S.EOJ,SNDEOJ		;SEND EOJ STATUS TO QMAN
	SPLFUN	S.DIE,DEATHO		;KILL OURSELF
	SPLFUN	S.STALL,IDLJOB,SET	;NULL JOB (ALWAYS SET)

	SPLEND

.SBTTL	LENTBL	- TABLE OF MINIMUM MESSAGE LENGTHS

; TABLE OF MINIMUM MESSAGE LENGTH OF ALL DEFINED MESSAGES.
; NOTE THAT ALL MAY NOT NECESSARILY BE LEGAL IN THIS PROGRAM

	.SAVE
	.PSECT	PURE

	.EVEN
LENTBL:	.WORD	NP.LEN+HD.LEN		; CMD #0 IS NOP
	.WORD	BP.LEN+HD.LEN		; CMD #1 IS BREAKPOINT TRAP
	.WORD	ST.LEN+HD.LEN		; CMD #2 IS STATUS REQUEST
	.WORD	SR.LEN+HD.LEN		; CMD #3 IS STATUS RESPONCE
	.WORD	SU.LEN+HD.LEN		; CMD #4 IS STATUS UPDATE
	.WORD	AK.LEN+HD.LEN		; CMD #5 IS ACK
	.WORD	NK.LEN+HD.LEN		; CMD #6 IS NACK
	.WORD	PD.LEN+HD.LEN		; CMD #7 IS PAUSE SERVER
	.WORD	CD.LEN+HD.LEN		; CMD #10 IS CONTINUE SERVER
	.WORD	JB.LEN+HD.LEN		; CMD #11 IS DEFINE A JOB
	.WORD	MD.LEN+HD.LEN		; CMD #12 IS MODIFY A JOB
	.WORD	KL.LEN+HD.LEN		; CMD #13 IS KILL A JOB
	.WORD	EJ.LEN+HD.LEN		; CMD #14 IS END OF JOB
	.WORD	FT.LEN+HD.LEN		; CMD #15 IS FONT
	.WORD	ON.LEN+HD.LEN		; CMD #16 IS ON LINE AND GOTO SPLIDL
	.WORD	OC.LEN+HD.LEN		; CMD #17 IS ON LINE CONFIRM
	.WORD	OF.LEN+HD.LEN		; CMD #20 IS OFFLINE
	.WORD	SY.LEN+HD.LEN		; CMD #21 IS SYNC
	.WORD	ID.LEN+HD.LEN		; CMD #22 IS INITIALIZE SERVER
	.WORD	MS.LEN+HD.LEN		; CMD #23 IS MODIFY SERVER
	.WORD	DD.LEN+HD.LEN		; CMD #24 IS DELETE SERVER
	.WORD	IQ.LEN+HD.LEN		; CMD #25 IS INITIALIZE QUEUE
	.WORD	MQ.LEN+HD.LEN		; CMD #26 IS MODIFY QUEUE
	.WORD	DQ.LEN+HD.LEN		; CMD #27 IS DELETE QUEUE
	.WORD	PQ.LEN+HD.LEN		; CMD #30 IS PAUSE QUEUE
	.WORD	CQ.LEN+HD.LEN		; CMD #31 IS CONTINUE QUEUE
	.WORD	AS.LEN+HD.LEN		; CMD #32 IS ASSIGN QUEUE
	.WORD	DS.LEN+HD.LEN		; CMD #33 IS DEASSIGN QUEUE

.SBTTL	SPLTBL	- INITIAL STATE TABLE FOR SPOOLER MESSAGE

; IN THIS STATE WE WAIT FOR A CONNECT CONFERM FROM THE QMAN.
; WE THEN PROCEDE TO THE IDLE LOOP FOR THE SPOOLER.
; 
;	NEXT STATE	ACTION	

SPLTBL:	.WORD	0,	RETURN		; CMD #0 IS NOP
	.WORD	0,	.BPT		; CMD #1 IS BREAKPOINT TRAP
	.WORD	0,	0		; CMD #2 IS STATUS REQUEST
	.WORD	0,	0		; CMD #3 IS STATUS RESPONCE
	.WORD	0,	0		; CMD #4 IS STATUS UPDATE
	.WORD	0,	0		; CMD #5 IS ACK
	.WORD	0,	0		; CMD #6 IS NACK
	.WORD	0,	0		; CMD #7 IS PAUSE SERVER
	.WORD	0,	0		; CMD #10 IS CONTINUE SERVER
	.WORD	0,	0		; CMD #11 IS DEFINE A JOB
	.WORD	0,	0		; CMD #12 IS MODIFY A JOB
	.WORD	0,	0		; CMD #13 IS KILL A JOB
	.WORD	0,	0		; CMD #14 IS END OF JOB
	.WORD	0,	0		; CMD #15 IS FONT
	.WORD	0,	0		; CMD #16 IS ON LINE (AND GOTO SPLIDL)
	.WORD	SPLIDL,	SPONC		; CMD #17 IS ON LINE CONFIRM
	.WORD	0,	SPOFL		; CMD #20 IS OFFLINE
	.WORD	0,	0		; CMD #21 IS SYNC ERROR DETECTED
	.WORD	0,	0		; CMD #22 IS INITIALIZE SERVER
	.WORD	0,	0		; CMD #23 IS MODIFY SERVER
	.WORD	0,	0		; CMD #24 IS DELETE SERVER
	.WORD	0,	0		; CMD #25 IS INITIALIZE QUEUE
	.WORD	0,	0		; CMD #26 IS MODIFY QUEUE
	.WORD	0,	0		; CMD #27 IS DELETE QUEUE
	.WORD	0,	0		; CMD #30 IS PAUSE QUEUE
	.WORD	0,	0		; CMD #31 IS CONTINUE QUEUE
	.WORD	0,	0		; CMD #32 IS ASSIGN QUEUE
	.WORD	0,	0		; CMD #33 IS DEASSIGN QUEUE

	.ASSUME	QS.NOP EQ 0.
	.ASSUME	QS.BPT EQ 1.
	.ASSUME	QS.STA EQ 2.
;	.ASSUME	QS.RSP EQ 3.
;	.ASSUME	QS.STU EQ 4.
	.ASSUME	QS.ACK EQ 5.
	.ASSUME	QS.NCK EQ 6.
	.ASSUME	QS.PDV EQ 7.
	.ASSUME	QS.CDV EQ 8.
	.ASSUME	QS.JOB EQ 9.
	.ASSUME	QS.MOD EQ 10.
	.ASSUME	QS.KIL EQ 11.
;	.ASSUME	QS.EOJ EQ 12.
	.ASSUME	QS.FNT EQ 13.
;	.ASSUME	QS.ONL EQ 14.
	.ASSUME	QS.ONC EQ 15.
	.ASSUME	QS.OFL EQ 16.
;	.ASSUME	QS.SYN EQ 17.
;	.ASSUME QS.IDV EQ 18.
;	.ASSUME QS.DDV EQ 19.
	.ASSUME QS.MAX EQ 34

.SBTTL	SPLIDL	- IDLE LOOP STATE TABLE FOR SPOOLER MESSAGE

; THIS IS THE IDLE LOOP STATE FOR ANY SPOOLERS, AT THIS POINT THE 
; SPOOLER IS ON LINE BUT WE DON'T HAVE ANY JOB STARTED.
; WE ARE WAITING FOR A JOB TO START TO BE SENT.
;
;	NEXT STATE	ACTION

SPLIDL:	.WORD	0,	RETURN		; CMD #0 IS NOP
	.WORD	0,	.BPT		; CMD #1 IS DEBUG
	.WORD	0,	SPSRQ		; CMD #2 IS STATUS SETFUN
	.WORD	0,	0		; CMD #3 IS STATUS RESPONCE
	.WORD	0,	0		; CMD #4 IS STATUS UPDATE
	.WORD	0,	0		; CMD #5 IS ACK
	.WORD	0,	0		; CMD #6 IS NACK
	.WORD	0,	SPPAU		; CMD #7 IS PAUSE
	.WORD	0,	SPCON		; CMD #10 IS CONTINUE
	.WORD	SPLJOB,	SPJOB		; CMD #11 IS QUE A JOB
	.WORD	0,	0		; CMD #12 IS MODIFY A JOB
	.WORD	0,	0		; CMD #13 IS KILL A JOB
	.WORD	0,	0		; CMD #14 IS END OF JOB
	.WORD	0,	0		; CMD #15 IS FORM
	.WORD	0,	0		; CMD #16 IS ON LINE
	.WORD	0,	0		; CMD #17 IS ON LINE CONFIRM
	.WORD	0,	SPOFL		; CMD #20 IS OFFLINE
	.WORD	0,	0		; CMD #21 IS SYNC ERROR DETECTED
	.WORD	0,	0		; CMD #22 IS INITIALIZE SERVER
	.WORD	0,	0		; CMD #23 IS MODIFY SERVER
	.WORD	0,	0		; CMD #24 IS DELETE SERVER
	.WORD	0,	0		; CMD #25 IS INITIALIZE QUEUE
	.WORD	0,	0		; CMD #26 IS MODIFY QUEUE
	.WORD	0,	0		; CMD #27 IS DELETE QUEUE
	.WORD	0,	0		; CMD #30 IS PAUSE QUEUE
	.WORD	0,	0		; CMD #31 IS CONTINUE QUEUE
	.WORD	0,	0		; CMD #32 IS ASSIGN QUEUE
	.WORD	0,	0		; CMD #33 IS DEASSIGN QUEUE

.SBTTL	SPLJOB	- JOB RUNNING STATE

; WE HAVE STARTED THE JOB, AND ARE WAITING FOR IT TO FINISH OR TO RECIEVE
; AN ABORT TYPE SETFUN
;
;	NEXT STATE	ACTION

SPLJOB:	.WORD	0,	RETURN		; CMD #0 IS NOP
	.WORD	0,	.BPT		; CMD #1 IS DEBUG
	.WORD	0,	SPSRQ		; CMD #2 IS STATUS SETFUN
	.WORD	0,	0		; CMD #3 IS STATUS RESPONCE
	.WORD	0,	0		; CMD #4 IS STATUS UPDATE
	.WORD	0,	0		; CMD #5 IS ACK
	.WORD	0,	0		; CMD #6 IS NACK
	.WORD	0,	SPPAU		; CMD #7 IS PAUSE
	.WORD	0,	SPCON		; CMD #10 IS CONTINUE
	.WORD	0,	0		; CMD #11 IS QUE A JOB
	.WORD	0,	0		; CMD #12 IS MODIFY A JOB
	.WORD	0,	SPKIL		; CMD #13 IS KILL A JOB
	.WORD	0,	0		; CMD #14 IS END OF JOB
	.WORD	0,	0		; CMD #15 IS FORM
	.WORD	0,	0		; CMD #16 IS ON LINE
	.WORD	0,	0		; CMD #17 IS ON LINE CONFIRM
	.WORD	0,	SPOFL		; CMD #20 IS OFFLINE
	.WORD	0,	0		; CMD #21 IS SYNC ERROR DETECTED
	.WORD	0,	0		; CMD #22 IS INITIALIZE SERVER
	.WORD	0,	0		; CMD #23 IS MODIFY SERVER
	.WORD	0,	0		; CMD #24 IS DELETE SERVER
	.WORD	0,	0		; CMD #25 IS INITIALIZE QUEUE
	.WORD	0,	0		; CMD #26 IS MODIFY QUEUE
	.WORD	0,	0		; CMD #27 IS DELETE QUEUE
	.WORD	0,	0		; CMD #30 IS PAUSE QUEUE
	.WORD	0,	0		; CMD #31 IS CONTINUE QUEUE
	.WORD	0,	0		; CMD #32 IS ASSIGN QUEUE
	.WORD	0,	0		; CMD #33 IS DEASSIGN QUEUE

	.RESTORE

.SBTTL	PRTSER	- THE ROOT OF THE PRINT SERVER

	.PSECT	PRTSER,RO,CON

	DEBUG	OFF		;ENABLE DEBUGING OR NOT

	.ENABL	LSB

PRTSER::NOP			;GOOD FOR NOTHING, BUT IT'S NICE TO HAVE
	MOV	@UCNTXT,R5	;GET USER CONTEXT WORD 0=FIRST TIME
	BNE	10$		;BR IF NOT FIRST TIME
	CALL	PRINIT		;FIRST TIME TROUGH - DO INITIAL SET UP
	MOV	SP,INITSP(R5)	;SAVE INITIAL STATE OF STACK POINTER
10$:	CLR	R1		;CLEAR INDEX COUNTER
	MOV	@UCNTXT,R5	;MAKE SURE R5 IS ALWAYS SET CORRECTLY
	MOV	INITSP(R5),SP	;ENSURE A CLEAN STACK (FROM INITIAL SETTING)
	MOV	R5,R2		;GET BASE OF IMPURE AREA
	ADD	#DSPBIT,R2	;ADD OFFSET TO DISPATCH BITS TABLE
	MOV	R2,R0		;SAVE COPY OF POINTER TO TABLE
20$:	TSTB	(R2)		;ANY BITS SET IN THIS BYTE?
	BNE	30$		;YES, DO IT THE HARD WAY
	ADD	#8.,R1		;NO, SHOW ADD 8. BITS WORTH TO INDEX COUNTER
	INC	R2		;AND POINT TO NEXT BYTE
	BR	20$		;NOW GO TRY IT

30$:	MOV	#1,R3		;PRESET TO CHECK FIRST BIT
40$:	BITB	R3,(R2)		;IS THIS BIT SET?
	BNE	50$		;YES SO GO DO IT
	INC	R1		;UP INDEX COUNTER
	ASLB	R3		;SLIDE THE TEST BIT OVER
	BCC	40$		;BR IF WE HAVE NOT EXAUSED THIS BYTE
	INC	R2		;INCREMENT TABLE POINTER TO NEXT BYTE
	BR	20$		;AND GO BACK FOR THE NEXT BYTE

50$:	CMP	#$DSMAX,R1	;IS THE FUNCTION CODE IN RANGE?
	BHIS	60$		;IS OK IF MAX IS GREATER
	CRASH			;OTHER WISE CRASH CUZ WE IS CORRUPTED

60$:	BICB	R3,(R2)		;CLEAR THE DISPAT BIT PRIOR TO CALL
	ASL	R1		;MAKE INDEX COUNTER * 2
;
; R0 POINTES TO FUNCTION BITS AT TIME OF FOLLOWING CALL
; R5 POINTES TO OUR IMPURE AREA
;
	CHKFRE			;VERIFY THE FREE LIST
	MOV	R1,L3QJOB(R5)	;SAVE SUBFUN NUMBER IN CASE OF TROUBLE
	CALL	@$DSPAT(R1)	;CALL ROUTINE IN DISPAT TABLE
	CHKFRE			;VERIFY THE FREE LIST
	BR	10$		;AND GO DO THE SCAN AGAIN

	GLOBAL	<UCNTXT>

	.DSABL	LSB

.SBTTL	PRINIT	- 1 SHOT INIT CODE FOR PRINT SERVER

;+
;
; PRINIT:
;
;
; INPUTS:
;
;	NONE
;
; CALL:
;	JSR	PC,PRINIT
;
;
; BACK:
;
;		R5,UCNTXT -> IMPURE AREA
;			WITH PRTSER DISPATCH WORDS FILLED IN
;			AND THE DUMMY RECEIVER ID FILLED IN
;			AND BUFFER POOL SET UP FOR RMS ROUTINES
;			AND ERROR HANDLER
;
;
;	ONLY RETURN IF SUCCESS
;	ON FAILURE CRASH SPOOLER
;
;-

PRINIT:	MOV	#SARGSIZ,R1		;COM BLOCK FOR RMS INTERFACE+RW FOR US
	GETBUF	R0,R1,CLEAR		;GO GET US A BUFFER
	BCC	20$	
10$:	CRASH				;NO BUFFER THEN CRAP OUT

20$:	MOV	R0,R5			;PUT POINTER TO BLOCK INTO R5
	MOV	R5,@UCNTXT		;SAVE POINTER TO COM BLOCK IN UCNTXT
	MOV	R1,(R5)			;LENGTH GOES IN FIRST WORD OF BLOCK
	MOV	#$DSBIT,R0		;GET POINTER TO PRTSER DISPATCH BITS
	MOV	#$DSBYT,R1		;AND LENGTH OF BITS IN BYTES
	MOV	R5,R2			;GET POINTER TO START OF IMPURE
30$:	MOVB	(R0)+,DSPBIT(R2)	;COPY THEM INTO THE IMPURE AREA
	INC	R2			;UP THE POINTER
	SOB	R1,30$			;UNTILL DONE
	MOV	#RIBNAM,R0		;get ptr to template rib name	;026
	MOV	R5,R1			;get base of impure area	;026
	ADD	#RECVID,R1		;R1 -> saved rcvr name		;026
	MOVSTR	R0,R1,#6		;copy name into impure area	;026
	PUSH	R5			;save base of impure area	;026
	MOV	R1,R5			;get pointer to saved rcvr name	;026
	ADD	#RIBJOB,R5		;R5 -> job number chars in name	;026
	MOV	JOBNUM,R3		;R3 =  RSTS job number		;026
	CMP	R3,#10.			;2-digit job no.?		;026
	BHIS	40$			;yes, so continue		;026
	INC	R5			;no, so skip over tens digit	;026
40$:	CALLX	BIN2D			;convert job number to ASCII	;026
	POP	R5			;restore base of impure area	;026
	MOV	R5,R2			;SAVE R5 IN R2
	SUBRIB	QRIB(R2)		;GET OUR SUBRIB NUMBER
	MOV	#SPLTBL,SP.STA(R5)	;SET UP THE INITIAL STATE
	MOV	#512.,R1		;SIZE OF OUTPUT BUFFER
..OBLN==.-2		; ** PATCH TO CHANGE SIZE OF OUTPUT BUFFER
	GETBUF	R0,R1,CLEAR		;ALLOCATE THE OUTPUT BUFFER
	BCS	10$			;ON FAILURE CRASH
	MOV	R0,OUTBUF(R5)		;SAVE IT'S ADDRES
	MOV	R0,OUTPTR(R5)		;RESET IT'S  INPUT POINTER
	MOV	R0,OUTPOS(R5)		;RESET IT'S OUTPUT POINTER
	MOV	R1,OUTBLN(R5)		;SAVE LENGTH OF OUTPUT BUFFER
	MOV	R1,FREE(R5)		;RESET THE COUNT OF FREE SPACE
	CALLX	RMSINIT			;INIT RMS AND BUFFER POOL
	MOV	REC(R5),RECPTR(R5)	;SET WORK COPY OF BUFFER LOC
	MOVB	#FIL.LEN,ENTBUF(R5)	; Set length
	MOVB	#FIL.LEN,FILBUF(R5)	;    fields for 
	MOVB	#<3.+4.+3.>,JCPBUF(R5)	;       the Splat
	MOVB	#<3.+4.+3.>,FCPBUF(R5)	;          line buffer
	MOVB	#NAM.LEN,DEVBUF(R5)	;
	MOVB	#NAM.LEN,FRMBUF(R5)	;
	MOVB	#<9.+1.+8.>,DATBUF(R5)	;
	MOVB	#28.,SYSBUF(R5)		;
;	CLRB	ACTBUF(R5)		; Assumed 0
;	CLRB	PPNBUF(R5)		;
	CALLR	SAVSYS			;save system name		;030
;	RETURN				;exit

	GLOBAL	<JOBNUM,UCNTXT>

.SBTTL	RIBNAM	- DEFINE RECEIVER NAME FORMAT FOR PRTSER

	.SAVE
	.PSECT	IMPURE

	.EVEN
RIBNAM:	.ASCII	"PR$"		;fixed part of receiver name		;026
RIBJOB	= .-RIBNAM		;offset to job number chars in name	;026
	.ASCII	"00"		;job number in ASCII (2 digits)		;026
RIBIDX	= .-RIBNAM		;offset to index char in name		;026
	.ASCII	"A"		;server index in ASCII (A-Z)		;026

	.EVEN
	.RESTORE

.SBTTL	GETMSG	- GET MESSAGE AND DISPATCH ON IT

;+
;
; GETMSG:
;
; INPUTS:
;		R0 -> FUNCTION BITS TABLE
;		R1 =  RIB NAME TO RECEIVE MSG
;		R4 =  PRIVED SENDER ONLY FLAG
;		R5 -> IMPURE AREA
;
; CALL:
;	JSR	PC,GETMSG
;
; BACK:
;
;		C=0 message received and set up
;			MSGPTR(R5) -> message buffer
;			MSGLEN(R5) =  message length
;		C=1 none or bad message
;		All regs preserved
;
;-

	.ENABL	LSB

GETMSG:	PUSH	<R0,R1>			;save some work regs
	TST	MSGPTR(R5)		;do we already have a message?
	BNE	80$			;yes so can't get another
10$:	RECV	R1			;receive message without data
	MOVBYT	FIRQB+0,R0		;R0 = error status
	BEQ	30$			;no error, so continue
	CMP	#NOSUCH,R0		;error of no message?
	BEQ	80$			;yes, so exit with error
	CMP	#BADFUO,R0		;no, rib not there?
	BEQ	80$			;yes, so exit with error
20$:	CRASH				;unexpected error, so crash

30$:	MOV	@#FIRQB+12,R1		;get length of pending message
	BEQ	80$			;nothing there, so exit with error
	MOV	R1,-(SP)		;save pending message length
	GETBUF	R0,R1,CLEAR		;get a cleared buffer
	BCS	20$			;failed, so crash
	MOV	R0,MSGPTR(R5)		;save pointer to message buffer
	MOV	R1,MSGLEN(R5)		;  and it's length
	ADD	R0,(SP)			;compute byte past message
	DEC	(SP)			;point to last byte in message
	MOV	(SP)+,MSGEND(R5)	;save message end addr
	MOV	(SP),R1			;restore RIB number
	RECV	R1,MSGPTR(R5),MSGLEN(R5),#BIT1 ;receive message data
	MOVBYT	FIRQB+0,R0		;R0 = error status
	BEQ	60$			;no error, so continue
40$:	RETBUF	MSGPTR(R5),MSGLEN(R5)	;return the wasted effort
	CLR	MSGPTR(R5)		;show no message buffer
	CLR	MSGLEN(R5)		;  and no buffer length
50$:	BR	80$			;exit with error

60$:	CMPB	#-11.,@#FIRQB+FQFIL	;was it a send with privs?
	BNE	40$			;no, so go return buffer & fail
	MOV	R5,R1			;yes, get copy of impure area pointer
	ADD	#PPN,R1			;R1 -> saved PPN in impure area
	MOV	FIRQB+FQPPN,(R1)+	;save sender's PPN
	MOVB	FIRQB+FQSIZM,(R1)+	;save sender's job no. times 2
.ASSUME	PPN+2	EQ	JBNO		;ensure JBNO follows PPN field
	MOVB	FIRQB+FQNAM1,(R1)+	;save sender's KB no.
.ASSUME	JBNO+1	EQ	KBNO		;ensure KBNO follows JBNO field
	MOVSTR	#FIRQB+FQEXT,R1,#<PRVSIZ*2.> ;store the sender's priv mask
.ASSUME	KBNO+1	EQ	PRIV		;ensure PRIV follows KBNO field
	TST	R4			;are sender privs required?
	BEQ	70$			;no, so exit
	MOV	#PBSPRV,R1		;yes, get required privs mask
	MUTEXC	R1,#FIRQB+FQEXT,#<PRVSIZ*2.> ;is sender prived enough?
	BCS	40$			;no, so trash it

70$:	TST	(PC)+			;clear carry for success
80$:	SEC				;set carry for error/no message
	POP	<R1,R0>			;restore regs
	RETURN				;and exit

GLOBAL	<NOSUCH,BADFUO,PBSPRV>

.SBTTL	QMMSG	- GET MESSAGE FROM QUEUE MANAGER AND DISPATCH ON IT

;+
;
; QMMSG:
;
;
; INPUTS:
;
;		R0 -> FUNCION BITS TABLE
;		R5 -> IMPURE AREA
;
; CALL:
;	JSR	PC,QMMSG
;
;
; BACK:
;
;		OUR MESSAGE DECODED AND DISPATCHED
;		RETURN AFTER DECODE OR NO MESSAGE
;
;-

	.ENABL	LSB

QMMSG:	MOVB	QRIB(R5),R1		;set up RIB number for receive
	MOV	#-1,R4			;sender must be priv'd		;029
	CALL	GETMSG			;go try to get the message
10$:	BCS	100$			;if none there or error go back
	CMP	MSGLEN(R5),#HD.LEN	;is message at least the min length?
	BLO	JMPRET			;no, so chuck it
	MOV	MSGPTR(R5),R1		;get pointer to message
	CMPB	HD.VER(R1),#P.VER	;do message versions match?
	BNE	JMPRET			;no, so chuck it
	CLR	HD.FLG(R1)		;clear out a handy cell (flg+ver)
	CMPB	#1,HD.RTQ(R1)		;was return by job # requested?
	BNE	REDO			;no, so continue
	MOV	#1,HD.RTN(R1)		;yes, so set for return by job no.
	MOVBYT	@#FIRQB+5,HD.RTN+2(R1)	;save user's job number
	CLR	HD.RTN+4(R1)		;zero rest of rcvr field
REDO:	MOV	MSGPTR(R5),R1		;get pointer to message
	MOVBYT	HD.CMD(R1),R3		;get command code
	CMP	R3,#QS.MAX		;is it out of range?
	BHIS	JMPRET			;yes, so dump it
	ASL	R3			;convert to word offset
	CMP	MSGLEN(R5),LENTBL(R3)	;is message long enough?
	BLO	JMPRET			;no, so trash it
	ASL	R3			;compute offset into state table
	MOV	SAVSTA(R5),R4		;get the saved state table (if any)
	BNE	60$			;got one, so use it
	MOV	SP.STA(R5),R4		;none, so use current state table
60$:	PUSH	R4			;save table base
	ADD	R3,R4			;add our message offset to table
	POP	R3			;restore table base (from R4)
	TST	2(R4)			;legal command for this state?
	BEQ	JMPRET			;no, so chuck it
	TST	SAVSTA(R5)		;is this a redo?
	BNE	80$			;yes, no need to save any states
	MOV	R3,SAVSTA(R5)		;save the state for a possible retry
80$:	TST	(R4)			;are we going to change states?
	BEQ	90$			;no, so no change to state counters
	MOV	SP.STA(R5),SP.OSTA(R5)	;save current state as old state
	MOV	(R4),SP.STA(R5)		;and the new state
90$:	MOV	MSGPTR(R5),R1		;get pointer to message
	MOV	MSGLEN(R5),R2		;and length
	ADD	#HD.LEN,R1		;R1 -> message past header
	SUB	#HD.LEN,R2		;R2 =  message length less header
	CALL	@2(R4)			;call through dispatch tbl
	BCC	SNACK			;success, go send ACK and chuck message
	CMP	#ER$RLK,R1		;error, due to record lock?
	BNE	SNNAC			;no, so send NACK and chuck message
	SETFUN	S.REDO,R0		;yes, ask to re-do message
	STALL	#2			;and wait a few secs

JMPRET:	JMP	RETMSG			;go return current message buffer

100$:	RETURN

	.DSABL	LSB

.SBTTL	SNACK	- SEND BACK AN ACK
.SBTTL	SNNCK	- SEND BACK AN ACK

;+
;
; SNACK:
; SNNCK:
;
;
; INPUTS:
;
;		R5 -> IMPURE AREA
;		R0 -> FUNCION BITS TABLE
;
; CALL:
;	JSR	PC,SNACK
;	JSR	PC,SNNCK
;
;
; BACK:
;
;		ACK OR NACK MESSAGE QUEUED TO SENDER OR CURRENT
;		MESSAGE (IN MSGPTR(R5)) IF A RETURN RECIEPT WAS 
;		REQUESTED.
;
;		ALL REGESTERS TRASHED
;
;-

	.ENABL	LSB
                
SNACK:	MOV	#QU.ACK,R2		;SET FOR ACK
	BR	10$			;JOIN COMMON

SNNAC:	MOV	#QU.NCK,R2		;SET FOR NACK
	.BR	10$			;JOIN COMMON

10$:	CLR	SAVSTA(R5)		;CLEAR THE SAVED STATE
	MOV	MSGPTR(R5),R4		;GET POINTER TO MESSAGE
	BEQ	20$			;MESSAGE DISAPEARED, SO NO (N)ACK
	TSTB	HD.RTQ(R4)		;WAS RETURN RECIEPT REQUESTED?
	BEQ	20$			;NO

	SWAPR	R1,R2			;R1 SB CMD, R2 SB STS
	MOV	HD.FLG(R4),R3		;FLAG FIELD
	TST	JOBPTR(R5)		;Do we have a job?		;074
	BEQ	15$			;Nope				;074
	MOV	JOBPTR(R5),R3		;Yes, fetch the job record	;074
	MOV	HD.LEN+JB.FLG(R3),R3	;And return JB.FLG for NOTIFY	;074
15$:	CALL	SNDCMN			;GO SEND A COMMON FORMAT MESSAGE
20$:	.BR	RETMSG			;AND RETURN THE ORIGINAL PACKET BUFFER

	.DSABL	LSB

.SBTTL	RETMSG	- RETURN CURRENT MESSAGE BUFFER (IF ANY)

;+
;
; RETMSG:
;
;
; INPUTS:
;
;		R5 -> IMPURE AREA
;		R0 -> FUNCION BITS TABLE
;
; CALL:
;	JSR	PC,RETMSG
;
;		RETURN MESSAGES AS REQUESTED
;
;
; BACK:
;
;		ALL REGS PRESERVED
;		CARRY PRESERVED
;
;-

RETMSG:	PUSH	<R1,R2>
	ROR	-(SP)			;SAVE CARRY ON STACK
	MOV	MSGPTR(R5),R2		;POINTER TO MESSAGE PACKET
	MOV	MSGLEN(R5),R1		;AND LENGTH
	BEQ	10$			;NO MESSAGE SO DON'T RETURN BUFFER
	RETBUF	R2,R1			;RETURN THE BUFFER
10$:	CLR	MSGPTR(R5)		;SHOW BUFFER AS RETURNED
	ROL	(SP)+			;RESTORE CARRY FROM STACK
	POP	<R2,R1>
	RETURN

.SBTTL	SPPAU	- HANDLE PAUSE MESSAGE

;+
;
; SPPAU:
;
;
; INPUTS:
;
;		R0 -> FUNCION BITS TABLE
;		R1 -> MESSAGE PAST HEADER
;		R2  = LENGTH OF MESSAGE (MINUS HEADER)
;		R5 -> IMPURE AREA
;
; CALL:
;	JSR	PC,SPPAU
;
;		GET US INTO PAUSE STATE
;
;
; BACK:
;
;		C=0 
;
;		 ALL REGS PRESERVED
;
;-

	.ENABL	LSB

SPPAU:	MOV	PD.FLG(R1),DDPAUS(R5)	;save pause options		;020
	BNE	10$			;skip immediate pause if any 	;020
	BIC	#PD$IMM,DDPAUS(R5)	;ensure immediate bit clear	;034
	SETFUN	S.PAU,R0		;request immediate pause	;020
	SETFUN	S.EMTY,R0		;request empty output buffers	;020
10$:	SETFUN	S.PACN,R0		;request pause/continue handler	;020
	PUSH	RESPTR(R5)		;SET UP TO RETURN PREVIOUS PACKET
	PUSH	RESLEN(R5)		;SET UP TO RETURN PREVIOUS PACKET
	MOV	MSGPTR(R5),RESPTR(R5)	;STORE POINTER TO PACKET
	MOV	MSGLEN(R5),RESLEN(R5)	;AND IT'S LENGTH
	POP	MSGLEN(R5)		;RETURN PREVIOUS PACKET
	POP	MSGPTR(R5)		;..DITO
	CALLX	RETMSG			;GO RETURN THE OLD ONE
	MOV	RESPTR(R5),MSGPTR(R5)	;NOW POINT BACK TO CURRENT FOR SNACK
	CLR	MSGLEN(R5)		;BUT SHOW A LENGTH OF ZERO SO WE
					; DON'T RETURN THE BUFFER TWICE
	;CLC				; CARRY CLEAR FROM CLR ABOVE
	RETURN

	.DSABL	LSB

.SBTTL	SPCON	- HANDLE CONTINUE MESSAGE

;+
;
; SPCON:
;
;
; INPUTS:
;
;		R0 -> FUNCION BITS TABLE
;		R1 -> MESSAGE PAST HEADER
;		R2  = LENGTH OF MESSAGE (MINUS HEADER)
;		R5 -> IMPURE AREA
;
; CALL:
;	JSR	PC,SPCON
;
;		GET US INTO OR OUT OF PAUSE STATE
;
;
; BACK:
;
;		C=0 
;
;		 ALL REGS PRESERVED
;
;-

	.ENABL	LSB

SPCON:	CLRFUN	S.PAU,R0		;GET US OUT OF PAUSE STATE
	CLRFUN	S.PEOJ,R0		;CLRFUN ANY EOJ PAUSE STATE
	CLRFUN	S.PEOF,R0		;CLRFUN ANY EOF PAUSE STATE
	CLR	DDPAUS(R5)		;show no pause options		;020
	SETFUN S.PACN,R0		;SETFUN THE PAUSE/CONTINUE HANDLER
	SETFUN S.EMTY,R0		;EMPTY OUTPUT BUFFERS TO DEVICE
	PUSH	RESPTR(R5)		;SET UP TO RETURN PREVIOUS PACKET
	PUSH	RESLEN(R5)		;SET UP TO RETURN PREVIOUS PACKET
	MOV	MSGPTR(R5),RESPTR(R5)	;STORE POINTER TO PACKET
	MOV	MSGLEN(R5),RESLEN(R5)	;AND IT'S LENGTH
	POP	MSGLEN(R5)		;RETURN PREVIOUS PACKET
	POP	MSGPTR(R5)		;..DITO
	CALLX	RETMSG			;GO RETURN THE OLD ONE
	MOV	RESPTR(R5),MSGPTR(R5)	;NOW POINT BACK TO CURRENT FOR SNACK
	CLR	MSGLEN(R5)		;BUT SHOW A LENGTH OF ZERO SO WE
					; DON'T RETURN THE BUFFER TWICE
	;CLC				; CARRY CLEAR FROM CLR ABOVE
	RETURN

	.DSABL	LSB

.SBTTL	PAUCON	- HANDLE JOB PAUSE/CONTINUE OPTIONS

;+
;
; PAUCON:
;
;
; INPUTS:
;
;		R0 -> FUNCION BITS TABLE
;		R5 -> IMPURE AREA
;
; CALL:
;	JSR	PC,PAUCON
;
;		TAKE CARE OF ALL PAUSE/CONTINUE OPTIONS
;
;
; BACK:
;
;		C=0 
;
;		 ALL REGS PRESERVED
;
;-

PAUCON:	SAVREG
	MOV	RESPTR(R5),R1		;get pointer to restart packet
	ADD	#HD.LEN,R1		;offset past fixed header
	TST	PD.FLG(R1)		;does user want any special options?
	BEQ	20$			;nope, all done
	BIT	#J.JOB,JOBSTA(R5)	;is there a job in progress?
	BEQ	20$			;no, so no options are meaningfull
	BIT	#J.ABRT,JOBSTA(R5)	;are we already trying to abort?
	BNE	20$			;yes, so no options are meaningfull
	MOV	#CONOPT-2,R3		;get start of continue options table
	CMPB	#QS.CDV,HD.CMD-HD.LEN(R1) ;is it a continue packet?
	BEQ	10$			;yes, so continue
	MOV	#PAUOPT-2,R3		;no, use pause options table
10$:	TST	(R3)+			;point to correct start of next
	TST	(R3)			;at end of table yet?
	BEQ	20$			;yes so no options were selected
	BIT	(R3)+,PD.FLG(R1)	;is flag set?
	BEQ	10$			;no, try for next flag
	CALL	@(R3)			;yes, dispatch to the action routine
	CMPB	#QS.CDV,HD.CMD-HD.LEN(R1) ;is this a continue packet?
	BNE	20$			;no, then we are done
	BIT	#J.ESC,JOBSTA(R5)	;are we in the processing of controls?
	BEQ	20$			;no, then we are done
	MOVBYT	#234,R3			;get a string terminator <ST>
	TST	RECL(R5)		;Anything in buffer?
	BNE	15$			;Yes, we better preserve it
	MOVB	R3,@RECPTR(R5)		;stuff in <ST>
	INC	RECL(R5)		;and show the character is there
	BR	17$			;format and buffer it

15$:	CMP	REC(R5),RECPTR(R5)	;Is there room for the <ST>?
	BEQ	16$			;Not really, so trash a good character
	DEC	RECPTR(R5)		;otherwise, make room for the <ST>
	INC	RECL(R5)		;and show that it is there
16$:	MOVB	R3,@RECPTR(R5)		;put the <ST> in the input buffer
17$:	CALLR	PRINTD			;and buffer it

20$:	CLC				;exit
	RETURN

	.ASSUME	PD.FLG EQ CD.FLG	;used for both pause and continue

.SBTTL	PAUSE/CONTINUE OPTIONS TABLES

	.SAVE
	.PSECT	PURE

;+
; NOTE THAT THESE TABLES ARE PRIORITIZED; ONLY ONE OPTION IS
; LEGAL PER COMMAND. E.G., IF CD$NXT IS SELECTED THEN CD$TOF
; WILL BE IGNORED ETC...
;-

	.EVEN

;CONTINUE OPTIONS TABLE

CONOPT:	.WORD	CD$NXT,	ABTERR		;RESTART AT NEXT JOB (ABORT) /NEXT
	.WORD	CD$TOF,	RESTOF		;RESTART AT TOP-OF-FILE	     /TOP
	.WORD	CD$RES,	RESTOJ		;RESTART AT TOP-OF-JOB       /RESTART
	.WORD	CD$PAG,	RESFFN		;RESTART AT N BUT <FF> FIRST /PAGE=N
	.WORD	CD$FWD,	RESFFN		;RESTART RELATIVE, BUT <FF>  /FORWARD
	.WORD	CD$BWD,	RESFFN		;RESTART RELATIVE, BUT <FF>  /BACKSPACE
	.WORD	0

;PAUSE OPTIONS TABLE

PAUOPT:	.WORD	PD$EOJ,	PEOJ		;PAUSE AT END OF JOB   /JOB
	.WORD	PD$EOF,	PEOF		;PAUSE AT END OF FILE  /FILE
	.WORD	0

	.RESTORE

.SBTTL	RESTOJ	- SETUP RESTART AT TOP OF JOB
.SBTTL	RESTOF	- SETUP RESTART AT TOP OF FILE

;+
;
; RESTOJ:
; RESTOF:
;
;
; INPUTS:
;
;	R0 -> FUNCION BITS TABLE
;	R1 -> MESSAGE PAST HEADER
;	R2  = LENGTH OF MESSAGE (MINUS HEADER)
;	R5 -> IMPURE AREA
;
; CALL:
;
;	JSR	PC,RESTOJ
;	JSR	PC,RESTOF
;
;		TAKE CARE OF RESTART AT TOP OF JOB OR TOP OF FILE
;
; BACK:
;
;	C=0 
;
;	ALL REGS PRESERVED
;
;-

	.ENABL	LSB

RESTOJ:	PUSH	<R3,R1>
	CLR	R3			;SET R3 TO ZERO IF RESTART @ TOP OF JOB
	BR	10$			;JOIN COMMON

RESTOF:	PUSH	<R3,R1>
	MOV	SP,R3			;SET R3 TO NON-ZERO IF RES @ TOF
10$:	MOV	REC(R5),RECPTR(R5)	;erase stuff in buffer             ;054
	CLR	RECL(R5)		;-- since we don't care about it nomore
	MOV	REC(R5),R1		;get copy of rec pointer           ;054
	TST	DDHORZ(R5)		;Are we at the left margin?	;069
	BEQ	12$			;Yes, no need for a <CR>	;073
	MOVB	#CR$CR,(R1)+		;Stuff a <CR> into the buffer	;073
	INC	RECL(R5)		;Record the new buffer length	;073
12$:	CMP	DDVERC(R5),DDVERT(R5)	;Are we on the top line?	;073
	BNE	14$			;No, send a <FF>		;073
	BIT	#J.DRTY,JOBSTA(R5)	;Yes, is the page clean?	;073
	BEQ	16$			;Ayup.				;073
14$:	MOVB	#CR$FF,(R1)		;Stuff a <FF> into the buffer	;073
	INC	RECL(R5)		;Record the new buffer length	;073
16$:	MOV	#-1,INT2(R5) 		;Signal TOF to RMSGET		;073
	CLRFUN	S.OPN,R0		;Don't open any un-open files	;073
	BIT	#J.OPN,JOBSTA(R5)	;HAVE WE ALREADY OPENED IT?
	BEQ	20$			;NO
	CLRFUN	S.GET,R0		;YES,STOP PROCESSING CURRENT FILE
	DEC	FILCOP(R5)		;BACK UP 1 FILE COPY
20$:	SETFUN	S.EOF,R0		;START WITH A NEW JOB COPY
	TST	R3			;IS THIS A TOJ RESTART?
	BNE	30$			;NO, SO ALL DONE
	CLRFUN	S.EOF,R0		;STOP END OF FILE HANDLING
	CLRFUN	S.ERASE,R0		;STOP ERASEING
	CLRFUN	S.WLD,R0		;STOP WILD CARD HANDLER
	CLRFUN	S.EOFS,R0		;STOP NEXT FILE SPEC HANDLER
	CLRFUN	S.PGJH,R0		;STOP JOB HEADERS
	CLRFUN	S.PGJT,R0		;STOP JOB TRAILERS
	SETFUN	S.EOJC,R0		;START WITH A NEW JOB COPY
	TST	JOBCOP(R5)		;HAVE WE STARTED ANY COPIES?
	BEQ	30$			;NO
	DEC	JOBCOP(R5)		;YES, SO BACK UP ONE COPY
30$:	CLRFUN	S.PGFH,R0		;STOP ANY FILE HEADER PAGES
	CLRFUN	S.PGFT,R0		;STOP ANY FILE TRAILER PAGES
	POP	<R1,R3>
	CLC
	RETURN

	.DSABL	LSB

.SBTTL	RESFFN	- GET TO TOF BEFORE SETFUNING RESTART AT N

;+
;
; RESFFN:
;
;
; INPUTS:
;
;		R0 -> FUNCION BITS TABLE
;		R5 -> IMPURE AREA
;
; CALL:
;	JSR	PC,RESFFN
;
;		GET TO TOF PRIOR TO CALLING RESATN
;
;
; BACK:
;
;		C=?
;
;		 ALL REGS PRESERVED
;
;-

RESFFN:	SAVREG
	SETFUN	S.ATN,R0		;REQEST WE CONTINUE AT RESATN
	MOV	REC(R5),RECPTR(R5)	;erase stuff in buffer             ;054
	CLR	RECL(R5)		;-- since we don't care about it nomore
	MOV	REC(R5),R1		;get copy of record pointer	;076
	TST	DDHORZ(R5)		;Are we at the left margin?	;069
	BEQ	12$			;Yes, no need for a <CR>	;073
	MOVB	#CR$CR,(R1)+		;Stuff a <CR> into the buffer	;073
	INC	RECL(R5)		;Record the new buffer length	;073
12$:	CMP	DDVERC(R5),DDVERT(R5)	;Are we on the top line?	;073
	BNE	14$			;No, send a <FF>		;073
	BIT	#J.DRTY,JOBSTA(R5)	;Yes, is the page clean?	;073
	BEQ	16$			;Ayup.				;073
14$:	MOVB	#CR$FF,(R1)		;Stuff a <FF> into the buffer	;073
	INC	RECL(R5)		;Record the new buffer length	;073
16$:	MOV	#-1,INT2(R5) 		;Signal TOF to RMSGET		;073
	TST	RECL(R5)		;Anything to do?		;073
	BEQ	20$			;No.  Don't attempt the write	;073
	CALL	SAVOPT			;SAVE CURRENT FILE OPTIONS
	BIS	#LPTNOX!LPTHDR!LPTRES,DDFLAG(R5) ;AND FORCE /TRUNCATE ON HEADERS
	BIC	#LPTOVF,DDFLAG(R5)	;AND NO /SKIP_6
	CALLR	PRINTD			;GO PRINT IT FROM THE BUFFER

20$:	RETURN

.SBTTL	RESATN	- SETUP RESTART AT PAGE [+/-] N

;+
;
; RESATN:
;
;
; INPUTS:
;
;		R0 -> FUNCION BITS TABLE
;		R5 -> IMPURE AREA
;
; CALL:
;	JSR	PC,RESATN
;
;		TAKE CARE OF RESTART AT PAGE [+/-] N
;
;
; BACK:
;
;		C=0 
;
;		 ALL REGS PRESERVED
;
;-

RESATN:	SAVREG	
	MOV	RESPTR(R5),R1		;GET POINTER TO RESTART PACKET
	ADD	#HD.LEN,R1		;OFFSET PAST FIXED HEADER
	MOV	#1,R2			;ASSUME CURRENT PAGE OF 1
	CLR	R3			; .. WORD 2
	BIT	#J.OPN,JOBSTA(R5)	;IS ANY FILE OPEN?
	BEQ	10$			;NO, SO USE ZERO AS THE CURRENT
	MOV	DDPAG0(R5),R2		;GET REAL CURRENT PAGE COUNTER
	MOV	DDPAG1(R5),R3		;.. WORD 2
10$:	BIT	#CD$PAG,PD.FLG(R1)	;IS THIS A RELATIVE PAGE OFFSET?
	BNE	50$			;YES
	BIT	#CD$FWD,PD.FLG(R1)	;IS THIS A FORWARDSPACE?
	BNE	40$			;YES
					;NO, MUST BE A BACK_SPACE
	CMP	CD.PG1(R1),R3		;BEFORE BEGINING OF FILE?
	BHI	20$			;YES, SO JUST USE ZERO
	BLO	30$			;NO, IS IN THE FILE
	CMP	CD.PG0(R1),R2		;BEFORE BEGINING OF FILE?
	BLO	30$			;NO, USE REAL OFFSET

20$:	MOV	#RSTBEG,R4		;START AT BEGINING OF FILE
	ADD	R5,R4			;PLUS ADDR OF IMPURE
	MOV	#1,R2			;SET PAGE NUMBER OF 1
	CLR	R3			;HIGH WORD ZERO
	BR	110$			;AND DO IT

30$:	SUB	CD.PG0(R1),R2		;SUB THE NEGATIVE OFFSET
	SBC	R3			;TAKE CARE OF OVER FLOW
	SUB	CD.PG1(R1),R3		;AND DO THE 2'ND WORD
	BR	60$			;NOW JOIN COMMON

40$:	ADD	CD.PG0(R1),R2		;ADD THE POSITIVE OFFSET
	ADC	R3			;TAKE CARE OF OVER FLOW
	ADD	CD.PG1(R1),R3		;AND DO THE 2'ND WORD
	BR	60$			;NOW JOIN COMMON

50$:	MOV	CD.PG0(R1),R2		;USE THE PAGE NUMBER USER ASKED FOR
	MOV	CD.PG1(R1),R3		; .. WORD 2
60$:	MOV	R5,R1			;GET BASE OF IMPURE
	ADD	#RSTBEG,R1		;NOW IS BASE OF RESTART TABLE
	MOV	R1,R4			;THIS IS THE BEST FOUND SO FAR..
	TST	R3			;IS THIS A RESTART AT BEGINING?
	BNE	70$			;NO
	CMP	R2,#1			;IS THIS STILL A RESTART AT PAGE 1
	BLOS	20$			;YES DO RESTART AT BEGINING

70$:	MOV	#RSTENT,R0		;COUNTER OF TABLE ENTRIES
80$:	CMP	RPAG1(R1),R3		;IS THIS PAGE IN RANGE?
	BHI	100$			;NOPE TOO HIGH
	CMP	RPAG1(R1),RPAG1(R4)	;IS IT BETTER THAN THE OLD ONE?
	BHI	90$			;YES, SO USE THE NEW ONE
	BLO	100$			;NO, IS WORSE
	CMP	RPAG0(R1),R2		;IS THE NEW ONE IN RANGE?
	BHIS	100$			;NOPE TOO HIGH
	CMP	RPAG0(R1),RPAG0(R4)	;IS IT BETTER THEN THE OLD?
	BLOS	100$			;NOPE, USE OLD ONE
90$:	MOV	R1,R4			;YES, IS BETTER USE NEW ONE
100$:	ADD	#RSIZ,R1		;POINT TO NEXT ENTRY
	SOB	R0,80$			;AND TRY FOR NEXT ENTRY

110$:	; R4 NOW BEST LEGAL
	BIS	#LPTRES,DDFLAG(R5)	;PUT US INTO RESTART
	MOV	RLIN(R4),DDVERT(R5)	;Set up new current line number	;069
	MOV	RPOS(R4),DDHORZ(R5)	;Set up new current CCPOS	;069
	MOV	RPAG0(R4),DDPAG0(R5)	;SET UP NEW CURRENT PAGE COUNTER
	MOV	RPAG1(R4),DDPAG1(R5)	;SET UP NEW CURRENT PAGE COUNTER
	MOV	R2,RESPG0(R5)		;PAGE TO RE-ENABLE PRINT AT
	MOV	R3,RESPG1(R5)		;.. WORD 2
	MOV	RAB(R5),R1		;GET POINTER TO INPUT FILE RAB
	ADD	#RRFA,R4		;POINT TO TARGET RFA
	CLR	R2			;ACUMULATOR FOR RFA BITS
	MOV	(R4),O$RFA(R1)		;STORE THE RFA INTO THE RAB
	BIS	(R4)+,R2		;PICK UP THE BITS
	MOV	(R4),O$RFA+2(R1)	;STORE THE RFA INTO THE RAB
	BIS	(R4)+,R2		;PICK UP THE BITS
	MOV	(R4),O$RFA+4(R1)	;STORE THE RFA INTO THE RAB
	BIS	(R4)+,R2		;PICK UP THE BITS
	TST	R2			;WAS THERE AN RFA?
	BEQ	120$			;NO, HAVENT'READ FIRST RECORD YET
	$STORE	#RB$RFA,RAC,R1		;AND SET NEXT GET TO GET BY RFA
120$:	RETURN

.SBTTL	PEOJ	- SET UP FOR PAUSE AT END-OF-JOB

;+
;
; PEOJ:
;
;
; INPUTS:
;
;		R0 -> FUNCION BITS TABLE
;		R5 -> IMPURE AREA
;
; CALL:
;	JSR	PC,PEOJ
;
;		SET UP FOR PAUSE AT END-OF-JOB
;
;
; BACK:
;
;		 ALL REGS PRESERVED
;
;-

PEOJ:	CLRFUN	S.PAU,R0		;CLRFUN IMMEDIATE PAUSE STATE
	SETFUN	S.PEOJ,R0		;SETFUN PAUSE AT EOJ STATE
	RETURN

.SBTTL	PEOF	- SET UP FOR PAUSE AT END-OF-FILE

;+
;
; PEOF:
;
;
; INPUTS:
;
;		R0 -> FUNCION BITS TABLE
;		R5 -> IMPURE AREA
;
; CALL:
;	JSR	PC,PEOF
;
;		SET UP FOR PAUSE AT END OF FILE
;
;
; BACK:
;
;		 ALL REGS PRESERVED
;
;-

PEOF:	CLRFUN	S.PAU,R0		;CLRFUN IMMEDIATE PAUSE STATE
	SETFUN	S.PEOF,R0		;SETFUN PAUSE AT EOF STATE
	RETURN

.SBTTL	.BPT	- ENTER DEBUGER IF DEBUGER PRESENT, ELSE IGNORE

;+
;
; .BPT:
;
;
; INPUTS:
;		NONE
;
; CALL:
;	JSR	PC,.BPT
;
;		DEBUGER CALLED IF THERE AND USER IS OPER
;
;
; BACK:
;
;		C=0 DEBUGER CALLED
;		C=1 NO DEBUGER
;		ERROR IN R1
;		 ALL OTHER REGS PRESERVED
;
;-

	.ENABL	LSB

.BPT:	TST	@#R.ODTV		;IS A DEBUGER PRESENT? (TST R.ODTV)
	BEQ	10$			;NO SO DON'T BPT
	BPT				;YES,GO TO DEBUGER
	MOV	#SU$SUC,R1		;SET STATUS TO SUCCESS
RETURN:	TST	(PC)+			;AND CLEAR CARRY PRIOR TO RETURN
10$:	SEC				;SET CARRY CUZ NO DEBUGER
	RETURN

	R.ODTV=112			;ADDR OF ODT SST VECTOR

	.DSABL	LSB

.SBTTL	SPONC	- ON LINE CONFIRMATION RECIEVED FROM QMAN

;+
;
; SPONC:
;
;
; INPUTS:
;
;		R0 -> FUNCION BITS TABLE
;		R1 -> MESSAGE PAST HEADER
;		R2  = LENGTH OF MESSAGE (MINUS HEADER)
;		R5 -> IMPURE AREA
;
; CALL:
;	JSR	PC,SPONC
;
;		SID SAVED 
;
; BACK:
;
;		C=0 SUCCESS
;		C=1 FAILURE
;		ERROR IN R1
;		 ALL OTHER REGS PRESERVED
;
;-

SPONC:	MOV	OC.STS(R1),SP.SID(R5)	;SAVE QMANS QID
	BIS	#J.ONL,JOBSTA(R5)	;SHOW US ONLINE TO QMAN
	CLC
	RETURN

.SBTTL	SPJOB	- JOB DEFINITION MESSAGE RECIEVED

;+
;
; SPJOB:
;
;
; INPUTS:
;
;		R0 -> FUNCION BITS TABLE
;		R1 -> MESSAGE PAST HEADER
;		R2  = LENGTH OF MESSAGE (MINUS HEADER)
;		R5 -> IMPURE AREA
;
; CALL:
;	JSR	PC,SPJOB
;
;		MESSAGE VALIDATED
;		STATE TRANSITION REJECTED IF VALIDATION FAILED
;		MESSAGE SAVED IN JOBMSG IF VALIDATION PASSED AND
;			ANY PREVIOUS JOB MESSAGE DISCARDED
;
; BACK:
;
;		C=0 SUCCESS
;		C=1 FAILURE
;		ERROR IN R1
;		 ALL OTHER REGS PRESERVED
;
;-


SPJOB:	SAVREG
	MOV	#JS$SUC,EOJSTS(R5)	;Preset entry's EOJ STS to success ;074
	MOV	JB.FIL(R1),R4		;GET OFFSET TO NEXT FILE AREA
20$:	MOV	R4,R2			;GET A SCRATCH COPY
	TST	R2			;IS IT A POSITIVE OFFSET?
	BLT	BNACK			;NO SO NACK IT
	BEQ	30$			;NONE SO EXIT
	CMP	R2,MSGLEN(R5)		;IS IT INSIDE OF MESSAGE?
	BHI	BNACK			;NO SO ERROR
	BIT	#1,R2			;IS IT PROPERLY WORD ALLIGNED?
	BNE	BNACK			;NO SO NACK IT
	ADD	#FB.SPL-FB.NXT,R2	;ADD OFFSET TO ADDR OF FILE SPEC
	CMP	R2,MSGLEN(R5)		;IS IT INSIDE OF MESSAGE?
	BHI	BNACK			;NO SO ERROR
	ADD	R1,R2			;ADD BASE TO OFFSET TO FILE SPEC
	MOVBYT	(R2)+,R3		;get length of file spec	;025
	ADD	R2,R3			;NOW IS ADDR OF END OF SPEC
	SUB	R1,R3			;AND FINALLY IS LENGTH TO END
	CMP	R3,MSGLEN(R5)		;IS IT INSIDE OF MESSAGE?
	BHI	BNACK			;NO SO ERROR
	ADD	R1,R4			;GET ADDR OF OFFSET TO NEXT
	MOV	(R4),R4			;GET THE NEXT OFFSET
	BR	20$			;AND GO CHECK IT OUT AS WELL

30$:	MOV	JB.PGL(R1),PGLIM0(R5)	;save page limit lsb		;021
	MOV	JB.PGM(R1),PGLIM1(R5)	;save page limit msb		;021
	PUSH	JOBPTR(R5)		;SET UP TO RETURN PREVIOUS JOB PACKET
	PUSH	JOBLEN(R5)		;SET UP TO RETURN PREVIOUS JOB PACKET
	MOV	MSGPTR(R5),JOBPTR(R5)	;STORE POINTER TO JOB
	MOV	MSGLEN(R5),JOBLEN(R5)	;AND IT'S LENGTH
	POP	MSGLEN(R5)		;RETURN PREVIOUS JOB PACKET
	POP	MSGPTR(R5)		;..DITO
	CALLX	RETMSG			;GO RETURN THE OLD ONE
	MOV	JOBPTR(R5),MSGPTR(R5)	;NOW POINT BACK TO CURRENT FOR SNACK
	CLR	MSGLEN(R5)		;BUT SHOW A LENGTH OF ZERO SO WE
					; DON'T RETURN THE BUFFER TWICE
	BIS	#J.JOB,JOBSTA(R5)	;SHOW A JOB IN PROGRESS
	BIC	#<J.KBCL!J.DRTY>,JOBSTA(R5) ;initially show no carrier loss
					;... and first page is clean	;073
	CLR	INT2(R5)		;Clear out CC:IMP stuff for RMS	;068
	SETFUN	S.ODEV,R0		;SETFUN TO OPEN OUTPUT DEVICE
	SETFUN	S.EOJ,R0		;SETFUN EOJ STATUS UPDATE TO QMAN
	CLR	JOBCOP(R5)		;SHOW US AS ON ZEROITH COPY
	CALL	SAVENT			;save entry-spec		;030
	CALL	SAVFRM			;save form name			;030
	CALL	SAVDEV			;save device name		;030
	CALL	SAVACT			;save account name & PPN	;030
	CLR	NAML(R5)		;show no file initially		;053
	CALL	SAVFIL			;clear file buffer initially	;053
	CLR	DDFLAG(R5)		;show no flag initially
	MOVB	JBNO(R5),QMJBNO(R5)	;save QMAN's job number		;047
	ASRB	QMJBNO(R5)		; we want * 1			;047
	CLC				;clear carry for success	;030
	RETURN				;and exit			;030

BNACK:	REJECT	R5			;MESSGE IS BAD REJECT STATE TRANSITION
	SEC				;SET CARRY 
	RETURN

.SBTTL	SPKIL	- Job kill message recieved
.SBTTL	ABORT	- Kill job setfun by this spooler (no msg from qman)
.SBTTL	ABTERR	- Kill job setfun by this spooler output error message

;+
;
; SPKIL:
;
;	Terminate current job ( if any ).  Print an abort message if the
;	printer isn't hung.
;
; INPUTS:
;
;		R0 -> FUNCION BITS TABLE
;		R1 -> MESSAGE PAST HEADER
;		R2  = LENGTH OF MESSAGE (MINUS HEADER)
;		R5 -> IMPURE AREA
;
; CALL:
;
;	JSR	PC,SPKIL
;	JSR	PC,ABORT
;	JSR	PC,ABTERR
;
;	 FOR SPKIL
;		Message validated
;		state transition rejected if validation failed
;	 FOR SPKIL AND ABORT
;		Abort job, so terminate it
;		abterr is the same as abort but an error message is queued up
;
; BACK:
;
;	C=0 SUCCESS
;	C=1 FAILURE
;	ERROR IN R1
;
;	R3 TRASHED
;	 ALL OTHER REGS PRESERVED
;
;-

	.ENABL	LSB

10$:	;REJECT	R5			;no, so reject transition
	MOV	#ER$CUR,R1		;set error of record not found
	SEC
	RETURN				;return will failure

SPKIL:	MOV	JOBPTR(R5),R3		;get job packet
	CMP	KL.SEQ(R1),JB.SEQ+HD.LEN(R3) ;does seq match?
	BNE	10$			;no, so go reject transition
	.BR	ABTERR			;yes, go abort with an error msg

ABTERR:	BIT	#J.DEV,JOBSTA(R5)	;is spooler device open?
	BNE	20$			;yes
	BIT	#J.KBCL,JOBSTA(R5)	;did we experience inital carrier loss?
	BEQ	15$			;no
	CALL	DEVOFL			;insure, correct behavior for /ABORT
15$:	CLRFUN	S.ODEV,R0		;don't bother to open it
	BR	ABORT			;abort the job, no message.
20$:	BIT	#J.HNG,JOBSTA(R5)	;is spooler device hung?
	BNE	ABORT			;yes, just abort it quietly
	BIT	#J.ESC,JOBSTA(R5)	;are we in the processing of controls?
	BEQ	50$			;no, nothing special needed
	TST	RECL(R5)		;Anything in buffer?
	BNE	30$			;Yes, we better preserve it
	MOVB	#234,@RECPTR(R5)	;No, stuff in <ST>
	INC	RECL(R5)		;and show the character is there
	BR	50$

30$:	CMP	REC(R5),RECPTR(R5)	;Is there room for the <ST>?
	BEQ	40$			;Not really, so trash a good character
	DEC	RECPTR(R5)		;otherwise, make room for the <ST>
	INC	RECL(R5)		;and show that it is there
40$:	MOVB	#234,@RECPTR(R5)	;put the <ST> in the input buffer
50$:	MOV	#ER$ABO,STS(R5)		;no, so set status to aborted
	CLR	STV(R5)			;and show no stv to confuse anyone
	SETFUN	S.ERROR,R0		;and call the error printer

ABORT:	PUSH	R1
	MOV	#ER$ABO,EOJSTS(R5)	;show eoj status as aborted
	CLRFUN	S.GET,R0		;stop processing current file
	BIS	#J.ABRT,JOBSTA(R5)	;show us in abort state
	MOV	#-1,R1			;get a handy 65535
	MOV	R1,FILCOP(R5)		;do no more file copies
	MOV	R1,JOBCOP(R5)		;do no more job copies
	MOVB	R1,PGJH(R5)		;do no more job header pages
	MOVB	R1,PGFH(R5)		;do no more file header pages
;	MOVB	R1,PGFT(R5)		;do no more file trailer pages	;056
	MOVB	R1,PGJT(R5)		;do no more job trailer pages
	CLR	SPLCNT(R5)		;and done with this page
	CLR	SPLLIN(R5)		;and done with this page
;	CLC				;clc from clr above
	POP	R1
	RETURN

	.DSABL	LSB

.SBTTL	SNDEOJ	- JOB HAS FINISHED - SEND BACK EOJ WITH STATUS

;+
;
; SNDEOJ:
;
;
; INPUTS:
;
;		R0 -> FUNCION BITS TABLE
;		R5 -> IMPURE AREA
;
; CALL:
;	JSR	PC,SNDEOJ
;
;		CURRENT JOB IS OVER, SEND BACK STATUS TO QMAN
;
; BACK:
;
;
;		C=0 SUCCESS
;		C=1 FAILURE
;		ERROR IN R1
;		 ALL OTHER REGS PRESERVED
;
;-

SNDEOJ:	SAVREG				;SEND OUR STATUS BACK TO QMAN
	BIC	#<J.PLE!J.SBS>,JOBSTA(R5) ; INSURE THESE BITS CLEAR WHEN IDLE
	MOV	#SPLIDL,SP.STA(R5)	;SET BACK TO 'IDLE' STATE
	MOV	#SQ.EOJ,R1		;SET COMMAND CODE
	MOV	EOJSTS(R5),R2		;RETURN THE JOB EXIT STATUS
	CMP	R2,#ER$ABO		;Is it "Operation aborted"?	;074
	BNE	10$			;Naah				;074
	MOV	#JS$KIL,R2		;Yes.  Be consistent with batch	;074
10$:	MOV	JOBPTR(R5),R3		;Fetch the entry record		;074
	MOV	HD.LEN+JB.FLG(R3),R3	;Return job flags for NOTIFY	;074
	CALL	SNDCMN			;SEND COMMON FORMAT MESSAGE
	RETURN

.SBTTL	SPOFL	- DISCONNECT RECIEVED FROM QMAN

;+
;
; SPOFL:
;
;
; INPUTS:
;
;		R0 -> FUNCION BITS TABLE
;		R1 -> MESSAGE PAST HEADER
;		R2  = LENGTH OF MESSAGE (MINUS HEADER)
;		R5 -> IMPURE AREA
;
; CALL:
;
;	JSR	PC,SPOFL
;
;		WE ARE NO LONGER WANTED, END ALL PROCESSING
;
; BACK:
;
;
;		C=0 SUCCESS
;		C=1 FAILURE
;		ERROR IN R1
;		ALL OTHER REGS PRESERVED
;
;-

SPOFL:	SETFUN	S.DIE,R0		;SETFUN A CRASH
	BIT	#OF$ABO,OF.FLG(R1)	;IS THIS A STOP/ABORT?
	BEQ	10$			;NO
	BIS	#J.ABOF,JOBSTA(R5)	;show that we received OFL/ABORT
	CALLR	ABTERR			;YES, KILL OFF ANY RUNNING JOBS
10$:	CLC				;EXIT HAPPY
	RETURN

.SBTTL	SPSRQ	- STATUS REPORT SETFUN PACKET RECIEVED

;+
;
; SPSRQ:
;
;
; INPUTS:
;
;		R0 -> FUNCION BITS TABLE
;		R1 -> MESSAGE PAST HEADER
;		R2  = LENGTH OF MESSAGE (MINUS HEADER)
;		R5 -> IMPURE AREA
;
; CALL:
;	JSR	PC,SPSRQ
;
;		SEND BACK STATUS RESPONCE
;
; BACK:
;
;
;		C=0 SUCCESS
;		C=1 FAILURE
;		ERROR IN R1
;		 ALL OTHER REGS PRESERVED
;
;-

SPSRQ:	MOV	#SQ.RSP,R1		;SET COMMAND CODE
	MOV	EOJSTS(R5),R2		;RETURN THE JOB EXIT STATUS
	CLR	R3			;NO SPECIAL FLAGS
	CALL	SNDCMN			;SEND COMMON FORMAT MESSAGE
	RETURN

.SBTTL	MDCL	- REMOVE PREVIOUS RIB AND DECLARE RECEIVER

;+
;
; MDCL:
;
;
; INPUTS:
;
;		R0 -> FUNCION BITS TABLE
;		R5 -> IMPURE AREA
;
; CALL:
;	JSR	PC,MDCL
;
;
; BACK:
;
;		OUR RECEIVER ID DECLARED OR
;		WE STALL AND RETRY OR
;		WE CRASH IF WE GET AN UNEXPECTED ERROR
;
;-

MDCL:	PUSH	R0			;SAVE FUNCTION TABLE POINTER
	MOV	R5,R1			;GET ADDR OF BASE OF IMPURE AREA
	ADD	#RECVID,R1		;PUT POINTER TO NAME IN R1
	MOV	QRIB(R5),R3		;GET OUR SUBRIB NUMBER
	REMV	R3			;remove our subrib		;025
10$:	DCLR	R1,R3,#LO.PRT,#BIT0!BIT1,#5 ;declare our receiver	;025
					;  local object = LO.PRT	;025
					;  local, priv'd senders	;025
					;  5 messages max		;025
	MOVBYT	FIRQB+0,R0		;R0 = error status		;025
	BEQ	60$			;no errors, so exit		;025
	CMP	R0,#FIEXST		;RIB NAME ALREADY EXIT?
	BEQ	20$			;yes, so try another name	;026
	CMP	R0,#NOROOM		;FAIL DUE TO NO BUFFERS?
	BNE	50$			;NO, IS UNKNOWN ERROR SO CRASH
	POP	R0			;RESTORE POINTER TO FUNCTION BITS
	SETFUN	S.MDCL,R0		;WE WANT TO RUN AGAIN
	RETRY	#10.			;TRY AGAIN IN 10 SECONDS

20$:	MOV	R1,R0			;get pointer to rcvr name	;026
	ADD	#RIBIDX,R0		;R0 -> rcvr index char (A-Z)	;026
	CMPB	(R0),#'Z		;is index char at max (Z)?	;026
	BHIS	50$			;yes, so crash			;026
	INCB	(R0)			;no, inc letter to next		;026
	BR	10$			;AND GO TRY DECLARE AGAIN

50$:	CRASH				;UNEXPECTED ERROR - CRASH

60$:	CALLX	ENTRCV			;ADD RECEIVER TO RIBLIST
	TST	(SP)+			;TRASH SAVED R0 VALUE
	RETURN				;AND BACK WE GO

	GLOBAL	<FIEXST,NOROOM>

.SBTTL	SNDONL	- SEND CONNECT TO QMAN

;+
;
; SNDONL:
;
;
; INPUTS:
;
;		R0 -> FUNCION BITS TABLE
;		R5 -> IMPURE AREA
;
; CALL:
;	JSR	PC,SNDONL
;
;
; BACK:
;
;		ONLINE PACKET QUEUED FOR SEND TO QMAN
;
;
;-
                
SNDONL:	SAVREG
	BIC	#J.ONL,JOBSTA(R5)	;SHOW US OFF-LINE TO QMAN
	.DATE				;GO GET A SEMI RANDOM NUMBER
	MOV	@#XRB+4,SP.RID(R5)	;RANDOM ENOUGH, SAVE IT
	MOV	#CMNDAT,R1		;GET POINTER TO DATA PORTION OF MSG
	ADD	#ON.RCL,R1		;ADD OFFSET TO NAME FIELD
	MOVB	#6.,(R1)+		;MOVE LENGTH OF 6 TO LENGTH FIELD
	MOV	R5,R0			;GET POINT TO IMPURE AREA
	ADD	#RECVID,R0		;AND POINT TO OUR RECVID
	MOVSTR	R0,R1,#6		;COPY RECVID
	MOV	TOS.R0(SP),R0		;RESTORE FUNCTION BITS PTR
	MOV	#SQ.ONL,R1		;COMMAND IS ONLINE
	MOV	SP.RID(R5),R2		;STS IS OUR ID
	CALL	SNDCMN
	CLC
	RETURN

.SBTTL	SNDCMN	- SEND COMMON FORMAT MESSAGE TO QMAN

;+
;
; SNDCMN:
;
;
; INPUTS:
;
;		R0 -> FUNCION BITS TABLE
;		R1  = CMD TYPE
;		R2  = STATUS
;		R3  = FLAG VALUE
;		R5 -> IMPURE AREA
;
; CALL:
;
;	JSR	PC,SNDCMN
;
; BACK:
;
;		MESSAGE QUEUED FOR SEND TO QMAN
;
;
;-

SNDCMN:	MOV	#CMNDAT,R4		;GET ADDRESS OF COMMON MESSAGE DATA
	MOVB	#QT$PRI,JB.QUE(R4)	;Insert queue type of spooler	;074
	MOV	R2,JB.STS(R4)		;INSERT STATUS VALUE
	MOV	R3,JB.FLG(R4)		;INSERT FLAG VALUE
	MOV	#XM.LEN+HD.LEN+ON.LEN,CMNMSG+XMITLN ;Assume short message ;074
	TST	JOBPTR(R5)		;IS THERE A JOB ACTIVE?
	BEQ	20$			;NO
	MOV	R0,-(SP)		;Save R0			;074
	ADD	#EJ.LEN-ON.LEN,CMNMSG+XMITLN ;Yes, make it a large message ;074
	MOV	JOBPTR(R5),R0		;Get pointer to entry record	;074
	MOV	JB.SEQ+HD.LEN(R0),SU.SEQ(R4) ;Return the entry's Seq #	;074
	MOV	JB.PPN+HD.LEN(R0),SU.PPN(R4) ;Return the owner's PPN	;074
	ADD	#JB.QNL+HD.LEN,R0	;Point to name of queue		;074
	MOV	#CMNDAT+SU.QNL,R4	;Destination of queue name	;074
	MOVSTR	R0,R4,#2*<NAM.LEN+1>	;Copy queue & entry name blocks ;074
.ASSUME	JB.NML	EQ <JB.QNM+NAM.LEN>	;Ensure proper order		;074
.ASSUME	SU.NML	EQ <SU.QNM+NAM.LEN>	;Ensure proper order		;074
	ADD	#JB.DVL-JB.QNL,R0	;Point to name of server	;074
	ADD	#SU.DVL-SU.QNL,R4	; and to destination of server	;074
	MOVSTR	R0,R4			;Copy server name block		;074
	MOV	(SP)+,R0		;Restore R0			;074
20$:	MOV	#CMNHD,R4		;GET ADDRESS OF COMMON MESSAGE HEADER
	MOVB	R1,HD.CMD(R4)		;INSERT COMMAND VALUE
	MOV	SP.SID(R5),HD.CID(R4)	;INSERT THE TARGET CID
	MOV	SP.CTX(R5),HD.CTX(R4)	;AND THE CTX FIELD
30$:	XMITM	#CMNMSG			;QUEUE UP THE UNMAPPED BUFFER
	RETURN

.SBTTL	CMNMSG	- DEFINE COMMON MESSAGE BLOCK

;+
; NOTE:	THIS COMMON MESSAGE AREA IS USED BY THE ROUTINE SNDCMN.
;	IT MAY BE USED TO SEND THE FOLLOWING COMMAND MESSAGES:
;
;		*	STATUS REQUEST
;			STATUS RESPONSE
;			STATUS UPDATE
;			ACKNOWLEDGE
;			NEG-ACKNOWLEDGE
;		*	PAUSE
;		*	CONTINUE
;		*	KILL JOB
;			END-OF-JOB
;			ON-LINE
;		*	ON-LINE CONFIRM
;			OFF-LINE
;		*	INITIALIZE DEVICE
;		*	DELETE DEVICE
;
; * THESE COULD BE USED BUT ARE NOT IN THIS MODULE.
;-

	.SAVE
	.PSECT	IMPURE
	.EVEN

CMNMSG:	
10$:	.WORD	0			;LINK TO NEXT
20$:	.WORD	XM.LEN+HD.LEN+ON.LEN	;LENGTH OF TOTAL MESSAGE
30$:	.BYTE	1			;ONE TARGET
40$:	.BYTE	0			;RETRY COUNT
	.WORD	0			;Reserved for broadcast target
50$:

;
;	ASSURE XMIT'S FIELDS ARE WHAT WE ARE SENDING
;

	.ASSUME	10$-CMNMSG EQ XMITNX
	.ASSUME	20$-CMNMSG EQ XMITLN
	.ASSUME	30$-CMNMSG EQ XMITCT
	.ASSUME	40$-CMNMSG EQ XMITRT
	.ASSUME	50$-CMNMSG EQ XMITFX
	.ASSUME XM.LEN EQ XMITFX+XMITTL

CMNTG:	
10$:	.BYTE	1			;Send by LOT
	.BYTE	<BIT7!LO.SRV>		;Send to PBS Server LOT
	.ASCII	/QM/			; reserved
	.ASCII	/$S/			;  reserved
	.ASCII	/RV/			;   reserved
20$:

;
;	ASSURE THAT THE RID FIELD IS RIGHT
;

	.ASSUME	20$-10$ EQ XMITTL

CMNHD:	
10$:	.BYTE	0			;RESERVED FLAG
20$:	.BYTE	P.VER			;PROTOCAL VERSION
30$:	.WORD	0			;CID TO RETURN
40$:	.BYTE	0			;RTQ FIELD
50$:	.BYTE	0			;CMD FIELD
60$:	.BLKW0	3			;RETURN ADDR
70$:	.WORD	0			;CTX FIELD
80$:

;
;	ASSURE THAT THE HEADER IS DEFINED CORRECTLY
;

	.ASSUME	10$-CMNHD EQ HD.FLG
	.ASSUME	20$-CMNHD EQ HD.VER
	.ASSUME	30$-CMNHD EQ HD.CID
	.ASSUME	40$-CMNHD EQ HD.RTQ
	.ASSUME	50$-CMNHD EQ HD.CMD
	.ASSUME	60$-CMNHD EQ HD.RTN
	.ASSUME	70$-CMNHD EQ HD.CTX
	.ASSUME	80$-CMNHD EQ HD.LEN

;
;	ASSURE THAT WE'RE WORKING WITH THE RIGHT VERSION OF PBSMAC
;

	.ASSUME P.VER	EQ 7.

CMNDAT:
 10$:	.WORD			; ??.SEQ
 20$:	.BYTE	QT$PRI		; ??.QUE
 30$:	.BYTE			; ??.IPR
 40$:	.WORD			; ??.EDA
 50$:	.WORD			; ??.ETI
 60$:	.WORD			; ??.AFT
 70$:	.WORD			; ??.AFD
 80$:	.WORD			; ??.STS
 90$:	.WORD			; ??.FLG
100$:
	.BLKB0	64.		; ADDED BUFFER SPACE FOR LARGER MESSAGES.
110$:
;
;	ASSURE THAT THE COMMON PACKET FIELDS MATCH UP
;

	.ASSUME 20$-CMNDAT EQ JB.QUE
	.ASSUME	30$-CMNDAT EQ JB.IPR
	.ASSUME	40$-CMNDAT EQ JB.EDA
	.ASSUME	50$-CMNDAT EQ JB.ETI
	.ASSUME	60$-CMNDAT EQ JB.AFT
	.ASSUME	70$-CMNDAT EQ JB.AFD
	.ASSUME	80$-CMNDAT EQ JB.STS
	.ASSUME	90$-CMNDAT EQ JB.FLG

;
;	ENSURE THAT THE COMMON PACKET LENGTH WILL HOLD ALL OF THE FIELDS
;	FOR THE MESSAGES THAT USE IT:
;

	.ASSUME	100$-CMNDAT GE NP.LEN	; CMD #0
	.ASSUME	100$-CMNDAT GE BP.LEN	; CMD #1
;	.ASSUME	100$-CMNDAT GE ST.LEN	; CMD #2  (* NOT DEFINED *)
;	.ASSUME	100$-CMNDAT GE SR.LEN	; CMD #3  (* NOT DEFINED *)
	.ASSUME	110$-CMNDAT GE SU.LEN	; CMD #4  (* LARGE MESSAGE *)	;074
	.ASSUME	110$-CMNDAT GE AK.LN2	; CMD #5  (* LARGE MESSAGE *)	;074
	.ASSUME	100$-CMNDAT GE NK.LEN	; CMD #6
;	.ASSUME	100$-CMNDAT GE PD.LEN	; CMD #7  (* NOT ALLOWED *)
;	.ASSUME	100$-CMNDAT GE CD.LEN	; CMD #10 (* NOT ALLOWED *)
;	.ASSUME	100$-CMNDAT GE JB.LEN	; CMD #11 (* NOT ALLOWED *)
;	.ASSUME	100$-CMNDAT GE MD.LEN	; CMD #12 (* NOT ALLOWED *)
;	.ASSUME	100$-CMNDAT GE KL.LEN	; CMD #13 (* NOT DEFINED *)
	.ASSUME	110$-CMNDAT GE EJ.LEN	; CMD #14 (* LARGE MESSAGE *)	;074
;	.ASSUME	100$-CMNDAT GE FT.LEN	; CMD #15 (* NOT ALLOWED *)
	.ASSUME	110$-CMNDAT GE ON.LEN	; CMD #16 (* LARGE MESSAGE *)	;074
;	.ASSUME	100$-CMNDAT GE OC.LEN	; CMD #17 (* NOT DEFINED *)	;074
	.ASSUME	100$-CMNDAT GE OF.LEN	; CMD #20
;	.ASSUME	100$-CMNDAT GE SY.LEN	; CMD #21 (* NOT DEFINED *)
;	.ASSUME	100$-CMNDAT GE ID.LEN	; CMD #22 (* NOT ALLOWED *)
;	.ASSUME	100$-CMNDAT GE MS.LEN	; CMD #23 (* NOT ALLOWED *)
;	.ASSUME	100$-CMNDAT GE DD.LEN	; CMD #24 (* NOT ALLOWED *)
;	.ASSUME	100$-CMNDAT GE IQ.LEN	; CMD #25 (* NOT ALLOWED *)
;	.ASSUME	100$-CMNDAT GE MS.LEN	; CMD #26 (* NOT ALLOWED *)
;	.ASSUME	100$-CMNDAT GE DQ.LEN	; CMD #27 (* NOT ALLOWED *)
;	.ASSUME	100$-CMNDAT GE PQ.LEN	; CMD #30 (* NOT ALLOWED *)
;	.ASSUME	100$-CMNDAT GE CQ.LEN	; CMD #31 (* NOT ALLOWED *)
;	.ASSUME	100$-CMNDAT GE AS.LEN	; CMD #32 (* NOT ALLOWED *)
;	.ASSUME	100$-CMNDAT GE DS.LEN	; CMD #33 (* NOT ALLOWED *)

	.RESTORE							;076

.SBTTL	OPNDEV	- OPEN OUTPUT DEVICE

;+
;
; OPNDEV:
;
;	Opens output device.  LP and KB are special cased.  Modem KB printers
;	will send carrier loss back to QMAN if no carrier is found.
;
;	Allocation of device requires doing a snagging assignment from QMAN.
;
; INPUTS:
;
;		R0 -> Funcion bits table
;		R5 -> Impure area
;
; CALL:
;	JSR	PC,OPNDEV
;
;
; BACK:
;
;		Output device open
;		Stall and retry if failure
;
;		ONLY RETURN IF SUCCESS
;		ON FAILURE STALL SPOOLER
;
;-

OPNDEV:	CLR	PUTSLP(R5)		;start this one with a fast sleep ;071
  	CLR	SUCPUT(R5)		;show no good puts yet
	CLR	ZERPUT(R5)		;show no zero length puts yet
	CLR	DDPAUS(R5)		;show no pause options		;020
	MOV	JOBPTR(R5),R3		;get scratch pointer to form section
	ADD	#HD.LEN,R3		;and offset past the header
	MOVBYT	JB.DVL(R3),R2		;get length of output device	;025
	ADD	#JB.DVL+1,R3		;now is pointer to start of dev
	GETDEV	R3,R2			;ask for permision to use device
	BCC	20$			;ok joe,  all yours
	SETFUN	S.ODEV,R0		;sorry device in use want to try again
	RETRY	#15.			;stall job for 15. seconds

20$:	SETFUN	S.CDEV,R0		;release the device when done
	BIT	#J.DEV,JOBSTA(R5)	;Opened outbound LAT port already? ;075
	BNE	65$			;Yes, check on port's status	;075
	CALLX	CLRFQX			;clear FIRQB and XRB
	MOV	R2,@#XRB+XRLEN		;length of file spec
	MOV	R2,@#XRB+XRBC		;length of file spec
	MOV	R3,@#XRB+XRLOC		;pointer to file spec
	.FSS
	MOV	@#FIRQB+FQDEV,R3	;save device name
	MOV	@#FIRQB+FQDEVN,R2	;save device unit number/real
	CALLX	CLRFQB			;clear FIRQB			;047
	MOVB	#UU.ASS,@#FIRQB+FQFUN	;select assignment function	;047
	MOV	#100001,@#FIRQB+FQMODE	;snag device from QMAN		;047
	MOV	R3,@#FIRQB+FQDEV	;set dev name			;047
	MOV	R2,@#FIRQB+FQDEVN	;set unit/flag			;047
	.UUO				;snag it			;047
	TST	@#FIRQB			;Did we get it?			;047
	BNE	50$			;no, wait for the device	;047
;	CMPB	QMJBNO(R5),@#FIRQB+FQFIL;Did we snag it from QMAN?	;047
;	BNE	sorry$			;No, we should apologize	;047
	CALLX	CLRFQX			;clear FIRQB/XRB
	MOVB	#CREFQ,@#FIRQB+FQFUN	;set in open setfun code
  	GETLUN	@#FIRQB+FQFIL		;get a channel
	MOV	@#FIRQB+FQFIL,OUTLUN(R5);and stash that away for later use
	MOV	#2+400,@#FIRQB+FQPPN	;set in a dummy ppn
	MOV	#^RPRI,@#FIRQB+FQNAM1	;and a dummy name
	MOV	#^RNT ,@#FIRQB+FQNAM1+2	;and more dummy name
	MOV	#^RTMP,@#FIRQB+FQEXT	;and dummpy extension
	MOV	R3,@#FIRQB+FQDEV	;resore device name
	MOV	R2,@#FIRQB+FQDEVN	;restore device unit number/real
	CLR	R2			;get scratch cell for mode
	CLR	ORCMOD(R5)		;show no record mode on output
	CMP	#"LP,R3			;was device an lp?
	BNE	30$			;no
	MOV	#8192.!256.!BIT15,R2	;yes, so no <FF> on close, /truncate
	MOV	#8192.!4096.,ORCMOD(R5)	;and use no stall puts & binary mods
30$:	CMP	#"KB,R3			;was device a kb?
	BNE	40$			;no
	MOV	#4.!16.!32.!512.!BIT15,R2 ;KB.  Use guarded control-C,	;070
					; XON/XOFF, nowrap, always sleep ;070
	MOV	#8192.!4096.,ORCMOD(R5)	;and use no stall puts & binary mods
40$:	MOV	R2,@#FIRQB+FQMODE	;and set in the mode
	CALFIP				;please mr(s). fip
	TSTB	@#FIRQB			;any errors?
	BEQ	60$			;no so br on
	CLR	@#FIRQB+FQMODE		;get rid of mode
	CMPB	@#FIRQB,#NOSUCH		;was error can't find file
	BEQ	40$			;yes so try without the mode

	
50$:	RETLUN	OUTLUN(R5)		;return the channel for later use
	BIC	#J.DEV,JOBSTA(R5)	;Ensure open flag is correct	;037
	TST	DEVHNG(R5)		;Did we experience carrier losss?
	BNE	110$			;yes, return error
55$:	SETFUN	S.ODEV,R0		;we want to try again
	RETRY	#15.			;nutts try again in 15 seconds

60$:	BIS	#J.DEV,JOBSTA(R5)	;show output device open	;075
	MOV	@#FIRQB+FQFLAG,DEVFLG(R5) ;save the device characteristics
	CALL	SETCHR			;set the device characteristics	;037
	CMPB	#TTYHND,DEVFLG(R5)	;is device a terminal device?
	BNE	100$			;nope, so all done
65$:	CALL	CLRFQX			;Clear FIRQB/XRB		;075
	MOV	#XRB,R1			;pointer to XRB
	INC	(R1)+			;length of buffer (XRLEN) =1
	INC	(R1)+			;length of data (XRBC) =1
	MOV	#CRLF,(R1)+		;addr of data (XRLOC)		;077
	MOVB	OUTLUN(R5),(R1) 	; channel for output (XRCI)
	MOV	#8192.,@#XRB+XRMOD	; 'no stall' write modifier
	.WRITE				;write out a <CR> to check connection
	TST	@#FIRQB			;errors?
	BEQ	80$			;no
	CMPB	#NOTAVL,@#FIRQB		;Outbound connection in progress? ;075
	BEQ	55$			;Yes, try again later		;075
	CMPB	#DETKEY,@#FIRQB		;Carrier/LAT connection loss?	;075
	BNE	70$			;no
	TST	DEVHNG(R5)		;Was the carrier loss detected by PUT:?
	BNE	70$			;Yes, keyboard was there at one time
	MOV	SP,DEVHNG(R5)		;simulate carrier loss
	CALL	DEVOFL			;Tell QMAN carrier is lost
	BCS	120$			;exit if OFL/ABORT command was given
	BIS	#J.KBCL,JOBSTA(R5)	;indicate that initial open failed
	CLR	DEVHNG(R5)		;no longer show carrier loss for retry
70$:	BR	50$

80$:	BIT	#J.KBCL,JOBSTA(R5)	;was there initial carrier loss?
	BEQ	90$			;no, continue
	CALL	DEVONL			;yes, tell QMAN carrier back
	BIC	#J.KBCL,JOBSTA(R5)	;show initial carrier achieved
90$:	CLR	DEVHNG(R5)		;The device can't be hung anymore
100$:	SETFUN	S.FORM,R0		;setfun from handling
	SETFUN	S.EOJC,R0		;setfun the job copies handler
	TST	(PC)+
110$:	SEC
120$:	RETURN

	GLOBAL	NOTAVL

.SBTTL	SETCHR	- Set DDCHAR word with output device characteristics

;+
;
; SETCHR:
;
;	This routine performs either UU.CFG ( for LP devices ) or UU.TRM
;	( for KB devices ) and sets the DDCHAR word accordingly.  We can
;	only find out two characteristics from the UU.TRM call so the rest
;	of the characteristics are defaulted.
;
; INPUTS:
;
;	FIRQB after the CREFQ CALFIP on output device
;	R3 =  either "KB" or "LP"
;	R5 -> Impure area
;
; CALL:
;
;	JSR	PC,SETCHR
;
; BACK:
;
;	C=0 ON SUCCESS, C=1 FAILURE
;
;	ALL REGS PRESERVED
;
;-

	.ENABL	LSB

SETCHR:	PUSH	R1
	CLR	DDCHAR(R5)			;Clear characteristics word
	MOV	@#FIRQB+FQDEVN,R1		;Retrieve unit number + flag
	CALLX	CLRFQB				;Clear the FIRQB
	CMP	#"KB,R3				;Is device a KB:?
	BEQ	10$				;Yes, go set up for UU.TRM
	MOVB	#UU.CFG,@#FIRQB+FQFUN		;Set UU.CFG (Config)
	MOVB	#1,@#FIRQB+FQFIL		;specify LP characteristics
	MOV	R3,@#FIRQB+FQDEV		;set device name in ascii
	MOV	R1,@#FIRQB+FQDEVN		;set unit number + flag
	.UUO					;perform call
	TST	@#FIRQB				;Errors?
	BNE	50$				;Yes, fail
	MOV	@#FIRQB+FQNAM1,DDCHAR(R5)	;Set the LPTCHR as DDCHAR
	BR	40$				;Success

10$:	BIS	#LPTRBS!LPTSFF,DDCHAR(R5)	;Force KB attributes:	;061
						; Real backspace	;061
						; No <sp><cr> after ff	;061
	MOVB	#UU.TRM,@#FIRQB+FQFUN		;Set UU.TRM (Set term char)
	MOVB	R1,@#FIRQB+FQSIZM		;move in keyboard number
	.UUO					;perform call
	TST	@#FIRQB				;Errors?
	BNE	50$				;Yes, fail
	MOV	#SETTTY,R1			;Get base of tty conv table
	PUSH	R2
	MOV	#SETLEN,R2			;R2 = length (entries) of table
20$:	CMPB	@(R1)+,(R1)			;Is this option selected?
	BNE	30$				;No
	BIS	2(R1),DDCHAR(R5)		;Yes, set the corresponding bit
30$:	ADD	#4,R1				;R1 -> the next entry
	SOB	R2,20$				;For each entry in the table
	POP	R2
40$:	CLR	DDFILL(R5)			; start with zeros	    ;058
	PUSH	R0				; get a reg		    ;058
	MOVBYT	@#FIRQB+FQSIZ,R0		; get index into table	    ;058
						; CRFILL count is off by one;058
	MOVB	CRTBL-1(R0),DDFILL(R5)		; get fill count from table ;058
	CLR	DDNULL(R5)			; none left at start	    ;058
	POP	R0				; restore reg		    ;058
	TST	(PC)+				;Success
50$:	SEC					;Failure
	POP	R1
	RETURN

	; Table for CRFILL. The UU call returns the CRFILL+1 in FQSIZ.	    ;058
	; We calculate the number of nulls to output for a <CR>, based	    ;058
	; on 2 ** (CRFIL-1) which we look up in the following table:	    ;058

	.SAVE								    ;058
	.PSECT	PURE							    ;058

CRTBL:	.BYTE	0.				; no fill		    ;058
	.BYTE	1.				; 2 ** (1-1) = 1	    ;058
	.BYTE	2.				; 2 ** (2-1) = 2	    ;058
	.BYTE	4.				; 2 ** (3-1) = 4	    ;058
	.BYTE	8.				; 2 ** (4-1) = 8	    ;058
	.BYTE	16.				; 2 ** (5-1) = 16	    ;058
	.BYTE	32.				; 2 ** (6-1) = 32	    ;058

	.RESTORE							    ;058

	.DSABL	LSB

.SBTTL	SETCHR	- Terminal FIRQB to bit translation table

;
;	Table format is as follows:
;
;	FIRQB offset, Value to compare, Bit to set in DDCHAR
;

	.SAVE
	.PSECT	PURE
	.EVEN					; Ensure word		;058
SETTTY:	.WORD	FIRQB+7,200,LPTTAB		; Tab/No Tab
	.WORD	FIRQB+11,200,LPTALC		; LC output/No LC output
	.WORD	FIRQB+36,30,LPT8BT		; 8-bit characteristics
	.WORD	FIRQB+14,377,LPTSCP		; Scope			;058
SETLEN	= <<.-SETTTY>/6>

	.RESTORE

.SBTTL	CLSDEV	- CLOSE OUTPUT DEVICE

;+
;
; CLSDEV:
;
;
; INPUTS:
;
;		R5 -> Impure Area
;		R0 -> Funcion bits table
;
; CALL:
;
;	JSR	PC,CLSDEV
;
; BACK:
;
;		Output device closed
;
;	ONLY RETURNS WITH SUCCESS
;
;-

CLSDEV:	CALLX	CLRFQX			;clear firqb and xrb
	MOVB	#CLSFQ,@#FIRQB+FQFUN	;set fun code for close
	MOVB	OUTLUN(R5),@#FIRQB+FQFIL ;and channel * 2
	BIT	#J.DEV,JOBSTA(R5)	;was device opened?
	BEQ	10$			;no so don't close or return lun
	CALFIP				;please to be closeing the file
	RETLUN	OUTLUN(R5)		;and return the lun
	BIC	#J.DEV,JOBSTA(R5)	;and mark it as no longer open
10$:	MOV	JOBPTR(R5),R3		;get scratch pointer to form section
	ADD	#HD.LEN,R3		;and offset past the header
	MOVBYT	JB.DVL(R3),R2		;get length of output device	;025
	ADD	#JB.DVL+1,R3		;now is pointer to start of dev
	RETDEV	R3,R2			;and return the device (always works)
	CALL	CLRFQX			;clear the firqb/xrb
	MOV	R2,@#XRB+XRLEN		;  set length of device name
	MOV	R2,@#XRB+XRBC		;     twice
	MOV	R3,@#XRB+XRLOC		;  set address of device name
	.FSS				;fss the device
	PUSH	@#FIRQB+FQDEV						;047
	PUSH	@#FIRQB+FQDEVN		; save device name and unit number;047
	CALL	CLRFQB			;clear the firqb again		;047
	MOVB	#UU.ASS,@#FIRQB+FQFUN	;select assignment function	;047
	MOVB	QMJBNO(R5),@#FIRQB+FQNAM1;reassign the device to QMAN	;047
	POP	@#FIRQB+FQDEVN						;047
	POP	@#FIRQB+FQDEV		;restore the name and unit	;047
	.UUO				;do the reassignment		;047
	TST	DEVHNG(R5)		;did we experience carrier loss?
	BNE	20$			;yes, don't mess with flags
	BIC	#J.JOB,JOBSTA(R5)	;show no job in progress any more
	BIC	#J.ABRT,JOBSTA(R5)	;reenable after an abort
	CALL	DEVONL			;don't really know, but...
20$:	RETURN

.SBTTL	OPEN	- OPEN INPUT DEVICE

;+
;
; OPEN:
;
;
; INPUTS:
;
;	R0 -> FUNCION BITS TABLE
;	R5 -> IMPURE AREA
;
; CALL:
;
;	JSR	PC,OPEN
;
; BACK:
;
;	INPUT FILE OPENED
;		STALL AND RETRY IF FAILURE
;		CRASH ON UNKNOWN ERRORS
;
;	ONLY RETURN IF SUCCESS
;	ON FAILURE STALL SPOOLER
;
;-

OPEN:	CLR	INT2(R5)	;Clear CC:IMP stuff for RMS		;068
	BIT	#J.ABRT,JOBSTA(R5);ARE WE TRYING TO ABORT?
	BNE	20$		;YES, SO DON'T OPEN THE FILE...
	CLR	RSTPTR(R5)	;RESET THE RE-START TABLE
	MOV	#1,DDPAG0(R5)	;RESET CURRENT PAGE (FIRST WORD)
	CLR	DDPAG1(R5)	; ...  CURRENT PAGE (SECOND WORD)
	CMP	#ER$FNF,STS(R5)	;WAS LOOKUP ERROR FILE NOT FOUND?
	BEQ	10$		; YES SO DON'T TRY THE OPEN
	CMP	#ER$FNM,STS(R5)	;WAS LOOKUP ERROR FILE NAME ERROR?
	NOP			; IGNORE ER$FNM, I.E., ALLOW NET WORK FILES
..NNET==.-2		; ** PATCH TO BR 10$ TO DISABLE NETWORK FILES SPECS
	SETFUN	S.CLOSE,R0	;CLOSE THE FILE WHETHER OPEN OR NOT !
	BIS	#J.OPN,JOBSTA(R5) ;SHOW STATUS OF FILE IS OPEN
	BIS	#BLKIO,OPT(R5)	;USE BLOCK IO IF FILE IS STREAM
	CALLX	RMSOPN		;OPEN THE FILE
	BCC	30$		;CONTINUE IF OK
;	CMP	#ER$WCD,STS(R5)	;WAS ERROR ILLEGAL WILD CARD
;	BNE	10$		;NO SO REPORT IT
;	MOV	#ER$FNF,STS(R5)	;YES SO CALL IT A FILE NOT FOUND
10$:	SETFUN	S.ERROR,R0	;QUEUE UP A ERROR MESSAGE
20$:	RETURN

30$:	SETFUN	S.GET,R0	; AND START THE DATA ROLLING
	BIC	#J.DRTY,JOBSTA(R5) ;Signal that current page is clean	;073
	PUSH	R1
	MOV	FAB(R5),R1	; get copy of FAB pointer		;055
	$TESTBITS #FB$CR,RAT,R1	; does this file have implied CC?	;055
	BEQ	40$		; no, nothing special needed		;055
	DEC	INT2(R5) 	; yes, signal TOF to RMSGET		;068
40$:	POP	R1
	RETURN

	GLOBAL	<ER$WCD,ER$FNF>

.SBTTL	CLOSE	- CLOSE INPUT DEVICE

;+
;
; CLOSE:
;
;
; INPUTS:
;
;		R5 -> IMPURE AREA
;		R0 -> FUNCION BITS TABLE
;
; CALL:
;	JSR	PC,CLOSE
;
;
; BACK:
;
;		INPUT FILE CLOSED
;			STALL AND RETRY IF FAILURE
;			CRASH ON UNKNOWN ERRORS
;
;
;
;	ONLY RETURN IF SUCCESS
;	ON FAILURE STALL SPOOLER
;
;-

CLOSE:	BIC	#J.OPN,JOBSTA(R5) ;SHOW STATUS OF FILE IS CLOSED
	CALLX	RMSCLS		;CLOSE THE FILE
	BCC	10$		;CONTINUE IF OK
	SETFUN	S.ERROR,R0
10$:	RETURN

.SBTTL	ERASE	- DELETE INPUT FILE

;+
;
; ERASE:
;
;
; INPUTS:
;
;		R5 -> IMPURE AREA
;		R0 -> FUNCION BITS TABLE
;
; CALL:
;	JSR	PC,ERASE
;
;
; BACK:
;
;		INPUT FILE DELETED IF DELETE REQUESTED
;		 	AND JOB HAS NOT 'ERRORED' YET
;			STALL AND RETRY IF FAILURE
;			CRASH ON UNKNOWN ERRORS
;
;
;
;	ONLY RETURN IF SUCCESS
;	ON FAILURE STALL SPOOLER
;
;-

	.MCALL	$ERASE

ERASE:	TST	EOJSTS(R5)	;ANY ERRORS YET?
	BLT	20$		;YES SO NO DELETE
	TST	KILLGL(R5)	;NO, ARE KILLS LEGAL FOR THIS SPEC?
	BEQ	20$		;NO,SO DON'T TOUCH IT.
	MOV	FILSPC(R5),R1	;POINT TO THIS FILE SPEC BLOCK
	BIT	#FF$DEL,FB.FLG(R1) ;WAS DELETE REQUESTED FOR THIS FILE?
	BEQ	20$		;NO SO DON'T DELETE
	MOV	FAB(R5),R1	;YES SO PREPAR TO KILL IT,GET THE FAB
	$STORE	#0,DNS,R1	;DON'T USE THE DEFAULT FILE NAME
	$ERASE	R1		;KISS IT GOOD BYE
	TST	O$STS(R1)	;DID WE SUCCEED IN KILLING THE FILE?
	BPL	10$		;YES
	CMP	#ER$FNF,O$STS(R1);WAS FAILURE DUE TO  FILE ALREADY DELETED?
	BNE	20$		;NO, DON'T REALLY KNOW WHAT HAPPENED?
10$:	DEC	WILD1(R5)	;AND TELL THE WILD CARD SCANNER TO BACK UP 1
	TST	(PC)+		;CLC AND RETURN
20$:	SEC
	RETURN

.SBTTL	EOFCHK	- END-OF-FILE HANDLER

;+
;
; EOFCHK:
;
;
; INPUTS:
;
;		R5 -> IMPURE AREA
;		R0 -> FUNCION BITS TABLE
;
; CALL:
;	JSR	PC,EOFCHK
;
;
; BACK:
;
;		RESETS BITS FOR FILE COPIES OR CLOSE UP
;		THE SPOOLER RUN FOR THIS FILE/JOB.
;
;-

EOFCHK:	MOV	FILSPC(R5),R1		;GET THE FILE SPEC PACKET	;073
	CMP	FILCOP(R5),FB.COP(R1)	;DO WE WANT ANY MORE FILE COPIES?
	BLO	10$			;YES, SO GO DO THEM
	MOV	JOBPTR(R5),R1		;NO, GET THE JOB PACKET
	CMP	JOBCOP(R5),JB.COP+HD.LEN(R1) ;IS THIS THE LAST JOB COPY TOO?
	BLO	40$			;NO, STILL MORE TO COME
	SETFUN	S.ERASE,R0		;YES, CALL THE ERASER
	BR	40$			;AND EXIT HAPPY

10$:	INC	FILCOP(R5)		;SHOW US ON THE NEXT COPY
	CLRB	PGFH(R5)		;SHOW NO FILE HEADERS PRINTED YET
	BIT	#FF$FHD,FB.FLG(R1)	;DO WE WANT FILE HEADER PAGES?
	BNE	20$			;YES, CONTINUE
	MOVB	#-1,PGFH(R5)		;NO, SO SHOW MAX ALREADY PRINTED
20$:	CALL	SAVFCP			;save curr/tot file copies	;030
	SETFUN	S.PGFH,R0		;DO THE FILE HEADER PAGES
	SETFUN	S.OPN,R0		;AND OPEN THE FILE AGAIN
	SETFUN	S.PGFT,R0		;DO THE FILE TRAILER PAGES
;	CLRB	PGFT(R5)		;SHOW NONE PRINTED YET		;056
	BIT	#FF$FTR,FB.FLG(R1)	;DO WE WANT FILE TRAILER PAGES?
	BNE	30$			;YES, CONTINUE
;	MOVB	#-1,PGFT(R5)		;NO, SO SHOW MAX ALREADY PRINTED;056
30$:	SETFUN	S.EOF,R0		;AND CALL US AGAIN LATER
	CLR	SPLLIN(R5)		;RESET SPLATER
	CLR	SPLCNT(R5)		;RESET SPLATER
40$:	RETURN				;and exit

.SBTTL	WLDCHK	- END-OF-WILDCARD HANDLER

;+
;
; WLDCHK:
;
;
; INPUTS:
;
;		R5 -> IMPURE AREA
;		R0 -> FUNCION BITS TABLE
;
; CALL:
;	JSR	PC,WLDCHK
;
;
; BACK:
;
;		DETERMINES WHETHER THE FILE SPEC IS WILD OR NOT 
;		AND SETS UP THE FSS ON THE FILE NAME TO INSURE
;		ITS OPENABILITY.  WILL HANDLE ALL WILDCARD AND NON
;		WILDCARD LOOKUPS.
;
;
;-

WLDCHK:	BIT	#J.ABRT,JOBSTA(R5) ;ARE WE ABORTING?
	BNE	20$		; YES
	CALL	LOOKUP		; AND CALL THE LOOKER UPPER
	BCC	10$		; IT WORKED SO GO SET UP THE FILE
	TST	WILD(R5)	; IS THIS THE FIRST WILD CARD CHECK?
	BNE	20$		; NO, SO THIS IS THE END OF THE LINE
10$:	MOV	SP,WILD(R5)	; SHOW US AS HAVING BEEN HERE BEFORE
	CLR	FILCOP(R5)	; START NEXT FILE ON COPY 0
	SETFUN	S.EOF,R0	; CALL THE EOF PROCESSOR
	SETFUN	S.WLD,R0	; CALL US AGAIN LATER
20$:	RETURN

.SBTTL	EOFSCHK	- END-OF-FILESPEC HANDLER

;+
;
; EOFSCHK:
;
;
; INPUTS:
;
;		R5 -> IMPURE AREA
;		R0 -> FUNCION BITS TABLE
;
; CALL:
;	JSR	PC,EOFSCHK
;
;
; BACK:
;
;		WATCH IT !  REGISTERS ARE NOT PRESERVED
;		DETECTS WHEN THE LAST FILE SPEC COMMAND FROM THE
;		JOB PACKET HAS BEEN EXECUTED.  ( DETERMINING END OF
;		JOB ).
;
;
;-

EOFSCHK:MOV	@FILSPC(R5),R1	;GET OFFSET TO NEXT FROM START OF PACKET
	BEQ	60$		;BR IF NONE LEFT
	ADD	JOBPTR(R5),R1	;NOW IS ADDER OF NEXT JOB SPEC
	ADD	#HD.LEN,R1	;NOT TO FORGET THE HEADER
	MOV	R1,FILSPC(R5)	;AND STORE POINTER TO NEW FILE SPEC
	BIT	#J.ABRT,JOBSTA(R5) ;ARE WE TRYING TO ABORT?
	BNE	60$		;BR IF WE ARE
	CLR	WILD(R5)	; RESET FOR FIRST FILE LOOKUP
	CLR	WILD1(R5)	; RESET THE WILD CARD LOOKERUPERRER
	CLR	WILD2(R5)	; RESET THE WILD CARD LOOKERUPERRER
	CLR	WILD4(R5)	; RESET THE WILD CARD LOOKERUPERRER
	CLR	FILCOP(R5)	; RESET THE FILE COPY CHECKER
	CLR	DDFLAG(R5)	;CLEAR ALL FLAGS
	MOV	FB.FLG(R1),R2	;GET FLAG WORD
20$:	MOV	#FFLG1-2,R3	;GET START OF OPTIONS TABLE TO SET (-2)
30$:	TST	(R3)+		;POINT TO CORRECT START OF NEXT
	TST	(R3)		;AT END OF TABLE YET?
	BEQ	40$		;YES SO ALL DONE WITH THESE BITS
	BIT	(R3)+,R2	;IS FLAG SET?
	BEQ	30$		;NO, TRY FOR NEXT FLAG
	BIS	(R3),DDFLAG(R5)	;YES, SO SET THE BIT(S)
	BR	30$		;AND TRY THE NEXT BITTS

40$:	MOV	JOBPTR(R5),R1	; GET POINTER TO JOB PACKET AGAIN
	CMP	DDVERC(R5),DDBOM(R5) ;Form long enough to support /FEED? ;069
	BHI	50$		; YES
	BIC	#LPTOVF,DDFLAG(R5) ; NO, SO CLRFUN THE OPTION
50$:	SETFUN	S.WLD,R0	; CALL THE MORE WILD CARD CHECKER
	SETFUN	S.EOFS,R0	; AND CALL US AGAIN
60$:	RETURN			; MOVE ONTO NEXT FILE SPEC FOR JOB

.SBTTL	EOJCHK	- END-OF-JOB HANDLER

;+
;
; EOJCHK:
;
;
; INPUTS:
;
;		R5 -> IMPURE AREA
;		R0 -> FUNCION BITS TABLE
;
; CALL:
;	JSR	PC,EOJCHK
;
;
; BACK:
;
;		WATCH YOUR REGISTERS !
;		WATCHES OUT FOR JOB COPIES AND SETS BITS
;		FOR TERMINATION OF THE JOB.
;
;-

EOJCHK:	MOV	JOBPTR(R5),R1		;GET THE JOB PACKET
	ADD	#HD.LEN,R1		;OFFSET PAST THE HEADER
	CMP	JOBCOP(R5),JB.COP(R1)	;DO WE WANT ANY MORE JOB COPIES?
	BHIS	10$			;NO
	INC	JOBCOP(R5)		;YES, SHOW US ON NEXT JOB COPY
	CALL	SAVJCP			;save curr/tot job copies	;030
	MOV	R1,R2			;GET ADDR OF START OF JOB PACKET
	ADD	#JB.FIL,R2		;NOW ADDR OF PTR TO FIRST FILE SPEC
	MOV	R2,FILSPC(R5)		;AND SET US POINTING TO THE FIRST
	SETFUN	S.EOFS,R0		;CALL THE END OF FILE SPEC PROCESSOR
	SETFUN	S.PGJH,R0		;PRINT OUT THE JOB HEADERS
	CLRB	PGJH(R5)		;SHOW NONE PRINTED YET
	SETFUN	S.PGJT,R0		;PRINT OUT THE JOB TRAILERS
	CLRB	PGJT(R5)		;SHOW NONE PRINTED YET
	SETFUN	S.EOJC,R0		;AND CALL US AGAIN LATER
10$:	RETURN				;exit

.SBTTL	FFLG1	- PRINTER OPTIONS TO SET TABLE

	.SAVE
	.PSECT	PURE
	.EVEN

;
; Define printer flags to set
;

FFLG1:	.WORD	FF$ZER,LPTCH0	;/CONVERT
	.WORD	FF$TRN,LPTNOX	;/TRUNCATE
	.WORD	FF$SKP,LPTOVF	;/FEED
	.WORD	FF$RAP,LPTRAP	;/WRAP					;070
	.WORD	0		;END OF TABLE

	.RESTORE

.SBTTL	HEADER	- PRINT HEADER/TRAILER PAGE(S)

;+
;
; PAGEJH:	(Job header page)
; PAGEJT:	(Job trailer page)
;
; PAGEFH:	(File header page)
; PAGEFT:	(File trailer page)
;
;	This routine creates the pages on a part by part basis.  As soon as
;	a section is formed, it is moved into the output buffer via MOVCVT.
;	MOVCVT then calls PUT when it empties its input buffer.  Control is
;	returned to this routine with a completely empty input buffer (REC(R5)
;	and RECL(R5) are at their initial settings).
;
; INPUTS:
;
;	R0 -> funcion bits table
;	R5 -> impure area
;
; CALL:
;
;	JSR	PC,PAGE??
;
; BACK:
;
;	Header/trailer outputed to print device
;		stall and retry if failure
;		crash on unknown errors
;
;	Only return if success
;	On failure stall spooler
;	In anycase, registers are not always preserved
;
;-

	.ENABL	LSB

10$:	RETURN				;all done go back

PAGEJH:	MOV	JOBPTR(R5),R2		;get pointer to job packet	;060
	ADD	#HD.LEN,R2		;and offset past the header	;060
	BIT	#JB$TAP,JB.FLG(R2)	;is special TAP bit set?	;060
	BNE	10$			;yes, so skip job headers	;060
	MOV	#JHPG,R1		;get base of dispat table
	TSTB	PGJH(R5)		;is this the zero'th time throu
	BNE	20$			;no
	CMP	#1,JOBCOP(R5)		;is this the first job copy?
	BNE	20$			;nope so just do the page if
	MOV	#JHPGFF,R1		;yes so print the leading <FF>
20$:	CMPB	PGJH(R5),JB.JHD(R2)	;have we printed enough yet?
	BHIS	10$			;yes, all done
	SETFUN	S.PGJH,R0		;ask for us back
	BIS	#H$JOBH,HDRFLG(R5)	;show we're printing job headers ;030
	BR	60$			;and join common code

PAGEFH:	MOV	JOBPTR(R5),R2		;get pointer to job packet	;060
	ADD	#HD.LEN,R2		;and offset past the header	;060
	BIT	#JB$TAP,JB.FLG(R2)	;is special TAP bit set?	;060
	BNE	10$			;yes, so skip file headers	;060
	MOV	#FHPG,R1		;get base of dispat table
	BIC	#H$JOBH,HDRFLG(R5)	;no want job packet file name in splat
	TSTB	PGFH(R5)		;is this the zero'th time throu
	BNE	30$			;no
	MOV	#FHPGFF,R1		;yes so print the leading <FF>
30$:	CMPB	PGFH(R5),JB.FHD(R2)	;have we printed enough yet?
	BLO	40$			;nope more to do
	CALLR	PAGEIF			;yes, do <FF> if not tof and return

40$:	SETFUN	S.PGFH,R0		;ask for us back
	BR	60$			;and join common code

PAGEFT:	MOV	JOBPTR(R5),R2		;get pointer to job packet	;060
	ADD	#HD.LEN,R2		;and offset past the header	;060
	BIT	#JB$TAP,JB.FLG(R2)	;is special TAP bit set?	;060
	BNE	10$			;yes, so skip file trailers	;060
	MOV	#FTPG,R1		;get base of dispat table
	BIT	#FM$FTP,JB.DCH(R2)	;Print a file trailer? 		;056
	BEQ	10$			;no, all done			;056
	BIS	#H$FILT,HDRFLG(R5)	;show we're printing file trailers ;056
	SETFUN	S.PGFT,R0		;ask for us back
	BR	60$			;and join common code

PAGEJT:	MOV	JOBPTR(R5),R2		;get pointer to job packet	;060
	ADD	#HD.LEN,R2		;and offset past the header	;060
	BIT	#JB$TAP,JB.FLG(R2)	;is special TAP bit set?	;060
	BNE	10$			;yes, so skip job trailers	;060
	MOV	#JTPG,R1		;get base of dispat table
	CMPB	PGJT(R5),JB.JTR(R2)	;have we printed enough yet?
	BLO	50$			;nope more to do
	CALLR	PAGEIF			;yes, do <FF> if not tof and return

50$:	SETFUN	S.PGJT,R0		;ask for us back
60$:	CALL	SAVDAT			;save curr date/time string	;030
	ADD	SPLLIN(R5),R1		;add our restart number to dispat tbl
	CALLR	@(R1)+			;and call it off the table

.SBTTL	FILE HEADER PAGE DISPATCH TABLE.

FHPGFF:	.WORD	EOPAGE			;end-of-page processing
FHPG:	.WORD	DOSPLT			;print splats
	.WORD	SKIP			;skip lines
	.WORD	DOACT			;Do account name?
	.WORD	ACTNAM			;display account name
	.WORD	SKIP			;skip lines
	.WORD	DOENT			;Do file name?
	.WORD	FILNAM			;display file name
	.WORD	SKIP			;skip lines
	.WORD	DOENT			;Do file type?
	.WORD	FILTYP			;display file type
	.WORD	SKIP			;skip lines
	.WORD 	DODEV			;Do device name?
	.WORD	DEVNAM			;display device and PPN
	.WORD	SKIP			;skip lines
	.WORD	POSITN			;position 3 bottom splats at location
	.WORD	DOSPLT			;print splats
	.WORD	SPLATF			;print interpage splats
;	.WORD	EOPAGE			;end-of-page processing
	.WORD	EOPGFH			;end-of-header-page processing

;
;	File header pages consists of:
;
;		9 lines for account name
;		14 lines or 7 lines each for filename and extension
;		7 lines for device name
;

FTPG:	.WORD	EOPAGE			;end-of-page processing		;056
	.WORD	DOSPLT			;print splats			;056
	.WORD	SKIP			;skip lines			;056
	.WORD	DOACT			;Do account name?		;056
	.WORD	ACTNAM			;display account name		;056
	.WORD	SKIP			;skip lines			;056
	.WORD	DOENT			;Do FILE?			;057
	.WORD	ENDFI1			;FILE				;057
	.WORD	SKIP			;skip lines			;057
	.WORD	DOENT			;Do END?			;057
	.WORD	ENDFI2			;END				;057
	.WORD	SKIP			;skip lines			;056
	.WORD 	DODEV			;Do device name?		;056
	.WORD	DEVNAM			;display device and PPN		;056
	.WORD	SKIP			;skip lines			;056
	.WORD	POSITN			;position 3 bottom splats at location
	.WORD	DOSPLT			;print splats			;056
	.WORD	EOPGFT			;end of trailer page processing	;056

;	File trailer page						;056
;

.SBTTL	JOB HEADER PAGE DISPATCH TABLE.

JHPGFF:	.WORD	EOPAGE
JHPG:	.WORD	DOSPLT
	.WORD	SKIP
	.WORD	DOACT			;ACTNAM must follow this word
	.WORD	ACTNAM
	.WORD	SKIP
	.WORD	CENTER
	.WORD	DOENT			;ENTNAM must follow this word
	.WORD	ENTNAM
	.WORD	CENPT2
	.WORD	SKIP
	.WORD	DOPPN			;PPNSTR must follow this word
	.WORD	PPNSTR
	.WORD	SKIP
	.WORD	POSITN
	.WORD	DOSPLT
	.WORD	SPLATJ
	.WORD	EOPGJH

;
;	Job header pages consist of:
;
;		9 lines for account name
;		14 or 7 lines for entry name
;		7 for PPN
;

JTPG:	.WORD	EOPGJT

;	Job trailer page
;				(*Not yet implemented*)

	.DSABL	LSB

.SBTTL	HEADER	- Routines to print items on header pages

;+
;	CALLED FROM DIPATCH TABLE ABOVE
;
;	DO???	- determines if enough lines are left on the form for next item
;	ENTNAM	- center the entry name in page double height.
;	ACTNAM	- center the account name in page single height.
;	PPNSTR	- center the ppn string in page single height.
;	FILNAM	- left justify current file name in page double height.
;	ENDFI1  - FILE in double height.
;	ENDFI2  - END in double height.
;	FILTYP	- left justify current file type in page double height.
;	PAGE	- goto new page.
;	EOPAGE	- tof.
;	PAGEIF	- tof if required.
;	EOPGJT	- end of job trailer page.
;	EOPGFT	- end of file header page.
;	EOPGJH	- end of job header page.
;	EOPGFH	- end of file header page.
;	CENTER	- vertically center entry name field in page.  (Job header only)
;	CENPT2	- part2 of CENTER.  (Job header only)
;	SKIP	- skip either 1 or 2 lines depending on form length.
;	SPLATJ	- inter page splat lines for job headers.
;	SPLATF	- inter page splat lines for file headers.
;	DOSPLT	- 3 line splat generator.
;	POSITN	- position last DOSPLT line at correct location.
;-

	.ENABL	LSB

DOENT:	MOV	#2,ENTSIZ(R5)		;assume double height chars
	MOV	#23.,R2			;required spaces for double space/height
	CMP	#41.,DDVERC(R5)		;Single or double spacing?	;069
	BLOS	10$			;double sticks
	MOV	#3,ENTSIZ(R5)		;set single space/height (#3=no descend)
	MOV	#15.,R2			;required spaces for single space/height
10$:	CMP	R2,DDVERT(R5)		;enough spaces left on page?	;069
	BLOS	90$			;yes, do it to it
	ADD	#2,SPLLIN(R5)		;no, skip entry name routine
	BR	90$			;and skip to next routine

ENDFI1:	MOV	#CFLKWD,R2		;get addr of start of packet	;057
	BR	12$			;go to common print		;057

ENDFI2:	MOV	#CEDKWD,R2		;get addr of start of packet	;057
	BR	12$			;go to common print		;057

ENTNAM:	MOV	JOBPTR(R5),R2		;get addr of start of packet	;057
.ASSUME	JB.NAM	EQ JB.NML+1		;ensure name follows length byte;057
	ADD	#JB.NML+HD.LEN,R2	;R2 -> entry name length	;057
					; fall through to common print	;057

12$:	MOV	CHARX2(R5),R3		;assume we want x2 chars	;057
	MOV	ENTSIZ(R5),R4		;recall size of char we want
	CMP	#2,R4			;did we want x2 chars?
	BEQ	15$			;yes, assumption is OK
	MOV	CHARX1(R5),R3		;set size of chars/line for x1
15$:	MOVBYT	(R2)+,R1		;R1 = length of entry name	;057
	BNE	20$			;non-null, so continue
	MOV	#FILLER,R2		;null, so use filler
	MOVBYT	(R2)+,R1		;and it's length
20$:	CMP	R1,R3			;will name exceed line length?
	BLOS	30$			;no, so continue
	MOV	R3,R1			;yes, so truncate name
30$:	JMP	170$			;go join common code

DOPPN:	CMP	#15.,DDVERT(R5)		;enough lines for PPN?		;069
	BLOS	90$			;yes do the PPN
	ADD	#2,SPLLIN(R5)		;no, skip PPN routine
	BR	90$			;and on to the next routine

PPNSTR:	MOV	CHARX1(R5),R3		;get max single chars per line	;031
	MOV	#PPNBUF,R2		;get offset of PPN buffer	;031
	ADD	R5,R2			;R2 -> PPN Buffer
	MOVBYT	(R2)+,R1		;R1 = length of PPN string	;031
	BNE	40$			;non-null, so continue		;031
	MOV	#FILLER,R2		;null, so use filler
	MOVBYT	(R2)+,R1		;and it's length
40$:	MOV	#3,R4			;load size of chars (#3=no descenders)
	CMP	R1,R3			;is name longer than our buffer?
	BLOS	30$			;no, so go output the ppn name
	MOV	R3,R1			;yes, so truncate the length
	BR	30$			;and join common code

FILNAM:	MOV	CHARX2(R5),R3		;assume we want x2 chars
	MOV	ENTSIZ(R5),R4		;recall size of char we want
	CMP	#2,R4			;did we want x2 chars?
	BEQ	45$			;yes, assumption is OK
	MOV	CHARX1(R5),R3		;set size of chars/line for x1
45$:	MOV	NAM(R5),R2		;R2 -> file name block
	MOV	NAML(R5),R1		;R1 =  length of file name
	BNE	60$			;non-null, so continue
50$:	MOV	#FILLER,R2		;null, so use filler
	MOVBYT	(R2)+,R1		;and it's length
	BR	80$			;go join common

60$:	CMPB	(R2)+,#']		;find start of file name (end of PPN)
	BNE	60$			;keep trying & hope it's there
	PUSH	R2			;save pointer to file name start
	CLR	R1			;clear file name length counter
70$:	CMPB	(R2)+,#'.		;find end of file name
	BEQ	80$			;found it, so stop search
	INC	R1			;not yet, so bump length
	BR	70$			;and try again till found

80$:	POP	R2			;restore start of filename pointer
	INC	R1			;include the dot in print out
	CMP	R1,R3			;is it longer than our buffer?
	BLOS	125$			;no, so continue
	MOV	R3,R1			;yes, so truncate the length
	BR	125$			;and join common code

90$:	ADD	#2,SPLLIN(R5)		;and on to next header task
	CLR	SPLCNT(R5)		;and start at it's begining
	RETURN				;exit

FILTYP:	MOV	CHARX2(R5),R3		;assume we want x2 chars
	MOV	ENTSIZ(R5),R4		;recall size of char we want
	CMP	#2,R4			;did we want x2 chars?
	BEQ	95$			;yes, assumption is OK
	MOV	CHARX1(R5),R3		;set size of chars/line for x1
95$:	MOV	NAM(R5),R2		;R2 -> file string
	MOV	NAML(R5),R1		;R1 =  length of file string
	BNE	110$			;non-null, so continue
100$:	MOV	#FILLER,R2		;null, so use filler
	MOVBYT	(R2)+,R1		;and it's length
	BR	120$			;go join common

110$:	DEC	R1			;compute extension length
	CMPB	(R2)+,#'.		;find dot
	BNE	110$			;keep trying & hope it's there
120$:	CMP	R1,R3			;is it longer than our buffer?
	BLOS	200$			;no, so go print it
	MOV	R3,R1			;yes, so trunctate the length
125$:	BR	200$			;and join common code

DODEV:	CMP	#15.,DDVERT(R5)		;enough lines for device name?	;069
	BLOS	90$			;yes do the device name
	ADD	#2,SPLLIN(R5)		;no, skip DEVNAM routine
	BR	90$			;and on to the next routine

DEVNAM:	MOV	CHARX1(R5),R3		;get max number of chars X 1 per line
	MOV	#3,R4			;set single size chars (no descenders)
	MOV	NAM(R5),R2		;set address of device name
	TST	NAML(R5)		;was there an actual name?
	BNE	130$			;yes, use it
	MOV	#FILLER,R2		;no, use the default
	MOVBYT	(R2)+,R1		;and it's length
	BR	200$			; don't bother to center it

130$:	CMPB	(R2),#'_		;Preceded by an '_'?
	BNE	140$			;No, contains printable information
	INC	R2			;Yes, don't print the underscore
140$:	PUSH	R2
	CLR	R1			;clear counter
150$:	INC	R1			;update length
	CMPB	(R2)+,#']		;are we at the end of the string yet
	BNE	150$			;no, keep searching
	POP	R2
	CMP	R1,R3			;will name fit on line?
	BLOS	170$			;yes, center it
	MOV	R3,R1			;no, print as much as will fit
	BR	200$			;and don't bother to center it

DOACT:	CMP	#17.,DDVERT(R5)		;Enough lines for account name?	;069
	BLOS	90$			;yes, go ahead and do it
	ADD	#2,SPLLIN(R5)		;no, skip actnam routine
	BR	90$			;and do next item
	
ACTNAM:	MOV	CHARX1(R5),R3		;R3 = max single chars per line
	MOV	#1,R4			;R4 = single height chars
	MOV	#ACTBUF,R2		;R2 = offset to account name
	ADD	R5,R2			;R2 -> account name buffer
	MOVBYT	(R2)+,R1		;R1 =  length of name
	BNE	160$			;non-null, so continue
	MOV	#PPNBUF,R2		;null, so use PPN string
	ADD	R5,R2			;R2 -> PPN buffer
	MOVBYT	(R2)+,R1		;and it's length
	BNE	160$			;non-null, so continue
	MOV	#FILLER,R2		;null, so use filler
	MOVBYT	(R2)+,R1		;and it's length
160$:	CMP	R1,R3			;will name exceed line?
	BLOS	170$			;no, so go print the line
	MOV	R3,R1			;yes, so truncate name	
	.BR	170$			;and join common

;
;	Common code to convert a string to x1 or x2 block letters.
;
;	Registers:
;
;		R1 =  Length of string to write
;		R3 =  Number of characters on the line
;		R4 =  #1 or #2 for single or double height
;		      #3 means single height, no descenders
;		R5 -> Impure area
;

170$:					;compute no. fill chars for centering
	SUB	R1,R3			;find out how much room is left on line
	BEQ	200$			;if none then all set
	PUSH	R5			;save R5
	CLR	R5			;start with a zero
	ASR	R3			;divide by 2
	BCC	180$			;is cc then don't add 1/2 a chr width
	MOV	#<CHRWD+1>/2,R5		;size of 1/2 character	
180$:	CMP	#3,R4			;is this a x1 no descender?
	BEQ	182$			;yes, multiply as if it were a one
	MUL	R4,R3			;now time the multiplier
182$:	MUL	#CHRWD+1,R3		;now times character width
	ADD	R5,R3			;conditionally add 1/2 character
	POP	R5			;restore R5
	PUSH	R4			;save a reg
	MOV	REC(R5),R4		;get pointer to buffer
	MOV	R3,RECL(R5)		;and up the count
190$:	MOVB	#BLANK,(R4)+		;init it to blanks
	SOB	R3,190$			;till done
	POP	R4			;restore a reg
200$:	PUSH	R0			;save R0
	MOV	SPLCNT(R5),R0		;get the context word
	MOV	REC(R5),R3		;pointer to buffer
	ADD	RECL(R5),R3		;correct for 1/2 character
	PUSH	R5			;save R5
	CMP	#3,R4			;is this an x1 no descender line?
	BNE	205$			;no, it's the regular type
	MOV	#1,R5			;set real char size in R5
	BR	207$			;and continue

205$:	MOV	R4,R5			;put character size in R5
	CMP	#1,R4			;is this an x1 character?
	BEQ	210$			;yes, so leave #1 in R4 for low case
207$:	CLR	R4			;no, so don't enable lower case
210$:	CALLX	CHRLIN			;and do it
	POP	R5			;restore R5
	ADD	R4,RECL(R5)		;update the data counter
	MOV	R0,SPLCNT(R5)		;save the line counter
	POP	R0			;and put R0 back
	TST	R4			;was there any data?
	BNE	220$			;yes so we want to come back here
	ADD	#2,SPLLIN(R5)		;no, go to next routine
	CLR	SPLCNT(R5)		;and start at it's begining
	CLR	RECL(R5)		;and undo the blanks
	RETURN

220$:	CALL	SAVOPT			;save current file options
	BIS	#LPTNOX!LPTHDR,DDFLAG(R5) ;and force /TRUNCATE on headers
	BIC	#LPTOVF,DDFLAG(R5)	;and no /FEED
	CALLR	PRINTD			;go print it from the buffer

	.DSABL	LSB

	.ENABL	LSB

;+
;
; CENTERing algorithm used:
;
; Average page layout (for pages that have room for entry name & ppn):
;
;	single space (less than 41 lines in form), 3 splats, 1 blank, 9 acco
;		name, 1 blank, * blanks (this routine calculates this number),
;		7 entry name, * blanks, 1 blank, 7 ppn, 1 blank, 3 splats, 4 
;		interpage perf.
;	double space (greater than 41 lines in form), 3 splats, 2 blanks, 9
;		acco name, 2 blanks, * blanks, 14 entry name, * blanks, 2 
;		blanks, 7 ppn, 2 blanks, 3 splats, 4 interpage perf.
;
; Formula for centering:
;
;	single space -   (DDVERT - A - B1 - C1) / 2
;	double space -   (DDVERT - A - B2 - C2) / 2
;
;	where,
;
;		DDVERT	= the number of lines left in a page
;		A	= 7 for the total number of lines taken up by the
;			  3 splats and 4 interpage perf.
;		B1	= 2 for the 2 blank lines before and after ppn
;		B2	= 4 for the 4 blank lines before and after ppn
;		C1	= 14 for lines required by entryname & ppn
;		C2	= 21 for lines required by entryname & ppn
;
; If there aren't enough lines left on the page for entryname and ppn, the
; algorithm is tried again excluding the lines for the ppn (7 for single and
; double both) and one set of blanks (1 for single, 2 for double).
;
;-

CENTER:	PUSH	<R1,R2>
	CLR	CENCNT(R5)		;clear out center counter
	MOV	#2,R1			;assume double spacing
	MOV	#<7.+4.+21.>,R2		;assume double spacing required length
	CMP	#41.,DDVERC(R5)		;Can we use double spacing?	;069
	BLO	10$			;yes, assumption is correct
	MOV	#1,R1			;no, set single spacing
	MOV	#<7.+2.+14.>,R2		;set single spacing required length
10$:	CMP	R2,DDVERT(R5)		;Will ENTNAM & PPN fit?		;069
	BLOS	20$			;Yes, do it
	SUB	#7.,R2			;subtract space off for PPN
	SUB	R1,R2			;subtract space off for blank separator
	CMP	R2,DDVERT(R5)		;Will ENTNAM alone fit?		;069
	BHI	35$			;Nope, forget this routine
20$:	MOV	DDVERT(R5),R1		;get number of lines left	;069
	SUB	R2,R1			;R1 = number of lines left on page
	ASR	R1			;divide by two
	BEQ	35$			;skip rest if zero
	MOV	R1,CENCNT(R5)		;set center counter for part two
30$:	CALL	PRINTC			;send <CR><LF>
	SOB	R1,30$			;for number of lines to center
35$:	POP	<R2,R1>
40$:	ADD	#2,SPLLIN(R5)		;go to next routine
	RETURN

CENPT2:	TST	CENCNT(R5)		;any lines to center by?
	BEQ	40$			;nope, goto next routine
	PUSH	<R1,R2>
	MOV	CENCNT(R5),R1		;get copy of number of lines to print
	BR	30$			;join common code

SKIP:	ADD	#2,SPLLIN(R5)		;go to next routine
	CLR	SPLCNT(R5)		;and start at it's begining
	CALL	SAVOPT			;save current file options
	BIS	#LPTNOX!LPTHDR,DDFLAG(R5) ;and force /TRUNCATE on headers
	BIC	#LPTOVF,DDFLAG(R5)	;and no /FEED
	CLR	R4			;zero length
	CMP	#41.,DDVERC(R5)		;does the form have 41 lines?	;069
	BLOS	50$			;yes, use double spacing
	CMP	#8.,DDVERT(R5)		;enough room for this spacing?	;069
	BHI	60$			;no, ignore this routine
	CALLR	PRINT			;print <CRLF>

50$:	CMP	#9.,DDVERT(R5)		;enough room for this spacing?
	BHI	60$			;no, ignore this routine
	CALLR	PPRINT			;print <CRLF><CRLF>

PAGE:	ADD	#2,SPLLIN(R5)		;and on to next header task
	CLR	SPLCNT(R5)		;and start at it's begining
	BR	70$			;and go do the <FF>

EOPAGE:	ADD	#2,SPLLIN(R5)		;and on to next header task
	CLR	SPLCNT(R5)		;and start at it's begining
PAGEIF:	MOV	REC(R5),R1		;Pick up buffer pointer		;073
	TST	DDHORZ(R5)		;Are we at the left margin?	;073
	BEQ	55$			;Yes, no need for a <CR>	;073
	MOVB	#CR$CR,(R1)+		;Stuff a <CR> into the buffer	;073
	INC	RECL(R5)		;Record the new buffer length	;073
55$:	CMP	DDVERC(R5),DDVERT(R5)	;Are we on the top line?	;073
	BNE	70$			;No, send a <FF>		;073
	BIT	#J.DRTY,JOBSTA(R5)	;Yes, is the page clean?	;073
	BNE	70$			;No.  <FF> needed		;073
	TST	RECL(R5)		;Anything left in buffer?	;073
	BNE	80$			;Yes, be sure to print it	;073
60$:	RETURN				;Nothing more to do		;073

70$:	MOVB	#CR$FF,(R1)+		;Stuff a <FF> into the buffer	;073
	INC	RECL(R5)		;and record the new buffer length
80$:	CALL	SAVOPT			;Save current file options	;073
	BIS	#LPTNOX!LPTHDR,DDFLAG(R5) ;and force /TRUNCATE on headers
	BIC	#LPTOVF,DDFLAG(R5)	;and no /FEED
	CALLR	PRINTD			;go print it from the buffer

	.DSABL	LSB

	.ENABL	LSB

EOPGJT:	INCB	PGJT(R5)		;show us on the next copy
	BR	10$			;join common end processing

EOPGFT:	CLRFUN	S.PGFT,R0		;STOP ANY FILE TRAILER PAGES	;056
	BIC	#H$FILT,HDRFLG(R5)	;Show done with file trailer page ;056
;	INCB	PGFT(R5)		;show us on the next copy	;056
	BR	10$			;join common end processing

EOPGJH:	INCB	PGJH(R5)		;show us on the next copy
	BR	10$			;join common end processing

EOPGFH:	INCB	PGFH(R5)		;show us on the next copy
	.BR	10$			;join common end processing

10$:	CLR	SPLCNT(R5)		;done with this so reset
	CLR	SPLLIN(R5)		;me too
	RETURN

	.DSABL	LSB

	.ENABL	LSB

SPLATJ:	MOVBYT	JB.JHD(R2),R3		;number of job hdrs requested	;025
	MOVBYT	PGJH(R5),R4		;number already printed		;025
	SUB	R4,R3			;if non-zero we have work to do
	DEC	R3			;subtract off the 1's bias
	BR	10$			;cuz then we have a next page

SPLATF:	MOVBYT	JB.FHD(R2),R3		;number of file hdrs requested	;025
	MOVBYT	PGFH(R5),R4		;number already printed		;025
	SUB	R4,R3			;if non-zero we have work to do
	DEC	R3			;subtract off the 1's bias
	BR	10$			;cuz then we have a next page

10$:	INC	SPLCNT(R5)		;show one more pass through
	TST	R3			;was there a previous or next page?
	BEQ	20$			;no so get to next routine
	CMPB	DDVERT(R5),DDVERC(R5)	;have we printed enough splats yet?
	BNE	40$			;no, go do another
20$:	ADD	#2,SPLLIN(R5)		;yes so go to next routine
	CLR	SPLCNT(R5)		;and start at it's begining
	RETURN

DOSPLT:	TST	SPLCNT(R5)		;Is this the first time through?
	BNE	30$			;no, splats in progress
	CMPB	#7,DDVERT(R5)		;Are there enough lines to do this?
	BHI	20$			;no, go on to the next item
30$:	INC	SPLCNT(R5)		;show one more pass through
	CMP	SPLCNT(R5),#BARS	;have we printed enough copies yet?
	BLO	40$			;no, so continue
	ADD	#2,SPLLIN(R5)		;yes, so next to go to next routine
	CLR	SPLCNT(R5)		;and start at it's begining

40$:	PUSH	R0
	MOV	REC(R5),R1		;R1 -> print buffer		;030
	BIT	#H$JOBH,HDRFLG(R5)	;are we printing job headers?	;030
	BEQ	45$			;no, so use file splat buffer	;056
	MOV	#JHSPLT,R4		;yes, R4 -> job header splat	;030
	BR	60$			;and join common		;030

45$:	BIT	#H$FILT,HDRFLG(R5)	;are we printing file trailers?	;056
	BEQ	50$			;no, so use file splat buffer	;056
	MOV	#FTSPLT,R4		;yes, R4 -> file trailer splat	;056
	BR	60$			;and join common		;056

50$:	MOV	#FHSPLT,R4		;R4 -> file header splat	;030
	.BR	60$			;join common			;030

60$:	MOV	(R4)+,R0		;get next field to copy
	BEQ	80$			;none, so print the buffer
	TST	(R4)+			;Is this an offset or an address?
	BEQ	70$			;If this is a real 'PURE' address
	ADD	R5,R0			;An offset, adjust to make real address
70$:	MOVBYT	(R0)+,R2		;R2 = length of chars to copy
	MOVSTR	R0,R1,R2		;copy field into buffer
	ADD	R2,RECL(R5)		;and update buffer length
	ADD	R2,R1			;  and pointer into buffer
	BR	60$			;continue with next field

80$:	POP	R0
	CALL	SAVOPT			;save current file options
	BIS	#LPTNOX!LPTHDR,DDFLAG(R5) ;force /TRUNCATE on headers
	BIC	#LPTOVF,DDFLAG(R5)	;and no /FEED
	CALLR	PRINTD			;print the buffer		;030
;	RETURN				;exit				;030

POSITN:	MOVBYT	DDVERT(R5),R1		;get number of lines left on page
	SUB	#7.,R1			;last 7 lines of form are in use
	BLE	100$			;this routine is a NOP if < 7 lines
90$:	CALL	PRINTC			;write out a CRLF
	SOB	R1,90$			;until the desired location is hit
100$:	ADD	#2,SPLLIN(R5)		;set next routine
	RETURN				;and exit

CHRWD=5
BARS=3

	.DSABL	LSB

.SBTTL	SAVENT	- SAVE JOB'S ENTRY-SPEC STRING

;+
; SAVENT
;
;		Save job's entry-spec string
;		("queue:[ppn]name").
;
; Input:	R5 -> impure area
;
; Call:		JSR	PC,SAVENT
;
; Output:	Entry-spec string saved in (ascic) buffer
;		Buffer padded with trailing blanks
;		All regs preserved
;
;-

	.ENABL	LSB

SAVENT:	SAVREG				;save all regs
	MOV	#ENTBUF,R1		;R1 = offset to Entry buffer
	ADD	R5,R1			;R1 -> Entry buffer
	MOVBYT	(R1)+,R3		;R3 = length of buffer
	MOV	JOBPTR(R5),R4		;get base of job packet
	ADD	#HD.LEN,R4		;R4 -> job packet past header
	MOV	R4,R0			;get base of job packet
	ADD	#JB.QNL,R0		;R0 -> queue name block
	MOVBYT	(R0)+,R2		;R2 = no. chars to copy
.ASSUME	JB.QNM	EQ JB.QNL+1		;ensure name string follows length
	BEQ	10$			;none, so skip copy
	MOVSTR	R0,R1,R2		;copy queue name into buffer
	ADD	R2,R1			;update buffer pointer
	SUB	R2,R3			;update buffer length
	MOVB	#':,(R1)+		;add trailing colon
	DEC	R3			;update buffer length
10$:	TST	JB.PPN(R4)		;any job owner PPN?
	BEQ	20$			;no, so skip PPN build
	PUSH	R1			;yes, save buffer pointer
	MOV	R1,R2			;R2 -> buffer for BLDPPN
	MOV	JB.PPN(R4),R1		;R1 = job owner PPN
	CALLX	BLDPPN			;insert the PPN string
	ADD	R1,(SP)			;update saved buffer pointer
	SUB	R1,R3			;update buffer length
	POP	R1			;restore buffer pointer
20$:	MOV	R4,R0			;get base of job packet
	ADD	#JB.NML,R0		;R0 -> entry name block
	MOVBYT	(R0)+,R2		;R2 =  no. chars to copy
.ASSUME	JB.NAM	EQ JB.NML+1		;ensure name string follows length
	BEQ	30$			;no name, so skip copy
	MOVSTR	R0,R1,R2		;copy entry name into buffer
	ADD	R2,R1			;update buffer pointer
	SUB	R2,R3			;update buffer length
30$:	FILL	#BLANK,R1,R3		;blank fill rest of buffer
	RETURN				;exit

.ASSUME	FIL.LEN	GE <NAM.LEN+1.+9.+NAM.LEN> ;ensure buffer is large enough

	.DSABL	LSB

.SBTTL	SAVFIL	- SAVE CURRENT FILE-SPEC STRING

;+
; SAVFIL
;
;		Save current file-spec string
;		("dev:[ppn]filnam.typ").
;
; Input:	R5 -> impure area
;
; Call:		JSR	PC,SAVFIL
;
; Output:	File-spec string saved in buffer
;		Buffer padded with blanks
;		All regs preserved
;
;-

	.ENABL	LSB

SAVFIL:	SAVREG				;save all regs
	MOV	#FILBUF,R1		;R1 = offset to file name buffer
	ADD	R5,R1			;R1 -> file name buffer
	MOVBYT	(R1)+,R3		;R3 = length of buffer
	MOV	NAM(R5),R0		;R0 -> current file-spec name
	MOV	NAML(R5),R2		;R2 = length of current file-spec name
	BEQ	20$			;no file, so skip copy
	CMP	R2,R3			;is file-spec name too long?
	BLOS	10$			;no, so continue
	MOV	R3,R2			;yes, so truncate it
10$:	MOVSTR	R0,R1,R2		;copy file-spec name into buffer
	ADD	R2,R1			;update buffer pointer
	SUB	R2,R3			;update buffer length
20$:	FILL	#BLANK,R1,R3		;blank fill the buffer
	RETURN				;exit

	.DSABL	LSB

.SBTTL	SAVJCP	- SAVE CURRENT/TOTAL JOB COPIES STRING
.SBTTL	SAVFCP	- SAVE CURRENT/TOTAL FILE COPIES STRING

;+
; SAVJCP
; SAVFCP
;
;		Save "<current> of <total>" string
;		in buffer.
;
; Input:	R5 -> impure area
;
; Call:		JSR	PC,SAVJCP
;		JSR	PC,SAVFCP
;
; Output:	Current/total copies string copied into buffer
;		Buffer padded with blanks
;		All regs preserved
;
;-

	.ENABL	LSB

SAVJCP:	SAVREG				;save all regs
	MOV	JOBCOP(R5),R3		;R3 = current job copy value
	MOV	JOBPTR(R5),R4		;get copy of job pointer
	MOVBYT	JB.COP+HD.LEN(R4),R0	;R0 = number of total job copies
	MOV	#JCPBUF,R1		;R1 = offset to job copies buffer
	BR	10$			;and join common

SAVFCP:	SAVREG				;save all regs
	MOV	FILCOP(R5),R3		;R3 = file copy value
	MOV	FILSPC(R5),R4		;R4 -> current filespec block
	MOVBYT	FB.COP(R4),R0		;R0 = number of total file copies
	MOV	#FCPBUF,R1		;R1 = offset to file copies buffer
	.BR	10$			;and join common

10$:	ADD	R5,R1			;R1 -> one of the buffers
	MOVBYT	(R1)+,R2		;R2 = length of buffer
	MOV	R1,R5			;R5 -> copies buffer
	CALLX	BIN2D			;insert current copy no. string
	MOVB	#BLANK,(R5)+		;skip a space
	MOVB	#'o,(R5)+		;insert a 'o
	MOVB	#'f,(R5)+		;insert a 'f
	MOVB	#BLANK,(R5)+		;skip a space
	MOV	R0,R3			;Set for total copies number
	CALLX	BIN2D			;insert total copies no. string
	MOV	R5,R0			;get copy of current buffer pointer
	SUB	R1,R0			;compute no. chars copied
	SUB	R0,R2			;R2 = no. chars to fill
	FILL	#BLANK,R5,R2		;blank fill rest of field
	RETURN				;and return

	.DSABL	LSB

.SBTTL	SAVDEV	- SAVE JOB'S DEVICE NAME STRING

;+
; SAVDEV
;
;		Save job's device name string
;		in buffer.
;
; Input:	R5 -> impure area
;
; Call:		JSR	PC,SAVDEV
;
; Output:	Device name string saved in buffer
;		Buffer padded with blanks
;		All regs preserved
;
;-

	.ENABL	LSB

SAVDEV:	SAVREG				;save all regs
	MOV	#DEVBUF,R1		;R1 = offset to device name buffer
	ADD	R5,R1			;R1 -> device name buffer
	MOVBYT	(R1)+,R3		;R3 = buffer length
	MOV	JOBPTR(R5),R0		;get base of current job packet
	ADD	#HD.LEN+JB.DVL,R0	;R0 -> device name length
	MOVBYT	(R0)+,R2		;R2 = length of device name
.ASSUME	JB.DEV	EQ JB.DVL+1		;ensure device name follows length byte
	BEQ	20$			;no device, so skip copy
	CMP	R2,R3			;is the device name too big?
	BLOS	10$			;no, so continue
	MOV	R3,R2			;yes, so truncate the name
10$:	CALLX	CLRFQX			;clear firqb and xrb for FSS
	MOV	R2,@#XRB		;set length of string
	MOV	R2,@#XRB+XRBC		; twice
	MOV	R0,@#XRB+XRLOC		;set starting address of string
	.FSS				;Convert controller syntax to KBn:
	TSTB	@#FIRQB			;Errors?
	BNE	20$			;Yes, use blanks
	MOV	R3,R4			;set buffer length for UNFSS
	MOV	R1,R5			;set buffer pointer for UNFSS
	CALLX	UNFSS			;translate to printable form
	MOV	R5,R1			;update buffer pointer
	MOV	R4,R3			;update buffer length
20$:	FILL	#BLANK,R1,R3		;blank fill the buffer
	RETURN				;and exit

	.DSABL	LSB

.SBTTL	SAVFRM	- SAVE JOB'S FORM NAME IN BUFFER

;+
; SAVFRM
;
;		Save job's form name in buffer.
;
; Inputs:	R5 -> impure area
;
; Call:		JSR	PC,SAVFRM
;
; Output:	Form name string saved in buffer.
;		Buffer padded with blanks
;		All regs preserved
;
;-

	.ENABL	LSB

SAVFRM:	SAVREG				;save all regs
	MOV	#FRMBUF,R1		;R1 = offset to form name buffer
	ADD	R5,R1			;R1 -> form name buffer
	MOVBYT	(R1)+,R3		;R3 = length of buffer
	MOV	JOBPTR(R5),R0		;get base of current job packet
	ADD	#HD.LEN+JB.FML,R0	;R0 -> form name length
	MOVBYT	(R0)+,R2		;R2 = length of form name
.ASSUME	JB.FRM	EQ JB.FML+1		;ensure form string follows length byte
	BEQ	20$			;no form name, so skip copy
	CMP	R2,R3			;is the form name too big?
	BLOS	10$			;no, so continue
	MOV	R3,R2			;yes, so truncate the name
10$:	MOVSTR	R0,R1,R2		;copy the name into buffer
	ADD	R2,R1			;update buffer pointer
	SUB	R2,R3			;update buffer length
20$:	FILL	#BLANK,R1,R3		;blank fill rest of buffer
	RETURN				;and exit

	.DSABL	LSB

.SBTTL	SAVDAT	- SAVE CURRENT DATE/TIME STRING

;+
; SAVDAT
;
;		Save current date/time string in buffer.
;
; Inputs:	R5 -> impure area
;
; Call:		JSR	PC,SAVDAT
;
; Output:	Current date/time strings saved in buffer
;		Buffer padded with blanks
;		All regs preserved
;
;-

	.ENABL	LSB

SAVDAT:	SAVREG				;save all regs
	MOV	#DATBUF+1,R1		;R1 = offset to date/time buffer
	ADD	R5,R1			;R1 -> date/time buffer
	MOV	R1,R3			;save start of buffer for later
	.DATE				;get current date & time
	CALLX	CLRFQB			;clear the FIRQB
	MOVB	#UU.CNV,@#FIRQB+FQFUN	;load UU.CNV function
	MOV	@#XRB+0,@#FIRQB+FQFIL	;load internal date
;	MOV	#0,@#FIRQB+FQPPN	;use default date format
	MOV	@#XRB+2,@#FIRQB+FQMODE	;load internal time
;	MOV	#0,@#FIRQB+FQFLAG	;use default time format
	.UUO				;convert date/time strings
	FQBERR	10$			;error, so leave buffer blank
	MOV	#FIRQB+FQNAM1,R0	;R0 -> date string to copy
	MOV	#9.,R2			;R2 =  max chars to copy
	CALL	MOVASZ			;copy date into buffer
	MOVB	#BLANK,(R1)+		;skip a space
	MOV	#FIRQB+FQPFLG,R0	;R0 -> time string to copy
	MOV	#8.,R2			;R2 =  max chars to copy
	CALL	MOVASZ			;copy time into buffer
10$:	MOV	R1,-(SP)		;save buffer pointer
	SUB	R3,(SP)			;(SP) = no. chars copied
	MOVBYT	DATBUF(R5),R2		;get length of date/time buffer
	SUB	(SP)+,R2		;R2 = no. chars to blank fill
	FILL	#BLANK,R1,R2		;blank fill rest of buffer
	RETURN				;exit

	.DSABL LSB

.SBTTL	SAVSYS	- SAVE SYSTEM NAME IN BUFFER

;+
; SAVSYS
;
;		Save system name in buffer
;
; Input:	R5 -> impure area
;
; Call:		JSR	PC,SAVSYS
;
; Output:	System name saved in buffer
;		Buffer padded with blanks
;		All regs preserved
;
;-

	.ENABL	LSB

SAVSYS:	SAVREG				;save all regs
	MOV	#SYSBUF+1,R1		;R1 = offset to system name buffer
	ADD	R5,R1			;R1 -> system name buffer
	MOV	R1,R3			;save buffer pointer
	CALLX	CLRFQB			;clear the FIRQB
	MOVB	#ERRFQ,@#FIRQB+FQFUN	;load ERRFQ function
;	MOVB	#0,@#FIRQB+FQERNO	;load error code 0
	CALFIP				;get the system name
	FQBERR	20$			;error, so leave buffer blank
	MOV	#FIRQB+4,R0		;R0 -> system name
	MOV	#28.,R2			;R2 =  max chars to copy
	CMP	R2,R3			;is name too big for buffer?
	BLOS	10$			;no, so continue
	MOV	R3,R2			;yes, so truncate name
10$:	CALL	MOVASZ			;copy name into buffer
20$:	MOV	R1,-(SP)		;save buffer pointer
	SUB	R3,(SP)			;(SP) = no. chars copied
	MOVBYT	SYSBUF(R5),R2		;get length of system name buffer
	SUB	(SP)+,R2		;R2 = no. chars to blank fill
	FILL	#BLANK,R1,R2		;blank fill rest of buffer
	RETURN				;exit

	.DSABL	LSB

.SBTTL	SAVACT	- SAVE JOB'S ACCOUNT NAME AND PPN STRING

;+
;
; SAVACT
;
;		Save account name and PPN string
;		for job owner (JB.PPN).  If no
;		account name attribute block is
;		found, then the account name field
;		is left blank.
;
; Input:	R5 -> Impure area
;
; Call:		JSR	PC,SAVACT
;
; Return:	C=0 account name and PPN string saved
;		C=1 no PPN found in job packet
;		All regs preserved
;
;-

SAVACT:	SAVREG				;save all regs
	CLRB	PPNBUF(R5)		;show no PPN string yet
	CLRB	ACTBUF(R5)		;show no account name yet
	MOV	JOBPTR(R5),R1		;get pointer to job packet
	MOV	JB.PPN+HD.LEN(R1),R1	;R1 = owner PPN
	BEQ	10$			;no PPN, so fail
	MOV	R1,R4			;R4 = copy of owner PPN
	MOV	#PPNBUF+1,R2		;R2 = offset to PPN string buffer
	ADD	R5,R2			; R2 -> PPN string buffer
	CALLX	BLDPPN			;build PPN string in buffer
	MOVB	R1,PPNBUF(R5)		;save length of string
	CALLX	CLRFQB			;clear the FIRQB
	MOVB	#UU.ATR,@#FIRQB+FQFUN	;load read attrib fun
	MOV	R4,@#FIRQB+FQPPN	;load the ppn to look up
	MOVB	#-1,@#FIRQB+FQFIL	;read UDF attribute
	MOVB	#5,@#FIRQB+FQSIZM	;read account name block
	.UUO				;read the attribute block
	TSTB	@#FIRQB			;any errors?
	BNE	10$			;yes, so leave field null
	MOV	#FIRQB+FQNAM1+1,R0	;R0 -> account name
	MOV	#ACTBUF+1,R1		;R1 = offset to account name buffer
	ADD	R5,R1			;R1 -> account name buffer
	MOV	#13.,R2			;R2 = max length of name
	MOV	R1,-(SP)		;save starting buffer loc
	CALL	MOVASZ			;copy name into buffer
	SUB	(SP)+,R1		;compute no. bytes copied
	MOVB	R1,ACTBUF(R5)		;save length of name
	TST	(PC)+			;clear carry for success
10$:	SEC				;set carry (no PPN found)
	RETURN				;exit

	.DSABL	LSB

.SBTTL	MOVASZ	- COPY ASCIZ STRING (UP TO NULL) INTO BUFFER

;+
; MOVASZ:
;
;		Copy a string into buffer. Copy ends
;		when dst buffer full or null detected.
;
; Input:	R0 -> src buffer
;		R1 -> dst buffer
;		R2 =  length of dst buffer
;
; Call:		JSR	PC,MOVASZ
;
; Return:	Src buffer copied to dst
;		R0, R1 updated
;		R2 = no. bytes remaining in dst buffer
;		All other regs preserved
;
;-
	.ENABL	LSB

MOVASZ:	TST	R2			;any room in dst buffer?
	BEQ	20$			;no, so exit
10$:	TSTB	(R0)			;is src char a null?
	BEQ	20$			;yes, so exit copy
	MOVB	(R0)+,(R1)+		;no, so copy char into dst buffer
	SOB	R2,10$			;  until done
20$:	RETURN				;exit

	.DSABL	LSB

.SBTTL	FORM	- Form set-up routine

;+
;
; FORM:
;
;	Set form and device characteristics as specified in form area.
;
; INPUTS:
;
;		R5 -> IMPURE AREA
;		R0 -> FUNCION BITS TABLE
;
; CALL:
;
;	JSR	PC,FORM
;
; BACK:
;
;		SOME THING DONE WITH FORMS
;			STALL AND RETRY IF FAILURE
;			CRASH ON UNKNOWN ERRORS
;
;
;
;	ONLY RETURN IF SUCCESS
;	ON FAILURE STALL SPOOLER
;
;-

FORM:	CLR	DEVHNG(R5)		;clear device hung bad flag
	MOV	JOBPTR(R5),R1		;get form pointer
	ADD	#HD.LEN,R1		;don't forget the header!
;071	CLR	DDFLAG(R5)		;clear the device flag		;071
	MOV	#FORMQ,R2		;get point to charistics tab	;037
	MOV	#FORMQL,R3		;get the length of the tab	;037
10$:	BIC	2(R2),DDCHAR(R5)	;Clear the bit initially	;037
	BIT	(R2),JB.DCH(R1)		;Does the server have this?	;037
	BEQ	20$			;No, don't set it		;037
	BIS	2(R2),DDCHAR(R5)	;Yes, set the charistic		;037
20$:	ADD	#4,R2			;Update the pointer to next	;037
	SOB	R3,10$			;Do for all entries in table	;037
30$:	MOVBYT	JB.WID(R1),R3		;get form width			;025
	MOV	R3,DDHORC(R5)		;load it in to ddb		;069
	CLR	DDHORZ(R5)		;Show carriage as restored	;069
	PUSH	R3			;save line width		;031
	CLR	R2			;init for divide		;031
	DIV	#<CHRWD+1>*1,R2		;R2 = no. single chars per line ;031
	MOV	R2,CHARX1(R5)		;save value in impure		;031
	POP	R3			;restore line width		;031
	CLR	R2			;init for divide		;031
	DIV	#<CHRWD+1>*2,R2		;R2 = no. double chars per line ;031
	MOV	R2,CHARX2(R5)		;and save value in impure	;031
	MOVBYT	JB.LNG(R1),R2		;get form length		;025
	MOV	R2,DDVERT(R5)		;load it in to ddb		;069
	MOV	R2,DDVERC(R5)		;load it in to ddb		;069
	MOV	#1,DDPGT0(R5)		;reset total page count (first word)
	CLR	DDPGT1(R5)		; ...  total page count (second word)
	MOVBYT	JB.BOM(R1),R3           ;Pick up bottom margin		;069
	MOV	R3,DDBOM(R5)		;Store bottom margin		;069
	MOVBYT	JB.TOM(R1),R3           ;Pick up top margin		;069
	MOV	R3,DDTOM(R5)		;Store top margin		;069
	MOVBYT	JB.LEM(R1),R3           ;Pick up left margin		;069
	MOV	R3,DDLEM(R5)		;Store left margin		;069
	MOVBYT	JB.RIM(R1),R3           ;Pick up right margin		;069
	MOV	R3,DDRIM(R5)		;Store right margin		;069
	SETFUN	S.P0CR,R0		;setfun the pre-cram handler
	SETFUN	S.P1CR,R0		;setfun the post-cram handler
	RETURN

.SBTTL	FORM	- Device characteristic qualifer table

;
;
;

	.SAVE
	.PSECT	PURE

FORMQ:	.WORD	FM$CTL,LPTNPC
	.WORD	FM$TOF,LPTHFF
	.WORD	FM$CUP,LPTCUP

	FORMQL	=	<<.-FORMQ>/4>

	.RESTORE

.SBTTL	P0CRAM	- PRE-CRAM HANDLER
.SBTTL	P1CRAM	- POST-CRAM HANDLER

;+
;
; P0CRAM:
; P1CRAM:
;
;
; INPUTS:
;
;		R5 -> IMPURE AREA
;		R0 -> FUNCION BITS TABLE
;
; CALL:
;	JSR	PC,P0CRAM
;	JSR	PC,P1CRAM
;
;
; BACK:
;
;			PRE OR POST CRAM REQUESTED TO PRINT
;			STALL AND RETRY IF FAILURE
;			CRASH ON UNKNOWN ERRORS
;
;
;
;	ONLY RETURN IF SUCCESS
;	ON FAILURE STALL SPOOLER
;
;-

	.ENABL	LSB

P0CRAM:
;	MOV	#FR.0CR,R1		;SAVE OFFSET TO PRE-CRAM ADDR
	BR	10$			;JOIN COMMON
P1CRAM:
;	MOV	#FR.1CR,R1		;SAVE OFFSET TO POST-CRAM ADDR
	SETFUN	S.EMT1,R0		;EMPTY OUTPUT BUFFER AFTER THIS
	.BR	10$			;JOIN COMMON

10$:
;	MOV	JOBPTR(R5),R2		;GET ADDR OF FORM PACKET
;	ADD	#HD.LEN,R2		;POINT PAST HEADER
;	MOV	R2,R3			;SAVE POINTER TO START OF DATA
;	ADD	R1,R2			;AND TO THE P?CRAM AREA
;	TST	(R2)			;ANY THING THERE?
;	BEQ	20$			;NO
;	ADD	(R2),R3			;NOW POINT TO START OF PRECRAM
;	MOV	(R3)+,R4		;AND R3=ADDR, R4=LEN
;	BEQ	20$			;GET OUT IF ZERO LENGTH
;	CALL	SAVOPT			;SAVE THE CURRENT FILE OPTIONS
;	BIS	#LPTHDR,DDFLAG(R5)
;	CALLR	PRINTB			;AND GO PRINT IT (NO CRLF'S)

20$:	RETURN

	.DSABL	LSB

.SBTTL	LOOKUP	- WILD CARD LOOKER UPPER

;+
;
; LOOKUP:
;
;
; INPUTS:
;
;	R0 -> FUNCION BITS TABLE
;	R5 -> IMPURE AREA
;
; CALL:
;
;	JSR	PC,LOOKUP
;
; BACK:
;
;		SOME THING DONE WITH WILD CARDS
;			STALL AND RETRY IF FAILURE
;			CRASH ON UNKNOWN ERRORS
;
;
;
;	ONLY RETURN IF SUCCESS
;	ON FAILURE STALL SPOOLER
;
;-

	.ENABL	LSB

LOOKUP:	MOV	FILSPC(R5),R3		;GET ADDR OF FILE SPEC PACKET
	TSTB	FB.SPL(R3)		;IS THERE A NAME?
	BNE	10$			;YES
	CLR	R2			;NO SO DON'T USE ANY
	CLR	R3			;....
	BR	20$			;GO JOIN BACK UP

10$:	ADD	#FB.SPL,R3		;NOW ADDR OF NAME
	MOVBYT	(R3)+,R2		;R3-> name , R2 = len		;025
20$:	MOV	R2,NAML(R5)		;PRESET NAME LENGTH 
	MOV	R3,NAM(R5)		;PRESET NAME POINTER
	CALL	WLDDIR			;GO MAKE A FILE SPEC
	BCS	30$			;NUTS IT FAILED
	MOV	#SU$SUC,STS(R5)		;SHOW SUCCESS
	MOV	R2,NAML(R5)		;SET IN LENGTH OF FILE SPEC
	MOV	R3,NAM(R5)		;AND POINTER TO FILE SPEC
	CALL	SAVFIL			;save file-spec name		;030
30$:	RETURN				;AND WE ARE DONE FOR NOW

	.DSABL	LSB

.SBTTL	WLDDIR	- Another wild card lookup routine

;+
;
; WILD1(R5) CLEARED AT JOB INITER
; WILD2(R5) CLEARED AT JOB INITER
; WILD4(R5) CLEARED AT JOB INITER
;
; INPUTS:
;
;	R0 -> FUNCTION BITS
;	R2  = LEN OF FILE SPEC
;	R3 -> FILE SPEC
;	R5 -> IMPURE AREA
;
; BACK:
;
;	R0 -> FUNCTION BITS
;	R2  = LEN OF FILE SPEC
;	R3 -> FILE SPEC
;	R5 -> IMPURE AREA
;
;-

	.ENABL	LSB

WLDDIR:	SAVREG				; SAVE ALL REGISTERS
	MOV	WILD1(R5),R0		; RESTORE R0
	MOV	WILD2(R5),R1		; RESTORE R1
	MOV	WILD4(R5),R4		; RESTORE R4
	CALL	WILDL			; GO DO THE WILD LOOKUP
	BCS	10$
	MOV	R0,WILD1(R5)		; SAVE R1 FOR NEXT TIME THROUGH
	MOV	R1,WILD2(R5)		; SAVE R2 FOR NEXT TIME THROUGH
	MOV	R4,WILD4(R5)		; SAVE R4 FOR NEXT TIME THROUGH
	ADD	#NAMBUF,R5		; GET POINTER TO NAME BUFFER
	MOV	#NAMBFS,R4		; LENGTH OF BUFFER
	MOV	R5,TOS.R3(SP)		; PRESET ADDRESS OF REBUILT FILE SPEC
	CALLX	UNFSS			; CREATE AN ASCII FILE SPEC
	MOV	R4,-(SP)		; SAVE AMOUNT FREE
	MOV	#NAMBFS,R4		; GET ORIGINAL SIZE
	SUB	(SP)+,R4		; SUB FREE PART = SIZE USED.
	MOV	R4,TOS.R2(SP)		; AND RETURN IT IN R2
	CLC				; SET SUCCESS
10$:	RETURN				; AND BACK WE GO

	.DSABL	LSB

.SBTTL	WILDL	- Wild card lookup/file lookup

;+
;
; WILDL:
;
;	This routine is resposible for looking up a file spec.
;
; INPUTS:
;
;	R0=FILE INDEX
;	R1=DIRECTORY INDEX
;	R2=LEN OF FILE NAME
;	R3->FILE NAME
;	R4 ?
;
; RETURN:
;
;	R0=FILE INDEX		!!! MUST BE PRESERVED ACCROSS CALLS!
;	R1=DIRECTORY INDEX	!!! MUST BE PRESERVED ACCROSS CALLS!
;	R2= LEN FILE NAME
;	R3->FILE NAME
;	R4			!!! MUST BE PRESERVED ACCROSS CALLS!
;
;	C=0 IF FILE FOUND 
;	C=1 IF FILE NOT FOUND OR INVALID FILE NAME
;	FIRQB = FNF IF FILE NOT FOUND
;
;-

	.ENABL	LSB

WILDL:	SAVREG				; save all registers
	TST	R0			; done with this ppn?
	BNE	20$			; nope, so skip ppn lookup
10$:	MOV	#ER$FNM,STS(R5)		; preset error to file name error
	MOV	(PC),KILLGL(R5)		; kills are legal for 'wierd' files
	CALL	DOFSS			; FSS the file-spec
	BCS	70$			; .FSS failed
	CLR	KILLGL(R5)		; assume kill is illegal for mt
	CMPB	#MTAHND,@#XRB+14	; is device mt:?
	BEQ	70$			; yes, so call it a file name error
	MOV	#ER$FNF,STS(R5)		; set error to file not found
					; can only have 2 types of errors
					; either twas error on the file name
					; in which case we hand it to rms
					; and hope for the best, or we pretend
					; the the file does not exist.
	MOVB	#UU.PPN,@#FIRQB+FQFUN	; load wild card ppn lookup
	MOV	TOS.R1(SP),@#FIRQB+4	; load wildcard  ppn index
	.UUO				; do wildcard ppn lookup
	FQBERR	70$			; skip if error
	MOV	@#FIRQB+FQPPN,TOS.R4(SP); save actual ppn for later

20$:	CALL	DOFSS			; FSS the file-spec (again)
	BCS	70$			; .FSS failed
	BIT	#1,@#XRB+10		; any file name specified?
	BNE	30$			; yes so on we go
	MOV	#134745,@#FIRQB+FQNAM1	; no so use *. (134745=^R???)
	MOV	#134745,@#FIRQB+FQNAM1+2; no so use *. (134745=^R???)
30$:	BIT	#10,@#XRB+10		; any extension found?
	BNE	40$			; yes so use it
	MOV	#^RLST,@#FIRQB+FQEXT	; no so use .LST
40$:	MOV	TOS.R4(SP),@#FIRQB+FQPPN; load actual ppn (if any)
	BIT	#200,@#XRB+10		; was a ppn found?
	BNE	50$			; yes so use it
	MOV	JOBPTR(R5),R1		; get pointer to job packet
	ADD	#HD.LEN,R1		; and offset past the header
	MOV	JB.PPN(R1),@#FIRQB+FQPPN ; and load users ppn
50$:	MOVB	#LOKFQ,@#FIRQB+FQFUN	; load wildcard lookup function
	MOV	TOS.R0(SP),@#FIRQB+4		; load wildcard index number
	CALFIP				; and do the lookup
	TSTB	@#FIRQB			; any errors?
	BEQ	60$			; no, continue
	CMPB	#NOSUCH,@#FIRQB		; was error file not found?
	BNE	70$			; no was some unknown error
	CLR	R0			; clear wildcard ppn index flag
	CLR	TOS.R0(SP)		; clear wildcard file index
	INC	TOS.R1(SP)		; incr the wildcard ppn index
	BR	10$			; and start the next directory
	
60$:	INC	TOS.R0(SP)		; incr the wildcard file index
	CALL	SECRTY			; see if we have read access
	BCS	10$			; nope, so try for the next
	TST	(PC)+			; clear carry for happy return
70$:	SEC				; set carry for sad return
	RETURN				; and ...

	.DSABL	LSB

.SBTTL	DOFSS	- Execute FSS call on a given filespec

;+
;
; DOFSS:
;
; INPUTS:
;
;	R2 = length of file-spec
;	R3 -> file-spec
;
; RETURN
;
;	C=0 if FSS suceeded
;	C=1 if FSS failed
;
;-

	.ENABL	LSB

DOFSS:	CALLX	CLRFQX			; clear XRB and FIRQB
	MOV	#XRB,R1			; get pointer to XRB
	MOV	R2,(R1)			; now is length of file spec
	MOV	(R1)+,(R1)+		; also length of file spec
	MOV	R3,(R1)+		; pointer to file name
	.FSS				; do the .FSS
	FQBERR	10$			; set carry if error
	TST	@#XRB+XRBC		; did we translate the whole name?
	BNE	10$			; no, so error
	TST	(PC)+			; no error, clr carry
10$:	SEC				; error, set carry	
	RETURN				; and return

	GLOBAL	<NOSUCH>

	.DSABL	LSB

.SBTTL	SECRTY	- Determine read/write access to file

;+
;
; SECRTY:
;
;	This routine sets 3pp on the owner's priv mask and checks his
;	access to the current file spec.  KILLGL(R5) is set if the owner
;	has adequate privilege to delete the file.  Carry is cleared/set for 
;	read access.
;
; INPUTS:
;
;	R5 -> impure area
;	FIRQB+FQPPN	= file's PPN
;	FIRQB+20 	= file's protection code
;
; CALL:
;
;	JSR	PC,SECRTY
;
; BACK:
;
;	Firqb is preserved
;
;	C=0 if read access granted, C=1 if file can't be read
;
;	ALL REGS PRESERVED
;
;-

	.ENABL	LSB

SECRTY:	SAVREG
	MOV	#FIRQB,R0		; Save the
	MOV	R5,R1			;   current firqb
	ADD	#WILFQB,R1		;      for the lookup
	MOV	#FQBSIZ,R2		;          routine to use
	MOVSTR	R0,R1,R2		;              later on
	MOV	@#FIRQB+FQPPN,R3	;Save ppn
	MOVBYT	@#FIRQB+20,R4		; Save file's prot code
	MOV	JOBPTR(R5),R0		; R0 -> job packet
	MOV	JB.PPN+HD.LEN(R0),R1	; R1 =  PPN
	MOV	R0,R2			; get copy of job ptr
	ADD	#JB.PRV+HD.LEN,R2	; R2 -> priv mask
	SETPRV	R1,R2			; Set the owner's privs
	CALLX	CLRFQB			; clear the firqb
	MOVB	#UU.CHK,@#FIRQB+FQFUN	; Select check sub fun
;	CLRB	@#FIRQB+FQFIL		; file access check
	MOV	R3,@#FIRQB+FQPPN	; select ppn to check
	MOVB	R4,@#FIRQB+FQPROT	; with the protection code
	.UUO				; perform function
	MOVBYT	@#FIRQB+FQERNO,R2	; save erno flag bits (used below)
	CLR	R1			; Clear R1 for setprv call
	SETPRV	R1,R2			; restore our privileges
	MOV	R5,R0			; Restore the 
	ADD	#WILFQB,R0		;   firqb as it
	MOV	#FIRQB,R1		;      was passed to
	MOVSTR	R0,R1,#FQBSIZ		;          us
	MOV	SP,KILLGL(R5)		; Assume that kills are legal
	BIT	#BIT2,R2		; Does /OWNER have write access?
	BEQ	10$			; Yes, remember the fact
	CLR	KILLGL(R5)		; don't allow erase of this file
10$:	BIT	#BIT1,R2		; Does /OWNER have read access?
	BNE	20$			; No, so fail
	TST	(PC)+			; Yes, success
20$:	SEC
	RETURN

	.DSABL	LSB

.SBTTL	ERROR	- INSERT ERROR MESSAGE IN PRINT QUEUE

;+
;
; ERROR:
;
;
; INPUTS:
;
;		R5 -> IMPURE AREA
;		R0 -> FUNCION BITS TABLE
;
; CALL:
;	JSR	PC,ERROR
;
;
; BACK:
;
;		RMS ERROR TEXT PUT ONTO PRINT QUEUE
;			CALL PRINTER IF BUFFER SPACE LOW
;
;
;
;	ONLY RETURN IF SUCCESS
;	ON FAILURE STALL SPOOLER
;
;-

	.ENABL	LSB

10$:	MOV	REC(R5),R1	;GET POINTER TO BUFFER
	ADD	RECL(R5),R1	;POINT TO FREE SPOT IN BUFFER
	MOVB	CRLF,(R1)+	;FIRST THE <CR>
	MOVB	CRLF+1,(R1)+	;AND <LF>
	MOV	#64.,R2		;LEN OF SLPATER
20$:	MOVB	#'*,(R1)+	;LOAD IN THE STARS
	SOB	R2,20$
	ADD	#64.+2,RECL(R5)	;INC DATA IN BUFFER
	RETURN

ERROR:	TST	RECL(R5)	;ANYTHING IN BUFFER?
	BEQ	30$		;NOPE, SO WE CAN USE IT
	SETFUN	S.ERROR,R0	;YES, SET TO CALL US BACK
	CALLR	PRINTD		;BUT PRINT THE BUFFER FIRST

30$:	CALL	10$		;GO PRINT A BANNER
	PUSH	R0		;SAVE R0
	MOV	#1,R0		;SET SETFUN FOR RMSERR MESSAGE
	MOV	STS(R5),R1	;AND ERROR NUMBER
	MOV	STV(R5),R2	;AND STV
	MOV	R1,EOJSTS(R5)	;AND SAVE THE BAD ERROR FOR END OF JOB
	CALLX	GETTXT		;GET THE TEXT
	POP	R0
	MOV	REC(R5),R3	;GET POINTER TO BUFFER
	ADD	RECL(R5),R3	;POINT TO FREE SPOT IN BUFFER
	TST	R2		;ANY MESSAGE?
	BEQ	50$		;NO?, OH WELL
	MOVB	CRLF,(R3)+	;NOW THE <CR>
	MOVB	CRLF+1,(R3)+	;AND <LF>
	ADD	#2,RECL(R5)	;FIX THE COUNT
	ADD	R2,RECL(R5)	;UP THE COUNT AGAIN
40$:	MOVB	(R1)+,(R3)+	;COPY ERROR MESSAGE TO BUFFER
	SOB	R2,40$
50$:	CALL	10$		;NO THE FINAL BANNER
	MOVB	CRLF,(R1)+	;AND TRAILING <CR>
	MOVB	CRLF+1,(R1)+	;AND <LF>
	ADD	#2,RECL(R5)
	CALL	SAVOPT		;SAVE CURRENT FILE OPTIONS
	BIS	#LPTNOX!LPTHDR,DDFLAG(R5) ;AND FORCE /TRUNCATE ON HEADERS
	CALLR	PRINTD		;PRINT DATA FROM BUFFER

	.ASSUME	64.+2+64.+2+64.+2+2 LE 512. ;MAKE SURE IT FITS IN BUFFER

	.DSABL	LSB

.SBTTL	PRINTB	- PRINT A LINE TO OUTPUT DEVICE
.SBTTL	PRINT	- PRINT A LINE + CRLF TO OUTPUT DEVICE
.SBTTL	PRINTC	- PRINT A CRLF ON ANYTHING THAT'S IN THE BUFFER
.SBTTL	PRINTD	- PRINT BUFFER TO OUTPUT DEVICE

;+
;
; PRINTB:
;
;	Line printing routine (no extra crlf's anywhere)
;
; PRINT:
;
;	Line printing routine with automatic trailing crlf
;
; PPRINT:
;
;	Line printing routine with automatic leading and trailing crlf
;
;	R3 -> Data (but not in buffer!!!!)
;	R4 =  LEN
;
; PRINTC:
;
;	Print a CRLF after what is already in the buffer.
;
; PRINTD:
;
;	Print contents of buffer
;
; INPUTS:
;                                    (common to all routines)
;	R0 =  function bits
;	R5 =  impure area
;
;-

	.ENABL	LSB

PRINTD:	MOV	REC(R5),R3		;R3 points to data
	MOV	RECL(R5),R4		;R4 is the length
	BR	10$			;join common print

PRINTC:	MOV	RECL(R5),R2		;get length of buffer
	ADD	REC(R5),R2		;get to current position in buffer
	BR	50$			;print it and return

PPRINT:	BIS	#BIT15,R4		;set sign bit of length for leding crlf
PRINT:	BIS	#BIT14,R4		;set next bit for trailing crlf
PRINTB:	CLR	RECL(R5)		;start at begining of buffer
10$:	MOV	REC(R5),R2		;get pointer to target record
	CMP	R2,R3			;is record already in buffer?
	BEQ	60$			;yes, so all done
	BIT	#BIT15,R4		;do we want a leading crlf?
	BEQ	20$			;no
	CALL	50$			;yes so go do it
20$:	PUSH	R4			;save dirty R4
	BIC	#BIT15!BIT14,R4		;clean the length
	BEQ	40$			;get out if zero length record
	ADD	R4,RECL(R5)		;and it's new length
30$:	MOVB	(R3)+,(R2)+		;move data into buffer
	SOB	R4,30$			;till done
40$:	POP	R4			;restore dirty R4
	BIT	#BIT14,R4		;do we want a trailing crlf?
	BEQ	60$			;no so just exit
50$:	MOVB	CRLF,(R2)+		;add on the crlf
	MOVB	CRLF+1,(R2)+		;add on the crlf
	ADD	#2,RECL(R5)		;update the length
60$:	SETFUN	S.CVT,R0		;call the character converter
70$:	RETURN

	.DSABL	LSB
	GLOBAL	<CRLF>

.SBTTL	MOVCVT	- MOVE AND CONVERT TEXT FROM INPUT BUFFER TO OUTPUT BUFFER

	.ENABL	LSB

MOVCVT:	CALL	CHRHND			;CONVERT AND MOVE THE CHARACTERS
	TST	RECL(R5)		;all chars converted?		;034
	BGT	10$			;no, so leave pointer alone	;034
	MOV	REC(R5),RECPTR(R5)	;yes, reset record pointer	;034
10$:	RETURN

	.DSABL	LSB

.SBTTL	RSTBLD	- BUILD RESTART TABLE

;+
;
; RSTBLD:
;
; NOTE THAT THE FIRST ENTRY ALWAYS HAS THE RFA/ADDR OF THE FIRST RECORD
;
; INPUTS:
;
;
; CALL:
;
;	JSR	PC,RSTBLD
;
; BACK:
;
;
;-

	.ENABL	LSB

RSTBLD:	TST	RSTPTR(R5)		;DOES TABLE WANT TO BE ZONKED?
	BNE	20$			;NO
	MOV	#1,RSTINT(R5)		;RE-SET THE RESTART TABLE INTERVAL
	MOV	#RSTBEG,R1		;GET BASE OF ALL RESTART TABLE
	ADD	R5,R1			;PLUS ADDR OF IMPURE AREA
	MOV	R1,RSTPTR(R5)		;POINT CURRENT AT THE BEGINING
	PUSH	R1
	MOV	#<RSTEND-RSTBEG>/2,R2	;GET LENGTH OF TABLES IN WORDS
10$:	CLR	(R1)+			;ZONK THE TABLE
	SOB	R2,10$
	POP	R1			;POINTS TO START OF TABLE
	BR	50$			;AND GO BUILD THE FIRST ENTRY

20$:	MOV	RSTPTR(R5),R1		;GET CURRENT POINTER
	MOV	DDPAG0(R5),R2		;STASH LOW BITS OF ACTUALL
	SUB	RPAG0(R1),R2		; - LAST SAVED
	BEQ	60$			;SAME SO DON'T UPDATE
	CMP	RSTINT(R5),R2		;DO THEY DIFFER BY THE INTERVAL?
	BHI	60$			;NO, SO DON'T CHANGE ANYTHING
30$:	MOV	#RSTEND-RSIZ,R2		;YES,GET ADDR OF LAST IN TABLE
	ADD	R5,R2			;PLUS ADDR OF IMPURE
	CMP	R1,R2			;CURRENT THE LAST IN TABLE?
	BNE	40$			;NO, SO CONTINUE
	MOV	#RSTBEG,R1		;YES, POINT TO FIRST ENTRY
	ADD	R5,R1			;PLUS ADDR OF IMPURE
	ADD	#RSTENT,RSTINT(R5)	;AND BUMP THE RESTART INTERVAL
40$:	ADD	#RSIZ,R1		;POINT TO NEXT FREE ENTRY
50$:	MOV	R1,RSTPTR(R5)		;SAVE THE 'CURRENT' POINTER
	MOV	RAB(R5),R2		;GET THE RAB POINTER
	BEQ	60$			;NO RAB, DON'T STORE THE DATA
	MOV	DDPAG0(R5),RPAG0(R1) 	;STORE CURRENT PAGE COUNTER
	MOV	DDPAG1(R5),RPAG1(R1) 	;STORE CURRENT PAGE COUNTER
	MOV	DDVERT(R5),RLIN(R1)	;Update the current line count	;069
	MOV	DDHORZ(R5),RPOS(R1)	;And position within that line	;069
	MOV	O$RFA(R2),RRFA(R1) 	;STORE THE LATEST RFA
	MOV	O$RFA+2(R2),RRFA+2(R1) 	;STORE THE LATEST RFA
	MOV	O$RFA+4(R2),RRFA+4(R1) 	;STORE THE LATEST RFA
60$:	RETURN

	.DSABL	LSB

.SBTTL	LPTBITS	- DEFINE BITS IN LP DDFLAG AND DDCHAR

;+
;
;  Don't panic:	DDFLAG and DDCHAR are only PBS internal.
;		They are NOT part of the monitor DDB.
;
;-

	.SAVE

.BSECT	,CREF		;in ddflag

LPTRES:	.BLKB	.	;don't count pages in total (in restart)
LPTHDR:	.BLKB	.	;output even if in restart this is a header
LPTCH0:	.BLKB	.	;change "0" into "O"	/CONVERT
LPTNOX:	.BLKB	.	;truncate long lines	/TRUNCATE
LPTOVF:	.BLKB	.	;skip over perforations	/FEED
LPTAVT:	.BLKB	.	;allow <VT>
LPTRAP:	.BLKB	.	;wrap long lines	/WRAP			;069
;
; Define bits for DDCHAR word ( equivalent to LPTCHR in LPDVR )
;
;	Comments and symbols from "LPDVR.MAC".  All rights preserved.
;

	.BSECT	,CREF

LPTRBS:	.BLKB	.	; allow <BS> for backspace (la180)
LPTNBS:	.BLKB	.	; don't process <BS> as backspace
LPT8BT: .BLKB	.	; allow 8-bit characters (ln01)
LPTNPC:	.BLKB	.	; allow non-printing characters
LPTSFF:	.BLKB	.	; no fill for <FF>
LPTEOT:	.BLKB	.	; allow <EOT>
LPTCRF:	.BLKB	.	; no <CR> required before <LF>,<VT>,<FF> (lp11)
LPTSCR:	.BLKB	.	; ignore <CR> if next is <LF> (lp11)
LPTTAB:	.BLKB	.	; No <TAB> expand (LN01)
LPTHFF:	.BLKB	.	; hardware <FF> supported ( not in LPDVR )
LPTCUP:	.BLKB	.	; pre-fix control chars with up-arrow (not in LPDVR )
LPTALC:	.BLKB	.	; Allow lower case (LPTALC)
LPTSCP: .BLKB   .       ; KB is a scope					;058

	.RESTORE

.SBTTL	LPTDSP	- CHARACTER DISPATCH TABLE AND MACRO

;+
; LPTDSP
;
; THIS MACRO INSERTS INTO THE CHARATER DISPATCH TABLE THE
; (WORD OFFSET)/2 FROM THE DISPATCHER TO THE CURRENT ADDRES STARTING AT 
; 'CHAR' AND CONTINUEING THROUGH 'LAST'.
;-

  	.SAVE
	.PSECT	LPDVR,RO,CON

LPDVR:	.BLKB0	400		;RESERVE THE DISPATCH TABLE SPACE

.MACRO	LPTDSP	CHAR,LAST
$$$$$$	=	.-LPTDSP/2
$$$$$0	=	$$$$$$
.IIF	LT	$$$$$0,	$$$$$0=^C<$$$$$0>
.ASSUME	$$$$$0&177600 EQ 0
$$$$$0	=	.
.	=	CHAR+LPDVR
	 .BYTE	$$$$$$
.IF	NB	<LAST>
.IF	NE	LAST-CHAR-1
.REPT	LAST-CHAR-1
.NLIST
	.BYTE	$$$$$$
.LIST
.ENDR
.LIST
	 ;	...
.NLIST
.ENDC
	 .BYTE	$$$$$$
.ENDC
.	=	$$$$$0
.ENDM	LPTDSP

.SBTTL	CHRHND	- CHARACTER HANDLER

;+
;
; CHRHND:
;
;
; INPUTS:
;		R0 -> FUNCTION BITS TABLE
;		R5 -> IMPURE AREA
;			RECPTR(R5)   -> RECORD
;			RECL(R5)    = LENGTH OF RECORD
;			OUTPTR(R5) -> OUTPUT BUFFER
;			FREE(R5)    = AMOUNT OF FREE SPACE IN BUFFER
;
; CALL:
;	JSR	PC,CHRHND
;
;
; BACK:
;		RECPTR,RECL,OUTPTR,FREE ADJUSTED AS NECESSARY
;		ALL REGISTERS PRESERVED
;
;	C=0 FOR SUCCESS
;	C=1 IF INTERNAL FAILURE OR ERROR
;
;-

.ENABL	LSB

CHRHND:	BIT	#PD$IMM,DDPAUS(R5) ;is pause immediate bit set?
	BNE	20$		;yes, so write current buffer to device	;034
	TST	FREE(R5)	;any room left in output buffer?	;064
	BGT	40$		;plenty, so continue to fill it up	;064
	BEQ	10$		;buffer full, empty it out		;064
	MOV	#ER$BUG,R1	;negative free space, bad news
	MOV	FREE(R5),R2	;show bad free count
	CRASH			;and crash

10$:	SETFUN	S.CVT,R0	;ask for us again
20$:	SETFUN	S.PUT,R0	;ask for the PUT routine
30$:	CLC			;clear carry
	RETURN			;exit

40$:	TST	DDNULL(R5)	;In the middle of performing a FILL?	;063
	BNE	55$		;Yes.  So finish it			;063
	TST	RECL(R5)	;any more data to transfer?
	BEQ	30$		;no, so return success
	MOVBYT	@RECPTR(R5),R2	;yes, get next char from input buffer
	INC	RECPTR(R5)	;count as fetched
	DEC	RECL(R5)	; and used
	BIT	JOBSTA(R5),#J.ESC ;Control sequence in progress?
	BEQ	50$		;No, treat the character in normal fashion
	CALL	CNTRLS		;Yes, monitor the sequence's progress
	BR	CHRHND		;and back for some more
                                
50$:	CALL	LPTSRT		;call the character formatter
	BR	CHRHND		;and on to next character

55$:	CALL	FILLCR		;resume the FILL operation		;063
	BR	CHRHND		;now on to the next character		;063

.SBTTL	MAIN LINE PRINTER CHARACTER CODE

LPTDSP	200,237			;process non-speical C1 control chars
	BIT	DDCHAR(R5),#LPTNPC	; Allowing non printing control chars?
	BEQ	60$			;no, process further
	JMP	LPTSTO			;Yes, print it

60$:	BIT	DDCHAR(R5),#LPTCUP	;Shall we print the '$' equivalent?
	BEQ	110$			;No, drop the character on the floor
	SUB	#64.,R2			;Yes, get the ascii rep of string
	CALL	UNGET			;save the rep
	MOVB	#'$,R2			;and print the '$'
	BR	75$			;via intermediate branch

LPTDSP	000,037				;process non-special C0 ctrl chars ;069
70$:	BIT	DDCHAR(R5),#LPTCUP 	;use uparrow style controls?
	BEQ	100$			;no, see if controls allowed
	BIS	#100,R2			;yes, make the control printable
	BIC	#^C<177>,R2		;make into 7-bit char if 8-bit
	CALL	UNGET			;save character temporarily
	MOV	#'^,R2			;now set the prefix uparrow
75$:	JMP	LPTBUF			; and go buffer it		;058

LPTDSP	033			;process <ESCAPE>    special C0 code
LPTDSP	220			;process <DCS>       special C1 codes
LPTDSP	233,237			;process <CSI>, <ST>, <OSC>, <PM>, <APC>
	JMP	CONTRL			;Goto control section

LPTDSP	013			;process <VT>
;058	BIT	DDFLAG(R5),#LPTAVT	;allow <VT>?
;058	BEQ	70$			;no, process as control char
	CALL	CHKCR			;yes, do we need <CR> first?
	BCC	78$			;no, just send char 		;058
	CALL	UNGET			;yes, save char temporarily
	CALLR	LPTCRO			;and send <CR>

78$:	CALL	LPTRST			;send char and come back	;058
	BIT	#LPTSCP,DDCHAR(R5)	; is it a scope?		;058
	BNE	79$			; Yes				;058
	MOV	DDFILL(R5),DDNULL(R5)	; No - move CR count		;058
  	BEQ	79$			; if zero end			;058
	ASL	DDNULL(R5)		; *2				;058
	ASL	DDNULL(R5)		; *4				;058
	ADD	DDFILL(R5),DDNULL(R5)	; *5				;058
	CALLR	FILLCR			; And go fill			;058
79$:	RETURN								;058

LPTDSP	004			;process <EOT>
	BIT	DDCHAR(R5),#LPTEOT	;allow <EOT>?
	BEQ	70$			;no, so treat as control char
	JMP	LPTRST			;yes, reset tof and send the character

LPTDSP	014			;process <FF>
FORMF:	MOV	#14,R2			;Ensure char is <FF>		;068
	BIS	#J.SFF,JOBSTA(R5)	;Signal we're processing a <FF>	;069
	CALL	CHKCR			;do we need <CR> first?
	BCC	90$			;no, just send char
	CALL	UNGET			;otherwise save char 
	CALL	LPTCRO			;and send <CR>
85$:	BIC	#J.SFF,JOBSTA(R5)	;Turn off <FF> flag		;069
	RETURN				;Come back later		;069

90$:	CALL	GETTOF			;try to get top of form		;064
	CMP	DDVERT(R5),DDVERC(R5)	;top of form yet?		;069
	BEQ	85$			;yes, turn of flag and exit	;069
	TST	FREE(R5)		;More room in output buffer?	;066
	BNE	90$			;Yes, keep looping.		;066
	MOV	#14,R2			;No, get the <FF> back		;066
	CALL	UNGET			;Save it for after the flush	;069
	BR	85$			;Come back later		;069

LPTDSP	000			;process <NULL>
LPTDSP	177			;process <DEL>
100$:	BIT	DDCHAR(R5),#LPTNPC	;should we output controls?
	BNE	LPTSTO			;yes
	BIT	JOBSTA(R5),#J.ESC	;Are we processing an escape?	;072
	BNE	LPTSTO			;Yes. Better send the character	;072
110$:	RETURN				;No. Ignore character

LPTDSP	060			;process <0>
	BIT	DDFLAG(R5),#LPTCH0	;convert 0-char into O-char?
	BEQ	LPTBUF			;nope, so just send it
	BIT	JOBSTA(R5),#J.ESC	;Are we in an escape sequence?
	BNE	LPTBUF			;Yes, don't convert
	MOV	#'O,R2			;no, so make into "O"
	BR	LPTBUF			; and send it

LPTSRT:	MOVB	LPDVR(R2),R4		;get entry from the dispatch table
	ASL	R4			; double it
	ADD	R4,PC			;  and dispatch on it...

LPTDSP:					;reference only ( dispatch reference )
	MOV	#ER$BUG,R1		;Uh oh!  We missed a char	;069
	CRASH				;Character we missed is in R2	;069

LPTDSP	010			;process <BS>				;036
	BIT	#LPTNBS,DDCHAR(R5)	;Are backspaces allowed for this dev?
	BNE	70$			;No, treat as none printable character
	BIT	#J.SBS,JOBSTA(R5)	;Are we in the middle of positioning?
	BNE	120$			;Yes, do not reinitialize counter
	TST	DDHORZ(R5)		;Already at the left margin?	;069
   	BEQ	140$			;Yes, ignore the character	;069
	DEC	DDHORZ(R5)		;correct the horizontal position;036
	CMP	DDHORZ(R5),DDHORC(R5)	;Were we past the right margin?	;071
	BLO	115$			;Nope.  We can send this char	;071
	BIT	#LPTNOX,DDFLAG(R5)	;Were we truncating?		;071
	BNE	140$			;Yes.  Well then this is easy	;071
	.BR	115$			;Else, /NOWRAP.  Send the char	;071
115$:	BIT	#LPTRBS,DDCHAR(R5)	;Does the dev understand a 'REAL' <BS>?
	BNE	LPTSTO			;Yes, output it			;067
	MOV	DDHORZ(R5),DDBSPO(R5)	;No, set horizontal pos to space to
	BEQ	LPTCRO			;<BS> at column 1 same as <CR>	;069
	BIS	#J.SBS,JOBSTA(R5)	;Show that we are simiulating a <BS>
	CALL	LPTCRO			;restore horizontal position	;036
120$:	TST	FREE(R5)		;any room in output buffer?	;036
	BNE	130$			;yes, send next space char	;036
	MOV	#10,R2			;no, load <BS> char		;036
	CALLR	UNGET			;and put the <BS> char back	;036

130$:	CALL	LPTSPO			;call the space outputter	;036
	CMP	DDHORZ(R5),DDBSPO(R5)	;Are we at the correct position?;036
	BLO	120$			;No, send another space		;069
	BIC	#J.SBS,JOBSTA(R5)	;show that we're no longer simulating
140$:	RETURN								;036

LPTDSP	011			;process horizontal <TAB>		;071
	BR	LPTHTO			;Can't get there from here	;071

LPTDSP	377			;process <377>				;072
LPTDSP	340,376			;process lower case multi-nationals	;063
LPTDSP	140,176			;process lower case graphics
	BIT	DDCHAR(R5),#LPTALC	;upper case only?
	BNE	LPTBUF			;no, go send it
	BIC	#40,R2			;yes, force to upper case
	.BR	LPTBUF			; then send it			;069

LPTDSP	240,337			;process Upper case Multinationals	;063
LPTDSP	040,137			;process upper case graphics

LPTBUF:	BIS	#J.DRTY,JOBSTA(R5)	;Say the page is dirty		;073
	.BR	LPTBF2			;And continue			;073

LPTDSP	040			;Process <space> (Doesn't dirty a page)	;073
LPTBF2:	INC	DDHORZ(R5)		;Increment CCPOS		;073
	BEQ	170$			;Huh???  The counter wrapped!	;069
150$:	CMP	DDHORZ(R5),DDHORC(R5)	;Does char fit on the line?	;069
    	BHI	180$			;No.  Check for truncate/wrap	;069
	CMP	DDVERT(R5),DDBOM(R5) 	;bottom margin exceeded?	;069
	BHI	LPTSTO			;no, store the character	;069
	BIT	DDFLAG(R5),#LPTOVF	;yes, skipping over perfs?	;069
	BEQ	LPTSTO			;no, store the character	;069
	CLR	DDHORZ(R5)		;Reset CCPOS			;069
	BIT	#J.STAB,JOBSTA(R5)	;Are we simulating a <TAB>?	;069
	BEQ	155$			;No, put back the char as is	;069
	MOV	#9.,R2			;Yes, then put the <TAB> back	;069
155$:	CALL	UNGET			;Save the character for later	;069
	CALLR	FORMF			;Go to top of next page first	;069

LPTSTO:	BIT	DDFLAG(R5),#LPTRES 	;are we in a restart?
	BEQ	160$			;no, so continue
	BIT	DDFLAG(R5),#LPTHDR	;but is this a header?
	BEQ	RESCHK			;no, so see what to do about it	;069
160$:	MOVB	R2,@OUTPTR(R5)		;yes, now store the character
	INC	OUTPTR(R5)		;and up the pointer
	DEC	FREE(R5)		;and show one less byte in the well
	RETURN				;exit

170$:	DEC	DDHORZ(R5)		;Ensure further characters wrap	;069
					;NOTE: <BS> and <TAB> don't work
					;	too well past this point
180$:	BIT	DDFLAG(R5),#LPTNOX	;truncate on line overflow?
	BNE	190$			;Yes, so we want to skip char	;069
	BIT	DDFLAG(R5),#LPTRAP	;No, so we need to check wrap	;069
	BEQ	LPTSTO			;/NOWRAP, just send the char	;070
	CALL	UNGET			;Save overflow char for later	;069
	.BR	LPTLFC			;skip to <LF> code		;068

LPTDSP	012			;process <LF>
LPTLFC:	MOV	#12,R2			;Ensure character is <LF>	;068
	CALL	CHKCR			;do we need <CR> first?
	BCC	LPTLFO			;no, just send char 
	CALL	UNGET			;otherwise save char 
	.CALLR	LPTCRO			;and send <CR>			;068

LPTDSP	015			;process <CR>
LPTCRO:	MOV	#15,R2			;set character to <CR>
	MOV	DDFILL(R5),DDNULL(R5)	;get <nul>'s to print		;058
	CALL	FFCHK			;load <CR> and return here	;063
	TST	DDNULL(R5)		;Did <CR> or <FF> get buffered?	;069
	BNE	FILLCR			;<CR>, go do the fill		;069
;	BEQ	190$			;<FF>, come back later for <CR>	;069
					;(Or <CR> and there is no fill)	;069
190$:	RETURN				;All done			;069

LPTHTO:	BIT	#LPTTAB,DDCHAR(R5)	;are we sending real tabs?	;071
	BEQ	200$			;no, simulate them		;038
	ADD	#8.,DDHORZ(R5)		;assume tabs at intervals of 8	;069
	BIC	#7,DDHORZ(R5)		;Aren't powers of 2 neat?	;069
	BEQ	170$			;Whoa! The word counter wrapped	;069
	BR	150$			;Check for a line overflow	;069

200$:	BIS	#J.STAB,JOBSTA(R5)	;Signal that we're simulating	;069
	CALL	LPTSPO			;Output a space			;069
	BIT	#7,DDHORZ(R5)		;Are we at the next tab stop?	;069
					;(Again, aren't powers of 2 neat?)
	BEQ	210$			;Hit the tab stop.  Get out now	;069
	TST	FREE(R5)		;More room in buffer?		;069
	BNE	200$			;Plenty.  Keep simulating	;069
	MOV	#9.,R2			;set character to <TAB>		;069
	CALL	UNGET			;and put it back in the buffer	;069
210$:	BIC	#J.STAB,JOBSTA(R5)	;No longer simulating		;069
	RETURN

LPTSPO:	MOV	#40,R2			;set character to <SPACE>
	BR	LPTBF2			;Don't dirty the page		;073

FILLCR:				; print extra fill characters		;069
	TST	FREE(R5)		;Any room in output buffer?	;058
	BEQ	190$			;no, come back later		;068
	CLR	R2			;set character to <NUL>		;063
	CALL	LPTSTO			;and send it out		;058
	DEC	DDNULL(R5)		;more to send?			;063
	BNE	FILLCR			;yep, go send 'em		;069
	RETURN				;Nope.  We're done		;069

RESCHK:	CMP	DDPAG1(R5),RESPG1(R5)	; have we passed the target yet? ;069
	BHI	220$			; yes, so re-enable output	;069
	BLO	230$			; no, continue with the restart	;069
	CMP	DDPAG0(R5),RESPG0(R5)	; how about the low word of count?
	BLO	230$			; no, continue with the restart	;069
220$:	BIC	#LPTRES,DDFLAG(R5)	; yes, clrfun the restart..	;069
	CMPB	#CR$SP,R2		; Is this delimiter/control char ;054
	BLOS	160$			; Nope, should print it
					; <Ignore 8 bit controls>
230$:	RETURN				; Done for now			;069

LPTLFO:	MOV	#12,R2			;set to output a <LF>
	DECB	DDVERT(R5)		;decr form length counter
	BEQ	LPTRST			;new page, reset vertical pos	;069
	BIS	#J.DRTY,JOBSTA(R5)	;Page is now dirty		;073
FFCHK:	BIT	#J.SFF,JOBSTA(R5)	;Already expanding a <FF>?	;069
	BNE	LPTRHZ			;Yes.  OK to send the character	;069
	CMP	DDVERT(R5),DDBOM(R5) 	;bottom margin exceeded?	;069
	BHI	LPTRHZ			;no, reset horizontal pos	;069
	BNE	240$			;yes, go see if we should skip	;069
	CMPB	R2,#15			;Is this a <CR> or <LF>?	;069
	BNE	LPTRHZ			;<LF> allowed here, <CR> isn't	;069
240$:	BIT	DDFLAG(R5),#LPTOVF	;skipping over perfs?		;069
	BEQ	LPTRHZ			;no, reset horizontal pos	;069
	CMPB	R2,#15			;No, is this a <CR>?		;069
	BEQ	245$			;Yes, vertical position is OK	;069
	INC	DDVERT(R5)		;No, don't count <LF> character	;069
245$:	CALL	UNGET			;'Cause we'll output it later	;069
	CALLR	FORMF			; Go output a <FF>		;068

LPTRST:	MOV	DDVERC(R5),DDVERT(R5)	;reset counter to top of form	;069
	BIC	#J.DRTY,JOBSTA(R5)	;Mark the new page as clean	;073
	BIT	DDFLAG(R5),#LPTHDR	;is this a header page?		;021
	BNE	260$			;yes, not part of job/file totals ;021
	BIT	DDFLAG(R5),#LPTRES	;are we restarting?		;021
	BNE	250$			;yes, don't count in job total	;021
	ADD	#1,DDPGT0(R5)		;incr job total pages (lsb)	;021
	ADC	DDPGT1(R5)		; and job total pages (msb)	;021
250$:	ADD	#1,DDPAG0(R5)		;incr file total pages (lsb)	;021
	ADC	DDPAG1(R5)		; and file total pages (msb)	;021
260$:	BIT	#PD$EOP,DDPAUS(R5)	;request pause at end of page?	;020
	BEQ	270$			;no, so continue		;020
	BIS	#PD$IMM,DDPAUS(R5)	;yes, set pause immediate bit	;034
	SETFUN	S.CVT,R0		;move and convert when we come back
	SETFUN	S.PAU,R0		;yes, ask for us to pause	;020
	SETFUN	S.EMTY,R0		;and empty the output buffers	;034
270$:	CALL	CHKLIM			;check for exceed page limit	;021

LPTRHZ:	CLR	DDHORZ(R5)		;reset horizontal line position	;069
	CALLR	LPTSTO			;now store the character

;
; UTILITY ROUTINES FOR LINE PRINTER CODE
;

CHKCR:	BIT	DDCHAR(R5),#LPTCRF	;<CR> before <LF>,<VT>,<FF>?
	BNE	CRNO			; no
	TST	DDHORZ(R5)		;is carriage already restored?	;069
	BNE	CRYES			; no
CRNO:	TST	(PC)+			;no need to restore carriage
CRYES:	SEC				;must restore carriage
	RETURN

GETTOF:	BIT	DDCHAR(R5),#LPTHFF	;any hardware <FF> support?
	BEQ	LPTLFO			;no, so line feed it out...	;058
	CALL	LPTRST			;yes, so do it quickly		;058
	BIT	#LPTSFF,DDCHAR(R5)	; ff fill?			;058    
	BNE	300$			;no - see if cr fill		;059
	MOV	#15,R2			;Have to do this bass-ackwards	;064
	CALL	UNGET			;First buffer a <CR>		;064
	BIT	JOBSTA(R5),#J.ESC	;Are we processing an ESCape?	;072
	BNE	280$			;Yes. Better not send a space	;072
	MOV	#40,R2			;Still in bass-ackwards mode	;064
280$:	.CALLR	UNGET			;Buffer a space and then return	;064

UNGET:	DEC	RECPTR(R5)		;point to previous character	;019
	INC	RECL(R5)		;show one more char in buffer	;019
	MOVB	R2,@RECPTR(R5)		;put possibly converted char back ;019
290$:	RETURN				;and exit			;069

300$:	MOV	DDFILL(R5),DDNULL(R5)	; yes - move CR count		;058    
	BEQ	290$			; no fill - so out		;069
	ASL	DDNULL(R5)		; *2				;058
	ASL	DDNULL(R5)		; *4				;058
	ASL	DDNULL(R5)		; *8				;058
	ADD	DDFILL(R5),DDNULL(R5)	; *9				;058
	JMP	FILLCR			; Go do the fill		;069

.DSABL	LSB

.SBTTL	CHKLIM	- CHECK FOR PAGE LIMIT EXCEEDED

;+
;
; CHKLIM:
;
;	Check the page limit of the currently processing job.
;
; INPUTS:
;
;	R0 -> Function bits
;	R5 -> Impure area
;
; CALL:
;
;	JSR	PC,CHKLIM
;
; RETURN:
;
;		C=1 if page limit exceeded
;		C=0 if page limit not exceeded
;		All registers preserved
;
;-

	.ENABL	LSB

CHKLIM:	CMP	DDPGT1(R5),PGLIM1(R5)	;total page MSB over limit?
	BHI	20$			;yes, so skip to exceed limit handler
	BLO	10$			;no, so exit happy
	CMP	DDPGT0(R5),PGLIM0(R5) 	;total pages lsb over limit?
	BHI	20$			;yes, so skip to exceed limit handler
10$:	CLC				;clear carry for no exceed limit
	BR	30$			;and exit

20$:	BIT	JOBSTA(R5),#J.PLE	;Have we already sent a message?
	BNE	30$			;yes, no need to test limits
	CLR	RECL(R5)		;Trash rest of input
	MOV	REC(R5),RECPTR(R5)	;  and set pointer to begining
	CALL	ABTERR			;call abort/display error routine
	MOV	#ER$INI,STS(R5)		;and load RMS error for exceed limit
	BIS	#J.PLE,JOBSTA(R5)	;Allow the error message to be printed.
	CLRFUN	S.CVT,R0		;cancell movcvt
	SEC				;set carry for exceed limit

30$:	RETURN				;exit

	.DSABL	LSB

.SBTTL	CONTRL	- Beginning of control sequence detected

;+
;
; CONTRL:
;
;	This routine is called to recognize the start of a control sequence.
;	We will recognize <ESC>, <DCS>, <CSI>, <ST>, <OSC>, <PM>, <APC>.  All
;	other control characters are assumed to be single character control
;	characters.  This routine will only be called if /CONTROLS is
;	specified for the server.
;
; INPUTS:
;
;	R2 = control character
;	R5 -> impure area
;
; CALL:
;
;	JMP	CONTRL
;
; BACK:
;
;	ALL REGS PRESERVED
;
;-

	.ENABL	LSB

CONTRL:	PUSH	<R0,R1>
	CLR	R0			;clear counting register
	MOV	#CTLIDT,R1		;R1 -> control ident table
10$:	TSTB	(R1)			;Are we at the end of the table?
	BEQ	80$			;yes, we should have never get here
	CMPB	R2,(R1)+		;Is this the control?
	BEQ	20$			;Yes, set parsing chain
	INC	R0			;No, bump counter
	BR	10$			;and try next one

20$:	BIT	DDCHAR(R5),#LPTCUP	;Convert control to readable format?
	BEQ	40$			;No, just process the char
	TST	R0			;Was the char an escape?
	BEQ	30$			;Yes, simple translation
	SUB	#64.,R2			;No, translate to 7-bit
	CALL	UNGET			;store the translated character
	CLR	R0			;Set table offset to escape
30$:	MOVB	#'$,R2			;Set char to the $ sign
	BR	60$			;and continue the process

40$:	TST	R0			;Was the char an escape?
	BEQ	60$			;Yes, same in both 7 and 8 bit
	BIT	DDCHAR(R5),#LPT8BT	;Does our device know 7 bits?
	BNE	50$			;Yes, no problem
	SUB	#64.,R2			;no, get second part of introducer
	CALL	UNGET			;and make it next for output
	MOV	#33,R2			;Set current character to escape
	CLR	R0			;correct the table offset
50$:	ASL	R0			;make counter*2 for word offset
60$:	MOV	CTLTYP(R0),CTLSTA(R5)	;control state set to initial state
	BEQ	70$			;write character if no state reqed <ST>
	BIS	#J.ESC,JOBSTA(R5)	;show that we are in control sequence
70$:	POP	<R1,R0>
	CALLR	CNTRLW			;write the control character out

80$:	POP	<R1,R0>			;failure exit
	RETURN

	.DSABL	LSB

.SBTTL	CNTRLS	- Scan control sequence for validity

;+
;
; CNTRLS:
;
;	This routine processes characters in a control sequence.  If the
;	character is unexpected, we put it back in the buffer and process
;	it as a normal text character.
;
;	Uses state transition table ( linked list ) as defined in the following
;	pages.
;
;	The string terminator character is treated special here.  If the device
;	does not understand eight bits, it is translated to '<ESC>\'.  It is
;	translated here since this is normally the only routine that will 
;	receive the character.
;
; INPUTS:
;
;	R2 = the next control sequence character
;	R5 -> Impure area
;
;	( R0 must be preserved, function bit table pointer )
;
; CALL:
;
;	JSR	PC,CNTRLS
;
; BACK:
;
;	R1 IS TRASHED
;
;-

	.ENABL	LSB

CNTRLS:	CMPB	#234,R2			;Is this the <ST> character?
	BNE	20$			;No, don't worry about it
	BIT	#LPTCUP,DDCHAR(R5)	;Are we displaying the <ST>s?
	BNE	10$			;Yes, set up to do so
	BIT	#LPT8BT,DDCHAR(R5)	;Is the device 8 bit?
	BNE	20$			;Yes, no problem
10$:	SUB	#64.,R2			;No, translate to 7-bit
	CALL	UNGET			;store the second character
	MOV	#33,R2			;and set current character to escape
20$:	MOV	CTLSTA(R5),R1		;Fetch the current state
30$:	CMPB	R2,STA.LOW(R1)		;Is char less than low range?
	BLO	50$			;Yes, try next entry
	CMPB	R2,STA.HIGH(R1)		;Is char higher than high range?
	BHI	50$			;Yes, try next entry
	CMP	STA.NXT(R1),#-1		;Are we changing states?	;072
	BEQ	CTRLWC			;No. Go process control char	;072
	MOV	STA.NXT(R1),CTLSTA(R5)	;Char in entry's range, set next state
	BNE	40$			;continue control sequence processing
	BIC	#J.ESC,JOBSTA(R5)	;done processing if no next state
40$:	CALLR	CNTRLW			;store the control sequence character

50$:	MOV	STA.LNK(R1),R1		;Get the next entry
	BNE	30$			;Process if there is one
	BIC	#J.ESC,JOBSTA(R5)	;Whoops, invalid control sequence
	CALLR	UNGET			;return the character

	.DSABL	LSB

.SBTTL	CNTRLW	- Control sequence writer

;+
;
; CNTRLW:
;
;	This routine will buffer a control sequence character.  If 
;	CONTROLS=UP_ARROW is in effect, we assume the character to 
;	already be translated to a printable form.  If NOCONTROLS is
;	set, we trash the character.  If CONTROLS are in effect, we
;	ship the character as we get it.
;
; INPUTS:
;
;	R2 = the character to write
;	R5 -> Impure area
;
; CALL:
;
;	JSR	PC,CNTRLW
;
; BACK:
;
;	ALL REGS PRESERVED
;
;-

	.ENABL	LSB

CNTRLW:	BIT	DDCHAR(R5),#LPTNPC	;Does the device want controls?
	BEQ	10$			;No, it wants something else
	CALLR	LPTSTO			;Yes, pass the control sequence

10$:	BIT	DDCHAR(R5),#LPTCUP	;Does the device want controls disped?
	BEQ	20$			;Nope, trash the character
CTRLWC:	CALLR	LPTSRT			;Yes, dispatch on character	;072

20$:	RETURN				;Trash-ola ( very gutsy move )

	.DSABL	LSB
	.RESTORE

.SBTTL	CONTRL	- Linked list offset definition

;
; Format for the linked lists that describe states for the control sequences:
;
;               +----------------------------+
;               | Pointer to next block      |   +0 STA.LNK   zero if no more
;               +----------------------------+
; STA.HIGH +3   | High range   | Low range   |   +2 STA.LOW   range to be in
;               +----------------------------+
;               | Next state                 |   +4 STA.NXT   state change
;               +----------------------------+
;

	.SAVE
	.DSECT	,CREF

STA.LNK:	.BLKW
STA.LOW:	.BLKB
STA.HIGH:	.BLKB
STA.NXT:	.BLKW

	.RESTORE

.SBTTL	CONTRL	- Control sequence identifier table

	.SAVE
	.PSECT	LPPURE,RO,CON,D

CTLIDT:	.BYTE	33	; <ESC> escape character
	.BYTE	233	; <CSI> control sequence introducer
	.BYTE	234	; <ST>  string terminator
	.BYTE	220	; <DCS> device control string
	.BYTE	235	; <OSC> operating system command
	.BYTE	236	; <PM>  privacy message
	.BYTE	237	; <APC> application program command
	.BYTE	0	; <> end of table

	L.CTLIDT =  <<.-CTLIDT>-1.>

	.EVEN

CTLTYP:	.WORD	$.ESC
	.WORD	$.CSI
	.WORD	0			; <ST> requires no state transition
	.WORD	$.DCS
	.WORD	$.OSC
	.WORD	$.PM
	.WORD	$.APC

	L.CTLTYP = <<.-CTLTYP>/2.>

	.ASSUME	L.CTLTYP EQ L.CTLIDT

	.RESTORE

.SBTTL	CONTRL	- Control sequence state lists

;
; <ESC> sequence recognition state
;

	.SAVE
	.PSECT	LPPURE
	.ENABL	LSB

$.ESC:		.WORD	10$		;CSI recognition
		.BYTE	133		; 133 = '[' 	5/11
		.BYTE	133		; escape followed directly by [ is CSI
		.WORD	$.CSI		; next state is CSI

10$:		.WORD	20$		;APC recognition
		.BYTE	137		; 137 = '_'	5/15
		.BYTE	137		; escape followed directly by _ is APC
		.WORD	$.APC		; next state is APC

20$:		.WORD	30$		;DCS recognition
		.BYTE	120		; 120 = 'P'	5/0
		.BYTE	120		; escape followed directly by P is DCS
		.WORD	$.DCS		; next state is DCS

30$:		.WORD	40$		;OSC recognition
		.BYTE	135		; 135 = ']'	5/13
		.BYTE	135		; escape followed directly by ] is OSC
		.WORD	$.OSC		; next state is OSC

40$:		.WORD	50$		;PM recognition
		.BYTE	136		; 136 = '^'	5/14
		.BYTE	136		; escape followed directly by ^ is PM
		.WORD	$.PM		; next state is PM

50$:		.WORD	$.ESCI		;ST recognition
		.BYTE	134		; 134 = '\'	5/12
		.BYTE	134		; escape followed directly by \ is ST
		.WORD	0		; escape sequence is done

$.ESCI:		.WORD	60$		;I..I intermediate processing
		.BYTE	40		; 40 = space	2/0
		.BYTE	57		; 57 = '/'	2/15
		.WORD	$.ESCI		; remain in escape sequence mode

60$:		.WORD	70$		;I..I more intermediate processing
		.BYTE	240		; 240 = undef	10/0
		.BYTE	257		; 257 = undef	10/15
		.WORD	$.ESCI		; remain in escape sequence mode

70$:		.WORD	80$		;F the final character
		.BYTE	60		; 60 = '0'	3/0
		.BYTE	176		; 176 = '~'	7/14
		.WORD	0		; escape sequence done

80$:		.WORD	90$		;F more final characters	;068
		.BYTE	260		; 260 = degree	11/0
		.BYTE	377		; 377 = undef	15/15		;072
		.WORD	0		; escape sequence done

90$:		.WORD	100$		;CAN control character processing ;068
		.BYTE	30		; 30 = CAN	1/8		;068
		.BYTE	30		;				;068
		.WORD	0		; cancel sequence processing	;068

100$:		.WORD	110$		;SUB control character processing ;068
		.BYTE	32		; 32 = SUB	1/10		;068
		.BYTE	32		;				;068
		.WORD	0		; cancel sequence processing	;068

110$:		.WORD	120$		;ESC control character processing ;068
		.BYTE	33		; 33 = <ESC>	1/11		;068
		.BYTE	33		;				;068
		.WORD	$.ESC		; next state escape sequence	;068

120$:		.WORD	130$		;C0 control character processing ;068
		.BYTE	0		; 0 = null	0/0		;068
		.BYTE	37		; 37 = US	1/15		;068
		.WORD	-1		; continue with same sequence	;072

130$:		.WORD	0		;DEL character processing	;068
		.BYTE	177		; 177 = DEL	7/15		;068
		.BYTE	177		;				;068
		.WORD	-1		; continue with same sequence	;072

	.DSABL	LSB

;
; <CSI> sequence recognition state
;

	.ENABL	LSB

$.CSI:
$.CSIP:		.WORD	10$		;P..P parameter string processing
		.BYTE	60		; 60 = '0'	3/0
		.BYTE	77		; 77 = '?'	3/15
		.WORD	$.CSIP		; remain parsing parameter string

10$:		.WORD	$.CSII		;P..P more parameter string processing
		.BYTE	260		; 260 = degree	11/0
		.BYTE	277		; 277 = ? sort	11/15
		.WORD	$.CSIP		; remain parsing parameter string

$.CSII:		.WORD	20$		;I..I intermediate processing
		.BYTE	40		; 40 = space	2/0
		.BYTE	77		; 77 = '?'	3/15
		.WORD	$.CSII		; remain parsing intermediate

20$:		.WORD	30$		;I..I more intermediate processing
		.BYTE	240		; 240 = undef	10/0
		.BYTE	277		; 277 = ? sort	11/15
		.WORD	$.CSII		; remain parsing intermediate
;
; NOTE: an intermediate char ( I..I ) between 3/0 and 3/15 and 11/0 and 11/15
;       is invalid, but we will continue processing the sequence.
;

30$:		.WORD	40$		;F final processing
		.BYTE	100		; 100 = '@'	4/0
		.BYTE	176		; 176 = '~'	7/14
		.WORD	0		; control sequence done

40$:		.WORD	50$		;F more final processing
		.BYTE	300		; 300 = an A	12/0
		.BYTE	377		; 377 = undef	15/15		;072
		.WORD	0		; control sequence done

50$:		.WORD	60$		;CAN control character processing
		.BYTE	30		; 30 = CAN	1/8
		.BYTE	30		; 
		.WORD	0		; cancel sequence processing

60$:		.WORD	70$		;SUB control character processing
		.BYTE	32		; 32 = SUB	1/10
		.BYTE	32		; 
		.WORD	0		; cancel sequence processing

70$:		.WORD	80$		;ESC control character processing
		.BYTE	33		; 33 = <ESC>	1/11
		.BYTE	33		; 
		.WORD	$.ESC		; next state escape sequence

80$:		.WORD	90$		;other control character processing
		.BYTE	0		; 0 = null	0/0
		.BYTE	37		; 37 = US	1/15
		.WORD	-1		; continue with same sequence	;072

90$:		.WORD	0		;DEL character processing
		.BYTE	177		; 177 = DEL	7/15
		.BYTE	177		;
		.WORD	-1		; continue with same sequence	;072

	.DSABL	LSB

;
; <DCS> sequence recognition state
;
;	This section handles the DCS introducer, the command string is
;	part of the common section following.
;

	.ENABL	LSB

$.DCS:
$.DCSP:		.WORD	10$		;P..P parameter string processing
		.BYTE	60		; 60 = '0'	3/0
		.BYTE	77		; 77 = '?'	3/15
		.WORD	$.DCSP		; remain parsing parameter string

10$:		.WORD	$.DCSI		;P..P more parameter string processing
		.BYTE	260		; 260 = degree	11/0
		.BYTE	277		; 277 = ? sort	11/15
		.WORD	$.DCSP		; remain parsing parameter string

$.DCSI:		.WORD	20$		;I..I intermediate processing
		.BYTE	40		; 40 = space	2/0
		.BYTE	77		; 77 = '?'	3/15
		.WORD	$.DCSI		; remain parsing intermediate

20$:		.WORD	30$		;I..I more intermediate processing
		.BYTE	240		; 240 = undef	10/0
		.BYTE	277		; 277 = ? sort	11/15
		.WORD	$.DCSI		; remain parsing intermediate
;
; NOTE: an intermediate char ( I..I ) between 3/0 and 3/15 and 11/0 and 11/15
;       is invalid, but we will continue processing the sequence.
;

30$:		.WORD	40$		;F final processing
		.BYTE	100		; 100 = '@'	4/0
		.BYTE	176		; 176 = '~'	7/14
		.WORD	$D..D		; parse the command string

40$:		.WORD	$D..D		;F more final processing
		.BYTE	300		; 300 = an A	12/0
		.BYTE	376		; 376 = undef	15/14
		.WORD	$D..D		; parse the command string

	.DSABL	LSB

;
; <OSC>, <PM>, <APC>, and <DCS> command string (D..D) sequence recognition state
;

	.ENABL	LSB

$.APC:
$.PM:
$.OSC:
$D..D:		.WORD	10$		;<ST> string terminator processing
		.BYTE	234		; 234 = <ST>	9/12
		.BYTE	234		;
		.WORD	0		; control string done

10$:		.WORD	20$		;<ESC> control character processing
		.BYTE	33		; 33 = <ESC>	1/11
		.BYTE	33		;
		.WORD	$D.ESC		; parse escape character received

$D.ESC:		.WORD	$D..D		;<ST> seven bit form detection
		.BYTE	134		; 134 = '\'	5/12
		.BYTE	134		;
		.WORD	0		; control string done

20$:		.WORD	0		;D..D processing
		.BYTE	0		; All other characters
		.BYTE	377		;
		.WORD	$D..D		; remain parsing command string

	.DSABL	LSB
	.RESTORE

.SBTTL	SAVOPT	- SAVE FILE OUTPUT OPTIONS
.SBTTL	RSTOPT	- RESTORE FILE OUTPUT OPTIONS
.SBTTL	SAVMOD	- SAVE FILE OUTPUT RECORD MODE
.SBTTL	RSTMOD	- RESTORE FILE OUTPUT RECORD MODE

;+
;
; SAVOPT:
; RSTOPT:
;
; SAVMOD:
; RSTMOD:
;
;
; INPUTS:
;
;		R5 -> IMPURE AREA
;		R0 -> FUNCION BITS TABLE
;
; CALL:
;	JSR	PC,SAVOPT
;	JSR	PC,RSTOPT
;
;	JSR	PC,SAVMOD
;	JSR	PC,RSTMOD
;
;
; BACK:
;
;			FILE OR OUTPUT RECORD OPTIONS SAVED OR RESTORED
;
;		ALL REGS PRESERVED
;
;
;-

SAVOPT:	MOV	DDFLAG(R5),SVDOPT(R5)	;SAVE THE OPTIONS WORD
	SETFUN	S.ROPT,R0		;SETFUN THAT OPTIONS BE RESTORED
	RETURN

RSTOPT:	MOV	SVDOPT(R5),DDFLAG(R5)	;RESTORE THE SAVED OPTIONS WORD
	RETURN

SAVMOD:	MOV	ORCMOD(R5),SVDMOD(R5)	;SAVE THE OUTPUT RECORD MOD WORD
	SETFUN	S.RMOD,R0		;SETFUN THAT IT BE RESTORED
	RETURN

RSTMOD:	MOV	SVDMOD(R5),ORCMOD(R5)	;RESTORE THE SAVED ORCMOD
	RETURN

.SBTTL	EMPTY	- EMPTY OUTPUT BUFFERS TO DEVICE

;+
;
; EMPTY:
;
;
; INPUTS:
;
;		R5 -> IMPURE AREA
;		R0 -> FUNCION BITS TABLE
;
; CALL:
;	JSR	PC,EMPTY
;
;
; BACK:
;
;			CALL PRINTER TO DRAIN OUTPUT BUFFERS
;			AND PAD WITH ZERO'S IF NECESSARY
;
;		ALL REGS PRESERVED
;
;
;-

EMPTY:	CMP	OUTPOS(R5),OUTPTR(R5)	;IS THE BUFFER ALREADY EMPTY?
	BEQ	30$			;YES
	BIT	#FLGFRC,DEVFLG(R5)	;ARE WE DOING PARTIAL-BLOCK PUTS?
	BNE	20$			;YES, SO NO NEED TO FILL THE BLOCK
	MOV	OUTPTR(R5),R1		;GET POINTER TO END OF CURRENT DATA
	MOV	FREE(R5),R2		;AND AMOUNT OF FREE SPACE IN BUFFER
	BEQ	30$			;  IF NO SPACE LEFT
10$:	CLRB	(R1)+			;PAD WITH NULLS
	SOB	R2,10$
	MOV	R1,OUTPTR(R5)		;CORRECT OUTPUT POINTER
	CLR	FREE(R5)		;AND FREE COUNT
20$:	SETFUN	S.PUT,R0		;CALL THE BUFFER WRITER
30$:	RETURN				; AND BACK WE GO

.SBTTL	EMPTY1	- EMPTY OUTPUT BUFFERS ON PRINT DEVICE

;+
;
; EMPTY1:
;
;
; INPUTS:
;
;		R5 -> IMPURE AREA
;		R0 -> FUNCION BITS TABLE
;
; CALL:
;	JSR	PC,EMPTY1
;
;
; BACK:
;
;		Wait for printer output buffer to empty
;		R1-R4 trashed if SLPTIM is called.
;
;-

EMPTY1:	CMP	OUTPOS(R5),OUTPTR(R5)	;IS THE BUFFER ALREADY EMPTY?
	BEQ	10$			;YES
	SETFUN	S.EMTY,R0		;NO, SO EMPTY IT FIRST
	SETFUN	S.EMT1,R0		;COME BACK TO US TO FINISH
	BR	20$			;AND EXIT

10$:	CMPB	#LPTHND,DEVFLG(R5)	;IS OUTPUT DEVICE AN LP?
	BNE	30$			;No.  Have to check KB's ourselves ;065
	BIT	#8192.,ORCMOD(R5)	;ARE WE DOING NO STALL WRITES?
	BEQ	20$			;NO, SO DON'T NEED TO WAIT
	CALL	SAVMOD			;YES, SAVE CURRENT MODIFIER BITS
	BIS	#4.,ORCMOD(R5)		;AND SET 'STALL UNTIL COMPLETE' BIT
	CLRB	@OUTPTR(R5)		;ADD NULL TO END OF CURRENT DATA
	INC	OUTPTR(R5)		;INCR OUTPUT POINTER
	DEC	FREE(R5)		;DECR FREE COUNT
	SETFUN	S.PUT,R0		;CALL THE BUFFER WRITER
20$:	RETURN				;AND EXIT

;+
; For keyboards, we'll check the buffer chain ourselves.
; It's sneaky, but until terminal service can help us it's
; the only thing we can do.  At least one .UUO is better
; than a couple PEEKs.
;
; If the chain isn't empty, we'll keep track of the DDB
; empty pointer to see if any progress is being made.
;
; If no progess is being made, we'll adjust the sleep timer
; according to the same rules that PUT uses, and possibly
; mark the server offline as well.
;
; According to current rules, server offline will occur
; in (5+5+6+7+8+9+10+10) = 60 seconds.
;-

30$:	CALLX	CLRFQB			;Start with a clear FIRQB	;065
	MOVB	#UU.FCB,@#FIRQB+FQFUN	;Get open channel statistics...	;065
	MOVB	OUTLUN(R5),@#FIRQB+FQFIL ; for the output device...	;065
	ASRB	@#FIRQB+FQFIL		;    on this channel.		;065
	;CLRB	@#FIRQB+FQSIZM		;We're interested in the DDB	;065
	.UUO				;Do it				;065
	CMP	@#FIRQB+FQBUFL,@#FIRQB+FQSIZ ; Is buffer chain empty?	;065
	BNE	40$			;No.  We'll have to sleep on it	;065
	CALLR	DEVONL			;Ensure QMAN knows all's well	;065

40$:	MOV	..DFSL,R1		;Get default sleep time		;065
	MOV	..SMLW,R2		;Fake bytes written for SLPTIM	;065
	MOV	@#FIRQB+FQSIZ,R3	;Pick up current empty pointer	;065
	MOV	DDBUFC(R5),R4		; and the last empty pointer	;065
	CALL	SLPTIM			;Find how long we should sleep	;065
	MOV	@#FIRQB+FQSIZ,DDBUFC(R5) ;Save the new empty pointer	;065
	SETFUN	S.EMT1,R0		;Come back to us again...	;065
	RETRY	R1			; after we sleep a while	;065

.SBTTL	GET	- GET RECORD FROM INPUT FILE

;+
;
; GET:
;
;
; INPUTS:
;
;		R5 -> IMPURE AREA
;		R0 -> FUNCION BITS TABLE
;
; CALL:
;	JSR	PC,GET
;
;
; BACK:
;
;		RECORD RECIEVED FROM INPUT FILE
;			STALL AND RETRY ON LOCKED BLOCKS
;			CALL PRINTER IF BUFFER SPACE LOW
;			CRASH ON UNKNOWN ERRORS
;
;
;
;	ONLY RETURN IF SUCCESS
;	ON FAILURE STALL SPOOLER
;
;-

GET:	CALLX	RMSGET		;TRY TO GET THE RECORD
	BCC	20$		;CONTINUE IF NO ERROR ON GET
	CMP	#ER$EOF,STS(R5)	;WAS ERROR END OF FILE?
	BEQ	30$		;YES SO DON'T PRINT ERROR
	CMP	#ER$RLK,STS(R5)	;WAS ERROR 'RECORD LOCKED'
	BNE	10$		;NO SO TO HELL WITH IT
	SETFUN	S.GET,R0	;WE WANT TO TRY AGAIN WHEN WE COME BACK
	RETRY	#3		;TAKE A SHORT NAP AND HOPE IT CLEARS UP

10$:	SETFUN	S.ERROR,R0	;UNKNOWN ERROR, SETFUN A MESSAGE
	CALLR	PRINTD		;BUT PRINT ANY DATE WE HAVE FIRST
				;AND DON'T COME BACK TO GET AGAIN

20$:	SETFUN	S.GET,R0	;AND THEN CALL US BACK
	CALL	RSTBLD		;GO BUILD THE RESTART TABLE ENTRY
	CALLR	PRINTD		;AND PRINT DATA FROM THE BUFFER

30$:	BIT	#J.ESC,JOBSTA(R5) ;ARE WE IN THE MIDDLE OF A CONTROL STRING?
	BEQ	35$		;NO, WE MAY TERMINATE NORMALLY
	MOVB	#234,@REC(R5)	;YES, WE MUST TERMINATE IT.  INSERT <ST>
	MOV	#1,RECL(R5)	;SET ARTIFICIAL LENGTH TO 1
	MOV	REC(R5),RECPTR(R5) ;SET ARTIFICIAL RECORD POINTER
	CALLR	PRINTD		;AND PRINT IT (WITH NO RESET SETFUN TO GET)

35$:	RETURN

.SBTTL	PUT	- PUT BUFFER TO OUTPUT DEVICE

;+
;
; PUT:
;
;
; INPUTS:
;
;	R0 -> Funcion bits table
;	R5 -> Impure area
;
; CALL:
;
;	JSR	PC,PUT
;
; BACK:
;
;	Data output to output channel
;	stall and retry on device hung
;
;	ONLY RETURN IF SUCCESS
;	ON FAILURE STALL SPOOLER
;-

PUT:	MOV	OUTPTR(R5),R2	;get addr of end of data
	SUB	OUTPOS(R5),R2	;-start of data=len of data
	BNE	10$		;yes, continue
	MOV	OUTBUF(R5),OUTPTR(R5) ;no, reset output pointer to begining
	MOV	OUTBUF(R5),OUTPOS(R5) ;reset output pointer to begining
	MOV	OUTBLN(R5),FREE(R5) ;and reset the free byte counter
	BR	90$

10$:	TST	DEVHNG(R5)	;Did we experience carrier loss?
	BEQ	30$		;nope, carry on (ha ha)
	CALL	OPNDEV		;Let's try to open the device again
	BCC	20$		;Open succeeded, inform QMAN
	CALL	CLSDEV		;Rats, modem line still down
	MOV	#30.,R1		;wait for device at 30 second intervals	;065
	BR	50$		;skip to retry code

20$:	CALL	DEVONL		;Notify QMAN that we have a printer again
	BR	90$		;and wait for further orders from QMAN

30$:	CALLX	CLRFQX		;clear the firqb and xrb
	MOV	#XRB,R1		;pointer to xrb
	MOV	R2,(R1)		;length of buffer (xrlen)
	MOV	(R1)+,(R1)+	;length of data (xrbc)
	MOV	OUTPOS(R5),(R1)+;addr of data (xrloc)
	MOVB	OUTLUN(R5),(R1) ; channel for output (xrci)
	MOV	ORCMOD(R5),@#XRB+XRMOD ;set output record modifyer
	.WRITE
	MOV	R2,R4		;save no. bytes requested (in case of nl:)
	MOV	@#XRB+XRBC,R3	;Pick up bytes left			;065
	SUB	R3,R2		;R2 = no. bytes actually printed	;065
	ADD	R2,OUTPOS(R5)	;update outpos for data printed for re-try
	MOV	#5.,R1		;init default sleep timer		;065
..DFSL==.-2		; ** PATCH TO CHANGE DEFAULT SLEEP TIMER
	TSTB	@#FIRQB		;did the write work?
	BEQ	70$		;yes, so skip error check
	CMPB	#HNGDEV,@#FIRQB	;was the error 'DEVICE HUNG'?
	BEQ	40$		;yes
	CMPB	#DETKEY,@#FIRQB	;was error 'I/O TO DETACHED KB'?
	BNE	50$		;no, so use short sleeper
	MOV	SP,DEVHNG(R5)	;yes, assuming carrier loss
	CALL	DEVOFL		;tell qman, enter paused state
	BCS	90$		;exit if OFL/ABORT was specified
	MOV	#30.,R1		;select 30 second stall interval	;065
	SUB	R2,OUTPOS(R5)	;pretend nothing made it out at all
	BR	50$		;and wait for our device to come back

40$:	ASL	R1		;double the sleep timer			;065
	CALL	DEVOFL		;call the device offline, tell qman
	BCS	90$		;exit if OFL/ABORT was specified
50$:	SETFUN	S.PUT,R0	;setfun us to try again
60$:	CLR	SUCPUT(R5)	;clear successful puts counter
	RETRY	R1		;any do the retry			;065

70$:	TST	@#XRB+XRBC	;did we write all the data?
	BNE	100$		;no, so go figure out how soon to try again
	CLR	ZERPUT(R5)	;yes, show no bad puts outstanding
	CALL	DEVONL		;tell qman device is back online
	MOV	OUTBUF(R5),OUTPTR(R5) ;yes, reset output pointer to begining
	MOV	OUTBUF(R5),OUTPOS(R5) ;reset output pointer to begining
	MOV	OUTBLN(R5),FREE(R5) ;and reset the free byte counter
	CLR	R1		;assume a short sleep timer		;065
	CMP	@#XRB+XRLEN,#132. ;was there much to write?
..LNGW==.-2		; ** PATCH TO LENGTH OF A 'LONG' WRITE ATTEMPT
	BLO	80$		;nope, not much
	CLR	PUTSLP(R5)	;enough to reset the sleep timer
80$:	INC	SUCPUT(R5)	;bump successfull put counter
	CMP	SUCPUT(R5),#4	;have we done a few successfull puts yet
..SUCP==.-2		; ** PATCH TO CHANGE MAX SUCCESS-PUT COUNTER
	BHI	60$		;yes, so nap for a short time
90$:	RETURN

100$:	CALL	SLPTIM		;Figure out how long we should sleep	;065
	BR	50$		;Now go do it				;065

.ASSUME	XRLEN	EQ	0	;verify xrb definitions
.ASSUME	XRBC	EQ	XRLEN+2	;verify xrb definitions
.ASSUME	XRLOC	EQ	XRBC+2	;verify xrb definitions
.ASSUME	XRCI	EQ	XRLOC+2 ;verify xrb definitions

	GLOBAL	<HNGDEV,DETKEY>

.SBTTL	SLPTIM	- Compute how long to wait for a retry

;+
;
; SLPTIM:
;
;
; INPUTS:
;
;	R0 -> Funcion bits table
;	R1 =  Default sleep time
;	R5 -> Impure area
;
;	Called by:	PUT				EMPTY1
;
;	R2 =  # of chars partially output		..SMLW
;	R3 =  Characters left in buffer		Current DDB empty pointer
;	R4 =  Size of output buffer		Previous DDB empty pointer
;
; CALL:
;
;	JSR	PC,SLPTIM
;
; BACK:
;
;	R1 =  How long to sleep before trying again
;	All other registers preserved
;
;	Device is marked offline if too much time has progressed
;	with nothing occuring on a keyboard server.
;-

SLPTIM:	CMP	R3,R4			;Has anything gone out?		;065
	BEQ	10$			;No, check for possible XOFF	;065
	CLR	ZERPUT(R5)		;Yes.  Show device is active	;065
	CALL	DEVONL			;Make sure QMAN knows it	;065
	CMP	R2,#16.			;Was it the arbitrary minimum?	;065
..SMLW==.-2		; ** PATCH TO LENGTH OF A 'SHORT' WRITE ATTEMPT
	BLO	30$			;No, see if we should bump it	;065
	MOV	PUTSLP(R5),R1		;Already at minimum sleep?	;065
	BEQ	50$			;Yes, so don't change timer	;065
	DEC	R1			;No, lower the sleep timer	;065
	BR	40$			;and go use it			;065

10$:	CMPB	#LPTHND,DEVFLG(R5)	;Writing to an LP device?	;065
	BNE	20$			;No, continue			;065
	MOV	#8192.+4,-(SP)		;Must be PUT calling...		;065
	BIC	ORCMOD(R5),(SP)+	;Both stall/no stall bits set?	;065
	BNE	20$			;No, continue			;065
	MOV	#2,R1			;Yes, just waiting for EOJ	;065
..LPWT==.-2		; ** PATCH TO CHANGE LP WAIT TIMER
	CALL	DEVONL			;In case we were offline before	;065
	BR	40$			;All set for retry		;065

20$:	INC	ZERPUT(R5)		;Count # times with no progress	;065
	CMP	ZERPUT(R5),#8.		;Have we waited long enough?	;065
..ZERP==.-2		; ** PATCH TO CHANGE MAX ZERO-LENGTH PUT COUNTER
	BHI	60$			;Yes, go call it offline	;065
30$:	MOV	PUTSLP(R5),R1		;No, how long did we last sleep	;065
	CMP	R1,#10.			;Already at maximum?		;065	
..MAXS==.-2		; ** PATCH TO CHANGE MAXIMUM SLEEP TIMER
	BHIS	40$			;Yep.  Just use it		;065
	CMP	ZERPUT(R5),#2		;Tried this value a few times?	;065
..ZERC==.-2		; ** PATCH TO CHANGE COUNT OF FAILURES TO INC SLEEPER
	BLOS	40$			;Not yet.  Stick with default	;065
	INC	R1			;Yes, try a longer sleep timer	;065
40$:	MOV	R1,PUTSLP(R5)		;Save the new sleep timer...	;065
50$:	RETURN				;Back to the caller		;065

60$:	ASL	R1			;Double the sleep timer		;065
	CALL	DEVOFL			;Call it offline		;065
	BCC	70$			;Everything's okay		;065
	COM	(SP)+			;Exit if OFL/ABORT specified	;065
70$:	RETURN				;All done in here		;065


.SBTTL	DEVOFL	- Device Offline Handler

;+
;
; DEVOFL:
;
;	Tell QMAN that our device has gone offline.
;
;	Carry is set when device is already offline and we have received
;	an OFL/ABORT command.
;
; INPUTS:
;
;	R0 -> Function bits table
;	R5 -> Impure area
;	DEVHNG(R5) <> 0 if carrier loss
;
; CALL:
;
;	JSR	PC,DEVOFL
;
; BACK:
;
;	C=0 ON SUCCESS, C=1 FAILURE
;
;	ALL REGS PRESERVED
;
;-

	.ENABL	LSB
                
DEVOFL:	BIT	#J.HNG,JOBSTA(R5)	;Have we already told QMAN?
	BNE	20$			; Yes, exit
	SAVREG
	BIS	#J.HNG,JOBSTA(R5)	;No, show device hung state
	MOV	#SQ.STU,R1		;Set status update command
	MOV	#SU$OFL,R2		;Assume simple offline status
	TST	DEVHNG(R5)		;Was offline due to Car loss?
	BEQ	10$			;No, assumption is valid
	MOV	#SU$CAR,R2		;Yes, set new status
	CLR	DDPAUS(R5)		;Show no pause options
	SETFUN	S.PAU,R0		;Fool us into being paused
	CALL	CLSDEV			;and close the output device
10$:	MOV	JOBPTR(R5),R3		;Fetch the job record		;074
	MOV	HD.LEN+JB.FLG(R3),R3	;Send JB.FLG for NOTIFY		;074
	CALL	SNDCMN			;Send the message
	BR	30$			;and succeed

20$:	BIT	#J.ABOF,JOBSTA(R5)	;have we received OFL/ABORT
	BEQ	30$			;no, continue
	CLRFUN	S.PUT,R0		;clear for clean abort......
	CLRFUN	S.RMOD,R0		;  if device is truely offline
	CLRFUN	S.EMTY,R0
	CLRFUN	S.PACN,R0
	CLRFUN	S.ATN,R0
	CLRFUN	S.PAU,R0
	CLRFUN	S.CVT,R0
	CLRFUN	S.ROPT,R0
	CLRFUN	S.FORM,R0
	CLRFUN	S.P0CR,R0
	CLRFUN	S.PGJH,R0
	CLRFUN	S.PGFH,R0
	CLRFUN	S.OPN,R0
	CLRFUN	S.ERROR,R0
	CLRFUN	S.PEOF,R0
	CLRFUN	S.EOF,R0
	CLRFUN	S.ERASE,R0
	CLRFUN	S.WLD,R0
	CLRFUN	S.EOFS,R0
	CLRFUN	S.PGJT,R0
	CLRFUN	S.PEOJ,R0
	CLRFUN	S.EOJC,R0
	CLRFUN	S.P1CR,R0
	CLRFUN	S.EMT1,R0
	BR	40$				;set fail flag to abort run
30$:	TST	(PC)+
40$:	SEC
	RETURN

	.DSABL	LSB

.SBTTL	DEVONL	- Device back On-line handler

;+
;
; DEVONL:
;
;	Tell QMAN that our device is once more on-line.
;
; INPUTS:
;
;	R0 -> Function bits table
;	R5 -> Impure area
;
; CALL:
;
;	JSR	PC,DEVONL
;
; BACK:
;
;	C=0 ON SUCCESS, C=1 FAILURE
;
;	ALL REGS PRESERVED
;
;-

	.ENABL	LSB

DEVONL:	BIT	#J.HNG,JOBSTA(R5)		;Does QMAN know we are ONL?
	BEQ	10$				;Yes, don't tell him again.
	TST	DEVHNG(R5)			;Did we experience carrier loss?
	BNE	10$				;Yes, we're not really onl.
	SAVREG
	BIC	#J.HNG,JOBSTA(R5)		;Show no longer hung
	MOV	#SQ.STU,R1			;Set status update command
	MOV	#SU$ONL,R2			;Set resume online status
	CLR	R3				;No flags meaningful
	CALL	SNDCMN				;Send the message
10$:	CLC
	RETURN

	.DSABL	LSB

.SBTTL	DEATHO	- ALL DONE CRASH NOW

;+
;
; DEATHO:
;
;
; INPUTS:
;
;		R5 -> IMPURE AREA
;		R0 -> FUNCION BITS TABLE
;
; CALL:
;	JSR	PC,DEATHO
;
;
; BACK:
;		THERE IS NO RETURN FROM WHENCE WE GO
;
;
;-

DEATHO:	MOV	#SQ.OFL,R1		;LOAD OFF-LINE COMMAND
	CALL	SNDCMN			;SUMMON QMAN TO OUR BEDSIDE
	SHUTUP				;THE KING IS DEAD,
					; LONG LIVE THE KING.

.SBTTL	PAUEOF	- PAUSE AT END-OF-FILE

;+
;
; PAUEOF:
;
;
; INPUTS:
;
;		R0 -> FUNCION BITS TABLE
;		R5 -> IMPURE AREA
;
; CALL:
;	JSR	PC,PAUEOF
;
;		PAUSE AT END OF FILE UNTIL CONTINUE RECEIVED
;
;
; BACK:
;
;		 ALL REGS PRESERVED
;
;-

PAUEOF:	SETFUN	S.EMTY,R0		;SETFUN TO EMPTY OUTPUT BUFFERS
	SETFUN	S.PAU,R0		;SETFUN PAUSE IMMEDIATELY
	SETFUN	S.QMSG,R0		;SETFUN TO CHECK FOR ANOTHER MSG
	RETURN				;DONE

.SBTTL	PAUEOJ	- PAUSE AT END-OF-JOB

;+
;
; PAUEOJ:
;
;
; INPUTS:
;
;		R0 -> FUNCION BITS TABLE
;		R5 -> IMPURE AREA
;
; CALL:
;	JSR	PC,PAUEOJ
;
;		PAUSE AT END-OF-JOB UNTIL CONTINUE MSG RECEIVED
;
;
; BACK:
;
;		 ALL REGS PRESERVED
;
;-

PAUEOJ:		RETURN				;ITS QMAN'S JOB, NOT OURS

.SBTTL	PAUSE	- PAUSE TILL NEXT MESSAGE
.SBTTL	IDLJOB	- IDLE/STALL LOOP FOR SPOOLER
.SBTTL	RETRY	- RETRY LATER AND ENABLE MESSAGES

;+
;
; PAUSE:
; IDLJOB:
;
;
; INPUTS:
;
;		R5 -> IMPURE AREA
;		R1  = STALL TIME (FOR RETRY ONLY)
;		R0 -> FUNCION BITS TABLE
;
; CALL:
;	JSR	PC,PAUSE
;	JSR	PC,IDLJOB
;	JSR	PC,RETRY
;
;
; BACK:
;
;			STALL SPOOLER UNTILL OUTSIDE EVENT OCCURES
;			SUCH AS A MESSAGE BEING SENT FOR US
;
;
;
;	WE NEVER RETURN (HERE) WE GET RESCHEDULED
;
;-

	.ENABL	LSB

PAUSE:	SETFUN	S.PAU,R0		;RESET OURSELVES FOR NEXT TIME
	CLR	DDPAUS(R5)		;show no pause options		;020
	.BR	IDLJOB			;AND JOIN IDLJOB

IDLJOB:	MOV	#-1,R1			;SET FOR A LONG NAP
RETRY:	SETFUN	S.STALL,R0		;WE MUST ALWAYS BE SET !!!!!
	SETFUN	S.QMSG,R0		;AND TRY FOR A NEW MESSAGE NEXT TIME
	STALL	R1			;AND AWAY WE GO

	.DSABL	LSB

	.END
