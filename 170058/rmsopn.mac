.INCLUDE	%CMN:COMMON%
TITLE	RMSOPN,<RMS-11 OPEN INTERFACE FOR SIMPLE CUSP>,0A,10-MAY-91,RTW/SJM/KCG/DBM

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR RMSOPN
;+
;
;  001  SJM  23-Sep-82	CREATION - And it was a good thing
;  002	KCG  11-Feb-83	Append mode 4096 to filespec string
;  003	KCG  24-Feb-83	Remove mode switch after the open
;  004	PRL  26-May-84	Use .INCLUDEs and .LIBRARYs
;
;  005	KCG  09-Jan-85	Allow an 8 byte pre-fixed stacking underflow area for
;			PRTSER's UNGET routine.
;  006	KCG  21-Aug-85	Honor STM FTN files.
;  007	KCG  23-Aug-85	Ensure Record I/O files get some kind of carriage 
;			control.
;  008	KCG  07-Oct-85	Take out change to default STM CC for non-stream files.
;  009	DBM  02-Sep-87	Use block I/O on stream files whenever possible
;			Ensure enough UNGET space in the buffer
;  010	DBM  01-Feb-88	Don't believe RMS on RF:STR, CC:IMP files.
;-

.SBTTL	INCLUDE MACRO LIBRARIES

.LIBRARY	%SYSTEM:PBSMAC%
.LIBRARY	%LB:RMSMAC%

.SBTTL	MACROS	- SUCK IN NEEDED MACROS

	.PSECT

	.MCALL	$INITIF		;DO THE RMS CALL TO DEFINE THE WORLD
	.MCALL	$STORE,$FETCH,$COMPARE,$TESTBITS,$SET,$OFF
	.MCALL	$OPEN,$CONNECT,$GET,$CLOSE
	.MCALL	FABOF$,RABOF$,FAB$BT,RAB$BT,$RMSTAT,RMS$L
	.MCALL	DFIN$L

	.MCALL	PSECTS,BITDEF,SAVREG
	.MCALL	FQBERR,RMSERR,CR$LF
	.MCALL	SUBRIB,GETLUN,RETLUN,GETBUF,RETBUF
	.MCALL	RMSBLK

	PSECTS
	BITDEF
	CR$LF
	RMSBLK



.SBTTL	OFFSETS	- DEFINE FAB/RAB OFFSETS

	FABOF$	RMS$L
	RABOF$	RMS$L
	FAB$BT	DFIN$L
	RAB$BT	DFIN$L
	$RMSTAT	DFIN$L

.SBTTL	RMSINIT	- INIT CODE FOR RMS-11 SIMPLE INTERFACE

;+
;
; RMSINIT
;
; THIS ROUTINE FIRST ALLOCATES
; ENOUGH BUFFER SPACE FOR IT'S USE. 
; THE ADDRESS AND LENGTH OF THE BUFFER GOTTEN ARE
; STORED IN BUF(R5) AND BUFL(R5). IF ENOUGH SPACE CAN NOT BE OBTAINED
; IT RETURNS THE RMS ERROR CODE FOR 'DYNAMIC MEMORY EXAUSTED' IN
; STS(R). IT SPACE WAS OBTAINED IT ALLOCATES IT FOR A FAB AND A RAB
; AND A 512. BYTE USER RECORD BUFFER FOR RMS, A 2 BYTE HEADER
; BUFFER IS USED FOR THE VFC HEADER IF THE FILE OPENED IS A PRN
; FORMAT FILE. THEN THE FAB AND RAB ARE INITIALIZE.
;
; INPUT FIELDS
;	ARGCNT	 = # OF BYTES LONG ARGUMENT BLOCK IS (SANITY CHECK)
;
; OUTPUT FIELDS
;	STS	 = CONTENTS OF RMS STS FIELD AFTER AN RMS OPERATION >=0 SUCCES
;	STV	 = CONTENTS OF RMS STV FIELD AFTER AN RMS OPERATION
;	BUF	-> BUFFER RETURNED FROM 'GETBUF'
;	BUFL	 = LEN OF BUFFER
;	REC	-> DATE RECORD TO BE RETURNED
;	RECL	 = LENGTH OF DATA RECORD
;	RECBL	 = LENGTH OF DATA BUFFER
;	FAB	-> FAB
;	RAB	-> RAB
;




;
;
;
;		-------------------------
;  	R5 ->	|    #OF ARGS 		| I	ARGCNT		0 
;		-------------------------
;		|    STATUS		| O	STS		2 
;		-------------------------
;		|    STATUS1		| O	STV		4 
;		-------------------------
;		| -> NAME		| 	NAM		6 
;		-------------------------
;		|    LEN OF NAME	| 	NAML		10
;		-------------------------
;		| -> BUFFER		| O	BUF		12
;		-------------------------
;		|    LENGTH OF BUFFER	| O	BUFL		14
;		-------------------------
;		| -> RECORD		| O	REC		20
;		-------------------------
;		|    LEN OF RECORD	| O	RECL		22
;		-------------------------
;		|    LEN OF RECORD BUFF	| O	RECBL		22
;		-------------------------
;		| -> FAB		| O	FAB		26
;		-------------------------
;		| -> RAB		| O	RAB		30
;		-------------------------
;		|    OPTIONS		| 	OPT		32
;		-------------------------
;		|    INTERNAL		| 	INT1		34
;		-------------------------
;		|    INTERNAL		| 	INT2		36
;		-------------------------
;
;
;	NOTE THAT "I" FIELDS ARE REQUIRED ON INPUT
;		AND "O" FIELDS ARE SET ON OUTPUT
;		"*" FIELDS ARE SET BY PREVIOUS RMSOPN OR RMSGET ROUTINE
;
; CALL:
;	JSR	PC,RMSINIT
;
;
; BACK:
;	IF C=0 THEN OK ELSE RMS ERROR IN STS(R5) AND STV(R5)
;	NO REGISTERES CHANGED
;
;-




	.PSECT	RMSINIT,RO,CON



RMSINIT::NOP				;FOR DEBUGING
	SAVREG				;SAVE ALL REGISTERS
	CMP	ARGCNT(R5),#ARGSIZ	;ENOUGH ARGS?
	BLO	30$			;NO SO GET OUT
	$INITIF				;INIT RMS IF NEEDED


;
; CREATE OUR BUFFER POOL
;

RMSBUF=512.*2				;USE TWO 512. BYTE BUFFERS
	TST	BUF(R5)			;IS THE BUFFER ALREADY SET UP?
	BNE	20$			;YES SO WE WANT TO GET OUT
10$:	MOV	#14+RMSBUF+FB$BLN+RB$BLN+2,R1 ;2+1 BUFFER 1 FAB 1 RAB 1 VFC BFR
					;FIRST 12 BYTES USED AS BACKUP SPACE BY
					;THE CHARACTER HANDLER IN SPOOLER.  ;005
					;	 8 for tab expansion	;009
					;	+3 for <FF><space><CR>	;009
					;	+1 for safety		;009
	MOV	#ER$DME,STS(R5)		;PRESET FOR ERROR 'NO ROOM IN POOL'
	TST	BUF(R5)			;WAS USERS LITTLE BUFFER REAL?
	BNE	30$			;YES, TOO BAD ... WE DIE
	GETBUF	R0,R1,CLEAR		;GO GET THE BUFFER
	BCS	30$			;BR IF WE FAILED
	MOV	R0,BUF(R5)		;STORE ADDR OF BUFFER
	MOV	R1,BUFL(R5)		;AND LENGTH


;
; CARVE A FAB AND A RAB OUT OF BUFFER
;

	MOV	R0,RAB(R5)		;STORE RAB ADDR (START OF BUF=RAB)
	MOV	R0,R1			;GET RAB ADDR
	ADD	#RB$BLN,R1		;+LEN OF RAB=ADDR OF FAB
	MOV	R1,FAB(R5)		;STORE FAB ADDRES
					; R0 -> RAB, R1 -> FAB
	MOV	R0,R2			;GET FAB POINTER
	ADD	#FB$BLN+RB$BLN,R2	;POINT TO END OF FAB/RAB
	ADD	#2+2,R2			;LEAVE ROOM FOR A VFC AND BACKUP BUFFER 
	MOV	R2,REC(R5)		;AND STORE ADDR OF FREE SPACE	
	CLR	RECL(R5)		;SHOW NO DATA RETURNED YET
	MOV	#RMSBUF,RECBL(R5)	;AND STUFF THE SIZE OF THE BUFFER

;
; MAKE THEM LOOK LIKE FAB AND A RAB
;

	$STORE	#FB$BID,BID,R1		;FILL IN BID/BLN FIELDS IN FAB
	$STORE	#FB$BLN,BLN,R1
	$STORE	#RB$BID,BID,R0		;FILL IN BID/BLN FIELDS IN RAB
	$STORE	#RB$BLN,BLN,R0

;
; ALL DONE SO EXIT
;

20$:	MOV	FAB(R5),TOS.R1(SP)	;SET UP FAB POINTER
	MOV	RAB(R5),TOS.R0(SP)	;SET UP RAB POINTER
	TST	(PC)+			;CLEAR CARRY AND RETURN
30$:	SEC				;SET CARRY AND RETURN
	RETURN





.SBTTL	RMSOPN  - OPEN CODE FOR RMS-11 SIMPLE INTERFACE

;+
;
; RMSOPN
;
; THIS ROUTINE FIRST CALLS RMSINIT TO SET UP THE BUFFER POOLS AND
; INIT RMS. IF ENOUGH SPACE CAN NOT BE OBTAINED
; IT RETURNS THE RMS ERROR CODE FOR 'DYNAMIC MEMORY EXAUSTED' IN
; STS(R). THE FAB AND RAB ARE FILLED IN APPROPRIATLY AND
; AND RMS IS CALLED TO OPEN AND CONNECT TO THE FILE, ANY ERRORS
; ARE RETURNED TO THE USER AND THE BUFFER SPACE IS NOT RETURNED.
; THEN THE CARRAGE CONTROL TYPE IS DETERMINED AND SET INTO THE
; USER CONTEXT FIELD OF THE RAB. THE VFC PRN HEADER IS THEN CONDITIONALLY
; SET US AND WE ARE DONE.
;
; INPUT FIELDS
;	ARGCNT	 = # OF BYTES LONG ARGUMENT BLOCK IS (SANITY CHECK)
;	NAM	-> ASCII STRING OF FILE NAME TO OPEN
;	NAML	 = LENGTH OF NAME IN BYTES
;	OPT	   ENABLE BLOCK IO IF BLKIO SET
;
; OUTPUT FIELDS
;	STS	 = CONTENTS OF RMS STS FIELD AFTER AN RMS OPERATION >=0 SUCCES
;	STV	 = CONTENTS OF RMS STV FIELD AFTER AN RMS OPERATION
;	BUF	-> BUFFER RETURNED FROM 'GETBUF'
;	BUFL	 = LEN OF BUFFER
;	REC	-> DATE RECORD TO BE RETURNED
;	RECL	 = LENGTH OF DATA RECORD
;	RECBL	 = LENGTH OF DATA RECORD BUFFER
;	FAB	-> FAB
;	RAB	-> RAB
;	INT1	   FOR INTERNAL USE ONLY
;	INT2	   FOR INTERNAL USE ONLY
;

;
;
;
;		-------------------------
;  	R5 ->	|    #OF ARGS 		| I	ARGCNT		0 
;		-------------------------
;		|    STATUS		| O	STS		2 
;		-------------------------
;		|    STATUS1		| O	STV		4 
;		-------------------------
;		| -> NAME		| I	NAM		6 
;		-------------------------
;		|    LEN OF NAME	| I	NAML		10
;		-------------------------
;		| -> BUFFER		| O	BUF		12
;		-------------------------
;		|    LENGTH OF BUFFER	| O	BUFL		14
;		-------------------------
;		| -> RECORD		| O	REC		20
;		-------------------------
;		|    LEN OF RECORD	| O	RECL		22
;		-------------------------
;		|    LEN OF RECORD BUFF	| O	RECBL		22
;		-------------------------
;		| -> FAB		| O	FAB		26
;		-------------------------
;		| -> RAB		| O	RAB		30
;		-------------------------
;		|    OPTIONS		| I	OPT		32
;		-------------------------
;		|    INTERNAL		| 	INT1		34
;		-------------------------
;		|    INTERNAL		| 	INT2		36
;		-------------------------
;
;
;	NOTE THAT "I" FIELDS ARE REQUIRED ON INPUT
;		AND "O" FIELDS ARE SET ON OUTPUT
;		"*" FIELDS ARE SET BY PREVIOUS RMSOPN OR RMSGET ROUTINE
;
; CALL:
;	JSR	PC,RMSOPN
;
;
; BACK:
;	IF C=0 THEN OK ELSE RMS ERROR IN STS(R5) AND STV(R5)
;	NO REGISTERES CHANGED
;
;-




	.PSECT	RMSOPN,RO,CON

RMSOPN::NOP				;FOR DEBUGING
	SAVREG				;SAVE ALL REGISTERS


;
; CREATE BUFFER POOL IF NECESSARY
; AND CREATE AND PARTIALLY INIT FAB AND RAB
; AND $INITIF RMS
;

	CALLX	RMSINIT			;GO SET UP THE BUFFERS
	BCS	10$			;RETURN ERRORS TO USER

;
; FINISH OFF THE FAB
;

	$STORE	#FB$GET,FAC,R1		;ALLOW GET'S
	
	MOV 	#FNAM,R4		;GET ADDR OF FILESPEC BUFFER.
	MOV	NAM(R5),R2		;GET ADDR OF FILESPEC
	MOV	NAML(R5),R3		;GET LEN  OF FILESPEC
7$:	MOVB	(R2)+,(R4)+		;COPY FILESPEC TO BUFFER
	SOB	R3,7$			;
	
	MOV	#MO4096,R2		;GET ADDR OF MODE SWITCH
	MOV	#ML4096,R3		;GET LEN  OF MODE SWITCH
9$:	MOVB	(R2)+,(R4)+		;COPY SWITCH TO FILESPEC
	SOB	R3,9$			;

	MOV	#ML4096,R3		;GET LEN  OF MODE SWITCH
	ADD	NAML(R5),R3		;ADD TO LEN OF FILE SPEC
	
	$STORE	#FNAM,FNA,R1		;SET POINTER TO FILENAME
	$STORE	R3,FNS,R1		;SET FILENAME LENGTH IN FAB
	$STORE	#DEFNAM,DNA,R1		;SET IN DEFAULT NAME (SY:.LST)
	$STORE	#DNAMSZ,DNS,R1		;AND SIZE
	$STORE	#FB$NEF,FOP,R1		;DO THE RIGHT THING FOR MT:
	$STORE	#0,SHR,R1		;ASSUME NO WRITE SHARING
	GETLUN	R4			;GET CHANNEL *2
	BCC	20$			;BR IF ALL OK
	MOV	#ER$LBY,STS(R5)		;SHOW ERR OR LOGICAL CHANNEL BUSY
10$:	JMP	130$			;AND EXIT CARRY SET

20$:	ASR	R4			;MAKE THAT *1
	$STORE	R4,LCH,R1		;LOGICAL CHANNEL		

;
; FINISH OFF THE RAB
;
	$STORE	R1,FAB,R0		;STORE POINTER TO FAB IN THE RAB
	$STORE	REC(R5),UBF,R0		;POINTER TO TARGET RECORD BUFFER
	$STORE	#RMSBUF,USZ,R0		;SIZE OF TARGET RECORD BUFFER
	$STORE	#RB$SEQ,RAC,R0		;SEQUENTIAL ACCESS
	$STORE	#RB$LOC,ROP,R0		;USE LOCATE MODE
	$STORE	#0,MBC,R0		;USE 1 INPUT BUFFERS
	$STORE	#0,RHB,R0		;NO VFC HEADER BY DEFAULT



;
; NOW FINALLY OPEN THE FILE
;

	BIT	#BLKIO,OPT(R5)		;ENABLE BLOCK IO?
	BEQ	30$			;NOPE, USE RECORD IO
..BIO==.			; PATCH TO NOP TO DISABLE BLOCK IO
	$SET	#FB$BIO,FAC,R1		;YES, ENABLE BLOCK IO
30$:	$OPEN	 R1			;OPEN THE FILE
	$STORE	NAM(R5),FNA,R1		;RESTORE ORG FILE SPEC ( W/O MO:4096 )
	$STORE	NAML(R5),FNS,R1		;RESTORE ORG FILE SPEC LENGTH
	$FETCH	STV(R5),STV,R1		;GET SECONDARY STATUS
	$FETCH	STS(R5),STS,R1		;CHECK/STORE STATUS CODE
	BLT	10$			;BLT	130$ (10$ is a JMP 130$) ;010

	$COMPARE #FB$STM,RFM,R1		;IS FILE STREAM?
	BNE	50$			;NO, SO CAN'T USE BIO
	$TESTBITS #FB$FTN,RAT,R1	;DOES FILE USE FORTRAN CR CONTROL? ;009
	BNE	50$			;YES, SO CAN'T USE BLOCK IO
	$COMPARE #FB$SEQ,ORG,R1		;IS FILE SEQ?
	BNE	50$			;No, so can't use block I/O	;010
	$TESTBITS #FB$CR,RAT,R1		;Is it CC:IMP carriage control?	;010
	BEQ	60$			;No, so all's well		;010
	CALLX	CLRFQB			;Hmmm.  RMS-11 may be fooling us ;010
	MOVB	#UU.ATR,@#FIRQB+FQFUN	;So let's look up the attributes ;010
	MOVB	R4,@#FIRQB+FQFIL	;Channel * 1 still in R4	;010
	.UUO				;Get the attributes		;010
	TST	@#FIRQB+FQPPN		;Does it really have them?	;010
	BEQ	55$			;Nope.  How 'bout that?		;010
50$:	$TESTBITS #FB$BIO,FAC,R1	;Were we trying block I/O?	;010
	BEQ	60$			;No, don't have to re-open file	;010
	$CLOSE	R1			;CLOSE FILE BACK DOWN
	$OFF	#FB$BIO,FAC,R1		;AND SET FOR RECORD ACCESS MODE
	BR	30$			;AND GO RE-OPEN

55$:	$OFF	#FB$CR,RAT,R1		;Looks like CC:NONE to us	;010
60$:	MOV	#1,O$BKT(R0)		;SET FOR FIRST READ OF BLOCK 1
	CLR	O$BKT+2(R0)		; HIGH BLOCK ZERO
	$COMPARE #FB$SEQ,ORG,R1		;IS FILE SEQUENTIAL?
	BNE	70$			;BR IF NO
	$STORE	#2,MBC,R0		;USE 2 INPUT BUFFERS
	CLRB	O$BKS(R1)		;IS SEQ CHANGE BKS FROM -1 TO 0
70$:	MOV	#ER$RTB,STS(R5)		;PRESET ERROR OF RECORD TOO BIG
	CMPB 	O$BKS(R1),#4		;IS BUCKET SIZE >4 ?
..MBKT==.-2			;** PATCH FOR MAX LEGAL BUCKET SIZE
	BHI	130$			;YES, SO ERR, CUZ TOO MUCH BUFFER
					;SPACE USED FOR IT, TOUGH LUCK CHARLY
	$CONNECT R0			;CONNECT TO DATA STREAM
	$FETCH	STV(R5),STV,R0		;GET SECONDARY STATUS
	$FETCH	STS(R5),STS,R0		;CHECK/STORE STATUS CODE
	BMI	130$			;IF ERROR THE GO BACK


;
; DETERMIN/SET UP FOR VARIOUS CARRAGE CONTROL TYPES
;
	CLR	R4			;ASSUME NO CC 
	$TESTBITS #FB$BIO,FAC,R1	;ARE WE DOING BLOCK IO?
	BNE	110$			;YES, SO USE NO CC
	TST	O$RAT(R1)		;Any attributes?		 ;007
	BNE	80$			;Yes, we can't be stream CC	 ;007
	$COMPARE #FB$STM,RFM,R1		;IS IT A STREAM FILE?
	BNE	80$			;NOPE
	MOV	#1*2,R4			;YES FLAG AS SUCH
	BR	110$			; DONE SO CLC AND RETURN

80$:	$FETCH	R2,RAT,R1		;GET RECORD ATTS
	MOV	#CCTBL,R3		;GET POINTER TO TABLE
90$:	ROR	R2			;IS THIS BIT SET?
	BCC	100$			;NOPE
	MOVB	(R3),R4			;FLAG AS THIS TYPE
100$:	INC	R3			;SKIP TO NEXT
	TSTB	(R3)			;AT END OF LIST?
	BNE	90$			;KEEP TRYING

110$:	$STORE	R4,CTX,R0		;SAVE CC TYPE IN CTX OF RAB
	$COMPARE #FB$PRN,RAT,R1		;IS THIS A PRN FILE?
	BNE	120$			;NO SO SKIP ON
	$COMPARE #2,FSZ,R1		;IS THERE A 2 BYTE HEADER (PRN)
	BNE	120$			;NO SO IGNORE IT
	MOV	REC(R5),R2		;GET POINTER TO END OF VFC AREA
	SUB	#4,R2			;NOW POINTER TO BEGINING
	$STORE	R2,RHB,R0		;USE THAT FOR FIX AREA
	.BR	120$

120$:	TST	(PC)+			;CLEAR CARRY OR
130$:	SEC				;SET CARRY AND EXIT
	RETURN				;THATS ALL FOR NOW

CCTBL:	.BYTE	2*2,3*2,4*2,0
	.EVEN
	.ASSUME	FB$FTN EQ 1
	.ASSUME	FB$CR  EQ 2
	.ASSUME	FB$PRN EQ 4

DEFNAM:	.ASCII	/SY:/			;DEFAULT NAME
					DNAMSZ=.-DEFNAM

MO4096:	.ASCII	%/MO:4096%		;MODE FOR READ REGARDLESS
					ML4096=.-MO4096
	.EVEN

FNAM:	.BLKB	40.			;BUFFER FOR FILESPEC

	.EVEN





	.END
