.INCLUDE	%CMN:COMMON%
.INCLUDE	%CMN:KERNEL%
TITLE	SKDINI,<INIT ROUTINES FOR MULTI-FUNCTION JOB>,0A,10-MAY-91,SJM/PRL/KCG

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR SKDINI
;+
;
;  001  SJM  23-Sep-82	CREATION - And it was a good thing
;  002	PRL  16-Jan-82	Save SPL's job number (for later kill)
;
;  ---	KCG  27-Oct-83	Creation of 9.0 from 8.0-06
;  003	KCG  27-Oct-83	Change of CIS routine to read config word from system
;  004	KCG  28-Oct-83	Add user selectable global symbols and validation rtne.
;  005	KCG  30-Oct-83	Add job allocation/starter routine.
;  006	KCG  28-Mar-84	Add legal privilege mask initializer.
;  007	KCG  26-Apr-84	Add .INCLUDEs and fix JOBNUM initializer
;  008	PRL  22-May-84	Renamed SKDCON macro to PBSCON
;  009	KCG  01-Oct-84	Add DEVICE privilege to DEFPRV
;  010	KCG  28-Oct-84	Add support for new rib list to SKDCRA
;  011	PRL  30-Oct-84	Change symbol QT$MNM -> QT$BAD
;  012	DBM  16-Aug-89	Fix reference to QT$BAD
;
;-

.LIBRARY	%SYSTEM:PBSMAC%
.LIBRARY	%LB:RMSMAC%

.SBTTL	MACROS	- DEFINE ALL NEEDED MACROS

	.PSECT

	.MCALL	SKDJDB,SKDSTA,RIBDEF,PBSCON
	.MCALL	SPLCMD,QUEDEF,PSECTS,BITDEF,SAVREG
	.MCALL	FQBERR,CR$LF,MOVSTR
	.MCALL	SUBRIB,GETLUN,RETLUN,GETBUF,RETBUF
	.MCALL	GETDEV,RETDEV

	SKDJDB
	SKDSTA
	RIBDEF
	PBSCON
	SPLCMD
	QUEDEF
	PSECTS
	BITDEF
	CR$LF

.SBTTL	INITSYS	- INIT ROOT

;+
;
; INITSYS
;
; THIS ROUTINE IS THE ROOT ROUTINE TO:
;	- DEASSIGN ALL LUNS (CHANNELS), DEVICES, AND RIBS
;	- CHECK TO SEE IS CIS IS PRESENT
;	- VALIDATE THE USER SELECTABLE VALUES
;	- ALLOCATE THE REQUIRED NUMBER OF JOBS OF EACH TYPE
;
;-
	.PSECT	INIT

INISYS::SAVREG
	CALL	DASSAL
	CALL	CHKCIS
	CALL	VALUSR
	CALL	ALOJOB
	CALL	DEFPRV
	RETURN

.SBTTL	DASSAL	- DEASSIGN ALL DEVICES,RIBS AND RESET ALL CHANNELS


;+
; DASSAL
; THIS ROUTINE DOES THE FOLLOWING :
;	A) DETERMINES IF CIS IS PRESENT
;	B) RESETS ALL RSTS/E CHANNELS EXCEPT 15
;	   WHICH IS USED BY RSTS/E FOR OVERLAYS.
; 	C) REMOVES ALL RECEIVER ID'S FOR THIS JOB
; 	   INCLUDING MULTIPLE RIBS.
; 	D) DEASSIGNS ALL DEVICES AND REMOVES ALL USER LOGICALS.
; THIS ROUTINE IS PART OF THE INIT WORLD FUNCTION
; FOR THE MULTI-FUNCTION JOB.  AND SET UP PROGRAM NAME.
;
; INPUTS:  NONE
; 
; CALL DASSAL
;
; OUTPUT : NONE
;
;	NO REGISTERS AFFECTED
;
;	CARRY CLEAR IF SUCCESS
;
;	CARRY SET IF FAILURE
;
;	
;
;-

DASSAL:	NOP			;FOR DEBUGING
	CALLX	CLRXRB		;CLEAR XRB
	MOV	#518.,@#XRB+0	;LOAD MONITOR WORK TO READ
	.PEEK			;RETURNS OUR JOB NO. TIMES 2
	MOV	@#XRB+0,R0	;SAVE JOB NO. TIMES 2
	ASR	R0		;NOW ITS THE REAL THING
	MOVB	R0,JOBNUM	;AND SAVE IT FOR SHUTTING DOWN
	CALLX	CLRFQB		;CLEAR FIRQB
	MOVB	#RSTFQ,@#FIRQB+FQFUN ;RESET CHANNEL FUNCTION CODE
	MOVB	#-15.*2.,@#FIRQB+FQFIL ;RESET ALL BUT LUN 15 (OVERLAY LUN)
	CALFIP			;DO IT
	FQBERR	20$		;CHECK FOR ERRORS
	MOV	#LUNTBL,R0	;ADDRESS OF LUNTABLE
	MOV	#16./2,R1	;LENGTH OF LUNTABLE IN WORDS
10$:	CLR	(R0)+		;CLEAR OUT THE LUNTABLE
	SOB	R1,10$		;DO THE WHOLE THING
	MOVB	#-1,LUN0	;MARK LUN 0 AS ALLOCATED
	MOVB	#-1,LUN15	;MARK LUN 15 AS ALLOCATED

	CALLX	CLRFQX		;CLEAR FIRQB
	MOVB	#-1,@#FIRQB+FQDEVN+1 ;REMOVE ALL RIBS
	.MESAG			;DO IT
..NMRM==.-2		; ** PATCH TO NOP TO DISABLE RIB REMOVAL
	FQBERR	20$		;CHECK FOR ERRORS

	CALLX	CLRFQX		;CLEAR FIRQB
	MOVB	#UU.DAL,@#FIRQB+FQFUN ;DEASSIGN ALL DEVICES & LOGICALS
	.ULOG
	FQBERR	20$		;CHECK FOR ERRORS
	TST	(PC)+		;CLEAR CARRY AND RETURN
20$:	SEC			;SET CARRY AND RETURN
	RETURN

	GLOBAL	<LUNTBL,LUN0,LUN15,JOBNUM>


.SBTTL	CHKCIS	- SEE IF CIS IS PRESENT


;+
; CHKCIS
;
; THIS ROUTINE LOOKS FOR CIS BY TESTING IF THE CIS BIT IS SET IN THE SYSTEM
; CONFIGURATION WORD.
;
;
; INPUTS:
;
;	NONE
;
; CALL	CHKCIS
;
; OUTPUTS:
;
;		CIS:	=  0 IF NO CIS
;			= -1 IF CIS
;
;	REGISTERS PRESERVED
;
;-

	.ENABL	LSB

CHKCIS:	CLR	CIS			;ASSUME NO CIS
	CALLX	CLRFQB			;CLEAR THE FIRQB
	MOVB	#UU.TB3,@#FIRQB+FQFUN	;SET THE FUNCTION
	.UUO				;GET MONITOR TABLES III
	BIT	#XC$CIS,@#FIRQB+FQPFLG	;IS THERE CIS ON THIS MACHINE?
	BEQ	10$			;NO
	MOV	SP,CIS			;YES
10$:	CLC
	RETURN

GLOBAL	<CIS>

	.DSABL	LSB

.SBTTL	VALUSR	- VALIDATE THE USER SELECTABLE FEATURES

;+
;
; VALUSR:
;
; SETS AND VALIDATES TABLE VALUES ( ...PRT, ...BAT ) FROM USER SELECTABLE 
; SYMBOLS.  ALSO VALIDATES ..IDLE TIME, ...JOB, AND .SPLER.
;
; THE FOLLOWING RANGES ARE USED TO VALIDATE THE TABLE VARIABLES:
;
;					0 < ...PRT < 4
;					0 < ...BAT < 5
;
;		IF EITHER OF THE VALUES ARE GREATER THAN THE ABSOLUTE MAXIMUM, 
;		THE VALUE IS SET TO THE ABSOLUTE MAXIMUM VALUE ( 3 FOR PRINT, 4
;		FOR BATCH).  IF EITHER OF THE VALUES ARE LESS THAN OR EQUAL TO 
;		0, THEN THE VALUE IS SET TO 1.
;
;			NOTE: IF ZERO IS REQUESTED IN ..PPRT OR ..PBAT ( OR 
;			      ZERO FOR BOTH ), THAT VALUE WILL BE HONORED IN 
;			      THE ALOJOB ROUTINE.
;
; THE RANGES FOR ..IDLE, ...JOB, AND .SPLER ARE:
;
;				2 MINUTES <= ..IDLE <= 24 HOURS
;
;				0 < ...JOB < 64
;
;				0 < .SPLER < 8
;
; INPUTS
;
;	NONE
;
; OUTPUTS
;
;	VALIDATED ..PPRT, ..PBAT, ..SPRT, ..SBAT, ...PRT, ...BAT, ..IDLE,
;	...JOB, AND .SPLER.
;
;-

	.ENABL	LSB

VALUSR:	NOP			;FOR DEBUGGING
	MOV	#MINTBL,R0	;VERIFY MINIMUM VALUES
	MOV	#PATFTR,R1	;STARTING ADDR OF USER PATCHABLE FEATURES TABLE
	MOV	#PATFLN,R2	;LENGTH OF PATCHABLE FEATURES TABLE
1$:	CMP	(R0)+,(R1)+	;IS THIS VALUE AT LEAST THE MINIMUM?
	BLE	2$		;YES, TRY NEXT VALUE
	MOV	-2(R0),-2(R1)	;NO, MAKE IT THE MINIMUM
2$:	SOB	R2,1$		;TEST ALL VALUES IN TABLE
	MOV	#MAXTBL,R0	;VERIFY MAXIMUM VALUES
	MOV	#PATFTR,R1	;STARTING ADDR OF USER PATCHABLE FEATURES TABLE
	MOV	#PATFLN,R2	;LENGTH OF PATCHABLE FEATURES TABLE
3$:	CMP	(R0)+,(R1)+	;IS THIS VALUE OVER THE MAXIMUM?
	BGE	4$		;NO, TRY NEXT VALUE
	MOV	-2(R0),-2(R1)	;YES, MAKE IT THE MAXIMUM
4$:	SOB	R2,3$		;TEST ALL VALUES IN TABLE
	MOV	..SPRT,...PRT	;FIND MAX VALUES FOR SPLERS, ASSUME SECONDARY >
	CMP	..PPRT,...PRT	;IS PRIMARY LARGER THAN SECONDARY?
	BLT	10$		;NO, KEEP SECONDARY
	MOV	..PPRT,...PRT	;YES, SET THE LARGER VALUE
10$:	MOV	..SBAT,...BAT	;ASSUME SECONDARY IS >
	CMP	..PBAT,...BAT	;IS PRIMARY LARGER THAN SECONDARY?
	BLT	20$		;NO, KEEP SECONDARY
	MOV	..PBAT,...BAT	;YES, SET THE LARGER VALUE
20$:	CLR	R2		;CLEAR ACCUMULATOR FOR COUNTING MAX SPLERS/JOB
	MOV	#..SPTB,R3	;R3 -> MAX SPLER/TYPE TABLE
	MOV	#QT$BAD,R4	;R4 = length of max spler type table	;012
110$:	ADD	(R3)+,R2	;ADD UP THE MAX NUMBER OF SPLERS
	SOB	R4,110$		;  TILL ALL TYPES ADDED
	TST	R2		; 0 < .SPLER < 8
	BGT	120$		;  DEFAULT = 7
	MOV	#1.,R2		;  MAXIMUM = 7
	BR	130$		;  MINIMUM = 1
120$:	CMP	R2,#8.		;
	BLT	130$		;
	MOV	#7.,R2		;
130$:	MOV	R2,.SPLER	;  STORE THE CORRECT VALUE

	RETURN

	GLOBAL	<JOBFLG,..PPRT,..PBAT,..SPRT,..SBAT,..SPTB,PATFTR,PATFLN>
								;GLOBAL INPUTS
	GLOBAL	<...PRT,...BAT,.SPLER>				;GLOBAL OUTPUTS

	.DSABL	LSB

.SBTTL	VALUSR	- MAX MIN TABLES

	.SAVE
	.PSECT	PURE

MINTBL:	.WORD	0		;..PPRT
	.WORD	0		;..PBAT
	.WORD	1		;..SPRT
	.WORD	1		;..SBAT

;	.ASSUME	<.-MINTBL> EQ PATFLN

MAXTBL:	.WORD	2		;..PPRT
	.WORD	3		;..PBAT
	.WORD	3		;..SPRT
	.WORD	4		;..SBAT

;	.ASSUME	<.-MINTBL> EQ PATFLN

;	GLOBAL	<PATFLN>

	.RESTORE

.SBTTL	ALOJOB	- ALLOCATE SPOOLER SUB-JOBS TO THIS JOB

;+
;
; ALOJOB:
;
; THIS ROUTINE MARKS THE REQUESTED AMOUNT OF SPOOLERS FOR THIS JOB AS 
; STARTED.  IF THE USER REALLY WANTED ZERO PRINT OR BATCH PROCESSORS IN
; THE PRIMARY JOB, THE REQUEST IS SATISFIED HERE.
;
; INPUT
;
;	NONE
;
; OUTPUT
;
;	THE JDB TABLE WILL CORRECTLY REFLECT THE NUMBER OF SPOOLERS TO 
;	RUN.
;-

	.ENABL	LSB

ALOJOB:	NOP
	MOV	..SPRT,R0		;SET NUMBER OF PRT SPLERS TO START
	MOV	..SBAT,R2		;SET NUMBER OF BAT SPLERS TO START
	TST	JOBFLG			;IS THIS THE PRIMARY JOB?
	BNE	10$			;NO
	MOV	..PPRT,R0		;SET NUM OF PRIMARY PRT SPLERS TO START
	MOV	..PBAT,R2		;SET NUM OF PRIMARY BAT SPLERS TO START
	MOV	#QMNJDB,R1		;YES, GET QMAN'S JDB
	BIC	#NORUN,(R1)		;MARK IT STARTED
	MOV	#MSGJDB,R1		;GET MSGSER'S JDB
	BIC	#NORUN,(R1)		;MARK IT STARTED
10$:	TST	R0			;TEST THE NUMBER OF PRINT SPLERS TO ST
	BEQ	30$			;SKIP IF ZERO
	MOV	#PRTJDB,R1		;GET START OF PRINT SPOOLER JDB LIST
20$:	BIC	#NORUN,(R1)		;TURN OFF THE NORUN BIT
	ADD	#JDBSIZ,R1		;SET R1 TO POINT TO NEXT
	SOB	R0,20$			;AND DO THE NEXT ONE
30$:	TST	R2			;TEST THE NUMBER OF BATCH SPLER TO ST
	BEQ	50$			;SKIP IF ZERO
	MOV	#BATJDB,R1		;GET START OF BATCH SPOOLER JDB LIST
40$:	BIC	#NORUN,(R1)		;TURN OFF THE NORUN BIT
	ADD	#JDBSIZ,R1		;SET R1 TO POINT TO THE NEXT JDB
	SOB	R2,40$			;AND DO THE NEXT ONE , TILL DONE

50$:	RETURN

	GLOBAL	<JOBFLG,QMNJDB,MSGJDB,PRTJDB,BATJDB>
	GLOBAL	<..PPRT,..PBAT,..SPRT,..SBAT,...PRT,...BAT>

	.DSABLE LSB

.SBTTL	DEFPRV	- INITIALIZE LEGAL PRIVS MASK

;+
;
; DEFPRV:
;
;	SETS PRIV MASK IN SKED TO BE USED TO DETERMINE
;	IF MESSAGE RECEIVED IS LEGAL OR NOT.
;
; INPUTS:
;
;		NONE
;
; CALL:
;
;	JSR	PC,DEFPRV
;
; BACK:
;
;	ALL REGS PRESERVED
;
;-

	.ENABL	LSB

DEFPRV:	NOP
	SAVREG
	MOV	#PBSPRV,R0		;R0 -> OUR PRIV MASK LOCATION
	MOV	#PRVSIZ,R1		;R1 = SIZE IN WORDS OF MASK
10$:	CLR	(R0)+			;CLEAR MASK INITIALLY
	SOB	R1,10$			;ALL CELLS
	MOV	#PRVTXT,R0		;R0 -> PRIV TEXT TABLE
	MOV	#PRVELN,R2		;R2 = LENGTH OF ENTRY IN TABLE
	MOV	#PRVTLN,R3		;R3 = NUMBER OF ENTRIES IN TABLE
20$:	MOV	#<PRVSIZ*2>,R5		;R5 = NUMBER OF BYTES POSSIBLE IN MASK
	MOV	#FIRQB+FQNAM1,R1	;R1 -> FIRQB LOC TO PUT STR AND GET BIT
	CALLX	CLRFQB			;CLEAR THE FIRQB
	MOVB	#UU.CHK,@#FIRQB+FQFUN	;SET THE CHECK ACCESS FUNCTION
	MOVB	#1,@#FIRQB+FQFIL	;SET THE CONVERT PRIV NAME TO MASK FUN
	MOVSTR	R0,R1,R2		;MOVE THE NAME ( NULL PADDED ) 
	.UUO				;AND MAKE THE CALL
	TST	@#FIRQB			;ERRORS
	BNE	40$			;YES, PROBABLY MEANS BIT NOT YET DEFED
	MOV	#PBSPRV,R4		;R4 -> OUR PRIV MASK LOCATION
30$:	BISB	(R1)+,(R4)+		;SET IN THE BIT FOUND
	SOB	R5,30$			;FOR ALL POSSIBLE LOCATIONS
40$:	ADD	R2,R0			;R0 -> THE NEXT PRIVILEGE
	SOB	R3,20$			;FOR ALL TABLE ENTRIES
	CLC
	RETURN

	GLOBAL	<PBSPRV>

	.DSABL	LSB

.SBTTL	DEFPRV	- PRIVILEGE NAME TEXT TABLE

;
; EACH ENTRY IS 6 BYTES LONG
;

	.SAVE

	.PSECT	PURE

	.EVEN

PRVTXT:	.ASCII	%PBSCTL%

	PRVELN	=	<.-PRVTXT>		;LENGTH OF ONE ENTRY

	.ASCII	%SEND%<CR$NUL><CR$NUL>
	.ASCII	%SWCFG%<CR$NUL>
	.ASCII	%TUNE%<CR$NUL><CR$NUL>
	.ASCII	%WACNT%<CR$NUL>
	.ASCII	%WREAD%<CR$NUL>
	.ASCII	%WWRITE%
	.ASCII	%DEVICE%

	PRVTLN 	=	<<.-PRVTXT>/PRVELN>	;NUMBER OF ENTRIES IN TABLE

	.RESTORE

.SBTTL	SKDCRA	- CRASH A JOB (NEVER TO BE RUN AGAIN)

;+
; SKDCRA
;
;	This routine marks a job as crashed
;
; INPUTS:
;
;	R5 = sub-job number*2
;
; CALL:
;
;	JSR	PC,SKDCRA
;
; BACK:
;
;	REGISTERS TRASHED
;
;-

	.MCALL	RETDAL
	.ENABL	LSB

SKDCRA::NOP			;for debuging
	MOV	R5,R0		;get copy of sub job number*2
	ASR	R0		;make it sub job number*1
	CALLX	GETJDB		;get pointer to jobs jdb
	BIS	#NORUN,JDBSTA(R5) ;mark job as crashed
	MOV	#RIBLST,R3	;R3 -> rib data struct list pointer
10$:	MOV	R3,R4		;R4 -> previous rib data structure
	MOV	(R3),R3		;R3 -> next rib data structure
	BEQ	30$		;If we're all done
20$:	CMPB	RIB.SJ(R3),R0	;Does this rib belong to sub job?
	BNE	10$		;No, try the next one
	MOV	(R3),(R4)	;Yes, delink the data structure
	CALL	CLRFQX		;Clear the Firqb and Xrb
	MOVB	RIB.SR(R3),@#FIRQB+FQDEVN	;Set the rib num to remove
	.MESAG			;Get rid of it ( if it is still there )
	MOV	RIB.LN(R3),R1	;move len to return to R1
	PUSH	R2
	MOV	R3,R2		;get copy of data structure pointer
	MOV	(R3),R3		;set pointer to next
	RETBUF	R2,R1		;return the data structure
	POP	R2
	TST	R3		;Are we through the list yet?
	BEQ	30$		;yes, no need to test anymore
	BR	20$		;try for another rib

30$:	MOV	#16.,R0		;set R0 to max number of luns
40$:	RETLUN	R0		;return it (nop if it was not ours)
	SOB	R0,40$		;return all of sub jobs luns (ignore errors)
	RETDAL			;and deallocate it too
	CALLRX	NXTJOB		;and were off for the next guy (gal?)

	GLOBAL	<RIBLST>
	.DSABL	LSB

	.END
