TITLE	PRTHIS,<PC HISTOGRAM GENERATOR>,0C,19-JUL-91,MHB/TG/FEK/KPH

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR PRTHIS
;+
;
;  000  RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;  001	TG   01-Jan-81	Created from HISTOG
;  002	FEK  06-MAR-84	BEGIN ADDING SUPPORT FOR V9
;  003	KPH  25-Mar-84	New dump file format
;  004	KPH  10-Jul-84	Add RSX phase
;  005	KPH  16-Oct-84	Add MVR phase
;
;			[RSTS/E V9.3]
;  006  KPH  06-Jun-86	Add new phases
;
;			[RSTS/E V10.1]
;  007	FEK  07-Jul-91	Add V9.6 and later phases
;
;-


	.MCALL	..V2.., .CSIGEN, .READW, .WRITW, .CLOSE, .PRINT, .EXIT
	.MCALL	.LOOKUP, .SETTOP

	..V2..

;
;	ORDER THE PSECTS
;

	DEFORG	PRTHIS
	DEFORG	PRTSUB
	DEFORG	PRTTXT
	DEFORG	PRTDAT
	ORG	.99ODT		;FOR ODT				;003
	ORG	.99999		;FOR ODT				;003
	DEFORG	PRTBUF		;* NOTE THIS PSECT MUST BE LAST FOR .SETTOP *


	.ENABL	LC
	.NLIST	BEX

;
;	Handy Definitions
;

SYSPTR	=	54		;POINTER TO R/W AREA
PHZCNT	=	34.		;CURRENT NUMBER OF PHASES		;005
LINLEN	=	132.-40.	;MAX LINE LENGTH
OUTLEN	=	512.		;OUTPUT BUFFER LENGTH
ADRLEN	=	12.*512.	;MAX ALLOWED SIZE OF ADDRESS FILE IN BYTES ;003
PHZLEN	=	2000		;Number of dump file "addresses" per phase ;003
DMPSIZ	=	PHZLEN*PHZCNT	;Number of "addresses" in dump file	;003
BUFLEN	=	64.*<512.+2>	;Size of dump file cache		;003
STATES	=	6		;Number of FIP states			;003
FIPOVR	=	PHZCNT+1	;"Phase number" for OVR phase		;004
FIPFUN	=	FIPOVR+1	;"Phase number" for FIP functions	;004
FIPADR	=	2*100		;Number of "addresses" in FIP area	;003

ADR.00	=	 0*100		;PC START OF 0				;003
ADR.12	=	12*100		;PC START OF 120000 (APR5)		;003
ADR.14	=	14*100		;PC START OF 140000 (APR6)		;003
ADR.FP	=	16*100		;PC START OF 160000 (FIP tables)	;003

.GETCOR	=	EMT+366		;EXPAND JOB SIZE CALL TO RT EMULATOR
.PRIV	=	EMT+377		;ESCAPE EMT FOR RT11

.MACRO	PHZTXT	PHAZ
.IRP	PHZ,<PHAZ>
'PHZ'HDR:	.ASCIZ	<15><12><14>"'PHZ' phase"<15><12><15><12>	;006
.ENDR
.ENDM	PHZTXT

;
;	Define some text
;

	ORG	PRTTXT

	.NLIST	BEX
HEADER:	.ASCII	<15><12>"           RSTS/E V10.1 PC Histogram Dump with a " ;007
	.ASCIZ	"divisor of "
RSTHDR:	.ASCIZ	""
	PHZTXT	<GEN,EMT,EM2,FIP,KBD,DSK,FMS,SES,NSP,TRN,XVR,MCP,BBR>	;007
	PHZTXT	<OPN,RSX,MVR,KVR,RDM,EVL,UNA,QNA,DMP,NOD,GRD,KIN>	;007
	PHZTXT	<PKPORT,DLPORT,DHPORT,DZPORT,VHPORT,TERCLS,LAT>		;007
OTHHDR:	.ASCIZ	<15><12><14>"OTHER phases"<15><12><15><12>

FIPFN1:	.ASCIZ	<15><12><14>"FIP mode function usage (running)"<15><12><15><12> ;003
FIPFN2:	.ASCIZ	<15><12><14>"FIP mode function usage (OVRBUF wait)"<15><12><15><12> ;003
FIPFN3:	.ASCIZ	<15><12><14>"FIP mode function usage (FIBUF wait)"<15><12><15><12> ;003
FIPFN4:	.ASCIZ	<15><12><14>"FIP mode function usage (SATBUF wait)"<15><12><15><12> ;003
FIPFN5:	.ASCIZ	<15><12><14>"FIP mode function usage (Other wait)"<15><12><15><12> ;003
FIPFN6:	.ASCIZ	<15><12><14>"FIP mode function usage (Queue depth)"<15><12><15><12> ;003

FIPOV1:	.ASCIZ	<15><12><14>"FIP mode overlay usage (running)"<15><12><15><12> ;003
FIPOV2:	.ASCIZ	<15><12><14>"FIP mode overlay usage (OVRBUF wait)"<15><12><15><12> ;003
FIPOV3:	.ASCIZ	<15><12><14>"FIP mode overlay usage (FIBUF wait)"<15><12><15><12> ;003
FIPOV4:	.ASCIZ	<15><12><14>"FIP mode overlay usage (SATBUF wait)"<15><12><15><12> ;003
FIPOV5:	.ASCIZ	<15><12><14>"FIP mode overlay usage (Other wait)"<15><12><15><12> ;003
FIPOV6:	.ASCIZ	<15><12><14>"FIP mode overlay usage (Queue depth)"<15><12><15><12> ;003

OPNERR:	.ASCIZ	<15><12>"?File open error"
REDERR:	.ASCIZ	<15><12>"?File read error"
CLSERR:	.ASCIZ	<15><12>"?File close error"
WRTERR:	.ASCIZ	<15><12>"?File write error"
ZERERR:	.ASCIZ	<15><12>"?Null sample ?? - No histogram will be generated"
CORERR:	.ASCIZ	<15><12>"?Program too big - Not enough memory"
OVFLW1:	.ASCIZ	<15><12>"?Overflow during MAIN summation"
OVFLW2:	.ASCIZ	<15><12>"?Overflow during percent"
OVFLW3:	.ASCIZ	<15><12>"?Overflow during FIP summation"
DONE:	.ASCIZ	<15><12>"Done creating Histogram"<15><12>


	.SBTTL	DATA AREA

	ORG	PRTDAT

;	*** THIS TABLE IS ORDERED ***
;	It must be in the same order as that in JQSTAT.MAC
;	and PHZCNT entries long
;

	.EVEN
PHZTBL:	.WORD	RSTHDR,'R		;RSTS PHASE
	.WORD	GENHDR,'G		;GEN PHASE
	.WORD	EMTHDR,'1		;EMT PHASE			;005
	.WORD	EM2HDR,'2		;EM2 PHASE			;003
	.WORD	FIPHDR,'F		;FIP PHASE
	.WORD	KBDHDR,'K		;TER PHASE			;007
	.WORD	DSKHDR,'D		;DSK PHASE
	.WORD	FMSHDR,'Z		;FMS PHASE			;003
	.WORD	SESHDR,'S		;SES PHASE			;003
	.WORD	NSPHDR,'N		;NSP PHASE
	.WORD	TRNHDR,'C		;TRN PHASE			;006
	.WORD	XVRHDR,'V		;XVR PHASE			;003
	.WORD	MCPHDR,'M		;MCP PHASE			;003
	.WORD	BBRHDR,'B		;BBR PHASE			;003
	.WORD	OPNHDR,'O		;OPN PHASE			;003
	.WORD	RSXHDR,'E		;RSX PHASE			;005
	.WORD	MVRHDR,'T		;MVR PHASE			;005
	.WORD	KVRHDR,'I		;KVR (KMC driver) phase		;006
	.WORD	RDMHDR,'X		;RDM phase			;006
	.WORD	EVLHDR,'L		;EVL phase			;006
	.WORD	UNAHDR,'U		;UNA phase			;006
	.WORD	QNAHDR,'Q		;QNA phase			;006
	.WORD	DMPHDR,'Y		;DMP phase			;006
	.WORD	NODHDR,'A		;Asnyc DDCMP phase		;007
	.WORD	GRDHDR,'g		;GRD Phase			;007
	.WORD	KINHDR,'k		;KIN Phase			;007
	.WORD	PKPORT,'4		;Pseudo Keyboard Driver		;007
	.WORD	DLPORT,'5		;DL11 Keyboard Driver		;007
	.WORD	DHPORT,'6		;DH11 Keyboard Driver		;007
	.WORD	DZPORT,'7		;DZ11 Keyboard Driver		;007
	.WORD	VHPORT,'8		;DHV11 Keyboard Driver		;007
	.WORD	TERCLS,'t		;Terminal Class Driver		;007
	.WORD	LATHDR,'9		;LAT Protocol processor		;007
	.WORD	OTHHDR,'?		;OTHER PHASES			;003

; The following entries are grouped

FIPTBL:	.WORD	FIPOV1,'#		;FIP overlay state #1		;003
	.WORD	FIPOV2,'#		;FIP overlay state #2		;003
	.WORD	FIPOV3,'#		;FIP overlay state #3		;003
	.WORD	FIPOV4,'#		;FIP overlay state #4		;003
	.WORD	FIPOV5,'#		;FIP overlay state #5		;003
	.WORD	FIPOV6,'#		;FIP overlay state #6		;003

	.WORD	FIPFN1,'#		;FIP function state #1		;003
	.WORD	FIPFN2,'#		;FIP function state #2		;003
	.WORD	FIPFN3,'#		;FIP function state #3		;003
	.WORD	FIPFN4,'#		;FIP function state #4		;003
	.WORD	FIPFN5,'#		;FIP function state #5		;003
	.WORD	FIPFN6,'#		;FIP function state #6		;003

; End of grouping

	.NLIST	BEX
CENT:	.BYTE	40,'0,'0,'.,'0,'0,'0,'%,40,'!
LINE:	.BLKB	LINLEN+10.
LINMAX:	.BLKB	20.
LINPTR:	.WORD	0
QUAD:	.BLKW	4
AREA:	.BLKW	5.		;GENERAL AREA TO USE FOR RT CALLS
DIVSOR:	.WORD	0		;DIVISOR FOR HISTOGRAM VALUES
RNDFAC:	.WORD	0		;ROUNDING FACTOR TO IMPROVE RESOLUTION
TOTAL:	.WORD	0,0		;FOR SUMMING PC COUNTS
SUM:	.WORD	0,0		;
ANSWER:	.WORD	0		;
EXT:	.RAD50	/DMPHIS      /	;DEFAULT EXTENSIONS FOR HISTOGRAM IN/OUT
SYMNME:	.RAD50	/SY RSTS  SYM/	;NAME OF SYMBOL NAME FILE
OUTBLK:	.WORD	0		;CURRENT BLOCK TO OUTPUT IN FILE
OUPNTR:	.WORD	OUTBUF		;CURRENT OUTPUT POINTER IN OUTBUF
CHERRP:	.WORD	HISBUF		;Cache fill round-robin pointer		;003
FIPTOT:	.BLKW	128.*2		;FIP mode summation cells		;003

;	DIVSOR = (MAX PC COUNT)/LINLEN
;	RNDFAC = DIVSOR/2.
;	RNDFAC = (MAX PC COUNT)/(LINLEN*2)
;	LINE COUNT= ((LINLEN * MAX PC COUNT) + RNDFAC)/ (MAX PC COUNT)


	.SBTTL	BUFFERS


;
;	The buffer space for these buffers is claimed at startup time
;	by the .GETCOR and .SETTOP EMT's
;

	ORG	PRTBUF

OUTBUF	==	PRTBUF+0	;OUTPUT BUFFER
ADRBUF	==	OUTBUF+OUTLEN	;SYMBOL NAME DATA BUFFER
HISBUF	==	ADRBUF+ADRLEN	;Histogram data cache
HISEND	==	HISBUF+BUFLEN	;End of histogram data cache		;003 

	.SBTTL	MAINLINE OF PROGRAM


	ORG	PRTHIS

	.NLIST	MEB

PRTHIS::.PRIV,	.STAT		;GET CURRENT SIZE
	MOV	@#XRB,R1	;IN KW
	ASH	#11.,R1		;NOW IN BYTES
	SUB	@#SYSPTR,R1	;NOW IS SIZE OF R/W AREA
	MOV	#OUTBUF,R0	;START HERE
	ADD	#OUTLEN+ADRLEN+BUFLEN,R0 ;AND ASK FOR THIS MUCH MORE
	MOV	R0,-(SP)	;SAVE IT FOR COMPARE
	ADD	R1,R0		;ADD IN R/W SIZE
	ADD	#3777,R0	;ROUND IT UP PLEASE
	CLC			;START WITH THIS CLEAR
	ROR	R0		;SHIFT IN A ZERO
	ASH	#-10.,R0	;MAKE IT KW PLEASE
	.GETCOR			;AND ASK FOR IT
	BCS	40$		;TOO BAD
	MOV	(SP),R0		;RESET HIM PLEASE
	.SETTOP			;ASK FOR IT PLEASE
	CMP	R0,(SP)+	;DID WE GET IT ??
	BLO	40$		;TOO BAD
	.CSIGEN	#EXT,#EXT	;GET THE FILES OPENED
	BCS	20$		;WHOOPS, SOME OPEN ERROR
	.LOOKUP	#AREA,#4,#SYMNME ;OPEN SYMBOL FILE
	BCS	20$		;TOO BAD
	.READW	#AREA,#4,#ADRBUF,#ADRLEN/2,#0 ;READ IN THE ADDRESSES
	BCS	30$		;WHOOPS, SOME READ ERROR
	.CLOSE	#4		;NOW CLOSE FILE
	BCS	10$		;SORRY CLEM

	MOV	#HISBUF,R1	;R1 -> Start of cache			;003
3$:	MOV	#-1,(R1)	;Invalidate this cache entry		;003
	ADD	#512.+2,R1	;Offset to the next entry		;003
	CMP	R1,#HISEND	;More to do?				;003
	BNE	3$		;Yes, so go for it			;003

	CALL	SUMHIS		;O.K., GO SUM FOR MAXIMUM
	TST	TOTAL+2		;'VIRTUALLY ZERO' ???
	BNE	5$		;NOPE
	TST	TOTAL		;REALLY ZERO
	BEQ	50$		;YEP - TOO BAD
5$:	CALL	ANNOUN		;ANNOUNCE US
	CALL	DOIT		;NOW DO THE THING
	CALL	MORE		;AND THE REST
	CALL	DOFIP		;AND PRINT IT OUT
	CALL	NULLS		;LAST BLOCK OF NULLS PLEASE
	.CLOSE	#0		;NOW CLOSE THE OUTPUT FILE
	BCS	10$		;WHOOPS, SOME CLOSE ERROR
	.PRINT	#DONE		;SAY WE ARE FINISHED
	.CLOSE	#3		;Close the histogram file		;003
	BCS	10$		;WHOOPS, SOME CLOSE ERROR
	BR	GETOUT		;AND GO BYE, BYE


	.SBTTL	MAINLINE CONTINUED



10$:	.PRINT	#CLSERR		;SOME CLOSE ERROR
	BR	GETOUT		;SO GET OUT

20$:	.PRINT	#OPNERR		;SOME OPEN ERROR
	BR	GETOUT		;SO GO GET OUT

30$:	.PRINT	#REDERR		;SOME READ ERROR
	BR	GETOUT		;AND GO AWAY

40$:	.PRINT	#CORERR		;TELL HIM NOT ENOUGH MEMORY
	BR	GETOUT		;AND GO AWAY

50$:	.PRINT	#ZERERR		;TELL HIM THE BAD NEWS
	.BR	GETOUT		;GO AWAY PLEASE

GETOUT:	.EXIT			;NOW EXIT ALL DONE


	.SBTTL	MAIN SUMMATION ROUTINE
;
;	FIND MAX HISTOGRAM VALUE AND DIVISOR
;

	ORG	PRTHIS

SUMHIS:	PUSH	<R0,R1,R2,R3,R4,R5> ;SAVE THE REGS PLEASE
	CLR	R2		;Start at Address #0			;003
	CLR	TOTAL		;START AT ZERO
	CLR	TOTAL+2		;AS A DOUBLE NUMBER
	CLR	R4		;SET VERY SMALL LARGEST
	CLR	R5		;NUMBER INITIALLY
10$:	CLR	-(SP)		;START WITH NOTHING			;003
	CLR	R3		;REALLY NOTHING
17$:	CALL	FETCH		;Fetch address from dump file		;003
	ADD	R1,R3		;Add in the LSB				;003
	ADC	(SP)		;AND CARRY THE CARRY
	ADD	R0,(SP)		;Now add in the LSB			;003
	BCS	DEATH		;TOO BAD - SHOULD NEVER HAPPEN ??
	ADD	#PHZLEN,R2	;And point to the next phase		;003
	CMP	R2,#DMPSIZ	;More phases to do?			;003
	BLO	17$		;Yes, so go for it			;003
	ADD	R3,TOTAL+2	;ADD LSB TO TOTAL
	ADC	TOTAL		;AND CARRY IF NEEDED
	MOV	(SP)+,R0	;Pick up MSB of total for this address	;003
	ADD	R0,TOTAL	;ADD MSB TO TOTAL			;003
	SUB	#DMPSIZ-1,R2	;Get back to start phase, next address	;003
	CMP	R0,R4		;IS THIS THE LARGEST YET?		;003
	BLO	30$		;NOPE, SMALLER IN MSB
	BHI	20$		;YEP, LARGER IN MSB
	CMP	R3,R5		;IS IT REALLY THE LARGEST?
	BLOS	30$		;NOPE, REALLY SMALLER
20$:	MOV	R0,R4		;IT IS LARGEST YET, MOVE MSB
	MOV	R3,R5		;AND LSB
30$:	CMP	R2,#ADR.FP	;MORE CHECKING TO DO?			;003
	BLO	10$		;YEP, SO LOOP...
	DIV	#LINLEN,R4	;FIND DIVISOR FOR # / LINE MAXIMUM
	MOV	R4,DIVSOR	;SAVE THAT DIVISOR
	BNE	40$		;SOMETHING THERE
	INC	DIVSOR		;MAKE IT AT LEAST ONE
40$:	ASR	R4		;NOW FIND ROUNDING FACTOR
	MOV	R4,RNDFAC	;AND SAVE THAT ALSO
	POP	<R5,R4,R3,R2,R1,R0> ;RESTORE THE REGS PLEASE
	RETURN			;AND GO AWAY

DEATH:	.PRINT	#OVFLW1		;VERY BAD - SORRY
	JMP	GETOUT		;AND GO AWAY


	.SBTTL	OUTPUT THE DIVISOR AND HEADER



ANNOUN:	CALL	TEXT,R3,HEADER	;DO THE ANNOUNCEMENT WITH HEADER
	MOV	DIVSOR,R3	;GET THE DIVISOR
	CALL	DECSTR		;AND MAKE IT INTO A DECIMAL STRING
	CMPB	(R2)+,#'.	;UP TO THE DECIMAL POINT?
	BNE	20$		;NO, MAKE POINT A COMMA AND PRINT
10$:	CMPB	(R2)+,#'0	;A LEADING ZERO?
	BEQ	10$		;YES, IGNORE LEADING ZERO'S
	TSTB	-(R2)		;NO, BACK UP TO SIG DIGIT (OR THE NULL)
	BNE	30$		;WE HAVE A SIGNIFICANT DIGIT
20$:	DEC	R2		;DO ANOTHER CORRECTION HERE
30$:	MOVB	#',,CENT+3	;CHANGE DECIMAL POINT INTO A COMMA
	CALL	SPTXT,R3	;NOW PRINT THE DIVISOR
	CALL	CRLF		;RESTORE CARRIAGE
	CALLR	CRLF		;TWICE AND EXIT


	.SBTTL	OUTPUT HISTOGRAM

	ORG	PRTHIS

DOIT:	CLR	R1		;START AT VIRTUAL ZERO PLEASE
	CLR	R2		;And set zero as the starting address	;003
10$:	MOV	#1,R5		;FROM FIRST GROUP
	CALL	ADDR		;PRINT AN ADDRESS
	 BR	30$		;ALL DONE
	CLR	SUM		;CLEAR OUT
	CLR	SUM+2		;THE SUMMING BUCKET
	MOV	#LINE,LINPTR	;INIT THE LINE POINTER
	MOV	#PHZTBL+2,R3	;POINT AT CHAR TO PRINT
20$:	CALL	CHARS		;DO THIS ONE
	CMP	(R3)+,(R3)+	;POINT AT NEXT LETTER
	ADD	#PHZLEN-1,R2	;NEXT PHASE, SAME PC PLEASE		;003
	CMP	R2,#DMPSIZ	;DONE YET ?				;003
	BLO	20$		;NOPE
	CALL	PERCNT		;OUTPUT PERCENT AND <CR><LF>
	ADD	#100,R1		;ADVANCE TO NEXT ADDRESS		;003
	SUB	#DMPSIZ-1,R2	;Go to first phase, next address	;003
	CMP	R2,#ADR.12	;MORE?					;003
	BLO	10$		;YEP, SO LOOP...
30$:	RETURN			;THAT'S ALL

	.SBTTL	DO EACH PHASE SEPARATELY


MORE:	MOV	#ADR.12,R2	;Set starting address of APR5		;003
	MOV	#PHZTBL,R3	;POINT AT TEXT HEADER TO PRINT FIRST
	CLR	R5		;PRESET THIS GUY
10$:	INC	R5		;FROM NEXT GROUP
	CMP	R5,#PHZCNT	;Are we done yet?
	BHI	90$		;YEP					;003
	MOV	R2,-(SP)	;SAVE START OF PHASE PLEASE
	MOV	(R3)+,R2	;GET ADDRESS OF HEADER FOR THIS PHASE
	CALL	SPTXT,R3	;AND OUTPUT IT
	MOV	(SP),R2		;RESTORE R2 PLEASE
	MOV	#120000,R1	;START AT PHASE ADDRESS PLEASE		;003
20$:	CALL	ADDR		;PRINT AN ADDRESS
	 BR	30$		;DONE THIS PHASE
	CLR	SUM		;CLEAR OUT
	CLR	SUM+2		;THE SUMMING BUCKET
	MOV	#LINE,LINPTR	;INIT THE LINE POINTER
	CALL	CHARS		;DO THIS ONE
	CALL	PERCNT		;OUTPUT PERCENT AND <CR><LF>
	ADD	#100,R1		;ADVANCE TO NEXT ADDRESS		;003
	CMP	R1,#160000	;MORE?					;003
	BLO	20$		;YEP, SO LOOP...
30$:	MOV	(SP)+,R2	;Restore start of phase
	ADD	#PHZLEN,R2	;NEXT PHASE PLEASE			;003
	TST	(R3)+		;SKIP CHARACTER
	BR	10$		;And loop

90$:	RETURN			;THAT'S ALL


	.SBTTL	DO FIP SPECIAL CASE

DOFIP:	MOV	#ADR.FP,R2	;Set up address of FIP statistics	;003
	MOV	#FIPTBL,R3	;Point at FIP state table		;003
	MOV	#FIPOVR,R5	;R5 = Phase # for FIP overlays		;003

5$:	MOV	#STATES,R4	;R4 = Number of FIP states to do	;003
	MOV	#FIPTOT,R1	;R1 -> FIP totals area			;003
	MOV	#128.*2,R0	;R0 = Number of words to clear		;003
6$:	CLR	(R1)+		;Clear out a word			;003
	SOB	R0,6$		;And loop for the entire area		;003

10$:	CALL	SUMFPP		;Now sum this FIP state area		;003
	CMP	R4,#7-6		;Are we about to do the queue depth?	;003
	BNE	20$		;No, not this time			;003
	MOV	#FIPTOT,R2	;R2 -> FIP totals area			;003

20$:	CALL	DOFPP		;Now do the FIP mode histogram		;003
	ADD	#PHZLEN,R2	;Offset to the next phase		;003
	CMP	(R3)+,(R3)+	;And point to the next header		;003
	SOB	R4,10$		;And loop for all the FIP states	;003
	MOV	#ADR.FP+<PHZLEN*10>,R2 ;Set up for overlay stats	;003
	INC	R5		;And set phase number for FIP functions	;003
.ASSUME	FIPFUN	EQ	FIPOVR+1
	CMP	R5,#FIPFUN	;Are we ready for fip function stats?	;003
	BEQ	5$		;Yes, so go for it			;003
	RETURN			;THAT'S ALL FOLKS

	.SBTTL	DO PART OF FIP MODE HISTOGRAM
;
;	R2 = Start "address" to do
;	R3 ->.WORD TEXT,.WORD CHAR
;	R4 = STATES+1 - (current FIP statistic type)
;	R5 = Group number to use (overlay or FIP function)
;

DOFPP:	PUSH	<R0,R1,R4,R3,R2> ;SAVE REGS PLEASE
	MOV	(R3)+,R2	;GET ADDRESS OF HEADER FOR THIS PART
	CALL	SPTXT,R3	;AND OUTPUT IT
	CLR	R1		;Set our starting address
	MOV	#FIPADR,R4	;Set number of addresses in FIP area	;003
	MOV	(SP),R2		;Restore the "address" to start with	;003
20$:	CALL	ADDR		;PRINT AN ADDRESS
	 BR	30$		;DONE THIS PART
	CLR	SUM		;CLEAR OUT
	CLR	SUM+2		;THE SUMMING BUCKET
	MOV	#LINE,LINPTR	;INIT THE LINE POINTER
	CMP	4(SP),#<STATES+1>-6 ;Are we about to do queue depth?	;003
	BNE	25$		;No, not this time			;003
	CALL	CHARSM		;Yes, so handle that from total cells	;003
	BR	27$		;And join up				;003

25$:	CALL	CHARS		;DO THIS ONE				;003
27$:	CALL	PERCNT		;OUTPUT PERCENT AND <CR><LF>		;003
	ADD	#1000,R1	;ADVANCE TO NEXT ADDRESS		;003
	SOB	R4,20$		;And loop for the whole area		;003
30$:	POP	<R2,R3,R4,R1,R0> ;RESTORE THE REGS PLEASE
	RETURN			;THAT'S ALL


	.SBTTL	FIP MODE SUM ROUTINE
;
;	FIND MAX HISTOGRAM VALUE AND DIVISOR FOR FIP MODE
;
;	R2 = Start "address" of FIP area to sum
;	R4 = STATES+1 - (Current FIP state code)

	ORG	PRTHIS

SUMFPP:	PUSH	<R0,R1,R2,R3,R4,R5> ;SAVE THE REGS PLEASE
	CLR	TOTAL		;START AT ZERO
	CLR	TOTAL+2		;AS A DOUBLE NUMBER
	MOV	#FIPTOT,R3	;R3 -> FIP totals area			;003
	CLR	R4		;SET VERY SMALL LARGEST
	CLR	R5		;NUMBER INITIALLY
10$:	CALL	FETCH		;Pick up two words from the dump file	;003
	CMP	2(SP),#<STATES+1>-6 ;Are we doing the queue depth?	;003
	BNE	15$		;No, not this time			;003
	MOV	R2,-(SP)	;Save a work register			;003
	MOV	(R3)+,R1	;Pick up LSB from total cells		;003
	MOV	(R3)+,R2	;And MSB from total cells		;003
	BNE	11$		;Non-zero, something to do		;003
	TST	R1		;Do we have to do this divide?		;003
	BEQ	14$		;No, so that's easy			;003
11$:	MOV	R3,-(SP)	;Get another work register		;003
	MOV	R4,-(SP)	;And even another one			;003
	MOV	R1,R3		;Pick up LSB from histogram area	;003
	MOV	R0,R4		;Pick up MSB from histogram area	;003
	CALL	DIV32B		;Go and do the divide			;003
	MOV	(SP)+,R4	;Restore work register			;003
	MOV	(SP)+,R3	;And another one			;003
	MOV	R2,R0		;Get MSB into proper register		;003
	MOV	R1,-4(R3)	;Save LSB into totals area		;003
	MOV	R0,-2(R3)	;And save MSB into totals area		;003

14$:	MOV	(SP)+,R2	;And restore the work register		;003

15$:	ADD	R1,TOTAL+2	;ADD LSB TO TOTAL			;003
	ADC	TOTAL		;AND CARRY IF NEEDED
	ADD	R0,TOTAL	;ADD MSB TO TOTAL			;003
	BCS	DEAD		;Too high... can't handle it		;003
	CMP	R0,R4		;IS THIS THE LARGEST YET?		;003
	BLO	30$		;NOPE, SMALLER IN MSB
	BHI	20$		;YEP, LARGER IN MSB
	CMP	R1,R5		;IS IT REALLY THE LARGEST?		;003
	BLOS	30$		;NOPE, REALLY SMALLER
20$:	MOV	R0,R4		;IT IS LARGEST YET, MOVE MSB		;003
	MOV	R1,R5		;AND LSB				;003
30$:	INC	R2		;Update "address" in dump area		;003
	CMP	2(SP),#<STATES+1>-6 ;Are we doing the queue depth state? ;003
	BEQ	35$		;Yes, so no accumulation to do		;003

32$:	ADD	R1,(R3)+	;Add LSB to total area			;003
	ADC	(R3)		;And carry into MSB			;003
	ADD	R0,(R3)+	;Now add into LSB			;003
	BCS	DEAD		;And die if it is too large		;003
35$:	CMP	R3,#FIPTOT+<128.*4> ;More to do?			;003
	BLO	10$		;Yes, so go for it			;003
	DIV	#LINLEN,R4	;FIND DIVISOR FOR # / LINE MAXIMUM
	MOV	R4,DIVSOR	;SAVE THAT DIVISOR
	BNE	40$		;ALL IS WELL
	INC	DIVSOR		;MAKE IT AT LEAST ONE PLEASE
40$:	ASR	R4		;NOW FIND ROUNDING FACTOR
	MOV	R4,RNDFAC	;AND SAVE THAT ALSO
	TST	TOTAL+2		;ANYTHING THERE ?
	BNE	50$		;YEP
	TST	TOTAL		;REALLY SOMETHING THERE ?
	BNE	50$		;YEP
	INC	TOTAL+2		;MAKE IT AT LEAST ONE PLEASE
50$:	POP	<R5,R4,R3,R2,R1,R0> ;RESTORE THE REGS PLEASE
	RETURN			;AND GO AWAY

DEAD:	.PRINT	#OVFLW3		;VERY BAD - SORRY
	JMP	GETOUT		;AND GO AWAY


	.SBTTL	FORCE LAST BLOCK OF NULLS


NULLS:	MOV	#14,R0		;SET A FINAL <FF>
	CALL	BYTE		; AND OUTPUT IT
	MOV	#OUTLEN,R1	;SET FOR FINAL BLOCK FORCE
10$:	CLR	R0		;SET NULL TYPE CHARACTER
	CALL	BYTE		; AND OUTPUT IT
	SOB	R1,10$		;LOOP TO FORCE 1 BLOCK OUT
	RETURN			;AND BACK TO MAINLINE


	.SBTTL	SUBROUNTINES

;
;	OUTPUT A <CR><LF> INTO FILE
;
;	CALL	CRLF
;

	ORG	PRTSUB

CRLF:	MOV	R0,-(SP)	;SAVE THIS REG PLEASE
	MOV	#15,R0		;SET <CR>
	CALL	BYTE		;AND SEND IT OUT
	MOV	#12,R0		;SET <LF>
	CALL	BYTE		;AND SEND IT OUT
	MOV	(SP)+,R0	;AND RESTORE THE REG
	RETURN			;AND GO AWAY


;
;	OUTPUT A BINARY DIGIT INTO FILE
;
;	R2=DIGIT
;
;	CALL	DIGIT
;

	ORG	PRTSUB

DIGIT:	MOV	R0,-(SP)	;SAVE A REG PLEASE
	MOV	R2,R0		;COPY THE DIGIT
	BIC	#^C<7>,R0	;MASK AND
	ADD	#'0,R0		;MAKE A DIGIT
	CALL	BYTE		;AND OUTPUT IT
	MOV	(SP)+,R0	;RESTORE THE REG
	RETURN			;AND GO AWAY


;
;	OUTPUT A RANDOM BYTE TO THE FILE
;
;	R0=BYTE TO OUTPUT
;
;	CALL	BYTE
;
;	EXIT ON ERROR
;

	ORG	PRTSUB

BYTE:	CMP	OUPNTR,#OUTBUF+OUTLEN ;MORE ROOM?
	BLO	10$		;YEP
	MOV	R0,-(SP)	;NOPE, SAVE CHARACTER
	.WRITW	#AREA,#0,#OUTBUF,#OUTLEN/2,OUTBLK ;OUTPUT THE BLOCK
	BCS	20$		;WHOOPS, SOME WRITE ERROR
	MOV	#OUTBUF,OUPNTR	;RESET OUTPUT POINTER
	INC	OUTBLK		;AND SET FOR NEXT OUTPUT BLOCK
	MOV	(SP)+,R0	;RESTORE THE CHARACTER
10$:	MOVB	R0,@OUPNTR	;STORE THE CHARACTER
	INC	OUPNTR		;AND BUMP THE POINTER
	RETURN			;AND EXIT

20$:	.PRINT	#WRTERR		;SOME WRITE ERROR
	JMP	GETOUT		;SO GET OUT



;
;	OUTPUT TEXT TO FILE
;
;	CALL	TEXT,R3,POINTER
;
;	CLOBBERS R2
;

TEXT:	MOV	(R3)+,R2	;GET TEXT POINTER
SPTXT:	MOVB	(R2)+,R0	;GET A CHARACTER
	BEQ	10$		;THE END...
	CALL	BYTE		;ELSE OUTPUT IT
	BR	SPTXT		;AND LOOP

10$:	RETURN	R3		;EXIT


	.SBTTL	OUTPUT PHASE CHARACTER
;+
; CHARS - Output characters for this type using dump file
; CHARSM - Output characters for this type from memory
;
;	OUTPUT CHARACTERS FOR THIS TYPE AT THIS RANGE
;
;	R3 -> CHARACTER TO USE
;	R2 = "Address" in dump file to use (memory for CHARSM)
;
;	CALL	CHARS
;	CALL	CHARSM
;
;	R2 = Next "address" in dump file or memory
;-

.ENABL	LSB

CHARSM:	PUSH	<R0,R1,R3>	;Get some work registers		;003
	MOV	(R2)+,R1	;Pick up LSB				;003
	MOV	(R2)+,R0	;And pick up MSB			;003
	BR	5$		;Now join up				;003

CHARS:	PUSH	<R0,R1,R3>	;SAVE A FEW				;003
	CALL	FETCH		;Pick up the LSB and MSB		;003
	INC	R2		;Update "address" for next time		;003
5$:	ADD	R1,SUM+2	;ADD LSB TO SUM				;003
	ADC	SUM		;AND CARRY IF NEEDED
	ADD	R0,SUM		;ADD MSB TO SUM				;003
	ADD	RNDFAC,R1	;ADD THE 1/2 ADJUST			;003
	ADC	R0		;AND CARRY IF NEEDED			;003
	DIV	DIVSOR,R0	;NOW DIVIDE FOR # CHARS			;003
	BEQ	30$		;ANSWER=0, JUST EXIT
10$:	MOVB	(R3),@LINPTR	;SET 1 CHARACTER
	CMP	LINPTR,#LINMAX-3 ;TOO FAR??
	BLO	20$		;NOPE
	MOVB	#'>,@LINPTR	;YEP, USE A '>' INSTEAD...
	CMP	LINPTR,#LINMAX	;MUCH TOO FAR???
	BHIS	30$		;YES INDEED, GET OUT
20$:	INC	LINPTR		;COUNT CHARS
	SOB	R0,10$		;LOOP FOR # REQUIRED
30$:	POP	<R3,R1,R0>	;Restore our work registers		;003
	RETURN			;AND EXIT

.DSABL	LSB

	.SBTTL	OUTPUT ADDRESS
;
;	OUTPUT ADDRESS LABEL AND VALUE
;
;	R1 = ADDRESS
;	R5 = GROUP NUMBER
;
;	CALL	ADDR
;

ADDR:	PUSH	<R2,R3,R4,R5>	;SAVE THE REGS PLEASE
	MOV	#ADRBUF-8.,R4	;GET ADDRESS BUFFER POINTER
5$:	ADD	#8.,R4		;SKIP OVER EOF FLAG
	DEC	R5		;IS IT THIS ONE
	BEQ	15$		;YEP - SO GO TO IT
10$:	CMP	(R4),#-1	;AT END OF THIS GROUP
	BEQ	5$		;YEP - CHECK WHICH GROUP AGAIN
	ADD	#8.,R4		;NEXT SYMBOL PLEASE
	BR	10$		;GO CHECK IT

15$:	MOV	#6,R2		;GET A HANDY CONSTANT...
	MOV	R1,R5		;COPY THE ADDR*4/100
	CMP	(R4),#-1	;EMPTY GROUP ??
	BEQ	40$		;YES - SO OUTPUT BLANKS
20$:	ADD	R2,R4		;ADVANCE THE POINTER
	MOV	R5,R3		;COPY THE REAL ADDRESS
	SUB	(R4)+,R3	;NOW FIND THE OFFSET
	CMP	R5,6(R4)	;THE CORRECT ONE?
	BHIS	20$		;NO, LOOP
	SUB	#8.,R4		;BACK IT UP TO THE SYMBOL PLEASE
30$:	MOVB	(R4)+,R0	;GET A SYMBOL CHARACTER
	BEQ	70$		;A NULL, ABOVE MODULE BOUNDS
	CALL	BYTE		;ELSE OUTPUT IT
	SOB	R2,30$		;DO FOR ALL 6 CHARACTERS
	MOV	#',,R0		;NOW OUTPUT
	CALL	BYTE		;A COMMA
	CALL	OCTAL		;NOW OUTPUT THE OFFSET (R3)
	BR	60$		;CONTINUE

40$:	MOV	#6+1+6,R2	;COUNT FOR NO SYMBOL
50$:	MOV	#40,R0		;USE SPACES
	CALL	BYTE		;AS OUTPUT
	SOB	R2,50$		;AND LOOP...
60$:	MOV	#40,R0		;NOW OUTPUT
	CALL	BYTE		;A SPACE
	MOV	R5,R3		;NOW SET UP THE REAL ADDRESS
	CALL	OCTAL		;AND GO OUTPUT IT
	ADD	#2,10(SP)	;TAKE SECOUND EXIT
70$:	POP	<R5,R4,R3,R2>	;NOW RESTORE THOSE REGS
	RETURN			;AND GO BACK TO WORK


	.SBTTL	OUTPUT AND OCTAL NUMBER
;
;	OUTPUT AND OCTAL NUMBER
;
;	R3=NUMBER TO PRINT
;
;	CALL	OCTAL
;

	ORG	PRTSUB

OCTAL:	MOV	R2,-(SP)	;SAVE A REG PLEASE
	MOV	R4,-(SP)	;AND ONE MORE
	CLR	R2		;CLEAR HIGH ORDER
	ASHC	#1,R2		;AND FIND THE FIRST DIGIT
	CALL	DIGIT		;OUTPUT SIGN DIGIT
	MOV	#5,R4		;NOW DO 5 MORE
10$:	ASHC	#3,R2		;SHIFT OVER 3
	CALL	DIGIT		;AND OUTPUT
	SOB	R4,10$		;AND LOOP UNTIL DONE
	MOV	(SP)+,R4	;RESTORE R4
	MOV	(SP)+,R2	;AND R2 AS WELL
	RETURN			;THEN EXIT



;
;	OUTPUT A DECIMAL STRING
;
;	R3=NUMBER TO OUTPUT
;	R2 -> ADDRESS TO PUT IT
;
;	CALL	DECSTR
;
;	CLOBBERS R0
;

DECSTR:	MOV	#CENT+1,R0	;GET DECIMAL STRING AREA POINTER
	CALL	20$,R5,10000.	;DO TEN-THOUSANDS FIRST
	CALL	20$,R5,1000.	;DO THOUSANDS NEXT
	MOVB	#'.,(R0)+	;NOW SET THE DECIMAL POINT
	CALL	20$,R5,100.	;DO HUNDERDS
	CALL	20$,R5,10.	;DO TENS
	CALL	20$,R5,1.	;DO UNITS
	CLRB	(R0)		;SET TERMINATING NULL
	MOV	#CENT,R2	;GET THE STRING POINTER AGAIN
10$:	MOVB	#40,(R2)+	;BLANK A LEADING ZERO
	CMPB	(R2),#'0	;ANOTHER LEADING ZERO?
	BEQ	10$		;YES, GO BLANK IT
	RETURN			;NO, EXIT

20$:	CLR	R2		;CLEAR A HIGH ORDER
	DIV	(R5)+,R2	; AND DIVIDE
	ADD	#'0,R2		;MAKE ANSWER AN ASCII DIGIT
	MOVB	R2,(R0)+	; AND SET THE DIGIT INTO STRING
	RETURN	R5		;EXIT

PERCNT:	PUSH	<R2,R3,R4,R5>	;SAVE THESE GUYS
	MOV	#QUAD,R0	;POINT TO QUAD WORD RESULT OF *100000.
	CLR	(R0)+		;CLEAR
	CLR	(R0)+		;THE
	CLR	(R0)+		;QUAD
	CLR	(R0)		;RESULT
	MOV	SUM+2,R2	;GET LOW ORDER MULTIPLICAND
	ASH	#5,R2		;AND MULTIPLY BY 32. (2**5)
	CALL	DOQUAD		;NOW MULTIPLY BY 3125. AND SUM IT
	ADC	-(R0)		;CARRY ANY CARRY
	BCS	DIE		;A CARRY?? (DIE)
	TST	(R0)+		;POINT INTO QUAD FOR MIDDLE ORDER
	MOV	SUM,R2		;GET MULTIPLICAND HIGH ORDER
	MOV	SUM+2,R3	;AND LOW ORDER
	ASHC	#5,R2		;AND MULTIPLY BY 32.
	CALL	DOQUAD		;NOW MULTIPLY BY 3125. AND SUM IT
	ADC	-(R0)		;CARRY ANY CARRY
	BCS	DIE		;A CARRY?? (DIE)
	TST	(R0)+		;POINT INTO QUAD FOR HIGHEST ORDER
	MOV	SUM,R2		;GET MULTIPLICAND HIGH ORDER
	ASH	#5-16.,R2	;AND MULTIPLY BY 32.
	BIC	#^C<37>,R2	;TRIMMING ANY SIGN EXTENSION
	CALL	DOQUAD		;NOW MULTIPLY BY 3125. AND SUM IT
	BCS	DIE		;A CARRY?? (DIE)
	BEQ	DODIV		;ALL O.K. IF HIGHEST ORDER IS ZERO
	
DIE:	.PRINT	#OVFLW2		;ELSE DIE...
	JMP	GETOUT		;AFTER PRINTING


DOQUAD:	MUL	#3125.,R2	;MULTIPLY BY 3125. (5**5)
	BPL	10$		;RESULT O.K.
	ADD	#3125.,R2	;ELSE CORRECT HIGH ORDER RESULT
10$:	ADD	R3,(R0)		;ADD IN LSB
	ADC	R2		;CARRY INTO MSB RESULT (NO PROPAGATION!)
	BCS	DIE		;A CARRY?? (DIE)
	ADD	R2,-(R0)	;ADD IN MSB
	RETURN			;EXIT WITH ANY FINAL CARRY INDICATION


DODIV:	CLR	ANSWER		;PRE-CLEAR THE FINAL ANSWER
	MOV	TOTAL,R0	;SET HIGH ORDER DIVISOR
	MOV	TOTAL+2,R2	;SET MIDDLE ORDER DIVISOR
	CLR	R3		;SET LOW ORDER DIVISOR
	CLR	-(SP)		;SET RESULTANT BIT (BIT 16...)
10$:	CLC			;ENSURE CARRY=0
	ROR	(SP)		;SHIFT RESULTANT BIT RIGHT ONE
	BCS	DIVDNE		;BIT SHIFTED OUT, DONE
	BNE	20$		;REAL BIT, CONTINUE
	MOV	#100000,(SP)	;NO BIT YET, SET A BIT
20$:	;CLC			;CARRY=0 SINCE NO 'BCS'
	ROR	R0		;DIVIDE THE
	ROR	R2		;DIVISOR
	ROR	R3		;BY 2
	CMP	QUAD+2,R0	;GOT IT?
	BLO	10$		;NOPE
	BHI	30$		;YEP
	CMP	QUAD+4,R2	;CHECK MIDDLE
	BLO	10$		;NOPE
	BHI	30$		;YEP
	CMP	QUAD+6,R3	;LAST CHECK...
	BLO	10$		;NOPE
30$:	BIS	(SP),ANSWER	;SET THE RESULTANT ANSWER BIT
	SUB	R0,QUAD+2	;DO HIGH ORDER
	SUB	R2,QUAD+4	;DO MIDDLE
	SBC	QUAD+2		;WITH CARRY
	SUB	R3,QUAD+6	;DO LOW ORDER
	SBC	QUAD+4		;WITH CARRY
	SBC	QUAD+2		;AND (POSSIBLY) ANOTHER
	BR	10$		;NOW LOOP...

DIVDNE:	TST	(SP)+		;POP THE (NOW JUNK) STACK ITEM
	MOV	ANSWER,R3	;GET ANSWER
	BEQ	10$		;ANSWER WAS ZERO...
	CMP	LINPTR,#LINE	;ANYTHING STORED?
	BNE	10$		;YEP
	MOVB	#'*,@LINPTR	;NOPE, PUT SOMETHING THERE
	INC	LINPTR		;AND COUNT IT
10$:	CALL	DECSTR		;MAKE ANSWER INTO A DECIMAL STRING
	MOVB	#'%,(R0)	;BUT TERMINATE IT WITH A PERCENT SIGN
	CLRB	@LINPTR		;ENSURE A TERMINATION
	CALL	TEXT,R3,CENT	;NOW OUTPUT THE TEXT WITH THIS HEADER
	CALL	CRLF		;RESTORE CARRIAGE AND EXIT
	POP	<R5,R4,R3,R2>	;AND RESTORE THE REGS
	RETURN			;AND GO AWAY

.SBTTL	Fetch a doubleword from the dump file

;+									;003
; FETCH - Fetch a doubleword from the dump file				;003
;									;003
;	R2 = "Address" to fetch						;003
;									;003
;	CALL	FETCH							;003
;									;003
;	R0 = MSB of doubleword						;003
;	R1 = LSB of doubleword						;003
;									;003
; This routine is used to fetch a doubleword from the dump file. The	;003
; "address" passed in R2 is actually the doubleword offset into		;003
; the file.								;003
;-									;003

FETCH:	MOV	R2,-(SP)	;Get one work register			;003
	MOV	R3,-(SP)	;And another one			;003
	MOV	R2,R3		;Copy doubleword offset to obtain	;003
	ASH	#-7,R3		;Now R3 has the block offset to obtain	;003
	BIC	#^C<777>,R3	;Trim off any junk			;003
	MOV	#HISBUF,R1	;R1 -> Start of histogram cache		;003
2$:	CMP	(R1)+,R3	;Is this the block we want?		;003
	BEQ	10$		;Yes, it sure is			;003
	ADD	#1000,R1	;Offset to the next block		;003
	CMP	R1,#HISEND	;Are we done yet?			;003
	BNE	2$		;No, so loop for all the cache entries	;003
	MOV	CHERRP,R1	;Block not found, get an entry to use	;003
	MOV	R3,(R1)+	;And stash our block number into it	;003
	ADD	#1000+2,CHERRP	;And update round-robin pointer		;003
	CMP	CHERRP,#HISEND	;Do we need to reset the pointer?	;003
	BNE	3$		;No, not this time			;003
	MOV	#HISBUF,CHERRP	;Reset the round-robin pointer		;003
3$:	.READW	#AREA,#3,R1,#256.,R3 ;Read in the block of the dump file ;003
	BCC	10$		;It worked, that's good			;003
	.PRINT	#REDERR		;Report a read error			;003
	.EXIT			;And get out				;003

10$:	BIC	#^C<177>,R2	;R2 has doubleword offset into block	;003
	ASL	R2		;Now R2 has word offset into block	;003
	ASL	R2		;Now R2 has byte offset into block	;003
	ADD	R1,R2		;R2 -> Desired area of histogram	;003
	MOV	(R2)+,R1	;Pick up LSB of doubleword		;003
	MOV	(R2)+,R0	;And MSB of doubleword			;003
	MOV	(SP)+,R3	;Restore one work register		;003
	MOV	(SP)+,R2	;And another one			;003
	RETURN			;And now we're done			;003

.SBTTL	Thirty-two bit divide routine

;+									;003
; DIV32B - Thirty-two bit divide					;003
;									;003
;	R1 = LSB of divisor						;003
;	R2 = MSB of divisor						;003
;									;003
;	R3 = LSB of dividend						;003
;	R4 = MSB of dividend						;003
;									;003
;	CALL	DIV32B							;003
;									;003
;	R1 = LSB of quotient						;003
;	R2 = MSB of quotient						;003
;	R3 = Undefined							;003
;	R4 = Undefined							;003
;-									;003

DIV32B:	MOV	R0,-(SP)	;Save R0 R5				;003
	MOV	R5,-(SP)	;					;003
	MOV	#33.,-(SP)	;Set up iteration count			;003
	CLR	R0		;Quotient ends up in R4:R3		;003
	CLR	R5		;					;003
100$:	ROL	R5		;Expose new bit of numerator		;003
	ROL	R0		;					;003
	CMP	R2,R0		;Does denominator fit?			;003
	BHI	120$		;No					;003
	BNE	110$		;Yes					;003
	CMP	R1,R5		;High parts are the same, check low	;003
	BHI	120$		;No					;003
110$:	SUB	R1,R5		;Subtract denominator from remainder	;003
	SBC	R0		;					;003
	SUB	R2,R0		;					;003
	SEC			;Indicate new quotient bit		;003
120$:	ROL	R3		;Shift in new bit of quotient		;003
	ROL	R4		;					;003
	DECB	(SP)		;Check loop count			;003
	BGT	100$		;Loop					;003
	TST	(SP)+		;Give back stack space			;003
	MOV	R0,R2		;Move result to R2:R1			;003
	MOV	R3,R1		;					;003
130$:	MOV	(SP)+,R5	;Restore R5 R0				;003
	MOV	(SP)+,R0	;					;003
	RETURN			;And now we're done			;003

.END	PRTHIS
