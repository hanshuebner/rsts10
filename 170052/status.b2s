2!		PROGRAM		: STATUS
5!		VERSION		: V10.1
6!		EDIT		: A
7!		EDIT DATE	: 10-MAY-91
8!
10	EXTEND
11	!								      &
									      &
									      &
	!		  C O P Y R I G H T				      &
									      &
									      &
  !		      Copyright (C) 1977, 1991 by			      &
  !	        Digital Equipment Corporation, Maynard, Mass.		      &
  !									      &
  !									      &
  !	This software is furnished under a license and may be used and	      &
  !	copied  only  in accordance with the terms of such license and	      &
  !	with the  inclusion  of  the  above  copyright  notice.   This	      &
  !	software  or  any  other copies thereof may not be provided or	      &
  !	otherwise made available to any other person.  No title to and	      &
  !	ownership of the software is hereby transferred.		      &
  !									      &
  !	The information in this software is subject to change  without	      &
  !	notice  and should not be construed as a commitment by Digital	      &
  !	Equipment Corporation.						      &
  !									      &
  !	DIGITAL assumes no responsibility for the use  or  reliability	      &
  !	of its software on equipment that is not supplied by DIGITAL.	      &
  !									      &
  !*******************************************************************	      &

20	!								      &
									      &
	!	M O D I F I C A T I O N   H I S T O R Y			      &

21	! VER/ED	EDIT DATE	REASON				      &
	!								      &
	! V9.3-13	18-Jun-86	(JJT) Increase maximum disks to 48    &
	!				Make maximum disks a constant	      &
	!				Only print out a screen full of data  &
	!				Add option to only print mounted disks &
	! V9.3-17	21-Oct-86	(JJT) Make the default only display   &
	!				mounted disks			      &
	! V9.7-06	21-Mar-89	(JJT) Don't put ANSI KB into VT52 mode &

100	!								      &
									      &
	!	G E N E R A L   D E S C R I P T I O N			      &

111!									      &
   !	 The STATUS program formats and prints monitor, cache, and disk	      &
   !	 statistics  collected by the RSTS/E monitor.  In order to	      &
   !	 use this package, the system manager must  have  included  the	      &
   !	 statistics option during system generation.			      &
   !									      &
   !									      &
   !	                              NOTE				      &
   !									      &
   !	     DIGITAL assumes no responsibility for the accuracy  of	      &
   !	     data  obtained  by  the statistics option, nor for the	      &
   !	     interpretation  of  that   data.    It   is   strongly	      &
   !	     recommended    that    you    consult   with   DIGITAL	      &
   !	     representatives   before   undertaking   any    system	      &
   !	     monitoring operations.					      &
   !									      &
   !	     The release of information in this document  does  not	      &
   !	     imply a commitment by DIGITAL to provide this facility	      &
   !	     or to maintain compatibility  in  future  releases  of	      &
   !	     RSTS/E.							      &
   !									      &

112!									      &
   !	                             Usage				      &
   !									      &
   !	 To use the STATUS program, type:				      &
   !									      &
   !	         RUN $STATUS						      &
   !									      &
   !	 After printing its header, STATUS asks:			      &
   !									      &
   !	         Output to <KB:STATUS.LST [/VT05, /VT5x, /VT100]>?	      &
   !									      &
   !	 Respond with the name of the output device  or  file.   Append	      &
   !	 /VT05, /VT50, /VT52 or /VT100 if the display is written on one	      &
   !	 of these  terminals.  STATUS then asks:			      &
   !									      &
   !	         Interval <60>?						      &
   !									      &
   !	 Respond with the interval between displays.  Using this  value	      &
   !	 as  a  guide, STATUS chooses a sleep time so as to present the	      &
   !	 display at the requested interval.  If  you  respond  with  an	      &
   !	 explicit  zero  value,  one  display (only) is output.  STATUS	      &
   !	 then asks:							      &
   !									      &
   !	         Percent mode (Yes/No) <No>?				      &
   !									      &
   !	 Respond with "Yes" if  you  want  directory,  user,  and  swap	      &
   !	 statistics  to  be  presented  in  terms  of  their percentual	      &
   !	 contribution, or with "No" if you want a presentation in terms	      &
   !	 of  accesses  (or blocks) per second.  You can switch back and	      &
   !	 forth between the two;  see below.  STATUS then asks:		      &
   !									      &
   !	         Physical I/O only (Yes/No) <No>?			      &
   !									      &
   !	 Respond with "Yes"  if you want to see only  I/O requests that	      &
   !	 caused a  physical  disk  operation,  or with "No"  to see all	      &
   !	 requests, including those satisfied from the cache.		      &
   !									      &
   !	 If the display interval is not zero, STATUS asks:		      &
   !									      &
   !	         Detach (Yes/No) <No>?					      &
   !									      &
   !	 Respond with "Yes" to detach the program.  Processing begins.	      &
   !									      &
   !	 If STATUS is printing on a terminal, it checks for input  from	      &
   !	 that  terminal.   The  following  may  be typed (followed by a	      &
   !	 delimiter):							      &
   !									      &
   !	         C   Clear the screen					      &
   !	         %   Display in percent mode				      &
   !	         V   Display in access/second mode			      &
   !	         P   Display physical I/O only				      &
   !	         R   Display all requests				      &
   !		 N   Display non-mounted disks as well as mounted disks	      &
   !		 M   Display only mounted disks (the default upon startup)    &
   !		 Dn  Display disks starting from disk unit n		      &
   !									      &
   !	 If you type CTRL/C at the terminal, STATUS closes  its  output	      &
   !	 file  and  asks  if  it  should  detach.  Type "Y" if you want	      &
   !	 detaching.							      &
   !									      &

113!									      &
   !	                         Error Messages				      &
   !									      &
   !	 ?Statistics not available					      &
   !									      &
   !	     Statistics were not configured in this system.		      &
   !									      &
   !	 ?Too many disks, please rebuild STATUS				      &
   !									      &
   !	     The dimension of the disk data tables  is  too  small  for	      &
   !	     your system.  You must edit STATUS to increase the value of      &
   !	     the constant MAX.UNIT and try again.			      &
   !									      &
   !	 ?Input a number						      &
   !									      &
   !	     The "Interval" question requires an integer.		      &
   !									      &
   !	 ?Please answer Yes or No					      &
   !									      &
   !	     Your answer was not understood.				      &
   !									      &
   !	 No Logins -- shutting down					      &
   !									      &
   !	     If the number of permitted jobs is set to 1 (by the UTILTY	      &
   !	     NO  LOGINS  command)  and output is to a disk file, STATUS	      &
   !	     closes the output file and stops processing.		      &
   !									      &
   !	 ?STATUS V10.1-A fatal error CODE at line LINE -- TEXT		      &
   !									      &
   !	     The program has crashed for some (unexpected) reason.	      &
   !									      &

114!									      &
   !	 The display is divided into two parts:  the upper has  monitor	      &
   !	 and  directory  cache  information,  while  the lower has disk	      &
   !	 data.								      &
   !									      &
   !	                       Monitor Statistics			      &
   !									      &
   !									      &
   !	 System status							      &
   !									      &
   !	     The first line of the  display  contains  a  status  line,	      &
   !	     including  date  and  time  of  the  display,  the  system	      &
   !	     identification, and the number of errors logged (excluding	      &
   !	     hung terminals).						      &
   !									      &
   !	 Jobs								      &
   !									      &
   !	     The number of jobs  logged  in,  and  the  maximum  number	      &
   !	     permitted.							      &
   !									      &
   !	 User running							      &
   !									      &
   !	     The percent of time spent running user programs.		      &
   !									      &
   !	 Fip needed							      &
   !									      &
   !	     The percent of time during which  at  least  one  job  was	      &
   !	     waiting for the file manipulation service (to open, close,	      &
   !	     or extend a file, for example).				      &
   !									      &
   !	 Seconds							      &
   !									      &
   !	     The interval over which this sample was taken.		      &
   !									      &
   !	 Idle								      &
   !									      &
   !	     The percent of time during which the system was idle;   no	      &
   !	     job in the system could run.				      &
   !									      &
   !	 SYS Charged							      &
   !									      &
   !	     The percent of time during which the system was  executing	      &
   !	     monitor code, while some job was running.			      &
   !									      &
   !	 Fip in use							      &
   !									      &
   !	     The file processor was executing.  This time is also  part	      &
   !	     of SYS charged (or uncharged).				      &
   !									      &

115!									      &
   !	 Cache hits							      &
   !									      &
   !	     The value printed is the percent of directory blocks  that	      &
   !	     were found in the XBUF cache.				      &
   !									      &
   !	 Lost								      &
   !									      &
   !	     Lost time is the percent of time no job  in  memory  could	      &
   !	     run,  but  some  job on the disk was selected for running.	      &
   !	     If high, you need more memory.				      &
   !									      &
   !	 SYS uncharged							      &
   !									      &
   !	     This is the percent of time monitor code was run which was	      &
   !	     not chargeable to some specific job.			      &
   !									      &
   !	 I/O service							      &
   !									      &
   !	     This is the percent of time the system serviced interrupts	      &
   !	     at  priority  level  4 (terminals and other slow devices),	      &
   !	     and priority level 5 (disk and magtape).  Priority  levels	      &
   !	     6 and 7 cannot be recorded by the statistics package.	      &
   !									      &
   !	 Cache CPU							      &
   !									      &
   !	     This is the percent of time the Directory cache  code  was	      &
   !	     running.							      &
   !									      &
   !	 Char/sec out							      &
   !									      &
   !	     This is the number of  bytes  per  second  output  to  all	      &
   !	     terminals.							      &
   !									      &
   !	 Char/sec in							      &
   !									      &
   !	     This is the number of bytes  per  second  input  from  all	      &
   !	     terminals.							      &
   !									      &
   !	 Min sml buff							      &
   !									      &
   !	     This is the minimum number of small buffers not in use.	      &
   !									      &

116!									      &
   !	                        Disk statistics				      &
   !									      &
   !	 Upon each disk  transfer,  the  monitor  records  the  device,	      &
   !	 access type (read or write), number of blocks, and the reason.	      &
   !	 These data are summarized under the following headings:	      &
   !									      &
   !									      &
   !	 Disk								      &
   !									      &
   !	     The name of the disk drive/unit.				      &
   !	     (If the disk is not mounted, nothing else is printed.)	      &
   !									      &
   !	 Access per Sec							      &
   !									      &
   !	     This group of numbers presents the number of transfers per	      &
   !	     second for each drive and unit.				      &
   !									      &
   !	 Blocks per Sec							      &
   !									      &
   !	     This group of numbers presents the number of  disk  blocks	      &
   !	     transferred per second.					      &
   !									      &
   !	 Total								      &
   !									      &
   !	     This column specifies each  drive's  contribution  to  the	      &
   !	     total system load.						      &
   !									      &
   !	 Reads								      &
   !									      &
   !	     This column specifies the percentage of accesses which are	      &
   !	     reads.  Note, this column is not printed on vt05 terminals	      &
   !	     because of line-width considerations.			      &
   !									      &
   !	 Direct								      &
   !									      &
   !	     This column describes directory read and write accesses.	      &
   !									      &
   !	 User								      &
   !									      &
   !	     This column describes user data read and write accesses.	      &
   !									      &
   !	 SwpSys								      &
   !									      &
   !	     This column describes  swap  and  other  system  accesses,	      &
   !	     including overlay code and DECtape buffer accesses.	      &
   !									      &

900	!								      &
									      &
	!	D I M E N S I O N   S T A T E M E N T S			      &

905	DECLARE WORD CONSTANT MAX.UNIT = 48				      &
		! DECLARE A CONSTANT FOR THE MAX NUMBER OF DISK UNITS	      &
\	DECLARE WORD CONSTANT MAX.STATS = MAX.UNIT * 48			      &
		! DECLARE A CONSTANT FOR THE MAX NUMBER OF DISK STATS	      &

910	DIM U(MAX.UNIT,6), A(MAX.UNIT),     B(MAX.UNIT),		      &
	    R(MAX.UNIT),   DISK$(MAX.UNIT), DSK.MNT%(MAX.UNIT)		      &
		! U(UNITS,6)	DISK STATISTICS				      &
		! A(UNITS)	ACCESSES PER UNIT			      &
		! B(UNITS)	BLOCKS PER UNIT				      &
		! R(UNITS)	READS PER UNIT				      &
		! DISK$(UNITS)	DISK NAMES				      &
		! DSK.MNT%	DISK UNIT MOUNTED/NOT MOUNTED FLAG	      &

920	DIM USERIO(MAX.UNIT,1), DIR.IO(MAX.UNIT,1), SWAPIO(MAX.UNIT,1)	      &
		! USERIO(UNITS,1)	USER DATA ACCESSES, BLOCKS	      &
		! DIR.IO(UNITS,1)	DIRECTORY ACCESSES, BLOCKS	      &
		! SWAPIO(UNITS,1)	SWAP/SYS  ACCESSES, BLOCKS	      &

930	DIM EXEC(70), DISK(MAX.STATS), H0%(30), H1%(30)			      &
		! EXEC(70)	CPU STATISTICS BUFFER			      &
		! DISK(...)	DISK STATISTICS BUFFER:			      &
		!	DIMENSION IS <NUMBER OF UNITS>*36.		      &
		! H0%(30)	SYS CALL VALUE BUFFER			      &
		! H1%(30)	SYS CALL VALUE BUFFER			      &

940	DIM CPU.PR(5), CACHE.PR(5)					      &
		! CPU.PR()	CPU PRIORITY LEVEL WHEN CLOCK TICKED	      &
		! CACHE.PR()	CACHE CODE RUNNING WHEN CLOCK TICKED	      &

950	EXTERNAL WORD FUNCTION DSKPEK(WORD,WORD)			      &

1000	!								      &
									      &
	!	I N I T I A L I Z A T I O N				      &

1010	VERSION$ = "V10.1-A"						      &

1020	ON ERROR GOTO 19000						      &
	\ SYSTEM$=FNE$(0%)						      &
	\ PRINT IF CCPOS(0%)						      &
	\ PRINT "STATUS"; CHR$(9%); VERSION$; CHR$(9%); SYSTEM$		      &

1030	DISK%=SWAP%(CVT$%(RIGHT(SYS(CHR$(6%)+CHR$(-29%)),29%)))		      &
	\ CPU%=PEEK(PEEK(156%)+2%)					      &
	\ CACHE%=PEEK(PEEK(156%)+6%)					      &
	\ IF (DISK%=0% OR CPU%=0% OR CACHE%=0%) THEN			      &
		PRINT "?Statistics not available"			      &
	\	GOTO 32767						      &
		! DISK%		BASE OF DISK STATISTICS			      &
		! CPU%		BASE OF CPU STATISTICS			      &
		! CACHE%	BASE OF DIRECTORY CACHE STATISTICS	      &

1040	UNITS%=DSKPEK(DISK%,0%) AND 255%				      &
	\ IF UNITS% > MAX.UNIT THEN					      &
		PRINT "?Too many disks, please rebuild STATUS"		      &
	\	GOTO 32767						      &
		! GET COUNT OF CONFIGURED DISKS.			      &
		! BUMP DSTATS POINTER SO IT POINTS TO START OF DISK DATA.     &
		! CHECK AGAINST DIMENSION STATEMENT			      &

1050	OLD.HITS,OLD.ATTEMPTS=0.0					      &
	\ EXEC(Q%)=0% FOR Q%=0% TO 60%					      &
	\ DISK(Q%)=0% FOR Q%=0% TO 576%					      &
	\ TICKS=PEEK(CPU%)						      &
	\ CHANGE SYS(CHR$(6%)+CHR$(-3%)) TO H0%				      &
	\ H0%(Q%)=H0%(Q%)+SWAP%(H0%(Q%+1%)) FOR Q%=5% TO 29% STEP 2%	      &
		! GET/STORE MONITOR TABLES PART 1			      &
	\ CHANGE SYS(CHR$(6%)+CHR$(-12%)) TO H1%			      &
	\ H1%(Q%)=H1%(Q%)+SWAP%(H1%(Q%+1%)) FOR Q%=3% TO 29% STEP 2%	      &
		! GET/STORE MONITOR TABLES PART 2			      &
	\ DEVCNT%=H0%(5%)						      &
	\ DEVNAM%=H1%(5%)						      &
	\ DEV0KB%=H1%(9%)						      &
		! DEVCNT%	HOW MANY UNITS PER DISK TABLE		      &
		! DEVNAM%	DEVICE NAME TABLE			      &
		! DEV0KB%	HOW MANY DEVICES TIMES 2%		      &
	\ GOSUB 10000							      &
	\ MAX.UNIT%=UNITS%-1%						      &
	\ Q$ = FNRJUST$(2%, 1.0, 32%)					      &
	\ START.DISK% = 0%						      &
	\ NO.MOUNT% = -1%						      &
		! CLEAR INITIAL COUNTER VALUES AND SETUP DISK NAME TABLE      &
		! THE DUMMY CALL TO FNRJUST$ FORCES FLOATING-POINT	      &
		! PARAMETERS, THUS PREVENTING AN ASSEMBLY ERROR.	      &
		! UNITS%	NUMBER OF DISK UNITS			      &
		! OLD.ATTEMPTS	NUMBER OF DIRECTORY CACHE ATTEMPTS	      &
		! OLD.HITS	NUMBER OF DIRECTORY HITS		      &
		! EXEC		CPU STATISTICS SAVE AREA		      &
		! TICKS		TICKS PER SECOND (UPTIME)		      &
		! MAX.UNIT%	HIGHEST INDEX IN DISK TABLE		      &
		! START.DISK%	Disk number to start			      &
		! NO.MOUNT%	Display non-mounted disks flag		      &
		!		 It is initially set to not display	      &
		!		 non-mounted disks			      &

1100	!								      &
									      &
	!	G E T   P A R A M E T E R S   A N D   S E T U P		      &

1110	GOSUB 25000							      &
	\ PRINT "Output to <KB:STATUS.LST [/VT05, /VT5x, /VT100]>";	      &
	\ INPUT LINE OUT.FILE$						      &
	\ OUT.FILE$=CVT$$(OUT.FILE$,-2%)				      &
	\ Q%=INSTR(1%,OUT.FILE$,"/")					      &
	\ Q%=LEN(OUT.FILE$)+1% IF Q%=0%					      &
	\ ERAS.END.LIN$,ERAS.END.SCR$=""				      &
	\ LINES%=32767%							      &
	\ FIXED%=10%							      &
	\ RESTART%=0%							      &
	\ CRLF$,HOME1$=CHR$(13%)+CHR$(10%)				      &
	\ HOME2$=CRLF$+CHR$(12%)					      &
	\ Q$=RIGHT(OUT.FILE$,Q%)					      &
	\ OUT.FILE$=LEFT(OUT.FILE$,Q%-1%)				      &
	\ WIDE% = (Q$ <> "/VT05") AND 6%				      &
	\ IF WIDE% = 0% THEN						      &
		HOME1$,HOME2$=CHR$(29%)					      &
	\	ERAS.END.LIN$=CHR$(30%)					      &
	\	ERAS.END.SCR$=CHR$(31%)					      &
	\	CLR.SCR$=HOME2$+ERAS.END.SCR$				      &
	\	LINES% = 20%						      &
		! GET OUTPUT DEVICE AND INITIALIZE CURSOR STRINGS	      &
		! AND LINES-PER-PAGE FOR "NOTHING."  SETUP FOR VT05	      &
		! WIDE%		0 IF VT05, 6 IF ANYTHING ELSE		      &

1130	IF LEFT(Q$,4%)="/VT5" THEN					      &
		ES$=CHR$(27%+128%)					      &
	\	HOME1$,HOME2$=ES$+"H"					      &
	\	ERAS.END.LIN$=ES$+"K"					      &
	\	ERAS.END.SCR$=ES$+"J"					      &
	\	CLR.SCR$=ES$+"G"+HOME2$+ERAS.END.SCR$			      &
	\	LINES% = 24%						      &
	\	LINES% = 12% IF Q$ = "/VT50"				      &
		! SETUP FOR VT50, VT52, OR VT100.			      &
		! CLR.SCR$ DOES THE FOLLOWING:				      &
		!  VT52		EXIT GRAPHICS MODE;CURSOR HOME;ERASE TO	      &
		!		 END-OF-SCREEN				      &

1135	IF LEFT(Q$,3%)="/VT" AND LEN(Q$) = 6% THEN			      &
		ES$=CHR$(27%+128%) + "["				      &
	\	HOME1$,HOME2$=ES$+"H"					      &
	\	ERAS.END.LIN$=ES$+"K"					      &
	\	ERAS.END.SCR$=ES$+"J"					      &
	\	ES$=CHR$(27%+128%)					      &
	\	CLR.SCR$=CHR$(15%)+ES$+"<"+HOME2$+ERAS.END.SCR$		      &
	\	LINES% = 24%						      &
		! SETUP FOR VT1xx, VT2xx, OR VT3xx.			      &
		! CLR.SCR$ DOES THE FOLLOWING:				      &
		!		EXIT GRAPHICS;ENTER ANSI;HOME;ERASE	      &

1140	OPTIMIZE% = 0%							      &
\	IF UNITS%+FIXED% > LINES% THEN					      &
		OPTIMIZE% = -1%						      &
		! CHECK FOR POSSIBLE OVERFLOW				      &

1150	SKIPPING% = ((UNITS%+FIXED%+DEVICES%) <= LINES%)		      &
	\ OUT.FILE$="KB:STATUS.LST" IF OUT.FILE$=""			      &
	\ OUT.FILE$="SY:"+OUT.FILE$  IF INSTR(1%,OUT.FILE$,":") = 0%	      &
	\ OUT.FILE$=OUT.FILE$+".LST" IF INSTR(1%,OUT.FILE$,".") = 0%	      &
	\ W%=1%								      &
	\ GOSUB 11000							      &
	\ EOLCR$ = ERAS.END.LIN$ + CRLF$				      &
		! SET FLAG IF SKIPPING BETWEEN DISK UNITS,		      &
		! FINISH MAKING A FILE NAME AND OPEN IT			      &
		! OUT.FILE$	OUTPUT FILE				      &
		! W% (= 1%)	OUTPUT CHANNEL				      &
		! SLEEP.TIME%	NUMBER OF SECONDS BETWEEN DISPLAYS	      &
		! EOLCR$	<EOL> <CR> <LF>				      &

1160	INPUT "Interval <60>"; Q$					      &
	\ SLEEP.TIME% = VAL(Q$)\ SLEEP.TIME%=60% IF LEN(CVT$$(Q$,-2%)) = 0%   &
	\ ACTUAL.TIME% = SLEEP.TIME%					      &
	\ PRPCT% = FNASK%("Percent mode")				      &
	\ PHYS% = FNASK%("Physical I/O only")				      &
	\ IF SLEEP.TIME% > 0% THEN					      &
		Q$=SYS(CHR$(6%)+CHR$(7%)) IF FNASK%("Detach")		      &
		! ACTUAL.TIME%	NUMBER OF SECONDS TO SLEEP		      &
		! PRPCT%	SET IF PRINTING DISK PERCENTAGE USAGE	      &
		! PHYS%		SET IF COLLECTING PHYSICAL I/O ONLY	      &

1200	PRINT #W%, CLR.SCR$;						      &
	\ Q$=SYS(CHR$(6%)+CHR$(-7%))					      &
	\ KBFLAG% = 1%							      &
	! GOSUB 20000							      &
	! GOSUB 21000							      &
	! GOSUB 22000							      &
	\ GOTO 2100							      &
		! CLEAR THE SCREEN, TRAP CTRL/C AND			      &
		! GET SOME STATS SO FIRST PASS DOESN'T LOOK SO WEIRD	      &
		! PRINT INITIAL STATISTICS IMMEDIATELY			      &
									      &

2000	!								      &
									      &
	!	S L E E P   A N D   G E T   T H E   N U M B E R S	      &

2010	IF KBFLAG% THEN							      &
		ACTUAL.TIME% = SLEEP.TIME%				      &
	ELSE	ACTUAL.TIME% = SLEEP.TIME%				      &
			- (INT(UPSECS + 0.5) - ACTUAL.TIME%)		      &
		! COMPUTE THE NUMBER OF SECONDS TO SLEEP FOR:		      &
		! KBFLAG% IS SET IF THERE WAS ANY TYPING DURING		      &
		! THE PREVIOUS PASS.  IF IT IS SET, RESET ACTUAL	      &
		! SLEEP TIME TO THE ORIGINAL VALUE.  IF (STILL) CLEAR,	      &
		! COMPUTE A NEW ACTUAL.TIME% SO THE DISPLAY TENDS	      &
		! TO COME AT THE REQUESTED INTERVAL.			      &

2020	KBFLAG% = 0%							      &
	\ GOSUB 11100\ SLEEP ACTUAL.TIME%\ GOSUB 11100			      &
		! CLEAR SLEEP FLAG AND ABSORB TYPING.			      &
		! THEN, SLEEP AND ABSORB TYPING AGAIN			      &

2100	!								      &
									      &
	!	C O L L E C T   S T A T I S T I C S			      &

2110	GOSUB 20000							      &
		! GET CPU STATISTICS					      &

2120	GOSUB 21000							      &
		! GET CACHE STATISTICS					      &

2130	GOSUB 22000							      &
		! GET DISK STATISTICS					      &

2190	IF MAXJOBS% <= 1% AND FILE.STATUS% = 0% THEN			      &
		PRINT #W%, CLR.SCR$; "No Logins -- shutting down"	      &
	\	CLOSE W%						      &
	\	GOTO 32767						      &
		! EXIT IF LOGINS ARE DISABLED AND OUTPUT IS TO DISK	      &
									      &

3000	!								      &
									      &
	!	P R I N T   I T   O U T					      &

3010	PRINT #W%, HOME1$; TODAY$; "  "; FNRJUST$(2%,HOURS%,48%); ":";	      &
			FNRJUST$(2%,MINUTES%,48%); ":";			      &
			FNRJUST$(2%,SECONDS%,48%); "  "; SYSTEM$; TAB(53%);   &
			FNRJUST$(6%,ERRORS,32%); " Errors"		      &
	\ PRINT #W%, FNRJUST$(3%,JOBS%,32%); "/";			      &
			FNRJUST$(2%,MAXJOBS%,32%); " Jobs";		      &
	\ Q%	= FNPPCT%(USER,UPTIME," User running ")			      &
		+ FNPPCT%(FIP.NEEDED,UPTIME," Fip needed")		      &
	\ IF UPSECS = 0.0 THEN						      &
		PRINT #W%, TAB(54%); "(Clock is frozen)"; EOLCR$;	      &
	ELSE	Q% = FNPVALX%(UPSECS,12%," Seconds"+EOLCR$)		      &
		! DO FIRST TWO LINES					      &

3020	  Q%	= FNPPCT%(NULL,UPTIME," Idle")				      &
		+ FNPPCT%(SYSTEM,UPTIME," SYS charged  ")		      &
		+ FNPPCT%(FIP.CPU,UPTIME," Fip in use     ")		      &
		+ FNPPCT%(CACHE.HITS,CACHE.ATTEMPTS,			      &
				" Cache hits"+CRLF$)			      &
	\ Q%	= FNPPCT%(LOST,UPTIME," Lost")				      &
		+ FNPPCT%(UNCHARGED,UPTIME," SYS uncharged")		      &
		+ FNPPCT%(IO,UPTIME," I/O service    ")			      &
		+ FNPPCT%(CACHE.CPU,UPTIME," Cache CPU"+CRLF$)		      &
	\ Q%	= FNPVALX%(KBOUT/UPSECS,18%," Char/sec out")		      &
		+ FNPVALX%(KBIN /UPSECS, 8%," Char/sec in") IF UPSECS > 0.0   &
	\ PRINT #W%, TAB(53%);  FNRJUST$(6%,MIN.SMALL%,32%); " Min sml buff"  &
									      &

3100	!								      &
									      &
	!	P R I N T   D I S K   S T A T I S T I C S		      &

3110	PRINT #W%, TAB(7%);"Access";TAB(40%+WIDE%);"Blocks"		      &
	\ PRINT #W%, "Disk   per sec Total";				      &
	\ PRINT #W%, " Reads"; IF WIDE%					      &
	\ PRINT #W%,                     " Direct User SwpSys";		      &
	\ PRINT #W%,       " per sec Total Direct User SwpSys"		      &
	\ DISK$=""							      &
	\ LINE.COUNT% = 7%						      &

3120	FOR U%=START.DISK% TO MAX.UNIT%					      &
	\	GOTO 3170 IF UPSECS = 0.0 OR DSK.MNT%(U%)<>0% IF NO.MOUNT%    &
	\	GOTO 3210 IF LINE.COUNT% >= LINES% - 2% IF OPTIMIZE%	      &
	\	IF SKIPPING% AND					      &
		 (LEFT(DISK$,2%) <> LEFT(DISK$(U%),2%)) THEN		      &
			PRINT #W%					      &
	\		LINE.COUNT% = LINE.COUNT% + 1%			      &
	\	END IF							      &
	\	DISK$=DISK$(U%)						      &
	\	PRINT #W%, DISK$; TAB(6%);				      &
	\	GOTO 3160 IF UPSECS = 0.0 OR DSK.MNT%(U%)<>0%		      &
	\	Q%	= FNPVAL%(A(U%)/UPSECS,9%)			      &
	\	GOTO 3160 IF A(U%) = 0.0				      &
	\	Q% = FNPPCT%(A(U%),A,"")				      &
	\	Q% = FNPPCT%(R(U%),A(U%),"") IF WIDE%			      &
	\	IF PRPCT% THEN						      &
			Q% = FNPPCT%(DIR.IO(U%,0%),A(U%),"")		      &
			+ FNPPCT%(USERIO(U%,0%),A(U%),"")		      &
			+ FNPPCT%(SWAPIO(U%,0%),A(U%),"")		      &
			+ FNPVAL%(B(U%)/UPSECS,10%)			      &
			+ FNPPCT%(B(U%),B,"")				      &
			+ FNPPCT%(DIR.IO(U%,1%),B(U%),"")		      &
			+ FNPPCT%(USERIO(U%,1%),B(U%),"")		      &
			+ FNPPCT%(SWAPIO(U%,1%),B(U%),"")		      &
	\		GOTO 3160					      &
		! PRINT PERCENTAGES IF REQUESTED			      &

3130		Q% = FNPVAL%(DIR.IO(U%,0%)/UPSECS,-7%)			      &
		+ FNPVAL%(USERIO(U%,0%)/UPSECS,-7%)			      &
		+ FNPVAL%(SWAPIO(U%,0%)/UPSECS,-7%)			      &
	  	+ FNPVAL%(B(U%)/UPSECS,10%)				      &
		+ FNPPCT%(B(U%),B,"")					      &
		+ FNPVAL%(DIR.IO(U%,1%)/UPSECS,7%)			      &
		+ FNPVAL%(USERIO(U%,1%)/UPSECS,-7%)			      &
		+ FNPVAL%(SWAPIO(U%,1%)/UPSECS,7%)			      &

3160		PRINT #W%, EOLCR$;					      &
\		LINE.COUNT% = LINE.COUNT% + 1%				      &

3170	NEXT U%								      &
									      &

3210	PRINT #W%, ERAS.END.LIN$					      &
	\ PRINT #W%, "Totals"; TAB(6%);					      &
	\ IF UPSECS = 0.0 THEN						      &
		PRINT #W%, ERAS.END.LIN$;				      &
	\	GOTO 3250						      &
		! PRINT LEFT MARGIN AND MAYBE NOTHING ELSE		      &

3220	Q% = FNPVAL%(A/UPSECS,9%)					      &
	\ GOTO 3250 IF A = 0.0						      &
	\ PRINT #W%, TAB(20%);						      &
	\ Q% = FNPPCT%(READS,A,"") IF WIDE%				      &
	\ IF PRPCT% THEN						      &
		Q% = FNPPCT%(DIR.ACC,A,"")				      &
		+ FNPPCT%(USERACC,A,"")					      &
		+ FNPPCT%(SWAPACC,A,"")					      &
		+ FNPVAL%(B/UPSECS,10%)					      &
	\	PRINT #W%, TAB(53%+WIDE%);				      &
	\	Q% = FNPPCT%(DIR.BLK,B,"")				      &
		+ FNPPCT%(USERBLK,B,"")					      &
		+ FNPPCT%(SWAPBLK,B,"")					      &
	\	GOTO 3250						      &
		! PRINT SUMMARY PERCENTAGES				      &

3230	Q%	= FNPVAL%(DIR.ACC/UPSECS,-7%)				      &
		+ FNPVAL%(USERACC/UPSECS,-7%)				      &
		+ FNPVAL%(SWAPACC/UPSECS,-7%)				      &
	  	+ FNPVAL%(B/UPSECS,10%)					      &
	  \ PRINT #W%, TAB(53%+WIDE%);					      &
	  \ Q%	= FNPVAL%(DIR.BLK/UPSECS,-7%)				      &
		+ FNPVAL%(USERBLK/UPSECS,-7%)				      &
		+ FNPVAL%(SWAPBLK/UPSECS,-7%)				      &
		! FINISH OFF WITH SOME TOTALS				      &

3250	PRINT #W%, ERAS.END.SCR$; HOME2$;				      &
	\ IF SLEEP.TIME% THEN						      &
		GOTO 2000						      &
	ELSE	CLOSE W%						      &
	\	GOTO 32767						      &
		! CONTINUE IF NON-ZERO SLEEP, ELSE EXIT			      &

10000	!								      &
									      &
	!	G E T   D I S K   N A M E S				      &

10010	DEVICES%,D%=0%							      &
		! GET SOME INTERNAL POINTERS:				      &
		! DEVCNT%	HOW MANY UNITS PER DISK TABLE		      &
		! DEVNAM%	DEVICE NAME TABLE			      &
		! DEV0KB%	HOW MANY DEVICES TIMES 2%		      &
		! DEVICES%	HOW MANY DIFFERENT DISKS		      &

10030	FOR DEV%=0% TO DEV0KB%-2% STEP 2%				      &
	\	Q%=PEEK(DEVNAM%+DEV%)					      &
	\	Q$=CHR$(Q% AND 255%)+CHR$(SWAP%(Q%) AND 255%)		      &
	\	DEVICES%=DEVICES%+1% IF PEEK(DEV%+DEVCNT%) >= 0%	      &
	\	FOR UNIT%=0% TO PEEK(DEV%+DEVCNT%)			      &
	\		DISK$(D%)=Q$+NUM1$(UNIT%)+":"			      &
	\		D%=D%+1%					      &
		! FOR EACH DISK DEVICE,					      &
		! Q$		DISK CONTROLLER NAME			      &
		! FOR EACH UNIT IN THIS DEVICE, ...			      &
		! DISK$()	 THE DEVICE/UNIT NAME,			      &
									      &

10050		NEXT UNIT%						      &
	\ NEXT DEV%							      &
		! DO THEM ALL						      &

10060	RETURN								      &

10500	D%=0%								      &
	\ UNTCNT%=H0%(19%)						      &
	\ FOR DEV%=0% TO DEV0KB%-2% STEP 2%				      &
	\	FOR UNIT%=0% TO PEEK(DEV%+DEVCNT%)			      &
	\		DSK.MNT%(D%)=0%					      &
	\		DSK.MNT%(D%)=-1% IF PEEK(UNTCNT%)<0%		      &
	\		D%=D%+1%					      &
	\		UNTCNT%=UNTCNT%+2%				      &
		! FOR EACH DISK DEVICE,					      &
		!	FOR EACH UNIT IN THIS DEVICE, ...		      &
		!	  DSK.MNT%() = -1 IF THE DISK IS DISMOUNTED.	      &
	\	NEXT UNIT%						      &
	\ NEXT DEV%							      &
		! DO THEM ALL						      &

10510	RETURN								      &
									      &

11000	!								      &
									      &
	!	O P E N   O U T P U T   F I L E				      &

11010	ON ERROR GOTO 11050						      &
	\ IF LEFT(OUT.FILE$,2%)="KB"					      &
	  THEN OPEN OUT.FILE$ FOR OUTPUT AS FILE W%, MODE 4%		      &
	  ELSE OPEN OUT.FILE$ FOR OUTPUT AS FILE W%			      &
		! OPEN THE FILE, SCOPE MODE IF IT'S A TERMINAL		      &
									      &

11020	FILE.STATUS%=STATUS AND 255%					      &
	\ GOSUB 25100							      &
	\ IF FILE.STATUS% <> 2% THEN					      &
		KB.NUMBER%=-1%						      &
	ELSE	Q%=PEEK(PEEK(PEEK(520%))+(W%*2%)) + 2%			      &
	\	KB.NUMBER%=SWAP%(PEEK(Q%)) AND 255%			      &
		! GET THE KB: NUMBER IF IT'S A TERMINAL			      &

11030	ON ERROR GOTO 19000						      &
	\ RETURN							      &

11050	RESUME 11030 IF RESTART%					      &
	\ GOTO 19000							      &
		! HANDLE "FILE OPEN" ERROR WHEN RESTARTING		      &

11100	!								      &
									      &
	!	A B S O R B   T E R M I N A L   I N P U T		      &

11110	WHILE KB.NUMBER% >= 0%						      &
	\	ON ERROR GOTO 11150					      &
	\	GET #W%, RECORD 8192%					      &
	\	KBFLAG% = 1%						      &
	\	FIELD #W%, RECOUNT AS Q1$				      &
	\	Q1$ = CVT$$(Q1$,-2%)					      &
	\	Q$ = LEFT(Q1$, 1%)					      &
	\	Q1$ = RIGHT(Q1$,2%)					      &
	\	PRINT #W%, CLR.SCR$; IF Q$ = "C"			      &
	\	PRPCT% = 1% IF Q$ = "%"					      &
	\	PRPCT% = 0% IF Q$ = "V"					      &
	\	PHYS% = -1% IF Q$ = "P"					      &
	\	PHYS% =  0% IF Q$ = "R"					      &
	\	NO.MOUNT% =  0% IF Q$ = "N"				      &
	\	NO.MOUNT% = -1% IF Q$ = "M"				      &
	\	START.DISK% = VAL(Q1$) IF (Q$ = "D") AND (LEN(Q1$) > 0%)      &
	\	START.DISK% = 0%       IF (Q$ = "D") AND (LEN(Q1$) = 0%)      &
	\	START.DISK% = MAX.UNIT% IF START.DISK% > MAX.UNIT%	      &
	\ NEXT								      &
		! GET ALL INPUT, LOOK FOR "CLEAR SCREEN"		      &
		! OR DISPLAY CHANGER:					      &
		! TYPE:	C	CLEAR SCREEN				      &
		!	%	PERCENT DISPLAY				      &
		!	V	VALUE DISPLAY				      &
		!	P	PHYSICAL I/O				      &
		!	R	ALL REQUESTS				      &
		!	Dn	Disk unit number to start		      &
									      &

11120	ON ERROR GOTO 19000						      &
	\ RETURN							      &
		! NO MORE TYPEIN					      &

11150	GOTO 19000 IF ERR=28%						      &
	\ RESUME 11120							      &
		! HANDLE TYPEIN ERROR CONDITIONS			      &
									      &

12000	!								      &
									      &
	!	P R I N T O U T   F U N C T I O N S			      &

12100	DEF* FNRJUST$(T%,V,F%)						      &
	!								      &
									      &
	!	F N R J U S T $ ( S I Z E % , V A L U E , F I L L % )	      &
									      &
		!							      &
		! FNRJUST$(T%,V,F%)					      &
		!		RETURN V AS A STRING RIGHT-JUSTIFIED	      &
		!		IN A T% FIELD.				      &
		!		FILL THE FIELD WITH CHR$(F%).		      &
		!							      &

12120	Q$=NUM1$(INT(V))						      &
	\ FNRJUST$=STRING$(T%-LEN(Q$),F%)+Q$				      &

12130	FNEND								      &

12200	DEF* FNPVAL%(V,S%)						      &
	!								      &
									      &
	!	F N P V A L % ( V A L U E , S I Z E % )			      &
									      &
		!							      &
		! FNPVAL%(V,S%)						      &
		!		PRINT V RIGHT-JUSTIFIED IN AN S%-1% BYTE      &
		!		FIELD.  PRINT JUST BLANKS IF		      &
		!		S% < 0% AND V < 0.1.			      &
		!							      &

12220	V = INT(V*10.0 + .5)						      &
	\ IF S% < 0% THEN						      &
	  S% = -S%							      &
	  \ IF V < 1.0 THEN						      &
	    PRINT #W%, SPACE$(S% - 1%);					      &
	    \ GOTO 12240						      &
		! DO THE SPECIAL (DISK) PRINT THING			      &

12230	Q$=NUM1$(V/10. + .01)						      &
	\ PRINT #W%, SPACE$(S%-LEN(Q$)); LEFT(Q$,LEN(Q$)-1%);		      &

12240	FNEND								      &
									      &

12300	DEF* FNPPCT%(D,Q,T$)						      &
	!								      &
									      &
	!	F N P P C T % ( D I V I D E N D , D I V I S O R ,	      &
	!				 T E X T $ )			      &
									      &
		!							      &
		! FNPPCT%(D,Q,T$)					      &
		!		PRINT D/Q AS A PERCENTAGE.		      &
		!		TEXT T$ FOLLOWS				      &
		!							      &

12320	IF Q = 0.0 THEN							      &
		PRINT #W%, "   **%";T$;					      &
	ELSE	Q$=NUM1$(INT(D/Q*100.+.5)+.1)				      &
	\	Q$="0.1" IF Q$=".1"					      &
	\	PRINT #W%, SPACE$(7%-LEN(Q$)); LEFT(Q$,LEN(Q$)-2%);"%";T$;    &

12330	FNEND								      &

12400	DEF* FNPVALX%(V,S%,T$)						      &
		!							      &
									      &
		!	F N P V A L X % ( V A L U E , S I Z E % , T E X T $ ) &
									      &
			! FNPVALX%(V,S%,T$)				      &
			!		PRINT V RIGHT-JUSTIFIED IN AN	      &
			!		S%-1% BYTE FIELD.  PRINT JUST BLANKS  &
			!		IF S% < 0% AND V < 0.1.  FOLLOW	      &
			!		WITH TEXT T$.			      &
			!						      &

12410	FNPVALX% = FNPVAL%(V, S%)					      &
	\ PRINT #W%, T$;						      &

12420	FNEND								      &

13000	DEF* FNV(Q%)							      &
	!								      &
									      &
	!	F N V ( A D D R E S S % )				      &
									      &
		!							      &
		! FNV(Q%)	RETURN A PEEKED VALUE			      &

13020	Q=PEEK(Q%)							      &
	\ Q=Q+65536.0 IF Q < 0.0					      &
	\ FNV=PEEK(Q%+2%)*65536.0+Q					      &
		! GET THE VALUE						      &

13030	FNEND								      &
									      &

13040	DEF* FNVDISK(Q%)						      &
	!								      &
									      &
	!	F N V D I S K ( A D D R E S S % )			      &
									      &
		!							      &
		! FNVDISK(Q%)	RETURN A PEEKED VALUE FROM THE DISK STATS     &

13050	Q=DSKPEK(DISK%,Q%+2)						      &
	\ Q=Q+65536.0 IF Q < 0.0					      &
	\ FNVDISK=DSKPEK(DISK%,Q%+4%)*65536.0+Q				      &
		! GET THE VALUE						      &

13060	FNEND								      &
									      &

13100	DEF* FNP(C%)							      &
	!								      &
									      &
	!	F N P ( A C C E S S _ T Y P E % )			      &
									      &
		!							      &
		! FNP(C%)	RETURN A DISK ENTRY:			      &
		!		C%	ACCESS TYPE (0-5)		      &
		!			  0	SWAPS			      &
		!			  1	USER			      &
		!			  2	SATT			      &
		!			  3	OVERLAY			      &
		!			  4	DIRECTORY		      &
		!			  5	DECTAPE BUFFER		      &
		!		U%	UNIT NUMBER (GLOBAL)		      &
		!		I%	READ/WRITE INDEX (GLOBAL) (0-5)	      &
		!			  0	READ MISS ACCESSES	      &
		!			  1	READ MISS BLOCKS	      &
		!			  2	WRITE     ACCESSES	      &
		!			  3	WRITE     BLOCKS	      &
		!			  4	READ HIT  ACCESSES	      &
		!			  5	READ HIT  BLOCKS	      &

13120	Q%=(C%*UNITS%+U%)*6% + I%					      &
	\ Q=FNVDISK(4%*Q%)\ FNP=Q-DISK(Q%)\ DISK(Q%)=Q			      &

13130	FNEND								      &

13200	DEF* FNC(Q%)							      &
	!								      &
									      &
	!	F N C ( A D D R E S S % )				      &
									      &
		!							      &
		! FNC(Q%)	RETURN CPU DATUM			      &

13220	Q=FNV(CPU%+Q%)\ FNC=Q-EXEC(Q%/2%)\ EXEC(Q%/2%)=Q		      &

13230	FNEND								      &

13300	DEF* FNI(Q%)							      &
	!								      &
									      &
	!	F N I ( A D D R E S S % )				      &
									      &
		!							      &
		! FNI(Q%)	RETURN PEEKED LOCATION AS AN UNSIGNED	      &
		!		FLOATING-POINT NUMBER			      &

13310	FNI, Q = PEEK(Q%)						      &
	\ FNI = Q + 65536.0 IF Q < 0.0					      &

13320	FNEND								      &
									      &

14000	DEF* FNASK%(PROMPT$)						      &
	!								      &
									      &
	!	F N A S K % ( P R O M P T $ )				      &
									      &
		! FNASK%(PROMPT$)	RETURN YES OR NO		      &
									      &

14010	PRINT PROMPT$; " (Yes/No) <No>";\ INPUT LINE Q$			      &
	\ Q$ = CVT$$(Q$,-2%)\ Q$ = "N" IF Q$ = ""			      &
	\ IF Q$ = LEFT("YES", LEN(Q$)) THEN FNASK% = -1%		      &
	  ELSE IF Q$ = LEFT("NO", LEN(Q$)) THEN FNASK% = 0%		      &
	  ELSE PRINT "?Please answer Yes or No"\ GOTO 14010		      &
		! DO IT							      &

14020	FNEND								      &

18000	DEF* FNE$(Q%) =							      &
	  CVT$$(RIGHT(SYS(CHR$(6%)+CHR$(9%)+CHR$(Q%)),3%),4%)		      &
	!								      &
									      &
	!	F N E $ ( C O D E % )					      &
									      &
		!							      &
		! FNE$(Q%)	RETURN ERROR MESSAGE TEXT		      &

19000	!								      &
									      &
	!	F A T A L   E R R O R					      &

19010	IF ERR=28% THEN							      &
	  RESUME 32767 IF RESTART%					      &
	  \ Q$=SYS(CHR$(6%)+CHR$(-7%))\ RESUME 19100			      &
		! CTRL/C TRAP, EXIT IF LOOPING				      &

19015	RESUME 32767 IF ERR=11% AND (ERL=1110% OR ERL=1160% OR ERL=14010%)    &

19020	IF ERL = 1160 THEN						      &
	  PRINT "%Input a number"					      &
	  \ RESUME 1160							      &
		! VAL CONVERSION ERROR					      &

19030	E%=ERR\ E1%=ERL\ RESUME 19040					      &

19040	PRINT								      &
	\ PRINT "STATUS "; VERSION$; " Fatal error"; E%; " at line"; E1%;     &
			" -- ";FNE$(E%);", ";TIME$(0%)			      &
		! GIVE UP						      &

19050	CLOSE W%							      &
	\ GOTO 32767							      &
									      &

19100	!								      &
									      &
	!	C T R L / C   H A N D L E R				      &

19110	CLOSE W%\ GOTO 32767 IF KB.NUMBER% < 0%				      &
	\ Q$=SYS(CHR$(6%)+CHR$(-5%)+CHR$(KB.NUMBER%)			      &
		+ CLR.SCR$+CRLF$+"    The terminal is all yours now."	      &
		+ CRLF$+CRLF$)						      &
	\ RESTART%=1%							      &
		! CLOSE UP FOR NOW, AND INFORM THE OPERATOR		      &
		! THEN, SET UP FOR RESTART				      &

19120	Q%=PEEK(PEEK(PEEK(520%)))					      &
	\ IF (PEEK(518%) AND 255%) <> (PEEK(Q%+W%*2%) AND 255%)		      &
			OR (PEEK(Q%+6%) AND 8192%) = 0%			      &
	  THEN SLEEP 15%\ GOTO 19200					      &
		! Q% => CONSOLE KB: DDB					      &
		! IF SOMEONE ELSE HAS IT OR IT'S NOT A CONSOLE,		      &
		! WE MUST WAIT A WHILE					      &

19130	KB.NUMBER%=SWAP%(PEEK(Q%+2%)) AND 255%				      &
	\ GOTO 32767 UNLESS FNASK%("Continue detached")			      &
	\ GOSUB 25000\ Q$=SYS(CHR$(6%)+CHR$(7%))\ GOSUB 25100		      &
		! WE'RE ATTACHED, STOP OR DETACH AS DESIRED		      &

19200	Q%=PEEK(H0%(7%)+H1%(9%))					      &
	\ Q%=Q%+2% WHILE (SWAP%(PEEK(PEEK(Q%)+2%)) AND 255%) <> KB.NUMBER%    &
	\ GOTO 19120 IF (PEEK(PEEK(Q%)+2%) AND 255%) <> 0%		      &
	\ OUT.FILE$="KB"+NUM1$(KB.NUMBER%)+":STATUS.LST"		      &
	\ GOSUB 11000\ GOTO 19120 IF BUFSIZ(W%) = 0%			      &
	\ RESTART%=0%\ GOTO 1200					      &
		! CHECK IF THE TERMINAL HAS A JOB, IGNORE IF SO		      &
		! ALL SET TO GO, SETUP THE FILE NAME AND OPEN IT	      &
		! KEEP SLEEPING IF IT DIDN'T OPEN			      &
		! OK, NO MORE RESTARTING, SO CRANK IT UP		      &
									      &

20000	!								      &
									      &
	!	G E T   M O N I T O R   S T A T I S T I C S		      &
									      &
		! THIS SECTION COLLECTS ALL MONITOR STATISTICS		      &
		! AVAILABLE -- AND A FEW THAT AREN'T A PART OF		      &
		! THE MONITOR STATISTICS OPTION, BUT SEEM USEFUL.	      &

20010	UPTIME		= FNC(2%)		! TIME FOR THIS PROBE	      &
	\ UPSECS	= UPTIME/TICKS		! PROBE TIME IN SECONDS	      &
	\ MIN.SMALL%	= PEEK(CPU%+6%)		! MINIMUM SMALL BUFFERS	      &
	\ SYSTEM	= FNC(8%)		! MONITOR CHARGED TIME	      &
	\ LOST		= FNC(12%)		! LOST TIME		      &
	\ UNCHARGED	= FNC(16%)		! MONITOR UNCHARGED TIME      &
	\ NULL		= FNC(20%)		! IDLE TIME		      &
	\ USER		= UPTIME - SYSTEM - LOST - UNCHARGED - NULL	      &
						! USEFUL WORK		      &

20100	Q% = PEEK(H1%(13%))						      &
	\ JOBS%		= Q% AND 255%		! NUMBER OF RUNNING JOBS      &
	\ MAXJOBS%	= SWAP%(Q%) AND 255%	! MAXIMUM NUMBER OF JOBS      &
	\ HUNG.TTY	= FNI(H1%(11%))		! HUNG TERMINAL COUNT	      &
	\ ERRORS	= FNI(H1%(17%)) - HUNG.TTY ! TRUE ERRORS	      &

20200	FIP.NEEDED	= FNC(24%)		! FIP IN USE BY SOMEONE	      &
	! FIP.NOT.RUNNING = FNC(28%)		!! FIP NOT RUNNING	      &
	\ FIP.WAITING	= FNC(32%)		! FIP WAITING		      &
	! FIP.CODE.WAIT	= FNC(36%)		!! FIP WTG FOR OVERLAY CODE   &
	! FIP.DISK.WAIT	= FNC(40%)		!! FIP WTG FOR DISK TRANSFER  &
	! FIP.SAT.WAIT	= FNC(44%)		!! FIP WTG FOR SATT BLOCK     &
	! FIP.OTHER.WAIT = FNC(48%)		!! FIP WTG FOR SOMETHING ELSE &
	\ FIP.CPU = FIP.NEEDED - FIP.WAITING	! FIP CPU USAGE		      &

20300	CPU.PR(Q%)	= FNC(Q%*4% + 52%) FOR Q% = 0% TO 5%		      &
						! CPU HARDWARE PRIORITY LEVELS &
	\ IO		= CPU.PR(4%) + CPU.PR(5%)	! I/O SERVICE TIME    &
	! KW11P.OVERRUN	= FNI(CPU%+76%) 	!! CRYSTAL CLOCK OVERRUN      &
	\ CACHE.PR(Q%)	= FNC(Q%*4% + 78%) FOR Q% = 0% TO 5%		      &
						! CACHE CODE RUNNING AT TICK  &
	\ CACHE.CPU	= CACHE.PR(3%) + CACHE.PR(4%) + CACHE.PR(5%)	      &
						! CACHE CODE RUNNING	      &

20400	! PR6.PR7	= FNI(CPU%+102%)	!! NUMBER OF TIMES AT PR6/PR7 &
	! KW11P.DATE%	= PEEK(CPU%+104%) 	!! LAST KW11P OVERRUN DATE    &
	! KW11P.TIME%	= PEEK(CPU%+106%) 	!! LAST KW11P OVERRUN TIME    &
	! KW11P.SEC%	= PEEK(CPU%+108%) 	!! LAST KW11P OVERRUN SECOND  &

20500	KBIN		= FNC(110%)		! TERMINAL INPUT BYTES	      &
	\ KBOUT		= FNC(114%)		! TERMINAL OUTPUT BYTES	      &
									      &

20800	TODAY$ = DATE$(0%)						      &
	\ T.O.D = TIME(0%)						      &
	\ HOURS% = T.O.D / 3600.0					      &
	\ SECONDS% = T.O.D - (HOURS% * 3600.0)				      &
	\ MINUTES% = SECONDS% / 60%					      &
	\ SECONDS% = SECONDS% - (MINUTES% * 60%)			      &
		! DATE AND TIME AT PROBE:				      &
		! TODAY$	DATE RIGHT NOW				      &
		! HOURS%	HOURS AFTER MIDNITE			      &
		! MINUTES%	MINUTES IN THE HOUR			      &
		! SECONDS%	SECONDS IN THE MINUTE			      &

20990	RETURN				! END OF CPU STATISTICS		      &
									      &

21000	!								      &
									      &
	!	G E T   C A C H E   S T A T I S T I C S			      &
									      &
	! RETURN DIRECTORY CACHING STATISTICS				      &

21010	ATTEMPTS = FNV(CACHE%)		! CACHE SEARCHES ATTEMPTED
21020	HITS = FNV(CACHE%+8%)		! CACHE SEARCHES SUCCESSFUL
21030	CACHE.ATTEMPTS = ATTEMPTS - OLD.ATTEMPTS			      &
	\ OLD.ATTEMPTS = ATTEMPTS	! SEARCHES THIS PROBE
21040	CACHE.HITS = HITS - OLD.HITS					      &
	\ OLD.HITS = HITS		! SUCCESSES THIS PROBE		      &

21990	RETURN								      &
									      &

22000	!								      &
									      &
	!	G E T   D I S K   S T A T I S T I C S			      &
									      &
	! COLLECT ALL DISK STATISTICS (IN DISK()) AND			      &
	! THE ONE'S WE WANT IN THE VARIOUS VECTORS			      &

22010	A,B,READS,USERACC,USERBLK,DIR.ACC,DIR.BLK,SWAPACC,SWAPBLK=0.0	      &
	\ GOSUB 10500							      &
	\ FOR U%=0% TO MAX.UNIT%					      &
	\	A(U%),B(U%),R(U%),USERIO(U%,0%),USERIO(U%,1%),		      &
			      DIR.IO(U%,0%),DIR.IO(U%,1%),		      &
			      SWAPIO(U%,0%),SWAPIO(U%,1%)=0.0		      &
	\	GOTO 22040 IF DSK.MNT%(U%)				      &
	\	FOR I%=0% TO 5%						      &
		! CLEAR BUFFERS						      &
		! CHECK TO SEE WHICH DISKS ARE MOUNTED. (<>0 MEANS DISMOUNTED) &
		! A	  B		TOTAL ACCESSES, BLOCKS		      &
		! USERACC USRBLK	TOTAL USER ACCESSES, BLOCKS	      &
		! DIR.ACC DIR.BLK	TOTAL DIRECTORY ACCESSES, BLOCKS      &
		! SWAPACC SWAPACC	TOTAL SWAP ACCESSES, BLOCKS	      &
		! A()			ACCESSES PER UNIT		      &
		! B()			BLOCKS TRANSFERRED PER UNIT	      &
		! R()			READS PER UNIT			      &
		! U(,0)			UNIT READ MISS ACCESSES		      &
		! U(,1)			UNIT READ MISS BLOCKS		      &
		! U(,2)			UNIT WRITE     ACCESSES		      &
		! U(,3)			UNIT WRITE     BLOCKS		      &
		! U(,4)			UNIT READ HIT  ACCESSES		      &
		! U(,5)			UNIT READ HIT  BLOCKS		      &
		! USERIO()		USER DATA			      &
		! DIR.IO()		DIRECTORY DATA			      &
		! SWAPIO()		SWAP DATA			      &
		! THE SECOND DIMENSION OF USERIO(), DIR.IO() AND	      &
		! SWAPIO() DEFINES THE READ/WRITE PROCESS:		      &
		!	(,0)	READ/WRITE TRANSFERS			      &
		!	(,1)	READ/WRITE BLOCKS			      &

22020			SWAPIO=FNP(0%)\ USERIO=FNP(1%)\ SATTIO=FNP(2%)	      &
	\		OVERIO=FNP(3%)\ DIR.IO=FNP(4%)\ BUFFIO=FNP(5%)	      &
	\		U(U%,I%)=SWAPIO+USERIO+SATTIO+OVERIO+DIR.IO+BUFFIO    &
	\		IF (I% < 4%) OR (NOT PHYS%) THEN		      &
				Q%=(I% AND 1%)				      &
	\			USERIO(U%,Q%)=USERIO(U%,Q%)+USERIO	      &
	\			DIR.IO(U%,Q%)=DIR.IO(U%,Q%)+DIR.IO	      &
	\			SWAPIO(U%,Q%)=SWAPIO(U%,Q%)+SWAPIO+SATTIO+    &
					BUFFIO+OVERIO			      &
		! COLLECT DISK STATISTICS, COMBINING READ AND WRITE DATA      &
		! FOR USER, DIRECTORY, AND SWAP/SYS ACCESS COUNTS.	      &

22030		NEXT I%							      &
	\	A(U%)=A(U%) + U(U%,0%)+U(U%,2%)				      &
	\	B(U%)=B(U%) + U(U%,1%)+U(U%,3%)				      &
	\	R(U%)=R(U%) + U(U%,0%)					      &
	\	IF NOT PHYS% THEN					      &
			A(U%)=A(U%) + U(U%,4%)				      &
	\		B(U%)=B(U%) + U(U%,5%)				      &
	\		R(U%)=R(U%) + U(U%,4%)				      &

22035		A=A+A(U%) \ B=B+B(U%) \ READS=READS + R(U%)		      &
	\	USERACC=USERACC+USERIO(U%,0%)				      &
	\	USERBLK=USERBLK+USERIO(U%,1%)				      &
	\	DIR.ACC=DIR.ACC+DIR.IO(U%,0%)				      &
	\	DIR.BLK=DIR.BLK+DIR.IO(U%,1%)				      &
	\	SWAPACC=SWAPACC+SWAPIO(U%,0%)				      &
	\	SWAPBLK=SWAPBLK+SWAPIO(U%,1%)				      &
		! AND GET THE TOTALS					      &

22040	NEXT U%								      &
		! FOR ALL UNITS						      &

22990	RETURN								      &
									      &

25000	!								      &
									      &
	!	P R I V I L E G E   D R O P P E R			      &

25010	Q$=SYS(CHR$(6%)+CHR$(-21%)+CHR$(-1%))				      &
	\ RETURN							      &
		! DROP PRIVILEGES TEMPORARILY				      &

25100	!								      &
									      &
	!	R E G A I N   P R I V I L E G E S			      &

25110	Q$=SYS(CHR$(6%)+CHR$(-21%)+CHR$(0%))				      &
	\ RETURN							      &
		! REGAIN DROPPED PRIVILEGES				      &

32767	END
