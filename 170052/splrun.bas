2!		PROGRAM		: SPLRUN.BAS
5!		VERSION		: V10.1
6!		EDIT		: A
7!		EDIT DATE	: 10-MAY-91
8!
10		EXTEND		! EXTEND
11	! &
	&
	&
	!		  C O P Y R I G H T &
	&
	&
  !		      Copyright (C) 1976, 1991 by &
  !	        Digital Equipment Corporation, Maynard, Mass. &
  !	&
  !	&
  !	This software is furnished under a license and may be used and &
  !	copied  only  in accordance with the terms of such license and &
  !	with the  inclusion  of  the  above  copyright  notice.   This &
  !	software  or  any  other copies thereof may not be provided or &
  !	otherwise made available to any other person.  No title to and &
  !	ownership of the software is hereby transferred. &
  !	&
  !	The information in this software is subject to change  without &
  !	notice  and should not be construed as a commitment by Digital &
  !	Equipment Corporation. &
  !	&
  !	DIGITAL assumes no responsibility for the use  or  reliability &
  !	of its software on equipment that is not supplied by DIGITAL. &
  !	&
  !*******************************************************************
20	! &
	&
	&
	!	M O D I F I C A T I O N    H I S T O R Y &
	&
	&

21	! VER/ED	EDIT DATE	REASON &
	! 9.3		10-NOV-86	ADD UNDERSCORE TO NL:'S &
	! 10.0		05-Oct-89	Make V8 patch 14.10.1 use FETPAT &
	!				syscall &
	! V10.0		05-Apr-90	Allow patch change on the fly &
	! &

901	DIM #1%,Z0%(32767%,63%) &
	\ DIM #1%,Z0$(32767%)=128% &
	\ DIM #1%,Z1$(3%)=256% &
	\ DIM S%(30%) &
	\ DIM #4%,BIGLTR%(6%,39%) &
	\ DIM Z%(30%) &
	\ DIM Z1%(30%) &
	\ DIM M%(5%) &
	\ DIM H$(6%),H%(6%) &
	\ DIM CTLTBL%(3%),CTLTBL$(3%) &
				!  Z0%(X,Y) - WORK-FILE, PRIMARY. &
	&
				! Z0$(X) - &
				! SECOND DIMENSION ON THE WORK-FILE FOR &
				!  THE LONG CONTIGUOUS STRINGS USED IN &
				!  XLATE ROUTINE. &
	&
				! S%(X) - &
				! INTERNAL STACK. &
	&
				! BIGLTR%(X,Y) - &
				! USED FOR THE BLOCK PRINT CHARACTER &
				!  PATTERNS FROM 'SY:$CHARS.QUE'. &
	&
				! Z%(X) - &
				! USED BY FNP%() FOR RETURN OF DATA &
	&
				! Z1%(X) - &
				! USED BY FNP%() FOR TEMPORARY STORAGE &
	&
				! M%(X) - &
				! USED BY THE POLLING ROUTINES TO HOLD &
				!  THE HEAD AND TAIL POINTERS FOR THE &
				!  FOLLOWING LISTS : &
				!	M%(0%)	- HEAD OF INCOMPLETE &
				!		   LIST &
				!	   1%	- TAIL OF LIST &
				!	   2%	- HEAD OF COMPLETE LIST &
				!	   3%	- TAIL OF LIST &
				!	   4%	- HEAD OF UNPROCESSED &
				!		   LIST &
				!	   5%	- TAIL OF LIST &
	&
				! H$(X),H%(X) - &
				! THESE TWO ARRAYS ARE USED TO &
				!  GENERATE THE SPLATS. &
	&
				! CTLTBL%(X),CTLTBL$(X) - &
				! THESE TWO TABLES ARE USED IN THE &
				!  FORMATTING ROUTINES TO KEEP TRACK OF &
				!  THE NUMBER OF VARIOUS KINDS OF &
				!  CONTROL CHARS NEEDED TO GET TO THE &
				!  APPROPRIATE LINE ON A PAGE.  THE &
				!  STRING ARRAY CONTAINS THE STRING &
				!  CHARACTERS WHICH ARE PUT INTO THE &
				!  BUFFER, AS FOLLOWS : &
				!	CTLTBL(0%) -	<CR> - CHR$(13%) &
				!	       1%  -	<FF> - CHR$(12%) &
				!	       2%  -	LPFORM-TYPE &
				!			 FORM-FEED - &
				!			 CHR$(128%) &
				!	       3%  -	<LF> - CHR$(10%) &
				! THE CTLTBL%() VALUES ARE SET UP BY THE &
				!  ROUTINE AT LINE 13500 (AND IN A FEW &
				!  OTHER PLACES WHERE IT IS UNDESIRABLE &
				!  TO CALL THE 13500 ROUTINE).  EACH &
				!  VALUE IN THE TABLE DEFINES HOW MANY &
				!  OF THE CORRESPONDING CHARACTERS TO &
				!  GENERATE INTO THE OUTPUT BUFFER.  FOR &
				!  EXAMPLE, IF CTLTBL%(0%) IS 1, AND &
				!  CTLTBL%(3%) IS 1, THEN THE GENERATION &
				!  ROUTINE (AT LINE 14000) WILL GENERATE &
				!  1 CARRIAGE-RETURN AND 1 LINE-FEED &
				!  INTO THE OUTPUT BUFFER.  THE VARIABLE &
				!  'CTLLEN%' IS USED TO KEEP TRACK OF &
				!  HOW MANY CHARACTERS, TOTAL, REMAIN TO &
				!  BE GENERATED. &

1000	ON ERROR GOTO 19000 &
	\ UU0$=CHR$(6%)+CHR$(26%)+CHR$(0%)+CHR$(0%) &
	\ UU1$=CHR$(6%)+CHR$(26%)+CHR$(0%)+CHR$(1%) &
		! SET UP STANDARD ERROR TRAP. &

1010	I$="V10.1-A" &
	\ IF E0% = 0% &
	THEN &
		S$ = SYS(CHR$(6%)+CHR$(9%)+CHR$(0%)) &
	\	PRINT	IF CCPOS(0%) &
	\	PRINT "SPLRUN   ";I$;"   "; &
			CVT$$(RIGHT(S$,3%),4%) &
		! SET UP VERSION/EDIT # &
		! IF AN ERROR, THEN PRINT PROGRAM HEADER &

1020	CHANGE SYS(CHR$(12%)) TO Z% &
	\ PKG.LOC$="OPSER$:" &
	\ IF Z%(3%)+SWAP%(Z%(4%))<>15%*2% THEN &
		PRINT "?SPLRUN must be COMPILED" &
	\	GOTO 32767 &
		! USE LOGICAL FOR PACKAGE LOCATION &
		! ISSUE AN ERROR IF IT WAS NOT A COMPILED FILE. &

1030	IF E0%<>2% THEN &
		PRINT "?Illegal entry - Please 'RUN " + PKG.LOC$ + "SPOOL'" &
	\	GOTO 32767 &
		! THE ONLY LEGAL ENTRY TO THIS PROGRAM IS A CHAIN ENTRY, &
		! SO GIVE AN ERROR IF THAT WASN'T THE WAY WE ENTERED. &
	&

1040	S$ = "SPLRUN   " + I$ &
	\ S% = -1% &
	\ JOB.ERR% = 0% &
	&
	\ CHR0$   = CHR$(  0%) &
	\ CHRM1$  = CHR$( -1%) &
	\ CHR6$   = CHR$(  6%) &
	\ CHR7$	  = CHR$(  7%) &
	\ CHR10$  = CHR$( 10%) &
	\ CHR13$  = CHR$( 13%) &
	\ CHRM21$ = CHR$(-21%) &
	\ CHR128$ = CHR$(128%) &
	\ CHR129$ = CHR$(129%) &
	\ CHR130$ = CHR$(130%) &
	\ CHR131$ = CHR$(131%) &
	\ CHR6.9$	= CHR6$+CHR$(9%) &
	\ CHR6.M10$	= CHR6$+CHR$(-10%) &
	\ CHR6.18$	= CHR6$+CHR$(18%) &
	\ CHR6.M21.0$	= CHR6$+CHRM21$+CHR0$ &
	\ CHR6.M21.M1$	= CHR6$+CHRM21$+CHRM1$ &
	\ CVT4.0$ = STRING$(4%,0%) &
	&
	! INITIALIZE STACK POINTER &
	! USEFUL LITERAL STRINGS &

1050	OPEN PKG.LOC$+"CHARS.QUE" FOR INPUT AS FILE 4%, MODE 8192% &
		! OPEN THE CHARACTER PATTERN FILE. &

1600	RTYP.OFF%=5% &
	\ RATT.OFF%=6% &
	\ RSIZ.OFF%=7% &
	\ HIBK.OFF%=11% &
	\ EFBK.OFF%=15% &
	\ FFBY.OFF%=17% &
	&
	\ ASCIZ%=0% &
	\ FIXED%=1% &
	\ VARIAB%=2% &
	&
	\ FORTRN%=1% &
	\ IMPLID%=2% &
	\ EMBEDD%=0% &
	&
	\ LPINDX%=8% &
	\ KBINDX%=2% &
		! SET UP CONSTANTS FOR THE RECORD DE-BLOCKING AND &
		! CARRIAGE CONTROL FORMATTING ROUTINES : &
		!	RTYP.OFF%	(FCS)	RECORD TYPE OFFSET &
		!	RATT.OFF%		RECORD ATTRIBUTE &
		!				 OFFSET &
		!	RSIZ.OFF%		RECORD SIZE OFFSET &
		!	HIBK.OFF%		OFFSET TO THE LAST &
		!				 ALLOCATED BLOCK &
		!	EFBK.OFF%		OFFSET TO THE END OF &
		!				 FILE BLOCK &
		!	FFBY.OFF%		OFFSET TO THE END OF &
		!				 FILE BYTE &
		!  THE ABOVE ARE ALL OFFSETS INTO THE RETURNED VALUE OF &
		!  THE 'READ ATTRIBUTES RECORD' SYS() CALL.  THEY ARE &
		!  THE ADDRESS IN THE RETURNED STRING FROM WHICH TO &
		!  EXTRACT THE SPECIFIED DATA. &
		! &
		! SET UP THE RECORD TYPE CONSTANTS FOR USE LATER : &
		!	ASCIZ%	USED FOR 'UNDEFINED' RECORDS OR FOR &
		!		 RECORDS WHOSE ATTRIBUTES INDICATE &
		!		 FORMATTED ASCII.  IF NO CARRIAGE &
		!		 CONTROL FORMATTING IS REQUESTED, THEN &
		!		 RESULTS IN BLOCK TRANSFER. &
		!	FIXED%	USED TO SET THE RCRDTY% VALUE IF THE &
		!		 FILE'S ATTRIBUTES INDICATE FIXED LENGTH &
		!		 RECORDS. &
		!	VARIAB%	USED FOR VARIABLE LENGTH RECORD FILES. &
		! &
		! SET UP THE VALUES USED TO DETERMINE THE CARRIAGE &
		!  CONTROL PROCESSING TYPE : &
		!	FORTRN%,COBOL% &
		!		USED WHEN THE FILE'S ATTRIBUTES INDICATE &
		!		 FORTRAN CARRIAGE CONTROL, OR WHEN &
		!		 SPECIFIED. &
		!	IMPLID%	USED WHEN THE FILE'S ATTRIBUTES INDICATE &
		!		 OR WHEN SPECIFIED. &
		!	EMBEDD%	USED WHEN THE FILE'S ATTRIBUTES INDICATE &
		!		 OR WHEN SPECIFIED. &
		! &
		! LPINDX% IS THE VARIABLE USED TO IDENTIFY THE DEVICE &
		!  BEING ACCESSED.  6 IS (2*) THE HANDLER INDEX OF THE &
		!  LINE-PRINTER. &

1620	NULSTG$="" &
	\ H$ = SPACE$(6%) &
	\ HH$ = "HH" &
	\ NOT32767% = NOT 32767% &
	&
	\ INBUF%=3% &
	\ OUTBUF%=2% &
	\ SWPBUF%=OUTBUF%+SWAP%(INBUF%) &
	&
	&
	\ CTLTBL$(0%) = CHR13$ &
	\ CTLTBL$(1%) = CHR$(12%) &
	\ CTLTBL$(2%) = CHR128$ &
	\ CTLTBL$(3%) = CHR10$ &
	\ GOSUB 20000 &
	&
		! HOLD THE DEVICE HANDLER FLAG WORD, THE DEVICE SWITCH &
		!  SPECIFICATION WORD, AND THE DEVICE CHARACTERISTICS &
		!  WORD. &
	&
		! SET LINE PRINTING CONTROL ARRAYS &
		! GO DO THE STANDARD START-UP. &
	&

2000	GO TO 9000	IF FATAL.ERR% &
	\ GOTO 3000 IF (R% AND 257%) &
	\ GOTO 9000 &
		! DISPATCH TO 'PRINT A JOB' ROUTINE IF EITHER ALIGNMENT &
		!  OR PRINT JOB IS REQUESTED; &
		! IF NONE OF THE ABOVE, THEN &
		!	GO CLEAR OUT BACK TO SPLIDL. &
	&

3000	R0%,Z0%(J9%,31%)=Z0%(J9%,31%) OR 256% &
	\ JOBNAM$=RAD$(Z0%(J9%,9%))+RAD$(Z0%(J9%,10%)) &
	\ FRMLEN%=Z0%(J9%,25%) &
	\ FRMWDT%=Z0%(J9%,26%) &
	\ HEADJB%=Z0%(J9%,29%) &
	\ JCOPYP%=Z0%(J9%,37%) &
	\ JCOPYR%=Z0%(J9%,30%) &
	\ KBCVT%  = Z0%(J9%,44%) &
	\ FRMFLG% = Z0%(J9%,45%) &
	\ DEFFRM% = Z0%(J9%,46%) &
	\ WDDV40% = Z0%(J9%,47%) &
		! SET UP THE JOB STATUS, SETTING THE 'IN PROCESS' FLAG; &
		! GET THE JOB'S SWITCH SPECIFICATION WORD, FORM LENGTH, &
		!  WIDTH, HEADING COUNT, FORMAT, COPIES REQUESTED, &
		!  COPIES COMPLETED. &

3020	LPFORM% = Z0%(J9%,40%) &
	\ SKPSIX% = Z0%(J9%,42%) &
		! GET THE USER REQUESTS : &
		!	LPFORM FLAG &
		!	SKIP 6 LINES ON A PAGE FLAG &

3060	OLPFRM% = Z0%(Q9%,40%) &
	\ OSKPSI% = Z0%(Q9%,42%) &
	\ OTOLF%  = Z0%(Q9%,43%) &
	\ OTOPF%  = Z0%(Q9%,44%) &
		! SET UP THE OUTPUT DEVICE REAL CHARACTERISTICS &

3100	E%,SKPCNT%=0% &
	\ PRTLNE%=1% &
	\ Z%=FNO%(Q9%,6%,OUTBUF%,0%) &
	\ IF E%=0% THEN &
		Q0%=PEEK(K0%+2%*OUTBUF%) &
	  ELSE	E1%=ERL &
	\	GOTO 19000 &
		! TRY TO OPEN THE DESTINATION DEVICE; &
		! IF NO ERROR, THEN &
		!	HOLD THE ADDRESS OF THE DEVICE'S DDB IN Q0%; &
		! ELSE	SET UP AN UNEXPECTED ERROR; &
		!	GO PROCESS THE FATAL ERROR. &

3110	DEVICE%=2%^((STATUS AND 255%)/2%) &
	\ OUTBFS%=BUFSIZ(OUTBUF%) &
	\ OPEN "_NL:" FOR INPUT AS FILE INBUF%, RECORDSIZE 512% &
	\ FIELD #INBUF%, BUFSIZ(INBUF%) AS BUFFER$ &
		! STORE THE SIZE OF THE OUTPUT BUFFER. &
		! OPEN THE FILE, AND SET THE GENERAL COVER FIELD &

3180	GOTO 8020 IF (R% AND 256%) &
		! THE 'FORMS ALIGNMENT' ROUTINE USES THIS MUCH OF THE &
		!  DEVICE SET UP CODE TO GET THE OUTPUT DEVICE OPEN; &
		! IF THIS IS AN ALIGNMENT RUN, THEN GO BACK INTO THE &
		!  ALIGNMENT ROUTINE. &

3190	GOTO 7000 UNLESS JCOPYP%<JCOPYR% &
		! IF ALL JOB COPIES HAVE BEEN PRINTED, THEN &
		!	GOTO END OF JOB PROCESSING. &
	&

3200	GOSUB 14500 IF PRTLNE%<>1% &
	\ CHANGE SYS(CHR6$+CHR$(34%)+CHR$(3%)) TO Z% &
		! Read the system feature patch words &
	\ F.P%=0% &
		! the feature by default is off &
	\ F.P%=-1% IF (Z%(5%)+SWAP%(Z%(6%))) AND 16% &
		! turn it on if requested &
	\ GOTO 3210 IF F.P% &
	\ NXTLNE%=2% \ RECLEN%=0% \ GOSUB 14800 &
	\ GOSUB 14500 &

3210	GO SUB 21000 &
	\ GO TO 4900	IF JOBMOD% AND JCOPYP% <> 0% &
	\ IF HEADJB% THEN &
		HEADJP% = 0% &
	\	IN.HDR%=-1% &
	\	WHILE HEADJP% < HEADJB% &
	\		HEADJP% = HEADJP% + 1% &
	\		GO SUB 16200 &
	\		GO SUB 21000 &
	\	NEXT &
	\	IN.HDR%=0% &
	\	GO TO 4900	IF JOBMOD% &
	! POLL JOB FOR INITIAL SETUP (POSSIBLE REQUE OR ABORT); &
	! GO PROCESS JOB MODIFICATION IF REQUESTED AND AT LEAST ONE &
	!  JOB HEADER PAGE HAS BEEN PRINTED; &
	! IF DESIRED, PRINT OUT REQUIRED NUMBER OF JOB BURST PAGES. &

3290	GO SUB 21000 &
	\ GO TO 4900	IF JOBMOD% &
	\ F1%=0% \ S0%=0% &
	\ P0%=Z0%(J9%,27%) &
	\ Z0%(P0%,31%)=R0% AND 16384% &
	\ R0%,Z0%(J9%,31%) = R0% AND -16385% &
	\ WHILE P0% AND (R0% AND 7%) = 0% &
		! SET UP TO FOLLOW THE FILE LIST FOR THIS JOB; &
		! SET UP THE 'IN REQUE' FLAG IF IT IS SET IN THE JOB; &
		! FOR EACH FILE IN THE LIST : &
		! RESET THE 'REQUE' FLAG IF SET &
		!	DO THE FOLLOWING 'PRINT A FILE' ROUTINE. &

3300	FSSW%=Z0%(P0%,34%) &
	\ HEADFL%=Z0%(P0%,29%) &
	\ HEADFL%=HEADJB% IF HEADFL%>HEADJB% &
	\ HEADFL%=HEADJB% UNLESS HEADFL% UNLESS (FSSW% AND 32%) &
	\ FCOPYP%=Z0%(P0%,37%) &
	\ FCOPYR%=Z0%(P0%,30%) &
	\ FCOPYR%=1% UNLESS FCOPYR% &
	\ RESPGE%,PGECNT%=0% &
		! SET UP THE FILE'S : &
		!	SWITCH SPECIFICATION WORD; &
		!	FILE PROCESSES REQUESTED WORD; &
		!	HEADING COUNT; &
		!	(DEFAULT IT TO THE JOB'S HEADING COUNT IF IT IS &
		!	0 AND THE 'NOHEADER' FLAG (32 BIT) IS NOT SET IN &
		!	THE FILE'S SWITCH SPECIFICATION WORD); &
		!	FILE COPIES PRINTED COUNT AND COPIES REQUESTED &
		!	 COUNTS (REQUESTED DEFAULTS TO 1); &
		!	RESTART PAGE, BLOCK, AND BYTE, AND CURRENT PAGE &
		!	 COUNT. &
	&

4000	E% = Z0%(P0%,49%) &
	\ Z% = FNO%(P0%,8%,INBUF%,Z0%(J9%,8%)) UNLESS E% &
	\ GO TO 14710 IF E% &
	\ FIELD #INBUF%, BUFSIZ(INBUF%) AS BUFFER$ &
	\ BUFLEN%=BUFSIZ(INBUF%) &
	\ CHANGE SYS(CHR6$+CHR$(-25%)+CHR$(INBUF%)+CHR0$) TO Z% &
	\ Z%(Z%)=Z%(Z%)+SWAP%(Z%(Z%+1%)) FOR Z%=1% TO 29% STEP 2% &
	\ Z%(Z%)=0% FOR Z%=5% TO 17% STEP 2% UNLESS Z%(RTYP.OFF%) &
	\ EOFBLK%,EOFBYT%,RCRDTY%,SOSLNE%,FRCLEN%=0% &
	\ EOFBLK%=Z%(EFBK.OFF%) &
	\ EOFBYT%=Z%(FFBY.OFF%) &
	\ EOFBLK%=-1% IF Z%(EFBK.OFF%-2%) &
	\ IF EOFBLK%=0% AND Z%(HIBK.OFF%)=0% THEN &
		TMP$=SYS(CHR$(12%)) &
	\	EOFBLK%=SWAP%(CVT$%(MID(TMP$,13%,2%))) &
	\	EOFBLK%=-1% IF CVT$%(MID(TMP$,4%,1%)) &
	\	EOFBYT%=BUFLEN% &

4012	E% = 128% IF EOFBLK% = 0% &
	\ E% = 129% IF EOFBLK% < 0% &
	\ Z% = Z%(RTYP.OFF%) AND 56% &
	\ E% = 130% IF Z% &
	\ GOTO 14710 IF E% &
	\ Z%=Z%(RTYP.OFF%) AND 3% &
	\ RCRDTY%=ASCIZ% IF Z%=0% OR Z%=4% &
	\ RCRDTY%=FIXED% IF Z%=1% &
	\ RCRDTY%=VARIAB% IF Z%=2% OR Z%=3% &
	\ SOSLNE%=(Z%=3%) AND 8% &
	\ FRCLEN%=Z%(RSIZ.OFF%) &
	\ FRCLEN%=BUFLEN% UNLESS FRCLEN% &
	\ NOTSPN%=(Z%(RATT.OFF%) AND 8%) &
	\ IF FRMFLG%=0% THEN &
		FORMAT%=Z%(RATT.OFF%) AND 7% &
	   ELSE FORMAT%=DEFFRM% &
		! OPEN THE INPUT FILE; &
		! GOTO ERROR HANDLER IF ERROR; &
		! READ THE FILE'S ATTRIBUTES; &
		! SET THEM UP IN AN ARRAY; &
		! ZERO THEM OUT IF THE FIRST ONE IS ZERO; &
		! SET UP THE FOLLOWING (FILE) CONSTANTS : &
		!	RCRDTY%		RECORD TYPE; &
		!	FRCLEN%		FIXED LENGTH RECORD RECORD &
		!			 LENGTH &
		!	SOSLNE%		SET TO 8 IF VFC/SOS LINES ARE IN &
		!			 THE FILE; &
		!	EOFBLK%		LAST BLOCK OF THE FILE. &

4030	FORMAT%=EMBEDD% IF RCRDTY%=ASCIZ% IF FORMAT%=IMPLID% &
	\ E%=130% IF FORMAT%>3% OR ((Z%(20%)<>2%) AND Z%(20%)) &
	\ GOTO 4012 IF E% &
	\ GOTO 4900 IF Z0%(P0%,3%) &
	\ EORSN%=-1% &
	\ GOTO 4950 UNLESS FCOPYR%>FCOPYP% &
		! IGNORE FORMAT=IMPLIED IF RECORD TYPE IS STREAM. &
		! SET UP TO TRAP ANY WORK-FILE ERROR; &
		! GO TO END OF FILE PROCESS IF THE FILE HAS ANY ERRORS &
		!  ALREADY; &
		! SET UP THE NUMBER OF COPIES REQUESTED FROM THE FILE'S &
		!  WORK-FILE RECORD (THIS IS SET UP EACH PASS BECAUSE &
		!  IT MAY BE MODIFIED IN THE FILE RECORD); &
		! IF ALL COPIES HAVE BEEN PRINTED, THEN &
		!	GO CLEAN UP FOR THIS FILE. &

4040	GO SUB 14500 &
	\	IF HEADFL% THEN &
			HEADFP%=0% &
	\		IN.HDR%=-1% &
	\		WHILE HEADFP%<HEADFL% &
	\			HEADFP%=HEADFP%+1% &
	\			GO SUB 16000 &
	\			GO SUB 21000 &
	\		NEXT &
	\		IN.HDR%=0% &
	\		GOTO 4900	IF JOBMOD% &
			! EJECT THE OUTPUT IF NECESSARY &
			! PRINT THE BURST PAGES. &
	&

4050	IF (Z0%(P0%,31%) AND 16384%) THEN &
		Z0%(P0%,31%)=Z0%(P0%,31%) AND -16385% &
	\	F2%=F2% AND -129% &
	\	FLEMOD%=0% &
	\	GOTO 4040 IF RESPGS% &
	\	GOSUB 14500 &
	\	PGECNT%=32767% UNLESS PGEFLG% &
	\	RESFLE%=-1% &
	\	RESBLK%=Z0%(P0%,59%) &
	\	RESBYT%=Z0%(P0%,60%) &
	\	RESPGE%=Z0%(P0%,58%) &
	\	GO TO 4070	IF IN.REQ.RES% &
	\	T$ = "File " &
	\	T$ = T$ + "RESTART"	UNLESS IN.REQ.RES% &
	\	T$ = T$ + " requested on " &
	\	T$ = T$ + "Page "+NUM1$(RESPGE%)	IF RESPGE% <> 32767% &
	\	T$ = T$ + "Block "+NUM1$(RESBLK%) &
			+ ", Byte "+NUM1$(RESBYT%)	IF RESBLK% <> 32767% &
	\	GO SUB 16100 &
		! IF THE RESTART REQUIRED FLAG (16384 BIT) IS SET IN THE &
		!  FILE'S PRW, THEN &
		!	SET THE RESTART FLAG; &
		!	RESET THE 'FILE MOD REQUESTED' FLAG; &
		!	RESET THE 'FILE MODIFICATION REQUESTED' STATUS &
		!	 FLAG; &
		!	SET UP THE BLOCK, BYTE, PAGE AT WHICH TO &
		!	 RESTART. &
		!	OUTPUT THE ABEND PAGE &

4070	PGEFLG%=0% &
	\ IF RESFLE% OR OTOLF%=0% OR (LPFORM%<>OLPFRM%) OR &
		(SKPSIX% <> OSKPSI%) OR FORMAT%=FORTRN% THEN &
		PGEFLG%=-1% &
	\	TLTTBL%=3%+(LPFORM%<>0%) &
		! RESET THE PAGE COUNT FLAG, ASSUMING THAT THERE IS NO &
		!  REASON TO PAGE COUNT; &
		! IF ANY REASON FOR PAGE COUNTING, THEN &
		!	SET THE PAGE COUNT FLAG &
		! (REASONS FOR PAGE COUNTING ARE : &
		!	1. DOING A PAGE RESTART; &
		!	2. DESTINATION DEVICE HAS NO TOP OF FORM, SO &
		!	    HAVE TO COUNT LINES TO KEEP TRACK OF TOP &
		!	    OF FORM; &
		!	3. LPFORM IS REQUESTED BUT THE OUTPUT DEVICE &
		!	    DOES NOT HANDLE IT. &
		!	4. THE OUTPUT FORMAT IS TO BE FORTRAN OR COBOL.); &
		!		IT IS NECESSARY TO SET UP THE TRANSLATE &
		!		 STRING FOR PAGE COUNTING : &
		!			SET UP THE TRANSLATION STRING &
		!			 FOR EITHER THE LPFORM CASE, IF &
		!			 LPFORM IS IN ACTION, OR THE &
		!			 SIMPLE <LF>, <ESC>, AND <FF> &
		!			 STRING. &

4080	ASKCNT%,BLKCNT%,RECLEN%=0% &
	\ PGECNT%,CURLNE%=1% &
	\ EORSN%,EIBFLG%=-1% &
		!	SET UP THE FOLLOWING : &
		!	PGECNT%		PAGE COUNTER &
		!	ASKCNT%		AFTER SKIP COUNTER &
		!	BLKCNT%		BLOCK COUNTER &
		!	RECLEN%		LENGTH OF FULL RECORD &
		!	EIBFLG%		END OF INPUT BUFFER &
		!			 FLAG : &
		!			 -1	=> BUFFER &
		!				   EXHAUSTED &
		!			  0	=> MORE LEFT IN &
		!				   BUFFER &
	&
	&
	&

4100	F1% = F1% AND 32767% \ F2% = F2% AND 32767% &
	\ 	GOTO 4900 IF JOBMOD% &
	\	GOTO 4050 IF FLEMOD% &
	\	IF EIBFLG% THEN &
			S0%=0% \ F1%=0% \ GOSUB 21000 &
	\		GOTO 4100 IF (JOBMOD% OR FLEMOD%) &
	\		INPPOS%,OUTPOS%, &
				LFPOS%,FFPOS%,ESCPOS%=0% &
	\		BLKCNT%=BLKCNT%+1% &
	\		GOTO 4700 IF BLKCNT%>EOFBLK% OR &
			 (BLKCNT%=EOFBLK% AND EOFBYT%=0%) &
	\		E%=0% \ GET #INBUF%,RECORD BLKCNT% &
	\		EIBFLG%=0% &
	\		BUFLEN%=RECOUNT &
	\		CTRLZ.FND%=0% &
	\		CTRLZ.FND%=INSTR(1%,BUFFER$,CHR$(26%)) &
			 IF FORMAT%=EMBEDD% IF RCRDTY%=ASCIZ% &
	\		EOFBYT%=CTRLZ.FND%-1% IF CTRLZ.FND% &
	\		EOFBLK%=BLKCNT% IF CTRLZ.FND% &
	\		BUFLEN%=EOFBYT% IF BLKCNT%=EOFBLK% &
	\		IF PGEFLG% THEN &
				TLTSTG$=NULSTG$ &
	\			TLTSTG$=XLATE(BUFFER$,Z1$(TLTTBL%)) &
			! GO POLL FOR MESSAGES IF NEW BLOCK NEEDED; &
			! SKIP PROCESSING IF JOB MODS REQUESTED; &
			! GO CHECK IT OUT IF FILE MODS REQUESTED; &
			! IF A NEW INPUT BUFFER IS REQUIRED, THEN &
			!	RESET THE INPUT POSITION AND LAST CHR &
			!	 PROCESSED IN OUTPUT POINTERS, AND &
			!	 RESET THE 'NEED A BLOCK' FLAG; &
			!	INCREMENT THE BLOCK POINTER; &
			!	GO TO EOF ROUTINE IF THE NEXT BLOCK IS &
			!	 PAST EOF; &
			!	GET ANOTHER BLOCK; &
			!	IF NO ERROR, THEN &
			!		SET UP THE BUFFER LENGTH INTO &
			!		 BUFLEN%; &
			!	SET 'EOF BYTE' AND 'EOF BLOCK' POINTERS IF &
			!	 WE ENCOUNTER A CTRL/Z IN AN ASCII STREAM &
			!	 RECORD. &
			!	SET THE BUFFER LENGTH TO THE 'EOF BYTE' &
			!	 IF THIS IS THE LAST BLOCK; &
			!	TRANSLATE THE BUFFER ACCORDING TO THE &
			!	 TRANSLATION TABLE IF PAGE COUNTING (AND &
			!	 THEREFORE, SCANNING FOR <LF>, <FF>, AND &
			!	 PERHAPS LPFORM CHRS IS NEEDED). &
	&

4120		BEGREC%=INPPOS% &
	\	IF RCRDTY%=ASCIZ% THEN &
			ENDREC%,ORG.ENDREC%=BUFLEN% &
	\		EIBFLG%=-1% &
	\		RECLEN%=ENDREC%-BEGREC% &
	\		GOTO 4170 &
			! SET THE BEGINNING POINTER (BEGREC%) FOR THE &
			!  RECORD TO THE CURRENT POSITION IN THE INPUT &
			!  BUFFER (INPPOS%); &
			! IF THE RECORD TYPE IS ASCII STREAM, THEN &
			!	SET THE 'END OF RECORD' POINTER &
			!	 (ENDREC%) TO THE END OF THE BUFFER; &
			!	SET THE 'END OF INPUT BUFFER' FLAG &
			!	 (EIBFLG%); &
			!	GO PROCESS THIS RECORD. &

4130		IF RECLEN%=0% THEN &
			BEGREC%,INPPOS%=(INPPOS%+1%) AND -2% &
	\		SOSSN%=0% &
	\		IF RCRDTY%<>VARIAB% THEN &
				RECLEN%=FRCLEN% &
			ELSE	GOTO 4600 IF BEGREC%>=BUFLEN% &
	\			FIELD #INBUF%,BEGREC% AS Z$,2% AS Z$ &
	\			RECLEN%,HOLD%=SWAP%(CVT$%(Z$)) &
	\			RECLEN%=0% IF RECLEN%<0% &
	\			BEGREC%,INPPOS%=INPPOS%+2% &
	\			GOTO 4600 IF HOLD%<0% OR &
				 BEGREC%>=BUFLEN% &
			! IF THE BYTES REMAINING IS NOT 0, THEN &
			!	IF THE RECORD TYPE IS 'VARIABLE', THEN &
			!		GO CHECK FOR SOS LINE NUMBERS; &
			!	ELSE	GO PROCESS THIS LINE; &
			! ELSE	INCREMENT THE BEGIN OF RECORD AND THE &
			!	 CURRENT INPUT POSITION POINTERS, AND &
			!	 ROUND THEM OFF TO A MULTIPLE OF 2; &
			!	RESET THE SOS SKIP SEEN, FIRST DATA &
			!	 SEEN, AND EOR SEEN FLAGS; &
			!	IF THE RECORD TYPE IS NOT VARIABLE, THEN &
			!		SET RECORD LENGTH TO THE FIXED &
			!		 LENGTH; &
			!	ELSE	GO FORCE A PUT OF THE CURRENT &
			!		 BUFFER IF THE INPUT POSITION IS &
			!		 AT THE END OF THE BUFFER; &
			!		OTHERWISE, SET UP AND CONVERT &
			!		 THE RECORD LENGTH OF THE NEXT &
			!		 RECORD; &
			!		IF THE RECORD LENGTH IS LESS &
			!		 THAN 0 (AS IT WILL BE ONLY IF &
			!		 THIS FILE DOES NOT HAVE 'SPAN- &
			!		 NED' RECORDS AND THE NEXT ONE &
			!		 WILL NOT FIT), THEN &
			!			GO FORCE A PUT; &
			!		ELSE	INCREMENT THE BEGIN &
			!			 POINTER, CURRENT INPUT &
			!			 POINTER PAST THE &
			!			 RECORD LENGTH WORD. &
			! (NOTE :	THE RECORD LENGTH ON A VARIABLE &
			!		LENGTH RECORD DOES NOT INCLUDE &
			!		THE TWO BYTE RECORD LENGTH.) &

4140		ENDREC%,ORG.ENDREC%=BEGREC%+RECLEN% &
	\	IF ENDREC%<=BUFLEN% THEN &
			EIBFLG%=0% &
	\		GOTO 4160 IF RCRDTY%=VARIAB% &
	\		GOTO 4170 &
			! SET UP THE RECORD LENGTH IF THE RECORD TYPE IS &
			!  FIXED; &
			! SET UP THE END OF RECORD AS THE BEGINNING &
			!  POINTER (BEGREC%) + THE RECORD LENGTH &
			!  (RECLEN%); &
			! IF THE END OF THE RECORD IS IN THIS BUFFER, &
			!  THEN &
			!	RESET THE 'NEW BUFFER REQUIRED' &
			!	 FLAG (EIBFLG%); &
			!	GO DO THE SOS CHECK. &

4150	GOTO 4600 IF NOTSPN% &
	\ ENDREC%,ORG.ENDREC%=BUFLEN% &
	\ EIBFLG%=-1% &
			! IF THE RECORD TYPE FORBIDS SPANNED RECORDS, &
			!  THEN &
			!	GO FORCE A PUT AND GET NEW BUFFER; &
			! ELSE	SET THE 'END OF RECORD' POINTER TO THE &
			!	 END OF THE BUFFER; &
			!	SET THE 'GET NEW BUFFER' FLAG (EIBFLG%) &
			!	 TO FORCE A GET NEXT TIME AROUN.; &

4160		IF SOSLNE% THEN &
			IF SOSSN%=0% THEN &
				IF BEGREC%=BUFLEN% THEN &
					GOTO 4600 &
				ELSE	BEGREC%,INPPOS%=INPPOS%+2% &
	\				RECLEN%=RECLEN%-2% &
			! IF THE SUBTYPE WORD INDICATES SOS LINES, THEN &
			!	IF THE 'SOS SEEN' FLAG IS OFF, THEN &
			!		IF THE BUFFER IS EXHAUSTED, THEN &
			!			FORCE A PUT AND GET A &
			!			 NEW BUFFER; &
			!		ELSE	INCREMENT THE BEGINNING &
			!			 OF THE RECORD AND THE &
			!			 CURRENT INPUT POSITION &
			!			 PAST THE SOS LINE &
			!			 NUMBER; &
			!			DECREMENT THE RECORD'S &
			!			 OVERALL LENGTH. &

4170		INPPOS%=ENDREC% &
	\	RECLEN%=RECLEN%-(ENDREC%-BEGREC%) &
			! SET THE 'CURRENT INPUT POSITION' POINTER TO &
			!  THE END OF THE NEW RECORD; &
			! DECREMENT THE RECORD'S OVERALL LENGTH BY THE &
			!  AMOUNT TAKEN THIS TIME AROUND. &
			! NOTE :	ALL INPUT DE-BLOCKING ROUTINES &
			!		EXIT THROUGH THIS LINE UNLESS &
			!		IT WAS NECESSARY TO FORCE OUTPUT &
			!		AND GET A NEW BUFFER, IN WHICH &
			!		CASE, THEY GO DIRECTLY TO THE &
			!		ROUTINE AT 4600. &
	&

4200	CURLNE%=0% UNLESS PGEFLG% &
	\ IF PGEFLG%=0% THEN &
		GOTO 4500 IF FORMAT%=EMBEDD% &
	\	IF FORMAT%=IMPLID% THEN &
			ASKCNT%=ASKCNT%+1% &
	\		FRSTDT%=EORSN% &
	\		EORSN%=(RECLEN%=0%) &
	\		GOTO 4400 &
		! IF PAGE COUNTING IS NOT NECESSARY, THEN &
		!	GO CLEAN UP THE BUFFER IF FORMAT IS EMBEDDED, &
		!	 SINCE NO OTHER PROCESSING OF CARRIAGE CONTROL &
		!	 IS NECESSARY; &
		!	IF THE FORMAT IS IMPLIED, HOWEVER, THEN &
		!		IT IS NECESSARY TO PUT A CR-LF ON THE &
		!		 END OF THE RECORD, SO INCREMENT THE &
		!		 NUMBER OF LINES TO SKIP AFTER PRINTING &
		!		 THE DATA AND GO DO THE FORMATTING. &

4220	FRSTDT%=EORSN% OR DLR%=0% &
	\ EORSN%=0% &
	\ HOLD%=ENDREC%+1% \ HLDCHR%=0% &
	\ IF LFPOS%<=BEGREC% THEN &
		LFPOS%=INSTR(BEGREC%+1%,TLTSTG$,CHR128$) &
	\	LFPOS%=32767% UNLESS LFPOS%
4222	IF FFPOS%<=BEGREC%+1% THEN &
		FFPOS%=INSTR(BEGREC%+1%-FRSTDT%,TLTSTG$,CHR130$) &
	\	FFPOS%=32767% UNLESS FFPOS%
4224	IF ESCPOS%<=BEGREC% THEN &
		ESCPOS%=INSTR(BEGREC%+1%,TLTSTG$,CHR131$) &
	\	ESCPOS%=32767% UNLESS ESCPOS%
4226	IF LFPOS%<HOLD% THEN &
		HOLD%=LFPOS% \ HLDCHR%=10%
4227	IF FFPOS%<HOLD% THEN &
		HOLD%=FFPOS% \ HLDCHR%=12%
4228	IF ESCPOS%<HOLD% THEN &
		HOLD%=ESCPOS% \ HLDCHR%=27%
4229	IF HLDCHR% THEN &
		ASKCNT%=ASKCNT%+1% IF HLDCHR%=10% UNLESS FORMAT%=FORTRN% &
	\	INPPOS%=HOLD% &
	\	INPPOS%=INPPOS%-1% IF HLDCHR%=12% &
	\	INPPOS%=INPPOS%+1% WHILE MID(TLTSTG$,INPPOS%+1%,1%)== &
			CHR129$ AND INPPOS%<ENDREC% &
	\	HOLD%=HOLD%-1% &
	\	HOLD%=HOLD%-1% WHILE MID(TLTSTG$,HOLD%,1%)==CHR129$ AND &
			HOLD%>BEGREC% &
	\	RECLEN%=RECLEN%+ENDREC%-INPPOS% &
	\	ENDREC%=HOLD% &
	\	EIBFLG%=0% UNLESS INPPOS%=BUFLEN% AND FORMAT%=FORTRN% &
	\	EORSN%=-1% &
		! AT THIS POINT, IT IS KNOWN THAT SOME REFORMATTING OF &
		!  THE LINE MAY BE NECESSARY.  THIS LINE FINDS THE FIRST &
		!  OCCURRENCE OF A <LF>, A <FF-TYPE>, OR AN <ESC> IN THE &
		!  BUFFER AT A POINT PAST THE BEGINNING OF THE RECORD &
		!  DEFINED BY BEGREC% AND ENDREC%.  IT FINDS THIS PLACE &
		!  BY SUCCESSIVELY SCANNING FOR A CHR$(128), A &
		!  CHR$(130), AND A CHR$(131), IN THE STRING CREATED BY &
		!  THE XLATE OF THE BUFFER ON THE APPROPRIATE XLATE &
		!  TABLE (THE XLATED STRING, TLTSTG$, IS CREATED BY THE &
		!  'GET A BLOCK' ROUTINE, ABOVE).  NOTE THAT THE &
		!  CHR$(130) CHARACTER IS CREATED EITHER BY A FORM-FEED &
		!  CHARACTER (CHR$(12%)) OR BY ANY LPFORM CHARACTER &
		!  (CHR$(127+%)) FOUND IN THE BUFFER, IF LPFORM IS &
		!  REQUESTED.  LINEFEEDS ARE CONVERTED TO CHR$(128%) &
		!  CHARACTERS, ESCAPES TO CHR$(131%), AND <CR> &
		!  AND <NULLS> ARE CONVERTED TO CHR$(129%). &
		! &
		! ONCE THE POSITION OF THESE THREE TYPES OF CHRS IS &
		!  FOUND, THE ROUTINE NEXT DETERMINES IF ANY OF THEM &
		!  FALLS WITHIN THE RECORD UNDER CONSIDERATION, AND, IF &
		!  SO, WHICH FALLS EARLIEST IN THE RECORD.  THE VARIABLE &
		!  'HOLD%' BECOMES THE POSITION OF THE FIRST OF THIS &
		!  OCCURRENCE WITHIN THE RECORD. &
		! &
		! (IF NONE FALLS WITHIN THE RECORD, THEN &
		!	NO RE-ARRANGEMENT OF THE RECORD'S END POINTER IS &
		!	 DONE.) &
		! IF ONE DOES FALL IN THE RECORD, THEN THE FOLLOWING &
		!  APPLIES : &
		!	IF THE CHR FOUND WAS AN <LF>, THEN &
		!		THE POSITION OF THE CHR DEFINES THE &
		!		 END OF THE RECORD.  IT IS NECESSARY &
		!		 TO SCAN FORWARDS FROM THE CHR TO &
		!		 ELIMINATE ANY GARBAGE (EG, <CR> OR &
		!		 <NULL> CHRS, WHICH WILL BE CHR$(129) &
		!		 IN THE XLATED STRING), PUSHING THE &
		!		 'CURRENT POSITION IN THE INPUT BUFFER' &
		!		 POINTER PAST THEM UNTIL, EITHER, A &
		!		 NON-GARBAGE CHR IS FOUND, OR THE END OF &
		!		 THE RECORD (AS DEFINED BY THE &
		!		 DE-BLOCKING ROUTINE, ABOVE) IS &
		!		 ENCOUNTERED. &
		!		THEN, SCAN BACKWARDS FROM THE CHR TO &
		!		 GET RID OF ALL GARBAGE CHRS BEFORE THE &
		!		 CONTROL CHR, PUSHING THE (TEMPORARY) &
		!		 END OF RECORD POINTER BACK SO THAT &
		!		 THESE CHRS ARE SKIPPED IN THE FINAL &
		!		 OUTPUT. &
		!		SINCE THE CHR FOUND WAS AN <LF>, THE &
		!		 'LINES TO SKIP AFTER PRINTING THIS &
		!		 RECORD' COUNTER MUST BE INCREMENTED &
		!		 TO REFLECT THE FACT.  NOTE THAT THIS &
		!		 INCREMENT IS NOT DONE IF THE FORMATTING &
		!		 IS FORTRAN OR COBOL; THUS, ALL EMBEDDED &
		!		 CARRIAGE CONTROL CHRS ARE TREATED ONLY &
		!		 AS RECORD TERMINATORS AND NOT AS &
		!		 CARRIAGE CONTROL CHRS IN FORTRAN/COBOL &
		!		 PROCESSING - ALL CARRIAGE CONTROL IN &
		!		 FORTRAN/COBOL TYPE FILES MUST BE IN &
		!		 FORTRAN OR COBOL FORMAT. &
		! &
		! &
		!	IF THE CHR FOUND WAS A <FF-TYPE> CHR, THEN &
		!		THIS CHARACTER DEFINES THE BEGINNING &
		!		 OF A SUBSEQUENT RECORD, SO SET THE &
		!		 'CURRENT POSITION IN THE INPUT BUFFER' &
		!		 POINTER TO THE POSITION BEFORE THIS &
		!		 ONE.  THE FORWARD SCAN IS PERFORMED, &
		!		 BUT IT IS GUARANTEED TO STOP &
		!		 IMMEDIATELY, SINCE THE FIRST CHR IT &
		!		 ENCOUNTERS IS NON-GARBAGE.  THE &
		!		 BACKWARDS SCAN IS PERFORMED TO FIND THE &
		!		 END OF THE RECORD. &
		! &
		!	IF THE CHR FOUND IS AN <ESC>, THEN &
		!		THE SITUATION IS THE SAME AS FOR AN <LF> &
		!		 CHR, EXCEPT THAT NO LINE COUNTER &
		!		 MODIFICATIONS ARE DONE, SINCE <ESC> IS &
		!		 NOT A 'NEW LINE' TYPE CHR. &
		! &
		!	FINALLY, THE END OF RECORD IS SET TO POINT TO &
		!	 IN FRONT OF THE GARBAGE, THE 'CHARACTERS LEFT &
		!	 IN RECORD' COUNTER IS UPDATED TO REFLECT THE &
		!	 NUMBER BACKED OVER, THE 'END OF INPUT BUFFER' &
		!	 FLAG IS RESET (SINCE A 'SUB-RECORD' WAS &
		!	 COMPLETELY DEFINED IN THE BUFFER) UNLESS &
		!	 IT IS A FORTRAN RECORD &
		!	 THAT ENDS AT THE END OF THE BUFFER, AND THE &
		!	 'END OF RECORD SEEN' FLAG IS SET, SINCE SOME &
		!	 END OF RECORD CHR WAS FOUND. &

4230	EORSN%=-1% IF RECLEN%=0% IF FORMAT%=IMPLID% OR FORMAT%=FORTRN% &
	   UNLESS RCRDTY%=ASCIZ% &
	\ ASKCNT%=ASKCNT%+1% IF EORSN% IF FORMAT%=IMPLID% &
	\ BEGREC%=BEGREC%+1% WHILE MID(TLTSTG$,BEGREC%+1%,1%)==CHR129$ &
		AND BEGREC%<ENDREC% AND DLR%=0% &
	\	SKPCNT%=SKPCNT%+1% IF BEGREC%=ENDREC% IF FORMAT%=FORTRN% &
	\ DLR%=ENDREC%-BEGREC% &
	\ GO TO 4400 IF FRSTDT% = 0% OR DLR%=0% &
	\ FIELD #INBUF%, BEGREC% AS Z$, 1% AS Z$ &
	\ HOLD%=ASCII(Z$) &
	\ IF FORMAT%=FORTRN% THEN &
		GOTO 4260 IF (HOLD% AND 128%) &
	\	SKPTMP%=1% &
	\	GOTO 4250 IF HOLD%=49% &
	\	SKPTMP%=2% IF HOLD%=48% &
	\	SKPTMP%=0% IF HOLD%=43% &
	\	BEGREC%=BEGREC%+1% &
	\	GOTO 4270 &
		! NOW, IF THE FORMAT OF THE FILE IS 'IMPLIED', THEN &
		!	IF THE 'NUMBER OF CHRS REMAINING IN RECORD' IS &
		!	 0, THEN	INCREMENT THE 'SKIP AFTER PRINT' &
		!			COUNTER, SINCE THIS IS THE END &
		!			OF THE RECORD; &
		! NOW, SCAN FROM THE BEGINNING OF THE RECORD FOR GARBAGE &
		!  CHRS, IN CASE THIS IS THE FIRST RECORD IN THE BUFFER. &
		! IF THE END OF RECORD WAS NOT FOUND IN THE PREVIOUS &
		!  BUFFER, OR THIS IS A NULL RECORD, AFTER ALL THE &
		!  FILTERING, THEN &
		!	EXIT FROM THIS ROUTINE; &
		! ELSE	IF FORMAT IS FORTRAN/COBOL, THEN &
		!		IF THIS IS A COBOL CTL CHR (128 BIT ON &
		!		 BYTE), THEN &
		!			GO DO THE COBOL SET UP; &
		!		ELSE	SET THE (LOCAL) SKIP COUNTER TO &
		!			 1; &
		!			GO PROCESS A 'SKIP TO LINE' ON &
		!			 THE LINE NUMBER IN THE SKIP &
		!			 COUNTER IF THE REQUEST WAS FOR &
		!			 TOP OF FORM (CHR="1"); &
		!			SET THE SKIP COUNTER TO 2 IF &
		!			 THE REQUEST WAS FOR DOUBLE- &
		!			 SPACE (CHR="0"); &
		!			SET THE SKIP COUNTER TO 0 IF THE &
		!			 REQUEST WAS FOR OVERPRINT (CHR= &
		!			 "+"); &
		!			 (THE SKIP COUNTER REMAINS 1 &
		!			 IF NONE OF THE ABOVE - THE &
		!			 FIRST CHR OF THE RECORD WILL &
		!			 BE STRIPPED REGARDLESS OF ITS &
		!			 VALIDITY AS A CTL CHR) &
		!			SET THE BEGINNING OF THE RECORD &
		!			 PAST THE FIRST CHR; &
		!			GO ADD THE (LOCAL) SKIP COUNTER &
		!			 INTO THE (GLOBAL) SKIP COUNTER. &

4240	IF HOLD%=12% THEN &
		SKPTMP%=1% &
	ELSE	GO TO 4400	IF HOLD% < 128% OR LPFORM% = 0% &
		\	SKPTMP%=HOLD% AND 127% &
		! THIS LINE TAKES CARE OF THE NON-FORTRAN/COBOL TYPE &
		!  CONTROL CHRS; &
		! IF THE CHR IS 'TOP OF FORM', THEN &
		!	SET THE SKIP LINE TO 1 (AND FALL THROUGH TO THE &
		!	 'SKIP TO LINE' ROUTINE, BELOW); &
		! ELSE	IF THE CHR IS NOT AN LPFORM-TYPE CHR, OR IF &
		!	 LPFORM IS NOT ACTIVE, THEN &
		!		GO TO THE EXIT WITHOUT CHANGING THE &
		!		 (GLOBAL) SKIP COUNTER; &
		!	ELSE	(IT MUST BE AN LPFORM CHR WITH LPFORM &
		!		 ACTIVE, SO ) &
		!		SET THE (LOCAL) SKIP COUNTER TO THE &
		!		 LINE NUMBER TO WHICH TO SKIP, AND FALL &
		!		 THROUGH TO THE 'SKIP TO LINE' ROUTINE. &

4250	BEGREC%=BEGREC%+1% &
	\ FSTLNE%=CURLNE%+SKPCNT% &
	\ FSTLNE%=FSTLNE%-FRMLEN% UNTIL FSTLNE%<SKPTMP% &
	\ SKPTMP%=SKPTMP%-FSTLNE% &
	\ GOTO 4270 &
		! INCREMENT THE 'BEGINNING OF RECORD' POINTER PAST THE &
		!  CONTROL CHR; &
		! CALCULATE THE LINE NUMBER ON WHICH THE CARRIAGE WILL &
		!  BE AFTER THE 'SKIP BEFORE' IS PROCESSED; &
		! CALCULATE THE NUMBER OF LINES PAST THAT LINE NEEDED TO &
		!  BRING THE CARRIAGE TO TOP OF FORM; &
		! GO TO THE ADD IT IN ROUTINE. &

4260	BEGREC%=BEGREC%+1% &
	\ SKPTMP%=(HOLD% AND 63%) &
	\ IF (HOLD% AND 64%)=0% THEN &
		ASKCNT%=ASKCNT%+SKPTMP% &
	\	GOTO 4400 &
		! THIS IS THE COBOL SIEVE : &
		! INCREMENT PAST THE CONTROL CHR, SINCE IT IS GARBAGE; &
		! HOLD THE 'NUMBER OF LINES TO SKIP' VALUE FROM THE CTL &
		!  CHR (BOTTOM SIX BITS); &
		! IF THE 'BEFORE FLAG' IN THE CTL CHR (THE 64 BIT) IS &
		!  NOT SET, THEN &
		!	ADD THE SKIP COUNT INTO THE 'SKIP AFTER PRINT' &
		!	 COUNTER, AND EXIT; &
		! (ELSE	FALL THROUGH TO THE 'ADD TO CURRENT LINE' &
		!	 ROUTINE.) &

4270	SKPCNT%=SKPCNT%+SKPTMP% &
		! ADD THE (LOCAL) SKIP COUNTER INTO THE (GLOBAL) SKIP &
		!  COUNTER. &
	&

4400		GOTO 4500  UNLESS FRSTDT% &
	\	GO SUB 13500 &
	\	GO TO 4920	IF RESFLE% = 0% &
				IF IN.REQ.RES% &

4410		GOTO 4490 UNLESS CTLLEN% &
	\	IF OUTPOS%<>BEGREC% THEN &
			INCPOS%=BEGREC% &
	\		INCVAL%=-1% &
	\		GENBUF%=INBUF% &
	\		GENCNT%=BEGREC%-OUTPOS% &
	\		GOSUB 14000 &
	\		BEGREC%=INCPOS% &
	\		GOTO 4410 &
			! GO CLEAN UP THE BUFFER IF THE LENGTH OF THE &
			!  REQUIRED CONTROL STRING IS 0; &
			! OTHERWISE, IF THERE IS ROOM IN THE CURRENT &
			!  BUFFER FOR SOME OR ALL OF THE CONTROL STRING, &
			!  THEN &
			!	SET UP TO GENERATE INTO THE INPUT BUFFER &
			!	 STARTING AT THE CURRENT BEGINNING OF &
			!	 THE RECORD, BACK UNTIL EITHER THE &
			!	 CONTROL STRING IS DONE, OR THE ROUTINE &
			!	 RUNS OUT OF BUFFER SPACE AT THE END OF &
			!	 THE PREVIOUS RECORD; &
			!	DO THE GENERATE; &
			!	UPDATE THE BEGIN OF RECORD POINTER TO &
			!	 POINT TO THE POSITION BEFORE THE FIRST &
			!	 IN THE CONTROL STRING; &
			!	GO CLEAN UP THE BUFFER IF THE CONTROL &
			!	 STRING HAS ALL BEEN GENERATED. &

4420		IF OUTPOS%=0% THEN &
			INCPOS%=0% &
	\		NEWLNE%=PRTLNE% &
	\		INCVAL%=1% &
	\		GENBUF%=OUTBUF% &
	\		GENCNT%=OUTBFS% &
	\		GOSUB 14000 &
	\		PRTLNE%=NEWLNE% &
	\		E%=0% \ PUT #GENBUF%,COUNT INCPOS% &
	\		GOTO 4410 &
			! IF THE NEW RECORD IS AT THE BEGINNING OF THE &
			!  BUFFER (IE, NO CHARACTERS REMAIN TO BE PUT &
			!  FROM THE BUFFER PRECEDING THE BEGINNING OF &
			!  THE RECORD), THEN &
			!	SET UP TO GENERATE THE CONTROL STRING &
			!	 INTO THE SECONDARY BUFFER, FROM THE &
			!	 BEGIN OF THE BUFFER FORWARD, UNTIL THE &
			!	 ROUTINE HAS EITHER FILLED THE BUFFER OR &
			!	 RUN OUT OF CONTROL CHARACTERS TO &
			!	 GENERATE; &
			!	DO THE GENERATION; &
			!	PUT THE SECONDARY BUFFER; &
			!	GO BACK TO CHECK TO SEE IF ANY MORE CHRS &
			!	 NEED TO BE GENERATED. &

4430		HOLD%=OUTPOS% &
	\	OUTPOS%=0% &
	\	PRTLNE%=OCRLNE% &
	\	GO SUB 16300	IF KBCVT% &
	\	E%=0% \ PUT #SWPBUF%,COUNT HOLD% &
	\	GOTO 4410 &
			! IF THE PROGRAM GETS TO THIS LINE, THE &
			!  FOLLOWING STATE EXISTS : &
			!	THERE REMAINS INSUFFICIENT ROOM BETWEEN &
			!	 THE END OF THE PREVIOUS RECORD AND THE &
			!	 BEGIN OF THIS RECORD FOR THE CONTROL &
			!	 STRING, AND THERE IS SOME PREVIOUS &
			!	 RECORD IN THE BUFFER.  SOMETHING HAS &
			!	 GOT TO GO, SO &
			!		PUT THE CONTENTS OF THE BUFFER &
			!		 UP TO THE END OF THE PREVIOUS &
			!		 RECORD; &
			!		THIS CLEARS THE BUFFER FOR MORE &
			!		 CONTROL INFORMATION, SO SET THE &
			!		 'END OF PREVIOUS OUTPUT RECORD' &
			!		 POINTER TO THE BEGINNING OF THE &
			!		 BUFFER; &
			!		GO RETRY THE GENERATION &
			!		 PROCEDURE. &

4490	OCRLNE%=CURLNE% &
	\ CURLNE% = CURLNE% + SKPCNT% &
	\ CURLNE% = CURLNE% + 6% * FRMSKP% IF OSKPSI% &
	\ CURLNE% = CURLNE% - FRMLEN% WHILE CURLNE%>FRMLEN% &
		! ALL CALCULATIONS BASED ON THE CURRENT LINE NUMBER HAVE &
		!  BEEN COMPLETED, SO UPDATE THE LINE COUNTER TO REFLECT &
		!  THE SKIPPING.  NOTE THAT THE PROGRAM DOESN'T GET TO &
		!  THIS LINE IF THE 'FRSTDT%' FLAG IS NOT SET. &
	&
	&
	&

4500		GO TO 4610	IF BEGREC% = OUTPOS% &
	\		HOLD%=BEGREC%-OUTPOS% &
	\		IF HOLD%>4% THEN &
				HOLD%=ENDREC%-BEGREC% &
	\			FIELD #INBUF%,OUTPOS% AS Z$,HOLD% AS Z$ &
	\			FIELD #INBUF%,BEGREC% AS Z0$,HOLD% AS &
					Z0$ &
	\			LSET Z$=Z0$ &
	\			ENDREC%=HOLD%+OUTPOS% &
	\			GOTO 4610 &
			! IF THE BEGIN OF THE NEW RECORD IS IMMEDIATELY &
			!  AFTER THE END OF THE OLD RECORD, THEN &
			!	GO CHECK TO SEE IF OUTPUT IS REQUIRED &
			!	(IE, THE BUFFER IS 'CLEAN', SO SKIP THIS &
			!	ROUTINE); &
			! ELSE	HOLD THE DISTANCE; &
			!	IF THE DISTANCE IS GREATER THAN FOUR &
			!	 BYTES, THEN &
			!		HOLD THE LENGTH OF THE RECORD; &
			!		FIELD THE NEW POSITION FOR THE &
			!		 RECORD, AND THE CURRENT &
			!		 POSITION OF THE RECORD; &
			!		LSET THE RECORD DOWN (NOTE : USE &
			!		 OF THE LSET IN THIS CASE &
			!		 DEPENDS ON THE FACT THAT LSET &
			!		 MOVES CHARACTERS FROM THE LEFT- &
			!		 MOST CHARACTER FIRST); &
			!		UPDATE THE END OF RECORD POINTER &
			!		 TO POINT TO THE NEW END; &
			!		GO CHECK TO SEE IF OUTPUT IS &
			!		 NEEDED. &

4510			FIELD #INBUF%,OUTPOS% AS Z$,HOLD% AS Z$ &
	\		LSET Z$=CVT4.0$ &
	\		GOTO 4610 &
			! IF THIS LINE IS EXECUTED, THE FOLLOWING STATE &
			!  PERTAINS : &
			!	THE DISTANCE BETWEEN THE END OF THE OLD &
			!	RECORD AND THE BEGINNING OF THE NEW &
			!	RECORD IS NON-ZERO, BUT IS 4 OR FEWER &
			!	BYTES, SO : &
			!		FIELD THE AREA BETWEEN THE OLD &
			!		 AND THE NEW RECORD; &
			!		LSET THEM TO FOUR (OR FEWER) &
			!		 NULLS; &
			!		GO CHECK TO SEE IF OUTPUT IS &
			!		 NECESSARY. &
	&
	&

4600		EIBFLG%=-1% &
	\	ENDREC%=OUTPOS% &
	\	ASKCNT%=SKPCNT% &
			! THIS LINE IS EXECUTED IF IT IS NECESSARY TO &
			!  FORCE OUTPUT OF THE CURRENT BUFFER UP TO THE &
			!  END OF THE PREVIOUS RECORD.  IT MAY BE USED &
			!  ONLY BY THE ROUTINES WHICH DO THE INPUT &
			!  DEBLOCKING, SINCE IT SIMPLY FALLS THROUGH &
			!  BACK TO THE INPUT ROUTINES.  THE ROUTINES &
			!  WHICH CREATE THE CONTROL STRING FOR FORMS &
			!  CARRIAGE CONTROL MUST USE THEIR OWN OUTPUT &
			!  ROUTINES. &
			! SET THE 'END OF BUFFER SEEN' FLAG, TO FORCE &
			!  OUTPUT; &
			! SET THE 'ENDREC' VALUE TO THE END OF THE &
			!  LAST RECORD PROCESSED. &
			! PUT THE 'AFTER SKIP COUNTER' BACK INTO THE &
			!  'BEFORE SKIP COUNTER', TO ENSURE THAT IT IS &
			!  PROPERLY UPDATED AT LINE 4620; &
			! NOTE : IF THE PROGRAM IS IN A RESTART, THIS &
			!  ACTION WILL NOT FORCE OUTPUT, BUT WILL CAUSE &
			!  THE SAME CHANGES IN POINTERS AS IF &
			!  IT HAD. &
	&

4610		IF EIBFLG% THEN &
			IF (RESFLE% OR JOBMOD%) THEN &
				ENDREC%=0% &
			ELSE	HOLD%=ENDREC% &
	\			PRTLNE%=CURLNE% &
	\			ENDREC%=0% &
	\			GO SUB 16300	IF KBCVT% &
	\			E%=0% \ PUT #SWPBUF%, COUNT HOLD% IF &
					 HOLD% &
			! IF THE 'END OF INPUT BUFFER' FLAG IS SET, THEN &
			!	IF SOME JOB MODIFICATIONS HAVE BEEN &
			!	 REQUESTED, THEN &
			!		PRETEND THAT THE PUT IS DONE; &
			!	ELSE	PUT THE CURRENT BUFFER (ACROSS &
			!		 BUFFERS); &
			!		SET THE 'LINE LAST PRINTED' TO &
			!		 THE LINE THE CARRIAGE WILL BE &
			!		 ON AFTER PRINTING THIS BUFFER; &
			!		SET THE 'END OF CURRENT RECORD' &
			!		 POINTER TO 0. &

4620		OUTPOS%=ENDREC% AND RESPGE%=0% &
	\	IF PGEFLG%=0% AND FORMAT%=EMBEDD% THEN &
			GOTO 4100 &
		ELSE	SKPCNT%=ASKCNT% &
	\		ASKCNT%=0% &
	\		GOTO 4100 &
			! UPDATE THE 'LAST CHARACTER PROCESSED IN OUTPUT &
			!  BUFFER' POINTER TO THE END OF THE PREVIOUS &
			!  RECORD, OR RESET THE POINTER TO 0, IF IN A &
			!  RESTART; &
			! IF THERE IS NO FORMAT GOING ON, THEN &
			!	GO FIND THE NEXT RECORD; &
			! ELSE	CHANGE THE 'SKIP COUNTER' TO THAT &
			!	 SPECIFIED IN THE 'AFTER SKIP COUNT'; &
			!	RESET THE 'AFTER SKIP COUNT'; &
			!	GO GET THE NEXT INPUT RECORD. &
	&
	&

4700	IF RESFLE% THEN &
		E%=11% &
	\	GOTO 5000 &
		! IF THE EOF WAS FOUND WHEN IN THE PROCESS OF A RESTART, &
		!  THEN &
		!	GO ISSUE A RESTART ERROR. &

4720	FRSTDT%=-1% \ BEGREC%,ENDREC%=BUFSIZ(INBUF%) &
	\ RECLEN%=0% &
	\ GOTO 4400 IF SKPCNT% IF PGEFLG% &
	\ PRTLNE%=0% UNLESS PGEFLG% &
	\ GOSUB 14200 &
	\ F1%,S0%=0% \ GOSUB 21000 &
	\ GOTO 4100 IF (JOBMOD% OR FLEMOD%) &
		! GO PUT THE LAST BUFFER AND MAKE SURE THAT BUFFERS ARE &
		!  CLEARED. &
	&
	&

4800	Z0%(P0%,37%)=FCOPYP% &
	\ FCOPYP%=FCOPYP%+1% &
	\ GOTO 4030 &
		! UPDATE THE # PRINTED IN THE FILE RECORD IN THE WORK- &
		!  FILE; &
		! INCREMENT THE COPY NUMBER; &
		! GO BACK AND SEE IF ANY MORE ARE NEEDED. &
	&
	&
	&

4900	F2%=F2% AND -17% &
	\ JOBMOD%=0% &
	\ IF (R0% AND 2%) THEN &
		R0%,Z0%(J9%,31%)=R0% AND -3% &
	\	GOSUB 14200 &
	\	T$ = "Job restarted" &
	\	GO SUB 16100 &
	\	GOTO 3190 &
		! RESET THE 'JOB MODIFICATION REQUESTED' STATUS FLAG; &
		! RESET THE 'JOB MODIFICATION' FLAG WORD; &
		! IF THE JOB MODIFICATION WAS A 'RES JOB' REQUEST, THEN &
		!	RESET THE JOB MODIFICATION FLAG IN THE JOB'S &
		!	 RECORD; &
		!	MAKE SURE THAT THE BUFFERS ARE CLEAR; &
		!	OUTPUT ABEND PAGE &
		!	GO RESTART THIS ITERATION OF THE JOB. &

4920	GO TO 4930	UNLESS (R0% AND 4%) &
	\ 	GOSUB 14200 &
	\	Z%=(P0%<>0%) &
	\	WHILE Z% &
	\		RESPGE%=PGECNT% &
	\		RESBLK%=BLKCNT% &
	\		RESBYT%=INPPOS% &
	\		RESPGE%=32767% UNLESS PGEFLG% &
	\		RESBLK%,RESBYT%=32767% IF PGEFLG% &
	\		Z0%(P0%,59%)=RESBLK% &
	\		Z0%(P0%,60%)=RESBYT% &
	\		Z0%(P0%,58%)=RESPGE% &
	\		Z0%(P0%,37%)=FCOPYP% &
	\		Z0%(J9%,37%)=JCOPYP% &
	\		Z%=0% &
	\	NEXT &
	\	Z0%(J9%,27%)=P0% &
	\	IF PGEFLG% OR (P0% = 0%) &
		THEN &
			T$ = "Job REQUEd at Page "+NUM1$(RESPGE%) &
	\		GO SUB 16100 &
	\		GO TO 7000 &

4925	FLEMOD% = -1% &
	\	Z0%(P0%,31%) = Z0%(P0%,31%) OR 16384% &
	\	IN.REQ.RES% = -1% &
	\	GO TO 4050 &
		! IF THE REQUESTED JOB MODIFICATION WAS A 'REQUE', THEN &
		!	SET UP THE 'CURRENT FILE' POINTER IN THE JOB &
		!	 RECORD TO POINT TO THE ACTIVE JOB; &
		!	WHILE THE CURRENT FILE RECORD IS THERE : &
		!		SET UP A RESTART PAGE, BLOCK, AND BYTE, &
		!		 AS NECESSARY FOR RESTART; &
		!		PUT THESE VALUES INTO THE FILE RECORD; &
		!		RESET THE 'FILE RECORD ACTIVE' FLAG; &
		!	IF WE WERE COUNTING PAGES, THEN GO TO END OF JOB &
		!	CLEANUP.   OTHERWISE, GO BACK FOR RESTART OPERATION &
		!	TO FIND THE CORRECT PAGE WE ARE ON &

4930	GO SUB 14400 &
	\  GO SUB 14200 &
	\  T$ = "Job Aborted" &
	\  GO SUB 16100 &
		! FOR ABORTS, KILL THE OUTPUT BUFFERS, WAIT FOR OUTPUT &
		! TO COMPLETE, THEN OUTPUT THE ABEND PAGE &

4950	F1% = F1% AND 32767% \ F2% = F2% AND 32767% &
	\ Z0%(P0%,37%)=0% &
	\ CLOSE 3% &
	\ OPEN "_NL:" FOR INPUT AS FILE INBUF%, RECORDSIZE 512% &
	\ FIELD #INBUF%, BUFSIZ(INBUF%) AS BUFFER$ &
	\ GOTO 6000 &
		! CLEAR REPLY FLAGS &
		! RESET THE COPIES PRINTED &
		! CLOSE THE INPUT FILE &
		! RE-OPEN THE NULL DEVICE TO HAVE A BUFFER TO PLAY WITH &
		! GO DO THE END OF JOB STUFF. &
	&

5000	T$=NULSTG$ \ RESFLE%,RESPGE%,RESBYT%,RESBLK%=0% &
		! INIT THE TEXT STRING TO NULL. &

5020	T$=T$+FNM0$("RESTART failure",J9%,P0%,E%,PGECNT%) &
	\ T$=T$+C9$+"Enter 'SKIP' to skip file:  " &
	\ F1% = FNPUSH%(F1%) &
	\ E% = FNPUSH%(E%) &
	\ F1%=F1% OR -32624% &
	\ GOSUB 23500 &
	\ F2%=F2% AND -145% &
	\ GOSUB 21000 &
	\ E% = FNPOP% &
	\ F1% = FNPOP% OR F1% &
	\ IF F2%>=0% THEN &
		GOTO 4100 IF (F2% AND 144%) &
	  ELSE	F2%=F2% AND 32767% &
	\	C$=R$ &
	\	IF FNR%("SKIP",3%) THEN &
			RESFLE%,RESPGE%,E%=0% &
	\		GOTO 14720 &
		! SET UP ERROR MESSAGE; &
		! SET RESPONSES TO 'JOB MODS', 'FILE MODS', OR OTHER; &
		! ISSUE THE MESSAGE; &
		! RESET THE 'JOB MODS' AND 'FILE MODS' STATUSES; &
		! GO GET THE RESPONSE, AND DISPATCH IF JOB MODS OR FILE &
		!  MODS WERE SPECIFIED; &
		! OTHERWISE, IT HAD BETTER BE 'SKIP'; &
		! IF IT IS, THEN &
		!	LOG ERROR; &
		!	RESET POSSIBLE RESTART VALUES; &
		!	GO TO THE EXIT CLEAN UP ROUTINE. &

5030	T$="Illegal response - "+C$+C9$ &
	\ GOTO 5020 &
		! WAS AN ILLEGAL RESPONSE - ISSUE ERROR AND REISSUE THE &
		!  ORIGINAL MESSAGE. &
	&
	&
	&

6000		P0%=Z0%(P0%,1%) &
	\ NEXT &
	\ GO TO 14730	IF JOB.ERR% &
	\ JCOPYP%=JCOPYP%+1% &
	\ GOTO 3190 &
		!	MOVE ON TO THE NEXT FILE; &
		! ABORT IF ANY FILE ERRORS OCCURED DURING JOB &
		! LOOP UNTIL POINTER IS 0; &
		! INCREMENT JOB COPIES COUNTER; &
		! GOTO THE START OF THE JOB PROCESSING. &
	&

7000	GOSUB 14500 IF PRTLNE%<>1% &
	\ GOSUB 14200 &
	\ R%=(R% AND -2%) OR 8% &
	\	IN.REQ.RES% = 0% &
	\ GOTO 2000 &
	&

8020	GOSUB 14600 &
	\ GOTO 7000 &
		! THE FORMS ALIGNMENT ROUTINE IS VERY SIMPLE - &
	&
		! CALL THE ALIGNER AND EXIT AS IF END OF JOB. &
	&

9000	Z0%(0%,11%)=FNA0%(Z0%(0%,11%)) IF Z0%(0%,11%) &
	\ P0%=Z0%(0%,13%) &
	\ IF P0% THEN &
		P$=FNU$(P0%,NULSTG$,-1%,0%) &
	\	Z0%(0%,13%)=Z0%(P0%,1%) &
	\	Z0%(P0%,1%)=0% &
	\	Z%=FNA0%(P0%) &
		! GET RID OF THE INDIRECT COMMAND LIST; &
		! SET UP THE NEXT ONE TO CHAIN TO IF ONE IS IN THE LIST. &

9020	WHILE M%(4%) &
	\	Z0%(M%(5%),1%)=M%(2%) &
	\	M%(2%)=M%(4%) &
	\	M%(4%)=0% &
	\ NEXT &
	\ Z0%(0%,9%)=M%(2%) &
	\ Z0%(0%,19%)=M%(0%) &
	&
	\ Z0%(0%,0%)=B0% &
	\ Z0%(0%,26%)=R% &
	\ Z0%(0%,27%)=J9% &
	\ Z0%(0%,49%)=FATAL.ERR% &
	&
	\ W$=SYS(CHR$(8%)+CVT%$(0%)+FNU$(Z0%(0%,12%),NULSTG$,-1%,-1%)) &
		 IF P0% &
	\ CLOSE 1%,2%,3%,4% &
	\ E%=0% &
	\ CHAIN P$ LINE 31000% + (32767% + 1%) IF P0% &
	\ E% = 1% &
	\ E1% = 9020% &
	\ GO TO 19995 &
	&
	&
		! THIS LINE PLACES THE HEAD POINTERS OF THE COMPLETE &
		!  MESSAGE AND INCOMPLETE MESSAGE LISTS INTO THE WORK- &
		!  FILE FOR RETRIEVAL BY THE NEXT MODULE.  IF ANY &
		!  'UNPROCESSED' REQUESTS ARE PRESENT, THEY ARE PUT AT &
		!  THE FRONT OF THE 'COMPLETED' MESSAGES LIST. &
	&
		! REPLACE THE FREE-LIST POINTER, THE PACKAGE STATUS, AND &
		!  THE CURRENT JOB NUMBER IN THE FILE HEADER RECORD. &
	&
		! PUT THE WORK-FILE NAME INTO CORE COMMON IF A CHAIN IS &
		!  TO BE DONE; &
		! CLOSE THE FILES; &
		! IF THERE WAS A CHAIN RECORD, THEN &
		!	DO THE CHAIN; &
		! ELSE	GO DO THE FINAL CLOSE OUT. &
	&

13500		CURLNE%=CURLNE%-FRMLEN% WHILE CURLNE%>FRMLEN% &
	\	FSTLNE%=CURLNE%+SKPCNT% &
	\	IF FSTLNE%<=FRMLEN% THEN &
			FRMSKP%=0% &
		ELSE	FRMSKP%=FSTLNE%/FRMLEN% &
	\		FSTLNE%=FSTLNE%-FRMLEN%*FRMSKP% &
			! SET UP THE NEW FIRST LINE AS THE CURRENT LINE &
			!  PLUS THE SKIP COUNT; &
			! IF THE NEW FIRST LINE IS ON THE SAME FORM, &
			!  THEN &
			!	SET THE FORM SKIP COUNTER TO 0; &
			! ELSE	CALCULATE THE FORM SKIP COUNT &
			!	 NECESSARY TO SKIP THE NUMBER OF &
			!	 LINES; &
			!	SET UP THE NEW FIRST LINE VALUE. &

13520		IF FSTLNE%+6%>FRMLEN% THEN &
			IF SKPSIX% THEN &
				FRMSKP%=FRMSKP%+1% &
	\			SKPCNT%=SKPCNT%+FRMLEN%-FSTLNE%+1% &
	\			FSTLNE%=1% &
			! IF THE NEW FIRST LINE IS WITHIN SIX LINES OF &
			!  THE END OF THE PAGE, THEN &
			!	IF THE SPECIAL 'SKIP SIX LINES AT THE &
			!	 END OF A PAGE' IS ON, THEN &
			!		INCREMENT THE FORM SKIP COUNTER; &
			!		UPDATE THE LINE SKIP COUNTER TO &
			!		 REFLECT THE FACT THAT WE WANT &
			!		 BE AT THE TOP OF A NEW FORM; &
			!		SET THE FIRST LINE POINTER TO &
			!		 REFLECT THE FACT THAT WE ARE AT &
			!		 THE TOP OF FORM. &
	&

13530		PGECNT%=PGECNT%+FRMSKP% &
	\	SKPCNT%=SKPCNT%-6%*FRMSKP% IF OSKPSI% &
	\	IF RESFLE% THEN &
		 IF IN.HDR%=0% THEN &
			IF RESPGE%<=PGECNT% OR BLKCNT%>RESBLK% &
				 OR (BLKCNT%=RESBLK% AND &
				 RESBYT%<=BEGREC%) THEN &
				RESPGE%,RESFLE%,RESBLK%,RESBYT%=0% &
	\			PGEFLG%=(OTOLF%=0%) OR (LPFORM%<> &
					OLPFRM%) OR (FORMAT%= &
					FORTRN%) OR IN.REQ.RES% &
	\			INPPOS%,ENDREC% = ORG.ENDREC%  UNLESS PGEFLG% &
	\			TLTSTG$=NULSTG$ UNLESS PGEFLG% &
	\			T$ = "RESTARTing"	UNLESS IN.REQ.RES% &
	\			T$ = "REQUEing"		IF IN.REQ.RES% &
	\			T$ = T$ + " print at page "+ &
					NUM$(PGECNT%) &
	\			T$ = T$ + " (Block"+ &
					NUM$(BLKCNT%)+")" UNLESS IN.REQ.RES% &
	\			GOSUB 23500 &
	\			FRMSKP%,OUTPOS%=0% &
	\			CURLNE%=PRTLNE% &
	\			SKPCNT%=FSTLNE%-CURLNE% &
	\			SKPCNT%=SKPCNT%+FRMLEN% WHILE SKPCNT%<1% &
			! UPDATE THE PAGE COUNT (THIS IS DONE EVERY TIME &
			!  EVEN THOUGH FRMSKP WILL USUALLY BE 0); &
			! SUBTRACT SIX FROM THE SKIP COUNT FOR EACH PAGE &
			!  PASSED IF THE DEVICE HANDLER WILL &
			!  AUTOMATICALLY SKIP SIX LINES ON EACH FORM; &
			! IF THE RESTART PAGE IS NON-ZERO, THEN &
			! (THIS IS THE MIDDLE OF A RESTART) &
			!	IF THIS PAGE IS ON OR AFTER THE RESTART &
			!	 PAGE, THEN &
			!		RESET THE RESTART VALUES; &
			!		SET THE 'COUNTING PAGES' FLAG &
			!		 BACK TO THE DEFAULT FOR THIS &
			!		 DEVICE; &
			!		SET THE END OF RECORD POINTER AND &
			!		THE INPUT POSITION POINTER EQUAL TO &
			!		THE REAL END OF THE RECORD (THAT IS &
			!		INCLUDING THE CONTROL CHARACTERS) &
			!		UNLESS WE'RE PAGE COUNTING. &
			!		ISSUE A RESTART MESSAGE; &
			!		RESET FORMS SKIP COUNTER, OUTPUT &
			!		 POSITION POINTER; &
			!		SET THE CURRENT LINE TO THE LAST &
			!		 LINE ACTUALLY BUFFERED; &
			!		SET THE SKIP COUNTER SO AS TO &
			!		 GET THE CARRIAGE TO THE &
			!		 APPROPRIATE FIRST LINE. &

13560		CTLTBL%(Z%)=0% FOR Z%=0% TO 3% &
	\	GOTO 13590 IF (RESFLE% OR JOBMOD%) UNLESS IN.HDR% &
	\	GOTO 13580 UNLESS SKPCNT% &
	\	GOTO 13570 UNLESS OLPFRM% &
	\	CTLTBL%(2%)=FRMSKP% IF SKPCNT%>FRMLEN% &
	&
	\	CTLTBL%(3%)=FSTLNE% - &
		 ((CURLNE% - (FRMLEN% AND CURLNE%>=FSTLNE%)) &
			 AND &
		      (CTLTBL%(2%)=0%)) &
			 + &
		   (CTLTBL%(2%)<>0%) &
	&
	\	CTLLEN%=CTLTBL%(2%)+CTLTBL%(3%) &
	\	GOTO 13580 &
			! GO SET UP A <CR> IF NO LINES ARE TO BE &
			!  SKIPPED; &
			! GO SET UP OTHER THAN LPFORM IF NO LPFORM ON &
			!  OUTPUT DEVICE DRIVER; &
			! SET UP SOME FORM SKIPS IF MORE THAN ONE FORM &
			!  IS TO BE SKIPPED; &
			! SET UP A CHR$(127%+FSTLNE) IF THE FIRST LINE &
			!  IS NOT 1 OR LESS THAN ONE FORM LENGTH IS TO &
			!  BE SKIPPED; &
			! SET UP THE COUNT OF CONTROL CHARACTERS; &
			! GO CHECK TO SEE IF A <CR> SHOULD BE ISSUED. &

13570		IF OTOLF%=0% THEN &
			CTLLEN%,CTLTBL%(3%)=SKPCNT% &
		ELSE	CTLTBL%(1%)=FRMSKP% &
	\		HOLD%=CURLNE% &
	\		HOLD%=1% IF FRMSKP% &
	\		CTLTBL%(3%)=FSTLNE%-HOLD% &
	\		CTLLEN%=CTLTBL%(1%)+CTLTBL%(3%) &
			! THE LP FORM OPTION IS NOT IN THE DRIVER FOR &
			!  THE OUTPUT DEVICE : &
			!	IF THE DRIVER DOES NOT KNOW ABOUT &
			!	 SOFTWARE TOP OF FORMS CHARACTERS &
			!	 (OTOLF%=0%) THEN &
			!		ALL THAT CAN BE DONE IS TO ISSUE &
			!		 LINE-FEED CHARACTERS UNTIL THE &
			!		 RIGHT LINE; &
			!	ELSE	SET UP AS MANY TOP OF FORMS CHRS &
			!		 AS THERE ARE TOP OF FORMS; &
			!		SET UP ENOUGH LINE FEED CHRS TO &
			!		 BRING THE CARRIAGE TO THE LINE &
			!		 NEEDED; &
			!		SET UP THE CONTROL COUNTER &
			!		 (CTLLEN%) TO THE NUMBER OF &
			!		 FORM-FEEDS + THE NUMBER OF &
			!		 LINE-FEEDS. &

13580		CTLTBL%(0%)=1% &
	\		CTLLEN%=CTLLEN%+1% &
			!	SET UP THE CARRIAGE RETURN COUNT; &
			!	INCREMENT CONTROL STRING LENGTH TO TAKE &
			!	 CARE OF IT. &

13590	IF SKPCNT%<>1% OR FRMSKP%<>1% THEN &
		RETURN &
	ELSE	CTLTBL%(1%)=0% &
	\	CTLTBL%(3%)=1% &
	\	RETURN &
		! AND EXIT. &
	&
	&
	&
	&
	&

14000	ADDLNE%=0% &
	\ FSTLNE%=CURLNE% &
	\ INCVAL%=1% OR INCVAL%<0% &
	\ HOLD%=3% AND (INCVAL%<0%) &
	\ HOLD0%=(HOLD%<>3%) AND 3% &
	\ FOR HOLD1%=HOLD% TO HOLD0% STEP INCVAL% &
	&
	\	HOLD2%=CTLTBL%(HOLD1%) &
	\	INCCNT%=GENCNT% &
	\	GOTO 14090 IF GENCNT%=0% OR CTLLEN%=0% &
	\	INCCNT%=HOLD2% IF HOLD2%<INCCNT% &
	\	GO TO 14070	UNLESS INCCNT% &
	\	INCPOS%=INCPOS%-INCCNT% IF INCVAL%<0% &
	\	FIELD #GENBUF%,INCPOS% AS Z$,1% AS Z$ &
	\	LSET Z$=CTLTBL$(HOLD1%) &
	\	IF INCCNT%>1% THEN &
			FIELD #GENBUF%,INCPOS% AS Z$,INCCNT% AS Z0$ &
	\		FIELD #GENBUF%,INCPOS%+1% AS Z$,INCCNT%-1% AS Z$ &
	\		LSET Z$=Z0$ &
		! SET UP INCCNT% AS THE MINIMUM OF (CHR COUNT, CHR LEFT &
		!  IN BUFFER); &
		! RETURN IF INCCNT%=0%; &
		! SET THE BEGIN POSITION BACK IF WE'RE INSERTING BACK- &
		!  WARDS; &
		! FIELD ONE CHARACTER; &
		! LSET IN THE CONTROL CHARACTER; &
		! IF THE COUNT IS NOT ONE, THEN &
		!	FIELD THE WHOLE SET OF CHARS AS ONE STRING, AND &
		!	 FIELD AN OVERLAPPING SET AS THE SECOND STRING; &
		!	LSET ONE STRING TO ANOTHER. &
		! (NOTE :	THIS WORKS BECAUSE THE LSET VERB OVER- &
		!		WRITES THE LEFT-MOST CHARACTER FIRST.) &

14060		CTLLEN%=CTLLEN%-INCCNT% &
	\	GENCNT%=GENCNT%-INCCNT% &
	\	INCPOS%=INCPOS%+INCCNT% IF INCVAL%>0% &
	\	CTLTBL%(HOLD1%)=HOLD2%-INCCNT% &
	\	NEWLNE%=1% IF HOLD1%=1% OR HOLD1%=2% &
	\	ADDLNE%=ADDLNE%+INCCNT% IF HOLD1%=3% &

14070	NEXT HOLD1% &
		! UPDATE THE 'CHARACTERS LEFT IN CONTROL STRING' COUNTER &
		!  AND THE NUMBER LEFT FREE IN BUFFER COUNTER; &
		! UPDATE THE CURRENT POSITION IN THE BUFFER IF WE'RE &
		!  INSERTING FROM THE BACK END; &
		! RETURN. &

14090	NEWLNE%=NEWLNE%+ADDLNE% &
	\ NEWLNE%=NEWLNE%-FRMLEN% WHILE NEWLNE%>FRMLEN% &
	\ RETURN &

14100	CHANGE CVT$$(H$,164%) TO H% &
	\ STGLEN%=H%(0%) &
	&
	\ FOR CHRNO%=1% TO STGLEN% &
	\	NEWCHR%=H%(CHRNO%) &
	\	H$(CHRNO%)=STRING$(WDDV40%,NEWCHR%) &
	\	H%(CHRNO%)=INSTR(1%, &
			"ABCDEFGHIJKLMNOPQRSTUVWXYZ$.?0123456789", &
			CHR$(NEWCHR%)) &
	\ NEXT CHRNO% &
	&
	\ FIELD #OUTBUF%,OUTBFS% AS Z$ &
	&
	\ FOR BIGLNE%=0% TO 6% &
	\	LSET Z$=NULSTG$ &
	\	LNEPOS%=0% &
	&
	\	FOR CHRNO%=1% TO STGLEN% &
	\		CHRPTN%=BIGLTR%(BIGLNE%,H%(CHRNO%)) &
	\		LTRPRT%=1% &
	\		WHILE LTRPRT%<32% &
	\			IF (CHRPTN% AND LTRPRT%)=0% THEN &
					FIELD #OUTBUF%,LNEPOS% AS Z$, &
						WDDV40% AS Z$ &
	\				LSET Z$=H$(CHRNO%) &
	&

14120				LNEPOS%=LNEPOS%+WDDV40% &
	\			LTRPRT%=LTRPRT%+LTRPRT% &
	\		NEXT &
	\		LNEPOS%=LNEPOS%+WDDV40% &
	\	NEXT CHRNO% &
	&
	\	LNEPOS%=LNEPOS%-WDDV40% IF LNEPOS% &
	\	FIELD #OUTBUF%,LNEPOS% AS Z$,2% AS Z$ &
	\	LNEPOS%=LNEPOS%+2% &
	\	LSET Z$=C9$ &
	&
	\	FOR CHRNO%=1% TO WDDV40% &
	\		PRTLNE%=PRTLNE%+1% &
	\		PUT #OUTBUF%, RECORD 2%, COUNT LNEPOS% &

14130		NEXT CHRNO% &
	\	FIELD #OUTBUF%,LNEPOS% AS Z$ &
	\ NEXT BIGLNE% &
	\ NXTLNE% = PRTLNE% &
	\ H$(CHRNO%)=NULSTG$ FOR CHRNO%=0% TO 6% &
	&
	\ RETURN &
	&
		! SET UP FOR BLOCK PRINT : &
		!	CHANGE THE TEXT IN THE FOLLOWING WAYS : &
		!		DISCARD TERMINATORS AND JUNK &
		!		CONVERT LOWER CASE TO UPPER CASE &
		!		DISCARD TRAILING SPACES AND TABS; &
		!	HOLD THE LENGTH OF THE CONVERTED STRING IN A &
		!	 CONVENIENT PLACE. &
	&
		! FIELD THE ENTIRE BUFFER TO MAKE SURE THAT IT WILL BE &
		!  CLEARED ON THE FIRST ITERATION. &
	&
		! FOR ALL 7 (GROUPS OF) LINES : &
		!	NULL OUT THE USED PART OF THE BUFFER; &
		!	SET THE 'CURRENT POSITION IN THE BUFFER' TO THE &
		!	 BEGINNING; &
	&
		!	FOR EACH CHR IN THE STRING TO PRINT : &
		!		GET THE PATTERN WORD FOR THE CURRENT &
		!		 LINE; &
		!		INITIALIZE THE COMPARISON WORD TO THE &
		!		 FIRST BIT; &
	&
		!		WHILE THE LOOP HAS NOT BEEN EXECUTED 5 &
		!		 TIMES (THE LTRPRT% VARIABLE IS DOUBLED &
		!		 EACH TIME THROUGH THE LOOP TO ADVANCE &
		!		 THE VALUE TO THE NEXT HIGHER BIT) : &
		!			IF THE PATTERN WORD HAS NO BIT &
		!			 SET IN THIS POSITION, THEN &
		!				PUT IN A BLOCK OF CHRS. &
		!			INCREMENT THE CURRENT POSITION &
		!			 IN THE LINE PAST THE BLOCK OF &
		!			 CHARS JUST PUT IN; &
		!			DOUBLE THE LTRPRT% VARIABLE TO &
		!			 MOVE THE MASK BIT UP TO THE &
		!			 NEXT BIT VALUE; &
		!		LOOP 5 TIMES; &
		!		MOVE THE CURRENT POSITION POINTER BY ONE &
		!		 MORE BLOCK IN ORDER TO LEAVE ROOM &
		!		 BETWEEN BLOCK CHARACTERS; &
		!	GO ON TO THE NEXT CHAR; &
	&
		!	BACK UP THE CURRENT POSITION POINTER, BECAUSE IT &
		!	 WAS INCREMENTED AFTER THE LAST CHAR BLOCK PUT &
		!	 IN (TO LEAVE SPACE BEFORE THE NEXT CHR) AND THE &
		!	 SPACE IS UNNECESSARY; &
		!	PUT IN A CR/LF; &
	&
		!	PUT THE DATA WDDV40% TIMES, INCREMENTING THE &
		!	 LAST LINE PRINTED COUNTER FOR EACH PUT; &
	&
		!	FIELD THE PART OF THE BUFFER JUST USED TO NULL &
		!	 IT OUT ON THE NEXT LOOP; &
		! AND LOOP FOR ALL 7 VERTICAL PARTS OF THE BLOCK CHRS. &
	&
		! AND EXIT. &

14200	HOLD%=0% &
	\ IF DEVICE%=LPINDX% THEN &
		FIELD #OUTBUF%,1% AS Z$ &
	\	LSET Z$=CHR0$ &
	\	HOLD%=1% &
		! IF THE DEVICE IS LINE-PRINTER, THEN &
		!	SET UP TO PUT A NULL CHARACTER FROM THE BUFFER. &

14230	E%=0% &
	\ PUT #OUTBUF%,RECORD (4% AND DEVICE%=LPINDX%),COUNT HOLD% IF &
		HOLD% &
	\ SLEEP 1% WHILE PEEK(Q0%+10%)<>PEEK(Q0%+12%) IF &
		DEVICE%=KBINDX% &
	&
	\ RETURN &
	&
		! 'WAIT FOR EMPTY OUTPUT BUFFERS' - &
	&
		! DO A 'PUT,RECORD 4' (WAIT FOR EMPTY BUFFERS) IF THE &
		!  DEVICE IS LP:; &
		! WAIT FOR EMPTY BUFFERS IF THE DEVICE IS KB:; &
		! EXIT. &
	&

14300	FIELD #OUTBUF%,1% AS Z$ &
	\ LSET Z$=CHR0$ &
	\ IF OUTHNG%=0% THEN &
		T$= &
		FNM0$(FNU$(Q9%,NULSTG$,4096%,0%)+" hung",J9%,P0%,0%, &
		 PGEFLG%)+ &
			C9$+"(Put device ONLINE to continue)" &
	\	GOSUB 23500 &
	\	OUTHNG%=-1% &
		! SET UP A NULL CHARACTER TO PRINT IN THE WAIT LOOP; &
		! IF THE MESSAGE HAS NOT BEEN ISSUED BEFORE, THEN &
		!	SET UP THE MESSAGE; &
		!	GO ISSUE IT; &
		!	SET THE 'MESSAGE ISSUED' FLAG. &

14320	E%=0% &
	\ F1%,S0%=0% \ GOSUB 21000 &
		! RESET THE ERROR FLAG; &
		! GO POLL FOR MESSAGES. &

14330	E%=0% &
	\ PUT #OUTBUF%,COUNT 1% &
	\ E%,OUTHNG%=0% &
	&
	&
	\ RETURN &
	&
		!	DO THE 'PUT' LOOP; &
		!	IF IT WAS SUCCESSFUL, THEN &
		!		RESET THE 'OUTPUT HUNG MESSAGE SENT' &
		!		 FLAG. &
	&
		! AND EXIT. &
	&

14400	RETURN		IF DEVICE% = KBINDX% &
	\ PRTLNE%=-1% &
	\ SKPCNT%=0% &
	\ FIELD #OUTBUF%,1% AS Z$ &
	\ LSET Z$=CHR0$ &
	\ E%=0% \ PUT #OUTBUF%,RECORD 8%,COUNT 1% &

14420	OUTHNG%=0% &
	&
	&
		! SET THE 'LAST LINE PRINTED' COUNTER TO AN INVALID &
		!  VALUE, AND RESET THE SKIP COUNT; &
		! PUT A NON-PRINTING CHARACTER INTO THE OUTPUT BUFFER; &
		! TRY TO PUT IT; &
		! WHEN THE PUT IS SUCCESSFUL, CLEAR THE 'OUTPUT HUNG' &
		!  FLAG, IN CASE IT IS SET, AND GO DO THE 'GET TO TOP &
		!  OF FORM' ROUTINE. &
	&

14500	IF PRTLNE%>-1% THEN &
		NEWLNE%=PRTLNE% &
	ELSE	GO TO 14600	IF OTOPF% = 0% AND PRTLNE% < 0% &
	\		CTLLEN%=2% &
	\		CTLTBL%(0%),CTLTBL%(1%) = 1% &
	\		CTLTBL%(2%),CTLTBL%(3%) = 0% &
	\		SKPCNT%=0% &
	\		GOTO 14530 &
		! 'GET TO TOP OF FORM' - &
	&
		! IF THE CURRENT LINE IS NOT ACCURATE (IE, IS LESS THAN &
		!  1), THEN &
		!	IF NO TOP OF PHYSICAL FORM IS AVAILABLE, THEN &
		!		GOTO THE FORM ALIGNMENT ROUTINE; &
		!	ELSE	SET UP TO GENERATE A CHR$(12%) (<FF>) &
		!		 INTO THE AUXILIARY BUFFER; &
		!		GO DO THE GENERATION. &

14520	GO TO 14540	IF PRTLNE% = 1% &
	\	FSTLNE% = PRTLNE% &
	\	SKPCNT%=FRMLEN%-FSTLNE%+1% &
	\	SKPCNT%=SKPCNT%+FRMLEN% WHILE SKPCNT%<=0% &
	\	PGECNT% = FNPUSH%(PGECNT%) &
	\	CURLNE% = FNPUSH%(CURLNE%) \ CURLNE% = FSTLNE% &
	\	RESFLE% = FNPUSH%(RESFLE%) \ RESFLE% = 0% &
	\	GOSUB 13500 &
	\	RESFLE% = FNPOP% &
	\	CURLNE% = FNPOP% &
	\	PGECNT% = FNPOP% &
		! SET THE CURLNE POINTER TO THE LINE NUMBER OF THE LAST &
		!  DATA ACTUALLY 'PUT'; &
		! CALCULATE THE NUMBER OF LINES TO SKIP TO GET FROM &
		!  THAT LINE TO THE FIRST LINE OF A FORM; &
		! GO SET UP THE CONTROL TABLES. &

14530	IF CTLLEN% THEN &
		GENBUF%=OUTBUF% &
	\	GENCNT%=OUTBFS% &
	\	INCVAL%=1% &
	\	INCPOS%=0% &
	\	GOSUB 14000 &
	\	FSTLNE%,PRTLNE%=NEWLNE% &
	\	E%=0% \ PUT #GENBUF%, RECORD 2%, COUNT INCPOS% &
	\	GOTO 14530 &
		! IF ANY CONTROL STRING IS LEFT, THEN &
		!	SET UP TO GENERATE IT INTO THE AUXILIARY BUFFER; &
		!	GENERATE IT; &
		!	DECREMENT THE LENGTH OF THE CONTROL STRING BY &
		!	 THE NUMBER OF CHARACTERS GENERATED; &
		!	UPDATE THE 'PRINTED LINE' COUNTER; &
		!	PUT IT; &
		!	GO SEE IF ANY MORE. &

14540	SKPCNT%=0% &
	&
	\ RETURN &
	&
		! MAKE SURE THAT THE SKIP COUNT IS RESET. &
	&
		! AND EXIT. &

14600	PRTLNE%=1% IF PRTLNE%<1% OR PRTLNE%>FRMLEN% &
	\ CURLNE% = FNPUSH%(CURLNE%) \ CURLNE% = PRTLNE% &
	\ RESFLE% = FNPUSH%(RESFLE%) &
	\ RESFLE%, SKPCNT%, ASKCNT% = 0% &
	\ LEAD%=(FRMWDT%-11%)/2% \ TRLR%=FRMWDT%-2% &
		! SET UP A CONSTANT HOLDING THE (CHANNEL TO PUT TO) + &
		!  SWAP(CHANNEL FROM WHOSE BUFFER TO PRINT); &
		! SET UP THE NEW VALUE OF PRTLNE IF THE CURRENT VALUE IS &
		!  INVALID; &
		! STORE THE CURRENT VALUES OF CURRENT LINE AND RESTART &
		!  FLAG TO PREVENT INTERFERENCE. &

14620	LSET BUFFER$=NULSTG$ \ RECLEN%=FRMWDT% &
	\ Z%=FNF%(0%,-1%,-1%,HH$)+FNF%(LEAD%,-1%,-1%,"Top of FORM")+ &
		FNF%(TRLR%,-1%,-1%,HH$) &
	\ NXTLNE%=1% \ GOSUB 14800 &
	&
	\ LSET BUFFER$=NULSTG$ &
	\ Z%=FNF%(0%,1%,-1%,HH$)+FNF%(TRLR%+1%,1%,0%,HH$) &
	\	NXTLNE%=2% \ GOSUB 14800 &
	&
	\	NXTLNE%=FRMLEN%-1% \ GOSUB 14800 &
	&
	\ LSET BUFFER$=NULSTG$ &
	\ Z%=FNF%(0%,-1%,-1%,HH$)+FNF%(LEAD%,-1%,-1%,"End of FORM")+ &
		FNF%(TRLR%,-1%,-1%,HH$) &
	\ NXTLNE%=FRMLEN% \ GOSUB 14800 &
	&
	\ NXTLNE%=1% \ RECLEN%=0% \ GOSUB 14800 &
		! NOW, CLEAR OUT THE BUFFER; &
		! SET UP FOR THE FIRST LINE OF THE PRINTOUT; &
		! PRINT IT ON THE FIRST LINE; &
		! SET UP THE SECOND AND NEXT TO LAST LINES AND PRINT &
		!  THEM; &
		! SET UP AND PRINT THE LAST LINE; &
		! PRINT A NULL RECORD IN ORDER TO GET TO THE TOP OF THE &
		!  NEXT FORM. &

14630	T$ = "If forms are properly aligned, enter 'GO'" + C9$+ &
		"Otherwise, enter 'RETRY':  " &
	\ S0%=0% \ F1%=18%+NOT32767% \ GOSUB 23500 \ GOSUB 21000 &
	\ F1% = F1% AND 32767% &
	\ IF F2%<0% THEN &
		F2%=F2% AND 32767% &
	\	GOTO 14620 IF FNR%("RETRY",3%) &
	\	IF FNR%("GO",2%)=0% THEN &
			T$="Illegal response - '"+C$+"'" &
	\		GOSUB 23500 &
	\		GOTO 14630 &
		! SET UP AND ISSUE THE APPROPRIATE MESSAGE; &
		! GET A RESPONSE; &
		! IF THE RESPONSE WAS A 'USER RESPONSE', THEN &
		!	RESET THE FLAG; &
		!	GO RETRY IF THAT WAS THE RESPONSE; &
		!	IF THE RESPONSE WAS NOT 'GO', THEN &
		!		ISSUE AN ERROR; &
		!		GO RETRY ON THE MESSAGE. &

14680	RESFLE% = FNPOP% &
	\ CURLNE% = FNPOP% &
	\ R% = R% AND -257% &
	&
	\ RETURN &
	&
		! POP THE STORED VALUES OF THE RESTART FLAG AND THE &
		!  CURRENT LINE. &
		! THEN CLEAR THE FORMS ALINGMENT REQUESTED FLAG &
	&
		! AND EXIT. &

14700	T$ = T$ + "    " + NUM1$(FCOPYR%-FCOPYP%)+" Copy(s) not printed" &

14705	GO SUB 16100 &
	\ GO TO 4950 &
		! PRINT MESSAGE.    PRINT SPLATS. GO TO END &
		! OF FILE PROCESSING SO OTHER FILES IN STRING CAN BE &
		! PRINTED &

14710	Z% = FNPUSH%(E%) &
	\ OPEN "_NL:" FOR INPUT AS FILE INBUF%, RECORDSIZE 512% &
	\ FIELD #INBUF%,BUFSIZ(INBUF%) AS BUFFER$ &
	\ GO SUB 14500	IF PRTLNE% <> 1% &
	\ GO SUB 16000	IF HEADFL% <> 0% &
	\ Z%=FNPOP% &
	\ T$ = CVT$$(RIGHT(SYS(CHR6.9$+CHR$(Z%)),3%),4%) IF Z% < 128% &
	\ T$ = "?0 LENGTH FILE" IF Z% = 128% &
	\ T$ = "?FILE TOO LONG" IF Z% = 129% &
	\ T$ = "?UNSUPPORTED FILE ORGANIZATION" IF Z%=130% &
	\ JOB.ERR% = -1% UNLESS Z%=128% &
		! DON'T SET THIS VARIABLE IF IT'S A "0 LENGTH FILE" &
		! OTHERWISE THE FILE WON'T GET DELETED &
	\ GO TO 14705 &
	! HANDLE FILE ERRORS &

14720	T$ = "File skipped by operator" &
	\  GO TO 14700 &
	! SET UP FILE SKIPPED MESSAGE AND GO PRINT IT &

14730	T$ = "?Job Aborted because of File Error(s)" &
	\ R0%,Z0%(J9%,31%)= R0% OR 1% &
	\  GO SUB 16100	IF HEADFL% &
			IF JCOPYR% > 1% &
	\  GO TO 7000 &
		! HANDLE END OF JOB DUE TO FILE ERRORS &
		! SET JOB ABORT FLAG &
	&

14800	CURLNE%,FSTLNE%=PRTLNE% &
	\ FSTLNE%=FSTLNE%-FRMLEN% WHILE FSTLNE%>NXTLNE% &
	\ SKPCNT%=NXTLNE%-FSTLNE% &
	\ NEWLNE%=PRTLNE% &
	\ GOTO 14840 UNLESS SKPCNT% &
	\ GOSUB 13500 &
	\ SKPCNT%=0% &
		! CALCULATE THE LINE THE PRINTER WOULD BE ON &
		!  AFTER ALL OUTSTANDING SKIPS ARE PERFORMED, THEN &
		!  CALCULATE THE NUMBER OF EXTRA SKIPS TO GET &
		!  TO THE DESIRED LINE; &
		! GO DIRECTLY TO PRINT IF NO SKIPS ARE NEEDED; &
		! OTHERWISE, SET UP THE CONTROL TABLES. &

14820	INCVAL%=1% \ INCPOS%=0% \ GENCNT%=OUTBFS% &
	\	GENBUF%=OUTBUF% \ GOSUB 14000 &
	\ 	IF CTLLEN% THEN &
		PRTLNE%=NEWLNE% &
	\	E%=0% \ PUT #OUTBUF%, RECORD 2%, COUNT INCPOS% &
	\	GOTO 14820 &
		! SET UP TO DO AND DO THE CONTROL STRING GENERATION; &
		! IF NOT ALL OF THE CONTROL STRING FITS, THE &
		!	PUT THIS MUCH OF IT AND GO REGENERATE. &
	&

14830	E%=0% &
	\ IF INCPOS% THEN &
		PRTLNE%=NEWLNE% &
	\	HOLD%=INCPOS% &
	\	INCPOS%=0% &
	\	PUT #OUTBUF%, RECORD 2%, COUNT HOLD% &
		! MAKE SURE THAT THE REMAINDER OF THE CONTROL INFO IS &
		!  OUTPUT. &

14840	E%=0% &
	\ PUT #SWPBUF%, RECORD 2%, COUNT RECLEN% IF RECLEN% &
		! PUT THE RECORD BEING PUT &

14850	NXTLNE% = PRTLNE% + 1% &
	\ RETURN &
		!  EXIT. &
	&

14900	RECLEN% = FRMWDT% &
	\  RECLEN% = 126%	IF FRMWDT% > 126% &
	\  RECLEN% = RECLEN% - 6% &
	\  Z% = Z0%(8%,0%) &
	\  FIELD #1%, ((120%-RECLEN%)/2%) AS SPLAT0$, RECLEN% AS SPLAT0$ &
	\  LSET BUFFER$ = NULSTG$ &
	\  INPPOS% = 0% &
	\  Z% = FNF%(0%,3%,-1%,"[[[") &
		+FNF%(3%,RECLEN%,-1%,SPLAT0$) &
		+FNF%(RECLEN%+3%,3%,-1%,"]]]") &
	\  RECLEN% = INPPOS% \ INPPOS% = 0% &
	\	GOSUB 14800 &
	\	GOSUB 14800 &
	&
	\  RETURN &
	!  SET SPLAT LINES COVER FIELDS.  LENGTH IS FORM WIDTH. CLEAR THE &
	!  WORKING BUFFER.  GET FIRST STRING. ADVANCE 2 SPACING LINES &
	!  PRINT THE LINE.  GET THE SECOND LINE. ADVANCE TO NEXT LINE. &
	!  PRINT THE LINE.  RESET THE INPUT BUFFER POSITION. &
	&
	!  RETURN &

15000	DEF* FNM0$(T$,J9%,P0%,E%,PGEFLG%) &

15010	T$=T$+" - " IF LEN(T$) &
	\ IF J9% THEN &
		T$=T$+" Job: "+FNU$(J9%,NULSTG$,129%,0%) &
	\	IF P0% THEN &
			T$=T$+"	File - "+FNU$(P0%,NULSTG$,-1%,0%) &
	\		IF PGECNT% THEN &
				T$=T$+C9$ &
	\			T$=T$+"Page: "+NUM1$(PGECNT%)+ &
				 "	" IF PGEFLG% &
	\			T$=T$+"Block: "+NUM1$(BLKCNT%) &

15090	T$=T$+C9$+ &
		CVT$$(RIGHT(SYS(CHR6.9$+CHR$(E%)),2%), &
			4%) IF E% &
	&
	\ FNM0$=T$ &
	&
	\ FNEND &
		! AND EXIT. &
	&

15200	DEF* FNF%(BEGPOS%,LENS%,LSETFL%,STRNG$) &
	&
	\ BEGPOS%=INPPOS% IF BEGPOS%<0% &
	\ LENS%=LEN(STRNG$) IF LENS%<0% &
	\ FIELD #INBUF%,BEGPOS% AS Z$,LENS% AS Z$ &
	\ LSET Z$=STRNG$ IF LSETFL% &
	\ RSET Z$=STRNG$ UNLESS LSETFL% &
	\ Z%=BEGPOS%+LENS% &
	\ INPPOS%=Z% IF Z%>INPPOS% &
	\ FNF%=INPPOS% &
	&
	\ FNEND &
	&

16000	GO SUB 16400 &
	\ NXTLNE% = 1% &
	\ LSET H$ = LEFT(FNU$(P0%,NULSTG$,9%,-1%),6%) &
	\	GO SUB 14100 &
	\ RECLEN% = 0% \ NXTLNE% = NXTLNE% + WDDV40% + (WDDV40%-1%) &
	\	GO SUB 14800 &
	\ LSET H$ = MID(FNU$(P0%,NULSTG$,9%,-1%),8%,3%) &
	\	GO SUB 14100 &
	\ RECLEN% = 0% \ NXTLNE% = NXTLNE% + (WDDV40%-1%) &
	\	GO SUB 14800 &
	\	GO SUB 14900 &
	\ RECLEN% = 0% &
	\	GO SUB 14800 &

16010	LSET BUFFER$ = NULSTG$ &
	\ Z% = FNF%(0%,-1%,-1%,A1$) &
		+FNF%(27%,9%,-1%,	DATE$(0%)) &
		+FNF%(40%,8%,-1%,	TIME$(0%)) &
	\ RECLEN% = INPPOS% \ INPPOS% = 0% &
	\	GO SUB 14800 &

16020	LSET BUFFER$ = NULSTG$ &
	\ Z% = FNF%(0%,-1%,-1%, &
	   "Copy XXXXX of XXXXX    /Delete:  NO   File = ") &
		+FNF%( 5%, 5%, 0%, NUM1$(FCOPYP%+1%)) &
		+FNF%(14%, 5%, 0%, NUM1$(FCOPYR%   )) &
		+FNF%(45%,30%, -1%, FNU$(P0%,NULSTG$,-1%,-1%)) &
	\ Z% = FNF%(32%,3%,-1%,"YES")	IF (FSSW% AND 4%) &
	\ RECLEN% = INPPOS% \ INPPOS% = 0% &
	\	GO SUB 14800 &

16030	T$ = "Record type:  " &
	   +MID("STREAM  FIXED   VARIABLEVFC     ",(8%*RCRDTY%+1%+SOSLNE%),8%) &
	\  T$ = T$ + "   Format type:  " &
		   +MID("EMBEDDED  FORTRAN   IMPLIED             PRINT     ", &
				(10%*FORMAT%+1%),10%) &
	\ LSET BUFFER$ = NULSTG$ &
	\ Z% = FNF%(0%,LEN(T$),-1%,T$) &
	\ RECLEN% = INPPOS% \ INPPOS% = 0% &
	\	GO SUB 14800 &

16040	RECLEN% = 0% &
	\	GO SUB 14800 &
	\	GO SUB 14900 &
	\	GO SUB 16450 &
	\	GO SUB 14500 &
	\ RETURN &
		! FILE BURST PAGE - FINISH PREVIOUS PAGE IF NECESSARY. &
		! OUTPUT FILE NAME IN BLOCK LETTERS, FOLLOWED BY TWO &
		! SPACING 'LINES'.  THEN OUTPUT THE FILENAME EXTENSION &
		! IN BLOCK LETTERS.  NEXT, SPLAT, A BLANK LINE, THEN &
		! JOB NAME, DATE AND TIME OF PRINTOUT FOR USER MSG. &
		! NEXT IS COPY N OF M, THE DELETE FLAG SETTING AND &
		! THE FULLY SPECIFIED FILENAME FOR THIS FILE. &
		! A SINGLE BLANK LINE IS THEN FOLLOWED BY A SPLAT AND &
		! THE PAGE IS COMPLETE &

16100	GO SUB 14500	IF PRTLNE% <> 1% &
	\ RESFLE% = FNPUSH%(RESFLE%) \ RESFLE% = 0% &
	\	GO SUB 16400 &
	\ NXTLNE% = 1% &
	\ 	GO SUB 14900 &
	\	GO SUB 14900 &
	\ RECLEN% = 0% &
	\	GO SUB 14800 &
	\ LSET BUFFER$ = NULSTG$ &
	\ Z% = FNF%(0%,-1%,-1%,T$) &
	\ RECLEN% = INPPOS% \ INPPOS% = 0% &
	\	GO SUB 14800 &
	\ RECLEN% = 0% &
	\	GO SUB 14800 &
	\	GO SUB 14900 &
	\	GO SUB 14900 &
	\	GO SUB 16450 &
	\	GO SUB 14500 &
	\ T$ = NULSTG$ &
	\ RESFLE% = FNPOP% &
	&
	\ RETURN &
	! OUTPUT ABNORMAL END (ABEND) PAGE.  FIRST, FINISH CURRENT PAGE &
	! THEN DOUBLE SPLAT, A SPACING LINE.  PRINTOUT CONDITION TEXT &
	! STRING, A SPACING LINE, THEN ANOTHER DOUBLE SPLAT.  FINISH THE &
	! PAGE AND EXIT &

16200	GO SUB 16400 &
	\ NXTLNE% = 1% &
	\ FIELD #INBUF%, 1% AS SIZE$ &
	\ LSET H$ = NUM1$(SWAP%(Z0%(J9%,8%)) AND 255%) &
	\ Z$ = "   " &
	\ RSET Z$ = NUM1$(Z0%(J9%,8%) AND 255%) &
	\ LSET H$ = LEFT(H$,3%) + Z$ &
	\	GO SUB 14100 &
	\ RECLEN% = 0% \ NXTLNE% = NXTLNE% +1% &
	\	GO SUB 14800 &
	\	GO SUB 14900 &
	\ RECLEN% = 0% &
	\ 	GO SUB 14800 &
	&
	\ FOR Z9% = 9% TO 13% &
	\	Z% = Z0%(Z9%,0%) &
	\	FIELD #1%, (Z9% AND 3%)*128% AS Z9$, 128% AS Z9$ &
	\	Z% = FNF%(0%,-1%,-1%,Z9$) &
	\	Z% = FNF%(11%,1%,-1%,NUM1$(JCOPYP%+1%)) IF Z9% = 13% &
	\	RECLEN% = ASCII(SIZE$) \ LSET SIZE$ = CHR0$ \ INPPOS% = 0% &
	\		GO SUB 14800 &
	\	A1$ = MID(BUFFER$,2%,RECLEN%-1%)	IF Z9% = 9% &
	\ NEXT Z9% &
	&
	\ RECLEN% = 0% &
	\	GO SUB 14800 &
	\	GO SUB 14900 &
	\ RECLEN% = 0% \ NXTLNE% = NXTLNE% + 2% &
	\	GO SUB 14800 &
	\ LSET H$ = JOBNAM$ &
	\	GO SUB 14100 &
	\ RECLEN% = 0% \ NXTLNE% = NXTLNE% + 1% &
	\	GO SUB 14800 &
	\	GO SUB 14900 &
	\	GO SUB 14900 &
	\	GO SUB 14500 &
	\	GO SUB 16450 &
	\ RETURN &
	! OUTPUT JOB BURST PAGE.  PROJ-PROG #, THEN SPLATS. &
	! GET JOB DESCRIPTIVE INFORMATION OUT OF WORK FILE &
	! THEN SPLATS, FOLLOWED BY JOB NAME, FINALLY WITH SPLATS &

16300	  Z8% = 1% &
	\ WHILE Z8% &
	\	Z8% = INSTR(Z8%,BUFFER$,"0") &
	\	RETURN	IF Z8% = 0% OR Z8% > HOLD% &
	\	FIELD #INBUF%, (Z8%-1%) AS Z9$, 1% AS Z9$ &
	\	LSET Z9$ = "O" &
	\	Z8% = Z8% + 1% &
	\ NEXT &
	! FOR THE LENGTH OF THE OUTPUT BUFFER STRING, SCAN &
	! FOR EACH OCCURANCE OF THE LETTER 0 (ZERO), FIELD &
	! THE CHARACTER AND REPLACE IT WITH THE LETTER O. &
	! SCAN AND REPLACE TERMINATES ON END OF BUFFER OR &
	! END OF SEGMENT TO BE PRINTED &

16400	  Z% = FNPUSH%(SKPSIX%) \ SKPSIX% = 0% &
	\ Z% = FNPUSH%(OSKPSI%) \ OSKPSI% = 0% &
	\ RETURN &
		! SAVE SKIP SIX PARAMETERS &

16450	  OSKPSI% = FNPOP% &
	\ SKPSIX% = FNPOP% &
	\ RETURN &
		! RESTORE SKIP SIZ PARAMETERS &
	&

19000	RESUME 19995  IF ERL=19990% &
	\ E1%=ERL UNLESS (E% AND 63%) \ E%=ERR UNLESS (E% AND 63%) &
	\ RESUME 19020 &
		! SET UP THE ERROR VALUE AND LINE; &
		! MAKE SURE OF THE RESUME. &

19020	ON ERROR GOTO 19000 &
		! MAKE SURE THE ERROR TRAP IS STILL ACTIVE. &

19030	IF E1%=4100% OR E1%=4950% THEN &
		GOTO 14710 &
		! IF THE ERROR OCCURRED WHEN TRYING TO READ OR &
		!  CLOSE THE INPUT FILE, THEN &
		!	GO PRINT THE ERROR. &

19040	IF E1%=4420% OR E1%=4430% THEN &
		GOSUB 14300 IF E%=14% &
	\	GOTO 4410 UNLESS E% &
			! ERROR WHEN TRYING TO 'PUT' A CTRL STRING FROM &
			!  THE AUXILIARY BUFFER OR FROM BEGIN PART OF &
			!  BUFFER : &
			! ANY ERROR OTHER THAN 'DEVICE HUNG' &
			!  NETS A FATAL ERROR; &
			! IF ONE OF THESE, THEN &
			!	GO CLEAR THE ERROR CONDITION; &
			!	PRETEND THAT THE ORIGINAL OPERATION &
			!	 WORKED, IF THE ERROR CONDITION WAS &
			!	 SUCESSFULLY CLEARED. &

19050	IF E1%=4610% THEN &
		GOSUB 14300 IF E%=14% &
	\	GOTO 4620 UNLESS E% &
			! ERROR WHEN TRYING TO DO THE PRIMARY 'PUT' TO &
			!  THE OUTPUT DEVICE : &
			! IF THE ERROR WAS 'DEVICE HUNG', THEN &
			!	GO TRY TO CLEAR THE ERROR CONDITION; &
			!	IF THE ERROR WAS NOT SUCCESSFULLY &
			!	 CLEARED, THEN &
			!		ERROR IS FATAL; &
			!	ELSE	GO BACK TO THE ROUTINE. &

19210	IF E%=14% THEN &
		IF (E1%/1000%)=14% AND E1%<>14330% THEN &
			E1% = FNPUSH%(E1%) &
			\ GOSUB 14300 &
			\ E1% = FNPOP% &
	\		IF E%=0% THEN &
				GOTO 14130 IF E1%=14120% &
	\			GOTO 14230 IF E1%=14230% &
	\			GOTO 14420 IF E1%=14400% &
	\			GOTO 14530 IF E1%=14530% &
	\			GO TO 14820 IF E1% = 14820% &
	\			GO TO 14840 IF E1% = 14830% &
	\			GO TO 14850 IF E1% = 14840% &
		! IF ERROR IS DEVICE HUNG, THEN &
		!	IF THE ERROR LINE WAS IN THE CLEAN-UP ROUTINE &
		!	 AND IT WAS NOT IN THE DEVICE HUNG ROUTINE, &
		!	 THEN &
		!		CALL THE DEVICE HUNG ROUTINE; &
		!		GO BACK TO THE PROCESS THAT WAS &
		!		 INTERRUPTED : &
		!		14230	- WAITING FOR EMPTY BUFFERS; &
		!		14420	- KILL BUFFERS &
		!		14530	- GET TO TOP OF FORM &
		!		148XX	- PRINT A LINE &
		!		 14830	- PUT OF CONTROL STRING &
		!		 14840	- PUT OF TEXT. &

19220	IF E%=14% AND E1%=14330% THEN &
		SLEEP 10% &
	\	GOTO 14320 &
		! ERROR IN 'OUTPUT HUNG' ROUTINE : &
		!	SLEEP AWHILE AND RETRY. &

19990	FATAL.ERR% = ERR &
	\ Z0%(0%,50%) = ERL &
	\ Z0%(0%,51%) = 31052% &
	\ Z0%(0%,52%) = 29654% &
	\ Z$ = SYS(CHR6.M10$ + MID(I$,2%,3%) + RIGHT(I$,6%)) &
	\ Z0%(0%,53%) = CVT$%(MID(Z$,7%,2%)) &
	\ Z0%(0%,54%) = CVT$%(MID(Z$,9%,2%)) &
	\ GO TO 2000 &
		! PACK IN FATAL ERROR DATA INTO WORK FILE. &
		!	ERROR CODE &
		!	ERROR LINE &
		!	"SPL" IN RAD$() FORM &
		!	"RUN" IN RAD$() FORM &
		!	VERSION/EDIT #'S IN RAD$() FORM &
		!	BACK TO MAIN CONTROL POINT &

19995	T$="??Fatal error while no access to work-file: ERR=" &
	   +NUM1$(E%)+", ERL="+NUM1$(E1%) &
	\  PRINT T$ &
	\  STOP &
	!  PUT THE JOB INTO HIBERNATION WHILE THE JOB IS DETACHED &

20000	Z$=SYS(CHR6.M21.M1$) &
	\	OPEN W$ FOR INPUT AS FILE 1% &
	\	Z$=SYS(CHR6.M21.0$) &
	\ R%=Z0%(0%,26%) &
	\ B0%=Z0%(0%,0%) &
	\ J9%=Z0%(0%,27%) &
	\ FATAL.ERR% = Z0%(0%,49%) &
	\ Q9%=Z0%(0%,4%) &
	\ NOT32767%=NOT 32767% &
	&
	\ M%(0%)=Z0%(0%,19%) &
	\ M%(2%)=Z0%(0%,9%) &
	\ FOR Z%=0% TO 2% STEP 2% &
	\	Z0%=M%(Z%) &
	\	IF Z0% THEN &
			Z0%=Z0%(Z0%,1%) WHILE Z0%(Z0%,1%) &
	\		M%(Z%+1%)=Z0%
20030	  NEXT Z% &
	&
	\ J%=(PEEK(518%) AND 255%)/2% &
	\ J$="  " \ RSET J$=NUM1$(J%) &
	\ J1%=SWAP%(CVT$%(MID(SYS(UU1$),25%,2%))) &
	\ A%=SWAP%(CVT$%(MID(SYS(UU0$),21%,2%))) &
	\ Z$="   " \ RSET Z$=NUM1$(SWAP%(A%) AND 255%) &
	\	A$="["+Z$ \ RSET Z$=NUM1$(A% AND 255%) &
	\	A$=A$+","+Z$+"]" &
	\ K0%=PEEK(J1%) &
	&
	\ C8$=CHR7$ &
	\ C9$=CHR13$+CHR10$ &
	\ GOSUB 23050 IF (R% AND 2048%) &
	\ GOSUB 23100 IF (R% AND 4096%) &
	&
	\ RETURN &
	&
		! DROP PRIVILEGES, (TRY TO) OPEN THE WORK-FILE, AND &
		!  REGAIN PRIVILEGES; &
		! GET THE STATUS WORD OUT OF THE WORK-FILE; &
		! GET THE (WORK-FILE) FREE-LIST POINTER, THE CURRENT JOB &
		!  POINTER, AND THE OUTPUT VOLUME POINTER INTO SOME &
		!  CONVENIENT (IN-MEMORY) VARIABLES. &
	&
		! THESE TWO LINES SET UP THE HEADS AND TAILS OF THE &
		!  INCOMPLETE MESSAGES AND COMPLETED MESSAGES LISTS. &
		!  THE HEADS OF THE LISTS ARE TAKEN DIRECTLY OUT OF THE &
		!  FILE HEADER RECORD OF THE WORK-FILE; THE TAILS MUST &
		!  BE FOUND BY A SCAN, IF THE LISTS ARE NON-EMPTY. &
	&
		! SET UP PARAMETERS FROM THE EXEC : &
		!	GET THE JOB NUMBER INTO J%; &
		!	SET UP A JOB NUMBER STRING IN J$; &
		!	GET THE ACCOUNT NUMBER OF THIS JOB OUT OF THE &
		!	 JDB OF THE JOB; &
		!	TURN THE ACCOUNT NUMBER INTO AN ACCOUNT NUMBER &
		!	 STRING; &
		!	STORE IN K0% THE ADDRESS OF THE I/O BLOCK FOR &
		!	 THIS JOB, FOR LOOKING UP SUCH THINGS AS THE &
		!	 CURRENT KEYBOARD, FOR ATTACHED/DETACHED, OR THE &
		!	 STATUS OF AN OPEN CHANNEL. &
	&
		! SET UP TWO USEFUL STRING CONSTANTS : &
		!	C8$	- A ^G (<BELL>) CHARACTER, FOR &
		!		   NOTIFICATION STRINGS &
		!	C9$	- A <CR><LF> STRING FOR GENERAL USE &
		! CALL THE 'ENTER' ROUTINE IF THE JOB IS ENTERED; &
		! CALL THE 'ONLINE' ROUTINE IF THE JOB IS ONLINE TO &
		!  OPSER; &
		! THESE TWO ROUTINES, ENTER, AND ONLINE, SET &
		!  UP APPROPRIATE CONSTANTS AND STRINGS TO DO THE &
		!  REQUIRED POLLING AND COMMUNICATIONS. &
	&
	&

21000	S1%,S3%=0% &
		! INIT TIMERS TO 0 TO PREVENT A SLEEP ON THE FIRST &
		! TIME THROUGH THE ROUTINE. &
		! TIMERS ARE : &
		!	S1%	- RECEIVE WITH SLEEP TIMER &
		!	S3%	- PLAIN OLD SLEEP TIMER, IN CASE THE &
		!			JOB IS NEITHER ATTACHED NOR A &
		!			RECEIVER. &
	&
	&

21100	TOD.=TIME(0%) &
		! STORE THE ENTRY TIME OF DAY.
21120	R% = R% AND 32767% &
		! REMOVE PROMPT FLAG &

21160	IF (R% AND 2048%) THEN &
		IF (PEEK(J0%) AND -256%) THEN &
			ON ERROR GOTO 19000 &
	\		M$=SYS(CHR6$+CHR$(18%)+CHR$(1%)) &
	\		N1%=ASCII(MID(M$,5%,1%))/2% &
	\		N2%=CVT$%(MID(M$,7%,2%)) &
	\		N%=ASCII(MID(M$,9%,1%)) &
	\		M$=MID(M$,10%, &
			   ((N%-1%) AND N%<21%) OR (19% AND N%>20%)) &
	\		N%=(N%<21%) &
	\		GOTO 21200 &
		! IF THIS JOB IS A RECEIVER, THEN &
		!	IF A MSG IS QUEUED, THEN &
		!		GET IT; &
		!		EXTRACT FROM IT THE JOB # (N1%), PPN &
		!		  PPN (N2%); &
		!		SET UP THE 'COMPLETED' FLAG - -1% IF THE &
		!		 MESSAGE IS COMPLETE, 0 OTHERWISE; &
		!		GO STORE IT AWAY. &

21170	IF S1%=0% THEN &
		GOTO 21400 &
	ELSE	SLEEP S1% &
	\	S1%=0% &
	\	GOTO 21160 &
		! IF NO WAIT TIMER IS SET FOR A SLEEP (S1%), THEN &
		!	GO EXIT FROM THE 'GET A MESSAGE' LOOP; &
		! ELSE	SLEEP THE ALLOTTED TIME; &
		!	RESET THE TIMER, SO NO SLEEP IS DONE NEXT TIME; &
		!	GO SEE IF ANYTHING ARRIVED WHILE YOU WERE OUT. &
	&

21200	GOTO 21400 IF N1%=0% OR (LEN(M$)=0% AND F1%>=0%) &
	\ M%=M%(0%) &
	\ M%=Z0%(M%,1%) WHILE M% AND Z0%(M%,6%)<>N1% &
	\ IF M%=0% THEN &
		M%=FNA% &
	\	Z0%(M%(1%),1%)=M% IF M%(1%) &
	\	Z0%(M%,1%)=M%(1%) &
	\	M%(0%)=M% UNLESS M%(0%) &
	\	M%(1%)=M% &
	\	Z0%(M%,6%)=N1% &
	\	Z0%(M%,7%)=N2% &
	\	N7%,Z0%(M%,12%)=ASCII(M$) &
	\	IF N7%=31% &
		OR (-1% < N7% AND N7% < 6%) &
		THEN &
			M$=RIGHT(M$,2%) &
		ELSE	N7%,Z0%(M%,12%)=6% &
		! SKIP THIS ROUTINE IF NO MESSAGE; &
		! FIND THE PLACE TO INSERT IN INCOMPLETE LIST; &
		! IF NO PARTIAL MESSAGE IS FOUND FOR THIS JOB, THEN &
		!	SET UP AND LINK IN A NEW MESSAGE RECORD; &
		!	SET UP THE DISPATCH CODE : &
		!	IF THE FIRST CHR IS ALREADY A DISPATCH CODE, &
		!	 THEN &
		!		REMOVE IT FROM THE RECORD; &
		!	ELSE	SET UP A DISPATCH OF 6, THE DECODE &
		!		 DISPATCH. &

21220	Z0%(M%,1%) = FNPUSH%(Z0%(M%,1%)) &
	\ Z0%(M%,1%)=Z0%(M%,2%) &
	\ M% = FNPUSH%(M%) &
	\ M0%=Z0%(M%,13%) &
	\ M1%=28% &
	\ WHILE M0%>128%-M1% &
	\	M0%=M0%-(128%-M1%) &
	\	M1%=12% &
	\	M%=Z0%(M%,1%) &
	\ NEXT &
	\ M1%=M0%+M1% &
	\ M2%=LEN(M$) &
	\ M3%=0% &

21230	Z$=Z0$(M%) &
	\ Z0$(M%)=Z$+STRING$(M1%-LEN(Z$),0%)+MID(M$,M3%+1%,128%-M1%) &
	\ M3%=M3%+128%-M1% &
	\ IF M3%<M2% THEN &
		M%,Z0%(M%,1%)=FNA% &
	\	M1%=12% &
	\	GOTO 21230 &

21240	M% = FNPOP% &
	\ Z0%(M%,13%)=Z0%(M%,13%)+LEN(M$) &
	\ Z0%(M%,2%)=Z0%(M%,1%) &
	\ Z0%(M%,1%) = FNPOP% &
	\ IF N% THEN &
		M9%=0% \ M8%=2% \ GOSUB 21300 &

21250	GOTO 21400 &
	&

21300	M0%=Z0%(M%,0%) &
	\ M1%=Z0%(M%,1%) &
	\ Z0%(M%,1%)=0% &
	\ Z0%(M0%,1%)=M1% IF M0% &
	\ Z0%(M1%,0%)=M0% IF M1% &
	\ M%(M9%)=M1% UNLESS M0% &
	\ M%(M9%+1%)=M0% UNLESS M1% &
	&
	\ WHILE M8% &
	\	M0%=M%(M8%+1%) &
	\	Z0%(M%,0%)=M0% &
	\	Z0%(M%,1%)=0% &
	\	Z0%(M0%,1%)=M% IF M0% &
	\	M%(M8%+1%)=M% &
	\	M%(M8%)=M% UNLESS M0% &
	\	M8%=0% &
	\ NEXT &
	\ RETURN &
	&

21350	T$="Illegal command" &
	\ E%=-1% &
	\ RETURN &
		! IF THE COMMAND ENTERED WAS A RECOGNIZABLE COMMAND, BUT &
		!  WAS NOT LEGAL FOR THIS PROGRAM, THEN &
		!	SET UP AND ISSUE A MESSAGE TO THAT EFFECT; &
		!	EXIT. &
	&
	&

21400	WHILE M%(2%) &
	\	M%=M%(2%) &
	\	P% = Z0%(M%,11%) &
	\	N7%=Z0%(M%,12%) &
	\	C$=FNUNPACK$(M%,26%) &
	\	E%=0% &
	\	ON N7% GOSUB &
			23600,23600,24300,23600,23600,21600,23600,21750, &
			22420,22430,21350,21350,22000,22100,21350,23600, &
			23600,23600,21740,23600,22400,21760,21350,21350, &
			21350,21770,21350,21350,21350,21350,23600 &
				IF (0% < N7% AND N7% < 32%) &
	\	WHILE E% AND M%<>0% &
	\		T$="%"+T$+C9$+"'"+C$+"' Ignored" &
	\		GOSUB 23500 &
	\		E%=0% &
	\	NEXT &
	\	WHILE M% &
	\		M9%=2% \ M8%=0% \ GOSUB 21300 &
	\		Z0%(M%,1%)=0% \ M%=FNA0%(M%) &
	\	NEXT &
	\ NEXT &
	&
	\ IF S3% THEN &
		SLEEP S3% &
	\	S3%=0% &
	\	GOTO 21160 &
	&
		! WHILE THERE ARE ANY COMPLETE MESSAGES : &
		!	SET UP THE MESSAGE NUMBER IN M%; &
		!	DISPATCH TO THE PROPER ROUTINE FOR THE MESSAGE'S &
		!	 TOKEN : &
		!	1        	S	NEWJOB FROM QUEMAN &
		!	2        	S	ENDJOB FROM QUEMAN &
		!	3   24300	P	KILLJOB FROM QUEMAN &
		!	4        	S	NEXT (FILE) PACKET FROM &
		!				 QUEMAN &
		!	5		S	ONLINE REQUEST FROM &
		!				 QUEMAN &
		!	6   21600	P	COMMAND DECODE &
		!	7        	S	ONLINE FROM KB:/OPSER &
		!	8        	S	OFFLINE FROM OPSER &
		!	9   22420	P	PAUSE &
		!	10  22430	P	CONTINUE &
		!	11       	S	TRANSFER THE LOG FILE &
		!	12       	R	INSERT A NOTICE TO THE &
		!				 OUTPUT LOG &
		!	13  22000	P	RETYPE LAST MESSAGE &
		!	14  22100	P	RETURN A STATUS REPORT &
		!	15		R	DISALLOWED LEGAL COMMAND &
		!	16       	S	ENTER STEP MODE OR STEP &
		!				 JOB &
		!	17       	S	EXIT STEP MODE &
		!	18       	S	END OPERATIONS (IE, KILL &
		!				 YOURSELF) &
		!	19  21740	P	ABORT THE CURRENT &
		!				 PROCESS &
		!	20       	S	CHANGE FORMS &
		!	21  22400	P	RESTART THE CURRENT &
		!				 PROCESS &
		!	22  21760	P	REQUE THE CURRENT &
		!				 PROCESS &
		!	23       	R	SEND THE SPECIFIED &
		!				 FILE(S) NEXT &
		!	24       	R	INTERRUPT THE CURRENT &
		!				 PROCESS IN ORDER TO &
		!				 SEND THE SPECIFIED &
		!				 FILE(S) &
		!	25		R	CHANGE THE OUTPUT &
		!				 FILE(S) FOR PRINT OR &
		!				 PUNCH OUTPUT &
		!	26  21770	P	RESPONSE TO BE RETURNED &
		!				 TO CALLER &
		!	27       	R	TAKE THE JOB OFF LINE &
		!				 FROM OPSER &
		!	28       	R	PUT THE JOB ONLINE TO &
		!				 QUEMAN &
		!	29       	R	TAKE THE JOB OFF LINE &
		!				 FROM QUEMAN &
		!	30  		R	DETACH THE JOB &
		!	31		S	FORMS CHANGE ACK FROM &
		!				 QUEMAN &
		!	IF ANY ERROR IS SET UPON RETURN, THEN &
		!		SET UP AND PRINT AN ERROR MESSAGE; &
		!	IF, UPON RETURN FROM THE PROCESS, THE MESSAGE &
		!	 POINTER IS NON-ZERO, THEN &
		!		REMOVE THE MESSAGE FROM THE COMPLETE &
		!		 LIST AND REPLACE IT IN THE FREE-LIST; &
		! LOOP UNTIL NO MORE COMPLETED MESSAGES EXIST. &
	&
		! IN THE ABOVE TABLE, THE ANNOTATION 'S' MEANS THAT ANY &
		!  MESSAGE OF THIS FORM IS STORED IN THE WORK-FILE BY &
		!  PROGRAM FOR LATER PROCESSING BY SOME OTHER MODULE OF &
		!  THE PACKAGE; THE 'P' MEANS THAT THIS MESSAGE TYPE IS &
		!  AT LEAST PARTIALLY PROCESSED BY THIS MODULE OF THE &
		!  PACKAGE; THE 'R' MEANS THAT THE COMMAND IS NOT LEGAL &
		!  FOR THIS PACKAGE, AND HAS BEEN REMOVED FROM THE LEGAL &
		!  COMMAND LIST. &
	&
		! IF THE 'SLEEP TIMER' (S3%) IS NON-ZERO, THEN &
		!	GO INTO A SLEEP FOR MORE DATA; &
		!	RESET SLEEP TIMER SO NO SLEEP IS DONE NEXT TIME; &
		!	GO SEE IF ANYTHING ARRIVED WHILE YOU WERE OUT. &
	&
	&

21500	TOD.=TIME(0%)-TOD. &
	\ TOD.=TOD.+86400. IF TOD.<0. &
	\ IF TOD.>65535. THEN &
		T0%=S0% &
	  ELSE	T0%=TOD.-32768. &
	\	T0%=T0% EQV 32767% &
		! STORE THE ELAPSED EXECUTION TIME; &
		! ADJUST FOR DATE WRAP-AROUND, IF NECESSARY; &
		! IF THE ELAPSED TIME IS GREATER THAN WHAT CAN BE HELD &
		! IN AN INTEGER, THEN &
		!	SET THE ELAPSED TIME TO THE REQUESTED TIME; &
		! ELSE	PUT IT IN AN INTEGER, ADJUSTING FOR THE SIGN &
		!	BIT.
21520	F2%=F2% AND -2% &
	\ T0%=S0%-T0% &
	\ F2%=F2% OR 1% IF T0%=0% OR (T0%<0% AND S0%>-1%) &
	\ T0%=0% IF (F2% AND 1%) &
	\ S0%=T0% &
		! RESET THE 'SLEEP TIME EXPIRED' FLAG; &
		! CALCULATE THE NEW 'SLEEP TIME' VALUE; &
		! SET THE 'SLEEP TIME EXPIRED' FLAG IF EITHER &
		!  THE NEW SLEEP TIME IS 0 &
		!	OR &
		!  THE OLD SLEEP TIME WAS POSITIVE AND THE &
		!  NEW SLEEP TIME IS NEGATIVE (IE, IT WENT THROUGH &
		!  A TRANSITION THROUGH 0); &
		! SET THE NEW SLEEP TIME TO 0 IF THE SLEEP TIME IS &
		!  EXPIRED. &

21530	S1%,S3%=0% &
	\ GOTO 21120 IF R%<0% &
	\ IF F1%=0% OR (F1% AND F2%) THEN &
		R%=R% AND -1025% &
	  ELSE	S0%=-1% UNLESS S0% &
	\	S1%=S0% IF (R% AND 2048%) &
	\	S3%=S0% UNLESS (R% AND 18432%) &
	\	GOTO 21100 &
		! GO MAKE SURE A NEW PROMPT IS PRINTED BEFORE CHECKING &
		!  FOR EXIT; &
		! IF THE EVENT REQUEST FLAG IS NON-ZERO AND NONE OF THE &
		!  EVENTS MATCH, THEN &
		!	ZERO OUT THE TIMERS, TO START WITH; &
		!	SET THE REQUESTED TIME TO INFINITE, IF IT IS NOT &
		!	 SET (IF THE EXPIRATION OF THE TIMER WAS A &
		!	 DESIRED EVENT, THEN THE EVENT FLAG SHOULD HAVE &
		!	 BEEN SET, AND THIS LINE WOULD NOT HAVE BEEN &
		!	 REACHED); &
		!	SET UP THE PROPER TIMER : &
		!		RECEIVE TIMER (S1%) IF THE PROGRAM IS &
		!		 ONLINE TO OPSER OR QUEMAN; &
		!		SLEEP TIMER (S3%) IF THE PROGRAM IS &
		!		 NEITHER ONLINE OR ATTACHED; &
		!	GO BACK AND LOOK FOR ANOTHER MESSAGE. &

21540	ON ERROR GOTO 19000 &
	\ R% = R% AND NOT 1536% &
	&
	\ RETURN &
	&
		! RESET ERROR TRAP. &
	&
		! AND EXIT. &
	&
	&

21600	Z%=0% &
	\ IF C$<>NULSTG$ OR (F1%<0% AND (F1% AND F2%)>=0%) THEN &
		RESTORE \ Z$=NULSTG$ \ READ Z$ UNTIL Z$="*STARTCOM" &
	\	P%=0% &
	\	WHILE P%=0% AND T$<>"*ENDCOM" &
	\		READ T$,N7% &
	\		Z%=FNR%(T$,N7%) &
	\		P%=0% UNLESS Z% &
	\		READ Z% &
	\	NEXT &
	\	IF P%=0% THEN &
			IF F1%<0% AND (F1% AND F2%)>=0% THEN &
				Z%=26% &
			ELSE	T$="Unrecognized command" &
	\			E%=-1% &
	\			RETURN &
		! IF THE STRING IS NON-NULL OR THE CALLER IS WAITING &
		!  FOR A RESPONSE, THEN &
		!	GET TO THE BEGINNING OF THE COMMAND TABLE; &
		!	WHILE A MATCH IS NOT FOUND AND THE TABLE IS NOT &
		!	 EMPTY : &
		!		READ THE NEXT ENTRY; &
		!		SEE IF THIS ONE MATCHES; &
		!		READ THE ROUTINE NUMBER; &
		!	LOOP ON NO MATCH; &
		!	IF NO MATCH WAS FOUND, THEN &
		!		IF A RESPONSE IS EXPECTED, THEN &
		!			ASSUME THAT THIS IS IT, AND SET &
		!			 UP TO RETURN IT; &
		!		ELSE	SET UP AN ERROR MESSAGE AND SET &
		!			 ERROR FLAG; &
		!			EXIT THE ROUTINE WITH THE &
		!			 MESSAGE POINTER STILL POINTING &
		!			 TO THIS ONE, SO IT WILL BE &
		!			 REMOVED. &

21620	Z0%(M%,12%)=Z% \ Z0%(M%,11%) = P% \ M%=0% &
	&
	\ RETURN &
	&
		! PUT THE NEW DISPATCH TOKEN INTO THE MESSAGE RECORD; &
		! RESET THE MESSAGE POINTER SO THAT THE MESSAGE IS &
		!  LEFT IN THE MESSAGE COMPLETED LIST, IF NO ERROR &
		!  OCCURRED. &
	&
		! AND EXIT. &
	&
	&

21650	DATA	"*STARTCOM", &
		ONLINE,		3,	7, &
		OFFLINE,	3,	8, &
		PAUSE,		3,	9, &
		CONTINUE,	3,	10, &
		LAST,		3,	13, &
		STATUS,		3,	14, &
		STEP,		3,	16, &
		NOSTEP,		5,	17, &
		END,		3,	18, &
		ABORT,		3,	19, &
		FORM,		3,	20, &
		RESTART,	3,	21, &
		REQUE,		3,	22 &
	&

21660	DATA "*ENDCOM",0,0,
21661		! DEFINE THE COMMANDS AND THEIR ROUTINES : &
		!	THE FORMAT IS : &
		!	  <COMMAND NAME>,<MATCH LENGTH>,<ROUTINE NUMBER> &

21740	GO TO 24960	IF (R% AND 1%) = 0% &
	\	R0%, Z0%(J9%,31%) = R0% OR 1% &
	\	F2%=F2% OR 16% &
	\	JOBMOD%=-1% &
	\	JCOPYP%=JCOPYR% &
	\	GOTO 24970 &
		! 'ABORT' - &
		! IF NO JOB IS IN PROCESS, THEN &
		!	GO ISSUE ERROR MESSAGE TO THAT EFFECT; &
		! ELSE	SET THE 'ABORT REQUESTED' FLAG ON THE JOB'S &
		!	 PROCESSES REQUESTED WORD; &
		!	SET 'SOME JOB MODIFICATION REQUESTED' STATUS; &
		!	SET NUMBER OF COPIES PRINTED TO COPIES REQUESTED; &
		!	EXIT. &

21750	GOSUB 21740 IF (R% AND 1%) &
	\ GOTO 23600 &
		! 'OFFLINE' - &
		! CALL THE 'END' ROUTINE TO SET UP AN 'END'; &
		! CALL THE 'ABORT' ROUTINE IF A JOB IS ACTIVE; &
		! EXIT. &

21760	GO TO 24960	IF (R% AND 1%) = 0% &
	\	GO TO 24970	IF Z0%(J9%,17%) <> 2% &
	\		F2% = F2% OR 16% &
	\		R0%,Z0%(J9%,31%)=R0% OR 4% &
	\		JOBMOD%=-1% &
	\		GOTO 24970 &
		! 'REQUE' - &
		! IF NO JOB IS IN PROCESS, THEN &
		!	GO ISSUE MESSAGE TO THAT EFFECT; &
		! ELSE	IF THE JOB IS NOT A QUEMAN JOB, THEN &
		!		GO ISSUE A MESSAGE TO THAT EFFECT &
		!		(CAN ONLY REQUE A JOB IF IT CAME FROM &
		!		 THE QUEUE ORIGINALLY); &
		!	ELSE	SET THE 'JOB MODIFICATION REQUESTED' &
		!		 FLAG; &
		!		SET THE 'REQUE REQUESTED ON JOB' FLAG ON &
		!		 THE JOB IN PROCESS; &
		!		EXIT. &

21770	F2%=F2% OR NOT32767% &
	\ GO SUB 23150 &
	\ R$=C$ &
	\ GOTO 24970 &
		! 'RESPONSE TO REQUEST' - &
		! SET 'RESPONSE RECEIVED' STATUS; &
		! TELL 'OPSER' WE GOT IT &
		! HOLD THE RESPONSE; &
		! EXIT. &

22000	T$="Last message was :"+C9$+R1$ &
	\ R2$=R1$ &
	\ R%=R% AND -1025% &
	\ GOSUB 23500 &
	\ R1$=R2$ &
	\ GOTO 24970 &
		! 'LAST' - &
		! SET UP TEXT STRING FOR ISSUANCE; &
		! GO ISSUE IT; &
		! TAKE OUT THE HEADING IF THE MESSAGE WAS SAVED; &
		! EXIT. &

22100	T$=S$+" Status"+C9$ &
	\ T$ = T$ + "Form = " + RAD$(Z0%(Q9%,23%)) + RAD$(Z0%(Q9%,24%))+C9$ &
		IF (R% AND 1%) &
	\ T$ = T$ + "Controlled Device = " &
		  +CVT$$(FNU$(Q9%,NULSTG$,1%,0%),2%) &
		  + ":/Unit:" + FNU0$(Z0%(Q9%,11%)) &
		  + " (" +FNU$(Q9%,NULSTG$,4096%,0%) + ")" +C9$ &

22120	IF (R% AND 1%) THEN &
		T$=T$+C9$+FNM0$(NULSTG$,J9%,P0%,0%,PGEFLG%)+C9$ &
	ELSE	T$=T$+C9$+"Waiting for Job" UNLESS (R% AND 256%) &
	\	T$=T$+C9$+"Waiting for Forms Alignment response" IF &
		 (R% AND 256%) &
		! SET UP THE PART OF THE MESSAGE TELLING WHAT KIND OF &
		!  JOB OPERATION IS GOING ON. &

22130	IF RESFLE% THEN &
		T$=T$+C9$+"Attempting RESTART at " &
	\	IF PGECNT%=32767% THEN &
			T$=T$+"Block: "+NUM1$(RESBLK%)+ &
				"	Byte: "+NUM1$(RESBYT%)+C9$ &
		ELSE	T$=T$+"Page: "+NUM1$(RESPGE%)+C9$ &
		! SET UP ANY FILE RESTART INFORMATION. &

22140	IF JOBMOD% THEN &
		T$=T$+C9$+"Preparing to 'REQUE' Job"+C9$ IF &
			(Z0%(J9%,31%) AND 4%) &
	\	T$=T$+C9$+"Preparing to 'ABORT' Job"+C9$ IF &
			(Z0%(J9%,31%) AND 1%) &
		! IF SOME JOB MODIFICATION IS OUTSTANDING, THEN &
		!	SET UP THE TEXT DESCRIBING IT. &

22190	GOSUB 23500 &
	\ GOTO 24970 &

22400	GOTO 24960 UNLESS (R% AND 1%) &
	\ T$="ERROR IN PARSE" &
	\ IF FNR%("JOB",3%) THEN &
		E%=(P%<>LEN(C$)) &
	\	GOTO 24970 IF E% &
	\	F2%=F2% OR 16% &
	\	JOBMOD%=-1% &
	\	R0%,Z0%(J9%,31%)=R0% OR 2% &
	\	GOTO 24970 &
		! CHECK TO MAKE SURE THERE IS A JOB ACTIVE; &
		! IF THE RESTART IS ON 'JOB', THEN &
		!	SET THE 'JOB MODIFICATION REQUESTED' STATUS; &
		!	SET THE 'JOB MODIFICATION' FLAG; &
		!	SET THE 'RESTART' FLAG IN THE JOB RECORD. &

22415	RESBYT%,RESBLK%,RESPGE%,RESPGS%=0% &
	\ RESPGS%=(FNR%(":",1%)=0%) &
	\ RESPGE%=FNN% IF P%<>LEN(C$) UNLESS RESPGS% &
	\ E%=(P%<>LEN(C$)) &
	\ GOTO 24970 IF E% &
	\ T$="No file active" &
	\ E%=(P0%=0%) &
	\ GOTO 24970 IF E% &
	\ F2%=F2% OR 128% &
	\ Z0%(P0%,58%)=RESPGE% &
	\ FLEMOD%=-1% &
	\ Z0%(P0%,31%)=Z0%(P0%,31%) OR 16384% &
	\ Z0%(P0%,59%),Z0%(P0%,60%)=32767% &
	\ GOTO 24970 &
		! SET UP THE FLAGS : &
		! SET RESPGS% IF NO ':N', TO RESTART FILE WITH BURST &
		!  PAGES; &
		! SET UP RESTART PAGE, IF ANY; &
		! SET THE 'FILE MODIFICATION REQUESTED' STATUS; &
		! SET THE RESTART PAGE IN THE FILE RECORD; &
		! SET THE 'FILE MODIFICATION' FLAG; &
		! SET THE 'RESTART' FLAG IN THE FILE RECORD; &
		! SET THE RESTART BLOCK AND BYTE TO INFINITE. &

22420	T$="Already in 'PAUSE'" &
	\ E%=(F1% AND 16384%) &
	\ GO TO 24970	IF E% &
	\	F1% = FNPUSH%(F1%) &
	\	F1%=16402%+(NOT32767% AND F1%) &
	\	Z0%(M%,12%)=0% &
	\	GOSUB 21000 &
	\	F1% = FNPOP% &
	\	F2%=F2% AND -16385% &
	\	GOTO 24970 &
		! 'PAUSE' - &
		! SET UP AN ERROR IF ALREADY IN PAUSE STATE; &
		! ELSE	PUSH THE CURRENT VALUE OF THE 'EVENTS REQUESTED' &
		!	 FLAG; &
		!	SET UP THE FOLLOWING EVENTS TO RETURN FROM THE &
		!	 PAUSE : &
		!		END &
		!		FORM CHANGE &
		!		JOB INTERRUPT &
		!		OFFLINE &
		!		CONTINUE &
		!	CALL THE POLLING ROUTINE TO WAIT FOR ONE OF &
		!	 THEM; &
		!	POP THE OLD EVENT FLAG; &
		!	RESET 'CONTINUE RECEIVED' STATUS; &
		! EXIT. &

22430	T$="Not in 'PAUSE'" &
	\ E%=(F1% AND 16384%)=0% &
	\ F2%=F2% OR 16384% UNLESS E% &
	\ GOTO 24970 &
		! 'CONTINUE' - &
		! SET UP ERROR IF NOT IN PAUSE STATE; &
		! ELSE	SET 'CONTINUE RECEIVED' STATUS FLAG; &
		! EXIT. &
	&

23050	J0%=SWAP%(CVT$%(MID(SYS(UU1$),29%,2%))) &
	\ RETURN	IF J0% = 0% &
	\	J0% = J0% + 14% &
	\	R%=R% OR 2048% &
	\	RETURN &
		! TAKE THE ADDRESS OF THE MESSAGE RECEIVER ENTRY OUT OF &
		!  JDB2; &
		! IF THE ADDRESS IS 0, THEN &
		!	WE FAILED TO ENTER OURSELVES, SO GO EXIT; &
		! ELSE	SET J0% TO POINT TO THE PLACE IN THE MESSAGE &
		!	 RECEIVER ENTRY WHEREIN IS STORED THE COUNT OF &
		!	 MESSAGES QUEUED FOR THIS JOB (THE COUNT IS IN &
		!	 THE HIGH BYTE OF THIS WORD); &
		!	SET THE 'ENTERED AS RECEIVER' FLAG; &
		!	EXIT. &
	&
	&
	&

23100	T0$=CHR6.18$+CHRM1$+CHR0$+ &
		MID(SYS(CHR6.M10$+"OPSER"),7%,4%) &
	\	RETURN &
		! SET UP THE STRING TO BE USED IN THE SEND TO &
		!  OPSER, REGARDLESS OF WHETHER OR NOT THE JOB HAS &
		!  ALREADY DONE AN ONLINE TO OPSER OR NOT &
	&

23120	WHILE (R% AND 4096%) &
	\	R%=FNPUSH%(R%) &
	\	R%=R% AND -16385% &
	\	T$=CHR192$+"OFFLINE" &
	\	GOSUB 23500 &
	\	R%=FNPOP% AND -4097% &
	\ NEXT &
	\ RETURN &
		! IF THE 'ONLINE TO OPSER' FLAG IS NON-ZERO, THEN &
		!	PUSH THE STATUS; &
		!	FORCE AN 'OFFLINE' TO OPSER; &
		!	POP THE STATUS AND RESET THE 'ONLINE' FLAG. &
	&
	&
	&
	&

23150	R% = FNPUSH%(R%) &
	\	R%=R% AND -16385% &
	\	T$=CHR$(192%)+"DELETE #"+J$ &
	\	GOSUB 23500 &
	\	R% = FNPOP% &
	\ RETURN &
		! IF THE 'ONLINE TO OPSER' FLAG IS NOT SET, THEN &
		!	GOTO EXIT; &
		! ELSE	PUSH THE CURRENT STATUS; &
		!	FORCE A SEND TO OPSER OF 'DELETE #<JOB NUMBER>'; &
		!	RESTORE THE STATUS. &

23500	R%=R% AND -513% &
	\ R8%=0% &
	\ P% = FNPUSH%(P%) &
	\ P%=0% &
	\ IF (R% AND 1024%)=0% THEN &
		R1$=T$ &
	\	IF F1%<0% AND (F1% AND F2%)>=0% THEN &
			R%=R% OR 1536% &
	\		T$=C8$+T$ &
		! RESET THE <CR><LF> INHIBIT FLAG; &
		! SET THE RETRY COUNTER FOR THE 'SEND' ROUTINE TO 0; &
		! PUSH THE CURRENT VALUE OF P%, SINCE THE ROUTINE WILL &
		!  USE P% AS A POSITION POINTER; &
		! SET THE VALUE OF P%; &
		! IF A MESSAGE IS NOT CURRENTLY STORED, THEN &
		!	STORE THIS ONE; &
		!	IF THIS MESSAGE IS A REQUEST (IE, THE 'USER &
		!	 RESPONSE' FLAG IN THE EVENT WORD IS SET AND &
		!	 IT IS NOT SET IN THE STATUS WORD), THEN &
		!		SET THE 'MESSAGE STORED' AND &
		!		 <CR><LF> INHIBIT FLAGS; &
		!		PUT A <BELL> ON THE FRONT OF THIS &
		!		 MESSAGE TO SIGNIFY AN ACTION REQUEST. &

23520	RESUME 23550	IF (R% AND 16384%) &
	\	ON ERROR GO TO 23530 &
	\	WHILE P%<LEN(T$) &
	\		Z%=LEN(T$)-P%+1% &
	\		Z%=255% IF Z%>20% &
	\		Z$=SYS(T0$+CHR$(Z%)+RIGHT(T$,P%+1%)) &
	\		R8%=0% &
	\		P%=P%+19% &
	\	NEXT &
	\	R%=R% OR 4096% &
	\	GOTO 23560 &
		! IF THE JOB IS FLAGGED AS ATTACHED, THEN &
		!	GO TO THE 'PRINT' ROUTINE; &
		! ELSE	SET ERROR TRAP; &
		!	SEND THE MESSAGE TO OPSER, 19 BYTES AT A TIME, &
		!	 USING THE STRING, T0$, SET UP BY THE 'ONLINE' &
		!	 ROUTINE; &
		!	SET THE 'ONLINE' FLAG. &

23530	IF ERR=32% THEN &
		R8%=R8%+1% &
	\	IF R8%<60% THEN &
			SLEEP 5% &
	\		RESUME 23520 &
		! IF THE ERROR MEANT 'NO ROOM FOR MESSAGE', THEN &
		!	INCREMENT THE RETRY COUNTER; &
		!	IF THE COUNTER IS STILL LESS THAN 5, THEN &
		!		SLEEP AWHILE; &
		!		TRY AGAIN TO SEND THE MESSAGE. &

23540	RESUME 19000 &
		! HANDLE AS FATAL ERROR &

23550	IF (R% AND 16384%) THEN &
		ON ERROR GOTO 0 &
	\	PRINT #0% IF CCPOS(0%) &
	\	PRINT #0%,T$; &
	\	PRINT #0% UNLESS (R% AND 512%) &
		! IF ATTACHED, THEN &
		!	RESET ERROR TRAP; &
		!	MAKE SURE THAT THE CARRIAGE IS AT THE LEFT &
		!	 MARGIN; &
		!	PRINT THE STRING WITHOUT <CR><LF>; &
		!	PRINT A <CR><LF> IF THE <CR><LF> INHIBIT FLAG IS &
		!	 NOT SET. &

23560	T$=NULSTG$ &
	\ P% = FNPOP% &
	\ R%=R% OR NOT32767% &
	&
	\ ON ERROR GOTO 19000 &
	&
	\ RETURN &
	&
		! NULL OUT THE TEXT STRING TO GET RID OF THE ROOM IT'S &
		!  TAKING; &
		! RESTORE THE ORIGINAL VALUE OF P%; &
		! SET THE 'PROMPT REQUIRED' FLAG. &
	&
		! RESET THE ERROR TRAP; &
	&
		! AND EXIT. &
	&

23600	M9%=2% \ M8%=4% \ GOSUB 21300 \ M%=0% \ RETURN &
		! SET UP THE CALL TO THE 'SHIFT A MESSAGE' ROUTINE : &
		!	TAKE FROM THE 'COMPLETED' LIST; &
		!	ENTER TO THE 'UNPROCESSED' LIST; &
		!	DO THE CALL, AND LET IT RETURN; &
		!	RESET THE 'CURRENT MESSAGE' POINTER; &
		! AND EXIT. &
	&

24300	IF J9% AND Z0%(J9%,17%)=2% THEN &
		GOSUB 21740 &
	\	Z0%(J9%,31%)=Z0%(J9%,31%) OR 16% &
	\	GOTO 24970 &
		! IF A JOB IS ACTIVE AND IT CAME FROM THE QUEUE, THEN &
		!	CALL THE ABORT ROUTINE; &
		!	SET THE 'BY QUEMAN' FLAG FOR THE ABORT MESSAGE; &
		!	GO EXIT. &

24320	GOTO 23600 &
		! IF THE CURRENT JOB IS NOT FROM THE QUEUE, THEN &
		!	GO STORE THE MESSAGE AS AN UNPROCESSED MESSAGE. &
	&

24960	T$="No Job active" &
	\ E%=-1% &
	\ GOTO 24970 &
		! COME HERE IF A JOB MODIFICATION COMMAND COMES IN WHEN &
		!  NO JOB IS ACTIVE. &

24970	ON ERROR GO TO 19000 &
	\ RETURN &
	! RESET ERROR TRAP AND EXIT &

25200	DEF* FNR%(S$,L%) &
	\ FNR%=0% &
	! FUNCTION:	KEYWORD MATCHING ROUTINE. MATCHES A STRING IN &
	!		THE COMMAND STRING C$ STARTING AT POSITION P%+1% &
	!		TO THE DUMMY STRING S$. A MATCH IS MADE WHEN THE &
	!		MINIMUM NUMBER OF CHARACTERS ARE MATCHED. THIS &
	!		MINIMUM NUMBER IS HELD IN THE DUMMY VARIABLE &
	!		L%. &
	! PARAMETERS:	S$	STRING TO MATCH TO. &
	!		L%	MINIMUM LENGTH OF MATCH. &
	! GLOBAL &
	! VARIABLES &
	! AFFECTED:	P%	POSITION POINTER POINTS TO THE LAST CHAR- &
	!			ACTER MATCHED SUCCESSFULLY. &
	! LOCAL &
	! VARIABLES &
	! USED:		Z%	TEMPORARY CHARACTER POINTER. &
	!		Z$	CHARACTER MATCHING VARIABLE FOR PROCESS- &
	!			ING BEYOND THE MINIMUM LENGTH. &
	! RETURNS:	THE NUMBER OF CHARACTERS SUCCESSFULLY MATCHED. &
	! ERRORS:	NONE EXPECTED. &

25210	Z%=ASCII(RIGHT(C$,P%+1%)) &
	\ IF Z%=32% OR Z%=9% THEN P%=P%+1% &
				\ GOTO 25210 &
		! SKIP PAST BLANKS AND TABS. &

25220	IF MID(S$,1%,L%)=MID(C$,P%+1%,L%) THEN Z%=L% &
	ELSE GOTO 25250 &
		! SEARCH FOR MINIMUM MATCH. &

25230	Z$=MID(C$,P%+Z%+1%,1%) &
	\ IF Z$<>MID(S$,Z%+1%,1%) THEN GOTO 25240 &
	  ELSE Z%=Z%+1% IF LEN(Z$) &
	  \ GOTO 25230 IF LEN(Z$) &
		! SEARCH FOR MORE MATCHING CHARACTERS. &

25240	P%=P%+Z% &
	\ FNR%=Z% &
		! RETURN WITH P% POINTING TO THE LAST SUCCESSFULLY &
		! MATCHED CHARACTER. FUNCTION WILL RETURN AS THE NUMBER &
		! OF CHARACTERS MATCHED. &

25250	FNEND &
	&
	&
	&

25900	DEF* FNU$(P0%,C$,Z%,Z0%) &
	! FUNCTION :	FNU$	TURN A FILE DESCRIPTOR RECORD INTO &
	!			AN OPENABLE FILENAME STRING. &
	! PARAMETERS :	P0%	RECORD IN WORK-FILE TO CHANGE &
	!		C$	DUMMY STRING TO USE IN CONSTRUCTING &
	!			THE FILENAME STRING. &
	!		Z%	FLAG WORD 2 FORMAT WORD SHOWING WHICH &
	!			FIELDS IN THE RECORD TO CONVERT. &
	!		Z0%	WORD SHOWING WHICH SWITCHES TO CONVERT &
	!			(OF /MODE, /CLU, AND /FILESIZE). &
	! RETURNS :	FUNCTION VALUE &
	!			THE STRING TO USE IN AN OPEN. &
	! USES :	FNU0$(L%) &

25910	Z%=Z% AND Z0%(P0%,14%) &
	\ Z%=Z% AND -3201% IF (Z0%(P0%,13%) AND 1914%) &
		IF Z0%(P0%,14%)>0% &
	\ C$=NULSTG$ &
		! CREATE A WORD (Z%) WHICH HAS BITS SET FOR A FIELD ONLY &
		! IF THAT FIELD IS BOTH REQUESTED AND PRESENT IN THE &
		! DATA; &
		! IF DEVICE IS NOT DISK, DT, MT, OR LOGICAL, DO NOT &
		! RETURN FILENAME, EXTENSION; &
		! INITIALIZE THE STRING TO NULL. &
	&

25920	C$=RAD$(Z0%(P0%,6%))+RAD$(Z0%(P0%,7%))+":" IF (Z% AND 4096%) &
	\ C$=C$+"["+FNU0$(SWAP%(Z0%(P0%,8%)))+","+FNU0$(Z0%(P0%,8%))+ &
		"]" IF (Z% AND 128%) &
	\ C$=C$+RAD$(Z0%(P0%,9%))+RAD$(Z0%(P0%,10%)) IF (Z% AND 1%) &
	\ C$=C$+"."+RAD$(Z0%(P0%,11%)) IF (Z% AND 8%) &
	\ C$=C$+"<"+FNU0$(SWAP%(Z0%(P0%,12%)))+">" IF (Z% AND 3072%) &
		! SET UP Z% AS BITS SET IN BOTH THE REQUESTED ENTRY &
		! WORD AND THOSE SET IN THE ACTUAL FILENAME STRING. &
		! IF DEV: REQ/EXSTS, MAKE IT; &
		! IF [PPN] REQ/EXSTS, MAKE IT; &
		! IF FILENAME REQ/EXSTS, MAKE IT; &
		! IF .EXT REQ/EXSTS, MAKE IT; &
		! IF <PROT> REQ/EXSTS, MAKE IT. &

25930	Z0%=Z0% AND Z0%(P0%,15%) AND 14336% &
	\ IF Z0% THEN &
		C$=C$+"/CL:"+NUM$(Z0%(P0%,18%)) IF (Z0% AND 2048%) &
	\	C$=C$+"/MO:"+NUM$(Z0%(P0%,16%)) IF (Z0% AND 4096%) &
	\	C$=C$+"/FI:"+NUM$(Z0%(P0%,19%)) IF (Z0% AND 8192%) &
		! SET UP Z0% TO HOLD ONLY THE FLAGS SET BOTH IN THE &
		! OPEERAND IN THE CALL AND IN THE RECORD POINTED TO; &
		! PUT THE "/SWITCH:OPERAND" STRINGS INTO THE RETURNED &
		! STRING IN THE ORDER: &
		!	2048	CLUSTERSIZE &
		!	4096	MODE &
		!	8192	FILESIZE &

25960	FNU$=C$ &
		! SET FUNCTION VALUE. &

25970	FNEND &

25980	DEF* FNU0$(L%) &
	\ L%=L% AND 255% &
	\ IF L%=255% THEN FNU0$="*" ELSE FNU0$=NUM1$(L%) &
		! TAKE THE LOW BYTE OF L%; &
		! IF THAT BYTE IS 255, THEN &
		!	RETURN '*'; &
		! ELSE	RETURN NUM1$ OF BYTE. &

25990	FNEND &
	&
	&
	&

26000	DEF* FNO%(P0%,A0%,C0%,PPN%) &
	\ FNO%=0% &
		! FUNCTION :	OPEN THE FILE WHOSE NAME IS IN RECORD &
		!		P0% OF THE WORK-FILE, ACCESS TYPE A0%, &
		!		ON CHANNEL C0%, USING SPECIFIED &
		!		CLUSTERSIZE, MODE, FILESIZE, AND &
		!		RECORDSIZE VALUES. &
		! &
		! PARAMETERS : &
		!	P0%	RECORD # OF FILE RECORD IN WORK-FILE &
		!	A0%	ACCESS TYPE : &
		!			1 - READ ONLY &
		!			2 - WRITE ONLY (SUPERSEDE) &
		!			3 - READ/WRITE &
		!			4 - \ PROTECTION &
		!			5 - \ VIOLATION &
		!			6 - OPEN, WRITE-ONLY, FOR EXTEND &
		!			7 - OPEN, READ/WRITE, FOR EXTEND &
		!			8 - OPEN FOR READ-REGARDLESS &
		!				(NO DROP OF PRIVILEGES) &
		!	C0%	CHANNEL ON WHICH TO OPEN IT. &

26010	GOTO 26090 IF E% &
	\ Z0%(P0%,16%)=4096% IF A0%=8% &
	\ IF (A0% AND 4%) THEN &
		A0%=A0% AND 3% &
	\	IF (Z0%(P0%,13%) AND 137%) THEN &
			Z0%(P0%,15%)=Z0%(P0%,15%) OR 4096% &
	\		Z0%=Z0%(P0%,13%) &
	\		Z%=Z0%(P0%,16%) &
	\		Z%=2% IF (Z0% AND 1%) &
	\		Z%=Z% OR 8192% IF (Z0% AND 8%) &
	\		Z%=128% IF (Z0% AND 128%) &
	\		Z0%(P0%,16%)=Z% &
	\		A0%=3% &
		! IF THIS IS AN ATTEMPT TO SUPERSEDE A FILE ON ANOTHER &
		! ACCOUNT BY A NON-PRIVILEGED USER, GIVE HIM AN ERROR. &
		! THIS CHECK IS NECESSARY TO PREVENT A NON-PRIVILEGED &
		! USER FROM DESTROYING FILES ON OTHER ACCOUNTS TO WHICH &
		! HE HAS WRITE ACCESS. &

26012	ON ERROR GOTO 26070 &
	\ GOTO 26020	IF PPN% = 0% &
	\ PRIV.MASK$ = MID(SYS(CHR$(6%)+CHR$(-25%)+CHR$(-1%)+CHR$(2%) &
		+CVT%$(SWAP%(PPN%))),9%,8%) &
			! DROP OUT IF WE AREN'T USING 3rd PARTY PRIVS &
			! GET THE OWNER PRIV MASK FROM DISK &

26014	DUMMY$ = SYS(CHR$(6%)+CHR$(31%)+STRING$(2%,0%) &
		+CVT%$(SWAP%(PPN%))+PRIV.MASK$) &
			! INSTALL THIRD PARTY PRIV CHECK &

26020	Z$=SYS(CHR6.M21.M1$) UNLESS A0%=8% &
	\ Z$=FNU$(P0%,NULSTG$,-1%,-1%) &
	\ Z%=(Z0%(P0%,17%) AND (Z0%(P0%,15%) AND 1024%)<>0%) &
	\ OPEN Z$ FOR INPUT AS FILE C0%, RECORDSIZE Z% IF (A0% AND 9%) &
	\ OPEN Z$ FOR OUTPUT AS FILE C0%, RECORDSIZE Z% IF A0%=2% &
	\ OPEN Z$ AS FILE C0%, RECORDSIZE Z% IF A0%=3% &
		! SET UP TO TRAP AN OPEN ERROR; &
		! DROP PRIVILEGES, SET UP FILE NAME WITH SWITCHES, SET &
		! UP RECORDSIZE; &
		! GIVE HIM THE KIND OF OPEN HE ASKED FOR: &
		!	READ ONLY	OPEN FOR INPUT &
		!	WRITE ONLY	OPEN FOR OUTPUT &
		!	READ/WRITE	OPEN &

26030	DUMMY$ = SYS(CHR$(6%)+CHR$(31%))	IF PPN% &
			! DROP THIRD PARTY PRIV CHECK &

26050	Z$=SYS(CHR6.M21.0$) UNLESS A0%=8% &
	\ ON ERROR GOTO 19000 &
		! RECOVER PRIVILEGES; &
		! RESET ERROR TRAP. &

26060	FNEND &
		! AND EXIT. &

26070	IF	ERL = 26012% &
	THEN	PRIV.MASK$ = STRING$(8%,0%) &
		\ RESUME 26014 &
		! TRY READING THIRD PARTY PRIVS, RETURN NULLS IF ERROR &

26080	E%=ERR \ RESUME 26090 &
		! THIS IS FOR ERRORS TRAPPED IN THE OPEN. &

26090	GOTO 26030 &
		! SET THE FLAG BIT SAYING 'ON OPEN', AND EXIT. &
	&
	&

26100	DEF* FNA% &
		! RETURN SUBSCRIPT OF NEXT FREE INDEX ENTRY AND ZERO &
		!  THAT ENTRY. &
		! PARAMETERS:	NONE &
		! RETURNS:	SUBSCRIPT OF THE FIRST ENTRY IN THE FREE &
		!		SPACE LIST. &
		! USES:	Z%	LOOP VARIABLE FOR ZEROING &
		! NOTES:	USES FREE LIST POINTER OUT OF THE INDEX FILE &
		!		HEADER TO GET SUBSCRIPT.  IF FL POINTER IS &
		!		NEGATIVE, THAT PART OF THE FILE HAS NOT YET &
		!		BEEN INITIALIZED, AND THE ROUTINE WILL GO TO &
		!		DO IT. THEN THE ENTRY TO BE RETURNED IS ZEROED. &

26110	B0%=Z0%(0%,0%) UNLESS B0% &
	\ Z0%=B0% &
	\ IF Z0%<0% THEN &
		Z0%=-Z0% &
	\	Z0%(Z%,1%)=Z%+1% FOR Z%=Z0% TO Z0%+7% &
	\	Z0%(Z%,1%)=-Z%-1% &
		! GET NEXT FREE LIST ENTRY; &
		! IF SUBSCRIPT IS NEGATIVE, THIS ENTRY HAS NOT YET BEEN &
		! TOUCHED, SO EXTEND A FEW. &

26120	B0%=Z0%(Z0%,1%) &
	\ Z0$(Z0%)=NULSTG$ &
	\ FNA%=Z0% &
		! ZERO OUT THE RETURNED ENTRY AND SET FUNCTION VALUE. &

26130	FNEND &
		! END OF FNA%. &
	&

26200	DEF* FNA0%(P0%) &

26210	Z0%,Z2%=P0% &
	\ Z0%=Z0%(Z0%,1%) WHILE Z0%(Z0%,1%) &
	\ FOR Z%=2% TO 5% &
	\	Z2%=P0% &
	\	WHILE Z2% &
	\		IF Z0%(Z2%,Z%) THEN &
				Z3%=Z0%(Z2%,Z%) &
	\			Z0%(Z2%,Z%)=0% &
	\			Z0%,Z0%(Z0%,1%)=Z3% &
	\			Z0%=Z0%(Z0%,1%) WHILE Z0%(Z0%,1%) &

26220			Z2%=Z0%(Z2%,1%) &
	\	NEXT &
	\ NEXT Z% &
	\ Z0%(Z0%,1%)=B0% &
	\ B0%=P0% &
	\ FNA0%=0% &

26230	FNEND &
	&

27200	DEF* FNN% &
	\ FNN%,F%=0% &
	! FUNCTION:	RETURN A NUMBER ROUTINE. &
	! PARAMETERS:	NONE &
	! GLOBAL &
	! VARIABLES &
	! AFFECTED:	P%	CHARACTERS POSITION POINTER. &
	!		F%	FOUND FLAG. &
	! LOCAL &
	! VARIABLES &
	! USED:		Z%	TEMPORARY POSITION POINTER. &
	!		Z0%	ASCII CHARACTER REPRESENTATION. &
	! RETURNS:	VALUE OF NUMERIC DIGITS FOLLOWING POSITION P% &
	!		IN THE STRING C$. IF NONE ARE FOUND THE FOUND FLAG &
	!		IS RETURNED AS ZERO. &
	! ERRORS:	NONE EXPECTED. &

27210	ON ERROR GOTO 27250 &
	\ Z%=P%-1% &
	\ Z0%=-1% &
		! SET LOCAL ERROR HANDLER. &
		! SET LOCAL CHARACTER POINTER. &
		! INITIALIZE ASCII DIGIT FLAG. &

27220	WHILE (Z0%>=48% AND Z0%<=57%) OR Z0%=-1% &
		\ Z%=Z%+1% &
		\ Z0%=ASCII(RIGHT(C$,Z%+1%)) &
	\ NEXT &
		! CHECK FOR DIGITS, AND EXIT HERE WITH Z%=P% OR Z% &
		! POINTING TO THE LAST DIGIT FOUND. &

27230	IF Z%<>P% THEN FNN%=VAL(MID(C$,P%+1%,Z%-P%)) &
				\ P%=Z% &
				\ F%=-1% &
		! WE HAVE FOUND A NUMBER. SET THE FUNCTION VALUE TO &
		! THE VALUE OF THE NUMBER FOUND AND SET THE FOUND FLAG. &

27240	ON ERROR GOTO 19000 &
	\ FNN%=0% IF E% &
	\ FNEND &
		! RESET THE ERROR HANDLER. &
		! IF ERR IN VAL FUNCTION, RETURN ZERO RESULT &
		! RETURN. &
	&

27250	E% = 564%	IF ERR/10% = 5% &
	\  RESUME 27240 &
		! HANDLE ERROR IN VAL FUNCTION &
	&

27300	DEF* FNUNPACK$(P0%,P1%) &
	! FUNCTION :	FNUNPACK$	UNPACK A STRING OUT OF THE WORK- &
	!				 FILE AND RETURN THE STRING IN &
	!				 THE FUNCTION VALUE. &
	! OPERANDS :	P0%		THE HEAD RECORD OF THE LIST OF &
	!				 RECORDS CONTAINING THE STRING. &
	!		P1%		THE NUMBER OF BYTES TO SKIP AT &
	!				 THE BEGINNING OF THE FIRST &
	!				 RECORD - THESE BYTES ARE &
	!				 SKIPPED IN ORDER TO LEAVE ROOM &
	!				 FOR CONTROL INFORMATION, SUCH &
	!				 SOURCE OF MESSAGE, PPN FROM &
	!				 WHICH IT CAME, DISPATCH CODE, &
	!				 ETC. &
	! RETURNS :	THE UNPACKED STRING IN THE FUNCTION VALUE. &
	&

27310	Z%=Z0%(P0%,P1%/2%) &
	\ P1%=P1%+3% &
	\ Z9%=P0% &
	\ Z8%=Z0%(P0%,1%) &
	\ Z0%(P0%,1%)=Z0%(P0%,2%) \ Z0$=NULSTG$ &

27320	Z0%=129%-P1% \ Z0%=Z% IF Z0%>Z% &
	\ Z$=RIGHT(Z0$(P0%),P1%) &
	\ Z$=Z$+STRING$(Z0%-LEN(Z$),0%) &
	\ Z%=Z%-LEN(Z$) &
	\ Z0$=Z0$+Z$ &
	\ P1%=Z0%(P0%,1%) &
	\ IF P1% THEN &
		P0%=P1% &
	\	P1%=13% &
	\	GOTO 27320 &

27330	Z0%(Z9%,1%)=Z8% &
	\ FNUNPACK$=Z0$ &

27340	FNEND &
	&

27400	DEF* FNPUSH%(P0%) &
	&
	\ S%=S%+1% \ S%(S%),FNPUSH%=P0% &
	&
	\ FNEND &

27410	DEF* FNPOP% &
	&
	\ FNPOP%=S%(S%) \ S%=S%-1% &
	&
	\ FNEND &

31000	E0%=2% &
	\ C$=SYS(CHR$(7%)) &
	\ W$=RIGHT(C$,3%) &
	\ GOTO 1000 &
		! TAKE THE BASE FHR AND THE WORK-FILE &
		! NAME OUT OF CORE COMMON AND GO TO WORK. &
	&

32767	END &

