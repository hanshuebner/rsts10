TITLE	TBL,<System Tables>,0L,03-AUG-92,MHB/ABC/GPK/MND/RRF/SJM/SRM/JTC/DRP/FEK/WJS/JHC/TWH/PRL/FRL/KPH/MNB/DBM/TPT/VAM/DSD

;
;		COPYRIGHT (c) 1974, 1992 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	Edit History for TBL
;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;  001	TG   27-Jun-80	NAMDIR stuff added
;  002	RTW  09-Aug-80	Add SYSTEM JOB tables
;  003	RTW  09-Aug-80	Add Complex EMT Tables
;  004	RTW  09-Aug-80	Add NSP/TRN queue headers from XMDINT
;  005	RTW  21-Aug-80	Fix L3QUE bit assignment for drivers
;  006	MND  15-SEP-80	Added <SCANPK,DOHSH,UNRD5> to EMTDSP
;  007	TG   01-Jan-81	Removed RSXDSP Psect
;  008	TG   01-Jan-81	Added GENDSP Psect
;  009	TG   01-Jan-81	Added FMSDSP psect and FMSAP5 dummy
;  010	GPK  16-Feb-81	Added XPEEK and DDCU stuff
;  011	MND  06-Apr-81	Removed comments for Named directories
;  012	RRF  15-Apr-81	Added dispatch table for FMS
;  013	SJM  06-Apr-81	Added Default KBM pointer
;  014	MDS  10-APR-81	Changes made for XBUF dumping
;  015	SRM  29-Apr-81	Merge MDS's XBUF dumping changes 
;  016	JTC  18-May-81	Tweaking XBUF dumping
;  017	RVR  15-Jun-81	Added placement for module QUESUB following NSPSUB
;  018	RRF  18-Jun-81	Added JMP FMS$KB in FMSDSP
;  019	SRM  26-Jun-81	Change "crash while crashing word" to zero
;  020	SJM  09-Jul-81	Added support for I&D space
;  021	SJM  29-Jul-81	Moved RELOAD: from here to RTI
;  022	GPK  11-Aug-81	Added setting of XD.1ST to XD: DDBs
;  023  SRM  27-Aug-81	Make mixed case the default for LPs.
;  024	JTC  09-Sep-81	Add xxDISP AND xxDTBL PSECTS for I&D space
;  025	JTC  02-Oct-81	Move $$ITOP to before FMSDSP
;  026	JTC  11-Oct-81	Support new FIP structure
;  027	JTC  14-Oct-81	Clean up the startup code
;  028	JTC  22-Oct-81	Start creating the APR table
;  029	MND  22-Oct-81	Corrected 010 (DDCU)
;  030	JTC  10-Nov-81	Define TRNSUB, EVLSUB, SESSUB PSECTs
;  031	JTC  18-Nov-81	Increase stack allocation
;
;  000  CEK  07-Jan-81  CREATION - COPIED FROM V7.1-11
;  001  CEK  07-Jan-81  Remove code to initialize OVRBUF pointer (now in INIT)
;  002  CEK  15-Jan-81  Add symbols so ONLPAT can find patch audit table
;  003  AJK  21-MAR-82  Added L3Q bit for MSCP processor.
;			Added MSCP data structures (CMT & UMT's)
;  004	DRP  09-AUG-82	Added SYDISP to I-Space
;  005	FEK  17-Aug-82	Add disk level, MFD, and QTB pointer tables
;  006  WJS  19-Oct-82	JDB2 structures for EMT Logger; pre-resolve globals
;  007  AJK  20-Oct-82	Added label for end of disk queue:  DQSEND
;  008  WJS  27-Oct-82	BL4 changes for EMT Logger
;  009	WJS  17-Dec-82	BL4+ changes for EMT Logger
;  010  AJK  21-FEB-83  Defined UMT$XX when no MSCP devices in system
;  011  JHC  23-Feb-83  Corrected rounding error in buffer pool calculations
;			Added GLOBAL $$USEM for SILUS to use with MORBUF
;
;				[RSTS V9.0]
;  012	GPK  25-Mar-83	Multiple privileges
;  013	WJS  21-Apr-83	Added EMLKIL entry to EMTDSP
;  014	JHC  11-Jul-83	Added conditional BBRDSP region
;  015  DRP  04-Oct-83	Made UNTOPT and UNTERR into word tables
;			Combined UNTCLU and UNTOWN
;  016	GPK  12-Oct-83	Added TBL, CTL psects for PFBIO
;  017	TWH  22-NOV-83	CHANGE PSECT FOR UNTSIZ 
;  018	PRL  22-Nov-83	Updated DDB layout and DDFLAG bits for LP
;  019  FRL  23-Nov-83  Assured that primary run-time system is ready to be
;			  swapped in (necessitated by L3Q changes).
;  020	GPK  22-Nov-83	Add $CHKAC dispatch to FIPDSP
;  021	DRP  05-Dec-83	Changes for Open phase
;  022	KPH  12-Jan-84	Add EM2 phase, move MID table to RAWMEM
;  023	MNB  05-Jan-84	Changes to M.CTRL byte (LCK, SWP bits affected)
;  024	GPK  19-Jan-84	Add $FIEXIX dispatch to FIPDSP
;  025	DRP  02-Feb-84	Added Disk Quota Pointer Table
;  026	PRL  07-Mar-84	Changed LPTCHR to a word, removed LPTPUC byte
;			  in LP DDB layout
;  027	TWH  13-Mar-84	Added BSTALL and MTU
;  028  FEK  13-Mar-84	Added PSECTS for RJ
;			Added code to check and see if RJ phase is mapped
;  029  FRL  01-Apr-84  Moved system logicals to XBUF
;  030  FRL  01-Apr-84  Added SEARCH and SRCHLG entries to EMTDSP
;  031	KPH  21-Mar-84	Added Psects for statistics
;			Changes for swap max > 32K words
;			Changes for task loader
;			Replace SCANPK with LOGR50 in EMTDSP
;  032	KPH  27-Mar-84	Added MTA, MTU, and DTU conditional includes
;  033	DRP  10-Apr-84	Added FIP to OPN dispatch
;  034	JHC  26-Mar-84	Modified DDB tables to make MS 'natively asynch'
;  035	DBM  08-May-84	Add RSTS to OPN dispatch (ASYECK)
;  036	GPK  20-Apr-84	Add dispatches for PFBIO in EM2; for MTA in OPN
;  037	TPT  15-May-84	Dispatches for TTDVR
;  038	KPH  03-Jul-84	Add DOFF to EMTDSP
;			Move EMU to RSX phase
;  039	KPH  16-Jul-84	Move DSTCTL to XBUF
;			Make DSTATs I-only
;  040	GPK  19-Jul-84	Add DECnet tracer
;  041	KPH  09-Aug-84	Define all known PSECTs
;  042	KPH  11-Sep-84	Move MTA to MVR phase, add MVRAP5 cell
;			Remove USRSET from EMTDSP
;			Remove resident overlay stuff
;  043	GPK  31-Oct-84	Add FIPRIV back in for RJ2780
;  044	KPH  31-Oct-84	Add USETBL
;  045	TPT  06-Nov-84	Remove TIC$KB entry (moved to KBDINT)
;  046	DRP  23-Jan-85	Add dispatch to TERDSP for TTDVR
;  047	DRP  21-Mar-85	Add dispatch to TERDSP for TTDVR
;  048	KPH  09-Apr-85	Bugfix in DSTATS setup
;
;				[RSTS V9.1]
;  049	KPH  12-Mar-85	Add SATMMU table
;			Remove primary RTS
;			Support new terminal service mapping
;			Require data caching
;			Move UUOSNC and EMLFQT tables to read/write area
;  050	DBM  17-May-85	TMSCP work
;			Change reference of SYSVEN to $$$VER
;	     02-Jun-85	Add DU$ERL to BBRDSP
;  051	DBM  13-Sep-85	Ensure DUMMY psect is in I-space area
;
;				[RSTS V9.2]
;  052  KPH  12-Jul-85	Add job control region
;  053	DBM  17-Oct-85	Fix BBRDSP problem for TMSCP only assemblies
;
;				[RSTS V9.3]
;  054	JHC  04-Nov-85	Update xxxTBL entries to merge UNA/QNA stuff
;			Create SJBQUE for SYSJOB posting
;  055	KPH  07-Dec-85	Changes for DECnet V4.0 (merged by JHC)
;  056	FEK  20-Jan-85	Setup for I/D RJ2780 capability
;  057  KPH  22-Feb-86	Move SYDVR out of RSTS phase
;  058  KPH  11-Apr-86	Move SJBQUE to a psect of its own
;  059  KPH  08-Jul-86	Remove BSTALL stuff
;			Add some entries to GENDSP
;			Add JOBF3 support
;			Add CHETBL
;  060	DBM  28-Aug-86	4 MU controllers
;  061  VAM  27-JUL-86	Changes to BBRDSP and xxDAP5 table for new [T]MSCP
;			phase layout.                             
;			Also, include DSASUB if [T]MSCP is present.
;  062	JHC/DBM 24-Sep-86 Fix up DSASUB to force into PMM
;
;			[RSTS/E V9.4]
;  063  KPH  11-Jan-87	Add changes for new user mapping structure
;			Add GRD phase
;  064  WRM   8-Apr-87  Add fastmap dispatch to GRD phase                  ;064
;
;			[RSTS/E V9.6]
;  065  KPH  13-Oct-87	Add support for dynamic KB devices
;			Add support for dynamic PK devices
;			Changes for new terminal driver mapping structure
;			Lookup KB0: DDB pointer using DEV.KB
;			Removed KB: error logging - added in KERNEL
;			Removed conditionals for control/T support
;  066  KPH  20-Oct-87	Add support for LAT
;  067	DSD  08-Feb-88	Add support for NO driver
;  068	DSD  17-Feb-88	Fix support for NO driver
;  069  KPH  19-Feb-88	Make statistics required
;
;			[RSTS/E V9.7]
;  070	KCG  22-Nov-88	Add DND dispatch table (DND is DECnet dispatcher).
;			This is a necessary change for the OV2 splitup.
;  071	DRP  26-Jan-89	Add XTRAP5 to APR table
;  072	JFM  06-Feb-89	Change DND dispatch table definition from .BLKW0 to
;			.BLKW to get rid of the LINK order dependencies.
;  073	FEK  03-Mar-89	Add some root patch space for RJ2780 in I & D space.
;
;			[RSTS/E V10.0]
;  074	FEK  25-Aug-89	Allow alpha BL #s
;  075  WRM  06-Nov-89	New entries for MERGE for RSX and GEN
;  076  VAM  17-Jun-90	Fix Patch Audit globals for new V10.0 component numbers
;
;			[RSTS/E V10.1]
;  077	FEK  10-Dec-90	Replace CON$PH definition with L3QENT in CPH
;-

; LIST THE PREFIX FILES

L$$IST	=	1

.SBTTL	Call all required modules from the library

	INCLUDE	<MED,UPE,FPP,RTI,RES,ERL,SUB,CMNDVR,BUFEXT,NSPSUB> 	;059
	INCLUDE <LTROOT,DSTAT>						;069

.IF	NE	<CNT.DU!TMSCP>	;If MSCP and/or TMSCP is present	;061
	INCLUDE	<DSASUB>	; bring in DSASUB as well.		;061
.ENDC									;061

.SBTTL	Call all needed disk drivers from the library (sort of...)

$DISKS
.IF	NE	CNT.'NAME
.GLOBL	CNT.'NAME
.IFF
.DSABL	CRF
NAME'DSK	==	0
$'NAME'DINT	==	0
.ENABL	CRF
.GLOBL	CNT.DU
.ENDC
.ENDM

.SBTTL	Call all needed drivers from the library

$NAMES
	INCLUDE	NAME'DVR
.IF	DIF	<NAME>,<SY>
.IF	DIF	<NAME>,<NL>
.IF	DIF	<NAME>,<PK>						;065
.GLOBL	CNT.'NAME
.ENDC									;065
.ENDC
.ENDC
.ENDM
.GLOBL	CNT.MU				;Always globalize CNT.MU	;050

.SBTTL	Globalize 2780 configuration information

$$2780	==	RJ2780	;**INIT** 2780 INTERFACE TYPE

.SBTTL	Define driver indexes for devices

.DSECT

$NAMES
.LIST
IDX.'NAME::.BLKW		; Driver index for NAME
.NLIST
.ENDM
IDX$MX::		; Size of driver tables in bytes

.SBTTL	Define JSbits for devices

JSALL	=	0	; This will be the ctrl/C JSBIT pattern

.BSECT

$NAMES
.IIF	NDF	CCC.'NAME,	CCC.'NAME=-1
.IF	NE	CCC.'NAME
.ASSUME	.	NE	JSTEL
.LIST
JS.'NAME::	.BLKB	.	; JSBIT for NAME driver
.NLIST
.IF	EQ	CCC.'NAME-1
JSALL	=	JSALL!JS.'NAME
.ENDC
.IFF
.LIST
JS.'NAME	==	JS.SY	; JSBIT for NAME driver
.NLIST
.ENDC
.ENDM

JSALL	==	JSALL!JSTEL!JSTIM!JSBUF

.SBTTL	Declare and order the .CSECTS

; ***** LOWCOR starts at physical 0 *****

	DEFORG	LOWCOR		; Low memory

.IF	NE,RJ2780
	ORG	RJDCTL		; The "RJ2780 root code"		;056
				;  This is needed here because this psect
				;  contains both R/W I and D.
.ENDC

	ORG	MEDCTL		; The "MED" code
$$MEDS	==	.	;**INIT** Start of "MED" code

	DEFORG	PATCH		; Patch space
$$MEDE	==	.	;**INIT** End of "MED" code

	.BLKW0	128.		; 128. words of patch allowed

; ***** BUFPOL starts at a 40(8) address boundary *****

	DEFORG	BUFPOL		; Monitor's buffer pool
$$BUFS	==	.	;**INIT** Start of Monitor's buffer pool

	.BLKB0	30.*40		; Minimum of 30 small buffers, please
				;  (also can be used for emergency patch space)
$$IBOT	==	.	;**INIT** End of low core that must be mapped I&D

	DEFORG	YABUF		; Yet another Monitor buffer pool...
$$BUFE	==	.	;**INIT** End of Monitor's buffer pool
$$YBFS	==	.	;**INIT** Start of Yet Another Monitor buffer pool

; ***** IOBUFR starts at a 1000(8) address boundary *****

	DEFORG	IOBUFR		; FIP'S I/O buffers
$$YBFE	==	.	;**INIT** End of Yet Another Monitor buffer pool

FIBUF::	.BLKB	760		; FIP'S directory buffer
FIBMAP::.BLKW			; Start of directory cluster map
FIBENT::.BLKW	7		; Start of directory cluster DCN's

CRASAV::			; Registers saved here on a crash
SATBUF::.BLKB	1000		; FIP'S S.A.T. buffer

; *****	I-space routines can be mapped out and this space used for
; *	small buffers if $$IBOT/$$ISPS crosses an APR boundry and
; *****	$$ISPE/$$ITOP also crosses an APR boundary 

	ORG	SUBISP		; Common subroutines
$$ISPS	==	.	;**INIT** Start of I-space routines

	ORG	RTIISP		; Interrupt control
	ORG	RESISP		; Random things
	ORG	KG11		; SOFT KG11 FOR Q-BUS RJ		;027
	ORG	CHEISP		; Cache block data mover		;069
	ORG	DUMMY		; Do-nothing I-space code area		;051

$NAMES
.LIST
				; Root I-space code for NAME driver (NAME'DISP)
.NLIST
	ORG	NAME'DISP
.ENDM

	ORG	MEDISP		; "MED" code
$$MEDI	==	.	;**INIT** Start of "MED" code

	ORG	SYDISP		; Window checker/file transfer code
$$MEDJ	==	.	;**INIT** End of "MED" code
$$SYDI	==	.	;**INIT** Start of window checker/file transfer code

	ORG	UPEISP		; UNIBUS memory parity code
$$SYDJ	==	.	;**INIT** End of window checker/file transfer code
$$UPEI	==	.	;**INIT** Start of UNIBUS parity code

	ORG	UMRISP		; UNIBUS window mapping register code
$$UPEJ	==	.	;**INIT** End of UNIBUS parity code
$$UMRI	==	.	;**INIT** Start of UMR allocation code

	ORG	FPPISP		; Async FPP code
$$UMRJ	==	.	;**INIT** End of UMR allocation code
$$FPPI	==	.	;**INIT** Start of async FPP code

	ORG	LIBISP		; Resident Library subroutines
$$FPPJ	==	.	;**INIT** End of async FPP code

	ORG	NETISP	;DECnet/E root code				;055
$$NETI	==	.	;**INIT** Start of DECnet/E root code		;055
; End of Instruction Space Code PSECTs  "???ISP"

	ORG	ISPE		; End Instruction space code
$$ISPE	==	.	;**INIT** End of I-space routines

; Start of Data space PSECTs "???CTL"

	ORG	MCPCTL		; MCP impure area
$$NETJ	==	.	;**INIT** End of DECnet/E root code		;055
$$MCPS	==	.	;**INIT** Start of MCP data data

	ORG	UPECTL		; UNIBUS memory parity code
$$MCPE	==	.	;**INIT** End of MCP data area
$$UPES	==	.	;**INIT** Start UNIBUS parity data

	ORG	UMRCTL		; UNIBUS Window mapping register data
$$UPEE	==	.	;**INIT** End of UNIBUS parity data
$$UMRS	==	.	;**INIT** Start of UMR allocation data

	ORG	FPPCTL		; Async FPP data goes here
$$UMRE	==	.	;**INIT** End of UMR allocation data
$$FPPS	==	.	;**INIT** Start of async FPP data

	ORG	LIBCTL		; Resident Library data goes here
$$FPPE	==	.	;**INIT** End of async FPP data
$$LIBS	==	.	;**INIT** Start of Resident Library data

	DEFORG	CMTCTL		; Controller mapping table & UMT areas
$$LIBE	==	.	;**INIT** End of Resident Library subroutines

	ORG	NETCTL		; DECnet/E data goes here		;055
$$NETS	==	.	;**INIT** Start of DECnet/E data		;055
	DEFORG	MORBUF		; Extra Monitor buffer pool comes here
$$NETE	==	.	;**INIT** End of DECnet/E data			;055
$$MBFS	==	.	;**INIT** Start of more Monitor buffer pool

	DEFORG	BGBUFR		; Big I/O buffer
$$MBFE	==	.	;**INIT** End of More Monitor buffer pool

	DEFORG	RAWMEM		; General read/write memory

$NAMES
.IF	DF	DDS.'NAME						;065
.LIST
				; DDBs for NAME driver (NAME'DDDB)
.NLIST
	DEFORG	NAME'DDDB
.ENDC
.ENDM

$DISKS
.IF	NE	CNT.'NAME
.LIST
			; R/W section for NAME driver (NAME'DCTL)
.NLIST
	DEFORG	NAME'DCTL
NAME'DCTL::.WORD	0		; Control busy pointer
NAME'DPT1::.WORD	DQE$'NAME		; Round-robin pointer #1
NAME'DPT2::.WORD	DQE$'NAME		; Round-robin pointer #2
.IF	IDN	<NAME>,<DL>
NAME'DPOS::.WORD	0		; Position bucket(s)
	.BLKW0	CNT.'NAME-1
.ENDC
.ENDC
.ENDM

$NAMES
.LIST
				; R/W section for NAME driver (NAME'DCTL)
.NLIST
	ORG	NAME'DCTL
.ENDM

.IRP	NAME,<RTI,BUF,RES,ERL,CHE,FIP,PFB,MTU,KG,LAT>			;066
.LIST
				; R/W section for NAME (NAME'CTL)
.NLIST
	ORG	NAME'CTL
.ENDM

	ORG	NETPRM		; Permanant DECnet/E data		;055

	ORG	SJBQUE		; System job queue pointer table	;058

	DEFORG	SNDLST		; RIB list root, Local Object Type tables

	ORG	ERLCTB		; Error logging control table

	ORG	CRACTL		; Crash data

	DEFORG	EMLCTL		; EMT logging control structure

.IF	NE	EMTLOG
EMLTBL::.BLKW0	EMLTSZ/2	; Initially, all are zero
.IFF
EMLTBL	 ==:	N$G$$D		; No EMT Logging control structure
.ENDC

	ORG	EMLFQT		; EMT Logger FQFUN table		;049
$EMLFQT	==	.	;**MERGE** Alternate for 'EMLFQT'		;049

	ORG	UUOSNC		; FIP'S UUO "flags" table		;049
$UUOSNC	==	.	;**MERGE** Alternate for 'UUOSNC'		;049
	.BLKB0	UU$MAX-UU$MIN+1	; Initially all are 0			;049

.SBTTL	***** TBL is the start of read-only memory *****


	DEFORG	TBL		; General R-O memory

$$SROM	==	.	;**INIT** Start of read-only memory



	DEFORG	PATCHS		; Patch sequence numbers

$$AUDS	==	.	;>> Start of patch audit table <<		;076
$$0301	==	.	;Monitor patches				;076
	.BLKW0	4		;3.1.1 through 3.1.64			;076
$$0304	==	.	;Terminal service patches			;076
	.BLKW0	4		;3.4.1 through 3.4.64			;076
$$0307	==	.	;File Processor patches				;076
	.BLKW0	4		;3.7.1 through 3.7.64			;076
$$0310	==	.	;Device driver patches				;076
	.BLKW0	4		;3.10.1 through 3.10.64			;076
$$0313	==	.	;FMS monitor patches				;076
	.BLKW0	4		;3.13.1 through 3.13.64			;076
$$0701	==	.	;DECnet patches					;076
	.BLKW0	4		;7.1.1 through 7.1.64			;076
$$AUDE	==	.	;>> End of patch audit table <<			;076

.SBTTL	Monitor dispatch and control tables


	ORG	EMTTBL		; EMT service dispatch table
$EMTTBL	==	.	;**MERGE** Alternate for 'EMTTBL'

	.BLKW0	EMTSIZ/2	; Initially all dispatch to 0

	ORG	L3QTBL		; Level 3 queue dispatch table
$L3QTBL	==	.	;**MERGE** Alternate for 'L3QTBL'
$L3QTMT	==	.+PQMTBUF	;**MERGE** L3Q dispatch for QMTBUF

	.BLKW0	L3QSIZ/2	; Initially all dispatch to 0

	ORG	L3QPAR		; Level 3 queue pointers to KISAR5 value
$L3QPAR	==	.	;**MERGE** Alternate for 'L3QPAR'
$L3QPMT	==	.+PQMTBUF	;**MERGE** L3Q pointer for QMTBUF

	.BLKW0	L3QSIZ/2	; Initially all are 0

	ORG	ERRTBL		; Error logging dispatch table
$ERRTBL	==	.	;**MERGE** Alternate for 'ERRTBL'

	.BLKW0	LOG$SZ/2	; Initially all dispatch to 0

	ORG	SERTBL		; I/O driver service dispatch table
$SERTBL	==	.	;**MERGE** Alternate for 'SERTBL'

	.BLKW0	IDX$MX/2	; Initially all dispatch to 0

	ORG	OPNTBL		; I/O driver OPEN service dispatch table
$OPNTBL	==	.	;**MERGE** Alternate for 'OPNTBL'

	.BLKW0	IDX$MX/2	; Initially all dispatch to 0

	ORG	CLSTBL		; I/O driver CLOSE service dispatch table
$CLSTBL	==	.	;**MERGE** Alternate for 'CLSTBL'

	.BLKW0	IDX$MX/2	; Initially all dispatch to 0

	ORG	SPCTBL		; I/O driver special function dispatch table
$SPCTBL	==	.	;**MERGE** Alternate for 'SPCTBL'

	.BLKW0	IDX$MX/2	; Initially all dispatch to 0

	ORG	ASNTBL		; I/O driver device assignment dispatch table
$ASNTBL	==	.	;**MERGE** Alternate for 'ASNTBL'

	.BLKW0	IDX$MX/2	; Initially all dispatch to 0

	ORG	DEATBL		; I/O driver device deassignment dispatch table
$DEATBL	==	.	;**MERGE** Alternate for 'DEATBL'

	.BLKW0	IDX$MX/2	; Initially all dispatch to 0

	ORG	TMOTBL		; I/O driver timeout dispatch table
$TMOTBL	==	.	;**MERGE** Alternate for 'TMOTBL'

	.BLKW0	IDX$MX/2	; Initially all dispatch to 0

	ORG	SLPTBL		; I/O driver "sleep" checking dispatch table
$SLPTBL	==	.	;**MERGE** Alternate for 'SLPTBL'

	.BLKW0	IDX$MX/2	; Initially all dispatch to 0

	ORG	FLGTBL		; I/O driver flags/handler index table
$FLGTBL	==	.	;**MERGE** Alternate for 'FLGTBL'

	.BLKW0	IDX$MX/2	; Initially all are 0

	ORG	SIZTBL		; I/O driver line width table
$SIZTBL	==	.	;**MERGE** Alternate for 'SIZTBL'

	.BLKW0	IDX$MX/2	; Initially all are 0
                        
	ORG	BUFTBL		; I/O driver buffer size table
$BUFTBL	==	.	;**MERGE** Alternate for 'BUFTBL'

	.BLKW0	IDX$MX/2	; Initially all are 0

	ORG	MSKTBL		; Posting pattern table
$MSKTBL	==	.	;**MERGE** Alternate for 'MSKTBL'

	.BLKW0	NONMSK/2,-1	; Initially all post nothing

	ORG	FIPTBL		; FIP'S function code dispatch table
$FIPTBL	==	.	;**MERGE** Alternate for 'FIPTBL'
                                   
	.BLKW0	FQFSIZ/2,1	; Initially all dispatch to 1

	ORG	DNDTBL		; System job function code dispatch table ;070
$DNDTBL	==	.	;**MERGE** Alternate for 'DNDTBL'		;070
	.BLKW	NTFQMX/2	; Dispatch table (loaded by NETFUN macros) ;072

	ORG	UUOTBL		; FIP'S UUO dispatch table
$UUOTBL	==	.	;**MERGE** Alternate for 'UUOTBL'

	.BLKW0	UU$MAX-UU$MIN+1 ; Initially all dispatch to 0

	ORG	UUOPRV		; FIP'S UUO privilege table
$UUOPRV	==	.	;**MERGE** Alternate for 'UUOPRV'

	.BLKW0	UU$MAX-UU$MIN+1 ; Initially no privilege checks

	ORG	CHETBL		; Cache giveback dispatch table		;059
$CHETBL	==	.	;**Merge** Alternate for 'CHETBL'		;059

	.BLKW0	CHECNT*2	; Initially table is empty		;059

        ORG     GRDDSP          ;select code dispatch in GRD phase      ;064
$GRDDSP ==      .       ;**MERGE** Alternate for 'GRDDSP'               ;064
FMAP$I::.BLKW  			;fastmap entry                          ;069
DOSTAT::.BLKW			;collect monitor statistics		;069

.SBTTL	Status table pointers and driver R/O data


	DEFORG	STSTBL		; Statistics tables pointers

	.WORD	0		; Reserved for historical purposes
	.WORD	0		; Pointer to job statistics
	.WORD	0		; Pointer to queue statistics
	.WORD	0		; Pointer to cache statistics

$NAMES                             
.LIST
				; R-O data for NAME driver (NAME'DTBL)
.NLIST
	ORG	NAME'DTBL
.ENDM

	.IRP	NAME,<PFB>
.LIST
				; R-O data for NAME module (NAME'TBL)
.NLIST
	ORG	NAME'TBL
.ENDM

	ORG	KGTBL		; KG emulation CRC tables		;027
	ORG	NETTBL		; DECnet/E dispatch table		;055
	ORG	APRTBL		; APR value table (not complete!!!!)

RSTAP5::.WORD	1200		; RSTS phase APR 5 value		;057
CRAAP5::.WORD	0		; Crash phase APR 5 value.
OPNAP5::.WORD	0		; Open phase APR 5 value		;021
EM2AP5::.WORD	0		; Secondary EMT phase APR 5 value	;022
RSXAP5::.WORD	0		; RSX emulation phase APR 5 value	;038
MVRAP5::.WORD	0		; Magtape phase APR5 value		;042
SYDAP5::			; Logical disk driver APR 5 value	;057
GRDAP5::.WORD	0		; GRD phase APR 5 value			;063
GENAP5::.WORD	0		; GEN phase APR 5 value			;057
XTRAP5::.WORD	0		; XTR phase APR 5 value			;071

	ORG	APREND		; Should follow APRTBL
APREND::			; End of APR table

.SBTTL	Monitor Phase Dispatch Table Allocations

	ORG	CRADSP		; CRASH dispatches
$CRADSP	==	.	;**MERGE** Alternate for CRADSP for SILUS

GOCRSH::.WORD	0		; Restart but first take a dump
GOINIT::.WORD	0		; Go back to INIT
CRAVER::.WORD	0		; Pointer to a two word map verification area 
				;  in the crash phase used to be sure its mapped

	ORG	DSKDSP		; Monitor to disk dispatches
$DSKDSP	==	.	;**MERGE** Alternate for 'DSKDSP'

GODISK::.WORD	0		; Go queue up a disk transfer

;053+
.IF	NE	<CNT.DU!CNT.MU>	; Don't bother if MCP phase isn't there	;050

	ORG	BBRDSP		;for calls from MCP to BBR		;014
$BBRDSP ==	.	;**MERGE** Alternate for 'BBRDSP'		;014

	TMPORG	DUMMY

NOCODE:	CRASH			;Crash since no code is there

	UNORG

;+
;	If MCP exists, but BBR doesn't then an errant call will
;	crash since the BBR phase won't have merged into this area
;-

$BBREP::.WORD	NOCODE		; go for the BBR stuff			;014
$RSMBR::.WORD	NOCODE		; and resume the BBR stuff....		;014
$MUSRV::.WORD	NOCODE		; Request processor for TMSCP.		;061
$MURSP::.WORD	NOCODE		; Response processor for TMSCP.		;061
$QUMTD::.WORD	NOCODE		; Queue a TSQ to TMSCP driver.		;061
$LOGMU::.WORD	NOCODE		; Log a TMSCP tape error.		;061

.ENDC
;053-
	ORG	FIPDSP		; Monitor to FIP dispatches
$FIPDSP	==	.	;**MERGE** alternate for 'FIPDSP'

FIPSNC::.WORD	0		; SYNC call to FIP
FIPGO::	.WORD	0		; Start up FIP
FIPERR::.WORD	0		; FIP error
$CHKAC::.WORD	0		; Protecion code checker		;020
$FIEXI::.WORD	0		; FIP exit with no JSFIP setting	;024

	ORG	GENDSP		; Monitor to GEN dispatches
$GENDSP	==	.	;**MERGE** Alternate for 'GENDSP'

ZERMEM::.WORD	0		; Zero memory
CKSWP::	.WORD	0		; Check for swaps in / out
RETMON::.WORD	0		; Return monitor/FIP pool buffer space	;059
RETMRP::.WORD	0		; RETMON restart point			;059
RETEXT::.WORD	0		; Return LRGPOL/EXTPOL buffer space	;059
RETERP::.WORD	0		; RETEXT restart point			;059
SETMDE::.WORD	0		; Set up a job's MDEs			;063
USRSTM::.WORD	0		; USRSET for updating MMU form MDE's	;075

	ORG	RSXDSP		; Monitor to RSX dispatches		;038
$RSXDSP	==	.	;**MERGE** Alternate for 'RSXDSP'		;038

RSXTRP::.WORD	0		; Do RSX SST/AST'S			;038
ODTADP::.WORD	0		; ODT's apping error vector		;075

	ORG	EMTDSP		; Monitor to EMT dispatches
$EMTDSP	==	.	;**MERGE** Alternate for 'EMTDSP'
$$ITOP	==	.	;**INIT* I-space must match D-space from here on ;065

DOPOST::.WORD	0		; Do job posting
	.WORD	0		; Reserved				;059
	.WORD	0		; Reserved				;042
DOMSIZ::MAP	0,APR=5,CODE,DATA,PIC ; Load EMTAP5 I&D PAR5
	JMP	@(PC)+		; Go do it
	.WORD	0		; Entry point filled in
.ASSUME	.-EMTDSP EQ 30		; EMT merge must be correct
EMLKIL::.WORD	RTS.PC		; EMT Logger processing for job kill	;013
LOGR50::.WORD	0		; Pack 9 characters into 3 RAD50 words	;031
SEARCH::.WORD	0		; Search logicals			;030
SRCHLG::.WORD	0		; Search system logicals (no Disks)	;030
DCOPY::	.WORD	0		; Copy low-core D-space to I-space	;052

	ORG	EM2DSP		; Dispatches for EM2 phase		;033
$EM2DSP	==	.	;**MERGE** Alternate for "EM2DSP"		;033

PFREDO::.WORD	0		; Re-do entry for PFB I/O		;033
GETICF::.WORD	0		; Get character from ICF		;033
PUTLOG::.WORD	0		; Store character in log		;033
CHKLBF::.WORD	0		; Check log buffer for fullness		;033
PFIODN::.WORD	0		; PFB I/O done code			;033

	ORG	MTADSP		; Overlay magtape dispatches
$MTADSP	==	.	;**MERGE** Alternate for 'MTADSP'

	.BLKW0	4		; OPN, CLS, DIR, ZER

	ORG	DTADSP		; Overlay DECtape dispatches
$DTADSP	==	.	;**MERGE** Alternate for 'DTADSP'

	.BLKW0	7		; OPN, CLS, DIR, ZER, UTL, DLN, REN

	ORG	OPNDSP		; FIP to OPN dispatch			;033
$OPNDSP	==	.	;**MERGE** Alternate for 'OPNDSP'		;033

SUBUSG::.WORD	0		;EXL					;033

	ORG	LATDIS		; Monitor to LAT dispatches		;066
$LATDIS	==	.	;**MERGE** Alternate for 'LATDIS'		;066
; ** temporary dispatches for lat **

LTSTRT::.WORD	0		; Start the LAT software on a circuit   ;066
LTSTOP::.WORD	0		; Stop the LAT software on a circuit    ;066
LATTMO::.WORD	0		; LAT timer processing                  ;066

$$CRSZ	==	.		; Historic used to be top address in crash dump 

.SBTTL	Read-Only Storage for Device Drivers

$DISKS
.IF	NE	CNT.'NAME
.LIST
				; R-O section for NAME driver (NAME'DINT)
.NLIST
	DEFORG	NAME'DINT
.LIST
$'NAME'DINT	==	.	;**MERGE** Alternate for '$'NAME'DINT'
NAME'DINT:	.BLKB	DSKSIZ
.NLIST
.ENDC
.ENDM

.SBTTL	R/O Storage for Device Drivers, cont'd


$NAMES
.LIST
				; R-O section for NAME driver (NAME'DINT)
.NLIST
	ORG	NAME'DINT
.IF	DIF	<NAME>,<NL>
.IF	DIF	<NAME>,<PK>
.IF	DIF	<NAME>,<KB>						;049
.IF	DIF	<NAME>,<SY>						;057
.LIST
NAME'DINT:	.BLKW	2
NAME'DAP5::
.NLIST
.ENDC									;049
.ENDC
.ENDC
.ENDC									;057
.ENDM

	ORG	QUESUB


.SBTTL	Fill in LOWCOR

; Fill in LOWCOR vector area

	ORG	LOWCOR

LOWCOR:

.REPT	40/4
.DSABL	CRF
$$$$$$	=	.-LOWCOR
.IRP	N,<\<$$$$$$/100>>
.NLIST
	.WORD	FTLXX'N,PR7&4340!<$$$$$$/4&17>
.LIST
.ENDM
.ENABL	CRF
.ENDR

.REPT	60-40/4
	.BLKW	2
.ENDR

.REPT	1000-60/4
.DSABL	CRF
$$$$$$	=	.-LOWCOR
.IRP	N,<\<$$$$$$/100>>
.NLIST
	.WORD	FTLXX'N,PR7&4340!<$$$$$$/4&17>
.LIST
.ENDM
.ENABL	CRF
.ENDR

GLOBAL	<FTLXX0,FTLXX1,FTLXX2,FTLXX3,FTLXX4,FTLXX5,FTLXX6,FTLXX7>

; Now for the real low LOWCOR contents

.ENABL	LSB

	VECTOR	0,20$,PR7	; For vectoring to 0

	ORG	LOWCOR,40

$$LOWS	==	.	;**INIT** Start of 40-56 load area
10$:	.BLKW	2		; 40 - Do a system reload

IDATE::	.BLKW			; 44 - Start up date
ITIME::	.BLKW			; 46 - Start up time

	.BLKW			; 50 - Do a system reload
	.BLKW			; 52 - Do a crash dump/auto-restart
HALT::	.BLKW			; 54 - A 'HALT' (almost the only one)
	.BLKW			; 56 - Do a system reload
$$LOWE	==	.	;**INIT** End of 40-56 load area

	VECTOR	100,CLOK.L,PR6	; For KW11-L clocks

	VECTOR	104,CLOK.P,PR6	; For KW11-P clocks

	ORG	LOWCOR,106

20$:	JSR	R3,(PC)		; For trap to 0 (=4317=PR6 & reg set 1)
	JMPX	FTL000		;   go to here

.DSABL	LSB

	ORG	LOWCOR,144

DODUMP:	JMPX	CRA52		; Go take a crash dump

	ORG	LOWCOR,234

	.WORD	STSTBL		; Pointer to statistics pointers

GLOBAL	<CLOK.L,CLOK.P>

; Fill in non-vector LOWCOR contents

	ORG	LOWCOR,DATE

; System date/time information

$$DATE	==	.	;**INIT** Start up date goes here
.ASSUME	.-LOWCOR EQ DATE
	.BLKW			; Current date
$$TIME	==	.	;**INIT** Start up time goes here
.ASSUME	.-LOWCOR EQ TIME
	.BLKW			; Current time
.ASSUME	.-LOWCOR EQ TIMSEC
	.BYTE	60.		; Seconds until next minute
.ASSUME	.-LOWCOR EQ TIMCLK
	.BYTE	1		; Ticks until next second

; Current job ("JOB") information

.ASSUME	.-LOWCOR EQ JOB
	.BYTE	0		; Current job ("JOB")
.ASSUME	.-LOWCOR EQ NEXT
	.BYTE	0		; Next job to run
.ASSUME	.-LOWCOR EQ JOBDA
	.WORD	0		; -> "JOB"s job data block
.ASSUME	.-LOWCOR EQ JOBF
	.WORD	ZERO		; -> "JOB"s job data block @ JDFLG
.ASSUME	.-LOWCOR EQ IOSTS
	.WORD	JUNK		; -> "JOB"s job data block @ JDIOST
.ASSUME	.-LOWCOR EQ JOBWRK
	.WORD	0		; -> "JOB"s work block
.ASSUME	.-LOWCOR EQ JOBJD2
	.WORD	JUNK		; -> "JOB"s JDPPN table entry @ - J@PPN
.ASSUME	.-LOWCOR EQ JOBRTS
	.WORD	0		; -> "JOB"s RTS block
.ASSUME	.-LOWCOR EQ CPUTIM
	.WORD	JUNK		; -> "JOB"s CPU time bucket
.ASSUME	.-LOWCOR EQ JOBWDB
	.WORD	0		; -> "JOB"s WDB block
.ASSUME	.-LOWCOR EQ JOBJCR
	.WORD	0		; -> "JOB"s JCR entry (through APR6)	;052
.ASSUME	.-LOWCOR EQ JOBJC6
	.WORD	0		; MMU address for job's JCR entry	;052
.ASSUME	.-LOWCOR EQ JOBF3
	.WORD	0		; -> "JOB"s JDB @ JDFLG3		;059
.ASSUME	.-LOWCOR EQ LOWEND	; KERNEL/TBL lowcore layout mismatch	;052

GLOBAL	<ZERO,JUNK>

.SBTTL	Initial memory control list

	ORG	LOWCOR

$$$$$$	=	40-<.-LOWCOR&37>&37+.-LOWCOR

	ORG	LOWCOR,$$$$$$

.ENABL	LSB

.ASSUME	.-LOWCOR&37 EQ 0

$$MEML	==	.	;**INIT** Root of memory control list
MEMLST::.WORD	0		; Link to previous @ +2
	.WORD	20$		; Link to next				;049
	.WORD	0		; Total size of memory
MONSIZ:	.BYTE	0		; Size of monitor in K words
	.BYTE	MC.LCK		; Monitor is locked into memory		;023
MONADR:	.WORD	0		; Physical address (MMU address)

$$$$$$	=	40-<.-LOWCOR&37>&37+.-LOWCOR

	ORG	LOWCOR,$$$$$$

.ASSUME	.-LOWCOR&37 EQ 0

$$MEMT	==	.	;**INIT** Tail of memory control list
20$:	.WORD	MEMLST+2	; Link to previous @ +2			;049
	.WORD	0		; Link to next
	.WORD	1		; Total size in K
	.BYTE	1		; Dummy 1K section
	.BYTE	MC.LCK		;   locked into memory			;023
MEMSIZ::.WORD	0		; Physical address (memory size in K*32.)

.DSABL	LSB

.SBTTL	Initial Message Receiver List

	ORG	LOWCOR

$$$$$$	=	40-<.-LOWCOR&37>&37+.-LOWCOR

	ORG	LOWCOR,$$$$$$

.ASSUME	.-LOWCOR&37 EQ 0

ERLRIB::.WORD	0		; No link to next RIB yet
	.ASCII	"ERRLOG"	; Receiver ID
	.BYTE	0,SO.ERL	; No JOB, and Object Type = ERRLOG
	.BYTE	SA.LCL!SA.PRV,0	; Only local, privileged senders
	.WORD	40.*40		; Buffer maximum of 40.
	.BYTE	40.,0		; Limit of 40. and no messages
	.WORD	0,.-2		; Null pending message list initially
	.BLKW0	6		; Extra words

.ASSUME	.-LOWCOR&37 EQ 0



.SBTTL	RIB list root, Local Object Type tables

; The following are ordered

	ORG	SNDLST

SNDLST::.WORD	ERLRIB		; Message receiver list begins at ERL's RIB

LOTTBL::.BLKW0	SO.1MX		; One cell for each "one-only" object type	       ;006+
LT.ERL	==:	LOTTBL-2+<2*SO.ERL>	; Error Logger's cell
LT.EML	==:	LOTTBL-2+<2*SO.EML>	; EMT Logger's cell
LT.NTR	==:	LOTTBL-2+<2*SO.NTR>	; DECnet tracer's cell		;040

LOTFLG::.BLKW0	SO.1MX		; One flag word for each "one-only" object type
	.   =	LOTFLG-2+<2*SO.ERL>
LF.ERL::.WORD	EMLNVR			; Set Error Logger as "never EMT-log"
	.   =	LOTFLG-2+<2*SO.EML>
LF.EML::.WORD	EMLNVR			; Set EMT Logger as "never EMT-log"
										       ;006-

.SBTTL	Null run-time system description block

	ORG	LOWCOR

$$$$$$	=	40-<.-LOWCOR&37>&37+.-LOWCOR

	ORG	LOWCOR,$$$$$$

.ASSUME	.-LOWCOR&37 EQ 0

NULRTS::.WORD	0		; No link to next for now		;049
	.RAD50	/...RSX/	; Name is "...RSX"
	.RAD50	/TSK/		; Extension is "TSK"			;031
	.WORD	0,0		; No link to previous or next
	.WORD	0		; No total size in K
	.BYTE	0		; No RTS size
	.BYTE	MC.LCK		; ALways locked into memory		;023
	.WORD	0		; No physical address
	.WORD	0,0		; No data on disk
	.WORD	0,0		; No file on disk
	.BYTE	0,0		; No counts (as yet)
NULMAX:	.BLKB			; "SWPMAX" maximum size (filled in...)
	.BYTE	1		; 1K word minimum size
	.WORD	PF.KBM		; Keyboard monitor			;049

.ASSUME	.-LOWCOR&37 EQ 0

.SBTTL	File processor (FIP) information

	ORG	LOWCOR

FIQUE::	.WORD	0		; FIP'S queue root

;***** The next items are grouped *****

FIJOB::	.BLKB			; The job number times 2 of the job in FIP
FIPRIV::.BLKB			; Privilege flag for RJ2780		;043
FIUSER::.BLKW			; PPN of job in FIP
FIJBDA::.BLKW			; -> JDB of job in FIP
FIJBD2::.BLKW			; -> PPN table entry @ -J2PPN
FIPRVM::.BLKW	PRIVSZ/2	; Privilege mask for job in FIP		;012
FIPJCR::.BLKW			; -> JCR entry of job in FIP (via APR6)	;052
FIPJC6::.BLKW			; APR6 value to map job's JCR entry	;052

;*****	End of grouping							;012

FIPSJN::.BLKW			; The job number of the system job in FIP

.SBTTL	Stack regions

	ORG	LOWCOR

PWFSAV::			; Start of power fail save area

$$$$$$	=	0		; Starting trial stack limit value

.REPT	10.			; 10. iterations should do it!!
.IIF	LT	$$$$$$+340-<PWFSAV-LOWCOR>, $$$$$$=$$$$$$+400
.ENDR

	ORG	LOWCOR,$$$$$$

SL.VAL::.BLKB	400		; Stack limit value

	.BLKW	156.-2.		; This is the monitor's stack
$$STAK	==	.	;**INIT** Initial start up SP stack
	.WORD	START,PR5	; RTI will fall into our start routine
SYSTAK::.WORD	77		; R0 for null job
	.WORD	0		; R1 for null job
$$NULW	==	.	;**INIT** Set to <freq+<30./2>>/30.
	.WORD	<60.+<30./2>>/30. ; R2 for null job
	.WORD	0		  ; R3 for null job
	.WORD	0		  ; R4 for null job
	.WORD	0		  ; R5 for null job
	.WORD	NULJOB		  ; PC for null job
	.WORD	PR1&4340	  ; PS for null job

	.BLKW	156.		; This is the FIP stack
FISTAK::			;   base (reset) location

.SBTTL	The monitor buffer pool

; PATCH is padded so that BUFPOL starts on a 40(8) boundary
; BUFPOL is padded so FIP's I/O buffers start on a 1000(8) boundary
;	and so the I-space code is alligned optimally
; Any leftover small buffers go in MORBUF

	ORG	LOWCOR

SIZMEM	=	.-LOWCOR	; Start with low core size

.IF	NE,RJ2780
	ORG	RJDCTL		; The "RJ2780 root code"		;056
SIZMEM	=	SIZMEM+1124	; This will break if RJ ever changes	;056
.ENDC

	ORG	MEDCTL

SIZMEM	=	SIZMEM+MEDSIZ	; Add size of the MED code

	ORG	PATCH

SIZMEM	=	SIZMEM+.-PATCH	; Add current patch size
$$$$$$	=	40-<SIZMEM&37>	; Compute patch space rounding
	.BLKB	$$$$$$		; Round patch space to 40(8)
SIZMEM	=	SIZMEM+$$$$$$	; Add the rest of PATCH


; YABUF space is reserved for things that INIT carves out of the monitor
; pool free list during system startup time.  While INIT may not use the
; space in YABUF for the actual carving, the space is reserved here, outside
; of BUFPOL and MORBUF so that INIT and SILUS will not count it in the
; number of small buffers reported to the user.

	TMPORG	YABUF			; Yet Another Monitor pool
	.BLKB	11.*40			; Space reserved for startup

SIZMEM	=	SIZMEM+.-YABUF		; Add size of YABUF (even though
					;   it's after BUFPOL)

; ASSUME INIT.SYS includes MORBUF in initial list of free buffers

	TMPORG	IOBUFR

SIZMEM	=	SIZMEM+.-IOBUFR		; Add size of IOBUFR (even though
					;   it's after BUFPOL)

; Actually, the rounding later on ensures that the top of IOBUFR is rounded to
; a block boundary.  We assume that this will also round the bottom of IOBUFR
; here explicitly:

.ASSUME	<<.-IOBUFR>&777>	EQ	0

	ORG	BUFPOL

SIZMEM	=	.-BUFPOL+SIZMEM		; Add size of BUFPOL so far

.IIF	NDF	SMLBUF,	SMLBUF=30.	; Default initial size to some minimum
SMLBUF	=	SMLBUF-<<.-BUFPOL>/40>	; Account for small buffers to date
.IIF	LT	SMLBUF, SMLBUF=0.	;   but don't let it go below zero

$$$$$$	=	<25000-SIZMEM>/40	; Try to allign I-code at 25000
.IIF	LT	SMLBUF-$$$$$$, $$$$$$=SMLBUF ; (up to # of buffers requested)

	.BLKB	<$$$$$$*40>		; Allocate this part of BUFPOL
SMLBUF	=	SMLBUF-$$$$$$		;   and count the buffers allocated

SIZMEM	=	SIZMEM+<$$$$$$*40>	; Add in this part of BUFPOL
$$$$$$	=	0			; pretend BUFPOL is on block boundary 
.IIF	NE	SIZMEM&777, $$$$$$=1000-<SIZMEM&777> ;it's not? Find the      
	.BLKB	$$$$$$			; difference and round it up	      
SMLBUF	=	SMLBUF-<$$$$$$/40>	; Account for these small buffers
.IIF	LT	SMLBUF, SMLBUF=0	;   but don't let count go negative

; ASSUME INIT.SYS includes BUFPOL in initial list of free buffers

	ORG	MORBUF

	.BLKB	<SMLBUF*40>	; Allocate the rest of the Monitor pool
$$USEM 	== 	.		; used by SILUS to establish buffer counts
; ASSUME INIT.SYS includes MORBUF in initial list of free buffers

.SBTTL	One-shot code/data "hidden" in LOWCOR

	ORG	LOWCOR,PWFSAV-LOWCOR

; Initial start code is stored here...

START:	NOP			;; a handy patch point			;055
	CALLX	SETUP		;; Turn on memory management, etc., etc.
	MOV	DATE,IDATE	;; Set startup date
	MOV	TIME,ITIME	;;  and time
	MOVB	SWPMAX,NULMAX	;; Set swap max for the null RTS
	MOV	FIPAP6,FPLAP6	;; Initialize the FIP pool mapping
	MOV	DLPAP5,KLPAP5	;; Initialize KL port mapping		;065
	MOV	DLPAP5,DEPAP5	;; And DE port mapping			;065
	CLR	R0		;; Set up to create a job on KB0:	;065
	MOV	DEV.KB,R1	;; And pick up its DDB pointer		;065
	CALLMI	CREJOB,KBDAP5	;; Now create the first job
	MOV	JOBTBL(R3),R1	;; Back to our job, point to job data block
	MOV	JDWORK(R1),R4	;;  and get pointer to work block
	MOVB	R3,FQJOB(R4)	;; Set job number times 2
	MOVB	#STAFQ,FQFUN(R4) ;; and the "start up" dispatch function
	CLR	JBSTAT(R3)	;; Say job is waiting
	MOV	#JSFIP,JBWAIT(R3) ;; on FIP
	MOV	#PR3,-(SP)	;; Set up for CLOKGO RTI back here at PR3
	CALLX	CLOKGO		;;  (so start the clock and return at level 3)
	LOG$PF			;  Log the system coming up
	JMPX	FIPSYS		;  Now off to FIP for more startup...

; The 40-56 contents are stored here...

$$LOWC	==	.	;**INIT** Start of contents for 40-56
10$:	JMP	@#RELOAD	; 40 - Do a system reload

	.BLKW			; 44 - Start up date
	.BLKW			; 46 - Start up time

	BR	10$		; 50 - Do a system reload
	BR	DODUMP+<$$LOWC-$$LOWS> ; 52 - Do a crash dump/auto-restart
	HALT			; 54 - A 'HALT' (almost the only one!)
	BR	10$		; 56 - Do a system reload

.ASSUME	.-$$LOWC EQ $$LOWE-$$LOWS

.ASSUME	.	LE	$$STAK-100

GLOBAL	<SWPMAX,FIPAP6,FPLAP6,OVRBUF,RELOAD,DLPAP5,DEPAP5,KLPAP5> 	;065

.SBTTL	Dummy Returns for Non-Selected Options

	ORG	DUMMY

CLR.C:	TST	(PC)+		; A general "Carry-bit clear" quick return
SET.C:	SEC			; Set Carry-Bit to indicate option absent
RTS.PC:	RETURN			; A quick exit for absent options


.SBTTL	Pre-Resolve Globals for Modules not Selected

.IF EQ EMTLOG			    ; If EMT logging not wanted:
		EMLBLD ==: RTS.PC
		EMLSND ==: RTS.PC	; no need to include EMTLOG -
		EMLRCV ==: SET.C	;   resolve its associated globals
.ENDC								;008-

.IF	EQ	<TM02!TM11!TS11!TMSCP> ; If no magtapes:	;050

MTA ==: 0			; no need to include MTA	;032
MTU ==: 0			; or MTU			;032

.ENDC	;EQ	<TM02!TM11!TS11!TMSCP>				;050

.IF	EQ	TC11		; If no dectapes:		;032

DTU ==: 0			; no need to include DTU	;032

.ENDC	;EQ	TC11						;032

.IF	EQ	KMC11		; If no KMC11's			;032

KMC ==: 0			; no need to include KMC	;032

.ENDC	;EQ	KMC11

.SBTTL	Call Modules Required by SYSGEN Options from the Library

.IIF NE EMTLOG,		INCLUDE EMLFQ$	; EMT FQFUN logging-control table

.SBTTL	The Null Job

	DEFORG	NULJOB

NULJOB:	MOV	R2,R1		; Reset delay counter
10$:	WAIT			; Now wait...
	SOB	R1,10$		;  for specified delay
	ROL	R0		; Shift the lights
	BR	NULJOB		;  and continue


.SBTTL	2780 (RJE) timeouts

;+
; RJETMO - 2780 (RJE) timeouts.
;
; This subroutine is called once a tick, every tick...
;-

	DEFORG	RJETMO

RJETMO:	RETURN			;; Nothing unless overlaid

;+									;027
; RJDISP - 2780 (RJE) Is the RJ phase mapped				;027
;									;027
;	This routine is called to see if the RJ phase is		;027
;	the currently mapped phase OR to call the KGEMUlator		;027
;	if it is genned in.						;027
;									;027
;-									;027
	ORG	RJDISP							;027

RJMAPD::CLZ			;Never EQ				;027
DOKG11::RETURN								;027

.IF	NE,QBUSRJ
.IIF	NE,RJ2780	INCLUDE <KGEMU> ;CALL IN THE EMULATOR CODE	;027
.ENDC

.IF	NE,RJ2780							;073
	ORG	RJRPAT		; The RJ2780 root patch code		;073
RJRPAT::.BLKW0	7.		; for I & D space 			;073
.ENDC									;073

.SBTTL	Do final PSECT ordering

; The first thing to do is set up the general subroutines

.MACRO	SCTDEF	LIST
.IRP	SECT,<LIST>
	.CSECT	SECT
.ENDM
.ENDM

	SCTDEF	<MED,UPE,FPP,RTI,RES,DSASUB>				;062
	SCTDEF	<PPNTBL,CHEZAP,CHEUUO,ERL,SUB,STORE,FETCH,CLRBUF> 	;069
	SCTDEF	<CMNDVR,ERLDVR>						;059

; Now set up the driver data psects (this starts $$EPMM)

$NAMES
	.CSECT	'NAME'DVR
.ENDM

; Now set up the stuff that follows $$EPMM

	SCTDEF	<BUF,BUFEXT,IRB,DSTAT>					;069

; Now we're done

.MDELETE SCTDEF								;041

.SBTTL	Define error logging for devices

.DSECT	+EMT+LOG$SZ

$NAMES
.IF	DIF	<NAME>,<SY>
.IF	DIF	<NAME>,<NL>
.IF	DIF	<NAME>,<PK>
.IF	DIF	<NAME>,<KB>						;065
.LIST
LOG$'NAME::.BLKW		      ; Log an error for NAME
.NLIST
	ERRENT	LOG$'NAME,ERL$'NAME
.GLOBL	ERL$'NAME
.ASECT
.ENDC									;065
.ENDC
.ENDC
.ENDC
.ENDM
LOG$SZ	=	.&377	; Size of ERRTBL in bytes

.SBTTL	Define level 3 queue bits for devices

$NAMES
.IF	DIF	<NAME>,<SY>
L3Q$'NAME
.ENDC
.ENDM

.SBTTL	Device name table (DEVNAM)

	ORG	TBL

	.WORD	"SY
DEVNAM::
$DISKS
	.WORD	"NAME
.ENDM
DEVNKB::
$NAMES
.IF	DIF	<NAME>,<SY>
NAM.'NAME:
	.WORD	"NAME
.ENDC
.ENDM
DEVSYN::
$NAMES
.IF	DF	ALT.'NAME
	.WORD	ALT.'NAME
.ENDC
.ENDM
	.WORD	-1

DEVOKB	==	DEVNKB-DEVNAM	; Offset from 'DEVNAM' to 'DEVNKB'

.SBTTL	Device maximal unit table (DEVCNT)

	ORG	TBL

	.WORD	1-1
DEVCNT::
$DISKS
	.WORD	CNT.'NAME-1
.ENDM
$NAMES
.IF	DIF	<NAME>,<SY>
.IF	DIF	<NAME>,<PK>						;065
	.WORD	CNT.'NAME-1
.IFF	;DIF	<NAME>,<PK>						;065
	.WORD	-1		; Filled in...				;065
.ENDC									;065
.ENDC
.ENDM

DEVOSN	==	.-DEVSYN	; Offset from 'DEVNAM' to 'DEVCNT'

$NAMES
.IF	DF	ALT.'NAME
	.WORD	NAM.'NAME+2
.ENDC
.ENDM

.SBTTL	Pointer to DDB pointer table (DEVPTR)

	ORG	TBL

$$SYSP	==	.	;**INIT** -> UNTCNT entry of system disk
	.WORD	UNTCNT
DEVPTR::
$DISKS
	.WORD	DEV.'NAME
.ENDM
$NAMES
.IF	DIF	<NAME>,<SY>
.IF	DIF	<NAME>,<PK>						;065
	.WORD	DEV.'NAME
.IFF	;DIF	<NAME>,<PK>						;065
	.WORD	0		;Filled in...				;065
.ENDC	;DIF	<NAME>,<PK>						;065
.ENDC
.ENDM
DEVPTE::			;End of DEVPTR table			;065

.SBTTL	Controller name tables

	ORG	TBL

UCTTBL::			; Number of units on each controller
$NAMES
.IF DIF	<NAME>,<SY>
.IF DF	CTL.'NAME
UCT.'NAME::
$$$$$$	=	0
.IF GT	CTL.'NAME-1
.REPT	CTL.'NAME
.RADIX	10
.IRP	N,<\$$$$$$>
.RADIX	8
.IF	DF	NAME''N'UN
	.WORD	NAME''N'UN
.IFF
	.WORD	0		; Filled in
.ENDC
.ENDM
$$$$$$	=	$$$$$$+1
.ENDR
.IFF
	.WORD	CNT.'NAME
.ENDC
.ENDC
.ENDC
.ENDM

DDCTBL::			; Number of controllers and bias into UCTTBL
$NAMES
.IF DF	UCT.'NAME
	.BYTE	CTL.'NAME,UCT.'NAME-UCTTBL
.IFF
	.WORD	0
.ENDC
.ENDM

.SBTTL	Table of DDB pointers (DEVTBL)
	
	ORG	RAWMEM							

RAWMEM:
$NAMES
.IF	DIF	<NAME>,<SY>
.IF	DIF	<NAME>,<PK>						;065
.LIST
DEV.'NAME::
.NLIST
.DSABL	CRF
$$$$$$	=	0
.REPT	CNT.'NAME
.IF	DF	DDS.'NAME
	.WORD	NAME'DDDB+<DDS.'NAME*$$$$$$>
.IFF
	.WORD	FAKDDB
.ENDC
$$$$$$	=	$$$$$$+1
.ENDR
.ENABL	CRF
.ENDC	;DIF	<NAME>,<PK>						;065
.ENDC
.ENDM

GLOBAL	<FAKDDB>							;065

.SBTTL	Job Tables

; Absolute Globalizations

JOBMAX	==	JOBMAX		; Maximal job number
JOBMX2	==	JOBMAX*2	; (Maximal job number) * 2

; Main Job Table
                           
	ORG	RAWMEM

JOBTBL::.BLKW0	JOBMAX+1	; Initially, all are 0
	.WORD	-1		;  ..ending with a word of -1

; Job Status (JBSTAT) and Job Wait (JBWAIT) Tables

	ORG	RAWMEM

JBSTAT::.BLKW0	JOBMAX+1	; Initially, all are 0
JBWAIT::.BLKW0	JOBMAX+1	; Initially, all are 0

; Job PPN (JBPPN) and Job tick (JBTICK) tables

JBPPN::	.BLKW0	JOBMAX+1	; Initially, all are 0			;052
JBTICK::.BLKW0	JOBMAX+1	; Initially, all are 0			;052

.SBTTL	Define layout of optional JCR entries

.DSECT	JCFXSZ

.IF	NE	EMTLOG

JCEMLP::.BLKW			; Pointer to EML message packet		;052

.IFF

JCEMLP	  ==:	N$G$$D		; No J2EMLP pointer if EMTLOG not selected ;052

.ENDC		;EMTLOG    

JCABCT	  ==:	<.-JCAUXB>/2	; Count of pointers -> auxiliary (BUFHDR'ed) buffers
.ASSUME JCABCT GT 0		; SCH  KILL code depends on it

JCCPUI::.BLKW			; Incremental CPU time calculation bucket ;052

; The next five entries are grouped and must always be the last two entries
; in the JCR fixed portion (see MAPSUB.MAC and SCH.MAC before moving).

JCMHGH::.BLKW			; Max address -1 in job's RTS		;063
JCMLOW::.BLKW			; Max address in job's I-space segment	;063
JCMDLO::.BLKW			; Max address in job's D-space segment	;063
JCMFLG::.BLKW			; Job's mapping flags			;063
JCMDE::				; Start of mapping description entries	;063
	.BLKB	MDSIZE*8.	; Always allocate entries for user I-space ;063
.ASSUME	MOUSRI	EQ	0
				; Remaining MDEs are allocated in INIT	;063
$$JCFX::			; Size of static JCR entries for INIT	;052

.SBTTL	System Job tables

SYSJOB	==	4		; Global value for number of system jobs ;066

;+
; The current system jobs and job numbers are:
; 
;	ERRLOG	=	0.5
;	NSP	=	1.5
;	TRN	=	2.5
;	LAT	=	3.5						;066
;-

;+									+;054
; System job queueing structure:
;	SJBQUE contains a one word entry into the queueing subblock
;	for each SYSJOB.  Each job MERGES into this table at offset
;	JBNO-1 with the address of it's subblock.
;
; Each subblock looks like this:
;
; JOBBLK::.WORD  0	; HEAD of queue
;	  .WORD  JOBBLK ; TAIL of queue (points to HEAD initially)
;	  .L3Q	 QJOB	; L3Q bits to set to initiate activity in SYSJOB
;-									-;054

	ORG	SJBQUE							;058

SJBQUE::.BLKW0	SYSJOB		; one entry per system job		;054
SJBEND == <. - SJBQUE>		; and define the highest offset in table;054

	ORG	RAWMEM							;052

SJBTBL::.BLKW0	SYSJOB+1	; Initially all are 0
SJBCQR::.BLKW0	SYSJOB+1	; Pointer to system job completion queue
SJBL3Q::.BLKW0	SYSJOB+1	; Level 3 que bit/s to set on sysjob completion

.SBTTL	Run-time system & resident library lists

	ORG	RAWMEM

DEFKBM::.WORD	NULRTS		; Pointer to Default Keyboard Monitor RTS ;049
RTSLST::.WORD	NULRTS		; RTS list root				;049
LIBLST::.WORD	0		; LIB list root

USETBL::.BLKB0	USESIZ		; Set up usage table			;044

.SBTTL	Job status bit table


	ORG	TBL

JSBTBL::
$NAMES
	.WORD	JS.'NAME
.ENDM



.SBTTL	I/O driver pointer to KISAR5 value table


	ORG	TBL

DVRAP5::
$NAMES
.IF	IDN	<NAME>,<NL>
	.WORD	RSTAP5							;057
.IFF
	.WORD	NAME'DAP5
.ENDC
.ENDM
DVRA5E::			; End of table

GLOBAL	<KBDAP5,PKDAP5>							;057

.SBTTL	Disk pointer table and UMR freed-up dispatch table

; ***** These 2 tables are grouped *****

DSKPTR::
$DISKS
.IF	NE	CNT.'NAME
	.WORD	$'NAME'DINT+DQS$OO
.ENDC
.ENDM
UMRKB:
$NAMES
.IF	DIF	<NAME>,<SY>
.IF	DF	UMR.'NAME
	.WORD	UMR$'NAME
.DSABL	CRF
.GLOBL	UMR$'NAME
.ENABL	CRF
.IFF
	.WORD	0
.ENDC
.ENDC
.ENDM
UMREND::			; End of table

.ASSUME	UMREND-UMRKB	EQ	DVRA5E-<DVRAP5+2>

.SBTTL	Timeout tables

	ORG	RAWMEM

TIMTBL::			; Device timeouts
DSS$XX::
$DISKS
.IF	NE	CNT.'NAME
.LIST
DSS$'NAME::
.NLIST   
	.BLKW0	CNT.'NAME
.LIST
DSE$'NAME::
.NLIST
.ENDC
.ENDM
$NAMES   
.IF	DIF	<NAME>,<SY>
.IF	DIF	<NAME>,<PK>						;065
.LIST
TIM.'NAME::
.NLIST
	.BLKW0	CNT.'NAME
.ENDC	;DIF	<NAME>,<PK>						;065
.ENDC
.ENDM
TIMEND::

DDO.XX	==	DEV.KB-TIM.KB	; Offset to DDB table from timeout table

.SBTTL	Device CSR table

	ORG	RAWMEM							;065

CSRTBL::
DSKCSR::
$DISKS
.IF	NE	CNT.'NAME
.LIST
CSR.'NAME::                                                   
$$CS'NAME	==	.	;**INIT** Disk CSR filled in
.NLIST
.NLIST
	.WORD	0          
.LIST
.ENDC
.ENDM                                                                       
$NAMES
.IF	DIF	<NAME>,<SY>
.IF	DIF	<NAME>,<PK>						;065
.IF	DIF	<NAME>,<NL>						;065
.LIST
CSR.'NAME::
.NLIST                                                            
.IF	NDF	CSR$'NAME
.LIST
$$CS'NAME	==	.	;**INIT** CSR(s) filled in
.NLIST
.ENDC
.ENDC	;IDN	<NAME>,<NL>						;065
.IF	NDF	CSR$'NAME                                            
	.BLKW0	CNT.'NAME
.IFF
	.BLKW0	CNT.'NAME,CSR$'NAME
.ENDC
.ENDC	;IDN	<NAME>,<PK>						;065
.ENDC
.ENDM

.SBTTL	Logical name table

	ORG	RAWMEM

DSKLOG::								;029
$DISKS
$$$$$$	=	0
.REPT	CNT.'NAME		; Removed PPN field from disk logicals	;029
	.WORD	0,0,0
	.ASCII	"NAME"
	.BYTE	$$$$$$,-1
$$$$$$	=	$$$$$$+1
.ENDR
.ENDM

;*** SYSLOG must follow DSKLOG table
SYSLOG::.WORD	0	; Contorted address of first system logical (in XBUF) ;029

.SBTTL	Line printer DDB layout

.DSECT

DDIDX:	.BLKB		; Driver index [IDX.LP]
DDSTS:	.BLKB		; Status and access control byte
DDJBNO:	.BLKB		; Owner job number times 2 (0 if free)
DDUNT:	.BLKB		; Device unit number
DDTIME:	.BLKW		; Time assigned or INITed
DDCNT:	.BLKW		; Init count and assignment control
DDFLAG:	.BLKW		; Device dependent flags
DDBUFC:	.BLKB	BCBSIZ	; Buffer chain control area (output)
DDHORZ:	.BLKB		; Horizontal position
DDHORC:	.BLKB		; Characters per line+1
DDVERT:	.BLKB		; Vertical position
DDVERC:	.BLKB		; Form length
LPTCHR:	.BLKW		; Printer characteristics			;026
LPTBFG:	.BLKB		; Check buffering flag
LPTERR:	.BLKB		; Last error returned
LPTSPC:	.BLKB		; Special character for LP11'S
LPTBQC:	.BLKB		; Buffer quota checking flag
LPTPSP:	.BLKB		; Pending space(s) count
LPTICH:	.BLKB		; Interrupt holding character
LPTIRB:	.BLKW		; Current IRB/DATA buffer indication (LPDVRX)
LPTBBP:	.BLKW		; Bridge block pointer (LPDVRK)
LPTPG0:	.BLKW		; Page counter lsb word				;018
LPTPG1:	.BLKW		; Page counter msb word				;018
LPTDFL:	.BLKB		; Default form length				;018
	.BLKB		; (reserved)					;018

.DSECT			; In DDFLAG word

	.BLKB	.	; (reserved)					;018
	.BLKB	.	; (reserved)					;018
	.BLKB	.	; (reserved)					;018
	.BLKB	.	; (reserved)					;018
	.BLKB	.	; (reserved)					;018
LPTESC:	.BLKB	.	; Change escape to $		(   16.)	;018
LPTNWR:	.BLKB	.	; No wrap long lines		(   32.)	;018
LPTBOK:	.BLKB	.	; Buffer chain owned by owner
LPTCH0:	.BLKB	.	; Change "0" to "O"		(  128.)
LPTNOX:	.BLKB	.	; Truncate long lines		(  256.)
LPTSFT:	.BLKB	.	; Software formatting		(  512.)
LPTALC:	.BLKB	.	; Allow lower case	     NOT( 1024.)
LPTOVF:	.BLKB	.	; Skip over perforations	( 2048.)
LPTFFT:	.BLKB	.	; Use form feed for TOF		( 4096.)	;018
LPTNFC:	.BLKB	.	; No form feed on close		( 8192.)
LPTCUP:	.BLKB	.	; Print ctrl chars with uparrow	(16384.)

.SBTTL	Device DDB's

XD.1ST	=	400		; "First unit on control" bit for XD's

$NAMES
.IF	DF	DDS.'NAME
	ORG	NAME'DDDB
.LIST

NAME'DDDB:
.NLIST
.DSABL	CRF
.GLOBL	DDS.'NAME,STS.'NAME
.IF DF	CTL.'NAME
$$$$$0	=	CTL.'NAME
.IFF
$$$$$0	=	1
.ENDC
$$$$$$	=	0
$$$$$C	=	0
.REPT	$$$$$0
.IF	DF	CTL.'NAME
.RADIX	10
.IRP	CTRL,<\$$$$$C>
.RADIX	8
$$$$$1	=	NAME''CTRL'UN
.ENDR
.IFF
$$$$$1	=	CNT.'NAME
.ENDC
$$$$$U	=	0
.REPT	$$$$$1
	.BYTE	IDX.'NAME,STS.'NAME,0,$$$$$$
.NLIST
.REPT	DDS.'NAME-4/2
	.WORD	0
.ENDR
.LIST
;034+
.IF	IDN	<NAME>,<MS>
.	=	.-DDS.MS+DDSTS
	.BYTE	DDASY/400
.	=	.+DDS.MS-DDSTS-1
.ENDC
;034-
;050+
.IF	IDN	<NAME>,<MU>
.	=	.-DDS.MU+DDSTS
	.BYTE	DDASY/400
.	=	.+DDS.MU-DDSTS-1
.ENDC
;050-
.IF	EQ	$$$$$U
.IF	IDN	<NAME>,<XD>
.	=	.-DDS.XD+DDFLAG
	.WORD	XD.1ST
.	=	.+DDS.XD-DDFLAG-2
.ENDC
.ENDC
.IF	DF	BFQ.'NAME
.GLOBL	BFQ.'NAME
.	=	.-DDS.'NAME+DDBUFC+BC
	.WORD	BFQ.'NAME
.	=	.+DDS.'NAME-DDBUFC-BC-2
.ENDC
.IF	DF	HOR.'NAME
.	=	.-DDS.'NAME+DDHORZ
	.BYTE	HOR.'NAME+1,HOR.'NAME+1
.	=	.+DDS.'NAME-DDHORZ-2
.ENDC
.IF	IDN	<NAME>,<LP>
.	=	.-DDS.LP+LPTCHR
	.WORD	LPTALC
.	=	.-2-LPTCHR+LPTDFL					;018
	.BYTE	66.							;018
.	=	.-1-LPTDFL+DDS.LP					;018
.ENDC
.LIST

.NLIST
$$$$$$	=	$$$$$$+1
$$$$$U	=	$$$$$U+1
.ENDR
$$$$$C	=	$$$$$C+1
.ENDR
.ENABL	CRF
.ENDC
.ENDM

.SBTTL	Device driver service dispatch tables

	ORG	SERTBL,0
SERTBL:
$NAMES
.IF	LE	IDX.'NAME'-14						;067
	.WORD	0		;Filled in...				;057
.IFF									;054
	.WORD	SER$'NAME
.DSABL	CRF
.GLOBL	SER$'NAME
.ENABL	CRF
.ENDC
.ENDM

.SBTTL	Device driver OPEN dispatch tables

	ORG	OPNTBL,0
OPNTBL:
$NAMES
.IF	IDN	<NAME>,<KB>
	.WORD	0	; Filled in...
.IFF
.IF	IDN	<NAME>,<PK>
	.WORD	0	; Filled in...
.IFF
.IF	IDN	<NAME>,<XE>					;054
	.WORD	0	; Filled in from XEDVR phase		;054
.IFF								;054
.IF	IDN	<NAME>,<XH>					;054
	.WORD	0	; Filled in from XHDVR phase		;054
.IFF								;067
.IF	IDN	<NAME>,<NO>					;067
	.WORD	0	; Filled in from NODVR phase		;067
.IFF								;054
	.WORD	OPN$'NAME
.DSABL	CRF
.GLOBL	OPN$'NAME
.ENABL	CRF
.ENDC								;067
.ENDC
.ENDC
.ENDC
.ENDC
.ENDM

.SBTTL	Device driver CLOSE dispatch tables

	ORG	CLSTBL,0
CLSTBL:
$NAMES
.IF	IDN	<NAME>,<KB>
	.WORD	0	; Filled in...
.IFF
.IF	IDN	<NAME>,<PK>
	.WORD	0	; Filled in...
.IFF
.IF	IDN	<NAME>,<XE>					;054
	.WORD	0	; Filled in from XEDVR phase		;054
.IFF								;054
.IF	IDN	<NAME>,<XH>					;054
	.WORD	0	; Filled in from XHDVR phase		;054
.IFF								;067
.IF	IDN	<NAME>,<NO>					;067
	.WORD	0	; Filled in from NODVR phase		;067
.IFF								;054
	.WORD	CLS$'NAME
.DSABL	CRF
.GLOBL	CLS$'NAME
.ENABL	CRF
.ENDC								;067
.ENDC
.ENDC
.ENDC
.ENDC
.ENDM

.SBTTL	Device driver timeout dispatch tables

	ORG	TMOTBL,0
TMOTBL:
$NAMES
.IF	IDN	<NAME>,<SY>
	.WORD	0
.IFF
.IF	IDN	<NAME>,<KB>
	.WORD	0	; Filled in...
.IFF
.IF	IDN	<NAME>,<PK>
	.WORD	0	; Filled in...
.IFF
.IF	IDN	<NAME>,<XE>					;054
	.WORD	0	; Filled in from XEDVR phase		;054
.IFF								;054
.IF	IDN	<NAME>,<XH>					;054
	.WORD	0	; Filled in from XHDVR phase		;054
.IFF								;067
.IF	IDN	<NAME>,<NO>					;067
	.WORD	0	; Filled in from NODVR phase		;067
.IFF								;054
	.WORD	TMO$'NAME
.DSABL	CRF
.GLOBL	TMO$'NAME
.ENABL	CRF
.ENDC								;067
.ENDC
.ENDC
.ENDC
.ENDC
.ENDC
.ENDM

.SBTTL	Device driver SPEC dispatch tables

	ORG	SPCTBL,0
SPCTBL:
$NAMES
.IF	LE	IDX.'NAME'-14						;067
	.WORD	0	; Filled in...
.IFF									;054
	.WORD	SPC$'NAME
.DSABL	CRF
.GLOBL	SPC$'NAME
.ENABL	CRF
.ENDC
.ENDM

.SBTTL	Device driver SLEEP dispatch tables

	ORG	SLPTBL,0
SLPTBL:
$NAMES
.IF	IDN	<NAME>,<KB>
	.WORD	0	; Filled in...
.IFF
.IF	IDN	<NAME>,<PK>
	.WORD	0	; Filled in...
.IFF
.IF	IDN	<NAME>,<XE>					;054
	.WORD	0	; Filled in from XEDVR phase		;054
.IFF								;054
.IF	IDN	<NAME>,<XH>					;054
	.WORD	0	; Filled in from XHDVR phase		;054
.IFF								;067
.IF	IDN	<NAME>,<NO>					;067
	.WORD	0	; Filled in from NODVR phase		;067
.IFF								;054
.IF	DF	SLP.'NAME
	.WORD	SLP$'NAME
.DSABL	CRF
.GLOBL	SLP$'NAME
.ENABL	CRF
.IFF
	.WORD	0
.ENDC
.ENDC								;067
.ENDC
.ENDC
.ENDC
.ENDC
.ENDM

.SBTTL	Device driver ASSIGN dispatch tables

	ORG	ASNTBL,0
ASNTBL:
$NAMES
.IF	IDN	<NAME>,<SY>
	.WORD	0
.IFF
.IF	IDN	<NAME>,<KB>
	.WORD	0	; Filled in...
.IFF
.IF	IDN	<NAME>,<PK>
	.WORD	0	; Filled in...
.IFF
.IF	IDN	<NAME>,<XE>					;054
	.WORD	0	; Filled in from XEDVR phase		;054
.IFF								;054
.IF	IDN	<NAME>,<XH>					;054
	.WORD	0	; Filled in from XHDVR phase		;054
.IFF								;067
.IF	IDN	<NAME>,<NO>					;067
	.WORD	0	; Filled in from NODVR phase		;067
.IFF								;054
	.WORD	ASN$'NAME
.DSABL	CRF
.GLOBL	ASN$'NAME
.ENABL	CRF
.ENDC								;067
.ENDC
.ENDC
.ENDC
.ENDC
.ENDC
.ENDM

.SBTTL	Device driver DEASSIGN dispatch tables

	ORG	DEATBL,0
DEATBL:
$NAMES
.IF	IDN	<NAME>,<SY>
	.WORD	0
.IFF
.IF	IDN	<NAME>,<KB>
	.WORD	0	; Filled in...
.IFF
.IF	IDN	<NAME>,<PK>
	.WORD	0	; Filled in...
.IFF
.IF	IDN	<NAME>,<XE>					;054
	.WORD	0	; Filled in from XEDVR phase		;054
.IFF								;054
.IF	IDN	<NAME>,<XH>					;054
	.WORD	0	; Filled in from XHDVR phase		;054
.IFF								;067
.IF	IDN	<NAME>,<NO>					;067
	.WORD	0	; Filled in from NODVR phase		;067
.IFF								;054
	.WORD	DEA$'NAME
.DSABL	CRF
.GLOBL	DEA$'NAME
.ENABL	CRF
.ENDC								;067
.ENDC
.ENDC
.ENDC
.ENDC
.ENDC
.ENDM

.SBTTL	Device driver data tables

	ORG	FLGTBL,0
FLGTBL:
$NAMES
	.WORD	FLG.'NAME
.DSABL	CRF
.GLOBL	FLG.'NAME
.ENABL	CRF
.ENDM

	ORG	SIZTBL,0
SIZTBL:
$NAMES
	.WORD	SIZ.'NAME
.DSABL	CRF
.GLOBL	SIZ.'NAME
.ENABL	CRF
.ENDM

	ORG	BUFTBL,0
BUFTBL:
$NAMES
	.WORD	BUF.'NAME
.DSABL	CRF
.GLOBL	BUF.'NAME
.ENABL	CRF
.ENDM

.SBTTL	MSCP data structures

	ORG	CMTCTL			; CMT/UMT area

;+
; *** NOTE *** NOTE *** NOTE *** NOTE ***
;
; IF THERE ARE NO MSCP DEVICES CONFIGURED ON THE SYSTEM, THEN 
; "CMT" MUST EQUAL "UMT$XX".  THESE LABELS ARE USED BY "LOD.MAC"
; MODULE TO DETERMINE IF THERE ARE MSCP DEVICES CONFIGURED ON
; THE SYSTEM BEING STARTED UP.  IF THESE  LABLES ARE EQUAL, THEN
; NO ATTEMPT IS MADE TO INITIALIZE THE MSCP REGION.
;
; INIT requires that UMT$DU always be defined.  If no disks are
; genned, then this value must equal UMT$XX.  INIT also assumes
; that when MSCP disks are present, that UMT$DU is the last entry.
; 
;-

.SBTTL	CMT (Controller Mapping Table)

;+
; Controller mapping table header
;-

.IIF	NE	<CNT.MU!CNT.DU>,.BLKW0	 <-CM.HDR/2>	;CMT header area ;050

;+
; Controller mapping table
;-

CMT::				;Always define it for LOD.MAC		;050

.IIF	NE	CNT.DU	.BLKB	CMTSIZ*4	; Allocate 4 disk CMT's	;050
.IIF	NE	CNT.MU	.BLKB	CMTSIZ*4	; Allocate 4 tape CMT's	;060

.SBTTL	UMT (Unit Mapping Table)

;+
; Unit mapping table.  Maps each unit to a given controller.
; Filled in by INIT or dynamically by the driver.
;-

UMT$XX::			;Always define it for LOD.MAC		;050

.IF	NE	CNT.DU

	$DISKS
	.IF	NE	CNT.'NAME
	.LIST
	UMT$'NAME::
	.NLIST
		.BLKW0	2*CNT.'NAME
	.LIST
	UME$'NAME::
	.NLIST
	.ENDC
	.ENDM

.IFF

UMT$DU::			; Always define it for INIT.SYS		;050

.ENDC

.SBTTL	Disk driver tables and queues

; FIP unit number to disk driver index table

	ORG	TBL

DSKMAP::
$$$$$$	=	0
$DISKS
.REPT	CNT.'NAME
	.WORD	$$$$$$
.ENDR
.IIF	NE	CNT.'NAME, $$$$$$ = $$$$$$+2
.ENDM

; All of the disk driver queues

	ORG	RAWMEM

DQS$XX::
$DISKS
.IF	NE	CNT.'NAME
.LIST
DQS$'NAME::
.NLIST
	.BLKW0	CNT.'NAME
.LIST
DQE$'NAME::
.NLIST
.ENDC
.ENDM

DQSEND::			; End of disk queues


; All of the optimization words

	ORG	RAWMEM

OPT$XX::
$DISKS
.IF	NE	CNT.'NAME
.LIST
OPT$'NAME::
.NLIST
	.BLKW0	CNT.'NAME
.ENDC
.ENDM

; Globalize offsets from queue root to other tables

DSO$XX	==	DSS$XX-DQS$XX	; From queue root to status table

OPO$XX	==	OPT$XX-DQS$XX	; From queue root to optimization word

; All of the 'ID' words

	ORG	RAWMEM							;022

$$DMID	==	.	;**INIT** Correct ID's filled in
MID$XX::
$DISKS
.IF	NE	CNT.'NAME
.LIST
MID$'NAME::
.NLIST
	.BLKW0	CNT.'NAME
.ENDC
.ENDM

.SBTTL	Disk logical status tables

; Unit status/count table

	ORG	RAWMEM

UNTCNT::
$DISKS
DEV.'NAME:
	.BLKW0	CNT.'NAME,UC.MNT
.ENDM
UNTCNE::

; Do absolute globalizations

MAXUNT	==	UNTCNE-UNTCNT/2-1
MAXUN2	==	MAXUNT*2

; Device cluster (DCS) and cluster factor (biased PCS/DCS) table

	ORG	RAWMEM

$$DDCS	==	.	;**INIT** Correct DCS'S filled in
DEVCLU::.BLKW0	MAXUNT+1
CLUFAC	==	DEVCLU+1

; Pack cluster size (PCS) and Owning job tables				;015

	ORG	RAWMEM

UNTCLU::.BLKW0	MAXUNT+1
UNTOWN	==	UNTCLU+1						;015

; Table of the [1,2] UFD starting DCN for each unit

	ORG	RAWMEM

UNTLIB::.BLKW0	MAXUNT+1

; List headers of open file FCB's for large file systems

	ORG	RAWMEM

FCBLST::.BLKW0	MAXUNT+1

; Size of unit in DCN's table

	ORG	RAWMEM							;017

$$DSIZ	==	.	;**INIT** Correct sizes filled in
UNTSIZ::.BLKW0	MAXUNT+1


; Unit options table							;015

	ORG	RAWMEM

UNTOPT::.BLKW0	MAXUNT+1						;015

; Unit error count table						;015

	ORG	RAWMEM

UNTERR::.BLKW0	MAXUNT+1						;015

; Unit revision level table

	ORG	RAWMEM

UNTLVL::.BLKW0	MAXUNT+1
UNTREV	==	UNTLVL+1	; Rev is in high byte

; MFD pointer table

	ORG	RAWMEM

MFDPTR::.BLKW0	MAXUNT+1

; Disk Quota Pointer Table						;025

	ORG	RAWMEM

DSKQPT::.BLKW0	MAXUNT+1						;025


.SBTTL	S.A.T. related tables

; S.A.T. logical pointer (DCN)

	ORG	RAWMEM

SATPTR::.BLKW0	MAXUNT+1

; S.A.T. end (largest PCN)

	ORG	RAWMEM

SATEND::.BLKW0	MAXUNT+1

; S.A.T. starting FIP block number

	ORG	RAWMEM

SATSTL::.BLKW0	MAXUNT+1

SATSTM::.BLKW0	MAXUNT+1

; S.A.T. count of free blocks

	ORG	RAWMEM

SATCTL::.BLKW0	MAXUNT+1

SATCTM::.BLKW0	MAXUNT+1

; S.A.T. MMU address if loaded

SATMMU::.BLKW0	MAXUNT+1						;049

.SBTTL	Set up disk statistics pointers

	ORG	RAWMEM

DSTSIZ	==	<MAXUNT+1*6*6*2>+1 ; Size of the table in words		;039
DSTMUL	==	MAXUNT+1*6*2*2	; Multiplication factor for table

DSTPTR::.WORD	0		; Pointer to stats table filled in	;039

	ORG	RAWMEM

HLTCRS::.WORD	0		; Word to flag a crash while crashing

.SBTTL	Set final .TITLE/.IDENT

$0	=	SYSVEL		; System major version
$1	=	SYSVEE		; System minor version
$2	=	$$$VER		; System edit level			;050
.IF	GT	<$$$VER&177>-100					;074
.IIF	GT	<$$$VER&177>-132	.ERROR	;Illegal Edit level
$2	=	<<$2/400&177>*400>+<$$$VER&177-100+22>			;074
.ENDC									;074
.IF	GT	<$$$VER/400&177>-100					;074
.IIF	GT	<$$$VER/400&177>-132	.ERROR	;Illegal Edit level
$2	=	<$2&177>+<<<$$$VER/400&177>-100+22>*400>		;074
.ENDC									;074

.TITLE	RSTS
.IDENT	<$0&177-22><$0/400&177-22>"."<$1/400&177-22><$2&177-22><$2/400&177-22>

.END
