	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
	.INCLUDE /CMN:FLDEF/
TITLE	FIL,<FILE ADD/REMOVE>,0A,10-MAY-91,MHB/RTW/GPK/SJM/WJS/DRP/TWH/FRL/KPH

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR FIL

;+
;
;  000	RRF  06-Mar-81	CREATION - COPIED FROM V7.0-07
;  001	RTW  09-Aug-80	Added 'adding' of DECnet files
;  002	RTW  19-Aug-80	Took away 2 decnet files
;  003  GPK  16-Mar-81	Added list file function
;  004  GPK  16-Mar-81	Removed second DECnet file code
;  005  SJM  19-Oct-81	Fix install of decnet files for big and litle fip
;
;				[RSTS V8.0]
;  006	GPK  27-Sep-82	New disk structure
;  007	WJS  29-Oct-82	New UUOENT for EMT Logger
;
;				[RSTS V9.0]
;  008	GPK  28-Mar-83	Multiple privileges
;  009	DRP  20-Sep-83	Check open count in INSTAL
;  010	DRP  03-Oct-83	Table changes to UNTCNT, UNTOWN/UNTOPT and 
;			UNTCLU/UNTERR
;  011	TWH  01-DEC-83	ADD CALL TO AUTOSZ
;  012	GPK  09-Dec-83	Make it fit
;  013  FRL  02-Apr-84  V9.0 logicals
;  014	GPK  17-Apr-84	Privilege name changes
;  015  FRL  23-Oct-84	Check disk size vs. swap slot size (for NFS swap)
;  016	KPH  19-Dec-84	Copy loaded overlays
;  017	KPH  23-Jan-85	Add WRTNFS check for NFS swap add
;
;				[RSTS V9.2]
;  018  KPH  09-Aug-85	Add job control region
;
;				[RSTS V9.3]
;  019  KPH  02-Oct-85	Changes for DECnet/E V4.0
;
;				[RSTS V10.0]
;  020	FEK  19-Feb-90	Return flag if no file was removed
;-

FQFSRT	FIL

.SBTTL	SWAP/OVERLAY/ERROR FILE ADD/REMOVE

;+
; UU.SWP - SWAP/OVERLAY/ERROR FILE ADD/REMOVE.
;
;	R4 -> FIRQB
;		FQFIL   =    0=> SWAPFILE #0
;		             1=> SWAPFILE #1
;		             2=> ILLEGAL (SWAPFILE #2)
;		             3=> SWAPFILE #3
;		             4=> OVERLAY FILE
;		             5=> ERROR MESSAGE FILE
;			     6=> NSP #0 [0,1]NSP0.SYS
;		FQFIL+1 =    0=> REMOVE
;		            >0=> ADD
;			    <0=> GET NAME
;		FQNAM1  =  FILENAME (2 WORDS) [ADD]
;		FQDEV,FQDEVN = DEVICE TO USE [ADD]
;-

SY.NSP=6

.ENABL	LSB

10$:	MOV	R3,R2		;COPY THE SWAP # TIMES 2		;017
	ASR	R3		; AND GET # OF SWAP FILE TO REMOVE
	ADD	#SWPUSE,R3	;  TO BUILD POINTER TO USE BYTE
	ASH	#3-1,R2		;ALSO GET SWAP # TIMES 8.
	FJMP	SWAPFL		;Now continue in next overlay		;017

20$:	FJMP	NETFIL		;PROCESS NSP FILES

30$:	FJMP	LSTFIL		;PROCESS GET NAME FUNCTION

40$:	FJMP	REMOVE		;PROCESS REMOVE

	UUOENT	SWP,,,LOGABL  ;SWAP/OVERLAY/ERROR FILE ADD/REMOVE	;008

	MOVB	FQFIL(R4),R3	;GET WHICH FILE WE ARE DEALING WITH
	CMP	R3,#6		;LEGAL FILE?
	BHI	50$		;NOPE, ERROR
	TSTB	FQFIL+1(R4)	;IS IT "GET NAME"?
	BMI	30$		;YES IF NEGATIVE
	TSTPRV	INSTAL,@#FIPRVM	;Privileged to install/remove things?	;014
	BEQ	50$		;No, reject this			;008
	CMP	R3,#5		;NSP FILE?
	BHI	20$		;6 => DECNET FILE
	ASL	R3		;YES, TIMES 2 FOR DISPATCHING NOW
	MOV	#OVBASU+FBBSIZ+F.FBNL,R2 ;PRESET POINTER FOR OVERLAY FILE
	ADD	R3,PC		;NOW DO THE DISPATCH...
	BR	10$		;0 => SWAPFILE #0
	BR	10$		;1 => SWAPFILE #1
50$:	ERROR	BADFUO		;2 => ILLEGAL (SWAPFILE #2)
	BR	10$		;3 => SWAPFILE #3
	BR	60$		;4 => OVERLAY FILE
	MOV	#ERBASU+FBBSIZ+F.FBNL,R2 ;5 => ERROR MESSAGE FILE; GET POINTER
60$:	TSTB	FQFIL+1(R4)	;IS IT ADD OR REMOVE?
	BEQ	40$		;0 SO IT IS REMOVE

GLOBAL	<FIPRVM,OVBASU,ERBASU>						;008

	MOV	(R2),R0		;IS ANYTHING INSTALLED
	BIS	-(R2),R0	; HERE NOW?
	BEQ	70$		;NOPE, SO O.K.
	ERROR	FIEXST		;YEP, SAY ALREADY EXISTS

70$:	MOV	-FBBSIZ-2(R2),R1 ;O.K., GET THE MINIMUM FILE SIZE
	CALL	CHKFIL		;NOW CHECK FOR FS AND THAT SIZE
	REGSAV			;SAVE REGISTERS FOR THE INSTALL
	MOVB	R0,@#L		;Save the destination unit number	;016
	MOV	@#FIBFBN,-(SP)	;SAVE MSB AND
	MOV	@#FIBFBN+F.FBNL,-(SP) ; LSB OF BLOCK NOW IN "FIBUF"
	MOV	-FBBSIZ-2(R2),R0 ;SAVE BLOCK COUNT FOR MOVE ON STACK
	MOV	@#OVBASE,R1	;POINT TO THE OVERLAY FILE FBB LIST
	CMP	R2,#OVBASU+FBBSIZ ;GOOD GUESS?
	BEQ	80$		;YES
	MOV	#ERBASE,R1	;NO, POINT TO ERROR FILE FBB
80$:	MOV	R4,R2		;NOW COPY THE STARTING DCN AND
	CALLX	CNVDCN		; CONVERT IT INTO A FBN
	MOV	R2,R5		;PUT LSB OF TARGET FILE HERE
	MOV	R3,R4		; AND MSB OF SAME HERE
	FCALL	CPYFBB		;Now copy the FBB list			;016
	MOV	(SP)+,R2	;RESTORE LSB AND
	MOV	(SP)+,R3	; MSB OF BLOCK TO BE IN "FIBUF"
	MOV	(SP),@#FIPUNT	;RESTORE UNIT OF THAT BLOCK
.ASSUME	TOS.R0	EQ	0
	CALLX	READ		; AND READ IT BACK
	CALLX	REGRES,R5	;NOW RESTORE THE REGISTERS
	FJMP	INSTAL		; AND EXIT INSTALLING THE FBB'S

.DSABL	LSB								;016

GLOBAL	<FIBFBN,OVBASE,OVBASU,ERBASE,L>					;016

;+
; CHKFIL - CHECK FILE DISALLOWING NON-FILE STRUCTURED.
;
;	R1 =  MINIMUM REQUIRED FILE SIZE
;	R4 -> FIRQB WITH NAME AND DEVICE
;
;	CALL	CHKFIL
;	FCALL	CHKFIL
;
;	R0 =  UNIT
;	R1 =  ACTUAL FILE SIZE IN BLOCKS
;	R3 =  RANDOM
;	R4 =  STARTING DCN OF FILE
;	R5 =  N.E. POINTER FOR FILE
;-

CHKFIL:	MOV	R2,-(SP)	;SAVE R2
	MOV	R1,-(SP)	;ALSO SAVE REQUIRED MINIMUM FILE SIZE
	TST	FQNAM1(R4)	;A FILENAME?
	BNE	10$		;YES
	ERROR	BADNAM		;NO, SO ERROR

10$:	CALLX	GUN,R5		;CHECK THE DEVICE NAME
	BR	20$		;DISK AND MOUNTED, O.K.
	ERROR	DEVNFS		;OTHER IS AN ERROR

20$:	MOV	R4,R0		;COPY THE FIRQB POINTER AND
	ADD	#FQPPN,R0	; INDEX TO PPN, FILENAME.EXT
	MOV	(PC)+,(R0)	;SET PPN = [0,1]
	 .BYTE	1,0
	MOV	#^RSYS,FQEXT(R4) ;SET EXTENSION = ".SYS"
	CALLX	SMU		;NOW TRY TO FIND THE FILE
	BCC	30$		;FOUND
	ERROR	NOSUCH		; ELSE ERROR

30$:	MOV	(PC)+,R0	;Set PPN				;014
	 .BYTE	1,0		; as [0,1]				;014
	MOV	R1,-(SP)	;Save possible FCB pointer		;014
	MOVB	UPROT(R5),R1	;Get protection code			;014
	CALLX	CHKACC		;Verify access rights			;014
	MOV	(SP)+,R1	;Restore R1				;014
	BIT	#DDWLO!DDRLO,R0	;Must have read/write access		;014
	BNE	40$		;Error if not				;014
	MOVB	@#FIPUNT,R0	;GET THE UNIT NUMBER
	ASL	R0		; TIMES 2 FOR WORD ADDRESSING
	BIT	#UC.WLO,UNTCNT(R0) ;WRITE LOCKED?
	BEQ	50$		;NOPE
40$:	ERROR	PRVIOL		;YEP, THAT IS AN ERROR

GLOBAL	<FIPUNT,UNTCNT>

50$:	TST	R1		;IS THERE AN FCB?			;008
	BEQ	60$		;NO
	MOV	R5,-(SP)	;SAVE N.E. POINTER
	MOV	R1,R5		;PUT FCB POINTER IN R5
	ADD	#F$STAT,R5	;INDEX TO: USTAT/UPROT, UACNT
	CALL	130$		;GO UPDATE THE FCB
	MOV	(SP)+,R5	;RESTORE THE N.E POINTER
60$:	ADD	#USTAT,R5	;INDEX TO: USTAT/UPROT, UACNT, UAA
	CALL	130$		;AND UPDATE THE N.E AS WELL
	TST	(R5)+		;SKIP OVER OPEN COUNT	
	MOV	(SP)+,R1	;RESTORE REQUIRED MINIMUM FILE SIZE
	MOV	R3,-(SP)	;SAVE LINK TO N.E. OF FILE
	MOV	(R5)+,R3	;GET THE LINK TO THE A.E.
	MOV	(R5)+,-(SP)	;SAVE THE LINK TO THE R.E.'S
	CALLX	RDE		;NOW READ THE A.E.
	BIT	(R5),#UL.BAD	;A BAD BLOCK IN THIS FILE?
	BNE	40$		;YES, DON'T LET IT IN
	TST	URTS(R5)	;RTS NAME?
	BNE	70$		;YES, NOT A "LARGE" FILE
	TSTB	URTS+2(R5)	;NO, REALLY A "LARGE" FILE??
	BNE	80$		;YES, THAT'S CERTAINLY BIG ENOUGH
70$:	CMP	R1,USIZ(R5)	;IS THE FILE BIG ENOUGH?
	BLOS	80$		;YEP
	ERROR	NOROOM		;NOPE, TOO SMALL

80$:	MOVB	DEVCLU(R0),R1	;GET THE DEVICE CLUSTER SIZE
	CLR	R2		;CLEAR A HIGH ORDER AND
	MOV	UCLUS(R5),R3	; GET LOW ORDER OF FILE CLUSTER SIZE
	DIV	R1,R2		;DIVIDE FOR # DC'S PER RP
	MOV	(SP)+,R3	;RESTORE LINK TO R.E.'S
	MOV	USIZ(R5),-(SP)	;SAVE THE FILE'S ACTUAL SIZE
	TST	URTS(R5)	;RTS NAME?
	BNE	90$		;YES, NOT A "LARGE" FILE
	TSTB	URTS+2(R5)	;NO, REALLY A "LARGE" FILE??
	BEQ	90$		;NOPE, "SMALL" IT IS
	MOV	#-1,(SP)	;YEP, "LARGE", GIVE A BIG SIZE

GLOBAL	<DEVCLU>

90$:	CALLX	RDECHK		;NOW READ THE FIRST R.E.
	BEQ	40$		;NULL FILE IS AN ERROR
	MOV	UENT(R5),R1	;GET THE FILE'S STARTING DCN
	MOV	R1,R4		; AND SAVE IT FOR THE EXIT
	BEQ	40$		;ZERO HERE IS AN ERROR
100$:	MOV	(R5)+,R3	;GET LINK TO THE NEXT R.E.
110$:	TST	(R5)		;END OF THE CHAIN?
	BEQ	120$		;YES
	CMP	R1,(R5)+	;NO, FILE CONTIGUOUS?
	BNE	40$		;NOT CONTIGUOUS, ERROR
	ADD	R2,R1		;ELSE BUMP FOR THE NEXT COMPARE
	BIT	R5,#20-1	;MORE RP'S IN THIS R.E.?
	BNE	110$		;YES, LOOP
	CALLX	RDECHK		;NO, GET THE NEXT R.E.
	BNE	100$		;LOOP IF MORE
120$:	MOV	(SP)+,R1	;RESTORE FILE'S ACTUAL SIZE
	MOV	(SP)+,R3	;RESTORE LINK TO N.E.
	MOV	(SP)+,R2	;RESTORE R2
	ASR	R0		;MAKE UNIT NUMBER TIMES 1
	CALLRX	RDE		; AND EXIT READING THE N.E. (SETS R5)


130$:	CMPB	FQFIL(R4),#SY.NSP ;IS THIS THE DECNET FILE NSP0.SYS?
	BEQ	140$		;YES SO DON'T DEMAND WE GET WRITE ACCESS
	BIT	(R5),#US.WRT!US.UPD ;LEGAL FILE?
	BNE	40$		;NOPE
140$:	BIT	(R5)+,#US.DEL!US.UFD!US.OUT ;LEGAL FILE?
	BNE	40$		;NOPE
	RETURN			;AND BACK WE GO


FQFEND

FQFSRT

.ENABL	LSB

10$:	MOV	R2,R3		;COPY THE SWAP # TIMES 8. AND
	ASH	#3,R3		; MAKE IT TIMES 64. (BITS 7-6)
	CLR	R0		;Initialize job pointer			;018
20$:	TST	(R0)+		;Advance to next job #			;018
	MOV	JOBTBL(R0),R2	;IS THERE A JOB HERE?			;018
	BEQ	20$		;NO, SKIP TO NEXT
	CMP	R2,#-1		;END OF THE TABLE?
	BNE	30$		;NO, PROCESS THIS JOB
	ERROR	INUSE		;END, SAY FILE IS "IN USE"

30$:	CALLX	MAPJCR		;Map JCR entry for job			;018
	MOVB	JCSWAP(R1),R1	;GET JOB'S SWAP SLOT NUMBER		;018
	BEQ	20$		;NONE, SKIP IT
	BIC	#^C<300>,R1	;ONE, TRIM TO ONLY FILE # TIMES 64.
	CMP	R1,R3		;MATCH THE FILE WE'RE REMOVING?
	BNE	20$		;NOPE, SKIP
	ADD	#JDMCTL+M.CTRL,R2 ;YEP, INDEX TO JOB'S MEMORY CONTROL	;012
	CMPB	(R2),#OUT	;IS JOB IMAGE NON-RESIDENT NOW?		;012
	BEQ	40$		;START RESIDENCY IF SO
	BITB	(R2),#IN	;COMING IN?				;012
	BNE	20$		;YES, SKIP IT
	BITB	(R2),#OUT	;GOING OUT?				;012
	BEQ	20$		;NO, SKIP IT
	BISB	#REQ,(R2)	;REQUEST RE-RESIDENCY IF GOING OUT NOW	;012
	BR	20$		; THEN CONTINUE

40$:	SUB	#M.CTRL,R2	;Fix R2 to point to MCSB of entry	;012
	CLR	JDRESB-JDMCTL(R2) ;INDICATE A "FORCED" RESIDENCY
	CALLX	RESENT		; AND START THAT RESIDENCY
	BR	20$		;NOW LOOP FOR MORE...

GLOBAL	<JOBTBL>

SWAPFL:	TSTB	FQFIL+1(R4)	;IS IT ADD OR REMOVE?			;017
	BNE	90$		;<>0 SO IT IS ADD
	MOV	SWBASE+FBBSIZ(R2),R0 ;IS ANYTHING ALREADY
	BIS	SWBASE+FBBSIZ+F.FBNL(R2),R0 ; INSTALLED HERE?
	BNE	50$		;YEP, TRY TO REMOVE IT
	RETURN			;NOPE, JUST EXIT

50$:	TSTB	(R3)		;HAS THE FILE BEEN LOCKED ALREADY?
	BMI	80$		;YES
	BISB	#200,(R3)	;NO, SO LOCK IT RIGHT NOW
	FCALL	SUMSWP		;SUM SWAP SLOTS WITHOUT THIS FILE
	SPLC	5		;;LOCKOUT NEW JOB CREATIONS
	MOVB	@#JOBCNT,R1	;;GET THE CURRENT # OF JOBS
	CMPB	R1,@#MAXJOB	;;IS IT > THE ALLOWED #?
	BHIS	60$		;;YES
	MOVB	@#MAXJOB,R1	;;NO, GET THE MAXIMUM # THEN
60$:	CMP	R1,R0		;;CAN WE STILL RUN IF THE SWAP FILE REMOVED?
	BLOS	70$		;;YEP
	BICB	#200,(R3)	;;NOPE, UNLOCK THE SWAPPING FILE
65$:	ERROR	PRVIOL		;; AND SAY ERROR			;017

70$:	FCALL	NUMSWP		;;SET A NEW # OF JOBS LIMITATION	;015
	SPLC	3		;; AND BACK TO LEVEL 3 AGAIN
	MOV	R2,R0		;COPY THE # TIMES 8. AND
	ADD	#SWPMAP,R0	; POINT TO THE MAP WORDS
	CLR	(R0)+		;NOW CLEAR ALL
	CLR	(R0)+		; OF THE MAP
	CLR	(R0)+		;  WORDS FOR THIS
	CLR	(R0)+		;   FILE
80$:	CMPB	(R3),#200	;IS THE FILE TOTALLY FREE NOW?
	BNE	10$		;NO, GO SAY "IN USE" NOW
	CLRB	(R3)		;O.K., CLEAR OUT THE USE COUNTER
	ADD	#SWBASE+FBBSIZ+F.FBNL,R2 ;INDEX TO THE FBB PAIR
	FJMP	REMOVE		; AND GO "CLOSE" THE FILE

GLOBAL	<SWPUSE,SWBASE,JOBCNT,MAXJOB,SWPMAP>

90$:	MOV	R2,-(SP)	;SAVE SWAPFILE # TIMES 8.
	ADD	#SWBASE+FBBSIZ+F.FBNL,R2 ;NOW POINT TO THE FBB'S
	MOV	(R2),R0		;IS ANYTHING ALREADY
	BIS	-(R2),R0	; INSTALLED HERE?
	BEQ	100$		;NO
	ERROR	FIEXST		;YES, AN ERROR

100$:	TST	FQNAM1(R4)	;IS THIS A FS SWAPFILE ADD?
	BNE	160$		;YES (FILENAME SUPPLIED)
	MOV	R2,-(SP)	;NO, NFS, SAVE R2
	CALLX	GUNMNT,R5	;CHECK DEVICE NAME
	BR	110$		;IT IS DISK, SO O.K.
	ERROR	DEVNFS		;OTHER IS AN ERROR

110$:	TSTPRV	WRTNFS,@#FIPRVM	;Privileged to write NFS?		;017
	BEQ	65$		;No, forget it				;017
	CMP	UNTCNT(R0),#UC.MNT ;SIMPLY NOT MOUNTED NOW?
	BEQ	130$		;YES, O.K. TO USE
	BHI	120$		;NO, DISABLED, SAY NOT AVAILABLE
	ERROR	INUSE		;NO, MOUNTED, SAY "IN USE"

120$:	ERROR	NOTAVL		;DEVICE IS NOT AVAILABLE

130$:	CALLX	AUTOSZ		;INITIALIZE THE SIZE TABLES		;011
	CALLX	READPL		;TRY TO READ FBN=1 (I.E. REALLY THERE?)
	CALLX	WRITE		; THEN WRITE IT BACK (I.E. WRITABLE?)
	MOV	UNTSIZ(R0),R1	;GET UNIT'S SIZE IN DC'S
	MOVB	DEVCLU(R0),R3	;NOW GET THE DCS VALUE
	MOVB	R3,UNTCLU(R0)	;Set PCS as DCS				;010
140$:	ASR	R3		;SHIFT SIZE AGAIN?
	BCS	150$		;NO
	ASL	R1		;YES, SO DO IT
	BCC	140$		;NO OVERFLOW, CONTINUE
	MOV	#177777,R1	;OVERFLOW, CALL IT BIG...
150$:	CLR	R5		;SIGNAL THE NFS CASE
	CLR	R4		;STARTING DCN=0 FOR NFS
	MOV	@#SWPMAX,R2	;Compute size of 1 swap slot		;015
	ASL	R2		;	(* 4 for blocks)		;015
	ASL	R2		;	...				;015
	CMP	R1,R2		;Is disk smaller than 1 swap slot?	;015
	BLOS	155$		;Yes, ERROR				;015
	MOV	#UC.PRI!UC.NFS!1,UNTCNT(R0) ;MOUNT DISK AS NFS & PRIVATE ;015
	INCB	UNTOWN(R0)	; AND OWNED BY THE SYSTEM		;015
	CLR	UNTOPT(R0)	;No options				;015
	CLR	UNTERR(R0)	; and no errors				;015
	ASR	R0		;MAKE UNIT NUMBER TIMES 1
	MOV	(SP)+,R2	;No, restore R2				;015
	BR	170$		; AND CONTINUE

155$:	ERROR	NOROOM		;Disk too small for NFS swapping	;015

GLOBAL	<SWBASE,UNTCNT,UNTOWN,UNTSIZ,DEVCLU,UNTCLU,UNTOPT,UNTERR>	;010

160$:	MOV	@#SWPMAX,R1	;MINIMUM SIZE IS 1 SWAP SLOT
	ASL	R1		; WHICH IS K TIMES
	ASL	R1		;  4 FOR BLOCKS
	FCALL	CHKFIL		;NOW CHECK THE FILE TO ADD
170$:	CALL	INSTAL		;GOT IT, INSTALL THE FBB'S
	MOV	(SP)+,R2	;GET BACK SWAPFILE # TIMES 8.
	ADD	#SWPMAP,R2	; AND BUILD A SWAP MAP POINTER
	CLR	R0		;CLEAR HIGH ORDER SIZE (LOW ORDER SET)
	ASHC	#-2,R0		;CONVERT BLOCKS INTO K
	DIV	@#SWPMAX,R0	;NOW DIVIDE FOR # OF SWAP SLOTS
	MOV	#2,R1		;START AT BIT <1>
	CMP	R0,#63.		;MORE THAT 63. SWAP SLOTS IN THIS FILE?
	BLOS	180$		;NO, O.K. TO USE FULL COUNT
	MOV	#63.,R0		;YES, REDUCE THE COUNT TO ONLY 63.
180$:	BIS	R1,(R2)		;TURN ON A SWAP SLOT
	ASL	R1		;SHIFT FOR THE NEXT SLOT'S BIT
	BCC	190$		;NO OVERFLOW, CONTINUE
	ROL	R1		;OVERFLOW, MAKE BIT <0> NOW AND
	TST	(R2)+		; ADVANCE THE MAP POINTER
190$:	SOB	R0,180$		;LOOP FOR ALL SWAP SLOTS OBTAINED
	FJMP	NUMSWP		;RECALCULATE LEGAL LIMIT AND EXIT	;015

.DSABL	LSB

GLOBAL	<SWPMAX,SWPMAP>

;+
; INSTAL - INSTALL THE FBB'S.
;
;	R0 =  UNIT
;	R2 -> DATA/FILE FBB PAIR @ FILE FBB
;	R4 =  STARTING DCN
;	R5 -> N.E. OF FILE (OR 0 IF NFS)
;	FIBUF HAS THE UFD BLOCK CONTAINING THE N.E. (IF FS)
;
;	CALL	INSTAL
;
;	R1 =  PRESERVED
;	R2 =  RANDOM
;	R3 =  RANDOM
;	R5 =  RANDOM
;-

INSTAL:	NOP
	MOV	R1,-(SP)	;SAVE R1
	MOV	R0,@#FIPUNT	;RESET CORRECT FIP UNIT NUMBER
	MOV	R5,R3		;COPY THE N.E. POINTER
	BEQ	30$		;ZERO, SO A NFS INSTALL
	ASL	R0		;Make it Fip Unit Number * 2		;009
	MOV	#UC.CNT,-(SP)	;Get maximum count of open files	;009
	BIC	UNTCNT(R0),(SP)+ ;Are we at the limit?			;009
	BNE	5$		;No					;009
	ERROR	DTOOOF		;Yes, then issue an error		;009

5$:	SUB	#FIBUF,R3	;FIND THE N.E. OFFSET
	ASR	R3		; DIVIDED BY 2 AND
	MOVB	R3,(R2)+	;  SAVE THAT OFFSET/2
	MOVB	@#FIBFBN,(R2)+	;SAVE MSB AND
	MOV	@#FIBFBN+F.FBNL,(R2) ; LSB OF THE UFD BLOCK
	CALLX	SNE		;GET THE FCB POINTER IN R1
	BCS	10$		;SKIP FCB IF IT'S NOT THERE
	MOV	R5,R3		;SAVE N.E. POINTER
	MOV	R1,R5		;PUT FCB POINTER IN R5
	ADD	#F$STAT,R5	;INDEX TO: USTAT/UPROT, UACNT
	CALL	40$		;GO UPDATE THE FCB
	MOV	R3,R5		;RESTORE THE N.E POINTER
10$:	ADD	#USTAT,R5	;INDEX TO: USTAT/UPROT, UACNT, UAA
	CALL	40$		;AND UPDATE THE N.E AS WELL
	TST	(R5)+		;NOW POINT TO UACNT
	INC	(R5)+		; AND COUNT AS AN OPEN ACCESS
	MOV	(R5),R3		;GET THE LINK TO A.E.
	CALLX	RDESV		; AND READ THE A.E.
	CALLX	DATEIT		;GO SET DATE OF LAST ACCESS/WRITE
	INC	UNTCNT(R0)	; AND COUNT AS 1 MORE OPEN FILE ON UNIT
	ASR	R0		;BACK TO UNIT TIMES 1 AGAIN
20$:	MOV	R2,R5		;COPY THE FBB PAIR POINTER AND
	CMP	-(R5),-(R5)	; RE-INDEX TO F.FBNL IN DATA FBB
	MOV	R4,R2		;NOW COPY THE STARTING DCN AND
	CALLX	CNVDCN		; CONVERT IT INTO A FBN
	MOV	R2,(R5)		;SET THE LSB AND
	MOVB	R3,-(R5)	; MSB OF THAT STARTING FBN
	MOVB	R0,-(R5)	;FINALLY SET THE UNIT NUMBER
	MOV	(SP)+,R1	;RESTORE R1
	RETURN			;NOW WE CAN EXIT

30$:	COM	(R2)+		;NFS, SET A NEGATIVE VALUE
	BR	20$		; THEN CONTINUE


40$:	CMP	#<N0BASE+FBBSIZ+2>,R2	;WORKING ON NSP0 FILE?
	BEQ	50$		;DONT TAKE WRITE PRIV'S
	BIS	#US.WRT,(R5)	;TAKE THE WRITE PRIV'S
50$:	RETURN


GLOBAL	<FIPUNT,FIBUF,FIBFBN,UNTCNT,N0BASE>

FQFEND



FQFSRT
;+
; NETFIL - ADD/REMOVE DECNET FILES
;
;-

NETFIL:	TST	@#NODLST	;Is there a local node block (DECnet on)? ;019
	BEQ	10$		;NO THEN ADD OR REMOVE CAN HAPPEN
	ERROR	PRVIOL		;NSP/TRN ON THAT IS AN ERROR

10$:	MOV	#N0BASE+FBBSIZ+F.FBNL,R2 ;ASSUME NSP0 FILE
	TSTB	FQFIL+1(R4)	;IS THIS AN ADD OR A REMOVE?
	BEQ	REMOVE		;=0 SO ITS A REMOVE SO GO "CLOSE" THE FILE

20$:	MOV	(R2),R0		;IS ANYTHING INSTALLED
	BIS	-(R2),R0	; HERE NOW?
	BEQ	30$		;NOPE SO O.K.
	ERROR	FIEXST		;YEP, SAY ALREADY EXISTS

30$:	MOV	-FBBSIZ-2(R2),R1 ;O.K., GET THE MINIMUM FILE SIZE
	FCALL	CHKFIL		;NOW CHECK FOR FS AND THAT SIZE
	FJMP	INSTALL		;AND EXIT INSTALLING THE FBB'S	

GLOBAL	<NODLST,N0BASE>							;019

;+
; LSTFIL - LOOK UP AN INSTALLED FILE'S NAME
;
; RETURNS:
;	FQPPN	PPN OF FILE (ALWAYS [0,1])
;	FQNAM1	NAME, OR ZERO IF NON-FILE STRUCTURED
;	FQEXT	EXTENSION (.SYS)
;	FQDEV	DEVICE NAME
;	FQDEVN	UNIT NUMBER AND "REAL" FLAG
;
; ERRORS:
;	NOSUCH	FILE IS NOT INSTALLED
;-

LSTFIL:	MOVB	FQFIL(R4),R0	;GET FILE NUMBER
	CMPB	R0,#2		;IS THIS SWAP.SYS?
	BEQ	30$		;YES, SPECIAL CASE
	ASL	R0		;FORM WORD OFFSET
	ADD	PC,R0		;POINT TO TABLE OF FILE FBB'S
	ADD	#BASETB-.,R0	; (PICLY)
	MOV	(R0),R2		;POINT TO FILE FBB @ F.FBNL
	MOV	(R2),R1		;SEE IF THERE'S ANYTHING THERE
	BIS	-(R2),R1	; IN EITHER WORD
	BEQ	20$		;FILE NOT INSTALLED, RETURN ERROR
	MOVB	-FBBSIZ+F.UNT(R2),R1 ;PICK UP FIP UNIT NUMBER OF FILE
	CALL	FUNDEV		;STORE THE DEVICE NAME
	CLR	FQNAM1(R4)	;ASSUME NFS
	TST	(R2)		;IS THAT SO?
	BMI	10$		;YES, ALL DONE
	CALLX	RNEFBB		;READ NAME ENTRY, POINT R5 TO IT
	ADD	#FQPPN,R4	;POINT TO PPN FIELD IN FIRQB
	TST	(R5)+		;POINT TO NAME IN N.E.
.ASSUME	UNAM EQ 2
	MOV	(PC)+,(R4)+	;SET PPN
	 .BYTE	1,0		; [0,1]
	MOV	(R5)+,(R4)+	;MOVE NAME
	MOV	(R5)+,(R4)+	; .. MORE NAME
	MOV	(R5)+,(R4)+	;  .. AND EXTENSION
10$:	RETURN			;ALL DONE

20$:	ERROR	NOSUCH		;ERROR IF FILE NOT INSTALLED

; FILE #2 IS A SPECIAL CASE SINCE THE FILE FBB IS NOT FILLED IN
; THEREFORE WE HARD-CODE THE NAME AS [0,1]SWAP.SYS

30$:	MOVB	@#SYSUNT,R1	;GET FIP UNIT NUMBER OF SYSTEM DISK
	CALL	FUNDEV		;STORE DEVICE NAME
	ADD	#FQPPN,R4	;POINT TO PPN FIELD IN FIRQB
	MOV	(PC)+,(R4)+	;SET PPN
	 .BYTE	1,0		; [0,1]
	MOV	(PC)+,(R4)+	;FILE NAME
	 .RAD50	/SWA/
	MOV	(PC)+,(R4)+	; ..
	 .RAD50	/P  /
	MOV	(PC)+,(R4)+	;  .. AND EXTENSION
	 .RAD50	/SYS/
	RETURN			;DONE

; CONVERT FUN TO DEVICE NAME

FUNDEV:	MUL	#DL$SIZ,R1	;COMPUTE OFFSET INTO DISK TABLE		;013
	ADD	#DSKLOG+DL$DEV,R1 ;POINT TO PHYSICAL NAME FOR THIS DISK	;013
	MOV	(R1)+,FQDEV(R4)	;STORE DEVICE NAME IN FIRQB
	MOV	(R1)+,FQDEVN(R4) ; AND UNIT NUMBER
.ASSUME	DL$NUM	EQ	DL$DEV+2					;013
	RETURN

; THE FOLLOWING TABLE GIVES THE FILE FBB ADDRESSES FOR THE INSTALLED
; FILES, INDEXED BY FILE NUMBER.

BASETB:	.WORD	SWBASE+<0*FBBSIZ*2>+FBBSIZ+F.FBNL ;SWAPFILE 0
	.WORD	SWBASE+<1*FBBSIZ*2>+FBBSIZ+F.FBNL ;SWAPFILE 1
	.WORD	SWBASE+<2*FBBSIZ*2>+FBBSIZ+F.FBNL ;SWAPFILE 2
	.WORD	SWBASE+<3*FBBSIZ*2>+FBBSIZ+F.FBNL ;SWAPFILE 3
	.WORD	OVBASU+FBBSIZ+F.FBNL		  ;OVERLAY FILE
	.WORD	ERBASU+FBBSIZ+F.FBNL		  ;ERROR FILE
	.WORD	N0BASE+FBBSIZ+F.FBNL		  ;NSP0 FILE

GLOBAL	<SYSUNT,DSKLOG>							;013

;+
; REMOVE - REMOVE AN INSTALLED FILE.
;
;	R2 -> DATA/FILE FBB PAIR @ F.FBNL IN THE FILE FBB
;	R4 -> FIRQB
;
;	JMP	REMOVE
;	FJMP	REMOVE
;-

REMOVE:	CLR	FQCLUS(R4)	;Start with a 0 value to return success	;020
	TST	-(R2)		;IS THERE AN INSTALLED FILE HERE?
	BMI	40$		;YES, AND NFS AT THAT
	BNE	10$		;YES (AND FS)
	TST	F.FBNL(R2)	;REALLY ONE THERE?
	BEQ	80$		;NOPE, SIMPLE
10$:	MOVB	FQFIL(R4),-(SP)	;SAVE THE SWAPFILE NUMBER
	CALL	50$		;COPY THE FBB PAIR AND CLEAR IT
	CALLX	RNEFBB		;READ THE N.E. OF THE FILE
	MOV	R3,-(SP)	;SAVE LINK TO N.E. OF FILE
	CALLX	RAE		;READ THE A.E.
	CALLX	DATEIT		;GO SET DATE OF LAST ACCESS/WRITE
	MOV	(SP)+,R3	;GET THE N.E. LINK BACK AND
	CALLX	RDE		; RE-READ THE N.E.
	CALLX	SNE		;GET THE FCB POINTER IN R1
	BCS	20$		;SKIP FCB IF IT'S NOT THERE
	CMPB	(SP),#SY.NSP	;WORKING ON NSP0 FILE?
	BEQ	20$		;YES DONT RETURN  WRITE PRIV'S
	BICB	#US.WRT,F$STAT(R1) ;WE GIVE BACK WRITE PRIV'S NOW
20$:	CMPB	(SP)+,#SY.NSP 	;WORKING ON NSP0 FILE?
	BEQ	30$		;YES DONT RETURN  WRITE PRIV'S
	BICB	#US.WRT,USTAT(R5) ;WE GIVE BACK WRITE PRIV'S NOW
30$:	MARK	FIBUF		;MARK BUFFER FOR WRITE
	DEC	UACNT(R5)	; AND SAY 1 LESS ACCESS TO THIS FILE
	BNE	70$		;OTHERS STILL HAVE IT OPEN
	TSTB	USTAT(R5)	;ALL CLOSED, MARKED FOR DELETE?
	BPL	70$		;NOPE
.ASSUME	US.DEL	EQ	200
	CALLRX	XFL3		;YEP, SO DELETE IT NOW AND EXIT

40$:	CALL	50$		;REMOVE FBB AND GET UNIT, ETC.
	BIC	#UC.PRI,UNTCNT(R1) ;NO LONGER PRIVATELY OWNED
	CMP	UNTCNT(R1),#UC.NFS ;IS THE UNIT FREE NOW?
	BNE	70$		;NO
	CALLRX	ZAPUNT		;YES, ZAP IT OUT OF HERE AND EXIT

50$:	CMP	-(R2),-(R2)	;BACK UP TO THE DATA FBB
	CMP	(R4)+,(R4)+	; AND INDEX TO FIRQB @ +FQFIL
	MOV	R2,R5		;PUT THE REAL FBB PAIR POINTER HERE
	MOV	R4,R2		; AND POINT AT THE "SAVED" FBB PAIR
	CMP	(R2)+,(R2)+	;NOW POINT @ FILE FBB OF THE PAIR
	MOVB	(R5),R1		;GET THE UNIT NUMBER
	ASL	R1		; TIMES 2 FOR WORD ADDRESSING
	DEC	UNTCNT(R1)	;1 LESS OPEN FILE ON UNIT NOW
	MOV	#4,R0		;THERE ARE 4 WORDS IN THE 2 FBB'S
60$:	MOV	(R5),(R4)+	;COPY A FBB PAIR WORD
	CLR	(R5)+		; AND THEN CLEAR OUT THE FBB
	SOB	R0,60$		;  FOR BOTH FBB'S OF THE PAIR
70$:	RETURN			;NOW EXIT

80$:	DEC	FQCLUS(R4)	; Return a flag - saying NONE to do.	;020
	RETURN			; and now return			;020

GLOBAL	<UNTCNT>

;+
; NUMSWP - RECALCULATE # OF SWAP SLOTS POSSIBLE.
;
;	FCALL	NUMSWP							;015
;
;	R0 =  LEGAL # OF SWAP SLOTS
;-

NUMSWP:	CALL	SUMSWP		;SUM UP THE NEW SWAPPING SLOTS		;015
	CMP	R0,@#LMTCNT	;IS THAT > THE LIMITING COUNT?
	BLOS	10$		;NOPE
	MOV	@#LMTCNT,R0	;YEP, SO LIMIT IT ALREADY
10$:	MOV	R0,@#MAXCNT	;SET MAX # FOR THIS SWAPPING SET
	RETURN			; AND EXIT


;+
; SUMSWP - SUM THE NUMBER OF TOTAL SWAP SLOTS.
;
;	CALL	SUMSWP
;	FCALL	SUMSWP
;
;	R0 =  TOTAL # OF SWAP SLOTS
;-

SUMSWP:	CLR	R0		;PRE-CLEAR THE SWAP SLOT BUCKET
	REGSCR			;SAVE ALL REGISTERS
	MOV	#SWPMAP,R1	;GET SWAP MAP POINTER
10$:	MOV	R1,R3		;COPY THE MAP POINTER
	ADD	#4*2,R1		; THEN INDEX TO NEXT SWAPFILE
	MOVB	SWPUSE(R0),R4	;HAS THIS FILE BEEN "LOCKED"?
	BMI	40$		;IT DOESN'T COUNT IF LOCKED
	ADD	R4,TOS.R0(SP)	;NOT LOCKED, COUNT TOWARD TOTAL
20$:	MOV	(R3)+,R5	;GET A WORD OF SWAP MAP
30$:	ASL	R5		;SHIFT A BIT INTO CARRY AND
	ADC	TOS.R0(SP)	; COUNT IF IT WAS A 1
	TST	R5		;MORE BITS?
	BNE	30$		;YES, CONTINUE
	CMP	R3,R1		;MORE?
	BLO	20$		;YES, LOOP
40$:	INC	R0		;GO TO THE NEXT SWAPFILE #
	CMP	R0,#3		;MORE?
	BLOS	10$		;YES, LOOP
	RETURN			;ELSE RETURN

GLOBAL	<LMTCNT,MAXCNT,SWPMAP,SWPUSE>

FQFEND


FQFSRT

;+
; CPYFBB - Copy the overlay or error file
;
;	R0 = # of FBBs to copy
;	R1 -> FBB list for overlay file, if overlay file
;		--or--
;	R1 -> Error file FBB
;	L = Destination unit
;
;	FCALL	CPYFBB
;
;	All registers are undefined.
;-

CPYFBB:	MOVB	(R1)+,@#FIPUNT	;SET THE INPUT UNIT			;016
	MOVB	(R1)+,R3	;NOW GET MSB AND
	MOV	(R1)+,R2	; LSB OF THE INPUT BLOCK'S FBN
	TST	R3		;IS THAT BLOCK REALLY THERE?
	BPL	95$		;Yes, sure is				;016
	MAP	R2,APR=6,DATA,PIC ;No, so map the FBB table		;016
	MOV	-4(R1),R3	;Get the overlay offset through APR5	;016
	SUB	#120000+2+FBBSIZ,R3 ;And get the # of FBBs to copy * 2 - 2 ;016
	ADD	R3,R1		;Skip past all the overlay pointers	;016
	MOV	R1,-(SP)	;Save the FBB pointer			;016
	ASR	R3		;Get the number of FBBs to copy - 1	;016
	ASR	R3		; ...					;016
.ASSUME	FBBSIZ	EQ	4
	SUB	R3,R0		;And update the number of FBBs to do	;016
	MOV	R0,-(SP)	;Save the number of FBBs to do		;016
	INC	R3		;And get the actual number for this overlay ;016
	MOV	R3,R0		;And move to a convenient register	;016
	MOV	#140000+2,R1	;R1 -> Start of FBB list for overlay	;016
	CALL	CPYFBB		;Go and copy these FBBs			;016
	MOV	(SP)+,R0	;Restore counter			;016
	MOV	(SP)+,R1	;And FBB pointer			;016
	MAP	FIPPOL		;And mapping				;016
	BR	120$		;And continue with the next overlay	;016

95$:	CMP	R1,#ERBASE+FBBSIZ ;GOOD BLOCK, IS IT THE ERROR FILE?	;016
	BNE	100$		;NO, OVERLAY FILE, ALL SET
	ADD	@#ERSIZE,R2	;YES, ERROR FILE, ADD IN THE
	ADC	R3		; LENGTH OF THE ERROR FILE AND
	SUB	R0,R2		;  SUBTRACT THE CURRENT "TO BE DONE"
	SBC	R3		;   COUNT FOR CORRECT INPUT BLOCK
	CMP	-(R1),-(R1)	;BACK UP TO GET ERROR FILE FBB AGAIN
100$:	MAP	PUSH,APR=6,DATA,PIC ;Save FBB mapping			;016
	MAP	FIPPOL		;And be sure that FIP pool is mapped	;016
	CALLX	READ		;NOW READ THE INPUT BLOCK IN
	MOV	R4,@#FIBFBN	;SET OUTPUT BLOCK MSB
	MOV	R5,@#FIBFBN+F.FBNL ; AND LSB AS WELL AS
	MOVB	@#L,@#FIBUNT 	;  ITS UNIT NUMBER			;016
	CALLX	WRITE		;WRITE TO TARGET FILE
	MAP	POP,APR=6,DATA,PIC,R=R3 ;Restore FBB mapping		;016
	ADD	#1,R5		;BUMP THE OUTPUT FILE
	ADC	R4		; FBN BY 1 BLOCK'S WORTH
120$:	SOB	R0,CPYFBB	;LOOP FOR MORE...			;016
	RETURN			;And we're done				;016

GLOBAL	<FIPUNT,ERBASE,ERSIZE,ERBASU,FIBFBN,FIBUNT,L>			;016
	
FQFEND

.END
