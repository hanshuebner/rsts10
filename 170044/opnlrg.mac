.INCLUDE /CMN:COMMON/							;062
.INCLUDE /CMN:KERNEL/							;062
.INCLUDE /CMN:FLDEF/							;062
.INCLUDE /CMN:DTDEF/							;062
.INCLUDE /CMN:MTDEF/							;062
TITLE	OPL,<DISK UTILITIES FOR LARGE FILES>,0I,31-JAN-92,MHB/ABC/RTW/TG/SRM/DRP/FEK/WJS/GPK/TWH/KPH/TWH/MNB/FRL/VAM

;
;		COPYRIGHT (c) 1974, 1992 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR OPNLRG

;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;  001	RTW  02-Jul-80	Added remove all rib's to kill code
;  002  TG   13-MAR-81	Added error handling code to open/close code
;  003	SRM  25-Mar-81	Apply patches 3.5.15 and 3.5.18.  Also move
;			the code to create an MFD and/or UFD into
;			FCALLable routines.
;  004	SRM  30-Mar-81	Correct a problem in the CREMFD routine that
;			would crash the system if certain FUNs were
;			specified.
;  005	SRM  28-Sep-81	Restrict non-privileged users from writing
;			into privileged-executable files.
;			Align the DCN specified for a placed file
;			to be on a file cluster boundry.
;  006	SRM  10-Oct-81	Integrate FIP Pool breadboard changes to put
;			FCBs in FIP's private buffer pool.
;  007	JTC  14-Oct-81	Get WCB's from FIP Pool
;  008	JTC  15-Oct-81	Add "SGNRES" to FQFSRT
;  009  SRM  13-Nov-81	Fix the check to pre-extend a file in CREATE.
;  010	DRP  01-Feb-82	Put patch article 3.5.13 "Close crashes system"
;			into source.
;  011	DRP  28-Jun-82	Added support for new NFS open mode, mode 512.
;  012	FEK  17-Aug-82	Add support for placed directories
;  013	FEK  30-AUG-82	Add GFD support to CREMFD
;  014	FEK  28-Sep-82	Remove logout syscall
;  015	DRP  30-Sep-82	Restrict NFS opens and writes by non-priv. users.
;  016	WJS  29-Oct-82	New UUOENT for EMT Logger
;  017  DRP  14-Feb-83	Invalidate directory lookup cell when creating a
;			new account.
;
;				[RSTS V9.0]
;  018	GPK  04-Mar-83	Job headers
;  019	GPK  25-Mar-83	Extended FCBs
;  020	GPK  31-Mar-83	Multiple privileges
;  021	GPK  17-May-83	Change J2HDRS to a byte
;  022	GPK  22-Sep-83	New permanent file handling, add SYSMGR privilege
;  023	DRP  20-Sep-83	Source clear patch 3.5.16 M.
;  024	DRP  03-OCT-83	Table changes (UNTCNT, UNTCLU/UNTERR, UNTOWN/UNTOPT)
;	TWH  12-OCT-83	Add call to AUTOSZ
;  025  DRP  18-Nov-83	Moved overlay UU.ERR (ERRFQ) to module UUO.MAC
;			Combined OPNLRG and EXTLRG into a phase
;  026	GPK  22-Nov-83	Change protection check for runnable files
;  027	KPH  16-Jan-84	Add UU.ONX
;  028	TWH  20-JAN-84	ADD MTAIO AND MTADD ROUTINES (FROM MTU)
;  029  MNB  22-Jan-84  Asynch changes in M.CTRL byte
;  030	DRP  01-Feb-84	Changes for logged-in quotas
;  031	KPH  29-Feb-84	Bug fixes and performance improvements to UU.ONX
;  032	MNB  14-Mar-84	Renamed W$PT to W$PR (pending requests)
;  033	DRP  16-Mar-84	More changes for logged-in quotas
;  034	FEK  30-Apr-84	Add cluster optimization
;  035  KPH  27-Mar-84	Fix system crashes on tentative file opens
;  036  MNB  20-Apr-84	INI got moved in from CTL
;			Disallowed CLOSE on channel w/outstanding asynch I/O
;  037  MNB  01-May-84	Changes for asynch EXTEND support
;  038	KPH  08-May-84	Changes for task-loader
;			Disallow write access for opens of deleted files
;  039	FRL  08-May-84	V9.0 logicals
;  040	GPK  17-Apr-84	Change some privilege names; new RTS name setting
;			rules in file create; clear unused disk open
;			mode bits on open/create
;  041	KPH  25-Jun-84	Bugfixes
;			Move .RUN job size initialization to SCH
;  042	DRP  10-Jul-84	Implement code review changes
;  043	KPH  20-Jul-84	Disallow DSKINT mode on DV disk
;  044	KPH  07-Aug-84	Add delayed close
;  045	KPH  29-Aug-84	Changes for FIP pool in APR5
;			Move MTA to MVR phase
;  046	DRP  29-Oct-84	Bugfix. Date of last access not being updated properly
;  047	KPH  31-Oct-84	Add QTB counters
;  048  FRL  02-Nov-84  New special argument for POSITION
;  049	KPH  04-Feb-85	Bugfix in NFS open
;			Change CKPRIV to obey third-party-privileges
;  050  FRL  12-Apr-85  TMPPRV support
;
;			[RSTS V9.1]
;  051  KPH  01-Apr-85	Resident SATT processing
;  052	KPH  03-Jun-85	Clustersize optimization fallback
;			Preserve FIBUF contents in RETQTB and CREQTB
;  053  KPH  09-Aug-85	Bugfixes in 052
;			Require TMPPRV privilege for write access to
;			temporarily privileged files
;
;			[RSTS V9.2]
;  054  KPH  09-Aug-85	Add job control region
;  055  KPH  11-Mar-86	Invalidate SATBUF on account creation (since
;			the wildcard account lookup calls use SATBUF
;			as a MFD cache)
;
;			[RSTS V9.3]
;  056  KPH  12-Jan-86	Pass caller's job number on open and close to
;			drivers (for shareable devices)
;  057  DRP  28-Apr-86	Split SAVRFB into two routines and trap I/O
;			failures in RSTRFB
;  058  VAM  27-May-86	Allow multiple OPENs on non-mounted NFS disk.
;  059  KPH  08-Jun-86	Set up TYPCRE before creating UFDs
;  060	FEK  22-Sep-86	Add mode 16384 for write access to NFS disks.
;
;			[RSTS V9.4]
;  061  KPH  30-Jan-87	Changes for new mapping structure
;
;			[RSTS V9.6]
;  062  KPH  13-Oct-87	Add .INCLUDEs
;			Skip GETDEV calls on PK opens (for dynamic PKs)
;  063  PJH  03-Dec-87  Add return of Massbus ID in NFS disk opens at FQCLUS 
;
;			[RSTS V9.7]
;  064	DRP  03-May-89	Allow only explicit file creations on virtual
;			disk mounted public.
;
;			[RSTS V10.0]
;  065	FEK  02-Nov-89	Add BACKUP/IGNORE flag support
;  066	DRP  07-Aug-90	Preserve the FCB -> in OPNER2 routine.
;
;			[RSTS V10.1]
;  067	FEK  29-May-91	Create public disk account @ correct clustersize
;  068	FEK  16-Dec-91	RC25 center really = size/4; size/2 = spindle
;-

	IONLY			;Invoke I-space macro definitions	;045

	DEFORG	OPL

GLOBAL	<SYSLRG>		;ENSURE CORRECT LINK

.SBTTL	The MTA hook

;+
; MTAFQ - The MTA hook
;
; MTAFQ is handled in the MVR phase. Since resident FIP dispatching comes
; to the OPN phase, we simply CALLMR into the MVR phase. For further
; information, see MTA.MAC.
;-

FQFENT	MTA,,,PHASE

	CALLMR	MTAFUN,MVRAP5	;Off to the real code			;045

.WEAK	MTAFUN								;045

.SBTTL	OPEN EXISTING FILE

;+
; OPNFQ - OPEN EXISTING FILE.
;
;	R4 -> FIRQB
;		FQFIL    =  CHANNEL NUMBER TIMES 2
;		FQPPN    =  PPN (0=>SELF)
;		FQNAM1   =  FILE NAME (2 WORDS) OR FILE ID (0 / FID)
;		FQEXT    =  EXTENSION
;		FQMODE   =  OPEN MODE
;		FQDEV,FQDEVN = DEVICE TO USE (0=>PUBLIC)
;
;	OPEN EXISTING DISK FILE MODE BITS:
;
;	     1	    1.	 0	UPDATE MODE
;	     2	    2.	 1	APPEND
;	     4	    4.	 2	SPECIAL UPDATE MODE (WITH BIT 0)
;	    10	    8.	 3	ALWAYS UPDATE DISK FILE SIZE
;	   200	  128.	 7	NFS BLOCK MODE (LARGE FILE SYS)	[NFS ONLY]
;	   400	  256.	 8	USER DATA CACHING
;	  1000	  512.	 9	DSKINT mode			[NFS]
;	  4000	 2048.	11	USER DATA CACHING IS SEQUENTIAL
;	 10000	 4096.	12	READ REGARDLESS
;	 20000	 8192.	13	READ-ONLY MODE			[NFS]
;	 40000	16384.	14	WRITE ACCESS TO UFD'S		[UFD]
;				 or to mounted NFS disks	[NFS]
;	100000	32768.	15	MODE IS "REAL" INDICATOR	[UFD, NFS]
;
;	IN FIRQB ON RETURN
;		FQFIL    =  SAME AS PASSED
;		FQSIZM   =  FILE SIZE MSB
;		FQPPN    =  PPN
;		FQNAM1   =  FILE NAME (2 WORDS)
;		FQEXT    =  EXTENSION
;		FQSIZ    =  FILE SIZE LSB
;		FQBUFL   =  DEFAULT BUFFER SIZE
;		FQMODE   =  SAME AS PASSED
;		FQFLAG   =  FILE FLAGS
;		FQPROT-1 =  FILE CLUSTER SIZE (MOD 400)
;		FQPROT   =  PROTECTION CODE
;		FQDEV,FQDEVN = PHYSICAL DISK DEVICE NAME
;		FQCLUS   =  FILE ID
;		FQNENT   =  SAME AS PASSED
;-

	FQFENT	OPN,,<FQSIZ,FQBUFL,FQFLAG,FQPROT,FQCLUS>,PHASE

	CLR	FQSWIT(R4)	;SIGNAL THIS IS A NORMAL OPEN
	TST	FQMODE(R4)	;IS THERE A REAL MODE?
	BMI	10$		;YES
	CLR	FQMODE(R4)	;NO, SO ENSURE NO MODE
10$:	CALL	INI		;CHECK FOR ALREADY OPEN CHANNEL		;036
	BNE	20$		;Channel is open, that's an error
	CALLX	GUNMNT,R5	;CHECK OUT THE DEVICE TYPE
	 BR	OPENDS		;DISK
	JMP	OPENDV		;Non disk, handle that

20$:	ERROR	NOTCLS		;ERROR IF CHANNEL NOT CLOSED		;027

; DISK FILE / NFS DISK OPENER

OPENDS:	MOV	R0,R2		;SAVE THE UNIT TIMES 2
	BIC	#2160,FQMODE(R4) ;Clear out unused mode bits
	MOV	@#FIJBDA,R3	;GET CALLER'S JOB DATA POINTER
	MOVB	#CREFQ,JDPOST(R3) ;ENSURE DISK FILE OPEN POSTING
	MOV	R4,R0		;COPY FIRQB POINTER AND
	ADD	#FQPPN,R0	; INDEX TO PPN, FILENAME
	MOV	#SMU,-(SP)	;GUESS AT NORMAL OPEN SEARCH
	TST	FQNAM1(R4)	;IS THERE A FILE NAME?
	BNE	20$		;YES, NORMAL SEARCH
	TST	(R0)		;PPN specified?				;025
	BNE	10$		;Yes, then it's a file structured open	;025
	JMP	OPENNF		;No, then do non-file-structure open	;025

10$:	MOV	#SMM,(SP)	;GUESS AT OPENING UFD SEARCH
	TST	FQNAM1+2(R4)	;IS THERE A FILE ID?
	BEQ	20$		;NO, MUST BE UFD SEARCH
	MOV	#SMFID,(SP)	;FINAL GUESS AT A FILE ID OPEN SEARCH
	TST	FQDEVN(R4)	;WAS THE DEVICE NAME SPECIFIC?
	BEQ	60$		;NO, ERROR
20$:	BIT	#UC.MNT!UC.NFS,(R1) ;FS OPEN, UNIT O.K.?
	BMI	30$		;IT IS NOT MOUNTED, ERROR
	BNE	40$		;IT IS MOUNTED NON-FILE STRUCTURED, ERROR
	CALL	@(SP)+		;IT IS O.K., DO THE PROPER SEARCH
	BCS	50$		;NOT FOUND, GIVE AN ERROR
	MOVB	@#FIPUNT,R0	;FOUND, GET THE UNIT NUMBER
	BR	OPENFS		;Continue the open			;040

30$:	ERROR	NOTMNT		;SAY NOT MOUNTED

40$:	ERROR	DEVNFS		;SAY NOT FILE STRUCTURED

50$:	ERROR	NOSUCH		;SAY FILE/UFD/FID NOT FOUND

60$:	ERROR	PRVIOL		;OPEN BY FID BUT NOT SPECIFIC UNIT

GLOBAL	<FIJBDA,SMU,SMM,SMFID,FIPUNT,FIPRVM>				;040

.SBTTL	THE REAL WORK OF FILE STRUCTURED OPEN

.ENABL	LSB

;+
; OPENCE - OPEN A NEWLY CREATED FILE.
;
;	R0 =  UNIT
;	R3 =  LINK OF ENTRY
;	R4 -> FIRQB
;	QTCURR = QT buffer if it was created or 0 if none		;033
;-

OPENCE:	CLR	R1		;NEW FILE CAN'T HAVE AN FCB YET
	BIC	#OP$DUD!OP$NGA,FQMODE(R4) ;Drop unused modes		;027
	SEC			;ALWAYS ALLOW READ/WRITE ACCESS
	BR	10$		;GO DROP PRIVILEGED MODES

;+
; OPENFS - OPEN EXISTING FILE
;
;	R0 =  UNIT
;	R1 -> FCB (IF FILE OPEN) OR 0 or 1				;022
;	R3 =  LINK OF ENTRY or permanent file buffer pointer		;022
;	R4 -> FIRQB
;-

OPENFS:	CLR	@#QTCURR	;Indicate no QTB yet			;033
	;CLC			;NO SPECIAL READ/WRITE ACCESS ON OPENS (C=0) ;033
10$:	MOV	R0,@#FIPUNT	;RESTORE THE FIP UNIT NUMBER & SPECIFIC
	ROR	-(SP)		;SAVE CARRY FLAG FOR NEWLY CREATED FILE	;040
	MOV	R1,-(SP)	;SAVE FCB POINTER AROUND CALL
	CALL	INI		;GET IOB ADDRESS			;036
	MOV	(SP)+,R1	;RESTORE FCB POINTER
	ASL	(SP)+		;RESTORE CREATED-FILE FLAG		;040
	ROR	R5		;SAVE IT AS PART OF IOB ADDRESS
	MOV	R5,-(SP)	;SAVE THE IOB ADDRESS / 2 ! CREATED FLAG
	ASL	R0		;MAKE THE UNIT NUMBER TIMES 2
	MOV	#UC.CNT,R5	;Maximum count of open files		;023
	BIC	UNTCNT(R0),R5	;Are we at the limit?			;023
	BNE	30$		;No, then continue on			;025
	TST	(SP)		;Yes, Was this a create?		;025
	BPL	20$		;No					;025
	CALL	DELNEW		;Delete new file and return QTB (if any) ;042
20$:	ERROR	DTOOOF		;Sorry, ?Too many open files		;025

30$:	MOV	R0,-(SP)	;Stack the unit number * 2		;025
	ADD	#UNTCNT,(SP)	;  AND BUILD POINTER TO UNTCNT TABLE ENTRY
	MOV	R0,R5		;SAVE FIP UNIT NUMBER * 2
	MUL	#DL$SIZ/2,R5	; AND GET INDEX INTO DISK LOGICAL TABLE	;039
	ADD	#FQDEV,R4	;INDEX TO: FQDEV, FQDEVN, FQCLUS
	MOV	DSKLOG+DL$DEV(R5),(R4)+ ;SET THE REAL PHYSICAL DISK	;039
	MOV	(R4),R2		;GET PASSED UNIT NUMBER AND FLAGS
	MOV	DSKLOG+DL$NUM(R5),(R4)+ ;SAVE UNIT NUMBER AND FLAG	;039
	BIT	#UC.PRI,@(SP)	;A PUBLIC UNIT?				;040
	BNE	50$		;NO, LEAVE FLAG OF -1 (377)
	ASLB	-(R4)		;YES, SET FLAG = -2 (376)
	TST	R2		;WAS INITIAL REFERENCE SPECIFIC??
	BNE	40$		;YEP, LEAVE FLAG OF -2 (376)
	ASLB	(R4)		;NOPE, SET FLAG = -4 (374)
40$:	INC	R4		;POINT TO FQCLUS NOW
50$:	MOV	R3,(R4)		;SET THE FID OF THIS FILE @ FQCLUS
.ASSUME	FQCLUS	EQ	FQDEVN+2
	ADD	#FQBUFL-FQCLUS,R4 ;INDEX TO: FQBUFL, FQMODE
	MOV	#512.,(R4)+	;SET DEFAULT BUFFER SIZE OF 1 BLOCK
	BIC	#OP$WLK,(R4)	;CLEAR THE "UNIT READ-ONLY" INDICATION
.ASSUME	FQMODE	EQ	FQBUFL+2
	TSTPRV	TUNE,@#FIPRVM	;Allowed to do tuning things?		;040
	BNE	60$		;Yes, so no mode pruning		;020
	BIC	#OP$CHE,(R4)	;Drop cache mode			;040
60$:	MOV	R4,-(SP)	;SAVE POINTER TO FIRQB @ FQMODE		;040

.DSABL	LSB

GLOBAL	<FIPUNT,UNTCNT,DSKLOG,FIPRVM>					;039

;	R0 =  UNIT * 2
;	R1 -> FCB (IF FILE OPEN) OR 0 or 1				;022
;	R3 =  LINK OF ENTRY or permanent file buffer pointer		;022
;	R4 -> FIRQB @ FQMODE
;		OP$WLK BIT CLEARED (WILL BE SET IF R/O UNIT)
;		MODES TO DROP ARE DROPPED
;	SP -> (0) POINTER TO FIRQB @ FQMODE
;	      (2) POINTER TO UNTCNT ENTRY
;	      (4) (POINTER TO SLOT IN IOB / 2) ! (100000 IF CREATE)

.ENABL	LSB

	CMP	R1,#1		;Is there an FCB already?		;022
	BLO	70$		;No, and no permanent file block either	;023
	BNE	30$		;Yes, there sure is			;027
	CALL	40$		;Get FCB, link it in			;022
	REGSAV			;Save some registers			;022
	MOV	R3,R4		;Copy permanent file list pointer	;022
	CALLX	MAPBUF		;Map that buffer			;022
	MOV	R3,R1		;Copy permanent file block pointer	;022
	CMP	R1,#140000	;APR6 pointer?				;022
	BLO	10$		;No					;022
	SUB	#20000,R1	;Yes, make APR5 pointer instead		;022
10$:	MOV	TOS.R4(SP),R3	;Get FCB pointer			;022
	MOV	@#DPAR6,R2	;Point to I/D PAR 6			;022
	MOV	(R2),R0		;Get current mapping			;022

	MOV	@#FPLAP6,(R2)	; and restore FIP mapping		;022
				;The above because of space shortages	;022
	MOV	#120000,R5	;Ready to check if buffer is in APR5	;045
	BIC	R3,R5		;Is buffer in APR5 (or 7 but that's bad) ;045
	BNE	20$		;Not an APR5 FIP pool buffer		;045
	MOV	@#OVRBUF,(R2)	;APR5, map APR5 FIP pool in APR6	;045
	INC	(R2)		;But offset into APR5 FIP pool by one sliver ;045
	ADD	#20000-100,R3	;Now convert the address virtually	;045
				;Note: The above is done since the length
				;      of APR6 is one sliver less than APR5
20$:	MOV	#40-2,R2	;Now set up byte count			;045
	TST	(R1)+		;Don't overwrite link word		;022
	CALLX	MOVMEM		;Copy permanent file block to FCB	;022
	REGRES			;Restore registers			;022
	MAP	FIPPOL		;And reset the mapping of FIP		;045
30$:	JMP	OPENX2		; and go to step 2			;022

40$:	CALLX	GETFIP		;GET FIP BUFFER FOR FCB (LEAVE 20. FREE)
	BCC	60$		;Got the FIP buffer, continue on	;025
	TST	6(SP)		;Oops, none to be had, doing a create?	;025
	BPL	50$		;NO, SKIP
	CALL	DELNEW		;Delete new file and return QTB (if any) ;042
50$:	ERROR	NOBUFS		;NO BUFFERS FOR AN FCB

60$:	MOV	R4,R1		;COPY FCB POINTER TO THE RIGHT REGISTER
	MOV	FCBLST(R0),(R4)+ ;POINT THE NEW FCB AT THE OLD LIST
	MOV	R1,FCBLST(R0)	; AND POINT THE LIST AT THIS FCB
	RETURN			;Done					;022

70$:	MOV	#OPNERX,@#FIPERX ;Set a FIP error exit			;033
	CALLX	RDE		;READ THE NAME ENTRY
	CLR	@#FIPERX	;Clear the FIP error exit		;033
	BITB	#US.OUT,USTAT(R5) ;CAN WE USE THIS THING?
	BEQ	80$		;Yes, go fetch an FCB			;025
	ERROR	PRVIOL		;No, issue protection violation		;025

80$:	CALL	40$		;Get FCB, link it in			;022
	BIC	#^C<UL.BLO!UL.CLO!UL.ENO>,R3 ;TRIM THE LINK WORD (CLEAR FLAGS)
	BIT	#UL.CHE,(R5)	;IS THIS FILE ALWAYS TO BE CACHED?
	BEQ	90$		;NO, SKIP
	BIS	#UL.CHE,R3	;YES, SO INDICATE AS FLAG IN LINK (FILE ID)
90$:	BIT	#UL.CHE,UAA(R5)	;IS THIS A SEQUENTIAL FILE?
	BEQ	100$		;NO, SKIP
	BIS	#UL.CLN,R3	;YES, SO INDICATE AS FLAG IN LINK (FILE ID)
100$:	MOV	R3,(R4)+	;SAVE LINK & CACHE FLAGS AS THE FILE ID
	MOV	(SP),R0		;GET THE POINTER TO FQMODE
	MOV	FQPPN-FQMODE(R0),(R4) ;SET PPN IN FCB
	BNE	110$		;IF PRESENT, USE IT
	MOV	@#FIUSER,(R4)	; ELSE USE CALLER'S PPN
110$:	CMP	(R5)+,(R4)+	;SKIP LINK IN NAME ENTRY, ADVANCE TO F$NAM
	MOV	R4,R0		;REMEMBER POINTER TO F$NAM
	MOV	(R5)+,(R4)+	;COPY THE NAME
	MOV	(R5)+,(R4)+	; TO THE FCB
	MOV	(R5)+,(R4)+	;  AND THE EXTENSION, TOO
	MOV	(R5),(R4)+	;COPY THE USTAT BITS AND PROTECTION CODE
	BIT	#US.UFD,(R5)+	;IS THIS A UFD OPEN?
	BEQ	120$		;NOPE
	CLR	(R0)+		;YES, THERE IS NO NAME
	CLR	(R0)+		; SO CLEAR IT
	CLR	(R0)+		;  ALL OUT
	BIC	#US.NOX,(R0)	;INDICATE NON-CONTIGUOUS "FILE"
120$:	CMP	(R5)+,(R4)+	;SKIP ACCESS COUNTS (THEY'RE 0 IN FCB)	;020
	MOV	(R5)+,R3	;GET LINK TO ACCOUNTING ENTRY
	MOV	(R5)+,-(SP)	;GET LINK TO R.E. OR UFD START DCN

GLOBAL	<FCBLST,FIUSER,DPAR6,FPLAP6,OVRBUF>				;045

	MOV	#OPNERR,@#FIPERX ;Set the FIP error exit		;025
	CALLX	RDE		;READ THE ACCOUNTING ENTRY
	MOV	UCLUS(R5),F$CLUS(R1) ;SET THE CLUSTER SIZE
	MOV	R4,R0		;COPY POINTER TO F$WFND
	CMP	(R0)+,(R0)+	;SKIP FBB OF R.E.
	MOV	F$FID(R1),R3	;GET LINK TO NAME ENTRY
	CALLX	PAKFBB		;BUILD AN FBB FOR NAME ENTRY
	MOVB	@#FIPUNT,(R0)+	;SET THE FIP UNIT NUMBER		;022
	.BR	OPENXX		;Continue on				;025

.DSABL	LSB

GLOBAL	<FIPUNT,FIPERX>							;025



;	R1 -> FCB
;	R2 =  MASK FOR LOCKS
;	SP -> (0) POINTER TO FIRQB @ FQMODE
;	      (2) POINTER TO UNTCNT ENTRY
;	      (4) (POINTER TO SLOT IN IOB / 2) ! (100000 IF NEWLY CREATED)

.ENABL	LSB								;022

OPENXX:	INC	R0		;Skip MSB size byte			;025
	MOV	(SP)+,R3	;RESTORE R.E. LINK OR UFD DCN
	BIT	#US.UFD,F$STAT(R1) ;IS THIS A UFD OPEN?
	BNE	20$		;YES, DO SPECIAL STUFF
	CMP	(R5)+,(R5)+	;SKIP TO FILE SIZE LSB
	MOV	(R5)+,(R0)	; AND SET IT IN THE FCB
	CMP	(R5)+,(R5)+	;NOW ADVANCE TO RTS NAME/MSB SIZE
	TST	(R5)+		;IS THIS MAYBE A LARGE FILE?
	BNE	10$		;NOPE, MSB SIZE IS ZERO
	MOVB	(R5),-(R0)	;YES, SET THE FILE SIZE MSB
10$:	MOV	R4,R0		;RESTORE POINTER TO R.E. FBB
	CALLX	PAKFBB		;BUILD FBB FOR RETRIEVAL ENTRY
	BR	OPENX2		;DONE WITH FCB

20$:	MOV	R3,R2		;GET UFD RETRIEVAL POINTER
	BEQ	10$		;IF NONE, SIZE IS 0 AND FBB IS NULL
	CALLX	READUF		; AND READ THE UFD
	MOVB	#760/2,(R4)+	;OFFSET/2 IS OFFSET FOR DIRECTORY MAP
	MOVB	R3,(R4)+	;FBN MSB IS DIRECTORY FBN
	MOV	R2,(R4)+	; AS IS FBN LSB
	MOV	#FIBENT,R5	;POINT TO THE DIRECTORY CLUSTER MAP
	MOV	#7,R4		;COUNT 7 RETRIEVAL POINTERS
30$:	TST	(R5)+		;IS THIS CLUSTER PRESENT?
	BEQ	40$		;NO, END OF MAP				;048
	ADD	F$CLUS(R1),(R0)	;YES, COUNT SIZE OF UFD
	SOB	R4,30$		;NO, TRY FOR MORE
40$:	CALLX	WRITEC		;Be sure FIBUF is written out		;048
	MOVB	#-1,@#FIBUNT	;And invalidate FIBUF			;048
OPENX2:	CLR	@#FIPERX	;Clear the alternate error exit		;025
	MOV	(SP),R0		;POINT TO FIRQB @ FQMODE		;019
	BIT	#UL.CHE,F$FID(R1) ;CACHE THIS FILE ALWAYS?		;019
	BEQ	50$		;NO, SKIP				;019
	BIS	#OP$CHE,(R0)	;YES, FORCE CACHING IN FIRQB		;019
50$:	BIT	#UL.CLN,F$FID(R1) ;IS THIS A SEQUENTIAL FILE?		;019
	BEQ	60$		;NO, SKIP				;019
	BIS	#OP$CSQ,(R0)	;YES, FORCE SEQUENTIAL IN FIRQB		;019
60$:	MOV	(SP),R0		;GET FQMODE POINTER AGAIN		;019
	MOV	R1,R5		;MAKE A WORKING COPY OF THE FCB POINTER
	ADD	#F$STAT,R5	;POINT TO FILE STATUS BITS
	MOVB	(R5),-(SP)	;COPY THE STATUS BYTE
	BITB	#US.UFD,(R5)+	;IS THE FILE A UFD?
	BEQ	80$		;NO
	REGSAV			;Save all registers			;040
	MOV	F$PPN(R1),R0	;Get account number from FQB		;040
	MOVB	(R5),R1		;Get UFD protection (always <60> in V9)	;040
.ASSUME	F$PROT EQ F$STAT+1						;040
	CALLX	CHKACC		;Get access flags			;040
	BIT	#DDRLO,R0	;Read locked out?			;040
	BNE	110$		;Yes, so no access to UFD		;040
	REGRES			;Restore registers			;040
	TSTPRV	WRTNFS,@#FIPRVM	;Allowed non-file-structured write?	;040
	BNE	70$		;Yes, so let it go			;020
	CLR	(R0)		;Force read-only UFD access		;020
70$:	COM	(R0)		;REVERSE BITS (WRITE UFD'S <-> R-O)	;020
	ASR	(R0)		;MOVE <14> (.NOT. WRITE UFD) TO <13> (R-O)
.ASSUME	OP$RO	EQ	OP$WUF/2
	BIC	#^C<OP$RO>,(R0) ;ISOLATE THE UFD OPEN MODE(S) TO R/O ONLY
80$:	BIT	#UC.WLO,@4(SP)	;IS THIS DISK WRITE LOCKED?
	BEQ	90$		;NO
	BIS	#OP$WLK!OP$RO,(R0) ;YES, INDICATE IT AND FORCE READ-ONLY MODE
90$:	CALLX	GETFIP		;NOW GET FIP BUFFER FOR WCB (LEAVE 20. FREE)
	BCC	160$		;CONTINUE IF BUFFERS AVAILABLE
	CALL	140$		;ELSE THEN RETURN THE FCB IF NECESSARY
	TST	6(SP)		;WAS THIS A CREATE?
	BPL	100$		;NO
	CALL	DELNEW		;Delete new file and return QTB (if any) ;042
100$:	ERROR	NOBUFS		;GIVE USER NO BUFFER SPACE ERROR	;033

110$:	CALL	140$		;NON-PRIV OPEN OF UFD, RETURN FCB
	ERROR	NOSUCH		;PRETEND WE CAN'T FIND THE FILE

120$:	MOV	2(SP),R1	;Pick up FIRQB @ FQMODE pointer		;027
	CMPB	FQFUN-FQMODE(R1),#LOKFQ ;Is this an open next?		;027
	BEQ	250$		;Yes, so just disallow all access	;027
	CALL	130$		;RETURN WCB AND FCB			;027
	ERROR	PRVIOL		;PRIVILEGE VIOLATION

; ERROR IN OPEN - UNLINK & RETURN BUFFERS

130$:	BUFFER	RETSML		;RETURN THE WCB
140$:	MOV	R5,R4		;COPY THE FCB POINTER
	BIC	#40-1,R4	; AND INDEX TO THE TOP
	TST	F$ACNT(R4)	;IS THE FILE OPEN?
	BNE	150$		;YES, DON'T RETURN THE FCB
	MOVB	@#FIPUNT,R1	;NO, THIS IS THE NEW FCB, SO GET UNIT
	ASL	R1		; TIMES 2
	MOV	(R4),FCBLST(R1)	;DELINK IT FROM THE LIST (IT'S FIRST)
	BUFFER	RETSML		;RETURN THE FCB
150$:	RETURN

GLOBAL	<FIPUNT,FIPRVM,FIPERX,FIBUNT>					;048

; GOT A WCB, START FILLING IT
;
;	R0 -> FIRQB @ FQMODE
;	R4 -> WCB
;	R5 -> FCB @ F$PROT

160$:	REGSAV			;Save registers for a bit		;020
	MOVB	(R5),R1		;Get protection code			;020
	MOV	F$PPN-F$PROT(R5),R0 ; and PPN				;020
	CALLX	CHKACC		;Check access rights to this file	;020
	BIC	#^C<DDWLO!DDRLO!DDAUX>,R0 ;Save lockout bits only	;026
	SWAB	R0		;Swap into low byte			;020
	MOV	R0,(R4)		;Store it away into the WCB		;020
	REGRES			;Restore registers			;020
	TST	6(SP)		;Was this a newly created file?		;022
	BPL	170$		;No, leave access rights alone		;022
	CLRB	(R4)		;Yes, force read-write rights		;022
170$:	MOV	#WC$SPU,R1	;BIT USED FOR CHECKING BELOW
	CMPB	FQFUN-FQMODE(R0),#RUNFQ ;Is this a .RUN open?		;026
	BNE	180$		;No					;026
	BIS	R1,(R4)		;Yes, assume no read access		;026
	BIT	#DDAUX/400,(R4) ;Execute lockout?			;026
	BNE	180$		;Yes, skip				;026
	BIC	R1,(R4)		;No, so allow "read" (i.e. execute)	;026
.ASSUME	WC$SPU	EQ	DDRLO/400
180$:	BIC	#DDAUX/400,(R4)	;Get rid of execute lockout bit		;026
	CMPB	(R5)+,#UP.RUN!UP.PRV ;Privileged program?		;026
	BLO	190$		;No, so continue			;026
	TSTPRV	TMPPRV,@#FIPRVM	;Allowed to mess with those?		;053
	BNE	190$		;Yes, go on				;020
	BIS	#DDWLO/400,(R4)	;No, so force read-only access to file	;020
190$:	MOVB	(SP),R3		;COPY THE STATUS BITS
	BPL	210$		;IF ALREADY DELETED, THIS IS A TENTATIVE
.ASSUME	US.DEL	EQ	200
	CMPB	FQFUN-FQMODE(R0),#LOKFQ ;Is this an open-next?		;035
	BNE	200$		;No, so this is a tentative open	;038
	BIS	#OP$RO,(R0)	;Open-next of deleted file, set RR mode	;038
	BR	210$		;And join up				;038

200$:	BIS	R1,W$WCB(R4) 	; SO SET THE TENTATIVE BIT IN THE WCB	;038
210$:	ASL	R1		;GET ANOTHER CONVENIENT BIT
.ASSUME	DDWLO	EQ	DDRLO*2
	MOV	(R0),R0		;GET THE USER MODE BITS
	BIT	R0,#OP$RO!OP$RR!OP$DUD ;DESIRE NO WRITE? (R-O OR R-R OR DUD) ;027
	BEQ	220$		;NO, KEEP IT IF IT IS THERE
	BISB	R1,(R4)		;YES, DROP WRITE PRIV'S (FORCE WRITE LOCK)

GLOBAL	<FIPUNT,FCBLST,FIUSER>

220$:	ASL	R1		;GET ANOTHER CONVENIENT BIT
.ASSUME	WC$UPD	EQ	DDWLO*2
	BIC	#^C<US.WRT>,R3	;ISOLATE THE 'WRITE ALREADY GIVEN' BIT
	BIC	#^C<US.UFD!US.NOX!US.UPD>,(SP) ;LEAVE ONLY UFD, CTG, UPDATE
.ASSUME	WC$UFD	EQ	US.UFD*400
.ASSUME	WC$CTG	EQ	US.NOX*400
.ASSUME	WC$UPD	EQ	US.UPD*400
	BIT	R0,#OP$RR!OP$NGA ;Read regardless or never grant access?   ;027
	BNE	240$		;Yes, go ignore the update flag
	ASR	R0		;DESIRE UPDATE MODE?
	BCC	260$		;NO, NORMAL FILE OPEN
.ASSUME	OP$UPD	EQ	1
	BMI	120$		;UPDATE MODE OPEN, ERROR IF UNIT WRITE LOCKED

; UPDATE MODE OPEN - CHECK FOR CONFLICTS

	BITB	R1,(SP)		;IS FILE ALREADY OPEN FOR UPDATE?
	BNE	230$		;IF SO THEN MORE UPDATERS CAN HAVE IT
	BISB	(R5),R3		;IF NOT, ANY OPEN(S) AND/OR WRITE GIVEN?
	BNE	120$		;YES, ONE OR BOTH, SO ERROR
230$:	BITB	#DDRLO/400,(R4)	;DID USER GET READ PRIVILEGES ?
	BNE	120$		;CANNOT UPDATE WITHOUT READ
	BISB	R1,(R4)		;ADD 'UPDATE' BIT FOR WCB (WC$UPD)
.ASSUME	WC$UPD	EQ	US.UPD*400
	BIC	#^C<OP$SPU/2>,R0 ;SPECIAL UPDATE MODE DESIRED?
	BIS	R0,W$WCB(R4)	;IF SO, SET IT
.ASSUME	WC$SPU	EQ	OP$SPU/2
	BR	270$		;MERGE, SETTING US.UPD IN F$STAT

; NORMAL MODE OPEN

240$:	BICB	R1,(SP)		;IGNORE ANY UPDATE MODE INDICATION
	BIT	#OP$NGA,R0	;Is this a never grant access open?	;027
	BEQ	260$		;No, must be read-regardless		;027
250$:	BISB	#<DDRLO!DDWLO>/400,(R4) ;Set read lock and write lock	;027
	CLR	R1		;Assure no extra bits in F$STAT		;027
	BIS	#OP$RR,@2(SP)	;Indicate that we need to update RR count ;027
	BICB	#WC$UPD/400,(SP) ;And be sure this isn't update mode	;031
	BR	270$		;And join up				;027

260$:	BITB	R1,(SP)		;NON-UPDATE OPEN. ALREADY OPEN FOR UPDATE ?
	BNE	120$		;YES, THAT IS AN ERROR
	BISB	R3,(R4)		;NOT UPD, WRITE LOCK IF US.WRT BIT ALREADY ON
.ASSUME	US.WRT	EQ	DDWLO/400
	CLR	R1		;ASSUME NO EXTRA FCB BITS
	CMPB	#DDWLO/400,(R4)	;DOES USER HAVE ANY PRIVILEGES NOW ?
	BLO	120$		;IF DDRLO!DDWLO ON, THEN SAY ERROR (NO PRIVS)
	BEQ	270$		;IF USER HAS NO WRITE PRIV'S, JUST CONTINUE
	BISB	#WC$USE/400,(R4) ; ELSE SET 'WRITE GIVEN' ON IN WCB
	MOV	#US.WRT,R1	;SET US.WRT IN F$STAT SINCE WRITE WAS GIVEN
270$:	BISB	(SP)+,(R4)	;.OR. EXTRA BITS (UFD,CTG,UPD) INTO WCB

.DSABL	LSB								;022

	GLOBAL	<FIPRVM>						;020

; ALL PATHS MERGE HERE.  NO MORE ERRORS ARE POSSIBLE

.ENABL	LSB

	BISB	R1,F$STAT-F$ACNT(R5) ;.OR. IN NEW STAT BITS (US.WRT OR US.UPD)
	MOV	R4,R1		;SHUFFLE WCB POINTER TO PROPER REGISTER
	MOV	R4,R0		; AND GET A WORKING COPY OF WCB POINTER
	MOV	(SP)+,R4	;MOVE THE FIRQB @ FQMODE POINTER TO ITS HOME
	SWAB	(R0)+		;STATUS INTO HIGH BYTE, DISK INDEX = 0 IN LOW
	MOVB	@#FIJOB,(R0)	;SET JOB NUMBER IN WCB
	ADD	#W$FCB-W$JBNO,R0 ;POINT TO FCB POINTER WORD
	MOV	R5,(R0)		;SAVE FCB POINTER
	ADD	#F$CLUS-F$ACNT,(R0) ; AND INDEX TO CLUSTERSIZE
	MOV	(R0)+,R3	;GET THE FCB @ F$CLUS POINTER
	CMP	(R0)+,(R3)+	;POINT TO W$WCB, F$WCB
.ASSUME	W$WCB EQ W$FCB+4						;019
.ASSUME	F$WCB EQ F$CLUS+2						;019
	MOV	(R3),-(SP)	;Get first WCB pointer and flags	;019
	BIC	#40-1,(SP)	;Get rid of flags			;019
	BIC	(SP),(R3)	;Leave only the flags in F$WCB		;019
	BIS	(SP)+,(R0)	;NEXT WCB IS PREVIOUS FIRST WCB		;019
	BIS	R1,(R3)		;FIRST WCB FOR FCB IS THIS ONE		;019
	BIT	#OP$AEX,(R4)	;ALWAYS DESIRED A "REAL" EXTEND?
	BEQ	10$		;NO
	BISB	#WC$AEX,(R0)	;YES, INDICATE SUCH
10$:	BIT	#OP$CHE,(R4)	;DO USER DATA CACHING?
	BEQ	20$		;NO
	BISB	#WC$CHE,(R0)	;YES, INDICATE SUCH
	BIT	#OP$CSQ,(R4)	;IF SO, IS IT SEQUENTIAL?
	BEQ	20$		;NOPE, LEAVE IT
	BISB	#WC$CSQ,(R0)	;YES, INDICATE SUCH

GLOBAL	<FLG.SY>

; Note: The cell FIPESP is used in a non-standard way below. It contains
; the pointer to the WCB for a file to be closed when doing an open next.
; If this isn't an open next, it contains a zero. If you change this routine
; (or the error trap at OPNER2), be aware of this!

20$:	TST	(R0)+		;POINT TO W$NXT FOR FBB
	COM	(R0)		;SET TO -1 (NONE) IN CASE NOTHING IS THERE
	MOV	#OPNER2,@#FIPERX ;Set the alternate FIP error exit	;025
	MOV	2(SP),R3	;Get the IOB pointer and create flag	;025
	ASL	R3		;Get only the IOB pointer		;025
	MOV	(R3),FIPESP	;Save possible current channel 		;027
	MOV	R1,(R3)		;Now link this WCB into the IOB		;025
	MOV	(R5),R3		;Pick up open count			;027
	MOV	#1,-(SP)	;Guess at fixing regular count		;027
	BIT	#OP$RR,(R4)	;'READ REGARDLESS' MODE?		;027
	BEQ	30$		;NO					;027
	SWAB	R3		;Yes, so count is in high byte		;027
	MOV	#400,(SP)	;SET TO ADD 1 TO HIGH BYTE		;027
	INC	-2(R0)		; AND INDICATE SPECIAL COUNT		;027
30$:	INCB	R3		;Can we open another file?		;027
	BNE	40$		;Yes, we sure can			;027
	ERROR	DTOOOF		;No, so give an error			;027

40$:	ADD	(SP)+,(R5)+	;COUNT ONE MORE FILE OPEN HERE		;027
	TST	(R5)		;IS THERE AN FBB FOR FIRST R.E.?
	BMI	70$		;NOPE, NO RETRIEVAL INFO
	CALLX	RFE		;READ THE FIRST RETRIEVAL ENTRY
	MOV	(R5)+,R3	;GET LINK TO NEXT R.E. (CLUSTERSIZE IF UFD)
	BIT	#WC$UFD,(R1)	;IS THIS A UFD?
	BEQ	50$		;IF NOT A UFD, USE THE LINK
	CLR	R3		;FOR UFD OPENS, THERE IS NO NEXT ENTRY
50$:	CALLX	PAKFBB		;BUILD FBB FOR SECOND RETRIEVAL ENTRY
	MOV	#7,R2		;SEVEN WORDS TO COPY
60$:	MOV	(R5)+,(R0)+	;COPY IN THE R.E.
	SOB	R2,60$		; UNTIL DONE
70$:	MOV	W$FCB(R1),R0	;POINT TO THE FCB AGAIN
	MOV	(SP)+,R2	;RECALL POINTER TO UNTCNT ENTRY
	TST	(SP)		;Newly created file?			;033
	BMI	90$		;Yes, CREATE took care of it		;033
	BIT	#WC$UFD,(R1)	;Is this a UFD?				;033
	BNE	90$		;Yes, then ignore this file		;033
	CMP	F$PPN-F$CLUS(R0),(PC)+ ;Account [0,1]?			;033
	 .BYTE	1,0							;033
	BEQ	90$		;Yes, no disk quota blockette		;033
	BIT	#UC.WLO,(R2)	;Unit write locked?			;033
	BNE	90$		;Yes, no need for quotas in memory	;033
	MOV	R2,R3		;Copy the UNTCNT entry pointer		;033
	SUB	#UNTCNT,R3	; and turn it into FUN * 2		;033
	CMP	UNTLVL(R3),(PC)+ ;Support extended quota data?		;033
	 .BYTE	2,1							;033
	BLO	90$		;No, then no QTB to create		;033
	MOV	R0,-(SP)	;Save the FCB @ F$CLUS pointer		;033
	MOV	R2,-(SP)	; along with the UNTCNT pointer		;033
	ADD	#F$PPN-F$CLUS,R0 ;Point at the PPN			;033
	MOV	#1.,R2		;Set the increment count		;033
	CALL	CREQTB		;Create a QTB for this PPN		;033
	MOV	(SP)+,R2	;Restore the UNTCNT pointer		;033
	MOV	(SP)+,R0	; and the saved FCB pointer		;033
	BCS	OPNER2		;return the WCB and FCB if create failed ;033
80$:	MAP	FIP,DATA	;Remap FIP				;033
90$:	ASL	(SP)		;GET THE NEWLY-CREATED FILE FLAG, FIX IOB ADDR
	MOV	#US.PLC,(SP)	;GET A HANDY BIT			;025
	BCC	100$		;NOT NEW, SO NO PLACEMENT STUFF
	MOV	FQNENT-FQMODE(R4),R5 ;NEW FILE, GET POSITION REQUESTED
	BEQ	100$		;NONE, SO NO PLACEMENT
	CMP	R5,W$WND(R1)	;DID IT GET PLACED APPROPRIATELY?
	BHI	100$		;NO, IT DIDN'T
	CALLX	RNE		;YUP, GET THE NAME ENTRY BACK
	BISB	(SP),USTAT(R5)	;INDICATE PLACED FILE
	BISB	(SP),F$STAT-F$CLUS(R0) ; IN BOTH PLACES
	MARK	FIBUF		;MARK THE BUFFER
100$:	BIT	(SP)+,(R4)	;ARE WE OPENING FOR APPEND?		;027
.ASSUME	OP$APP	EQ	US.PLC
	BEQ	110$		;NO
	MOV	R0,R3		;YES, COPY FCB POINTER
	MOV	-(R3),W$NVBL(R1) ;SET NEXT BLOCK TO FIRST NON-EXISTENT ONE
	MOVB	-(R3),W$NVBM(R1) ; TO EXTEND SOON
110$:	MOV	(R4)+,-(SP)	;Save the open mode one last time	;027
	BIT	#WC$UFD,(R1)	;IS THIS A UFD?
	BNE	130$		;IF SO, DON'T DATE IT
	CALLX	RNE		;NO, READ THE NAME ENTRY
	CALLX	RAE		;READ THE ACCOUNTING ENTRY FROM IT
	CMPB	FQFUN-FQFLAG(R4),#LOKFQ ;Is this open next?		;027
	BNE	120$		;No, so don't return date information	;027
	ADD	#UTC,R5		;Point to creation time			;027
	MOV	(R5),(R4)	;Now return creation time		;027
	BIC	#^C<UTC.TM>,(R4); and only the time			;065
	MOV	-(R5),-(R4)	;Now return creation date		;027
.ASSUME	UDC	EQ	<UTC-2>						;027
	TST	-(R5)		;Point to date of last access		;027
	MOV	-(R5),-(R4)	;Return date of last access		;027
.ASSUME	UDLA	EQ	<UDC-4>
	TST	-(R5)		;Now point back to start of name entry	;027
.ASSUME	UDLA	EQ	2
	ADD	#FQNENT-FQBUFL,R4 ;Now point to FQNENT in work block	;027
120$:	BIT	(R2),#UC.DLW!UC.WLO ;LAST WRITE AND/OR WRITE LOCKED OR UFD?
	BNE	130$		;YES, LET OTHERS SET THE DATE BIT
	MOV	#<DDWLO!DDRLO>,-(SP) ;Need to check for any access	;046
	BIC	(R1),(SP)+	;Access allowed?			;046
	BEQ	130$		;No, so no need to set dates at all	;046
	BIT	#OP$DUD,(SP)	;Don't update dates?			;046
	BNE	130$		;Yes, so forget it			;046
	CALLX	DATEIT		;GO SET DATE OF LAST ACCESS
130$:	TST	(SP)+		;Clean up the stack			;027
	CALLX	WRITEC		;WRITE IF NECESSARY
	CLR	@#FIPERX	;Clear the alternate FIP error exit	;025
	MOV	(R1),(R4)	;Return flags to the caller (FQFLAG or FQNENT)
	BIC	#^C<DDWLO!DDRLO>,(R4) ;TRIM ALL BUT LOCK BITS
	BIS	#FLG.SY,(R4)	; AND .OR. IN THE STANDARD BITS
	BIC	#37,R4		;Point to start of work block		;027
	ADD	#FQPFLG,R4	;Now point to where to return clustersize ;027
	MOVB	(R0),(R4)+	;SET CLUSTERSIZE FOR USER (256 => 0)
	MOVB	F$PROT-F$CLUS(R0),(R4) ;SET PROTECTION CODE OF FILE
	ADD	#FQSIZM-FQPROT,R4 ;NOW POINT TO MSB SIZE
	MOV	-(R0),FQSIZ-FQSIZM(R4) ;RETURN LSB SIZE
	MOVB	-(R0),(R4)+	; AND MSB SIZE
	MOV	F$PPN-F$SIZM(R0),(R4) ;RETURN THE ACTUAL PPN
	INC	(R2)		;COUNT AS ONE MORE OPEN FILE IN UNTCNT
	MOV	FIPESP,R1	;Get possible file to close		;027
	BEQ	140$		;None, that's good			;027
	SUB	#FQPPN,R4	;Close file, so point to start of work block ;027
	CLRB	FQFUN(R4)	;Indicate function is close		;027
.ASSUME	CLSFQ	EQ	0
	CALL	CLOSSY		;Now close this file (keep this a CALL!) ;027
140$:	RETURN			;AMEN, BROTHER. AMEN.

GLOBAL	<FIPUNT,FIPERX,UNTLVL,FIJBDA>					;037



OPNERR:	MOVB	@#FIPUNT,R1	;Get the Fip Unit Number		;025
	ASL	R1		;Make it FUN * 2			;025
	MOV	FCBLST(R1),R2	;Point to the just linked in FCB	;025
	BR	160$		; and go return it			;025

OPNER2:	MOV	@FIJBDA,R0	;Point to the IOB of FIJOB		;043
	MOV	FIQUE,R1	;Get the work block pointer		;043
	MOVB	FQFIL(R1),R1	;Get the channel # * 2			;025
	ADD	R1,R0		;Point into the IOB			;025
	MOV	(R0),R4		;Point to the WCB we created for this channel ;025
	MOV	W$FCB(R4),R2	;FCB @ F$CLUS				;025
	BIC	#37,R2		;Get back to the top of the FCB		;025
	MOV	W$WCB(R4),R3	;Pointer to the next WCB		;025
	BIC	#^C<37>,F$WCB(R2) ;Clear the old link pointer leaving any flags ;025
	BIC	#37,R3		;Clear out the flag bits		;025
	BIS	R3,F$WCB(R2)	;Make next into current			;025
	ADD	#F$ACNT,R2	;Point to the open count bytes		;025
	BIT	#WC$RR,W$WCB(R4) ;Are we RR				;025
	BEQ	150$		;No, so dec the low byte		;025
	INC	R2		;Point to the RR byte			;025
150$:	DECB	(R2)		; and lower the count			;025
	MOV	FIPESP,(R0)	;Put this channel back the way it was	;027
	BUFFER	RETSML		; and return the WCB			;025
	BIC	#37,R2		;Get back to the top of the FCB		;025
	MOVB	F$UNT(R2),R1	;Get the FUN from the FCB		;025
	ASL	R1		; and make it FUN * 2			;025
160$:	TST	@#QTCURR	;Do we have a QT buffer?		;033
	BEQ	170$		;No, then no QTB to return		;033
	MOV	R2,R0		;Yes, then copy the FCB ->		;033
	ADD	#F$PPN,R0	; and point to the PPN			;033
	MOV	R2,-(SP)	;Save the FCB ->			;066
	CALL	210$		;Go try to return the QTB entry		;033
	MOV	(SP)+,R2	;Restore the saved FCB ->		;066
170$:	TST	F$ACNT(R2)	;Is the file open?			;033
	BNE	180$		;Yes, don't return it			;025
	MOV	(R2),FCBLST(R1)	;Delink this FCB from the list		;025
	MOV	R2,R4		;Copy the FCB pointer			;025
	BUFFER	RETSML		; and return it				;025
180$:	CLR	@#FIPERX	;Don't come back here again		;025
	JMPX	FIEXIT		; and quit, returning the error to the user ;025

OPNERX:	CALL	200$		;Return the QTB (if any)		;042
	BR	180$		;Exit returning the error to the user	;042

GLOBAL	<FIPUNT,FCBLST,FIJBDA,FIPERX,QTCURR,FIQUE>			;043


;+									;042
;	DELNEW - Delete the newly created file and return the QTB	;042
;									;042
;	Inputs:								;042
;		R3 = Link to N.E. entry					;042
;		FIPUNT = Unit						;042
;		FIBUF has any block of directory			;042
;									;042
;	Outputs:							;042
;		Registers are NOT saved					;042
;		FIP private error trap (FIPERX) is cleared
;-

DELNEW::MOV	#190$,@#FIPERX	;Return back to us if XFL3 fails	;033
	MOV	SP,@#FIPESP	;Remember our current stack pointer	;033
	CALLX	XFL3		;Delete that just created file		;033
190$:	MOV	@#FIPESP,SP	;Reset the saved stack pointer		;033
	CLR	@#FIPERX	;Clear the FIP error exit		;033
200$:	TST	@#QTCURR	;Do we have a QT buffer			;042
	BEQ	220$		;No, then no QTB entry to return	;033
	MOV	@#FIQUE,R0	;Get the user's FIRQB			;033
	ADD	#FQPPN,R0	; and point to the PPN			;033
210$:	MOV	#1.,R2		;Set the decrement count		;052
	CALL	RETQTB		;Return the QTB entry			;033
220$:	RETURN			; and back we go			;033

GLOBAL	<FIPERX,FIPESP,QTCURR,FIQUE>					;042

.DSABL	LSB

.SBTTL	INIT FOR CHANNEL OPERATIONS					;036+

;+
; INI - INIT FOR CHANNEL OPERATIONS.
;
;	R4 -> FIRQB
;		FQFIL = CHANNEL NUMBER TIMES 2
;
;	CALL	INI
;
;	R1 -> WCB/SCB/DDB
;	R5 -> CHANNEL SLOT IN THE IOB
;
;	IF Z=0 THEN OPEN CHANNEL
;	IF Z=1 THEN CHANNEL IS CLOSED
;-

.ENABL	LSB

INI:	MOVB	FQFIL(R4),R5	;GET CHANNEL NUMBER TIMES 2
	BIT	R5,#^C<15.*2>	;VALID?
	BNE	10$		;NO, ERROR
	ADD	@FIJBDA,R5	;NOW POINT TO THE I/O BLOCK ENTRY
	MOV	(R5),R1		;NOW GET THE WCB/SCB/DDB ADDRESS
	;BEQ			;IF ZERO, THEN CHANNEL NOT OPEN (Z=1)
	;BNE			;CHANNEL OPEN (Z=0)
	RETURN			;EXIT

10$:	ERROR	BSERR		;ILLEGAL I/O CHANNEL

GLOBAL	<FIJBDA>							;036-

.SBTTL	NFS DISK OPENER

;	R0 -> FIRQB @ FQPPN
;	R1 -> UNTCNT TABLE ENTRY
;	R2 =  UNIT TIMES 2
;	R3 -> JDB
;	R4 -> FIRQB
;	R5 -> IOB ENTRY

OPENNF:	ASR	R2		;NFS OPEN, GET FIP UNIT * 1
	MOV	R2,@#FIPUNT	;STASH IT
	ASL	R2		;MAKE IT * 2 AGAIN
	ADD	#FQDEVN,R4	;NFS, INDEX TO DEVICE NUMBER IN FIRQB
	TST	(R4)+		;DID USER SPECIFY GENERAL DISK?
	BEQ	80$		;YES, SO CALL IT AN ERROR
	TSTPRV	RDNFS,@#FIPRVM	;Privileged to read NFS disk?		;040
	BEQ	80$		;No, error				;020
	MOV	#OP$RO,(SP)	;INITIALLY SET NO WRITE ACCESS
	TSTPRV	WRTNFS,@#FIPRVM	;Allowed NFS write access?		;040
	BEQ	20$		;No, so skip				;020
	CLR	(SP)		;Yes, so indicate it's allowed		;020
20$:	CMP	(R1),#UC.MNT	;CHECK UNIT'S STATUS			;020
	BEQ	50$		;Not mounted, so ok			;020
	BHI	70$		;NEVER MOUNTABLE, ERROR
	BIT	#UC.NFS,(R1)	;NFS disk?				;020
	BNE	25$		;Yes, so check ownership match		;058
	BIT	#OP$INI,FQMODE-FQCLUS(R4) ;No, mounted disk, initialize mode? ;049
	BNE	80$		;Yes, so forget it			;049
25$:	TSTPRV	SYSMOD,@#FIPRVM	;Allowed to write mounted disks?	;058
	BEQ	28$		;No, Force Read only			;060
	BIT	#OP$WUF,FQMODE-FQCLUS(R4) ;Do they want to write?	;060
	BNE	30$		;Yes, so let them			;060
28$:	MOV	#OP$RO,(SP)	;No, so force read-only			;020
30$:	TSTB	UNTOWN(R2)	;Shared disk?				;020
	BEQ	50$		;Yes, so proceed			;020
40$:	CMPB	@#FIJOB,UNTOWN(R2) ;YES, IS THIS THE OWNER??		;020
	BNE	80$		;NOT THE OWNING JOB			;020
50$:	TST	(R1)		;Mounted?				;042
	BPL	60$		;Yes, no need to auto size		;042
.ASSUME	UC.MNT	EQ	100000						;045
	CALLX	AUTOSZ		;Initialize size			;024
60$:	MOV	R4,R3		;SAVE FIRQB ADDRESS IN R3		;042
	CALLX	GETFIP		;THEN GET FIP BUFFER FOR WCB (LEAVE 20. FREE)
	BCC	90$		;ALL GOTTEN
	ERROR	NOBUFS		; ELSE ERROR

70$:	ERROR	NOTAVL		;DISK UNIT IS DISABLED

80$:	ERROR	PRVIOL		;ERROR

GLOBAL	<FIPUNT,FIJOB,UNTOWN,FIPRVM>

90$:	MOV	R4,(R5)		;SET ADDRESS IN IOB
	CLRB	-(R0)		;SET HIGH ORDER SIZE TO ZERO
	MOVB	DEVCLU(R2),R0	;GET DEVICE CLUSTER SIZE
	TST	(R1)		;MOUNTED NOW?
	BPL	100$		;YES
	MOV	#UC.NFS,(R1)	;NO, SO MOUNT AS NFS
	MOV	R0,UNTCLU(R2)	;  SET CLUSTER SIZE (No owner)		;024
	CLR	UNTOPT(R2)	;   and no options			;024
	CLR	UNTERR(R2)	;    and no errors			;024
100$:	BIT	#UC.WLO,(R1)	;Write-locked?				;020
	BEQ	110$		;No					;020
	BIS	#OP$RO,(SP)	;Yes, force read-only			;020
110$:	INC	(R1)		;ONE MORE OPEN FILE ON UNIT
        MOV     MID$XX(R2),(R3) ;No file ID, so put Massbus ID here     ;063
	BIS	#377*400,-(R3)	;INDICATE SPECIFIC UNIT FOR SURE
	TST	-(R3)		;BACK UP POINTER
	MOV	R0,-(R3)	;SET CLU=DCS AND NO PROTECTION CODE
	MOV	#FLG.SY,-(R3)	;SET PROTOTYPE BITS FOR USER
	MOV	#DDWLO!DDNFS,R5	;SET UP CORRECT WCB BITS HERE
	BIS	-(R3),(SP)	;.OR. MODE INTO WRITE ACCESS INDICATOR
	BIT	#OP$INI,(SP)	;NFS INITIALIZE MODE SPECIFIED?
	BEQ	120$		;NO
	CMP	FQDEV-FQMODE(R3),#"DV ;Opening the virtual disk?	;043
	BEQ	120$		;Yes, don't allow DSKINT mode		;043
	BIS	#UO.INI,UNTOPT(R2) ;Yes, set "Initializing" status bit	;024
120$:	BIT	#OP$RO,(SP)	;ALLOWING WRITE?
	BNE	130$		;NOPE
	BIC	#DDWLO,R5	;YEP, SO ALLOW IT
	BIT	#UC.NFS,(R1)	;NFS disk?				;020
	BEQ	130$		;No, so don't set UC.WLO		;020
	BIT	#UC.PRI,(R1)	;PRIVATE NFS DISK?			;041
	BEQ	130$		;YES, NEVER TURN ON WRITE LOCK
	BIS	#UC.WLO,(R1)	;NO, MARK UNIT AS WRITES GIVEN OUT
	BIS	#WC$USE,R5	; AND SAY THIS CALLER DID IT
130$:	MOV	R5,(R4)+	;NOW SET BITS IN THE WCB, ADVANCE POINTER
.ASSUME	WC$USE	EQ	FLGRND
	BIS	R5,FQFLAG-FQMODE(R3) ;.OR. FLAGS INTO THE FIRQB
	MOV	R0,-(R3)	;SET DCS FOR USER IN FQBUFL
	SWAB	(R3)		; TIMES 512 GIVES
	ASL	(R3)		;  BUFFER SIZE
	MOVB	@#FIJOB,(R4)+	;SET THE JOB NUMBER IN THE WCB
	MOV	UNTSIZ(R2),R2	;GET THE DEVICE SIZE IN DC'S
	MOV	R2,-(R3)	; AND FOR USER TOO
	MOV	R3,R5		;COPY THE FIRQB POINTER
	CALLX	CNVDCN		;CONVERT SIZE IN DC'S TO MAX FBN = DEVICE SIZE
	COM	(SP)		;INVERT SENSE OF MODE BITS
	ROLB	(SP)+		;SET CARRY IF HE WANTED NFS BY CLUSTERS
	RORB	(R4)+		; AND USE IT AS CLUSTER MODE FLAG
.ASSUME	WC$NFC	EQ	200
	BMI	140$		;DONE IF CLUSTER MODE
	INC	W$NVBL-W$PR(R4)	;START BLOCK MODE TRANSFER AT FBN 1	;041
	MOVB	R3,FQSIZM-FQSIZ(R5) ;RETURN SIZE IN FIP BLOCKS MSB
	MOV	R2,(R5)+	; AND LSB
	MOV	#512.,(R5)	;BUFFER SIZE FOR BLOCK MODE IS 1 BLOCK

GLOBAL	<DEVCLU,UNTERR,UNTOPT,UNTCLU,FIPRVM,FLG.SY,UNTSIZ,MID$XX>	;063

140$:	ADD	#F$CLUS-W$PR,R4	;POINT TO AREA FOR FAKE FCB INSIDE WCB	;032
	MOV	R4,W$FCB-F$CLUS(R4) ;POINT TO IT IN WCB
	MOV	R0,(R4)		;SET THE CLUSTER SIZE AS DCS
	MOV	R2,-(R4)	;SET UP F$SIZL
	MOVB	R3,-(R4)	; AND F$SIZM
	MOVB	@#FIPUNT,-(R4)	;SET UP FIP UNIT NUMBER
	RETURN			;EXIT

.DSABL	LSB

GLOBAL	<FIPUNT>

	.SBTTL	Create a GFD entry

	.ENABL	LSB

;+
; CREGFD - GFD ENTRY DOES NOT EXIST SO MUST CREATE ONE
;
;			R0 =  unused
;			R1 =  unused
;			R2 =  CLUSTERSIZE
;			R3 =  link
;			R4 =  FIRQB
;			R5 -> ENTRY
;
;			FIPCLU = The previous link to link it into.
;			FIPUNT = FIP UNIT #
;
;			output
;
;			R* = See CREMFD
;			GFD created or error
;-

CREGFD:	MOV	#^RGFD,@#TYPCRE	;CREATING "GFD" THIS TIME
	MOV	R0,-(SP)	;Save the Fip Unit Number
	MOV	R2,-(SP)	;SAVE CLUSTERSIZE FOR LATER
	MOV	@#FIBMAP,R0	;SAVE THE MFD'S CLUSTERSIZE
	MOV	@#FIBENT,R2	;GET THE DCN OF THE MFD
	CALLX	CNVDCN		;CONVERT DCN INTO A FBN
	ADD	#1,R2		;GET THE GFD POINTER BLOCK
	ADC	R3		;REALLY GET THE RIGHT FBN
	CMPB	FIPUNT,SATUNT	;Is a block of this disk in SATBUF?	;055
	BNE	8$		;No, not this time, that's easy		;055
	CMPB	R3,SATFBN	;Yes, does the MSB match?		;055
	BNE	8$		;No, so nothing special to do		;055
	CMP	R2,SATFBN+F.FBNL ;Yes, how about LSB matching?		;055
	BNE	8$		;No, nothing special to do		;055
	CALLX	WOMSAT		;Be sure SATT is written out (just in case) ;055
	MOVB	#-1,SATUNT	;And invalidate SATBUF			;055
8$:	CALLX	READ		;NOW, READ IT IN
	MOV	R0,R2		;AND USE THIS CLUSTERSIZE (THE MFD'S)
	MOV	R4,R0		;COPY THE FIRQB POINTER
	ADD	#FQPPN,R0	; AND POINT TO THE PPN
	CMPB	#255.,(R0)	;CREATE GFD? (CAN ONLY COME FROM UU.PAS)
	BNE	10$		;NO, SO USE THE DEFAULT CLUSTERSIZE
	MOV	(SP),R2		;RECOVER THE REQUESTED CLUSTERSIZE
	BIS	#100000,R2	;SET THE SIGN BIT IN THE CLUSTERSIZE
10$:	MOV	R2,@#FIPMUC	;SET THE CLUSTERSIZE TO CREATE AT
	MOV	(R0),-(SP)	;SAVE THE REAL PPN
	MOVB	#255.,(R0)	; AND CHANGE IT TO THE GFD PPN
	CLR	R1		;START WITH A CLEAR GROUP NUMBER
	BISB	1(R0),R1	;GET THE GROUP NUMBER
	ASL	R1		;AND MAKE IT *2
	ADD	#FIBUF,R1	;MAKE IT A POINTER TO THE DCN WORD
	SEC			;SET FLAG TO SAY NO MFD ENTRY REQUIRED
	CALL	100$		;TO GO CREATE THE GFD
	MOV	(SP)+,FQPPN(R4)	; AND RESTORE THE REAL PPN
	MOV	#^RUFD,@#TYPCRE	;SAY "UFD" FOR NEXT TIME
	MOV	@#FIBENT,R2	;GET THE GFD'S DCN
	CALLX	CNVDCN		;AND MAKE IT AN FBN
	ADD	#1,R2		;GO ONTO THE NEXT BLOCK (DCN TABLE)
	ADC	R3		;DOUBLE INTEGER NEXT BLOCK
	MOV	#FIBUF,R0	;POINT TO THE BUFFER, TO CLEAR IT OUT
20$:	CLR	(R0)+		;CLEAR OUT FIBUF FOR A WRITE
	CMP	R0,#FIBUF+1000	;IS IT ALL CLEAR
	BLO	20$		;GO CLEAR MORE OF IT
	MOV	R2,@#FIBFBN+F.FBNL ;SET UP TO DO THE WRITE
	MOV	R3,@#FIBFBN	;SET IT UP ALL THE WAY FOR THE WRITE
	CALLX	WRITE		;WRITE THE DCN TABLE OUT
	ADD	#1,@#FIBFBN+F.FBNL ;NOW, GO ONTO THE NAME -> TABLE
	ADC	@#FIBFBN	;AND DO A DOUBLE INTEGER ADD
	MARK	FIBUF		;NOW, MARK IT FOR WRITE
	SUB	#1,R2		;GET BLOCK 1 OF THE GFD INTO THE BUFFER
	SBC	R3		;BECAUSE WE NEED THE CLUSTER MAP
	CALLX	READ		;AND DO THE READ
	MOV	(SP)+,R2	;NOW, USE THE REQUESTED CLUSTER SIZE
	MOV	(SP)+,R0	;Restore the Fip Unit Number		;030
	CMPB	FQPPN(R4),#255.	;DID THEY REQUEST TO CREATE THE GFD??
	BNE	DOCRE		; NO, SO GO CREATE THE UFD
	RETURN			;YES, SO DON'T DO ANY MORE.

GLOBAL	<FIPCLU,TYPCRE,FIPUNT,SATUNT,SATFBN>				;055

	.SBTTL	Create a UFD entry

;+
; CREUFD		PPN IS IN MFD, WE MUST CREATE UFD ON OUTPUT DISK
;	
; Inputs:		R0 =  FIP unit number of the output disk
;			R1 =  Flag indicating specific or general disk search.
;			R2 =  Not used
;			R3 =  Link of entry
;			R4 -> FIRQB
;			R5 =  Entry
;
; Calling convention:	CALL	CREUFD
;
; Outputs:		R0 =  FIP unit number
;			R1 =  Random
;			R2 =  A.E. link pointer
;			R3 =  Random
;			R4 -> FIRQB
;			R5 =  Same as passed
;-

CREUFD:	MOV	@#FIPCLU,R1	;SAVE POINTER TO UAR IN MFD NAME ENTRY
	MOV	#^RUFD,@#TYPCRE	;MAKE SURE WE CREATE THE CORRECT TYPE
	MOV	R0,@#FIPUNT	;Restore the FIP unit number
	SEC			;SET C=1 TO FLAG PPN ALREADY IN MFD
	BR	100$		;NOW CREATE THE UFD

	GLOBAL	<FIPCLU,FIPUNT,TYPCRE>

	.SBTTL	Create a MFD entry

;+
; CREMFD		PPN NOT IN MFD OF TARGET DISK, ERROR (PRIVATE) OR
;			ENTER IT (PUBLIC)
;
; Inputs:		R0 =  FIP unit number of the output disk
;			R1 =  Flag indicating specific or general disk search.
;			R2 =  Pack clustersize of FIPUNT
;			R3 =  Link of entry
;			R4 -> FIRQB
;			R5 =  Entry
;
; Assumptions:		FIBUF has any block of the directory
;
; Calling convention:	FCALL	CREMFD
;
; Outputs:		R0 =  FIP unit number
;			R1 =  Random
;			R2 =  A.E. link pointer
;			R3 =  Random
;			R4 -> FIRQB
;			R5 =  Same as passed
;-

;
;	Error exit points
; 

30$:	TST	R1		;Did we create a quota blockette?	;030
	BEQ	40$		;No, then none to return		;030
	MOV	R1,R3		;Yes, then copy the link pointer	;030
	CALLX	RDE		;Read the blockette			;030
	CALLX	ZDE		; and return it				;030
40$:	MOV	R2,R3		;Set the Account entry link in R3	;024
	CALLX	RDE		;READ THE ACCOUNT ENTRY
	CALLX	ZDE		;MAKE IT A HOLE AGAIN
50$:	ERROR	NOROOM		;ANNOUNCE THE ERROR

60$:	ERROR	PRIVAT		;PRIVATE PACK ERROR

70$:	ERROR	NOSUCH		;NO PPN FOUND ERROR

CREMFD::MOV	R0,@#FIPUNT	;Restore the FIP unit number.
	TST	R1		;CHECK THE VALUE OF R1 NOW
	BNE	60$		;IF NON-ZERO, THEN PRIVATE PACK ERROR
	CMP	R2,@#FIPU0C	;IS PACK CLUSTER > SYSTEM UFD CLUSTER?
	BHI	80$		;YES, USE THE PACK CLUSTER SIZE FOR THIS UFD
	MOV	@#FIPU0C,R2	;NOPE, SO USE USER'S SYSTEM DISK UFD CLUSTER
	BMI	70$		;NO UFD ON SYSTEM DISK! GIVE ERROR
80$:	CMP	R2,#16.		;Did we end up with a HUGE clustersize?	;067
	BLOS	82$		; NO, so life is fine (smell the roses)	;067
	MOV	#16.,R2		; Yes, reset to max (just carnations)	;067
82$:	ASL	R0		;MAKE IT FUN * 2
	TST	UNTLVL(R0)	;CAN THIS DISK STAND GFD'S?? (NEW?)
	BEQ	87$		; NO, SO ENTER THE ACCOUNT IN THE MFD	;059
	CMPB	LSTFUN,FIPUNT	;Was last directory lookup on this FIP unit? ;055
	BNE	85$		;No, it certainly wasn't		;055
	MOVB	#-1,LSTFUN	;It was, so invalidate the context cells ;055
85$:	CMP	@#FIBENT,MFDPTR(R0) ;ARE WE STILL IN THE MFD?
	BNE	87$		;No, in the GFD, create that UFD now	;059
	JMP	CREGFD		;Yes, so go create the GFD		;055

87$:	MOV	#^RUFD,TYPCRE	;We are creating a UFD now		;059
DOCRE:	CALLX	GDE		;GET A DIRECTORY ENTRY FROM THE MFD/GFD
	BCS	50$		;IF NO ROOM, THEN TELL HIM
	INC	(R5)		;MARK THIS AS THE ACCOUNTING BLOCK
.ASSUME	UL.USE	EQ	1
	MOV	R2,UCLUS(R5)	;SET UFD CLUSTER SIZE
	MOV	R2,@#FIPMUC	;SET CLUSTER SIZE FOR ALLOCATE
	MOV	R3,R2		;SAVE THE LINK TO THE A.E.
	CLR	R1		;Say no quota blockette			;030
	CMP	UNTLVL(R0),(PC)+ ;Version 9.0 or newer disk structure?	;030
	.BYTE	2,1							;030
	BLO	90$		;No, then no quota blockette		;030
	CALLX	GDESV		;Yes, get an entry for the quotas	;030
	BCS	40$		;If no room, then kill the A.E.		;030
	CLR	(R5)+		;Clear the link word			;030
	MOV	#AA.QUO,(R5)+	;Set the type code			;030
	MOV	#-1,(R5)	;Unlimited logged-out quota (LSB)	;030
	MOV	(R5)+,(R5)	; and Logged-in quota (LSB)		;030
	MOV	(R5)+,(R5)	; and same for the MSB portion of both	;030
	MOV	R3,R1		;Save the link pointer			;030
90$:	CALLX	GDESV		;NOW GET THE NEW NAME ENTRY
	BCS	30$		;If no room, return whatever we created	;030
	MOV	R1,(R5)+	;Set the link to the attributes (if any) ;030
	MOV	FQPPN(R4),(R5)+	; AND SET THE PPN OF THIS FILE
	CMP	(R5)+,(R5)+	;SKIP THE PASSWORD SECTION
	MOV	(PC)+,(R5)+	;SET NORMAL PROTECTION AND UFD
	 .BYTE	US.UFD!US.NOK!US.NOX,UP.WPW!UP.RPW!UP.WPG!UP.RPG
	CLR	(R5)+		;CLEAR ACCESS COUNTER
	MOV	R2,(R5)+	; AND SET LINK TO ACCOUNTING ENTRY
	MOV	R5,R1		;SAVE POINTER TO UAR IN MFD NAME ENTRY
	;CLC			;SET C=0 TO INDICATE CREATION NECESSARY 
	;CLR	(R5)		;SAY ACCT HAS NO UFD YET (CLEAR FROM GDE)

GLOBAL	<FIPUNT,FIPCLU,FIBFBN,FIPU0C,FIPMUC,UNTLVL,MFDPTR,LSTFUN>

100$:	MOV	@#FIBFBN+F.FBNL,-(SP) ;SAVE BLOCK OF THIS NEW ENTRY
	MOV	@#FIBFBN,-(SP)	; (BOTH WORDS)
	BCS	130$		;NOT A NEW ENTRY, SO CONTINUE
	MOV	R3,-(SP)	;SAVE LINK TO THIS NEW MFD ENTRY
	TST	@#FIBMAP	;IS THIS A NEW STYLE MFD/GFD
	BPL	110$		;NO, SO DO IT THE OLD WAY
	MOV	@#FIBENT,R2	;GET THE FIRST DCN OF THIS GFD
	CALLX	CNVDCN		;CONVERT IT INTO THE FBN
	ADD	#2,R2		;POINT TO THE NAME POINTER TABLE
	ADC	R3		;AND REALLY POINT THERE
	CALLX	READSV		;READ THIS BLOCK INTO FIBUF
	CLR	R5		;START WITH A CLEAR PROG #
	BISB	FQPPN(R4),R5	;GET THE PROGRAMMER NUMBER
	ASL	R5		;MAKE IT THE PROG *2
	MOV	(SP)+,FIBUF(R5)	;PUT THE LINK INTO THE LINK MAP AREA
	BR	120$		;AND CONTINUE INLINE

110$:	MOV	@#FIPCLU,R3	;GET MFD LAST LINK (FROM "RUF")
	CALLX	RDESV		; AND READ THE LAST ENTRY IN MFD
	BIS	(SP)+,(R5)	;LINK NEW ENTRY INTO MFD CHAIN
120$:	CALLX	WRITE		;FORCE WRITE OF THIS BUFFER

130$:	CALLX	GDECR		;CREATE A UFD AND GET A ENTRY
	BCS	50$		;NO ROOM ERROR
	MOV	R3,R0		;SAVE A.E. LINK
	MOV	(SP)+,R3	;RESTORE MFD FBN (MSB)
	MOV	(SP)+,R2	;RESTORE MFD FBN (LSB)
	MOV	R0,-(SP)	;SAVE A.E. LINK FOR MAIN CODE (In CREATE).
	MOV	@#FIPUNT,R0	;Pass the FIP unit number.
	MOV	R5,-(SP)	; Save some registers to
	MOV	R1,-(SP)	;  use as scratch.
	MOV	@#FIBENT,-(SP)	;GET START DCN OF THE NEW UFD
	MOV	FQPPN(R4),@#FIBUF+LPPN ;SET THE PPN AND
	MOV	@#TYPCRE,@#FIBUF+LID ; "UFD" INTO UFD'S LABEL ENTRY
	CMP	FQPPN(R4),@#PPNTBL ;IS THIS THE LIBRARY PPN?
	BNE	140$		;NO, SO DON'T STUFF THE UNTLIB TABLE
	ASL	R0		;MAKE IT FUN * 2 FOR A LITTLE WHILE
	MOV	(SP),UNTLIB(R0)	; AND SET LIBRARY UFD STARTING DCN
	ASR	R0		;MAKE IT THE FUN * 1 AGAIN
140$:	CMPB	R0,@#SYSUNT	;IS IT THE SYSTEM DISK?
	BNE	170$		;NO
150$:	MOV	R0,-(SP)	;Get a work register			;054
	CLR	R0		;And get ready to look at all jobs	;054
160$:	TST	(R0)+		;Advance to the next job		;054
	MOV	JOBTBL(R0),R5	;Pick up job data block pointer		;054
	BEQ	160$		;NONE, LOOP
	CMP	R5,#-1		;ONE, THE END?
	BEQ	165$		;YES, DONE
	MOV	JDJDB2(R5),R5	;ELSE GET JOB'S JDB2 POINTER
	CMP	FQPPN(R4),J2PPN(R5) ;SAME PPN?
	BNE	160$		;NO, LOOP
	CALLX	MAPJCR		;Found one, map the JCR entry		;054
	MOV	FIBENT,JCUFDR(R1) ;Set up the UFD pointer		;054
	BR	160$		;And loop				;054

165$:	MOV	(SP)+,R0	;Restore FIP unit number		;054
	MAP	FIPPOL		;And restore FIP pool mapping		;054
170$:	CALLX	READSV		;NOW READ THE MFD
	MOV	(SP)+,R2	;RESTORE UFD START DCN
	MOV	(SP)+,R1	; Word in MFD name entry for DCN
	MOV	R2,(R1)		; AND STASH IT IN THE MFD NAME ENTRY
	TST	@#FIBMAP	;IS THIS A NEW STYLE MFD/GFD??
	BPL	180$		;NO, SO JUST CONTINUE NOW
	CMPB	FQPPN(R4),#255.	;IS THIS ONE A GFD CREATE
	BEQ	180$		;YES, SO JUST QUIT HERE
	MOV	R2,-(SP)	;SAVE THE REAL UFD'S DCN NUMBER
	MOV	@#FIBENT,R2	;GET THE FIRST DCN OF THIS GFD
	CALLX	CNVDCN		;CONVERT IT INTO THE FBN
	ADD	#1,R2		;POINT TO THE NAME POINTER TABLE
	ADC	R3		;AND REALLY POINT THERE
	CALLX	READSV		;READ THIS BLOCK INTO FIBUF (WRITES 1ST)
	CLR	R5		;START WITH A CLEAR PROG #
	BISB	FQPPN(R4),R5	;GET THE PROGRAMMER NUMBER
	ASL	R5		;MAKE IT THE PROG *2
	MOV	(SP),FIBUF(R5)	;STORE THE DCN INTO THE POINTER TABLE
	MOV	(SP)+,R2	;NOW, GET THE REAL ONE TO READ BACK
180$:	MARK	FIBUF		;INDICATE A CHANGE
	CALLX	READUF		;READ IN THE FIRST UFD BLOCK AND RETURN
	MOV	(SP)+,R5	; Restore the Pointer to the entry.
	MOV	(SP)+,R2	;Pass the A.E. link back.
	RETURN

GLOBAL	<FIBENT,FIBUF,SYSUNT,PPNTBL,SYSUN2,UNTLIB,JOBTBL,TYPCRE,FIBMAP>

	.DSABL	LSB


.SBTTL	RUN A BINARY FILE

;+
; RUNFQ - RUN A BINARY FILE.
;
;	R4 -> FIRQB
;		FQFIL    =  15. TIMES 2
;		FQPPN    =  PPN (0=>SELF)
;		FQNAM1   =  FILE NAME (2 WORDS)
;		FQEXT    =  EXTENSION OR -1 FOR EXTENSION SEARCHING
;		FQSWIT   <=0 => NORMAL RUN
;		          >0 => .CHAIN TYPE RUN
;		FQMODE   =  130000
;		FQDEV,FQDEVN = DEVICE TO USE (0=>PUBLIC)
;
;	OPEN MODE BITS FORCED FOR RUNS:
;
;	 10000	 4096.	12	ALWAYS READ NORMAL MODE
;	 20000	 8192.	13	READ-ONLY MODE
;	100000	32768.	15	MODE IS "REAL" INDICATOR
;
;	IN FIRQB ON RETURN
;		FQFIL    =  15. TIMES 2
;		FQSIZM   =  0
;		FQPPN    =  PPN
;		FQNAM1   =  FILE NAME (2 WORDS)
;		FQEXT    =  EXTENSION
;		FQSIZ    =  FILE SIZE
;		FQBUFL   =  DEFAULT BUFFER SIZE
;		FQMODE   =  130000
;		FQFLAG   =  FILE FLAGS
;		FQPROT-1 =  FILE CLUSTER SIZE (MOD 400)
;		FQPROT   =  PROTECTION CODE
;		FQDEV,FQDEVN = PHYSICAL DISK DEVICE NAME
;		FQCLUS   =  FILE ID
;		FQNENT   =  SAME AS PASSED
;
;	"SOFT" ERRORS (FQFLAG = -1)
;
;		NORACS		NON-DISK DEVICE
;
;		NOSUCH		FILE NOT FOUND
;
;		PRVIOL		NOT A RUNNABLE FILE
;-

RUNENT::MAP	FIPPOL		;Be sure that FIP is mapped correctly	;045

FQFENT	RUN,,<FQSIZM,FQPPN,FQEXT,FQSIZ,FQBUFL,FQFLAG,FQPROT,FQDEV,FQDEVN,FQCLUS>,PHASE

	CLR	FQFLAG(R4)	;INITIALLY ERRORS ARE FATAL		;045
	MOVB	(PC),-(SP)	;FLAG AS NO CLOSE REQUIRED (<>0 BYTE)
	CALL	INI		;CHECK FOR ALREADY OPEN			;036
	BEQ	10$		;NOPE, NO CLOSE REQUIRED
	MOVB	(R1),(SP)	;YEP, SAVE DRIVER INDEX AS FLAG
	BEQ	10$		;OPEN DISK FILE, WE'LL CLOSE IT LATER
	ERROR	NOTCLS		;OPEN OTHER FILE, ERROR

10$:	CALLX	GUN,R5		;GET THE UNIT AND DEVICE TYPE
	 BR	20$		;IT IS DISK
	COM	FQFLAG(R4)	;NOT DISK, NON-FATAL ERROR
	ERROR	NORACS		;NOT RANDOM ACCESS DEVICE

20$:	TST	FQNAM1(R4)	;VALID NAME?
	BNE	30$		;YES
	ERROR	BADNAM		;NO NAME!

30$:	MOV	R4,R0		;COPY FIRQB POINTER AND
	ADD	#FQPPN,R0	; INDEX TO PPN AND FILE.EXT
	CMP	-(SP),-(SP)	;MAKE ROOM FOR LINK AND UFD DCN
	MOV	#-1,-(SP)	;SET IMPOSSIBLY BAD "HAPPINESS" FACTOR
40$:	CALLX	RUF		;READ IN THE UFD
	BCS	80$		;NO UFD TO SEARCH HERE
	MOV	#FIBUF,R5	;ELSE GET POINTER FOR SEARCHING
50$:	CALLX	RDENXT		;READ NEXT IN THE CHAIN
	BEQ	80$		;NO MORE
	BITB	#US.DEL!US.UFD,USTAT(R5) ;DELETED OR A UFD?
	BNE	50$		;YES, SKIP IT
	MOV	R0,R1		;COPY THE PPN,NAME.EXT POINTER
	MOV	R5,R2		; AND COPY THE ENTRY POINTER
	CMP	(R1)+,(R2)+	;SKIP ONE WORD IN BOTH
	CMP	(R1)+,(R2)+	;DOES THE NAME PART 1 MATCH?
	BNE	50$		;NO
	CMP	(R1)+,(R2)+	;DOES THE NAME PART 2 MATCH?
	BNE	50$		;NO
	CMP	(R1),(R2)	;DOES THE EXTENSION MATCH?
	BEQ	110$		;YES, EXACTLY, ALL FOUND
	TST	(R2)		;FILE HAS NULL EXTENSION?
	BEQ	50$		;NULL EXTENSION CANNOT MATCH RTS EXTENSION
	MOV	(R1),R2		;NO, GET EXTENSION FROM FIRQB
	INC	R2		;DOING AUTO-EXTENSION MATCHING (EXT = -1)?
	BNE	50$		;NOT THIS TIME, LOOP
	;CLR	R2		;YES, START THE "HAPPINESS" FACTOR
	MOV	#NULRTS,R1	;Get the pointer to the null RTS block	;038
	BR	70$		;And join up				;038
60$:	MOV	(R1),R1		;GET NEXT IN RTS LIST
	BEQ	50$		;THE END, JUST CONTINUE LOOKING
70$:	INC	R2		;ANOTHER, BUMP THE FACTOR		;038
	CMP	R.DEXT(R1),UNAM+4(R5) ;DOES THE EXTENSION MATCH?
	BNE	60$		;NOT A MATCH, GET NEXT RTS
	BITB	#UP.RUN,UPROT(R5) ;IS THIS AN EXECUTABLE FILE?
	BEQ	60$		;NO, SO TRY THE NEXT RTS
	DEC	R2		;A MATCH, CORRECT THE FACTOR
	BEQ	110$		;ZERO, QUITS RIGHT NOW!
	SWAB	R2		;PUT "HAPPINESS" IN HIGH BYTE AND
	BISB	@#FIPUNT,R2	; THE UNIT IN LOW BYTE
	CMP	R2,(SP)		;IS THIS FILE "BETTER"?
	BHIS	50$		;NO, CONTINUE LOOKING
	MOV	SP,R1		;YES, COPY POINTER TO STACK DATA
	MOV	R2,(R1)+	;SAVE THIS FILE'S "HAPPINESS" FACTOR
	MOV	@#FIBENT,(R1)+	; AND ITS STARTING UFD DCN
	MOV	R3,(R1)+	;  AND ITS LINK
	BR	50$		;NOW WE CAN CONTINUE

80$:	TSTB	FIPGEN		;Specific unit?				;045
	BEQ	90$		;Yes, don't try to find another unit	;045
	MOV	#UC.MNT!UC.PRI!UC.NFS,R2 ;Set up mask for a public unit	;045
	CALLX	NXTUN2,R1	;Get the next public unit		;045
	 BR	90$		;None, check the best found file
	BR	40$		;ANOTHER, SO DO IT

GLOBAL	<FIBUF,NULRTS,FIPUNT,FIBENT>					;038

90$:	MOVB	(SP)+,R3	;GET THE BEST FOUND UNIT
	BPL	100$		;ONE EXISTS
	COM	FQFLAG(R4)	;NONE, SO NO FILE, SOFT ERROR
	ERROR	NOSUCH		; OF NOT THERE

100$:	MOV	R3,@#FIPUNT	;SET THE FOUND UNIT
	MOV	(SP)+,R2	;GET THE UFD'S DCN AND
	CALLX	READUF		; READ THAT UFD
	MOV	(SP)+,R3	;NOW GET THE FILE'S LINK
	CALLX	RDE		; AND READ IN THE NAME ENTRY
	BR	120$		;NOW WE CAN FINISH UP

110$:	ADD	#3*2,SP		;COLLAPSE SP STACK SPACE
120$:	MOV	UNAM+4(R5),FQEXT-FQPPN(R0) ;RETURN THE EXTENSION WE FOUND
	MOVB	@#FIPUNT,R1	;GET THE UNIT NUMBER AND
	MOV	R1,@#FIPUNT	; RESET IT (FIPGEN=0 NOW)
	BITB	#US.UFD!US.OUT,USTAT(R5) ;UFD OR OUT OF SAT?
	BNE	140$		;YES IS ERROR
	REGSAV			;Save the registers			;020
	MOV	(R0),R0		;Get PPN of file			;020
	MOVB	UPROT(R5),R1	; and protection code			;020
	BITB	R1,#UP.RUN	;'COMPILED' TYPE FILE?			;020
	BEQ	130$		;NOPE IS (NON-FATAL) ERROR
	CALLX	CHKACC		;Find out access rights			;020
	BIT	#DDAUX,R0	;Execute lockout?			;026
	BNE	140$		;Yes, error				;020
	REGRES			;Restore registers			;020
	BR	150$		; and continue				;040

130$:	COM	FQFLAG(R4)	;NON-FATAL ERROR
140$:	ERROR	PRVIOL		;PROTECTION VIOLATION

GLOBAL	<FIPUNT,FIUSER,FIPRVM,UNTCNT>					;020

150$:	CALLX	SNE		;FIND FCB IF FILE ALREADY OPEN
	MOV	R1,-(SP)	; AND SAVE FOR LATER
	MOV	R3,-(SP)	;SAVE N.E. LINK
	CALLX	RAE		;READ ACCOUNTING ENTRY
	MOV	@#FIJBDA,R1	;GET JOB DATA POINTER
	MOV	#NULRTS,R3	;Guess at wanting RSX emulation		;038
	TST	(R1)+		;And point to JDFLG			;038
.ASSUME	JDFLG	EQ	2
	TST	URTS+2(R5)	;Is second half of RTS blank?		;038
	BNE	160$		;No, so they don't want RSX		;038
	CMP	URTS(R5),NULRTS+R.NAME+2 ;Do they want RSX?		;038
	BEQ	170$		;Yes, all set up then			;038
160$:	MOV	R4,-(SP)	;SAVE THE FIRQB POINTER SO		;038
	MOV	R5,R4		; WE CAN BUILD A POINTER TO
	TST	(R4)+		;  RTS NAME (AS FQNAM1(R4))		;038
.ASSUME	URTS	EQ	FQNAM1+2
	CALLX	FNDRTX		;NOW TRY TO FIND THE RUN-TIME SYSTEM	;038
	MOV	(SP)+,R4	;FOUND, RESTORE THE FIRQB POINTER
170$:	MOV	#JFRUN,-(SP)	;PRESET JDFLG2 BIT(S) TO NORMAL RUN	;038
	TST	FQSWIT(R4)	;SPECIAL CHAIN TYPE RUN?
	BLE	180$		;NO, NORMAL RUN AND/OR CCL
	INC	(SP)		;YES, SHIFT TO JFRUN!JFCTXT IN JDFLG2
.ASSUME	JFCTXT	EQ	1
	CMP	R3,JDRTS-JDFLG(R1) ;WOULD WE SWITCH RTS'S?
	BEQ	200$		;NO SWITCH
	ERROR	NORTS		;A SWITCH, SAY ERROR INSTEAD

180$:	CALLX	SWRTS		;SWITCH THE USER TO NEW RTS
	MOVB	R.SIZE(R3),R3	;R3 = Maximum allowed size for this RTS	;041
	CMPB	R3,#32.		;Is maximum more than allowed for I-space? ;041
	BLOS	190$		;No, so let this pass			;041
	MOVB	#32.,R3		;Yes, so use 32K instead		;041
190$:	MAP	FIPJC6,APR=6,DATA ;Map this job's JCR entry		;054
	MOV	FIPJCR,R0	;R0 -> JCR entry for job		;054
	MOVB	JCISIZ(R0),R5	;R5 = Size of job's I-space		;054
	CLR	-(SP)		;Get a cell for job's D-space size	;041
	MOVB	JCDSIZ(R0),(SP)	;Pick up job's D-space size		;054
	ADD	(SP)+,R5	;R5 = Size of job's I&D space		;041
	SUB	R3,R5		;R5 = Amount of extra I&D for this RTS	;041
	BLOS	200$		;Job is presently loadable for this RTS	;041
	MOVB	R3,JCISIZ(R0)	;Set up the job's I-space size		;054
	CLRB	JCDSIZ(R0)	;And forget about D-space		;041
	MOVB	JDSIZE-JDFLG(R1),R3 ;Pick up present size		;041
	SUB	R5,R3		;R3 has our new size			;041
	MOVB	R3,JCSIZN(R0)	;Set up our new size for next residency ;054
	CMPB	JDMCTL+M.CTRL-JDFLG(R1),#OUT ;Is job out of memory?	;041
	BEQ	200$		;Yes, so we've done all we need		;041
	MOVB	R3,JDSIZE-JDFLG(R1) ;No, so set the size in memory	;041
200$:	MOVB	@#FIJOB,R0	;Get job # * 2				;061
	CALLMI	SETMDE,GENAP5	;And update this job's MDEs		;061
	MAP	FIPPOL		;Re-map FIP pool correctly		;054
	BIS	#JFSPCL,(R1)	;SIGNAL A SPECIAL CONDITION
	BISB	(SP)+,JDFLG2-JDFLG(R1) ; AS RUN ENTRY

GLOBAL	<FIJBDA,FIJBD2,SWOCNT,NULRTS,FIPJC6,FIPJCR>			;054

	MOV	(SP)+,R3	;RESTORE N.E. LINK
	MOV	(SP)+,R1	;RESTORE FCB POINTER
	MOVB	@#FIPUNT,R0	; AND GET THE UNIT
	TSTB	(SP)+		;DO WE NEED TO CLOSE CHANNEL #15?
	BNE	210$		;NO, JUST GO DO IT
	MOV	R3,-(SP)	;YES, SAVE THE N.E. LINK
	MOV	@#FIBFBN,-(SP)	;SAVE CURRENT BLOCK MSB
	MOV	@#FIBFBN+F.FBNL,-(SP) ; AND LSB
	CALL	CLOSE		;GO OFF AND CLOSE CHANNEL #15		;022
	MOV	R0,@#FIPUNT	;RESTORE THE UNIT
	MOV	(SP)+,R2	;RESTORE BLOCK NUMBER LSB
	MOV	(SP)+,R3	; AND MSB
	CALLX	READ		;NOW RE-READ THAT BLOCK
	MOV	(SP)+,R3	;RESTORE THE N.E. LINK
	CALLX	RDE		;GET NAME ENTRY
	CALLX	SNE		;FIND FCB IF ANY
210$:	JMP	OPENFS		;NOW GO OFF AND REALLY OPEN IT		;040

GLOBAL	<FIPUNT,FIBFBN>


.SBTTL	CREATE A TEMP FILE

;+
; CRTFQ - CREATE A TEMP FILE.
;
;	R4 -> FIRQB
;		FQFIL    =  CHANNEL NUMBER TIMES 2
;		FQSIZ    =  FILE SIZE
;		FQMODE   =  OPEN MODE
;		FQDEV,FQDEVN = DISK DEVICE TO USE (0=>PUBLIC)
;		FQCLUS   =  FILE CLUSTER SIZE (0=>PCS)
;
;	CREATE A TEMP FILE MODE BITS:
;
;	    20	   16.	 4	CREATE CONTIGUOUS FILE
;	    40	   32.	 5	CREATE TENTATIVE FILE
;	   100	   64.	 6	CONDITIONAL CONTIGUOUS
;	   400	  256.	 8	USER DATA CACHING
;	  4000	 2048.	11	USER DATA CACHING IS SEQUENTIAL
;	100000	32768.	15	MODE IS "REAL" INDICATOR
;
;	IN FIRQB ON RETURN
;		FQFIL    =  SAME AS PASSED
;		FQSIZM   =  FILE SIZE MSB
;		FQPPN    =  PPN OF SELF
;		FQNAM1   =  FILE NAME (2 WORDS) AS "TEMPNN"
;		FQEXT    =  EXTENSION AS ".TMP"
;		FQSIZ    =  FILE SIZE LSB
;		FQBUFL   =  DEFAULT BUFFER SIZE
;		FQMODE   =  SAME AS PASSED
;		FQFLAG   =  FILE FLAGS
;		FQPROT-1 =  FILE CLUSTER SIZE (MOD 400)
;		FQPROT   =  PROTECTION CODE
;		FQDEV,FQDEVN = PHYSICAL DISK DEVICE NAME
;		FQCLUS   =  FILE ID
;		FQNENT   =  SAME AS PASSED
;
;	A FULL CREATE IS DONE IF
;		FQSIZ    <> 0
;		FQSIZM   <> 0
;		FQMODE   IS "REAL"
;		FQDEV,FQDEVN SPECIFIES A SPECIFIC UNIT
;		FQCLUS   <> 0
;-

.ENABL	LSB

FQFENT	CRT,,<FQSIZM,FQPPN,FQNAM1,FQNAM1+2,FQEXT,FQSIZ,FQBUFL,FQFLAG,FQPROT,FQDEV,FQDEVN,FQCLUS>,PHASE

	CALL	INI		;CHECK FOR ALREADY OPEN			;036
	BNE	70$		;ALREADY OPEN, ERROR
	CALLX	GUN,R5		;CHECK THE DEVICE
	BR	20$		;IT IS DISK
10$:	ERROR	NORACS		;NON-DISK, ERROR

20$:	MOV	R4,R0		;COPY THE FIRQB POINTER
	ADD	#FQSIZM,R0	; AND POINT TO MSB SIZE
	MOVB	(R0)+,R3	;REMEMBER MSB SIZE
.ASSUME	FQPPN	EQ	FQSIZM+1
	MOV	R0,R1		;NOW COPY THAT POINTER
	MOV	@#FIUSER,(R1)+	;USE CURRENT PPN
	MOV	(PC)+,(R1)+	;SET 1ST PART OF NAME
	 .RAD50	/TEM/
	MOVB	@#FIJOB,R5	;GET JOB NUMBER TIMES 2
	ASR	R5		;NOW IT IS AN INTEGER
	MOV	(PC)+,(R1)	;SET BASE FOR 2ND PART OF NAME
	 .RAD50	/P0 /
30$:	ADD	#50,(R1)	;BUMP THE RAD50 TENS DIGIT
	SUB	#10.,R5		;DIVIDE BY 10.
	BHIS	30$		; AND LOOP ON TENS DIGIT
	ADD	R5,(R1)+	;FINAL FUDGE
	MOV	(PC)+,(R1)+	;SET THE TMP EXTENSION
	 .RAD50	/TMP/		;FROM HERE
	BIS	(R1),R3		;.OR. SIZE LSB INTO SIZE MSB
	MOV	#UP.WPW!UP.RPW!UP.WPG!UP.RPG*400+377,FQPROT-1(R4) ;STANDARD PROT

GLOBAL	<FIUSER,FIJOB>

	BIC	#^C<OP$MOD!OP$CSQ!OP$CHE!OP$CCT!OP$TEN!OP$CTG>,FQMODE(R4)
	BMI	40$		;A 'REAL MODE', DO A REAL CREATE
	BIS	FQCLUS(R4),R3	;SPECIFIED FILE SIZE OR CLUSTER SIZE?
	BNE	40$		;REAL CREATE IF ANY OF THE ABOVE
	TSTB	@#FIPGEN	;GENERAL DISK?
	BEQ	40$		;NOPE, DO A REAL CREATE
	CALLX	SDU		;NOW SEARCH
	BCS	40$		;NOT THERE
	MOVB	@#FIPUNT,R0	;GET THE UNIT NUMBER
	MOV	R0,R1		;COPY UNIT AND
	ASL	R1		; TIMES 2 FOR WORD ADDRESSING
	BIT	#UC.MNT!UC.PRI!UC.LCK!UC.NFS!UC.WLO,UNTCNT(R1) ;IS THIS PACK LOCKED NOW?
	BNE	40$		;IF SO, THEN DON'T USE IT
	CALLX	SNE		;OPEN BY ANYONE?
	BNE	40$		;IF IN USE, THEN MAKE A NEW ONE
	CMP	USTAT(R5),#UP.WPW!UP.RPW!UP.WPG!UP.RPG*400+0 ;VALID STATUS/PROT?
	BNE	40$		;NO, CREATE A NEW FILE
	JMP	OPENFS		;NOW REALLY (RE-)OPEN IT		;052

GLOBAL	<FIPGEN,FIPUNT,UNTCNT>

.SBTTL	CREATE A BINARY FILE

;+
; CRBFQ - CREATE A BINARY FILE.
;
;	R4 -> FIRQB
;		FQFIL    =  CHANNEL NUMBER TIMES 2
;		FQSIZM   =  MUST BE 0 (COMPILED FILES MUST BE SMALL)
;		FQPPN    =  PPN (0=>SELF)
;		FQNAM1   =  FILE NAME (2 WORDS)
;		FQEXT    =  EXTENSION
;		FQSIZ    =  FILE SIZE
;		FQMODE   =  OPEN MODE
;		FQPROT   =  PROTECTION CODE (0=>SYSTEM DEFAULT)
;		FQDEV,FQDEVN = DISK DEVICE TO USE (0=>PUBLIC)
;		FQCLUS   =  FILE CLUSTER SIZE (0=>PCS)
;		FQNENT	 =  DCN OF POSITION ON DISK TO PLACE FILE
;
;	CREATE A BINARY FILE MODE BITS:
;
;	     1	    1.	 0	UPDATE MODE
;	     2	    2.	 1	APPEND
;	     4	    4.	 2	SPECIAL UPDATE MODE (WITH BIT 0)
;	    10	    8.	 3	ALWAYS UPDATE DISK FILE SIZE
;	    20	   16.	 4	CREATE CONTIGUOUS FILE
;	    40	   32.	 5	CREATE TENTATIVE FILE
;	   100	   64.	 6	CONDITIONAL CONTIGUOUS
;	   200	  128.	 7	DO NOT SUPERSEDE EXISTING FILE
;	   400	  256.	 8	USER DATA CACHING
;	  2000	 1024.	10	LINK NEW FILE TO END OF DIRECTORY
;	  3000	 1536.	10-9	LINK NEW FILE TO TOP OF DIRECTORY
;	  4000	 2048.	11	USER DATA CACHING IS SEQUENTIAL
;	 10000	 4096.	12	ALWAYS READ NORMAL MODE
;	 20000	 8192.	13	READ-ONLY MODE
;	 40000	16384.	14	WRITE ACCESS REQUIRED
;	100000	32768.	15	MODE IS "REAL" INDICATOR
;
;	IN FIRQB ON RETURN
;		FQFIL    =  SAME AS PASSED
;		FQSIZM   =  0 (COMPILED FILES MUST BE SMALL)
;		FQPPN    =  PPN
;		FQNAM1   =  FILE NAME (2 WORDS)
;		FQEXT    =  EXTENSION
;		FQSIZ    =  FILE SIZE LSB
;		FQBUFL   =  DEFAULT BUFFER SIZE
;		FQMODE   =  SAME AS PASSED
;		FQFLAG   =  FILE FLAGS
;		FQPROT-1 =  FILE CLUSTER SIZE (MOD 400)
;		FQPROT   =  PROTECTION CODE
;		FQDEV,FQDEVN = PHYSICAL DISK DEVICE NAME
;		FQCLUS   =  FILE ID
;		FQNENT   =  SAME AS PASSED
;-

FQFENT	CRB,,<FQSIZM,FQPPN,FQSIZ,FQBUFL,FQFLAG,FQPROT,FQDEV,FQDEVN,FQCLUS>,PHASE

	TSTB	FQSIZM(R4)	;DOES HE WANT A LARGE FILE?
	BNE	90$		;YES, ERROR
	MOV	#UP.RUN,-(SP)	;THIS WILL BE A 'COMPILED' FILE
	BR	50$		; NOW CONTINUE

.SBTTL	CREATE A FILE

;+
; CREFQ - CREATE A FILE.
;
;	R4 -> FIRQB
;		FQFIL    =  CHANNEL NUMBER TIMES 2
;		FQSIZM   =  FILE SIZE MSB
;		FQPPN    =  PPN (0=>SELF)
;		FQNAM1   =  FILE NAME (2 WORDS)
;		FQEXT    =  EXTENSION
;		FQSIZ    =  FILE SIZE LSB
;		FQMODE   =  OPEN MODE
;		FQPROT   =  PROTECTION CODE (0=>SYSTEM DEFAULT)
;		FQDEV,FQDEVN = DEVICE TO USE (0=>PUBLIC)
;		FQCLUS   =  FILE CLUSTER SIZE (0=>PCS)
;		FQNENT	 =  DCN OF POSITION ON DISK TO PLACE FILE
;
;	CREATE A DISK FILE MODE BITS:
;
;	     1	    1.	 0	UPDATE MODE
;	     2	    2.	 1	APPEND
;	     4	    4.	 2	SPECIAL UPDATE MODE (WITH BIT 0)
;	    10	    8.	 3	ALWAYS UPDATE DISK FILE SIZE
;	    20	   16.	 4	CREATE CONTIGUOUS FILE
;	    40	   32.	 5	CREATE TENTATIVE FILE
;	   100	   64.	 6	CONDITIONAL CONTIGUOUS
;	   200	  128.	 7	DO NOT SUPERSEDE EXISTING FILE
;	   400	  256.	 8	USER DATA CACHING
;	  2000	 1024.	10	LINK NEW FILE TO END OF DIRECTORY
;	  3000	 1536.	10-9	LINK NEW FILE TO TOP OF DIRECTORY
;	  4000	 2048.	11	USER DATA CACHING IS SEQUENTIAL
;	 10000	 4096.	12	ALWAYS READ NORMAL MODE
;	 20000	 8192.	13	READ-ONLY MODE
;	 40000	16384.	14	WRITE ACCESS REQUIRED
;	100000	32768.	15	MODE IS "REAL" INDICATOR
;
;	IN FIRQB ON RETURN
;		FQFIL    =  SAME AS PASSED
;		FQSIZM   =  FILE SIZE MSB
;		FQPPN    =  PPN
;		FQNAM1   =  FILE NAME (2 WORDS)
;		FQEXT    =  EXTENSION
;		FQSIZ    =  FILE SIZE LSB
;		FQBUFL   =  DEFAULT BUFFER SIZE
;		FQMODE   =  SAME AS PASSED
;		FQFLAG   =  FILE FLAGS
;		FQPROT-1 =  FILE CLUSTER SIZE (MOD 400)
;		FQPROT   =  PROTECTION CODE
;		FQDEV,FQDEVN = PHYSICAL DISK DEVICE NAME
;		FQCLUS   =  FILE ID
;		FQNENT   =  SAME AS PASSED
;-

FQFENT	CRE,,<FQSIZM,FQPPN,FQSIZ,FQBUFL,FQFLAG,FQPROT,FQDEV,FQDEVN,FQCLUS>,PHASE

40$:	CLR	-(SP)		;THIS WILL BE A DATA FILE
50$:	TST	FQMODE(R4)	;ANY MODE SPECIFIED?
	BMI	60$		;YES
	CLR	FQMODE(R4)	;NO, ENSURE NO MODE VALUE
60$:	MOV	#-1,FQSWIT(R4)	;SET A FLAG FOR DECTAPE/MAGTAPE
	CALL	INI		;CHECK FOR CHANNEL ALREADY OPEN		;036
	BEQ	80$		;O.K., CHANNEL IS CLOSED
70$:	ERROR	NOTCLS		;ELSE ERROR

80$:	CALLX	GUN,R5		;GET NAME AND UNIT NO.
	 BR	100$		;ALL DISKS PASS ON
	TST	(SP)+		;'COMPILED' FILE?
	BNE	10$		;YES, SO ERROR
	JMP	OPENDV		; ELSE GO DO A GENERAL OPEN

90$:	ERROR	PRVIOL		;NO BINARIES NOT ON DISK

100$:	CALLX	CHKNAM		;CHECK THE NAME FOR LEGALITY
	MOV	#OP$TEN!OP$UPD,R0 ;CAN'T HAVE BOTH TENTATIVE AND UPDATE MODES
	BIC	FQMODE(R4),R0	;ARE THEY BOTH ON?
	BEQ	90$		;ERROR IF SO
	MOV	@#FIPUNT,R0	;GET UNIT AND FIPGEN SPECIFICATION
	MOV	R0,FQSWIT(R4)	; AND SAVE FOR LATER USE
	BIT	#UC.PRI,(R1)	;IS THIS A PUBLIC PACK REFERENCE ?
	BNE	110$		;IF NOT THEN LEAVE SPECIFICATION ALONE
	MOVB	@#SYSUNT,R0	;SET BASE AS SYSTEM UNIT AND
	BIS	(PC)+,R0	; ENSURE A GENERAL SEARCH
	 .BYTE	0,-1
110$:	BIT	#UC.WLO,(R1)	;UNIT WRITE LOCKED?
	BNE	90$		;YES, ERROR
	MOV	R4,R2		;COPY THE FIRQB POINTER AND
	ADD	#FQPPN,R2	; INDEX TO THE PPN

GLOBAL	<FIPUNT,SYSUNT>

	MOV	@#FIUSER,R3	;GET THE CALLER'S PPN
	TST	(R2)		;WAS THE PPN SUPPLIED?
	BNE	120$		;YES
	MOV	R3,(R2)		;NO, SO SET CALLER'S PPN
120$:	MOV	R0,-(SP)	;Save a register			;020
	MOV	R1,-(SP)	; and another				;020
	CLR	R1		;Use a faked protection code		;020
	MOV	(R2),R0		;Get PPN for file			;020
	CALLX	CHKACC		;Check access rights			;020
	BIT	#DDPRVO,R0	;Do you have create/rename rights	;040
	BEQ	90$		;If not, can't create there		;020
	MOV	(SP)+,R1	;Restore registers			;020
	MOV	(SP)+,R0						;020
	BIS	#UP.WPW!UP.RPW!UP.WPG!UP.RPG*400,(SP) ;SET DEFAULT PROT CODE
..DPRT	==	.-1	;**PATCH** SYSTEM DEFAULT PROTECTION CODE
	BISB	(SP),1(SP)	;Put in compiled bit if CRBFQ		;050
	TSTB	FQPROT-1(R4)	;WAS THE PROTECTION CODE SPECIFIED?
	BEQ	130$		;NO
	MOVB	FQPROT(R4),1(SP) ;YES, SO USE THAT SUPPLIED CODE
	BISB	(SP),1(SP)	;Put in compiled bit if CRBFQ		;050
	BIS	#200,(SP)	; AND INDICATE CODE IS NOW "REAL"
130$:	TST	(SP)		;Setting UP.PRV?			;050
	BPL	160$		;No, skip priv check			;050
.ASSUME	UP.PRV*400 EQ 100000						;050
	BIT	#UP.RUN*400,(SP) ;Yes, setting UP.RUN?			;050
	BEQ	140$		;No, check for SYSIO			;050
	TSTPRV	TMPPRV,@#FIPRVM	;Yes, TMPPRV?				;050
	BNE	160$		;Yes, he has carte blanche		;050
	BR	150$		;No, nuke UP.PRV			;050

140$:	TSTPRV	SYSIO,@#FIPRVM	;SYSIO?					;050
	BNE	160$		;Yes, anything goes			;050
150$:	BIC	#UP.PRV*400,(SP) ;Turn off UP.PRV bit			;050
160$:	MOV	(SP)+,FQPROT-1(R4) ;REPLACE PROTECTION CODE IN FIRQB NOW
	MOV	FQCLUS(R4),R5	;GET THE FILE CLUSTER SIZE
	BEQ	180$		;=0, THAT WILL ALWAYS BE O.K.
	BPL	170$		;>0, CHECK FOR LEGALITY
	NEG	R5		;<0, FORM THE ABS(CLUSTER SIZE) AND CHECK
170$:	MOV	R5,R2		;COPY THE CLUSTER SIZE
	DEC	R2		;MAKE IT A MASK
	BIT	R2,R5		;IS IT A POWER OF 2?
	BNE	190$		;NOPE, ERROR
	SWAB	R2		;IS CLUSTER-1>255 (TOO BIG)?
	BNE	190$		;IF SO, ERROR
180$:	MOV	#-1,@#FIPU0C	;SET FLAG TO TRAP NON-EXISTENT PPN'S
	;MOV	@#FIPUNT,R0	;GET THE FIPUNT/FIPGEN FOR CREATE
	MOV	R0,-(SP)	; AND STACK IT
	;MOV	SP,R1		;R1 IS <> 0
	JMP	CREATE		;NOW GO REALLY CREATE THE FILE

190$:	ERROR	BADCLU		;CLUSTER SIZE NOT LEGAL

.DSABL	LSB

GLOBAL	<FIUSER,FIPRVM,FIPU0C>						;020


.SBTTL	THE REAL WORK OF CREATE

.ENABL	LSB

10$:	MOV	FQSWIT(R4),(SP)	;RESET ORIGINAL UNIT+GEN
	MOVB	FQSWIT+1(R4),R1	;WAS THIS AN EXPLICIT REF TO PUBLIC?
	BEQ	CREATE		;YES, GO SEARCH AGAIN (R1=0 THIS TIME)
	CLR	R0		;R0 AND R2 ARE
	CLR	R2		; OUR MAXIMUM SIZE HOLDERS
	MOV	#MAXUNT+1,R1	;THIS IS OUR FILE UNIT COUNTER
	MOV	#SATCTM+MAXUN2+2,R5 ;POINT TO TOP OF MSB SIZE TABLE
20$:	CMP	R2,-(R5)	;DOES THIS UNIT HAVE MORE BLOCKS MSB?
	BNE	30$		;MSB DIFFERENT, GO SORT IT OUT
	CMP	R0,SATCTL-SATCTM(R5) ;ARE THE LSB FREE BLOCK COUNTS DIFFERENT?
30$:	BHI	40$		;FEWER FREE BLOCKS HERE, SKIP IT
	BIT	#UC.MNT!UC.PRI!UC.LCK!UC.NFS!UC.WLO,UNTCNT-SATCTM(R5) ;MOUNTED & PUBLIC?
	BNE	40$		;IF NOT AVAILABLE, SKIP IT
	MOV	R1,R3		;Copy FUN + 1				;064
	DEC	R3		; and make it just FUN			;064
	MUL	#DL$SIZ,R3	;Multiply it by the size of DLNB entry	;064
	ADD	#DSKLOG,R3	; and get this FUN's entry in DLNB	;064
	CMP	DL$DEV(R3),#"DV	;Is this the virtual disk?		;064
	BEQ	40$		;Yes, can't put files there by default	;064
	MOV	SATCTL-SATCTM(R5),R0 ;MAKE THIS OUR NEW MAXIMUM
	MOV	(R5),R2		; ROOM PACK
	MOV	R1,(SP)		;MAXIMUM ROOM PACK
40$:	SOB	R1,20$		;CHECK ALL UNITS
	DEC	(SP)		;MAKE LOOP INDEX INTO REAL FIP UNIT NUMBER
	;CLRB	1(SP)		;SET THE SPECIFIC UNIT FLAG
	;CLR	R1		;SET R1 TO 0 AS A FLAG (R1=0 FROM SOB LOOP)

GLOBAL	<MAXUNT,SATCTM,MAXUN2,SATCTL,UNTCNT>

;+
; CREATE - CREATE A FILE.
;
;	R1 <> 0
;	R4 -> FIRQB
;	SP -> INITIAL FIP UNIT AND GENERAL INDICATOR
;-

CREATE:	MOV	(SP),@#FIPUNT	;SET THE UNIT+GEN FLAG
	MOV	R4,R0		;COPY THE FIRQB POINTER
	ADD	#FQPPN,R0	; AND POINT TO THE PPN
	CALLX	SDP		;Look in permanent file list or disk	;022
	MOVB	@#FIPUNT,R0	;PRESET THE FIP UNIT NUMBER
	BCS	100$		;IF NOT FOUND, THEN ALL IS O.K.
	TSTB	FQMODE(R4)	;NO SUPERSEDING ON CREATE?
.ASSUME	OP$NOS	EQ	200
	BMI	70$		;IF SO, GIVE ERROR FOR TRYING
	ASR	R1		;Found in permanent list?		;022
	BCS	80$		;Yes, can't supersede it then		;022
	MOV	R0,-(SP)	;Save a register			;022
	MOV	R1,-(SP)	; and another				;022
	MOV	FQPPN(R4),R0	;Get PPN of file			;022
	MOVB	UPROT(R5),R1	; and its protection code		;022
	CALLX	CHKACC		;Are we allowed to delete the file?	;022
	BIT	#DDWLO,R0	;I.e. do we have write access to it?	;022
	BNE	80$		;Error if not				;022
	MOV	(SP)+,R1	;Now restore registers			;022
	MOV	(SP)+,R0	; for goodness				;022
	BITB	#US.NOK,USTAT(R5) ;CAN WE DELETE IT?			;022
	BNE	80$		;NO, GIVE ERROR
	ASL	R0		;YES, UNIT TIMES 2 FOR WORD ADDRESSING
	BIT	#UC.WLO,UNTCNT(R0) ;UNIT WRITE LOCKED??
	BNE	80$		;YES, CAN'T DELETE IT
	MOVB	FQPROT-1(R4),R0	;IS PROTECTION CODE VALID YET?
	BMI	60$		;YES
	MOV	UPROT-1(R5),-(SP) ;NO, GET THIS FILE'S PROT CODE
	BIC	#UP.PRV!UP.RUN*400!377,(SP) ;TRIM PRIV AND RUNNABLE
	ASLB	R0		;WHAT KIND OF FILE IS THIS TO BE?
	BPL	50$		;IT WILL BE A DATA FILE, LEAVE AS IS
.ASSUME	UP.RUN*2	EQ	200
	BIS	#UP.RUN*400,(SP) ;IT WILL BE A 'COMPILED' FILE
50$:	COMB	(SP)		;INDICATE PROT CODE IS NOW VALID
	MOV	(SP)+,FQPROT-1(R4) ;REPLACE (NOW VALID) CODE IN FIRQB
60$:	BIT	#OP$TEN,FQMODE(R4) ;IS THIS A TENTATIVE CREATE?
	BNE	90$		;IF SO, DON'T DELETE THE OLD FILE YET
	CALLX	XFL		;DELETE ALL FILE SPACE
	BR	CREATE		; AND GO TRY THE SEARCH AGAIN

70$:	ERROR	FIEXST		;CAN'T SUPERSEDE FILE

80$:	ERROR	PRVIOL		;GIVE VIOLATION IF NEEDED

GLOBAL	<FIPUNT,UNTCNT>

90$:	CALLX	RDEPRV		;FOR TENTATIVE ENTER, FIND END OF N.E. LIST
	BNE	90$		; SO WE CAN CREATE AT END
	MOV	#4,R5		;INDICATE WE SHOULD CREATE NEW FILE NAME ENTRY
100$:	MOVB	@#FIPUNT,R0	;PRESET THE FIP UNIT NUMBER
	TSTB	1(SP)		;WERE WE DOING A GENERAL SEARCH
	BNE	10$		; YES, GO GET A SPECIFIC UNIT FOR THE CREATE
	MOV	R2,(SP)		;SAVE THE OLD LINK FOR LATER
	ASL	R0		;MAKE UNIT TIMES 2 FOR WORD ADDRESSING
	CLR	R2		;Get ready to get the pack clustersize	;052
	BISB	UNTCLU(R0),R2	;Now pick up the pack clustersize	;052
	MOV	FQCLUS(R4),-(SP) ;And pick up the user's request	;034
	BNE	130$		;Got one, no optimization to do		;034
	MOV	#256.,(SP)	;No clustersize, start with 256		;034
	TSTB	FQSIZM(R4)	;Is this a large file?			;034
	BNE	120$		;Yes, so we are all done		;052
	TST	FQSIZ(R4)	;Is there a size at all?		;034
	BEQ	150$		;No, go use the PCS for the file	;034
	MOV	#<128.*7.>,R2	;Get the initial filesize to check	;034
110$:	CMP	FQSIZ(R4),R2	;Is filesize larger than our max size?	;034
	BHI	120$		;Yes, so we've found the clustersize	;034
	ASR	R2		;No, get the next filesize to try	;034
	ASR	(SP)		;And get the next appropriate clustersize ;034
	BNE	110$		;Try again unless we hit zero		;034
	INC	(SP)		;If zero, go and try one now		;034
120$:	CLR	R2		;Get ready to get the pack clustersize	;052
	BISB	UNTCLU(R0),R2	;Now pick it up				;052
	CMP	(SP),R2		;Did we pick a clustersize > PCS?	;052
	BLOS	150$		;No, so set to use the PCS		;052
	BIS	#100000,(SP)	;Yes, so set the optimization flag	;052
	BR	160$		;And join up				;052

; Come to the code below if a clustersize has been specified. We will
; check to see if it is negative (meaning use PCS instead) or whether
; we should actually check the request.

130$:	BMI	140$		;IF NEGATIVE, CHECK FOR TOO SMALL	;034
	CMP	R2,(SP)		;CHECK PACK VS SPECIFIED
	BLOS	160$		;O.K. IF LESS OR SAME
	ERROR	BADCLU		;ELSE AN ERROR

140$:	NEG	(SP)		;Get the actual clustersize
	CMP	(SP),R2		;Is this clustersize legal?		;052
	BHIS	160$		;Yes, go use it				;052
150$:	MOV	R2,(SP)		;Use the pack clustersize
160$:	MOV	(SP)+,FQCLUS(R4) ;Now set the clustersize and flag
	MOV	@#FIBENT,@#DIRPOS ;SET THE DEFAULT POSITION		;045
	ASR	R0		;Make it FUN * 1			;025
	ASL	R5		;Form JMP table offset			;040
	ADD	R5,PC		;INDEX FROM THE SDU FAILURE
	 JMP	330$		;NO PPN WAS FOUND AT ALL		;040
	 JMP	320$		;GO CREATE A UFD FOR THIS USER		;040
	CALLX	GDE		;GET ME A DIRECTORY ENTRY
	BCC	170$		;We got one, good			;041
	ERROR	NOROOM		;Report the lack of room in directory	;041

170$:	MOV	R3,-(SP)	;SAVE LINK OF THE A.E.			;041
180$:	INC	(R5)+		;SET THE A.E. MARKER
.ASSUME	UL.USE	EQ	1
.ASSUME	ULNK	EQ	0
	MOV	#DATE,R0	;POINT TO: DATE, TIME
	MOV	(R0),(R5)+	;SET TODAY'S DATE as the DLA
.ASSUME UDLA	EQ	ULNK+2
	CLR	(R5)+		;SET SIZE=0 FOR NOW
.ASSUME USIZ	EQ	ULNK+4
	MOV	(R0)+,(R5)+	;SET CREATION AS TODAY
.ASSUME UDC	EQ	ULNK+6
	MOV	(R0)+,(R5)+	; AND CREATION TIME AS RIGHT NOW
.ASSUME UTC	EQ	ULNK+10
	CMPB	FQFUN(R4),#CRTFQ ;Temporary file create?		;065
	BNE	185$		; NO, so life is easy			;065
	BIS	#UTC.IG,-2(R5)	; Yes, so set the IGNORE flag		;065
185$:	MOV	@#FIJBDA,R0	;R0 -> JDB for job in FIP		;041
	MOV	JDRTS(R0),R0	;R0 -> job's present RTS		;041
	CMP	R.DEXT(R0),FQEXT(R4) ;Does type match RTS executable type? ;041
	BEQ	200$		;Yes, so use this RTS for file		;041
	TST	FQEXT(R4)	;Does this file have a type at all?	;041
	BEQ	200$		;No, so use this RTS for file		;041
	MOV	#NULRTS,R0	;Point to null RTS			;040
190$:	CMP	R.DEXT(R0),FQEXT(R4) ;Does file go with this RTS?	;040
	BEQ	200$		;Yes, so use its name for the file	;040
	MOV	(R0),R0		;Point to next one in list		;040
.ASSUME	R.LINK EQ 0							;040
	BNE	190$		; and continue search if more to do	;040
	MOV	@#FIJBDA,R0	;GET JOB DATA POINTER			;041
	MOV	JDRTS(R0),R0	; AND FROM THAT THE RTS BLOCK
200$:	TST	(R0)+		;POINT THE RTS NAME			;040
.ASSUME	R.NAME	EQ	2
	MOV	(R0)+,(R5)+	;SET NAME PART 1
	MOV	(R0)+,(R5)+	; AND NAME PART 2
	MOV	FQCLUS(R4),(R5)	;Set the clustersize and flag		;052
	BIC	#100000,(R5)	;Clear the flag				;052
	MOV	(R5)+,FIPCLU	;And save the clustersize for later	;052
	CALLX	GDESV		;Now try to get a name entry
	BCC	210$		;Got one, good				;052
	MOV	(SP)+,R3	;Failed, get back accounting entry link	;052
	CALLX	RDE		;Read it back in			;052
	CALLX	ZDE		;Free it up				;052
	ERROR	NOROOM		;And announce the error			;052

210$:	MOV	R4,R1		;BUILD A POINTER			;052
	ADD	#FQMODE,R1	; TO MODE VALUE FOR LINKING DIRECTION
	MOV	R4,R0		;COPY THE FIRQB POINTER
	ADD	#FQNAM1,R0	; AND POINT TO THE NAME
	CLR	(R5)+		;THIS IS THE LAST ENTRY

GLOBAL	<FIPGEN,UNTCLU,FIJBDA,DIRPOS,NULRTS,FIPCLU>			;052

	MOV	(R0)+,(R5)+	;NOW SET THE FILE NAME
	MOV	(R0)+,(R5)+	; (BOTH WORDS)
	MOV	(R0)+,(R5)+	;  AND EXTENSION
	MOV	(R1),R2		;COPY MODE FLAGS
	ASH	#-6,R2		;SHIFT "TENTATIVE" BIT INTO CARRY
.ASSUME	OP$TEN	EQ	40
	RORB	(R5)+		;SET USTAT CORRECTLY
.ASSUME	US.DEL	EQ	200
	MOVB	FQPROT(R4),(R5)	;UPROT GETS WHAT IT NEEDS
	MOV	(SP)+,UAA-UPROT(R5) ;SET THE A.E. LINK
	MOVB	@#FIPUNT,R0	;GET THE UNIT NUMBER
	MOV	R3,R2		;SAVE NEW FILE'S NAME ENTRY LINK
	MOV	(SP)+,R3	;GET PREVIOUS LAST LINK
	BIT	#OP$LNK,(R1)	;SPECIFIED LINK DIRECTION?
	BNE	220$		;YES, SO USE IT
	MOV	R0,R1		;ELSE COPY UNIT
	ASL	R1		; AND BUILD A POINTER
	ADD	#UNTOPT,R1	;  TO DEFAULT LINK DIRECTION INFORMATION ;024
220$:	BIT	#OP$TOP,(R1)	;LINK TO TOP?
	BEQ	230$		;NO, TO END
.ASSUME	UO.TOP	EQ	OP$TOP
	CLR	R3		;YES, TO TOP, FORCE TOP
230$:	CALLX	RDESV		;READ PREVIOUS ENTRY
	MOV	(R5),-(SP)	;SAVE THIS ENTRY'S LINK
	BIC	#UL.BLO!UL.CLO!UL.ENO,(R5) ;NOW MAKE IT LINK NOWHERE
	BIC	(R5),(SP)	; AND LEAVE ONLY LINK INFO ON STACK
	BIS	R2,(R5)		;NOW LINK THIS TO THE NEW ENTRY
	MOV	R2,R3		;GET BACK THE NEW ENTRY'S LINK
	CALLX	RDESV		; AND READ IT AGAIN
	MOV	(SP)+,(R5)	;LINK NEW ENTRY TO WHEREVER
	MARK	FIBUF		; AND MARK BUFFER FOR WRITE
	MOV	FQNENT(R4),R2	;GET THE STARTING DCN
	BEQ	260$		;DON'T BOTHER ROUNDING ZERO.
	REGSAV			;SAVE THE WORLD (SETSAT WILL CHANGE IT)
	ASL	R0		;Yes, get FUN * 2			;048
	CMP	R2,#-1		;Did they ask for middle?		;025
	BEQ	240$		;Yes					;048
	CMP	R2,#-2		;No, did he ask for close to SATT?	;048
	BNE	250$		;No					;048
	MOV	MFDPTR(R0),R2	;Get SATT location (next to MFD)	;048
	BR	250$		;Continue				;048

240$:	MOV	UNTSIZ(R0),R2	;Get the devices size			;025
	;CLC			; (carry clear from CMP)		;048
	ROR	R2		; and get the middle			;025
	CMPB	MID$XX+1(R0),#3	;RC25 controller type?			;068
	BNE	250$		; NO					;068
	CMP	R2,#61553	; RC25s spindle location?		;068
	BNE	250$		; NO					;068
	ROR	R2		; Get the RC25 real middle		;068
250$:	ASR	R0		;Make it FUN * 1			;048
	MOV	R4,R3		;COPY THE FIRQB POINTER
	MOV	FIPCLU,R1	;Pick up the file clustersize		;052
	CALLX	SETSAT		;GET ALIGNED PCN (=(DCN-1)/(PCS/DCS))
	MOVB	CLUFAC(R5),R1	;GET THE CLUSTER RATION FACTOR (PCS/DCS)
	NEG	R1		;MAKE IT A MULTIPLICATION FACTOR.
	ASH	R1,R2		;CONVERT TO (DCN-1)
	INC	R2		; AND ADD IN THE EXTRA ONE.
	MOV	R2,FQNENT(R3)	;THIS IS THE DCN THE USER REALLY WANTED.
	REGRES			;PUT BACK THE SAVED CONTEXT.	
260$:	CALL	CRTENT		;Try creating a QTB entry		;033
	MOVB	FQSIZM(R4),R2	;Get the MSB of the filesize		;052
	BIS	FQSIZ(R4),R2	;And .OR. in the LSB size		;052
	BEQ	310$		;Zero, nothing to do			;052
	CLR	R2		;Guess at no clustersize optimization	;052
	TST	FQCLUS(R4)	;Good guess?				;052
	BPL	270$		;Yes, sure was				;052
	MOVB	R0,R1		;Copy FIP unit number			;052
	ASL	R1		;And get it times two			;052
	BISB	UNTCLU(R1),R2	;Now pick it up				;052
270$:	MOV	FIPCLU,R1	;Get the optimial clustersize		;052

; R0 = Fip Unit Number
; R1 = Optimal (or requested) clustersize
; R2 = Pack clustersize (zero if no optimization)
; R3 = Name entry link word
; R4 -> FIRQB
; FIPCLU = Optimal (or requested) clustersize
;
; At this point, we are going to try the extends as requested by the
; user.
;
; There are four possible extends which we can try:
;
;	1. Contiguous at optimal (or requested) clustersize
;	2. Contiguous at pack clustersize
;	3. Non-contiguous at optimal (or requested) clustersize
;	4. Non-contiguous at pack clustersize
;
; Choices 2 and 4 are only executed if we have done clustersize optimization.

	BIT	#OP$CCT!OP$CTG,FQMODE(R4) ;Desire a contiguous file?	;052
	BEQ	290$		;No, not this time			;052
	CALL	EXTCTG		;Yes, try a contiguous extend		;052
	BCC	310$		;Success!				;052
	MOV	R2,FIPCLU	;Failure, set fallback clustersize	;052
	BEQ	280$		;None, see if we can do non-contiguous	;052
	CALL	EXTCTG		;Try non-optimal contiguous extend	;052
	BCC	310$		;Success!				;052
280$:	BIT	#OP$CTG,FQMODE(R4) ;Can we try non-contiguous?		;052
	BNE	300$		;No, we've failed			;052
	MOV	R1,FIPCLU	;Yes, set up optimal clustersize	;052
290$:	CALLX	EXTCLS		;Try a non-contiguous extend		;052
	BCC	310$		;Success, file is extended		;052
	MOV	R2,FIPCLU	;Failure, can we try again?		;052
	BEQ	300$		;No, give the user an error		;052
	CALLX	EXTCLS		;Try this extend one last time...	;052
	BCC	310$		;Worked!				;052
	.BR	300$		;Error...				;052

; We get here when we exhaust all the extends we are allowed to try.

300$:	CALLX	DELNEW		;Go and delete this new file		;052
	ERROR	NOROOM		;And tell them about the problem...	;052

; We get here after a successful extend. We will now go to open the file.

310$:	MOV	FIPCLU,FQCLUS(R4) ;Get the actual clustersize in the FIRQB ;052
	JMP	OPENCE		;File extended, go open it now		;052

GLOBAL	<FIPUNT,UNTCNT,FIPCLU,CLUFAC,UNTSIZ,MFDPTR,MID$XX>		;068

; PPN IS IN MFD, WE MUST CREATE UFD ON OUTPUT DISK

320$:	CALL	CREUFD		;  it will be reset by the FCALL.
	BR	340$		; Finish up upon return.

; PPN NOT IN MFD OF TARGET DISK, ERROR (PRIVATE) OR ENTER IT (PUBLIC)

330$:	CALL	CREMFD		;  FCALL resets it to the system disk.

340$:	MOV	R2,-(SP)	; Save the A.E. link for the main code.
	MOV	R0,@#FIPUNT	; Make sure that FIPUNT has been restored.
	JMP	180$		;CONTINUE

;+									;033
; Create QTB entry if RDS1.2 or newer and not account [0,1]		;033
;									;042
; Inputs -								;042
;									;042
;	R0 =  Fip Unit Number						;042
;	R3 =  Name entry link word					;052
;	R4 -> FIRQB							;042
;									;033
;	FIBUF has any block of the directory				;033
;-

CRTENT:	REGSCR			;Save all registers			;053
	CLR	@#QTCURR	;No QTB entry yet			;033
	ASL	R0		;Make it FUN * 2			;033
	CMP	UNTLVL(R0),(PC)+ ;Support extended quota data		;033
	 .BYTE	2,1							;033
	BLO	350$		;No, no QTB entries to create		;033
	CMP	FQPPN(R4),(PC)+	;Account [0,1]?				;033
	 .BYTE	1,0							;033
	BEQ	350$		;Yes, no QTB entries for these either	;033
	MOV	R4,R0		;Copy the FIRQB pointer			;033
	ADD	#FQPPN,R0	; and point to the PPN			;033
	MOV	#1.,R2		;Set the increment count		;033
	CALL	CREQTB		; and go create the QTB entry		;033
	BCS	360$		;Create failed				;033
	MAP	FIP,DATA	;Otherwise, remap FIP			;033
350$:	RETURN			; and back to caller			;033

360$:	MOV	TOS.R3(SP),R3	;Pick up N.E. pointer for new file	;053
	CALLX	XFL3		;Delete the newly created file		;033
	JMPX	FIEXIT		; and exit, returning the error to the user ;033

GLOBAL	<QTCURR,UNTLVL,FIBFBN>						;033

.DSABL	LSB

GLOBAL	<FIPUNT>



.SBTTL	CONTIGUOUS FILE EXTENDER

;+
; EXTCTG - CONTIGUOUS FILE EXTENDER.
;
;	R0 =  UNIT
;	R3 =  LINK OF ENTRY
;	R4 -> FIRQB
;		FQSIZ  =  DESIRED FILE SIZE LSB
;		FQSIZM =  DESIRED FILE SIZE MSB
;	FIPCLU = File cluster size
;
;	CALL	EXTCTG
;
; All registers are preserved.
;
;	C = 0 indicates successful extend
;	C = 1 indicates no disk space available; file not extended
;-

EXTCTG:	REGSCR			;Keep that promise about registers...	;052
	MOV	#CTGERX,@#FIPERX ;Set FIP error exit			;042
	MOV	SP,@#FIPESP	;Save the current stack pointer		;052
	MOV	FIPCLU,R1	;Get the file cluster size		;052
	MOV	FQSIZ(R4),R5	;GET THE DESIRED FILE SIZE LSB
	MOVB	FQSIZM(R4),R2	;GET THE FILE SIZE MSB
	TST	@#QTCURR	;Did CREATE create a QTB entry?		;033
	BEQ	20$		;No, then no need for quota check	;033
	MOVB	@#FIPUNT,R0	;Get the Fip Unit Number		;033
	ASL	R0		; and make it FUN * 2			;033
	BIT	#UO.NQT,UNTOPT(R0) ;Mounted /Noquota?			;033
	BNE	20$		;Yes, then we won't check the quota	;033
	TSTPRV	EXQTA,@#FIPRVM	;Allowed to exceed quotas?		;042
	BNE	20$		;Yes, then no need to check		;042
	REGSAV			;Save all current register contents	;033
	MOV	R4,R0		;Copy the FIRQB pointer			;033
	ADD	#FQPPN,R0	; and point to the PPN			;033
	MOV	R1,R3		;Copy the file cluster size		;033
	MOV	R5,R1		;Get the file size LSB			;033
	CALLX	CHKQTA		;Will we exceed quota?			;042
	BCC	10$		;No, then continue with extend		;042
	ERROR	QUOTA		; and issue error			;033

10$:	REGRES			;Restore registers			;033
20$:	MOV	R1,R0		;COPY THE CLUSTER SIZE
30$:	ASR	R0		;DIVIDE THE FILE
	BCS	40$		; SIZE BY THE
	;CLC			;  FILE CLUSTER SIZE TO
	ROR	R2		;   GET NUMBER OF CLUSTERS
	ROR	R5		;    NEEDED FOR FILE
	ADC	R5		;     BEING SURE TO ROUND
	ADC	R2		;      UP AS DOUBLE PRECISION
	BR	30$		;       SIZE

40$:	;CLR	R0		;SET NO R.E. CHAIN NOW (R0=0 FROM SHIFTS)
	TST	R2		;IS THERE AN MSB OF NUMBER OF FILE CLUSTERS?
	BNE	160$		;Yes, forget that!			;052
	MOVB	FIPUNT,R0	;Pick up FIP unit #			;051
	ASL	R0		;Make it times two			;051
	MOV	#1,SATPTR(R0)	;Guess at starting from the beginning	;051
	MOV	FQNENT(R4),R2	;Did user ask for a position?		;051
	BEQ	50$		;No, not this time			;051
	MOV	R2,SATPTR(R0)	;Yes, so set up for it			;051

50$:	MOV	R5,R2		;Pick up the number of clusters		;051
	CALLX	GETCL2		;Now allocate that space		;051
	BCS	110$		;No space, get ready to tell our caller	;052
	REGSAV			;Save all registers			;053
	MOVB	DEVCLU(R0),R4	;Got space, get the device clustersize	;051
	CLR	R0		;Set up for divide			;051
	DIV	R4,R0		;Now get # of DCNs between file clusters ;051
	MOV	R0,R1		;And get it into a convenient register	;051

; R1 = Clustersize/DCS (distance between clusters)
; R2 -> Start DCN

	CALLX	GDE		;GET THE FIRST R.E.
	BCS	140$		;NO DIRECTORY SPACE AT ALL!
	MOV	R3,(SP)		;SAVE THE INITIAL R.E. LINK
.ASSUME	TOS.R0	EQ	0
	MOV	TOS.R5(SP),R4	;GET A COUNT OF NUMBER OF CLUSTERS
	BR	70$		;BUILD THE R.E. CHAIN

GLOBAL	<SATPTR,DEVCLU>							;051

60$:	BIT	R5,#20-1	;MORE SPACE IN THIS R.E.?
	BNE	80$		;YES, SO USE IT
	CALLX	GDE		;NO, GET ANOTHER R.E.
	BCS	120$		;FAILED...
	MOV	R3,R0		;GOT IT, SAVE ITS LINK
	MOV	(SP)+,R3	;NOW GET LINK OF PREVIOUS R.E.
	CALLX	RDE		; AND READ IT
	MOV	R0,@(SP)+	;LINK NEW R.E. TO PREVIOUS R.E.
	MOV	R0,R3		;RESTORE LINK TO NEW R.E.
	CALLX	RDESV		; AND READ IT BACK AGAIN
70$:	MOV	R5,-(SP)	;SAVE POINTER TO LINK LOCATION AND
	MOV	R3,-(SP)	; SAVE LINK OF THIS R.E.
	CLR	(R5)+		;NO LINK NEXT YET
80$:	MOV	R2,(R5)+	;SET A RP (DCN) IN THE R.E.
	MARK	FIBUF		; AND MARK BUFFER FOR WRITE
	ADD	R1,R2		;NOW BUMP TO THE NEXT DCN
	SOB	R4,60$		;LOOP FOR ALL ENTRIES NEEDED
	CMP	(SP)+,(SP)+	;POP THE POINTER/LINK
	REGRES			;Restore our registers
	MOV	R3,R2		;SAVE THE N.E. LINK THEN		;052
	CALLX	RDE		; READ THE N.E.
	MOV	R0,UAR(R5)	;LINK THE R.E. CHAIN TO N.E.
	BISB	#US.NOX,USTAT(R5) ; AND SAY FILE IS CONTIGUOUS
	CALLX	RAESV		;READ ACCOUNTING ENTRY
	CMP	(R5)+,(R5)+	;POINT TO SIZE WORD
.ASSUME	USIZ	EQ	4
	MOV	FQSIZ(R4),(R5)	;Set the LSB of the file size		;052
	ADD	#UCLUS-USIZ,R5	;Point to clustersize			;052
	MOV	FIPCLU,(R5)	;And set it				;052
	MOVB	FQSIZM(R4),R0	;GET THE SIZE MSB
	BEQ	90$		;NO RTS NAME CHANGE IF ZERO MSB
	MOV	R0,-(R5)	;Set MSB filesize			;052
	CLR	-(R5)		;And indicate this is a large file	;052
90$:	MARK	FIBUF		;MARK BUFFER FOR WRITE
	MOV	R2,R3		;RESTORE THE N.E. LINK
	MOVB	@#FIPUNT,R0	;RESTORE THE FIP UNIT NUMBER
	TST	@#QTCURR	;Is there a QTB entry?			;033
	BEQ	100$		;No					;033
	MOV	R4,R0		;Copy the FIRQB pointer			;033
	ADD	#FQPPN,R0	; and point to the PPN			;033
	MOV	FQSIZ(R4),R1	;Get the file size LSB			;033
	MOVB	FQSIZM(R4),R2	; and file size MSB			;033
	MOV	FQCLUS(R4),R3	;  and the file cluster size		;033
	CALLX	ADDUSG		;Now update the usage in the QTB	;033
100$:	CLR	@#FIPERX	;Clear the FIP error exit		;033
	;CLC			;Clear carry for goodness		;052
	RETURN			;And we're done				;052

; If we get here, free space could not be found to create the file.

110$:	MOV	FIPESP,SP	;Clean up the stack			;052
	CLR	@#FIPERX	;Clear the FIP error exit		;052
	SEC			;Indicate failure 			;052
	RETURN			;And we're done				;052

; We get here if we are unable to extend the directory to handle the
; new retrieval entries.

120$:	CMP	(SP)+,(SP)+	;NO MORE ROOM IN UFD. POP LINK AND POINTER
	MOV	(SP),R3		;GET BACK LINK TO FIRST R.E.
.ASSUME	TOS.R0	EQ	0
130$:	CALLX	RDECHK		;TRY FOR THE NEXT R.E.
	BEQ	140$		;NO MORE
	CALLX	ZDENXT		;ZERO IT, SAVING LINK TO NEXT
	BR	130$		;LOOP FOR MORE

140$:	MOV	R1,(SP)		;R.E.'S ARE GONE, PREPARE TO RETURN CLUSTERS
.ASSUME	TOS.R0	EQ	0	;SAVE DELTA FOR DCN'S IN R0
	CALLX	REGRES,R5	;RESTORE TO GET DELTA, CLUSTER SIZE, AND DCN
150$:	CALLX	RETCLU		;RETURN A CLUSTER TO THE SYSTEM
	ADD	R0,R2		;NOW GO TO THE NEXT DCN
	SOB	R5,150$		;LOOP FOR ALL SPACE ALLOCATED
160$:	ERROR	NOROOM		;Not enough directory space		;052

CTGERX:	MOV	@#FIPESP,SP	;Restore the stack			;052
	MOV	<3+1>*2(SP),R3	;Get back saved N.E. link (from REGSCR)	;052
	CALL	DELNEW		;Delete the new file and return the QTB ;042
	;CLR	@#FIPERX	;DELNEW clears FIPERX			;052
	JMPX	FIEXIT		;Exit now, returning the error to the user ;042

GLOBAL	<FIPUNT,FIPERX,FIPESP>						;042


.SBTTL	Handle delayed close

;+
; DECFQ - Handle a delayed close function
;
;	R4 -> FIRQB (really a DSQ)
;		FQPPN -> WCB to close		
;
; The first byte of the WCB contains the following data:
;
;	BIT 0 - Set to indicate reset type close, else close type close
;	BIT 1 - Channel number
;	BIT 2 - Channel number
;	BIT 3 - Channel number
;	BIT 4 - Channel number
;	BIT 5 - Reserved
;	BIT 6 - Reserved
;	BIT 7 - Will always be set (used as flag in SYDLRG)
;
; This function is used to perform a close when the initial close operation
; could not succeed do to outstanding asynchrouous I/O.
;-

FQFENT	DEC,,,PHASE		;Delayed close				;044

	MOV	#1,@#FIPERX	;Indicate no JDIOST error posting	;044
	MOV	FQPPN(R4),R1	;Pick up WCB pointer			;044
;	MOVB	#RSTFQ,FQFUN(R4) ;Guess at a reset (FQFUN<>0)		;044
	BITB	#1,(R1)		;Good guess?				;044
	BNE	10$		;Yes, sure is				;044
	CLRB	FQFUN(R4)	;No, set up for a close			;044
.ASSUME	CLSFQ	EQ	0
10$:	BICB	#^C<15.*2>,(R1)	;Trim all but channel number		;044
	MOVB	(R1),FQFIL(R4)	;Set up the channel number		;044
	CALL	DOCLOS		;Now go and close the channel		;044
	MOV	FIQUE,R4	;Pick up our FIRQB pointer		;044
	MOV	(R4),-(SP)	;Requeue the FIP queue			;044
	MOV	SP,FIQUE	;Through the FIP stack			;044
	BUFFER	RETSML		;Now give back this DSQ			;044
	JMPX	FIEXIX		;And get out (skipping JSFIP)		;044

GLOBAL	<FIPERX>							;044

.SBTTL	RESET OPEN CHANNEL(S)

;+
; RSTFQ - RESET OPEN CHANNEL(S).
;
;	R4 -> FIRQB
;		FQFIL  =  0  => RESET ALL CHANNELS
;		          N  => RESET CHANNEL N/2
;		          -N => RESET ALL BUT CHANNEL N/2
;-

	FQFENT	RST,,<>,PHASE	;RESET CHANNEL(S)

RESET:	MOVB	FQFIL(R4),R0	;GET TYPE OF "RESET" TO DO
	BGT	CLOSE		;RESET CLOSE ONLY ONE CHANNEL
	NEGB	R0		;RESET ALL OR ALL BUT ONE CHANNEL
RESETA::MAP	FIPPOL		;Be sure that FIP is mapped correctly	;045
	MOV	#15.*2,FQFIL(R4) ;START AT CHANNEL 15.
10$:	CMPB	R0,FQFIL(R4)	;SKIP THIS CHANNEL??
	BEQ	20$		;YES, SO SKIP IT
	CALL	CLOSE		;NO, RESET CLOSE THIS CHANNEL
20$:	SUB	#1*2,FQFIL(R4)	;GO TO THE NEXT LOWER CHANNEL PLEASE
	BNE	10$		;NOT TO CHANNEL #0 YET, SO CONTINUE
	.BR	CLOSE		;CHANNEL #0, FALL THROUGH TO CLOSE

.SBTTL	CLOSE AN OPEN CHANNEL

;+
; CLSFQ - CLOSE AN OPEN CHANNEL.
;
;	R4 -> FIRQB
;		FQFIL  =  CHANNEL NUMBER TIMES 2
;-

CLOSE::	MAP	FIPPOL		;Be sure FIP is mapped correctly	;045
                
	FQFENT	CLS,,<>,PHASE	;CLOSE A CHANNEL

.ENABL	LSB

	REGSCR			;SAVE ALL REGISTERS			;045
	CALL	INI		;GET THE SCB/DDB POINTER		;036
	BEQ	40$		;IF CLOSED THIS IS A NOP
	TSTB	FQFIL(R4)	;IF CHANNEL #0 THEN
	BEQ	40$		;ALSO A NOP
	CLR	(R5)		;REMOVE FROM THE I/O BLOCK
	MOV	R1,R5		;PUT DDB ADDRESS INTO R5 ALSO
	MOVB	(R1),R2		;GET THE DRIVER INDEX
	MOV	$CLSTBL(R2),R0	;PICKUP ADDRESS OF CLOSE ROUTINE
	BIT	R0,#1		;CHECK FOR SPECIALS (ODD)
	BEQ	20$		;EVEN SO WE HAVE A REAL ADDRESS
	ADD	#90$-1-10$,R0	;ODD, SO CORRECT FOR THE
	ADD	PC,R0		; ABSOLUTE DISPATCH ADDRESS
10$:				;REFERENCE ONLY
	TSTB	FQFUN(R4)	;SET Z=1 IF A REAL CLOSE
.ASSUME	CLSFQ	EQ	0
	CALL	(R0)		;CALL THE NON-RESIDENT CLOSE ROUTINE
	BR	30$		;NOW FINISH UP

20$:	MOVB	@#FIJOB,R3	;Pick up caller's job # * 2		;056
	CALLX	OPNCLS		;CALL FOR CLOSE DISPATCHING
30$:	MOV	R5,R1		;PUT DDB ADDRESS INTO R1
	CMPB	DDJBNO(R1),@#FIJOB ;IS THE DEVICE REALLY OWNED?
	BNE	40$		;NOPE, SKIP THE BELOW
	DECB	DDCNT(R1)	;DECREASE THE ACCESS COUNT
	CALLX	RETDEV		; AND RETURN THE DEVICE
40$:	RETURN			;EXIT


GLOBAL	<$CLSTBL,FIJOB>							;044

; MAGTAPE CLOSER

CLOSMT:	BEQ	50$		;NORMAL CLOSE
	MOV	MTACB+MTDDSP(R5),R1 ;RESET CLOSE, GET ACB ADDRESS
	BEQ	40$		;NONE, JUST EXIT
	CLR	MTACB+MTDDSP(R5) ;ONE, CLEAR THE POINTER NOW
	BR	70$		;EXIT RETURNING THE ACB

50$:	FJMPDV	MT,CLS		;DO A REAL MAGTAPE CLOSE

; DECTAPE CLOSER

CLOSDT:	MOV	DTFDDB(R1),R5	;GET REAL DDB ADDRESS INTO R5
	SUB	#DTDDSP,R5	;GET THE REAL POINTER
	BIT	#DT.CTG!DDWLO!DDNFS,(R1) ;WAS THIS A LINKED OUTPUT FILE?
	BNE	60$		;NO, NOT POSSIBLE
	TSTB	FQFUN(R4)	;IS THIS THE REAL CLOSE?
	BEQ	80$		;YES, GO DO IT CLEANLY
	MOVB	#-1,DTOFIL+DTDDSP(R5) ;NO, RESET OUTPUT TO NOTHING OPEN
60$:	BIC	#DDSTAT,(R5)	;CLOSE POSSIBLE NFS OPEN (ONLY ONE!)
70$:	JMP	280$		; AND RETURN THE FCB

80$:	FJMPDV	DT,CLS		;REAL, DO A DECTAPE CLOSE

;+
; DECTAPE CLOSE - ENTRY CONDITIONS.
;
;	R1 -> SCB
;	R4 -> FIRQB
;	R5 -> DDB @ DDIDX
;-

; DISPATCHERS (NOTE - ORDER IS IMPORTANT HERE)

	BR	CLOSMT		;MT: CLOSE ($CLSTBL = -4+1 IMPLIES -4 OFFSET)

	BR	CLOSDT		;DT: CLOSE ($CLSTBL = -2+1 IMPLIES -2 OFFSET)

90$:	.BR	CLOSSY		;SY: CLOSE ($CLSTBL = -0+1 IMPLIES -0 OFFSET)

; DISK FILE CLOSER
;
; Caution: This routine will return to the caller's caller, not the
; caller. Consider yourself warned!
;
;	R1 -> WCB
;	R4 -> FIRQB

CLOSSY:	TST	(SP)+		;Dump the return address		;044
	TSTB	W$PR(R1)	;Do we have pending I/O?		;044
	BEQ	DOCLOS		;No, so we can do this now		;044
	MOVB	FQFIL(R4),(R1)	;Pending I/O, set pending close	channel # ;044
	TSTB	FQFUN(R4)	;Really a close?			;044
.ASSUME	CLSFQ	EQ	0						;044
	BEQ	100$		;Yes, so all set up			;044
	INCB	(R1)		;No, reset, set the flag		;044
100$:	RETURN			;And we're done now			;044

DOCLOS:	MOV	W$FCB(R1),R3	;GET THE FCB POINTER FROM WCB @F$CLUS	;044
	MOVB	F$UNT-F$CLUS(R3),R0 ;GET THE UNIT NUMBER
	ASL	R0		;NOW TIMES TWO
	DEC	UNTCNT(R0)	;ONE LESS OPEN FOR THIS UNIT NOW
	MOV	R3,-(SP)	;SAVE IT FOR LATER
	MOV	R0,-(SP)	;AND THIS GUY ALSO
	TSTB	FQFUN(R4)	;RESET THE TYPE OF CLOSE FLAG
	BNE	110$		;DON'T UNDELETE TENTATIVES ON RESET
	BIT	#WC$UPD,(R1)	;REAL CLOSE, IS IT OPEN UPDATE?
	BNE	110$		;YES, CAN'T BE TENTATIVE CREATION
	BIT	#WC$SPU,W$WCB(R1) ;NOT UPDATE, IS IT TENTATIVE?
	BEQ	110$		;NOPE, NORMAL CLOSE
	TST	F$NAM-F$CLUS(R3) ;Dummy file?				;022
	BEQ	110$		;Yes, those are never made permanent	;022
	CALL	CLOSTE		;CLOSING TENTATIVE, GO DELETE OLD COPY
110$:	MOV	(SP)+,R0	;GET UNIT NUMBER TIMES TWO
	MOV	(SP)+,R3	;AND RESTORE FCB POINTER
	MOV	R3,R4		;COPY IT
	TST	(R3)+		;INDEX TO F$WCB				;044
.ASSUME	F$WCB EQ F$CLUS+2						;019
	BIT	#DDNFS,(R1)	;NFS?
	BEQ	120$		;No, do normal file close		;033
	JMP	310$		;YES, GO DO NFS CLOSE			;033

120$:	MOV	#40-1,R2	;GET A HANDY CONSTANT
130$:	MOV	R3,R5		;COPY POINTER TO PREVIOUS
	MOV	(R5),R3		;POINT TO NEXT WCB IN THE LIST
	BIC	R2,R3		;CLEAR FLAGS TO POINT TO START OF WCB
	ADD	#W$WCB,R3	; AND INDEX TO THE THREAD WORD
	CMP	(R3),W$WCB(R1)	;IS LINK HERE OUR LINK (I.E. IS THIS US)?
	BNE	130$		;NO, LOOK HARDER (CAN'T FAIL!)
	MOV	(R3),-(SP)	;SAVE LINK TO NEXT WCB
	BIC	R2,(SP)		; TRIM FLAGS
	BIC	R1,(R5)		;REMOVE ADDRESS PART OF LINK TO OUR WCB
	BIS	(SP)+,(R5)	; AND RELINK PREVIOUS WCB TO NEXT
	CLR	R5		;GET CONSTANT FOR ACCESS COUNT DOWN
	ASR	(R3)		;ARE WE OPEN READ REGARDLESS?
.ASSUME	WC$RR	EQ	1
	SBCB	R5		;YES, SET TO DECREMENT R-R COUNT
140$:	INC	R5		;GET COUNT OF 1 IN LOW OR HIGH BYTE
	ADD	#F$ACNT-F$CLUS,R4 ;POINT TO THE ACCESS COUNTS
	SUB	R5,(R4)		;ONE LESS OPEN OF THIS FILE
	BNE	170$		;STILL OPEN, CHECK FOR GIVING BACK WRITE
	BIC	R2,R4		;Last one, back to start of FCB		;022
	ADD	#FCBLST,R0	;POINT TO THE LIST OF FCB'S ON THIS UNIT
	BR	160$		;GO LOOK FOR IT

GLOBAL	<UNTCNT>							;042

150$:	MOV	(R0),R0		;NEXT IN LIST
160$:	CMP	R4,(R0)		;ARE WE AFTER THIS FCB?
	BNE	150$		;NO, LOOK MORE (CAN'T FAIL!)
	MOV	(R4),(R0)	;YES, UNLINK US FROM THE LIST
	TSTB	F$STAT(R4)	;IS THE FILE MARKED FOR DELETE?
	BPL	200$		;NO, UPDATE DATE/SIZE IF NEEDED AND FINISH
	BR	240$		;Yes, go return buffers and delete the file ;033

170$:	TST	(R1)		;TIME TO TURN OFF "US.WRT"?
	BPL	180$		;NO
.ASSUME	WC$USE	EQ	100000
	BICB	#US.WRT,F$STAT-F$ACNT(R4) ;YES, INDICATE NO WRITE GIVEN OUT
180$:	TSTB	(R4)		;ANY NORMAL OPEN(S) LEFT?
	BNE	190$		;YES
	BIC	#US.UPD,-(R4)	;NO, SO CAN'T BE UPDATE ANYMORE
190$:	BIC	R2,R4		;BACK UP TO START OF FCB
200$:	MOV	W$FLAG-1(R1),R3	;GET OPEN FLAG BITS
	BIC	(R1),R3		;TURN OFF WC$DLW IF WC$UFD IS ON
	BIT	R3,#WC$DLW*400	;SHOULD WE UPDATE SIZE AND DATE?
.ASSUME	WC$DLW*400 EQ	WC$UFD
	BEQ	240$		;NOT IF UFD OR NOT NEEDED
	BIC	#^C<1>,@#FIPERX	;Save caller's error posting indication	;044
	BIS	#CLSERX,@#FIPERX ;Set a FIP error exit			;044
	MOV	R1,-(SP)	;Save the WCB -> incase of I/O failure	;042
	MOV	R4,-(SP)	;Same goes for the FCB ->		;042
	MOV	SP,@#FIPESP	;Remember our current stack value	;042
	CALLX	RNE		;YES, GET THE NAME ENTRY
	CALLX	RAE		;FROM IT, GET THE ACCOUNTING ENTRY
	CALLX	DATEIT		;SET DATE OF LAST WRITE
	CMP	(R5)+,(R5)+	;POINT TO USIZ WORD
.ASSUME	USIZ	EQ	4
	MOVB	F$SIZM(R4),R3	;GET SIZE MSB
	BEQ	210$		;NO MSB SIZE, SO IT CERTAINLY MATCHES
	CMPB	R3,URTS+2-USIZ(R5) ;DOES MSB SIZE MATCH?
	BNE	220$		;NO, IT MUST CHANGE
	TST	URTS-USIZ(R5)	;YES, IS IT REAL?
	BNE	220$		;NOPE, MUST UPDATE NEW LARGE SIZE
210$:	CMP	F$SIZL(R4),(R5)	;MSB MATCHES, IS LSB SIZE UNCHANGED?
	BEQ	230$		;YUP, NO NEED TO REWRITE NEW SIZE	;042
220$:	MARK	FIBUF		;ENSURE BUFFER IS REWRITTEN
	MOV	F$SIZL(R4),(R5)+ ;SAVE NEW SIZE
	TSTB	R3		;IS THERE AN MSB?
	BEQ	230$		;NO, NO CHANGE				;042
	CMP	(R5)+,(R5)+	;YES, INDEX TO RTS FIELD
	CLR	(R5)+		;FLAG A LARGE FILE
	MOVB	R3,(R5)		; AND SET SIZE MSB
230$:	MOV	(SP)+,R4	;Restore the FCB ->			;042
	MOV	(SP)+,R1	; along with the WCB ->			;042

GLOBAL	<FIPERX,FIPESP>							;042


240$:	REGSAV			;Save all current register contents	;033
	MOVB	F$UNT(R4),R0	;Get the Fip Unit Number		;033
	ASL	R0		; and make it FUN * 2			;033
	BIT	#UC.WLO,UNTCNT(R0) ;Unit write locked?			;033
	BNE	250$		;Yes, no QTBs then			;033
	CMP	UNTLVL(R0),(PC)+ ;Support extended quota data?		;033
	 .BYTE	2,1							;033
	BLO	250$		;No, then no QTB to check		;033
	BIT	#WC$UFD,(R1)	;Is this a UFD?				;033
	BNE	250$		;Yes, then ignore this file		;033
	ASR	R0		;Make it just FUN			;033
	MOV	R0,@#FIPUNT	; and set the Fip Unit Number		;033
	MOV	R4,R0		;Copy the FCB pointer			;033
	ADD	#F$PPN,R0	; and point to the PPN			;033
	CMP	(R0),(PC)+	;Account [0,1]?				;033
	 .BYTE	1,0							;033
	BEQ	250$		;Yes, then no disk quota blockette	;033
	MOV	#1.,R2		;Set the decrement count		;033
	CALL	RETQTB		;Return this QTB (Remaps FIP)		;033
250$:	REGRES			;Restore all register to their old values ;033
	TST	F$ACNT(R4)	;LAST CLOSE?
	BNE	270$		;NOPE, KEEP THE FCB
	TSTB	F$STAT(R4)	;Yes, File marked for delete?		;033
	BPL	260$		;No					;033
	BIC	#^C<1>,@#FIPERX	;Save caller's error reporting flag	;044
	BIS	#CLSER2,@#FIPERX ;Set another alternate error exit	;044
	MOV	R1,-(SP)	;Save the WCB -> incase of I/O failure	;042
	MOV	R4,-(SP)	; and the FCB -> too			;042
	MOV	SP,@#FIPESP	;Save the current stack value		;042
	CALLX	RNE		;Make sure the name entry is resident	;033
	TST	(SP)+		;Junk the saved FCB ->			;042
	MOV	#XFL3,(SP)	; and delete file after returning buffers ;042
260$:	BUFFER	RETSML		;Yes, return the FCB			;022
270$:	BITB	#WC$EXT,W$FLAG(R1) ;IS THERE A WCB EXTENSION?
	BEQ	280$		;NO
	MOV	WCBSIZ(R1),(R1)	;YES, GET THE SIZE OF WCB EXTENSION
	BR	290$		; AND GO INCLUDE THE WCB'S SIZE

280$:	CLR	(R1)		;SIMPLY RETURN A SMALL BUFFER
290$:	ADD	#WCBSIZ,(R1)	;INCLUDE WCB IN SIZE TO RETURN
.ASSUME	WCBSIZ	EQ	40
	MOV	R1,R4		;COPY POINTER TO IT
	BUFFER	RETURN		; AND RETURN IT
300$:	BIC	#^C<1>,@#FIPERX	;Clear the FIP error exit (save flag)	;044
	RETURN			;ALL CLOSED

CLSERX:	MOV	@#FIPESP,SP	;Restore the saved stack pointer	;042
	BR	230$		; and return the buffers		;042

CLSER2:	MOV	@#FIPESP,SP	;Restore the saved stack pointer	;042
	MOV	(SP)+,R4	;Restore the FCB ->			;042
	MOV	(SP)+,R1	; and the WCB ->			;042
	BR	260$		;Now go return those buffers		;042

GLOBAL	<FIPERX,FIPESP,XFL3>						;042

310$:	TST	(R1)		;NFS CLOSE, DID CALLER HAVE THE WRITE-PRIV'S?
	BPL	320$		;NOT THIS CALLER
.ASSUME	SC$USE	EQ	100000
	BIC	#UC.WLO,UNTCNT(R0) ;CALLER DID, RELEASE WRITE AGAIN
320$:	CALL	280$		;RELEASE THE WCB
	CMP	#UC.NFS,UNTCNT(R0) ;IS THIS THE LAST NFS CLOSE?
	BNE	300$		;NO, SO JUST EXIT
	MOV	R0,R1		;YES, SET UNIT TIMES TWO HERE
	CALLRX	ZAPUNT		; AND EXIT ZAPPING THE UNIT

.DSABL	LSB

GLOBAL	<UNTCNT,FIPERX,FIPESP,FIPUNT,UNTLVL>				;042



.SBTTL	CLOSE TENTATIVE ENTRY

CLOSTE:	BIC	#^C<1>,@#FIPERX ;Save caller's error return flag	;044
	BIS	#40$,@#FIPERX	;SET UP ERROR TRAP			;044
	MOV	R1,-(SP)	;JUST IN CASE OF AN ERROR
	MOV	SP,@#FIPESP	;AND SAVE STACK POINTER FOR ERROR TRAPPER
	MOV	W$FCB(R1),R0	;GET POINTER TO FCB
	MOVB	F$UNT-F$CLUS(R0),R0 ;GET UNIT FROM FCB
	MOV	R0,-(SP)	;SAVE UNIT NUMBER
	ASL	R0		;DOUBLE IT FOR WORD ADDRESS
	BIT	#UC.PRI,UNTCNT(R0) ;IS THIS A PRIVATE PACK?
	BNE	10$		; YES, GO SET UP CORRECT UNIT FOR SEARCH
	MOVB	@#SYSUNT,(SP)	; NO, SO SET SYSUNT AS UNIT TO SEARCH
	COMB	1(SP)		;  AND FIPGEN (HIGH BYTE) TO GENERAL SEARCH
10$:	MOV	(SP),@#FIPUNT	;SET THE UNIT AND FIPGEN FLAG TO SEARCH WITH
	MOV	W$FCB(R1),R0	;POINT TO THE FCB
	ADD	#F$PPN-F$CLUS,R0 ; AT THE PPN-NAME-EXT ENTRY
	CALLX	SDU		;SEARCH FOR ANY OLD COPY OF THE FILE
	BCS	20$		;NONE, SO THIS IS EASY
	;CLC			;C=0 FROM 'BCS'
	BITB	#US.NOK,USTAT(R5) ;CAN WE DELETE IT?			;022
	BNE	20$		;NOPE, ERROR (AND RENAME THE TENTATIVE)
	MOV	R1,-(SP)	;Save FCB pointer			;022
	MOV	(R0),R0		;Get PPN				;022
	MOVB	UPROT(R5),R1	;Get protection code of duplicate	;022
	CALLX	CHKACC		;Check access rights to it		;022
	MOV	(SP)+,R1	;First restore FCB pointer		;022
	BIT	#DDWLO,R0	;Do we have delete rights?		;022
	BNE	20$		;No, so don't delete it			;022
	MOVB	@#FIPUNT,R0	;GET THE UNIT NUMBER OF THE DUPLICATE
	ASL	R0		; * 2
	BIT	#UC.WLO,UNTCNT(R0) ;IS THE PACK WRITE LOCKED?
	BNE	20$		;YES, ERROR HERE
	CALLX	XFL		;DELETE THE OLD COPY OF THE FILE
	BR	10$		; AND TRY AGAIN

	GLOBAL	<UNTCNT,FIPGEN,FIPUNT,SYSUNT,FIPERX,FIPESP>

20$:	ROR	(SP)		;CLOBBER UNIT, SAVE ERROR FLAG
	CALLX	RNE		;READ THE TENTATIVE'S NAME ENTRY
	ADD	#USTAT,R5	;POINT TO STATUS BYTE
	BICB	#US.DEL,(R5)	; AND UNDELETE THE FILE
	MARK	FIBUF		;INDICATE THE CHANGE
	MOV	W$FCB(R1),R0	;GET POINTER TO FCB
	BICB	#US.DEL,F$STAT-F$CLUS(R0) ;MARK IT AS NOT DELETED NOW
	ROL	(SP)+		;ERROR HERE?
	BCS	50$		;NOPE, RETURN TO FINISH THE CLOSE
	BIT	#1,@#FIPERX	;Can we return errors?			;044
	BNE	30$		;No, that's the price he pays		;044
	MOV	@#FIJBDA,R0	;YES, POINT TO JOB'S JDB
	SETERR	PRVIOL,JDIOST(R0) ; AND SET AN ERROR FOR HIM
30$:	MOV	#^RTMP,-(R5)	;RENAME THE FILE TO TM?NNN.TMP. SET EXTENSION
	MOV	#^R000,-(R5)	;SET A BLANK FOR THE JOB NUMBER
	MOVB	@#FIJOB,R3	;GET JOB NUMBER * 2
	CLR	R2		;CLEAR FOR DIVIDE
	ASR	R3		;WE WANT JOB * 1
	DIV	#10.,R2		;CONVERT TO DECIMAL
	ADD	R3,(R5)		;ADD UNITS DIGIT
	MUL	#50,R2		;SHIFT TENS DIGIT FOR RAD50
	ADD	R3,(R5)		; AND ADD THAT, TOO
	CLR	-(R5)		;CLEAR OUT FIRST WORD OF NAME
	MOVB	FQFIL(R4),(R5)	;SET UP CHANNEL TIMES 2
	ASR	(R5)		; AND MAKE IT TIMES 1
	ADD	#^RTMA,(R5)	;SET THIRD LETTER AS CHANNEL INDICATOR
	MOV	W$FCB(R1),R0	;R0 -> FCB for tentative file @ F$CLUS	;031
	ADD	#F$NAM-F$CLUS,R0 ;R0 -> FCB for tentative file @ F$NAM	;031
	MOV	(R5)+,(R0)+	;Copy the first part of the new name	;031
	MOV	(R5)+,(R0)+	;Now the second part of the new name	;031
	MOV	(R5)+,(R0)+	;Now finally copy the file type		;031
	BR	50$		;ALL DONE

40$:	MOV	@#FIPESP,SP	;RESET THE STACK POINTER ,NO ROSE GARDEN HERE
	MOV	@#FIJBDA,R0	;YES, POINT TO JOB'S JDB
	SETERR	ABORT,JDIOST(R0) ;AND SET A VERY FATAL TYPE ERROR FOR HIM
50$:	MOV	(SP)+,R1	;AND RESTORE R1, HOPE WE DIDN'T NEED IT
	BIC	#^C<1>,@#FIPERX	;Clear error trap, save flag		;044
	RETURN			;AND GO AWAY


	GLOBAL	<FIJBDA,FIJOB,FIPERX,FIPESP>


.SBTTL	NON-DISK DEVICE OPENER

;+
; OPENDV - DO A NON-DISK DEVICE OPEN.
;
;	R1 -> DDB
;	R4 -> FIRQB
;	I/O CHANNEL IS NOT ALREADY OPEN
;-

OPENDV:	MOV	@#FIJBDA,R3	;GET CALLER'S JOB DATA POINTER
	MOVB	#OPNFQ,JDPOST(R3) ;ENSURE GENERAL DEVICE OPEN POSTING
	CMPB	(R1),#IDX.PK	;Is this a pseudo keyboard?		;062
.ASSUME	DDIDX	EQ	0
	BEQ	10$		;Yes, don't grab those here		;062
	CALLX	GETDEV		;GRAB THE DEVICE FOR USER
10$:	MOVB	(R1),R2		;GET DRIVER INDEX			;062
	MOV	$OPNTBL(R2),R0	; AND FROM THAT THE OPEN ROUTINE
	BIT	R0,#1		;EVEN IS RESIDENT ROUTINE
	BNE	30$		;ODD IS NON-RESIDENT ROUTINE
	MOV	$FLGTBL(R2),FQFLAG(R4) ;SET DEFAULT FLAGS
	MOV	$BUFTBL(R2),FQBUFL(R4) ;SET DEFAULT BUFFER SIZE
	MOVB	@#FIJOB,R3	;Get ready to pass job # * 2 to device	;056
	CALLX	OPNCLS		;CALL FOR OPEN DISPATCH
	INCB	DDCNT(R1)	;ONE MORE FILE OPEN ON DEVICE
	MOV	R1,(R5)		;SET IOB FOR OPEN CHANNEL
	RETURN			; AND EXIT

20$:	ERROR	NOTCLS		;ERROR IF CHANNEL NOT CLOSED

30$:	INC	R0		;MAKE -2+1 INTO 0 (DT), -4+1 INTO -2 (MT)
	SUB	R0,PC		;DISPATCH TO OPEN DECTAPE OR MAGTAPE
	 BR	OPENDT		;DT: OPEN ($OPNTBL = -2+1 +1 GIVES  0 OFFSET)
	.BR	OPENMT		;MT: OPEN ($OPNTBL = -4+1 +1 GIVES -2 OFFSET)

OPENMT:	FJMPDV	MT,OPN		;DO A MAGTAPE OPEN

OPENDT:	FJMPDV	DT,OPN		;DO A DECTAPE OPEN

GLOBAL	<$OPNTBL,$FLGTBL,$BUFTBL,FIJBDA,FIJOB>				;056

;+									;027
; UU.ONX - Open next file matching specification			;027
;									;027
;	R4 -> FIRQB							;027
;		FQFIL    =  Channel number times two			;027
;		FQPPN    =  PPN ( 0 means self)				;027
;		FQNAM1   =  File name, may include wildcards		;027
;		FQEXT    =  File type					;027
;		FQMODE   =  Open mode					;027
;		FQDEV,FQDEVN = Device to use ( 0 means public)		;027
;									;027
;	Open next disk file modes:					;027
;									;027
;	     1	    1.	 0	Update mode				;027
;	     2	    2.	 1	Append					;027
;	     4	    4.	 2	Special update mode (with bit 0)	;027
;	    10	    8.	 3	Always update file size			;027
;	    20	   16.	 4	Don't update access dates (and no write access) ;027
;	    40	   32.	 5	Never grant read/write access to file	;027
;	   400	  256.	 8	User data caching			;027
;	  4000	 2048.	11	User data caching is sequential		;027
;	 10000	 4096.	12	Read regardless				;027
;	 20000	 8192.	13	Read-only mode				;027
;	 40000	16384.	14	Return marked-for-delete files		;031
;	100000	32768.	15	Mode is "real" indicator		;027
;									;027
;	IN FIRQB ON RETURN						;027
;		FQFIL    =  SAME AS PASSED				;027
;		FQSIZM   =  FILE SIZE MSB				;027
;		FQPPN    =  PPN						;027
;		FQNAM1   =  FILE NAME (2 WORDS)				;027
;		FQEXT    =  EXTENSION					;027
;		FQSIZ    =  FILE SIZE LSB				;027
;		FQBUFL   =  Date of last access/write			;027
;		FQMODE   =  Date of creation				;027
;		FQFLAG   =  Time of creation				;027
;		FQPROT-1 =  FILE CLUSTER SIZE (MOD 400)			;027
;		FQPROT   =  PROTECTION CODE				;027
;		FQDEV,FQDEVN = PHYSICAL DISK DEVICE NAME		;027
;		FQCLUS   =  FILE ID					;027
;		FQNENT   =  File flags					;027
;-									;027

	UUOENT	ONX,,,LOGABL,,,PHASE					;027

	MOVB	#LOKFQ,FQFUN(R4) ;Pretend that this is directory lookup	;027
	CLR	FQSWIT(R4)	;SIGNAL THIS IS A NORMAL OPEN		;027
	TST	FQMODE(R4)	;IS THERE A REAL MODE?			;027
	BMI	10$		;YES					;027
	CLR	FQMODE(R4)	;NO, SO ENSURE NO MODE			;027
10$:	BIT	#3300,FQMODE(R4) ;Asking for unknown modes?		;040
	BNE	30$		;Yes, reject				;040
	TST	FQPPN(R4)	;User specify a PPN?			;027
	BNE	20$		;Yes, that's good			;027
	MOV	FIUSER,FQPPN(R4) ;No, so use the caller's		;027
20$:	CALLX	GUN,R5		;Check out the device type		;027
	 BR	40$		;Disk, so this is open first		;027
	ERROR	DEVNFS		;Non-disk, open next isn't valid	;027

30$:	ERROR	PRVIOL		;Unknown mode bits specified		;040

40$:	MOV	R1,R2		;Save pointer to unit's status		;027
	CALL	INI		;Is channel already open?		;036
	BEQ	80$		;Not open, must be open first		;027
	BIT	#DDNFS!WC$UFD!377,(R1) ;Open, is this an open next of a file? ;027
.ASSUME	W$IDX	EQ	0						;027
	BNE	50$		;No, so error				;027
	MOV	W$FCB(R1),R3	;Get the pointer to the FCB @ F$CLUS	;027
	CMP	F$PPN-F$CLUS(R3),FQPPN(R4) ;Does PPN match?		;027
	BNE	50$		;No, so error				;027
	CMPB	F$UNT-F$CLUS(R3),FIPUNT ;Same FIP unit number?		;027
	BEQ	70$		;Yes, that's OK (and FIPGEN is correct)	;027
	TSTB	FIPGEN		;Different, is this a public disk request? ;027
	BEQ	50$		;No, so this is an error		;027
	MOVB	F$UNT-F$CLUS(R3),R0 ;Pick up FIP unit number		;027
	ASL	R0		;Now make it times two			;027
	BIT	#UC.PRI,UNTCNT(R0) ;Is the current file open on a public disk? ;027
	BEQ	60$		;Yes, this is OK			;027
50$:	ERROR	BADFUO		;Tell them ?Illegal SYS usage		;027

60$:	MOVB	F$UNT-F$CLUS(R3),FIPUNT ;Now set up current unit number	;027
70$:	MOVB	FIPGEN,-(SP)	;Save general flag			;031
	CALLX	RNE		;Read the name entry of this file	;031
	MOVB	(SP)+,FIPGEN	;Restore general flag			;031
	MOV	#NOFNXT,FIPERX	;Now set the special error exit		;027
	BR	90$		;Now join up				;027

80$:	CLR	R5		;This is open first, indicate directory start ;040
90$:	MOV	R4,R0		;Copy work block pointer		;027
	ADD	#FQPPN,R0	;And advance to FQPPN			;027
	MOV	#1,R1		;Indicate we want first file		;027
	CALL	FNDFIL		;Now do the lookup			;027
	CMP	(R5)+,(R0)+	;Advance to name in work block & name entry ;027
	MOV	(R5)+,(R0)+	;Set up name part 1			;027
	MOV	(R5)+,(R0)+	; And part 2				;027
	MOV	(R5)+,(R0)+	;And file type				;027
	SUB	#10,R5		;Now point back to start of name entry	;027
	MOVB	FIPUNT,R0	;Pick up specific unit number		;027
	CALLX	SNE		;Now look for the file's FCB		;027
	BNE	110$		;Got one, that's good			;027
	MOV	R4,-(SP)	;Save work block pointer		;027
	CALLX	SCNPRU		;See if the file is installed		;027
	BCS	100$		;Not installed, oh well			;027
	MOV	#1,R1		;Installed, so set that flag		;027
	MOV	R4,R3		;Set up the address of the extended FCB	;027
100$:	MOV	(SP)+,R4	;Now restore work block pointer		;027
110$:	BIC	#OP$MDL,FQMODE(R4) ;Don't pass marked-for-delete open mode ;031
	JMP	OPENFS		;Now open the file			;027

GLOBAL	<FIPUNT,FIPGEN,FIJBDA,FIPERX,FIUSER,PAKLCK,FIPRVM>		;027

;+									;027
; NOFNXT - No file found error trap for open next			;027
;									;027
;	R0 = Returned error code (better be NOSUCH)			;027
;									;027
; We come here if a file wasn't found matching the specification passed	;027
; to UU.ONX and this was open next (as opposed to open first).		;027
;									;027
; We clear FIP's error exit, make sure that this is NOSUCH, and		;027
; if so, close the channel. Other errors are reported back to the caller. ;027
;-									;027

NOFNXT:	CLR	FIPERX		;Turn off our error exit		;027
	MOV	#FISTAK-2,SP	;Clean stack (w/ return to FIEXIT)	;027
	CMPB	R0,#NOSUCH	;Is this the error we expected?		;027
	BNE	10$		;No, this is something strange		;027
	MOV	FIQUE,R4	;R4 -> Work block in FIP		;043
	CLRB	FQFUN(R4)	;Function code is close			;027
.ASSUME	CLSFQ	EQ	0						;027
	CALLR	CLOSE		;Now do the close			;027

10$:	RETURN			;Go and return this unknown error code	;027

GLOBAL	<FIPERX,NOSUCH,FIJBDA,FISTAK>					;027

;+									;027
; FNDFIL - Find a file matching a wildcard specification		;027
;									;027
;	R0 -> FIRQB @ FQPPN						;027
;		FQPPN = PPN for search					;027
;		FQNAM1 = Wildcarded name to find			;027
;		FQEXT = Wildcarded type to find				;027
;	R1 = Index number to search for (one means first)		;027
;	R5 -> Link word to begin search with				;031
;									;027
;	FIPUNT = Starting Unit						;027
;	FIPGEN = 0 if specific unit					;027
;									;027
;	CALL	FNDFIL							;027
;									;027
;	R5 -> Name entry of found file					;027
;	FIPUNT updated to reflect found unit				;027
;									;027
; Returns NOSUCH if file isn't found					;027
;-									;027

FNDFIL::REGSCR			;Save all registers			;027
	SUB	#10.,SP		;GET SOME SP STACK WORK SPACE		;027
	MOV	SP,R1		;PLACE TO STORE MATCHING DATA		;027
	MOV	R0,R4		;Copy FIRQB pointer			;027
	TST	(R4)+		;And advance to FQNAM1			;027
	CALL	R50ASC		;Convert the string to RAD-50		;027
	TST	R5		;Do we have a starting link?		;031
	BNE	10$		;We have one, nothing to initialize	;031
	CALL	INISCN		;INITIALIZE DIRECTORY SCAN		;027
10$:	CALL	NXTENT		;GET NEXT DIRECTORY ENTRY		;027
	BCS	10$		;SKIP IF NOT PRIVILEGED TO READ IT	;027
	MOV	R3,10.+TOS.R3(SP) ;Guess that this is the link to return ;027
	MOV	R0,R1		;GET POINTER TO PPN,NAME.EXT IN FIRQB	;027
	MOV	R5,R4		;GET POINTER TO ??,NAME.EXT IN NAME ENTRY ;027
	CMP	(R4)+,(R1)+	;POINT R4 @ NAME.EXT; POINT R1 @ NAME.EXT ;027
	CALL	R50ASC		;TAKE RAD50 @R4 AND STORE AS ASCII @R1	;027
	MOV	#9.,R3		;GET COUNT OF CHARACTERS TO MATCH	;027
	MOV	SP,R4		;GET START OF WILD NAME TO MATCH	;027
	ADD	R3,R4		; AND GO TO MATCHING DATA END+1		;027
20$:	CMPB	-(R4),-(R1)	;MATCH?					;027
	BEQ	30$		;YES					;027
	CMPB	(R4),#35	;NO, WAS THIS LOCATION WILD?		;027
	BNE	10$		;NOT WILD, SO NO MATCH			;027
30$:	SOB	R3,20$		;CONTINUE CHECKING FOR MISMATCH		;027
	DEC	10.+TOS.R1(SP)	;NAME MATCHES, DID WE HIT THE ONE DESIRED? ;027
	BNE	10$		;NOT DONE YET...			;027
	ADD	#10.,SP		;Restore work area on stack		;027
	MOV	R5,TOS.R5(SP)	;Return the link of the entry		;027
	RETURN			;And we're done				;027

;+									;027
; R50ASC - CONVERT 3 RAD50 WORDS TO 9 ASCII CHARACTERS			;027
;									;027
;	R1 -> AREA FOR ASCII STRING					;027
;	R4 -> 3 WORDS OF RAD50 NAME.EXT					;027
;									;027
;	CALL	R50ASC							;027
;									;027
;	R1 -> END OF ASCII STRING (PASSED R1 + 9)			;027
;	R2 =  RANDOM							;027
;	R3 =  RANDOM							;027
;	R4 -> END OF RAD50 NAME (PASSED R4 + 6)				;027
;-									;027

R50ASC:	CALL	10$		;DO THE					;027
	MOV	PC,-(SP)	; BELOW THREE (3) TIMES			;027
10$:	MOV	(R4)+,R3	;GET A RAD50 WORD			;027
	CALL	20$		; AND GET THREE (3)			;027
	MOV	PC,-(SP)	;  CHARACTERS FROM			;027
20$:	CLR	R2		;   IT					;027
	DIV	#50,R2		;DIVIDE BY 50				;027
	MOVB	R3,(R1)+	;NOW STORE THE CHARACTER CODE		;027
	MOV	R2,R3		;SET A NEW NUMBER TO DIVIDE		;027
	RETURN			; AND EXIT (MANY TIMES...)		;027

;+									;027
; INISCN - INITIALIZE FOR SCAN OF DISK OR STRUCTURE			;027
;									;027
;	R0 -> FIRQB @ FQPPN						;027
;	FIPUNT = (STARTING) UNIT					;027
;	FIPGEN = 0 IF SPECIFIC UNIT					;027
;									;027
;	CALL	INISCN							;027
;									;027
;	R2 =  RANDOM							;027
;	R5 -> Requested entry						;027
;-									;027

.ENABL	LSB								;027

10$:	TSTB	FIPGEN		;General unit?				;045
	BEQ	20$		;No, not this time, all done		;045
	MOV	#UC.MNT!UC.PRI!UC.LCK!UC.NFS,R2 ;Set up mask for public disk ;045
	CALLX	NXTUN2,R1	;And get the next unit			;045
20$:	 ERROR	NOSUCH		;ALL DONE OR NOT GENERAL, NO MORE	;027
INISCN::CALLX	RUF		;READ THIS UFD				;027
	BCS	10$		;NOT ON THIS UNIT			;027
	MOV	#FIBUF,R5	;GET INITIAL POINTER			;027
	RETURN			;RETURN ANOTHER TRIAL UNIT		;031

;+									;027
; NXTENT - GET NEXT VALID NAME ENTRY ON DISK/STRUCTURE			;027
;									;027
;	R0 -> FIRQB @ FQPPN						;027
;	R5 -> LINK OF NEXT ENTRY					;027
;	FIPUNT = (STARTING) UNIT					;027
;	FIPGEN = 0 IF SPECIFIC UNIT					;027
;									;027
;	CALL	NXTENT							;027
;									;027
;	R2 =  RANDOM							;027
;	R3 = Link word of entry						;027
;	R5 -> NEXT ENTRY						;027
;	C=1 IF NO READ ACCESS TO FILE					;027
;-									;027

30$:	CALL	10$		;GET ANOTHER TRIAL UNIT			;027
NXTENT::CALLX	RDENXT		;READ NEXT N.E.				;027
	BEQ	30$		;NO MORE, GO GET ANOTHER UNIT		;027
	BITB	#US.UFD,USTAT(R5) ;Is this a UFD?			;031
	BNE	NXTENT		;IF SO, SKIP THIS ENTRY			;027
	BIT	#OP$MDL,FQMODE-FQPPN(R0) ;Desire marked-for-delete files? ;031
	BNE	CKPRIV		;Yes, so don't check the MDL bit	;031
	TSTB	USTAT(R5)	;Is this file marked for delete?	;031
.ASSUME	US.DEL	EQ	200						;031
	BMI	NXTENT		;Yes, so skip the file			;031
	.BR	CKPRIV		;SET CARRY FOR PRIVILEGE TO ACCESS	;027

;+									;027
; CKPRIV - CHECK FOR DIRECTORY ACCESS TO FILE				;027
;									;027
;	R0 -> FIRQB @ FQPPN						;027
;	R5 -> NAME ENTRY						;027
;									;027
;	CALL	CKPRIV							;027
;									;027
;	R2 =  RANDOM							;027
;	C=1 IF NO DIRECTORY ACCESS TO FILE				;027
;-									;027

CKPRIV::REGSCR			;Save registers				;027
	MOV	(R0),R0		;Get PPN				;027
	MOVB	UPROT(R5),R1	;Get protection code			;027
	BICB	#UP.RPO!UP.WPO,R1 ;Clear owner field			;049
	CALLX	CHKACC		;Check access rights			;027
	BIC	#^C<DDRLO!DDAUX>,R0 ;Leave only these two bits		;027
	CMP	#DDRLO!DDAUX-1,R0 ;Read and execute lockout both?	;027
				;C = 1 if both (because BLO=BCS)	;027
40$:	RETURN			;Done					;027

.DSABL	LSB								;027

GLOBAL	<FIUSER>							;027


.SBTTL	Quota Block Routines

;+									;030
;	SERQTB	-	Search QTB's for a match on PPN			;030
;									;030
;	R0 -> PPN							;030
;	FIPUNT = Unit	(Version 9.0 or newer)				;030
;									;030
;	CALL	SERQTB							;030
;									;030
;	R0-R4	  Preserved						;030
;	R5     -> QTB entry						;030
;	QTPREV =  Previous QT Table (Zero if C = 1 or 1st one)		;030
;	QTCURR =  Current QT Table  (Zero if C = 1)			;030
;									;030
;	C = 0	Match on PPN						;030
;	C = 1	No match on PPN	(FIP mapped in APR6)			;030
;-									;030

SERQTB::REGSCR			;Save all registers			;030
	CLR	QTPREV		;No previous QT buffer			;030
	CLR	QTCURR		; or current QT buffer address yet	;030
	CLR	R2		;No previous yet			;030
	MOV	(R0),R0		;Get the PPN to match			;033
	MOVB	FIPUNT,R4	;Get the unit number			;030
	ASL	R4		;Make it FUN * 2			;030
	ADD	#DSKQPT,R4	;Point at this units quota table entry	;030
	MOV	(R4),R4		; and get the initial buffer address	;030
	BEQ	30$		;None					;030
10$:	CALLX	MAPBUF		;Map the buffer				;030
	MOV	R3,R5		;Copy the pointer to this QT table	;030
	ADD	#QTLINK,R5	; and point to the link word		;030
	MOV	R4,R3		;Copy the current buffer address	;030
	MOV	(R5)+,R4	; and save the address to the next one	;030
	MOV	#3.,R1		;Three QTBs within a QT table		;030
20$:	CMP	R0,(R5)		;Same PPN?				;033
	BEQ	40$		;Yes					;030
	ADD	#QTBSIZ,R5	;On to the next one			;030
	SOB	R1,20$		; till all have been checked		;030
	TST	R4		;Is there another QT table to check?	;030
	BEQ	30$		;No					;030
	MOV	R3,R2		;Make the current address previous	;030
	BR	10$		; and go search the next		;030

30$:	MAP	FIP,DATA	;No match, remap FIP			;030
	SEC			;Indicate no match found		;030
	RETURN			; Return now				;030

40$:	MOV	R2,QTPREV	;Remember the previous QT table		;030
	MOV	R3,QTCURR	; along with the current one		;030
	MOV	R5,TOS.R5(SP)	;Return the pointer to the QTB entry	;030
	;CLC			;Incicate match found (C=0 from CMP)	;030
	RETURN			; and return to our caller		;030

GLOBAL	<QTPREV,QTCURR,FIPUNT,DSKQPT>					;030

;+									;030
;	CREQTB	-	Create a Quota Block (QTB)			;030
;									;030
;	R0 ->	PPN							;030
;	R2 =	Increment count						;033
;	FIPUNT = Unit (Version 9.0 or newer)				;030
;									;030
;	CALL	CREQTB							;030
;									;030
;	R0-R4	  Preserved						;030
;	R5    ->  QTB entry (through DPAR6)				;030
;	QTPREV =  Previous QT Table (Zero if C = 1)			;030
;	QTCURR =  Current QT Table  (Zero if C = 1)			;030
;									;030
;	C = 0	Succeeded						;030
;	C = 1	Failed		(FIP mapped to APR6)			;030
;-									;030

CREQTB::REGSCR			;Save all registers			;057
	CALL	SAVEFB		;Preserve the contents of FIBUF & FIPUNT ;057
	CLR	QTCURR		;No current QT buffer yet		;033
	CLR	QTPREV		; or previous either			;033
	MOVB	FIPUNT,R1	;Get the Fip Unit Number		;057
	ASL	R1		; and make it FUN * 2			;033
	BIT	#UC.PRI,UNTCNT(R1) ;Private disk?			;033
	BEQ	PUBCRT		;No public, do public structure create	;057
	CALL	BLDQTB		;Yes, then build the QTB for this unit	;033
	CALL	RSTRFB		;Restore the contents of FIBUF & FIPUNT	;057
	BCS	10$		;Failed, may have a QTB to return	;057
	MOV	R5,TOS.R5(SP)	;No, then return the QTB entry pointer	;057
	BR	30$		; and back to our caller		;057

10$:	TST	QTCURR		;Did we create a QTB entry?		;057
	BEQ	20$		;No, good nothing to return		;057
	MOV	TOS.R2(SP),R2	;Yes, restore the increment count	;057
	CALL	RETENT		; and return the QTB			;057
20$:	SEC			;Make sure failure is indicated		;057
30$:	RETURN			; and return				;057

GLOBAL	<QTCURR,QTPREV,FIPUNT>						;033

	;+
	; The following code is responsible for creating quota blocks   ;057
	; for each unit that makes up the public structure. The first	;057
	; priority of business is to preserve the current contents of	;057
	; FIBUF in order to restore it prior to returing to our caller.	;057
	; If we fail to create a quota block on any unit or to restore	;057
	; the contents of FIBUF then any quota blocks we may have just	;057
	; allocated on this request will be returned and the C bit set.	;057
	;
	; On entry:
	;	R0 -> PPN
	;	R1 =  FUN * 2
	;	R2 =  Increment count
	;-

PUBCRT:	MOVB	SYSUNT,FIPUNT	 ;Start with the system disk		;057
20$:	CALL	BLDQTB		;Build a QTB entry for this general unit ;033
	BCC	25$		;Succeeded, try another unit		;057
	CALL	55$		;Failed, return QTBs we may have allocated ;057
	CALL	RSTRFB		;Restore the contents of FIBUF and FIPUNT ;057
	BR	40$		; and return with C=1			;057

25$:	MAP	FIP,DATA	;Remap FIP				;033
	MOV	R2,R1		;Save the increment count from NXTUNT	;033
	MOV	#UC.MNT!UC.PRI!UC.NFS,R2 ;Set up to find a public unit	;045
	CALLX	NXTUN2,R1	;Get next public unit			;045
	 BR	30$		;None, then go finish up		;033
	MOV	R1,R2		;Restore the increment count		;033
	BR	20$		;Otherwise, continue on			;033

30$:	CALL	RSTRFB		;Restore the contents of FIBUF & FIPUNT ;057
	BCS	50$		;Unable to restore FIBUF, return QTBs	;057
	CALL	SERQTB		;Get the original units QTB entry (can't fail) ;057
	MOV	R5,TOS.R5(SP)	;Return the QTB pointer			;057
40$:	RETURN			;Return to our caller			;052

GLOBAL	<FIPUNT,SYSUNT>							;057

;+									;033
; We come here if we failed to create QTB entries for the public	;033
; structure or if we failed to restore the saved contents of FIBUF.	;057
; The routine is designed to return any QTB entries we may have		;057
; allocated to the public structure. On return we assure that the	;057
; C bit is set and that FIP is mapped through APR 6.			;057
;									;033
;	R0 -> PPN							;033
;	FIPUNT = Unit that we failed on					;033
;-									;033

50$:	MOV	TOS.R2(SP),R2	;Restore the increment count		;057
55$:	MOVB	SYSUNT,FIPUNT	;Start with the system disk		;057
60$:	CALL	SERQTB		;No, then get the QTB entry for that unit ;033
	BCS	65$		;None on this unit			;057
	CALL	RETENT		;Try to return this entry		;033
65$:	MOV	R2,R1		;Save the decrement count		;033
	MOV	#UC.MNT!UC.PRI!UC.NFS,R2 ;Set up for a public unit	;045
	CALLX	NXTUN2,R1	;Get next public unit			;045
	 BR	70$		;None, then we're done			;033
	MOV	R1,R2		;Restore the decrement count		;033
	BR	60$		;Otherwise, process this unit		;033

70$:	SEC			;Set the C bit to indicate failure	;057
	RETURN			; and return to our caller		;033

GLOBAL	<FIPUNT,SYSUNT>							;033


;+									;033
;	BLDQTB	-	Build a Quota Block (QTB)			;033
;									;033
;	R0 ->	PPN							;033
;	R2 =	Increment count						;033
;	FIPUNT = Unit (Version 9.0 or newer)				;033
;									;033
;	CALL	BLDQTB							;033
;									;033
;	R0-R4	  Preserved						;033
;	R5    ->  QTB entry						;033
;	QTPREV =  Previous QT Table (Zero if C = 1)			;033
;	QTCURR =  Current QT Table  (Zero if C = 1)			;033
;									;033
;	C = 0	Succeeded						;033
;	C = 1	Failed		(FIP mapped to APR6)			;033
;-									;033

.ENABL	LSB

BLDQTB::REGSCR								;033
	MOV	FIPERX,-(SP)	;Save the current FIP error exit	;042
	MOV	FIPESP,-(SP)	;Save current value of FIPESP		;033
	MOV	SP,FIPESP	; and now save the stack pointer	;033
	MOV	#BLDERX,FIPERX	;Set a FIP error exit			;042
	CALL	SERQTB		;Does this PPN already have a QTB?	;030
	BCC	10$		;Yes					;030
	MOV	(R0),-(SP)	;Save the PPN				;033
	CALLX	SDM		;Does the account exist?		;033
	BCC	20$		;Yes, then create QTB with real data	;033
	CALL	GETQTB		;Get a QTB entry (always zeroed)	;033
	BCS	BLDERX		;No buffers				;033
	MOV	(SP)+,(R5)	;Set the PPN in the QTB			;033
10$:	MOV	R5,R2		;Copy the QTB pointer			;033
	ADD	#QTBOPN,R2	; and point to the counters		;033
	BR	40$		;  and go increment it			;033

20$:	MOV	#AA.QUO,R0	;Want the Disk Quota blockette		;030
	CALLX	SAA		;Now get it				;030
	BCS	BLDERR		;Issue error if it's not there		;030
	MOV	R5,R4		;Copy the disk quota entry pointer	;030
	ADD	#AQ.DJB,R4	;Point to the detach job quota		;033
.ASSUME	AQ.DJB EQ AQ.LOL-1
	CALL	GETQTB		;Get a free QTB entry			;030
	BCS	BLDERX		;No buffers available (FIPs mapped)	;030
	MOV	R5,R2		;Copy the QTB pointer			;030
	MOV	(SP)+,(R2)+	;Set the PPN in the QTB			;033
	CLRB	(R2)+		;Clear the flag byte			;033
	MOV	#13.,R3		;Number of bytes to copy		;033
30$:	MOVB	(R4)+,(R2)+	;Copy an item into the QTB		;033
.ASSUME	AQ.DJB EQ QTBDJB
.ASSUME	AQ.LOL EQ QTBLOL
.ASSUME	AQ.LIL EQ QTBLIL
.ASSUME	AQ.LIM EQ QTBLIM
.ASSUME	AQ.LOM EQ QTBLOM
.ASSUME	AQ.RSM EQ QTBRSM
.ASSUME	AQ.CRM EQ QTBCRM
.ASSUME	AQ.RSL EQ QTBRSL
.ASSUME	AQ.CRL EQ QTBCRL
	SOB	R3,30$		;Continue till all six are done		;030
40$:	ADD	TOS.R2+4(SP),(R2) ;Increment the count			;042
	MOV	R5,TOS.R5+4(SP)	;Return the QTB pointer			;042
	CLC			;Indicate success			;042
50$:	MOV	(SP)+,FIPESP	;Restore the saved FIPESP contents	;033
	MOV	(SP)+,FIPERX	; and saved FIP error exit		;042
	RETURN			;Return to our caller			;033

BLDERR:	MOV	FIJBDA,R0	;Get the user's JDB			;033
	SETERR	BADDIR,JDIOST(R0) ;Disk Quota blockette not found	;033
BLDERX:	MOV	FIPESP,SP	;Restore the original stack pointer	;033
	SEC			;Indicate failure			;033
	BR	50$		; and return				;042

.DSABL	LSB

GLOBAL	<FIPESP,FIPERX,FIJBDA>						;033


;+									;033
;	RETQTB	-	Return a QTB entry				;033
;									;033
;	R0    ->  PPN							;033
;	R2     =  Decrement count					;033
;	FIPUNT =  Unit	(Version 9.0 or newer)				;033
;									;033
;	CALL RETQTB							;033
;									;033
;	R5 = Undefined							;052
;
;	C = 0	FIBUF contents successfully restored 			;057
;	C = 1   FIBUF contents not restored				;057
;									;057
;	FIP is mapped on return						;033
;-									;033

RETQTB::REGSCR			;Save all registers			;057
	CALL	SAVEFB		;Preserve the current contents of FIBUF	;057
	MOVB	FIPUNT,R1	;Get the Fip Unit Number		;033
	ASL	R1		; and make it FUN * 2			;033
	BIT	#UC.PRI,UNTCNT(R1) ;Private disk?			;033
	BEQ	10$		;No public				;033
	CALL	SERQTB		;Get this user's QTB entry		;033
	BCS	50$		;Not found, should have been there	;033
	CALL	RETENT		;Found it, now go return it (C=0)	;033
	BR	40$		;Now exit				;052

	;+								;057
	; The following code is responsible for returning quota blocks	;057
	; allocated to the public structure for the PPN specified.	;057
	; The current contents of FIBUF is preserved and restored	;057
	; prior to returning back to our caller.			;057
	;-								;057

10$:	MOVB	SYSUNT,FIPUNT	;Start with the system disk		;033
20$:	CALL	SERQTB		;Get this PPN's QTB entry		;033
	BCS	50$		;Should have one on all public units	;033
	CALL	RETENT		;Found it, now try to return it		;033
	MOV	R2,R1		;Save the decrement count		;033
	MOV	#UC.MNT!UC.PRI!UC.NFS,R2 ;Set up for a public unit	;045
	CALLX	NXTUN2,R1	;Get next public unit			;045
	 BR	40$		;None, then go finish up		;057
	MOV	R1,R2		;Restore the decrement count		;033
	BR	20$		;Otherwise, try this unit		;033

40$:	CALL	RSTRFB		;Restore the contents of FIBUF and FIPUNT ;057
	RETURN			; and return to our caller		;052

50$:	CRASH			;Software forced crash			;033

GLOBAL	<FIPUNT,UNTCNT>							;033


;+									;033
;	RETENT	-	Return a QTB entry				;033
;									;033
;	R0    ->  PPN							;033
;	R2     =  Decrement count					;033
;	R5    ->  QTB entry being returned				;033
;	QTPREV =  Previous QT Table					;033
;	QTCURR =  Current QT Table					;033
;	FIPUNT =  Unit	(Version 9.0 or newer)				;033
;									;033
;	CALL RETENT							;033
;									;033
;	All registers preserved						;033
;									;033
;	Routine will zero out the QTB entry if no longer in use and	;033
;	will also return the buffer if all QTB entries have been	;033
;	cleared. FIP is always mapped through APR 6 on exit.		;057
;-									;033

RETENT::REGSCR			;Save all registers			;033
	SUB	R2,QTBOPN(R5)	;Decrement the count			;033
	BNE	90$		;Still in use can't be returned		;033
	BITB	#Q.UPDC,QTBFLG(R5) ;Need to write usage to disk?	;033
	BEQ	10$		;No					;033
	CALL	WRTUSG		;Yes, then go do it			;033
10$:	MOV	#<QTBSIZ/2>,R1	;Get the number of words to clear	;033
20$:	CLR	(R5)+		;Clear a word				;033
	SOB	R1,20$		;Continue until the QTB is cleared	;033
	MOV	QTCURR,R5	;Get the current QT table pointer	;042
	BIT	R5,#37		;Monitor buffer?			;042
	BEQ	30$		;Yes, then we're already at the top	;042
	MOV	#140000,R5	;XBUF buffer, then point to the top	;042
30$:	MOV	R5,R3		;Save the QT table pointer		;033
	ADD	#QTBENT,R5 	; and point at the 1st QTB		;033
	MOV	#3.,R1		;Three entries to check			;030
40$:	TST	QTBOPN(R5)	;Still in use?				;033
	BNE	90$		;Yes, buffer is still in use		;030
	ADD	#QTBSIZ,R5	;Try the next QTB entry			;030
	SOB	R1,40$		;Continue till all three are checked	;030
	MOV	QTLINK(R3),-(SP) ;Save the address to the next QT	;030
	MOV	QTCURR,R4	;Get the buffer address			;033
	BIT	#40-1,R4	;Is this an XBUF buffer?		;047
	BNE	50$		;Yes, sure is				;047
	DEC	USETBL+UT.QTS	;Count another small buffer QT returned	;047
	BR	60$		;And join up				;047

50$:	DEC	USETBL+UT.QTX	;Count another XBUF QT returned		;047
60$:	BUFFER	RETURN		; and return it				;033
	MOV	QTPREV,R4	;Now get the previous QT table address	;030
	BNE	70$		;Wasn't the first one			;030
	MOVB	FIPUNT,R1	;Get the Fip Unit Number		;030
	ASL	R1		;Make it FUN * 2			;030
	ADD	#DSKQPT,R1	;Build a pointer to the root		;030
	MOV	(SP)+,(R1)	;Save the link pointer to the next QT	;030
	BR	80$		; and return				;030

70$:	CALLX	MAPBUF		;Map the buffer				;030
	MOV	(SP)+,QTLINK(R3) ;Save the link pointer to the next QT	;030
80$:	CLR	QTPREV		;Invalidate the previous		;030
	CLR	QTCURR		; and current QT cells			;030
90$:	MAP	FIP,DATA	;Remap FIP				;057
	RETURN			;Return to our caller			;030

GLOBAL	<QTCURR,QTPREV,DSKQPT,FIPUNT,USETBL>				;047

;+									;030
;	GETQTB	-	Get a free QTB entry				;030
;									;030
;	FIPUNT = Unit	(Version 9.0 or newer)				;030
;									;030
;	CALL	GETQTB							;030
;									;030
;	R0-R4	  Preserved						;030
;	R5     -> QTB entry						;030
;	QTPREV =  Previous QT Table (Zero if C = 1)			;030
;	QTCURR =  Current QT Table  (Zero if C = 1)			;030
;									;030
;	C = 0	Succeeded						;030
;	C = 1	Failed							;030
;-									;030

GETQTB:	REGSCR			;Save the world				;030
	CLR	QTPREV		;No previous QT table			;030
	CLR	QTCURR		; or current QT table address yet	;030
	CLR	R0		;No previous yet			;033
	MOVB	FIPUNT,R4	;Get the Fip Unit Number		;030
	ASL	R4		; and make it FUN * 2			;030
	ADD	#DSKQPT,R4	;Build a pointer to this units QT table	;030
	MOV	R4,R3		;Copy the root pointer			;030
	MOV	(R4),R4		;Get the initial buffer address		;030
	BEQ	40$		;None, then go create one		;030
10$:	CALLX	MAPBUF		;else, map the buffer			;030
	ADD	#QTLINK,R3	;Point to the link word			;030
	MOV	R3,R5		;Copy the QT pointer			;030
	TST	(R5)+		; and point to the 1st QTB entry	;030
	MOV	#3.,R1		;Three QTB's to search			;030
20$:	TST	QTBOPN(R5)	;Any open files or logged in users?	;030
	BNE	30$		;Yes, skip this entry it's still in use	;030
	TSTB	QTBFLG(R5)	;Is the "needs updating" flag set?	;030
	BPL	80$		;No, then this one is available now	;030
	CRASH			;Yes, should never happen		;030

30$:	ADD	#QTBSIZ,R5	;Point to the next QTB			;030
	SOB	R1,20$		; and continue searching till done	;030
	MOV	R4,R0		;Copy the current buffer address	;030
	MOV	(R3),R4		;Another QT to check?			;030
	BNE	10$		;Yes, then search this one		;030
40$:	MOV	#QTSIZE,R1	;We want a buffer of QTSIZE length	;045
	MOV	#64.,R2		;Leave 64. buffers in monitor's pool	;045
	MOV	#LRGPOL,R4	;Get a buffer from LRGPOL		;045
	CALLX	BUFFR4,R5	;Now go get the buffer			;045
	BCS	90$		;None, simply return leaving C=1	;030
	MOV	R4,(R3)		;Save buffers address in the link word	;030
	BIT	#40-1,R4	;Is this a small buffer?		;047
	BNE	50$		;No, not this time			;047
	INC	USETBL+UT.QTS	;Count another QTB in monitor pool	;047
	BR	60$		;And join up				;047

50$:	INC	USETBL+UT.QTX	;Count another QTB in XBUF		;047
60$:	CALLX	MAPBUF		;Now map it via APR6			;047
	MOV	R3,R5		;Copy the buffer pointer		;030
	ADD	#QTSIZE,R5	;Start at the end of the buffer		;030
	MOV	#<QTSIZE-QTLINK>/2,R1 ;Get the number of words to clear	;030
70$:	CLR	-(R5)		;Clear a word in the QT entry		;030
	SOB	R1,70$		;Continue till done			;030
	TST	(R5)+		;Point at the 1st QTB entry		;030
80$:	MOV	R0,QTPREV	;Remember the previous QT table address	;030
	MOV	R4,QTCURR	; along with the current one		;030
	MOV	R5,TOS.R5(SP)	;  and return the pointer to this QTB	;030
	;CLC			;Indicate success (C=0 from TST)	;030
	RETURN			;Return to our caller			;030

90$:	MOV	FIJBDA,R0	;Get the user's JDB			;033
	SETERR	NOBUFS,JDIOST(R0) ;Indicate no buffers available	;033
	MAP	FIP,DATA	;Remap FIP				;033
	SEC			;Indicate failure			;033
	RETURN			;Return to our caller (C set by BUFFER)	;033

GLOBAL	<QTPREV,QTCURR,FIPUNT,DSKQPT,FIJBDA,LRGPOL,USETBL>		;047

;+									;030
;	WRTUSG	-	Write current usage to disk			;030
;									;030
;	R0    -> PPN							;033
;	R5    -> QTB entry within the current QT table			;033
;	QTCURR = Current QT table					;033
;	FIPUNT = Unit	(Version 9.0 or newer)				;030
;									;030
;	CALL	WRTUSG							;030
;									;030
;	All registers preserved						;030
;-									;030

.ENABL	LSB

WRTUSG:	REGSCR			;Save current register values		;030
	MAP	FIP,DATA	;We need to have FIP mapped		;030
	MOV	FIPERX,-(SP)	;Save the current FIP error exit	;042
	MOV	FIPESP,-(SP)	; and the possible stack pointer	;042
	MOV	SP,FIPESP	;Preserve our current stack pointer	;030
	MOV	#WRTERX,FIPERX 	;Set our error handling address	;042
	CALLX	SDM		;Look it up				;030
	BCS	WRTERR		;Not there, something is very ill	;030
	MOV	#AA.QUO,R0	;We want quota attributes		;030
	CALLX	SAA		;Find the blockette			;030
	BCS	WRTERR		;Not there, issue error			;042
	MOV	@#QTCURR,R4	;Get the current QT buffer address	;033
	CALLX	MAPBUF		; and map it				;033
	MOV	TOS.R5+4(SP),R1	;Get the QTB pointer back		;030
	MOV	QTBCRL(R1),AQ.CRL(R5) ;Write the current usage (LSB)	;030
	MOVB	QTBCRM(R1),AQ.CRM(R5) ; and current usage (MSB)		;030
	MARK	FIBUF,INLINE	;Make sure it gets written out		;045
10$:	MOV	(SP)+,FIPESP	;Restore our saved stack pointer	;042
	MOV	(SP)+,FIPERX	; and the saved FIp error exit		;042
	BICB	#Q.UPDC,QTBFLG(R1) ;Clear the "update disk usage" flag	;030
	RETURN			;Return to our caller			;030

WRTERR:	MOV	FIJBDA,R0	;Get the user's JDB			;042
	SETERR	ABORT,JDIOST(R0) ; and issue "Fatal system I/O failure"	;042
WRTERX:	MOV	FIPESP,SP	;Unexpected I/O error, restore SP	;033
	MOV	QTCURR,R4	;Restore our QT buffer address		;030
	CALLX	MAPBUF		; and map it				;030
	MOV	TOS.R5+4(SP),R1	;Restore the QTB pointer		;030
	BR	10$		;Simply ignore the update		;030

.DSABL	LSB

GLOBAL	<FIBUF,QTCURR,FIPERX,FIPESP,FIJBDA>				;042

.SBTTL	Save and Restore FIBUF routines

;+
; SAVEFB - Save FIBUF contents
;
;	CALL	SAVEFB
;
;	R5 =  Undefined
;	SP -> (0) FBN (LSB)
;	      (2) FBN (MSB) or -1 (-1 = do not restore FIBUF)
;	      (4) FIPUNT
;
; This routine will save the block number of the current contents
; of FIBUF along with the FIPUNT number. On initial entry the
; return address is preserved in R5 prior to pushing the data onto
; the stack. Finally we return to our caller by jumping to the
; address saved in R5.
;-

SAVEFB:	MOV	(SP)+,R5	;Get the return address			;052
	MOV	FIPUNT,-(SP)	;Save the current FIPUNT and FIPGEN	;057
	MOV	#-1,-(SP)	;Guess that FIBUF contents aren't important ;053
	CMPB	FIBUNT,FIPUNT	;Good guess?				;053
	BNE	5$		;Yes, sure is				;053
	MOV	FIBFBN,(SP)	;No, so save current FBN MSB		;052
5$:	MOV	FIBFBN+F.FBNL,-(SP) ;Save current FBN LSB		;053
	JMP	(R5)		;Return to our caller			;057

GLOBAL	<FIPUNT,FIBUNT,FIBFBN>						;057


;+									;057
; RSTRFB - Restore FIBUF contents
;
;	SP -> (0) Return address
;	      (2) FBN (LSB)
;	      (4) FBN (MSB) or -1 (-1 = do not restore FIBUF)
;	      (6) FIPUNT
;
;	CALL	RSTRFB
;
; This routine is called to restore the saved contents of FIBUF if it
; was saved along with the saved FIP unit number. A FIP error exit is
; set up in order to return to our control should any type of I/O failure
; occur when restoring FIBUF. If an error should occur, the routine will
; set the C bit so the caller can take appropriate action. Otherwise the
; C bit is preserved and restored to whatever sense it was upon entry.
;-									;057

RSTRFB:	MOV	6(SP),FIPUNT	;Restore saved FIPUNT			;057
	MOV	(SP)+,4(SP)	;Save away our return address		;057
	MOV	(SP)+,R2	;Restore the saved FBN LSB		;052
	MOV	(SP)+,R3	;Restore the saved FBN MSB		;052
	BMI	20$		;Unit invalid, nothing to do		;052
	PUSH	<R0,R5>		;Save the contents of R0 and R5		;057
	ROL	-(SP)		;Save the "C" bit for our caller's caller ;052
	MAP	PUSH,APR=6,DATA	;Save APR6 data mapping			;052
	MAP	FIPPOL		;Be sure FIP is mapped correctly	;052
	MOV	FIPERX,-(SP)	;Save the current contents of FIPERX	;057
	MOV	FIPESP,-(SP)	; and FIPESP				;057	
	MOV	SP,FIPESP	;Save the current stack pointer		;057
	MOV	#100$,FIPERX	; and set the address of our error handler ;057
	CALLX	READ		;Go read that block in			;052
10$:	MOV	(SP)+,FIPESP	;Restore the saved contents of FIPESP	;057
	MOV	(SP)+,FIPERX	; and FIPERX				;057
	MAP	POP,APR=6,DATA	;Restore APR6 data mapping		;052
	ROR	(SP)+		;Restore the "C" bit			;052
	POP	<R5,R0>		; and the saved values of R0 and R5	;057
20$:	RETURN			; and we're done			;057

100$:	MOV	FIPESP,SP	;Restore the saved stack pointer	;057
	BIS	#1,6(SP)	;Set the saved C bit to 1		;057	
	BR	10$		;Now go finish up			;057

GLOBAL	<FIBUNT,FIPUNT,FIBFBN>						;053

.END

