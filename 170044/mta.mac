	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
	.INCLUDE /CMN:FLDEF/
	.INCLUDE /CMN:MTDEF/
TITLE	MTA,<MAGTAPE I/O CODE>,0A,10-MAY-91,TWH/JHC/DBM/KPH/TPT

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR MTA

;+
;			[RSTS/E V9.0]
;  000	TWH  26-MAR-84	CREATION - IT TOOK 6 DAYS, I RESTED ON THE 7TH
;  001	JHC  23-APR-84	Bug fix on TSQRET movbyte, and change PSECT
;			to MTA from OPL, and repair CHKTSQ
;  002	DBM  02-May-84	Asynchronus EOV setup code (ASYECK)
;  003	KPH  11-Sep-84	Move to MVR phase
;  004	DBM  24-Oct-84	Flag MTU rewinds to the MSDVR
;
;			[RSTS/E V9.2]
;  005	TPT  10-Jan-86	Add BLDTSQ, common routine for MS/MU type drives
;
;			[RSTS/E V9.3]
;  006  KPH  11-Jul-86	Use WAIT2T instead of BSTALL for buffer waits
;  007	DBM  07-Nov-86	Make LODTSQ do buffer waits correctly
;-

	DEFORG	MTA
.SBTTL	MAGTAPE I/O
;+									
;	MTAIO - MAGTAPE I/O
;	MTADD - MTU REGISTER SHIFT ROUTINE
;	
;	THESE ROUTINES ARE CALLED FROM MTU ONLY.  MTAIO QUEUES
;	THE I/O REQUEST FOR FIP, AND UPON COMPLETION OF OUR REQUEST
;	WE COME BACK THROUGH THE MAGTAPE DISPATCH (MTA).
;
;	UPON ENTRY TO MTAIO:
;
;	R1 -> FIRQB @ FQFIL
;	R2 -> COMMAND FOR TAPE DRIVER
;	R4 -> DDB @ MTDDSP
;
;	UPON ENTRY TO MTADD:
;
;	R4 -> FIRQB
;
;	WHEN WE LEAVE MTADD AND RETURN TO OUR CALLER:
;
;	R1 -> FIRQB @ FQFIL
;	R4 -> DDB @ MTDDSP
;
;-

MTAIO::	MOVB	R2,MTCCMD(R4)		;SAVE THE COMMAND		
	MOVB	#MTRTCT,MTRTRY(R4)	;SET THE RETRY COUNT
	MOVB	#MTAFQ,-(R1)		;ENSURE MT DISPATCH
	BIT	#DDASY,MTSTS-1(R4)	;Asynchronous device?		;007
	BEQ	10$			;Nope				;007
	CALL	LODTSQ			;Yes.  Load up a TSQ		;007
	BR	20$			;Now get out			;007

10$:	CALLX	QUEL3Q			;Que a synchronous request	;007
20$:	MOV	FIJBDA,R1		;Pick up the JDB pointer	;007
	CALLX	CLRRSQ			;Clear the residency quantum	;007
	JMPX	FIEXIX			;Exit without setting JSFIP	;007

GLOBAL	<FIJBDA>							;007

;+
; MTAFUN - Handle MTAFQ
;
; FIP jumps here on a MTAFQ. The actual dispatching code is in the OPN phase.
;-

.ENABL	LSB

MTAFUN::CALL	CHKTSQ			;CHECK OUT THE TSQ IF WE HAVE ONE ;003
10$:	MOV	R1,MTFQB(R4)		;SAVE THE FIRQB POINTER
	CMP	(R1)+,(R1)+		;BIAS FIRQB POINTER TO FQFIL
	MOV	MTBCNT(R4),R5		;GET THE RETURN ADDRESS INTO THE OVR IN MTU
	FJMP	(R5)			;AND GO TO IT

MTADD::	MOV	R4,R1			;GET THE FIRQB POINTER		
	MOV	FQCLUS(R1),R4		;GET THE DDB POINTER
	ADD	#MTDDSP,R4		;BIAS IT
	BR	10$

.DSABL	LSB

.SBTTL	LOAD TSQ ROUTINE FOR MTAIO

;+
;	LODTSQ - LOAD THE TSQ  
;	
;	R1 -> FIRQB @FQFUN
;	R4 -> DDB @MTDDSP
;
;	CALL	LODTSQ
;
;	FIRST, WE TRY TO GET A SMALL BUFFER.  IF SUCCESSFUL,
;	WE PLUG IN A FEW THINGS IN THE TSQ AND STUFF THE TSQ POINTER
;	IN R3.  WE THEN CALL THE DRIVER AT THE SERVICE ENTRY POINT.
;	IF WE CAN'T GET A SMALL BUFFER, WE QUEUE OUR
;	BUFFER STALL QUEUE SUB-BLOCK IN THE DDB ONTO OUR QUEUE (MTBSTQ).
;
;-

LODTSQ:	TST	R2			;EOV COMPLETION?		;002
	BPL	10$			;NOPE				;002
	CLR	R3			;YES, SO NO TSQ			;002
	MOV	R4,R2			;SAVE DDB POINTER		;002
	BR	20$			;GO ON TO DISPATCH		;002

10$:	MOV	R4,R2			;SAVE DDB POINTER
	BUFFER	GETSML,,10.		;TRY TO GET A SMALL BUFFER	;006
	BVS	SNOBUF			;NO LUCK - PUT US IN THE BUFFER STALL QUEUWE
	MOVB	MTDUNI(R2),TSQPUN(R4)	;COPY PHYSICAL UNIT NUMBER
	MOVB	MTIDX(R2),TSQIDX(R4)	;COPY DEVICE INDEX
	MOVB	MTOFLG(R2),TSQMTO(R4)	;SAVE FLAG WORD
	MOV	MTUBUF(R2),TSQMAL(R4)	;GET ANSI LABEL BUFFER PTR
	MOVB	MTRTRY(R2),TSQRTY(R4)	;SAVE RETRY COUNT
	MOV	MTCNT(R2),TSQCNT(R4)	;GET TRANSFER COUNT
	MOVB	MTCCMD(R2),TSQCMD(R4)	;SAVE THE COMMAND
	BISB	#TS$RWD,TSQSTS(R4)	;Set rewind flag in TSQ		;004
;
; NOTE:	The above flag is being set on all requests to reduce code,
;	but the MSDVR will only look at the flag for rewind requests
;-
	MOV	R4,MTUBUF(R2)		;SAVE THE TSQ POINTER
	MOV	R4,R3			;R3 -> TSQ
20$:	MOVB	MTIDX(R2),R4		;GET DEVICE INDEX
	MOV	R2,R1			;R1 -> DDB	
	SUB	#MTDDSP,R1		;UNBIAS R1
	MOVB	MTDUNI(R2),R0		;R0 = UNIT NUMBER
	ASL	R0			;	TIMES TWO
	MOV	#-1,R2			;TELL DRIVER WE'RE COMING FROM MTU
	CALLX	DVRDSP,R4,$SERTBL	;Call driver dispatch routine	;007
	RETURN				;Go return accordingly		;007

GLOBAL	<$SERTBL>							;006

.SBTTL	SNOBUF	Stall on buffer allocation failure

;+
; SNOBUF - Stall on buffer allocation failure
;
;	R1 -> FIRQB @ FQFUN
;	R2 -> DDB
;
;	JMP	SNOBUF
;
; The DDB is linked into the buffer stall queue and we are scheduled
; to try again in two clock ticks.
;-

SNOBUF:	MOV	R2,R4		;RESTORE DDB POINTER
	SUB	#FQFUN,R1	;UNBIAS FIRQB POINTER
	MOV	R1,MTFQB(R4)	;SAVE FIRQB POINTER
	ADD	#MTCRET,R4	;Point to queue link word		;006
	CALLX	QUEUER,R0,MTBSTQ ;And add this DDB to the queue		;006
	L3QSET	QMTBUF,WAIT2T	;Come back here very soon		;006
	RETURN			;Back to caller				;007

GLOBAL	<WAIT2T,MTBSTQ>							;006

.SBTTL	CHECK THE TSQ RETURNED FROM THE TAPE DRIVER

;+
;
;	CHKTSQ - CHECK TSQ FOR ERROR/COMPLETION RETURN VALUE
;
;	R4 -> FIRQB (from FIP dispatch in CTL)
;
;	CALL	CHKTSQ
;
;	DDB FIELDS UPDATED  (MTLCEV,MTCRET)
;
;	CHKTSQ IS CALLED AFTER I/O COMPLETION.  IF HAVE A TSQ, THEN
;	WE UPDATE THE DDB FROM THE TSQ.  OTHERWISE RETURN.
;
;-

CHKTSQ:	MOV	R4,R1			; get the FIRQB pointer in R1	;001
	MOV	FQCLUS(R1),R4		; and get the DDB pointer out	;001
	ADD	#MTDDSP,R4		; bias the DDB pointer		;001
	BIT	#DDASY,MTSTS-1(R4)	;IS THIS A ASYNC capable DEVICE?
	BEQ	RETMTU			;NOPE			
	MOV	R4,R2			;COPY DDB POINTER	
	MOV	MTUBUF(R4),R4		;GET THE TSQ POINTER in R4
	MOVB	TSQCEV(R4),MTLCEV(R2)	;GET THE ERROR CODE
	MOV	TSQRET(R4),MTCRET(R2)	;GET COMPLETION RETURN VALUE
	MOV	TSQMAL(R4),MTUBUF(R2)	;GET BACK ANSI LABEL BUFFER
	BUFFER 	RETSML			;RETURN THE SMALL BUFFER
	MOV	R2,R4			;RESTORE DDB POINTER
RETMTU:	RETURN				;BACK TO CALLER

;+005
.SBTTL   BLDTSQ - BUILD A TSQ
;+
;
; BLDTSQ
;   R1 -> DDB @MTQPTR
;   R3 -> XRB
;   R4 =  JOB # * 2
;
;	CALL BLDTSQ
;
;   R3 -> XRB
;   R4 -> TSQ (initialized)
;
;   IF NO SMALL BUFFER IS AVAILABLE; EXIT WITH CARRY SET, R4 NOT CHANGED.
;
; NOTE:	IN THE CASE OF AN ERROR CHECK STATE, THE OPEN BIT WILL SHOW AS A
;	MTU REQUEST BECAUSE IT IS SENDING IN REQUESTS, BUT AN ASYNCHRONOUS
;	USER CAN STILL ISSUE REQUESTS.  SINCE MTU ALWAYS PROVIDES THE TSQ,
;	ANYTIME THIS ROUTINE IS CALLED IS FOR A USER REQUEST, THEREFORE WE
;	CAN ENSURE THAT THE OPEN BIT IS SET PROPERLY SO THE REQUEST CAN BE
;	ANSWERED CORRECTLY
;-

BLDTSQ::PUSH	R4		; SAVE R4			
	BUFFER	GETSML,,15	; GET A SMALL BUFFER (CLEARED)	
	BVS	20$		; NO BUFFERS, UGH, DIE OR WAIT	
	CLRB	TSQSTS(R4)	; WE GOT ONE, CLEAR THE STATUS  
	BIT	#1,XRBCRA(R3)	; IS THIS AN ASYNCH REQUEST?
	BEQ	10$		; NO				
	BISB	#TS$ASY,TSQSTS(R4) ; YES, SO REMEMBER THAT	
10$:	MOV	R3,TSQASY(R4)	; SET UP THE ASYWRK POINTER	
	ASR	R0		; GET UNIT # TIMES 1		
	MOVB	R0,TSQPUN(R4)	; AND SAVE IT			
	ASL	R0		; RESTORE UNIT #*2		
	MOVB	MTOFLG(R1),TSQMTO(R4) ; REMEMBER OPEN STATUS WHEN ISSUED 
;	BITB	#MT.ECK,MTFLAG(R1) ;ARE WE IN AN ERROR CHECK STATE?
;	BEQ	15$		; NOPE, NO WORRY	
;*** REMEMBER USER/MTU DIFFERENTIATION	
	BISB	#MT.OPN,TSQMTO(R4) ; YES, SO REMEMBER THIS IS A USER REQ 
15$:	MOVB	#MTRTCT,TSQRTY(R4) ;AND SET THE RETRY COUNT	
	MOVB	(SP)+,TSQJOB(R4) ; GET RID OF OLD R4, STORING JOB # * 2
	;CLC			; CLEAR THE CARRY (DONE BY THE ASL)
	RETURN			; AND QUIT HAPPY		

20$:	POP	R4		; RESTORE JBNO *2 TO R4		
	SEC			; OH-OH, NOT HAPPY		
	RETURN			; GET OUT OF HERE		

;-005

.SBTTL	L3Q ENTRY FOR QMTBUF (MT BUFFER WAIT)

;	L3Q entry point for QMTBUF - set when LODTSQ cannot get a small
;	buffer for TSQ.  We will come here every two ticks to try the
;	request again.

	L3QENT	QMTBUF,,MVRAP5		;MTU buffer continuation	;003

QMTBUF:	MOV	MTBSTQ,R4		;GET BUFFER STALL QUEUE ROOT
	BEQ	20$			;Nothing in queue		;007
	MOV	(R4),MTBSTQ		;DEQUEUE THIS REQUEST
	BEQ	10$			;LAST ITEM
	L3QSET	QMTBUF			;SET L3Q BIT SAYING WAITING FOR BUFFERS
10$:	MOV	R4,R1			;COPY DDB PTR			;002
	SUB	#MTCRET,R1		;SET DDB PTR BACK TO MTDDSP	;006
	MOV	MTFQB-MTCRET(R4),R4	;R4 -> FIRQB (IF ANY)		;006
	BIT	#MT.ECK,MTFLAG(R1)	;ERROR CHECK COMPLETION?	;002
	BNE	ASYECK			;YES, CONTINUE WITH IT		;003
	CALL	LODTSQ			;No, try to re-start request	;007
20$:	JMPX	RTI3			;Go out to RTI3			;007

GLOBAL	<MVRAP5,MTBSTQ>							;006

;002+
.SBTTL	DO ASYNCHRONUS ERROR CHECK (EOV)

;+
;
;	ASYECK - DO ASYNCHRONUS ERROR CHECK (EOV)
;
;	R1 -> DDB @ MTDDSP
;
;	ROUTINE IS JUMPED TO FROM THE DRIVER
;
;	GETS A SMALL BUFFER SO IT CAN FAKE A WORK BLOCK FOR AN
;	ASYNCHRONUS DRIVER, SETS IT UP, AND QUEUES IT THROUGH FIPSYS
;
;-

; Entry point here is for the QMTBUF L3Q re-entry point, found above

ASYECK::MOV	R1,R2			;SAVE DDB POINTER (FOR SNOBUF)	;003
	BUFFER	GETSML,,10.		;GET A BUFFER			;006
	BVS	10$			;None available			;007
	MOVB	#EOVFQ,FQFUN(R4)	;SET EOV FUNCTION
	MOVB	MTJBNO(R1),FQJOB(R4)	;SET JOB # IN 'WORK BLOCK'
	MOV	R1,FQCLUS(R4)		;SET DDB POINTER IN IT TOO
	SUB	#MTDDSP,FQCLUS(R4)	; UNBIASED
	MOV	R4,MTFQB(R1)		;STORE NEW FIRQB ADDRESS IN DDB
	JMPX	FIPSYS			;QUEUE FIRQB OR WORK BLOCK

10$:	CALL	SNOBUF			;Stall the request		;007
	JMPX	RTI3			;And leave			;007

	.END
