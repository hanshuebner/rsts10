.INCLUDE /CMN:COMMON/
.INCLUDE /CMN:KERNEL/
.INCLUDE /CMN:FLDEF/
.INCLUDE /CMN:PFBDEF/
.INCLUDE /CMN:KBDEF/
.INCLUDE /CMN:PKDEF/
TITLE	LOG,<LOGIN, LOGOUT, ATTACH & DETACH>,0I,31-JAN-92,MHB/ABC/SRM/JTC/PRL/DRP/FEK/GPK/WJS/AWL/FRL/KPH/DWF/JFM

;
;		COPYRIGHT (c) 1974, 1992 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR LOG

;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;  001	SRM  25-Mar-81	Add patch 3.5.14 to source.
;  002	JTC  12-Oct-81	Add "SGNRES" to FQFSRT
;  003	JTC  15-Oct-81	Add "LOGIN, No password" entry for sys startup.
;
;				[RSTS V7.2]
;  000	PRL  17-Mar-82  CREATION - COPIED FROM V7.1-11
;  001	PRL  17-Mar-82  Allow reattach to owned terminal
;
;				[RSTS V8.0]
;  002	DRP  02-Jul-82	Disallow password of ??????
;  003	GPK  20-Sep-82	Changes for new directory structure
;  004	GPK  27-Sep-82	Separated out LOG from LIN (attach)
;			Enhancements to Attach
;  005	GPK  14-Oct-82	Disallow passwords with embedded ?, record login time
;  006	FEK  29-Sep-82	Make logout do only logout, & kill deassign & close
;  007	GPK  28-Oct-82	Fix option byte in Attach for ascii passwords,
;			bugfixes
;  008	WJS  29-Oct-82	New UUOENT for EMT Logger
;  009	GPK  23-Nov-82	Logged-in spawn; fix BL3 field test bugs,
;			Moved detach here from UUO
;  010  AWL  07-Dec-82  Added NPQCHK to test non-priv detached quota; added FQSIZ to QUOCHK
;  011  AWL  15-Dec-82  Changed name of LOGSPW to LOGSPI
;  012  AWL  17-Dec-82  Made LOGOUT non-privileged
;  013  WJS  19-Dec-82  Changed EMT Logger use of register
;  014  AWL  23-Dec-82  Removed BL4 temporary patch from NPQCHK
;  015  AWL  05-Jan-83  Include JFNOPR in test of priority for non-priv detach
;                       Remove some unnecessary code
;  016  AWL  11-Jan-83  Correct return of error code to FIRQB by QUOCHK
;                       Cleanup some QUOCHK & NPQCHK code
;  017	FEK  28-Jan-83	Don't return success from NPQCHK since QUOCHK will be
;			returning success or warning.
;  018	WJS   1-Feb-83	Fix FQFIL's being cleared before J2S1LO check
;
;				[RSTS V9.0]
;  019	GPK  28-Mar-83	Multiple privileges
;  020  BSB  05-Jul-83	Add PFB Cleanup overlay for LOGOUT/SHUTUP code
;  021	GPK  16-Sep-83	Multi-privilege changes, added check-password
;  022	GPK  19-Nov-83	Fix spawn priv handling, better check-password
;  023	DRP  05-Dec-83	Changes for Open phase
;  024  GPK  29-Dec-83	Split ACNT into WACNT/GACNT, remove extraneous
;			 JFNOPR reference
;  025	GPK  12-Jan-84	Add system password facility, nologin flag handling,
;			 captive setup, nonet/nodialup checks
;  026	GPK  19-Jan-84	Turn on log buffer flush code, clear group privs
;			 at logout time
;  027	DRP  14-Feb-84	Changes for logged-in quotas
;			Bug fix to LOGSPI.
;  028  FRL  01-Apr-84  V9.0 logicals
;  029	GPK  17-Apr-84	More account flag handling, priv name changes
;  030	DRP  02-Apr-84	More changes for logged-in quotas
;  031	KPH  26-Jun-84	Bugfixes, make lookup passwords case-insensitive
;  032	GPK  17-Jul-84	Bugfix in LOGLOG (quota error handling)
;  033	GPK  01-Aug-84	Bugfix in attach, login (NOnetwork check)
;  034	GPK  02-Aug-84	Bugfix in LOGSPI
;  035	GPK  07-Aug-84	Reset, not close, PFB channels 1-17
;  036	DRP  14-Sep-84	Add EXQTA priv check to UU.DET
;  037	DRP  17-Sep-84	Make error code returned by UU.BYE a word value
;			Fix problem with UU.BYE not returning quota flag
;  038	KPH  16-Oct-84	Improve ICFP detach handling
;  039	GPK  30-Oct-84	Fix GACNT privilege checks, add flag for
;			suppressing password check; fix detach/noclose bug
;  040	DRP  29-Nov-84	Fix bug in SPWCHK routine
;  041	KPH  19-Dec-84	Allow ICFP detach on /NOCLOSE with one console open
;			PK priority restrictions
;  042	GPK  22-Jan-85	Special-case LINNOP for R-O system disk
;  043	KPH  01-Mar-85	Pass logicals and core common on ICFP detach
;  044	GPK  23-Feb-85	Fix CHKACC calls, add no-password-check flag to
;			UU.ATT, fix UU.JOB with EXQTA privs to bypass
;			quota checks
;  045	GPK  15-Apr-85	Fix access type checks for detached (server) jobs;
;			truncate /lookup passwords to 6 characters
;
;			[RSTS V9.1]
;  046  KPH  31-May-85	Bugfixes
;  047  KPH  08-Jul-85	Fix PK: logout check (only job is on a PK)
;			Bugfixes in LOGLOG
;  048  KPH  23-Aug-85	Bugfixes
;
;			[RSTS V9.2]
;  049  KPH  25-Jul-85	Add job control region
;  050  KPH  23-Oct-85	Add a missing PIC to a MAP reference
;
;			[RSTS V9.3]
;  051  KPH  12-Jan-86	Don't allow logins to NOUSER accounts
;  052  KPH  12-Mar-86	Fix problem with total job quota check
;  053  KPH  20-May-86	Update some ICFP detach comments
;  054	DRP  06-Nov-86	Ensure "Name Blockette" is updated on disk
;			in logout (UU.BYE) directive.
;
;			[RSTS V9.4]
;  055  KPH  30-Jan-87	Changes for new mapping structure
;  056	DWF  19-Feb-87	Add PK system job support
;
;			[RSTS V9.6]
;  057  KPH  13-Oct-87	Change device lookup routines to follow DEVPTR
;			for all devices, rather than assuming that
;			all DDBs followed one another
;			Changed PK DDB lookup to use CSR.KB value
;			Changed KB lookups that used DEVTBL to DEV.KB
;			Changed PK mode references to be symbolic
;
;			[RSTS V9.7]
;  058  WRM  15-Mar-89	Fix flush/close of log file
;
;			[RSTS V10.0]
;  059	FEK  29-Jan-90	Add non-interactive login date/time + failed logins
;  060	JFM  15-Feb-90	Source clear detach of dynamic PK problem, patch 3.5.19
;  061	FEK  22-Feb-90	Make BATCH = non-interactive
;  062	JFM  16-Mar-90	Use JOBTBL, not FIJBDA to get JDB pointer in detach
;  063	WRM  25-May-90	Fix swap console crash problem for LAT lines (DRP/WRM)
;  064	JFM  07-Aug-90	Source clear MONITR.CMD patch for V10.0 - Map the JCR
;
;			[RSTS V10.1]
;  065	DRP  17-Apr-91	Source clear patch 3.7.1 published in the December
;			1990 Software Dispatch.
;  066	JFM  06-May-91	Source clear patch in MONITR.CMD, fix reattach so it 
;			preserves open modes.
;  067	FEK  01-Oct-91	Include headersize when SLI to KBM
;  068	FEK  06-Jan-91	Allow logout from R/O SY0:
;-

FQFSRT	LOG								;049

.ENABL	LSB								;019

5$:	CALLM	RETQTB,OPNAP5	; can't log in, so give back the QTB.	;059
10$:	ERROR	NOSUCH		; General "you blew it" error		;047

20$:	ERROR	NOTAVL		; Different error for "expired"		;047

;+
; Do the actual logging in
;
;	R1  ->	JDB							;029
;	R2  ->	JDB2							;025
;	R3  =	Link of name entry
;	R4  ->  Work block						;047
;	R5  ->	Date/time blockette in FIBUF				;025
;
;	PPN is in work block at FQPPN					;047
;
;	[F]CALL	LOGLOG
;
;	R0 = Undefined
;	R1 = Undefined
;	R2 = Undefined
;	R3 = Undefined
;	R4 -> Work block
;	R5 = Undefined
;	
;	
;-									;019

LOGLOG:	MOV	@(R1)+,R0	; Get console DDB pointer		;047
	CMPB	DDJBNO(R0),@#FIJOB ; Owned by caller?
	BNE	30$		; No, he's detached
	BIT	#DDCONS,DDCNT(R0) ; Yes, but as console?
	BNE	40$		; Yes, so he's attached after all
30$:	CLR	R0		; Clear pointer to indicate detached
40$:	MOV	R0,-(SP)	; Save console pointer
	MOVB	@#SYSUN2,R0	; Get FIP unit number * 2 of system disk ;029
	TST	UNTLVL(R0)	; New disk?
	BEQ	10$		; No, error				;019
	MOV	R3,-(SP)	; Save name entry link			;019
	MOV	#AA.DAT,R0	; Look for date/time blockette
	CALLX	SAA		; Find it				;021
	BCS	10$		; Not there, error			;021
	MOV	R3,-(SP)	; Save date/time block link		;029
	CMPB	@#FIPFUN,#STAFQ ; Logging in the initial job?		;029
	BEQ	48$		; Yes, skip expiration/quota checks	;029
	CMP	@#DATE,AT.EXP(R5) ; Is account expired?			;021
	BHI	20$		; Yes, so don't log in			;022
	BITB	#JOBNQT,FQFIL(R4) ; Spawning and no quota check?	;044
	BNE	48$		; Yes, so skip the check		;044
	MOV	2(SP),R3	; Re-get name block link		;029
	FCALL	GETJQ		; Get job quotas and counts		;043
	CMPB	R2,R3		; Can we allow another job?		;052
	BHIS	42$		; No, forget it				;052
	TST	4(SP)		; Yes, is it a detached job though?	;052
	BNE	41$		; No, so don't adjust the count		;052
	INC	R0		; Yes, count another detached job	;052
41$:	MOVB	#-2,R3		; Guess at exceeding detached quota	;052
	CMPB	R0,R1		; Have we exceeded the quota?		;029
	BLOS	50$		; No, not yet, everything is OK		;052
42$:	MOVB	R3,FQFUN(R4)	; Quota exceeded, return the info	;029
	ADD	#3*2,SP		; Pop the stack				;029
	RETURN			;  and exit				;047

150$:	JMPX	FIEXIT		;Back to FIP reporting the error	;047

48$:	CLR	R5		; Clear the QT2 pointer word		;059
50$:	MOVB	@#SYSUN2,R2	; Get the unit * 2 of the system disk	;027
	CMP	UNTLVL(R2),(PC)+ ; Support extended quota data?		;030
	 .BYTE	2,1							;027
	BLO	64$		; No					;030
	MOV	R5,-(SP)	; Save the QT2 pointer (maybe)		;059
	MOV	R4,R0		; Copy work block pointer		;047
	ADD	#FQPPN,R0	; And point to the PPN			;047
	MOV	#2000,R2	; Set increment count			;030
	CALLM	CREQTB,OPNAP5	;  and create a QTB for this user	;030
	BCS	150$		; Error during create, can't log in	;030
	MAP	FIP,DATA,PIC	; Remap FIP				;027
	MOV	(SP)+,R5	; Get QT2 pointer back again (maybe)	;059
	BNE	60$		;  and use it if its there.		;059
	CMPB	@#FIPFUN,#STAFQ ; Logging in the initial job?		;059
	BEQ	64$		; Yes, don't reset the [1,2] counter	;059
	MOV	#AA.QT2,R0	; Get the QT2 block			;059
	MOV	2(SP),R3	; from this name blockette		;059
	CALLX	SAA		;  and go get it.			;059
	BCS	5$		; OH NO, can't have that!		;059
60$:	CLRB	A2.PWF(R5)	; Clear out the bad PWD counter		;059
	MARK	FIBUF		;  and write it back to disk		;059
	TST	4(SP)		; Is there a console KB pointer?	;059
	BEQ	62$		;  No, so its non-interactive		;061
	MOV	@#FIJBDA,R3	; Get the JDB pointer for this job	;061
	BIT	#J2BAT,JDFLG3(R3) ; Is it a batch job?			;061
	BEQ	64$		; No, so it is INTERACTIVE		;061
62$:	ADD	#A2.NDT,R5	; point to the last two words		;059
	CALL	140$		; and go put the date/time there	;059
64$:	MOV	(SP)+,R3	; Restore date/time block link		;030
	CALLX	RDE		; Reread the date/time blockette	;027
	ADD	#AT.LDA,R5	; Point to login date/time/place data	;059
	MOV	2(SP),R0	; Get console pointer			;021
	BEQ	70$		; None = non-interactive, skip		;029
	MOV	@#FIJBDA,R3	; Get the JDB pointer for this job	;061
	BIT	#J2BAT,JDFLG3(R3) ; Is it a batch job?			;061
	BNE	70$		; Yes, so it was NON-INTERACTIVE	;061
	MOVB	DDUNT(R0),-1(R5) ; Store keyboard number
	CALL	140$		; update the date/time blockette	;059
	TST	-(R5)		; Backup R5 to AT.LDA			;059
70$:	MOV	AT.PTI-AT.LDA(R5),R0 ; Get account flags		;059
	MOV	(SP)+,R3	; Restore name entry link		;019
	CALLX	RDE		; Read it				;019
	MOV	@#FIJBDA,R2	; Get JDB pointer 			;049
	BIC	#J2CAPT,JDFLG3(R2) ; Assume not a captive account	;049
	TST	R0		; Correct?				;029
	BPL	80$		; Yes					;029
.ASSUME	AT.CAP LT 0							;029
	BIS	#J2CAPT,JDFLG3(R2) ; Captive, so set the flag		;049
80$:	MAP	@#FIPJC6,APR=6,DATA,PIC,R=1 ;Map this job's JCR entry	;049
	MOV	@#FIPJCR,R1	;And point to it			;049
	MOV	UAR(R5),JCUFDR(R1) ; Set DCN of UFD (if any)		;049
	MAP	FIPPOL		; And restore FIP pool mapping		;049
	INCB	UACNT+1(R5)	;  and count as one more login
	MARK	FIBUF		; Mark buffer for write
	MOV	#AA.PRV,R0	; Look for privileges			;019
	CALLX	SAA		; Are they there?			;019
	ROR	-(SP)		; Save the carry			;021
	MOV	@#FIJBDA,R1	; Point to JDB				;029
	TST	(R1)+		; Now to flags				;029
.ASSUME	JDFLG EQ 2							;029
	MOV	@#FIJBD2,R3	; Point to caller's JDB2		;021
	MOV	FQPPN(R4),J2PPN(R3) ; Logged in now, so set PPN		;047
	MOV	FQPPN(R4),@#FIUSER ; And set the current job in FIP	;047
	BIS	#JFSYS!JFSYST,(R1) ; Give him temp privs		;021
	BIS	#J2PRVP,JDFLG3-JDFLG(R1) ; Mark as priv'd program	;049
	MAP	@#FIPJC6,APR=6,DATA,PIC ; Map the job's JCR entry	;049
	MOV	@#FIPJCR,R3	; And point to it			;049
	ADD	#JCSPRV,R3	; Point to mask save area		;049
	MOV	#PRIVSZ/2,R0	; Count to clear			;021
90$:	CLR	(R3)+		; Clear out saved (normal) privs	;021
	SOB	R0,90$		;  until done				;021
	ROL	(SP)+		; Did we find attributes?		;021
	BCC	100$		; Yes, move them			;021
	MOV	R3,R5		; No, so we'll give him zeroes		;021
	SUB	#PRIVSZ+AP.PRV,R5 ;  by pointing to the cleared mask	;021
100$:	ADD	#AP.PRV,R5	; Point to privileges			;021
	MOV	#PRIVSZ/2,R0	; Get word count			;021
.ASSUME	JCAPRV EQ JCSPRV+PRIVSZ						;049
110$:	MOV	(R5),JCSPRV-JCAPRV(R3) ; Set up authorized as normal	;049
	BIS	(R5),JCPRIV-JCAPRV(R3) ;  and merge in with temporary	;049
	MOV	(R5)+,(R3)+	; Now set up authorized privs		;019
	SOB	R0,110$		; Loop until done			;019
	MOV	(SP)+,R3	; Get ch #0 (terminal) DDB address
	BEQ	130$		; None, so don't set a login time
	MOV	@#TIME,DDTIME(R3) ; Enter log in time
130$:	BIS	#JFIOKY,(R1)	; Post keyword				;019
	MAP	FIPPOL		; Restore FIP pool mapping before exit	;049
	RETURN			;  and return				;019

140$:	SPLC	6		;; NO clock change for a bit.		;059
	MOV	@#DATE,(R5)+	;; Store date of login
.ASSUME	AT.LDA EQ AT.KB+1
	BIC	#AT.MSK,(R5)	;; Clear out time field in attributes	;029
	BIS	@#TIME,(R5)	;;  and update it			;029
.ASSUME	AT.LTI EQ AT.LDA+2
	SPLC	3		;; OK, the clock can change now.	;059
	MARK	FIBUF		; Mark buffer for write
	RETURN			; go to the next step now		;059
.DSABL	LSB								;019

GLOBAL	<FIJBD2,FIPFUN,FIQUE,FIUSER,SYSUN2,OPNAP5,JOBNQT,FIPJCR,FIPJC6>	;049

FQFEND

FQFSRT
        
.SBTTL	ACCOUNTING DUMP

;+              
; UU.ACT - ACCOUNTING INFORMATION DUMP.
;
;	R1 -> JOB DATA BLOCK
;	R4 -> FIRQB
;		FQPPN  =  PPN (0=>SELF)
;-
                
.ENABL	LSB

	UUOENT	ACT,<GACNT,WACNT>,,LOGABL,DOLOG	;ACCOUNTING DUMP	;024

	MOV	FQPPN(R4),R0	;Get PPN to dump to			;039
	CALLX	CHKACC		;Check access rights			;039
	TST	R0		;Do we have accounting rights?		;039
	BPL	20$		;No, error				;039
.ASSUME	DDSTAT LT 0							;039
	MOV	R4,R0		;COPY FIRQB POINTER
	ADD	#FQPPN,R0	;INDEX DOWN TO SUPPLIED PPN
	TST	(R0)		;ANY SUPPLIED ?
	BNE	10$		;YES, SO USE IT
	MOV	#FIUSER,R0	;NO, USE CALLER'S PPN
10$:	CALLX	SDM		;FIND THAT ACCOUNT			;024
	BCC	CHARGE		;Found it, go charge the account	;048
	ERROR	NOSUCH		;CAN'T FIND ACCOUNT TO UPDATE

20$:	ERROR	PRVIOL		;Trying to do it to another group if GACNT ;024
           
.DSABL	LSB

GLOBAL	<FIUSER>							;048

;+              
; CHARGE - Charge a user for his time
;          
;    	R5 -> Account's name entry in GFD
;                                                                   
;	CALL	CHARGE
;
; All registers are undefined.
;-
                                                
.ENABL	LSB

CHARGE:	CALLX	RAE		;Read accounting entry			;048
	MOV	R5,-(SP)	;And save pointer to it			;005
	MAP	@#FIPJC6,APR=6,DATA,PIC,R=2 ;Map the job's JCR entry	;049
	MOV	@#FIPJCR,R2	;And point to it with R2		;049
	MOV	#DEVPTR+DEVOKB,R3 ;Point to DDB pointer table at keyboards ;005
10$:	MOV	<DEVCNT-DEVPTR>(R3),R4 ;Get max unit # of this device type ;005
	INC	R4		;Now get the actual count		;005
	MOV	(R3)+,R5	;Get pointer table for this device type	;005
20$:	MOV	(R5)+,R1	;Get a device DDB			;005
	CMPB	DDJBNO(R1),@#FIJOB ;Is this device owned by our caller?	;048
	BNE	40$		;No, so skip this device		;048
	BIT	#DDCONS,DDCNT(R1) ;Yes, but is it the console?		;048
	BNE	40$		;Yes, that's not "device" time		;048
	MOV	DDTIME(R1),R0	;No, get time of assignment		;048
	MOV	@#TIME,DDTIME(R1) ;And reset it to now			;048
	SUB	@#TIME,R0	;Find elapsed time			;048
	BPL	30$		;Positive, hasn't crossed midnight	;048
	ADD	#1440.,R0	;Negative, correct time time		;048
30$:	ADD	R0,JCDEV(R2)	;Charge our caller for this time	;048
40$:	SOB	R4,20$		;Loop for all units of this type	;005
	CMP	R3,#DEVPTE	;The end?				;005
	BLO	10$		;If not, then loop			;005
	TST	#JCCPUI		;Do we have Control/T support?		;048
	BEQ	50$		;No, not this time			;048
	CLR	JCCPUI(R2)	;Yes, go clear incremental time		;048
50$:	ADD	#JCCPU,R2	;Now point to the CPU time cell		;049
	MOV	(SP)+,R5	;Restore accounting entry pointer	;005
	TST	(R5)+		;Advance to MCPU in GFD			;049
.ASSUME	MCPU EQ 2                                 
	ADD	(R2),(R5)+	;COLLECT LSB OF CPU TIME AND                
	ADCB	JCCPUM-JCCPU(R2) ; CARRY INTO MSB			;049
	CLR	(R2)+		;NOW CLEAR IN-MEMORY TIME
	ADD	(R2),(R5)+	;COLLECT CONNECT TIME
.ASSUME	JCCON EQ JCCPU+2
	CLR	(R2)+		;NOW CLEAR IN-MEMORY TIME
	ADD	(R2),(R5)+	;COLLECT LSB OF KCT'S AND
.ASSUME JCKCT EQ JCCON+2                                          
	ADCB	JCKCTM-JCKCT(R2) ; CARRY INTO MSB			;049
	CLR	(R2)+		;NOW CLEAR IN-MEMORY TIME
	ADD	(R2),(R5)+	;COLLECT DEVICE TIME
.ASSUME JCDEV EQ JCKCT+2
	CLR	(R2)+		;NOW CLEAR IN-MEMORY TIME
	MOVB	(R2)+,R0	;GET MSB OF KCT'S
.ASSUME JCKCTM EQ JCDEV+2                                                 
	ADD	(R5),R0		;ADD IN WHAT WAS ON-DISK
	BIC	#^C<1777>,R0	; AND TRIM TO CORRECT MAXIMUM
	MOVB	(R2)+,R3	;GET MSB OF CPU TIME
.ASSUME JCCPUM EQ JCKCTM+1
	ASH	#10.,R3		; AND SHIFT TO CORRECT LOCATION
	ADD	R3,(R5)		;COLLECT MSB OF CPU TIME
	BIC	#1777,(R5)	;CLEAR OUT AND MSB OF KCT'S                 
	BIS	R0,(R5)+	; AND .OR. IN THE REAL VALUE
	CLR	-(R2)		;NOW CLEAR OUT IN-MEMORY MSB'S
	MAP	FIPPOL		;Restore FIP mapping			;049
	MARK	FIBUF		;INDICATE WRITING NEEDED
	RETURN			; AND EXIT

GLOBAL	<DEVPTR,DEVOKB,DEVCNT,DEVPTE,FIPJCR,FIPJC6>			;005
.WEAK	JCCPUI								;049

.DSABL	LSB

FQFEND

FQFSRT

.SBTTL	LOGIN

;+
; UU.LIN - LOGIN.
;
;	R1 -> JOB DATA BLOCK
;	R2 -> SECOND JOB DATA BLOCK
;	R3 =  CURRENT PPN (=0 IF LOGGED OUT)
;	R4 -> FIRQB
;		FQSIZM =  Options					;021
;				bit 0 = password-check function		;021
;				bit 1 = ASCII format password		;021
;				bit 2 = system-password function	;025
;				bit 3 = suppress password check		;039
;		FQPPN  =  PPN (if bit 2 is clear in FQSIZM)		;025
;		FQNAM1 =  PASSWORD (2 WORDS RAD50 or 8 words ASCII,	;021
;			  depending on FQSIZM)				;021
;
;	IN FIRQB ON RETURN (for regular login function)			;025
;		+3     =  Status code					;029
;				-1  =	Ok				;029
;				-2  =	Too many detached jobs		;029
;				>=0 =	Too many jobs total;		;029
;					value returned = job quota	;029
;		+4     =  NUMBER OF JOBS LOGGED IN UNDER THAT ACCOUNT
;		+5     =  JOB NUMBER OF DETACHED JOB
;		          ...
;		          0
;
; The password-check function is used to verify a password for		;021
; correctness.  It forces the user's PPN unless the caller has		;025
; the appropriate accounting privilege.					;025
; The system-password function is used to validate a system access	;025
; password.  The system access password is stored as the [0,1]		;025
; password.  If the function succeeds, a flag is set to indicate that	;025
; the validation has occurred.  If the flag was set already, then	;025
; the function always succeeds.						;025
; The system-password function is a No-op (returns success, doesn't	;026
; set the flag) if the type of terminal the job runs at does't		;026
; require a system password.						;026
; The suppress-password-check flag requires accounting privilege	;039
; (GACNT or WACNT).  If set, the password comparison is skipped.	;039
;-

.ENABL	LSB
        
	UUOENT	LIN,,,LOGABL,DOLOG	;LOGIN				;019

	BITB	#1!4,FQSIZM(R4)	;Ordinary login function?		;039
	BEQ	10$		;Yes, skip				;026
	FJMP	PWCHEK		;No, go to password-checking options	;026

10$:	MOVB	#-1,FQFUN(R4)	;Assume login will work			;029
	MOVB	#ERRFQ,JDPOST(R1) ; and make sure FQFUN is posted	;029
	ASRB	FQSIZM(R4)	;Shift the password-check bit out	;026
	TST	R3		;ALREADY LOGGED IN?			;021
	BNE	LOGDET		;YES, SO COUNT DETACHED JOBS ONLY
	CALL	LOGCHK		;NO, SO CHECK OUT THE NEW ACCOUNT
	FCALL	SPWCHK		;System password checked out yet?	;029
	BCS	60$		;No, so reject				;029
20$:	MOVB	@#SYSUNT,R2	;Get FIP unit number			;029
	BITB	#8./2,FQSIZM(R4) ;Asking for suppressed password check?	;039
	BEQ	25$		;No, do the normal thing		;039
	MOV	FQPPN(R4),R0	;Get PPN to log into			;039
	CALLX	CHKACC		;Do access check			;039
	TST	R0		;Have accounting rights?		;039
	BPL	25$		;No, do password check after all	;039
	REGSAV			;Save the registers			;039
	FCALL	CHKFLG		;Check flags but not password		;039
	REGRES			;Restore registers			;039
	BCC	28$		;It worked, go on			;044
24$:	ERROR	NOTAVL		;Can't use this account (same as expired) ;044

LOGBAD:	CLR	-(SP)		;Set a 0 flag for ATTACH failures	;059
	BR	251$

25$:	FCALL	FLGPWD		;Check access flags and password	;025
	BCC	28$		;It worked, go on			;044
	MOV	R4,-(SP)	;Get a <>0 flag for later		;059
251$:	CMPB	R0,#NOTAVL	;Failed on access flags?		;044
	BEQ	24$		;Yes, return that error code		;044
	MOV	#AA.QT2,R0	; Get the QT2 block			;059
	CALLX	SAA		;  and go get it.			;059
	BCS	26$		; OH NO, can't have that!		;059
	INCB	A2.PWF(R5)	; tell them the PWD failed		;059
	MARK	FIBUF		; and write it back to disk		;059
26$:	TST	(SP)+		; which error do we give?		;059
	BEQ	27$		; - go give the ATTACH error		;059
	ERROR	NOSUCH		;GENERAL "YOU BLEW IT" ERROR MESSAGE	;044

27$:	ERROR	BADFUO		;Otherwise generic error		;044

28$:	CLRB	FQFIL(R4)	;No spawn-type options for LOGLOG	;047
	FCALL	LOGLOG		;SO ACTUALLY LOG THE USER IN		;029
	MOV	FQPPN(R4),R3	;Get PPN being logged into		;029
LOGDET:	MOV	R3,-(SP)	;Stack the requested PPN		;029
	MOV	R4,R3		;COPY THE FIRQB POINTER
	CMP	(R3)+,(R3)+	;SKIP TWO WORDS IN FIRQB
	MOV	R3,R2		;COPY FIRQB POINTER
	CLRB	(R2)+		; FOR COUNTER OF JOB UNDER THIS PPN
	CLR	R5		;START JOB NUMBERS AT 0
30$:	TST	(R5)+		;BUMP JOB NUMBER BY 2
	MOV	JOBTBL(R5),R1	;GET JOB ENTRY
	BEQ	30$		;NOT A JOB
	CMP	R1,#-1		;END OF JOB TABLE?
	BEQ	50$		;YES
	CMP	JBPPN(R5),(SP)	;SAME AS OUR USER?			;061
	BNE	30$		;NOPE
	INCB	(R3)		;COUNT THIS AS A JOB
	MOV	@(R1)+,R1	;NOW GET TTY DDB ADDRESS
	CMPB	R5,DDJBNO(R1)	;IS THE USER DETACHED?
	BNE	40$		;YEP
	BIT	#DDCONS,DDCNT(R1) ;REALLY DETACHED?
	BNE	30$		;NOPE
40$:	MOVB	R5,(R2)		;IF SO, THEN STASH USER'S JOB NUMBER
	ASRB	(R2)+		;MAKE NOT TIMES 2
	BIT	R2,#40-1	;OFF END OF FIRQB NOW?
	BNE	30$		;NOPE
	DEC	R2		;YEP, SO OVERLAY LAST ENTRY
	BR	30$		;BUT CONTINUE
        
50$:	CLRB	(R2)+		;END WITH A ZERO BYTE
	TST	(SP)+		;Clean up the stack			;029
	RETURN			; NOW EXIT

60$:	JMPX	ERROR		;Abort the operation			;029

.DSABL	LSB

GLOBAL	<JOBTBL,FIPUNT,UNTLVL,FIUSER,JBPPN>

; Check out the account to log in under

LOGCHK:	TSTB	FQPPN+1(R4)	; Trying [0,*]?				;022
	BEQ	10$		; Yes, call it an error			;019
	MOV	R4,R0		; Copy the FIRQB pointer		;021
	ADD	#FQPPN,R0	;  and index to PPN, password
	CALLX	SDM		; No, search for the account
	BCS	10$		; Not found, error			;025
	MOV	R0,-(SP)	; Sae PPN pointer			;051
	MOV	R3,-(SP)	; Save link to name entry		;025
	MOV	#AA.PAS,R0	; First, look for the password block	;051
	CALLX	SAA		; Is it there?				;051
	BCS	10$		; No, NOUSER account, forget it		;051
	MOV	(SP),R3		; User account, get NE pointer again	;051
	MOV	#AA.DAT,R0	; Set up to find date/time attribute	;025
	CALLX	SAA		; Go search for it			;025
	BCS	20$		; Not found, error			;025
	MOV	(SP)+,R3	; Restore name entry link		;025
	MOV	(SP)+,R0	; Restore PPN pointer			;051
	RETURN			; Done					;025

10$:	ERROR	NOSUCH		; General "you blew it" error		;019

20$:	ERROR	BADDIR		; Date/time entry missing, bad news	;025

;+
; UU.ATT - ATTACH AND REATTACH.
;
;	R4 -> FIRQB
;		+4     =  JOB NUMBER TO ATTACH TO
;		+5     =  KB NUMBER TO REATTACH TO [REATTACH]
;			  0 to attach, 1 to swap console [Attach]
;			  2 for attach with long password
;			  4 to attach without password check (priv'd)	;044
;		FQPPN  =  PPN [ATTACH, if not = caller's]
;		FQNAM1 =  PASSWORD (2 WORDS) [ATTACH, if changing PPN]
;-

	UUOENT	ATT,,,LOGABL,DOLOG	;ATTACH

	MOV	@#FIJBDA,R2	;GET CALLING JOB DATA POINTER
	MOV	(R2)+,R5	;NOW GET CALLING JOB'S IOB POINTER
	MOV	(R5)+,R1	; AND CALLING JOB'S TTY DDB (CH #0)
	CMP	(R4)+,(R4)+	;INDEX TO JOB NUMBER TO ATTACH TO
	MOVB	(R4)+,R0	; AND GET JOB NUMBER TO ATTACH TO
	ASL	R0		;MAKE THAT TIMES 2
	CMP	R0,#JOBMX2	;TOO BIG?
	BHI	50$		;YES, ERROR
	CMPB	R0,@#FIJOB	;SAME AS CALLING JOB?
	BNE	60$		;No, so it can't be reattach		;025
	FJMP	REATTA		;Yes, so do it				;025

60$:	MOV	JOBTBL(R0),R2	;GET NEW JOB'S DATA POINTER
	BEQ	50$		;NO JOB IS ERROR
	CMPB	(R4),#4		;Valid option flag?			;044
	BHI	50$		;Only 0 - 4 are allowed			;044
	MOVB	(R4),-(SP)	;Save attach vs. kbswap flag
	ASRB	(R4)+		;Leave ascii/rad50 and nopassword flags	;044
	BIC	#^C<1>,(SP)	;Leave only attach/swap flag on stack
	FJMP	ATTAC2		;And continue in the next overlay	;049

50$:	ERROR	PRVIOL		;General "you blew it" error		;049

FQFEND									;026

FQFSRT

.SBTTL	Attach

.ENABL	LSB

; Come here if job number specified is an attached job.  Check for the
; case of a detached job doing a Kbswap function.

10$:	FJMP	REATT2		;Off to reattach for checking		;041

20$:	CMPB	R0,DDJBNO(R1)	;DOES JOB # MATCH JOB # IN TTY DDB?
	BNE	30$		;NO, MUST BE DETACHED
	;CLC			;CARRY=0 SINCE 'BEQ' FROM 'BHIS'='BCC'
	BIT	#DDCONS,DDCNT(R1) ;YES, BUT IS JOB REALLY DETACHED?
	BNE	40$		;NOT DETACHED (C=0 EXIT)
30$:	SEC			;DETACHED (C=1 EXIT)
40$:	RETURN			; AND EXIT
                  
50$:	ERROR	BADFUO		;General error				;025

ATTAC2:	MOV	R0,-(SP)	;SAVE NEW JOB NUMBER (TIMES 2)		;049
	MOV	(R2),-(SP)	;SAVE NEW JOB'S IOB POINTER
	MOV	@(R2)+,R1	;GET NEW JOB'S CH #0 DDB POINTER
	CALL	20$		;NEW JOB DETACHED?
	BCC	10$		;No, check it out
	MOV	R4,R0		;PUT Pointer to firqb@PPN in safe place	;063
	TST	-(R2)		;POINT AT THE JOB'S JDB
	MOV	JDJDB2(R2),R3	;RETRIEVE THE JDB2 POINTER
	TST	(R0)		;PPN specified?
	BNE	60$		;Yes
	MOV	@#FIUSER,(R0)	;No, so supply caller's
60$:	CMP	(R0),J2PPN(R3)	;Did caller specify correct PPN?
	BNE	50$		;NO SO FLAG THIS AS AN ERROR
	CMP	(R0),@#FIUSER	;Same as caller's?
	BEQ	120$		;Yes, so no password check needed
	TSTB	4(SP)		;KBswap function?
	BNE	50$		;Yes, requires matching PPN
	MOV	R0,-(SP)	;Save PPN pointer			;039
	MOV	(R0),R0		;Get PPN to attach to			;039
	CALLX	CHKACC		;Check access rights			;039
	TST	R0		;Have accounting rights?		;039
	BPL	50$		;No, error				;039
.ASSUME	DDSTAT LT 0							;039
	MOV	(SP)+,R0	; and restore R0			;039
70$:	BIC	#37,R4		;point R4 back to top of FIRQB
	FCALL	LOGCHK		;Check out PPN, read date/time block	;025
	TST	@#FIUSER	;Currently logged in?			;029
	BNE	80$		;Yes, so no need to check sys pw again	;029
	FCALL	SPWCHK		;No, check for system password passed	;029
	BCC	80$		;System password OK, that's good	;041
	JMPX	ERROR		;System password bad, quit		;041

80$:	MOVB	@#SYSUNT,R2	;Get FIP unit number			;029
	BITB	#4/2,FQSIZM(R4)	;Asking to skip password check?		;044
	BEQ	100$		;No, move on				;044
	REGSAV			;Yes, save registers			;044
	FCALL	CHKFLG		;Check flags only			;044
	REGRES			;Restore registers			;044
	BCC	120$		;It worked, go on			;044
90$:	ERROR	NOTAVL		;Special error for no access		;044

100$:	FCALL	FLGPWD		;Check out access flags and password	;044
	BCC	120$		;Match, all set				;044
	FJMP	LOGBAD		; No match = count and give error	;059

110$:	ERROR	BADFUO		;Otherwise generic error		;044
                  
120$:	MOV	@#FIJBDA,R3	;GET CALLING JOB'S DATA POINTER
	MOV	@(R3)+,R1	;GET CALLING JOB'S CH #0 TTY DDB POINTER
.ASSUME	JDIOB	EQ	0
	MOVB	@#FIJOB,R0	;GET CALLING JOB NUMBER (TIMES 2)
	CALL	20$		;IS CALLING JOB DETACHED?
	BCS	50$		;YES, ERROR
	CMPB	TTINTF(R1),#TTPK11 ;Are we running on a PK?		;041
	BNE	140$		;No, not this time			;041
	MOV	R1,-(SP)	;Yes, so save DDB pointer		;041
	MOVB	DDUNT(R1),R1	;Get the keyboard number		;041
	ASL	R1		;Now get unit # * 2			;005
	MOV	CSR.KB(R1),R1	;And get PK DDB pointer			;005
	MOVB	DDJBNO(R1),R0	;Get controlling job's job # 		;005
	BIT	#1,R0		;Is the controlling job a system job?	;056
	BNE	130$		;Yes, skip priority check		;056
	CALLX	MAPJCR		;Map controlling job JCR entry		;049
	MOVB	JCPRI(R1),R2	;And pick up the priority		;049
	MOVB	4(SP),R0	;Get new job # * 2			;049
	CALLX	MAPJCR		;And map the JCR entry			;049
	CMPB	R2,JCPRI(R1)	;Controller priority lower than new job? ;049
	BLT	110$		;Yes, so don't do the attach		;044
130$:	MOV	(SP)+,R1	;Restore old console DDB address	;056
140$:	MOV	(SP)+,R2	;GET NEW IOB ADDRESS			;041
	MOV	(SP)+,R5	;RESTORE NEW JOB NUMBER (TIMES 2)
	MOVB	R5,DDJBNO(R1)	;SET NEW JOB NUMBER INTO TTY DDB	;041
	BIC	#^C<DDASN!DDCONS>,DDCNT(R1) ;Clear out count etc.	;029
	MAP	FIPPOL		;Map FIP pool for the IOB		;049
	MOV	(R2),R4		;SAVE "OLD" CONSOLE DDB POINTER
	MOV	#16.,R0		;And set up the channel count		;049
				;Note: R5 will never be zero therefore	;065
				; DDCNT will be updated.		;065
	CALL	UPDC2		;Update console pointers in IOB		;029
	MOV	R4,-(SP)	;Save "old" DDB pointer			;039
	MOV	R1,R4		;switch DDB pointers			;063
	MOV	(SP),R1		;copy old DDB for test			;063
	MOV	R5,-(SP)	;Save away the new job number		;065
	CLR	R5		;Skip the DDCNT update			;065
	MOV	-(R3),R2	;get callers @JDB (DDB)			;063
	MOV	#16.,R0		; and set up channel count		;063
	CALL	UPDC2		;now update the "other" console pointers;063
	MOV	(SP)+,R5	;Restore the saved job number		;065
	MOV	JOBTBL(R5),R2	;Get new job's JDB pointer		;063
	MOV	@#FIJBDA,R4	;Get JDB pointer for caller		;049
	MOV	JDFLG3(R4),R4	; and now flags				;049
	BIC	#^C<J2NET!J2BAT>,R4 ;Isolate job type			;033
	BIC	#J2NET!J2BAT,JDFLG3(R2) ;Clear out type in new job	;049
	BIS	R4,JDFLG3(R2)	;and set it to match caller's type	;049
	MOV	(SP)+,R4	;Now restore R4				;039

	;This code is commented out because it's unnecessary.		;063
	;The current design does not permit devices to be opened	;063
	; at the command level- only disk files. Therefore the DDB	;063
	; we seek can not be in a PFBIO list, so don't bother looking.	;063
	;Note the code points at wrong JCR anyway!			;063
	;MOV	#14.,R0		;Set up number of channels to do	;063
	;MOV	@#FIPJCR,R2	;Point to JCR entry			;063
	;ADD	#JCPFB+<PF$DAT*2>,R2 ;And point to first data channel	;063
	;CALL	UPDCON		;Update PFB pointers too		;063

	MAP	@#FIPJC6,APR=6,DATA,PIC ;Map JCR entry			;064
150$:	TST	JBWAIT(R5)	;NEW JOB COMPLETELY STALLED?		;029
	BNE	160$		;NO, JOB WILL RUN SOMETIME
	MOV	#JSTIM!JS.KB,JBWAIT(R5) ;YES, SO SET ENOUGH TO RUN SOON
160$:	BIS	#JSTIM,JBSTAT(R5) ;ALWAYS AWAKEN NEW JOB FROM SLEEP
	TSTB	(SP)+		;Was kbswap flag set?
	BNE	230$		;Yes, so don't blow away caller's job
	MOV	@#FIPJCR,R2	;Point to start of JCR again		;005
	MOV	R5,-(SP)	;Save unit number times two		;005
	MOV	#DEVPTR+DEVOKB,R3 ;Point to DDB pointer table at keyboards ;005
170$:	MOV	<DEVCNT-DEVPTR>(R3),R4 ;Get max unit # of this device type ;005
	INC	R4		;Now get the actual count		;005
	MOV	(R3)+,R5	;Get pointer table for this device type	;005
180$:	MOV	(R5)+,R1	;Get a device DDB			;005
	CMPB	DDJBNO(R1),@#FIJOB ;WAS DEVICE OWNED BY CALLING JOB?	;049
	BNE	200$		;NO, SO SKIP THAT DEVICE
	CMP	DDCNT(R1),#DDASN ;Yes, but simply assigned?		;029
	BNE	200$		;Something else/more, so skip it	;029
	MOV	DDTIME(R1),-(SP) ;YES, GET TIME ASSIGNED                    
	MOV	@#TIME,DDTIME(R1) ; AND RESET TIME
	SUB	@#TIME,(SP)	;FIND ELAPSED TIME
	BPL	190$		;NO CORRECTION NEEDED
	ADD	#1440.,(SP)	;CORRECTION NEEDED FOR PAST MIDNIGHT
190$:	ADD	(SP)+,JCDEV(R2)	;COLLECT DEVICE TIME FOR CALLING JOB	;005
	MOVB	(SP),DDJBNO(R1)	; THEN REASSIGN DEVICE TO NEW JOB	;005
200$:	SOB	R4,180$		;Loop for all units of this type	;005
	CMP	R3,#DEVPTE	;The end?				;005
	BLO	170$		;If not, then loop			;005
	MOV	(SP)+,R5	;Restore job number times two		;005
	CLR	R1		;Initialize FIP unit number to check
210$:	TST	UNTCNT(R1)	;Mounted disk?
	BMI	220$		;No, skip it
.ASSUME	UC.MNT LT 0
	CMPB	UNTOWN(R1),@#FIJOB ;Mounted /NOSHARE by caller?		;049
	BNE	220$		;No, skip it                                
	MOVB	R5,UNTOWN(R1)	;Yes, update ownership to new job
220$:	TST	(R1)+		;Update FUN * 2
	CMP	R1,#MAXUN2	;Done scanning all units?
	BLOS	210$		;Loop if not
	MOV	@#FIJBDA,R3	;Yes, get JDB pointer			;005
	BIS	#JFSPCL,JDFLG(R3) ;INDICATE SPECIAL CONDITION FOR CALLER ;005
	BISB	#JFKILL,JDFLG2(R3) ; AS JOB KILL			;005
	MOVB	#127.,JCPRI(R2)	;ENSURE THAT JOB WILL RUN SOON		;005
230$:	MAP	FIPPOL		;Restore FIP pool mapping		;049
	RETURN			; AND EXIT

UPDCON:	CMP	R4,(R2)		;THIS CHANNEL MATCH OLD CONSOLE?
	BNE	240$		;NO
	CMPB	DDJBNO(R1),DDJBNO(R4) ;YES, STILL OWN THE OLD ONE?
	BEQ	240$		;JUST SKIP IT IF STILL OWNED
UPDC2:	MOV	R1,(R2)		; ELSE SET POINTER TO NEW CONSOLE	;029
240$:	CMP	R1,(R2)+	;THIS CHANNEL MATCH CONSOLE?
	BNE	250$		;NO, SKIP IT
	TST	R5		;Allowed to update DDCNT?		;065
	BEQ	250$		;No					;065
	INCB	DDCNT(R1)	;ELSE CORRECT ACCESS COUNT
250$:	SOB	R0,UPDCON	;Loop for all the channels		;049
	RETURN								;029

.DSABL	LSB        

FQFEND

GLOBAL	<FIJBDA,JOBMX2,FIJOB,FIPUNT,UNTLVL,JOBTBL,JBWAIT,JBSTAT>	;019
GLOBAL	<FIPRVM,DEVPTR,DEVOKB,DEVCNT,DEVPTE,CSR.KB,FIPJCR,FIPJC6> 	;005

FQFSRT             

.SBTTL	DETACH

;+
; UU.DET - DETACH.
;
;	R0 =  JOB NUMBER TIMES 2
;	R4 -> FIRQB
;		FQERNO =  0 => DETACH SELF; NO TERMINAL CLOSE
;		       =  200 => DETACH SELF; TERMINAL CLOSE
;		       <> 0 => DETACH JOB N; NO TERMINAL CLOSE
;		       <> 0+200 => DETACH JOB N; TERMINAL CLOSE
;-

	UUOENT	DET,,,LOGABL,DOLOG,LOCK	;DETACH				;043

	MOVB	FQERNO(R4),R3	;Pick up job number to detach		;038
	BMI	5$		;/CLOSE detach, don't check console opens ;041
	MOV	@#FIJBDA,R1	;/NOCLOSE, get JDB pointer		;041
	MOV	@(R1)+,R1	;Now get console DDB pointer		;041
.ASSUME	JDIOB	EQ	0
	CMPB	DDCNT(R1),#1	;Is there exactly one open?		;041
	BNE	DETJB2		;No, so not an ICFP detach		;043
5$:	BIC	#^C<177>,R3	;Save only job #			;041
	BEQ	10$		;Same job, might be ICFP detach		;038
	ASL	R3		;Get job # * 2 to detach		;038
	CMPB	R0,R3		;Trying to detach self?			;038
	BNE	DETJB2		;No, so not an ICFP detach		;043
10$:	MOV	@#FIJBDA,R1	;Get JDB pointer			;049
	TSTB	JDFLG3(R1)	;Is ICF active?				;049
	BPL	DETJB2		;No, so not an ICFP detach		;043
.ASSUME	J2ICF EQ 200							;029
	MOVPIC	#70$,R2		;Get error trap address			;049
	MOV	R2,@#FIPERX	;Now set up the private error trap	;049
	CALL	CHKDPV		;Check privileges for detach		;038
	MOV	(R1),R1		;Get IOB pointer			;049
.ASSUME	JDIOB	EQ	0
	MOV	@#FIPJCR,R0	;Pick up JCR pointer			;049
	ADD	#JCPFB+<PF$DAT*2>,R0 ;And point to first data channel	;049
	MOV	#14.,R5		;Set up PFB channel count		;049
	MOV	(R1)+,R3	;Get console DDB pointer		;038
	BIT	#DDCONS,DDCNT(R3) ;Job attached?			;038
	BEQ	50$		;No, forget this call			;038
	CMPB	@#FIJOB,DDJBNO(R3) ;Really attached?			;038
	BNE	50$		;No, so forget this			;038

; Note: The check above for detached is done as a nicety. Since this
; call involves queueing and multiple FIP requests, it is possible
; that the job may get detached while this operation is being processed.
; If this happens, the final processing in SCH will notice this case and
; cause the new job to be created detached.

20$:	MAP	@#FIPJC6,APR=6,DATA,PIC,R=2 ;Map the JCR entry for the PFB ;050
	MOV	(R0)+,R2	;Get a PFB data channel			;029
	BEQ	40$		;Not open, skip				;029
	CMP	R2,R3		;Open to console?			;038
	BEQ	40$		;Yes, so skip it			;038
	MAP	FIPPOL		;Map the FIP pool for the IOB		;049
30$:	CMP	R2,(R1)+	;Also open on IOB?			;029
	BEQ	60$		;Yes, can't do the detach then		;038
	BIT	#40-1,R1	;Done checking IOB channels?		;029
	BNE	30$		;Not yet				;029
	SUB	#40,R1		;Yes, back to start of IOB		;029
40$:	SOB	R5,20$		;And loop for all PFB channels		;049

; At this point, we have determined that the spawn/detach is legal,
; so we will set up the work block for the spawn code and go there.

	MAP	@#FIPJC6,APR=6,DATA,PIC,R=0 ;Map job's JCR entry	;049
	MOV	@#FIPJCR,R0	;Pick up JCR pointer			;049
	MOV	JCDRTS(R0),R0	;Get job's default RTS pointer		;029
	MAP	FIPPOL		;Restore FIP mapping			;049
	MOV	R.NAME(R0),FQNAM1(R4) ;Set in work block		;029
	MOV	R.NAME+2(R0),FQNAM1+2(R4)				;029
	MOV	#220,FQFIL(R4)	;Enter KBM, ignore login maximum if priv'd ;043
.ASSUME FQSIZM EQ FQFIL+1	;Indicate spawn is to be detached	;043
	MOV	@#FIUSER,FQSIZ(R4) ;Set account to use			;029
	CLR	20(R4)		;No priority games			;029
	CLR	22(R4)		;Ditto					;029
	CLR	@#FIPERX	;Disable the error trap			;043
	FJMP	SPWDET		;And finish up in the spawn code	;043

; The spawn code will be entered with the FIRQB set up looking like
; a spawn request with all the appropriate FIRQB contents set up.
; 
; The spawn code can tell that this is an ICFP detach because we
; do not set the spawn-logged-in flag in FIRQB+FQFIL. Any true
; spawn-logged-in request will have the bit set.
;
; The spawn code will attempt to duplicate the job in memory (two MEMLST
; entries for the same memory), and swap out one of the copies.  If that
; isn't possible, the detach will fail with an error. If that works, the
; new job will be created, with a copy of the job header, and low core.
;
; If the creation succeeds, the spawn will exit FIP and the new job will
; enter FIP with a request to log in the new job. If the login of the
; new job fails, SCH will post the error code to the old job and kill
; the new job. If the login succeeds, the new job will take all the
; PFB channels from the old job and continue.

50$:	ERROR	BADFUO		;Already detached			;038
60$:	ERROR	DTOOOF		;Device open on both PFB and IOB	;038

; The following is a private error trap so that we can fix up the
; lock count before exiting FIP.

70$:	MOVB	@#FIJOB,R0	;Get the job number			;043
	CALLX	UNLOCK		;Now unlock the job			;043
	JMPX	FIEXIT		;And get out of here...			;043

GLOBAL	<FIJBDA,FIJBD2,JOBTBL,SPWDET,FIPERX,FIPJC6,FIPJCR>		;049

DETJB2:	CALLX	UNLOCK		;Unlock the job first			;043
DETJOB:	MOV	R4,-(SP)	;Save FIRQB pointer			;029
	MOVB	FQERNO(R4),R5	;GET JOB NUMBER				;029
	SXT	-(SP)		;PUT -1 ON STACK IF CLOSE OFF TTY CHANNEL
	ASL	R5		; NOW TIMES 2
	MOVB	R5,R5		;  AND TRIM OFF THE HIGH BYTE
	BNE	10$		;ONE WAS SPECIFIED
	MOVB	R0,R5		; ELSE USER THE CALLER'S
10$:	CMP	R5,#JOBMX2	;LEGAL?
	BHI	30$		;NO, ERROR
	MOVB	R5,FQERNO(R4)	;Save job * 2 being detached		;029
	CMPB	R0,R5		;Trying to detach self?			;025
	BEQ	20$		;Yes, skip				;025
	TSTPRV	JOBCTL,@#FIPRVM	;Otherwise must be able to do it to jobs ;029
	BEQ	30$		;Error if not				;025
20$:	MOV	JOBTBL(R5),R1	;GET JOB DATA ADDRESS
	BEQ	30$		;NONE, ERROR
	MOV	R4,-(SP)	;Save work block pointer		;029
	MOV	R5,R4		;Copy job number			;029
	CALLX	CONNEC		;COMPUTE CONNECT TIME
	MOV	(SP)+,R4	;Restore work block pointer		;029
	BCC	40$		;ATTACHED, O.K. TO DETACH
30$:	ERROR	BADFUO		;ELSE AN ERROR

40$:	CALL	CHKDPV		;Check privileges for detach		;038
	MOV	R3,R1		;MOVE KB DDB POINTER TO HERE		;036
	DECB	DDCNT(R1)	;ONCE LESS INIT'D NOW
	BIS	#DDCONS,(SP) 	; AND NO LONGER THE CONSOLE
	BIC	(SP)+,DDCNT(R1)	;FORCE A 0 IF CLOSE OFF TTY CHANNEL
	BEQ	45$		;No longer in use, go free it up	;060
	BIT	#DDDYNA,(R1)	;In use.  Dynamic KB (PK or LAT)?	;060
	BEQ	50$		;No, nothing to do			;060
	MOV	JOBTBL(R5),R4	;Yes, get JDB pointer			;062
	MOV	#KBFDD2,@(R4)+	;Point DDB at fake DDB			;060
	BR	50$		;All done				;060

45$:	SPLC	5		;;Lockout terminal interrupts		;060
	CALLMI	ENDKEY,KBDAP5	;;FREE UP THIS KEYBOARD
	SPLC	3		;;BACK TO LEVEL 3 NOW
50$:	MOV	(SP)+,R4	;Restore R4 for caller			;029
	RETURN			;NOW EXIT

GLOBAL	<JOBMX2,JOBTBL,FIPRVM,KBFDD2>					;060

;+
; CHKDPV - Check privileges for detach
;
;	R0 =  Job number * 2						;059
;	R4 -> Work block
;-

CHKDPV:	MOV	JBPPN(R0),FQPPN(R4) ;Copy job's PPN into work block	;038
	TSTPRV	EXQTA,@#FIPRVM	;Allowed to exceed detach job quota?	;036
	BNE	10$		;Yes, then no need to check it		;038
	REGSCR			;Save registers for a bit		;029
	ADD	#JBPPN,R0	;Point to this jobs PPN			;059
	CALLX	SDM		;Find account's entry			;029
	BCS	20$		;Can't find, bogus!			;029
	CALL	GETJQ		;Get job quotas				;043
	CMPB	R0,R1		;Are we at/above detached quota now?	;029
	BHIS	30$		;Yes, so reject this			;029
10$:	RETURN			;And return, request is OK		;038

20$:	ERROR	ABORT		;Can't find own account's entry!	;029

30$:	ERROR	QUOTA		;Quota exceeded				;029

GLOBAL	<JBPPN>								;059

.SBTTL	Get job and detached job counts/quotas

;+									;029
; Entry:								;029
;	R3 =	Account's name block link				;029
;									;029
; Exit:									;029
;	R0 =	Detached job count					;029
;	R1 =	Detached job quota					;029
;	R2 =	Total job count						;029
;	R3 =	Total job quota						;029
;	R5 ->	QT2 block in FIBUF (or 0 if none)			;059
;-									;029

GETJQ:	CALLX	RDE		;Re-read name block			;029
	MOV	#-1,-(SP)	;Assume no limits			;029
	MOV	(SP),-(SP)	; on either quota			;029
	MOV	UNAM(R5),-(SP)	;Stack PPN				;029
	MOVB	@#SYSUN2,R0	;Get system unit * 2			;029
	CMP	UNTLVL(R0),(PC)+ ;Have quotas?				;029
	 .BYTE	2,1		; Only on level 1.2 or above		;029
	BLO	18$		;  so branch if not			;029
	MOV	#AA.QUO,R0	;Search for this type			;029
	MOV	R3,-(SP)	; but save link to N.E.			;029
	CALLX	SAA		;Find it				;029
	MOVB	AQ.DJB(R5),4+2(SP) ;Set detached quota			;029
	BCC	10$		;There was one, skip			;029
	CLR	4+2(SP)		; otherwise use zero			;029
10$:	MOV	(SP)+,R3	;Restore R3				;029
	MOV	#AA.QT2,R0	;Another block to find			;029
	CALLX	SAA		; so find it				;029
	MOVB	A2.JOB(R5),2(SP) ;Save that one too			;029
	BCC	20$		;Skip if good				;029
	CLR	2(SP)		; otherwise default to nothing		;029
18$:	CLR	R5		; and don't save a pointer		;059
20$:	MOV	R5,-(SP)	;Save the pointer to the QT2 block	;059
	CLR	R0		;Clear count of detached jobs		;029
	CLR	R2		; and count of all jobs			;029
30$:	MOV	#JOBTBL+2,R1	;Point to job table			;029
40$:	MOV	(R1)+,R3	;Get JDB pointer			;029
	BEQ	40$		;Skip non-entries			;029
	CMP	R3,#-1		;Done?					;029
	BEQ	60$		;Yes, so check counts against quotas	;029
	MOV	JDJDB2(R3),R5	;Get JDB2 pointer			;029
	CMP	J2PPN(R5),2(SP)	;Same PPN?				;029
	BNE	40$		;No, so skip				;029
	INC	R2		;Yes, count another job			;029
	MOV	@(R3)+,R3	;Get console DDB pointer		;029
	BIT	#DDCONS,DDCNT(R3) ;Is this a console?			;029
	BEQ	50$		;No, so detached job			;029
	MOVB	DDJBNO(R3),R5	;Yes, so get job number * 2		;029
	ADD	#JOBTBL+2,R5	;Form biased job table offset for job	;029
	CMP	R5,R1		;Is this our console or another job's?	;029
	BEQ	40$		;Ours, so job is not detached		;029
50$:	INC	R0		;Count another detached job		;029
	BR	40$		; and loop				;029

60$:	MOV	(SP)+,R5	;Restore the QT2 pointer		;059
	TST	(SP)+		;Toss PPN off the stack			;029
	MOV	(SP)+,R3	;Pick up total job quota		;029
	MOV	(SP)+,R1	; and detached job quota		;029
	RETURN			;And we're done				;052

GLOBAL	<JOBTBL,SYSUN2>							;029

FQFEND									;029

FQFSRT									;029

.SBTTL	FLGPWD -- Check account access flags, then password

;+									;025
; FLGPWD -- Check account access flags, then do password check		;025
;									;025
; Entry:								;025
;	R0 ->	word before password					;025
;	R3 =	Link to name entry for account				;025
;	R4 ->	FIRQB							;025
;	R5 ->	Date/time blockette in FIBUF				;025
;									;025
; Exit:									;025
;	R1-R5	preserved						;025
;	FIBUF contains name entry for account				;025
;	C = 0	Password matches					;025
;	R0	preserved						;025
;									;025
;	C = 1	Password mismatch or none exists, or illegal password	;025
;	R0 =	error code						;025
;-									;025

.ENABL	LSB								;025

FLGPWD:	REGSCR			;Preserve registers			;025
	CALL	CHKFLG		;Check the flags			;025
	BCC	10$		;Continue in password code if ok	;044
	SETERR	NOTAVL,TOS.R0(SP),WORD ;Set error code			;044
	BR	110$		; and exit with C=1			;044
	

.SBTTL	CMPPWD -- Check a password

;+
; CMPPWD - Compare user-supplied password against the one on disk
;
; Entry:
;	R0 ->	word before password
;	R2 =	FIP unit number
;	R3 =	Link to name entry for account
;	R4 ->	FIRQB
;	R5 ->	Date/time attribute block in FIBUF			;029
;
; Exit:
;	R1-R5	preserved						;025
;	FIBUF contains name entry for account
;	C = 0	Password matches
;	R0	preserved						;025
;
;	C = 1	Password mismatch or none exists, or illegal password
;	R0 =	error code						;025
;-

CMPPW2:	REGSCR			;Save registers				;029
	BR	20$		; and skip no-password flag test	;029

CMPPWD::REGSCR			;Save all registers			;029
	MOV	R2,@#FIPUNT	;Restore FIP unit number
10$:	CLC			;Assume no password check		;029
	BIT	#AT.NPW,AT.LTI(R5) ;Suppressing password compare?	;029
	BNE	120$		;Yes, so exit successfully		;029
20$:	TSTB	FQSIZM(R4)	;ASCII password given?			;025
	BNE	40$		;Yes, skip conversion			;019
	MOV	R4,R2		;Copy FIRQB pointer			;019
	ADD	#FQNAM1+3,R2	;Set up password string pointer		;019
	MOV	FQNAM1+2(R4),R0	;Get second word
	CALLX	R50ASC		;Convert it, return pointer in R0
	MOVB	(R0)+,(R2)+	;Store away converted string		;019
	MOVB	(R0)+,(R2)+						;019
	MOVB	(R0)+,(R2)+						;019
	SUB	#6,R2		;Point to start of password string	;019
	MOV	(R2),R0		;Get 1st word				;021
	CALLX	R50ASC		;Convert it also
	MOVB	(R0)+,(R2)+	;Store away converted string		;019
	MOVB	(R0)+,(R2)+						;019
	MOVB	(R0)+,(R2)+						;019
	ADD	#3,R2		;Point to end of converted password	;019
30$:	CLR	(R2)+		;Zero-fill the rest			;019
	BIT	#37,R2		;Done?					;019
	BNE	30$		;Loop until we are			;019
40$:	MOV	R4,R0		;Copy FIRQB pointer			;019
	ADD	#FQPPN,R0	;Now point to PPN again			;019
	MOV	R0,R2		;Copy PPN pointer
	TST	(R2)+		;Point to password
	MOV	#16.,R1		;Count of bytes to check		;021
50$:	CMPB	(R2)+,#'?	;Question mark?
	BEQ	90$		;Yes, reject that
	SOB	R1,50$		;Check all bytes
60$:	MOVB	@#FIPUNT,R2	;Get FIP unit number
	ASL	R2		;Make FIP unit a word offset
	TST	UNTLVL(R2)	;New disk?
	BEQ	90$		;No, so reject this			;019
	CMP	UNTLVL(R2),(PC)+ ;Encryption in use on this disk?	;021
	 .BYTE	1,1		; which it isn't on rev 1.1 or below	;021
	BLOS	70$		;No					;019
	BIT	#AT.NLK,AT.PTI(R5) ;Yes, but is this password encrypted? ;031
	BEQ	70$		;No, not this time			;031
	CLR	FQDEV(R4)	;Yes, tell hasher to use time from disk	;021
	MOVB	@#FIPUNT,R0	;Pass FIP unit number			;021
	FCALL	HASHPW		;Hash the password			;021
	CALLX	RDE		;Re-read the name entry			;021
	BR	75$		;And skip case conversion		;031

70$:	MOV	R4,R0		;Copy FIRQB pointer			;031
	ADD	#FQNAM1,R0	;Point to data passed			;031
	MOV	#6.,R1		;Count of bytes to convert		;031
72$:	CMPB	(R0)+,#137	;Is this lowercase?			;031
	BLOS	73$		;No, not this time			;031
	BICB	#40,-1(R0)	;Yes, so convert to upper case		;031
73$:	SOB	R1,72$		;And loop for the whole thing		;031
.REPT	<<14.-6>/2>		;Rest is nulled out			;045
	CLR	(R0)+							;045
.ENDR
75$:	MOV	#AA.PAS,R0	;Look for password attribute block	;031
	CALLX	SAA		;Search for it
	BCS	100$		;If none, can't log in			;025
	ADD	#UADAT,R5	;Point to data field of attribute
	MOV	R4,R0		;Copy FIRQB pointer
	ADD	#FQNAM1,R0	;Point to password as given
	MOV	#20-UADAT,R1	;Get count to compare
.ASSUME	20-UADAT LT FQBSIZ-FQNAM1
80$:	CMPB	(R0)+,(R5)+	;Match?					;019
	BNE	90$		;Quit if mismatch
	SOB	R1,80$		;Continue until done checking		;019
	;CLC			;C=0 from CMP				;025
	BR	120$		;Exit successfully			;025

90$:	SETERR	BADNAM,TOS.R0(SP),WORD ;Set error code = mismatch	;025
	BR	110$		; and skip				;025

100$:	SETERR	NOSUCH,TOS.R0(SP),WORD ;Set error code = no pw block	;025
110$:	SEC			;Indicate mismatch
120$:	ROL	-(SP)		;Save carry
	MOV	#16./2,R0	;Count of words to clear		;021
	ADD	#FQNAM1,R4	;Point to where password lives		;021
130$:	CLR	(R4)+		;Make sure the encryption is cleared out ;021
	SOB	R0,130$		;Loop until done			;021
	MOV	TOS.R3+2(SP),R3	;Retrieve caller's R3
	CALLX	RDE		;Restore the name entry to FIBUF
	ROR	(SP)+		;Restore carry
	RETURN			;Now leave

GLOBAL	<UNTLVL,HASHPW>							;021

.DSABL	LSB								;025

.SBTTL	CHKFLG -- Check account access flags

.DSABL	LSB								;025

;+									;025
; CHKFLG -- Check account access flags					;025
; CHKFL2 -- Check account flags except the no-login flag		;025
;									;025
; Entry:								;025
;	R4 ->	FIRQB							;025
;	R5 ->	Date/time block in FIBUF				;025
;									;025
; Exit:									;025
;	R0	Random							;025
;	C = 0	Access permitted					;025
;	C = 1	Access disallowed					;025
;-									;025

.ENABL	LSB								;025

CHKFLG:	MOV	#AT.NLG,-(SP)	;Check no-interactive bit later		;045
	BR	3$		; and skip				;045

CHKFL2:	CLR	-(SP)		;Don't check no-interactive bit		;045
3$:	MOVB	FQJOB(R4),R0	;Get job * 2				;025
	MOV	JOBTBL(R0),R0	;Get JDB pointer			;025
	BIT	#J2NET,JDFLG3(R0) ;Check network job (or server) flag	;049
	BEQ	20$		;Not network job, go look at its KB	;045
	BIT	#J2BAT,JDFLG3(R0) ;Is it server (both bits set)?	;049
	BEQ	5$		;No, skip				;045
	CLR	(SP)		;Yes, so ignore no-interactive bit	;045
5$:	BIT	#AT.NNT,AT.PTI(R5) ;Network jobs disallowed?		;025
	BEQ	30$		;No, exit				;025
10$:	COM	(SP)+		;Clean stack, indicate error		;045
	RETURN								;025

20$:	MOV	@(R0)+,R0	;Get channel 0 pointer			;025
.ASSUME	JDIOB EQ 0							;025
	CMPB	DDJBNO(R0),FQJOB(R4) ;Owned by caller?			;025
	BNE	30$		;No, so he's detached			;025
	BIT	#DDCONS,DDCNT(R0) ;Yes, but as console?			;025
	BEQ	30$		;No, so he's detached			;033
	BIT	#TTMODM,TTINTF(R0) ;Is this a modem line?		;025
	BEQ	30$		;No, allow access			;025
	BIT	#AT.NDL,AT.PTI(R5) ;Dialups disallowed?			;025
	BNE	10$		;Yes, so error				;025
30$:	BIT	(SP),AT.PTI(R5)	;Is this no-interactive (if we care)?	;045
	BNE	10$		;Yes and we care, so error		;045
	TST	(SP)+		;Interactive or we don't care, success	;045
	RETURN			;Done					;025

GLOBAL	<JOBTBL>							;045

.DSABL	LSB								;025

FQFEND

FQFSRT

.SBTTL	LOGOUT

;+
; BYEFQ - Logout (called from 'SCH' kill job code).
; UU.BYE - Logout (the syscall).
;
;	R4 -> FIRQB
;			FQFIL BIT #	-	Meaning
;				0 = 0	-	Do full logout & clean
;				  = 1	-	Just log out (no cleanup)
;				1 = 0	-	Check quotas
;				  = 1	-	Don't check quotas
;
;	FIPUNT = System unit (from FJMP)
;	FIPGEN = 0 (specific)(from FJMP)
;-

.ENABL	LSB								;021

	FQFENT	BYE,,<>		; Logout (from KILL)

	MOV	#2,FQFIL(R4)	; Do the full clean up (with no quotas)
	BR	20$		;  and skip EXQTA check			;021

	UUOENT	BYE,,,LOGABL,DOLOG	; Logout comes here

	;MOVB	@#SYSUNT,@#FIPUNT ; Restore system unit (from FCALL)
	TSTPRV	EXQTA,@#FIPRVM	; Allowed to ignore quotas?		;021
	BNE	10$		; Yes, move on				;021
	BIC	#2,FQFIL(R4)	; No, so disallow that option		;021
10$:	TSTPRV	WACNT,@#FIPRVM	; Is job privileged?			;029
	BNE	20$		; Yes					;019
	BIC	#1,FQFIL(R4)	; No, force full cleanup for self-kill	;021
20$:	MOV	FQFIL(R4),-(SP)	; Save a copy of "parameter" byte
	BIT	#1,(SP)		; Is it just logout (not full clean up)
	BNE	60$		; Yes, so just do the logout
;	  CLR	R0		; Set for full reset close		;058
;	  CALLM	RESETA,OPNAP5	; Close all except channel #0		;058
				; above done in PFBIO			;058
	FCALL	CLNPFB		; Clean up the PFB channels also	;020
	FCALLI	$UUOTBL+<UU.DAL-UU$MIN*2> ;  and deassign all devices
	MOVB	@#FIJOB,R0	; Get caller's job number times 2
	CLR	FQFIL(R4)	; Indicate remove self to message code
	MOV	#<-1*400>,FQDEVN(R4) ; Flag as a remove all RIBs call
	FCALLI	$FIPTBL+REMFQ	; Go remove as receiver			;029
	MOV	#MAXUN2+2,-(SP)	; Get highest FUN * 2 + 2
40$:	MOV	(SP),R1		; Get current FUN
	BEQ	50$		; Done scanning
	TST	-(R1)		; Back up one unit
	MOV	R1,(SP)		; Save this FUN * 2
	TST	UNTCNT(R1)	; Is this unit mounted?
	BMI	40$		; No, scan some more
.ASSUME	UC.MNT LT 0
	CMPB	UNTOWN(R1),@#FIJOB ; Mounted /NOSHARE by caller?
	BNE	40$		; No
	CMPB	R1,@#SYSUN2	; SY0:?					;068
	BEQ	40$		;  YES - then we'll get it later	;068
	MUL	#DL$SIZ/2,R1	; Compute offset into disk table	;028
	MOV	DSKLOG+DL$DEV(R1),FQDEV(R4) ; Set physical name		;028
	MOV	DSKLOG+DL$NUM(R1),FQDEVN(R4) ;	and unit + flag		;028
	MOVB	#2,FQERNO(R4)	; Set subfunction = dismount
	CLR	FQMODE(R4)	; No mode (to be on the safe side)
	FCALLI	$UUOTBL+<UU.MNT-UU$MIN*2> ; Dismount this disk
	BR	40$		; Continue looking for others

50$:	TST	(SP)+		; Clean the stack (discard FQFUN)
60$:	MOV	@#FIJBD2,R1	; Get the JDB2 pointer
	CLR	FQERNO(R4)	; Return no error code
	MOV	J2PPN(R1),FQPPN(R4) ; Copy job's PPN			;029
	BEQ	70$		; Not logged in, so no quota checks
	BIT	#2,(SP)		; Requesting quota checks????
	BNE	70$		; No, skip the checks
	FCALL	QUOCHK		; Check the logged out quotas
	MOV	@#FIJBDA,R1	; Get the JDB pointer
	MOV	@(R1)+,R1	; Get DDB pointer
	CMPB	@#FIJOB,DDJBNO(R1) ; Is caller detached?
	BNE	70$		; Yes, skip detach quota check
	BIT	#DDCONS,DDCNT(R1) ; Really detached?
	BEQ	70$		; Yes, skip detach quota check
	MOV	R4,R0		; Copy FIRQB pointer			;029
	ADD	#FQPPN,R0	; Point to PPN				;029
	CALLX	SDM		; Find the account			;029
	BCS	140$		; Can't, serious error			;029
	FCALL	GETJQ		; Get job related quotas		;029
	CMPB	R0,R1		; Are we over detached quota?		;029
	BLOS	70$		; No					;029
	MOV	#-1,FQERNO(R4)	; Yes, set error code			;037
	MOVB	R0,FQMODE(R4)	; Set current count			;029
	MOVB	R1,FQMODE+1(R4)	;  and quota				;029
	MOV	#1,FQSIZ(R4)	;Flag detached job quota error		;037
70$:	MOV	@#FIJBDA,R1	; Restore JDB pointer
80$:	MOV	R4,-(SP)	; Save FIRQB pointer
	MOVB	@#FIJOB,R4	; Get calling job number times 2
	CALLX	CONNEC		; Compute the connect time
	MOV	(SP)+,R4	; Now restore FIRQB pointer
	TSTPRV	WACNT,@#FIPRVM	; Is job privileged?			;029
	BNE	90$		; Yes					;019
	BISB	#JFKILL,JDFLG2-JDFLG(R1) ;No, flag self-kill
	BIS	#JFSPCL,(R1)
90$:	BIS	#JFIOKY,(R1)	; Post keyword				;024
	TST	-(R1)		; Now correct the job data block pointer
	TST	J2PPN(R2)	; Already logged out?
	BEQ	130$		; Yes, so don't accumulate time

;+
;	R1 -> JDB							;021
;	R2 -> JDB2
;	R4 -> FIRQB
;-

	MAP	@#FIPJC6,APR=6,DATA,PIC ;Map the JCR entry for job	;049
	MOV	@#FIPJCR,R0	;And point to it			;049
	MOV	#3,R3		; Count of masks to fix up		;026
	ADD	#JCPRIV,R0	; Point to masks			;026
.ASSUME	JCSPRV EQ JCPRIV+PRIVSZ						;049
.ASSUME	JCAPRV EQ JCSPRV+PRIVSZ						;049
100$:	CLRPRV	<GACNT,GREAD,GWRITE>,(R0) ;Turn off group-type stuff	;026
	ADD	#PRIVSZ,R0	; Point to next mask			;026
	SOB	R3,100$		;  and loop				;026
	MAP	FIPPOL		; Restore FIP mapping			;049
	MOV	R2,R0		; Copy the JDB2 pointer
	ADD	#J2PPN,R0	;  and point to the PPN
	MOVB	@#SYSUN2,R3	; Get FUN * 2 of the system disk	;027
	BIT	#UC.WLO,UNTCNT(R3) ;Is SY0: write protected????		;068
	BNE	130$		;    Yes = No QTB or charging time	;068
	CMP	UNTLVL(R3),(PC)+ ; Support Quota Blocks (QTBs)?		;027
	 .BYTE	2,1							;027
	BLO	120$		; No					;027
	MOV	#2000,R2	; Set decrement count			;030
	CALLM	RETQTB,OPNAP5	; Return of this QTB (Remaps FIP)	;030
120$:	CALLX	SDM		; Find MFD entry
	BCS	140$		; This should never fail!		;029
	DECB	UACNT+1(R5)	; User is logging out
	MARK	FIBUF		; Update "Name Blockette" on disk	;054
	CLR	@#FIUSER	; No more PPN
	CLR	(R0)		;  in both places
	TST	(SP)+		; Clean up the stack			;048
	FJMP	CHARGE		; And exit charging this user		;048

130$:	TST	(SP)+		; Discard saved FQFIL (clean the stack)
	RETURN			; All done with the logout stuff

140$:	ERROR	ABORT		; Can't find my own account entry!	;029

.DSABL	LSB								;021

GLOBAL	<RESETA,$UUOTBL,FIJOB,$FIPTBL,SYSUNT,FIPUNT,FIJBDA,FIJBD2>
GLOBAL	<FIJOB,OPNAP5,FIPRVM,FIUSER,MAXUN2,UNTOWN,FIPJCR,FIPJC6,SYSUN2>	;0xx

FQFEND									;029

.SBTTL	CHECK LOGGED OUT DISK QUOTAS

FQFSRT

;+
;
;	QUOCHK	-	CHECK QUOTA ON ALL R/W MOUNTED DISKS
;				IF PRIVED
;			CHECK QUOTA ON ALL R/W (NON-LOCKED)
;				MOUNTED DISKS IF NON-PRIVED
;
;	R4 -> FIRQB
;
;	Layout of the quota cells on the stack:
;
;			+-----------------------+
;			|  Private quota (LSB)	| 0
;			|-----------------------|
;			|  Private quota (MSB)	| 2
;			|-----------------------|
;			|  Public quota  (LSB)	| 4
;			|-----------------------|
;			|  Public quota  (MSB)	| 6
;			|-----------------------|
;			|  Public usage  (LSB)	| 10
;			|-----------------------|
;			|  Public usage  (MSB)	| 12
;			|-----------------------|
;			|  Current usage (LSB)	| 14
;			|-----------------------|
;			|  Current usage (MSB)	| 16
;			+-----------------------+
;
;	The sign bit of the MSB portion of the quota field is used as
;	a flag to indicate that the quota is unlimited. The assumption
;	made here is that RSTS will never support disks sizes greater
;	than 2^23. Therefore, the sign bit is set if the quota is zero
;	(unlimited) for RDS0 and RDS1.1 disks. On version 9.0 or newer
;	disk structures an unlimited quota is all bits set to 1's,
;	therefore the sign bit is set by default.
;-

QUOCHK:	NOP
	REGSCR			;SAVE THE CALLERS REGS
	MOV	@#FIJBD2,R0	;-> JDB2 OF THIS JOB
	ADD	#J2PPN,R0	;POINT TO THE PPN
	TST	(R0)		;LOGGED IN??
	BNE	10$		; YES, SO NO QUOTAS TO CHECK
	RETURN			;NO, SO JUST EXIT HERE

GLOBAL	<FIJBD2>							;027

10$:	MOV	SP,R4		;Copy our current stack pointer		;027
	CMP	-(R4),-(R4)	; and -> at the current usage (LSB)	;027
	MOV	#8.,R1		;Need eight cells			;027
20$:	CLR	-(SP)		;Initialize this cell			;027
	SOB	R1,20$		;Do them all				;027
	CALLX	SDM		;GO FIND THE PPN
	;BCS			;THIS LOOKUP CAN'T FAIL!!
	MOV	UAR(R5),-(SP)	;SAVE THE DCN FOR THIS DIRECTORY
	MOVB	@#FIPUNT,R2	;GET THE FUN
	ASL	R2		;AND MAKE IT THE FUN * 2
	MOV	SP,R1		;Copy the stack pointer			;027
	ADD	#<4+2>,R1	;Point to where the public quota goes	;030
	CALL	130$		;Go read them				;027
	MOV	(SP)+,R3	;Restore the DCN of the UFD		;030
	BEQ	60$		;None, then no usage to check		;027
30$:	TSTB	6(SP)		;Unlimited Public quota?		;030
	BMI	60$		;Yes, then don't bother with the usage	;027
40$:	MOV	R2,R1		;Copy the FUN * 2 (FIPGEN = specific)	;027
	ASR	R1		; and make it just FUN			;027
	MOV	R1,-(SP)	;Save the FUN from GETUSG		;027
	MOV	R3,R2		;Copy the DCN of the UFD		;027
	FCALL	GETUSG		;Go determine the usage			;027
	BCS	80$		;I/O error occurred, clean up		;027
	NOP
	MOV	R1,(R4)		;Set the LSB part of the usage		;027
	MOV	R2,2(R4)	; as well as the MSB part		;027
	MOV	(SP)+,R2	;Get back the FUN			;027
	MOV	R2,@#FIPUNT	;RESTORE THE FIP UNIT NUMBER
	ASL	R2		;MAKE THE FUN INTO FUN * 2
	BIT	#UC.PRI,UNTCNT(R2) ;PUBLIC OR PRIVATE DISK
	BNE	50$		;PRIVATE, SO CHECK IT NOW
	ADD	(R4),10(SP)	;TOTAL UP THE PUBLIC USAGE		;027
	ADC	12(SP)		;Add the overflow into the MSB part	;027
	ADD	2(R4),12(SP)	;Now add in the MSB part		;027
	CMP	12(SP),6(SP)	;PUB USAGE (MSB) > PUB QUOTA (MSB)?	;027
	BHI	110$		;Yes, over quota
	BLO	60$		;Less, then not over quota		;027
	CMP	10(SP),4(SP)	;Pub usage (LSB) > Pub quota (LSB)?	;030
	BHI	110$		;Yes, over quota			;027
	BR	60$		;OK, GO DO THE NEXT ONE.

50$:	CMP	2(R4),2(SP)	;Is usage (MSB) > private quota (MSB)?	;027
	BHI	110$		;Yes, over quota			;027
	BLO	60$		;Less, then not over quota		;027
	CMP	(R4),(SP)	;Is usage (LSB) > private quota (LSB)?	;027
	BHI	110$		;YES, SO ERROR

GLOBAL	<FIPUNT,GETUSG>							;027

	
60$:	CLR	@#FIPERX	;Clear the alternate error address	;027
	CALLX	NXTUNT,R1,<UC.MNT!UC.WLO!UC.NFS> ;Next mounted, r/w, fs disk
	 BR	120$		; ALL DONE, SO QUIT
	ASL	R2		;MAKE IT THE FUN * 2
	TSTB	UNTOWN(R2)	;Is this disk mounted /noshare?
	BEQ	70$		;No, check it
	CMPB	UNTOWN(R2),@#FIJOB ;Yes, but by caller?
	BNE	60$		;No, then skip it
70$:	MOV	SP,@#FIPESP	;Save the current stack pointer		;027
	MOVPIC	#90$,R1	;Compute the error recovery address	;027
	MOV	R1,@#FIPERX	; and set it				;027
	MOV	R2,-(SP)	;Save the current FUN from SDM	
	CALLX	SDM		;SEARCH FOR THE PPN ON THIS DISK
	MOV	(SP)+,R2	;RESTORE THE FUN NOT CHANGING CARRY
	BCS	60$		;NONE, THEN HIT THE NEXT ONE
	MOV	UAR(R5),R1	;Save the DCN of the UFD		;027
	BEQ	60$		;None, so skip this unit		;027
	MOV	R1,-(SP)	;Save the DCN of the UFD		;027
	MOV	SP,R1		;Copy the current stack pointer		;027
	TST	(R1)+		; and point at the private quota cells	;027
	CALL	130$		;Go read them				;027
	MOV	(SP)+,R3	;Restore the DCN of the UFD		;027
	BIT	#UC.PRI,UNTCNT(R2) ;PUBLIC OR PRIVATE DISK		;030
	BEQ	30$		;Public, go check that			;030
	TSTB	2(SP)		;Unlimited quota?			;030
	BMI	60$		;Yes, then don't bother with this unit	;027
	BR	40$		;No, then check this unit		;027

80$:	MOV	(SP)+,R2	;Get the FUN back			;027
	MOV	R2,@#FIPUNT	;Restore the Fip Unit Number		;027
	BR	100$		;Clean up the JDB			;027

90$:	MOV	@#FIPESP,SP	;Restore the stack pointer		;027
	MOVB	@#FIPUNT,R2	;Restore the the FUN			;027
	MOV	@#FIJBD2,R0	;Restore the JDB2 pointer		;027
	ADD	#J2PPN,R0	; and point at the PPN			;027
100$:	ASL	R2		;Make it FUN * 2			;027
	MOV	@#FIJBDA,R1	;Get the jobs JDB			;027
	CLRB	JDIOST(R1)	;Say no error occurred			;027
	BR	60$		; and ignore this unit			;027

GLOBAL	<FIPUNT,UNTCNT,UNTOWN,FIPESP,FIPERX>				;027


110$:	ASR	R2		;Make it just FUN			;027
	FJMP	QUOERR		;Go return exceeded quota info.		;027

120$:	;MOVB	@#SYSUNT,@#FIPUNT ;Reset the Fip Unit to the system unit ;027
	ADD	#<8.*2>,SP	;Clean up the stack			;030
	MOV	TOS.R4(SP),R4	;Point to the FIRQB			;027
	CLR	FQERNO(R4)	;Indicate no quota exceeded		;027
	RETURN			;Return to our caller			;027

130$:	MOV	R0,-(SP)	;Save the current PPN pointer		;027
	MOV	R2,-(SP)	; along with the FUN * 2		;027
	CMP	UNTLVL(R2),(PC)+ ;Support Quota Blocks (QTBs)?		;027
	 .BYTE	2,1							;027
	BLO	160$		;No, then get the quota old style	;027
	TST	DSKQPT(R2)	;Any QTBs for this unit?		;027
	BEQ	140$		;No, have to look on disk		;027
	CALLM	SERQTB,OPNAP5	;Is there a QTB for this user?		;027
	BCC	150$		;Yes, get the quota data from there	;027
140$:	MOV	#AA.QUO,R0	;We want quota attributes		;027
	CALLX	SAA		;Go get the blockette			;027
	BCS	180$		;Doesn't exist, error			;027
150$:	MOV	AQ.LOL(R5),(R1)	;Set the LSB part of the logged-out quota ;027
.ASSUME	AQ.LOL EQ QTBLOL
	MOVB	AQ.LOM(R5),2(R1) ; and the MSB part			;027
.ASSUME	AQ.LOM EQ QTBLOM
	MAP	FIP,DATA,PIC	;Make sure FIP is mapped		;027
	BR	170$		;We're done here			;027

160$:	CALLX	RAE		;Get the A.E. blockette			;027
	CLR	2(R1)		;No MSB part on pre 9.0 disks		;027
	MOV	MDPER(R5),(R1)	;Copy the quota				;027
	BNE	170$		;Not unlimited quota			;027
	COM	2(R1)		;Unlimited, set the sign bit of the (MSB) ;027
170$:	MOV	(SP)+,R2	;Restore the FUN * 2			;030
	MOV	(SP)+,R0	; and the PPN pointer			;030
	RETURN			;Back to our caller			;027

180$:	ERROR	BADDIR		;No quota attributes			;027

GLOBAL	<SYSUNT,FIPUNT,UNTLVL,FIPESP,FIPERX,FIJBDA,DSKQPT>		;027

FQFEND

FQFSRT

	;+
	; Jumped to from QUOCHK with quota and usage data on the stack.
	; See QUOCHK for layout of the data.
	;
	; R0 -> JDB2 @ J2PPN of FIJOB
	; R2 =  FIPUNT
	; R4 -> Current usage cells
	; SP -> Quota/Usage cells
	;-

QUOERR:	MOV	R2,@#FIPUNT	;Restore the Fip Unit Number		;027
	ASL	R2		;Now make it FUN * 2			;027
10$:	MOV	R4,R3		;COPY THE CURRENT USAGE POINTER
	MOV	TOS.R4+20(SP),R4 ;GET THE FIRQB POINTER
	ADD	#FQBUFL,R4	;POINT TO THE FLAG WORD TO RETURN DATA	;027
	MOVB	6(SP),(R4)+	;Return the MSB part of the public quota ;027
	MOVB	12(SP),(R4)+	; and the MSB part of the public usage	;027
	TST	(R4)+		;Point to where the LSB parts are returned ;027
	MOV	4(SP),(R4)+	;Return the LSB part of the public quota ;027
	MOV	10(SP),(R4)+	; and the LSB part of the public usage	;027
	MOV	#"SY,(R4)+	;SET THE DEFAULT NAME AS SY:
	CLR	(R4)		;AND NO UNIT NUMBER
	BIT	#UC.PRI,UNTCNT(R2) ;PUBLIC OR PRIVATE??
	BEQ	20$		;PUB, SO SKIP THE NAME GETTING
	MOV	R2,R1		;MOVE THE FUN * 2 TO AN ODD REG.
	MUL	#DL$SIZ/2,R1	;COMPUTE OFFSET INTO DISK TABLE @ UNIT	;028
	ADD	#DSKLOG+DL$NUM,R1 ;   NUMBER FROM FIP UNIT NUMBER * 2	;028
	MOV	(R1),(R4)	;GET THE DEVICE NUMBER
	MOV	-(R1),-(R4)	; AND THE DEVICE NAME
	MOV	(R3),-(R4)	;  AND RETURN THE CURRENT USAGE (LSB)
	MOV	(SP),-(R4)	; RETURN THIS DISKS CURRENT QUOTA (LSB)
	TST	-(R4)		;Point to where the MSB parts are returned ;027
	MOVB	2(R3),-(R4)	;Return the MSB part of the current usage ;027
	MOVB	2(SP),-(R4)	; and the MSB part of the current quota	;027
20$:	BIC	#37,R4		;NOW, ALLIGN TO THE TOP OF THE FIRQB
	MOV	@#FIJBDA,R3	;-> JDB2 OF THIS JOB
	MOV	@JDIOB(R3),R3	;POINT TO THE DDB
	CLR	R5		;Start with 0 counter of same PPN found
	BIT	#DDCONS,DDCNT(R3) ;IS IT A CONSOLE DEVICE??
	BEQ	40$		;NO, SO THIS JOB IS DETACHED
	CMPB	DDJBNO(R3),@#FIJOB ;SAME JOB # * 2??
	BNE	40$		;NO, SO REALLY DETACHED
	; THIS JOB IS ATTACHED WHEN WE GET HERE
	;  SO NOW, COUNT OTHERS ATTACHED TO A REAL KB
	MOV	#JOBTBL+2,R1	;GET THE JOB TABLES ADDRESS (FOR JOB 1)
30$:	MOV	(R1)+,R2	;GET THIS JOBS JDB POINTER
	BEQ	30$		;NONE, SO GET NEXT ONE
	CMP	R2,#-1		;END OF THE LIST
	BEQ	40$		; YES, SO QUIT
	MOV	JDJDB2(R2),R3	;GET THE JDB2 POINTER
	CMP	J2PPN(R3),(R0)	;IS IT THE SAME PPN
	BNE	30$		;NO, SO GO LOOK AT THE NEXT JOB
	MOV	@JDIOB(R2),R3	;THE CONSOLE KB DDB ADDRESS
	BIT	#DDCONS,DDCNT(R3) ;IS IT A CONSOLE DEVICE??
	BEQ	30$		;NO, SO THIS JOB IS DETACHED

	SUB	#JOBTBL+2,R1	;Pick up job # * 2			;047
	CMPB	DDJBNO(R3),R1	;Is this really attached?		;047
	BNE	35$		;No, not this time
	CMPB	#TTPK11,TTINTF(R3) ;Yes, but is it on a PK?
	BEQ	35$		;Yes, so don't count that one
	CMPB	R1,@#FIJOB	;Is this our job?			;047
	BEQ	35$		;Yes, don't count that			;047
	INC	R5		;Count other attached jobs
35$:	ADD	#JOBTBL+2,R1	;Get the pointer to the next job	;047
	BR	30$		;And continue looking

40$:	MOV	#-1,R1		;SET UP FOR A FATAL ERROR
	TST	R5		;Were there other attached jobs?	;047
	BEQ	50$		;No, so fatal quota check error		;047
	DEC	R1		;MAKE THE ERROR CODE -2 (SOFT)
50$:	MOV	R1,FQERNO(R4)	;SET THE ERROR CODE
	CLR	FQSIZ(R4)	;Flag disk quota error
	ADD	#8.*2,SP	;CLEAN UP THE STACK
	;MOVB	@#SYSUNT,@#FIPUNT ;RESET THE FIP UNIT TO THE SYSTEM UNIT
	INC	R1		;ARE WE RETURNING A FATAL ERROR
	BEQ	60$		; YES, SO GO DO FATAL EXIT
	RETURN			;RETURN TO CALLER RESTORING REGS AND
				; FIPUNT, CAUSE CROSS OVERLAY RETURN
60$:	JMPX	FIEXIT		;EXIT FIP, WITH A CLEAN STACK

GLOBAL	<DSKLOG,UNTCNT,JOBTBL,FIJBDA,TTPK11,SYSUNT,FIPUNT,FIJOB>	;047

.SBTTL	SPWCHK	Check for system password check done

;+									;026
; Check whether system password is needed and has been checked yet	;029
; SPWCK2 takes a DDB pointer as input, assumes attached job		;029
; SPWCKN checks for DECnet, tests NET flag				;029
;									;029
; Entry:								;029
;	R2 ->	DDB (for SPWCK2)					;029
;	R5 ->	Date/time block for account, or 0 to skip AT.NLK test	;029
;									;029
; Exit:									;029
;	C = 0	System password ok (or not needed)			;029
;	C = 1	System password not ok					;029
;	R0 =	Error code						;029
;
;	Other registers preserved					;029
;	FIBUF contents preserved					;029
;-									;029

.ENABL	LSB								;029

SPWCKN::REGSCR			;Save registers				;029
	CLR	R5		;Skip account flags check		;029
	MOV	#4,R4		;Type is network			;029
	BR	40$		; and go look for the password		;029

SPWCK2:	REGSCR			;Save registers
	CLR	R4		;Assume local job			;029
	BR	10$		; and merge with common code		;029

SPWCHK:	REGSCR			;Save registers				;029
	CLR	R4		;Assume local job			;026
	MOV	@#FIJBDA,R2	;Get JDB pointer			;026
	MOV	@(R2)+,R2	;Get console pointer			;026
	CMPB	DDJBNO(R2),@#FIJOB ;Owned by caller?			;026
	BNE	20$		;No, so detached, local or net		;045
	BIT	#DDCONS,DDCNT(R2) ;Yes, but console?			;027
	BEQ	20$		;No, so local or net			;045
10$:	CMPB	TTINTF(R2),#TTPK11 ;Is this a PK:?			;026
	BEQ	20$		;Yes, skip				;026
	BIT	#TTMODM,TTINTF(R2) ;No, is it modem?			;026
	BEQ	40$		;No					;026
	BR	30$		;Yes, set "dialup"			;026

20$:	MOV	@#FIJBDA,R2	;Get JDB pointer			;049
	BIT	#J2NET,JDFLG3(R2) ;Network job?				;049
	BEQ	40$		;No, so local				;026
	TST	(R4)+		;Bump code				;026
30$:	TST	(R4)+		;Bump code				;026
40$:	MOVB	@#FIBUNT,-(SP)	;Save unit number for current block	;029
	MOV	@#FIBFBN,-(SP)	;Save high order block number		;031
	MOV	@#FIBFBN+F.FBNL,-(SP) ; low order, too			;029
	TST	R5		;Checking no-lookup flag?		;029
	BEQ	50$		;No, skip test				;029
	BIT	#AT.NLK,AT.PTI(R5) ;"Lookup" account?			;026
	BEQ	70$		;Yes, so no check needed		;026
50$:	MOVB	@#SYSUN2,R2	;Get the system unit number * 2		;027
	CMP	UNTLVL(R2),(PC)+ ;Check rev level			;026
	 .BYTE	1,1							;026
	BLOS	70$		;Rev 1.1 or below, no check needed	;026
	MOV	@#FIJBDA,R2	;Get JDB pointer			;049
	BIT	#J2SYSV,JDFLG3(R2) ;Already passed the test?		;049
	BNE	70$		;Yes, skip				;029
	MOV	#ONE,R0		;Point to 1 = [0,1]			;029
	CALLX	SDM		;Find that account			;029
	BCS	90$		;Not found, corrupted disk		;029
	MOV	#AA.DAT,R0	;Find the date/time block		;029
	CALLX	SAA		;Search for it				;029
	BCS	100$		;Not found, error			;029
	ADD	PC,R4		;Point to table of bits to check	;029
	ADD	#120$-.,R4	; (picly)				;029
	SETERR	NOSUCH,R0	;Assume this error code			;029
	BIT	(R4),AT.PTI(R5)	;Need password for this type?		;029
60$:	BEQ	70$		;No, ok					;029
	MOV	R0,TOS.R0+6(SP)	;Return error code			;029
	SEC			;Indicate error				;029
	BR	80$		; and merge with exit code		;029

70$:	CLC			;Indicate success			;029
80$:	MOV	(SP)+,R2	;Retrieve low order block to re-read	;029
	MOV	(SP)+,R3	; and high order			;031
	MOVB	(SP)+,R0	;  and unit number			;040
	BMI	85$		;Skip if contents of FIBUF was invalid	;040
	MOVB	R0,@#FIPUNT	;Otherwise, set the unit number		;040
	ROR	-(SP)		;Save success/failure flag		;029
	CALLX	READ		;Re-read it into FIBUF			;029
	ROL	(SP)+		;Restore C bit				;029
85$:	RETURN			;Done					;040

90$:	SETERR	BADPAK,R0	;No [0,1] directory??			;029
	BR	60$							;029

100$:	SETERR	BADDIR,R0	;No date/time block for [0,1]		;029
	BR	60$							;029

110$:	SETERR	NOSUCH,R0	;System password not specified		;029
	BR	60$							;029

120$:	.WORD	AT.NLG		;Local job				;029
	.WORD	AT.NLG!AT.NDL	;Dialup					;029
	.WORD	AT.NLG!AT.NNT	;Network job				;029

.DSABL	LSB								;029

GLOBAL	<SYSUN2,UNTLVL,FIJBDA,FIJBD2,FIBUNT,FIBFBN,ONE>			;029

FQFEND

FQFSRT

.SBTTL	Log in a job for Spawn/ICFP detach/DECnet

;+
; LOGSPI -- Log in a job for the Spawn function
;
; Entry:
;	R4 ->	FIRQB
;		FQFIL	JOBKBM clear to run a program next		;021
;				set  to enter a keyboard monitor next	;021
;			JOBAPR clear to use account's privileges	;022
;				set  to reduce authorized privs to	;022
;				     subset of caller's current privs	;022
;			JOBCPR clear to turn on current privs		;022
;				set  to leave them zero (as on login)	;022
;			JOBNQT clear to check job quotas normally	;044
;				set  to bypass job quota check at login	;044
;		FQSIZM	= job number * 2 of job issuing spawn, or zero
;			  for DECnet spawn
;		FQPPN	= PPN to log into
;-

LOGSPI::FCALL	LOGCHK		;Check out this PPN
	FCALL	CHKFL2		;Check account flags except no-login	;025
	BCS	10$		;Quit if access not permitted		;025
	MOVB	@#FIPUNT,R0	;Get FIP unit number
	ASL	R0		; times 2
	TST	UNTLVL(R0)	;Old disk or new?
	BNE	20$		;New
10$:	ERROR	NOTAVL		;Old disk or inaccessible account	;044

20$:	MOV	R3,-(SP)	;Save link to name entry
	MOV	#AA.PAS,R0	;Search for password
	CALLX	SAA		;Does it exist?
	BCS	10$		;No, so reject this account
	MOV	(SP)+,R3	;Restore link to name entry
	CALLX	RDE		;Re-read it
30$:	MOVB	#-1,FQFUN(R4)	;Assume successful login		;047
	MOV	@#FIJBDA,R1	;Point to JDB for LOGLOG		;034
	FCALL	LOGLOG		;Log in
	CMPB	FQFUN(R4),#-1	;Did it work?				;029
	BEQ	35$		;Yes					;029
	ERROR	QUOTA		;No, so report quota error		;029

35$:	MOVB	FQFIL(R4),-(SP)	;Save switch/run flag			;029
	MOVB	FQSIZM(R4),R0	;Get spawner's job number times 2
	BEQ	60$		;Skip if this is DECnet			;029
	MOV	JOBTBL(R0),-(SP) ;Pick up new job JDB pointer		;049
	BITB	#JOBAPR,FQFIL(R4) ;Restrict new job's privileges?	;021
	BEQ	55$		;No, leave them alone			;049
	CALLX	GETJCR		;Get the JCR pointer for spawner's job	;049
	MOV	@#DPAR6,R3	;R3 -> MMU address for data mapping	;049
	MOV	@#FIPJCR,R0	;And point to JCR entry for job		;049

; R0 -> New job's JCR entry
; R1 -> Spawner's JCR entry
; R2 = MMU address for spawner's JCR entry
; R3 -> KISAR6 or KDSAR6
; R4 -> New job work block
; SP -> Saved spawner's JDB, ...

; First we will clear any bit in the new job's authorized privileges which
; aren't set in both the spawner's current privileges and the spawner's
; alternate privileges.

	ADD	#JCPRIV,R1	;Now point to original current privs	;049
	ADD	#JCAPRV,R0	; and new job's authorized privs	;049
	MOV	#PRIVSZ/2,-(SP)	;Get count of words to copy		;049
	MOV	R1,R5		;Copy pointer to spawner's JCR entry	;049
	TST	JCALPP-JCPRIV(R5) ;Is alternate privilege data valid?	;049
	BEQ	40$		;No, so all set				;049
	ADD	#JCALPV-JCPRIV,R5 ;Yes, so point to the alternate mask	;049
40$:	MOV	R2,(R3)		;Map the spawner's JCR			;049
	MOV	(R1)+,-(SP)	;Get a word from the current mask	;049
	COM	(SP)		;Complement it				;021
	MOV	(R5)+,-(SP)	;Get a word from the alternate mask	;049
	COM	(SP)		;Complement it				;049
	MOV	@#FIPJC6,(R3)	;Map the new job's JCR			;049
	BIC	(SP)+,(R0)	;Clear disallowed bits in new job	;049
	BIC	(SP)+,(R0)+	; from both masks			;049
	DEC	(SP)		;Say one more done			;049
	BNE	40$		;More to do, go do it			;049
	TST	(SP)+		;All done, trash the counter		;049

; R4 -> New job work block
; SP -> Spawner's JDB pointer, ...
;
; New job's JCR is mapped through APR6
;

55$:	MOV	(SP)+,R0	;Restore JDB pointer			;049
60$:	CLR	-(SP)		;Assume new job will have privs enabled	;022
	BITB	#JOBCPR,FQFIL(R4) ;Is that so?				;022
	BEQ	70$		;If bit is clear then it is		;022
	COM	(SP)		;Otherwise we'll clear them all		;022
70$:	MOV	@#FIPJCR,R2	;Point to new job's JCR			;049
	MAP	@#FIPJC6,APR=6,DATA,PIC ;And map it			;049
	ADD	#JCPRIV,R2	; now to current privs field		;049
	MOV	#FIPRVM,R3	;Point to FIP's privilege mask		;022
	MOV	#PRIVSZ/2,R5	;Count of words to set/clear		;022
80$:	MOV	JCAPRV-JCPRIV(R2),(R2) ;Copy authorized to current	;049
	BIC	(SP),(R2)	;Clear it if we want it that way	;022
	MOV	(R2)+,(R3)+	;Set as FIP's mask also			;022
	SOB	R5,80$		;Process the entire mask		;022
	TST	(SP)+		;Pop the flag				;022
	MAP	FIPPOL		;Restore FIP mapping			;049
	TST	R0		;DECnet spawn?				;029
	BNE	85$		;No, skip				;029
	MOV	FQSIZ(R4),FQPPN(R4) ;Yes, copy over PPN 		;029
	BR	95$		; and skip work block moving		;029

85$:	MOV	JDWORK(R0),R2	;Point to his work block		;029
	CMP	(R2)+,(R4)+	;Skip first
	CMP	(R2)+,(R4)+	; two words
.ASSUME	FQJOB LT 4
90$:	MOV	(R2)+,(R4)+	;Copy it to ours
	BIT	#37,R4		;Done?
	BNE	90$		;No
	SUB	#40,R4		;Back to top
95$:	MOV	34(R4),FQNENT(R4) ;Put entry parameter in proper place
	MOV	@#FIJBDA,R1	;Pick up new job's JDB entry		;049
	TST	(R1)+		;And advance to JDFLG			;049
.ASSUME	JDFLG	EQ	2
	BIC	#JFSYS!JFSYST,(R1) ;Make sure temp privs are marked off	;022
	BITB	#JOBKBM,(SP)+	;Run or switch to do next?		;022
	BNE	100$		;Switch
	MOVB	#RUNFQ,FQFUN(R4) ;Set the RUN function code in the FIRQB ;027
	MOV	#130000,FQMODE(R4) ;Set proper mode for run (readonly)
	MOV	#15.*2,FQFIL(R4) ; and channel is 15.
	CLR	FQSWIT(R4)	;Real run, not .CHAIN
	BIS	#JFPOST!JFIOKY,(R1)+ ;Indicate posting required
	MOV	#UUOFQ*400,(R1)	;Index = uuo, to post everything
.ASSUME	JDIOST EQ JDFLG+2
.ASSUME	JDPOST EQ JDIOST+1
	CALLMR	RUNENT,OPNAP5	;Go do the run				;025

100$:	TST	FQNAM1(R4)	;Asking for default RTS?
	BEQ	110$		;Yes, don't switch
	CALLX	FNDRTS		;Try to find the RTS being asked for
	BIT	#PF.KBM,R.FLAG(R3) ;Found it, is it a KBM?
	BEQ	120$		;No, that's illegal
	CALLX	SWRTS		;Switch to new RTS
	MOV	@#FIPJCR,R0	;Point to JCR entry for job		;049
	MAP	@#FIPJC6,APR=6,DATA,PIC ;And map the JCR		;049
	MOV	R3,JCDRTS(R0)	;Now set up the RTS as our default	;049
	CLR	-(SP)		;Get a calculation area			;067
	BISB	R.MSIZ(R3),(SP)	; to calculate new initial size		;067
	ADD	JCHDRS(R0),(SP) ; including the jobs headersize		;067
	MOVB	(SP)+,JCSIZN(R0);  now set the correct initial size	;067
	MOVB	R.MSIZ(R3),JCISIZ(R0) ; and the ISPACE size		;049
	MOVB	@#FIJOB,R0	;Get job # * 2				;055
	CALLMI	SETMDE,GENAP5	;And update caller's MDEs		;055
	MAP	FIPPOL		;Restore FIP mapping			;049
110$:	BIS	#JFSPCL!JFIOKY,(R1) ;Indicate special condition (switch/spawn)
	RETURN			;All done, go run that job...

120$:	ERROR	PRVIOL		;RTS found but it's not a KBM

GLOBAL	<FIPUNT,UNTLVL,JOBTBL,FIJBDA,FIJBD2,JOBAPR,JOBCPR,JOBKBM,$FIPTBL> ;034
GLOBAL	<FIPJC6,FIPJCR>							;049

;+
; LINNOP - Log in, no password supplied
;
;	R1 -> Job data block
;	R2 -> Second job data block
;	R4 -> FIRQB
;		FQPPN  = PPN
;
;	FCALL (or FJMP) LINNOP
;
;	R0-R3 = Undefined
;	R4    = Same as passed
;	R5    = Undefined
;-

LINNOP::MOVB	@#SYSUN2,R0	;Get SY0: FIP unit number		;042
	BIT	#UC.WLO,UNTCNT(R0) ;Write-locked SY0:?			;042
	BEQ	5$		;No, so do normal login			;042
	MOV	#1*400+2,@#FIUSER ;Yes, do shortcut login		;042
	MOV	#1*400+2,J2PPN(R2) ; by simply setting up PPN		;042
	MOV	@(R1)+,R0	;Get console DDB pointer		;042
	MOV	@#DATE,DDTIME(R0) ;Set time of login			;042
	BIS	#JFIOKY,(R1)	;Make sure KEY is updated		;042
.ASSUME	JDFLG EQ 2							;042
	BR	7$		; and go set up privs			;042

5$:	FCALL	LOGCHK		;Check out the account specified
	CLRB	FQFIL(R4)	;Ensure no spawn-type flag for LOGLOG	;044
	FCALL	LOGLOG		; It looks ok, so go log in		;019
7$:	MOV	@#FIJBDA,R3	;Point to JDB				;049
	BIS	#J2SYSV,JDFLG3(R3) ;Indicate system password is OK	;049
	MOV	#3,R0		;Count of privilege masks to set	;029
.ASSUME	JCSPRV EQ JCPRIV+PRIVSZ						;049
.ASSUME	JCAPRV EQ JCSPRV+PRIVSZ						;049
	MOV	@#FIPJCR,R3	;Point to caller's JCR entry		;049
	MAP	@#FIPJC6,APR=6,DATA,PIC ;And map it			;049
	ADD	#JCPRIV,R3	;now offset to privileges		;049
10$:
$$$$$$	=	0							;029
.REPT	PRIVSZ/2							;029
.IRP	N,<\$$$$$$>							;029
	MOV	#..PRW'N,(R3)+						;029
.ENDR									;029
$$$$$$	=	$$$$$$+1						;029
.ENDR									;029
	SOB	R0,10$		;Loop until all set			;019
	MOV	#FIPRVM,R3	;Point to FIP's mask			;021
	MOV	#PRIVSZ/2,R0	;Count of words to set			;021
20$:	MOV	#-1,(R3)+	;Set mask for job in FIP		;021
	SOB	R0,20$		;Loop until done			;021
	MAP	FIPPOL		;Be sure FIP is mapped on exit		;049
	RETURN			;Now exit				;019

FQFEND

FQFSRT

.ENABL	LSB								;029

PWCHEK:	ASRB	FQSIZM(R4)	;Asking for password check function?	;021
	BCC	40$		;No					;021
	MOV	FQPPN(R4),R0	;Get PPN to check			;039
	BNE	10$		;Not defaulted, skip			;039
	MOV	@#FIUSER,FQPPN(R4) ;Defaulted, supply self		;039
	BEQ	100$		; and reject if not currently logged in	;021
10$:	CALLX	CHKACC		;Check access rights			;039
	TST	R0		;Accounting rights?			;039
	BPL	70$		;No, error				;039
.ASSUME	DDSTAT LT 0							;039
20$:	CALLX	GUN,R5		;Scan the device name in FQDEV		;029
	 BR	30$		;Disk, skip				;026
	 ERROR	NORACS		;Not a disk, error			;026

30$:	TSTB	@#FIPGEN	;General?				;026
	BNE	90$		;Yes, error				;026
	TSTB	UNTLVL(R0)	;Check unit level			;026
	BEQ	90$		;Level 0.0 is illegal			;026
	CALL	80$		;Find the account			;026
	BCS	35$		;Error, report it			;029
	MOV	@#FIPUNT,R2	;Get FIP unit number			;021
	FCALL	CMPPWD		;Check for password match		;021
	BCC	60$		;Exit if ok				;025
35$:	JMPX	ERROR		;Otherwise report the error		;031

40$:	BITB	#4/2,FQSIZM(R4)	;System password check?			;025
	BEQ	70$		;No, something strange, error		;026
	CLR	R5		;Don't check no-lookup bit		;029
	FCALL	SPWCHK		;Is system pw ok already or not needed?	;029
	BCC	60$		;Yes, don't check again			;029
	CALL	CMPSPW		;Go compare against system password	;029
	BCC	50$		;Match, good				;025
	CMPB	R0,#NOSUCH	;No password block present?		;025
	BNE	35$		;Other error, report it			;029
50$:	MOV	@#FIJBDA,R2	;Get JDB pointer back			;049
	BIS	#J2SYSV,JDFLG3(R2) ;Mark system password validated	;049
60$:	RETURN			;Done					;025

70$:	ERROR	BADFUO		;Bad subfunction flags			;026

80$:	MOV	R4,R0		;Copy FIRQB pointer			;026
	ADD	#FQPPN,R0	;Point to PPN				;026
	CALLX	SDM		;Find it				;026
	BCS	100$		;Not found, error			;026
	MOV	R0,-(SP)	;Save some registers			;026
	MOV	R3,-(SP)						;026
	MOV	#AA.DAT,R0	;Look for date/time			;026
	CALLX	SAA		;Search for it				;026
	MOV	(SP)+,R3	;Restore link				;026
	MOV	(SP)+,R0	; and PPN pointer			;026
	BCS	110$		;Not found, error			;026
	RETURN			;Done					;026

90$:	ERROR	PRVIOL		;Specified SY: or RDS0 disk		;026

100$:	SETERR	NOSUCH,R0	;Account not found			;026
	SEC			;Indicate error				;029
	RETURN			; and exit				;029

110$:	SETERR	BADDIR,R0	;Bad directory -- no date/time info	;026
	SEC			;Indicate error				;029
	RETURN			; and exit				;029

CMPSPW::MOV	#0*400+1,FQPPN(R4) ;Set "ppn" of [0,1]			;025
	CALL	80$		;Find it				;026
	BCS	110$		; no luck, die				;029
	MOVB	@#FIPUNT,R2	;Get FIP unit number			;025
	FCALL	CMPPW2		;Check the password, skip AT.NPW test	;029
120$:	RETURN			;Done					;029

.DSABL	LSB								;029

GLOBAL	<UNTLVL,FIPGEN,FIPUNT>						;026

.SBTTL	Clean up the files in the PFB					;020

;+									;020
;	FCALL	CLNPFB							;020
;									;020
;	This call will close out all the IOB files and then		;020
;	move all the PFB files over to the IOB and close 		;020
;	all them also. Be warned that all files WILL be			;020
;	closed after this FCALL.					;020
;									;020
;	Note:	If a log file is not opened, then we return here.	;058
;		If a log file is opened, then the buffer is flushed	;058
;		and the current FIP request is requeued to start over,	;058
;		which means you never return here after the call to	;058
;		LFLUSH.  But, when the current FIP request is restarted	;058
;		you will reexecute this code, but now the log file	;058
;		doesn't need flushing, so you do return, and continue	;058
;		executing the code after the LFLUSH call.		;058
;									;020
;	all registers are returned intact from call			;020
;									;020
;-									;020
.ENABL	LSB								;020

CLNPFB::REGSCR			; Save the needed scratch registers	;020
	CLR	R0		; Set for full close and reset		;020
	MOVB	FQFUN(R4),-(SP)	; Save function code			;031
	MOV	FQFIL(R4),-(SP)	; Save this word also			;058
	MOVB	#RSTFQ,FQFUN(R4) ; Make sure next is a reset-close	;029
	CALLM	RESETA,OPNAP5	; Make sure all channels are closed	;023
	MOV	(SP)+,FQFIL(R4)	; Restore thos word			;058
	MOVB	(SP)+,FQFUN(R4)	; Restore function code			;031
	MOV	@#FIJBDA,R1	; Start PFB Cleanup, get the JDB pointer ;049
	BIC	#J2LOG!J2ICF,JDFLG3(R1) ; Log and ICF will be inactive	;049
	MOVB	@#FIJOB,R0	; Get job number			;022
	CALLM	LFLUSH,EM2AP5	; Flush out the log			;029
	BCS	50$		; No buffers to do it with		;022
10$:	MAP	@#FIPJC6,APR=6,DATA,PIC,R=4 ;Map the JCR entry		;049
	MOV	@#FIPJCR,R2	; Point to JCR entry			;049
	MOV	JCPFB+<PF$LOG*2>(R2),R4 ; Get log file CBB pointer	;049
.ASSUME	PF$LOG EQ 0							;022
	BEQ	20$		; None, that helps			;022
	CLR	JCPFB+<PF$LOG*2>(R2) ; Got one, clear out that pointer	;049
	CALLX	MAPBUF		; Make sure CBB is mapped		;029
	MOV	#CBB$SZ,(R3)	; Set size for buffer returner		;022
.ASSUME	BF.SIZ EQ 0							;022
	MOV	PF.WCB(R3),R3	; Save WCB pointer			;022
	BUFFER	RETURN		; Release the CBB			;022
	DEC	@#USETBL+UT.PFB	; And update the usage counter		;046
	MOV	TOS.R4(SP),R4	; Point to work block			;022
	MOVB	FQFUN(R4),-(SP)	; Save function in FIRQB		;022
	CLRB	FQFUN(R4)	; Set up for close			;022
.ASSUME	CLSFQ EQ 0							;022
	MOVB	#1*2,FQFIL(R4)	; We'll close channel 1			;022
	MOV	(R1),R1		; Point to IOB				;022
.ASSUME	JDIOB	EQ	0
	MAP	FIPPOL		; Map FIP pool for the IOB		;049
	MOV	R3,1*2(R1)	; Copy log file WCB into IOB channel 1	;022
	CALLM	CLOSE,OPNAP5	; Now close it (not a reset-close!)	;023
	MOVB	(SP)+,FQFUN(R4)	; Restore function code			;022
20$:	MAP	@#FIPJC6,APR=6,DATA,PIC,R=4 ;Map the JCR entry		;049
	MOV	@#FIPJCR,R4	; Point to JCR again			;049
	CLR	R3		; Guess at no active ICF		;049
	MOV	JCPFB+<PF$ICF*2>(R4),R4 ; Pick up ICF CBB pointer	;049
	BEQ	30$		; None, that's easy			;022
	CALLX	MAPBUF		; Map it				;022
	MOV	#CBB$SZ,(R3)	; Set size for buffer returner		;022
.ASSUME	BF.SIZ EQ 0							;022
	MOV	PF.WCB(R3),R3	; Get WCB pointer			;022
	BUFFER	RETURN		; Now release the CBB			;022
	DEC	@#USETBL+UT.PFB	; And update usage counter		;046
30$:	MAP	@#FIPJC6,APR=6,DATA,PIC,R=4 ;Map the JCR entry		;049
	MOV	@#FIPJCR,R4	; Point to JCR entry			;049
	ADD	#JCPFB+<PF$ICF*2>,R4 ;And point to the ICF channel	;049
	MOV	R3,(R4)		; Set up pointer to ICF WCB (if any)	;049
	MOV	@#FIJBDA,R1	; Get pointer to JDB			;049
	MOV	(R1),R1		; Then pick up pointer to the IOB	;020
.ASSUME	JDIOB EQ 0
	ADD	#1*2,R1		; And advance to channel #1		;049
40$:	MAP	@#FIPJC6,APR=6,DATA,PIC,R=2 ;Map the JCR entry		;049
	MOV	(R4),R5		; Pick up a PFB channel			;049
	CLR	(R4)+		; And close it				;049
	MAP	FIPPOL		; Set up FIP pool mapping for the IOB	;049
	MOV	R5,(R1)+	; Copy the channel to the IOB		;049
	BIT	#40-1,R1	; Are we done yet?			;049
	BNE	40$		; No					;022
	MOV	TOS.R4(SP),R4	; Get work block pointer again		;049
	CLR	R0		; Set up for a clear all		;020
	;MOVB	#RSTFQ,FQFUN(R4) ; Set up for reset			;035
.ASSUME	RSTFQ NE 0							;035
	CALLMR	RESETA,OPNAP5	; Go close (not reset) those channels	;029

50$:	MOV	@#FIJBDA,R1	; Point to our JDB			;022
	TSTB	JDFLG2(R1)	; Is this job being killed?		;022
.ASSUME	JFKILL EQ 200							;022
	BPL	60$		; No, so error				;022
	BR	10$		; Yes, so you lose, partial log loss	;022

60$:	ERROR	NOBUFS		; Can't get DSQ to flush with		;022

.DSABL	LSB								;020

GLOBAL	<RETSML,$FIPTB,FIJBD2,RESETA,CLOSE,OPNAP5,FIJBDA,USETBL>	;046
GLOBAL	<FIPJCR,FIPJC6>							;049

FQFEND									;041

FQFSRT									;041

.SBTTL	Reattach function

.ENABL	LSB								;025

REATT2:	TSTB	4(SP)		;KBswap?				;041
	BEQ	60$		;No, so error
	ADD	#6,SP		;Clean up the stack from attach		;048
	CLR	-(SP)		;Indicate this is a swap console	;048
	MOV	R1,-(SP)	;Save DDB pointer of terminal to attach to ;048
	MOV	@#FIJOB,R0	;Get caller's job number		;048
	MOV	@#FIJBDA,R1	;Get caller's JDB pointer
	MOV	@(R1)+,R1	;Now console pointer
	CALL	30$		;Are we detached?
	BCC	60$		;No, so error
	MOV	JDJDB2-2(R2),R0	;Point to other job's JDB2
	CMP	J2PPN(R0),@#FIUSER ;Should match other job's PPN	;048
	BNE	60$		;If not that's an error
	MOVB	DDUNT(R1),R3	;Get keyboard number 			;005
	ASL	R3		;Now get unit number times two		;005
	BR	65$		;Otherwise join the reattach code	;048

GLOBAL	<FIPJC6,FIPJCR>							;005

30$:	CMPB	R0,DDJBNO(R1)	;DOES JOB # MATCH JOB # IN TTY DDB?
	BNE	40$		;NO, MUST BE DETACHED
	;CLC			;CARRY=0 SINCE 'BEQ' FROM 'BHIS'='BCC'
	BIT	#DDCONS,DDCNT(R1) ;YES, BUT IS JOB REALLY DETACHED?
	BNE	50$		;NOT DETACHED (C=0 EXIT)
40$:	SEC			;DETACHED (C=1 EXIT)
50$:	RETURN			; AND EXIT

REATTA:	CALL	30$		;CALLING JOB DETACHED?
	BCC	60$		;NO, ERROR
	MOVB	(R4)+,R3	;YES, GET KB # TO ATTACH TO
	CMP	R3,#CNT.KB	;LEGAL?
	BHIS	60$		;NOPE
	ASL	R3		;MAKE IT TIME 2
	MOV	DEV.KB(R3),R1	;GET THAT TTY DDB ADDRESS		;005
	MOV	R1,-(SP)	;Set a non-zero flag to indicate reattach ;048
	MOV	R1,-(SP)	;Save DDB address			;048
65$:	CMPB	TTINTF(R1),#TTPK11 ;Swapping with a PK?			;049
	BNE	70$		;No, not this time			;041
	MOV	CSR.KB(R3),R0	;Yes, get the DDB pointer		;005
	MOVB	DDJBNO(R0),R0	;R0 = Controlling job's job # 		;005
	BEQ	60$		;Unowned? Forget this!			;049
	BIT	#1,R0		;Owned by a system job?			;056
	BNE	70$		;Yes, skip priority checks		;056
	CALLX	MAPJCR		;Map controller's JCR entry		;049
	MOVB	JCPRI(R1),-(SP)	;And save the controller's priority	;049
	MAP	@#FIPJC6,APR=6,DATA,PIC,R=0 ;Map caller's JCR entry	;049
	MOV	@#FIPJCR,R0	;And point to the JCR entry		;049
	CMPB	(SP)+,JCPRI(R0)	;Controller priority lower than caller's? ;049
	BLT	60$		;Yes, so don't swap consoles		;041
	MAP	FIPPOL		;No, restore FIP mapping		;049
70$:	BIC	#40-1,R4	;Point back to top of FIRQB		;041
	MOV	@#FIUSER,FQPPN(R4) ;Set up caller's PPN			;025
	FCALL	LOGCHK		;Find the date/time block		;029
	MOV	(SP),R2		;Get DDB pointer			;029
	FCALL	SPWCK2		;Check for system password ok yet	;029
	BCC	72$		;Continue if it's ok			;066
	JMPX	ERROR		;Not okay, quit				;066

72$:	MOV	(SP)+,R1	;Copy DDB pointer			;027
	SPLC	5		;;Lock out terminal interrupts
	MOVB	DDJBNO(R1),R0	;;Pick up present owner 		;048
	BEQ	75$		;;Unowned, that's easy			;048
	TST	(SP)		;;Is this a reattach?			;048
	BEQ	80$		;;Yes, anyone can own it then		;048
	CMPB	R0,@#FIJOB	;;Does our caller own it?		;048
	BEQ	80$		;;Yes, so skip privilege check		;048
60$:	ERROR	BADFUO		;No, forget this			;048

75$:	TSTPRV	DEVICE,@#FIPRVM	;;Privileged caller?			;029
	BNE	80$		;;Yes, ok				;041
	BIT	#DDPRVO,(R1)	;;Require privs to own device?
	BNE	60$		;;Yes, so error
80$:	CLR	R0		;;Assume new job type is interactive	;045
	CMPB	TTINTF(R1),#TTPK11 ;;Is this a PK?			;045
	BNE	82$		;;No, so can't be network job		;045
	MOVB	DDUNT(R1),R3	;;Get unit number			;045
	ASL	R3		;;Now get unit number times two		;005
	MOV	CSR.KB(R3),R3	;;And get PK DDB pointer		;005
	MOV	PKMODE(R3),R0	;;Get PK mode				;005
	BIC	#^C<PKBAT!PKNET>,R0 ;;Get only batch/net flags		;045
.ASSUME	J2NET	EQ	PKNET
.ASSUME	J2BAT	EQ	PKBAT
	BIT	#J2NET,R0	;;Network?				;045
	BEQ	84$		;;Not network, so access allowed	;045
	BIT	#AT.NNT,AT.PTI(R5) ;;Network access prohibited?		;045
	BEQ	84$		;;No, so all set			;045
	ERROR	BADFUO		;;Yes, reject				;045
                   
82$:	BIT	#TTMODM,TTINTF(R1) ;;Is this a modem line?		;046
	BEQ	84$		;;No, allow access			;045
	BIT	#AT.NDL,AT.PTI(R5) ;;Dialups disallowed?		;045
	BNE	60$		;;Yes, so error				;045
84$:	MOV	@#FIJBDA,R3	;;Get JDB pointer			;049
	BIC	#J2NET!J2BAT,JDFLG3(R3) ;;Clear out current job type	;049
	BIS	R0,JDFLG3(R3)	;;Update job type			;049
	TST	(SP)		;;Is this a reattach?			;048
	BNE	88$		;;Yes, so skip swap console stuff	;048
	MOVB	DDJBNO(R1),R4	;;Pick up owner job # * 2		;048
	BEQ	85$		;;Hummm... must have just hung up	;048
	MOV	JOBTBL(R4),R1	;;Pick up pointer to JDB		;048
	CALLX	CONNEC		;;Now update the connect time		;048
	MOV	R3,R1		;;And get the DDB pointer back		;048
85$:	CALLMI	KBRSET,KBDAP5	;;Reset the terminal			;048
88$:	MOVB	@#FIJOB,R0	;;Get the JOB's job number		;066
	MOV	@#FIJBDA,R2	;; and the JDB pointer			;066
	TST	(SP)+		;;Is this a swap console?		;066
	BEQ	90$		;;Yes, don't clear out terminal		;066
	TSTB	DDJBNO(R1)	;;Is this job owned?			;066
	BNE	92$		;;Yes, so don't clear out the terminal	;066
	MOVB	R0,DDJBNO(R1)	;;No, set the new owner			;066
	CALLMI	CLRTIN,KBDAP5	;;Clear TTY input side/mode(s)		;066
90$:	MOVB	R0,DDJBNO(R1)	;;Set the new owner for swap console	;066
	MOV	@#TIME,DDTIME(R1) ;;Set time assigned			;066
92$:	MOVB	#1,DDCNT(R1)	;;Force access count to 1		;066
	BIS	#DDCONS,DDCNT(R1);; AND SET TTY CONSOLE FLAG
	SPLC	3		;;BACK TO LEVEL 3 AGAIN
	MOV	(R2),R2		;GET IOB POINTER
100$:	MOV	(R2),R4		;SAVE "OLD" CONSOLE DDB POINTER
	MOV	R1,(R2)+	;SET "NEW" CONSOLE IN IOB CHNL 0
	MOV	#15.,R3		;Set up the channel counter		;049
	CALL	110$		;Update the IOB				;029
	MAP	@#FIPJC6,APR=6,DATA,PIC,R=2 ;Map JCR entry for job	;049
	MOV	@#FIPJCR,R2	;And point to it			;049
	ADD	#JCPFB+<PF$DAT*2>,R2 ;Now point to first data channel	;049
	MOV	#14.,R3		;Set up the channel counter		;049
	.CALLR	110$		;Update the PFB channels		;049

110$:	CMP	R4,(R2)		;THIS CHANNEL MATCH OLD CONSOLE?
	BNE	120$		;NO
	CMPB	DDJBNO(R1),DDJBNO(R4) ;YES, STILL OWN THE OLD ONE?
	BEQ	120$		;JUST SKIP IT IF STILL OWNED
	MOV	R1,(R2)		; ELSE SET POINTER TO NEW CONSOLE
120$:	CMP	R1,(R2)+	;THIS CHANNEL MATCH CONSOLE?
	BNE	130$		;NO, SKIP IT
	INCB	DDCNT(R1)	;ELSE CORRECT ACCESS COUNT
130$:	SOB	R3,110$		;And loop for all the channels		;049
	MAP	FIPPOL		;Restore FIP pool mapping		;049
	RETURN			;And exit				;049


GLOBAL	<CNT.KB,DEV.KB,CSR.KB,FIPJC6,FIPJCR>				;005

.DSABL	LSB								;025

FQFEND									;020

.END
