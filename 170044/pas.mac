	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
	.INCLUDE /CMN:FLDEF/
TITLE	PAS,<Create account/PASSWORDS, ETC.>,0A,10-MAY-91,MHB/ABC/SRM/FEK/GPK/WJS/DRP/FRL/KPH

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR PAS

;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;  001	SRM  25-Mar-81	Have UU.DAT reset seconds to zero.
;
;				[RSTS V8.0]
;  003  FEK  16-Jul-82	Add GFD creation.
;  004  FEK  19-Jul-82  Break into 2 overlays
;  005  FEK  28-Jul-82	Add pre-extended & placed UFD's
;  006	GPK  08-Oct-82	Passwords in password blockettes
;  007	GPK  28-Oct-82	Fix password creation on old disks
;  008	WJS  29-Oct-82	New UUOENT for EMT Logger
;  009	GPK  08-Dec-82	Fix bug in account creation
;  010  DRP  11-Feb-83  Invalidate directory lookup cell when deleting
;			accounts.
;  011  DRP  11-Feb-83	Source clear fix for setting quota when creating
;			an account which has no password.
;
;				[RSTS V9.0]
;  012	GPK  25-Mar-83	Multiple privileges
;  013	GPK  20-Sep-83	Long passwords/encryption
;  014	GPK  19-Nov-83	Bugfixes in create account; enhance delete account
;  015	DRP  05-Dec-83	Changes for Open phase
;  016	GPK  29-Dec-83	Split ACNT into WACNT/GACNT
;  017	GPK  12-Jan-84	Disallow pre-84 dates
;  018  FRL  21-Dec-83  Allowed creation of [0,*] for V9.0 disks
;  019	DRP  01-Feb-84	Add support for logged-in quotas to UU.PAS
;  020	DRP  16-Mar-84	Removed unnecessary code from UU.PAS
;  021	GPK  19-Apr-84	Privilege name changes
;  022	GPK  09-May-84	Disallow setting password on [0,*] other than [0,1]
;  023	GPK  11-May-84	Allow setting creation date/time on UU.BCK
;  024	DRP  21-May-84	Validate quotas prior to creating the account
;  025	GPK  30-Oct-84	Fix GACNT privilege check
;  026  FRL  02-Nov-84  New special value for POSITION
;  027	GPK  22-Jan-85	Bugfix in old-style passwords on UU.PAS
;  028	KPH  15-Feb-85	Change error for files in account to FIEXST
;
;			[RSTS/E V9.3]
;  029  KPH  30-May-86	Return FIEXST on [0,1] creation attempts
;  030  KPH  11-Sep-86	Fix UU.NAM check for executable files
;
;  			[RSTS/E V9.5]
;  031	PJH  07-Jul-87	Add large disk support
;  032	PJH  09-Oct-87	Fix VALQTA call in Account create call
;
;  			[RSTS/E V10.0]
;  033	FEK  02-Nov-89	Add BACKUP/IGNORE bits support
;-

FQFSRT	PAS

.SBTTL	ACCOUNT CREATOR

;+
; UU.PAS - ACCOUNT CREATOR.
;
;	Old Format
;
;	R4 -> FIRQB
;		FQERNO	 =  # CLUSTERS TO PRE-EXTEND
;		FQSIZM	 =  0 (Old format of call)			;019
;		FQPPN 	 =  DCN TO PLACE UFD AT
;		FQNAM1 	 =  PPN
;		+12    	 =  PASSWORD (2 WORDS RAD50)
;			    0 to not set a password (no access)
;		FQBUFL	 =  Expiration date (0 if none)			;013
;		FQDEV,FQDEVN = DEVICE TO USE
;		FQCLUS	 =  UFD CLUSTER SIZE
;
;	New Format							;019
;
;		FQERNO	 =  # CLUSTERS TO PRE-EXTEND
;		FQSIZM	 =  128 (New format of call)			;019
;		FQPPN 	 =  DCN TO PLACE UFD AT
;		FQNAM1 	 =  PPN
;		+12    	 =  PASSWORD (2 WORDS RAD50)
;			    0 to not set a password (no access)
;		FQSIZ 	 =  Logged-out quota (LSB)			;019
;		FQBUFL	 =  Expiration date (0 if none)			;013
;		FQMODE	 =  Logged-in quota (LSB)			;019
;		FQFLAG	 =  Logged-in quota (MSB)			;019
;		FQFLAG+1 =  Logged-out quota (MSB)			;019
;		FQPFLG	 =  Reserve quota (LSB)				;019
;		FQDEV,FQDEVN = DEVICE TO USE
;		FQCLUS	 =  UFD CLUSTER SIZE
;		FQCLUS+1 =  Reserve quota (MSB)				;019
;-

	UUOENT	PAS,<WACNT,GACNT>,,LOGABL,DOLOG	;ACCOUNT CREATION	;016

	CALLX	GUN,R5		;GET THE UNIT
	 BR	50$		;DISK IS O.K.
	ERROR	DEVNFS		;ELSE IS BAD NEWS

10$:	ERROR	PRVIOL		;WRITE-LOCKED UNIT OR ILLEGAL PPN

20$:	ERROR	BADCLU		;BAD CLUSTER SIZE

30$:	ERROR	BADCNT		;ILLEGAL PARAMETER.

40$:	ERROR	FIEXST		;ACCOUNT TO ADD IS ALREADY THERE

45$:	ERROR	BADNAM		;Trying to specify password on [0,2...254] ;022

50$:	BIT	#UC.WLO,(R1)	;IS UNIT WRITE LOCKED?
	BNE	10$		;YES, ERROR
	MOV	R0,R1		;SAVE UNIT TIMES 2 HERE
	TST	UNTLVL(R1)	;Old disk?				;013
	BEQ	10$		;Yes, can't do those			;013
	MOV	FQNAM1(R4),R0	;Get PPN to create			;025
	CALLX	CHKACC		;Check access rights			;025
	TST	R0		;Have accounting rights?		;025
	BPL	10$		;No, error				;025
.ASSUME	DDSTAT LT 0							;025
60$:	NOP			;Debugging				;031
	MOV	R4,R0		;NOW POINT R0 TO THE FIRQB		;016
	ADD	#FQNAM1,R0	;INDEX TO THE PPN AND PASSWORD
	CLR	R5		;avoid sign extends			;031
	BISB	UNTCLU(R1),R5	;GET PACK CLUSTER SIZE IN R5		;031
	MOV	FQPFLG(R4),FQNENT(R4) ;Move the reserve quota (LSB)	;024
	MOVB	FQCLUS+1(R4),FQPROT(R4) ; and the MSB part also		;024
	MOV	R1,-(SP)	;SAVE THE FUN *2
	CMP	UNTLVL(R1),(PC)+ ;Support extended disk quotas?		;031
	 .BYTE	2,1							;031
	BHIS	68$		;Yes, then no validation needed		;031
	ASR	R1		;Make it just FUN			;024
	FCALL	VALQTA		;Go validate the quotas			;024
	MOVB	R1,@#FIPUNT	;Restore the Fip Unit number		;032
68$:	CLR	R1		;avoid sign extends			;031
	BISB	FQCLUS(R4),R1	;GET THE CLUSTER SIZE			;031
	BEQ	80$		;IF NONE, check/USE PACK CLUSTER SIZE	;031
	BPL	70$		;IF POSITIVE USE IT AS IS
	NEGB	R1		;IF NEGATIVE USE ABS(CLUSTER)		;031
	CMP	R1,R5		;IS IT TOO SMALL?
	BLO	80$		;YES, USE PACK CLUSTER SIZE
70$:	CMP	R5,#16.		;large cluster disk?			;031
	BLOS	75$		;no, so standard checks			;031
	CMP	R1,#16.		;large disk, so must be 16		;031
	BNE	20$		;not, so error out			;031
	BR	77$		;join common code			;031

75$:	CMP	R1,R5		;CHECK FOR TOO SMALL
76$:	BLO	20$		;ERROR IF TOO SMALL			;031
	CMP	R1,#16.		;CHECK FOR TOO BIG
	BHI	20$		;EVIL IF > 16.
77$:	MOV	R1,R5		;SET THIS AS THE CLUSTER SIZE
	DEC	R1		;NOW FIND OUT IF IT IS
	BIT	R1,R5		; A POWER OF 2
	BNE	20$		;IF NOT, THEN AN ERROR
80$:	MOV	(SP),R1		;RESTORE THE FUN*2
	CMP	R5,#16.		;PCS greater than 16?			;031
	BLOS	85$		;no, so ok				;031
	MOV	#16.,R5		;Yes, so save as 16			;031
85$:	MOV	R5,(SP)		;SAVE THE CLUSTER SIZE
	MOV	(R0),R2		;GET THE NEW PPN
	BEQ	10$		;[0,0] IS AN ERROR
	INCB	R2		;CHECK FOR [*,255]
	BEQ	10$		;[*,255] IS AN ERROR
..AGFD==.-2		;** PATCH ** ALLOW EXPLICIT GFD CREATES
	CMP	R2,(PC)+	;[0,1]?					;018
	 .BYTE	 2,0		; (low byte of R2 was incremented)	;018
	BEQ	40$		;Yes, already exists			;029
	SWAB	R2		;NOW SWITCH TO PROJECT NUMBER
	BNE	90$		;Not [0,*], skip			;018
	CMP	UNTLVL(R1),(PC)+ ;V9.0 DISK?				;018
	 .BYTE	 2,1							;018
	BLO	10$		;No, so all [0,*] are illegal		;018
	TST	2(R0)		;Specifying password?			;022
	BNE	45$		;Yes, that's an error			;022
90$:	INCB	R2		;CHECK FOR [255,*]			;018
	BEQ	10$		;ERROR IF [255,*]
	MOVB	FQERNO(R4),R5	;GET THE NUMBER OF CLUSTERS WANTED
	CMPB	R5,#7		;IS IT TO BIG?
	BHI	30$		; YES, THATS TO MANY
	CMP	-(R0),#-2	;SPECIAL?? (i.e. -1 or -2)		;frl
	BHIS	120$		;YES, SO SKIP THE DCN TO BIG CHECK	;frl
	MOVB	DEVCLU(R1),R3	;GET THE DEVICE CLUSTER SIZE IN R3
	MOV	(SP),R2		;GET THE UFD CLUSTER SIZE BACK
100$:	ASR	R3		;Divide DCS by 2
	BCS	110$		;Done
	ASR	R2		;Divide UFD CS to get cluster ratio
	BR	100$

110$:	TST	R2		;Did we get a valid Clus Ratio?		;031
	BNE	115$		;yes, so ok				;031
	INC	R2		;No, so large disk, set ratio to 1	;031
115$:	MUL	R2,R5		;TOTAL NUM. OF D.C'S FOR ENTIRE EXTEND
	ADD	(R0),R5		;FIND THE REQUESTED ENDING DCN
	BCS	30$		;IF IT OVERFLOWS, THEN IT'S TO BIG
	CMP	R5,UNTSIZ(R1)	;TO BIG??
	BHI	30$		;YES, SO ILLEGAL PARMS
120$:	MOV	(R0),@#DIRPOS	;SAVE THE STARTING DCN
	MOV	FQNAM1(R4),(R0)	;MOV THE PPN TO FQPPN (FOR CREMFD)
	CALLX	SDM		;SEARCH THE MFD.
	BCC	40$		;ALREADY THERE IS AN ERROR
	CMPB	(R0),#255.	;DO THEY WANT TO CREATE THE GFD??
	BNE	130$		;NO, SO ALL IS WELL
	CMP	MFDPTR(R1),@#FIBENT ;ARE WE STILL IN THE MFD??
	BNE	40$		;NO, IN A GFD, SO CAN'T CREATE A GFD
	CMP	(SP),#4		;A GFD'S CLUSTERSIZE MUST BE >= 4.
	BLO	76$		;ERROR IF SMALLER!!! (2 step jmp to 20$)   ;031
	MOVB	#1,FQERNO(R4)	;MAKE SURE WE ONLY EXTEND BY 1 CLUSTER
130$:	TST	@#DIRPOS	;DID THEY REQUEST A POSITION???
	BNE	140$		; YES, SO USE THEIRS
	MOV	@#FIBENT,@#DIRPOS ; NO, GET CLOSE TO NEXT HIGHER LEVEL
140$:	MOV	R2,@#FIPCLU	;REMEMBER THE LINK TO THE LAST ENTRY
	MOV	(SP),R2		;AND THE CLUSTER SIZE
	MOV	R2,@#FIPU0C	;PUT IT HERE ALSO
	MOV	R1,R0		;MOVE THE FUN*2 TO R0 FOR THE FCALL
	ASR	R0		;R0 = FUN * 1
	CLR	R1		;FLAG TO MAKE SURE IT WORKS
	CALLM	CREMFD,OPNAP5	;CREATE UFD, GFD (IF WE CAN) & MFD ENTRY ;015
	MOV	R0,@#FIPUNT	;RESTORE THE FIP UNIT # FOR SDM
	MOVB	FQERNO(R4),R3	;GET THE COUNT TO EXTEND
	DEC	R3		;DEC THE COUNT TO EXTEND
	BLE	220$		; 1 OR 0, THEN WE JUST DID THAT ONE
	MOV	#FIBENT+2,R5	;SET THE STARTING POINTER
	MOV	(SP),R1		;GET THE CLUSTER SIZE AGAIN
	ASL	R0		;MAKE R0 = FUN*2
150$:	MOV	@#DIRPOS,SATPTR(R0) ;SET THE STARTING DCN #
	CALLX	GETCLU		;GET A CLUSTER TO EXTEND THE DIR
	BCS	160$		;CAN'T, SO JUST EXIT HERE
	MOV	R2,(R5)+	;STORE THE CLUSTER AWAY
	SOB	R3,150$		;DO ALL THE CLUSTERS THEY WANTED
160$:	MOV	#FIBENT,R5	;POINT TO ALL THE DCN'S AGAIN
	CLR	-(SP)		;PUT A FIRST TIME FLAG ON THE STACK
170$:	MOV	(R5)+,R2	;GET THE DCN # WE MUST CHANGE
	BEQ	210$		;ALL DONE
	CALLX	CNVDCN		;GET THE FBN WE'RE CHANGING
	MOV	R2,@#FIBFBN+F.FBNL ; TELL IT WHERE TO WRITE
	MOV	R3,@#FIBFBN	;BOTH PARTS OF THE FBN
180$:	CALLX	WRITE		;PUT IT BACK OUT THERE (ALL UPDATED)
	ADD	#1,@#FIBFBN+F.FBNL ;GO TO THE NEXT FBN
	ADC	@#FIBFBN	;REALLY GET THE NEXT FBN
	TST	(SP)		;CHECK IF WE MUST ZERO
	BNE	200$		;NO, WE DON'T HAVE TO ZERO IT
	MOV	#FIBUF,R2	;POINTER TO LABEL BLOCKETTE TO ZERO IT
	MOV	#10,R0		;COUNT OF AREA TO ZERO
190$:	CLR	(R2)+		;DO THE CLEAR
	SOB	R0,190$		;CLEAR THE WHOLE LABEL OUT.
	INC	(SP)		;SET THE FLAG THAT WE DID THE CLEAR
200$:	SOB	R1,180$		;GET ALL FBN'S IN THIS DIR CLUSTER
	MOV	2(SP),R1	;GET THE CLUSTER SIZE BACK AGAIN
	INC	(SP)		;COUNT THIS CLUSTER
	CMP	(SP),#8.	;DID WE JUST FINISH THE LAST ONE
	BNE	170$		;NO, SO DO THE NEXT DCN.
210$:	TST	(SP)+		;DUMP THE FLAG
220$:	TST	(SP)+		;DUMP THE CLUSTER SIZE FINALLY
	MOV	@#FIPUNT,R0	;Grab the current fip unit (FJMP mungs)	;031
	FJMP	RSTPAS		;go to next overlay			;031
FQFEND									;031

GLOBAL	<UNTCLU,CREMFD,FIPUNT,DIRPOS,FIPCLU,FIPU0C,UNTSIZ,DEVCLU>
GLOBAL	<MFDPTR,FIBENT,FIBFBN,FIBUF,SATPTR,OPNAP5>			;016
GLOBAL	<SETQTA,VALQTA>							;024

FQFSRT									;031

RSTPAS:	NOP			;debugging				;031
	MOV	R0,@#FIPUNT	;put back fip unit number		;031
	MOV	#FIBENT,R1	;COPY 7 DCN'S STARTING HERE
	MOV	#7,R3		;GET ALL 7
230$:	MOV	(R1)+,-(SP)	;Store away all seven DCN's		;019
	SOB	R3,230$		; for later use				;019
	MOV	R4,-(SP)	;Now save the FIRQB pointer		;019
	ADD	#FQBSIZ,(SP)	; and point to the end of the FIRQB	;019
	MOV	R4,R0		;COPY THE FIRQB POINTER
	ADD	#FQNAM1,R0	;POINT TO THE PPN IN THE FIRQB		;027
	CMPB	(R0),#255.	;DID THEY REQUEST  A GFD CREATE
	BEQ	270$		;Yes, skip
	CALLX	SDM		;Search for the name entry again
	BCS	290$		;Can't find it, that's ill
	BISB	#7,FQSIZM(R4)	;Set-up flag byte for SETQTA		;019
	MOVB	@#FIPUNT,R1	;Save the FIP unit number		;020
	FCALL	SETQTA		;Go and set the quotas			;019
	MOVB	R1,@#FIPUNT	;Restore the Fip Unit Number		;019
	MOV	R3,-(SP)	;Save the link
	MOV	R0,-(SP)	;Save R0
	MOV	#AA.DAT,R0	;We'll create date entry this way
	CALLX	SAACR		;By using search or create
	BCS	300$		;No room, die
	MOV	(SP)+,R0	;Restore R0
	MOV	@#DATE,AT.CDA(R5) ;Set creation date
	MOV	FQBUFL-FQNAM1(R0),AT.EXP(R5) ;Set expiration date	;013
	BNE	260$		;One was specified, skip		;013
	DEC	AT.EXP(R5)	;Otherwise default to "no expiration"	;019
260$:	MARK	FIBUF		;Mark buffer
	MOV	(SP)+,R3	;Restore the link
	TST	2(R0)		;Password specified?
	BEQ	270$		;No, just return the clusters and exit	;019
	MOVB	@#FIPUNT,R1	;Get FIP unit number
	FCALL	SETPAS		;Go set the password in UU.CHU		;014
270$:	MOV	(SP)+,R0	;Retrieve cluster info pointer		;014
	MOV	#7,R1		;Count to restore			;014
280$:	MOV	(SP)+,-(R0)	;Restore cluster info to FIRQB		;014
	SOB	R1,280$		; until done				;014
	RETURN			;That's all				;014

; ERRORS CREATING ACCOUNT

290$:	ERROR	ABORT		;SOMETHING IS MESSED UP.

300$:	ERROR	NOROOM		;No room to create another entry

FQFEND

GLOBAL	<SYSUN2,UNTCLU,CREMFD,FIPUNT,DIRPOS,FIPCLU,FIPU0C,UNTSIZ,DEVCLU>
GLOBAL	<MFDPTR,FIBENT,FIBFBN,FIBUF,SATPTR,SETPAS,FIUSER,FIPRVM,OPNAP5>	;016
GLOBAL	<SETQTA,VALQTA>							;024

FQFSRT

.SBTTL	FILE RUN-TIME SYSTEM NAME CHANGER

;+
; UU.NAM - FILE RUN-TIME SYSTEM NAME CHANGER.
;
;	R1 -> JOB DATA BLOCK
;	R4 -> FIRQB
;		FQFIL  =  CHANNEL NUMBER
;		+5     =  NEW RUN-TIME SYSTEM NAME (4 BYTES)
;-

.ENABL	LSB								;023

	UUOENT	NAM,,,LOGABL	;RUN-TIME SYSTEM NAME CHANGER

	CLC			;Indicate UU.NAM			;023
	BR	10$

.SBTTL	BACKUP FILE DATE/TIME CHANGER

;+
; UU.BCK - BACKUP FILE DATE/TIME CHANGER.
;
;	R1 -> JOB DATA BLOCK
;	R4 -> FIRQB
;		FQFIL  =  CHANNEL NUMBER
;		+5     =  NEW DATE OF LAST ACCESS/WRITE (2 BYTES)
;		+7     =  NEW DATE OF CREATION (2 BYTES)
;		+11    =  NEW TIME OF CREATION (2 BYTES)
;-

	UUOENT	BCK,,,LOGABL	;FILE DATE/TIME CHANGE		;021

	TSTPRV	DATES,@#FIPRVM	;Have dates privilege?			;023
	BNE	5$		;Yes					;023
	CLRB	FQSIZM(R4)	;No, so force no change in last access	;023
	CLRB	FQPPN(R4)	; both bytes				;023
5$:	SEC			;SET C=1
10$:	MOV	#DDWLO!WC$UFD!DDNFS!377,-(SP) ;SET LEGAL REQUEST FLAGS	;023
	RORB	(SP)		;INDICATE UU.NAM(177) OR UU.BCK(377)
	CMP	(R4)+,(R4)+	;INDEX TO FQFIL
	MOVB	(R4)+,R0	;GET THE CHANNEL NUMBER
	CMP	R0,#15.		;LEGAL?
	BHI	80$		;NO
	ASL	R0		;YES, TIMES 2 NOW
	ADD	(R1),R0		;FORM POINTER INTO IOB
	MOV	(R0),R1		; AND GET THE WCB/SCB/DDB POINTER
	BEQ	70$		;ERROR, NOT OPEN
	BIT	(SP),(R1)	;HAVE REQUIRED ACCESS?
	BNE	310$		;NO, ERROR
	CALLX	RNE		;NOW READ THE NAME ENTRY
	MOVB	@#FIPUNT,R0	;GET FIP UNIT
	ASL	R0		; TIMES 2
	BIT	#UC.WLO,UNTCNT(R0) ;IS THE DISK WRITE LOCKED?
	BNE	310$		;YES, ERROR
	MOVB	UPROT(R5),R2	;No, get protection code for later	;030
	CALLX	RAE		;READ ACCOUNTING ENTRY INTO MEMORY
	MARK	FIBUF		;PRE-MARK BUFFER
	MOV	R5,R0		;COPY A.E. POINTER
	ADD	#URTS+2,R0	; AND POINT TO RTS NAME OR LARGE FILE SIZE
	MOVB	(R0),R3		;GET MSB SIZE IF REALLY LARGE
	TST	-(R0)		;IS IT A LARGE FILE (RTS NAME NULL)?
	BNE	20$		;NO, LEAVE C=0 (FROM 'TST')
	NEGB	R3		;YES, SET CARRY IF MSB <> 0, CLEAR C IF MSB=0
20$:	BITB	(SP),(SP)+	;WANT TO CHANGE RUN-TIME SYSTEM NAME?
	BPL	60$		;YEP
	TST	(R5)+		;Index to DLA				;023
.ASSUME	UDLA EQ 2							;023
	TSTB	(R4)		;Have new date?				;023
	BNE	25$		;Yes					;023
	TSTB	1(R4)		;Maybe...				;023
	BNE	25$		;Yes, set it				;023
	TST	(R5)+		;Bump accounting block pointer		;023
	ADD	#2,R4		; and FIRQB pointer (which is odd here)	;023
	BR	28$		;  and skip				;023

25$:	MOVB	(R4)+,(R5)+	;SET LOW LAST ACCESS DATE BYTE
	MOVB	(R4)+,(R5)+	; THEN HIGH BYTE
28$:	BICB	#WC$DLW,W$FLAG(R1) ;TURN OFF CORRECTION AT CLOSE
	MOV	W$FCB(R1),R2	;GET POINTER TO FCB @ F$CLUS
	MOV	-(R2),(R5)	;ENSURE CORRECT SIZE LSB
	MOVB	-(R2),R2	; AND GET SIZE MSB
	BEQ	40$		;IF NONE, NO CHANGE TO URTS
	CLR	(R0)+		;IF MSB SIZE, FLAG WITH RTS OF 0
	MOVB	R2,(R0)		; AND SET THE MSB SIZE
40$:	TST	(R5)+		;NOW INDEX TO DATE/TIME OF CREATION
	.ASSUME UDC EQ 6
	MOVB	(R4)+,(R5)+	;SET A BYTE (creation date LSB)
	MOVB	(R4)+,(R5)+	; AND SET ANOTHER (creation date MSB)
	MOVB	(R4)+,(R5)+	; Now, set the creation time LSB	;033
	.ASSUME UTC EQ 10
	MOV	(R4)+,R0	; Get the creation time MSB for now	;033
	BICB	#^C<UTC.TM>/400,R0 ;No changing flag bits		;033
	BICB	#UTC.TM/400,(R5) ; Clear old time MSB to replace it	;033
	BISB	R0,(R5)		; Merge new time into old flags		;033
	RETURN			;  THEN EXIT OR LOOP


GLOBAL	<FIPUNT,UNTCNT>

; CHANGE RTS NAME

60$:	BCS	310$		;SETTING RTS NAME ON A LARGE FILE IS AN ERROR
	MOV	R0,R5		;COPY POINTER TO THE RTS NAME LOCATION
	MOV	R4,R0		;COPY FIRQB POINTER
	MOVB	(R0)+,R3	;CHECK FOR REAL (NON-ZERO)
	BISB	(R0)+,R3	; RUN-TIME SYSTEM NAME
	BNE	90$		;REAL (NON-ZERO), GO DO IT
	ASLB	R2			;NULL (ZERO), RUNNABLE FILE?
	BMI	310$		;YES, THAT MUST HAVE A RTS NAME
.ASSUME	UP.RUN*2 EQ	200
	MOVB	(R0)+,R3	;DATA FILE, FULLY ZERO
	BISB	(R0)+,R3	; RTS NAME??
	BEQ	90$		;YES, ALLOW THAT
310$:	ERROR	PRVIOL		;ILLEGAL ACCESS/WLO/RTS ON LARGE FILE
	
70$:	ERROR	NOTOPN		;CHANNEL IS CLOSED

80$:	ERROR	BSERR		;ILLEGAL I/O CHANNEL

90$:	MOV	PC,-(SP)	;EXECUTE CODE BELOW TWICE FOR 2 WORDS
	MOVB	(R4)+,(R5)+	;SET A BYTE
	MOVB	(R4)+,(R5)+	; AND SET ANOTHER
	RETURN			;  THEN EXIT OR LOOP

.DSABL	LSB								;023

.SBTTL	DELETE USER ACCOUNT

;+
; UU.DLU - DELETE USER ACCOUNT.
;
;	R4 -> FIRQB
;		FQNAM1 =  PPN
;		FQDEV,FQDEVN = DEVICE TO USE
;-

	UUOENT	DLU,<WACNT,GACNT>,,LOGABL,DOLOG	;DELETE ACCOUNT		;016

	CALLX	GUN,R5		;GET THE UNIT INVOLVED
	 BR	10$		;DISK IS O.K.
	ERROR	DEVNFS		;ELSE IS A BADDY

10$:	BIT	#UC.WLO,(R1)	;IS THE UNIT WRITE LOCKED?
	BNE	310$		;YES, ERROR
	MOV	FQNAM1(R4),R0	;Get PPN to delete			;025
	CALLX	CHKACC		;Check access rights			;025
	TST	R0		;Have accounting rights?		;025
	BPL	310$		;No, so reject this			;025
.ASSUME	DDSTAT LT 0							;025
320$:	MOV	R4,R0		;BUILD A SEARCH				;016
	ADD	#FQNAM1,R0	; POINTER
	CMP	(R0),(PC)+	;ILLEGAL IF [0,1] OR TOTALLY 0
	 .BYTE	1,0
	BLOS	310$		; SO GIVE ERROR
	TST	UNTLVL-UNTCNT(R1) ;IS IT OLD OR NEW??
	BNE	20$		;NEW, THEN THEY CAN DELETE [1,1]
	CMP	(R0),(PC)+	;ILLEGAL IF [1,1]
	 .BYTE	1,1
	BEQ	310$		;WHOOPS! ERROR
20$:	CALLX	SDM		;MASTER FILE DIRECTORY SEARCH
	BCS	40$		;COULDN'T FIND ACCOUNT
	CALLX	SNE		;FOUND. IS THE UFD OPEN AS A FILE?
	BCC	70$		;YES FOR LARGE FILE SYSTEMS
	TST	UACNT(R5)	;CHECK FOR ANY ACCESSES FOR SMALL FILE SYSTEMS
	BNE	70$		;ERROR IF OPEN AS FILE
	MOV	UAR(R5),R2	;IS THIS UFD NULL?
	BEQ	30$		;YES
	CALLX	RAE		;READ ACCOUNTING ENTRY
	BIT	(R5),#UL.BAD	;A BAD BLOCK IN THIS DIRECTORY?
	BEQ	130$		;No bad block, check if it's empty
	CALLX	READUF		;A BAD BLOCK, SO READ DIRECTORY
	BIT	#UL.BLO!UL.CLO!UL.ENO,@#FIBUF ;ANY FILES THERE?
	BNE	120$		;Yes, report it still has files

GLOBAL	<FIBUF,UNTLVL,FIUSER,FIPRVM>					;016

30$:	CALLX	SDM		;O.K., RE-SEARCH FOR PPN TO GET PREVIOUS LINK
	MOVB	@#FIPUNT,R1	;GET THE CURRENT FUN * 1
	ASL	R1		;AND MAKE IT FUN * 2
	TST	UNTLVL(R1)	;IS IT A NEW OR OLD DISK??
	BEQ	350$		;OLD, SO GO DO IT
	MOV	UAA(R5),-(SP)	;SAVE THE ACCOUNTING LINK POINTER
	MOVB	#-1,@#LSTFUN	;MAKE SURE READ/RESET ACCOUNTING CODE
				;STARTS FROM THE BEGINNING
330$:	CALLX	ZDENXT		;ZERO THIS ONE, AND GO ONTO THE NEXT ONE
	CALLX	RDECHK		;READ IN THE NEXT ONE
	BNE	330$		;GO AND ZERO IT AND LOOK FOR MORE
	MOV	(SP)+,R3	;RESTORE THE ACCOUNTING POINTER
	CALLX	RDECHK		;FIRST WE MUST READ IT IN...
	BEQ	340$		; UNLESS, SOMEHOW, THERE IS NO ENTRY
	CALLX	ZDE		;AND GO ZAP THIS ONE
340$:	CALLX	SDMDCN		;GO GET THE DCN POINTER TABLE IN FIBUF
	CLR	FIBUF(R5)	;CLEAR OUT THIS PPN'S POINTER
	CALLX	WRITE		;AND RE-WRITE THIS BLOCK
	MOV	@#FIBFBN+F.FBNL,R2 ;GET THE FIP BLOCK # WE JUST WROTE TO
	MOV	@#FIBFBN,R3	; REALLY GET ALL OF IT BACK
	ADD	#1,R2		;GET TO THE NAME BLOCK POINTER TABLE
	ADC	R3		;REALLY GET THERE
	CALLX	READ		; AND READ THIS INTO FIBUF
	CLR	FIBUF(R5)	;AND ZAP THE POINTER TO THIS PPN'S NAME BLOCK
	CALLX	WRITE		;AND MAKE SURE IT GETS RE-WRITTEN
	BR	360$		;AND CONTINUE INLINE

350$:	CALLX	XDR		;BYE TO ALL OF UFD
360$:	TSTB	@#FIPGEN	;GENERAL?
	BEQ	60$		;NO, SO EXIT
	DECB	@#FIPGEN	;COUNT THIS AS ONE FOUND
40$:	TSTB	@#FIPGEN	;GENERAL?
	BEQ	80$		;ERROR IF SPECIFIC
	CALLX	NXTUNT,R1,<UC.MNT!UC.PRI!UC.NFS!UC.WLO> ;GET NEXT UNIT
	 BR	50$		;NONE
	BR	20$		;ONE

50$:	INCB	@#FIPGEN	;DID WE FIND ANY
	BEQ	80$		;IF NOT, THEN AN ERROR
60$:	RETURN			;ELSE EXIT

310$:	ERROR	PRVIOL		;WRITE LOCKED OR [0,0] OR [0,1] OR [1,1]

70$:	ERROR	INUSE		;UFD IS OPEN AS FILE, EXISTS, HAS BADS & FILES

80$:	ERROR	NOSUCH		;NOT THERE (SPECIFIC) OR NOWHERE (GENERAL)

120$:	ERROR	FIEXST		;Account is not empty			;028

130$:	CALLX	READUF		;Read UFD label block			;014
	BIT	#UL.BLO!UL.CLO!UL.ENO,@#FIBUF ;Have files?		;014
	BNE	120$		;Yes, reject the delete			;014
	MOV	#FIBENT+<7*2>,R5 ;Point beyond clustermap		;014
140$:	MOV	-(R5),R2	;Pick up previous entry			;014
	BEQ	140$		;Haven't found one yet			;014
	CMP	R5,#FIBENT	;Done yet?				;014
	BLO	30$		;Yes, so do the actual delete		;014
	CLR	R1		;avoid sign extends			;031
	BISB	@#FIBMAP,R1	;Get UFD clustersize			;031
	CALLX	RETCLU		;Return the cluster			;014
	CALLX	WOMSAT		;Make sure SAT is updated		;014
	BR	140$		; and repeat with next map entry	;014

GLOBAL	<FIPGEN,FIPUNT,UNTLVL,LSTFUN,FIBENT,FIBMAP>			;014

FQFEND

.END
