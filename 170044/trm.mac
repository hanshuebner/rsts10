.INCLUDE /CMN:COMMON/							;028
.INCLUDE /CMN:KERNEL/							;028
.INCLUDE /CMN:FLDEF/							;028
.INCLUDE /CMN:KBDEF/							;028
TITLE	TRM,<TERMINALS CHARACTERISTICS>,0F,24-AUG-91,MHB/GW/ABC/JTC/RRF/SDL/WJS/TPT/GPK/DRP/DWF/JFM/DBM

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR TRM
;+
;
;  000	RRF  26-JAN-82	CREATION - COPIED FROM V7.1-56
;  001	SDL  26-JAN-82  Added CALLMI SETPRM,KBDAP5
;  002  SDL  09-FEB-82  Moved CALLMI further up in code
;  003	DRP  18-JUN-82	Fix a bug in validating the KB number
;  004	WJS  29-Oct-82	New UUOENT for EMT Logger
;  005	TPT  15-Feb-83	Added 7/8 bit controls
;  006	MHB  18-Feb-83	More work on 7/8 bit handling
;  007	TPT  22-Feb-83	Fix bug in ring list return values
;  008	TPT  18-Apr-83  Remove 2741/DC11 specific code
;
;			[RSTS V8.0-07]
;  009	TPT  22-Aug-83	Added DHV11 support
;
;			[RSTS V9.0]
;	[NOTE: V9.0 development merged with V8.0-07]
;  010	TPT  10-Nov-83	Merged GPK - Multiple privileges
;  011  TPT  10-Nov-83  Merged GPK - Add SYSMGR privilege
;  012  TPT  27-Feb-84	New TRM extension
;  013	GPK  17-Apr-84  Privilege name changes, make TRM synch
;  014  TPT  21-May-84  Don't allow speed change with Auto-Baud & Bugfix
;  015	TPT  05-Jun-84	Make TRM CALL not JMP to RQSPRM, cleanup
;  016	TPT  31-Oct-84	Protect Auto-Baud timing bits, bugfix
;  017	DRP  19-Nov-84	Fix bugs in UU.TRM and UU.HNG
;  018	DRP  23-Jan-85	Call routine to reset delimiter count when changing
;			the private delimiter or enable/disable CTRL/C
;  019	DRP  09-Feb-85	Add /BUFFER_QUOTA support
;			Return -1 for terminal speed if the device is
;			marked /AUTO and not owned by any job
;			Make TRM loadable
;
;			[RSTS V9.1]
;  020	DRP  28-Jun-85	Fix infinite loop problem when returning input
;			buffer quota.
;  021	DRP  02-Aug-85	Allow speed changes to owned terminals set to
;			Auto-baud.
;
;			[RSTS V9.2]
;  022	DRP  14-Oct-85	Issue NODEVC error on Get/Set Terminal
;			Characteristics if disabled.
;  023  DRP  31-Dec-85  Ignore nonexisting units in MORDHV.
;
;			[RSTS V9.3]
;  024	DRP  07-Feb-86	Correct parity setting problem in SPEEDV.
;                       Correct problem with setting NOLOCAL_ECHO
;			permanent characteristics.                           
;  025	DWF  13-May-86	Allow non-privileged access to owned non-console
;			terminals
;
;			[RSTS V9.4]
;  026	DRP  06-Mar-87	Return NOTAVL error in UU.TRM if accessing terminals
;			disabled by INIT.
;  027	DRP  20-Apr-87	Skip disabled check for Pseudo-keyboards.            
;
;			[RSTS V9.5]
;  029  JFM  12-Oct-87  Set permanent CTRL characteristics on sys call part one
;
;			[RSTS V9.6]
;  028  KPH  13-Oct-87	Add .INCLUDEs
;			Don't allow setting characteristics on non-existant
;			terminals
;			Changes for new terminal driver mapping
;			Change references to parts of DDB which were optional
;			Cleanup parameter word setting
;			Change disable processing to share code with UU.CFG
;  030  WRM  01-Dec-87  Source clear V9.5 into V9.6
;  031	DRP  09-Dec-87	Source clear correction to fix UU.HNG failures.
;  032	DRP  17-Feb-88	Check for disabled KBs in UU.HNG
;  033	DWF  02-Mar-88	Make Hangup (and set DTR) work on local LAT lines
;
;			[RSTS V9.7]
;  034	DRP  09-Aug-88	Clear out "trash input" timing bits from the
;			permanent copy of TTCAPB.
;
;			[RSTS/E V10.0]
;  035	JFM  31-Aug-89	Add new byte for new term characteristics
;  036	DBM  19-Oct-89	Add check for OPER privilege
;  037	JFM  30-Oct-89	Make line editing and recall DDB settings, not terminal
;			attributes.
;  038	JFM  14-Nov-89	Undid change 037 due to PPC (product planning committe)
;			recommendation
;  039	JFM  02-Jan-90	Happy new year!  Took out code to check type ahead (018)
;  040	JFM  19-Feb-90	Changed name of DDB cell from DDFLG3 to TTFLG3
;  041	DRP  17-Mar-90	Fix bug in old disable device SYS call.
;  042	DRP  29-May-90	Add comments describing how we get to the Disable device
;			SYS call.
;
;			[RSTS/E V10.1]
;  043	JFM  17-Jun-91	Adjust prompt position cell if terminal width changes
;  044	DRP  22-Aug-91	Allow the user to set the input buffer quota as low
;			as one.
;-


IONLY
FQFSRT	TRM,LODABL

.SBTTL	SET TERMINAL CHARACTERISTICS                                         

;+
; UU.TRM - SET TERMINAL CHARACTERISTICS.
;
;	R0 =  JOB NUMBER TIMES 2
;	R1 -> JOB DATA BLOCK
;	R4 -> FIRQB
;		 +4 =  0=> TRM   1=> TRM EXTENDED			;012
;		 +5 =  KB NUMBER (-1=>SELF)
;		** 0 => NO CHANGE FOR ALL PARAMETERS **
;		 +6 =  WIDTH +1 (0=>NO CHANGE)
;		 +7 =  -1=>NO TAB; 200=>TAB
;		+10 =  -1=>FORM; 200=>NO FORM
;		+11 =  -1=>NO LC OUTPUT; 200=>LC OUTPUT
;		+12 =  -1=>XON; 200=>NO XON
;		+13 =  -1=>LOCAL ECHO; 200=>FULL DUPLEX
;		+14 =  -1=>SCOPE+SYNC; 200=>NO SCOPE+NO SYNC
;		+15 =  -1=>LC INPUT+33 AS ESC; 200=>NO LC INPUT+33/175/176 AS ESC
;		+16 =  FILL FACTOR +1 (-1=>LA30 SERIAL FILL)
;		+17 =  OUTPUT SPEED CODE +1
;		+20 =  PARITY AND 7/8 BIT (0=>NO CHANGE TO EITHER)	;006
;			<2-0> = PARITY SETTING:				;006
;				<1-0> = 1=>NONE; 2=>EVEN; 3=>ODD	;006
;				 <2>  = DO NOT ALTER DATA FRAME SIZE	;006
;			<4-3> = 7/8 BIT SETTING:			;006
;				 <3>  = 8-BIT MODE (INSTEAD OF 7-BIT)	;006
;				 <4>  = 7/8 BIT SETTING IS "REAL"	;006
;		+21 =  INPUT SPEED CODE +1 (-1=>2741) (0=>INPUT=OUTPUT)
;		+22 =  -1=>SYNC; 200=>NO SYNC
;		+23 =  -1=>NO UPARROW; 200=>UPARROW
;		+24 =  ** UNUSED **					;006
;		+25 =  DH11 PARAMETERS (PARITY, STOP BITS, DATA FRAME)	;006
;		+26 =  PERMANENT TERMINAL CHARACTERISTICS		;012
;					0 => NO CHANGE			;012
;				      200 => RETURN PERMANENT CHARACTERISTICS ;012
;				      377 => SET PERMANENT CHARACTERISTICS ;012
;		+27 =  -1=>INCOMING ESC SEQ; 200=>NO INCOMING ESC SEQ
;		+30 =  PRIVATE DELIMITER (200=>NO PRIVATE DELIMITER)
;		+31 =  -1=>33 AS ESC; 200=>33/175/176 AS ESC
;		+32 =  -1=>ALLOW ^R/^T; 200=>DON'T ALLOW ^R/^T
;		+33 =  -1=>"XON" ON ANY CHAR; 200=>"XON" ONLY ON 'XON'/^C
;		+34 =  -1=>XLATE BREAK TO CTRL/C; 200=>TREAT BREAK AS NULL
;		+35 =  -1=>"GAG" THE TERMINAL; 200=>"UNGAG" THE TERMINAL
;
;	CURRENT SETTINGS ARE RETURNED AS ABOVE IN THE FIRQB.  IN ADDITION:
;		 +4 =  BITS 0-6 = DDJBNO, JOB*2 WHO OWNS TERMINAL
;		       BIT 7 = 1=>MODEM LINE HUNG UP; 0=>LINE GOOD
;		+24 =  INTERFACE TYPE
;		+36 =  7/8 BIT MODE (20=>7-BIT, 30=>8-BIT)		;006
;-

	UUOENT	TRM,,SYNC,LOGABL	;SET TERMINAL STUFF		;013

.ENABL	LSB

	NOP
	MOV	@(R1)+,R1	;GET DDB OF JOB'S CONSOLE TERMINAL
	MOVB	5(R4),R5	;GET TERMINAL DESIRED
	BPL	20$		;IT WAS AN EXPLICIT TERMINAL NUMBER
	CMPB	R0,DDJBNO(R1)	;CONSOLE REQUESTED.  DO WE OWN IT?
	BEQ	40$		;YES, WE MAY PROCEED
BADPRM:	ERROR	BADFUO		;NOPE

20$:	CMP	R5,#CNT.KB	;WAS IT A LEGAL KB NUMBER?
	BHIS	BADPRM		;NO
	ASL	R5		;YES, TIMES 2 FOR WORD ADDRESSING
	MOV	DEV.KB(R5),R2	;GET DDB OF TARGET KEYBOARD
	CMP	R1,R2		;WAS IT REALLY THE CONSOLE KB?
	BNE	30$		;NO, IT WAS SOME OTHER KEYBOARD
	MOV	#-1,R5		;YES, SO MAKE IT EXPLICIT
30$:	MOV	R2,R1		;WE NOW HAVE THE RIGHT DDB
	CMP	R1,#FAKDDB	;Does this terminal exist?		;028
	BNE	40$		;Yes, let the call go through		;028
	ERROR	NOTAVL		;No, KB is not available		;026

GLOBAL	<CNT.KB,DEV.KB,FAKDDB>						;028

;+
; PROTECTION CHECKING IN UU.TRM IS DONE WITH TWO 2-WORD BIT MASKS
; EACH OF THE 40(8) BITS IN A MASK CORRESPONDS TO A FIRQB BYTE OFFSET.
; IF THE BIT IS ON, THE BYTE MUST BE ZERO FOR NON-PRIV'D CALLERS.
;
; THE TWO-WORD MASK AT PATCH LOCATIONS ..TRM1 AND ..TRM2 IS CHECKED
; WHEN NON-PRIV'D USER SPECIFIES JOB'S CONSOLE KEYBOARD IN THE CALL.
; THE TWO-WORD MASK AT LOCATIONS ..TRM3 AND ..TRM4 IS CHECKED WHEN
; A NON-PRIV'D USER SPECIFIES ANY OTHER KEYBOARD THAT THE JOB OWNS.
;
; ..TRM1 AND ..TRM3 ARE MASKS FOR BYTES 0-17(8) OF THE FIRQB, AND
; ..TRM2 AND ..TRM4 ARE THE MASKS FOR BYTES 20-37(8).
; FOR EXAMPLE, IF VALUE 1 IS OR'D INTO LOCATION ..TRM2, A NON-PRIV'D
; USER COULD NOT CHANGE PARITY (BYTE 20) AT THE JOB'S CONSOLE.
;
; IF NONE OF THESE WORDS ARE PATCHED, THE NON-PRIV'D USER MAY CHANGE
; ANYTHING ON JOB'S CONSOLE EXCEPT SPEEDS AND RING CHARACTERISTICS,
; AND MAY CHANGE NOTHING ON OTHER TERMINALS THAT JOB OWNS (BUT
; THE CHARACTERISTICS MAY STILL BE READ).
;
; NOTE THAT BY OR'ING VALUE 10(8) INTO ..TRM3, USER IS "NOT ALLOWED"
; TO SPECIFY FQFUN (WHICH MUST BE 16. TO INVOKE US), SO WE RETURN
; PROTECTION VIOLATION WITHOUT DIVULGING THE CHARACTERISTICS OF ANY
; RANDOM NON-CONSOLE KEYBOARD OWNED BY THE JOB.
;-

40$:	MOV	R5,-(SP)	;Save a register			;013
	MOV	(PC)+,R5	;Set the priv to check in R5		;019
	 .BPRIV	HWCFG		;Check for hardware-config privs	;013
	CALLX	CHKPR5,R4	;Go and check it			;019
	MOV	(SP)+,R5	;Restore the register			;013
	BCC	70$		;Yes, anything goes			;013
	TSTB	FQFIL(R4)	;Extended format of call?		;019
	BEQ	45$		;No					;019
	TSTB	FQPROT(R4)	;Changing input buffer quota?		;019
	BNE	NOPRIV		;Yes, doesn't have privileges		;019
45$:	CMPB	R0,DDJBNO(R1)	;NO, SO DOES JOB OWN THE TERMINAL?	;019
	BNE	NOPRIV		;NOT OURS, SO FORGET IT ALREADY
	MOV	R4,R0		;OURS, SO COPY FIRQB POINTER FOR PLAY TIME
	MOV	#100000,R3	;IF IT'S CALLER'S CONSOLE, ALLOW ANYTHING
..TRM1	==	.-2	;**PATCH** PRIVILEGE BIT MASK WORD 1
	MOV	#2!100,R2	;EXCEPT OUTPUT SPEED, INPUT SPEED, RING CHARS
..TRM2	==	.-2	;**PATCH** PRIVILEGE BIT MASK WORD 2
	TST	R5		;IS IT REALLY THE CONSOLE?
	BMI	50$		;YES, WE NOW HAVE THE RIGHT BIT MASK
	MOV	#100000,R3	;It's not the console, but allow the	;025
..TRM3	==	.-2	;**PATCH** PRIVILEGE BIT MASK WORD 3
	MOV	#2!100,R2	;same level of access as the console	;025
..TRM4	==	.-2	;**PATCH** PRIVILEGE BIT MASK WORD 4
50$:	INC	R0		;OK. POINT TO NEXT WORD IN THE FIRQB
	BIT	R0,#40-1	;HAVE WE LOOKED AT ALL OF THEM?
	BEQ	70$		;YES, NOW ON TO THE REAL WORK...
	ASHC	#-1,R2		;NOT YET.  WHAT'S THE NEXT BIT SAY?
	BCC	50$		;THIS BIT DOESN'T CARE
	TSTB	-1(R0)		;OH OH, BETTER NOT HAVE ...
	BEQ	50$		;ALL RIGHT, STILL ON THE LEVEL
NOPRIV:	ERROR	PRVIOL		;AH HA, CAUGHT RED HANDED

GLOBAL	<FIPRVM>							;010

70$:	TSTB	FQFIL(R4)	;DO WE WANT TRM EXTENDED?		;012
	BNE	TRMEXT		;Yes, do the extended form		;018
	FJMP	NRMTRM		;No, do the normal TRM call		;018

.DSABL	LSB

;+									;012
; TRMEXT - SET TERMINAL CHARACTERISTICS EXTENDED
;
;	R1 -> DDB
;	R4 -> FIRQB
;		 +4 =  REQUESTED TRM OR TRM-EXTENDED
;			<0> =  0=> TRM   1=> TRM EXTENDED
;		 +5 =  KB NUMBER (-1=>SELF)
;		 +6 = TERMINAL TYPE CODE
;	    +7->+23 = ** RESERVED **
;		+24 = Set various characteristic flags			;035
;				0 => No Change				;035
;				1 => Allow operator messages		;035
;				2 => Allow operator requests		;035
;				4 => Allow line editing			;038
;				8 => Allow command recall		;038
;			      200 => Insert edit mode (clears overstrike) ;037
;		+25 = Clear various characteristic flags		;035
;				0 => No Change				;035
;				1 => Disable operator messages		;035
;				2 => Disable operator requests		;035
;				4 => Disable line editing		;038
;				8 => Disable command recall		;038
;			      200 => Overstrike edit mode (clears insert) ;037
;		+26 = PERMANENT TERMINAL CHARACTERISTICS
;				0 => NO CHANGE
;			      200 => RETURN PERMANENT CHARACTERISTICS
;			      377 => SET PERMANENT CHARACTERISTICS
;		+27 = INPUT BUFFER QUOTA
;				0 => NO CHANGE
;			    6-255 => NEW BUFFER QUOTA
;		+30 = SET CONTROL CHARACTERS
;				0 => NO CHANGE
;				1 => SET CONTROL/C FLAG
;				2 => SET CONTROL/T FLAG
;				4 => SET CONTROL/R FLAG
;		    	       10 => SET CONTROL/X FLAG
;			       20 => SET AUTO-BAUD
;		+31 = CLR CONTROL CHARACTERS
;				0 => NO CHANGE
;				1 => CLR CONTROL/C FLAG
;				2 => CLR CONTROL/T FLAG
;				4 => CLR CONTROL/R FLAG
;		    	       10 => CLR CONTROL/X FLAG
;			       20 => CLR AUTO-BAUD
;	     <32-33>= TERMINAL CAPABILITY FLAGS TO SET	 (FULL WORD)
;				0 => NO CHANGE
;				1 => SET ANSI ESCAPE SEQUENCES
;				2 => SET ADVANCED VIDEO
;				4 => SET 132 COLUMNS FLAG
;			       10 => SET PRINTER PORT FLAG
;			       20 => SET REGIS GRAPHICS FLAG
;			       40 => SET SIXEL GRAPHICS FLAG
;			      100 => SET KATAKANA CHARACTER SET FLAG
;			      200 => SET SELECTIVELY ERASEABLE CHARACTERS
;			      400 => SET DYNAMICALLY REDEFINABLE CHAR. SET (DRCS)
;			     1000 => SET USER DEFINED KEYS FLAG
;			     2000 => SET ANSI ESCAPE SEQUENCES FLAG
;			     4000 => SET LOCAL COPY
;	     <34-35>= TERMINAL CAPABILITY FLAGS TO CLEAR (FULL WORD)
;				0 => NO CHANGE
;				1 => CLR ANSI ESCAPE SEQUENCES
;				2 => CLR ADVANCED VIDEO
;				4 => CLR 132 COLUMNS FLAG
;			       10 => CLR PRINTER PORT FLAG
;			       20 => CLR REGIS GRAPHICS FLAG
;			       40 => CLR SIXEL GRAPHICS FLAG
;			      100 => CLR KATAKANA CHARACTER SET FLAG
;			      200 => CLR SELECTIVELY ERASEABLE CHARACTERS
;			      400 => CLR DYNAMICALLY REDEFINABLE CHAR. SET (DRCS)
;			     1000 => CLR USER DEFINED KEYS FLAG
;			     2000 => CLR ANSI ESCAPE SEQUENCES FLAG
;			     4000 => CLR LOCAL COPY
;
;	ON RETURN FIRQB FORMAT IS AS FOLLOWS:
;		     
;		+6  = RETURNS TERMINAL TYPE CODE
;		+24 = Returns current line editing/operator chars	;035
;		+30 = RETURNS CURRENT CONTROL FUNCTIONS
;	     <32-33>= RETURNS CURRENT TERMINAL CAPABILITY FLAG STATUS
;
;-									;012
.ENABL	LSB

TRMEXT: NOP			;ODT BPT ENTRY				;012
	BIT	#<3*400>+3,FQFLAG(R4) ; Mucking with operator bits?	;036
	BEQ	5$		;Nope, no need to worry			;036
	MOV	(PC)+,R5	;Set the priv to check in R5		;036
	 .BPRIV	OPER		;Check for operator priv		;036
	CALLX	CHKPR5,R4	;Go and check it			;036
	BCS	NOPRIV		;Doesn't have it, sorry charlie		;037
5$:	MAP	TERAP6,APR=6,CODE,DATA,PIC ;Map the terminal driver	;028
	;
	; Buffer quota, stored as buff count (BC) in TTINPT
	;
	CLR	R3		;Assure the high byte is clear		;021
	BISB	FQPROT(R4),R3	;Get the new buffer quota		;021
	BEQ	8$		;None					;019
	CMPB	R3,#1		;Legal value (1-255)?			;044
	BLO	BADPRM		;No, go return error			;019
	SPLC	5		;Disable terminal interrupts		;019
	CALL	100$		;;Get the number of buffers allocated	;019
	SUB	R0,R3		;;Adjust the new quota accordingly	;019
	MOV	R3,TTINPT+BC(R1) ;;Set the new quota			;019
	SPLC	3		;;Enable terminal interrupts		;019
	;
	; TCHAR2
	;
8$:	BISB	FQFLAG(R4),TCHAR2(R1) ;Set requested char flags		;035
	BICB	FQFLAG+1(R4),TCHAR2(R1) ;Clear requested char flags 	;035
	ASLB	TTFLG3(R1)	;;Set up to copy bit 15			;040
.ASSUME	TTEMOD	EQ 200		;;					;037
	MOVB	TCHAR2(R1),R0	;;Get terminal characteristic byte	;037
	ASLB	R0		;;Set C bit if TTIEDT bit set		;037
.ASSUME	TTIEDT	EQ 200		;;					;037
	RORB	TTFLG3(R1)	;;Set TTEMOD if bit 15 set in TCHAR2	;040
	;
	; TTTYPE
	;
	TSTB	FQPPN(R4) 	;CHANGING TERMINAL TYPE?		;019
	BEQ	10$		;NOPE					;012
	MOVB	FQPPN(R4),TTTYPE(R1) ;YES, STORE REQUESTED TERM TYPE	;012
	;
	; TTCAPB
	;
10$:	BIC	#^C<17777>,FQDEVN(R4) ;PROTECT AUTO-BAUD TIMING BITS	;016
	BIC	#^C<17777>,FQCLUS(R4) ;PROTECT AUTO-BAUD TIMING BITS	;016
	BIS	FQDEVN(R4),TTCAPB(R1) ;SET REQUESTED CAPABILITY FLAGS	;012
	BIC	FQCLUS(R4),TTCAPB(R1) ;CLR REQUESTED CAPABILITY FLAGS 	;012
	;
	; TTFCNT (and TTAUTO in TTCTRL)
	;
30$:	BITB	#TTAUTO,FQDEV(R4) ;SETTING AUTO-BAUD?			;012
	BNE	40$		;YES					;012
	BITB	#TTAUTO,FQDEV+1(R4) ;HOW ABOUT CLRING AUTO-BAUD?	;012
	BEQ	50$		;NOPE					;012
40$:	BICB	#TTLOW!TTVERF,TTFCNT(R1) ;CLR AUTO-BAUD STATE FLAGS 	;012
	BICB	#TTAUTO,TTCTRL(R1) ;CLR AUTO-BAUD			;012
	BITB	#TTAUTO,FQDEV(R4) ;IS IT A SET AUTO-BAUD?		;012
	BEQ	50$		;NOPE					;012
	BIT	#TTMUX,TTINTF(R1) ;IS THIS A MUX LINE?			;016
	BEQ	50$		;NOPE, SO DON'T DO ANYTHING		;016
	CMPB	#TTDJ11,TTINTF(R1) ;IS THIS A DJ11 LINE?		;016
	BEQ	50$		;YES, WE DON'T AUTO-BAUD DJ11'S		;016
	BISB	#TTAUTO,TTCTRL(R1) ;NO, SO SET AUTO-BAUD		;012
	MOVB	DDUNT(R1),R0	;GET THE KEYBOARD NUMBER		;012
	ASL	R0		;MAKE IT TIMES 2			;012
	CLR	R3		;DEFAULT AUTO-BAUD SPEED=9600		;012
	MOV	R4,-(SP)	;SAVE FIRQB POINTER			;015
	SPLC	5		;TO LEVEL 5 FOR SAFETY			;012
	CALLM	AUTOSP,KINAP5	;;AND SET THE SPEED			;028
	SPLC	3		;;AND BACK DOWN AGAIN			;012
	MOV	(SP)+,R4	;RESTORE FIRQB POINTER			;012
	;
	; TTCTRL
	;
50$:	MOV	FQDEV(R4),R0	;Get control bits			;037
	BIC	#^C<17*400+17>,R0 ;Mask off unnecessary bits		;037
				;(auto-baud should already be set)	;037
	BISB	R0,TTCTRL(R1) 	;Set requested control functions	;037
	SWAB	R0		;Get bits to clear			;037
	BICB	R0,TTCTRL(R1) 	;Clear requested control functions	;037
	;
	; Return current settings
	;
	MOVB	TCHAR2(R1),FQFLAG(R4);Return the current char flags	;035
	MOVB	TTTYPE(R1),FQPPN(R4) ;RETURN THE CURRENT TERMINAL TYPE	;012
	MOVB	TTCTRL(R1),FQDEV(R4) ;RETURN CONTROL FUNCTIONS		;012
	MOV	TTCAPB(R1),FQDEVN(R4) ;RETURN CURRENT CAPABILITY SETTINGS ;012
	SPLC	5		;Disable terminal interrupts		;019
	CALL	100$		;;Get the number of buffers allocated	;019
	MOV	TTINPT+BC(R1),R2 ;;Get the buffer quota			;019
	ADD	R0,R2		;;Add in the allocated amount		;019
	MOVB	R2,FQPROT(R4)	;;Return the quota			;019
	SPLC	3		;;Enable terminal interrupts		;019
	MAP	FIP,CODE,DATA	;Restore FIP mapping			;028
	TSTB	FQPFLG(R4)	;REQUESTING CHANGE TO PERMANENT CHARS.? ;012
	BEQ	120$		;NOPE					;037
	FJMP	RQSPRM		;OFF TO PERMANENT CHARS. LAND...	;012

    
100$:	CLR	R0		;;Start with zero buffers allocated	;019
	MOV	TTINPT+EP(R1),R2 ;;Get the initial buffer ->		;020
	BEQ	120$		;;None, simply return			;019
110$:	CMPB	(R0)+,-(R2)	;;Increment the count by one (R0=count)	;020
				;; and decrement the buffer -> by one.	;020
				;; It's possible for the initial -> to	;020
				;;  point at the 1st word of the next	;020
				;;  sequential buffer in the buffer	;020
				;;  pool. Which could be anything!	;020
	BIC	#40-1,R2	;;Back to the top of our buffer		;020
	MOV	(R2),R2		;;Get the link to the next buffer	;019
	BNE	110$		;;Have one, bump the count		;019
120$:	RETURN			;;Return to our caller			;019
    
GLOBAL	<TERAP6>							;028

.DSABL	LSB

FQFEND

FQFSRT          
	;+
	; NRMTRM - Normal form of the TRM call
	;
	;	R1 -> DDB
	;	R4 -> FIRQB
	;-

NRMTRM:	NOP								;018
	MAP	TERAP6,APR=6,CODE,DATA,PIC ;Map the class driver	;028
	BITB	#TTAUTO,TTCTRL(R1);Auto-Baud set?			;021
	BEQ	10$		;No, then no problems with speed changes ;021
	TSTB	FQSIZ+1(R4)	;Changing speeds?			;021
	BEQ	10$		;No, all's well then			;021
	CMPB	#377,FQPFLG(R4)	;Set permanent call?			;021
	BEQ	50$		;Yes, that's not allowed		;021
	TSTB	DDJBNO(R1)	;Terminal owned?			;021
	BEQ	50$		;No, that's not allowed			;021
10$:	ADD	#16-0,R4	;POINT TO FILL BYTE AT FIRQB+16		;018
	MOVB	(R4)+,R0	;GET FILL BYTE
	BEQ	100$		;NO FILL CHANGE
	BPL	80$		;NORMAL (NON-LA30 SERIAL) FILL
	MOV	#TTLA30,R0	;SERIAL LA30 TYPE FILL
	BR	90$		;SO SET IT
                                                                            
50$:	ERROR	PRVIOL		;Privilege violation			;021

80$:	DEC	R0		;CORRECT FOR PROPER FILL COUNT
	BIC	#^C<TTFILL>,R0	;CLEAR OUT JUNK BITS
90$:	BICB	#TTLA30!TTFILL,TTFCNT(R1) ;CLEAR OUT OLD FILL STUFF	;006
	BISB	R0,TTFCNT(R1)	;SET THE NEW FILL COUNT, ETC.		;006
100$:	MOVB	30-17(R4),R2	;GET NEW PRIVATE DELIMITER
	BEQ	110$		;DON'T CHANGE IT
	BIC	#^C<177>,R2	;TRIM TO 7 BITS				;006
	MOVB	R2,TTPDLM(R1)	;SET THE NEW DELIMETER
110$:	ADD	#TTCHAR,R1	;INDEX TO CHARACTERISTICS IN TERMINAL DDB
	MOVB	20-17(R4),R0	;GET PARITY SELECTION                       
	BITB	#20,R0		;GET 7/8 BIT FLAG			;005
	BEQ	115$		;NO CHANGE				;005
	BICB	#TT8BIT,TTFCNT-TTCHAR(R1) ;ASSUME 7-BIT			;006
	BITB	#10,R0		;DO WE REALLY WANT 7-BIT?		;005
	BEQ	115$		;YES, WE DO				;005
	BISB	#TT8BIT,TTFCNT-TTCHAR(R1) ;NO, SO SET 8-BIT		;006
115$:	BIC	#^C<3>,R0	;TRIM PARITY TO NO(1), EVEN(2), ODD(3)	;006
	BEQ	150$		;NOTHING, LEAVE IT ALONE
	MOV	R0,R2		;SOMETHING, SAVE THE PARITY SETTING
	BIC	#TTPRTY!TTPODD,(R1) ;NO PARITY AT FIRST
	SUB	#3,R0		;Make it NO(-2), EVEN(-1), ODD(0)	;019
	ASL	R0		;Times two				;019
	ASL	R0		; times four				;019
	SUB	R0,PC		;Point to the correct parity setting	;019
	BIS	#TTPODD,(R1)	;Set odd parity				;019
	BIS	#TTPRTY,(R1)	;Set even parity			;019
	TSTB	(R4)		;WILL WE SETTING A NEW SPEED ALSO?
	BNE	150$		;YES, PARITY CHANGE IS CAUGHT IN SPEED CHANGE
	MOV	#40,R0		;NO, SET DH11'S ODD PARITY BIT
	MOV	#1,R5		; AND DH11'S CHARACTER LENGTH CHANGE AMOUNT
	CMPB	TTINTF-TTCHAR(R1),#TTDH11 ;REALLY A DH11 LINE?
	BEQ	130$		;YEP
	MOV	#200,R0		;NOPE, SET DZ11'S ODD PARITY BIT
	MOV	#10,R5		; AND DZ11'S CHARACTER LENGTH CHANGE AMOUNT
	CMPB	TTINTF-TTCHAR(R1),#TTDZ11 ;REALLY A DZ11 LINE?
	BEQ	130$		;YES					;009
	MOV	#100,R0		;NOPE SET DHV11'S EVEN PARITY BIT	;009
	MOV	#10,R5		; AND DHV11'S CHARACTER LENGTH CHANGE AMOUNT ;009
	CMPB	TTINTF-TTCHAR(R1),#TTVH11 ;REALLY A DHV11 LINE?		;009
	BNE	150$		;NOPE, NO HARDWARE PARITY THEN...	;009
	MOV	#<TTPODD/400>,R3 ;GET THE ODD PARITY FLAG BIT		;017
	XOR	R3,R2		;CHANGE 2 TO 3 AND 3 TO 2		;009
				;CAUSE THE DHV EVEN IS ON AND ODD IF OFF;009
130$:	BITB	#TT8BIT,TTFCNT-TTCHAR(R1) ;8-BIT TERMINAL?		;006
	BNE	133$		;YES, NO DATA FRAME SIZE CHANGES	;006
	BITB	20-17(R4),#4	;DATA FRAME SIZE CHANGE INHIBIT?	;006
	BEQ	135$		;NO, SO ALLOW DATA FRAME TO CHANGE	;006
133$:	CLR	R5		;CLEAR DATA FRAME SIZE INCREMENT	;006
135$:	MOV	TTPARM-TTCHAR(R1),R3 ;GET CURRENT LINE PARAMETER WORD	;005
	BIC	R0,R3		;REMOVE ODD PARITY BIT ALWAYS
	ASR	R0		;NOW WE HAVE THE PARITY ENABLE BIT
	BIT	R3,R0		;WAS PARITY ENABLED?
	BEQ	140$		;NO
	BIC	R0,R3		;YES, SO DISABLE PARITY
	ADD	R5,R3		; AND INCREMENT THE CHARACTER LENGTH
140$:	DEC	R2		;DESIRE NO PARITY (CODE=1)?
	BLE	260$		;YES, GO SET NO PARITY			;017
	BIS	R0,R3		;NO, SO ENABLE PARITY
	SUB	R5,R3		; AND DECREMENT THE CHARACTER LENGTH
	DEC	R2		;IS DESIRED PARITY EVEN (CODE=2)?
	BEQ	260$		;YES, EVEN PARITY DESIRED, GO SET EVEN PARITY
	ASL	R0		;NO, ODD PARITY DESIRED, FORM ODD PARITY BIT
	BIS	R0,R3		; AND SET ODD PARITY
	BR	260$		;  THEN GO SET ODD PARITY

       
150$:	MOVB	(R4),R0		;GET THE NEW RECEIVE SPEED		;009
	BEQ	270$		;NO NEW SPEED				;006
	CLRB	(R4)		;CLEAR FOR REPORTING LATER		;006
	MOVB	21-17(R4),R3	;GET INPUT SPEED
160$:	MOV	#4!3,R2		;SET DH11 DEFAULT EXTRA BITS
	CMP	R0,#3+1		;IS NEW OUTPUT SPEED >110 BAUD?
	BLOS	170$		;NO SPEED <=110 BAUD, LEAVE 2 STOP BITS
	ASR	R2		;SPEED > 110 BAUD, ONLY 1 STOP BIT
.ASSUME	4!3/2	EQ	3
170$:	MOV	(R1),R5		;GET THE PARITY BIT(S)
	ASH	#7,R5		;SHIFT FOR C=TTPRTY, N=TTPODD
.ASSUME	TTPRTY*200 EQ	0
.ASSUME	TTPODD*200 EQ	100000
	BCC	190$		;NO PARITY (TTPRTY=0)
	BPL	180$		;EVEN PARITY (TTPRTY=1; TTPODD=0)
	ADD	#40,R2		;ODD PARITY, SO SET THE ODD PARITY BIT
180$:	ADD	#20,R2		;TURN ON PARITY ENABLE			;006
	BITB	#TT8BIT,TTFCNT-TTCHAR(R1) ;8-BIT TERMINAL?		;006
	BNE	190$		;YES, KEEP DATA FRAME AS 8 BITS		;006
	DEC	R2		;NO, SET DATA FRAME TO 7 BITS		;006
190$:	MOVB	25-17(R4),R5	;SPECIAL PARAMETERS?
	BEQ	200$		;NOPE
	MOV	R5,R2		;YEP, SO GET THEM
	BIC	#^C<67>,R2	;CLEAR ANY JUNK BIT(S)
200$:	TST	R3		;INPUT SPEED?
	BEQ	210$		;NONE SPECIFIED, USE SAME INPUT AND OUTPUT
	BPL	220$		;SEPARATE INPUT SPEED WAS SPECIFIED
210$:	MOV	R0,R3		;USE OUTPUT SPEED FOR INPUT
220$:	DEC	R0		;MAKE SPEED IN 0-N RANGE
	DEC	R3		;INPUT SPEED ALSO
	BIC	#^C<17>,R0	;MAKE SPEED 0. TO 15.
	BIC	#^C<17>,R3	;INPUT SPEED TOO
	ASH	#6+4,R0		;PUT OUTPUT SPEED HERE (BITS <13-10>)
	ADD	R0,R2		;ADD IN THE OUTPUT SPEED
	ASH	#6,R3		;PUT INPUT SPEED HERE (BITS <9-6>)
	ADD	R2,R3		;ADD IT IN ALSO

; WE NOW HAVE THE FOLLOWING ALL BUILT UP...
;
;	R0 = OUTPUT SPEED CODE * 2000 (0<=SPEED<=17)
;	R2 = 010461 IF 2741; SOMETHING ELSE IF NOT
;	R3 = DH11 PARAMETER WORD AS FOLLOWS:
;
;		<1-0>	DATA FRAME LENGTH (0=>5, 1=>6, 2=>7, 3=>8.)
;		<2>	STOP BIT (0=>1, 1=>2)
;		<3>	0
;		<4>	PARITY ENABLE (0=>NO PARITY, 1=>PARITY)
;		<5>	ODD PARITY (0=>EVEN PARITY, 1=>ODD PARITY)
;		<9-6>	INPUT SPEED CODE * 100 (0<=SPEED<=17)
;		<13-10>	OUTPUT SPEED CODE * 2000 (0<=SPEED<=17)
;		<15-14>	0

	MAP	FIP,CODE,DATA,PIC ;Be sure that FIP is mapped		;028
	MOV	R1,R5		;COPY DDB POINTER @ TTCHAR
	TST	(R5)+		; INDEX TO @ TTINTF
.ASSUME	TTINTF	EQ	TTCHAR+2
	CMPB	(R5),#TTDH11	;DH11?
	BEQ	260$		;YES, ALL O.K., JUST SET IT
240$:	CMPB	(R5)+,#TTDZ11	;DZ11?					;006
	BNE	250$		;NOPE					;009
	FCALL	SPEEDZ		;YES, CORRECT PARAMETER FOR DZ11'S	;006
	BR	260$		;AND SET IT				;009

250$:	CMPB	-(R5),#TTVH11	;DHV11?					;009
	BNE	270$		;NO, NO SPEED CHANGE POSSIBLE		;009
	FCALL	SPEEDV		;YES, SO CORRECT PARAMETER FOR DHV11'S	;009
260$:	SUB	#TTCHAR,R1	;BACK TO TOP OF THE TERMINAL DDB	;028
	MAP	FIP,CODE,DATA,PIC ;Be sure that FIP is mapped		;028
	FJMP	MORTRM		;AND ON TO MORE...

270$:	MOV	TTPARM-TTCHAR(R1),R3 ;Get current parameter word	;028
	BR	260$		;And join up				;028

FQFEND

FQFSRT

; OUR HANDY INDEX REGISTERS SHOULD NOW READ AS FOLLOWS:
;
;	R1 -> BASE OF TERMINAL DDB
;	R3 =  New parameter word
;	R4 -> FIRQB+17
;
; OUR NEXT ORDER OF BUSINESS IS TO STEP THROUGH THE TABLE THAT MAPS
; OFFSETS IN THE FIRQB TO BITS IN THE TERMINAL'S DDB.  FOR EACH
; TABLE ENTRY WE WILL FIRST SET/CLEAR THE BIT IN THE DDB IF THE
; FIRQB ARGUMENT INDICATES THAT WE SHOULD, AND THEN MARK THE FIRQB
; LOCATION TO INDICATE WHETHER THE DDB BIT WAS SET OR CLEARED.

MORTRM: NOP
	MOV	R3,TTPARM(R1) 	;SET PARAMETER VALUE			;028
	MAP	@#KISAR5,APR=5,DATA,PIC ;Map the table			;019
	MOVPIC	#180$,R2	;GET PIC TABLE ADDRESS	
10$:	MOVB	(R2)+,R0	;GET DELTA INDEX INTO FIRQB
	BNE	20$		;IT'S A NEW OFFSET
	MOVB	R5,(R4)		;SAME OFFSET, SO USE LAST PARAMETER
20$:	ADD	R0,R4		; AND POINT TO NEW FIRQB OFFSET
	MOVB	(R4),R5		;REMEMBER THIS PARAMETER
	MOVB	(R2)+,R3	;GET THE BIT PATTERN
	BEQ	60$		;OOPS, WE'RE DONE
	MOV	(PC)+,-(SP)	;PRESET THE VALUE TO RETURN IN FIRQB
	 .BYTE	-1,200		; ASSUME FOR NOW: -1 IF BIT ON; 200 IF BIT OFF
	MOVB	(R2)+,R0	;NOW SNAG THE DDB OFFSET.
	BPL	30$		;OUR ASSUMPTION WAS GOOD
	SWAB	(SP)		;NO, RETURN: 200 IF BIT ON; -1 IF BIT OFF
	NEG	R0		;AND FIND THE REAL DDB OFFSET
30$:	ADD	R1,R0		;OK. NOW INDEX INTO THE DDB
	TSTB	(R4)		;ANY CHANGE HERE?
	BPL	40$		;NOPE
	BICB	R3,(R0)		;YES, ASSUME CLEAR OF BIT(S)
	CMPB	(R4),(SP)	;WAS OUR ASSUMPTION GOOD?
	BNE	40$		;YES
	BISB	R3,(R0)		;NO, SET THE BIT(S) INSTEAD
40$:	BITB	R3,(R0)		;WHAT SHALL WE RETURN TO THE USER?
	BNE	50$		;THE BIT WAS ON; USE PLAN A
	SWAB	(SP)		;AREN'T WE GLAD WE HAD PLAN B
50$:	MOVB	(SP)+,(R4)	;SET THE CORRECT CALLING ARGUMENT
	BR	10$		; AND LOOP...

60$:	CLR	R3		;Prepare to get width+1			;043
	BISB	(R4),R3		;Get new width+1			;043
	CMPB	R3,#1		;IS NEW WIDTH+1 0 OR 1?
	BLOS	80$		;YES, LEAVE WIDTH ALONE THEN
	CLR	R0		;Prepare to get current width+1		;043
	BISB	DDHORC(R1),R0	;Get current width+1			;043
	SUB	R3,R0		;CALCULATE WIDTH CHANGE
	SPLC	5		;Lock out terminal interrupts
	MOVB	R3,DDHORC(R1)	;;WE CAN PUT IN NEW WIDTH+1 NOW.
	CLR	R3		;;Prepare to get horizonal position	;043
	BISB	DDHORZ(R1),R3	;;Get DDHORZ (countdown) position	;043
	SUB	R0,R3		;;CORRECT DDHORZ FOR NEW WIDTH
	BPL	70$		;;STILL HAVEN'T GOTTEN TO END OF LINE
	CLR	R3		;;WHOOPS! WE'RE NOW AT END OF LINE
70$:	MOVB	R3,DDHORZ(R1)	;;RETURN CORRECTED HORZ POSITION TO DDB
	CLR	R3		;;Prepare to get prompt position	;043
	BISB	PMTPOS(R1),R3	;;Get prompt position			;043
	BEQ	75$		;;Not set up, nothing to adjust		;043
	SUB	R0,R3		;;Correct PMTPOS for new width		;043
	BPL	73$		;;Still within reasonable bounds	;043
	MOVB	DDHORC(R1),R3	;;Set prompt pos to left margin		;043
73$:	MOVB	R3,PMTPOS(R1)	;;Adjust prompt position		;043
75$:	SPLC	3		;;And enable interrupts			;043
80$:	MOVB	DDUNT(R1),R0	;GET THE KB NUMBER			;028
	ASL	R0		;TIMES 2 				;028
	MOV	R4,-(SP)	;Save FIRQB pointer			;028
	MAP	TERAP6,APR=6,CODE,DATA,PIC ;Map the terminal driver	;028
	SPLC	5		;;LOCK OUT TERMINAL INTERRUPTS
	CALLX	SETPRM		;;ENSURE PARAMETERS ARE CORRECTLY SET	;028
	SPLC	3		;;TERMINAL INTERRUPTS OK AGAIN
	MAP	FIP,CODE,DATA	;Restore FIP mapping 			;028
	MOV	(SP)+,R4	;Restore FIRQB pointer			;028
	TSTB	26-6(R4)	;REQUESTING CHANGE TO PERMANENT CHARS.? ;012
	BEQ	90$		;NO					;007
	SUB	#6,R4		;YES, WE WANT TO BE @FIRQB+0		;012
	CMPB	#200,FQPFLG(R4)	;IS THIS A SHOW PERMANENT CHARS.?	;015
	BNE	85$		;NO, IT'S A SET, SO DON'T JMP!		;015
	FJMP	RQSPRM		;YES, OFF TO PERMANENT CHARS. LAND	;015

85$:	FCALL	RQSPRM		;SET PERMANENT CHARS. (AND COME BACK!)	;015
	ADD	#6,R4		;AND NOW BACK UP TO FIRQB+6		;015
90$:	CLRB	21-6(R4)	;CLEAR FOR REPORTING LATER
	CLRB	25-6(R4)	;CLEAR FOR REPORTING LATER
	MOVB	DDHORC(R1),(R4)	;SET TERMINAL WIDTH+1 @ FIRQB+6
	MOVB	#20,36-6(R4)	;ASSUME 7-BIT (20)			;006
	BITB	#TT8BIT,TTFCNT(R1) ;DO WE WANT 7-BIT?			;005
	BEQ	95$		;YES WE DO				;005
	MOVB	#20!10,36-6(R4)	;ELSE, SET FOR 8-BIT (30)		;006
95$:	ADD	#16-6,R4	;NOW POINT TO FILL FACTOR IN FIRQB	;005
	MOVB	#-1,(R4)+	;GUESS AT SERIAL LA30 FILL (@ FIRQB+16)
	MOVB	TTFCNT(R1),R0	;GET THE REAL FILL CHARACTERISTICS
	BMI	100$		;SERIAL LA30 FILL IT IS
.ASSUME	TTLA30	EQ	200
	BIC	#^C<TTFILL>,R0	;ELSE TRIM TO ONLY FILL COUNT
	INC	R0		; THEN MAKE THAT FILL COUNT +1
	MOVB	R0,-1(R4)	;  AND SET FILL COUNT +1 @ FIRQB+16
100$:	MOV	#1,R0		;GUESS AT PARITY SETTING OF "NO PARITY"
	BIT	#TTPRTY,TTCHAR(R1) ;GOOD GUESS?
	BEQ	110$		;YES, LEAVE CODE=1
	INC	R0		;NO, SET CODE=2 (EVEN PARITY)
	BIT	#TTPODD,TTCHAR(R1) ;IS EVEN PARITY A GOOD GUESS??
	BEQ	110$		;YES, LEAVE CODE=2
	INC	R0		;NO, ODD PARITY, SET CODE=3
110$:	MOVB	R0,20-17(R4)	;SET PARITY SETTING @ FIRQB+20
	MOVB	TTPDLM(R1),R0	;GET THE PRIVATE DELIMITER
	BIS	#200,R0		; AND FORCE ON THE PARITY BIT
	MOVB	R0,30-17(R4)	;  THEN SET THAT @ FIRQB+30
	BITB	#TTAUTO,TTCTRL(R1) ;Auto-baud?				;019
	BEQ	115$		;No					;019
	TSTB	DDJBNO(R1)	;Is the device owned?			;019
	BNE	115$		;Yes					;019
	MOVB	#-1,(R4)	;No, return -1 for speed setting	;019
	BR	160$		;Now go return it			;019

115$:	MOV	TTPARM(R1),R3	;Get line parameters			;028
	MOV	#-6.,R0		;SHIFT FOR DH11 INPUT SPEED (<9-6>)
	MOV	#-10.+6.,R2	;NEXT SHIFT FOR DH11 OUTPUT SPEED (<13-10>)
	MOV	#^C<17>,R5	;SPEED ISOLATION MASK FOR DH11 (4 BITS)
	CMPB	TTINTF(R1),#TTDH11 ;REALLY A DH11 LINE?
	BEQ	120$		;YEP
	MOV	#-8.,R0		;SHIFT FOR DZ11 INPUT SPEED (<11-8>)
	CLR	R2		;NEXT SHIFT FOR DZ11 OUTPUT SPEED (<11-8>)
	;MOV	#^C<17>,R5	;SPEED ISOLATION MASK FOR DZ11 (4 BITS)
	CMPB	TTINTF(R1),#TTDZ11 ;REALLY A DZ11 LINE?			;009
	BEQ	120$		;YES					;009
	;MOV	#-8.,R0		;SHIFT FOR DHV11 INPUT SPEED (<11-8>)	;009
	MOV	#-12.+8.,R2	;NEXT SHIFT FOR DHV11 OUTPUT SPEED (<15-12>) ;009
	;MOV	#^C<17>,R5	;SPEED ISOLATION MASK FOR DHV11 (4 BITS) ;009
	CMPB	TTINTF(R1),#TTVH11 ;REALLY A DHV11 LINE?		;009
	BNE	160$		;NOPE, SO SPEED NOT SETTABLE		;009
120$:	ASH	R0,R3		;MOVE INPUT SPEED TO <3-0>	
	MOV	R3,R0		;NOW SAVE INPUT SPEED
	BIC	R5,R0		; TRIMMING IT TO A LEGAL VALUE
	ASH	R2,R3		;MOVE OUTPUT SPEED TO <3-0>
	BIC	R5,R3		; TRIMMING IT TO A LEGAL VALUE
	CMPB	TTINTF(R1),#TTDZ11 ;WAS THIS A DZ11 LINE??
	BNE	130$		;NOPE
	BIT	#010000,TTPARM(R1) ;YEP, WAS RECEIVER CLOCK ACTIVE?
	BEQ	130$		;NOT ACTIVE, LEAVE A CODE OF ZERO
	CMPB	(R0)+,(R3)+	;ACTIVE, DO EXTRA +1 IN SPEED CODES
130$:	CMP	R3,R0		;DOES OUTPUT SPEED = INPUT SPEED ?
	BEQ	140$		;YES, LEAVE FIRQB+21 = 0
	INC	R0		;NO, SET INPUT SPEED CODE +1
	MOVB	R0,21-17(R4)	; AT FIRQB+21
140$:	INC	R3		;SET OUTPUT SPEED CODE +1
	MOVB	R3,(R4)		; AT FIRQB+17
160$:	MOVB	TTINTF(R1),24-17(R4) ;ALSO RETURN INTERFACE TYPE @ +24
	MOVB	DDJBNO(R1),4-17(R4) ;RETURN OWNER OF KB @ +4.
	TST	MODCLK(R1)	;Is line answered now?
	BPL	170$		;NO, RETURN
.ASSUME	TTDSBL	EQ	100000
	BIS	#200,4-17(R4)	;YES. FLAG AS SUCH @ +4.
170$:	RETURN			;NOW WE CAN FINALLY EXIT...		;028

GLOBAL	<TERAP6>

;
; THE TRMTBL MACRO IS USED TO GENERATE THE TABLE THAT MAPS
; PARAMETERS IN THE USER'S FIRQB TO BITS IN THE KEYBOARD DDB.
; TABLE ENTRIES ARE DEFINED WITH:
;
;	TRMTBL	FQOFF,BIT,S,DDBWRD
;
;	WHERE:	FQOFF	USER FIRQB OFFSET OF FLAG BYTE
;		BIT	BIT SET OR CLEARED IN DDB+DDBWRD
;		S	0 => BIT CLEARED <==> 255. IN FIRQB
;			1 => BIT SET <==> 255. IN FIRQB
;		DDBWRD	WORD OF DDB IN WHICH BIT IS SET/CLEARED
;
; THE TRMTBL MACRO GENERATES THE FOLLOWING TABLE ENTRY:
;
;	.BYTE	FIRQB DELTA INDEX CHANGE SINCE LAST ENTRY
;	.BYTE	BIT THAT IS SET/CLEARED IN BYTE IN DDB
;	.BYTE	DDB OFFSET OF BYTE (<0 => REVERSE SENSE)
;
; PROGRAMMING NOTES:
; 1.	THE .IIF IN THE TRMTBL MACRO IS A DUMMY.  IT IS USED
;	SO THAT THE ARGUMENTS TO THE MACRO WILL BE CREF'D.
; 2.	IF MORE THAN ONE BIT IS TO BE SET/CLEARED BY THE
;	SAME FIRQB ENTRY, THE FOLLOWING SHOULD BE NOTED:
;	A.  ALL ENTRIES FOR THE SAME FIRQB OFFSET MUST BE
;	    CONSECUTIVE IN THE TABLE.
;	B.  THE VALUE RETURNED IN THE FIRQB REFLECTS ONLY
;	    THE STATE OF THE DDB BIT(S) DESCRIBED IN THE
;	    LAST TABLE ENTRY FOR THAT FIRQB OFFSET.
;
.MACRO	TRMTBL	FQOFF,BIT,S,DDBWRD

.IIF	NE	FQOFF!BIT!S!DDBWRD

.DSABL	CRF

	$$$$$1	=	BIT
	$$$$$2	=	DDBWRD

.IF	NE	BIT&^C<377>
	$$$$$1	=	BIT/400
	$$$$$2	=	DDBWRD+1
.ENDC

.NLIST	SRC

	.BYTE	FQOFF-$$$$$$,$$$$$1,<S*2-1>*$$$$$2

.LIST	SRC

	$$$$$$	=	FQOFF

.ENABL	CRF

.ENDM

;
; TABLE FOR MAPPING FIRQB PARAMETERS TO BITS IN THE DDB
;
180$:	$$$$$$	=	17		;WE START OUT AT FIRQB+17	
	TRMTBL	07,TTTAB ,0,TTCHAR	;SET NO TAB
	TRMTBL	10,TTFORM,1,TTCHAR	;SET FORM
	TRMTBL	11,TTLCOU,0,TTCHAR	;SET NO LC OUTPUT
	TRMTBL	12,TTXON ,1,TTCHAR	;SET XON
	TRMTBL	13,LCLCPY,1,TTCAPB	;SET LOCAL ECHO			;012
	TRMTBL	14,TTSYNC,1,TTCHAR	; (PLEASE SET STALL WITH SCOPE)
	TRMTBL	14,TTSCOP,1,TTCHAR	;SET SCOPE
	TRMTBL	15,TTESC ,1,TTCHAR	; (PLEASE SET ESC WITH LC INPUT)
	TRMTBL	15,TTLCIN,1,TTCHAR	;SET LC INPUT
	TRMTBL	22,TTSYNC,1,TTCHAR	;SET STALL
	TRMTBL	23,TTUPAR,0,TTCHAR	;SET NO UPARROW
	TRMTBL	27,TTESCI,1,TTCHAR	;SET ESC SEQ
	TRMTBL	31,TTESC ,1,TTCHAR	;SET ESC
	TRMTBL	32,TTCTRT,1,TTCTRL	; (PLEASE SET CTRL/T WITH CTRL/R) ;012
	TRMTBL	32,TTCTRR,1,TTCTRL	;SET CTRL/R			;012
	TRMTBL	33,TTXANY,1,TTCHAR	;SET RESUME ANY
	TRMTBL	34,TTBRK ,0,TTCHAR	;SET NO BREAK
	TRMTBL	35,TTGAG ,1,TTCHAR	;SET GAG
	.BYTE	6-$$$$$$		;WE WANT TO END UP AT FIRQB+6
	.BYTE	0			;END OF TABLE
;
; NOTE: PATCHES APPLIED TO THIS OVERLAY (IF THERE'S ANY ROOM)
; SHOULD BE STARTED FROM THE END OF THE OVERLAY TO ALLOW
; FOR POSSIBLE PATCHING IN OF ADDITIONS TO THE ABOVE TABLE.
;
FQFEND

FQFSRT
                                                                       
.SBTTL	HANGUP/ENABLE A DATASET, DISABLE TERMINAL, FORMAT DC11/DZ11 SPEEDS

;+
; DISABLE A TERMINAL.
;
;	R0 =  KEYBOARD NUMBER
;
; We get to this code from the UU.CHU function in FSS. In order to	;042
; disable the device we jump to the new style disable routine in the	;042
; CFG module. Note however that the TRM module can be made resident 	;042
; and is synchronous.	The CFG module on the other hand is never	;042
; resident and is asynchronous. Normally, we would crash when		;042
; attempting to jump to the CFG routine because synchronous functions	;042
; run on the system stack and there's an explicit check in CTL to make	;042
; sure you don't try to execute an asynchronous function when your on	;042
; the system stack. However, because we came from the UU.CHU overlay,	;042
; which is an asynchronous function, we are actually using FIP's stack	;042
; when we enter this code and therefore it all works. At some point	;042
; this code should be moved to the UU.CHU overlay to eliminate this	;042
; confusion.								;042
;-                                                                      

.ENABL	LSB                                                             
                
10$:	CMP	R0,#CNT.KB	;LEGAL?
	BHIS	20$		;NOPE
	ASL	R0		;NOW MAKE KB NUMBER TIMES 2
	MOV	DEV.KB(R0),R1	;Get the keyboard DDB			;028
 	CMP	R1,#FAKDDB	;Does keyboard exist?			;028
	BEQ	20$		;No, give an error			;028
	MOV	#CFGJOB,R0	;Set to disable the device		;028
	FJMP	DSBLDV		;Off to CFG to finish the disable	;041

20$:	ERROR	BADFUO		;ILLEGAL KEYBOARD NUMBER

GLOBAL	<DEV.KB,FAKDDB,DSBLDV>						;041

;+
; UU.HNG - HANGUP/ENABLE A DATASET.                                     
;
;	R0 =  Job number * 2						;011
;	R4 -> FIRQB
;		+4     =  KB NUMBER OF DATASET LINE
;		+5     =0 => 2 SECOND HANGUP
;		       >0 => N SECOND HANGUP
;		       <0 => ENABLE                                     
;-

	BR	10$		;GO DO TERMINAL DISABLE

	UUOENT	HNG,,SYNC,LOGABL,DOLOG	;HANGUP A DATASET		;010

	CMP	(R4)+,(R4)+	;INDEX INTO FIRQB
	MOVB	(R4)+,R0	;GET LINE #
	CMP	R0,#CNT.KB	;VALID LINE #?
	BHIS	20$		;NOPE
	ASL	R0		;LINE # TIMES 2 NOW
	MOV	DEV.KB(R0),R1	;GET THE TERMINAL DDB POINTER		;028
	BITB	#1,DDJBNO(R1)	;Disabled keyboard			;032
	BNE	20$		;Yes, return an error			;032
	MOV	R0,-(SP)	;Save the line #			;017
	MOVB	FQJOB-5(R4),R0	;Get the job number * 2			;017
	CMPB	R0,DDJBNO(R1)	;Do we own this terminal?		;017
	BEQ	55$		;Yes, anything goes			;010
	MOV	(PC)+,R5	;Set the priv to check in R5		;019
	 .BPRIV	HWCTL							;013
	CALLX	CHKPR5,R4	;Go and check it			;019
	BCS	20$		;No cigar				;017
55$:	MOV	(SP)+,R0	;Restore the line #			;017
	CMPB	#TTLT11,TTINTF(R1) ;Is this a LAT line?			;033
	BEQ	57$		;If so, always allow this		;033
	BIT	#TTMODM,TTINTF(R1) ;A MODEM LINE?			;010
	BEQ	70$		;NOPE, DO NOTHING
57$:	MOVB	(R4),R3		;IS IT HANGUP OR ENABLE?		;033
	BMI	80$		;<0 => ENABLE
	BNE	60$		;>0 => N SECOND HANGUP
	MOV	#2,R3		;=0 => 2 SECOND HANGUP
60$:	TST	MODCLK(R1)	;ALREADY HUNG UP?			;031
	BMI	70$		;YEP
.ASSUME	TTDSBL	EQ	100000
	MOV	R3,MODCLK(R1)	;SET THE TIME UNTIL A HANGUP		;031
70$:	RETURN			;NOW EXIT

GLOBAL	<CNT.KB,DEV.KB>							;028

80$:	MOV	CSR.KB(R0),R3	;GET THE CSR POINTER
	MAP	TERAP6,APR=6,CODE,DATA,PIC ;;Map the termianal driver	;028
	SPLC	5		;;TO LEVEL 5 FOR SAFETY
	CALLX	SETDTR		;;Enable DTR for the line		;028
	BIT	#TTDSBL!TTWRC,MODCLK(R1) ;;IS LINE IN HANG UP STATE?
	BNE	90$		;;NOPE
	CLR	MODCLK(R1)	;;YEP, CLEAR THE HANG UP TIMEOUT VALUE
90$:	SPLC	3		;;BACK TO LEVEL 3 AGAIN
	MAP	FIP,CODE,DATA	;Be sure mapping is correct		;028
	RETURN			; AND EXIT

.DSABL	LSB

GLOBAL	<CSR.KB,TERAP6>							;028

;+
; SPEEDV - FORMAT FOR DHV11 PARAMETER WORD.
;
;	R0 =  OUTPUT SPEED CODE * 2000 (0<=SPEED<=17)
;	R3 =  DH11 PARAMETER WORD
;	R4 -> FIRQB @ +17 (SPEED)
;	R5 -> DDB @ TTINTF+0
;               
; FOR DHV11'S WE WANT...
;
;	R3 = RE-FORMATED PARAMETER WORD AS FOLLOWS:
;
;		<2-0>	0
;		<4-3>	DATA FRAME LENGTH (DH11 BITS <1-0>)	
;		<5>	PARITY ENABLE (DH11 BIT <4>)
;		<6>	EVEN PARITY (DH11 BIT <5>)
;		<7>	STOP CODE (DH11 BIT <2>)
;		<11-8>	RECEIVE SPEED (DH11 BITS <9-6>)
;		<15-12> TRANSMIT SPEED (DH11 BITS <13-10>)
;-

NGSPD	=^B<1001000000000000>	;38.4K AND 7200 ARE GROUP A SO ILLEGAL	;019

SPEEDV: NOP
	BIC	#140010,R3	;ENSURE UNUSED BITS ARE CLEAR		;009
	ASH	#2,R3		;SHIFT SPEEDS TO HIGH BYTE		;009
	MOV	R3,R0		;COPY THE PARAMETER WORD		;009
	SWAB	R0		;GET SPEEDS DOWN TO THE LOW BYTE	;009
	MOV	R0,R2		;COPY THE SPEED				;009
	BIC	#^C<17>,R0	;GET THE RECEIVE SPEED			;009
	ASL	R0		;MAKE IT TIMES TWO			;009
	ASH	#-3,R2		;SHIFT THE TRANSMIT SPEED TO <4-1>	;009
	BIC	#^C<17*2>,R2	;AND CLR UNUSED BITS			;009
	MOV	BITWRD(R0),R0	;GET THE RECEIVE SPEED BIT		;009
	BIS	BITWRD(R2),R0	;AND THE TRANSMIT SPEED BIT		;009
	BIT	R0,#NGSPD	;IS THIS AN ILLEGAL SPEED?		;009
	BNE	20$		;YES IT IS				;009
	MOV	R3,R0		;COPY THE PARAMETER WORD		;009
	ASLB	R3		;GET CHAR. LENGTH IN BITS <4-3>		;009
	ASR	R0		;EVEN PARITY/PARITY ENABLE IN BITS <6-5> ;009
	BIC	#^C<150>,R0	;GET THE EVEN PARITY/PAR. ENAB./STOP	;009
	BIT	#40,R0		;Enabling parity?			;024
	BEQ	5$		;No					;024
	MOV	#100,R2		;Set mask to flip/flop parity setting	;024
	XOR	R2,R0		;Set parity (1=Even, 0=Odd)		;024
5$:	BICB	#^C<30>,R3	;GET THE PARITY/CHAR. LENGTH		;009
	BIT	#10,R0		;2 STOP BITS?				;009
	BEQ	10$		;NOPE ONLY ONE				;009
	ADD	#200-10,R0	;CORRECT THE STOP BITS			;009
10$:	BIS	R0,R3		;MERGE PARITY,STOP,CHAR LENGTH W/SPEED	;009
	RETURN			;RETURN RE-FORMATED PARAMETER WORD	;009

20$:	MOV	TTPARM-TTCHAR(R1),R3 ;ILLEGAL SPEED, SPEED REMAINS THE SAME ;009
	RETURN

GLOBAL	<BITWRD>


;+
; SPEEDZ - FORMAT FOR DZ11 PARAMETER WORD.
;
;	R0 =  OUTPUT SPEED CODE * 2000 (0<=SPEED<=17)
;	R3 =  DH11 PARAMETER WORD
;	R4 -> FIRQB @ +17 (SPEED)
;	R5 -> DDB @ TTINTF+1
;
; FOR DZ11'S WE WANT...
;
;	R3 = RE-FORMATED PARAMETER WORD AS FOLLOWS:
;
;		<2-0>	SUBLINE NUMBER (FROM THE DDB)
;		<4-3>	DATA FRAME LENGTH (DH11 BITS <1-0>)
;		<5>	STOP BITS (DH11 BIT <2>)
;		<6>	PARITY ENABLE (DH11 BIT <4>)
;		<7>	ODD PARITY (DH11 BIT <5>)
;		<11-8>	SPEED CODE (DH11 BITS <9-6> MINUS 1)
;		<12>	RECEIVER CLOCK ENABLE (1 UNLESS DH11 BITS <9-6> = 0)
;		<15-13>	0
;-

SPEEDZ:	BIC	#^C<1767>,R3	;TRIM TO ONLY SPD, PARITY, STOP, LEN	;006
	ASH	#4,R3		;MOVE SPEED CODE TO <13-10>
	ASLB	R3		;STOP, LEN TO BITS <7-5>
	ASR	R3		;SHIFT ALL BITS BACK TO
	ASR	R3		; THEIR CORRECT POSITIONS
	ADD	#10000-400,R3	;ADD RCVR CLK ENBL, SPEED=SPEED-1
	CMPB	(R4),#21	;REALLY ASKING FOR THAT HIGH SPEED??
	BNE	10$		;NOPE
	ADD	#10000,R3	;YEP, SO CORRECT THE SPEED
10$:	MOVB	(R5),R5		;GET SUBLINE NUMBER AND
	BIC	#^C<7>,R5	; TRIM TO ONLY THE SUBLINE
	BIS	R5,R3		;NOW .OR. SUBLINE INTO PARAMETER WORD
	RETURN			;RETURN RE-FORMATED PARAMETER WORD	;006

FQFEND

FQFSRT
;+ 012
;
; RQSPRM - REQUEST TO SET OR SHOW PERMANENT TERMINAL CHARACTERISTICS
;
;	RQSPRM WILL SET OR SHOW PERMANENT TERMINAL CHARACTERISTICS FOR
;	TRM OR TRMEXT (TRM EXTENDED).
;
;	R1 -> DDB
;	R4 -> FIRQB
;
;- 012

RQSPRM: NOP			;ODT BPT ENTRY				;012
	MOV	#TTRING,R2	;GET THE RING LIST OFFSET		;012
	ADD	R1,R2		;NOW ADD IN THE DDB ADDRESS		;012
	CMPB	#200,FQPFLG(R4)	;IS THIS A SHOW PERMANENT CHARS.?	;012
	BEQ	100$		;YES IT IS				;012
	BPL	95$		;0,200,377 ARE THE ONLY VALID PARAMETERS ;012
	TSTB	FQFIL(R4)	;IS THIS FOR TRM EXTENDED?		;012
	BNE	90$		;YES IT IS				;012
	MOV	TTPARM(R1),(R2)+ ;SAVE THE PARAMETERS WORD		;012
	MOV	TTCHAR(R1),(R2)+ ; AND THE CHARACTERISTICS		;021
	MOVB	TTFCNT(R1),(R2)+ ;  AND FILL CHARACTERISTICS		;012
	MOVB	DDHORC(R1),(R2)+ ;SAVE DDHORC				;012
	BIC	#LCLCPY,(R2)	;Assume we are to clear local copy	;029
	MOV	TTCAPB(R1),R3	;GET THE CURRENT CAPABILITY FLAGS	;012
	BIC	#^C<LCLCPY>,R3	;GET RID OF ALL BUT LOCAL COPY		;012
	BIS	R3,(R2)+	;Set permanent local copy if its set now;029
	MOVB	TTCTRL(R1),(R2)+;Save the control char. functions	;029
	BR	95$		;Now leave				;024

90$:	ADD	#6,R2		;POINT TO BEGINNING OF TRM EXTENDED PERM. LIST ;012
	MOV	TTCAPB(R1),(R2) ;SAVE THE CAPABILITY FLAGS		;034
	BIC	#TIC1!TIC2!TIC3,(R2)+ ;Clear "trash input" timing bits	;034
	MOVB	TTCTRL(R1),(R2)+ ;SAVE THE CONTROL CHAR. FUNCTIONS	;012
	MOVB	TTTYPE(R1),(R2)+ ;SAVE THE TERMINAL TYPE		;035
	MOVB	TCHAR2(R1),(R2)+ ;Save additional characteristic flags	;035
95$:	RETURN			;AND GET OUT OF HERE			;024

100$:	TSTB	FQFIL(R4)	;IS THIS REALLY FOR TRM EXTENDED?	;012
	BEQ	104$		;NOPE					;012
	JMP	200$		;YES, GO TO IT				;012

104$:	MOV	R1,-(SP)	;SAVE THE DDB POINTER			;012
	MOV	#1,R3		;START TESTING AT BIT 1			;012
	TST	(R2)+		;GET UP TO TTCHAR (/PERM)		;015
	MAP	@#KISAR5,APR=5,DATA,PIC ;Need to map the table		;019
	MOVPIC	#300$,R1	;GET TTCHAR FORMAT TABLE		;012
110$:	MOV	R4,-(SP)	;SAVE FIRQB+0				;012
	MOVB	(R1)+,R5	;GET THE FIRQB OFFSET			;012
	MOV	R5,-(SP)	;SAVE FIRQB OFFSET			;012
	BIC	#^C<177>,R5	;GET RID OF SIGN IF SET			;012
	ADD	R5,R4		;AND ADD THE FIRQB OFFSET TO FIRQB+0	;012
	MOV	(SP)+,R5	;RESTORE FIRQB OFFSET ALONG WITH SIGN (IF SET) ;012
	BIT	R3,(R2)		;IS THIS SET AS A PERMANENT CHARACTERISTIC? ;012
	BEQ	115$		;NOPE					;012
	MOVB	#377,(R4)	;YES, SO RETURN SAYING IT'S SET		;012
	TSTB	R5		;BUT IS THIS SPECIAL?			;012
	BPL	120$		;NOPE					;012
	MOVB	#200,(R4)	;YES, SO RETURNING 200 MEANS IT'S SET	;012
	BR	120$		;AND CONTINUE				;012
		
115$:	MOVB	#200,(R4)	;NOT SET, SO RETURN SAYING IT'S NOT SET	;012
	TSTB	R5		;BUT IS THIS A SPECIAL?			;012
	BPL	120$		;NOPE 					;012
	MOVB	#377,(R4)	;YES, SO RETURNING A 377 MEANS BIT ISN'T SET ;012
120$:	MOV	(SP)+,R4	;GET FIRQB+0				;012
	ASL	R3		;CHECK NEXT BIT				;012
	BCC	110$		;CONTINUE TILL WE'RE DONE...		;012
	MAP	FIPPOL		;Make sure FIPPOL is remaped		;019
	MOV	(SP)+,R1	;RESTORE THE DDB POINTER		;012
	MOV	#1,R0		;GUESS AT PARITY SETTING OF "NO PARITY"	;015
	BIT	#TTPRTY,(R2)	;GOOD GUESS?	(R2->TTCHAR)		;015
	BEQ	125$		;YES, LEAVE CODE=1			;015
	INC	R0		;NO, SET CODE=2 (EVEN PARITY)		;015
	BIT	#TTPODD,(R2)	;IS EVEN PARITY A GOOD GUESS??		;015
	BEQ	125$		;YES, LEAVE CODE=2			;015
	INC	R0		;NO, ODD PARITY, SET CODE=3		;015
125$:	TST	(R2)+		;UP TO TTFCNT (/PERM)			;015
	MOVB	R0,FQBUFL(R4)	;SET PARITY SETTING @ FIRQB+20		;015
	MOVB	#-1,FQSIZ(R4)	;GUESS AT SERIAL LA30 FILL (@ FIRQB+16)	;015
	MOVB	(R2),R0		;GET THE REAL FILL CHARACTERISTICS	;015
	BMI	128$		;SERIAL LA30 FILL IT IS			;015
.ASSUME	TTLA30	EQ	200						;015
	BIC	#^C<TTFILL>,R0	;ELSE TRIM TO ONLY FILL COUNT		;015
	INC	R0		; THEN MAKE THAT FILL COUNT +1		;015
128$:	MOVB	R0,FQSIZ(R4)	;  AND SET FILL COUNT +1 @ FIRQB+16	;015
	MOVB	#20,FQNENT(R4)	;ASSUME 7-BIT (20)			;015
	BITB	#TT8BIT,(R2)	;DO WE WANT 7-BIT?			;015
	BEQ	130$		;YES WE DO				;015
	MOVB	#20!10,FQNENT(R4) ;ELSE, SET FOR 8-BIT (30)		;015
130$:	TSTB	(R2)+		;UP TO DDHORC (/PERM)			;015
	MOVB	(R2)+,FQPPN(R4)	;SET TERMINAL WIDTH+1 @ FIRQB+6		;015
	MOVB	#200,FQNAM1+3(R4) ;GUESS AT FULL DUPLEX			;015
	BIT	#LCLCPY,(R2)	;BUT IS THIS LOCAL COPY?		;015
	BEQ	140$		;NOPE					;015
	MOVB	#377,FQNAM1+3(R4) ;YES, SO RETURN SHOWING LOCAL COPY	;015
140$:	TST	(R2)+		;UP TO TTCTRL (/PERM)			;015
	MOVB	#200,FQDEVN(R4) ;GUESS ^R IS DISABLED			;015
	BITB	#TTCTRR,(R2)	;IS ^R SET AS PERMANENT?		;015
	BEQ	150$		;NOPE, WE'RE RIGHT			;015
	MOVB	#377,FQDEVN(R4) ;YES, SAY IT'S ENABLED			;015
150$:	BITB	#TTAUTO,TTCTRL(R1) ;Auto-Baud set?			;021
	BNE	185$		;Yes, speed no setable 			;021
				;(CLRB 17(R4) in NRMTRM)		;021
	SUB	#10,R2		;BACK TO TTPARM (/PERM)			;015
	MOV	(R2),R3		; AND GET THOSE PARAMETERS		;012
	MOV	#-6.,R0		;SHIFT FOR DH11 INPUT SPEED (<9-6>)	;012
	MOV	R2,-(SP)	;SAVE THE PERMANENT LIST POINTER	;012
	MOV	#-10.+6.,R2	;NEXT SHIFT FOR DH11 OUTPUT SPEED (<13-10>) ;012
	MOV	#^C<17>,R5	;SPEED ISOLATION MASK FOR DH11 (4 BITS)	;012
	CMPB	TTINTF(R1),#TTDH11 ;REALLY A DH11 LINE?			;012
	BEQ	160$		;YEP					;012
	MOV	#-8.,R0		;SHIFT FOR DZ11 INPUT SPEED (<11-8>)	;012
	CLR	R2		;NEXT SHIFT FOR DZ11 OUTPUT SPEED (<11-8>) ;012
	;MOV	#^C<17>,R5	;SPEED ISOLATION MASK FOR DZ11 (4 BITS)	;012
	CMPB	TTINTF(R1),#TTDZ11 ;REALLY A DZ11 LINE?			;012
	BEQ	160$		;YES					;012
	;MOV	#-8.,R0		;SHIFT FOR DHV11 INPUT SPEED (<11-8>)	;012
	MOV	#-12.+8.,R2	;NEXT SHIFT FOR DHV11 OUTPUT SPEED (<15-12>) ;012
	;MOV	#^C<17>,R5	;SPEED ISOLATION MASK FOR DHV11 (4 BITS) ;012
	CMPB	TTINTF(R1),#TTVH11 ;REALLY A DHV11 LINE?		;012
	BNE	190$		;NOPE, SO SPEED NOT SETTABLE		;012
160$:	ASH	R0,R3		;MOVE INPUT SPEED TO <3-0>		;012
	MOV	R3,R0		;NOW SAVE INPUT SPEED			;012
	BIC	R5,R0		; TRIMMING IT TO A LEGAL VALUE		;012
	ASH	R2,R3		;MOVE OUTPUT SPEED TO <3-0>		;012
	BIC	R5,R3		; TRIMMING IT TO A LEGAL VALUE		;012
	MOV	(SP)+,R2	;RESTORE THE PERMANENT LIST POINTER	;012
	CMPB	TTINTF(R1),#TTDZ11 ;WAS THIS A DZ11 LINE??		;012
	BNE	170$		;NOPE					;012
	BIT	#010000,(R2)	;YEP, WAS RECEIVER CLOCK ACTIVE?	;012
	BEQ	170$		;NOT ACTIVE, LEAVE A CODE OF ZERO	;012
	CMPB	(R0)+,(R3)+	;ACTIVE, DO EXTRA +1 IN SPEED CODES	;012
170$:	CMP	R3,R0		;DOES OUTPUT SPEED = INPUT SPEED ?	;012
	BEQ	180$		;YES, LEAVE FIRQB+21 = 0		;012
	INC	R0		;NO, SET INPUT SPEED CODE +1		;012
	MOVB	R0,FQBUFL+1(R4)	; AT FIRQB+21				;012
180$:	INC	R3		;SET OUTPUT SPEED CODE +1		;012
	MOVB	R3,FQSIZ+1(R4)	; AT FIRQB+17				;012
185$:	MOVB	TTINTF(R1),FQFLAG(R4) ;RETURN INTERFACE TYPE		;021
	BR	210$		;AND LEAVE				;012

190$:	MOV	(SP)+,R2	;CLEAN OFF STACK			;012
	BR	210$		;AND LEAVE				;012

200$:	ADD	#6,R2		;POINT TO PERMANENT EXTENDED CHARACTERISTICS ;012
	MOV	(R2)+,FQDEVN(R4) ;RETURN PERMANENT TERMINAL CAPABILITY FLAGS ;012
	MOVB	(R2)+,FQDEV(R4)	;RETURN THE TTCTRL PERMANENT BYTE	;012
	BIC	#^C<17777>,FQDEVN(R4) ;DON'T RETURN AUTO-BAUD TIMING BITS ;016
	BICB	#^C<77>,FQDEV(R4) ;DON'T RETURN AUTO-BAUD TIMING BITS  ;016
	MOVB	(R2)+,FQPPN(R4)	;RETURN PERMANENT TERMINAL TYPE CODE	;035
	MOVB	(R2)+,FQFLAG(R4);Return line editing/operator chars	;035
210$:	RETURN								;012

;	THE FOLLOWING IS A TABLE OF BITS (LSB TO MSB) OF THE WORD 	;012
;	TTCHAR.  IF THE SIGN BIT OF THE BYTE IS SET, RETURNING		;012
;	A 200 MEANS THE BIT IS SET, 377 IT IS CLEAR.  OTHERWISE, A 200	;012
;	RETURNED MEANS THE BIT IS CLEAR, A 377 IT'S SET.		;012
;	VALUES SPECIFIED ARE FIRQB OFFSETS TO SET/CLR THAT BIT.		;012
300$:	.BYTE	35		;TTGAG					;012
	.BYTE	234		;TTBRK					;012
	.BYTE	33		;TTXANY					;012
	.BYTE	232		;RESERVED				;012
	.BYTE	31		;TTESC					;012
	.BYTE	14		;TTSCOP					;012
	.BYTE	27		;TTESCI					;012
	.BYTE	211		;TTLCOU					;012
	.BYTE	20		;TTPODD					;012
	.BYTE	20		;TTPRTY					;012
	.BYTE	223		;TTUPAR					;012
	.BYTE	22		;TTSYNC					;012
	.BYTE	12		;TTXON					;012
	.BYTE	10		;TTFORM					;012
	.BYTE	207		;TTTAB					;012
	.BYTE	15		;TTLCIN					;012

FQFEND									

.END
