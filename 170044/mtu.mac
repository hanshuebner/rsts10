	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
	.INCLUDE /CMN:FLDEF/
	.INCLUDE /CMN:MTDEF/
TITLE	MTU,<MAGTAPE UTILITY CODE>,0A,10-MAY-91,MHB/ABC/SJK/SRM/TWH/DBM/JHC/KPH/TPT/FEK

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR MTU
;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;  001	SRM  28-Sep-81	Clean up the writing of EOF trailers.
;
;			[RSTS V9.0]
;  002	TWH  01-DEC-83	REMOVE MTAIO AND MTADD SUBRS TO CTL
;  003	TWH  30-MAR-84	MULTI-VOLUME ANSI MAGTAPE SUPPORT
;  004	DBM  27-Apr-84	Finish MVA support
;  005	JHC  14-May-84	Add LEOT support to EOV handler.
;			fix up TMK positioning after operation
;  006	DBM  10-Jun-84	Fix MTOFLG and JFPOST handling
;  007	DBM  03-Aug-84	Fix bug in open code (Offline during open will crash)
;  008	DBM  28-Aug-84	Fix bug in asynchrous EOV end-processing
;  009	KPH  01-Oct-84	Move MTA to MVR phase
;  010	KPH  21-Jan-85	Don't clobber density in MTOFLG
;  011	DBM  08-Feb-85	Clear posting mask during EOF/EOV handling
;
;			[RSTS V9.1]
;  012	DBM  27-May-85	Check status on open for NOTAVL (TMSCP support)
;  013	TPT  15-Jun-85	Fix bug in open done processing (inc'ing MTFLAG!)
;  014	DBM  11-Jul-85	Fix carriage control flags for non-DEC, non-IBM tapes
;
;			[RSTS V9.2]
;  015	DBM  01-Oct-85	Issue Error Condition Acknowledge function on opens
;			Bug fix in positioning after EOF/EOV check
;
;			[RSTS V9.3]
;  016	DBM  19-Aug-86	Change internal ANSI/DOS open flag
;			(Fix crash if error log occurs during ANSI open)
;
;			[RSTS V9.6]
;  017  VAM  24-May-88	Use new "backspace tape mark" TMSCP feature.
;			Also fix tape filesizes > 65535. records.
;
;			[RSTS/E V10.0]
;  018	FEK  05-Oct-89	Create option for recordsize=blocksize
;-

; MACROS FOR MTU

.MACRO	CALLU	SUBR,REG,ARG
.IRP	N,<\FQFNUM>
	CALL	SUBR''N,REG,<ARG>
.ENDM
.ENDM	CALLU

.MACRO	BCU	OP,LABEL
.IRP	N,<\FQFNUM>
	 B'OP	LABEL''N
.ENDM
.ENDM	BCU

.MACRO	ENTERU	LABEL
.IRP	N,<\FQFNUM>
LABEL''N:
.ENDM
.ENDM	ENTERU

.MACRO	MOVU	RADDR							;002
.IRP	N,<\FQFNUM>							;002
.IF	B	<RADDR>							;002
	 MOV	#MTIOR'N,MTBCNT(R4)					;002
	 CALLM	MTAIO,MVRAP5						;009
MTIOR'N:								;002
.IFF									;002
.IF	IDN	<RADDR>,SP						;002
	 MOV	(SP)+,FQADDR(R4)					;002
.IFF									;002
	 MOV	#RADDR''N,FQADDR(R4)					;002
.ENDC									;002
	 MOV	#MTIOR'N,MTDDSP+MTBCNT(R1)				;002
	 CALLMR	MTADD,MVRAP5						;009
.ENDC									;002
.ENDM									;002
.ENDM	MOVU								;002

.SBTTL	DEFINE ANSI LABEL FORMATS

.DSECT			;VOL1 LABEL
V1.LID:	.BLKB	3	;"VOL"	LABEL IDENTIFIER
V1.LNU:	.BLKB	1	;"1"	LABEL NUMBER
V1.VID:	.BLKB	6	;AAAAAA	VOLUME IDENTIFIER
V1.ACC:	.BLKB	1	;" "	ACCESSIBILITY (SPACE => NO RESTRICTIONS)
	.BLKB	26.	;RESERVED
V1.OWN:	.BLKB	14.	;"D%B4431JJJGGG1" OWNER IDENTIFIER (& DEC PROTECTION)
	.BLKB	28.	;RESERVED
V1.LSV:	.BLKB	1	;"3"	LABEL-STANDARD VERSION
ANSLBL:			;CHECK LENGTH

.DSECT			;FILE LABEL 1 (HDR1 OR EOF1)
F1.LID:	.BLKB	3	;"HDR" OR "EOF" OR "EOV" LABEL IDENTIFIER
F1.LNU:	.BLKB	1	;"1"	LABEL NUMBER
F1.FID:	.BLKB	17.	;FILNAM.EXT FILE IDENTIFIER
F1.FSI:	.BLKB	6	;AAAAAA	FILE-SET IDENTIFIER (VOLUME ID)
F1.SEC:	.BLKB	4	;NNNN	FILE SECTION NUMBER
F1.SEQ:	.BLKB	4	;NNNN	FILE SEQUENCE NUMBER
F1.GEN:	.BLKB	4	;0001	GENERATION NUMBER
F1.GVN:	.BLKB	2	;00	GENERATION VERSION NUMBER
F1.CRE:	.BLKB	6	; YYDDD CREATION DATE (LEADING SPACE!)
F1.EXP:	.BLKB	6	; YYDDD EXPIRATION DATE (SAME IN RSTS)
F1.ACC:	.BLKB	1	;" "	ACCESSIBILITY (SPACE => NO RESTRICTIONS)
F1.BLK:	.BLKB	6	;NNNNNN	BLOCK COUNT (000000 FOR HDR1 LABEL)
F1.SYS:	.BLKB	13.	;"DECRSTS/E" SYSTEM CODE
	.BLKB	7	;RESERVED
ANSLBL:			;CHECK LENGTH

.DSECT			;FILE LABEL 2 (HDR2 OR EOF2)
F2.LID:	.BLKB	3	;"HDR" OR "EOF" OR "EOF" LABEL IDENTIFIER
F2.LNU:	.BLKB	1	;"2"	LABEL NUMBER
F2.FMT:	.BLKB	1	;"F" (FIXED), "D" (VARIABLE), OR "S" (SPANNED)
F2.BLK:	.BLKB	5	;NNNNN	BLOCK LENGTH
F2.REC:	.BLKB	5	;NNNNN	RECORD LENGTH
	.BLKB	21.	;RESERVED FOR SYSTEM USE
F2.CTL:	.BLKB	1	;DEC: CONTROL CHARACTERS ("A", " ", OR "M")
	.BLKB	13.	;RESERVED FOR SYSTEM USE
F2.BFO:	.BLKB	2	;"00"	BUFFER-OFFSET LENGTH
	.BLKB	28.	;RESERVED
ANSLBL:			;CHECK LENGTH

.DSECT			;ANSI CONTROL BLOCK (ACB)
ACBCHR:	.BLKW		;FILE CHARACTERISTICS WORD
ACBTYP:	.BLKW		;LABEL TYPE (HDR OR EOF OR EOV)
ACBNAM:	.BLKW	3	;FILENAME.EXTENSION (RAD50)
ACBVOL:	.BLKB	6	;VOLUME ID (ASCII)
ACBSIZ:	.BLKW		;BLOCK SIZE
ACBSID:	.BLKW		;SYSTEM ID					;003
ACBSEQ:	.BLKW		;FILE SEQUENCE NUMBER
ACBGEN:	.BLKW		;GENERATION NUMBER (THIS SPACE COULD BE USED)
ACBCNT:	.BLKW		;BLOCK COUNT
ACBSEC:	.BLKW		;SECTION NUMBER					;003
ACBRTY:	.BLKB		;RECORD TYPE					;004
ACBMOD:	.BLKB		;MODIFIER CHAR					;003
ACBFLG:	.BLKW		;ANSI Flag bits					;018
.ASSUME	. EQ 40		;BETTER BE ONE SMALL BUFFER!			;004

.BSECT			;ACBFLG definitions				;018
AF.BIG:	.BLKB	.	;Use block size value in place of recordsize	;018
	.BLKB	.	;Reserved					;018
	.BLKB	.	;Reserved					;018
	.BLKB	.	;Reserved					;018
	.BLKB	.	;Reserved					;018
	.BLKB	.	;Reserved					;018
	.BLKB	.	;Reserved					;018
	.BLKB	.	;Reserved					;018
	.BLKB	.	;Reserved					;018
	.BLKB	.	;Reserved					;018
	.BLKB	.	;Reserved					;018
	.BLKB	.	;Reserved					;018
	.BLKB	.	;Reserved					;018
	.BLKB	.	;Reserved					;018
	.BLKB	.	;Reserved					;018
	.BLKB	.	;Reserved					;018

FQFSRT	MTU

.SBTTL	MAGTAPE ZERO

	FJMPDV	MT,ZER,ENTER	;MAGTAPE ZERO

.SBTTL	DOS MAGTAPE ZERO

	CLR	FQERNO(R4)	;ENSURE TAPE WILL BE REWOND
	CALL	MTAGET		;GRAB THE MAGTAPE AND CHECK FOR ANSI
	BEQ	MTACEF		;DOS, DO A DOS MAGTAPE ZERO
	FJMP	ANSZER		;ANSI, DO AN ANSI MAGTAPE ZERO

.SBTTL	MAGTAPE CLOSE

.ENABL	LSB

	FJMPDV	MT,CLS,ENTER	;MAGTAPE CLOSE

.SBTTL	NON-FILE STRUCTURED MAGTAPE CLOSE
.SBTTL	DOS MAGTAPE CLOSE
.SBTTL	ANSI MAGTAPE INPUT CLOSE

	MOV	MTACB+MTDDSP(R1),R5	;GET ACB POINTER, IF ANY	;004
	BEQ	5$		;NONE, DON'T WOORY			;004
	MOV	MTBCNT+MTDDSP(R1),ACBCNT(R5) ;COPY BLOCK COUNT FOR CLOSE;004
5$:	CALL	MTACL0		;GET REGISTERS/DDB STRAIGHT
	BIT	#DDRLO,MTIDX(R4) ;CHECK FOR READ LOCKOUT
	BEQ	30$		;IF READABLE THEN NO EOF'S NEEDED
	TST	MTACB(R4)	;ANSI OUTPUT CLOSE? (ACB?)
	BEQ	MTACEF		;DOS CLOSE, DO IT
	FJMP	ANSCLS		;ANSI OUTPUT CLOSE, OFF TO IT

MTACEF:	MOV	#2,FQFLAG(R1)	;SET COUNTER FOR 2 BACKSPACES (AFTER EOF'S)
MTACEA:	MOV	#3,FQPPN(R1)	;SET COUNTER FOR WRITING 3 EOF'S
10$:	MOV	#EOF.MT,R2	;SET FUNCTION TO "WRITE EOF"
	CALLU	MTCIO		;NOW WRITE AN EOF			;002
	BCU	NE,MTACX	;ERROR, DIE				;004
	DEC	FQPPN(R1)	;MORE EOF'S TO WRITE?
	BGT	10$		;YES, SO CONTINUE WRITING THEM
	BITB	#MT.NRW,MTFLAG(R4) ;DONE, WILL WE BE REWINDING?
	BEQ	50$		;YES, SO GO DO REWIND RIGHT NOW
20$:	CALLU	MTCIO		;NOW DO ONE BACKSPACE			;002
	BCU	NE,MTACX	;ERROR, DIE				;004
	DEC	FQFLAG(R1)	;MORE BACKSPACES TO DO?
	BGT	20$		;YES, SO DO THEM
	BR	MTANEX		;NO, ALL DONE

30$:	BITB	#MT.NRW,MTFLAG(R4) ;SHOULD WE REWIND THE TAPE?
	BEQ	50$		;YES, SO REWIND THE TAPE
	TSTB	MTOFLG(R4)	;NO, FILE STRUCTURED?
	BPL	MTANEX		;NON-FILE STRUCTURED, SO JUST EXIT
40$:	BIT	#MTEOF,MTLCST(R4) ;FILE STRUCTURED, ARE WE AT EOF NOW?
	BNE	MTANEX		;YES, NO SKIP TO EOF REQUIRED
	NEG	MTCNT(R4)	;NO, SO SET FOR AN "INFINITE" SKIP
	DEC	R2		; AND CHANGE FUNCTION TO SKIP FORWARD
.ASSUME	SKP.MT	EQ	BSP.MT-1
	CALLU	MTCIO		;NOW SKIP THAT FILE			;002
	BCU	NE,MTACX	;SOME ERROR, DIE			;004
	BR	40$		;ELSE CHECK FOR BEING AT EOF AGAIN

50$:	CALLU	MTARW		;NOW REWIND THE TAPE			
MTANEX:	CLRB	MTLCEV(R4)	;REPORT NO ERROR OCCURED

.DSABL	LSB

.ENABL	LSB

ENTERU	MTACX
	MOVB	MTLCEV(R4),R0	;GET THE ERROR CODE IF ANY
	BLE	10$		;DON'T REWIND IF CODE <= 0
ENTERU	MTACE
	MOVB	R0,FQFLAG(R1)	;ELSE SAVE THE ERROR CODE
	CALLU	MTARW		;THEN REWIND THE TAPE FOR BAD ERRORS
	MOVB	FQFLAG(R1),R0	;NOW GET BACK THE ORIGINAL CODE
10$:	FJMP	MTACE		;FINISH UP EXIT IN ANOTHER OVERLAY	;004

.DSABL	LSB

GLOBAL	<FIJBDA>

.SBTTL	DOS MAGTAPE DIRECTORY

.ENABL	LSB

10$:	MOV	R1,MTUBUF(R4)	;SET LABEL READING LOCATION
	ADD	#FQNAM1,MTUBUF(R4) ; WITHIN FIRQB
	MOV	#DOSLBL-2,MTCNT(R4) ;SET LABEL'S MAXIMUM LENGTH -2
	MOV	#RED.MT,R2	;SET FUNCTION AS "READ"
	CALLU	MTCIO		;NOW READ THE LABEL			;002
	BEQ	60$		;NO ERROR, BAD LABEL!
	CMPB	R5,#EOF		;LOGICAL END OF TAPE??
	BEQ	50$		;YES, END OF LISTING
	CMPB	R5,#MAGRLE	;RECORD LENGTH ERROR?
	BCU	NE,MTACX	;NO, ALL OTHER ERRORS ARE FATAL		;004
	CMP	FQNAM1(R1),#"VO	;REALLY AN ANSI LABEL??
	BEQ	60$		;YES, ERROR ALSO
	MOV	FQNAM1+6(R1),FQPROT-1(R1) ;SAVE THE PPN OF THIS LABEL
	CLR	FQSIZ(R1)	;Pre-clear returned file size,		;017
	CLRB	FQBUFL+1(R1)	; both LSB and MSB.			;017
	CMP	FQPPN(R1),#-1	;Is a file skip desired?		;017
	BEQ	30$		;No, leave size and function code alone	;017
				; (R2 currently contains "backspace").	;017
	DEC	FQSIZ(R1)	;Start at -1 to correct for EOF (which	;017
				; is counted as a record skipped but	;017
				; isn't included in the file size).	;017
	DECB	FQBUFL+1(R1)	;And MSB, too (for 24-bit arithmetic).	;017
20$:	DEC	R2		;Change function code to "skip" (MTCIO	;017
				; resets this to "backspace").		;017
.ASSUME	SKP.MT	EQ	BSP.MT-1
	NEG	MTCNT(R4)	;Change count of records to be skipped	;017
				; from 1 to -1 (MTCIO resets this to 1).;017
30$:	CALLU	MTCIO		;NOW SKIP THE WHOLE FILE		;002
MTACXJ:	BCU	NE,MTACX	;ERROR, DIE				;004
	CMP	FQPPN(R1),#-1	;SPECIAL NO FILE SKIP CALL?
	BEQ	40$		;YES, SO JUST RETURN THE INFO.
	COM	MTCRET(R4)	;Calculate number of records actually	;017
				; skipped ('COM n' = '65535.-n').	;017
	ADD	MTCRET(R4),FQSIZ(R1) ;Add number of records skipped,	;017
	ADCB	FQBUFL+1(R1)	; both LSB and MSB.			;017
	BIT	#MTEOF,MTLCST(R4) ;DID LAST COMMAND REALLY HIT "EOF"?
	BEQ	20$		;No, so go skip some more.		;017
	TST	FQPPN(R1)	;PPN supplied?
	BEQ	40$		;NO, SO ALL PPN'S MATCH
	CMP	FQPROT-1(R1),FQPPN(R1) ;YES, DOES IT MATCH?
	BNE	10$		;NO, AROUND AGAIN...
40$:	BIC	#100000,FQNAM1+12(R1) ;ENSURE A CORRECT DATE
	BR	MTANEX		;EXIT RETURNING NO ERROR

50$:	SETERR	NOSUCH,R0	;SET THE FINAL ERROR CODE
	BCU	R,MTACE		; AND EXIT (TAPE WILL REWIND)		;004

60$:	SETERR	BADDIR,R0	;BAD DIRECTORY ERROR (& REWIND)
	BCU	R,MTACE		;SO EXIT ALREADY			;004

GLOBAL	<EOF,MAGRLE>

.SBTTL	MAGTAPE DIRECTORY

	FJMPDV	MT,DIR,ENTER	;MAGTAPE DIRECTORY

	CALL	MTAGET		;GET THE MAGTAPE AND CHECK FOR ANSI
	BEQ	10$		;DOS DIRECTORY, DO IT
	MOV	#ANSDIR,FQFLAG(R1) ;ANSI DIRECTORY, SET FJMP RETURN
	CMP	(R1)+,(R1)+	;BIAS THE FIRQB POINTER
.ASSUME	FQFIL	EQ	4
	FJMP	GETHD1		;NOW GO READ THE HEADER LABEL SET

.DSABL	LSB

; GRAB A MAGTAPE DDB AND CHECK FOR ANSI

MTAGET:	CALLX	GETDEV		;GRAB THE MAGTAPE IF WE CAN
	TSTB	DDCNT(R1)	;ANY OPEN FILES?
	BEQ	10$		;NO, O.K. TO PROCEED
	ERROR	DTOOOF		;YES, SAY TOO MANY ARE OPEN

10$:	BIS	#DDUTIL,DDCNT(R1) ;SAY INTO UTILITY SEQUENCE
	BIS	#DDSTAT,(R1)	;INDICATE DEFAULTS NEED SETTING
	MOV	(SP)+,FQFLAG(R4) ;SAVE THE RETURN ADDRESS		;002
	CALL	MTACL0		;DO THE REGISTER SHIFTS, ETC.
	TST	FQERNO(R1)	;REWIND THE TAPE??
	BNE	20$		;NO
	CALLU	MTARW		;YES, SO DO IT ALREADY
	BNE	MTACXJ		;ERROR, DIE
20$:	TSTB	MTLBLI(R4)	;SET Z-BIT=1 IF DOS LABELING
	JMP	@FQFLAG(R1)	; AND RETURN TO OUR CALLER

; SET UP DDB/FIRQB FOR CLOSE

MTACL0:	MOV	R1,FQCLUS(R4)	;SAVE DDB POINTER IN THE FIRQB
	MOVU	SP		;SAVE A RETURN ADDRESS			;002

; REWIND THE MAGTAPE DRIVE

ENTERU	MTARW
	MOV	#REW.MT,R2	;SET FUNCTION TO "REWIND"
	
; DO MAGTAPE I/O

ENTERU	MTCIO								;002
	MOV	(SP)+,FQADDR(R1) ;SAVE OUR RETURN ADDRESS		;002
	CMP	(R1)+,(R1)+	;LINE UP R1 FOR COMMON MTAIO		;002
	MOVU			;GO DO IT				;002
	CMP	-(R1),-(R1)	;RESTORE R1 WHERE WE WANT IT		;002
	BICB	#MT.OPN,MTOFLG(R4) ;ENSURE ANY OPEN FILE IS "CLOSED"	;002
	MOV	#1,MTCNT(R4)	;PRESET A COUNT OF 1 FOR NEXT OPERATION ;002
	MOV	#BSP.MT,R2	;PRESET FUNCTION CODE OF BACKSPACE	;002
	MOV	FQADDR(R1),-(SP) ;SAVE THE RETURN ADDRESS		;002
	MOV	R2,FQNENT(R1)	;PRESET # ITEMS ON DIRECTORY & USTAT=0	;002
.ASSUME	BSP.MT	EQ	6						;002
	MOVB	MTLCEV(R4),R5	;ANY ERRORS?				;002
	BEQ	10$		;NOPE-LEAVE Z-BIT =1			;002
	CMPB	R5,#NOROOM	;IS IT EOT?				;002
	;BEQ	10$		;YES-IGNORE IT LEAVING Z-BIT = 1	;002
	;BNE	10$		;NOPE-SET Z-BIT = 0			;002
10$:	RETURN			;Z-BIT CLEAR ON ERROR			;002

GLOBAL	<NOROOM>

FQFEND

FQFSRT
;004+
.SBTTL	MTU COMMON EXITS

MTACEX:	MOVB	MTLCEV(R4),R0	;GET THE ERROR CODE IF ANY
	BLE	MTACE		;DON'T REWIND IF CODE <= 0		;004
	MOVB	R0,FQFLAG(R1)	;ELSE SAVE THE ERROR CODE		;004
	CMP	(R1)+,(R1)+	;BUMP R1 FOR I/O ROUTINE		;004
	CALLU	MTARW
	BICB	#MT.OPN,MTOFLG(R4) ;ENSURE ANY OPEN FILE IS "CLOSED"	;006
	CMP	-(R1),-(R1)	;RESET R1 BACK THE WAY WE LIKE IT	;004
	MOVB	FQFLAG(R1),R0	;NOW GET BACK THE ORIGINAL ERROR CODE
MTACE:	TSTB	MTDDCT(R4)	;ANY FILE OPEN ON MAGTAPE?		;004
	BEQ	20$		;NO, SO LEAVE COUNT ALONE
	DECB	MTDDCT(R4)	;YES, SO ONE LESS OPEN NOW
20$:	MOV	R4,R1		;MOVE THE DDB POINTER TO HERE
	SUB	#MTDDSP,R1	; AND UNBIAS IT
	CALLX	RETDEV		;NOW RETURN DEVICE IF POSSIBLE
	MOV	@#FIJBDA,R2	;GET CALLER'S JOB DATA POINTER
	BIC	#^C<177>,R0	;TRIM ERROR CODE OF THE "REWIND" BIT
	MOVB	R0,JDIOST(R2)	; AND SET THE ERROR CODE FOR CALLER
	BEQ	25$		;NO ERROR, SO POST WORK BLOCK		;004
	BIC	#JFPOST,JDFLG(R2);ERROR, SO JUST RETURN THE ERROR CODE	;004
25$:	MOV	MTACB+MTDDSP(R1),R4 ;GET THE ACB ADDRESS IF ANY
	BEQ	30$		;NONE, JUST EXIT
	CLR	MTACB+MTDDSP(R1) ;ONE, BE SURE TO INDICATE NONE NOW
	BUFFER	RETSML		;THEN RETURN THE ACB SPACE
30$:	JMPX	FIEXIT		; AND TAKE THE FINAL EXIT

; REWIND A MAGTAPE DRIVE

ENTERU	MTARW
	MOV	#REW.MT,R2	;SET FUNCTION "REWIND"			;004
	;BCU	R,MTCIO		;DO THE I/O
;004-

.SBTTL	MAGTAPE OPEN

; DO MAGTAPE I/O

ENTERU	MTCIO								;002
	MOV	(SP)+,FQADDR-FQFIL(R1)	 ;SAVE OUR RETURN ADDRESS	;002
	MOVU			;DO THE I/O				;002
	MOV	R1,R3		;COPY THE BIASED FIRQB POINTER		;002
.ASSUME	FQNAM1	EQ	FQFIL+4
	CMP	(R3)+,(R3)+	;AND SET POINTER TO NAME.EXT		;002
	MOVB	MTLCEV(R4),R0	;SET THE ERROR CODE			;002
	BEQ	10$		;NO ERROR, EXIT Z=1			;002
	CMPB	R0,#NOROOM	;ERROR, IS IT EOT?			;002
	;BEQ	10$		;YES, EXIT Z=1				;002
	;BNE	10$		;NO, REAL ERROR, EXIT Z=0		;002
10$:	JMP	@FQADDR-FQFIL(R1)  ;RETURN WITH CC'S SET		;002

ENTERU	MTFIX								;002
	MOVU	SP		;SAVE RETURN ADDDRESS AND JMP TO MTADD	;002

GLOBAL	<NOROOM>

;+
; NOTES ON THE MODE VALUE FOR MAGTAPE OPENS.
;
; VALID MODE BITS FOR NON-FILE STRUCTURED OPENS:
;
;	BIT  0 (    1.)	0=>ODD PARITY, 1=>EVEN PARITY
;	BITS 2-3	00( 0.)=>200 BPI (7-TRACK ONLY)
;			01( 4.)=>556 BPI (7-TRACK ONLY)
;			10( 8.)=>800 BPI (7-TRACK ONLY)
;			11(12.)=>800 BPI CORE DUMP MODE
;	BIT  8 (  256.)	1=>PHASE ENCODED(1600 BPI)
;
; VALID MODE BITS FOR FILE STRUCTURED OPENS:
;
;	BIT  1 (    2.)	1=>NEVER REWIND TAPE (OPEN OR CLOSE)
;	BIT  4 (   16.)	1=>OVERRIDE EXISTING FILE ON OUTPUT
;	BIT  5 (   32.)	1=>DO INITIAL REWIND BEFORE OPENING
;	BIT  6 (   64.)	1=>REWIND TAPE ON CLOSE
;	BIT  7 (  128.)	1=>OPEN FOR APPEND
;	BIT  9 (  512.)	1=>OPEN OUTPUT IN-PLACE
;	BIT 10 ( 1024.) 1=>Use /FILESIZE in place of /CLUSTERSIZE	;018
;				for the recordsize field  [ANSI only]	;018
;	BIT 13 ( 8192.)	1=>DO ANSI LABELING (IF BIT 14 = 1)
;	BIT 14 (16384.)	1=>OVERRIDE LABELING DEFAULT
;-

	FJMPDV	MT,OPN,ENTER		;MAGTAPE OPEN

	TSTB	MTDDCT+MTDDSP(R1)	;FILE ALREADY OPEN?
	BEQ	2$			;NO, SO ALL O.K.		;007
	ERROR	DTOOOF			;YES, SO ERROR

2$:	MOV	#16384.,R3		;Assume DOS open		;016
	TST	FQNAM1(R4)		;FILE-STRUCTURED?		;004
	BEQ	8$			;NFS, DON'T WORRY 'BOUT ANSI STUFF;004
	MOV	FQMODE(R4),R2		;GET MODE BITS			;004
	BPL	4$			;NONE SPECIFIED, USE DEFAULT	;004
	ASH	#2,R2			;SET C=OVERRIDE,N=LABELING	;004
	BCC	4$			;NO OVERRIDE, USE DEFAULT	;004
	BMI	6$			;ANSI OVERRIDE			;004
	BR	8$			;DOS OVERRIDE

4$:	BIC	#8192.,FQMODE(R4)	;Ensure ANSI flag is off	;016
	TSTB	MTDDSP+MTLBLI(R1)	;ANSI OR DOS DEFAULT?		;004
	BEQ	8$			;DOS, DON'T DO ANSI SAVES	;004
6$:	MOV	FQNENT(R4),FQPFLG(R4)	;SAVE POSITION			;004
	MOV	FQCLUS(R4),FQFLAG(R4)	;SAVE "CLUSTERSIZE" FOR ANSI
	BIS	#8192.,R3		;FLAG ANSI OPEN			;016
8$:	BIS	R3,FQMODE(R4)		;Save ANSI indicator in FIRQB	;016
	MOV	R1,FQCLUS(R4)		;SAVE DDB POINTER IN FIRQB
	MOV	R5,MTDDSP+MTJIOB(R1)	;STORE IOB ADDRESS IN DDB	;002
	CALLU	MTFIX			;LINE UP REGISTERS		;002

	BICB	#MT.OPN!MT.FS,MTOFLG(R4) ;Make sure all open flags are off ;010
	BIS	#DDSTAT,MTIDX(R4)	;INDICATE DEFAULTS NEED SETTING
	BIS	#DDUTIL,MTDDCT(R4)	;HOLD FOR UTILTIY SEQUENCE IN OPEN
	MOV	FQMODE-FQFIL(R1),(R1)	;SAVE THE MODE BITS
	BPL	20$			;NO MODE WAS SPECIFIED
	BIC	#100000,(R1)		;FORCE IN/OUT FLAG TO INPUT
	TST	(R3)			;FILE STRUCTURED? (FILENAME?)
	BNE	20$			;YES, SO NO DEN/PAR ALTERATIONS
	MOV	(R1),MTCNT(R4)		;NO, SET SUPPLIED MODE
	MOV	#DEN.MT,R2		;FUNCTION IS SET DENSITY/PARITY
	CALLU	MTCIO			;NOW DO IT			;002
20$:	TST	-(R3)			;PPN SUPPLIED?
	BNE	30$			;YES
	MOV	@#FIUSER,(R3)		;NO, SUPPLY CALLER'S OWN
30$:	MOV	#ECA.MT,R2		;Set error ack function		;015
	CALLU	MTCIO			;Issue it			;015
	MOV	#UNT.MT,R2		;SET FUNCTION AS READ STATUS
	CALLU	MTCIO			;GET THE STATUS			;002
	MOVB	#200+NOTAVL,R0		;MUDVR can give NOTAVL error	;012
	CMPB	MTLCEV(R4),#NOTAVL	;Let's find out if it did...	;012
	BEQ	50$			;Yep.  So get out of here now	;012
	MOV	MTCRET(R4),R5		;FETCH RETURNED STATUS
	MOVB	#200+MAGSEL,R0		;PRESET SELECT ERROR CODE
	BIT	R5,#40			;REALLY A SELECT ERROR?
	BNE	50$			;YES, SO QUIT
	TST	FQSWIT-FQFIL(R1)	;INPUT OR OUTPUT??
	BPL	40$			;IT IS INPUT
	BIS	#100000,(R1)		;IT IS OUTPUT, SET FLAG
	MOVB	#200+HNGDEV,R0		;PRESET WRITE LOCK ERROR
	BIT	R5,#2000		;REALLY WRITE LOCKED??
	BNE	50$			;YES, SO QUIT

GLOBAL	<FIUSER,MAGSEL,HNGDEV,NOTAVL>

40$:	TST	(R3)			;FILE STRUCTURED? (NAME SUPPLIED?)
	BNE	45$			;YES				;003
	FJMP	MTANFS			;NO, SO ALL DONE		;003

45$:	BISB	#MT.FS,MTOFLG(R4)	;YES, SO SET FILE STRUCTURED
	BIT	R5,#400			;TAPE AT BOT NOW??
	BNE	60$			;YES, NEVER AN INITIAL REWIND
	BIT	#40,(R1)		;DO AN INITIAL REWIND??
	BEQ	70$			;NOPE
	CALLU	MTARW			;DO IT				;004
	BEQ	70$			;DONE WITH NO ERROR
50$:	MOVB	R0,MTLCEV(R4)		;SAVE THE ERROR IN THE DDB
	CMP	-(R1),-(R1)		;FIX THE FIRQB POINTER
.ASSUME	FQFIL	EQ	4
	JMP	MTACEX			;NOW GO EXIT WITH ERROR

60$:	BIS	#40,(R1)		;SAY REWIND HAS BEEN DONE
70$:	BIT	#8192.,(R1)		;Did we flag DOS or ANSI open?	;016
	BNE	100$			;IT IS AN ANSI LABELED (FS) OPEN
	FJMP	DOSOPN			;IT IS A DOS LABELED (FS) OPEN

100$:	CMP	#9999.,FQPFLG-FQFIL(R1)	;VALIDATE FILE SECTION NUMBER	;004
	BHIS	105$			;IT'S OK			;003
	MOV	#200+BADNAM,R0		;SET ERROR			;003
	BR	50$			;GO TO COMMON ERROR EXIT	;003

105$:	MOV	R4,R2			;ANSI OPEN. COPY DDB POINTER
	BUFFER	GETSML,,20.		;GET A SMALL BUFFER FOR ACB
	BVC	110$			;SUCCESSFUL, SO CONTINUE
	MOV	R2,R4			;NO BUFFER. RESTORE THE DDB
	MOVB	#200+NOBUFS,R0		;SET THE ERROR CODE
	BR	50$			; AND GIVE AN ERROR

110$:	MOV	R4,MTACB(R2)		;SAVE THE ACB ADDRESS IN THE DDB
	BIT	#2000,(R1)		;Did they want big record mode?	;018
	BEQ	112$			; No				;018
	BIT	#7777,FQFLAG-FQFIL(R1)	; Yes, but is there a recordsize? ;018
	BNE	112$			;  Yes, so use it.		;018
	BIS	#AF.BIG,ACBFLG(R4)	;  No, so set big record flag	;018
112$:	MOV	FQPFLG-FQFIL(R1),ACBSEC(R4) ;SAVE FILE SECTION NUMBER IN ACB ;004
	BNE	115$			;NUMBER SPECIFIED		;003
	TST	(R1)			;INPUT?				;003
	BPL	115$			;YES				;003
	INC	ACBSEC(R4)		;DEFAULT = 1			;003
115$:	MOV	FQFLAG-FQFIL(R1),(R4)+	;PUT USER CHARACTERISTICS IN ACB
	.ASSUME	ACBCHR	EQ	0
	MOV	#^RHDR,(R4)+		;NEXT LABEL SET IS HDR
	MOV	(R3)+,(R4)+		;SAVE USER'S
	MOV	(R3)+,(R4)+		; FILE NAME
	MOV	(R3)+,(R4)+		;  IN ACB
	CMP	(R3),#18.		;REQUEST A TINY BUFFER SIZE?
	BGE	120$			;NOPE, USE REQUESTED SIZE
	MOV	#512.,(R3)		;YES tiny, (or >32767.)
					;  ADJUST TO A REASONABLE ONE
120$:	MOV	(R3),ACBSIZ-ACBVOL(R4)	;SAVE THE BLOCK SIZE IN THE ACB
	MOV	R2,R4			;RESTORE THE DDB POINTER
	MOV	#ANSOPN,FQFLAG-FQFIL(R1) ;SET RETURN FJMP AFTER HDR1 READ
	FJMP	GETHD1			;TRY TO GET A HDR1 LABEL

GLOBAL	<NOBUFS>

FQFEND

FQFSRT

.SBTTL	ANSI MAGTAPE OPEN

.ENABL	LSB

; LOOP BACK HERE FOR LOGICAL END OF TAPE

10$:	MOVB	#200+NOSUCH,R0	;PRESET THE CAN'T FIND IT ERROR
	TST	(R1)		;INPUT FILE?
	BPL	20$		;YES, REWIND OR GIVE ERROR
	TSTB	(R1)		;OUTPUT, IS IT APPEND?
	BMI	20$		;YES, CHECK FOR NEEDING A REWIND NOW
	CALL	90$		;NORMAL OUTPUT, CHECK FOR EOT
	BNE	30$		;ERROR IF AT EOT
	CALLU	MTABS		;ELSE BACKSPACE AND
	INC	ACBSEQ(R2)	; ADVANCE THE SEQUENCE NUMBER
	BR	80$		;  THEN WRITE OUT SOME LABELS

20$:	CALL	110$		;REWIND AND CONTINUE IF LEGAL
30$:	TST	ACBSEQ(R2)	;REALLY NOT THERE. IN DUMMY HDR LABELS?
	BNE	150$		;NOPE, REAL LEOT (FQBUFL = 0 FROM LEOT)
	SETERR	NOSUCH,R0	;YEP, SET CAN'T FIND AND REWIND
	BR	CMNMTR		; AND EXIT				;003

; COME HERE WHEN THE FILE NAME DOES NOT MATCH

40$:	CALL	110$		;REWIND AND RETRY IF LEGAL
	CALL	MTAFSE		;ELSE OPTIONAL SKIP OVER LABEL SET
	CALL	MTAFSI		;SKIP OVER FILE DATA
50$:	MOV	#ANSOPN,FQFLAG-FQFIL(R1) ;SET RETURN ADDRESS FOR READER
	FJMP	GETHD1		;GET THE NEXT HEADER LABEL SET

GLOBAL	<NOSUCH>

ANSOPN:	CALLU	MTFIX		;FIX REGISTERS, GET ACB & ERROR CODE
	TST	FQBUFL-FQFIL(R1) ;ARE WE AT LOGICAL END OF TAPE?
	BEQ	10$		;YES, ERROR IF INPUT, CREATE IF OUTPUT
	TST	(R1)		;NO. OPEN FOR INPUT OR OUTPUT?
	BPL	60$		;FOR INPUT
	BIT	#1000,(R1)	;FOR OUTPUT. DOES HE WANT CREATE IN-PLACE?
	BNE	70$		;YES, CREATE IT IN PLACE
60$:	MOV	R2,R5		;COPY THE ACB POINTER
	CMP	(R5)+,(R5)+	; AND INDEX TO THE FILE NAME
.ASSUME	ACBNAM	EQ	4
	CMP	(R3)+,(R5)+	;CHECK OUT THE NAME
	BNE	40$		;NO MATCH
	CMP	(R3)+,(R5)+
	BNE	40$
	CMP	(R3)+,(R5)+
	BNE	40$
	CMP	FQPFLG-FQFIL(R1),ACBSEC(R2) ;DO THE SECTION NO'S MATCH?	;003
	BEQ	65$		;IT MATCHES				;003
	MOV	#200+WRGPAK,R0	;PRESET ERROR				;003
	TST	ACBSEC(R2)	;IS THE SECTION NUMBER 0?		;003
	BCU	NE,MTERR	;NO, WRONG VOLUME			;003
	MOV	FQPFLG-FQFIL(R1),ACBSEC(R2) ;COPY THE SECTION NUMBER	;003
65$:	TST	(R1)		;FOUND IT! INPUT OR OUTPUT?
	BPL	120$		;INPUT, PROCEED WITH THE OPENING
	TSTB	(R1)		;OUTPUT, IS IT APPEND MODE?
	BMI	140$		;YES, GO DO APPENDING SKIPS
70$:	CALLU	MTABS		;FILE FOUND FOR OUTPUT. BACK UP TO HDR1
	CALLU	MTABS		;ONE MORE
	MOVB	#200+FIEXST,R0	;PRESET EXISTANCE ERROR
	BIT	#1000!20,(R1)	;CREATE IN-PLACE OR OVERRIDE IF PRESENT?
	BCU	EQ,MTERR	;NOPE, GIVE USER THE ERROR
	CALL	90$		;CHECK FOR EOT
	BCU	NE,MTERR	;YES, ERROR ALSO
80$:	CMP	ACBSEC(R2),#1	;IS THIS FILE SECTION 1			;003
	BEQ	85$		;YEP					;003
	CMP	ACBSEQ(R2),#1	;BETTER BE SEQUENCE NUMBER 1		;003
	BEQ	85$		;GOOD DEAL				;003
	MOV	#200+BADDIR,R0	;SAY BAD DIRECTORY			;003
CMNMTR:	BCU	R,MTERR		;OFF TO ERROR ROUTINE			;003

85$:	FJMP	ANSWLB		;GO WRITE ANSI LABELS

90$:	MOVB	#200+NOROOM,R0	;PRESET THE NOROOM ERROR
	BIT	#MTEOT,MTLCST(R4) ;SET Z-BIT = 0 IF AT EOT
100$:	RETURN			; AND EXIT

110$:	BIT	#40!2,(R1)	;HAS REWINDING BEEN DONE?
	BNE	100$		;YES, DONE ONCE OR FORBIDDEN BY USER
	BIS	#40,(R1)	;NO, BUT DON'T DO IT EVER AGAIN
	CALLU	MTARW		;REWIND THE TAPE NOW
	BR	50$		; AND RESTART THE SEARCH FROM BOT

GLOBAL	<FIEXST,WRGPAK,NOROOM>						;003

; HERE IF FILE FOUND FOR INPUT

120$:	CALL	MTAFSE		;OPTIONAL SKIP OVER LABEL SET
130$:	FJMP	MTAOAX		;EXIT FROM ANSI OPEN CODE

; HERE FOR FILE FOUND ON OPEN APPEND

140$:	CALL	MTAFSE		;OPTIONAL SKIP PAST THE LABEL SET
	CALL	MTAFSI		;PASS OVER THE DATA
	CALL	90$		;CHECK FOR EOT
	BCU	NE,MTERR	;YES, ERROR
	MOV	FQSIZ-FQFIL(R1),ACBCNT(R2) ;SET THE NUMBER OF DATA BLOCKS
	CALL	MTAFSI		;SKIP OVER THE EOF LABEL SET
	CALLU	MTAFS		;SKIP ONE MORE RECORD
	MOV	MTLCST(R4),FQBUFL-FQFIL(R1) ;REMEMBER THE STATUS HERE
	MOVB	#200+PRVIOL,R0	; AND THIS (MIGHT) BE THE ERROR
150$:	MOVB	R0,FQFLAG-FQFIL(R1) ;SAVE THE ERROR CODE
	CALLU	MTABS		;BACK OVER THAT SKIPPED RECORD
	CALLU	MTABS		;BACK OVER THE TAPE MARK ENDING EOF SET
160$:	CALL	MTABSI		;BACK OVER THE EOF LABEL SET
	BIT	#MTEOF,MTLCST(R4) ;DID WE REALLY GET THERE?
	BEQ	160$		;NOPE, TRY AGAIN
	BIT	#MTEOF,FQBUFL-FQFIL(R1) ;WAS THIS THE LAST FILE ON TAPE?
	BNE	130$		;YES, SET UP THE ACB & RETURN
	CALLU	MTAFS		;NO, POSITION AT A LABEL SET
	MOVB	FQFLAG-FQFIL(R1),R0 ;GET THE CORRECT ERROR
	BCU	R,MTERR		;GIVE THAT ERROR

.DSABL	LSB

GLOBAL	<PRVIOL>

.ENABL	LSB

; HANDLE MAGTAPE ERRORS

10$:	SETERR	NOSUCH,R0	;SET "NO MORE" AND REWIND UNIT

ENTERU	MTERR
	MOVB	R0,MTLCEV(R4)	;SAVE THE ERROR IN THE DDB
	CMP	-(R1),-(R1)	;LINE UP FIRQB POINTER
	FJMP	MTACEX		;EXIT FROM FIP WITH AN ERROR

.SBTTL	ANSI MAGTAPE DIRECTORY

ANSDIR:	CALLU	MTFIX		;FIX REGISTERS AND GET ERROR CODE
	TST	FQBUFL-FQFIL(R1) ;IS THE SEQUENCE NUMBER 0?
	BEQ	10$		;IF SO, WE ARE DONE
	CMP	FQPPN-FQFIL(R1),#-1 ;SPECIAL CALL NOT TO SKIP?
	BNE	20$		;NOPE, GO COMPUTE LENGTH
	INC	MTCNT(R4)	;SET COUNT = 2				;003
	CALLU	MTABS		;YES, BACK UP OVER THE "HDR1" & "HDR2" LABEL
	CLR	FQSIZ-FQFIL(R1)	;INDICATE SIZE OF 0
	BR	30$		;GO FINISH UP

20$:	CALL	MTAFSE		;OPTIONAL SKIP OVER LABEL SET
	CALL	MTAFSI		;SKIP DATA, COMPUTING LENGTH
30$:	MOVB	#6,FQNENT-FQFIL(R1) ;SIX ENTRIES RETURNED & USTAT=0
	CLR	R0		;NO ERROR NOW
	FJMP	MTADEX		;DIRECTORY EXIT 

.DSABL	LSB

.ENABL	LSB								;002
; DO A REWIND

ENTERU	MTARW
	MOV	#REW.MT,R2		;SET FUNCTION TO REWIND
	BCU	R,MTCIO			;GO DO IT			;002

; DO A FORWARD SPACE OF ONE RECORD

ENTERU	MTAFS
	MOV	#SKP.MT,R2		;SET FUNCTION TO SKIP FORWARD
	BCU	R,MTCIO			;GO DO IT			;002

;									;017
; Do an "infinite" backspace (up to 65535. records, or until we hit	;017
;  a tape mark).							;017
;									;017
;	Here, we tell the driver to backspace 0 records.  For		;017
;	non-TMSCP drivers, this has the same effect as passing a count	;017
;	of 65535.  For the TMSCP driver, this invokes the "backspace	;017
;	one tape mark" command.						;017
;									;017

MTABSI:	CLR	MTCNT(R4)		;Set count to 0.		;017


; DO A BACKSPACE OF 1 RECORD

ENTERU	MTABS
	MOV	#BSP.MT,R2		;SET FUNCTION TO BACKSPACE

; DO MAGTAPE I/O

ENTERU	MTCIO								;002
	MOV	(SP)+,FQADDR-FQFIL(R1)	 ;SAVE OUR RETURN ADDRESS	;002
	MOVU			;DO THE I/O				;002
5$:	MOV	R1,R3			;COPY BIASED FIRQB POINTER AND	;002
	CMP	(R3)+,(R3)+		; SET POINTER TO NAME.EXT	;002
.ASSUME	FQNAM1	EQ	FQFIL+4						;002
	MOV	MTACB(R4),R2		;GET THE ACB POINTER		;002
	MOV	#1,MTCNT(R4)		;PRESET A COUNT FOR NEXT TIME	;002
	MOVB	MTLCEV(R4),R0		;GET THE ERROR CODE		;002
	BEQ	10$			;NO ERROR, EXIT Z-BIT=1		;002
	CMPB	R0,#NOROOM		;ERROR, IS IT END OF TAPE?	;002
	BEQ	10$			;YES, EXIT Z-BIT=1		;002
	BCU	NE,MTERR		;ALL OTHER ERRORS ARE FATAL	;002
10$:	JMP	@FQADDR-FQFIL(R1)	

ENTERU	MTFIX
	CLRB	MTLCEV(R4)		;CLEAR ANY PREVIOUS ERRORS
	MOV	(SP)+,FQADDR-FQFIL(R1)		;SAVE OUR RETURN ADDRESS ;002
	BR	5$			;Continue on.			;017

.SBTTL	SKIP FORWARD FOREVER, COUNTING RECORDS

MTAFSE:	CMPB	R0,#EOF			;AT EOF ALREADY?
	BEQ	10$			;YEP, SIMPLY EXIT
MTAFSI:	MOV	(SP)+,FQFLAG-FQFIL(R1)	;SAVE RETURN ADDRESS
	MOV	#-1,FQSIZ-FQFIL(R1)	;Start at -1 to correct for EOF	;017
					; (which is counted as a record	;017
					; skipped but isn't included in	;017
					; the file size).		;017
	MOVB	#-1,<FQBUFL+1>-FQFIL(R1);MSB, too (for 24-bit math).	;017
20$:	NEG	MTCNT(R4)		;Change count of records to be	;017
					; skipped from 1 to -1 (MTAFS	;017
					; resets this to 1 every time).	;017
	CALLU	MTAFS			;Now, go do the skip.		;017
	COM	MTCRET(R4)		;Calculate number of records	;017
					; actually skipped ('COM n' is	;017
					; the same as '65535.-n').	;017
	ADD	MTCRET(R4),FQSIZ-FQFIL(R1)				;017
					;Add number of records skipped,	;017
	ADCB	<FQBUFL+1>-FQFIL(R1)	; both LSB and MSB.		;017
	BIT	#MTEOF,MTLCST(R4)	;Are we at EOF yet?		;017
	BEQ	20$			;No, so go skip some more.	;017
	JMP	@FQFLAG-FQFIL(R1)	;Otherwise, go back.		;017

.DSABL	LSB

GLOBAL	<NOROOM,EOF>

FQFEND

FQFSRT

.SBTTL	ANSI MAGTAPE UTILITY - READ HDR1/HDR2 LABELS

;+
; GETHD1 - GET INFORMATION FROM HDR LABELS.
;
;	R1 -> FIRQB @ FQFIL
;		FIRQB @ FQFLAG = RETURN FJMP ADDRESS
;	R4 -> DDB @ MTQPTR
;
;	FJMP	GETHD1
;
;	R0, R2, R3, R5 RANDOM
;
;	FIRQB IS LOADED AS FOLLOWS:
;
;	FQNAM1, FQEXT	= FILE NAME AND EXTENSION IN RAD50
;	FQSIZ		= RANDOM
;	FQBUFL		= FILE SEQUENCE NUMBER (0 IF NO MORE FILES)
;	FQPFLG		= FILE SECTION NUMBER
;	FQMODE		= CREATION DATE
;	FQNENT+1	= BUFFER OFFSET
;
;	IF AN ACB EXISTS (ADDRESS IN DDB @ MTACB), IT IS LOADED AS:
;
;	ACBVOL		= VOLUME ID IN ASCII
;	ACBSIZ		= BLOCK SIZE (F2.BLK)
;	ACBSID		= TRIAL CHARACTERISTICS AND RECORD LENGTH (F2.REC)
;	ACBSEQ		= SEQUENCE NUMBER OF LAST HDR OR EOF LABEL FOUND
;	+34		= RECORD TYPE (F2.FMT)
;	+35		= MODIFIER (F2.CTL)
;
;	IF A HEADER LABEL SET IS FOUND, THE TAPE IS LEFT POSITIONED
;		ONE RECORD PAST THE HDR1 (POSSIBLY AFTER AN EOF)
;		(I.E. HDR1 HDR2 ! *  OR  HDR1 * ! ... OR HDR1 ??? ! )
;
;	IF LEOT IF FOUND (SEQ # = 0), THE TAPE IS LEFT AFTER LEOT MARK
;		(2 TAPE MARKS) OR AFTER DUMMY HDR1 (SEQ#=0) FOR EMPTY TAPE
;-

;	NOTE:	THE ENTRY POINT IS FURTHER DOWN IN THE CODE.		;004
;		THIS IS TO ALLOW BRANCHES SO JUMPS AREN'T A NECESSITY.	;004
;		(RIGHT NOW THE OVERLAY NEEDS ALL THE WORDS IT CAN SAVE)	;004

.ENABL	LSB

40$:	MOV	R1,R5		;GOT A RECORD. COPY THE FIRQB POINTER
	CMP	(R5)+,(R5)+	; AND POINT TO FQNAM1 FOR THE NAME
.ASSUME	FQNAM1	EQ	FQFIL+4
	CALL	PACK1R		;PACK THE LABEL TYPE
	CMPB	(R0)+,#'1	;LABEL NUMBER SHOULD BE 1
	BNE	20$		;IF NOT, TRY FOR ANOTHER LABEL
	CMP	-(R5),#^RHDR	;IS IT A HEADER LABEL?
	BEQ	50$		;YES, FOUND HDR1
	SUB	#^REOF,(R5)	;NO, IS IT A TRAILER LABEL?
	BEQ	45$		;YES, IT IS AN EOF LABEL
	SUB	#^REOV-^REOF,(R5) ;IS IT AN EOV LABEL? (SAME AS EOF, TO US)
	BNE	20$		;NOPE, TRY AGAIN (MAYBE VOL, ETC.)
45$:	MOV	#2,FQSIZ-FQFIL(R1) ;AFTER CONVERTING, ALLOW 1 OR 2 EOF'S
50$:	MOV	(R5),-(SP)	;SAVE HDR/EOF INDICATION (0 => EOF)
	MOVB	F1.FSI-F1.FID(R0),-(SP) ;SAVE JUST BEYOND FILNAM.EXT AREA
	CLRB	F1.FSI-F1.FID(R0) ; AND ENSURE TERMINATION OF SCANS
	CALL	PACK2R		;PACK THE FILE NAME INTO FQNAM1/FQNAM1+2
	MOV	#^RDAT,(R5)+	;NO .EXT DEFAULTS TO ".DAT" IN FQEXT
60$:	TSTB	(R0)		;END OF FILNAM.EXT AREA?
	BEQ	70$		;YES, NO ".", SO ".DAT" GUESS WAS GOOD
	CMPB	(R0)+,#'.	;ELSE CHECK FOR "."
	BNE	60$		;NOT ".", CONTINUE LOOKING
	CLR	-(R5)		;"." FOUND, CLEAR OUT FQEXT
	CALL	PACK1R		; AND PACK INTO IT
70$:	MOV	MTUBUF(R4),R0	;GET THE ANSI LABEL POINTER AGAIN
	MOVB	(SP)+,F1.FSI(R0) ;RESTORE JUST BEYOND FILNAM.EXT AREA
	ADD	#F1.CRE+1,R0	;POINT TO CREATION DATE
	CMP	(R5)+,(R5)+	;POINT TO FQMODE IN FIRQB FOR THE DATE
.ASSUME	FQMODE	EQ	<<FQEXT+2>+4>
	CALL	PACK0D		;PACK 2 DIGITS, CLEARING ACCUMULATOR
	SUB	#70.,R3		;BIAS DOWNWARD FOR RSTS DATE REL 1970
	BHIS	80$		; IF VALID
	CLR	R3		;ELSE FORCE TO 1970
80$:	CALL	PACK3D		;PACK 3 MORE DIGITS FOR DAY OF YEAR
	MOV	R3,(R5)		;SET THE DATE IN THE FIRQB @ +22
	ADD	#F1.SEC-<F1.CRE+6>,R0 ;POINT TO SECTION NUMBER		;003
	CALL	PACK4D		;PACK 4 DIGITS				;004
	MOV	R3,FQPFLG-FQFIL(R1)	;SAVE SECTION NUMBER IN FQPFLG	;003
	CALL	PACK4D		;PACK 4 DIGITS				;004
	MOV	R3,-(R5)	;SAVE SEQUENCE NUMBER IN FQBUFL
.ASSUME	FQBUFL	EQ	FQMODE-2

	MOV	MTACB(R4),R5	;DONE WITH FIRQB. GET THE ACB POINTER
	BEQ	120$		;IF NO ACB, SKIP THE ACB FILL IN
	ADD	#ACBVOL,R5	;ELSE POINT TO VOLUME AREA IN ACB
	ADD	#F1.FSI-<F1.SEQ+4>,R0 ;WHICH WE WILL LOAD FROM F1
	MOV	#6,R2		;THERE ARE 6 CHARACTERS OF VOLUME NAME
90$:	MOVB	(R0)+,(R5)+
	SOB	R2,90$
	ADD	#F1.SYS-<F1.FSI+6>,R0 ;POINT TO SYSTEM NAME
	MOV	(R0)+,R2	;GET THE CREATING SYSTEM NAME
	SUB	#"OS,R2		;TAPE CREATED BY OS 360?
	BEQ	110$		;YES, FLAG = 0 AND F2.CTL IS VALID
	SUB	#"DE-"OS,R2	;NO, MAYBE CREATED BY A DEC SYSTEM?
	BNE	100$		;NOPE, A STRANGER
	CMPB	(R0),#'C	;REALLY DEC?
	BEQ	110$		;YUP, REALLY DEC
100$:	MOV	#030000,R2	;UNKNOWN SYSTEM - FORMAT U, UNDEFINED MODIFIER
110$:	CLR	34-<ACBVOL+6>(R5)	;PRE-CLEAR RECORD TYPE/MODIFIER
	TST	(R5)+		;SKIP BLOCK SIZE FOR NOW		;004
	MOV	R2,(R5)+	;SET THE SYSTEM ID CODE
.ASSUME	ACBSID EQ <ACBVOL+6+2>
	MOV	R3,(R5)+	;SAVE THE SEQUENCE NUMBER IN THE ACB
.ASSUME	ACBSEQ EQ <ACBSID + 2>
	MOV	#100.,(R5)	;GENERATION # AND VERSION ALWAYS 1 AND 0;004
.ASSUME	ACBGEN EQ <ACBSEQ + 2>
120$:	NEG	(SP)+		;SET C=0 IF JUST DID EOF1 LABEL (VALUE=0)
	BIT	R3,R3		;DID WE FIND THE DUMMY HDR1/EOF1 LABEL??
	BNE	125$		;NO					;003
	BCS	30$		;FOUND DUMMY HDR1, RETURN TO PROCESS
	CALLX	RETBIG,R5,MTULBF ;FOUND DUMMY EOF1, RETURN THE BIG BUFFER
	MOV	#REW.MT,R2	;SET FUNCTION AS REWIND
	MOVPIC	#GETHD1,-(SP)	;PUSH A RETURN ADDRESS (PIC)
	JMP	DUMREW		; AND GO REWIND THE TAPE, RETURNING TO GETHD1

GETHD1:	CLR	FQSIZ-FQFIL(R1)	;FLAG SAYING EOF NOT LEGAL HERE
	CLR	MTUBUF(R4)	;DON'T RETURN A BUFFER WE DON'T HAVE ONE
20$:	CLR	FQBUFL-FQFIL(R1) ;SET SEQUENCE # IN FIRQB = 0 IF EOF
	CALLU	MTCIO		;READ LABEL, GETTING BUFFER		;002
	BEQ	40$		;READ WAS SUCCESSFUL
	CMPB	R5,#EOF		;DID WE FIND EOF?
	BNE	130$		;NO EOF, A REAL ERROR
	SETERR	BADDIR,MTLCEV(R4) ;PRESET BAD DIRECTORY ERROR & REWIND
	DEC	FQSIZ-FQFIL(R1)	;DID WE EXPECT EOF'S (AFTER EOF LABEL)?
	BMI	130$		;NO, RETURN ERROR TO THE USER
	BNE	20$		;YES, TRY FOR THE HDR1 AFTER EOF LABELS
	;BEQ	30$		;TWO TAPE MARKS MEAN LOGICAL EOT
30$:	CALLX	RETBIG,R5,MTULBF ;RETURN THE BIG BUFFER
	MOV	FQFLAG-FQFIL(R1),R5 ;GET THE RETURN ADDRESS
	FJMP	(R5)		;BACK TO CALLER WITH LABEL OR END

GLOBAL	<EOF>

125$:	BCC	20$		;REAL EOF1 LABEL (C=0), TRY FOR A HDR1
	CALLU	MTCIO		;WE CAN USE HDR2 DATA			;002
	BEQ	140$		;READ WAS SUCCESSFUL
	CMPB	R5,#EOF		;NOPE. END OF FILE?
	BEQ	30$		;YES, WE ARE AT EOF, SO RETURN TO CALLER
130$:	CALLX	RETBIG,R5,MTULBF ;RETURN THE BIG BUFFER ON ERRORS
	CMP	-(R1),-(R1)	;LINE UP FIRQB POINTER
	FJMP	MTACEX		;RETURN ERROR TO USER

GLOBAL	<EOF>

140$:	MOV	(R0)+,-(SP)	;GET THE FIRST WORD OF THE LABEL
	SUB	#"HD,(SP)	;CHECK
	MOV	(R0)+,-(SP)	; FOR
	SUB	#"R2,(SP)	;  "HDR2"
	BIS	(SP)+,(SP)+	;ARE THE FIRST 2 WORDS "HDR2" ?
	BEQ	145$		;YES					;003
	JMP	30$		;NO, RETURN TO PROCESS			;003

145$:	MOV	MTACB(R4),R5	;POINT TO THE ACB
	BEQ	150$		;NO ACB					;003
;004+
;NOTE	SINCE THERE IS AN ACB, THE FIP FUNCTION MUST BE OPN, NOT DIR
;	IF THE OPEN IS FOR INPUT, THEN WE NEED THE INFO FROM THE LABEL
;	IF FOR APPEND OUTPUT, THEN WE NEED THE INFO FROM THE LABEL
;	IF WE'RE CREATING A NEW FILE, THEN THE ACB IS STORED FROM THE
;		FIRQB AND CANNOT BE DESTROYED!
;
	TST	(R1)		;WAS THE OPEN MODE FOR INPUT?
	BPL	147$		;YES, SO UNPACK THE LABEL
	TSTB	(R1)		;OUTPUT, APPEND MODE?
	BPL	150$		;NO, SO DON'T DESTROY THE ACB!
;004-
147$:	MOVB	(R0)+,34(R5) 	;SAVE F2.FMT IN ACB @ +34
	CALL	PACK5D		;CONVERT BLOCK SIZE
	MOV	R3,ACBSIZ(R5)	; AND SAVE IT				;004
	CALL	PACK5D		;CONVERT RECORDSIZE
	BIC	#^C<7777>,R3	;GET IT TO A RANGE WE CAN BELIEVE
	BIS	R3,ACBSID(R5)	;SAVE RECORDSIZE IN THE ACB @ +ACBSID	;004
	MOV	ACBSID(R5),(R5)	;NOW COPY TO CHARACTERISTICS WORD	;004
	MOVB	F2.CTL-<F2.REC+5>(R0),35(R5) ;SAVE F2.CTL IN ACB @ +35	;004
150$:	MOV	MTUBUF(R4),R0	;POINT TO ANSI LABEL BUFFER		;003
	ADD	#F2.BFO,R0	;POINT TO BUFFER OFFSET FIELD		;003
	CALL	PACK2D		;PACK TWO DIGITS			;003
	MOVB	R3,<FQNENT+1>-FQFIL(R1)	;STORE IT AT FQNENT+1		;003
	JMP	30$		;DONE

.DSABL	LSB

; DO DECIMAL PACKING (ASCII -> BINARY)

.ENABL	LSB

PACK5D:	CALL	PACK0D		;TO DO 5, CLEAR AND DO 2
PACK3D:	CALL	PACK2D		;DO 2 MORE
	BR	PACK1D		;DO 1 MORE

PACK4D:	CALL	PACK0D		;TO DO 4, CLEAR AND DO 2		;004
	BR	PACK2D		; THEN 2 MORE				;004
PACK0D:	CLR	R3		;PRECLEAR THE ACCUMULATOR
PACK2D:	MOV	PC,-(SP)	;DO THE FOLLOWING TWICE
PACK1D:	MOVB	(R0)+,R2	;GET A BYTE
	SUB	#'0,R2		;MAKE IT NUMERIC
	MUL	#10.,R3		;SHIFT DECIMAL
	BR	60$		; AND ACCUMULATE

; DO RADIX 50 PACKING (ASCII -> RAD50)

PACK2R:	MOV	PC,-(SP)	;DO THE FOLLOWING TWICE
PACK1R:	CLR	R3		;CLEAR RAD50 ACCUMULATOR
	CALL	10$		;SCAN 2 CHARACTERS
	CALL	20$		;SCAN A THIRD
	MOV	R3,(R5)+	;SET THE WORD IN THE OUTPUT AREA
	RETURN

10$:	MOV	PC,-(SP)	;DO THE FOLLOWING TWICE
20$:	MOVB	(R0),R2		;GET THE BYTE
	SUB	#'A,R2		;MAKE A-Z INTO 0-31
	CMP	R2,#'Z-'A	;WITHIN RANGE?
	BLOS	40$		;YES
	SUB	#'0-'A,R2	;MAKE 0-9 INTO 0-9
	CMP	R2,#'9-'0	;WITHIN RANGE?
	BLOS	30$		;YES
	CLR	R2		;MAKE IT A SPACE
	BR	50$		;WHICH WE IGNORE?

30$:	ADD	#36-1,R2	;CORRECT THE NUMERICS
40$:	CMPB	(R2)+,(R0)+	;BUMP LETTER OR DIGIT, ADVANCE POINTER
50$:	MUL	#50,R3		;SHIFT RADIX 50
60$:	ADD	R2,R3		;ADD IN THE NEW LOW DIGIT
	RETURN

.DSABL	LSB

; DO MAGTAPE I/O

ENTERU	MTCIO								;002
	MOV	#RED.MT,R2	;SET FUNCTION AS READ			;002
	MOV	#ANSLBL,MTCNT(R4) ;SET COUNT IN THE DDB			;004
DUMREW:	MOV	(SP)+,FQADDR-FQFIL(R1)	;SAVE OUR RETURN ADDRESS	;002
	MOVU			;DO THE I/O				;002
	MOV	MTUBUF(R4),R0	;POINT TO THE ANSI LABEL BUFFER		;002
	MOVB	MTLCEV(R4),R5	;GET THE ERROR CODE			;002
	JMP	@FQADDR-FQFIL(R1)

FQFEND

FQFSRT

.SBTTL	ANSI MAGTAPE OUTPUT CLOSE

ANSCLS:	CMP	(R1)+,(R1)+	;BIAS R1 PROPERLY
.ASSUME	FQFIL	EQ	4

.SBTTL	ANSI MAGTAPE UTILITY - WRITE LABELS

ANSWLB:	CLR	MTUBUF(R4)	;NO BUFFER IS OWNED UPON ENTRY
	CLRB	MTLCEV(R4)	;MAKE SURE THERE IS NO ERROR		;002
	CALLU	MTFIX		;SET REGISTERS, POINT INTO ACB
	CMP	(R5),#^RHDR	;WRITING HDR LABELS?			;003
	BEQ	10$		;YES
	CALLU	MTAWE		;NO, WRITE A TAPE MARK
10$:	MOV	#GBF.MT,R2	;FUNCTION IS GET A BUFFER
	CALLU	MTCIO		;DO IT					;002
	CALL	LBLCLR		;CLEAR THE LABEL BUFFER AND
	;CALL	UNPRD1		;UNPACK THE LABEL TYPE INTO THE BUFFER
	MOVB	#'1,(R0)+	;MAKE IT 'HDR1' OR 'EOF1' OR 'EOV1'
	CALL	UNPRD2		;UNPACK 2 WORDS OF FILE NAME
	MOVB	#'.,(R0)+	;SIGNAL AN EXTENSION
	CALL	UNPRD1		; AND GIVE IT ONE
	MOV	MTUBUF(R4),R0	;RESTORE THE LABEL BUFFER
	ADD	#F1.FSI,R0	; AND INDEX TO THE VOLUME ID
	MOV	#6,R3		;SIX BYTES TO INSTALL
20$:	MOVB	(R5)+,(R0)+
	SOB	R3,20$
	ADD	#ACBSEC-20,R5	;OFFSET TO SECTION NUMBER		;004
	CALL	UNPD,R1,4	;SET 4-DIGIT SECTION #, 4-DIGIT SEQ #	;003
	SUB	#ACBSEC+2-ACBSEQ,R5 ;BACK TO SEQUENCE NUMBER		;004
	CALL	UNPD,R1,4
	MOV	#100.,(R5)	;GENERATION IS 0001, GVN IS 00
	CALL	UNPD,R1,6	;SET A 6-DIGIT NUMBER
	CALL	UNPDT2		;SET CREATION DATE, THEN EXPIRATION DATE
	INC	R0		;SKIP ACCESSIBILITY (BLANK)
	CALL	UNPD,R1,6	;BLOCK COUNT IS A 6-DIGIT NUMBER
	CALL	30$,R3		;GET A TEXT POINTER
	  .NLIST BEX
	  .ASCIZ "DECRSTS/E"	;OUR IDENTIFICATION
	  .LIST	 BEX
	  .EVEN
30$:	MOVB	(R3)+,(R0)+	;MOVE IDENTIFICATION INTO BUFFER
	BNE	30$		;UNTIL DONE
	MOVB	(R0),-(R0)	;FIX NULL TO BE BLANK
	CALL	WRTLBL		;WRITE THE LABEL AT THE RIGHT LENGTH

	CALL	LBLCLR		;CLEAR LABEL OUT AGAIN
	;CALL	UNPRD1		;UNPACK THE LABEL TYPE INTO THE BUFFER
	MOVB	#'2,(R0)+	;MAKE IT 'HDR2' OR 'EOF2'
	MOV	#"00,F2.BFO-F2.FMT(R0) ;BUFFER OFFSET IS 0
	INC	R0		;SKIP FORMAT (FOR NOW)
	ADD	#ACBSIZ-<ACBTYP+2>,R5 ;POINT TO BLOCK SIZE WORD
	MOV	(R5),ACBSID-ACBSIZ(R5) ;assume block size = recordsize	;018
	CALL	UNPD,R1,5	;UNPACK IT AS A 5-DIGIT NUMBER
.ASSUME	ACBSID EQ <ACBSIZ + 2>
	BIT	#AF.BIG,ACBFLG-<ACBSIZ+2>(R5) ;ask for block=record?	;018
	BNE	34$		; yes, leave it alone			;018
	MOV	ACBCHR-<ACBSIZ+2>(R5),(R5) ;No, GET CHARACTERISTICS
	BIC	#^C<7777>,(R5)	;LEAVE ONLY THE RECORD SIZE
34$:	CALL	UNPD,R1,5	;UNPACK RECORD SIZE AS 5 DIGITS		;018
	CALL	SETBYT,R1	;SET THE FORMAT CHARACTER
	  .WORD	-14.		;SHIFT FOR THESE BITS
	  .WORD	F2.FMT-<F2.REC+5> ;OFFSET TO THIS POSITION
	  .BYTE	'U,'F,'D,'S	;FORMATS 0, 1, 2, 3
	CALL	SETBYT,R1	;SET THE MODIFIER CHARACTER
	  .WORD	-12.		;SHIFT FOR THESE BITS
	  .WORD	F2.CTL-F2.FMT	;OFFSET TO THIS POSITION
	  .BYTE	'M,'A,40,40	;MODIFIERS 0, 1, 2, 3
	CALL	WRTLBL		;WRITE THE LABEL
	CALLX	RETBIG,R5,MTULBF ;RELEASE THE BIG BUFFER
	CMP	(R5),#^RHDR	;DID WE JUST WRITE HDR LABELS?		;003
	BEQ	40$		;YES					;003
	CMP	-(R1),-(R1)	;FIX FIRQB POINTER FOR CLOSE EXIT
.ASSUME	FQFIL	EQ	4
	MOV	#5,FQFLAG(R1)	;SET COUNTER FOR 5 BACKSPACES (AFTER EOF'S)
	FJMP	MTACEA		;FINISH UP THE CLOSE OR ZERO

40$:	CALLU	MTAWE		;WRITE 1 TAPE MARK AFTER HDR2
	MOV	#^REOF,(R5)	;SHIFT TO WRITE EOF LABELS LATER
	TST	ACBSEQ-ACBTYP(R5) ;IS THIS THE DUMMY ZEROING FILE?
	BEQ	ANSWLB		;YES, WRITE THE TRAILER LABELS NOW
	CLR	FQSIZ-FQFIL(R1)	;JUST WROTE HDR LABELS, SO SIZE IS 0
	MOV	ACBSIZ-ACBTYP(R5),FQBUFL-FQFIL(R1) ;SET TRUE BUFFER SIZE
	FJMP	MTAOEX		;FINISH UP THE OPEN FOR OUTPUT

; GET A BYTE INTO THE LABEL

SETBYT:	MOV	ACBCHR-<ACBSIZ+4>(R5),R2 ;GET THE CHARACTERISTICS
	ASH	(R1)+,R2	;SHIFT TO GET RELEVANT BITS
	BIC	#^C<3>,R2	;ISOLATE TWO BITS
	ADD	(R1)+,R0	;POINT TO PROPER BYTE IN BUFFER
	ADD	R1,R2		;POINT TO BYTE IN TABLE
	MOVB	(R2),(R0)	; AND PUT IT IN THE BUFFER
	CMP	(R1)+,(R1)+	;SKIP OVER THE TABLE
	RETURN	R1		; AND OUT

.ENABL	LSB

;
; UNPD		Convert an integer into a string.
; UNPDR3	Convert an integer passed in R3 into a string.
;
; Calling seq:	CALL	UNPD,R1,<Number of digits in output string>
;		CALL	UNPDR3,R1,<Ibid>
;
; Data passed:	UNPD	R5 -> integer to convert
;		UNPDR3	R3 = integer to convert
;		Both	R1 -> Number of digits in the output string.
;
; Data return:	UNPD	R5 points to the next word.
;		Both	R0 points after the string in output buffer.
;			R2, R3 are scratched.
;			R4 is preserved.
;

UNPD:	MOV	(R5)+,R3	;Get the number to unpack.
UNPDR3:	MOV	R4,-(SP)	;Get a scratch register.
	MOV	(R1),R4		;Get the # of digits (we will need it again).
10$:	CLR	R2		;Create digits from right to left by dividing
	DIV	#10.,R2		; by ten.
	ADD	#'0,R3		;Take the remainder and make it a sting.
	MOV	R3,-(SP)	;Store each digit on the stack (output later).
	MOV	R2,R3		;The quotient now becomes the number.
	SOB	R4,10$		;Back for another digit.
	MOV	(R1)+,R4	;Get the number of digits again.
20$:	MOVB	(SP)+,(R0)+	;Put the digits into the output buffer in
	SOB	R4,20$		; the correct order.
	MOV	(SP)+,R4	;Restore the saved register.
	RETURN	R1		;And back to our caller.


UNPDT2:	MOV	PC,-(SP)	;UNPACK THE DATE TWICE
	INC	R0		;DATE STARTS WITH A BLANK
	MOV	@#DATE,R3	;GET THE DATE
	CALL	UNPDR3,R1,5	;GO CONVERT IT
	MOVB	-5(R0),R3	;GET TENS OF YEAR
	ADD	#7,R3		;CORRECT IT FOR 1970
	MOVB	R3,-5(R0)	;RESET IT
	RETURN

.DSABL	LSB

; CLEAR THE LABEL

LBLCLR:	MOV	R0,R2		;COPY THE LABEL POINTER
	MOV	#ANSLBL/2,R3	;COUNT TO CLEAR
10$:	MOV	#40*400+40,(R2)+ ;SET SPACES
	SOB	R3,10$
	BR	UNPRD1		;Now unpack the label.

;	RADIX 50 CONVERSION

UNPRD2:	MOV	PC,-(SP)	;DO THE BELOW TWICE
UNPRD1:	MOV	(R5)+,R3	;GET THE WORD TO CONVERT
	CALL	10$,R5,<50*50,50,1> ;DO THE CONVERSION
.ASSUME	<<50*50!50!1>&200>	EQ	0
	RETURN

10$:	CLR	R2		;CLEAR THE HIGH ORDER
	DIV	(R5)+,R2	; AND DIVIDE
	BEQ	30$		;0 IS SPACE, IGNORE THAT
	ADD	#100,R2		;GUESS AT ALPHA CORRECTION
	CMP	R2,#'Z		;REALLY ALPHA?
	BLOS	20$		;YES
	ADD	#'0-36-100,R2	;NO, CORRECT FOR DIGIT
20$:	MOVB	R2,(R0)+	;STORE THE CHARACTER
30$:	TSTB	(R5)		;MORE? (HEAP BIG MAGIC HERE, TOO!)
	BPL	10$		;YES
	RETURN	R5

; WRITE A TAPE MARK

ENTERU	MTAWE
	MOV	#EOF.MT,R2		;FUNCTION IS WRITE EOF
	BCU	R,MTCIO			;DO IT				;002

; WRITE AN ANSI LABEL BUFFER

WRTLBL:	MOV	#ANSLBL,MTCNT(R4)	;SET THE COUNT TO WRITE
	MOV	#WRT.MT,R2		;FUNCTION IS WRITE

.ENABL	LSB
; DO MAGTAPE I/O

ENTERU	MTCIO								;002
	MOV	(SP)+,FQADDR-FQFIL(R1)	;SAVE OUR RETURN ADDRESS	;002
	MOVU				;DO THE I/O			;002
5$:	MOV	MTUBUF(R4),R0		;GET BIG BUFFER POINTER		;002
	MOV	MTACB(R4),R5		;GET ACB POINTER		;002
	TST	(R5)+			; @ ACBTYP			;002
	MOVB	MTLCEV(R4),R2		;GET THE ERROR CODE		;002
	BEQ	10$			;NO ERROR, EXIT Z-BIT=1		;002
	CMPB	R2,#NOROOM		;IS IT END-OF-TAPE?		;002
	BNE	30$			;NO, QUIT			;002
	;BEQ	10$			;CONTINUE IF NO ERROR		;002
10$:	JMP	@FQADDR-FQFIL(R1)

30$:	CALLX	RETBIG,R5,MTULBF	;RETURN THE BIG BUFFER		;002
	CMP	-(R1),-(R1)		;FIX R1				;002
.ASSUME	FQFIL	EQ	4						;002
	FJMP	MTACEX			;EXIT GIVING ERROR		;002

ENTERU	MTFIX								;002
	MOV	(SP)+,FQADDR-FQFIL(R1)	;SAVE OUR RETURN ADDRESS	;002
	BR	5$			;CONTINUE ON			;018

GLOBAL	<NOROOM>
.DSABL	LSB			
FQFEND

FQFSRT

.SBTTL	ANSI MAGTAPE ZERO

ANSZER:	CMP	(R1)+,(R1)+	;BIAS THE FIRQB POINTER
.ASSUME	FQFIL	EQ	4
	MOV	#GBF.MT,R2	;FIRST, GET A LABEL BUFFER
	CALLU	MTCIO							;002
	MOV	R0,R2		;COPY THE LABEL BUFFER POINTER
	MOV	#ANSLBL/2,R3	;SIZE IN WORDS
10$:	MOV	#40*400+40,(R2)+ ;BLANK-FILL THE BUFFER
	SOB	R3,10$
	MOVB	#'3,-(R2)	;LABEL-STANDARD LEVEL = 3
	MOV	#"VO,(R0)+	;TYPE IS VOL1
	MOV	#"L1,(R0)+
	SETERR	BADNAM,R2	;PRESET THE NAME ERROR
	MOV	FQNAM1-FQFIL(R1),R3 ;GET FIRST WORD OF VOLUME LABEL
	BCU	EQ,MTERR	;IF NULL, THAT'S AN ERROR
	CALL	SETVID		;SET NAME IN BUFFER
	MOV	FQNAM1+2-FQFIL(R1),R3 ;SET SECOND WORD OF NAME
	CALL	SETVID		; INTO THE BUFFER
	SETERR	NOBUFS,R2	;PRESET AN ERROR
	MOV	R4,R3		;COPY THE DDB POINTER
	BUFFER	GETSML,,20.	;GET AN ACB FOR US
	BVS	40$		;OOPS, NO BUFFERS

	MOV	R4,MTACB(R3)	;SAVE THE ACB POINTER IN THE DDB
	CLR	(R4)+		;DUMMY FILE HAS NO CHARACTERISTICS
	MOV	#^RHDR,(R4)	;SET TO WRITE HEADER LABELS
	ADD	#<ACBVOL+6>-ACBTYP,R4 ;POINT TO VOLUME ID IN FCB
	MOV	#6,R2		;GET A COUNTER
20$:	MOVB	-(R0),-(R4)	;COPY THE VOLUME ID INTO THE ACB
	SOB	R2,20$
	MOV	R3,R4		;RESTORE THE DDB POINTER
	ADD	#V1.OWN-V1.VID,R0 ;INDEX TO SYSTEM ID CODE
	MOVB	#'D,(R0)+	;OUR ID IS:
	MOV	#"%B,(R0)+	; D%B
	MOV	#"44,(R0)+	;OUR PROTECTION IS:
	MOV	#"31,(R0)+	; 4431
	MOV	FQPPN-FQFIL(R1),-(SP) ;GET THE PPN SUPPLIED
	BNE	30$		; IF ANY
	MOV	@#FIUSER,(SP)	;ELSE USE CALLER'S PPN
30$:	CALL	SETPPN		;SET PROJECT
	CALL	SETPPN		;SET PROGRAMMER
	TST	(SP)+		;DUMP THE PPN
	MOVB	#'1,(R0)+	;DEC LABEL-STANDARD REVISION
	MOV	#ANSLBL,MTCNT(R4) ;SET THE COUNT FOR LABEL WRITING
	MOV	#WRT.MT,R2	;FUNCTION IS WRITE
	CALLU	MTCIO		;DO IT					;002
	CALLX	RETBIG,R5,MTULBF ;RETURN THE LABEL BUFFER
	FJMP	ANSWLB		;THEN WRITE OUT THE DUMMY FILE LABELS

40$:	MOV	R3,R4		;RESTORE THE DDB POINTER
	;BCU	MTERR

GLOBAL	<FIUSER>

; HANDLE MAGTAPE ERRORS

ENTERU	MTERR
	CALLX	RETBIG,R5,MTULBF ;RETURN THE BIG BUFFER (IF ANY)
	MOVB	R2,MTLCEV(R4)	;SET THE ERROR IN THE DDB
	CMP	-(R1),-(R1)	;FIX THE FIRQB POINTER
.ASSUME	FQFIL	EQ	4
	FJMP	MTACEX		;EXIT WITH THE ERROR

.ENABL	LSB

SETPPN:	SWAB	2(SP)		;SWITCH BYTES
	CLR	R3		;GET THE LOW BYTE
	BISB	2(SP),R3	; WITH NO SIGN EXTEND
	MOV	#36,R5		;THIS IS THE CORRECTION FACTOR
	CALL	10$,R5,<100.,10.,1.>
	RETURN

SETVID:	CLR	R5		;THIS IS THE CORRECTION FACTOR
	CALL	10$,R5,<50*50,50,1>
	RETURN

10$:	CLR	R2		;CLEAR THE HIGH ORDER
	DIV	(R5)+,R2	; AND DIVIDE
	ADD	(SP),R2		;ADD IN THE CORRECTION FACTOR
	BNE	20$		;<>0, SO NEVER SPACE
	MOV	#40-100,R2	;ZERO, SO SPACE
20$:	ADD	#100,R2		;NOW ALPHAS AND SPACE ARE CORRECT
	CMP	R2,#'Z		;IS IT REALLY NUMERIC?
	BLOS	30$		;NO
	ADD	#'0-36-100,R2	;YES, MAKE IT A VALID ASCII NUMBER
30$:	MOVB	R2,(R0)+	;STORE IT
	TSTB	(R5)		;MORE TO GO?
	BPL	10$		;YES
	RETURN	R5		;NO

.DSABL	LSB

; DO MAGTAPE I/O

ENTERU	MTCIO								;002
	MOV	(SP)+,FQADDR-FQFIL(R1)	;SAVE OUR RETURN ADDRESS	;002
	MOVU				;DO THE I/O			;002
	MOV	MTUBUF(R4),R0		;GET BIG BUFFER POINTER		;002
	MOV	MTACB(R4),R5		;GET ACB POINTER		;002
	MOVB	MTLCEV(R4),R2		;GET THE ERROR CODE		;002
	BEQ	10$			;NO ERROR, EXIT Z-BIT=1		;002
	CMPB	R2,#NOROOM		;IS IT END OF TAPE ERROR?	;002
	BEQ	10$			;YES, IGNORE, EXIT Z-BIT=1	;002
	BCU	NE,MTERR		;ALL ERRORS EXCEPT NOROOM ARE FATAL ;002
10$:	JMP	@FQADDR-FQFIL(R1)	

GLOBAL	<NOROOM>							;002

.SBTTL	NON-FILE STRUCTURED MAGTAPE OPEN

MTANFS:	CLR	FQSIZ-FQFIL(R1)		;INDICATE FILE SIZE IS 0

; DOS LABELED OPEN DONE

MTA512:	MOV	#512.,FQBUFL-FQFIL(R1)	;SET THE DEFAULT BUFFER LENGTH

; OPEN DONE - FINISH UP

MTAOEX:	MOV	#DDWLO,R5		;GUESS A READ-ONLY FILE
	TST	(R1)			;GOOD GUESS??
	BPL	10$			;YES
	ASR	R5			;NO, WRITE-ONLY FILE
.ASSUME	DDRLO	EQ	DDWLO/2
10$:	BISB	#MT.OPN,MTOFLG(R4)	;NOW SAY FILE IS OPEN
	BMI	20$			;BRANCH OUT IF FILE STRUCTURED
	BIC	#DDWLO,R5		;NON-FILE STRUCTURED IS NEVER WRITE LOCKED
20$:	BIC	#DDWLO!DDRLO,MTIDX(R4)	;CLEAR WRITE/READ LOCKS
	BIS	R5,MTIDX(R4)		; AND SET THE CORRECT LOCK (IF ANY)
	TSTB	MTOFLG(R4)		;NON-FILE STRUCTURED?
	BMI	30$			;NOPE
	BIS	#DDNFS,R5		;YEP, SO SAY SO
30$:	BIS	#MTAHND,R5		;.OR. IN THE HANDLER IDEX
	MOV	R5,FQFLAG-FQFIL(R1)	; AND SET THE FIRQB FLAG WORD
	ASLB	(R1)			;CHECK CLOSE REWIND STATUS
	BMI	40$			;BIT 6 => ALWAYS REWIND ON CLOSE
	BISB	#MT.NRW,MTFLAG(R4)	;NOW SET NO REWIND ON CLOSE	;013
.ASSUME	MT.NRW	EQ	1
40$:	MOV	FQCLUS-FQFIL(R1),@MTJIOB(R4) ;POINT IOB TO THE DDB
	INCB	MTDDCT(R4)		; AND COUNT AS AN OPEN FILE
	BIC	#DDUTIL,MTDDCT(R4)	;NO LONGER UTILITY, SINCE TRULY OPEN
	CLR	FQPROT-1-FQFIL(R1)	;SAY PROT=0 AND CLUSTER=0
	MOV	FQSIZ-FQFIL(R1),MTBCNT(R4) ;SET # BLKS AS FILE'S SIZE
	MOV	MTACB(R4),R5		;GET ACB POINTER (IF ANY)
	BEQ	50$			;NO ACB, CHARACTERISTICS=0
	MOV	ACBSEC(R5),FQSIZ-FQFIL(R1) ;RETURN SECTION NUMBER TO USER ;003
	MOV	(R5),R5			;ACB, GET REAL CHARACTERISTICS
50$:	MOV	R5,FQCLUS-FQFIL(R1)	;RETURN CHARACTERISTICS FOR USER
	BIC	#MTEOF,MTLCST(R4)	;SAY NOT YET AT EOD WITHIN FILE
	RETURN				;FINAL EXIT, ALL OPEN


; ANSI LABELED OPEN DONE

MTAOAX:	MOV	ACBCNT(R2),FQSIZ-FQFIL(R1) ;GIVE USER FILE SIZE (APPEND) ;003
	MOV	ACBSIZ(R2),FQBUFL-FQFIL(R1) ;GIVE USER THE BUFFER SIZE	;004
	MOV	ACBSID(R2),(R2)		;SET TRUE RECORD LENGTH		;004
	CALL	20$,R1			;GO FILL IN THE RECORD TYPE
	  .BYTE	'U,'F,'D,'S		; TABLE OF TYPE CHARACTERS
	  .WORD	ACBRTY			; ACB OFFSET TO TYPE CHARACTER
	  .WORD	14.			; SHIFT VALUE
	BIT	(R2),#030000		;DOES MODIFIER (F2.CTL) HAVE MEANING?
	BEQ	5$			;Yes.				;014
	BIC	#030000,(R2)		;No.  So return 0 by default	;014
	BR	10$			;And don't try to decode it	;014

5$:	CALL	20$,R1			;Fill in the modifier code	;014
	  .BYTE	'M,'A,40,40		; TABLE OF MODIFIER CHARACTERS
	  .WORD	ACBMOD			; ACB OFFSET TO MODIFIER CHARACTER
	  .WORD	12.			; SHIFT VALUE
10$:	MOV	#^REOF,ACBTYP(R2)	;NEXT LABEL SET TO WRITE IS EOF
	BR	MTAOEX			;NOW FINISH UP

20$:	MOV	R1,R0			;GET TABLE OF CHARACTERS POINTER
	CMP	(R1)+,(R1)+		; THEN SKIP OVER THE TABLE
	ADD	(R1),R2			;INDEX TO CORRECT BYTE IN THE ACB
	MOV	#-4,R3			;COUNT UP BOTTOM 2 BITS
30$:	CMPB	(R2),(R0)+		;MATCH?
	BEQ	40$			;YES
	INC	R3			;NO, COUNT MORE?
	BNE	30$			;KEEP COUNTING...
40$:	BIC	#^C<3>,R3		;ISOLATE THE BOTTOM 2 BITS
	SUB	(R1)+,R2		;RE-INDEX BACK TO TOP OF THE ACB
	ASH	(R1)+,R3		;SHIFT BITS TO CORRECT LOCATION
	BIS	R3,(R2)			; AND .OR. IN THE CORRECT BITS
	RETURN	R1			;  THEN EXIT

FQFEND

FQFSRT

.SBTTL	DOS MAGTAPE OPEN

; DO A BACKSPACE OF 1 RECORD

MTADBS:	MOV	#BSP.MT,R2		;SET FUNCTION TO BACKSPACE

; SET 1 RECORD AND DO MAGTAPE I/O

MTADSK:	MOV	#1,MTCNT(R4)		;SET COUNT OF 1 RECORD

; DO MAGTAPE I/O

ENTERU	MTCIO								;002
	MOV	(SP)+,FQADDR-FQFIL(R1)	;SAVE OUR RETURN ADDRESS	;002
	MOVU				;DO THE I/O			;002
	MOV	R1,R3			;COPY BIASED FIRQB POINTER AND	;002
	CMP	(R3)+,(R3)+		; SET POINTER TO NAME.EXT	;002
.ASSUME	FQNAM1	EQ	FQFIL+4						;002
	MOVB	MTLCEV(R4),R0		;GET THE ERROR CODE		;002
	BEQ	10$			;NO ERROR, EXIT Z-BIT=1		;002
	CMPB	R0,#NOROOM		;ERROR, IT IS END-OF-TAPE	;002
	;BEQ	10$			;YES, EXIT Z-BIT=1		;002
	;BNE	10$			;NO, EXIT Z-BIT=0		;002
10$:	JMP	@FQADDR-FQFIL(R1)

GLOBAL	<NOROOM>							;002

; FILE SPEC DOESN'T MATCH

MTAONO:	MOV	#SKP.MT,R2		;PRESET SKIP FORWARD OF
	MOV	#-1,MTCNT(R4)		; AN "INFINITE" AMOUNT
	BIT	#40!2,(R1)		;SHOULD WE SKIP THE WHOLE FILE?
	BCU	EQ,MTARW		;NO, REWIND THE UNIT		;002
	CALLU	MTCIO			;YES, DO THE LONG SKIP
	BNE	MTAOER			;DIE ON ANY ERROR
	BIT	#MTEOF,MTLCST(R4)	;REALLY AT EOF NOW??
	BEQ	MTAONO			;NO, TRY, TRY AGAIN...
	BR	DOSOPN			;YES, GO READ A LABEL

; TAPE IS NOW AT LOGICAL END OF TAPE (LET)

MTALET:	BIT	#100000!40!2,(R1)	;CHECK OUTPUT AND POTENTIAL REWIND
	BCU	EQ,MTARW		;INPUT & MUST REWIND UNIT NOW
	BPL	10$			;INPUT, FILE NOT FOUND
	TSTB	(R1)			;OUTPUT, IS IT APPEND ALSO?
	BPL	MTADLB			;NOT APPEND, TO BACKSPACE AND WRITE
	BIT	#40!2,(R1)		;APPEND, HAVE WE REWOUND?
	BCU	EQ,MTARW		;NOT YET...
10$:	CALL	MTADBS			;BACKSPACE OVER THE LET
	BNE	MTAOER			;ERROR, DIE
	MOVB	#200+NOSUCH,R0		;SET CAN'T FIND AND NO REWIND
	BR	MTAOER			; THEN TELL THE USER ABOUT IT

; REWIND THE MAGTAPE

ENTERU	MTARW
	BIS	#40,(R1)		;SAY WE DID THE REWIND
	MOV	#REW.MT,R2		;SET THE REWIND COMMAND
	CALLU	MTCIO			;DO THE REWIND			;002
	BEQ	DOSOPN			;NO ERROR

; OPEN ERROR(S)

MTAOER:	MOVB	R0,MTLCEV(R4)		;SAVE THE ERROR IN THE DDB
	CMP	-(R1),-(R1)		;LINE UP FIRQB POINTER
	FJMP	MTACEX			;NOW GO EXIT WITH ERROR

GLOBAL	<NOSUCH>

; CHECK A DOS LABEL

.ENABL	LSB

DOSOPN:	TST	(R1)			;OUTPUT FILE?
	BPL	10$			;NO
	BIT	#1000,(R1)		;YES, OPEN IN-PLACE?
	BNE	60$			;SURE, SO JUST WRITE A LABEL
10$:	MOV	R1,MTUBUF(R4)		;SET LABEL BUFFER ADDRESS
	ADD	#FQSIZ-FQFIL,MTUBUF(R4)	;NOW CORRECT THE ADDRESS
	MOV	#RED.MT,R2		;FUNCTION IS READ
	MOV	#DOSLBL-2,MTCNT(R4)	;SET LABEL SIZE -2
	CALLU	MTCIO			;NOW READ THE LABEL		;002
	BEQ	90$			;NO ERROR, LABEL ERROR!
	CMPB	R0,#EOF			;LOGICAL END OF TAPE??
	BEQ	MTALET			;CHECK AT LOGICAL END OF TAPE
	CMPB	R0,#MAGRLE		;LENGTH ERROR?
	BNE	MTAOER			;NO, OTHERS ARE FATAL
	CMP	FQSIZ-FQNAM1(R3),#"VO	;REALLY AN ANSI LABEL??
	BEQ	90$			;YES, ERROR
	CMP	FQSIZ-FQNAM1(R3),#"HD	;REALLY AN ANSI LABEL??
	BNE	20$			;NO
	CMPB	FQSIZ+2-FQNAM1(R3),#'R	;MAYBE...
	BEQ	90$			;YES, ERROR ALSO
20$:	MOV	#3,R5			;MATCH CHECK FOR NAME, EXTENSION
30$:	CMP	FQSIZ-FQNAM1(R3),(R3)+	;NOW CHECK LABEL VS. SUPPLIED
	BNE	MTAONO			;DOESN'T MATCH
	SOB	R5,30$			;CONTINUE FOR 3. WORDS
	CMP	FQSIZ+6-FQFIL(R1),FQPPN-FQFIL(R1) ;DOES THE PPN MATCH?
	BNE	MTAONO			;NO, SO NO MATCH
	TST	(R1)			;FULL MATCH, INPUT OR OUTPUT ??
	BPL	70$			;INPUT, ALL DONE
	TSTB	(R1)			;APPEND?
	BPL	50$			;NO, NORMAL OUTPUT

GLOBAL	<EOF,MAGRLE>

; CHECK FOR APPENDING ONLY AT CURRENT LOGICAL END OF TAPE

	MOV	#-1,FQSIZ-FQFIL(R1)	;YES, SET THE EOF CORRECTION
40$:	MOV	#-1,MTCNT(R4)		;PRESET FOR WHOLE FILE SKIP
	DEC	FQSIZ-FQFIL(R1)		; AND CORRECT FOR THAT SETTING
	MOV	#SKP.MT,R2		;FUNCTION IS "SKIP"
	CALLU	MTCIO			;DO THE LONG SKIP TO EOF	;002
	BNE	MTAOER			;ERRORS ARE FATAL
	SUB	MTCRET(R4),FQSIZ-FQFIL(R1) ;NOW GET THE FILE'S CURRENT SIZE
	BIT	#MTEOF,MTLCST(R4)	;DID THAT SKIP REALLY GO TO EOF?
	BEQ	40$			;NO, LOOP FOR MORE
	MOV	#SKP.MT,R2		;YES, SET TO SKIP AGAIN
	CALL	MTADSK			; DOING 1 RECORD THIS TIME
	BNE	MTAOER			;DIE ON ERRORS
	CALL	MTADBS			;THEN DO 1 BACKSPACE
	BNE	MTAOER			;DIE ON ERRORS
	MOVB	#200+PRVIOL,R0		;PRESET NOT LAST FILE ERROR
	BIT	#MTEOF,MTLCST(R4)	;WAS THAT AN EOF?
	BEQ	MTAOER			;NOPE, SO PROT VIOLATION
	MOVB	#200+NOROOM,R0		;PRESET EOT ERROR
	BIT	#MTEOT,MTLCST(R4)	;AT EOT NOW?
	BNE	MTAOER			;YES, SO ERROR

GLOBAL	<PRVIOL,NOROOM>

; BACKSPACE OVER FOUND LABEL/LOGICAL END OF TAPE

MTADLB:	BIS	#20,(R1)		;ENSURE THE WRITING OF A LABEL HERE
50$:	CALL	MTADBS			;DO 1 BACKSPACE
	BNE	MTAOER			;SOME ERROR
	MOVB	#200+FIEXST,R0		;PRESET EXISTANCE ERROR
	BITB	#200!20,(R1)		;OVERRIDE OR APPEND ON OUTPUT?
	BEQ	MTAOER			;NO, SO ERROR
	BMI	80$			;YES, APPEND, SO ALL DONE

; WRITE OUT A DOS LABEL

60$:	MOVB	#200+NOROOM,R0		;PRESET EOT ERROR
	BIT	#MTEOT,MTLCST(R4)	;ARE WE AT EOT NOW?
	BNE	MTAOER			;YES, SO ERROR
	MOV	R3,MTUBUF(R4)		;SET THE DATA BUFFER ADDRESS (FQNAM1)
	ADD	#6,R3			;SKIP OVER THE FILENAME.EXT
	MOV	FQPPN-FQFIL(R1),(R3)+	;SET THE PPN FOR LABEL
	MOV	#233,(R3)+		;SET THE "DOS" PROTECTION CODE
	MOV	@#DATE,(R3)+		;SET TODAY'S DATE AS CREATION DATE
	CLR	(R3)+			;LAST WORD OF LABEL IS ZERO...
	MOV	#WRT.MT,R2		;FUNCTION IS WRITE
	MOV	#DOSLBL,MTCNT(R4)	;SET SIZE OF A DOS LABEL
	CALLU	MTCIO			;NOW WRITE OUT THAT LABEL	;002
	BNE	100$			;SOME ERROR!

; OPEN ALL DONE

70$:	CLR	FQSIZ-FQFIL(R1)		;THE FILE'S SIZE IS NOW ZERO
80$:	FJMP	MTA512			;OPEN ALL DONE, SO FINISH UP

; DIRECTORY IS ILLEGAL

90$:	SETERR	BADDIR,R0		;SET BAD DIRECTORY & REWIND
100$:	JMP	MTAOER			; AND SAY OPEN ERROR

GLOBAL	<FIEXST,NOROOM>

.DSABL	LSB

FQFEND

FQFSRT

.ENABL	LSB
.SBTTL	ANSI MAGTAPE DIRECTORY SUCCESS EXIT

MTADEX:	MOVB	R0,MTLCEV(R4)		;SAVE THE ERROR IN THE DDB	;003
	CMP	-(R1),-(R1)		;LINE UP FIRQB POINTER		;003
	CLR	FQPPN(R1)		;NO PPN ON ANSI MAGTAPE		;004
	MOV	FQPFLG(R1),FQCLUS(R1) 	;SAVE SECTION NUMBER		;003
	CLR	FQPROT-1(R1) 		;NO PROTECTION ON ANSI MAGTAPE	;003
20$:	MOV	R4,R1			;MOVE THE DDB POINTER TO HERE	;003
	SUB	#MTDDSP,R1		; AND UNBIAS IT			;003
	CALLX	RETDEV			;NOW RETURN DEVICE IF POSSIBLE	;003
	MOV	@#FIJBDA,R2		;GET CALLER'S JOB DATA POINTER	;003
	BIC	#^C<177>,R0		;TRIM ERROR CODE OF THE "REWIND" BIT ;003
	MOVB	R0,JDIOST(R2)		; AND SET THE ERROR CODE FOR CALLER  ;003
30$:	JMPX	FIEXIT			; AND TAKE THE FINAL EXIT	;003

.DSABL	LSB

.ENABL LSB
.SBTTL	EOVFQ - DETERMINE EOV OR EOF LABEL TYPE

;+
;
;	EOVFQ - END OF VOLUME CHECKER
;
;	THIS CODE IS ENTERED AS A FIP REQUEST WHEN THE USER IS
;	DOING MAGTAPE I/O AND HITS AN EOF.  THE DRIVER QUEUES
;	A EOVFQ REQUEST IN ORDER TO DETERMINE WHETHER WE SHOULD
;	GIVE THE USER A EOF OR EOV ERROR.
;
;	THIS ROUTINE TRIES TO READ THE NEXT LABEL AND LOOKS IN 
;	THE LABEL BUFFER TO FIND THE LABEL TYPE.  IF IT IS A
;	EOV LABEL WE CHANGE THE ERROR CODE TO EOV.  WE THEN DO
;	A BACKSPACE OVER THE LABEL TO LEAVE THE USER WHERE HE
;	IS SUPPOSED TO BE.
;
;-

FQFENT	EOV,,,								;003
	
	MOV	R4,R1		;COPY FIRQB POINTER			;004
	MOV	FQCLUS(R4),R4	;GET DDB POINTER			;004
	ADD	#MTDDSP,R4	;BIAS IT				;004
	MOV	R1,MTFQB(R4)	;SAVE FIRQB POINTER IN DDB		;004
	CMP	(R1)+,(R1)+	;NOW BIAS IT FOR US			;004
	CLR	MTUBUF(R4)	;WE DON'T HAVE A BUFFER AT THE START	;004
	BICB	#MT.OPN,MTOFLG(R4) ;SIGNAL FIP I/O			;003
	CALLU	MTCIO		;READ THE NEXT LABEL, GETTING A BUFFER	;004
	BEQ	10$		; no error, go ahead then.		;005
	CMP	#EOF,R5		; error,another tape mark? (LEOT)	;005
	BNE	50$		; no, so die and tell user....		;005
	BISB	#MT.LEO,MTFLAG(R4) ; yes, so remember not to skip 	;005
	MOV	R5,R2		; get the error into the right register	;005
	BR	40$		; and branch around label crap		;005

10$:	MOV	MTUBUF(R4),R0	;FETCH POINTER TO BUFFER		;003
	MOV	(PC)+,R2	;PRESET BAD DIRECTORY ERROR, OR EOF	;004
	.BYTE	BADDIR,EOF						;004
	CMP	(R0)+,#"EO	;EO? LABEL?				;003
	BNE	40$		;NO					;003
	CMPB	(R0),#'F	;EOF LABEL?				;003
	BEQ	30$		;YES - GO SET EOF ERROR CODE		;004
	CMPB	(R0),#'V	;EOV LABEL?				;003
	BNE	40$		;NOPE, SO BADDIR WAS RIGHT		;004
	MOV	#EOV*400,R2	;YEP, SO SET EOV INSTEAD OF EOF		;004
30$:	SWAB	R2		;GET EOF OR EOV IN LOW BYTE		;004
40$:	MOVB	R2,FQSIZM-FQFIL(R1)	;SAVE THE ERROR CODE		;004
	MOV	#2,MTCNT(R4)	;COUNT = 2				;015
	CALLU	MTABS		;BACKUP OVER LABEL and TMK		;004
	BNE	50$		; error, quit noting catastrophe	;005
	BITB	#MT.LEO,MTFLAG(R4) ; was this an LEOT?			;005
	BNE	45$		; yes, so just set error, and exit	;005
	MOV	#1,MTCNT(R4)	; set  a count of 1			;005
	CALLU	MTASK		; and skip to beginning of label	;005
	BNE	50$		; go out with it if error reported	;005
45$:	MOVB	FQSIZM-FQFIL(R1),MTLCEV(R4)	;SET ERROR CODE		;004

;+
;FINISH UP AND RETURN TO CALLER
;-

50$:	BICB	#MT.LEO,MTFLAG(R4) ; clear LEOT flag just in case	;005
	CALLX	RETBIG,R5,MTULBF;RETURN BIG BUFFER			;003
	MOV	@#FIJBDA,R2	;GET CALLERS JOB DATA POINTER		;003
	BISB	#MT.OPN,MTOFLG(R4);CLEAR FIP I/O FLAG BIT		;003
	BIT	#DDASY,MTSTS-1(R4);ASYNCHRONUS DEVICE?			;004
	BEQ	55$		;NOPE					;004
	MOV	#-1,R2		;SET MTU COMMAND			;004
	BR	70$		;LET THE DRIVER FINISH UP AND RETURN	;008

55$:	MOVB	MTLCEV(R4),JDIOST(R2)	;SET THE ERROR CODE FOR THE CALLER ;003
	CLRB	JDPOST(R2)		;But don't return anything else	;011
	RETURN								;003

; DO MAGTAPE I/O

ENTERU	MTABS								;003
	MOV	#BSP.MT,R2	;SET FUNCTION = BACKSPACE		;003
	BR	65$		; count already set			;005

ENTERU	MTASK
	MOV	#SKP.MT,R2	; function is skip			;005
	BR	65$		; count already set

ENTERU	MTCIO								;003
	MOV	#RED.MT,R2	;SET FUNCTION AS READ			;003
	MOV	#ANSLBL,MTCNT(R4) ;SET COUNT IN THE DDB			;008
65$:	MOV	(SP)+,FQADDR-FQFIL(R1)	;SAVE OUR RETURN ADDRESS	;003
70$:	MOVU			;DO THE I/O				;008
	MOV	MTUBUF(R4),R0	;POINT TO THE ANSI LABEL BUFFER		;003
	MOVB	MTLCEV(R4),R5	;GET THE ERROR CODE			;003
	JMP	@FQADDR-FQFIL(R1) ;					;003

.DSABL	LSB
	GLOBAL	<BADDIR,EOV,EOF,MAGRLE,FIJBDA>

FQFEND		
	.END
