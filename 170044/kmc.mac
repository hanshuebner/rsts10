.INCLUDE /CMN:COMMON/							;005
.INCLUDE /CMN:KERNEL/							;005
.INCLUDE /CMN:FLDEF/							;005
.INCLUDE /CMN:XKDEF/							;005
.INCLUDE /CMN:IIDEF/							;005
TITLE	KMC,<KMC-11 TO OTHER DEVICE DRIVER BRIDGING>,0A,10-MAY-91,MHB/SPC/SJK/JTC/WJS/FEK/KPH
;
;		COPYRIGHT (c) 1974, 1987 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR KMC
;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;  001	JTC  07-AUG-81	CHANGE FOR NEW CALLMX CONVENTION
;  002	JTC  09-AUG-81	BUM CODE SO KMC2 WILL FIT
;  003	WJS  29-Oct-82	New UUOENT for EMT Logger
;  004	FEK  07-Feb-83	Merge changes from Reading
;
;			[RSTS V9.6]
;  005  KPH  13-Oct-87	Add .INCLUDEs
;			Change CSR references to not assume that CSRTBL
;			matches DEVPTR.
;  006  JJT  16-Nov-87	Fix 005 by changing DVRAPE to DVRA5E
;
;			[RSTS V10.0]
;  007	FEK  12-Jul-89	Fix 005 by changing (R5)+ to (R4)+
;-

FQFSRT	KMC

.SBTTL	KMC-11 TO OTHER DEVICE DRIVER BRIDGING

;+
; UU.KMC - KMC-11 TO OTHER DEVICE DRIVER BRIDGING.
;
;	R4 -> FIRQB
;		  +4   = 0 => BUILD A BRIDGE			A
;		       = 2 => BREAK A BRIDGE			  B
;		       = 4 => RETURN XK: STATUS			    C
;		       = 6 => RETURN A BRIDGE'S STATUS		      D
;		 +6-10 = AUXILIARY DEVICE (XKN:)		A B C D
;		  +11  = BRIDGE INDEX (-1 FOR FIRST FREE)	A     D
;		+12-14 = DEVICE TO BRIDGE TO (LPN:, IIN:, DZN:)	A
;		  +15  = CONTROL UNIT ADDRESS (IIN: ONLY)	A
;		+16-17 = NUMBER OF UNITS (IIN: ONLY)		A
;		  +20  = DEFAULT FREE IRB DATA BUFFER SIZE/100	A
;		  +21  = DEFAULT NUMBER OF FREE IRB'S		A
;		+22-23 = MAX # OF IRB/BIG BUFF FOR RECEIVING
;		+24-25 = PRODUCT ID
;
;	IN FIRQB ON RETURN:
;		  +4   = 4 (RETURNED XK: STATUS)
;		  +11  = NUMBER OF ACTIVE BRIDGES
;		  +20  = DEFAULT FREE IRB DATA BUFFER SIZE
;		  +21  = DEFAULT NUMBER OF FREE IRB'S
;		  +22  = MAX # OF RCVD BUFFERS
;		  +23  = # OF RCVD BUFFERS IN USE
;		+24-25 = XKN: DDB ADDRESS
;		+26-27 = XKN: CSR ADDRESS
;		+30-31 = XKN: STATUS
;		+32-33 = XKN: PRODUCT ID
;
;		  +4   = 6 (RETURNED BRIDGE STATUS)
;		+12-14 = DEVICE BRIDGED TO
;		  +15  = CONTROL UNIT ADDRESS
;		+16-17 = NUMBER OF UNITS
;		+24-25 = DEVICE DDB ADDRESS
;		+26-27 = DEVICE CSR ADDRESS
;		+30-31 = LST ADDRESS
;		+32-33 = LTT ADDRESS (IIN:) OR BASE KB # (DZN:)
;-

	UUOENT	KMC,,,LOGABL	;BUILD KMC-11 (XK:) BRIDGE				;003

	MOV	6(R4),FQDEV(R4)	;MOVE THE "XK" TO STANDARD NAME LOCATION
	MOVB	10(R4),FQDEVN(R4) ;ALSO MOVE THE UNIT NUMBER
	MOVB	#-1,FQDEVN+1(R4) ; MAKING IT REAL
	CALLX	GUNMNT,R5	;CHECK OUT THE AUXILIARY'S DEVICE NAME
10$:	  ERROR	BADFUO		;DISK(S) ARE ILLEGAL
	MOV	(R1),R0		;R0 = DRIVER INDEX AND STATUS FLAGS
	BIC	#177400,R0	;R0 = DRIVER INDEX
	CMP	#"XK,DEVNKB-2(R0) ;REALLY "XKN:"?
	BNE	10$		;NOPE, AN ERROR
	MOVB	DDUNT(R1),R0	;GET DEVICE'S UNIT NUMBER
	ASL	R0		; TIMES 2 FOR WORD ADDRESSING
	MOV	4(R4),R2	;GET THE FUNCTION CODE
	BIC	#^C<6>,R2	; AND ENSURE IT IS VALID
	ADD	R2,PC		;NOW DISPATCH ON IT
	 BR	60$		;0, BUILD A BRIDGE
	 BR	70$		;2, BREAK A BRIDGE
	 BR	50$		;4, RETURN XKN: STATUS
	.BR	15$		;6, RETURN BRIDGE BLOCK INFORMATION

;+                     
; RETURN BRIDGE STATUS IN FIRQB:
;
; ON ENTRY:
;
;	R0 =  XK UNIT # * 2
;	R1 -> XKDDB
;	R2 =  6        
;	R4 -> FIRQB
;
; ON EXIT IN FIRQB:
;
;		  +4   = 6
;		+12-14 = DEVICE BRIDGED TO
;		  +15  = CONTROL UNIT ADDRESS (IIN: ONLY)
;		+16-17 = NUMBER OF UNITS (IIN: ONLY)
;		+24-25 = DEVICE DDB ADDRESS
;		+26-27 = DEVICE CSR ADDRESS
;		+30-31 = LST ADDRESS
;		+32-33 = LTT ADDRESS (IIN:) OR BASE KB # (DZN:)
;-
                       
15$:	MOVB	11(R4),R2	;6, RETURN BRIDGE STATUS, GET BRIDGE INDEX
	CMP	R2,#MAXBBP	;IS THE INDEX WITHIN RANGE?
	BHI	10$		; NOPE, ERROR
	ASL	R2		;YEP, TIMES 2 FOR WORD ADDRESSING
	ADD	R1,R2		;BIAS IT BY THE AUXILIARY DEVICE'S DDB
	ADD	#XKBBP-2,R2	; AND BY THE DDB OFFSET
	MOV	(R2),R2		;GET POINTER TO THE BRIDGE BLOCK
	BNE	30$		;BRIDGE EXISTS
20$:	 ERROR	NOSUCH		;NO BRIDGE, ERROR

30$:	MOV	#DVRAP5,R0	;GET LIST OF DEVICE DRIVER PAR5 POINTERS
35$:	CMP	R0,#DVRA5E	;END OF LIST?
	BHIS	20$		; YES, NOT FOUND???
	CMP	BBDAP5(R2),(R0)+ ;A MATCH?
	BNE	35$		; NOPE, KEEP LOOKING...
	SUB	#DVRAP5+2,R0	; YEP, FIND THE DRIVER INDEX
	ADD	#12,R4		;INDEX TO RETURNED DATA
	CMP	#"KB,DEVNKB-2(R0) ;IS IT KMC-DZ?
	BNE	38$		; NOOP...
	MOV	#"DZ,(R4)+	;WE WILL SAY "DZ" THEN
	BR	40$    

38$:	MOV	DEVNKB-2(R0),(R4)+ ;RETURN DEVICE NAME
40$:	MOVB	BBDUNT(R2),R3	;GET DEVICE'S CONTROL UNIT NUMBER
	MOVB	R3,(R4)+	;RETURN DEVICE'S CONTROL UNIT NUMBER
	ASL	R3		;DOUBLE CONTROL UNIT NUMBER
	MOV	<DEVPTR+DEVOKB-IDX.KB>(R0),R1
				;Point to DDB vector for device		;005
	ADD	R3,R1		;Now point to DDB pointer for this unit	;005
	MOV	(R1),R1		;Now get the DDB pointer itself		;005
	CMP	#"II,DEVNKB-2(R0) ;IS IT "IIN:"?
	BNE	42$		; NO...
	MOVB	IICUA(R1),(R4)+	;YES, RETURN CONTROL UNIT ADDRESS
	MOVB	IILTTN(R1),R5	;RETURN NUMBER OF UNITS
	MOV	R5,(R4)+
	MOV	IILTTP(R1),R5	;R5 = LTT ADDRESS                           
	BIT	(R4)+,(R4)+	;ADD 4 TO R4 TO BIAS TO 24TH BYTE
	MOV	CSR.II(R3),-(SP) ;Get CSR pointer			;005
	BR	45$

42$:	CMP	#"KB,DEVNKB-2(R0) ;IS IT "KBN:"?
	BNE	43$		; NO...
	MOV	DDUNT(R1),R5	;R5 = BASE KB # OF DZN:
	MOV	CSR.KB(R3),-(SP) ;Get CSR pointer			;005

; SINCE WE ONLY SUPPORT KB, II AND LP, IT MUST BE LP THEN....

43$:	ADD	#7,R4		;BIAS TO 24TH BYTE OF FIRQB
	MOV	CSR.LP(R3),-(SP) ;Get CSR pointer			;005

45$:	MOV	R1,(R4)+	;RETURN DEVICE DDB ADDRESS                  
	MOV	(SP)+,(R4)+	;RETURN CSR ADDRESS
	MOV	BBDAP5+2(R2),(R4)+ ;RETURN LST ADRESS
	MOV	R5,(R4)+	;RETURN LTT ADDRESS OR BASE KB #
	RETURN  

GLOBAL	<DVRAP5,DVRA5E,BBDAP5,DEVPTR,DEVOKB>                    	;006
.WEAK	CSR.II,CSR.KB,CSR.LP						;005

;+
; RETURN XKN: STATUS IN FIRQB:
;
; ON ENTRY:
;
;	R0 =  XK UNIT # * 2
;	R1 -> XKDDB
;	R2 =  4
;	R4 -> FIRQB
;                                                                           
; ON EXIT IN FIRQB:
;
;		  +4   = 4 (RETURNED XK: STATUS)
;		  +11  = NUMBER OF ACTIVE BRIDGES
;		  +20  = DEFAULT FREE IRB DATA BUFFER SIZE
;		  +21  = DEFAULT NUMBER OF FREE IRB'S
;		  +22  = MAX # OF RCVD BUFFERS
;		  +23  = # OF RCVD BUFFERS IN USE
;		+24-25 = XKN: DDB ADDRESS
;		+26-27 = XKN: CSR ADDRESS
;		+30-31 = XKN: STATUS
;		+32-33 = XKN: PRODUCT ID
;-

50$:	MOVB	XKACBB(R1),11(R4) ;RETURN NUMBER OF ACTIVE BRIDGES          
	ADD	#20,R4		;INDEX TO REST OF RETURNED DATA
	MOV	XKBSIZ(R1),(R4)+ ;RETURN DEF DATA BUFF SIZE & # OF FREE IRB
	MOV	XKMRBF(R1),(R4)+ ;RETURN MAX & USED # OF RCVD BUFF
	MOV	R1,(R4)+	;RETURN AUXILIARY DEVICE'S DDB ADDRESS
	MOV	CSR.XK(R0),(R4)+ ;Return KMC-11 CSR address		;007
	MOV	XKSTS(R1),(R4)+	;RETURN AUXILIARY DEVICE'S STATUS
	MOV	XKPRID(R1),(R4)+ ;RETURN AUXILIARY DEVICE'S PRODUCT ID
	RETURN			;EXIT, ALL DONE


60$:	FJMP	BUBRID		;GOTO BUILD BRIDGE MODULE...

70$:	FJMP	BKBRID		;GOTO BREAK BRIDGE MODULE...

GLOBAL	<CSR.XK>							;005

FQFEND

FQFSRT

;+
; BREAK A BRIDGE CONNECTION:
;
; ON ENTRY:
;
;	R0 =  XK UNIT # * 2
;	R1 -> XKDDB
;	R2 =  2
;	R4 -> FIRQB
;
;		  +4   = 2 => BREAK A BRIDGE			A
;		 +6-10 = AUXILIARY DEVICE (XKN:)		A B C D
;-

BKBRID:	CMPB	@#FIJOB,DDJBNO(R1) ;IS AUXILIARY DEVICE OPEN BY OUR CALLER?
	BEQ	10$		; YEP...
	 ERROR	PRVIOL		; ELSE, RETURN AS PROTECTION VIOLATION...

10$:	MOV	XKSTS(R1),R3	;R3 = XKDVR STATUS
	BIT	#XKCON,R3	;IT HAS BETTER BEEN CONNECTED
	BNE	20$		;IF "XKCON" IS SET, OK...
	 ERROR	NOSUCH		; ELSE NO BRIDGE...
20$:	BIT	#XKRUN,R3	;IT HAS BETTER BEEN NOT RUNNING
	BEQ	60$		; YES, GOOD, ELSE USER IS SUPPOSED TO STOP IT
	 ERROR	INUSE		; RETURN AS "IN USED" ERROR

60$:	MOV	R1,R3		;BUILD A POINTER
	ADD	#XKBBP,R3	; TO BRIDGE POINTERS
	MOV	#MAXBBP,R2	;R2 = MAX NUMBER OF BB
65$:	MOV	(R3),R4		;R4 -> BRIDGE BLOCK
	BEQ	90$		;IF EQ, NO BRIDGE BLOCK FOR THIS ENTRY...
	CLRB	BBSTS(R4)	;CLEAR STATUS IN BB TO INDICATE DISCONNECT REQ
	CALLX	REGSAV,R5	;SAVE ALL REGISTER
	MOV	XKPRID(R1),-(SP) ;TOP OF STACK = PRODUCT ID
	MOVB	BBDUNT(R4),R0	;R0 = CONTROLLER #
	ASL	R0		;R0 = CONTROLLER # * 2
	CLR	R1		;R1 = UNIT # * 2, INIT TO ZERO
	MOV	#1,R2		;PRESET COUNTER TO ONE
	BIT	#XKDZ,(SP)+	;IS IT KMC-DZ?
	BEQ	67$		; NOOP
	MOV	#10,R2		;YEP, THEN WE HAVE TO CALL TTDVR FOR 8 TIMES
67$:	CALLBB	BBDSTA		;CALL SLAVE DRIVER FOR DISCONNECT REQ
	TST	(R1)+		;NEXT UNIT
	SOB	R2,67$		;LOOP UNTIL DONE...
	CALLX	REGRES,R5	;RESTORE ALL REGISTER

	MOV	XKPRID(R1),R0	;R0 = PRODUCT ID
	BIT	#XKLP,R0	;IS IT KMC-LP?
	BNE	85$		; YEP...
	BIT	#XKDZ,R0	;IS IT KMC-DZ?
	BNE	80$		; YEP...

; THEN, IT MUST BE KMC-IBM.
; BREAK II CONNECTION

	MOV	#DVRAP5,R0	;GET LIST OF DEVICE DRIVER APR5 POINTERS
70$:	CMP	BBDAP5(R4),(R0)+ ;A MATCH?
	BNE	70$		; NOOP...
	SUB	#DVRAP5+2,R0	; YEP, FIND THE DRIVER INDEX FOR II:
	MOVB	BBDUNT(R4),R5	;GET DEVICE'S CONTROL UNIT NUMBER
	ASL	R5		;DOUBLE CONTROL UNIT NUMBER
	ADD	<DEVPTR+DEVNKB-DEVNAM-2>(R0),R5 ;FORM POINTER TO DDB POINTER
	MOV	(R5),R5		;GET IIDDB ADDRESS
	ADD	#IILTTP,R5	;BIAS R5 TO LTT POINTER ENTRY
	CLR	(R5)+		;CLEAR IILTTP
	CLR	(R5)+		;CLEAR IIBBP
	CLR	(R5)+		;CLEAR IILTTN AND IICUA
	CLR	(R5)+		;CLEAR IIDCNT
	MOV	R4,-(SP)	;SAVE BRIDGE BLOCK ADDR ONTO STACK
	MOV	BBDAP5+2(R4),R4	;R4 -> LST
	CALL	CLRLST		;CLEAR UP LST
	SUB	#10,R4		;R4 -> BEGINNING OF MONITOR BUFFER (LST & LTT)
	BUFFER	RETURN		;RETURN IT BACK TO MONITOR
	MOV	(SP)+,R4	;RESTORE BRIDGE BLOCK ADDR
	.BR	85$		;GOTO COMMON CODES...

; BREAK KB CONNECTION
; *** HAVE'NT DEFINED WHAT TO DO YET *****

80$:				;I DO NOT KNOW WHAT HAVE TO BE DONE NOW?

85$:	BUFFER	RETSML		;RETURN BB TO RSTS/E MONITOR
90$:	CLR	(R3)+		;CLEAR THE BRIDGE BLOCK
	DEC	R2		;TRY NEXT ENTRY
	BNE	65$
	ADD	#XKACBB,R1	;BIAS R1 TO POINT TO XKACBB
	CLRB	(R1)+		;CLEAR XKACBB
	CLR	(R1)+		;CLEAR XKSTS
	CLR	(R1)+		;CLEAR XKPRID
	CLR	(R1)+		;CLEAR XKBSIZ
	CLR	(R1)+		;CLEAR XKBNO
	ADD	#MAXBBP*2,R1	;BIAS R1 TO POINT TO XKIRBH
93$:	MOV	(R1),R2		;R2 -> IRB/BIG BUFFER
	BEQ	110$		;IF ZERO, NO MORE
	CALL	RETIRB		;RETURN IRB/BIG BUF
	CLR	(R1)		;CLEAR HEAD POINTER
110$:	CLR	2(R1)		;CLEAR IRB CHAIN TAIL POINTER TOO
	RETURN			;ALL DONE, RETRUN TO USER
	
; CLEAR UP LST SUBROUTINE
; R4 -> LST
; ON OUTPUT, ALL REGISTERS PRESERVED

CLRLST:
	REGSCR			;SAVE ALL REGISTERS
	MOV	R4,R0		;R0 -> LST
10$:	CMPB	#377,1(R0)	;END OF LST?
	BEQ	50$		;YEP...
	MOV	2(R0),R2	;R2 -> DATA-OUT IRB IF ANY
	BEQ	20$		;IF ZERO, NONE...
	CALL	RETIRB		;RETURN IRB CHAIN
20$:	ADD	#LSTSIZ,R0	;AVANCE TO DATA-IN LST
	MOV	2(R0),R2	;R2 -> DATA-IN IRB IF ANY
	BEQ	40$		;IF ZERO, NO IRB...
	CLR	IRBNXT(R2)	;WE DO NOT HAVE IRB CHAINED FOR DATA-IN *****
	CALL	RETIRB		;RETURN IRB CHAIN...
40$:	ADD	#LSTSIZ,R0	;ADVANCE TO NEXT ENTRY
	BR	10$		;LOOP UNTIL DONE...
50$:	RETURN

; RETURN IRB CHAIN
; R2 -> IRB
; ON OUTPUT, R2, R4 CHANGED

RETIRB:
20$:	MOV	IRBCON(R2),R4	;R4 = CONTROTED ADDR OF BIG BUF
	BEQ	25$		;IF ZERO, NO BIG BUF
	BUFFER	RETURN		;RETURN BIG BUF
25$:	MOV	R2,R4		;MAKE A COPY INTO R4 OF IRB ADDR
	MOV	IRBNXT(R4),R2	;R2 -> NEXT IRB IN THE CHAIN IF ANY
	BUFFER	RETSML		;RETURN IRB
	TST	R2		;DO WE HAVE MORE IRB?
	BNE	20$		;YEP...
	RETURN

	GLOBAL	<DEVNAM,DEVNKB,DEVPTR,FIJOB>
	GLOBAL	<DVRAP5,DVRA5E>

FQFEND

FQFSRT

;+
; BUILD A BRIDGE CONNECTION:
;
; ON ENTRY:
;
;	R0 =  XK UNIT # * 2
;	R1 -> XKDDB
;	R2 =  0
;	R4 -> FIRQB
;
;		  +4   = 0 => BUILD A BRIDGE			A
;		 +6-10 = AUXILIARY DEVICE (XKN:)		A B C D
;		  +11  = BRIDGE INDEX (-1 FOR FIRST FREE)	A     D
;		+12-14 = DEVICE TO BRIDGE TO (LPN:, IIN:, DZN:)	A
;		  +15  = CONTROL UNIT ADDRESS (IIN: ONLY)	A
;		+16-17 = NUMBER OF UNITS (IIN: ONLY)		A
;		  +20  = DEFAULT FREE IRB DATA BUFFER SIZE/100	A
;		  +21  = DEFAULT NUMBER OF FREE IRB'S		A
;		+22-23 = MAX # OF IRB/BIG BUFF FOR RECEIVING
;		+24-25 = PRODUCT ID
;-

LSTSIZ	=	4		;4 BYTES PER LST ENTRY

BUBRID:	CMPB	@#FIJOB,DDJBNO(R1) ;IS AUXILIARY DEVICE OPEN BY OUR CALLER?
	BEQ	10$		; YES, GOOD...
5$:	 ERROR	BADFUO		; NOOP, ERROR

10$:	MOV	XKPRID(R1),R3	;R3 = PRODUCT ID
	BEQ	12$		;IF ZERO, FIRST TIME TO BE HERE...
	CMP	R3,24(R4)	; OTHERWISE, MUST BE THE SAME AS WHAT WE HAD
	BNE	5$		; NOOP, ERROR

12$:	MOV	XKSTS(R1),R3	;COPY XKSTS INTO R3
	BIC	#XKCON,R3	;MASK OF BIT "XKCON"
	BEQ	15$		;IF RESULT IS ZERO, WE CAN MAKE THE BRIDGE
13$:	 ERROR	NOTAVL		;OTHERWISE, WE CAN'T DO THAT
15$:	MOV	R1,R3		;BUILD A POINTER
	ADD	#XKBBP,R3	; TO BRIDGE POINTERS
	MOVB	11(R4),R2	;GET THE BRIDGE INDEX
	BMI	18$		;-1, FIND THE FIRST ONE IS FREE..
	CMP	R2,#MAXBBP	;WITHIN RANGE?
	BHIS	13$		; NOOP...
	ASL	R2		; TIMES TWO FOR WORD ADDRESSING
	ADD	R2,R3		;R3 -> BRIDGE BLOCK ENTRY IN XKDDB
	TST	(R3)		;IS IT EMPTY?
	BEQ	30$		; YES..
	 ERROR	INUSE		;SORRY, SOMEONE IS USING THIS ENTRY

18$:	MOV	#MAXBBP,R2	;R2 = MAX NUMBER OF ENTRIES
20$:	TST	(R3)+		;FOUND A FREE ENTRY?
	BEQ	25$		;YES
	SOB	R2,20$		;TRY NEXT
	 ERROR	NOROOM		;NO, ERROR

25$:	TST	-(R3)		;R3 -> FREE ENTRY
30$:	MOV	R1,R5		;MAKE A COPY OF XKDDB POINTER INTO R5
	MOV	12(R4),FQDEV(R4) ;MOVE THE DEV NAME TO STANDARD NAME LOCATION
	MOVB	14(R4),FQDEVN(R4) ;ALSO MOVE THE UNIT NUMBER
	MOVB	#-1,FQDEVN+1(R4) ;MAKE IT REAL
	CALLX	GUNMNT,R5	;CHECK OUT THE AUXILIARY'S DEVICE NAME
32$:	 ERROR	BADFUO		;NAME ARE ILLEGAL

	BIT	#DDAUX,(R1)	;IS IT A CONNECTABLE DEVICE?			;004
	BEQ	13$		;NOOP, REPORT AS NOTAVL ERROR...		;004
	MOV	R5,R0		;R0 -> XKDDB
	MOV	R4,R5		;GET A COPY OF FIRQB POINTER INTO R5
	BUFFER	GETSML		;GET A SMALL BUFFER
	BVC	35$		;IF VC, WE GOT ONE
	 ERROR	NOBUFS		; ELSE RETURN AS NO BUFFER ERROR

; NOW, WE HAVE
;	R0 -> XKDDB
;	R1 -> ??DDB
;	R4 -> BRIDGE BLOCK
;	R5 -> FIRQB

35$:	CALLX	REGSAV,R5	;SAVE ALL REGISTERS				;004
	MOV	R0,R1		;R1 -> XKDDB
	MOV	R4,R0		;R0 -> BRIDGE BLOCK
	MOVB	DDUNT(R1),BBAUNT(R0) ;MOVE IN XKDVR CONTROLLER NUMBER
	CALL	CALASN		;CALL "ASN$XK" ENTRY POINT IN XKDVR
	MOV	(R1),R1		;GET DRIVER INDEX AND FLAGS FOR XKDVR
	BIC	#177400,R1	;R1 = DRIVER INDEX
	MOV	DVRAP5(R1),BBAAP5(R0) ;MOVE IN XKDVR APR5 VALUE
	CALLX	REGRES,R5	;RESTORE ALL REGISTERS

	CALLX	REGSAV,R5	;SAVE ALL REGISTERS
	MOV	R4,R0		;R0 -> BRIDGE BLOCK
	MOVB	DDUNT(R1),BBDUNT(R0) ;MOVE IN XXDVR CONTROLLER NUMBER
	MOV	(R1),R3		;GET DRIVER INDEX AND FLAGS
	BIC	#177400,R3	;R3 = DRIVER INDEX
	MOV	DVRAP5(R3),BBDAP5(R0) ;MOVE IN XXDVR APR5 VALUE
	CMP	#"LP,DEVNKB-2(R3) ;IS IT KMC-LP?
	BNE	40$		; NOOP...
	CALL	CALASN		;CALL "ASN$LP" ENTRY POINT IN LPDVR
	BCS	41$		;IF CS, REQUEST HAS BEEN REJECTED...
	ADD	#24,R4		;BIAS R4 TO POINT TO LST (WITHIN BB)
	MOV	R4,BBDAP5+2(R0)	;FILL IN LST POINTER IN BB
	CLR	(R4)+		;MAKE SURE LST ENTRY IS CLEAN
	CLR	(R4)+
	CLR	(R4)+
	CLR	(R4)+
	MOV	#177400,(R4)	;PUT IN STOPPER
	BR	60$		;GOTO COMMON CODES

40$:	CMP	#"II,DEVNKB-2(R3) ;IS IT KMC-IBM?
	BNE	50$		; NOOP...
	MOV	R1,R3		;R3 -> IIDDB
	MOV	16(R5),R1	;R1 = # OF UNITS
	MUL	#<2*LSTSIZ+LTTSIZ>,R1 ;R1 = # OF BYTES NEED FOR LTT AND LST
	ADD	#<2*LSTSIZ+10>,R1 ;INCLUDE HEADER AND LAST ENTRY FOR LST
	MOV	#30,R2		;LEAVE 24 SMALL BUFFERS AT LEASE
	CALLX	BUFFER,R5,MONPOL ;GET BUFFER FROM MONITOR
	BCS	80$		;IF CS, COULD NOT GET ONE...	
	MOV	R3,R1		;R1 -> IIDDB
	CALL	CALASN		;CALL "ASN$II" ENTRY PT IN IIDVR
	BCC	42$		;IF CC, GOT IT
	BUFFER	RETURN		;REQUEST HAS BEEN REJECTED, RETURN LTT AND LST
41$:	BR	80$		;GOTO ERROR HANDLE CODES...
42$:	MOV	24(R5),IIPRID(R3) ;FILL IN PRODUCT ID
	BIT	#II3271,IIPRID(R3) ;IS IT RSTS/KMC-3271
	BEQ	43$		;NOOP...
	MOVB	15(R5),IICUA(R3) ;FILL IN CUA ADDRESS
	MOV	#1,IIDCNT(R3)	;DEFAULT PENDING O/P COUNT IS 1 FOR KMC-3271
	BR	44$
43$:	CLRB	IICUA(R3)	;CLEAR CUA ADDRESS FOR RSTS/KMC-2780 THEN
	MOV	#2,IIDCNT(R3)	;WE WILL SET PENDING O/P COUNT TO 2 MAX.
44$:	MOV	16(R5),R1	;R1 = # OF LTT ENTRY
	MOVB	R1,IILTTN(R3)	;FILL IN # OF TERMINALS

; SET UP LST

	ADD	#10,R4		;R4 -> BEGINNING OF LST
	MOVPIC	#DEVTAB,R2	;SET UP R2 TO POINT (PIC) TO DEVTAB
	MOV	R4,BBDAP5+2(R0)	;FILL IN LST POINTER ADDR IN BB
45$:	MOVB	(R2),(R4)+	;FILL IN DEV ID
	CLRB	(R4)+		;CLEAR LSTSTS
	CLR	(R4)+		;CLEAR IRB POINTER
	MOVB	(R2)+,(R4)+	;FILL IN DEV ID
	CLRB	(R4)+		;CLEAR LSTSTS
	CLR	(R4)+		;CLEAR IRB POINTER
	SOB	R1,45$		;LOOP UNTIL DONE...
	MOV	#377*400,(R4)+	;FILL IN STOPPER
	CLR	(R4)+		;AND CLEAR IRB POINTER FOR THIS LAST ENTRY
	CLR	(R4)+
	CLR	(R4)+

; SET UP LTT

	MOV	R4,IILTTP(R3)	;FILL IN LTT POINTER
	MOVB	IILTTN(R3),R1	;R1 = # OF LTT ENTRY
	BIT	#II3271,IIPRID(R3) ;IS IT RSTS/KMC-3271?
	BEQ	47$		;NOOP...

; SET UP LTT FOR RSTS/KMC-3271

	MOVPIC	#DEVTAB,R2	;SET UP R2 TO POINT (PIC) TO DEVTAB
46$:	CLR	(R4)+		;CLEAR JOB AND CHANNEL #
	MOVB	(R2)+,(R4)+	;MOVE IN DEV ID
	CLRB	(R4)+		;CLEAR RESERVED BYTE
	CLR	(R4)+		;CLEAR MODE AND STATUS
	CLR	(R4)+		;CLEAR LTTOUT
	CLR	(R4)+		;CLEAR LTTIRB
	CLR	(R4)+		;CLEAR PENDING O/P COUNT
	SOB	R1,46$		;LOOP UNITL DONE...
	BR	60$

; SET UP LTT FOR RSTS/KMC-2780

47$:	MUL	#<LTTSIZ/2>,R1	;GET # OF WORDS TO CLEAR INTO R1
48$:	CLR	(R4)+		;CLEAR ALL
	SOB	R1,48$
	.BR	60$		;GO TO COMMON CODES

; SET UP FOR RSTS/KMC-DZ

50$:
;	CMP	#"KB,DEVNKB-2(R3) ;IS IT KMC-DZ?
;	BNE	55$		;NO...
;
; ...
	.BR	60$		;GO TO COMMON CODES...
;55$:	ERROR	BADFUO		;WE ONLY SERVICE LP, II AND KB NOW

; WE HAVE BUILT THE BRIDGE

60$:	CALLX	REGRES,R5	;RESTORE ALL REGISTERS
	MOV	R4,(R3)		;REMEMBER BB INTO XKDDB
	MOV	20(R5),XKBSIZ(R0) ;MOVE DEFAULT BUFFER SIZE & DEF # OF BUFF
	MOV	22(R5),XKMRBF(R0) ;MOVE MAX # OF RCVD BUFF
	MOV	24(R5),XKPRID(R0) ;MOVE PRODUCT ID
	INCB	XKACBB(R0)	;ONE MORE ENTRY
	BIS	#XKCON,XKSTS(R0) ;REMEMBER WE HAVE MADE THE BRIDGE(S)
	RETURN

; ERROR IN BRIDGE BUILDING

80$:	CALLX	REGRES,R5	;RESTORE ALL REGISTERS
	BUFFER	RETSML		;RETURN THE SMALL BUFFER TO RSTS/E
	 ERROR	NOTAVL		;RETURN AS NOT AVAILABLE ERROR

; SUBROUTINE TO MAKE A MAPPED CALL TO ASSIGN ENTRY POINT OF DRIVER
; WHEN ENTER:
;	R1 -> ??DDB
;	(SP) = RET ADDR
; R1 CHANGED WHEN RETURNED

CALASN:	MAP	PUSH,APR=5,CODE,DATA,PIC ;SAVE OLD APR5 VALUES ONTO STACK
	MOV	R1,-(SP)	;SAVE R1 ONTO STACK
	MOV	(R1),R1		;GET DRIVER INDEX AND FLAGS
	BIC	#177400,R1	;R1 = DRIVER INDEX
	MOV	@DVRAP5(R1),-(SP) ;PUSH NEW APR5 VALUE ONTO STACK
	MOV	$ASNTB(R1),-(SP) ;PUSH ASSIGN ENTRY POINT ONTO STACK
	MOV	4(SP),R1	;RESTORE R1
	MOV	(SP)+,2(SP)	;ASSIGN ENTRY PT SHOULD BE 2ND ITEM ON STACK
	JMPX	CALLMX		;GOTO MAPPED CALL SERVICE....

	GLOBAL	<MONPOL,$ASNTB,CALLMX>

;+
; TERMINAL UNIT ADDRESS FOR RSTS/KMC-3271
;
; MAXIMUN 32 TERMINALS PER CONTROLLER
; THEY SHOULD BE IDENTIFIED IN THE FOLLOWING ORDER AS IN EBCDIC:
;
;	SPACE,A,B,C,D,E,F,G,H,I,CENT-SIGN,
;	.,<,(,+,PL/1 UPSLASH,&,J,K,L,M,N,O,
;	P,Q,R,!,$,*,),;,PL/1 NOT SIGN
;-

DEVTAB:
	.BYTE	64.		;SPACE
	.BYTE	193.		;A
	.BYTE	194.		;B
	.BYTE	195.		;C
	.BYTE	196.		;D
	.BYTE	197.		;E
	.BYTE	198.		;F
	.BYTE	199.		;G
	.BYTE	200.		;H
	.BYTE	201.		;I
	.BYTE	74.		;CENT SIGN
	.BYTE	75.		;.
	.BYTE	76.		;<
	.BYTE	77.		;(
	.BYTE	78.		;+
	.BYTE	79.		;PL/1 UPSLASH
	.BYTE	80.		;&
	.BYTE	209.		;J
	.BYTE	210.		;K
	.BYTE	211.		;L
	.BYTE	212.		;M
	.BYTE	213.		;N
	.BYTE	214.		;O
	.BYTE	215.		;P
	.BYTE	216.		;Q
	.BYTE	217.		;R
	.BYTE	90.		;!
	.BYTE	91.		;$
	.BYTE	92.		;*
	.BYTE	93.		;)
	.BYTE	94.		;;
	.BYTE	95.		;PL/1 NOT SIGN


FQFEND

.END

