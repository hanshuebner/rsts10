	.INCLUDE /CMN:COMMON/
	.INCLUDE /CMN:KERNEL/
	.INCLUDE /CMN:FLDEF/
	.INCLUDE /CMN:DTDEF/
TITLE	DTU,<DECTAPE UTILITY CODE>,0A,10-MAY-91,ABC/SJK

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR DTU
;+
;
;  000	RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;
;-

; MACROS FOR DTU

.MACRO	CALLU	NAME,REG,ARG
.IRP	N,<\FQFNUM>
	 CALL	NAME''N,REG,<ARG>
.ENDM
.ENDM	CALLU

.MACRO	ENTERU	NAME
.IRP	N,<\FQFNUM>
NAME''N:
.ENDM
.ENDM	ENTERU

; COMMON BIT ASSIGNMENTS IN "DTST"

.DSECT	3

	.BLKB	31	;EXTENDED DATA BITS
	.BLKB	4	;DATA TRACKS
	.BLKB	.	;MAINTENANCE MARK TRACK
	.BLKB	.	;CLOCK SIMULATES TIMING
	.BLKB	.	;TAPE IS UP TO SPEED
	.BLKB	.	;NON-EXISTENT MEMORY
	.BLKB	.	;DATA MISSED
	.BLKB	.	;BLOCK MISSED
TCSELE:	.BLKB	.	;SELECT ERROR
TCILO:	.BLKB	.	;ILLEGAL OPERATION
TCMTE:	.BLKB	.	;MARK TRACK ERROR
TCPAR:	.BLKB	.	;PARITY ERROR
	.BLKB	.	;END ZONE

.SBTTL	DECTAPE BLOCK ALLOCATOR

FQFSRT	DTU

	BR	DTUERR		;ERROR HANDLER IS AT UTL-2

	FJMPDV	DT,UTL,ENTER	;DIRECTORY ALLOCATION UTILITY FUNCTION

	MOV	(R4),-(SP)	;WHEN ENTERED FROM DT DRIVER, REROUTE
	MOV	SP,@#FIQUE	; FIP'S QUEUE THROUGH THE STACK
DTALC1:	MOV	DTFDDB(R4),R1	;ENTER HERE FROM OPEN. POINT TO THE DDB
	MOV	#DDRLO,(R4)	;RESET FIRST WORD OF FCB TO DDRLO
	MOVB	DTIDX(R1),(R4)	; + IDX.DT
	MOVB	DTBUFB(R1),R2	;GET THE BIAS INTO BUFF.SYS FOR UNIT
	ADD	#DTBPBM,R2	; + THE PBM BIAS
	MOV	#BFBASE,R0	;POINT TO THE INFO ON BUFF.SYS
	MOVB	(R0)+,@#FIPUNT	;SET THE UNIT
	MOVB	(R0)+,R3	;GET THE DISK MSB
	ADD	(R0),R2		;ADD IN THE LSB
	ADC	R3		; AND CARRY
	CALLX	READ		;READ IN THE PBM
	MOV	DTFPTR(R4),R0	;IS THIS THE FIRST TIME THROUGH?
	BNE	20$		;NO, WE'VE BEEN HERE BEFORE
	;CLR	R0		;YES, CLEAR R0 TO START ALLOCATION
	MOV	#FIBUF+80.,R2	;CLEAR OUT THE TEMPORARY FILE BIT MAP
	MOV	#512.-80./2,R1	;WHICH IS STORED BENEATH THE PBM
10$:	CLR	(R2)+
	SOB	R1,10$
	;CLR	R1		;R1 = 0 FROM SOB
	INC	R1		;R1 = 1 FOR ALLOCATOR (FORWARD SEARCH)
	CALL	DTGBLI		;GET THE INITIAL BLOCK FOR THE FILE
	MOV	R0,DTFSBL(R4)	;SAVE AS FILE'S START BLOCK
	MOV	R0,DTFNXB(R4)	;AND AS NEXT BLOCK TO WRITE
20$:	MOV	DTFNXB(R4),R0	;GET BLOCK TO ALLOCATE FROM
	MOV	R4,R5		;POINT TO THE WINDOW
	ADD	#DTFWND,R5	; IN THE FCB
	MOV	R5,DTFPTR(R4)	;RESET THE WINDOW POINTER
30$:	CALL	DTGBLK		;GET ANOTHER BLOCK
	MOV	R0,(R5)+	;SAVE IN THE WINDOW
	BIT	R5,#37		;DONE?
	BNE	30$		;NO
	CALLX	WRITE		;WRITE OUT THE ALTERED BUFFER
	TST	DTFLEN(R4)	;IS THE FILE 0 LENGTH?
	BEQ	40$		;YES, WE WERE CALLED FROM OPEN
	MOV	DTFDDB(R4),R4	;R4 -> DDB
	CALLX	QUEL3Q		;QUEUE HIM INTO THAT STEP
40$:	JMPX	FIEXIT		;EXIT FROM FIP (IF NOT OPEN, IGNORE JSFIP)

GLOBAL	<FIQUE,BFBASE,FIPUNT,FIBUF>

; THE ACTUAL ALLOCATOR

.ENABL	LSB

DTGBLK:	MOV	#1,R1		;ASSUME WE WILL SEARCH FORWARD
	TST	R0		;CHECK THE BLOCK TO START THE SEARCH
	BEQ	80$		;IF PREVIOUS WAS 0, WE'RE EMPTY
	BPL	10$		;IF POSITIVE, WE ARE OK
	NEG	R1		;BACKWARDS, DIRECTION IS -1
	NEG	R0		;AND GET POSITIVE BLOCK NUMBER
	SUB	#6,R0		;START SEARCH AT BLOCK -4 (BACKWARDS)
10$:	ADD	#3,R0		;START SEARCH AT BLOCK +4 (FORWARDS)
DTGBLI:	CLR	-(SP)		;FLIP-FLOP DETECTS 2 TURN-AROUNDS
20$:	ADD	R1,R0		;MOVE TO THE NEXT BLOCK
	BMI	30$		;AT START OF TAPE, GO TURN AROUND
	CMP	R0,#575.	;END OF TAPE?
	BLE	50$		;NO, KEEP LOOKING
30$:	MOV	#575.,R0	;GUESS THAT WE ARE TURN TO BACKWARDS
	NEG	R1		;REVERSE THE SEARCH
	BMI	40$		;GOOD GUESS
	MOV	R1,R0		;NOPE, START FORWARDS FROM 1
40$:	COM	(SP)		;FLIP THE FLOP
	BEQ	70$		;SECOND REVERSAL MEANS ALL FULL
50$:	MOV	R0,R3		;COPY THE BLOCK NUMBER
	CLR	R2		;CLEAR FOR DIVIDE
	DIV	#8.,R2		;CONVERT TO BIT AND BYTE
	MOVB	BITBYT(R3),R3	;AND GET CORRESPONDING BIT
	BITB	R3,FIBUF+8.(R2)	;IS THIS BLOCK AVAILABLE?
	BNE	20$		;NOPE, TRY AGAIN
	BISB	R3,FIBUF+8.(R2)	;ALLOCATE THE BIT FROM THE PBM
	BISB	R3,FIBUF+80.(R2) ; AND IN THE TFBM
	TST	R1		;BACKWARDS ALLOCATION?
	BPL	60$		;NO
	NEG	R0		;YES, GIVE HIM A BACKWARDS BLOCK
60$:	MOV	R0,(SP)		;RETURN IT IN R0
70$:	MOV	(SP)+,R0	;RETURN THE BLOCK OR 0
80$:	RETURN

.DSABL	LSB

GLOBAL	<BITBYT,FIBUF>

.SBTTL	DECTAPE ERROR RECOVERY FROM FIP

;+
; DTUERR - HANDLE ERRORS DURING FIP DECTAPE I/O
;
; ENTRY CONDITIONS:
;
;	R4 -> USER'S FIRQB
;		FQSIZ  = USER'S R5
;		FQCLUS = POINTER TO DDB @ DTQPTR
;	DDB @ DTRIO CONTAINS RETURN ADDRESS WITHIN FIP, ODD IF CLOSE
;-

DTUERR:	CALLU	SETUP		;SET UP THE REGISTERS
	ASR	-(R4)		;WAS THE CALL FROM CLOSE?
.ASSUME	DTRIO	EQ	DTQPTR-2
	BCC	10$		;NO
	BIS	#377,-(R4)	;DTOFIL = -1, NO OUTPUT ACTIVE
.ASSUME	DTOFIL	EQ	DTRIO-2
	MOV	FQSIZ(R1),R4	;RETURN THE FCB
	BUFFER	RETSML
10$:	MOV	FQCLUS(R1),R4	;RESTORE THE DDB POINTER
	CALLX	RETBIG,R5,512.	;RETURN THE BIG BUFFER
	MOV	R4,R1		;COPY THE DDB POINTER
	SUB	#DTDDSP,R1	;UNBIAS IT
	CALLX	RETDEV		; AND RETURN IT
	CMPB	DTSERR(R4),#CTRLCE ;WAS IT STOPPED BY ^C?
	BNE	20$		;NO
	ERROR	CTRLCE		;YES, GIVE THE ERROR

20$:	MOVB	DTECNT(R4),R0	;GET THE HARDWARE ERROR CODE
	BNE	40$		;NO
30$:	ERROR	HNGDEV		;HUNG DEVICE

40$:	BIT	R0,#<TCPAR!TCMTE>/400 ;PARITY OR MARK TRACK ERROR?
	BEQ	50$		;NO
	ERROR	DATERR		;USER DATA ERROR ON DEVICE

50$:	BIT	R0,#<TCILO!TCSELE>/400 ;ILLEGAL OP(WRITE LOCK) OR SELECT
	BNE	30$		;YES, HUNG DEVICE
	ERROR	ABORT		;NO, ABORT

.SBTTL	UTILITIES FOR DTU0

ENTERU	SETUP
	MOV	R4,R1		;USE R1 AS A FIRQB POINTER
	MOV	FQCLUS(R4),R4	;RESTORE THE DDB POINTER
	MOV	R1,DTFQCB(R4)	;ENSURE THAT THE DDB LINKS TO THE FIRQB
	RETURN

FQFEND

.SBTTL	DECTAPE OPEN

FQFSRT

	FJMPDV	DT,OPN,ENTER

;+
; DECTAPE OPEN - ENTRY CONDITIONS
;
;	R1 -> DDB
;	R4 -> FIRQB
;		FQSWIT = 0  => OPEN FOR INPUT
;		FQSWIT = -1 => OPEN FOR OUTPUT
;	GETDEV HAS BEEN CALLED TO ACQUIRE THE TAPE
;-

.ENABL	LSB

	CALLU	SETDT		;HANDLE REGISTER SHIFTS & CROSS-LINKS
	TST	FQNAM1(R1)	;IS THIS A FILE STRUCTURED OPEN?
	BNE	30$		;YES, GO DO IT
	TSTB	DTDDCT(R4)	;NFS OPEN. ANYTHING ELSE OPEN?
	BEQ	20$		;NOPE, THIS CAN GO THROUGH
10$:	ERROR	DTOOOF		;NO, GIVE HIM AN ERROR

20$:	CALL	DTSML,R5,DDNFS	;GET AN FCB & INIT IT
	BIS	#DDSTAT,(R0)	;TURN ON DDB FLAG SAYING TAPE IS NFS
	MOV	#578.,DTFLEN(R4) ;THE SIZE IS 578. BLOCKS
	BR	90$		;GO SET UP THE FCB

30$:	TST	FQSWIT(R1)	;FS OPEN. INPUT OR OUTPUT?
	BPL	40$		;INPUT, THAT'S ALWAYS POSSIBLE
	TSTB	DTOFIL(R4)	;IF OUTPUT, THIS MUST BE THE FIRST
	BPL	10$		;NO, ANOTHER OUTPUT IS OPEN
	MOV	R4,-(SP)	;SAVE THE DDB POINTER
	MOV	R1,R4		;REPLACE WITH A FIRQB POINTER
	CALLX	CHKNAM		;CHECK THE NAME SUPPLIED FOR OPEN FOR OUTPUT
	MOV	R4,R1		;IF WE RETURN EVERYTHING IS FINE
	MOV	(SP)+,R4	;RESTORE THE DDB AND FIRQB POINTERS
40$:	TST	(R0)		;IS THE TAPE OPEN NFS?
	BPL	50$		;NOPE, FS OPEN CAN GO THROUGH
	ERROR	DEVNFS		;TAPE ALREADY OPEN NON-FILE STRUCTURED

50$:	BIS	#DDUTIL,DTDDCT(R4) ;ASSIGN FOR UTILITY SEQUENCE DURING OPEN
	TSTB	DTDDCT(R4)	;IS ANYTHING OPEN ON THE TAPE?
	BNE	DTOPN1		;IF SO, DIRECTORY IS ON DISK
	MOV	#DTOPN1,R5	;SET RETURN ADDRESS
	FJMP	DTRDIR		; AND GO GET DIRECTORIES ON DISK

DTOPN1:	CALLU	DTSCH,R5,FQNAM1 ;SEARCH FOR NAME AT FQNAM1 IN THE FIRQB
	BCS	110$		;NOT FOUND
	TST	FQSWIT(R1)	;GOT IT. OPEN FOR OUTPUT?
	BPL	60$		;NO
	FJMP	DTKIL1		;YES, GO KILL IT AND TRY AGAIN

60$:	CALL	DTSML,R5,DDWLO	;GET FCB AND INIT FOR INPUT FILE
	ADD	#DTUSBL,R5	;POINT TO STARTING BLOCK INFO
	MOV	(R5),DTFNXB(R4)	;NEXT BLOCK TO READ IS FIRST BLOCK
	MOV	(R5)+,DTFSBL(R4) ;STARTING BLOCK NUMBER IN FCB
	MOV	(R5),DTFLEN(R4)	;LENGTH
	TST	DTUDAT-DTULEN(R5) ;CONTIGUOUS FILE?
	BMI	80$		;YES, GO DO SPECIALS
	COM	DTFPTR(R4)	;DTFPTR <> 0 FOR LINKED INPUT
70$:	MOV	#510.,FQBUFL(R1) ;SET 510 BYTE BUFFER LENGTH IN FIRQB
	MOV	(R4),FQFLAG(R1)	;RETURN FLAG BITS IN FIRQB
	BR	100$		;MERGE

80$:	INC	DTFNXB(R4)	;YES, NEXT BLOCK TO GET IS BLOCK 1
	MOVB	#DT.CTG/400,1(R4) ;SET UP CORRECT STATUS BITS
90$:	MOV	#512.,FQBUFL(R1) ;SET 512 BYTE BUFFER LENGTH IN FIRQB
	MOV	(R4),FQFLAG(R1)	;SET THE FLAG BITS INCLUDING
	BIS	#FLGRND,FQFLAG(R1) ; THE "RANDOM" ACCESS BIT
100$:	MOVB	#DTAHND,FQFLAG(R1) ;SET HANDLER INDEX FOR OUTSIDE WORLD
	MOV	DTFLEN(R4),FQSIZ(R1) ;RETURN SIZE IN FIRQB
	MOVB	FQJOB(R1),DDJBNO(R4) ;SET JOB NUMBER IN FCB
	MOVB	FQFIL(R1),R0	;GET CHANNEL NUMBER * 2
	MOV	@#FIJBDA,R5	;POINT TO CALLER'S JDB
	ADD	(R5),R0		;ADD IN IOB POINTER
	MOV	R4,(R0)		;LINK HIS IOB TO THE DECTAPE FCB
	MOV	R3,DTFDDB(R4)	;LINK FCB TO DDB
	INCB	DTDDCT(R3)	;ONE MORE FILE OPEN HERE
	BIC	#DDUTIL,DTDDCT(R3) ;NO LONGER UTILITY, SINCE TRULY OPEN
	RETURN

110$:	TST	FQSWIT(R1)	;NOT FOUND. WHY DID WE WANT IT?
	BMI	120$		;FOR OUTPUT, GO CREATE IT
	CALLU	DTRET		;RETURN THE TAPE
	ERROR	NOSUCH

120$:	CALL	DTSHOL,R5,<0,0,0> ;OUTPUT, FIND A HOLE IN THE DIRECTORY
	BCC	130$		;GOT IT
	CALLU	DTRET		;NO ROOM. RETURN THE TAPE
	ERROR	NOROOM
GLOBAL	<FIJBDA>

130$:	CALL	DTSML,R5,DDRLO	;GET FCB, INIT FOR OUTPUT FILE
	MOV	FQNAM1(R1),(R5)+ ;PUT THE NAME IN THE DIRECTORY
	MOV	FQNAM1+2(R1),(R5)+
	MOV	FQEXT(R1),(R5)+
	MOV	@#DATE,(R5)+	;CREATION DATE
	ADD	#10,R5		;SKIP MODE, START, LENGTH, END
	MOV	#233,(R5)+	;PROTECTION
	MOVB	R0,DTOFIL(R3)	;INDICATE OUTPUT FILE OPEN
	MARK	FIBUF		;WE CHANGED THE UFD ON DISK
	CALL	70$		;BUILD THE FCB (LEAVE LENGTH 0)
	FJMP	DTALC1		;ALLOCATE THE FIRST WINDOW

.DSABL	LSB

;+
; DTSML - GET A SMALL BUFFER FOR OPEN
;
;	R4 -> DDB @ DTQPTR
;
;	CALL	DTSML,R5,FLAGS
;
;	R3 -> DDB @ DTQPTR
;	R4 -> FCB, WITH IDX.DT+FLAGS PLACED IN FIRST WORD
;-

DTSML:	MOV	R4,R3		;SHIFT DDB POINTER TO A NEW REGISTER
	BUFFER	GETSML,,20.	;GET A SMALL BUFFER FOR AN FCB
	BVS	10$		;NO CAN DO
	MOV	(R5)+,(R4)	;SET THE FLAG WORD OF THE FCB
	MOVB	DTIDX(R3),(R4)	; AND PUT IN THE DECTAPE INDEX FROM DDB
	RETURN	R5

10$:	MOV	R3,R4		;RESTORE THE DDB POINTER
	CALLU	DTRET		;RETURN THE TAPE
	ERROR	NOBUFS		;NO BUFFER FOR FCB

.SBTTL	UTILITIES FOR DTU1

; GRAB THE DECTAPE AND ENSURE NOT ALREADY NFS OPEN

ENTERU	DTGET
	CALLX	GETDEV		;GRAB THE TAPE
	TST	(R1)		;ALREADY NFS OPEN?
	BPL	10$		;NOPE
	ERROR	DEVNFS		;YES, SAY DEVICE IS NFS

10$:	BIS	#DDUTIL,DDCNT(R1) ;ASSIGN IT FOR UTILITY SEQUENCE
ENTERU	SETDT
	MOV	R1,R0		;SAVE THE UNBIASED POINTER
	ADD	#DTDDSP,R1	;BIAS THE POINTER
	MOV	R1,FQCLUS(R4)	;LINK FIRQB TO DDB
ENTERU	SETUP
	MOV	R4,R1		;USE R1 AS A FIRQB POINTER
	MOV	FQCLUS(R4),R4	;RESTORE THE DDB POINTER
	MOV	R1,DTFQCB(R4)	;ENSURE THAT THE DDB LINKS TO THE FIRQB
	RETURN

ENTERU	DTRET
	MOV	R4,R1		;COPY THE DDB POINTER
	SUB	#DTDDSP,R1	;UNBIAS IT
	CALLRX	RETDEV

;+
; DTSHOL - SEARCH THE TAPE DIRECTORY FOR A HOLE
;
;	DIRECTORIES ON DISK
;
;	CALL	DTSHOL,R5,<0,0,0>
;
;	R0 =  DIRECTORY INDEX (0 TO 57.)
;	R2 =  BIAS OF UFD BLOCK INTO BUFF.SYS
;	R3 -> THE SEARCH ARGUMENT (0,0,0)
;	R5 -> HOLE IN FIBUF
;
;	C=0 IF HOLE WAS FOUND
;	C=1 IF NO HOLE IN DIRECTORY
;-

.ENABL	LSB

DTSHOL:	MOV	R5,R3		;THE HOLE FOLLOWS THE CALL
	CMP	(R5)+,(R5)+	;BUMP OVER FIRST TWO WORDS
	BR	10$		;ENTER THE MAIN LOOP

;+
; DTSCH - SEARCH THE TAPE DIRECTORY FOR A NAME
;
;	R1 -> FIRQB, WITH NAME.EXT AT KNOWN OFFSET
;	DIRECTORIES ON DISK
;
;	CALLU	DTSCH,R5,<OFFSET OF NAME IN FIRQB>
;
;	R0 =  DIRECTORY INDEX (0 TO 57.)
;	R2 =  BIAS OF UFD BLOCK INTO BUFF.SYS
;	R3 -> FILE NAME IN FIRQB
;	R5 -> UFD ENTRY IN FIBUF
;
;	C=0 IF FILE WAS FOUND
;	C=1 IF NO SUCH FILE IN DIRECTORY
;-

ENTERU	DTSCH
	MOV	R1,R3		;COPY THE FIRQB POINTER
10$:	ADD	(R5)+,R3	;ADD IN THE BIAS TO POINT TO THE NAME
	MOV	R5,(SP)		;SAVE RETURN ADDRESS
	MOV	#DTBUF0-1,-(SP)	;SET BUFF.SYS BIAS (BIASED)
	CLR	R0		;COUNTER = 0
20$:	INC	(SP)		;GET NEXT BUFF.SYS BIAS
	MOV	(SP),R2		;COPY TO R2 FOR READING FROM BUFF.SYS
	CALLU	DTCRR		;READ A UFD BLOCK FROM DISK
	MOV	#FIBUF+2,R5	;POINT TO THE DIRECTORY
30$:	MOV	R5,R2		;COPY THE DIRECTORY POINTER
	CMP	(R2)+,(R3)	;CHECK THE NAME
	BNE	40$
	CMP	(R2)+,2(R3)
	BNE	40$
	CMP	(R2)+,4(R3)
	BEQ	50$		;FOUND IT
40$:	ADD	#DTU$SZ,R5	;POINT TO NEXT ENTRY IN THIS BLOCK
	INC	R0		;BUMP FILE NUMBER
	CMP	R0,#28.		;END OF UFD0 BLOCK?
	BEQ	20$		;YES, GO TRY UFD1
	CMP	#56.-1,R0	;END OF UFD1 BLOCK?
	BHIS	30$		;NO, TRY AGAIN IN THIS BLOCK
	;SEC			;C=1 FROM CMP (BHIS = BCC)
50$:	MOV	(SP)+,R2	;RETURN BIAS INTO BUFF.SYS
	RETURN			;RETURN WITH C=1 FOR FAILURE

.DSABL	LSB

GLOBAL	<FIBUF>

;+
; READ A BLOCK FROM BUFF.SYS FOR DECTAPE UTILITY
;
;	R2 = BIAS INTO DIRECTORY BLOKS
;	CALLU	DTCRR
;-

ENTERU	DTCRR
	REGSCR			;SAVE ALL REGISTERS
	MOVB	DTBUFB(R4),R0	;GET OFFSET FROM START OF BUFF.SYS
	ADD	R0,R2		;COMPUTE (SMALL) OFFSET INTO FILE
	MOV	#BFBASE,R0	;POINT TO BUFF.SYS BASE DATA
	MOVB	(R0)+,@#FIPUNT	;SET FIP UNIT NUMBER
	MOVB	(R0)+,R3	;BUFF.SYS MSB
	ADD	(R0),R2		;ADD IN LSB
	ADC	R3		; AND CARRY
	CALLRX	READ		;READ THE BLOCK

GLOBAL	<BFBASE,FIPUNT>

FQFEND

.SBTTL	DECTAPE CLOSE

FQFSRT

	FJMPDV	DT,CLS,ENTER	;DECTAPE CLOSE

;+
; DECTAPE CLOSE - ENTRY CONDITIONS
;
;	R1 -> FCB, WHICH HAS BEEN REMOVED FROM THE IOB
;	R4 -> FIRQB
;	R5 -> DDB @ DDIDX (UNBIASED)
;-

.ENABL	LSB

	MOV	R1,R0		;COPY FCB POINTER
	MOV	R5,R1		;GET DDB POINTER IN THE STANDARD PLACE
	MOV	R0,R5		;GET FCB POINTER
	CALLU	SETDT		;HANDLE REGISTER SHIFTS
	DECB	DTDDCT(R4)	;ONE LESS OPEN FILE
	MOV	DTFLBL(R5),R0	;REWRITE FINAL BLOCK WITHOUT LINK
	BEQ	20$		;A NULL FILE!
	NEG	R0		;FIRST, READ IT BACKWARDS
	MOV	R0,DTBLOK(R4)	; BY SETTING THE NEGATIVE BLOCK NUMBER
	CALLU	DTCIO,R5,RED.DT ;REREAD THE LAST BLOCK
	MOV	DTBUFF(R4),R3	;GET THE BUFFER ADDRESS
	MOV	R3,R0		;COPY IT
	ADD	#776,R0		;POINT TO LAST WORD (LINK WORD)
	CLR	(R0)+		;CLEAR LINK, POINT TO END
10$:	MOV	(R3),R2		;REVERSE THE BUFFER. GET LOW WORD,
	MOV	-(R0),(R3)+	; REPLACE IT WITH HIGH WORD
	MOV	R2,(R0)		;  WHICH IS OVERLAID WITH LOW WORD
	CMP	R3,R0		;IF POINTERS HAVEN'T MET YET
	BLO	10$		; THEN WE HAVE MORE TO DO
	MOV	DTFLBL(R5),DTBLOK(R4) ;SET TRUE BLOCK NUMBER
	CALLU	DTCIO,R5,WRT.DT ;REWRITE IT
	CALLX	RETBIG,R5,512.	;GIVE BACK THE BIG BUFFER
20$:	MOVB	DTOFIL(R4),R3	;GET FILE INDEX WITHIN DIRECTORY
	CLR	R2		;CLEAR FOR DIVIDE
	DIV	#7,R2		;COMPUTE BLOCK AND BIAS FOR FILE BIT MAP
	ADD	#DT$BM0,R2	;BIT MAPS START HERE ON TAPE
	CMP	R2,DTBLOK(R4)	;IS THE TAPE NOW HIGHER THAN THE MAPS?
	BGT	30$		;NOPE, LOWER. START SEARCH FORWARD
	MOV	#REV.DT,DTSOPT(R4) ;YES, OPTIMIZE BY SEARCHING REVERSE
30$:	MOV	R2,DTBLOK(R4)	;SO ALTER THAT BLOCK
	MUL	#36.*2,R3	;THERE ARE 36 WORDS PER MAP
	MOV	R3,FQPROT-1(R1)	;SAVE THE MAP OFFSET IN THE FIRQB

	CALLU	DTCIO,R5,RED.DT ;READ THE MAP BLOCK FROM TAPE
	MOV	#DTBPBM,R2	;GET THE PBM NUMBER
	CALLU	DTCRR		;READ THE PBM BLOCK FROM BUFF.SYS
	MOV	DTFPTR(R5),R0	;RETURN UNUSED BLOCKS FROM THE WINDOW
	MOV	DTFNXB(R5),R3	;INCLUDING THE NEXT BLOCK
	BEQ	60$		; IF ANY
40$:	BPL	50$		;OK IF POSITIVE
	NEG	R3		;GET ABSOLUTE VALUE OF BLOCK NUMBER
50$:	CLR	R2		;CLEAR FOR DIVIDE
	DIV	#8.,R2		;COMPUTE BYTE AND BIT
	BICB	BITBYT(R3),FIBUF+8.(R2) ;FREE THE BLOCK IN THE PBM
	BICB	BITBYT(R3),FIBUF+80.(R2) ; AND IN THE TFBM
	BIT	R0,#37		;DONE WITH THE WINDOW?
	BEQ	60$		;YES
	MOV	(R0)+,R3	;NO, GET ANOTHER BLOCK FROM IT
	BNE	40$		;DEALLOCATE IF REAL
60$:	CALLX	WRITE		;PBM IS ALTERED
	MOV	#FIBUF+80.,R2	;POINT TO THE TFBM
	MOV	DTBUFF(R4),R0	;POINT TO THE BUFFER
	ADD	FQPROT-1(R1),R0	; AND OFFSET TO THE FILE BIT MAP
	MOV	#36.,R3		;THERE ARE 36 WORDS TO MOVE
70$:	MOV	(R2)+,(R0)+	;MOVE TFBM TO FBM
	SOB	R3,70$
	CALLU	DTCIO,R5,WRT.DT ;REWRITE THE FBM
	MOVB	DTOFIL(R4),R3	;GET THE OUTPUT FILE NUMBER
	CLR	R2		;CLEAR FOR DIVIDE
	DIV	#28.,R2		;COMPUTE FILE NUMBER WITHIN UFD BLOCK
	CALLU	DTCRR		;READ BLOCK FROM BUFF.SYS
	MUL	#DTU$SZ,R3	;COMPUTE OFFSET TO DIRECTORY ENTRY
	ADD	#FIBUF+2+DTUSBL,R3 ; AND GET ACTUAL ADDRESS
	MOV	DTFSBL(R5),(R3)+ ;SAVE STARTING BLOCK
	MOV	DTFLEN(R5),(R3)+ ;SAVE LENGTH
	MOV	DTFLBL(R5),(R3)+ ;SAVE ENDING BLOCK
	BNE	90$		;IF NON-0, THEN FILE HAS BEEN WRITTEN
	TST	(R3)+		;POINT TO THE END OF THE UFD ENTRY
	MOV	#9.,R0		;CLEAR OUT 9 WORDS
80$:	CLR	-(R3)		;NULL ENTRY FOR NULL LENGTH FILE
	SOB	R0,80$
90$:	CALLX	WRITE		;UFD IS ALTERED
	MOVB	#-1,DTOFIL(R4)	;OUTPUT FILE NOT OPEN NOW
	MOV	R5,R4		;NOW RETURN THE FCB
	BUFFER	RETSML

GLOBAL	<BITBYT,FIBUF>

; THE FILE IS NOW TECHNICALLY CLOSED

	MOV	FQCLUS(R1),R4	;RESTORE DDB POINTER
	MOV	R2,R5		;COPY UFD BLOCK WHICH WAS CHANGED
	MOV	#DTBPBM,R2	;FIRST, UPDATE THE BIT MAP
	CALLU	DTCRR		;READ IT
	MOV	DTBUFF(R4),R0	;POINT TO OUTPUT BUFFER FOR TAPE
	MOV	#FIBUF,R2	;POINT TO NEW DATA FRO BUFF.SYS
	MOV	#256.,R3	;ONE BLOCK
100$:	MOV	(R2)+,(R0)+	;COPY IT
	SOB	R3,100$
	MOV	#256.-<4.+36.>,R3 ;NOW FILL THE END OF THE MAP
110$:	MOV	#-1,-(R0)	; WITH -1 FOR ALLOCATED
	SOB	R3,110$
	MOV	#DT$PBM,DTBLOK(R4) ;SET BLOCK TO WRITE
	CALLU	DTSIO,R5,WRT.DT ;WRITE THE TAPE BLOCK
	MOV	R5,R2		;NOW GET THE UFD TO REWRITE
	CALLU	DTCRR		;READ THE BLOCK FROM BUFF.SYS
	NEG	R5		;COMPUTE PHYSICAL BLOCK TO WRITE REVERSE
	SUB	#DT$UF0,R5	; BY TAKING -(DT$UF0+BIAS)
	MOV	R5,DTBLOK(R4)	;SET IT
	MOV	DTBUFF(R4),R0	;COPY DISK BUFFER TO BIG BUFFER
	MOV	#FIBUF+1000,R2	; AND REVERSE IT IN THE PROCESS
	MOV	#256.,R3	;ONE BLOCK
120$:	MOV	-(R2),(R0)+	;COPY THE BLOCK
	SOB	R3,120$
	CALLU	DTSIO,R5,WRT.DT ;WRITE OUT THE ALTERED UFD
	CALLX	RETBIG,R5,512.	;GIVE BACK THE BIG BUFFER
	;CALLRU	DTRET		;RETURN THE TAPE AND EXIT

ENTERU	DTRET
	MOV	R4,R1		;COPY THE DDB POINTER
	SUB	#DTDDSP,R1	;UNBIAS IT
	CALLRX	RETDEV

.DSABL	LSB

GLOBAL	<FIBUF>

.SBTTL	UTILITIES FOR DTU2

; HANDLE REGISTER SHIFTS FOR DECTAPE ENTRY

ENTERU	SETDT
	MOV	R1,R0		;SAVE THE UNBIASED POINTER
	ADD	#DTDDSP,R1	;BIAS THE POINTER
	MOV	R1,FQCLUS(R4)	;LINK FIRQB TO DDB
ENTERU	SETUP
	MOV	R4,R1		;USE R1 AS A FIRQB POINTER
	MOV	FQCLUS(R4),R4	;RESTORE THE DDB POINTER
	MOV	R1,DTFQCB(R4)	;ENSURE THAT THE DDB LINKS TO THE FIRQB
	RETURN

; DO DECTAPE I/O FOR FIP

;+
; DTSIO - DO DECTAPE I/O FOR FIP
;
;	R1 -> FIRQB
;	R4 -> DDB @ DTQPTR
;
;	CALLU	DTSIO,R5,<DT FUNCTION>
;
;	R0,R2,R3 RANDOM
;-

ENTERU	DTSIO
	TST	(PC)+		;CLEAR THE CARRY, SKIP THE 'SEC'
ENTERU	DTCIO			;SPECIAL I/O CALL FOR CLOSE
	SEC			;C=1 TO FORCE ODD ADDRESS IN DTRIO
	MOV	(R5)+,DTCFUN(R4) ;LOAD THE FUNCTION INTO THE DDB
	ADC	R5		;SET R5 ODD IF CLOSING A FILE
	MOV	#10$,FQADDR(R1)	;LOAD THE ADDRESS TO FJMP BACK TO
	MOV	DTFIPQ(R4),DTRPTR(R4) ;LOAD THE QUEUE & L3Q BITS
	CALLX	QUEL3Q		;QUEUE IT AND START THE PROCESS
	MOV	R5,-(R4)	;SAVE RETURN ADDRESS IN DTRIO
	MOV	(SP)+,FQSIZ(R1)	;SAVE CALLER'S R5 IN FQSIZ
	JMPX	FIEXIX		;EXIT WITHOUT FINISHING

10$:	MOV	FQSIZ(R4),R5	;RESTORE CALLER'S R5
	CALLU	SETUP		;SET UP THE REGISTERS
	BIC	#1,DTRIO(R4)	;EVEN OUT THE RETURN ADDRESS
	JMP	@DTRIO(R4)	;RETURN TO CALLER

;+
; READ A BLOCK FROM BUFF.SYS FOR DECTAPE UTILITY
;
;	R2 = BIAS INTO DIRECTORY BLOKS
;	CALLU	DTCRR
;-

ENTERU	DTCRR
	REGSCR			;SAVE ALL REGISTERS
	MOVB	DTBUFB(R4),R0	;GET OFFSET FROM START OF BUFF.SYS
	ADD	R0,R2		;COMPUTE (SMALL) OFFSET INTO FILE
	MOV	#BFBASE,R0	;POINT TO BUFF.SYS BASE DATA
	MOVB	(R0)+,@#FIPUNT	;SET FIP UNIT NUMBER
	MOVB	(R0)+,R3	;BUFF.SYS MSB
	ADD	(R0),R2		;ADD IN LSB
	ADC	R3		; AND CARRY
	CALLRX	READ		;READ THE BLOCK

GLOBAL	<BFBASE,FIPUNT>

FQFEND

.SBTTL	DECTAPE KILL

FQFSRT

	FJMPDV	DT,DLN,ENTER

;+
; DECTAPE KILL - ENTRY CONDITIONS
;
;	R1 -> DDB @ DDIDX (UNBIASED)
;	R4 -> FIRQB
;
;	AVAILABILITY HAS NOT BEEN CHECKED
;-

.ENABL	LSB

	CLR	FQSWIT(R4)	;SET FQSWIT = 0 TO INDICATE NO OPEN
	CALLU	DTGET		;SNAG THE TAPE, BUT NOT IF NFS
	TSTB	DTDDCT(R4)	;ANY OPEN FILES?
	BNE	10$		;IF SO, DIRECTORIES ARE ON DISK
	MOV	#10$,R5		;ELSE GO GET THE DIRECTORIES
	FJMP	DTRDIR
10$:	CALLU	DTSCH,R5,FQNAM1 ;SEARCH FOR THE FILE NAMED
	BCC	20$		;GOT IT
	CALLU	DTRET		;NOT THERE. RETURN THE TAPE
	ERROR	NOSUCH

20$:	CMPB	R0,DTOFIL(R4)	;ARE WE KILLING THE CURRENT OUTPUT FILE?
	BNE	DTKIL1		;NOPE
	ERROR	DTOOOF		;WE OWN THE OUTPUT FILE

DTKIL1:	MOV	#9.,R3		;COUNT OF NUMBER OF ENTRIES TO KILL
30$:	CLR	(R5)+		;ZAP THE DIRECTORY ENTRY
	SOB	R3,30$
	CALLX	WRITE		;ALTERED
	MOV	R2,R5		;PRESERVE UFD BLOCK WHICH WE CHANGED
	ADD	#DT$UF0,R2	;COMPUTE BLOCK ON TAPE
	MOV	R2,DTBLOK(R4)	;SET IT IN THE DDB
	MOV	R0,FQPROT-1(R1)	;SAVE THE FILE NUMBER IN THE FIRQB
	CALLU	DTSIO,R5,ALC.DT ;GET A BIG BUFFER

	MOV	R5,R2		;COPY THE BUFF.SYS BIAS FOR UFD BLOCK
	CALLU	DTCRR		;READ THE MODIFIED BLOCK FROM DISK
	MOV	DTBUFF(R4),R3	;POINT TO THE BIG BUFFER
	MOV	#FIBUF,R0	;POINT TO FIP'S BUFFER
	MOV	#256.,R2	;COPY THE WHOLE THING
40$:	MOV	(R0)+,(R3)+	; FROM FIBUF
	SOB	R2,40$		;  TO BIG BUFFER
	;CLR	R2		;CLEAR FOR DIVIDE
	MOVB	DTOFIL(R4),R3	;GET THE CURRENT OPEN OUTPUT FILE
	BMI	60$		;NONE, THIS IS EASY
	DIV	#28.,R2		;COMPUTE UFD BLOCK AND POSITION
	CMP	R2,R5		;IS THAT FILE IN THIS UFD BLOCK?
	BNE	60$		;NO, SO THE UFD BLOCK IS GOOD
	MUL	#DTU$SZ,R3	;COMPUTE OFFSET IN BIG BUFFER
	ADD	DTBUFF(R4),R3	; TO THE OUTPUT FILE'S ENTRY
	TST	(R3)+
	MOV	#9.,R0		;CLEAR IT SO IT DOESN'T SHOW ON TAPE
50$:	CLR	(R3)+		; UNTIL THE ACTUAL OUTPUT FILE
	SOB	R0,50$		;  IS CLOSED
60$:	CALLU	DTSIO,R5,WRT.DT ;WRITE THE MODIFIED UFD BLOCK
	MOV	FQPROT-1(R1),R3	;RESTORE THE FILE NUMBER
	CLR	R2		;CLEAR FOR DIVIDE
	DIV	#7,R2		;COMPUTE FBM BLOCK AND POSITION
	ADD	#DT$BM0,R2	;MAKE THE FBM BLOCK ABSOLUTE
	MOV	R2,DTBLOK(R4)	; AND SET IT IN THE DDB
	MUL	#36.*2,R3	;COMPUTE OFFSET IN FBM BLOCK OF MAP
	MOV	R3,R5		;SAVE IT IN R5
	CALLU	DTSIO,R5,RED.DT ;READ THE FBM BLOCK
	MOV	#DTBPBM,R2	;SET THE PBM OFFSET IN BUFF.SYS
	CALLU	DTCRR		;GET THE PBM FROM DISK
	ADD	DTBUFF(R4),R5	;POINT TO THE FILE BIT MAP
	MOV	#FIBUF+8.,R2	; AND TO THE PERMANENT BIT MAP
	MOV	#36.,R0		;CLEAR OUT BITS
70$:	BIC	(R5)+,(R2)+	; IN THE MAP IN FIBUF
	SOB	R0,70$		;LEAVE R2 POINTING AT TFBM IN FIBUF
	CALLX	WRITE		;BIT MAP IS NOW ALTERED ON DISK
	MOV	DTBUFF(R4),R3	;MOVE IT TO THE BIG BUFFER
	MOV	#FIBUF,R0	; FOR REWRITING TO TAPE
	MOV	#40.,R5		;COPY ONLY THE MAP PART TO THE BIG BUFFER
80$:	MOV	(R0)+,(R3)+
	SOB	R5,80$

GLOBAL	<FIBUF>

	TSTB	DTOFIL(R4)	;IS THERE AN ACTIVE OUTPUT FILE?
	BMI	100$		;NOPE, THIS IS EASY
	SUB	#36.*2,R3	;YES, BACK UP TO THE PBM IN BIG BUFFER
	MOV	#36.,R5		;ON TAPE, THOSE OUTPUT BLOCKS ARE FREE
90$:	BIS	(R2)+,(R3)+	; SINCE THE OUTPUT FILE ISN'T CLOSED
	SOB	R5,90$		;  SO REALLOCATE THE TFBM BITS
100$:	MOV	#256.-<40.>,R5	;NOW SET BITS IN THE REST OF THE PBM
110$:	MOV	#-1,(R3)+
	SOB	R5,110$
	MOV	#DT$PBM,DTBLOK(R4) ;BLOCK IS PBM
	CALLU	DTSIO,R5,WRT.DT ;WRITE THE MODIFIED PBM ONTO TAPE
	CALLX	RETBIG,R5,512.	;RETURN THE BIG BUFFER
	TST	FQSWIT(R1)	;CALLED FROM OPEN FOR OUTPUT?
	BNE	120$		;YES, RETURN TO OPEN CODE
	;CALLRU	DTRET		;NO, RETURN THE TAPE AND EXIT

ENTERU	DTRET
	MOV	R4,R1		;COPY THE DDB POINTER
	SUB	#DTDDSP,R1	;UNBIAS IT
	CALLRX	RETDEV

120$:	FJMP	DTOPN1		;RETURN TO OPEN CODE

.DSABL	LSB

.SBTTL	UTILITIES FOR DTU3

; GRAB THE DECTAPE AND ENSURE NOT ALREADY NFS OPEN

ENTERU	DTGET
	CALLX	GETDEV		;GRAB THE TAPE
	TST	(R1)		;ALREADY NFS OPEN?
	BPL	10$		;NOPE
	ERROR	DEVNFS		;YES, SAY DEVICE IS NFS

10$:	BIS	#DDUTIL,DDCNT(R1) ;ASSIGN IT FOR UTILITY SEQUENCE
ENTERU	SETDT
	MOV	R1,R0		;SAVE THE UNBIASED POINTER
	ADD	#DTDDSP,R1	;BIAS THE POINTER
	MOV	R1,FQCLUS(R4)	;LINK FIRQB TO DDB
ENTERU	SETUP
	MOV	R4,R1		;USE R1 AS A FIRQB POINTER
	MOV	FQCLUS(R4),R4	;RESTORE THE DDB POINTER
	MOV	R1,DTFQCB(R4)	;ENSURE THAT THE DDB LINKS TO THE FIRQB
	RETURN

; DO DECTAPE I/O FOR FIP

;+
; DTSIO - DO DECTAPE I/O FOR FIP
;
;	R1 -> FIRQB
;	R4 -> DDB @ DTQPTR
;
;	CALLU	DTSIO,R5,<DT FUNCTION>
;
;	R0,R2,R3 RANDOM
;-

ENTERU	DTSIO
	MOV	(R5)+,DTCFUN(R4) ;LOAD THE FUNCTION INTO THE DDB
	MOV	#10$,FQADDR(R1)	;LOAD THE ADDRESS TO FJMP BACK TO
	MOV	DTFIPQ(R4),DTRPTR(R4) ;LOAD THE QUEUE & L3Q BITS
	CALLX	QUEL3Q		;QUEUE IT AND START THE PROCESS
	MOV	R5,-(R4)	;SAVE RETURN ADDRESS IN DTRIO
	MOV	(SP)+,FQSIZ(R1)	;SAVE CALLER'S R5 IN FQSIZ
	JMPX	FIEXIX		;EXIT WITHOUT FINISHING

10$:	MOV	FQSIZ(R4),R5	;RESTORE CALLER'S R5
	CALLU	SETUP		;SET UP THE REGISTERS
	JMP	@DTRIO(R4)	;RETURN TO CALLER

;+
; DTSCH - SEARCH THE TAPE DIRECTORY FOR A NAME
;
;	R1 -> FIRQB, WITH NAME.EXT AT KNOWN OFFSET
;	DIRECTORIES ON DISK
;
;	CALLU	DTSCH,R5,<OFFSET OF NAME IN FIRQB>
;
;	R0 =  DIRECTORY INDEX (0 TO 57.)
;	R2 =  BIAS OF UFD BLOCK INTO BUFF.SYS
;	R3 -> FILE NAME IN FIRQB
;	R5 -> UFD ENTRY IN FIBUF
;
;	C=0 IF FILE WAS FOUND
;	C=1 IF NO SUCH FILE IN DIRECTORY
;-

.ENABL	LSB

ENTERU	DTSCH
	MOV	R1,R3		;COPY THE FIRQB POINTER
10$:	ADD	(R5)+,R3	;ADD IN THE BIAS TO POINT TO THE NAME
	MOV	R5,(SP)		;SAVE RETURN ADDRESS
	MOV	#DTBUF0-1,-(SP)	;SET BUFF.SYS BIAS (BIASED)
	CLR	R0		;COUNTER = 0
20$:	INC	(SP)		;GET NEXT BUFF.SYS BIAS
	MOV	(SP),R2		;COPY TO R2 FOR READING FROM BUFF.SYS
	CALLU	DTCRR		;READ A UFD BLOCK FROM DISK
	MOV	#FIBUF+2,R5	;POINT TO THE DIRECTORY
30$:	MOV	R5,R2		;COPY THE DIRECTORY POINTER
	CMP	(R2)+,(R3)	;CHECK THE NAME
	BNE	40$
	CMP	(R2)+,2(R3)
	BNE	40$
	CMP	(R2)+,4(R3)
	BEQ	50$		;FOUND IT
40$:	ADD	#DTU$SZ,R5	;POINT TO NEXT ENTRY IN THIS BLOCK
	INC	R0		;BUMP FILE NUMBER
	CMP	R0,#28.		;END OF UFD0 BLOCK?
	BEQ	20$		;YES, GO TRY UFD1
	CMP	#56.-1,R0	;END OF UFD1 BLOCK?
	BHIS	30$		;NO, TRY AGAIN IN THIS BLOCK
	;SEC			;C=1 FROM CMP (BHIS = BCC)
50$:	MOV	(SP)+,R2	;RETURN BIAS INTO BUFF.SYS
	RETURN			;RETURN WITH C=1 FOR FAILURE

.DSABL	LSB

GLOBAL	<FIBUF>

;+
; READ A BLOCK FROM BUFF.SYS FOR DECTAPE UTILITY
;
;	R2 = BIAS INTO DIRECTORY BLOKS
;	CALLU	DTCRR
;-

ENTERU	DTCRR
	REGSCR			;SAVE ALL REGISTERS
	MOVB	DTBUFB(R4),R0	;GET OFFSET FROM START OF BUFF.SYS
	ADD	R0,R2		;COMPUTE (SMALL) OFFSET INTO FILE
	MOV	#BFBASE,R0	;POINT TO BUFF.SYS BASE DATA
	MOVB	(R0)+,@#FIPUNT	;SET FIP UNIT NUMBER
	MOVB	(R0)+,R3	;BUFF.SYS MSB
	ADD	(R0),R2		;ADD IN LSB
	ADC	R3		; AND CARRY
	CALLRX	READ		;READ THE BLOCK

GLOBAL	<BFBASE,FIPUNT>

FQFEND

.SBTTL	DECTAPE RENAME

FQFSRT

	FJMPDV	DT,REN,ENTER

;+
; DECTAPE RENAME - ENTRY CONDITIONS
;
;	R1 -> DDB @ DDIDX (UNBIASED)
;	R4 -> FIRQB
;		FQNAM1 = FILE TO RENAME
;		FQNAM2 = NEW NAME
;		FQPROT = NEW PROTECTION
;
;	DEVICE AVAILABILITY HAS NOT BEEN CHECKED
;-

.ENABL	LSB

	TST	FQNAM1(R4)	;CHECK FOR A FILE NAME
	BNE	20$		; THERE WAS A NAME SUPPLIED, PROCESS IT
10$:	ERROR	BADNAM		;STOP HIM HERE

20$:	CALLU	DTGET		;SNAG THE TAPE, DISALLOWING NFS
	MOV	FQPROT-1(R1),FQFIL(R1) ;MOVE PROTECTION CODE TO SAFE PLACE
	TSTB	DTDDCT(R4)	;ANYTHING OPEN?
	BNE	30$		;IF SO, DIRECTORIES ARE ON DISK
	MOV	#30$,R5		;IF NOT, GET THEM THERE
	FJMP	DTRDIR
30$:	CALLU	DTSCH,R5,FQNAM1 ;SEARCH FOR THE OLD NAME
	BCC	40$		;GOT IT
	CALLU	DTRET		;NOT THERE. RETURN THE TAPE
	ERROR	NOSUCH

40$:	MOV	R2,-(SP)	;SAVE THE UFD BLOCK IN USE
	MOV	R5,R2		;COPY THE UFD ENTRY POINTER
	CMP	(R5)+,FQNAM2+0(R1) ;IS HE CHANGING THE NAME
	BNE	50$		; OR JUST THE PROTECTION CODE?
	CMP	(R5)+,FQNAM2+2(R1)
	BNE	50$
	CMP	(R5)+,FQNAM2+4(R1)
	BEQ	70$		;A SIMPLE PROTECTION CODE SHIFT

50$:	MOV	R2,-(SP)	;SAVE THE UFD ENTRY POINTER
	CALLU	DTSCH,R5,FQNAM2 ;DOES THE NEW NAME EXIST?
	BCS	60$		;NOT THERE, SO OK
	CALLU	DTRET		;RETURN THE TAPE
	ERROR	FIEXST		;IT'S ALREADY THERE

60$:	MOV	(SP)+,R5	;RESTORE THE UFD ENTRY POINTER
	MOV	(SP),R2		;GET UFD BLOCK NUMBER
	CALLU	DTCRR		;REREAD THE BLOCK WITH THE FILE ENTRY
	MOV	FQNAM2+0(R1),(R5)+ ;MOVE THE NEW NAME INTO PLACE
	MOV	FQNAM2+2(R1),(R5)+
	MOV	FQNAM2+4(R1),(R5)+
70$:	TSTB	FQFIL(R1)	;NEW PROTECTION?
	BEQ	80$		;NO
	MOVB	FQFIL+1(R1),DTUPRO-DTUDAT(R5) ;YES, SET IT
80$:	CALLX	WRITE		;ALTERED ON DISK
	MOV	(SP)+,R5	;GET THE UFD BLOCK ALTERED
	CALLU	DTSIO,R5,ALC.DT ;GET US A BIG BUFFER
	MOV	R5,R2		;REREREAD THE UFD BLOCK
	CALLU	DTCRR
	MOV	#FIBUF,R0	;COPY THE UFD BLOCK FROM FIBUF
	MOV	DTBUFF(R4),R2	; TO THE BIG BUFFER
	MOV	#256.,R3
90$:	MOV	(R0)+,(R2)+
	SOB	R3,90$
	ADD	#DT$UF0,R5	;COMPUTE BLOCK ON TAPE FOR UFD
	MOV	R5,DTBLOK(R4)	; AND SET IT IN THE DDB
	CALLU	DTSIO,R5,WRT.DT!CCE.DT ;WRITE OUT THE UFD
	CALLX	RETBIG,R5,512.	;RETURN THE BIG BUFFER
	;CALLRU	DTRET		;RETURN THE UNIT AND GO BYE BYE

ENTERU	DTRET
	MOV	R4,R1		;COPY THE DDB POINTER
	SUB	#DTDDSP,R1	;UNBIAS IT
	CALLRX	RETDEV

.DSABL	LSB

GLOBAL	<FIBUF>

.SBTTL	DECTAPE DIRECTORY

	FJMPDV	DT,DIR,ENTER

;+
; DECTAPE DIRECTORY - ENTRY CONDITIONS
;
;	R1 -> DDB @ DDIDX (UNBIASED)
;	R4 -> FIRQB
;		FQFIL = INDEX OF ENTRY TO GET
;
;	DEVICE IS AVAILABLE, BUT MIGHT NOT BE OWNED
;-

.ENABL	LSB

	CALLU	DTGET		;GET THE DECTAPE
	MOV	#10$,R5		;POINT TO RETURN ADDRESS
	MOVB	DTDDCT(R4),R0	;IF A FILE IS OPEN
	BIS	FQERNO(R1),R0	; OR HE IS NOT ASKING FOR FIRST ENTRY
	BNE	10$		;  THEN DON'T GET DIRECTORIES
	FJMP	DTRDIR		;GO GET THEM
10$:	CMP	(R1)+,(R1)+	;POINT TO THE INDEX VALUE
	MOV	#28.*400+28.,R5	;SET COUNT OF 28 ENTRIES IN EACH BLOCK
	CLR	R2		;BIAS INTO BUFF.SYS OF 3
.ASSUME	DTBUF0	EQ	0
20$:	CALLU	DTCRR		;READ A DIRECTORY BLOCK FROM DISK
	MOV	#FIBUF+2,R0	;POINT TO FIRST ENTRY IN THE BLOCK
30$:	TST	(R0)		;ANYTHING HERE?
	BEQ	40$		;NO, SO DON'T COUNT THIS ENTRY
	DEC	(R1)		;YES, IS THIS THE ONE HE WANTS?
	BMI	50$		;YUP, FILL HIS FIRQB
40$:	ADD	#DTU$SZ,R0	;POINT TO THE NEXT ENTRY
	DECB	R5		;COUNT DOWN
	BNE	30$		;MORE IN THIS BLOCK
	MOV	#DTBUF1,R2	;SECOND DIRECTORY BLOCK IS BIAS 2
	SWAB	R5		;GET COUNT AGAIN
	BNE	20$		;GO GET THE BLOCK AND CONTINUE
	CALLU	DTRET		;RETURN THE DECTAPE
	ERROR	NOSUCH		;CAN'T FIND FILE OR ACCOUNT

GLOBAL	<FIBUF>

50$:	MOV	#6,FQNENT-4(R1)	;SIX ENTRIES (TAPE), USTAT=0
	CMP	(R1)+,(R1)+	;POINT TO FQNAM1
	MOV	(R0)+,(R1)+	;10 COPY THE NAME.EXT
	MOV	(R0)+,(R1)+	;12
	MOV	(R0)+,(R1)+	;14
	MOV	DTULEN-DTUDAT(R0),(R1)+ ;16 FILE SIZE
	MOVB	DTUPRO-DTUDAT(R0),(R1)+ ;20 PROTECTION
	CLRB	(R1)+		;21 ZERO BYTE
	MOV	(R0),(R1)	;22 CREATION DATE
	BPL	60$		;NOT A CONTIGUOUS FILE
	MOVB	#US.NOX,FQNENT+1-22(R1) ;CONTIGUOUS, SET THE FLAG
60$:	BIC	#100000,(R1)+	; WITH A BIT TRIMMED
	MOV	(R0),(R1)	;24 SET THE MODE INDICATOR (HISTORICAL)
	MOV	R4,R1		;COPY THE DDB POINTER
	SUB	#DTDDSP,R1	;UNBIAS IT
	CALLRX	RETDEV

.DSABL	LSB

.SBTTL	UTILITIES FOR DTU4

; GRAB THE DECTAPE AND ENSURE NOT ALREADY NFS OPEN

ENTERU	DTGET
	CALLX	GETDEV		;GRAB THE TAPE
	TST	(R1)		;ALREADY NFS OPEN?
	BPL	10$		;NOPE
	ERROR	DEVNFS		;YES, SAY DEVICE IS NFS

10$:	BIS	#DDUTIL,DDCNT(R1) ;ASSIGN IT FOR UTILITY SEQUENCE
ENTERU	SETDT
	MOV	R1,R0		;SAVE THE UNBIASED POINTER
	ADD	#DTDDSP,R1	;BIAS THE POINTER
	MOV	R1,FQCLUS(R4)	;LINK FIRQB TO DDB
ENTERU	SETUP
	MOV	R4,R1		;USE R1 AS A FIRQB POINTER
	MOV	FQCLUS(R4),R4	;RESTORE THE DDB POINTER
	MOV	R1,DTFQCB(R4)	;ENSURE THAT THE DDB LINKS TO THE FIRQB
	RETURN

; DO DECTAPE I/O FOR FIP

;+
; DTSIO - DO DECTAPE I/O FOR FIP
;
;	R1 -> FIRQB
;	R4 -> DDB @ DTQPTR
;
;	CALLU	DTSIO,R5,<DT FUNCTION>
;
;	R0,R2,R3 RANDOM
;-

ENTERU	DTSIO
	MOV	(R5)+,DTCFUN(R4) ;LOAD THE FUNCTION INTO THE DDB
	MOV	#10$,FQADDR(R1)	;LOAD THE ADDRESS TO FJMP BACK TO
	MOV	DTFIPQ(R4),DTRPTR(R4) ;LOAD THE QUEUE & L3Q BITS
	CALLX	QUEL3Q		;QUEUE IT AND START THE PROCESS
	MOV	R5,-(R4)	;SAVE RETURN ADDRESS IN DTRIO
	MOV	(SP)+,FQSIZ(R1)	;SAVE CALLER'S R5 IN FQSIZ
	JMPX	FIEXIX		;EXIT WITHOUT FINISHING

10$:	MOV	FQSIZ(R4),R5	;RESTORE CALLER'S R5
	CALLU	SETUP		;SET UP THE REGISTERS
	JMP	@DTRIO(R4)	;RETURN TO CALLER

;+
; DTSCH - SEARCH THE TAPE DIRECTORY FOR A NAME
;
;	R1 -> FIRQB, WITH NAME.EXT AT KNOWN OFFSET
;	DIRECTORIES ON DISK
;
;	CALLU	DTSCH,R5,<OFFSET OF NAME IN FIRQB>
;
;	R0 =  DIRECTORY INDEX (0 TO 57.)
;	R2 =  BIAS OF UFD BLOCK INTO BUFF.SYS
;	R3 -> FILE NAME IN FIRQB
;	R5 -> UFD ENTRY IN FIBUF
;
;	C=0 IF FILE WAS FOUND
;	C=1 IF NO SUCH FILE IN DIRECTORY
;-

.ENABL	LSB

ENTERU	DTSCH
	MOV	R1,R3		;COPY THE FIRQB POINTER
10$:	ADD	(R5)+,R3	;ADD IN THE BIAS TO POINT TO THE NAME
	MOV	R5,(SP)		;SAVE RETURN ADDRESS
	MOV	#DTBUF0-1,-(SP)	;SET BUFF.SYS BIAS (BIASED)
	CLR	R0		;COUNTER = 0
20$:	INC	(SP)		;GET NEXT BUFF.SYS BIAS
	MOV	(SP),R2		;COPY TO R2 FOR READING FROM BUFF.SYS
	CALLU	DTCRR		;READ A UFD BLOCK FROM DISK
	MOV	#FIBUF+2,R5	;POINT TO THE DIRECTORY
30$:	MOV	R5,R2		;COPY THE DIRECTORY POINTER
	CMP	(R2)+,(R3)	;CHECK THE NAME
	BNE	40$
	CMP	(R2)+,2(R3)
	BNE	40$
	CMP	(R2)+,4(R3)
	BEQ	50$		;FOUND IT
40$:	ADD	#DTU$SZ,R5	;POINT TO NEXT ENTRY IN THIS BLOCK
	INC	R0		;BUMP FILE NUMBER
	CMP	R0,#28.		;END OF UFD0 BLOCK?
	BEQ	20$		;YES, GO TRY UFD1
	CMP	#56.-1,R0	;END OF UFD1 BLOCK?
	BHIS	30$		;NO, TRY AGAIN IN THIS BLOCK
	;SEC			;C=1 FROM CMP (BHIS = BCC)
50$:	MOV	(SP)+,R2	;RETURN BIAS INTO BUFF.SYS
	RETURN			;RETURN WITH C=1 FOR FAILURE

.DSABL	LSB

GLOBAL	<FIBUF>

;+
; READ A BLOCK FROM BUFF.SYS FOR DECTAPE UTILITY
;
;	R2 = BIAS INTO DIRECTORY BLOKS
;	CALLU	DTCRR
;-

ENTERU	DTCRR
	REGSCR			;SAVE ALL REGISTERS
	MOVB	DTBUFB(R4),R0	;GET OFFSET FROM START OF BUFF.SYS
	ADD	R0,R2		;COMPUTE (SMALL) OFFSET INTO FILE
	MOV	#BFBASE,R0	;POINT TO BUFF.SYS BASE DATA
	MOVB	(R0)+,@#FIPUNT	;SET FIP UNIT NUMBER
	MOVB	(R0)+,R3	;BUFF.SYS MSB
	ADD	(R0),R2		;ADD IN LSB
	ADC	R3		; AND CARRY
	CALLRX	READ		;READ THE BLOCK

GLOBAL	<BFBASE,FIPUNT>

FQFEND

.SBTTL	DECTAPE ZERO

FQFSRT

	FJMPDV	DT,ZER,ENTER	;DECTAPE ZERO

;+
; DECTAPE ZERO - ENTRY CONDITIONS
;
;	R1 -> DDB FOR DECTAPE UNIT
;	R4 -> FIRQB
;
;	DEVICE IS AVAILABLE, BUT MIGHT NOT BE OWNED
;-

.ENABL	LSB

	TSTB	DDCNT(R1)	;IS THERE ANYTHING OPEN?
	BEQ	10$		;NO, WE CAN ZERO IT
	ERROR	DTOOOF		;TOO MANY OPEN FILES TO ZERO IT

10$:	CALLX	GETDEV		;SNAG THE TAPE
	BIS	#DDUTIL,DDCNT(R1) ;ASSIGN IT FOR UTILITY SEQUENCE
	ADD	#DTDDSP,R1	;NOW BIAS THE DDB POINTER
	MOV	R1,FQCLUS(R4)	;LINK THE FIRQB TO THE DDB
	CALLU	SETUP		;SHIFT REGISTERS
	CALLU	DTSIO,R5,ALC.DT ;CALL THE DRIVER TO GET A BIG BUFFER
	MOVPIC	#ZERLST,R5	;POINT (PIC) TO THE ZEROING LIST
20$:	MOV	DTBUFF(R4),R0	;POINT TO THE BUFFER
	ADD	#1000,R0	; AT THE END
	MOV	R0,R3		;COPY THE END POINTER
	MOV	#256.,R2	;ONE BLOCK TO CLEAR
30$:	CLR	-(R0)		;CLEAR OUT THE BUFFER
	SOB	R2,30$
	MOV	(R5)+,DTBLOK(R4) ;SET THE BLOCK TO WRITE
	MOV	(R5)+,R2	;GET COUNT OF THINGS
	BEQ	80$		;NOTHING, WRITE A ZERO BLOCK
40$:	MOV	(R5)+,(R0)+	;FILL UP THE BUFFER WITH DATA
	SOB	R2,40$
	CMP	DTBLOK(R4),#DT$PBM ;IS THIS THE PERMANENT BIT MAP?
	BNE	60$		;NO, GO WRITE IT
	INC	(R0)		;YES. MARK FIRST BLOCK IN USE FOR BOOT
	COMB	7(R0)		;BLOCKS 70-77 ARE IN USE FOR BIT MAPS
	MOVB	#37,10(R0)	;BLOCKS 100-104 ARE THE DIRECTORIES
	ADD	#36.*2,R0	;POINT PAST THE ACTUAL BIT MAP
	MOV	#256.-<36.+4.>,R2 ;COUNT OF WORDS TO MAKE -1
50$:	COM	(R0)+		;SET THE REST OF THE BLOCK TO -1
	SOB	R2,50$		; FOR CLEANLINESS
60$:	TST	DTBLOK(R4)	 ;CHECK THE BLOCK TO WRITE
	BPL	80$		;FORWARDS IS EASY
	MOV	DTBUFF(R4),R0	;TURN THE BUFFER AROUND IN MEMORY
70$:	MOV	(R0),R2		;SAVE A LOW WORD
	MOV	-(R3),(R0)+	; MOVE DOW A HIGH WORD
	MOV	R2,(R3)		;  AND REPLACE IT WITH THE LOW
	CMP	R0,R3		;IF THE POINTERS HAVEN'T MET,
	BLO	70$		; THEN WE MUST DO MORE
80$:	MOV	(R5)+,DTSOPT(R4) ;START IN A GOOD DIRECTION
	CALLU	DTSIO,R5,WRT.DT!CCE.DT ;WRITE OUT THE BLOCK
	TST	(R5)		;ANYTHING ELSE?
	BNE	20$		;GO DO ANOTHER
	CALLX	RETBIG,R5,512.	;GIVE BACK THE BIG BUFFER
	;CALLRU	DTRET		;RETURN THE TAPE, EXIT FROM FIP

.DSABL	LSB

ENTERU	DTRET
	MOV	R4,R1		;COPY THE DDB POINTER
	SUB	#DTDDSP,R1	;UNBIAS IT
	CALLRX	RETDEV

ZERLST:	.WORD	DT$BM0+0,0,0	;BIT MAP 0, ZEROS, FORWARD SEARCH
	.WORD	DT$BM0+4,0,0	;BIT MAP 4, ZEROS, FWD
	.WORD	DT$MF0,4,DT$MF1,4,DT$PBM,DT$PBM,0 ;MFD0
	.WORD	DT$PBM,4,0,1,36.,DT$PBM,0 ;PBM
	.WORD	-DT$UF1,0,0	;UFD1
	.WORD	-<DT$BM0+7>,0,0	;BIT MAP 7
	.WORD	-<DT$BM0+3>,0,0	;BIT MAP 3
	.WORD	DT$BM0+1,0,REV.DT ;BIT MAP 1 (START SEARCHING REVERSE)
	.WORD	DT$BM0+5,0,0	;BIT MAP 5
	.WORD	DT$MF1,4,0,1*400+1,DT$UF0,9.,0 ;MFD1
	.WORD	-DT$UF0,1,DT$UF1,REV.DT ;UFD0
	.WORD	-<DT$BM0+6>,0,0	;BIT MAP 6
	.WORD	-<DT$BM0+2>,0,0	;BIT MAP 2
	.WORD	0		;END OF LIST

;+
; DTRDIR - READ DIRECTORIES FROM TAPE TO DISK
;
;	R1 -> FIRQB
;	R4 -> DDB @ DTQPTR
;	R5 =  FJMP RETURN ADDRESS
;
;	FJMP	DTRDIR
;
;	R0,R2,R3,R5 RANDOM
;-

DTRDIR:	CALL	10$,R5,<DT$UF1,-DT$UF0,DT$PBM,0> ;POINT TO LIST

10$:	MOV	(SP)+,FQPROT-1(R1) ;SAVE CALLER'S R5
20$:	MOV	(R5),DTBLOK(R4)	;GET THE NEXT TAPE BLOCK TO DO
	CALLU	DTSIO,R5,RED.DT!CCE.DT ;READ THE BLOCK
	MOV	(R5)+,R2	;GET THE BLOCK NUMBER AGAIN
	BPL	40$		;POSITIVE, SO DON'T REVERSE
	MOV	DTBUFF(R4),R3	;POINT TO THE BUFFER
	MOV	R3,R0		;COPY IT
	ADD	#1000,R0	; AND POINT TO THE END
30$:	MOV	(R3),-(SP)	;SAVE A LOW WORD
	MOV	-(R0),(R3)+	;COPY WORD DOWN
	MOV	(SP)+,(R0)	;REPLACE THE LOW WORD UP HIGH
	CMP	R3,R0		;IF THE POINTERS HAVEN'T MET,
	BLO	30$		; THEN WE MUST DO MORE
	NEG	R2		;NEGATE R2 TO MAKE IT POSITIVE
40$:	SUB	#DT$UF0,R2	;UNBIASED TO GET BUFF.SYS OFFSET
	MOVB	DTBUFB(R4),R0	;GET THE BIAS INTO BUFF.SYS
	ADD	R0,R2		;ADD THE LOCATION OF THIS BLOCK
	MOV	#BFBASE,R0	;POINT TO DATA ON BUFF.SYS
	MOVB	(R0)+,@#FIPAR+DSQUNT ;SET THE UNIT NUMBER
	MOVB	(R0)+,R3	;DISK BLOCK MSB
	ADD	(R0),R2		;ADD IN THE LSB
	ADC	R3		; AND CARRY
	MOV	R4,-(SP)	;SAVE R4
	MOV	DTBUFF(R4),R4	;GET THE BUFFER ADDRESS
	CALLX	PARSEX,R5,<WFUN,0> ;WRITE FROM BUFFER @ R4
	MOV	(SP)+,R4	;RESTORE DDB POINTER
	CALLX	RETBIG,R5,512.	;RETURN THE BUFFER FOR OTHER GUYS
	TST	(R5)		;DONE?
	BNE	20$		;NO, DO MORE
	MOV	FQPROT-1(R1),R5	;RESTORE CALLER'S ADDRESS
	FJMP	(R5)		;GO BACK TO HIM

GLOBAL	<BFBASE,FIPAR>

.SBTTL	UTILITIES FOR DTU5

; HANDLE REGISTER SHIFTS FOR DECTAPE ENTRY

ENTERU	SETDT
	MOV	R1,R0		;SAVE THE UNBIASED POINTER
	ADD	#DTDDSP,R1	;BIAS THE POINTER
	MOV	R1,FQCLUS(R4)	;LINK FIRQB TO DDB
ENTERU	SETUP
	MOV	R4,R1		;USE R1 AS A FIRQB POINTER
	MOV	FQCLUS(R4),R4	;RESTORE THE DDB POINTER
	MOV	R1,DTFQCB(R4)	;ENSURE THAT THE DDB LINKS TO THE FIRQB
	RETURN

; DO DECTAPE I/O FOR FIP

;+
; DTSIO - DO DECTAPE I/O FOR FIP
;
;	R1 -> FIRQB
;	R4 -> DDB @ DTQPTR
;
;	CALLU	DTSIO,R5,<DT FUNCTION>
;
;	R0,R2,R3 RANDOM
;-

ENTERU	DTSIO
	TST	(PC)+		;CLEAR THE CARRY, SKIP THE 'SEC'
ENTERU	DTCIO			;SPECIAL I/O CALL FOR CLOSE
	SEC			;C=1 TO FORCE ODD ADDRESS IN DTRIO
	MOV	(R5)+,DTCFUN(R4) ;LOAD THE FUNCTION INTO THE DDB
	ADC	R5		;SET R5 ODD IF CLOSING A FILE
	MOV	#20$,FQADDR(R1)	;LOAD THE ADDRESS TO FJMP BACK TO
	MOV	DTFIPQ(R4),DTRPTR(R4) ;LOAD THE QUEUE & L3Q BITS
	CALLX	QUEL3Q		;QUEUE IT AND START THE PROCESS
	MOV	R5,-(R4)	;SAVE RETURN ADDRESS IN DTRIO
	MOV	(SP)+,FQSIZ(R1)	;SAVE CALLER'S R5 IN FQSIZ
	JMPX	FIEXIX		;EXIT WITHOUT FINISHING

20$:	MOV	FQSIZ(R4),R5	;RESTORE CALLER'S R5
	CALLU	SETUP		;SET UP THE REGISTERS
	BIC	#1,DTRIO(R4)	;EVEN OUT THE RETURN ADDRESS
	JMP	@DTRIO(R4)	;RETURN TO CALLER

FQFEND

.END

