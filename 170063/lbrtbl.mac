	.TITLE	LBRTBL
	.IDENT	/03/

;
; COPYRIGHT 1975, DIGITAL EQUIPMENT CORP., MAYNARD, MASS.  01754
; COPYRIGHT 1974, DIGITAL EQUIPMENT CORP., MAYNARD, MASS.  01754
; COPYRIGHT 1973, DIGITAL EQUIPMENT CORP., MAYNARD, MASS.  01754
;
;	DEC ASSUMES NO RESPONSIBLIITY FOR THE USE
;	OR RELIABILITY OF ITS SOFTWARE ON EQUIPMENT
;	WHICH IS NOT SUPPLIED BY DEC.
;
; THIS SOFTWARE IS FURNISHED TO PURCHASER UNDER A LICENSE FOR USE
; ON A SINGLE COMPUTER SYSTEM AND CAN BE COPIED (WITH INCLUSION
; OF DEC'S COPYRIGHT NOTICE) ONLY FOR USE IN SUCH SYSTEM, EXCEPT
; AS MAY OTHERWISE BE PROVIDED IN WRITING BY DEC.
;
; THE INFORMATION IN THIS DOCUMENT IS SUBJECT TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT BY DIGITAL
; EQUIPMENT CORPORATION.
;
; VERSION 03
;
; WRITTEN BY:
;	GEORGE W. BERRY
;
; MODIFIED BY:
;	C.A. D'ELIA	10-JUN-74
;	C.A. D'ELIA	25-JUN-74  (VIRTUAL TABLES)
;	THOMAS J. MILLER 14-NOV-74
;
;

;
; MACRO CALLS
;
 
	.MCALL	IOERR$
	IOERR$
	.MCALL	FDOFF$
	FDOFF$	DEF$L
	.MCALL	FCSBT$
	FCSBT$	DEF$L

 
	.IF NDF	S$$LIB
 
 
	.MCALL	GET$
 
	.IFF
 
	.MCALL	GET$S
 
 
	.ENDC
 

;
; LOCAL DATA
;
 
LASTV:	.BLKW	1		;FIRST HALF OF LAST SYMBOL INSERTED
ELESIZ:	.BLKW	1		;SIZE OF VIRTUAL MEMORY NEEDED FOR ELEMENT
 
;+
; **-$RDEP-READ EPT
;
; THIS ROUTINE READS THE EPT.
;
; INPUTS:
;
;	L$BUF CONTAINS THE LIBRARY HEADER RECORD
;
; OUTPUTS:
;
;	$EPBLK (EPT BLOCK DESCRIPTOR) IS SET UP
;
;-
$RDEP::	SAVRG			;SAVE R3-R5
	MOV	#$EPBLK,R5
	MOV	#$EPTHL,R1	;POINT R1 TO EPT LIST HEADS
	MOVB	L$ES,R3		;PUT SIZE OF EPT ENTRY IN R3
	MOV	L$ET,R2		;PUT VBN OF START OF EPT IN R2
	MOV	#L$EI,R4	;PUT ADDR OF EPT'S ALLOCATED IN R4
	BR	RDR		;GO TO COMMON CODE
;+
;
; **-$RDMN=READ MNT
;
; THIS ROUTINE READS THE MNT.
;
; INPUTS:
;
;	L$BUF CONTAINS THE LIBRARY HEADER RECORD
;
; OUTPUTS:
;
;	$MNBLK (MNT BLOCK DESCRIPTOR) IS SET UP.
;
;-
$RDMN::	SAVRG
	MOV	#$MNBLK,R5
	MOV	#$MNTHL,R1	;POINT R1 TO MNT LIST HEADS
	MOVB	L$MS,R3		;PUT SIZE OF MNT ENTRY IN R3
	MOV	L$MT,R2		;PUT VBN OF START OF MNT IN R2
	MOV	#L$MI,R4	;PUT ADDR OF MNT'S ALLOCATED IN R4
 
RDR:	MOV	$LBRPT,R0	;POINT R0 TO LIBRARY FDB, ETC
	MOVB	#R.FIX,F.RTYP(R0)  ;INDICATE READ FIXED LENGTH RECORDS
	MOV	R3,F.RSIZ(R0)	;SET THE DESIRED RECORD LENGTH
	MOV	R3,(R5)+	;STORE TABLE ENTRY SIZE
	MOV	R1,(R5)+	;AND ADDRESS OF LIST HEADS
	MOV	(R4),(R5)	;AND NUMBER OF ENTRIES ALLOCATED
	MOV	R1,$HDLST	;SET ADDR OF CURRENT LIST HEADS
	ADD	#2,R3		;CALC SIZE OF REQ'D VIRTUAL MEMORY BLKS
	MOV	R3,ELESIZ	;AND STORE IT
	CALL	SETUP		;POSITION FILE
	MOV	(R4)+,R1	;GET NUMBER OF ENTRIES ALLOCATED
	SUB	(R4),R1		;AND, SUBTRACT ENTRIES AVAILABLE
	BLE	RTN		;LEAVE IF NONE HAVE BEEN USED
	MOV	R1,-(SP)	;ELSE, SAVE ENTRIES USED ON STACK
	CLR	LASTV		;INITIALIZE LAST VALUE INSERTED
	CLR	R3		;INITIAL PARTITION LIST OFFSET IS ZERO
	MOV	$HDLST,R4	;POINT R4 TO FIRST LIST HEAD INITIALLY
	CLR	R5		;AND ASSIGN VIRTUAL ZERO TO IT
RDELE: 
 
	.IF NDF	S$$LIB
 
 
	GET$	$LBRPT,#$OUTBF+4 ;GET TABLE ELEMENT
 
	.IFF
 
	GET$S	$LBRPT,#$OUTBF+4 ;GET TABLE ELEMENT
 
 
	.ENDC
 
 
	BCS	ERROR		;BRANCH IF READ ERROR OCCURRED
	MOV	F.NRBD+2(R0),R2	;GET ADDR OF ELEMENT
	MOV	R2,-(SP)	;AND SAVE IT
	CMP	(R2),LASTV	;COMPARE ELE TO LAST ELEMENT
	BLO	LIBERR		;OUT OF ORDER, ERROR
	MOV	(R2),LASTV	;ELSE, RESET LAST ELEMENT READ
10$:	CMP	(R2),$PARTD(R3)	;COMPARE ELE WITH PARTITION DESCRIPTOR
	BLOS	INSERT		;BRANCH IF THIS IS CORRECT PARTITION
	CALL	UNLOCK		;UNLOCK OLD PARTITION (IF NECESSARY)
	ADD	#2,R3		;UPDATE PARTITION LIST OFFSET
	CMP	R3,#<NU$PAR*2>-2  ;COMPARE IT WITH MAXIMUM OFFSET
	BGT	LIBERR		;IF GREATER, THEN ERROR
	MOV	$HDLST,R4	;NEW LINK WORD IS NEXT...
	ADD	R3,R4		;...PARTITION LIST HEAD
	CLR	R5		;IT'S VIRTUAL LOCATION IS ZERO
	BR	10$		;REPEAT TEST FOR THIS PARTITION
INSERT:	MOV	ELESIZ,R1	;SET SIZE OF MEMORY REQUIRED
	CALL	$ALVRT		;ALLOCATE THE VIRTUAL MEMORY
	CALL	$LCKPG		;LOCK PAGE CONTAINING NEW LOCN
	CALL	$NWLNK		;UNLOCK OLD LINK AND INSERT ELEMENT
	MOV	(SP)+,R0	;POINT R0 TO NEW ELEMENT
	MOV	R4,R1		;POINT R1 TO VIRTUAL MEMORY BLOCK
	TST	(R1)+		;BUMP R1 PAST THE LINK WORD
	MOV	ELESIZ,R2	;GET SIZE OF VIRTUAL ALLOCATION
	ASR	R2		;CONVERT IT TO WORDS
	DEC	R2		;SUBTRACT OUT THE LINK WORD
20$:	MOV	(R0)+,(R1)+	;COPY ELEMENT INTO VIRTUAL STORAGE
	DEC	R2		;
	BNE	20$		;
	DEC	(SP)		;DECREMENT ELEMENT COUNT
	BGT	RDELE		;IF SOME REMAIN, REPEAT PROCESS
	TST	(SP)+		;CLEAN THE STACK
UNLOCK:	MOV	R5,R1		;PUT VIRTUAL LOCN OF LINK IN R1
	BEQ	RTN		;IF NULL, DON'T TRY TO UNLOCK IT
	CALL	$UNLPG		;UNLOCK VIRTUAL PAGE CONTAINING OLD LINK
RTN:	RETURN
 
;
; GENERAL ERROR EXIT
;
LIBERR:	MOV	(PC)+,R1	;ERROR -- BAD LIBRARY
	.BYTE	E$R29,S$V2
	BR	ERRNM
 
PERR:	MOV	(PC)+,R1	;ERROR IN POSITIONING FILE
	.BYTE	E$R14,S$V2	;WITH .POINT
	BR	ERRNM

ERROR:	MOV	(PC)+,R1	;CAN'T READ LIBRARY FILE
	.BYTE	E$R01,S$V2
ERRNM:	MOV	R$NAME(R0),R2	;GIVE FILE NAME
ERXIT:	JMP	$ERMSG		;FATAL ERROR EXIT

;+
;
; SETUP FOR EPT OR MNT READ
;
; THIS ROUTINE POSITIONS THE FILE AT THE DESIRED TABLE BLOCK.
;
; INPUTS:
;
;	R0 = $LBRPT
;	R2 = STARTING BLOCK OF TABLE
;
; OUTPUTS:
;
;	R0 IS UNCHANGED
;	R1 AND R3 ARE LOST
;
;-

SETUP:	CLR	R1		;CLEAR HIGH VBN
	CLR	R3		;CLEAR BYTE ADDRESS
	CALL	.POINT		;POSITION FILE
	BCC	10$		;BRANCH TO LEAVE ON SUCCESS
	CMPB	#IE.EOF,F.ERR(R0) ;IGNORE EOF ERRORS
	BNE	PERR		;BRANCH IF NOT EOF ERROR
10$:	RETURN



	.END
