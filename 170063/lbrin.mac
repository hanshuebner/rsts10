	.TITLE	LBRIN
	.IDENT	/7.02/
;
;		COPYRIGHT (C) 1985,1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD
;	 MASSACHUSETTS.  ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE  IS  FURNISHED  UNDER  A LICENSE AND MAY BE USED
; AND  COPIED  ONLY IN  ACCORDANCE WITH THE TERMS OF SUCH LICENSE
; AND WITH  THE INCLUSION  OF THE ABOVE  COPYRIGHT  NOTICE.  THIS
; SOFTWARE  OR ANY OTHER  COPIES  THEREOF, MAY NOT BE PROVIDED OR
; OTHERWISE MADE  AVAILABLE TO ANY OTHER PERSON.  NO TITLE TO AND
; OWNERSHIP OF THE SOFTWARE IS HEREBY TRANSFERED.
;
; THE INFORMATION  IN THIS DOCUMENT IS SUBJECT  TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT  BY  DIGITAL
; EQUIPMENT CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF
; ITS SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.
;
;
; ALL RIGHTS RESERVED
;
;
; WRITTEN BY:
;	GEORGE W. BERRY
;
; PREVIOUSLY MODIFIED BY:
;
;	C. A. D'ELIA
;	T. J. MILLER
;	B.    ALIMONTI
;	D. R. DONCHIN
;	M. JOHNSON
;	J. GALLANT
;	C. ZIEGELMILLER
;
; MODIFIED BY:
;
;	P. J. KOBAR	2-FEB-84	7.01
;		PJK123 -- CORRECT PROBLEM WITH MODULES HAVING BLANK IDENTS
;			IN CONCATENATED OBJECT FILES (SPR 62919)
;
;
; MODIFIED FOR RSTS V10.1 BY:
;
;	S. LEVAN	9-MAY-91	7.02
;		MERGE RSTS-SPECIFIC CODE INTO RSX V4.3 VERSION OF THIS MODULE.
;

;
; MACRO CALLS
;

	.MCALL	IOERR$
	IOERR$
	.MCALL	FDOFF$
	FDOFF$	DEF$L
	.MCALL	CSI$
	CSI$
	.MCALL	FCSBT$
	FCSBT$

	.MCALL	CLOSE$,GTIM$S,PUT$
	.MCALL	READ$,WAIT$,FDBK$R


	.IF NDF	S$$LIB


	.MCALL	GET$,OPEN$R

	.IFF

	.MCALL	GET$S


	.ENDC


;
; LOCAL DATA
;

 
TAB	=11			;ASCII FOR TAB
SPACE	=40			;ASCII FOR SPACE
COMMA	=54			;ASCII FOR COMMA
SEMI	=73			;ASCII FOR SEMI-COLON
 
 
STBLK:	.BLKW	5		;INPUT FILE STATISTIC BLOCK
ENDSPC:	.WORD	0		;END OF INPUT FILE SPEC.
ARGBLK:	.WORD	0		;ARGUEMENT BLK FOR INVALID RAD50 CHAR ERROR MSG
MHSZ:	.BLKW	1		;ACTUAL MODULE HEADER SIZE
DATE:	.BLKW	8.		;DATE + TIME VALUE FROM
XXX:	.BLKW	3
ID	=XXX			;MODULE .IDENT
ENDFLG	=XXX+4			;END FLG
MDEPTH:	.BLKW	1		;MACRO DEFINITION DEPTH COUNTER
MACNAM:	.BLKW	3		;MACRO NAME BUFFER
	.WORD	0		;NON-RAD50 CHARACTER STOPPER
				;   0=READING MODULE
				;   1=EOF EXPECTED

	.PSECT	PUTCOM,D

RPBLK:	.BLKW	4		;MODULE REPLACE INFO BLOCK -- CLEARED
				;... INITIALLY & FILLED IN AS FOLLOWS:
RPMNT==RPBLK			;  RPMNT-NAME OF MNT REPLACED
RPMHD==RPBLK+4			;  RPMHD-ADDR (VBN) OF MODULE REPLACED


LASTEP::.BLKW	2		;LAST EPT ENTRY REPLACED ...
				;... IN CASE OF REPLACE ERROR

	.PSECT

;
; REPLACE MESSAGE
;

	.NLIST	BEX
	.ENABL	LC
RPM:	.ASCIZ	<15><12>/Module "%2R" replaced/<15><12>
;
; KEY WORD STRINGS
;
MACSTR:	.ASCIZ	/MACRO/
REPSTR:	.ASCIZ	/REPT/
IRCSTR:	.ASCIZ	/IRPC/
IRSTR:	.ASCIZ	/IRP/
ENMSTR:	.ASCIZ	/ENDM/
ENRSTR:	.ASCIZ	/ENDR/
	.EVEN
	.LIST	BEX




;+
; **-$INS-INSERT FUNCTION
;
; THIS ROUTINE PERFORMS AN INSERT OF SPECIFIED
; INPUT MODULES (WHERE THE SPECIFICATION IS
; TAKEN FROM THE COMMAND INPUT DEVICE) INTO THE
; LIBRARY.  THE MNT AND EPT ARE UPDATED.
;
; INPUTS:
;
;	NONE
;
; OUTPUTS:
;
;	NONE
;
;-
$INS::	SAVRG			;SAVE R3-R5
	MOV	$INPPT,R0	;POINT TO INPUT FDB
	MOV	#FD.PLC,F.RACC(R0) ;SET TO PARTIAL LOCATE MODE
IN10:	JSR	R5,$CLEAR	;CLEAR TEMP AREA
	.WORD	XXX
	.WORD	4


	CMPB	#2,L$TYP		; UNI MODULE TYPE ?
	BNE	3$			; NO
	JSR	R5,$CLEAR		; CLEAR BUFFER WHERE MODULE NAMES ARE
					; STORED FOR INPUT FILES
	.WORD	$INBLK			; STARTING ADDRESS
	.WORD	30.			; LENGTH (FIVE FIELDS,EACH 6 CHAR)
3$:
	.IF NDF	Q$$CMO


	MOV	$CMOPT,R0	;OUTPUT ON CMO DEVICE (LUN-2)

	.IFF

	CLR	R0		;OUTPUT TO CMO VIA QUEUE I/O


	.ENDC


	CALL	$OUT		;INIT MESSAGE OUTPUT ROUTINE
	MOV	$INPPT,R0	;GET INPUT FILE CONTROL BLOCK ADDRESS
	MOV	$SWTCH,R$SWTH(R0) ;SET UP /RP BIT
	MOV	#$CSIBK,R1	;GET CSI BLOCK ADDRESS
	CALL	$SCANI		;SCAN FOR AN INPUT FILE
	BCC	5$		;BRANCH IF FILE SPEC ENCOUNTERED

	CLR	$OPNFL		;INDICATE LIBRARY IS ONLY OPEN FILE
	CALLR	$WTHD		;REWRITE MODIFIED HEADER
				;AND RETURN THROUGH  $WTHD***

5$:	MOV	#FO.UPD,R1	;SPECIFY OPEN FOR UPDATE
	CALL	$RDHD		;READ HEADER, EPT AND MNT
	MOVB	L$TYP,R1	;GET FILE TYPE
	ASL	R1		;CONVERT IT TO A TABLE OFFSET
	ASL	R1
	CMPB	#2,L$TYP	;UNI MODULE TYPE?
	BNE	10$		;IF NE, NO, DON'T PROCESS UNI DEFAULT FILETYPE
	MOV	L$UEX,INPNAM+N.FTYP ;MOVE UNI DEFAULT FILETYPE TO NMBLK
	BR	20$		;BRANCH TO CONTINUE
10$:	MOV	$INSUB+2(R1),INPNAM+N.FTYP ;MOV DEFAULT FILETYPE TO NMBLK
20$:	MOV	$INPPT,R0	;POINT R0 TO ADDR OF INPUT FDB ADDR
	CALL	@$INSUB(R1)	;INIT INSERT TYPE-DEPENDENT CO-ROUTINE
	MOV	R0,$OPNFL	;INDICATE OPEN FILE ON 'INPPT'


	.IF NDF	S$$LIB


	OPEN$R	R0

	.IFF

	MOV	#FO.RD,R1	;SPECIFY OPEN FOR READ
	CALL	$OPEN		;PARSE FILENAME AND OPEN FILE


	.ENDC


	BCC	IN20		;BRANCH IF OK
	CMPB	#IE.PRI,F.ERR(R0)	; IS THE ERROR A PRIVILEGE VIOLATION?
	BNE	22$			; IF NOT, JUMP
	MOV	(PC)+,R1
	.BYTE	E$R77,S$V2		; PRIVILEGE VIOLATION
	BR	ERROR
22$:	MOV	(PC)+,R1
	.BYTE	E$R11,S$V2		; CAN'T OPEN FILE
ERROR:	MOV	R$NAME(R0),R2
ERRXIT:	JMP	$ERMSG		;FATAL ERROR EXIT.


IN20:	MOV	#RPBLK,R1	;CLEAR REPLACE BLOCK
	CLR	(R1)+		;
	CLR	(R1)+
	CLR	(R1)+
	CLR	(R1)
	BIT	#RP$SW,R$SWTH(R0) ;/RP INDICATED
	BEQ	1$		;BRANCH IF NOT
	INC	-(R1)		;PERMIT /RP
1$:	MOV	$LBRPT,R0	;GET LIBRARY FDB
	MOVB	#R.VAR,F.RTYP(R0) ;CHANGE LBR TO VARIABLE LENGTH RECORDS
	CLR	R1		;HIGH ORDER VIRTUAL BLOCK
	MOV	L$NX,R2		;LOW ORDER VIRTUAL BLOCK
	MOV	L$NX+2,R3	;BYTE WITHIN BLOCK
	CALL	.POINT		;CALL THE .POINT SUBROUTINE
	BCC	25$		;BRANCH IF OK
	CMPB	#IE.EOF,F.ERR(R0) ;IGNORE EOF ERROR IF IT OCCURS
	BEQ	25$		;BRANCH IF EOF ERROR

24$:	MOV	(PC)+,R1	;INDICATE POSITIONING ERROR
	.BYTE	E$R14,S$V2
	BR	ERROR

25$:	JSR	R5,$CLEAR	;ZERO MODULE HEADER RECORD
	.WORD	$MHBUF
	.WORD	6
	PUT$	R0,#$MHST,MHSZ	;WRITE MODULE HEADER RECORD
	BCC	27$		;IF CC, NO ERROR, CONTINUE
	JMP	40$		;REPORT ERROR
27$:	CMPB	#2,L$TYP	;UNIVERSAL MODULE TYPE?
	BNE	30$		;IF NE, NO NEED TO ADJUST LIB TO NEXT BLK BOUND.
	MOVB	#R.FIX,F.RTYP(R0) ;CHANGE LIBRARY TO FIX LENGTH RECORDS
	CALL	.MARK		;GET CURRENT POSITION OF INPUT FILE
	CLR	R1		;ZERO OUT HIGH BITS OF VBN
	INC	R2		;INDICATE NEXT BLOCK
	CLR	R3		;ZERO BYTE IN BLOCK
	CALL	.POINT		;POSITION FILE TO BEGINNING OF NEXT BLOCK
	BCC	30$		;IF CC, NO ERRORS, SO CONTINUE
	CMPB	#IE.EOF,F.ERR(R0) ;IS ERROR EOF?
	BNE	24$		;IF NE, NO, SO REPORT POSITIONING ERROR
30$:	MOV	$INPPT,R0	;PUT ADDR OF INPUT FDB IN R0
	TST	ENDFLG		;TEST FOR OMITTING GET
	BGT	35$		;BRANCH...FIRST RECORD ALREADY READ
 
; FOR A UNIV. MOD, READ$ (BLOCK I/O) IS USED TO READ 512. BYTES FROM THE INPUT
; FILE.  PUT$ (REC. I/O) WITH (F.RSIZ = 512.) IS USED TO WRITE THESE BYTES TO  
; THE LIB. FILE (DONE TO ALLOW THE LIBRARY TO HANDLE UNIVERSAL MODULES FROM RMS
; FILES.).
 
	CMPB	#2,L$TYP	;UNIVERSAL MODULE TYPE?
	BNE	310$		;IF NE, NO, SO DO RECORD I/O
	CLR	F.NRBD+2(R0)	;CLEAR INPUT RECORD...
	CLR	F.NRBD(R0)	;...DESCRIPTOR
	READ$	R0		;READ 512. BYTES FROM INPUT FILE
	BCS	305$		;IF CS, READ ERROR
	WAIT$	R0		;WAIT TO I/O FINISHES BEFORE GOING ON
	BCC	35$		;IF CC, NO ERROR SO CONTINUE
305$:	CMPB	#IE.EOF,F.ERR(R0) ;IS ERROR EOF?
	BNE	31$		;IF NE, NO, SO BRANCH TO REPORT READ ERROR
	MOV	$LBRPT,R0	;COPY ADDRESS OF LIBRARY FDB INTO R0
	BR	46$		;AND CONTINUE
 
310$:


	.IF NDF	S$$LIB


	GET$	R0		;GET INPUT RECORD

	.IFF

	GET$S	R0		;GET INPUT RECORD


	.ENDC


	BCC	35$
	CMPB	#IE.EOF,F.ERR(R0) ;EOF ENCOUNTERED
	BNE	31$		;IF NE, NO, SO OTHER ERROR
	MOV	(PC)+,R1	;INVALID MODULE FORMAT
	.BYTE	E$R39,S$V2
	BR	ERROR		;FATAL EXIT
31$:	MOV	(PC)+,R1	;FATAL READ ERROR
	.BYTE	E$R01,S$V2
	BR	ERROR		;FATAL EXIT

35$:	CALL	@(SP)+		;SCAN RECORD JUST READ
	MOV	$INPPT,R1
	MOV	$LBRPT,R0
	CMPB	#2,L$TYP	;UNIVERSAL MODULE TYPE?
	BNE	37$		;IF NE, NO, SO CONTINUE AS USUAL
	MOV	F.BKDS+2(R1),F.NRBD+2(R1) ;COPY INPUT RECORD ADDRESS...
	MOV	F.BKDS(R1),F.NRBD(R1) ;...AND RECORD SIZE
37$:	TST	F.NRBD(R1)	;NULL RECORD?...(NEVER FOR UNIVERSAL MODULE)
	BEQ	30$		;SKIP PUT IF SO
	PUT$	R0,F.NRBD+2(R1),F.NRBD(R1) ;WRITE OUT RECORD
	BCC	45$
40$:	MOV	(PC)+,R1	;WRITE ERROR
	.BYTE	E$R02,S$V2
	JMP	ERROR


45$:	TST	ENDFLG		;CHECK END FLAG
	BLE	30$		;IF NOT SET, CONTINUE READING MODULE
46$:	MOV	#$MHST,R4	;BUILD MODULE HEADER RECORD
	CLR	(R4)+		;CLEAR MODULE STATUS
	BIT	#SS$SW,R$SWTH+INPPT  ;WAS /SS SWITCH SPECIFIED?
	BEQ	50$		;BRANCH IF NOT
	BISB	#SS$,-1(R4)	;YES--SET SELECTIVE SEARCH ATTRIBUTE
50$:	CMPB	#2,L$TYP	;UNIVERSAL MODULE TYPE
	BNE	59$		;IF NE, NO
	TST	STBLK		;IS INPUT FILE CONTIGIOUS?
	BNE	55$		;IF NE, YES
	TST	STBLK+2		;IS INPUT FILE CONTIGIOUS?
	BEQ	59$		;IF EQ, NO, SO CONTINUE
55$:	BISB	#CN$TG,-1(R4)	;SET CONTIGIOUS ATTRIBUTE
59$:	MOV	#L$NX,R5	;GET ADDRESS OF MODULE INSERT
	CALL	.MARK		;COMPUTE CURRENT VBN&BYTE-IN-BLOCK
	MOV	R3,-(SP)	;SAVE BYTE IN BLOCK
	SUB	(R5)+,R2	;# OF BLOCKS


	.IF DF	R$$EIS


	MUL	#512.,R2	;COMPUTE # OF BYTES

	.IFF

	SWAB	R2		;MULTIPLY R2 BY 256.
	MOV	R2,R3		;MAKE IT DOUBLE WORD RESULT
	CLRB	R3		;CLEAR LOW HALF OF R3
	BIC	R3,R2		;CLEAR HIGH HALF OF R2
	ASL	R3		;FINAL RESULT IS MULTIPLIED BY 512.
	ROL	R2		;DOUBLE WORD


	.ENDC


	ADD	(SP),R3		;ADD BYTE-IN-BLOCK INTO MODULE SIZE
	ADC	R2		;(DOUBLE PRECISION)
	SUB	(R5),R3		; - BYTE IN RECORD OF START
	SBC	R2		;(DOUBLE PRECISION)
	MOV	R2,(R4)+	;AND SAVE MODULE SIZE
	MOV	R3,(R4)+
	MOV	#DATE,R1
	GTIM$S	R1
	MOV	#L$DAT,R3	;STORE DATE IN BOTH LIBRARY HEADER
	MOV	(R1),(R4)+	;AND MODULE HEADER
	MOV	(R1)+,(R3)+
	MOV	(R1),(R4)+
	MOV	(R1)+,(R3)+
	MOV	(R1),(R4)+
	MOV	(R1)+,(R3)+
	MOV	(R1)+,(R3)+
	MOV	(R1)+,(R3)+
	MOV	(R1),(R3)
	CMPB	#2,L$TYP	;UNI MODULE TYPE?
	BEQ	140$		;IF EQ, YES, BR. TO HANDLE USER SUPPLIED IDENT
	MOV	ID,(R4)+	;STORE MHID
	MOV	ID+2,(R4)
	MOV	#$INBLK,R3	;POINT R3 TO $INBLK
	MOV	#$INVSZ,R2	;R2 = MAX NUM OF VALUES ON /IN
130$:	TST	(R3)+		;SINCE NOT UNI MODULE, INVALID INFO SPEDIFIED?
	BNE	135$		;IF NE, YES, SO BRANCH TO REPORT IT
	SOB	R2,130$		;IF R2 # 0, TEST SOME MORE
	BR	200$		;NO INFO SUPPLIED OBJ OR MAC MODULES, SO CONT.
135$:	MOV	(PC)+,R1	;INDICATE INVALID INFO SUPPLIED ERROR
	.BYTE	E$R35,S$V0
	CALL 	$ERMSG
	MOV	$LBRPT,R0	;RESTORE R0 TO VALUE BEFORE CALL $ERMSG
	BR	200$		;DISREGARD INFO AND CONTINUE
140$:	MOVB	#R.VAR,F.RTYP(R0) ;SET LIBRARY BACK TO FIXED LENGTH RECORDS
	MOV	$INPPT,R1	;POINT TO INPUT FDB
	MOV	F.FNB+N.FTYP(R1),(R4)+ ;MOVE INPUT FILETYPE TO MODULE HEADER
	MOV	F.FNB+N.FVER(R1),(R4)+ ;MOVE INPUT FILEVERSION (BINARY) TO HDER
	MOV	#$INVSZ-1,R2	;R2 = NUM OF OP INFO
	MOV	#$INBLK,R3	;POINT R3 TO /IN VALUES
180$:	ADD	#6,R3		;POSITION R3 TO NEXT USER SUPPLIED INFO.
	CALL	$CARD		;CONVERT VALUES TO RAD50
	BCC	185$		;IF CC, NO CONVERSION ERROR, SO CONTINUE
	MOV	(PC)+,R1	;CONVERSION ERROR
	.BYTE	E$R36,S$V2
	MOV	#ARGBLK,R2	;POINT R2 TO THE ARGUEMENT BLOCK
	MOV	R3,(R2)		;MOVE ADDRESS OF STRING TO ARG BLK
	JMP	$ERMSG		;FATAT ERROR EXIT
185$:	SOB	R2,180$		;IF R2 # 0, BRANCH TO CONVERT SOME MORE
;
; COPY THE USER FILE ATTRIBUTES FROM THE INPUT FILE HEADER TO THE MODULE HEADER
;
 
	MOV	$INPPT,R0	;POINT RO TO INPUT FDB
	.IF	NDF,R$RSTS	;++RSTS 7.2
	MOVB	#-4,ATTLST	;INDICATE READ USER FILE ATTRIBUTES
	MOV	#IO.RAT,R1	;INDICATE READ ATTRIBUTES FOR .XQIO
	MOV	#2,R2		;INDICATE 2 OPTIONAL PARAMETERS
	MOV	#$RUFAP,R3	;POINT R3 TO PARAMETER LIST
	CALL	.XQIO		;READ USER FILE ATTRIBUTES INTO MODULE HEADER
	.IFF			;++RSTS 7.2
	MOV	R5,-(SP)	;++RSTS 7.2 SAVE WORKING REGISTER
	JSR	R5,$CLEAR	;++RSTS 7.2 CLEAR OUT FIRQB
	  .WORD	FIRQB		;++RSTS 7.2 
	  .WORD	FQBSIZ		;++RSTS 7.2
	MOV	#FIRQB,R5	;++RSTS 7.2 POINT TO FIRQB
	CLR	R4		;++RSTS 7.2 MAKE IT A READ
	CALL	..ATR		;++RSTS 7.2 GET FILE ATTRIBUTES
	TSTB	@#FIRQB		;++RSTS 7.2 ANY ERRORS?
	BNE	189$		;++RSTS 7.2 YES, THEN LEAVE FDB ALONE
	MOV	#11.,R4		;++RSTS 7.2 TRANSFER MAX OF 11.
	MOV	#$MHUFA,R1	;++RSTS 7.2 COPY POINTER TO PARAMETER LIST
	CMP	(R5)+,(R5)+	;++RSTS 7.2 POINT TO RETURNED ATTRIBUTES 
	TST	(R5)+		;++RSTS 7.2
	TST	(R5)		;++RSTS 7.2 ARE THERE ANY ATTRIBUTES?
	BNE	188$		;++RSTS 7.2 YUP, START UP TRANSFER
	MOV	R0,R5		;++RSTS 7.2 NOPE, USE THE INPUT FILE ATT.
	MOV	#4,(R0)+	;++RSTS 7.2 FAKE STREAM TYPE
	MOV	#96.,(R0)+	;++RSTS 7.2 SEEMS LIKE A NICE ROUND NUMBER
188$:	MOV	(R5)+,(R1)+	;++RSTS 7.2 COPY THE ATTRIBUTES
	SOB	R4,188$		;++RSTS 7.2
189$:	MOV	(SP)+,R5	;++RSTS 7.2 RESTORE WORKING REGISTER
	.ENDC			;++RSTS 7.2
	BCC	190$		;IF CC, CONTINUE
	MOV	(PC)+,R1	;ERROR ON INPUT
	.BYTE	E$R01,S$V2
	MOV	INPPT+R$NAME,R2
	JMP	$ERMSG
190$:	BITB	#CN$TG,$MHAT	;IS THE INPUT FILE CONTIGIOUS?
	BNE	195$		;IF NE, YES, DON'T READJUST HIGH BLOCK
	MOV	$MHUFA+F.EFBK+2,$MHUFA+F.HIBK+2 ;MAKE HIGH BLK ATTRIB.=EOF BLK
195$:	MOV	$LBRPT,R0	;RESTORE R0
 
200$:	CLR	R1		;GET ADDRESS OF MODULE HEADER RECORD
	MOV	-(R5),R2
	MOV	2(R5),R3
	MOV	F.VBN+2(R0),(R5)+ ;SAVE NEW NEXT MODULE ADDRESS
	MOV	(SP)+,(R5)
	CALL	.POINT		;RESET RECORD POINTER
	BCC	11$		;IF CC, NO ERROR, SO CONTINUE
	JMP	24$		;POSITION ERROR, SO REPORT IT
11$:	PUT$	R0,#$MHST,MHSZ	;REWRITE MODULE HEADER
	BCC	12$		;IF CC, BRANCH AROUND JUMP TO CONTINUE
	JMP	40$		;JUMP IF WRITE ERROR
12$:	CMP	RPMHD,#1	;CHECK FOR OCCURRENCE OF REPLACE
	BHI	13$		;IF HI, BRANCH AROUND JUMP TO CONTINUE
	JMP	18$		;JUMP IF NO OCCURRENCE OF REPLACE
13$:	TST	RPMNT		;IF SO, CHECK FOR THE MODULE NAME
	BNE	15$		;IF PRESENT, CONTINUE
	JMP	EPTERR		;OTHERWISE, FORCE EPT ERROR
15$:
	MOV	#RPMHD,R2	;NOW IS THE TIME TO DELETE MODULE
	CALL	$DELM
	CALL	$WTHD		;BEST REWRITE HEADER
	MOV	#RPM,R1		;TELL HIM I DID IT
	MOV	#RPMNT,R2	;GET POINTER TO MNT NAME
	CALL	$OUT1
18$:	MOV	$INPPT,R0
	CMPB	#2,L$TYP	;UNI MODULE TYPE?
	BEQ	CLOSIN		;IF EQ, YES, ALREADY EOF AND NO NEED TO READ


	.IF NDF	S$$LIB


	GET$	R0		;MORE INPUT?

	.IFF

	GET$S	R0		;MORE INPUT?


	.ENDC


	BCS	CLOSIN		;BRANCH IF NO MORE INPUT
	CLR	ID		;CLEAR OUT ID FOR CONCATENATED
	CLR	ID+2		;	OBJECT MODULE PROCESSING
	JMP	IN20		;GET$ SUCCEEDED...GO BACK FOR MORE

CLOSIN:	CLOSE$	R0		;CLOSE INPUT FILE
	TST	(SP)+		;FLUSH COROUTINE ADDRESS
	CALL	$WTHD		;WRITE OUT HEADER, EPT, MNT
	JMP	IN10		;RETURN FOR MORE INPUT
	.PAGE
;
; OBJECT LANGUAGE DEFINITION
;

GSD	=1			;GLOBAL SYMBOL DIRECTORY RECORD TYPE
	MN=0				;MODULE NAME ENTRY
	GSN=4				;GLOBAL SYMBOL NAME ENTRY
		DEF=10				;DEFINITION FLAG
	PVI=6				;PROGRAM VERSION ID ENTRY

ENDOM	=6			;END OF MODULE RECORD TYPE


;+
;
; THIS CO-ROUTINE HANDLES THE OBJECT MODULE TYPE-DEPENDENT
; FUNCTIONS FOR THE INSERT ($INS) PROCESSOR.
;
;-

$INOBJ::
	MOV	#HS$OBJ,MHSZ	;STORE MODULE HEADER SIZE

CO1:	CLR	ENDFLG
COXIT:	CALL	@(SP)+		;EXIT CO-ROUTINE
	MOV	F.NRBD+2(R0),R1	;GET ADDRESS OF RECORD JUST READ
	CMPB	#GSD,(R1)
	BEQ	120$		;BRANCH IF GSD RECORD
	CMPB	#ENDOM,(R1)
	BNE	CO1		;BRANCH IF NOT END-OF-MODULE
	INC	ENDFLG		;INDICATE END OF MODULE
	BR	COXIT		;EXIT

120$:	MOV	R1,R5
	ADD	F.NRBD(R0),R5	;R5=END OF RECORD ADDRESS
	TST	(R1)+		;POINT TO FIRST GSD ENTRY

ILOP:	CMP	R1,R5		;REACHED END OF RECORD?
	BHIS	CO1		;EXIT IF ALL DONE
	CMPB	#MN,5(R1)
	BNE	140$		;BRANCH IF NOT MODULE NAME ENTRY
	MOV	#$MNBLK,R2	;MNT DESCRIPTOR
	MOV	#L$MA,R4	;POINT R4 TO MNT'S AVAILABLE
	CALL	PUT

140$:	CMPB	#GSN,5(R1)
	BNE	150$		;BRANCH IF NOT GLOBAL SYMBOL NAME
	BITB	#DEF,4(R1)	;IS IT A SYMBOL DEFINITION?
	BEQ	CEXIT		;BRANCH IF NOT
	BIT	#EP$SW,INPPT+R$SWTH ;ENTRY POINTS DESIRED?              ; TM002
	BNE	CEXIT		;IF NE NO                               ; TM002
	MOV	#$EPBLK,R2	;EPT DESCRIPTOR
	MOV	#L$EA,R4	;POINT R4 TO EPT'S AVAILABLE
	CALL	PUT		;UPDATE THE EPT

150$:	CMPB	#PVI,5(R1)
	BNE	CEXIT		;BRANCH IF NOT PROGRAM VERSION ID ENTRY
	MOV	(R1),ID		;STORE VERSION IDENTIFICATION
	MOV	2(R1),ID+2

CEXIT:	ADD	#8.,R1		;GET NEXT GSD ENTRY
	BR	ILOP

;
;+
;
; THIS ROUTINE SCANS FOR FIRST LEVEL MACRO DEFINITIONS IN THE INPUT FILE.
; IT CREATES THE MNT ENTRY FOR EACH DEFINITION IT FINDS AND ONLY SWITCHES
; TO THE MAIN PROGRAM LOOP WHEN IT IS SCANNING LINES OF A MACRO DEFINITION
; WHICH MUST BE WRITTEN TO THE LIBRARY FILE.  THEREFORE IT MUST DO ITS OWN
; INPUT WHILE IT SCANNING OUTSIDE OF A MACRO DEFINITION.
;
;-
$INMAC::
	MOV	#HS$MAC,MHSZ	;SET MODULE HEADER SIZE
COXIT1:	CALL	@(SP)+		;SWITCH TO MAIN PROGRAM LOOP
	TST	MDEPTH		;ARE WE INSIDE A MACRO DEFINITION ALREADY?
	BHI	70$		;BRANCH IF SO
	CLR	ENDFLG		;OTHERWISE INDICATE NO END OF MODULE
10$:	CALL	SCAN		;SCAN FOR NEXT KEY WORD
	BCS	20$		;IF NONE FOUND READ NEW LINE
	TST	R4		;IS KEY WORD ".MACRO"?
	BEQ	30$		;BRANCH IF SO
20$:

	.IF NDF S$$LIB

	GET$	R0		;READ NEXT LINE

	.IFF

	GET$S	R0		;READ NEXT LINE

	.ENDC

	BCC	10$		;BRANCH TO SCAN LINE IF NO ERRORS
	JMP	CLOSIN		;JUMP TO CLOSE INPUT FILE
				;(COROUTINE WILL BE RESTARTED)
30$:	MOV	R3,R4		;COPY END OF LINE POINTER
	SUB	R1,R4		;MACRO DEF FOUND, CALCULATE CHARS LEFT
				;... IN CURRENT LINE
	BLE	20$		;IGNORE LINE IF NO MACRO NAME
	CMP	R4,#6		;GREATER THAN SIX?
	BLE	40$		;OK IF NOT
	MOV	#6,R4		;OTHERWISE CONSIDER ONLY FIRST SIX
40$:	MOV	#MACNAM+4,R0	;POINT TO MACNAM BUFFER
	CLR	(R0)		;...AND CLEAR IT  OUT
	CLR	-(R0)
	CLR	-(R0)
	MOV	R4,R2		;SAVE STRING COUNTER
50$:	MOVB	(R1)+,(R0)+	;MOVE IN CHARS FROM INPUT LINE
	SOB	R4,50$		;LOOP UNTIL ALL MOVED
	MOV	#MACNAM,R0	;POINT TO NAME BUF
	MOV	R0,R1		;SET UP TO CONVERT TO UPPER CASE
	MOV	R0,R4		;SAVE STRING POINTER
	CALL	$CVTUC		;DO THE CONVERSION
	MOV	R4,R0		;PUT STRING POINTER BACK IN R0
	CALL	$CAT5		;CONVERT
	MOV	R1,R5		;COPY CONVERTED CHARS TO R5
	BCC	55$		;IF CC, NO CONVERSION ERROR, SO CONTINUE
	CLR	R1		;SINCE ERROR, 2ND RAD50 WORD (IF USED) IS NULL
	TST	R2		;WAS INVALID CHAR A NULL?
	BEQ	60$		;IF EQ, YES, SO NOT REALLY AN ERROR
	CMP	#TAB,R2		;WAS INVALID CHAR A TAB?
	BEQ	60$		;IF EQ, YES, SO NOT REALLY AN ERROR
	CMP	#SPACE,R2	;WAS INVALID CHAR A SPACE?
	BEQ	60$		;IF EQ, YES, SO NOT REALLY AN ERROR
	CMP	#COMMA,R2	;WAS INVALID CHAR A COMMA?
	BEQ	60$		;IF EQ, YES, SO NOT REALLY AN ERROR
	CMP	#SEMI,R2	;WAS INVALID CHAR A SEMI-COLON?
	BEQ	60$		;IF EQ, YES, SO NOT REALLY AN ERROR
53$:	MOV	(PC)+,R1	;ERROR, INVALID RAD50 CHAR
	.BYTE	E$R19,S$V2
	MOV	#ARGBLK,R2	;POINT R2 TO ADDRESS OF ARGUEMENT BLK
	MOV	#MACNAM,(R2)	;MOVE ADDRESS OF MACRO NAME TO ARGUEMENT BLK
	JMP	$ERMSG		;FATAL ERROR EXIT
55$:	CALL	$CAT5		;CONVERT SECOND HALF OF MACRO NAME
	BCC	60$		;IF CC, NO ERROR
	TST	R2		;WAS INVALID CHAR A NULL?
	BEQ	60$		;IF EQ, YES, SO NOT REALLY AN ERROR
	CMP	#TAB,R2		;WAS INVALID CHAR A TAB?
	BEQ	60$		;IF EQ, YES, SO NOT REALLY AN ERROR
	CMP	#SPACE,R2	;WAS INVALID CHAR A SPACE?
	BEQ	60$		;IF EQ, YES, SO NOT REALLY AN ERROR
	CMP	#COMMA,R2	;WAS INVALID CHAR A COMMA?
	BEQ	60$		;IF EQ, YES, SO NOT REALLY AN ERROR
	CMP	#SEMI,R2	;WAS INVALID CHAR A SEMI-COLON
	BNE	53$		;IF NE, NO, SO ERROR
60$:	MOV	R1,MACNAM+2	;MOVE IN SECOND RAD50 WORD INTO NAME BUFFER
	MOV	R5,MACNAM	;MOVE IN FIRST RAD50 WORD INTO NAME BUFFER
	MOV	#MACNAM,R1	;POINT TO MACRO NAME
	MOV	#$MNBLK,R2	;POINT TO MNT BLOCK
	MOV	#L$MA,R4	;MOVE IN MODULE HEADER SIZE
	CALL	PUT		;WRITE MNT ENTRY
	INC	MDEPTH		;WE ARE IN A MACRO DEF NOW
	BR	SQZ		;BRANCH TO HAVE LINE WRITTEN TO LBR FILE
70$:	CALL	SCAN		;SCAN FOR KEY WORD
	BCS	SQZ		;WRITE LINE IF NONE FOUND
	BIT	#4,R4		;.MACRO, .REPT, .IRPC OR .IRP?
	BNE	80$		;BRANCH IF NOT
	INC	MDEPTH		;OTHERWISE INC MACRO DEPTH
	BR	SQZ		;AND WRITE LINE
80$:	DEC	MDEPTH		;MUST HAVE BEEN ".ENDM" OR ".ENDR"
	BNE	SQZ		;WRITE LINE IF STILL IN MACRO DEF
	INC	ENDFLG		;OTHER INDICATE END OF MACRO DEF
	BR	SQZ		;WRITE LAST LINE AND ADJUST POINTERS
SQZ:	BIT	#SZ$SW,R$SWTH+INPPT ;SQUEEZE DESIRED?
	BEQ	COXIT1		;IF EQ NO
	MOV	F.NRBD+INPPT,R1	;PICK UP CHARACTER COUNT FOR LINE
	CALL	ELIM		;ELIMINATE TRAILING BLANKS AND TABS
	MOV	R1,F.NRBD+INPPT	;UPDATE CHARACTER COUNT
	BEQ	COXIT1		;IF EQ LINE ELIMINATED
10$:	CMPB	-(R3),#';	;SEMI-COLON?
	BEQ	20$		;IF EQ YES
	DEC	R1		;OTHERWISE DECREMENT COUNT
	BNE	10$		;IF NE MORE CHARACTERS ON LINE
	JMP	COXIT1		;OTHERWISE NO SEMI ON LINE
20$:	DEC	R1		;DEC COUNT FOR SEMI
	BEQ	30$		;IF EQ FIRST CHAR ON LINE
	CALL	ELIM		;ELIMINATE TRAILING BLANKS AND TABS
30$:	MOV	R1,F.NRBD+INPPT	;UPDATE CHARACTER COUNT
	JMP	COXIT1		;JMP TO PRINT LINE


;+
;
; THIS THE SCAN ROUTINE.  IT SCANS FOR KEY WORDS IN THE INPUT SOURCE FILES.
;
; INPUTS:
;	R0 POINTS TO FDB ON WHICH LINE HAS JUST BEEN READ.
;
; OUTPUTS:
;	C-BIT SET IF NO KEY WORD WAS FOUND ON CURRENT LINE.
;
;	C-BIT CLEAR IF A KEY WORD WAS FOUND, AND
;	R1 POINTS TO FIRST CHARACTER OF OPERAND FIELD (OR PAST END OF LINE)
;	R4 CONTAINS:
;		0 IF IT WAS ".MACRO"
;		1 IF IT WAS ".REPT"
;		2 IF IT WAS ".ENDM"
;		3 IF IT WAS ".ENDR"
;
;-
SCAN:	MOV	F.NRBD+2(R0),R1	;POINT TO LINE
	MOV	F.NRBD(R0),R3	;PICK UP CHARACTER COUNT
	ADD	R1,R3		;POINT TO CHAR PAST END OF LINE
5$:	BIS	#1,R2		;INITIALLY INDICATE NO KEY WORD ON LINE
	CALL	SKIP		;POINT R1 TO FIRST NON BLANK
	BCS	25$		;BRANCH IF NOTHING ON LINE
	CMPB	(R1),#'.	;FIRST CHAR "." (POSSIBLE KEY WORD)?
	BNE	10$		;BRANCH IF NOT
	INC	R1		;OTHERWISE POINT TO NEXT CHARACTER
	JSR	R5,CMPSTR	;SEE IF KEY WORD
	.WORD	6
	.WORD	MACSTR
	.WORD	REPSTR
	.WORD	IRCSTR
	.WORD	IRSTR
	.WORD	ENMSTR
	.WORD	ENRSTR
10$:	MOV	R1,R5		;SAVE CURRENT STRING POINTER
	CALL	SKIP		;POINT TO NEXT NONBLANK
	BCS	20$		;BRANCH ON LINE TERMINATION
15$:	CMPB	(R1)+,#':	;RESTART LINE SCAN FOR LABLE
	BEQ	5$		;BRANCH IF SO
	CMPB	-(R1),#'=	;CHECK FOR ASSIGNMENT STATEMENT
	SEC			;PREPARE TO RETURN STATUS OF NO KEY WORD
	BEQ	25$		;RETURN IF ASSIGNMENT
	CMP	R1,R5		;SEE IF POINTER WAS BUMPED IN "SKIP"
	BNE	20$		;IF IT WAS, THEN OPERATOR HAS BEEN SCANNED
	BIS	#1,R2		;COULD NOT HAVE SCANNED KEY WORD
	INC	R1		;OTHERWISE BUMP POINTER
	BR	10$		;CONTINUE SCAN
20$:	ROR	R2		;SET RETURN STATUS
25$:	RETURN


;+
;
; THIS ROUTINE COMPARES A STRING IN THE INPUT BUFFER WITH A SET OF
; STRINGS POINTED TO IN THE CALL.
;
; IT IS CALLED BY:
;	JSR	R5,CMPSTR
;	.WORD	COUNT
;	.WORD	STRPT0
;	.WORD	STRPT1
;	...
;
; WHERE:
;	COUNT IS THE NUMBER OF STRING POINTERS BEING PASSED
;	STRPT0,STRPT1,... ARE POINTERS TO ASCIZ STRINGS
;	R1 POINTS TO THE TEST STRING
;
; OUTPUTS:
;	R2 UNCHANGED IF NO MATCH WAS FOUND
;
;	R2 CLEAR IF MATCH WAS FOUND, AND
;	R1 POINTS TO FIRST CHARACTER OF OPERAND FIELD (OR PAST END OF LINE)
;	R4 CONTAINS NUMBER OF STRING POINTER THAT WAS MATCHED.
;
;-
CMPSTR:	MOV	(R5)+,R4	;PICK UP COUNT
	MOV	R4,-(SP)	;AND SAVE IT
	MOV	R1,-(SP)	;SAVE STRING POINTER
5$:	MOV	(SP),R1		;PICK UP INPUT STRING PTR
	MOV	(R5)+,R2	;PICK COMPARE STRING PTR
10$:	TSTB	(R2)		;AT END OF COMPARE STRING?
	BEQ	15$		;MATCH IF SO
	CMPB	(R1)+,(R2)+	;OTHERWISE, COMPARE NEXT CHARACTER
	BEQ	10$		;LOOP IF EQUAL
	MOVB	-1(R2),-(SP)	;SET UP TO SEE IF LOWER CASE MATCHES
	ADD	#40,(SP)	;
	CMPB	-1(R1),(SP)+	;SEE IF ASCII FOR THE LOWER CASE MATCHES
	BEQ	10$
	SOB	R4,5$		;LOOP UNTIL STRING POINTERS EXHAUSTED
	MOV	(SP)+,R1	;RESTORE INPUT STRING POINTER
	TST	(SP)+		;POP SAVED COUNT
	BR	25$		;BRANCH TO EXIT
15$:	TST	(SP)+		;THROW AWAY SAVED STRING POINTER
	ADD	R4,R5		;BUMP R5 PAST
	ADD	R4,R5		;...LAST STRING POINTER
	TST	-(R5)		;...AND POINT TO INSTRUCTION AFTER CALL
	SUB	(SP)+,R4	;CALCULATE NEGATIVE OF NUMBER OF MATCH
	NEG	R4		;MAKE POSITIVE
	CLR	R2		;INDICATE SUCCESSFUL MATCH
25$:	RTS	R5
;+
;
; THIS ROUTINE ATTEMPTS TO POINT R1 TO THE NEXT NONBLANK IN THE CURRENT.
; IT RETURNS:
;
;	C-BIT CLEAR IF SUCCESSFUL
;
;	C-BIT SET IF ";" OR END OF LINE SEEN
;
;-
SKIP:	CMP	R1,R3		;END OF LINE?
	BHIS	15$		;BRANCH TO RETURN C-BIT SET IF SO
	CMPB	(R1),#';	;COMMENT FIELD?
	BEQ	15$		;BRANCH IF SO
	CMPB	(R1)+,#11	;CURRENT CHARACTER A TAB?
	BEQ	SKIP		;BRANCH TO BUMP POINTER IF SO
	CMPB	-(R1),#40	;CURRENT CHARACTER SPACE?
	CLC			;PREPARE TO RETURN C-BIT CLEAR IF NOT
	BNE	20$		;BRANCH TO RETURN C-BIT CLEAR
	INC	R1		;BUMP POINTER PAST SPACE OR TAB
	BR	SKIP		;CHECK NEXT CHAR
15$:	SEC
20$:	RETURN


;+
;
; THIS ROUTINE IS USED TO ELIMINATE TRAILING BLANKS AND TABS FROM THE
; CURRENT SOURCE LINE.
;
; INPUTS:
;	R1 CONTAINS CHARACTER OF CURRENT LINE
;	R3 POINTS PAST LAST CHARACTER ON CURRENT LINE
;
; OUTPUTS:
;	R1 CONTAINS UPDATED CHARACTER COUNT
;	R3 POINTS PAST LAST NONBLANK, NONTAB CHARACTER ON LINE
;
;-

ELIM:	CMPB	-(R3),#11	;CURRENT LAST CHAR A TAB?
	BEQ	10$		;IF EQ YES
	CMPB	(R3),#40	;CURRENT LAST CHAR A BLANK?
	BNE	20$		;IF NE NO
10$:	DEC	R1		;REDUCE COUNT FOR TRAILING CHAR
	BNE	ELIM		;IF NE MORE CHARS ON LINE
20$:	INC	R3		;POINT R3 PAST CURRENT END OF LINE
	RETURN
 
 
;+
; THIS CO-ROUTINE PUTS A UNIVERSAL MODULE ENTRY INTO THE MNT AND PROVIDES FOR
; THE COPYING OF A RECORD FROM THE INPUT FILE INTO THE LIBRARY.
;-
 
$INUNI::
	MOV	#HS$UNI,MHSZ	;STORE UNIVERSAL MODULE HEADER SIZE
	CLR	ENDFLG		;INDICATE NO END OF MODULE
	MOVB	#FD.RWM,F.RACC(R0) ;INDICATE BLK I/0 
	FDBK$R	R0,#$RECBF,#$BFSIZ,,#1,$BKSTA ;SET-UP FOR BLOCK READ
	MOV	#STBLK,F.STBK(R0) ;COPY ADDR OF STATISTIC BLK TO INPUT FDB
	CALL	@(SP)+		;EXIT CO-ROUTINE
	MOV	#$UNINM,R4	;POINT R4 TO (RAD50) UNI MODULE NAME BUFFR
	MOV	#$INBLK,R3	;POINT TO ASCII UNIVERSAL MOD. NAME
	TSTB	(R3)		;USE DEFAULT NAME?
	BNE	30$		;IF NE, NO, SO BRANCH TO CONVERT
	MOV	$INPPT,R1	;POINT TO INPUT FDB
	MOV	F.FNB+N.FNAM(R1),(R4)+ ;MOVE FIRST 6 CHAR OF INPUT FILENAME...
	MOV	F.FNB+N.FNAM+2(R1),(R4) ;...TO UNIVERSAL MODULE NAME BUFFER
	BR	50$		;BRANCH AROUND RAD50 CONVERSION
30$:	CALL	$CARD		;CONVERT USER SPECIFIED NAME TO RAD50
	BCC	50$		;IF CC, NO CONVERSION ERROR, SO CONTINUE
	MOV	(PC)+,R1	;CONVERSION ERROR
	.BYTE	E$R19,S$V2
	MOV	#ARGBLK,R2	;POINT R2 TO THE ARGUEMENT BLK
	MOV	R3,(R2)		;MOVE ADDRESS OF STRING TO ARG BLK
	JMP	$ERMSG		;FATAL ERROR EXIT
50$:	MOV	#$UNINM,R1	;POINT R1 TO UNI MODULE NAME
	MOV	#$MNBLK,R2	;POINT R2 TO MNT DESCRIPTOR BLOCK
	MOV	#L$MA,R4	;POINT R4 TO MNT'S AVAILABLE
	CALL	PUT		;PUT MODULE IN MNT
5$:	CLR	ENDFLG		;INDICATE NOT END OF MODULE
	CALL	@(SP)+		;EXIT CO-ROUTINE
	BR	5$		;BRANCH TO READ NEXT RECORD
	.END


