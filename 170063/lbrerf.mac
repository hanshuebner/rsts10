	.TITLE	LBRERF
	.IDENT	/4.01/
;
;		COPYRIGHT (C) 1985, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD
;	 MASSACHUSETTS.  ALL RIGHTS RESERVED.
;
; THIS  SOFTWARE  IS  FURNISHED  UNDER  A LICENSE AND MAY BE USED
; AND  COPIED  ONLY IN  ACCORDANCE WITH THE TERMS OF SUCH LICENSE
; AND WITH  THE INCLUSION  OF THE ABOVE  COPYRIGHT  NOTICE.  THIS
; SOFTWARE  OR ANY OTHER  COPIES  THEREOF, MAY NOT BE PROVIDED OR
; OTHERWISE MADE  AVAILABLE TO ANY OTHER PERSON.  NO TITLE TO AND
; OWNERSHIP OF THE SOFTWARE IS HEREBY TRANSFERED.
;
; THE INFORMATION  IN THIS DOCUMENT IS SUBJECT  TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT  BY  DIGITAL
; EQUIPMENT CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF
; ITS SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.
;
;
;
;
;
; WRITTEN BY:
;	GEORGE W. BERRY
;
; MODIFIED BY:
;
;	J. W. BERZLE	20-SEP-83	4.00
;
;		JWB049 - GET TASK NAME FOR ERROR MESSAGES FROM $GTKNM
;
; MODIFIED FOR RSTS/E V10.1 BY:
;
;	S. LEVAN	09-MAY-91	4.01
;
;		MERGE RSTS-SPECIFIC CODE INTO RSX V4.3 VERSION OF MODULE.
;
;
; ERROR MESSAGE FORMATTING ROUTINE
;

;
; MACRO LIBRARY CALLS
;

	.MCALL	FCSBT$
	FCSBT$
	.MCALL	FDOFF$
	FDOFF$	DEF$L
 
 
	.IF NDF	R$$11M
 
	.MCALL	MOUT$,MOWA$S,DIR$
 
	.ENDC
 
 
;
; LOCAL DATA
;
 
	.PSECT	TXT

	.IF	NDF,R$RSTS		;++RSTS 7.2
DIAG:	.ASCII	<15><12>
	.BYTE	0,0,0		;ROOM FOR TASK NAME FROM $GTKNM
	.ASCIZ	/ --*DI/	;NOTE: NULL CHARACTER MUST BE 4 BYTES FORM...
				;    ... END OF STRING
	.ASCII	/AG*-/
FATAL:	.ASCII	<15><12>
	.BYTE	0,0,0		;ROOM FOR TASK NAME FROM $GTKNM
	.ASCIZ	/ --*FAT/	;NOTE: NULL CHARACTER MUST BE 4 BYTES FORM...
				;    ... END OF STRING
	.ASCII	/AL*-/

	.IFF			;++RSTS 7.2
DIAG:	.ASCIZ	<15><12><045>/LBR -- *DI/  ;++RSTS 7.2 DIAGNOSTIC PREFIX
	.ASCII	/AG*-/	  	;++RSTS 7.2 NOTE: NULL CHAR MUST BE 4 BYTES FROM ...
				;++RSTS 7.2      ... END OF STRING
FATAL:	.ASCIZ	<15><12><077>/LBR -- *FAT/  ;++RSTS 7.2 FATAL PREFIX
	.ASCII	/AL*-/		;++RSTS 7.2 NOTE: PLACEMENT OF NULL CHAR AGAIN
	.ENDC			;++RSTS 7.2
 
	.PSECT
 
 
	.IF NDF	R$$11M
 
 
;
; MESSAGE FILENAME DESCRIPTOR
;
 
	.PSECT	TXT
 
MSGFL:	.ASCII	/SY:[1,2]LBR.MSG/  ;FILENAME STRING
MSGFLE:
 
	.PSECT
 
MFLDS:	.WORD	MSGFLE-MSGFL	;FILENAME DESCRIPTOR
	.WORD	MSGFL
 
;
; MESSAGE OUTPUT DPB
;
 
MODPB:	MOUT$	MFLDS,,,CONT,USBUF,$OUTBF,128.,MOSTS,8.
 
;
; MESSAGE OUTPUT I/O STATUS BLOCK
;
 
MOSTS:	.BLKW	2
 
 
	.ENDC
 
 
;+
;
; **-$FMTER- FORMAT AN ERROR MESSAGE
;
; THIS ROUTINE IS CALLED BY '$ERMSG'.  THE DESCRIPTION ON ITS
; USE IS FOUND IN THAT MODULE.
;
;-

$FMTER::
	CLR	R5		;
	BISB	R1,R5		;GET ERROR NUMBER
	CLR	R4		;
	SWAB	R1		;SWAP HALVES
	BISB	R1,R4		;GET SEVERITY
	MOV	$CMIPT,R3	;GET COMMAND INPUT RECORD BLOCK
	BITB	#FD.TTY,F.RCTL(R3);TERMINAL DEVICE?
	BNE	40$		;IF NE YES
	INC	R4		;INCREMENT SEVERITY

40$:
	.IF	NDF,R$RSTS		;++RSTS 7.2
	MOV	(PC)+,R1	;DEFAULT TASK NAME IS TSK
	.RAD50	/TSK/
	CALL	$GTKNM		;GET 3 CHARACTER TASK NAME
	MOV	#DIAG+2,R0	;ADDRESS FOR TASK NAME IN MESSAGE
	MOV	R2,-(SP)	;SAVE R2
	MOV	R1,-(SP)	;SAVE R1 (TASK NAME IN RAD50
	CALL	$C5TA		;CONVERT TO ASCII
	MOV	#FATAL+2,R0	;ADDRESS FOR TASK NAME IN MESSAGE
	MOV	(SP)+,R1	;RESTORE R1 (TASK NAME IN RAD50)
	CALL	$C5TA		;CONVERT TO ASCII
	MOV	(SP)+,R2	;RESTORE R2
	.ENDC			;++RSTS 7.2

	MOV	#DIAG,R1	;ASSUME DIAGNOSTIC MESSAGE
	MOV	#EX$WAR,R0	;SET WARNING STATUS
	CMP	R4,#S$V2	;FATAL ERROR?
	BLT	45$		;IF LT NO
	MOV	#EX$ERR,R0	;SET ERROR STATUS
	MOV	#FATAL,R1	;GET ADDRESS OF FATAL MESSAGE
45$:	CMP	R0,$ERSTS	;IS NEW STATUS WORSE THAN CURRENT STATUS?
	BLE	50$		;IF LE NO
	MOV	R0,$ERSTS	;SET NEW STATUS
50$:	MOV	#$ERRBF,R0	;GET ADDRESS OF OUTPUT BUFFER
60$:	MOVB	(R1)+,(R0)+	;INSERT PREFIX
	BNE	60$		;
	DEC	R0		;BACKUP BUFFER ADDRESS
 
 
	.IF NDF	R$$11M
 
 
	MOV	R4,R3		;SAVE SEVERITY
	MOV	#MODPB,R4	;GET ADDRESS OF MESSAGE OUTPUT DPB
	MOV	R0,M.OBUF(R4)	;SET UP BUFFER ADDRESS
	MOV	R2,M.OPRM(R4)	;SET ADDRESS OF PARAMETER BLOCK
	MOV	R5,M.ONUM(R4)	;SET ERROR NUMBER
	INC	M.ONUM(R4)	;CONVERT TO RECORD NUMBER
	DIR$	R4		;FORMAT MESSAGE
	BCS	63$		;IF CS MO NOT IN SYSTEM
	MOWA$S			;WAIT FOR FORMATTING TO BE COMPLETED
	DECB	MOSTS		;I/O ERROR?
	BEQ	67$		;IF EQ NO
63$:	CMPB	(R0)+,(R0)+	;POINT TO BYTE COUNT
	MOVB	#2,(R0)+	;SET BYTE COUNT TO 2
	TSTB	(R0)+		;ADJUST FIRST TEXT BYTE
	CLR	R4		;CLEAR HIGH PART OF DIVIDEND
	MOV	R0,-(SP)	;SAVE R0
	MOV	#10.,R0		;PREPARE TO DIVIDE BY 10.
	DIV	R0,R4		;CONVERT ERROR NUMBER
	MOV	(SP)+,R0	;RESTORE R0
	ADD	#'0,R4		;CONVERT HIGH DIGIT TO ASCII
	MOVB	R4,(R0)+	;INSERT DIGIT IN BUFFER
	ADD	#'0,R5		;CONVERT LOW DIGIT TO ASCII
	MOVB	R5,(R0)		;INSERT LOW DIGIT IN BUFFER
	SUB	#5,R0		;BACK UP RECORD COUNT ADDRESS
67$:	MOVB	(R1)+,(R0)+	;INSERT REMAINDER OF PREFIX
	MOVB	(R1)+,(R0)+	;
	MOVB	(R0),R2		;PICK UP LENGTH OF RECORD
	MOVB	(R1)+,(R0)+	;
	MOVB	(R1),(R0)+	;INSERT LAST BYTE OF PREFIX
	SUB	#$OUTBF,R0	;CALCULATE LENGTH OF PREFIX
	ADD	R0,R2		;ADD TO FORMATTED RECORD LENGTH
	MOV	R3,R4		;RESTORE SEVERITY INTO R4
 
	.IFF
 
	MOVB	(R1)+,(R0)+	;MOVE REMAINDER OF ...
	MOVB	(R1)+,(R0)+	;... PREFIX STRING ...
	MOVB	(R1)+,(R0)+	;... INTO THE MESSAGE ...
	MOVB	(R1),(R0)+	;... BUFFER
	ASL	R5		;CONVERT ERROR NUMBER INTO AN OFFSET
	MOV	$MGLST(R5),R1	;POINT R1 TO ERROR MESSAGE FORMAT STRING
	CALL	$EDMSG		;GENERATE THE ERROR MESSAGE
	MOV	R0,R2		;PUT ADDR OF END OF MESSAGE IN R2
	SUB	#$ERRBF,R2	;CALCULATE LENGTH OF ERROR MESSAGE STRING
 
 
	.ENDC
 
 
	RETURN
 
 
 
	.END
