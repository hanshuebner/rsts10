	.TITLE	LBREX
	.IDENT	/02.02/

;
; COPYRIGHT (C) 1976, 1978, 1979, 1981
; DIGITAL EQUIPMENT CORP., MAYNARD, MASS. 01754
;
;	DEC ASSUMES NO RESPONSIBLIITY FOR THE USE
;	OR RELIABILITY OF ITS SOFTWARE ON EQUIPMENT
;	WHICH IS NOT SUPPLIED BY DEC.
;
; THIS SOFTWARE IS FURNISHED TO PURCHASER UNDER A LICENSE FOR USE
; ON A SINGLE COMPUTER SYSTEM AND CAN BE COPIED (WITH INCLUSION
; OF DEC'S COPYRIGHT NOTICE) ONLY FOR USE IN SUCH SYSTEM, EXCEPT
; AS MAY OTHERWISE BE PROVIDED IN WRITING BY DEC.
;
; THE INFORMATION IN THIS DOCUMENT IS SUBJECT TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT BY DIGITAL
; EQUIPMENT CORPORATION.
;
; VERSION 02.02
;
; WRITTEN BY:
;
;	THOMAS J. MILLER 11-JAN-76
;
; PREVIOUSLY MODIFIED BY:	B. ALIMONTI
;
; MODIFIED BY:
;	M. JOHNSON	22-JUL-81
;		MJ021 -- (RE)-INITIALIZE F.RACC TO CLEAR F.RWM WHEN RUNNING
;			  IN PROMPT MODE
;
; LIBRARY MODULE EXTRACTION.
;
;
; MACRO CALLS.
;

	.MCALL	FDOFF$
	FDOFF$	DEF$L
	.MCALL	FCSBT$
	FCSBT$
	.MCALL	CLOSE$,PUT$
	.MCALL	WRITE$,WAIT$,FDBK$R
	.MCALL	DIR$,ALUN$,GLUN$S
	.MCALL	CSI$
	CSI$


	.IF NDF	S$$LIB

	.MCALL	GET$,OPEN$

	.IFF

	.MCALL	GET$S

	.ENDC


;
; ALUN$  MACRO AND PARAMETERS
;

ALUN:	ALUN$	4,XX,0
DEVICE	=ALUN+A.LUNA
UNIT	=ALUN+A.LUNU


;
; LOCAL DATA.
;

DFTYP:				;TABLE OF DEFAULT FILE TYPES FOR OUTPUT
	.RAD50	/OBJ/		;DEFAULT FOR OBJECT MODULE OUTPUT
	.RAD50	/MAC/		;DEFAULT FOR MACRO DEFINITION OUTPUT
	.RAD50	/XXX/		;HERE TO BE CONSISTANT WITH OTHER LIBRARY TYPES
NXTHD:	.BLKW	2		;VBN / BYTE IN BLOCK OF END OF MODULE
LUNNFO:	.BLKW	6		;LUN INFORMATION RETURNED BY GLUN$S
SY:	.ASCII	/SY:/		;SYSTEM DEVICE MNEMONIC


	.EVEN

;+
;
; **-$EXT-MODULE EXTRACT FUNCTION
;
; THIS ROUTINE CONCATENATES THE SPECIFIED MODULES IN THE INPUT LIBRARY
; FILE INTO THE SPECIFIED OUTPUT FILE.  IF NO MODULES ARE SPECIFIED, ALL
; MODULES IN THE LIBRARY ARE CONCANTENATED INTO THE OUTPUT FILE IN
; ALPHABETICAL ORDER.
;
; INPUTS:
;
;	THE INPUT LBR FDB IS SET UP.
;	THE DESIRED MODULE NAMES ARE STORED IN RAD50 IN THE VECTOR AT
;		$DMN.
;
; OUTPUTS:
;
;	NONE.
;
;-

$EXT::	SAVRG			;SAVE R3-R5
	MOV	$EXTPT,R0	;POINT TO OUTPUT FDB
	CLR	F.RACC(R0)	; (RE)-INIT. RECORD ACCESS FOR PROMPT MO; MJ021
	MOV	#$CSIBK,R1	;POINT TO CSI BLOCK
	CALL	$SCANO		;GET OUTPUT FILE SPEC
	BCC	10$		;IF CC GOT ONE
	MOV	(PC)+,R1	;OUTPUT FILE SPEC MISSING
	.BYTE	E$R34,S$V2	;
	BR	15$		;
10$:	TST	R0		;MORE OUTPUT SPECS?
	BNE	20$		;IF NE NO
	MOV	(PC)+,R1	;TOO MANY OUTPUT FILES (INFORMATIONAL)
	.BYTE	E$R24,S$V0	;
15$:	CALL	$ERMSG		;ISSUE ERROR MESSAGE
20$:	MOV	#FO.RD,R1	;SET FOR READ ACCESS
	CALL	$RDHD		;READ LIBRARY HEADER, EPT AND MNT
	CMPB	#2,L$TYP	;UNIVERSAL MODULE TYPE?
	BEQ	21$		;IF EQ, YES, BRANCH TO PROCESS OF UNI LIB TYPE
	MOVB	L$TYP,R1	;GET LIBRARY TYPE
	ASL	R1		;CONVERT TO WORD OFFSET
	MOV	DFTYP(R1),EXTNAM+N.FTYP ;SET DEFAULT FILE TYPE
	BR	28$		;BRANCH AROUND PROCESSING OF UNI LIB TYPE


; SET-UP BLOCK I/O FOR EXTRACTING UNIVERSAL MODULES

21$:

.IF	DF	R$RSTS		;+++RSTS V9.0

	MOV	$CSIBK+C.DEVD+2,R0 ;Pick up address of device name
	BITB	#CS.DVF,$CSIBK+C.STAT ;Did we get a device name?
	BNE	2110$		;Yes, so use it
	MOV	#SY,R0		;Not found, point to SY:
	MOV	#3,R2		;And set up the length
	BR	2115$		;Now join up

2110$:	MOV	$CSIBK+C.DEVD,R2 ;R2 = Length of device name
	INC	R2		;Add one for the colon

2115$:	MOV	#XRB,R1		;R1 -> XRB
	MOV	R2,(R1)+	;Set up the length
	MOV	R2,(R1)+	;In both places
	MOV	R0,(R1)+	;Set up the address of the string
	CLR	(R1)+		;Clear out a word
	CLR	(R1)+		;And another one
	CLR	(R1)+		;And another one
	CLR	(R1)+		;And another one
	MOV	#"SY,@#FIRQB+30	;Set a default device name
	CLR	@#FIRQB+32	;And be sure we have no unit number
	.FSS			;Now scan the string
	TSTB	@#FIRQB		;Error?
	BNE	2410$		;Yes, so report it to the caller
	TST	@#XRB+10	;Did we get anything real?
	BMI	2410$		;No, so report an error
	MOV	@#FIRQB+30,DEVICE ;Yes, set the real device name
	MOVB	@#FIRQB+32,UNIT ;And the unit number
	CLRB	UNIT+1		;As a word
	TST	@#FIRQB+32	;Is the unit number real?
	BNE	2405$		;Yes, so keep it the way it is
	MOV	#-1,UNIT	;Not real, set our funny unit number

.IFF	;RSTS V9.0

	MOV	$CSIBK+C.DEVD+2,R0 ;MOVE ADR OF OUTPUT DEVICE NAME (ASCII) TO R0
	TST	R0		;WAS A DEVICE SPECIFIED?
	BNE	22$		;IF NE, YES
	MOV	#SY,R0		;GET ADDRESS OF SYSTEM MNEMONIC
22$:	MOVB	(R0)+,DEVICE	;MOVE OUTPUT ASCII DEVICE MNEMONIC...
	MOVB	(R0)+,DEVICE+1	;...TO ALUN$ DEVICE OFFSET
	CLR	R1		;INDICATE 0 DEVICE UNIT NUMBER
	CMPB	#':,(R0)	;WAS A DEVICE UNIT NUMBVER SPECIFIEC?
	BEQ	24$		;IF EQ, YES, SO USE UNIT 0
	CALL	$COTB		;CONVERT ASCII DEVICE UNIT NUMBER TO BINARY
24$:	MOV	R1,UNIT		;MOVE UNIT NUMBER TO ALUN$ UNIT OFFSET

.ENDC	;RSTS V9.0

2405$:				;++RSTS V9.0
	DIR$	#ALUN		;DO ALUN$
	BCC	26$		;IF CC, NO ERROR
2410$:				;++RSTS V9.0
	MOV	(PC)+,R1	;LUN ASSIGNMENT ERROR...ILLEGAL DEVICE/VOLUME
	.BYTE	E$R56,S$V2
	MOV	#$CSIBK+C.DEVD,R2 ;POINT R2 TO DEVICE NAME DESCRIPTOR
	JMP	$ERMSG
26$:	GLUN$S	#4,#LUNNFO	;GET LUN INFO FOR OUTPUT DEVICE
	BIT	#FD.REC,LUNNFO+4 ;RECORD ORIENTED DEVICE?
	BEQ	33$		;IF EQ, NO, SO BRANCH AROUND OPENING OF OUT FILE

28$:	MOV	$EXTPT,R0	;POINT R0 TO OUTPUT FDB


	CALL	OPNEXT		;OPEN EXTRACTION (OUTPUT) FILE
	BCS	64$		;IF CS, OPEN FAILURE, REPORT ERROR


	.IF DF	Q$$CMO

	BNE	31$		;IF NE NOUT QIO OUTPUT TO 'CMO'
	MOV	#$CMOLN,R0	;PUT LUN IN R0
	BR	32$		;BRANCH TO DO ATTACH

	.ENDC


31$:	BITB	#FD.TTY,F.RCTL(R0) ;OUTPUTTING TO A TERMINAL DEVICE?
	BEQ	33$		;IF EQ NO
	MOVB	F.LUN(R0),R0	;PUT LUN IN R0
32$:	CALL	$TTYAT		;ATTACH TO TERMINAL
33$:	MOV	#$DMN,R5	;POINT TO MODULE NAME VECTOR
	TST	(R5)		;ANY MODULE NAMES SPECIFIED?
	BNE	39$		;IF NE YES
	MOV	#$MNTHL,R4	;POINT TO MNT ENTRY LISTHEADS
	MOV	(R4)+,R5	;PICK UP POINTER TO FIRST MNT ENTRY
39$:	TST	$DMN		;ANY MODULE NAMES SPECIFIED?
	BEQ	48$		;IF EQ NO
40$:	MOV	(R5)+,R0	;PICK UP NEXT MODULE NAME
	BNE	42$		;IF NE, MORE, SO CONTINUE
41$:	JMP	110$		;NO MORE
42$:	MOV	(R5)+,R1	;
	MOV	#$MNBLK,R2	;POINT TO MNT DESCRIPTOR BLOCK
	CALL	$FINDA		;SEARCH FOR MODULE NAME
	BCC	50$		;IF CC FOUND IT
	MOV	(PC)+,R1	;MODULE DOES NOT EXIST
	.BYTE	E$R18,S$V2	;
	MOV	R5,R2		;POINT TO MISSING MODULE NAME
	CMP	-(R2),-(R2)	;
	;BR	15$
	JMP	15$		;++RSTS V9.0
48$:	MOV	R5,R1		;GET VIRTUAL ADDRESS OF NEXT MNT ENTRY
	BNE	49$		;IF NE THERE IS ONE
	CMP	R4,#$MNTHL+<NU$PAR*2> ;AT END OF LISTHEADS?
	BHIS	41$		;IS HIS, YES
	MOV	(R4)+,R5	;ELSE PICK UP FIRST IN NEXT LIST
	BR	48$		;
49$:	CALL	$CVRL		;POINT TO NEXT ENTRY
	MOV	(R0),R5		;SAVE VIRTUAL LINK TO NEXT
	TST	6(R0)		;LOGICALLY DELETED MODULE?
	BEQ	48$		;IF EQ YES
50$:	MOV	R0,R1		;COPY MNT ENTRY POINTER
	ADD	#8.,R1		;POINT TO END OF MODULE ADDRESS
	MOV	(R1),-(SP)	;SAVE BYTE OFFSET
	MOV	-(R1),-(SP)	;SAVE VBN
	CALL	$RDMH		;READ MODULE HEADER
	BCC	63$		;IF CC NO ERRORS
60$:	MOV	(PC)+,R1	;I/O ERROR ON INPUT FILE
	.BYTE	E$R01,S$V2	;
	MOV	LBRPT+R$NAME,R2	;POINT TO FILE SPEC
	JMP	64$		;REPORT ERROR
63$:	CMPB	#2,L$TYP	;UNIVERSIAL MODULE TYPE?

	BEQ	603$		;++RSTS 7.2 YES SO CHECK THE DETAILS
	JMP	77$		;++RSTS 7.2 NO DON'T WORRY ABOUT REC CONDITIONS
603$:				;++RSTS 7.2

;	BNE	77$		;IF NE, DON'T WORRY ABOUT REC CONDITIONS
	BIT	#FD.REC,LUNNFO+4 ;IS OUTPUT DEVICE RECORD ORIENTED?
	BEQ	68$		;IF EQ, NO, SO BRANCH TO SET UP FOR BLK I/O
	BITB	#^C17,$MHUFA	;WAS INPUT FILE AN RMS FILE?
	BEQ	65$		;IF EQ, NO, FCS, SO CONTINUE
	MOV	(PC)+,R1	;ERROR--CAN'T OUTPUT AN RMS FILE TO REC DEVICE
	.BYTE	E$R40,S$V2
64$:	JMP	$ERMSG
65$:	MOVB	$MHUFA+F.RTYP,F.RTYP(R0) ;MOVE REC TYPE TO INPUT FDB
	MOVB	$MHUFA+F.RATT,F.RATT(R0) ;MOVE REC ATTRIB TO INPUT FDB
	MOV	$MHUFA+F.RSIZ,F.RSIZ(R0) ;MOVE REC SIZE TO INPUT FDB
	MOV	$EXTPT,R0	;POINT R0 TO OUTPUT FDB
	MOVB	$MHUFA+F.RTYP,F.RTYP(R0) ;MOVE REC TYPE TO OUTPUT FDB
	MOVB	$MHUFA+F.RATT,F.RATT(R0) ;MOVE REC ATTRIB TO OUTPUT FDB
	MOV	$MHUFA+F.RSIZ,F.RSIZ(R0) ;MOVE REX SIZE TO OUTPUT FDB

	.IF	DF,R$RSTS	;++RSTS 7.2
	CMPB	#4,$MHUFA	;++RSTS 7.2 IS IT A STREAM FILE?
	BNE	605$		;++RSTS 7.2 NOPE, OK THEN
	MOV	#1002,F.RTYP(R0);++RSTS 7.2 MAKE IT VARIABLE, CC:IMP
605$:				;++RSTS 7.2 REFERENCE LABEL
	.ENDC			;++RSTS 7.2

	MOV	$LBRPT,R0	;POINT R0 TO INPUT FDB
	CALL	.MARK		;GET POSITION OF LIBRARY FILE
	MOV	R2,NXTHD	;COPY VBN
	MOV	R3,NXTHD+2	;COPY BYTE IN BLOCK
	ADD	$MHUFA+F.EFBK+2,NXTHD ;ADD NUM OF BLKS FROM INSERTED FILE
	DEC	NXTHD		;GET VBN OF END OF MODULE IN LIBRARY
	ADD	$MHUFA+F.FFBY,NXTHD+2 ;GET NEXT AVAIL. BYTE OF MODULE IN LIBRARY
	CMP	#1000,NXTHD+2	;END OF BLOCK?
	BNE	67$		;IF NE, NO, SO GO ON
	INC	NXTHD		;CONVERT TO BYTE...
	CLR	NXTHD+2		;...ZERO OF NEXT BLOCK
67$:	TST	(SP)+		;POP OFF THE SAVED (BUT NOW UNNEEDED) INPUT...
	TST	(SP)+		;...VBN AND BYTE OFFSET FROM THE STACK
	BR	80$		;BEGIN EXTRACTING
68$:	MOVB	#R.FIX,F.RTYP(R0) ;FIXED LENGTH GETS FROM LIBRARY
	MOV	#512.,F.RSIZ(R0) ;SET RECORD SIZE TO 512.
	MOV	$EXTPT,R0	;POINT R0 TO OUTPUT FDB
	CLR	F.HIBK(R0)	;CLEAR HIGH BITS OF OUTPUT FILE VBN
	MOV	$MHUFA+F.HIBK+2,F.CNTG(R0) ;INDICATE NUM OF OUTPUT BLKS TO ALLOC

	.IF	DF,R$RSTS	;++RSTS 7.2
	CMPB	#4,$MHUFA	;++RSTS 7.2 IS IT A STREAM FILE?
	BNE	609$		;++RSTS 7.2 NOPE, DON'T ADJUST
	DEC	F.CNTG(R0)	;++RSTS 7.2 ALWAYS POINTS PAST LAST BLOCK
609$:				;++RSTS 7.2 REFERENCE LABEL
	.ENDC			;++RSTS 7.2

	BITB	#CN$TG,$MHAT	;WAS INPUT FILE OF MODULE CONTIGIOUS?
	BNE	75$		;IF NE, YES, SO BRANCH AROUND NEGATION
	NEG	F.CNTG(R0)	;INDICATE NONCONTIGIOUS ALLOCATION
75$:	MOVB	#FD.RWM,F.RACC(R0) ;INDICATE BLK I/O WRITES TO OUTPUT FILE
	FDBK$R	R0,#$RECBF,#$BFSIZ,,#1,$BKSTA ;INITIALIZE BLOCK I/O
	MOV	$MHID,EXTNAM+N.FTYP ;SET OUTPUT FILE DEFAULT TYPE
	CALL	OPNEXT		;OPEN OUTPUT FILE
	BCS	64$		;IF CS, OPEN FAILURE, REPORT ERROR

	.IF	NDF,R$RSTS	;++RSTS 7.2

	MOVB	#4,ATTLST	;INDICATE WRITE USER FILE ATTRIBUTES
	MOV	#IO.WAT,R1	;INDICATE WRITE ATTRIBUTES FUNCTION
	MOV	#2,R2		;R2 = NUMBER OF OPTIONAL PARAMETERS
	MOV	#$WUFAP,R3	;R4 POINTS TO PARAMETERS FOR WRITING ATTRIBS.
	CALL	.XQIO		;WRITE USER FILE ATTRIBUTES

	.IFF			;++RSTS 7.2
	MOV	R5,-(SP)	;++RSTS 7.2 SAVE WORKING REGISTER
	MOV	#$MHUFA,R1	;++RSTS 7.2 COPY POINTER TO PARAMETER LIST
	CMPB	#4,(R1)		;++RSTS 7.2 IS IT A STREAM FILE?
	BEQ	189$		;++RSTS 7.2 THEN DON'T WRITE ATTRIBUTES
	MOV	#11.,R4		;++RSTS 7.2 TRANSFER MAX OF 11.
	MOV	#FIRQB,R5	;++RSTS 7.2 POINT TO FIRQB
	CLR	(R5)+		;++RSTS 7.2 CLEAR UNUSED STUFF
	CLRB	(R5)+		;++RSTS 7.2
	MOVB	#UU.ATR,(R5)+	;++RSTS 7.2 SETUP FOR WRITE ATTRIBUTES
	MOVB	F.LUN(R0),(R5)+	;++RSTS 7.2 SET CHANNEL = LUN
	MOVB	R4,(R5)+	;++RSTS 7.2 NUMBER OF WORDS TO WRITE
187$:	MOV	(R1)+,(R5)+	;++RSTS 7.2 TAKE THEM AWAY
	SOB	R4,187$		;++RSTS 7.2
	.UUO			;++RSTS 7.2
189$:	MOV	(SP)+,R5	;++RSTS 7.2 RESTORE WORKING REGISTER
	.ENDC			;++RSTS 7.2

	BCC	77$		;IF CC, NO ERRORS, SO CONTINUE
	MOV	(PC)+,R1	;I/O ERROR ON OUTPUT FILE
	.BYTE	E$R02,S$V2
	MOV	EXTPT+R$NAME,R2
	JMP	$ERMSG
77$:	MOV	(SP)+,R1	;RETRIEVE MODULE ADDRESS
	MOV	(SP)+,R2	;
	CALL	$NEXT		;COMPUTE ADDRESS OF NEXT MODULE HEADER
	MOV	R1,NXTHD	;SAVE ADDRESS OF NEXT MODULE HEADER
	MOV	R2,NXTHD+2	;
80$:	MOV	$LBRPT,R0	;POINT TO LIBRARY FILE FDB
	CALL	.MARK		;GET CURRENT POSITION IN FILE
	CMP	#1000,R3	;EXACT END OF BLOCK?
	BNE	90$		;IF NE NO
	INC	R2		;CONVERT TO BYTE...
	CLR	R3		;...ZERO OF NEXT BLOCK
90$:	CMP	R2,NXTHD	;REACHED END OF MODULE?

	.IF	NDF,R$RSTS	;++RSTS 7.2

	BNE	100$		;IF NE NO
	CMP	R3,NXTHD+2	;
	BNE	100$		;IF NE, NOT END OF MODULE, CONTINUE TO READ MORE

	.IFF			;++RSTS 7.2
	BLT	100$		;++RSTS 7.2 IF LT NO
	CMP	R3,NXTHD+2	;++RSTS 7.2
	BLT	100$		;++RSTS 7.2 IF LT, NOT END OF MODULE, CONTINUE TO READ MORE
94$:				;++RSTS 7.2 REF LABLE
	.ENDC			;++RSTS 7.2

	CMPB	#2,L$TYP	;UNIVERSAL MODULE TYPE?
	BEQ	95$		;IF EQ, YES
	JMP	39$		;IF NE, NO, SO GO BACK FOR NEXT EXTRACT MODULE
95$:	MOV	$EXTPT,R1	;GET ADDRESS OF EXTRACT FILE FDB
	MOV	#$MHUFA,R2	;R2 = ADDRESS OF MODULE'S USER FILE ATTRIBUTES
	MOV	#7,R3		;COUNT OF USER FILE ATTRIB. DESIRED
97$:	MOV	(R2)+,(R1)+	;MOVE FIRST 7 WORDS OF USER FILE...
	SOB	R3,97$		;...ATTRIB. TO FDB OF EXTRACT FILE
	TST	(R5)		;MORE MODULES TO EXTRACT?
	BEQ	110$		;IF EQ, NO, SO ALL OK, BRANCH TO FINISH UP
	MOV	(PC)+,R1	;DIAG ERROR-- ONLY ONE UNIVERSAL MOD EXTRACTED
	.BYTE	E$R38,S$V0
	CALL	$ERMSG
	BR	110$		;CONTINUE
100$:				;REF LABEL


	.IF NDF	S$$LIB

	GET$	R0,#$RECBF,#$BFSIZ ;READ NEXT RECORD

	.IFF

	GET$S	R0,#$RECBF,#$BFSIZ ;READ NEXT RECORD

	.ENDC


	BCC	102$		;IF CC, NO ERRORS, SO CONTINUE

	.IF	DF,R$RSTS	;++RSTS 7.2
	CMPB	#4,$MHUFA	;++RSTS 7.2 IS IT A STREAM FILE?
	BNE	101$		;++RSTS 7.2 NO, SOMETHING IS WRONG
	CMPB	#IE.EOF,F.ERR(R0) ;++RSTS 7.2 IS THE ERROR END-OF-FILE?
	BEQ	94$		;++RSTS 7.2 YES, MAKE LIKE WE FOUND THE END
101$:				;++RSTS 7.2
	.ENDC			;++RSTS 7.2

	JMP	60$		;JUMP TO REPORT ERROR ON INPUT
102$:	MOV	R0,R1		;COPY LBR FDB POINTER
	MOV	$EXTPT,R0	;POINT TO OUTPUT FILE

; FOR UNIVERSAL MODULES, ININSERT IS DONE BY READ$ ON THE INPUT FILE (512.
; BYTES) AND PUT$ TO THE LIBRARY (F.RSIZ = 512.).  EXTRACT ALSO USES BLOCK AND
; RECORD I/O, BUT IN REVERSE.  GET$ IS USED TO GET 512. BYTES FROM THE LIBRARY
; AND WRITE$ IS USED TO PLACE THESE BYTES IN THE NEWLY CREATED FILE.

	CMPB	#2,L$TYP	;UNIVERSAL MODULE TYPE?
	BNE	103$		;IF NE, NO, SO DO PUT$ (RECORD I/O)
	BIT	#FD.REC,LUNNFO+4 ;IS OUTPUT DEVICE RECORD ORIENTED?

	.IF	NDF,R$RSTS	;++RSTS 7.2

	BNE	103$		;IF NE, YES, SO USE PUT(S) INSTEAD OF WRITE(S)

	.IFF			;++RSTS 7.2
	BEQ	1002$		;++RSTS 7.2 IF NO, USE BLOCK I/O
	CMPB	#4,$MHUFA	;++RSTS 7.2 IS IT A STREAM FILE?
	BNE	103$		;++RSTS 7.2 NO, THEN NOTHING TO WORRY ABOUT
	MOV	R2,-(SP)	;++RSTS 7.2 SAVE IN A TEMPORARY
	INC	(SP)		;++RSTS 7.2 SEE IT WE'RE CLOSE TO END
	CMP	(SP)+,NXTHD	;++RSTS 7.2 ON THE LAST BLOCK?
	BNE	103$		;++RSTS 7.2 NOPE, THEN NOTHING TO WORRY ABOUT
	MOV	$LBRPT,R0	;++RSTS 7.2 POINT TO THE LIBRARY FILE
	CALL	.MARK		;++RSTS 7.2 FIND OUT WHERE WE ARE NOW
	MOV	R0,R1		;++RSTS 7.2 SET THE POINTERS BACK
	MOV	$EXTPT,R0	;++RSTS 7.2 TO THE WAY THE WERE AT FIRST
	CMP	R2,NXTHD	;++RSTS 7.2 ARE WE REALLY PAST THE END?
	BLT	103$		;++RSTS 7.2 NOPE, THEN NOTHING TO WORRY ABOUT
	BR	94$		;++RSTS 7.2 MAKE LIKE WE FOUND THE END
1002$:				;++RSTS 7.2 REFERENCE LABEL
	.ENDC			;++RSTS 7.2

	WRITE$	R0		;WRITE OUT A BLOCK
	BCS	104$		;IF CS, WRITE ERROR, REPORT IT
	WAIT$	R0		;WAIT FOR BLOCK I/O TO FINISH
	BCC	80$		;IF CC, NO SO, BR TO READ NEXT REC (512. BYTES)
	BR	104$		;BRANCH TO REPORT ERROR


103$:	PUT$	R0,F.NRBD+2(R1),F.NRBD(R1) ;OUTPUT RECORD
	BCC	80$		;IF CC NO ERRORS
104$:	MOV	(PC)+,R1	;;ERROR ON OUTPUT FILE
	.BYTE	E$R02,S$V2	;
105$:	MOV	EXTPT+R$NAME,R2	;POINT TO FILE SPEC
	JMP	$ERMSG		;REPORT ERROR
110$:	MOV	$EXTPT,R0	;PICK UP EXTRACT FDB ADDRESS


	.IF DF	Q$$CMO

	BEQ	120$		;IF EQ DETACH 'CMO' DEVICE

	.ENDC


	CLOSE$	R0		;CLOSE LIBRARY FILE
	CLR	$OPNFL		;INDICATE LIBRARY FILE ONLY OPEN FILE
	TSTB	$ATTFG		;TERMINAL ATTACHED?
	BEQ	130$		;IF EQ NO
120$:	CALL	$TTYDT		;DETACH TERMINAL
130$:	RETURN			;




;+
;
; **OPNEXT-OPEN EXTRACTION (OUTPUT) FILE
;
; THIS ROUTINE OPENS THE OUTPUT FILE (THE FILE TO WHICH THE EXTRACTED
; MODULE OF THE LIBRARY IS COPIED).
;
; INPUTS:
;
;	TAILORED SETUP FOR OPEN.
;
; OUTPUTS:
;
;	THE OUTPUT FILE IS OPENED.
;
;-


OPNEXT:	MOVB	#FD.CR,F.RATT(R0) ;SET CARRIAGE CONTROL ATTRIBUTES
	TSTB	L$TYP		;OBJECT MODULE TYPE
	BNE	10$		;IF NE, NO, SO JUST CONTINUE
	CLRB	1(R0)		;CLEAR F.RATT OF EXTRACT FILE FDB
10$:	MOV	#FO.WRT,R1	;INDICATE OPEN FOR WRITE
	MOV	R0,$OPNFL	;INDICATE OPEN FILE

	.IF NDF S$$LIB


	OPEN$	R0,R1		;CREATE OUTPUT FILE


	.IFF


	CALL	$OPEN		;CREATE OUTPUT FILE


	.ENDC


	BCC	30$		;IF CC, NO ERRORS, CONTINUE
	MOV	(PC)+,R1	;OUTPUT FILE OPEN ERROR
	.BYTE	E$R11,S$V2
	MOV	EXTPT+R$NAME,R2	;POINT R2 TO FILE SPEC
30$:	RETURN

	.END
