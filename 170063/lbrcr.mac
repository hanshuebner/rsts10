	.TITLE	LBRCR
	.IDENT	/05/

; COPYRIGHT 1978, DIGITAL EQUIPMENT CORP., MAYNARD, MASS.  01754
; COPYRIGHT 1979, IDGITAL EQUIPMENT CORP., MAYNARD, MASS.  01754
; COPYRIGHT 1975, DIGITAL EQUIPMENT CORP., MAYNARD, MASS.  01754
; COPYRIGHT 1974, DIGITAL EQUIPMENT CORP., MAYNARD, MASS.  01754
; COPYRIGHT 1973, DIGITAL EQUIPMENT CORP., MAYNARD, MASS.  01754
;
;	DEC ASSUMES NO RESPONSIBLIITY FOR THE USE
;	OR RELIABILITY OF ITS SOFTWARE ON EQUIPMENT
;	WHICH IS NOT SUPPLIED BY DEC.
;
; THIS SOFTWARE IS FURNISHED TO PURCHASER UNDER A LICENSE FOR USE
; ON A SINGLE COMPUTER SYSTEM AND CAN BE COPIED (WITH INCLUSION
; OF DEC'S COPYRIGHT NOTICE) ONLY FOR USE IN SUCH SYSTEM, EXCEPT
; AS MAY OTHERWISE BE PROVIDED IN WRITING BY DEC.
;
; THE INFORMATION IN THIS DOCUMENT IS SUBJECT TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT BY DIGITAL
; EQUIPMENT CORPORATION.
;
; VERSION 05
;
; WRITTEN BY:
;	GEORGE W. BERRY
;
; MODIFIED BY:
;	C.A. D'ELIA	10-JUN-74
;	C.A. D'ELIA	02-JUL-74  (VIRTUAL TABLES)
;
;
;	B. ALIMONTI	19-DEC-78
;		BA002	ADDITION OF UNIVERSAL MODULE TYPE
;
;
;
 
;
; MACRO LIBRARY CALLS
;
 
	.MCALL	GTIM$S
 
;
; LOCAL DATA
;

TIME:	.BLKW	8.		;DATE AND TIME VALUES


;+
; **-$CRE-CREATE LIBRARY OUTPUT FILE
;
; THIS ROUTINE ALLOCATES THE INITIAL BLANK EPT, MNT AND
; LIBRARY HEADER RECORDS.
;
;
; INPUT:
;
;	$SIZ=SIZE OF .LBR FILE IN BLOCKS (HIGHEST RELATIVE BLOCK+1)
;	$EPT=EPT ENTRIES ALLOCATED
;	$MNT=MNT ENTRIES ALLOCATED
;	$TYP=TYPE OF LIBRARY
;	$VRSN=VERSION IDENTIFIER OF LIBRARIAN (2 WORDS)
;
; OUTPUTS:
;
;	NONE
;
;
;-
$CRE::	SAVRG			;SAVE R3-R5
	JSR	R5,$CLEAR	;CLEAR FIRST 256 WORDS OF L$BUF
	.WORD	L$BUF
	.WORD	256.
	MOV	$TYP,R5		;GET FILE TYPE
; LOAD TYPE DEPENDENT INFORMATION
	MOVB	R5,L$TYP	;LOAD TYPE
	CMPB	#2,L$TYP	;UNI LIBRARY MODULE?
	BNE	10$		;IF NE, NO, SO DON'T COPY DEFAULT FILETYPE
	MOV	$UNIEX,L$UEX	;COPY (RAD50) UNI LIB DEFAULT INSERT FILETYPE
10$:	MOVB	TY$ES(R5),L$ES	;LOAD EPT ENTRY SIZE
	MOVB	TY$MS(R5),L$MS	;LOAD MNT ENTRY SIZE
	MOV	#EPTBLK,L$ET	;LOAD EPT STARTING BLOCK

	MOVB	#ID$,L$ID	;LOAD ID BYTE
	MOV	$VRSN,L$VER	;LOAD VERSION IDENTIFICATION
	MOV	$VRSN+2,L$VER+2
	MOV	#TIME,R4
	GTIM$S	R4		;GENERATE TIME
	BCS	60$		;OUTPUT TIME ERROR

75$:	MOV	#L$DAT,R5	;STORE AT L$DAT
	MOV	#6,R3		;6 WORDS

55$:	MOV	(R4)+,(R5)+
	SOB	R3,55$
	MOV	#$EPBLK,R1	;POINT TO $EPBLK TO SET IT UP
	MOV	$EPT,R3		;GET NUMBER OF ENTRIES REQUESTED
	CALL	COMP		;COMPUTE NUMBER TO ACTUALLY ALLOCATE
	MOV	#$EPTHL,$EPADR	;SET ADDR OF EPT PARTITION LIST HEADS
	ADD	L$ET,R3		;COMPUTE MNT START BLOCK
	MOV	R3,L$MT		;AND STORE IN LIBRARY HEADER
	MOV	#$MNBLK,R1	;POINT TO $MNBLK TO SET IT UP
	MOV	$MNT,R3		;GET NUMBER OF ENTRIES REQUESTED
	CALL	COMP		;COMPUTE NUMBER TO ACTUALLY ALLOCATE
	MOV	#$MNTHL,$MNADR	;SET ADDR OF MNT PARTITION LIST HEADS
	ADD	L$MT,R3		;COMPUTE FIRST ACTUAL BLOCK OF FILE

	MOV	R3,L$NX		;SET BLOCK FOR FIRST MODULE INSERT

	BIS	#IN$COR!LB$DTY,$SWTCH+2 ;INDICATE THAT THE HEADER, MNT AND EPT
				;ARE SET UP.  WE WILL LET $INS WRITE THEM OUT
				;NOTE-$WTHD ALSO COMPUTES L$LA!
	CALLR	$WTHD		;WRITE HEADER EPT AND MNT AND EXIT

60$:	MOV	(PC)+,R1	;GTIM$S FAILED
	.BYTE	E$R17,S$V2
ERROR:	JMP	$ERMSG		;FATAL ERROR EXIT

ZERR:	MOV	(PC)+,R1	;SIZE ERROR
	.BYTE	E$R13,S$V2
	BR	ERROR		;FATAL ERROR EXIT





;+
; THIS ROUTINE COMPUTES THE NUMBER OF EPT OR MNT ENTRIES
; TO ACTUALLY ALLOCATE (IT FILLS OUT THE TABLE TO THE NEXT
; HIGHEST EVEN BLOCK BOUNDARY).
;
; INPUTS:
;
;	R1 = ADDRESS OF $EPBLK OR $MNBLK
;	R3 = # OF ENTRIES REQUESTED
;	R5 = ADDRESS OF ENTRY SIZE IN L$BUF
;
; OUTPUTS:
;
;	R5 = R5+8.
;	R3 = # OF 256. WORD BLOCKS USED
;	$EPBLK OR $MNBLK IS SET UP PROPERLY
;
;-

COMP:	CLR	R4		;INITIALIZE R4
	MOVB	(R5),R0		;GET ENTRY SIZE (L$?S)
	MOV	R0,(R1)+	;SAVE ENTRY SIZE IN DESCRIPTOR BLOCK
	TST	(R1)+		;SKIP ADDR OF PARTITION LIST HEADS
	MUL	R0,R3		;CALC # OF WORDS REQUIRED
	BCS	ZERR		;ERROR IF OUT OF RANGE (>= 32768.)
	TST	R3		;NO DESCRIPTOR BLOCKS TO BE ALLOCATED?
	BEQ	10$		;SKIP TO FILL IN ENTRIES IF SO
	DEC	R3		;ROUND UP TO NEAREST 256 WORD BLOCK
	BIS	#777,R3		;ROUND TO NEXT HIGHER BLOCK
	INC	R3

	MOV	R5,-(SP)	;SAVE R5
	MOV	R3,R5		;PUT LOW ORDER DIVIDEND IN R5
	DIV	R0,R4		;COMPUTE # OF ENTRIES
	MOV	(SP)+,R5	;RESTORE R5
10$:	ADD	#4,R5
	MOV	R4,(R5)+	;STORE ENTRIES ALLOCATED (L$?I)
	MOV	R4,(R5)+	;STORE ENTRIES AVAILABLE (L$?A)
	MOV	R4,(R1)		;SAVE TABLE ALLOCN IN DESCRIPTOR BLOCK
	SWAB	R3
	ASR	R3		;R3/512. = # OF DISK BLOCKS NEEDED
	RETURN


;
	.END
