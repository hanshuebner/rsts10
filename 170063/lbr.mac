	.TITLE	LBR
	.IDENT	/06.01/
;
; COPYRIGHT (C) 1985
; DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ONLY ON A
; SINGLE COMPUTER SYSTEM AND MAY  BE  COPIED   ONLY  WITH  THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE,  OR
; ANY OTHER COPIES THEREOF, MAY NOT BE PROVIDED  OR  OTHERWISE
; MADE AVAILABLE TO ANY OTHER PERSON   EXCEPT FOR  USE ON SUCH
; SYSTEM AND TO ONE WHO AGREES TO THESE LICENSE  TERMS.  TITLE
; TO AND OWNERSHIP OF THE SOFTWARE SHALL AT ALL  TIMES  REMAIN
; IN DEC.
;
; THE INFORMATION IN THIS DOCUMENT IS SUBJECT TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT BY DIGITAL
; EQUIPMENT CORPORATION.
;
; DEC ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF
; ITS SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DEC.
;
; THIS SOFTWARE IS FURNISHED TO PURCHASER UNDER A LICENSE FOR USE
; ON A SINGLE COMPUTER SYSTEM AND CAN BE COPIED (WITH INCLUSION
; OF DEC'S COPYRIGHT NOTICE) ONLY FOR USE IN SUCH SYSTEM, EXCEPT
; AS MAY OTHERWISE BE PROVIDED IN WRITING BY DEC.
;
; THE INFORMATION IN THIS DOCUMENT IS SUBJECT TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT BY DIGITAL
; EQUIPMENT CORPORATION.
;
; VERSION 06.01
;
; WRITTEN BY:
;	GEORGE W. BERRY
;
; MODIFIED BY:
;	C.A. D'ELIA	16-JUN-74
;	C.A. D'ELIA	24-JUN-74  (VIRTUAL TABLES)
;	THOMAS J. MILLER 01-NOV-74  (MACRO LIBRARIES)
;				    (/DF SWITCH)
;				    (/SZ SWITCH)
;			 18-MAR-75  (FIX COMPRESS BUG)
;			 20-JUN-75  (CRAM END OF FILE IN FDB)
;			 16-JUL-75  (USE GTSK FOR GETTING LBR SIZE)
;
;	T. J. MILLER 11-JAN-76
;
;		TM001 -- ADDITION OF EXTRACT SWITCH (/EX).
;
;	T. J. MILLER 22-JAN-76
;
;		TM002 -- ADDITION OF ENTRY POINT SWITCH (/EP).
;
;	C.A. D'ELIA	28-SEP-77
;
;		CD046 -- ADD EXIT-WITH-STATUS SUPPORT.
; 
;	B. ALIMONTI	12-OCT-78
; 
;		BA002 -- ADDITION OF UNIVERSAL MODULE TYPE
;
;
;	P. K. M. WEISS	23-OCT-84
;
;		PKW073 -- ADD LOGICAL NAME SUPPORT
;
;
; LIBRARIAN ROOT SEGMENT.
;


;
; LIBRARIAN VERSION IDENTIFICATION
;

	.MACRO	VERSN	VER
	.IDENT	/VER/
$VRSN::	.RAD50	/VER/
	.IIF EQ	<.-2-$VRSN>,	.WORD	0
	.IIF B	<VER>,	.ERROR		;LBR VERSION MUST BE SPECIFIED
	.ENDM


	VERSN	<06.00>
                                                                                ;**-1
;
; GLOBAL AND LOCAL DATA
;

SPSAV:	.BLKW	1		;SAVED INITIAL STACK POINTER
$ERSTS::.BLKW	1		;LOCATION TO ACCUMULATE EXIT STATUS

;
; MACRO LIBRARY CALLS
;

	.MCALL	EXIT$S,FINIT$


	.IF DF	S$$LIB

	.MCALL	OFNB$,FDOFF$
	FDOFF$	DEF$L

	.ENDC


	.IF NDF	Q$$CMO

	.MCALL	OPEN$W,CLOSE$

	.ENDC


;+
;
; **-$LBR- ENTRY TO RSX11D/M LIBRARIAN
;
;-

$LBR::	FINIT$			;INITIALIZE FCS


	.IF NDF	Q$$CMO


	OPEN$W	$CMOPT		;OPEN COMMAND OUTPUT FILE
	BCS	$QUIT		;ABORT IF ERROR


	.ENDC


	MOV	SP,SPSAV	;SAVE FOR REENTRY
	MOV	#-1,$ERSTS	;INITIALIZE EXIT STATUS WITH ILLEGAL VALUE

$RSTRT::MOV	SPSAV,SP	;RESTART ENTRY
	CALL	$INIT		;INIT LBR AND GET COMMAND LINE
	CALL	$DECD		;GET OPTIONS
	BIT	#CR$SW,(R5)	;/CR?
	BEQ	10$
	CALL	$CRE

10$:	BIT	#DL$SW,(R5)	;/DE?
	BEQ	15$
	CALL	$DEL
 
15$:	BIT	#MH$SW,(R5)		;/MH?
	BEQ	20$
	CALL	$MOD

20$:	BIT	#IN$SW,(R5)	;/IN?
	BEQ	30$
	CALL	$INS

30$:	BIT	#CO$SW,(R5)	;/CO?
	BEQ	40$
	CALL	$CMP		;PERFORM FILE COMPRESS

40$:	BIT	#EX$SW,(R5)	;/EX?                                           ; TM001
	BEQ	50$                                                             ; TM001
	CALL	$EXT		;PERFORM MODULE EXTRACTION                      ; TM001
                                                                                ; TM001
50$:	JMP	$LISCD		;CHECK FOR LISTING AND ...                      ; TM001
				;... CLOSE LIBRARY FILE                         ;**-1



$QUIT::


	.IF NDF	Q$$CMO


	CLOSE$	$CMOPT		;CLOSE COMMAND OUTPUT FILE


	.ENDC


	MOV	$ERSTS,R0	;GET EXIT STATUS
	BPL	100$		;IF PL STATUS SET DURING PROCESSING
	MOV	#EX$SUC,R0	;ELSE, NO ERRORS -- SET SUCCESS
100$:	JMP	$EXST		;EXIT, WITH STATUS



;+
;
; THIS ROUTINE CLEARS A DESIGNATED AREA.
;
; CALLED BY:
;
;	JSR	R5,$CLEAR
;	.WORD	START-OF-AREA-TO-CLEAR
;	.WORD	NUMBER-OF-WORDS-TO-CLEAR
;
;-
$CLEAR::MOV	(R5)+,R1	;GET START OF AREA
	MOV	(R5)+,R2	;GET NUMBER OF WORDS
10$:	CLR	(R1)+		;CLEAR DESIGNATED AREA
	SOB	R2,10$		;
	RTS	R5


	.IF DF	S$$LIB


;+
;
; *-$OPEN-*-PARSE FILENAME AND OPEN FILE
;
; INPUTS:
;	R0=ADDRESS OF FDB
;	R1=FILE OPEN FUNCTION, E.G.  #FO.WRT , ETC
;
;-

$OPEN::	SAVRG			;SAVE R3-R5
	MOV	R1,R4		;COPY FUNCTION INTO R4
	MOV	R0,R1		;POINT R1 TO THE FILE NAME BLOCK
	ADD	#F.FNB,R1	;
	MOV	F.DSPT(R0),R2	;POINT R2 TO FILE DESCRIPTOR
	MOV	F.DFNB(R0),R3	;POINT R3 TO DEFAULT FILENAME BLOCK
	BISB	#FL.AEX,F.FLG(R0) ;DON'T EXPAND THE FILESPEC AGAIN
	CALL	.PARSE		;PARSE FILENAME, CREATING FILENAME BLK
	BCS	10$		;SKIP ON ERROR
	OFNB$	R0,R4		;OPEN FILE (WITH DESIRED FUNCTION)
10$:	RETURN			;


	.ENDC


	.IF NDF	R$$EIS


;+
;
; *-$LMUL1-*-MULTIPLY WITH A SINGLE WORD RESULT
; *-$LMUL2-*-MULTIPLY WITH A DOUBLE WORD RESULT
; *-$LDIV-*-DIVIDE
;
; $LMUL1 PERFORMS AS 'MUL  R0,R3'
; $LMUL2 PERFORMS AS 'MUL  R0,R4'
; $LDIV  PERFORMS AS 'DIV  R0,R4'
;
;-

$LMUL1::MOV	R4,-(SP)	;SAVE R4 AND R5
	MOV	R5,-(SP)	;
	MOV	R3,R4		;COPY MULTIPLICAND INTO R4
	CALL	$LMUL2		;PERFORM 2-WORD RESULT MULTIPLY
	MOV	R5,R3		;PUT SINGLE PRECISION ANSWER IN R3
	MOV	(SP)+,R5	;RESTORE R5 AND R4
	MOV	(SP)+,R4	;
	RETURN

$LMUL2::MOV	R0,-(SP)	;SAVE R0
	MOV	R1,-(SP)	;SAVE R1
	MOV	R4,-(SP)	;COPY MULTIPLICAND INTO STACK
	CLR	R1		;INIT HIGH WORD OF MULTIPLIER
	CLR	R4		;INITIALIZE THE DOUBLE WORD RESULT
	CLR	R5		;
10$:	TST	(SP)		;TEST REMAINDER OF MULTIPLICAND
	BEQ	30$		;IF ZERO, WE'RE DONE
	ROR	(SP)		;DIVIDE MULTIPLICAND BY TWO
	BCC	20$		;SKIP IF BIT-0 WAS ZERO
	ADD	R0,R5		;ELSE, ADD THE MULTIPLIER ...
	ADC	R4		;... TO THE DOUBLE WORD RESULT
	ADD	R1,R4
20$:	ASL	R0		;DOUBLE THE MULTIPLIER
	ROL	R1		;...DOUBLE PRECISION
	BR	10$		;AND REPEAT
30$:	TST	(SP)+		;CLEAN THE STACK
	MOV	(SP)+,R1	;RESTORE R1
	MOV	(SP)+,R0	;RESTORE R0
	TST	R4		;EXAMINE HIGH ORDER OF RESULT
	BNE	40$		;IF NOT NULL, SET CARRY
	TST	R5		;ELSE, EXAMINE LOW ORDER OF RESULT
	BPL	50$		;IF NOT NEGATIVE, LEAVE
40$:	SEC			;SET CARRY
50$:	RETURN


$LDIV::	MOV	R3,-(SP)	;SAVE R3
	MOV	#32.,-(SP)	;DIVIDEND HAS 32. BITS
	CLR	R3		;INITIALIZE THE REMAINDER
10$:	ASL	R5		;SHIFT THE REMAINING DIVIDEND ...
	ROL	R4		;... LEFT AND INTO THE REMAINDER
	ROL	R3		;
	CMP	R3,R0		;COMPARE REMAINDER W/ DIVISOR
	BLO	20$		;SKIP IF IT'S LESS
	SUB	R0,R3		;SUBTRACT DIVISOR FROM REMAINDER
	INC	R5		;AND INCREMENT THE QUOTIENT
20$:	DEC	(SP)		;DECREMENT ITERATION COUNTER
	BNE	10$		;CONTINUE UNTIL IT'S ZERO
	TST	(SP)+		;PURGE ITERATION COUNT FROM STACK
	MOV	R5,R4		;PUT QUOTIENT IN R4
	MOV	R3,R5		;PUT REMAINDER IN R5
	MOV	(SP)+,R3	;RESTORE R3
	RETURN


	.ENDC


;+
; **-$NWLNK-*-INSERT ELEMENT INTO VIRTUAL MEMORY TABLE
;
; THIS ROUTINE INSERTS AN ELEMENT INTO A LINKED-LIST VIRTUAL MEMORY
; TABLE.  IT UNLOCKS AND MARKS DIRTY THE PAGE CONTAINING THE LINK OF
;  THE CURRENT TABLE ENTRY, IF NECESSARY.  FINALLY, THE NEWLY INSERTED
; ENTRY BECOMES THE CURRENT ENTRY.
;
; INPUTS:
;	R0 = ADDRESS OF NEW ENTRY
;	R1 = VIRTUAL MEMORY LOCATION OF NEW ENTRY
;	R4 = ADDRESS OF CURRENT ENTRY
;	R5 = VIRTUAL MEMORY LOCATION OF CURRENT ENTRY
;
; OUTPUTS:
;	R0 & R1 ARE LOST
;	R4 = ADDRESS OF NEW CURRENT ENTRY
;	R5 = VIRTUAL MEMORY LOCATION OF NEW CURRENT ENTRY
;
;-

$NWLNK::MOV	(R4),(R0)	;LINK NEXT ELEMENT TO NEW ENTRY
	MOV	R1,(R4)		;LINK NEW ENTRY TO CURRENT ELEMENT
	MOV	R5,-(SP)	;SAVE VIRTUAL LOCATION OF CURRENT ELE
	MOV	R0,R4		;NEW ENTRY BECOMES CURRENT ELEMENT ...
	MOV	R1,R5		;... BY STORING ITS ADDR AND V.L.
	MOV	(SP)+,R1	;PUT VIRTUAL LOCN OF OLD ELE IN R1
	BEQ	10$		;BRANCH IF IT WAS A LIST HEAD
	CALL	$WRMPG		;ELSE, MARK DIRTY AND ...
	CALL	$UNLPG		;... UNLOCK PAGE WITH OLD LINK
10$:	RETURN


	.END	$LBR


