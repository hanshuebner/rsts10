	.TITLE	LBRLI
	.IDENT	/05.02/

;
; COPYRIGHT 1981, DIGITAL EQUIPMENT CORP., MAYYNARD, MASS.  01754
; COPYRIGHT 1979, DIGITAL EQUIPMENT CORP., MAYNARD, MASS.  01754
; COPYRIGHT 1975, DIGITAL EQUIPMENT CORP., MAYNARD, MASS.  01754
; COPYRIGHT 1974, DIGITAL EQUIPMENT CORP., MAYNARD, MASS.  01754
; COPYRIGHT 1973, DIGITAL EQUIPMENT CORP., MAYNARD, MASS.  01754
;
;	DEC ASSUMES NO RESPONSIBLIITY FOR THE USE
;	OR RELIABILITY OF ITS SOFTWARE ON EQUIPMENT
;	WHICH IS NOT SUPPLIED BY DEC.
;
; THIS SOFTWARE IS FURNISHED TO PURCHASER UNDER A LICENSE FOR USE
; ON A SINGLE COMPUTER SYSTEM AND CAN BE COPIED (WITH INCLUSION
; OF DEC'S COPYRIGHT NOTICE) ONLY FOR USE IN SUCH SYSTEM, EXCEPT
; AS MAY OTHERWISE BE PROVIDED IN WRITING BY DEC.
;
; THE INFORMATION IN THIS DOCUMENT IS SUBJECT TO CHANGE WITHOUT
; NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT BY DIGITAL
; EQUIPMENT CORPORATION.
;
; ALL RIGHTS RESERVED
;
; VERSION 05.02
;
; WRITTEN BY:
;	GEORGE W. BERRY
;
; PREVIOUSLY MODIFIED BY:
;
;	C. A. D'ELIA
;	T. J. MILLER
;	J.    MATTHEWS
;	B.    ALIMONTI
;
; MODIFIED BY:
;
;	D. R. DONCHIN	19-JAN-81
;		DD082 -- CHANGE MESSAGES TO UPPER/LOWER CASE
;
;	J. L. GALLANT	9-FEB-81
;		JG002 -- INSERT TAB BEFORE IDENT MESSAGE TO PREVENT STAGGERING
;			 IDENT MESSAGES WHEN DATE IS LESS THAN 9 CHARACTERS
;			 WHEN USING /FU SWITCH.
;
 
;
; MACRO CALLS
;
 
	.MCALL	FCSBT$
	FCSBT$
	.MCALL	FDOFF$
	FDOFF$	DEF$L
	.MCALL	FILIO$
	FILIO$
 
	.MCALL	CLOSE$,PRINT$,QIO$,DIR$
 
 
	.IF NDF	S$$LIB
 
	.MCALL	OPEN$W
 
	.ENDC
 
 
;
; LOCAL DATA
;
 
LINSIZ=8.			;NUMBER OF EP'S LISTED PER LINE
 
SAVR3:	.BLKW	1		;NEEDED TO SAVE R3 DURING EPT AND UFA LISTING
NXTMNT:	.BLKW	1		;VIRTUAL LOCN OF NEXT MNT ENTRY
TYPASC:				;TABLE OF LIBRARY TYPE MESSAGE POINTERS
	.WORD	OBJSIZ
	.WORD	OBJSTR
	.WORD	MACSIZ
	.WORD	MACSTR
	.WORD	UNVSIZ
	.WORD	UNVSTR
 
 
 
;
; FORMAT STRINGS FOR DIRECTORY LISTING
;
	.NLIST	BEX
	.ENABL	LC
HD1:	.ASCIZ	/%F%2NDirectory of file %X%N/
HD2AA:	.ASCIZ	/%VA/		;LIBRARY TYPE MESSAGE
HD2:	.ASCIZ	/ library created by:  LBR V%2R%N/
HD2A:	.ASCIZ	/Last insert occurred %Y at %3Z%N/
CRLF	=.-3

HD3:	.ASCIZ	/MNT entries allocated: %D; Available: %D%N/
HD3X	=HD3+2
HD4:	.ASCIZ	/EP/
HD5:	.ASCIZ	/File space available: /
HD6:	.ASCIZ	/Recoverable deleted space: /
HD6X:	.ASCIZ	/ words%N/
HD7:	.ASCIZ	/%2N/
HD10:	.ASCIZ	/UNI LIB DEF filetype:%R%N/
MN1:	.ASCIZ	/%N** Module:/
MN1X:	.ASCIZ	/%2R/
MN2:	.ASCIZ	/  Size:/
MN3:	.ASCIZ	/  Inserted:%Y/
MN4P:	.ASCIZ	/ 	Ident:%R/
MN4P2:	.ASCIZ	/%R%N/
MN4P3:	.ASCII	/%P/
MN4A:	.ASCIZ	/%N/
ATRIB1:	.ASCIZ	<11><11>/Attrib:/
ATRIB2:	.ASCIZ	/SS/
ATRIB3:	.ASCIZ	/Contiguous/
ATRIB4:	.ASCIZ	/, /
MN4:	.ASCIZ	/  %2R/
OP:	.ASCIZ	<11>/OP info:%2R   %2R   %2R   %2R%N/
UFA1:	.ASCII	<11>/User file attrib:/
UFA2:	.ASCIZ	/%P %P %P %P%N/
UFA3:	.ASCIZ	<11><11><11>/%S/
OBJSTR:	.ASCII	/Object module/
OBJSIZ=	.-OBJSTR
MACSTR:	.ASCII	/Macro/
MACSIZ=	.-MACSTR
UNVSTR:	.ASCII	/Universal/
UNVSIZ=	.-UNVSTR
 
 
	.EVEN
	.NLIST	BEX
 
 
;+
;**-$LIS-LIST DIRECTORY FUNCTION
;
; THIS ROUTINE OUTPUTS A LIBRARY DIRECTORY LISTING
; ON THE SPECIFIED LISTING OUTPUT DEVICE. THERE
; ARE THREE FORMS OF THIS DIRECTORY DEPENDING ON
; WHETHER /EP AND/OR /FU ARE GIVEN, TO INDICATE
; THAT ENTRY POINTS AND FULL MODULE IDENTIFICATION
; ARE TO BE LISTED.
;
; INPUTS:
;
;	NONE
;
; OUTPUTS:
;
;	NONE
;
;-
$LIS::	SAVRG			;SAVE R3-R5
	MOV	#FO.RD,R1	;INDICATE OPEN FOR READ
	CALL	$RDHD		;READ LIBRARY HEADER, EPT, & MNT
	MOV	$LISPT,R0	;OUTPUT ON LISTING DEVICE
	CALL	LISOUT		;INIT OUTPUT CO-ROUTINE
;****	OUTPUT HEADER
	CMP	#LISPT,R0	;CHECK FOR LIST FILE SPECIFIED
	BNE	1$		;BRANCH IF NOT
 
 
	.IF NDF	S$$LIB
 
 
	OPEN$W	R0		;OPEN LISTING FILE
 
	.IFF
 
	MOV	#FO.WRT,R1	;SPECIFY OPEN FOR WRITE
	CALL	$OPEN		;PARSE FILENAME AND OPEN FILE
 
 
	.ENDC
 
 
	BCC	1$		;BRANCH IF OPEN WAS OK
	MOV	(PC)+,R1	;OPEN FAILURE ON FILE
	.BYTE	E$R11,S$V2
	MOV	R$NAME(R0),R2
	JMP	$ERMSG		;FATAL ERROR EXIT

1$:	MOV	#HD1,R1		;GET ADDRESS OF FORMAT STRING
	MOV	R0,$OPNFL	;INDICATE FILE OPEN ON 'LISPT'
 
 
	.IF DF	Q$$CMO
 
	BNE	3$		;SKIP IF NOT QIO OUTPUT TO 'CMO'
	MOV	#$CMOLN,R0	;PUT LUN IN R0
	BR	5$		;BRANCH TO DO THE ATTACH
 
	.ENDC
 
 
3$:	BITB	#FD.TTY,F.RCTL(R0) ;OUTPUTTING TO A TERMINAL DEVICE?
	BEQ	10$		;BRANCH IF NOT
	MOVB	F.LUN(R0),R0	;PUT LUN IN R0
5$:	CALL	$TTYAT		;ATTACH THE TELETYPE
	TST	(R1)+		;DON'T OUTPUT FORM-FEED
10$:	MOV	$LBRPT,R0	;OUTPUT LIBRARY FILENAME
	MOV	R$NAME(R0),R2	;GET FILE NAME POINTER
	CALL	@(SP)+		;CONVERT + OUTPUT
	MOV	#HD2AA,R1	;POINT TO LIBRARY TYPE MESSAGE
	MOVB	L$TYP,R2	;PICK UP LIBRARY TYPE
	ASL	R2		;CONVERT TO DOUBLE WORD OFFSET
	ASL	R2
	ADD	#TYPASC,R2	;POINT INTO TABEL
	CALL	@(SP)+		;PRINT IT
	MOV	#L$VER,R2
	MOV	#HD2,R1		;"CREATED BY LBR VXXX"
	CALL	@(SP)+		;CONVERT AND OUTPUT
	MOV	#HD2A,R1	;"LAST INSERT OCCURRED"
	MOV	#L$DAT,R2
	CALL	@(SP)+		;CONVERT AND OUTPUT
	MOV	#L$MI,R2
	MOV	#HD3,R1		;"MNT'S ALLOCATED"
	CALL	@(SP)+		;CONVERT AND OUTPUT
	MOV	#HD4,R1		;"EPT'S ALLOCATED"
	CALL	@(SP)+		;CONVERT AND OUTPUT
	MOV	#HD3X,R1
	MOV	#L$EI,R2
	CALL	@(SP)+
	MOV	#HD5,R1		;FILE SPACE AVAILABLE
	CALL	@(SP)+
	MOV	#L$LA,R0	;GET ADDRESS OF SPACE AVAILABLE
	CALL	WORDS
	MOV	#HD6X,R1
	CALL	@(SP)+		;OUTPUT END OF LINE
	MOV	#L$LD,R0	;OUTPUT LOGICALLY DELETED SPACE
	TST	(R0)+		;ONLY IF NON-ZERO
	BNE	2$
	TST	(R0)
	BEQ	20$
2$:	MOV	#HD6,R1
	CALL	@(SP)+
	MOV	#L$LD,R0	;OUTPUT NON-ZERO DELETED SPACE
	CALL	WORDS
	MOV	#HD6X,R1
	CALL	@(SP)+		;OUTPUT IT
20$:	CMPB	#2,L$TYP	;UNI MODULE TYPE?
	BNE	205$		;IF NE, NO, SO DON'T OUTPUT DEF INSERT FILETYPE
	MOV	#HD10,R1	;POINT R1 TO FILETYPE OUTPUT FORMAT
	MOV	#L$UEX,R2	;POINT R2 TO UNI DEF INSERT FILETYPE
	CALL	@(SP)+		;OUTPUT FILE FILETYPE MESSAGE
205$:	MOV	#CRLF,R1	;END OF HEADER
	CALL	@(SP)+
;****	END OF HEADER
	CLR	R3		;INIT PARTITION LIST OFFSET TO ZERO
21$:	MOV	$MNADR,R4	;GET ADDR OF MNT PARTITION LIST HEADS
	ADD	R3,R4		;POINT R4 TO PROPER LIST HEAD
22$:	MOV	(R4),R1		;PUT VIRTUAL LOCN OF NEXT MNT ENTRY IN R1
	BNE	23$		;BRANCH IF NOT AT END OF LIST
	ADD	#2,R3		;UPDATE THE LIST OFFSET
	CMP	R3,#<NU$PAR*2>-2  ;COMPARE WITH MAXIMUM
	BLE	21$		;IF LE, GET ENTRIES FROM NEXT PARTITION LIST
	JMP	90$		;ELSE, CONTINUE IF AT END OF THE TABLE
23$:	CALL	$CVRL		;OBTAIN REAL ADDR OF THE MNT ENTRY
	MOV	R0,R4		;COPY IT INTO R4
	MOV	(R0),NXTMNT	;SAVE VIRTUAL LOCN OF NEXT MNT ENTRY
	TST	6(R0)		;EXAMINE ASSOCIATED MODULE HEADER ADDR
	BEQ	22$		;BRANCH IF SYMBOL IS LOGICALLY DELETED
	BIT	#LE$SW,$SWTCH	;EPT LISTING DESIRED?
	BEQ	24$		;BRANCH IF NOT
	MOV	#MN1,R1		;IF TRUE, PROVIDE '** MODULE:'
	CALL	@(SP)+
 
24$:	MOV	#MN1X,R1
	MOV	R4,R2		;PUT ADDRESS OF MNT ENTRY IN R2
	TST	(R2)+		;SKIP PAST THE LINK--PNT TO MODULE NAME
	CALL	@(SP)+		;OUTPUT MODULE NAME
	BIT	#FU$SW,$SWTCH	;FULL MODULE ID NEEDED?
	BEQ	30$		;BRANCH IF NOT
	MOV	R4,R1		;PUT ADDR OF MNT ENTRY IN R1
	ADD	#6,R1		;POINT R1 TO MODULE HEADER ADDR
	CALL	$RDMH		;READ THE MODULE HEADER
	BCC	25$
	MOV	(PC)+,R1	;CAN'T READ MODULE HEADER
	.BYTE	E$R10,S$V2
	MOV	R$NAME(R0),R2	;PNT R2 TO FILE NAME
	JMP	$ERMSG		;FATAL ERROR EXIT

25$:	MOV	#MN2,R1
	CALL	@(SP)+
	MOV	#$MOSZ,R0
	CALL	WORDS		;OUTPUT MODULE SIZE
;****	OUTPUT TYPE DEPENDENT INFORMATION
	MOV	#MN3,R1
	MOV	#$MHDA,R2	;POINT TO ARGUMENTS
	CALL	@(SP)+
	MOV	#MN4A,R1	;POINT R1 TO CRLF
	CMPB	#1,L$TYP	;MACRO DEF MODULE TYPE?
	BEQ	26$		;IF EQ, YES, SO DON'T OUTPUT AN IDENT
	MOV	#MN4P,R1	;POINT R1 TO IDENT LABEL--1ST FORMAT PART
	CALL	@(SP)+		;OUTPUT IT
	MOV	#MN4P2,R1	;POINT R1 TO OBJ MODULE IDENT FORMAT
	TSTB	L$TYP		;OBJ MODULE TYPE
	BEQ	26$		;IF EQ, YES, SO BRANCH TO OUTPUT IT
	MOV	#MN4P3,R1	;POINT R1 TO UNI MODULE IDENT FORMAT
26$:	CALL	@(SP)+		;OUTPUT IT
	TSTB	$MHAT		;CHECK MODULE ATTRIBUTES
	BEQ	285$		;BRANCH IF NONE PRESENT
	MOV	#ATRIB1,R1	;POINT R1 TO ATTRIBUTE LABEL
	CALL	@(SP)+		;OUTPUT ATTRIBUTE LABEL
	BITB	#SS$,$MHAT	;SELECTIVE SEARCH ATTRIBUTE INDICATED?
	BEQ	27$		;IF EQ, NO, SO CHECK CONTIGIOUS ATTRIB
	MOV	#ATRIB2,R1	;POINT R1 TO SELECTIVE SEARCH MSG
	CALL	@(SP)+		;OUTPUT SELECTIVE SEARCH MSG
	BITB	#CN$TG,$MHAT	;CONTIGIOUS ATTRIBUTE INDICATED?
	BEQ	28$		;IF EQ, NO
	MOV	#ATRIB4,R1	;POINT R1 TO ', '
	CALL	@(SP)+		;OUTPUT  ', '
27$:	MOV	#ATRIB3,R1	;POINT R1 TO CONTIGIOUS MSG
	CALL	@(SP)+		;OUTPUT CONTIGIOUS MSG
28$:	MOV	#MN4A,R1	;POINT R1 TO CR, LF
	CALL	@(SP)+		;OUTPUT CR, LF
285$:	CMPB	#2,L$TYP	;UNIVERSAL MODULE TYPE?
	BNE	30$		;IF NE, CONTINUE
	MOV	#OP,R1		;POINT R1 TO OP INFO OUTPUT FORMAT
	MOV	#$MHOP1,R2	;POINT R2 TO BEGINNING OF OP INFO (BUFFER)
	CALL	@(SP)+		;OUTPUT OP INFO
	MOV	#UFA1,R1	;POINT R1 TO USER FILE ATTRIB LABEL FORMAT
	MOV	#$MHUFA,R5	;COPY ADDRESS OF USER FILE ATTRIB BUFFER
	MOV	R5,R2		;MOV ADDRESS OF UFA TO R2
	CALL	@(SP)+		;OUTPUT 4 ATTRIBUTES
	MOV	R3,SAVR3	;SAVE R3
	MOV	#3,R3		;R3 = COUNT FOR UFA OUTPUTTING
29$:	MOV	#UFA3,R1	;POINT R1 TO TABS AND SPACE FORMAT
	CALL	@(SP)+		;OUTPUT TABS AND SPACE
	MOV	#UFA2,R1	;POINT R1 TO UFA FORMAT
	ADD	#10,R5		;PT. TO BEGINNING ADDR OF NEXT SET OF 4 ATTRIBS.
	MOV	R5,R2		;MOVE ADDRESS TO R2
	CALL	@(SP)+		;OUTPUT 4 ATTRIBUTES
	SOB	R3,29$		;BRANCH BACK IF MORE UFA
	MOV	SAVR3,R3	;RESTORE R3
30$:	MOV	#CRLF,R1
	CALL	@(SP)+
;****
	BIT	#LE$SW,$SWTCH	;LIST ENTRY POINTS?
	BNE	33$		;IF NE, YES
	JMP	22$		;NO, SO GET VIRTUAL LOC OF NEXT ENTRY
33$:	MOV	#CRLF,R1
	CALL	@(SP)+		;PUT OUT A BLANK LINE BEFORE EPT
	MOV	#$EPBLK,R2	;GET PARAMETER BLOCK FOR ASSOCIATIVE SEARCH
	MOV	6(R4),R0	;PUT MODULE HEADER ADDR (VBN ...
	MOV	8.(R4),R1	;... AND OFFSET) IN R0-R1
	CALL	$FINDC		;START CONTINUOUS ASSOCIATIVE SEARCH
	BCS	50$		;GET NEXT MNT IF NOTHING FOUND
	MOV	R3,SAVR3	;SAVE R3
	CLR	R3		;R3 KEEPS NUMBER OF EPT'S IN OUTPUT LINE
35$:	MOV	#MN4,R1		;OUTPUT NAME
	MOV	R0,R2		;COPY ADDR OF EPT ENTRY INTO R2
	TST	(R2)+		;SKIP PAST THE LINK WORD
	CALL	@(SP)+		;OUTPUT EPT NAME
	INC	R3		;INCREMENT EP'S PER LINE COUNT
	CMP	#LINSIZ,R3	;CHECK FOR FULL LINE
	BNE	38$		;BRANCH IF NOT
	MOV	#CRLF,R1	;OUTPUT THE LINE
	CALL	@(SP)+
	CLR	R3		;AND CLEAR FLAG
38$:	CALL	$FINDN		;CONTINUE SEARCH
	BCC	35$		;UNTIL NO MORE FOUND
	MOV	#HD7,R1		;OUTPUT TWO CRLF'S
	TST	R3		;UNLESS WE'RE ALREADY AT THE
				;START OF A LINE
	BNE	40$
	MOV	#CRLF,R1
40$:	CALL	@(SP)+		;OUTPUT A CR-LF
	MOV	SAVR3,R3	;RESTORE R3
50$:	MOV	#NXTMNT,R4	;PNT R4 TO VIRTUAL LOCN OF NEXT MNT ENTRY
	JMP	22$		;CONTINUE WITH NEXT MNT ENTRY
 
90$:	MOV	#HD7,R1
	CALL	@(SP)+		;OUTPUT A COUPLE CRLF'S TO FINISH
	TST	(SP)+		;FLUSH CO-ROUTINE FROM STACK
	BIT	#SP$SW,$SWTCH	;SPOOLING REQUESTED?
	BNE	91$		;BRANCH IF /-SP
	PRINT$	$LISPT		;SPOOL OUTPUT IF NEEDED
91$:	MOV	$LISPT,R0	;PUT ADDR OF LISTING FDB, ETC IN R0
 
 
	.IF DF	Q$$CMO
 
 
	BEQ	95$		;SKIP IF OUTPUT TO 'CMO' VIA QIO
 
	.IFF
	CMP	$CMOPT,R0	; OUTPUT TO (DEFAULT) COMMAND TERMINAL.
	BEQ	95$		; IF EQ YES--DO NOT CLOSE TERMINAL.
 
	.ENDC
 
 
	CLOSE$	R0		;CLOSE LISTING FILE
	TSTB	$ATTFG		;CHECK THE TTY ATTACHED FLAG
	BEQ	100$		;BRANCH TO LEAVE IF NOT ATTACHED
95$:	CALL	$TTYDT		;DETACH THE TELETYPE
100$:	RETURN			;AND EXIT
;+
;
; THIS ROUTINE TAKES A DOUBLE PRECISION VALUE (# OF BYTES)
; AND CONVERTS IT TO A STRING DISPLAYING THE VALUE (DIVIDING THE
; VALUE BY 2 TO DISPLAY # OF WORDS)
;
; INPUTS:
;
;	R0 = ADDRESS OF VALUE (IN ADDR AND ADDR+2)
;
; OUTPUTS:
;
;	R0,R1,R2  ARE LOST
;
;-
WORDS:	SAVRG			;SAVE R3-R5
	MOV	(R0)+,R4
	MOV	(R0),R5		;GET DOUBLE PRECISION VALUE
	DIV	#20000.,R4	;SPLIT VALUE INTO TWO PARTS
	MOV	$LIPTR,R0	;POINT R0 TO OUTPUT FDB, ETC
	MOV	R4,R1		;GET HIGH ORDER VALUE
	BEQ	10$		;DON'T OUTPUT IF ZERO
	CLR	R2		;ZERO SUPPRESS
	CALL	$CBDMG		;CONVERT VALUE
	MOVB	-(R0),-(SP)	;SAVE LAST CHAR
	MOV	PC,R2		;NON-ZERO VALUE TO ZERO SUPPRESS FLAG
	CALL	10$		;GET LOW ORDER STRING
	MOVB	(SP)+,-5(R0)	;RESET STORED DIGIT
	RETURN

10$:	ASR	R5		;DIVIDE IN HALF FOR WORDS
	MOV	R5,R1
	CALL	$CBDMG		;CONVERT VALUE
	MOV	R0,$LIPTR	;RESTORE $LIPTR
	RETURN


;
; LISOUT--LISTING OUTPUT CO-ROUTINE
;
 
LISOUT:	CALL	$OUT		;INIT MESSAGE OUTPUT ROUTINE
10$:	CALL	@(SP)+		;RETURN VIA CO-ROUTINE CALL
	CALL	$OUT1		;CALL MESSAGE OUTPUT ROUTINE
	BR	10$
 
 
 
	.END
