TITLE	RC,<RUN-TIME MAINLINE>,08,13-MAY-86,TPH/MHB/JDM/AWR/TS/WJS/EFV

;                   Copyright 1974,1990 by Digital Equipment Corporation
;                                  All rights reserved.
;
;          This software is furnished under a license and may be used and copied
;          only  in  accordance  with  the  terms  of  such license and with the
;          inclusion of the above copyright notice.  This software or any copies
;          shall not be provided to any other person.   No title to or ownership
;          of the software is hereby transferred.
;
;          The information in this software is subject to change without notice.
;
;          DIGITAL  assumes  no  responsibility  for the  use, functionality, or
;          reliability of its  software  on equipment  which  is not supplied by
;          DIGITAL.
;
;	MODIFICATIONS:
;
;*A* 22-AUG-80 BY SCARPELLI: ADD CLR I/O BUFFER ON OPEN
;*B* 07-Dec-84 by Sconce:  cvt$$( ,32%) made to handle international chars
;    27-Jan-85 by Vogel: add edit *A* above... was commented out
;*C* 22-Jan-90 by Sconce:  RAD50 handling for V10.0 extended logicals

L$$IST	=	1		;GET PREFIX FILES LISTED

; DEFINE PUSH-POP TABLE INITIALLY

	DEFORG	PT

	ZSKIP	256.,ERROR

	..	PPADDI,ADDI	;INTEGER +
	..	PPSUBI,SUBI	;INTEGER -
	..	PPRSBI,RSUBI	;INTEGER REVERSE -
	..	PPPWRI,PWRI	;INTEGER ^
	..	PPEQF,.EQ.F	;FLOATING EQUAL OPERATOR
	..	PPEQI,.EQ.I	;INTEGER EQUAL OPERATOR
	..	PPEQS,.EQ.S	;STRING EQUAL OPRERATOR
	..	PPEVS,.EV.S	;STRING EQUIVALENCE
	..	PPGTF,.GT.F	;FLOATING >
	..	PPGTI,.GT.I	;INTEGER >
	..	PPGTS,.GT.S	;STRING >
	..	PPGEF,.GE.F	;FLOATING >=
	..	PPGEI,.GE.I	;INTEGER >=
	..	PPGES,.GE.S	;STRING >=
	..	PPLTF,.LT.F	;FLOATING <
	..	PPLTI,.LT.I	;INTEGER <
	..	PPLTS,.LT.S	;STRING <
	..	PPLEF,.LE.F	;FLOATING <=
	..	PPLEI,.LE.I	;INTEGER <=
	..	PPLES,.LE.S	;STRING <=
	..	PPNEF,.NE.F	;FLOATING <>
	..	PPNEI,.NE.I	;INTEGER <>
	..	PPNES,.NE.S	;STRING <>
	..	PPNEGI,NEGI	;INTEGER COMPLEMENT
	..	PPUSHI,PUSHI	;INTEGER PUSH
	..	PPUSHS,PUSHS	;STRING PUSH
	..	PPREPI,REPLI	;REPLICATE INTEGER
	..	PPREPS,REPLS	;REPLICATE STRING
	..	PPLEN,LEN	;FIND STRING LENGTH
	..	PPSPAC,SPACES	;MAKE STRING OF SPACES
	..	PPSBST,SUBSTR	;FIND SUBSTRING
	..	PPSBS1,SUBST1	;FIND OTHER SUBSTRING
	..	PPINST,INSTR	;FIND IF IN THERE AT ALL
	..	PPNUM,NUM$	;FUNCTION NUM$
	..	PPVAL,VAL	;FUNCTION VAL
	..	PPUJ,UJ		;UNCONDITIONAL JUMP
	..	PPUJX,UJX	;UNCONDITIONAL JUMP EXTERNAL
	..	PPIFJ,IFJ	;IF FALSE JUMP
	..	PPIFJX,IFJX	;IF FALSE JUMP EXTERNAL
	..	PPITJ,ITJ	;IF TRUE JUMP
	..	PPITJX,ITJX	;IF TRUE JUMP EXTERNAL
	..	PPUSHX,PUSHJX	;PUSH AND JUMP EXTERNAL
	..	PPOPJ,POPJ	;POP JUMP RETURN
	..	PPNOT,.NOT.	;LOGICAL NOT
	..	PPAND,.AND.	;LOGICAL AND
	..	PPOR,.OR.	;LOGICAL OR
	..	PPXOR,.XOR.	;LOGICAL XOR
	..	PPIMP,.IMP.	;LOGICAL IMPLIES
	..	PPIFF,.IFF.	;LOGICAL IF AND ONLY IF
	..	PPREDF,READF	;READ FLOATING
	..	PPREDI,READI	;READ INTEGER
	..	PPREDS,READS	;READ STRING
	..	PPCONC,CONCAT	;STRING CONCATENATE
	..	PPENDA,ENDRPT	;END OF CONDITIONAL OPERATOR
	..	PPFRI,FORI	;FOR INTEGER ENTRY
	..	PPRPI,REPTI	;REPEAT INTEGER
	..	PPFRF,FORF	;FOR FLOATING
	..	PPRPF,REPTF	;REPETE FLOATING
	..	PPFRIX,FORIX	;FOR INTEGER EXTERNAL
	..	PPRPIX,REPTIX	;REPETE INTEGER EXTERNAL
	..	PPFRFX,FORFX	;FOR FLOATING EXTERNAL
	..	PPRPFX,REPTFX	;REPEAT FLOATING EXTERNAL
	..	PPNXI,NEXTI	;NEXT INTEGER
	..	PPNXF,NEXTF	;NEXT FLOATING
	..	PPNXIX,NEXTIX	;NEXT INTEGER EXTERNAL
	..	PPNXFX,NEXTFX	;NEXT FLOATING EXTERNAL
	..	PPCLOS,CLOSER	;CLOSE
	..	PPSSI,SSI	;SELECT SLOT FOR INPUT
	..	PPSSON,SSONRC	;SELECT SLOT FOR OUTPUT
	..	PPINPL,INPUTL	;INPUT LINE
	..	PPINPF,INPUTF	;INPUT FLOATING
	..	PPINPI,INPUTI	;INPUT INTEGER
	..	PPINPS,INPUTS	;INPUT STRING
	..	PPSTOP,STOP	;STOP EXECUTION
	..	PPHALT,UJX6	;HALT AFTER IMMEDIATE EXECUTION
	..	PPBADC,BADCOD
	..	PPUUO,UUOCON	;UUO CONTROL
	..	PPTAB,TABF	;TAB FUNCTION
	..	PPPOS,POSF	;POS FUNCTION
	..	PPCHR,CHR$	;CHR$ FUNCTION
	..	PPNXTS,NEXTS	;END OF CURRENT STATEMENT GO TO NEXT ONE
	..	PPASC,ASCII	;ASC FUNCTION
	..	PPDAT$,DATE$	;DATE FUNCTION
	..	PPTIM$,TIME$	;TIME OF DAY FUNCTION
	..	PPPEEK,PEEKF	;PEEKING TOMG FUNCTION
	..	PPSLEP,SLEEP	;SLEEP FUNCTION
	..	PPWAIT,WAITF	;WAIT FUNCTION
	..	PPREST,RESTOR	;RESTORE VERB
	..	PPRESU,RESUME	;RESUME VERB
	..	PPONUB,ONSUB	;ON ... GOSUB ...
	..	PPCSV,CSV	;CHANGE STRING TO VECTOR
	..	PPCVS,CVS	;CHANGE VECTOR TO STRING
	..	PPOPIO,OPENIO	;OPEN FOR INPUT AND OUTPUT
	..	PPOPIN,OPENI	;OPEN FOR INPUT
	..	PPOPOU,OPENO	;OPEN FOR OUTPUT
	..	PPNAME,NAMER	;RENAME
	..	PPKILL,KILLER	;DELETE
	..	PPENDI,ENDINP	;EMPTY THE INPUT BUFFER
	..	PPLEFT,LEFT	;INITIAL SUBSTRING
	..	PPON,ONSTMT	;ON STATEMENT
	..	PPONER,ONERR	;ON ERROR GOTO
	..	PPSDRO,SETDRO	;SET THE NEXDRO FLAG FOR LOOP PPOPS
	..	PPDI,DUPLI	;DUPLICATE INTEGER
	..	PPJSLD,JMPSLD	;JUMP EXTERNAL, THEN NEXTS, ALL IN ONE
	..	PPEND,UJX8	;END OF PROGRAM
	..	PPFIX1,PUSHI1	;PUSH INTEGER 1
	..	PPKIF,PFTJS	;KILL TOP FLOATER (POP FLOAT TO J-SPACE)
	..	PPNXTL,NEXTL	;EXTERNAL JUMP TO NEXT NUMBERED STMT.
	..	PPIFNL,IFNL	;IF FALSE NXTL, ELSE INTERNAL JUMP
	..	PPDUPS,DUPLS	;DUPLICATE STRING AT TOP OF R1 STACK
	..	PPSWAP,SWAPBY	;SWAP BYTE FUNCTION
	..	PPCALL,CALLFN	;FUNCTION ENTER
	..	PPXIT,EXIT	;FUNCTION EXIT
	..	PPENTR,ERROR	;
	..	PPRAD$,RAD50$	;RADIX 50 FUNCTION
	..	PPREAL,REALFG	;SET 'REAL' FLAG (BIT 15)
	..	PPCVSS,CVSSFN	;SPECIAL STRING FUNCTION
	..	PPSSOR,SSOREC	;SELECT SLOT WITH "RECORD"
	..	PPSTNG,STRING	;MAKE A STRING
	..	PPNM1$,NUM1$	;FUNCTION NUM1$
	..	PPANOT,ANOT	;ABSOLUTE NOT
	..	PPRADI,RADIFN	;RAD%() function			*C*
	..	PPDATI,DATIFN	;DATE%() function			*C*

	DEFORG	RC
	DEFORG	UI
	ORG	RC

	.GLOBL	MID9,EDSAVE,POS000,INTERP,INTERB
	.GLOBL	RTSENT,PUSHS1,PUSHS3,DUPLS,TRPINT,UUOCSI,UUORET
	.GLOBL	R1SOUT,ECONOM,PUSHS,CVS3,R50A01,CLOSER,RESTOR
	.GLOBL	PUSHI1,NUM$00,SAVEM,REPLS1,.EQ.S,ATOI
	.GLOBL	SAVREG,RESREG,EDREST
	.GLOBL	LENP3,THENT,PUSHS2,TIME07,READF,READS
	.GLOBL	BUILDS,INPUTF,INPUTS,SSIX1,SSO01,SSIDN
	.GLOBL	SSONRC,SSOCH0,OPNI11,OPNI20,CLSR09,DATE07,MID6
	.GLOBL	READ.,WRITE.,GETBUF,IODIE,UUOSPC,REA.D,WRIT.E
	.GLOBL	BRKENT,SHUT04,IFPOS0

	.GLOBL	PRINTA,PRL14,PROMPT
	.GLOBL	INTFUN,INTFAI,INTFAF,INTFAS,ATOF,PSTJS,FLTLE2
	.GLOBL	RTSRET,EDERR,EDERRN,ZOTALL
	.GLOBL	PRINTL,ATLINE,PRINTI,CRLF,FTLERM
	.GLOBL	RTSRER,PUSHF3,PUSHF1,POPF1,PUSHF
	.GLOBL	PUSHF2,MFLTL2,INDO1,FIX,INDX90,FLT
	.GLOBL	INDR3,ADDF,SUBF,CMPF
	.GLOBL	$PLSIG,..SIG.
	.GLOBL	MULI,FLTLEN
	.GLOBL	SCAN,CSI,BASFRC,DLTONR,EDRSR1
	.GLOBL	DEFFUN,OPNRR1,OPNR20,POPS1

;	THE USER'S SWAP IMAGE IS COMPOSED OF FOUR MAJOR PARTS
;	1.  THE USER'S HARDWARE STACK (SP=%6) & STATIC AREA
;	2.  THE USER STACK (R1=%1)
;	3.  THE USER DATA AREA
;	4.  THE USER TEXT AREA

;	THE RSTS MONITOR MAINTAINS THE SWAP SAVE AREA (9. WORDS
;	STARTING @ SWPSAV) IN THE STATIC AREA. THIS AREA ALSO
;	CONTAINS THE CSR'S THAT POINT TO CRITICAL AREAS
;	IN THE USER'S IMAGE. THESE CSR'S ARE MAINTAINED BY
;	THE CORE SETUP, CORE ALLOCATOR, AND GARBAGE COLLECTOR.

;	THE TEXT AND DATA AREAS ARE SIMILAR IN STRUCTURE
;	IN THAT EACH HAS A BASE AREA THAT DESCRIBES THE
;	AMOUNT AND USAGE OF CORE ALLOCATED TO IT BY THE CORE ALLOCATOR.
;	   00		A LINK TO THE FIRST STRING HEADER
;	   02		THE POSITIVE STATIC LIMIT
;	   04		THE NEGATIVE STATIC LIMIT
;	   06		THE POSITIVE DYNAMIC LIMIT
;	   10		THE NEGATIVE DYNAMIC LIMIT

;	THE MEANS OF DYNAMIC STORAGE IS THE STRING HEADER
;	IT CONTAINS AT LEAST THREE(3) WORDS IN THE FORM
;	1.  LINK WORD
;	2.  PNTR WORD
;	3.  LENGTH WORD

;	I/O HEADERS ALSO CONTAIN
;	4.  SLOT BYTE
;	5.  FLAG BYTE
;	6.  BC WORD
;	7.  CURLOC WORD

;	ARRAY HEADERS CONTAIN
;	4.  2 WORD DYNAMIC DIMENSIONS
;	5.  SLOT BYTE IF DISK BASED
;	6.  TYPE BYTE
;	7.  2 WORD UPPER LIMIT ADDRESS
;	8.  2 WORD ADDITIVE OFFSET
;	9.  INDIVIDUAL ITEM WORD LENGTH WORD
;	10. 2 WORD STATIC DIMENSIONS

;	TEXT HEADERS CONTAIN
;	4.  ASCII TEXT POINTER WORD
;	5.  ASCII TEXT LENGTH BYTE
;	6.  STATEMENT LABEL WORD(1-32767)
;	7.  STATEMENT TYPE BYTE

; SAVE AND RESTORE REGISTERS ROUTINES

SAVREG:	MOV	R4,-(SP)	;SAVE REGISTERS R4,
	MOV	R3,-(SP)	; R3,
	MOV	R2,-(SP)	;  R2,
	MOV	R1,-(SP)	;   R1,
	MOV	R0,-(SP)	;    AND R0 ON SP STACK.
	MOV	5*2(SP),-(SP)	;NOW MOVE R5 VALUE ON STACK AGAIN
	RTS	R5		;AND EXIT NICELY

RESREG:	INC	(SP)+		;DUMP OLD R5 WITHOUT CHANGING C-BIT
	MOV	(SP)+,R0	;RESTORE REGISTERS R0,
	MOV	(SP)+,R1	; R1,
RESRG2:	MOV	(SP)+,R2	;  R2,
	MOV	(SP)+,R3	;   R3,
	MOV	(SP)+,R4	;    AND R4 FROM SP STACK.
	RTS	R5		;NOW RESTORE R5 AND EXIT

EDREST:	INC	(SP)+		;DUMP OLD R5 WITHOUT CHANGING C-BIT
	MOV	(SP)+,R0	;RESTORE R0, BUT
	BR	RESRG2		;DON'T RESTORE R1

; REAL FLAG SETTER (SETS BIT 15 UNCONDITIONALLY)

REALFG:	BIS	#100000,(R1)	;SET FLAG BIT
	RTS	PC		;NOW EXIT

;USED TO INVOKE FN, LEAVES:
;	R1	OLD IPC
;		OLD SCTH
;		CURRIO
;		FN BLK	(IS NEGATIVE--FLAG FOR EXIT)
;		STACK

CALLFN:	GWTXT	R0		;GET A COMPILED WORD
	MOV	SPDA,R2		;PICK UP BASE
	MOV	STACK(R2),-(R1)	;SAVE ERROR RESET STACK
	MOV	R0,-(R1)	;SAVE FUNCTION BLOCK
	MOV	CURRIO(R2),-(R1);SAVE IO BLOCK
	ADD	R2,R0		;MAKE IT ABS.
	MOV	(R0),R0		;GET STATEMENT
	BMI	CALLF1		;CK FOR DEFINED
	ERROR	UNDFNI,FATAL	;UNDEFINED FUNCTION CALLED

CALLF1:	JSR	PC,PSHJX2	;OTHERWISE PUSHJX
	MOV	SPDA,R0		;SAVED STACK UDATE
	ADD	#2,STACK(R0)	;PICTURE WORD NOW ON STACK SOON GOES
;ROUTINE USED TO SAVE OLD VALUES OF DUMMY VARIABLES AND POST ARGUMENTS
;AS CURRENT VALUES IS FIRST OP IN DEF, ALWAYS RUNS JUST AFTER CALLFN
	MOV	(R1)+,-(SP)	;TEMP MOVE IPC
	MOV	(R1)+,-(SP)	;AND SCTH
	MOV	(R1)+,-(SP)	;SAVE CURRIO
	MOV	(R1)+,-(SP)	;FUNCTION BLOCK
	ADD	(SP),R0		;NOW ABSOLUTE
	MOV	(R1)+,-(SP)	;SAVE STACK
	MOV	2(R0),R0	;PICTURE WORD
	MOV	R0,-(SP)	;FOR LATER
	JSR	R5,DEFFUN	;ADJUST TYPES OF ARGUMENTS
	MOV	R1,R4		;SETUP A TEMPORARY R1
	MOV	(SP)+,R2	;RETRIEVE PICTURE
	ADD	#10,R5		;SKIP ALL JUNK AT BEGINNING STMT
ENTR02:	CLR	R3		;WILL BE TYPE INDEX
	ROR	R2		;A LA JFS
	ROL	R3		;GET FIRST BIT
	ROR	R2		;TO MAKE "COMPLEMENT OBVERSE"
	ROL	R3		;HERE
	BEQ	ENTR01		;IF DONE
	MOV	(R5)+,R0	;GET LOCATION-KNOW EVEN
	SWAB	R0		;AND IN RIGHT ORDER
	ADD	SPDA,R0		;MAKE ABSOLUTE
	ASR	R3		;SHIFT CODE OF 1, 2, OR 3
	BEQ	ENTR05		;CODE OF 1 => INTEGER ARGUMENT
	MOV	#FLTLEN,R3	;ASSUMING FLOATER, GET LENGTH
	BCC	ENTR04		;CODE OF 2 => FLOATER

	CMP	(R0)+,(R4)+	;STRING, SKIP LINKS
	ADD	R0,(R0)		;MAKE BOTH ABSOLUTE
	ADD	R4,(R4)		;AND
	MOV	(R0),-(SP)	;THEN SWAP POINTERS
	MOV	(R4),(R0)	;TO THE STRINGS
	MOV	(SP)+,(R4)	;AND
	SUB	R0,(R0)		;RELATIVIZE THEM
	SUB	R4,(R4)		;AGAIN
	CMP	(R0)+,(R4)+	;DON'T TRY AUTO INC IN PREV INSTRUCTIONS
ENTR05:	MOV	#1,R3		;COUNT OF ADDITIONAL ITEMS TO MOVE
ENTR04:	MOV	(R0),-(SP)	;SWAP WITH NO CHANGE
	MOV	(R4),(R0)+	;THIS NEXT
	MOV	(SP)+,(R4)+	;ITEM-PART OF A # OR STR LEN
	SOB	R3,ENTR04	;COUNT THROUGH DATUM
	BR	ENTR02		;THEN PROCESS NEXT ARG

ENTR01:	MOV	(SP)+,-(R1)	;RESTORE STACK
	MOV	(SP)+,-(R1)	;RESTORE FN BLK
	MOV	(SP)+,-(R1)	;CURRIO
	MOV	(SP)+,-(R1)	;AND SCTH
	MOV	(SP)+,-(R1)	;AAAAND IPC
	RTS	PC		;AND DONE ENTRING

;EXIT DOES A PUSH OF THE FUNCTION'S VALUE AND USES THE LIST OF ARGUMENTS
;IN THE DEF STATEMENT TO RESTORE ALL THE SAVED DUMMY ARG VALUES
EXIT:	MOV	R1,R2		;TEST USED UP STACK
	ADD	#6,R2		;SIZE OF BLOCK PUT ON BY CALL
	CMP	R1,R1CORG	;TEST FOR UNDERFLOW--TOO MANY FNEND'S/RETURNS
	BHIS	1$		;OK
	TST	(R2)		;SEE IF GOSUB
	BMI	3$		;OK IF -, GOSUB LEAVES 0
1$:	ERROR	EXITNR,FATAL	;FN'S & SUB'S BADLY NESTED

3$:	MOV	(R1)+,-(SP)	;OLD IPC
	MOV	SPTA,R4		;GET PROG BASE
	ADD	R4,(SP)		;MAKE ABS
	ADD	R4,(R1)		;OLD HEADER
	MOV	(R1)+,SCTH	;POST IT
	MOV	SPDA,R0		;GET BASE
	MOV	R0,R2		;SAVE IT FOR LATER, TOO
	MOV	(R1)+,CURRIO(R0);RESTORE REL CURRIO
	MOV	(R1)+,R0	;PICK UP FN BLK (OR GOSUB'S ZERO)
	MOV	(R1)+,STACK(R2)	;RESTORE PRE-FN STACK

	ADD	R2,R0		;MAKE FNBLK ABSOLUTE
	MOV	(R0)+,R5	;DEF STATEMENT HEADER
	ADD	R4,R5		;ABSOLUTE
	ADD	2(R5),R5	;POINTER TO PUSHPOP
	ADD	#7,R5		;SKIPENTR AND FN BLK
	MOVB	(R5)+,-(SP)	;POP VALUE CODE
	MOV	(R0)+,R4	;PICTURE WORD
	MOV	R0,-(SP)	;SAVE FN VALUE LOC
EXIT07:	CLR	R3		;CALCULATE OBVERSE
	ROR	R4		;USING ROTATE
	ROL	R3		;DANCE
	ROR	R4		;I'M GETTING
	ROL	R3		;DIZZY
	ASL	R3		;MAKE IT A WORD ADDRESS
	MOV	(R5)+,R0	;TAKE ADVANTAGE OF EVENNESS
	SWAB	R0
	ADD	R2,R0		;MAKE ARG ABSOLUTE
	JSR	PC,@99$(R3)	;DO THE APPROPRIATE THING
	BR	EXIT07		;NEXT SAVED DUMMY

99$:	.WORD	EXIT12,EXIT11,POPF1,POPS1 ;0=DONE, 1=INTEGER, 2=FLOAT, 3=STRING

EXIT11:	MOV	(R1)+,(R0)	;POP INTEGER
	RTS	PC		;DONE

EXIT12:	TST	(SP)+		;DUMP RETURN FROM DISPATCH CALL
	MOV	(SP)+,R0	;RESTORE VALUE POINTER
	MOVB	(SP)+,R4	;CODE FROM AFTER ENTR
	ADD	R4,PC		;AND DISPATCH
	BR	EXIT05		;FLOATING
	BR	EXIT06		;INTEGER
	JSR	PC,PUSHS1	;STRING
	TST	(R0)+		;RESET LENGTH
	CLR	(R0)		;TO FREE STRING SPACE
	BR	EXIT13
EXIT05:	JSR	PC,PUSHF2	;PUSH THE FLOATER
	BR	EXIT13
EXIT06:	MOV	(R0),-(R1)	;PUSH INTEGER
EXIT13:	MOV	(SP)+,R5	;OLD IPC
	RTS	PC

EDSAVE:	MOV	R4,-(SP)	;SAVE R4
	MOV	R3,-(SP)	; AND R3
	MOV	R2,-(SP)	;  AND R2
	MOV	R0,-(SP)	;   AND R0 (BUT NOT R1)
	MOV	4*2(SP),-(SP)	;SAVE R5 AGAIN
	RTS	R5		;THEN EXIT

; UNEXECUTABLE STATEMENT ERROR

BADCOD:	ERROR	BADERR,FATAL	;CALL IT FATAL

;ILLEGAL OP-CODE ROUTINE

ERROR:	ERROR	ERRERR,FATAL	;BAD INTERPRETIVE CODE

POST00:	ERROR	FLTERR		;FLOATING POINT ERROR
SHUT01:
;	JMP	INTERB		;READY SET GO

;	MAIN INTERPRETER

INTERB:	IFZERO	EQ,(R1)+,INTERP	;BR IF NONINTERNAL INTERPRETATION
	MOV	R5,-(SP)	;OTHWS, SAVE EXTERNAL PP POINTER
	MOV	-2(R1),R5	;& USE PREVIOUSLY SAVED INTERNAL POINTER
	BR	INTERP		;DO IT ONE MORE TIME, UNLESS HE GOOFS

INTERL:	MOVB	(R5)+,R0	;GET AN OP-CODE
	ASL	R0		;MAKE INTO AN INDEX
	JSR	PC,@PT+256.(R0)	;DISPATCH INTO HANDLER
INTERP:	TST	JOBF		;SEE IF HE WANTS US TO QUIT
	BPL	INTERL		;STOP IF SO REQUESTED
;	BR	SHUTUP		;FALL THRU TO SHUT-UP

;QUIT ROUTINE 

SHUTUP:	CLR	-(R1)		;CLEAR INTERNAL PP FLAG
	CMP	R5,#PT		;INTERNAL OR EXTERNAL? (USER<BASIC)
	BLO	3$		;IT IS EXTERNAL
	MOV	R5,(R1)		;OTHWS, SAVE INTERNAL PP POINTER
	MOV	(SP)+,R5	;& REPLACE IT WITH EXTERNAL PP POINTER
3$:	MOV	#JOBF,R4	;GET A MOST USEFUL POINTER
	MOVB	(R4),R2		;SEE IF ^C OR POST ERROR
	BPL	SHUT00		;BRANCH IF POST
	BIC	#JFCC!JFRTS,(R4);CLEAR ^C FLAG SO WE CAN CONTINUE
	MOV	SPDA,R2		;GET PROGRAM DATA BIAS
	MOV	SCTH,R0		;GET CURRENT STATEMENT HEADER
	MOV	TAGBIN(R0),-(SP);AND THE LINE # FROM THAT
	MOV	(SP),CURLIN(R2)	;NOW SET ^C LINE #
	BLE	SHUT04		;ABORT ON ^C IF IMMEDIATE MODE
	MOV	OEGTLN(R2),R0	;GET "ON ERROR GOTO" LINE #
	BEQ	SHUT04		;NONE, SO DIE
	BIT	#JFCCC,(R4)	;ENABLED FOR ^C?
	BEQ	SHUT04		;NOPE, SO DIE ALSO
	BIC	#JFCCC,(R4)	;YEP, BUT TURN IT OFF NOW
	TST	RUNLVL		;ALREADY IN ERROR? (RUNLVL=0)
	BEQ	SHUT04		;YES
	SETERR	CTRLCE,ERRVAL(R2);SET ERROR CODE AS ^C
	CLR	RUNLVL		;SAY WE ARE RUNNING IN ERROR
	.TTRST			;CANCEL ^O DONE BY ^C
	JMP	TRAP20		;AND GO TO IT

STOP:	ERROR	STPERR		;PROGRAMED STOP
BRKENT:	CLR	-(R1)		;CLEAR INTERNAL PP FLAG
SHUT04:	MOV	#USRSP,SP	;RESET THE STACK POINTER
	MOV	#RTSRET,-(SP)	;SET RETURN TO "RTSRET"
UUOXI0:	MOV	SPDA,R0		;GET A DATA POINTER
	MOV	CURRIO(R0),-(R1);STORE THE CURRENT IO POINTER
	MOV	SCTH,-(R1)	;STORE HEADER ADDRESS
	MOV	SPTA,R4		;GET A TEXT POINTER
	SUB	R4,(R1)		;MAKE RELATIVE
	SUB	R4,R5		;MAKE IPC RELATIVE
	MOV	R5,-(R1)	;SAVE THE IPC TOO
	MOV	R1,R1CONT	;SAVE R1 FOR "CONT"
	SUB	R1CORG,R1CONT	;MAKE IT REL
	BIS	#EDCONT,EDFLAG	;HE CAN CONTINUE BECAUSE STUFF SAVED OK
	RTS	PC		;RETURN TO THE EDITOR

SHUT00:	BIC	#-JFRTS-1,R2	;CLEAR ALL BUT OUR BITS
	BIC	#JFSTOP!JFRTS,(R4)	;CLEAR OUR BITS IN JOB FLAGS
	ADD	R2,PC		;DISPATCH
	BR	SHUT01		;NO POSTING ERRORS
	BR	POST00		;POST ERROR 0
	BR	POST01		;POST ERROR 1
;	BR	POST02
POST02:	ERROR	DIVBY0
	BR	SHUT01

POST01:	ERROR	FIXERR		;NUMBER TOO BIG TO BE AN INTEGER
	BR	SHUT01		;AND CONTINUE

TRPINT:	JSR	R4,SAVEM	;SAVE R4,R3,R2,R0
	MOV	4*2(SP),R2	;GET THE SAVED PC
	MOVB	-2(R2),R3	;GET TRAP EVEN BYTE CODE
	BEQ	TRAP06		;BRANCH IF POST ERROR
	MOV	SPDA,R2		;GET DATA AREA POINTER
	MOV	CURRIO(R2),-(SP);SAVE CURRENT IO POINTER
	MOV	RUNLVL,-(SP)	;SAVE THE CALLING LEVEL
	CLR	RUNLVL		;THEN SET IT TO 0 (ERRORS)
	TSTB	R3		;SEE IF FATAL ERROR
	BPL	1$		;BRANCH IF NON-FATAL
	MOV	#EDERR,-(SP)	;ASSUME ERROR IS NOT IOTERR
	BIT	#176,R3		;NOW SEE IF IT IS IOTERR
	BNE	12$		;IT'S NOT (IOTERR = 001)
	MOV	#EDERRN,(SP)	;IT IS--WE WANT TO GO TO EDERRN THEN
12$:	MOV	(SP)+,6*2(SP)	;STORE WHERE RETURN WILL RETURN TO
	BIC	#1,R1		;MAKE STACK EVEN FOR PUSH LATER
	BIC	#EDGOFL,EDFLAG	;NO GO AFTER LOAD IF ERROR
	BIC	#-177-1,R3	;CLEAR FATAL BIT
	BEQ	TRAP05		;IF NOW ZERO THEN EXIT
1$:	CMPB	R3,#1		;SEE IF AN IO ERROR
	BNE	9$		;BRANCH IF GARDEN VARITY USER ERROR
	MOVB	IOSTS,R3	;ADD IN IOSTS
9$:	MOV	R3,ERRVAL(R2)	;STORE THE ERROR NUMBER
	BIC	#JFRTS,JOBF	;INSURE NO POSTING ERRORS NOW
	MOV	SCTH,R4		;GET CURRENT HEADER ADDRESS
	MOV	TAGBIN(R4),-(SP);AND THE LINE # FROM THAT
	MOV	(SP),VALERR(R2)	;SET THAT LINE # FOR "ERL"
	BLE	TRAP11		;FATAL ERROR IF IN IMMEDIATE MODE
	CMP	(PC),2(SP)	;SEE IF SAVED RUNLVL IS 2 (USER)
	BEQ	TRAP07		;IF 2, THEN USER RUNNING

TRAP11:	.TTRST			;CANCEL ANY ^O
	CHKERR	CTRLCE,R3	;CONTROL/C ERROR?
	BEQ	5$		;YES, SO NO MESSAGE(S)
	JSR	PC,GETBUF	;GET A LITTLE BUFFER
	CMP	(R4)+,(R4)+	;SKIP TO CODE LOCATION
	MOV	R3,(R4)		; AND SET THE ERROR CODE
	MOV	R4,-(SP)	;SAVE TEXT RETURN LOCATION
	MOVB	#ERRFQ,-(R4)	;NOW SET ERROR MESSAGE LOOKUP FUNCTION
	JSR	PC,FIPCAL	;CALL MONITOR FOR FIP SERVICE
	BEQ	96$		;WE MADE IT
	MOV	#FTLERM,(SP)	;ERROR IN ERROR, PRINT THIS INSTEAD
96$:	JSR	PC,IFPOS0	;PRINT IF POS(0%), SELECT CHANNEL 0
99$:	MOV	(SP)+,R3	;GET MESSAGE POINTER
98$:	MOVB	(R3)+,R2	;GET A CHARACTER
	BEQ	97$		;THE END...
	CALLX	PRINTC,R3	;ELSE PRINT IT
	CMP	R3,#FIRQB+FQBSIZ;MORE?
	BNE	98$		;MIGHT BE
97$:	MOV	(SP),R4		;GET LINE # OF ERROR
	BLE	4$		;DON'T BOTHER PRINT "LINE 0"
	MOV	R4,-(R1)	;DO BOTHER PRINTING REAL LINE
	MOV	#ATLINE,R2	;SO PRINT " AT LINE"
	JSR	PC,PRINTL	;USE PRINTL TO PRINT LINE
	JSR	PC,PRINTI	;PRINT THE LINE NUMBER

4$:	JSR	PC,CRLF		;FINISH THE LINE
5$:	TST	(SP)+		;DUMP SAVED LINE #
TRAP05:	MOV	(SP)+,RUNLVL	;RESTORE RUNNING LEVEL
	MOV	SPDA,R2		;GET DATA AREA POINTER
	MOV	(SP)+,CURRIO(R2);RESTORE I/O POINTER
TRAP10:	MOV	(SP)+,R0	;RESTORE THE REGISTERS
	MOV	(SP)+,R2
	MOV	(SP)+,R3
	MOV	(SP)+,R4
	RTI			;WHITHER WANDEREST THOU WAYFARER??

TRAP06:	BIS	(R2)+,JOBF	;SET ERROR BITS
	MOV	R2,4*2(SP)	;UPDATE THE PC
	BR	TRAP10		;RESTORE REGS AND GO

TRAP07:	MOV	OEGTLN(R2),R0	;GET ERROR LINE NUMBER
	BEQ	TRAP11		;BRANCH IF NO USER ERROR ROUTINE
	CHKERR	STMERR,R3	;SEE IF RECOVERABLE ERROR (<STMERR)
	BLOS	TRAP11		;EXIT IF STOPING
TRAP20:	MOV	STACK(R2),R1	;REMOVE HIS JUNK
	ADD	R1CORG,R1	;MAKE ABSOLUTE
	MOV	R2,R4		;USE R4 FOR A STRING HEADER POINTER
8$:	ADD	(R4),R4		;GO SKIPPING DOWN THE CHAIN
	CMP	R4,R1		;SEE IF ON THE OLD STACK
	BLO	8$		;BRANCH IF IT WAS
	SUB	R2,R4		;MAKE FIRST STRING ADDRESS RELATIVE
	MOV	R4,(R2)		;AND STORE IT AWAY
	MOV	SCTH,R5		;START OF CURRENT STATEMENT
	SUB	SPTA,R5		;MAKE RELATIVE
	MOV	R5,RESLOC(R2)	;SAVE HEADER ADDRESS
	MOV	#USRSP,SP	;RESET STACK
	MOV	#INTERP,-(SP)	;INTERPRETER START UP OPINT
	BR	UJX1		;START HIM UP

;	IF (FALSE OR TRUE) JUMP ROUTINE

ITJ:	JSR	PC,ANOT		;DO ABSOLUTE NOT

IFJ:	GWTXT	R0		;GET THE POSSIBLE PLACE TO GO
	TST	(R1)+		;TEST BOOLEAN VALUE
IFJ2:	BNE	IFJ1		;IF TRUE WXIT NOW
	ADD	R0,R5		;ELSE UPDATE IPC
IFJ1:	RTS	PC		;AND RETURN

PIFJ:	MOV	SPDA,R2
	MOV	(R1),RPTERM(R2)  ;SAVE TRUTH VALUE FOR "NEXT" STATEMENT
	BR	IFJ

IFNL:	TST	(R1)+		;SPECIAL POP FOR IF STATEMENTS
	BEQ	NEXTL		;NEXTL IF FALSE, OTHERWISE UJ

;	UNCONDITIONAL JUMP ROUTINE

UJ:	MOVB	(R5)+,-(R1)	;GET THE DISPLACEMENT
	MOVB	(R5)+,-(R1)
	ADD	(R1)+,R5	;ADJUST THE IPC
	RTS	PC		;RETURN

;	POP AND JUMP ROUTINE

POPJ:	MOV	SPDA,R2		;GET THE ADDRESS OF THE DATA AREA
	TST	GOSUB(R2)	;TOO MANY RETURNS?
	BLE	POPJ99		;YES
	TST	6(R1)		;DEFINITELY NOT DONE BY GOSUB IF <>0
	BNE	POPJ99		; IN THIS WORD
	BIT	4(R1),#1	;MUST BE IMMEDIATE MODE "RETURN" IF
	BEQ	UJX4		; THIS IS EVEN (GOSUB PUSHES A 1)
	DEC	GOSUB(R2)	;DECREMENT THE COUNTER
	MOV	SPTA,R4		;GET THE TEXT AREA POINTER
	MOV	(R1)+,R5	;GET THE RETURN ADDRESS
	ADD	R4,R5		;RELOCATE IT
	ADD	R4,(R1)		;RELOCATE THE HEADER ADDRESS TOO
	MOV	(R1)+,SCTH	;STORE THE OLD HEADER
	CMP	(R1)+,(R1)+	;POP THE TWO TYPE WORDS
	MOV	R1,STACK(R2)	;UPDATE ERROR RECOVERY STACK
	SUB	R1CORG,STACK(R2)	;MUST BE RELATIVE
IFJX1:	RTS	PC

POPJ99:	ERROR	EXITTM,FATAL	;NO GOSUB!!!!!!!!

; PRECEEDING WORD MUST BE NEGATIVE!!
	.WORD	1.		;40.^0.
	.WORD	40.		;40.^1.
R50A00:	.WORD	1600.		;40.^2.

;	IF TRUE JUMP EXTERNAL ROUTINE
ITJX:	COM	(R1)		;REVERSE THE SENSE
;	IF FALSE JUMP EXTERNAL ROUTINE

IFJX:	GWTXT	R0		;GET THE POINTER LOCATION
	TST	(R1)+		;SEE HOW TO GO
IFJXN2:	BNE	IFJX1		;IF TRUE FALL THRU
	BR	UJX1		;PLAY LIKE UJX NOW

;VARIANT OF IFJX USED BY "FOR" RPT LOOPS

PIFJXN:	MOV	SPDA,R2
	MOV	(R1),RPTERM(R2)  ;SAVE TRUTH VALUE FOR "NEXT" STATEMENT
	BR	IFJX

;	PUSH JUMP EXTERNAL ROUTINE

PUSHJX:	GWTXT	R0		;GET DESTINATION ADDRESS
PSHJX1:	CLR	-(R1)		;CLEAR TWO WORDS SO WE LOOK
	MOV	#1,-(R1)	;  LIKE GOSUB CALLS
	MOV	SPDA,R2		;GET DATA AREA POINTER
	INC	GOSUB(R2)	;INCREMENT COUNTER
PSHJX2:	SUB	SPTA,R5		;MAKE IPC RELATIVE
	MOV	SCTH,-(R1)	;SAVE THE STATEMENT HEADER ADDRESS
	SUB	SPTA,(R1)	;AND MAKE IT RELATIVE
	MOV	R5,-(R1)	;SAVE IT FOR THE POPJ
	BR	UJX1		;MAKE LIKE UJX

ONSUB:	JSR	PC,ONSET	;DO COMMON STUFF FOR ON ... GOSUB ...
	BR	PSHJX1		;NOW DO GOSUB

ONSTMT:	MOV	#UJX1,-(SP)	;SET RETURN ADDRESS
ONSET:	CLR	R0		;CLEAR UP R0
	BISB	(R5)+,R0	;GET COUNT TIMES 2 (NO SIGN EXTEND)
	MOV	(R1)+,R2	;GET INDEX
	BLE	1$		;<=0 IS AN ERROR
	ADD	R2,R2		;NOW INDEX IS REALLY TIMES 2
	CMP	R2,R0		;SEE IF IN RANGE
	BLOS	2$		;O.K.
1$:	ERROR	ONBAD,FATAL	;ON ERROR

2$:	ADD	R0,R5		;ADJUST IPC
	MOV	R5,R4		;AND SAVE IT
	SUB	R2,R4		;BACK TO HEADER
	MOVB	(R4)+,-(R1)	;NOW GET IT
	MOVB	(R4)+,-(R1)
	MOV	(R1)+,R0	;INTO R0
	RTS	PC		;THEN EXIT ACCORDINGLY

;	UNCONDITIONAL JUMP EXTERNAL ROUTINE

UJX:	GWTXT	R0		;GET THE POINTER LOCATION
UJX1:	MOV	SPTA,R5		;START OF TEXT POINTER AREA
	ADD	R0,R5		;RELOCATE TO POINTER
UJX2:	BIT	#EDIMED,EDFLAG	;ARE WE IN IMMEDIATE MODE?
	BNE	UJX4		;YES--DON'T LET HIM ENTER PROGRAM
	TST	LENGTH(R5)	;CHECK FOR A NON-ZERO LENGTH
	BNE	RTSENT		;GO IF NON-ZERO
	ERROR	STMERR,FATAL	;NOT FOUND ERROR

UJX4:	ERROR	NRNERR,FATAL	;USE RUN--CANT'T CONTINUE

RESU3:	ERROR	RESERR,FATAL	;NO ERROR AND RESUME USED

RESUME:	MOV	SPDA,R2		;GET A DATA AREA POINTER
	GWTXT	R5		;GET THE STATEMENT HEADER
	BNE	RESU1		;BRANCH IF START SOME PLACE ELSE
	MOV	RESLOC(R2),R5	;GET SAVED LOCATION
	BEQ	RESU3		;BRANCH IF NO ERROR AND SIMPLE RESUME
RESU1:	CLR	RESLOC(R2)	;CLEAR THE TRACKS
	ADD	SPTA,R5		;MAKE ABSOLUTE
	MOV	#2,RUNLVL	;GOTO USER LEVEL
	BR	UJX2		;AND GO LIKE UJX

NEXTL:	BIT	#EDIMED,EDFLAG	;IF IMMEDIATE COMMAND
	BNE	UJX6		;QUIT
	MOV	SCTH,R5		;SAVE ORIG. LINE NUMBER
	MOV	TAGBIN(R5),R4	;FOR COMPARISON
	BEQ	UJX6		;CATCH IMED. IFTHEN FALLING THRU
NEXTL1:	TST	(R5)		;END OF STMT. LIST?
	BEQ	UJX81		;YES
	ADD	(R5),R5		;NEXT ONE PLEASE
	TST	LENGTH(R5)	;PHANTOM?
	BEQ	NEXTL1		;YES
	CMP	R4,TAGBIN(R5)	;SAME LINE NUMBER?
	BEQ	NEXTL1		;YES
	BR	RTSENT		;AH, NEW LINE

UJX8:	JSR	PC,ZOTALL	;END STATEMENT CLOSES ALL FILES
UJX81:	BIC	#EDCONT,EDFLAG	;CLEAR CONTINUE
UJX6:	TST	(SP)+		;REMOVE THE INTERPRETER'S RETURN
	JMP	RTSRET		;RETURN TO THE EDITOR COMPILER ETC

;NEXT STATEMENT ROUTINE
;ONE OF THE PRINCIPLE THINGS TO DO IS INSURE THAT THERE IS ENOUGH
;R1 STACK FOR THE NEXT STATEMENT.  MOST STATEMENTS CANNOT USE MORE STACK
;THEN TWO TIMES THE NUMBER OF BYTES IN THE COMPILED CODE (HART'S THEOREM)
;THE EXCEPTION'S TO THIS RULE ARE COVERED BY THE R1SMIN FUDGE
;WHICH TAKES CARE OF THINGS LIKE PRINT USING. TO BE 100% SAFE, WE INSURE
;THAT THERE ARE R1SMIN+2*TAGLEN BYTES OF R1 STACK TO SPARE.
 

JMPSLD:	JSR	PC,UJX		;JUMP,SLIDE POP USED TO SKIP FN DEFS
NEXTS:	MOV	SCTH,R5		;GET THE ADDRESS OF THE CURRENT HEADER
NXTS01:	TST	(R5)		;SEE IF THIS IS THE END
	BEQ	UJX8		;IF SO QUIT AND RETURN TO THE EDITOR
	ADD	(R5),R5		;GO DOWN THE LINKS
RTSENT:	MOV	R5,SCTH		;SAVE THE HEADER ADDRESS
	MOV	SPDA,R2		;GET DATA AREA POINTER
	MOV	R1,R3		;COPY STACK
	SUB	R1CORG,R3	;MAKE RELATIVE
	MOV	R3,STACK(R2)	;SAVE FOR ERRORS MAYBE
	MOV	LENGTH(R5),R4	;GET CODE LENGTH
	BEQ	NXTS01		;GO ON IF NULL
	CMP	R4,#256.	;IS CODE LENGTH REALLY LARGE???
	BLOS	2$		;NO
	MOV	#256.,R4	;YES, PUT SOME UPPER BOUND ON IT...
2$:	ASL	R4		;MAKE INTO GUESS AT STACK LENGTH
	ADD	#R1SMIN,R4	;ELSE SET THE MINIMUM
	MOV	R1,-(SP)	;PUSH THE CURRENT R1
	SUB	R4,(SP)		;SEE WHERE IT MIGHT GO
	CMP	(SP)+,#NSTORG	;SEE IF ENOUGH ROOM
	BHIS	3$		;BRANCH IF NO MORE STACK NEEDED
	ASL	R4		;BUY IN QUANTITY
	CMP	R4,R1SNOM(R2)	;IS IT GIVING US THIS MUCH?
	BLOS	1$		;IF SO
	MOV	R4,R1SNOM(R2)	;MAKE SURE CORE ALLOCATOR KNOWS HOW MUCH IS NEEDED
1$:	JSR	PC,R1SOUT	;GET MORE STACK SPACE
	MOV	SCTH,R5		;GET HEADER BACK
3$:	ADD	PNTR(R5),R5	;RELOCATE TO THE STRING
	JMP	DEBUG		;CHECK FOR DEBUGGING OR RETURN

	TMPORG	DEBUG		;DUMMY UNLESS 'DEBUG.OBJ' IS LINKED
DEBUG:	RTS	PC		;THAT WAS EASY
	UNORG

;	ABSOLUTE NOT

ANOT:	TST	(R1)		;CHECK SENSE
	BEQ	.NOT.		;WAS FALSE, MAKE TRUE
	CLR	(R1)		;WAS TRUE, MAKE FALSE
	RTS	PC

;	LOGICAL AND ROUTINE

.AND.:	COM	(R1)		;SINCE BIC IS .NOT. AND
	BIC	(R1)+,(R1)	;COMPLEMENT SOURCE AND DO A BIC
	RTS	PC		;AND RETURN

;	LOGICAL EQUIVALENCE ROUTINE

.IFF.:	MOV	(R1)+,R3	;FIRST DO AN XOR
	XOR	R3,(R1)		;THEN COMPLEMENT THE RESULT

;	LOGICAL NOT ROUTINE

.NOT.:	COM	(R1)		;A SIMPLE COMPLEMENT WILL SOLVE THE PROBLEM
	RTS	PC		;RETURN

;	LOGICAL IMPLIES ROUTINE

.IMP.:	COM	2(R1)		;.IMP=A.OR.-B SO MAKE NOT B AND FALL THRU

;	LOGICAL OR ROUTINE

.OR.:	BIS	(R1)+,(R1)	;DO THE OR
	RTS	PC		;AND RETURN

.XOR.:	MOV	(R1)+,R3	;GET THE FIRST INTO A REGISTER
	XOR	R3,(R1)		;DO THE XOR
	RTS	PC		;DONE


;	FIXED POINT ARITHMETICS

NEGI:	NEG	(R1)		;NEGATE THE NUMBER
	RTS	PC		;AND RETURN

RSUBI:	NEG	2(R1)		;NEGATE NEXT TO TOP ELEMENT AND FALL THRU

ADDI:	ADD	(R1)+,(R1)	;ADD POLISH MODE
	RTS	PC		;THAT WAS QUICK WASN'T IT

SUBI:	SUB	(R1)+,(R1)	;SUBTRACT POLISH MODE
	RTS	PC		;THAT WAS QUICK ALSO

;	REPLICATE INTEGER ROUTINE

REPLI:	GWTXT	R0		;GET THE DATA AREA LOCATION
	ADD	SPDA,R0		;MAKE IT AN ABSOLUTE ADDRESS
	MOV	(R1),(R0)	;STORE WITH OUT THE POP
	RTS	PC		;AND RETURN


CMPS:	MOV	R1,R0		;COPY STACK POINTER
	MOV	R1,R3		;MAKE TWO TEMP COPYS
	TST	(R3)+		;POINT TO #1 ADDRESS
	ADD	(R3)+,R0	;MAKE #1 POINTER ABSOLUTE
	MOV	(R3)+,R2	;GET #1 LENGTH
	MOV	LENGTH(R3),R4	;GET # 2 LENGTH
	ADD	PNTR(R3),R3	;GET ADDRESS OF #2
CMPS0:	DEC	R2		;SEE IF ANY LEFT IN #1
	BLT	CMPS2		;FILL WITH <SP> OF NONE LEFT
	DEC	R4		;SEE IF ANY IN #2
	BLT	CMPS4		;FILL WITH <SP> IF NONE LEFT
	CMPB	(R0)+,(R3)+	;COMPARE THE TWO BYTES
	BEQ	CMPS0		;IF EQUAL CONTINUE
	BHI	CMPS1		;ELSE EXIT IF .GT.
CMPS3:	CCC			;SET .LT.
	RTS	PC		;AND RETURN

CMPS4:	CMPB	(R0)+,#40	;SEE IF TRAILING SPACES ON #1
	BEQ	CMPS0		;IF SO GO AGAIN
CMPS1:	CCC			;.GT.
	SEN			;SET LT FLAG
	RTS	PC		;AND RETURN

CMPS2:	DEC	R4		;SEE IF ANY IN #2
	BLT	CMPS9		;IF NONE THEN EQUAL STRINGS
	CMPB	#40,(R3)+	;SEE IF TRAILING SPACES IN #2
	BEQ	CMPS0		;IF SO GO AGAIN
	BR	CMPS3		;ELSE SHOW .GT.

CMPS9:	CMP	R2,R4		;SEE IF EQUAL LENGTH
	+CLC ! CLV ! CLN	;CLEAR OTHER CONDITION CODES
	BNE	CMPS7		;IF SAME WITH SPACES EXIT NOW
	SEC			;CARRY ON FOR IDENTICAL STRINGS
CMPS7:	SEZ			;Z-BIT ON FOR EQUAL STRINGS
	RTS	PC

DUPLI:	MOV	(R1),-(R1)	;COPY THE WORD
	RTS	PC		;AND RETURN

DUPLS:	MOV	R1,R0		;WE'RE GOING TO INTER POSHS SO SET
	MOV	SPDA,R2		;UP R0 + R2 FOR ENTRY AT PUSH1
	BR	PUSHS1		;AND GO THERE

REPLS:	GWTXT	R0		;GET USER ADDRESS
	ADD	SPDA,R0		;COMPUTE ABSOLUTE ADDRESS
REPLS1:	MOV	LENGTH(R1),LENGTH(R0)	;COPY THE LENGTH
	MOV	PNTR(R1),R2	;GET THE RELATIVE POINTER
	ADD	R1,R2		;MAKE ABSOLUTE
	SUB	R0,R2		;ADJUST FOR NEW RESTING PLACE
	MOV	R2,PNTR(R0)	;STORE IT AWAY
	RTS	PC		;AND RETURN

PUSHS:	GWTXT	R0		;GET THE HEADER LOCATION
	MOV	SPDA,R2		;DATA AREA POINTER
PUSHS3:	ADD	R2,R0		;COMPUTE THE REAL ADDRESS
PUSHS1:	CMP	(R0)+,(R0)+	;GO TO THE LENGTH FIELD
	MOV	(R0),-(R1)	;STORE THE LENGTH FIELD
	MOV	-(R0),-(R1)	;STORE THE OLD POINTER
	ADD	R0,(R1)		;REMOVE THE OLD BIAS
	SUB	R1,(R1)		;AND ADD OUR OWN
	MOV	(R2),-(R1)	;GET THE HEAD OF THE STRING LOCATION
PUSHS2:	ADD	R2,(R1)		;REMOVE IT'S BIAS
	SUB	R1,(R1)		;AND SHOW HOW IT'S BEEN MOVED
	MOV	R1,(R2)		;STORE THE NEW START OF ALL STRINGS
	SUB	R2,(R2)		;AND MAKE IT RELATIVE
	RTS	PC

;	PUSH INTEGER ROUTINE

PUSHI:	MOVB	(R5)+,-(R1)	;GET A WORD
	MOVB	(R5)+,-(R1)	; OF PROGRAM TEXT
	ADD	SPDA,(R1)	;RELOCATE IT
	MOV	@(R1)+,-(R1)	;REPLACE IT WITH THE INTEGER THERRE
	RTS	PC		;AND RETURN

.GT.I:	CMP	(R1)+,(R1)	;COMPARE THE NUMBERS
	BLT	TRU.		;BRANCH IF TRUE
	BR	FLS.		;ELSE SET FALSE

.GE.I:	CMP	(R1)+,(R1)
	BLE	TRU.
	BR	FLS.

.LT.I:	CMP	(R1)+,(R1)
	BGT	TRU.
	BR	FLS.		;ALL 6 ROUTINES ARE

.LE.I:	CMP	(R1)+,(R1)	;STRIKINGLY SIMILAR - HUH?
	BGE	TRU.
	BR	FLS.

.NE.I:	CMP	(R1)+,(R1)
	BEQ	FLS.
TRU.:	MOV	#-1,(R1)	;SHOW TRUE ANSWER
	RTS	PC		;AND RETURN

.EQ.I:	CMP	(R1)+,(R1)
	BEQ	TRU.
FLS.:	CLR	(R1)		;SHOW FALSE RESULT
	RTS	PC		;AND RETURN

;	FLOATING RELATIONAL OPERATORS

.GE.F:	MOV	#.NOT.,-(SP)	;TEST OPPOSITE CONDITION, THEN REVERSE
.LT.F:	JSR	PC,CMPF		;COMPARE THE NUMBERS
	BLT	.TRUE		;BRANCH TO STORE TRUE
	BR	.FALSE		;ELSE IS FALSE

.GT.F:	MOV	#.NOT.,-(SP)	;TEST OPPOSITE CONDITION, THEN REVERSE
.LE.F:	JSR	PC,CMPF		;COMPARE THE NUMBERS
	BLE	.TRUE		;BRANCH IF TRUE
.FALSE:	CLR	R2		;SET FALSE INDICATION
	BR	.TRUE1		;FINISH UP VIA TRUE

.NE.F:	MOV	#.NOT.,-(SP)	;TEST OPPOSITE CONDITION, THEN REVERSE
.EQ.F:	JSR	PC,CMPF		;COMPARE THE NUMBERS
	BNE	.FALSE		;ELSE FALSE
.TRUE:	MOV	#-1,R2		;SET TRUE INDICATION
.TRUE1:	ADD	#FLTLE2-2,R1	;CORRECT STACK
.TRUE2:	MOV	R2,(R1)		;AND REPLACE THE THIRD
	RTS	PC		;AND RETURN

;	STRING COMPARE AND STRING RELATIONALS ROUTINES

.LE.S:	MOV	#.NOT.,-(SP)	;TEST OPPOSITE CONDITION, THEN REVERSE
.GT.S:	JSR	PC,CMPS		;COMPARE THE STRINGS
	BGT	.TRU		;BRANCH IF TRUE CONDITION
	BR	.FLS

.GE.S:	MOV	#.NOT.,-(SP)	;TEST OPPOSITE CONDITION, THEN REVERSE
.LT.S:	JSR	PC,CMPS		;COMPARE THE STINGS
	BGE	.FLS		;BRANCH IF FALSE
.TRU:	MOV	#-1,R2		;SHOW TRUE CONDITION
	BR	.FLS1		;AND CONTINUE

.NE.S:	MOV	#.NOT.,-(SP)	;TEST OPPOSITE CONDITION, THEN REVERSE
.EQ.S:	JSR	PC,CMPS		;DO THE COMPARE
	BEQ	.TRU		;BRANCH IF THE SAME
.FLS:	CLR	R2		;SHOW FALSE CONDITION
.FLS1:	MOV	R1,R0		;COPY THE STACK POINTER
	ADD	(R0),R0		;SKIP DOWN ONE
	ADD	(R0),R0		;DOWN TWO STRINGS
	SUB	SPDA,R0		;MAKE RELATIVE AGAIN
	MOV	R0,@SPDA	;AND STORE IT AWAY
	ADD	#STRLEN*2-2,R1	;REMOVE THE STRING POINTERS
	BR	.TRUE2		;STORE VALUE ON R1 STACK

.EV.S:	JSR	PC,CMPS		;SEE HOW THEY COMPARE
	BCC	.FLS		;NOT IDENTICAL
	BR	.TRU		;ELSE SHOW TRUE

RESTOR:	MOV	SPDA,R2		;GET A DATA AREA POINTER
	MOV	@SPTA,DATHDR(R2);STORE FIRST POSSIBLE DATA STATEMENT
	CLR	DATCNT(R2)	;CLEAR BYTES LEFT
	RTS	PC		;AND RETURN

READI:	JSR	R4,READER	;CALL COMMON READ PROCESSOR
	+	INPUTI		;JUST LIKE INPUT--HUH

READF:	JSR	R4,READER	;CALL READ ROUTINE
	+	INPUTF		;DO LIKE INPUTF

READS:	JSR	R4,READER	;CALL READ ROUTINE
	+	INPUTS		;PROCESSING ROUTINE ADDRESS

READ09:	ERROR	ODD,FATAL	;OUT OF DATA

READER:	MOV	SPDA,R2		;GET A DATA AREA POINTER
	MOV	#BASE,CURRIO(R2);SET UP SOME KIND OF FUNNY IO!
	MOV	R2,R3		;COPY SPDA
	ADD	#BASE+CURLOC,R3	;WE'LL USE R3 A LOT
	MOV	DATPTR(R2),(R3)	;STORE CURRENT LOCATION
	ADD	SPTA,(R3)	;MAKE ABSOLUTE
	SUB	R3,(R3)		;MAKE RELATIVE TO CURLOC
	ADD	#CURLOC,(R3)	;NOW TO THE HEADER ITSELF
	MOV	DATCNT(R2),-(R3);NOW MOVE THE COUNTER
	BEQ	READ05		;BRANCH IF NEXT DATA STATEMENT NEEDED
	JSR	PC,@(R4)+	;GO PROCESS AS INPUT
READ01:	MOV	BYTCNT(R4),CNTBAS(R4)	;STORE REMAINING COUNT
	MOV	CURLOC(R4),(SP)	;PUT THE POINTER ON OLD R4
	ADD	R4,(SP)		;MAKE ABSOLUTE
	SUB	SPTA,(SP)	;AND NOEW RELATIVE TO THE TEXT
	MOV	(SP)+,PTRBAS(R4)	;STORE THE NEW POINTER
ENDI01:	CLR	BYTCNT(R4)	;EMPTY THE BUFFER FOR NOW
	RTS	PC		;AND RETURN

READ05:	MOV	DATHDR(R2),R0	;GET RELATIVE HEADER ADDRESS
	ADD	SPTA,R0		;MAKE ABSOLUTE
READ06:	TST	(R0)		;SEE IF THE END OF THE ROAD
	BEQ	READ09		;BRANCH IF OUT OF DATA
	ADD	(R0),R0		;SLIP DOWN THE CHAIN
	CMPB	#4,TAGTYP(R0)	;SEE IF THIS IS ONE GOODIE
	BNE	READ06		;LOOP IF NO GOOD
	MOV	R0,R3		;SAVE ITS ADDRESS
	SUB	SPTA,R3		;MAKE IT RELATIVE
	ADD	#DATHDR,R2	;GO TO THE DATA ADDRESSES
	MOV	R3,(R2)+	;STORE THE ADDRESS
	MOV	TAGPUL(R0),(R2)	;STORE LENGTH
	DEC	(R2)+		;ADJUST FOR RTS OVERHEAD
	ADD	PNTR(R0),R0	;COMPUTE ADDRESS OF DATA
	SUB	SPTA,R0		;MAKE IT RELATIVE
	INC	R0		;SKIP THE LEADING NEXTS
	MOV	R0,(R2)+	;AND STORE IT FOR LATTER
	BR	READER		;AND GO GET IT NOW


ENDINP:	MOV	SPDA,R4		;GET A DATA AREA POINTER
	ADD	#BASE,R4	;POINT TO THE INPUT BUFFER
	BR	ENDI01		;AND EMPTY IT

INPUTS:	JSR	PC,INPUTC	;SEE IF ANY THERE ETC,ETC
	JSR	PC,BUILDS	;GO SET UP FOR A STRING
	MOV	R3,-(SP)	;SAVE DESTINATION ADDRESS
	JSR	PC,INPUTC	;THIS TIME TO GET ADDRESS OF BUFFER
	MOV	(SP)+,R3	;RESTORE WHERE IT GOES
	MOV	R4,R2		;GET LOCATION OF INPUT STRING
1$:	MOVB	(R2)+,R4	;GET A CHARACTER
	BIC	#-177-1,R4	;MASK OFF PARITY BITS
	BEQ	1$		;IGNORE INITIAL NULLS
	CMPB	R4,#11		;TAB?
	BEQ	1$		;IGNORE INITIAL TABS
	CMPB	R4,#40		;SPACE?
	BEQ	1$		;IGNORE INITIAL SPACES
	CMPB	R4,#''		;SINGLE QUOTE (')?
	BEQ	2$		;YES, USE IT AS DELIMITER
	CMPB	R4,#'"		;DOUBLE QUOTE (")?
	BEQ	2$		;YES, USE IT AS DELIMITER
	MOV	#100000+',,R4	;NOW USE COMMA (,) AS DELIMITER
	DEC	R2		;AND BACK UP TO GET 1ST CHARACTER
2$:	MOVB	(R2),(R3)	;LOAD THE TRIAL CHARACTER
	BICB	#-177-1,(R3)	;AND TRIM ANY PARITY BIT
	CMPB	R4,(R3)		;DELIMITER FOUND?
	BEQ	4$		;YES, CALL IT QUITS
	MOV	#INPLST,R5	;NO, GET END-OF-LINE LIST
3$:	CMPB	(R3),(R5)+	;MATCH IN LIST?
	BEQ	5$		;YES, END IT
	TSTB	(R5)		;MORE IN LIST?
	BNE	3$		;YES, CONTINUE THROUGH WHOLE LIST
	CMPB	(R2)+,(R3)+	;NOW KEEP CHARACTER AND GO TO NEXT TRIAL
	BR	2$		;TRY FOR MORE CHARACTERS

4$:	TST	R4		;WAS THE DELIMITER A COMMA?
	BMI	5$		;YES, SO DON'T BYPASS IT
	INC	R2		;ELSE BYPASS CLOSING ' OR "
5$:	MOV	R2,R4		;SAVE POINTER TO INPUT
	JSR	PC,@(SP)+	;RETURN TO BUILDS
	MOV	(SP)+,R5	;GET IPC BACK
	MOV	(R2),(R1)	;SET UP FOR PUSH OF STRING
	JSR	PC,PUSHS2	;PUT IT ON THE LIST
	MOV	R4,R2		;RESTORE THE INPUT POINTER
	JSR	PC,INPUTT	;CHECK FOR TERMINATOR
	JMP	PSTJS		;COROUTINE TO REMOVE HEADER FROM STRING LIST

INPLLL:	.BYTE	',		;LIST OF TERMINATORS
INPLST:	.BYTE	012,014,015,033,000;LIST OF END-OF-LINES

.ENABL	LSB

INPU00:	JSR	PC,INPUTC	;MAKE SURE THERE'S INPUT TO BE HAD
	MOV	R4,R2		;POINT TO THE BUFFER
	JSR	PC,@(SP)+	;BUILD A NUMBER AS SPECIFIED
	BVS	2$		;BRANCH IF BAD FORMAT
INPUTT:	MOV	SPDA,R0		;GET THE BIAS
	CLR	NVTM(R0)	;SET MATINPUT FLAG TO "FALSE"
1$:	MOVB	(R2)+,R3	;GET THE NEXT CHARACTER
	BIC	#-177-1,R3	;TRIM ANY PARITY BIT
	BEQ	1$		;BRANCH IF NULL
	CMPB	R3,#040		;SEE IF A SPACE
	BEQ	1$		;LOOP FOR MORE IF A SPACE
	CMPB	R3,#011		;SEE IF A TAB CHARACTER
	BEQ	1$		;SKIP TABS TOO
	CMPB	R3,#015		;THE LAST OK NON GOODIE IS <CR>
	BNE	3$		;BR IF NOT CR
	DEC	NVTM(R0)	;IF CR, SET MATINPUT FLAG TO "TRUE"
	BR	1$		;THEN SKIP OVER CR

2$:	CLR	R3		;BADDY, SO FLAG IT
3$:	MOV	SPDA,R4		;GET BACK HEADER FOR -1 BUFFER
	ADD	#BASE,R4	;AT BASE + SPDA
	SUB	R4,R2		;COMPUTE NEW CURLOC
	SUB	CURLOC(R4),R2	;CALCULATE BYTES USED
	ADD	R2,CURLOC(R4)	;STORE IT AWAY FOR NEXT TIME
	SUB	R2,BYTCNT(R4)	;AND ADJUST THE COUNT ACCORDINGLY
	MOV	#INPLLL,R2	;GET TERMINATOR LIST
10$:	CMPB	R3,(R2)+	;COMMA IS A GOOD ONE
	BEQ	5$		;O.K., BUT DON'T CLEAR THE BUFFER
11$:	CMPB	R3,(R2)+	;END-OF-LINE TERMINATORS MATCH?
	BEQ	4$		;O.K., AND CLEAR THE BUFFER
	TSTB	(R2)		;MORE IN LIST?
	BNE	11$		;YES, CONTINUE CHECKING
	NEG	R3		;OTHERS ARE BADDIES
4$:	CLR	BYTCNT(R4)	;CLEAR THE MINUS 1 BUFFER
5$:	MOV	(SP)+,R2	;PICK UP COROUTINE RETURN
	SETERR	BDNERR		;GUESS AT A BAD NUMBER ERROR
	TST	R3		;SEE IF ALL GOOD OR NOT
	BGT	INPC00		;BRANCH IF ALL OK
	BPL	20$		;BRANCH IF REALLY BAD NUMBER ERROR
	SETERR	FMTERR		;OTHER IS BAD FORMAT ERROR
20$:	JSR	PC,(R2)		;REMOVE ITEM FROM R1 STACK VIA COROUTINE
	CMP	(SP),#READ01	;SEE IF CALLED FROM 'READ'
	BEQ	8$		;BRANCH IF SO
;**** WARNING: INPUT & MATINPUT BOTH REQUIRE REMOVAL OF XTRA WORD HERE
	TST	(R1)+		;REMOVE EXTRA CHANNEL # OR MATINP. ADDR
	IOTERR			;BAD FORMAT
	JSR	PC,INPC99	;SEE WHAT SLOT NUMBER IT IS
	BNE	7$		;BRANCH IF NOT THE TTY
	CMP	(SP),#INTERP	;CHECK FOR NORMAL INPUT STATEMENT
	BEQ	6$		;BR IF NORMAL
	TST	(SP)+		;IF MATINPUT, DO
	MOV	(SP)+,(SP)	;SOME HOUSECLEANING
6$:	MOV	SCTH,R5		;GET START OF THE STATEMENT
	TST	LENGTH(R5)	;REALLY A STATEMENT THERE?
	BEQ	7$		;NO, DIE
	JMP	RTSENT		;AND TRY IT AGAIN UNTIL IT'S RIGHT

8$:	IOTERR			;FATAL BAD NUMBERS
7$:	TRAP	FATAL		;TO THE EDITOR

.DSABL	LSB

INPUTI:	JSR	PC,INPU00	;COROUTINE TO START THINGS OFF
	JSR	PC,ATOI		;COROUTINE TO CONVERT INPUT DATA TO INTEGER
	JSR	PC,@(SP)+	;COROUTINE RETURN FROM CONVERSION
	TST	(R1)+		;COROUTINE TO CLEAR STACK IF CONVERSION ERROR
	RTS	PC		;AND OUT

INPUTF:	JSR	PC,INPU00	;START THINGS OFF BY GETTING CHARS
	JSR	PC,ATOF		;NOW TRY TO CONVERT TO FLOATING
	JSR	PC,@(SP)+	;RETURN AFTER CONVERSION
PFTJS:	ADD	#FLTLE2,R1	;POP FLOATER TO J SPACE
	RTS	PC		;THAT'S IT

INPUTL:	JSR	PC,INPUTC	;GET US SOME GOODIES
	MOV	R3,-(R1)	;STORE CHARACTER COUNT
	CLR	BYTCNT(R2)	;EMPTY THE BUFFER
	JSR	PC,BUILDS	;BUILD US A STRING
	MOV	(R1)+,R4	;GET COUNT BACK
	MOV	R0,R2		;GET COPY OF SPDA
	ADD	#BASE,R2	;GO TO TEMP BUFFER
	ADD	CURLOC(R2),R2	;GO TO THE BUFFER
INPL01:	MOVB	(R2)+,(R3)+	;MOVE A BYTE
	SOB	R4,INPL01	;LOOP TILL ALL GONE
	BR	NUM$02		;EXIT LIKE NUM$

INPC80:	CLR	-(R1)		;SLOT # OF 0
	JSR	PC,SSI		;GET ANOTHER LINE
INPUTC:	MOV	SPDA,R2		;GET A DATA AREA POINTER
	ADD	#BASE,R2	;GO TO INPUT BUFFER
	MOV	R2,R4		;COPY HEADER ADDRESS
	ADD	CURLOC(R2),R4	;COMPUTE CURRENT ADDRESS
	MOV	BYTCNT(R2),R3	;GET THE LENGTH REMAINING
	BNE	INPC00		;EXIT NOW IF STUFF THERE
	JSR	PC,INPC99	;SEE IF SLOT 0 AS SOURCE
	BEQ	INPC80		;IF 0 THEN NO ERROR
	ERROR	NEDERR,FATAL	;NOT ENOUGH DATA GIVEN

INPC99:	MOV	SPDA,R2		;GET A DATA AREA POINTER
	ADD	CURRIO(R2),R2	;GO TO THE BUFFFER HEADER
	TSTB	SLOT(R2)	;SEE IF ZERO
INPC00:	RTS	PC		;LET CALLER DECIDE

	.sbttl	VAL	Service for VAL() function

	.enabl	lsb

VAL:	CALL	FASPJS		;Point R2 -> string, R4 -> just beyond it  *C*
	MOVB	(R4),-(SP)	;SAVE THE NEXT CHARACTER
	CLRB	(R4)		;STOP THE SCAN
	MOV	R4,-(SP)	;SAVE ITS ADDRESS
	JSR	PC,ATOF		;CALL FOR CONVERSION
	BVC	2$		;CONVERSION HAD NO ERRORS
	CLR	R2		;WAS AN ERROR--FORCE CALL BELOW
2$:	MOV	(SP)+,R4	;RESTORE THE END ADDRESS
	MOVB	(SP)+,(R4)	;REPLACE THE END NEXT CHARACTER
	CMP	R4,R2		;SEE IF ALL THE STRING SCANNED
	BEQ	1$		;BRANCH IF OK
	ERROR	BDNERR		;BAD FORMAT
1$:	RTS	PC		;AND RETURN

	.dsabl	lsb

	.sbttl	RADIFN	Service for RAD%() function

;						*C*
	.enabl	lsb

RADIFN:	CALL	FASPJS		;Enforce string arg, point R2/R4 -> arg, pop header
	CLR	-(R1)		;Tell RADI "no conversion of underscores to periods"

RAD50::	CALL	RADI		;Attempt the conversion
	BCC	80$		;All OK => exit happily
	ERROR	LOGERR,FATAL	;No match at all:  data format error


RADI::	MOV	R5,-(SP)	;Save IPC
	MOV	R4,-(SP)	;  and byte-beyond-string pointer
	CLR	R3		;Clear accumulator for returned function value
	MOV	#3,R0		;R0 <- 3 (count of chars to be translated)
10$:	MUL	#50,R3		;Shift accumulated result left 1 RAD50 "digit"
	CMP	R2,(SP)		;Argument string exhausted?
	BHIS	50$		;Yes => add nothing (same as "space")
	MOVB	(R2)+,R5	;No:  grab next argument byte for comparisons
	CMPB	R5,#'_		;Underscore?
	BNE	15$		;No => continue
	TST	(R1)		;Yes:  is conversion to periods requested?
	BPL	70$		;No => don't allow a underscore
	MOVB	#'.,R5		;Yes:  convert it
15$:	CMPB	R5,#'?		;They aren't asking for "?", are they?
	BEQ	70$		;Yes => don't allow a question mark
	MOV	#50,R4		;Initialize running probe value
20$:	DEC	R4		;Probe for each value 47 through 0
	BMI	70$		;Woops, out the end with no match => error
	MOV	R4,-(R1)	;Feed instantiated probe value to R50DGT
	CALL	R50DGT		;Convert probe value to RAD50
	CMP	(R1)+,R5	;Match?
	BNE	20$		;Not yet => go try next probe value
40$:	ADD	R4,R3		;Match:  add in probe as next RAD50 "digit"
50$:	SOB	R0,10$		;Loop for translation of 3 characters
	MOV	R3,(R1)		;Done:  return accumulated value on R1 stack
60$:	TST	(PC)+		;Pass back carry clear for "success"
70$:	SEC			;Pass back carry set for "error"
	MOV	(SP)+,R4	;Restore R4
	MOV	(SP)+,R5	;  and IPC
80$:	RETURN

	.dsabl	lsb

	.sbttl	FASPJS	Common front-end for servers taking a string argument

;+
;  FASPJS	Common front-end for servers taking a string argument      *C*
;
;  Input:	One string argument on the R1 stack
;
;  Output:	Function mask checked and popped from R1 stack
;		R2 -> first byte of argument string, absolutely
;		R4 -> first byte beyond argument string, absolutely
;		String's header popped from R1 stack
;		   and removed from string list
;
;  Registers:	others preserved
;
;  SUCJS	Alternate entry, INTFUN already called
;		  (in which case arguments are one string, one integer)
;		  CVSS is called before setting R2/R4 and popping header
;-

	.enabl	lsb

SUCJS::	CALL	CVSS			;Apply CVT$$() conversions
	BR	10$			;Continue with common code

FASPJS::CALL	INTFAS,R5		;Demand a single string argument
10$:	MOV	PNTR(R1),R2		;R2 -> argument string, relatively
	ADD	R1,R2			;R2 -> argument string, absolutely
	MOV	LENGTH(R1),R4		;R4 <- length of argument string
	ADD	R2,R4			;R4 -> beyond arg string, absolutely
	CALLR	PSTJS			;Header off R1S and out of string list

	.dsabl	lsb

	.sbttl

NUM1$:	MOV	#$PLSIG,$.PLCS	;SET UP MAXIMAL PRINT DESCRIPTOR
NUM$:	JSR	R5,INTFAF	;CALL THE FUNCTION ENTRY DUDE
NUM$00:	MOVB	#$PLSIG+5.,R3	;MAXIMUM LENGTH
	JSR	PC,BUILDS	;GO MAKE A STRING
	MOV	R3,-(SP)	;SAVE THE ADDRESS
	JSR	PC,NUM$XX	;GO DO THE NECESSARY PRINT CONVERSION
	MOV	(SP)+,R3	;RESTORE THE BUFFER ADDRESS
1$:	MOVB	(R2)+,(R3)+	;STORE A CHARACTER
	BNE	1$		;LOOP TILL THE END
	DEC	R3		;BACK UP TO THE NULL
NUM$02:	MOV	SPDA,R0		;RESTORE R0 TO SPDA POINTER
	JSR	PC,@(SP)+	;CO-ROUTINE BACK TO BUILDS
	MOV	(SP)+,R5	;RESTORE IPC
	MOV	(R2),(R1)	;SET UP LINK
	JMP	PUSHS2		;AND PUSH AND EXIT

NUM$XX::JSR	PC,PRINTA	;DO PRINT CONVERSION
	CMP	$.PLCS,..SIG.	;WAS THIS A SPECIAL CONVERSION?
	BEQ	20$		;NO
	MOV	R2,R3		;YES, COPY THE POINTER
	CMPB	(R2)+,#40	;A LEADING <SPACE>?
	BEQ	10$		;JUNK IT IF SO
	DEC	R2		;ELSE KEEP THAT LEADING - SIGN
10$:	TSTB	(R3)+		;UP TO THE END YET?
	BNE	10$		;NOPE...
	CLRB	-2(R3)		;YES, DELETE THE TRAILING <SPACE>
	MOV	..SIG.,$.PLCS	;RESTORE THE DEFAULT PRINT DESCRIPTOR
20$:	RETURN			; AND EXIT

SAVEM:	MOV	R3,-(SP)	;SAVE R4,R3,R2,R0
	MOV	R2,-(SP)
	MOV	R0,-(SP)
	JMP	(R4)		;RETURN

.ENABL	LSB

IFPOS0:	CLR	XRB+XRCI	;SELECT CHANNEL #0
	.POSTN			;AND FIND CURRENT POSITION
	TST	XRB+2		;IS CARRIAGE ALREADY RESTORED?
	BEQ	SSOCH0		;YES
	MOV	#CRLF,-(SP)	;NO, SO RETURN THRU "PRINT CR-LF" ROUTINE
	BR	SSOCH0		;NOW SET UP FOR CHANNEL ZERO

SSONRC:	JSR	PC,SSO		;DO THE REAL SSO PART
	ADD	R2,R3		;MAKE POINTER ABS
	TST	LENGTH(R3)	;IS THE CHANNEL OPEN?
	BNE	30$		;YES
SSOREE:	ERROR	NOTOPN,FATAL	;NO, NOT OPEN

SSOREC:	MOV	(R1)+,-(SP)	;SAVE "RECORD" VALUE
	JSR	PC,SSONRC	;NOW DO THE NON-RECORD PART
	ADD	R2,R3		;MAKE POINTER ABS
	MOVB	#FLGRND/400+FORCE,-(SP);FOR THIS TO BE LEGAL
	BICB	FLAGS(R3),(SP)+	;BOTH OF THESE BITS MUST BE ON
	BEQ	10$		;BOTH WERE ON, SO EXIT O.K.
	ERROR	NORACS,FATAL	;ELSE FATAL TYPE ERROR

SSO:	CMP	(R1),#12.	;SEE IF IN RANGE
	BLOS	SSO01		;BRANCH IF USER CHANNEL
	CMP	RUNLVL,#1	;ONLY EDITOR ALLOWED UP HERE
	BEQ	SSO01		;THIS IS HIM, SO ALLOW ACCESS
	ERROR	BSERR,FATAL	;USER TRYING TO SCREW US. NOT THIS TIME!

SSOCH0:	CLR	-(R1)		;USE CHANNEL #0 FOR THIS SELECTION
SSO01:	MOV	(R1)+,R3	;ALTERNATE ENTRY POINT *****
	ASH	#4,R3		;MAKE IT (SLOT * 8) AND A WORD INDEX
	ADD	#BASE+IOLEN,R3	;AND SKIP OVER THE CONSTANT STUFF
	MOV	SPDA,R2		;GET THE PDA POINTER
	MOV	R3,CURRIO(R2)	;STORE THE BUFFER HEADER ADDRESS
	ADD	R2,R3		;MAKE POINTER ABS
	MOV	CURBLK(R3),-(SP);SAVE CURRENT CURRENT BLOCK
	BITB	#FORCE,FLAGS(R3);FORCE TYPE DEVICE?
	BEQ	20$		;NOPE, LEAVE CURRENT BLOCK ALONE
	CLR	(SP)		;YEP, SO CLEAR CURRENT BLOCK
10$:	CLRB	CURBKM(R3)	; IN BOTH PLACES
20$:	MOV	(SP)+,CURBLK(R3);INSTALL CORRECT CURRENT BLOCK
30$:	SUB	R2,R3		;MAKE POINTER REL AGAIN
	RTS	PC		;AND EXIT

.DSABL	LSB

.ENABL	LSB

CLOSER:	TST	(R1)		;CHECK CHANNEL #
	BPL	CLOSNT		;>=0 IS NORMAL CLOSE
	NEG	(R1)		;<0 IS RESET CLOSE, MAKE POSITIVE
	MOV	#70$,-(SP)	; AND MARK AS RESET CLOSE
CLOSNT:	TST	(R1)+		;SEE IF TTY
	BEQ	70$		;EXIT NOW IF NOTHING TO DO
	TST	-(R1)		;ELSE GET BACK THE CHANNEL #
	JSR	PC,SSO		;CALCULATE BUFFER ADDRESS
CLSR09:	MOV	R2,R0		;COPY SPDA
	ADD	R3,R0		;ABSOLUTE TO IOB
	TST	LENGTH(R0)	;SEE IF SLOT IS OPEN
	BEQ	70$		;BRANCH IF NO WORK TO DO
	CMP	(SP),#NTHENT	;NO "THENT" CALL THIS CLOSE?
	BEQ	10$		;YES, SO SKIP CALLING "THENT"
	MOV	#THENT,-(SP)	;NO, DE-ALLOCATE BUFFER WHEN DONE
10$:	MOV	R3,-(SP)	;SAVE RELATIVE ADDRESS OF HEADER
	ADD	R2,R3		;MAKE ABSOLUTE
	MOV	SLOT(R3),-(SP)	;SAVE SLOT/FLAGS ON STACK
	CMP	6(SP),#70$	;IS THIS THE RESET CLOSE?
	BEQ	50$		;YES, JUST GO DO IT
	BIT	#WRTARY*256.,(SP);SEE IF MEDDLED BIT IS ON
	BEQ	50$		;BRANCH IF EASY THIS TIME
	MOV	BYTCNT(R3),R4	;GET # BYTES USED UP
	BEQ	30$		;IF NONE, THEN NO FILLING
	CLR	CURBLK(R3)	;THIS WAS A SERIAL ACCESS
	CLRB	CURBKM(R3)	; IN BOTH PLACES
	SUB	LENGTH(R3),R4	;ELSE FIND -# TO BE FILLED
	BEQ	30$		;IF NONE THEN EASY
	MOV	R3,R0		;IF SOME, THEN GET HEADER ADDRESS
	ADD	CURLOC(R3),R0	;AND GET CURRENT LOC TO FILL
20$:	CLRB	(R0)+		;THEN NULL FILL UNTIL
	INC	R4		;MORE?
	BNE	20$		;YEP
30$:	BIT	#FORCE*400,(SP)	;LINE BY LINE?
	BNE	40$		;YES
	MOV	LENGTH(R3),BYTCNT(R3)	;NO, WHOLE BUFFER MUST GO
40$:	TST	BYTCNT(R3)	;ANY DATA TO SEND?
	BEQ	50$		;NOPE, SO DON'T TRY TO OUTPUT ANY...
	JSR	PC,PRL14	;CALL FOR OUTPUT SERVICE
50$:	JSR	PC,GETBUF	;GET A FIRQB
	CMP	(R4)+,(R4)+	;SKIP TO SLOT NUMBER
	MOVB	(SP)+,(R4)	; AND SET SLOT
.IIF	NE	FQFIL-4, .ERROR	;THE ABOVE WON'T WORK
	CLRB	-(R4)		;THE FUNCTION IS "CLOSE"
.IIF	NE	CLSFQ,	.ERROR	;THE ABOVE WON'T WORK
.IIF	NE	FQFIL-1-FQFUN, .ERROR ;THE ABOVE WON'T WORK
	CMP	4(SP),#70$	;RESET CLOSE?
	BNE	55$		;NO
	MOVB	#RSTFQ,(R4)	;YES
55$:	JSR	PC,FIPCAL	;CALL FIP PROCESSOR
	BEQ	60$		;SEE IF ANY TROUBLE WITH CLOSE
	IOTERR	!FATAL		;THERE WAS...

60$:	CLR	R0		;ZERO BUFFER LENGTH
	MOV	(SP)+,R2	;SET UP R2 FOR BUFFER ALLOCATOR
70$:	RTS	PC		;NOW EXIT

.DSABL	LSB

SSI:	JSR	PC,SSO		;GO SELECT AND SET UP CURRIO
SSIX1:	ADD	R2,R3		;COMPUTE ADDRESS OF I/O HEADER
	ADD	#BASE,R2	;R3 IS FOR THE INPUT LINE
	TST	LENGTH(R3)	;SEE IF FILE OPEN
	BEQ	SSOREE		;NOT OPEN!
	TST	BYTCNT(R2)	;SEE IF IT'S EMPTY
	BGT	3$		;BRANCH IF NOT QUITE EMPTY
	MOV	PNTR(R2),CURLOC(R2)	;SET UP CURLOC FOR THE EXIT
	CLR	BYTCNT(R2)	;ZERO THE BYTE COUNT
3$:	JSR	PC,SSI031	;NOW GET THE CHARACTER
SSI01:	BEQ	10$		;FLUSH AWAY THE NULLS
	CMPB	#177,(R0)	;SEE IF RUBOUT
	BEQ	10$		;IF SO TOO BAD FOR IT
	CMPB	#015,(R0)	;SEE IF <CR>
	BEQ	SSI02		;BRANCH IF A <CR>
	CMPB	#033,(R0)	;SEE IF <ESC>
	BEQ	SSI08		;BRANCH IF FOUND
	CMPB	#14,(R0)	;IS IT FORM FEED?
	BEQ	SSI08		;YES
	CMPB	#32,(R0)	;IS IT A ^Z
	BEQ	SSI15		;YES--STOP FEED CHARS AND GIVE EOF
	CMPB	#12,(R0)	;IS IT A <LF>?
	BEQ	SSI021		;BRANCH IF <LF>
	JSR	PC,SSI110	;STASH AWAY THAT CHARACTER
10$:	JSR	PC,SSI001	;AND GET NEXT CHARACTER
	BR	SSI01		;AND GO CHECK IT OUT

SSI110:	INC	R0		;GO TO THE NEXT CHARACTER IN THE OUTPUT BUFFER
	INC	BYTCNT(R2)	;SHOW THE MOVED CHARACTER
	CMP	BYTCNT(R2),LENGTH(R2)	;SEE IF ANY ROOM LEFT
	BLO	11$		;BRANCH IF OK
	CLR	BYTCNT(R2)	;CLEAR ANY TTY INPUT NOW
	JSR	PC,SSI11	;CLOSE OUT THE CREATION OF THE BUFFER
	ERROR	LINERR		;TELL PEOPLE THAT IT'S TOO LONG
	TST	(SP)+		;DUMP THE RETURN AND DO FINAL EXIT
11$:	RTS	PC

SSI876:	JSR	PC,RDSER	;GET A BUFFER'S WORTH
SSI031:	MOV	R2,R0		;COPY THE TWO
	MOV	R3,R4		;  BUFFER HEADER POINTERS
	ADD	CURLOC(R0),R0	;R0 HAS BUFFER ADDRESS
	ADD	BYTCNT(R2),R0	;ADJUST FOR PARTIAL BUFFER
	ADD	CURLOC(R4),R4	;R4 IS FOR THE LINE TO BE
SSI001:	DEC	BYTCNT(R3)	;SEE IF ANY INPUT LEFT
	BLT	SSI876		;BRANCH IF I/O REQUIRED
	MOVB	(R4)+,(R0)	;MOVE THE CHARACTER
	BICB	#200,(R0)	;CLEAR THE PARITY BIT ON TAPE
	RTS	PC		;ELSE EXIT

SSI02:	JSR	PC,SSI110	;STASH THE <CR> IN BUFFER
	JSR	PC,SSI001	;GET THE NEXT CHARACTER
	BEQ	10$		;NEXT IS <NULL>, DUMP IT
	IF	(R0),EQ,#12,SSI08,B;IF NEXT IS <LF> THEN END OF LINE
	BR	SSI01		;ELSE CONTINUE

10$:	DEC	BYTCNT(R2)	;CORRECT SINCE WE WILL
	MOVB	(R0),-(R0)	;REMOVE THE <CR> FROM BUFFER
	BR	SSI01		;CHECK THE LAST INPUT CHAR

SSI021:	JSR	PC,SSI110	;STASH THE <LF> IN THE BUFFER
	MOVB	#15,(R0)	;PUT <CR> INTO BUFFER
	JSR	PC,SSI110	;STASH THE <CR> IN THE BUFFER ALSO
	CLRB	(R0)		;NULLSVILLE
SSI08:	INC	BYTCNT(R2)	;SHOW THE FINAL <LF>
SSI11:	SUB	R3,R4		;THE NEW CURLOC
	TST	BYTCNT(R3)	;SEE IF FORCED BUFFER(OR EMPTY)
	BGT	5$		;IF STILL SOME THERE BRANCH
	MOV	PNTR(R3),R4	;ELSE SHOW THE START OF THE BUFFER
5$:	MOV	R4,CURLOC(R3)	;STORE IT AWAY
	RTS	PC		;AND RETURN

RDSER:	CLR	CURBLK(R3)	;SERIAL READ
	CLRB	CURBKM(R3)	; IN BOTH PLACES
SSI04:	CLR	BYTCNT(R3)	;EMPTY OUT THE BUFFER
	MOV	#-1,R4		;SET EDITOR WAIT
	CMP	RUNLVL,#1	;SEE IF EDITOR OR USER
	BEQ	SSI07		;BRANCH IF NOT OUTPUTTING A ?
	MOV	SPDA,R4		;GET DATA AREA POINTER
	MOV	WAITTM(R4),R4	;GET USER SPECIFIED WAIT INTERVAL
	BPL	1$		;POSITIVE IS OK
	CLR	R4		;BUT NOT NEGATIVE TIMES
1$:	TSTB	SLOT(R3)	;SEE IF SLOT 0
	BNE	SSI07		;IF NOT THEN NO ?
	MOV	R2,-(SP)	;AND SAVE R2
	MOV	#PROMPT,R2	;SET UP THE ?
	.TTRST			;ELIMINATE ^O EFFECT
	JSR	PC,PRINTL	;PRINT IT
	MOV	(SP)+,R2	;GET BUFFER HEADER POINTER BACK
SSI07:	MOV	PNTR(R3),CURLOC(R3)	;START AT THE BEGINNING OF THE LINE
	JSR	PC,READ.	;GET LINE
SSIDN:	MOV	SPDA,-(SP)
	ADD	#RECOUN,(SP)
	MOV	BYTCNT(R3),@(SP)+
	MOV	PNTR(R3),CURLOC(R3);START AT THE BEGINNING OF THE BUFFER
	BICB	#WRTARY,FLAGS(R3);SAY NO MEDDLING YET
	TSTB	JOBF		;SEE IF ^C TYPED
	BMI	SSI10		;BRANCH IF TIME TO EXIT
	TST	IOSTS		;SEE IF EOF-MAYBE
	BEQ	OPNRTS		;IF NO ERROR, THEN EXIT
	CLR	BYTCNT(R3)	;IF ERROR, CLEAR OUT BUFFER
	BR	SSI12		;AND SET THE ERROR

SSI15:	SETERR	EOF		;TIME TO GIVE AN EOF
	CLR	BYTCNT(R2)	;CLEAR BUFFER FIRST
SSI12:	IOTERR			;LOG THE ERROR AND HANDLE IF SO REQUESTED
	CMP	RUNLVL,#1	;SEE IF EDITOR OR RTS CALLING
	BNE	SSI13		;BRANCH IF THE USER
SSI14:	JMP	EDERRN		;GO TO TERMINATE THE OLD COMMAND

SSI13:	TRAP	FATAL		;GO TO EDERR IF EDITOR

SSI10:	CLR	BYTCNT(R3)	;CLEAR BUFFER IF CTRL/C
	CMP	RUNLVL,#1	;SEE IF EDITOR CALLING
	BEQ	SSI14		;IF EDITOR LEAVE THIS WAY
	CMP	-(R1),(SP)+	;BACK R1 FOR SLOT AND DUMP RETURN ADDRESS
	DEC	R5		;BACK UP IPC LIKE NATHAN DOES TO US
	JMP	SHUTUP		;AND STOP NICELY

; OPNRPM - THIS SETS UP FOR AN OPEN/CREATE BASED ON:
;
;	R1 ->	MODE
;		FILE SIZE
;		CLUSTER SIZE
;		RECORD SIZE
;		CHANNEL NUMBER
;		LINK OF STRING
;		PNTR OF STRING
;		LENGTH OF STRING

OPNRPM:	MOV	10(R1),-(R1)	;COPY CHANNEL # FOR CLOSE
	JSR	PC,CLOSNT	;NOW CLOSE OFF THE CHANNEL
NTHENT:				; WITHOUT COLLAPSING THE BUFFER
	ADD	#10,R1		;NOW INDEX TO CHANNEL #
	MOV	(R1),R2		;GET THE CHANNEL NUMBER AND
	ASL	R2		; DOUBLE IT
	MOV	-6(R1),(R1)	;MOVE FILE SIZE HERE NOW
	MOV	-(R1),-(SP)	;SAVE RECORD SIZE ON SP STACK
	BIC	#1,(SP)		; MAKING IT EVEN FOR "THENT"
	MOV	-6(R1),(R1)	;MOVE MODE HERE NOW
	TST	-(R1)		;BACK UP TO COVER THE CLUSTER SIZE

;	R1 ->	CLUSTER SIZE
;		MODE
;		FILE SIZE
;		LINK OF STRING
;		PNTR OF STRING
;		LENGTH OF STRING

	JSR	PC,OPNRR1	;SCAN USING R1 STACK PARAMETERS
	MOV	(SP)+,-(R1)	;NOW PUT BUFFER SIZE HERE FOR LATER
OPNRTS:	RTS	PC		;AND EXIT

FIPCAL:	CALFIP			;DO THE MONITOR EMT
	BR	IOERT		;RETURN USEFUL BIT

GETBUF:	MOV	#FIRQB+FQBSIZ,R4 ;TO CLEAR
	MOVB	JOB,-(SP)
1$:	CLR	-(R4)		;CLEAR ONE
	CMP	R4,#FIRQB	;DONE?
	BHI	1$		;NOT YET
	MOVB	(SP)+,FQJOB(R4)	;RESTORE JOB
	RTS	PC

.SBTTL	READ. AND WRITE. IO ROUTINES
;	BOTH ARE CALLED WITH AN ABSOLUTE IOB POINTER IN R3
;	THEY TRANSFER ALL REQUIRED PARAMETERS TO THE XRB
;	AND EXECUTE THE APPROPRIATE MONITOR CALL
;	THEY ASSUME THAT CURBLK/CURBKM IS SET TO 0(SERIAL) OR BLOCK NUMBER
;	THE BLOCK NUMBER IS ALWAYS LEFT IN THE IOB
;	CALL WITH JSR PC

.ENABL	LSB

REA.D:	MOV	#20$,-(SP)	;INOUT SELECTION AT 20$
IOXX:	MOV	R0,-(SP)	;GET A WORKING REGISTER
	MOV	#XRB,R0		;TO USE FOR XRB POINTING
	MOV	(SP),(R0)+	;SET BUFFER SIZE @ XRLEN (FROM R0)
	MOV	R2,(R0)+	;SET COUNT @ XRBC (FROM R2)
	MOV	R4,(R0)+	;SET POINTER @ XRLOC (FROM R4)
	MOV	SPDA,R4		;GET DATA BASE AND THE
	MOV	WAITTM(R4),R4	; WAIT TIME FOR TERMINALS
	BPL	10$		;O.K., USE IT
	CLR	R4		;<0, FORCE IT TO 0 THEN
	BR	10$		;NOW JOIN THE COMMON CODE

WRITE.:	MOV	#30$,-(SP)	;INOUT SELECTION AT 30$
IO:	MOV	R0,-(SP)	;GET A WORKING REGISTER
	MOV	#XRB,R0		; TO USE AS AN XRB POINTER
	MOV	R3,XRLOC(R0)	;MAKE A RELATIVE POINTER
	TST	(R3)+		;SKIP LINK
	ADD	(R3)+,XRLOC(R0)	;NOW MAKE POINTER ABSOLUTE
	MOV	(R3)+,(R0)+	;BUFFER LENGTH @ XRLEN
	MOV	(R3)+,(R0)+	;BYTE COUNT @ XRBC
	CMP	(R3)+,(R0)+	;SKIP CURLOC AND XRLOC
10$:	MOVB	(R3)+,(R0)+	;CHANNEL INDEX @ XRCI
	CMPB	(R3)+,(R3)+	;SKIP OVER FLAGS AND POSITN
	MOVB	(R3)+,(R0)+	;0 (SERIAL) OR BLOCK (MSB)
	MOV	(R3),(R0)+	;0 (SERIAL) OR BLOCK
	CLR	(R0)+		;NO TIME @ XRTIME
	CLR	(R0)		;NO MODIFIER @ XRMOD
	MOVB	#FLGRND!FLGFRC/400,-(SP);IF BOTH OF THESE ARE ON
	BICB	FLAGS-CURBLK(R3),(SP)+; THEN IT TAKES MODIFIERS
	BNE	2$		;NO TURE, NO MODIFIERS
	MOV	(R3),(R0)	;TURE, SET FOR MODIFIER(S)
2$:	MOV	(SP)+,R0	;RESTORE WORKING REGISTER
	JSR	PC,@(SP)+	;INOUT SELECTION
	BITB	#FORCE,FLAGS-CURBLK(R3);FORCE TYPE DEVICE?
	BNE	1$		;YES, SO DON'T REMEMBER RETURNED VALUE
	MOV	XRB+XRBLK,(R3)	;NO, SO REMEMBER THE VALUE
	MOVB	XRB+XRBLKM,CURBKM-CURBLK(R3) ; IN BOTH PLACES
1$:	SUB	#CURBLK,R3	;BACK UP TO TOP OF IOB
IOERT:	TST	IOSTS		;RETURN ERROR INDICATOR
	RTS	PC

READ.:	JSR	PC,IO		;SET XRB TO IOB PARAMETERS
20$:	CLR	XRB+XRBC	;NONE TO START PROPERLY
	MOV	R4,XRB+XRTIME	;SET TTY INPUT PATIENCE
	.READ			;MONITOR SERVICE
	MOV	XRB+XRBC,BYTCNT-CURBLK(R3)	;RETURNED BYTES
	RTS	PC

WRIT.E:	JSR	PC,IOXX		;SET UP THE XRB
30$:	.WRITE			;DO IT
	RTS	PC		;BACK TO IO TO FINISH

.DSABL	LSB

;+
; THENT - THENT CREATES AND/OR ANNIHILATES SPACE FOR I/O BUFFERS
;	AND ARRAYS. THE SPACE THAT IS NEWLY CREATED IS ALWAYS JUST
;	ABOVE THE PERMANENT VARIABLES IN "STRING" SPACE AND JUST
;	BELOW NEWLY CREATED STUFF.
;
;	R0 =  SIZE DESIRED
;	R1 -> R1 STACK
;	R2 -> HEADER (RELATIVE SPDA)
;	R5 =  IPC
;
;	JSR	PC,THENT
;
;	R0 =  SIZE OBTAINED (EVENED UP)
;	R1 -> R1 STACK
;	R2 -> HEADER (RELATIVE SPDA)
;	R3 =  RANDOM
;	R4 =  SPDA
;	R5 =  IPC
;-

THENT:	MOV	SPDA,R4		;WE WILL NEED SPDA A LOT HERE...
	BIC	#1,R0		;ROUND DOWN SIZE TO AN EVEN NUMBER
	BPL	10$		;O.K. IF SIZE IS < 16K WORDS
	MOV	#077776,R0	;ELSE FORCE A FAILURE LATER
10$:	MOV	R1,R1RING	;SAVE R1
	MOV	R5,R5RING	;SAVE R5
	MOV	R0,-(SP)	;SAVE SIZE OBTAINED ON STACK
	MOV	R2,-(SP)	;SAVE HDR ADDR (REL SPDA) ON STACK
	ADD	R4,R2		;NOW MAKE HDR POINTER ABSOLUTE
	MOV	LENGTH(R2),R5	;SET R5 = OLD LENGTH OF BUFFER
	BNE	20$		;OLD LENGTH <> 0
	CLR	PNTR(R2)	;OLD LENGTH = 0; NO "PNTR" THEN
20$:	MOV	R0,R1		;COPY DESIRED LENGTH TO R1
	SUB	R5,R0		;FIND DELTA LENGTH IN R0
	BLE	30$		;IF SHIRNK OR NO CHANGE THEN CONTINUE
	MOV	PLD(R4),R3	;IF EXPAND THEN GET + LIMIT OF STORAGE
	SUB	PDD(R4),R3	; AND FIND STORAGE STILL LEFT
	CMP	R0,R3		;IS ENOUGH FREE NOW?
	BLE	30$		;YES, ENOUGH IS FREE, CONTINUE
	MOV	R0,-(SP)	;NO, SAVE THE DELTA SIZE
	MOV	R0,STRNOM(R4)	;AND SHOW OUR DIRE NEED FOR SPACE
	SUB	R4,R2		;MAKE HDR POINTER RELATIVE AGAIN
	MOV	R1,-(SP)	;SAVE NEW LENGTH AND
	MOV	R1RING,R1	; BUILD A REAL R1 STACK
	JSR	R5,ECONOM	;CALL FOR MORE SPACE IN THE
	+	STRNOM		; "STRING" SPACE
	MOV	(SP)+,R1	;RESTORE NEW LENGTH
	MOV	R0,R4		;MOVE SPDA OVER TO R4
	ADD	R4,R2		;MAKE HDR POINTER ABSOLUTE AGAIN
	MOV	(SP)+,R0	;RESTORE THE DELTA SIZE
30$:	MOV	PNTR(R2),R3	;GET POINTER (HDR REL) TO BUFFER
	BNE	40$		;GOOD, WE HAVE A "PNTR" ALREADY
	MOV	PSD(R4),R3	;ELSE GET (REL SPDA) ADDR AND
	ADD	R4,R3		; MAKE IT ABSOLUTE AND THEN
	SUB	R2,R3		;  MAKE IT REL TO THE HDR
	MOV	R3,PNTR(R2)	;FINALLY WE HAVE A NEW "PNTR"
40$:	MOV	R1,LENGTH(R2)	;SET NEW LENGTH INTO THE HDR
	BNE	50$		;LENGTH <> 0; KEEP "PNTR"
	CLR	PNTR(R2)	;LENGTH = 0; NO "PNTR"
50$:	ADD	R2,R3		;R3 -> BUFFER ABSOLUTELY

; NOW:	R0	R1	R2	R3	R4	R5
;	CHANGE	NEW LEN	->HDR	->BUF	SPDA	OLD LEN

	MOV	R2,-(SP)	;SAVE ABS POINTER TO HDR
	ADD	R3,R5		;R5 -> OLD END +1
	ADD	R3,R1		;R1 -> NEW END +1

; START OF MAJOR ADJUSTMENT LOOP
;
; NOW:	R0	R1	R2	R3	R4	R5	SP->
;	CHANGE	->NE+1	??	->BUF	SPDA	->OE+1	HDR

60$:	MOV	(R4),R2		;GET (REL) POINTER TO NEXT
	BEQ	170$		;THE END...
	ADD	R4,R2		;MAKE POINTER ABSOLUTE
	CMP	R2,R3		;IS THIS HDR BELOW NEW/OLD BUFFER?
	BLO	140$		;YES, NO HDR ADJUSTMENT
	CMP	R2,R5		;IS THIS HDR ABOVE OLD BUFFER?
	BHIS	80$		;YES, ADJUST THE HDR THEN
70$:	MOV	(R2),(R4)	;WHOOPS, WITHIN OLD BUFFER!
	BEQ	170$		; COLLAPSE LIST; EXIT IF END
	ADD	R2,(R4)		;NOT END, MAKE POINTER ABSOLUTE
	SUB	R4,(R4)		; THEN THE CORRECT RELATIVE VALUE
	BR	60$		;AND LOOP FOR MORE...

; THIS HEADER IS ABOVE CHANGE AREA, BUT ITS PREVIOUS HDR IS
;	BELOW CHANGE AREA. CORRECT THE POINTER.

80$:	ADD	R0,(R4)		;ADJUST HDR POINTER

; THIS HEADER IS ABOVE CHANGE AREA. CHECK FOR ITS BUFFER
;	CROSSING CHANGE AREA.

90$:	MOV	R2,R4		;ESTABLISH A NEW POINTER
	CMP	R4,(SP)		;IS IT OUR CHANGING HDR?
	BEQ	120$		;YES, DON'T TOUCH IT
	ADD	PNTR(R4),R2	;R2 -> THIS HDR'S BUFFER
	CMP	R2,R5		;IS BUFFER ABOVE CHANGE AREA?
	BHIS	110$		;YES, ALL O.K.
	CMP	R2,R3		;IS BUFFER BELOW CHANGE AREA?
	BLO	100$		;YES, RELOCATE POINTER
	ADD	LENGTH(R4),R2	;R2 -> THIS HDR'S BUFFER'S END+1
	CMP	R2,R1		;IS END+1 ABOVE CHANGE?
	BLOS	100$		;NO, JUST RELOCATE
	CLR	LENGTH(R4)	;WITHIN CHANGE, ZAP IT
100$:	SUB	R0,PNTR(R4)	;ADJUST THE BUFFER POINTER
110$:	TST	LENGTH(R4)	;ANY LENGTH?
	BNE	120$		;YES, CARRY ON
	CLR	PNTR(R4)	;NO, SO NO POINTER
120$:	MOV	(R4),R2		;GET REL POINTER TO NEXT
	BEQ	170$		;THE END...
	ADD	R4,R2		;MAKE POINTER ABSOLUTE
	CMP	R2,R5		;IS HDR ABOVE CHANGE AREA?
	BHIS	90$		;YES, NO HDR CORRECTION NEEDED
	CMP	R2,R3		;IS HDR BELOW CHANGE AREA?
	BLO	130$		;YES, CORRECT HDR POINTER
	MOV	(R2),(R4)	;WITHIN! KILL IT
	BEQ	170$		;THE END
	ADD	R2,(R4)		;MAKE THE POINTER ABS THEN
	SUB	R4,(R4)		; CORRECTLY RELATIVE
	BR	120$		;  LOOP...

; THIS HEADER IS BELOW CHANGE AREA, BUT ITS PREVIOUS HDR IS
;	ABOVE CHANGE AREA. CORRECT THE POINTER.

130$:	SUB	R0,(R4)		;ADJUST HDR POINTER

; THIS HEADER IS BELOW CHANGE AREA. CHECK FOR ITS BUFFER
;	CROSSING CHANGE AREA.

140$:	MOV	R2,R4		;ESTABLISH A NEW POINTER
	CMP	R4,(SP)		;IS IT OUR CHANGING HDR?
	BEQ	60$		;YES, DON'T TOUCH IT THEN
	ADD	PNTR(R4),R2	;R2 -> THIS HDR'S BUFFER
	CMP	R2,R3		;IS THIS BUFFER BELOW CHANGE?
	BLO	160$		;IT IS BELOW AS IS HDR, ALL O.K.
	CMP	R2,R5		;IS THIS BUFFER ABOVE CHANGE?
	BHIS	150$		;IT IS ABOVE, RELOCATE POINTER
	ADD	LENGTH(R4),R2	;R2 -> THIS HDR'S BUFFER'S END+1
	CMP	R2,R1		;IS END+1 WITHIN CHANGE?
	BLOS	160$		;NO, ALL O.K.
	CLR	LENGTH(R4)	;YES! COLLAPSE THIS BUFFER
150$:	ADD	R0,PNTR(R4)	;RELOCATE THE BUFFER POINTER
160$:	TST	LENGTH(R4)	;ANY LENGTH?
	BNE	60$		;YES, CARRY ON
	CLR	PNTR(R4)	;NO, SO NO POINTER
	BR	60$		; AND CARRY ON...

; ALL STRING HEADERS HAVE NOW BEEN CHECKED AND FIXED IF NEEDED.
;
; NOW:	R0	R1	R2	R3	R4	R5	SP->
;	CHANGE	->NE+1	??	->BUF	??	->OE+1	HDR
;
; NOW UPDATE THE ARRAY AND I/O HEADER LIST.

170$:	MOV	SPDA,R4		;GET SPDA AGAIN
	ADD	ARYPTR(R4),R4	;GET START OF ARRAY LIST
	BR	190$		;AND GO DO IT

180$:	TST	(R4)		;MORE TO DO?
	BEQ	200$		;NO
	ADD	(R4),R4		;YES, GO TO THE NEXT
190$:	CMP	R4,(SP)		;IS THIS OUR HDR?
	BEQ	180$		;YES, DON'T TOUCH IT
	MOV	R4,R2		;COPY THE POINTER
	ADD	PNTR(R4),R2	;R2 -> ARRAY ITSELF
	CMP	R2,R5		;IS ARRAY BELOW THE CHANGE?
	BLO	180$		;YES, ALL O.K.
	ADD	R0,PNTR(R4)	;NO, ADJUST THE POINTER
	BITB	#ARYIOB,FLAGS(R4) ;I/O BUFFER REALLY?
	BEQ	180$		;NO, AN ARRAY
	ADD	R0,CURLOC(R4)	;YES, CORRECT CURRENT POINTER ALSO
	BR	180$		; THEN LOOP

; ALL ARRAY AND I/O BUFFER HEADERS ARE NOW DONE.
;
; NOW:	R0	R1	R2	R3	R4	R5	SP->
;	CHANGE	->NE+1	??	->BUF	??	->OE+1	HDR
;
; DO THE ACTUAL DATA MOVING NOW.

200$:	TST	(SP)+		;DON'T NEED HDR ANYMORE
	MOV	SPDA,R4		;GET SPDA AGAIN...
	MOV	PDD(R4),R2	;GET DYNAMIC LIMIT
	ADD	R4,R2		; ABSOLUTELY
	TST	R0		;WHICH DIRECTION??
	BEQ	240$		;NOTHING...
	BGT	220$		;EXPANDING

; A COLLAPSE - MOVE FROM OLD END (POPPING) TO NEW END (POPPING)
;	UNTIL WE HAVE MOVED ALL (JUST MOVED DATA @ R2)

210$:	MOV	(R5)+,(R1)+	;MOVE A DATA WORD DOWN
	CMP	R5,R2		;DONE?
	BLOS	210$		;NOT YET...
	BR	240$		;ELSE DONE

; AN EXPAND - MOVE FROM TOP (DATA @ R2) (PUSHING) UP TO
;	A BIAS OF THE DELTA SIZE (PUSHING)

220$:	MOV	R2,R1		;COPY DYMANIC LIMIT
	ADD	R0,R1		;GO TO NEW DYMANIC LIMIT
	CMP	(R2)+,(R1)+	;PRE-INDEX THE POINTERS
230$:	MOV	-(R2),-(R1)	;MOVE A DATA WORD UP
	CMP	R2,R5		;DONE?
	BHI	230$		;NOT YET...

; ALL DONE MOVING THE DATA.

240$:	ADD	R0,PSD(R4)	;CORRECT DATA AREA
	ADD	R0,PDD(R4)	; BASE POINTERS
	MOV	(SP)+,R2	;RESTORE HDR POINTER (REL SPDA)
	MOV	(SP)+,R0	;RESTORE THE OBTAINED SIZE
	MOV	R1RING,R1	;RESTORE R1
	MOV	R5RING,R5	;RESTORE R5
	RTS	PC		;EXIT

OPENI:	JSR	PC,OPNRPM	;CLOSE OLD FILE AND SCAN NEW ONE
	BR	OPNI10		;DO THE OPEN AND ALLOCATE THE BUFFER

OPENO:	JSR	PC,OPNRPM	;CLOSE THE SLOT FIRST AND SCAN THE STRING
OPNO10:	MOVB	#CREFQ,FQFUN(R4);CREATE IT
	BR	OPNI11		;AND GO DO IT

OPNI10:	MOVB	#OPNFQ,FQFUN(R4);TRY TO OPEN IT
OPNI11:	JSR	PC,FIPCAL	;CAL FILE PROCESSOR
	BNE	OPNI91		;IF NOT ZERO IS ALL OVER
OPNI20:	CALL	SAVEFQ		;SAVE FIRQB AFTER OPENS
	MOV	FIRQB+FQBUFL,R0	;GET NEEDED BUFFER SIZE
	TST	(R1)		;BIT 15 =1 IN SUPPLIED BUFFER SIZE?
	BPL	10$		;NO, CHECK SUPPLIED AGAINST NEEDED
	BIC	#100001,(R1)	;YES, TRIM BIT 15 (AND BIT 0)
	BNE	20$		;USE RESULT IF RESULT IS <>0
10$:	CMP	R0,(R1)		;IS NEEDED >= SUPPLIED SIZE?
	BHIS	30$		;YES, SO USE NEEDED SIZE
20$:	MOV	(R1),R0		;NO, USE SUPPLIED SIZE
30$:	TST	(R1)+		;DUMP SUPPLIED SIZE NOW
	MOVB	R2,XCDCHN	;STASH CH# * 2 JUST IN CASE...
	ASH	#3,R2		;MAKE SLOT INDEX TO BUF HDR INDEX POINTER
	ADD	#BASE+IOLEN,R2	;GET BUFFER ADDRESS
	JSR	PC,THENT	;GO TO THE ROUTINE TIM & I SHARE
	CLRB	XCDCHN		;WE GOT OUR BUFFER
	ADD	R4,R2		;GOTO ABSOLUTE BUFFER ADDRESS
	MOV	PNTR(R2),CURLOC(R2)	;MOVE CURLOC
	CLR	BYTCNT(R2)	;AND MAKE IT REAL EMPTY
	MOV	R0,-(SP)	;*A* SAVE R0 (SIZE OF BUF)
	MOV	R2,-(SP)	;*A* AND R2 (SPDA)
	ADD	CURLOC(R2),R2	;*A* GET TO END OF BUFFER TO CLEAR
35$:	CLRB	(R2)+		;*A* CLR 1BYTE AT A TIME FROM END OF BUF TO BEG
	SOB	R0,35$		;*A* R0 = # OF BYTES IN BUF,LOOP UNTIL ALL ZERO
	MOV	(SP)+,R2	;*A* RESTORE R2 (SPDA)
	MOV	(SP)+,R0	;*A* AND R0 (SIZE OF BUF)
39$:	MOV	FIRQB+FQFLAG,STATUS(R4);SAVE STATUS AT OPEN TIME
	MOVB	FIRQB+FQFLAG+1,R4	;GET MONITOR FLAGS
	MOVB	#FLGMOD!FLGFRC/400,-(SP) ;IF BOTH MODIFIERS AND
	BICB	R4,(SP)+	; AND FORCE ARE ON THEN SAY "RANDOM"
	BNE	40$		;NOPE
	BISB	#FLGRND/400,R4	;YES, .OR. IN THE "RANDOM" BIT
40$:	BICB	#-1-FLGFRC-FLGRND-FLGPOS/400,R4	;KEEP THREE OF THEM
	BISB	#ARYIOB,R4	;KEEP THIS ONE
	MOVB	R4,FLAGS(R2)	;NOW THEY ARE IN IOB
	CLR	POSITN(R2)	;CLEAR POSITION AND CURRENT BLOCK MSB
.IIF	NE	CURBKM-POSITN-1, .ERROR ;THE ABOVE WON'T WORK
	CLR	CURBLK(R2)	;NO BUFFER CONTENTS
	RTS	PC		;AND RETURN

OPENIO:	JSR	PC,OPNRPM	;CLOSE SCAN ETC
	MOVB	#OPNFQ,FQFUN(R4);SET TO TRY OPEN
	JSR	PC,FIPCAL	;LET NAT IN ON THE ACTION
	BEQ	OPNI20		;IF OK DO OPEN
	CHKERR	NOSUCH		;SEE IF NOT THERE ERROR
	BEQ	OPNO10		;IF NOT THERE CREATE
OPNI91:	ASH	#3,R2		;MAKE SLOT INDEX TO BUF HDR INDEX POINTER
	BEQ	OPNI90		;AVIOD CHANNEL #0
	ADD	#BASE+IOLEN,R2	;GET BUFFER ADDRESS
	CLR	R0		;NO BUFFER SIZE FOR DEALLOCATE BUFFER
	JSR	PC,THENT	;GO TO THE ROUTINE TIM & I SHARE
OPNI90:	IOTERR	!FATAL		;FILE NOT FOUND

KILLER:	JSR	PC,OPNR20	;GET A FIRQB AND SCAN THE FIRST NAME
	MOVB	#DLNFQ,FQFUN(R4);SET UP TO DELETE BY NAME
KILL01:	JSR	PC,FIPCAL	;INVOKE THE FILE SYSTEM
IODIE:	TST	IOSTS		;ANY ERROR?
	BNE	OPNI90		;BRANCH IF ANY ERROR
	RTS	PC		;AND EXIT IF OK

NAMER:	JSR	PC,OPNR20	;GET A FIRQB AND SCAN THE NAME
	MOV	R4,R3		;SET UP FOR THE SAVE
	ADD	#FQNAM1,R3	;SKIP HOUSKEEPING STUFF
	MOV	#3,R2		;A COUNT OF THE NUMBER OF WORDS TO SAVE
1$:	MOV	(R3)+,-(SP)	;MOVE A WORD
	SOB	R2,1$		;LOOP IF MORE TO DO
	MOV	FQPROT-1(R4),-(SP);ALSO SAVE PROTECTION
	JSR	PC,SCAN		;GET THE SECOND NAME
	MOV	R4,R3		;SET POINTER FOR THE
	ADD	#FQPROT-1+2,R3	;  INSERTION OF TDE FIRST NAME
	MOV	#4,R2		;SET UP THE COUNTER
2$:	MOV	(SP)+,-(R3)	;MOVE A WORD OF THE SECOND NAME
	SOB	R2,2$		;LOOP IF MANY WORDS LEFT
	MOVB	#RENFQ,FQFUN(R4);SET RENAME FUNCTION
	BR	KILL01

SLEEP:	MOV	(R1)+,XRB+XRLEN	;GET # SECONDS TO SNOOZE
	.SLEEP			;ROCK A BYE BABY
	RTS	PC		;EXIT

SAVEFQ::MOV	#FQBSIZ,R0	;GET FIRQB SIZE
10$:	MOVB	FIRQB-1(R0),SFIRQB-1(R0) ;SAVE A BYTE
	SOB	R0,10$		; AND LOOP
	RETURN			;EXIT

UUOXXX:	BIS	#JFWIPE!JFEXIT,JOBF ;SET "WIPE OUT" & "EXIT" BITS
	CMP	LENGTH(R1),#5	;SPECIFYING A NEW DEFAULT RTS?
	BLT	UUOXX0		;NO
	MOV	#FIRQB+FQNAM1,R4 ;YES, GET US A FIRQB POINTER
	MOVB	(R3)+,(R4)+	;NOW LOAD THE
	MOVB	(R3)+,(R4)+	; NEW RTS NAME
	MOVB	(R3)+,(R4)+	;  BOTH
	MOVB	(R3)+,(R4)+	;   PARTS
	MOV	#-1,(R4)+	;SET FLAG FOR "NEW DEFAULT"
	CMP	LENGTH(R1),#6	;DID THEY INCLUDE A "NEW DEFAULT" FLAG?
	BLT	1$		;NO
	TSTB	(R3)+		;YES, DID THEY WANT A NEW DEFAULT?
	BNE	1$		;YES, SO LEAVE THE "NEW DEFAULT" FLAG SET
	CLR	-(R4)		;ELSE CLEAR IT FOR A TEMPORARY SWITCH
1$:	.RTS			;AND SWITCH TO IT...

;AT THIS POINT, WE MAY HAVE FALLEN THRU BECAUSE OF AN ERROR, BECAUSE THEY
;ASKED FOR US, OR BECAUSE WE ARE THEIR DEFAULT.  THE ONLY ODD CASE IS A
;'TEMPORARY SWITCH' TO US FROM ANOTHER RTS, SINCE A .EXIT WOULD NOT LEAVE
;US SITTING HERE.  HENCE, WE HAVE TO SPECIAL CASE 'ENTER <THIS RTS>' BY
;NOT ATTEMPTING .EXIT IF THERE WAS NO ERROR.

	TST	IOSTS		;ANY ERROR?
	BNE	UUOXX0		;YES; JUST CONTINUE
	TSTB	-(R3)		;WAS IT A 'TEMPORARY SWITCH'?
	BNE	UUOXX0		;NO
	BIC	#JFEXIT,JOBF	;YES; JUST WIPE HIM
	BR	UUOXX0		;PROCEED

UUOXIT:	BIC	#JFEXIT!JFWIPE,JOBF ;SAY NO EXIT TO DEFAULT RTS
UUOXX0:	CLR	-(R1)		;CLEAR INTERNAL PP FLAG
	MOV	#RTSRER,(SP)	;CHANGE RETURN ADDRESS TO EDITOR
	JMP	UUOXI0		;AND EXIT NICELY

UUOCON:	JSR	R5,INTFAS	;MAKE SURE ITS A STRING FOR US
	MOV	R1,R3		;COPY THE STACK POINTER
	ADD	PNTR(R1),R3	;NOW POINTER TO REAL STRING DATA
	TST	LENGTH(R1)	;NULL STRING TYPE?
	BEQ	UUOBAD		;IF SO, THAT'S BAD...
	MOVB	(R3)+,R0	;ELSE GET FIRST BYTE FROM HIM
	CMP	R0,#14.		;WITHIN RANGE??
	BLOS	UUOC01		;YEP
UUOBAD::ERROR	BADFUO,FATAL	;NOPE, ERROR AND FATAL AT THAT

UUOC01:	MOV	#XRB,R4		;GET XRB POINTER
	CMP	R0,#4		;IS IT A TTY PSEUDO-EMT?
	BLOS	UUOTTY		;YES
	ASL	R0		;OTHERWISE DISPATCH
	JMP	@UUODSP-5.-5.(R0) ;THRU TABLE

UUOTTC:	MOV	#7,R0		;FUNCTION CODE IS BE 7 (CLEAR INPUT)
UUOTTY:	MOV	R0,(R4)+	;LOAD FUNCTION CODE
	CLR	(R4)+		;XRBC<-0
	CLR	(R4)+		;SKIP XRLOC
	MOV	#TTYHND*400,(R4);TARGET DEVICE TYPE IS TERMINALS
	CMP	LENGTH(R1),#2	;CHECK STRING LENGTH
	BLO	UUOSPC		;ALTER CONSOLE (CH# 0)
	BEQ	1$		;ALTER SPECIFIED CHANNEL
	MOVB	1(R3),XRBC-XRCI(R4);ALTER THIS KB
	COMB	XRBC+1-XRCI(R4)	;SIGNAL SPECIAL KB TO BE ALTERED
1$:	MOVB	(R3),(R4)	;LOAD THE CHANNEL NUMBER
	ASLB	(R4)		; TIMES 2 NOW
UUOSPC:	.SPEC			;PERFORM MAGIC
	BR	IODIE		;CK IOSTS, DIE OR RTS PC

UUODSP:	UUOXIT			;5, EXIT TO EDITOR, NO 'READY'
	UUOFIP			;6, FIP SUB FUNCTIONS
	UUOGET			;7, GET CORE COMMON STRING
	UUOPUT			;8, PUT CORE COMMON STRING
	UUOXXX			;9, EXIT TO EDITOR AND SET UP 'NONAME'
	UUOUSR			;10, USER DEFINED, IF ANY
	UUOTTC			;11, CLEAR TYPE-AHEAD
	UUOFQB			;12, GET SAVED FIRQB DATA
	UUOUS2			;13, USER DEFINED, IF ANY
	UUOCCL			;14, TRY TO DO A CCL
..CCL.	==	.-2	;**PATCH** PLUG IN 'UUOBAD' TO DISABLE CCL'S

	.ENABL	LSB

UUOCCL:	MOV	LENGTH(R1),(R4)	;GET LENGTH +1 OF THE PROPOSED CCL
	DEC	(R4)		; THEN MAKE IT THE REAL LENGTH
	MOV	(R4)+,(R4)+	;PUT CCL LENGTH HERE ALSO
	MOV	R3,(R4)+	;START OF PROPOSED CCL STRING
	.CCL			;TRY TO DO IT
	JMP	IODIE		;(NO ERROR IF NO CCL)

UUOFIP:	MOV	LENGTH(R1),R0	;GET LENGTH IN R0
	DEC	R0		;IS IT MORE THAN 1 BYTE?
	BLE	UUOBAD		;EVIL IF NOT
	JSR	PC,SN		;TRY FOR SPECIAL MESSAGE SEND/RECEIVE
	CMPB	(R3),#-21.	;FORGET ANY TEMP PRIVS?
	BNE	30$		;NO
	MOV	#JFSYS,(R4)	;YES, GUESS AT TEMP DROP/RESTORE
	DEC	R0		;IS THE LENGTH MORE THAN 2 BYTES?
	BGT	61$		;YES, TEMP KIND, CHECK DIRECTION
	MOV	#JFSYS!JFPRIV,(R4) ;FOREVER DROP, SO DO IT
60$:	.CLEAR			;AND DROP THEM
	RTS	PC

30$:	CMPB	(R3),#-20.	;LOCK/UNLOCK IN MEMORY?
	BNE	40$		;NO
	DEC	R0		;STRING 3 BYTES OR MORE?
	BLE	UUOBAD		;NO, ERROR
	MOV	#JFLOCK,(R4)	;YES, THIS IS THE BIT TO USE
61$:	TSTB	1(R3)		;SET OR CLEAR?
	BNE	60$		;<>0 MEANS CLEAR
70$:	.SET			;AND TRY TO SET THEM
	RTS	PC

40$:	MOV	#JFSPRI,(R4)	;ASSUME SPECIAL RUN PRIV'S
	CMPB	(R3),#-22.	;SPECIAL RUN PRIV ?
	BEQ	70$		;YES, NOW TRY TO SET IT
	CMPB	(R3),#-7.	;ENABLE ^C TRAP?
	BNE	4$		;NO
	BIS	#JFCCC,JOBF	;SET THE TRAP ENABLE BIT
	RTS	PC

4$:	CMPB	(R3),#-4	;IS IT FORCE?
	BEQ	10$		;YES
	CMPB	(R3),#-5	;IS IT BROADCAST?
	BNE	20$		;NO
10$:	MOVB	(R3)+,R0	;FUNCTION CODE
	NEG	R0		;-4,-5 TO 5,6
	INC	R0		;TO MATCH OLD CONVENTIONS
	MOV	R0,(R4)+	;PUT TO XRB+XRLEN
	MOV	LENGTH(R1),(R4)	;MAKE THE MESSAGE LENGTH
	SUB	#3,(R4)+	;DON'T COUNT CODE
	BLT	UUOBAD		;NO MESSAGE??
	MOV	R3,(R4)		;SET POINTER AT XRLOC
	INC	(R4)+		;KB BYTE
	MOV	#TTYHND*400,(R4)+ ;HANDLER AND CHANNEL 0 (KB'S)
	MOVB	(R3)+,(R4)	;KB TO DO IT TO
	JSR	PC,UUOSPC	;NOW DO IT
	MOV	SPDA,R2		;GET DATA AREA AND
	MOV	XRB+XRBC,RECOUN(R2) ;SET ANY REMAINING COUNT
	RTS	PC		;NOW EXIT

20$:	JSR	PC,GETBUF	;GET A SMALL BUFFER
	CMPB	(R3),#-23.	;SPECIAL SCANNER?
	BEQ	90$		;YES
	CMPB	(R3),#-10.	;SCAN IS NOW RESIDENT
	BNE	1$		;IF NOT SCAN
90$:	MOVB	(R3),R3		;SET FLAG FOR SCANNER
	JSR	PC,CSI		;PARSE IT
UUOCSI:	BR	UUORET		;RETURN VALUE

1$:	MOV	R4,R2		;COPY THE POINTER
	ADD	#FQFUN,R2	; AND INDEX TO FUNCTION SPOT
	MOV	LENGTH(R1),R0	;MOVE THE STRING TO FIRQB
	DEC	R0		;FOR SOB
	CMP	R0,#FQBSIZ-FQFUN ;DONT MOVE TOO MUCH
	BLOS	2$		;OK
	MOV	#FQBSIZ-FQFUN,R0 ;PLEASE BEHAVE
2$:	MOVB	(R3)+,(R2)+	;MOVE ONE BYTE
	SOB	R0,2$		;MOVE ALL
	CALLX	CHKASD		;GO CHECK FOR ASSIGN/DEASSIGN, ETC.
UUORET:	MOV	#30.,R3		;LENGTH OF THE STRING
	CMPB	(R4)+,(R4)+	;SKIP TO RESULTS

	.DSABL	LSB

UUOG01:	MOV	R3,R2		;LATER WE WILL MOVE THIS MANY
	JSR	PC,BUILDS	;GO ALLOCATE SPACE
	ADD	#STRLEN,R1	;"POP" THE STRING
	TST	R2		;SEE IF DONE BEFORE BEGUN
	BLE	5$		;YES!
2$:	MOVB	(R4)+,(R3)+	;COPY A WORD
	SOB	R2,2$		;LOOP TILL THE JOBS DONE
5$:	JMP	MID6		;FINISH UP AND RETURN

UUOPUT:	MOV	#CORCMN,R2	;GET POINTER TO CORE COMMON
	MOVB	LENGTH(R1),R0	;GET PART OF THE LENGTH
	DECB	R0		;ADJUST FOR SYS FUNCTION BYTE
	MOVB	R0,(R2)+	;MOVE THE LENGTH DOWN THERE
3$:	BLE	UUO999		;IF DONE EXIT
	MOVB	(R3)+,(R2)+	;COPY A BYTE
	DECB	R0		;DECREMENT COUNT
	BR	3$		;AND LOOP FOR MORE

UUOGET:	MOV	#CORCMN,R4	;GET POINTER TO CORE COMMON
	MOVB	(R4)+,R3	;GET THE LENGTH
	BPL	UUOG01		;LENGTH IS 0. TO +127.
	CLR	R3		;IF LENGTH IS OTHER THEN LENGTH=0.
	BR	UUOG01

UUOFQB:	MOV	#SFIRQB,R4	;POINT TO SAVED FIRQB DATA
	BR	UUORET		; AND GO RETURN IT

	TMPORG	SN		;SPECIAL MESSAGE SEND/RECEIVE
SN:	RTS	PC		;NOT UNLESS OVERLAID

	TMPORG	UI		;USER IMPLEMENTABLE UUO #1 (10.)
UUOUSR:	ERROR	BADFUO,FATAL
	UNORG

	TMPORG	UI2		;USER IMPLEMENTABLE UUO #2 (13.)
UUOUS2:	ERROR	BADFUO,FATAL
	UNORG

ASCII:	JSR	R5,INTFAS	;CALL THE PDP-11 FUNCTION INTERPRETER
	MOV	R1,R3		;COPY THE STACK
	ADD	PNTR(R3),R3	;POINTE THE THE STRING
	CLR	-(SP)		;POSSIBLE 0 ANSWER
	TST	LENGTH(R1)	;SEE IF NO STRING
	BEQ	1$
	MOVB	(R3)+,(SP)	;SAVE THE BYTE
1$:	JSR	PC,PSTJS	;POP THE STRING
	MOV	(SP)+,-(R1)	;SAVE THE VALUE
UUO999:	RTS	PC		;AND RETURN THE VALUE AS INTEGER


WAITF:	MOV	SPDA,R2		;GET DATA AREA POINTER
	MOV	(R1)+,WAITTM(R2);SET THE WAIT TIME
ONERR9:	RTS	PC		;AND RETURN

ONERR:	MOVB	(R5)+,-(R1)	;GET ERROR STATEMENT HEADER
	MOVB	(R5)+,-(R1)
	MOV	SPDA,R2		;GET DATA AREA POINTER
	MOV	(R1)+,OEGTLN(R2);STORE FOR ERROR TIME
	BNE	ONERR9		;BRANCH IF NON ZERO
	TST	RUNLVL		;SEE IF HANDLING AN ERROR
	BNE	ONERR9		;EXIT IF NOT AT THE ERROR LEVEL
	MOV	RESLOC(R2),R3	;GET OLD SCTH
	ADD	SPTA,R3		;MAKE IT ABSOLUTE
	MOV	R3,SCTH		;AND STUFF IT INTO SCTH
	MOV	#TRAP!FATAL,-(SP)	;STORE A TRAP VALUE
	BISB	ERRVAL(R2),(SP)	;ADD THE ERROR COUNT
	MOV	SP,PC		;WOW

	.sbttl	RAD50$	Service for RAD$() function

RAD50$:	JSR	R5,INTFAI		;GET ONE INTEGER
	MOV	#3,R3			;3 CHARACTER STRING NEEDED
	JSR	PC,BUILDS		;SO GET IT
	MOV	#CVS3,-(SP)		;SET RETURN TO FINISH UP
	MOV	(R1)+,R2		;PUT VALUE HERE FOR LATER
	.callr	R50A01


;+
;  R50A01	Expand a RAD50 word to 3 ASCII characters         revision *C*
;
;  Input:	(R2) = RAD50 word to be expanded
;		R3 -> area to receive 3 ASCII characters
;
;  Output:	R3 -> beyond third expanded character (fourth byte is nulled)
;
;  Registers:	R2, R4 destroyed
;-

	.enabl	lsb

R50A01:	MOV	#R50A00,R4		;R4 -> table of powers of 50 octal
2$:	CLR	-(R1)			;Make a zero counter
3$:	CMP	R2,(R4)			;Can we divide?
	BLO	4$			;NOPE
	INC	(R1)			;Yes:  count it
	SUB	(R4),R2			;and subtract
	BR	3$			;AND LOOP...


;  ((R1)) = one RAD50 "digit", unconverted

4$:	CALL	R50DGT			;Convert one RAD50 "digit" to ASCII
	MOVB	(R1)+,(R3)+		;Set the character into storage
	MOVB	(R1)+,(R3)		;Maintain trailing null, keep R1S even
	TST	-(R4)			;GET NEXT LIST ITEM
	BPL	2$			;IF THERE IS ONE...
	RTS	PC			;AND EXIT

	.dsabl	lsb

	.sbttl	R50DGT	Convert one RAD50 "digit" to ASCII

;+
;  R50DGT	Convert one RAD50 "digit" to ASCII                revision *C*
;
;  Input:	((R1)) = RAD50 "digit" to be converted
;
;  Output:	((R1)) = converted ASCII character
;
;  Registers:	preserved
;-

	.enabl	lsb

; Table of subtrahends for conversion of one RAD50 "digit"

10$:	.BYTE	00, 340	     ;	-40  Singleton:  RAD50 00 => 40, space
	.BYTE	33, 367	     ;	-11  Singleton:  RAD50 33 => 44, dollar sign
	.BYTE	35, 336	     ;	-42  Singleton:  RAD50 35 => 77, question mark
;	.BYTE	34, 356	     ;	-22  Singleton:  RAD50 34 => 56, period
;				  (34 => 56 case included in "digits" range)
	.BYTE	356	     ;	-22    36-60	 "Digits" range subtrahend
	.BYTE	300	     ; -100    1-101	 "Letters" range subtrahend

	.even



R50DGT:	MOV	R0,-(SP)		;Save R0
	MOV	#10$,R0			;R0 -> table of conversion subtrahends
20$:	CMPB	(R1),(R0)+		;Singleton match?
	BEQ	30$			;Yes => go translate singleton
	CMPB	(R0)+,(R0)		;No:  last singleton table entry?
	BHI	20$			;Not yet => go check next one
	CMPB	(R1),#34		;Yes, a "range" value:  low or high?
	BHIS	30$			;High range => use "digits" subtrahend
	TSTB	(R0)+			;Low range:  use "letters" subtrahend
30$:	MOVB	(R0),R0			;Expand selected subtrahend to a word
	SUB	R0,(R1)			;Translate!
	MOV	(SP)+,R0		;Restore R0
	RETURN

	.dsabl	lsb

	.sbttl

LEN:	JSR	R5,INTFAS	;GO DO FUNCTION MANAGEMENT
LENP3:	JSR	PC,PSTJS	;POP THE STRING
	TST	-(R1)		;GET BACK THE LENGTH
	RTS	PC		;AND RETURN

PEEKF:	JSR	R5,INTFAI	;GET ARG TO BE FIXED
	MOV	(R1),XRB+XRLEN	;WORD TO PEEK AT
	.PEEK			;PICK UP THE CONTENTS
	MOV	XRB+XRLEN,(R1)	;ITS CONTENTS
	JMP	IODIE		;CHECK IOSTS AND RETURN (OR DIE)

SWAPBY:	JSR	R5,INTFAI	;GET AN INTEGER
	SWAB	(R1)		;AND SWAP BYTES
	RTS	PC

ATOI:	CLR	R3		;CLEAR THE NUMBER TO BE
	CLR	R4		;AND THE SWITCHES
1$:	MOVB	(R2)+,R0	;GET A CHARACTER
	BIC	#-177-1,R0	;REMOVE PARITY BIT AND SIDE EFFECT
	SUB	#'0,R0		;REDUCE TO BINARY IF A NUMBER
	BLT	10$		;BRANCH IF + OR - (OR OTHER SPECIAL ONE)
	CMPB	R0,#'9-'0	;SEE IF OUT OF RANGE HIGH
	BGT	10$		;BRANCH IF NON-NUMERIC
	BITB	R4,#4		;SEE IF - SWITCH
	BEQ	2$		;BRANCH IF + NUMBER
	NEG	R0		;NEGATE CURRENT DIGIT
2$:	ASL	R3		;N*2
	BVS	4$		;OVERFLOW CHECK
	MOV	R3,-(SP)	;SAVE FOR LATTER
	ASL	R3		;N*4
	BVS	5$		;OVERFLOW CHECK
	ASL	R3		;N*8
	BVS	5$		;OVERFLOW CHECK
	ADD	(SP)+,R3	;N*8+N*2=N*10
	BVS	4$		;OVERFLOW CHECK
	ADD	R0,R3		;INCLUDE THE CURRENT DIGIT
	BVS	4$		;AND A FINAL OVERFLOW CHECK
	BISB	#1,R4		;SET NUMBERS SEEN
	BR	1$		;AND RESUME THE SCAN

10$:	CMPB	R0,#11-'0	;CHECK CHARACTER FOR <TAB>
	BEQ	1$		;BRANCH TO IGNORE TAB'S
	CMPB	R0,#40-'0	;CHECK CHARACTER FOR <SP>
	BEQ	1$		;BRANCH TO IGNORE SP'S
	CMPB	R0,#'+-'0	;CHECK CHARACTER FOR <+>
	BEQ	20$		;BRANCH IF A + SIGN
	CMPB	R0,#'--'0	;CHECK CHARACTER FOR <->
	BNE	3$		;EXIT IF NOT RECIGNIZED
	BISB	#4,R4		;SET - NUMBER FOR SCANNER ABOVE
20$:	BITB	R4,#3		;SEE IF SIGN IS LEGAL, I.E. ONLY ONE - NO #'S
	BNE	3$		;BRANCH IF END OF THE LINE
	BISB	#2,R4		;SET SIGN ENCOUNTERED
	BR	1$		;RESUME THE SCAN

5$:	TST	(SP)+		;REMOVE TEMP SAVED VALUE
4$:	BISB	#200,R4		;SET V SWITCH
3$:	DEC	R2		;BACK UP TO BAD CHARACTER
	MOV	R3,-(R1)	;STORE THE VALUE
	ASLB	R4		;SET V + C ACCORDINGLY
	RTS	PC		;AND RETURN


;INTEGER NEXT PUSHPOPS

NEXTI:	MOV	#UJ,-(SP)	;SET UP EXIT THRU INTERNAL JUMP
	BR	FXNEXT

NEXTIX:	MOV	#UJX,-(SP)	;SET UP EXIT THRU EXTERNAL JUMP
FXNEXT:	MOV	SPDA,R3		;R3 _ BASE
	IF  NEXDRO(R3),HI,RPTERM(R3),FXNEX3  ;DROP THROUGH IF END OF LOOP & DROP SET
	GWTXT	R0		;1ST ARG INTO R0
	BEQ	CMNEXT		;BRANCH IF NO VARIABLE
	ADD	R3,R0		;BIAS ADDR OF VARIABLE
	GWTXT	R2		;2ND ARG INTO R2
	ASR	R2		;SET CARRY IF INCREMENT OF ONE
	BCC	FXNEX1		;BRANCH IF NOT ONE
	IFZERO	EQ,RPTERM(R3),FXNEX6  ;BR IF DONE LOOPING
	INC	(R0)		;INCREMENT VARIABLE
	BVS	FXNEX7		;BR IF INTEGER OVERFLOW
FXNEX2:	MOV	#-1,RPTERM(R3)	;SET LOOPING FLAG
	CLR	NEXDRO(R3)	;CLEAR DROP THRU FLAG
	RTS	PC

FXNEX1:	ASL	R2		;RESTORE ADDR OF INCREMENT
	ADD	R3,R2		;BIAS ADDR OF INCREMENT
	IFZERO	EQ,RPTERM(R3),FXNEX5  ;BR IF DONE LOOPING
	ADD	(R2),(R0)	;INCREMENT VARIABLE
	BVC	FXNEX2		;BR IF OK
FXNEX7:	ERROR	IOLERR,FATAL	;INTEGER OVERFLOW

FXNEX3:	ADD	#4,R5		;TAKE IPC PAST ARGUMENTS
FXNEX4:	TST	(SP)+		;DON'T EXIT THRU A JUMP
	BR	CMNEXT		;JUST DROP THRU TO INTERP

FXNEX5:	SUB	(R2),(R0)	;DEC CNTRL VARIABLE AT END OF FOR LOOPING
	BR	FXNEX4		;AND JUST DROP THRU

FXNEX6:	DEC	(R0)		;DEC CNTRL VAR AT END OF FOR LOOPING
	BR	FXNEX4		;AND JUST DROP THRU

;FLOATING NEXT PUSHPOPS

NEXTF:	MOV	#UJ,-(SP)	;SET UP EXIT THRU INTERNAL JUMP
	BR	FLNEXT

NEXTFX:	MOV	#UJX,-(SP)	;SET UP EXIT THRU EXTERNAL JUMP
FLNEXT:	MOV	SPDA,R3		;R3 _ BASE
	IF  NEXDRO(R3),HI,RPTERM(R3),FXNEX3  ;DROP THRU  IF END OF LOOP & DROP SET
	GWTXT	R0		;1ST ARG INTO R0
	BEQ	CMNEXT		;BRANCH ON NO VARIABLE
	JSR	PC,PUSHF3	;PUSH VARIABLE
	MOV	R0,-(SP)	;SAVE ITS ABSOLUTE ADDR
	GWTXT	R0		;2ND ARG INTO R0
	ASR	R0		;SET CARRY IF INCREMENT OF ONE
	BCC	FLNEX1		;BRANCH IF NOT ONE
	JSR	PC,PUSHF1	;PUSH ONE
FLNEX2:	IFZERO	EQ,RPTERM(R3),FLNEX5  ;BR IF DONE LOOPING
	JSR	PC,ADDF		;INCREMENT VARIABLE
FLNEX6:	MOV	SPDA,R3		;R3 IS THE BASE REGISTER
	MOV	(SP)+,R0	;RESTORE VARIABLE
	JSR	PC,POPF1	;POP VARIABLE & EXIT
	BR	FXNEX2

FLNEX1:	ASL	R0		;RESTORE INCREMENT ADDR
	JSR	PC,PUSHF3	;PUSH INCREMENT
	BR	FLNEX2

FLNEX5:	JSR	PC,SUBF		;DEC CNTRL VAR AT END OF FOR LOOPING
	MOV	(SP)+,(SP)	;GET RID OF EXIT THRU A JUMP
	CMPB	(R5)+,(R5)+	;SKIP OVER INTERP. JUMP ADDR
	BR	FLNEX6		;RESTORE VARIABLE AND DROP THRU

CMNEXT:	CMPB	(R5)+,(R5)+	;KICK IPC PAST ONE ARGUMENT
	BR	FXNEX2		;BR TO GENERAL EXIT

;INTEGER FOR PUSHPOPS

FORI:	MOV	#PIFJ,-(SP)	;SET UP RETURN THRU INTERN. FALSE JUMP
	BR	FXFOR

FORIX:	MOV	#PIFJXN,-(SP)	;SET UP EXTERNAL "FOR" FALSE JUMP
FXFOR:	CLR	-(R1)		;TRUTH VALUE TO FALSE
	GWTXT	R0		;VARIABLE ADDR INTO R0
	ADD	SPDA,R0		;BIAS IT
	GWTXT	R2		;2ND ARG INTO R2
	ADD	SPDA,R2		;BIAS IT
	ASR	R2		;SET CARRY IF INCREMENT IS ONE
	BCC	FXFOR1		;BRANCH IF NOT ONE
	ASL	R2		;LIMIT ADDR INTO R2
FXFOR3:	CMP	(R0),(R2)	;CHECK VARIABLE VS LIMIT
FXFOR9:	BGT	FXFOR2		;BRANCH IF GT FOR FALSE
FXFOR4:	COM	(R1)		;TRUTH VALUE TO TRUE
FXFOR2:	RTS	PC

FXFOR1:	ASL	R2		;RESTORE INCREMENT ADDR
	IFSIGN	(R2)+,PL,FXFOR3	;BRANCH ON POSITIVE INCREMENT
	CMP	(R2),(R0)	;DO A REVERSE COMPARE
	BR	FXFOR9		;THEN ENTER COMPARISON LOOP

;FLOATING FOR PUSHPOPS

FORF:	MOV	#PIFJ,-(SP)	;SET UP RETURN THRU INTERN. FALSE JUMP
	BR	FLFOR

FORFX:	MOV	#PIFJXN,-(SP)	;SET UP EXTERNAL "FOR" FALSE JUMP
FLFOR:	JSR	PC,PUSHF	;PUSH VARIABLE
	GWTXT	R0		;2ND ARG INTO CARRY
	ADD	SPDA,R0		;BIAS ADDR OF 2ND ARG
	ASR	R0		;SET CARRY IF INCREMENT IS ONE
	BCC	FLFOR1		;BRANCH IF NOT ONE
	ASL	R0		;LIMIT ADDR INTO R0
FLFOR2:	MOV	#.LE.F,-(SP)	;COMPARISON EXITS WITH LE TEST
FLFOR9:	JMP	PUSHF2		;PUSH THE LIMIT AND EXIT

FLFOR1:	ASL	R0		;VARIABLE ADDR INTO R0
	ADD	#FLTLE2,R0	;LIMIT ADDR INTO R0
	IFSIGN	MFLTL2(R0),PL,FLFOR2;BR IF INCREMENT +
	MOV	#.GE.F,-(SP)	;COMPARISON EXITS WITH GE TEST
	BR	FLFOR9		;GO PUSH LIMIT

;THESE ROUTINES DO THE PUSHPOPS FOR "WHILE" OR "UNTIL"
;CONTROLLED MODIFIERS

REPTI:
REPTF:	MOV	#IFJ2,-(R1)	;SAVE END OFFSET FOR ENDRPT
	BR	REPT2
REPTIX:
REPTFX:	MOV	#IFJXN2,-(R1)	;SAVE END OFFSET FOR ENDRPT
REPT2:	ADD	#4,R5		;IPC TO THIRD ARG
	MOVB	(R5)+,-(R1)	;SAVE TENTATIVE JUMP ADDR
	MOVB	(R5)+,-(R1)
	RTS	PC		;DO THE CONDITIONAL

;AT THE END OF THE CONDITIONAL, WE'LL COME HERE

ENDRPT:	JSR	PC,SETDRO	;SET THE DROP THRU FLAG FOR SUBSEQ. "NEXT"
	MOV	(R1)+,(R2)	;TRUTH VALUE TO RPTERM
	MOV	(R1)+,R0	;TENTATIVE JUMP ADDR TO R0
	TST	(R2)
	JMP	@(R1)+		;EXIT THRU APPROP. COND. JUMP

SETDRO:	MOV	SPDA,R2		;R2 _ BASE
	ADD	#NEXDRO,R2	;ABS ADDR NEXDRO FLAG INTO R2
	MOV	#+1,(R2)+	;SET NEXDRO & INC R2 TO ADDR OF RPTERM
	RTS	PC

; SPECIAL STRING FUNCTION
;	ARE DECODES AS FOLLOWS:
;	BIT 0 => TRIM PARITY
;	BIT 1 => DISCARD ALL SPACES AND TABS
;	BIT 2 => DISCARD ALL TERMINATORS AND JUNK BYTES
;	BIT 3 => DISCARD LEADING SPACES AND TABS
;	BIT 4 => REDUCE SPACES AND TABS TO ONE SPACE
;	BIT 5 => CONVERT LOWER CASE TO UPPER CASE
;	BIT 6 => CONVERT [ TO ( AND ] TO )
;	BIT 7 => DISCARD TRAILING SPACES AND TABS
;	BIT 8 => DON'T ALTER WHAT'S INSIDE QUOTES (EXCEPT FOR PARITY TRIM)

	.enabl	lsb

CVSSFN:	JSR	R5,INTFUN	;STRAIGHTEN OUT ARGUMENTS
	ARGS	FAS,FAI		;ONE STRING THEN ONE INTEGER
CVSS:	MOV	(R1)+,R4	;GET ARG BIT PATTERN TO HERE
	ASH	#7,R4		;THEN SHIFT IT FOR PARITY TRIM SETUP
	MOV	LENGTH(R1),R3	;LEN(FINAL STR) <= LEN(ORIGINAL STR) ALWAYS
	JSR	PC,BUILDS	;BUILD US A NEW STRING PLEASE
	MOV	R1,R2		;COPY THE R1 STACK TOP
	TST	(R1)+		;SKIP LINK WORD ON ORIGINAL STRING
	ADD	(R1)+,R2	;R2 IS ABS PTR TO ORIGINAL STRING
	MOV	R3,-(SP)	;SAVE START OF NEW STRING
	CLRB	-(SP)		;SAY OUTSIDE OF QUOTES INITIALLY
10$:	DEC	(R1)		;MORE TO GO IN ORIGINAL STRING?
	BMI	90$		;NOPE, SO FINISH UP
	MOVB	(R2)+,R5	;YEP, SO FETCH A BYTE
	BICB	R4,R5		;TRIM PARITY ON BYTE IF DESIRED
	TST	R4		;KEEP QUOTED BYTES?
	BPL	25$		;NO, NO SPECIAL HANDLING FOR QUOTES
	TSTB	(SP)		;YES, ARE WE WITHIN QUOTES NOW?
	BEQ	13$		;WE ARE OUTSIDE OF QUOTES
	CMPB	R5,(SP)		;WE ARE INSIDE QUOTES, IS THIS THE ENDING QUOTE?
	BNE	80$		;NOT ENDING QUOTE, KEEP BYTE
	CLRB	(SP)		;IT IS ENDING QUOTE, CLEAR THE INSIDE FLAG
	BR	80$		; AND KEEP THE ENDING QUOTE BYTE

13$:	CMPB	R5,#''		;START OF QUOTED STRING?
	BEQ	15$		;YES
	CMPB	R5,#'"		;MIGHT STILL BE A QUOTED STRING START
	BNE	25$		;DEFINITELY NOT STARTING A QUOTED STRING
15$:	MOVB	R5,(SP)		;STARTING A QUOTED STRING, SAVE QUOTE BYTE
	BR	80$		; AND KEEP THE STARTING QUOTE BYTE

25$:	BIT	R4,#4*200	;DISCARD TERMINATORS AND JUNK BYTES?
	BEQ	30$		;NO, KEEP THEM
	MOV	#110$,R0	;YES, GET LIST POINTER
27$:	CMPB	R5,(R0)+	;DOES THE BYTE MATCH THE LIST?
	BLO	27$		;NO, BUT KEEP CHECKING
	BEQ	10$		;YES, SO DISCARD THIS BYTE
	;BHI	30$		;NO, NO NEED TO CHECK FURTHER

30$:	CMPB	R5,#040		;IS THIS A SPACE?
	BEQ	40$		;YES
	CMPB	R5,#011		;NO, IS THIS A TAB?
	BNE	60$		;NOT A TAB, FORGET NEXT FEW CHECKS
40$:	BIT	R4,#2+10*200	;ELSE DISCARD ALL AND/OR LEADING ONES?
	BNE	10$		;IF SO THEN JUST DISCARD THIS BYTE
	BIT	R4,#20*200	;REDUCE SPACE/TAB SEQUENCES TO A SINGLE SPACE?
	BEQ	80$		;NO, SO JUST OUTPUT THIS SPACE OR TAB
	CMP	R3,2(SP)	;YES, HAVE WE OUTPUT ANYTHING AT ALL?
	BEQ	58$		;NOT YET, CONVERT TO SPACE AND OUTPUT IT
	CMPB	-1(R3),#040	;ELSE IS THE PRECEEDING A SPACE?
	BEQ	10$		;JUST DISCARD THIS SPACE/TAB IF SO
58$:	MOVB	#040,R5		;ELSE SET THE BYTE TO BE A SPACE FOR SURE
	BR	80$		; AND OUTPUT IT

60$:	BIT	R4,#40*200	;Convert lc to UC?
	BEQ	70$		;Nope
	MOV	#120$,R0	;Yes:  get list pointer			;*B*
63$:	CMPB	R5,(R0)+	;Is byte too low to upcase?		;*B*
	BLOS	70$		;Yes => continue, no change		;*B*
	CMPB	R5,(R0)+	;Too high to upcase?			;*B*
	BHI	63$		;Yes => go check next range (or quit)	;*B*
	BICB	#40,R5		;In lc range:  upcase it		;*B*
	BR	80$		; and output it as UC

70$:	BIT	R4,#100*200	;CONVERT []'S TO ()'S?
	BEQ	80$		;NOPE
	CMPB	R5,#'[		;YEP, IS IT [?
	BEQ	75$		;IT IS [, CONVERT IT TO (
	CMPB	R5,#']		;CHECK FOR IT BEING ]
	BNE	80$		;NOT TRUE, JUST OUTPUT IT
	DECB	R5		;IT IS ], SO ] = 135 - 64 = ) = 51
75$:	SUB	#'[-'(,R5	;AND         [ = 133 - 63 = ( = 50
80$:	MOVB	R5,(R3)+	;OUTPUT ONE BYTE TO NEW STRING
	BIC	#10*200,R4	;NOW TURN OFF LEADING SPACE/TAB DISCARDING
	BR	10$		;LOOP FOR ANOTHER BYTE

90$:	TSTB	(SP)+		;WERE WE INSIDE OF QUOTES AT STRING'S END?
	BNE	100$		;YES, SO NEVER CHECK FOR TRAILING DISCARDS
	ASL	R4		;NO, DISCARD TRAILING SPACES AND TABS?
	BPL	100$		;NOPE
92$:	MOVB	-(R3),R5	;GET LAST BYTE STORED
	CMP	R3,(SP)		;GOTTEN BACK TOO MANY?
	BLO	94$		;YES, SO STOP TRYING TO DISCARD TRAILING STUFF
	CMPB	R5,#040		;NO, IS IT A SPACE?
	BEQ	92$		;IT IS A SPACE, DISCARD IT
	CMPB	R5,#011		;IS IT A TAB?
	BEQ	92$		;IT IS A TAB, DISCARD IT
94$:	INC	R3		;ELSE KEEP THE LAST BYTE REMOVED
100$:	TST	(SP)+		;POP THE NEW STRING'S START FROM STACK
	BR	MID10		;RESTORE SPDA AND FINISH UP

110$:	.BYTE	177,033,015,014,012,000

120$:	.BYTE	'A+40-1, 'Z+40,    340-1, 376,    377
	.even

	.dsabl	lsb

;CHECKS THE STRING AT THE TOP OF THE STACK FOR INCLUSION
;IN THE NEXT STRING ON THE STACK AS A SUBSTRING
;AT OR BEYOND THE POSITION SPECIFIED BY THE NUMBER WHICH
;FOLLOWS ON THE STACK - IF INCLUDED, RETURNS THE
;CHARACTER POSITION AT WHICH FIRST OCCURRENCE STARTS -
;IF NOT, RETURNS 0 - THE NULL STRING IS A SUBSTRING
;OF EVERY STRING IMMEDIATELY

INSTR:	JSR	R5,INTFUN	;GET THE ARGS STRAIGHTENED OUT
	ARGS	FAI,FAS,FAS	;INTERGER-STRING-STRING ARGS
	MOV	R5,-(SP)	;SAVE IPC
	MOV	SPDA,R2		;R2 IS THE BASE REGISTER
	MOV	R1,R5		;R5 _ OLD R1 STACK PTR
	JSR	PC,PSTJS	;THROW OUT TOP STRING
	MOV	R1,R0		;R0 _ NEW R1 STACK PTR
	MOV	-(R0),R4	;R4 _ LENGTH OF SUPPOSED SUBSTRING
	ADD	-(R0),R5	;R5 _ ITS ADDR
	MOV	R1,R2		;R2 _ OLD R1 STACK PTR
	JSR	PC,PSTJS	;THROW OUT TOP STRING
	MOV	R1,R0		;R0 _ NEW R1 STACK PTR
	MOV	-(R0),R3	;R3 _ LENGTH OF SUPPOSED OUTER STRING
	ADD	-(R0),R2	;R2 _ ITS BEG ADDR
	DEC	(R1)		;DEC CHAR POSITION TO START AT
	BPL	INSTR0		;BRANCH ON POSITIVE CHAR POSITION
	CLR	(R1)		;EARLY START CORRECTION
INSTR0:	ADD	(R1),R2		;START AT INDICATED CHAR
	SUB	(R1),R3		;WITH APPROPRIATE LENGTH
INSTR1:	IF  R4,GT,R3,INSTR2	;BRANCH IF NO ROOM FOR INCLUSION
	INC	(R1)		;OTHWS, ADVANCE POSITION INDICATIO
	CLR	R0		;CLR CHAR MATCH COUNTER

INSTR4:	IF  R0,EQ,R4,MID8	;BRANCH IF SUBSTRING FOUND
	INC	R0		;OTHWS, INC MATCH COUNTER
	IF  (R2)+,EQ,(R5)+,INSTR4,B  ;LOOP BACK ON CHAR MATCH
	SUB	R0,R5		;RESTORE BEG OF SUPPOSED SUBSTRING
	INC	R2		;TRY ONE CHAR FURTHER DOWN
	SUB	R0,R2		;OF SUPPOSED OUTER STRING
	DEC	R3		;DEC ITS LENGTH
	BR	INSTR1		;AROUND OUTER LOOP AGAIN

INSTR2:	CLR	(R1)		;SEND BACK A 0 TO INDICATE FAILURE
	BR	MID8		;RESTORE IPC AND EXIT

;CONCATENATE ROUTINE
CONCAT:	MOV	LENGTH(R1),R3	;R3 _ LENGTH OF 2ND STRING
	ADD	STRLEN+LENGTH(R1),R3;PLUS LENGTH OF 1ST STRING
	JSR	PC,BUILDS	;START TO BUILD THE STRING
	MOV	#MATBLK,R4	;R4_ADDR TEMP STORAGE BLOK
	ADD	R0,R4		;BIAS BLOCK ADDR
	CLR	(R4)+		;PUT A 0 BLOCK LENGTH INTO BLOCK AS FLAG
	MOV	R1,R5
	TST	(R1)+		;SKIP OVER LINK
	ADD	(R1)+,R5	;ABS ADDR 2ND STRING INTO R5
	MOV	(R1)+,(R4)+	;ITS LENGTH INTO BLOCK
	MOV	R1,R2
	TST	(R1)+		;SKIP LINK OF 1ST STRING
	ADD	(R1)+,R2	;UNBIASED ADDR OF 1ST STRING IN R2
	MOV	(R1)+,(R4)	;LENGTH OF 1ST STRING INTO BLOCK
	ADD	#STRLEN,(R0)	;THROW OUT FIRST STRING HEADER
CONCA1:	DEC	(R4)		;DEC LENGTH OF ONE OF STRINGS
	BMI	CONCA2		;DONE WITH THIS STRING IF NEG
	MOVB	(R2)+,(R3)+	;OTHWS, TRANSFER A CHAR
	BR	CONCA1		;AROUND AGAIN

CONCA2:	MOV	R5,R2		;R2 _ ADDR OF 1ST STRING
	IFZERO	NE,-(R4),CONCA1	;GO AROUND AGAIN IF NONZERO LENGTH
	BR	MID6		;EXIT

;PUSHPOP FOR MID

SUBST1:	JSR	R5,INTFUN	;STRAIGHTEN OUT ARGS
	ARGS	FAS,FAI,FAI	;STRING-INTEGER-INTEGER ARGS
	MOV	(R1)+,R3	;R3_SUBSTRING LENGTH
MID1:	MOV	(R1)+,R4	;R4_CHAR POSITION
	DEC	R4		;A LITTLE SMOOTHER DECREMENTED
	BPL	MID2		;BRANCH ON POSITIVE CHAR POSITION
MID5:	CLR	R4		;PRETEND IT WAS 1
MID2:	MOV	R4,R2		;R2 _ ADJUSTED CHAR POSITION
	NEG	R2		;NEGATED
	ADD	LENGTH(R1),R2	;R2 _ LENGTH OF REMAINDER OF STRING
	BPL	1$		;GOING TO RETURN NULL IF NEGATIVE
	CLR	R2		;YEP IT WAS NEG
1$:	TST	R3		;ALSO YIELD NULL
	BPL	2$		;IF LENGTH OF RESULT
	CLR	R3		;LOOK NEGATIVE HERE
2$:	IF  R3,GE,R2,3$	;BR IF PUTATIVE LENGTH GR THAN REST OF STRING
	MOV	R3,R2		;ANYWAY, R2 _ LESSER LENGTH
3$:	MOV	R2,R3		;AND SO DOES R3
	JSR	PC,BUILDS	;BUILD SUBSTRING ON R1 STACK
	ADD	R1,R4		;PREPARE TO DERELATIVIZE
	TST	(R1)+		;POINT AT STRING PTR
	ADD	(R1)+,R4	;R4_ABS. ADDR 1ST SUBSTRING CHAR
4$:	DEC	R2		;DECREMENT LENGTH
	BMI	MID9		;BRANCH IF DONE
	MOVB	(R4)+,(R3)+	;TRANSFER A CHAR
	BR	4$

MID10::	MOV	SPDA,R0		;RESTORE SPDA POINTER
MID9:	TST	(R1)+		;ADJUST R1 TO POINT JUST ABOVE HEADER
MID6:	JSR	PC,@(SP)+	;FINISH UP IN BUILDS
MID8:	MOV	(SP)+,R5	;RESTORE IPC
	RTS	PC

;PUSHPOP FOR RIGHT

SUBSTR:	JSR	R5,INTFUN	;STRAIGHTEN OUT ARGS
	ARGS	FAS,FAI		;STRING-INTEGER ARGS
	MOV	#77777,R3	;FAR FAR RIGHT INDEED
	BR	MID1		;PROCESS AS VARIANT OF MID

LEFT:	JSR	R5,INTFUN	;STRAIGHTEN OUT ARGS
	ARGS	FAS,FAI		;STRING-INTEGER ARGS
	MOV	(R1)+,R3	;R3_SUBSTRING LENGTH
	BR	MID5

CHR$:	JSR	R5,INTFAI	;FIX ARG IF NECESSARY
	MOV	(R1)+,R2	;R2_ASCII VALUE CHAR
	CLR	R3		;APPROX LENGTH OF STRING
	JSR	PC,BUILDS	;BUILD THE STRING ETC
	MOVB	R2,(R3)+	;MOVE THE CHARACTER IN
	BR	CVS3		;PUT NEW HEADER ON LIST & EXIT

POSF:	TST	(R1)		;SEE IF ANY ARGUMENT
	BEQ	1$		;BRANCH IF ZERO ASSUMED
	JSR	R5,INTFAI	;CALL THE COMMON FUNCTION INTERPRETER
1$:	MOV	(R1)+,R3	;GET THE WANTED CHANNEL #
	BIC	#-17-1,R3	;MAKE SURE IT IS VALID
	ASH	#4,R3		;TIMES 16.
POS04:	ADD	#BASE+IOLEN,R3	;GO TO BUFFER HEADER RELATIVE
POS02:	ADD	SPDA,R3		;MAKE ADDRESS ABSOLUTE
	MOVB	SLOT(R3),XRB+XRCI;SET CHANNEL # TIMES 2
	.POSTN			;GET LINE LENGTH & CUR. POSITION
	MOVB	IOSTS,R0	;ANY ERROR?
	BEQ	1$		;NOPE
	CHKERR	DETKEY,R0	;ERROR, DETACHED??
	BEQ	1$		;NO ERROR REPROT IF SO...
	IOTERR	!FATAL		;YES

1$:	MOV	XRB+XRLEN,R0	;STORE THE LINE LENGTH (+1) HERE
	MOV	XRB+XRBC,-(R1)	;AND CUR. POS. ON R1 STACK
	BITB	#FLGPOS/400,FLAGS(R3);DOES MONITOR KEEP POSITION?
	BNE	2$		;YES, SO CUR. POS. IS NOW SET
	MOVB	POSITN(R3),(R1)	;NO, SO REPLACE WITH OUR POSITION
2$:	RTS	PC		;AND OUT

;	DO THE TAB FUNCTION
TABF:	JSR	R5,INTFAI	;ADJUST ARG TYPES
	JSR	PC,POS000	;FIND POSITION
	SUB	(R1)+,(R1)	;FIND AMOUNT NEEDED TO GO
	BR	SPAC01		;AND DO IT

POS000:	MOV	SPDA,R3		;GET SPDA BASE BIAS
	MOV	CURRIO(R3),R3	;NOW GET CURRENT IO ADDRESS
	BNE	POS02		;WE ARE DOING IO
	BR	POS04		;ELSE USE CONSOLE

SPACES:	JSR	R5,INTFAI	;FIX ARG IF NECESSARY
SPAC01:	MOV	#40,R2		;BYTE TO USE IS <SPACE>
SPAC02:	MOV	(R1)+,R3	;R3 _ NUMBER OF SPACES IN STRING
	MOV	R3,R4		;ALSO R4
	BPL	1$		;BRANCH IF POSITIVE LENGTH
	CLR	R3		;ELSE MAKE  NO STRING
1$:	JSR	PC,BUILDS	;BEGIN TO BUILD THE STRING
2$:	DEC	R4		;DECREMENT STRING LENGTH
	BLT	CVS3		;EXIT WHEN LENGTH COUNT GOES NEGATIVE
	MOVB	R2,(R3)+	;OTHWS, ADD A BYTE TO THE STRING
	BR	2$		;AND GO ROUND AGAIN

STRING:	JSR	R5,INTFUN	;GET 2 'FAI' ARGS
	ARGS	FAI,FAI
	MOV	(R1)+,R2	;SECOND ARG IS BYTE VALUE FOR STRING
	BR	SPAC02

;CONVERT VECTOR TO STRING

CVS:	CLR	-(R1)		;INITIALIZE TO ZEROTH ENTRY
	JSR	PC,CVSPUS	;PUSH FIRST ENTRY
	MOV	(R1)+,R4	;R4_STRING LENGTH
	MOV	R4,R3		;SO DOES R3
	JSR	PC,BUILDS	;BUILD THE STRING
CVS1:	DEC	R4		;DEC LENGTH
	BMI	CVS2		;ALMOST DONE IF NEGATIVE
	SUB	R0,R3		;GUARD AGAINST DISASTER
	MOV	2(SP),R5	;R5 _ RELATIVE IPC SAVED BY BUILDS
	ADD	SPTA,R5		;NOW IPC ABSOLUTE
	CMPB	-(R5),-(R5)	;BUT WE HAVE TO POINT AT ARRAY ADDRESS
	JSR	PC,CVSPUS	;PUSH ENTRY
	ADD	R0,R3		;UNGUARD
	MOV	(R1)+,R2	;R2_MATRIX ENTRY
	MOVB	R2,(R3)+	;PUT L.S. BYTE INTO STRING
	BR	CVS1		;AND AROUND AGAIN
CVS2:	TST	(R1)+		;GET RID OF RUNNING ARRAY INDEX
CVS3:	JSR	PC,@(SP)+	;RETURN TO BUILDS TO FINISH UP
	MOV	(R2),(R1)	;LINK _ RELATIVE PTR TO 1ST STRING HEADER
	JSR	PC,PUSHS2	;PUT HEADER ON HEADER LIST
	BR	MID8

;TURNS A STRING INTO AN ARRAY

CSV:	CLR	-(SP)		;INITIALIZE TO ZEROTH ENTRY
	MOV	LENGTH(R1),-(R1);STRING LENGTH TO TOP OF STACK
	JSR	PC,CSVPOP	;SALT IT AWAY IN ARRAY
	MOV	R1,R4		;R4 _ R1 STACK POINTER
	JSR	PC,PSTJS	;POP STRING TO J SPACE
	MOV	-(R1),R3	;R3 _ STRING LENGTH
	ADD	-(R1),R4	;R4 _ ABS STRING POINTER
	CMP	(R1)+,(R1)+	;CLEAN UP R1 STACK
CSV1:	DEC	R3		;DECREMENT LENGTH
	BMI	CSV2		;DONE IF NEGATIVE
	CLR	-(R1)		;OTHWS,SET UP ANOTHER POP
	MOVB	(R4)+,(R1)	;WITH BYTE FROM THE STRING
	SUB	R0,R4		;GUARDING AGAINST DISASTER
	CMPB	-(R5),-(R5)	;ADJUST IPC FOR NEXT POP
	JSR	PC,CSVPOP	;POP R1 STACK TO MATRIX
	ADD	R0,R4		;DANGER BEHIND US
	BR	CSV1		;AROUND AGAIN

CSV2:	TST	(SP)+		;RID OF RUNNING ARRAY INDEX
	RTS	PC

;SPECIAL PUSH FOR CVS ROUTINE - FIXES THE PUSHED ITEM
;IF IT WAS A FLOATER-SAVES R3 & R4
;EXIT WITH R0 = SPDA - JSR PC

CVSPUS:	MOV	R3,-(SP)	;SAVE R3 & R4
	MOV	R4,-(SP)
	MOV	(R1),-(R1)	;ARRAY INDEX _ RUNNING INDEX
	INC	2(R1)		;INCREMENT RUNNING INDEX
	JSR	PC,INDO1	;PUSH ARRAY ENTRY
	JMASK0	NE,(R0),FIXARY,CVSPU1,B	;BR ON FIXED NUM
	JSR	PC,FIX		;OTHWS, FIX IT
CVSPU1:	MOV	(SP)+,R4	;RESTORE R4 & R3
	MOV	(SP)+,R3
	MOV	SPDA,	R0	;BUT SET R0 TO SPDA
	RTS	PC

;SPECIAL POP FOR CSV ROUTINE - POPS THE TOP INTEGER
;(FLOATED, IF NEED BE) INTO ARRAY - SAVES R3 & R4 -
;EXIT WITH R0 = SPDA - JSR PC

CSVPOP:	MOV	R3,-(SP)	;SAVE R3 & R4
	MOV	R4,-(SP)
	MOV	6(SP),-(R1)	;ARRAY INDEX _ RUNNING INDEX
	INC	6(SP)		;INCREMENT RUNNING INDEX
	CLR	-(R1)		;DUMMY IN 2ND INDEX OF ZERO
	JSR	PC,INDX90	;CALL ARRAY PREFACE
	CLR	DIM2-ARYFLG(R0)	;MAKE IT A VECTOR!
	JMASK0	NE,(R0),FIXARY,CSVPO,B  ;BR IF INTEGER ARRAY
	JSR	R5,EDSAVE	;SAVE R0,2,3,4,5
	JSR	PC,FLT		;FLOAT THE NUMBER
	JSR	R5,EDREST	;AND RESTORE THEM
CSVPO:	JSR	PC,INDR3	;POP TO ARRAY
	BR	CVSPU1		;RESET R3 & R4 AND SET R0 TO SPDA

.ENABL	LSB

DATE$:	JSR	R5,INTFAI	;SEE WHAT WE'VE GOT
DATE07:	MOV	#4-FQFUN,R3	;DATE CONVERION IS OFFSET=4
10$:	MOV	#FIRQB+FQBSIZ,R4 ;GET END OF FIRQB POINTER
20$:	MOV	-(R4),-(SP)	;SAVE A FIRQB WORD
	CLR	(R4)		; THEN CLEAR A FIRQB WORD
	CMP	R4,#FIRQB+FQFUN+1 ;UP TO THE FUNCTION YET?
	BHI	20$		;NOT YET...
	MOVB	#UU.CNV,-(R4)	;YES, SET CONVERT DATE/TIME
	ADD	R3,R4		;NOW INDEX TO CORRECT SPOT
	MOV	(R1)+,(R4)+	;SET DATE OR TIME
	CLR	(R4)+		; AND INDICATE THE DEFAULT FORMAT
	.UUO			;GO DO IT
	MOV	#10.,R3		;GET AT LEAST 10. BYTES
	JSR	PC,BUILDS	; OF STRING SPACE
30$:	MOVB	(R4)+,(R3)+	;MOVE A BYTE
	BNE	30$		; UNTIL END...
	DEC	R3		;BACK UP OVER NULL BYTE
	JSR	PC,@(SP)+	;CO-ROUTINE RETURN
	MOV	(R2),(R1)	;LINK INTO STRING LIST
	JSR	PC,PUSHS2	; THIS WAY...
	MOV	(SP)+,R5	;RESTORE IPC
	MOV	#FIRQB+FQFIL,R4	;GET FIRQB POINTER AGAIN
40$:	MOV	(SP)+,(R4)+	;RESTORE A FIRQB WORD
	CMP	R4,#FIRQB+FQBSIZ ;DONE?
	BLO	40$		;NOT YET...
	RTS	PC		;EXIT

TIME$:	JSR	R5,INTFAI	;SEE WHAT WE'VE GOT
TIME07:	MOV	#22-FQFUN,R3	;TIME CONVERSION IS OFFSET=22
	BR	10$		;SO GO DO IT

.DSABL	LSB

	.sbttl	DATIFN	Service for DATE%() function

;						*C*

	deforg	DATI		;Dummy, overlaid if DATE%() selected

DATIFN:	ERROR	ERRERR,FATAL

	org	RC

	.sbttl

;PUTS A STRING ON THE R1 STACK - CALLING SEQUENCE:
;		R3 _	TIGHT UPPER BOUND ON STRING LENGTH
;		JSR	PC,BUILDS	(NO ABS POINTERS & NO STRING DATA POINTERS)
;		INITIALIZE
;	LOOP:	GO RET IF CONDITION FOR STRING END MET
;		GET READY TO SHIP CHAR (KEEPING R0 _ SPDA
;					AND R3 PROPERLY ABSOLUTE)
;		(R3)+ _	CHAR
;		BR	LOOP
;	RET:	JSR	PC,@(SP)+
;		MOV	(R2),(R1)	(TO PUT NEW HEADER ON LIST)
;		JSR	PC,PUSHS2
;		   OR	NOTHING		(IF PREVIOUS ITEM 
;					ON R1 STACK WAS A STRING
;					HEADER STILL ON HEADER LIST
;					WHOSE LINK IS UNDESTROYED BY
;					R1 STACK DIDDLING IN THE
;					CHAR TRANSMISSION PORTION OF
;					COROUTINE)
;		MOV	(SP)+	R5	(TO RESTORE IPC IF R5 ORIG IPC)
;		   OR	TST (SP)+ (IF R5 NOT IPC AT ENTRY)
;		EXIT	CODE
;AT FIRST EXIT TO COROUTINE, R3 IS ABSOLUTE ADDR OF
;FIRST STRING BYTE TO BE STORED INTO - AT ALL
;EXITS, R0 IS SPDA, AND MUST BE SO MAINTAINED -
;AT LAST EXIT R2 IS ALSO SPDA - WARNING:  THE VALUE
;OF SPDA & SPTA MAY CHANGE BETWEEN THE INITIAL ENTRY TO BUILDS
;AND THE FIRST EXIT TO COROUTINE - IF R5 CONTAINS
;IPC, AN APPROPIATELY UPDATED VERSION IS ON THE SP STACK AT
;EXIT - OTHWS, JUNK WORD ON STACK AT EXIT
;DOES NOT USE R2, R4, OR R5 EXCEPT FOR THE RETURN OF SPDA IN R2 AT LAST EXIT

BUILDS:	MOV	SP,R0		;KEEP BACK UP OF STACK POINTER
	MOV	(SP),-(SP)	;MAKE A SLOT FOR IPC
	MOV	R5,(R0)		;SLOT _ IPC
	SUB	SPTA,(R0)	;RELATIVIZE W.R.T. SPTA
	MOV	SPDA,R0		;R0 IS THE BASE REGISTER
	BIC	#1,R3		;MAKE STRING LENGTH EVEN
	ADD	#2,R3		;LITTLE SLACK
	BPL	BLDS0		;BR IF STRING LENGTH NONNEGATIVE
	ERROR	XCDCOR,FATAL	;TOO BIG!
BLDS0:	MOV	R3,STRNOM(R0)	;TELL GARBAGE COLLECTOR HOW MUCH
	ADD	NEXSTR(R0),R3	;R3 _ APPROX. END OF STRING TO BE BUILT
	IF R3,LO,STRLIM(R0),BLDS1  ;BRANCH IF ROOM FOR STRING
	JSR	R5,ECONOM	;USER-CORE MANAGER
	+	STRNOM		;GIVE US STRING SPACE PLEASE
BLDS1:	MOV	NEXSTR(R0),R3	;R3 _ NEXT AVAILABLE BYTE IN STRING SPACE
	ADD	R0,R3		;BIAS R3
	JSR	PC,@(SP)+	;GO BUILD THE STRING, ETC
	SUB	R0,R3		;UNBIAS R3
	MOV	R3,-(R1)	;LENGTH _ REL LOC OF NEXT FREE STRING BYTE
	MOV	R3,-(R1)	;STRING LINK DOES TOO
	ADD	R0,(R1)+	;STRING LINK _ ABS ADDR
	SUB	NEXSTR(R0),(R1)	;LENGTH _ LENGTH OF STRING BUILT
	BGT	BLDS2		;BRANCH IF POSITIVE LENGTH
	CLR	(R1)		;ELSE MAKE ZERO LENGTH
BLDS2:	SUB	(R1),-(R1)	;STRING LINK _ ABS ADDR OF STRING BUILT
	TST	-(R1)		;POINT AT LINK
	SUB	R1,2(R1)	;RELATIVIZE PTR
	INC	R3		;MAKE R3 EVEN (ROUND UP)
	BIC	#1,R3
	MOV	R3,NEXSTR(R0)	;UPDATE NEXT AVAIL STRING BYTE ADDR
	ADD	SPTA,2(SP)	;MAKE POSSIBLE IPC ABSOLUTE
	MOV	R0,R2		;PUBLIC SERVICE - R2 _ SET TO BIAS
	RTS	PC

PWRI:	MOV	(R1)+,-(SP)	;SAVE THE POWER
	BLT	PWRI00		;IF NEGITIVE GIVE ZERO RESULT
	MOV	(R1)+,-(SP)	;SAVE THE NUMBER
	MOV	#1,-(R1)	;START THE PRODUCT AT 1
PWRI10:	DEC	2(SP)		;DECREMENT THE COUNT
	BLT	PWRI20		;EXIT IF DONE
	MOV	(SP),-(R1)	;MOVE THE BASE NUMBER
	JSR	PC,MULI		;AND MULTIPLY
	BR	PWRI10		;AND LOOP FOR MORE IF NEEDED

PWRI20:	TST	(SP)+		;POP THE NUMBER
PWRI25:	TST	(SP)+		;POP THE EXPONENT
	RTS	PC		;AND RETURN

PWRI00:	CLR	(R1)		;MAKE RESULT 0
	BR	PWRI25		;AND EXIT NICELY

PUSHI1:	MOV	#1,-(R1)	;PUSH INTEGER 1
	RTS	PC

	.TITLE	BASIC
	.END

