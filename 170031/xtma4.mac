TITLE	XTMA4,<4-WORD TRIG FUNCTIONS>,08,13-MAY-86,TPH/JDM/MHB/WBN

;                   Copyright 1974,1990 by Digital Equipment Corporation
;                                  All rights reserved.
;
;          This software is furnished under a license and may be used and copied
;          only  in  accordance  with  the  terms  of  such license and with the
;          inclusion of the above copyright notice.  This software or any copies
;          shall not be provided to any other person.   No title to or ownership
;          of the software is hereby transferred.
;
;          The information in this software is subject to change without notice.
;
;          DIGITAL  assumes  no  responsibility  for the  use, functionality, or
;          reliability of its  software  on equipment  which  is not supplied by
;          DIGITAL.

.SBTTL	EXTERNAL GLOBALS

	.GLOBL	INTFUN,ADDF,MULF,DIVF
	.IF	DF	DECMAP
	.GLOBL	DSCTST
	.ENDC
	.IF	NDF	FPU
	.GLOBL	$ADD,$SBD,$MLD,$DVD,$ID,$DI,$DINT,DUP4
	.GLOBL	$POLSH,DUPLF
	.ENDC

.SBTTL	LOAD PUSH-POP CODE FOR TRIG FUNCTIONS

	ORG	PT,0

	..	PPSIN,SIN
	..	PPCOS,COS
	..	PPATAN,ATAN
	..	PPTAN,TAN

	.IF	NDF	FPU
	ORG	POLY,0
POLY:
;	POLY4 IS A POLYNOMIAL EVALUATOR TO EVAL
;	C(N)*X**N+C(N-1)*X**N-1+...+C(1)*X+C(0)
;	CALL POLY4 (VIA $POLSH) WITH X (A 4-WD FL-PT NO.)
;	ON THE R1 STACK AND C(R4)=A POINTER TO A POINTER TO A WORD
;	CONTAINING N+1, I.E., THE NO. OF CONSTANTS.
;	THE CONSTANTS THEMSELVES ARE STORED (AS 4-WD FL-PT
;	NO'S.) IMMED. BEFORE THE WORD CONTAINING THE N+1,
;	WITH C(N) AT LOWEST ADDR AND C(0) AT HIGHEST.
;	E.G., TO EVAL. 5*X**2+3*X+2, THE CONST. TABLE
;	LOOKS LIKE:
;		.WORD	...,...,...,...		;4-WD FL-PT 5, I.E. C(2)
;		.WORD	...,...,...,...		;4-WD FL-PT 3, I.E. C(1)
;		.WORD	...,...,...,...		;4-WD FL-PT 2, I.E. C(0)
;		.WORD	3			;NO. OF CONS'TS
;
POLY2:	;POLY2 IS LIKE POLY4 - BUT FOR 2-WORD STUFF
POLY4:	MOV	(R4)+,R0	;POINTER TO NUMBER OF COEFFICIENTS, ETC.
	MOV	R4,-(SP)	;SAVE RETURN POINTER
	MOV	(R0),R4		;SAVE THE NUMBER OF COEFFICIENTS IN R4
	MOV	R4,-(SP)	;AND ON THE STACK
	MOV	(R1)+,R2	;SAVE X
	MOV	(R1)+,R3
	.REPT	FLTLEN-2
	MOV	(R1)+,-(SP)
	.ENDR
	BR	PLP42		;GO PUSH A COEFFICIENT
PLP41:	.IF	EQ	FLTLEN-4	;FETCH X BACK TO THE R1 STACK
	MOV	(SP),-(R1)
	MOV	2(SP),-(R1)
	.ENDC
	MOV	R3,-(R1)
	MOV	R2,-(R1)
PLP42:	MOVFLT	-(R0),-(R1)	;PUSH ONE OF THE COEFFICIENTS
	SOB	R4,PLP41	;REPEAT UNTIL COEFF COUNT = 0
	.IF	EQ	FLTLEN-4
	CMP	(SP)+,(SP)+	;SOME GARBAGE OFF THE STACK
	.ENDC
	DEC	(SP)		;DECREMENT 2ND COPY OF COUNTER
PLP43:	JSR	PC,MULF		;MULTIPLY TOP OF STACK BY X
	JSR	PC,ADDF		;ADD IN NEXT COEFFICIENT
	DEC	(SP)		;DECREMENT COUNTER
	BNE	PLP43		;REPEAT UNTIL COUNT = 0
	TST	(SP)+		;DISCARD COUNTER
	MOV	(SP)+,R4	;RESTORE POLISH POINTER
	JMP	@(R4)+		;POLISH EXIT

;	UP4 IS A POLISH ROUTINE TO MOVE THE 4 WDS AT THE HEAD
;	OF THE STACK TO A LOC 8 WD'S AWAY INSIDE THE STACK
UP2:	;LIKE UP4 BUT 2 WORDS AT HEAD GET MOVED 4 WORDS AWAY
UP4:	MOVFLT	(R1)+,6*FLTLEN-2(R1)  ;MOVE SOME WORDS SOME DISTANCE
	JMP	@(R4)+
;
;	MSPR1 IS A POLISH ROUTINE THAT TRANSFERS THE TOP 2 WDS.
;	OF THE SP STACK TO THE R1 STACK
MSPR1:	MOV	(SP)+,-(R1)
	MOV	(SP)+,-(R1)
	JMP	@(R4)+
;
;	KPUSH IS A SUBROUTINE TO PUSH THE CONSTANT THAT FOLLOWS THE
;	CALL ONTO THE R1 STACK.
KPUSH:	.REPT	FLTLEN
	MOV	(R0)+,-(R1)
	.ENDR
	RTS	R0		;RETURN TO CALLER
;
	.ENDC

	DEFORG	MAXT
TAN:	.IF	DF	DECMAP
	JSR	PC,DSCTST	;GET 'FAF' ARG AND CHECK FOR SCALING
	.IFF
	JSR	R5,INTFUN	;DEMAND A FLOATING ARG
	ARGS	FAF
	.ENDC
	MOVFLT	(R1)+,-(SP)	;COPY ARG ON SP STACK
	FLTPP	-(R1)		;BACK UP ON R1 STACK
	JSR	PC,SINF		;GET SIN(X)
	MOVFLT	(SP)+,-(R1)	;GET BACK THE COPY
	JSR	PC,COSF		;GET COS(X)
	JMP	DIVF		;TAN(X)=SIN(X)/COS(X)

;	SIN	COS	THE DOUBLE PRECISION SIN AND COS
;	FUNCTIONS.
;	CALLING SEQUENCE:
;	CALLED WITH ARG (4-WD FL-PT NO.) ON R1 STACK
;		JSR	PC,SIN	(OR COS)
;		(RETURN)
;	RETURNS SIN OR COS OF ARG (4-WD FL-PT NO.) ON R1 STACK
;
SIN:	.IF	DF	DECMAP
	JSR	PC,DSCTST	;GET 'FAF' ARG AND CHECK FOR SCALING
	.IFF
	JSR	R5,INTFUN	;DEMAND A FLOATING ARG
	ARGS	FAF
	.IFTF
	BR	SINF		;AND DO SINE
COS:
	.IFT
	JSR	PC,DSCTST	;GET 'FAF' ARG AND CHECK FOR SCALING
	.IFF
	JSR	R5,INTFUN	;DEMAND A FLOATING ARG
	ARGS	FAF
	.ENDC
	.IF	NDF	FPU
COSF:	JSR	R0,KPUSH	;PUSH PI/2
	 .WORD	064302,121041,007732,040311
	JSR	PC,ADDF		;COS(X) = SIN(X+PI/2)
SINF:	CLR	-(SP)		;MAKE ROOM FOR QUADRANT FLAG
	ASL	(R1)		;CLEAR SIGN AND SAVE IT
	ROR	(SP)		;IN QUADRANT FLAG
	ROR	(R1)
	CMP	(R1),#026000	;VERY SMALL?
	BLO	RTN3		;YES
	JSR	R0,KPUSH	;PUSH 2*PI
	 .WORD	064302,121041,007732,040711
	JSR	R4,$POLSH	;ENTER POLISH MODE
	.WORD	$DVD		;X/2PI
	.WORD	DUP4		;2 COPIES
	.WORD	$DINT		;INT(X/2PI)
	.WORD	$SBD		;FRACT(X/2PI)
	.WORD	X4		;4*FRACT(X/2PI)
	.WORD	DUP4		;2 COPIES
	.WORD	$DINT		;INT(4*FRACT(X/2PI))
	.WORD	QUAD		;SAVE INT(......)
	.WORD	$SBD		;Y=FRACT(4*FRACT(X/2PI))
	.WORD	QSET		;REDUCE Y TO (-1,1)
	.WORD	DUP4		;2 COPIES
	.WORD	DUP4		;3 COPIES
	.WORD	$MLD		;Y*Y
	.WORD	POLY4		;PUSH COEFFICIENTS
	.WORD	CONSTS		;CONST. TAB. POINTER FOR POLY4
	.WORD	$MLD		;CALC Y*POLY(Y*Y)
	.WORD	RTN3

X4:	TST	(R1)		;CHECK FOR 0 FRACTION
	BEQ	RTN3		;QUIT NOW
	INCB	1(R1)		;QUADRUPLE STACK ITEM
	JMP	@(R4)+
;
QUAD:	BIS	(R1),(SP)	;SAVE QUADRANT NUMBER
POLRET:	JMP	@(R4)+
;
QSET:	TSTB	(SP)		;TEST QUADRANT
	BEQ	Q13		;JUMP IF FIRST OR THIRD QUAD
	ADD	#100000,(R1)	;NEGATE X CRUDELY (ADDF CLEANS UP)
	CLR	-(R1)
	CLR	-(R1)
	CLR	-(R1)		;PUSH A FLOATING 1.
	MOV	#40200,-(R1)
	MOV	R4,-(SP)	;SAVE POLISH PC
	JSR	PC,ADDF		;X = 1.-X
	MOV	(SP)+,R4	;RESTORE POLISH PC
Q13:	ASRB	1(SP)		;TEST QUADRANT
	BCC	QOUT		;JUMP IF FIRST OR SECOND
	TST	(R1)		;IF IT'S ZERO
	BEQ	QOUT		;THEN DON'T NEGATE IT
	ADD	#100000,(R1)	;NEGATE STACK ITEM
QOUT:	MOV	(R1),-(SP)	;COPY THE NUMBER
	BIC	#100000,(SP)	;MAKE IT ABSOLUTE
	CMP	(SP)+,#026000	;TOO SMALL?
	BHIS	POLRET		;NO, CONTINUE WITH POLISH
RTN3:	BIC	#^C<100000>,(SP) ;STRIP FLAG TO SIGN BIT
	ADD	(SP)+,(R1)	;SIN(-X) = -SIN(X)  FLIP SIGN IF FLAG SET
	RTS	PC		;BACK TO CALLER
	.ENDC
;
	.IF	DF	FPU
COSF:	SETD			;DOUBLE PRECISION FP
	LDD	(R1)+,F0	;GET ARGUMENT
	ADDD	PIOV2,F0	;COS(X)=SIN(X+PI/2)
	BR	SINCOS		;
SINF:	SETD			;DOUBLE PRECISION FP
	LDD	(R1)+,F0	;GET ARGUMENT
SINCOS:	SETI			;SHORT INTEGERS
	MOV	#FCONST,R0	;POINTER TO CONSTANTS
	CFCC			;GET SIGN OF ARG
	SXT	R4		;SET SIGN FLAG ACCORDINGLY
	ABSD	F0		;REMOVE ARGUMENT SIGN
	CMPD	#^O026000,F0	;TOO SMALL?
	CFCC
	BGE	RTNX		;YES
	DIVD	(R0)+,F0	;X/2PI
	MODD	#1.0,F0		;F0= FRACT(X/2PI)
	CFCC
	BEQ	RTN3		;EXIT ON 0 FRACTION
	MODD	#4.0,F0		;F0= FRACT(4*FRACT(X/2PI))
	STCDI	F1,R2		;QUAD= INT(4*FRACT(X/2PI))
	ROR	R2		;
	BCC	Q13		;JUMP IF FIRST OR THIRD QUAD
	NEGD	F0		;
	ADDD	#1.0,F0		;Y=1.0-X
Q13:	ROR	R2		;
	BCC	Q12		;JUMP IF FIRST OR 2ND QUAD
	NEGD	F0		;Y = -Y
;
Q12:	LDD	F0,F2		;COPY NUMBER
	ABSD	F2		;TAKE ABS VALUE
	CMPD	#^O026000,F2	;VERY SMALL?
	CFCC
	BGE	RTNX		;YES
	LDD	F0,F2		;
	MULD	F2,F2		;Z=Y**2
	MOV	#8.,R2		;COUNT OF CONSTANTS FOR POLYNOMIAL
	LDD	(R0)+,F1	;INITIALIZE ACCUMULATOR
XPAND:	MULD	F2,F1		;
	DEC	R2		;COUNT
	ADDD	(R0)+,F1	;F1:= Z:F1 + C(I)
	BGT	XPAND		;LOOP
;
	MULD	F1,F0		;F0:= Y*F1
RTNX:	TST	R4		;TEST SIGN FLAG
	BEQ	RTN3		;
	NEGD	F0		;SIN(-X) = -SIN(X)
RTN3:	STD	F0,-(R1)	;MOVE RESULT TO STACK
	RTS	PC		;EXIT
;
PIOV2:	.WORD	040311,007732	;PI/2
	.WORD	121041,064302	;
;
;	ORDER-DEPENDENT CONSTANTS
;
FCONST:	.WORD	040711,007732	;2*PI
	.WORD	121041,064302	;
	.ENDC
	.WORD	026716,106703	;.587061098171E-11
	.WORD	045277,146362
;
	.WORD	130467,136273	;-.66843217206396E-9
	.WORD	103054,123153
;
	.WORD	032164,074657	;.5692134872719023E-7
	.WORD	047254,154742
;
	.WORD	133561,101646	;-.3598843007208693E-5
	.WORD	167216,134016
;
	.WORD	035050,036032	;.1604411847068221E-3
	.WORD	041214,103131
;
	.WORD	136231,064546	;-.4681754135302643E-2
	.WORD	071423,125024
;
	.WORD	037243,032743	;.7969262624616544E-1
	.WORD	035655,051557
;
	.WORD	140045,056747	;-.6459640975062462
	.WORD	030455,171222
;
	.WORD	040311,007732	;1.570796326794897
	.WORD	121041,064302
;
	.IF	NDF	FPU
CONSTS:	.WORD	9.
	.ENDC

;	THE ATAN FUNCTION
;	CALLING SEQUENCE FOR ATAN:
;	CALLED WITH ARG (4-WD FL-PT NO.) ON R1 STACK
;		JSR	PC,ATAN
;		(RETURN)
;	RETURNS ARCTAN(ARG) (4-WD FL-PT NO.) ON R1 STACK
;
ATAN:	.IF	DF	DECMAP
	JSR	PC,DSCTST	;GET 'FAF' ARG AND CHECK FOR SCALING
	.IFF
	JSR	R5,INTFUN	;DEMAND A FLOATING ARG
	ARGS	FAF
	.ENDC
	.IF	NDF	FPU
	CLR	-(SP)		;CLEAR SIGN FLAG
	ASL	(R1)		;COPY SIGN OF X
	ROR	(SP)		;INTO FLAG
	ROR	(R1)		;TAKE ABS(X)
	CLR	-(SP)		;CLEAR QUADRANT BIAS
	CLR	-(SP)
	CLR	-(SP)
	CLR	-(SP)
	MOV	R1,R0		;WORKING COPY OF R1 POINTER
	CMP	(R0)+,#40200	;CHECK IF <1.
	BLO	LE1		;JUMP IF <1.
	BGT	GT1		;>1.
	TST	(R0)+		;CHECK LOW ORDER
	BNE	GT1
	TST	(R0)+
	BNE	GT1
	TST	(R0)+
	BEQ	LE1		;=1.
GT1:	MOV	SP,R0		;WORKING COPY OF STACK POINTER
	MOV	#064301,(R0)+	;-PI/2
	MOV	#121041,(R0)+	;ATAN(X)=PI/2-ATAN(1/X)
	MOV	#007732,(R0)+
	MOV	#140311,(R0)+
	ADD	#100000,(R0)	;COMPLEMENT SIGN FLAG
	MOV	R1,R2
	JSR	PC,DUPLF	;DUPLICATE ARGUMENT
	MOV	#40200,(R2)+	;INSERT 1.
	CLR	(R2)+
	CLR	(R2)+
	CLR	(R2)+
	JSR	PC,DIVF
LE1:	MOV	R1,R2
	JSR	PC,DUPLF
	CLR	(R2)+		;INSERT A 0.
	CLR	(R2)+
	CLR	(R2)+
	CLR	(R2)+
	MOV	R1,R0
	CMP	(R0)+,#037611	;TAN(15)
	BLO	LT15		;JUMP IF LESS THAN TAN(15)
	BHI	TRANS		;JUMP IF >
	CMP	(R0)+,#030242	;CHECK LOW ORDER
	BHI	TRANS
	BLO	LT15
	CMP	(R0)+,#172366
	BHI	TRANS
	BLO	LT15
	CMP	(R0)+,#065261
	BLOS	LT15		;JUMP IF =
TRANS:	MOV	#115454,-(R2)	;INSERT PI/6
	MOV	#140553,-(R2)
	MOV	#005221,-(R2)
	MOV	#040006,-(R2)
	MOV	-(R2),R4
	MOV	-(R2),R3
	MOV	-(R2),R2
	MOV	(R1),R0
	JSR	PC,ROOT3	;PUSH  -ROOT3, ARG
	CLR	-(R1)		;PUSH 1
	CLR	-(R1)
	CLR	-(R1)
	MOV	#40200,-(R1)
	JSR	PC,ROOT3	;PUSH  -ROOT3, ARG
	JSR	R4,$POLSH	;TRANSFORM ARG
;		(ROOT3*X-1)/(ROOT3 +X)
	.WORD	$MLD,$ADD,UP4,$SBD,$DVD,LT15
LT15:	JSR	R4,$POLSH
	.WORD	DUP4,DUP4,$MLD	;GET ARG**2
	.WORD	POLY4		;EXPAND POLYNOMIAL
	.WORD	CONST1		;CONST. TAB. POINTER FOR POLY4
	.WORD	$MLD,$ADD,MSPR1,MSPR1
	.WORD	$ADD		;P(X)+0 IF X<=1, P(X)-PI/2 IF X>1
	.WORD	SIGN3		;ADJUST SIGN 
	.WORD	EXIT2
EXIT2:	RTS	PC		;RETURN TO USER

; ROUTINE TO PUSH -ROOT3, ARG ON R1 STACK

ROOT3:	JSR	R0,KPUSH	;PUSH -ROOT3
	 .WORD	062524,041302,131727,140335
	MOV	R4,-(R1)	;PUSH ARG
	MOV	R3,-(R1)
	MOV	R2,-(R1)
	MOV	R0,-(R1)
	RTS	PC		;RETURN TO CALLER
;
SIGN3:	ADD	(SP)+,(R1)	;NEGATE RESULT FOR (-1,0) & (1,INF)
	JMP	@(R4)+
;
	.ENDC
	.IF	DF	FPU
	SETD			;SET DP MODE FOR FPU
	CLRD	F3		;CLEAR ATAN2 BIAS
	LDD	(R1)+,F0	;GET ARGUMENT
	CLR	R4		;CLEAR SIGN FLAG
	CFCC			;GET SIGN OF ARGUMENT
	STD	F3,F5		;F5=ATAN2 BIAS
	CLRD	F3		;CLEAR QUADRANT BIAS
	BGE	PLUSQZ		;JUMP IF QUADRANT 1 OR 3
	ABSD	F0		;ABS(X)
	INC	R4		;FLAG -
PLUSQZ:	LDD	#1.0,F1		;1.0
	CMPD	F0,F1		;CHECK IF X<=1.0
	CFCC
	BLE	LE1		;
	DEC	R4		;X>1.0, ADJUST SIGN FLAG
	DIVD	F0,F1		;1.0/X
	LDD	F1,F0		;ATAN(X)=PI/2-ATAN(1/X)
	LDD	PI2,F3		;QUADRANT BIAS=PI/2
LE1:	STD	F3,F4		;F4=QUADRANT BIAS
	CLRD	F3		;F3=0,0
	CMPD	TAN15,F0	;COMPARE TAN(15) : X
	CFCC
	BGE	LT15		;X<= TAN(15)
	LDD	PI6,F3		;F3=PI/6
	LDD	F0,F1		;
	MULD	ROOT3,F0	;
	SUBD	#1.0,F0		;X*ROOT3-1.0
	ADDD	ROOT3,F1	;X+ROOT3
	DIVD	F1,F0		;(X*ROOT3-1.0)/(X+ROOT3)
;
LT15:	LDD	F0,F2		;X
	MULD	F0,F0		;X**2
	MOV	#FCONS1,R0	;POINTER TO POLYNOMIAL CONSTANTS
	MOV	#8.,R2		;COUNT OF COEFFICIENTS
	LDD	(R0)+,F1	;INITIALIZE ACCUMULATOR
XPAND1:	MULD	F0,F1		;
	DEC	R2		;COUNT
	ADDD	(R0)+,F1	;F1:= F1* X**2 + C(I)
	BGT	XPAND1		;LOOP
	MULD	F2,F1		;F1:= F1*X
	ADDD	F3,F1		;PI/6 OR 0.0
	SUBD	F4,F1		;P(X)-QUAD BIAS
	TST	R4		;TEST SIGN FLAG
	BEQ	SIGN1		;NO ADJUSTMENT
	NEGD	F1		;NEGATE RESULT FOR (-1,0)&(1,INF)
SIGN1:	ADDD	F5,F1		;ATAN2 BIAS
;
	STD	F1,-(R1)	;MOVE RESULT TO STACK
	RTS	PC		;EXIT
;
;
PI:	.WORD	040511,007732	;PI
	.WORD	121041,064301	;
;
PI2:	.WORD	040311,007732	;PI/2
	.WORD	121041,064301	;
;
TAN15:	.WORD	037611,030242	;TAN(15)
	.WORD	172366,065261	;
;
PI6:	.WORD	040006,005221	;PI/6
	.WORD	140553,115454	;
;
ROOT3:	.WORD	040335,131727	;
	.WORD	041302,062524	;
	.ENDC
FCONS1:	.WORD	037065,150707	;.0443895157187
	.WORD	162300,163030
;
	.WORD	137204,143233	;-.06483193510303
	.WORD	004010,000413
;
	.WORD	037235,043002	;.0767936896066
	.WORD	027154,142446
;
	.WORD	137272,025671	;-.0909037114191074
	.WORD	116412,065630
;
	.WORD	037343,107047	;.11111097898051048
	.WORD	023625,025401
;
	.WORD	137422,044444	;-.14285714102825545
	.WORD	071335,116151
;
	.WORD	037514,146314	;.19999999998729448
	.WORD	146224,165650
;
	.WORD	137652,125252	;-.33333333333329930
	.WORD	125252,113602
;
	.WORD	040200,000000	;.999999999999999
	.WORD	000000,000000
	.IF	NDF	FPU
CONST1:	.WORD	9.
	.ENDC

	.END

