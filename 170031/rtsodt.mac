TITLE	RTSODT,<OCTAL DEBUGGING TOOL>,11,19-NOV-81,TPH/MHB/ABC/SSS/SJK

;                   Copyright 1974,1990 by Digital Equipment Corporation
;                                  All rights reserved.
;
;          This software is furnished under a license and may be used and copied
;          only  in  accordance  with  the  terms  of  such license and with the
;          inclusion of the above copyright notice.  This software or any copies
;          shall not be provided to any other person.   No title to or ownership
;          of the software is hereby transferred.
;
;          The information in this software is subject to change without notice.
;
;          DIGITAL  assumes  no  responsibility  for the  use, functionality, or
;          reliability of its  software  on equipment  which  is not supplied by
;          DIGITAL.

.SBTTL	EDIT HISTORY FOR RTSODT
;+
;
;  000  RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;
;-

.SBTTL	USER INSTRUCTIONS

; WHEN LINKING RTSODT WITH A RUN-TIME SYSTEM, THE RTS MUST (OF COURSE)
;	HAVE ITS VECTORS AS THE HIGHEST .CSECT.
; RTSODT SHOULD BE LINKED IN AFTER THE RTS'S VECTORS, SINCE IT
;	ASSUMES THEY ARE JUST BELOW ITSELF.
;
; THE RUN-TIME SYSTEM CONTAINING RTSODT MUST BE LOADED INTO MEMORY
;	READ/WRITE.
; THE FIRST USER TO ENTER THE RTS OBTAINS CONTROL OF ODT.  SUBSEQUENT
;	USERS ARE IGNORED BY ODT, WHICH IS TRANSPARENT TO THEM.
;
; RTSODT TAKES CONTROL OF ALL RTS ENTRY VECTORS, AND IS ENTERED
;	WHENEVER THE RTS IS ENTERED FROM THE MONITOR.
; TO CAUSE A PARTICULAR TRAP TO BE PASSED STRAIGHT TO THE RTS,
;	DO THE FOLLOWING (SUBSTITUTE THE ACTUAL ADDRESS FOR P.???):
;		+P.???/XXXXXX	@
;		+XXXXXX/000003	240
;	SUBSTITUTING A NOP FOR THE BPT AT THE DISABLED ENTRY POINT.
;
; WHENEVER RTSODT INTERCEPTS AN RTS ENTRY, YOU MAY CONTINUE TO THE
;	ACTUAL ENTRY POINT WITH A 'P' (PROCEED) COMMAND.
;
; RTSODT WORKS WHETHER OR NOT THE RTS IS LOADED WITH THE '/EMT'
;	OPTION.

.SBTTL	USER STATE AREA AND DATA CONTROL

.CSECT	.99ODT		;PUT ODT INTO A UNIQUE .CSECT
ODT:			;DEFINE ODT'S START (LOWEST ADDRESS)

.MACRO	DOEMT	EMT
	 JSR	R5,DOEMT
	  .WORD	EMT
.ENDM	DOEMT

;SOME ODT TYPE DEFINITIONS (THESE ARE NOT PARAMETERS).

O.BKP	=16		;NUMBER OF BREAKPTS-1 X 2
O.RLR	=16		;NUMBER OF CORE RELOC. REGISTERS -1 X 2
O.TBT	=20		;T-BIT MASK, PROCESSOR STATUS

;SET UP THE REAL THING FINALLY

.	=	.+100	;LEAVE SOME ODT STACK SPACE
ODTSTK:

;THE ORDER OF THESE ITEMS IS INTENTIONAL, SEE REGISTER MAPPING SCHEME

INTBEG	=.	;STARTING ADDRESS OF INTERNAL REGISTERS

O.UR0:	0	;USER R0			$0
	0	;     R1			$1
	0	;     R2			$2
	0	;     R3			$3
	0	;     R4			$4
	0	;     R5			$5
O.USP:	0	;USER SP			$6
O.UPC:	0	;USER PC			$7
O.UST:	0	;USER ST			$S
O.ARG:	0	;ARGUMENT REGISTER		$A
O.MSK:	-1	;MASK				$M
O.LOW:	0	;LOW LIMIT			$L
O.HI:	0	;HIGH LIMIT			$H
O.CNST:	O.ODT	;CONSTANT REGISTER		$C
O.QUAN:	0	;QUANTITY REGISTER		$Q
O.FORM:	0	;FORMAT REGISTER		$F
O.PRNT:	0	;PRINT FORMAT REGISTER		$=
O.JOB:	0	;ODT OWNER JOB INDEX		$J

.SBTTL	BREAKPOINT AND RELOCATION TABLES

INTINX	=.	;STARTING ADDRESS OF INTERNAL TABLES

;BREAKPOINT CONTROL LISTS

O.BKAC:	.BLKW0	9.,-1		;ACTION ROUTINES FOR BPT'S	($0D-$10D)

O.ADR1:	.BLKW0	9.,O.TRTC	;ADDRESS OF THE BREAKPOINT	($0B-$7B)

O.CT:	.BLKW0	9.,0.		;PROCEED COUNT			($0G-$7G)

O.UIN:	.BLKW0	9.,BPT		;USER INSTRUCTION SAVE LOCATION	($0I-$7I)

;RELOCATION REGISTERS

O.RELT:	.BLKW0	8.,-1		;RELOCATION TABLES		($0R-$7R)

INTEND	=.	;END OF INTERNAL RESISTERS AND TABLES

; ACTION ROUTINE STORAGE

O.ACTN:	.BLKW0	8.*32.		;ACTION ROUTINE STORAGE

.SBTTL	INTERNAL DIRTY DATA AREA

;WORDS AND ORDERED BYTES, ITEMS MUST BE KEPT FROM COMMAND TO COMMAND

O.CAD:	.WORD	0	;ADDRESS OF CURRENTLY OPEN REGISTER
O.DOT:	.WORD	0	;ADDRESS OF LAST EXPLICITLY OPENED CELL
O.BW:	.WORD	0	;OPEN CELL TYPE, 0=NONE, 1=BYTE, 2=WORD
O.OPN:	.WORD	0	;LOCATION OPEN FLAG 0=NOT OPEN, NON-ZERO=OPEN
D.ARGS:	.WORD	0	;SEMI COLON PUSH WORD


;THE FOLLOWING ITEMS NEED NOT BE KEPT FROM COMMAND TO COMMAND
;THEIR ORDER IS INTENTIONAL SO KNOW THY MAKER!

O.OP:	.BYTE	0	;CURRENT ARITHMETIC OPERATOR
	.ODD		;FIRST BYTE GOTTA BE AT ODDS
O.ALFA:	.BYTE	0	;AREA FOR RADIX 50 CONVERSION, 3 BYTES!
O.EXP:	.WORD	0	;EXPRESSION BUCKET, LAST 2 BYTES OF O.ALFA!
O.SMFD:	.BYTE	0	;SEMI-COLON COUNTER

;THE FOLLOWING ITEMS MUST BE KEPT FROM COMMAND TO COMMAND.

O.T:	.BYTE	0	;T BIT IN USE FLAG
O.P:	.BYTE	-1	;PROCEED ALLOW FLAG
O.S:	.BYTE	0	;SINGLE INSTRUCTION MODE, 0=NORMAL, -1=ENABLE
O.FM:	.BYTE	2	;OUTPUT FORMAT MODE, BYTE, WORD, ANSII, RAD50
O.OBW:	.BYTE	2	;OPEN CELL TYPE, 1=BYTE, 2=WORD
O.SEQ:	.BYTE	0	;CHANGE SEQUENCE INDICATIOR

;ACTION ROUTINE NEXT CHARACTER POINTER

	.EVEN
O.GETP:	.WORD	0	;-> NEXT CHARACTER IN ACTION ROUTINE

;RSTS STUFF

O.XRB:	.BLKB	XRBSIZ	;SAVED RSTS XRB
O.BUF:	.BLKW	1	;CHARACTER I/O BUFFER

.SBTTL	INTERNAL REGISTER NAME AND CONTROL TABLES

;NON-INDEXED REGISTER NAMES

NIXMAP:	.ASCII	/01234567/	;USER REGISTER NAMES FOR MAPPING

NIXREG:	.BYTE	'S	;O.UST	USER STATUS
	.BYTE	'A	;O.ARG	ARGUMENT
	.BYTE	'M	;O.MSK	MASK REGISTER
	.BYTE	'L	;O.LOW	LOW SCAN LIMIT
	.BYTE	'H	;O.HI	HIGH SCAN LIMIT
	.BYTE	'C	;O.CNST	CONSTANT
	.BYTE	'Q	;O.QUAN	QUANTITY
	.BYTE	'F	;O.FORM	FORMAT CONTROL
	.BYTE	'=	;O.PRNT	PRINT FORMAT CONTROL
	.BYTE	'J	;O.JOB	JOB INDEX OF OWNER

	.BYTE	00	;END OF THIS LIST

;INDEXED REGISTER NAMES

INXREG:	.BYTE	'D	;O.BKAC	BKPT ACTIONS
	.BYTE	'B	;O.ADR1	BKPT ADDRESSES
	.BYTE	'G	;O.CT	BKPT PROCEED COUNTS
	.BYTE	'I	;O.UIN	BKPT USER INSTRUCTIONS
	.BYTE	'R	;O.RELT	RELOCATION REGISTERS

	.BYTE	00	;END OF THIS LIST

;INDEXED REGISTER TABLE BASES

	.EVEN
INXTBL:	.WORD	O.BKAC	;BKPT ACTION #'S
	.WORD	O.ADR1	;BKPT ADDRESS TABLE
	.WORD	O.CT	;BKPT PROCEED COUNTS
	.WORD	O.UIN	;BKPT'D INSTRUCTION
	.WORD	O.RELT	;RELOCATION TABLES
	.WORD	INTEND	;END OF TABLE AREA FOR ADDRESS MAPPING


.SBTTL	COMMAND NAME AND DISPATCH TABLES

COMTAB:		;ADDRESS OF THE CHARACTER TABLE

;OPEN REGISTER COMMANDS (ORDER AND POSITION CRITICAL)

	.BYTE	'\,'/,'','",'%

;CLOSE REGISTER COMMANDS

	.BYTE	015,012,'^,'_,'@,'>,'<

;SPECIAL FORMS

	.BYTE	'$,'=,'C,'Q,'.

;OPERATORS (ORDER OF -+* IS CRITCAL)

	.BYTE	';,'-,'+,'*,',,'!,'&

;COMMANDS

	.ASCII	/()[]ABDEFGKLNOPRSWX/

	.BYTE	00	;******* END OF THE LIST *******

;THE DISPATCH TABLE, ORDERED ON ABOVE TABLE

	.EVEN		;THIS CAN HAPPEN TO YOU!!!!

;OPEN REGISTER COMMANDS

COMDIS:	+	OCBYTE	;\	OPEN OCTAL BYTE
	+	OCWORD	;/	OPEN OCTAL WORD
	+	ANBYTE	;'	OPEN ANSII BYTE
	+	ANWORD	;"	OPEN ANSII WORD
	+	MODULO	;%	OPEN RADIX 50 WORD

;CLOSE REGISTER COMMANDS

	+	CLCRET	;<CR>	CLOSE, NO SUCESSIVE OPEN
	+	CLLNFD	;<LF>	CLOSE, OPEN NEXT
	+	CLUPAR	;^	CLOSE, OPEN PREVIOUS
	+	CLBACK	;_	CLOSE, OPEN PC RELATIVE MODE
	+	CLATSG	;@	CLOSE, OPEN INDIRECT
	+	CLGRTH	;>	CLOSE, OPEN PC OFFSET AS BRANCH
	+	CLLSTH	;<	CLOSE, OPEN OLD SEQUENCE

;SPECIAL FORMS

	+	O.REGT	;$	INTERNAL REGISTER REFERENCE
	+	EQUALS	;=	PRINT LEFT SIDE IN OCTAL
	+	CHRCEE	;C	CONSTANT REGISTER CONTENTS
	+	CHRQUE	;Q	QUANTITY REGISTER CONTENTS
	+	CHRDOT	;.	LAST OPENED LOCATION'S ADDRESS

;OPERATORS

	+	O.SEMI	;;	MULTIPLE ARGUMENT DELIMITER
	+	O.MINS	;-	SUBTRACTION
	+	O.PLUS	;+	ADDITION
	+	O.STAR	;*	MULTIPLY BY 50
	+	O.COMM	;,	RELOCATION COMPUTE
	+	O.EXCL	;!	SHIFT
	+	O.AMPR	;&	AND

;COMMANDS

	+	O.LPAR	;(	SET AN ACTION
	+	O.RPAR	;)	TYPE AN ACTION
	+	O.COND	;[	START OF CONDITIONAL
	+	O.DCD	;]	END OF CONDITIONAL
	+	O.DOAC	;A	DO AN ACTION
	+	O.SEBK	;B	SET / CLEAR BREAKPOINTS
	+	O.SEBA	;D	SET / CLEAR ACTION #'S FOR BREAKPOINTS
	+	O.EFFA	;E	EFFECTIVE ADDRESS SEARCH
	+	O.FILL	;F	MEMORY FILL
	+	O.GOTO	;G	GO TO USER'S DATA
	+	O.KILO	;K	KOMPUTE AND TYPE RELOCATION DATA
	+	O.LIST	;L	LIST MEMORY ON SPECIFIED DEVICE
	+	O.NOTW	;N	NOT WORD SEARCH
	+	O.OFST	;O	TYPE PC RELATIVE OFFSETS
	+	O.PROC	;P	PROCEED FROM BREAKPOINT
	+	O.RELO	;R	SET / RESET RELOCATION REGISTERS
	+	O.SNGL	;S	SET / RESET SINGLE STEP MODE
	+	O.WSCH	;W	MEMORY WORD SEARCH
	+	O.EXIT	;X	EXIT FROM ODT

; SPECIAL INPUT MODES

INPMOD:	.BYTE	'%	;INPUT RAD50 WORD
	.BYTE	''	;INPUT SINGLE ASCII CHARACTERS
	.BYTE	'"	;INPUT 2 ASCII CHARACTERS
	.BYTE	'.	;INPUT DECIMAL NUMBER
	.BYTE	'#	;INPUT OCTAL NUMBER

	.BYTE	00	;END OF LIST

INPUTS:	.WORD	INPRAD	;$%XXX		RAD50 INPUT
	.WORD	INPBYT	;$'X		SINGLE CHARACTER
	.WORD	INPASC	;$"XX		TWO CHARACTERS
	.WORD	INPDEC	;$.NNNNN	DECIMAL NUMBER
	.WORD	INPOCT	;$#OOOOOO	OCTAL NUMBER

.SBTTL	MAJOR ENTRY AND RE-ENTRY POINTS

; INITIALIZE ODT
;  USE O.ODT FOR A NORMAL ENTRY, COMPLETE CLEAN RE-START
;  USE O.ODT+2 TO RE-ENTER (I.E. - FAKE A BREAKPOINT)

O.ODT::	BR	O.STRT		;NORMAL ENTRY

;RE-ENTER AS IF BREAKPOINT, BAD ONE AT THAT

O.ENTR:	CLR	-(SP)		;SET PS AS IF INTERRUPT
	MOV	#O.ENTR-2,-(SP)	;SET PC, IT GETS BUMPED BY 2 ON BE'S
	CLRB	O.S		;FAST EXECUTION MOOD
	JMP	O.BRK		;IT IS A BREAK, RUN LIKE HELL

;START ODT FROM SCRATCH, CLEAN SLATE

O.TRTC:	BPT			;TRACE TRAP ENTRY AND PROTOTYPE

O.STRT:	CLR	O.UST		;SAVE STATUS AND RUN AT ENTRY STATUS
	CALL	O.SVR,R0	;SAVE REGISTERS (MAINLY SP)
	MOV	#ODTSTK,SP	;SET A STACK TO GO WITH
	CALL	O.RUAL		;RESET RELOC AND UNIT
	CLRB	O.S		;DISABLE SINGLE INSTRUCTION FOR NOW
	MOVB	#-1,O.P		;DISALLOW PROCEED
	MOV	#O.BRK,@#14	;SET THE VECTOR FOR ODT TYPE
	CLR	@#16		; TRAPS
	JMP	O.RALL		;CLEAR BRK PT TABLES GOT TO DECODER

; EXIT FROM ODT

O.EXIT:	DOEMT	.EXIT		;ENSURE AN EXIT

.SBTTL	COMMAND PROCESSORS

.SBTTL	"$,<ALT-MODE>" PROCESSOR - INTERNAL REGISTER MAPPER

;SYNTAX--
;$L		DELIVER INTERNAL ADDRESS OF L
;$NL		DELIVER INTERNAL ADDRESS OF L+2N
;$N		DELIVER INTERNAL ADDRESS OF USER REGISTER N
;$XYYY		TRANSLATE SPECIAL FORM OF TYPE X

;SEE MAPPING TABLES, RANGE OF N IS 0-37

O.REGT:	CALL	GETNUM		;GET AN OCTAL NUMBER
	CALL	O.RTST		;CHECK FOR ERROR
	BCS	O.ERR0		;MPY R4 X 2
	TST	R2		;SEE IF ANYTHING TYPED
	BNE	20$		;IF SO IS INDEXED OR USER REGISTER?
	CALL	LOOKUP,R5,NIXREG;SEE IF NON-INDEXED
	BCC	10$		;IT IS INDEED NON-INDEXED
	CALL	LOOKUP,R5,INPMOD;IS IT SPECIAL INPUT MODE
	BCS	O.ERR0		;NO, IT'S AN ERROR
	CALL	@INPUTS(R1)	;YES,GET A SPECIAL FORM OF INPUT
	BCC	MKGTGO		;C=0 MEANS WE NEED TO GET A CHARACTER
	BR	MKGO		;ELSE R0 HAS DISPATCH CHARACTER

10$:	MOV	R1,R4		;PLACE IN LIST IS INTERNAL ORDER
	ADD	#O.UST,R4	;GET ADDRESS IN R4, GOTTA READ CHAR
	BR	MKGTGO		;MARK R2 REAL, GET ANOTHER CHAR, GO DO IT

20$:	CALL	LOOKUP,R5,INXREG;SEE IF INDEXED
	BCC	40$		;WAS TRULY INDEXED
	CMP	#7*2,R4		;INTERNAL USER REGISTER RANGE CHECK
	BLO	O.ERR0
	ADD	#O.UR0,R4	;SET ACCESS TO R0-R7 OF THE USER
	BR	MKGO		;MARK R2 REAL, DISPATCH ON CHAR IN R0

40$:	ADD	INXTBL(R1),R4	;COMPUTE ADDRESS TO INDEXED TABLE
	BR	MKGTGO		;MARK R2 REAL, GET ANOTHER CHARACTER, GO ON IT


.SBTTL	"A-Q-." PROCESSORS - SPECIAL VALUES

;MERELY SUBSTITUTE THE VALUE IN R4 WITH THE CONTENTS OF THE SPECIFIED
;REGISTER.

CHRQUE:	MOV	O.QUAN,R4	;LAST QUANTITY PRINTED
	BR	MKGTGO

CHRCEE:	MOV	O.CNST,R4	;CONSTANT REGISTER
	BR	MKGTGO

CHRDOT:	MOV	O.CAD,R4	;CURRENT LOCATION
MKGTGO:	CALL	O.GET		;GET NEXT CHARACTER AND ASSUME IT'S TERMINATOR
MKGO:	INC	R2		;ALLOW AS R4 IS REAL
	JMP	O.CLGL		;PROCESS CHARACTER AS TERMINATOR

.SBTTL	"B" PROCESSOR - SET AND REMOVE BREAKPOINTS

;SYNTAX--
;B			CLEAR ALL BREAKPOINTS
;NB			CLEAR BKPT N
;A;B			SET BKPT AT A, USE FIRST FREE  BKPT
;A;NB			SET BKPT N AT A

;DEPENDS MIGHTILY UPON LOCATION "O.TRTC" CONTAINING A TRAP INST.
;AND THAT A FREE BKPT CONTAINS THE ADDRESS "O.TRTC".

O.SEBK:	ASL	R4		;MPY R4 X2, JUST IN CASE ALL IS GO
	MOV	#O.TRTC,R0	;SET MAGIC VALUE IN R0, JUST IN CASE
	TST	R3		;CHECK FOR THE REAL CASE
	BEQ	O.REMB		;REMOVAL CASES, CLEAR THEM UP
	BIT	#1,R5		;LOOK AT ADDRESS
	BNE	O.ERR		;THAT'S ODD ?
	TST	R2		;SEE IF I GET TO PICK IT OR NOT
	BNE	O.SE04		;OR NOT, DISAPPOINTMENT
O.SE02:	CMP	R0,O.ADR1(R4)	;LOOK FOR LOCATION WITH FREE ADDRESS
	BEQ	O.SE04		;A HIT
	TST	(R4)+		;KEEP AT FOR A LONG WHILE
	BR	O.SE02		;LOOOOOOOOP

O.SE04:	MOV	R5,R0		;R0 HAS ADDRESS OF BREAKPOINT
	BR	O.RE02		;GO TUCK IT IN

;REMOVE SOME BREAKPOINTS

O.REMB:	TST	R2		;SEE IF ONE OR ALL
	BEQ	O.RALL		;ALL
O.RE02:	CALL	SETBRK		;SET THE ONE SET UP TO SET
	BCC	O.DCD		;IT HAPPENED
O.ERR0:	BR	O.ERR		;SOME THING WENT WRONG

;REMOVE ALL BREAKPOINTS  (N.B. CALLED BY THE INIT CODE)

O.RALL:	MOV	#O.TRTC,R0	;MAGIC IN R0
	CLR	R4		;R4 IS ZERO
O.RA01:	CALL	SETBRK		;SET THEM TILL
	BCC	O.RA01		;THEY GET OUTTA
O.DCD0:	BR	O.DCD		;HAND!!!!

.SBTTL	"R" PROCESSOR -RELOCATION REGISTER PROCESSING

;DETERMINE IF CLEAR OR SET

O.RELO:	TSTB	O.SMFD		;SEMI-COLON ABSENT MEANS CLEAR
	BEQ	O.RCLR		;CLEAR DISPATCH, OR FALL TO SETTING

;FORMS HERE--
; A;NR			SET RELOC(N) TO A
;ABSENT A OR N DEFAULTS TO 0

	CALL	O.RTST		;PROTECTION EDITING
	BCS	O.ERR		;ILLEGAL REGISTER NUMBER ?
	MOV	R5,O.RELT(R4)	;SET THE APPROPRIATE REGISTER
	BR	O.DCD		;GO GET NEXT COMMAND

;FORMS HERE--
;R			RESET ALL TO -1 FOR RELOC(0-7)
;NR			RESET ONLY RELOC(N)

O.RCLR:	TST	R2		;SEE IF NR OR JUST R
	BEQ	O.RC01		;CLEAR ALL
	CALL	O.RUCL		;CLEAR THE ONE IN R4
	BCS	O.ERR		;ERROR, INVALID REGISTER ?
	BR	O.DCD		;NEXT COMMAND

O.RC01:	CALL	O.RUAL		;DO THEM ALL
	BR	O.DCD		;OFF AND ON

.SBTTL	"K" PROCESSOR - COMPUTE AND PRINT RELOCATION

;SYNTAX--
;AK				TYPE RELOCATION DEAL FROM DOT TO A
;L;AK				TYPE RELOCATION DEAL FROM L TO A

;IF A IS NULL THE THE OLD BEST FIT RULE APPLIES
;TYPES	=N,DDDDDD	WHERE N IS THE RELOCATION REGISTER
;				AND D-D IS THE RELOCATION BIAS

O.KILO:	TST	R2		;SEE WHO PICKS THE REGISTER
	BNE	O.KI02
	CALL	O.LOC		;WE PICK IT
	BMI	O.ERR		;CAN'T FIND ONE THATS GOOD
	MOV	R0,R4		;R4 HAS OUR PICK
O.KI02:	BIC	#177770,R4	;EDIT REGISTER
	CALL	O.TYPC,R5,<" =>	;TYPE CUE
	MOVB	R4,R0		;TYPE REGISTER & A ,
	CALL	O.TYPA,R5,<"0,>
	ASL	R4		;GO GET IT AS TABLE INDEX
	TST	R3		;SEE WHO TYPED THE ADDRESS
	BNE	O.KI04
	MOV	O.CAD,R5	;THAT CAD!
O.KI04:	SUB	O.RELT(R4),R5
	MOV	R5,R0		;BIAS COMPUTE
	CALL	O.CADW		;PRINT AS WORD
	BR	O.DCD

.SBTTL	COMMAND DE-CODER AND MAIN LOOP OF ODT

;  ALL REGISTERS MAY BE USED (R0-R5),

;ERROR ENTRY, TYPE FLAG AND GO DO COMMAND

O.ERR:	DOEMT	.TTRST		;CANCEL ANY CTRL/O IN EFFECT
	CLR	O.GETP		;CLEAR ANY INDIRECTORS
	CALL	O.TYPC,R5,<" ?>	; TYPE A SPACE THEN A QUESTION MARK


;DECODE FROM THE TOP, CLOSE ALL AND DO CR/LF/+

O.DCD:	CALL	O.CRLF		;TYPE  <CR><LF>
O.DCDX:	MOV	#ODTSTK,SP	;SET THE STACK FOR SANITY
	CLR	O.OPN		;SET NO LOCATION OPEN
	DOEMT	.TTRST		;CANCEL ^O
	DOEMT	.TTECH		;ENABLE ECHO
	MOVB	#'+,R0		;+ TO GO NEXT
	CALL	O.FTYP

;MAINTAIN OPENED LOCATION, RE-INIT INPUT

O.NEWC:	CLRB	O.SMFD		;CLEAR SEMI-COLON FLAG/COUNT
	CLR	R3		;ZERO SECONDARY ARGUMENT FLAG
	CLR	R5		;AND ARGUMENT

;NEW SUB-EXPRESSION ENTRY

O.NEWE:	CLRB	O.OP		;CLEAR OPERATOR FOUND
	CLR	O.EXP		;SET ZERO IN EXPRESSION SO FAR LOCATION

;GET NUMBER AND THEN SCAN FOR COMMAND

O.NEWN:	CALL	GETNUM		;GET AN OCTAL NUMBER AND TERMINATOR

;NON-OCTAL CHAR TYPED WHAT ARE WE TO DO?

O.CLGL:	CALL	LOOKUP,R5,COMTAB;GO SEE IF IT IS REAL
	BCS	O.ERR		;EASY ENOUGH IF NOT REAL
	TST	R2		;IF NOTHING TYPE BOTHER NOT
	BEQ	O.CL01		;WITH THE EXPRESSION
	CALL	EXPCOM		;COMPUTE EXPRESSION
O.CL01:	JMP	@COMDIS(R1)	;GO TO PROPER ROUTINE

;FOR THE BENEFIT ALL REGISTERS ARE AS FOLLOWS

;R0	LAST CHARACTER TYPED, THE COMMAND ITSELF!
;R1	TABLE INDEX TO COMMAND ADDRESSES, IT IS USED.
;R2,R4	FIRST ARGUMENT, IF R2<>0 THEN R4 IS DATA
;R3,R5	SECOND ARGUMENT, IF R3<>0 THEN R5 IS DATA

.SBTTL	EXPRESSION SETUP COMMANDS
.SBTTL	";", SEMI-COLON PROCESSOR

O.SEMI:	INCB	O.SMFD		;COUNT SEMI-COLON
	CMPB	#2,O.SMFD	;PUSH CONTENTS INTO MULTI
	BNE	O.SEM1		;SEMI COLON ARG LIST
	MOV	R5,D.ARGS
O.SEM1:	MOV	R2,R3		;PUSH R2 AND R4 INTO
	MOV	R4,R5		;R3 AND R5 (FLAG AND CONTENTS)
	BR	O.NEWE		;CONTINUE SCANNER

;MEMORY RELOCATION CHECK

O.COMM:	ASL	R4		;ALL NEED IT X 2
	CMP	R4,#O.RLR	;SEE IF REGISTER IS OUT OF RANGE
	BGT	O.ERR
	MOV	O.RELT(R4),O.EXP	;COMPUTE REAL CORE ADDRESS
	.BR	O.PLUS

.SBTTL	"+", ADDITION SETUP

O.PLUS:	CLRB	R4		;OP IS 0 FOR +
	BR	O.CO00

.SBTTL	"-", SUBTRACT SET UP

O.MINS:	MOVB	#2,R4		;OP IS 2 FOR -
	BR	O.CO00

.SBTTL	"*", MULTIPLY BY 50 AND ADD

O.STAR:	MOVB	#-2,R4		;OP IS -2 FOR *
	BR	O.CO00

.SBTTL	"!", SHIFT

O.EXCL:	MOVB	#-4,R4		;OP IS -4 FOR !
	BR	O.CO00

.SBTTL	"&", LOGICAL AND

O.AMPR:	MOVB	#-6,R4		;OP IS -6 FOR &
	.BR	O.CO00

O.CO00:	MOVB	R4,O.OP		;SET THE OP CODE
	CLR	R4		;R4 IS RESET
	BR	O.NEWN

.SBTTL	OPEN AND CLOSE PROCESSORS

;"\-/-'-"-%-:" PROCESSOR - OPEN AND TYPE CONTENT COMMANDS

;SYNTAX--
;NC				OPEN LOC N IN MODE C, SET MODE FOR NEXT
;C				TYPE LAST OPENED LOC IN MODE C

OCWORD:		;OCTAL WORD -		R1=2
ANWORD:		;ANSII WORD -		R1=6
MODULO:		;RADIX 50 WORD -	R1=10

;OPEN WORD MODE ENTRY, R1 CONTAINS FORMAT INDEX

	MOV	#2,R0		;SET BYTE FLAG TO WORD FLAG
	BR	OPE004		;GO TO IT ACE HOLE

OCBYTE:		;OCTAL BYTE -		R1=0
ANBYTE:		;ANSII BYTE -		R1=4

OPE001:	MOV	#1,R0		;SET WORD FLAG TO BYTE FLAG
OPE004:	TST	R2		;IF NO VALUE TYPED NO MODE SET
	BEQ	OPE005
	MOV	R0,O.BW		;SET MODE AND FORMAT FLAGS
	MOVB	R0,O.OBW	;SET THE LATER USE MOOD
	MOVB	R1,O.FM		;SET THE MODE FLAG FOR SOOTH
	MOV	R4,O.CAD	;SET ADDRESS FOR EXPLICIT OPEN
	MOV	R4,O.DOT	;RESET RETURN PTR.
OPE005:	CMP	#1,R0		;CHECK ON BYTE MOOD
	BEQ	OPE010		;NOT BYTE MODE
	BIT	#1,O.CAD	;SEE IF ADDRESS IS ODD
	BEQ	OPE010		;ALL IS GOOD
	CLR	R1		;THEY GET BYTE MODE ONLY
	BR	OPE001

OPE010:	MOV	R1,-(SP)	;SAVE FORMAT MAINLY
	CALL	GETCAD		;GET THE DATA
	MOV	(SP)+,R1	;GET FORMAT
	CALL	@TYFORM(R1)	;PRINT DATA IN PROPER FORMAT
	BR	O.NEWC		;GO GETTA NEW COMMAND TO DO

;"<CR>-<LF>->-<-^-_-@" PROCESSOR - CLOSE AND OPEN REFERENCED REGISTERS

.SBTTL	"<CR>", CARRIAGE RETURN

CLCRET:	CALL	PUTCAD		;CLOSE LOCATION
	BR	O.DCDX		;RETURN TO DECODER

.SBTTL	"<", LESS THAN, BACK TO MAIN STREAM

CLLSTH:	INCB	O.SEQ		;SET FLAG TO LATER RESTORE CAD
	CALL	O.CRLF		;RESTORE CARRIAGE

.SBTTL	"<LF>", LINE FEED, NEXT ONE DOWN

CLLNFD:	CALL	O.TYPC,R5,15	;ENSURE RESTORED CARRIAGE (WITH FILL ..)
	CALL	PUTCAD		;CLOSE PRESENT CELL
	TSTB	O.SEQ		;SHOULD CAD BE RESTORED?
	BEQ	O.OP5		;BRANCH IF NOT
	MOV	O.DOT,O.CAD	;RESTORE PREVIOUS SEQUENCE
	CLRB	O.SEQ		;RESET FLAG; NO LONGER NEEDED
	BR	O.OP2A
O.OP5:	ADD	O.BW,O.CAD	;GENERATE NEW ADDRESS
O.OP2:	MOV	O.CAD,O.DOT	;INITIALIZE DOT
O.OP2A:	MOV	O.CAD,R0	;NUMBER TO TYPE
	CALL	O.RORA		; CHECK FORMAT
	MOVB	O.FM,R0		;SET FORMAT
	ASR	R0		;SPLIT R0 IN HALF
	MOVB	COMTAB(R0),R0	;SET SUFFIX CHARACTER
	CALL	O.FTYP		;PRINT IT
	MOV	O.CAD,R4	;SET UP THE DATA
	CLR	R2		;SET TO USE O.CAD ADDRESS
	CLRB	O.OP		;THIS IS BECUZE
	CLR	O.EXP
	BR	O.CLGL		;R0 HAS TERMIN, R4- DATA, R2= FLAG

.SBTTL	"^", UP ARROW, NEXT ONE UP

CLUPAR:	CALL	PUTCAD
	SUB	O.BW,O.CAD	;GENERATE NEW ADDRESS
	CALL	O.CRLF		;NEW LINE
	BR	O.OP2		;GO DO THE REST

.SBTTL	"_", UNDERLINE, PC RELATIVE COMPUTE

CLBACK:	CALL	O.TCLS		;TEST WORD MODE AND CLOSE
	ADD	@R2,R2		;COMPUTE
	INC	R2
	INC	R2		;   NEW ADDRESS
O.PCS:	MOV	R2,O.CAD	;UPDATE CAD
	CALL	O.CRLF		;NEW LINE
	BR	O.OP2A		;GO FINISH UP

.SBTTL	"@", AT SIGN, ABSOLUTE OR INDIRECT CHAIN

CLATSG:	CALL	O.TCLS		;TEST WORD MODE AND CLOSE
	MOV	@R2,R2		;GET ABSOLUTE ADDRESS
	BR	O.PCS

.SBTTL	">", GREATER THAN, PC OFFSET BRANCH ADDRESS

CLGRTH:	CALL	O.TCLS		;TEST AND CLOSE
	MOVB	@R2,R1		;COMPUTE NEW ADDRESS, EXTEND SIGN
	ASL	R1		;R2=2(@R2)
	INC	R1		;   +2
	INC	R1
	ADD	R1,R2		;   +PC
	BR	O.PCS

;HANDY DANDY TO DO SOME LEG WORK

O.TCLS:	CALL	PUTCAD		;CLOSE CURRENT CELL
	CMP	#2,O.BW		;ONLY WORD MODE ALLOWED
	BNE	O.ERR1		;BRANCH IF ERROR
	MOV	O.CAD,R2	;CURRENT ADDRESS IN R2
	RTS	PC

.SBTTL	COMMAND PROCESSORS, SECTION TWO

.SBTTL	"O" PROCESSOR - COMPUTE AND PRINT OFFSETS

;SYNTAX--
;AO				TYPE OFFSETS FROM . TO A
;L;AO				TYPE OFFSETS FROM L TO A

;TYPES	_PPPPPP >DDDDDD			WHERE P-P IS PC RELATIVE
;					AND D-D IS BRANCH OFFSET

O.OFST:	TST	R3		;HOW ABOUT A VALUE OTHER
	BNE	O.OF01		;THAN CAD
	MOV	O.CAD,R5	;RELUCTANTLY
O.OF01:	SUB	R5,R4
	SUB	#2,R4		;NO TRICKS, ODD AND NON-EXIST THINGS
	CALL	O.TYPC,R5,<" _>	;TYPE PC RELATIVE CUE
	MOV	R4,R0
	MOV	R4,-(SP)	;GOOD IDEA TO SAVE THIS
	CALL	O.CADW		;TYPE VALUE + BLANK
	MOVB	#'>,R0		;TYPE OFFSET BRANCH CUE
	CALL	O.FTYP
	MOV	(SP)+,R0
	ASR	R0		;DIVIDE
O.OF09:	CALL	O.CADW		;16 BITS SO YOU CAN SEE HOW FAR OFF
	JMP	O.DCD		;YOU ARE

;JUST ANOTHER ERROR CALL

O.ERR1:	JMP	O.ERR

.SBTTL	"G" PROCESSOR - GO TO PROGRAM COMMAND

;SYNTAX--
;LG			START PROGRAM AT LOCATION L
;G			START PROGRAM AT CURRENT PC

O.GOTO:	TST	R2		;SEE IF SPECIFIC ADDRESS
	BNE	O.GO01		;NO
	MOV	O.UPC,R4	;USE PC AS IT IS
O.GO01:	ASR	R4		;SEE IF STRANGE
	BCS	O.ERR1		;THAT'S ODD ?
	ASL	R4
	MOV	R4,O.UPC	;SET THE PC
	CLRB	O.S		;NO SINGLE INSTRUCTIONS
	MOVB	#O.BKP+3,O.P	;GOTTA BREAK TO PROCEED
O.TBIT:	CLRB	O.T		;CLEAR T-BIT FLAGS
	BIS	#O.TBT,O.UST	;BOTH
	TSTB	O.S		;SEE IF WE NEED A T-BIT BIT
	BMI	O.GO2		;NO GO ON
	BIC	#O.TBT,O.UST	;SET THE TEE BIT
	CALL	O.RSB		;RESTORE BREAKPOINTS
O.GO2:	CALL	O.RSR,R0	;RESTORE USER STATE
	MOV	O.UST,-(SP)	;	AND STATUS
	MOV	O.UPC,-(SP)	;	AND PC
	RTT

.SBTTL	"S" PROCESSOR - SINGLE STEP PROCEED COMMAND

;SYNTAX--
;NS				EXECUTE N INSTRUCTIONS AND THEN STOP
;S				EXECUTE ONE INSTRUCTION

O.SNGL:	MOVB	#-1,O.S		;SET THE MODE FOR S.I. MOOD
	MOVB	#O.BKP+2,R0	;FAKE THE BREAK
	BR	O.PR01		;FAKE A PROCEED IN S.I. MOOD

.SBTTL	"P" PROCESSOR - PROCEED FROM BREAKPOINT COMMAND

;SYNTAX--
;NP				PROCEED THRU THIS BREAKPOINT N TIMES
;P				ASSUME N=1

O.PROC:	CLRB	O.S		;SET FAST MODE
	MOVB	O.P,R0		;GET NUMBER OF BREAK
	BMI	O.ERR1		;THERE WASN'T ONE SO FAR ?
O.PR01:	TST	R2
	BEQ	O.C990		;NO R4 IS DEFAULT TO 1
	MOV	R4,O.CT(R0)	;SET USER'S COUNT
O.C990:	CMPB	O.P,#O.BKP	;SEE IF A REAL ONE OR A FAKE
	BGT	O.TBIT		;BRANCH IF FAKE
	TSTB	O.S		;SEE IF SINGLE INSTRUCTION MODE
	BMI	O.TBIT		;IF SO EXIT NOW
	INCB	O.T		;SET T-BIT FLAG
	BIS	#O.TBT,O.UST	;SET T-BIT
	BR	O.GO2

.SBTTL	BREAKPOINT TRAP ENTRY ROUTINE

O.BREK:	MOV	(SP)+,O.UPC	;PRIORITY IS 7 UPON ENTRY
	MOV	(SP)+,O.UST	;SAVE STATUS AND PC
	CLR	O.GETP		;CLEAR INDIRECT POINTER
	MOVB	#O.BKP+3,O.P	;TELL ;P THAT WE CAN CONTINUE
	CALL	O.SVR,R0	;SAVE VARIOUS REGISTERS
	DOEMT	.TTRST		;ENSURE CONTROL/O IS CANCELED
	TSTB	O.T		;CHECK FOR T-BIT SET
	BNE	O.TBIT		;JUMP IF SET
	CALL	O.REM		;REMOVE BREAKPOINTS
	MOV	O.UPC,R5	;GET PC, IT POINTS TO THE TRT
	TSTB	O.S		;SEE IF IT WAS SINGLE INSTRUCTION FUN
	BMI	O.B4		;IF SO HANDLE THERE
	TST	-(R5)
	MOV	R5,O.UPC
	MOV	#O.BKP,R4	;GET A COUNTER
O.B1:	CMP	R5,O.ADR1(R4)	;COMPARE WITH LIST
	BEQ	O.B2		;JUMP IF FOUND
	DEC	R4
	DEC	R4
	BGE	O.B1		;RE-LOOP UNTIL FOUND
	CALL	O.CRLF
	CALL	O.TYPC,R5,<"BE>	;TYPE A BAD ENTRY
	CLR	O.GETP		;CLEAR INDIRECTOR ON BAD ENTRY
	MOV	R5,R0
	ADD	#2,O.UPC	;POP OVER THE ADJUSTMENT ABOVE
	BR	O.B3		; OR CONTINUE

O.B4:	MOVB	#O.BKP+2,R4	;SET BREAK POINT HIGH + 1
	MOV	R5,O.ADR1(R4)	;STORE NEXT PC VALUE FOR TYPE OUT
O.B2:	MOVB	R4,O.P		;ALLOW PROCEED
	DEC	O.CT(R4)
	BGT	O.C990		;JUMP IF REPEAT
	MOV	#1,O.CT(R4)	;RESET COUNT TO 1
	CALL	O.CRLF
	MOVB	R4,R0		;SET UP TO TYPE B PLUS N
	ASR	R0		;JUST AS A TOKEN GESTURE
	CALL	O.TYPA,R5,<"0B>	;TYPE IT
	CALL	O.TYPC,R5,<':>	;FOLLOWED BY COLON, AND THEN ADDRESS
	MOV	O.ADR1(R4),R0	;GET ADDRESS OF BREAK
	MOV	O.BKAC(R4),R4	;GET BREAKPOINT ACTION ROUTINE
	CMP	R4,#7		;WITHIN RANGE?
	BHI	O.B3		;NOPE, SO DO NOTHING
	CALL	MAPACT		;YEP, MAP INTO ACTION ROUTINE
	MOV	R4,O.GETP	;AND SET IT UP TO GO
O.B3:	CALL	O.RORB		; CHECK FORMAT
	JMP	O.DCD		;GO TO DECODER

.SBTTL	COMMAND PROCESSORS, SECTION THREE

.SBTTL	"L" PROCESSOR - LIST MEMORY ON THE SPECIFIED DEVICE

;SYNTAX--
; D;S;FL		WHERE	D IS DEVICE, NULL OR 0 = CONSOLE
;				S IS START ADDRESS, SETS $L IF THERE
;				F IS STOP ADDRESS, SETS $H IF THERE

O.LIST:	TST	R2		;SET UPPER AND LOWER LIMITS
	BEQ	O.LI02		;IF SPECIFIED TO DO SO
	MOV	R4,O.HI
O.LI02:	TST	R3		;DO THE LOW ONE
	BEQ	O.LI10
	MOV	R5,O.LOW
O.LI10:	CALL	SARSET		;SET UP THE LIMITS TO START
	TST	-(SP)		;MAKE A HOLE IN THE STACK
O.LI30:	CLR	(SP)		;NEW LINE UP
	CALL	SNAGIT		;ACCESS DEVICE FOR DATA
	CALL	SPRINT		;PRINT ADDRESS AND FIRST ITEM
O.LI35:	CALL	SNAGIT		;GET MORE DATA
	CALL	DPRINT		;JUST PRINT THE DATA
	INC	(SP)		;COUNT THE DATA
	CMP	#7,(SP)		;CHECK THE COUNT
	BNE	O.LI35		;JUST LIKE THEY TOLD YOU AT THE
	BR	O.LI30		;FAMOUS PROGRAMMERS SCHOOL

.SBTTL	"W" PROCESSOR - MASKED EQUAL WORD SEARCH

;SYNTAX--
;M;AW				SET $M TO M, SET $A TO A, DO SEARCH
;AW				SET $A TO A, DO SEARCH
;W				USE $L, $H, $M, $A TO SEARCH. PRINT HITS

O.WSCH:	CALL	SARGUS		;SET UP $A, $M AND R5
O.WS02:	CALL	SNAGIT		;R5 IS MEMORY INDEX, CHECK FOR IT
	BNE	O.WS02		;NOT EQUAL IS NOT THE OBJECTIVE
	CALL	SPRINT		;PRINT LOCATION AND VALUE
	BR	O.WS02		;MOVE ON

.SBTTL	"N" PROCESSOR - MASKED NOT EQUAL WORD SEARCH

;SYNTAX--
;N				COMMAND IS "N", FORMS AS ARE FOR "W"

O.NOTW:	CALL	SARGUS
O.NO02:	CALL	SNAGIT
	BEQ	O.NO02		;THE ONLY DIFFERENCE
	CALL	SPRINT
	BR	O.NO02

.SBTTL	"E" PROCESSOR - MASKED EFFECTIVE ADDRESS

;SYNTAX--
;E		COMMAND IS "E", FORMS ARE AS ABOVE IN "W" AND "N"

O.EFFA:	CALL	SARGUS		;SET IT ALL UP PLEASE
O.EF02:	CALL	SNAGIT		;GET THE DATA VIA R5
	BEQ	O.EF10		;SAME ABSOLUTE ADDRESS FOUND
	MOV	R5,R0		;DO THE PC REL
	CALL	SRCHEF		;GO SEE IF MASKED SAME
	BEQ	O.EF10		;SAME PC RELATIVE ADDRESS
	MOVB	R5,R0		;DISPLACEMENT INTO R1, SIGN EXTEND
	ASL	R0		;CARRY IS CLEAR
	CALL	SRCHEF		;CHECK IT
	BNE	O.EF02		;SAME BRANCH DISPLACE IN FALL THRU
O.EF10:	CALL	SPRINT
	BR	O.EF02

.SBTTL	"F" COMMAND - FILL MEMORY WORDS

;AF			SET ARG REGISTER, FILL WITH $A FROM $L TO $H

O.FILL:	CLR	R3		;NO MASK IS TO BE SET
	CALL	SARGUS		;SET UP ARG AND R5
O.FI02:	CALL	SNAGIT		;GET LOC IN R5
	MOV	SP,R2		;PRETEND DATA IS HERE
	MOV	O.ARG,R4	;THIS IS WHY
	MOVB	O.OBW,O.BW	;OPEN THE ITEM
	CALL	PUTCAD		;PUT THE DATA
	BR	O.FI02		;GO TILL BROKEN

.SBTTL	"A" COMMAND - DO AN ACTION

; SYNTAX--
;  nA		DO ACTION ROUTINE n

O.DOAC:	CALL	CHKACT		;CHECK ACTION # AND POINT TO IT
	MOV	R4,O.GETP	;SET THE INDIRECT INPUT POINTER
	BR	O.DCD9		; AND CONTINUE

.SBTTL	")" COMMAND - TYPE AN ACTION

; SYNTAX--
;  n)		TYPE ACTION ROUTINE n

O.RPAR:	CALL	CHKACT		;CHECK FOR LEGAL ACTION AND POINT TO IT
	CALL	O.CRLF		;RESTORE CARRIAGE
10$:	MOVB	(R4)+,R0	;GET THE CHARACTER TO TYPE
	BEQ	O.DCD9		;QUIT IF END OF ROUTINE
20$:	CALL	O.FTYP		;TYPE THE CHARACTER
	CMPB	R0,#15		;IS THIS A CARRIAGE RETURN?
	BNE	10$		;NO, GET THE NEXT CHARACTER
	MOVB	#12,R0		;YES, SO TYPE A LINE FEED ALSO
	BR	20$		; AND DO IT

.SBTTL	"(" COMMAND - ESTABLISH AN ACTION ROUTINE

; SYNTAX--
;   n(		ESTABLISH ACTION ROUTINE n

.ENABL	LSB

O.LPAR:	CALL	CHKACT		;CHECK FOR LEGAL ACTION AND POINT TO IT
	MOV	#63.,R3		;SET LIMITING COUNTER
	CLR	R5		;CLEAR PAREN LEVEL COUNTER
10$:	CALL	O.GET		;GET NEXT CHARACTER
	CMPB	R0,#')		;ENDING PAREN?
	BEQ	50$		;MIGHT BE
	CMPB	R0,#'(		;NESTED PAREN?
	BNE	20$		;NO
	INC	R5		;YES, COUNT IT
20$:	MOVB	R0,(R4)+	;STORE THE CHARACTER IN ACTION BUFFER
	CLRB	(R4)		;KEEPING THE STRING ASCIZ
	DEC	R3		;TOO MUCH?
	BGT	10$		;NOPE, CONTINUE
	CLRB	-63.(R4)	;YES, FORGET THE WHOLE LINE
O.ERR9:	JMP	O.ERR		;SAY ERROR

50$:	DEC	R5		;END OF ACTION?
	BPL	20$		;NOPE, STORE THE RPAR AWAY
O.DCD9:	JMP	O.DCD		;YES, DONE

.DSABL	LSB

.SBTTL	"D" COMMAND - DEFINE BREAKPOINT ACTION

; SYNTAX--
;    D		CLEAR ALL BKPT ACTIONS
;   nD		CLEAR BKPT ACTION n
; a;nD		SET ACTION a FOR BKPT n

O.SEBA:	ASL	R4		;PRE-DOUBLE ACTION NUMBER
	TST	R3		;REMOVES?
	BEQ	20$		; YES
	CMP	R5,#7		;NO, LEGAL ACTION NUMBER?
	BHI	O.ERR9		; NO, ERROR!!!
10$:	CALL	40$		;SET THE ACTION
	BCS	O.ERR9		;ILLEGAL
	BR	O.DCD9		;ELSE O.K.

20$:	MOV	#-1,R5		;SET TO DISABLE ACTIONS
	TST	R2		;ALL?
	BNE	10$		;NO, REMOVE ONLY ONE
	CLR	R4		;YES, ALL, START AT 0
30$:	CALL	40$		;DO A REMOVE
	BCC	30$		;MORE TO GO ....
	BR	O.DCD9		;ELSE EXIT

40$:	CMPB	#8.*2,R4	;LEGAL?
	BLO	50$		;NO, C=1
	MOV	R5,O.BKAC(R4)	;YES, SET IT
	TST	(R4)+		;AND ADVANCE (C=0)
50$:	RETURN

.SBTTL	"[" COMMAND - CONDITIONAL EXECUTION

; SYNTAX--
;    n[...]		DO ... ONLY IF n <> 0
;  1;n[...]		DO ... ONLY IF n = 0

O.COND:	NEG	R5		;SET C=1 IF DOING n=0
	BIT	R4,R4		;SET Z=1 IF n=0
	BCS	40$		;C=1, SO PROCEED ONLY IN V=0
	BNE	O.DCD9		;C=0, SO CONTINUE ONLY IF V<>0
10$:	CLR	R5		;SET THE LEVEL COUNTER
20$:	CALL	O.GET		;GET THE NEXT CHARACTER
	CMPB	R0,#'[		;NESTING?
	BNE	30$		;NO
	INC	R5		;YES, SO COUNT UP ONE
30$:	CMPB	R0,#']		;POSSIBLE END, OR UNNESTING?
	BNE	20$		;NO, EAT NEXT CHARACTER
	DEC	R5		;YES, REAL END?
	BPL	20$		; NOT YET, CONTINUE EATING
	BR	O.DCD9		; YES, BACK TO DECODER

40$:	BEQ	O.DCD9		;CONTINUE ONLY IF V=0
	BR	10$		;ELSE SKIP CONDITIONAL

.SBTTL	"=" COMMAND - PRINT VALUE OF EXPRESSION

; SYNTAX--
;  exp=			PRINT VALUE OF LEFT SIDE

EQUALS:	MOV	R4,R5		;SAVE VALUE IN SAFE SPOT
	MOV	O.PRNT,-(SP)	;SAVE CURRENT PRINT FORMAT
	CALL	20$		; AND PRINT IT AS OCTAL
	CMP	R5,#7		; IS IT A SIMPLE OCTAL DIGIT?
	BLOS	10$		; WE ARE ALL DONE IF SO
	INC	O.PRNT		;SET UNSIGNED DECIMAL
	CALL	20$		; AND PRINT IT
	TST	R5		; NEGATIVE?
	BPL	10$		;  NO, WE ARE ALL DONE
	NEG	O.PRNT		;SAY PRINT SIGNED DECIMAL
	CALL	20$		; AND PRINT IT
10$:	MOV	(SP)+,O.PRNT	;RESTORE THE PRINT OUT FORMAT
	BR	O.DCD9		; AND CONTINUE

20$:	MOV	R5,R0		;SET THE VALUE
	CALLR	O.CADW		;  AND GO PRINT IT

CHKACT:	CMP	R4,#7		;LEGAL?
	BHI	O.ERR9		;NOPE, ERROR
MAPACT:	ASL	R4		;*2
	ASL	R4		;*4
	ASL	R4		;*8.
	ASL	R4		;*16.
	ASL	R4		;*32.
	ASL	R4		;*64.
	ADD	#O.ACTN,R4	;POINT TO IT
	RETURN


.SBTTL	UTILITIES - SAVE AND RESTORE USER DATA.

;SAVE REGISTERS R0-R6, SET ODT'S STACK UP	JSR R0,O.SVR

O.SVR:	MOV	(SP)+,O.UR0	;PICK R0 FROM STACK AND SAVE
	MOV	SP,O.USP	;SAVE USER STACK ADDRESS
	MOV	#O.USP,SP	;SET TO INTERNAL STACK
	MOV	R5,-(SP)	;SAVE
	MOV	R4,-(SP)	; REGISTERS
	MOV	R3,-(SP)	;5
	MOV	R2,-(SP)	; THRU
	MOV	R1,-(SP)	;     1
	CMP	-(SP),-(SP)	;SET UP ODT'S STACK AND COVER R0 SAVE
	RTS	R0

;RESTORE REGISTERS R0-R6			JSR R0,O.RSR

O.RSR:	CMP	(SP)+,(SP)+	;POP THE EXTRA CELLS
	MOV	(SP)+,R1	;RESTORE
	MOV	(SP)+,R2	; REGISTERS
	MOV	(SP)+,R3	;  1
	MOV	(SP)+,R4	;  THRU
	MOV	(SP)+,R5	;    5
	MOV	O.USP,SP	;RESTORE USER STACK
	MOV	O.UR0,-(SP)	;PUT R0 ON USER STACK
	RTS	R0

;RESTORE BREAKPOINTS 7-0			JSR PC,O.RSB

O.RSB:	MOV	#O.BKP,R4	;RESTORE ALL BREAKPOINTS
O.RS1:	MOV	@O.ADR1(R4),O.UIN(R4)	;SAVE CONTENTS
	MOV	O.TRTC,@O.ADR1(R4)	;REPLACE WITH TRAP
	DEC	R4
	DEC	R4
	BGE	O.RS1		;RE-LOOP UNTIL DONE
	RTS	PC		;  THEN QUIT

;REMOVE BREAKPOINTS 0-7, OPPOSITE ORDER!!	JSR PC,O.REM

O.REM:	TSTB	O.S		;IGNOGE IT IF S.I MOOD
	BNE	O.R2		;SEE ABOVE
	CLR	R4		;REMOVE ALL START WITH 0
O.R1:	MOV	O.UIN(R4),@O.ADR1(R4)	;INSTR BACK TO PROGRAM
	TST	(R4)+		;BUMP BUMP
	CMP	#O.BKP,R4
	BHIS	O.R1		;LOOP
O.R2:	RTS	PC		;THEN SPLIT

.SBTTL	UTILITIES - COMMAND SUPPORT ROUTINES

;TEST FOR VALID RELOCATION REGISTER IN R4

O.RTST:	TST	R4
	BMI	O.RTS9		;LOW IS NO GOOD
	CMP	#O.RLR,R4
	BLOS	O.RTS9		;HIGH IS NO GOOD HERE
	ASL	R4
O.RTS8:	CLC
	RTS	PC

O.RTS9:	SEC
	RTS	PC

;RESET RELOCATION BASE AND UNIT REGISTER

O.RUCL:	CALL	O.RTST		;TEST REGISTER TYPE
	BCS	O.RU99		;BAD REGISTER, JUST GO
	MOV	#-1,O.RELT(R4)	;R4 IS INTEGER X2
	ASR	R4		;R4 BACK TO ST INTEGER
O.RU99:	RTS	PC

;CLEAR ALL RELOC AND UNIT REGISTERS

O.RUAL:	CLR	R4		;START WITH 0
O.RUA1:	CALL	O.RUCL		;DO THIS ONE ONLY AT A TIME
	BCS	O.RU99		;SAME AS RTS PC
	INC	R4		;NEXT ONE AT A TIME
	BR	O.RUA1

;RESET BREAKPOINT VIA VALUE IN R4 AND R0

SETBRK:	CMP	#O.BKP,R4	;SEE IF LEGAL REFERENCE
	BLO	O.RTS9		;NO GO SIGNAL ON SPLIT
	MOV	R0,O.ADR1(R4)	;SET THE ADDRESS
	MOV	(R0),O.UIN(R4)	;SET THE INSTRUCTION/ OR TRAP
	CLR	O.CT(R4)	;ZERO PROCEED COUNT
	TST	(R4)+		;A TOUCH
	BR	O.RTS8		;GOOD SPLIT

;SNAG MEMORY LOCATION AND CHECK FOR =	JSR PC,SNAGIT

;NEEDS--
;O.CAD		POINTS TO MEMORY WORD (APPROXIMATELY THAT IS)
;R0,R5		CONTAINS REAL WORD UPON EXIT TO "SRCHEK"

;FALLS THRU TO "SRCHEK" FOR THE NITTY GRITTY

SNA000:	JMP	O.DCD		;GO RESET STACK AND DO NEXT TASK

SNAGIT:	MOVB	O.OBW,R0	;SET THE INCREMENT
	ADD	R0,O.CAD	;INCREMENT AND NOW
	CMP	O.CAD,O.HI	;SEE IF MORE TO DO
	BHI	SNA000		;IF NOT DO NOT
	CALL	GETCAD		;ACCESS METHOD
	MOV	R0,R5		;MAKE A COPY FOR LATER

;MASKED SEARCH CHECKER				JSR PC,SRCHEK

;NEEDS--
;R0		HAS OBJECT UNDER TEST
;SEES IF R0 UNDER MASK IS SAME AS ARGUMENT UNDER MASK

;RETURNS--
;CODES SET FOR	BEQ GOOD FOR SAME, R0=0
;		BNE GOOD FOR NOT SAME, R0<>0

SRCHEK:	MOV	R0,R2		;MAKA COPY
	MOV	O.ARG,R1	;DE ARGUMENT TO COMPARE AGAINST
	BIC	R1,R0		; (NOT A) AND O = X
	BIC	R2,R1		; (NOT O) AND A = Y
	BIS	R0,R1		; X IOR Y = Z
	MOV	O.MSK,R0
	COM	R0
	BIC	R0,R1		;(NOT (NOT M)) AND Z = R1
	RTS	PC		;BACK TO NEXT ONE

;FINISH EFFECTIVE ADDRESS COMPUTE AND CHECK IT, R0 HAS THE ADDRESS

SRCHEF:	ADD	#2,R0		;TWO CAUSE THE PC GETS TWO TOO
	ADD	O.CAD,R0	;RELOCATION PLEASE
	BR	SRCHEK		;DO THE LOGICAL COMPARE

;SET UP SEARCH ARGUMENTS			JSR PC,SARGUS
;JUST SET UP LIMIT				JSR PC,SARSET

;SETS UP--
;O.ARG IF R4 IS VALID
;O.MSK IF R5 IS VALID
;O.CAD,O.OBW	USED TO GET THE ADDRESS TO START OUT WITH

SARGUS:	TST	R2
	BEQ	SAR002
	MOV	R4,O.ARG	;SET THE SEARCH ARGUMENT
SAR002:	TST	R3
	BEQ	SARSET
	MOV	R5,O.MSK
SARSET:	MOV	O.LOW,R5	;SET THE START OF START
	MOVB	O.OBW,R0	;NO SUCHA THING AS A "SUBB"
	SUB	R0,R5
	MOV	R5,O.CAD
	RTS	PC

;SEARCH HIT PRINT			JSR PC,SPRINT

;O.CAD POINTS TO THE LOC TO BE PRINTED
;R5 CONTAINS THE CONTENTS OF THE LOCATION TO BE PRINTED

SPRINT:	CALL	O.CRLF
	MOV	O.CAD,R0	;THE LOCATION
	CALL	O.RORA		;THE MODE
	MOVB	O.FM,R0		;PICK UP OLD CURENT MODE
	ASR	R0		;HALVES
	MOVB	COMTAB(R0),R0	;AH HA
	CALL	O.FTYP		;TYPE THE MODE DESIGNATOR

;DATA PRINT ROUTINE			JSR PC,DPRINT

;PRINTS DATA IN R5 IN CURRENT MODE

DPRINT:	MOVB	O.FM,R1		;SET THE MODE
	MOV	R5,R0		;THIS IS THE POOR DATA
	MOV	R5,-(SP)	;SAVE THE DATA
	CALL	@TYFORM(R1)	;DO THAT __ TO THE POOR DATA
	MOV	(SP)+,R5	;RESTORE THE DATA
	RTS	PC		;RESTORE THE PC

.SBTTL	EXPRESSION COMPUTATION

;EXPRESSION COMPUTATION ROUTINE		JSR PC,EXPCOM

;NEEDS--
;O.OP			THE OPERATION (-2=*, 0=+, *=2)
;O.EXP			THE LEFT SIDE
;R4			THE RIGHT SIDE

;SETS UP--
;O.OP			BACK TO 0 FOR ADD
;O.EXP,R4		ALL SO FAR

EXPCOM:	MOVB	O.OP,R2		;GET THE OP CODE
	JMP	@100$(R2)	; AND DO THE OPERATION

10$:	NEG	R4		;MINUS, OP=2
20$:	ADD	O.EXP,R4	;PLUS, OP=0
30$:	MOV	R4,O.EXP	;COMMON OUT, SET EXP TO WHATEVER
	CLRB	O.OP		;INDICATE FINAL OPERAION IS +
	MOV	#1,R2		;SET R2 TO INDICATE R4 IS REAL
	RETURN

40$:	MOV	R4,-(SP)	;MULTIPLE BY 50, OP=-2, SAVE OLD R4
	CLR	R4		;CLEAR THE ACCUMULATOR
	MOV	#50,R2		;DO A NON-OPTIMIZED MULTIPLY
50$:	ADD	O.EXP,R4
	DEC	R2
	BNE	50$
	ADD	(SP)+,R4	;RECOVER THE R4 VALUE
	BR	30$		; MERGE

60$:	MOV	R4,R2		;COPY THE SHIFT COUNT
	MOV	O.EXP,R4	;GET THE VALUE TO SHIFT
	TST	R2		;RIGHT OR LEFT
	BMI	80$		;RIGHT, GO DO IT
70$:	DEC	R2		;COUNT DOWN THE SHIFT
	BMI	30$		;DONE
	ASL	R4		;SHIFT THE VALUE
	BR	70$		; AND TRY FOR MORE

80$:	ASR	R4		;SHIFT RIGHT
	INC	R2		;BUMP THE SHIFT COUNT
	BMI	80$		;NOT DONE
	BR	30$		;DONE

90$:	COM	O.EXP		;LOGICAL AND. COMPLEMENT THE OLD
	BIC	O.EXP,R4	;DO THE AND
	BR	30$		; MERGE

	.WORD	90$		;-6 AMPERSAND
	.WORD	60$		;-4 EXCLAIMATION
	.WORD	40$		;-2 ASTERISK
100$:	.WORD	20$		;+0 ADD
	.WORD	10$		;+2 SUBTRACT

.SBTTL	SPECIAL INPUT PROCESSORS

.ENABL	LSB

.SBTTL	"%", RADIX 50 INPUT

INPRAD:	CLR	R4		;CLEAR R4 FOR RAD50 INPUT
	CALL	10$		;CALL THE BELOW 3 TIMES
	MOV	PC,-(SP)	;CALL IT AGAIN
10$:	CALL	O.GET		;GET A RAD50 CHARACTER
	MOV	R0,R2		;COPY IT
	SUB	#'9+1,R0	;REDUCE IT NUMERIC
	ADD	#'9+1-'0,R0	;IS IT A DIGIT?
	BCC	30$		;NO
	ADD	#30.,R0		;YES, MAKE IT RAD50
20$:	ASL	R4
	ASL	R4
	ASL	R4
	ADD	R4,R0		;ADD TO ADDER
	ASL	R4
	ASL	R4
	ADD	R0,R4		;DONE
	CLC			;SET FLAG FOR NEEDING CHARACTER
	RETURN

30$:	SUB	#'Z+1-'0,R0	;CHECK FOR ALPHABETIC
	ADD	#'Z+1-'A,R0	;IS IT A LETTER
	BCC	40$		;NO
	INC	R0		;YES, RANGE IT
	BR	20$		;AND SHIFT AND ADD

40$:	MOV	#70$,R0		;CHECK SPECIAL CHARACTER TABLE
50$:	CMPB	R2,(R0)+	; IS THIS IT?
	BNE	60$		;NO
	MOVB	(R0),R0		;YES, GET VALUE
	BR	20$		; AND USE IT

60$:	INC	R0		;SKIP VALUE
	TSTB	(R0)		;DONE?
	BNE	50$		;NO
	JMP	O.ERR		;YES, NOT A VALID CHARACTER, ERROR!

70$:	.BYTE	'$,^R  $	;DOLLAR
	.BYTE	'.,^R  .	;PERIOD
	.BYTE	'+,^R   	;SPACE - USE + FOR SPACE
	.BYTE	'?,35		;UNDEFINED - ? ON RSTS
	.BYTE	0		;END OF TABLE
	.EVEN

.SBTTL	"'", INPUT SINGLE ASCII CHARACTER

INPBYT:	CALL	O.GET		;GET A BYTE
	CLR	R4		;CLEAR FOR BISB
	BR	80$		;DO IT AND RETURN

.SBTTL	""", INPUT 2 ASCII CHARACTERS
INPASC:	CALL	INPBYT		;GET ONE BYTE
	CALL	O.GET		;GET ANOTHER
	SWAB	R0		;SET IT
80$:	BIS	R0,R4		;SET IT
	RETURN

.DSABL	LSB

;BUILD AN OCTAL NUMBER		JSR PC,GETNUM

;NEEDS AND RETURNS--
;R0	NON-OCTAL TERMINATING CHARACTER
;R2	OCTAL CHARACTER COUNT
;R4	OCTAL NUMBER THAT I GOT, YOU GET

INPOCT:				;HERE IS THE SPECIAL FORM OCTAL
GETNUM:	TST	(PC)+		;C=0 FOR RADIX 8.
INPDEC:	SEC			;C=1 FOR RADIX 10.
	MOV	#4,-(SP)	;PUT A 4 ON THE STACK
	ADC	(SP)		;MAKE IT A FIVE IF DECIMAL
	ASL	(SP)		;STACK NOW HAS 8. OR 10., CLEVER, EH?
	CLR	R2		;NEW R2 AND R4
	CLR	R4
	CALL	O.GET		;CHECK FOR LEADING MINUS SIGN
	CMPB	R0,#'-		;GOT ONE?
	BNE	20$		;NO, PROCESS THIS CHARACTER
	BIS	#100000,(SP)	;YES, SET FLAG (SP)
10$:	CALL	O.GET		;GET 1 CHARACTER
20$:	SUB	#'0,R0		;REDUCE THE NUMBER
	CMPB	R0,(SP)		;IN RANGE OF RADIX?
	BHIS	40$		;NO, EXIT NOW
	ASL	R4		;SHIFT FOR * 8.
	CMPB	(SP),#10.	;DECIMAL?
	BNE	30$		;NO
	ADD	R4,R0		;YES, ADD IN 2*OLD
30$:	ASL	R4
	ASL	R4		;MPY BY 10 TO MAKE ROOM
	ADD	R0,R4		;PLANT LO PLACE
	INC	R2		;ACCOUNT FOR NEW ONE
	BR	10$		;NEXT ONE OR OTHER

40$:	ADD	#'0,R0		;FIX R0
	TST	(SP)+		;DUMP THE RADIX
	BPL	50$		;NO LEADING -
	NEG	R4		;NEGATE IT
50$:	SEC			;C=1 INDICATING WE GOT A CHARACTER
	RETURN

.SBTTL	LOOKUP - SCAN LIST OF CHARACTERS

;SCAN A LIST OF CHARACTERS	JSR R5,LOOKUP

;CALL--
;		R0	HAS THE CHARACTER
;	JSR	R5,LOOKUP	;THAT IS IT
;	 +	LIST TO USE, 00 BYTE IS END OF LIST

;RETURNS AT CALL + 2 WITH--
;R0	STILL HAS CHARACTER
;R1	HAS INDEX X2 OF FOUND CHARACTER IF C=0
;C=1	CHARACTER WAS NOT FOUND

LOOKUP:	MOV	(R5),R1		;GET LIST START
LOOK10:	CMPB	R0,(R1)		;IS THIS THE ONE
	BNE	LOOK20		;RIGHT IT WASN'T
	SUB	(R5)+,R1	;COMPUTE INDEX AND RETURN
	ASL	R1		;DO THIS FOR EVERBODY, C=0
	BR	LOOK99

LOOK20:	TSTB	(R1)+		;CHECK FOR END OF LIST
	BNE	LOOK10		;IF NOT LOOK AT NEXT ITEM
	TST	(R5)+		;END, AVOID ILLEGAL INSTRUCTION
	SEC			;SECURITY EXCHANGE COMMISION
LOOK99:	RTS	R5		;SECURITY ELSEWHERE

;GET CONTENTS OF ADDRESS IN THE MODE		JSR PC,GETCAD

;NEEDS--
;R0		THE MODE 1=BYTE, 2=WORD
;O.CAD		THE ADDRESS
;O.DEVI		THE DEVICE CODE

;RETURNS--
;R0		HAS THE DATA YOU ASKED FOR

GETCAD:	MOV	O.CAD,R3	;GET CORE ADDRESS
	MOV	SP,O.OPN	;SET LOCATION OPEN
	ASR	R0		;PUSH BW FLAG INTO CARRY BIT
	BCC	GETC95		;2 WON'T FIT SO IS WORD
	MOVB	(R3),R0		;ACCESS BYTE
	BR	GETC99

GETC95:	MOV	(R3),R0		;ACCESS WORD
GETC99:	RTS	PC		;STACK ACCESS

;PUT R4 INTO ADDRESS IN THE MODE		JSR PC,PUTCAD

;NEEDS--
;R2		CONTENT FLAG, 0 FOR NONE, ELSE R4 IS GOLD
;R4		THE DATA
;O.BW		THE MODE FLAG, IF 0 THEN NO LOCATION OPEN

PUTCAD:	TST	R2		;CHECK FOR TYPED VALUE
	BEQ	PUTC12		;NO DATA NO DODO
	MOV	O.BW,R0		;PICK UP MODE AN CC'S
	TST	O.OPN		;IS A LOCATION OPEN AT PRESENT?
	BEQ	PUTC12		;NOT OPEN NOT STORED
	MOV	O.CAD,R3	;GET THE CORE ADDRESS
	BIT	#177776,R0	;CHECK MODE
	BNE	PUTC10		;WORD MODE
	MOVB	R4,(R3)		;BYTE MODE
	BR	PUTC12		;BRANCH MODE

PUTC10:	MOV	R4,(R3)		;WORD MODE
PUTC12:	RTS	PC

.SBTTL	UTILITIES - TELETYPE I/O ROUTINES

;TYPE BY ADDING TO R0

O.TYPA:	ADD	(R5)+,R0	;ADD BIAS
	BR	O.TY9Z		;DO IT

;TYPE A CONSTANT IN LINE

O.TYPC:	MOV	(R5)+,R0	;GET CHARACTERS
O.TY9Z:	CALL	O.TYPE		;TYPE IT
	RETURN	R5

;TYPE A DIGIT

O.TYPD:	BIC	#^C<7>,R0	;ISOLATE DIGIT
O.TYPN:	ADD	#'0,R0		;MAKE IT ASCII
	BR	O.FTYP		;TYPE IT

;TYPE CARRIAGE RETURN LINE FEED			JSR PC,O.CRLF

O.CRLF:	MOV	(PC)+,R0
	.BYTE	015,012

;TYPE TWO CHARS IN R0 PLEASE			JSR PC,O.TYPE

O.TYPE:	CALL	O.FTYP		;DO ONE
	SWAB	R0

;TYPE ONLY ONE CHARACTER IN R0			JSR PC,O.FTYP

O.FTYP:	MOVB	R0,O.BUF	;PUT CHAR IN BUFFER
	MOV	R0,-(SP)	;BREATHING ROOM
	CALL	O.IO		;CALL SETUP
	INC	XRB+XRBC	;ONE BYTE TRANSFER
	DOEMT	.WRITE		;OUT IT GOES
	CALL	@(SP)+		;RESTORE XRB
	MOV	(SP)+,R0	;GET IT BACK
	RTS	PC

O.IO:	MOV	#XRBSIZ,R0	;GET SIZE OF XRB IN BYTES
10$:	MOVB	XRB-1(R0),O.XRB-1(R0);SAVE XRB THEN
	CLRB	XRB-1(R0)	; CLEAR IT
	SOB	R0,10$
	INC	XRB+XRLEN	;SET BUFFER LENGTH TO 1
	MOV	#O.BUF,XRB+XRLOC;SET BUFFER POINTER TO CHARACTER BUFFER
	CALL	@(SP)+		;CO-ROUTINE FOR THE REAL I/O
	MOV	#XRBSIZ,R0	;GET XRB SIZE IN BYTES
20$:	MOVB	O.XRB-1(R0),XRB-1(R0);RESTORE THE XRB
	SOB	R0,20$
	RTS	PC		;DONE

.ENABL	LSB

2$:	INC	O.GETP		;INCREMENT THE POINTER
	MOVB	(R0),R0		;GET THE NEXT INPUT BYTE
	BNE	30$		;PROCESS IT
	CLR	O.GETP		;IF IT IS A NULL CLEAR INDIRECT POINTER
	.BR	O.GET		; AND GET STUFF FROM CONSOLE

O.GET:	MOV	O.GETP,R0	;GET THE INDIRECT COMMAND POINTER
	BNE	2$		;THERE IS ONE, DO IT
	CALL	O.GET1		;GET A CHARACTER
	CMPB	#15,R0		;IS IT <CR>?
	BNE	10$		;NO
	CALL	O.GET1		;YES, EAT THE <LF>!
	MOV	#15,R0		;RESTORE <CR>
10$:	CMPB	#33,R0		;IS IT ALT MODE?
	BNE	1$		;NO
	MOVB	#'$,R0		;YES, USE $
1$:	CMPB	#' ,R0		;CVT BLANK
	BNE	20$
	MOVB	#'+,R0		;INTO +
20$:	RTS	PC

30$:	CALL	O.FTYP		;TYPE THE CHARACTER WE PULLED FROM THE ACTION
	CMPB	R0,#15		;WAS IT A CARRET?
	BNE	40$		;NO, GIVE TO THE CALLER
	MOV	R0,-(SP)	;YES, SAVE IT
	MOVB	#12,R0		; AND GET SET TO PRINT A LINE FEED
	CALL	O.FTYP		;  PRINT IT
	MOVB	(SP)+,R0	;RESTORE CARRET
40$:	RETURN			;  AND RETURN TO CALLER

.DSABL	LSB

O.GET1:	CALL	O.IO		;CALL SERVICE ROUTINE
	DOEMT	.TTDDT		;ANY ONE WILL DO
	DOEMT	.READ		;GET IT
	CALL	@(SP)+		;RESTORE
	MOVB	O.BUF,R0	;HERE IT IS
	BIC	#-177-1,R0	;TRIM OFF ANY PARITY BIT
	BEQ	O.GET1		;AND IGNORE NULLS
	CMP	R0,#'A+40	;LOWER CASE POSSIBLY?
	BLO	10$		;NOPE
	CMP	R0,#'Z+40	;MIGHT BE...
	BHI	10$		; BUT IT ISN'T
	BIC	#40,R0		;CONVERT L.C. INTO U.C.
10$:	RTS	PC

.SBTTL	UTILITIES - PRETTY PRINTERS

;PRINT ADDRESS- RELOC, SYMBOLIC, OR ABSL	JSR PC.O.RORA

;R0	ADDRESS TO BE PRINTED
;O.FORM	CORE ADDRESS FORMAT (0-RELOC  1-ABSOL)

;REGISTER	'$R ' OR '$DR '
;CORE		'D,XXXXXX ' OR 'XXXXXX '

O.RORB:	CMP	R0,#VECTBL	;SPECIAL "P.???" PRINTING??
	BLO	O.RORA		;NOPE
	CMP	R0,#ODT+SIZODT	;MIGHT BE...
	BHIS	O.RORA		; BUT IT ISN'T
	MOV	6(R0),R1	;YES, FIND REAL VECTOR ADDRESS
	CALL	O.TYPC,R5,<"P.>	;ANNOUNCE
	MOV	VECTBL-P.FIS(R1),R0
	CALL	O.TYPE
	MOV	VECTB2-P.FIS(R1),R0
O.RO10:	BR	O.TYPE

O.RORA:	MOV	R0,-(SP)	;CALLING VALUE ONA TOPPA SATCK
	CMP	#INTBEG,(SP)
	BHI	O.RO50		;BELOW FIRST NON-INDEXED
	CMP	#INTEND+2,(SP)
	BLO	O.RO50		;ABOVE LAST NON-INDEXED
	MOV	#'$,R0		;ANNOUNCE INTENTIONS
	CALL	O.FTYP
	CMP	#INTINX,(SP)
	BLOS	O.RO20		;GO TO DO INDEXED
	MOV	(SP)+,R0	;NON-INDEXED REGISTER ----- "$R "
	SUB	#INTBEG,R0	;CLEANED UP STACK, GET OFFSET
	ASR	R0		;BYTE THAT WORD, WORD THAT BYTE
	MOVB	NIXMAP(R0),R0	;MAGIC CHARACTER FROM TABLE
O.RO15:	BIS	(PC)+,R0
	.BYTE	000,' 		;CHARACTER PLUSSA BLANK
	BR	O.RO10		;NAME PLUS BLANK AND SPLIT

O.RO20:	CLR	R1		;SEE WHICH SET OF TABLES WE GOT
O.RO22:	CMP	INXTBL+2(R1),(SP)	;LOOK ON AHEAD TO FIND BEHIND
	BHI	O.RO24		;R1 POINTS TO BASE OF SET
	TST	(R1)+		;THINK ABOUT THOSE DUMMY ENTRIES DUMMY
	BR	O.RO22

O.RO24:	MOV	(SP)+,R0	;INDEXED REGISTER ---- "$DR "
	SUB	INXTBL(R1),R0	;GET ADDRESS AND COMPUTE OFFSET IN WORDS
	ASR	R0		;AND FINALLY IN PLAIN TALK
	ADD	#'0,R0		;CONVERT TO ASCII
	CALL	O.FTYP		;TYPE OUT REGISTER NUMBER
	ASR	R1
	MOVB	INXREG(R1),R0	;PICK UP THE REAL CHARACTER
	BR	O.RO15		;GO PRINT REST OF IT

O.RO50:	TST	O.FORM		;CORE ADDRESS SEE WHAT USER WANTS
	BNE	O.RO90		;TYPE AS ABSOLUTE.
	MOV	(SP),R4		;RELOCATE ---- "R,XXXXXX "
	CALL	O.LOCA		;WE ALWAYS PICK, ODT KNOWS BEST
	BMI	O.RO90		;BUT NOT ALL THE TIME
	MOV	R1,(SP)		;SET THE DISPLACEMENT
O.RO80:	CALL	O.TYPA,R5,<"0,>	;PRINT REGISTER AND COMMA
O.RO90:	MOV	(SP)+,R0	;PRINT R0 AS A WORD
	.CALLR	O.CADW

;TYPE R0 AS BYTE OR WORD, TWO ENTRIES
;	FOR A WORD				JSR PC,O.CADW
;	FOR A BITE				JSR PC,O.CADB

.ENABL	LSB

O.CADW:	MOV	R0,O.QUAN	;SET THE FAMOUS QUANTITY VALUE
	MOV	#6,R3		;# OF DIGITS
	MOV	#1-3,R4		;# OF BITS FIRST-3
	BR	10$		;DO THE COMMON THING

O.CADB:	CLR	O.QUAN		;SET FOR ALL OF QUAN A BYTE
	MOVB	R0,O.QUAN	;SET THE QUANTITY THING AGAIN
	MOV	#3,R3		;THERE ARE THREE DIGITS
	MOV	#2-3,R4		;AND ONLY TWO BITS
	SWAB	R0		;SWITCH ENDS
10$:	TST	O.PRNT		;WHAT TYPE OF PRINTING?
	BEQ	80$		;OCTAL
	INC	R4		;DECIMAL, BYTE MODE?? (2-3=1)
	BNE	20$		;NO, WORD MODE
	CLRB	R0		;YES, BYTE MODE, CORRECT
	SWAB	R0		; THE VALUE
20$:	MOV	R0,R3		;SAVE THE VALUE
	TST	O.PRNT		;SIGNED?
	BGT	40$		;NO, UNSIGNED
	TST	R3		;IS THE VALUE NEGATIVE?
	BMI	30$		;IT IS NEGATIVE
	TST	R4		;POSITIVE AS A WORD, BUT WHAT MODE?
	BNE	40$		;WORD MODE, O.K.
	MOVB	R0,R3		;BYTE MODE, SIGN EXTEND VALUE
	BPL	40$		;STILL POSITIVE
30$:	MOV	#'-,R0		;SET AND
	CALL	O.FTYP		; PRINT THE MINUS SIGN
	NEG	R3		;  THEN CORRECT THE VALUE
40$:	MOV	#120$,R4	;GET THE TABLE POINTER
	MOV	#-1,-(SP)	;START WITH LEADING SPACES
50$:	CLR	R0		;INIT THE ANSWER
60$:	INC	R0		;COUNT TIMES
	SUB	(R4),R3		; THROUGH
	BHIS	60$		;  THIS LOOP
	ADD	(R4)+,R3	;CORRECT MAIN VALUE
	ADD	(SP),R0		; AND ANSWER
	BLE	70$		;A LEADING SPACE
	MOV	#20-1!100000,(SP) ; REAL DIGIT, START KEEPING DIGITS
	ADD	#20,R0		;INCLUDING THIS ONE
70$:	ADD	#40,R0		;FORM CHARACTER
	CALL	O.FTYP		;  AND TYPE IT
	TST	(R4)		;MORE?
	BNE	50$		;YES, LOOP
	MOV	R3,R0		;GET THE LAST PLACE (UNITS)
	CALL	O.TYPN		; AND TYPE AS A NUMBER
	MOV	#'.,R0		;SET TRAILING .
	CALL	O.FTYP		; AND TYPE IT AS CUE
	BR	110$		;  GO EXIT

80$:	MOV	R0,-(SP)	;SAVE R0
90$:	ADD	#3,R4		;COMPUTE THE NUMBER OF BITS TO DO
	CLR	R0
100$:	ROL	(SP)		;GET A BIT
	ROL	R0		;STORE IT AWAY
	DEC	R4		;DECREMENT COUNTER
	BGT	100$		;LOOP IF MORE BITS NEEDED
	CALL	O.TYPD		;TYPE IT AS A DIGIT
	DEC	R3		;SEE IF MORE DIGITS TO DO
	BGT	90$		;LOOP IF SO
110$:	TST	(SP)+		;GET RID OF JUNK
O.TYPS:	MOVB	#' ,R0		;SET UP FOR TRAILING SPACE
	JMP	O.FTYP		;TYPE IT

120$:	.WORD	10000.,1000.,100.,10.,0

.DSABL	LSB

;TYPE CONTENTS OF WORD IN FORMAT	JSR PC,@TYFORM(R1)

;R0		WORD OR BYTE TO BE TYPED, RHJ
;R1		FORMAT CODE,	-0 BYTE OCTAL
;				-2 WORD OCTAL
;				-4 BYTE ANSII
;				-6 WORD ANSII
;				-10 RADIX 50 / MODULO 40

TYFORM:	+	O.CADB	;BYTE OCTAL
	+	O.CADW	;WORD OCTAL
	+	TYF040	;BYTE ANSII
	+	TYF060	;WORD ANSII
	+	TYF100	;RADIX 50

;MODULO 40, RADIX 50

TYF100:	MOV	#O.ALFA,R1	;SET OUTPUT DATA ADDRESS
	CALL	UNPA00		;R0 TO RADIX 50
	MOV	#O.ALFA,R1
	MOVB	(R1)+,R0	;GET A CHARACTER, #1
	CALL	O.FTYP
	MOV	(R1),R0		;GET CHARS #2 AND #3

;WORD ANSII

TYF060:	CALL	O.FTYP		;TYPE BYTE IN R0
	SWAB	R0		;SWAP EM AND TYPE IT

;BYTE ANSII

TYF040:	CALL	O.FTYP		;TYPE OF BYTE IN R0
	BR	O.TYPS		;TYPE SPACE

;SELECT RELOCATION REGISTER			JSR PC,O.LOC

;O.CAD		ADDRESS TO USE IN SELECTION

;RETURNS--
;R0				REGISTER NUMBER FOUND, -1 IF NONE FOUND
;R1				DISTANCE, RELOCATION FACTOR

;SUBROUTINE TO LOCATE RELOCATION REGISTER NEAREST BUT STILL 
;BELOW THE ADDRESS IN O.CAD.  RETURNS WITH THE REGISTER 
;NUMBER IN R0, AND WITH THE DISTANCE BETWEEN THE REGISTER 
;AND (O.CAD) IN R1
;IF NO GOOD RELOC. REG. FOUND, R0 WILL = -1

O.LOC:	MOV	O.CAD,R4	;SET UP CAD DATA
O.LOCA:	CLR	R0
	MOV	#-1,-(SP)	;INITIALIZE RELOC. REG. INDEX
	MOV	(SP),R1		;INITIALIZE DISTANCE TO A HIGH VALUE
O.LOC4:	CMP	R0,#O.RLR	;ARE WE DONE COMPARING?
	BHI	O.LOC1		;BRANCH IF DONE
	CMP	O.RELT(R0),R4	;IS CURR. RELOC. BIAS > (R4)?
	BHI	O.LOC2		;IF SO, BRANCH -- DON'T SUBTRACT, GET NEXT
	MOV	R4,R2		;OTHERWISE TAKE THE DIFFERENCE
	SUB	O.RELT(R0),R2	;OF CURR. RELOC. REG. AND O.CAD
	CMP	R1,R2		;IS THE RESULT THE SMALLEST SO FAR?
	BHI	O.LOC3		;BRANCH IF YES (UNSIGNED CONDITIONAL)
O.LOC2:	TST	(R0)+		;OTHERWISE, BUMP R0 FOR NEXT RELOC. REG.
	BR	O.LOC4		;LOOP BACK FOR NEXT COMPARISON

O.LOC1:	MOV	(SP)+,R0	;PUT REG.# IN R0
	RTS	PC		;JOB OVER, RETURN

O.LOC3:	MOV	R2,R1		;REMEMBER SMALLEST DIFFERENCE IN O.XXY
	ASR	R0		;AND ASSOCIATED REGISTER NUMBER
	MOV	R0,(SP)		; IN (SP)
	ASL	R0		;RESTORE R0 TO ORIGINAL VALUE
	BR	O.LOC2		;GO FO NEXT COMPARISON.

.SBTTL	RADIX 50 UNPACK

;	MOD40 UNPACK - ENTERED VIA JSR PC,UNPA00
;
;	INPUT:	R0= MOD40 NUMBER (1 WORD)
;		R1=ADR OF ASCII STRING (3 BYTES)
;
;	OUTPUT:	R1 POINTS ONE PAST LAST GENERATED CHARACTER
;
;	IF N IS THE MOD40 NUMBER, THEN
;		N=C1*50 ^ 2+C2*50+C3
;	THUS, N/50^2 IS C1 AND THE REMAINDER IS C2*50+C3
;	THE REMAINDER IS DIVIDED BY 50 TO GET C2 ETC.
;
UNPA00:	MOV	R0,R3		;MOVE MOD40 NUMBER TO HERE
	MOV	#100$,R0	;GET DIVIDE TABLE
10$:	CLR	R2		;CLEAR THE HIGH ORDER AND
	DIV	(R0)+,R2	; DIVIDE
	BEQ	20$		;ANSWER=0, SO <SPACE>
	CMP	R2,#33		;ELSE CHECK FOR "$"
	BEQ	40$		;IT IS "$"
	BHI	30$		;IT IS "." OR "0-9"
	ADD	#40,R2		;IT IS "A-Z"
20$:	ADD	#16,R2		;
30$:	ADD	#11,R2		;
40$:	ADD	#11,R2		;FORM THE ASCII CODE
	CMP	R2,#'/		;IS IT "/"?
	BNE	50$		;NO
	MOV	#'?,R2		;YES, "/" IS REALLY "?"
50$:	MOVB	R2,(R1)+	;STORE THE ANSWER
	TST	(R0)		;MORE?
	BNE	10$		;YES, CONTINUE
	RTS	PC		;NO, EXIT

100$:	.WORD	40.*40.,40.,1.,0;TABLE OF DIVISORS

; SPECIAL EMT PREFIX HANDLER

DOEMT:	MOV	(PC)+,-(SP)	;SET THE FUNNY RETURN INSTRUCTION
		JSR	SP,@(SP)+
	MOV	(PC)+,-(SP)	;TARGET FOR: MOV #<SV-FIRQB>,@#FIRQB
		.WORD	FIRQB
	MOV	@(PC)+,-(SP)	;SOURCE FOR: MOV #<SV-FIRQB>,@#FIRQB
		.WORD	FIRQB
	MOV	(PC)+,-(SP)	;INSTRU FOR: MOV #<SV-FIRQB>,@#FIRQB
		MOV	(PC)+,@(PC)+
	MOV	(R5)+,-(SP)	;SET THE EMT ITSELF
	TST	@#P.FLAG	;SPECIAL PREFIX REQUIRED?
	BPL	10$		;NO
	MOV	#EMT,-(SP)	;YES, SET A BARE BONES EMT AND
	MOVB	@#P.FLAG,(SP)	; PUT IN THE PREFIX CODE
10$:	CALL	(SP)		;NOW DO THE EMT
	RTS	R5		;AND EXIT

.NLIST	BEX

VECTBL:	.ASCII	/FICRSTNERUBABPIOEMTRFPCC2C/
VECTB2:	.ASCII	/S ASRTW N D T T T APP   C /

.LIST	BEX

O.FIS:	BPT
	CALL	REROUT,R0
	 .WORD	P.FIS

O.CRAS:	BPT
	CALL	REROUT,R0
	 .WORD	P.CRAS

O.STR:	BPT
	CALL	REROUT,R0
	 .WORD	P.STRT

O.NEW:	BPT
	CALL	REROUT,R0
	 .WORD	P.NEW

O.RUN:	BPT
	CALL	REROUT,R0
	 .WORD	P.RUN

O.BAD:	CMP	(SP),#O.BRK1	;ERROR TRYING TO OWN ODT?
	BEQ	1$		;YES, SO FORGET IT ALOTGETHER
	BPT
	CALL	REROUT,R0
	 .WORD	P.BAD		;NO, SO CALL IT A REAL ERROR

1$:	CMP	(SP)+,(SP)+	;DUMP PC & PS FROM BAD TYPE TRAP
	MOV	(SP)+,@#FIRQB	;RESTORE ORIGINAL IO STATUS
O.BRK0:	RTI			;AND JUST EXIT

O.BRK:	DOEMT	.TTRST		;REFRESH MEMORY (MIGHT NOT WORK!)
	TSTB	O.JOB		;ODT OWNED?
	BEQ	1$		;NO, SO OWN IT
	CMPB	O.JOB,@#FIRQB+FQJOB;YES, BY WHO?
	BNE	O.BRK0		;OTHERS, SO FORGET IT
1$:	MOV	@#FIRQB,-(SP)	;SAVE CURRENT IO STATUS
	MOVB	@#FIRQB+FQJOB,O.JOB;AND TRY TO OWN ODT
O.BRK1:				;TRAP WITH THIS ADDR IF R-O
	MOV	(SP)+,@#FIRQB	;RESTORE IO STATUS IF SUCCESSFUL
	JMP	O.BREK		;AND ENTER ODT FOR REAL

O.IOT:	BPT
	CALL	REROUT,R0
	 .WORD	P.IOT

O.EMT:	CMP	(SP),#ODT	;EMT REROUTED FROM ODT?
	BLO	1$		;NO
	CMP	(SP),#ODT+SIZODT;MIGHT BE...
	BLO	O.BRK0		;YES, IT IS, SKIP IT
1$:	BPT
	CALL	REROUT,R0
	 .WORD	P.EMT

O.TRAP:	BPT
	CALL	REROUT,R0
	 .WORD	P.TRAP

O.FPP:	BPT
	CALL	REROUT,R0
	 .WORD	P.FPP

O.CC:	CMP	SP,#ODT		;INSIDE ODT?
	BLO	1$		;NO
	CMP	SP,#ODT+SIZODT	;MIGHT BE...
	BHIS	1$		; BUT IT ISN'T
	JMP	O.DCDX		;YES, STOP AND RE-START

1$:	BPT
	CALL	REROUT,R0
	 .WORD	P.CC

O.2CC:	BPT
	CALL	REROUT,R0
	 .WORD	P.2CC

REROUT:	MOV	(R0),R0		;GET THE REAL VECTOR ADDRESS
	SUB	#-P.OFF-2,R0	;FIX AS IF NO INTERVENING ODT CODE
	CMP	#ODTVE,#ODT+SIZODT;DOES ODT INTERVENE?
	BNE	1$		;NO
	ADD	#-P.OFF-2,R0	;YES, RE-CORRECT THE
	SUB	10$,R0		; POINTER
1$:	MOV	(R0),R0		;GET THE ADDRESS
	RTS	R0		;AND EXIT TO RTS

10$:	.WORD	SIZODT-P.OFF-2

.SBTTL	DEFINE ODT VECTOR AREA

.MACRO	VECTOR	AT,TO
.	=	ODTVE+AT-P.OFF
	 .WORD	TO
.ENDM	VECTOR

.CSECT	.99999			;PUT VECTORS IN HIGHEST POSSIBLE .CSECT
ODTVE:				;CALLING IT "ODTVE"

	VECTOR	P.FLAG,O.FLAG+PF.NER+PF.RW+PF.1US+PF.REM
	VECTOR	P.DEXT,O.DEXT
	VECTOR	P.ISIZ,O.MSIZ
	VECTOR	P.MSIZ,O.MSIZ
	VECTOR	P.FIS,O.FIS
	VECTOR	P.CRAS,O.CRAS
	VECTOR	P.STRT,O.STR
	VECTOR	P.NEW,O.NEW
	VECTOR	P.RUN,O.RUN
	VECTOR	P.BAD,O.BAD
	VECTOR	P.BPT,O.BRK
	VECTOR	P.IOT,O.IOT
	VECTOR	P.EMT,O.EMT
	VECTOR	P.TRAP,O.TRAP
	VECTOR	P.FPP,O.FPP
	VECTOR	P.CC,O.CC
	VECTOR	P.2CC,O.2CC
	VECTOR	P.SIZE,O.SIZE

GLOBAL	<O.FLAG,O.DEXT,O.MSIZ,O.SIZE>

.CSECT	.99ODT		;BACK TO ODT'S UNIQUE .CSECT

SIZODT	=	.-ODT	;SIZE OF ODT CODE AND DATA IN BYTES

.END

