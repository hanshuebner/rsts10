TITLE	DBG,<BASIC+ DEBUGGER>,08,13-MAY-86,AWR

;                   Copyright 1974,1990 by Digital Equipment Corporation
;                                  All rights reserved.
;
;          This software is furnished under a license and may be used and copied
;          only  in  accordance  with  the  terms  of  such license and with the
;          inclusion of the above copyright notice.  This software or any copies
;          shall not be provided to any other person.   No title to or ownership
;          of the software is hereby transferred.
;
;          The information in this software is subject to change without notice.
;
;          DIGITAL  assumes  no  responsibility  for the  use, functionality, or
;          reliability of its  software  on equipment  which  is not supplied by
;          DIGITAL.

;+
;		THE BASIC-PLUS DEBUGGER/EXTENDED
;
;IF THIS SET OF CSECTS IS LINKED WITH BASIC-PLUS, THE FOLLOWING FEATURES
;ARE ENABLED:
;	TRACE		ONLY AS A KEYBOARD COMMAND
;	UNTRACE		ONLY AS A KEYBOARD COMMAND
;	BREAK [NNN]	KEYBOARD COMMAND, NNN IS 1 OF 10 LINE NUMBERS
;	UNBREAK [NNN]	KEYBOARD COMMAND
;-

.SBTTL DEFINE SOME PATCH FLAGS

	DEFORG	PATCHD		;DEBUG PATCH FLAGS

$$0410::.BLKW0	2		;ALLOW SPACE FOR 32 PATCHES.  NOTE THAT
				; THE PRESENCE OF THE GLOBAL "$$0410" IS
				; SUFFICIENT TO DETECT THE PRESENCE OF
				; THE DEBUGGER.

.SBTTL	DEBUG -- NEW LINE PROCESSING

	DEFORG	DEBUG		;OVERLAYS 'DEBUG' IN RC

;+
;DEBUG -- NEW LINE PROCESSING
;
;THIS ROUTINE IS CALLED BY THE 'NEXT STATEMENT' ROUTINE IN RC.
;-

.ENABL	LSB

DEBUG:	BIT	#JFBREK!JFTRAC,JOBF ;ANY CALL FOR US?
	BEQ	80$		;NO
	MOV	SCTH,R2		;GET THE HEADER
	CMP	TAGBIN(R2),DEBLIN ;SAME AS OLD LINE NUMBER?
	BEQ	80$		;YES, SO IGNORE IT
	CMPB	TAGTYP(R2),#6	;IS IT MULTI-LINE DEF?
	BEQ	80$		;YES, CAN'T STOP NOW
	CMPB	TAGTYP(R2),#10	;IS IT A SINGLE LINE DEF?
	BEQ	80$		;YES; NO STOPPING HERE

10$:	MOV	TAGBIN(R2),DEBLIN ;REMEMBER CURRENT LINE FOR NEXT TIME
	BEQ	80$		;DON'T BREAK ON IMMEDIATE MODE
	BIT	#JFBREK,JOBF	;ARE WE BREAKING
	BEQ	50$		;NO - GO TRACE
20$:	BIT	#140000,BREKFL	;BREAK?
	BMI	30$		;YES; BREAK ALWAYS
	MOV	DEBLIN,-(R1)	;R1=>LINE TO FIND
	JSR	PC,CHKBRK	;SEE IF IT IS THERE
	BIT	(R1),(R1)+	;POP R1 W/OUT TOUCHING CARRY
	BCS	40$		;NO MATCH, NO BREAK
30$:	MOV	#BRKMSG,-(R1)	;FIND MESSAGE TO PRINT
	JSR	PC,60$		;PRINT "BREAK AT LINE NNN"
	JMP	BRKENT		;GO FINISH LIKE IT WAS 'STOP'

40$:	BIT	#JFTRAC,JOBF	;NEED WE GO ON?
	BEQ	80$		;NO
50$:	MOV	#ATLINE,-(R1)	;FIND MESSAGE TO PRINT
	.BR	60$		;PRINT "AT LINE NNN"

60$:	CALLX	IFPOS0		;PRINT IF POS(0%); SELECT CHANNEL 0
	MOV	(R1)+,R2	;GET MESSAGE POINTER
	JSR	PC,PRINTL	;PRINT MESSAGE
	MOV	DEBLIN,-(R1)	;GET CURRENT LINE NUMBER
	JSR	PC,PRINTI	;PRINT IT
	JSR	PC,CRLF		;END IT
80$:	RTS	PC		;ALL DONE

.GLOBL	BRKENT,IFPOS0,PRINTL,PRINTI,CRLF

.DSABL	LSB

.SBTTL	CHKBRK -- SEE IF LINE NUMBER ON R1 STACK IS IN BREAK TABLE

;+
;CHKBRK -- FIND AN ENTRY IN THE BREAK TABLE
;
;IF FOUND, R3 => ENTRY, C=0
;    ELSE  C=1
;-
.ENABL	LSB

CHKBRK:	MOV	#BRKEND,R3	;FIND END OF BREAK TABLE
10$:	CMP	-(R3),(R1)	;IS THIS THE ONE?
	BEQ	30$		;YES; BREAK HERE
20$:	CMP	R3,#BRKTBL+2	;END OF LIST?
	BHIS	10$		;NO; TRY AGAIN
;	SEC			;C=1 -- NOT FOUND IN BREAK TABLE
30$:	RTS	PC		;DONE

.DSABL	LSB

.SBTTL	EDEB -- EXECUTE DEBUGGING COMMANDS

	DEFORG	EDEB		;OVERLAYS 'EDEB' IN ED

;+
;EDEB -- EXECUTE DEBUGGING COMMANDS
;
;THIS ROUTINE IS CALLED FROM ED, AND REPLACES "?WHAT?" ERRORS.
;-
.ENABL	LSB

EDEB:

DOTRAC:	BR	60$		;TRACE
	.ASSUME	DOTRAC	EQ EDEB	;DOTRAC MUST BE AT RELATIVE ZERO
DOUNTR:	BR	70$		;UNTRACE
	.ASSUME	DOUNTR	EQ EDEB+2 ;ORDER IS IMPORTANT
DOBREK:	BR	80$		;BREAK
	.ASSUME	DOBREK	EQ EDEB+4
DOUNBR:	.BR	10$		;UNBREAK
	.ASSUME	DOUNBR	EQ EDEB+6


10$:	JSR	PC,GETARG	;GET ANY ARGUMENT
	MOV	(R1)+,R2	;ARE THERE ANY?
	BEQ	40$		;NO
20$:	JSR	PC,CHKBRK	;FIND THE BREAKPOINT ENTRY
	BCS	30$		;NOT THERE
	CLR	(R3)		;ELSE MAKE IT NOT THERE
30$:	TST	(R1)+		;SKIP ARGUMENT
	SOB	R2,20$		;TRY ANOTHER ONE
	BR	50$		;END IT
40$:	BIC	#JFBREK,JOBF	;UNBREAK THE WORLD
	.BR	50$
50$:	JMP	EDCTLH		;ALL DONE

60$:	BIS	#JFTRAC,JOBF	;TRACE
	BR	50$

70$:	BIC	#JFTRAC,JOBF	;UNTRACE
	BR	50$

80$:	JSR	PC,RSTBRK	;PUT THE WORLD IN ORDER
	MOV	(R1)+,R2	;GET NUMBER OF ARGUMENTS
	BNE	90$		;IT'S HARDER WITH AN ARGUMENT
	BIS	#100000,BREKFL	;BREAK ON ALL LINE NUMBERS
	BR	50$		;ALL DONE

90$:	BIS	#40000,BREKFL	;BREAK ON LINE NUMBERS
100$:	JSR	PC,CHKBRK	;DO WE HAVE THIS LINE NUMBER?
	BCC	110$		;YES; TRY FOR ANOTHER
	CLR	-(R1)		;FIND A ZERO ENTRY
	JSR	PC,CHKBRK	;IN THE BREAK TABLE
	BIT	(R1),(R1)+	;POP R1 STACK W/OUT TOUCHING CARRY
	BCS	120$		;NO FREE (=ZERO) ENTRIES
	MOV	(R1)+,(R3)	;REMEMBER WHERE TO BREAK
110$:	SOB	R2,100$		;TRY FOR ANOTHER ONE
	BR	50$		;GO BACK

120$:	ASL	R2		;MAKE ARG COUNT A WORD COUNT
	ADD	R2,R1		;RESTORE R1
	CALLX	IFPOS0		;PRINT IF POS(0%); SELECT CHANNEL 0
	MOV	#NOROOM,R2	;FIND "%NO ROOM"
	JSR	PC,PRINTL	;PRINT IT AND RETURN FROM THERE
	BR	50$		;DONE

.DSABL	LSB

.GLOBL	DOCONT,EDCTLH

.SBTTL	RSTBRK -- RESET THE BREAKPOINT TABLE AND FLAGS

.ENABL	LSB

RSTBRK:	BIT	#JFBREK,JOBF	;IS THE WORLD IN ORDER?
	BNE	GETARG		;YES
	MOV	#BRKEND,R3	;FIND THE END OF THE DEBUGGING TABLES
.ASSUME	BREKFL	EQ DEBLIN+2
.ASSUME	BRKTBL	GT BREKFL+2
10$:	CLR	-(R3)		;CLEAR THE WORD
	CMP	R3,#DEBLIN	;DONE YET?
	BHI	10$		;DO MORE
	INC	JOBF		;BIT 0 OF JOBF MUST BE 0 HERE
.ASSUME	JFBREK	EQ 1
GETARG:	CLR	-(SP)		;PREPARE THE ARGUMENT COUNTER
20$:	JSR	PC,TLGNEP	;GET A TOKEN,SKIP NEXT BRANCH IF NOT EOL
	BR	30$		;DONE AT END OF LINE
	CMPB	TOKE(R0),#LINUM	;IS IT A LINE NUMBER?
	BEQ	25$		;YES
	CMP	TOKA(R0),#COMMA	;SIMPLY A COMMA? (IF NOT, DIE AT TLGLN1)
	BEQ	20$		;YES, SO GET ANOTHER TOKEN
25$:	JSR	PC,TLGLN1	;LINE NUMBER TO R1 STACK, OR DIE
	INC	(SP)		;INCREMENT ARG COUNTER
	BR	20$		;LOOK FOR ANOTHER
30$:	MOV	(SP)+,-(R1)	;PUSH THE ARGUMENT COUNT ON R1 STACK
	RTS	PC		;ALL DONE

.GLOBL	TLGNEP,TLGLN1

.DSABL	LSB

.SBTTL	DEBUGGING TEXT

	ORG	DEBTXT

.ENABL	LC

BRKMSG:	.ASCII	"Break "		;RUNS INTO THE NEXT MESSAGE
ATLINE:	.ASCIZ	"at line"

NOROOM:	.ASCIZ	"%No room"

.DSABL	LC
	UNORG
.END
