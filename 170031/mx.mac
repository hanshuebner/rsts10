TITLE	MX,<MX - MAT STATEMENTS>,08,13-MAY-86,TPH/JDM

;                   Copyright 1974,1990 by Digital Equipment Corporation
;                                  All rights reserved.
;
;          This software is furnished under a license and may be used and copied
;          only  in  accordance  with  the  terms  of  such license and with the
;          inclusion of the above copyright notice.  This software or any copies
;          shall not be provided to any other person.   No title to or ownership
;          of the software is hereby transferred.
;
;          The information in this software is subject to change without notice.
;
;          DIGITAL  assumes  no  responsibility  for the  use, functionality, or
;          reliability of its  software  on equipment  which  is not supplied by
;          DIGITAL.

	.if eq 0	;Originally .if df HELLO	WJS 90.1.31
	ORG	XT,TKMAT-DOTABV
	.WORD	$$MAT	;MAT(RIX)
	.endc	;eq 0					WJS 90.1.31

	ORG	PT,0
	..	PPMRD,MATRD	;MATRIX PUSH-POPS
	..	PPMPRN,MATPRN
	..	PPMPRT,MATPRT
	..	PPMINP,MATINP
	..	PPMZR,MATZRO
	..	PPMC1,MATC1
	..	PPMID,MATID
	..	PPMTRN,MATTRN
	..	PPMINV,MATINV
	..	PPSMPF,MATSMF
	..	PPSMPI,MATSMI
	..	PPMCPY,MATCPY
	..	PPMMUL,MATMUL
	..	PPMADD,MATADD
	..	PPMSUB,MATSUB
	..	PPMPRC,MATPRC
	..	PPMPUS,MATPUS
	..	PPMPOP,MATPOP
	..	PPZSMA,ZSMADD
	..	PPMPR,MATPR
	..	PPMAIN,MATIN
	..	PPMRD0,MATRD0
	..	PPRDIM,ROWDIM
	..	PPCDIM,COLDIM
	..	PPCMPI,CMPIPP
	..	PPFFLT,FFLTPP
	..	PPCALS,CALLPP
	..	PPCALI,CALIPP
	..	PPCORU,CORUPP
	..	PPRTS,RTSPP
	..	PPREOR,REORPP
	..	PPBEGN,BEGINP
	..	PPFFUF,FFUF
	..	PPTST,TSTFL
	..	PPEMC,EMCODE

	DEFORG	MX

	.if eq 0	;Originally .if df HELLO	WJS 90.1.31
	.GLOBL	SAINT					;(TR)
	.endc	;eq 0					WJS 90.1.31
	.GLOBL	FLT,FIX,ADDF,Z00000			;(MA)
	.GLOBL	SINF1
	.GLOBL	PRINTS,PRINTF,CRLF,NXTZON		;(PN)
	.GLOBL	INDO3,INDR3,PUSHI1,INDEGH,READS		;(RC)
	.GLOBL	READF,INPUTS,INPUTF
	.GLOBL	EXPDIF,FLTLEN,FLTLE2,FLTLE4

	.if eq 0	;Originally .if df HELLO	WJS 90.1.31
;THE MATRIX OPERATIONS IN THE TABLE BELOW
;ALL HAVE SIMILAR PUSH POP OPERATOR FORMATS
;THE FIRST DIMENSION IS PUSHED ON THE R1
;STACK, THEN THE SECOND (ZERO IS PUSHED
;WHENEVER A GIVEN DIMENSION IS NOT SPECIFIED), AND
;THE PUSHPOP OPERATOR IS FOLLOWED BY A
;TWO BYTE MATRIX HEADER ADDRESS
;MATRIX OPERATION		RTS PUSH-POP OP
;MAT READ			PPMRD
;MAT PRINT WITH TABS		PPMPRT
;MAT PRINT NO TABS		PPMPRN
;MAT INPUT			PPMIP
;MAT C=ZER			PPMZR
;MAT C=CON			PPMC1
;MAT C=IDN			PPMID
DOMADM:	RNTJ	LPAR,DOMRA1	;IF NO DIMENSIONS SPECIFIED
	RCI			;FIRST DIMENSION
	NTJ	COMMA,DOMRA2	;MUST BE VECTOR
	RCI			;2ND DIMENSION
	B	DOMRA3
DOMRA2:	CB	PPFIX0		;USE ZERO FOR UNSPECIFIED DIM
DOMRA3:	T	RPAR		;MUST BE ")"
	R
	QUITS
DOMRA1:	CB	PPFIX0		;DUMMY IN 1ST DIM
	CB	PPFIX0		;LEAVE
	CB	PPNOT		;-1 AROUND AS NO INDEX FLAG
	QUITS

SELEC3:	RNTJ	POUND,DOMSE1	;READ AND GET POUND
	RCI			;IF POUND THEN GET INTEGER
	T	COMMA		;FORCA A COMMA
	SARF			;??
	R			;READ NEXT TOKEN
	QUITS
DOMSE1:	CB	PPFIX0
	QUITS			;EXIT SUBROUTINE

;ROUTINE TO HANDLE ONE MEMBER OF POSSIBLE LIST OF ARRAYS
;FOR MAT READ,INPUT,& PRINT
DOMRAY:	X			;X FOR MATRIX;MUST BE INDEXED VARIABLE
	PT			;SAVE IT
	CALLS	DOMADM
	C2OF1			;COMPILE THE SAVED OP CODE
	CW			;COMPILE THE ARRAY HEADER IN-LINE
	QUITS

;MAT VERB-MESSIEST OF ALL
$SAINT	MAT			;INITIALLY ENTER SYNTAX ANALYZER...
	RNTJ	TREAD,DOMAT3
	PBS	PPMRD		;MATRIX READ OP
	B	DOMAT2
DOMAT3:	NTJ	INPUT,DOMAT1
	CALLS	SELEC3
	CB	PPENDI		;EMPTY BUFFER
	CB	PPSSI
	PBS	PPMINP		;MATRIX INPUT OP
	B	DOM99
DOMAT2:	SARF			;FOR LA
	R
DOM99:	CALLS	DOMRAY		;COMPILE ONE MEMBER OF LIST
	TJ	COMMA,DOMAT2
	TJ	SEMICO,DOMAT2
DOMA52:	TST1AI
	QUIT
DOMAD1:	B	DOMADM
DOMAT1:	NTJ	PRINT,DOMAT5

;MAT PRINT ROUTINE--------------------------------------------------
;COMPILE PPMPRN POP IF NO TABS BETWEEN ELEMENTS,
;AND PPMPRT IF TABS ARE DESIRED
	CALLS	SELEC3
	CB	PPSSON
	X			;GET ARRAY HEADER
	PT			;SAVE IT
	CALLS	DOMADM		;COMPILE DIMENSIONS
	EJ	DOMB03		;NEEDS A CRLF (USE PPMPRT)
	TJ	COMMA,DOMB05	;TABS, NO CRLF IF END
	T	SEMICO		;ONLY OTHER LEGAL TOKEN
	CB	PPMPRN		;NO TABS,NO CRLF IF END
	B	DOMB04
DOMB05:	CB	PPMPRT		;PUT OUT TABS TYPE POP
DOMB04:	RE			;MUST SEE END OF STATEMENT
	B	DOMB06
DOMB03:	CB	PPMPRC		;COLUMN VECTOR
DOMB06:	CW			;HEADER
	CB	PPCRLF
	QUIT
DOMAT5:	XIJ	DOMA51		;MUST BE A MAT. VARIABLE
	XF
DOMA51:	PTYPE
	PT			;SAVEIT
	RT	EQUALS		;DEMAND "="
	RNTJ	ZER,DOMAT6
	PBS	PPMZR		;ZERO MATRIX

DOMA10:	CALLS	DOMAD1		;COMPILE DIMENSIONS
	CBS			;COMPILE UP BYTE FROM STACK
DOMA53:	CW			;COMPILE ARRAY NAME FROM STACK
	B	DOMA52
DOMAT6:	NTJ	CON,DOMAT9
	PBS	PPMC1		;SET MATRIX TO ALL 1'S
	B	DOMA10
DOMAT9:	NTJ	IDN,DOMA11
	PBS	PPMID		;SET MATRIX TO IDENTITY
	B	DOMA10
DOMA11:	NTJ	TRNLP,DOMA14
	CB	PPMTRN		;MATRIX TRANSPOSE
DOMA16:	RX			;READ OPERAND
	MATCHT			;MUST BE SAME TYPE AS FIRST MAT
	CT			;COMPILE IT
	RT	RPAR
	B	DOMA24

DOMA14:	NTJ	INVLP,DOMA15
	CB	PPMINV		;MATRIX INVERSE
	B	DOMA16
DOMA15:	NTJ	LPAR,DOMA17	;SCALAR MULTIPLY CASE
	R			;NEXT TOKEN
	CN			;COMPILE EITHER TYPE OF NUMBER
	COPR	DOMOPT		;AND APPROPRIATE POP DEPEND ON FLOAT OR INTEGER
	T	RPAR
	SARF			;FOR LA
	RT	STAR
	RX			;READ LAST OPERAND
	MATCHT			;MUST BE SAME TYPE AS FIRST MAT
	CT			;COMPILE LAST OPERO
DOMA24:	R
	B	DOMA53
DOMOPT:	.BYTE	PPSMPF,PPSMPI	;SCALAR MULTIPLY PUSH/POPS

DOMA17:	X			;MAT A=B CASE
	MATCHT			;MUST BE SAME TYPE AS FIRST MAT
	PT			;PUSH THE FIRST OPERAND
	RNEJ	DOMA19		;COPU CASE
	CB	PPMCPY		;MATRIX COPY
	CW			;PPMCPY[A][C]
	B	DOMA53
DOMA19:	NTJ	STAR,DOMA20
	CB	PPMMUL		;MATRIX MULTIPLY
DOMA22:	RX
	CT			;FIRST OPERAND
	CW
	MATCHT			;MUST BE SAME TYPE AS FIRST MAT
	B	DOMA24		;PPMMUL[A][B][C]
DOMA20:	NTJ	PLUS,DOMA21
	CB	PPMADD
	B	DOMA22
DOMA21:	T	BMINS
	CB	PPMSUB
	B	DOMA22
	.EVEN
	.endc	;eq 0					WJS 90.1.31

;STORES THE TOP WORD OF THE R1 STACK LESS EXPDIF ON THE SP STACK
;USED TO SET A MINIMUM  EXPONENT FOR ZSMADD, ETC.  JSR PC

DIFEXP:	MOV	(R1),R2		;SAVE EXPONENT IN R2
	ROL	R2		;DUMP SIGN
	MOV	R2,R0		;INTO R0 WITH IT
	SUB	#EXPDIF,R0	;GET MIN ALLOWABLE NONZERO EXPONENT
	IF	R0,LOS,R2,DIFEX1  ;BR IF RESULT SMALLER
	CLR	R0		;OTHWS, MAKE IT ZERO
DIFEX1:	JSR	R0,@(SP)+	;SAVE R0 ON STACK

;AN ADD PUSHPOP WHICH RETURNS ZERO IF THE RESULT IS VERY SMALL.

ZSMADD:	JSR	PC,DIFEXP	;SAVE MIN ALLOWABLE EXPONENT ON SP STACK
	JSR	PC,ADDF		;ADD TWO TOP FLOATERS TOGETHER
ZSMAD0:	MOV	(R1),R0		;GET M.S. WORD OF RESULT
	ROL	R0		;DUMP ITS SIGN
	IF	(SP)+,LOS,R0,BGINP1  ;EXIT IF RESULT BIG ENOUGH
	JMP	SINF1		;SUBSTITUTE A FLOATING 0

;FOR A PUSHPOP BYTE ARGUMENT INDIRECTLY POINTING TO AN
;ARRAY HEADER, GETS THE ABSOLUTE ADDRESS OF 
;THE ARRAY HEADER INTO R2.

COMDIM:	MOV	SPDA,R2		;GET THE BIAS
	MOVB	(R5)+,R0	;RELATIVE INDIRECT ADDRESS
	ADD	R2,R0		;ABSOLUTE 
	ADD	(R0),R2		;ABSOLUTE HEADER ADDRESS
	RTS	PC

;GETS THE ROW DIMENSION OF MATRIX INDIRECTLY
;REFERENCED THROUGH BYTE ARGUMENT

ROWDIM:	JSR	PC,COMDIM	;DO THE ABOVE
	MOV	DIM1(R2),-(R1)	;OTHWS PUSH DIM1
	RTS	PC

;GETS THE COLUMN DIMENSION OF MATRIX
;INDIRECTLY REFERENCED THROUGH BYTE ARG

COLDIM:	JSR	PC,COMDIM	;R2<--HEADER ADDRESS
	MOV	DIM2(R2),-(R1)	;PUSH DIM2
BGINP1:	RTS	PC

;SUBSTITUTES AND INTEGER ONE FOR THE TOP
;R1 STACK INTEGER UNLESS THAT INTEGER IS A ZERO

BEGINP:	IFZERO	EQ,(R1)+,BGINP3	;EXIT IF TOP OF STACK 0
	JMP	PUSHI1		;OTHERWISE, SUBSTITUTE 1

BGINP3:	CLR	-(R1)		;LEAVE 0 AT TOP OF R1 STACK
	RTS	PC

;PUSHES A MATRIX ENTRY ONTO THE R1 STACK (FLOATED).
;1ST BYTE ARG INDIRECTLY POINTS TO MATRIX HEADER, 2ND
;AND 3RD BYTES POINT DIRECTLY AT INDICES.

MATPUS:	JSR	PC,COMATP	;SETUP VIA INDX90
	JMASK0	EQ,(R0),FIXARY,MATP1,B  ;BR IF FLOATING
	MOV	#FLT,-(SP)	;EXIT THROUGH FLT
MATP1:	JMP	INDO3		;PUSH MATRIX ITEM

;POPS A MATRIX ENTRY FROM THE R1 STACK (FIXED,
;IF NECESSARY).  ARGS AS FOR MATPUS.

MATPOP:	JSR	PC,COMATP	;SETUP VIA INDX90
	JMASK0	EQ,(R0),FIXARY,MATPP1,B; BR IF FLOATING
	MOV	R3,-(SP)	;OTHWS, SAVE R3 FOR INDR3
	JSR	PC,FIX		;FIX ITEM
	MOV	(SP)+,R3	;RESTORE R3 FOR INDR3
MATPP1:	JMP	INDR3		;POP OFF

;ENTERED WITH R5 POINTING TO THE FIRST OF 3
;BYTE ADDRESSES - 1ST INDIRECT TO A
;MATRIX HEADER, THE OTHER 2 DIRECT TO INDICES.
;SETS UP A CALL INTO INDX90. INTERCHANGES
;R5 WITH 4(SP) BEFORE AND AFEER THE INDX90
;CALL. THIS ENABLES MAIN LINE BOOKKEEPING ON
;THE IPC IN CASE OF CORE ALLOCATION.

COMATP:	MOV	SPDA,R2		;BIAS
	MOVB	(R5)+,R0	;RELATIVE INDIRECT HEADER ADDRS
	ADD	R2,R0		;ABSOLUTE
	MOV	(R0),R0		;RELATIVE DIRECT HEADER ADRESS
	MOVB	(R5)+,R3	;RELATIVE INDEX ADDRESS
	ADD	R2,R3		;ABSOLUTE
	MOV	(R3),-(R1)	;PUSH INDEX
	MOVB	(R5)+,R3	;AND AGAIN
	ADD	R2,R3
	MOV	(R3),-(R1)
	MOV	(SP)+,R3	;SAVE TOP OF STACK
	JSR	PC,SWPIPC	;INTERCHANGE IPC'S
	MOV	R3,-(SP)	;RESTORE TOP OF STACK
	JSR	PC,INDEGH	;INTO INDX90
	JSR	PC,@(SP)+	;RETURN TO CALLING ROUTINE FOR AWHILE
	BR	MATRD2		;RE-INTERCHANGE IPC'S AND EXIT

SWPIPC:	MOV	R5,-(SP)	;INTERCHANGE IPC'S
	MOV	3*2(SP),R5
	MOV	(SP)+,2*2(SP)
	RTS	PC

;PUSHPOP SUBROUTINE & COROUTINE ROUTINES
;SUBROUTINE CALL.  R1EXT _R5_ ADDRESS
CALLPP:	MOVB	(R5)+,-(R1)	;SUBROUTINE JUMP ADDRESS
	MOVB	(R5)+,-(R1)	;ONTO R1 STACK
	ADD	R5,(R1)		;DERELATIVIZE SUBROUTINE ADDRESS
CALL0:	MOV	SPDA,R2		;GET THE BIAS
	MOV	R5,R1EXT(R2)	;SAVE RETURN ADDRESS
	MOV	(R1)+,R5	;SET SUBROUTINE ADDRESS
	RTS	PC

;COROUTINE CALL.  ALSO SUBROUTINE EXIT.  R1EXT <=> R5
CORUPP:	MOV	SPDA,R2		;GET THE BIAS
	MOV	R1EXT(R2),-(R1) ;SAVE DESTINATION ADDRESS
	BR	CALL0

;SUBROUTINE CALL THEOUGH R1.  R1EXT_R5_(R1)
CALIPP:	MOV	(R1),-(R1)	;SAVE DESTINATION ADDRESS
	BR	CALL0

;HONEST SUBROUTINE EXIT.  R5_R1EXT_(R1)+
RTSPP:	MOV	SPDA,R2		;GET BIAS
	MOV	R1EXT(R2),R5	;RETURN ADDRESS INTO R5
	MOV	(R1)+,R1EXT(R2) ;POP TO DUMMY TOP
	RTS	PC

;A PUSHPOP WHICH "ORS" THE TOP TWO R1 WORDS TOGETHER
;BUT DOES NOT REMOVE THEM.

REORPP:	TST	(R1)		;LOOK AT PSEUDO-INDEX
	BPL	BGINP3		;BR IF HONEST INDEX
	MOV	(R1)+,(R1)	;MOVE DISHONEST INDEX DOWN FOR POPPING IT
REORI:	RTS	PC

;A PUSHPOP WHICH TESTS THE TOP TWO R1 STACK
;ITEMS AND COMPLIANTS IF THEY ARE NOT EQUAL.
;THROW TOP ITEMS AWAY.

CMPIPP:	IF	(R1)+,EQ,(R1),REORI	;EXIT IF TOP ELEMENTS EQUAL
	ERROR	DIMERR,FATAL	;DIMENSION ERROR OTHERWISE
;FETCHES THE FLOATER UNDER THE TOP INTEGER TO
;THE TOP OF THE STACK

FFLTPP:	MOV	#FLTLE2+2,R2	;POINT TO FLOATER BELOW INTEGER
FFUFS0:	ADD	R1,R2		;BY ADDING IN R1 POINTER
	MOV	#FLTLEN,R0	;GET WORD COUNTER
FFUFS1:	MOV	-(R2),-(R1)	;AND MOVE A FLOATER
	SOB	R0,FFUFS1	;LOOP
	RTS	PC

;PPUSHPOP CAUSES EXIT FROM INTERNAL PUSHPOP TO MACHINE CODE
;FOLLOWING AT NEXT EVEN LOCATION

EMCODE:	MOV	R5,R4		;SAVE CURRENT INTERNAL PP POINTER
	INC	R4		;EVEN UP
	BIC	#1,R4
	MOV	2(SP),R5	;RESTORE EXTERNAL PP POINTER
	MOV	(SP)+,(SP)	;OBLITERATE EXTERNAL POINTER TEMP
	MOV	R4,PC		;EXIT TO MACHINE CODE

;CODE FOR PUSHPOP PPFFUF (COPY 2'ND FROM TOP FLOAT # AT HEAD OF STACK)
FFUF:	MOV	#FLTLE4,R2	;PREPARE TO POINT TO 2ND FLOATER
	BR	FFUFS0		;NOW GO MOVE IT

;CODE FOR PUSHPOP PPTST (BRANCHES TO BYTE ADDRESS FOLLOWING
;IF NV3<>0,OTHERWISE DROPS THROUGH)
TSTFL:	MOVB	(R5)+,R2		;MOVE 1-BYTE ADDR. TO R2
	MOV	SPDA,R3			;MOVE C(SPDA) TO R3
	IFZ	NV3(R3),TSTF1		;TEST C(NV3), BR IF =0
	ADD	R2,R5			;NV3 FLAG <>0, SO ADD R2 TO INT. PC
TSTF1:	RTS	PC			;AND EXIT

;SET Z FLOP IF MATRIX POINTED AT BY MATRIC
;IS A STRING ARRAY. ALSO INTERCHANGES IPC'S.
TSTRNG:	MOV	SPDA,R2		;GET BIAS
	ADD	MATRIC(R2),R2	;ABSOLUTE ADDRESS ARRAY HEADER
	MOV	(SP)+,R3	;SAVE TOP OF STACK
	JSR	PC,SWPIPC	;SWAP IPC'S
	MOV	R3,-(SP)	;RESTORE TOP OF STACK
	BITB	#STRARY,ARYFLG(R2)	;TEST STRING ARRAY FLAG
TSTRN1:	RTS	PC		;AND OUT
;PRINT PUSHPOP FOR INDIVIDUAL MATRIX ENTRIES
MATPR:	JSR	PC,TSTRNG	;TEST STRING FLAG
	BEQ	MATPR1		;BR IF NOT STRING
	JSR	PC,PRINTS	;PRINT STRING
	BR	MATPR2
MATPR1:	JSR	PC,PRINTF	;PRINT FLOATER
MATPR2:	MOV	SPDA,R2
	MOV	NVTM(R2),R4	;GET TAB & CRLF FLAGS
	BMI	MATPR5		;IF CRLF FLAG SET, OUTPUT CRLF
	MOV	CB2(R2),R3	;R3_INNER REPEAT LOOP LIMIT
	IF  NV2(R2),NE,R3,MATPR4  ;EXIT IF NE CONTROL VARIABLE
	DEC	R3		;MAKE SMALL NUM NONPOSITIVE
	BLE	MATPR4		;EXIT ON SUCH NUMBERS
	JSR	PC,CRLF		;OUTPUT TWO CRLF'S
MATPR5:	JSR	PC,CRLF		;OUTPUT CRLF
	BR	MATRD2

MATPR4:	TSTB	R4		;CHECK TAB FLAG
	BPL	MATRD2		;EXIT IF NOT SET
	JSR	PC,NXTZON	;OTHWS, SEND OUT THE TAB
	BR	MATRD2

;READ PUSHPOP FOR INDIVIDUAL MATRIX ENTRIES
MATRD0:	JSR	PC,TSTRNG	;TEST STRING FLAG
	BEQ	MATRD1		;BR IF NOT A STRING MATRIX
	JSR	PC,READS	;READ STRING
	BR	MATRD2

MATRD1:	JSR	PC,READF	;READ A FLOATER
MATRD2:	JSR	PC,SWPIPC	;SWAP IPC'S
	RTS	PC

;INPUT PUSHPOP FOR INDIVIDUAL MATRIX ENTRIES

MATIN:	JSR	PC,TSTRNG	;TEST STRING FLAG
	BEQ	MATIN1		;BR IF NOT A STRING MATRIX
	JSR	PC,INPUTS	;INPUT A STRING
	BR	MATRD2

MATIN1:	JSR	PC,INPUTF	;INPUT A FLOATER
	BR	MATRD2

;ROUTINES TO SET MATRIA, MATRIB, & MATRIC TO
;POINTERS TO THE ARRAY HEADERS WHOSE ADDRESSES
;FOLLOW MATRIX PUSHPOPS.  MAT3ST SETS MATRIB TO THE
;ADDRESS OF THE SECOND ARG OF A MATRIX OPERATION
;AND DOES NAT2ST.  MAT2ST SETS MATRIA TO THE
;ADDRESS OF THE FIRST ARG AND DOES MAT1ST.  MAT1ST
;SETS MATRIC TO THE ADDRESS OF THE DESTINATION MATRIX.

MAT3ST:	MOV	#6,R0
MATNST:	MOV	#MATRIC,R2
	ADD	SPDA,R2
	ADD	R0,R2
MATLST:	MOVB	(R5)+,-(R2)
	SOB	R0,MATLST
	RTS	PC

MAT2ST:	MOV	#4,R0
	BR	MATNST

MAT1ST:	MOV	#2,R0
	BR	MATNST

;A FREQUENTLY USED PUSHPOP DOUBLE-INDEXED REPEAT
;COROUTINE FOR MATRIX STUFF

MAT2LP:	.BYTE	PPRDIM,MATRIA	;PUSH SOURCE ROW DIM
	.BYTE	PPCDIM,MATRIA	;PUSH SOURCE COLUMN DIM
MATLP0:	.BYTE	PPEMC		;EXIT TO MACHINE CODE
	.EVEN
	MOV	SPDA,R0		;SET BASE REGISTER
	ADD	MATRIC(R0),R0	;GET ABSOLUTE ADDRESS OF DESTINATION HEADER
	MOV	(R1),DIM2(R0)	;GET THE COLUMN DIM
	MOV	2(R1),DIM1(R0)	;GET THE ROW DIM
	JSR	R5,@(SP)+	;BACK TO INTERNAL PUSHPOP
MATL00:	.PPM	PPREPI,CB2	;SET IMMER RPT LIM
	.BYTE	PPBEGN		;GET INNER RPT START
	.PPM	PPOPI,NVT	;SAVE IN A TEMP
	.PPM	PPREPI,CB1	;SET OUTER RPT LIM
	.BYTE	PPBEGN		;GET OUTER RPT START
	.PPM	PPOPI,NV1	;POP TO CONTROL VARIABLE
	.PPM	PPUSHI,R1EXT	;POSITION SUBROUTINE ADDRESS
MT2LP1:	.PPM	PPFRI,NV1,CB1+1,MT2LP4-ME.	;BEGIN OUTER REPEAT
	.PPM	PPUSHI,NVT	;FETCH INNER REPEAT START
	.PPM	PPOPI,NV2	;POP TO CONTROL VARIABLE
MT2LP2:	.PPM	PPFRI,NV2,CB2+1,MT2LP3-ME.	;BEGIN INNER REPEAT
	.BYTE	PPCALI		;CALL SUBROUTINE
MT2LP3:	.PPM	PPNXI,NV2,CB2+1,MT2LP2-ME.	;END OF INNER REPEAR
MT2LP4:	.PPM	PPNXI,NV1,CB1+1,MT2LP1-ME.	;END OF OUTER REPEAT
	.BYTE	PPRTS		;HONEST SUB EXIT

;A FREQUENTLY USED PUSHPOP DOUBLE-INDEXED REPEAT
;COROUTINE FOR MATRIX STUFF - WITH INDICES ON R1 STACK.

MAT2IN:	.BYTE	PPREOR		;SET UP TEST ON INDICES
	.PPM	PPIFJ,MATLP0-ME.  ;BR IF USER-SUPPLIED INDICES
MAT2I1:	.BYTE	PPRDIM,MATRIC	;OTHWS, USE THE
	.BYTE	PPCDIM,MATRIC	;DESTINATION MATRIX DIMS
	.PPM	PPUJ,MATLP0-ME.	;REJOIN NONZERO CASE
;A VARIANT OF MAT2IN
MAT2I2:	.BYTE	PPREOR		;SET UP TEST ON INDICES
	.PPM	PPIFJ,MATL00-ME.	;BR IF USER SUPPLIED INDICES
	.PPM	PPUJ,MAT2I1-ME.	;JUST LIKE MAT2IN
	.EVEN

;THE MATRIX COPY PUSHPOP
MATCPY:	JSR	PC,MAT2ST	;SET SOURCE & DESTINATION ADDRESS
	JSR	R5,@(SP)+	;INTO INTERPRETIVE MODE
	.PPM	PPCALS,MAT2LP-ME.	;SET UP DOUBLE LOOP
;THIS CODE GETS EXECUTED REPEATEDLY
	.BYTE	PPMPUS,MATRIA,NV1,NV2	;PUSH SOURCE ENTRY
MATCP1:	.BYTE	PPMPOP,MATRIC,NV1,NV2	;POP TO DESTINATION
MATCP2:	.BYTE	PPCORU		;BACK TO REPEAT LOOP
	.BYTE	PPEXIT		;HOME JAMES
	.EVEN
;MATRIX SCALAR MULTIPLIES
MATSMI:	JSR	PC,FLT		;FIT INTEGER & DROP THRU
MATSMF:	JSR	PC,MAT2ST	;SET SOURCE & DESTINATION ADDRESS
	JSR	R5,@(SP)+	;INTO INTERPRETIVE MODE
	.PPM	PPCALS,MAT2LP-ME.	;SET UP DOUBLE LOOP
;THIS CODE GETS EXECUTED REPEATEDLY
	.BYTE	PPFFLT		;FETCH MULTIPLIER
	.BYTE	PPMPUS,MATRIA,NV1,NV2	;PUSH SOURCE ENTRY
	.BYTE	PPMULF		;MULTIPLY
	.BYTE	PPMPOP,MATRIC,NV1,NV2  ;POP TO DESTINATION
	.BYTE	PPCORU		;BACK TO DOUBLE LOOP
	.BYTE	PPKIF		;GET RID OF SCALAR MULTIPLIER
	.BYTE	PPEXIT		;OUT
	.EVEN

;ROUTINE USEFUL TO MATRIX ADD & SUBSTRACT

MATAD0:	.BYTE	PPRDIM,MATRIA	;PUSH A ROW DIM
	.BYTE	PPRDIM,MATRIB	;PUSH B ROW DIM
	.BYTE	PPCMPI		;ERROR IF NOT EQUL
	.BYTE	PPCDIM,MATRIA	;PUSH A COL DIM
	.BYTE	PPCDIM,MATRIB	;PUSH B COL DIM
	.BYTE	PPCMPI		;ERROR IF NOT EQUAL
	.BYTE	PPCORU		;BACK
	.EVEN

;MATRIX ADD

MATADD:JSR	PC,MAT3ST	;SET SOURCE & DESTINATION ADDRESSES
	JSR	R5,@(SP)+	;ENTER INTERPRETER
	.PPM	PPCALS,MATAD0-ME.	;TEST DIMENSIONS
	.PPM	PPCALS,MATLP0-ME.	;ENTER INTERPRETER
;THIS CODE GETS EXECUTED OVER & OVER
	.BYTE	PPMPUS,MATRIA,NV1,NV2	;PUSH A ENTRY
	.BYTE	PPMPUS,MATRIB,NV1,NV2	;PUSH B ENTRY
	.BYTE	PPADDF		;ADD
	.PPM	PPUJ,MATCP1-ME.	;EXIT VAI MATCP1
	.EVEN

;MATRIX SUB

MATSUB:	JSR	PC,MAT3ST	;SET SOURCE & DESTINATION ADDRESSES
	JSR	R5,@(SP)+	;ENTER INTERPRETER
	.PPM	PPCALS,MATAD0-ME.	;TEST DIMENSIONS
	.PPM	PPCALS,MATLP0-ME.	;SET UP DOUBLE LOOP
;OVER & OVER
	.BYTE	PPMPUS,MATRIA,NV1,NV2	;PUSH A ENTRY
	.BYTE	PPMPUS,MATRIB,NV1,NV2	;PUSH B ENTRY
	.BYTE	PPSUBF		;SUBTRACT
	.PPM	PPUJ,MATCP1-ME.	;EXIT VIA MATCP1
	.EVEN

;MATRIX MULTIPLY

MATMUL:	JSR	PC,MAT3ST	;SET SOURCE & DESTINATION ADDRESSES
	JSR	R5,@(SP)+	;ENTER INTERPRETER
	.BYTE	PPCDIM,MATRIA	;MATRIX A'S COLUMN DIMENSION
	.BYTE	PPRDIM,MATRIB	;MATRIX B'S ROW DIMENSION
	.BYTE	PPCMPI		;ERROR IF INDICES NOT EQUAL
	.PPM	PPREPI,CB3	;SET DOT PRODUCT LOOP LIMIT
	.BYTE	PPBEGN		;GET ITS START
	.PPM	PPOPI,NVTM	;SAVE IN TEMP
	.BYTE	PPRDIM,MATRIA	;MATRIX A'S ROW DIM
	.BYTE	PPCDIM,MATRIB	;MATRIX B'S COLUMN DIM
	.PPM	PPCALS,MATLP0-ME.	;SET UP DOUBLE OUTER LOOP
;THIS IS THE INNER LOOP
	.BYTE	PPUFL0		;PUSH FLOATING 0
	.PPM	PPUSHI,NVTM	;GET DOT LOOP START
	.PPM	PPOPI,NV3	;POP TO CONTROL VAR
MAMUL1:	.PPM	PPFRI,NV3,CB3+1,MAMUL2-ME.	;BEGIN DOT LOOP
	.BYTE	PPMPUS,MATRIA,NV1,NV3	;PUSH A TERM
	.BYTE	PPMPUS,MATRIB,NV3,NV2	;PUSH B TERM
	.BYTE	PPMULF		;MULTIPLY
	.BYTE	PPADDF		;ADD TO RUNNING TOTAL
MAMUL2:	.PPM	PPNXI,NV3,CB3+1,MAMUL1-ME.	;END OF DOT LOOP
	.PPM	PPUJ,MATCP1-ME.	;EXIT VIA MATCP1
	.EVEN

;MATRIX TRANSPOSE

MATTRN:	JSR	PC,MAT2ST	;SET SOURCE & DESTINATION ADDRESSES
	JSR	R5,@(SP)+	;NO INTO INTERPRETIVE MODE
	.BYTE	PPCDIM,MATRIA	;PUSH SOURCE COLUMN DIM
	.BYTE	PPRDIM,MATRIA	;PUSH ROW DIM
	.PPM	PPCALS,MATLP0-ME.	;SET UP DOUBLE LOOP
;THIS CODE GETS EXECUTED OVER & OVER
	.BYTE	PPMPUS,MATRIA,NV2,NV1	;PUSH SOURCE ENTRY
	.PPM	PPUJ,MATCP1-ME.	;EXIT VIA MATCP1

;THE MATRIX ZERO PUSHPOP

MATZRO:	JSR	PC,MAT1ST	;GET DESTINATION ADDRESS
	JSR	R5,@(SP)+	;INTO INTERPRETIVE MODE
	.PPM	PPCALS,MAT2IN-ME.	;INITIALIZE DOUBLE LOOP
;INSIDE CODE
MZRO:	.BYTE	PPUFL0		;PUSH FLOATING ZERO
	.PPM	PPUJ,MATCP1-ME.	;GO TO MATCP1
	.EVEN

;THE MATRIX ONE PUSHPOP

MATC1:	JSR	PC,MAT1ST	;GET DESTINATION ADDRESS
	JSR	R5,@(SP)+	;INTO INTERPRETIVE MODE
	.PPM	PPCALS,MAT2IN-ME.	;INIT DOUBLE LOOP
;INSIDE CODE
MC1:	.BYTE	PPUFL1		;PUSH FLOATING ONE
	.PPM	PPUJ,MATCP1-ME.	;GO TO MATCP1
	.EVEN

;THE MATRIX IDENTITY PUSHPOP

MATID:	JSR	PC,MAT1ST	;GET DESTINATION ADDRESS
	JSR	R5,@(SP)+	;INTO INTERPRETIVE MODE
	.PPM	PPCALS,MAT2IN-ME.	;INITIALIZE DOUBLE LOOP
;INSIDE CODE
	.PPM	PPUSHI,NV1
	.PPM	PPUSHI,NV2
	.BYTE	PPEQI
	.PPM	PPITJ,MC1-ME.	;ON DIAGONAL, PUSH 1
	.PPM	PPUJ,MZRO-ME.	;OFF DIAGONAL, PUSH 0
	.EVEN

;MATRIX PRINT PUSHPOP

MATPRC:	MOV	#100000,-(R1)	;SIGNAL CRLF
	BR	MATPN1

MATPRT:	MOV	#200,-(R1)	;SIGNAL TAB
	BR	MATPN1

MATPRN:	CLR	-(R1)		;SIGNAL NO TABS OR CRLF'S
MATPN1:	JSR	PC,MAT1ST	;GET SOURCE ADDRESS
	JSR	R5,@(SP)+	;START INTERPRETING
	.PPM	PPOPI,NVTM	;SAVE TAB-CRLF FLAG
	.PPM	PPCALS,MAT2I2-ME.	;SET UP DOUBLE LOOP
;THIS CODE IS EXECUTED REPEATEDLY
	.BYTE	PPMPUS,MATRIC,NV1,NV2	;PUSH ITEM FOR PRINTING
	.BYTE	PPMPR		;PRINT IT
	.BYTE	PPCORU		;BACK TO REPEAT LOOP
	.BYTE	PPEXIT
	.EVEN

;MATRIX READ ROUTINE

MATRD:	JSR	PC,MAT1ST	;SET DESTINATION
	JSR	R5,@(SP)+	;INTERPRETIVE MODE
	.PPM	PPCALS,MAT2IN-ME.	;SET UP DOUBLE LOOP
;REPEATED CODE
	.BYTE	PPMRD0		;READ AN ENTRY
	.PPM	PPUJ,MATCP1-ME.	;EXIT VIA MATCP1
	.EVEN


;MATRIX INPUT ROUTINE

MATINP:	JSR	PC,MAT1ST	;SET DESTINATION
	JSR	R5,@(SP)+	;INTERPRETIVE MODE
	.PPM	PPCALS,MAT2IN-ME.	;SET UP DOUBLE LOOP
;REPEATED CODE
	.BYTE	PPMAIN		;INPUT AN ENTRY
	.BYTE	PPMPOP,MATRIC,NV1,NV2  ;POP TO DESTINATION MATRIX
	.PPM	PPUSHI,NVTM	;PUSH DONE FLAG
	.PPM	PPIFJ,MATCP2-ME.  ;GO TO MATCP2 IF NOT DONE
	.BYTE	PPIJS		;IF DONE EARLY, DUMP COROUTINE ADDRS
	.BYTE	PPEXIT
	.EVEN

;THE MATRIX INVERSION PUSHPOP
MATINV:	JSR	PC,MAT2ST	;SET SOURCE AND DESTIN. ADDRESSES
	JSR	R5,@(SP)+	;ENTER INTERPRETIVE MODE
	.BYTE	PPRDIM,MATRIA		;PUSH ARG ROW DIM
	.BYTE	PPCDIM,MATRIA		;PUSH ARG COLUMN DIM
	.BYTE	PPCMPI		;CHECK FOR EQUALITY
	.BYTE	PPEMC		;EXIT TO MACHINE CODE
	.EVEN
	IFZERO	NE,(R1)+,MILCM4  ;BR IF DIMS NONZERO
	ERROR	DIMERR,FATAL	;OTHWS, SEND BACK DIMENSION ERROR
MILCM4:	JSR	R5,@(SP)+	;BACK TO PUSHPOP
	;COPY ARG INTO DESTINATION
	.PPM	PPCALS,MAT2LP-ME.	;SET UP DOUBLE LOOP
	.BYTE	PPMPUS,MATRIA,NV1,NV2  ;PUSH ARG ENTRY
	.BYTE	PPMPOP,MATRIC,NV1,NV2  ;POP TO DESTINATION
	.BYTE	PPCORU		;BACK TO DOUBLE LOOP
	;END OF COPY OPERATION
	.BYTE	PPUFL1		;PUSH A FLOATING ONE
	.PPM	PPOPF,DET	;STORE IT IN DET
	.BYTE	PPFIX1		;PUSH AN INTEGER ONE
	.PPM	PPOPI,NV1	;INIT. LOOP VAR. TO 1
MILB1:	.PPM	PPFRI,NV1,CB1+1,MILE1-ME.	;BEGIN LOOP TO INIT.
						;0'TH COL. OF A TO 0
	.BYTE	PPUFL0			;PUSH A FLOATING ZERO
	.BYTE	PPMPOP,MATRIC,NV1,Z00000	;SET A(I,0)=0
MILE1:	.PPM	PPNXI,NV1,CB1+1,MILB1-ME.	;END OF LOOP
	.BYTE	PPFIX1		;PUSH INTEGER 1
	.PPM	PPOPI,NV2	;INIT. I TO 1
MILB2:	.PPM	PPFRI,NV2,CB1+1,MILE2-ME.	;SET UP I LOOP
	.BYTE	PPUFL0		;PUSH FLOATING 0 AS INIT. VAL. OF P
	.BYTE	PPFIX1		;PUSH INTEGER 1
	.PPM	PPOPI,NV1	;INIT. J TO 1
MILB3:	.PPM	PPFRI,NV1,CB1+1,MILE3-ME.	;SET UP J LOOP
	.BYTE	PPMPUS,MATRIC,NV1,Z00000	;PUSH A(J,0)
	.BYTE	PPUFL0		;PUSH FLOATING 0
	.BYTE	PPNEF		;TEST FOR <>
	.PPM	PPITJ,MILE3-ME.	;BRANCH IF A(J,0)<>0
	.BYTE	PPMPUS,MATRIC,NV1,NV2	;PUSH A(J,I)
	.BYTE	PPFFUF		;COPY P AT HEAD OF STACK
	.BYTE	PPABXF		;CALC. ITS ABSOLUTE VAL.
	.BYTE	PPFFUF		;COPY A(J,I)
	.BYTE	PPABXF		;CALC. ITS ABS. VAL.
	.BYTE	PPGEF		;TEST FOR >=
	.PPM	PPIFJ,MILL1-ME.	;BRANCH IF ABS(A(J,I))>ABS(P)
	.BYTE	PPKIF		;KILL A(J,I),LEAVING OLD P VALUE
	.PPM	PPUJ,MILE3-ME.	;AND BRANCH BACK
MILL1:	.PPM	PPOPF,TEMF	;STORE A(J,I) IN TEMF
	.BYTE	PPKIF		;KILL THE OLD VALUE OF P
	.PPM	PPUSHF,TEMF	;BRING BACK C(TEMF) AS THE NEW P VAL.
	.PPM	PPUSHI,NV1	;PUSH THE VALUE OF J
	.PPM	PPOPI,NVTM	;STORE IT AS THE VALUE OF L
MILE3:	.PPM	PPNXI,NV1,CB1+1,MILB3-ME.	;END OF J LOOP
	.PPM	PPREPF,TEMF	;SAVE THE FINAL P VALUE IN TEMF
	.PPM	PPUSHF,DET	;PUSH THE CURR. DET. VALUE
	.BYTE	PPMULF		;CALC. P*C(DET)
	.PPM	PPREPF,DET	;AND STORE BACK IN DET
	.BYTE	PPUFL0		;PUSH A FLOATING 0
	.BYTE	PPNEF		;TEST FOR DET<>0
	.PPM	PPITJ,MILL3-ME.	;BRANCH IF <>0
	.BYTE	PPEMC		;EXIT TO MACHINE CODE
	.EVEN
	ERROR	MINVER		;DETERMINANT=0, CAN'T INVERT
	RTS	PC		;KEEP GOING AFTER ERROR
MILL3:	.BYTE	PPUFL1		;PUSH FLOATING 1
	.BYTE	PPNEGF		;NEGATE,GET FLOATING -1 ON STACK
	.BYTE	PPMPOP,MATRIC,NVTM,NV2	;A(L,I)=-1
	.PPM	PPUSHI,NV2		;PUSH I
	.BYTE	PPFLT		;FLOAT I
	.BYTE	PPMPOP,MATRIC,NVTM,Z00000	;A(L,0)=I
	.PPM	PPUSHI,NVTM		;PUSH L
	.BYTE	PPFLT		;FLOAT L
	.BYTE	PPMPOP,MATRIC,Z00000,NV2	;A(0,I)=L
	.BYTE	PPFIX1		;PUSH AN INTEGER 1
	.PPM	PPOPI,NV1		;INIT. J VALUE TO 1
MILB4:	.PPM	PPFRI,NV1,CB1+1,MILE4-ME.	;SET UP J LOOP
	.BYTE	PPMPUS,MATRIC,NVTM,NV1	;PUSH A(L,J)
	.BYTE	PPNEGF		;NEGATE,GET -A(L,J) ON STACK
	.PPM	PPUSHF,TEMF	;PUSH P
	.BYTE	PPDIVF		;CALC. -A(L,J)/P
	.BYTE	PPMPOP,MATRIC,NVTM,NV1		;A(L,J)=-A(L,J)/P
MILE4:	.PPM	PPNXI,NV1,CB1+1,MILB4-ME.	;END OF J LOOP
	.BYTE	PPFIX1		;PUSH AN INTEGER 1
	.PPM	PPOPI,NV1		;INIT. J TO 1
MILB5:	.PPM	PPFRI,NV1,CB1+1,MILE5-ME.	;SET UP J LOOP
	.PPM	PPUSHI,NV1	;GET J
	.PPM	PPUSHI,NVTM	;GET L
	.BYTE	PPEQI		;TEST IF J=L
	.PPM	PPITJ,MILE5-ME.	;BRANCH IF =
	.BYTE	PPMPUS,MATRIC,NV1,NV2	;GET A(J,I), I.E. S
	.BYTE	PPMPUS,MATRIC,NV1,NV2	;GET IT AGAIN
	.PPM	PPUSHF,TEMF		;PUSH P
	.BYTE	PPDIVF		;DIVIDE BY P
	.BYTE	PPMPOP,MATRIC,NV1,NV2	;A(J,I)=A(J,I)/P
	.BYTE	PPFIX1		;PUSH AN INTEGER 1
	.PPM	PPOPI,NV3		;INIT. K TO 1
MILB6:	.PPM	PPFRI,NV3,CB1+1,MILE6-ME.	;SET UP K LOOP
	.PPM	PPUSHI,NV3		;PUSH K
	.PPM	PPUSHI,NV2		;PUSH I
	.BYTE	PPEQI		;TEST IF K=I
	.PPM	PPITJ,MILE6-ME.	;BRANCH IF =
	.BYTE	PPMPUS,MATRIC,NV1,NV3	;PUSH A(J,K)
	.BYTE	PPFFUF		;COPY S AT TOP OF STACK
	.BYTE	PPMPUS,MATRIC,NVTM,NV3	;PUSH A(L,K)
	.BYTE	PPMULF		;CALC. S*A(L,K)
	.BYTE	PPZSMA		;CALC. A(J,K)+S*A(L,K),TESTING FOR UNDERFLOW
	.BYTE	PPMPOP,MATRIC,NV1,NV3	;STORE IN A(J,K)
MILE6:	.PPM	PPNXI,NV3,CB1+1,MILB6-ME.	;END OF K LOOP
	.BYTE	PPKIF		;KILL TOP FLOAT ON STACK,I.E. S
MILE5:	.PPM	PPNXI,NV1,CB1+1,MILB5-ME.	;END OF J LOOP
MILE2:	.PPM	PPNXI,NV2,CB1+1,MILB2-ME.	;END OF I LOOP
	;UNSCRAMBLING OF ROWS AND COLUMNS BEGINS HERE
	.BYTE	PPFIX0		;PUSH AN INTEGER 0
	.PPM	PPOPI,NV3	;SET PPTST FLAG=0
	.PPM	PPUSHI,CB1	;PUSH N
	.BYTE	PPFIX1		;PUSH AN INTEGER 1
	.BYTE	PPSUBI		;CALC. N-1
	.PPM	PPOPI,CB2		;AND STORE IT IN CB2
MILL4:	.BYTE	PPFIX1		;PUSH AN INTEGER 1
	.PPM	PPOPI,NV1		;INIT. I TO 1
MILB7:	.PPM	PPFRI,NV1,CB2+1,MILE7-ME.	;SET UP I LOOP
	.BYTE	PPTST,MILL5-.-1	;BRANCH IF COL. PASS
MILL14:	.BYTE	PPMPUS,MATRIC,NV1,Z00000	;PUSH A(I,0),CALL IT L
	.PPM	PPUJ,MILL6-ME.	;BRANCH TO MILL6
MILL5:	.BYTE	PPMPUS,MATRIC,Z00000,NV1	;PUSH A(0,I),CALL IT L
MILL6:	.BYTE	PPFIX		;FIX L
	.PPM	PPREPI,NVTM	;AND STORE IN NVTM
	.PPM	PPUSHI,NV1	;PUSH I
	.BYTE	PPEQI		;TEST IF I=L
	.PPM	PPITJ,MILE7-ME.	;IF SO, BRANCH
	.BYTE	PPTST,MILL7-.-1	;BRANCH IF COL. PASS
	.PPM	PPUSHF,DET	;PUSH C(DET)
	.BYTE	PPNEGF		;NEGATE,LEAVES -C(DET) ON STACK
	.PPM	PPOPF,DET	;AND STORE BACK IN DET
MILL7:	.BYTE	PPFIX0		;PUSH AN INTEGER 0
	.PPM	PPOPI,NV2	;INIT. J TO 0
MILB8:	.PPM	PPFRI,NV2,CB1+1,MILE8-ME.	;SET UP J LOOP
	.BYTE	PPTST,MILL8-.-1		;BRANCH IF COL. PASS
	.BYTE	PPMPUS,MATRIC,NV1,NV2	;PUSH A(I,J) AS P
	.PPM	PPUJ,MILL9-ME.	;BRANCH TO MILL9
MILL8:	.BYTE	PPMPUS,MATRIC,NV2,NV1	;PUSH A(J,I) AS P
MILL9:	.BYTE	PPTST,MILL10-.-1	;BRANCH IF COL. PASS
	.BYTE	PPMPUS,MATRIC,NVTM,NV2	;PUSH A(L,J)
	.BYTE	PPMPOP,MATRIC,NV1,NV2	;AND STORE IT IN A(I,J)
	.PPM	PPUJ,MILL11-ME.	;BRANCH TO MILL11
MILL10:	.BYTE	PPMPUS,MATRIC,NV2,NVTM	;PUSH A(J,L)
	.BYTE	PPMPOP,MATRIC,NV2,NV1	;AND STORE IT IN A(J,I)
MILL11:	.BYTE	PPTST,MILL12-.-1	;BRANCH IF COL. PASS
	.BYTE	PPMPOP,MATRIC,NVTM,NV2	;STORE P IN A(L,J)
	.PPM	PPUJ,MILE8-ME.		;BRANCH TO MILE8
MILL12:	.BYTE	PPMPOP,MATRIC,NV2,NVTM	;STORE P IN A(J,L)
MILE8:	.PPM	PPNXI,NV2,CB1+1,MILB8-ME.	;END OF J LOOP
	.BYTE	PPTST,MILL5-.-1	;BRANCH IF COL. PASS
	.PPM	PPUJ,MILL14-ME.	;BRANCH TO MILL14

MILE7:	.PPM	PPNXI,NV1,CB2+1,MILB7-ME.	;END OF I LOOP
	.BYTE	PPTST,MILL15-.-1	;BRANCH IF COL. PASS COMPLETED
	.BYTE	PPFIX1		;PUSH AN INTEGER 1
	.PPM	PPREPI,NV3		;SET PPTST FLAG <>0
	.PPM	PPUJ,MILL4-ME.+1	;BRANCH TO MILL4+1; GO AROUND AGAIN FOR COLS.
MILL15:	.BYTE	PPEXIT		;DONE,EXIT
	.EVEN

	.END

