.IIF	NDF	L$$IST,	.NLIST
TITLE	SYRC,<BASIC+ SYSTEM DEFINITIONS>,08,13-MAY-86,TPH/MHB/JDM/TVG

;                   Copyright 1974,1990 by Digital Equipment Corporation
;                                  All rights reserved.
;
;          This software is furnished under a license and may be used and copied
;          only  in  accordance  with  the  terms  of  such license and with the
;          inclusion of the above copyright notice.  This software or any copies
;          shall not be provided to any other person.   No title to or ownership
;          of the software is hereby transferred.
;
;          The information in this software is subject to change without notice.
;
;          DIGITAL  assumes  no  responsibility  for the  use, functionality, or
;          reliability of its  software  on equipment  which  is not supplied by
;          DIGITAL.


;+
;  Definitions for bogus conditions, such locations to jump to for
;  situations which "can't happen"
;-

; RTS pseudo-vectors now handled only by DCL, and no longer by any other RTS,
; such as BASIC-PLUS

XXCRAS	  =:	-1	;P.CRAS, system crash restart -- jump to -1
XXINIT	  =:	-3	;P.STRT, system startup -- jump to -3

; MACRO DEFINITIONS

; GET A WORD OUT OF THE DATA AREA AT RUN TIME - GWTXT

.MACRO	GWTXT	REG
	  MOVB	(R5)+,-(R1)
	  MOVB	(R5)+,-(R1)
	  MOV	(R1)+,REG
.ENDM

; TRANSCENDENTALS

.MACRO	TOPR1	OP,ADDR
	  MOV	#ADDR,R0
	  JSR	PC,@#PUSHF2
	  JSR	PC,@#OP
.ENDM

.MACRO	MOVFLT	ADR1,ADR2
.REPT	FLTLEN
	  MOV	ADR1,ADR2
.ENDR
.ENDM

.MACRO	FLTPP	ARG
.NTYPE	$$$$$$,ARG
.IF	EQ	FLTLEN-2
	 CMP	ARG,ARG
.MEXIT
.ENDC
.DSABL	CRF
.IF	EQ	$$$$$$&70-20
.IRP	$$$$$$,<\<$$$$$$&7>>
.ENABL	CRF
.IF	EQ	$$$$$$-6
	 ADD	#FLTLEN*2,SP
.IFF
	 ADD	#FLTLEN*2,R'$$$$$$
.ENDC
.ENDM
.MEXIT
.ENDC
.IF	EQ	$$$$$$&70-40
.IRP	$$$$$$,<\<$$$$$$&7>>
.ENABL	CRF
.IF	EQ	$$$$$$-6
	 SUB	#FLTLEN*2,SP
.IFF
	 SUB	#FLTLEN*2,R'$$$$$$
.ENDC
.ENDM
.MEXIT
.ENDC
.ENABL	CRF
.ERROR	;INVALID ARGUMENT TYPE
.ENDM	FLTPP

.MACRO	FPUSHC	ARG
.IF	EQ	FLTLEN-2
	 CLR	-(R1)
	 MOV	#^F'ARG,-(R1)
.IFF
	 JSR	R0,FPUSHC
	  .WORD	^F'ARG
.ENDC
.ENDM	FPUSHC

.MACRO	FLTCLR	ARG
.REPT	FLTLEN-2
	  CLR	ARG
.ENDR
.ENDM

.MACRO	ZSKIP	AMT,VALUE
.BLKW0	<AMT>,<VALUE>
.ENDM	ZSKIP

; EQUATES TO LA'S TABLES

PLUS	=	 0	;+
STAR	=	 1	;*
;	=	 2	;/
BMINS	=	 3	;BINARY -
;	=	 4	;UNARY -
;	=	 5	;^ OR **
;	=	 6	;.AND.
;	=	 7	;.OR.
;	=	10	;.XOR.
;	=	11	;.NOT.
;	=	12	;.IMP.
;	=	13	;.EQV.
EQUALS	=	14	;=
;	=	15	;<>
;	=	16	;>
;	=	17	;>=
;	=	20	;<
;	=	21	;<=
;	=	22	;==
PUSH	=	23	;
LPAR	=	24	;(
RPAR	=	25	;)
COMMA	=	26	;,
ENDOL	=	27	;END OF LINE
SEMICO	=	30	;;

COLON	=	43	;:
POUND	=	44	;#

THEN	=	300	;THEN
ELSE	=	301	;ELSE
STEP	=	302	;STEP
ASFILE	=	303	;AS FILE
;	=	304	;
;	=	305	;
USING	=	306	;USING
ZER	=	307	;ZER(
IDN	=	310	;IDN(
CON	=	311	;CON(
TRNLP	=	312	;TRN(
INVLP	=	313	;INV(
TO	=	314	;TO
FINASF	=	315	;FOR INPUT AS FILE
FOUASF	=	316	;FOR OUTPUT AS FILE
AS	=	317	;AS
RCORSZ	=	320	;RECORD SIZE
MODE	=	321	;MODE
CLUSSZ	=	322	;CLUSTER SIZE
RECORD	=	323	;RECORD
COUNT	=	324	;COUNT
FILESZ	=	325	;FILE SIZE
BLOCK	=	326	;BLOCK

TKCONT	=	 46	;CONT(INUE)
;	=	 50	;LIST
;	=	 52	;LIST NH
;	=	 54	;DELETE
;	=	 56	;LENGTH
;	=	 60	;NEW
;	=	 62	;OLD
;	=	 64	;RENAME
;	=	 66	;REPLACE
;	=	 70	;RUN
;	=	 72	;RUN NH
;	=	 74	;ASSIGN
;	=	 76	;SAVE
;	=	100	;DEASSIGN
;	=	102	;UNSAVE
;	=	104	;CATALOG
;	=	106	;COMPILE
;HELLO	=	110	;HELLO		;No longer	WJS 90.1.31
;	=	112	;BYE		;No longer	WJS 90.1.31
;	=	114	;TAPE
;	=	116	;KEY
TKAPND	=	120	;APPEND
TKMORE	=	122	;MORE TO COME...

TKRAND	=	124	;RANDOMIZE
TKMAT	=	126	;MAT(RIX)
TKCHNG	=	130	;CHANGE
INPUT	=	132	;INPUT
TKPRIN	=	134	;PRINT
;	=	136	;DIM(ENSION)
;	=	140	;DEF(INE)
GOTO	=	142	;GOTO
;	=	144	;IF
;	=	146	;FOR
;	=	150	;ON
;	=	152	;RETURN
TKLET	=	154	;LET
;	=	156	;DATA
;	=	160	;RESTORE
;	=	162	;RESUME
;	=	164	;STOP
;	=	166	;END
;	=	170	;ON ERROR GOTO
;	=	172	;OPEN
;	=	174	;CLOSE
;	=	176	;CHAIN
REMRK	=	200	;REM(ARK)
;	=	202	;NEXT
;	=	204	;NAME
TREAD	=	206	;READ
TGOSUB	=	210	;GOSUB
;	=	212	;FNEND
;	=	214	;INPUT LINE
;	=	216	;WHILE
;	=	220	;UNTIL
;	=	222	;KILL
TKGET	=	224	;GET
;	=	226	;PUT
;	=	230	;FIELD
;	=	232	;LSET
;	=	234	;RSET
TKULOC	=	236	;UNLOCK
TKSLEP	=	240	;SLEEP
TKWAIT	=	242	;WAIT
TKUNLS	=	244	;UNLESS
TKXTND	=	246	;EXTEND
TKNXTN	=	250	;NO EXTEND
PRINT	=	TKPRIN

; XT (TRANSLATOR TABLE) DEFINITIONS

DOTABV	=	TKCONT		;LOWEST INDEX INTO TABLE

TLDIPT	=	0		;START OF TABLE INDICIES

TLDIPB	=	TKRAND-TKCONT+TLDIPT	;START OF PROGRAM TABLE INDICIES

TLDIPL	=	TKNXTN		;HIGHEST 'GOOD' INDEX

; ARGUMENT MACROS

.MACRO	ARGS	A1,A2,A3,A4
.IF	NE	A4+0
	.WORD	A1*4+A2*4+A3*4+A4
.MEXIT
.ENDC
.IF	NE	A3+0
	.WORD	A1*4+A2*4+A3
.MEXIT
.ENDC
.IF	NE	A2+0
	.WORD	A1*4+A2
.MEXIT
.ENDC
	.WORD	A1
.ENDM

; PUSH-POP MACRO

.MACRO	.PPM	PSHPOP,AD1,AD2,AD3
	.BYTE	PSHPOP
.NARG	TMPTAG
.IF	GE	TMPTAG-2
ME.	=	.+2
	.BYTE	AD1&177400/400,AD1&377
.ENDC
.IF	GE	TMPTAG-3
ME.	=	.+2
	.BYTE	AD2&177400/400,AD2&377
.ENDC
.IF	GE	TMPTAG-4
ME.	=	.+2
	.BYTE	AD3&177400/400,AD3&377
.ENDC
.ENDM

; LOOP MACROS

.MACRO	.BLOOP	NAME,COUNT
NAME'1:	DEC	COUNT		;BEG LOOP NAME
	BMI	NAME'2+2	;IF COUNT EXAUSTED, EXIT
.ENDM

.MACRO	.ELOOP	NAME
NAME'2:	BR	NAME'1		;END OF LOOP NAME
.ENDM

; TESTING MACROS

.MACRO	IF	A1,REL,A2,ADDR,BY
	 CMP'BY	A1,A2		;BRANCH IF A1 REL A2
	 B'REL	ADDR
.ENDM

.MACRO	IFZERO	REL,A1,ADDR,BY
	 TST'BY	A1		;BRANCH IF A1 REL 0
	 B'REL	ADDR
.ENDM

.MACRO	IFSIGN	A1,SGN,ADDR,BY
	 TST'BY	A1
	 B'SGN	ADDR		;BRANCH IF A1 SGN'US
.ENDM

.MACRO	JMASK0	REL,A1,MASK,ADDR,BY
	 BIT'BY	A1,#'MASK	;IF 0 REL A1 & MASK
	 B'REL	ADDR		;THEN GO TO ADDR
.ENDM

.MACRO	IFZ	A1,ADDR,BY
	 TST'BY	A1
	 BEQ	ADDR		;IF A1 = 0 THEN ADDR
.ENDM

.MACRO	IFNZ	A1,ADDR,BY
	 TST'BY	A1
	 BNE	ADDR		;IF A1 <> 0 THEN ADDR
.ENDM

.MACRO	IFTOKA	REL,ARG,ADDR
	 JSR	R5,@#TATEST
	 .WORD	ARG
	 B'REL	ADDR
.ENDM

.MACRO	TBITT	A1,ADDR
	 BITB	#'A1,TOKE(R0)
	 BEQ	ADDR
.ENDM

; JOB FLAG BITS:

.BSECT

JFBREK:	.BLKB	.	;STEP/BREAK HAS BEEN INVOKED (DEBUG OPTION)
	.BLKB	.	;RESERVED FOR 'JFRTS'
	.BLKB	.	;RESERVED FOR 'JFRTS'
JFTRAC:	.BLKB	.	;TRACE HAS BEEN INVOKED (DEBUG OPTION)
JFEXIT:	.BLKB	.	;EXIT TO USER'S DEFAULT RTS
JFWIPE:	.BLKB	.	;WIPE OUT CORE IMAGE ON ERROR OR EXIT
JFCCC:	.BLKB	.	;ENABLE ^C ERROR CATCHER
	.BLKB	.	;RESERVED FOR 'JFCC'
JFSPRI:	.BLKB	.	;RUNNING AT SPECIAL RUN PRIORITY
JFFPP:	.BLKB	.	;CONTEXT SWITCH THE FPP
JFPRIV:	.BLKB	.	;USER HAS PERM. PRIV'S
JFSYS:	.BLKB	.	;RUNNING WITH SPECIAL PRIV'S
JFNOPR:	.BLKB	.	;USER NOT LOGGED IN YET
JFBIG:	.BLKB	.	;JOB CAN EXCEED PRIVATE CORMAX
JFLOCK:	.BLKB	.	;LOCK USER INTO MEMORY
JFSTOP:	.BLKB	.	;STOP THIS USER AFTER CURRENT POP

JFRTS	=	6	;NUMERICAL ERRORS POSTED HERE
JFCC	=	JFSTOP+200;A ^C HAS BEEN TYPED

; ERROR MESSAGE HANDLING

FATAL	=	200	;FATAL BIT

.MACRO	ERROR	CODE,TYPE
.GLOBL	CODE
	 .WORD	TYPE+CODE+TRAP
.ENDM	ERROR

.MACRO	SETERR	CODE,DST
.GLOBL	CODE
.IF	NB	<DST>
	 MOV	#CODE,DST
.IFF
	 MOV	#CODE,IOSTS
.ENDC
.ENDM	SETERR

.MACRO	CHKERR	CODE,SRC
.GLOBL	CODE
.IF	NB	<SRC>
	 CMPB	#CODE,SRC
.IFF
	 CMPB	#CODE,IOSTS
.ENDC
.ENDM	CHKERR

; ERROR MODIFIERS

POST	=	TRAP		;POST AN ERROR

PSTFLT	=	2+JFSTOP	;FLOATING ERROR
PSTFIX	=	4+JFSTOP	;FIX ERROR
PSTDV0	=	6+JFSTOP	;DIVISION BY 0 ERROR

IOTERR	=	TRAP+1		;GET THE FIP ERROR

; USER AREA DEFINITIONS

R1SMIN	=	200		;R1 STACK MINIMUM

; RELATIVE TO SPDA (ALL <0)

ONECON	=		-10	;CONSTANT OF 1. (4 WORD)
PICON	=	ONECON	-10	;PI CONSTANT (4 WORD)
DET	=	PICON	-10	;DET FOR MAT INV (4 WORD)
ERRVAL	=	DET	-2	;ERR VALUE
CB1	=	ERRVAL	-2	;OUTER LOOP LIMIT
NV1	=	CB1	-2	;OUTER LOOP CONTROL VAR
CB2	=	NV1	-2	;INNER LOOP LIMIT
NV2	=	CB2	-2	;INNER LOOP CONTROL VAR
NV3	=	NV2	-2	;DOT LOOP CONTROL VAR IN MAT MUL
NVT	=	NV3	-2	;RESERVED DOUBLE LOOP TEMP
NVTM	=	NVT	-2	;FREE TEMP WORD
CB3	=	NVTM	-2	;DOT LOOP LIMIT IN MAT MUL
TEMF	=	CB3	-10+2	;TEMP OVER MATRIB & CB3 (4 WORD)
MATRIB	=	TEMF		;2ND MATRIX OPERAND ADDRESS
MATRIA	=	MATRIB	-2	;1ST MATRIX OPERAND ADDRESS
MATRIC	=	MATRIA	-2	;??
RECOUN	=	MATRIC	-2	;COUNT VALUE FOR GET
R1EXT	=	RECOUN	-2	;R1 STACK ??
CURLIN	=	R1EXT	-2	;CURRENT LINE NUMBER WHEN ^C
VALERR	=	CURLIN	-2	;ERROR LINE NUMBER
STATUS	=	VALERR	-2	;STATUS OF LAST 'OPEN'
LSTPDA	=	STATUS	;!!!!!!!!LAST MINUS SPDA ADDRESS

BASVEN	=	4.		;BASIC-PLUS COMPATIBILITY LEVEL

FAS	=	3		;STRING TYPE
FAI	=	2		;INTEGER TYPE
FAF	=	1		;FLOATING TYPE

; TOKENS CONSIST OF A BYTE OF FLAGS AND AN
; ADDRESS WORD - FLAG BITS AS BELOW

TOKF	=	200		;TOKEN FLAG - SIGN BIT
BASF	=	100		;BASIC VERB, FNCN, OROPR
DATAF	=	 40		;DATA - NUM OR STRING
FUNCF	=	 20		;FUNCTION FLAG - MUST BE 020
INDEXF	=	 10		;INDEXED FLAG - MUST BE 010
STRINF	=	  4		;STRING FLAG - MUST BE 004
FLOATF	=	  2		;FLOATING FLAG - MUST BE 002
INTGF	=	  1		;INTEGER FLAG - MUST BE 001

LINUM	=	TOKF			;TOKEN FOR LINE NUMBERS
DSTR	=	TOKF+STRINF+DATAF 	;TOKEN FOR DATA STRINGS
DFLT	=	TOKF+FLOATF+DATAF 	;TOKEN FOR FLOATING DATA
DINT	=	TOKF+INTGF+DATAF  	;TOKEN FOR INTEGER DATA
FLTINT	=	256.*DFLT+DINT
BASTOK	=	TOKF+BASF		;BASIC TOKEN USUALLY RETURNED FROM FIXED TABLE
BFI	=	BASTOK+FUNCF+INTGF	;TOKEN FOR INTEGER FUNCT
BFF	=	BASTOK+FUNCF+FLOATF	;TOKEN FOR FLOATING FUNCT
BFS	=	BASTOK+FUNCF+STRINF	;TOKEN FOR STRING FUNCT

VARFIF	=	BASF+DATAF+FUNCF+INDEXF+STRINF ;VALUE FOR TESTING NUMBER VARIABLES

; STAT IS A FLAG WORD FOR THE LEXICAL ANALYZER
; FLAG BITS ARE THOSE DESCRIBED BELOW : THE FIRST 8 BITS
; ARE OFTEN SET AND UNSET IN PARALLEL, THE OTHERS ONE
; AT A TIME

; PARALLEL BITS

BLINEF	=	     1		;BEG OF LOGICAL LINE
BSTATF	=	     2		;BEG OF STATEMENT
CTUNF	=	     4		;CHANGE - TO UNARY
QUOT1F	=	    10		;TURNED OFF BY CR
LINUMF	=	    20		;NEXT ITEM A POSSIBLE LINE NUMBER
ARF	=	    40		;MATRIX COMMAND ARRAY FLAG
HARF	=	   100		;TREAT NONSTRING VARIABLES AS ARRAY VARIABLES
COMF	=	   200		;COMMENT FLAG - MUST BE THE SIGN BIT

; SINGLE BITS

TABLEF	=	  1000		;VARIABLE NAME NOT IN SYMBOL TABLE
IMMEDF	=	  2000		;IMMEDIATE LOGICAL LINE
NUMBF	=	  4000		;SET WHEN NMSCAN SEES A NUMBER
OUTEXF	=	 10000		;SET WHEN OUTSIDE ARITH EXPR (TLCOMF)
CONVFF	=	 20000		;SET WHEN INTG TO FLTG CONV REQUIRED
QUOTF	=	100000		;COMPLEMENTED BY QUOTE OR APOSTROPHE - MUST BE SIGN

; CONSTANTS

SYMMAX	=	30.		;GREATEST SYMBOL LENGTH IN EXTEND MODE
SPACE	=	40		;ASCII SPACE
CR	=	15		;ASCII CARRIAGE RETURN
ASCLF	=	12		;ASCII LINE FEED
TAB	=	11		;ASCII TAB
ALT	=	33		;ASCII ALTMODE
CTRZ	=	32		;ASCII CONTROL/Z
BMIN	=	37		;DUMMY FOR BINARY MINUS
BUMCHR	=	36		;DUMMY FOR LINE FEEDS
ENDCHR	=	35		;END OF LINE SYMBOL IN LEX BUFFER
COM	=	'!		;COMMENT DELIMITER
QUOTE	=	'"		;QUOTE
APOS	=	''		;APOSTROPHE
SLOP	=	ARYLEN+SYMMAX+12 ;# FREE BYTES NEEDED IN VARIABLE TABLE FOR NEW
BLINS	=	BSTATF+BLINEF+LINUMF+CONVFF ;FLAGS SET AT BEG LINE
BLINC	=	HARF+ARF+COMF+QUOTF+CTUNF+IMMEDF ;FLAGS CLEARED AT BEG LINE
BSTAS	=	OUTEXF		;FLAGS SET AT BEG OF STATEMENT
BSTAC	=	BLINC+BLINEF+BSTATF ;FLAGS CLEARED AT BEG OF STATEMENT
;VARS	=	0		;FLAGS SET AFTER VARIABLE
VARC	=	LINUMF+CTUNF+QUOT1F ;FLAGS CLEARED AFTER VARIABLE
;LINS	=	0		;FLAGS SET AFTER LINE NUMBER
LINC	=	BLINEF+BSTATF+CTUNF ;FLAGS CLEARED AFTER LINE NUMBER
SIG	=	2		;SIGINICANT DIGIT FLAG IN ATOF
EXPN	=	10		;ATOF FLAG FOR HAVING SEEN E IN NUMBER
DOTF	=	20		;ATOF FLAG FOR HAVING SEEN . IN NUMBER

; SOME FROM THE EDITOR

BLKLEN	=1024.*2		;CORE BLOCK LENGTH 
LINLEN	=256.			;LINE BUFFER LENGTH, IN BYTES
TTYLEN	=90.			;TTY BUFFER LENGTH, IN BYTES

;EDITOR FLAG ASSIGNMENTS

EDGOFL	=     1			;LOAD AND GO
EDAPND	=     2			;APPEND THIS FILE TO CURRENT STUFF
EDNEWF	=     4			;NEW PROGRAM SO NEW .TMP FILE DUE
EDCOMP	=    10			;COMPILE INPUT FILE
EDFIRS	=    20			;1 = PRESENCE OF .TMP BEEN INVESTIGATED
EDETMP	=    40			;IF SO, THIS IS ANSWER:  1=IT EXISTS
EDEOFF	=   100			;END STATEMENT ENCOUNTERED
EDCONT	=   200			;IF CONTINUE ALLOWED
CKEBIT	=   400			;CHECKPASS ERROR --INHIBIT RUN-ING
CKDEFB	=  1000			;DEF SO FAR WITHOUT ENDDEF -- CKPASS
EDPRES	=  2000			;VARIABLES HAVE BEEN ZEROED
EDXTND	=  4000			;USE EXTENDED-LENGTH VARIABLES
EDIMED	= 10000			;RTS RUNNING IN IMMEDIATE MODE FOR JOB
EDDXTN	= 20000			;DEFAULT IS EXTENDED-LENGTH VARIABLES
TRNKER	= 40000			;TEXT SET IN TAG BEFORE ERROR CALL
REEROR	=100000			;REENTERED ERROR PROCESSOR

;EDITOR CHANNEL ASSIGNMENTS

BASCHN	=14.*2			;CHANNEL 14 (*2)
BASCH	=14.			;VERSION FOR RTS
BACCHN	=15.*2			;CHANNEL FOR .BAC FILE WORK
BACCH	=15.			;VERSION FOR SSO
TMPCHN	=13.*2			;CHANNEL 13 (*2)
TMPCH	=13.			;FOR .TMP FILE WORK


; STATIC VIRTUAL ADDRESS AREA (FIRST 256. WORDS)

.DSECT

USRORG:			;BASE OF USER'S IMAGE
FSSFLG:	.BLKW		;FLAGS BACK FROM .FSS
CONCNT:	.BLKW		;CONTINUATION LINE COUNTER
	.BLKW	4	;UNUSED...
SFIRQB:	.BLKB	FQBSIZ	;SAVED FIRQB FROM RUNS/OPENS
DEBLIN:	.BLKW		;PREVIOUS LINE NUMBER FOR 'BREAK' (DEBUGGER)
BREKFL:	.BLKW		;BREAK FLAG (FOR DEBUGGER)
	.BLKW	45	;MONITOR'S CONTEXT REGION
BRKTBL:	.BLKW	12	;10. WORD BREAK POINT (LINE NUMBER) TABLE
BRKEND:	.BLKW		;FLAG TO CHECK STACK OVERFLOW
	.BLKW	70	;USER'S SP STACK AREA
USRSP:			;INITIAL USER SP STACK VALUE
JOBF:			;KEYWORD AREA
KEY:	.BLKW		;JOBS STATUS
IOSTS:			;I/O STATUS RETURNED ERROR CODE
FIRQB:	.BLKB	FQBSIZ	;FILE REQUEST BLOCK
XRB:	.BLKB	XRBSIZ	;IO CONTROL PARAMETERS
CORCMN:	.BLKB	200	;CORE COMMON STRING (LEN+UP TO 127. BYTES)
EDFLAG:	.BLKW		;EDITOR BIT FLAG WORD
RUNLVL:	.BLKW		;RUNNING LEVEL (0=ERRORS;1=ED;2=RTS)
;*** FOLLOWING 15. WORDS (R5RING TO OASL) ARE THE CSR'S
;*** SAVED IN .BAC FILES AND MUST APPEAR TOGETHER AND IN ORDER
R5RING:	.BLKW		;SAVE SPOT FOR R5 (IPC)
R1RING:	.BLKW		;SAVE SPOT FOR R1 (POLISH STACK)
SCTH:	.BLKW		;POINTER TO CURRENT TEXT HEADER
SPTA:	.BLKW		;POINTER TO BASE OF TEXT AREA
SPDA:	.BLKW		;POINTER TO BASE OF DATA AREA
R1CORG:	.BLKW		;R1 STACK ORIGIN (BASE)
;*** FOLLOWING 3 GROUPS OF 3 ARE ORDERED
COSI:	.BLKW		;CODE STACK INITIAL VALUE
COSP:	.BLKW		; "    "    CURRENT POINTER
COSL:	.BLKW		; "    "    LIMIT
OPSI:	.BLKW		;OPERATOR STACK INITIAL VALUE
OPSP:	.BLKW		; "        "    CURRENT POINTER
OPSL:	.BLKW		; "        "    LIMIT
OASI:	.BLKW		;OPERAND STACK INITIAL VALUE
OASP:	.BLKW		; "       "    CURRENT POINTER
OASL:	.BLKW		; "       "    LIMIT
SCAFAC:	.BLKW		;SCALING POINTER
SCAVAL:	.BLKB		;SCALING VALUE
SCAUPV:	.BLKB		;USER PROGRAM SCALING VALUE
R1CONT:	.BLKW		;R1 STACK SAVED FOR "CONT"
XXMORE:	.BLKB		;MORE TO COME TOKEN SPOT
XCDCHN:	.BLKB		;CHANNEL TO CLOSE ON MAX CORE EXCEEDED
$.PLCS:	.BLKB	2	;# OF DIGITS TO PRINT/CONVERT IN PRINT/NUM$
USRPPN:	.BLKW		;USER'S ASSIGNED PPN
USRPRT:	.BLKW		;USER'S ASSIGNED PROTECTION CODE
USRLOG:	.BLKW	4*4	;USER'S LOGICAL DEVICE TABLE
NSTORG:			;START OF NON-STATIC AREA

JOB	=	FIRQB+FQJOB;JOB NUMBER LOCATION

; RELATIVE TO PTA

.MACRO	$PTA	X,Y
X	=	TMPTAG
.LIST
	X	=	X
.NLIST
TMPTAG	=	TMPTAG+2
.ENDM

TMPTAG	=	4

$PTA	BADBYT,	PPBADC*256.!PPBADC	;POP FOR BAD STMT (IN MINSTA)
$PTA	PROPTR,	ENDPTA-BEGPTA		;PLUDYN
$PTA	TAGPTR,	-TAGLEN			;LAST USED WORD IN STATEMENT HEADER AREA
$PTA	PROLIM,	CAILEN-TGSORG		;PLULIM
$PTA	TAGLIM,	-TAGSIZ			;LIMIT OF STATEMENT HEADER AREA

; RELATIVE TO PDA

.MACRO	$PDA	X,Y
X	=	TMPTAG
.LIST
	X	=	X
.NLIST
TMPTAG	=	TMPTAG+2
.ENDM

.MACRO	$PDAB	X,Y
X	=	TMPTAG
.LIST
	X	=	X
.NLIST
TMPTAG	=	TMPTAG+1
.ENDM

TMPTAG	=	0

$PDA	PDA,	DUMSTR			;POINTER TO LAST AND DUMMY STRING
;CORE ALLOCATION PARAMETERS
$PDA	PSD,	ENDSTT-BEGPDA
$PDA	STAT,	+BLINEF			;LEX ANALYZER STATUS FLAGS
$PDA	NEXSTR,	ENDSTT-BEGPDA		;NEXT AVAILABLE WORD IN THE STRING AREA
	PDD	=	NEXSTR
$PDA	NEXFRE,	BEGHDR-BEGPDA		;POINTS TO LAST CELL USED IN STRING HEADER AREA
	MDD	=	NEXFRE
$PDA	STRLIM,	TGSORG-TAGSIZ-PDAORG	;STRING LIMIT -- LEAVE ROOM FOR A FEW TAGS
	PLD	=	STRLIM
$PDA	SPCLIM,	R1SORG-PDAORG		;STRING HEADER LIMIT WITH 24 WORDS SLOP
	MLD	=	SPCLIM
$PDA	ARYPTR,	BASE			;FIRST I/O ARRAY HEADER ITEM
;DO NOT DISTURB CELL ORDER BACK TO BEGPDA
$PDA	EDDUMM,	+0			;STRING FOR NONAME.BAS
	TMPTAG=TMPTAG+12
;PERMANENT VARIABLE AREA--------------------------------------------
;CORE ALLOCATOR VARIABLES-GO IN PDA
;"NOMINALS" ARE FREE SPACE AMOUNTS GUARANTEED BY CA
$PDA	R1SNOM,	+200			;NOMINAL FOR R1 STACK
$PDA	TAGNOM,	+626.			;NOMINAL FOR STATEMENT HEADERS
$PDA	PRONOM,	+564.			;NOMINAL FOR STATEMENT-PUSH POP
$PDA	HDRNOM,	+342.			;NOMINAL FOR STRING HEADERS
$PDA	STRNOW,	+0			;MODIFIED BY CA
$PDA	STRNOM,	+1000			;NOMINAL FOR STRINGS
;DO NOT DISTURB CELL ORDER BACK TO R1SNOM
$PDA	SUMNOM,	+0			;SUM OF ALL NOMINALS
$PDA	NSTRNM,	+0			;SUM OF ALL BUT STRING
$PDA	BASE,	.=.			;LENGTH OF BASE AREA
	TMPTAG=TMPTAG-2
	TMPTAG=TMPTAG+14
$PDA	TLMIND,	BEGHDR-BEGPDA		;OLD VALUE OF STR HDR PTR, RESTRD AFTER ERROR
$PDA	RNDML,	RANDYL			;RANDOM STORAGE (LSB)
	TMPTAG=16.*20+TMPTAG-10
$PDA	RNDMH,	RANDYH			;RANDOM STORAGE (MSB)
	TMPTAG=TMPTAG+2
$PDA	OEGTLN,	0		;ON ERROR GOTO LINE NUMBER
$PDA	WAITTM,	0		;WAIT TIME FOR TTY I/O
;THE ABOVE 2 WORDS GO IN UNUSED WORDS IN SLOT 15.
;REST OF STUFF IS SUPOSSED TO BE 0 AND IS NOT MOVED INTO USER AREA BY CATSUP
$PDA	RESLOC,	+0		;SAVE SCTH FOR ERRORS
$PDA	CURRIO,	0			;CURRENT IO POINTER
$PDA	DATHDR,	0			;DATA STATEMENT HEADER
$PDA	DATCNT,	0			;DATA STATEMENT RESIDUAL COUNT
$PDA	DATPTR,	0			;DATA STATEMENT POINTER
	CNTBAS=DATCNT-BASE
	PTRBAS=DATPTR-BASE
$PDA	INTPPF,	+0		;BACKUP LOC FOR INTERNAL PP POINTER
$PDA	NEXDRO,	+0		;DROP THRU "NEXT" STATEMENT IF RPTERM FLAG ON
$PDA	RPTERM,	+0		;TREAT "NEXT" STATEMENT AS TERMINAL
$PDA	MATBLK,	+0		;USED BY SOME OF THE STRING PUSHPOPS
	TMPTAG=TMPTAG+4
$PDA	GOSUB,	+0	;GO SUB COUNTER FOR STACK UNDERFLOW
$PDA	DUMSTR,	0	;A DUMMY STRING AND NULL AT THAT
	TMPTAG=TMPTAG+4
$PDA	STACK,	0	;STACK SAVE LOCATION
$PDA	PHLB,	.=.	;LEXICAL BUFFER
$PDA	LINBUF,	0	;AS REF'D BY RC
	TMPTAG=TMPTAG+LINLEN-2
$PDA	TTYBUF,	0	;TTY OUT BUFFER
	TMPTAG=TMPTAG+TTYLEN-2
;BASGET AND BASPUT VARIABLES----------------------------------
$PDA	BASBUF,	.=.+1000		;TMP FILE BUFFER
	TMPTAG=TMPTAG+1000-2
;BEGINNING OF TR VARIABLES
$PDA	DISPOS,	.=.			;REST ARE USED ONLY BY COMPILER
	TMPTAG=TMPTAG-2
$PDAB	BASCUM,	+0			;MSB OF BASCUR
$PDAB	BASBEM,	+0			;MSB OF BASBEG
$PDA	BASCUR,	+0			;NEXT ADDRESS TO BE WRITTEN IN TMP FILE
$PDA	GETAGV,	+0			;ANSWER CELL FOR GETAG SUBRS
$PDA	VARTAB,	+0		;A THRU Z
	TMPTAG=25.*2+TMPTAG
;SMALL DATA ITEMS
$PDA	CLB,	+0		;CURRENT BEG LEX BUF
$PDA	TOKE,	+0		;TOKEN (LOWER BYTE ONLY)
$PDA	TOKA,	+0		;ADDRESS PORTION OF TOKEN
$PDA	UNQUOT,	+0		;HOLDS UNQUOTE CHAR TO CLR QUOTF
$PDA	CFLG,	+0		;FLAG WORD FOR MODIFIER ROUTINES
;TL DATA (IN USER SWAP AREA)
$PDA	TLPCOU,	+0	;PARENTHESIS DEPTH COUNTER
$PDA	TLFNBK,	+0	;TEMP. LOC. FOR FUNCTION BLOCK - DODEF
$PDA	TLFNAT,	+0	;PICTURE WORD ACC. -DODEF
$PDA	PRPMOD,	+0	;TEMP. LOC. FOR SAVED PMODE  VALUE
$PDA	TLBIFF,	+0	;BUILT-IN (1) VS USER-DEF (0) FCN FLAG
$PDA	PTOKA,	+0	;WORD PART OF PREV.TOKEN INF.
$PDA	TLLINO,	+0	;LINE NO. OF CURR. STAT.
$PDA	CPREC,	+0	;CURR. PREC. VALUE
$PDA	PRPREC,	+0	;PREV. PREC. VALUE
$PDA	PMODE,	+0	; CURRENT PMODE VALUE
$PDA	NARGS,	+0	;NO. OF ARGS. IN FCN. CALL OR INDEXED VAR.
$PDA	TLCTTW,	+0	;COMF. WORD TEMP.
$PDA	TLTOPC,	+0	;"PROG.CTR." FOR GEN. CODE
$PDA	TLSTPC,	+0	;"PROG. COUNTER" FOR GEN. CODE,CURR. BLOCK
$PDA	TLTYCT,	+0	;TYPE (0,1, OR 2) OF CURR. FCN. NAME
$PDA	TLCOMR,	+0	;TYPE OF TLCOMF RESULT(0=FLOAT,1=FIX,2=STRING)
$PDA	TLOPRP,	+0	;OPERATOR STACK REL PTR
$PDA	TLOARP,	+0		;ADDR OF LINK IN FIRSP HEADER
$PDA	BASBEG,	+0	;INITIAL TEXT POINTER FOR STATEMENT HEADER
$PDA	TLGCOP,	+0	;GENC TEMP.
$PDAB	SAINTF,	+0	;FLAG BYTE USED BY SAINT FLAG OPS
$PDAB	MATCH,	+0	;MATCH FLAG FOR SYNTAX INTERPRETER
$PDAB	TLOPRF,	+0	;FLAG OPERAND -- QUIT ON 2ND IN ROW
$PDAB	PTOKE,	+0	;FLAG BYTE OF PREV. TOKEN INF.
$PDAB	TLFNAF,	+0	;COMF FLAG******TLFNAF,TLOPTF MUST BE ONE WORD*****
$PDAB	TLOPTF,	+0	;FLAG FOR TWO OPERATORS IN A ROW
$PDAB	PTOKF,	+0	;PREV. TOKEN FLAG
$PDAB	TLCOFL,	+0	;CONDIT. EXPRESSION FLAG
$PDAB	TLLSFL,	+0	;"LEFT-SIDE" FLAG IN DOLET
$PDAB	TLFNAR,	+0	;NUMBER OF ARGS FOR FUNCTION
$PDAB	TLINFL,	+0	;FLAG - TOP-LEVEL=0, INSIDE=1
$PDAB	TLENBY,	+0	;CONTAINS "NEXTS" OR "HALT" OPERATOR
LOAS=200.		;LENGTH OF OPERAND STACK
LOPS=50.		;LENGTH OF OPERATOR STACK
LCOS=300.		;LENGTH OF CODE STACK
	TMPTAG=TMPTAG+LOAS
$PDA	OASB,		;OPERAND STACK
	TMPTAG=TMPTAG+LOPS-2
$PDAB	OPSB,		;OPERATOR STACK
	TMPTAG=TMPTAG+LCOS
$PDAB	COSB,		;CODE STACK
$PDA	PDAEND,	.=.			;SYMBOL FOR END
;END VARIABLES BELONGING IN SWAP AREA-------------------------------

;	STRING HEADER DEFINITIONS
LINK	=	 0	;LINK TO NEXT HEADER (REL .)
PNTR	=	 2	;POINTS TO DATA (REL .-2)
LENGTH	=	 4	;LENGTH OF DATA (IN BYTES)

;	IO BLOCK DEFINITIONS

;LINK	=	 0	;
;PNTR	=	 2	; AS IN STRINGS
;LENGTH	=	 4	;
BYTCNT	=	 6	;# OF BYTES REMAINING IN BUFFER
CURLOC	=	10	;CURRENT BUFFER POSITION
SLOT	=	12	;IO CHANNEL FOR THIS HEADER
FLAGS	=	13	;STATUS AND DEVICE PROPERTIES BYTE
POSITN	=	14	;NUMBER OF CHARS OUTPUT SINCE LAST <CR>
CURBKM	=	15	;RNDM ACCS DEVICE: BLK (MSB) AT BEGINNING OF BUF
CURBLK	=	16	;RNDM ACCS DEVICE: BLK AT BEGINNING OF BUF

;	IOB FLAGS BITS DEFINITIONS

;FLGRND/400=	200	;RANDOM ACCESS DEVICE
WRTARY	=	100	;BIT TO SHOW RE-WRITE OF THE BUFFER NEEDED
FORCE	=	 FLGFRC/400	;FORCE BIT FOR USER I/O BUFFER HEADER FLAGS BYTE
ARYIOB	=	 20	;BIT TO SHOW HEADER IS FOR IO AND NOT ARRAY
;FLGPOS/400=	 10	;MONITOR KEEPS CURRENT LINE POSITION

;	ARRAY HEADER DEFINITIONS
;LINK	=	 0	;
;PNTR	=	 2	; AS IN STRINGS
;LENGTH	=	 4	;
DIM1	=	 6	;CURRENT FIRST DIMENSION
DIM2	=	10	;CURRENT SECOND DIM
ARYSLT	=	12	;SLOT # IF VIRTUAL ARRAY
ARYFLG	=	FLAGS	;ARRAY/BUFFER CONTROL FLAGS
ARYLIM	=	14
MAXSTR	=	24	;MAXIMUM STRING LENGTH FOR VIRTUAL STRING ARRAY
PDIM1	=	26	;PERMANENT DIM 1--RESET ON RUN,ETC.
PDIM2	=	30	;PERMANENT DIM 2--DITTO

;	ARRAY FLAG BIT DEFINITIONS
DSKARY	=	200	;BIT TO SHOW DISK RESIDENCE
;ARYIOB	=	 20	;0 FOR ARRAY HEADER
DIMARY	=	 10	;BIT TO SHOW ARRAY DIMENSIONED
REFARY	=	  4	;BIT TO SHOW ARRAY REFERENCED
STRARY	=	  2	;BIT TO SHOW A ARRAY OF STRINGS
FIXARY	=	  1	;BIT TO SHOW A FIXED ARRAY

;	STATEMENT HEADER DEFINITIONS
;LINK	=	 0	;
;PNTR	=	 2	; AS IN STRINGS
;LENGTH	=	 4	;
TAGPUS	= 2			;POINTER TO PUSHPOP CODE
TAGPUL	= 4			;LENGTH OF PUSHPOP
TAGTXT	= 6			;POINTER TO TEXT IN .TMP
TAGTXL	=10			;LENGTH OF TEXT
TAGTYP	=11			;ONE BYTE TYPE CODE, FOR ASSIGNMENTS, SEE DLTONE
TAGBIN	=12			;STATEMENT NUMBER IN BINARY


IOLEN	=	20	;THE LENGTH OF AN I/O BUFFER HEADER
ARYLEN	=	32	;THE LENGTH OF AN ARRAY HEADER
TAGLEN	=14			;BYTES PER TAG
STRLEN	=	 6	;THE LENGTH OF A BASIC STRING

; STARTING RANDOM NUMBER VALUE

RANDYL	=	15073		;AS RANDOM AS ANY!
RANDYH	=	0		;???
.IIF	NDF	L$$IST,	.LIST

