TITLE	PU,<PRINT USING>,08,13-MAY-86,MHB/TPH/LD/EV

;                   Copyright 1974,1990 by Digital Equipment Corporation
;                                  All rights reserved.
;
;          This software is furnished under a license and may be used and copied
;          only  in  accordance  with  the  terms  of  such license and with the
;          inclusion of the above copyright notice.  This software or any copies
;          shall not be provided to any other person.   No title to or ownership
;          of the software is hereby transferred.
;
;          The information in this software is subject to change without notice.
;
;          DIGITAL  assumes  no  responsibility  for the  use, functionality, or
;          reliability of its  software  on equipment  which  is not supplied by
;          DIGITAL.
;
;	MODIFICATIONS:
;
;*B* 19-NOV-80 BY VOGEL: FIX PRINT USING SO TRAILING COMMAS WORK

	..	PPRNUF,PRINUF
	..	PPRNUI,PRINUI
	..	PPRNUS,PRINUS
	..	PPRNUE,PRINUE

	ORG	PO,0		;OVERLAY MA
	.WORD	PRINU9
	.WORD	PRINU8

	DEFORG	PX		;PRINT CONTROL
..PUCH	==	.	;**PATCH** PRINT-USING SPECIAL CHARACTERS
FLTCHR:	.WORD	'$		;FLOATING CHARACTER
DOTCHR:	.WORD	'.		;DECIMAL POINT CHARACTER
CMACHR:	.WORD	',		;COMMA INSERTION CHARACTER

	DEFORG	PU

	.if eq 0	;Originally .if df HELLO	WJS 90.1.31
	.GLOBL	SAINT					;(TR)
	.endc	;eq 0					WJS 90.1.31
	.GLOBL	FLT					;(MA)
	.GLOBL	PSTJS					;(RC)
	.GLOBL	CRLF,PRINU3,PRINTL,PRNFL1,PRNFL2	;(PN)
	.GLOBL	PRNFL3,PRNF05,PRNF15
	.GLOBL	PRNBUF,PRINU2,PRNBUC,PNTUXP

	.if eq 0	;Originally .if df HELLO	WJS 90.1.31
; PRINT USING VERB COMPILING

PU:	JSR	R5,SAINT	;ENTER INTERPRETER
	RCS			;GET THE 'USING' STRING
	CB	PPFIX0		;AND SIGNAL IT
1$:	NTJ	COMMA,2$	;*A**B*COMMA?
	R			;*B* SKIP COMMAS
	EJ	5$		;*B*OUT IF DONE
2$:	NEJ	4$		;IF NOT END JUMP
3$:	CB	PPRNUE		;END PRINT USING
	CB	PPCRLF		;AND CR/LF
	QUIT

4$:	CA			;COMPILE ANYTHING
	COPR	9$		;AND SET IT
	EJ	3$		;IF END, THEN QUIT
	NTJ	SEMICO,1$	;IF NO ; THEN TRY FOR ,
	RNEJ	4$		;IF NOT END, THEN COMPILE
5$:	CB	PPRNUE		;ELSE END IT
	QUIT

9$:	.BYTE	PPRNUF,PPRNUI,PPRNUS
	.EVEN
	.endc	;eq 0					WJS 90.1.31

; FOR DISPATCHES FROM THE MATH PACKAGE

PRINU8:	TST	2(SP)		;SHOULD WE GO BACK TO MATH PACKAGE?
	BNE	2$		;IF FLAG NON-0 THEN YES (RTS PC)
	CMP	(SP)+,#PRNF15	;WHICH CALL WAS THIS?
	BNE	3$		;CALL FOR RETURN TO "PRNU15"
	CMPB	(R3)+,#'0	;LEADING 0?
	BNE	1$		;NOPE
	CMPB	(R3)+,#'0	;ANOTHER 0?
	BNE	1$		;NOPE
	JMP	PRNF05		;IF SO, THE MA HANDLES IT NOW

1$:	DEC	R3		;CORRECT R3 POINTER
	MOV	#PRNU40,(SP)	;SET A RETURN ADDRESS
2$:	RTS	PC		;AND GO TO IT

3$:	MOV	#PRNU15,(SP)	;SET RETURN ADDRESS
	RTS	PC		;AND GO

PRCOUN	=	 16			;COUNT!!!!!!!
PRMSKP	=	  1			;DECIMAL
PRMSKE	=	  2			;EXPONENT
PRMSKA	=	  4			;ASTERISK FILL
PRMSKC	=	 10			;COMMA
PRMSKM	=	 20			;TRAILING MINUS
PRMSKD	=	 40			;FLOATING DOLLAR
PRULPF	=	100			;LOOP PREVENTION BIT
				;SP WILL BE USED FOR CHARACTER
				;COUNTER (SP), A FLAG TO INDICATE
PRINUS:	CLR	-(SP)		;LAST PASS 2(SP), AND A FLAG
	CLR	-(R1)		;ONE MORE ITEM TO MAKE 4...
	BR	PRUF1		;TO INDICATE NUMBER OR STRING 2(SP)

PRINUI:	JSR	PC,FLT
PRINUF:	MOV	#1000,-(SP)	;NUMBER FLAG ON, LAST PASS OFF
	JSR	PC,PRINU2	;"DUPLF" FOR 2-WORD OR NOP FOR 4-WORD
PRUF1:	CLR	-(R1)
	CLR	-(R1)		;# DIGITS TO RIGHT OF DEC. PT.
	CLR	-(R1)		;FLAG WORD FOR FLOATING, INT $ ETC.
	CLR	-(SP)		;CHARACTER CTR=0
	BR	PRST1

PRINUE:	MOV	#1,-(SP)	;LAST PASS FLAG ON
	CLR	-(SP)		;CHAR CTR.
	SUB	#PRCOUN+2,R1	;CORRECT R1 DEPTH FOR PRGETC
PRST:	TST	(R1)+
PRST1:	JSR	PC,PRGETC
PRST2:	CMPB	#'!,(R1)	;CHECK FOR ONE CHAR
	BEQ	PRCH1		;PRINT ONE CHAR FROM STRING
	CMPB	#'\,(R1)
	BNE	PRNY		;CHECK FOR # VARIABLE
PRCH2:	INC	(SP)		;INCREMENT CHAR CTR
	JSR	PC,PRGETB	;GET NEXT CHAR FROM USING STRING
	CMPB	#'\,(R1)
	BEQ	PRCH1		;PRINT (SP)+1 CHARACTERS OF STRING
	CMPB	#40,(R1)
	BEQ	PRCH2
	CALLX	PRINTX,R3,<'\>	;PRINT \
	JSR	PC,PRSPAC	;PRINT SPACES
	BR	PRST2		;CONTINUE TESTING CHARACTER

PRERR:	ERROR	PRERRS,FATAL	;WRONG TYPE VARIABLE ON USING STRING

PRCH1:	TSTB	2(SP)
	BNE	PRFINN		;FINAL PASS
	TSTB	3(SP)
	BNE	PRERR		;CHECK VARIABLE TYPE
	INC	(SP)		;CORRECT CHARACTER COUNT
	CLR	(R1)		;REMOVE LAST CHAR. & USE R1
PRCH5:	CMP	(R1),PRCOUN(R1)	;CURR POS VS LENGTH OF STRING
	BLO	PRCH6		;STILL STRING LEFT
	INC	(SP)		;OTHERWISE FILL OUT
	JSR	PC,PRSPAC	;WITH SPACES
	BR	PRCH4

PRCH6:	MOV	R1,R2		;TO POINT TO STRING
	ADD	#PRCOUN-4,R2	;LINK
	ADD	PRCOUN-2(R1),R2	;RELATIVE PTR
	ADD	(R1),R2		;PLACE IN STRING
	INC	(R1)		;STEP POINTER TO NEXT OUTPUT BYTE
	MOVB	(R2),R2
	CALLX	PRINTC,R3
	DEC	(SP)
	BNE	PRCH5		;LOOP ON NUMBER TO PRINT
PRCH4:	ADD	#PRCOUN-4,R1	;REMOVE ALL BUT STRING JUST PRINTED
	JMP	PRFIN2		;POP IT TO J-SPACE, AND RETURN

PRNY:	CMPB	(R1),FLTCHR
	BEQ	PRNY1
	CMPB	(R1),#'*
	BEQ	PRNY2
	CMPB	(R1),#'#
	BEQ	PRNY3
	CMPB	(R1),DOTCHR
	BEQ	PRNY3B		;IF LEADING DEC. PT.
	CMPB	(R1),#15
	BEQ	PRNYE		;CHAR IS CR, SEE IF 2(SP) ON
PRNYZ:	MOV	(R1)+,R2
	CALLX	PRINTC,R3	;PRINT ANY OTHER CHARACTER
	BR	PRST1

PRNYE:	TSTB	2(SP)
PRFINN:	BNE	PRNY3C		;FINAL PASS
	BIT	#PRULPF,2(R1)	;SEE IF WE'VE BEEN HERE BEFORE
				;IF SO, NO #'S ETC. IN USING STRING
	BNE	PRERR		;BACK WITH NO PROGRESS MADE
	BIS	#PRULPF,2(R1)	;AND DON'T COME BACK
	JSR	PC,CRLF		;ELSE PRINT CRLF & CONTINUE
	BR	PRST

PRNY1:	JSR	PC,PRGETB	;IF NEXT CHAR IS $, SET
	CMPB	(R1),FLTCHR	;FLOATING $
	BEQ	PRNY1A
	MOVB	FLTCHR,R2
PRNY4:	CALLX	PRINTC,R3
	BR	PRST2

PRNY1A:	BIS	#PRMSKD,2(R1)	;SET BIT FOR FLOAT $
PRNY1B:	INC	4(R1)		;INC LEFT COUNT
PRNY3:	INC	4(R1)		;INCREMENT LEFT CTR.
PRNY3A:	TSTB	2(SP)
PRNY3C:	BNE	PRFIN		;LAST PASS
	TSTB	3(SP)
	BEQ	PRERR		;WRONG VARIABLE TYPE
	BR	PRNY5

PRNY2:	JSR	PC,PRGETB
	CMPB	(R1),#'*
	BEQ	PRNY2A		;* FILL
	MOVB	#'*,R2
	BR	PRNY4

PRNY3B:	JSR	PC,PRGETB	;CHECK NEXT STRING CHARACTER
	CMPB	(R1),#'#	;SEE IF #
	BEQ	1$		;BRANCH IF YES
	MOVB	DOTCHR,R2	;NO, SO MOVE . TO R2
	BR	PRNY4		;BRANCH TO PRINT IT

1$:	BIS	#PRMSKP,2(R1)	;SET DEC. PT. SEEN FLAG
	INC	6(R1)		;INCR RIGHT AFTER DEC. PT.
	BR	PRNY3A		;BRANCH TO CHECK FLAGS

PRNY2A:	BIS	#PRMSKA,2(R1)	;SET * FILL BIT
	BR	PRNY1B

PRNY5A:	BIT	2(R1),#PRMSKP
	BEQ	PRNY8
	INC	6(R1)		;INC RIGHT AFTER DEC. PT.
PRNY5:	JSR	PC,PRGETB
	CMPB	(R1),#'#
	BEQ	PRNY5A
	CMPB	(R1),CMACHR
	BEQ	PRNY5B
	CMPB	(R1),DOTCHR
	BEQ	PRNY5C
	CMPB	(R1),#'-
	BEQ	PRNY5D
	CMPB	(R1),#PNTUXP
	BEQ	PRNY5E
PRNY6:	JSR	PC,PRMOVQ	;MOVE USING PTR BACK 1
	TST	4(R1)		;CHECK FOR 0
	BNE	PRNY6A
	TST	6(R1)
	BEQ	PRNYZ		;AND IT IS TOO
PRNY6A:	TST	(R1)+
	JSR	PC,PRNU		;PRINT NUMBER
	BR	PRFIN1		;POP PC & EXIT.

PRNY5B:	BIT	2(R1),#PRMSKP	;IF NO DEC. PT. SET
	BNE	PRNY6		;COMMA BIT.  IF YES,
	BIS	#PRMSKC,2(R1)	;PRINT NUMBER
PRNY8:	INC	4(R1)		;INC LEFT BEFORE DEC. PT.
	BR	PRNY5

PRNY5C:	BIT	2(R1),#PRMSKP	;IF NO DEC. PT. SET
	BNE	PRNY6		;DEC. PT. BIT.  IF YES,
	BIS	#PRMSKP,2(R1)	;TERMINATE
	BR	PRNY5

PRNY5D:	BIS	#PRMSKM,2(R1)	;SET TRAILING MINUS
PRNY9:	JSR	PC,PRGETB	;ADJUST STRING PT.
	BR	PRNY6

PRNY5E:	BIT	#PRMSKD!PRMSKA,2(R1)	;NO EXP W/FLOATING $
	BNE	PRNY6		;OR * FILL
	JSR	PC,PREXPP
	TST	(R1)
	BEQ	PRNY6		;WASN'T EXP.
	BIS	#PRMSKE,2(R1)
	BR	PRNY9		;SET EXP. BIT.

PRFIN:	ADD	#PRCOUN+4,R1	;POP DUMMIES FROM R1
PRFIN2:	JSR	PC,PSTJS	;REMOVE STRING
PRFIN1:	CMP	(SP)+,(SP)+	;AND TERMINATE
PRSE:	RTS	PC

PRSPAC:	DEC	2(SP)		;PRINT 2(SP)-1 SPACES
	BEQ	PRSE
	CALLX	PRINTX,R3,<40>
	BR	PRSPAC

PRGETB:	TST	(R1)+		;POP R1 FIRST
PRGETC:	MOV	R1,R2		;GET ONE CHAR FROM USING STRING
	ADD	#PRCOUN,R2	;MAKE A POINTER TO THE COUNT
	MOV	(R2)+,R3	;PICK IT UP
	ADD	R2,R3		;MAKING A POINTER TO THE STRING
	TST	(R2)+		;NOW POINT TO THE POINTER
	ADD	(R2)+,R3	;NOW ABS PTR TO STRING
	MOV	#15,-(R1)	;IN CASE AT END
	TST	(R2)		;MAKE SURE THERE IS SOME USING STRING
	BNE	PRGET1		;OK
	ERROR	PRERRS,FATAL	;PRINT USING WITH NULL USING STRING

PRGET1:	CMP	(R2),-6(R2)	;END?
	BEQ	PRREST		;YES
	MOVB	(R3),(R1)	;NO, SO PICK UP CHAR FROM USING STR
	INC	-6(R2)		;POINT TO NEXT ONE
	RTS	PC

PRREST:	CLR	2+PRCOUN(R1)	;RESET THE COUNT
	RTS	PC

PREXPP:	CLR	-(SP)		;ONE ^ SEEN SO FAR
PREXP3:	JSR	PC,PRGETB	;TRY FOR 3 MORE
	INC	(SP)		;TALLY ONE MORE ^
	CMP	#'^,(R1)	;IS THIS ONE?
	BEQ	PREXP1		;YEP
PREXP2:	JSR	PC,PRMOVQ	;NO, DIDN'T GET 4, SO NOT EXP FORMAT
	DEC	(SP)		;BACK OVER THEM, 0 VALUE SIGS NOT EXP
	BNE	PREXP2
	BR	PREXP4

PREXP1:	CMP	(SP),#3		;ENOUGH?
	BNE	PREXP3		;NOPE
PREXP4:	MOV	(SP)+,(R1)	;RETURN COUNT
	RTS	PC

PRMOVQ:	MOV	R1,R2		;COPY FOR MAKING POINTER
	ADD	#PRCOUN+2,R2	;POINT TO COUNT
	TST	(R2)		;IF ZERO, MUST GO TO END
	BNE	PRMOV1		;IF NON-ZERO
	MOV	6(R2),(R2)	;OTHERWISE SET TO LENGTH
	RTS	PC

PRMOV1:	DEC	(R2)		;LESS ONE
	RTS	PC

;USING PART OF SETUP FROM REGULAR PRINT PROGRAM
PRNU:	MOV	(R1)+,-(SP)		;MOVE CODE BITS TO SYSTEM STACK
	CMP	(R1),#PRNBUF		;SEE IF TOO MANY LEFT FORMAT CHAR
	BGT	1$			;YES, GIVE ERROR AND QUIT
	MOV	(R1)+,-(SP)		;MOVE LEFT FORMAT CHARS TO SYSTEM STACK
	MOV	(R1)+,-(SP)		;MOVE RIGHT FORMAT CHARS TO SYSTEM STACK
	CLR	-(SP)			;MOVE FLAG ONTO SYSTEM STACK
	JMP	PRINU3			;JUMP INTO REGULAR PRINT PROGRAM

1$:	ERROR	PRNER2,FATAL		;BUFFER OVERFLOW

PRINU9:	TST	2(SP)			;SHOULD WE GO BACK
	BEQ	PRNU01			;NO, STAY HERE
	JMP	PRNFL3			;YES, RETURN

PRNU01:	MOVB	PRNBUF-3(R2),2(SP)	;SAVE SIGN OF NUMBER ON SYSTEM STACK
	MOV	R1,-(SP)		;SAVE R1 POINTER ON SYSTEM STACK
;CHECK FOR NUMBER OUT OF RANGE
	BIT	#PRMSKD,12(SP)		;CHECK $ BIT
	BNE	PRNU18			;IF SET, GO TO DECREMENT
	BIT	#PRMSKM!PRMSKA,12(SP)	;CHECK * AND TERMINAL - BIT
	BNE	PRNU17			;IF SET, DON'T DECREMENT FORMAT COUNT
	TSTB	4(SP)			;TEST SIGN OF NUMBER
	BEQ	PRNU17			;IF POSITIVE, DON'T DECREMENT FORMAT COUNT
PRNU18:	DEC	10(SP)			;SUBTRACT OFF NON-DIGIT CHAR FROM LEFT FORMAT
	BLT	PRNU40			;ILLEGAL IF COUNT IS NOW NEGATIVE
	BNE	PRNU17			;BRANCH IF COUNT IS OK
	BIT	#PRMSKE,12(SP)		;SEE IF E MODE
	BNE	PRNU40			;ILLEGAL FORMAT IF SO
PRNU17:	MOV	10(SP),R1		;PICK UP NUMBER OF LEFT FORMAT CHARS
	BIT	#PRMSKC,12(SP)		;CHECK , BIT
	BEQ	PRNU02			;IF NOT SET, SKIP COMMA COUNTING
	CLR	R0			;R0 IS USED FOR COUNTING COMMAS
PRNU60:	CMP	#3,R1			;SEE IF >3 CHARS IN LEFT FORMAT
	BGE	PRNU61			;IF NOT, BRANCH OUT
	SUB	#4,R1			;SUBTRACT OFF FOR 3 DIGITS AND 1 COMMA
	INC	R0			;INCREMENT COMMA COUNTER
	BR	PRNU60			;BRANCH BACK

PRNU61:	MOV	R1,-(SP)		;SAVE R1 ON SYSTEM STACK
	MOV	12(SP),R1		;PICK UP NUMBER OF LEFT FORMAT CHARS
	SUB	R0,R1			;SUBTRACT OFF NUMBER OF COMMAS
	MOV	(SP)+,R0		;REMOVE TEMP STORAGE FROM SYSTEM STACK
PRNU02:	BIT	#PRMSKE,12(SP)		;CHECK E BIT
	BNE	PRNU04			;IF SET, SKIP SOME INITIAL PROCESSING
	CMP	R4,R1			;COMPARE NUMBER WITH FORMAT
	BGT	PRNU40			;JUMP OUT IF NUMBER IS TOO BIG
;PROCESS FOR COMMAS
	BIT	#PRMSKC,12(SP)		;CHECK , BIT
	BEQ	PRNU16			;IF NOT SET, SKIP COMMA PROCESSING
	MOV	R4,R0			;MOVE SCALE FACTOR TO R0
	CLR	R1			;R1 IS USED FOR COUNTING COMMAS
PRNU23:	CMP	#3,R0			;SEE IF >3 DIGITS
	BGE	PRNU24			;IF NOT, JUMP OUT
	SUB	#3,R0			;SUBTRACT OFF THE THREE DIGITS
	INC	R1			;INCREMENT COMMA COUNTER
	BR	PRNU23			;LOOP BACK AGAIN

PRNU24:	ADD	R1,R4			;ADD NUMBER OF COMMAS
PRNU16:	BIT	#PRMSKD!PRMSKA,12(SP)	;CHECK * AND $ BITS
	BNE	PRNU20			;IF SET, INITIALIZE * OUTPUT
PRNU03:	CMP	#1,10(SP)		;TEST FORMAT COUNT
	BGE	PRNU04			;IF ONE, BRANCH TO CHECK SIGN
	CMP	R4,10(SP)		;SEE IF SOME SPACES ARE NEEDED
	BGE	PRNU04			;IF NOT, BRANCH TO CHECK ON SIGN
	MOVB	#40,(R2)+		;OUTPUT SPACE
	DEC	10(SP)			;DECREMENT FORMAT COUNT
	BR	PRNU03			;LOOP BACK AGAIN

PRNU73:	TST	6(SP)			;TEST FRACTION FORMAT
	BNE	PRNU14			;IF ROOM, CHECK FOR DECIMAL POINT
PRNU40:	MOV	2(SP),R1		;GET R1 FROM STACK
	ADD	#PRNBUC,R1		;RESET TO ORIGINAL VALUE
	CALLX	PRINTX,R3,<'%>		;PRINT %
	MOV	#PRNU41,-(SP)		;STORE RETURN ADDRESS ON STACK
	JMP	PRNFL1			;PRINT INPUT NUMBER

;PROCESS ASTERISK
PRNU20:	BIT	#PRMSKM,12(SP)		;SEE IF TERMINAL -
	BNE	PRNU21			;IF SO, DON'T CHECK SIGN OF NUMBER
	TSTB	4(SP)			;TEST SIGN OF NUMBER
	BEQ	PRNU21			;IF POSITIVE, THEN O.K.
	JMP	PRN100			;IF NEGATIVE, BRANCH TO ERROR

PRNU21:	BIT	#PRMSKD,12(SP)		;CHECK $ BIT
	BNE	PRNU31			;IF SET, GO TO PROCESS $
	CMP	R4,10(SP)		;COMPARE NUMBER WITH FORMAT
	BGE	PRNU06			;IF >=, RETURN TO MAIN PROGRAM
	CMP	10(SP),#1		;TEST FORMAT COUNT
	BLE	PRNU26			;IF <=1, RETURN TO MAIN PROGRAM
	MOVB	#'*,(R2)+		;OUTPUT *
	DEC	10(SP)			;DECREMENT FORMAT COUNT
	BGT	PRNU21			;LOOP BACK AGAIN
	BR	PRNU26

;PROCESS DOLLAR SIGN
PRNU31:	CMP	R4,10(SP)		;COMPARE NUMBER WITH FORMAT
	BGE	PRNU32			;IF >=, BRANCH TO OUTPUT $
	CMP	10(SP),#1		;TEST FORMAT COUNT
	BLE	PRNU32			;OUTPUT $ IF <=1
	MOVB	#40,(R2)+		;OUTPUT SPACE
	DEC	10(SP)			;DECREMENT FORMAT COUNT
	BGT	PRNU31			;LOOP BACK AGAIN
PRNU32:	MOVB	FLTCHR,(R2)+		;OUTPUT $
	BR	PRNU26			;RETURN TO MAIN PROGRAM

;CHECK ON SIGN
PRNU04:	BIT	#PRMSKM,12(SP)		;CHECK TERMINAL - BIT
	BNE	PRNU26			;IF SET, OUTPUT SIGN LATER
	TSTB	4(SP)			;TEST SIGN OF NUMBER
	BEQ	PRNU26			;IF POSITIVE, SKIP - OUTPUT
	MOVB	#'-,(R2)+		;OUTPUT -
PRNU26:	TST	R4			;TEST SCALE FACTOR
	BGT	PRNU06			;BRANCH OUT IF MORE THAN ONE
	BIT	#PRMSKE,12(SP)		;CHECK E BIT
	BNE	PRNU06			;IF SET, DON'T OUTPUT 0
	TST	10(SP)			;SEE IF LEFT SIDE POSITIONS
	BLE	PRNU73			;;;;
	MOVB	#'0,(R2)		;OUTPUT 0

	TST	6(SP)			;TIME TO ROUND?
	BNE	1$			;DON'T ROUND IF MORE FORMAT
	TST	R4			;TEST SCALE FACTOR
	BNE	1$			;IT'S NON-ZERO
	JMP	PRNU72			;IT'S ZERO, SO GOTO ROUND

1$:	JMP	PRNU71			;NO ROUND

PRNU06:	BIT	#PRMSKC,12(SP)		;CHECK , BIT
	BNE	PRNU50			;IF SET, OUTPUT USING COMMAS
	TST	10(SP)			;TEST WHETHER INTEGER PART
	BGT	PRNU08			;IF SO, BRANCH TO DIGIT OUTPUT
PRNU14:	BIT	#PRMSKP,12(SP)		;CHECK . BIT
	BEQ	PRNU10			;IF NOT SET, BRANCH TO FINISH
;OUTPUT DECIMAL POINT AND LEADING ZEROS
	MOVB	DOTCHR,(R2)+		;OUTPUT .
	BIC	#PRMSKP,12(SP)		;CLEAR . BIT
	MOV	6(SP),10(SP)		;REPLACE LEFT FORMAT BY RIGHT FORMAT
	CLR	6(SP)			;CLEAR RIGHT FORMAT
PRNU07:	TST	10(SP)			;TEST FORMAT COUNT
	BEQ	PRNU10			;IF ZERO, BRANCH TO FINISH
	BIT	#PRMSKE,12(SP)		;CHECK E BIT
	BEQ	PRNU00			;IF NOT SET, TEST FOR LEADING ZEROS
	ADD	10(SP),R4		;INCREMENT SCALE FACTOR BY NO. OF FORMAT CHARS
;OUTPUT DIGITS
PRNU08:	JSR	PC,PRNU90		;OUTPUT A DIGIT
	DEC	10(SP)			;DECREMENT FORMAT COUNT
	BGT	PRNU08			;IF NON-ZERO, LOOP BACK
	BR	PRNU14			;BRANCH TO CHECK ON DECIMAL POINT

PRNU00:	TST	R4			;TEST IF LEADING ZEROS ARE NEEDED
	BGE	PRNU08			;IF NOT, BRANCH TO DIGIT OUTPUT
	CMP	#1,10(SP)		;SEE IF FORMAT COUNT IS ONE
	BEQ	PRNU70			;IF SO, BRANCH TO ROUND
	MOVB	#'0,(R2)+		;OUTPUT 0
	DEC	10(SP)			;DECREMENT FORMAT COUNT
	INC	R4			;INCREMENT SCALE FACTOR
	BR	PRNU07			;LOOP BACK AGAIN

;FINISHING
PRNU10:	BIT	#PRMSKE,12(SP)		;CHECK E BIT
	BEQ	PRNU15			;IF NOT SET, BRANCH TO CHECK TERMINAL -
	CLR	-(SP)			;MOVE FLAG ONTO SYSTEM STACK
	JMP	PRNFL2			;JUMP INTO REGULAR PRINT PROGRAM

PRNU15:	TSTB	4(SP)			;TEST SIGN OF NUMBER
	BEQ	1$			;IF POSITIVE, BRANCH OUT
	MOV	R2,R3			;COPY OUTPUT BUFFER POINTER
	DEC	R3			;MOVE BACK ONE CHARACTER
	CMPB	(R3),#'0		;SEE IF LAST DIGIT WAS 0
	BNE	1$			;IF NOT, BRANCH OUT
	CMP	R3,2(SP)		;SEE IF 0 WAS ONLY CHARACTER
	BEQ	PRNU12			;YES, SO OUTPUT TRAILING SPACE
	DEC	R3			;MOVE BACK 1 MORE CHARACTER
	CMPB	(R3),#'-		;SEE IF CHARACTER IS MINUS SIGN
	BNE	2$			;NO, SO BRANCH OUT
	MOVB	#40,(R3)		;REPLACE - WITH SPACE
	BR	PRNU13			;BRANCH OUT

2$:	CMPB	(R3),#40		;SEE IF CHARACTER IS A SPACE
	BEQ	PRNU12			;YES, SO OUTPUT TRAILING SPACE
1$:	BIT	#PRMSKM,12(SP)		;CHECK TERMINAL -
	BEQ	PRNU13			;IF NOT SET, BRANCH OUT
	TSTB	4(SP)			;TEST SIGN OF NUMBER
	BEQ	PRNU12			;IF POSITIVE, BRANCH OUT
	MOVB	#'-,(R2)+		;OUTPUT TERMINAL -
	BR	PRNU13			;SKIP SPACE OUTPUT

PRNU12:	MOVB	#40,(R2)+		;OUTPUT SPACE FOR POSITIVE NUMBER
PRNU13:	CLRB	(R2)+			;OUTPUT TRAILING NULL FOR PRINTL
	MOV	2(SP),R2		;RESET R2
	MOV	R2,R1			;ALSO MOVE POINTER TO R1
	ADD	#PRNBUF,R1		;RESET R1
PRNU41:	ADD	#14,SP			;RESET SYSTEM STACK
	JMP	PRINTL			;PRINT BUFFER

;ERRORS
PRN100:	MOV	2(SP),R1		;RESTORE R1 STACK POINTER
	ERROR	PRNER1,FATAL		;ILLEGAL MINUS SIGN IN PRINT USING

PRN101:	MOV	4(SP),R1		;RESTORE R1 STACK POINTER
PRN102:	ERROR	PRNER2,FATAL		;OUTPUT BUFFER OVERFLOW IN PRINT USING

;OUTPUT USING COMMAS
PRNU50:	TST	R0			;TEST REMAINDER
PRNU52:	BLE	PRNU51			;IF <= ZERO, BRANCH TO CHECK IF FINISHED
PRNU53:	JSR	PC,PRNU90		;OUTPUT A DIGIT
	DEC	10(SP)			;DECREMENT LEFT FORMAT COUNT
	DEC	R0			;DECREMENT COUNTER
	BR	PRNU52			;LOOP BACK AGAIN

PRNU51:	TST	10(SP)			;IF <0, TEST LEFT FORMAT COUNT
	BLE	PRNU14			;RETURN TO MAIN PROGRAM
	MOVB	CMACHR,(R2)+		;OUTPUT ,
	MOV	#3,R0			;RESET 3 COUNTER
	DEC	10(SP)			;DECREMENT LEFT FORMAT COUNT
	BR	PRNU53			;LOOP BACK AGAIN

;ROUNDING DURING LEADING ZEROS
PRNU70:	MOVB	#'0,(R2)		;OUTPUT 0 WITHOUT INCREMENTING STACK
	CMP	R4,#-1			;TEST SCALE FACTOR
	BNE	PRNU71			;IF NOT -1, BRANCH OUT
PRNU72:	CMPB	#'5,(R3)		;SEE IF NEXT DIGIT >5
	BGT	PRNU71			;IF NOT, BRANCH OUT
	INCB	(R2)			;INCREMENT DIGIT
PRNU71:	INC	R2			;INCREMENT POINTER
	BR	PRNU14			;BRANCH TO CHECK ON DECIMAL POINT

;OUTPUT A DIGIT, ROUNDED IF NECESSARY
PRNU90:	CMP	R2,R3			;CHECK OUTPUT BUFFER
	BGT	PRN101			;OUTPUT BUFFER OVERLAPS INPUT CHARS
	CMP	R3,2(SP)		;SEE IF ANY MORE SIGNIFICANT DIGITS
	BHI	PRNU93			;IF NOT, ADD TRAINING ZEROS
	CMP	#1,12(SP)		;SEE IF ONLY ONE FORMAT CHAR LEFT
	BNE	PRNU99			;IF NOT, GO TO OUTPUT
	TST	10(SP)			;CHECK RIGHT FORMAT COUNT
	BEQ	PRNU80			;IF ZERO, BRANCH TO ROUND
PRNU99:	MOVB	(R3)+,(R2)+		;OUTPUT DIGIT
PRNU98:	DEC	R4			;DECREMENT SCALE FACTOR
	RTS	PC			;RETURN

PRNU93:	MOV	4(SP),R3		;GET HEAD OF BUFFER
	ADD	#PRNBUF,R3		;ADD LENGTH OF BUFFER
	CMP	R2,R3			;COMPARE WITH CURRENT POSITION
	BGT	PRN101			;OUTPUT BUFFER IS FULL
	MOVB	#'0,(R2)+		;OUTPUT 0
	BR	PRNU98			;BRANCH TO RETURN

PRNU80:	MOVB	(R3)+,(R2)+	;STORE NEXT DIGIT ON STACK
	CMP	R3,2(SP)	;SEE IF THERE IS A REMAINING DIGIT
	BHI	PRNU98		;IF NOT, RETURN
	CMPB	#'5,(R3)	;SEE IF DIGIT >5
	BGT	PRNU98		;IF NOT, RETURN
	MOV	R2,-(SP)	;SAVE CURRENT POINTER
	CLR	-(SP)		;MAKE ROOM FOR 0 FILL POINTER
PRNU85:	CMP	R2,10(SP)	;AT TOP OF STACK YET?
	BNE	PRNUYY		;NO, CHECK ANOTHER CHARACTER
PRNUXX:	BIT	#2,20(SP)	;DOING E FORMAT?
	BEQ	PRNU83		;NO, EXIT WITH ERROR
	INC	R4		;YES, CORRECT EXPONENT
	MOV	(SP),R2		;GET THE 0 FILL POINTER
	BNE	PRNU82		;ONE EXISTS, SO FILL
	BR	PRNU83		;ELSE EXIT WITH ERROR

PRNUYY:	CMPB	#'9,-(R2)	;CHECK FOR A 9
	BEQ	PRNU92		;IT IS A 9, GO CARRY
	CMPB	DOTCHR,(R2)	;CHECK FOR A .
	BEQ	PRNU85		;IT IS A ., LOOP
	CMPB	CMACHR,(R2)	;CHECK FOR A ,
	BEQ	PRNU85		;IT IS A ,, LOOP
	CMPB	#'*,(R2)	;CHECK FOR A *
	BEQ	PRNU82		;IT IS A *, FILL OVER IT
	CMPB	#40,(R2)	;CHECK FOR A <SPACE>
	BEQ	PRNU82		;IT IS A <SPACE>, FILL OVER IT
	CMPB	FLTCHR,(R2)	;CHECK FOR A $
	BEQ	PRNU84		;IT IS A $, CHECK FURTHER
	CMPB	#'-,(R2)	;CHECK FOR A -
	BEQ	PRNU84		;IT IS A -, CHECK FURTHER
	CMPB	#'0,(R2)	;CHECK FOR A DIGIT
	BLE	PRNU88		;IT IS A DIGIT, GO INCREMENT
PRNU83:	ADD	#6,SP		;COLLAPSE SP STACK SPACE
	JMP	PRNU40		; AND EXIT WITH ERROR

PRNU92:	MOVB	#'0,(R2)	;CARRY A 9 INTO A 0
	MOV	R2,(SP)		;REMEMBER THE 0 FILL LOCATION
	BR	PRNU85		; AND LOOP

PRNU84:	CMPB	#40,-1(R2)	;$ OR - PRECEEDED WITH <SPACE>?
	BNE	PRNUXX		;NO, FINISH UP
	MOVB	(R2),-1(R2)	;YES, MOVE THE $ OR - LEFT ONE PLACE
PRNU82:	MOV	R2,-(SP)	;SAVE CURRENT POINTER
	MOVB	#'0,(R2)+	;NOW 0 FILL
	BIT	#10,22(SP)	;DOING , INSERTION?
	BEQ	10$		;NOPE
	CMPB	(R2)+,(R2)+	;YEP, DO NEXT 2 CHARS MATCH?
	BNE	10$		;NO, CANNOT BE ",000,"
	CMPB	(R2),#'0	;MATCH, REALLY ",000,"??
	BNE	10$		;NOPE
	MOV	(SP)+,R2	;YEP, GET BACK POINTER
	MOVB	CMACHR,(R2)	; AND INSERT A COMMA
	BR	PRNU85		;NOW LOOP

10$:	MOV	(SP)+,R2	;RESTORE POINTER
PRNU88:	INCB	(R2)		;CARRY INTO NEXT DIGIT
	TST	(SP)+		;JUNK THE 0 FILL POINTER
	MOV	(SP)+,R2	;RESTORE ORIGINAL POINTER
	BR	PRNU98		; AND EXIT

.END

