TITLE	LA,<LEXICAL ANALYZER>,08,13-MAY-86,TPH/MHB/JDM/TVG/AWR/WJS

;                   Copyright 1974,1990 by Digital Equipment Corporation
;                                  All rights reserved.
;
;          This software is furnished under a license and may be used and copied
;          only  in  accordance  with  the  terms  of  such license and with the
;          inclusion of the above copyright notice.  This software or any copies
;          shall not be provided to any other person.   No title to or ownership
;          of the software is hereby transferred.
;
;          The information in this software is subject to change without notice.
;
;          DIGITAL  assumes  no  responsibility  for the  use, functionality, or
;          reliability of its  software  on equipment  which  is not supplied by
;          DIGITAL.

	DEFORG	LA

	.GLOBL	LEXAN
	.GLOBL	FRESPC,PRESET,MAPTOK,TOKDEC,FLOTIM
	.globl	DOASSR

	.GLOBL	EDFTCH,EDSTOR,ECONOM,SPDAR0
	.GLOBL	BUILDS,ATOI,ATOF,FIX,SAVREG,RESREG
	.GLOBL	TYTB,INCTAB,FLTLE2,BNT4,ZARRY4,TOKZIP

;THE FOLLOWING MACRO IGNORES ITS FIRST TWO ARGUMENTS AND
;BUILDS THE REST, IN REVERSE ORDER, INTO AN ASCII BYTE STRING -
;THE FIRST SHOULD ALWAYS BE SUPPLIED AS SOMETHING INNOCUOS -
;IN PARTICULAR, IT MUST NOT BE =, WHICH DESTROYS THE MACRO.

	.MACRO	BNAME	PROTCT,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R
	  .ASCII  !'R'Q'P'O'N'M'L'K'J'I'H'G'F'E'D'C'B'!
	.ENDM

;THE FOLLOWING MACRO MAKES NON-FUNCTION ENTRIES IN
;THE BASIC PERMANENT SYMBOL TABLE - A COUNTER KEPT IN
;BEC IS USED TO PROVIDE A UNIQUE NAME FOR EACH ENTRY
;(EACH ENTRY NAME IS PREFIXED WITH QX) - NEXT IS SET TO 0
;IN THE LAST ENTRY IN A BUCKET, TO 1 OTERWISE - NAME IS
;THE NAME THE ENTRY IS FOR (IN THE FORM 
;	^"L1,L2,...,LN"
;WHERE THE LI ARE THE LETTERS OF THE NAME) - TOKEN
;POINTS AT A THREE BYTE ENTRY IN THE TOKETB TABLE -
;TA IS THE WORD TO BE TRANSMITTED TO TOKA

	.MACRO	BENTRY	NEXT,NAME,TOKEN,TA
.LIST
;***********************************************************************

	 .BYTE	TA,TOKEN
	 BNAME	0,NAME
.NLIST
	 FUDGE	\BEC,\BEC+NEXT
	 BEC=1+BEC
.LIST

;***********************************************************************
.NLIST
	.ENDM

;GENERATES A TABLE ENTRY USED FOR AMBIGUITY RESOLUTION

	.MACRO	AMBIG	NEXT,NAME,TOKEN
.LIST
;*************************************************************************

	 .BYTE	TOKEN
	 BNAME	0,NAME
.NLIST
	 FUDGE	\BEC,\BEC+NEXT
	 BEC=BEC+1
.LIST

;*************************************************************************
.NLIST
	.ENDM

	.MACRO	EENTRY	NEXT,NAME,TOKEN,TA
.LIST
;*************************************************************************

	.BYTE	TA,TKMORE,TOKEN
	BNAME	0,NAME
.NLIST
	FUDGE	\BEC,\BEC+NEXT
	BEC=BEC+1
.LIST

;*************************************************************************
.NLIST
	.GLOBL	TA
	.ENDM

	.MACRO	FUDG1	ARG
	  FUDG2	ARG,\BEC
	.ENDM

	.MACRO	FUDG2	ARG1,ARG2
.LIST
QX'ARG1'	=QX'ARG2'
.NLIST
	.ENDM

;THE FOLLOWING MACRO MAKES FUNCTION ENTRIES IN THE BASIC
;PERMANENT SYMBOL TABLE - SIMILAR TO THE ABOVE 
;MACRO EXCEPT THAT THE WORD DESTINED FOR TOKA IS A POINTER
;THAT POINTS AT (1) THE PUSH-POP CODE WORD (PPOP) 
;FOR THE FUNCTION,(2) A WORD EACH TWO BITS OF WHICH
;(FROM RIGHT TO LEFT) GIVE TYPE INFORMATION 
;ABOUT THE FUNCTION'S ARGUMENTS:
;	FAF -- FLOATING
;	FAI -- INTEGER
;	FAS -- STRING
;ONLY FOUR OF THE FIVE FUNCTION ARGUMENT TYPE SLOTS
;(A1,A2,A3 & A4) ARE INCLUDED IN THE CURRENT MACRO
;DEFINITION

	.MACRO	FENTRY	NEXT,NAME,TOKEN,PPOP,A1,A2,A3,A4
.LIST
;**********************************************************************

	 .ODD
	 .BYTE	PPOP
.NLIST
	 ARGS	A1,A2,A3,A4
	 .BYTE	TOKEN
	 BNAME	0,NAME
	 FUDGE	\BEC,\BEC+NEXT
	 BEC=1+BEC
.LIST

;**********************************************************************
.NLIST
	.ENDM

	.MACRO	FUDGE	N1,N2
QX'N1':	  .BYTE	QX'N2'-.
	.ENDM

;+
; NXTEND TAKES TWO ARGUMENTS, THE LATTER OF WHICH IS A BRANCH ADDRESS. THE
; FIRST ARGUMENT IS EITHER EQ OR NE. IF IT IS EQ, THE BRANCH IS TAKEN IF
; NOEXTEND IS IN EFFECT.
;-

.MACRO	NXTEND	RL,LOC
	  BIT	#EDXTND,EDFLAG
	  B'RL	LOC
.ENDM	NXTEND

;WHEN A LOOKUP IS DONE IN THE PERMANENT SYMBOL TABLE, THE
;"TOKEN" BYTE (FIRST NEGATIVE BYTE ABOVE NAME BYTES)
;POINTS RELATIVE TO TOKETB AT A THREE BYTE
;ENTRY IN THE FOLLOWING TABLE - THE FIRST BYTE OF THE
;ENTRY GOES INTO TOKE - THE NEXT IS USED TO SET SOME BITS
;IN THE LOWER BYTE OF STAT - THE LAST IS USED TO CLEAR
;SOME BITS IN THE LOWER BYTE OF STAT

;INTERSPERSED THROUGHOUT THE TABLE ARE SINGLE OR DOUBLE BYTES
;PRECEDING CERTAIN ENTRIES, WHICH BYTES ACT AS DISPATCH ADDRESSES
;TO THE AMBIGUITY RESOLVER - IN THE RESOLVER, AN APPROPRIATE TEST
;IS MADE TO DETERMINE WHETHER TO PROCESS THE SYMBOL AS BUILT (USING
;THE ENTRY FOLLOWING THE DISPATCH ADDRESS) OR TO GO BUILD A VARIABLE
QZR1:	.BYTE	BASTOK,0,CTUNF+LINUMF
QZR2:	.BYTE	BASTOK,BLINEF,377-BLINEF
QZR3:	.BYTE	BASTOK,0,0
QZQR2:	.BYTE	OKNCUN-OKNCND	;XOR AMBIGUITY RESOLUTION
QZR4:	.BYTE	BASTOK,CTUNF,LINUMF
QZQR1:	.BYTE	0		;FOR AMBIGUITY RESOLUTION
QZR5:	.BYTE	BASTOK,CTUNF,LINUMF+ARF+HARF
QZR6:	.BYTE	BASTOK,0,CTUNF
QZR7:	.BYTE	BASTOK,CTUNF,0
QZR8:	.BYTE	BASTOK,BSTATF,LINUMF
QZQR6:	.BYTE	OKNCUN-OKNCND	;RUN AMBIGUITY RESOLUTION
QZR9:	.BYTE	BASTOK,QUOT1F,LINUMF
QZQR3:	.BYTE	OKNCUN-OKNCND	;AS,DIM,STOP AMBIG. RESOLUTION
QZR10:	.BYTE	BASTOK,0,LINUMF
QZR11:	.BYTE	BASTOK,HARF,LINUMF
QZR12:	.BYTE	BASTOK,LINUMF,CTUNF+ARF+HARF
QZR13:	.BYTE	BASTOK,ARF,LINUMF
QZR14:	.BYTE	BASTOK,COMF,0
QZR15:	.BYTE	BFS,0,LINUMF+CTUNF
QZQR7:	.BYTE	OKSUBT-OKNCND,1	;FOR RND RESOLVING
QZR16:	.BYTE	BFF,0,LINUMF+CTUNF
QZR18:	.BYTE	BFI,0,LINUMF+CTUNF
QZQR5:	.BYTE	OKSUBT-OKNCND,3	;PI AMBIG. RESOLUTION
QZR17:	.BYTE	DFLT,0,VARC	;"VARS"=0
QZQR4:	.BYTE	BRTBT6-OKNCND	;IF,PI,TAN AMBIG. RESOLUTION
QZR19:	.BYTE	DINT,0,VARC	;"VARS"=0
TOKETB:

.SBTTL	PERMANENT SYMBOL TABLE

BEC=1			;BASIC ENTRY COUNTER
	FUDG1	END
	BENTRY  0,,QZR2-TOKETB,27		;ENDCHR
	FUDG1	BM
	BENTRY  0,-,QZR7-TOKETB,3		;BINARY -
	FUDG1	EX
	BENTRY	0,!,QZR14-TOKETB,200		;EXCLAMATION MARK
	FUDG1	LB
	BENTRY  0,#,QZR5-TOKETB,44
	FUDG1	AMP
	BENTRY	0,&,QZR4-TOKETB,134		;& EQUAL PRINT
	FUDG1	LPA
	BENTRY  0,(,QZR5-TOKETB,24
	FUDG1	RPA
	BENTRY  0,),QZR1-TOKETB,25
	FUDG1	STAR
	BENTRY	1,^"*,*",QZR4-TOKETB,5		;UPARROW, FORTRAN STYLE
	BENTRY  0,*,QZR4-TOKETB,1
	FUDG1	PLUS
	BENTRY  0,+,QZR4-TOKETB,0
	FUDG1	COMA
	BENTRY  0,,QZR7-TOKETB,26		;COMMA
	FUDG1	UM
	BENTRY  0,-,QZR3-TOKETB,4		;UNARY -
	FUDG1	SLAS
	BENTRY  0,/,QZR4-TOKETB,2
	FUDG1	COL
	BENTRY  0,,QZR8-TOKETB,43		;COLON
	FUDG1	SEMI
	BENTRY  0,,QZR4-TOKETB,30		;SEMI-COLON
	FUDG1	LT
	BENTRY  1,^"^%<%,>",QZR4-TOKETB,15
	BENTRY  1,^"^%<%,=",QZR4-TOKETB,21
	BENTRY  0,^"^%<%",QZR4-TOKETB,20
	FUDG1	EQ
	BENTRY  1,^"=,=",QZR4-TOKETB,22
	BENTRY  0,=,QZR4-TOKETB,14
	FUDG1	GT
	BENTRY  1,^">,=",QZR4-TOKETB,17
	BENTRY  0,>,QZR4-TOKETB,16

.SBTTL	A WORD TO THE WISE

; NOTE WELL:
;	IT IS ABSOLUTELY ESSENTIAL THAT MULTI-WORD KEYWORDS BE
;	ARRANGED IN THE TABLE BELOW SO THAT THE LONGER KEYWORD
;	PRECEDES THE SHORTER KEYWORD,  IE,  "AS FILE" PRECEDES
;	"AS".   THIS IS REQUIRED FOR PROPER  PARSING OF ABSURD
;	STATEMENTS IN EXTEND MODE, SUCH AS "INPUT LINEPNTER$".
;	IF YOU DON'T BELIEVE ME, SEE SUBROUTINE 'LOOKUP.'
;			--AWR 18-APR-79

	FUDG1	A
	FENTRY  1,^"A,B,S",QZR16-TOKETB,PPABSF,FAF
	BENTRY  1,^"A,N,D",QZR4-TOKETB,6
	BENTRY	1,^"A,P,P,E,N,D",QZR9-TOKETB,TKAPND
	FENTRY	1,^"A,S,C,I,I",QZR18-TOKETB,PPASC,FAS
	BENTRY	1,^"A,S,< >,F,I,L,E",QZR4-TOKETB,303
	BENTRY  1,^"A,S,S,I,G,N",QZR9-TOKETB,74
	FENTRY  1,^"A,T,N",QZR16-TOKETB,PPATAN,FAF
	BENTRY  0,^"A,S",QZQR3-TOKETB,317
	FUDG1	B
	BENTRY	1,^"B,L,O,C,K",QZR4-TOKETB,BLOCK
.if df DE$BUG
	EENTRY	1,^"B,R,E,A,K",QZR12-TOKETB,TKBREK
.iff ;df DE$BUG
	EENTRY	1,^"B,?,?,?,K",QZR12-TOKETB,TKBREK
.endc ;df DE$BUG
	FENTRY	0,^"B,U,F,S,I,Z",QZR18-TOKETB,PPBUFN,FAF
;	FENTRY	1,^"B,U,F,S,I,Z",QZR18-TOKETB,PPBUFN,FAF	;  WJS 90.1.31
;	BENTRY  0,^"B,Y,E",QZR10-TOKETB,112		;No longer WJS 90.1.31
	FUDG1	C
	BENTRY  1,^"C,A,T,A,L,O,G",QZR9-TOKETB,104
	BENTRY	1,^"C,A,T",QZR9-TOKETB,104
	EENTRY	1,^"C,C,O,N,T",QZR1-TOKETB,TKCCON
	FENTRY	1,^"C,C,P,O,S",QZR18-TOKETB,PPPOS,FAF
	BENTRY  1,^"C,H,A,N,G,E",QZR11-TOKETB,130
	FENTRY	1,^"C,H,R,$",QZR15-TOKETB,PPCHR,FAF
	BENTRY  1,^"C,L,O,S,E",QZR4-TOKETB,174
	FENTRY	1,^"C,O,M,P,%",QZR18-TOKETB,PPCOM$,FAS,FAS
	BENTRY  1,^"C,O,M,P,I,L,E",QZR9-TOKETB,106
	BENTRY	1,^"C,O,N,T",QZR1-TOKETB,46
	BENTRY  1,^"C,O,N",QZR10-TOKETB,311
	BENTRY	1,^"C,L,U,S,T,E,R,< >,S,I,Z,E",QZR4-TOKETB,322
	BENTRY	1,^"C,O,U,N,T",QZR4-TOKETB,324
	FENTRY	1,^"C,V,T,%,$",QZR15-TOKETB,PPCVIS,FAI
	FENTRY	1,^"C,V,T,F,$",QZR15-TOKETB,PPCVFS,FAF
	FENTRY	1,^"C,V,T,$,%",QZR18-TOKETB,PPCVSI,FAS
	FENTRY	1,^"C,V,T,$,F",QZR16-TOKETB,PPCVSF,FAS
	FENTRY	1,^"C,V,T,$,$",QZR15-TOKETB,PPCVSS,FAS,FAF
	FENTRY	1,^"C,O,S",QZR16-TOKETB,PPCOS,FAF
	BENTRY  0,^"C,H,A,I,N",QZR10-TOKETB,176
	FUDG1	D
	BENTRY  1,^"D,A,T,A",QZR9-TOKETB,156
	FENTRY	1,^"D,A,T,E,$",QZR15-TOKETB,PPDAT$,FAF
	FENTRY	1,^"D,?,T,E,%",QZR18-TOKETB,PPDATI,FAS
	BENTRY  1,^"D,E,A,S,S,I,G,N",QZR9-TOKETB,100
	BENTRY  1,^"D,E,F,< >,*",QZR10-TOKETB,140
	BENTRY  1,^"D,E,F",QZR10-TOKETB,140
	BENTRY  1,^"D,E,L,E,T,E",QZR12-TOKETB,54
	.BYTE	DET,377				;ADDRESS OF DETERMINANT
	AMBIG	1,^"D,E,T",QZR17-TOKETB
	FENTRY	1,^"D,I,F,$",QZR15-TOKETB,PPDIF$,FAS,FAS
	BENTRY  1,^"D,I,M",QZQR3-TOKETB,136
.if df DE$BUG
	EENTRY	0,^"D,U,M,P",QZR9-TOKETB,TKDUMP
.iff ;df DE$BUG
	EENTRY	0,^"D,?,?,P",QZR9-TOKETB,TKDUMP
.endc ;df DE$BUG
	FUDG1	E
;	FENTRY	1,^"E,D,I,T,$",QZR15-TOKETB,PPCVSS,FAS,FAF
						; EDIT$() = CVT$$()
	BENTRY  1,^"E,L,S,E",QZR12-TOKETB,301
	BENTRY  1,^"E,N,D",QZR10-TOKETB,166
	BENTRY	1,^"E,Q,V",QZR4-TOKETB,13
	.BYTE	VALERR,377			;ADDRESS OF ERL'S VALUE
	AMBIG	1,^"E,R,L",QZR19-TOKETB
	.BYTE	ERRVAL,377			;ADDRESS OF ERR'S VALUE
	AMBIG	1,^"E,R,R",QZR19-TOKETB
	EENTRY	1,^"E,X,I,T",QZR10-TOKETB,TKEXIT
	BENTRY	1,^"E,X,T,E,N,D",QZR10-TOKETB,TKXTND
	FENTRY  0,^"E,X,P",QZR16-TOKETB,PPEXP,FAF
	FUDG1	F
	BENTRY	1,^"F,I,E,L,D",QZR4-TOKETB,230
	FENTRY	1,^"F,I,X",QZR16-TOKETB,PPFIXF,FAF
	BENTRY	1,^"F,N,E,N,D",QZR10-TOKETB,212
	BENTRY	1,^"F,O,R,< >,I,N,P,U,T,< >,A,S,< >,F,I,L,E",QZR4-TOKETB,315
	BENTRY	1,^"F,O,R,< >,O,U,T,P,U,T,< >,A,S,< >,F,I,L,E",QZR4-TOKETB,316
	BENTRY	1,^"F,I,L,E,< >,S,I,Z,E",QZR4-TOKETB,325
	BENTRY	0,^"F,O,R",QZQR1-TOKETB,146
	FUDG1	G
	BENTRY	1,^"G,E,T",QZR4-TOKETB,224
	BENTRY	1,^"G,O,< >,S,U,B",QZR12-TOKETB,210
	BENTRY	0,^"G,O,< >,T,O",QZR12-TOKETB,142
;	FUDG1	H					;No longer WJS 90.1.31
;	BENTRY	0,^"H,E,L,L,O",QZR10-TOKETB,110		;No longer WJS 90.1.31
	FUDG1	I
	BENTRY	1,^"I,D,N",QZR10-TOKETB,310
	AMBIG	1,^"I,F,O,R",QZQR4-TOKETB
	BENTRY	1,^"I,F",QZR5-TOKETB,144
	BENTRY	1,^"I,M,P",QZR4-TOKETB,12
	BENTRY	1,^"I,N,P,U,T,< >,L,I,N,E",QZR4-TOKETB,214
	BENTRY	1,^"I,N,P,U,T",QZR4-TOKETB,132
	FENTRY	1,^"I,N,S,T,R",QZR18-TOKETB,PPINST,FAF,FAS,FAS
	FENTRY	1,^"I,N,T",QZR16-TOKETB,PPINTF,FAF
	BENTRY	1,^"I,N,V,[",QZR4-TOKETB,313
	BENTRY	0,^"I,N,V,(",QZR4-TOKETB,313
	FUDG1	K
	BENTRY	1,^"K,E,Y",QZR10-TOKETB,116
	BENTRY	0,^"K,I,L,L",QZR10-TOKETB,222
	FUDG1	L
	FENTRY	1,^"L,E,F,T",QZR15-TOKETB,PPLEFT,FAS,FAF
	BENTRY	1,^"L,E,N,G,T,H",QZR10-TOKETB,56
	FENTRY	1,^"L,E,N",QZR18-TOKETB,PPLEN,FAS
	BENTRY	1,^"L,S,E,T",QZR4-TOKETB,232
	BENTRY	1,^"L,E,T",QZR10-TOKETB,154
	.BYTE	CURLIN,377
	AMBIG	1,^"L,I,N,E",QZR19-TOKETB
	BENTRY	1,^"L,I,S,T,< >,N,H",QZR12-TOKETB,52
	FENTRY	1,^"L,O,G,1,0",QZR16-TOKETB,PPLG10,FAF
	FENTRY	1,^"L,O,G",QZR16-TOKETB,PPLN,FAF
	BENTRY	0,^"L,I,S,T",QZR12-TOKETB,50
	FUDG1	M
	FENTRY	1,^"M,A,G,T,A,P,E",QZR18-TOKETB,PPMAGT,FAI,FAI,FAI
	BENTRY	1,^"M,O,D,E",QZR4-TOKETB,321
	EENTRY	1,^"M,O,U,N,T",QZR9-TOKETB,TKMOUN
	BENTRY	1,^"M,A,T",QZR13-TOKETB,126
	FENTRY	0,^"M,I,D",QZR15-TOKETB,PPSBS1,FAS,FAF,FAF
	FUDG1	N
	BENTRY	1,^"N,A,M,E",QZR10-TOKETB,204
	BENTRY	1,^"N,E,W",QZR9-TOKETB,60
	BENTRY	1,^"N,E,X,T",QZR10-TOKETB,202
	BENTRY	1,^"N,O,< >,E,X,T,E,N,D",QZR10-TOKETB,TKNXTN
	BENTRY	1,^"N,O,T",QZR4-TOKETB,11
	FENTRY	1,^"N,U,M,1,$",QZR15-TOKETB,PPNM1$,FAF
	FENTRY	1,^"N,U,M,$",QZR15-TOKETB,PPNUM,FAF
	.BYTE	NV2,377				;ADDRESS OF NUM2
	AMBIG	1,^"N,U,M,2",QZR19-TOKETB
	.BYTE	NV1,377				;ADDRESS OF NUM
	AMBIG	0,^"N,U,M",QZR19-TOKETB
	FUDG1	O
	BENTRY	1,^"O,L,D",QZR9-TOKETB,62
	BENTRY	1,^"O,N,< >,E,R,R,O,R,< >,G,O,< >,T,O",QZR12-TOKETB,170
	BENTRY	1,^"O,N",QZR4-TOKETB,150
	BENTRY	1,^"O,P,E,N",QZR10-TOKETB,172
	BENTRY	0,^"O,R",QZR4-TOKETB,7
	FUDG1	P
	FENTRY	1,^"P,E,E,K",QZR18-TOKETB,PPPEEK,FAF
	.BYTE	PICON,377			;ADDRESS OF PI
	AMBIG	1,^"P,I,F,O,R",QZQR5-TOKETB
	AMBIG	1,^"P,I,F",QZQR4-TOKETB
	.BYTE	PICON,377			;ADDRESS OF PI
	AMBIG	1,^"P,I",QZR17-TOKETB
	FENTRY	1,^"P,L,A,C,E,$",QZR15-TOKETB,PPLAC$,FAS,FAI
	FENTRY	1,^"P,O,S",QZR18-TOKETB,PPPOS,FAF
	FENTRY	1,^"P,R,O,D,$",QZR15-TOKETB,PPROD$,FAS,FAS,FAI
	BENTRY	1,^"P,U,T",QZR4-TOKETB,226
	BENTRY	0,^"P,R,I,N,T",QZR4-TOKETB,134
	FUDG1	Q
	FENTRY	0,^"Q,U,O,$",QZR15-TOKETB,PPQUO$,FAS,FAS,FAI
	FUDG1	R
	FENTRY	1,^"R,A,D,$",QZR15-TOKETB,PPRAD$,FAF
	FENTRY	1,^"R,A,D,%",QZR18-TOKETB,PPRADI,FAS
	BENTRY	1,^"R,A,N,D,O,M,I,Z,E",QZR10-TOKETB,124
	BENTRY	1,^"R,A,N,D,O,M",QZR10-TOKETB,124
	BENTRY	1,^"R,E,A,D",QZR10-TOKETB,206
	EENTRY	1,^"R,E,A,S,S,I,G,N",QZR9-TOKETB,TKREAS
	BENTRY	1,^"R,E,C,O,R,D,< >,S,I,Z,E",QZR4-TOKETB,320
	BENTRY	1,^"R,E,C,O,R,D",QZR4-TOKETB,323
	.BYTE	RECOUN,377			;ADDRESS OF RECORD COUNT
	AMBIG	1,^"R,E,C,O,U,N,T",QZR19-TOKETB
	BENTRY	1,^"R,S,E,T",QZR4-TOKETB,234
	BENTRY	1,^"R,E,M",QZR14-TOKETB,200
	BENTRY	1,^"R,E,N,A,M,E",QZR9-TOKETB,64
	BENTRY	1,^"R,E,P,L,A,C,E",QZR9-TOKETB,66
	BENTRY	1,^"R,E,S,T,O,R,E",QZR10-TOKETB,160
	BENTRY	1,^"R,E,S,U,M,E",QZR12-TOKETB,162
	BENTRY	1,^"R,E,T,U,R,N",QZR10-TOKETB,152
	FENTRY	1,^"R,I,G,H,T",QZR15-TOKETB,PPSBST,FAS,FAF
	FENTRY	1,^"R,N,D,[",QZQR7-TOKETB,PPRND,FAF
	FENTRY	1,^"R,N,D,(",QZQR7-TOKETB,PPRND,FAF
	FENTRY	1,^"R,N,D",QZR16-TOKETB,PPRND,0
	BENTRY	1,^"R,U,N,N,H",QZR9-TOKETB,72
	BENTRY	0,^"R,U,N",QZQR6-TOKETB,70
	FUDG1	S
	BENTRY	1,^"S,A,V,E",QZR9-TOKETB,76
	EENTRY	1,^"S,C,A,L,E",QZR1-TOKETB,TKSCAL
	BENTRY	1,^"S,L,E,E,P",QZR4-TOKETB,TKSLEP
	FENTRY	1,^"S,G,N",QZR16-TOKETB,PPSGNF,FAF
	FENTRY	1,^"S,I,N",QZR16-TOKETB,PPSIN,FAF
	FENTRY	1,^"S,P,A,C,E,$",QZR15-TOKETB,PPSPAC,FAF
	FENTRY	1,^"S,Q,R",QZR16-TOKETB,PPSQRT,FAF
	FENTRY	1,^"S,U,M,$",QZR15-TOKETB,PPSUM$,FAS,FAS
	FENTRY	1,^"S,W,A,P,%",QZR18-TOKETB,PPSWAP,FAF
	.BYTE	STATUS,377			;ADDRESS OF STATUS'S VALUE
	AMBIG	1,^"S,T,A,T,U,S",QZR19-TOKETB
	BENTRY	1,^"S,T,E,P",QZR4-TOKETB,302
	BENTRY	1,^"S,T,O,P",QZQR3-TOKETB,164
	FENTRY	1,^"S,T,R,I,N,G,$",QZR15-TOKETB,PPSTNG,FAF,FAF
	FENTRY	1,^"S,Y,S",QZR15-TOKETB,PPUUO,FAS
	FENTRY	0,^"S,P,E,C,%",QZR18-TOKETB,PPSPEC,FAI,FAF,FAI,FAI
	FUDG1	T
	FENTRY	1,^"T,A,B",QZR15-TOKETB,PPTAB,FAF
	AMBIG	1,^"T,A,N,D",QZQR4-TOKETB
	FENTRY	1,^"T,A,N",QZR16-TOKETB,PPTAN,FAF
	BENTRY	1,^"T,A,P,E",QZR10-TOKETB,114
	BENTRY	1,^"T,H,E,N",QZR12-TOKETB,300
	FENTRY	1,^"T,I,M,E,$",QZR15-TOKETB,PPTIM$,FAF
	FENTRY	1,^"T,I,M,E",QZR16-TOKETB,PPTIME,FAF
	BENTRY	1,^"T,O",QZR4-TOKETB,314
.if df DE$BUG
	EENTRY	1,^"T,R,A,C,E",QZR10-TOKETB,TKTRAC
.iff ;df DE$BUG
	EENTRY	1,^"T,?,?,?,E",QZR10-TOKETB,TKTRAC
.endc ;df DE$BUG
	BENTRY	1,^"T,R,N,[",QZR4-TOKETB,312
	BENTRY	0,^"T,R,N,(",QZR4-TOKETB,312
	FUDG1	U
.if df DE$BUG
	EENTRY	1,^"U,N,B,R,E,A,K",QZR12-TOKETB,TKUNBR
.iff ;df DE$BUG
	EENTRY	1,^"U,?,?,?,?,?,K",QZR12-TOKETB,TKUNBR
.endc ;df DE$BUG
	BENTRY	1,^"U,N,L,E,S,S",QZR5-TOKETB,TKUNLS
	BENTRY	1,^"U,N,S,A,V,E",QZR9-TOKETB,102
	BENTRY	1,^"U,N,L,O,C,K",QZR4-TOKETB,236
	BENTRY	1,^"U,S,I,N,G",QZR4-TOKETB,306
	BENTRY	1,^"U,N,T,I,L",QZR5-TOKETB,220
.if df DE$BUG
	EENTRY	0,^"U,N,T,R,A,C,E",QZR10-TOKETB,TKUNTR
.iff ;df DE$BUG
	EENTRY	0,^"U,?,?,?,?,?,E",QZR10-TOKETB,TKUNTR
.endc ;df DE$BUG
	FUDG1	V
	FENTRY	0,^"V,A,L",QZR16-TOKETB,PPVAL,FAS
	FUDG1	W
	BENTRY	1,^"W,A,I,T",QZR4-TOKETB,TKWAIT
	BENTRY	0,^"W,H,I,L,E",QZR5-TOKETB,216
	FUDG1	X
	FENTRY	1,^"X,L,A,T,E",QZR15-TOKETB,PPXLTE,FAS,FAS
	BENTRY	0,^"X,O,R",QZQR2-TOKETB,10
	FUDG1	Z
	BENTRY	0,^"Z,E,R",QZR10-TOKETB,307
	FUDG1	UPAR
	BENTRY	0,,QZR4-TOKETB,5		;UPARROW
QXLAST=.
	.EVEN

;THIS TABLE DISPATCHES THE PERMANENT 
;SYMBOL TABLE - THE SELF-RELATIVE ADDRESS OF
;THE FIRST ENTRY BEGINNING WITH, SAY, X IS
;LOCATED AT PERTAB+2*('X-'(SPACE)) - AN ENTRY
;HAS THE FORM:
;	1-BYTE SELF-RELATIVE ADDRESS OF NEXT ENT BEG WITH X
;	2ND THRU LAST CHARS OF ENTRY NAME
;	DISPATCH TOKEN INTO TOKETB TABLE
;	1 BYTE OR WORD OF TOKEN FOR TOKA
;	OTHER BYTES OF DATA AS REQUIRED (USUALLY NONE)
;ANY TIME THE POINTER TO A TABLE ENTRY IS 0,
;THAT ENTRY DOES NOT EXIST

PERBAS=PERTAB-ENDCHR-ENDCHR	;BASE ADDRESS OF PERM SYMBOL TABLE BIASED BY ENDCHR

PERTAB:	.WORD	QXEND-.		;ENDCHR
	.WORD	0		;BUMCHR
	.WORD	QXBM-.		;BINARY -
	.WORD	0		;SPACE
	.WORD	QXEX-.		;!
	.WORD	0		;"
	.WORD	QXLB-.		;#
	ZSKIP	2		;$ THRU %
	.WORD	QXAMP-.		;&
	.WORD	0		;'
	.WORD	QXLPA-.		;(
	.WORD	QXRPA-.		;)
	.WORD	QXSTAR-.	;*
	.WORD	QXPLUS-.	;+
	.WORD	QXCOMA-.	;COMMA
	.WORD	QXUM-.		;UNARY -
	.WORD	0		;PERIOD
	.WORD	QXSLAS-.	;/
	ZSKIP	10.		;0 THRU 9
	.WORD	QXCOL-.		;COLON
	.WORD	QXSEMI-.	;SEMI-COLON
	.WORD	QXLT-.		;<
	.WORD	QXEQ-.		;=
	.WORD	QXGT-.		;>
	ZSKIP	2		;? THRU @
	.WORD	QXA-.		;A
	.WORD	QXB-.		;B
	.WORD	QXC-.		;C
	.WORD	QXD-.		;D
	.WORD	QXE-.		;E
	.WORD	QXF-.		;F
	.WORD	QXG-.		;G
	.WORD	0		;H
	.WORD	QXI-.		;I
	.WORD	0		;J
	.WORD	QXK-.		;K
	.WORD	QXL-.		;L
	.WORD	QXM-.		;M
	.WORD	QXN-.		;N
	.WORD	QXO-.		;O
	.WORD	QXP-.		;P
	.WORD	QXQ-.		;Q
	.WORD	QXR-.		;R
	.WORD	QXS-.		;S
	.WORD	QXT-.		;T
	.WORD	QXU-.		;U
	.WORD	QXV-.		;V
	.WORD	QXW-.		;W
	.WORD	QXX-.		;X
	.WORD	0		;Y
	.WORD	QXZ-.		;Z
	.WORD	QXLPA-.		;[ (EQUIVALENT TO ()
	.WORD	QXCOL-.		;\ (EQUIVALENT TO :)
	.WORD	QXRPA-.		;] (EQUIVALENT TO ))
	.WORD	QXUPAR-.	;UPARROW
	.WORD	0		;BACKARROW

.SBTTL	LEXAN - MAIN LEXICAL ANALYZER ROUTINE

LEXAN:	MOV	R1,R1RING	;SAVE R1 IN A READILY ACCESSIBLE PLACE
	JSR	R5,SAVREG	;SAVE R0-R5
	MOV	SPDA,R0		;R0 <- BASE ADDRESS
	MOV	STAT(R0),R4	;SET R4 TO STATUS WORD
	JMASK0	EQ,R4,BLINEF,LEX1 ;PROCESS CURRENT LINE IF NOT BEG. OF LINE
	BIS	#BLINS,R4	;SET STATUS FLAGS
	JMASK0	EQ,R4,QUOT1F,LEX7 ;FILL THE BUFFER IF QUOT1F IS OFF
	BIC	#BLINEF+BLINC-IMMEDF,R4  ;OTHWS, PRETEND WE'RE IN MIDDLE OF LINE
	BR	LEX6		;FILL BUFFER, BUT AVOID CLEARING IMMEDF FLAG

LEX7:	BIC	#BLINC,R4
LEX6:	JSR	PC,FILCLB	;FILL LEXICAL BUFFER
LEX1:	JMASK0	EQ,R4,BSTATF,2002$ ;BR IF IN MIDDLE OF A STATEMENT
	BIS	#BSTAS,R4	;SET & CLR STATUS FLAGS
	BIC	#BSTAC,R4
2002$:	MOV	R4,STAT(R0)	;SET STATUS FROM R4

; WE GET HERE WHEN IT IS TIME TO PROCESS THE NEXT LEXICAL BUFFER CHARACTER.
; CLB(R0) IS AN UNBIASED POINTER TO THE NEXT LEXICAL BUFFER CHAR.

LEX2:	MOV	CLB(R0),R5	;R5 <- CUR LEX BEG PTR
	ADD	R0,R5		;BIAS
	IF	(R5),EQ,#ENDCHR,STRTIM,B ;PROCESS END OF LINE
	IF	(R5),NE,#BUMCHR,10$,B ;SKIP IF NOT SUBLINE END
	TSTB	1(R5)		;IS IT THE REAL END?
	BEQ	LEX6		;YES, GET NEXT SUBLINE
	JMASK0	EQ,R4,QUOT1F,LEX6 ;NO, SPECIAL QUOTED STRING??
	MOVB	#COM,(R5)	;IF SO REPLACE THE MISSING "!"
10$:	IFSIGN	R4,MI,LEX5,B	;BR IF IN A COMMENT
	IF	(R5),NE,#SPACE,STRTIM,B ;PROCESS NONSPACES PRONTO

; WE GET HERE IF: (1) WE HAVE A SPACE TO IGNORE OR (2) IF WE HAVE A CHAR
; EMBEDDED IN A COMMENT TO IGNORE.

LEX5:	INC	CLB(R0)		;SET UP CHAR SKIP
	BR	LEX2		;GO LOOK AT NEXT CHAR

;HERE WE'RE LOOKING FOR A STRING - MAYBE

STRTIM:	MOVB	(R5),R2		;R2_CUR FIRST CHAR OF LEX BUFFER
	JSR	PC,QTEST	;SET AND CLR QUOTF & QUOT1F AS APPROPRIATE
	BEQ	NUMTIM		;QUOTF OR QUOT1F SET?
;BUILD THE STRING - KEEPING R4 CLEAN, BECAUSE IT HAS THE STATUS BITS
	BIC	#QUOTF,R4	;OUT OF QUOTES IF QUOT1F QUOTED
	JMASK0	NE,R4,QUOT1F,STR2  ;YES - BR IF QUOT1F SET
	INC	R5		;YES - SKIP QUOTE SYMB IN LEX BUF
	BIS	#QUOTF,R4	;INSIDE QUOTES IF NORMAL THING
STR2:	SUB	R0,R5		;UNBIAS R5
	JSR	PC,FRESPC	;R3 _ ADDR LOWEST ITEM IN HEASER AREA
	MOV	R3,R2		;SAVE IN R2
	MOV	#LINLEN,R3	;MAKE SURE THERE'S ROOM FOR ALL CHARS
	MOV	R1RING,R1	;RESTORE LEGAL STACK POINTER
	JSR	PC,BUILDS	;BUILD A STRING ON THE R1 STACK
	ADD	R0,R2		;BIAS NEW HEADER ADDR+6
	MOV	R2,R1		;NOW MAKE BELIEVE ITS IN THE R1 STACK AREA
	ADD	R0,R5		;BIAS R5
STR4:	MOVB	(R5)+,R2	;GET NEXT CHAR FOR STRING
	JSR	PC,QTEST	;TEST QUOTE SITUATION
	BEQ	STR5		;BRANCH IF DONE
	BMI	10$		;INSIDE REAL QUOTES, KEEP CHAR

; Hmmm.  QUOT1F set.  Special quoting...

	CMPB	R2,#SPACE	;Is character a <space> ?
	BEQ	12$		;Yes => probably won't keep it
10$:	MOVB	R2,(R3)+	;No:  keep this character
	BR	STR4		;AROUND AGAIN

12$:	CMP	26(SP),#DOASSR	;ASSIGN command being processed?
	BNE	STR4		;No => ignore the space
	;BR	STR5		;Yes:  treat space as token delimiter

STR5:	SUB	R0,R5		;UNBIAS R5
	IF	R2,EQ,UNQUOT(R0),STR3,B  ;BUILDS DONE - BRANCH IF R2 THE OFFICIAL UNQUOTE
	DEC	R5		;IT ISN'T SO BACK UP LEX PTR
STR3:	JSR	PC,@(SP)+	;FINISH UP IN BUILDS
	MOV	R5,(SP)		;REPLACE NON-IPC WITH CLB FOR FIXUP AT TABT2
	MOV	#DSTR,TOKE(R0)	;SET STRING DATA TOKEN
	MOV	R1,R3		;POINTER TO WOULD-BE STRING HEADER
	JSR	PC,LISHED	;PUT IT ON HEADER LIST
	BR	TABT7		;EXIT SEQUENCE

;AT THIS POINT BEGINS THE CODE FOR PROCESSING
;NUMBERS, INCLUDING LINE NUMBERS

NUMTIM:	JSR	PC,NMSCAN	;FIX UP STRINGS OF LEADING SIGNS & TEST FOR NUMBER
	JMASK0	EQ,R4,NUMBF,TABTIM  ;NUMBER?
	MOV	#FLTINT,TOKE(R0)  ;YES - SET TOKE TO INTEGER TOKEN
	JSR	PC,FRESPC	;R3_ADDR LOWEST BYTE OF TABLE & HEADER AREA
	MOV	R3,R1		;SET DUMMY R1 STACK POINTER
	MOV	CLB(R0),R2	;R2_BEG OF NUM IN LEX BUFFER
	ADD	R0,R1		;BIAS R1 & R2
	ADD	R0,R2
	JMASK0	EQ,R4,LINUMF,1$	;BR IF NOT POSSIBLE LINE NUMBER
	JSR	PC,ATOI		;TRY TO BUILD AN INTEGER
	BR	2$		;PROCESS AS THE INTEGER IT IS

1$:	JSR	PC,ATOF		;TRY TO BUILD FLOATING NUMBER
	BVC	2$		;BR IF FLOATER O.K.
	POST,	PSTFLT		;OTHWS, POST FLOATING ERROR
2$:	MOV	SPDA,R0		;RESET BASE REGISTER
	MOV	R4,R3		;HAVE ANOTHER USE FOR R4
	MOV	STAT(R0),R4	;R4 _ STATUS FLAGS
	MOVB	(R2),R5		;SAVE CHAR FOLLOWING NUMBER IN R5
	SUB	R0,R2		;UNBIAS R2
	MOV	R2,CLB(R0)	;SAVE BEG LEX PTR
	JMASK0	NE,R3,DOTF+EXPN,3$ ;CAN'T BE INTEGER (%) IF DOT OR "E"
	IF	R5,NE,#'%,3$	;BRANCH IF NUM NOT FOLLOWED BY %
	INC	CLB(R0)		;OTHERWISE, SKIP OVER %
	BIC	#CONVFF,R4	;NO MORE AUTOMATIC CONVERSION TO FLOATING
	BR	INTIM		;AND FORCE INTEGER CONVERSION

3$:	JMASK0	NE,R4,LINUMF,INTIM1
	JMASK0	NE,R3,DOTF+EXPN,FLOTIM  ;DECIMAL PT OR EXP IN NUMBER?
	JSR	PC,BNT4			;CHECK FOR POSSIBLE INTEGER
	JMASK0	EQ,R4,OUTEXF+CONVFF,INTIM  ;INTEGER IF INSIDE TLCOMF & CONVFF OFF

;AT THIS POINT WEARE PROCESSING A FLOATING PT NUMBER

FLOTIM:	SWAB	TOKE(R0)	;TOKE _ FLOATING DATA TOKEN
	MOV	#ONECON,R5	;R5 _ ADDR FLOATING ONE
	MOV	R5,R3		;DITTO R3 - JUST IN CASE
	ADD	R0,R5		;BIAS R5
	MOV	R1,R2		;R2 _ ADDR CURRENT FLOATING NUMBER
	ADD	#FLTLE2,R2	;POINT TO END+2 OF IT
	ADD	#FLTLE2,R5	;DITTO
FLOT2:	CMP	-(R2),-(R5)	;THE SAME?
	BNE	FLOT1		;NO
	CMP	R2,R1		;DONE COMPARING?
	BNE	FLOT2		;NOT YET
	BR	TABT4		;IT IS A FLOATING 1

;AT THIS POINT WE ARE PROCESSING AN INTEGER
INTIM:	JMASK0	NE,R4,LINUMF,INTIM1
	JSR	PC,FIX		;CONVERT NUMBER TO INTEGER FORMAT
FLOT1:	SUB	R0,R1		;NO - UNBIAS R1
	MOV	R1,NEXFRE(R0)	;UPDATE NEXFRE TO POINT AT LASTITEM
	BR	TABT3		;EXIT

INTIM1:	IFZERO	LE,(R1),FLOT1	;IS NUMBER NONNEGATIVE AND NONZERO?
	MOV	#LINUM,TOKE(R0)	;IF SO, SET LINE NUMBER TOKEN
	MOV	(R1),R1		;STANDING IN FOR TOKA, R1_ACTUAL LINE NUMBER
	;BIS	#LINS,R4	;SET & CLR STATUS FOR LINE NUMBER
	BIC	#LINC,R4
	BR	LEXEX		;EXIT


;THIS PART OF THE MAIN ROUTINE IS REACHED IF
;THE CURRENT LEXICAL ITEM MUST BE LOOKED UP
;IN THE PERMANENT OR VARIABLE SYMBOL TABLE - IT
;IS FIRST LOOKED UP IN THE PERMANENT SYMBOL TABLE -
;IF NOT FOUND THERE, IT IS CHECKED TO SEE IF IT IS
;A WELL-FORMED VARIABLE NAME - THEN CHECKED AGAINST
;THE VARIABLE SYMBOL TABLE & ADDED TO IT IF NOT
;ALREADY FOUND THERE

TABTIM:	MOV	#PERBAS,R4	;R4_ADDR PERM SYMB TABLE
	JSR	PC,LOOKUP	;LOOK UP SYMBOL
	BR	PERSYM		;BR IF SYMBOL FOUND
TABT6:	JSR	PC,DECVAR	;DECODE SYMBOL AS VARIABLE NAME
	MOV	#VARTAB-'A-'A,R4;R4_ADDR VAR SYMB TABLE
	ADD	R0,R4		;BIAS R4
	JSR	PC,LOOKUP	;LOOK UP SYMBOL
TABT0:	BR	VARSYM		;BR IF SYMBOL FOUND
	SUB	R0,R3		;UNBIAS R3
TABT1:	JSR	PC,ADDVAR	;IF NOT ADD TO VAR TABLE
TABT2:	MOV	STAT(R0),R4	;R4 _ STAT
	TST	(SP)+		;RID OF "PURE" SYMBOL END POINTER
TABT7:	MOV	(SP)+,CLB(R0)	;ADVANCE LEX PTR TO NEW VALUE STORED ON STACK BY DECVAR
TABT4:	MOV	R3,R1		;TOKA_ADDR NEW VALUE
TABT3:	;BIS	#VARS,R4	;SET & CLR STATUS BITS
	BIC	#VARC,R4
TABT5:	JMASK0  EQ,TOKE(R0),INTGF,LEXEX  ;LEX ITEM AN INTEGER VARIABLE?
	BIC	#CONVFF,R4	;YES - TURN OFF CONVERT TO FLOATING FLAG
LEXEX:	MOV	R1,TOKA(R0)	;SET TOKA & STAT FROM REGISTERS
	MOV	R4,STAT(R0)
	JSR	R5,RESREG	;RESTORE R0-R5
	MOV	R1RING,R1	;UPDATE R1 STACK POINTER
	JMP	SPDAR0		;SPDA TO R0, RTS PC

VARSYM:	SUB	R0,R5		;DEBIAS R5
	IF  R5,EQ,(SP),VARS1	;BR IF WHOLE VARIABLE NAME SCANNED
	MOV	#TABT0,-(SP)	;OTHWS, NOT TRUE MATCH - DUMMY RETURN
	BR	LOOK1		;	TO TABT0 & CONTINUE AT LOOK1

VARS1:	JSR	R1,TMATCH	;CHECK TOKENS
	BR	TABT1		;NO MATCH-ADD ENTRY TO SUBTABLE
	JSR	PC,TOKDEC	;MATCH-R3_ADDR OF VALUE
	BR	TABT2

PERSYM:	MOV	STAT(R0),R4	;R4 _ STATUS BITS FOR LEX ANALYZER
	MOVB	(R3),R1		;TOKEN USED TO POINT R1 INTO TOKETB TABLE
	ADD	#TOKETB,R1
	IFSIGN	(R1),PL,RESOLV,B  ;IF TOKETB TOKEN POS, RESOLVE AMBIGUITY
PERS1:	SUB	R0,R5		;DEBIAS LEXICAL POINTER
	MOV	R5,CLB(R0)	;OTHWS, ADVANCE LEX PTR TO NEXT TOKEN
	MOVB	(R1)+,TOKE(R0)	;SET TOKEN BYTE
	BISB	(R1)+,R4	;SET STATUS BITS FOR SYMB
	BICB	(R1),R4		;CLR STATUS BITS FOR SYMB
	CLR	R1		;NO - SET REST OF TOKEN
	BISB	-(R3),R1	;SET R1 - R1 IS STANDING IN FOR TOKA
	MOVB	-1(R3),XXMORE	;SAVE IN CASE OF MORE...
	IF  TOKE(R0),EQ,#BASTOK,LEXEX,B  ;BR IF GARDEN VARIETY BASIC TOKEN
	BGT	PERS2		;BR IF SYSTEM FUNCTION
	SWAB	R1		;MUST BE PI OR SOMETHING LIKE THAT
	BISB	-(R3),R1	;SET LOW BYTE
	BR	TABT5		;EXIT

PERS2:	CMPB	-(R3),-(R3)	;DEC PERM SYMB TABLE POINTER BY 2
	MOV	R3,R1		;AND RETURN PTR IN TOKA - EVENTUALLY
	BR	TABT5

RESOLV:	MOVB	(R1)+,R2	;DISPATCH TO APPROPRIATE RESOLUTION
	ADD	R2,PC		;	ROUTINE
OKNCND:	IFZERO	EQ,TLCOFL(R0),PERS1,B  ;SYMBOL O.K. IF NOT INSIDE CONDITIONAL COMPILATION
OKNCUN:	JMASK0	EQ,R4,CTUNF,PERS1  ;SYMBOL O.K. IF NOT IN OPERAND SLOT
BRTBT6:	BR	TABT6		;GO MAKE A VARIABLE

OKSUBT:	MOVB	(R1)+,R2	;WE'VE GONE TOO FAR - BACK UP
	SUB	R2,R5
	BR	PERS1		;AND USE FIRST PART OF SYMBOL

.SBTTL	LOOKUP - LOOK UP AN IDENTIFIER

;LOOKS UP LEX BUF SYMBOL BEGINNING AT CLB IN SYMBOL TABLE
;WHOSE BASE ADDRESS IS (R4) -
;CALLING SEQUENCE:
;	JSR	PC,LOOKUP
;	SUCCESS EXIT (2 BYTES)
;	FAILURE RETURN
;IN DESCENDING LOCATIONS, TABLE ENTRIES HAVE THE
;FORM:
;	1-BYTE OR WORD SELF-RELATIVE ADDR OF NEXT ENTRY
;	2ND THRU LAST CHARS OF SYMBOL TO BE MATCHED
;	1-BYTE NEGATIVE QUANTITY (MAY BE BYTE FOR TOKE OR PTR INTO TOKETB)
;	ANY NUMBER OF VALUE BYTES
;IF THE SEARCH IS SUCCESSFUL, R3 (STILL
;BIASED) POINTS TO NEGATIVE BYTE, AND R5 (BIASED)
;POINTS TO NEXT UNMATCHED LEX CHAR -
;IF THE SEARCH IS UNSUCCESSFUL, R3 POINTS TO THE LAST TABLE ENTRY, AND
;THERE IS A ONE-WORD SKIP ON EXIT - JSR PC

LOOKUP:	MOV	CLB(R0),R1	;R1_BEG LEX BUF
	ADD	R0,R1		;BIAS
	MOVB	(R1)+,R2	;R2_1ST CHAR OF SYMBOL
	ASL	R2
	ADD	R2,R4		;R4_TABLE BASE+CHAR OFFSET
LOOK1:	MOV	R1,R5		;INIT LEX PTR
	MOV	R4,R3		;INIT TABLE PTR
	IF  R3,LO,#QXLAST,LOOK7  ;R3 POINT ABOVE PERMANENT SYMBOL TABLE?

LOOK8:	IFZERO	EQ,(R3),LOOK3	;YES - TABLE ENTRY EXIST?
	ADD	(R3),R3		;YES - R3 _ ITS ADDRESS
LOOK6:	MOV	R3,R4		;SAVE PTR
LOOK2:	IFSIGN  -(R3),MI,LOOK9,B  ;CHAR IN TABLE ENTRY A TOKEN?
	IF	(R3),EQ,(R5)+,LOOK2,B ;TABLE CHAR = LEX CHAR?
	IF	(R3),NE,#SPACE,LOOK1,B ;MATCH FAIL - NO SPACE ALLOWED HERE

; HERE WE HAVE A SPACE ALLOWED IN THE IDENTIFIER, BUT NONE ACTUALLY PRESENT
; IN THE IDENTIFIER UNDER SCAN IN THE LEXICAL BUFFER.

	DEC	R5		;TRY LAST LEX CHAR AGAIN AFTER SPACE
	BR	LOOK2		;GO HERE TO DO IT

LOOK9:	NXTEND	EQ,LOOK4	;A MATCH IF NO EXTEND IN EFFECT
	MOVB	-1(R5),R2	;GET LAST CHAR OF SCANNED SYMBOL (OR PART OF SAME)
	JSR	PC,TSTCHR	;FIND OUT IF IT IS NONALPHANUMERIC ETC
	BVS	LOOK4		;A MATCH IF NONALPHANUMERIC
	MOVB	(R5),R2		;GET NEXT CHAR
	JSR	PC,TSTCHR	;FIND OUT IF IT IS ALPHANUMERIC
	BVC	LOOK1		;BETTER TRY FOR A SHORTER MATCH IF ALPHANUMERIC
	BR	LOOK4		;ELSE WE HAVE A MATCH

LOOK3:	ADD	#2,(SP)		;SKIP ON FAILURE
LOOK4:	BIS	#TABLEF,STAT(R0)  ;SET FLAG FOR EXIT FROM LOOKUP
	RTS	PC

LOOK7:	IF	R3,LO,#TOKETB,LOOK8	;IF NOT IN QX TABLE
	IFZERO	EQ,(R3),LOOK3,B	;BYTE COMPARE - TABLE ENTRY EXIST?
	MOVB	(R3),R3		;YES - R3 _ ITS ADDRESS
	ADD	R4,R3
	BR	LOOK6

;ROUTINE TO IMMEDIATELY FOLLOW LOOKUP IN USER
;SYMBOL TABLE - CHECKS TOKEN IN TABLE AGAINST
;TOKEN IN TOKE (BUILT BY DECVAR) - MATCH
;COMPLETE ONLY IF TOKENS MATCH - OTHERWISE,
;SEARCHS SUBTABLE OF SYMBOL BUILT FOR
;MATCHING TOKEN - SUBTABLE ENTRIES ARE:
;	1 - BYTE TOKEN
;	1 - BYTE TOKEN AGAIN IF NECESSARY TO MAKE ADDR EVEN
;	1 - WORD SELF-RELATIVE ADDR OF NEXT SUBTABLE ENTRY
;	ANY NUMBER OF VALUE WORDS
;AT EXIT TOKE CONTAINS THE TOKEN AND R3 (UNBIASED)
;POINTS AT THE ADDR WORD OF THE LAST SUBTABLE
;ENTRY - IF THERE IS A SUCCESSFUL MATCH,
;A WORD IS SKIPPED AT EXIT - STATUS IN STAT(R0) - JSR R1

TMATCH:	BIC	#1,R3		;DEC R3 IF R3 ODD
TM3:	IF	TOKE(R0),EQ,(R3),TM1,B	;TABLE TOKEN = (TOKE)?
	IFZERO  EQ,-(R3),TM2	;NO - NEXT SUBTABLE ENTRY EXIST?
	ADD	(R3),R3		;R3 _ POINT AT IT
	BR	TM3

TM1:	CMP	-(R3),(R1)+	;R3 <- VALUE AREA+2, SET SKIP ON SUCCESS
TM2:	SUB	R0,R3		;UNBIAS R3
	BIC	#TABLEF,STAT(R0)  ;UNSET FLAG FOR EXIT FROM TMATCH
	RTS	R1

.SBTTL	DECVAR - CHECK VARIABLE WELL-FORMEDNESS

;+
; DECVAR DECODES A VARIABLE NAME & CHECKS FOR WELL-FORMEDNESS. IT ALSO STORES
; THE TOKEN APPROPRIATE FOR THE SCANNED VARIABLE IN TOKE OR RETURNS AN ERROR IF
; THE VARIABLE IS NOT WELL-FORMED.
;
; ENTERED WITH:
;	JSR	PC
;	R0 CONTAINS SPDA
;	CLB(R0) POINTS TO NEXT LEXICAL CHARACTER
;
; EXIT WITH:
;	R0 & R1 PRESERVED
;	R2, R3, R4, & R5 DESTROYED
;	CLB(R0) ADVANCED PAST FN-PREFIX, IF ANY
;	TOKE(R0) SET TO APPROPRIATE TOKEN FOR VARIABLE
;	AFTER RETURN:
;	  (SP) POINTING AT 1+"PURE" SYMBOL END (IGNORING SYMBOL SUFFIX)
;	  2(SP) POINTING AT 1+WHOLE SYMBOL END (INCLUDING SUFFIX)
;-

	.ENABL	LSB

DECVAR:	MOV	CLB(R0),R5	;SET LEX PTR
	ADD	R0,R5		;BIAS
	CLR	R4		;CLR TOKEN
	BIS	#TOKF+FLOATF,R4	;SET TOKEN & FLOATING FLAGS
	MOVB	(R5)+,R2	;R2 _ 1ST CHAR
	IF	R2,NE,#'F,DEC1,B  ;POSS FN-NAME?
	MOVB	(R5)+,R2	;YES - GET NEXT CHAR
	IF	R2,NE,#'N,DEC2,B  ;FN - NAME?
	BIS	#FUNCF,R4	;YES - SET FN & INDEX BITS
	ADD	#2,CLB(R0)	;BYPASS FN-PREFIX
	MOVB	(R5)+,R2	;GET NEXT CHAR
DEC1:	JSR	PC,TST01
	BVS	DECERR		;A LETTER?
	MOVB	(R5)+,R2	;GET NEXT CHAR
DEC2:	JSR	PC,TSTCHR
	BEQ	1$		;BR IF CHAR A DIGIT
	BVS	2003$		;NO ALPHA - NO DICE
	NXTEND	EQ,2003$	;NO ALPHAS IF NO EXTEND

; WE GET HERE IF: (1) NO EXTEND IS IN EFFECT AND THE 2ND CHAR IS NUMERIC, OR
; (2) EXTEND IS IN EFFECT AND WE HAVE A LEGAL IDENTIFIER SO FAR.

1$:	MOVB	(R5)+,R2	;GET THE NEXT CHAR
	NXTEND	NE,DEC2		;AND TRY FOR MORE IN EXTEND MODE

; WE GET HERE WHEN THE WHOLE SYMBOL NAME HAS BEEN SCANNED OFF EXCEPT PERHAPS
; THE TYPE PREFIX. BY DEFINITION, HERE AND NOW, THIS CONSTITUTES THE END OF
; THE SCAN OF THE "PURE" IDENTIFIER.

2003$:	MOV	R5,R3		;1+CURRENT BUFFER LOCATION
	SUB	R0,R3		;DEBIASED
	DEC	R3		;1+END OF "PURE" SYMBOL
	SUB	CLB(R0),R3	;1+LENGTH OF "PURE" IDENTIFIER
	IF	R3,GT,#SYMMAX,DECERR ;TOO LONG IS TOO BAD
	ADD	CLB(R0),R3	;RECOVER 1+END OF "PURE" SYMBOL
	IF	R2,NE,#'%,DEC4,B ;INT VAR?
	BIS	#INTGF,R4	;YES - SET BIT
	BR	DEC5

DEC4:	IF	R2,NE,#'$,DEC6,B	;STRING VAR?
	BIS	#STRINF,R4	;YES - SET FLAG
DEC5:	BIC	#FLOATF,R4	;CLR FLOATING FLAG
	MOVB	(R5)+,R2	;NEXT CHAR
DEC6:	IF	R2,EQ,#'(,DEC7,B	;INDEXED?
	IF	R2,EQ,#'[,DEC7,B	;REALLY INDEXED??
	JMASK0	NE,STAT(R0),ARF,DEC7  ;NO - ARRAY FLAG SET?
	JMASK0  EQ,STAT(R0),HARF,DEC8  ;NO - FLOAT & INT ARRAY FLAG SET?
	JMASK0  NE,R4,STRINF,DEC8  ;YES - STRING VARIABLE?
DEC7:	JMASK0	NE,R4,FUNCF,DEC8  ;SKIP SETTING INDEXF IF A FUNCTION
	BIS	#INDEXF,R4	;NO - SET INDEX FLAG
DEC8:	DEC	R5		;BACK UP LEX PTR
	SUB	R0,R5		;UNBIAS
	MOVB	R4,TOKE(R0)	;TOKE _ TOKEN
	MOV	(SP),-(SP)	;SAVE RETURN ADDRESS
	MOV	R5,2(SP)	;SAVE END OF FULL LEX ITEM
	JSR	R3,@(SP)+	;SAVE PTR TO END OF "PURE" SYMBOL

DECERR:	MOV	R1RING,R1	;RESTORE R1 FOR ERROR ROUTINE
	ERROR	COSERR,FATAL	;BAD CHARACTER OR SYMBOL ERROR

	.DSABL	LSB

.SBTTL	ADDVAR - ADD USER VARIABLE TO SYMBOL TABLE

;+
; ADDVAR ADDS A VARIABLE TO THE SYMBOL TABLE. IF THE "PURE" PART OF THE NAME
; (SANS PREFIXES AND/OR SUFFIXES) HAS NOT APPEARED BEFORE, IT IS ADDED TO THE
; TABLE ALONG WITH ITS TOKEN AND VALUE SLOT. IF THE "PURE" NAME HAS APPEARED
; BEFORE (FOR EXAMPLE IF THE A IN A$ HAS APPEARED BEFORE IN A%), THEN ONLY THE
; TOKEN AND VALUE SLOT ARE ADDED. IN THIS LATTER CASE, THE TOKEN IS POINTED AT
; BY A POINTER ASSOCIATED WITH THE "PURE" PART OF THE NAME AND IS REFERRED TO AS
; A "SUBTABLE" ENTRY. ENTRIES CONTAINING A PURE NAME AS WELL ARE CALLED "TABLE"
; ENTRIES. A FEW RULES ABOUT ENTRIES SHOULD BE REMEMBERED:
;
; (1) TABLE ENTRIES BUILD DOWN IN CORE STARTING WITH A FULL-WORD SELF-RELATIVE
; POINTER TO THE NEXT TABLE ENTRY WHOSE "PURE" NAME BEGINS WITH THE SAME LETTER.
;
; (2) WORKING DOWN THE 2ND THRU N-TH CHARACTERS OF THE "PURE" NAME ARE STORED
; IN SUCCEEDING BYTES.
;
; (3) IMMEDIATELY FOLLOWING THE LAST "PURE" NAME CHARACTER IS THE TOKEN VALUE
; FOR THE SYMBOL, WHICH IF IN THE HIGH BYTE OF ITS WORD, IS COPIED INTO THE
; LOW BYTE AS WELL.
;
; (4) THE TABLE ENTRY WORD CONTAINING THE TOKEN MAY BE THOUGHT OF AS THE FIRST
; WORD OF THE SUBTABLE ENTRY ASSOCIATED WITH THE FIRST SYMBOL FOUND HAVING THE
; ASSOCIATED "PURE" NAME. THIS WORD ALWAYS HAS A TOKEN VALUE IN ITS LOW BYTE.
;
; (5) THE NEXT SUBTABLE ENTRY WORD HAS A SELF-RELATIVE POINTER TO THE SUBTABLE
; ENTRY FOR THE NEXT SYMBOL HAVING THE SAME "PURE" NAME.
;
; (6) FINALLY COMES THE VARIABLE'S VALUE SLOT - OF WHATEVER SIZE IS NECESSARY
; FOR THE TYPE OF VARIABLE REPRESENTED.
;
; ENTERED WITH:
;	JSR	PC,ADDVAR
;	R0 SET TO SPDA
;	R3 POINTING AT POINTER-TO-BE TO ENTRY WE ARE ABOUT TO BUILD (WHETHER
;		TABLE OR SUBTABLE) (UNBIASED)
;	2(SP) (AFTER ENTRY) SET TO 1+"PURE" VARIABLE NAME END (UNBIASED)
;	CLB(R0) SET TO "PURE" VARIABLE NAME START (UNBIASED)
;	STAT(R0) WITH BIT TABLEF SET IF FULL "PURE" NAME TO BE ADDED
;
; EXIT WITH:
;	R0 SET TO SPDA
;	R3 POINTING AT VARIABLE VALUE SLOT (UNBIASED)
;	R1, R2, R4, & R5 DESTROYED
;	NEW ENTRY ADDED TO TABLE OR SUBTABLE
;		HEADER (IF ANY) LINKED INTO STRING LIST
;-


ADDVAR:	MOV	R3,R1		;R1 _ ADDR PTR TO NEW ENTRY
	JSR	PC,FRESPC	;R3 _ ADDR LAST WORD IN TABLE AREA
	ADD	R0,R1		;BIAS R1 & R3
	ADD	R0,R3
	CLR	-(R3)		;CLR 1ST WORD IN NEW ENTRY
	MOV	R3,(R1)		;SET RELATIVE POINTER TO
	SUB	R1,(R1)		;NEW ENTRY
	JMASK0	EQ,STAT(R0),TABLEF,ADV1 ;BR IF SUBTABLE ENTRY
	MOV	2(SP),R1	;1+END OF "PURE" SYMBOL
	MOV	CLB(R0),R5	;CURRENT LEXICAL POINTER
	SUB	R5,R1		;NUMBER OF CHARS TO COPY
	INC	R5		;START WITH 2ND CHAR
	ADD	R0,R5		;BIAS CHAR POINTER
	BR	2$		;INTO MIDDLE OF IDENTIFIER-BUILD LOOP

1001$:	MOVB	(R5)+,-(R3)	;MOVE A CHARACTER
2$:	SOB	R1,1001$	;UNTIL THERE ARE NO MORE TO MOVE

	MOVB	TOKE(R0),-(R3)	;SET UP THE TOKEN
	BIC	#1,R3		;POINT AT LOW BYTE IN WORD

; WE GET HERE WHEN IT IS TIME TO BUILD A SUBTABLE ENTRY. R3 TELLS WHERE.

ADV1:	MOV	TOKE(R0),R5	;SAVE TOKE IN R5
	MOVB	R5,(R3)		;PUT TOKE IN NEW ENTRY
	CLR	-(R3)		;CLR NEXT SUBTABLE ENT ADDR
	JSR	PC,MAPTOK	;R2 SET TO TOKEN INDEX
	MOVB	INCTAB(R2),R2	;R2 SET TO LENGTH OF VALUE SLOT IN BYTES
	ASR	R2		;IN WORDS
1003$:	CLR	-(R3)		;CLEAR OUT VALUE AREA TO AVOID CRASHES
	SOB	R2,1003$	;UNTIL WHOLE VALUE SLOT CLEARED

	JMASK0	EQ,R5,INDEXF,ADV3  ;BR IF NOT AN ARRAY VARIABLE
	BIC	#177770,R5	;SAVE STRING - FLOAT - INTEGER BITS
	MOVB	TYTB(R5),ARYFLG(R3)  ;SET TYPE INFO IN ARRAY HEADER FLAG BYTE
	MOV	#10.,PDIM2(R3)	;MAKE IT A NONVECTOR INITIALLY
	JSR	PC,ZARRY4	;SO SYSTEM WON'T CRASH ON IMMED ARRAYS
ADV3:	;BR	LISHED		;EXIT THRU LISHED

;IF A NEW STRING OR ARRAY HEADER IS POINTED AT BY R3
;AND THE TOKEN IN TOKE INDICATES THAT IT IS INDEED
;SUCH A HEADER, IT IS ADDED TO THE HEADER LIST -

LISHED:	MOV	R3,-(SP)		;SAVE R3
	MOV	R5,-(SP)		;AND R5
	MOV	TOKE(R0),R5		;R5 _ TOKEN FLAG WORDS
	JMASK0	EQ,R5,FUNCF,LISH2	;FUNCTION?
	ADD	#4,R3			;ADVANCE FUNCTION PTR TO VALUE
LISH2:	JMASK0	EQ,R5,STRINF+INDEXF,LISH1	;NO - STRING OR ARRAY?
LISH3:	MOV	R0,R1			;ABS ADDRESS NEXT LINK
	JMASK0	EQ,R5,INDEXF,LISH4	;BRANCH IF NOT ARRAY
	ADD	#ARYPTR,R1		;REORIGIN A LITTLE FOR ARRAY HEADER LIST
LISH4:	ADD	(R1),R0			;ABS ADDRESS NEXT LINK
	IF	R0,LO,R1CORG,LISH3	;DROP DOWN IF NEXT HEADER ON R1 STACK
	SUB	R3,R0			;NEXT RELATIVE TO NEW
	MOV	R0,(R3)+		;DEPOSIT NEW LINK
	JMASK0	NE,R5,DATAF,LISH5,B	;BR IF A DATA STRING
	CLR	(R3)+			;IN MEMORIUM, JWS
LISH5:	SUB	R0,(R1)			;NEW LINK RELATIVE TO CURRENT
	MOV	SPDA,R0			;RESTORE BIAS (+5V)
LISH1:	MOV	(SP)+,R5		;RESTORE R5
	MOV	(SP)+,R3		;RESTORE R3
	SUB	R0,R3			;UNBIAS
	MOV	R3,NEXFRE(R0)		;NEXFRE_ ADDRESS LAST WORD OF NEW ENTRY
	RTS	PC

;SETS R3 TO POINT AT LAST WORD USED IN VARIABLE
;TABLE & HEADER SPACE - CHECKS TO SEE THAT THERE ARE
;SUFFICIENT BYTES TO MAKE A NEW ENTRY - IF NOT,
;CALLS THE ALLOCATOR - DANGEROUS, CAN AFFECT SPDA - JSR PC

FRESPC:	MOV	SPCLIM(R0),R3	;R3 _ AREA LIMIT
	ADD	#SLOP,R3	;LESS SLOP
	IF	R3,LOS,NEXFRE(R0),FRES1  ;ENOUGH AREA LEFT?
	MOV	R1,-(SP)	;SET UP REAL R1
	MOV	R1RING,R1	;FOR RECYCL
	JSR	R5,ECONOM	;CALL STORAGE CONTROLLER
	+	HDRNOM		;FOR STR HEADER SPACE
	MOV	(SP)+,R1	;THE WAY THEY WERE
FRES1:	MOV	NEXFRE(R0),R3	;R3 _ ADDR LAST WORD USED
	RTS	PC

;THE FOLLOWING ROUTINE CHECKS FOR UNARY PLUS &
;MINUS, BINARY MINUS, AND NUMBERHOOD -
;MOVES CLB PAST REDUNDANT SIGNS, DUMMYING IN A
;UNARY MINUS IF NECESSARY - CHANGES BINARY MINUS
;TO BMIN, A DUMMY CHAR - SETS NUMBF FLAG IN R4
;IF AT NUMBER - ASSUMES R5 (ABSOLUTE) POINTS TO,
;AND R2 CONTAINS,
;NEXT LEX CHAR - DESTROYS R2 & R5 - JSR PC

NMSCAN:	BIC	#NUMBF,R4	;CLR NUMBER FLAG
	CLR	-(SP)		;CLR SIGN FLAG
	JMASK0	EQ,R4,CTUNF,NMSCX4  ;CONVERT TO UNARY FLAG ON?
NMSC0:	MOVB	(R5)+,R2	;YES - R2_CUR LEX CHAR
	IF  R2,EQ,#'+,NMSC0,B	;UNARY PLUS?
	IF  R2,NE,#'-,NMSCX,B	;NO - UNARY MINUS?
	COM	(SP)		;YES - COMPLEMENT SIGN FLAG
	BR	NMSC0		;GO AROUND AGAIN

NMSCX:	TSTB	-(R5)		;BACK UP R5
NMSCX2:	TST	(SP)+		;POP SIGN FLAG
	BEQ	NMSCX3		;NEGATIVE?
	MOVB	#'-,-(R5)	;YES - DUMMY A UNARY MINUS INTO LEX BUF
	MOVB	(R5),R2		;RESET CHARACTER
NMSCX3:	IF  R2,EQ,#'.,NMSCX1,B	;CHAR A DECIMAL POINT?
	JSR	PC,TST00	;NO - 
	BNE	NMSCX5		;A DIGIT?
NMSCX1:	BIS	#NUMBF,R4	;SET NUMBER FLAG
NMSCX5:	SUB	R0,R5		;UNBIAS R5
	MOV	R5,CLB(R0)	;ADJUST LEX PTR
	RTS	PC

NMSCX4:	IF  R2,NE,#'-,NMSCX2,B  ;CHAR A BINARY MINUS?
	MOVB	#BMIN,(R5)	;YES - DUMMY IN A SPECIAL BINARY MINUS
	BR	NMSCX2

;+
; GET NEXT INPUT CHARACTER FILTERING OUT FUNNY MATCHES TO ENDCHR
; AND/OR BUMCHR. ALSO, IGNORE LEADING CHARACTERS OF ASCII CODE
; LESS THAN OR EQUAL TO SPACE ON A NEW LINE. IF LINE STARTS WITH
; A NON-DIGIT THEN GUESS AT IMMEDIATE MODE.
;
; R0 =  SPDA
; R1 -> R1 STACK
; R4 =  STATUS
; JSR	PC,GETCHR
; R2 =  CHARACTER
;-

GETCHR:	JSR	PC,EDFTCH		;FETCH CHARACTER FROM EDITOR
	MOV	(R1)+,R2		;PLACE IT HERE AND
	BIC	#-177-1,R2		; TRIM ANY PARITY BIT OFF
	IF	R2,EQ,#ENDCHR,GETCHR,B	;IGNORE IF ENDCHR CONFLICT
	IF	R2,EQ,#BUMCHR,GETCHR,B	;IGNORE IF BUMCHR CONFLICT
	JMASK0	EQ,R4,BLINEF,10$	;ALL DONE IF NOT LINE'S START
	IF	R2,LOS,#SPACE,GETCHR,B	;ELSE IGNORE ALL <=SPACE
	DEC	R4			;IF >SPACE THEN REAL LINE START
.IIF	NE	BLINEF-1,	.ERROR	;THE ABOVE WON'T WORK !!!
	JSR	PC,TST00		;DOES LINE BEGIN WITH DIGIT?
	BEQ	10$			;YES, DIGIT, NOT IMMEDIATE MODE
	BIS	#IMMEDF,R4		;NO, NON-DIGIT, IMMEDIATE MODE
10$:	RTS	PC			;NOW EXIT

;+
; STORE THE CHARACTER IN THE .TMP FILE IF NOT IMMEDIATE MODE
; AND IF NOT A CONTROL CHARACTER OUTSIDE OF QUOTES
;
; R0 =  SPDA
; R1 -> R1 STACK
; R2 =  CHARACTER
; R4 =  STATUS
; JSR	PC,STOCHR
;-

.ENABL	LSB

STOCHR:	IFSIGN	R4,MI,STOBYT		;ALWAYS STORE IF INSIDE QUOTES
	IF	R2,EQ,#TAB,STOBYT,B	;AND ALWAYS STORE TABS
	IF	R2,LO,#SPACE,10$,B	;SKIP STORING IF CONTROL CHAR

;+
; STORE THE CHARACTER IN THE .TMP FILE IF NOT IMMEDIATE MODE
;
; R0 = SPDA
; R1 -> R1 STACK
; R2 =  CHARACTER
; R4 =  STATUS
; JSR	PC,STOBYT
;-

STOBYT:	JMASK0	NE,R4,IMMEDF,10$	;SKIP STORING IF IMMEDIATE MODE
	JSR	PC,EDSTOR		;ELSE STORE CHAR IN THE .TMP FILE
10$:	JMP	SPDAR0			;SPDA TO R0; RTS PC

.DSABL	LSB

;+
; FILCLB - FILLS THE LEXICAL BUFFER
;
; R0 =  SPDA
; R1 -> R1 STACK
; R4 =  STATUS
; JSR	PC,FILCLB
; R2, R3, R5 DESTROYED
; CLB(R0) RESET TO LEX BUFFER START
;-

.ENABL	LSB


5$:	TST	R5			;IS THIS THE FIRST LEX "!"?
	BNE	25$			;NO
	MOV	R2,R5			;YES, REMEMBER ITS POSITION
	BR	25$			; THEN CONTINUE

10$:	BIC	#QUOTF,R4		; START OUTSIDE OF QUOTES
	MOV	R4,-(SP)		; AND SAVE STATUS
	MOV	R3,R2			;COPY BUFFER START POINTER
	MOV	R3,-(SP)		; AND SAVE BUFFER START
	CLR	R5			;SAY NO "!" FOUND YET
20$:	MOVB	(R3)+,(R2)		;MOVE A BYTE
	MOV	R2,-(SP)		; SAVE THE DESTINATION POINTER
	MOVB	(R2),R2			; SO WE CAN GET THE CHARACTER
	JSR	PC,QTEST		; DO QUOTE CHECKING
	MOV	(SP)+,R2		; RESTORE DESTINATION POINTER
	TST	R4			; IN QUOTES, NOT A LEXICAL CHARACTER...
	BMI	30$
.ASSUME	QUOTF	EQ	100000
	CMPB	(R2),#COM		; IS IT A COMMENT?
	BEQ	5$			; IT'S A LEXICAL "!"
	CMPB	(R2),#SPACE		; IS IT A SPACE
	BNE	25$			; NOPE, OTHER
	NXTEND	EQ,20$			;NO EXTEND => NO LEX SPACES
	CMPB	(R2),(R3)		;EXTEND, IS NEXT ALSO A LEXICAL SPACE?
	BEQ	20$			;YES, IGNORE THIS ONE
25$:	IF	(R2),LT,#140,30$,B	; IS IT 'LOWER CASE'?
	BICB	#40,(R2)		;YES; UPCASE IT
30$:	IF	(R2)+,EQ,#ENDCHR,40$,B	;DONE IF ENDCHR
	IF	-1(R2),NE,#BUMCHR,20$,B ;LOOP IF NOT BUMCHR
40$:	CLRB	(R2)			;FLAG END WITH A 0 BYTE
	MOV	(SP)+,R3		;RESTORE BUFFER START PTR
	NXTEND	EQ,60$			;EXIT NOW IF NOT EXTEND MODE
	IF	-(R2),NE,#ENDCHR,60$,B	;IF NOT ENDCHR THEN QUIT
50$:	IF	-(R2),EQ,#SPACE,50$,B	;IGNORE TRAILING SPACES
	IF	(R2),EQ,#TAB,50$,B	;IGNORE TRAILING TABS
	IF	(R2),NE,#'&,60$,B	;IF NOT & THEN NOTHING SPECIAL
	IF	R2,LO,R3,60$		;IF UNDERFLOW THEN QUIT TOO
	MOVB	#BUMCHR,(R2)+		;ELSE SET <BUMCHR>
	CLRB	(R2)			; AND FLAG IT AS THE REAL END
	INC	CONCNT			;COUNT AS A CONTINUATION LINE
	TST	R5			;DID WE FIND A LEX "!"?
	BEQ	60$			;NO
	MOVB	#BUMCHR,(R5)+		;REPLACE "!" WITH BUMCHR
	CLRB	(R5)			; AND FLAG IT AS THE NEW REAL END
60$:	MOV	(SP)+,R4		; RESTORE STATUS (W/ QUOTF CLEAR)
	RTS	PC			;THEN EXIT

FILCLB:	MOV	#PHLB,R5		;GET (UNBIASED) START OF LEX BUFFER
	MOV	R5,CLB(R0)		;AND RESET LA'S POINTER
	BIC	#QUOTF,R4		;START OUTSIDE OF QUOTES
70$:	JSR	PC,GETCHR		;GET A CHARACTER
80$:	MOV	#200$,R3		;GET ADDRESS OF COMPARE LIST
	IF	R2,NE,(R3)+,90$,B	;IF NOT <CR> THEN CONTINUE
	JSR	PC,GETCHR		;IF <CR> THEN GET NEXT CHARACTER
	IF	R2,NE,(R3)+,80$,B	;IF NOT <CR><LF> THEN RETRY...
	CMP	(R3)+,(R3)+		;IT IS <CR><LF>, ADVANCE PTR
	BR	100$			; 4 CHARS TO: <CR><LF><ENDCHR>

90$:	IF	R2,NE,(R3)+,130$,B	;IF NOT <LF> THEN CONTINUE
	JSR	PC,STOBYT		;IF <LF> THEN STORE THE <LF>
	MOV	#220$,R3		;AND POINT TO: <CR><NULL><BUMCHR>
100$:	MOVB	(R3)+,R2		;GET THE NEXT
	JSR	PC,STOBYT		; TWO CHARACTERS FROM THE
	MOVB	(R3)+,R2		;  LIST AND STORE THEM IN THE
110$:	JSR	PC,STOBYT		;   .TMP FILE
	MOVB	(R3)+,R2		;NOW GET THE FINAL CHARACTER
	JSR	PC,170$			;AND STORE IT INTO LEX BUFFER
	MOV	#PHLB,R3		;GET (UNBIASED) LEX BUF START
	SUB	R3,R5			;FIND LINE LENGTH
	ADD	R0,R3			;MAKE BUFFER START ABSOLUTE
	DEC	R5			;CORRECT LENGTH FOR ENDCHR/BUMCHR
	BEQ	10$			;LENGTH=0, SKIP CCL CHECK
	JMASK0	EQ,R4,IMMEDF,10$	;SKIP CCL CHECK IF NOT IMMED MODE
	JMASK0	NE,R4,QUOT1F,10$	;SKIP CCL CHECK IF 'QUOTED'
	BIT	#EDCOMP,EDFLAG		;INPUT FROM A .BAS FILE?
	BNE	10$			;SKIP CCL CHECK IF FROM .BAS FILE
	MOV	#XRB+XRLOC,R2		;ELSE GET XRB POINTER @ XRLOC
	MOV	R3,(R2)			;AND STORE START @ XRLOC
	MOV	R5,-(R2)		;SET XRBC TO LENGTH AND
	MOV	R5,-(R2)		; SET XRLEN TO LENGTH
	.CCL				;ASK MONITOR FOR A CCL CHECK
	TSTB	IOSTS			;NOT CCL, IS IT AN ERROR?
	BEQ	10$			;NO ERROR, CONTINUE
	IOTERR	!FATAL			;ERROR, SO SAY ERROR

120$:	MOV	#210$,R3		;NON-STD DELIMITER, POINT TO
	BR	110$			; <ENDCHR> BUT STORE THE DELIMITER

130$:	IF	R2,EQ,(R3)+,120$,B	;IS IT A NON-STD DELIMITER?
	IFZERO	NE,(R3),130$,B		;IF NOT END-OF-LIST THEN LOOP

	TSTB	R2			;IS THIS A NULL BYTE?
	BEQ	70$			;YES, TOTALLY IGNORE IT
	JSR	PC,STOCHR		;ELSE STORE CHARACTER IN .TMP FILE
	JSR	PC,QTEST		;CHECK FOR QUOTED STRINGS
	BMI	160$			;INSIDE QUOTES, KEEP IT
	CMPB	R2,#SPACE		;CHECK FOR SPACE OR CONTROL CHAR
	BHI	160$			;NON-SPACE/CONTROL, KEEP IT
	BEQ	140$			;SPACE
	IF	R2,NE,#TAB,70$,B	;IGNORE ALL BUT TABS BY NOW
	MOV	#SPACE,R2		;TABS BECOMES SPACES
140$:	IF	R5,EQ,#PHLB,70$		;IGNORE LEADING LEXICAL SPACES
160$:	MOV	#70$,-(SP)		;LOOP AFTER STORING INTO LEX BUF
170$:	IF	R5,HIS,#PHLB+LINBUF-1,190$ ;ERROR IF ABOUT TO STORE TO MUCH
	ADD	R0,R5			;MAKE LEX BUF PTR ABSOLUTE
	MOVB	R2,(R5)+		;THEN STORE INTO LEX BUFFER
	SUB	R0,R5			;MAKE LEX BUF PTR REL AGAIN
	RTS	PC			;THEN EXIT

190$:	ERROR	TLCNTD,FATAL		;USER TRYED TO STORE TOO MUCH

200$:	.BYTE	CR,ASCLF
	.BYTE	ALT,CTRZ,14,0
	.BYTE	CR,ASCLF
210$:	.BYTE	ENDCHR

220$:	.BYTE	CR,0,BUMCHR
	.EVEN

.DSABL	LSB

;SETS AND UNSETS QUOTF & QUOT1F (THE QUOTE FLAGS) IN THE OBVIOUS
;WAY DEPENDING ON THE CHAR IN R2 - SETS N ON QUOTF -
;AND CLRS Z ON QUOTF OR QUOT1F - ASSUMES STATUS IN R4 - JSR PC

QTEST:	IFSIGN R4,MI,QTST1	;QUOTF FLAG SET?
	IF	R2,EQ,#QUOTE,QTST2,B	;NO-CHAR A QUOTE?
	IF	R2,NE,#APOS,QTST6,B	;NO-AN APOSTROPHE?
QTST2:	MOVB	R2,UNQUOT(R0)		;YES-SAVE CHAR TO UNQUOTE
	BIS	#QUOTF,R4		;SET QUOTF
	BR	QTST3

QTST1:	IF	R2,EQ,UNQUOT(R0),QTST5,B	;CHAR THE UNQUOTE CHAR?
QTST6:	IF  R2,EQ,#BUMCHR,QTST4,B  ;BR IF AT END OF SUBLINE
	IF	R2,NE,#ENDCHR,QTST3,B	;NO-A ENDCHR?
QTST4:	BIC	#QUOT1F,R4	;YES CLR QUOTIF
QTST5:	BIC	#QUOTF,R4		;CLR QUOTF
QTST3:	BIT	#QUOTF+QUOT1F,R4  ;SET N ON QUOTF, CLR Z ON QUOTF OR QUOT1F
	RTS	PC

;DECREMENTS R3 BY AN AMOUNT EQUAL TO THE LENGTH OF THE
;DATA OR VARIABLE VALUE (OR HEADER, ETC) ASSOCIATED WITH
;THE TOKEN IN TOKE - DESTROYS R2 - JSR PC

TOKDEC:	JSR	PC,MAPTOK		;DECODE TOKEN
	MOVB	INCTAB(R2),R2	;R2_LENGTH OF ITEM OR HEADER
	SUB	R2,R3		;ADJUST R3 FOR THAT LENGTH
	RTS	PC

;MAPS DATA AND VARIABLE TOKENS INTO OCTAL DIGITS
;FOR TABLE DISPATCHING - ASSUMES TOKEN IN
;TOKE - RETURNS VALUE IN R2 - MAPPING:
;INTEGER  0	FLOATING 1	STRING 2
;ARRAY	3			INTG-VALUED FUNCTION 4
;FLTG-VALUED FUNCTION 5		STRING-VALUED FUNCTION 6
;CALLED WITH JSR PC

MAPTOK:	CLR	R2		;CLR  R2
	MOV	R5,-(SP)	;SAVE R5
	MOV	TOKE(R0),R5	;R5_TOKEN
	BIC	#177740,R5	;STRIP IRRELEVANT BITS
	JMASK0	EQ,R5,FUNCF,MAPT1  ;A FUNCTION?
	CMP	(R2)+,(R2)+	;YES - SET R2 TO 4
	BIC	#FUNCF,R5	;KNOCK OFF FUNCTION BITS
MAPT1:	DEC	R2		;DEC R2 TO GET OFF ON RIGHT FOOT
MAPT2:	INC	R2		;INCREMENT VALUE
	ASR	R5		;SHIFT A BIT OFF THE END
	BNE	MAPT2		;BITS FINISHED?
	MOV	(SP)+,R5	;YES - RESTORE R5
	RTS	PC		;EXIT WITH VALUE IN R2

;GOES THRU THE VARIABLE TABLE TO 0 VARIABLES
;SAVES REGISTERS - JSR PC

PRESET:	JSR	R5,SAVREG	;SAVE REGISTERS
	MOV	SPDA,R0		;SET BASE REGISTER
	CLR	DUMSTR(R0)	;IN CASE THERE ARE STRING ARRAYS
	MOV	#VARTAB,R5	;R5_ADDR FIRST ENTRY
PRES2:	IF  R5,NE,#VARTAB+52.,PRES1  ;DISP TABLE DONE?
	JSR	R5,RESREG	;YES - EXIT
	RTS	PC

PRES1:	MOV	R5,R1		;R1_REL ENTRY ADDR
	ADD	R0,R1		;BIAS R1
	TST	(R5)+		;R5_ADDR NEXT DISP TABLE ENTRY
PRES3:	IFZERO  EQ,(R1),PRES2	;TABLE ENTRY EXIST?
	ADD	(R1),R1		;YES - -POINT AT IT
	MOV	R1,R4
1001$:	JMASK0	EQ,-(R4),TOKF,1001$ ;ROUND & ROUND TILL TOKEN FOUND
PRES4:	MOV	(R4),TOKE(R0)	;SET TOKE TO TOKEN
	TST	-(R4)		;R4_ADDR OF LINK TO NEXT SUBTABLE ENTRY
	MOV	R4,R3
	JSR	PC,TOKDEC	;R3_ADDR OF VALUE
	JSR	PC,TOKZIP	;ZERO THE VALUE
	IFZERO  EQ,(R4),PRES3	;NEXT SUBTABLE ENTRY EXIST?
	ADD	(R4),R4		;YES - R4_ADDR NEXT SUBTABLE ENTRY
	BR	PRES4

;+
; TSTCHR SETS CONDITION BITS DEPENDING ON THE CHARACTER IN R2.
;	Z-BIT ON, V-BIT OFF IF NUMERIC
;	NO BITS ON IF ALPHABETIC OR PERIOD
;	V-BIT SET OTHERWISE
;
; ENTERED WITH:
;	JSR	PC,TSTCHR
;	R2 CONTAINING CHAR TO TEST
;
; EXIT WITH:
;	ALL REGISTERS PRESERVED
;	CONDITION CODES SET AS DESCRIBED ABOVE
;-

TSTCHR:	JSR	PC,TST00	;TEST ALPHANUMERIC
	BVC	TST04		;EXIT IF ALPHANUMERIC
	IF	R2,NE,#'.,TST03	;NONE OF THE ABOVE - SET THE V-BIT
	BR	TST05		;PERIOD LOOKS JUST LIKE ALPHABETICS

; TSTCH - TST00, TEST ALPHABETIC VS NUMERIC IN R2
;	REGISTERS USED - R2
TST00:	CMP	R2,#'0		;CHECK NUMERIC
	BLT	TST03		;NON-NUMERIC
	CMP	R2,#'9		;CHECK ALPHA
	BGT	TST01		;NON-NUMERIC
	SEZ			;SET ZERO CODE IF NUMERIC
	RTS	PC

TST01:	CMP	R2,#'A		;ALPHABETIC?
	BLT	TST03		;NO
	CMP	R2,#'Z		;ALPHABETIC?
	BGT	TST03		;NO
TST05:	CCC			;SET NON-ZERO CODE IF ALPHABETIC
	RTS	PC

TST03:	CCC
	SEV			;SET
TST04:	RTS	PC		;OVERFLOW IF NEITHER

.END

