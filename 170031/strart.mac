TITLE	STRART,<STRING ARITHMETIC FUNCTIONS>,08,13-MAY-86,TVG

;                   Copyright 1974,1990 by Digital Equipment Corporation
;                                  All rights reserved.
;
;          This software is furnished under a license and may be used and copied
;          only  in  accordance  with  the  terms  of  such license and with the
;          inclusion of the above copyright notice.  This software or any copies
;          shall not be provided to any other person.   No title to or ownership
;          of the software is hereby transferred.
;
;          The information in this software is subject to change without notice.
;
;          DIGITAL  assumes  no  responsibility  for the  use, functionality, or
;          reliability of its  software  on equipment  which  is not supplied by
;          DIGITAL.

.ENABL	AMA			;ABSOLUTE MODE ASSEMBLY
.NLIST	CND			;NO LISTING OF CONDITIONALS
.LIST	MEB			;LIST MACRO BINARY EXPANSIONS

;+
; STRART CONTAINS THE MAIN ROUTINES FOR EXECUTING STRING ARITHMETIC FUNCTIONS.
;-

.GLOBL	INTFUN,PSTJS,MID6,BUILDS
.GLOBL	RESREG,SAVREG

;+
; PUSH AND POP PUSH AND POP RESPECITIVELY ARGUMENTS TO AND FROM THE SP STACK.
; IT IS ASSUMED THAT IF THERE ARE MORE THAN TWO ARGUMENTS IN THE PUSH OR
; POP LIST, A GENERAL ALL-REGISTER PUSH OR POP IS DESIRED.
;-

.MACRO	PUSH	A
	.NARGS	A
.IF LE <NARGS-2>
	.IRP	X,<A>
.IIF NB X,	  MOV	X,-(SP)
	.ENDM
.IFF
	  JSR	R5,SAVREG
.ENDC
.ENDM	PUSH

.MACRO	POP	A
	.NARGS	A
.IF LE <NARGS-2>
	.IRP	X,<A>
.IIF NB X,	  MOV	(SP)+,X
	.ENDM
.IFF
	  JSR	R5,RESREG
.ENDC
.ENDM	POP

.SBTTL	PUSHPOPS DEFINED FOR STRING ARITHMETIC

	ORG	PT,0

..	PPSUM$,SUM$		;ARITHMETIC SUM OF TWO STRINGS
..	PPDIF$,DIF$		;ARITHMETIC DIFFERENCE OF TWO STRINGS
..	PPROD$,PROD$		;ARITHMETIC PRODUCT OF TWO STRINGS
..	PPQUO$,QUO$		;ARITHMETIC QUOTIENT OF TWO STRINGS
..	PPCOM$,COMP.$		;ARITHMETIC COMPARISON OF TWO STRINGS
..	PPLAC$,PLACE$		;STRING ARITHMETIC ROUND/TRUNCATE FUNCTION

.EQUATE	$MXLEN,	60.		;MAXIMUM NUMERIC STRING LENGTH (<=62)

	DEFORG	SF



.SBTTL	COMP.$ - ARITHMETIC STRING COMPARE

;+
; COMP.$ COMPARES THE NEXT-TO-TOP STRING ON THE
; R1 STACK WITH THE TOP STRING ON THE R1 STACK,
; RETURNING AN INTEGER VALUE ON THE R1 STACK WHICH IS:
;	-1 IF NEXT-TO-TOP < TOP
;	0 IF NEXT-TO-TOP = TOP
;	1 IF NEXT-TO-TOP > TOP
;
; ENTERED WITH:
;	JSR	PC,COMP.$
;	R1 STACK POINTER
;	R5 INTERPRETIVE PROGRAM COUNTER
;	2 NUMERIC STRINGS ON R1 STACK
;
; EXIT WITH:
;	R1 & R5 PRESERVED (IN FUNCTIONAL SENSE)
;	DESIRED RESULT ON R1
;-

COMP.$:	JSR	R5,INTFUN	;DEMAND
	ARGS	FAS,FAS		;TWO STRING ARGUMENTS
	JSR	PC,SET2BL	;MAKE TWO DESCRIPTOR BLOCKS

; AT THIS POINT, WE HAVE ADDED TO THE R1 STACK DESCRIPTOR
; BLOCKS FOR THE TOP 2 NUMERIC STRINGS IN THEIR RESPECTIVE
; ORDER.  MOREOVER R2,R3,R4, & R5 ARE SET UP FOR THE CALL 
; TO $CMPN, AND THE OLD IPC IS ON THE SP STACK.

	JSR	PC,$CMPN	;GET THE 3-WAY COMPARE ON SP STACK
	ADD	#2*$NBLEN,R1	;POP DESCRIPTORS FROM R1 STACK
	JSR	PC,PSTJS	;POP TOP STRING
	JSR	PC,PSTJS	;ALSO ONE JUST BELOW
	MOV	(SP)+,-(R1)	;RETURN 3-WAY COMPARE VALUE
	POP	R5		;RESTORE IPC
	$EXIT			;EXIT COMP.$

.SBTTL	SUM$ & DIF$ - ADD & SUBTRACT NUMERIC STRINGS

;+
; SUM$ & DIF$ RESPECTIVELY ADD THE TOP TWO R1 STACK
; STRINGS AND SUBTRACT THE TOP STRING FROM THE
; NEXT-TO-TOP STRING.
;
; ENTERED WITH:
;	JSR	PC,SUM$ (OR DIF$)
;	R1 STACK POINTER
;	R5 INTERPRETIVE PROGRAM COUNTER
;	2 NUMERIC STRINGS ON R1 STACK
;
; EXIT WITH:
;	RESULT SUBSTITUTED FOR ARGUMENTS ON R1 STACK
;	R5 INTERPRETIVE PROGRAM COUNTER
;	OTHER REGISTERS DESTROYED
;-

	.ENABL	LSB

SUM$:	CLR	-(SP)		;REMEMBER IT'S "ADD"
	BR	2001$		;CONTINUE IN MAINLINE

DIF$:	MOV	#-1,-(SP)	;REMEMBER IT'S "SUBTRACT"

2001$:	JSR	R5,INTFUN	;DEMAND
	ARGS	FAS,FAS		;2 STRING ARGUMENTS
	MOV	(SP)+,R0	;RETRIEVE ADD/SUBTRACT FLAG
	JSR	PC,SET2BL	;MAKE TWO DESCRIPTOR BLOCKS

; AT THIS POINT, WE HAVE ADDED TO THE R1 STACK DESCRIPTOR
; BLOCKS FOR THE TOP 2 NUMERIC STRINGS IN THEIR RESPECTIVE
; ORDER.  R2 POINTS AT THE NEXT-TO-TOP DESCRIPTOR BLOCK, R4
; POINTS AT THE TOP DESCRIPTOR BLOCK, AND THE IPC IS
; SAVED ON THE SP STACK.

	XOR	R0,$SIGN(R4)	;COMPLEMENT TOP SIGN IF  SUBTRACT
	MOV	R2,R5		;NEXT-TO-TOP POINTER
	SUB	#$NBLEN,R1	;MAKE ROOM FOR SUM DESC. BLOCK
	MOV	R1,R2		;POINT SUM DESC. BLOCK SLOT
.IIF NE	$MSOFF	.ERROR		;FOLLOWING WON'T WORK
	MOVB	#1,(R2)		;$MSOFF =1, ROOM FOR SIGN

; NOW WE MAKE THE SLOT ON THE R1 STACK INTO A "REASONABLE"
; DESCRIPTOR BLOCK FOR OUR DESIRED SUM.

	JSR	PC,SUMBLK	;MAKE THE SUM DESCRIPTOR BLOCK
	MOVB	$LSOFF(R2),R3	;WE WANT THIS MUCH STRING SPACE
	POP	R5		;RESTORE IPC
	JSR	PC,BUILDS	;GET THE DESIRED STRING SPACE
	JSR	PC,MDCOM6	;FIX UP R2 & R4 POINTERS

; NOW R3 POINTS ABSOLUTE TO THE DESIRED STRING SPACE AND A
; DEBIASED IPC IS ON THE SP STACK JUST UNDER A COROUTINE
; RETURN TO BUILDS.  ALSO, R4 STILL POINTS AT THE DESCRIPTOR
; BLOCK FOR THE TOP STACK ARGUMENT.  WE ASSUME THAT THE 
; RESULT WILL HAVE THE SAME SIGN AS THE TOP ARGUMENT AND 
; CORRECT LATER IF WE'RE WRONG.

.IIF NE <$NBLEN-$SIGN-2> .ERROR	;FOLLOWING WON'T WORK
	ADD	#$NBLEN+$SIGN,R2 ;POINT AT TOP ARG SIGN
	MOV	(R2),-(R4)	;MOVE IT TO RESULT SIGN
	MOV	(R4)+,R0	;AND SAVE IT IN R0
	CLR	(R2)+		;CLR TOP ARG SIGN & POINT NEXT-TO-TOP
	MOV	$SIGN(R2),R5	;NEXT-TO-TOP ARG'S SIGN
	XOR	R5,R0		;XOR'D INTO TOP ARG'S SIGN

; WE SAVE THE EXCLUSIVE OR OF THE TWO SIGNS AS A FLAG FOR
; LATER DISPATCH

	$GO.IF	,EQ,,2002$	;BR IF IT'S A SIMPLE ADD

; WE GET HERE IF WE ARE ADDING QUANTITIES WHICH ARE
; OPPOSITELY SIGNED.  WE SHALL WANT TO SEE WHICH IS THE
; LARGER IN ABSOLUTE MAGNITUDE & START WITH IT IN OUR
; NUMERIC STRING ACCUMULATOR.

	CLR	$SIGN(R2)	;BOTH ARG SIGNS NOW POSITIVE
	PUSH	R3		;SAVE ABSOLUTE ACCUMULATOR POINTER
	JSR	PC,SETR35	;MAKE R3 & R5 STRING POINTERS FOR R2 & R4
	JSR	PC,$CMPN	;COMPARE ARG MAGNITUDES
	$GO.IF	(SP)+,LE,#0,2003$ ;O.K. IF NEXT-TO-TOP <=TOP
 	COM	$SIGN(R1)	;ELSE FLIP RESULT SIGN
	PUSH	R2		;AND EXCHANGE
	MOV	R4,R2		;TOP AND NEXT-TO-TOP
	POP	R4		;POINTERS
2003$:	POP	R3		;RESTORE ABSOLUTE ACC POINTER

; WHETHER THE SIGNS ARE THE SAME OR DIFFERENT, ALL PATHS
; MERGE HERE.  R4 POINTS AT THE DESCRIPTOR BLOCK OF THE 
; ARGUMENT TO BE INSERTED IN THE ACCUMULATOR, AND R2 POINTS
; AT THE DESCRIPTOR BLOCK OF THE ARGUMENT TO BE ADDED TO OR SUBTRACTED FROM IT.

2002$:	PUSH	R2		;SAVE POINTER TO ADDEND OR SUBTRAHEND
	MOV	R1,R2		;POINT AT ACCUMULATOR DESCRIPTOR
	JSR	PC,SETR5	;R5 POINTS AT ARG WHOSE DESC. POINTED AT BY R4
	JSR	PC,$COPY	;COPY APPROPRIATE ARG TO ACC
	JSR	PC,STSIGN	;FILL IN SIGN ACCORDING TO $SIGN(R2)

; NOW WE SHALL EITHER ADD OR SUBTRACT THE OTHER ARGUMENT, DEPENDING ON
; THE EXCLUSIVE OR OF THE ARGUMENTS' SIGNS SAVED ON R0

	POP	R4		;POINT AT OTHER ARG'S DESC. BLOCK
	PUSH	R3		;SAVE ACC POINTER
	MOVB	$LSOFF(R2),R5	;L.S.DIGIT OFFSET IN ACC
	ADD	R5,R3		;POINT AT IT IN ACC
	MOVB	$RIGHT(R2),R5	;#PLACES RIGHT OF DECIMAL PT. IN ACC
	SUB	R5,R3		;POINT IN FRONT OF M.S. DIGIT TO RIGHT OF POINT
	MOVB	$RIGHT(R4),R5	;#PLACES RIGHT OF DEC. PT. IN ARG
	ADD	R5,R3		;THAT'S WHERE WE START IN ACC.
	JSR	PC,SETR5	;R5 POINTS AT ARG STRING
	ASL	R0		;0 - ADD, -2 - SUBTRACT
	JSR	PC,@1$(R0)	;$ADDU OR $SUBU
	POP	R3		;RECOVER ACC STRING POINTER
	JSR	PC,$RECOP	;MAKE THE FINAL ACCUMULATOR

; NOW THE STRING WHOSE ABSOLUTE ADDRESS IS IN R3 CONTAINS
; THE DESIRED RESULT.  ALL THAT REMAINS IS CLEANUP

BLDRET:	MOVB	$LSOFF(R1),R4	;GET STRING LENGTH
	ADD	R4,R3		;RETURN TO BUILDS NEEDS FINAL LOCATION
	MOV	SPDA,R0		;AND THIS 
	ADD	#STRLEN,(R0)	;THROW OUT TOP STRING HEADER
	ADD	#<3*$NBLEN>+<2*STRLEN>,R1 ;CLEAN UP R1 STACK
JPMID6:	JMP	MID6		;FINISH UP & EXIT

; THIS TABLE IS INDEXED BY -2 OR 0 TO DETERMINE WHETHER AN ABSOLUTE MODE
; SUBTRACT OR ADD IS TO BE PERFORMED.

	.WORD	$SUBU		;ABSOLUTE SUBTRACT
1$:	.WORD	$ADDU		;ABSOLUTE ADD

	.DSABL	LSB

.SBTTL	PLACE$ - ROUND/TRUNCATE NUMERIC STRINGS

;+
; PLACE$ ROUNDS OR TRUNCATES A NUMERIC STRING ON THE 
; R1 STACK ACCORDING TO THE INTEGER IMMEDIATELY ABOVE
; IT AT THE TOP OF THE STACK.  IF THE PLACE-SPECIFYING
; INTEGER IS LESS THAN 5000, ROUNDING IS REQUIRED,
; AND THE INTEGER IS INTERPRETED AS THE NUMBER OF
; SIGNIFICANT PLACES TO THE RIGHT OF THE DECIMAL 
; POINT DESIRED IN THE RESULT.  (THE RESULT DOES NOT
; NECESSARILY CONTAIN THAT MANY PHYSICAL PLACES.)
; (IF THE ARGUMENT IS NEGATIVE, PLACES TO THE LEFT OF
; THE DECIMAL POINT ARE THROWN AWAY AND THE RESULT
; IS LIKE ROUNDED DIVISION BY A POWER OF 10.)
; IF THE PLACE-SPECIFYING INTEGER IS GREATER THAN 5000,
; TRUNCATION IS SPECIFIED, AND THE INTEGER-10000 IS 
; INTERPRETED SIMILARLY TO THE ROUNDING CASE INSOFAR 
; AS SIGNIFICANT PLACES IS CONCERNED.
;
; ENTERED WITH:
;	JSR	PC,PLACE$
;	R5	INTERPRETIVE PROGRAM COUNTER
;	R1	CONTAINING STACK POINTER
;	ROUNDING/TRUNCATION PLACES SPECIFIER AT TOP OF R1 STACK
;	NUMERIC STRING JUST BELOW ON R1 STACK
;
; EXIT WITH:
;	RESULT SUBSTITUTED FOR ARGUMENTS ON R1 STACK
;	R5 INTERPRETIVE PROGRAM COUNTER
;	OTHER REGISTERS DESTROYED
;-

PLACE$:	JSR	R5,INTFUN	;DEMAND ARGUMENTS
	ARGS	FAS,FAI		;A STRING & AN INTEGER
.IIF NE<$NBLEN-STRLEN>	.ERROR	;FOLLOWING WON'T WORK
	SUB	#$NBLEN-2,R1	;SO MBLOCK WORKS
	MOV	R1,R0		;SAVE POINTER TEMPORARILY
	JSR	PC,MBLOCK	;MAKE DESC. BLOCK FOR ARG
	MOV	R1,R4		;SAVE A POINTER TO IT

; TO MAKE SPACE FOR ABOMINABLE CARRIES AND KEEP FROM HAVING
; LSET/RSET PROBLEMS, WE SHALL MAKE A COPY OF THE ARGUMENT.
; FIRST, WE WANT A SLIGHTLY EXPANDED DESCRIPTOR FOR THE COPY.

.IIF NE <$NBLEN-$SIGN-2> .ERROR ;FOLLOWING WON'T WORK
	MOV	-(R0),-(R1)	;COPY THE SIGN
.IIF NE <<$SIGN-$RIGHT-1>!<$RIGHT-$LSOFF-1>> .ERROR
	MOV	-(R0),-(R1)	;COPY $LSOFF - & $RIGHT
.IIF NE <<$LSOFF-$LEFT-1>!<$LEFT-$MSOFF-1>> .ERROR ;FOLLOWING WON'T WORK
	MOV	-(R0),-(R1)	;COPY $LEFT & $MSOFF
.IIF NE $MSOFF .ERROR		;FOLLOWING WON'T WORK
	MOVB	#1,(R1)		;SHORTER CODE TO MAKE EXPLICIT SIGN SPACE
	MOV	R1,R2		;CSPACE NEEDS THIS
	JSR	PC,CSPACE	;MAKE SPACE FOR A LEFT CARRY & SET $LSOFF
	MOVB	$LSOFF(R2),R3	;SET STRING LENGTH NEEDED FROM BUILDS

; NOW WE GET THE SPACE FOR THE COPY USING BUILDS

	JSR	PC,BUILDS	;GET SOME STRING SPACE
	JSR	PC,MDCOM6	;FIX UP R2 & R4 POINTERS

; NOW R3 POINTS ABSOLUTE TO SPACE FOR THE COPY, AND A
; DEBIASED IPC IS ON THE SP STACK UNDER THE COROUTINE
; RETURN ADDRESS FOR BUILDS.  ALSO, R4 STILL POINTS
; AT THE ARGUMENT'S DESCRIPTOR BLOCK.

	JSR	PC,SETR5	;MAKE R5 POINT TO ARG STRING
	JSR	PC,$COPY	;COPY THE AGRUMENT
	JSR	PC,STSIGN	;COPY THE SIGN
	MOV	3*$NBLEN-2(R1),R5 ;GET ROUND/TRUNCATE PARAMETER
	JSR	PC,RNDTRN	;DO TRUNCATION OR ROUNDING
	
; NOW WE HAVE THE STRING WE WANT.  R3 POINTS TO IT,
; AND R5 CONTAINS ITS LENGTH.

	ADD	R5,R3		;RETURN TO BUILDS NEEDS FINAL CHAR LOC.
	ADD	#3*$NBLEN+STRLEN,R1 ;CLEAN UP R1 STACK
	MOV	SPDA,R0		;SET UP R0 DATA BASE ADDRESS FOR BUILDS RETURN
	BR	JPMID6		;FINISH UP & EXIT

.SBTTL	PROD$ - MULTIPLY NUMERIC STRINGS

;+
; PROD$ MULTIPLIES THE TOP TWO R1 STACK STRINGS AND 
; ROUNDS OR TRUNCATES THE RESULT ACCORDING TO THE INTEGER
; PARAMETER JUST ABOVE THE STRING ARGUMENTS AT THE TOP
; OF THE R1 STACK.
;
; ENTERED WITH:
;	JSR	PC,PROD$
;	R5 INTERPRETIVE PROGRAM COUNTER
;	R1 CONTAINING STACK POINTER
;	ROUNDING/TRUNCATION PLACES SPECIFIER AT TOP OF R1 STACK
;	TWO NUMERIC STRINGS JUST BELOW ON R1 STACK
;
; EXITS WITH:
;	RESULT SUBSTITUTED FOR ARGUMENTS ON R1 STACK
;	R5 INTERPRETIVE PROGRAM COUNTER
;	OTHER REGISTERS DESTROYED
;-

PROD$:	JSR	PC,MDCOM1	;DO INITIAL SETUP

; WE NOW HAVE A DESCRIPTOR BLOCK BUILT ON THE R1
; STACK FOR EACH OF THE TWO NUMERIC STRING ARGUMENTS.
; THE ROUND/TRUNCATE PARAMETER HAS BEEN SHIFTED TO THE
; SP STACK.  R2 POINTS AT THE MULTIPLICAND DESCRIPTOR
; BLOCK. R4 POINTS AT THE MULTIPLIER DESCRIPTOR BLOCK.
; NOW WE MAKE A PLAUSIBLE DESCRIPTOR BLOCK FOR
; THE PRODUCT.

	JSR	PC,MDCOM2	;FINISH DESC. BLOCK & SET R3 TO STRING LENGTH

; NOW WE HAVE THE NOW DESCRIPTOR BLOCK SET UP.  TIME
; TO GET STRING SPACE IN WHICH TO BUILD THE PRODUCT.

	JSR	PC,BUILDS	;GETS THE STRING SPACE
	JSR	PC,MDCOM6	;FIX UP R2 & R4 POINTERS

PARLOC	=4			;LOCATION OF ROUND/TRUNC. PARAMETER ON SP STACK

; NOW R2 POINTS AT THE ACCUMULATOR DESCRIPTOR BLOCK, AND R3
; POINTS AT THE ACCUMULATOR.  R4 POINTS AT THE TOP ARGUMENT
; DESCRIPTOR BLOCK.

	JSR	PC,$ZERO	;ZERO THE ACCUMULATOR
	JSR	PC,STSIGN	;SET INDICATED SIGN

; NOW WE ARE READY TO SET UP FOR MULTIPLICATION AS A
; REPEATED SERIES OF SHIFTED ADDS.

	PUSH	<R1,R3>		;FREE SOME WORK REGISTERS
	JSR	PC,SETR5	;R5 POINTS AT MULTIPLIER
	MOV	R5,R0		;R0 POINTS AT MULTIPLIER
	JSR	PC,MDCOM3	;DO A PARTIAL LOOP CONTROL SETUP
	ADD	R0,R1		;1+END OF MULTIPLIER

; NOW REGISTER USAGE IS:
; R0 WILL BE USED TO COUNT ADDS OF THE MULTIPLICAND
; R1 POINTS AT SUCCESSIVE DIGITS OF THE MULTIPLIER
; R2 POINTS AT ACCUMULATOR DESCRIPTOR BLOCK
; R3 POINTS AT 1+L.S. DIGIT OF ACCUMULATOR WHERE CURRENT ADD TAKES PLACE
; R4 POINTS AT MULTIPLICAND DESCRIPTOR BLOCK
; R5 POINTS AT MULTIPLICAND
; (SP) LOW BYTE CONTAINS MULTIPLIER DIGIT EXHUSTION COUNT

; SO NOW WE DO NONFANCY, SLOW, REPEATED SHIFTS WITH 
; REPEATED ADDS BECAUSE THERE ISN'T MUCH ROOM FOR THIS
; CODE AS IT IS.

1005$:	DECB	(SP)		;DEC. MULTIPLIER DIGIT COUNT
	$GO.IF	,LT,,2001$	;QUIT LOOP IF MULTIPLIER FINISHED OFF
	MOVB	-(R1),R0	;GET MULTIPLIER DIGIT
	$GO.IF	R0,EQ,#'.,1005$ ;NUTS TO DECIMAL POINTS
	$GO.IF	-(R3),EQ,#'.,2003$,B ;SKIP DEC. PT. IN ACC.
	INC	R3		;BUT THIS WASN'T DEC. POINT
2003$:	SUB	#'0,R0		;NOW IT'S AN ADD COUNT
	$GO.IF	,EQ,,2002$	;UNLESS IT'S ZERO
1004$:	JSR	PC,$ADDU	;ADD IN MULTIPLICAND
	SOB	R0,1004$	;UNTIL MULTIPLIER DIGIT COUNTED DOWN

; WHEN WE GET HERE IN THE LOOP WE HAVE ADDED THE
; MULTIPLICAND INTO THE ACCUMULATOR A NUMBER  
; TIMES INDICATED BY ONE OF THE MULTIPLIER DIGITS.
; ITS TIME TO SHIFT LEFT ONE DIGIT IN THE ACCUMULATOR
; & CONSIDER THE NEXT MULTIPLIER DIGIT.

2002$:	DEC	R3		;SHIFT LEFT IN ACCUMULATOR
	BR	1005$		;DO NEXT MULTIPLIER DIGIT

; THE PRODUCT IS NOW IN THE ACCUMULATOR.  TIME TO
; CLEAN UP, PERFORM REQUESTED ROUNDING, & RETURN
; HIS ANSWER.

2001$:				;END OF PRODUCT FORMATION LOOP
MDCOM4:	TST	(SP)+		;RID OF DIGIT COUNT
	POP	<R3,R1>		;RESTORE R3 & R1
	MOV	R1,R2		;PUBLIC SERVICE FOR $QUO WHICH EXITS THRU HERE
	MOV	PARLOC(SP),R5	;ROUND/TRUNCATE PARAMETER
	JSR	PC,RNDTRN	;ROUND OR TRUNCATE RESULT
	MOV	PARLOC-2(SP),PARLOC(SP) ;RECOVER STACK FOR BUILDS
.IIF NE <PARLOC-4> .ERROR	;STACK CLEANUP WON'T WORK
	POP	(SP)		;RECOVER STACK FOR BUILDS
	BR	BLDRET		;EXIT PROD$

.SBTTL	QUO$ - DIVIDE NUMERIC STRINGS

;+
; QUO$ DIVIDES THE NEXT-TO-TOP R1 STACK NUMERIC
; STRING BY THE TOP NUMERIC STRING, ROUNDING OR
; TRUNCATING THE RESULT ACCORDING TO THE INTEGER
; PARAMETER JUST ABOVE THE STRINGS AT THE TOP OF
; THE R1 STACK.
;
; ENTERED WITH:
;	JSR	PC,QUO$
;	R5 INTERPRETIVE PROGRAM COUNTER
;	R1 CONTAINING STACK POINT
;	ROUNDING/TRUNCATION PLACES SPECIFIER AT TOP OF R1 STACK
;	TWO NUMERIC STRINGS JUST BELOW ON R1 STACK
; 
; EXITS WITH:
;	RESULT SUBSTITUTED FOR ARGUMENTS ON R1 STACK
;	R5 INTERPRETIVE PROGRAM COUNTER
;	OTHER REGISTERS DESTROYED
;-

QUO$:	JSR	PC,MDCOM1	;DO INITIAL SETUP

; HERE WE HAVE PUSHED ARGUMENT DESCRIPTOR BLOCKS ONTO
; THE R1 STACK AFTER HAVING MOVED THE ROUND/TRUNCATE
; PARAMETER TO THE SP STACK.  R2 POINTS AT THE DIVIDEND
; DESCRIPTOR BLOCK, AND R4 POINTS AT THE DIVISOR DESCRIPTOR
; BLOCK.

	MOV	(SP),R3		;ROUND/TRUNCATE PARAMETER
	JSR	PC,QUOBLK	;FINISH	QUOTIENT DESC. BLOCK

; NOW WE HAVE A PLAUSIBLE QUOTIENT DESCRIPTOR BLOCK ON THE
; R1 STACK.  WE SHALL NOW MAKE AN EXPANDED COPY OF THE 
; DIVIDEND.  FIRST, WE MAKE ITS DESCRIPTOR BY PRETENDING
; WE ARE MULTIPLYING THE QUOTIENT BY THE DIVISOR.

.IIF NE <$NBLEN-$SIGN-2> .ERROR	;FOLLOWING WON'T WORK
	CLR	-(R1)		;PRETEND TO MAKE SIGN FOR MDCOM2
	JSR	PC,MDCOM2	;MAKE DESC. OF EXPANDED DIVIDEND

; NOW R3 CONTAINS THE LENGTH OF THE DIVIDEND COPY.  WE
; WANT BUILDS TO GIVE US SUFFICIENT SPACE FOR BOTH THE
; QUOTIENT & THE EXPANDED DIVIDEND.

	MOVB	$LSOFF+$NBLEN(R1),R0 ;GET SIZE OF QUOTIENT
	ADD	R0,R3		;WE WANT ALL OF THIS FROM BUILDS
	JSR	PC,BUILDS	;GIVE US LOTS OF STRING SPACE
	JSR	PC,MDCOM6	;R2 POINTS AT DIVIDEND COPY DESC & R4 AT QUO DESC

PAROFF	=4			;LOCATION OF ROUND/TRUNC. PARAM. ON SP STACK

; NOW R3 POINTS TO ENOUGH STRING SPACE TO HAVE FIRST THE
; QUOTIENT STRING AND FOLLOWING IT THE EXPANDED DIVIDEND.  FIRST, WE
; ZERO THE DIVIDEND FOR CONVENIENCE.

	MOV	R4,R2		;POINT AT QUOTIENT
	JSR	PC,$ZERO	;ZERO THE QUOTIENT PIECE
	JSR	PC,STSIGN	;GET IT'S SIGN SET UP
	PUSH	<R2,R3>		;SAVE R2(WILL BECOME R1) & R3
	ADD	#2*$NBLEN,R4	;POINT AT DIVIDEND DESC. BLOCK
	JSR	PC,SETR5	;AND AT DIVIDEND ITSELF
	MOVB	$LSOFF(R2),R0	;LENGTH OF QUOTIENT STRING
	ADD	R0,R3		;POINT AT SPACE FOR NEW DIVIDEND
	MOV	R1,R2		;POINT AT ITS DESC. BLOCK
	JSR	PC,$COPY	;MAKE EXPANDED DIVIDEND

; WE ARE ABOUT TO SET UP A REPEATED SUBTRACTION LOOP TO CALCULATE
; THE QUOTIENT.  WHEN WE ARE FINISHED, REGISTERS WILL HAVE THE
; FOLLOWING USES:
; R0 POINTS TO LEADING DIGIT IN EXPANDED DIVIDEND (BORROW CONTROL)
; R1 POINTS AT DIGIT IN QUOTIENT CURRENTLY BEING CALCULATED
; R2 POINTS AT EXPANDED DIVIDEND DESCRIPTION BLOCK
; R3 POINTS INTO EXPANDED DIVIDEND WHERE SUBTRACTION IS BEING DONE
; R4 POINTS AT DIVISOR DESCRIPTION BLOCK
; R5 POINTS AT DIVISOR
; LOW BYTE OF (SP) CONTAINS NUMBER OF SHIFTS LEFT IN CALCULATION

	MOV	R3,R0		;POINT AT DIVIDEND COPY
	INC	R0		;AT ITS LEADING 0
	SUB	#2*$NBLEN,R4	;POINT AT QUOTIENT DESC. FOR MDCOM3
	JSR	PC,MDCOM3	;DO SOME INITIAL SETUP

; WE'RE NOT THERE YET.  R3 POINTS ONE CHAR BEYOND THE LAST IN
; THE DIVIDEND COPY, AND R1 CONTAINS THE LENGTH OF THE QUOTIENT.
; THIS IS A GREAT PLACE TO CHECK FOR DIVISION BY 0.

.IIF NE $MSOFF .ERROR		;FOLLOWING WON'T WORK
	$GO.IF	(R4),EQ,$LSOFF(R4),7$,B ;BR IF DIVISION BY 0
	DEC	R1		;$LSOFF-$MSOFF (QUOTIENT)
	$GO.IF	$RIGHT+$NBLEN(R2),EQ,#0,2001$,B ;BR IF R1=$RIGHT+$LEFT
	DEC	R1		;$RIGHT+$LEFT (QUOTIENT)
2001$:	SUB	R1,R3		;GUESS WHERE SUBTRACTION TO START
	$GO.IF	$RIGHT(R2),EQ,#0,2002$,B ;RIGHT IF NO DEC. PT. IN DIVIDEND
	$GO.IF	$RIGHT(R2),GE,R1,2002$,B ;RIGHT IF LOTS OF PLACES TO RIGHT
	DEC	R3		;ELSE SKIP DECIMAL POINT TOO
2002$:	MOV	2(SP),R1	;START OF QUOTIENT (JUST BEFORE FIRST DIGIT)
	INCB	(R0)		;SOMETHING TO BORROW AGAINST IN DIVIDEND

; FINALLY, WE ARRIVE AT THE POINT WHERE WE CAN START SUBTRACTING
; AND SHIFTING TO CALCULATE THE QUOTIENT.  HERE'S THE LOOP WHICH 
; DOES IT.

1003$:	DECB	(SP)		;DECREASE SHIFT COUNT
	$GO.IF	,LT,,2004$	;EXIT LOOP IF NO MORE LEFT
	INC	R1		;POINT AT NEXT QUOTIENT DIGIT
	$GO.IF	(R1),EQ,#'.,1003$,B ;SKIP QUOTIENT DECIMAL POINT
	$GO.IF	(R3)+,NE,#'.,2005$,B ;O.K. IF NOT AT ACC. DEC. PT.
	INC	R3		;ELSE GET BY IT
2005$:
1006$:	JSR	PC,$SUBU	;SUBTRACT DIVISOR FROM DIVIDEND
	INCB	(R1)		;COUNT IT IN QUOTIENT
	$GO.IF	(R0),NE,#'0,1006$,B ;LOOP UNTIL THERE'S A BORROW
	JSR	PC,$ADDU	;ADD DIVISOR BACK INTO DIVIDEND
	DECB	(R1)		;CORRECT DIGIT IN QUOTIENT
	BR	1003$		;DO NEXT QUOTIENT DIGIT

; THE QUOTIENT IS NOW IN THE QUOTIENT.  ITS TIME TO CLEAN UP,
; PERFORM REQUESTED ROUNDING, & RETURN HIS ANSWER USING MDCOM4
; IN THE PROD$ ROUTINE.  NOTE THAT TO USE THE MDCOM4 EXIT.
; WE USE A TRICK CONSISTING OF TWO PARTS:
; (1) HAVING SAVED OUR R2 AWHILE BACK  IN THE
;	PLACE ON THE STACK WHICH MDCOM4 WILL RESTORE 
;       AS R1.
; (2) HAVING MDCOM4 PERFORM A MOV R1,R2 AFTER RESTORATION
;	OF R1 THAT IS UNNECESSARY FOR THE PROD$ CODE.

7$:	POST,	PSTDV0		;KLUTZ TRIED DIVIDING BY 0
.IIF NE <PAROFF-PARLOC> .ERROR	;FOLLOWING WON'T WORK
2004$:	BR	MDCOM4		;EXIT QUO$

.SBTTL	QUOBLK - COMPLETE QUOTIENT DESCRIPTOR BLOCK

;+
; QUOBLK FINISHES CONSTRUCTION OF A QUOTIENT DESCRIPTOR BLOCK
; ON THE R1 STACK ASSUMING THE SIGN WORD IS ALREADY ON THE R1
; STACK.  QUOBLK DOES NUMEROUS CHECKS TO INSURE THAT THE QUOTIENT
; IS SHORT ENOUGH TO BE USED IN QUO$.
;
; ENTERED WITH:
;	JSR	PC,QUOBLK
;	R1 STACK POINTER ($SIGN ALREADY ON R1 STACK)
;	R2 POINTING AT DIVIDEND DESCRIPPTOR BLOCK
;	R3 CONTAINING ROUND/TRUNCATE PARAMETER
;	R4 POINTING AT DIVISOR DESRIPTOR BLOCK
;
; EXIT WITH:
;	REST OF QUOTIENT DESCRIPTOR BLOCK PUSHED ON R1 STACK
;	R2 POINTING AT QUOTIENT DESCRIPTOR BLOCK
;	R0 & R3 DESTROYED
;-

QUOBLK:	$GO.IF	R3,LT,#5000.,2001$ ;BR IF IT'S A ROUNDING PARAMETER
	SUB	#10000.,R3	;ELSE MAKE IT LOOK LIKE ONE
	DEC	R3		;CANCEL THE INC BELOW
2001$:	INC	R3		;ROUNDING REQUIRES AN EXTRA DIGIT
	$GO.IF	,GE,,2007$	;BR IF THIS IS NONNEGATIVE
	CLR	R3		;WELL $RIGHT CAN'T BE NEGATIVE
.IIF NE <<$SIGN-$RIGHT-1>!<<$RIGHT & 1>-1>> .ERROR
2007$:	SWAB	R3		;MORE CONVENIENT PLACE FOR $RIGHT
	$GO.IF	,EQ,,2004$	;BR IF NOT RIDICULOUSLY BIG
	POST,	PSTFLT		;$RIGHT >= 256, THAT'S NONSENSE
	MOV	#256.*<$MXLEN-2>,R3 ;BUT LET HIM TRY A BIG ONE

; NOW THE HIGH BYTE OF R3 CONTAINS OUR CANDIDATE FOR $RIGHT IN
; THE QUOTIENT DESCRIPTOR BLOCK.  LET'S POSIT IT.

.IIF NE <$SIGN-$RIGHT-1> .ERROR	;FOLLOWING WON'T WORK
2004$:	MOV	R3,-(R1)	;DEPOSIT $RIGHT ON R1 STACK
.IIF NE <$LEFT-1> .ERROR	;FOLLOWING WON'T WORK
	MOV	(R2),R0		;DIVIDEND'S $LEFT IN HIGH BYTE

; NOW WE HAVE TWO POSSIBILITIES:  (1) IF THE DIVISOR'S $LEFT
; IS NONZERO, THE QUOTIENT'S $LEFT = 1+$LEFT(R2)-$LEFT(R4),
; OR (2) OTHERWISE, THE QUOTIENT'S $LEFT = $LEFT(R2)+$RIGHT(R4).
; AS A MATTER OF CONVENIENCE, HOWEVER, WE DEMAND THAT THE
; QUOTIENT'S $LEFT ALWAYS BE AT LEAST ONE.

	$GO.IF	$LEFT(R4),EQ,#0,2002$,B ;BR IF CASE (2)
.IIF NE <$LEFT-1> .ERROR	;FOLLOWING WON'T WORK
	SUB	(R4),R0		;$LEFT(R2)-$LEFT(R4) (HIGH BYTE)

; THE $MXLEN+1 PORTION OF THE ADDITION CONSTANT USED BELOW IS TO CORRECT FOR
; ANY BORROWS INTO THE HIGH BYTE CAUSED BY THE PRECEDING SUBTRACT.

	ADD	#256.*1+$MXLEN+1,R0 ;$LEFT(R2)-$LEFT(R4)+1
	BR	3002$		;GO TO END OF CASE (2)

.IIF NE <<$RIGHT&1>-1> .ERROR	;FOLLOWING WON'T WORK
2002$:	ADD	$RIGHT-1(R4),R0	;$LEFT(R2)+$RIGHT(R4)
3002$:	CLRB	R0		;RID OF GARBAGE BYTE
	$GO.IF	R0,GT,#0,2005$	;BR IF $LEFT POSITIVE
	MOV	#256.*1,R0	;ELSE MAKE IT A ONE

; NOW WE HAVE A GOOD GUESS FOR $LEFT IN THE HIGH BYTE OF R0
; WE SHALL NOW SEE IF IT FITS WITH $RIGHT TO MAKE A DESCRIPTOR
; BLOCK FOR A STRING WHOSE LENGTH WILL NOT EXCEED $MXLEN.

2005$:	MOV	#256.*<$MXLEN-3>,R3 ;THE -3 ACCOUNTS FOR THE SIGN, CARRY, & DEC. PT.
	SUB	R0,R3		;SUBTRACT $LEFT (IN HIGH BYTE)
	$GO.IF	,GE,,2003$	;O.K. IF SOMETHING'S LEFT

	ERROR	BDNERR,FATAL	;ELSE HE'S A HACKER

2003$:	$GO.IF	R3,HIS,(R1),2006$ ;BR IF WE DON'T SHORTEN $RIGHT
	POST,	PSTFLT		;TELL HIM, BUT DON'T KILL HIM
	MOV	R3,(R1)		;GIVE HIM AS MUCH $RIGHT AS POSSIBLE

; NOW HE HAS $RIGHT EITHER AS HE REQUESTED IT OR AS MUCH AS WE
; CAN GIVE HIM WITHOUT BLOWING BYTE ARITHMETIC.  WE FINISH QUICKLY.

.IIF NE <<$RIGHT-$LEFT-2>!<$LEFT-1>> .ERROR
2006$:	MOV	R0,-(R1)	;PUT $LEFT ON STACK
	BR	MDCOM5		;& EXIT QUOBLK THRU MDCOM2

.SBTTL	RNDTRN - ROUND/TRUNCATE UTILITY

;+
; RNDTRN ROUNDS OR TRUNCATES THE NUMERIC STRING IN
; THE NUMERIC STRING ACCUMULATOR AS DIRECTED BY THE
; ROUND/TRUNCATE PARAMETER CONTAINED IN R5 AT ENTRY.
; IF THIS PARAMETER IS LESS THAN 5000, ROUNDING IS 
; SPECIFIED;  ELSE TRUNCATION IS SPECFIED AND 10,000
; IS SUBTRACTED FROM THE PARAMETER.  THE (PERHAPS 
; MODIFIED) PARAMETER IS THEN THE NUMBER OF SIGNIFICANT
; PLACES TO THE RIGHT OF THE DECIMAL POINT TO WHICH
; ROUNDING OR TRUNCATION IS TO BE PERFORMED.  IF THIS
; PARAMETER IS NEGATIVE, PLACES ARE CONSTRUED TO BE
; TO THE LEFT OF THE DECIMAL POINT IN THE OBVIOUS MANNER.
; (THE EFFECT IN THE LATTER CASE IS THAT OF DIVIDING
; BY A POSITIVE POWER OF 10 WITH ROUNDING OR TRUNCATION).
; 
; ENTERED WITH:
;	R2 POINTING AT ACCUMULATOR DESCRIPTOR BLOCK
;	R3 POINTING AT ACCUMULATOR
;	R5 CONTAINING ROUND/TRUNCATE PARAMETER
;	ACCUMULATOR OF SUFFICIENT LENGTH TO ALLOW LEFT ROUND CARRYOUT
;			
; EXIT WITH:
;	R5 CONTAINING LENGTH OF MODIFIED ACCUMULATOR
;	OTHER REGISTERS PRESERVED
;-

RNDTRN:	PUSH	<R0,R1,R2,R3,R4> ;SAVE R0,R1,R2,R3, & R4
	CLR	R0		;ASSUME IT'S ROUNDING
	$GO.IF	R5,LT,#5000.,2001$ ;BR IF IT'S ROUNDING
	INC	R0		;FLAG TRUNCATION
	SUB	#10000.,R5	;& ADJUST THE PARAMETER

; HERE R0 = 0 FOR ROUND, 1 FOR TRUNCATE. R5 = NUMBER
; OF PLACES DESIRED TO RIGHT OF DECIMAL POINT.

.IIF NE <$RIGHT-3> .ERROR	;FOLLOWING WON'T WORK
2001$:	CMP	(R2)+,(R2)+	;POINT 1+$RIGHT
	MOVB	-(R2),R4	;#PLACES TO RIGHT OF POINT
	SUB	R5,R4		;NUMBER OF SUPERFLOUS DIGITS
	$GO.IF	,LE,,2002$	;BR IF NUMBER O.K. AS IS

; HERE WE HAVE TO DO SOME CHOPPING TO GET THE NUMBER DOWN TO
; THE REQUIRED SIZE.

	MOVB	(R2),R5		;#PLACES TO RIGHT OF POINT
.IIF NE <$RIGHT-$LSOFF-1> .ERROR ;FOLLOWING WON'T WORK
	MOVB	-(R2),R1	;LENGTH OF INTERESTING PORTION OF STRING
	ADD	R1,R3		;POINT 1 BEYOND LAST DIGIT
.IIF NE <$LSOFF-$LEFT-1> .ERROR	;FOLLOWING WON'T WORK
	MOVB	-(R2),R1	;#PLACES TO LEFT OF POINT
	ADD	R1,R5		;#SIGNIFICANT PLACES
	$GO.IF	R4,LOS,R5,2003$	;BR UNLESS HE WANTS TO CHOP TOO MANY PLACES
	MOV	R5,R4		;DON'T LET HIM
2003$:	BR	5$		;BR INTO MIDDLE OF SOB LOOP

; THE FOLLOWING LOOP PLANTS SPACES IN THE PLACES TO BE CHOPPED
; OFF IN THE STRING.

1004$:	MOVB	#' ,(R3)	;LAST CHAR IS SPACED OUT
5$:	$GO.IF	-(R3),EQ,#'.,1004$,B ;SO ARE DECIMAL POINTS
	SOB	R4,1004$	;DESTROY SIGNIFICANT DIGITS AWHILE

; WHEN WE GET HERE, R3 IS POINTING AT THE DIGIT IMMEDIATELY
; TO THE RIGHT OF THE LEAST SIGNIFICANT ONE HE WANTS PRESERVED.
; BEWARE OF A TRICK USED BELOW WHICH SETS OR CLEARS THE C-BIT,
; THEN DOES SEVERAL OPERATIONS WHICH DO NOT AFFECT THE CARRY
; (INCLUDING A CONDITIONAL BRANCH), AND FINALLY TESTS THE CARRY
; WITH BLO.

	CMPB	(R3),#'5	;;C-BIT=0 FOR HIS OR 1 FOR LO
	MOVB	#' ,(R3)	;;DESTROY LAST SIGNIFICANT DIGIT
	MOV	R0,R0		;;TEST ROUND/TRUNCATE FLAG WITHOUT CHANGING C-BIT
	$GO.IF	,NE,,2006$	;;BR IF TRUNCATING
	$GO.IF	,LO,,2006$	;;BR IF NO CARRY PROPAGATION IN ROUND
	JSR	PC,$CARRY	;PROPAGATE THE CARRY
	TST	(SP)+		;DUMP $CARRY COROUTINE RETURN

; EXCEPT FOR FINAL CLEANUP, WE HAVE HIS ROUNDED OR TRUNCATED
; NUMBER IN THE ACCUMULATOR.

2006$:				;LET'S FINISH THIS UP
2002$:	POP	<R4,R3,R2,R1,R0> ;RESTORE R4,R3,R2,R1, & R0
	JSR	PC,$RECOP	;COMPRESS THE NUMERIC STRING
	MOVB	$LSOFF(R2),R5	;RETURN LENGTH IN R5
	$EXIT			;EXIT RNDTRN

.SBTTL	MULTIPLY & DIVIDE UTILITIES

;+
; MDCOM1 DOES INITIAL ARGUMENT CHECKING AND ARGUMENT
; DESCRIPTOR BLOCK SETUP FOR PROD$ AND QUO$.
; 
; ENTERED WITH:
;	JSR	PC,MDCOM1 (AT START OF PROD$ OR QUO$)
;	R1 STACK POINTER
;	R5 INTERPRETIVE PROGRAM COUNTER
;	INTEGER AND 2 STRINGS ON R1 STACK
;
; EXIT WITH:
;	R0 DESTROYED
;	R1 STACK POINTER
;	R2 POINTING AT DESC. BLOCK FOR NEXT-TO-TOP STRING
;	R3 POINTING ABSOLUTE AT NEXT-TO-TOP STRING
;	R4 POINTING AT DESC. BLOCK FOR TOP STRING
;	R5 PRESERVED
;	ROUND/TRUNCATE PARAMETER REMOVED FROM R1 STACK
;	TWO DESIRED DESCRIPTOR BLOCKS PUSHED ON R1 STACK
;	$SIGN OF PRODUCT OR QUOTIENT PUSHED ON R1 STACK
;	ROUND/TRUNCATE PARAMETER AT TOP OF SP STACK (AT EXIT)
;-

MDCOM1:	JSR	R5,INTFUN	;CHECK ARGUMENTS
	ARGS	FAS,FAS,FAI	;STRING,STRING, & INTEGER
	PUSH	(SP)		;MAKE SLOT FOR ROUND/TRUNC. PARAMETER
	MOV	(R1)+,2(SP)	;SAVE ROUND/TRUNCATE PARAMETER
	JSR	PC,SET2BL	;MAKE TWO DESCRIPTORS
.IIF NE <$NBLEN-$SIGN-2>.ERROR	;FOLLOWING WON'T WORK
	MOV	$SIGN(R2),-(R1)	;GET NEXT-TO-TOP ARG SIGN
	MOV	$SIGN(R4),R5	;GET TOP ARG SIGN
	XOR	R5,(R1)		;SIGN OF PRODUCT OR QUOTIENT
	MOV	(SP)+,R5	;RESTORE R5
	$EXIT			;EXIT MDCOM1

;+
; MDCOM2 FINISHES SETTING UP A PRODUCT DESCRIPTOR BLOCK ASSUMING $SIGN HAS
; ALREADY BEEN SET AND R1 IS POINTING AT THE $SIGN ENTRY.
;
; ENTERED WITH:
;	JSR	PC,MDCOM2
;	R1 STACK POINTER (WITH $SIGN ALREADY ON R1 STACK)
;	R2 POINTING AT ONE ARGUMENT DESCRIPTOR BLOCK
;	R4 POINTING AT OTHER ARGUMENT DESCRIPTOR BLOCK
;
; EXIT WITH:
;	BALANCE OF DESCRIPTOR BLOCK PUSHED ON R1 STACK
;	R2 POINTING AT NEW DESCRIPTOR BLOCK
;	R3 SET TO LENGTH OF STRING COVERED BY DESCRIPTOR BLOCK
;	OTHER REGISTERS PRESERVED
;-

.IIF NE <<$SIGN-$LSOFF-2>!<$RIGHT-$LSOFF-1>> .ERROR
MDCOM2:	MOV	$RIGHT-1(R2),-(R1) ;ALL WE'RE AFTER IS $RIGHT
	ADD	$RIGHT-1(R4),(R1) ;THE SUM OF ARG $RIGHT'S
.IIF NE <<$LSOFF-2>!<$LEFT-1>!$MSOFF> .ERROR
	MOV	(R2),-(R1)	;ALL WE'RE AFTER IS $LEFT
	ADD	(R4),(R1)	;THE SUM OF ARG $LEFT'S
MDCOM5:	MOVB	#1,(R1)		;$MSOFF=1 TO ALLOW FOR SIGN 
	MOV	R1,R2		;PREPARE TO CALCULATE $LSOFF
	JSR	PC,CSPACE	;CALCULATE $LSOFF
	MOVB	$LSOFF(R2),R3	;RETURN STRING LENGTH IN R3
	$EXIT			;EXIT MDCOM2

;+
; MDCOM3 DOES A PARTIAL SETUP OF CONTROL VARIABLES FOR MULTIPLY ADD LOOPS AND
; DIVIDE SUBTRACT LOOPS. NOTE THAT ONE OF THE VARIABLES SET UP IS R1, WHICH
; MUST HAVE BEEN PREVIOUSLY SAVED.
;
; ENTERED WITH:
;	JSR	PC,MDCOM3
;	R2 POINTING AT ACCUMULATOR DESCRIPTOR BLOCK
;	R4 POINTING AT MULTIPLIER OR QUOTIENT DESCRIPTOR BLOCK
;
; EXIT WITH:
;	R0 UNCHANGED
;	R1 SET TO LENGTH OF MULTIPLIER OR QUOTIENT
;	R2 UNCHANGED
;	R3 POINTING 1 CAHR BEYOND LAST CHAR OF ACCUMULATOR
;	R4 POINTING AT MULTIPLICAND OR DIVISOR DESCRIPTION BLOCK
;	R5 POINTING AT MULTIPLICAND OR DIVISOR
;	LOW BYTE OF (SP) = # SIG. MULTIPLIER OR QUOTIENT DIGITS (INCL. DEC. PT.)
;-

MDCOM3:	PUSH	(SP)		;MAKE A SLOT FOR SHIFT COUNT
	MOVB	$LSOFF(R2),R5	;GET LENGTH OF ACCUMULATOR
	ADD	R5,R3		;POINT AT 1+L.S. DIGIT IN ACC
	MOVB	$LSOFF(R4),R1	;LENGTH OF MULTIPLIER OR QUOTIENT
	MOV	R1,2(SP)	; & ON THE STACK
.IIF NE $MSOFF .ERROR		;FOLLOWING WON'T WORK
	SUB	(R4),2(SP)	;LOW BYTE = NUMBER OF SHIFTS
	ADD	#$NBLEN,R4	;DESC. BLOCK OF MULTIPLICAND OR DIVISOR
	JSR	PC,SETR5	;R5 POINTS AT MULTIPLICAND OR DIVISOR
	$EXIT			;EXIT MDCOM3

;+
; MDCOM6 IS USED AFTER A CALL TO BUILDS TO SET R2 TO POINT AT THE R1 STACK
; AND R4 TO POINT AT THE R1 STACK+$NBLEN BYTES DOWN.
;
; ENTERED WITH:
;	JSR	PC,MDCOM6
;	R1 STACK POINTER
;
; EXIT WITH:
;	R2 POINTING AT R1 STACK
;	R4 POINTING INTO R1 STACK $NBLEN BYTES
;-

MDCOM6:	MOV	R1,R2		;R2 POINTS AT TOP OF STACK
	MOV	R1,R4		;R4
	ADD	#$NBLEN,R4	;POINTS ONE ITEM DOWN ON STACK
	$EXIT			;EXIT MDCOM6

.SBTTL	SETR5 & SETR35 - MAP DESC. POINTERS INTO STRING POINTERS

;+
; SETR5 USES THE NUMERIC STRING DESCRIPTOR BLOCK POINTER IN
; R4 TO CALCULATE THE CORRESPONDING STRING POINTER AND PLACE
; IT IN R5.  SETR35 DOES THE SAME THING AS SETR5, BUT IN ADDITION,
; IT MAPS THE DESCRIPTOR BLOCK POINTER IN R2 INTO A CORRESPONDING
; STRING POINTER IN R3.  BOTH ROUTINES ASSUME DESCRIPTOR BLOCKS
; ARE SEPARATED FROM THE HEADERS OF THE STRINGS THEY DESCRIBE
; BY 6 WORDS.  (USUALLY BOTH WILL BE ON THE R1 STACK.)
;
; ENTER WITH:
;	JSR	PC,SETR5 (OR SETR35)
;	R4 POINTING AT NUMERIC STRING DESCRIPTOR BLOCK
;	R2 POINTING AT NUMERIC STRING DESCRIPTOR BLOCK (SETR35)
;	STRING HEADER(S) SIX WORDS HIGHER THAN DESC. BLOCK(S)
;
; EXIT WITH:
;	R5 POINTING ABSOLUTE AT NUMERIC STRING REF. BY R4
;	R3 POINTING ABSOLUTE AT NUMERIC STRING REF. BY R2 (SETR35)
;	OTHER REGISTERS PRESERVED
;-

.IIF NE <$NBLEN-STRLEN> .ERROR	;REWRITE LOT'S OF CODE

SETR35:	MOV	R2,R3		;COPY DESCRIPTOR POINTER
	ADD	#$NBLEN+STRLEN,R3 ;INCREMENT TO STRING HEADER
	ADD	PNTR(R3),R3	;NOW TO STRING
SETR5:	MOV	R4,R5		;COPY DESCRIPTOR POINTER
	ADD	#$NBLEN+STRLEN,R5 ;POINT AT STRING HEADER
	ADD	PNTR(R5),R5	;NOW TO STRING
	$EXIT			;EXIT SETR35 OR SETR5

.SBTTL	SET2BL - SET UP 2 DESCRIPTOR BLOCKS

;+
; SET2BL PUSHES ONTO THE R1 STACK DESCRIPTOR BLOCKS
; FOR THE NEXT-TO-TOP AND TOP STRINGS ALSO SETS UP
; AND SAVES REGISTERS AS DESCRIBED BELOW.
;
; ENTER WITH:
;	JSR	PC,SET2BL
;	R1 STACK POINTER
;	R5 INTERPREETIVE PROGRAM COUNTER
;	2 NUMERIC STRINGS ON R1 STACK
;
; EXIT WITH:
;	R0 PRESERVED
;	TWO DESIRED STRING DESCRIPTORS PUSHED ON R1 STACK
;	FORMER R5 (IPC) ON SP STACK (AFTER EXIT)
;	R2 POINTING AT DESC. BLOCK FOR NEXT-TO-TOP STRING
;	R3 POINTING AT NEXT-TO-TOP STRING ABSOLUTE 
;	R4 POINTING AT DESC. BLOCK FOR TOP STRING
;	R5 POINTING AT TOP STRING ABSOLUTE
;-

SET2BL:	PUSH	(SP)		;COPY RETURN ADDRESS
	MOV	R5,2(SP)	;SAVE IPC
.IIF NE <$NBLEN-STRLEN> .ERROR	;FOLLOWING WON'T WORK
	JSR	PC,MBLOCK	;MAKE DESC. BLOCK FOR NEXT-TO-TOP STRING
	PUSH	R3		;SAVE ABS STRING POINTER
	JSR	PC,MBLOCK  	;MAKE DESC. BLOCK FOR TOP STRING
	MOV	R2,R4		;TOP DESC. BLOCK POINTER
	MOV	R3,R5		;TOP STRING POINTER (ABSOLUTE)
	ADD	#$NBLEN,R2	;POINT AT NEXT-TO-TOP DESC. BLOCK
	POP	R3		;POINT AT NEXT-TO-TOP STRING
	$EXIT			;EXIT SET2BL

.SBTTL	MBLOCK - MAKE A STRING DESCRIPTOR BLOCK

;+
; MBLOCK MAKES A DESCRIPTION BLOCK FOR THE NUMERIC STRING
; 3 WORDS DOWN ON THE R1 STACK.  (STRING HEADERS AND NUMERIC 
; DESCRIPTOR BLOCKS HAD BOTH BETTER BE THREE WORDS LONG.)
;
; ENTER WITH:
;	JSR	PC,MBLOCK
;	R1 STACK POINTER
;	NUMERIC STRING THREE WORDS DOWN ON R1 STACK
;
; EXIT WITH:
;	DESCRIPTOR BLOCK PUSHED ON R1 STACK
;	R2 POINTING AT DESCRIPTOR BLOCK (R1 STACK)
;	R3 POINTING (ABSOLUTELY) AT ARGUMENT STRING
;	R4 DESTROYED
;-

.IIF NE <$NBLEN-STRLEN>	.ERROR	;REWRITE A LOT OF CODE

MBLOCK:	MOV	R1,R3		;POINT AT
	ADD	#STRLEN,R3	;ARGUMENT STRING HEADER
	SUB	#$NBLEN,R1	;MAKE ROOM ON STACK FOR DESC. BLOCK
	MOV	R1,R2		;AND POINT AT DESCRIPTOR BLOCK
	MOV	LENGTH(R3),R4	;THE STRING LENGTH
	$GO.IF	R4,HI,#$MXLEN,2001$ ;MIGHT BE RIDICULOUS
	ADD	PNTR(R3),R3	;ABS. ADDRESS OF STRING
	ADD	R3,R4		;1+ ADDRESS OF LAST CHAR
	JSR	PC,MAKBLK	;MAKE DESCRIPTOR BLOCK
	BCC	2002$		;BR IF O.K. NUMERIC STRING

2001$:	ERROR	BDNERR,FATAL	;DODGY NUMERIC STRING ERROR

2002$:	$EXIT			;EXIT MBLOCK

