.IIF	NDF	L$$IST,	.NLIST
TITLE	SYSA,<SAINT INTERPRETER DEFINITIONS>,08,13-MAY-86,TPH/JDM

;                   Copyright 1974,1990 by Digital Equipment Corporation
;                                  All rights reserved.
;
;          This software is furnished under a license and may be used and copied
;          only  in  accordance  with  the  terms  of  such license and with the
;          inclusion of the above copyright notice.  This software or any copies
;          shall not be provided to any other person.   No title to or ownership
;          of the software is hereby transferred.
;
;          The information in this software is subject to change without notice.
;
;          DIGITAL  assumes  no  responsibility  for the  use, functionality, or
;          reliability of its  software  on equipment  which  is not supplied by
;          DIGITAL.

;SYNTAX ANALYZER - A SET OF OPERATORS USED FOR MANY MESSY STATEMENTS
;NAMES OF THE MICRO-CODED OPERATORS HAVE FOLLOWING SYNTAX:
;	[R][N][D][F][J]
;	      [V][I]
;	      [X][S]
;	        [E]
;	        [T]
;	OR  C([B]
;	      [A]
;	      [T]
;	      [I]
;	      [S])
;THE LETTERS STAND FOR:
;	A	ANY FORMULA FROM INPUT STREAM
;	B	THE BYTE FOLLOWING
;	C	COMPILE
;	D	DATA, I.E. AN ACTUAL NUMBER OR STRING
;	E	END OF STATEMENT-CR,:,IF,FOR,UNLESS,WHILE, UNTIL,THEN
;	F	FLOATING
;	I	INTEGER
;	J	JUMP TO FOLLOWING LOCATION IF SATIS.
;	N	NOT MATCHING
;	R	READ A NEW TOKEN
;	S	STRING
;	T	A TOKEN
;	V	VARIABLE
;	X	MATRIX VARIABLE
;THERE ARE A NUMBER OF OTHER OPERATORS WITHOUT SUCH REGULAR NAMES
;THE NAMES OF THE FIRST SET OF OPERATORS IS INTERPRETABLE AS FOLLOWS:
;	1)  IF R PRESENT, FIRST READ A NEW TOKEN
;	2)  N MEANS THE IMPLIED PREDICATE IS SATISFIED IF THREE
;	    DO NOT MATCH; NO MATCH IS ATTEMPTED UNLESS
;	    SOME CHARACTER OF THE 4 THE CLASS IS PRESENT
;	3)  IF D PRESENT THEN INSIST THAT CURRENT TOKEN BE ACTUAL DATA
;	    IF V INSIST IT BE A VARIABLE
;	    IF X INSIST IT BE AN ARRAY
;	4)  IF ONE OF THE FOURTH GROUP OCCURS, THE CURRRENT TOKEN MUST
;	    BE OF THAT CLASS
;	5)  IF J IS NOT PRESENT THEN A FATAL ERROR IS CAUSED BY FAILURE
;	    OF THE MATCH; IF J IS PRESENT A BRANCH TO THE LOCATION 
;	    WHICH IS GIVEN AS THE SECOND ARGUMENT WILL OCCUR WHEN THE
;	    CONDITION  IS SATISFIED

;THE NAMES OF THE SECOND SET OF OPERATORS IS INTERPRETABLE AS "COMPILE
;THE INDICATED QUANTITY".  IN PARTICULAR:
;	CB	COMPILE THE FOLLOWING BYTE--NO EFFECT ON TOKEN POINTER
;	CA	COMPILE A FORMULA FROM THE INPUT STREAM
;	CT	COMPILE THE CURRENT TOKEN (2 BYTES)
;	CI	COMPILE A FORMULA AND INSIST THAT IT BE INTEGER - USE
;		TYPE COMVERSION ROUTINE IF POSSIBLE.
;	CS	COMPILE A STRING
;ALL CALLS TO THE FORMULA COMPILER ASSUME THAT THE CURRENT TOKEN IS
;THE FIRST IN THE FORMULA AND IS ONE PAST THE FORMULA AT RETURN.
;FOR EXAMPLE:
;	T COMMA		MEANS "ERROR IF NOT A COMMA" 
;	RS		MEANS READ A TOKEN, ERROR IF NOT A STRING
;	NVJ LOC		JUMP TO "LOC" IF CURRENT TOKEN NOT A VARIABLE
;	RNTJ COMMA,LOC	MEANS READ A TOKEN; IF IT IS NOT A COMMA JUMP
;			TO "LOC"

;...;...;...;...;...;...;...;...
;   ;   ;   ;       ;       ;   
; R ; N ; J ; D V X ; F I S ; - 
;   ;   ;   ;   ;   ;   ;   ;   
;...;...;...;...;...;...;...;...
;R=200	N=100	J=40	D=10	F=2
;			V=20	I=4
;			X=30	S=6
;			   E=20
;			   T=10

;A MACRO TO INITIALLY ENTER "SAINT"

	.MACRO	$SAINT	SYM
	.ODD
$$'SYM:
	.ENDM

; MICRO CODED OP DEFS
;SOME MACROS TO DO THE WORK

	.MACRO	D0	NAME,VALUE	;NO ARGS
	.MACRO	NAME
				.BYTE	VALUE
	.ENDM
	.ENDM

	.MACRO	D1	NAME,VALUE	;ONE ABS ARG
	.MACRO	NAME	Q1
				.BYTE	VALUE,Q1
	.ENDM
	.ENDM

	.MACRO	D2	NAME,VALUE	;ONE ABS ARG, ONE REL ARG
	.MACRO	NAME	Q1,Q2
				.IF	GT	Q2-.-177
				.ERROR	;ADDRESS ERROR
				.ENDC
				.IF	LT	Q2-.+200
				.ERROR	;ADDRESS ERROR
				.ENDC
				.BYTE	VALUE,Q1,Q2-.
	.ENDM
	.ENDM

	.MACRO	D4	NAME,VALUE	;ONE REL ARG
	.MACRO	NAME	Q1
				.IF	GT	Q1-.-177
				.ERROR	;ADDRESS ERROR
				.ENDC
				.IF	LT	Q1-.+200
				.ERROR	;ADDRESS ERROR
				.ENDC
				.BYTE	VALUE,Q1-.
	.ENDM
	.ENDM

	D0	R,201
	D0	E,21
	D0	RE,221
	D4	EJ,61
	D4	NEJ,161
	D4	REJ,261
	D4	RNEJ,361
	D0	S,7
	D0	DS,17
	D4	NDSJ,157
	D0	RS,207
	D0	RDS,216
	D4	RNSJ,347
	D0	RVS,227
	D1	T,11
	D1	RT,211
	D1	NT,111
	D2	RTJ,251
	D2	RNTJ,351
	D2	NTJ,151
	D2	TJ,51
	D4	VFJ,63
	D4	NVFJ,163
	D4	NVIJ,165
	D4	NVSJ,167
	D4	RVFJ,263
	D4	RXFJ,273
	D4	XIJ,75
	D0	XI,35
	D0	XF,33
	D0	XS,37
	D4	RVSJ,267
	D4	VIJ,65
	D0	VS,27
	D0	X,31
	D0	RX,231
	D0	RDI,215

; THE MACROS DEFIN - ARE
;USED TO DEFINE OPS.
; *** BEWARE OF GLOBALS GENERATED BY MACROS ***
.SBTTL	GLOBALS ARE GENERATED BY SAINT MACROS
.SBTTL					

	.MACRO	D.FIN0	NAME	;DEFINE OP WITH NO ARGS
				.MACRO	NAME
				.BYTE	$'NAME
				.GLOBL	$'NAME
				.ENDM
	.ENDM

	.MACRO	D.FIN1	NAME	;ONE ABSOLUTE ARG
				.MACRO	NAME	Q1
				.BYTE	$'NAME,Q1
				.GLOBL	$'NAME
				.ENDM
	.ENDM

	.MACRO	D.FIN2	NAME	;ONE ABS,ONE REL
				.MACRO	NAME	Q1,Q2
				.GLOBL	$'NAME
				.IF	GT	Q2-.-177
				.ERROR	;ADDRESS ERROR
				.ENDC
				.IF	LT	Q2-.+200
				.ERROR	;ADDRESS ERROR
				.ENDC
				.BYTE	$'NAME,Q1,Q2-.
				.ENDM
	.ENDM

	.MACRO	D.FIN3	NAME	;ONE RELATIVE ARG
				.MACRO	NAME	Q1
				.GLOBL	$'NAME
				.IF	GT	Q1-.-177
				.ERROR	;ADDRESS ERROR
				.ENDC
				.IF	LT	Q1-.+200
				.ERROR	;ADDRESS ERROR
				.ENDC
				.BYTE	$'NAME,Q1-.
				.ENDM
	.ENDM

	;D.FIN0	SEXIT		;EXTERNAL JUMP
				.MACRO	SEXIT	Q1
				.BYTE	$SEXIT
				.GLOBL	$SEXIT
				.EVEN
				.WORD	Q1
				.ENDM
	;D.FIN0	QUITD		;RETURN TO MACHINE CODE
				.MACRO	QUITD
				.BYTE	$QUITD
				.GLOBL	$QUITD
				.EVEN
				.ENDM
	D.FIN0	RCS		;READ AND COMPILE STRING
	D.FIN0	CS		;COMPILE A STRING EXPRESSION
	D.FIN0	CN		;COMPILE AN EXPRESSION FOR A NUMBER
	D.FIN1	CB		;(BYTE) COMPILE IN-LINE BYTE
	D.FIN0	CBS		;COMPILE A BYTE FROM STACK
	D.FIN0	PT		;PUSH TOKEN
	D.FIN0	SARF		;SET ARRAY FLAG FOR LA
	D.FIN3	CALLS		;SUBROUTINE CALL
	D.FIN3	B		;LOCATION BRANCH
	D.FIN1	PBS		;(BYTE) PUSH BYTE (USE WORD) OF STACK
	D.FIN0	TST1AI		;TEST & REMOVE WORD FROM STACK
	D.FIN0	P0		;PUSH ZERO
	D.FIN0	PTYPE		;PUSH TYPE OF TOKA
	D.FIN0	QUIT		;LEAVE VIA TLMODI
	D.FIN0	RCI		;READ AND COMPILE INTEGER
	D.FIN0	CI		;COMPILE AN INTEGER EXPRESSION
	D.FIN3	COPR		;(TABLE) USE VALUE IN TLCOMR
	D.FIN0	MATCHT		;
	D.FIN0	QUITN		;FOR STATEMENTS NOT TAKING MODIFIERS
	D.FIN0	SHARF		;SET FLAG FOR LA
	D.FIN0	QUITS		;RETURN FROM INTERP SUBR
	D.FIN0	RINTS		;READ AND STACK A CONSTANT - MAKE FIXED
	D.FIN0	GLNS		;GET AND STACK A LINE NUMBER
	D.FIN0	CA		;COMPILE A FORMULA
	D.FIN0	C2OF1		;COMPILE BYTE FROM 2ND WORD OF STACK
	D.FIN0	CCB		;CLOSE CODE BLOCK
	D.FIN0	CF		;COMPILE FIELD LEFT SIDE A LA TOM E
	D.FIN0	TC		;R1-AIDED TYPE CONVERSION A LA TOM E
	D.FIN0	CFA		;COMPILE FIELD ADDRESS
	D.FIN0	CL		;COMPILE LEFT SIDE (OF LET)
	D.FIN1	SF		;SET FLAG BYTE
	D.FIN0	ICF		;INCREMENT FLAG BYTE
	D.FIN3	COPT		;(TABLE) COMPILE ONE BYTE FROM TABLE
	D.FIN0	CT		;COMPILE 2 BYTES OF TOKEN
	D.FIN0	CW		;COMPILE WORD FROM STACK
	D.FIN2	BFS		;BRANCH ON FLAGS SET
	D.FIN2	BFC		;BRANCH ON FLAG CLEAR
	D.FIN0	ARYS		;

.IIF	NDF	L$$IST,	.LIST

