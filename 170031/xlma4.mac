TITLE	XLMA4,<4-WORD FUNCTIONS>,08,13-MAY-86,TPH/JDM/MHB/WBN/SLR

;                   Copyright 1974,1990 by Digital Equipment Corporation
;                                  All rights reserved.
;
;          This software is furnished under a license and may be used and copied
;          only  in  accordance  with  the  terms  of  such license and with the
;          inclusion of the above copyright notice.  This software or any copies
;          shall not be provided to any other person.   No title to or ownership
;          of the software is hereby transferred.
;
;          The information in this software is subject to change without notice.
;
;          DIGITAL  assumes  no  responsibility  for the  use, functionality, or
;          reliability of its  software  on equipment  which  is not supplied by
;          DIGITAL.
;
;	MODIFICATIONS:
;
;*A* 4-FEB-80 REILLY: CHECK EXP ARGUMENT BETTER

.SBTTL	EXTERNAL GLOBALS
;
	.GLOBL	INTFUN,ADDF,MULF,DIVF,PUSHF0
	.IF	DF	DECMAP
	.GLOBL	DSCTST
	.ENDC
	.IF	NDF	FPU
	.GLOBL	$ADD,$SBD,$MLD,$DVD,$ID,$DI,$DINT,DUP4
	.GLOBL	$POLSH,DUPLF
	.ENDC

.SBTTL	LOAD PUSH-POP CODE FOR LOG FUNCTIONS

	ORG	PT,0

	..	PPSQRT,SQRT
	..	PPEXP,EXP
	..	PPLN,LOG
	..	PPLG10,LOG10

.SBTTL	LONG ROUTE FOR A**B (A**B = EXP(B*LOG(A)) )

	ORG	XF,0

XF:	JSR	PC,LOGF		;TAKE LOG OF NUMBER TO EXPONENTIATE
	MOVFLT	(SP)+,-(R1)	;EXPONENT BACK TO R1
	JSR	PC,MULF		;MULT BY LOG OF NUMBER
	JMP	EXPF		;AND EXIT THRU EXPONENTIAL ROUTINE

	.IF	NDF	FPU
	ORG	POLY,0
POLY:
;	POLY4 IS A POLYNOMIAL EVALUATOR TO EVAL
;	C(N)*X**N+C(N-1)*X**N-1+...+C(1)*X+C(0)
;	CALL POLY4 (VIA $POLSH) WITH X (A 4-WD FL-PT NO.)
;	ON THE R1 STACK AND C(R4)=A POINTER TO A POINTER TO A WORD
;	CONTAINING N+1, I.E., THE NO. OF CONSTANTS.
;	THE CONSTANTS THEMSELVES ARE STORED (AS 4-WD FL-PT
;	NO'S.) IMMED. BEFORE THE WORD CONTAINING THE N+1,
;	WITH C(N) AT LOWEST ADDR AND C(0) AT HIGHEST.
;	E.G., TO EVAL. 5*X**2+3*X+2, THE CONST. TABLE
;	LOOKS LIKE:
;		.WORD	...,...,...,...		;4-WD FL-PT 5, I.E. C(2)
;		.WORD	...,...,...,...		;4-WD FL-PT 3, I.E. C(1)
;		.WORD	...,...,...,...		;4-WD FL-PT 2, I.E. C(0)
;		.WORD	3			;NO. OF CONS'TS
;
POLY2:	;POLY2 IS LIKE POLY4 - BUT FOR 2-WORD STUFF
POLY4:	MOV	(R4)+,R0	;POINTER TO NUMBER OF COEFFICIENTS, ETC.
	MOV	R4,-(SP)	;SAVE RETURN POINTER
	MOV	(R0),R4		;SAVE THE NUMBER OF COEFFICIENTS IN R4
	MOV	R4,-(SP)	;AND ON THE STACK
	MOV	(R1)+,R2	;SAVE X
	MOV	(R1)+,R3
	.REPT	FLTLEN-2
	MOV	(R1)+,-(SP)
	.ENDR
	BR	PLP42		;GO PUSH A COEFFICIENT
PLP41:	.IF	EQ	FLTLEN-4	;FETCH X BACK TO THE R1 STACK
	MOV	(SP),-(R1)
	MOV	2(SP),-(R1)
	.ENDC
	MOV	R3,-(R1)
	MOV	R2,-(R1)
PLP42:	MOVFLT	-(R0),-(R1)	;PUSH ONE OF THE COEFFICIENTS
	SOB	R4,PLP41	;REPEAT FOR EACH COEFFICIENT
	.IF	EQ	FLTLEN-4
	CMP	(SP)+,(SP)+	;SOME GARBAGE OFF THE STACK
	.ENDC
	DEC	(SP)		;DECREMENT 2ND COPY OF COUNTER
PLP43:	JSR	PC,MULF		;MULTIPLY TOP OF STACK BY X
	JSR	PC,ADDF		;ADD IN NEXT COEFFICIENT
	DEC	(SP)		;DECREMENT COUNTER
	BNE	PLP43		;REPEAT FOR EACH COEFFICIENT
	TST	(SP)+		;DISCARD THE COUNTER
	MOV	(SP)+,R4	;RESTORE POLISH POINTER
	JMP	@(R4)+		;POLISH EXIT

;	UP4 IS A POLISH ROUTINE TO MOVE THE 4 WDS AT THE HEAD
;	OF THE STACK TO A LOC 8 WD'S AWAY INSIDE THE STACK
UP2:	;LIKE UP4 BUT 2 WORDS AT HEAD GET MOVED 4 WORDS AWAY
UP4:	MOVFLT	(R1)+,6*FLTLEN-2(R1)  ;MOVE SOME WORDS SOME DISTANCE
	JMP	@(R4)+
;
;	MSPR1 IS A POLISH ROUTINE THAT TRANSFERS THE TOP 2 WDS.
;	OF THE SP STACK TO THE R1 STACK
MSPR1:	MOV	(SP)+,-(R1)
	MOV	(SP)+,-(R1)
	JMP	@(R4)+
;
;	KPUSH IS A SUBROUTINE TO PUSH THE CONSTANT THAT FOLLOWS THE
;	CALL ONTO THE R1 STACK.
KPUSH:	.REPT	FLTLEN
	MOV	(R0)+,-(R1)
	.ENDR
	RTS	R0		;RETURN TO CALLER
;
	.ENDC

	DEFORG	MAXL
;	SQRT	THE DOUBLE PRECISION SQUARE ROOT FUNCTION
;	CALLING SEQUENCE:
;	CALLED WITH ARG (4-WORD FL-PT NO.) ON THE R1 STACK
;		JSR	PC,SQRT
;		(RETURN)
;	RETURNS SQRT (4-WD FL-PT NO.) ON R1 STACK
;
SQRT:	.IF	DF	DECMAP
	JSR	PC,DSCTST	;GET 'FAF' ARG AND CHECK FOR SCALING
	.IFF
	JSR	R5,INTFUN	;DEMAND A FLOATING ARG
	ARGS	FAF
	.ENDC
	TST	(R1)		;GET HIGH ORDER ARGUMENT
	BPL	DSQRT1		;BR IF ARGUMENT POSITIVE
	BIC	#100000,(R1)	;MAKE IT POSITIVE
	ERROR	SQRERR		;SIGNAL ERROR BEFORE CONTINUING
DSQRT1:	BEQ	EXITSQ		;FAST EXITSQ IF ZERO
	.IF	NDF	FPU
	MOV	#4,-(SP)	;PUSH ITERATION COUNT
	MOV	R1,R2		;SAVE R1 BACKUP
	JSR	PC,DUPLF	;DUPLICATE ARG = F * 4^K, 1/2 <= F < 2
	CLR	-(R2)		;CLEAR LOW WORDS IN DUPLICATE
	CLR	-(R2)
	ASR	(R1)		;TAMPER WITH INITIAL COPY TO
	ROR	-(R2)		;FORM INITIAL ESTIMATE
	ADD	#20100,(R1)	; = (F+1)/2 * 2^K
LOOP:	JSR	R4,$POLSH	;ENTER POLISH MODE
	.WORD	TWICE		;DUPLICATE X AND ESTIMATE
	.WORD	$DVD,$ADD,LOOP1	;X/E+E
LOOP1:	SUB	#200,(R1)	;(X/E+E)/2
	DEC	(SP)		;COUNT LOOP
	BNE	LOOP		;GO AROUND AGAIN
	TST	(SP)+		;DISCARD COUNTER
	MOV	#8.,R2		;MOVE RESULT UP ON TOP OF ARGUMENT
	ADD	R1,R2
	MOV	(R1)+,(R2)+
	MOV	(R1)+,(R2)+
	MOV	(R1)+,(R2)+
	MOV	(R1)+,(R2)+
EXITSQ:	RTS	PC		;RETURN TO CALLER
	.ENDC
	.IF	DF	FPU
	CLR	-(SP)		;FORM INITIAL ESTIMATE
	CLR	-(SP)		;LOW-ORDER PARTS ARE 0
	MOV	2(R1),-(SP)	;TAMPER WITH COPY OF
	MOV	(R1),-(SP)	;HIGH-ORDER
	ASR	(SP)		;PARTS
	ROR	2(SP)
	ADD	#20100,(SP)
	MOV	#4,R0		;ITERATION COUNT
	SETD			;DOUBLE PRECESION FP
	LDD	(SP)+,F0	;GET INITIAL ESTIMATE
	LDD	(R1)+,F2	;GET X
;
LOOP:	LDD	F0,F1		;E=E'
	LDD	F2,F0		;X
	DIVD	F1,F0		;X/E
	ADDD	F1,F0		;X/E+E
	DEC	R0		;COUNT
	DIVD	#2.0,F0		;E'=(X/E+E)/2E
	BGT	LOOP		;LOOP
;
	STD	F0,-(R1)	;MOVE RESULT TO STACK
EXITSQ:	RTS	PC		;RETURN TO CALLER
	.ENDC

;	THE LOG AND LOG10 FUNCTIONS
;	CALLING SEQUENCE:
;	CALLED WITH ARG (4-WORD FL-PT NO.) ON R1 STACK
;		JSR	PC,LOG	(OR LOG10)
;		(RETURN)
;	RETURNS LN(ARG) (OR LOG10(ARG)) (4-WORD FL-PT NO.) ON R1 STACK
;
	.IF	NDF	FPU
LOG:	.IF	DF	DECMAP
	JSR	PC,DSCTST	;GET 'FAF' ARG AND CHECK FOR SCALING
	.IFF
	JSR	R5,INTFUN	;DEMAND A FLOATING ARG
	ARGS	FAF
	.ENDC
LOGF:	MOV	(R1)+,R0	;SAVE X IN R0,R2,R3,R4
	BLE	ERROR2		;JUMP IF NOT POSITIVE
	MOV	(R1)+,R2
	MOV	(R1)+,R3
	MOV	(R1)+,R4
	CMP	R0,#040200	;IS THIS LOG(1.000000)?
	BNE	10$		;NOPE
	MOV	R4,-(SP)	;MIGHT BE
	BIS	R3,(SP)
	BIS	R2,(SP)+
	BNE	10$		;BUT IT ISN'T
	JMP	PUSHF0		;THE LOG(1.0000000)=0.000000

10$:	JSR	R0,KPUSH	;PUSH -1/2*LN(2)
	 .WORD	147572,173721,071027,137661
	SUB	#8.,R1		;PUSH WORK SPACE
	MOV	R4,-(R1)	;PUSH X
	MOV	R3,-(R1)
	MOV	R2,-(R1)
	MOV	R0,-(R1)
	ASL	(R1)+
	MOVB	-(R1),-(SP)	;GET EXPONENT
	MOVB	#200,(R1)	;TRANSFORM X INTO [1/2,1)
	RORB	(R1)
	RORB	-(R1)
	JSR	R0,KPUSH	;PUSH 1/2*ROOT2
	 .WORD	157145,031771,002363,040065
	MOV	R4,-(R1)	;PUSH MODIFIED X
	MOV	R3,-(R1)
	MOV	R2,-(R1)
	MOV	14.(R1),-(R1)
	JSR	R0,KPUSH	;PUSH 1/2*ROOT2
	 .WORD	157145,031771,002363,040065
	JSR	R4,$POLSH	;ENTER POLISH MODE
	.WORD	$SBD,UP4,$ADD,$DVD
				;GET (X-ROOT2)/(X+ROOT2)
	.WORD	DUP4,DUP4	;GET THREE COPIES
	.WORD	$MLD,POLY4	;EXPAND POLYNOMIAL
	.WORD	CONST		;CONST. TAB. POINTER FOR POLY4
	.WORD	$MLD,$ADD	;LN(FRAC) = Y*POLY(Y*Y) - 1/2*LN(2)
	.WORD	SCALE2,$ID,PLN2,$MLD	;GET LN(EXP)
	.WORD	$ADD,LOGQZ	;COMBINE WITH FRACTION
				;AND CHECK IF DONE
;
ERROR2:	MOV	R0,-(R1)	;FIX UP R1 STACK
	ERROR	LOGERR		;NEGATIVE ARGUMENT A BAD SCENE
LOGQZ:	RTS	PC
;
SCALE2:	CLR	-(R1)
	BISB	(SP)+,(R1)	;GET EXPONENT
	SUB	#200,(R1)	;REMOVE EXCESS 128
	JMP	@(R4)+
;
PLN2:	JSR	R0,KPUSH	;PUSH LN(2)
	 .WORD	147572,173721,071027,040061
	JMP	@(R4)+
;
LOG10:	.IF	DF	DECMAP
	JSR	PC,DSCTST	;GET 'FAF' ARG AND CHECK FOR SCALING
	.IFF
	JSR	R5,INTFUN	;DEMAND A FLOATING ARG
	ARGS	FAF
	.ENDC
	JSR	PC,LOGF
	JSR	R0,KPUSH	;PUSH LOG10(E)
	 .WORD	024162,124467,055730,037736
	JMP	MULF
;
	.ENDC
	.IF	DF	FPU
LOG10:	.IF	DF	DECMAP
	JSR	PC,DSCTST	;GET 'FAF' ARG AND CHECK FOR SCALING
	.IFF
	JSR	R5,INTFUN	;DEMAND A FLOATING ARG
	ARGS	FAF
	.IFTF
	MOV	PC,R4		;GET NON-ZERO AS LOG10 FLAG
	BR	LOGF1
LOG:
	.IFT
	JSR	PC,DSCTST	;GET 'FAF' ARG AND CHECK FOR SCALING
	.IFF
	JSR	R5,INTFUN	;DEMAND A FLOATING ARG
	ARGS	FAF
	.ENDC
LOGF:	CLR	R4		;GET 0 AS LOG FLAG
LOGF1:	SETD			;DOUBLE PRECISION FP
	SETI			;SHORT INTEGERS
	MOV	#FCONS0,R0	;POINTER TO CONSTANTS
	LDD	(R1),F2		;GET ARG
	CFCC
	BLE	ERROR2		;JUMP IF NOT POSITIVE
	CMPD	#1.0,F2		;IS THIS LOG(1.000000000)?
	CFCC
	BNE	10$		;NOPE
	CLRD	F0		;YES, LOG(1.000000)=0.00000
	BR	LOGOUT		;AND EXIT

10$:	STEXP	F2,R2		;GET EXPONENT OF ARGUMENT
	LDCID	R2,F3		;CONVERT TO FP FOR.
	MULD	(R0)+,F3	;SCALE FACTOR=EXPONENT*LN(2)
	LDEXP	#0,F2		;TRANSFORM ARG TO(1/2,1)
;
	LDD	F2,F1		;
	SUBD	(R0),F2		;X-1/2*SQRT(2)
	ADDD	(R0)+,F1	;X+1/2*SQRT(2)
	DIVD	F1,F2		;W=(X-ROOT2)/(X+ROOT2)
	LDD	F2,F1		;
	MULD	F1,F1		;Y=W**2
;
	MOV	#6,R2		;COUNT CONSTANTS FOR POLYNOMIAL
	LDD	(R0)+,F0	;INITIALIZE ACCUMULATOR
XPAN0:	MULD	F1,F0		;
	DEC	R2		;COUNT
	ADDD	(R0)+,F0	;F0:= Y*F0 + C(I)
	BGT	XPAN0		;LOOP
	MULD	F2,F0		;
	ADDD	(R0)+,F0	;F0:= W*F0 - 1/2*LN(2)
	ADDD	F3,F0		;ADD SCALE FACTOR FOR EXPONENT
	TST	R4		;TEST LOG10 FLAG
	BEQ	LOGOUT		;
	MULD	(R0),F0		;LOG10 = LOG*LOG10(E)
;
LOGOUT:	STD	F0,(R1)		;MOVE RESULT TO STACK
	RTS	PC		;EXIT
ERROR2:	ERROR	LOGERR		;LOG IS INFINITE
	RTS	PC		;EXIT
;	ORDER-DEPENDENT CONSTANTS FOR ROUTINE
; 	R0 POINTS AT CURRENT CONSTANT IN FPU VERSION
;
FCONS0:	.WORD	040061,071027	;LN(2)
	.WORD	173721,147572	;
;
	.WORD	040065,002363	;1/2*SQRT(2)
	.WORD	031771,157145	;
	.ENDC
	.WORD	037455,106270	;.16948212488
	.WORD	157166,174770
;
	.WORD	037471,072731	;.1811136267967
	.WORD	137716,117115
;
	.WORD	037543,111153	;.22223823332791
	.WORD	060101,135465
;
	.WORD	037622,044436	;.2857140915904889
	.WORD	007306,063062
;
	.WORD	037714,146314	;.400000001206045365
	.WORD	153450,165773
;
	.WORD	040052,125252	;.6666666666633660894
	.WORD	125247,004643
;
	.WORD	040400,000000	;2.00000000000000261
	.WORD	000000,000057
	.IF	NDF	FPU
CONST:	.WORD	7
	.ENDC
	.IF	DF	FPU
;	MORE ORDER-DEPENDENT CONSTANTS
;
	.WORD	137661,071027	;-1/2*LN(2)
	.WORD	173721,147572	;
;
	.WORD	037736,055730	;LOG10(E)
	.WORD	124467,024162	;
	.ENDC

;	THE EXP FUNCTION
;	CALLING SEQUENCE:
;	CALLED WITH ARG (4-WD FL-PT NO.) ON R1 STACK
;		JSR	PC,EXP
;		(RETURN)
;	RETURNS E**ARG (4-WD FL-PT NO.) ON R1 STACK
;
EXP:	.IF	DF	DECMAP
	JSR	PC,DSCTST	;GET 'FAF' ARG AND CHECK FOR SCALING
	.IFF
	JSR	R5,INTFUN	;DEMAND A FLOATING ARG
	ARGS	FAF
	.ENDC
EXPF:	MOV	(R1),R0		;GET HIGH ORDER ARG IN R0
	.IF	NDF	FPU
	MOV	R0,-(SP)	;ALSO SAVE IT ON SP STACK
	.ENDC
	BGT	POS1		;JUMP IF +
	CMP	R0,#141660	;*A* ARG IS -
	BHI	ZERO4		;JUMP IF ARG < -88.7
	BR	SMTST		;JUMP TO TEST SMALL MAGNITUDE ARG
POS1:	CMP	R0,#41660
	BHI	OVER5		;JUMP IF ARG >87
SMTST:	ASL	R0		;DUMP SIGN
	CMP	R0,#044142
	BLOS	ONE		;JUMP IF ARG MAGNITUDE <2**-60
	.IF	NDF	FPU
	SUB	#8.,R1		;MOVE ARG UP TO GET WORK SPACE
	MOV	#16.,R2
	ADD	R1,R2
	MOV	-(R2),-(R1)
	MOV	-(R2),-(R1)
	MOV	-(R2),-(R1)
	MOV	-(R2),-(R1)
	JSR	R0,KPUSH	;PUSH LOG2(E)
	 .WORD	013761,024534,125073,040270
	JSR	R4,$POLSH	;ENTER POLISH MODE
	.WORD	$MLD		;Y=X*LOG2(E)
	.WORD	DUP4
	.WORD	$DI		;INT(X*LOG2(E))
	.WORD	ADJST
	.WORD	$ID		;Z=INT(X*LOG2(E)),Y>=0; Z=Z-1,Y<0
	.WORD	$SBD
	.WORD	M16		;D=16*(X*LOG2(E)-FLOAT(Z))
	.WORD	DUP4		;2 COPIES
	.WORD	$DI
	.WORD	DSAVE		;SAVE INTEGER PART OF 2**Y
	.WORD	$ID		;E=D-INT(D)
	.WORD	$SBD,D16	;E/16
	.WORD	DUP4,DUP4	;GET 3 COPIES
	.WORD	$MLD		;E*E
	.WORD	UNPOL1
ONE:	MOV	#40200,(R1)	;RESULT IS 1.
	BR	Z1

UNPOL1:	MOV	(R1)+,R0	;POP E*E TO REGISTERS
	MOV	(R1)+,R2
	MOV	(R1)+,R3
	MOV	(R1)+,-(SP)
	JSR	R0,KPUSH	;PUSH P0=7.213503410844819083
	 .WORD	033343,015345,152405,040746
	MOV	(SP),-(R1)	;PUSH E*E
	MOV	R3,-(R1)
	MOV	R2,-(R1)
	MOV	R0,-(R1)
	JSR	R0,KPUSH	;PUSH P1=.057761135831801928
	.WORD	153703,153011,113360,037154
	MOV	(SP)+,-(R1)	;PUSH E*E (AND POP SP)
	MOV	R3,-(R1)
	MOV	R2,-(R1)
	MOV	R0,-(R1)
	JSR	R0,KPUSH	;PUSH Q0=20.8137711965230362973
	 .WORD	171042,074433,101232,041246
	JSR	R4,$POLSH
	.WORD	$ADD,AUP	;A=E*E+Q0 TO WORK SPACE
	.WORD	$MLD,$ADD,$MLD	;B=E*(E*E*P1+P0)
	.WORD	TWICE		;DUPLICATE A AND B
	.WORD	$ADD,UP4	;A+B TO WORK SPACE
	.WORD	$SBD,$DVD	;(A+B)/(A-B)
	.WORD	SCALE		;APPLY SCALE FACTORS
SCALE:	MOV	#ROOTS2+8.,-(SP)	;POINT TO POWERS OF 2
ASR:	MOV	(SP)+,R0
ASR1:	ASR	(SP)		;SHIFT D
	BCS	RMULT		;MULTIPLY IF BIT IS SET
	BEQ	SCALE1		;SKIP OUT IF DONE
	SUB	#8.,R0		;BACK UP TO NEXT CONSTANT
	BR	ASR1		;GO AROUND AGAIN

RMULT:	MOV	-(R0),-(R1)	;PUSH 2**((2**N)*D/16)
	MOV	-(R0),-(R1)
	MOV	-(R0),-(R1)
	MOV	-(R0),-(R1)
	MOV	R0,-(SP)
	JSR	PC,MULF		;MULTIPLY BY ABOVE FACTOR
	BR	ASR		;AND TEST NEXT BIT

SCALE1:	TST	(SP)+		;FLUSH D
	MOV	(SP)+,R0	;GET Z
	SWAB	R0
	CLRB	R0		;MAKE INTO EXPONENT MODIFIER
	ASR	R0
	ADD	R0,(R1)		;APPLY TO RESULT
	BPL	OUT3		;JUMP IF NO OVERFLOW

OVER5:
ZERO4:	ERROR	EXPERR		;CAN'T DO EXPONENTIAL
	CLR	(R1)		;RESULT IS 0
Z1:	CLR	2(R1)
	CLR	4(R1)
	CLR	6(R1)
OUT3:	TST	(SP)+
	RTS	PC
;
ADJST:	TST	(SP)		;TEST X
	BGE	ARTN		;JUMP IF +
	DEC	(R1)		;Z=Z-1
ARTN:	MOV	(R1),-(SP)
	JMP	@(R4)+
;
M16:	ADD	#1000,(R1)	;16* STACK ITEM
	JMP	@(R4)+
;
D16:	SUB	#1000,(R1)	;1/16*STACK ITEM
	BPL	D16R		;JUMP IF NO UNDERFLOW
	CLR	(R1)		;UNDERFLOW=0
D16R:	JMP	@(R4)+
;
DSAVE:	MOV	(R1),-(SP)	;SAVE D AS AN INTEGER
	CMP	#16.,(R1)	;CHECK FOR BAD D VALUE
	BNE	1$		;NOPE
	CLR	(SP)		;CLEAR INT(D) OUT
	INC	2(SP)		;Z=Z+1 IN THAT CASE
1$:	JMP	@(R4)+
;
AUP:	MOV	#40.,R2		;MOVE A TO WORK SPACE
	ADD	R1,R2
	MOV	(R1)+,(R2)+
	MOV	(R1)+,(R2)+
	MOV	(R1)+,(R2)+
	MOV	(R1)+,(R2)
	JMP	@(R4)+
;
TWICE:	MOV	#8.,R0		;EIGHT WORDS
TW1:	MOV	14.(R1),-(R1)	;DUPLICATE 2 DOUBLES
	SOB	R0,TW1
	JMP	@(R4)+
;
	.WORD	040265,002363,031771,157145	;2**1/2
	.WORD	040230,033760,050615,134251	;2**1/4
	.WORD	040213,112701,161752,105727	;2**1/8
ROOTS2:	.WORD	040205,125303,063714,044173	;2**1/16
	.ENDC
;
	.IF	DF	FPU
	SETD			;DOUBLE PRECISION FP
	SETI			;SHORT INTEGERS
	MOV	#FCONS2,R0	;POINTER TO CONSTANTS
	LDD	(R1)+,F2	;GET ARGUMENT
	MODD	(R0)+,F2	;F2=FRACT(X*LOG2(E))
	STCDI	F3,R4		;Z=INT(X*LOG2(E))
	TSTD	F2		;
	CFCC			;
	BGE	ONEP		;TEST F2
	ADDD	#1.0,F2		;MAKE F2 POSITIVE
	DEC	R4		;AND ADJUST Z=Z-1
ONEP:	CMPD	#1.0,F2		;FRAC = 1.0?
	CFCC
	BGT	M16		;NO
	CLRD	F2		;RESET TO 0
	INC	R4		;BUMP Z=Z+1
M16:	MODD	#16.0,F2	;F2=FRACT(16*(X*LOG2(E)-FLOAT(Z)))
	STCDI	F3,R3		;D=INT (16*(...
	DIVD	#16.0,F2	;E=F2/16
	LDD	F2,F3		;
	MULD	F3,F3		;E*E
;
	LDD	F3,F1		;
	ADDD	(R0)+,F1	;A=E*E+Q0
	MULD	(R0)+,F3	;
	ADDD	(R0)+,F3	;
	MULD	F2,F3		;B=(E*E*P1 + P0)*E
	LDD	F1,F0		;
	ADDD	F3,F0		;A+B
	SUBD	F3,F1		;A-B
	DIVD	F1,F0		;(A+B)/(A-B)
;
SCALE:	ASR	R3		;SHIFT D
	BCC	NOMULT		;
	MULD	(R0)+,F0	;MULTIPLY BY ROOT OF 2
	BR	SCALE		;
NOMULT:	BEQ	SCALE1		;
	ADD	#8.,R0		;POINT TO NEXT ROOT OF 2
	BR	SCALE		;
;
SCALE1:	STD	F0,-(R1)	;MOVE RESULT TO STACK
	SWAB	R4		;CONVERT Z TO EXPONENT MODIFIER
	CLRB	R4		;
	ASR	R4		;
	ADD	R4,(R1)		;APPLY TO RESULT
	BMI	OVER5		;JUMP IF OVERFLOW
	RTS	PC		;EXIT
;
ONE:	MOV	#40200,(R1)	;RESULT IS 1.
	BR	Z1
OVER5:
ZERO4:	ERROR	EXPERR		;CAN'T DO EXPONENTIAL
	CLR	(R1)		;RESULT IS 0
Z1:	CLR	2(R1)
	CLR	4(R1)
	CLR	6(R1)
	RTS	PC		;EXIT
;
;	ORDER-DEPENDENT CONSTANTS
;	R0 POINTS AT NEXT CONSTANT IN FPU VERSION
;
FCONS2:	.WORD	40270,125073,024534,013761	;LOG2(E)
;
	.WORD	041246,101232,074433,171042	;Q0
	.WORD	037154,113360,153011,153703	;P1
	.WORD	040746,152405,015345,033343	;P0
	.WORD	040205,125303,063714,044173	;2**1/16
	.WORD	040213,112701,161752,105727	;2**1/8
	.WORD	040230,033760,050615,134251	;2**1/4
	.WORD	040265,002363,031771,157145	;2**1/2
	.ENDC

	.END

