TITLE	XLMA2,<2-WORD FUNCTIONS>,08,13-MAY-86,TPH/JDM/MHB/SLR

;                   Copyright 1974,1990 by Digital Equipment Corporation
;                                  All rights reserved.
;
;          This software is furnished under a license and may be used and copied
;          only  in  accordance  with  the  terms  of  such license and with the
;          inclusion of the above copyright notice.  This software or any copies
;          shall not be provided to any other person.   No title to or ownership
;          of the software is hereby transferred.
;
;          The information in this software is subject to change without notice.
;
;          DIGITAL  assumes  no  responsibility  for the  use, functionality, or
;          reliability of its  software  on equipment  which  is not supplied by
;          DIGITAL.
;
;	MODIFICATIONS:
;
;*A* 4-FEB-80 REILLY: CHECK EXP ARGUMENTS BETTER

.SBTTL	EXTERNAL GLOBALS
;
	.GLOBL	INTFUN,ADDF,MULF,DIVF
	.IF	NDF	FPU
	.GLOBL	$ADR,$SBR,$MLR,$DVR,$IR,$RI,$INTR,DUP2
	.GLOBL	$POLSH,DUPLF
	.ENDC

.SBTTL	LOAD PUSH-POP CODE FOR FUNCTIONS

	ORG	PT,0

	..	PPSQRT,SQRT
	..	PPEXP,EXP
	..	PPLN,LOG
	..	PPLG10,LOG10

.SBTTL	LONG ROUTE FOR A**B (A**B = EXP(B*LOG(A)) )

	ORG	XF,0

XF:	JSR	PC,LOGF		;TAKE LOG OF NUMBER TO EXPONENTIATE
	MOVFLT	(SP)+,-(R1)	;EXPONENT BACK TO R1
	JSR	PC,MULF		;MULT BY LOG OF NUMBER
	JMP	EXPF		;AND EXIT THRU EXPONENTIAL ROUTINE

	.IF	NDF	FPU
	ORG	POLY,0
POLY:
;	POLY4 IS A POLYNOMIAL EVALUATOR TO EVAL
;	C(N)*X**N+C(N-1)*X**N-1+...+C(1)*X+C(0)
;	CALL POLY4 (VIA $POLSH) WITH X (A 4-WD FL-PT NO.)
;	ON THE R1 STACK AND C(R4)=A POINTER TO A POINTER TO A WORD
;	CONTAINING N+1, I.E., THE NO. OF CONSTANTS.
;	THE CONSTANTS THEMSELVES ARE STORED (AS 4-WD FL-PT
;	NO'S.) IMMED. BEFORE THE WORD CONTAINING THE N+1,
;	WITH C(N) AT LOWEST ADDR AND C(0) AT HIGHEST.
;	E.G., TO EVAL. 5*X**2+3*X+2, THE CONST. TABLE
;	LOOKS LIKE:
;		.WORD	...,...,...,...		;4-WD FL-PT 5, I.E. C(2)
;		.WORD	...,...,...,...		;4-WD FL-PT 3, I.E. C(1)
;		.WORD	...,...,...,...		;4-WD FL-PT 2, I.E. C(0)
;		.WORD	3			;NO. OF CONS'TS
;
POLY2:	;POLY2 IS LIKE POLY4 - BUT FOR 2-WORD STUFF
POLY4:	MOV	(R4)+,R0	;POINTER TO NUMBER OF COEFFICIENTS, ETC.
	MOV	R4,-(SP)	;SAVE RETURN POINTER
	MOV	(R0),R4		;SAVE THE NUMBER OF COEFFICIENTS IN R4
	MOV	R4,-(SP)	;AND ON THE STACK
	MOV	(R1)+,R2	;SAVE X
	MOV	(R1)+,R3
	.REPT	FLTLEN-2
	MOV	(R1)+,-(SP)
	.ENDR
	BR	PLP42		;GO PUSH A COEFFICIENT
PLP41:	.IF	EQ	FLTLEN-4	;FETCH X BACK TO THE R1 STACK
	MOV	(SP),-(R1)
	MOV	2(SP),-(R1)
	.ENDC
	MOV	R3,-(R1)
	MOV	R2,-(R1)
PLP42:	MOVFLT	-(R0),-(R1)	;PUSH ONE OF THE COEFFICIENTS
	DEC	R4		;DECREMENT THE COEFFICIENT COUNT
	BGT	PLP41		;AROUND AGAIN IF COUNT NOT DONE
	.IF	EQ	FLTLEN-4
	CMP	(SP)+,(SP)+	;SOME GARBAGE OFF THE STACK
	.ENDC
	DEC	(SP)		;DECREMENT 2ND COPY OF COUNTER
PLP43:	JSR	PC,MULF		;MULTIPLY TOP OF STACK BY X
	JSR	PC,ADDF		;ADD IN NEXT COEFFICIENT
	DEC	(SP)		;DECREMENT COEFFICIENT COUNT
	BGT	PLP43		;BR IF MORE TO DO IN LOOP
	TST	(SP)+		;POP THE COUNTER
	MOV	(SP)+,R4	;RESTORE POLISH POINTER
	JMP	@(R4)+		;POLISH EXIT

;	UP4 IS A POLISH ROUTINE TO MOVE THE 4 WDS AT THE HEAD
;	OF THE STACK TO A LOC 8 WD'S AWAY INSIDE THE STACK
UP2:	;LIKE UP4 BUT 2 WORDS AT HEAD GET MOVED 4 WORDS AWAY
UP4:	MOVFLT	(R1)+,6*FLTLEN-2(R1)  ;MOVE SOME WORDS SOME DISTANCE
	JMP	@(R4)+
;
;	MSPR1 IS A POLISH ROUTINE THAT TRANSFERS THE TOP 2 WDS.
;	OF THE SP STACK TO THE R1 STACK
MSPR1:	MOV	(SP)+,-(R1)
	MOV	(SP)+,-(R1)
	JMP	@(R4)+
;
	.ENDC

	DEFORG	MAXL
;	SQRT	THE SQUARE ROOT FUNCTION
;	CALLING SEQUENCE:
;	CALLED WITH ARG (2-WORD FL-PT NO) ON THE R1 STACK
;		JSR	PC,SQRT
;		(RETURN)
;	RETURNS THE SQUARE ROOT (2-WD FL-PT NO.) ON THE R1 STACK
;
SQRT:	JSR	R5,INTFUN	;DEMAND FLOATER
	+FAF
	TST	(R1)		;SET FLAGS
	BPL	SQRT1		;BR ON NONNEGATIVE ARG
	BIC	#100000,(R1)	;POSITIVIZE NEGATIVE ARG
	ERROR	SQRERR		;SIGNAL ERROR
SQRT1:	BEQ	EXITSQ		;FAST EXITSQ IF ZERO
	.IF	NDF	FPU
	MOV	#3,-(SP)	;PUSH ITERATION COUNT
	.ENDC
	MOV	2(R1),-(SP)	;SAVE LOW-ORDER WD OF ARG
	MOV	(R1),-(SP)	;SAVE HIGH-ORDER WD OF ARG
	ASR	(R1)		;FORM INITIAL ESTIMATE
	ADD	#20100,(R1)
	CLR	2(R1)		;USE 0 FOR LOW-ORDER PART
				;TO SPEED ADD,DIV
	.IF	NDF	FPU
	CLR	-(R1)		;PUSH ARG ON R1,USE 0 FOR LOW PART
	MOV	(SP),-(R1)	;PUSH HIGH-ORDER WD OF ARG
	CLR	-(R1)		;PUSH EST AGAIN (USE 0 FOR LOW PART)
LOOP:	MOV	6(R1),-(R1)	;PUSH HIGH-ORDER WD OF ESTIMATE
	JSR	R4,$POLSH	;ENTER POLISH MODE
	.WORD	$DVR,$ADR,UNPOL	;(X/E+E)
UNPOL:	SUB	#200,@R1	;(X/E+E)/2
	DEC	4(SP)		;COUNT LOOP
	BEQ	RTN2		;LEAVE IF COUNT EXHAUSTED
	MOV	2(SP),-(R1)	;ELSE PUSH LOW-ORDER WD OF ARG
	MOV	(SP),-(R1)	;THEN HIGH-ORDER WD OF ARG
	MOV	6(R1),-(R1)	;THEN LOW-ORDER WD OF ESTIMATE
	BR	LOOP		;GO FOR ANOTHER ITERATION
RTN2:	ADD	#6,SP		;CLEAN UP SP STACK
EXITSQ:	RTS	PC		;RETURN TO CALLER
	.ENDC
	.IF	DF	FPU
	MOV	#3,R0		;ITERATION COUNT
	SETF			;SINGLE PRECISION FP
	LDF	(R1)+,F0	;GET INITIAL ESTIMATE
	LDF	(SP)+,F2	;GET X
;
LOOP:	LDF	F0,F1		;E=E'
	LDF	F2,F0		;X
	DIVF	F1,F0		;X/E
	ADDF	F1,F0		;X/E+E
	DEC	R0		;COUNT
	DIVF	#2.0,F0		;E'=(X/E+E)/2
	BGT	LOOP
;
	STF	F0,-(R1)	;RESULT TO STACK
EXITSQ:	RTS	PC		;RETURN TO CALLER
	.ENDC

;	THE LOG AND LOG10 FUNCTIONS
;	CALLING SEQUENCE:
;	CALLED WITH ARG (2-WORD FL-PT NO.) ON R1 STACK
;		JSR	PC,LOG	(OR LOG10)
;		(RETURN)
;	RETURNS LN(ARG) (OR LOG10(ARG)) (2-WORD FL-PT NO.) ON R1 STACK
;
	.IF	NDF	FPU
LOG:	JSR	R5,INTFUN	;DEMAND FLOATING ARG
	+FAF
LOGF:	MOV	(R1)+,R2	;SAVE X IN R2,R3
	BLE	ERROR2		;JUMP IF NOT POSITIVE
	MOV	(R1)+,R3
	MOV	#071030,-(R1)	;PUSH -1/2*LN(2)
	MOV	#137661,-(R1)
	CMP	-(R1),-(R1)	;PUSH WORK SPACE
	MOV	R3,-(R1)	;PUSH X
	MOV	R2,-(R1)
	ASL	(R1)+
	MOVB	-(R1),-(SP)	;GET EXPONENT
	MOVB	#200,(R1)	;TRANSFORM X INTO (1/2,1)
	RORB	(R1)
	RORB	-(R1)
	MOV	#002363,-(R1)	;PUSH 1/2*ROOT2
	MOV	#040065,-(R1)
	MOV	R3,-(R1)	;PUSH MODIFIED  X
	MOV	6(R1),-(R1)
	MOV	#002363,-(R1)	;PUSH 1/2*ROOT2
	MOV	#040065,-(R1)
	JSR	R4,$POLSH	;ENTER POLISH MODE
	.WORD	$SBR,UP2,$ADR,$DVR
				;GET (X-ROOT2)/(X+ROOT2)
	.WORD	DUP2,DUP2	;GET THREE COPIES
	.WORD	$MLR,POLY2	;EXPAND POLYNOMIAL
	.WORD	CONST		;CONST. TAB. PTR. FOR POLY2
	.WORD	$MLR,$ADR
	.WORD	SCALE1,$IR,PLN2,$MLR	;GET LN(EXP)
	.WORD	$ADR,LOGQZ	;COMBINE WITH FRACTION
				;AND CHECK IF DONE
;
SCALE1:	CLR	-(R1)
	BISB	(SP)+,(R1)	;GET EXPONENT
	SUB	#200,(R1)	;REMOVE EXCESS 128
	JMP	@(R4)+
;
PLN2:	MOV	#071030,-(R1)	;PUSH LN(2)
	MOV	#040061,-(R1)
	JMP	@(R4)+
;
LOG10:	JSR	PC,LOG
	MOV	#055731,-(R1)	;PUSH LOG10(E)
	MOV	#037736,-(R1)
	JMP	MULF
LOGQZ:	RTS	PC
;
ERROR2:	MOV	R2,-(R1)	;FIX UP R1 STACK
	ERROR	LOGERR		;LOG IS INFINITE
	RTS	PC
	.ENDC
	.IF	DF	FPU
LOG10:	JSR	R5,INTFUN	;DEMAND FLOATING ARG
	+FAF
	MOV	PC,R4		;GET NON-ZERO AS LOG10 FLAG
	BR	LOGF1
LOG:	JSR	R5,INTFUN	;DEMAND FLOATING ARG
	+FAF
LOGF:	CLR	R4		;GET 0 AS LOG FLAG
LOGF1:	SETF			;SINGLE PRECISION FP
	SETI			;SHORT INTEGERS
	MOV	#FCONS0,R0	;POINTER TO CONSTANTS FOR ROUTINE
	LDF	(R1),F2		;GET ARGUMENT
	CFCC
	BLE	ERROR2		;JUMP IF NOT POSITIVE
	STEXP	F2,R2		;GET EXPONENT OF ARG
	LDCIF	R2,F3		;CONVERT TO FP FORM
	MULF	(R0)+,F3	;SCALE FACTOR=EXPONENT*LN(2)
	LDEXP	#0,F2		;TRANSFORM ARG TO (1/2,1)
	LDF	F2,F1
	SUBF	(R0),F2		;X-1/2*SQRT(2)
	ADDF	(R0)+,F1	;X+1/2*SQRT(2)
	DIVF	F1,F2		;W=(X-ROOT2)/(X+ROOT2)
	LDF	F2,F1
	MULF	F1,F1		;Y= W**2
;
	MOV	#3,R2		;COUNT OF CONSTS FOR POLYNOMIAL
	LDF	(R0)+,F0	;INITIALIZE ACCUMULATOR FOR POLYNOMIAL
XPAN0:	MULF	F1,F0
	DEC	R2		;COUNT
	ADDF	(R0)+,F0	;F0:=Y*F0 + C(I)
	BGT	XPAN0		;LOOP
;
	MULF	F2,F0
	ADDF	(R0)+,F0	;F0:= W*F0 - 1/2*LN(2)
	ADDF	F3,F0		;ADD SCALE FACTOR FOR EXPONENT
	TST	R4		;TEST LOG10 FLAG
	BEQ	LOGOUT
	MULF	(R0)+,F0	;LOG10:= LOG*LOG10(E)
;
LOGOUT:	STF	F0,(R1)		;MOVE RESULT TO STACK
	RTS	PC		;EXIT
ERROR2:	ERROR	LOGERR		;LOG IS INFINITE
	RTS	PC		;EXIT
;	ORDER-DEPENDENT CONSTANTS FOR ROUTINE
;	R0 POINTS AT CURRENT CONSTANT IN FPU VERSION
;
FCONS0:	.WORD	040061,071030	;LN(2)
;
	.WORD	040065,002363	;1/2*SQRT(2)
	.ENDC
;CONSTANTS FOR POLYNOMIAL EXPANSION
;
	.WORD	037632,014525	;.300974506
	.WORD	037714,120036	;.399659100
	.WORD	040052,125332	;.666669471
	.WORD	040400,000000	;1.99999999
	.IF	NDF	FPU
CONST:	.WORD	4
;
	.ENDC
	.IF	DF	FPU
;	MORE ORDER-DEPENDENT CONSTANTS
	.WORD	137661,071030	;-1/2*LN(2)
;
	.WORD	037736,055731	;LOG10(E)
	.ENDC

;	EXP	THE EXPONENTIATION ROUTINE
;	CALLING SEQUENCE:
;	CALLED WITH ARG (2-WD FL-PT NO.) ON R1 STACK
;		JSR	PC,EXP
;		(RETURN)
;	RETURNS EXPONENTIAL (2-WD FL-PT NO.) ON R1 STACK
;
EXP:	JSR	R5,INTFUN	;DEMAND FLOATING ARG
	+FAF
EXPF:	MOV	(R1)+,R0	;POP HIGH-ORDER WD OF ARG TO R0
	MOV	(R1)+,R3	;POP LOW-ORDER WD TO R3
	MOV	R0,R2		;HIGH-ORDER WD ALSO TO R2
	BGT	POS1		;JUMP IF ARG +
	CMP	R0,#141660	;*A* CHECK IF EXPON. < -88.4
	BHI	ZERO2		;JUMP IF EXPONENT < -88.4
	BR	SMTST
POS1:	CMP	R0,#41660
	BHI	OVER4		;JUMP IF EXPONENT > 87
SMTST:	ASL	R0		;DUMP SIGN
	CMP	R0,#63000
	BLO	ONE		;JUMP IF EXPONENT MAGNITUDE < 2**-28
	.IF	NDF	FPU
	CLR	-(R1)		;PUSH A 1.
	MOV	#40200,-(R1)
	.ENDC
	MOV	R3,-(R1)	;GET LOW ORDER ARGUMENT
	MOV	R2,-(R1)	;HIGH ORDER
	.IF	NDF	FPU
	JSR	R4,$POLSH	;ENTER POLISH MODE
	.WORD	DUP2
	.WORD	PL2E		;PUSH LOG2(E)
	.WORD	$MLR
	.WORD	$RI		;FIX LOG2(E)*X
	.WORD	ESAVE		;SAVE EXPONENT SCALE
	.WORD	$IR		;FLOAT IT
	.WORD	PL2E		;PUSH LOG2(E)
	.WORD	$DVR
	.WORD	$SBR
	.WORD	CFRACT		;PUSH CONTINUED FRACTION CONSTANTS
	.WORD	$MLR		;Y*Y
	.WORD	$ADR		;B1+Y*Y
	.WORD	$DVR		;A1/(B1+Y*Y)
	.WORD	$ADR		;Y+A1/(B1+Y*Y)
	.WORD	$ADR		;A0+Y+A1/(B1+Y*Y)
	.WORD	$DVR		;Y/(A0+Y+A1/(B1+Y*Y))
	.WORD	INC		;-2*Y/(A0+Y+A1/(B1+Y*Y))
	.WORD	$ADR		;1-2*Y/.........
	.WORD	DUP2		;DUPLICATE IT
	.WORD	$MLR		;(1-2*Y/.....)**2
	.WORD	SCALE		;EXIT POLISH MODE AND SCALE RESULT
INC:	ADD	#100200,(R1)	;MULTIPLY BY -2.0
	JMP	@(R4)+		;GO BACK TO LIST
;
PL2E:	MOV	#125073,-(R1)	;PUSH LOG2(E)
	MOV	#40270,-(R1)
	JMP	@(R4)+
;
ESAVE:	MOV	(R1),-(SP)	;SAVE EXPONENT SCALE
	JMP	@(R4)+
;
CFRACT:	ROL	(R1)		;SHIFT MODIFIED ARG
	ROL	R0		;SAVE SIGN
	SUB	#400,(R1)	;DIVIDE BY 2.
	BLOS	ZFRACT		;UNDERFLOW. MAKE ARG 0
	ROR	R0		;GET SIGN BACK
	ROR	(R1)
	MOV	(R1),R0		;GET MODIFIED ARGUMENT
	MOV	2(R1),R2	;IN REGISTERS
	MOV	#036602,-(R1)	;PUSH -12.01501675 ***********
	MOV	#141100,-(R1)
	MOV	R2,-(R1)	;PUSH MODIFIED ARG
	MOV	R0,-(R1)
	MOV	#071571,-(R1)	;PUSH 601.8042667 ***************
	MOV	#042426,-(R1)
	MOV	#056133,-(R1)	;PUSH 60.0901907 ***********
	MOV	#041560,-(R1)
	MOV	R2,-(R1)	;PUSH MODIF. ARG AGAIN
	MOV	R0,-(R1)
	MOV	R2,-(R1)	;AND AGAIN
	MOV	R0,-(R1)
	JMP	@(R4)+
	.ENDC
;
	.IF	DF	FPU
	SETD			;DOUBLE PRECISION ARGUMENT REDUCTION
	SETI			;SHORT INTEGERS
	MOV	#FCONS2,R0	;POINTER TO CONSTANTS
	LDCFD	(R1)+,F2	;GET ARGUMENT
	MODD	(R0)+,F2	;F2=FRACT(X*LOG2(E))
	STCDI	F3,R4		;R4=INT (X*LOG2(E))
	LDD	#1.0,F0		;F0=1.0
	DIVD	(R0)+,F2	;Y=F2/(2*LOG2(E))
	SETF
	LDCDF	F2,F2		;REST IN SINGLE PRECISION
	CFCC			;TEST FOR UNDERFLOW
	BEQ	SCALE1		;APPROXIMATION RESULT IS 1.0
	LDF	F2,F3
	MULF	F3,F3		;Y*Y
	ADDF	(R0)+,F3	;B1+Y*Y
	LDF	(R0)+,F1
	DIVF	F3,F1		;A1/(B1+Y*Y)
	ADDF	F2,F1
	ADDF	(R0)+,F1	;A0+Y+A1/(B1+Y*Y
	DIVF	F1,F2		;Y/(A0+Y+A1/(B1+Y*Y
	MULF	#2.0,F2
	SUBF	F2,F0		;1-2*Y/. . .
	MULF	F0,F0		;(1-2*Y. . . )**2
SCALE1:	STF	F0,-(R1)	;MOVE APPROXIMATION TO STACK
	MOV	R4,R0
	.ENDC
	.IF	NDF	FPU
ZFRACT:	CMP	(R1)+,(R1)+	;FLUSH CFRACT ARG
;			RESULT IS 1.
SCALE:	MOV	(SP)+,R0	;GET INTEGER PART OF X*LOG2(E)
	.ENDC
	SWAB	R0		;MAKE IT INTO EXPONENT MODIFIER
	CLRB	R0
	ASR	R0
	ADD	R0,(R1)		;ADD IN APPROXIMATION RESULT
	BPL	EXPXIT
	CMP	(R1)+,(R1)+
OVER4: ZERO2:	ERROR	EXPERR
	CLR	-(R1)		;RETURN 0
	CLR	-(R1)
EXPXIT:	RTS	PC
ONE:	CLR	-(R1)
	MOV	#40200,-(R1)	;EXP(TINY) = 1.
	RTS	PC
	.IF	DF	FPU
;	ORDER-DEPENDENT CONSTANTS
;
FCONS2:	.WORD	040270,125073	;LOG2(E) DOUBLE PRECISION
	.WORD	024534,013761
;
	.WORD	040470,125073	;2*LOG2(E) DOUBLE PRECISION
	.WORD	024534,013761
;
	.WORD	041560,056133	;B1=60.0901907
;
	.WORD	042426,071571	;A1=601.8042667
;
	.WORD	141100,036602	;A0=-12.01501675
	.ENDC

	.END

