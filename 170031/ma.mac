TITLE	MA,<MATH COMMON>,08,13-MAY-86,MHB/TPH/TGE/LD/TVG/ABC/SLR/TS

;                   Copyright 1974,1990 by Digital Equipment Corporation
;                                  All rights reserved.
;
;          This software is furnished under a license and may be used and copied
;          only  in  accordance  with  the  terms  of  such license and with the
;          inclusion of the above copyright notice.  This software or any copies
;          shall not be provided to any other person.   No title to or ownership
;          of the software is hereby transferred.
;
;          The information in this software is subject to change without notice.
;
;          DIGITAL  assumes  no  responsibility  for the  use, functionality, or
;          reliability of its  software  on equipment  which  is not supplied by
;          DIGITAL.
;
;	MODIFICATIONS:
;
; *A* 30-APR-81 REILLY     CHECK NEGATIVE SUBSCRIPTS
; *B* 06-MAY-81 REILLY     ALLOW SINGLE + OR - SIGNS FOR REAL NUMBERS
; *C* 23-OCT-81 SCARPELLI: FIX BUG IN *A*, 2ND SUBSCRIPT IS BIASED BY 1.

;THIS IS THE COMMON FRONT FOR THE 2-WORD AND 4-WORD MATH PACKAGE

;FOR THE 2-WORD MATH PACKAGE ASSEMBLE:
;COMMON,USER,SYRC,SYPP,MA2?,MA,XCMA2[,XFMA2],END

;FOR THE 4-WORD  MATH PACKAGE ASSEMBLE:
;COMMON,USER,SYRC,SYPP,MA4?,MA,XCMA4[,XFMA4],END

;FOR THE 4-WORD DECIMAL MATH PACKAGE ASSEMBLE:
;COMMON,USER,SYRC,SYPP,MA4D,MA,MAD

	.SBTTL	PUSH-POPS DEFINED

	ORG	PT,0

	..	PPUSHF,PUSHF
	..	PPOPF,POPF
	..	PPFLPF,FPOPF
	..	PPFLRF,FREPLF
	..	PPOPI,POPI
	..	PPFIPI,IPOPI
	..	PPFIRI,IREPLI
	..	PPOPS,POPS
	..	PPADDF,ADDF
	..	PPSUBF,SUBF
	..	PPSGNF,SGNF
	..	PPUFL0,PUSHF0
	..	PPUFL1,PUSHF1
	..	PPABSF,ABSF
	..	PPRSBF,RSUBF
	..	PPNEGF,NEGF
	..	PPINTF,INTF
	..	PPFLT1,FLT1
	..	PPPWRF,PWRF
	..	PPRND,RND
	..	PPRAND,RANDOM
	..	PPTIME,TIMEF
	..	PPFIX0,PUSHI0
	..	PPMULI,MULI
	..	PPDIVI,DIVI
	.IF	DF	DECMAP
	..	PPMULF,MULF.S
	..	PPDIVF,DIVF.S
	.IFF
	..	PPMULF,MULF
	..	PPDIVF,DIVF
	.ENDC
	..	PPFIX,FIX
	..	PPFLT,FLT
	..	PPRINF,PRINTF
	..	PPRINI,PRINTI
	..	PPRINS,PRINTS
	..	PPCOMA,NXTZON
	..	PPCRLF,CRLF
	..	PPEXIT,EXITPP
	..	PPIJS,PITJS
	..	PPEVF,.EV.F
	..	PPABXF,ABSF00
	..	PPREPF,REPLF
	..	PPFIXF,FIXF
	..	PPFID1,IINR1
	..	PPFLD1,FINR1
	..	PPFIR1,IINL1
	..	PPFLR1,FINL1
	..	PPFID2,IINR2
	..	PPFLD2,FINR2
	..	PPFIR2,IINL2
	..	PPFLR2,FINL2
	..	PPIDO1,INDO1
	..	PPIDO2,INDO2
	..	PPIDR1,INDR1
	..	PPIDR2,INDR2
	..	PPIRR1,INDL1
	..	PPIRR2,INDL2
	..	PPUSHC,PUSHC
	..	PPUFLX,PUSHXF
	..	PPCFDI,CNVFDI

	.SBTTL	PO - PRINT USING OVERLAY THIS DISPATCH TABLE

	DEFORG	PO		;POSSIBLE OVERLAY BY PRINT USING
PRINU0:	.WORD	PRNFL3
PRINU1:	.WORD	PRS01		;A "RTS PC"

	.SBTTL	MATH PACKAGE DEFINITIONS/GLOBALS
	DEFORG	MA
	DEFORG	MI
	ORG	MA

	.IF	EQ	.MATH.
	.GLOBL	FLTLE3,FLTLE5,FLTLE4,NXTZON,PRINTF,SINF1
	.GLOBL	EXPDIF,INDEGH,INDO3,$POLSH,DUPLF,PUSHF0
	.IF	NDF	FPU
	.IF	EQ	FLTLEN-2
	.GLOBL	$ADR,$SBR,$MLR,$DVR,$IR,$RI,$INTR,DUP2
	.IFF
	.GLOBL	$ADD,$SBD,$MLD,$DVD,$ID,$DI,$DINT,DUP4
	.ENDC
	.ENDC
	.IF	DF	DECMAP
	.GLOBL	DSCTST
	.ENDC
	.ENDC

	.GLOBL	FLTLEN,FLTLE2,MFLTL2,DOSCAL		;INTERNAL
	.GLOBL	ATOF,CRLF,PRINU2,PRNBUF,PRNBUC
	.GLOBL	PRINTA,PRINTI,PRINTL,PRINTS
	.GLOBL	PSTJS,PUSHF1,MAXSIG,$PLSIG,INDARY
	.GLOBL	PRINU3,.MATH.,Z00000
	.GLOBL	MULI,PRNF15,PRNF05,PRNFL3
	.GLOBL	PRL14,FLT,SUBF,ADDF,MULF,DIVF,FIX,CMPF
	.GLOBL	INDR3,INDX90,INDO1,INDO2,INTFUN,DEFFUN
	.GLOBL	INCTAB,PUSHF2,PUSHF3
	.GLOBL	PUSHF,POPS1,POPF1,PRNFL1,PRNFL2
	.GLOBL	TOKZIP,ZARRY4,BNT4,PNTUXP
	.GLOBL	SPDAR0
	.GLOBL	SCATAB,SCASUP,SCAINI,SCAMAX

;EXTERNAL REFERENCES TO OTHER SEGMENTS

	.GLOBL	CRLF0,POS000,MAPTOK
	.GLOBL	ATOI,SAVEM,FLOTIM
	.GLOBL	READ.,WRITE.,IODIE,THENT,NUM$00
	.GLOBL	.EQ.S,PUSHS1,PUSHS2,BUILDS,REPLS1
	.GLOBL	GUSINT,TLENDP,EDCTLH,LENNUM,TLGENP

FLTLE2	=	FLTLEN*2
FLTLE3	=	FLTLEN*3
FLTLE5	=	FLTLEN*5
MFLTL2	=	-FLTLE2
FLTLE4	=	FLTLEN*4

; A COUPLE OF PRINT BUFFER PARAMETERS WHICH NEED TO BE UP FRONT

PRNBUC	=40.			;ADD THIS MUCH BUFFER TO FTOA BUFFER
PRNBUF	=PRNBUC+FLTLE5+2	;TO MAKE THIS MUCH TOTAL BUFFER FOR PRINTA

	.IF	EQ	.MATH.
Z00000	=	ONECON+6	;REL SPDA LOCATION OF INTEGER 0
EXPDIF	=	400*40.		;MAX EXP SHRINK IN SPECIAL MATINV PP
MAXSIG	=	16.		;MAX NUMBER SIG. CHARS AVAILABLE
MAXPOW	=	32.		;BIGGEST POWER OF 10 IN CONV. TABLE
PNTUXP	=	'^		;ALLOW ^^^^ FOR EXPONENTS
	.IF	EQ	FLTLEN-2
EXPDIF	=	400*18.		;LESS SHRINKAGE FOR 2-WORD
MAXSIG	=	7		;NOT AS MUCH SIGNIFICANCE IN 2-WORD
	.ENDC
	.ENDC
	.IF	NE	.MATH.
Z00000	=	ONECON+0	;REL SPDA LOCATION OF INTEGER 0
MAXSIG	=	13.+6.		;19. TOTAL DIGITS IN THIS PACKAGE
PNTUXP	=	'-		;DISALLOW ^^^^ FOR EXPONENTS
	.ENDC

$PLSIG	=	400*<MAXSIG-1>+PRNBUF ;MAXIMAL PRINT FOR NUM1$

.SBTTL	TABLE OF ONE AND PI

SCATAB:				;TABLE OF PI & ONE
	.IF	NE	.MATH.
	.WORD	000000,000000,000057,167731	;PI
	.WORD	000000,000000,000017,041100	;ONE
	.ENDC
	.IF	EQ	.MATH.
	.IF	EQ	FLTLEN-2
	.WORD	040511,007733,000000,000000	;PI
	.WORD	040200,000000,000000,000000	;ONE
	.ENDC
	.IF	EQ	FLTLEN-4
	.WORD	040511,007732,121041,064302	;PI
	.WORD	040200,000000,000000,000000	;ONE
	.IF	DF	DECMAP
	.WORD	041373,051721,045251,141363	;PI*10.
	.FLT4	1E1
	.WORD	042235,012142,147252,014730	;PI*100.
	.FLT4	1E2
	.WORD	043104,054573,101124,120115	;PI*1000.
	.FLT4	1E3
	.WORD	043765,067732,061351,144141	;PI*10000.
	.FLT4	1E4
	.WORD	044631,062750,076722,016475	;PI*100000.
	.FLT4	1E5
	.WORD	045477,137542,116506,122214	;PI*1000000.
	.FLT4	1E6
	.ENDC
	.ENDC
	.ENDC

	.SBTTL	ROUTINES FOR OTHERS
; ROUTINES AND TABLES FOR LA

	.IF	EQ	.MATH.
BNT4:	.IF	DF	DECMAP
	MOV	R0,-(SP)	;SAVE R0
	MOV	SCAFAC,R0	;GET SCALING POINTER
	BEQ	10$		;NO SCALING
	.IF	DF	FPU
	SETD
	LDD	(R1),F0		;SCALING, GET FLOATER
	DIVD	(R0),F0		;DIVIDE FOR NORMAL NUMBER
	STD	F0,-(R1)	;STORE ANSWER
	.IFF
	MOV	#5$,-(SP)	;SET A RETURN ADDRESS
	JSR	R4,SAVEM	;SAVE R0,R2,R3,R4
	JSR	PC,DUPLF	;DUPLICATE FLOATER
	JSR	PC,DIVFR0	;PUSH DIVISOR AND DIVIDE
	JMP	RESTEM		;RESTORE R0,R2,R3,R4 AND RETURN
	.ENDC
5$:	MOV	(R1)+,R0	;SAVE HIGH ORDER OF ANSWER
	CMP	(R1)+,(R1)+	;COLLAPSE MIDDLE PART
	MOV	R0,(R1)		;NOW CLOBBER LSB WITH MSB
	BR	20$
10$:	MOV	(R1),-(R1)	;COPY MSB ONTO R1 STACK
20$:	MOV	(SP)+,R0	;RESTORE R0
	.IFF
	MOV	(R1),-(R1)	;DUPLICATE THE EXP
	.ENDC
	ASL	(R1)		;DUMP SIGN BIT
	CMP	(R1)+,#110000	;CHECK FOR VALID INTEGER RANGE
	BLO	BNT5		;O.K.
	MOV	#FLOTIM,(SP)	;NO, CHANGE TO FLOATER
BNT5:	RTS	PC		;EXIT
	.ENDC

FLTSTF:	.WORD	FLTLEN,1.,3.	;LENGTHS (FLT,INT,STR)
	.WORD	FLTLEN*11.,1.*11.,3.*11.
	.WORD	FLTLEN*121.,1.*121.,3.*121.

TOKZIP:	JSR	PC,MAPTOK	;DECODE TOKEN
	ASL	R2		;R2_2*TOKEN CODE
	ADD	R2,PC		;DISPATCH THRU ZROUT MODIFIED BY TOKEN CODE

	BR	ZINTG		;INTEGER ZERO
	BR	ZFLT		;FLOATING ZERO
	BR	ZSTR		;STRING ZERO
	BR	ZARRAY		;ARRAY ZERO
	BR	FZINTG		;INTG-VALUED FUNCTION
	BR	FZFLT		;FLTG-VALUED FUNCTION
	CLR	10(R3)		;STRING-VALUED FUNCTION - CLEAR COUNT
	RTS	PC

FZFLT:	CMP	(R3)+,(R3)+	;CLR FLOATING FUNCTION
ZFLT:	CLR	(R3)+		;CLR FLOATING NUMBER
	FLTCLR	(R3)+		;CLEAR MORE IF NEEDED
ZINTG:	CLR	(R3)		;CLR INTEGER
	RTS	PC

ZSTR:				;CLEAR COUNT IN STRING
FZINTG:	CLR	4(R3)		;CLEAR INTEGER FNCN
	RTS	PC

;THIS ROUTINE WORKS ON ARRAY HEADERS (NOT IOB'S)
;THUS THE BICB BELOW IS PROBABLY NONSENSE
ZARRAY:	MOV	R3,R2		;COPY HEADER ADDRESS
	BICB	#WRTARY,ARYFLG(R3)	;CLEAR RE-WRITE BIT
	SUB	R0,R2		;MAKE RELATIVE
	CLR	R0		;MAKE NEW LENGTH 0
	MOV	R4,-(SP)	;SAVE TOM'S POINTER
	MOV	R3,-(SP)	;SAVE R3 FOR LATER
	JSR	PC,THENT	;NEVER MOVES ON A COLAPSE
	MOV	(SP)+,R3	;RESTORE HEADER POINTER
	MOV	(SP)+,R4	;AND RESTORE THE LA POINTER
ZARRY4:	MOV	R3,R0		;R0 <- ABS HEADER ADDRESS
	MOVB	ARYFLG(R3),R2	;GET FLAG BYTE
	BITB	R2,#DIMARY	;ALREADY DIMED ARRAY?
	BNE	ZARRY3		;YEP
	BIC	#-3-1,R2	;GET 0 TO 2 INDEX
	ASL	R2		;NOW WORD INDEX
	ADD	#FLTSTF,R2	;MAKE POINTER
ZARRY1:	ADD	#PDIM2+2,R3	;GO TO END OF HEADER
	MOV	(R2),-(SP)	;SAVE ITEM LENGTH ON STACK
	IFZERO	EQ,-(R3),ZARRY2	;BR IF PDIM=0
	ADD	#6,R2		;OTHWS, GO A LITTLE FURTHER IN INFO
	MOV	#10.,(R3)	;& SET PDIM2=10
ZARRY2:	MOV	#10.,-(R3)	;PDIM1=10 ALWAYS IN UNDIMMED CASE
	MOV	(SP)+,-(R3)	;STORE ITEM LENGTH IN MAXSTR
	CLR	-(R3)		;CLEAR OFFSET
	CLR	-(R3)		;2 WORDS WORTH
	CLR	-(R3)		;& HIGH ORDER LIMIT
	MOV	6(R2),-(R3)	;SET LOW ORDER LIMIT
ZARRY3:	MOV	PDIM2(R0),DIM2(R0)  ;SET DIM2 FROM BACKUP
	MOV	PDIM1(R0),DIM1(R0)  ;DITTO DIM1
	MOV	R0,R3		;SAVE ABSOLUTE POINTER AS PUBLIC SERVICE
SPDAR0:	MOV	SPDA,R0		;RESTORE R0 AND EXIT
	RTS	PC		;UTILITY TAIL

INCTAB:	.BYTE	2		;INTEGERS
	.BYTE	2*FLTLEN	;FLOATERS
	.BYTE	6		;STRINGS
	.BYTE	ARYLEN		;ARRAY HEADERS
	.BYTE	2+4		;INTEGER FUNCTIONS
	.BYTE	2*FLTLEN+4	;FLOATING FUNCTIONS
	.BYTE	6+4		;STRING FUNCTIONS
	.EVEN

	.IF	EQ	.MATH.
$POLSH:	TST	(SP)+		;DELETE JUNK FROM STACK
$PLSHE:	JMP	@(R4)+

DUP4:				;SAME AS 'DUP2' BUT FOR 4-WORD
DUP2:	MOV	#$PLSHE,-(SP)	;SET RETURN FOR POLISH
	.IF	EQ	FLTLEN-2
PRINU2:
	.ENDC
	.ENDC
DUPLF:	MOVFLT	FLTLEN-1*2(R1),-(R1)	;DUPLICATE FLOATING
	RTS	PC		;ON R1 STACK

PUSHF:	GWTXT	R0		;GET THE POINTER
PUSHF3:	ADD	SPDA,R0		;MAKE IT ABSOLUTE
PUSHF2:
.IF	EQ	FLTLEN-2
	MOV	2(R0),-(R1)	;PUSH ONE WORD
	MOV	(R0),-(R1)	; THEN ANOTHER
.IFF
	ADD	#FLTLEN*2,R0	;POINT TO THE END OF THE FLOATER
	MOV	-(R0),-(R1)	;PUSH
	MOV	-(R0),-(R1)	; ALL
	MOV	-(R0),-(R1)	;  FOUR
	MOV	-(R0),-(R1)	;   WORDS
PRINU2:
.ENDC	;EQ	FLTLEN-2
	RTS	PC

; PUSH INTEGER AND FLOATING CONSTANT

PUSHXF:	FLTCLR	-(R1)		;CLEAR EXTRA WORDS IF ANY
	CLR	-(R1)		;CLEAR ANOTHER
PUSHC:	MOVB	(R5)+,-(R1)	;SET THE IMMEDIATE
	MOVB	(R5)+,-(R1)	; CONSTANT VALUE
	RTS	PC

; POP A STRING

POPS:	GWTXT	R0		;GET ADDRESS
	MOV	SPDA,R2		;AND GET SPDA
	ADD	R2,R0		;MAKE R0 ABSOLUTE
POPS1:	TST	(R0)+		;SKIP THE LINK
	ADD	R1,(R1)		;GET ABS LINK
	SUB	R2,(R1)		;MAKE RELATIVE
	MOV	(R1)+,(R2)	;AND LINK IT
	ADD	R1,(R1)		;
	SUB	R0,(R1)		;
	BR	POPS2		;MOVE POINTER AND LINK

FREPLF:	MOV	(R1),-(R1)	;COPY INTEGER ON STACK
FPOPF:	JSR	PC,FLT		;FLOAT AN INTEGER
POPF:	GWTXT	R0		;GET ADDRESS
	ADD	SPDA,R0		;MAKE ABSOLUTE
POPF1:	.REPT	FLTLEN-2
	MOV	(R1)+,(R0)+	;AND MOVE IT
	.ENDR
POPS2:	MOV	(R1)+,(R0)+	;MOVE ONE MORE
	BR	POPI1		;AND GO MOVE ANOTHER

IREPLI:	JSR	PC,DUPLF	;DUPLICATE FLOATING
IPOPI:	JSR	PC,FIX		;FIX THE FLOATING
POPI:	GWTXT	R0		;GET ADDRESS
	ADD	SPDA,R0		;MAKE ABS.
POPI1:	MOV	(R1)+,(R0)+	;AND MOVE IT
	RTS	PC

REPLF:	GWTXT	R0
	ADD	SPDA,R0
	MOVFLT	(R1)+,(R0)+
	SUB	#FLTLE2,R1
	RTS	PC

.IF	EQ	FLTLEN-4
FPUSHC:	FLTCLR	-(R1)		;PUSH A FLOATING POINT CONSTANT
	CLR	-(R1)		; OF FOUR WORDS
	MOV	(R0)+,-(R1)	;EXPONENT AND MANTISSA PASSED IN 1 WORD
	RTS	R0
.ENDC	;EQ	FLTLEN-4

INDL1:	CLR	-(R1)		;SET UP A SECOND SUBSCRIPT
INDL2:	JSR	PC,INDX90	;GO DO FUNNY THINGS COMMON TO INDX
	BISB	#WRTARY,(R4)	;SET DIDDLED BIT
	BITB	#FIXARY,(R0)	;SEE IF FLOATING
	BNE	INDX50		;BRANCH IF TRUE
	BITB	#STRARY,(R0)	;SEE IF STRING HEADER
	BNE	INDX60		;BRANCH IF STRING
	MOV	R1,R0		;COPY THE POINTER TO FLOATER ON STACK
	MOVFLT	(R0)+,(R3)+	;POP FLOATING
	RTS	PC		;AND RETURN

INDX50:	MOV	(R1),(R3)	;REPLICATE INTEGER
	RTS	PC		;AND RETURN

INDX60:	TSTB	(R0)		;SEE IF DSK AND STRING
	BMI	INDX42		;BRANCH IF THE WORST CASE
	MOV	R3,R0		;MOVE POINTER TO R0
	JMP	REPLS1		;AND GO TO REPLS

INDO1:	CLR	-(R1)		;MAKE A PHONY #2 SUBSCRIPT
INDO2:	JSR	PC,INDX90	;CALCULATE INDEX INTO ARRAY
INDO3:	BITB	#FIXARY,(R0)	;SEE IF FIXED-FLOAT-STRING
	BNE	INDX10		;BRANCH IF PUSH FLOATING
	BITB	#STRARY,(R0)	;SEE IF FIXED-STRING
	BNE	INDX20		;BRANCH IF PUSH STRING
	.NLIST
	  AFLTLN=2*FLTLEN-2	;DISTANCE TO 1ST FLOATER
	  .REPT	FLTLEN-1
	.LIST
	MOV	AFLTLN(R3),-(R1)  ;WORD OF FLOATER ONTO R1 STACK
	.NLIST
	  AFLTLN=AFLTLN-2
	  .ENDR
	.LIST
INDX10:	MOV	(R3),-(R1)
	RTS	PC		;AND RETURN

INDX20:	TSTB	(R0)		;SEE IF DISK BASED
	BMI	INDX21		;BRANCH IF FUNNY STRING ON DISK
	MOV	R3,R0		;COPY STRING HEADER ADDRESS
	MOV	SPDA,R2		;SET UP FOR ENTRY TO PUSHS
	JMP	PUSHS1		;AND ENTER IN THE MIDDLE

INDX40:	TSTB	(R0)		;SEE IF STRING IS ON DISK STORAGE
	BMI	INDX41		;BRANCH TO PICK UP THE MESSY ONE(DSK&STRING)
	MOV	R3,R0		;COPY HEADER ADDR TO R0
	MOV	SPDA,R2		;SET UP PDA POINTER
	BR	POPS1		;AND JOIN FORCES WITH POPS


INDX21:	MOV	MAXSTR-ARYFLG(R0),R4	;SET UP MAX LENGTH
	ASL	R4		;MAKE BYTE COUNT
	SUB	R2,R3		;MAKE ADDRESS OF STRING RELATIVE
	MOV	R3,-(R1)	;SAVE ON R1 STACK
	MOV	R4,R3		;SET UP MAXIMUM LENGTH NEEDED
	JSR	PC,BUILDS	;SET UP TO BUILD A STRING
	MOV	(R1)+,R2	;GET RELATIVE STRING ADDRESS BACK
	ADD	R0,R2		;MAKE ABSOLUTE AGAIN
	MOV	R3,-(SP)	;SAVE STARTING POINT OF NEW STRING
10$:	MOVB	(R2)+,(R3)+	;MOVE A CHARACTER
	SOB	R4,10$		;LOOP IF STILL MORE
20$:	TSTB	-(R3)		;SEE IF UNNEEDED NULL
	BNE	30$		;DONE IF NON-NULL
	CMP	R3,(SP)		;ELSE BELOW STARTING POINT?
	BHIS	20$		;NO, LOOP
30$:	CMPB	(SP)+,(R3)+	;ELSE COUNT IT (& POP START)
	JSR	PC,@(SP)+	;AND RETURN TO BUILDS
	MOV	(SP)+,R5	;RESTORE IPC
	MOV	(R2),(R1)	;SET LINK TO FIRST STRING
	JMP	PUSHS2		;AND INSERT STRING IN LIST

INDR1:	CLR	-(R1)		;MAKE SECOND ENTRY + USE INDR2
INDR2:	JSR	PC,INDX90	;CALC ALL KINDS OF STUFF
INDR3:	BISB	#WRTARY,(R4)	;MAKE SURE TO WRITE IT BACK OUT
	BITB	#FIXARY,(R0)	;SEE IF FLOATING
	BNE	INDX30		;BRANCH IF SO
	BITB	#STRARY,(R0)	;SEE IF A STRING
	BNE	INDX40		;BRANCH IF SO
	  .NLIST
	  .REPT	FLTLEN-1
	  .LIST
	MOV	(R1)+,(R3)+	;STORE FLOATING POINT
	  .NLIST
	  .ENDR
	  .LIST
INDX30:	MOV	(R1)+,(R3)+
	RTS	PC		;AND RETURN

INDX41:	MOV	#PSTJS,-(SP)	;WHEN DONE POP A STRING
INDX42:	MOV	MAXSTR-ARYFLG(R0),R4	;GET MAXIMUM LENGTH
	ASL	R4		;AND MAKE BYTE COUNT (NOTE NON-0!)
	MOV	LENGTH(R1),R2	;GET LENGTH OF THE STRING
	BEQ	INDX45		;DON'T COPY ANYTHING FOR NULL STRING
	CMP	R2,R4		;SEE HOW COMPARED WITH MAX ALLOWED
	BLE	INDX43		;BRANCH IF OK
	MOV	R4,R2		;ELSE TRUNCATE TO MAX LENGTH
INDX43:	MOV	R1,R0		;COPY STACK SO AS TO NOT DESTROY POINTER
	ADD	PNTR(R1),R0	;GET A POINTER TO THE STRING PROPER
INDX44:	MOVB	(R0)+,(R3)+	;STORE A CHARACTER
	DEC	R4		;DECREMENT FOR NULL INSERTION
	SOB	R2,INDX44	;LOOP IF MORE TO DO
	BLE	INDX46		;NO CLEARING IF COUNT IS NOT POSITIVE
INDX45:	CLRB	(R3)+		;CLEAR THE REST OF THE VC STRING
	SOB	R4,INDX45	;FOR THE REMAINING COUNT
INDX46:	RTS	PC

.ENABL	LSB

IINR1:	CLR	-(R1)		;MAKE SECOND SUBSCRIPT 0
IINR2:	MOV	(R1)+,-(SP)	;SAVE #2
	MOV	(R1)+,-(SP)	;SAVE #1
10$:	JSR	PC,FIX		;MAKE VALUE AN INTEGER
20$:	MOV	(SP)+,-(R1)	;RESTORE #1
	MOV	(SP)+,-(R1)	;RESTORE #2
	BR	INDR2		;MAKE LIKE A WELL KNOWN OTHER OP

IINL1:	CLR	-(R1)		;MAKE SECOND SUBSCRIPT 0
IINL2:	MOV	(R1)+,-(SP)	;SAVE THE SECOND SUBSCRIPT
	MOV	(R1)+,-(SP)	;AND #1 TOO
	JSR	PC,DUPLF	;DUPLICATE FLOATING
	BR	10$		;AND GO TO ABOVE

FINR1:	CLR	-(R1)		;SAME GAME #2=0
FINR2:	MOV	(R1)+,-(SP)	;SAVE #2
	MOV	(R1)+,-(SP)	;SAVE #1
30$:	JSR	PC,FLT		;MAKE INTO FLOATING
	BR	20$		;RESTORE AND CONTINUE

FINL1:	CLR	-(R1)		;WE KNOW WHAT HE WANTS
FINL2:	MOV	(R1)+,-(SP)	;SAVE #2
	MOV	(R1)+,-(SP)	;SAVE #1
	MOV	(R1),-(R1)	;DUPLICATE IT
	BR	30$		;AND RESUME ABOVE

.DSABL	LSB

.ENABL	LSB

INDX90:	GWTXT	R0		;GET THE DOPE VECTOR ADDRESS
INDEGH:	MOV	R0,R2		;COPY POINTER FOR POSSIBLE ALLOCATION
	ADD	SPDA,R0		; AND MAKE ABSOLUTE
	TST	LENGTH(R0)	;SEE IF ANY CORE ARRAY
	BNE	90$		;BRANCH IF CORE ARRAY ALREADY ALLOCATED
	TSTB	ARYFLG(R0)	;SEE IF DISK OR CORE
	BPL	30$		;IF CORE, GO ALLOCATE SPACE
	MOVB	ARYSLT(R0),R4	;GET THE DISK SLOT NUMBER
	ASH	#3,R4		; TIMES 8
	ADD	#BASE+IOLEN,R4	;  AND COMPUTE RELATIVE BUFFER ADDRESS
	ADD	SPDA,R4		;MAKE IT ABSOLUTE
	MOV	R4,R3		;COPY THE ABSOLUTE HEADER ADDRESS
	TST	(R4)+		; THEN INDEX TO "PNTR"
.ASSUME	PNTR	EQ	2
	ADD	(R4)+,R3	;GET ABS POINTER TO THE I/O BUFFER
	SUB	R0,R3		;MAKE I/O BUF PTR RELATIVE TO DOPE VECTOR
	MOV	R3,PNTR(R0)	;STORE IT IN THE ARRAY'S DOPE VECTOR
	MOV	(R4),-(SP)	;GET I/O BUFFER'S LENGTH
.ASSUME	LENGTH	EQ	PNTR+2
	BEQ	10$		;LENGTH IS 0, SO NOT OPEN
	CMP	(R4),#1000	;IS LENGTH AT LEAST 512. BYTES?
	BLO	20$		;NOPE, AN ERROR
	DEC	(SP)		;MAKE BYTE SIZE INTO .BIC. TYPE MASK
	BIT	(R4),(SP)	;IS BYTE LENGTH A POWER OF 2?
	BNE	20$		;NOPE, THAT'S AN ERROR ALSO
	ASR	(SP)		;NOW MAKE A WORD .BIC. MASK
	MOV	R4,-(SP)	;SAVE ABS HEADER ADDRESS @ LENGTH FOR LATER
	BR	90$		;GO DO SUBSCRIPT COMPUTATION

10$:	ERROR	VCOERR,FATAL	;VIRTUAL ARRAY NOT OPEN

20$:	ERROR	VCSERR,FATAL	;BUFFER SIZE NOT 512.

30$:	MOV	ARYLIM(R0),R0	;GET THE AMOUNT WE MUST ALLOCATE
	ASL	R0		;MAKE INTO BYTE LENGTH
	JSR	PC,THENT	;GO ALLOCATE ARRAY SPACE
	ADD	R4,R2		;COMPUTE ABS POINTER TO HEADER
	MOV	R2,-(SP)	;SAVE IT FOR A MINUTE
	ASR	R0		;COMPUTE BACK TO WORDS
	BEQ	50$		;SKIP IF NO ARRAY
	ADD	PNTR(R2),R2	;GO TO THE AREA PROPER
40$:	CLR	(R2)+		;ARRAYS ARE INITIALLY FILLED WITH 0'S
	SOB	R0,40$		;LOOP TIL DONE
50$:	MOV	(SP)+,R0	;RESTORE HEADER ADDRESS
	BITB	#DSKARY!STRARY,ARYFLG(R0) ;ARE STRING HEADERS NEEDED?
	BLE	90$		;NO IF VIRTUAL OR NOT STRING
	MOV	R0,R2		;YES, COPY THE HEADER ADDRESS
	MOV	LENGTH(R0),R3	;GET THE LENGTH
	ADD	PNTR(R0),R2	;POINT TO THE AREA
	MOV	R2,-(SP)	;SAVE START ADDRESS
60$:	MOV	#6,(R2)		;STORE A LINK
	SUB	(R2),R3		;DECREMENT THE LENGTH
	BLE	70$		;BRANCH IF DONE
	ADD	(R2),R2		;SKIP DOWN THE CHAIN????
	BR	60$		;AND LOOP FOR MORE

70$:	MOV	R4,R3		;COPY SPDA
	ADD	#DUMSTR,R3	;DUMSTR GETS IT A LOT HERE
	MOV	(R3),(R2)	;COPY OLD LINK
	BEQ	80$		;BRANCH IF END OF THE LINE
	ADD	R3,(R2)		;MAKE ABSOLUTE
	SUB	R2,(R2)		;NOW RELATIVE TO HERE
80$:	MOV	(SP)+,R2	;GET THE HEAD OF THE LIST
	MOV	R2,(R3)		;STORE IT AT DUMSTR
	SUB	R3,(R3)		;AND MAKE RELATIVE

90$:	JSR	PC,INDARY	;CHECK OUT THE INDICES
	CMP	R2,-(R0)	;SEE HOW THE HIGH ORDER PARTS ARE
	BLO	100$		;BRANCH IF OK
	BHI	170$		;BRANCH IF SUBSCRIPTING ERROR
	CMP	R3,-2(R0)	;SEE ABOUT THE LOW ORDERS
	BHIS	170$		;BRANCH IF AN ERROR
100$:	MOV	R0,R4		;COPY POINTER TO ARRAY HEADER
	TST	-(R0)		;POP OVER THE LOW ORDER
	TST	-(R0)		;TEST TYPE - CORE VS DSK
	BPL	160$		;BRANCH IF MERELY CORE
	MOV	(SP)+,R4	;RESTORE ABS POINTER TO I/O HEADER @ LENGTH
	MOV	R3,-(SP)	;SAVE LOW ORDER PART OF ADDRESS
	BIC	2(SP),R3	;FIND LOW ORDER W/O THE BUFFER WORD OFFSET
	BIC	R3,(SP)		; AND FIND THE BUFFER WORD OFFSET
	MOV	(SP)+,(SP)	;MOVE BUFFER WORD OFFSET ONTO THE .BIC. MASK
	ASHC	#-8.,R2		;MAKE R2,R3 INTO A BLOCK NUMBER
	ADD	#1,R3		;FIP GOES FROM 1 TO N NOW
	ADC	R2		; W/ A CARRY
	BVS	BIGSIZ		;TOO BIG
	BMI	BIGSIZ		;ALSO TOO BIG
	MOV	R3,-(SP)	;SAVE BLOCK LSB
	MOV	R4,R3		;COPY THE POINTER @ LENGTH
	TST	(R4)+		; AND ADVANCE TO BYTCNT IN HEADER
.ASSUME	BYTCNT	EQ	LENGTH+2
	MOV	(R3),(R4)+	;MOVE LENGTH TO BYTCNT FOR I/O
	MOV	-(R3),(R4)+	;MOVE POINTER TO CURLOC TO RESET IT
.ASSUME	PNTR	EQ	LENGTH-2
.ASSUME	CURLOC	EQ	BYTCNT+2
	TST	(R4)		;TEST THE FLAGS (HIGH BYTE)
.ASSUME	FLAGS	EQ	CURLOC+3
	BPL	180$		;ERROR IF NT A RANDOM ACCESS DEVICE
	BIT	#FORCE*400,(R4)+ ;IS IT A FORCE TYPE DEVICE?
	BNE	180$		;YES, THAT'S AN ERROR IN VIRTUAL CORE
	CMP	-(R3),(R4)+	;BACK UP TO IO HEADER, FORWARD TO CURBLK
.ASSUME	0	EQ	PNTR-2
.ASSUME	CURBLK	EQ	FLAGS+3
	TSTB	CURBKM-CURBLK(R4) ;ANY HIGH ORDER BLOCK NUMBER?
	BNE	99$		;YES
	TST	(R4)		;VIRGIN SINCE OPEN?
	BEQ	110$		;IF SO NO BLOCK IN BUFFER
99$:	CMPB	R2,CURBKM-CURBLK(R4) ;MSB MATCH?
	BNE	101$		;NO
	CMP	(SP),(R4)	;IS THE BLOCK REALLY IN CORE?
	BEQ	150$		;NO I/O IF SO
101$:	BITB	#WRTARY,FLAGS(R3) ;DO WE NEED TO WRITE?
	BEQ	110$		;NO, ARRAY BLOCK IS UNMODIFIED
	JSR	PC,WRITE.	;WRITE OLD BLOCK
	BNE	120$		;SOME KIND OF PROBLEM
110$:	MOV	(SP),(R4)	;SET NEW BLOCK LSB
	MOVB	R2,CURBKM-CURBLK(R4) ;SET UP NEW BLOCK MSB
	JSR	PC,READ.	;GET IT
	BEQ	140$		;NO ERROR
	CHKERR	EOF		;EOF IS OK
	BEQ	130$		;EOF'S AREN'T REAL ERRORS
	CLR	(R4)		;INDICATE ZILCH BUFFER
	CLRB	-(R4)		; IN BOTH PLACES
.ASSUME	CURBKM	EQ	CURBLK-1
120$:	IOTERR	!FATAL		;DIE!

130$:	MOV	(SP),(R4)	;MONITOR RETURNED ITS CURR, BUT WE WANT THIS ONE
	MOVB	R2,CURBKM-CURBLK(R4) ; IN BOTH PLACES
140$:	BICB	#WRTARY,FLAGS(R3) ;NOTE THAT DISK AND CORE AGREE NOW
150$:	CLR	BYTCNT(R3)	;SIGNAL THIS WAS RANDOM ACCESS
	TST	(SP)+		;POP THE BLOCK LSB
	MOV	(SP)+,R3	;GET WORD DISPLACEMENT IN BUFFER
160$:	ADD	#FLAGS-CURBLK,R4 ;ADJUST FOR POINTER TO FLAGS
	ASL	R3		;MAKE INTO BYTE ADDRESS
	BVS	170$		;IF OVERFLOW BETTER TELL HIM
	BMI	170$		;IF WRONG DIRECTION TOO
	ADD	R0,R3		;GO TO ABSOLUTE ADDRESS
	SUB	#ARYSLT,R3	;SUB TYPFIL BECAUSE R0 IS OFF BY TYPFIL
	ADD	PNTR-ARYSLT(R0),R3 ;AND MOVE TO THE BUFFER ITSELF.
	MOV	SPDA,R2		;AND A PUBLIC SERVICE GESTURE
	INC	R0		;POINT TO THE FLAG BYTE
	RTS	PC

ERRSUB:
170$:	ERROR	SUBERR,FATAL	;SUBSCRIPTING ERROR

180$:	ERROR	VCAERR,FATAL	;DISK ARRAY NOT ON DISK

.DSABL	LSB

.ENABL	LSB

INDARY:	MOV	(R1)+,-(SP)	;SAVE INDEX2
	BEQ	5$		;*C* DON'T CHECK IF NO 2ND SUBSCRIPT
	CMP	#100000,(SP)	;*C* 2ND SUBSCRIPT IS BIASED BY 1
	BMI	ERRSUB		;*A* CHECK NEGATIVE SUBSCRIPT
5$:
	MOV	(R1)+,R3	; SAVE INDEX1
	BMI	ERRSUB		;*A* CHECK NEGATIVE SUBSCRIPT
	MOV	DIM2(R0),R2	;GET DIM2
	BEQ	10$		;SAVE TIME IF ONE DIMENSIONAL
	INC	R2		;TO ALLOW INDICES TO START AT 0
	MUL	R3,R2		;R2,R3 <- INDEX1*(DIM2+1)
10$:	ADD	#MAXSTR,R0	;POINT AT ITEM WORD LENGTH
	ADD	R3,(SP)		;R2,(SP) = INDEX1*(DIM2+1)+INDEX2
	BIC	R3,R3		;CLEAR IN CASE WE DON'T MULTIPLY
	ADC	R2		;CARRY INTO HIGH ORDER ARRAY INDEX
	BEQ	20$		;NONE, R3,R2 = HIGH PART OF INDEX * ITEM SIZE
	JSR	PC,30$		;DO MULTIPLY BY ITEM WORD LENGTH
	;TST	R2		;IS THE OFFSET OVER 32 BITS?
	BNE	BIGSIZ		;YES, TOO MUCH DISK DEMANDED
20$:	MOV	(SP)+,R2	;RETRIEVE L.S. WORD
	MOV	R3,-(SP)	;SAVE HIGH INDEX * ITEM SIZE
	JSR	PC,30$		;DO MULTIPLY BY ITEM WORD LENGTH
	ADD	(SP)+,R2	;ADD IN REST OF M.S. WORD
	BCS	BIGSIZ		;BR IF EXORBITANT DISK DEMAND
	ADD	-(R0),R3	;ADD IN START WITHIN VIRTUAL CORE FILE
	ADC	R2		; FILE (ZERO IF THIS IS REAL CORE)
	BCS	BIGSIZ		;OOPS, OVERFLOW
	ADD	-(R0),R2	;FINISH HIGH ORDER (ALSO 0 IF REAL CORE)
	BCC	70$		;O.K., EXIT
BIGSIZ:	ERROR	SIZERR,FATAL	;ARRAY TOO BIG.

;ASSUMING (R0) CONTAINS A POWER OF 2
;OR 3!!!

30$:	MOV	(R0),-(SP)	;MULTIPLIER = ITEM WORD LENGTH
	MOV	R2,R3		;MOVE MULTIPLICAND TO LSB
	CLR	R2		; AND CLEAR AN MSB
40$:	ASR	(SP)		;DUMP A BIT
	BCS	50$		;DONE
	ASL	R3		;DOUBLE SHIFT WORDS LEFT
	ROL	R2		; ONE PLACE
	BR	40$		;  AND LOOP...

50$:	BEQ	60$		;IT WAS A POWER OF 2
	MOV	R3,(SP)		;ELSE SAVE VALUE TIMES 1
	ASL	R3		;NOW TIMES 2
	ROL	R2		;SAVE OVERFLOWS
	ADD	(SP),R3		;MAKE IT TIMES 3 NOW
	ADC	R2		;WATCH FOR OVERFLOWS...
60$:	MOV	R2,(SP)+	;DUMP STACK SETTING CC'S ON MSB (R2)
70$:	RTS	PC		; AND RETURN

.DSABL	LSB

.EV.F:	MOVFLT	(R1)+,-(SP)	;SAVE ONE FLOATER
	JSR	PC,NUM$00	;MAKE STRING VERSION OF 2ND
	MOVFLT	(SP)+,-(R1)	;GET BACK ORIGINAL FLOATER
	MOV	#.EQ.S,-(SP)	;SET FOR STRING COMPARE
	JMP	NUM$00		;MAKE STRING OF 1ST FLOATER

.ENABL	LSB

INTFAI::MOV	#FAI,R0		;ENTRY FOR FUNCTION TAKING 1 INTEGER
	BR	DEFFUN		;MERGE WITH COMMON CODE

INTFAS::MOV	#FAS,R0		;ENTRY FOR FUNCTION TAKING 1 STRING
	BR	DEFFUN		;MERGE WITH COMMON CODE

INTFAF::MOV	#FAF,R0		;ENTRY FOR FUNCTION TAKING 1 FLOATER
	BR	DEFFUN		;MERGE WITH COMMON CODE

INTFUN:	MOV	(R5)+,R0	;GET SPECIFIED FUNCTION PATTERN
DEFFUN:	MOV	(R1)+,R2	;GET THE INVOCATION PATTERN
	CMP	R2,R0		;DO A QUICK LOOK SEE
	BEQ	150$		;EXIT NOW IF ALL OK
	MOV	SPDA,R4		;GET A POINTER TO THE DATA AREA
	MOV	R5,-(SP)	;SAVE THE IPC, WE AREN'T MOVING
	CLR	R5		;ZERO THE ACTUAL PARAMETER COUNTER
10$:	CLR	R3		;CLEAR THE TYPE INDEX
	ROR	R2		;GET A BIT
	ROL	R3		;STORE IT IN THE REGISTER
	ROR	R2		;GET THE SECOND BIT
	ROL	R3		;THIS IS COMPLEMENT OBVERSE
	INC	R5		;COUNT 1 MORE ACTUAL PARAMETER
	ASL	R3		;DOUBLE THE ACTUAL PARAMETER TYPE
	ADD	R3,PC		;DISPATCH ON TYPE,000-END,010-FIXED,100-FLOATING,110-STRING
	 BR	50$		;NO MORE PARAMETERS PASSED, GO POP THEM
	 BR	20$		;BRANCH IF FIXED
	 BR	30$		;BRANCH IF FLOATING
	;BR	.+2		;BRANCH IF STRING

	ADD	R1,(R1)		;STRING PASSED.  MAKE LINK ABSOLUTE
	SUB	R4,(R1)		;MAKE IT RELATIVE TO SPDA
	MOV	(R1)+,(R4)	;MOVE IT OFF THE PLIST TEMPORARILY
	ADD	R1,(R1)		;MAKE POINTER ABSOLUTE ALSO-OFF BY TWO
	MOV	(R1)+,-(SP)	;STORE THE POINTER
	MOV	(R1)+,-(SP)	; AND THE LENGTH
	MOV	#4,-(SP)	;TYPE IT: 4=STRING
	BR	10$		;LOOP FOR MORE

20$:	MOV	(R1)+,-(SP)	;INTEGER PASSED. SAVE THE INTEGER
	CLR	-(SP)		;TYPE IT: 0=FIXED
	BR	10$		;GO GET MORE GOODIES

30$:	MOVFLT 	(R1)+,-(SP)	;FLOATER PASSED. SAVE FLOATER
	MOV	#2,-(SP)	;TYPE IT: 2=FLOATING
	BR	10$		;GET MORE

40$:	ASL	R0		;KEEP SHIFTING THOSE BITS
	ASL	R0		;OVER TWO BITS FOR THE POP OFF
	BEQ	110$		;BRANCH IF AN ERROR--TO GET HERE R3<>0
50$:	BIT	#140000,R0	;SHIFT UNTIL PATTERN IS IN HIGH BYTE
	BEQ	40$		;LOOP IF MORE TO DO
60$:	CLR	R3		;TYPE TO BE
	ROL	R0		;GET A BIT OF THE WANTED
	ROL	R3		;MOVE IT TO THE INDEX AREA
	ROL	R0		;GET A SECOND BIT
	ROL	R3		;MAKE COMPLEMENT OBVERSE INDEX
	ASL	R3		;MAKE AN INDEX WORD 
	DEC	R5		;COUNT DOWN NUMBER OF ARGUMENTS PASSED
	BLE	140$		;BRANCH IF NO MORE GIVEN
	ADD	R3,PC		;DISPATCH ON TYPE WANTED BY FUNCTION
	 BR	110$		;ERROR IF NO MORE WANTED
	 BR	100$		;BRANCH IF FLOAT WANTED
	 BR	70$		;BRANCH IF FIXED WANTED
	;BR	.+2		;BRANCH IF STRING WANTED

	ADD	(SP)+,PC	;STRING WANTED. DISPATCH ON ACTUAL STACK TYPE
	 BR	110$		;CAN'T CONVERT STRING TO INTEGER
	 BR	110$		;CAN'T CONVERT STRING TO FLOATER
	;BR	.+2		;EASY TO CONVERT STRING TO STRING

	MOV	(SP)+,-(R1)	;STRING TO STRING. STACK THE LENGTH
	MOV	(SP)+,-(R1)	;MOVE THE POINTER
	SUB	R1,(R1)		;REMEMBER HOW SLOPPY WE WERE STORING IT?
	MOV	(R4),-(R1)	;SET FORMER FIRST STRING
	ADD	R4,(R1)		;MAKE ABSOLUTE
	SUB	R1,(R1)		;MAKE A LINK FROM HERE
	MOV	R1,(R4)		;SET UP NEW FIRST POINTER
	SUB	R4,(R4)		;MAKE RELATIVE OT SPDA
	BR	60$		;GO FINISH THE JOB

70$:	ADD	(SP)+,PC	;INTEGER WANTED. DISPATCH ON ACTUAL TYPE
	 BR	80$		;EASY TO CONVERT INTEGER TO INTEGER
	 BR	90$		;GO CONVERT FLOATER TO INTEGER
	 BR	110$		;CAN'T CONVERT STRING TO INTEGER

80$:	MOV	(SP)+,-(R1)	;INTEGER TO INTEGER BY REPLACING IT
	BR	60$		;LOOP FOR MORE

90$:	MOVFLT	(SP)+,-(R1)	;FLOAT TO INTEGER. REPLACE FLOATER ON STACK
	JSR	PC,FIX		;FIX IT, LEAVING INTEGER ON STACK
	BR	60$		;LOOP AGAIN

100$:	ADD	(SP)+,PC	;FLOATER WANTED. DISPATCH ON ACTUAL TYPE
	 BR	130$		;GO CONVERT INTEGER TO FLOATER
	 BR	120$		;EASY TO CONVERT FLOATER TO FLOATER
	;BR	110$		;CAN'T CONVERT STRING TO FLOATER

110$:	 ERROR	FUNERR,FATAL	;FUNCTION ERROR

120$:	MOVFLT	(SP)+,-(R1)	;FLOATER TO FLOATER BY REPLACING ON STACK
	BR	60$		;LOOP FOR MORE

130$:	MOV	(SP)+,-(R1)	;INTEGER TO FLOATER. REPLACE THE INTEGER
	JSR	PC,FLT		;FLOAT IT AWAY
	BR	60$		;LOOP TO FINISH MAYBE

140$:	MOV	(SP)+,R5	;NO MORE ACTUAL ARGUMENTS. RESTORE IPC
	TST	R3		;DO WE EXPECT MORE ARGUMENTS?
	BNE	110$		;YES, THAT'S AN ERROR
150$:	RTS	R5		;BACK WE GO

.DSABL	LSB

MULI:	MOV	(R1)+,R3	;GET FIRST NUMBER
	MUL	(R1),R3		;MULTIPLY BY SECOND NUMBER
	MOV	R3,(R1)		;STORE THE RESULT ONTO THE STACK
	RTS	PC		;AND RETURN

DIVI:	MOV	(R1)+,R4	;PICK UP THE DIVISOR
	MOV	(R1)+,R3	;PICK UP THE DIVIDEND
	SXT	R2		;EXTEND THE SIGN
	DIV	R4,R2		;PERFORM THE DIVIDE
	MOV	R2,-(R1)	;MOVE THE QUOTIENT TO THE STACK
	MOV	R3,R2		;MOVE THE REMAINDER TO R2
	BCC	10$		;BRANCH IF NO DIVISION BY ZERO ERROR
	POST,	PSTDV0		;SHOW DIVISION BY 0
10$:	RTS	PC

;THE SGN FUNCTION
SGNF:	JSR	R5,INTFAF	;DEMAND ONE FLOATING ARG
	.IF	EQ	.MATH.
	IFZERO	EQ,(R1),RTSLC1	;BRANCH OUT IF ZERO
	MOV	R1,R0		;COPY R1 POINTER INTO R0
	BIC	#77777,(R0)	;SAVE THE SIGN
	.IF	NDF	DECMAP
	BIS	#40200,(R0)+	;AND SUPERIMPOSE 1ST WORD OF ONE
	CLR	(R0)+		;MAKE IT A FLOATING ONE
	.IFF
	MOV	SCAFAC,R2	;GET POINTER TO A "ONE"
	BNE	1$		;NON-ZERO
	MOV	#SCATAB+<4*2>,R2;GET A REAL ONE
1$:	BIS	(R2)+,(R0)+	;SUPERIMPOSE 1ST WORD ON SIGN
	MOV	(R2)+,(R0)+	;AND COPY NEXT WORD
	.ENDC
	FLTCLR	(R0)+
	.ENDC
	.IF	NE	.MATH.
	JSR	PC,FLTEST	;CHECK FOR 0
	BEQ	PUSHF0		;IF 0, THEN KEEP IT 0
PUSDF1:	MOV	#041100,-(R1)	;SET UP A 1.000000
	MOV	#000017,-(R1)
	CLR	-(R1)
	MOV	-(R1),-(SP)	;SAVE OLD SIGN
	CLR	(R1)		;FINAL CLEAR FOR 1.000000
SGNEXT:	TST	(SP)+		;NEGATE IT?
	BMI	NEGF		;YES
	.ENDC
RTSLC1:	RTS	PC
	.IF	EQ	.MATH.
RTSLOC:	.WORD	RTSLC1		;FOR DUMMYING POLISH RETURNS

;REPLACE CURRENT FLOATER WITH ZERO
SINF1:	FLTPP	(R1)+		;UP THE R1 STACK & FALL THRU
	.ENDC

;PUSH A FLOATING ZERO
PUSHF0:	FLTCLR	-(R1)		;SOME CLEARS
	CLR	-(R1)
PUSHI0:	CLR	-(R1)		;PUSH INTEGER ZERO
	RTS	PC

;PUSH A FLOATING ONE
PUSHF1:	.IF	EQ	.MATH.
	FLTCLR	-(R1)		;SOME CLEARS
	.IF	NDF	DECMAP
	CLR	-(R1)
	MOV	#40200,-(R1)	;THE LEADING WORD
	RTS	PC
	.IFF
	MOV	SCAFAC,R0	;GET FLOATING ONE POINTER
	BNE	1$		;NON-ZERO
	MOV	#SCATAB+<4*2>,R0;GET A REAL ONE
1$:	MOV	2(R0),-(R1)	;SET 2ND WORD
	MOV	(R0),-(R1)	;SET TOP WORD
	RTS	PC
	.ENDC
	.ENDC
	.IF	NE	.MATH.
	CLR	MFLTL2(R1)	;INSURE A +1.000000
	BR	PUSDF1		;AND DO IT
	.ENDC

;EXITS INTERNAL PUSHPOP MODE
EXITPP:	MOV	(SP)+,R5	;GET READY TO
	RTS	R5		;RESTORE AND EXIT TO INTERPRETER

	.IF	NE	.MATH.
FLTEST:	MOV	(R1)+,-(SP)	;SAVE 1ST WORD
	ASL	(SP)		;PUT SIGN IN CARRY AND SAVE REST OF IT
	BIS	(R1)+,(SP)	;NOW CHECK ALL OF IT
	BIS	(R1)+,(SP)
	BIS	(R1)+,(SP)+	;FINAL CHECK
	BNE	FLTES0		;NON-0
	BCC	FLTES0		;0 AND O.K.
	POST,	PSTFLT		;THAT SPECIAL WIERDO IS HERE AGAIN
	CLR	MFLTL2(R1)	;MAKE IT A 0
FLTES0:	RTS	PC		;EXIT
	.ENDC

	.IF	NE	.MATH.
ABSFSV:	MOV	(SP),-(SP)	;RESAVE RETURN ADDRESS
	MOV	(R1),2(SP)	;SAVE SIGN OF NUMBER
	BR	ABSF00		;NOW TAKE ABS VALUE OF IT
	.ENDC
;THE ABSOLUTE FUNCTION
ABSF:	JSR	R5,INTFAF	;DEMAND ONE FLOATING ARGUMENT
ABSF00:	.IF	EQ	.MATH.
	BIC	#100000,(R1)	;THAT'S ALL THERE IS TO IT
	.ENDC
	.IF	NE	.MATH.
	TST	(R1)		;NEED SIGN REVERSING
	BMI	NEGF		;YES
	.ENDC
	RTS	PC

;THE REVERSE SUBTRACT
RSUBF:	JSR	PC,SUBF		;SUBTRACT & FALL THRU TO COMPLEMENT

;THE NEGATE
NEGF:	.IF	EQ	.MATH.
	IFZERO	EQ,(R1),NEGF01	;NEGATE 0 AS 0
	ADD	#100000,(R1)	;JUST COMPLEMENT THE SIGN
	.ENDC
	.IF	NE	.MATH.
	JSR	PC,FLTEST	;CHECK FOR 0
	BEQ	PUSHF0		;KEEP 0 A 0
	NEG	-(R1)		;NEGATE IT
	ADC	-(R1)
	BCS	1$
	NEG	(R1)
1$:	ADC	-(R1)
	BCS	2$
	NEG	(R1)
2$:	ADC	-(R1)
	BCS	NEGF01
	NEG	(R1)
	.ENDC
NEGF01:	RTS	PC

;THE BASIC INT FUNCTION
INTF:	.IF	DF	DECMAP
	JSR	PC,DSCTST	;GET 'FAF' ARG AND CHECK FOR SCALING
	.IFF
	JSR	R5,INTFUN	;DEMAND A FLOATING ARG
	ARGS	FAF
	.ENDC
	IFSIGN	(R1),PL,FIXF11	;OUT FAST FOR NONNEGATIVE NUMBERS
	MOV	R1,R0		;SAVE R1 POINTER
	MOVFLT	(R0)+,-(SP)	;MAKE A COMPARISON COPY OF ARG
	JSR	PC,FIXF1	;FIX THE NUMBER
	MOVFLT	(SP)+,-(R1)	;GET THE COMPARISON COPY
	JSR	PC,CMPF		;COMPARE THEM
	BEQ	RTSLC1		;EXIT IF THEY WERE EQUAL
	FPUSHC	1.		;PUSH A FLOATING 1.0 ON R1 STACK
	JMP	SUBF		;THEN SUBTRACT AND EXIT

FIXF11:	JMP	FIXF1		;JUMP TO THE FIX ROUTINE


FLT1:	MOVFLT	(R1)+,-(SP)	;SAVE TOP FLOATER
	JSR	PC,FLT		;FLOAT THE INTEGER BELOW
	MOVFLT	(SP)+,-(R1)	;RESTORE TOP FLOATER
	RTS	PC

	.IF	EQ	.MATH.
;RAISES 2ND NUMBER ON R1 STACK TO 1ST NUMBER POWER - 2ND NUMBER
;MUST BE NONNEGATIVE UNLESS EXPONENT IS AN INTEGER <= 31
PWRF:	.IF	DF	DECMAP
	MOV	SCAFAC,R0	;GET SCALING POINTER
	BEQ	10$		;NONE
	.IF	DF	FPU
	SETD
	LDD	(R1)+,F0	;GET EXPONENT
	LDD	(R1),F1		;GET NUMBER TO RAISE
	DIVD	(R0),F1		;CORRECT NUMBER TO RAISE
	STD	F1,(R1)		;AND PUT IT BACK ON STACK
	DIVD	(R0),F0		;CORRECT EXPONENT
	STD	F0,-(R1)	;AND PUT IT BACK ON STACK
	.IFF
	MOVFLT	(R1)+,-(SP)	;SAVE EXPONENT
	JSR	PC,DIVFR0	;CORRECT THE NUMBER TO RAISE
	MOVFLT	(SP)+,-(R1)	;RESTORE EXPONENT
	JSR	PC,DIVFSC	;CORRECT EXPONENT
	.ENDC
	MOV	#DSCDNE,-(SP)	;REMEMBER TO RE-SCALE ON EXIT
10$:
	.ENDC
	MOV	R1,R0		;R0 POINTS AT EXPONENT
	MOVFLT	(R0)+,-(SP)	;SAVE EXPONENT
	MOV	(R1),R2		;M.S. WORD OF EXPONENT
	ROL	R2		;GET RID OF SIGN
	IF  R2,HI,#103000,PWR5	;DO IT CRUMMY IF EXPONENT >= 32
	JSR	PC,DUPLF	;COPY EXPONENT
	.IF	NDF	DECMAP
	JSR	PC,FIX		;INTEGER PART OF EXPONENT
	MOV	(R1),-(SP)	;ONTO SP STACK
	JSR	PC,FLT		;REFLOAT INTEGER PART
	.IFF
	JSR	R4,$RI		;GET INTEGER OF EXPONENT
	.WORD	20$,$IR,30$
20$:	MOV	(R1),(SP)	;SAVE EXPONENT AS INTEGER
	JMP	@(R4)+
30$:
	.ENDC
	JSR	PC,SUBF		;TO FIND FRACTIONAL PART
	.REPT	FLTLEN-2
	MOV	(R1)+,(R1)	;MOVE THE TOP WORD UP A LITTLE
	.ENDR
	MOV	(R1)+,(R1)+	;TEST TOP WORD & POP TWO WORDS
	BNE	PWR4		;BR IF NOT PURE INTEGER EXPONENET
	IFSIGN	(SP),PL,PWR0	;BR IF EXPONENT NONNEGATIVE
	MOV	R1,R2		;SAVE STACK POINTER
	JSR	PC,DUPLF	;MOVE NUM TO EXPONENTIATE OUT ON STACK
	MOV	#40200,(R2)+	;AND A FLOATING ONE WHERE IT WAS
	CLR	(R2)+
	FLTCLR	(R2)+
	JSR	PC,DIVF		;RECIPROCAL OF NUMBER TO EXPONENTIATE
	NEG	(SP)		;AND NEGATE THE EXPONENT
PWR0:	ASR	(SP)		;SET CARRY IF EXPONENT ODD
	MOV	R1,R0		;SAVE THE STACK POINTER
	MOVFLT	(R0)+,-(SP)	;SAVE THE NUMBER
	BCS	PWR1		;IF EXPON ODD, LEAVE NUMBER ON STACK
	FLTCLR	-(R0)		;PUSH A FLOATING 1.0 IN ITS PLACE
	CLR	-(R0)
	MOV	#^F1.,-(R0)
PWR1:	IFZERO	EQ,2*FLTLEN(SP),PWR3  ;BR IF DONE

PWR2:	MOVFLT	(SP)+,-(R1)	;OTHWS, PUSH SOME POWER OF NUMBER
	JSR	PC,DUPLF	;DUPLICATE IT
	JSR	PC,MULF		;SQUARE IT
	ASR	(SP)		;SET CARRY IF SQUARE TO BE MULTIPLIED IN
	MOVFLT	(R1)+,-(SP)	;SAVE SQUARE
	BCC	PWR2		;BR IF SQUARE NOT MULTIPLIED IN
	FLTPP	-(R1)		;OTHWS, RECOVER SQUARE
	JSR	PC,MULF		;AND MULTIPLY IT IN
	BR	PWR1
PWR3:	ADD	#4*FLTLEN+2.,SP	;CLEAN THE STACK
	RTS	PC		;JUST EXIT

;WHEN WE GET HERE, THE NUMBER TO EXPONENTIATE HAD BETTER BE NONNEGATIVE

PWR4:	TST	(SP)+		;GET RID OF INTEGER PART OF EXPONENT
	BR	PWR8		;SKIP THE R1 POINTER SETUP
PWR5:	MOV	R0,R1		;R1 POINTS TO NUMBER TO EXPONENTIATE
PWR8:	IFZERO	NE,(R1),PWR6	;BR IF NUMBER TO EXPONENTIATE NONZERO
	IFSIGN	2*FLTLEN-2(SP),PL,PWR7  ;BR IF EXPONENT NONNEG
	ERROR	LOGERR		;IF EXP NEGATIVE, ANSWER IS INFINITY
PWR7:	FLTPP	(SP)+		;OTHWS, CLEAN STACK & RETURN 0
	RTS	PC		;EXIT

PWR6:	JMP	XF		;DO IT THE LONG WAY...

	DEFORG	XF

XF:	ERROR	ERRERR		;NO EXTENDED FUNCTIONS
	JMP	PWR7		;SO SAY ERROR AND EXIT

	ORG	MA
	.ENDC

	.IF	NE	.MATH.
PWRF:	JSR	PC,DUPLF	;DUPLICATE EXPONEXT ON STACK
	JSR	PC,FIX		;NOW FIX THE EXPONENT
	MOV	(R1),-(SP)	;SAVE VALUE OF FIXED EXPONENT
	JSR	PC,FLT		;NOW RE-FLOAT IT
	JSR	PC,SUBF		;AND SUBTRACT (FLT(FIX(EXP))) FROM (EXP)
	JSR	PC,FLTEST	;CHECK FOR TRUE ZERO
	BEQ	1$		;IT IS TRUE 0
	TST	(SP)+		;DUMP SAVED EXPONENT
	ADD	#FLTLE2,R1	;AND POP NUMBER
	ERROR	ERRERR		;MISSING SPECIAL FEATURE
	BR	PUSHF0		;RETURN A FLOATING ZERO

1$:	TST	(SP)		;EXPONENT NEGATIVE??
	BPL	PWR2		;NOPE, O.K.
	MOV	R1,R2		;SAVE R1 STACK
	JSR	PC,DUPLF	;DUP FLOATER
	FLTCLR	(R2)+		;MAKE A 1.000000
	MOV	#000017,(R2)+
	MOV	#041100,(R2)+
	JSR	PC,DIVF		;BY DIVIDING
	NEG	(SP)		;AND REVERSE EXP SIGN
	BVC	PWR2		;O.K.
	CLR	(SP)		;MAKE -32768 BE 0
PWR2:	MOV	R1,R2		;COPY R1 STACK
	ASR	(SP)		;GET EVEN/ODD INTO CARRY
	MOVFLT	(R2)+,-(SP)	;SAVE NUMBER
	BCS	PWR3		;IF ODD, THEN KEEP NUMBER
	MOV	R2,R1		;ELSE MAKE IT A 1.000000
	JSR	PC,PUSHF1
PWR3:	TST	FLTLE2(SP)	;END?
	BEQ	PWR9		;YES
PWR4:	MOVFLT	(SP)+,-(R1)	;NO, GET NUMBER
	JSR	PC,DUPLF	;DUPLICATE IT
	JSR	PC,MULF		;AND SQUARE IT
	ASR	(SP)		;SET CARRY FOR LATER
	MOVFLT	(R1)+,-(SP)	;SAVE THE SQUARE
	BCC	PWR4		;NO ADDITION
	FLTPP	-(R1)		;GRAB BACK THE SQUARE
	JSR	PC,MULF		;AND MULTIPLY IT IN
	BR	PWR3		;CHECK FOR END

PWR9:	ADD	#FLTLE2+2,SP	;COLLAPSE SP STACK
	RTS	PC		;AND EXIT
	.ENDC

.SBTTL	CONVERT FLOATER INTO DOUBLE INTEGER

CNVFDI::			;CONVERT FLOATER TO DOUBLE INTEGER
.IF	EQ	.MATH.
	TST	(R1)		;CHECK OUT THE FLOATER
	BLE	30$		;NEGATIVE OR ZERO IS SPECIAL CASED
.IF	DF	DECMAP
	MOV	SCAFAC,R0	;GET SCALING POINTER
	BEQ	10$		;NO SCALING
.IF	DF	FPU
	SETD
	LDD	(R1),F0
	DIVD	(R0),F0		;CORRECT FLOATER
	STD	F0,(R1)
.IFF
	JSR	PC,DIVFR0	;CORRECT FLOATER
.ENDC	;DF	FPU
10$:
.ENDC	;DF	DECMAP
	MOVB	(R1),R2		;GET FRACTION HIGH ORDER BITS
	BIC	#^C<177>,R2	; TRIM TO ONLY THE FRACTION
	BIS	#200,R2		;  AND PUT BACK THE 'HIDDEN' BIT
	ASL	(R1)+		;NOW SHIFT FOR A CORRECT EXPONENT VALUE
	CLR	R0		;GET CORRECT EXPONENT
	BISB	-1(R1),R0	; WITHOUT SIGN EXTENSION
	MOV	(R1)+,R3	;GET FRACTION LOW ORDER BITS
	SUB	#230,R0		;FIND THE SHIFT AMOUNT
	BMI	20$		;BR IF NUMBER IS NOT TOO BIG
	POST,	PSTFIX		;TOO BIG, POST AN ERROR
	MOV	#-30,R0		;THIS ENSURES A VALUE OF ZERO IS RETURNED
20$:	ASHC	R0,R2		;MAKE THE DOUBLE INTEGER
.IF	EQ	FLTLEN-4
	CMP	(R1)+,(R1)+	;DUMP REST OF FLOATER IF NEEDED
.ENDC	;EQ	FLTLEN-4
	MOV	R3,-(R1)	;SAVE LSB OF DOUBLE INTEGER
	MOV	R2,-(R1)	;SAVE MSB OF DOUBLE INTEGER
	RTS	PC		;NOW EXIT

30$:				;GO DO A NORMAL "FIX"
.ENDC	;EQ	.MATH.
	JSR	PC,FIX		;JUST "FIX" NEGATIVES AND ZERO
	CLR	-(R1)		;GIVE A HIGH ORDER OF ZERO
	RTS	PC		; AND EXIT

;PRINT IT ABSOLUTELY FOR SURE

	.IF	EQ	.MATH.
PRINU3:	.IF	EQ	FLTLEN-2
	CMP	(R1)+,(R1)+	;CLEAR JUNK ON R1 STACK
	.ENDC
PRINTA:	JSR	PC,FTOA		;GET THE INITIAL SCAN
PRNFL1:	MOV	FLTLE5(R1),R4	;GET THE SCALE FACTOR
	MOVB	$.PLCS+1,R0	;GET NUMBER OF SIG DIGITS TO PRINT
	NEG	R0		; AS A -(MAX #)
	TST	(SP)		;CALLED FROM PRINT USING?
	BNE	PRNF20		;IF NOT, THEN NORMAL
	MOV	#-MAXSIG+1,R0	;IF SO, THEN GIVE HIM THE MAX
PRNF20:	MOV	R1,R2		;COPY THE STACK POINTER
	SUB	#PRNBUC,R2	;MAKE ROOM FOR THE ENTIRE STRING
	MOV	R2,-(SP)	;SAVE THE POINTER START
	MOV	R1,R3		;COPY INPUT BUFFER POINTER
	CMPB	(R3),#'0	;SEE IF LEADING ZERO
	BNE	PRNF19		;IF NOT, DO NOT INCREMENT
	INC	R3		;IF SO, INCREMENT BY ONE
PRNF19:	SUB	R0,R3		;MOVE DOWN THE BUFFER
	CMPB	(R3),#'4	;SEE IF ROUNDING IS NEEDED
	BGT	PRNF17		;GO TO ROUND
PRNF18:	CMPB	(R1),#'0	;SEE IF ONE LEADING ZERO
	BNE	PRNF01		;BRANCH IF SIGNIFICANT DIGIT
	DEC	R4		;ADJUST THE SCALE FACTOR
	INC	R1		;POP OVER THE DIGIT
PRNF01:	INC	R4		;MAKE A FINAL ADJUSTMENT TO SCALE FACTOR
	IFZERO	EQ,2(SP),PRNF08	;NO SIGN OUT IF CALLED FROM PRINT USING
	MOVB	PRNBUF-3(R2),R3	;GET THE SIGN INDICATOR
	BNE	PRNF09		;SKIP IF NEGATIVE NUMBER
	MOVB	#40,R3		;LEADING SPACE INSTEAD OF A MINUS SIGN
PRNF09:	MOVB	R3,(R2)+	;OUTPUT THE SIGN
PRNF08:	MOV	R1,R3		;SAVE START OF STRING
	SUB	R0,R1		;GO TO TAIL END OF THE STRING
PRNF02:	CMPB	-(R1),#'0	;SEE IF TRAILING ZERO
	BNE	PRNF03		;BRANCH IF NOT 
	INC	R0		;REDUCE SIGFIGS COUNT
	BNE	PRNF02		;BRANCH OF MORE TO TEST
	DEC	R0		;ONE DIGIT FOR NUMBER = 0
	INC	R4		;AND MAKE THE SCALE FACTOR 1
PRNF03:	JMP	@PRINU0		;DISPATCH TO "PRNFL3" OR PRINT USING

PRNFL3:	CMPB	R4,$.PLCS	;TOO BIG TO PRINT?
	BGT	PRNF10		;YES
	TST	R4		;SEE IF NEGATIVE
	BGT	PRNF05		;IF POSITIVE OUTPUT SOME NOW
	ADD	R4,R0		;COMPUTE FIELD LENGTH
	MOVB	$.PLCS,-(SP)	;GET # OF DIGITS TO CONVERT
	NEGB	(SP)		;SEE IF TOO
	CMPB	R0,(SP)+	;  LONG
	BLT	PRNF10		;BRANCH FOR E FORMAT
	SUB	R4,R0
	MOVB	#'.,(R2)+	;START LITTLES WITH .
	TST	R4		;SEE IF ANY LEADING 0 NEEDED
PRNF04:	BPL	PRNF05		;IF READY GO PUT OUT DIGITS
	MOVB	#'0,(R2)+	;STORE A SPACE HOLDIN 0
	INC	R4		;ADJUST SCALE FACTOR UPWARDS
	BR	PRNF04		;LOOP FOR MORE

PRNE01:	IF	R3,LOS,R1,PRNF05 ;MOVE SIG DIGITS IF ANY REMAIN
	MOVB	#'0,(R2)+	;ELSE MOVE A TRAILING 0
	BR	PRNE02		;IN ANY CASE REDUCE THE COUNT

PRNF05:	MOVB	(R3)+,(R2)+	;MOVE A REALLY DIGIT
PRNE02:	DEC	R4		;REDUCE THE COUNT
	BGT	PRNE01		;BRANCH IF STILL GOOD NUMBERS TO GO
	BNE	PRNF06		;BRANCH IF FILLING UP SPACE
	CMP	R3,R1		;SEE IF END OF SIGNIFICANCE
	BHI	PRNF07		;EXIT IF ALL DONE
	MOVB	#'.,(R2)+	;STORE A .
	BR	PRNF05		;LOOP FOR MORE GOODNESS

PRNF06:	CMP	R3,R1		;SEE IF GOODNESS REMAINS
	BLOS	PRNF05		;BRANCH IF TOO SOON TO QUIT
PRNF07:	JSR	PC,@PRINU1	;DISPATCH TO A "RTS PC" OR PRINT USING
PRNFL5:	MOVB	#40,(R2)+	;INSERT TRAILING SPACE
	CLRB	(R2)+		;TRAILING NULL FOR PRINTL
	MOV	(SP)+,R2	;RESTORE DATA POINTER
	MOV	R2,R1		;R2 IS A GOOD GUESS
	ADD	#PRNBUF,R1	;NOW WE HAVE IT
	RTS	PC		;AND RETURN WITH IT ON THE STACK

PRNF10:	MOVB	#'.,(R2)+	;OUTPUT A LEADING .
PRNF11:	MOVB	(R3)+,(R2)+	;MOVE A DIGIT
	CMP	R3,R1		;SEE IF DONE
	BLOS	PRNF11		;LOOP IF MORE DIGITS
PRNFL2:	MOVB	#'E,(R2)+	;STORE THE E THING
	TST	R4		;SEE IF + OR -
	BPL	PRNF12		;BRANCH IF + OR 0
	MOVB	#'-,(R2)+	;MAKE IT MINUS WHEN IT PRINTS
	NEG	R4		;AND BACK TO +
	BR	PRNF13		;SKIP FOLLOWING STATEMENT

PRNF12:	MOVB	#40,(R2)+	;OUTPUT THE SIGN(POSITIVE)
PRNF13:	MOV	R2,-(SP)	;SAVE OUR PLACE PLEASE MISTER
	MOV	R2,R1		;FOR FTOA TAIL END
	CLR	R3		;HIGH ORDER OF R4
	MOV	#PRNF14,-(SP)	;RETURN ADDRESS
	.IF	EQ	FLTLEN-4
	CLR	R2		;HIGHER ORDER OF R4
	CLR	-(SP)		;HIGHER ORDER OF R4
	.ENDC
	MOV	#3,-(SP)	;COUNTER FOR FTOA06
	MOV	#ATOFTH,R0	;TABLE START
	JMP	FTOA09		;GO FIND THE EXPONENT

PRNF16:	CMPB	-(R3),#'9	;SEE IF CURRENT DIGIT CAN BE INCR.
	BEQ	PRNF17		;IF NOT, BRANCH OUT
	INCB	(R3)		;INCREMENT DIGIT
	BR	PRNF18		;BRANCH BACK

PRNF17:	MOVB	#'0,(R3)	;STORE ZERO AS DIGIT
	BR	PRNF16		;GO TO INCREMENT PREVIOUS DIGIT

PRNF14:	MOV	(SP)+,R2	;RESTORE OUR POSITION
	CLR	R4		;FOR PRNF05 STUFF
	MOV	R2,R1
	MOV	R1,R3		;JUST FIXING UP THE VARIOUS REGISTERS
	ADD	#3.,R1		;FOR PRNF05 LOOP
	JSR	PC,@PRINU1	;DISPATCH TO A "RTS PC" OR PRINT USING
PRNF15:	CMPB	(R3),#'0	;SEE IF LEADING ZERO
	BNE	PRNF05		;EXIT IF FOUND THE END
	INC	R3		;POP POINTER
	BR	PRNF15		;LOOP THERE MUST BE ONE!!
	.ENDC

	.IF	NE	.MATH.
PRINU3:				;ALWAYS 4 WORD
PRINTA:	JSR	PC,FTOA		;CONVERT TO ASCII
PRNFL1:	MOV	FLTLE5(R1),R4	;GET THE SCALE COUNTER
	MOV	R1,R2		;COPY THE R1 STACK
	SUB	#PRNBUC,R2	;MAKE ROOM FOR THE ENTIRE STRING
	MOV	R2,-(SP)	;SAVE R2 FOR LATER
	MOV	R1,R0		;COPY POINTER TO DIGIT START
PRNF10:	CMPB	(R1),#'0	;DELETE LEADING 0'S
	BNE	PRNF11		;NON-ZERO
	INC	R1		;GO TO NEXT DIGIT
	DEC	R4		;ONE LESS DIGIT BEFORE DOT
	CMP	R4,#-6.		;WATCH OUT FOR TRUE 0
	BGT	PRNF10		;STILL O.K.
	MOV	#1,R4		;IF TRUE 0, SAY 0
	MOV	R0,R1		;AND START AT THE TOP
PRNF11:	IFZERO	EQ,2(SP),PRNF08	;PRINT USING NO SIGN CHECK
	MOVB	PRNBUF-3(R2),R3	;GET SIGN
	BNE	PRNF09		;IT IS -
	MOV	#40,R3		;IF +, MAKE IT SPACE
PRNF09:	MOVB	R3,(R2)+	;SET SIGN
PRNF08:	MOV	R1,R3		;COPY POINTER
	MOV	R0,R1		;GET POINTER TO START
	ADD	#MAXSIG,R1	;THEN GO TO THE TAIL END+1
PRNF02:	CMPB	-(R1),#'0	;TRAILING 0?
	BNE	PRNF03		;NOPE
	CMP	R1,R0		;TRUE 0 CHECK AGAIN
	BHI	PRNF02		;STILL O.K.
PRNF03:	JMP	@PRINU0		;PRINT USING CHECK

PRNFL3:	TST	R4		;DECIMALS?
	BGT	PRND05		;NOPE
	MOVB	#'.,(R2)+	;YES, SET IT
	TST	R4		;0'S?
PRNF04:	BPL	PRND05		;NOPE
	MOVB	#'0,(R2)+	;YES
	INC	R4		;CORRECT COUNTER
	BR	PRNF04		;AND CONTINUE

PRND05:	MOVB	(R3)+,(R2)+	;MOVE DIGIT
	DEC	R4		;MORE?
	BGT	PRND05		;YES
	BNE	PRNF06		;DECIMAL?
	CMP	R3,R1		;END?
	BHI	PRNF07		;YES
	MOVB	#'.,(R2)+	;SET DECIMAL POINT
	BR	PRND05		;CONTINUE

PRNF06:	CMP	R3,R1		;END?
	BLOS	PRND05		;NOPE
PRNF07:	MOVB	#40,(R2)+	;TRAILING SPACE
	CLRB	(R2)+		;AND NULL
	MOV	(SP)+,R2	;RESTORE R2
	MOV	R2,R1		;SET R1
	ADD	#PRNBUF,R1	;AND CORRECT IT
	RTS	PC		;THEN EXIT

PRNF05:
PRNF15:
PRNFL2:	HALT			;JUST IN CASE!!
	.ENDC

PSTJS:	MOV	SPDA,R3		;GET SPDA POINTER
	ADD	R1,(R1)		;MAKE THE LINK ABSOLUTE
	MOV	(R1)+,(R3)	;STORE THE NEW START OF THE CHAIN
	SUB	R3,(R3)		;AND MAKE IT RELATIVE
	TST	(R1)+		;POP THE LENGTH AND POINTER
PITJS:	TST	(R1)+		;POP INTEGER OFF THE STACK
	RTS	PC		;AND RETURN

PRINTI:	JSR	PC,FLT		;FLOAT AN INTEGER
PRINTF:	JSR	PC,PRINTA	;CALL FOR CONVERSION
	BR	PRINTL		;AND PRINT IT

;	COMMA OPERATOR ROUTINE

NXTZON:	JSR	PC,POS000	;GET CURRENT POSITION
	MOV	(R1)+,R4	;PLACE IT IN R4
	MOV	#14.,R2		;HANDY ZONE (14.) COUNTER
	SUB	R2,R0		;INITIAL CORRECTION
10$:	SUB	R2,R0		;OUT OF ROOM?
	BLE	CRLF		;IF SO, THEN RETURN CARRIAGE
	SUB	R2,R4		;FIND FILL FACTOR
	BPL	10$		;STILL MORE...
20$:	CALL	PRINTX,R3,<40>	;PRINT A <SPACE>
	INC	R4		;ANOTHER?
	BNE	20$		;YEP
PRS01:	RTS	PC		;AND RETURN

;	PRINT STRING ROUTINE

PRINTS:	MOV	R1,R2		;COPY THE STACK POINTER
	ADD	PNTR(R2),R2	;POINT TO THE STRING
	JSR	PC,PSTJS	;GET RID OF THE STRING
	MOV	-2(R1),R4	;BUT RECOVER THE STRING'S LENGTH
	BLE	PRS00		;AVOID TRYING TO PRINT NULL STRINGS
	JSR	PC,PRINTL	;ELSE PRINT THE STRING
PRS00:	RTS	PC		;AND EXIT

; NOTE THAT "PRINTL" LOOKS AT THE RETURN ADDRESS OF "PRS00"!!!!!

CRLF:	MOV	#CRLF0,R2	;OUTPUT A <CR><LF>
PRINTL:	JSR	R4,SAVEM	;SAVE R4,R3,R2,R0
1$:	MOV	SPDA,R3		;GET THE LOCATION OF THE PDA
	ADD	CURRIO(R3),R3	;GET THE ADDRESS OF THE BUFFER HEADER
	BISB	#WRTARY,FLAGS(R3)	;SET MEDDLED BIT
	MOV	LENGTH(R3),R0	;GET THE LENGTH OF IT
	SUB	BYTCNT(R3),R0	;COMPUTE THE BYTES REMAINING
	MOV	R3,R4		;COPY THE HEADER ADDRESS
	ADD	CURLOC(R4),R4	;POINT TO THE CURRENT POSITION
10$:	DEC	R0		;SEE IF ANY MORE ROOM
	BGE	3$		;YES, SKIP OUTPUT THIS TIME
	BITB	#FORCE,FLAGS(R3);FORCE TYPE?
	BNE	20$		;YEP
	CLR	CURBLK(R3)	;SERIAL WRITE
	CLRB	CURBKM(R3)	; IN BOTH PLACES
20$:	MOV	LENGTH(R3),BYTCNT(R3)	;WHOLE BUFFER
	JSR	PC,PRL14	;WRITE IT
	BR	1$		;BACK AROUND

3$:	CMPB	#015,(R2)	;SEE IF A CR
	BNE	4$		;BRANCH IF PRINTING-MAYBE
	CLRB	POSITN(R3)	;GO TO START OF THE LINE
4$:	CMPB	#011,(R2)	;SEE IF A TAB
	BNE	99$		;BRANCH IF NOT TAB
98$:	INCB	POSITN(R3)	;TAB, BUMP A POSITION
	BITB	POSITN(R3),#7	;MORE?
	BNE	98$		;YES
99$:	BITB	#140,(R2)	;SEE IF PRINTABLE
	BEQ	5$		;BRANCH IF NO MARK GENERATED
	INCB	POSITN(R3)	;TALLY A CHARACTER PRINTED
5$:	MOVB	(R2)+,(R4)+	;MOVE A CHARACTER
	CMP	10(SP),#PRS00	;IS THIS THE SPECIAL "PRINTS" CALL?
	BNE	30$		;NOPE, SO CHECK FOR END OF ASCIZ STRING
	DEC	6(SP)		;YEP, MORE TO GO?
	BGT	10$		;MORE TO GO, SO SEND THEM
	BR	40$		;NO MORE, SO ALL DONE

30$:	TSTB	(R2)		;SEE IF MORE TO DO
	BNE	10$		;IF NOT NULL THEN GO AGAIN
40$:	SUB	R3,R4		;MAKE IT RELATIVE
	MOV	R4,CURLOC(R3)	;STORE THE UPDATED COUNT
	MOV	LENGTH(R3),BYTCNT(R3)	;GET READY FOR THE FINAL CALC.
	SUB	R0,BYTCNT(R3)	;COMPUTE THE BYTE COUNT USED
	BEQ	RESTEM		;IMPOSSIBLE - <>0 BYTCNT REQD FOR CLOSER
	BITB	#FORCE,FLAGS(R3);SEE IF OUTPUT NOW OR LATER
	BEQ	RESTEM		;ONLY ON EOB ELSEWISE
	JSR	PC,PRL14	;OUTPUT THE BUFFER NOW
RESTEM:	MOV	(SP)+,R0	;RESTORE R0
	MOV	(SP)+,R2	; AND R2
	MOV	(SP)+,R3	;  AND R3
	MOV	(SP)+,R4	;   AND R4
	RTS	PC		;NOW EXIT

PRL14:	MOV	PNTR(R3),CURLOC(R3)	;SET UP TO START AT THE BEGINNING
	BICB	#WRTARY,FLAGS(R3)	;CLEAR REWRITE BIT
	JSR	PC,WRITE.		;WRITE IT
	CLR	BYTCNT(R3)		;EMPTY THE BUFFER
	JMP	IODIE			;DIE ON ERROR ELSE EXIT

PRINTX::MOV	(R3)+,R2	;SET CHARACTER TO PRINT
PRINTC::CLR	-(SP)		;CLEAR THE "LINE"
	MOVB	R2,(SP)		;STORE THE WHOLE LINE
	MOV	SP,R2		;SET UP FOR PRINTL
	JSR	PC,PRINTL	;GO OUTPUT A "LINE"
	TST	(SP)+		;REMOVE THE OUTPUT AREA
	RETURN	R3		;EXIT

ATOF:	CLR	-(R1)
	CLR	-(R1)		;SET NUMBER TO BE TO ZERO
	FLTCLR	-(R1)		;SOME MORE CLEARS?
	CLR	-(SP)		;COUNT OF SIG. DIGITS
	CLR	-(SP)		;EXPONENT
	.IF	DF	DECMAP
	MOVB	SCAUPV,(SP)	;PRESET SCALING FACTOR
	.ENDC
	CLR	-(SP)		;SWITCHES IN A BYTE
				; SIG,MINUS,*,SIGN,DOT,EXP,*,DIG
	.IF	DF	FPV
	SETI
	.IF	EQ	FLTLEN-4
	SETD
	.IFF
	SETF
	.ENDC
	.ENDC
ATOF01:	MOVB	(R2)+,R3	;GET A CHARACTER
	BIC	#-177-1,R3	;CLEAR PARITY AND SIDE EFFECT
	CMPB	R3,#'0		;COMPARE IT WITH ASCII 0
	BLT	ATOF05		;IF LESS THAN ZERO CHECK SPECIAL CHARACTERS
	CMPB	R3,#'9		;COMPARE WITH ASCII 9
	BGT	ATOF05		;IF GREATER THAN NINE CHECK FOR OTHERS
	BISB	#1,(SP)		;SAY SOME DIGIT FOUND
	SUB	#'0,R3		;CONVERT TO BINARY
	BNE	ATOF02		;IT IS NON-ZERO
	BITB	#210,(SP)	;ACTUAL DIGIT YET?
	BMI	ATOF02		;IF SO, THEN CALL IF SIG.
	BEQ	ATOF01		;IF NO DECIMAL POINT YET, COMPLETE IGNORE
	DEC	2(SP)		;IF YES, THEN *10^-1 LESS
	BR	ATOF01		;AND CONTINUE

ATOF02:	BITB	#10,(SP)	;AFTER DECIMAL POINT
	BEQ	ATOF03		;NO, SO IT IS TIMES 10 AND ADD
	.IF	EQ	.MATH.
	CMP	4(SP),#MAXSIG	;IF AFTER DECIMAL, IS THIS TOO MUCH
	BGE	ATOF01		;IF SO, THEN IGNORE MORE
	.IFF
	CMP	2(SP),#-6	;CHECK FOR TOO MANY DECIMALS
	BLE	ATOF01		;START IGNORING
	.ENDC
	DEC	2(SP)		;ELSE *10^-1 LESS
ATOF03:	INC	4(SP)		;COUNT AS SIG DIGIT
	.IF	NDF	FPV
	MOV	R2,-(SP)	;SAVE THE INPUT POINTER
	.IF	EQ	.MATH.
	MOV	R3,R4		;SAVE THE NUMBER
	FPUSHC	10.		;PUSH A FLOATING 10.0
	.IF	EQ	FLTLEN-2
	JSR	R4,$MLR
	.WORD	1$,$IR,$ADR,2$
	.IFF
	JSR	R4,$MLD
	.WORD	1$,$IR,$ADD,2$
	.IFTF
1$:	MOV	(SP)+,-(R1)	;PUT DIGIT ON STACK
	JMP	@(R4)+
2$:
	.ENDC
	.IFF
	MOV	R3,-(SP)	;SAVE THE NUMBER
	JSR	PC,M10		;*10.
	ADD	#FLTLE2,R1	;NOW POINT TO BOTTOM+2
	ADD	(SP)+,-(R1)	;AND ADD IN THE NEW DIGIT
	ADC	-(R1)		;THEN CARRY
	ADC	-(R1)		; AND CARRY
	ADC	-(R1)		;  AND CARRY...
	.ENDC
	MOV	(SP)+,R2	;RESTORE THE INPUT POINTER
	.IFF
	.IF	EQ	FLTLEN-4
	LDCID	R3,F0		;F0 CONTAINS CURRENT DIGIT
	LDD	ATOFTA,F1	;F1 CONTAINS FLOATING TEN
	MULD	(R1)+,F1	;MULTIPLY ACCUMULATED SUM BY 10
	ADDD	F1,F0		;ADD IN DIGIT
	STD	F0,-(R1)	;STORE RESULT ON R1 STACK
	.IFF
	LDCIF	R3,F0		;F0 CONTAINS CURRENT DIGIT
	LDF	ATOFTA,F1	;F1 CONTAINS FLOATING TEN
	MULF	(R1)+,F1	;MULTIPLY ACCUMULATED SUM BY 10
	ADDF	F1,F0		;ADD IN DIGIT
	STF	F0,-(R1)	;STORE RESULT ON R1 STACK
	.ENDC
	.ENDC
	BISB	#201,(SP)	;SET SIGNIFICANCE
	BR	ATOF01		;GET NEXT CHARACTER

ATOF05:	CMPB	R3,#40		;SEE IF A <SP>
	BEQ	ATOF01		;IGNORE SPACES
	CMPB	R3,#011		;SEE IF A <TAB>
	BEQ	ATOF01		;IGNORE TABS
	CMPB	R3,#'.		;COMPARE WITH DECIMAL POINT
	BEQ	ATOF10		;GO ON POINT
	.IF	EQ	.MATH.
	CMPB	R3,#'E		;COMPARE WITH AN "E"
	BEQ	ATOF11		;BRANCH IF AN "E"
	CMPB	R3,#'E+40	;COMPARE WITH A LOWER CASE "E"
	BEQ	ATOF11		;BRANCH IF AN "E"
	.ENDC
	CMPB	R3,#'+		;COMPARE WITH A PLUS SIGN
	BEQ	10$		;IT IS + SIGN, BRANCH C=0 (BEQ=>BHIS=BCC)
	CMPB	R3,#'-		;COMPARE WITH MINUS SIGN
	BNE	ATOF12		;IF NOT SPECIAL THEN QUIT THE SCAN
	SEC			;SET C=1 FOR - SIGN SEEN
10$:	BITB	#231,(SP)	;NO NUMBERS(S),SIGNS(A), OR DECIMAL PT(D)
	BNE	ATOF12		;IF ANY ARE ON THEN END SCAN
	BISB	#21,(SP)	;*B* SET THE A SWITCH
	BCC	ATOF01		;IF + THEN NEXT CHARACTER PLEASE
	BISB	#101,(SP)	;*B* MINUS FRACTION BIT 
	BR	ATOF01		;GO GET MORE

ATOF10:	BITB	#10,(SP)	;ALREADY HAVE A DECIMAL POINT?
	BNE	ATOF12		;YES, SO END THE SCAN
	BISB	#10,(SP)	;SHOW DECIMAL PT FOUND
	BR	ATOF01		;COULD BE MORE TO COME

	.IF	EQ	.MATH.
ATOF11:	BITB	#1,(SP)		;SEE IF ANY NUMBERS TYPED
	BEQ	ATOF12		;NO NUMBERS NO DICE
	BISB	#4,(SP)		;SHOW E FOUND
	JSR	PC,ATOI		;GO COLLECT THE EXPONENT
	BVS	ATOF21		;BRANCH IF TWO SIGNS OR TOO BIG
	BIT	R4,#2		;SEE IF ANY #'S TYPED
	BNE	ATOF22		;BRANCH IF O.K.
	BICB	#4,(SP)		;CLEAR THE EXP FLAG CAUSE ITS NOT THAT
	TST	(R1)+		; AND DUMP THE EXPONENT VALUE
	BR	ATOF12		;  THEN END THE SCAN

ATOF21:	BICB	#201,(SP)	;SIGNAL ERROR TO ATOF12
ATOF22:	INC	R2		;POP CHARACTER POINTER TO FIX ATOI EXIT
	ADD	(R1)+,2(SP)	;ACCULMULATE EXPONENT
	BVC	ATOF12		;ADDITION IS O.K.
	BICB	#201,(SP)	;ELSE SIGNAL ERROR
	.ENDC

ATOF12:	MOV	(SP)+,R4	;GET THE SWITCHES
	BEQ	ATOF14		;IF NOTHING THE ANS=0.
	BITB	R4,#201		;IF ANY SWITCHES THEN MUST BE DIGITS
	BEQ	ATOF13		;NO IS AN ERROR
	.IF	EQ	.MATH.
	BMI	ATOF08		;IF SIG DIGITS THEN CONTINUE
	CLR	(SP)		;ELSE SAY TRUE 0
ATOF08:	BITB	R4,#100		;SEE IF MINUS FRACTION
	BEQ	ATOF14		;IF POSITIVE OMIT NEXT STEP
	JSR	PC,NEGF		;MAKE NEGATIVE
ATOF14:	MOV	(SP)+,(SP)	;GET EXPONENT
	BEQ	ATOF16		;EXIT IF NO ADJUSTMENT
	BPL	ATOF18		;BRANCH IF POSITIVE EXPONENT
	MOV	#ATOFTB+MFLTL2,R0  ;NEGATIVE POWERS OF 10
	NEG	(SP)		;MAKE EXPONENT POSITIVE
	BR	ATOF20		;MAKE LIKE POSITVESVILLE

ATOF18:	MOV	#ATOFTA+MFLTL2,R0  ;POSITIVE POWERS OF 10
ATOF19:	CMP	(SP),#MAXPOW+6	;AN UPPER LIMIT
	BHI	ATOF23		;BRANCH IF OUT OF RANGE
ATOF20:	TST	(SP)		;SEE IF ANY BITS ARE LEFT
	BEQ	ATOF16		;EXIT IF DONE
	.IF	NDF	FPV
	FLTPP	(R0)+		;GO TO NEXT ELEMENT
	ASR	(SP)		;GET THE LOW ORDER BIT
	BCC	ATOF20		;IF NOT SET DON'T MULTIPLY
	MOV	R0,-(SP)	;SAVE THE POINTER
	MOV	R2,-(SP)	;SAVE THE INPUT POINTER
	MOV	R4,-(SP)	;SAVE THE SWITCHES
	JSR	PC,MULFR0	;PUSH TABLE VALUE AND MULTIPLY
	MOV	(SP)+,R4	;RESTORE THE SWITCHES
	MOV	(SP)+,R2	;RESTORE THE INPUT POINTER
	MOV	(SP)+,R0	;GET THE POINTER BACK
	.ENDC
	.IF	DF	FPV
	.IF	EQ	FLTLEN-4
	TSTD	(R0)+		;GO TO NEXT ELEMENT
	ASR	(SP)		;GET THE LOW ORDER BIT
	BCC	ATOF20		;IF NOT SET DON'T MULTIPLY
	LDD	(R0),F0		;LOAD WITH TABLE VALUE
	MULD	(R1)+,F0	;MULTIPLY
	STD	F0,-(R1)	;STORE RESULT ON R1 STACK
	.ENDC
	.IF	NE	FLTLEN-4
	TSTF	(R0)+		;GO TO NEXT ELEMENT
	ASR	(SP)		;GET THE LOW ORDER BIT
	BCC	ATOF20		;IF NOT SET DON'T MULTIPLY
	LDF	(R0),F0		;LOAD WITH TABLE VALUE
	MULF	(R1)+,F0	;MULTIPLY
	STF	F0,-(R1)	;STORE RESULT ON R1 STACK
	.ENDC
	.ENDC
	BR	ATOF20		;LOOP FOR MORE TO DO
	.ENDC

	.IF	NE	.MATH.
ATOF14:	MOV	(SP)+,(SP)	;GET EXPONENT
	ADD	#6.,(SP)	;CORRECT IT
	BEQ	ATOF20		;NO MORE CORRECTIONS
	TSTB	R4		;ANY DIGITS?
	BPL	ATOF16		;NO, SO REALLY 0
	MOV	R4,-(SP)	;SAVE FLAG REGISTER
	MOV	R2,-(SP)	;AND INPUT POINTER
1$:	JSR	PC,M10		;MULTIPLY BY 10.
	DEC	4(SP)		;AGAIN?
	BNE	1$		;YES
	MOV	(SP)+,R2	;RESTORE INPUT POINTER
	MOV	(SP)+,R4	;AND FLAG REGISTER
ATOF20:	BIT	R4,#100		;NEGATE IT?
	BEQ	ATOF16		;NO
	JSR	PC,NEGF		;YES
	BR	ATOF16		;THEN EXIT
	.ENDC

ATOF13:	TST	(SP)+		;POP THE EXTRA WORD
ATOF17:	BIS	#40000,R4	;SIGNAL THE ERROR
ATOF16:	TST	(SP)+		;CLEAN UP THE STACK
	.IF	DF	DECMAP
	TST	SCAFAC		;SCALING?
	BEQ	1$		;NOPE
	.IF	NDF	FPU
	MOV	R2,-(SP)	;SAVE INPUT POINTER
	MOV	R4,-(SP)	;AND FLAGS
	.IFF
	LDD	(R1),F0		;GET THE RESULT
	.IFTF
	JSR	PC,SCAFIX	;CORRECT NUMBER
	.IFT
	MOV	(SP)+,R4	;RESTORE FLAGS
	MOV	(SP)+,R2	;AND INPUT POINTER
	.ENDC
1$:
	.ENDC
	DEC	R2		;RETURN POINTING TO THE FIRST BAD CHARACTER
	ASL	R4		;SET V AND C AS NEEDED
	RTS	PC

ATOF23:	POST,	PSTFLT		;POST FLOATING POINT ERROR
	MOV	R1,R0		;COPY R1 TO R0
	CLR	(R0)+		;CLEAR A WORD
	CLR	(R0)+		;CLEAR ANOTHER, SO ATOF RETURNS 0
	.IF	EQ	FLTLEN-4
	CLR	(R0)+		;CLEAR ANOTHER
	CLR	(R0)+		;CLEAR ANOTHER, IN 4-WORD CASE
	.ENDC
	BR	ATOF17		;AND EXIT

.IF	NE	.MATH.

M10:	MOV	#FLTLEN,R4	;GET # WORDS TO DO
	ADD	#FLTLE2,R1	;POINT TO BOTTOM+2 OF NUMBER
	CLR	R2		;NO CURRENT CARRY INITIALLY
1$:	MOV	R2,-(SP)	;SAVE THE CURRENT CARRY
	MOV	-(R1),R2	;GET NEXT TO MULTIPLY
	BEQ	3$		;HANDLE ZERO QUICKLY
	BMI	4$		;SPECIAL CASE ONES >=32768.
	MUL	#10.,R2		;R2,R3 GETS X*10.
2$:	ADD	R3,(SP)		;ADD LOW ORDER TO CURRENT CARRY
	ADC	R2		;IF CARRY CARRIES THEN CARRY
3$:	MOV	(SP)+,(R1)	;LOAD NEW RESULTANT WORD
	SOB	R4,1$		;DO ALL OF THE WORDS...
	RTS	PC		;DONE

4$:	BIC	#100000,R2	;MAKE >=32768. INTO (X-32768.) [<32768.]
	MUL	#10.,R2		;R2,R3 GETS (X-32768.)*10.
	ADD	#10./2,R2	;NOW ADD IN 32768.*10.
	BR	2$		;AND CONTINUE

	.ENDC

	.IF	EQ	.MATH.
;	THE FOLLOWING IS A TABLE OF POWERS OF TEN OF THE FORM
;	10^(2^N) WHERE N IS AN INTEGER

	.IF	EQ	FLTLEN-2
ATOFTA:	.FLT2	1.E1		;10^1
	.FLT2	1.E2		;10^2
	.FLT2	1.E4		;10^4
	.FLT2	1.E8		;10^8
	.FLT2	1.E16		;10^16
	.FLT2	1.E32		;10^32
	.ENDC
	.IF	EQ	FLTLEN-4
ATOFTA:	.FLT4	1.E1		;10^1
	.FLT4	1.E2		;10^2
	.FLT4	1.E4		;10^4
	.FLT4	1.E8		;10^8
ATOFTI:	.FLT4	1.E16		;10^16
	.FLT4	1.E32		;10^32
	.ENDC
ATOFTC	=	.

;	THE FOLLOWING IS A TABLE OF POWERS OF TEN OF THE FORM
;	10^-(2^N) WHERE N IS AN INTEGER

	.IF	EQ	FLTLEN-2
ATOFTB:	.FLT2	1.E-1		;10^-1
	.FLT2	1.E-2		;10^-2
	.FLT2	1.E-4		;10^-4
	.FLT2	1.E-8		;10^-8
	.FLT2	1.E-16		;10^-16
	.FLT2	1.E-32		;10^-32
	.ENDC
	.IF	EQ	FLTLEN-4
ATOFTB:	.FLT4	1.E-1		;10^-1
	.FLT4	1.E-2		;10^-2
	.FLT4	1.E-4		;10^-4
	.FLT4	1.E-8		;10^-8
	.FLT4	1.E-16		;10^-16
	.FLT4	1.E-32		;10^-32
	.ENDC
ATOFTD	=	.

;	MISCELLANEOUS CONSTANTS AND TABLES
	.IF	EQ	FLTLEN-2
ATOFTG:	.WORD	000230,113200	;10000000
	.WORD	000017,041100	;1000000
	.WORD	000001,103240	;100000
	.WORD	000000,023420	;10000
ATOFTH:	.WORD	000000,001750	;1000
	.WORD	000000,000144	;100
	.WORD	000000,000012	;10
ATOFTE:	.FLT2	1.E6		;10^6
ATOFTI:	.FLT2	1.E7		;10^7
	.ENDC
	.IF	EQ	FLTLEN-4
ATOFTG:	.WORD	000043,103362,067701,000000	;10000000000000000
	.WORD	000003,106576,122306,100000	;1000000000000000
	.WORD	000000,055363,010172,040000	;100000000000000
	.WORD	000000,004430,047162,120000	;10000000000000
	.WORD	000000,000350,152245,010000	;1000000000000
	.WORD	000000,000027,044166,164000	;100000000000
	.WORD	000000,000002,052013,162000	;10000000000
	.WORD	0,0,035632,145000		;1000000000
	.WORD	0,0,002765,160400		;100000000
	.WORD	0,0,000230,113200		;10000000
	.WORD	0,0,000017,041100		;1000000
	.WORD	0,0,000001,103240		;100000
	.WORD	0,0,000000,023420		;10000
ATOFTH:	.WORD	0,0,000000,001750		;1000
	.WORD	0,0,000000,000144		;100
	.WORD	0,0,000000,000012		;10
ATOFTE:	.FLT4	1.E15				;10^15
	.ENDC

FTOA03:	MOV	#ATOFTD+MFLTL2,R0  ;TABLE OF NEG POWERS OF 10
	MOV	#-MAXPOW,R2	;AND THE STARTING EXPONENT VALUE
	.IF	NDF	FPV
FTOA05:	JSR	PC,PUSHF2	;PUSH THE NUMBER
	MOV	R2,-(SP)	;SAVE THE EXPONENT
	MOV	R0,-(SP)	;AND THE POINTER
	JSR	PC,CMPF		;DO THE COMPARE
	BGT	FTOA15		;BRANCH IF NO ADJUSTMENT
	MOV	(SP),R0		;GET THE POINTER
	ADD	#ATOFTA-ATOFTB,R0	;FIND THE INVERSE
	JSR	PC,MULFR0	;PUSH IT ON THE STACK AND MULTIPLY
	ADD	2(SP),4(SP)	;UPDATE THE EXPONENT
FTOA15:	MOV	(SP)+,R0	;RESTORE THE POINTER
	MOV	(SP)+,R2	;RESTORE THE CURRENT EXPONENT
	FLTPP	-(R0)		;GO TO NEXT ITEM
	ASR	R2		;ADJUST AND CHECK FOR THE END
	BCC	FTOA05		;LOOP IF MORE TO DO
	MOV	#ATOFTI,R0	;MULTIPLIER FOR HERE
	.ENDC
	.IF	DF	FPV
	.IF	EQ	FLTLEN-4
	SETD
FTOA05:	LDD	(R0),F0		;LOAD WITH THE SELECTED ITEM
	CMPD	(R1),F0		;DO THE COMPARE
	CFCC
	BGT	FTOA15		;BRANCH IF NO ADJUSTMENT
	MOV	R0,-(SP)	;COPY POINTER TO SP
	ADD	#ATOFTA-ATOFTB,(SP)	;POINT TO THE INVERSE 
	LDD	@(SP)+,F0	;LOAD WITH THE INVERSE
	MULD	(R1)+,F0	;MULTIPLY
	STD	F0,-(R1)	;SAVE PRODUCT ON R1 STACK
	ADD	R2,(SP)		;UPDATE THE EXPONENT
FTOA15:	TSTD	-(R0)		;GO TO NEXT ITEM
	ASR	R2		;ADJUST AND CHECK FOR THE END
	BCC	FTOA05		;LOOP IF MORE TO DO
	LDD	ATOFTI,F1	;MULTIPLIER FOR HERE
	.ENDC
	.IF	NE	FLTLEN-4
	SETF
FTOA05:	LDF	(R0),F0		;LOAD WITH THE SELECTED ITEM
	CMPF	(R1),F0		;DO THE COMPARE
	CFCC
	BGT	FTOA15		;BRANCH IF NO ADJUSTMENT
	MOV	R0,-(SP)	;COPY POINTER TO SP
	ADD	#ATOFTA-ATOFTB,(SP)	;POINT TO THE INVERSE
	LDF	@(SP)+,F0	;LOAD WITH THE INVERSE
	MULF	(R1)+,F0	;MULTIPLY
	STF	F0,-(R1)	;SAVE PRODUCT ON R1 STACK
	ADD	R2,(SP)		;UPDATE THE EXPONENT
FTOA15:	TSTF	-(R0)		;GO TO NEXT ITEM
	ASR	R2		;ADJUST AND CHECK FOR THE END
	BCC	FTOA05		;LOOP IF MORE TO DO
	LDF	ATOFTI,F1	;MULTIPLIER FOR HERE
	.ENDC
	.ENDC
	BR	FTOA16		;ELSE GO FINISH UP LIKE NORMAL

FTOA:	.IF	DF	DECMAP
	MOV	SCAFAC,R0	;SCALING?
	BEQ	1$		;NOPE
	.IF	DF	FPU
	SETD
	LDD	(R1),F0		;GET NUMBER
	DIVD	(R0),F0		;CORRECT NUMBER
	STD	F0,(R1)
	.IFF
	JSR	PC,DIVFR0	;CORRECT NUMBER
	.ENDC
1$:
	.ENDC
	CLR	-(SP)		;SIGN CONTROL WORD
	ASL	(R1)		;PUT SIGN INTO CARRY, SET Z IF 0
	BEQ	FTOA00		;IT IS A 0 (HOWEVER FUNNY...)
	BCC	10$		;NON-0 AND POSITIVE
	COM	(SP)		;NON-0 AND NEGATIVE, SET SIGN FLAG
10$:	CLR	-(SP)		;THIS WORD BECOMES THE SCALE FACTOR
	;CLC			;C=0 FROM 'CLR' ABOVE
	ROR	(R1)		;CORRECT THE ARGUEMENT
	JSR	PC,FTOA90	;GET EXPONENT
	CMPB	R0,#200		;CHECK TO SEE IF BIG OR LITTLE
	BLOS	FTOA03		;BRANCH IF A FRACTION
	MOV	#ATOFTC+MFLTL2,R0  ;ADDRESS OF POWERS OF TEN TABLE
	MOV	#MAXPOW,R2	;AND THE FIRST EXPONENT
	.IF 	NDF	FPV
FTOA02:	JSR	PC,PUSHF2	;PUSH THE SELECTED ITEM
	MOV	R2,-(SP)	;SAVE THE EXPONENT VALUE
	MOV	R0,-(SP)	;AND THE POINTER
	JSR	PC,CMPF		;SEE WHICH SIDE OF THE FENCE HE'S ON
	BLT	FTOA04		;BRANCH IF NO ADJUSTMENT NEEDED
	MOV	(SP),R0		;GET THE TABLE POINTER
	ADD	#ATOFTB-ATOFTA,R0	;POINT TO THE INVERSE VALUE
	JSR	PC,MULFR0	;PUSH INVERSE. MULTIPLYING BY INVERSE SAVES DIVIDING
	ADD	2(SP),4(SP)	;ADJUST THE SCALE FACTOR ACCORDINGLY
FTOA04:	MOV	(SP)+,R0	;GET THE POINTER BACK
	MOV	(SP)+,R2	;GET EXPONENT BACK
	FLTPP	-(R0)		;AND GO TO NEXT ENTRY
	ASR	R2		;SEE IF DONE
	BCC	FTOA02		;LOOP IF NOT QUITE DONE
	INC	(SP)		;GET A REAL GOOD ESTIMATE
	MOV	#ATOFTE,R0	;ADDRESS OF ESTIMATE
FTOA16:	JSR	PC,MULFR0	;PUSH IT AND MULTIPLY TO GET BIG INTEGER
	.ENDC
	.IF	DF	FPV
	.IF	EQ	FLTLEN-4
	SETD
FTOA02:	LDD	(R0),F0		;LOAD WITH THE SELECTED ITEM
	CMPD	(R1),F0		;SEE WHICH SIDE OF THE FENCE HE'S ON
	CFCC
	BLT	FTOA04		;BRANCH IF NO ADJUSTMENT NEEDED
	MOV	R0,-(SP)	;COPY POINTER TO SP
	ADD	#ATOFTB-ATOFTA,(SP)	;POINT TO THE INVERSE VALUE
	LDD	@(SP)+,F0	;LOAD WITH THE INVERSE VALUE
	MULD	(R1)+,F0	;MULTIPLYING BY THE INVERSE VALUE SAVES DIVIDING
	STD	F0,-(R1)	;STORE PRODUCT ON R1 STACK
	ADD	R2,(SP)		;ADJUST THE SCALE FACTOR ACCORDINGLY
FTOA04:	TSTD	-(R0)		;GO TO THE NEXT ENTRY
	ASR	R2		;SEE IF DONE
	BCC	FTOA02		;LOOP IF NOT QUITE DONE
	INC	(SP)		;GET A REAL GOOD ESTIMATE
	LDD	ATOFTE,F1	;LOAD WITH ESTIMATE
FTOA16:	MULD	(R1)+,F1	;MULTIPLY TO GET BIG INTEGER
	STD	F1,-(R1)	;STORE RESULT ON R1
	.ENDC

	.IF	NE	FLTLEN-4
	SETF
FTOA02:	LDF	(R0),F0		;LOAD WITH THE SELECTED ITEM
	CMPF	(R1),F0		;SEE WHICH SIDE OF THE FENCE HE'S ON
	CFCC
	BLT	FTOA04		;BRANCH IF NO ADJUSTMENT NEEDED
	MOV	R0,-(SP)	;COPY POINTER TO SP
	ADD	#ATOFTB-ATOFTA,(SP)	;POINT TO THE INVERSE VALUE
	LDF	@(SP)+,F0	;LOAD WITH THE INVERSE VALUE
	MULF	(R1)+,F0	;MULTIPLYING BY THE INVERSE SAVES DIVIDING
	STF	F0,-(R1)	;STORE PRODUCT ON R1 STACK
	ADD	R2,(SP)		;ADJUST THE SCALE FACTOR ACCORDINGLY
FTOA04:	TSTF	-(R0)		;GO TO THE NEXT ENTRY
	ASR	R2		;SEE IF DONE
	BCC	FTOA02		;LOOP IF NOT QUITE DONE
	INC	(SP)		;GET A REAL GOOD ESTIMATE
	LDF	ATOFTE,F1	;LOAD WITH ESTIMATE
FTOA16:	MULF	(R1)+,F1	;MULTIPLY TO GET BIG INTEGER
	STF	F1,-(R1)	;STORE RESULT ON R1
	.ENDC
	.ENDC
	.IF	EQ	FLTLEN-2
	MOV	#230,R2		;THE EXPONENT FOR DOUBLE PRECISION
	CLR	R3
	BISB	(R1),R3		;GET THE HIGH ORDER FRACTION
	BIS	#200,R3		;SET BIT FOR UNHIDDEN NORMALIZATION
	JSR	PC,FTOA90	;PICK UP EXPONENT
	TST	(R1)+		;POP R1
	MOV	(R1)+,R4	;GET THE LOW ORDER FRACTION
	SUB	R0,R2		;CALCULATE THE SHIFT NEEDED
	.ENDC
	.IF	EQ	FLTLEN-4
	MOV	#270,-(SP)	;THE EXPONENT FOR DOUBLE PRECISION
	JSR	PC,FTOA90	;PICK UP EXPONENT
	SUB	R0,(SP)		;CALCULATE THE SHIFT NEEDED
	CLR	R0
	BISB	(R1),R0		;GET THE HIGH ORDER FRACTION
	BIS	#200,R0		;SET BIT FOR UNHIDDEN NORMALIZATION
	TST	(R1)+		;POP R1
	MOV	(R1)+,R2	;GET SECOND WORD OF MAGNITUDE
	MOV	(R1)+,R3	;GET THIRD WORD OF MAGNITUDE
	MOV	(R1)+,R4	;GET FOURTH WORD OF MAGNITUDE
	TST	(SP)		;CHECK SHIFT NEEDED
	.ENDC
	BEQ	FTOA11		;BRANCH IF NONE TO BE DONE
	.IF	NE	FLTLEN-4
FTOA06:	ASR	R3		;MOVE THE HIGH PART ONE BIT
	ROR	R4		;AND PUT IT IN THE LOW ORDER
	DEC	R2		;COUNT DOWN ONE
	.ENDC
	.IF	EQ	FLTLEN-4
FTOA06:	ASR	R0		;MOVE THE HIGH PART ONE BIT
	ROR	R2		;AND PUT IN THE LOWER PARTS
	ROR	R3
	ROR	R4
	DEC	(SP)		;COUNT DOWN ONE
	.ENDC

	BGT	FTOA06		;LOOP IF MORE TO DO
FTOA11:
	.IF	EQ	FLTLEN-4
	TST	(SP)+		;REMOVE COUNTER FROM SP
	.ENDC
	MOV	(SP)+,-(R1)	;COPY THE SCALE FACTOR OVER
	TST	(SP)+		;SEE ABOUT THE SIGN
	BEQ	FTOA07		;BRANCH IF POSITIVE
	MOV	(PC)+,-(R1)	;SET - SIGN IN ODD BYTE
	.BYTE	0,'-
	BR	FTOA08		;REJOIN THE MAIN STREAM CODE

FTOA00:	CMP	(SP)+,(R1)+	;DUMP SIGN AND ONE DATA WORD
.IF	EQ	FLTLEN-4
	CMP	(R1)+,(R1)+	;DUMP TWO MORE WORDS HERE
	CLR	R0
	CLR	R2
.ENDC
	CLR	R3		;CLEAR THE NUMBER
	CLR	R4		;HIGH AND LOW ORDER
	CLR	(R1)		;GUARENTEE TRUE 0

FTOA07:	CLR	-(R1)		;STORE A ZERO FOR A SIGN
FTOA08:	CLR	-(R1)		;CLEAR A
	CLR	-(R1)		;  SMALL OUTPUT
	CLR	-(R1)		;    BUFFER
	CLR	-(R1)		
	FLTCLR	-(R1)		;DO SOME CLEARING?
	.IF	EQ	FLTLEN-4
	CLR	-(R1)
	CLR	-(R1)
	CLR	-(R1)
	MOV	R0,-(SP)
	.ENDC
	MOV	#MAXSIG,-(SP)	;START A COUNTER
	MOV	#ATOFTG,R0	;INTEGER POWERS OF TEN STUFF
	.IF	NE	FLTLEN-4
FTOA09:	MOV	#-1,R2		;QUOTIENT REGISTER
FTOA10:	INC	R2		;COUNT THE SUBTRACTIONS
	SUB	(R0),R3		;DO A DOUBLE
	SUB	2(R0),R4	;  PRECISION
	SBC	R3		;    SUBTRACTION
	BPL	FTOA10		;LOOP IF NO OVERDRAW
	ADD	(R0)+,R3	;ELSE CORRECT 
	ADD	(R0)+,R4	;THE ERROR
	ADC	R3		;WITH A DOUBLE ADD
	ADD	#'0,R2		;CONVERT TO ASCII
	MOVB	R2,(R1)+	;AND STORE IT
	.ENDC
	.IF	EQ	FLTLEN-4
FTOA09:	MOV	#-1,-(SP)	;QUOTIENT REGISTER
FTOA10:	INC	(SP)		;COUNT THE SUBTRACTIONS
	MOV	4(SP),-(SP)	;SAVE THE CURRENT VALUE
	MOV	R2,-(SP)
	MOV	R3,-(SP)
	MOV	R4,-(SP)
	SUB	6(R0),R4	;DO
	SBC	R3		;  A
	SBC	R2
	SBC	12.(SP)
	SUB	4(R0),R3	;    MULTIPLE
	SBC	R2		;      PRECISION
	SBC	12.(SP)
	SUB	2(R0),R2	;        SUBTRACT
	SBC	12.(SP)
	SUB	(R0),12.(SP)
	BMI	FTOA13		;BRANCH IF OVERDRAWN
	ADD	#8.,SP		;RESET SP
	BR	FTOA10		;LOOP BACK AGAIN
FTOA13:	MOV	(SP)+,R4	;RESTORE PREVIOUS VALUE
	MOV	(SP)+,R3
	MOV	(SP)+,R2
	MOV	(SP)+,4(SP)
	ADD	#8.,R0		;MOVE TO NEXT VALUE IN TABLE
	ADD	#'0,(SP)	;CONVERT TO ASCII
	MOVB	(SP)+,(R1)+	;AND STORE IT
	.ENDC
	DEC	(SP)		;SEE IF MORE TO DO
	BGT	FTOA09		;IF + GO AGAIN
	ADD	#'0,R4		;FINISH UP THE LAST DIGIT
	MOVB	R4,(R1)+	;AND STORE IT AWAY
	CLRB	(R1)		;CLEAR NEXT BYTE
	SUB	#MAXSIG+1,R1	;GO BACK TO THE TOP OF R1
	.IF	EQ	FLTLEN-4
	CMP	(SP)+,(SP)+	;GET RID OF COUNTER AND MAG WORD
	.ENDC
	.IF	NE	FLTLEN-4
	TST	(SP)+		;GET RID OF COUNTER
	.ENDC
	RTS	PC

FTOA90:	MOV	(R1),R0		;PICK UP EXPONENT WORD
	ASL	R0		;SHIFT OFF SIGN BIT
	CLRB	R0		;CLEAR MAG BITS
	SWAB	R0		;MOVE EXPONENT TO RIGHT OF WORD
	RTS	PC		;RETURN
	.ENDC

RND:	TST	(R1)		;NO ARGS IS OK
	BEQ	10$		;BRANCH IF NO ARGS
	JSR	R5,INTFAF	;DEMAND ONE FLOATING ARGUMENT
.IF	EQ	FLTLEN-2
	TST	(R1)+		;DUMP FIRST WORD OF FLOATER
.IFF
	ADD	#3*2,R1		;DUMP FIRST 3 WORDS OF FLOATER
.ENDC	;EQ	FLTLEN-2
10$:	TST	(R1)+		;FINAL 1 WORD DUMP
	MOV	SPDA,R4		;GET A DATA AREA POINTER
	MOV	RNDML(R4),R3	;GET SEED
	MOV	RNDMH(R4),R2
	ASL	R3		;*2
	ROL	R2
	ADD	RNDMH(R4),R2	;NOW *3
	ADD	RNDML(R4),R3
	ADC	R2
	ADD	RNDML(R4),R2	;NOW 2**16+3
	BPL	20$
	ADD	#100000,R2	;GET 2**32+3
20$:	MOV	R3,RNDML(R4)	;SAVE NEW SEED
	MOV	R2,RNDMH(R4)
.IF	EQ	.MATH.
	MOV	#201+1,R0	;INITIAL (BIASED) EXPONENT & POSITIVE
NORMSC:				;NORMALIZE THEN SCALE IF NEEDED
.IF	DF	DECMAP
	CALL	NORMIT		;GO DO THE NORMALIZE
	TST	SCAFAC		;SCALING?
	BEQ	RNDRTS		;NOPE
	JMP	SCACR1		;YEP, CORRECT
.ENDC	;DF	DECMAP
NORMIT:	FLTCLR	-(R1)		;CLEAR LOW ORDER WORDS IF NEEDED
	TST	R2		;HIGH ORDER ALL ZERO?
	BNE	10$		;NO
	MOV	R3,R2		;YES, MOVE LOW ORDER INTO HIGH ORDER
	BEQ	20$		;WHOOPS! BOTH ZERO, CALL IT TRUE 0.0
	CLR	R3		;NOW CLEAR THE LOW ORDER
	SUB	#20,R0		;THAT COUNTS AS 16. SHIFTS
10$:	DEC	R0		;CORRECT EXPONENT
	ASL	R3		; BECAUSE WE JUST
	ROL	R2		;  THE FRACTION WORDS
	BCC	10$		;WAIT FOR A SHIFTED OUT BIT...
.IF	EQ	FLTLEN-4
	MOVB	R3,1(R1)	;SAVE LOWEST ORDER FRACTION
.ENDC	;EQ	FLTLEN-4
	CLRB	R3		;	A/B	C/0
	BISB	R2,R3		;	A/B	C/B
	SWAB	R3		;	A/B	B/C
	CLRB	R2		;	A/0	B/C
	BISB	R0,R2		;	A/EXP	B/C
	SWAB	R2		;	EXP/A	B/C
	ROL	R0		;LOAD C-BIT WITH SIGN
	ROR	R2		;INSERT CORRECT SIGN
	ROR	R3		; AND SHIFT
.IF	EQ	FLTLEN-4
	ROR	(R1)		;  AND INTO LOWEST...
.ENDC	;EQ	FLTLEN-4
20$:	MOV	R3,-(R1)	;SET NEXT WORD
	MOV	R2,-(R1)	;SET HIGHEST WORD AND EXPONENT
	RETURN			;NOW EXIT
.IFF
	MOV	R3,-(R1)	;SAVE NUMBER
	MOV	R2,-(R1)
	FLTCLR	-(R1)
	CLR	-(R1)
	MOV	#100000,-(R1)	;ADJUSTMENT FOR 0<NUM<1.
	FLTCLR	-(R1)
	JMP	DIVF		;DIVIDE AND EXIT
.ENDC	;EQ	.MATH.

RANDOM:	MOV	SPDA,R4		;GET A DATA AREA POINTER
	.DATE			;GET TIME -- THIS IS NOT A GOOD ALGORITHM
	MOV	XRB+4,R3	;PUT TIME VALUE INTO ODD REGISTER
	MUL	#10,R3		;NOW TIMES 10(8) FOR RANDOMNESS
	ADD	R3,RNDML(R4)	;UPDATE THE RANDOM NUMBER SEED
RNDRTS:	RTS	PC		;AND RETURN

TIME01:	.TIME			;GET TIMING DATA
	DEC	R2		;MAKE 1, 2, 3, 4 INTO 0, 1, 2, 3
	ASL	R2		;MAKE 0, 1, 2, 3 INTO 0, 2, 4, 6
	BIC	#^C<6>,R2	;ENSURE RANGE
	MOV	XRB(R2),-(R1)	;MOVE LSB OF ANSWER ONTO R1 STACK AS INTEGER
	CLR	-(R1)		; AND GUESS AT MSB OF ZERO
	BIT	R2,#2		;WAS IT 2(CON) OR 6(DEV)??
	BNE	CNV2IF		;YES, SO JUST FLOAT IT AND EXIT
	MOV	XRB+10(R2),(R1)	;NO, SO SET MSB OF 0(CPU) OR 4(KCT'S)
CNV2IF::			;CONVERT DOUBLE INTEGER INTO FLOATER
.IF	EQ	.MATH.
	MOV	(R1)+,R2	;SET MSB
	MOV	(R1)+,R3	; AND LSB
	MOV	#240+1,R0	;SET (BIASED) EXPONENT & POSITIVE
	BR	NORMSC		;DO NORMALIZE AND SCALING IF NEEDED
.IFF
	CLR	-(SP)		;ENSURE NUMBER STAYS POSITIVE
	BR	FLT.02		;NOW GO FLOAT IT
.ENDC	;EQ	.MATH.

TIMEF:	JSR	R5,INTFAI	;DEMAND ONE INTEGER ARGUMENT
	MOV	(R1)+,R2	;POP IF OFF
	BNE	TIME01		;BRANCH IF NOT 0
	.DATE			;GET TIME INTO XRB+XRBC AND XRB+XRLOC(BYTE)
	.IF	NDF	FPV
	MOV	#60.,-(R1)	;NUMBER OF MINUTES IN AN HOUR
	JSR	PC,FLT		;FLOAT IT
	MOV	#1440.,-(R1)	;NUMBER OF MINUTES IN A DAY
	SUB	XRB+XRBC,(R1)	;SEE HOW MANY LEFT
	JSR	PC,FLT		;FLOAT FOR MULTIPLYING
	.IF	NDF	DECMAP
	JSR	PC,MULF		;MAKE INTO SECONDS
	.IFF
	JSR	PC,MULF.S	;MAKE INTO SECONDS
	.ENDC
	MOV	#60.,-(R1)	;SECONDS IN A MINUTE
	CLR	-(R1)		;MAKE FOR A FUNNY MOVB
	MOVB	XRB+XRLOC,(R1)	;SECONDS TILL NEXT MINUTE
	SUB	(R1)+,(R1)	;AND MAKE FROM INSTEAD OF TO
	JSR	PC,FLT		;FLOAT FOR ADDING
	BR	ADDF		;AND AWAY WE GO
	.ENDC
	.IF	DF	FPV
	SETI
	.IF	EQ	FLTLEN-4
	SETD
	LDCID	#60.,F0		;NUMBER OF MINUTES IN AN HOUR
	MOV	#1440.,-(R1)	;NUMBER OF MINUTES IN A DAY
	SUB	XRB+XRBC,(R1)	;SEE HOW MANY LEFT
	LDCID	(R1)+,F1	;CONVERT FOR MULTIPLYING
	MULD	F0,F1		;MAKE INTO SECONDS
	MOV	#60.,-(R1)	;SECONDS IN A MINUTE
	CLR	-(R1)		;MAKE FOR A FUNNY MOVB
	MOVB	XRB+XRLOC,(R1)	;SECONDS TILL NEXT MINUTE
	SUB	(R1)+,(R1)	;AND MAKE FROM INSTEAD OF TO
	LDCID	(R1)+,F0	;CONVERT FOR ADDING
	ADDD	F0,F1		;ADD
	.IF	DF	DECMAP
	MOV	SCAFAC,R0	;GET SCALING POINTER
	BEQ	1$		;NONE
	MULD	(R0),F1		;ONE
1$:
	.ENDC
	STD	F1,-(R1)	;AND STORE ON R1
	RTS	PC		;RETURN
	.ENDC
	.IF	NE	FLTLEN-4
	SETF
	LDCIF	#60.,F0		;NUMBER OF MINUTES IN AN HOUR
	MOV	#1440.,-(R1)	;NUMBER OF MINUTES IN A DAY
	SUB	XRB+XRBC,(R1)	;SEE HOW MANY LEFT
	LDCIF	(R1)+,F1	;CONVERT FOR MULTIPLYING
	MULF	F0,F1		;MAKE INTO SECONDS
	MOV	#60.,-(R1)	;SECONDS IN A MINUTE
	CLR	-(R1)		;MAKE FOR A FUNNY MOVB
	MOVB	XRB+XRLOC,(R1)	;SECONDS TILL NEXT MINUTE
	SUB	(R1)+,(R1)	;AND MAKE FROM INSTEAD OF TO
	LDCIF	(R1)+,F0	;CONVERT FOR ADDING
	ADDF	F0,F1		;ADD
	.IF	DF	DECMAP
	MOV	SCAFAC,R0	;GET SCALING POINTER
	BEQ	1$		;NONE
	MULF	(R0),F1		;ONE
1$:
	.ENDC
	STF	F1,-(R1)	;AND STORE ON R1
	RTS	PC		;RETURN
	.ENDC
	.ENDC

	DEFORG	DM
.SBTTL	DECIMAL (SCALING) MATH ROUTINES
.IF	DF	DECMAP

; FUNCTION ENTER

.ENABL	LSB

DSCTST:	JSR	R5,INTFAF	;GET A FLOATING ARG
	MOV	SCAFAC,R0	;GET SCALING POINTER
	.IF	DF	FPU
	BEQ	1$		;NONE
	SETD
	LDD	(R1),F0		;GET ARG
	DIVD	(R0),F0		;AND CORRECT IT
	STD	F0,(R1)		;RESTORE ARG
	.IFF
	BNE	1$		;ONE
	RTS	PC		;NONE

1$:	JSR	PC,DIVFR0	;DIVIDE BY CORRECTION
	.IFTF
	JSR	PC,@(SP)+	;CALL FUNCTION AS CO-ROUTINE
DSCDNE:
	.IFT
SCACR1:	SETD
	LDD	(R1),F0		;GET RESULT
	MULD	@SCAFAC,F0	;CORRECT RESULT
SCAFIX:	MODD	#1.0,F0		;GET INTEGER PART
	STD	F1,(R1)		;AND STORE IT ON R1 STACK
1$:	RTS	PC
	.IFF
SCACR1:	JSR	PC,MULFSC	;CORRECT RESULT
	JMP	SCAFIX		;GET INTEGER PART
	.ENDC

.DSABL	LSB

;ROUTINE TO PROCESS SCALE COMMAND, WITH OR WITHOUT ARG

SCAMAX	=	6.		;MAX VALUE = 6. IF SCALING
	.IFF
SCAMAX	=	0.		;MAX VALUE = 0. IF NO SCALING
	.IFTF
DOSCAL:	JSR	PC,GUSINT	;GET A NON-NEGATIVE INTEGER
	BNE	10$		;NO INTEGER THERE FOR US
	MOV	(R1)+,-(SP)	;SAVE SCALE FACTOR ON SP STACK
	JSR	PC,TLGENP	;IS NEXT EOL?
99$:	ERROR	SASYNE,FATAL	;NO IS ERROR
	CMP	(SP),#SCAMAX	;IS SCALE FACTOR LEGAL ??
	.IFT
	BHI	99$		;NOPE, ERROR
	.IFF
	BLOS	88$		;YEP (IT IS A 0)
	ERROR	ERRERR,FATAL	;NO SCALING
88$:
	.IFTF
	MOVB	(SP)+,SCAVAL	;YEP, SO SET NEW FACTOR
5$:	JMP	EDCTLH		;AND EXIT TO EDITOR AGAIN

10$:	JSR	PC,TLENDP	;IS THIS EOL?
	BR	99$		;NO IS AN ERROR
	CMP	TOKA(R0),#ENDOL	;YES, BUT IS IT ":"?
	BNE	99$		;THIS COMMAND MUST END WITH REAL EOL
	CLR	-(R1)		;GET USER SETTABLE SCALE FACTOR
	MOVB	SCAVAL,(R1)	; ONTO THE R1 STACK
	JSR	PC,LENNUM	;NOW PRINT IT WITH NO SPACES ON CH #0
	.IFT
	MOVB	SCAUPV,R4	;NOW GET PROGRAM'S SCALE FACTOR VALUE
	CMPB	R4,SCAVAL	;DO SCALE FACTORS MATCH?
	BEQ	20$		;YES
	CALL	PRINTX,R3,<',>	;NO, SEPARATE THEM WITH A COMMA
	MOV	R4,-(R1)	;NOW SET PROGRAM'S SCALE VALUE
	JSR	PC,LENNUM	; AND PRINT WITH NO SPACES
20$:
	.IFTF
	JSR	PC,CRLF		;FINALLY RESTORE THE CARRIAGE
	BR	5$		;AND EXIT

.SBTTL	SCALING SET UP

SCAINI:	CMP	R2,#SCAMAX	;IS USER PROGRAM SCALE FACTOR LEGAL?
	BLOS	10$		;YES
	CLR	R2		;NO, QUIETLY RESET IT TO 0 !!!
10$:	MOVB	R2,SCAUPV	;SET USER PROGRAM SCALE FACTOR
	.IFT
	ASH	#4,R2		;SCALE TIMES 16. FOR TABLE OFFSET
	.IFTF
	MOV	R2,SCAFAC	;SET SCALING POINTER
	.IFT
	BEQ	1$		;NO SCALING, LEAVE POINTER=0
	ADD	#SCATAB+<4*2>,SCAFAC;SCALING, MAKE PTR ABS TO "ONE"
1$:
	.ENDC
	RTS	R5		;NOW EXIT

SCASUP:	.IF	NE	.MATH.
	DECB	(R1)+		;MUST = .MATH. (WHICH = 1)
	BEQ	20$		;O.K.
	.ENDC
	.IF	EQ	.MATH.
	.IF	NDF	DECMAP
	TSTB	(R1)+		;CHECK SCALING FACTOR
	BEQ	20$		;=0 IS O.K.
	.IFF
	MOVB	(R1)+,R2	;GET SCALING FACTOR
	NEG	R2		;IT IS STORED NEGATIVE...
	BGE	SCAINI		;O.K. IF >=0 NOW
	.ENDC
	.ENDC
	TST	(R5)+		;TAKE ERROR EXIT
20$:	RTS	R5		;TAKE O.K. EXIT

	ORG	MA

.SBTTL	MATH INITIALIZE AND EXCEPTION TRAPS

	TMPORG	MI
MI:
.IF	DF	FPU
	MOV	#JFFPP,XRB	;ASK FOR FPP CONTEXT
	.SET			; SWITCHING BY MONITOR
	MOV	#7400,R2	;GET FPU BIT PATTERN
	LDFPS	R2		; AND INIT THE FPU
MI.BAD::			;REFERENCE FOR RESERVED INSTRUCTION TRAPS
.IFF
.IF	DF	FIS
	MOV	#NSTORG+10,R2	;POINT TO A DUMMY REGION
	CLR	-(R2)		;DUMMY 2 ARGS
	CLR	-(R2)
	CLR	-(R2)
	CLR	-(R2)
	FADD	R2		;DO A TRIAL ADDITION
MI.BAD::			;REFERENCE FOR RESERVED INSTRUCTION TRAPS
.IFF
MI.BAD	==	0		;NO RESERVED INSTRUCTION(S) SHOULD OCCUR
.ENDC
.ENDC
	RTS	PC
	UNORG

.IF	NDF	FIS
FIS.IN:
.GLOBL	FIS.IN
.ENDC
.IF	NDF	FPU
FPP.IN:
.GLOBL	FPP.IN
.ENDC
	CLR	R3
	CLR	R5
XXX.IN:	.ERLOG			;LOG AN EXCEPTIONAL EXCEPTION TRAP
	SETERR	FLTERR		;SET ERROR AS FLOATING POINT ERROR
	JMP	FUCERR		;BUT CALL IT FATAL

.GLOBL	FUCERR

