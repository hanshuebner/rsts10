TITLE	XCMA4,<MATH MODULE>,08,13-MAY-86,TGE/LD/MHB/TPH

;                   Copyright 1974,1990 by Digital Equipment Corporation
;                                  All rights reserved.
;
;          This software is furnished under a license and may be used and copied
;          only  in  accordance  with  the  terms  of  such license and with the
;          inclusion of the above copyright notice.  This software or any copies
;          shall not be provided to any other person.   No title to or ownership
;          of the software is hereby transferred.
;
;          The information in this software is subject to change without notice.
;
;          DIGITAL  assumes  no  responsibility  for the  use, functionality, or
;          reliability of its  software  on equipment  which  is not supplied by
;          DIGITAL.

.SBTTL	4-WD FL-PT ADD,SUB,MUL,DIV,CMP, AND CONVERSION ROUTINES

	ORG	MA

;FL-PT TRAP-HANDLING ROUTINE

;FPP.IN ENTRY:
;	SP	FEC
;		FEA
;		PC
;		PS
;
.IF	DF	FPU
FPP.IN:
.GLOBL	FPP.IN
	MOV	R3,-(SP)	;SAVE R3 AND
	MOV	R5,-(SP)	; R5 ALSO
	MOV	4(SP),R3	;GET FEC
	MOV	6(SP),R5	; AND FEA ALSO
	BIT	R3,#-16-1	;IS FEC A LEGAL CODE??
	BNE	XXX.IN		;NOPE
	ADD	R3,PC		;YEP, SO INDEX ON IT
	BR	XXX.IN		; 0, UNUSED ON PDP-11/45
	BR	XXX.IN		; 2, FL. OP CODE ERROR
	BR	FPIDV0		; 4, DIVIDE BY 0
	BR	FPIICE		; 6, INTEGER CONVERSION ERROR
	BR	FPIFLO		;10, OVERFLOW
	BR	FPIFLO		;12, UNDERFLOW
	BR	FPICLR		;14, UNDEFINED VARIABLE
	BR	XXX.IN		;16, MAINT. TRAP

FPIICE:	POST,	PSTFIX		;POST ERROR
FPIEXT:	MOV	(SP)+,R5	;RESTORE R5 AND
	MOV	(SP)+,R3	; R3 ALSO
	CMP	(SP)+,(SP)+	;KNOCK OFF FEC,FEA
	RTI			;AND EXIT

FPIDV0:	POST,	PSTDV0		;POST ERROR
FPICLR:	MOV	(R5),R5		;GET INSTRUCTION IN ERROR
	ASH	#-4,R5		;SHIFT RIGHT 4 FOR
	BIC	#-14-1,R5	;FOR F0, F1, F2, OR F3 (0, 4, 10, OR 14)
	ADD	R5,PC		;NOW INDEX
	CLRF	F0		;F0<-0
	BR	FPIEXT
	CLRF	F1		;F1<-0
	BR	FPIEXT
	CLRF	F2		;F2<-0
	BR	FPIEXT
	CLRF	F3		;F3<-0
	BR	FPIEXT

FPIFLO:	POST,	PSTFLT		;POST ERROR
	BR	FPICLR		;AND ZERO A REGISTER
	.ENDC

;	FLT	THE FLOAT ROUTINE
;	CALLING SEQUENCE:
;	CALLED WITH AN INTEGER ON THE R1 STACK
;		JSR	PC,FLT
;		(RETURN)
;	RETURNS WITH THE INTEGER CONVERTED TO A FLOATING POINT NUMBER
;	ON THE R1 STACK.
;
;	$IR	IS THE TWO-WORD POLISH VERSION OF THE FLT ROUTINE
;	$ID	IS THE FOUR-WORD POLISH VERSION OF THE FLT ROUTINE
;
FLT:				;CONVERT INTEGER INTO FLOATER (SIGNED)
.IF	DF	FPU
	JSR	R4,$IR		;DO INTEGER INTO FLOATER
	.WORD	10$		;THEN RETURN
10$:
.IF	DF	DECMAP
	MOV	SCAFAC,R2	;GET SCALING POINTER
	BEQ	20$		;NO SCALING
	MULF	(R2),F0		;SCALING, SO DO IT
	STD	F0,(R1)		; AND REPLACE THE ANSWER
20$:
.ENDC	;DF	DECMAP
	MOV	(SP)+,R4	;RESTORE R4
	RETURN			; AND EXIT
.IFF
	MOV	R0,-(SP)	;SAVE R0
	JSR	R4,$IR		;DO INTEGER INTO FLOATER
.IF	DF	DECMAP
	.WORD	CHKSCL,$MLD
.IFTF
	.WORD	FIXTWO		;EXIT BY RESTORING R0 AND R4
.IFT

CHKSCL:	MOV	SCAFAC,R0	;GET SCALING POINTER
	BEQ	20$		;NO SCALING
	CALL	PUSHF2		;SCALING, PUSH THE FACTOR
10$:	JMP	@(R4)+		;EXIT

20$:	TST	(R4)+		;SKIP THE MULTIPLY
	JMP	@(R4)+		; AND CONTINUE

.ENDC	;DF	DECMAP
.ENDC	;DF	FPU

$IR:				;INTEGER INTO FLOATER
$ID:				; DITTO...
.IF	DF	FPU
.IF	EQ	FLTLEN-4
	SETD			;4-WORD
.IFF
	SETF			;2-WORD
.ENDC	;EQ	FLTLEN-4
	SETI			;SHORT INTEGERS
	LDCIF	(R1)+,F0	;CONVERT INTEGER INTO FLOATER
	STF	F0,-(R1)	; AND SAVE THE RESULT
.IFF
	MOV	R3,-(SP)	;SAVE R3
	MOV	#220+1*2,R0	;SET (BIASED) EXPONENT (DOUBLED FOR SIGN)
	CLR	R3		;LSB IS ZERO
	MOV	(R1)+,R2	;SET THE MSB FROM THE INTEGER
	BPL	10$		;POSITIVE OR ZERO, C-BIT=0 FROM 'CLR'
	NEG	R2		;NEGATIVE, CORRECT AND SET C-BIT=1
10$:	ROR	R0		;INSERT SIGN INTO BIASED EXPONENT
	CALL	NORMIT		;GO DO NORMALIZE
	MOV	(SP)+,R3	;RESTORE R3
.ENDC	;DF	FPU
	JMP	@(R4)+		;POLISH EXIT

;	ADDF	THE DOUBLE PRECISION ADD ROUTINE
;	CALLING SEQUENCE:
;	CALLED WITH THE TWO (4-WD FL-PT) ARGUMENTS ON THE R1 STACK
;		JSR	PC,ADDF
;		(RETURN)
;	RETURNS WITH THE SUM ON THE R1 STACK
;
;	SUBF	 THE DOUBLE PRECISION SUBTRACT ROUTINE
;	CALLING SEQUENCE:
;	CALLED WITH THE TWO (4-WD FL-PT) ARGUMENTS ON THE R1 STACK
;		JSR	PC,SUBF
;		(RETURN)
;	SUBTRACTS THE TOP ITEM FROM THE SECOND ITEM
;	AND RETURNS WITH THE DIFFERENCE ON THE R1 STACK
;
;	$ADD,$SBD ARE THE POLISH VERSIONS OF THE DOUBLE PRECISION
;	ADD AND SUBTRACT ROUTINES
;
	A1=0
	B1=2.
	C1=4.
	D1=6.
	A2=8.
	B2=10.
	C2=12.
	D2=14.
	SIGNS=0.
$SBD:	ADD	#100000,(R1)	;POLISH RSTS ENTRY
	BR	$ADD
SUBF:	ADD	#100000,(R1)	;NORMAL RSTS ENTRY
ADDF:	MOV	#RTSLOC,R4
$ADD:
	.IF	DF	FPU
	SETD
	LDD	(R1)+,F0	;GET OPERAND
	ADDD	(R1)+,F0	;ADD
	STD	F0,-(R1)	;SUM TO STACK
	JMP	@(R4)+
	.ENDC
	.IF	NDF	FPU
	MOV	R4,-(SP)
	MOV	R5,-(SP)
	CLR	-(SP)		;CLEAR SIGNS
	CLR	R4		;CLEAR EXPONENTS
	CLR	R5
	ADD	#8.,R1		;FIDDLE WITH R1 STACK POINTER
	MOV	R1,R2		;AND INTO R2 WITH IT
	ASL	-(R2)		;SHIFT OUT SIGN OF TOP ITEM
	ROL	-(R2)
	ROL	-(R2)		;SHIFT A1
	ROL	-(R2)		;SHIFT A2
	BISB	1(R2),R4	;GET E1
	BEQ	A1Z1		;JUMP IF ZERO
	ROLB	(SP)		;GET S1
	MOV	R2,R1		;THE REAL R1 STACK POINTER RETURNS
	ADD	#16.,R2		;NOW TO LOOK AT SECOND STACK ITEM
	ASL	-(R2)		;SHIFT OUT SIGN OF SECOND ITEM
	ROL	-(R2)
	ROL	-(R2)
	ROL	-(R2)
	BISB	1(R2),R5  	;GET E2
	BNE	A2NZ		;JUMP IF NOT 0
	MOV	R1,R2		;COPY STACK POINTER
	RORB	(SP)		;RECONSTRUCT A1
	ROR	(R2)+
	ROR	(R2)+
	ROR	(R2)+
	ROR	(R2)+
	MOV	(R1)+,(R2)+  	;FIRST ARG TO TOP OF STACK
	MOV	(R1)+,(R2)+
	MOV	(R1)+,(R2)+
	MOV	(R1)+,(R2)+
A1Z1:	TST	(SP)+		;FLUSH SIGNS
	JMP	OUT		;DONE

A2NZ:	ROLB	SIGNS+1(SP)   	;GET S2
	MOVB	#1,A2+1(R1)	;INSERT NORMAL BIT
	MOVB	#1,A1+1(R1)	;INSERT NORMAL BIT
	SUB	R4,R5		;R5=E2-E1, R4=E1
	BGT	EXPA		;JUMP IF E2>E1
	MOV	R1,R0		;POINT TO
	ADD	#D2,R0		; TOP OF SECOND NUMBER
	MOV	(R0),R3		;GET D2
	MOV	-(R0),R2	; AND C2
	MOV	-(R0),-(SP)	;STACK B2
	MOV	-(R0),-(SP)	; AND A2
	MOV	(R1)+,(R0)+	;MOVE ARG 1
	MOV	(R1)+,(R0)+	; ON TOP OF ARG2
	MOV	(R1)+,(R0)+	;  POPPING ARG2
	MOV	(R1)+,(R0)+	;   IN THE PROCESS
	MOV	(SP)+,R0	;RESTORE A2
	BR	SCHK		;GO CHECK SIGNS

EXPA:	ADD	R5,R4		;R5=E2-E1,R4=E2,E2>E1
	MOV	(R1)+,R0	;R0=A1
	MOV	(R1)+,-(SP)	;R1=B1
	MOV	(R1)+,R2
	MOV	(R1)+,R3
	SWAB	2(SP)		;EXCHANGE SIGNS
	NEG	R5		;E1-E2
SCHK:	MOV	(SP)+,-(R1)	;B2 OR B1 TO (R1)
	CMPB	SIGNS+1(SP),(SP)	;COMPARE SIGNS
	BEQ	ECHK		;THEY'RE THE SAME. CHECK EXPONENT
	JSR	PC,NG0123	;NEGATE OPERAND IN R0-R3
ECHK:	TST	R5		;CHECK EXPONENTS
	BEQ	SHFTD		;JUMP IF E1=E2
	CMP	#-57.,R5	;IS THERE ANY POINT IN SHIFTING?
	BLE	SHFTR		;YES
	MOV	A1+2(R1),R0	;ANSWER IS OPERAND WITH
	MOV	B1+2(R1),(R1)	;LARGER EXPONENT
	MOV	C1+2(R1),R2
	MOV	D1+2(R1),R3
	BR	NORMD

SHFTR:	CMP	#-8.,R5		;CHECK # OF BITS TO SHIFT
	BLE	SR8		;JUMP IF NOT MORE THAN 1/2 WORD
	TST	R0
	SXT	-(SP)		;EXTEND SIGN
SHFTR1:	CMP	#-16.,R5
	BLT	SR16		;JUMP IF NOT MORE THAN A WORD TO SHIFT
	MOV	R2,R3		;SHIFT A WORD AT A TIME
	MOV	(R1),R2
	MOV	R0,(R1)
	MOV	(SP),R0		;USE EXTENSION
	ADD	#16.,R5		;ADJUST EXPONENT
	BNE	SHFTR1		;TRY AGAIN
	TST	(SP)+		;POP EXTENSION
	BR	SHFTD		;SHIFT IS ALL DONE

SR16:	CMP	#-3,R5		;JUMP IF NOT MORE THAN 3 TO SHIFT
	BLE	SR8A
	MOV	R1,(SP)		;SAVE R1 STACK PTR
	MOV	(R1),R1
	MOV	R4,-(SP)	;SAVE EXP AND SHIFT COUNT
	MOV	R5,-(SP)
	MOV	R1,R4		;SAVE R1
	ASHC	R5,R0		;SHIFT HIGH ORDER
	MOV	R2,R5		;SAVE R2
	ASHC	(SP),R4		;SHIFT IT
	MOV	R2,R4
	MOV	R5,R2		;R2 DONE
	MOV	R3,R5		;SET UP LOW ORDER
	ASHC	(SP)+,R4	;DO LOW ORDER
	MOV	R5,R3
	MOV	(SP)+,R4	;RESTORE EXPONENT TO R4
	MOV	R1,@(SP)
	MOV	(SP)+,R1	;RESTORE R1 STACK PTR.
	BR	SHFTD

SR8A:	TST	(SP)+		;POP EXTENSION
SR8:	ASR	R0		;SHIFT RIGHT
	ROR	(R1)
	ROR	R2
	ROR	R3
	INC	R5		;COUNT LOOP
	BLT	SR8
SHFTD:	ADD	D1+2(R1),R3	;FORM THE SUM
	ADC	R2
	ADC	(R1)
	ADC	R0
	ADD	C1+2(R1),R2
	ADC	(R1)
	ADC	R0
	ADD	B1+2(R1),(R1)
	ADC	R0
	ADD	A1+2(R1),R0
	CMPB	SIGNS+1(SP),(SP)	;CHECK FOR UNEQUAL SIGNS
	BNE	SUB		;GO CLEAN UP SUBTRACT
	BIT	R0,#1000
	BEQ	NORMD		;JUMP IF NO NORMAL BIT OVERFLOW
	ASR	R0
	ROR	(R1)
	ROR	R2
	ROR	R3
	INC	R4		;INCREASE EXPONENT
NORMD:	SWAB	R4		;MOVE EXPONENT LEFT
	BNE	OVERF		;JUMP IF OVERFLOW
	BISB	R0,R4		;INSERT HIGH ORDER FRACTION
	ROR	(SP)+		;INSERT SIGN
	ROR	R4
	ROR	(R1)
	ROR	R2
	ROR	R3
	ADC	R3
	ADC	R2
	ADC	(R1)
	ADC	R4
	BVS	OVER7		;JUMP IF OVERFLOW ON ROUND
	BCS	OVER7
NFLOW:	MOV	R1,R5		;COPY POINTER TO R1 STACK
	TST	(R5)+		;BUMP OVER 1 WORD
	MOV	R4,(R5)+	;STORE EXPONENT AND SIGN
	MOV	(R1)+,(R5)+	;INSERT LOW ORDER FRACTION
	MOV	R2,(R5)+
	MOV	R3,(R5)+
OUT:	MOV	(SP)+,R5
	MOV	(SP)+,R4
	JMP	@(R4)+		;DONE. RETURN

UTEST:	TST	R4		;CHECK FOR UNDERFLOW
	BGT	NORMD
OVERF:	TST	(SP)+		;POP SIGN
OVER7:	POST,	PSTFLT
	CLR	(R1)		;UNDERFLOW AND OVERFLOW--TREAT AS 0
	CLR	R2
	CLR	R3
OVER8:	CLR	R4
	BR	NFLOW		;FINISH OUT NORMALLY

ZERO:	TST	(SP)+		;POP SIGN
	BR	OVER8

SUB:	TST	R0		;CHECK HIGH ORDER RESULT FRACTION
	BGT	BIT9		;IF POSITIVE SIGN IS OK
	BEQ	ZTEST		;CHECK FOR ZERO RESULT
	SWAB	(SP)		;EXCHANGE SIGNS
	JSR	PC,NG0123	;GET ABSOLUTE VALUE
	BNE	BIT9		;NON-ZERO RESULT
ZTEST:	SUB	#8.,R4		;REDUCE EXPONENT
	TST	(R1)
	BNE	ZT1		;JUMP IF ONLY R0=0
	SUB	#16.,R4
	MOV	R2,(R1)
	BNE	ZT2		;JUMP IF R2 NOT 0
	SUB	#16.,R4
	TST	R3
	BEQ	ZERO		;ANSWER IS 0
	BISB	R3,(R1)		;MOVE BYTES TO R0,(R1)
	SWAB	(R1)
	SWAB	R3
	BISB	R3,R0
	CLR	R3		;MAKE ALL OTHERS 0
BIT9:
BIT9A:	BIT	R0,#400		;CHECK NORMAL BIT
	BNE	UTEST		;JUMP IF FOUND
	DEC	R4		;DECREASE EXPONENT
	ASL	R3		;DOUBLE FRACTION
	ROL	R2
	ROL	(R1)
	ROL	R0
	BR	BIT9A		;TRY AGAIN

ZT2:	MOV	R3,R2		;SHIFT LEFT 16 BITS
	CLR	R3
ZT1:	SWAB	(R1)		;SHIFT R0/(R1)/R2/R3 LEFT 1 BYTE
	BISB	(R1),R0
	SWAB	R2
	MOVB	R2,(R1)
	SWAB	R2
	ASHC	#8.,R2
	BR	BIT9		;GO NORMALIZE WHAT'S LEFT

NG0123:	NEG	R3		;NEGATE OPERAND
	ADC	R2
	ADC	(R1)
	ADC	R0
	NEG	R2
	ADC	(R1)
	ADC	R0
	NEG	(R1)
	ADC	R0
	NEG	R0
	RTS	PC		;CONDITION CODES SET ON R0
	.ENDC

;	FIXF	THE FIXF FUNCTION
;	CALLING SEQUENCE:
;	CALLED WITH ARG (4-WORD FL-PT NO) ON THE R1 STACK
;		JSR	PC,FIXF
;		(RETURN)
;	RETURNS SIGN OF ARG * GREATEST REAL INTEGER <=ABS(ARG)
;	ON THE R1 STACK
;
;	$DINT	SAME FUNCTION AS FIXF, BUT CALLED
;	IN THE POLISH MODE WITH THE ARG AND RETURN ON THE STACK.
;
FIXF:	.IF	DF	DECMAP
	JSR	PC,DSCTST	;GET 'FAF' ARG AND CHECK FOR SCALING
	.IFF
	JSR	R5,INTFUN	;DEMAND A FLOATING ARG
	ARGS	FAF
	.ENDC
	.IF	DF	DECMAP
	.IF	NDF	FPU
SCAFIX:
	.ENDC
	.ENDC
FIXF1:	MOV	#RTSLOC,R4
$DINT:
	.IF	DF	FPU
	SETD
	LDD	(R1),F0		;LOAD ARG
	MODD	#1.0,F0		;GET INTEGER PART
	STD	F1,(R1)		;PUSH INTEGER
	JMP	@(R4)+		;RETURN TO CALLER
	.ENDC
	.IF	NDF	FPU
	MOV	R4,-(SP)
	MOV	R5,-(SP)
	MOV	(R1)+,R2	;SPREAD NUMBER OUT
	MOV	(R1)+,R3
	MOV	(R1)+,R4
	MOV	(R1)+,R5
	MOV	R1,-(SP)	;SAVE R1 STACK POINTER
	MOV	R2,R0		;GET EXPONENT
	ROL	R0
	CLRB	R0
	SWAB	R0
	SUB	#270,R0		;CONVERT TO -SHIFT COUNT
	BGE	DONE		;JUMP IF ARG MUST BE INTEGER ALREADY
	CMP	#-70,R0
	BLT	SHIFT		;JUMP TO GET INTEGER PART
	CLR	R2		;ANSWER IS 0
	CLR	R3
C23:	CLR	R4
	CLR	R5
	BR	DONE

SHIFT:	CMP	#-32.,R0	;CHECK FOR HIGH OR LOW ORDER TRUNCATION
	BLT	R23		;LOW
	BEQ	C23		;CLEAR LOW ORDER
	ADD	#32.,R0		;HIGH ORDER PARTS
	ASHC	R0,R2		;SHIFT OUT FRACTION
	NEG	R0		;SET TO SHIFT LEFT
	ASHC	R0,R2		;BRING IN THE 0'S
	BR	C23		;GO CLEAR LOW ORDER

R23:	ASHC	R0,R4
	NEG	R0
	ASHC	R0,R4		;SHIFT IN 0'S
DONE:	MOV	(SP)+,R1	;RESTORE R1 STACK POINTER
	MOV	R5,-(R1)	;PUSH RESULT
	MOV	R4,-(R1)
	MOV	R3,-(R1)
	MOV	R2,-(R1)
	MOV	(SP)+,R5
	MOV	(SP)+,R4
	JMP	@(R4)+		;RETURN
	.ENDC

;	MULF     THE DOUBLE MULTIPLY ROUTINE
;	CALLING SEQUENCE:
;	CALLED WITH THE TWO (4-WD FL-PT) ARGUMENTS ON THE R1 STACK
;		JSR	PC,MULF
;		(RETURN)
;	RETURNS WITH THE PRODUCT ON THE R1 STACK
;
;	$MLD IS THE POLISH VERSION OF THE DOUBLE PRECISION
;	MULTIPLY ROUTINE
;
	A=2
	B=10.
	RESLT=12.
	SIGN=2
	.IF	DF	DECMAP
MULF.S:
	.IF	DF	FPU
	SETD
	LDD	(R1)+,F0	;GET ONE OPERAND
	MULD	(R1),F0		;AND MULTIPLY BY OTHER
	MOV	SCAFAC,R0	;GET SCALING POINTER
	BEQ	1$		;NONE
	DIVD	(R0),F0		;CORRECT ANSWER
	JMP	SCAFIX		;FIX ANSWER
1$:	STD	F0,(R1)		;STORE ANSWER
	RTS	PC
	.IFF
	TST	SCAFAC		;SCALING?
	BEQ	MULF		;NOPE
	JSR	PC,MULF		;YEP, MULTIPLY FIRST
	JSR	PC,DIVFSC	;DIVIDE BY SCALING FACTOR
	BR	SCAFIX		;NOW FIX RESULT

MULFSC:	MOV	SCAFAC,R0	;GET SCALING POINTER
	.ENDC
	.ENDC
MULFR0:	JSR	PC,PUSHF2	;PUSH VIA R0
MULF:	MOV	#RTSLOC,R4
$MLD:
	.IF	DF	FPU
	SETD
	LDD	(R1)+,F0	;GET OPERAND
	MULD	(R1)+,F0	;PRODUCT
	STD	F0,-(R1)	;PRODUCT TO STACK
	JMP	@(R4)+
	.ENDC
	.IF	NDF	FPU
	MOV	R4,-(SP)
	MOV	R5,-(SP)
	ASL	(R1)		;SHIFT MULTIPLICAND
	BEQ	ZERO1		;JUMP IF ANSWER IS ZERO
	ROL	-(SP)		;KEEP SIGN
	CLR	-(SP)		;CLEAR EXPONENT
	SWAB	(R1)		;EXPONENT TO LOW BYTE
	MOVB	(R1)+,(SP)	;SAVE EXPONENT ON STACK
	SEC			;INSERT NORMALIZATION BIT
	RORB	(R1)+		; IN HIGH ORDER FRACTION
	SWAB	(R1)		;SWAP BYTES 2/3
	MOVB	(R1)+,-3(R1)	;SHIFT DOWN
	INC	R1		;SKIP BYTE SHIFTED BY SWAB
	SWAB	(R1)		;SWAP BYTES 4/5
	MOVB	(R1)+,-3(R1)
	INC	R1
	SWAB	(R1)		;SWAP BYTES 6/7
	MOVB	(R1),-2(R1)	;SHIFT A BYTE
	CLRB	(R1)		;SHIFT ZEROS INTO LOW ORDER FRACTION
	SUB	#6,R1		;CORRECT R1
	ASL	B-2(R1)		;SHIFT HIGH MULTIPLIER
	BNE	NONZ		;JUMP IF NOT ZERO
	CMP	(SP)+,(SP)+	;FLUSH SIGN AND EXPONENT
ZERO1:	JMP	ZERO2

NONZ:	ADC	SIGN(SP)	;GET PRODUCT SIGN
	CLR	R0		;CLEAR PRODUCT
	CLR	-(R1)
	MOV	R1,R3		;COPY STACK POINTER
	ADD	#B+1,R3		;POINT TO EXPONENT OF 2ND NUMBER
	CLR	R4		;CLEAR FOR BISB
	BISB	(R3),R4		;GET EXPONENT OF ARG2
	ADD	R4,(SP)		;COMPUTE SUM OF EXPONENTS ON STACK
	SEC			;INSERT NORMALIZATION BIT
	RORB	-(R3)		; IN HIGH ORDER FRACTION BYTE
	SWAB	(R3)+		;SHIFT EVERYTHING
	SWAB	(R3)
	MOVB	(R3)+,B(R1)
	INC	R3
	SWAB	(R3)
	MOVB	(R3)+,B+2(R1)
	INC	R3
	SWAB	(R3)
	MOVB	(R3),B+4(R1)
	CLRB	(R3)		;SHIFT ZEROS INTO LOW ORDER
	MOV	A(R1),-(SP)
	MOV	(R3),R4		;GET A1*B4
	JSR	PC,EMULT
	MOV	R4,R2		;RESULT TO PRODUCT
	MOV	-(R3),R4	;GET B+4
	MOV	R5,R3
	MOV	A+2(R1),-(SP)
	JSR	PC,EMULT	;GET A2*B3
	ADD	R4,R2		;ADD TO PRODUCT
	ADC	(R1)
	ADD	R5,R3
	ADC	R2
	ADC	(R1)
	MOV	A+4(R1),-(SP)
	MOV	B+2(R1),R4	;GET A3*B2
	JSR	PC,EMULT
	ADD	R4,R2
	ADC	(R1)
	ADD	R5,R3
	ADC	R2
	ADC	(R1)
	MOV	A+6(R1),-(SP)
	MOV	B(R1),R4	;GET A4*B1
	JSR	PC,EMULT
	ADD	R4,R2
	ADC	(R1)
	ADD	R5,R3
	ADC	R2
	ADC	(R1)
	MOV	R2,R3		;DIVIDE BY 2**16
	MOV	(R1),R2
	CLR	(R1)
	MOV	A(R1),-(SP)
	MOV	B+4(R1),R4	;GET A1*B3
	JSR	PC,EMULT
	ADD	R4,R2
	ADC	(R1)
	ADD	R5,R3
	ADC	R2
	ADC	(R1)
	MOV	A+2(R1),-(SP)
	MOV	B+2(R1),R4	;GET A2*B2
	JSR	PC,EMULT
	ADD	R4,R2
	ADC	(R1)
	ADD	R5,R3
	ADC	R2
	ADC	(R1)
	MOV	A+4(R1),-(SP)
	MOV	B(R1),R4	;GET A3*B1
	JSR	PC,EMULT
	ADD	R4,R2
	ADC	(R1)
	ADD	R5,R3
	ADC	R2
	ADC	(R1)
	MOV	A(R1),-(SP)
	MOV	B+2(R1),R4	;GET A1*B2
	JSR	PC,EMULT
	ADD	R4,(R1)
	ADC	R0
	ADD	R5,R2
	ADC	(R1)
	ADC	R0
	MOV	A+2(R1),-(SP)
	MOV	B(R1),R4	;GET A2*B1
	JSR	PC,EMULT
	ADD	R4,(R1)
	ADC	R0
	ADD	R5,R2
	ADC	(R1)
	ADC	R0
	MOV	A(R1),-(SP)
	MOV	B(R1),R4	;GET A1*B1
	JSR	PC,EMULT
	ADD	R4,R0
	ADD	R5,(R1)
	ADC	R0
	MOV	(SP)+,R4	;GET SUM OF EXPONENTS
	ASL	R3		;SHIFT OUT NORMAL BIT
	ROL	R2
	ROL	(R1)
	ROL	R0
	BCS	NORM		;JUMP IF IT WAS FOUND
	ASL	R3
	ROL	R2
	ROL	(R1)
	ROL	R0		;MUST HAVE GOT IT NOW
	DEC	R4		;ADJUST EXPONENT
NORM:	SUB	#200,R4		;TAKE OUT ONE OF THE EXCESS 128'S
	BLE	UNDER1		;JUMP IF UNDERFLOW
	CMP	#377,R4
	BLT	OVER2		;JUMP IF OVERFLOW
	CLRB	R3
	BISB	R2,R3		;SHIFT FRACTION RIGHT
	SWAB	R3
	CLRB	R2
	BISB	(R1),R2
	SWAB	R2
	CLRB	(R1)
	BISB	R0,(R1)
	SWAB	(R1)
	CLRB	R0
	BISB	R4,R0
	SWAB	R0
	ROR	(SP)+		;GET PRODUCT SIGN
	ROR	R0		;INSERT IT IN RESULT
	ROR	(R1)
	ROR	R2
	ROR	R3
	ADC	R3		;ROUND RESULT
	ADC	R2
	ADC	(R1)
	ADC	R0
	BCS	OVER1		;JUMP IF OVERFLOW ON ROUND
	BVS	OVER1
OUT2:	MOV	(R1)+,-(SP)	;TEMP SAVE OF (R1)
	ADD	#16.,R1		;POP ARGUMENTS
	MOV	R3,-(R1)	;PUSH RESULT
	MOV	R2,-(R1)
	MOV	(SP)+,-(R1)
	MOV	R0,-(R1)
	MOV	(SP)+,R5
	MOV	(SP)+,R4
	JMP	@(R4)+		;RETURN
OVER1:	TST	-(SP)		;FAKE SIGN
OVER2:
UNDER1:	POST,	PSTFLT		;UNDER OR OVERFLOW
	CMP	(SP)+,(R1)+	;FLUSH SIGN AND EXTRA WORD IN R1
ZERO2:	CLR	R0		;CLEAR HIGH ORDER RESULT
	CLR	-(R1)		;CLEAR LOW ORDER
	CLR	R2
	CLR	R3
	BR	OUT2

.ENABL	LSB

EMULT:	CLR	-(SP)		;CLEAR HIGH PRODUCT
	TST	R4		;TEST MULTIPLICAND
	BEQ	60$		;JUMP IF 0
	BGT	50$		;+
	TST	4(SP)		;TEST MULTIPLIER
	BEQ	60$		;JUMP IF 0
	BGT	20$		;+
10$:	ADD	R4,(SP)		;BOTH -
20$:	ADD	4(SP),(SP)	;MULTIPLICAND -
30$:	MUL	4(SP),R4	;GET PRODUCT
40$:	ADD	(SP)+,R4	;ADD IN HIGH ORDER PARTS
	MOV	(SP)+,(SP)	;FLUSH MULTIPLIER
	RTS	PC		;RETURN

50$:	TST	4(SP)		;TEST MULTIPLIER
	BEQ	60$		;JUMP IF 0
	BGT	30$		;+
	ADD	R4,(SP)		;MULTIPLIER -
	BR	30$

60$:	CLR	R4		;EITHER 0, RESULT IS 0
	CLR	R5
	BR	40$

.DSABL	LSB
	.ENDC

;	DIVF	THE DOUBLE DIVIDE ROUTINE
;	CALLING SEQUENCE:
;	CALLED WITH THE TWO (4-WD FL-PT) ARGUMENTS ON THE R1 STACK
;	THE NUMERATOR IS THE SECOND ITEM ON THE STACK
;	AND THE DENOMINATOR IS ON TOP.
;		JSR	PC,DIVF
;		(RETURN)
;	RETURNS WITH THE QUOTIENT ON THE R1 STACK
;
;	$DVD IS THE POLISH VERSION OF THE DOUBLE PRECISION
;	DIVIDE ROUTINE
;
	D=0.
	NN=8.
	Q=8.
	.IF	DF	DECMAP
DIVF.S:	MOV	SCAFAC,R0	;GET SCALING POINTER
	BEQ	DIVF		;NONE
	.IF	DF	FPU
	SETD
	LDD	(R1)+,F1	;SAVE DIVISOR
	LDD	(R1),F0		;GET DIVIDEND
	MULD	(R0),F0		;SCALE DIVIDEND
	DIVD	F1,F0		;NOW DIVIDE
	JMP	SCAFIX		;THEN FIX RESULT
	.IFF
	MOVFLT	(R1)+,-(SP)	;SAVE DIVISOR
	JSR	PC,MULFR0	;CORRECT DIVIDEND
	MOVFLT	(SP)+,-(R1)	;RESTORE DIVISOR
	JSR	PC,DIVF		;NOW DIVIDE
	JMP	SCAFIX		;AND FIX RESULT

DIVFSC:	MOV	SCAFAC,R0	;GET SCALING POINTER
DIVFR0:	JSR	PC,PUSHF2	;PUSH VIA R0
	.ENDC
	.ENDC
DIVF:	MOV	#RTSLOC,R4	;SET RETURN FOR DOS CONVENTION
$DVD:
	.IF	DF	FPU
	SETD
	LDD	(R1)+,F1	;GET DIVISOR
	LDD	(R1)+,F0	;GET DIVIDEND
	DIVD	F1,F0		;GET QUOTIENT
	STD	F0,-(R1)	;TO STACK
	JMP	@(R4)+
	.ENDC
	.IF	NDF	FPU
	MOV	R4,-(SP)
	MOV	R5,-(SP)
	CLR	R2
	CLR	R3
	CLR	R4
	CLR	R5
	CLR	-(SP)
	ASL	NN+0(R1)	;SHIFT NUMERATOR
	ROL	(SP)		;GET NUMERATOR SIGN
	CLR	-(SP)
	TST	(R1)		;CHECK FOR DIVISION BY 0
	BEQ	DCHK		;AND IT IS TOO
	BISB	NN+1(R1),(SP)	;GET NUMERATOR EXPONENT
	BEQ	ZERO3		;JUMP IF NUMERATOR IS ZERO
	BISB	NN(R1),R2
	SWAB	R2		;LEFT JUSTIFY NUMERATOR FRACTION
	SEC			;INSERT NORMAL BIT
	ROR	R2
	ADD	#NN+2,R1	;POINT TO NUMERATOR FRACTION
	BISB	(R1)+,R3
	BISB	(R1)+,R2
	SWAB	R3
	BISB	(R1)+,R4
	BISB	(R1)+,R3
	SWAB	R4
	BISB	(R1)+,R5
	BISB	(R1)+,R4
	SWAB	R5
	SUB	#NN+8.,R1
	ASL	(R1)+		;SHIFT DENOMINATOR
	ADC	2(SP)		;GET RESULT SIGN
	CLR	R0
	BISB	-(R1),R0	;GET DIVISOR EXPONENT
	SUB	R0,(SP)		;SUBTRACT EXPONENTS
	SEC			;INSERT NORMAL BIT
	RORB	-(R1)		; IN HIGH ORDER FRACTION
	SWAB	(R1)+		;SHIFT THE FRACTION
	SWAB	(R1)
	MOVB	(R1)+,-3(R1)
	INC	R1
	SWAB	(R1)
	MOVB	(R1)+,-3(R1)
	INC	R1
	SWAB	(R1)
	MOVB	(R1),-2(R1)
	CLRB	(R1)+
	INC	R1
	CLR	(R1)+		;CLEAR QUOTIENT
	CLR	(R1)+
	CLR	(R1)+
	SUB	#Q+6,R1		;RESTORE R1 STACK POINTER
	CMP	R2,(R1)		;COMPARE HIGH NUM. AND DEN.
	BHI	DLOW		;JUMP IF DENOMINATOR LOW
	BLO	DHI		;JUMP IF DENOMINATOR HIGH
	CMP	R3,D+2(R1)	;COMPARE LOW ORDER PARTS
	BHI	DLOW
	BLO	DHI
	CMP	R4,D+4(R1)
	BHI	DLOW
	BLO	DHI
	CMP	R5,D+6(R1)
	BHI	DLOW
	BNE	DHI
	INC	(SP)		;BUMP EXPONENT
	CLR	R0
	BR	FLOATG

DCHK:	POST,	PSTDV0		;DIVISION BY ZERO
	BR	ZERO3

UNDER2:	POST,	PSTFLT		;UNDER OR OVERFLOW
ZERO3:	CMP	(SP)+,(SP)+	;FLUSH EXP AND SIGN
OVER6:	MOV	R1,R2		;MAKE RESULT 0
	ADD	#8.,R2
	CLR	(R2)+
	CLR	(R2)+
	CLR	(R2)+
	CLR	(R2)+
	BR	RTN

DLOW:	ROR	R2		;HALVE DENOMINATOR  (C=0)
	ROR	R3		;TO ENSURE THAT N<D
	ROR	R4
	ROR	R5
	INC	(SP)		;COMPENSATE EXPONENT
DHI:	MOV	#9.,-(SP)	;GO DO FIRST 9 QUOTIENT BITS
	JSR	PC,DIV1
	MOVB	R0,Q(R1)	;SAVE ALL HIGH ORDER Q FRACTION
				;EXCEPT NORMAL BIT
	TST	(SP)		;SEE IF DONE
	BNE	FLOAT1		;YES, REST OF NUMERATOR IS 0
	MOV	#16.,(SP)	;GO DO 16 MORE BITS
	JSR	PC,DIV1
	MOV	R0,Q+2(R1)
	TST	(SP)
	BNE	FLOAT1
	MOV	#16.,(SP)
	JSR	PC,DIV1
	MOV	R0,Q+4(R1)
	TST	(SP)
	BNE	FLOAT1
	MOV	#16.,(SP)
	JSR	PC,DIV1
	BR	FLOAT

FLOAT1:	CLR	R0		;CLEAR LOWEST ORDER QUOTIENT
FLOAT:	TST	(SP)+		;EXP.TO TOP OF SP
FLOATG:	ADD	#200,(SP)	;ADD IN EXCESS 200
	BLE	UNDER2		;UNDERFLOW
	MOVB	(SP),Q+1(R1)	;INSERT EXPONENT IN RESLT
	SWAB	(SP)		;CHECK HIGH PART OF EXPONENT
	BNE	UNDER2		;OVERFLOW IF NON-0
	TST	(SP)+		;POP EXP
	MOV	R1,R5		;COPY R1 STACK POINTER
	ADD	#Q,R5		;ADVANCE TO QUOTIENT AREA
	;CLC			;FROM ADD ABOVE
	ROR	(SP)+		;INSERT QUOTIENT SIGN
	ROR	(R5)+
	ROR	(R5)+
	ROR	(R5)+
	ROR	R0
	ADC	R0		;ROUND
	MOV	R0,(R5)		;SAVE LOW ORDER FRACTION
	ADC	-(R5)
	ADC	-(R5)
	ADC	-(R5)
	BCS	OVER6
	BVS	OVER6
RTN:	MOV	(SP)+,R5
	MOV	(SP)+,R4
	ADD	#8.,R1		;FLUSH FIRST ARGUMENT
	JMP	@(R4)+

DIV1:	ASL	R0		;SHIFT QUOTIENT
	ASL	R5		;SHIFT NUMERATOR
	ROL	R4
	ROL	R3
	ROL	R2
	BCS	GO		;GUARANTEED TO GO
	CMP	(R1),R2		;COMPARE HIGH DIVISOR AND DIVIDEND
	BHI	NOGO		;JUMP IF DIVISOR BIGGER
	BLO	GO		;JUMP IF DIVISOR SMALLER
	CMP	D+2(R1),R3	;CHECK THE LOW ORDERS
	BHI	NOGO
	BLO	GO
	CMP	D+4(R1),R4
	BHI	NOGO
	BLO	GO
	CMP	D+6(R1),R5
	BHI	NOGO
	BEQ	NEQD		;JUMP IF NUMERATOR =DENOMINATOR
GO:	SUB	D+6(R1),R5	;N=N-D
	SBC	R4
	SBC	R3
	SBC	R2
	SUB	D+4(R1),R4
	SBC	R3
	SBC	R2
	SUB	D+2(R1),R3
	SBC	R2
	SUB	(R1),R2
	INC	R0		;INSERT QUOTIENT BIT
NOGO:	DEC	2(SP)		;COUNT LOOP
	BGT	DIV1
	RTS	PC

NEQD:	INC	R0		;INSERT LAST 1 BIT IN QUOTIENT
	BR	EQ1

EQ2:	ASL	R0		;FINISH OUT QUOTIENT WITH 0'S
EQ1:	DEC	2(SP)
	BGT	EQ2
	INC	2(SP)		;FLAG NO MORE NUMERATOR
	RTS	PC		;RETURN TO CALLER
	.ENDC

;	FIX	THE FIX ROUTINE
;	CALLING SEQUENCE:
;	CALLED WITH A FLOATING-POINT NUMBER ON THE R1 STACK
;		JSR	PC,FIX
;		(RETURN)
;	RETURNS WITH THE FLOATING-POINT NUMBER CONVERTED TO AN INTEGER
;	AND STORED ON THE R1 STACK
;
;	$RI	IS THE TWO-WORD POLISH VERSION OF THE FIX ROUTINE
;	$DI	IS THE FOUR-WORD POLISH VERSION OF THE FIX ROUTINE
;
FIX:	.IF	NDF	DECMAP
	MOV	R0,-(SP)	;R0 GETS SAVED
	JSR	R4,$RI		;SO DOES R4
	.WORD	FIXTWO		;RETURN FROM FIX ROUTINE
FIXTWO:	MOV	(SP)+,R4	;RESTORE R4
	MOV	(SP)+,R0	;AND R0
	RTS	PC
	.IFF
	.IF	DF	FPU
	SETD
	SETI			;SHORT INTEGERS
	LDD	(R1)+,F0	;GET FLOATING NUMBER
	MOV	SCAFAC,R2	;GET SCALING POINTER
	BEQ	1$		;NONE
	DIVD	(R2),F0		;DIVIDE BY SCALING FACTOR
1$:	STCDI	F0,-(R1)	;CONVERT AND STASH ON R1 STACK
	RTS	PC		;THEN EXIT
	.IFF
	MOV	R0,-(SP)	;R0 GETS SAVED
	JSR	R4,CHKSCL	;GO CHECK FOR SCALING
	.WORD	$DVD,$RI,FIXTWO
FIXTWO:	MOV	(SP)+,R4	;RESTORE R4
	MOV	(SP)+,R0	;AND R0
	RTS	PC
	.ENDC
	.ENDC
$RI:
	.IF	DF	FPU
	.IF	EQ	FLTLEN-4
$DI:	SETD			;DOUBLE PRECISION
	.ENDC
	.IF	NE	FLTLEN-4
	SETF
	.ENDC
	SETI			;SHORT INTEGERS
	LDD	(R1)+,F0	;GET ARG
	STCDI	F0,-(R1)	;CONVERT
	JMP	@(R4)+		;RETURN
	.ENDC

	.IF	NDF	FPU
	.IF	EQ	FLTLEN-4
$DI:	MOV	(R1)+,2(R1)	;TRUNC. TO REAL FORMAT
	MOV	(R1)+,2(R1)
	.ENDC
	CLR	R2		;CLEAR WORK SPACE
	INC	R2		;SET UP NORMAL BIT
	MOV	(R1)+,R0	;GET REAL ARGUMENT
	ROL	(R1)		;GET SIGN
	ROL	R0		;AND
	ROL	-(SP)		;SAVE IT
	MOVB	R0,R3		;GET HIGH ORDER FRACTION
	CLRB	R0
	SWAB	R0		;GET EXPONENT
	SUB	#201,R0
	BLT	ZERO5		;JUMP IF IT IS TOO SMALL
	BEQ	DONE2
	CMP	#15.,R0
	BLT	OVER3		;JUMP IF IT IS TOO BIG
	SWAB	R3		;FORM 16 BITS OF HIGH ORDER FRACTION
	CLRB	R3
	BISB	1(R1),R3
	ASHC	R0,R2
DONE2:	NEG	R2		;MAKE -
	BVS	NEGM		;JUMP IF POSSIBLE NEGMAX
	BGT	OVER3		;JUMP IF MORE THAN 15 BITS
SIGN2:	ROR	(SP)+		;GET SIGN
	BCS	OUT4		;JUMP IF -
	NEG	R2		;- RESULT
OUT4:	MOV	R2,(R1)		;STORE INTEGER RESULT
	JMP	@(R4)+		;RETURN TO CALLER
NEGM:	ROR	(SP)+
	BCS	OUT4		;OK IF RESULT TO BE -
	TST	-(SP)		;FAKE SIGN
OVER3:	POST,	PSTFIX
ZERO5:	CLR	R2		;ANSWER IS 0
	BR	SIGN2
	.ENDC

;	CMPF	THE DOUBLE PRECISION COMPARE ROUTINE
;	CALLING SEQUENCE:
;	CALLED WITH THE TWO (4-WD FL-PT)
;	COMPARANDS ON THE R1 STACK:
;	FIRST IS AT 8(R1), SECOND IS (R1)
;		JSR	PC,CMPF
;		(RETURN)
;	RETURNS WITH ONLY THE FIRST COMPARAND
;	ON THE R1 STACK AND WITH THE CONDITION CODES SET AS FOLLOWS:
;	FIRST < SECOND  N=1, Z=0
;	FIRST = SECOND  N=0, Z=1
;	FIRST > SECOND  N=0, Z=0
;
;	$CMD	IS THE DOUBLE PRECISION POLISH VERSION OF THE COMPARE ROUTINE
;
CMPF:	MOV	#RTSLOC,R4	;SET RETURN FOR RSTS
$CMD:
	.IF	DF	FPU
	SETD
	LDD	(R1)+,F0	;GET SECOND ARG
	CMPD	(R1),F0		;COMPARE
	CFCC			;GET CONDITION CODES
	JMP	@(R4)+
	.ENDC
	.IF	NDF	FPU
	MOV	#16601,R0	;GET 00XXXXX   XXXX01 IN R0
	MOV	8.(R1),R3	;GET HIGH ORDER FIRST ARG
	BGE	FPOS		;JUMP IF FIRST ARG +
	ASL	R0		;FLAG FIRST ARG -
	MOV	(R1)+,R2	;GET HIGH SECOND ARG
	BLT	SAME		;JUMP IF BOTH SIGNS -
	BR	NEG		;JUMP IF FIRST - AND SECOND +
FPOS:	MOV	(R1)+,R2
	BLT	PLS		;JUMP IF FIRST + AND SECOND -
SAME:	CMP	R3,R2		;COMPARE MAGNITUDES
	BNE	OUT1		;JUMP IF DIFFERENT
	CMP	8.(R1),(R1)
	BNE	OUT1
	CMP	10.(R1),2(R1)
	BNE	OUT1
	CMP	12.(R1),4(R1)
	BNE	OUT1
	CLR	R0		;FLAG =
OUT1:	ROR	R0		;SAVE C BIT AND TEST SECOND ARG -
	BCS	PLS		;JUMP IF SECOND ARG +
NEG:	NEG	R0		;REVERSE C BIT
PLS:	ADD	#6,R1		;POP ARGS, LEAVING SECOND ARG FOR RSTS
	TST	R0		;SET Z AND N BITS CORRECTLY
	JMP	@(R4)+		;RETURN TO CALLER
	.ENDC

	.END

