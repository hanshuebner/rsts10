TITLE	XTMA2,<2-WORD TRIG FUNCTIONS>,08,13-MAY-86,TPH/JDM/MHB

;                   Copyright 1974,1990 by Digital Equipment Corporation
;                                  All rights reserved.
;
;          This software is furnished under a license and may be used and copied
;          only  in  accordance  with  the  terms  of  such license and with the
;          inclusion of the above copyright notice.  This software or any copies
;          shall not be provided to any other person.   No title to or ownership
;          of the software is hereby transferred.
;
;          The information in this software is subject to change without notice.
;
;          DIGITAL  assumes  no  responsibility  for the  use, functionality, or
;          reliability of its  software  on equipment  which  is not supplied by
;          DIGITAL.

.SBTTL	EXTERNAL GLOBALS

	.GLOBL	INTFUN,ADDF,MULF,DIVF
	.IF	NDF	FPU
	.GLOBL	$ADR,$SBR,$MLR,$DVR,$IR,$RI,$INTR,DUP2
	.GLOBL	$POLSH,DUPLF
	.ENDC

.SBTTL	LOAD PUSH-POP CODE FOR TRIG FUNCTIONS

	ORG	PT,0

	..	PPSIN,SIN
	..	PPCOS,COS
	..	PPATAN,ATAN
	..	PPTAN,TAN

	.IF	NDF	FPU
	ORG	POLY,0
POLY:
;	POLY4 IS A POLYNOMIAL EVALUATOR TO EVAL
;	C(N)*X**N+C(N-1)*X**N-1+...+C(1)*X+C(0)
;	CALL POLY4 (VIA $POLSH) WITH X (A 4-WD FL-PT NO.)
;	ON THE R1 STACK AND C(R4)=A POINTER TO A POINTER TO A WORD
;	CONTAINING N+1, I.E., THE NO. OF CONSTANTS.
;	THE CONSTANTS THEMSELVES ARE STORED (AS 4-WD FL-PT
;	NO'S.) IMMED. BEFORE THE WORD CONTAINING THE N+1,
;	WITH C(N) AT LOWEST ADDR AND C(0) AT HIGHEST.
;	E.G., TO EVAL. 5*X**2+3*X+2, THE CONST. TABLE
;	LOOKS LIKE:
;		.WORD	...,...,...,...		;4-WD FL-PT 5, I.E. C(2)
;		.WORD	...,...,...,...		;4-WD FL-PT 3, I.E. C(1)
;		.WORD	...,...,...,...		;4-WD FL-PT 2, I.E. C(0)
;		.WORD	3			;NO. OF CONS'TS
;
POLY2:	;POLY2 IS LIKE POLY4 - BUT FOR 2-WORD STUFF
POLY4:	MOV	(R4)+,R0	;POINTER TO NUMBER OF COEFFICIENTS, ETC.
	MOV	R4,-(SP)	;SAVE RETURN POINTER
	MOV	(R0),R4		;SAVE THE NUMBER OF COEFFICIENTS IN R4
	MOV	R4,-(SP)	;AND ON THE STACK
	MOV	(R1)+,R2	;SAVE X
	MOV	(R1)+,R3
	.REPT	FLTLEN-2
	MOV	(R1)+,-(SP)
	.ENDR
	BR	PLP42		;GO PUSH A COEFFICIENT
PLP41:	.IF	EQ	FLTLEN-4	;FETCH X BACK TO THE R1 STACK
	MOV	(SP),-(R1)
	MOV	2(SP),-(R1)
	.ENDC
	MOV	R3,-(R1)
	MOV	R2,-(R1)
PLP42:	MOVFLT	-(R0),-(R1)	;PUSH ONE OF THE COEFFICIENTS
	DEC	R4		;DECREMENT THE COEFFICIENT COUNT
	BGT	PLP41		;AROUND AGAIN IF COUNT NOT DONE
	.IF	EQ	FLTLEN-4
	CMP	(SP)+,(SP)+	;SOME GARBAGE OFF THE STACK
	.ENDC
	DEC	(SP)		;DECREMENT 2ND COPY OF COUNTER
PLP43:	JSR	PC,MULF		;MULTIPLY TOP OF STACK BY X
	JSR	PC,ADDF		;ADD IN NEXT COEFFICIENT
	DEC	(SP)		;DECREMENT COEFFICIENT COUNT
	BGT	PLP43		;BR IF MORE TO DO IN LOOP
	TST	(SP)+		;POP THE COUNTER
	MOV	(SP)+,R4	;RESTORE POLISH POINTER
	JMP	@(R4)+		;POLISH EXIT

;	UP4 IS A POLISH ROUTINE TO MOVE THE 4 WDS AT THE HEAD
;	OF THE STACK TO A LOC 8 WD'S AWAY INSIDE THE STACK
UP2:	;LIKE UP4 BUT 2 WORDS AT HEAD GET MOVED 4 WORDS AWAY
UP4:	MOVFLT	(R1)+,6*FLTLEN-2(R1)  ;MOVE SOME WORDS SOME DISTANCE
	JMP	@(R4)+
;
;	MSPR1 IS A POLISH ROUTINE THAT TRANSFERS THE TOP 2 WDS.
;	OF THE SP STACK TO THE R1 STACK
MSPR1:	MOV	(SP)+,-(R1)
	MOV	(SP)+,-(R1)
	JMP	@(R4)+
;
	.ENDC

	DEFORG	MAXT
TAN:	.IF	DF	DECMAP
	JSR	PC,DSCTST	;GET 'FAF' ARG AND CHECK FOR SCALING
	.IFF
	JSR	R5,INTFUN	;DEMAND A FLOATING ARG
	ARGS	FAF
	.ENDC
	MOVFLT	(R1)+,-(SP)	;COPY ARG ON SP STACK
	FLTPP	-(R1)		;BACK UP ON R1 STACK
	JSR	PC,SINF		;GET SIN(X)
	MOVFLT	(SP)+,-(R1)	;GET BACK THE COPY
	JSR	PC,COSF		;GET COS(X)
	JMP	DIVF		;TAN(X)=SIN(X)/COS(X)

;	SIN	COS	THE SIN AND COSINE FUNCTIONS
;	CALLING SEQUENCE:
;	CALLED WITH ARG (2-WD FL-PT NO.) ON R1 STACK
;		JSR	PC,SIN	(OR COS)
;		(RETURN)
;	RETURNS SIN OR COS OF ARG (2-WD FL-PT NO.) ON R1 STACK
;
SIN:	JSR	R5,INTFUN	;DEMAND FLOATING ARG
	+FAF
	BR	SINF		;DO THE SINE
COS:	JSR	R5,INTFUN	;DEMAND FLOATING ARG
	+FAF
	.IF	NDF	FPU
COSF:	MOV	#007733,-(R1)	;PUSH PI/2
	MOV	#040311,-(R1)
	JSR	R4,$POLSH	;ENTER POLISH MODE
	.WORD	$ADR,SINF	;COS(X)=SIN(X+PI/2)
SINF:	CLR	-(SP)		;MAKE ROOM FOR QUADRANT FLAG
	ASL	(R1)		;REMOVE AND SAVE SIGN
	ROR	(SP)		;IN QUADRANT FLAG
	ROR	(R1)		;SHIFT ARG BACK
	CMP	(R1),#026000	;VERY SMALL?
	BLO	RTN3		;YES
	MOV	#007733,-(R1)	;PUSH 2*PI
	MOV	#040711,-(R1)
	JSR	R4,$POLSH	;ENTER POLISH MODE
	.WORD	$DVR		;X/2PI
	.WORD	DUP2		;2 COPIES
	.WORD	$INTR		;INT(X/2PI)
	.WORD	$SBR		;FRACT(X/2PI)
	.WORD	X4		;4*FRACT(X/2PI)
	.WORD	DUP2		;2 COPIES
	.WORD	$INTR		;INT(4*FRACT(X/2PI))
	.WORD	QUAD		;SAVE INT(......)
	.WORD	$SBR		;Y=FRACT(4*FRACT(X/2PI))
	.WORD	QSET		;REDUCE Y TO (-1,1)
QSETRE:	.WORD	DUP2		;2 COPIES
	.WORD	DUP2		;3 COPIES
	.WORD	$MLR		;Y*Y
	.WORD	POLY2		;PUSH COEFFICIENTS
	.WORD	CONSTS		;CONST. TAB. PTR. FOR POLY2
	.WORD	$MLR
	.WORD	RTN3
RTN3:	TST	(SP)+		;POP QUADRANT FLAG
	BGE	RTN1		;JUMP IF ARGUMENT WAS +
	ADD	#100000,(R1)	;SIN(-X)=-SIN(X)
RTN1:	RTS	PC		;BACK TO CALLER
;
X4:	TST	(R1)		;CHECK FOR 0 FRACTION
	BEQ	RTN3		;QUIT NOW
	INCB	1(R1)		;QUADRUPLE STACK ITEM
	JMP	@(R4)+
;
QUAD:	BIS	(R1),(SP)	;SAVE QUADRANT NUMBER
	JMP	@(R4)+
;
QSET:	TSTB	(SP)		;TEST QUADRANT
	BEQ	Q13		;JUMP IF FIRST OR THIRD QUAD
	TST	(R1)		;IF IT'S ZERO
	BEQ	QSET1		;THEN DON'T NEGATE IT
	ADD	#100000,(R1)	;NEGATE STACK ITEM
QSET1:	CLR	-(R1)		;PUSH A FLOATING 1.
	MOV	#40200,-(R1)
	JSR	R4,$POLSH	;ENTER POLISH
	.WORD	$ADR,QSETR	;X=1.-X
QSETR:	MOV	#QSETRE,R4	;POINT BACK INTO LIST
Q13:	ASRB	1(SP)		;TEST QUADRANT
	BCC	QOUT		;JUMP IF FIRST OR SECOND
	TST	(R1)		;IF IT'S ZERO
	BEQ	QOUT		;THEN DON'T NEGATE IT
	ADD	#100000,(R1)	;NEGATE STACK ITEM
QOUT:	MOV	(R1),-(SP)	;GET THE ARGUMENT
	BIC	#100000,(SP)	;TAKE ITS ABSOLUTE VALUE
	CMP	(SP)+,#026000	;TOO SMALL?
	BLO	RTN3		;YES, JUST EXIT
	JMP	@(R4)+
	.ENDC
	.IF	DF	FPU
COSF:	SETD			;DOUBLE PRECISION FP
	LDCFD	(R1)+,F0	;GET ARGUMENT
	ADDD	PIOV2,F0	;COS(X)= SIN(X+PI/2)
	BR	SINCOS		;
SINF:	SETD			;DOUBLE PRECISION FP
	LDCFD	(R1)+,F0	;GET ARGUMENT
SINCOS:	SETI			;SHORT INTEGERS
	MOV	#FCONST,R0	;POINTER TO CONSTANTS
	CFCC			;GET SIGN OF ARGUMENT
	SXT	R4		;SAVE THE SIGN FLAG
	ABSD	F0		;REMOVE ARGUMENT SIGN
	CMPD	#^O026000,F0	;VERY SMALL?
	CFCC
	BGE	RTNX		;YES
	DIVD	(R0)+,F0	;X/(PI/2)
	MODD	#0.25,F0	;F0=FRACT(X/2PI)
	SETF			;SINGLE PRECISION FP
	LDCDF	F0,F0		;CONVERT ARGUMENT
	CFCC			;
	BEQ	RTN3		;CHECK FOR 0 FRACTION
	MODF	#4.0,F0		;F0=FRACT(4*FRACT(X/2PI))
	STCFI	F1,R2		;QUAD=INT(4*FRACT(X/2PI))
	ROR	R2		;
	BCC	Q13		;JUMP IF FIRST OF THIRD QUAD
	NEGF	F0		;
	ADDF	#1.0,F0		;Y=1.0-X
Q13:	ROR	R2		;
	BCC	Q12		;JUMP IF FIRST OR SECOND QUAD
	NEGF	F0		;Y= -Y
;
Q12:	LDF	F0,F2		;COPY NUMBER
	ABSF	F2		;TAKE ABS VALUE
	CMPF	#^O026000,F2	;VERY SMALL?
	CFCC
	BGE	RTNX		;YES
	LDF	F0,F2		;
	MULF	F2,F2		;Z=Y**2
	MOV	#4,R2		;COUNT OF CONSTANTS FOR POLY
	LDF	(R0)+,F1	;INITIALIZE ACCUMULATOR
XPAND:	MULF	F2,F1		;
	DEC	R2		;COUNT
	ADDF	(R0)+,F1	;F1:= Z*F1 + C(I)
	BGT	XPAND		;LOOP
	MULF	F1,F0		;F0:= Y*F1
RTNX:	SETF
	TST	R4		;TEST SIGN FLAG
	BEQ	RTN3		;
	NEGF	F0		;SIN(-X) = -SIN(X)
RTN3:	STF	F0,-(R1)	;MOV RESULT TO STACK
	RTS	PC		;EXIT
;
FCONST:
PIOV2:	.WORD	040311,007732	;PI/2 (DOUBLE PRECISION)
	.WORD	121041,064302	;
;
;	ORDER-DEPENDENT CONSTANTS
;
	.ENDC
	.WORD	035036,153672	;.00015148419
	.WORD	136231,023143	;-.00467376557
	.WORD	037243,032130	;.0796896793
	.WORD	140045,056741	;-.645963711
	.WORD	040311,007733	;1.570796318
	.IF	NDF	FPU
CONSTS:	.WORD	5
	.ENDC

;	THE ATAN FUNCTION
;	CALLING SEQUENCE FOR ATAN:
;	CALLED WITH ARG (2-WD FL-PT NO.) ON R1 STACK
;		JSR	PC,ATAN
;		(RETURN)
;	RETURNS ARCTAN(ARG) (2-WORD FL-PT NO.) ON R1 STACK
;
ATAN:	JSR	R5,INTFUN	;DEMAND FLOATING ARG
	+FAF
	.IF	NDF	FPU
	CLR	-(SP)		;CLEAR SIGN FLAG
	CLR	-(SP)		;CLEAR QUADRANT BIAS
	CLR	-(SP)
	TST	(R1) 		;TEST X
	BGE	PLUSQZ		;JUMP IF QUADRANT 1 OR 3
	ADD	#100000,(R1)	;GET ABS VALUE 
	INC	4(SP)		;FLAG -
PLUSQZ:	CMP	(R1),#40200	;CHECK IF <1.
	BLO	LE1		;JUMP IF <1.
	BGT	GT1		;>1.
	TST	2(R1)		;CHECK LOW ORDER
	BEQ	LE1		;=1.
GT1:	MOV	#140311,2(SP)	;-PI/2
	MOV	#007733,(SP)	;ATAN(X)=PI/2-ATAN(1/X)
	DEC	4(SP)		;ADJUST SIGN
	MOV	R1,R2
	JSR	PC,DUPLF
	MOV	#40200,(R2)+	;INSERT 1.
	CLR	(R2)+
	JSR	PC,DIVF
LE1:	MOV	R1,R2
	JSR	PC,DUPLF
	CLR	(R2)+		;STORE ZERO
	CLR	(R2)+
	CMP	(R1),#037611	;TAN(15)
	BLO	LT15		;JUMP IF LESS THAN TAN(15)
	BHI	TRANS		;JUMP IF >
	CMP	2(R1),#030243	;CHECK LOW ORDER
	BLOS	LT15		;JUMP IF =
TRANS:	MOV	#005222,-(R2)	;INSERT PI/6
	MOV	#040006,-(R2)
	MOV	@R1,R0		;ARG TO REGS
	MOV	-(R2),R2
	MOV	#131727,-(R1)	;PUSH -ROOT 3
	MOV	#140335,-(R1)
	MOV	R2,-(R1)	;PUSH ARG
	MOV	R0,-(R1)
	CLR	-(R1)		;PUSH 1.
	MOV	#40200,-(R1)
	MOV	#131727,-(R1)	;PUSH ROOT3
	MOV	#040335,-(R1)
	MOV	R2,-(R1)	;PUSH ARG
	MOV	R0,-(R1)
	JSR	R4,$POLSH	;TRANSFORM ARG
;		(ROOT3*X-1)/(ROOT3 +X)
	.WORD	$MLR,$SBR,UP2,$SBR,$DVR,LT15
LT15:	JSR	R4,$POLSH
	.WORD	DUP2,DUP2,$MLR	;GET ARG**2
	.WORD	POLY2		;EXPAND POLYNOMIAL
	.WORD	CONST1		;CONST. TAB. PTR. FOR POLY2
	.WORD	$MLR,$ADR
	.WORD	MSPR1		;MOVE VALUE FROM SP TO R1
	.WORD	$ADR		;P(X)+0 IF X<=1, P(X)-PI/2 IF X>1
	.WORD	SIGN3		;ADJUST SIGN 
	.WORD	EXIT2		;POP RESULT TO REGS
EXIT2:	RTS	PC		;RETURN TO USER
;
SIGN3:	TST	(SP)+		;CHECK SIGN FLAG
	BEQ	SIGN1
	ADD	#100000,(R1)	;NEGATE RESULT FOR (-1,0) & (1,INF)
SIGN1:	JMP	@(R4)+
	.ENDC
	.IF	DF	FPU
	SETF			;SET FP MODE FOR FPU
	CLRF	F3		;CLEAR ATAN2 BIAS
	LDF	(R1)+,F0	;GET ARGUMENT
	CLR	R4		;CLEAR SIGN FLAG
	CFCC			;GET SIGN OF ARGUMENT
	STF	F3,F5		;F5=ATAN2 BIAS
	CLRF	F3		;CLEAR QUADRANT BIAS
	BGE	PLUSQZ		;JUMP IF QUADRANT 1 OR 3
	ABSF    F0		;ABS(X)
	INC	R4		;FLAG -
PLUSQZ:	LDF	#1.0,F1		;1.0
	CMPF	F0,F1		;CHECK IF X<=1.0
	CFCC
	BLE	LE1		;
	DEC	R4		;X>1.0, ADJUST SIGN FLAG
	DIVF	F0,F1		;1.0/X
	LDF	F1,F0		;ATAN(X)=PI/2-ATAN(1/X)
	LDF	PI2,F3		;QUADRANT BIAS=PI/2
;
LE1:	STF	F3,F4		;F4=QUADRANT BIAS
	CLRF	F3		;F3=0.0
	CMPF	TAN15,F0	;COMPARE TAN(15) : X
	CFCC
	BGE	LT15		;X<= TAN(15)
	LDF	PI6,F3		;F3=PI/6
	LDF	F0,F1		;
	MULF	ROOT3,F0	;
	SUBF	#1.0,F0		;X*ROOT3-1.0
	ADDF	ROOT3,F1	;X+ROOT3
	DIVF	F1,F0		;(X*ROOT3-1.0)/(X+ROOT3)
;
LT15:	LDF	F0,F2		;X
	MULF	F0,F0		;X**2
	MOV	#FCONS1,R0	;POINTER TO POLYNOMIAL CONSTANTS
	MOV	#4,R2		;COUNT OF COEFFICIENTS
	LDF	(R0)+,F1	;INITIALIZE ACCUMULATOR
XPAND1:	MULF	F0,F1		;
	DEC	R2		;COUNT
	ADDF	(R0)+,F1	;F1:= F1* X**2 + C(I)
	BGT	XPAND1		;LOOP
	MULF	F2,F1		;F1:= F1*X
	ADDF	F3,F1		;PI/6 OR 0.0
	SUBF	F4,F1		;P(X)-QUAD BIAS
	TST	R4		;TEST SIGN FLAG
	BEQ	SIGN1		;NO ADJUSTMENT
	NEGF	F1		;NEGATE RESULT FOR (-1,0)&(1,INF)
SIGN1:	ADDF	F5,F1		;ATAN2 BIAS
;
	STF	F1,-(R1)	;MOVE RESULTS TO STACK
	RTS	PC		;EXIT
;
PI:	.WORD	040511,007733	;PI
PI2:	.WORD	040311,007733	;PI/2
TAN15:	.WORD	037611,030243	;TAN(15)
PI6:	.WORD	040006,005222	;PI/6
ROOT3:	.WORD	040335,131727	;ROOT3
	.ENDC
FCONS1:	.WORD	037305,035302	;.0963034789
	.WORD	137421,056514	;-.1419574624
	.WORD	037514,143333	;.1999773201
	.WORD	137652,125244	;-.3333331319
	.WORD	040200,000000	;.9999999999
	.IF	NDF	FPU
CONST1:	.WORD	5
	.ENDC

	.END

