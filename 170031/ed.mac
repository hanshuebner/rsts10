TITLE	ED,<EDITOR>,08,26-APR-89,TGE/TPH/MHB/AWR/JFG/TS/WJS

;                   Copyright 1974,1990 by Digital Equipment Corporation
;                                  All rights reserved.
;
;          This software is furnished under a license and may be used and copied
;          only  in  accordance  with  the  terms  of  such license and with the
;          inclusion of the above copyright notice.  This software or any copies
;          shall not be provided to any other person.   No title to or ownership
;          of the software is hereby transferred.
;
;          The information in this software is subject to change without notice.
;
;          DIGITAL  assumes  no  responsibility  for the  use, functionality, or
;          reliability of its  software  on equipment  which  is not supplied by
;          DIGITAL.
;
;	MODIFICATIONS:
;
;*A* 22-APR-80 JFG	REMOVE SEQUENTIAL CAHCHING ON 'OLDs' BECAUSE IT
;		CAUSES FLOPPIES TO BE READ BY SECTOR (SEE FLOPPY DRIVER)
;
;    29-FEB-88 PJH	Fix the CAT SPR.  Change the command, so that it
;			dosen't read Marked-for-delete files by mistake.
;
;    29-FEB-88 PJH	Fix the Non-trappable error #21.  It lies in user
;			trappable space, make it user trappable.
;
;    21-APR-89 PJH      Comment out EDINIT code, EDCRAS code, and any
;                       references to them.
;
;    09-Feb-90 WJS	Extended user logicals (ASSIGN, DEASSIGN)

	ORG	XT,TLDIPT

	.WORD	DOCONT	;CONT(INUE)
	.WORD	DOLIST	;LIST
	.WORD	DOLINH	;LIST NH
	.WORD	DODELE	;DELETE
	.WORD	DOLENG	;LENGTH
	.WORD	DONEW	;NEW
	.WORD	DOOLD	;OLD
	.WORD	DORENA	;RENAME
	.WORD	DOREPL	;REPLACE
	.WORD	DORUN	;RUN
	.WORD	DORUNH	;RUN NH
	.WORD	DOASSI	;ASSIGN
	.WORD	DOSAVE	;SAVE
	.WORD	DODEAS	;DEASSIGN
	.WORD	DOUNSA	;UNSAVE
	.WORD	DOCATA	;CATALOG
	.WORD	DOCOMP	;COMPILE
	.WORD	0			;HELLO removed 90.2.12  WJS
	.WORD	0			;BYE removed 90.2.12  WJS
	.WORD	DOTAPE	;TAPE
	.WORD	DOKEY	;KEY
	.WORD	DOAPND	;APPEND
	.WORD	DOMORE	;MORE TO COME...

	..	PPCHAI,RRRRR

	DEFORG	ED
	DEFORG	ZT
	ORG	ED

	.GLOBL	GETAG,GETAGD,GETAGN,BAD.XX,EDSTOR
	.GLOBL	EDFTCH,BASFRC,BAD.10,BASVEN
	.GLOBL	LSTOP1,DLTONN,DLTONR,FUCERR,EDRSR1
	.GLOBL	EDCLR,EDENDC,EDFIPK,LENNUM
	.GLOBL	EDRSTH,EDSCAN,EDTYPE,EDERR,EDERRN
	.GLOBL	RTSRER,RTSRET,R1SCHK,EDCTLH,DOCONT
	.GLOBL	NEWJOB,RUNIM,R1SOUT,ZOTALL,EDRUN
	.GLOBL	ASKNEW,ASKOLD,READYM,BYEM,KSIZEM
	.GLOBL	STR$LI
	.GLOBL	PRINTL,FLT,OPNR20,$PLSIG
	.GLOBL	SSONRC,SSOCH0,SSO01,OPNI11,OPNI20,PUSHS1
	.GLOBL	CLSR09,PRESET
	.GLOBL	PUSHS3,DUPLS,RTSENT,CRLF,TIME07,DATE07
	.GLOBL	PRINTS,R50A01,SSIX1,IFPOS0
	.GLOBL	TLGDFN,TLGFNA,TL,TLGPDS,TLCMWD,TLENER
	.GLOBL	TLPTIN,TLBEGH,TLPDST,TLGLN1,TLGENP,TLGNEP
	.GLOBL	TLGTOK,NEWOLD,TLPAIR,CATSUR
	.GLOBL	FLTLEN,CATSUP
	.GLOBL	ECONOM,EDSAVE
	.GLOBL	RESTOR,CLOSER,INTERP,INTERB,.MATH.,MI.BAD
	.GLOBL	TLER18,EDREST,GETBUF,READ.,WRITE.
	.GLOBL	GETBYT,DOSCAL
	.GLOBL	CATSUC,SCASUP
	.globl	SUCJS,RADI



;EDITOR-----------------------------------------------------------------
;PROCESSOR FOR USER'S IMMEDIATE COMMANDS
;THE EDITOR IS ENTERED AT "NEWJOB" BY THE SCHEDULER WHEN A TERMINAL IS
;FIRST ACTIVATED.  THE EDITOR ENTERS THE TRANSLATOR VIA CALLS "TL" AND
;"TLC" WITH R1 AND R6 STACKS SETUP AND ALSO WITH CORE ALLOCATORS POINTERS
;INITIALIZED.  THE EDITOR IS REENTERED FROM THE TRANSLATOR WHEN THE USER
;EXECUTES ANY OF THE IMMEDIATE COMMANDS.  SOME OF THESE COMMANDS,
;SUCH AS RUN, CAUSE THE EDITOR TO CALL THE RUN-TIME-SYSTEM VIA A CALL
;TO "RTS".

RAD50A:	CMP	-(SP),-(SP)	;MAKE 4 BYTES OF STORAGE ON STACK
	MOV	(R1)+,R2	;GET VALUE TO DECODE
	MOV	SP,R3		;POINT TO THE STORAGE TO USE
	JSR	PC,R50A01	;NOW DECODE IT
	MOV	SP,R2		;POINT TO THE DECODED DATA
	JSR	PC,PRINTL	;AND PRINT IT
	CMP	(SP)+,(SP)+	;COLLAPSE THE STORAGE SPACE
	RTS	PC		;THEN EXIT



.MACRO	ZT,NAME
.GLOBL	TK'NAME
TK'NAME	=	TMPTAG
TMPTAG	=	TMPTAG+2
	ORG	ZT,TK'NAME
	.WORD	DO'NAME
.ENDM

TMPTAG	=	0

	ZT	REAS
	ZT	CCON
	ZT	SCAL
	ZT	MOUN
	ZT	EXIT
	ZT	TRAC
	ZT	UNTR
	ZT	BREK
	ZT	UNBR
	ZT	DUMP

	ORG	ED

DOMORE:	MOV	R2,-(SP)	;GET A WORKING REGISTER
	MOVB	XXMORE,R2	;NOW GET THE SUB-TOKEN CODE
	MOV	ZT(R2),R2	;GET DISPATCH ADDRESS
	RTS	R2		;SO GO TO IT...



;^C FLAG TRAPPER UNSETTER

CC2INT::BIC	#JFCCC,JOBF	;HE MUST BE IN TROUBLE

; ^C FLAG SETTER

CCINT::	BIS	#JFCC,JOBF	;STOP BECAUSE CONTROL C TYPED
DORTI::	RTI

.ENABL	LSB

BAD.XX:	CMP	(SP),#MI.BAD	;ERROR FROM MATH INITIALIZATION?
	BNE	10$		;NOPE
	CMP	6(SP),#20$	;YEP, IS THIS THE RE-SET UP AFTER FAILURE??
	BEQ	DORTI		;JUST IGNORE THE TRAP THE 2ND TIME...
10$:	MOV	#USRSP,SP	;ENSURE A GOOD SP STACK
	JSR	PC,NOLOGS	;CLEAR LOGICAL TABLE ON THIS KIND OF ERROR
	BR	BADDY		;AND CONTINUE

BAD.10:	SETERR	B.10		;SET CORRECT ERROR CODE
BADDY:	MOV	#USRSP,SP	;ENSURE A GOOD SP STACK
	MOV	IOSTS,-(SP)	;SET THE ERROR CODE
	JSR	PC,CATSUC	;NO INITIALIZE EVERYTHING
20$:				;REFERENCE ONLY...
	MOV	(SP)+,IOSTS	;RESTORE THE ERROR CODE
	BEQ	30$		;NONE
	IOTERR			;ONE, ANNOUNCE IT
30$:	ERROR	FUCORE		;APOLOGIZE FOR CLOBBERING THE PROGRAM
	CLR	FIRQB+FQNAM1	;SIGNAL RETURN TO PERSONAL DEFAULT RTS
	.RTS			;AND DO IT
	.EXIT			;BACK TO SYSTEM DEFAULT IF HERE...

.DSABL	LSB

	.enabl	lsb

NEWJOB:	MOV	XRB+2,-(SP)	;SAVE CALLING RTS NAME (PART 1)
	MOV	FIRQB+FQFIL,-(SP) ;SAVE (POSSIBLE) CREATING JOB # *2
	JSR	PC,CATSUC	;DO ABS CORE SETUP
	MOV	(SP)+,R3	;RESTORE (POSSIBLE) CREATING JOB # *2
	BIS	#JFWIPE,JOBF	;ENSURE CLEARING THE IN-CORE IMAGE
	TST	(SP)+		;CALLED BY ANOTHER?
	BNE	ED$CT4		;YES, JUST SAY 'READY'
	BIT	#JFNOPR,JOBF	;LOGGED IN?
	BEQ	ED$CT4		;YES, SO SET UP "NONAME"
	JSR	PC,NOLOGS	;ELSE CLEAR LOGICAL TABLE
	MOV	#FIRQB,R4	;GET FIRQB POINTER
	TST	FQPPN(R4)	;A JOB SPAWN REQUEST?
	BNE	87$		;Yes
	MOV	#32000.!100000,-(SP) ;No:  set LOGIN to run from 32000
;	BR	40$		;JOIN COMMON CODE

40$:	MOV	#STR$LI,R0	;SET NAME OF "$LOGIN"

50$:	MOV	#CORCMN,R3	;THIS IS CORE COMMON POINTER
	CLRB	(R3)+		;START A 0 LENGTH
	CMP	(SP),#32000.!100000 ;NEWJOB ENTRY?
	BEQ	70$		;YES, SO NO LA STRING POSSIBLE
	MOV	SPDA,R2		;GET SPDA AND FIND
	ADD	CLB(R2),R2	; LA'S LINE POINTER
60$:	CMPB	(R2),#BUMCHR	;MORE?
	BEQ	70$		;NO
	CMPB	(R2),#ENDCHR	;MIGHT BE
	BEQ	70$		;NO MORE
	MOVB	(R2)+,(R3)	;MORE, MOVE OVER 1 BYTE AND
	BICB	#-177-1,(R3)+	; TRIM OFF ANY PARITY BIT
	INCB	CORCMN		;AND COUNT THAT BYTE
	BPL	60$		;CONTINUE IF WE CAN
70$:	MOV	SPDA,R2		;GET SPDA
	JSR	PC,PUSHS1	;AND PUSH STRING ONTO THE R1 STACK
	BR	RRRR$2		;NOW GO AND DO IT

87$:	MOV	#CORCMN,R0	;YES, POINT TO CORE COMMON
	MOV	#11.,R2		;DO 11. BYTES
	MOVB	R2,(R0)+	;SET SIZE = 11. BYTES
88$:	MOVB	FIRQB+16-<CORCMN+1>(R0),(R0)+ ;FILL CORE COMMON
	SOB	R2,88$		;FOR WHOLE COUNT
	MOVB	R3,-(R0)	;MAKE LAST BYTE THE CREATOR J # *2
	BR	SPAWN		;NOW GO DO IT

	.dsabl	lsb



DOKEY:	.TTECH			;ENABLE THE ECHOS
ED$CT4:	BR	EDCTL4		;THEN EXIT

;EDPUSS MAKES A STRING HEADER BLOCK ON R1 STACK FOR PROBLEM NAMES
EDPUSS:	MOV	(R1)+,R0	;PLACE WHERE RTS WANTS IT
	BNE	10$		;TEST FOR NONAME
	MOV	#EDDUMM,R0	;AHHH
10$:	MOV	SPDA,R2		;WHERE RTS EXPECTS IT
	JSR	PC,PUSHS3	;SPLAY IT OUT
	JMP	EDRSTD		;SPDA TO R0, RTS PC

;NEW PREPARES FOR BRAND NEW PROBLEM FROM THE USER
DONEW:	MOV	#ASKNEW,-(R1)	;GET A FILE NAME OUT OF HIM
	JSR	PC,NEWOLD	;IF YOU CAN
DONCLR:	JSR	PC,EDPUSS	;MAKE NAME INTO HEADER
	JSR	PC,EDSCAN	;INSTALL THE NAME
	JSR	PC,EDCLR	;CLEAR OLD PROBLEM ETC.
	JSR	PC,CATSUP	;CLEAR ALL VARIABLES
	BIS	#EDNEWF,EDFLAG	;FLAG NEW ENTRY
	BIC	#EDCOMP!EDGOFL,EDFLAG ;CLEAR COMPILE AND GO
	BR	EDCTL4		;GO DO IT

DOAPND:	JSR	PC,EDTMPP	;CHECK FOR NON-COMPILED
	BIS	#EDAPND,EDFLAG	;DON'T KILL WHAT YOU GOT
DOOLD:	MOV	#ASKOLD,-(R1)	;BARGAIN FOR A FILE NAME
	JSR	PC,NEWOLD	;FROM THE USER
	JSR	PC,EDPUSS	;MAKE NAME INTO HEADER
COMPI8:	JSR	PC,OPNR20	;SCAN THE NEW NAME
	MOV	#BASCHN,FQFIL(R4);SET THE .BAS CHANNEL
;	BIS	#104000,FQMODE(R4);*A* OPEN IT SEQUENTIALLY IF CACHING
	JSR	R5,EDFIP1	;AND CALL FIP FOR
	.RAD50	/BAS/		; OPENING THE FILE
	+	OPNFQ		;  WITH (OPTIONAL) .BAS EXTENSION
	BCS	OLDE		;NOT O.K. IF FILE NOT FOUND
	BIT	#EDAPND,EDFLAG	;APPENDING?
	BNE	20$		;YES, SO DON'T DESTROY THIS IMAGE...
	.NAME			;NO, SO INSTALL THE NAME PROBLEM NAME
	MOV	#-BASCHN,FQFIL(R4);SET TO RESET ALL CHANNELS EXCEPT THIS ONE
	JSR	R5,EDFIPK	;NOW CALL FIP TO
	+	RSTFQ		; RESET ANY OPEN CHANNELS
	JSR	PC,EDCLRF	;CLEAR EDITOR FLAGS
	JSR	PC,CATSUP	;CLEAR CORE AND INITIALIZE IT
	MOV	#FIRQB,R4	;NOW RESTORE THE FIRQB POINTER
20$:	JSR	R5,EDOI10	;CALL FOR
	+	OPNI20		; OPENING (IN TERMS OF BUFFERS) FILE
	BIS	#EDCOMP,EDFLAG	;SET COMPILE FLAG
	JSR	PC,EDCCTS	;CHECK FOR ^C FIRST
EDCTL4:	JMP	EDCTL		;GET TO EDCTL

OLDE:	IOTERR	!FATAL		;ANY RETURN TO HERE IS AN ERROR




;THE FOLLOWING COMMANDS DESTROY THE CURRENT SWAP AREA CONTENTS
;BY LOADING A NEW AREA FROM THE DISK, OR BY INITIALIZING THE AREA.
;R AND CHAIN HAVE TWO ARGUMENTS, A STATEMENT # IN BINARY, AND A
;STRING HEADER FOR A <FILENAME>.  I.E. 
;	R1	STATEMENT #
;		HEADER
;IF HEADER = 0, THE FILE "NONAME" WILL BE USED.
;IF STATEMENT # = 0, THE FIRST STATEMENT WILL BE USED.

DOR1:	JSR	PC,TLPDST	;IF NOT STRING, ERROR; PUSH STR; READ TOKEN
	ERROR	TLJNKY,FATAL	;JUNK INSTEAD OF DATA STRING
	BIS	#LINUMF,STAT(R0);TELL LA TO GET A LINE NO
	JSR	PC,TLGENP	;SKIP IF END OF STATEMENT
	BR	5$		;NOT END, THERE'S A LINE NO. ARGUMENT TOO
	CLR	-(R1)		;STACK 0 IN NON-LINE NO. CASE
	BR	3$

5$:	JSR	PC,TLGLN1	;STACK A LINE #
3$:	MOV	(R1)+,-(SP)	;MOVE LOC TO SP STACK
	JSR	PC,EDPUSS	;SPLAY HEADER, CHECK FOR 0=NONAME
RRRRR1:	BIS	#EDGOFL,EDFLAG	;LOAD & GO FLAG
	JSR	PC,DUPLS	;COPY STRING IN CASE .BAS ONLY AVAIL
RRRR$2:	JSR	PC,OPNR20	;SCAN THE STRING - MAKE FIRQB
	TSTB	JOBF		;CONTROL/C PENDING?
	BMI	EDCTL4		;YES, SO RESPOND TO IT
	TST	FQEXT(R4)	;EXTENSION SPECIFIED?
	BNE	1$		;YES
	MOV	#-1,FQEXT(R4)	;ASSUME AUTO-DETERMINATION OTHERWISE
1$:	MOV	(SP)+,FQNENT(R4);SET THE PASSED ARGUMENT (LINE #)
SPAWN:	.RUN			;AND TRY TO RUN THIS PROGRAM
	MOV	FQNENT(R4),-(SP);WE FAILED, SO STACK ARG AGAIN
	BIC	#100000,(SP)	; BUT NEVER KEEP PRIV'S NOW
	BIT	#EDGOFL,EDFLAG	;WAS THIS A LOAD AND GO REQUEST?
	BEQ	FUCERR		;NOPE, SO DIE NOW
	TSTB	FQFLAG(R4)	;SHOULD WE DIE??
	BNE	COMPI8		;NOPE, TRY FOR NON-COMPILED
	CMPB	#21.,IOSTS	; TEST FOR DEVICE NOT MOUNTED, BUG FIX 1/88
	BNE	FUCERR		; NOT THAT ERROR, DIE SUCKER!
	BR	OLDE		; ELSE, ALLOW FOR USER ROUTINE.

RRRRR:	MOV	(R1)+,(SP)	;START LINE NO ON SP (KILL RTS PC)
	BIC	#100000,(SP)	;INDICATE NO PRIV PASSING
	BIT	#JFSYS!JFNOPR!JFPRIV,JOBF;ALLOWED TO PASS PRIV'S?
	BEQ	RRRRR1		;NO, LET MONITOR HANDLE IT
	BIS	#100000,(SP)	;ELSE COMPLEMENT THE BIT
	BR	RRRRR1		;NOW GO DO IT



;MONITOR ENTRY - POSSIBLY FROM ANOTHER RUN-TIME SYSTEM

.ENABL	LSB

EDRUN:	MOV	#USRSP,SP	;RESET THE SP STACK
	TSTB	IOSTS		;ERROR POSTED ALREADY?
	BNE	FUCERR		;YES, DIE
	CALLX	SAVEFQ		;SAVE FIRQB DATA ON RUN ENTRIES
	MOV	FIRQB+FQNENT,-(SP) ;STACK STARTING LINE NUMBER
	MOV	XRB,-(SP)	;STACK CCL & DETACH DETERMINATION
	TST	XRB+6		;SET N-BIT=1 IF CALLED FROM SELF...
	JSR	PC,CATSUR	;ABS CORE SETUP (AND FPU ON IF ANY...)
EDKEEP::			;TO ENSURE KEEPING TEMP PRIV'S ETC.
	BIS	#JFEXIT!JFWIPE,JOBF ;SET INDICATION TO RETURN TO DEFAULT RTS
	.NAME			;ENSURE NAME IS INSTALLED
	MOV	#FIRQB,R4	;AS IF AN OPEN HAD JUST BEEN DONE
	MOV	FQSIZ(R4),R0	;SET UP PARAMETERS FOR READ
	BIT	R0,#-77-1	;CHECK FOR A VALID SIZE
	BNE	10$		;IF <0 OR >16K, THEN ERROR
	MOV	R0,-(SP)	;SAVE FILE SIZE
	INC	R0		;CORRECT FOR 1 BLOCK NOT IN FILE
	BIT	R0,#3		;CHECK FOR EVEN 1K INCREMENTS
	BNE	10$		;IF NOT, THEN ERROR
	CMP	R0,#10		;ALSO CHECK FOR AT LEAST 2K
	BLT	10$		;IF LESS THEN 2K THEN ERROR
	ASR	R0		;GET NUMBER OF
	ASR	R0		;1K CORE BLOCKS REQ'D
	MOV	R0,XRB+XRLEN	;SET AMOUNT TO ASK FOR
	BR	100$		;NOW GO DO IT

10$:	SETERR	BADCNT		;ILLEGAL .BAC FILE SIZE
	BR	FUCERR		; AND DIE



;CODE TO DO RUN COMMANDS
DORUNH:	JSR	PC,TLGTOK	;MOVE TOKEN POINTER
	BR	DOR2
DORUN:	JSR	PC,TLGENP
	BR	DOR1		;HAS AN ARG SO IT MEANS GET ANOTHER IMAGE
	JSR	PC,HEADER	;MEANS RUN CURRENT PROGRAM
DOR2:	CLR	-(R1)		;INDICATE NO ARG
	MOV	#RUN,-(SP)	;SET SUCCESS RETURN ADDRESS
CHKSCA:	CMPB	SCAVAL,SCAUPV	;DO SCALING FACTORS MATCH??
	BEQ	20$		;O.K.
	ERROR	SCAERR		;NOPE, GIVE (NON-FATAL) ERROR
..SCE.	==	.-2	;**PATCH** 'NOP' FOR NO SCALE (NON-FATAL) ERROR
20$:	RTS	PC		;YEP, SO RETURN



100$:	.CORE			;ASK FOR THE MEMORY
	TSTB	IOSTS		;ERROR?
	BNE	FUCERR		;YES, DIE
	MOV	(SP)+,R0	;PUT FILE SIZE INTO R0
	MOV	#XRB,R3		;PARAMETER BLOCK
	SWAB	R0		;SIZE TIMES 256.
	ASL	R0		;NOW BYTES
	MOV	R0,(R3)+	;BUFFER LENGTH @ XRLEN
	CLR	(R3)+		;BYTCNT @ XRBC
	MOV	#NSTORG,(R3)+	;LOC @ XRLOC
	MOV	(PC)+,(R3)+	;CHANNEL INDEX @ XRCI & 0 @ XRBLKM
	 .BYTE	BACCHN,0
	CLR	(R3)+		;SEQUENTIAL READ @ XRBLK
	CLR	(R3)+		;NO TIME @ XRTIME
	CLR	(R3)+		;NO MODIFIERS @ XRMOD
	.READ			;AND READ IT
	TSTB	IOSTS		;ANY ERROR?
	BNE	FUCERR		;ANY ERRORS HERE ARE VERY FATAL!
	MOV	#NSTORG,R3	;R3 IS POINTER TO HASH, R1 STACK
	MOV	(R3)+,-(SP)	;SAVE HASH TOTAL ON THE STACK
	MOV	(R3),R1		;AND THEN GET R1 STACK BACK
	ASR	R0		;FIND # WORDS IN IMAGE READ
	DEC	R0		;LESS 1 FOR HASH TOTAL SPOT
	CLR	R5		;HASH TOTAL WILL GO HERE
110$:	ADD	(R3)+,R5	;COMPUTE HASH TOTAL
	SOB	R0,110$		;LOOPING THROUGH CORE
	MOV	(SP)+,R3	;GET RIGHT CHECKSUM
	CMP	R5,R3		;DO THEY MATCH?
	BEQ	200$		;CHECKSUM OK
	.ERLOG			;LOG A CHECKSUM ERROR, BAD CORE?
120$:	CLR	IOSTS		;NO PRECEEDING MESSAGE
FUCERR:	JMP	BADDY		;GO OFF AND DIE



200$:	SWAB	(R1)		;PUT VERSION NUMBER IN LOW BYTE
	DECB	(R1)		;GET VERSION NUMBER -1
	CMPB	(R1),#BASVEN-1	;LEGAL VERSION (#1 THROUGH CURRENT)?
	BHI	120$		;NO, SO FATAL TYPE ERROR
	CMPB	(R1),#BASVEN-2	;YES, BUT DON'T ACCEPT (CURRENT-2)
	BEQ	120$		;WHICH WAS THE SPECIAL GET/PUT HACKS...
.IIF	NE	BASVEN-4, .ERROR ;CURRENT=4, ACCEPT #1, #2, AND #4
	CMP	(R1)+,(R1)+	;O.K., SO DUMP SYSVEE,BASVEN,SYSVEL
	MOV	(R1)+,R5	;GET POINTER TO RESTORE CSR'S
	MOV	(R1)+,R3	;AND COUNT TO RESTORE
220$:	MOV	(R1)+,-(R5)	;NOW RESTORE THEM
	SOB	R3,220$		;AND LOOPING
	CMPB	(R1)+,#FLTLEN	;CHECK FOR CORRECT FLOATER SIZE
	BNE	230$		;ERROR IF NO MATCH
	JSR	R5,SCASUP	;O.K., SO CHECK AND SET SCALING
	BR	240$		;ALL O.K. AND SET UP NOW
230$:	SETERR	NOMATH		;WRONG MATH PACKAGE...
	BR	FUCERR		; SO DIE

240$:	BIT	#JFSYS!JFNOPR,JOBF ;TEMP PRIV'S?
	BNE	250$		;YES, WE WILL WIPE OUT LATER
	BIC	#JFWIPE,JOBF	;NO, DON'T WIPE HIM OUT THEN
250$:	JSR	PC,EDCLR	;NOW CLOSE ALL FILES
	BIS	#EDFIRS!EDGOFL,EDFLAG;SET FLAGS FOR NO .TMP AND LOAD AND GO
	JSR	PC,EDCCTS	;TEST FOR ^C (AND SPDA TO R0)
	MOV	(SP),STATUS(R0)	;SET "STATUS" FROM RUN'S XRB+0 WORD
	ASL	(SP)+		;NOW CHECK THE DETACH FLAG (BIT 14)
	BPL	260$		;NO DETACH DESIRED
	BIT	#JFPRIV,JOBF	;DETACH, PREM TYPE PRIV'S?
	BEQ	260$		;NOPE, LET SOMEONE ELSE DECIDE...
	JSR	PC,DOCCOX	;YEP, SO DETACH ALREADY
260$:				;AND CARRY ON

.DSABL	LSB

; COMMENTS ON .BAC FILE STRUCTURE:
;	@NSTORG+0 IS:	HASH TOTAL OF IMAGE
;	@NSTORG+2 IS:	R1 STACK VALUE OF IMAGE
;
;	@R1 POPPING DOWN IS:	'SYSVEE' AND 'BASVEN'
;				'SYSVEL'
;				PTR TO END OF CSR'S +2
;				COUNT OF CSR'S
;				THAT MANY CSR'S
;				MATH PACKAGE TYPE



EDENDC:	JSR	PC,EDBUFC	;DEALLOCATE AND CLOSE BAS FILE
	BIC	#EDCONT!EDAPND!EDPRES!EDCOMP!EDEOFF,EDFLAG ;CLEAR THE FLAG
	BIT	#EDGOFL,EDFLAG	;IF SET RUN THE IMAGE
	BEQ	RUN20		;NO, BACK TO COMMAND LEVEL
	MOV	(SP)+,-(R1)	;RUN FROM HERE
	CLR	TLLINO(R0)	;SET THIS UP AS IT
	JSR	PC,TLBEGH	;HAVE BEEN IF ON-LINE
				;FALL THROUGH TO RUN

;((SPTA))=STATEMENT LIST POINTER AND = 0 IF NO ENTRIES ON IT.
;OTHERWISE IT IS A POINTER RELATIVE TO SPTA TO FIRST WORD IN A TAG
;(STATEMENT HEADER).  EACH TAG LINK WORD IS RELATIVE TO ITS OWN LOCATION
;RUN ([STATEMENT#]) EXPECTS EITHER 0 OR A BINARY STATEMENT NUMBER AS ITS ARGUMENT.

RUN:	ASL	(R1)		;C=CCL FLAG; OTHER=LINE # TIMES 2
	BNE	1$		;NON-ZERO LINE #
	MOV	@SPTA,(R1)	;ZERO LINE #, SET STARTING LINE
	BR	RUN6		;AND GO DO IT

1$:	BCS	2$		;C=1 => CCL, SO KEEP ANY PRIV'S
	MOV	#JFSYS!JFPRIV,XRB ;ELSE SET UP FOR A DROP
	.CLEAR			; OF TEMP PRIV'S
2$:	CLC			;CARRY=0 AND
	ROR	(R1)		; RESTORE STARTING LINE #
	JSR	R5,LSTOP1	;LET LISTOP DO THE WORK
	GETFOP			;GET FIRST HEADER WITH #
	MOV	GETAGV(R0),-(R1);MAYBE THIS IS IT
	BNE	RUN7		;GOT IT
	TST	(R1)+		;FIX R1 BACK UP
	ERROR	STMERR,FATAL	;NO SUCH STATEMENT

RUN7:	SUB	SPTA,(R1)	;RELATIVIZE THE HEADER
RUN6:	BIC	#EDGOFL!EDIMED!EDCONT,EDFLAG	;CLEAR LOAD&GO FLAG
	JSR	PC,CKPASS	;CK, XLNK STATEMENTS, RESET VARS
	BNE	RUN66		;CROSSLINK ERROR MAY CHOKE RTS
	JSR	PC,ZOTALL	;CLOSE ALL USER FILES
RTSNT1:	MOV	(R1)+,R5	;GET THE DISPLACEMENT
	ADD	SPTA,R5		;MAKE ABSOLUTE
	MOV	#INTERP,-(SP)	;START THE INTERPRETER
	MOV	#2,RUNLVL	;GOTO LEVEL 2 FOR RTS NORMAL
	JMP	RTSENT		;NOW PLAY NEXTS LIKE STUFF

ZOTALL:	MOV	#12.,-(SP)	;CLOSE ANY OPEN FILES
2$:	MOV	(SP),-(R1)	;CHANNEL # TO CLOSE
	JSR	PC,CLOSER	;CLOSE IT IF OPEN
	DEC	(SP)		;NEXT CHANNEL
	BNE	2$		;UNTIL WE GET TO CHANNEL 0
	TST	(SP)+		;GET RID OF NUMBER ON STACK
	JMP	EDRSTD		;SPDA->R0, RTS PC



; RUN IMMEDIATE MODE STATEMENT

RUNIM:	JSR	PC,CHKSCA	;SEE IF SCALE INTERLOCK SAYS DON'T RUN
	MOV	@SPTA,-(R1)	;START AT FIRST STATEMENT
	BIS	#EDIMED,EDFLAG	;AS FLAG FOR CKPASS
	BIT	#EDPRES,EDFLAG	;VARIABLES AT LEAST RESET
	BNE	1$		;ALL SET
	JSR	PC,CKPASS	;CLEAR VARIABLE AND CROSSLINK
	BR	2$		;NO NEED DO IT AGAIN

1$:	JSR	PC,CKCONT	;ONLY CROSSLINK
2$:	BNE	3$		;IF NOT IN PROPER SAAPE
	BIC	#EDIMED,EDFLAG	;LET HIM GET INTO HIS PROGRAM
3$:	BR	RTSNT1		;AND AWAY WE GO

RUN66:	TST	(R1)+		;POP OFF START LOC
RUN20:	BR	EDCTLH		;RETURN

.ENABL	LSB

;CONTINUE () CALLS RTS WITHOUT FIRST CLEARING ALL OF THE USER'S VARIABLES.
DOCCON:	BIT	#JFSYS!JFPRIV!JFNOPR,JOBF;PRIV'D FOR THE DETACH?
	BNE	10$		;YES
	ERROR	PRVIOL,FATAL	;NO, ANNOUNCE ERROR

10$:	MOV	#DOCCOX,-(SP)	;WILL DETACH US
	BR	3$		;NOW CARRY ON

DOCONT:	MOV	#EDRSTD,-(SP)	;WILL R0<=SPDA, THEN RTS PC
3$:	JSR	PC,CHKSCA	;SEE IF SCALE IS INTERRLOCKED
	TSTB	EDFLAG		;CAN WE CONTINUE?
	BMI	1$		;YEP, NO CHANGES MADE TO PROGRAM
.IIF	NE	EDCONT-200, .ERROR ;THE ABOVE WON'T WORK
2$:	ERROR	EDCONE,FATAL	;ERROR -- CANNOT CONTINUE; PROG CHANGED

1$:	BIC	#JFCC!JFCCC!JFRTS,JOBF	;CLEAR ^C FOR SO WE CAN EXECUTE
	BIC	#EDIMED!EDCONT,EDFLAG	;TURN OFF IMMEDIATE MODE CHECKING
	JSR	PC,CKCONT	;CROSSLINK AND CK NEXTING
	BNE	2$		;YOU HAVE SCREWED IT UP
	MOV	R1CONT,R1	;GET SAVED R1
	ADD	R1CORG,R1	;MAKE IT ABS
	JSR	PC,EDRCON	;REMOVE ANY STRINGS LEFT ABOVE
	JSR	PC,@(SP)+	;DO THE CO-ROUTINE
	MOV	(R1)+,R5	;GET IPC BACK
	MOV	SPTA,R4		;AND A POINTER TO THE TEXT AREA
	ADD	R4,(R1)		;MAKE SCTH ABSOLUTE
	MOV	(R1)+,SCTH	;STORE HEADER
	MOV	(R1)+,CURRIO(R0);RESTORE CURRIO
	ADD	R4,R5		;MAKE IPC ABSOLUTE
	MOV	#2,RUNLVL	;GOTO LEVEL 2 FOR RUNNING
	JMP	INTERB		;GO BABY GO

.DSABL	LSB



;HERE ON I/O ERRORS
EDERRN:	JSR	PC,EDERRS	;SAVE PS AND GOTO LEVEL 1
	BIC	#EDCOMP!EDAPND!EDGOFL,EDFLAG	;I/O ERROR WHILE COMPILING KILLS IT
	BIT	#REEROR,EDFLAG	;TO TRAP REENTRIES
	BNE	EDERR3		;FROM CLOSE
	BIS	#REEROR,EDFLAG	;TO TRAP REENTRIES
	JSR	PC,EDBUFC	;RELEASE THE INPUT BUFFER
	BR	EDERR3

;HERE ON NON-I/O ERRORS
EDERR:	JSR	PC,EDERRS	;SAVE PS AND GOTO LEVEL 1
EDERR3:	DEC	R2		;WERE WE COMPILING (LEVEL 1)?
	BNE	1$		;IF NOT THEN NO DELETION TAKES PLACE
				;GET RID OF ANY PARTIALLY COMPLETED STATEMENT
	MOV	TLLINO(R0),-(R1);ITS NUMBER IS HERE
	JSR	R5,LSTOP1	;DELETE ONLY THE PUSHPOP
	DLTPOP
	TST	GETAGV(R0)	;ANY DELETIONS?
	BEQ	1$		;NO, SKIP MAKING BADCOD
	JSR	PC,TLENER	;REMEMBER TEXT LENGTH; EVEN UP PROPTR
	JSR	PC,TLBEGH	;SET SCTH TO FIRST HEADER THIS STMT.
	MOVB	#5,(R4)		;NOTE BAD STATEMENT IN TYPE
	INC	LENGTH-TAGTYP(R4)	;ONE BYTE OF CODE
	MOV	SPTA,R5
	ADD	#TAGTYP+BADBYT,R5	;SET UP TAG
	SUB	R4,R5		;FOR PSUEDO POP
	MOV	R5,PNTR-TAGTYP(R4)	;AT BADBYT
1$:	MOV	#USRSP,SP	;RESET STACK
	BIC	#EDGOFL!REEROR!EDEOFF!TRNKER,EDFLAG	;RECORD?
	BR	EDCTLH		;TRYING TO RECOVER HDR SPACE IN ERRORS DOESNT WORK



.if eq 0		;New code 90.4.26 WJS

..PMP.	  ==	.	;##Optional patch (fall-back)**
			;	..PMP. <- 104600+TLCNTD to disable DUMP

DODUMP:	BIT	#JFPRIV,JOBF	;Are we privileged enough?
	BNE	10$		;Yes => allow either source or compiled

.iff ;eq 0		;Old code 90.4.26

DODUMP:	BIT	#JFPRIV,JOBF	;ARE WE PRIVILEGED?
	ERROR	TLCNTD,FATAL	;?WHAT?
..PMD.	==	.-2	;##OPTIONAL PATCH## ..PMD.="BNE 10$" TO ENABLE DUMP
;	BNE	10$		;YES, DON'T BOTHER TO CHECK FOR COMPILED

.endc ;eq 0		;New/old code 90.4.26

	JSR	PC,EDTMPP	;ELSE MAKE SURE WE ARE RUNNING FROM SOURCE
..NPD.	==	.-4	;##OPTIONAL PATCH##..NPD. = NOP,NOP
			;## FOR NON-PRIV'D USERS TO DUMP COMPILED FILES
10$:	CLR	-(SP)		;'START OF WRITE' ADDRESS FOR EDWBAC
	BR	EDWBIN		;PRETEND IT WAS SOME SORT OF COMPILE
DOCOMP:	JSR	PC,EDTMPP	;IS IT LEGAL TO SAVE?
	BIC	#EDIMED,EDFLAG	;
	JSR	PC,CKPASS	;CLEAN UP IMAGE
	BNE	EDCTLH		;BEFORE WRITING IT
	JSR	PC,ZOTALL	;COLLAPSE BUFFERS
	MOV	#NSTORG,-(SP)	;'START OF WRITE' ADDRESS FOR EDWBAC
EDWBIN:	JSR	PC,SAVFQB	;READ LABEL
	JSR	PC,EDWBAC	;WRITE .BAC FILE
	TST	(SP)+		;POP 'START OF WRITE' FROM STACK

;
;	WHEN THE EDITOR IS INVOKED, CONTROL MUST
;	PASS THROUGH HERE TO PRINT THE 'Ready' PROMPT.
;

EDCTLC:				;SYMBOL FOR CONTINUATION CALLS TO TL
EDCTL:
;	JSR	PC,EDRSTH	;RESET STR HDR PTR TO PREV VALUE
RTSRET:
EDCTLH:	BIT	#EDCOMP,EDFLAG	;DON'T TYPE READY IF
	BNE	RTSRER		;THIS IS GOING TO BE A COMPILE JOB
	BIT	#JFEXIT!JFWIPE,JOBF ;DON'T TYPE READY IF
	BNE	RTSRER		;GOING TO EXIT OR WIPE OUT THE IMAGE
	JSR	PC,READY
RTSRER:	MOV	#JOBF,R4	;GET JOB FLAG POINTER
	BIT	#JFEXIT,(R4)	;TIME TO EXIT?
	BEQ	10$		;NO
	CLR	FIRQB+FQNAM1	;YES, SET RETURN TO PERSONAL DEFAULT RTS
	.RTS			;AND SWITCH TO IT...
	BIC	#JFEXIT,(R4)	;SWITCH TO SELF, CLEAR THE EXIT FLAG
	BR	EDCTLH		; AND LOOP

10$:	BIT	#JFWIPE,(R4)	;WIPE OUT THIS PROGRAM IMAGE?
	BEQ	20$		;NO
	BIC	#JFBREK!JFTRAC,JOBF ;YES, DISABLE BREAK AND TRACE
	MOV	#SFIRQB+FQBSIZ,R4 ;POINT TO JUST BEYOND SAVED FIRQB
.ASSUME	SFIRQB	LT USRSP	;CLEARING TO 0; DON'T WIPE CRITICAL STUFF
15$:	CLR	-(R4)		;MAKE THE SAVED FIRQB (SYS(12)) EMPTY
	TST	R4		;END OF MEMORY YET?
	BNE	15$		;NO
	CLR	-(R1)		;SIGNAL "NONAME" FOR A NAME
	JMP	DONCLR		; AND FAKE A 'NEW' COMMAND

20$:	MOV	#-JFFPP-1,XRB	;SET TO DROP ALL BUT FPP
	.CLEAR			;NOW DROP THEM ON THE FLOOR
	BIC	#JFEXIT!JFWIPE!JFCCC,(R4) ;NOW CLEAR THESE BITS ALSO
	MOV	SPDA,R0		;GET BASE REGISTER FOR DATA AREA
	MOV	#BLINEF,STAT(R0);CLEAR LA'S LINE BUFFER
	CLR	BASE+BYTCNT(R0)	;CLEAR ANY REMNANTS FOR RTS BUFFER
	MOV	#1,RUNLVL	;GOTO EDITOR LEVEL
	JSR	PC,EDCCTS	;SEE IF ^C TYPED
	JMP	TL		;FROM BEGINNING

DOTAPE:	.TTAPE			;TAPE COMMAND
	BR	RTSRER		;SIMPLE...

DOEXIT:	BIS	#JFEXIT!JFWIPE,JOBF ;EXIT, OR AT LEAST CLEAR CORE
	BR	EDCTL		; EXIT TO PRIVATE DEFAULT RTS
;	.EXIT			; EXIT TO SYSTEM DEFAULT RTS



EDERRS:	MOV	RUNLVL,R2	;GET PRIOR RUNNING LEVEL
	MOV	#1,RUNLVL	;THEN GOTO LEVEL 1
	BR	EDERR5

EDRSR1:	MOV	R1CORG,R1	;RESET R1 STACK
	MOV	SPDA,R0		;SET BASE
	CLR	GOSUB(R0)	;NOT INTO GOSUB'S IF R1 STACK RESET
EDRCON:	MOV	R1,R4		;AND REMOVE HEADERS
	BR	EDRSHM

EDRSTH:	MOV	SPDA,R0		;SET UP BASE
	MOV	TLMIND(R0),R4	;OLD POINTER
	MOV	R4,MDD(R0)	;POSTED SO AS TO RETRIEVE HDR SPC
	ADD	R0,R4		;MAKE ABS
EDRSHM:	BIC	#EDCONT,EDFLAG	;R1 STACK RESET--CONT CONTINUE
	MOV	R0,R3		;CLEAR ANY STRINGS IN HDR AREA OR ON R1 STACK
EDERR4:	ADD	(R3),R3		;NEXT ITEM
	CMP	R3,R4		;ON STACK?
	BLO	EDERR4		;YES, KEEP GOING
	SUB	R0,R3		;NO, MAKE THIS BEGINNING OF POST-R1 LIST
	MOV	R3,(R0)		;AND INSTALL IN LAST PRE-R1 LINK
EDERR5:	JMP	EDRSTD		;SPDA TO R0 THEN RTS PC....

DOLENG:	.STAT			;GET STATUS
	MOV	XRB+4,-(R1)	;SAVE USER'S PRIVATE MAX
	MOV	XRB+0,-(R1)	;SAVE USER'S CURRENT SIZE
	JSR	PC,LENNUM	;PRINT AN UNSPACED NUMBER
	CALLX	PRINTX,R3,<'(>	;NOW PRINT THE "("
	JSR	PC,LENNUM	;PRINT AN UNSPACED NUMBER
	CALLX	PRINTX,R3,<')>	;NOW PRINT THE ")"
	MOV	#KSIZEM,R2	;"K OF MEMORY USED"
	JSR	PC,PRINTL	; SO PRINT IT
BRBACK:	BR	EDCTL		;AND CONTINUE

DOUNSA:	JSR	PC,SAVFQB	;GET A FIRQB WITH ARGUMENT PARSED IN IT
	JSR	R5,EDFIP1	;DELETE A FILE
	.RAD50	/BAS/		;DEFAULT EXTENSION
	+	DLNFQ		;DELETER
	BCC	EDCTL		;UNSAVE WORKED!
	IOTERR	!FATAL		;NO SUCH FILE--COMPLAIN



;CATALOG COMMAND
DOCATA:	JSR	PC,SSOCH0	;SELECT CHANNEL #0
	JSR	PC,SAVFQB	;GET A FIRQB

; V9.7 maintenance article 4.1.6 retired	90.4.26 WJS
;	BR	1$		;POSSIBLE PPN CLEAR
;..CAT.	==	.-2	;**PATCH** 'CLR X(R4)' FOR NO PPN'S
;	 .WORD	FQPPN		; THE INDEX WORD FOR THE ABOVE

1$:	CLR	FQFIL(R4)	;START WITH FIRST FILE
2$:	JSR	R5,EDFIPK	;KEEP FIRQB UNLESS ERROR
	+	DIRFQ		;DIRECTORY LOOKUP (INDEXED)
	BCS	BRBACK		;RETURNS THE FIRQB WHEN NO MORE TO POOL
	TSTB	JOBF		;DOES HE WANT OUT
	BMI	BRBACK		;YES--LET GO THEN
	MOV	R4,-(SP)	;SAVE FIRQB
	MOVB	FQNENT(R4),R5	;GET # OF ENTRIES TO TYPE
	MOV	#DIRPRT,R3	;POINT TO FORMAT LIST
	ADD	#FQNAM1,R4	;TEMP SOURCE
	JSR	PC,CATALP	;FANCY PRINTER
	MOV	(SP)+,R4	;RESTORE FIRQB
	INC	FQFIL(R4)	;NEXT FILE ENTRY
	CLR	FQMODE(R4)	; CLEAR M-F-D BIT, BUG FIX 1/88
	BR	2$

HEADER:	CLR	-(R1)		;DATE$(0) IS TODAY
	CLR	-(R1)		;TIME$(0) IS RIGHT NOW!
	.DATE			;GET PROBLEM NAME
	MOV	XRB+XRCI+2,-(R1)	;PNAME+2
	MOV	XRB+XRCI,-(R1)	;PNAME
	MOV	#HEAPRT,R3	;USE THE FORMATTER
	MOVB	(R3)+,R5	;# OF ENTRIES FOR HEADER
CATALP:	CMP	R3,#HEAPRT
	BHIS	2$
	MOV	(R4)+,-(R1)	;ITEM
2$:	MOVB	(R3)+,R2	;ROUTINE TO PROCESS IT
	JSR	R5,EDSAVE
	MOVB	(R3)+,-(SP)	;SAVE CHARACTER TO FOLLOW
	JSR	PC,@CATPRT(R2)	;PRINT IT
	MOVB	(SP)+,R2	;FOLLOW WITH THIS CHARACTER
	BEQ	3$		;BRANCH IF NULL
	CALLX	PRINTC,R3	;PRINT IT
3$:	JSR	R5,EDREST
	INC	R3		;POP BY THE DELIMITER
	SOB	R5,CATALP	;LOOP UNTIL DONE
	JSR	PC,CRLF		;NEW LINE
	JMP	EDRSTD		;RESET R0 TO CURRENT SPDA AND EXIT..

PRTIME:	JSR	PC,TIME07	;GET STRING OF TIME
	BR	PRDAT1		;AND PRINT IT

PRDATE:	JSR	PC,DATE07	;MAKE THE STRING
PRDAT1:	JMP	PRINTS		;PRINT IT




CATPRT:	.WORD	RAD50A		;PRINT RADIX 50
	.WORD	20$		;DO SIZE
	.WORD	PRDATE		;PRINT A DATE
	.WORD	PRTIME		;PRINT A TIME
	.WORD	10$		;DO PROT

10$:	CLRB	1(R1)		;ENSURE A BYTE VALUE
	JMPX	PRINTI		; AND GO PRINT <PROT>

20$:	CLR	-(R1)		;CLEAR HIGH ORDER
	MOVB	1(R4),(R1)	;NOW SET HIGH ORDER FILE SIZE
	BITB	FQNENT+1-<FQSIZ+2>(R4),#20 ;CONTIGUOUS?
	BEQ	PRINTD		;NO, JUST PRINT IT
	CALL	PRINTD		;YES, PRINT IT
	CALLX	PRINTX,R3,<'C>	;SAY FILE IS CONTIGUOUS WITH A 'C'
	RETURN			;NOW EXIT

LENNUM:	JSR	PC,SSOCH0	;SELECT CHANNEL #0
	CLR	-(R1)		;CLEAR NUMBER'S HIGH ORDER
PRINTD:	CALLX	CNV2IF		;FLOAT THE DOUBLE INTEGER
	MOV	#$PLSIG,$.PLCS	;ENSURE A FULL CONVERSION & NO SPACE(S)
	CALLX	NUM$XX		;GO DO THAT PRINT CONVERSION
	JMP	PRINTL		; AND PRINT IT

DIRPRT:	.BYTE	0,0		;FILE
	.BYTE	0,'.		;NAME .
	.BYTE	0,11		;EXT 	
	.BYTE	2,11		;SIZE -->
	.BYTE	10,11		;PROT -->
	.BYTE	4,40		;ACCESS DATE -->
	.BYTE	4,40		;CREATION DATE -->
	.BYTE	6,0		;CREATION TIME

HEAPRT:	.BYTE	4		;NUMBER OF ITEM
	.BYTE	0,0		;FILE
	.BYTE	0,11		;NAME
	.BYTE	6,11		;TIME
	.BYTE	4,0		;DATE
	.EVEN

	.sbttl	Dummy debug module

	TMPORG	EDEB		;MAY BE OVERLAID BY DEBUGGING ROUTINES
EDEB:
DOTRAC:	ERROR	TLCNTD,FATAL	;?WHAT?
	.ASSUME	DOTRAC	EQ EDEB	;MUST BE AT RELATIVE ZERO
DOUNTR:	ERROR	TLCNTD,FATAL	;?WHAT?
	.ASSUME	DOUNTR	EQ EDEB+2 ;POSITION IS IMPORTANT
DOBREK:	ERROR	TLCNTD,FATAL	;?WHAT?
	.ASSUME	DOBREK	EQ EDEB+4
DOUNBR:	ERROR	TLCNTD,FATAL	;?WHAT?
	.ASSUME	DOUNBR	EQ EDEB+6

	UNORG

	.sbttl



;SAVE([FILENAME])
;MAKE A .BAS FILE ORDERED BY STATEMENT # - REQUIRES
;COMPLETELY REORGANIZING FILE ON A STATEMENT BY STATEMENT BASIS.

DOSAVE:	JSR	PC,SAVFQ	;GET NEW NAME IF ANY
	MOV	#-1,FQERNO(R4)	;DO A NORMAL LOOKUP
	JSR	R5,EDFIP1	;NO SUCH IF I MUSTN'T
	.RAD50	/BAS/		;.BAS FOR THE EXTENSION
	+	LOKFQ		;LOOK UP .BAS IF ANY
	BCS	REPLAC		;IF NOT ALREADY SAVED
	ERROR	EDARSV,FATAL	;PROBLEM ALREADY SAVED,USE REPLACE

DOREPL:	JSR	PC,SAVFQ	;INSTALL NEW NAME
REPLAC:	JSR	PC,EDBASI	;SET UP CHANNEL
	JSR	R5,EDFIP1	;CALL FIP FOR
	.RAD50	/BAS/		; (DEFAULT EXTENSION)
	+	RSTFQ		;CLOSING SLOT IF NEEDED
	MOVB	#CREFQ,FQFUN(R4);SET THE CREATE FUNCTION
	JSR	R5,EDOI10	;OPEN IT
	+	OPNI11		;(REALLY CAL FILE PROCESSOR)
	MOV	#BASCH,-(R1)	;OPEN BASCHN
	JSR	PC,SSONRC
	CLR	-(R1)		;OUTPUT ALL THE STATEMENTS
	MOV	#77777,-(R1)	;0 TO INFINITY
	MOV	SPDA,R0
	JSR	R5,LSTOP2	;PSEUDO-LIST
	LISTNN
	JSR	PC,EDBUFC	;DEALLOCATE AND CLOSE BAS FILE
	JMP	EDCTL

SAVFQ:	JSR	PC,EDTMPP
SAVFQB:	JSR	PC,TLGPDS	;GET ANY FILE NAME
	BR	SAVE1		;THEN USE CURRENT ONE
	JSR	PC,EDPUSS	;SPREAD OUT HEADER
	MOV	#BASCHN,R2	;SET UP EDITOR CHANNEL
	JSR	PC,OPNR20	;MAKE A FIRQB
	TST	FQNAM1(R4)	;SEE IF ONLY A DEVICE SPECIFIED
	BNE	1$		;NO, A NAME GIVEN
	.DATE			;GET NAME
	MOV	XRB+XRCI,FQNAM1(R4)	;NAME
	MOV	XRB+XRCI+2,FQNAM1+2(R4)	;NAME+2
1$:	JMP	TLGTOK		;NEXT TOKEN PLEASE

SAVE1:	JSR	PC,EDFIRQ	;MAKE ONE WITH CURRENT NAME
EDBASI:	MOV	#BASCHN,FQFIL(R4)	;SET UP BAS CHANNEL
	RTS	PC



.ENABL	LSB

EDBUFC:	JSR	R5,EDSAVE
	MOV	#BASCH,-(R1)	;DEALLOC AND CLOSE
	JSR	PC,SSO01
	JSR	PC,CLSR09
	BR	10$

EDCLR:	MOV	R4,-(SP)	;SAVE OLD R4
	MOV	#FIRQB+2,R4	;USEFUL POINTER
	MOV	(R4)+,-(SP)	;SAVE JOB
	MOV	(R4),-(SP)	;FQFIL
	CLR	(R4)		;RESET ALL
	MOV	R4,-(SP)	;SAVE THIS POINTER FOR RESTORING
	CMP	-(R4),-(R4)	;AND BACK IT FOR EDFIPK
	JSR	R5,EDFIPK	;CLOSE ALL FILES
	+	RSTFQ
	MOV	(SP)+,R4	;RESTORE POINTER NOW
	MOV	(SP)+,(R4)	;FQFIL BACK
	MOV	(SP)+,-(R4)	;JOB
	MOV	(SP)+,R4	;RESTORE R4 AND
EDCLRF:	BIC	#EDFIRS+EDETMP+EDNEWF+EDPRES+EDCONT,EDFLAG ;INDICATE NO .TMP
	RTS	PC

;EDSCAN([FILENAME])
;USES RTS SCAN TO PARSE AND STORE A FILENAME
;TO NAME1 TABLE

EDSCAN:	JSR	R5,EDSAVE	;PROTECTION AGAINST RTS RAVAGES
	JSR	PC,OPNR20	;SORTS IT OUT, LEAVES IN FIRQB
	.NAME			;INSTALL NAME
10$:	JMP	DLTONR		;EDREST,SPDA TO R0,RTS PC

.DSABL	LSB



;WRITE .BAC VERSION - SEE READING OF .BAC FOR COMMENTS

EDWBAC:	.STAT			;GET STATUS
	MOV	XRB+XRLEN,R3	;SIZE
	ASL	R3		;TIMES 2 NOW
	ASL	R3		;TIMES 4 NOW FOR SEGMENT SIZE
	TST	FQCLUS(R4)	;CLUSTER SIZE SPECIFIED?
	BNE	99$		;YES
	MOV	#-4,FQCLUS(R4)	;NO, SET OPTIMUM CLUSTER SIZE
99$:	MOV	#BACCHN,FQFIL(R4) ;USE CHANNEL 15.
	MOV	2(SP),-(SP)	;MOVE "NSTORG" TO TOP OF STACK
	BEQ	30$		;IF PMD, SKIP THIS
	TST	FQEXT(R4)	;EXPLICIT .EXTENSION?
	BNE	98$		;YES
	MOV	@#P.DEXT,FQEXT(R4) ;SET DEFAULT EXECUTABLE EXTENSION
98$:	BIS	#100100,FQMODE(R4) ;.OR. IN CONDITIONAL CTG MODE
	DEC	R3		;LESS 1 FOR 1ST BLOCK
30$:	MOV	R3,FQSIZ(R4)	;SET SIZE IN SEGS FOR .BAC FILE
	JSR	R5,EDFIP1	;CALL THE FIP PROCESSOR
	.RAD50	/PMD/		;FOR DUMP, @#P.DEXT WAS NOT USED
	+	CRBFQ		;AND CREATE/OPEN IT SAVING FIRQB
	BCC	97$		;ALL O.K.
	IOTERR	!FATAL		;ELSE ERROR

97$:	MOVB	#.MATH.,-(R1)	;SET MATH TYPE (FLT OR INT/DEC)
	BNE	1$		;IF INT/DEC THEN LEAVE IT
	MOVB	SCAUPV,(R1)	;ELSE SET USER'S SCALING FACTOR
	NEGB	(R1)		;AND MAKE IT NEGATIVE
1$:	MOVB	#FLTLEN,-(R1)	;SET FLOATER SIZE ALSO
	MOV	#R5RING,R5	;POINTER TO CSR'S
	MOV	#15.,R2		;COUNT OF CSR'S
	MOV	R2,-(SP)	;ON STACK ALSO
9$:	MOV	(R5)+,-(R1)	;SAVE A CSR ON THE R1 STACK
	SOB	R2,9$		;LOOPING...
	MOV	(SP)+,-(R1)	;SAVE COUNT OF CSR'S
	MOV	R5,-(R1)	;SAVE POINTER TO CSR AREA+2
	MOV	#SYSVEL,-(R1)	;THEN SYSTEM PARAMETERS
	MOV	(PC)+,-(R1)
.IF	EQ	SYSVEE&177400
	.BYTE	SYSVEE,BASVEN
.IFF
	.BYTE	SYSVEE/400&377,BASVEN
.ENDC
	MOV	#NSTORG+2,R5	;GET ADDRESS TO START WRITING (NSTORG)
	MOV	R1,(R5)		;SAVE R1 STACK HERE
	CLR	-(R5)		;BACK AND CLEAR HASH SPOT
	MOV	(SP),R0		;AND THEN FIND THE STARTING POINTER
	SWAB	R3		;FIND # WORDS TO COMPUTE WITH
	MOV	R3,R2		;AND SAVE IT
10$:	ADD	(R0)+,(R5)	;AND COMPUTE HASH TOTAL
	SOB	R3,10$		;LOOPING THROUGH CORE...
	MOV	#XRB,R3		;PARAMETER BLOCK
	ASL	R2		;BYTES NOW
	MOV	R2,(R3)+	;LENGTH @ XRLEN
	MOV	R2,(R3)+	;BYTCNT @ XRBC
	MOV	(SP)+,(R3)+	;START HERE @ XRLOC
	MOV	(PC)+,(R3)+	;CHANNEL INDEX @ XRCI & 0 @ XRBLKM
	 .BYTE	BACCHN,0
	CLR	(R3)+		;SERIAL @ XRBLK
	CLR	(R3)+		;NO TIME @ XRTIME
	CLR	(R3)+		;NO MODIFIERS @ XRMOD
	.WRITE			;AND WRITE IT
	JSR	PC,EDR1		;AND FINISH UP
	ADD	#15.+5.*2,R1	;CORRECT R1 STACK
	JSR	R5,EDFIPK	;CLOSE THE FILE
	+	CLSFQ		;BUT DO NOT REMOVE THE BUFFER!!
	BR	EDLDF1



EDOI10:	JSR	R5,EDSAVE	;EDITOR'S CALL TO BUFFER MANAGER
	MOV	#BASCHN,R2	;ALLOCATE BUFFER WITH SIZE
	CLR	-(R1)		;SIGNAL FOR DEVICE DEPENDANCY
	JSR	PC,@(R5)+	;CALL THE CORRECT ROUTINE
	JSR	R5,EDREST	;RESTORE R0,R2,R3,R4,R5
	TST	(R5)+		;SKIP THE ROUTINE ADDRESS
	RTS	R5		;AND RETURN

;	RENAM ([FILENAME]) COMMAND ROUTINE
DORENA:	JSR	PC,TLGDFN	;DEMAND A NEW NAME
	JSR	PC,EDPUSS	;SPLAY HEADER
	JSR	PC,EDSCAN	;SAVE THE NEW NAME
	JMP	EDCTLC

;EDTMPP SETS UP A TMP FILE IF POSSIBLE.
;RETURN:	Z=1 IF NO TMP FILE
;		Z=0 IF THERE IS ONE

EDTMPP:	JSR	PC,20$		;GET FLAGS
	BIT	#EDFIRS,R2	;SET AFTER FIRST CALL
	BEQ	1$		;FIRST CALL SINCE EDCLR
3$:	MOV	R2,EDFLAG	;PUT FLAGS BACK IN CORE
	BIT	#EDETMP,R2	;RETURN Z BIT
	BEQ	10$		;ERROR
	RTS	PC		;O.K.

1$:	BIC	#EDNEWF+EDETMP,EDFLAG	;IN CASE OF ERROR
	JSR	R5,EDFIP
	.RAD50	/TMP/
	+	CRTFQ		;HANG ONTO FIRQB IF NO ERROR
	CLR	BASCUR(R0)	;NEW TEXT GOES AT BEGINNING
	CLRB	BASCUM(R0)	;(MSB ALSO)
	MOV	#TMPCH+1*IOLEN+BASE+FLAGS,R2	;IOB POINTER
	ADD	R0,R2
	BICB	#WRTARY,(R2)	;NOT CHANGED YET
	JSR	PC,20$
	BIS	#EDFIRS+EDETMP,R2	;NOW WE KNOW THAT .TMP LIVES
	BR	3$		;RETURN Z BIT

10$:	ERROR	EDEXON,FATAL	;NO SYMBOLIC

; LOADS FLAGS INTO R2, ALSO SETS UP R0 TO SPDA

20$:	MOV	EDFLAG,R2
	BR	EDLDF1



;EDFIRQ MAKES A FIRQB WITH CURRENT FILENAME
;INFO, .TMP CHANNEL, SIZE=0, DEFAULT PROTECTION

EDFIRQ:	JSR	PC,GETBUF	;SET UP R4 AND CLEAR FIRQB
	MOV	#TMPCHN,FQFIL(R4)	;CHANNEL
	.DATE			;GET NAME
	MOV	XRB+XRCI,FQNAM1(R4)	;NAME 1
	MOV	XRB+XRCI+2,FQNAM1+2(R4)	;NAME1+2
	MOV	USRPRT,FQPROT-1(R4);SET DEFAULT PROT IF ANY
EDLDF1:	JMP	EDRSTD		;SPDA TO R0, RTS PC
;EDFIP IS EDITORS CALL TO FIP -- IT HANDLES ERRORS
;	JSR	R5,EDFIP
;	.RAD50	/BAS/		;FILE EXTENSION
;	.WORD	OPNFQ		;FUNCTION
;				RETURNS C=1 NO SUCH FILE
;				RETURNS C=0 NO ERRORS
;				DOESN'T RETURN IF OTHER ERROR
;ENTRY FOR NON-FILE REQUESTS
EDFIPN:	JSR	PC,EDFIRQ
	BR	EDFIPK

EDFIP:	JSR	PC,EDFIRQ	;GET A PRELOADED FIRQB
EDFIP1:	TST	FQEXT(R4)	;EXTENSION SUPPLIED?
	BNE	10$		;YEP
	MOV	(R5),FQEXT(R4)	;NOPE, SO SUPPLY ONE
10$:	TST	(R5)+		;AND SKIP THE ARGUMENT
EDFIPK:	MOVB	(R5),FQFUN(R4)	;FUNCTION TO FIRQB
	CALFIP			;EXECUTE REQUEST
	CHKERR	NOTCLS,(R4)	;SEE IF IT WAS STILL OPEN
	BNE	5$		;OK IF NOT
	MOVB	#RSTFQ,FQFUN(R4);THEN CLOSE IT BY RESETTING
	CALFIP			;AND TRY AGAIN
	BR	EDFIPK

5$:	TST	(R5)+		;SKIP OVER FUNCTION IN CALL
	TSTB	(R4)		;ANY ERROR?
	BEQ	EDFNER		;IF NOT
	CHKERR	NOSUCH,(R4)	;IS IT A "NO SUCH FILE" ERROR?
	BNE	EDFERR		;NO, SO SIMPLY PANIC
	SEC			;INDICATE NO SUCH FILE
EDFNER:	MOV	SPDA,R0		;RESTORE SPDA
	RTS	R5

EDFERR:	IOTERR	!FATAL		;SIGNAL I/O ERROR



;BASGET (ADDRESS)		GET A CHARACTER FROM THE
;				CURRENT .TMP FILE (WHICH
;				WILL BE MADE INTO THE .BAS FILE)
;EDSTOR (CHAR)			PUTS CHAR IN NEXT SEQUENTIAL LOC
;				IN .TMP FILE AND ADVANCES LOC.
;				(STORED IN BASCUR).
;				EDSTOR EITHER WRITE THE CHARACTER OUT OR
;				IGNORES IT DEPENDING ON THE COMPIL FLAG
BASGET:	JSR	R5,EDSAVE	;MAKE SOME WORKSPACE
	CLR	-(SP)		;FLAG FOR GET ENTRY
	BR	BASG01

EDSTOR:	MOV	R2,-(R1)	;MATCH LA CONVENTIONS
	BIT	#JFNOPR,JOBF	;SEE IF LOGGED IN
	BEQ	3$		;BRANCH IF NO STORE ALLOWED
	ERROR	PRVIOL,FATAL	;TELL THE WORLD HE SHOULD LOG IN

3$:	JSR	R5,EDSAVE	;R0 AT TOP OF R6 STACK
	MOV	PC,-(SP)	;FLAG FOR PUT ENTRY
	MOV	SPDA,R0		;FOR CONVENIENT USE
	MOV	BASCUR(R0),-(R1);ADDRESS TO STORE AT
	MOVB	BASCUM(R0),-(R1); WITH MSB ALSO
BASG01:	JSR	PC,EDTMPP	;IS THERE A .TMP NOW?
	MOVB	(R1)+,R2	;GET MSB AND THE
	MOV	(R1)+,R3	; LSB OF .TMP FILE ADDRESS
	DIV	#1000,R2	;FIND BLK# AND BYTE POINTER
	MOV	R3,R5		;PUT BYTE POINTER INTO HERE
	INC	R2		;FIP STARTS AT 1
	MOV	SPDA,R0		;BASE FOR GLOBALS
	JSR	PC,BASPFB	;IOB TO R3
	CMP	R2,CURBLK(R3)	;IF SEG ALREADY IN BUFFER
	BEQ	2$		;NO NEED DIDDLE BUFFER
	JSR	PC,BASF01	;FORCE OUT OLD SEG IF MODIFIED
1$:	MOV	R2,CURBLK(R3)	;NEW BLOCK
	TST	(SP)		;IS IT 'WRITE'?
	BEQ	5$		;NO, READ
	TST	R5		;NO READ ON 'WRITE'ING
	BEQ	6$		;FIRST BYTE OF NEW BLOCK
5$:	JSR	PC,READ.	;CALL FOR DATA
	JSR	PC,EDR1		;CHECK FOR ANY ERRORS
6$:	BICB	#WRTARY,FLAGS(R3)	;INDICATE VIRGIN



2$:	ADD	#BASBUF,R5	;ADD IN BUFFER ADX
	ADD	R0,R5		;ABS BYTE ADDRESS
	TST	(SP)		;SEE IF RD OR WR
	BNE	7$		;IF WR
	CLR	-(R1)		;AVOID ODD LOC FOR R1
	BISB	(R5),(R1)	;READ CH
	BR	9$

7$:	MOVB	(R1),(R5)	;STORE NEW ONE
	BISB	#WRTARY,FLAGS(R3)	;SET MEDDLED BIT
	CLR	BYTCNT(R3)	;SIGNAL THIS WAS A RANDOM ACCESS
	ADD	#1,BASCUR(R0)	;# STORED
	ADCB	BASCUM(R0)	; WITH A CARRY
	TST	(R1)+		;POP ARG
9$:	TST	(SP)+		;POS R/W SWITCH
	JSR	R5,EDREST	;RESTORE
	RTS	PC

;GET IOB POINTER IN R3

BASPFB:	MOV	#TMPCH+1*IOLEN+BASE,R3	;REL
	ADD	R0,R3		;NOW ABS
	MOV	PNTR(R3),CURLOC(R3)
	RTS	PC


;FORCE OUT THE CURRENT SEGMENT

BASFRC:	JSR	PC,BASPFB	;IOB PTR TO R3
	BIT	#EDETMP,EDFLAG	;IS THERE A TMP FILE?
	BEQ	EDCCT1		;DO NOTHING IF NOT
BASF01:	BITB	#WRTARY,FLAGS(R3)	;NEED TO WRITE IT?
	BEQ	EDCCT1
	MOV	LENGTH(R3),BYTCNT(R3)	;SET FULL WRITE COUNT
	JSR	PC,WRITE.	;WRITE SUBR
	BICB	#WRTARY,FLAGS(R3)	;VIRGIN NOW
EDR1:	TSTB	IOSTS		;CHECK FOR ERRORS
	BNE	EDFERR		;COMPLAIN
EDCCTS:	MOV	SPDA,R0		;GET DATA AREA BASE
	TSTB	JOBF		;SEE IF ^C TYPED
	BPL	EDCCT1		;NOPE
	BIC	#JFCC,JOBF	;CLEAR IT
	BIC	#EDCOMP!EDAPND!EDGOFL!EDEOFF,EDFLAG	;GET INPUT FROM TYT
	MOV	#BLINEF,STAT(R0);TELL LA ABOUT THIS
EDCCT1:	RTS	PC



;EDFTCH GET A CHARACTER EITHER FROM THE TTY OR FROM A .BAS FILE,
;DEPENDING ON THE COMPILE FLAG.
EDFTCH:	JSR	R5,EDSAVE	;PROTECT OTHER PEOPLES R'S
	JSR	PC,R1SCHK	;GUARANTEE SOME STACK
	BR	GETBYT
GBNONE:	CLR	-(R1)		;CHANNEL ZERO
	BIT	#EDCOMP,EDFLAG	;FROM TTY OR ELSEWHERE?
	BEQ	GBNON1		;TTY
	MOV	#BASCH,(R1)	;CHANNEL FOR RANDOM PLACE
GBNON1:	JSR	PC,SSO01
	JSR	PC,SSIX1

GETBYT:	MOV	SPDA,R2		;MAKE A POINTER
	ADD	#BASE,R2	;TO THE BUFFER
	DEC	BYTCNT(R2)	;ONE LESS CHAR
	BLT	GBNONE		;GET A NEW BUFFER FULL
	MOV	R2,R0		;TO WORK ON
	ADD	CURLOC(R0),R0	;LOC IN BUFFER
	INC 	CURLOC(R2)	;UPDATE IT
	CMPB	(R0),#'D-100	;IS THIS CONTROL/D?
	BNE	10$		;NOPE
	BPT			;YES, CALL ODT (IF THERE!)
10$:	CLR	-(R1)		;PUT IT ON STACK
	MOVB	(R0),(R1)	;BYTEWISE THAT IS
	JMP	DLTONR		;EDREST, SPDA TO R0, RTS PC



;CKPASS CHECKING PASS-INVOKED JUST BEFORE PROGRAM IS RUN.
;ROUTINE TO LINK DATA STATEMENTS, TO CROSS LINK FOR & NEXT STATEMENTS,
;AND TO PROVIDE ERROR CHECKING FOR "FOR" STATEMENTS AND MULTI-LINE "DEF"
;BEING PROPERLY NESTED.  IT SCANS THE STATEMENT LIST AND PUSHES FOR & MULTI-LINE
;DEFS.  ON ENCOUNTERING A NEXT IT POPS ITEM WHICH MUST BE CORRESPONDING
;FOR--AT WHICH TIME IT CROSS LINKS THEM.  WHEN ENCOUNTERING ENDDEF IT
;POPS ITEM WHICH MUST BE MULTI-LINE DEF. IF CORRESPONDENCE FAILS IT ISSUES A
;COMPLAINT, CONTINUES SCAN BUT INHIBITS RUNNING.

CKPASS:	JSR	PC,PRESET	;PRESET ALL VARIABLES TO ZERO
	BIS	#EDPRES,EDFLAG	;AND SAY THAT WE DID IT
	JSR	PC,RESTOR	;RESTORE THE DATA STATEMENTS
	CLR	WAITTM(R2)	;CLEAR CONSOLE TTY WAIT TIME
	CLR	OEGTLN(R2)	;NO ON ERROR GOTO
	CLR	RESLOC(R2)	;NOT RECOVERING FROM ERRORS
	MOV	#RANDYL,RNDML(R2);RESET TO RANDOM
	MOV	#RANDYH,RNDMH(R2); NUMBERS
	MOV	(R1)+,R5	;SAVE START LOC
	JSR	PC,EDRSR1	;RESET R1 STACK SO R1CORG GOOD TOP CHECK
	MOV	R5,-(R1)	;RESTORE START LOC
CKCONT:	MOV	R1,R1RING	;USE FOR TOP OF STACK CHECKING
	BIC	#CKEBIT+CKDEFB,EDFLAG	;CLEAR ERROR FLAG
	MOV	SPTA,R0		;BEGIN SCAN
	MOV	R0,R2		;WANT TO KEEP SPTA IN R2
CPLOO1:	TST	(R0)		;TEST LINK
	BEQ	CPDONE		;END OF STATEMENT LIST
	ADD	(R0),R0		;PICK UP LINK
	MOV	R0,-(SP)	;KEEP A RELATIVE VERSION
	SUB	R2,(SP)		;MAKE REL TO SPTA, WHY NOT?
CPPOST:	MOV	R0,SCTH		;POST FOR ERRORS
	TST	TAGPUL(R0)	;IF 0 STATEMENT
	BEQ	CPLOOP		;NOT REALLY THERE
	CLR	-(SP)		;PLACE FOR ARITHMETIC
	MOVB	TAGTYP(R0),(SP)	;TYPE TO DISPATCH ON
	ASL	(SP)		;TIME TWO
	ADD	(SP)+,PC	;INTO PC
	BR	CPLOOP		;0 NULL - SKIP STATEMENT
	BR	CPLOOP		;1 ARRAY
	BR	CPEDEF		;2 ENDDEF
	BR	CPNEXT		;3 NEXT
	BR	CPLOOP		;4 DATA
	BR	CPLOOP		;5 ERROR ON COMPILING STATEMENT
	BR	CPPDEF		;6 DEF-MULTI
	BR	CPPUSH		;7 FOR
	BR	CPSLDF		;10 SINGLE LINE DEF
	BR	CPLOOP		;11 END OF DIM STATEMENT
CPPUSH:	MOV	(SP),-(R1)	;SAVE TAG
	MOV	(SP),-(R1)	;TWICE
CPLOOP:	JSR	PC,R1SCHK	;GUARANTEE R1 STACK SPACE
	MOV	SPTA,R2		;RESTORE IN CASE OF RELOC
	MOV	R2,R0		;REMAKE POINTER
	ADD	(SP)+,R0	;IN R0
	BR	CPLOO1



CPUDFC:	JSR	R0,CPEROR	;SAY ERROR
	ERROR	CPUPDF		;NON-FATAL -- "DEF W/O FNEND"
CPDON2:	MOV	SPTA,R2		;RESET BASE
CPDONE:	CMP	R1,R1RING	;IF STACK NOT BACK UP
	BEQ	CPDON1		;SOME BEGINS HAVE NOT BEEN ENDED
	ADD	R2,(R1)		;ADD SPTA
	MOV	(R1)+,SCTH	;AND R1 TELLS WHICH ONES
	TST	(R1)+		;AND THIS TELLS WHICH KIND
	BEQ	CPUDFC		;IF DEF
	JSR	R0,CPEROR	;REPORT ERROR
	ERROR	CPUPFR		;NON-FATAL -- "FOR W/O NEXT"
	BR	CPDON2		;SEE IF MORE 

CPDON1:	MOV	#SPTA,R0	;POINT TO START OF TEXT AREA
	MOV	(R0),-(R0)	;SET SCTH (START CUR TEXT HDR) TO STMT 0
.IIF	NE	SCTH+2-SPTA, .ERROR ;THE ABOVE WON'T WORK
	ADD	@(R0)+,-(R0)	; AS SPTA + @SPTA
	MOV	SPDA,R0		;RESET BASE
	BIT	#CKEBIT,EDFLAG	;SET FOR EXIT
	RTS	PC		;QUIT

CPPDEF:	BIT	#CKDEFB,EDFLAG	;BEEN A DEF UNPAIRED SO FAR?
	BNE	CPPDE1		;YES, KICK ABOUT TWO DEF IN ROW
	BIS	#CKDEFB,EDFLAG	;SET FLAG TO INDICATE IN DEF
	CLR	-(R1)		;INDICATE DEF WITH A ZERO
	MOV	(SP),-(R1)	;PUSH STATEMENT
	BR	CPLOOP

CPPDE1:	JSR	R0,CPEROR	;REPORT ERROR
	ERROR	CPNSDF		;NON-FATAL -- "ILLEGAL DEF NESTING"
	BR	CPLOOP		;NEXT STATEMENT

;MUST BE A "DEF" ON STACK
CPEDEF:	BIT	#CKDEFB,EDFLAG	;TEST CKDEFB FLAG
	BEQ	CPEDFC		;BR IF IT'S OFF
	BIC	#CKDEFB,EDFLAG	;INDICATE OUT OF DEF
	CMP	R1,R1RING	;CK FOR TOP OF STACK
	BEQ	CPEDFC		;WAS LAST ITEM A DEF?
	MOV	(R1)+,R3	;POP OFF STATEMENT
	ADD	R2,R3		;MAKE ABSOLUTE
	TST	(R1)+		;MUST BE 0
	BEQ	CPEDE2		;PREVIOUS ITEM WAS A DEF
	CMP	-(R1),-(R1)	;USE THIS ITEM SOMEHOW
CPEDFC:	JSR	R0,CPEROR	;SAY ERROR
	ERROR	CPUPED		;NON-FATAL -- "FNEND W/O DEF"
	BR	CPLOOP		;NEXT STATEMENT

CPSLDF:	MOV	R0,R3		;TREAT 1-LINE DEF LIKE DEF AND FNEND
CPEDE2:	MOV	(SP),R4		;STACK HAS REL VS OF CURRENT ONE
	ADD	TAGPUS(R3),R3	;HERE
	INC	R3		;SKIP PPUJX
	BR	CPNEX2



CPNXTE:	CMP	-(R1),-(R1)	;USE IT FOR SURE LATER
CPNEX3:	JSR	R0,CPEROR	;SAY ERROR
	ERROR	CPUFNX		;NON-FATA -- "NEXT W/O FOR"
	BR	CPLOOP		;NEXT STATEMENT

CPLDEF:	ADD	R2,R3		;MAKE STMT ABS
	MOV	R3,SCTH		; FOR POSTING
	JSR	R0,CPEROR	;SAY ERROR
	ERROR	CPUPDF		;NON-FATAL -- "DEF W/O FNEND"
	BR	CPPOST		;GO TRY AGAIN...

;MUST BE A "FOR" ON STACK
CPNEXT:	CMP	R1,R1RING	;CK TOP OF STACK
	BEQ	CPNEX3		;LAST ITEM NOT A FOR?
	MOV	(R1)+,R3	;POP OFF STATEMENT
	MOV	(R1)+,R4	;GET PREVIOUS HEADER
	BEQ	CPLDEF		;LAST ITEM WAS DEF!
	ADD	R2,R4
	MOV	R0,R3		;MAKE TEMP FOR PTR
	MOV	R4,R5		;AND TEMP NEXT
	ADD	TAGPUS(R3),R3	;ABS PTR TO PUSH-POP
	ADD	TAGPUS(R5),R5	;AND TO ONE FOR NEXT
	CMPB	(R3)+,(R5)+	;SKIP FIRST BYTE IN BOTH
	CMPB	(R3)+,(R5)+	;COMPARE HIGH BYTE OF VARIABLE
	BNE	CPNXTE		;BAD NEST
	CMPB	(R3)+,(R5)+	;NOW COMPARE LOW BYTES
	BNE	CPNXTE		;BAD NEST
	MOVB	(R5)+,(R3)+	;PASS BACK THE CONTROL BLOCK
	MOVB	(R5)+,(R3)+	;IN ONE BYTE CHUNKS
	MOV	R0,-(R1)	;NOW FOR HEADER TO NEXT PUSHPOP
	SUB	R2,(R1)		;NEEDS TO BE RELATIVE
	SWAB	(R1)		;AND IN RIGHT ORDER
	MOVB	(R1)+,(R5)+	;PASS HIGH BYTE
	MOVB	(R1)+,(R5)+	;AND LOW
	SUB	R2,R4		;NEXT HEADER TO FOR PUSHPOP
CPNEX2:	SWAB	R4		;GET HIGH BYTE
	MOVB	R4,(R3)+	; INTO TEXT
	SWAB	R4		;RESTORE R4, GET LOW BYTE
	MOVB	R4,(R3)+	; INTO TEXT
	BR	CPLOOP		;CONTINUE SCAN

CPEROR:	BIS	#CKEBIT,EDFLAG	;FLAG "ERROR OCCURED"
	BIT	#EDIMED,EDFLAG	;ANNOUNCE ERROR ?
	BEQ	1$		;YES, TAKE FIRST EXIST
	TST	(R0)+		;NO, TAKE SECOND EXIT
1$:	RTS	R0		;NOW EXIT




;	LISTOP (S(1), E(1), S(2), E(2),...,S(N), E(N), N)
;	DOES ALL THE WORK FOR LIST & LISTNH.
;	LISTOP WANTS TO BE GIVEN STATEMENT BINARY
;	NUMBERS FOR THE FIRST AND LAST LINES
;	TO BE TYPED, AND THE TOTAL NUMBER OF SUCH PAIRS
;	AS INDICATED ABOVE.  SEARCHES THE STATEMENT LIST FOR
;	STATEMENT >= START & CALLS OPERATOR 'TIL > END.
;	CALL:
;	JSR	R5,LISTOP
;	OPERATOR
;	WHERE OPERATOR IS A JSR PC TYPE SUBROUTINE
;	WHICH DOES THE WORK ON EACH STATEMENT.
;	LSTOP1 AND LSTOP2 ARE ALTERNATE ENTRIES
LSTOP1:	MOV	(R1),-(R1)	;MAKE END SAME AS BEGINNING
LSTOP2:	MOV	#1,-(R1)	;INDICATE ONE PAIR
	CLR	GETAGV(R0)	;CLEAR ANSWER ACCUMULATOR
LISTOP:	JSR	R5,EDSAVE	;MAKE ELBOW ROOM
	MOV	(R1)+,-(SP)	;# OF ARGUMENT SETS
	BEQ	LISTNF		;NO SETS
LISTNP:	MOV	SPTA,R4		;STATEMENT CHAIN
LISTNO:	TST	(R4)		;SEE IF LAST TAG PROCESSED
	BEQ	LISTND		;IF NO STATEMENTS
	ADD	(R4),R4		;GO TO NEXT TAG
	MOV	R4,R2		;LOCAL VERSION
	SUB	SPTA,R4		;SAVE UNRELOC LINK
	CMP	TAGBIN(R2),2(R1);CUR < START?
	BLT	LISTNL		;KEEP LOOKING
	CMP	TAGBIN(R2),(R1)	;CUR > END?
	BGT	LISTND		;ALL DONE
	MOV	@12(SP),R3	;OPERATOR ADDRESS
	JSR	PC,(R3)		;CALL IT TO PROCESS THIS STATEMENT

LISTNL:	ADD	SPTA,R4		;MAKE ABSOLUTE
	BR	LISTNO

LISTND:	CMP	(R1)+,(R1)+	;POP PAIR BOUNDS
	DEC	(SP)		;DEC. COUNT OF PAIRS
	BNE	LISTNP		;CONTINUE IF MORE
LISTNF:	TST	(SP)+		;POP OFF COUNT
	JSR	R5,EDREST	;ALL DONE
	TST	(R5)+		;SKIP SUBROUTINE ARGUMENT
	JMP	EDFNER		;RESET R0 TO CURRENT SPDA AND EXIT..



;	LIST USES LISTOP TO PASS THROUGH THE PROGRAM
;	WITH LISTNM OPERATING ON EACH STATEMENT TO TYPE
DOLIST:	JSR	PC,HEADER	;TYPE HEADER LINE
DOLINH:	JSR	PC,TLPAIR
	JSR	PC,SSOCH0	;SELECT CHANNEL #0
	JSR	PC,EDTMPP	;IS THERE A .TMP FILE?
	JSR	R5,LISTOP	;PASS OVER PROGRAM
	LISTNM			;LOOKING FOR ONES TO TYPE
	BR	DECTLC		;LONG BRANCH

.ENABL	LSB

LISTNN:	MOVB	TAGTXL(R2),R3	;ANY LENGTH?
	BEQ	EDRSTD		;NO
	MOV	TAGTXT(R2),-(R1);YES, GET THE POINTER
	BR	20$

LISTNM:	MOVB	TAGTXL(R2),R3	;ANY LENGTH?
	BEQ	EDRSTD		;NO
	MOV	TAGTXT(R2),-(R1);YES, GET THE POINTER
	CMPB	#5,TAGTYP(R2)	;IF AN ERROR LINE PREFIX
	BNE	20$		;(IT'S NOT)
	MOVB	#'?,R2		;ITS TYPEOUT WITH ?
10$:	CALLX	PRINTC,R3	;PRINT IT
20$:	TSTB	JOBF		;DOES HE WANT TO QUIT?
	BMI	30$		;YES--THIS IS AS GOOD A TIME AS ANY
	MOV	(R1),-(R1)	;REPLICATE THE LSB AND
	MOVB	R3,-(R1)	; SET MSB THEN
	COMB	(R1)		; UNCOMPLEMENT IT
	JSR	PC,BASGET	;POSSIBLE DISK REF & RELOC
	MOV	(R1)+,R2	;SET UP ARG FOR PRINTC
	ADD	#1,(R1)		;INC LSB AND
	SBC	R3		; CARRY
	TSTB	R2		;END FLAG?
	BPL	10$		;NO, SO PRINT IT
30$:	TST	(R1)+		;DONE, POP THE LSB
	BR	EDRSTD		;AND EXIT

.DSABL	LSB



;READY () PRINTS "READY CR LF" ON USER'S TTY

READY:	JSR	R5,EDSAVE	; Save registers...
	JSR	PC,IFPOS0	; Point to IOB for #0, and put in a CRLF in needed
	ADD	SPDA,R3		; SSOCH0 puts R2 <- SPDA, R3 <- rel add of IOB
	BIS	#100,CURBLK(R3)	; Set bit to keep READY quit during COM file
	MOV	#READYM,R2	; R2 -> Point to the 'READY' message
; PJH - This seemed to be from days of past...
;	BIT	#JFNOPR,JOBF	;LOGGED OUT NOW?
;	BEQ	10$		;NO
;	MOV	#BYEM,(R1)	;YES, USE THIS MESSAGE
	.TTRST			;CANCEL ^O
	BR	EDTYP2		; Jump past what we already did

EDTYPE:	JSR	R5,EDSAVE
	JSR	PC,SSOCH0	;SELECT CHANNEL #0
	MOV	(R1)+,R2	;MATCH CONVENTIONS
EDTYP2:	JSR	PC,PRINTL	;PRINT IT
	BR	DLTONR		;EDREST,SPDA TO R0,RTS PC



;	DLSTMT HAS SAME CALL FORMAT AS LISTOP.  IT USES
;	LISTOP TO PASS OVER THE PROGRAM AND DLTONE TO REMOVE
;	EACH UNDESIRABLE STATEMENT.
DODELE:	JSR	PC,TLPAIR	;GET PAIRS
	JSR	PC,EDTMPP	;INSURE SYMBOLIC EXISTS
	JSR	R5,LISTOP	;PASS OVER PROGRAM
	DLTONN			;DELETE ONE STATEMENT, NO CONT ALLOWED
DECTLC:	JMP	EDCTLC

DLTONN:
;	BIC	#EDCONT,EDFLAG	;MODIFIED PROGRAM SIGNAL
DLTONE:	CLRB	TAGTXL(R2)	;CLEAR TEXT
DLTPOP:	MOV	R2,GETAGV(R0)	;SAVE THAT WE GOT HERE
	JSR	R5,EDSAVE	;MAKE ROOM
	MOV	TAGPUL(R2),R5	;SAVE TAGPUL FOR USE LATER
	CLR	TAGPUL(R2)	;CHOP OFF ANY PUSH-POP IS FLAG FOR ABSENT STATEMENT
	MOVB	TAGTYP(R2),R3	;TYPE FOR DISPATCH
	ASL	R3		;TIMES TWO FOR WORDS
	CLRB	TAGTYP(R2)	;RESET STATEMENT TYPE
	ADD	R3,PC		;DISPATCH
	BR	DLTONR		;0 NULL
	BR	DLTARY		;1 ARRAY
	BR	DLNOCO		;2 ENDDEF
	BR	DLNOCO		;3 NEXT
	BR	DLTONR		;4 DATA
	BR	DLTONR		;5 ERROR OCCURED COMPILING STATEMENT
	BR	DLDEFN		;6 MULTILINE DEF
	BR	DLNOCO		;7 FOR
	BR	DLDEFN		;10 SINGLE LINE DEF
;	BR	DLTONR		;11 END OF DIM---MUST BE FOLLOWED BY DLTONR!!
DLTONR:	JSR	R5,EDREST
EDRSTD:	MOV	SPDA,R0		;RESTORE DATA BASE REG
	RTS	PC

DLDEFN:	ADD	TAGPUS(R2),R2	;PUSHPOP PTR
	ADD	#5,R2		;OVER ENTR
	CLR	R3		;FOR ADDRESS
	BISB	(R2)+,R3	;HI BYTE
	SWAB	R3
	BISB	(R2)+,R3	;LOW BYTE
	ADD	SPDA,R3		;ABS PTR TO FUNCTION BLOCK
	MOV	SP,(R3)		;REF'D BUT NOT DEF'D: POS<>0
DLNOCO:	;BIC	#EDCONT,EDFLAG	;NO CONTINUING, NOT CROSSLINKED RIGHT
	BR	DLTONR
DLTARY:	ASR	R5		;# ARRAYS = # BYTES IN DIM / 2
	BEQ	DLTONR
	ADD	TAGPUS(R2),R2	;PUSHPOP PTR
	TST	(R2)+		;SKIP JUNK
DLTAR1:	DEC	R5		;ONE LESS NOW
	BEQ	DLTONR		;YEP
	MOV	(R2)+,R3
	SWAB	R3
	ADD	SPDA,R3		;MAKE ABS
	BICB	#REFARY!DIMARY,FLAGS(R3)
	BISB	#REFARY,FLAGS(R3)	;SET TO REF'D BUT NOT DIM'D
	BR	DLTAR1



;GETXXX ROUTINES ALL ASSUME SPDA IS IN R0.
;WHEN USER STARTS A LINE WITH A LINE NUMBER CALL GETAGD(BINSTATNO)
;WHEN COMPILING A STATEMENT, CALL GETAGN TO GET A HEADER FOR
;IT - I.E. FOR MULTIPLE STATEMENT LINES:  1 CALL TO GETAGD TO
;REMOVE OLD STATEMENT(S) WITH THAT LINE NUMBER AND CALLS TO
;GETAGN FOR EACH NEW STATEMENT ON THE LINE.
;IF HE IS JUST REFERENCING IT CALL GETAG(BINSTATNO).  IN
;EITHER CASE A HEADER (POSSIBLY VIRGIN) IS RETURNED.
;GETAGD(N)
;CHANGES ALL STATEMENTS WITH A GIVEN # TO PHANTOMS
GETAGD:	JSR	R5,LSTOP1	;WORK OVER ALL SUCH STATEMENTS
	DLTONE			;WITH DELETE OPERATOR
	RTS	PC

;GETAGN(N)
;FIND FIRST PHANTOM WITH GIVEN STATEMENT # OR MAKES ONE
GETAGN:	JSR	R5,LSTOP1	;WORK THEM OVER
	GETNOP			;WITH FIND FIRST PH OP
	BR	GETF1		;THEN IF NOT MAKE ONE

;GETAG(N)
;FIND FIRST STATEMENT OF ANY KIND WITH #, OR MAKES ONE
GETAG:	JSR	R5,LSTOP1	;WORK OVER N'S WITH
	GETFOP			;GET-FIRST OP
GETF1:	TST	GETAGV(R0)	;IT ACCUMULATED ANY HERE
	BEQ	GETF2		;IF NONE, MAKE A NEW ONE
	MOV	GETAGV(R0),-(R1);ANSWER TO STACK
	RTS	PC

GETF2:	TST	-(R1)		;MAKE ONE - SAVE # FOR IT
GETAG4:	MOV	SPTA,R0		;PREPARE TO TALK ABOUT THE PROGRAM AREA
	MOV	TAGPTR(R0),R2	;RESERVE SPACE
	SUB	#TAGLEN,R2	;TRY FOR SPACE
	CMP	R2,TAGLIM(R0)	;ENOUGH AVAILABLE?
	BGT	GETAG3		;YEP
	JSR	R5,ECONOM	;STORAGE CONTROLLER
	+	TAGNOM		;GET TAG SPACE
	BR	GETAG4		;SEE IF IT IS ENOUGH

GETAG3:	MOV	R2,TAGPTR(R0)	;STORE IT BACK FOR THE NEXT GUY
	MOV	SPDA,R0		;BACK TO DATA AREA
	ADD	SPTA,R2		;MAKE ABS PTR.
	MOV	(R1),R3		;GET # BACK
	MOV	R3,TAGBIN(R2)	;PUT IT IN NEW HEADER
	CLR	TAGPUL(R2)	;MAKE SURE IT LOOKS EMPTY
	CLR	TAGTXL(R2)	;IN BOTH WAYS; KILL TYPE TOO



;NOW INSTALL IT IN PROPER PLACE IN LIST
;R2 CONTAINS STATEMENT HEADER (WITH # FILLED IN) & WE
;NEED TO FIND RIGHT PLACE TO LINK IT INTO.
;IF THERE ARE ANY WITH THAT #, IT GOES AFTER THEM:
;I.E. GET HEADER OF THE LAST OF THEM; OTHERWISE
;GET HEADER OF LAST STATEMENT WHICH IS SMALLER 
;THAN THIS NEW ONE.  SO A SEARCH 0-# WITH
;OPERATOR TO STORE THE LAST WILL DO
	CLR	(R1)		;FROM BEGINNING
	MOV	R3,-(R1)	;THROUGH END CURRENT ST.
	JSR	R5,LSTOP2	;SEARCH
	GETSOP			;SAVE EACH TIME
	MOV	GETAGV(R0),R3	;PICK UP PTR
	BNE	GETAG5		;IF ANY FOUND THERE, LINK IN
	MOV	SPTA,R3		;OTHERWISE THE NEW ONE IS FIRST
GETAG5:	MOV	(R3),(R2)	;MOV OLD LINK
	BEQ	GETAG6		;IF ZERO DON'T RE-RELATIVIZE IT
	ADD	R3,(R2)		;MAKE ABLS
	SUB	R2,(R2)		;RE-RELATIVIZE IT
GETAG6:	MOV	R2,(R3)		;MOV IN NEW LINK
	SUB	R3,(R3)		;RELATIVIZE IT
	MOV	R2,-(R1)	;NEW ONE IS VALUE
	RTS	PC

;GETNOP - LISTOP OPERATOR TO GET FIRST PHANTOM
GETNOP:	TST	TAGPUL(R2)	;SEE IF PHANTOM
	BNE	GETSR		;NO
;GETFOP - LISTOP TO GET FIRST - PERIOD
GETFOP:	TST	GETAGV(R0)	;IF ANY ALREADY FOUND
	BNE	GETSR		;QUIT
;GETSOP - LISTOP TO GET LAST
GETSOP:	MOV	R2,GETAGV(R0)	;SAVE ABSOLUTE POINTER
GETSR:	RTS	PC

R1SCHK:	CMP	R1,#NSTORG+20	;CHECK FOR R1 STACK SIZE
	BHI	GETSR		;IF O.K., THEN JUST EXIT
R1SOUT:	JSR	R5,ECONOM	;STORAGE CONTROL
	+	R1SNOM		;STACK SPACE PLEASE
	RTS	PC

	.sbttl	ASSIGN et al commands

.ENABL	LSB

10$:	JSR	PC,TLGDFN	;GET STRING OR DIE
20$:	JSR	PC,EDPUSS	;SPREAD OUT HEADER
	JSR	PC,OPNR20	;POST DEVICE, ETC.
	BIT	#4000,FSSFLG	;DID OPNR20 SUPPLY THE <PROT> ?
	BEQ	30$		;NO
	CLR	FQPROT-1(R4)	;YES, SO CLEAR IT (.ULOG WOULD LIKE TO TAKE
				; IT INSTEAD OF CERTAIN OTHER GOODIES)
30$:	JSR	PC,@(SP)+	;CO-ROUTINE BACK...
	JMP	EDCTL		;DONE

DOREAS:	JSR	PC,10$		;GET THE SPECIFICATION, SET RETURN ADDRESS
	MOV	R4,-(SP)	;SAVE FIRQB POINTER
	MOV	FQNAM1(R4),R5	;NOW GET RAD50 JOB # TO PROCESS
	CLR	R4		;CLEAR HIGH ORDER FOR
	DIV	#50,R4		; THIS DIVIDE
	TST	R5		;MUST NOT BE A 3RD CHARACTER
	BNE	50$		;ERROR IF SO
	MOV	R4,R5		;MOVE ANSWER TO LOW ORDER
	CLR	R4		;AND CLEAR HIGH ORDER FOR
	DIV	#50,R4		; THIS DIVIDE (WHAT AGAIN?)
	SUB	#36,R4		;MAKE 1ST CHAR INTO A DIGIT
	BLE	50$		;ERROR IF NON-DIGIT OR 0
	TST	R5		;ANY 2ND CHARACTER?
	BEQ	40$		;NOPE
	SUB	#36,R5		;YEP, SO MAKE IT INTO A DIGIT
	BLT	50$		;ERROR IF NON-DIGIT
	MOV	R4,-(SP)	;SWAP THE 1ST DIGIT
	MOV	R5,R4		; AND
	MOV	(SP)+,R5	;  2ND DIGIT
	MUL	#10.,R5		;1ST DIGIT <- 1ST DIGIT *10.
40$:	ADD	R4,R5		;FORM FINAL NUMBER
	MOV	(SP)+,R4	;RESTORE FIRQB POINTER
	MOV	R5,FQNAM1(R4)	;AND SET JOB NUMBER
	BR	60$		;GO DO IT

50$:	ERROR	BDNERR,FATAL	;NOT A VALID NUMBER

	.sbttl	-- note LA's incestuous knowledge of DOASSR: return address
	.sbttl

;+
;  The ASSIGN command needs special help from LA -- scan for the second token
;  needs to be terminated by a space.  This special need is communicated by
;  DOASSR:: being our return address.  An ugly and dangerous formalism, to
;  be sure.  But this is B+/RSTS...
;-

DOASSI:	JSR	PC,TLGNEP	;Lex next token, skip if not EOL
DOASSR::ERROR	TLJNKY,FATAL	;EOL:  error
	JSR	PC,TLPDST	;If data string push it and skip
55$:	ERROR	TLJNKY,FATAL	;Not data string:  error
	JSR	PC,20$		;FSS string into FIRQB, set up coroutine
	BIS	#QUOT1F,STAT(R0) ;Continue lex under special quoting
	JSR	PC,TLGNEP	;Lex next token, skip if not EOL
	 BR	 ASSUUO		;EOL, no third token => old format
	JSR	PC,TLPDST	;Third token:  push it, skip if data string
	 BR	 55$		;  Not data string => error
	CALL	200$		;Spread header and pack RAD50 into FIRQB
	BCC	57$		;RAD50 packed OK => continue
	ERROR	BADNAM,FATAL	;Junk instead of valid RAD50:  error
57$:


;DOASSI:JSR	PC,10$		;GET THE SPECIFICATION, SET RETURN ADDRESS

ASSUUO:				;ENTER HERE FOR SYS CALL
60$:	MOVB	#UU.ASS,R0	;Do an ASSIGN/REASSIGN
70$:	MOVB	R0,@#FIRQB+FQFUN  ;Post the function code for .ULOG
	MOV	#XRB,R0		;CLOBBER THE XRB
	CLR	(R0)+		;LENGTH OF ALTERNATE LOGICAL TABLE
	CLR	(R0)+		; AND AGAIN
	CLR	(R0)+		;LOCATION OF LOGICAL TABLE (STANDARD)
	.ULOG			;TRY TO DO IT
	BR	100$		;GO CHECK FOR ERRORS

DOMOUN:	JSR	PC,10$		;GET THE SPECIFICATION, SET RETURN ADDRESS
	CLR	FQERNO(R4)	;FIRST MOUNT THE DISK (0)
	JSR	PC,80$		;SO GO DO IT
	MOV	#6,FQERNO(R4)	;SECOND UNLOCK THE DISK (6)
80$:	MOVB	#UU.MNT,FQFUN(R4) ;SET THE FUNCTION CODE
90$:	.UUO			;NOW DO IT
100$:	JMPX	IODIE		;DIE IF ERROR, ELSE RETURN

CHKASD::CLR	FSSFLG		;PRE-CLEAR .FSS FLAGS
	CMPB	FQFUN(R4),#UU.ASS ;IS IT ASSIGN?
	BEQ	ASSUUO		;YES
	CMPB	FQFUN(R4),#UU.DEA ;IS IT DEASSIGN?
	BEQ	DEAUUO		;YES
	BR	90$		;NEITHER, GO DO THE .UUO

DODEAS:	JSR	PC,TLGFNA	;FILE NAME OR 0
	MOV	#EDCTL,-(SP)	;SET RETURN ADDRESS
	MOV	(R1),R5		;Clone TOKA
	BEQ	110$		;Null string => all devices and logicals
	CALL	GETBUF		;Get a clean FIRQB
	CALL	200$		;Convert string to RAD50
	BCC	DEAUUO		;Success, FIRQB loaded => go issue UU.DEA
	MOV	R5,-(R1)	;Not RAD50:  get TOKA back to FSS that string
	JSR	PC,20$		;SPREAD HEADER, GET DEVICE
	TST	(SP)+		;DON'T CO-ROUTINE BACK TO 30$

DEAUUO:	MOVB	#UU.DEA,R0	;Set to do a DEASSIGN
	BR	70$		;GO DO IT

110$:	TST	(R1)+		;RESTORE R1
NOLOGS:	CLR	USRPRT		;No more user-assignable protection code
	CLR	USRPPN		;No more user-assignable PPN
	CALL	GETBUF		;Get a clean FIRQB
	MOVB	#UU.DAL,R0	;Function is "deallocate everything"
	BR	70$		;Issue .ULOG and return


; Load extended user logical name into FIRQB starting at FQNAM1,
;   return Carry set if invalid RAD50 encountered

ASSWDS	  =:	5		;Number of RAD50 words to load into FIRQB
ASSLOD	  =:	FIRQB+FQNAM1	    ;Loading starts here
ASSLMT	  =:	ASSLOD+<ASSWDS*2>   ;  and ends short of here

200$:	MOV	R5,-(SP)	;Save R5
	CALL	EDPUSS		;Construct string header on R1 stack
	MOV	#ASSLOD,R5	;R5 -> first word to load  (FQNAM1)
	TST	(R5)		;A filename already there?
	BNE	230$		;Yes, filename twice => that's an error
	MOV	#40,-(R1)	;Mask for "convert to upper case" onto R1S
	CALL	SUCJS		;Convert to UC, R2/R4 -> string, pop header
220$:	MOV	#100000,-(R1)	;Tell RADI to convert "_" to "."
	CALL	RADI		;Create a word of RAD50 from R2/R4's string
	MOV	(R1)+,(R5)+	;Insert a word of RAD50 into FIRQB
	BCS	225$		;Word of junk, not RAD50 => exit w/Carry set
	CMP	R5,#ASSLMT	;An OK RAD50 word:  all words inserted yet?
	BLO	220$		;No => loop to convert another word
	;CLC			;Yes:  Carry clear for success  (BLO = BCS)
225$:	MOV	(SP)+,R5	;Restore R5
	RETURN


230$:	ERROR	SASYNE,FATAL	;Syntax error

	.dsabl	lsb

	.sbttl	DOCCOX	Detacher

DOCCOX:	JSR	PC,GETBUF	;GET THE FIRQB SETUP
	MOV	#100000+UU.DET,FQERNO(R4);SET DETACH(7.) & CLOSE TTY (<0)
	JSR	R5,EDFIPK	;NOW DO IT WITH
	+	UUOFQ		;THIS FUNCTION
	RTS	PC		;AND BACK AGAIN

	.end



