TITLE	ARITH,<STRING ARITHMETIC>,08,13-MAY-86,TVG/RGH

;                   Copyright 1974,1990 by Digital Equipment Corporation
;                                  All rights reserved.
;
;          This software is furnished under a license and may be used and copied
;          only  in  accordance  with  the  terms  of  such license and with the
;          inclusion of the above copyright notice.  This software or any copies
;          shall not be provided to any other person.   No title to or ownership
;          of the software is hereby transferred.
;
;          The information in this software is subject to change without notice.
;
;          DIGITAL  assumes  no  responsibility  for the  use, functionality, or
;          reliability of its  software  on equipment  which  is not supplied by
;          DIGITAL.

.SBTTL	STRING ARITHMETIC DESCRIPTOR BLOCKS

;+
; SEVERAL OF THE STRING ARITHMETIC ROUTINES ASSUME THAT NUMERIC OPERANDS ARE
; DESCRIBED BY A COMMON TYPE OF DESCRIPTOR BLOCK. THIS BLOCK DESCRIBES, FOR
; A GIVEN OPERAND:
;	1) THE OFFSET WITHIN THE STRING OF THE MOST SIGNIFICANT DIGIT
;	2) THE NUMBER OF SIGNIFICANT DIGITS TO THE LEFT OF THE DECIMAL POINT
;	3) 1+THE OFFSET WITHIN THE STRING OF THE LEAST SIGNIFICANT DIGIT
;	4) THE NUMBER OF SIGNIFICANT DIGITS TO THE RIGHT OF THE DECIMAL POINT
;	5) THE NUMBER'S SIGN
;
; THE DESCRIPTOR BLOCK OFFSETS ARE GIVEN BELOW.
;-

$MSOFF	=0			;M.S. DIGIT OFFSET WITHIN THE STRING
$LEFT	=1			;# OF SIGNIFICANT DIGITS TO LEFT OF POINT
$LSOFF	=2			;L.S. DIGIT OFFSET+1 WITHIN THE STRING
$RIGHT	=3			;# SIGNIFICANT DIGITS TO RIGHT OF POINT
$SIGN	=4			;SIGN (0 FOR POSITIVE, -1 FOR NEGATIVE)
$NBLEN	=6			;SIZE OF DESCRIPTOR BLOCKS

.SBTTL	MAKBLK - MAKE A DESCRIPTOR BLOCK

;+
; MAKBLK MAKES A DESCRIPTOR BLOCK ON THE SP STACK FOR A NUMERIC STRING.
;
; ENTERED WITH:
;	R2 POINTING AT SPACE FOR A DESCRIPTOR BLOCK
;	R3 POINTING AT THE FIRST STRING CHARACTER
;	R4 POINTING ONE BEYOND THE LAST STRING CHARACTER
;
; EXIT WITH:
;	DESCRIPTOR BLOCK FILLED IN
;	ALL REGISTERS PRESERVED
;	C-BIT SET IF AND ONLY IF NUMBER FORMAT ERROR DETECTED
;-

MAKBLK:	PUSH	<R2,R3,R4>	;SAVE R2,R3,R4
.IIF NE <$MSOFF!<$LEFT-1>> .ERROR ;FOLLOWING WON'T WORK
	CLR	(R2)+		;CLEAR $MSOFF & $LEFT
.IIF NE <<$LSOFF-2>!<$RIGHT-3>>	.ERROR ;FOLLOWING WON'T WORK
	MOV	R4,(R2)		;WE WANT $LSOFF SET TO STRING LENGTH
	SUB	R3,(R2)+	;& $RIGHT SET TO 0 (SHOULD WORK)
.IIF NE <$SIGN-4> .ERROR	;FOLLOWING WON'T WORK
	CLR	(R2)		;CLEAR SIGN (DEFAULT FOR 0)
.IIF NE <$NBLEN-6> .ERROR	;FOLLOWING WON'T WORK
	CMP	-(R2),-(R2)	;POINT AT DESCRIPTOR BLOCK
	BR	2$		;START LOOKING FOR LEFT MOST SIG. DIGITS

; THE FOLLOWING LOOP LOOKS AT THE LEADING CHARACTERS OF
; THE STRING TO DETERMINE ITS SIGN & FIND OUT WHERE ITS
; LEADING SIGNIFICANT DIGIT IS

.IIF NE $MSOFF	.ERROR		;FOLLOWING WON'T WORK
1002$:	INCB	(R2)		;INC LOCATION OF M.S. DIGIT
	TSTB	(R3)+		;LOOK AT NEXT DIGIT
2$:	$GO.IF	R3,EQ,R4,7$	;BR IF DONE WITH STRING
	JSR	PC,STRCHR	;EXAMINE THE CHARACTER
	$GO.IF	,HI,,1003$	;BR IF 1-9 - A M.S. DIGIT
	$GO.IF	,HIS,,1002$	;LOOP IF A LEADING ZERO
	$GO.IF	,EQ,,4$		;BR IF DECIMAL PT. - M.S. DIGIT NEXT
	$GO.IF	(R3),NE,#'-,1002$,B ;LOOP IF SPACE OR OTHER GARBAGE
	COM	$SIGN(R2)	;TOGGLE THE SIGN
	BR	1002$		;& LOOP

; THE FOLLOWING LOOP CONTINUES ANALYZING THE STRING
; FROM THE LEFT TO LOCATE A DECIMAL POINT.

1003$:	INCB	$LEFT(R2)	;ANOTHER SIG. DIGIT LEFT OF POINT
	TSTB	(R3)+		;POINT AT NEXT CHAR
	$GO.IF	R3,EQ,R4,7$	;BR IF DONE WITH STRING
	JSR	PC,STRCHR	;EXAMINE THE CHARACTER
	$GO.IF	,HIS,,1003$	;BR IF 0-9 - ANOTHER SIG. DIGIT
	$GO.IF	,EQ,,4$		;BR IF DECIMAL POINT FOUND

; HERE WE HAVE GARBAGE. LET'S CALL IT QUITS.

	SUB	R3,R4		;THIS FAR FROM END OF STRING
	MOVB	$LSOFF(R2),R3	;DEFAULT RIGHT SIG. DIGIT OFFSET
	SUB	R4,R3		;JUST TO THE GARBAGE
	MOVB	R3,$LSOFF(R2)	;UPDATE $LSOFF TO POINT JUST BEYOND L.S. DIGIT
	BR	7$		;EXIT

; WE GET HERE WHEN A DECIMAL POINT HAS BEEN ENCOUNTERED DURING A LEFT SCAN.

4$:	MOV	R4,-(SP)	;INTERCHANGE R3 & R4
	MOV	R3,R4
	MOV	(SP)+,R3	;INTERCHANGE COMPLETE
	BR	5$		;ENTER THE LOOP LATE

; THE FOLOWING LOOP SCANS FROM THE RIGHT TO FIND THE
; LAST TRAILING SIGNIFICANT DIGIT.

1004$:	DECB	$LSOFF(R2)	;TICK OFF INSIGNIFICANT STUFF
5$:	TSTB	-(R3)		;LOOK AT NEXT CHARACTER
	JSR	PC,STRCHR	;EXAMINE THE CHARACTER
	$GO.IF	,HI,,1005$	;BR IF 1-9, THE L.S. DIGIT
	$GO.IF	,HIS,,1004$	;LOOP IF TRAILING ZERO        
	$GO.IF	,NE,,1004$	;LOOP IF TRAILING GARBAGE
	DECB	$LSOFF(R2)	;L.S. DIGIT TO LEFT OF POINT
	BR	6$		;BR TO "DECIMAL POINT FOUND CODE"


; THE FOLLOWING LOOP CONTINUES ANALYZING THE STRING FROM THE
; RIGHT TO LOCATE THE DECIMAL POINT.

1005$:	INCB	$RIGHT(R2)	;ANOTHER SIG. DIGIT RT. OF POINT
	TSTB	-(R3)		;LOOK AT NEXT CHAR
	JSR	PC,STRCHR	;EXAMINE THE CHARACTER
	$GO.IF	,HIS,,1005$	;0-9 - ANOTHER SIG. DIGIT
	BNE     1$     		;EMBEDDED GARBAGE IS ERROR

; WE GET HERE WHEN A DECIMAL POINT HAS BEEN FOUND WHEN SCANNING
; FROM THE RIGHT.  IT HAD BETTER BE THE SAME ONE WE FOUND 
; SCANNING FROM THE LEFT.

6$:	$GO.IF	R3,NE,R4,1$	;EMBEDDED GARBAGE IS ERROR

; HERE WE WISH TO TEST FOR 0 IN THE ACCUMULATOR. THE TEST IS WHETHER $MSOFF &
; $LEFT = $LSOFF & $RIGHT.

.IIF NE <$MSOFF!<$LEFT-1>!<$LSOFF-2>!<$RIGHT-3>!<$SIGN-4>> .ERROR ;TROUBLE
7$:	$GO.IF	(R2)+,NE,(R2)+,2009$ ;BR IF NONZERO ACCUMULATOR
	CLR	(R2)		;0 IS ALWAYS A POSITIVE NUMBER
2009$:	CLC			;SIGNAL NO ERROR
	BR	8$		;EXIT

1$:	SEC			;SIGNAL BAD NUMBER FORMAT
8$:	POP	<R4,R3,R2>	;RESTORE R4,R3,R2
	$EXIT			;EXIT MAKBLK

.SBTTL	STRCHR - CHECK CHARACTER FOR NUMERIC


;+
; STRCHR TESTS THE CHARACTER POINTED AT BY R3 TO SEE WHETHER
; IT IS NUMERIC OR A DECIMAL POINT, SETTING CONDITION CODES
; AS FOLLOWS:
;	C-BIT OFF TO INDICATE NUMERIC (0-9)
;		Z-BIT SET TO INDICATE 0
;	C-BIT ON TO INDICATE NONNUMERIC
;		Z-BIT SET TO INDICATE DECIMAL POINT
;
; ENTER WITH:	
;	JSR	PC.STRCHR
;	R3 POINTING AT CHARACTER
;
; EXIT WITH:
;	CONDITION BITS SET AS DESCRIBED ABOVE
;	REGISTERS PRESERVED
;-

STRCHR:	$GO.IF  #'9,LO,(R3),2001$,B ;BR IF TOO HIGH FOR DIGIT
	$GO.IF	(R3),HIS,#'0,2001$,B ;BR IF 0-9
	CMPB	(R3),#'.	;HOW ABOUT DECIMAL POINT
	SEC			;SHOW IT'S NONNUMERIC
2001$:	$EXIT			;EXIT STRCHR

.SBTTL	$RECOP - RECOPY STRING ACCUMULATOR

;+
; $RECOP RECOPIES AN ACCUMULATOR IN PLACE DELETING LEADING
; & TRAILING ZEROES.  IT IS ASSUMED THAT THE NUMBER BEING 
; RECOPIED IS NICE; I.E. (1) IF IT IS SIGNED, THE SIGN IS
; THE FIRST CHARACTER AND (2) THE NEXT CHARACTER AFTER THE
; SIGN IS THE FIRST DIGIT OF THE MAGNITUDE.  UPDATES DESCRIPTOR
; BLOCK.
;
; ENTERED WITH:
;	JSR	PC,$RECOP
;	R2 POINTING AT SPACE FOR DESCRIPTOR BLOCK
;	R3 POINTING AT ACCUMULATOR
;	$LSOFF(R2) POINTS 1 PAST L.S.D.
;
; EXIT WITH:
;	ALL REGISTERS PRESERVED
;-

$RECOP:	PUSH	<R3,R4,R5>	;SAVE R3,R4,R5
	MOVB	$LSOFF(R2),R4	;GET DISPLACEMENT PAST END OF STRING
	ADD	R3,R4		;TURN INTO POINTER
	JSR	PC,MAKBLK	;SET UP THE DESCRIPTOR BLOCK
.IIF NE $MSOFF .ERROR		;FOLLOWING WON'T WORK
	MOVB	(R2),R4		;RELATIVE OFFSET OF M.S.
	MOVB	$LSOFF(R2),R5	;1+ OFFSET OF L.S. DIGIT

; NOW WE RESET THE DESCRIPTOR BLOCK ASSUMING NO SIGN

	SUB	R4,R5		;NUMBER OF CHARS TO COPY
	ADD	R3,R4		;TURN R4 INTO POINTER 
	$GO.IF	R5,NE,#0,2003$	;BR IF NONZERO RESULT
	INC	R5		;LET'S COPY ONE
	MOVB	#'0,(R4)	;ZERO INTO RESULT
.IIF NE $MSOFF .ERROR		;FOLLOWING WON'T WORK
2003$:	CLRB	(R2)		;ASSUME 1ST CHAR WILL BE M.S.
	MOVB	R5,$LSOFF(R2)	;AND THIS WILL BE 1 + L.S. LOC
	$GO.IF	$SIGN(R2),EQ,#0,2001$ ;BR IF NO CORRECTION FOR SIGN
	INC	R3		;TO 1ST SIG CHAR LOC.
.IIF NE $MSOFF .ERROR		;FOLLOWING WON'T WORK
	INCB	(R2)		;BUMP M.S. OFFSET PAST SIGN
	INCB	$LSOFF(R2)	;L.S. TOO OF COURSE
2001$:
1002$:	MOVB	(R4)+,(R3)+	;COPY CHARS
	SOB	R5,1002$	;UNTIL DONE
	POP	<R5,R4,R3>	;RESTORE R5,R4,R3
	$EXIT			;EXIT $RECOP

.SBTTL	STSIGN - SET SIGN IN STRING ACCUMULATOR

;+
; STSIGN SETS THE SIGN INDICATED IN THE ACCUMULATOR DESCRIPTOR BLOCK INTO THE
; FIRST BYTE OF THE NUMERIC STRING ACCUMULATOR.
;
; ENTERED WITH:
;	JSR	PC,STSIGN
;	R2 POINTING AT ACCUMULATOR DESCRIPTOR BLOCK
;	R3 POINTING AT ACCUMULATOR
;
; EXIT WITH:
;	ALL REGISTERS PRESERVED
;-

STSIGN:	MOVB	#'0,(R3)	;ASSUME IT'S POSITIVE & DUMMY LEADING ZERO
	$GO.IF	$SIGN(R2),EQ,#0,2001$ ;BR IF IT REALLY IS POSITIVE
	MOVB	#'-,(R3)	;ELSE INSERT A MINUS SIGN
2001$:	$EXIT			;EXIT STSIGN

.SBTTL	SUMBLK - CONSTRUCT SUM'S DESCRIPTOR BLOCK

;+
; SUMBLK MAKES A DESCRIPTOR BLOCK DESCRIBING A NUMERIC STRING CAPABLE OF HOLDING
; THE SUM OR DIFFERENCE OF THE NUMERIC STRINGS DESCRIBED BY TWO ARGUMENT
; DESCRIPTOR BLOCKS. WHERE THE SYMBOLS USED BELOW HAVE THE OBVIOUS MEANINGS, THE
; CALCULATIONS PERFORMED BY SUMBLK MAY BE SUMMARIZED BY THE FOLLOWING SEQUENCE:
;	$RIGHT = MAX($RIGHT1,$RIGHT2)
;	$LEFT = MAX($LEFT1,$LEFT2)+1
;	$LSOFF = $MSOFF+$LEFT+$RIGHT (+1 IF $RIGHT>0)
;
; SUMBLK CHANGES NEITHER $LSOFF OR $SIGN IN THE BLOCK IT IS MAKING.
;
; ENTRY CSPACE IS USED TO ENLARGE A DESCRIPTOR BLOCK TO ALLOW CARRY OUT OF THE
; LEFT END OF A NUMBER.
;
; ENTRY MLSOFF IS USED TO CALCULATE $LSOFF WHEN $LEFT, $RIGHT, & $MSOFF ARE
; KNOWN.
;
; ENTERED WITH:
;	JSR	PC,SUMBLK
;	R2 POINTING AT DESCRIPTOR BLOCK TO BE MADE
;	R4 POINTING AT 1ST ARGUMENT DESCRIPTOR BLOCK
;	R5 POINTING AT 2ND ARGUMENT DESCRIPTOR BLOCK
;	$MSOFF(R2) SET TO DESIRED OFFSET OF M.S. DIGIT IN SUM-TO-BE STRING
;
; EXIT WITH:
;	ALL REGISTERS PRESERVED
;-

;+
; THE FOLLOWING MACRO IS USED TO ABBREVIATE THE CODE LISTING
; MAXB MOVES THE MAXIMUM OF FIELD(RA) AND FIELD(RB) TO FIELD(RC)
;-

.MACRO	MAXB	FIELD,RA,RB,RC   ?LAB1
	  MOVB	FIELD(RA),-(SP) ;ASSUME FIELD(RA)>=FIELD(RB)
	$GO.IF	(SP),HIS,FIELD(RB),LAB1,B ;BR IF FIELD(RA)>=FIELD(RB)
	  MOVB	FIELD(RB),(SP)	;ELSE USE FIELD(RB) AS MAX
LAB1:	  MOVB	(SP)+,FIELD(RC) ;SET LARGER FIELD INTO DESTINATION FIELD
.ENDM

;ROUTINE FOLLOWS:

	.ENABL	LSB

SUMBLK:	
	MAXB	$RIGHT,R4,R5,R2 ;MOVE LARGER OF $RIGHT'S TO SUM $RIGHT
	MAXB	$LEFT ,R4,R5,R2 ;MOVE LARGER OF $LEFT'S TO SUM $LEFT
CSPACE:				;ENTRY TO ENALRGE FOR DESTRUCTIVE CARRY
	INCB	$LEFT(R2)	;INCREASE BY 1 TO ALLOW FOR CARRY ON ADD
MLSOFF:				;ENTRY TO CALCULATE $LSOFF
	MOVB	$RIGHT(R2),-(SP) ;NUMBER OF PLACES TO RIGHT OF POINT
	$GO.IF	,EQ,,2001$	;BR IF THERE AREN'T ANY
	INCB	(SP)		;ELSE ALLOW FOR A DECIMAL POINT TOO
.IIF NE $MSOFF .ERROR		;FOLLOWING WON'T WORK
2001$:	ADD	(R2),(SP)	;ADD $MSOFF TO RIGHT OF POINT (INC PT) COUNT
	MOVB	$LEFT(R2),-(SP)	;GET $LEFT
	ADD	(SP)+,(SP)	;ADD $LEFT IN
	MOVB	(SP)+,$LSOFF(R2) ;HERE'S $LSOFF
	RTS	PC		;AND THAT'S IT

	.DSABL	LSB

.SBTTL	$CMPN--ARITHMETIC COMPARISON ROUTINE
;+
; <CMPN> GIVEN TWO NUMERIC STRINGS AND THEIR DESCRIPTOR BLOCKS, THIS
; ROUTINE RETURNS THE SIGN-FUNCTION OF THEIR DIFFERENCE ON THE TOP
; OF THE STACK
;	CALL: JSR PC,$CMPN
;	ENTRY: R2 -> DESCRIPTOR ARG1
;		R3 -> STRING ARG 1
;		R4 -> DESCRIPTOR ARG2
;		R5 -> STRING ARG 2
;	EXIT: ALL REGISTERS HAVE VALUE ON ENTRY (EXCEPT SP)
;		TOP OF STACK IS SIGN(ARG1-ARG2)
;-

;+
; THE FOLLOWING MACROS ARE USED TO DEFINE THE CALLING SEQUENCE TO
; XCMPS, A SUBROUTINE WHICH COMPARES UNSIGNED INTEGER STRINGS:
;-

.MACRO	FORM	REG,ARG1,ARG2,ARG3	;MACRO TO PLACE ARG1+ARG2-ARG3
				;IN REGISTER 'REG'
	.IF	NB ^\ARG3\	;IF 3RD ARG GIVEN
	  MOVB	ARG3,REG	; PLACE ARG3 IN REG
	  MOV	REG,-(SP)	;AND PUSH ON STACK TO ALLOW FOR
				;NEXT BYTE ACCESS
	.IFTF			;IN ANY CASE,
	  MOVB	ARG2,REG	;GET BYTE ARG2 AS WORD
	.IFT			;IF ANYTHING ON STACK,
	  SUB	(SP)+,REG	;SUBTRACT FROM REG
	.ENDC	
	  ADD	ARG1,REG	;ADD IN FIRST ARG
	.ENDM	

.MACRO	$XCMP	STR1,STR2,LEN	;SETS UP CALLING SEQUENCE TO XCMPS
	PUSH	<R0,R1>		;THESE REGS CARRY ARGS TO FUNCTION
	PUSH	R2		;THIS ONE TOO
	FORM	R1,STR1		;ADDRESS OF FIRST STRING IN R1
	FORM	R2,STR2		;ADDRESS OF 2ND STRING IN R2
	.NTYPE	X,LEN		;CHECK LEN ARGUMENT
	.IF	NE X		;IF LEN IS NOT R0
	  MOVB	LEN,R0		;MOVE LEN INTO R0 FOR CALL
	.ENDC	
	  JSR	PC,XCMPS	;SUBR RETURNS SIGN IN  R0
	POP	<R2,R1>	;RESTORE OTHER REGISTERS
	  MOV	(SP),-(SP)	;REPLICATE OLD R0
	  MOV	R0,2(SP)	;PUT NEW ONE IN ITS PLACE
	POP	R0		;GET OLD R0 BACK
	  TST	(SP)+		;AND SET CONDITION CODES
	.ENDM	


; THE BODY OF THE ROUTINE FOLLOWS:

$CMPN:	MOV	(SP),-(SP)	;RESERVE SLOT (6(SP)) FOR RESULT
	PUSH	<R0,R1>		;SAVE R0 & R1 (NOW 6(SP) IS RESERVED)
	CLR	6(SP)		;AND FILL IT WITH ZERO INITIALLY
	CMPB	$SIGN(R2),$SIGN(R4) ; COMPARE SIGNS OF ARGS
	BGT	1100$		;ARG1>ARG2
	BLT	900$		;ARG1<ARG2

; SIGNS ARE EQUAL; WE MUST COMPARE MAGNITUDES

	CMPB	$LEFT(R2),$LEFT(R4) ;COMPARE # OF SIG DIGITS TO LEFT
				;OF DECIMAL POINT
	BIF	495$,,515$	;IF NOT SAME WE KNOW ONE NUMBER IS BIGGER

; AT THIS POINT WE KNOW NUMBERS HAVE SAME NUMBER OF SIGNIFICANT DIGITS
; TO LEFT OF DECIMAL POINT--WE FIRST COMPARE THE 'WHOLE NUMBER' PARTS

	TSTB	$LEFT(R2)	;IF NO SIGNIFICANCE TO THE LEFT,
	BEQ	200$		;THEN GO AHEAD AND COMPARE FRACTIONAL PART

.IIF NE $MSOFF .ERROR		;FOLLOWING WON'T WORK
	$XCMP	<R3,(R2)>, <R5,(R4)>, $LEFT(R4)
				;COMPARE SIGNIFICANT DIGITS TO LEFT
				;OF DECIMAL POINT
	BIF	495$,,515$	;IF NOT EQUAL WE KNOW WHICH IS BIGGER

;+
; AT THIS POINT WE MUST COMPARE THE PLACES TO THE RIGHT OF THE
; DECIMAL POINT,IF THERE ARE ANY
;-

200$:	MOVB	$RIGHT(R2),R0	;GET # OF TRAILING DIGITS IN ARG1
	BGT	250$		;IF THERE AREN'T ANY,
	TSTB	$RIGHT(R4)	;WE LOOK AT HOW MANY ARG2 HAS,
	BIF	,500$,490$	;AND BRANCH ACCORDINGLY

250$:	MOVB	$RIGHT(R4),R1	;GET # OF TRAILING DIGITS IN ARG2
	BEQ	510$		;IF ZERO WE KNOW FIRST ARG IS BIGGER

; THIS BLOCK OF CODE PLACES MIN(R0,R1) IN R0 AND (R0-R1) IN R1

	MOV	R1,-(SP)	;SAVE VALUE FOR LATER
	SUB	R1,R0		;R0 IS SIGNED DIFFERENCE
	MOV	R0,R1		;SAVE R0-R1 IN R1
	BLE	300$		;ELSE WE MOVE AHEAD
	CLR	R0		;SO THAT R0 WILL END UP CONTAINING THE OLD R1
300$:	ADD	(SP)+,R0	;R0 NOW CONTAINS MIN(R0,R1)

; HERE WE COMPARE THE TRAILING DIGITS OF THE TWO STRINGS UP TO THE
; L.S.D. OF THE LEAST SIGNIFICANT

	$XCMP	<R3,$LSOFF(R2),$RIGHT(R2)>, <R5,$LSOFF(R4),$RIGHT(R4)>, R0
	BIF	490$,,510$	;IF NOT EQUAL WE KNOW WHICH IS LARGER

; COMPARABLE TRAILING DIGITS ARE EQUAL, SO LONGER MUST HAVE LARGER
; MAGNITUDE

	TST	R1		;FIND OUT WHICH ONE WAS LONGER
	BIF	490$,500$	;AND BRANCH ACCORDINGLY

;+
; THE FOLLOWING THREE LABELS ARE REACHED WITH A KNOWLEDGE OF
; WHICH STRING HAS LARGER ABSOLUTE MAGNITUDE; WE RESTORE REGISTERS,
; LOOK AT THE COMMON SIGN, AND MAKE TOWARD THE EXIT ACCORDINGLY
;-

510$:				;REACH HERE IF ABS(ARG1) > ABS(ARG2)
515$:	TSTB	$SIGN(R2)	;TEST SIGN
	BIF	900$,1100$	;AND BRANCH ACCORDINGLY

490$:				;REACH HERE IF ABS(ARG1)<ABS(ARG2)
495$:	TSTB	$SIGN(R2)	;TEST SIGN OF ARGS
	BIF	1100$		;AND BRANCH ACCORDINGLY

;+
; RECALL THAT 6(SP) WAS ZEROED IN THE INITIALIZATION
; WHEN WE REACH HERE ALL WE MUST DO IS PUT RESULT ON STACK AND RETURN
;-

900$:	COM	6(SP)		; ARG1 < ARG2--RETURN -1 ON STACK
	BR	1010$		;AND EXIT

1100$:	INC	6(SP)		;ARG1>ARG--RETURN 1 ON STACK
500$:				;REACH HERE IF ABS(ARG1)=ABS(ARG2)
1000$:				;ARG1=ARG2--RETURN 0 ON STACK
1010$:	POP	<R1,R0>		;RESTORE R1 & R0
	$EXIT			;EXIT $CMPN

;+
; THIS IS THE SUBROUTINE WHERE CHARACTER BY CHARACTER COMPARISONS
; ARE DONE
;	ENTRY:	R0 = NUMBER OF CHARS TO COMPARE
;		R1-> HEAD 1ST STRING
;		R2->HEAD 2ND STRING
;	EXIT:	REGISTERS R0,R1,R2 ALTERED
;		SIGN(R0) =SIGN(ARG1-ARG2)
;-

XCMPS:
10$:	CMPB 	(R1)+,(R2)+	;COMPARE CHARACTERS
	BGT	30$		;FIRST STRING LARGER
	BEQ	20$		;KEEP COMPARING
	NEG	R0		;FIRST STRING SMALLER
	BR	30$		;AND EXIT

20$:	SOB	R0,10$		;LOOP ON FURTHER PLACES
30$:	RTS	PC		;RETURN 0 IN R0 IF STRINGS EQUAL

.SBTTL	STRING ARITHETIC UTILITIES

;+
; THE STRING-ARITHMETIC ROUTINES DESCRIBED BELOW SHARE A NUMBER OF THINGS IN
; COMMON:
;	1) EACH ROUTINE (EXCEPT $ZERO) OPERATES ON TWO STRINGS, ONE CALLED THE
;	ACCUMULATOR, THE OTHER CALLED THE OPERAND.
;	2) EACH ROUTINE IS ENTERED WITH:
;		R2 POINTING AT ACCUMULATOR DESCRIPTOR BLOCK
;		R3 POINTING AT THE ACCUMULATOR (THE L.S. DIGIT IN SOME CASES)
;		R4 POINTING AT OPERAND DESCRIPTOR BLOCK
;		R5 POINTING AT THE OPERAND
;	3) EACH ROUTINE PRESERVES REGISTERS R0-R5.
;
; THE ROUTINES ARE THE FOLLOWING:
;
; $ADDU ADDS THE MAGNITUDE OF THE OPERAND TO THE MAGNITUDE OF THE ACCUMULATOR,
; WITHOUT SIGN CORRECTION. FOR THIS ROUTINE, R3 POINTS AT THE L.S. DIGIT IN THE
; ACCUMULATOR AND THE ACCUMULATOR DESCRIPTOR BLOCK IS COMPLETELY IGNORED.
; HOWEVER, THE OPERAND DESCRIPTOR BLOCK IS USED TO DEFINE THE LOCATION OF THE
; SIGNIFICANT PORTION OF THE OPERAND'S MAGNITUDE, AND ONLY THAT PORTION OF THE
; OPERAND IS USED. IF A NONNUMERIC CHARACTER IS DISCOVERED IN EITHER THE
; ACCUMULATOR OR THE OPERAND DURING THE ADDITION PROCESS, IT IS SIMPLY SKIPPED
; OVER WITHOUT DECLARING AN ERROR. (THE PURPOSE OF THIS IS TO ALLOW $ADDU TO BE
; USED FOR REPEATED, SHIFTED ADDITION IN A MULTIPLICATION ROUTINE WHERE THE
; INVOKING ROUTINE HAS ALREADY WORRIED THRU THE PROBLEM OF DECIMAL POINT
; ALIGNMENT IN THE PRODUCT.) IT IS ASSUMED THAT SUFFICIENT SPACE HAS BEEN
; ALLOWED IN THE ACCUMULATOR TO ALLOW FOR CARRY PROPAGATION.
;
; $SUBU SUBTRACTS THE MAGNITUDE OF THE OPERAND FROM THE MAGNITUDE OF THE
; ACCUMULATOR, WITHOUT SIGN CORRECTION. THE ROUTINE IS SIMILAR TO $ADDU. IT IS
; ASSUMED THAT THE MAGNITUDE OF THE ACCUMULATOR EXCEEDS THE MAGNITUDE OF THE
; OPERAND SO THAT BORROW PROPAGATION IS LIMITED.
;
; $COPY COPIES THE SIGNIFICANT PORTION OF THE MAGNITUDE OF THE OPERAND INTO
; THE ACCUMULATOR, USING THE DESCRIPTOR BLOCKS TO LOCATE THE EXACT POSITION
; WITHIN THE ACCUMULATOR FOR THE COPY. THE OPERAND'S DECIMAL POINT, IF ANY WITHIN
; THE SIGNIFICANT MAGNITUDE, IS COPIED INTO THE ACCUMULATOR. THE REMAINING
; LEADING AND TRAILING DIGITS WITHIN THE ACCUMULATOR'S SIGNIFICANT MAGNITUDE
; ARE SET TO 0. (THIS ROUTINE IS INTENDED TO MAKE A COPY OF THE OPERAND WITH
; PRE-SPECIFIED DECIMAL POINT LOCATION TO PROVIDE EXPANDED WORK SPACE FOR
; ARITHMETIC UTILITIES.)
;
; $ZERO ZEROES OUT THE SIGNIFICANT MAGNITUDE OF THE ACCUMULATOR, INSERTING THE
; DECIMAL POINT WHERE INDICATED BY THE ACCUMULATOR DESCRIPTOR BLOCK.
;
; $CMPN ARITHMETICALLY COMPARES THE ACCUMULATOR TO THE OPERAND, RETURNING
; SIGN(ACC-OPRD) ON TOP OF THE STACK (I.E. (SP)=1 IF ACC>OPRD,
; (SP)=0 IF ACC=OPRD, (SP)=-1 IF ACC<OPRD).
;-

.SBTTL	$COPY  OPERAND TO ACCUMULATOR, ALIGNING DECIMAL POINT

$COPY:
	PUSH	<R0,R1,R3,R5>	;THESE ARE USED AS WORK REGISTERS

.IIF NE $MSOFF .ERROR		;FOLLOWING WON'T WORK
	MOVB	(R4),R1		;GET M.S.D. OFFSET
	ADD	R1,R5		;R5->MOST SIG DIGIT

.IIF NE $MSOFF .ERROR		;FOLLOWING WON'T WORK
	MOVB	(R2),R1		;GET ACC. M.S.D.
	ADD	R1,R3		;R3->ACC M.S.D.

	MOVB	$LEFT(R2),R0	;GET $LEFT(ACC)
	MOVB	$LEFT(R4),R1	;GET $LEFT(OPRD)
	SUB	R1,R0		;R0=DIFFERENCE IN LEADING SIGNIFICANCE
	BGT	10$		;ZERO FILL IF $LEFT(ACC) > $LEFT(OPD)
	CLR	R0		;ELSE SET LEFT ZERO FILL COUNT TO 0
	BR	101$		;AND BRANCH AROUND ZERO FILL ROUTINE

;MORE LEADING SIGNIFICANT DIGITS IN ACC THAN OPRD, SO WE NEED
;TO ZERO THEM

10$:	PUSH	R0		;SAVE FILL COUNT FOR OTHER SIDE OF LOOP
20$:	MOVB	#'0,(R3)+	;FILL IN A ZERO
	SOB	R0,20$		;AND LOOP UNTIL EXCESS TAKEN CARE OF
	POP	R0		;RESTORE FILL COUNT

;+
; HERE WE DETERMINE THE NUMBER OF PLACES TO BE COPIED, WHICH IS
; MIN( $LSOFF(ACC)-$MSOFF(ACC)-[# LEFT ZERO FILLS], $LSOFF(OPRD)-$MSOFF(OPRD) )
;-

100$:	NEG	R0		;MUST SUBTRACT FILL COUNT SO CHANGE SIGN
101$:	MOVB	$LSOFF(R2),R1	;COPY LEFT SIGNIFICANT OFFSET
	ADD	R1,R0		;ADD TO -[#LEFT ZERO FILLS]
.IIF NE $MSOFF .ERROR		;FOLLOWING WON'T WORK
	MOVB	(R2),R1		;OFFSET OF MSD IN ACC
	SUB	R1,R0		;DIFFERENCE IS # OF SIGNIFICANT PLACES
	MOV	R0,-(SP)	;SAVE VALUE SO WE CAN REUSE REGISTERS
	MOVB	$LSOFF(R4),R0	;LSD OFFSET IN OPRD
.IIF NE $MSOFF .ERROR		;FOLLOWING WON'T WORK
	MOVB	(R4),R1		;MSD OFFSET IN OPRD
	SUB	R1,R0		;R0=#OF SIG DIGITS IN OPRD
	SUB	(SP),R0		;R0 = DIFFERENCE IN SIGNIFICANCE
	MOV	R0,R1		;SAVE THIS VALUE FOR LATER
	BLE	110$		;WE WANT THE MIN OF THE 2 LENGTHS IN R0
	CLR	R0		;MOST RECENT R0 WAS LARGER,SO COPY OLD IN
110$:	ADD	(SP)+,R0	;R0 IS THE # OF DIGITS TO COPY
	BEQ	130$		;OPERAND(PRESUMABLY)=0 SO NO COPY

; HERE WE COPY THE OPERAND TO THE ACCUMULATOR

120$:	MOVB	(R5)+,(R3)+	;COPY OPRD TO ACC
	SOB	R0,120$		;FOR EACH SIGNIFICANT DIGIT

; HERE WE SEE IF WE NEED TO ZERO FILL ON RIGHT, AND DO SO IF NECESSARY

130$:	TST	R1		;SEE IF ZERO FILLS REQUIRED
	BGE	160$		;EXIT IF NOT
	NEG	R1		;MAKE DIFFERENCE IN SIGNIFICANCE POSITIVE

; THIS SECTION OF CODE DETERMINES IF THE FIRST ZERO FILL SHOULD IN FACT BE
; A DECIMAL POINT

	TSTB	$RIGHT(R4)	;SEE IF WE HAVE ALREADY COPIED POINT
	BGT	140$		;WE HAVE UNLESS OPERAND INTEGER
	TSTB	$RIGHT(R2)	;SEE IF ACCUMULATOR IS INTEGER
	BEQ	140$		;AND GO AHEAD IF IT IS DESCRIBED SO
	MOVB	#'. ,(R3)+	;MOVE DECIMAL POINT IN
	DEC	R1		;ADJUST RIGHT ZERO FILL COUNT
	BEQ	160$		;EXIT IF NO MORE ZERO FILLS

; HERE WE DO THE ZERO FILL

140$:	MOVB	#'0,(R3)+	;ZERO FILL ON RIGHT
	SOB	R1,140$		;FOR AS MANY PLACES AS NECESSARY

; RESTORE REGISTERS AND EXIT

160$:	POP	<R5,R3,R1,R0>	;RESTORE REGISTERS
	RTS	PC		;AND RETURN


.SBTTL	$ZERO - CLEAR ACCUMULATOR WITH PROPER DEC.PT.
;+
; THIS SUBROUTINE PLACES ZEROS IN ALL THE SIGNIFICANT PLACES IN AN ACCUMULATOR
; INSERTING THE DECIMAL POINT AS APPROPRIATE
;-

$ZERO:
	PUSH	R1		;USE THIS FOR WORK REGISTER
	PUSH	R3		;AND THIS AS STRING POINTER
.IIF NE $MSOFF .ERROR		;FOLLOWING WON'T WORK
	ADDB	(R2),R1,R3 	;POINT AT FIRST SIGNIFICANT DIGIT
	MOVB	$LEFT(R2),R1	;SEE IF ANY SIGNIFICANCE TO LEFT OF POINT
	BEQ	20$		;IF NOT GO LOOK AT RIGHT

; ZERO FILL ON LEFT

10$:	MOVB	#'0,(R3)+	;INSERT A ZERO 
	SOB	R1,10$		;AND LOOP UNTIL $LEFT EXHAUSTED

; DETERMINE IF ZERO FILL ON RIGHT NECESSARY

20$:	MOVB	$RIGHT(R2),R1	;SEE IF ANY PLACES TO THE RIGHT
	BEQ	40$		;IF NOT WE ARE FINISHED

; DO ZERO FILL ON RIGHT

	MOVB	#'.,(R3)+	;INSERT DECIMAL POINT

30$:	MOVB	#'0,(R3)+	;INSERT A ZERO
	SOB	R1,30$		;LOOP UNTIL $RIGHT EXHAUSTED

; EXIT

40$:	POP	<R3,R1>		;RESTORE REGISTERS
	RTS	PC		;GOODBYE

.SBTTL	$ADDU--ADD 'UNFORMATTED' STRINGS OF DIGITS TOGETHER

$ADDU:
	PUSH	<R0,R1,R2,R3,R4,R5> ;WE NEED TO USE ALL REGISTERS
	JSR	PC,CTLOOP	;START COMMON CONTROL LOOP
1030$:	ADD	R4,R5		;ADD DIGITS TOGETHER
	CMP	R5,#'0+'9	;CHECK FOR CARRY
	BLE	200$		;IF NOT GO AHEAD AND STORE BACK
	SUB	#10.,R5		;"SUBTRACT 10...
	INC	R0		;...AND CARRY A 1"
200$:	SUB	#'0,R5		;CORRECT FOR ASCII REPRESENTATION
	JSR	PC,@(SP)+	;BACK TO CONTROL LOOP
	$GO.IF	,EQ,,1030$	;LOOP IF STILL ADDING

; WE GET HERE IF WE NEED TO HANDLE A FINAL CARRY PROPAGATION

$CARRY:				;THIS IS A UTILITY TOO!
1020$:	$GO.IF	-(R3),EQ,#'.,1020$,B ;CARRIES DON'T CHANGE DECIMAL POINTS
	INCB	(R3)		;ADD IN CARRY
	$GO.IF	(R3),LE,#'9,1050$,B ;BR IF NO CARRYOUT
	MOVB	#'0,(R3)	;REPLACE THE DIGIT WITH A 0
	BR	1020$		;AND LOOP BACK TO NEXT TEST

1050$:	JSR	PC,@(SP)+	;RETURN TO LOOP COROUTINE TO EXIT

;+
; CTLOOP IS THE CONTROL LOOP COROUTINE FOR $ADDU & $SUBU.
;-

CTLOOP:	MOVB	$LSOFF(R4),R2	;R2->1 PAST LSD IN OPERAND
	MOV	R2,R1		;IN R1 CALCULATE # OF SIGNIFICANT PLACES
				;IN OPERAND
	ADD	R5,R2		;R2 NOW IN FACT A PTR AND NOT AN OFFSET
.IIF NE $MSOFF .ERROR		;FOLLOWING WON'T WORK
	MOVB	(R4),R4		;FOR SIGNIFICANT PLACE CALCUALTION
	SUB	R4,R1		;R1 IS NO. OF SIGNIICANT PLACES
	BEQ	2000$		;ZERO OPERAND; EXIT IMMEDIATELY

;+
; FROM HERE ON OUT REGISTER USAGE IS
;	R0	CARRY OR BORROW FLAG
;	R1	# OF DIGITS OF OPERAND TO ADD OR SUBTRACT
;	R2	POINTER IN OPERAND STRING
;	R3	POINTER IN ACCUMULATOR STRING
;	R4,R5	WORK REGISTERS
;-

	CLR	R0		;CLEAR CARRY FOR FIRST GO-ROUND

;ADD OR SUBTRACT NEXT HIGHER ORDER DIGIT PAIR

100$:	MOVB	-(R2),R4	;GET NEXT OPRD DIGIT
	CMPB	R4,#'.		;MAKE SURE IT'S REALLY A DIGIT
	BEQ	1000$		;IF NOT LOOP AROUND AGAIN

150$:	MOVB	-(R3),R5	;GET NEXT ACC DIGIT
	CMPB	R5,#'.		;MAKE SURE IT'S NOT DEC.PT.
	BEQ	150$		;IF IT IS,LOOP AROUND TO GET NEXT DIGIT
	ADD	R0,R5		;FIRST ADD IN CARRY OR BORROW FLAG
	CLR	R0		;AND RESET IT
;	SEZ			;TELL HIM TO ADD A DIGIT
	JSR	PC,@(SP)+	;COROUTINE BACK TO $ADDU OR $SUBU
	MOVB	R5,(R3)		;STORE BACK IN ACC STRING
1000$:	SOB	R1,100$		;LOOP WHILE THERE ARE OPERAND DIGITS TO ADD

; MAIN ADDITION FINISHED; NOW JUST PROPOGATE CARRY

1010$:	TST	R0		;SEE IF THERE IS A CARRY
	BEQ	2000$		;IF NOT WE ARE FINISHED
;	CLZ			;TELL HIM TO CLEAN UP CARRY OR BORROW PROPAGATION
	JSR	PC,@(SP)+	;COROUTINE BACK TO $ADDU OR $SUBU

; WE ARE FINISHED; RESTORE REGISTERS AND RETURN

2000$:	TST	(SP)+		;DUMP COROUTINE RETURN ADDRESS
	POP	<R5,R4,R3,R2,R1,R0> ;RESTORE
	RTS	PC		;AND GOODBYE

.SBTTL	$SUBU--SUBTRACT 'UNFORMATTED' STRINGS OF DIGITS 

$SUBU:
	PUSH	<R0,R1,R2,R3,R4,R5> ;WE NEED TO USE ALL REGISTERS
	JSR	PC,CTLOOP	;START UP SUBTRACT CONTROL LOOP
1030$:	SUB	R4,R5		;SUBTRACT CORRESPONDING DIGIT PAIR
	BGE	200$		;IF ACC DIGIT HIGHER, NO BORROW
	ADD	#10.,R5		;"BORROW 10...
	COM	R0		;...FROM THE LEFT" (SET BORROW FLAG)
200$:	ADD	#'0,R5		;CORRECT TO ASCII REPRESENTATION
	JSR	PC,@(SP)+	;BACK TO CONTROL LOOP
	$GO.IF	,EQ,,1030$	;BR TO SUBTRACT ANOTHER DIGIT

; WE GET HERE TO HANDLE FINAL BORROW PROPAGATION

1020$:	$GO.IF	-(R3),EQ,#'.,1020$,B ;BORROWS DON'T CHANGE DECIMAL POINTS
	DECB	(R3)		;SUBTRACT OUT BORROW
	$GO.IF	(R3),GE,#'0,1050$,B ;BR IF NO BORROW TO MAKE THIS BORROW WORK
	MOVB	#'9,(R3)	;REPLACE THE DIGIT WITH A 9
	BR	1020$		;AND LOOP BACK TO NEXT BORROW

1050$:	JSR	PC,@(SP)+	;EXIT THRU COROUTINE

	.END

