TITLE	IO,<RECORD IO FEATURE>,08,13-MAY-86,TPH/JDM/MHB

;                   Copyright 1974,1990 by Digital Equipment Corporation
;                                  All rights reserved.
;
;          This software is furnished under a license and may be used and copied
;          only  in  accordance  with  the  terms  of  such license and with the
;          inclusion of the above copyright notice.  This software or any copies
;          shall not be provided to any other person.   No title to or ownership
;          of the software is hereby transferred.
;
;          The information in this software is subject to change without notice.
;
;          DIGITAL  assumes  no  responsibility  for the  use, functionality, or
;          reliability of its  software  on equipment  which  is not supplied by
;          DIGITAL.

	.SBTTL	MAGTAPE SPECIAL FUNCTION

	ORG	PT,0
	..	PPMAGT,MAGTAP
	..	PPSPEC,SPECAL

	DEFORG	MF

	.GLOBL	INTFUN,INTFAI,INTFAF,INTFAS,IODIE,UUOSPC,FLTLE2

;	MAGTAPE(F,C,N)
;	F = FUNCTION CODE + 1
;	C = COUNT (OR ZERO IF IRRELEVENT)
;	N = I/O CHANNEL

.ENABL	LSB

MAGTAP:	JSR	R5,@#INTFUN	;TAKE CARE OF TYPE CHANGES
	ARGS	FAI,FAF,FAI	; F=INT, C IS FLOATED, N=INT
	MOV	#MTAHND,-(R1)	;THIS IS THE HANDLER INDEX
	DEC	FLTLE2+4(R1)	;MAKE THE REAL FUNCTION CODE
	BR	10$		;NOW CONTINUE

;	SPEC%(F,C,N,H)
;	F = FUNCTION CODE
;	C = COUNT (OR ZERO IF IRRELEVENT)
;	N = I/O CHANNEL
;	H = HANDLER INDEX

SPECAL:	JSR	R5,@#INTFUN	;TAKE CARE OF TYPE CHANGES
	ARGS	FAI,FAF,FAI,FAI	; F=INT, C=FLT, N=INT, H=INT
10$:	SWAB	(R1)		;PUT HANDLER INDEX INTO HIGH BYTE
	BIS	(R1)+,(R1)	; AND .OR. INTO CH #
	ASLB	(R1)		;NOW MAKE CH # TIMES 2
	MOV	(R1)+,-(SP)	;SAVE HANDLER INDEX/CH # TIMES 2
	CALLX	CNVFDI		;CONVERT FLOATING COUNT INTO DOUBLE INTEGER
	MOV	#XRB+XRBSIZ,R3	;GET AN XRB POINTER
20$:	CLR	-(R3)		;CLEAR THE XRB
	CMP	R3,#XRB+XRCI	;UP TO CHANNEL/HANDLER INDEX?
	BHI	20$		;NOT YET...
	MOV	(SP)+,(R3)	;LOAD XRCI WITH HANDLER INDEX/CH # *2
	MOV	(R1)+,-(R3)	;LOAD XRLOC WITH FUNCTION COUNT MSB
	MOV	(R1)+,-(R3)	;LOAD XRBC WITH THE FUNCTION COUNT
	MOV	(R1)+,-(R3)	;LOAD FUNCTION CODE INTO XRLEN
	.SPEC			;DO IT
	MOV	XRB+XRBC,-(R1)	;ANSWER
	JMP	IODIE		;CK IOSTS, RTS PC OR DIE

.DSABL	LSB

	.SBTTL	BUFFER SIZE FUNCTION

	..	PPBUFN,BUFN

	ORG	MF

	.GLOBL	INTFAI

BUFN:	JSR	R5,INTFAI	;GET A 'FAI' ARG
	MOV	(R1)+,R3	;GET CHANNEL NUMBER
	BIC	#-17-1,R3	;MAKE IT LEGAL
	ASH	#4,R3		;TIMES 16.
	ADD	SPDA,R3		;MAKE ABSOLUTE
	MOV	LENGTH+BASE+IOLEN(R3),-(R1);SET BUFFER'S SIZE
	RTS	PC		;AND EXIT

	.SBTTL	UNLOCK VERB

	.if eq 0	;Originally .if df HELLO	WJS 90.1.31
	ORG	XT,TKULOC-DOTABV
	.WORD	$$ULOC	;ALLOW UNLOCK VERB
	.endc	;eq 0					WJS 90.1.31

	ORG	PT,0
	..	PPULOC,UNTLOC

	DEFORG	UP

	.if eq 0	;Originally .if df HELLO	WJS 90.1.31
	.GLOBL	SAINT
;UNLOCK VERB

$SAINT	ULOC			;INITIALLY ENTER SYNTAX ANALYZER...
	RT	POUND		;MUST BE A "#"
	RCI			;NOW GET ANY INTEGER
	CB	PPULOC		;UNLOCK POP
	QUIT			;ALLOW MODIFIERS
	.endc	;eq 0					WJS 90.1.31

	.EVEN
UNTLOC:	CLR	XRB+XRLEN
	ASL	(R1)		;MAKE INDEX
	CLRB	1(R1)		;DEVICE TYPE = 0
.IIF	NE	DSKHND, .ERROR ;THE ABOVE WON'T WORK
	MOV	(R1)+,XRB+XRCI	;TO BECOME CHANNEL INDEX
	JMP	UUOSPC

	.if eq 0	;Originally .if df HELLO	WJS 90.1.31
	ORG	XT,TKGET-DOTABV
	.WORD	$$GET	;GET
	.WORD	$$PUT	;PUT
	.WORD	$$FIEL	;FIELD
	.WORD	$$LSET	;LSET
	.WORD	$$RSET	;RSET
	.endc	;eq 0					WJS 90.1.31
	ORG	PT,0

	..	PPGET,GET
	..	PPPUT,PUT
	..	PPCVIS,CVIS
	..	PPCVFS,CVFS
	..	PPCVSI,CVSI
	..	PPCVSF,CVSF
	..	PPLSET,LSET
	..	PPILS1,M1LSET
	..	PPILS2,M2LSET
	..	PPRSET,RSET
	..	PPIRS1,M1RSET
	..	PPIRS2,M2RSET
	..	PPFSET,FIELD
	..	PPIFS1,M1FSET
	..	PPIFS2,M2FSET
	..	PPXLTE,XLATE

	DEFORG	IO

	.if eq 0	;Originally .if df HELLO	WJS 90.1.31
	.GLOBL	SAINT,TLIDXH,SELECT,SKPCOM			;(TR)
	.endc	;eq 0					WJS 90.1.31
	.GLOBL	SSONRC,REA.D,WRIT.E,PUSHS,LENP3,BUILDS,SSIDN,CVS3 ;(RC)
	.GLOBL	INDO2,INTFUN,PSTJS,INDX90			;(MA)
	.GLOBL	FLTLE2,MID9

.SBTTL	GET AND PUT

; PUT
;
;		NEW		OLD
;
;	R1 ->	,OFFSET		,COUNT
;		,COUNT		,RECORD
;		,BLOCK (MSB)	CHANNEL NUMBER(S)
;		,BLOCK (LSB)
;		CHANNEL NUMBER(S)

.ENABL	LSB

PUT:	CMPB	(R5)+,#PPPUT	;NEW OR OLD?
	BEQ	10$		;NEW
	DEC	R5		;OLD, BACK UP THE IPC
	MOV	(R1),-(R1)	;MOVE ,COUNT UP ON R1 STACK
	CLR	2(R1)		; AND MAKE ,BLOCK MSB BE ZERO
	CLR	-(R1)		;DUMMY ,OFFSET AS ZERO
10$:	JSR	PC,SETUP	;DO COMMON THING
	JSR	PC,WRIT.E	;NOW DO THHE WRITE OPERATION
	BEQ	50$		;NO ERROR, EXIT
	IOTERR	!FATAL		;ELSE ERROR

; GET
;
;		NEW		OLD
;
;	R1 ->	,OFFSET		,RECORD
;		,COUNT		CHANNEL NUMBER(S)
;		,BLOCK (MSB)
;		,BLOCK (LSB)
;		CHANNEL NUMBER(S)

GET:	CMPB	(R5),#PPGET	;NEW OR OLD?
	BEQ	20$		;NEW
	CLR	-(R1)		;OLD, DUMMY ,BLOCK MSB AS ZERO
	CLR	-(R1)		;DUMMY ,COUNT AS ZERO
	CLR	-(R1)		;DUMMY ,OFFSET AS ZERO
20$:	JSR	PC,SETUP	;DO COMMON THING
	MOV	R2,R0		;SET LIMITING "COUNT" VALUE
	JSR	PC,REA.D	;NOW DO THE READ OPERATION
	CMPB	(R5),#PPGET	;NEW OR OLD?
	BEQ	30$		;NEW
	ADD	#3*2,R1		;OLD, POP DUMMIES
30$:	JSR	PC,SSIDN	;FINISH UP
	CMPB	(R5)+,#PPGET	;NEW OR OLD?
	BEQ	40$		;NEW
	DEC	R5		;OLD, BACK UP THE IPC
	SUB	#3*2,R1		;RE-PUSH SOME DUMMY DUMMIES
40$:	CLR	BYTCNT(R3)	;"EMPTY" THE BUFFER
50$:	ADD	#4*2,R1		;POP "COUNT", "BLOCK", AND CHANNEL NUMBER(S)
	RTS	PC		; AND EXIT

.DSABL	LSB

; COMMON SET UP
;
;	R1 ->	,OFFSET
;		,COUNT
;		,BLOCK (MSB)
;		,BLOCK (LSB)
;		CHANNEL NUMBER(S)
;
;	JSR	PC,SETUP
;
;	R0 =	BUFFER SIZE
;
;		,OFFSET
;	R1 ->	,COUNT
;		,BLOCK (MSB)
;		,BLOCK (LSB)
;		CHANNEL NUMBER(S)
;
;	R2 =	BUFFER 'COUNT'
;	R3 ->	BUFFER HEADER @ "SLOT"
;	R4 ->	BUFFER

SETUP:	CLR	-(R1)		;MAKE A 0 WORD ON R1 STACK
	MOVB	13(R1),(R1)	; TO GET BUFFER CHANNEL NUMBER
	;NOTE:	Z=1 IF NO BUFFER CHANNEL SPECIFIED
	JSR	PC,50$		;DO THE COMMON CHANNEL THING
	MOV	R0,-(SP)	;SAVE BUFFER'S SIZE
	MOV	R4,-(SP)	;SAVE (ABS) PTR TO BUFFER
	CLR	-(R1)		;MAKE A 0 WORD ON R1 STACK
	;SEZ			;Z=1 FROM THE 'CLR'
	JSR	PC,50$		;DO THE COMMON CHANNEL THING
	MOV	(SP)+,R4	;RESTORE (ABS) PTR TO BUFFER
	MOV	(SP)+,R0	;RESTORE BUFFER'S SIZE
	ADD	(R1),R4		;ADD "OFFSET" TO BUFFER PTR
	SUB	(R1)+,R0	;SUBTRACT "OFFSET" FROM BUFFER'S SIZE
	BHI	10$		;STILL HAVE SOME SIZE LEFT
	ERROR	BADCNT,FATAL	; ELSE ERROR

10$:	MOV	(R1),R2		;GET "COUNT"
	BEQ	20$		;NONE, USE SIZE
	CMP	R2,R0		;IS "COUNT" <= SIZE ?
	BLOS	30$		;YES, SO USE IT
20$:	MOV	R0,R2		;NO, USE SIZE AS "COUNT"
30$:	MOVB	2(R1),CURBKM-SLOT(R3) ;SET BLOCK MSB VALUE IF ANY
	MOV	4(R1),CURBLK-SLOT(R3) ;SET BLOCK LSB VALUE IF ANY
	BNE	40$		;ONE, GO CHECK FOR RANDOM ACCESS
	TSTB	2(R1)		;NO LSB, ANY MSB?
	BEQ	70$		;NONE, JUST EXIT
40$:	TST	(R3)		;ONE, RANDOM ACCESS?
	BMI	70$		;ALL O.K. IF RANDOM ACCESS
.IIF	NE	FLGRND-100000, .ERROR ;THE ABOVE WON'T WORK
	ERROR	NORACS,FATAL	; ELSE ERROR

50$:	BNE	60$		;ALTERNATE SPECIFIED
	MOVB	12(R1),(R1)	;ELSE USE STD I/O CHANNEL NUMBER
60$:	JSR	PC,SSONRC	;SELECT THIS CHANNEL
	ADD	R2,R3		;ABS POINTER TO BUFFER HEADER NOW
	MOV	R3,R4		;COPY ABS PTR TO BUFFER HEADER
	CMP	(R3)+,(R3)+	;INDEX TO BUFFER'S SIZE
	MOV	(R3)+,R0	; AND GET BUFFER'S SIZE
	CLR	(R3)+		;CLEAR BYTCNT
	MOV	PNTR-CURLOC(R3),(R3) ;RESET CURLOC TO BE PNTR
	ADD	(R3)+,R4	;FIND ABS POINTER TO THE BUFFER
	BIC	#WRTARY*400,(R3) ;CLEAR "WRITE IT" BIT
	CLR	CURBLK-SLOT(R3)	;CLEAR THE BLOCK NUMBER
	CLRB	CURBKM-SLOT(R3)	; IN BOTH PLACES
70$:	RTS	PC		;EXIT

; LEFT-JUSTIFIED STRING SET

M1LSET:	CLR	-(R1)		;DUMMY SECOND INDEX TO 0
M2LSET:	JSR	PC,COMAST	;AND DO THE INDEXING
	BR	MLSET		;NOW DO THE MOVING

LSET:	JSR	PC,COMSET	;DO THE COMMON THING
MLSET:	SUB	R2,R3		;R2=LEN(SRC)-LEN(DST)
	BGE	2$		;IF SRC>=DST THEN JUST MOVE IT TO DST
	ADD	R3,R2		;R2 IS NOW THE LEN(SRC)
	JSR	PC,2$		;SO COPY SRC TO DST
1$:	MOVB	#40,(R0)+	;AND FILL IN PADDING
	INC	R3		;THE COUNT IN R3 TELLS US
	BNE	1$		;WE HAVE DONE IT
2$:	DEC	R2		;ANY OF SRC LEFT TO MOVE
	BMI	LSET2		;NO, EXIT
	MOVB	(R4)+,(R0)+	;YES, MOVE IT
	BR	2$		;LOOP

; RIGHT-JUSTIFIED STRING SET

RSET:	JSR	PC,COMSET	;DO THE COMMON THING
MRSET:	ADD	R2,R0		;POINT TO END OF DST
	ADD	R3,R4		;AND TO END OF SRC
	SUB	R2,R3		;R3=LEN(SRC)-LEN(DST)
	BGE	1$		;IF SRC>DST, JUST MOVE
	ADD	R3,R2		;IF DST<SRC, THEN FILL
	JSR	PC,1$		;MOVE FIRST
3$:	MOVB	#40,-(R0)	;FILL ONE MORE BYTE
	INC	R3		;MORE?
	BNE	3$		;YES, CONTINUE
1$:	DEC	R2		;MORE SRC?
	BMI	LSET2		;NO, EXIT
	MOVB	-(R4),-(R0)	;YES, CONTINUE
	BR	1$		;LOOP

M1RSET:	CLR	-(R1)		;DUMMY SECOND INDEX TO 0
M2RSET:	MOV	#MRSET,-(SP)	;RETURN TO "MRSET"
COMAST:	JSR	PC,INDO2	;DO THE INDEXING
	BR	CMASET		;THEN CONTINUE IN COMMON

COMSET:	JSR	PC,PUSHS	;PUSH DST STRING
CMASET:	MOV	R1,R0		;SAVE R1 STACK POINTER
	ADD	PNTR(R0),R0	;NOW R0 IS ABS. POINTER TO DST
	JSR	PC,LENP3	;PUT LEN(DST) ON R1 STACK
	MOV	(R1)+,R2	;NOW R2 IS LEN(DST)
	MOV	R1,R4		;SAVE R1 STACK POINTER
	ADD	PNTR(R4),R4	;NOW R4 IS ABS. POINTER TO SRC
	JSR	PC,LENP3	;PUT LEN(SRC) ON R1 STACK
	MOV	(R1)+,R3	;NOW R3 IS LEN(SRC)
LSET2:	RTS	PC		;AND EXIT WITH CONDITIONS SET

; MAKE STRING INTO A FLOATER

CVSF:	MOV	#FLTLE2,-(SP)	;SET (SP) TO NUMBER BYTES IN A FLOATER
	BR	CVSF02		;AND CONTINUE

; MAKE STRING INTO AN INTEGER

CVSI:	MOV	#2,-(SP)	;THERE ARE 2 BYTES IN AN INTEGER
CVSF02:	JSR	R5,INTFAS	;STRAIGHTEN OUT ARGS
	MOV	R1,R2		;COPY THE R1 STACK POINTER
	JSR	PC,PSTJS	;AND REMOVE THE STRING TO J-SPACE
	MOV	(SP)+,R4	;GET # OF BYTES IN VALUE
	MOV	LENGTH(R2),R3	;GET LENGTH OF STRING
	ADD	PNTR(R2),R2	;GET ABS PTR TO STRING
1$:	CLRB	-(R1)		;ASSUME NO BYTE AVAILABLE
	DEC	R3		;BYTE AVAILABLE IN STRING?
	BMI	3$		;NO, USE THE NULL
	MOVB	(R2)+,(R1)	;USE STRING BYTE HERE
3$:	SOB	R4,1$		;DO AS MANY TIMES AS NEEDED
	RTS	PC		;THEN EXIT

; MAKE FLOATER INTO A STRING

CVFS:	JSR	R5,INTFAF	;GET A FLOATER
	MOV	#FLTLE2,R3	;SET STRING LENGTH IN BYTES
	BR	CVIS1		;AND CONTINUE

; MAKE INTEGER INTO A STRING

CVIS:	JSR	R5,INTFAI	;GET AN INTEGER
	MOV	#2,R3		;2 BYTE STRING
CVIS1:	MOV	R3,R2		;SAVE STRING LENGTH
	JSR	PC,BUILDS	;AND GET US A STRING
	ADD	R2,R1		;STACK POINTER WHEN FINISHED
	MOV	R1,R4		;COPY STACK AT COMPLETION
CVIS2:	MOVB	-(R4),(R3)+	;COPY ONE BYTE
	SOB	R2,CVIS2	;AND LOOP
	JMP	CVS3		;THEN EXIT NICELY

; FIELD STATEMENT

FIELD:	GWTXT	R0		;GET THE STRING HEADER
	MOV	SPDA,R2		;PICK UP BASE
	ADD	R2,R0		;MAKE POINTER ABSOLUTE
FPOP:	MOV	R2,R3		;COPY SPDA
	ADD	CURRIO(R2),R3	;GET SPECIFIED SLOT
	CMP	(R0)+,(R3)+	;GET PAST BOTH LINKS
	MOV	R3,R4		;SAVE PTR PTR
	ADD	(R3)+,R4	;MAKE BUF PTR ABSOLUTE (+2)
	ADD	(R1)+,(R1)	;UPDATE FIELD COUNT BY CUR LEN
	CMP	(R1),(R3)	;OFF END OF BUFFER?
	BLOS	20$		;NOT YET ANYWAY
	ERROR	FIELDE,FATAL	;BUFFER TOO SMALL FOR FIELD STATEMENT

20$:	ADD	(R1),R4		;FIRST TO END
	SUB	-(R1),R4	;START OF PIECE OF STRING+2
	SUB	R0,R4		;RELATIVIZE POINTER
	MOV	R4,(R0)+	;SAVE NEW POINTER INTO BUFFER
	MOV	(R1)+,(R0)	;AND NEW LENGTH
	BPL	30$		;LENGTH O.K.
	CLR	(R0)		;ELSE SAY LENGTH=0
30$:	RTS	PC		;END OF THIS PIECE

M1FSET:	CLR	-(R1)		;DUMMY SECOND INDEX TO 0
M2FSET:	JSR	PC,INDX90	;AND DO THE INDEXING
	TSTB	(R0)		;DISK OR CORE?
	BPL	.+4		;IT IS CORE
	ERROR	DISERR,FATAL	;IF DISK, THEN AN ERROR
	MOV	SPDA,R2		;GET BIAS
	MOV	R3,R0		;INDX90 RETURNS STR HDR IN R3
	BR	FPOP		;AND CONTINUE

; TRANSLATE FUNCTION (XLATE(S$,T$))

XLATE:	JSR	R5,INTFUN	;GET 2 STRING FOR US
	ARGS	FAS,FAS
	MOV	STRLEN+LENGTH(R1),R3;GET LEN(S$) FOR NEW STRING
	JSR	PC,BUILDS	;AND BUILD A NEW STRING THAT SIZE
	ADD	#STRLEN,(R0)	;DE-LINK TARGET STRING
	MOV	R1,R5		;COPY CURRENT R1 POINTER
	TST	(R1)+		;SKIP T$ LINK WORD
	ADD	(R1)+,R5	;R5 -> T$
	MOV	(R1)+,R4	;R4 = LEN(T$)
	MOV	R1,R2		;COPY R1 POINTER NOW
	TST	(R1)+		;SKIP S$ LINK WORD
	ADD	(R1)+,R2	;R2 -> S$
XLATE1:	DEC	(R1)		;DECREMENT LEN(S$)
	BMI	XLATE2		;NO MORE IN S$
	CLR	R0		;SET UP FOR LOADING VALUE
	BISB	(R2)+,R0	;AND GET BYTE VALUE
	CMP	R0,R4		;SEE IF IT IS WITHIN RANGE
	BGE	XLATE1		;IGNORE BYTES OUT OF RANGE
	ADD	R5,R0		;MAKE A POINTER TO NEW BYTE VALUE
	MOVB	(R0),(R3)	;AND GET THAT NEW BYTE
	BEQ	XLATE1		;IGNORE NEW 0 BYTES
	INC	R3		;BUT, COUNT OTHERS AS REAL
	BR	XLATE1		;AND CONTINUE

XLATE2:	JMPX	MID10		;EXIT SETTING UP THINGS

	.if eq 0	;Originally .if df HELLO	WJS 90.1.31
; COMPILE LSET AND RSET VERBS

$SAINT	LSET			;INITIALLY ENTER SYNTAX ANALYZER...
	P0			;CLEAR LEFT SIDE COUNT
	PBS	6		;PUSH 6 ON R1 STACK - TLCOMR
	B	DORST1		;NOW GO TO MAINLINE CODE

$SAINT	RSET			;INITIALLY ENTER SYNTAX ANALYZER...
	P0			;CLEAR LEFT SIDE COUNT
	PBS	7		;PUSH 7 ON R1 STACK - TLCOMR
DORST1:	R			;READ OVER VERB OR COMMA
	CF			;COMPILE LEFT SIDE, CLOSED CODE BLOCK
	TJ	EQUALS,DORST2	;BR IF NEXT IS =
	T	COMMA		;ELSE DEMAND A COMMA
	CB	PPDUPS		;DUPLICATE THE STRING
	B	DORST1		;AND LOOP

DORST2:	RCS			;READ/COMPILE A STRING
	CCB			;CLOSE CODE BLOCK
	TC			;ADJUST LEFT SIDE WITH DUMMY TLCOMR
	QUIT			;AND QUIT

; COMPILE FIELD STATEMENT

$SAINT	FIEL			;INITIALLY ENTER SYNTAX ANALYZER...
	CALLS	SELEC5		;GET CHANNEL
	CB	PPSSON		;AND SELECT IT
	CB	PPFIX0		;COUNT OF CHARACTER ASSIGN SO FAR
	NEJ	DOFI01		;DONE ALREADY?
DOFI03:	CB	PPIJS		;TERMINATE POP - GET RID OF COUNT
	QUIT			;AND QUIT

DOFI01:	CI			;COMPILE AN INTEGER
	T	AS		;DEMAND AN "AS"
	RVS			;AIM AT VARIABLE
	PBS	8.		;CODE TO END UP WITH A PPFIEL
	CFA			;COMPILE FIELD ADDRESS
	EJ	DOFI03		;IF END, THE EXIT
	T	COMMA		;ELSE DEMAND A COMMA
	R			;SKIP THE COMMA
	B	DOFI01		;AND CONTINUE

SELEC5:	SEXIT	SELECT		;GO EXTERNAL TO SELECT

; GET AND PUT

.ENABL	LSB

$SAINT	GET			;INITIALLY ENTER SYNTAX ANALYZER...
	CALLS	10$		;COMPILE IT
	CB	PPGET		;DO GET
	CB	PPGET		; WITH BLOCK AND OFFSET
	QUIT

$SAINT	PUT			;INITIALLY ENTER SYNTAX ANALYZER...
	CALLS	10$		;COMPILE IT
	CB	PPPUT		;DO PUT
	CB	PPPUT		; WITH BLOCK AND OFFSET
	QUIT

10$:	CALLS	SELEC5		;GET #N
	NTJ	RECORD,20$	;IF NOT ,RECORD THEN BR
	CALLS	110$		;GET INTEGER AND COMMAS
	B	40$		;GO DUMMY IN THE HIGH ORDER
20$:	NTJ	BLOCK,30$	;IF NOT ,BLOCK THEN BR
	R			;ELSE READ OVER ,BLOCK
	CN			;COMPILE A NUMBER
	COPR	100$		;DECODE USING THIS TABLE
	CALLS	120$		;SKIP ANY COMMAS
	B	50$
30$:	CB	PPFIX0		;NO RECORD/BLOCK, USE 0
40$:	CB	PPFIX0		;DUMMY A HIGH ORDER OF ZERO
50$:	NTJ	COUNT,60$	;IF NOT ,COUNT THEN BR
	CALLS	110$		;GET INTEGER AND COMMAS
	B	70$
60$:	CB	PPFIX0		;NO COUNT, USE 0
70$:	NTJ	USING,80$	;IF NOT ,USING THEN BR
	RCI			;GET INTEGER
	B	90$
80$:	CB	PPFIX0		;NO USING, USE 0
90$:	QUITS

100$:	.BYTE	PPCFDI,PPFIX0	;FLT=>CVT TO 2-INT, INT=>MSB=0

110$:	RCI			;READ AND COMPILE AN INTEGER
120$:	SEXIT	SKPCOM		;GO SKIP OVER COMMA(S)
	.EVEN

.DSABL	LSB

	.endc	;eq 0					WJS 90.1.31
	.END
