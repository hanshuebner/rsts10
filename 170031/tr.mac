TITLE	TR,<BASIC+ TRANSLATOR>,08,13-MAY-86,TPH/MHB/JDM/TVG/TS

;                   Copyright 1974,1990 by Digital Equipment Corporation
;                                  All rights reserved.
;
;          This software is furnished under a license and may be used and copied
;          only  in  accordance  with  the  terms  of  such license and with the
;          inclusion of the above copyright notice.  This software or any copies
;          shall not be provided to any other person.   No title to or ownership
;          of the software is hereby transferred.
;
;          The information in this software is subject to change without notice.
;
;          DIGITAL  assumes  no  responsibility  for the  use, functionality, or
;          reliability of its  software  on equipment  which  is not supplied by
;          DIGITAL.

; ESTABLISH TRANSLATOR TABLE

	DEFORG	XT
	ZSKIP	TLDIPL-DOTABV+2/2,TLER18	;ESTABLISHED AS TLER18'S

; TRANSLATOR DIRECTIVES (VERBS)

	ORG	XT,TKRAND-DOTABV

	.WORD	$$RAND	;RANDOMIZE

	ORG	XT,TKCHNG-DOTABV
	.WORD	$$CHAN	;CHANGE
	.WORD	$$INPT	;INPUT
	.WORD	$$PRIN	;PRINT
	.WORD	DODIM	;DIM(ENSION)
	.WORD	DODEF	;DEF(INE)
	.WORD	$$GOTO	;GOTO
	.WORD	DOIF	;IF
	.WORD	DOFOR	;FOR
	.WORD	$$ON	;ON
	.WORD	$$RETU	;RETURN
	.WORD	DOLET	;LET
	.WORD	DODATA	;DATA
	.WORD	$$REST	;RESTORE
	.WORD	$$RESU	;RESUME
	.WORD	$$STOP	;STOP
	.WORD	DOEND	;END
	.WORD	$$ONER	;ON ERROR GOTO
	.WORD	$$OPEN	;OPEN
	.WORD	$$CLOS	;CLOSE
	.WORD	$$CHAI	;CHAIN
	.WORD	DOREM	;REM(ARK)
	.WORD	DONEXT	;NEXT
	.WORD	$$NAME	;NAME
	.WORD	$$READ	;READ
	.WORD	$$GOSB	;GOSUB
	.WORD	DOFNEN	;FNEND
	.WORD	$$INPL	;INPUT LINE
	.WORD	DOWHIL	;WHILE
	.WORD	DOUNTL	;UNTIL
	.WORD	$$KILL	;KILL

	ORG	XT,TKSLEP-DOTABV
	.WORD	$$SLEP	;SLEEP
	.WORD	$$WAIT	;WAIT
	.WORD	DOUNLS	;UNLESS
	.WORD	DOXTND	;EXTEND
	.WORD	DONXTN	;NO EXTEND

	ORG	PU,0
PU:	ERROR	ERRERR,FATAL;NO PRINT USING UNLESS THIS IS OVERLAID

	DEFORG	TR

	.GLOBL	NEWOLD,SAINT,TLENDP,GUSINT
	.GLOBL	TL,TLIDXH,SELECT,RCICOM,SKPCOM
	.GLOBL	TLER18,TYTB,TLGTOK,TLPAIR
	.GLOBL	TLPDST,TLBEGH,TLCMWD,TLENER
	.GLOBL	TLGDFN,TLGFNA,TLGENP,TLGLN1,TLGPDS,TLGNEP

	.GLOBL	TLPTIN,THENT
	.GLOBL	LEXAN,MAPTOK,TOKDEC,FRESPC
	.GLOBL	EDENDC,EDRSTH,EDTYPE,EDSTOR
	.GLOBL	GETAGN,GETAGD,GETAG,LSTOP1,DLTONN
	.GLOBL	ECONOM,R1SCHK
	.GLOBL	INDARY,RUNIM,ASKNAM,FLTLEN,FLTLE2
	.GLOBL	SAVREG,RESREG

;FUNCTION BLOCK ELEMENT LOCATIONS
;FNBTAG	=	0	 USED IN DODEF ROUTINES
FNBPIC	=	2	;FUNCTION BLOCK PICTURE WORD, BITS FOR ARG TYPE
FNBVAL	=	4	;FUNCTION BLOCK VALUE, VALUE OF FUNCTION STORED HERE

;SUBROUTINE CALLED BY MACRO IFTOKA

TATEST:	IF  TOKA(R0),NE,(R5)+,TATES1	;BR IF TOKEN NOT EQUAL ARG
	CMPB	TOKE(R0),#BASTOK	;Z SET IF BASIC VERB, ETC MATCHING ARGUMENT
TATES1:	RTS	R5

.ENABL	LSB

ARYSET:	JSR	R5,SAVREG	;SAVE THE REGISTERS
	MOV	10(R1),R5	;GET THE HEADER ADDRESS
	ADD	R0,R5		;MAKE THE ADDRESS ABSOLUTE
	MOV	#256.,R3	;GET MAX POSSIBLE
	MOV	(R1)+,R2	;GET MAX LENGTH # WORDS
	BEQ	ARST06		;BRANCH IF NOT SPECIFIED
ARST01:	CMP	R2,R3		;HAVE WE FOUND IT YET?
	BGT	ARST02		;IF SO, R3 HAS WORD COUNT
	ASR	R3		;IF NOT, DIVIDE R3 BY 2.
	BNE	ARST01		;AND TRY AGAIN IF NON-ZERO
	MOV	#1-8.+256.,R3	;SET UP AS 2 BYTES IF 1 SPECIFIED
ARST06:	ADD	#8.-256.,R3	;DEFAULT TO 16 IN LENGTH
ARST02:	MOV	R5,R0		;ABS HEADER POINTER
	ADD	#DIM1,R0	;POINT AT DIM1
	ADD	#PDIM2,R5	;POINT AT PDIM2
	MOV	(R1)+,(R5)	;SET PDIM2
	MOV	(R1),(R0)+	;SET DIM1
	MOV	(R5),(R0)+	;SET DIM2
	MOV	(R1)+,-(R5)	;SET PDIM1
	MOV	(R1)+,R2	;GET FLAGS
	CMP	(R1)+,(R0)+	;RID OF HEADER - 1 BEYOND ARYFLG
	BISB	R2,-(R0)	;SET ARYFLG BITS
	BICB	#DSKARY,(R0)	;BUT TURN OFF DISK BIT
	MOV	(R1)+,R4	;SLOT NUMBER
	ASL	R4		;DOUBLED
	MOVB	R4,-(R0)	;INTO ARYSLT
	BEQ	ARST12		;BR IF CORE BASED
	BISB	#DSKARY,1(R0)	;OTHWS, TURN ON DISK FLAG
ARST12:	DEC	R2		;SHUFFLE THE TYPE CODE
	BLE	10$		;BRANCH IF FIXED OR FLOATING
	TSTB	(R0)		;STRING, IS IT DISK BASED?
	BNE	20$		;YES, USE LENGTH IN R3
10$:	MOVB	99$+1(R2),R3	;GET TRUE LENGTH
20$:	MOV	R3,R4		;COPY LENGTH PER ITEM
	MOV	R3,-(R5)	;SET MAXSTR TO ITEM WORD LENGTH
	DEC	R4		;DEC PSEUDO-LENGTH
	MOV	(R1)+,-(R5)	;LOW-ORDER OFFSET
	ADD	R4,(R5)		;ROUND UP TO NEXT USABLE OFFSET
	BIC	R4,(R5)		;ISN'T THIS CUTE?
	MOV	(R1),-(R5)	;HIGH-ORDER OFFSET
	ADC	(R5)		;CARRY FROM LOW-ORDER ROUND
	BCS	ARST08		;BR IF TOO MUCH DISK NEEDED

	CMP	-(R1),-(R1)	;SAVE SLOT & OFFSET WORDS
	MOV	-(R0),R3	;DIM2
	INC	R3		;GO ONE BEYOND LAST ENTRY
	MOV	-(R0),-(R1)	;DIM1
	MOV	R3,-(R1)	;WE'RE SET TO JUMP INTO INDX90
	SUB	#DIM1,R0	;AFTER GETTING BACK TO 1ST HEADER WORD
	JSR	PC,INDARY	;CALCULATE LIMIT IN R2,R3
	MOV	R2,-(R5)	;HIGH-ORDER LIMIT
	MOV	R3,-(R5)	;LOW-ORDER LIMIT
	TSTB	-(R5)		;DISK OR CORE?
	BPL	ARST07		;BR IF CORE
	MOV	R3,2(R1)	;OTHWS, UPDATE OFFSET - LOW-ORDER
	MOV	R2,4(R1)	;HIGH-ORDER
ARST05:	MOV	R1,2(SP)	;RETURN OUR R1 TO SAINT
	JSR	R5,RESREG	;RESTORE THE REGISTERS
	RTS	PC		;AND RETURN

ARST07:	TST	R2		;CHECK CORE SIZE REASONABLE
	BNE	ARST08		;BR IF TOO MUCH CORE
	TST	R3		;SEE IF
	BPL	ARST05		;NOT OBVIOUSLY TOO LARGE
ARST08:	ERROR	SIZERR,FATAL	;WOULD NEED TOO MUCH DISK

99$:	.BYTE	FLTLEN,1,3	;LENGTHS FOR FLOAT, FIXED, STRING
	.EVEN

.DSABL	LSB

; BEGINNING OF TRANSLATOR, NEW STARTUP

TL:	CLR	-(R1)		;ZERO ARGUMENT
	JSR	PC,GETAGD	;GET RID OF ANY IMMEDIATE STATEMENTS
TLNEWL:	CLR	CONCNT		;PRE-CLEAR CONTINUATION LINE COUNTER
	MOV	MDD(R0),TLMIND(R0)	;SAVE STRING HEADER POINTER FOR POSSIBLE RESTORATION
	CLR	TLLINO(R0)	;CLEAR LINE NO. LOC.
	JSR	PC,TLBEGH	;SET SCTH TO IMMEDIATE STATEMENT, SO 
				;EOF WON'T WIPE OUT LAST STATEMENT
	MOV	(PC)+,-(SP)	;TO SET UP FINAL BYTE
	.BYTE	PPHALT,PPNXTS
	MOV	BASCUR(R0),BASBEG(R0)	;SAVE CURRENT TEXT FILE POINTER
	MOVB	BASCUM(R0),BASBEM(R0)	;(AND MSB ALSO)
	JSR	PC,TLGTO1	;GET FIRST TOKEN
	IF	TOKE(R0),NE,#200,TLSAM3,B	;TEST FOR LINE NUMBER

TLSAM1:	SWAB	(SP)		;LAST BYTE SHOULD BE NXTS
	MOV	TOKA(R0),-(R1)	;DELETE OLD ONE IF ANY
	MOV	(R1),TLLINO(R0)	;SAVE LINE NO.
	JSR	R5,LSTOP1	;REMOVE AND SIGNAL NO CONTINUING
	DLTONN
	JSR	PC,LEXAN	;AVOID REMARK SUPPRESSION
TLSAM3:	JSR	PC,TLBEGH	;SET UP A HEADER
	MOVB	(SP)+,TLENBY(R0);POST FINAL BYTE
	IFTOKA	NE,ENDOL,TLSAM2	;CONTINUE IF NOT END-OF-LINE
	TST	CONCNT		;END-OF-LINE, WERE THERE CONTINUATION LINE(S)?
	BEQ	TLNEWL		;NO, <LINE #><CR><LF> CASE
	BR	TLB03		;YES, KEEP THE NULL LINE

TLSAM2:	JSR	PC,TLPTIN	;INIT. STACK POINTERS
	CLRB	TLINFL(R0)	;FLAG INDICATES CALL FROM TOP LEVEL
TLSCAL:	JSR	PC,TLSCOM	;CALL ROUTINE TO COMPILE STATEMENT
;NOTICE ERROR POSTINGS DURING COMPILATION AND REPORT ERROR
	MOV	JOBF,R2		;GET CONTENTS OF POSTING FLAG
	BPL	TLB03		;NOTHING TO DO
	BIC	#JFSTOP!JFRTS,JOBF	;CLEAR POST-RELATED BITS
	BIC	#-JFRTS-1,R2	;CLEAR ALL BUT BITS TO INDEX ON
	ADD	R2,PC		;DISPATCH
	BR	TLB03		;"IMPOSSIBLE" CASE--IGNORE IT
	ERROR	FLTERR,FATAL	;SEND FLT-ERR MESSAGE
	ERROR	FIXERR,FATAL	;SEND INTEGER ERROR MESSAGE
	ERROR	DIVBY0,FATAL	;SEND DIV-BY 0 ERR MESSAGE
TLB03:	IF	TOKA(R0),NE,#ENDOL,TLA1	;BRANCH AROUND CR/LF CASE
	JSR	PC,TLENDH	;FINISH HEADER
	BIT	#EDEOFF,EDFLAG	;SEE IF LINE INCLUDED AN END STATEMENT
	BEQ	TLB01		;NO
	JMP	EDENDC		;JUST FINISHED GENERATING CORE IMAGE

TLB01:	TST	TLLINO(R0)
	BNE	TLNEWL		;NOT IMMEDIATE GET NEW LINE
	MOV	SCTH,R5		;BLOCK EXECUTING
	TSTB	TAGTYP(R5)	;OF FOR, NEXT, DIM ETC.
	BNE	TLB02
	BIT	#EDCOMP,EDFLAG	;INPUT FROM A .BAS FILE?
	BEQ	TLBXX		;NO, GO DO IT
..IBAS	==	.-2	;**PATCH** 'BR' FOR .BAS IMMEDIATE MODE
TLB02:	ERROR	NONOIM,FATAL	;NOT LEGAL IMMEDIATE STATEMENT

TLBXX:	JMP	RUNIM		;RUN IT

TLA1:	IFTOKA	EQ,COLON,TLSAM4	;MULTIPLE STATEMENT CASE
	ERROR	EOSERR,FATAL	;ILLEGAL FORMAT-STATEMENT SHOULD HAVE
				;BEEN OVER BUT WASN'T
TLSAM4:	TST	TLLINO(R0)	;IMMEDIATE MODE?
	BEQ	TLB02		;YEP, SO ERROR
	JSR	PC,LEXAN	;NEXT ONE PLEASE
	BR	TLSAM2

;SUBROUTINE TO COMPILE A STATEMENT
;CALLED FROM BOTH TOP LEVEL (PREV. PAGE.)  AND INSIDE DOIF
TLSCOM:	CLR	TLSTPC(R0)	;ZERO "STATEMENT PROG. COUNTER"
	CLR	TLTOPC(R0)	;ZERO "PROGRAM COUNTER"
	CLR	PTOKF(R0)	;CLEAR PTOKF AND TLCOFL (PREV TOKN & CONDIT EXPR)
	CLRB	TLLSFL(R0)	;CLEAR LEFT-SIDE FLAG
	MOV	TOKA(R0),R2	;MAKE TOKA MORE ACCESSABLE
	BIT	#JFNOPR,JOBF	;SEE IF HE'S LOGGED IN
	BEQ	1$		;YES, HE IS
;	IFTOKA	EQ,HELLO,1$	;NO, ONLY 'HELLO' ALLOWED THEN	; WJS 90.1.31
	ERROR	PRVIOL,FATAL	;ELSE IS ERROR

1$:	BITB	#BASF,TOKE(R0)	;CHECK FOR A VERB
	BNE	2$		;IF VERB, THEN CONTINUE
	INCB	PTOKF(R0)	;IF NOT VERB, ASSUME 'LET'
	MOV	#TKLET,R2	;SET THE 'LET' TOKEN
2$:	SUB	#DOTABV,R2	;CHECK FOR OPERATOR (<DOTABV)
	BHIS	4$		;IF >=DOTABV THEN REALLY A VERB
3$:	ERROR	TLOPNV,FATAL	;ELSE SAY NOT A LEGAL PROGRAM VERB

4$:	CMP	R2,#TLDIPL-DOTABV;CHECK FOR WITHIN TOP RANGE
	BLOS	5$		;BRANCH IF O.K.
	JMP	TLER18		;ELSE SAY 'WHAT?' OR 'ILLEGAL VERB'

5$:	CMP	R2,#TLDIPB-TLDIPT;CHECK FOR EDITOR COMMAND
	BGE	6$		;IF PROGRAM VERB THEN PROCEED
	TST	TLLINO(R0)	;IF EDITOR COMMAND THEN CHECK MODE
	BNE	3$		;IF LINE NUMBERED THEN ERROR
	BIT	#EDCOMP,EDFLAG	;ALSO CHECK FOR NON-KEYBOARD COMMAND
	BNE	3$		;ONLY EDITOR COMMANDS FROM KEYBOARD ALLOWED
	CMP	(SP)+,#TLSCAL+4	;FINAL CHECK IS FOR INTERNAL RECALL
	BNE	3$		;IF NOT MAIN CALL THEN ERROR
6$:	MOV	R5,-(SP)	;SAVE R5 (LIKE 'JSR R5,' WOULD...)
	MOV	XT+TLDIPT(R2),R5 ;GET DISPTACH TO THE 'DO' ROUTINE
	BIT	R5,#1		;IS IT ODD?
	BNE	7$		;YES, SO ENTER THROUGH "SAINT"
	RTS	R5		;NO, DO A NORMAL 'JMP' TYPE DISPATCH

7$:	JMP	SAINT		;OFF TO SAINT W/ R5-> CODE...

;CONSTRUCTION OF STATEMENT HEADERS IS ACCOMPLISHED AS FOLLOWS:
;WHEN A LINE NUMBER IS TYPED A HEADER IS PROCURED AND POSTED IN TLCURH.
;IF NO LINE NUMBER IS SPECIFIED, THE LINE IS COMPILED AS LINE 0, THE
;IMMEDIATE LINE. EACH SPECIAL DO ROUTINE FOR THOSE STATEMENT TYPES WHICH
;REQUIRE THEIR OWN HEADER (SUCH AS FOR) TERMINATES THE EXISTING HEADER
;AND STARTS A NEW ONE (EXCEPT WHEN EXISTING ONE IS EMPTY), USING TLIDXH,
;AND TAKES CARE OF POSTING APPROPRIATE CODES IN TAGTYP. THE PUSH-POP IS ARRANGED
;TO END ON EVEN BOUNDARY AND THIS IS INDICATED IN THE HEADER AS WELL AS IN PROPTR.
;TLIDXH IS A ROUTINE TO END CURRENT, AND SET UP NEW HEADER
;IT RETURNS AN ABS POINTER TO TAGTYP OF HEADER IN R4

TLIXNC:	;BIC	#EDCONT,EDFLAG	;NEW FOR,NEXT,DEF,ENDDEF
TLIDXH:	MOV	SCTH,R4		;CURRENT TAG
	TST	TAGPUL(R4)	;SEE IF USED
	BEQ	TLIDXR		;NO
	JSR	PC,TLENDH	;CLOSE IT
TLBEGH:	MOV	TLLINO(R0),-(R1);GET FIRST AVAILABLE HEADER THIS LINE
	JSR	PC,GETAGN	;IE UNUSED
	MOV	(R1),R4		;IT WILL MAKE ONE IF NECESSARY
	MOV	(R1),SCTH	;POST IT AS CURRENT HEADER
	MOV	SPTA,R3		;GET PUSHPOP BASE
	SUB	R3,(R1)		;MAKE RELATIVE HEADER POINTER
	NEG	(R1)		;TO MAKE A HEADER-REL POINTER
	ADD	PROPTR(R3),(R1)	;TO THE PUSH-POP
	TST	(R4)+		;SKIP LINK
	MOV	(R1)+,(R4)+	;POST CURRENT CODE LOCATION IN TAGPUS
	CLR	(R4)		;CLEAR TAGPUL
	CMP	-(R4),-(R4)	;BACK UP TO THE TOP NOW
TLIDXR:	ADD	#TAGTYP,R4	;POINTER TO TYP AS PROMISED
	RTS	PC

TLENDH:	MOVB	TLENBY(R0),-(R1)
	JSR	PC,SCBPPA	;PUT OUT NEXTS, OR HALT ETC.
TLENER:	BIT	#TRNKER,EDFLAG	;REENTRY DURING ERROR PROCESSING?
	BNE	TLEVEN		;DON'T MESS UP TEXT POINTERS THEN
	MOV	SCTH,R4		;STATEMENT HEADER
	ADD	#TAGTXL,R4	;PNTR TO TXT LENGTH FLAG BYTE
	CLRB	(R4)		;MARK AS NO TEXT INITIALLY
	BIT	#EDETMP,EDFLAG	;DOES A .TMP EXIST?
	BEQ	TLEVEN		;NO, SO NO TEXT THEN
	MOV	#200,R2		;SET END-OF-STATEMENT CHARACTER
	JSR	PC,EDSTOR	;AND STORE IT AS A FLAG
	MOVB	BASBEM(R0),(R4)	;NOW STORE TEXT MSB AND
	COMB	(R4)		; COMPLEMENT IT FOR GOODNESS
	MOV	BASBEG(R0),-(R4);SIMILARILY FOR TEXT LSB
	MOVB	BASCUM(R0),BASBEM(R0);UPDATE BASBEG BOTH
	MOV	BASCUR(R0),BASBEG(R0); MSB AND LSB
TLEVEN:	MOV	SPTA,R5		;BASE FOR PROPTR
	MOV	PROPTR(R5),R2	;CURRENT PUSHPOP POINTER
	ASR	R2		;MASK FOR LOW BIT
	ADC	PROPTR(R5)	;AND IF THERE BUMP FREE POINTER
	RTS	PC

;ROUTINE TO COMPILE CODE FOR A FORMULA

TLCOMF:	BIS	#CONVFF,STAT(R0);FORCE CONVERSION OF NUMBERS TO FLOATING INITIALLY
TLCMF1:	BIC	#OUTEXF,STAT(R0);TELL LEX ANAL WE'RE IN TLCOMF 
	CLR	TLPCOU(R0)	;CLEAR PAREN COUNTER
	CLR	TLFNAF(R0)	;CLEAR FN. NAME AND OPERATOR FLAGS
	CLRB	TLOPRF(R0)	;OPERAND JUST PREVIOUS TOKEN
	CLR	PMODE(R0)	;TOP LEVEL INDICATOR
	MOV	OPSI,OPSP	;INIT. OPERATOR STACK PTR.
	MOV	OPSI,TLOPRP(R0)	;PICK UP ABSOLUTE OPERATOR STACK POINTER
	SUB	R0,TLOPRP(R0)	;COMPUTE REL. OPERATOR STACK POINTER FROM IT
	MOV	OASP,TLOARP(R0)		;PICK UP ABS. OPERAND STACK PTR.
	SUB	R0,TLOARP(R0)		;RELATIVEIZE IT
TLCOE:	IFZ	PTOKF(R0),TLCOE1,B	;IF PTOKF<>0 THEN PTOKE=0
	CLRB	PTOKE(R0)		;ZERO IT
	BR	TLCOE2

TLCOE1:	CLRB	TOKE(R0)	;OTHERWISE TOKE=0
TLCOE2:	CLR	CPREC(R0)	;CLEAR CURR.PREC. LOC
	CLR	PRPREC(R0)	;CLEAR PREV.PREC.LOC.
TLCOA:	JSR	PC,TLGTOK	;GET NEXT TOKEN
	IFZ	TLFNAF(R0),TLCON,B	;JMP IF TLFNAF FLAG NOT SET
	IF	TOKA(R0),EQ,#LPAR,TLCON	;THERE ALSO IF TOKEN=(
	CLR	TLFNAT(R0)	;CLEAR PICTURE WORD LOCATION (CORR. TO FN. WITH 0 ARGS)
	MOV	PMODE(R0),-(R1)	;SAVE OLD PMODE VALUE
	JSR	PC,TLFIPM	;GO OFF TO CALCULATE PMODE VALUE
	MOV	TLTYCT(R0),-(R1);PUT TYPE OF CURR. TOKEN ON R1 STACK
	JSR	PC,TLRPF1	;FCN. W/O FOLLOWING (
	CLRB	TLFNAF(R0)	;CLEAR FN. NAME FLAG
	MOV	(R1)+,PMODE(R0)	;RESTORE OLD PMODE
TLCON:	JSR	PC,TLOPP	;TEST TOKEN FOR OPERATOR
	BR	TLCON2		;IT ISN'T
	IFNZ	TLOPTF(R0),TLCON3,B	;SEE IF PREVIOUS TOKEN WAS OPERATOR
	INCB	TLOPTF(R0)	;IT WASN'T, BUT THIS ONE IS
	CMPB	#11,TOKA(R0)	;A "NOT"?
	BNE	TLCON1		;NOPE, NORMAL CASE
	TSTB	TLOPRF(R0)	;YEP, REALLY O.K.??
	BEQ	TLCON1		;O.K.
	ERROR	TLNZSP,FATAL	;ERROR, CASE OF "A% NOT A%"

TLCON3:	IF	TOKA(R0),EQ,#4,TLCON1	;IS CURRENT OP. A UNARY -?
	IF	TOKA(R0),EQ,#11,TLCON1	;A "NOT" IS ALSO OK
TLER10:	ERROR	TLNZSP,FATAL	;TWO OPERATORS IN SUCCESSION IS A NONO

TLCON2:	CLRB	TLOPTF(R0)	;CLEAR OPERATOR FLAG, TOKEN NOT OPERATOR
TLCON1:	JSR	PC,TLOAP	;SKIP IF TOKEN IS AN OPERAND
	BR	TLNOPR		;NO
	TSTB	TLOPRF(R0)	;WAS PREV TOK AN OPERAND
	BNE	TLCOB		;YEP, SO QUIT
	COMB	TLOPRF(R0)	;INDICATE OPERAND
	JMP	TLCOL		;YES

TLCOH1:	MOV	TOKA(R0),R2	;PICK UP CURR. TOKEN VALUE IN R2
	MOVB	TLPRET(R2),R2	;LOOK UP IT'S PRECEDENCE
	MOV	R2,CPREC(R0)	;AND STORE IT IN CPREC
TLCOI:	IF	PRPREC(R0),NE,#11.,TLCOI1	;IF PREV NOT ^
	IF	CPREC(R0),EQ,#10.,TLCOD	;BR IF CURR OP = UNARY -
TLCOI1:	IF	CPREC(R0),GT,PRPREC(R0),TLCOD	;CURR.PREC > PREV. PREC.,SO DEFER ACTION
	JSR	PC,TLGENC	;CURR.PREC.<=PREV.PREC., SO MAKE CODE
	MOV	OPSP,R2
	SUB	R0,R2
	IF	R2,EQ,TLOPRP(R0),TLCOD	;JMP IF OPERATORS USED UP
	MOVB	@OPSP,R2		;LOOK UP PRECEDENCE OF TOP ELEMENT
	MOVB	TLPRET(R2),R2		;AND MOVE IT INTO R2
	MOV	R2,PRPREC(R0)		;STORE IT IN PPREC
	BR	TLCOI

TLCOBI:	CLRB	TLOPRF(R0)		;NOT AN OPERAND
	JSR	PC,TLOPP		;SEE IF OPERATOR
	BR	TLCOBE			;NOT OPERATOR--SEE IF (, ETC.
	IFNZ	PMODE(R0),TLCOH1	;HERE IF OPERATOR
	IFZ	TLLSFL(R0),TLCOH1,B	;WE'RE DOING A LEFT SIDE IF TLLSFL NOT=0
	ERROR	TLOPNV,FATAL		;NOT A VERB--COMPLAIN

TLCOD:	MOV	CPREC(R0),PRPREC(R0)	;SAVE CURRENT PREC VAL AS PREV
	MOVB	TOKA(R0),-(R1)		;MOVE CURRENT TOKEN VAL TO STACK
	JSR	PC,PUOPST		;PUSH ONTO OPERATOR STACK
	BR	TLCOA			;GO BACK FOR NEXT TOKEN

TLCOBE:	IF	TOKA(R0),EQ,#LPAR,TLCOF	;JMP IF TOKEN = (
	IF	TOKA(R0),EQ,#COMMA,TLCOQ;TO TLCOQ IF TOKEN = ,
TLCOB:	MOV	OASP,R2			;PICK UP OPERAND STACK PTR IN R2
	TST	(R2)+			;INCR. R2 BY 2
	IF	R2,NE,OASI,TLCOZ	;DOES OPERAND STACK HAVE EXACTLY ONE ELEM.?
	IF	OPSP,NE,OPSI,TLCOZ	;YES, NOW GO GENERATE CODE IF OPERATOR
	JSR	PC,POOAST		;STACK NOT EMPTY -ELSE SAVE RESULT TYPE AND EXIT
	MOV	(R1)+,TLCOMR(R0)	;MOVE RESULT TYPE FROM R1 STACK INTO TLCOMR
	BIS	#OUTEXF,STAT(R0)	;TELL LEX ANAL WE'RE OUT OF TLCOMF
	JMP	TLCLCB			;CLOSE OUT BLOCK AND EXIT THROUGH TLCLCB

TLCOQ:	IFZ	PTOKE(R0),TLER10,B	;COMMA AS FIRST CHAR OF EXPR IS BAD
	IF	PMODE(R0),EQ,#1,TLER10	;COMMA INSIDE EXPR IS BAD TOO
	BHI	TLCOJ			;TREAT AS ARG DELIMITER
	BR	TLCOB			;OTHERWISE,TREAT IT AS AN EXPRESSION TERMINATOR

TLCOZ:	JSR	PC,TLGENC		;GO OFF TO GENERATE CODE
	BR	TLCOB

TLNOPR:	IF	TOKA(R0),NE,#RPAR,TLCOBI;TO TLCOBI IF TOKEN <> (<>)
	IFZ	PTOKE(R0),TLCOZ2,B	;")" AS 1ST CHAR OF EXPRESSION!
	IFZ	TLPCOU(R0),TLCOB	;TO TLCOB IF PAREN. COUNT DOWN TO 0
	DEC	TLPCOU(R0)		;ONE LESS IN PARENTHESIS DEPTH
TLCOZ2:	IF	PTOKA(R0),NE,#LPAR,TLCOZ1;BRANCH IF PREV. TOKEN NOT (
	IF	PMODE(R0),GT,#4,TLCOK1	;() CASE IS ERROR EXCEPT IN FN CALL
TLER11:	ERROR	TLNZSP,FATAL		;ILLEGAL EXPRE

TLCOZ1:	IFZ	PTOKE(R0),TLER11,B; ) AS 1ST OF EXPRESSION
	BR	TLCOW

TLGTST:	MOV	OASP,R2		;SUBROUTINE TO SEE IF NEW ITEMS ON OPERAND STACK
	SUB	R0,R2		;RELATIVE OPERAND SP
	CMP	TLOARP(R0),R2	;ANYTHING ADDED SINCE LAST TIME WE SAVED IT
	BLOS	TLER11		;NO-ERROR
	RTS	PC		;OK TO POP STUFF OFF NOW

TLCOF:	CMP	PTOKA(R0),#RPAR	;SEE IF LEFT PAREN FOLLOWS RIGHT
	BEQ	TLER11		;CASE OF )(--ALWAYS AN ERROR
	INC	TLPCOU(R0)	;INCREASE PAREN DEPTH
	MOV	PMODE(R0),-(R1)	;( CASE, PUT PMODE VAL. ON R1 STACK
	MOV	#PUOAST,R3	;GET SET TO MOVE LOTS TO OPERAND STACK
	JSR	PC,(R3)		;FIRST PMODE VAL
	MOV	CPREC(R0),-(R1)	;PUT PREC VAL ON R1 STACK
	JSR	PC,(R3)		;AND TO OPERAND STACK
	MOV	TLOPRP(R0),-(R1);PUT REL. OPERATOR STACK PTR. ON R1 STACK
	JSR	PC,(R3)		;PUT IT ON OPERAND STACK
	MOV	TLOARP(R0),-(R1);PUT REL OPERAND STACK PTR ON R1 STACK
	JSR	PC,(R3)		;AND TO OPERAND STACK
	CLR	-(R1)		;PUT 0 ON R1 STACK
	JSR	PC,(R3)		;PUT PICTURE WORD ON OPERAND STACK, INIT. TO 0
	MOV	#1,-(R1)	;PUT 1 ON R1 STACK
	JSR	PC,(R3)		;PUT NO. ARGS. ON OPERAND STACK,INIT. TO 1
	MOV	OPSP,TLOPRP(R0)	;PICK UP OP. STACK PTR. VAL.
	SUB	R0,TLOPRP(R0)	;MAKE IT RELATIVE AND SAVE IN TLOPRP
	MOV	OASP,TLOARP(R0)	;PICK UP OPERAND SATCK PTR VAL
	SUB	R0,TLOARP(R0)	;MAKE IT REL & SAVE IT IN TLOARP
	JSR	PC,TLFIPM	;CALC. PMODE VAL. FOR PREV.TOKEN
				;AND STORES THAT VALUE IN PMODE
	CLRB	TLFNAF(R0)	;CLEAR FUNCTION FLAG
	JMP	TLCOE		;GO BACK TO CLEAR PREC. LOC'S AND GET NEXT TOKEN

TLCOP:	JSR	PC,TLGENC	;MAKE SOME CODE
TLCOJ:	MOV	OPSP,R2		;COMMA CASE
	SUB	R0,R2		;MAKE REL. OPERATOR STACK PTR.
	IF	R2,NE,TLOPRP(R0),TLCOP	;HAVE WE USED UP ALL THE OPERATORS?
	JSR	PC,POOAST	;POP TOP ELEMENT OFF OPERAND STACK
	JSR	PC,TLFIXI	;CALL TLFIXI
	INC	@OASP		;INCR. ARG. COUNT BY 1
	JMP	TLCOE		;GO BACK TO CLEAR PREC. VAL'S, & READ NEXT TOKEN
TLCOWA:	JSR	PC,TLGENC	;MAKE SOME CODE
TLCOW:	MOV	OPSP,R2		;PICK UP OPERATOR STACK PTR. IN R2
	SUB	R0,R2		;MAKE IT RELATIVE TO SPDA
	CMP	R2,TLOPRP(R0)	;SEE IF OPERATORS USED UP
	BNE	TLCOWA		;GO AROUND AGAIN
	JSR	PC,POOAST	;POP TOP ELEM. OFF OPERAND STACK
	MOV	(R1),TLCTTW(R0)	;STORE TYPE OF LAST CALC. INSIDE ()'S
	JSR	PC,TLFIXI	;CALL TLFIXI

TLCOK1:	MOV	#POOAST,R3	;FOR CHEAP ACCESS
	JSR	PC,(R3)		;POP NEXT ELEM. OFF OPERAND STACK
	MOV	(R1)+,NARGS(R0)	;AND STORE IN NARGS (# OF ARGS)
	JSR	PC,(R3)		;POP NEXT ELEM. OFF OPERAND STACK
	MOV	(R1)+,TLFNAT(R0);AND STORE IN TLFNAT (PICTURE WD.)
	JSR	PC,(R3)		;POP NEXT ELEM. OFF OPERAND STACK
	MOV	(R1)+,TLOARP(R0);AND STORE IN TLOARP (OPERAND STACK REL. PTR)
	JSR	PC,(R3)		;POP NEXT ELEM. OFF OPERAND STACK
	MOV	(R1)+,TLOPRP(R0);AND STORE IN TLOPRP (REL. STACK PTR. LIMIT)
	JSR	PC,(R3)		;POP NEXT ELEM. OFF OPERAND STACK
	MOV	(R1)+,PRPREC(R0);AND STORE IN PRPREC (PREV. PREC. VAL.)
	JSR	PC,(R3)		;POP NEXT ELEM. OFF OPERAND STACK
	MOV	(R1)+,PRPMOD(R0);AND STORE IN PRPMOD (TEMP. STORAGE FOR PMODE VAL.)
	MOV	PMODE(R0),R2	;PICK UP PMODE VALUE IN R2
	IF	R2,LE,#4,TLCOY	;TO TLCOY IF NOT A FCN. CALL.
	INC	TLBIFF(R0)	;SET BUILT-IN FCN. FLAG
	SUB	#5,R2		;SUBTR 5 FROM IT
	IF	R2,LE,#2,TLCOV	;TO TLCOV IF A BUILT-IN FCN.
	CLR	TLBIFF(R0)	;CLEAR BUILT-IN FCN FLAG
	SUB	#3,R2		;AND REDUCE VAL. IN R2 BY 3
TLCOV:	MOV	R2,TLTYCT(R0)	;STORE FCN. TYPE IN TLTYCT
TLCOX:	JSR	PC,TLRPFX	;CALL TLRPFX
	MOV	PRPMOD(R0),PMODE(R0) ;MOVE SAVED PMODE VAL. INTO PMODE, FINALLY
	BR	TLCOAA		;BACK FOR NEXT TOKEN

TLCOY:	DEC	R2		;IF PMODE =1 THEN ORDINARY () CASE
	BEQ	TLCOX		;WAS A 1, SO DO IT
	DEC	R2		;DATA TYPE = PMODE-2
	MOV	R2,TLTYCT(R0)	;SAVE DATA TYPE OF INDEXED VARIABLE
	BR	TLCOX		;CALL TLPRFX AND TRY AGAIN

TLCOL:	JSR	PC,TLTYPE	;CALC DATA TYPE OF CURR. TOKEN
	TBITT	FUNCF,TLCOR	;BRANCH IF NOT FUNCTION
	INCB	TLFNAF(R0)	;YES, SET FCN. NAME FLAG
	CLR	TLBIFF(R0)	;CLEAR BUILT-IN FCN. FLAG
	TBITT	BASF,TLCOM	;BUILT IN FUNCTION OR USER DEFINED?
	INC	TLBIFF(R0)	;BUILT IN---SET FLAG
TLCOM:	MOV	TOKA(R0),-(R1)	;MOVE CURR. TOKEN TO R1 STACK
	JSR	PC,PUOAST	;AND PUSH IT ONTO THE OPERAND STACK.
	BR	TLCOAA		;GO BACK TO READ A NEW TOKEN

TLCOR:	CLRB	TLFNAF(R0)	;CLEAR THE FN. NAME FLAG
	BITB	#INDEXF,TOKE(R0);SEE IF INDEXED VARIABLE OR SIMPLE ONE
	BNE	TLCOM		;INDEXED..
	MOV	#PUSH,TLGCOP(R0);PUT "PUSH" INTO THE OPERATOR SLOT
	JSR	PC,SATYPE	;STORE ITS DATA TYPE ON R1 STACK
	MOV	#3,-(R1)	;PUT 3 ON R1 STACK TO NOTIFY TYPR OF UNARY OPERATOR
	JSR	PC,TLADDC	;GENERATE CODE TO PUSH OPERAND ONTO RUN-TIME STACK.
TLCOAA:	JMP	TLCOA		;GO BACK TO READ NEW TOKEN


;CODE GENERATING ROUTINE
TLGENC:	JSR	PC,POOPST	;POP TOP ELEM. OFF OPERATOR STACK
	MOVB	(R1)+,TLGCOP(R0) ;AND PUT IT IN TLGCOP
	CLRB	TLGCOP+1(R0)	;CLEAR HIGH BYTE OF TLGCOP
	JSR	PC,TLGTST	;TEST FOR EXIST OF OPERAND ON STACK
	JSR	PC,POOAST	;POP TOP ELEM. OFF OPERAND STACK
	IF	TLGCOP(R0),NE,#4,TLGEN2		;TO TLGEN2 IF OP. NOT UNARY -
TLGEN4:	MOV	#3,-(R1)	;UNARY OP. CASE, NOTIFY TYPR BY 3 AS 2ND ARG.
	BR	TLADDC		;CALL TLADDC TO GEN. CODE & EXIT

TLGEN2:	IF	TLGCOP(R0),EQ,#11,TLGEN4	;TO TLGEN4 IF OP. NOT "NOT"
	JSR	PC,TLGTST	;TEST FOR EXIST IF OPERAND ON STACK
	JSR	PC,POOAST	;NOT UNARY, SO POP 2ND ITEM OFF OPERAND STACK
TLADDC:	MOV	2(R1),-(R1)	;COPY NEXT-TO-TOP ELEM. OF R1 STACK (OPERAND)
	MOV	2(R1),-(R1)	;COPY TOP ELEM. OF R1 STACK (OPERAND)
	JSR	PC,TYPR		;CALC. THE TYPE OF THE RESULT
	MOV	(R1),R2		;USE THIS TYPE TO CHOOSE
	ADD	R2,R2		;WHICH TABLE TO USE
	MOV	TLOTIX(R2),R3	;BRING BASE. ADDR. OF APPROP. TABLE INTO R2
	ADD	TLGCOP(R0),R3	;INDEX BY OPERATOR TOKEN VALUE

	MOVB	(R3),R3		;GET POP
	BEQ	TLER14		;0 IS ERROR, NO CORRESP. PUSHPOP CODE
	IF	TLGCOP(R0),NE,#PUSH,100$ ;TREAT PUSH AS SPECIAL CASE
	MOV	TOKA(R0),R4	;IT IS "PUSH", GET THE (REL SPDA) ADDR
	CMPB	R3,#PPUSHF	;FLOATING PUSH?
	BNE	50$		;NO
	CMP	R4,#ONECON	;IS THIS THE FLOATING 1 CASE?
	BEQ	20$		;YES
	JSR	R4,70$		;CHECK FOR DATA=FLT AND REAL DATA
	 .BYTE	DFLT,PPUSHF
	MOV	R4,R2		;COPY THE FLOATER'S ADDRESS
	ADD	#FLTLE2,R2	;NOW INDEX TO END+2 OF FLOATER
10$:	TST	-(R2)		;TRAILING 0 WORD?
	BEQ	10$		;YES, LOOP FOR NON-0 WORD
	CMP	R2,R4		;WHAT KIND OF FLOATER?
	BHI	80$		;LOTS OF 1-BITS, KEEP IT
	BEQ	30$		;ONLY 1-BITS IN FIRST WORD
	ADD	#FLTLE2,NEXFRE(R0) ;TURE 0, RECOVER ALL DATA SPACE
	MOVB	#PPUFL0,R3	;USE THIS POP OP-CODE
	BR	130$		; WHICH IS PUSH FLOATING 0

20$:	MOVB	#PPUFL1,R3	;OP-CODE IS "PUSH FLOATING 1"
	BR	130$		;SO GO DO IT

30$:	MOVB	#PPUFLX,R3	;USE THIS OP-CODE
	ADD	#FLTLE2,NEXFRE(R0) ;AND RECOVER ALL DATA SPACE
40$:	MOV	(R4),R4		;GET THE DATA CONSTANT
	BR	90$		;AND GO USE IT

50$:	CMPB	R3,#PPUSHI	;INTEGER PUSH?
	BNE	90$		;NO
	JSR	R4,70$		;CHECK FOR DATA=INT AND REAL DATA
	 .BYTE	DINT,PPUSHC
	ADD	#2,NEXFRE(R0)	;RECOVER INTEGER DATA SPACE
	CMP	(R4),#1		;IS IT 0 AND/OR 1?
	BHI	40$		;NO, DO "PPUSHC" WITH DATA
	MOVB	#PPFIX0,R3	;YES, SET "PPFIX0" (PUSH INTEGER 0)
	BCS	130$		;JUST "PPFIX0" IF 0
	MOVB	#PPFIX1,R3	;ELSE JUST "PPFIX1" (PUSH INTEGER 1)
	BR	130$		; IF DATA=1

70$:	CMPB	TOKE(R0),(R4)+	;IS DATA TYPE (TOKEN) CORRECT?
	BNE	95$		;NO
	CMP	(SP),#LSTPDA	;YES, REAL DATA??
	BHIS	95$		;NOT REAL DATA
	ADD	R0,(SP)		;REAL DATA, GET ABS PTR TO IT
	MOVB	(R4)+,R3	;UPDATE THE POP OP-CODE
	RTS	R4		;AND RETURN

80$:	SUB	R0,R4		;MAKE REL SPDA ADDRESS AGAIN
90$:	MOV	R4,-(SP)	;SAVE (REL SPDA) DATA/VARIABLE ADDR
95$:	MOV	#TLSTSP,-(SP)	;AND SET AS A WORD AS COMPLETION
	BR	130$		;NOW GO SET THE OP-CODE

100$:	IF	4(R1),EQ,(R1),110$ ;IS 1ST OPERAND OF SAME TYPE AS RESULT?
	MOVB	#PPFLT,-(R1)	;NO, FLOAT IT (PUT "FLOAT" CODE ON R1 STACK)
	BR	120$

110$:	MOV	R1,R4		;MAKE DESTUCTABLE R1 POINTER
	CMP	(R4)+,(R4)	;DO THEY AGGREE?
	BEQ	130$		;SAME TYPE---
	CMP	(R4),#3		;SEE IF UNARY OP WITH NO 2ND OPERAND
	BEQ	130$		;YES--NO CONVERSION PORBLEMS THEN
	MOVB	#PPFLT1,-(R1)	;OTHERWISE FLOAT IT (PUT "FLOAT1" CODE ON R1 STACK
120$:	JSR	PC,PUCOST	;PUT "FLOAT" OR "FLOAT1" ON CODE STACK
130$:	MOVB	R3,-(R1)	;PUT PUSHPOP OPCODE FROM TABLE ON R1 STACK, THEN
	JSR	PC,PUCOST	;PUT OPCODE ON CODE STACK
	IF	TLGCOP(R0),LT,#6,140$	;FOR THE LOGICAL OP'S. IN CONDIT.
	IF	TLGCOP(R0),EQ,#23,140$	;MAKE SURE RESULT TYPE IS INTEG.
	MOV	#1,(R1)		;BY PUTTING 1 (I.E. INTEGER) ON R1 STACK AS TYPE
140$:	JSR	PC,PUOAST	;PUT RESIDUE ON OPERAND STACK
	CMP	(R1)+,(R1)+	;R1_R1+4 TO CLEAN UP STACK
	RTS	PC		;NOW EXIT DOING CORRECT THING

TLER14:	ERROR	TLNOIT,FATAL	;NO OPCODE IN TABLE CORR. TO THAT OPERATOR AND TYPE

;ROUTINE TO DO MISCELL.FIXUPS UPON HITTING )
TLRPFX:	IF	PMODE(R0),NE,#1,RPFA ;BR IF PMODE VALUE ISN'T = 1
	MOV	TLCTTW(R0),-(R1)	;ORDINARY PARENTH. EXPR. CASE
	BR	RPF8

RPFA:	MOV	TLTYCT(R0),-(R1)	;PUT TYPE ON R1 STACK
	IF	PMODE(R0),GT,#4,TLRPF1	;TEST WHETHER PMODE VAL. <=4
	MOV	NARGS(R0),R3	;NUMBER OF DIMENSIONS OR ARGS
	IF	R3,GT,#2,TLER12	;INDEXED VAR. CASE
	DEC	R3		;NOW 0 IF 1D, 1 IF 2D
	MOVB	RPIDTB(R3),-(R1);PICK UP RIGHT INDO
	JSR	PC,PUCPOO	;MOVE TO CODE STACK, GET DOPE VEC PTR
	MOV	(R1),-(R1)	;COMPILE A COPY
	JSR	PC,TLSTCW	;OF IT
	MOV	(R1)+,R2	;MAKE POINTERS WITH IT
	ADD	R0,R2		;NOW ABSOLUTE
	MOV	R2,R4		;SAVE A COPY
	ADD	#PDIM2,R4	;POINTER TO PDIM2 WORD
	ADD	#ARYFLG,R2	;POINTER TO FLAG BYTE
	BITB	#REFARY!DIMARY,(R2)	;SEE IF EVER HEARD OF BEFORE
	BNE	RPFG		;YES
	BISB	#REFARY,(R2)	;INDICATE WE HAVE HEARD OF IT NOW
	MOV	R3,(R4)		;SIGNAL # DIMENSIONS
	BISB	(R1),(R2)	;PUT TYPE BITS IN FLAG
	BR	RPF8		;DONE

RPFG:	TST	R3		;CHECK DIMS IN CALL
	BEQ	RPFH		;1D CALL
	TST	(R4)		;PDIM2 IS NOT 0 IF 2D ARRAY
	BNE	RPF8		;CHECK OUT OK
RPFI:	BITB	#DIMARY,(R2)	;INCONSISTENT USE, SEE IF DIM'D
	BNE	RPFJ		;YES, LEAVE # ARGS ALONE
	MOV	R3,(R4)		;SET TO LATEST REFERENCE
RPFJ:	ERROR	TLIDIM		;INCONSIS # DIM'S INDEXED VARIABLE
	MOV	SPDA,R0		;RESET R0 FROM POSSIBLE MOVEMENT
	BR	RPF8

RPFH:	TST	(R4)		;1D CALL CASE
	BNE	RPFI		;INCONSISTENT
	BR	RPF8		;PUT TYPE ON OPERAND STACK& EXIT

TLER12:	ERROR	TLXDIM,FATAL	;TOO MANY DIMENSIONS ON INDEXED VARIABLE

RPIDTB:	.BYTE	PPIDO1,PPIDO2	;INDEX VAR FETCHES

;SUBROUTINE OF TLRPFX TO HANDLE FUNCTION CALL CASE
TLRPF1:	IF	NARGS(R0),GT,#5.,RPF3
	MOVB	#PPUSHC,-(R1)	;PUT "PUSHC" OPCODE ON R1 STACK
	JSR	PC,PUCOST	;THEN PUSH IT ONTO CODE STACK
	MOV	TLFNAT(R0),-(R1);MOVE PICTURE WORD TO R1 STACK,THEN
	JSR	PC,TLSTCW	;PUT IT ON CODE STACK
	MOV	@OASP,R2	;GET POINTER TO FUNCTION HEADER
	IFNZ	TLBIFF(R0),RPF10;JMP IF BUILT-IN FCN. CASE
	ADD	R0,R2		;MAKE FCN. HEADER PTR. ABSOL.
	IFNZ	(R2),RPF9	;JMP IF PREV. REF. OR DEFINED
	INC	(R2)+		;SET HEADER 1'ST. WD. POSITIVE TO INDIC. "USED"
	MOV	TLFNAT(R0),(R2)	;PUT PICTURE WD. IN HEADER
RPF4:	IFNZ	TLBIFF(R0),RPF2	;TO RPF2 IF COMPILING A CALL TO A BUILT-IN FCN.
	MOVB	#PPCALL,-(R1)	;BRING "CALL" OPCODE TO R1 STACK
	JSR	PC,PUCPOO	;PUT "CALL" ON CODE STACK, GET ADDRESS
	JSR	PC,TLSTCW	;PUT OPERAND ADDRESS ON CODE STACK
RPF8:	JMP	PUOAST		;PUT TYPE ON OPERAND STACK AND EXIT

RPF9:	INC	R2		;INCR BY 1 MORE IN USER-DEF FCN CASE,
RPF10:	INC	R2		;HEADER FORMATS DIFFER FOR USER, SYSTEM FCTN.
	IF	TLFNAT(R0),EQ,(R2),RPF4	;JMP IF PICTURE WORDS MATCH, ALL O.K.
	MOV	TLFNAT(R0),-(R1);OTHERWISE MOVE CURR. PICT. WD. TO R1 STACK
	MOV	(R2),-(R1)	;THEN MOVE PICT. WD. FROM HEADER TO R1 STACK, ALSO
	MOV	#8.,R4		;SET R4=8
RPF6:	MOV	2(R1),R2	;1ST P.W. FROM R1 STACK TO R2
	BIC	#177774,R2	;CLEAR ALL BUT 2 LOW-ORDER BITS
	ASL	R2		;SHIFT BY
	ASL	R2		; 2 BITS
	MOV	(R1),R3		;PICK UP OTHER P.W. FROM R1 STACK
	BIC	#177774,R3	;CLEAR ALL BUT 2 LOW-ORDER BITS
	ADD	R2,R3		;ADD VAL'S.
	MOV	#^B0111100110011110*2,R2 ;GET MASK OF LEGAL COMBINATIONS
	ASH	R3,R2		;SHIFT LEGALITY BIT INTO THE CARRY
	BCS	RPF7		;ERROR - CANNOT CONVERT AT RUN TIME
	;CLC			;CLEAR HIGH BIT
	ROR	(R1)		;SHIFT ONE PICT. WD. RIGHT 1 BIT
	ASR	(R1)		;AGAIN
	CLC			;CLEAR C-BIT
	ROR	2(R1)		;SHIFT OTHER PICT. WD. RIGHT 1 BIT
	ASR	2(R1)		;DO IT
	SOB	R4,RPF6		;LOOP
	CMP	(R1)+,(R1)+	;R1_R1+4
	BR	RPF4		;YES, CLEAN UP R1 STACK

RPF7:	ERROR	FUNERR,FATAL	;INCONSIST. # OR TYPE OF ARGS IN FCN. CALL

RPF2:	MOV	@OASP,R2	;PICK UP TOP ELEM. OF OPERAND STACK IN R2
	MOVB	(R2),-(R1)	;FETCH OPCODE TO R1 STACK
	JSR	PC,PUCPOO	;PUT OPCODE ON CODE STACK, CLEAN UP
	TST	(R1)+		;R1_R1+2
	BR	RPF8		;GO TO EXIT POINT

RPF3:	ERROR	TLTMAF,FATAL	;TOO MANY ARGS. IN FUNCTION CALL-8 ALLOWED

;FIXUP ROUTINE USED BY TLCOMF, MAKES SURE  INDEX CALC'S. COME OUT FIXED

TLFIXI:	IF	PMODE(R0),GE,#5,TLFIX3	;DO FCN. CALL CASE
	IF	PMODE(R0),LT,#2,TYP0	;DO NON-INDEXED VAR. CASE
	IF	(R1),GE,#2,TLER17	;INVALID TYPE FOR INDEX, SO ERROR
	DEC	(R1)+		;IF TYPE IS A "1" THEN INTEGER ALREADY
	BEQ	TLFIX2		;IT WAS A 1, SO NOTHING TO DO
	MOVB	#PPFIX,-(R1)	;COMPILE A FIX FOR FLOATING INDEX RESULT
	JMP	PUCOST		;PUSH IT ONTO THE CODE STACK

TLER17:	ERROR	TLNZSP,FATAL	;RES. OF INDEX. CALC. NOT FLOAT OR INTEG.

TLFIX3:	INC	(R1)		;ADD 1 TO TYPE ON R1 STACK
	MOV	OASP,R2		;PICK UP OPERAND STACK PTR IN R2
	TST	(R2)+		;POINT R2 AT PICTURE WD ON OPERAND STACK
	;CLC			;CLEAR C BIT
	ROL	(R2)		;ROTATE P.W. LEFT 1 BIT
	ROL	(R2)		;ROTATE P.W. LEFT 1 BIT
	BIS	(R1)+,(R2)	;SET BITS INTO PICTURE WD.
TLFIX2:	RTS	PC		;EXIT

;CALCULATE PMODE VALUE
TLFIPM:	CLR	R3		;ZERO R3
	MOVB	PTOKE(R0),R2	;MOVE C(PTOKE) INTO R2
	BEQ	TLFIP2		;IF PTOKE=0 THEN PMODE=1:RETURN
	BITB	#BASF,R2	;TEST BASIC THING FLAG IN TOKEN FLAG WD.
	BEQ	TLFIP3		;BR IF NOT A BASIC THING
	BITB	#FUNCF,R2	;TEST FUNCTION FLAG IN TOKEN FLAG WD.
	BEQ	TLFIP2		;BR IF NOT A FUNCTION
TLFIP1:	ADD	TLTYCT(R0),R3	;BUILT-IN FUNCTION CASE,VAL=5,6,OR 7
	ADD	#5,R3		;INCREM. R3 BY 5
TLFIEX:	MOV	R3,PMODE(R0)	;STORE C(R3) AS PMODE VALUE
	RTS	PC		;EXIT

TLFIP2:	TSTB	(R3)+		;PARENTH. EXPR. CASE,VAL=1
	BR	TLFIEX		;GO TO EXIT

TLFIP3:	BITB	#FUNCF,R2	;TEST FUNCTION FLAG IN TOKEN FLAG WD.
	BEQ	TLFIP4		;BR IF NOT A FUNCTION
	MOV	#3,R3		;USER-DEF. FUNCTION CASE,VAL=8,9,OR 10
	BR	TLFIP1

TLFIP4:	JMASK0	EQ,R2,INDEXF,TLFIP5,B	;BRANCH IF INDEXED CONSTANT
	TST	(R3)+		;INDEXED VARIABLE CASE,VAL=2,3, OR 4
	ADD	TLTYCT(R0),R3	;INCR. R3 BY TYPE OF VARIABLE
	BR	TLFIEX

TLFIP5:	ERROR	TLNZSP,FATAL	;ERROR INDEXED CONSTANT

;FIND-TYPE OF RESULT GIVEN TYPES OF OPERANDS
;FLOAT+FLOAT IS FLOAT, FIX+FIX IS FIX, FLOAT+FIX IS FLOAT,
;FIX+FLOAT IS FLOAT, STRING+STRING IS STRING -- ANY OTHER ERROR
TYPR:	IF	(R1),LE,#2,TYP1	;TEST WHETHER THERE ARE 2 ARG'S.
TYP0:	TST	(R1)+		;NO ARG2, ARG1 IS ANSWER
	RTS	PC		;EXIT

TYP1:	MOV	(R1),R2		;MOVE ARG2 TO R2
	ADD	R2,R2		;MUL. BY 2
	ADD	(R1)+,R2	;ADD IN ANOTHER & POP IT
	ADD	(R1)+,R2	;ADD IN ARG1, SO HAVE CALC 3*ARG2+ARG1
	MOVB	TYRTAB(R2),R2	;USE C(R2) AS TABLE INDEX
	BMI	TLER16		;MINUS BYTE==> BAD MODE MIXING
	MOV	R2,-(R1)	;MOVE ANSWER TO R1
	RTS	PC		;EXIT

TLER16:	ERROR	TLNOIT,FATAL	;ILLEGAL TYPE COMBINATION

TYRTAB:	.BYTE	0,0,-1		;TYPE COMBIN. TABLE
	.BYTE	0,1,-1
	.BYTE	-1,-1,2
	.EVEN

;ROUTINE TO CALC DATA TYPE FROM TOKEN FLAG BYTE, LEAVES IT IN TLTYCT
TLTYPE:	MOV	TOKE(R0),R5	;MOVE C(TOKE) TO R5
TLTYP1:	BIC	#177770,R5	;CLEAR ALL BUT LOW-ORDER 3 BITS
	MOVB	TYTB(R5),TLTYCT(R0) ;LOOK UP DATA TYPE CODE CORR. TO FLAG BITS
	BPL	TLFLRT		;A NEG. VAL. CORRESP. TO AN ILLEG. COMBIN. OF FLAG BITS
	ERROR	TLURTP,FATAL	;UNRECOGNIZABLE DATA TYPE ERROR

TYTB:	.BYTE	-1,1,0,-1,2,-1,-1,-1 ;TABLE OF DATA TYPE CODES
;TLOPP SKIPS IF CURR. TOKEN IS AN OPERATOR
TLOPP:	IF	TOKE(R0),NE,#300,TLFLRT,B	;NOT AN OPERATOR IF TOKE<>300
	IFZ	TLLSFL(R0),TLOPP1,B	;ARE WE DOING A LEFT SIDE OF A LET?
	CMP	TOKA(R0),#EQUALS	;IF SO, IS TOKEN AN =?
	BNE	TLOPP1			;NO, TEST SOME MORE
	IFZ	TLPCOU(R0),TLFLRT	;IF PAREN LEV=0, = IS A TERMIN.

TLOPP1:	CMP	TOKA(R0),#22		;OPERATOR IF TOKA<=18.
TLOPP2:	BLE	TLFLO1			;IF TRUE, THEN SKIP
	RTS	PC			;ELSE DON'T

;TLOAP SKIPS IF CURR. TOKEN IS AN OPERAND
;I.E.,ANY NON-BASIC TOKEN OR A BUILT-IN FUNCTION
TLOAP:	TBITT	BASF,TLFLO1		;YES,NON-BASIC
	TBITT	FUNCF,TLFLRT		;NO,BASIC BUT NOT A FUNCTION
TLFLO1:	ADD	#2,(SP)			;CAUSE RETURN TO SKIP
TLFLRT:	RTS	PC			;RETURN

;TLGENP GRABS A TOKEN AND SKIPS AS TLENDP BELOW
;TLENDP SKIPS IF CURR. TOKEN IS END OF LINE OR :
;TLGNEP IS COMPLEMENT OF TLGENP AS FAR AS SKIPPING GOES

TLGENP:	JSR	PC,TLGTOK		;TL GET,END PREDICATE
TLENDP:	IF	TOKE(R0),NE,#300,TLFLRT,B ;FOR EOL. OR :  C(TOKE) MUST=300
	IF	TOKA(R0),EQ,#ENDOL,TLFLO1 ;BR IF = E.O.L.
	CMP	TOKA(R0),#COLON		;IS TOKEN =:?
	BNE	TLFLRT			;NO
	BR	TLFLO1			;YES, WAS :

TLGNEP:	JSR	PC,TLGENP		;GET TOKEN AND SEE IF EOL
	BR	TLFLO1			;BR TO SKIP IF NOT E.O.L. OR :
	RTS	PC			;RETURN WITHOUT SKIPPING

;READ TOKEN,PUSH TOKEN AND SKIP IF DATA STRING
TLGPDS:	JSR	PC,TLGTOK		;READ TOKEN
TLPDST:	IF	TOKE(R0),NE,#DSTR,TLFLRT,B	;GO IF NOT
	MOV	TOKA(R0),-(R1)		;PUSH STRING
	BR	TLFLO1			;SKIP


;ROUTINES TO PUSH AND POP WORDS AND BYTES ON TL STACKS

PUOAST:	MOV	#OASL,R2	;****PUSH A WORD ON OPERAND STACK
	CMP	(R2),-(R2)	;LIMIT >= CURRENT VALUE
	BHIS	TLPSH1		;YES--NO ROOM ON THE STACK!
	SUB	#2,(R2)		;SIMULATE WORD PUSH
	MOV	(R1)+,@(R2)+	;MOVE DATA TO NEW TOP OF STACK
	RTS	PC		;THATS IT

PUCPOO:	JSR	PC,PUCOST	;FIRST PUSH A BYTE ON THE CODE STACK
POOAST:	MOV	#OASI,R2	;****POP A WORD OFF OPERAND STACK
	CMP	(R2)+,(R2)	;SEE IF WE'RE UNDERFLOWING
	BLOS	TLPOP1		;WE ARE--QUIT NOW
	MOV	@(R2)+,-(R1)	;MOV WORD ONTO R1 STACK
	ADD	#2,-(R2)	;FIX TL SP TO SIMULATE POP
	RTS	PC		;..

TLSTSP:	MOV	(SP)+,-(R1)	;GET CODE WORD FROM SP STACK
TLSTCW:	SWAB	(R1)		;****MOVE WORD ONTO CODE STACK WITH BYTES REVERSED
	JSR	PC,(PC)		;PUSH BYTE ONTO CODE STACK
;	JSR	...		;PUSH BYTE ONTO CODE STACK (SNEAKY WAY)

PUCOST:	INC	TLTOPC(R0)	;****PUSH BYTE ON CODE STACK
	INC	TLSTPC(R0)	;STATEMENT PC+1_
PUCOS1:	MOV	#COSL,R2	;POINT TO CODE STACK POINTERS
	BR	TLPSHB		;AND PUSH A BYTE

PUOPST:	MOV	#OPSL,R2	;****PUSH A BYTE ONTO OPERATOR STACK
TLPSHB:	CMP	(R2),-(R2)	;SEE IF ROOM ON TOP
	BLO	.+4		;THERE IS
TLPSH1:	ERROR	OUTOAS,FATAL	;THERE WAS NOT...QUIT NOW
	DEC	(R2)		;SIMULATE BYTE PUSH
	MOVB	(R1)+,@(R2)+	;STORE BYTE ON TOP
	RTS	PC		;QUIT

POOPST:	MOV	#OPSI,R2	;****POP BYTE OFF OPERAND STACK
	BR	TLPOPB

POCOST:	MOV	#COSI,R2	;****POP BYTE OFF CODE STACK
TLPOPB:	CMP	(R2)+,(R2)	;SEE IF UNDERFLOW ABOUT TO HAPPEN
	BHI	.+4		;NOPE
TLPOP1:	ERROR	SASYNE,FATAL	;CAUGHT IT, QUIT
	MOVB	@(R2)+,-(R1)	;POP BYTE FROM TL TO R1 STACK
	INC	-(R2)		;UPDATE TL SP
	RTS	PC		;AND QUIT

;+
; DOXTND & DONXTN PERFORM THE EXTEND & NOEXTEND DECLARATIONS. NOTE THAT
; IMMEDIATE MODE SETS OR CLEARS THE DEFAULT EXTEND BIT AS WELL AS THE
; STANDARD EXTEND BIT.
;
; BOTH DOXTND & DONXTN USE A SUBROUTINE XTNDSB WHICH SETS R2 TO THE BITS TO
; BE SET OR CLEARED IN EDFLAG.
;-

DOXTND:	JSR	PC,XTNDSB	;R2 SET TO THE BITS TO SET
	BIS	R2,EDFLAG	;IN EDFLAG
	BR	TLGTOK		;EXIT ALLOWING NO MODIFIERS

DONXTN:	JSR	PC,XTNDSB	;R2 SET TO BITS TO CLEAR
	BIC	R2,EDFLAG	;IN EDFLAG
	BR	TLGTOK		;EXIT ALLOWING NO MODIFIERS

XTNDSB:	MOV	#EDXTND,R2	;THE NORMAL EXTEND BIT INTO R2
	IFZERO	NE,TLLINO(R0),2001$ ;THAT'S ENOUGH IF NOT IMMEDIATE MODE
	BIS	#EDDXTN,R2	;DEFAULT BIT TOO IN IMMEDIATE MODE
2001$:	RTS	PC		;EXIT XTNDSB

;EDCOMP FLAG TO BE CLEARED WHEN END STATEMENT COMPILED.
;ALSO WHEN EOF ENCOUNTERED ON INPUT BY EDFTCH.
DOEND:	MOVB	#PPEND,TLENBY(R0)	;COMPILE AS A STOP
	BIT	#EDCOMP,EDFLAG		;TEST COMPILE MODE FLAG
	BEQ	TLGTOK			;NOT ON
	BIS	#EDEOFF,EDFLAG		;FLAG TO TYPE OUT READY

;REMARK ROUTINE JUST GETS ANOTHER TOKEN

DOREM:

;TLGTOK READS NEXT TOKEN AND SAVES PREV. TOKEN 
;IF PTOKF NE 0, RETURNS WITH SAME TOKEN AS READ LAST TIME

TLGTOK:	IFNZ	PTOKF(R0),TLGTO3,B	;SEE IF REALLY WANT A NEW ONE
TLGTO1:	MOVB	TOKE(R0),PTOKE(R0)	;SAVE PREV. TOKE VAL. IN TOKE
	MOV	TOKA(R0),PTOKA(R0)	;SAVE PREV. TOKA VAL. IN PTOKA
TLGTO2:	JSR	PC,LEXAN		;CALL LEX ANA FOR A TOKEN
	IFTOKA	EQ,REMRK,TLGTO2		;CHECK FOR REMARK TOKENS
TLGTO3:	CLRB	PTOKF(R0)		;CLEAR PTOKF FLAG
	RTS	PC			;AND FILTER THEM OUT


;ROUTINE TO COMPILE LET STATEMENTS
DOLET:	CLR	-(R1)		;NUMBER OF VARIABLES TO STORE RIGHT SIDE AT
DOLE1:	JSR	PC,DOLETL	;COMPILE A LEFT SIDE
	INC	(R1)		;ADD 1 TO COUNT OF L.S. ADDRS.
	IF	TOKA(R0),EQ,#COMMA,DOLE1	;IF , GO BACK FOR ANOTHER L.S.
	IF	TOKA(R0),NE,#EQUALS,TLER18	;NEITHER , OR = SO ERROR
	JSR	PC,TLCOMF	;COMPILE R.S.
	JSR	PC,TYCOMP	;DO ANY NECESSARY TYPE CONVERSION
	JMP	TLMODI

;ROUTINE WHICH DOES ONE LEFT SIDE OF A LET STATEMENT
DOLETL:	JSR	PC,TLGTOK	;GET NEXT TOKEN
DOLETN:	INCB	TLLSFL(R0)	;SET LEFT-SIDE FLAG
	MOV	TOKE(R0),R2	;MAKE TOKE ACCESSIBLE
	IF  R2,LT,#201,TLER18,B	 ;IF IT'S NOT A VARIABLE ,
	IF  R2,GT,#224,TLER18,B  ;THE HECK WITH IT
	BIT	#FUNCF,R2	;SEE IF IT'S A FUNCTION
	BEQ	DOLE2		;IT'S NOT
	JSR	PC,TLTYPE	;GET ITS TYPE
	MOV	TLTYCT(R0),R2	;USE IT AS INDEX
	MOVB	POPT1(R2),-(R1)	;TO GET CORRECT "PUSH" OPCODE
	JSR	PC,PUCOST	;PUT OPCODE ON CODE STACK
	MOV	TOKA(R0),-(R1)	;GET ADDRESS
	ADD	#FNBVAL,(R1)	;INCR. BY FNBVAL TO POINT WHERE VAL. GETS STORED
	JSR	PC,TLSTCW	;PUT IT ON CODE STACK
	JSR	PC,TLCLCB	;CLOSE CODE BLOCK
	JSR	PC,TLGTOK	;READ NEXT TOKEN
	BR	DOLE3

DOLE2:	INCB	PTOKF(R0)	;MOVE TOKEN PTR. BACK 1
	JSR	PC,TLCOMF	;COMPILE A L.S. ADDR. EXPRESSION
DOLE3:	CLRB	TLLSFL(R0)	;CLEAR LEFT-SIDE FLAG
	RTS	PC		;EXIT


TLER18:	TST	TLLINO(R0)	;SEE IF IMMEDIATE
	BNE	TLER20		;NO
	ERROR	TLCNTD,FATAL	;CANT DECODE STATEMENT
TLER20:	ERROR	TLOPNV,FATAL	;ILLEGAL VERB

;ROUTINE TO COMPILE "IF" & "UNLESS" STATEMENTS
DOUNLS:	MOV	#-1,-(SP)	;SET "UNLESS"
	BR	DOI1

DOIF:	CLR	-(SP)		;SET "IF"
DOI1:	INCB	TLINFL(R0)	;FLAG INDIC. CALL OF TLSCOM FROM INSIDE DOIF
	JSR	PC,TLCOMC	;COMPILE CONDITIONAL
	JSR	PC,TLOPCB	;REOPEN CODE BLOCK
	TST	(SP)+		;"IF"?
	BEQ	10$		;YES
	MOVB	#PPANOT,-(R1)	;NO, "UNLESS"
	JSR	PC,PUCOST
10$:	MOVB	#PPIFJ,-(R1)	;PUT "BRANCH IF FALSE" OPCODE ON CODE STACK
	JSR	PC,PUCOST	;BY USING PUCOST
	CLR	-(R1)		;FOLLOW IT WITH 2 ZERO BYTES TO BE FILLED IN
	JSR	PC,TLSTCW	;USE TLSTCW TO PUT THEM ON CODE STACK
	JSR	PC,TLCLUN	;CLOSE AND UNSTACK BLOCK
	MOV	SPTA,R2		;SAVE POINTER TO CURRENT LOCATION IN POP
	MOV	PROPTR(R2),-(R1);RELATIVE TO SPTA
	MOV	#DOI3,-(SP)	;IN EITHER CASE RETURN TO DOI3
	IF	TOKA(R0),EQ,#THEN,DOI6	;IS TOKEN = "THEN"?
	IF	TOKA(R0),EQ,#GOTO,DOI2	;IS TOKEN = "GOTO"?
	ERROR	TLIFFE,FATAL	;FORMAT ERROR IN IF STATEMENT

DOI3:	MOV	(PC)+,-(SP)
	.BYTE	PPNXTL,PPIFNL
	MOV	SPTA,R4		;CURRENT LOC IN POP
	MOV	PROPTR(R4),R3	;REL START CUR STATEMENT
	SUB	(R1),R3		;MAKE CORRECT RELATIVE ADDRESS
	ADD	(R1)+,R4	;MAKE ABS. ADDR. OF CODE WD. TO BE FILLED IN
	IF	TOKA(R0),EQ,#ELSE,DOI4  ;IS TOKEN = "ELSE"?
	CMPB	-(R4),-(R4)	;AIM AT THE PPIFJ
	SWAB	(SP)		;SWITCH TO OTHER POP
	MOVB	(SP)+,-(R4)	;PUT IFNL THERE INSTEAD
	RTS	PC

DOI4:	MOVB	(SP)+,-(R1)	;INSTALL FINAL POP - NEXTL
	JSR	PC,PUCOST	;INTO CODE
	INC	R3		;ONE LATER
	MOVB	R3,-(R4)	;PUT ONE BYTE IN
	SWAB	R3		;SWAP BYTES IN R3
	MOVB	R3,-(R4)	;PUT OTHER BYTE IN
	JSR	PC,TLCLUN	;CLOSE AND UNSTACK BLOCK
DOI6:	JSR	PC,TLGTOK	;READ TOKEN
	IF	TOKE(R0),NE,#200,DOI2,B	;BRANCH IF NOT A LINE #
	CLR	TLTOPC(R0)	;CLEAR TLTOPC COUNTER
	CLR	TLSTPC(R0)	;CLEAR TLSTPC COUNTER
	JMP	FINIF		;GO FINISH UP THE IF

DOI2:	JMP	TLSCOM		;COMPILE STATEMENT

;----------------------------------------------------------------
;	DEF FNA(X,Y,Z)		COMPILES INTO
;	JMPSLD	[- -]		ADDRESS FILLED IN BY CHECKPASS
;	0		DUMMY BYTE
;	ENTR	[FUNCTION BLOCK POINTER]	16 BITS IN-LINE
;	VALUECODE			8 BITS - TELLS IF VALUE F,I,S:0,2,4 RESP.
;	Z PARAMETER			16 BITS IN-LINE
;	Y				16 BITS IN-LINE
;	X				16 BITS IN-LINE
;	NEXTS
;----------------------------------------------------------------
;	DEF FNA(X,Y,Z)=X+Y+Z		COMPILES INTO
;	JMPSLD	[- -]		ADDRESS FILLED IN BY CHECKPASS
;	0		DUMMY BYTE
;	ENTR	[FUNCTION BLOCK POINTER]	16 BITS IN-LINE
;	VALUECODE
;	Z
;	Y
;	X
;	PUSHF X
;	PUSHF Y
;	ADDF
;	PUSHF Z
;	ADDF
;	POPF FNA
;	EXITFN
;---------------------------------------------------------------
;	FNEND				COMPILES INTO
;	EXITFN
;---------------------------------------------------------------
;	LET X=FNA(A,B,C)		COMPILES INTO
;	PUSHF A
;	PUSHF B
;	PUSHF C
;	PUSHC <CALL PICTURE>		16 BITS IN-LINE
;	CALLFN [FUNCTION BLOCK POINTER]
;RTS MAKES A QUICK COMPARISON BETWEEN THE CALL PICTURE AND
;THE FUNCTON BLOCK PICTURE AND IS HAPPY IF THEY ARE IDENTICAL.
;IF NOT, IT TAKES LOTS OF TIME CONVERTING TYPES TO GET ARGUMENT
;COMPATIBILITY BETWEEN CALL AND DEFINITION.
;---------------------------------------------------------------

;ARGUMENT TYPES IN FUNCTION CALLS AND IN FUNCTION DEFS ARE ENCODED
;2 BITS PER ARGUMENT AND ASSEMBLED INTO A WORD CALLED THE PICTURE
;WORD.  THE STATEMENT WORD IN THE FUNCTON BLOCK IS USED TO
;DECODE THE STATUS OF THE FUNCTION, OF WHICH
;THREE CASES ARE OF INTEREST WHEN THE COMPILER ENCOUNTERS A DEF:
;A:  REFERENCED BUT NOT DEFINED - >0 IN STATEMENT WORD
;B:  NOT REFERENCED OR DEFINED - 0 IN STATEMENT WORD
;C:  DEFINED ALREADY - RELATIVE STATEMENT HEADER POINTER (NEGATIVE NUMBER)
;THIS INFORMATION IS KEPT IN THE FUNCTION BLOCK AND IS USED.
;TO GENERATE DIAGNOSTICS AS FOLLOWS
;	IF B THEN NONE
;ELSE IF C THEN "MULTIPLE FUNCTION DEFINITION"
;ELSE IF (PICTURES MATCH) THEN NONE
;THEN NON-FATAL "DEFINITION INCONSISTENT WITH PREVIOUS USE"
;WHEN A FUNCTION DEF IS DELETED IT IS SET TO "REFERENCED BUT NOT
;DEFINED" - THIS WILL ALLOW A DIAGNOSTIC WHEN A NEW DEFINITION IS
;INCONSISTENT WITH THE OLD.

DODEF:	IFZERO	NE,TLLINO(R0),DODEF1	;*A* BR IF IMMEDIATE
	ERROR	NONOIM,FATAL	; *A* NO DEFS IN IMMEDIATE
DODEF1:	JSR	PC,TLIXNC	;START A NEW HEADER
	JSR	PC,TLGTOK	;SHOULD GET FUNCTION
	MOV	TOKE(R0),R2	;IT BETTER BE A FUNCTION NAME
	BIC	#-FUNCF-BASF-1,R2 ;BUT IT CAN'T BE INTRINSIC FUNCTION
	CMP	#FUNCF,R2	;IT HAS TO BE USER-DEFINED THING
	BNE	DODE99		;NOT A LEGAL FUNCTION NAME
	MOV	#PPJSLD,-(R1)	;TO SKIP DEF WHEN DROPPED INTO OF GOTO'D
	JSR	PC,TLCMW2	;LEAVE SPACE FOR ADDRESS
	CLR	-(R1)		;AND ONE EXTRA BYTE
	JSR	PC,TLCMW2	;FOR EVENING UP
	MOVB	#PPENTR,-(R1)	;ENTER OP CODE
	JSR	PC,SCBPPA	;COMPILED
	MOV	TOKE(R0),-(R1)	;SAVE TOKEN TO BUILD
	MOV	TOKA(R0),-(R1)	;POP TO FN VALUE IF ONE-LINE DEF
	MOV	(R1),TLFNBK(R0)	;SAVE FUNCTION BLOCK
	MOV	(R1),-(R1)	;FUNCTION BLOCK
	JSR	PC,TLCMWD	;COMPILED IN LINE
	JSR	PC,TLTYPE	;COMPUTE TYPE
	MOVB	TLTYCT(R0),R2	;AND GET IT TO
	ASL	R2		;MULTIPLY
	MOVB	R2,-(R1)	;BY 2 AND USE AS A BYTE OF CODE
	JSR	PC,SCBPPA	;WHICH IS HOW RTS TELLS WHAT TYPE FN IS
	CLRB	TLFNAR(R0)	;ZERO NUMBER OF ARGS COUNTER
	CLR	TLFNAT(R0)	;FUNCTION'S ARGUMENT TYPE ACCUMULATOR
	JSR	PC,TLGNEP	;PARSE ONE AND TEST FOR END OF STATEMENT
	BR	DODEF9		;MULT-LINE, NO ARGS
	IF	TOKA(R0),EQ,#LPAR,DODEF2
DODEF7:	IF	TOKA(R0),EQ,#EQUALS,DODEF6 ;IF SINGLE LINE NO ARGS
DODE99:	ERROR	TLNOTF,FATAL	;?? FOLLOWING FN

DODE98:	IF	TOKA(R0),NE,#COMMA,DODE13 ;DEMAND A COMMA
DODEF2:	JSR	PC,TLGTOK	;AN ARGUMENT OR
	IF	TOKA(R0),EQ,#RPAR,DODEF3	;IF ALL DONE
	MOVB	TOKE(R0),R2	;GET DUMMY TYPE
	IF	R2,LT,#201,DODE13,B	;IERR IF TOO LOW FOR SCALAR VARIABLE
	IF	R2,LE,#204,DODEF4,B	;IF LEGAL DUMMY
DODE13:	ERROR	TLQDUM,FATAL	;ILLEGAL DUMMY VAR IN DEF

DODEF4:	INCB	TLFNAR(R0)	;INCREASE COUNT OF NUMBER OF ARGS
	CMPB	TLFNAR(R0),#6.	;SEE IF TOO MANY
	BNE	.+4		;NOPE
	ERROR	TLTMAF,FATAL	;TOO MANY DUMMY ARGUMENTS - 5 ALLOWED
	MOV	TLFNAT(R0),R3	;GET PICTURE WORD ACCUMULATOR
	ASL	R3		;R2 HAS TYPE INFO
	ASL	R3		;MOVE OLD PICTURE WORD OVER
	BISB	TLMAKT-177601(R2),R3	;PUT NEW BITS IN ACCUMULATOR
	MOV	R3,TLFNAT(R0)	;SAVE
	MOV	TOKA(R0),-(R1)	;SAVE DUMMY
	JSR	PC,TLGTOK	;A, OR )
	IF	TOKA(R0),NE,#RPAR,DODE98 ;IF NO ')', GO DEMAND COMMA
;HERE AFTER ")"
DODEF3:	TSTB	TLFNAR(R0)	;COMPILE ARG LIST IN REV ORDER
DODE11:	BEQ	DODE10
	JSR	PC,TLCMWD	;COMPILE ONE DUMMY
	DECB	TLFNAR(R0)	;DECREASE COUNT OF THEM
	BR	DODE11		;THEY GO OUT REVERSED

DODE10:	JSR	PC,TLGENP	;IS END OF STATEMENT?
	BR	DODEF7		;NO, BETTER BE =
				;FALL THROUGH TO DODEF9

;HERE WHEN EOS FOR MULTI-LINE DEF HAS BEEN PROCESSED
DODEF9:	ADD	#4,R1		;SKIP SAVED TOKEN SINCE MULTI-LINE DEF
	MOVB	#6,R5		;TYPE FOR MULTI-DEF
	JSR	PC,DODEFC	;COMPARE PICTURES
	BR	DOFNE2		;TL TOP PUTS NEXTS ON

;HERE AFTER "="
DODEF6:	MOV	(R1)+,TOKA(R0)	;REPOST FUNCTION NAME TOKEN
	MOVB	(R1),TOKE(R0)	;TO COMPILE POP TO VALUE FOR IT
	TST	(R1)+		;IN CASE LA SENSITIVE TO REST OF TOKE
	JSR	PC,TLDFVL	;PUT APPROPRIATE POP ON CODE STACK
	MOVB	#10,R5		;SET TYPE
	JSR	PC,DODEFC	;COMPARE PICTURES
	MOV	#1,-(R1)	;ONE LEFT SIDE
	MOVB	#BASTOK,TOKE(R0);IT'S NOT NICE TO TRICK TLCOMF
	JSR	PC,TLCOMF	;COMPILE RIGHT SIDE, AND UNSTACK POP
	JSR	PC,TYCOMP	;ASSURE TYPE COMPATIBILITY AND PUT IN POP
DOFNE1:	JSR	PC,TLDUMP	;FLUSH INTO POP AREA
	MOVB	#PPXIT,-(R1)	;COMPILE EXITFN
	JSR	PC,PUCOST	;PPXIT TO TLENBY DOESN'T WORK HERE
	MOV	#TLIDXH,-(SP)	;SO JMPSLD HITS NEXT GUY
DOFNE2:
TLUNST:	IFZERO	EQ,TLINFL(R0),TLUNS2,B  ;BR IF OUTSIDE "IF...THEN"
	ERROR	TLIFFE,FATAL	;TRIED A STATEMENT IN "IF...THEN" THAT PERMITS NO MODIFIERS

TLUNS0:	IFNZ	TLINFL(R0),TLUNS1,B  ;IF "INSIDE" FLAG SET, BRANCH
TLUNS2:	JSR	PC,TLENDP	;OTHERWISE CALL TLENDP
	ERROR	EOSERR,FATAL	;IF NOT E.O.L. OR :, IT'S AN ERROR

TLDUMP:	JSR	PC,TLCLCB	;CLOSE CODE BLOCK
TLSKAG:	JSR	PC,UNSTCB	;AND UNSTACK IT INTO PUSHPOP AREA
	BR	TLSKAG		;LOOP AROUND
	RTS	PC		;TILL DNSTCB SKIPS TO HERE, THEN EXIT

TLUNS1:	JSR	PC,MODMAP	;CALL MODMAP
	BHI	TLSKAG		;TEST & BR
	ERROR	EOSERR,FATAL	;ERROR, STAT. DIDN'T END IN END-OF-LINE OR :

;FUNCTION END VERB
DOFNEN:	JSR	PC,TLGTOK	;POINT AT END OF LINE WE HOPE
	JSR	PC,TLIXNC	;START A NEW HEADER
	MOVB	#2,(R4)+	;SIGNAL A FNEND
	BR	DOFNE1

;TLMAKT IS TABLE OF PICTURE VALUES FOR EACH DATA TYPE

TLMAKT:	.BYTE	2,1		;INTEGER=2,	FLOAT=1
	.BYTE	0,3		;NO ARG =0,	STRING=3

;TLDFVL PUTS A POP OF THE APPROPRIATE TYPE ON THE CODE STACK
;DEPENDING ON THE CURRENT TOKEN
TLDFVL:	JSR	PC,TLTYPE	;COMPUTE ITS TYPE
	MOV	TLTYCT(R0),R2	;FOR USE AS INDEX
	MOVB	DOPUST(R2),-(R1);INTO A TABLE OF POPS
	JSR	PC,PUCOST	;PUT RIGHT KIND ONTO CODE STACK
	MOV	TLFNBK(R0),-(R1);MAKE A VALUE POINTER
	ADD	#FNBVAL,(R1)	;ON THE R1 STACK
	JSR	PC,TLSTCW	;AND MOVE IT TO THE CODE STACK
	JMP	TLCLCB		;AND CLOSE THE CODE STACK BLOCK

DOPUST:	.BYTE	PPUSHF,PPUSHI,PPUSHS	;FLOATING, FIXED, STRING
	.EVEN

;DODEFC SETS UP THE FUNCTION BLOCK, COMPARES PICTURES OF VARIABLES &
;CHECKS FOR CONSISTENCY.  IT ALSO COMPLAINS ABOUT MULTIPLE DEFINITIONS.
DODEFC:	MOV	SCTH,R4		;TO GET AT TYPE BYTE
	MOVB	R5,TAGTYP(R4)	;INSTALL IT
	MOV	TLFNBK(R0),R2	;SET UP FUNCTION BLOCK
	ADD	R0,R2		;MAKE ABS POINTER
	TST	(R2)+		;WHAT DOES STATEMENT WORD LOOK LIKE
	BEQ	DODFC1		;FOR PREVIOUSLY UNHEARD OF
	BPL	DODFC2		;AROUND MULT DEF CASE
	CLRB	TAGTYP(R4)	;THIS FUNCTION
	ERROR	TLMFND,FATAL	; MULTIPLY DEF FN

DODFC2:	CMP	TLFNAT(R0),(R2)	;CMPR WITH PICTURE WORD
	BEQ	DODFC1		;DEF CONSISTENT WITH USE
	ERROR	TLINCD		;NON-FATAL - FN DEF INCONSIS WITH PREVIOUS USE
DODFC1:	MOV	SPDA,R0		;RELOAD AFTER POSSIBLE RELOC
	MOV	TLFNBK(R0),R2
	ADD	R0,R2
	MOV	SCTH,(R2)	;SAVE IT
	SUB	SPTA,(R2)+
	MOV	TLFNAT(R0),(R2)	;TO PICTURE WORD
	RTS	PC

;SPECIAL FORM OF "LET" STATEMENT COMPILER FOR USE IN "FOR",ETC.
SIMLET:	JSR	PC,TLCOMF	;COMPILE STATEMENT
	JSR	PC,TLOPCB	;OPEN CODE BLOCK
	MOV	(R1),R5		;COPY TOP R1 STACK ELEM. TO R5
	JSR	PC,TLTYP1	;FIND TYPE OF DESTIN.
	MOV	TLCOMR(R0),R2	;GET TYPE OF RESULT OF COMPILATION
	ASL	R2		;TO SELECT WHICH HALF OF TABLE
	ADD	TLTYCT(R0),R2	;SELECT ITEM
	IF	R2,GE,#4,TLER21	;CATCH INCOMPATIBLE DATA TYPES
	MOVB	SIMLTA(R2),-(R1);SELECT THE APPROP. POP
	JMP	PUCOST		;PUT IT ON THE CODE STACK

SIMLTA:	.BYTE	PPOPF,PPFIPI,PPFLPF,PPOPI


;ROUTINE TO CHANGE PUSHES TO POPS AND TO SET UP TYPE COMPATIBILITY
;BETWEEN LEFT SIDE(S) AND RIGHT SIDE IN "LET" STATEMENTS
;EXPECTS THE NUMBER OF LEFT SIDES ON R1 STACK
TYCOMP:	MOV	COSP,R2		;KEEP CODE STACK POINTER IN R2
				;GET # OF BYTES OF RIGHT SIDE CODE
	MOVB	(R2)+,-(R1)	;MOVE BYTE FROM CODE STACK TO R1 STACK
	MOVB	(R2)+,-(R1)	;MOVE BYTE FROM CODE STACK TO R1 STACK
	SWAB	(R1)		;SWAP BYTES IN TOP R1 STACK WD.
	ADD	(R1)+,R2	;MOVE PTR PAST R.S. CODE
TYCOL1:	DEC	(R1)		;DEC LEFT SIDE COUNT
	BPL	TYCOL2		;BR IF MORE TO DO
	TST	(R1)+		;POP LEFT SIDE COUNT
	RTS	PC		;EXIT

;MORE TO DO,GET # OF BYTES IN THIS L.S. BLOCK AND KEEP IT IN R4

TYCOL2:	MOVB	(R2)+,-(R1)	;MOVE BYTE FROM CODE STACK TO R1 STACK
	MOVB	(R2)+,-(R1)	;MOVE BYTE FROM CODE STACK TO R1 STACK
	SWAB	(R1)		;SWAP BYTES IN TOP R1 STACK WD.
	MOV	(R1)+,R4	;POP TOP R1 STACK ELEM. TO R4
	CMPB	(R2)+,(R2)+	;R2_R2+2 POINT AT PUSH
	MOVB	(R2),R3		;AND BRING IT INTO R3
	MOV	R2,-(SP)	;PUT PTR. ON R1 STACK FOR NOW
	CLR	R2		;ZERO R2
TYCOL3:	IF	POPT1(R2),EQ,R3,TYCOL4,B	;FIND PUSH OPCODE IN POPT1
	INC	R2		;ADD 1 TO R2
	BR	TYCOL3		;GO AROUND AGAIN


TYCOL4:	MOVB	POPT2(R2),R3	;CALC. INDEX TO REF. POPT3
	MOV	TLCOMR(R0),-(SP)  ;GET RIGHT SIDE PSEUDO-TYPE
	IF	(SP),GT,#2,TYCOL5	;BR IF NOT TYPE INFO
	ADD	(SP),(SP)	;IF TYPE INFO, DOUBLE IT
	IFZERO  EQ,(R1),TYCOL5	;BR IF WORKING ON LEFTMOST LEFT SIDE
	INC	R3		;ADD 1 TO R3 IF NOT LEFTMOST L.S.
TYCOL5:	ADD	(SP)+,R3	;FIRST STAB AT POPT3 INDEX
	IF	R2,LT,#3,TYCOL6	;BR IF AN INDEXED STORE
	MOV	(SP),R2		;COPY TOP ELEM.
	MOV	R3,-(R1)	;SAVE R3 VAL. ON R1 STACK
	MOVB	-(R2),-(R1)	;MOVE A FULL WORD
	MOVB	-(R2),-(R1)	; FROM CODE STACK TO R1 STACK
	MOV	(R1)+,R2	;GET DATA TYPE INF. FROM DOPE VECTOR
	ADD	R0,R2		;MAKE ABSOLUTE POINTER
	MOVB	ARYFLG(R2),R2	;GET FLAG BYTE WITH TYPE IN IT
	BIC	#177774,R2	;REMOVE JUNK
	MOVB	POPT2(R2),R3	;GET APPROP. POPT3 INDEX FROM POPT2
	ADD	(R1)+,R3	;ADD DATA TYPE CODE TO R3
TYCOL6:	MOVB	POPT3(R3),R3	;USE R3 TO INDEX POPT3
	BEQ	TLER21		;GET POP OPCODE FROM POPT3--0 MEANS ERROR
	MOV	(SP)+,R2	;BRING BACK PTR.
	MOVB	R3,(R2)		;INSERT NEW OPCODE
	ADD	R4,R2		;MOVE ON TO NEXT L.S., IF ANY
	CMPB	-(R2),-(R2)	;R2_R2-2
	BR	TYCOL1		;GO AROUND FOR CODE BLOCK, IF ANY

TLER21:	ERROR	TLNOIT,FATAL	;ERROR,INCOMPATIBLE DATA TYPES


;TABLES USED BY TYCOMP
POPT1:	.BYTE	PPUSHF,PPUSHI,PPUSHS,PPIDO1,PPIDO2
POPT2:	.BYTE	0,9.,18.,27.,54.

POPT3:	.BYTE	PPOPF,PPREPF,PPFLPF,PPFLRF,0,0
	.BYTE	0,0,0
	.BYTE	PPFIPI,PPFIRI,PPOPI,PPREPI,0,0
	.BYTE	0,0,0
	.BYTE	0,0,0,0,PPOPS,PPREPS
	.BYTE	PPLSET,PPRSET,PPFSET
	.BYTE	PPIDR1,PPIRR1,PPFLD1,PPFLR1,0,0
	.BYTE	0,0,0
	.BYTE	PPFID1,PPFIR1,PPIDR1,PPIRR1,0,0
	.BYTE	0,0,0
	.BYTE	0,0,0,0,PPIDR1,PPIRR1
	.BYTE	PPILS1,PPIRS1,PPIFS1
	.BYTE	PPIDR2,PPIRR2,PPFLD2,PPFLR2,0,0
	.BYTE	0,0,0
	.BYTE	PPFID2,PPFIR2,PPIDR2,PPIRR2,0,0
	.BYTE	0,0,0
	.BYTE	0,0,0,0,PPIDR2,PPIRR2
	.BYTE	PPILS2,PPIRS2,PPIFS2
	.EVEN

;DATA IN DATA STATEMENTS IS PUT IN THE PUSHPOP AREA
;THE TEXT OF THE DATA STATEMENT AFTER THE DATA VERB
;IS COPIED VERBATUM.  IT IS PROCEEDED BY ONE BYTE (A NEXTS POP)
;AND IS FOLLOWED BY ONE BYTE (ANOTHER NEXTS POP).

DODATA:	JSR	PC,TLIDXH	;MAKE A NEW HEADER FOR IT
	MOV	MDD(R0),TLMIND(R0)	;BACKUP FOR USE BY EDRSTH
	MOVB	#4,(R4)		;SET TAGTYP
	MOVB	#PPNXTS,-(R1)	;SKIP GARBAGE WHEN RUNNING
	JSR	PC,SCBPPA	;BY INSERTION OF NEXTS
DODAT1:	BIS	#QUOT1F,STAT(R0);SET QUOTE FLAG
	JSR	PC,TLGPDS	;INSIST ON IT BEING A CONSTANT STRING
	BR	UNST4		;INSIST ON A STRING
	MOV	(R1),R2		;POINTER TO STRING
	ADD	R0,R2		;NOW ABSOLUTE
	MOV	4(R2),-(SP)	;SAVE LENGTH
	CLR	R3		;CHARACTER INDEX
DODAT3:	MOV	(R1),R2		;GET STRING
	ADD	R0,R2		;ABS
	ADD	2(R2),R2	;ABS TO STRING NOW
	ADD	R3,R2		;POINT TO PARTICULAR CHAR
	MOVB	(R2),-(R1)	;TO STACK
	MOV	R3,-(SP)	;SAVE R3
	JSR	PC,SCBPPA	;TO PUSH-POP AREA
	MOV	(SP)+,R3	;RESTORE R3
	INC	R3		;TO NEXT CHAR
	CMP	R3,(SP)		;IS IT LAST?
	BNE	DODAT3		;IF NOT
	CMP	(R1)+,(SP)+	;FIX STACK POINTER
	JSR	PC,EDRSTH	;RESTORE STRING HEADER POINTER TO 
				;POSITION BEFORE THIS STATEMENT COMPILED
	BR	DODAT1		;BACK UPSTAIRS

;COMPILE A WORD FROM THE R1 STACK
TLCMWD:	SWAB	(R1)
TLCMW2:	JSR	PC,(PC)		;PUT OUT HIGH BYTE
				;THEN LOW BYTE AND RETURRN

;ROUTINE TO STORE A BYTE (FROM R1 STACK) IN THE PUSHPOP CODE AREA
;AT CURR. PTR. LOCATION AND INCREMENT PTR.

SCBPPA:	JSR	PC,PUCOS1	;FIRST PUT IT ON CODE STACK
	MOV	#1,R3		;THEN USE UNSTACK
	BR	UNST5		;TO DO THE WORK

;ROUTINE TO CLOSE AND UNSTACK. MUST BE ONLY ONE BLOCK ON STACK!

TLCLUN:	JSR	PC,TLCLCB	;FIRST CLOSE

;ROUTINE TO UNSTACK A CODE BLOCK AND STORE CODE IN PUSHPOP AREA.
;IF CALLED WITH NO BLOCKS ON CODE STACK,DOES NOTHING AND SKIPS ON RETURN

UNSTCB:	IF	COSP,EQ,COSI,UNST2  ;BR IF NO MORE BLOCKS TO DO
	JSR	PC,TLPOPW	;POP FULL WD. FROM CODE STACK
	MOV	(R1)+,R3	;GET BACK # BYTES
UNST5:	CLR	R2		;ZERO R2
	ADD	R3,COSP		;ADD # BYTES TO CODE STACK PTR.
UNST3:	TST	R3		;IS R3 = 0?
	BEQ	UNST4		;IF SO, GO EXIT
	MOV	SPTA,R5		;GET AT PROGRAM STORAGE POINTER
	MOV	PROPTR(R5),R4	;GET POINTER TO AVAILABLE PUSH-POP SPACE
	IF	R4,NE,PROLIM(R5),UNST1	;TEST OUT OF PROGRAM SPACE
	JSR	R5,ECONOM	;STORAGE MANAGER
	+	PRONOM		;GET PPOP SPACE
	BR	UNST3		;NOW SHOULD BE ABLE TO STORE

UNST1:	ADD	R5,R4		;MAKE ABSOLUTE POINTER
	ADD	COSP,R2
	MOVB	-(R2),(R4)	;MUST BE CAREFUL OF RELOCATION BY PROOUT
	SUB	COSP,R2
	INC	PROPTR(R5)	;AND THIS POINTER
	MOV	SCTH,R5		;UPDATE LENGTH IN HEADER TO
	INC	TAGPUL(R5)	;KEEP GARBAGE COLLECTOR AT BAY
	SOB	R3,UNST3	;LOOP UNTIL ALL MOVED
UNST4:	RTS	PC		;EXIT

UNST2:	JMP	TLFLO1		;EXIT WITH SKIP


;INVERSE OF TLSTCW
TLPOPW:	JSR	PC,POCOST	;POP BYTE FROM R1 STACK TO CODE STACK
	JSR	PC,POCOST	;POP BYTE FROM R1 STACK TO CODE STACK
	SWAB	(R1)		;SWAP BYTES IN TOP WD. OF R1 STACK
	RTS	PC

;ROUTINE TO CLOSE OUT CODE BLOCK BY PUTTING  PC VALUE (I.E. LENGTH)
;ON IT, AND FINALLY INITIALIZING FOR NEXT BLOCK

TLCLCB:	MOV	TLTOPC(R0),-(R1);GET CODE COUNT WD.
	JSR	PC,TLSTCW	;PUSH IT ONTO CODE STACK
	SUB	#2,TLSTPC(R0)	;DECR TLSTPC VAL. BY 2 (CORR. TO 2 BYTE COUNT)
	CLR	TLTOPC(R0)	;CLEAR TLTOPC
	RTS	PC		;EXIT

;ROUTINE TO REOPEN LATEST CODE BLOCK, UNDOES TLCLCB

TLOPCB:	JSR	PC,TLPOPW	;POP FULL WD. FROM CODE STACK (I.E., COUNT)
	MOV	(R1)+,TLTOPC(R0);PUT IT IN TLTOPC
	RTS	PC		;EXIT

;OPERATOR PRECEDENCE TABLE
TLPRET:	.BYTE	7		;+
	.BYTE	8.		;*
	.BYTE	8.		;/
	.BYTE	7		;-
	.BYTE	10.		;UNARY -
	.BYTE	11.		;^
	.BYTE	4		;AND,&
	.BYTE	3		;OR
	.BYTE	3		;XOR
	.BYTE	5		;NOT
	.BYTE	2		;IMP
	.BYTE	1		;EQV
	.BYTE	6		;=
	.BYTE	6		;<>
	.BYTE	6		;>
	.BYTE	6		;>=
	.BYTE	6		;<
	.BYTE	6		;<=
	.BYTE	6		;==

TLOTAF:	.BYTE	PPADDF		;ADDF
	.BYTE	PPMULF		;MULF
	.BYTE	PPDIVF		;DIVF
	.BYTE	PPSUBF		;SUBF
	.BYTE	PPNEGF		;NEGF
	.BYTE	PPPWRF		;PWRF
	.BYTE	0		;ILLEGAL, NO SUCH OPCODE
	.BYTE	0		;   "
	.BYTE	0		;   "
	.BYTE	0		;   "
	.BYTE	0		;   "
	.BYTE	0		;   "
	.BYTE	PPEQF		;.EQ.F
	.BYTE	PPNEF		;.NE.F
	.BYTE	PPGTF		;.GT.F
	.BYTE	PPGEF		;.GE.F
	.BYTE	PPLTF		;.LT.F
	.BYTE	PPLEF		;.LE.F
	.BYTE	PPEVF		;==
	.BYTE	PPUSHF		;PUSHF
TLOTAI:	.BYTE	PPADDI		;ADDI
	.BYTE	PPMULI		;MULI
	.BYTE	PPDIVI		;DIVI
	.BYTE	PPSUBI		;SUBI
	.BYTE	PPNEGI		;NEGI
	.BYTE	PPPWRI		;PWRI
	.BYTE	PPAND		;.AND.
	.BYTE	PPOR		;.OR.
	.BYTE	PPXOR		;.XOR.
	.BYTE	PPNOT		;.NOT.
	.BYTE	PPIMP		;.IMP.
	.BYTE	PPIFF		;.IFF.
	.BYTE	PPEQI		;EQI
	.BYTE	PPNEI		;NEI
	.BYTE	PPGTI		;GTI
	.BYTE	PPGEI		;GEI
	.BYTE	PPLTI		;LTI
	.BYTE	PPLEI		;LEI
	.BYTE	0		;ILLEGAL, NO SUCH OPCODE
	.BYTE	PPUSHI		;PUSHI

TLOTAS:	.BYTE	PPCONC		;CONCAT
	.BYTE	0		;ILLEGAL, NO SUCH OPCODE
	.BYTE	0		;   "
	.BYTE	0		;   "
	.BYTE	0		;   "
	.BYTE	0		;   "
	.BYTE	0		;   "
	.BYTE	0		;   "
	.BYTE	0		;   "
	.BYTE	0		;   "
	.BYTE	0		;   "
	.BYTE	0		;   "
	.BYTE	PPEQS		;EQS
	.BYTE	PPNES		;NES
	.BYTE	PPGTS		;GTS
	.BYTE	PPGES		;GES
	.BYTE	PPLTS		;LTS
	.BYTE	PPLES		;LES
	.BYTE	PPEVS		;==
	.BYTE	PPUSHS		;PUSHS
	.EVEN
TLOTIX:	.WORD	TLOTAF,TLOTAI,TLOTAS

NXLENG	=	7			;LENGTH OF "NEXT" PUSHPOP CODE
NEXTST	=	3			;FLAG BITS FOR "NEXT" STATEMENT HEADER
FORST	=	7			;FLAG BITS FOR "FOR" STATEMENT HEADER

;TABLE OF PUSHPOP CODES

INTFOR:	.BYTE	PPFRI		;PPCODE FOR "FOR-TO" INTEGER INTERNAL
	.BYTE	PPFRF		;DITTO---------------FLOATING INTERNAL
EXTFOR:	.BYTE	PPFRIX		;DITTO---------------INTEGER EXTERNAL
	.BYTE	PPFRFX		;DITTO---------------FLOATING EXTERNAL
	.BYTE	PPRPI		;PPCODE FOR "WHILE" OR "UNTIL"
	.BYTE	PPRPF		;SAME SEQUENCE AS ABOVE
EXTRPT:	.BYTE	PPRPIX		; *** MUST HAVE PPRP?=PPFR?+1 FOR ?=I,F,IX,FX
	.BYTE	PPRPFX
INNEXT:	.BYTE	PPNXI		;PPCODE FOR "NEXT"
	.BYTE	PPNXF		;SAME SEQUENCE AS ABOVE
EXNEXT:	.BYTE	PPNXIX
	.BYTE	PPNXFX
IFJAD:	.BYTE	PPIFJ		;JUMP ON FALSE INTERNAL
	.BYTE	PPITJ		;JUMP ON TRUE INTERNAL

;FETCH A LIST OF PAIRS FROM TL
;IF NO  PAIRS BEFORE STATEMENT END, USE 1-INFINITY
;IF IT IS A SINGLETON USE IT AS BOTH START AND END.
;LEAVE PAIRS IN LISTOP FORMAT ON R1 PAIRS HAVE TO BE REVERSED FOR LISTOP

TLPAIR:	CLR	-(R1)		;TO COUNT PAIRS
TLPAIL:	JSR	PC,TLGNEP	;SKIP IF NOT END OF STATEMENT
	BR	TLPAI1		;STATEMENT ENDED HERE
	IF	TOKE(R0),EQ,#200,TLPA10,B	;SEE IF LINNO
	IF	TOKA(R0),EQ,#COMMA,TLPAIL
TLPA10:	JSR	PC,TLGLN1	;STACK THE LINE NUMBER OR DIE
	JSR	PC,TLGNEP	;SKIP IF NOT END
	BR	TLPAI7		;TERMINAL SINGLETON
	IF	TOKA(R0),NE,#COMMA,TLPAI5
	MOV	(R1),-(SP)	;SINGLETON
	BR	TLPAI6

TLPAI5:	IF TOKA(R0),EQ,#BMINS,TLPAI9
	ERROR	TLPRNM,FATAL	;ILLEGAL ARGUMENT PAIR FOR LIST OR DELETE
TLPAI9:	MOV	(R1)+,-(SP)	;TEMPORARILY USE THIS STACK
	JSR	PC,TLGLNO	;GET 2ND LINE # OR DIE
TLPAI6:	MOV	(R1)+,-(SP)
	INC	(R1)		;BUMP # PAIRS
	BR	TLPAIL

TLPAI7:	MOV	(R1)+,-(SP)	;STACK TWO COPIES
	MOV	(SP),-(SP)
	INC	(R1)		;COUNT ONE MORE PAIR
TLPAI1:	TST	(R1)		;IF NO PAIRS
	BNE	TLPAI2		;USE INFINITY
	INC	(R1)		;THEN FROM 1
	MOV	#77777,-(R1)	;TO EFFECTIVE INFINITY
	MOV	#1,-(R1)	;AND 1 PAIR
	RTS	PC		;RETURN RESULT

TLPAI2:	MOV	(R1)+,R2	;POP COUNT OF PAIRS
	MOV	R2,R3		;SAVE A COPY
TLPAI8:	JSR	PC,R1SCHK	;CK FOR ENOUGH R1 SPACE
	MOV	(SP)+,R4	;MOVE UP AN END
	MOV	(SP)+,-(R1)	;TRANSFER A BEGIN
	MOV	R4,-(R1)	;NOW PUT IN END
	SOB	R2,TLPAI8	;BRANCH UNTIL EACH ONE NEW
	MOV	R3,-(R1)	;PUT ON CORRECT
	RTS	PC

;TYPE "FILE NAME--" AND SEE IF YOU GET ONE
;DONT GET MAD IF YOU DONT
NEWOLD:	JSR	PC,TLGENP	;SEE IF END OF LINE
	BR	NEWOL2		;MUST BE A FILE NAME THEN
	JSR	PC,EDTYPE	;TYPE NEW OR OLD
	MOV	#ASKNAM,-(R1)	;ASK MESSAGE
	JSR	PC,EDTYPE	;TYPE IT
	BIS	#QUOT1F+IMMEDF,STAT(R0)  ;CONDITION LA TO MAKE A STRING
;ROUTINE TO ASK FOR A FILE NAME BUT NOT BARK IF NONE GIVEN.
TLGFNA:	JSR	PC,TLGENP	;GIVE ZERO IF NONE SPECIFIED
	BR	NEWOL1
	CLR	-(R1)		;USE NONAME
	RTS	PC

NEWOL2:	TST	(R1)+		;RID OF ASCII
NEWOL1:	JSR	PC,TLPDST	;IF DATA STRING PUSH IT AND SKIP
	ERROR	TLJNKY,FATAL	;BAD STUFF INSTEAD OF CONSTANT STRING
	JMP	TLGTOK

TLGDFN:	JSR	PC,TLGENP	;DIE IF NO FILE NAME GIVEN
	BR	NEWOL1
	ERROR	TLNOFN,FATAL	;NO FILE NAME GIVEN FOR COMMAND

;TLGLNO GETS A LINE NUMBER FROM LA OR COMPLAINS
TLGLNO:	JSR	PC,TLGTOK
TLGLN1:	IF	TOKE(R0),NE,#200,TLER19,B	;NOT A LINE NO
	MOV	TOKA(R0),-(R1)
	RTS	PC

TLER19:	ERROR	TLRNNM,FATAL	;?? INSTEAD OF A LINE NUMBER

;FOLLOWING SUBROUTINE DOES MODIFIER CODE FOR STATEMENT ASSUMED TO BE ON
;CODE STACK - "FOR" MODIFIERS ARE HANDLED AS INTERNAL VARIANTS OF "FOR"
;STATEMENTS WITH DUMMIED "NEXT" STATEMENTS SAVED ON THE R1 STACK FOR
;INSERTION AT THE END OF PROCESSING - UNLIKE THE "FOR" STATEMENTS,
;FORWARD LINKS AND BACKLINKS ARE FILLED IN IMMEDIATELY IN THE MODIFIER
;CASE - MODIFIER SEGMENTS MUST BE FOLLOWED BY COLON, CARRIAGE RETURN, OR "ELSE" -
;DESTROYS R2-R5 - JSR PC

TLMODI:	CLR	-(SP)		;CLR LOOP COUNTER
MODRET:	JSR	PC,TLCLCB	;CLOSE CURRENT CODE BLOCK
	JSR	PC,MODMAP	;SET CFLG & CONDITION CODES FOR DELIMITER
	BGE	MDERR		;LEGAL MODIFIER OR END?
	BLOS	LEGMOD		;YES - LEGAL MODIFIER?
				;NO - AT THE END OF A  MODIFIER SEGMENT
MODEND:	JSR	PC,UNSTCB	;UNSTACK CODE BLOCK INTO SPTA AREA
	BR	MODEND		;NOT EMPTY - AROUND AGAIN

	.BLOOP	MDEND,(SP)	;BEG LOOP TO EMPTY DUMMY LOOP ENDS SAVED ON R1 STACK
	IF (R1)+,NE,#BASTOK,MDEND3,B	;INTERNAL JUMP ON R1?
	JSR	PC,PUCOST	;YES - MOVE OPCODE ONTO CODE STACK
	JSR	PC,TLSTCW	;MOVE ADDRESS ONTO CODE STACK
	BR	MDEND4

MDEND3:	JSR	PC,FORST1	;MOVE "NEXT" PP CODE ONTO CODE STACK
MDEND4:	JSR	PC,TLCLCB	;CLOSE CODE BLOCK
	.ELOOP	MDEND		;END LOOP TO EMPTY DUMMY LOOP ENDS
	TST	(SP)+		;CLEAN UP STACK
	JMP	TLUNS0		;EXIT EXPECTING AN END OF STATEMENT

;HERE WE BEGIN TO PROCESS A MODIFIER SEGMENT KNOWN TO START
;WITH IF, UNLESS, FOR, WHILE, OR UNTIL
LEGMOD:	BNE	MDOFOR		;"FOR"DIFIER?
	BPL	MDOWHI		;NO - "IF" OR "UNLESS"?
	JSR	PC,PPCOND	;YES - COMPILE IT
	BR	MODRET		;LOOK FOR NEXT MODIFIER

;HERE WE ARE PROCESSING "WHILE" OR "UNTIL" MODIFIER -
MDOWHI:	ADD	#3,TLSTPC(R0)	;INCREMENT CODE LENGTH BY LENGTH
				;OF LOOP END RETURN JUMP
	JSR	PC,PPCOND	;COMPILE CONDITIONAL EXPRESSION
	MOV	TLSTPC(R0),-(R1);SET RETURN JUMP ADDR ON R1 STACK
	NEG	(R1)		;IT'S NEGATIVE
	MOV	(PC)+,-(R1)	;PUT UJ OPCODE ON STACK AND
	.BYTE	BASTOK,PPUJ	;BASTOK PSEUDO-TOKEN AT TOP
	BR	INCLC

;HERE WE ARE PROCESSING "FOR" MODIFIERS
MDOFOR:	JSR	R5,SETNEX	;GENERATE "NEXT" PUSHPOP SKELETON ON R1 STACK
	.WORD	INNEXT		;WITH INTERNAL OPCODE
	BCS	MDOFO1		;CONTROL VARIABLE PRESENT?
MDERR:	ERROR	MODERR,FATAL	;NO-ERROR

MDOFO1:	SUB	TLSTPC(R0),6(R1);NEG CODE LENGTH INTO BACKLINK
	JSR	R5,PSTNEX	;GENERATE "FOR" PUSHPOP SKELETON ON R1 STACK
	.WORD	INTFOR		;WITH INTERNAL OPCODE
	MOV	TLSTPC(R0),6(R1);CODE LENGTH INTO FORWARD LINK
	JSR	PC,FORSUB	;DO THE "FOR" MODIFIER
	ADD	TLSTPC(R0),16(R1);SET BACKLINK BLOCK TO LENGTH OF
				;CODE GEN. SINCE MDOFOR
	MOV	4(R1),14(R1)	;SET CONTROL BLOCK PTR IN "NEXT" SKELETON
	JSR	PC,@(SP)+	;BACK TO FORSUB
	ADD	#NXLENG,TLSTPC(R0)  ;INC CODE LEN BY LEN OF "NEXT" PPOP
	SUB	TLSTPC(R0),6(R1);SET BACKLINK IN "NEXT" SKELETON
INCLC:	INC	(SP)		;INCREMENT LOOP COUNTER
	BR	MODRET		;LOOK FOR NEXT MODIFIER

;FORSUB DOES ASSIGNMENTS FOR "FOR" STATEMENTS AND "FOR"
;MODIFIERS - IT ASSUMES THERE IS A "FOR" SKELETON ON THE
;R1 STACK WHEN IT IS CALLED - 
;DIDDLES THE OPCODE, VARIABLE ADDRESS, AND CONTROL
;BLOCK ADDRESS AS IT FINDS APPROPRIATE - AFTER
;ASSIGNMENTS ARE COMPLETE, RETURNS COROUTINE
;STYLE TO ALLOW FOR CLEANUPS - THEN DUMPS
;"FOR" STATEMENT OR "FOR" MODIFIER CODE (INCLUDING
;CONDITIONAL EXPRESSIONS FOR "WHILE" AND "UNTIL")
;ONTO CODE STACK - DESTROYS R2-R5 - JSR PC

FORSUB:	JSR	PC,TLGTOK	;GET NEXT TOKEN
	IFTOKA	NE,EQUALS,MDERR	;ERROR IF NOT AN EQUALS SIGN
	JSR	PC,SIMLET	;PUT PPCODE ASSIGNING VARIABLE ONTO CODE STACK
	MOV	2(R1),-(R1)	;SUPPLY VARIABLE ADDESS FOR FINAL POP
	JSR	PC,TLSTCW	;AND INTO THE CODE STACK WITH IT
	JSR	PC,MODMAP	;SET CFLG & CONDITION FLAGS FOR NEXT DELIMITER
	BGT	STEPDL		;BRANCH ON "STEP"
	BLT	FORSB0		;"TO" OR SCREWY TOKEN?
	BCC	TODELM		;YES - "TO"?
FORSB0:	BMI	MDERR		;NO - LOOK FOR "WHILE" OR "UNTIL"
	BNE	MDERR

;HERE WE HAVE EITHER "WHILE" OR "UNTIL" TERMINATION
	INC	4(R1)		;INC CONTROL BLOCK ADDR TO INDICATE STEP SIZE ONE
	INCB	1(R1)		;TURN "FOR" OPCODE INTO CORRESPONDING CONDITIONAL RPT OPCODE
FORSB1:	JSR	PC,@(SP)+	;GO DO SOME EXTERNAL CODE
	JSR	PC,FORSTK	;PUT CONDITIONAL RPT STATEMENT ON CODE STACK
	JSR	PC,TLCOMC	;ALSO CONDITIONAL EXPR
	JSR	PC,TLOPCB	;OPEN THE CODE BLOCK
	ASR	CFLG(R0)	;SET CARRY IF PREVIOUSLY SET
	BCC	WHICND		;BRANCH IF "WHILE"
	MOVB	#PPANOT,-(R1)	;FOR "UNTIL", COMPLEMENT TEST
	JSR	PC,PUCOST	;GET PPANOT ON CODE STACK
WHICND:	MOVB	#PPENDA,-(R1)	;PUT "CONDITION END" PUSHPOP ONTO CODE STACK
	BR	FORSB2		;GET IT ON & EXIT

;HERE WE'RE PROCESSING EITHER "TO" OR "STEP" IMMEDIATELY
;FOLLOWING THE ASSIGNMENT OF THE "FOR" CONTROL VARIABLE

STEPDL:	JSR	PC,LETSIM	;PUT PPCODE ASSIGNING STEP SIZE ONTO CODE STACK
	DEC	4(R1)		;WILL GET INCREMENTED BACK IN A MINUTE
	JSR	PC,MODMAP	;SET CFLG & CONDITION FLAGS ON DELIM
	BR	FORSB0

;HERE WE'RE DOING THE "TO" DELIMITER
TODELM:	JSR	PC,LETSM1	;PUT PPCODE ASSIGNING LIMIT ONTO C0DE STACK
	INC	4(R1)		;IN CASE NO FOLLOWING "STEP" STATEMENT, INDICATE STEP OF ONE
	JSR	PC,MODMAP	;SET CFLG & CONDITION FLAGS ON DELIMITER
	BLE	TODEL1		;"STEP"?
	JSR	PC,LETSIM	;YES - PUT PPCODE ASSIGNING
				;STEP SIZE ONTO CODE STACK
TODEL1:	MOVB	#PPSDRO,-(R1)	;ADD THE SETDRO PPOP IN THE "FOR...TO" CASE
	JSR	PC,PUCOST	;PUT IT ON THE CODE STACK
	JSR	PC,@(SP)+	;DO SOME EXTERNAL CODE
FORSTK:	INC	R1		;MOVE "FOR" BLOCK ONTO CODE STACK
FORST1:	MOV	#TLSTCW,-(SP)	;SET UP CALL TO TLSTCW TO MOVE FORWARD LINK
	MOV	(SP),-(SP)	;DITTO TO MOVE CONTROL BLOCK ADDR
	MOV	(SP),-(SP)	;DITTO TO MOVE VARIABLE ADDR
FORSB2:	JMP	PUCOST		;MOVE OPCODE, ALL THE OTHER STUFF & EXIT

;THIS ROUTINE PUTS PUSHPOP CODE FOR A CONDITIONAL EXPR
;ON THE CODE STACK - FOLLOWING THAT, IT PUTS THE
;APPROPRIATE CONDITIONAL JUMP CODE FOR IF, UNLESS,
;WHILE, OR UNTIL - ASSUMES WORD BUILT BY
;MODMAP IS IN CFLG - DESTROYS R2-R5 - JSR PC

PPCOND:	MOV	TLSTPC(R0),-(R1);LENGTH OF CODE ONTO R1 STACK
	MOV	#IFJAD,R3	;R3_ADDR IFJ PUSHPOP
	ASR	CFLG(R0)	;SET CARRY IF ITJ NECESSARY
	ADC	R3		;R3_ADDR APPROP. PUSHPOP
	MOVB	(R3),-(R1)	;APPROP PUSHPOP ONTO R1 STACK
	JSR	PC,PUCOST	;PUT CONDITIONAL JUMP ON CODE STACK
	JSR	PC,TLSTCW	;DITTO JUMP ADDRESS-AND EXIT
	JSR	PC,TLCLCB	;CLOSE CODE BLOCK
;	JMP	TLCOMC		;PUT CONDITIONAL PP BLOCK ON CODE STACK & EXIT

;ROUTINE TO COMPILE A CONDITIONAL
TLCOMC:	INCB	TLCOFL(R0)	;SET CONDIT. FLAG
	JSR	PC,TLCOMF	;CALL TLCOMF TO COMPILE EXPR.
	CLRB	TLCOFL(R0)	;CLEAR CONDIT. FLAG
	IF  TLCOMR(R0),EQ,#1,TLCOM1  ;IS TYPE OF COMPILED EXPR = INTEGER?
	ERROR	TLCONI,FATAL	;ERROR - CONDITIONAL NOT AN INTEGER-VALUED EXPRESSION

TLCOM1:	RTS	PC		;EXIT

;THE FOLLOWING ROUTINE MAPS DELIMITERS
;WHICH CAN OCCUR IN MODIFIER EXPRESSIONS INTO NUMBERS
;WHICH ARE USED TO SET THE 4 CONDITION BITS
;IN THE PROCESSOR STATUS REGISTER - AT EXIT,
;THE NUMBER IS IN CFLG AS WELL AS IN THE N,Z,V,C BITS - 
;JSR PC
MODMAP:	MOV	R5,-(SP)	;SAVE R5
	MOV	#MAPTAB,R5	;R5_BEG OF TEST & VALUE TABLE
	IF  TOKE(R0),EQ,(R5)+,1$,B  ;BRANCH IF TOKEN A BASIC VERB ETC.
	MOV	#MOERR,R5	;OTHERWISE, SET UP ERROR RETURN
1$:	MOVB	(R5)+,CFLG(R0)	;CFLG _ POTENTIAL VALUE OF COND FLAGS
	IF  R5,EQ,#MOERR+1,2$	;BRANCH IF AT ERROR VALUE
	IF  (R5)+,NE,TOKA(R0),1$,B  ;GO AROUND AGAIN IF NO MATCH YET
2$:	MOV	(SP)+,R5	;YES - RESTORE R5
	MOV	(PC)+,-(SP)	;SET THE RETURNING INSTRUCTION ON STACK
		JSR	SP,@(PC)+
	MOV	#260,-(SP)	;MODEL "SET CONDITION CODES" INSTRUCTION
	BISB	CFLG(R0),(SP)	;NOW 'OR' IN CC BITS TO SET
	CCC			;CLEAR ALL CONDITION CODES NOW
	JMP	(SP)		;NOW EXECUTE CODE AND "RTS PC"

;MODMAP TABLE - MODMAP VALUE PRECEDES TOKA VALUE	N Z V C NXV Z+NXV Z+C
MAPTAB:	.BYTE	BASTOK		;BASIC VERB ETC. TOKEN
	.BYTE	6,216		;WHILE			0 1 1 0  1    1    1
	.BYTE	3,146		;FOR			0 0 1 1  1    1    1
	.BYTE	10,301		;ELSE			1 0 0 0  1    1    0
	.BYTE	10,43		;COLON			1 0 0 0  1    1    0
	.BYTE	10,27		;CARRIAGE RETURN	1 0 0 0  1    1    0
	.BYTE	1,302		;STEP			0 0 0 1  0    0    1
	.BYTE	14,144		;IF			1 1 0 0  1    1    1
	.BYTE	15,TKUNLS	;UNLESS			1 1 0 1  1    1    1
	.BYTE	16,314		;TO			1 1 1 0  0    1    1
	.BYTE	7,220		;UNTIL			0 1 1 1  1    1    1
MOERR:	.BYTE	17		;END OF TABLE - ERROR	1 1 1 1  0    1    1

;SETNEX SETS UP A DUMMY "NEXT" OR "FOR" STATEMENT (OR ITS SKELETON) ON THE R1
;STACK AND MOVES TOKE TO THE TOP OF R1 - AT ENTRY TO SETNEX, IT SHOULD BE TIME
;TO READ THE CONTROL VARIABLE (IF THARE IS ONE) - SETNEX WILL RETURN WITH THE
;CARRY BIT ON IFF IT HAS READ AN INTEGER OR FLOATING CONTROL VARIABLE - THE CALL
;TO SETNEX SHOULD BE IMMEDIATELY FOLLOWED BY A WORD POINTING AT A TWO BYTE TABLE
;OF EITHER THE INTERNAL OR EXTERNAL VARIANTS OF THE "NEXT" OR "FOR" PUSHPOP CODE
;(INTEGER VARIANT PRECEDING FLOATING VARIANT)  -  
;DESTROYS R2 - JSR R5

SETNEX:	JSR	PC,TLGTOK	;READ CONTROL VARIABLE TOKEN - MAYBE
PSTNEX:	CLR	-(R1)		;MAKE BACKLINK SLOT
	CLR	-(R1)		;MAKE CONTROL BLOCK PTR SLOT
	CLR	-(R1)		;MAKE VARIABLE SLOT + ZERO IT
	JSR	PC,MAPTOK	;R2_1 IF FLOATING VARIABLE OR 0 IF INTEGER OR OTHER NONERROR
	ADD	(R5)+,R2	;ADD IN TABLE BASE & CLR CARRY
	JMASK0	NE,TOKE(R0),VARFIF,SNX1  ;INTEGER OR FLOATING VARIABLE?
	SEC			;YES - SET CARRY
	MOV	TOKA(R0),(R1)	;SET CONTROL VARIABLE
SNX1:	MOVB	(R2),-(R1)	;SET "NEXT" PUSHPOP CODE
	MOVB	TOKE(R0),-(R1)	;EVEN OFF R1 BY ADDING TOKE AT THE TOP
 	RTS	R5

;THESE ROUTINES SIMULATE COMPILATION OF A LET STATEMENT IN THE FOLLOWING SENSE
;IT IS AS THOUGH TOKE IS SET FROM THE TOP BYTE ON R1, AND TOKA TO THE NEXT
;AVAILABLE CONSTANT SPACE IN THE SPDA AREA - THESE ARE ASSUMED TO BE THE TOKEN
;WORDS FOR A VARIABLE WHICH IS TO BE SET TO THE VALUE OF THE NEXT EXPRESSION
;ALSO MOVES ADDR IN TOKA INTO CONTROL BLOCK PTR WORD IN "FOR" STATEMENT SKELETON 
;LETSIM ASSIGNS THE VARIABLE SPACE BEFORE EXPRESSION COMPILATION
;LETSM1 DOES THE EXPRESSION COMPILATION FIRST, THEN ASSIGNS THE SPACE FOR THE POP
;DESTROY R2-R5 - JSR PC

LETSIM:	JSR	PC,SIMSET	;MAKE A SLOT IN CTRL BLK & RETURN ITS ADDR ON THE R1 STACK
	JSR	PC,SIMLET	;GENERATE ASSIGNMENT STATEMENT, EXCEPT FOR POP ADDR
	BR	LETSM2		;PUT POP ADDR ON CODE STACK
LETSM1:	JSR	PC,SIMLET	;GENERATE ASSIGNMENT STATEMENT, EXCEPT FOR POP ADDR
	JSR	PC,SIMSET	;MAKE A SLOT IN CTRL BLK & RETURN ITS ADDR ON THE R1 STACK
LETSM2:	MOV	4(R1),-(R1)	;SET THE POP ADDR FOR NEXT INSTRUCTION
	JMP	TLSTCW		;PUT POP ADDR ON CODE STACK & EXIT

SIMSET:	SWAB	TOKE(R0)	;SAVE TOKE AT TOKE+1
	MOVB	(R1),TOKE(R0)	;DUMMY TOKE TO CTRL VAR TOKEN FLAGS
	MOV	R1,R1RING	;IN CASE OF CORE ALLOCATION
	JSR	PC,FRESPC	;R3_ADDR LAST USED WORD IN SPDA CONSTANT AREA
	MOV	R1RING,R1	;NOW RETRIEVE IT
	JSR	PC,TOKDEC	;R3_NEXT AVAILABLE CONSTANT HOLE
	MOV	R3,NEXFRE(R0)	;UPDATE LAST CONSTANT PTR
	MOV	R3,4(R1)	;SET CONTROL BLOCK PTR IN "FOR" STATEMENT SKELETON
	SWAB	TOKE(R0)	;RESTORE REAL TOKEN TO TOKE
	RTS	PC

;THIS ROUTINE DOES THE STATEMENTS BEGINNING WITH "WHILE" OR
;"UNTIL" INSTEAD OF "FOR" - DESTROYS R2-R5 - JSR PC

DOUNTL:
DOWHIL:	JSR	PC,MODMAP	;SET UP CFLG
	JSR	R5,PSTNEX	;GENERATE "FOR" SKELETON ON R1 STACK
	.WORD	EXTRPT		;WITH EXTERNAL OPCODE
	JSR	PC,FORSB1	;SYNCHRONIZE WITH FORSUB ROUTINE
	BR	DOFO2		;BUT GO TO DOFO2

;THIS ROUTINE DOES "FOR" STATEMENTS, LEAVING
;FORWARD LINKS TO BE FILLED IN AT RUN TIME
;DESTROYS R2-R5 - JSR PC
DOFOR:	JSR	R5,SETNEX	;GENERATE "FOR" PUSHPOP SKELETON ON R1 STACK
	.WORD	EXTFOR		;WITH EXTERNAL OPCODE
	BCS	DOFO1		;CONTROL VARIABLE PRESENT?
	ERROR	MODERR,FATAL	;NO - ERROR

DOFO1:	JSR	PC,FORSUB	;DO THE "FOR" INSTRUCTION
	MOVB	#PPNXTS,-(R1)	;NEXT STATEMENT PLEASE
	JSR	PC,PUCOST	;COMPILE IT
DOFO2:	JSR	PC,TLCLCB	;CLOSE CODE BLOCK
DOFO3:	JSR	PC,UNSTCB	;UNSTACK CODE STACK
	BR	DOFO3		;KEEP UNSTACKING UNTIL EMPTY
	JSR	PC,TLIXNC	;GENERATE NEW HEADER
	MOVB	#FORST,(R4)	;TAG IT AS A "FOR" STATEMENT TYPE
	JSR	PC,@(SP)+	;BACK TO FORSUB
	BR	DNX2		;EXIT EXPECTING NO MODIFIERS

;COMPILES "NEXT" STATEMENTS, WITH OR WITHOUT A
;CONTROL VARIABLE - LEAVES BACKLINK TO BE FILLED IN AT
;RUN TIME - DESTROYS R2-R5  -  JSR PC
DONEXT:	JSR	PC,TLIXNC	;MAKE SURE THERE'S A NEW HEADER
	MOVB	#NEXTST,(R4)	;TAG HEADER AS "NEXT" TYPE
	JSR	R5,SETNEX	;PUT "NEXT" CODE ON R1 STACK
	.WORD	EXNEXT		;USING EXTERNAL PUSHPOPS
	BCC	DNX1		;CONTROL VARIABLE VARIANT?
	JSR	PC,TLGTOK	;YES - READ NEXT TOKEN
DNX1:	JSR	PC,FORSTK	;PUT "NEXT" CODE ON CODE STACK
DNX2:	JMP	TLUNST		;EXIT EXPECTING NO MODIFIERS

;-------------------------------------------------------------------
;SYNTAX ANALYZER - A SET OF OPERATORS USED FOR MANY MESSY STATEMENTS
;NAMES OF THE MICRO-CODED OPERATORS HAVE FOLLOWING SYNTAX:
;	[R][N][D][F][J]
;	      [V][I]
;	      [X][S]
;	        [E]
;	        [T]
;	OR  C([B]
;	      [A]
;	      [T]
;	      [I]
;	      [S])
;THE LETTERS STAND FOR:
;	A	ANY FORMULA FROM INPUT STREAM
;	B	THE BYTE FOLLOWING
;	C	COMPILE
;	D	DATA, I.E. AN ACTUAL NUMBER OR STRING
;	E	END OF STATEMENT-CR,:,IF,FOR,UNLESS,WHILE, UNTIL,THEN
;	F	FLOATING
;	I	INTEGER
;	J	JUMP TO FOLLOWING LOCATION IF SATIS.
;	N	NOT MATCHING
;	R	READ A NEW TOKEN
;	S	STRING
;	T	A TOKEN
;	V	VARIABLE
;	X	MATRIX VARIABLE
;THERE ARE A NUMBER OF OTHER OPERATORS WITHOUT SUCH REGULAR NAMES
;THE NAMES OF THE FIRST SET OF OPERATORS IS INTERPRETABLE AS FOLLOWS:
;	1)  IF R PRESENT, FIRST READ A NEW TOKEN
;	2)  N MEANS THE IMPLIED PREDICATE IS SATISFIED IF THREE
;	    DO NOT MATCH; NO MATCH IS ATTEMPTED UNLESS
;	    SOME CHARACTER OF THE 4 THE CLASS IS PRESENT
;	3)  IF D PRESENT THEN INSIST THAT CURRENT TOKEN BE ACTUAL DATA
;	    IF V INSIST IT BE A VARIABLE
;	    IF X INSIST IT BE AN ARRAY
;	4)  IF ONE OF THE FOURTH GROUP OCCURS, THE CURRRENT TOKEN MUST
;	    BE OF THAT CLASS
;	5)  IF J IS NOT PRESENT THEN A FATAL ERROR IS CAUSED BY FAILURE
;	    OF THE MATCH; IF J IS PRESENT A BRANCH TO THE LOCATION 
;	    WHICH IS GIVEN AS THE SECOND ARGUMENT WILL OCCUR WHEN THE
;	    CONDITION  IS SATISFIED

;THE NAMES OF THE SECOND SET OF OPERATORS IS INTERPRETABLE AS "COMPILE
;THE INDICATED QUANTITY".  IN PARTICULAR:
;	CB	COMPILE THE FOLLOWING BYTE--NO EFFECT ON TOKEN POINTER
;	CA	COMPILE A FORMULA FROM THE INPUT STREAM
;	CT	COMPILE THE CURRENT TOKEN (2 BYTES)
;	CI	COMPILE A FORMULA AND INSIST THAT IT BE INTEGER - USE
;		TYPE COMVERSION ROUTINE IF POSSIBLE.
;	CS	COMPILE A STRING
;ALL CALLS TO THE FORMULA COMPILER ASSUME THAT THE CURRENT TOKEN IS
;THE FIRST IN THE FORMULA AND IS ONE PAST THE FORMULA AT RETURN.
;FOR EXAMPLE:
;	T COMMA		MEANS "ERROR IF NOT A COMMA" 
;	RS		MEANS READ A TOKEN, ERROR IF NOT A STRING
;	NVJ LOC		JUMP TO "LOC" IF CURRENT TOKEN NOT A VARIABLE
;	RNTJ COMMA,LOC	MEANS READ A TOKEN; IF IT IS NOT A COMMA JUMP
;			TO "LOC"


;...;...;...;...;...;...;...;...
;   ;   ;   ;       ;       ;   
; R ; N ; J ; D V X ; F I S ; - 
;   ;   ;   ;   ;   ;   ;   ;   
;...;...;...;...;...;...;...;...
;R=200	N=100	J=40	D=10	F=2
;			V=20	I=4
;			X=30	S=6
;			   E=20
;			   T=10

;CONTROL IS TRANSFERRED HERE FOR MICRO-CODED OPS WITH THE OP
;SITTING ON THE STACK SHIFTED ONE PLACE RIGHT
SAMICR:	BPL	SAMI01		;SIGN SET ORIGINALLY FOR READ (R)?
	JSR	PC,TLGTOK	;YES - HANDLE R
SAMI01:	CLRB	MATCH(R0)	;0 IN MATCH = "FALSE"
	MOV	(SP),R3		;GET SHIFTED MICRO-CODED OP
	BIC	#177774,R3	;MASK FOR FIS
	MOVB	SATBIT(R3),R3	;CONVERT TO TOK FORMAT
	BEQ	SAMICA		;IF FIS=0 (BITS FIS 0 1)
	BITB	R3,TOKE(R0)	;EITHER COM OR NOT
	BEQ	SAMICC		;DEPENDING ON BIT
SAMI12:	COMB	MATCH(R0)	;IN TOKE
	MOV	(SP),R3		;MASK FOR DVX
	ASR	R3		;RIGHT ON!!!
	ASR	R3		;DVX BITS NOW TWO LEAST SIG
	BIC	#177774,R3	;CLOBBER THE REST
	MOVB	SATBIT+4(R3),R3	;CONVERT TO A PSEUDO-TOKEN FORMAT
	CLC			;GOTTA HAVE THAT CARRY CLEAR
	RORB	R3		;SAVE ODD-EVEN INFORMATION IN CARRY
	BITB	R3,TOKE(R0)	;CORRESPONDING BITS SET FOR TYPE?
	BCS	SAMI05		;COMPLEMENT FOLLOWING TEST IF C ON
	BNE	SAMICC		;WAS THERE A MATCH?
	BR	SAMI06		;NO - CLR MATCH

SATBIT:	.BYTE	0,FLOATF,INTGF,STRINF
	.BYTE	1,DATAF+DATAF,BASF+BASF+DATAF+DATAF+1,INDEXF+INDEXF
SAMI05:	BEQ	SAMICC
SAMI06:	CLRB	MATCH(R0)
SAMICC:	BIT	#40,(SP)	;N (BIT 5)
	BEQ	SAMI07	
	COMB	MATCH(R0)	;THEN COMPLEMENT TEST
SAMI07:	BIT	#20,(SP)+	;J (BIT 4)
	BNE	SAMI08
	TSTB	MATCH(R0)	;NOT J
	BNE	SAINT		;OK, MATCHED
	ERROR	SASYNE,FATAL	;SYNTAX ERROR
SAMI08:	MOVB	(R5)+,R3	;GET JUMP LOCATION
	TSTB	MATCH(R0)	;SEE IF OK TO JUMP
	BEQ	SAINT		;NO
	ADD	R3,R5		;YES
	DEC	R5
	BR	SAINT

SAMICA:	MOV	(SP),R3		;GET OP AGAIN
	ASR	R3		;DISPATCH ON DVX
	BIC	#177771,R3	;AGAIN
	ADD	R3,PC
	BR	SAMI10		;R ALONE (?)
	BR	SAMI09		;T
	BR	SAMI11		;CHECK FOR END OF STATEMENT
	BR	SAMI12		;TEST FOR ARRAY TYPE
SAMI11:	JSR	PC,MODMAP	;MAYBE "IF" ETC?
	BGE	SAMICC		;NOPE
SAMI10:	COMB	MATCH(R0)	;YES SET MATCH
	BR	SAMICC

SAMI09:	CLR	R3
	BISB	(R5)+,R3	;T CASE
	CMP	R3,TOKA(R0)	;SEE IF THEY MATCH
	BNE	SAMICC		;NOPE
	BR	SAMI10		;YEP

;SA OPERATOR INTERPRETER PROPER
;ENTER WITH JSR R5,SAINT
;EXIT WITH QUIT OP
;THE MACROS DEFIN - ARE
;USED TO DEFINE OPS.

.MACRO	DEFIN0	NAME	;DEFINE OP WITH NO ARGS
	$'NAME=.-SAIDAD
	.GLOBL	$'NAME
.IIF	NE	$'NAME&177401,	.ERROR	;ILLEGAL OFFSET FOR NAME
.ENDM

.MACRO	DEFIN1	NAME	;ONE ABSOLUTE ARG
	DEFIN0	NAME
.ENDM

.MACRO	DEFIN2	NAME	;ONE ABS,ONE REL
	DEFIN0	NAME
.ENDM

.MACRO	DEFIN3	NAME	;ONE RELATIVE ARG
	DEFIN0	NAME
.ENDM

;MAIN INTERPRETER ENTRY------------------------------------------------
;MAIN ENTRY TO THE SYNTAX ANALYZER INTERPRETER
;CALL WITH JSR R5,SAINT WITH CODE BYTE STRING FOLLOWING THE CALL.

SAINT:	CLR	-(SP)		;R5 HAS INTER PC
	MOVB	(R5)+,(SP)
	ASRB	(SP)		;PICK UP OP
	BCS	SAMICR		;LOW BIT INTO CARRY - ON IF MICRO-CODED
	ASLB	(SP)		;RESTORE OP TO DISPATCH
	ADD	PC,(SP)
SAIDAD:	JSR	PC,@(SP)+	;DISPATCH
	BR	SAINT

;NON-MICRO CODED OP DISPATCH TABLE
;THE MACROS DEFINE THE OP AS A MACRO
	DEFIN0	RCS		;READ AND COMPILE STRING
	JSR	PC,TLGTOK	;READ NEW TOKEN
	DEFIN0	CS		;COMPILE A STRING EXPRESSION
;COMPILE A STRING EXPRESSION OR DIE
SACS:	JSR	PC,SACOMF	;COMPILE A FORMULA
	BGT	SARTS		;IF STRING
	ERROR	SAFNOS,FATAL	;FORMULA NOT A STRING
	DEFIN0	CN		;COMPILE AN EXPRESSION FOR A NUMBER
SACN:	JSR	PC,SACOMF	;COMPILE FORMULA
	BLE	SARTS		;OK IF NUMERIC
	ERROR	SASNOI,FATAL	;FORMULA IS NON-NUMERIC
	DEFIN1	CB		;(BYTE) COMPILE IN-LINE BYTE
	CLR	-(R1)
	MOVB	(R5)+,(R1)
	DEFIN0	CBS		;COMPILE A BYTE FROM STACK
SACI2:	MOVB	(R1)+,(R1)	;PUSH UP A BYTE AND PUT ON CODE STACK
	BR	SAOPT1
	DEFIN0	PT		;PUSH TOKEN
SARDI1:	MOV	TOKA(R0),-(R1)
	RTS	PC
	DEFIN0	SARF		;SET ARRAY FLAG FOR LA
	BIS	#ARF,STAT(R0)
	RTS	PC

	DEFIN3	CALLS
	MOV	(SP),-(SP)	;SAVE INTERP CALL
	MOV	R5,2(SP)	;SAVE INTERP RETURN
	INC	2(SP)		;SHOULD EVENTUALLY BE REMOVABLE
	DEFIN3	B		;LOCATION BRANCH
SACI90:	MOVB	(R5),R3
	ADD	R3,R5		;A RELATIVE BRANCH
	RTS	PC
	DEFIN1	PBS		;(BYTE) PUSH BYTE (USE WORD) OF STACK
	CLR	-(R1)
	MOVB	(R5)+,(R1)
	RTS	PC
	DEFIN0	TST1AI		;TEST & REMOVE WORD FROM STACK
	TST	(R1)+
	RTS	PC
	DEFIN0	P0		;PUSH ZERO
	CLR	-(R1)
	RTS	PC

	DEFIN0	PTYPE		;PUSH TYPE OF TOKA
SATYPE:	MOV	R5,-(SP)	;CALL TO THE TYPE ROUTINE
	JSR	PC,TLTYPE
	MOV	TLTYCT(R0),-(R1)	;IT PUT TYPE THERE
	BR	SAR5RT
	DEFIN0	QUITD		;LEAVE TO MACHINE CODE
	MOV	R5,(SP)		;CLOBBER RTS PC ADDRESS WITH R5
	ASR	(SP)+		;NOW DUMP IT BUT LOAD CARRY
	ADC	R5		;MAKE R5 EVEN IF NEEDED
	RTS	R5		;RETURN TO MACHINE CODE
	DEFIN0	QUIT		;LEAVE VIA TLMODI
SAQU01:	CMP	(SP)+,(SP)+	;RID OF OLD R5
	JMP	TLMODI		;UNSTACK & TREAT MODIFIERS
	DEFIN0	RCI		;READ AND COMPILE INTEGER
	JSR	PC,TLGTOK	;READ NEW TOKEN
	DEFIN0	CI		;COMPILE AN INTEGER EXPRESSION
SACI:	JSR	PC,SACN		;GET SOME KIND OF NUMBER
	BEQ	SARTS		;IT IS AN INTEGER ALREADY
	MOVB	#PPFIX,-(R1)	;PUT OUT OP TO FIX A FLOATER
SAOPT1:	MOV	R5,-(SP)
	JSR	PC,PUCOST	;COMPILE IT
SAR5RT:	MOV	(SP)+,R5
	CMP	TLCOMR(R0),#1	;LEAVE WITH TEST SETUP
SARTS:	RTS	PC
	DEFIN3	COPR		;(TABLE) USE VALUE IN TLCOMR
SAOPR:	MOV	TLCOMR(R0),-(R1);USE TLCOMR TYPE TO REFERENCE TABLE
	BR	SAOPT2
	DEFIN0	MATCHT
	BITB	#STRINF,TOKE(R0);ASSURE IT IS NOT STRING
SAOKCK:	BEQ	SARTS		;OK
	ERROR	SASYNE,FATAL	;SYNTAX ERROR
	DEFIN0	QUITN		;FOR STATEMENTS NOT TAKING MODIFIERS
	CMP	(SP)+,(SP)+	;KILL OLD R5
	JSR	PC,TLUNST	;UNSTACK CODE FROM CODE STACK ETC.
	JSR	PC,TLIDXH	;FOR DIM STMTS WHICH BEGIN WITH NEXTS
	MOVB	#11,(R4)	;TAGTYP IS "END OF DIM"
	RTS	PC		;THAT'S IT

	DEFIN0	SHARF		;SET FLAG FOR LA
	BIS	#HARF,STAT(R0)
	RTS	PC

	DEFIN0	QUITS		;RETURN FROM INTERP SUBR
	MOV	(SP)+,R5
	RTS	R5

	DEFIN0	GLNS		;GET AND STACK A LINE NUMBER
	JMP	TLGLNS
	DEFIN0	RINTS		;READ AND STACK A CONSTANT - MAKE FIXED
	BR	SARINT
	DEFIN0	C2OF1		;COMPILE BYTE FROM 2ND WORD OF STACK
	MOV	2(R1),-(R1)
	BR	SACI2
	DEFIN0	CCB		;CLOSE CODE BLOCK
	BR	CCBDEF
	DEFIN0	CF		;COMPILE FIELD LEFT SIDE A LA TOM E
	BR	CFDEF2
	DEFIN0	TC		;R1-AIDED TYPE CONVERSION A LA TOME
	BR	TCDEF
	DEFIN0	CFA		;COMPILE FIELD ADDRESS
	BR	SACFA
	DEFIN0	CL		;COMPILE A LEFT SIDE (OF LET)
	BR	SACL		;USEFUL SUBROUTINE
	DEFIN1	SF		;SET FLAG BYTE
	MOVB	(R5)+,SAINTF(R0)
	RTS	PC
	DEFIN0	ICF		;INCREMENT FLAG
	INCB	SAINTF(R0)
	RTS	PC
	DEFIN3	COPT		;(TABLE) COMPILE ONE BYTE FROM TABLE
	BR	SAOPT		;ACCORDING TO TYPE OF TOKA (FIS)
	DEFIN0	CT		;COMPILE 2 BYTES OF TOKEN
	MOV	TOKA(R0),-(R1)
	DEFIN0	CW		;COMPILE WORD FROM STACK
	MOV	R5,-(SP)
	JSR	PC,TLSTCW	;R5 OK
SARAH5:	BR	SAR5RT

	DEFIN2	BFS		;BRANCH FLAGS SET
	BITB	(R5)+,SAINTF(R0)
	BNE	SACI90
SACI91:	TSTB	(R5)+		;SKIP OVER THE BRANCH ADDRESS
	RTS	PC
	DEFIN2	BFC		;BRANCH IF FLAG CLEAR
	BITB	(R5)+,SAINTF(R0)
	BEQ	SACI90
	BR	SACI91

	DEFIN0	SEXIT
	INC	R5		;ROUND R5 UP TO NEXT
	BIC	#1,R5		;EVEN (.EVEN)
	MOV	(R5),R5		;DO EXTERNAL JUMP
	RTS	PC		;AND EXIT

	DEFIN0	CA		;COMPILE A FORMULA
	BR	SACOMF

	DEFIN0	ARYS
	MOV	R5,-(SP)
	MOV	10(R1),R2	;R2=REL. HEADER ADDRESS
	CLR	R0		;INDICATE RELEASE STORAGE
	JSR	PC,THENT	;RELEASE ANY CURRENTLY ALLOCATED STORAGE
	MOV	R4,R0		;RESTORE SPDA
	MOV	R2,R3		;R3=REL. HEADER ADDRESS
	ADD	R0,R3		;NOW ABS
	ADD	#FLAGS,R3	;POINTER TO ARRAY STATUS BYTE
	BITB	#DIMARY,(R3)	;SEE IF PREVIOUSLY DIMED
	BEQ	1$		;NO
	JSR	PC,TLDUMP	;RESET CURRENT DOPE VECTOR ADDRESS
	MOV	SCTH,R5		;
	SUB	#2,TAGPUL(R5)	;REMOVE THIS HEADER ADDRESS
	MOV	(SP)+,R5	;RESTORE R5
	ERROR	DIMED2,FATAL	;2ND TIME ARRAY APPEARING IN DIM STATEMENT

1$:	BITB	#REFARY,(R3)	;SEE IF REFERENCED YET
	BEQ	2$		;NO, JUST SET STATUS AS DIMED
	TST	2(R1)		;CHECK CURRENT 2ND DIM
	BNE	3$		;IF 2 DIM
	TST	PDIM2-FLAGS(R3)	;BEING DIMED AS 1D, HOW REF'D?
	BEQ	2$		;BOTH 1D
	BR	6$		;REPORT POSSIBLE ERROR

3$:	TST	PDIM2-FLAGS(R3)	;REF'D AS 2D ALSO?
	BNE	2$		;ALL IS WELL
6$:	ERROR	TLIDIM		;INCONSISTENT DIMENSIONS
2$:	BICB	#REFARY!DIMARY,(R3)	;CLEAR CURRENT STATUS
	BISB	#DIMARY,(R3)	;SET AS DIMED
	JSR	PC,TLCLCB	;CODE TO PUSHPOP AREA
	JSR	PC,UNSTCB	;IN PREPARATION FOR POSSIBLE ERRORS
	JSR	PC,ARYSET	;PREPARE ARRAY HEADER
SARAH4:	BR	SARAH5

;USE A TABLE TO COMPILE A BYTE ACCORDING TO TYPE OF TOKEN
SAOPT:	JSR	PC,SATYPE	;GET TYPE
SAOPT2:	CLR	-(SP)		;MAKE A PLACE TO WORK IN
	MOVB	(R5)+,(SP)
	DEC	(SP)
	ADD	R5,(SP)
	ADD	(R1)+,(SP)	;ADD IN TYPE
	MOVB	@(SP)+,-(R1)	;MOVE IT TO PUCOST ARG POSITION
	BR	SAOPT1

;COMPILE LEFT SIDE, I.E. STORE OPERATION
SACL:	MOV	R5,-(SP)	;PRESERVE PC
	JSR	PC,CFDEF	;COMPILE STUFF - NOTE RESULT TYPE SET
SACL01:	CLR	-(R1)		;SET UP FOR ONE LEFT SIDE
	MOV	COSP,R2		;PREPARE TO JUMP INTO INNARDS
	JSR	PC,TYCOL2	;OF TYPE COMPATIBILITY ROUTINE
	BR	SAOPNR		;CLEAN UP AND LEAVE

CCBDEF:	MOV	R5,-(SP)	;SAVE SPC
	JSR	PC,TLCLCB	;CLOSE CODE BLOCK
	BR	SARAH4		;RESTORE SPC

CFDEF2:	INC	2(R1)		;INCREMENT LEFT-SIDE COUNTER
CFDEF:	MOV	R5,-(SP)	;PRESERVE SPC
	JSR	PC,DOLETN	;COMPILE LEFT SIDE PURE AND SIMPLE
	BR	SARAH4		;RESTORE SPC

TCDEF:	MOV	R5,-(SP)	;SAVE SPC
	MOV	(R1)+,TLCOMR(R0)  ;BEST TO KNOW WHAT'S IN R1 HERE
	JSR	PC,TYCOMP	;ADJUST A PREVIOUSLY STORED LEFT SIDE
	BR	SARAH4		;RESTORE SPC

SACFA:	MOV	R5,-(SP)	;SAVE IPC
	JSR	PC,CFDEF	;COMPILE LEFT SIDE TYPE EXPRESSION
	MOV	(R1)+,TLCOMR(R0);SPECIAL KIND OF CONVERSION
	BR	SACL01

SARINT:	MOV	#SAOKCK,-(SP)	;SET O.K. CHECK RETURN ADDRESS
GUSINT:	BIC	#CONVFF+OUTEXF,STAT(R0)  ;TELL LA TO GET INTEGER
	JSR	PC,TLGTOK	;GET THE INTEGER
	BIS	#CONVFF+OUTEXF,STAT(R0)  ;UNTELL THE LA
	CMPB	TOKE(R0),#DINT	;INTEGER DATA TYPE?
	BNE	20$		;NOPE, EXIT WITH Z=0
	MOV	TOKA(R0),R2	;RELATIVE POINTER TO INTEGER
	CMP	R2,#LSTPDA	;IS THIS "ERL","ERR",ETC.?
	BLO	10$		;NOPE, SO ALL O.K.
5$:	ERROR	SASYNE,FATAL	;YES, SO FATAL ERROR

10$:	ADD	#2,NEXFRE(R0)	;RECOVER THE INTEGER DATA SPACE
	ADD	R0,R2		;ABS POINTER TO INTEGER
	MOV	(R2),-(R1)	;GET INTEGER ON STACK
	BMI	5$		;MUST BE NONNEGATIVE INTEGER
	SEZ			;EXIT WITH Z=1 FOR ALL O.K.
20$:	RTS	PC

;MATCH CONVENTIONS BETWEEN SA & TL W/R/T TOKEN POINTER
SACOMF:	INCB	PTOKF(R0)	;BACK TOKEN POINTER
	MOV	R5,-(SP)
	BIS	#CONVFF,STAT(R0)  ;SIGNAL LA TO GO FLOATING
	JMASK0	EQ,TOKE(R0),INTGF,SACMF1,B  ;UNLESS INTEGER ALREADY FOUND
	BIC	#CONVFF,STAT(R0)  ;IN WHICH CASE, GO INTEGER
SACMF1:	JSR	PC,TLCMF1	;GO GET AN EXPRESSION
SAOPNR:	JSR	PC,TLOPCB	;OPEN CODE BLOCK BACK UP
	BR	SARAH4

TLGLNS:	MOV	R5,-(SP)	;SAVE SAINT POINTER
	JSR	PC,TLGLN1	;INSIST IT BE A LINE NUMBER
	JSR	PC,GETAG	;GET CORRESP. (RELATIVE) HEADER PTR.
	SUB	SPTA,(R1)	;MAKE THIS A RELATIVE POINTER TO THE HEADER
	MOV	(SP)+,R5	;RESTORE SAINT POINTER
	RTS	PC		;EXIT

;CHANGE VERB
;EITHER FPCSV[X](S) OR PPCVS[X][S]
$SAINT	CHAN			;INITIALLY ENTER SYNTAX ANALYZER...
	RNSJ	DOCHA1		;SEE IF NEXT TOKE IS STRING
	CS			;YES COMPLIE IT
	T	TO		;DEMAND "TO"
	SHARF			;SET ARRAY FLAG FOR LA
	RXFJ	DOCHA2
	XI
DOCHA2:	CB	PPCSV		;CHANGE STRING TO VECTOR
	CT			;COMPILE MATRIX VARIABLE NAME
	R
	QUIT
DOCHA1:	X
	CB	PPCVS		;CHANGE VECTOR TO STRING
	CT			;MUST BE AN ARRAY
	RT	TO		;DEMAND "TO"
	RVS			;DEMAND STRING VARIABLE
	PBS	2		;SET TYPE AS "STRING"
	CFA			;COMPILE POP TO STRING VAR
	QUIT

;DIM VERB
;ARYSET DOES ACTUAL WORK
;STACK FOR ARYSET:
;R1	MAX STRING LENGTH
;	DIM2
;	DIM1
;	TYPE -- 0,1,2 = F,I,S
;	HEADER
;	CHANNEL -- 0 IF CORE
;	OFFSET
;	OFFSET
;ARYSET POPS ALL BUT CHANNEL AND OFFSET
	.EVEN
DODIM:	IFZERO	NE,TLLINO(R0),DODIM7	;BR IF NOT IMMEDIATE
	ERROR	NONOIM,FATAL	;NO DIMS IN IMMEDIATE
DODIM7:	JSR	PC,TLIDXH	;NEW HEADER
	MOVB	#1,(R4)+	;SET TYPE
	JSR	R5,SAINT	;USE THE SYNTAX ANALYZER INTERPRETER
	CB	PPNXTS		;SKIP OVER ARRAY HEADERS
	CB	PPNXTS		;COMPILE DUMMY BYTE TO GUARANTEE WORD BOUNDARIES
	P0			;START OFFSET AT 0
	P0			;2 WORDS OF OFFSET
	RNTJ	POUND,DODIM1	;DISK ARRAYS?
	RINTS			;YES, GET CHANNEL
	RT	COMMA		;DEMAND A COMMA AFTER CHN
DODIM6:	R
	B	DODIM2
DODIM1:	P0			;PUSH 0 - CORE ARRAY
DODIM2:	X			;MUST BE ARRAY NAME
	PT			;PUSH ARRAY HEADER
	PT			;MAKE A LIST OF THEM
	CW
	PTYPE			;PUSH THE TYPE

	RT	LPAR		;"("
	RINTS			;FIRST DIMENSION
	RNTJ	COMMA,DODIM3	;JUMP IF 1-D
	RINTS			;SECOND DIMENSION
	R
	B	DODIM4
DODIM3:	P0			;SAY SECOND DIM=0
DODIM4:	T	RPAR		;DEMAND CLOSING RT. PAREN
	RTJ	EQUALS,DODML1
	P0
	B	DODML2
DODML1:	RINTS			;MAX LENGTH OF ITEM
	R			;READ END OF LINE (HOPEFULLY)
DODML2:	ARYS			;SETUP ARRAY BLOCK
	TJ	COMMA,DODIM6	;MORE IN LIST
	TST1AI			;POP CHN
	TST1AI			;POP OFFSET
	TST1AI
	QUITN		;NO MODIFIERS ALLOWED FOR DIM STATEMENTS

;SARV IS A FAKE "RV"
SARV:	RVFJ	SARXR
	VIJ	SARXR
	VS
SARXR:	QUITS

$SAINT	READ			;INITIALLY ENTER SYNTAX ANALYZER...
DOREA1:	CALLS	SARV
	COPT	RDPOPT		;COMPILE APPROPRIATE RD P-POP OP
	CL			;LOCATION TO READ TO
	TJ	COMMA, DOREA1	;MORE TO DO IF COMMA
	QUIT			;HANDLE MODIFIERS AND INSTACH
RDPOPT:	.BYTE	PPREDF,PPREDI,PPREDS
;SUBR TO HANDLE # CONVENTION CHANNEL SPECIFICATION
SELECT:	RNTJ	POUND, DOPRI1	;IS CHN SPECIFIED?
	RCI			;YES, COMPILE NUM
	NTJ	COMMA,DOPRI2	;DEMAND COMMA
	R			;NEW TOKEN
	QUITS
DOPRI1:	CB	PPFIX0		;ASSUME CHN 0
DOPRI2:	QUITS

$SAINT	PRIN			;INITIALLY ENTER SYNTAX ANALYZER...
	CALLS	SELECT		;GET CHANNEL
	NTJ	RECORD,20$	;IF NOT "RECORD" THEN JUMP
	RCI			;COMPILE "RECORD" VALUE
	NTJ	COMMA,10$	;FOLLOWED BY COMMA?
	R			;YES, SO SKIP THE COMMA
10$:	CB	PPSSOR		;SELECT OUTPUT WITH RECORD
	B	30$

20$:	CB	PPSSON		;SELECT OUTPUT WITH NO RECORD
30$:	TJ	USING,DOPRTU	;BRANCH HERE IF PRINT USING
	EJ	DOPRI9		;PRINT CRLF GENERATES EMPTY LINE
	B	DOPR11		;NOW CHECK FOR DELIMITERS
DOPRI7:	REJ	DOPRI6		;GET NEXT TOKEN
DOPR11:	SF	1		;DELIMITER ENCOUNTERED FLAG
DOPR10:	NTJ	COMMA, DOPRI5
	CB	PPCOMA		;OP TO SKIP NEXT PRINT ZONE
	B	DOPRI7
DOPRI5:	TJ	SEMICO,DOPRI7	;SEMICOLONS ARE MEANINGLESS
	NDSJ	DOPR12		;IF DS, MUST HAVE HAD EITHER DS OR , OR ; BEFORE
	SF	1		;REMEMBER DELIMITED OK
	B	DOPR13		;AND COMPILE HAPPILY AWAY

DOPR12:	BFC	1,DOINP3	;IF NOT DS NOW & NO DELIM GIVE ERROR
	SF	0		;RESET TO "NO DELIMITER"
DOPR13:	CA			;MUST BE FORMULA
	COPR	PRPOPT		;COMPILE APPROPRIATE PRINT OP
	NEJ	DOPR10		;TO CATCH END WITHOUT COMMA
DOPRI9:	CB	PPCRLF		;TO GO TO NEXT FILE
DOPRI6:	QUIT
PRPOPT:	.BYTE	PPRINF,PPRINI,PPRINS

DOPRTU:	QUITD			;EXIT TO MACHINE CODE
	JMP	PU		;GO TO PRINT USING CODE

SELEC9:	B	SELECT

;INPUT VERB
$SAINT	INPT			;INITIALLY ENTER SYNTAX ANALYZER...
	CALLS	SELECT		;PUSH # NUMBER
	SF	0		;CLEAR FLAG BYTE
DOINP1:	VIJ	DOIN02		;IS IT A VARIABLE NAME?
	VFJ	DOIN02		;TOO BAD ABOUT THIS
	NVSJ	DOINP3		;WISH IT WERENT
DOIN02:	BFC	2,DOIN10	;IF NOTHING SELECTED
	BFC	1,DOIN11	;IF INPUT SELECTED
DOIN10:	CB	PPENDI		;THIS EMPTIES THE INPUT BUFFER AT RUN TIME
	CB	PPDI		;DUPLICATE INTEGER ON STACK
	CB	PPSSI		;SELECT INPUT PPOP
	SF	2		;INDICATE INPUT SELECTED
DOIN11:	COPT	INPOPT		;COMPILE APP OP CODE
	CL			;TO INPUT TO ITEM IN TABLE
	NEJ	DOINP7		;QUIT IF END
DOINP9:	CB	PPIJS		;GET RID OF CHANNEL
	QUIT
DOINP7:	TJ	SEMICO,DOIN15	;SEE IF A SEMI COLON
	NTJ	COMMA,DOINP1	;OTHERWISE MUST BE COMMA
DOIN15:	R			;GET NEXT TOKEN
	B	DOINP7		;LOOP UNTIL OUT OF COMMAS
DOINP3:	DS			;ONLY OTHER ALLOWED IS STRING CASE
	BFC	2,DOIN12	;IF NOTHING SELECTED
	BFS	1,DOIN13	;IF OUTPUT SELECTED
DOIN12:	CB	PPDI		;DUPLICATE INTEGER
	CB	PPSSON		;SELECT FOR OUTPUT
	SF	3		;REMEMBER THAT
DOIN13:	CB	PPUSHS		;COMPILE A PUSH OF
	CT			;THE STRING AND
	CB	PPRINS		;A PRINT STRING
	RTJ	SEMICO,DOINP8	;DEMAND SEMICOLON
	EJ	DOINP9
	TJ	COMMA,DOIN14	;COMPILE A TAB THING
	CB	PPCRLF		;NOTHING DEMANDS A CRLF
	B	DOINP7		;NOW SKIP ANY COMMAS
DOIN14:	CB	PPCOMA
DOINP8:	RNEJ	DOINP7		;BACK FOR MORE UNLESS END OF STATEMENT
	CB	PPCRLF
	B	DOINP9


INPOPT:	.BYTE	PPINPF,PPINPI,PPINPS	;INPUT FLOAT,FIXED,STRING

$SAINT	INPL			;INITIALLY ENTER SYNTAX ANALYZER...
	CALLS	SELEC9		;GET #<EXP>, CONSTRUCTION IF ANY
	CB	PPENDI		;FIRST CLEAR BUFFER
	CB	PPSSI		;THEN GET INPUT
	VS			;GET VARIABLE STRING
	CB	PPINPL		;INPUT LINE OP
	CL			;PLACE TO INPUT TO
	E			;DEMAND END OF LINE
DOCLO2:	QUIT
;CLOSE VERB
$SAINT	CLOS			;INITIALLY ENTER SYNTAX ANALYZER...
1$:	RNTJ	POUND,2$	;CHECK FOR OPTIONAL #
	R			;READ OVER THE #
2$:	CI			;COMPILE AN INTEGER
	CB	PPCLOS		;COMPILE CLOSE POP
	EJ	DOCLO2		;GET OUT IF END
	T	COMMA		;ELSE DEMAND A COMMA
	B	1$		;NOW LOOP

;OPEN VERB
$SAINT	OPEN			;INITIALLY ENTER SYNTAX ANALYZER...
	RCS			;GET FILE NAME
	NTJ	ASFILE,DOOPE2	;IS IT AS FILE?
	PBS	PPOPIO		;YES, BOTH
	B	DOOPE6

DOOPE2:	NTJ	FINASF,DOOPE3	;IS IT "FOR INPUT AS FILE"?
	PBS	PPOPIN		;OPEN FOR INPUT
	B	DOOPE6

DOOPE3:	T	FOUASF		;MUST BE "FOR OUTPUT AS FILE"
	PBS	PPOPOU
DOOPE6:	RNTJ	POUND,1$	;IS THERE A #?
	R			;YES, SO SKIP IT
1$:	CI			;CODE TO PUSH FILE #
	CALLS	SKPCOM		;SKIP OVER ANY COMMAS
	TJ	RCORSZ,DOOP10	; THEY ARE: RECORD SIZE, CLUSTER SIZE, AND MODE
	CB	PPFIX0		;NO RECORD SIZE SPECIFIED, SO USE 0
	B	DOOP14

DOOP10:	CALLS	RCICOM		;COMPILE INTEGER EXPR, SKIP COMMAS
DOOP14:	TJ	CLUSSZ,DOOP13	;IF CLUSTER SIZE SPECIFIED
	CB	PPFIX0		;OTHERWISE COMPILE 0
	B	DOOP15

DOOP13:	CALLS	RCICOM		;COMPILE INTEGER EXPR, SKIP COMMAS
DOOP15:	TJ	FILESZ,1$	;IS THERE A FILE SIZE SPECIFIED
	CB	PPFIX0		;OTHERWISE COMPILE 0
	B	2$		;AND CONTINUE

1$:	CALLS	RCICOM		;COMPILE INTEGER EXPR, SKIP COMMAS
2$:	TJ	MODE,DOOP11	;IS THERE A MODE SPECIFIED
	CB	PPFIX0		;DUMMY IN ZERO
	B	DOOP17

DOOP11:	CALLS	RCICOM		;COMPILE INTEGER EXPR, SKIP COMMAS
	CB	PPREAL		;NOW MAKE MODE VALUE REAL
DOOP17:	CBS			;PUT THE BYTE OUT AS CODE
	QUIT

RCICOM:	RCI		;COMPILE INTEGER EXPRESSION
SKPCOM:	NTJ	COMMA,SKPC01	;DONE IF NO MORE COMMAS
	R			;LOOK AT NEXT TOKEN
	B	SKPCOM		;SEE IF IT IS A COMMA
SKPC01:	QUITS			;ALL DONE

$SAINT	SLEP			;INITIALLY ENTER SYNTAX ANALYZER...
	RCI
	CB	PPSLEP
	QUIT

$SAINT	WAIT			;INITIALLY ENTER SYNTAX ANALYZER...
	RCI
	CB	PPWAIT
	QUIT

$SAINT	NAME			;INITIALLY ENTER SYNTAX ANALYZER...
	RCS			;COMPILE STRING
	T	AS		;DEMAND "AS"
	RCS			;COMPILE SECOND STRING
	CB	PPNAME
	QUIT

$SAINT	KILL			;INITIALLY ENTER SYNTAX ANALYZER...
	RCS			;COMPILE STRING EXPRESSION
	CB	PPKILL		;AND KILL POP
	QUIT

$SAINT	CHAI			;INITIALLY ENTER SYNTAX ANALYZER...
	RCS			;READ AND COMPILE A STRING
	EJ	DOCH01		;IF NO STARTING STATEMENT NUMBER
	QUITD			;BACK TO MACHINE CODE...
	CMPB	TOKE(R0),#DINT	;TOKEN = INTEGER DATA??
	BNE	10$		;NOPE
	CMP	TOKA(R0),#CURLIN ;YEP, IS IT REALLY "LINE" VARIABLE???
	BNE	10$		;NOPE
	JSR	PC,TLGTOK	;YEP, SKIP "LINE" INSIDE OF A CHAIN...
10$:	JSR	R5,SAINT	;BACK TO SAINT...
	CI			;COMPILE LINE AS AN INTEGER
	B	DOCH02
DOCH01:	CB	PPFIX0		;START AT ZERO IN THAT CASE
DOCH02:	CB	PPCHAI
	QUIT

;ON VERB -- THE SWITCH
$SAINT	ON			;INITIALLY ENTER SYNTAX ANALYZER...
	RCI			;COMPILE ME AN INTEGER
	TJ	GOTO,10$	;BR IF "GOTO"
	T	TGOSUB		;ELSE DEMAND "GOSUB"
	CB	PPONUB		;COMPILE ON GOSUB BYTE
	B	20$		;CONTINUE

10$:	CB	PPON		;COMPILE ON GOTO BYTE
20$:	SF	0		;START A BYTE COUNTER
30$:	R			;READ NEXT TOKEN
	GLNS			;MOVE A LINE NUMBER TO STACK
	ICF			; AND COUNT IT
	BFS	200,50$		;ERROR IF >=128.
	RTJ	COMMA,30$	;LOOP IF A COMMA
	QUITD			;ELSE BACK TO MACHINE
	CLR	-(R1)		;MOVE THE COUNT TO STACK
	MOVB	SAINTF(R0),(R1)	;AS A WORD
	ASL	(R1)		;TIMES 2
	NEGB	SAINTF(R0)	;MAKE FLAG A -(COUNT)
	JSR	R5,SAINT	;BACK TO SAINT
	CBS			;COMPILE THE COUNT*2 BYTE FROM STACK
40$:	CW			;COMPILE LINE # FROM STACK
	ICF			; AND COUNT IT
	BFS	377,40$		;MORE? LOOP IF SO
	QUIT			;ELSE DONE

50$:	QUITD
	ERROR	TLTMAF,FATAL	;>=128., TOO MANY ARGUMENTS...

.ENABL	LSB

$SAINT	RESU			;RESUME [LINE]
	CB	PPRESU
	B	10$

$SAINT	ONER			;ON ERROR GOTO [LINE]
	CB	PPONER
10$:	SF	0		;PRECLEAR THE SAINT FLAG
	QUITD			;BACK TO MACHING CODE
	JSR	PC,GUSINT	;TRY TO GET A POSITIVE INTEGER
	BEQ	20$		;WE GOT ONE
	CMPB	TOKE(R0),#200	;DID WE GET A LINE NUMBER INSTEAD?
	BEQ	30$		;YES, SO USE LINE NUMBER (FLAG=0)
	MOV	SP,-(R1)	;NO, FAKE A BAD INTEGER VALUE
20$:	COMB	SAINTF(R0)	;SET FLAG=377
	TST	(R1)+		;TEST THE INTEGER VALUE WE GOT
	BEQ	30$		;TRUELY A ZERO, LEAVE FLAG=377
	DECB	SAINTF(R0)	;NON-ZERO, SET FLAG=376
30$:	JSR	R5,SAINT	;BACK TO SAINT AGAIN
	BFC	2,50$		;REAL LINE NUMBER, USE IT
	P0			;ELSE PUSH 0 WORD ONTO STACK
	CW			;COMPILE WORD (THE 0) FROM STACK
	BFS	1,60$		;MUST READ NEXT TOKEN IF TRUELY A 0
	QUIT			;ELSE JUST QUIT

$SAINT	GOSB			;GOSUB LINE
	CB	PPUSHX
	B	40$

$SAINT	GOTO			;GOTO LINE
	CB	PPUJX
40$:	R			;SKIP GOSUB/GOTO
50$:	GLNS			;GET LINE NUMBER TO STACK
	CW			; AND COMPILE IT
60$:	R			;ADJUST TOKEN POINTER
	QUIT			; AND QUIT

	.EVEN
FINIF:	JSR	R5,SAINT	;GET INTO SAINT
	CB	PPUJX		;DO AN UNCONDITIONAL JUMP
	B	50$		; THEN A LINE NUMBER

.DSABL	LSB

.ENABL	LSB

$SAINT	REST			;RESTORE
	CB	PPREST
	B	10$

$SAINT	RAND			;RANDOMIZE
	CB	PPRAND
	B	10$

$SAINT	RETU			;RETURN
	CB	PPOPJ
	B	10$

$SAINT	STOP			;STOP
	CB	PPSTOP
10$:	R			;SKIP THE VERB
	QUIT			; AND QUIT

.DSABL	LSB

	.EVEN
	.END

