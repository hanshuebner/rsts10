TITLE	ODT,<OCTAL DEBUGGING TOOL>,0G,01-NOV-91,MJS/MHB/JDM/ABC/SJK/GPK/HS/KPH

;
;		COPYRIGHT (c) 1974, 1991 BY
;	DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
; COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY  OF ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

.SBTTL	EDIT HISTORY FOR ODT
;+
;
;  000  RRF  06-MAR-81	CREATION - COPIED FROM V7.0-07
;  001	TG   10-NOV-80	Moved CTRL/S,CTRL/Q support onto D:
;  002	HS   03-AUG-81	Start 'D' space additions
;  003  HS   04-AUG-81	Add all the bells and whistles
;  004  HS   05-AUG-81	Code tidy-up and commentary
;  005  HS   07-AUG-81	Add Trap catchers for T.4 and T.250
;  006  HS   08-AUG-81	Put in non MMU code for INIT.SYS use
;  007	GPK  28-Aug-81	Fix breakpoint setting code, disable $P
;
;			[RSTS/E V9.2]
;  008  KPH  17-Dec-85	Add FEK's MXV-11 support code
;
;			[RSTS/E V10.1]
;  009	FEK  07-Oct-91	Print APR6 values correctly
;-


; NOTES ON ODT PARAMETERS:
; 	ODT+0	JMP @(PC)+	ENTER HERE TO SET UP VECTORS, ETC.
;	ODT+2	 O.ODT
; 	ODT+4	O.CNST		[RETURN ADDRESS]
; 	ODT+6	O.BREK		[AT 14 PART OF VECTOR]
; 	ODT+10	O.STM		[AT 16 PART OF VECTOR]
; 	ODT+12	ODTBUF		[DISK I/O BUFFER]
; 	ODT+14	0		[HIGH PART OF SAME]
; 	ODT+16	RTTRTI		[ODT EXIT ADDRESS]
;	ODT+20	JMP @(PC)+	ENTER HERE WITH JSR PC FROM RSTS/E
;	ODT+22	 O.RSTS		[ENTRY FROM RSTS]

	DEFORG	ODT

ODT:	JMP	@(PC)+		;+0 - JMP TO O.ODT
	 .WORD	O.ODT		;+2 - ADDRESS OF O.ODT
	.WORD	O.CNST		;+4 - ADDRESS OF O.CNST
	.WORD	O.BREK		;+6 - @14 PART OF VECTOR
	.WORD	O.STM		;+10 - @16 PART OF VECTOR
	.WORD	ODTBUF		;+12 - DISK I/O BUFFER
	.WORD	0		;+14 - HIGH PART OF SAME
	.WORD	RTTRTI		;+16 - ODT EXIT
	JMP	@(PC)+		;+20 - RSTS ENTRY
	 .WORD	O.RSTS		;+22 - ADDRESS OF JSR ENTRY

; CONSOLE TERMINAL DEFINITION

TKS	=	177560

; LINE PRINTER DEVICE ADDRESSES FOR MEMORY LIST

LPS	=	177514	;LINE PRINTER STATUS
LPB	=	177516	;LINE PRINTER BUFFER

; DISK DEVICE ADDRESSES

DCS	=	177460	;RF DISK CONTROL STATUS
DAE	=	177470	;RF DISK ADDRESS EXTENSION ERROR
RKCS	=	177404	;RK DISK CONTROL STATUS
RKDA	=	177412	;RK DISK ADDRESS REGISTER
RPCS	=	176714	;RP DISK CONTROL STATUS
RPDA	=	176724	;RP DISK ADDRESS REGISTER

; DISK COMMAND PATTERNS

RKCFUN	=	000000	;CLEAR RK CONTROLLER
RPCFUN	=	000000	;CLEAR RP CONTROLLER
RFCFUN	=	000400	;CLEAR RF DEVICE

.SBTTL	USER STATE AREA AND DATA CONTROL

; SOME ODT TYPE DEFINITIONS (THESE ARE NOT PARAMETERS)

O.BKP	= 8.-1*2	;NUMBER OF BREAKPTS - 1 X 2
O.RLR	= 8.-1*2	;NUMBER OF CORE RELOC. REGISTERS - 1 X 2
O.TVEC	= 14		;BPT INSTRUCTION VECTOR
O.STM	= 7*40		;PRIORITY MASK, PRIORITY 7

; SET UP THE REAL THING FINALLY

ODTBUF:	.BLKW	400	;SET 256 WORD BUFFER
	.BLKW	20	;16 WORD STACK
ODTSTK:			;BASE OF STACK HERE


.SBTTL		Internal Registers and Tables

; THE ORDER OF THESE ITEMS IS INTENTIONAL, SEE REGISTER MAPPING SCHEME

; STARTING ADDRESS OF INTERNAL REGISTERS

INTBEG:

O.UR0:	0	;USER R0			$0
	0	;     R1			$1
	0	;     R2			$2
	0	;     R3			$3
	0	;     R4			$3
	0	;     R5			$5
O.USP:	0	;USER SP			$6
O.UPC:	0	;USER PC			$7
O.UST:	0	;USER ST			$S
O.PRI:	7	;ODT PRIORITY			$P
O.ARG:	0	;ARGUMENT REGISTER		$A
O.MSK:	-1	;MASK				$M
O.LOW:	0	;LOW LIMIT			$L
O.HI:	ODT	;HIGH LIMIT			$H
O.CNST:	O.EXIT	;CONSTANT REGISTER		$C
O.QUAN:	0	;QUANTITY REGISTER		$Q
O.BUFF:	ODTBUF	;DISK I/O BUFFER		$Z
O.FORM:	0	;FORMAT REGISTER		$F
O.PRNT:	0	;PRINT FORMAT REGISTER		$=


; STARTING ADDRESS OF INTERNAL TABLES

; TERMINAL OR CONSOLE ADDRESS VECTORS	($0T-$3T)

INTINX:

O.TKS:	.WORD	177560	;KEYBOARD STATUS REGISTER
O.TKB:	.WORD	177562	;KEYBOARD DATA BUFFER
O.TPS:	.WORD	177564	;PRINTER STATUS REGISTER
O.TPB:	.WORD	177566	;PRINTER DATA BUFFER
I.FILL:	.BYTE	0,0,0,0	;NULL FILL LIST

;	$nE value table
ETBINX:

O.APR6:	.WORD	0	;APR6 VALUE FOR MMU WORK	$0E
O.DPR6:	.WORD	0	; Rsts/e saved KDSAR6		$1E
O.ODR6:	.WORD	0	;ODT's APR6			$2E
O.PTA6:	.WORD	O.JUNK	;-> RSTS/E SAVED APR6		$3E
O.PTD6:	.WORD	O.JUNK	;-> Rsts/e saved D APR6		$4E
O.MSR3:	.WORD	0	; Saved MMUSR3			$5E
O.VEC:	.BLKW0	2*4	;Vector storage for T.4, T.250	$6E - $12E

;	$0-7V table

O.KIAR:	.BLKW0	8.	;Kernel I space address regs for mapper ($0V-$7V)
O.KIDR:	.BLKW0	8.	;KERNEL I SPACE DESCRIPTOR REGS ($10V-$17V)

;	$0-7W table

O.KDAR:	.BLKW0	8.	;Kernel D space address regs for mapper

;	$0-7X table

O.UIAR:	.BLKW0	8.	;User I space address regs for mapper

;	$0-7Y table

O.UMAR:	.BLKW0	8.	;Defineable mapper regs


; ACTION ROUTINE FOR EACH BREAKPOINT

O.BKAC:	.BLKW0	9.,-1		;ACTION # FOR BREAKPOINT N  ($0D-$10D)

; BREAKPOINT CONTROL LISTS

O.ADR1:	.BLKW0	9.,-1		;Virtual ADDRESS OF THE BREAKPOINT  ($0B-$7B)

O.CT:	.BLKW0	9.		;PROCEED COUNT   ($0G-$7G)

O.UIN:	.BLKW0	9.		;SAVED USER INSTRUCTION     ($0I-$7I)

; RELOCATION REGISTERS

; RELOCATION TABLES ($0R-$37R)

O.RELT::.BLKW0	8.*4,-1		;8 WORDS FOR CORE, RF DISK, RK DISK, RP DISK

; UNIT TABLES ($20U-$37U)

O.UNIT:	.BLKW0	8.*2		;8 WORDS FOR RK DISK, RP DISK

;
;


INTEND	= .-2			;END OF INTERNAL RESISTERS AND TABLES


; BREAKPOINT ADDRESS LISTS

O.ADRL:	.BLKW0	9.		;LOW 6 BITS OF BREAK ADDRESS
O.ADRM:	.BLKW0	9.		;HIGH 16 BITS OF BREAK ADDRESS

; ACTION ROUTINE STORAGE

O.ACTN:	.BLKW0	8.*16.		;ACTION ROUTINE STORAGE

.SBTTL	INTERNAL DIRTY DATA AREA

; WORDS AND ORDERED BYTES, ITEMS MUST BE KEPT FROM COMMAND TO COMMAND

O.CAD:	.WORD	0	;ADDRESS OF CURRENTLY OPEN REGISTER
O.DOT:	.WORD	0	;ADDRESS OF LAST EXPLICITLY OPENED CELL

O.CSR1:	.BYTE	0	;SAVED TERMINAL INPUT  CSR
O.CSR2:	.BYTE	0	;SAVED TERMINAL OUTPUT CSR

INP:	.BYTE	0	;CURRENT INPUT CHARACTER RING POINTER
OUP:	.BYTE	0	;CURRENT OUTPUT CHARACTER RING POINTER

O.BW:	.WORD	0	;OPEN CELL TYPE, 0=NONE, 1=BYTE, 2=WORD
D.ARGS:	.WORD	0	;SEMI-COLON PUSH WORD
O.DEVI:	.WORD	-1	;RELOCATION KEY, - IS CORE, + IS INDEX TO DISK
OLDBUF:	.WORD	-1	;CURRENT BUFFER IN USE
OLDSEG:	.WORD	-1	;CURRENT SEGMENT IN DISK BUFFER
OLDUNT:	.WORD	-1	;CURRENT UNIT OF SEGMENT IN DISK BUFFER

; THE FOLLOWING ITEMS NEED NOT BE KEPT FROM COMMAND TO COMMAND
; THEIR ORDER IS INTENTIONAL SO KNOW THY MAKER!

O.OP:	.BYTE	0	;CURRENT ARITHMETIC OPERATOR
	.ODD		;FIRST BYTE GOTTA BE AT ODDS
O.ALFA:	.BYTE	0	;AREA FOR RADIX 50 CONVERSION, 3 BYTES!
O.EXP:	.WORD	0	;EXPRESSION BUCKET, LAST 2 BYTES OF O.ALFA!
O.SMFD:	.BYTE	0	;SEMI-COLON COUNTER

; THE FOLLOWING ITEMS MUST BE KEPT FROM COMMAND TO COMMAND.

O.T:	.BYTE	0	; Step-over-BPT flag ( for Proceed )
O.P:	.BYTE	-1	;PROCEED ALLOW FLAG
O.S:	.BYTE	0	;SINGLE INSTRUCTION MODE, 0=NORMAL, -1=ENABLE

O.FM:	.BYTE	2	;OUTPUT FORMAT MODE, BYTE, WORD, ANSII, RAD50
O.OBW:	.BYTE	2	;OPEN CELL TYPE, 1=BYTE, 2=WORD
O.SEQ:	.BYTE	0	;CHANGE SEQUENCE INDICATIOR
	.EVEN

; THE FOLLOWING ITEMS ARE IN NO PARTICULAR ORDER

O.APR5:	.WORD	1200	;SAVED APR5 VALUE DURING CORE EXAMINE
O.WND5:	.WORD	1200	;APR5 VALUE USED TO WINDOW CORE EXAMINE

O.XOFF:	.WORD	0	;NON-0 IF X-OFF RECEIVED

; THE FOLLOWING MUST BE IN ORDER (MMU control table)

O.KIA6:	.WORD	O.JUNK	;ADDRESS OF APR6 IF MMU ACTIVE
O.KIA5:	.WORD	O.JUNK	;ADDRESS OF APR5 IF MMU ACTIVE
O.OF56:	.WORD	0	;FACTOR TO SUBTRACT IF MMU ACTIVE
O.KDA6:	.WORD	O.JUNK	;Address of KDSAR6 if MMU active
;	**** down to here

O.JUNK:	.WORD	0	;BIT BUCKET FOR MOVES @O.KIA? IF NO MMU
O.MMAP:	.WORD	140000,160000-1 ;ADDRESS RANGE WHICH GETS MAPPED
O.MAPF:	.WORD	0	;FLAG <>0 IF NOT TO MAP FOR ODT

O.DSP:	.WORD	0	; <>0 if we have D space caps

; Mapper control vars and tables

O.MAPM:	.WORD	10	; Current mapper mode : default K


;+
;	This table gives the base addresses of the storage
;	regions for the various APR's
;-

MAPM:	+	O.KIAR		; Mode I
	+	O.KDAR		; Mode D
	+	O.UIAR		; Mode U
	+	O.UMAR		; Mode X
	+	O.KIAR		; Mode K alias mode I

;+
;	This is the Prompt table
;-

MAPC:	.BYTE	'I
	.BYTE	'D
	.BYTE	'U
	.BYTE	'X
	.BYTE	'K
	.BYTE	000	;Null character for non-MMU
	.EVEN
;



; RING BUFFER SIZE DEFINITIONS

RINGSZ	=	20	;RING BUFFER SIZE, MUST BE EVEN POWER OF TWO
ROSIE	=	-RINGSZ	;RING AROUND ROSIE MASK

RING:	.BLKW0	RINGSZ/2 ;YE RING BUFFER

; ACTION ROUTINE TERMINAL INPUT POINTER

O.GETP:	.WORD	0	;-> NEXT CHARACTER TO READ

.SBTTL	INTERNAL REGISTER NAME AND CONTROL TABLES

; NON-INDEXED REGISTER NAMES

NIXMAP:	.ASCII	/01234567/	;USER REGISTER NAMES FOR MAPPING

NIXREG:	.BYTE	'S		;O.UST	USER STATUS
	.BYTE	'P		;O.PRI	ODT RUNNING PRIORITY
	.BYTE	'A		;O.ARG	ARGUMENT
	.BYTE	'M		;O.MSK	MASK REGISTER
	.BYTE	'L		;O.LOW	LOW SCAN LIMIT
	.BYTE	'H		;O.HI	HIGH SCAN LIMIT
	.BYTE	'C		;O.CNST	CONSTANT
	.BYTE	'Q		;O.QUAN	QUANTITY
	.BYTE	'Z		;O.BUFF	DISK I/O BUFFER
	.BYTE	'F		;O.FORM	FORMAT CONTROL
	.BYTE	'=		;O.PRNT	PRINT FORMAT CONTROL

	.BYTE	00		;END OF THIS LIST

; INDEXED REGISTER NAMES

INXREG:	.BYTE	'T		;O.TKS	CONSOLE DEVICE ADDRESSES
	.BYTE	'E		;O.APR6	Internal values table
	.BYTE	'V		;O.KIAR	Kernel I space APRs
	.BYTE	'W		;O.KDAR	Kernel D space APRs
	.BYTE	'X		;O.UIAR	User I space APRs
	.BYTE	'Y		;O.UMAR	Definable mapper APRs
	.BYTE	'D		;O.BKAC	BREAKPOINT ACTIONS
	.BYTE	'B		;O.ADR1	BKPT ADDRESSES
	.BYTE	'G		;O.CT	BKPT PROCEED COUNTS
	.BYTE	'I		;O.UIN	BKPT USER INSTRUCTIONS
	.BYTE	'R		;O.RELT	RELOCATION REGISTERS
	.BYTE	377		;DUMMY FOR UNIT ADDRESS TYPE-OUT
	.BYTE	'U		;O.UNIT	UNIT REGISTERS

	.BYTE	00		;END OF THIS LIST

;+
;	Register names available for use
; J K N O and punctuation characters

; INDEXED REGISTER TABLE BASES

	.EVEN
INXTBL:	.WORD	O.TKS		;CONSOLE DEVICE ADDRESSES
	.WORD	ETBINX		;Internal regs
	.WORD	O.KIAR		;Kernel I space
	.WORD	O.KDAR		;Kernel D space
	.WORD	O.UIAR		;User I space
	.WORD	O.UMAR		;Defineable mapper
	.WORD	O.BKAC		;BKPT ACTION #'S
	.WORD	O.ADR1		;BKPT ADDRESS TABLE
	.WORD	O.CT		;BKPT PROCEED COUNTS
	.WORD	O.UIN		;BKPT'D INSTRUCTION
	.WORD	O.RELT		;RELOCATION TABLES
	.WORD	O.UNIT		;ENTRY FOR ADDRESS MAPPING
	.WORD	O.UNIT-20-20	;UNIT TABLE
	.WORD	INTEND+2	;END OF TABLE AREA FOR ADDRESS MAPPING

; CHARACTER CONVERSION LISTS.

ALTTAB:	.BYTE	033,175,176	;ALTERNATE ALT-MODE FORMS

	.BYTE	000		;END OF THIS LIST TOO

MAPTAB:	.BYTE	'I,'D,'U,'X,'K	;M command args list

	.BYTE	000		;End of list


.SBTTL	COMMAND NAME AND DISPATCH TABLES

COMTAB:		;ADDRESS OF THE CHARACTER TABLE

; OPEN REGISTER COMMANDS (ORDER AND POSITION CRITICAL)

	.BYTE	'\,'/,'','",'%

; CLOSE REGISTER COMMANDS

	.BYTE	015,012,'^,'_,'@,'>,'<

; SPECIAL FORMS

	.BYTE	'$,'=,'C,'Q,'.

; OPERATORS (ORDER OF -+* IS CRITCAL)

	.BYTE	';,'-,'+,'*,',,'!,'&

; COMMANDS

	.ASCII	/()[]ABDEFGKLMNOPRSTW/

	.BYTE	00	;******* END OF THE LIST *******

	.EVEN	;THIS CAN HAPPEN TO YOU!!!!
;+
;	Available commands
; C H I J Q U V X Y Z
;-

; THE DISPATCH TABLE, ORDERED ON ABOVE TABLE

; OPEN REGISTER COMMANDS

COMDIS:	+	OCBYTE	;\	OPEN OCTAL BYTE
	+	OCWORD	;/	OPEN OCTAL WORD
	+	ANBYTE	;'	OPEN ANSII BYTE
	+	ANWORD	;"	OPEN ANSII WORD
	+	MODULO	;%	OPEN RADIX 50 WORD

; CLOSE REGISTER COMMANDS

	+	CLCRET	;<CR>	CLOSE, NO SUCESSIVE OPEN
	+	CLLNFD	;<LF>	CLOSE, OPEN NEXT
	+	CLUPAR	;^	CLOSE, OPEN PREVIOUS
	+	CLBACK	;_	CLOSE, OPEN PC RELATIVE MODE
	+	CLATSG	;@	CLOSE, OPEN INDIRECT
	+	CLGRTH	;>	CLOSE, OPEN PC OFFSET AS BRANCH
	+	CLLSTH	;<	CLOSE, OPEN OLD SEQUENCE

; SPECIAL FORMS

	+	O.REGT	;$	INTERNAL REGISTER REFERENCE
	+	EQUALS	;=	PRINT LEFT SIDE IN OCTAL
	+	CHRCEE	;C	CONSTANT REGISTER CONTENTS
	+	CHRQUE	;Q	QUANTITY REGISTER CONTENTS
	+	CHRDOT	;.	LAST OPENED LOCATION'S ADDRESS

; OPERATORS

	+	O.SEMI	;;	MULTIPLE ARGUMENT DELIMITER
	+	O.MINS	;-	SUBTRACTION
	+	O.PLUS	;+	ADDITION
	+	O.STAR	;*	MULTIPLY BY 50
	+	O.COMM	;,	RELOCATION COMPUTE
	+	O.EXCL	;!	SHIFT
	+	O.AMPR	;&	AND

; COMMANDS

	+	O.LPAR	;(	SET AN ACTION
	+	O.RPAR	;)	TYPE AN ACTION
	+	O.COND	;[	START OF CONDITIONAL
	+	O.DCD	;]	END OF CONDITIONAL
	+	O.DOAC	;A	DO AN ACTION
	+	O.SEBK	;B	SET / CLEAR BREAKPOINTS
	+	O.SEBA	;D	SET ACTION FOR A BREAKPOINT
	+	O.EFFA	;E	EFFECTIVE ADDRESS SEARCH
	+	O.FILL	;F	MEMORY FILL
	+	O.GOTO	;G	GO TO USER'S DATA
	+	O.KILO	;K	KOMPUTE AND TYPE RELOCATION DATA
	+	O.LIST	;L	LIST MEMORY ON SPECIFIED DEVICE
	+	O.MAPR	;M	Change the mapper mode ( I, D, or U space)
	+	O.NOTW	;N	NOT WORD SEARCH
	+	O.OFST	;O	TYPE PC RELATIVE OFFSETS
	+	O.PROC	;P	PROCEED FROM BREAKPOINT
	+	O.RELO	;R	SET / RESET RELOCATION REGISTERS
	+	O.SNGL	;S	SET / RESET SINGLE STEP MODE
	+	O.TTYS	;T	ALTER CONSOLE TTY ASSIGNMENT
	+	O.WSCH	;W	MEMORY WORD SEARCH

.SBTTL	SPECIAL INPUT MODES

INPMOD:	.BYTE	'%	;INPUT RAD50 WORD
	.BYTE	''	;INPUT SINGLE ASCII CHARACTER
	.BYTE	'"	;INPUT 2 ASCII CHARACTERS
	.BYTE	'.	;INPUT DECIMAL NUMBER
	.BYTE	'#	;INPUT OCTAL NUMBER

	.BYTE	00	;END OF LIST

INPUTS:	.WORD	INPRAD	;$%XXX	RAD50 INPUT
	.WORD	INPBYT	;$'X	SINGLE CHARACTER
	.WORD	INPASC	;$"XX	TWO CHARACTERS
	.WORD	INPDEC	;$.NNNNN DECIMAL NUMBER
	.WORD	INPOCT	;$#NNNNN OCTAL NUMBER

.SBTTL	MAJOR ENTRY AND RE-ENTRY POINTS

; INITIALIZE ODT
;  USE O.ODT FOR A NORMAL ENTRY, COMPLETE CLEAN RE-START
;  USE O.ODT+2 TO RE-ENTER (I.E. - FAKE A BREAKPOINT)

.ODTKB::.WORD	TKS		;DEFAULT TTY CSR (GLOBALIZED FOR PATCHING)
O.I.TK:	.WORD	-1		;ZERO IF 1ST TTY RESTORE DONE

O.EXIT:				;EXIT ADDRESS IF ENTRY AT O.ENTR
O.ODT::	BR	O.STRT		;NORMAL ENTRY

; RE-ENTER AS IF BREAKPOINT, BAD ONE AT THAT

O.ENTR:	MOV	@#PS,-(SP)	;SET PS AS IF INTERRUPT
	MOV	#O.ENTR-2,-(SP)	;SET PC, IT GETS BUMPED BY 2 ON BE'S
	MOVB	ODT+10,@#PS	;;;SET UP OPERATING PRIORITY
	CLRB	O.S		;;;FAST EXECUTION MOOD
	JMP	O.BREK		;;;IT IS A BREAK, RUN LIKE HELL

; START ODT FROM SCRATCH, CLEAN SLATE

.ENABL	LSB

O.STRT:	MOVB	ODT+10,@#PS	;;;SET RUNNING LEVEL
	MOV	ODT+10,O.UST	;;;SAME LEVEL FOR USER RETURN
	MOV	O.CNST,O.UPC	;;;AND A PC
	MOV	R0,O.UR0	;;;SAVE USER'S R0
	MOV	#10$,R0		;;;AND SET UP A RETURN ADDRESS
	JMP	O.SVR0		;;;NOW SAVE REGISTERS

10$:	CALL	O.SVTT		;;;SAVE TTY STATUS
	MOV	.ODTKB,R4	;;;RESET CONSOLE TTY FOR FATAL
	CALL	SETTTY		;;;ERRORS
	CLR	O.I.TK		;;;SAY WE DID IT
	CALL	SETMMU		;;;SET UP THE MMU
	CALL	VEC.SV		;;;Save the critical vectors
	CALL	O.RUAL		;;;RESET RELOC AND UNIT
	CLRB	O.S		;;;DISABLE SINGLE INSTRUCTION FOR NOW
	CLR	INP		;;;INIT TYPE-AHEAD RING BUFFER
	CLR	O.GETP		;;;NO INDIRECT POINTER
	MOVB	#-1,O.P		;;;DISALLOW PROCEED

	MOV	#RTT,RTTRTI	;;;DO PDP-11/20 PDP-11/40/45 CHECKING
	MOV	#10,R0		;;;R0 -> VECTOR AT 10
	MOV	(R0),R3		;;;TEMP SAVE OF @10
	MOV	#20$,(R0)+	;;;SET TO SKIP IF BELOW IS FATAL
	MOV	(R0),R4		;;;TEMP SAVE OF @12
	MOV	ODT+10,(R0)	;;;PRIORITY TO SKIP INTO
	MOV	(R0),-(SP)	;;;SET A DUMMY PS AND
	MOV	#30$,-(SP)	;;; DUMMY PC
RTTRTI:	RTT			;;;NOW DO IT

20$:	MOV	#RTI,RTTRTI	;;;CHANGE MIND
;
; Set-up the BPT (14) vector
;
30$:	MOV	(R0),@#O.TVEC+2	;;;SET PS PART OF VECTOR
	MOV	#O.BREK,@#O.TVEC ;;;SET PC PART OF VECTOR
	MOV	R4,(R0)		;;;RESTORE @12
	MOV	R3,-(R0)	;;;RESTORE @10

	JMP	O.RALL		;;;CLEAR BRK PT TABLES GOT TO DECODER

.DSABL	LSB

.SBTTL	$ (OR ALT MODE) PROCESSOR - INTERNAL REGISTER MAPPER

; SYNTAX--
; $L		DELIVER INTERNAL ADDRESS OF L
; $NL		DELIVER INTERNAL ADDRESS OF L+2N
; $N		DELIVER INTERNAL ADDRESS OF USER REGISTER N
; $XYYY		TRANSLATE SPECIAL FORM OF TYPE X

; SEE MAPPING TABLES, RANGE OF N IS 0-37

O.REGT:	CALL	GETNUM		;GET AN OCTAL NUMBER
	CALL	O.RTST		;CHECK FOR valid reg, and R4 <- R4 * 2
	BCS	O.ERR0		;Didn't check out OK
	MOV	SP,O.MAPF	;DO NOT MAP THIS REFERENCE
	TST	R2		;SEE IF ANYTHING TYPED
	BNE	20$		;IF SO IS INDEXED OR USER REGISTER
	CALL	LOOKUP,R5,<NIXREG> ;SEE IF NON-INDEXED
	BCC	10$		;IT IS INDEED NON-INDEXED
	CALL	LOOKUP,R5,<INPMOD> ;IS IT SPECIAL INPUT MODE?
	BCS	O.ERR0		;NO, IT'S AN ERROR
	CLR	O.MAPF		;SORRY, WE DID WANT TO MAP IT
	CALL	@INPUTS(R1)	;YES, GET A SPECIAL FORM OF INPUT
	BCC	MKGTGO		;C=0 MEANS WE NEED TO GET A CHARACTER
	BR	MKGO		;ELSE R0 HAS DISPATCH CHARACTER

10$:	MOV	R1,R4		;PLACE IN LIST IS INTERNAL ORDER
	ADD	#O.UST,R4	;GET ADDRESS IN R4, GOTTA READ CHAR
	BR	MKGTGO		;MARK R2 REAL, GET ANOTHER CHAR, GO DO IT

20$:	CALL	LOOKUP,R5,<INXREG> ;SEE IF INDEXED
	BCC	40$		;WAS TRULY INDEXED
	CMP	#7*2,R4		;INTERNAL USER REGISTER RANGE CHECK
	BLO	O.ERR0
	ADD	#O.UR0,R4	;SET ACCESS TO R0-R7 OF THE USER
	BR	MKGO		;MARK R2 REAL, DISPATCH ON CHAR IN R0

40$:	ADD	INXTBL(R1),R4	;COMPUTE ADDRESS TO INDEXED TABLE
	BR	MKGTGO		;MARK R2 REAL, GET ANOTHER CHARACTER, GO ON IT

.SBTTL	Q PROCESSOR - GET VALUE OF QUANTITY REGISTER

; MERELY SUBSTITUTE THE VALUE IN R4 WITH THE CONTENTS OF THE SPECIFIED
; REGISTER.

CHRQUE:	MOV	O.QUAN,R4	;LAST QUANTITY PRINTED
	CLR	O.MAPF		;TURN ON MMU MAPPING AGAIN
	BR	MKGTGO

.SBTTL	C PROCESSOR - GET VALUE OF CONSTANT REGISTER

CHRCEE:	MOV	O.CNST,R4	;CONSTANT REGISTER
	BR	MKGTGO

.SBTTL	. PROCESSOR - GET CURRENT ADDRESS VALUE

CHRDOT:	MOV	O.CAD,R4	;CURRENT LOCATION
MKGTGO:	CALL	O.GET		;GET NEXT CHARACTER, ASSUME IT'S A TERMINATOR
MKGO:	INC	R2		;ALLOW AS R4 IS REAL
	JMP	O.CLGL		;PROCESS CHARACTER IN R0 AS TERMINATOR

.SBTTL	T PROCESSOR - ALTER CONDOLE TTY ASSIGNMENT

; SYNTAX--
; AT			SET UP CONTROL REGISTERS BEGINNING AT "A"
; T			RESET REGISTERS STARTING AT 177560

O.TTYS:	CALL	O.RSTT		;RESTORE OLD STATUS
	TST	R2		;SEE WHO
	BNE	10$		;THEM!!
	MOV	.ODTKB,R4	;STATUS BACK BABY
10$:	CALL	SETTTY		;SET THE CONSOLE VECTORS
	CALL	O.SVTT		;SAVE NEW ASSUMED DEVICE STATUS
	CLR	INP		;RESET TYPE-AHEAD
	CLR	O.GETP		;NO INDIRECT POINTER
	JMP	O.DCD

.SBTTL	B PROCESSOR - SET/REMOVE BREAKPOINTS

; SYNTAX--
; B			CLEAR ALL BREAKPOINTS
; NB			CLEAR BKPT N
; A;B			SET BKPT AT A, USE FIRST FREE  BKPT
; A;NB			SET BKPT N AT A

O.SEBK:	ASL	R4		;MPY R4 X2, JUST IN CASE ALL IS GO
	MOV	#-1,R0		;SET MAGIC VALUE IN R0, JUST IN CASE
	TST	R3		;CHECK FOR THE REAL CASE
	BEQ	O.REMB		;REMOVAL CASES, CLEAR THEM UP
	BIT	#1,R5		;LOOK AT ADDRESS
	BNE	O.ERR		;THAT'S ODD ?
	CMP	O.MAPM,#2*2	;CURRENT USING USER MODE MAPPING?
	BEQ	O.ERR		;YES, SETTING BREAKS THERE IS SENSELESS
	TST	R2		;SEE IF I GET TO PICK IT OR NOT
	BNE	20$		;OR NOT, DISAPPOINTMENT
10$:	CMP	R0,O.ADR1(R4)	;LOOK FOR LOCATION WITH FREE ADDRESS
	BEQ	20$		;A HIT
	TST	(R4)+		;KEEP AT FOR A LONG WHILE
	BR	10$		;LOOOOOOOOP

20$:	MOV	R5,R0		;R0 HAS ADDRESS OF BREAKPOINT
	CALL	SETBRK		;PUT THE BREAKPOINT IN THE TABLE
	BCS	O.ERR0		;WHOOPS!!!
	MOV	R0,O.ADRL-2(R4)	;SAVE THE ADDRESS

	TST	O.OF56		;IS THE MMU ON?
	BEQ	O.DCD		;NOT THIS TIME...

;
; Set-up MMU data for breakpoint
;
	BIC	#^C<77>,O.ADRL-2(R4) ;TRIM ADDRESS TO 6 BITS
	BIS	#120000,O.ADRL-2(R4) ; AND MAKE FOR KISAR5
	;CLC			;C=0 FROM 'TST' ABOVE
	ROR	R0		;SHIFT
	ASR	R0		; ADDRESS
	ASR	R0		;  RIGHT
	ASR	R0		;   5
	ASR	R0		;    PLACES
	MOV	R0,R1		;COPY IT
	ASR	R1		;NOW FIND
	BIC	#^C<177>,R1	; THE NEXT 7 BITS / 100
	CLRB	R0		;PUT TOP 3 BITS
	SWAB	R0		; INTO
	ASL	R0		;  <3-1>
	MOV	R0,-(SP)	;SAVE THAT APR NUMBER
	MOV	O.MAPM,R0	;GET CURRENT MAPPING INDEX
	ADD	MAPM(R0),(SP)	;FORM ADDRESS OF "FAKE" APR ON STACK
	ADD	@(SP)+,R1	;COMPUTE THE BREAK'S HIGH 16 BITS
	MOV	R1,O.ADRM-2(R4)	;SAVE HIGH 16 BITS OF BREAK ADDRESS

	BR	O.DCD		;GO DECODE SOMETHING ELSE

; REMOVE SOME BREAKPOINTS

O.REMB:	TST	R2		;SEE IF ONE OR ALL
	BEQ	O.RALL		;ALL
	CALL	SETBRK		;SET THE ONE SET UP TO SET
	BCC	O.DCD		;IT HAPPENED

O.ERR0:	BR	O.ERR		;SOME THING WENT WRONG

;REMOVE ALL BREAKPOINTS  (N.B. CALLED BY THE INIT CODE)

O.RALL:	MOV	#-1,R0		;MAGIC IN R0
	CLR	R4		;R4 IS ZERO
10$:	CALL	SETBRK		;SET THEM TILL
	BCC	10$		;THEY GET OUTTA

	BR	O.DCD		;HAND!!!!

.SBTTL	R PROCESSOR - SET/CLEAR RELOCATION REGISTERS

.ENABL	LSB

O.RELO:	TSTB	O.SMFD		;SEMI-COLON ABSENT MEANS CLEAR
	BEQ	10$		;CLEAR DISPATCH, OR FALL TO SETTING

; FORMS HERE--
;  A;NR			SET RELOC(N) TO A
;  U;A;NR		SET RELOC(N) TO A, SET UNIT(N) TO U
; ABSENT A OR N DEFAULTS TO 0, NO U DOES NOT RESET.

	CALL	O.RTST		;PROTECTION EDITING
	BCS	O.ERR		;ILLEGAL REGISTER NUMBER ?
	MOV	R5,O.RELT(R4)	;SET THE APPROPRIATE REGISTER
	CMP	#20*2,R4	;SEE IF UNIT IS VALID
	BHI	O.DCD		;IF NOT THEN BOTHER NOT
	CMPB	#2,O.SMFD	;SEE IF UNIT IS TO BE CHANGED
	BNE	O.DCD		;IF NOT BOTHER NOT
	MOV	D.ARGS,O.UNIT-20-20(R4)	;SET UNIT REGISTER
	BR	O.DCD		;GO DO NEXT COMMAND

; FORMS HERE--
;  R			RESET ALL TO -1 FOR RELOC(0-37) AND 0 FOR UNITS
;  NR			RESET ONLY RELOC(N) AND UNIT(N)

10$:	TST	R2		;SEE IF NR OR JUST R
	BEQ	20$		;CLEAR ALL
	CALL	O.RUCL		;CLEAR THE ONE IN R4
	BCS	O.ERR		;ERROR, INVALID REGISTER ?
	BR	O.DCD		;NEXT COMMAND

20$:	CALL	O.RUAL		;DO THEM ALL
	BR	O.DCD		;OFF AND ON

.DSABL	LSB

.SBTTL	K PROCESSOR - COMPUTE AND PRINT RELOCATION

; SYNTAX--
;  AK				TYPE RELOCATION DEAL FROM DOT TO A
;  L;AK				TYPE RELOCATION DEAL FROM L TO A

; IF A IS NULL THE THE OLD BEST FIT RULE APPLIES
; TYPES	=N,DDDDDD	WHERE N IS THE RELOCATION REGISTER
;				AND D-D IS THE RELOCATION BIAS

O.KILO:	TST	R2		;SEE WHO PICKS THE REGISTER
	BNE	10$
	MOV	R5,R4
	CALL	O.LOCA		;WE PICK IT
	BMI	O.ERR		;CAN'T FIND ONE THATS GOOD
	MOV	R0,R4		;R4 HAS OUR PICK
10$:	BIC	#177770,R4	;EDIT REGISTER
	CALL	O.TYPC,R5,<" =>	;TYPE CONSTANT PROMPTING STRING
	MOVB	R4,R0		;TYPE REGISTER & A ,
	CALL	O.TYPA,R5,<"0,>	;ADD ASCII DIGIT AND COMMA, TYPE IT
	ASL	R4		;GO GET IT AS TABLE INDEX
	TST	R3		;SEE WHO TYPED THE ADDRESS
	BNE	20$
	MOV	O.CAD,R5	;THAT CAD!
20$:	SUB	O.RELT(R4),R5
	MOV	R5,R0		;BIAS COMPUTE
	CALL	O.CADW		;PRINT AS WORD
	BR	O.DCD

.SBTTL	COMMAND DE-CODER AND MAIN LOOP OF ODT

;  ALL REGISTERS MAY BE USED (R0-R5)

; ERROR ENTRY, TYPE FLAG AND GO DO COMMAND

O.ERR:	CLR	INP		;RESET TYPE-AHEAD
	CLR	O.GETP		;NO INDIRECT POINTER
	CALL	SETCON		;SET CONSOLE VECTORS DUE TO "L"
	CALL	O.TYPC,R5,<" ?>	;TYPE SPACE AND QUESTION MARK

; DECODE FROM THE TOP, CLOSE ALL AND DO CR/LF/_

O.DCD:	CALL	SETCON		;RESET CONSOLE VECTORS DUE TO "L"
	MOV	#ODTSTK,SP	;SET THE STACK FOR SANITY
	CLR	O.BW		;CLOSE ALL
	MOV	#-1,O.DEVI	;CLOSE THE DISK TOO
	CLR	O.MAPF		;TURN ON MMU MAPPING
	CALL	O.CRLF		;TYPE  <CR><LF>

	MOV	O.MAPM,R0	;Get current mode
	ASR	R0		;Turn into byte offset
	MOVB	MAPC(R0),R0	;Get prompt character

	CALL	O.FTYP		;Print prompt
	CALL	O.TYPC,R5,<'_>	;TYPE AN UNDERSCORE

; MAINTAIN OPENED LOCATION, RE-INIT INPUT

O.NEWC:	CLRB	O.SMFD		;CLEAR SEMI-COLON FLAG/COUNT
	CLR	R3		;ZERO SECONDARY ARGUMENT FLAG
	CLR	R5		;AND ARGUMENT

; NEW SUB-EXPRESSION ENTRY

O.NEWE:	CLRB	O.OP		;CLEAR OPERATOR FOUND
	CLR	O.EXP		;SET ZERO IN EXPRESSION SO FAR LOCATION

; GET NUMBER AND THEN SCAN FOR COMMAND

O.NEWN:	CALL	GETNUM		;GET AN OCTAL NUMBER AND TERMINATOR

; NON-OCTAL CHAR TYPED WHAT ARE WE TO DO?

O.CLGL:	CALL	LOOKUP,R5,<COMTAB> ;GO SEE IF IT IS REAL
	BCS	O.ERR		;EASY ENOUGH IF NOT REAL
	TST	R2		;IF NOTHING TYPE BOTHER NOT
	BEQ	10$		;WITH THE EXPRESSION
	CALL	EXPCOM		;COMPUTE EXPRESSION
10$:	JMP	@COMDIS(R1)	;GO TO PROPER ROUTINE

; FOR THE BENEFIT ALL REGISTERS ARE AS FOLLOWS

; R0	LAST CHARACTER TYPED, THE COMMAND ITSELF!
; R1	TABLE INDEX TO COMMAND ADDRESSES, IT IS USED.
; R2,R4	FIRST ARGUMENT, IF R2<>0 THEN R4 IS DATA
; R3,R5	SECOND ARGUMENT, IF R3<>0 THEN R5 IS DATA

.ENABL	LSB

.SBTTL	; PROCESSOR - SEPARATE MULTIPLE ARGUMENTS

O.SEMI:	INCB	O.SMFD		;COUNT SEMI-COLON
	CMPB	#2,O.SMFD	;PUSH CONTENTS INTO MULTI
	BNE	10$		;SEMI COLON ARG LIST
	MOV	R5,D.ARGS
10$:	MOV	R2,R3		;PUSH R2 AND R4 INTO
	MOV	R4,R5		;R3 AND R5 (FLAG AND CONTENTS)
	BR	O.NEWE		;CONTINUE SCANNER

.SBTTL	, PROCESSOR - DO RELOCATION

O.COMM:	CMP	R4,#O.UNIT-O.RELT/2 ;ENSURE THAT IT IS VALID
	BHIS	O.ERR		;NOT A GOOD RELOCATION REG NUMBER
	ASL	R4		;ALL NEED IT X 2
	SUB	#10*2,R4	;SET TO MINUS FOR CORE
	BPL	O.COMD		;GO DO DISK
	MOV	O.RELT+<10*2>(R4),O.EXP ;COMPUTE REAL CORE ADDRESS
	BR	O.PLUS		;Set up an addition for the relocation

; DISK RELOCATION

O.COMD:	MOV	R4,O.DEVI	;JUST FLAG IT FOR LATER
	CLR	O.EXP		;RESET EXPRESSION TO PREVENT CONFUSION
	;BR	O.PLUS		;ADD CAN HAPPEN AND DOES

.SBTTL	+ PROCESSOR - PREPARE TO DO ADDITION

O.PLUS:	CLRB	R4		;OP IS 0 FOR +
	BR	20$

.SBTTL	- PROCESSOR - PREPARE TO DO SUBTRACTION

O.MINS:	MOVB	#2,R4
	BR	20$

.SBTTL	* PROCESSOR - SET TO MULTIPLY BY 50 AND ADD

O.STAR:	MOVB	#-2,R4		;OP IS -2 FOR *
	BR	20$

.SBTTL	! PROCESSOR - PREPARE TO SHIFT

O.EXCL:	MOVB	#-4,R4		;OP IS -4 FOR SHIFT
	BR	20$

.SBTTL	& PROCESSOR - PREPARE TO DO LOGICAL AND

O.AMPR:	MOVB	#-6,R4		;OP IS -6 FOR LOGICAL AND

20$:	MOVB	R4,O.OP		;SET UP THE OP CODE
	CLR	R4		;R4 IS RESET
	BR	O.NEWN

.DSABL	LSB

.SBTTL	OPEN AND CLOSE PROCESSORS

.ENABL	LSB

.SBTTL	/ PROCESSOR - OPEN OCTAL WORD
.SBTTL	" PROCESSOR - OPEN ASCII WORD
.SBTTL	% PROCESSOR - OPEN RAD50 WORD

; SYNTAX--
;  NC				OPEN LOC N IN MODE C, SET MODE FOR NEXT
;  C				TYPE LAST OPENED LOC IN MODE C

OCWORD:		;OCTAL WORD -		R1=2
ANWORD:		;ASCII WORD -		R1=6
MODULO:		;RADIX 50 WORD -	R1=10

; OPEN WORD MODE ENTRY, R1 CONTAINS FORMAT INDEX

	MOV	#2,R0		;SET BYTE FLAG TO WORD FLAG
	BR	20$		;GO TO IT ACE HOLE

.SBTTL	\ PROCESSOR - OPEN OCTAL BYTE
.SBTTL	' PROCESSOR - OPEN ASCII BYTE

OCBYTE:		;OCTAL BYTE -		R1=0
ANBYTE:		;ASCII BYTE -		R1=4

10$:	MOV	#1,R0		;SET WORD FLAG TO BYTE FLAG
20$:	TST	R2		;IF NO VALUE TYPED NO MODE SET
	BEQ	30$
	MOV	R0,O.BW		;SET MODE AND FORMAT FLAGS
	MOVB	R0,O.OBW	;SET THE LATER USE MOOD
	MOVB	R1,O.FM		;SET THE MODE FLAG FOR SOOTH
	MOV	R4,O.CAD	;SET ADDRESS FOR EXPLICIT OPEN
30$:	CMP	#1,R0		;CHECK ON BYTE MOOD
	BEQ	40$		;NOT BYTE MODE
	BIT	#1,O.CAD	;SEE IF ADDRESS IS ODD
	BEQ	40$		;ALL IS GOOD
	CLR	R1		;THEY GET BYTE MODE ONLY
	BR	10$

40$:	MOV	R1,-(SP)	;SAVE FORMAT MAINLY
	CALL	GETCAD		;GET THE DATA
	MOV	(SP)+,R1	;GET FORMAT
	CALL	@TYFORM(R1)	;PRINT DATA IN PROPER FORMAT
	BR	O.NEWC		;GO GETTA NEW COMMAND TO DO

.DSABL	LSB

.ENABL	LSB

.SBTTL	<CR> PROCESSOR - CLOSE OPEN LOCATION

CLCRET:	CALL	PUTCAD		;CLOSE LOCATION
	BR	O.DCD		;RETURN TO DECODER

.SBTTL	LEFT ANGLE BRACKET PROCESSOR - BACK TO MAIN STREAM

CLLSTH:	INCB	O.SEQ		;SET FLAG TO LATER RESTORE CAD

.SBTTL	<LF> PROCESSOR - CLOSE THIS LOCATION, OPEN NEXT

CLLNFD:	CALL	PUTCAD		;CLOSE PRESENT CELL
	MOV	#O.CAD,R4	;R4 -> CURRENT ADDRESS WORD
	TSTB	O.SEQ		;SHOULD CAD BE RESTORED?
	BEQ	10$		;BRANCH IF NOT
	MOV	O.DOT,(R4)	;RESTORE PREVIOUS SEQUENCE
	CLRB	O.SEQ		;RESET FLAG; NO LONGER NEEDED
10$:	ADD	O.BW,(R4)	;GENERATE NEW ADDRESS
20$:	MOV	(R4),O.DOT	;INITIALIZE DOT
30$:	CALL	O.CRLF		;<CR><LF>
	MOV	(R4),R0		;NUMBER TO TYPE
	CALL	O.RORA		; CHECK FORMAT
	MOVB	O.FM,R0		;SET FORMAT
	ASR	R0		;SPLIT R0 IN HALF
	MOVB	COMTAB(R0),R0	;SET SUFFIX CHARACTER
	CALL	O.FTYP		;PRINT IT
	MOV	O.CAD,R4	;SET UP THE DATA
	MOV	(PC),R2		;SET R2 <> 0
	CLRB	O.OP		;THIS IS BECAUSE
	CLR	O.EXP
	JMP	O.CLGL		;R0 HAS TERMIN, R4- DATA, R2= FLAG

.SBTTL	^ PROCESSOR - CLOSE THIS LOCATION, OPEN PREVIOUS

CLUPAR:	CALL	PUTCAD
	MOV	#O.CAD,R4	;R4 -> CAD WORD
	SUB	O.BW,(R4)	;GENERATE NEW ADDRESS
	BR	20$		;GO DO THE REST

.SBTTL	_ PROCESSOR - CLOSE THIS LOCATION, OPEN RELATIVE WORD

CLBACK:	CALL	O.TCLS		;TEST WORD MODE AND CLOSE
40$:	ADD	R0,(R4)		;ADD CONTENTS OF LOCATION TO ADDRESS
	ADD	#2,(R4)		;ADVANCE BY ONE WORD
	BR	30$		;GO TO OPEN THAT WORD

.SBTTL	@ PROCESSOR - CLOSE THIS LOCATION, OPEN INDIRECT

CLATSG:	CALL	O.TCLS		;TEST WORD MODE AND CLOSE
	MOV	R0,(R4)		;CHANGE CURRENT ADDRESS TO CONTENTS
	CLR	O.MAPF		;TURN ON MMU MAPPING
	BR	30$

.SBTTL	RIGHT ANGLE BRACKET PROCESSOR - CLOSE, OPEN RELATIVE BRANCH

CLGRTH:	CALL	O.TCLS		;TEST AND CLOSE
	MOVB	R0,R0		;SIGN EXTEND LOW BYTE OF WORD
	ASL	R0		;DOUBLE IT
	BR	40$		;THEN TREAT IT AS RELATIVE WORD

; CLOSE OPEN LOCATION, CHECK WORD MODE

O.TCLS:	CALL	PUTCAD		;CLOSE CURRENT CELL
	MOV	O.BW,R0		;GET BYTE/WORD INDICATION
	CMP	R0,#2		;ONLY WORD MODE ALLOWED
	BNE	O.ERR1		;BRANCH IF ERROR
	CALL	GETCAD		;GET CONTENTS OF CURRENT LOCATION
	MOV	#O.CAD,R4	;R4 -> CAD WORD
	RETURN

.DSABL	LSB

.SBTTL	O PROCESSOR - COMPUTE AND PRINT OFFSETS

; SYNTAX--
;  AO				TYPE OFFSETS FROM . TO A
;  L;AO				TYPE OFFSETS FROM L TO A

; TYPES	_PPPPPP >DDDDDD			WHERE P-P IS PC RELATIVE
;					AND D-D IS BRANCH OFFSET

O.OFST:	TST	R3		;HOW ABOUT A VALUE OTHER
	BNE	10$		;THAN CAD
	MOV	O.CAD,R5	;RELUCTANTLY
10$:	SUB	R5,R4
	SUB	#2,R4		;NO TRICKS, ODD AND NON-EXIST THINGS
	CALL	O.TYPC,R5,<" _>	;TYPE PC RELATIVE CUE
	MOV	R4,R0
	MOV	R4,-(SP)	;GOOD IDEA TO SAVE THIS
	CALL	O.CADW		;TYPE VALUE + BLANK
	CALL	O.TYPC,R5,076	;TYPE OFFSET BRANCH CUE
	MOV	(SP)+,R0
	ASR	R0		;DIVIDE
	CALL	O.CADW		;16 BITS SO YOU CAN SEE HOW FAR OFF
	JMP	O.DCD		;YOU ARE

; JUST ANOTHER ERROR CALL

O.ERR1:	JMP	O.ERR

.SBTTL	G PROCESSOR - GO TO PROGRAM

; SYNTAX--
;  LG			START PROGRAM AT LOCATION L
;  G			START PROGRAM AT CURRENT PC

O.GOTO:	TST	R2		;SEE IF SPECIFIC ADDRESS
	BNE	10$		;Yes, use it
	MOV	O.UPC,R4	;USE PC AS IT was
10$:	ASR	R4		;SEE IF STRANGE
	BCS	O.ERR1		;THAT'S ODD ?
	ASL	R4
	MOV	R4,O.UPC	;SET THE PC
	CLRB	O.S		;NO SINGLE INSTRUCTIONS
	MOVB	#O.BKP+3,O.P	;GOTTA BREAK TO PROCEED
	MOVB	#O.STM,@#PS	;;;SET HIGH PRIORITY
	CALL	O.RSTT		;;;RESTORE TTY

O.TBIT:	CLRB	O.T		;;;CLEAR Step-over-BPT FLAG
	BIS	#T,O.UST	;;;Assume T bitting
	TSTB	O.S		;;;SEE IF WE NEED A T-BIT for Single Step
	BMI	O.RESU		;;;Yes, GO ON with the show

	BIC	#T,O.UST	;;; No S/Step - ReSET T bit

; Now set the BPT's into the program

	MOV	@O.KIA5,O.APR5	;;;SAVE APR5

	MOV	#O.ADR1+O.BKP+2,R4 ;;;RESTORE BREAKPOINTS. POINT PAST THE LAST
10$:	CMP	-(R4),#-1	;;;REAL?
	BEQ	20$		;;;NOPE
	MOV	O.ADRL-O.ADR1(R4),R2 ;;;GET VIRTUAL POINTER
	MOV	O.ADRM-O.ADR1(R4),@O.KIA5 ;;; AND MAP IT
	MOV	(R2),O.UIN-O.ADR1(R4) ;;;SAVE CONTENTS OF USER LOCATION
	MOV	#BPT,(R2)	;;;CHANGE THAT LOCATION TO BPT
20$:	CMP	R4,#O.ADR1	;;;DONE?
	BHI	10$		;;;NO

	MOV	O.APR5,@O.KIA5	;;;RESTORE APR5

O.RESU:	CALL	VEC.RS		;;;Restore critical vectors
	CALL	O.RSR,R0	;;;RESTORE USER STATE
	CLR	OLDBUF		;;;USER MIGHT ALTER DISK AND NOT BUFFER

; Set up a BPT'ish stack

	MOV	O.UST,-(SP)	;;;	STATUS
	MOV	O.UPC,-(SP)	;;;	AND PC

	MOV	O.UST,-(SP)	;;;T-BIT FIX HACK FIX, FLUSH INTERRUPTS
	BIC	#T,(SP)		;;;CLEAR T-BIT AND THEN
	MOVB	(SP)+,@#PS	;;;JAM PS TO USER'S PRIORITY TO FLUSH

	JMP	@ODT+16		;;;NOW EXIT (Rsts will finally RTT)

.SBTTL	S PROCESSOR - SINGLE STEP

.ENABL	LSB

; SYNTAX--
;  NS				EXECUTE N INSTRUCTIONS AND THEN STOP
;  S				EXECUTE ONE INSTRUCTION

O.SNGL:	MOVB	#-1,O.S		;SET THE MODE FOR S.I. MOOD
	MOVB	#O.BKP+2,R0	;FAKE THE BREAK
	BR	10$		;FAKE A PROCEED IN S.I. MOOD

.SBTTL	P PROCESSOR - PROCEED FROM BREAKPOINT

; SYNTAX--
;  NP				PROCEED THRU THIS BREAKPOINT N TIMES
;  P				ASSUME N=1

O.PROC:	CLRB	O.S		;SET FAST MODE
	MOVB	O.P,R0		;GET NUMBER OF BREAK
	BMI	O.ERR1		;THERE WASN'T ONE SO FAR ?
10$:	TST	R2
	BEQ	20$		;NO R4 IS DEFAULT TO 1
	MOV	R4,O.CT(R0)	;SET USER'S COUNT
20$:	MOVB	#O.STM,@#PS	;;;FORCE HIGH PRIORITY
	CALL	O.RSTT		;;;RESTORE TTY

O.REPT:	CMPB	O.P,#O.BKP	;;;SEE IF A REAL ONE OR A FAKE
	BGT	O.TBIT		;;;BRANCH IF FAKE

	TSTB	O.S		;;;SEE IF SINGLE INSTRUCTION MODE
	BMI	O.TBIT		;;;IF SO EXIT NOW

;+
; In order to execute the instruction which was covered
; by a BPT, we set the T bit so only one instruction is executed,
; and then we can again insert our BPT's
; We remenber this fact in O.T
;-

	MOVB	#O.STM,@#PS	;;;SET HIGH PRIORITY
	INCB	O.T		;;;SET Step-over-BPT FLAG
	BIS	#T,O.UST	;;;SET T-BIT

	BR	O.RESU		;;;AND GO

.DSABL	LSB

O.TBX:	BR	O.TBIT		;For reaching purposes


.SBTTL	Rsts/e support code for BPT
;
;+	Rsts code for BPT support
;
;.SBTTL	BPT TRAP HANDLING
;
;
; ALL BPT INSTRUCTIONS AND T-BIT TRAPS COME HERE.
;
; 1) BPT FROM USER MODE.
;
;	THE BPT IS RE-ROUTED TO THE USER THROUGH P.BPT.
;
; 2) BPT FROM KERNEL MODE.
;
;	UNLESS KERNEL MODE ODT IS INSTALLED THIS WILL
;	CAUSE THE SYSTEM TO CRASH JUST LIKE ANY RESERVED
;	INSTRUCTION.
;-
;
;.ENABLE	LSB
;
;	TMPORG	RTICTL
;
;SVPAR6:	.BLKW	2		;SAVED KERNEL MODE PAR6 VALUE
;
;	TMPORG	RTI		;SO IT'L ALWAYS BE AROUND
;
;20$:	MOV	@#KISAR6,SVPAR6	;;;SAVE INTERRUPTED PAR6
;	MOV	@DPAR6,SVPAR6+2	;;; AND TOTO TOO (D APR)
;	MOV	#0,@#KISAR6	;;;SET ODT'S PAR6 VALUE
;$$ODT6	==	.-4	;**INIT** ODT'S PAR6 IF KERNEL MODE ODT
;	MOV	@#KISAR6,@DPAR6	;;; AND D-SPACE
;	CALL	@#NOODT		;;;NOW ENTER ODT (OR 'NOODT' IF NO ODT)
;$$ODTE	==	.-2	;**INIT** ODT'S ENTRY IF KERNEL MODE ODT
;	MOV	@#SVPAR6,@#KISAR6 ;;;RESTORE INTERRUPTED PAR6
;				;;;(ODT FETCHES ADDRESS OF SVPAR6 FROM
;				;;; SOURCE OF THE MOV INSTRUCTION.)
;	MOV	@#SVPAR6+2,@DPAR6 ;;;RESTORE INTERRUPTED PAR6 D-SPACE
;	RTT			;;; AND EXIT FROM THE BREAKPOINT
;
;	VECTOR	14,,PR7		;BPT COMES HERE
;
;	TMPORG	RTI		;I LIKE THIS PSECT, LET'S STAY HERE
;				; THE VECTOR MACRO TOOK US ELSE WHERE
;
;	TST	1*2(SP)		;;;FROM USER MODE?
;	BPL	20$		;;;NO
;	SPLC	3		;;;YES, DROP TO LEVEL 3
;	REGSAV			;SAVE ALL REGISTERS
;	MOV	#P.BPT,R0	;RE-ROUTE THROUGH P.BPT
;	JMP	RETUSR		;NOW GO DO THE RE-ROUTE
;
;.DSABL	LSB
;
;	UNORG
;
;GLOBAL	<DPAR6>
;
;-

.SBTTL	RSTS/E ENTRY

; ENTRY HERE IS VIA JSR PC,O.RSTS
;	after RSTS has fielded the BPT
; The current running RSTS APR6 and DAPR6 have been saved.
;
; APR6 and DPAR6 now map ODT
;
; RETURN IS TO BE EFFECTIVELY RTS PC
;	actually is a JMP @ODT+16
;
; ALSO, THE RUNNING PROGRAM APR6 IS pointed to at 2 PAST THE RETURN ADDRESS
; and the running program DAPR6 is pointed to at 10 past the return.


O.RSTS:	MOV	(SP),ODT+16	;;;SET RETURN ADDRESS
	ADD	#2,(SP)		;;;POINT TO THE APR6 VAL (Source of MOV inst)
	MOV	@(SP)+,O.PTA6	;;;SAVE POINTER TO APR6 VALUE, and clean stack
	MOV	@O.PTA6,O.APR6	;;;AND SAVE IT AS $0E VALUE
	MOV	O.PTA6,O.PTD6	;;;Copy for pointer to DPAR6
	ADD	#2,O.PTD6	;;; +2 is where it lives
	MOV	@O.PTD6,O.DPR6	;;;Save its value as $1E
	.BR	O.BREK		;;;DO A BREAKPOINT

.SBTTL	BREAKPOINT TRAP ENTRY ROUTINE

O.BREK:	MOV	(SP)+,O.UPC	;;;PRIORITY IS 7 UPON ENTRY
	MOV	(SP)+,O.UST	;;;SAVE STATUS AND PC
	MOVB	#O.BKP+3,O.P	;;;TELL ;P THAT WE CAN CONTINUE
	CALL	O.SVR,R0	;;;SAVE VARIOUS REGISTERS, establish stack

	TST	O.I.TK		;;;NEED RESTORE?
	BEQ	10$		;;;NOPE
	MOV	.ODTKB,R4	;;;YES, SO DO IT
	CALL	SETTTY		;;;SET TO DEFAULT
	CLR	O.I.TK		;;;AND SAY WE DID IT

10$:	CALL	SETMMU		;;;SET UP MMU MODE

	CALL	VEC.SV		;;;Set-up T4 and T250 catcher

	CLR	INP		;;;RESET TYPE AHEAD MODE
	CLR	O.GETP		;;;NO INDIRECT POINTER

	TSTB	O.T		;;;CHECK FOR Step-over-BPT SET
	BNE	O.TBX		;;;JUMP IF SET

	TSTB	O.S		;;;ARE WE IN SINGLE STEP MODE?
	BNE	50$		;;;YES, DON'T REMOVE BREAKPOINTS
				;;; as we never put them in
;
; Remove BPT's from user program
;
	MOV	@O.KIA5,O.APR5	;;;SAVE APR5
	MOV	#O.ADR1+O.BKP+2,R4 ;;;POINT BEYOND LAST BREAKPOINT
20$:	CMP	-(R4),#-1	;;;REAL?
	BEQ	40$		;;;NOPE
	MOV	O.ADRL-O.ADR1(R4),R2 ;;;ELSE GET VIRTUAL POINTER
	MOV	O.ADRM-O.ADR1(R4),@O.KIA5 ;;; AND MAP IT
	CMP	(R2),#BPT	;;;REALLY A BREAKPOINT THERE???
	BEQ	30$		;;;YEP

;+
;	There isn't a BPT where we say it should be
;-

	MOV	#-1,(R4)	;;;NOPE!!! REMOVE THE BREAKPOINT
	CLR	O.CT-O.ADR1(R4)	;;; AND ITS COUNT
	CALL	O.SVTT		;;;SAVE TERMINAL STATUS
	CALL	O.CRLF		;;;RESTORE CARRIAGE
	MOV	#'_,R0		;;;ANNOUNCE
	CALL	O.FTYP		;;; ODT
	MOV	R4,R0		;;;FIND
	SUB	#O.ADR1,R0	;;; THE
	ASR	R0		;;;  BREAK NUMBER
	CALL	O.TYPA,R5,<"0B>	;;;   AND TYPE IT
	MOV	#"??,R0		;;; Tell him it's missing
	CALL	O.TYPE
	CALL	O.RSTT		;;;RESTORE TERMINAL STATUS AGAIN

	BR	40$		;;; AND CONTINUE THE SCAN

30$:	MOV	O.UIN-O.ADR1(R4),(R2) ;;;RESTORE USER INSTRUCTION
40$:	CMP	R4,#O.ADR1	;;;MORE?
	BHI	20$		;;;YEP

	MOV	O.APR5,@O.KIA5	;;;RESTORE APR5

50$:	MOVB	O.PRI,R5	;;;CHECK IF PRIORITY
	BPL	60$		;;; IS AS SAME AS USER PGM
	MOVB	O.UST,R5	;;;PICK UP USER UST IF SO
	BR	70$		;;;CONTINUE

60$:	RORB	R5		;;;SHIFT LOW ORDER BITS
	RORB	R5		;;;  INTO
	RORB	R5		;;;    HIGH ORDER
	RORB	R5		;;;      POSITION

70$:	BIC	#^C<O.STM>,R5	;;;CLEAR ALL BUT PRI FOR POS T-BIT
;///
;///	Priority setting has been temporarily disabled.
;///
;///	The reason is that SETMMU disables D-space mapping for kernel mode,
;///	which would probably kill interrupt service routines.  Until this
;///	issue is resolved, ODT will always run at PR7.
;///
;\\\	MOVB	R5,@#PS		;;;PUT STATUS AWAY WHERE IT BELONGS

	MOV	O.UPC,R5	;GET PC, IT POINTS TO THE BPT + 2
	MOV	#O.ADR1+O.BKP+2,R4 ;R4 -> SINGLE STEP TABLE OFFSET
	TSTB	O.S		;SEE IF IT WAS SINGLE INSTRUCTION FUN
	BMI	110$		;IF SO HANDLE THERE

	SUB	#2,R5		;BACK UP TO LOCATION HE BROKE ON
	MOV	R5,O.UPC	;FIX THE USER'S PC

	TST	O.OF56		;MMU ON?
	BEQ	80$		;NO

;+
;	Make MMU address of BPT instruction
;-

	MOV	R5,R1		;YES, COPY VIRTUAL ADDRESS
	BIC	#^C<77>,R1	; AND FIND LOW 6 BITS
	MOV	R5,R0		;COPY AGAIN
	;CLC			;C=0 FROM 'TST' ABOVE
	ROR	R0		;SHIFT
	ASR	R0		; ADDRESS
	ASR	R0		;  RIGHT
	ASR	R0		;   5
	ASR	R0		;    PLACES
	MOV	R0,R2		;SAVE THAT
	ASR	R2		; AND FIND
	BIC	#^C<177>,R2	;  THE 7 BITS
	CLRB	R0		;NOW
	SWAB	R0		; TOP 3 BITS
	ASL	R0		;  TO <3-1>
	ADD	KISAR0(R0),R2	;CALCULATE HIGH 16 BITS
	CMP	R0,#6*2		;CORRECT?
	BNE	80$		;YES
	SUB	KISAR0(R0),R2	;NO
	ADD	O.APR6,R2	; BUT THIS IS...

80$:	TST	O.OF56		;MMU ON?
	BEQ	90$		;NO
	TST	-(R4)		;YES, GET CORRECT POINTER
	CMP	R2,O.ADRM-O.ADR1(R4) ;CORRECT HIGH 16 BITS?
	BNE	100$		;NO
	CMPB	R1,O.ADRL-O.ADR1(R4) ;CORRECT LOW 6 BITS?
	BNE	100$		;NO
	MOV	R5,(R4)+	;YES, ENSURE A MATCH
90$:	CMP	R5,-(R4)	;COMPARE WITH LIST
	BEQ	120$		;JUMP IF FOUND
100$:	CMP	R4,#O.ADR1	;DOWN TO THE BEGINNING?
	BHI	80$		;NO, LOOK MORE

;+
;	We couldn't match the BPT's address with any of our B's
;-

	CALL	O.SVTT		;SAVE TELETYPE STATUS
	CALL	O.CRLF
	CALL	O.TYPC,R5,<"BE>	;OUTPUT "BE" FOR BAD ENTRY
	MOV	R5,R0
	ADD	#2,O.UPC	;POP OVER THE ADJUSTMENT ABOVE
	BR	140$		; and CONTINUE

110$:	MOV	R5,(R4)		;STORE NEXT PC VALUE FOR TYPE OUT
120$:	SUB	#O.ADR1,R4	;COMPUTE RELATIVE BP NUMBER
	MOVB	R4,O.P		;ALLOW PROCEED

	DEC	O.CT(R4)	;Exhausted iteration count?
	BLE	130$		;Sure have!
	JMP	O.REPT		; REPEAT it some more

130$:	MOV	#1,O.CT(R4)	;RESET COUNT TO 1
	CALL	O.SVTT		;SAVE TELETYPE STATUS, R4 IS SAFE
	MOVB	R4,R0		;SET UP TO TYPE B PLUS N
	ASR	R0		;JUST AS A TOKEN GESTURE
	CALL	O.TYPA,R5,<"0B>	;TYPE "NB" WHERE N IS THE BPT NUMBER
	CALL	O.TYPC,R5,<':>	;TYPE A COLON TO DELIMIT THE ADDRESS
	MOV	O.ADR1(R4),R0	;GET ADDRESS OF BREAK
	MOV	O.BKAC(R4),R4	;GET BREAKPOINT ACTION #
	CMP	R4,#7		;LEGAL?
	BHI	140$		;NOPE, SO DO NOTHING
	CALL	MAPACT		;YEP, MAP INTO AN ACTION POINTER
	MOV	R4,O.GETP	; AND USE THAT AS AN INDIRECT

140$:	CALL	O.RORA		;Print out Break address in
				;the appropriate format

	JMP	O.DCD		;GO TO DECODER to see what he wants


.SBTTL	L PROCESSOR - LIST MEMORY ON SPECIFIED DEVICE

; SYNTAX--
;   D;S;FL		WHERE	D IS DEVICE, NULL OR 0 = CONSOLE
;				S IS START ADDRESS, SETS $L IF THERE
;				F IS STOP ADDRESS, SETS $H IF THERE

O.LIST:	TST	R2		;SET UPPER AND LOWER LIMITS
	BEQ	10$		;IF SPECIFIED TO DO SO
	MOV	R4,O.HI
10$:	TST	R3		;DO THE LOW ONE
	BEQ	20$
	MOV	R5,O.LOW
20$:	CMPB	#2,O.SMFD	;SEE ABOUT THE DEVICE
	BNE	40$		;CONSOLE, NO BIG DEAL
	MOV	D.ARGS,R0	;SEE WHICH DEVICE
	BEQ	40$		;OTHER CHOICE IS LP11
	BIT	R0,#1		;ODD ADDRESS?
	BEQ	30$		;NOPE, USE AS CSR ADDRESS
	MOV	#LPS,R0		;YES, USE LP: AS DEVICE
30$:	MOV	R0,O.TPS	;NEW STATUS ADDRESS
	TST	(R0)+		;NEXT IS BUFFER
	MOV	R0,O.TPB	;NEW BUFFER ADDRESS
	CALL	O.TYPC,R5,<14*400+15> ;FORM FEED THE PRINTER
40$:	CALL	SARSET		;SET UP THE LIMITS TO START
	TST	-(SP)		;MAKE A HOLE IN THE STACK
50$:	CLR	(SP)		;NEW LINE UP
	CALL	SNAGIT		;ACCESS DEVICE FOR DATA
	CALL	SPRINT		;PRINT ADDRESS AND FIRST ITEM
60$:	CALL	SNAGIT		;GET MORE DATA
	CALL	DPRINT		;JUST PRINT THE DATA
	INC	(SP)		;COUNT THE DATA
	CMP	#7,(SP)		;CHECK THE COUNT
	BNE	60$		;JUST LIKE THEY TOLD YOU AT THE
	BR	50$		;FAMOUS PROGRAMMERS SCHOOL

.SBTTL	W PROCESSOR - MASKED EQUAL WORD SEARCH

; SYNTAX--
;  M;AW				SET $M TO M, SET $A TO A, DO SEARCH
;  AW				SET $A TO A, DO SEARCH
;  W				USE $L, $H, $M, $A TO SEARCH. PRINT HITS

O.WSCH:	CALL	SARGUS		;SET UP $A, $M AND R5
10$:	CALL	SNAGIT		;R5 IS MEMORY INDEX, CHECK FOR IT
	BNE	10$		;NOT EQUAL IS NOT THE OBJECTIVE
	CALL	SPRINT		;PRINT LOCATION AND VALUE
	BR	10$		;MOVE ON

.SBTTL	N PROCESSOR - MASKED NOT EQUAL WORD SEARCH

; SYNTAX--
;  N				COMMAND IS "N", FORMS AS ARE FOR "W"

O.NOTW:	CALL	SARGUS
10$:	CALL	SNAGIT
	BEQ	10$		;THE ONLY DIFFERENCE
	CALL	SPRINT
	BR	10$

.SBTTL	E PROCESSOR - MASKED EFFECTIVE ADDRESS

; SYNTAX--
;  E		COMMAND IS "E", FORMS ARE AS ABOVE IN "W" AND "N"

O.EFFA:	CALL	SARGUS		;SET IT ALL UP PLEASE
10$:	CALL	SNAGIT		;GET THE DATA VIA R5
	BEQ	20$		;SAME ABSOLUTE ADDRESS FOUND
	MOV	R5,R0		;DO THE PC REL
	CALL	SRCHEF		;GO SEE IF MASKED SAME
	BEQ	20$		;SAME PC RELATIVE ADDRESS
	MOVB	R5,R0		;DISPLACEMENT INTO R1, SIGN EXTEND
	ASL	R0		;CARRY IS CLEAR
	CALL	SRCHEF		;CHECK IT
	BNE	10$		;SAME BRANCH DISPLACE IN FALL THRU
20$:	CALL	SPRINT
	BR	10$

.SBTTL	F PROCESSOR - FILL MEMORY WORDS

; SYNTAX--
;  AF			SET ARG REGISTER, FILL WITH $A FROM $L TO $H

O.FILL:	CLR	R3		;NO MASK IS TO BE SET
	CALL	SARGUS		;SET UP ARG AND R5
10$:	CALL	SNAGIT		;GET LOC IN R5
	MOV	SP,R2		;PRETEND DATA IS HERE
	MOV	O.ARG,R4	;THIS IS WHY
	MOVB	O.OBW,O.BW	;OPEN THE ITEM
	CALL	PUTCAD		;PUT THE DATA
	BR	10$		;GO TILL BROKEN

.SBTTL	A PROCESSOR - DO AN ACTION

; SYNTAX--
;  NA			DO ACTION ROUTINE A

O.DOAC:	CALL	CHKACT		;CHECK ACTION # AND POINT TO IT
	MOV	R4,O.GETP	;SET THE INDIRECT INPUT POINTER
	BR	O.DCD9		; AND CONTINUE

.SBTTL	) PROCESSOR - TYPE AN ACTION ROUTINE

; SYNTAX--
;  A)			TYPE ACTION ROUTINE A

O.RPAR:	CALL	CHKACT		;CHECK FOR LEGAL ACTION AND POINT TO IT
	CALL	O.CRLF		;RESTORE CARRIAGE
10$:	MOVB	(R4)+,R0	;GET A CHARACTER
	BEQ	O.DCD9		;THE END
20$:	CALL	O.FTYP		;ELSE TYPE IT
	CMPB	R0,#15		;<CR>?
	BNE	10$		;OTHER
	MOVB	#12,R0		;YEP, DO A <LF> THEN
	BR	20$

.SBTTL	( PROCESSOR - ESTABLISH AN ACTION ROUTINE

;  A(...)		ESTABLISH ACTION ROUTINE A

.ENABL	LSB

O.LPAR:	CALL	CHKACT		;CHECK FOR LEGAL ACTION AND POINT TO IT
	MOV	#31.,R3		;SET LIMITING COUNTER
	CLR	R5		;SET PAREN LEVEL COUNTER
10$:	CALL	O.GET		;GET NEXT CHARACTER
	CMPB	R0,#')		;ENDING PAREN?
	BEQ	50$		;MIGHT BE
	CMPB	R0,#'(		;NESTED PAREN?
	BNE	20$		;NO
	INC	R5		;YES, COUNT IT
20$:	CMPB	R0,#15		;<CR>?
	BEQ	30$		;YES, ECHO A <LF> ALSO
	CMPB	R0,#12		;<LF>?
	BNE	40$		;OTHER, JUST STORE IT
30$:	MOVB	R0,-(SP)	;SAVE CHARACTER
	MOVB	#12,R0		;NOW TYPE
	CALL	O.FTYP		; A <LF>
	MOVB	(SP)+,R0	;RESTORE CHARACTER
40$:	MOVB	R0,(R4)+	;STORE IN ACTION BUFFER
	CLRB	(R4)		;KEEPING IT .ASCIZ
	DEC	R3		;TOO MUCH?
	BGT	10$		;NO, CONTINUE
	CLRB	-31.(R4)	;YES, FORGET THIS WHOLE LINE
O.ERR9:	JMP	O.ERR		;SAY ERROR

50$:	DEC	R5		;END OF ACTION?
	BPL	40$		;NOT YET
O.DCD9:	JMP	O.DCD		;YES, DONE

.DSABL	LSB

.SBTTL	D PROCESSOR - DEFINE BREAKPOINT ACTION

; SYNTAX--
;  D			CLEAR ALL BKPT ACTIONS
;  ND			CLEAR BKPT N ACTION
;  A;ND			SET ACTION A FOR BKPT N

O.SEBA:	ASL	R4		;PRE-DOUBLE ACTION NUMBER
	TST	R3		;REMOVES?
	BEQ	20$		;YES
	CMP	R5,#7		;NO, LEGAL ACTION NUMBER?
	BHI	O.ERR9		;ERROR
10$:	CALL	40$		;SET THE ACTION
	BCS	O.ERR9		;ILLEGAL
	BR	O.DCD9		;ELSE O.K.

20$:	MOV	#-1,R5		;SET TO DISABLE ACTIONS
	TST	R2		;ALL?
	BNE	10$		;NO, REMOVE ONLY ONE
	CLR	R4		;YES, ALL, START AT 0
30$:	CALL	40$		;DO A REMOVAL
	BCC	30$		;MORE TO GO...
	BR	O.DCD9		;ELSE EXIT

40$:	CMP	#8.*2,R4	;LEGAL?
	BLO	50$		;NO, C=1
	MOV	R5,O.BKAC(R4)	;YES, SET IT
	TST	(R4)+		;AND ADVANCE (C=0)
50$:	RETURN

.SBTTL	[ PROCESSOR - HANDLE CONDITIONALS

; SYNTAX--
;  V[...]		DO ... ONLY IF V<>0
;  1;V[...]		DO ... ONLY IF V=0

O.COND:	NEG	R5		;SET C=1 IF DOING V=0
	BIT	R4,R4		;SET Z=1 IF V=0
	BCS	40$		;C=1, SO PROCEED ONLY IF V=0
	BNE	O.DCD9		;C=0, CONTINUE ONLY IF V<>0
10$:	CLR	R5		;SET THE LEVEL COUNTER
20$:	CALL	O.GET		;GET NEXT CHARACTER
	CMPB	R0,#'[		;NESTING?
	BNE	30$		;NO
	INC	R5		;YES, SO COUNT IT
30$:	CMPB	R0,#']		;POSSIBLE END?
	BNE	20$		;NO
	DEC	R5		;YES, REAL END?
	BPL	20$		;NOT YET...
	BR	O.DCD9		;YES

40$:	BEQ	O.DCD9		;CONTINUE ONLY IF V=0
	BR	10$		;ELSE SKIP CONDITIONAL

.SBTTL	EQUALS PROCESSOR - PRINT VALUE OF EXPRESSION

EQUALS:	MOV	R4,R5		;SAVE VALUE IN SAFE SPOT
	MOV	O.PRNT,-(SP)	;SAVE CURRENT PRINT FORMAT
	CLR	O.PRNT		;NOW SET IT TO OCTAL
	CALL	20$		; AND PRINT IT AS OCTAL
	CMP	R5,#7		;IS IT A SIMPLE OCTAL DIGIT?
	BLOS	10$		;WE ARE ALL DONE IF SO
	INC	O.PRNT		;SET UNSIGNED DECIMAL
	CALL	20$		; AND PRINT IT AS UNSIGNED DECIMAL
	TST	R5		;NEGATIVE?
	BPL	10$		;NO, NO NEED FOR SIGNED DECIMAL
	NEG	O.PRNT		;YES, SET SIGNED DECIMAL
	CALL	20$		; AND PRINT IT AS SIGNED DECIMAL
10$:	MOV	(SP)+,O.PRNT	;RESTORE THE ORIGINAL PRINT FORMAT
	BR	O.DCD9		; AND CONTINUE

20$:	MOV	R5,R0		;SET THE VALUE
	CALLR	O.CADW		; AND GO PRINT IT

CHKACT:	CMP	R4,#7		;LEGAL?
	BHI	O.ERR9		;NO, ERROR
MAPACT:	ASL	R4		;*2
	ASL	R4		;*4
	ASL	R4		;*8.
	ASL	R4		;*16.
	ASL	R4		;*32.
	ADD	#O.ACTN,R4	;POINT TO IT
	RETURN


.SBTTL	M Processor - Set mapper mode

; SYNTAX:
;
;		Only valid if MMU is present
;
;	Mx where x is:
;
;	I - Use I space
;	D - Use D space
;	U - User User I space
;	X - Use Defineable Mapper
;

O.MAPR:	TST	O.OF56		;Is MMU on?
	BEQ	O.ERR9		;No - so this is illegal

	CALL	O.GET		;Get another character
	CALL	LOOKUP,R5,<MAPTAB>	;Look in this table for matches
	BCS	O.ERR9		;Whoops

	CMP	#1*2,R1		;Is this D?
	BNE	10$		;No, forget D space check
	TST	O.DSP		;Do we have D space caps.
	BEQ	O.ERR9		;No - so no go
	BR	99$

10$:	CMP	#4*2,R1		;Is this K
	BNE	20$		;No, don't worry then
	TST	O.DSP		;Do we have D space?
	BEQ	20$		;No, no need
	MOV	#0*2,R1		;Make I space when I or D
	BR 	99$

20$:	CMP	#0*2,R1		;Is this I ?
	BNE	99$
	TST	O.DSP
	BNE	99$		;OK if I or D
	MOV	#4*2,R1		;Make K
	.BR	99$

99$:	MOV	R1,O.MAPM	;Set the mode
	JMP	O.DCD		;and back for more




.SBTTL	UTILITIES - SAVE AND RESTORE USER DATA.

; SAVE REGISTERS R0-R6, SET ODT'S STACK UP	JSR R0,O.SVR

O.SVR:	MOV	(SP)+,O.UR0	;PICK R0 FROM STACK AND SAVE
O.SVR0:	MOV	SP,O.USP	;SAVE USER STACK ADDRESS
	MOV	#O.USP,SP	;SET TO INTERNAL STACK
	MOV	R5,-(SP)	;SAVE
	MOV	R4,-(SP)	; REGISTERS
	MOV	R3,-(SP)	;5
	MOV	R2,-(SP)	; THRU
	MOV	R1,-(SP)	;     1
	CMP	-(SP),-(SP)	;SET UP ODT'S STACK AND COVER R0 SAVE
	RETURN	R0

.SBTTL	O.RSR - Restore user state

; RESTORE REGISTERS R0-R6			JSR R0,O.RSR

O.RSR:	TST	O.OF56		;WAS THE MMU ON?
	BEQ	20$		;NO

	TST	O.DSP		;Did we have D space enabled?
	BEQ	15$		;NO
	MOV	O.MSR3,@#MMUSR3	;Restore Mem Mgt status
;+
;	We did the MMUSR3 restore here as I/o page is RO in
;	running monitor
;-

15$:	MOV	#KISDR0,R3	;YES, RESTORE THE DESCRIPTOR REGS
	MOV	#O.KIDR,R4	; FROM THE SAVED TABLE
10$:	MOV	(R4)+,(R3)+	;PUT BACK DESC REG
	CMP	R3,#KISDR0+<8.*2> ;DONE ALL 8?
	BLO	10$		;NO


20$:	CMP	(SP)+,(SP)+	;POP THE EXTRA CELLS
	MOV	(SP)+,R1	;RESTORE
	MOV	(SP)+,R2	; REGISTERS
	MOV	(SP)+,R3	;  1
	MOV	(SP)+,R4	;  THRU
	MOV	(SP)+,R5	;    5
	MOV	O.USP,SP	;RESTORE USER STACK
	MOV	O.UR0,-(SP)	;PUT R0 ON USER STACK
	RETURN	R0

.SBTTL	Vector Save and Restore

;+
;	Set T4 and T250 vectors after preserving old
;-

VEC.SV:	MOV	#O.VEC,R4	;Save area
	MOV	#4,R3		;Trap to 4 vector
	CALL	10$		;Save and replace
	MOV	#250,R3		;Trap to 250 vector
	
10$:	MOV	(R3),(R4)+	;Save the PC part
	MOV	#O.T4,(R3)+	;Replace with addr of catcher
	MOV	(R3),(R4)+	;Save the PS part
	MOV	#O.STM,(R3)+	;Replace with priority 7
	RETURN


;+
;	Restore original T4 and T250 vectors
;-

VEC.RS:	MOV	#252,R3		;A backward restore to 250
	MOV	#O.VEC+<2*4>,R4	;Point past the restore area
	CALL	10$		;Do first part to 250
	MOV	#6,R3		;Set-up for T4
10$:	MOV	-(R4),(R3)	;Restore PS
	MOV	-(R4),-(R3)	;Restore PC
	RETURN


.SBTTL	Trap to 4 and Trap to 250 Handler

;+
;	Handle NXM and MMU violations
;-

O.T4:	CMP	(SP)+,(SP)+	;Pop off Trap contents from stack
	MOV	O.APR5,@O.KIA5	;Restore original APR5

	CALL	O.CRLF		;Restore carriage
	CALL	O.TYPC,R5,<"? >
	CALL	O.TYPC,R5,<"T4>	;Moan a little

	JMP	O.ERR		;Handle as error




.SBTTL	O.SVTT

; SAVE TELETYPE STATUS				JSR PC,O,SVTT

O.SVTT:	MOVB	@O.TKS,O.CSR1	;SAVE R C/SR
	MOVB	@O.TPS,O.CSR2	;SAVE T C/SR
	CLRB	@O.TKS		;CLEAR ENABLE AND MAINTENANCE
	CLRB	@O.TPS		;  BITS IN BOTH C/SR
	BITB	#2,O.CSR2	;Is this a programmable MXV11?		;008
	BEQ	10$		;No, some other kind of DL-11		;008
	MOVB	O.CSR2,-(SP)	;Yes, get the speed			;008
	BIC	#^C<72>,(SP)	; and only the speed			;008
	BISB	(SP)+,@O.TPS	;So we can put it back			;008
10$:	TSTB	@O.TPS		;LOOP UNTIL READY BIT COMES ON
	BPL	10$		;BR IF BIT NOT ON
	RETURN

.SBTTL	O.RSTT

; RESTORE TELETYPE STATUS			JSR PC,O.RSTT

O.RSTT:	CALL	O.CRLF
10$:	TSTB	@O.TPS		;WAIT READY
	BPL	10$		;  ON PRINTER
	BIT	#4000,@O.TKS	;CHECK BUSY FLAG
	BEQ	30$		;SKIP READY LOOP IF NOT BUSY
20$:	TSTB	@O.TKS		;WAIT READY
	BPL	20$		;    ON READER
	CLR	O.XOFF		;CLEAR X-OFF ON THE WAY OUT
30$:	MOVB	O.CSR1,@O.TKS	;RESTORE
	MOVB	O.CSR2,@O.TPS	;  THE STATUS REGISTERS
	RETURN

.SBTTL	UTILITIES - COMMAND SUPPORT ROUTINES

.ENABL	LSB

; TEST FOR VALID RELOCATION REGISTER IN R4

O.RTST:	CMP	#<O.UNIT-O.RELT>/2-1,R4 ;CHECK FOR PROPER RANGE
	BLO	10$		;TOO BIG (> 37), RETURN WITH C=1
	ASL	R4		;DOUBLE IT, CLEAR CARRY
10$:	RETURN

; RESET RELOCATION BASE AND UNIT REGISTER

O.RUCL:	CALL	O.RTST		;TEST REGISTER TYPE
	BCS	30$		;BAD REGISTER, JUST GO
	MOV	#-1,O.RELT(R4)	;R4 IS INTEGER X2
	CMP	R4,#40
	BLO	20$		;NOT IN UNIT REGISTER RANGE
	CLR	O.UNIT-<20*2>(R4)
20$:	ASR	R4		;R4 BACK TO ST INTEGER
30$:	RETURN

; CLEAR ALL RELOC AND UNIT REGISTERS

O.RUAL:	CLR	R4		;START WITH 0
40$:	CALL	O.RUCL		;DO THIS ONE ONLY AT A TIME
	BCS	30$		;SAME AS RTS PC
	INC	R4		;NEXT ONE AT A TIME
	BR	40$

.SBTTL	SETBRK

; RESET BREAKPOINT VIA VALUE IN R4 AND R0

SETBRK:	CMP	#O.BKP,R4	;SEE IF LEGAL REFERENCE
	BLO	50$		;NOT LEGAL, RETURN WITH C=1
	MOV	R0,O.ADR1(R4)	;SET THE ADDRESS
	CLR	O.CT(R4)	;ZERO PROCEED COUNT
	TST	(R4)+		;POINT TO NEXT BREAKPOINT, CLEAR CARRY
50$:	RETURN

.DSABL	LSB

.SBTTL	COMADD - Compute an address for reference

; COMPUTE ADDRESS FOR CORE OR DISK		JSR PC,COMADD
; and set-up O.WND5 for access
;
;	Very little done if MMU not on

; NEEDS--
; O.CAD			ADDRESS TYPED
; O.DEVI			DEVICE FLAG, - IS CORE, + IS DISK
; O.MAPM		Mapper mode (0,2,4,6,10) if MMU

; SETS UP--
;  R3			ACTUAL CORE ADDRESS
;  O.WND5		APR5 mapper value if MMU
;
;  R5			DISK SEGMENT NUMBER IF SHOULD BE
; C=0 FOR DEVICE IS CORE, C=1 FOR DEVICE IS DISK

COMADD:	MOV	@O.KIA5,O.APR5	;SAVE CURRENT VALUE OF APR 5 IF MMU
	MOV	O.APR5,O.WND5	;AND SET THE NULL WINDOW IF NOT IN RANGE

	MOV	O.CAD,R3	;GET CORE ADDRESS

	MOV	O.DEVI,R2	;SEE ABOUT DEVICE
	BPL	50$		;DISK, GO CHECK IT OUT

;
; We are computing a core address
;
; APR 5 needs to be set-up
; and R3 adjusted to reference thru APR5
;
	TST	O.OF56		;MMU ON?
	BEQ	40$		;NO, so no adjustment needed

	TST	O.MAPF		;NO, IS MAPPING ENABLED THIS TIME?
	BNE	90$		;TEMP DISABLE, so use our APR6

10$:	CMP	R3,O.KIA5	;TRYING TO REACH KISAR5?
	BNE	20$		;NO
	MOV	#O.APR5,R3	;YES, CHANGE THE "ADDRESS"
	BR	90$		;and map to us.

20$:	CMP	R3,O.KIA6	;REALLY KISAR6?
	BNE	25$		;NO
	MOV	O.PTA6,R3	;YES, change the 'address'
	BR	35$		;and map to them.

25$:	CMP	R3,#KDSAR6	;Trying for KDSAR6?
	BNE	30$		;NO
	MOV	O.PTD6,R3	;Yes, pick up pointer
	BR	35$		; and map to them

30$:	CMP	R3,#KISDR0		;KISDR0 - KISDR7 ?
	BLO	35$			;Definitely not
	CMP	R3,#KISDR0+<8.*2>	;Maybe??
	BHIS	35$			;No again
	ADD	#O.KIDR-KISDR0,R3	;Add the Bias
	BR	90$			;and off to map to us

;
; A 'core' address is required
;

35$:	MOV	R3,R5		;Make a copy
	SWAB	R3		;Start making a MMU thru PAR5 pointer
	ROR	R3
	 ROR	R3
	  ROR	R3
	   ROR	R3		;Now have APR # * 2
	BIC	#^C<7*2>,R3	;Trim off garbage

	MOV	R3,-(SP)		;Save virtual APR #
	MOV	O.MAPM,R3		;Get current mode
	ADD	MAPM(R3),(SP)		;Form table address
	MOV	@(SP)+,O.WND5		;Move contents of table to mapper

85$:	MOV	R5,R3		;Retrieve copy
	BR	80$

;We have a local reference
;Use our current APR6 as O.WND5 and adjust R3 accordingly
;else adjust R3 for APR5 reference

90$:	MOV	O.ODR6,O.WND5		;Window to ourselves
80$:	BIC	#160000,R3		;Clear APR index
	ADD	#120000,R3		;Now thru APR 5
	.BR	40$			;and off to see the wizard


40$:	CLC			;C=0 TO INDICATE MEMORY
	RETURN

;
;	Disk look is required

50$:	TST	O.BUFF		;SEE IF DISK LOOK IS ENABLED
	BEQ	60$		;ZERO IS UNLIKELY
	MOV	R3,R5		;MAKE A COPY FOR SEGMENT
	;CLC			;SET UP FOR ROTATE
	ROR	R5		;COMPUTATION, WORDS NOT BITES
	CLRB	R5		;CLEAR LOW BIT OF WORD
	SWAB	R5		;GET HIGH, GET LOW, WANT NEITHER
	ADD	O.RELT+20(R2),R5 ;RELOCATE VIA TABLE SEGMENT
	BIC	#177000,R3	;CLEAR OUT SEGMENT
	ADD	O.BUFF,R3	;THIS IS THE BUFFER ADDRESS
	SEC			;RETURN C=1
	RETURN

60$:	JMP	O.ERR		;DON'T DO IT

.SBTTL	SNAGIT

; SNAG MEMORY LOCATION AND CHECK FOR =	JSR PC,SNAGIT

; NEEDS--
;  O.CAD		POINTS TO MEMORY WORD (APPROXIMATELY THAT IS)
;  R0,R5		CONTAINS REAL WORD UPON EXIT TO "SRCHEK"

; FALLS THRU TO "SRCHEK" FOR THE NITTY GRITTY

SNAGIT:	MOVB	O.OBW,R0	;SET THE INCREMENT
	ADD	R0,O.CAD	;INCREMENT AND NOW
	CMP	O.CAD,O.HI	;SEE IF MORE TO DO
	BLOS	10$		;IF SO, DO IT
	CALL	O.CRLF		;IF NOT, RETURN THE CARRIAGE
	JMP	O.DCD		;DO ANOTHER THING

10$:	CALL	GETCAD		;ACCESS METHOD
	MOV	R0,R5		;MAKE A COPY FOR LATER

; MASKED SEARCH CHECKER				JSR PC,SRCHEK

; NEEDS--
;  R0		HAS OBJECT UNDER TEST
; SEES IF R0 UNDER MASK IS SAME AS ARGUMENT UNDER MASK

; RETURNS--
;  CODES SET FOR	BEQ GOOD FOR SAME, R0=0
;		BNE GOOD FOR NOT SAME, R0<>0

SRCHEK:	MOV	R0,R2		;MAKA COPY
	MOV	O.ARG,R1	;DE ARGUMENT TO COMPARE AGAINST
	BIC	R1,R0		; (NOT A) AND O = X
	BIC	R2,R1		; (NOT O) AND A = Y
	BIS	R0,R1		; X IOR Y = Z
	MOV	O.MSK,R0
	COM	R0
	BIC	R0,R1		;(NOT (NOT M)) AND Z = R1
	RETURN			;BACK TO NEXT ONE

; FINISH EFFECTIVE ADDRESS COMPUTE AND CHECK IT, R0 HAS THE ADDRESS

SRCHEF:	ADD	#2,R0		;TWO CAUSE THE PC GETS TWO TOO
	ADD	O.CAD,R0	;RELOCATION PLEASE
	BR	SRCHEK		;DO THE LOGICAL COMPARE

; SET UP SEARCH ARGUMENTS			JSR PC,SARGUS
; JUST SET UP LIMIT				JSR PC,SARSET

; SETS UP--
; O.ARG IF R4 IS VALID
; O.MSK IF R5 IS VALID
; O.CAD,O.OBW	USED TO GET THE ADDRESS TO START OUT WITH

SARGUS:	TST	R2
	BEQ	10$
	MOV	R4,O.ARG	;SET THE SEARCH ARGUMENT
10$:	TST	R3
	BEQ	SARSET
	MOV	R5,O.MSK
SARSET:	MOV	O.LOW,R5	;SET THE START OF START
	MOVB	O.OBW,R0	;NO SUCHA THING AS A "SUBB"
	SUB	R0,R5
	MOV	R5,O.CAD
	RETURN

; SEARCH HIT PRINT			JSR PC,SPRINT

; O.CAD POINTS TO THE LOC TO BE PRINTED
; R5 CONTAINS THE CONTENTS OF THE LOCATION TO BE PRINTED

SPRINT:	CALL	O.CRLF
	MOV	O.CAD,R0	;THE LOCATION
	CALL	O.RORA		;THE MODE
	MOVB	O.FM,R0		;PICK UP OLD CURENT MODE
	ASR	R0		;HALVES
	MOVB	COMTAB(R0),R0	;AH HA
	CALL	O.FTYP		;TYPE THE MODE DESIGNATOR

; DATA PRINT ROUTINE			JSR PC,DPRINT

; PRINTS DATA IN R5 IN CURRENT MODE

DPRINT:	MOVB	O.FM,R1		;SET THE MODE
	MOV	R5,R0		;THIS IS THE POOR DATA
	MOV	R5,-(SP)	;SAVE THE DATA
	CALL	@TYFORM(R1)	;DO THAT __ TO THE POOR DATA
	MOV	(SP)+,R5	;RESTORE THE DATA
	RETURN

; EXPRESSION COMPUTATION ROUTINE		JSR PC,EXPCOM

; NEEDS--
; O.OP			THE OPERATION (-2=*, 0=+, *=2)
; O.EXP			THE LEFT SIDE
; R4			THE RIGHT SIDE

; SETS UP--
; O.OP			BACK TO 0 FOR ADD
; O.EXP,R4		ALL SO FAR

EXPCOM:	MOVB	O.OP,R2		;GET THE OP CODE
	JMP	@100$(R2)	;AND DO THE OPERATION

10$:	NEG	R4		;MINUS, OP=2
20$:	ADD	O.EXP,R4	;PLUS, OP=0
30$:	MOV	R4,O.EXP	;COMMON OUT, SET EXP TO WHATEVER
	CLRB	O.OP		;INDICATE FINAL OPERATION IS +
	MOV	#1,R2		;SET R2 TO INDICATE R4 IS REAL
	RETURN

40$:	MOV	R4,-(SP)	;MULTIPLY X 50, OP=-2  SAVE OLD R4
	CLR	R4		;12 BITS IN A PDP-8, MORE HERE
	MOV	#50,R2		;MULTIPLY!!!
50$:	ADD	O.EXP,R4
	DEC	R2
	BNE	50$		;NOT OPTIMIZED
	ADD	(SP)+,R4	;RECOVER R4 AND JUST RECOVER, INCOVER
	BR	30$

60$:	MOV	R4,R2		;COPY THE SHIFT COUNT
	MOV	O.EXP,R4	;GET VALUE TO SHIFT
	TST	R2		;LEFT OR RIGHT?
	BMI	80$		;RIGHT, GO DO IT
70$:	DEC	R2		;COUNT DOWN THE SHIFT
	BMI	30$		;DONE
	ASL	R4		;SHIFT THE VALUE
	BR	70$		;AND TRY FOR MORE

80$:	ASR	R4		;SHIFT RIGHT
	INC	R2		;BUMP THE SHIFT COUNT
	BMI	80$		;NOT DONE
	BR	30$		;DONE

90$:	COM	O.EXP		;LOGICAL AND.  COMPLEMENT THE OLD
	BIC	O.EXP,R4	;DO THE AND
	BR	30$		;EXIT

	.WORD	90$		;-6 AMPERSAND
	.WORD	60$		;-4 EXCLAMATION
	.WORD	40$		;-2 STAR
100$:	.WORD	20$		;0 ADD
	.WORD	10$		;2 SUBTRACT

.SBTTL	GETNUM

; BUILD AN OCTAL NUMBER		JSR PC,GETNUM

; NEEDS AND RETURNS--
;  R0	NON-OCTAL TERMINATING CHARACTER
;  R2	OCTAL CHARACTER COUNT
;  R4	OCTAL NUMBER THAT I GOT, YOU GET

INPOCT:				;HERE IS THE SPECIAL FORM OCTAL
GETNUM:	TST	(PC)+		;C=0 FOR RADIX 8
INPDEC:	SEC			;C=1 FOR RADIX 10.
	MOV	#4,-(SP)	;PUT A 4 ON THE STACK
	ADC	(SP)		;MAKE IT 5 IF DECIMAL
	ASL	(SP)		;STACK HAS 8. OR 10.
	CLR	R2		;NEW R2 AND R4
	CLR	R4
	CALL	O.GET		;CHECK FOR LEADING MINUS SIGN
	CMPB	R0,#'-		;IS THERE ONE?
	BNE	20$		;NO
	BIS	#100000,(SP)	;YES, SET FLAG (SP)
10$:	CALL	O.GET		;GET 1 CHARACTER
20$:	SUB	#'0,R0		;REDUCE THE NUMBER
	CMPB	R0,(SP)		;IN RANGE OF RADIX?
	BHIS	40$		;NO, EXIT NOW
	ASL	R4		;SHIFT FOR * 8.
	CMPB	(SP),#10.	;DECIMAL?
	BNE	30$		;NO
	ADD	R4,R0		;YES, ADD IN 2*OLD
30$:	ASL	R4
	ASL	R4		;MPY BY 10 TO MAKE ROOM
	ADD	R0,R4		;PLANT LO PLACE
	INC	R2		;ACCOUNT FOR NEW ONE
	BR	10$		;NEXT ONE OR OTHER

40$:	ADD	#'0,R0		;FIX R0
	TST	(SP)+		;DUMP THE RADIX
	BPL	50$		;NO LEADING -
	NEG	R4		;NEGATE IT
50$:	SEC			;C=1 INDICATING WE GOT A CHARACTER
	RETURN

.SBTTL	LOOKUP

; SCAN A LIST OF CHARACTERS	JSR R5,LOOKUP

; CALL--
;		R0	HAS THE CHARACTER
;	CALL	LOOKUP,R5	;THAT IS IT
;	 +	LIST TO USE, 00 BYTE IS END OF LIST

; RETURNS AT CALL + 2 WITH--
;  R0	STILL HAS CHARACTER
;  R1	HAS INDEX X2 OF FOUND CHARACTER IF C=0
; C=1	CHARACTER WAS NOT FOUND

LOOKUP:	MOV	(R5),R1		;GET LIST START
10$:	CMPB	R0,(R1)		;IS THIS THE ONE
	BNE	20$		;RIGHT IT WASN'T
	SUB	(R5)+,R1	;COMPUTE INDEX AND RETURN
	ASL	R1		;DO THIS FOR EVERBODY, C=0
	RETURN	R5		;RETURN WITH C=0

20$:	TSTB	(R1)+		;CHECK FOR END OF LIST
	BNE	10$		;IF NOT LOOK AT NEXT ITEM
	TST	(R5)+		;END, AVOID ILLEGAL INSTRUCTION
	SEC			;SECURITY EXCHANGE COMMISION
	RETURN	R5		;SECURITY ELSEWHERE

; SPECIAL INPUT PROCESSORS

.ENABL	LSB

INPRAD:	CLR	R4		;CLEAR R4 FOR RAD50 INPUT
	CALL	10$		;CALL THE BELOW 3 TIMES
	MOV	PC,-(SP)	;CALL IT AGAIN
10$:	CALL	O.GET		;GET A RAD50 CHARACTER
	MOV	R0,R2		;COPY IT
	SUB	#'9+1,R0	;REDUCE IT NUMERIC
	ADD	#'9+1-'0,R0	;IS IT A DIGIT?
	BCC	30$		;NO
	ADD	#30.,R0		;YES, MAKE IT RAD50
20$:	ASL	R4		;MULTIPLY BY 50
	ASL	R4
	ASL	R4
	ADD	R4,R0		;ADD TO ADDER
	ASL	R4
	ASL	R4
	ADD	R0,R4		;DONE
	CLC			;SET FLAG FOR NEEDING CHARACTER
	RETURN

30$:	SUB	#'Z+1-'0,R0	;CHECK FOR ALPHABETIC
	ADD	#'Z+1-'A,R0	;IS IT A LETTER?
	BCC	40$		;NO
	INC	R0		;YES, RANGE IT
	BR	20$		;AND SHIFT AND ADD

40$:	MOV	#70$,R0		;CHECK SPECIAL CHARACTER TABLE
50$:	CMPB	R2,(R0)+	;IS THIS IT?
	BNE	60$		;NO
	MOVB	(R0),R0		;YES, GET VALUE
	BR	20$		;AND USE IT

60$:	INC	R0		;SKIP VALUE
	TSTB	(R0)		;DONE?
	BNE	50$		;NO
	JMP	O.ERR		;YES, NOT A VALID RAD50 CHAR

70$:	.BYTE	'$,^R  $,'.,^R  .,'+,^R   ,'?,35,0
	.EVEN

INPBYT:	CALL	O.GET		;GET A BYTE
	CLR	R4		;CLEAR FOR BISB
	BR	80$		;DO IT AND RETURN

INPASC:	CALL	INPBYT		;GET ONE BYTE
	CALL	O.GET		;GET ANOTHER IN R4
	SWAB	R0		;SWAB THE SECOND BYTE
80$:	BIS	R0,R4		;SET IT
	RETURN			;RETURN WITH C=0

.DSABL	LSB

.SBTTL	GETCAD - Get contents of current address

;GET CONTENTS OF ADDRESS IN THE MODE		JSR PC,GETCAD

;NEEDS--
;R0		THE MODE 1=BYTE, 2=WORD
;O.CAD		THE ADDRESS
;O.DEVI		THE DEVICE CODE

;RETURNS--
;R0		HAS THE DATA YOU ASKED FOR

.ENABL	LSB

GETCAD:	CALL	COMADD		;FIND OUT ABOUT THE ADDRESS AND PLACE
	BCC	10$		;NOT ON THE DISK
	CALL	REDISK		;READ THE DISK DUMMY

10$:	MOV	O.WND5,@O.KIA5	;TURN ON WINDOWED MAPPING IF NEEDED

	ASR	R0		;PUSH BW FLAG INTO CARRY BIT
	BCC	20$		;2 WON'T FIT SO IS WORD
	MOVB	(R3),R0		;ACCESS BYTE
	BR	30$

20$:	MOV	(R3),R0		;ACCESS WORD

30$:	MOV	O.APR5,@O.KIA5	;RESTORE THE OLD APR5 MAP IF ANY

40$:	RTS	PC		;Ahh! - RETURN

.SBTTL	PUTCAD	- Put to current address

;PUT R4 INTO ADDRESS IN THE MODE		JSR PC,PUTCAD

;NEEDS--
;R2		CONTENT FLAG, 0 FOR NONE, ELSE R4 IS GOLD
;R4		THE DATA
;O.BW		THE MODE FLAG, IF 0 THEN NO LOCATION OPEN

PUTCAD:	TST	R2		;CHECK FOR TYPED VALUE
	BEQ	40$		;NO DATA NO DODO
	MOV	O.BW,R0		;PICK UP MODE AN CC'S
	BEQ	40$		;NOT OPEN NOT STORED
	CALL	COMADD		;HOW ABOUT THE ADDRESSES
	MOV	O.WND5,@O.KIA5	;SET UP APR5 MAP IF NEEDED
	BIT	#177776,R0	;CHECK MODE
	BNE	50$		;WORD MODE
	MOVB	R4,(R3)		;BYTE MODE
	BR	60$		;BRANCH MODE

50$:	MOV	R4,(R3)		;WORD MODE

60$:	MOV	O.APR5,@O.KIA5	;RESTORE THE APR5 WINDOW
	BCC	40$		;CORE MODE

	;CALLR	WRDISK		;WRITE THE DISK MODE

.DSABL	LSB

;READ THE--WRITE THE-- DISK		JSR PC,REDISK/WRDISK

;R5		HAS THE 256. WORD SEGMENT NUMBER SAVED THERE
;R2		HAS THE INDEX TO THE SPECIFIC DEVICE FOR UNIT
;			0-16 (OR 10-17) FOR RF DISK
;			20-36 (OR 20-27) FOR RK DISK
;			40-56 (OR 30-37) FOR RP DISK
;R1		WORKING REGISTER, MAY BE USED

;ALL OTHER REGISTERS MUST BE SAVED

	MOV	#WFUN,-(SP)	;SAY WE ARE GOING TO WRITE
	BR	DISKGO		;BRANCH TO TAG DISKGO

;READ THE DISK'S ENTRY

REDISK:	CMP	O.BUFF,OLDBUF	;SEE IF A NEW BUFFER
	BNE	10$		;GOTTA DO A NEW READ INTO NEW BUFFER
	CMP	R5,OLDSEG	;SEE IF WE NEED A REED
	BNE	10$		;NEED A REED
	CMP	O.UNIT-20(R2),OLDUNT ;CHECK THE UNIT!!
	BEQ	DIS099		;AVOID A VOID
10$:	MOV	#RFUN,-(SP)	;A TRY AT A READ

;COMMON DISK SPLIT UP

DISKGO:	MOV	O.BUFF,OLDBUF	;FLAG THIS BUFFER
	MOV	R5,OLDSEG	;THE OLD SEGMENT
	MOV	O.UNIT-20(R2),OLDUNT ;DITTO UNIT
	CMP	#20,R2		;CHECK OUT THE TYPE
	BLE	DIS100		;RK OR RP GETS IT FOR NOW

;DO THE RF DISK HOUSE KEEPING

	JSR	R5,DIBUSY	;GO WAIT AND CLEAR THE DISK
	 +	DCS		;MAGIC
	 +	RFCFUN		;MAGIC
	MOV	#DAE,R2		;GET CONTROL ADDRESS, EXTEND AND ERROR
	CLR	(R2)		;RESET THE ERRORS, ETC.
	SWAB	R5		;MPY BY 256 THE EXTEND ADDRESS
	MOVB	R5,(R2)		;SET THE EXTENDED ADDRESS
	CLRB	R5		;CLEAR OUT THE EXTENDED STUFF
	BR	DIS050		;GO DO COMMON DISK INITIATE


;RK DISK HANDLING ROUTINE

DIS100:	CMP	R2,#40		;RP03 OR BIGGER ?
	BGE	DIS200		;YUP
	JSR	R5,DIBUSY	;CHECK FOR RK BUSY
	 +	RKCS		;WHERE TO CHECK
	 +	RKCFUN		;CLEAR CONTROLLER FUNCTION

;DISK IS NOW NOT BUSY AND WE ARE HIGH ON PR7

	MOV	O.UNIT-20(R2),R2	;GET DISK UNIT IN LO 3
	CLC			;ALL 17 BITS M.B. KNOWN
	ROR	R2		;SEVENTEEN BITS!!!!!
	ROR	R2
	ROR	R2
	ROR	R2		;UNIT IN BITS 15-13
	BR	DIS122

DIS120:	ADD	#20,R2		;COUNT SURFACE AND CYLINDER
DIS122:	SUB	#14,R5		;CHECK FOR NEW SURFACE
	BGE	DIS120		;DIVIDE BY 12, -REMAIN IS SECTOR
	ADD	#14,R5		;NOT REALLY - REMAIN
	ADD	R2,R5		;R5 HAS THE RK ADDRESS
	MOV	#RKDA+2,R2	;PRETEND DUE TO EXTENDED ADDRESS

;COMMON DISK INITIATE OPERATION

DIS050:	MOV	R5,-(R2)	;SET THE LOW DISK ADDRESS
	MOV	R0,-(SP)	;SAVE R0
	MOV	O.BUFF,R0	;GET CORE ADDRESS
	CMP	R0,#ODTBUF	;STD. ADDRESS?
	BNE	1$		;NOPE, SO USE IT AS IS
	TSTB	ODT+15		;USING RELOCATION?
	BEQ	1$		;NOPE
	MOV	ODT+12,R0	;YEP, SO GET LOW ADDRESS
	ADD	#ODTBUF-ODT,R0	;AND ADD IN STD. BASE ADDRESS
	BISB	ODT+14,2(SP)	;OR IN XMEM BITS (INTO FUNCTION)
1$:	MOV	R0,-(R2)	;SET CORE ADDRESS
	MOV	(SP)+,R0	;RESTORE R0
	MOV	#-400,-(R2)	;WORD COUNT
	MOV	(SP)+,-(R2)	;SET THE FUNCTION
	INC	(R2)		;GIVE ER DA GO
DIS090:	TSTB	(R2)		;AWAIT
	BPL	DIS090		;AWAIT TILL DONE
	MOVB	R1,@#PS		;RESET CALLING PS, CAN BE TROUBLE HERE??
	TST	(R2)		;SEE HOW WELL THEY DID IT
	BMI	DIS999		;GO TO USED USER
DIS099:	RTS	PC

DIS200:	JSR	R5,DIBUSY	;CHECK FOR RP BUSY
	+	RPCS		;WHERE TO CHECK
	+	RPCFUN		;RP CONTROLLER CLEAR
	MOVB	O.UNIT-20(R2),1(SP);UNIT + FUNCTION ON STACK
	BIC	#4000,(SP)	;MAKE FOR REAL UNIT (0-7)
	MOV	R1,-(SP)	;NEED ONE TO WORK WITH
	CLR	-(SP)		;CLEAR CYLINDER ADDRESS
	CLR	-(SP)		;RP03'S NEED 17 BIT SEGMENT #
	BIT	#10,O.UNIT-20(R2);TOP HALF OF RP03 ?
	BEQ	5$		;NOPE LOW HALF OR RP02
	ADD	#116100,R5	;OFFSET R5 BY 40,000 SEGMENTS
	ADC	(SP)		;WHICH MIGHT CARRY
5$:	MOV	#256.,R1	;ADD FACTOR
	MOV	#256.*200.,R2	;SUBTRACT FACTOR
	SUB	R2,R5		;SO SUBTRACT IT
	SBC	(SP)+		;DISPENSE WITH 17 BIT CRAP
	BMI	30$		;THERE WASN'T ANY 17TH BIT ANYHOW
10$:	ADD	R1,(SP)		;BUILD CYLINDER NUMBER
	BR	35$		;AND SHIFT
20$:	SUB	R2,R5		;SUBTRACT
	BHIS	10$		;HANG IN THERE
30$:	ADD	R2,R5		;CORRECT FOR OVERFLOW
35$:	CLC			;WANT NON-SIGNED SHIFTS
	ROR	R2		;WHEN JUGGLING FACTORS
	CLC			;
	ROR	R1		;
	BNE	20$		;UNTIL MEDIUM WELL
				;CYLINDER NUMBER (0-399) NOW ON STACK
	CLR	-(SP)		;CLEAR PLACE TO ACCUMULATE TRACK
	MOV	#10.,R2		;NEW SUBTRACT FACTOR (10 SECTORS/TRACK)
	BR	50$		;NO INC FIRST TIME THRU
40$:	INC	(SP)		;ACCUMULATE TRACK
50$:	SUB	R2,R5		;THE HARD WAY AGAIN
	BPL	40$		;PATIENCE
	ADD	R2,R5		;CORRECT OVERFLOW. R5 NOW = SECTOR
	SWAB	(SP)		;TRACK INTO HIGH BYTE
	MOVB	R5,(SP)		;SECTOR INTO LOW
	MOV	#RPDA,R2	;RP DISK ADDRESS ADDRESS TO R2
	MOV	(SP)+,(R2)	;SET TRACK AND SECTOR
	MOV	(SP)+,R5	;CYLINDER NUMBER TO R5
	MOV	(SP)+,R1	;RESTORE R1
	BR	DIS050		;DO COMMON DISK INITIATE

;CHECK FOR BUSY DISK, SET PRIORITY AND CLEAR DISK

;WORD FOLLOWING CALL HAS THE DEVICE STATUS REGISTER ADDRESS
;AND THE NEXT WORD HAS THE CLEAR FUNCTION FOR DEVICE
;R1	HAS ADDRESS IF DISK STATUS ON ENTRY
;R1	HAS PS AT CALL ON EXIT

DIBUSY:	MOV	(R5)+,R1	;SET THE DEVICE'S ADDRESS
DIB000:	MOV	@#PS,-(SP)	;SAVE THE CALLING STATUS
DIB001:	TSTB	(R1)		;SET ABOUT HOW BUSY
	BPL	DIB001		;BUSY ON NOT BUSY THAT IS IT
	MOVB	#O.STM,@#PS	;SPL TO 7, HIGH AS IT CAN GET
	TSTB	(R1)		;SEE IF BUSY AGAIN
	BMI	DIB005		;NOT BUSY SO ALL IS OKAY
	MOVB	(SP)+,@#PS	;COME DOWN TO CHECK
	BR	DIB000		;START FROM THE TOP

DIB005:	MOV	(R5)+,(R1)	;DO THE CLEAR
	INC	(R1)		;GO
DIB007:	TSTB	(R1)		;THIS AGAIN
	BPL	DIB007
	MOV	(SP)+,R1	;CALLING PS INTO R1
	RTS	R5		;SPLIT

;SEE THEM RUN, DISK ERROR ROUTINE

DIS999:	JMP	O.ERR		;ERROR RE-TRY ROUTINE IS THE USER!!

;RESET TO THE CONSOLE DEVICE, ALSO ANY DEVICE	JSR PC,SETTTY
;						JSR PC,SETCON

SETCON:	MOV	O.TKS,R4	;SET UP FOR CONSOLE RESET
SETTTY:	MOV	#O.TKS,R3	;NOT ALWAYS A NO-OP!!
	MOV	#4,R2		;FOUR VECTORS, USING THE LP11 GETS
10$:	MOV	R4,(R3)+	;THE LAST TWO WHAMMO'ED
	TST	(R4)+		;NEXT VECTOR
	DEC	R2
	BNE	10$		;REALLY NEXT VECTOR TO DO
	RETURN


.SBTTL	Set up Memory Management

; SET UP THE MMU MAPPING REGISTERS IF THE MMU IS ON

SETMMU:	MOV	#5*2,O.MAPM	;Set initial mapper mode (No MMU)
	MOV	#50$,R3		;POINT TO TABLE FOR NON-MMU

	MOV	#4,R4		;INTERCEPT TRAPS TO 4
	MOV	(R4),-(SP)	;SAVE VECTOR @ 4
	MOV	#30$,(R4)+	; AND SET IT TO TRAP TO US
	MOV	(R4),-(SP)	;SAVE PS OF TRAP @ 4
	MOV	@#PS,(R4)+	; AND SET OUR OWN
	BIT	#1,@#MMUSR0	;IS THE MMU ON?
	BEQ	40$		;NO, BUT IT EXISTS.  GO ACT AS IF NO MMU

	MOV	#4*2,O.MAPM	;Set mapper to K type

	MOV	#KISDR0,R3	;YES, SAVE THE DESCRIPTOR REGISTERS
	MOV	#O.KIDR,R5
10$:	MOV	(R3),(R5)+	;SAVE A DESCRIPTOR
	MOV	(PC)+,(R3)+ 	;MAKE IT R/W AND 4K
	.BYTE	4!2,128.-1
	CMP	R3,#KISDR0+<8.*2> ;DONE?
	BLO	10$		;NO
;
;	Save some registers for the mapper
;

	MOV	#KISAR0,R3	;Save the I space APR's too
	MOV	#O.KIAR,R5
15$:	MOV	(R3)+,(R5)+
	CMP	R3,#KISAR0+<8.*2>	;Done
	BLO	15$
	MOV	O.APR6,@#O.KIAR+<6*2>	;Patch in correct APR6 value

	MOV	#UISAR0,R3	;Save the User I space regs
	MOV	#O.UIAR,R5	;To here
20$:	MOV	(R3)+,(R5)+
	CMP	R3,#UISAR0+<8.*2>
	BLO	20$		;Loop till done

; Get and save ODT's running APR6 for peeking at self

	MOV	@#KISAR0+<6*2>,O.ODR6	;Save ODT's APR6

;
; Now check for D space capabilities
; and action accordingly
;

	MOV	#130$,@#4	;Set up an intercept

	BIT	#4,@#MMUSR3	;Do we have D space on OR no MMUSR3 ?
	BEQ	140$		;No, but we could have
	MOV	@#MMUSR3,O.MSR3	;Save away the status
	BIC	#4,@#MMUSR3	;and turn off D for now

	MOV	#-1,O.DSP	;Say, 'By JOve, we've got it!'
	MOV	#0*2,O.MAPM	;Set-up default prompt to I

	MOV	#KDSAR0,R3	;Set up to move D space APRs
	MOV	#O.KDAR,R5	;to here

110$:	MOV	(R3)+,(R5)+	;Move it away
	CMP	R3,#KDSAR0+<8.*2>	; Is it done?
	BLO	110$		;No - so around again
	MOV	O.DPR6,@#O.KDAR+<6*2>	;Patch correct D APR6

	BR	160$		;all done

130$:	CMP	(SP)+,(SP)+	;Clean-up the stack from trap
140$:	CLR	O.DSP		;Oh dear - it's not on

160$:	MOV	#60$,R3		;SET UP TABLE FOR ACTUAL MMU
	BR	40$		;AND GO MOVE IT

30$:	CMP	(SP)+,(SP)+	;WE TRAPPED! NO MMU HERE, so clean-up stack

40$:	MOV	(SP)+,-(R4)	;RESTORE VECTOR AT 4
	MOV	(SP)+,-(R4)

	MOV	#O.KIA6,R4	;POINT TO MMU CONTROL TABLE and move data
	MOV	(R3)+,(R4)+	;ADDRESS OF KISAR6 OR JUNK
	MOV	(R3)+,(R4)+	;ADDRESS OF KISAR5 OR JUNK
	MOV	(R3)+,(R4)+	;OFFSET FROM APR5 TO APR6 WINDOW OR 0
	MOV	(R3)+,(R4)+	;Address of KDSAR6 or JUNK

	RETURN			;From whence we came

50$:	.WORD	O.JUNK,O.JUNK,0,O.JUNK	;TABLE IF NO MMU

60$:	.WORD	KISAR6,KISAR5,140000-120000,KDSAR6 ;TABLE IF MMU

	.DSABL	LSB

.SBTTL	UTILITIES - TELETYPE I/O ROUTINES

.ENABL	LSB

; TYPE BY ADDING TO R0

O.TYPA:	ADD	(R5)+,R0	;ADD BIAS
	BR	10$		;DO IT

; TYPE A CONSTANT IN LINE

O.TYPC:	MOV	(R5)+,R0	;GET CHARACTERS
10$:	CALL	O.TYPE		;TYPE IT
	RETURN	R5

; TYPE A DIGIT

O.TYPD:	BIC	#^C<7>,R0	;ISOLATE DIGIT BITS
O.TYPN:	ADD	#'0,R0		;MAKE IT ASCII
	BR	O.FTYP		;TYPE IT

; TYPE CARRIAGE RETURN LINE FEED			JSR PC,O.CRLF

O.CRLF:	MOV	(PC)+,R0
	.BYTE	015,012

;TYPE TWO CHARS IN R0 PLEASE			JSR PC,O.TYPE

O.TYPE:	CALL	O.FTYP		;DO ONE
	SWAB	R0
	BEQ	O.FKBR		;NO MORE

;TYPE ONLY ONE CHARACTER IN R0			JSR PC,O.FTYP

O.FTYP:	CALL	O.FKBR		;DO THIS WHILE WAITING
	TST	O.XOFF		;X-OFF FLAG SET?
	BNE	O.FTYP		;IF SO, WAIT FOR IT TO GO OFF
	TSTB	@O.TPS
	BPL	O.FTYP
	CALL	O.TFIL		;SET IT

;INPUT CHARACTER BUFFERING ROUTINE		JSR PC,O.FKBR

O.FKBR:	TSTB	@O.TKS		;SEE WHAT'S UP CHUCK
	BPL	60$		;NOTHING IS UP
	MOV	R0,-(SP)	;SAVE R0 FOR OTHERS
	MOVB	@O.TKB,-(SP)	;READ FROM THE TERMINAL
	BIC	#-177-1,(SP)	;TRIM OFF JUNK AND ANY PARITY, ETC.
	BEQ	50$		;NULL, JUNK IT
	CMP	(SP),#'A+40	;COULD IT BE LOWER CASE?
	BLO	20$		;NEVER
	CMP	(SP),#'Z+40	;MIGHT BE...
	BHI	20$		;BUT IS ISN'T
	BIC	#40,(SP)	;ELSE IT IS BUT ISN'T ANYMORE
20$:	CMP	(SP),#177	;A RUBOUT??
	BEQ	70$		;YES, WE WILL QUICKLY PUNT
	CMP	(SP),#'S&37	;X-OFF?
	BNE	30$		;NO
	MOV	SP,O.XOFF	;YES, SET X-OFF FLAG
	BR	50$		;AND OTHERWISE IGNORE THE CHARACTER
30$:	CMP	(SP),#'Q&37	;X-ON?
	BNE	40$		;NO
	CLR	O.XOFF		;YES, CLEAR X-OFF FLAG
	BR	50$		;AND EXIT TO RESUME OUTPUT
40$:	MOVB	INP,R0		;UP CHUCK, PICK UP POINTER
	INC	R0		;SEE IF RING IS FULL
	BIC	#ROSIE,R0	;RING AROUND THE ROSIE
	CMPB	R0,OUP
	BEQ	50$		;FULL SO WAIT
	MOVB	INP,R0		;DO THIS AGAIN PLEASE
	MOVB	(SP),RING(R0)	;SAVE IT IN THE RING
	INC	R0		;BEGIN TO UPDATE POINTER
	BIC	#ROSIE,R0
	MOVB	R0,INP		;SAVE UPDATED ONE
50$:	TST	(SP)+		;JUNK THE CHARACTER NOW
	MOV	(SP)+,R0	;RESTORE THE SAVED R0
60$:	RTS	PC		;AND EXIT

70$:	JMP	O.ERR

.DSABL	LSB

;GENERAL CHARACTER INPUT ROUTINE		JSR PC,O.GET

.ENABL	LSB

10$:	CALL	O.FKBR		;KEEP LOADED, SLEEP POINT FOR MIMIC
20$:	CLR	O.GETP		;STOP ANY INDIRECT COMMANDS
O.GET:	MOV	O.GETP,R1	;GET INDIRECT COMMAND POINTER
	BEQ	30$		;NONE
	MOVB	(R1)+,R0	;ONE, GET A CHARACTER
	MOV	R1,O.GETP	; AND RESTORE UPDATED POINTER
	BR	40$		;GO CHECK THAT CHARACTER

30$:	MOVB	OUP,R1		;SEE IF WE ARE LOADED
	CMPB	INP,R1		;SEE IF CHARACTER FLAG IS HIGH
	BEQ	10$		;THIS IS THE GARDEN VARIETY WAIT LOOP
	MOVB	RING(R1),R0	;SNAG AND STASH CHARACTER
	INC	R1		;ACCOUNTING CRAP
	BIC	#ROSIE,R1	;RINGER
	MOVB	R1,OUP		;SAVE FOR LATER
40$:	TST	R0		;NULL ENITY?
	BEQ	20$		;IGNORE NOTHING AT ALL
	CMPB	R0,#012		;SEE IF A <LF>
	BEQ	60$		;IF SO SAVE THE PAPER
	CALL	LOOKUP,R5,<ALTTAB> ;SEE ABOUT ALL THOSE ALT MODE'S
	BCS	50$		;NOTTA CHANCE AT THE ALT
	MOVB	#'$,R0		;DOLLARS DESIGN
50$:	CALL	O.FTYP		;ECHO CHARACTER
	CMPB	#' ,R0
	BNE	60$		;NOTTA SPACE FOR A CHANCE
	MOVB	#'+,R0		;TURN IT INTO A PLUS FOR OUR SIDE
60$:	RETURN

.DSABL	LSB

O.TFIL:	MOVB	R0,@O.TPB	;REALLY SEND IT
	MOV	R1,-(SP)	;SAVE R1
	MOV	#I.FILL,R1
10$:	TSTB	(R1)
	BEQ	40$
	CMPB	R0,(R1)+
	BEQ	20$
	INC	R1
	BR	10$

20$:	MOVB	(R1),R1
	MOV	R0,-(SP)
30$:	TSTB	@O.TPS
	BPL	30$
	CLRB	@O.TPB
	DEC	R1
	BGT	30$
	MOV	(SP)+,R0
40$:	MOV	(SP)+,R1
	RETURN

.SBTTL	UTILITIES - PRETTY PRINTERS

;PRINT ADDRESS- RELOC, SYMBOLIC, DISK, OR ABSL	JSR PC.O.RORA

;R0	ADDRESS TO BE PRINTED
;O.DEVI	MODE FOR CORE OR DISK
;O.FORM	CORE ADDRESS FORMAT (0-RELOC  1-ABSOL)

;DISK		'DD,XXXXXX '
;REGISTER	'$R ' OR '$DDR '
;CORE		'D,XXXXXX ' OR 'XXXXXX '

O.RORA:	MOV	R0,-(SP)	;CALLING VALUE ONA TOPPA SATCK
	MOV	O.DEVI,R0	;DETERMINE TYPE OF ADDRESS GOING OUT
	BMI	10$		;NOT THE DISK
	ASR	R0		;DISK----- "DD,XXXXXX "
	ADD	#10,R0
	MOV	R0,-(SP)	;A SAVE FOR THE LO-DIGIT
	ASR	R0
	ASR	R0		;HIGH DIGIT TO LOW
	ASR	R0
	ADD	#'0,R0		;GOOD OLD ASCII CONVERT
	CALL	O.FTYP		;AND NOW TYPE IT
	MOV	(SP)+,R0	;GET HIGH DIGIT
	BIC	#177770,R0	;GET LOW MASKED
	BR	70$		;GO TYPE HIGH DIGIT AND COMMA

10$:   	TST	O.OF56		; Is MMU being used?		;009
	BEQ	15$		;NO - So could be in ODT	;009
	TST	O.MAPF		;Did we do mapping?		;009
	BNE	15$		;NO - So could be in ODT	;009
	CMP	O.WND5,O.ODR6	;Yes - Really come from ODT?	;009
	BNE	60$		; NO!!				;009
15$:	CMP	#INTBEG,(SP)
	BHI	60$		;BELOW FIRST NON-INDEXED
	CMP	#INTEND,(SP)
	BLO	60$		;ABOVE LAST NON-INDEXED
	CALL	O.TYPC,R5,<'$>	;PRINT THE DOLLAR SIGN
	CMP	#INTINX,(SP)
	BLOS	30$		;GO TO DO INDEXED
	MOV	(SP)+,R0	;NON-INDEXED REGISTER ----- "$R "
	SUB	#INTBEG,R0	;CLEANED UP STACK, GET OFFSET
	ASR	R0		;BYTE THAT WORD, WORD THAT BYTE
	MOVB	NIXMAP(R0),R0	;MAGIC CHARACTER FROM TABLE
20$:	BIS	(PC)+,R0
	.BYTE	000,' 		;CHARACTER PLUSSA BLANK
	JMP	O.TYPE		;NAME PLUS BLANK AND SPLIT

30$:	CLR	R1		;SEE WHICH SET OF TABLES WE GOT
40$:	CMP	INXTBL+2(R1),(SP)	;LOOK ON AHEAD TO FIND BEHIND
	BHI	50$		;R1 POINTS TO BASE OF SET
	TST	(R1)+		;THINK ABOUT THOSE DUMMY ENTRIES DUMMY
	BR	40$

50$:	SUB	INXTBL(R1),(SP)	;COMPUTE OFFSET IN WORDS FROM TABLE
	ASR	(SP)		; NOW BYTES
	MOV	(SP),R0		;GET THE INDEX NUMBER
	ASR	R0		;GET HIGH DIGIT BY SHIFTING
	ASR	R0
	ASR	R0
	CALL	O.TYPD		;TYPE AS A DIGIT
	MOV	(SP)+,R0	;GET LOW BITS
	CALL	O.TYPD		;TYPE AS A DIGIT
	ASR	R1
	MOVB	INXREG(R1),R0	;PICK UP THE REAL CHARACTER
	BR	20$		;GO PRINT REST OF IT

60$:	TST	O.FORM		;CORE ADDRESS SEE WHAT USER WANTS
	BNE	80$		;TYPE AS ABSOLUTE.
	MOV	(SP),R4		;RELOCATE ---- "R,XXXXXX "
	CALL	O.LOCA		;WE ALWAYS PICK, ODT KNOWS BEST
	BMI	80$		;BUT NOT ALL THE TIME
	MOV	R1,(SP)		;SET THE DISPLACEMENT
70$:	CALL	O.TYPA,R5,<"0,>	;DISK AND CORE
80$:	MOV	(SP)+,R0	;PRINT R0 AS A WORD
	;CALLR	O.CADW

;TYPE R0 AS BYTE OR WORD, TWO ENTRIES
;	FOR A WORD				JSR PC,O.CADW
;	FOR A BITE				JSR PC,O.CADB

.ENABL	LSB

O.CADW:	MOV	R0,O.QUAN	;SET THE FAMOUS QUANTITY VALUE
	MOV	#6,R3		;# OF DIGITS
	MOV	#1-3,R4		;# OF BITS FIRST-3
	BR	10$		;DO THE COMMON THING

O.CADB:	CLR	O.QUAN		;SET FOR ALL OF QUAN A BYTE
	MOVB	R0,O.QUAN	;SET THE QUANTITY THING AGAIN
	MOV	#3,R3		;THERE ARE THREE DIGITS
	MOV	#2-3,R4		;AND ONLY TWO BITS
	SWAB	R0		;SWITCH ENDS
10$:	TST	O.PRNT		;WHAT TYPE OF PRINTING?
	BEQ	80$		;OCTAL
	INC	R4		;DECIMAL, BYTE MODE?? (2-3=1)
	BNE	20$		;NO, WORD MODE
	CLRB	R0		;YES, BYTE MODE, CORRECT
	SWAB	R0		; THE VALUE
20$:	MOV	R0,R3		;SAVE THE VALUE
	TST	O.PRNT		;SIGNED?
	BGT	40$		;NO, UNSIGNED
	TST	R3		;IS THE VALUE NEGATIVE?
	BMI	30$		;IT IS NEGATIVE
	TST	R4		;POSITIVE AS A WORD, BUT WHAT MODE?
	BNE	40$		;WORD MODE, O.K.
	MOVB	R0,R3		;BYTE MODE, SIGN EXTEND VALUE
	BPL	40$		;STILL POSITIVE
30$:	MOV	#'-,R0		;SET AND
	CALL	O.FTYP		; PRINT THE MINUS SIGN
	NEG	R3		;  THEN CORRECT THE VALUE
40$:	MOV	#120$,R4	;GET THE TABLE POINTER
	MOV	#-1,-(SP)	;START WITH LEADING SPACES
50$:	CLR	R0		;INIT THE ANSWER
60$:	INC	R0		;COUNT TIMES
	SUB	(R4),R3		; THROUGH
	BHIS	60$		;  THIS LOOP
	ADD	(R4)+,R3	;CORRECT MAIN VALUE
	ADD	(SP),R0		; AND ANSWER
	BLE	70$		;A LEADING SPACE
	MOV	#20-1!100000,(SP) ;REAL DIGIT, START KEEPING DIGITS
	ADD	#20,R0		; INCLUDING THIS ONE
70$:	ADD	#40,R0		;FORM CHARACTER
	CALL	O.FTYP		; AND TYPE IT
	TST	(R4)		;MORE?
	BNE	50$		;YES, LOOP
	MOV	R3,R0		;GET THE LAST PLACE (UNITS)
	CALL	O.TYPN		; AND TYPE AS A NUMBER
	MOV	#'.,R0		;SET TRAILING .
	CALL	O.FTYP		; AND TYPE IT AS CUE
	BR	110$		;GO EXIT

80$:	MOV	R0,-(SP)	;SAVE R0
90$:	ADD	#3,R4		;COMPUTE THE NUMBER OF BITS TO DO
	CLR	R0
100$:	ROL	(SP)		;GET A BIT
	ROL	R0		;STORE IT AWAY
	DEC	R4		;DECREMENT COUNTER
	BGT	100$		;LOOP IF MORE BITS NEEDED
	CALL	O.TYPD		;TYPE IT AS A DIGIT
	DEC	R3		;SEE IF MORE DIGITS TO DO
	BGT	90$		;LOOP IF SO
110$:	TST	(SP)+		;GET RID OF JUNK 
O.TYPS:	MOVB	#' ,R0		;SET UP FOR TRAILING SPACE
	JMP	O.FTYP

120$:	.WORD	10000.,1000.,100.,10.,0

.DSABL	LSB

;TYPE CONTENTS OF WORD IN FORMAT	JSR PC,@TYFORM(R1)

;R0		WORD OR BYTE TO BE TYPED, RHJ
;R1		FORMAT CODE,	-0 BYTE OCTAL
;				-2 WORD OCTAL
;				-4 BYTE ANSII
;				-6 WORD ANSII
;				-10 RADIX 50 / MODULO 40

TYFORM:	+	O.CADB	;BYTE OCTAL
	+	O.CADW	;WORD OCTAL
	+	30$	;BYTE ANSII
	+	20$	;WORD ANSII
	+	10$	;RADIX 50

;MODULO 40, RADIX 50

10$:	MOV	#O.ALFA,R1	;SET OUTPUT DATA ADDRESS
	CALL	UNPA00		;R0 TO RADIX 50
	MOV	#O.ALFA,R1
	MOVB	(R1)+,R0	;GET A CHARACTER, #1
	CALL	O.FTYP
	MOV	(R1),R0		;GET CHARS #2 AND #3

;WORD ANSII

20$:	CALL	O.FTYP		;TYPE BYTE IN R0
	SWAB	R0		;SWAP EM AND TYPE IT

;BYTE ANSII

30$:	CALL	O.FTYP		;TYPE OF BYTE IN R0
	BR	O.TYPS		;ALSO SAVE SPACE

;SELECT RELOCATION REGISTER			JSR PC,O.LOC

;O.CAD		ADDRESS TO USE IN SELECTION

;RETURNS--
;R0				REGISTER NUMBER FOUND, -1 IF NONE FOUND
;R1				DISTANCE, RELOCATION FACTOR

;SUBROUTINE TO LOCATE RELOCATION REGISTER NEAREST BUT STILL 
;BELOW THE ADDRESS IN O.CAD.  RETURNS WITH THE REGISTER 
;NUMBER IN R0, AND WITH THE DISTANCE BETWEEN THE REGISTER 
;AND (O.CAD) IN R1
;IF NO GOOD RELOC. REG. FOUND, R0 WILL = -1

O.LOC:	MOV	O.CAD,R4	;SET UP CAD DATA
O.LOCA:	CLR	R0
	MOV	#-1,-(SP)	;INITIALIZE RELOC. REG. INDEX
	MOV	(SP),R1		;INITIALIZE DISTANCE TO A HIGH VALUE
10$:	CMP	R0,#O.RLR	;ARE WE DONE COMPARING?
	BHI	30$		;BRANCH IF DONE
	CMP	O.RELT(R0),R4	;IS CURR. RELOC. BIAS > (R4)?
	BHI	20$		;IF SO, BRANCH -- DON'T SUBTRACT, GET NEXT
	MOV	R4,R2		;OTHERWISE TAKE THE DIFFERENCE
	SUB	O.RELT(R0),R2	;OF CURR. RELOC. REG. AND O.CAD
	CMP	R1,R2		;IS THE RESULT THE SMALLEST SO FAR?
	BHI	40$		;BRANCH IF YES (UNSIGNED CONDITIONAL)
20$:	TST	(R0)+		;OTHERWISE, BUMP R0 FOR NEXT RELOC. REG.
	BR	10$		;LOOP BACK FOR NEXT COMPARISON

30$:	MOV	(SP)+,R0	;PUT REG.# IN R0
	RETURN			;JOB OVER, RETURN

40$:	MOV	R2,R1		;REMEMBER SMALLEST DIFFERENCE IN O.XXY
	ASR	R0		;AND ASSOCIATED REGISTER NUMBER
	MOV	R0,(SP)		; IN (SP)
	ASL	R0		;RESTORE R0 TO ORIGINAL VALUE
	BR	20$		;GO FO NEXT COMPARISON.

;	MOD40 UNPACK - ENTERED VIA JSR PC,UNPA00
;
;	INPUT:	R0= MOD40 NUMBER (1 WORD)
;		R1=ADR OF ASCII STRING (3 BYTES)
;
;	OUTPUT:	R1 POINTS ONE PAST LAST GENERATED CHARACTER
;
;	IF N IS THE MOD40 NUMBER, THEN
;		N=C1*50 ^ 2+C2*50+C3
;	THUS, N/50^2 IS C1 AND THE REMAINDER IS C2*50+C3
;	THE REMAINDER IS DIVIDED BY 50 TO GET C2 ETC.
;
UNPA00:	MOV	#-3,R5		;MINOR LOOP COUNT
	MOV	#COEFF,R2	;PTR TO COEFFICIENT TABLE
10$:	CLR	R3		;0 QUOTIENT
;	DIVIDE BY COEFFICIENTS
20$:	CMP	R0,(R2)		;DONE WITH DIVIDE?
	BLO	30$	;YES
	SUB	(R2),R0		;NO-SUBTRACT COEFF.
	INC	R3		;ADD 1 TO QUOTIENT
	BR	20$
;	DIVIDE DONE.  QUOT IN R3, REMAINDER IN R0
;	CONVERT TO AN ASCII CHARACTER
30$:	TSTB	R3
	BEQ	40$		;"BLANK"
	CMPB	R3,#33
	BEQ	60$		;"$"
	BGT	50$		;"." OR "0-9"
	ADD	#40,R3		;"A-Z"
40$:	ADD	#16,R3
50$:	ADD	#11,R3
60$:	ADD	#11,R3
	MOVB	R3,(R1)+	;STORE CHARACTER
	TST	(R2)+		;ADVANCE TO NEXT COEFF.
	INC	R5		;DONE 3 CHARS?
	BLT	10$		;NO-DO MORE
	RTS	PC

;COEFFICIENT TABLE

COEFF:	.WORD	+1600.,+40.,+1.		;40.^2,40.^1,40.^0

ENDODT=.-2		;LAST LOCATION USED
SIZODT=ENDODT-ODT+2	;SIZE OF ODT CODE AND DATA IN BITES (4kw = 20000 )

.END	O.ODT

